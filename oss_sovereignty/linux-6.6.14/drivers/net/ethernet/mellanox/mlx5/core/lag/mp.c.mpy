{
  "module_name": "mp.c",
  "hash_id": "b65647f706caf9d8c7c7cd30fc3512d3c010ee295aae522c56ac9400d58cfee8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lag/mp.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <net/nexthop.h>\n#include \"lag/lag.h\"\n#include \"lag/mp.h\"\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"lib/events.h\"\n\nstatic bool __mlx5_lag_is_multipath(struct mlx5_lag *ldev)\n{\n\treturn ldev->mode == MLX5_LAG_MODE_MULTIPATH;\n}\n\n#define MLX5_LAG_MULTIPATH_OFFLOADS_SUPPORTED_PORTS 2\nstatic bool mlx5_lag_multipath_check_prereq(struct mlx5_lag *ldev)\n{\n\tif (!mlx5_lag_is_ready(ldev))\n\t\treturn false;\n\n\tif (__mlx5_lag_is_active(ldev) && !__mlx5_lag_is_multipath(ldev))\n\t\treturn false;\n\n\tif (ldev->ports > MLX5_LAG_MULTIPATH_OFFLOADS_SUPPORTED_PORTS)\n\t\treturn false;\n\n\treturn mlx5_esw_multipath_prereq(ldev->pf[MLX5_LAG_P1].dev,\n\t\t\t\t\t ldev->pf[MLX5_LAG_P2].dev);\n}\n\nbool mlx5_lag_is_multipath(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_lag *ldev = mlx5_lag_dev(dev);\n\n\treturn ldev && __mlx5_lag_is_multipath(ldev);\n}\n\n \nstatic void mlx5_lag_set_port_affinity(struct mlx5_lag *ldev,\n\t\t\t\t       enum mlx5_lag_port_affinity port)\n{\n\tstruct lag_tracker tracker = {};\n\n\tif (!__mlx5_lag_is_multipath(ldev))\n\t\treturn;\n\n\tswitch (port) {\n\tcase MLX5_LAG_NORMAL_AFFINITY:\n\t\ttracker.netdev_state[MLX5_LAG_P1].tx_enabled = true;\n\t\ttracker.netdev_state[MLX5_LAG_P2].tx_enabled = true;\n\t\ttracker.netdev_state[MLX5_LAG_P1].link_up = true;\n\t\ttracker.netdev_state[MLX5_LAG_P2].link_up = true;\n\t\tbreak;\n\tcase MLX5_LAG_P1_AFFINITY:\n\t\ttracker.netdev_state[MLX5_LAG_P1].tx_enabled = true;\n\t\ttracker.netdev_state[MLX5_LAG_P1].link_up = true;\n\t\ttracker.netdev_state[MLX5_LAG_P2].tx_enabled = false;\n\t\ttracker.netdev_state[MLX5_LAG_P2].link_up = false;\n\t\tbreak;\n\tcase MLX5_LAG_P2_AFFINITY:\n\t\ttracker.netdev_state[MLX5_LAG_P1].tx_enabled = false;\n\t\ttracker.netdev_state[MLX5_LAG_P1].link_up = false;\n\t\ttracker.netdev_state[MLX5_LAG_P2].tx_enabled = true;\n\t\ttracker.netdev_state[MLX5_LAG_P2].link_up = true;\n\t\tbreak;\n\tdefault:\n\t\tmlx5_core_warn(ldev->pf[MLX5_LAG_P1].dev,\n\t\t\t       \"Invalid affinity port %d\", port);\n\t\treturn;\n\t}\n\n\tif (tracker.netdev_state[MLX5_LAG_P1].tx_enabled)\n\t\tmlx5_notifier_call_chain(ldev->pf[MLX5_LAG_P1].dev->priv.events,\n\t\t\t\t\t MLX5_DEV_EVENT_PORT_AFFINITY,\n\t\t\t\t\t (void *)0);\n\n\tif (tracker.netdev_state[MLX5_LAG_P2].tx_enabled)\n\t\tmlx5_notifier_call_chain(ldev->pf[MLX5_LAG_P2].dev->priv.events,\n\t\t\t\t\t MLX5_DEV_EVENT_PORT_AFFINITY,\n\t\t\t\t\t (void *)0);\n\n\tmlx5_modify_lag(ldev, &tracker);\n}\n\nstatic void mlx5_lag_fib_event_flush(struct notifier_block *nb)\n{\n\tstruct lag_mp *mp = container_of(nb, struct lag_mp, fib_nb);\n\n\tflush_workqueue(mp->wq);\n}\n\nstatic void mlx5_lag_fib_set(struct lag_mp *mp, struct fib_info *fi, u32 dst, int dst_len)\n{\n\tmp->fib.mfi = fi;\n\tmp->fib.priority = fi->fib_priority;\n\tmp->fib.dst = dst;\n\tmp->fib.dst_len = dst_len;\n}\n\nstruct mlx5_fib_event_work {\n\tstruct work_struct work;\n\tstruct mlx5_lag *ldev;\n\tunsigned long event;\n\tunion {\n\t\tstruct fib_entry_notifier_info fen_info;\n\t\tstruct fib_nh_notifier_info fnh_info;\n\t};\n};\n\nstatic struct net_device*\nmlx5_lag_get_next_fib_dev(struct mlx5_lag *ldev,\n\t\t\t  struct fib_info *fi,\n\t\t\t  struct net_device *current_dev)\n{\n\tstruct net_device *fib_dev;\n\tint i, ldev_idx, nhs;\n\n\tnhs = fib_info_num_path(fi);\n\ti = 0;\n\tif (current_dev) {\n\t\tfor (; i < nhs; i++) {\n\t\t\tfib_dev = fib_info_nh(fi, i)->fib_nh_dev;\n\t\t\tif (fib_dev == current_dev) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (; i < nhs; i++) {\n\t\tfib_dev = fib_info_nh(fi, i)->fib_nh_dev;\n\t\tldev_idx = mlx5_lag_dev_get_netdev_idx(ldev, fib_dev);\n\t\tif (ldev_idx >= 0)\n\t\t\treturn ldev->pf[ldev_idx].netdev;\n\t}\n\n\treturn NULL;\n}\n\nstatic void mlx5_lag_fib_route_event(struct mlx5_lag *ldev, unsigned long event,\n\t\t\t\t     struct fib_entry_notifier_info *fen_info)\n{\n\tstruct net_device *nh_dev0, *nh_dev1;\n\tstruct fib_info *fi = fen_info->fi;\n\tstruct lag_mp *mp = &ldev->lag_mp;\n\n\t \n\tif (event == FIB_EVENT_ENTRY_DEL) {\n\t\t \n\t\tif (mp->fib.mfi == fi)\n\t\t\tmp->fib.mfi = NULL;\n\t\treturn;\n\t}\n\n\t \n\tif (mp->fib.mfi && mp->fib.mfi != fi &&\n\t    (mp->fib.dst != fen_info->dst || mp->fib.dst_len != fen_info->dst_len) &&\n\t    fi->fib_priority >= mp->fib.priority)\n\t\treturn;\n\n\tnh_dev0 = mlx5_lag_get_next_fib_dev(ldev, fi, NULL);\n\tnh_dev1 = mlx5_lag_get_next_fib_dev(ldev, fi, nh_dev0);\n\n\t \n\tif (!nh_dev0) {\n\t\tif (mp->fib.dst == fen_info->dst && mp->fib.dst_len == fen_info->dst_len)\n\t\t\tmp->fib.mfi = NULL;\n\t\treturn;\n\t}\n\n\tif (nh_dev0 == nh_dev1) {\n\t\tmlx5_core_warn(ldev->pf[MLX5_LAG_P1].dev,\n\t\t\t       \"Multipath offload doesn't support routes with multiple nexthops of the same device\");\n\t\treturn;\n\t}\n\n\tif (!nh_dev1) {\n\t\tif (__mlx5_lag_is_active(ldev)) {\n\t\t\tint i = mlx5_lag_dev_get_netdev_idx(ldev, nh_dev0);\n\n\t\t\ti++;\n\t\t\tmlx5_lag_set_port_affinity(ldev, i);\n\t\t\tmlx5_lag_fib_set(mp, fi, fen_info->dst, fen_info->dst_len);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\tif (!mp->fib.mfi && !__mlx5_lag_is_active(ldev)) {\n\t\tstruct lag_tracker tracker;\n\n\t\ttracker = ldev->tracker;\n\t\tmlx5_activate_lag(ldev, &tracker, MLX5_LAG_MODE_MULTIPATH, false);\n\t}\n\n\tmlx5_lag_set_port_affinity(ldev, MLX5_LAG_NORMAL_AFFINITY);\n\tmlx5_lag_fib_set(mp, fi, fen_info->dst, fen_info->dst_len);\n}\n\nstatic void mlx5_lag_fib_nexthop_event(struct mlx5_lag *ldev,\n\t\t\t\t       unsigned long event,\n\t\t\t\t       struct fib_nh *fib_nh,\n\t\t\t\t       struct fib_info *fi)\n{\n\tstruct lag_mp *mp = &ldev->lag_mp;\n\n\t \n\tif (!mp->fib.mfi || mp->fib.mfi != fi)\n\t\treturn;\n\n\t \n\tif (event == FIB_EVENT_NH_DEL) {\n\t\tint i = mlx5_lag_dev_get_netdev_idx(ldev, fib_nh->fib_nh_dev);\n\n\t\tif (i >= 0) {\n\t\t\ti = (i + 1) % 2 + 1;  \n\t\t\tmlx5_lag_set_port_affinity(ldev, i);\n\t\t}\n\t} else if (event == FIB_EVENT_NH_ADD &&\n\t\t   fib_info_num_path(fi) == 2) {\n\t\tmlx5_lag_set_port_affinity(ldev, MLX5_LAG_NORMAL_AFFINITY);\n\t}\n}\n\nstatic void mlx5_lag_fib_update(struct work_struct *work)\n{\n\tstruct mlx5_fib_event_work *fib_work =\n\t\tcontainer_of(work, struct mlx5_fib_event_work, work);\n\tstruct mlx5_lag *ldev = fib_work->ldev;\n\tstruct fib_nh *fib_nh;\n\n\t \n\trtnl_lock();\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tmlx5_lag_fib_route_event(ldev, fib_work->event,\n\t\t\t\t\t &fib_work->fen_info);\n\t\tfib_info_put(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_NH_ADD:\n\tcase FIB_EVENT_NH_DEL:\n\t\tfib_nh = fib_work->fnh_info.fib_nh;\n\t\tmlx5_lag_fib_nexthop_event(ldev,\n\t\t\t\t\t   fib_work->event,\n\t\t\t\t\t   fib_work->fnh_info.fib_nh,\n\t\t\t\t\t   fib_nh->nh_parent);\n\t\tfib_info_put(fib_work->fnh_info.fib_nh->nh_parent);\n\t\tbreak;\n\t}\n\n\trtnl_unlock();\n\tkfree(fib_work);\n}\n\nstatic struct mlx5_fib_event_work *\nmlx5_lag_init_fib_work(struct mlx5_lag *ldev, unsigned long event)\n{\n\tstruct mlx5_fib_event_work *fib_work;\n\n\tfib_work = kzalloc(sizeof(*fib_work), GFP_ATOMIC);\n\tif (WARN_ON(!fib_work))\n\t\treturn NULL;\n\n\tINIT_WORK(&fib_work->work, mlx5_lag_fib_update);\n\tfib_work->ldev = ldev;\n\tfib_work->event = event;\n\n\treturn fib_work;\n}\n\nstatic int mlx5_lag_fib_event(struct notifier_block *nb,\n\t\t\t      unsigned long event,\n\t\t\t      void *ptr)\n{\n\tstruct lag_mp *mp = container_of(nb, struct lag_mp, fib_nb);\n\tstruct mlx5_lag *ldev = container_of(mp, struct mlx5_lag, lag_mp);\n\tstruct fib_notifier_info *info = ptr;\n\tstruct mlx5_fib_event_work *fib_work;\n\tstruct fib_entry_notifier_info *fen_info;\n\tstruct fib_nh_notifier_info *fnh_info;\n\tstruct fib_info *fi;\n\n\tif (info->family != AF_INET)\n\t\treturn NOTIFY_DONE;\n\n\tif (!mlx5_lag_multipath_check_prereq(ldev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tfen_info = container_of(info, struct fib_entry_notifier_info,\n\t\t\t\t\tinfo);\n\t\tfi = fen_info->fi;\n\t\tif (fi->nh)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tfib_work = mlx5_lag_init_fib_work(ldev, event);\n\t\tif (!fib_work)\n\t\t\treturn NOTIFY_DONE;\n\t\tfib_work->fen_info = *fen_info;\n\t\t \n\t\tfib_info_hold(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_NH_ADD:\n\tcase FIB_EVENT_NH_DEL:\n\t\tfnh_info = container_of(info, struct fib_nh_notifier_info,\n\t\t\t\t\tinfo);\n\t\tfib_work = mlx5_lag_init_fib_work(ldev, event);\n\t\tif (!fib_work)\n\t\t\treturn NOTIFY_DONE;\n\t\tfib_work->fnh_info = *fnh_info;\n\t\tfib_info_hold(fib_work->fnh_info.fib_nh->nh_parent);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tqueue_work(mp->wq, &fib_work->work);\n\n\treturn NOTIFY_DONE;\n}\n\nvoid mlx5_lag_mp_reset(struct mlx5_lag *ldev)\n{\n\t \n\tldev->lag_mp.fib.mfi = NULL;\n}\n\nint mlx5_lag_mp_init(struct mlx5_lag *ldev)\n{\n\tstruct lag_mp *mp = &ldev->lag_mp;\n\tint err;\n\n\t \n\tmp->fib.mfi = NULL;\n\n\tif (mp->fib_nb.notifier_call)\n\t\treturn 0;\n\n\tmp->wq = create_singlethread_workqueue(\"mlx5_lag_mp\");\n\tif (!mp->wq)\n\t\treturn -ENOMEM;\n\n\tmp->fib_nb.notifier_call = mlx5_lag_fib_event;\n\terr = register_fib_notifier(&init_net, &mp->fib_nb,\n\t\t\t\t    mlx5_lag_fib_event_flush, NULL);\n\tif (err) {\n\t\tdestroy_workqueue(mp->wq);\n\t\tmp->fib_nb.notifier_call = NULL;\n\t}\n\n\treturn err;\n}\n\nvoid mlx5_lag_mp_cleanup(struct mlx5_lag *ldev)\n{\n\tstruct lag_mp *mp = &ldev->lag_mp;\n\n\tif (!mp->fib_nb.notifier_call)\n\t\treturn;\n\n\tunregister_fib_notifier(&init_net, &mp->fib_nb);\n\tdestroy_workqueue(mp->wq);\n\tmp->fib_nb.notifier_call = NULL;\n\tmp->fib.mfi = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}