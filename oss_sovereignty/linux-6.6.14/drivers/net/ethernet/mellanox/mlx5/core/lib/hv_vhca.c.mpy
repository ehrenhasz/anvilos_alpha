{
  "module_name": "hv_vhca.c",
  "hash_id": "cfca43b9d3f1ddd0e7edd40e2d1d2cf606577921239eaae5ac2cf6a287b1292f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.c",
  "human_readable_source": "\n\n\n#include <linux/hyperv.h>\n#include \"mlx5_core.h\"\n#include \"lib/hv.h\"\n#include \"lib/hv_vhca.h\"\n\nstruct mlx5_hv_vhca {\n\tstruct mlx5_core_dev       *dev;\n\tstruct workqueue_struct    *work_queue;\n\tstruct mlx5_hv_vhca_agent  *agents[MLX5_HV_VHCA_AGENT_MAX];\n\tstruct mutex                agents_lock;  \n};\n\nstruct mlx5_hv_vhca_work {\n\tstruct work_struct     invalidate_work;\n\tstruct mlx5_hv_vhca   *hv_vhca;\n\tu64                    block_mask;\n};\n\nstruct mlx5_hv_vhca_data_block {\n\tu16     sequence;\n\tu16     offset;\n\tu8      reserved[4];\n\tu64     data[15];\n};\n\nstruct mlx5_hv_vhca_agent {\n\tenum mlx5_hv_vhca_agent_type\t type;\n\tstruct mlx5_hv_vhca\t\t*hv_vhca;\n\tvoid\t\t\t\t*priv;\n\tu16                              seq;\n\tvoid (*control)(struct mlx5_hv_vhca_agent *agent,\n\t\t\tstruct mlx5_hv_vhca_control_block *block);\n\tvoid (*invalidate)(struct mlx5_hv_vhca_agent *agent,\n\t\t\t   u64 block_mask);\n\tvoid (*cleanup)(struct mlx5_hv_vhca_agent *agent);\n};\n\nstruct mlx5_hv_vhca *mlx5_hv_vhca_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_hv_vhca *hv_vhca;\n\n\thv_vhca = kzalloc(sizeof(*hv_vhca), GFP_KERNEL);\n\tif (!hv_vhca)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thv_vhca->work_queue = create_singlethread_workqueue(\"mlx5_hv_vhca\");\n\tif (!hv_vhca->work_queue) {\n\t\tkfree(hv_vhca);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\thv_vhca->dev = dev;\n\tmutex_init(&hv_vhca->agents_lock);\n\n\treturn hv_vhca;\n}\n\nvoid mlx5_hv_vhca_destroy(struct mlx5_hv_vhca *hv_vhca)\n{\n\tif (IS_ERR_OR_NULL(hv_vhca))\n\t\treturn;\n\n\tdestroy_workqueue(hv_vhca->work_queue);\n\tkfree(hv_vhca);\n}\n\nstatic void mlx5_hv_vhca_invalidate_work(struct work_struct *work)\n{\n\tstruct mlx5_hv_vhca_work *hwork;\n\tstruct mlx5_hv_vhca *hv_vhca;\n\tint i;\n\n\thwork = container_of(work, struct mlx5_hv_vhca_work, invalidate_work);\n\thv_vhca = hwork->hv_vhca;\n\n\tmutex_lock(&hv_vhca->agents_lock);\n\tfor (i = 0; i < MLX5_HV_VHCA_AGENT_MAX; i++) {\n\t\tstruct mlx5_hv_vhca_agent *agent = hv_vhca->agents[i];\n\n\t\tif (!agent || !agent->invalidate)\n\t\t\tcontinue;\n\n\t\tif (!(BIT(agent->type) & hwork->block_mask))\n\t\t\tcontinue;\n\n\t\tagent->invalidate(agent, hwork->block_mask);\n\t}\n\tmutex_unlock(&hv_vhca->agents_lock);\n\n\tkfree(hwork);\n}\n\nvoid mlx5_hv_vhca_invalidate(void *context, u64 block_mask)\n{\n\tstruct mlx5_hv_vhca *hv_vhca = (struct mlx5_hv_vhca *)context;\n\tstruct mlx5_hv_vhca_work *work;\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn;\n\n\tINIT_WORK(&work->invalidate_work, mlx5_hv_vhca_invalidate_work);\n\twork->hv_vhca    = hv_vhca;\n\twork->block_mask = block_mask;\n\n\tqueue_work(hv_vhca->work_queue, &work->invalidate_work);\n}\n\n#define AGENT_MASK(type) (type ? BIT(type - 1) : 0  )\n\nstatic void mlx5_hv_vhca_agents_control(struct mlx5_hv_vhca *hv_vhca,\n\t\t\t\t\tstruct mlx5_hv_vhca_control_block *block)\n{\n\tint i;\n\n\tfor (i = 0; i < MLX5_HV_VHCA_AGENT_MAX; i++) {\n\t\tstruct mlx5_hv_vhca_agent *agent = hv_vhca->agents[i];\n\n\t\tif (!agent || !agent->control)\n\t\t\tcontinue;\n\n\t\tif (!(AGENT_MASK(agent->type) & block->control))\n\t\t\tcontinue;\n\n\t\tagent->control(agent, block);\n\t}\n}\n\nstatic void mlx5_hv_vhca_capabilities(struct mlx5_hv_vhca *hv_vhca,\n\t\t\t\t      u32 *capabilities)\n{\n\tint i;\n\n\tfor (i = 0; i < MLX5_HV_VHCA_AGENT_MAX; i++) {\n\t\tstruct mlx5_hv_vhca_agent *agent = hv_vhca->agents[i];\n\n\t\tif (agent)\n\t\t\t*capabilities |= AGENT_MASK(agent->type);\n\t}\n}\n\nstatic void\nmlx5_hv_vhca_control_agent_invalidate(struct mlx5_hv_vhca_agent *agent,\n\t\t\t\t      u64 block_mask)\n{\n\tstruct mlx5_hv_vhca *hv_vhca = agent->hv_vhca;\n\tstruct mlx5_core_dev *dev = hv_vhca->dev;\n\tstruct mlx5_hv_vhca_control_block *block;\n\tu32 capabilities = 0;\n\tint err;\n\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (!block)\n\t\treturn;\n\n\terr = mlx5_hv_read_config(dev, block, sizeof(*block), 0);\n\tif (err)\n\t\tgoto free_block;\n\n\tmlx5_hv_vhca_capabilities(hv_vhca, &capabilities);\n\n\t \n\tif (!capabilities) {\n\t\tmemset(block, 0, sizeof(*block));\n\t\tgoto write;\n\t}\n\n\tif (block->capabilities != capabilities)\n\t\tblock->capabilities = capabilities;\n\n\tif (block->control & ~capabilities)\n\t\tgoto free_block;\n\n\tmlx5_hv_vhca_agents_control(hv_vhca, block);\n\tblock->command_ack = block->command;\n\nwrite:\n\tmlx5_hv_write_config(dev, block, sizeof(*block), 0);\n\nfree_block:\n\tkfree(block);\n}\n\nstatic struct mlx5_hv_vhca_agent *\nmlx5_hv_vhca_control_agent_create(struct mlx5_hv_vhca *hv_vhca)\n{\n\treturn mlx5_hv_vhca_agent_create(hv_vhca, MLX5_HV_VHCA_AGENT_CONTROL,\n\t\t\t\t\t NULL,\n\t\t\t\t\t mlx5_hv_vhca_control_agent_invalidate,\n\t\t\t\t\t NULL, NULL);\n}\n\nstatic void mlx5_hv_vhca_control_agent_destroy(struct mlx5_hv_vhca_agent *agent)\n{\n\tmlx5_hv_vhca_agent_destroy(agent);\n}\n\nint mlx5_hv_vhca_init(struct mlx5_hv_vhca *hv_vhca)\n{\n\tstruct mlx5_hv_vhca_agent *agent;\n\tint err;\n\n\tif (IS_ERR_OR_NULL(hv_vhca))\n\t\treturn IS_ERR_OR_NULL(hv_vhca);\n\n\terr = mlx5_hv_register_invalidate(hv_vhca->dev, hv_vhca,\n\t\t\t\t\t  mlx5_hv_vhca_invalidate);\n\tif (err)\n\t\treturn err;\n\n\tagent = mlx5_hv_vhca_control_agent_create(hv_vhca);\n\tif (IS_ERR_OR_NULL(agent)) {\n\t\tmlx5_hv_unregister_invalidate(hv_vhca->dev);\n\t\treturn IS_ERR_OR_NULL(agent);\n\t}\n\n\thv_vhca->agents[MLX5_HV_VHCA_AGENT_CONTROL] = agent;\n\n\treturn 0;\n}\n\nvoid mlx5_hv_vhca_cleanup(struct mlx5_hv_vhca *hv_vhca)\n{\n\tstruct mlx5_hv_vhca_agent *agent;\n\tint i;\n\n\tif (IS_ERR_OR_NULL(hv_vhca))\n\t\treturn;\n\n\tagent = hv_vhca->agents[MLX5_HV_VHCA_AGENT_CONTROL];\n\tif (agent)\n\t\tmlx5_hv_vhca_control_agent_destroy(agent);\n\n\tmutex_lock(&hv_vhca->agents_lock);\n\tfor (i = 0; i < MLX5_HV_VHCA_AGENT_MAX; i++)\n\t\tWARN_ON(hv_vhca->agents[i]);\n\n\tmutex_unlock(&hv_vhca->agents_lock);\n\n\tmlx5_hv_unregister_invalidate(hv_vhca->dev);\n}\n\nstatic void mlx5_hv_vhca_agents_update(struct mlx5_hv_vhca *hv_vhca)\n{\n\tmlx5_hv_vhca_invalidate(hv_vhca, BIT(MLX5_HV_VHCA_AGENT_CONTROL));\n}\n\nstruct mlx5_hv_vhca_agent *\nmlx5_hv_vhca_agent_create(struct mlx5_hv_vhca *hv_vhca,\n\t\t\t  enum mlx5_hv_vhca_agent_type type,\n\t\t\t  void (*control)(struct mlx5_hv_vhca_agent*,\n\t\t\t\t\t  struct mlx5_hv_vhca_control_block *block),\n\t\t\t  void (*invalidate)(struct mlx5_hv_vhca_agent*,\n\t\t\t\t\t     u64 block_mask),\n\t\t\t  void (*cleaup)(struct mlx5_hv_vhca_agent *agent),\n\t\t\t  void *priv)\n{\n\tstruct mlx5_hv_vhca_agent *agent;\n\n\tif (IS_ERR_OR_NULL(hv_vhca))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (type >= MLX5_HV_VHCA_AGENT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&hv_vhca->agents_lock);\n\tif (hv_vhca->agents[type]) {\n\t\tmutex_unlock(&hv_vhca->agents_lock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tmutex_unlock(&hv_vhca->agents_lock);\n\n\tagent = kzalloc(sizeof(*agent), GFP_KERNEL);\n\tif (!agent)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tagent->type      = type;\n\tagent->hv_vhca   = hv_vhca;\n\tagent->priv      = priv;\n\tagent->control   = control;\n\tagent->invalidate = invalidate;\n\tagent->cleanup   = cleaup;\n\n\tmutex_lock(&hv_vhca->agents_lock);\n\thv_vhca->agents[type] = agent;\n\tmutex_unlock(&hv_vhca->agents_lock);\n\n\tmlx5_hv_vhca_agents_update(hv_vhca);\n\n\treturn agent;\n}\n\nvoid mlx5_hv_vhca_agent_destroy(struct mlx5_hv_vhca_agent *agent)\n{\n\tstruct mlx5_hv_vhca *hv_vhca = agent->hv_vhca;\n\n\tmutex_lock(&hv_vhca->agents_lock);\n\n\tif (WARN_ON(agent != hv_vhca->agents[agent->type])) {\n\t\tmutex_unlock(&hv_vhca->agents_lock);\n\t\treturn;\n\t}\n\n\thv_vhca->agents[agent->type] = NULL;\n\tmutex_unlock(&hv_vhca->agents_lock);\n\n\tif (agent->cleanup)\n\t\tagent->cleanup(agent);\n\n\tkfree(agent);\n\n\tmlx5_hv_vhca_agents_update(hv_vhca);\n}\n\nstatic int mlx5_hv_vhca_data_block_prepare(struct mlx5_hv_vhca_agent *agent,\n\t\t\t\t\t   struct mlx5_hv_vhca_data_block *data_block,\n\t\t\t\t\t   void *src, int len, int *offset)\n{\n\tint bytes = min_t(int, (int)sizeof(data_block->data), len);\n\n\tdata_block->sequence = agent->seq;\n\tdata_block->offset   = (*offset)++;\n\tmemcpy(data_block->data, src, bytes);\n\n\treturn bytes;\n}\n\nstatic void mlx5_hv_vhca_agent_seq_update(struct mlx5_hv_vhca_agent *agent)\n{\n\tagent->seq++;\n}\n\nint mlx5_hv_vhca_agent_write(struct mlx5_hv_vhca_agent *agent,\n\t\t\t     void *buf, int len)\n{\n\tint offset = agent->type * HV_CONFIG_BLOCK_SIZE_MAX;\n\tint block_offset = 0;\n\tint total = 0;\n\tint err;\n\n\twhile (len) {\n\t\tstruct mlx5_hv_vhca_data_block data_block = {0};\n\t\tint bytes;\n\n\t\tbytes = mlx5_hv_vhca_data_block_prepare(agent, &data_block,\n\t\t\t\t\t\t\tbuf + total,\n\t\t\t\t\t\t\tlen, &block_offset);\n\t\tif (!bytes)\n\t\t\treturn -ENOMEM;\n\n\t\terr = mlx5_hv_write_config(agent->hv_vhca->dev, &data_block,\n\t\t\t\t\t   sizeof(data_block), offset);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttotal += bytes;\n\t\tlen   -= bytes;\n\t}\n\n\tmlx5_hv_vhca_agent_seq_update(agent);\n\n\treturn 0;\n}\n\nvoid *mlx5_hv_vhca_agent_priv(struct mlx5_hv_vhca_agent *agent)\n{\n\treturn agent->priv;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}