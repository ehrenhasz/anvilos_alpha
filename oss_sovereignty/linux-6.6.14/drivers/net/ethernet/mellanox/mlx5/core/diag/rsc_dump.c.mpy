{
  "module_name": "rsc_dump.c",
  "hash_id": "f7efedc81bc5fe0e40a8cbd6b9ead95f7d061ae8d633711d384690a02f59de86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/diag/rsc_dump.c",
  "human_readable_source": "\n \n\n#include \"rsc_dump.h\"\n#include \"lib/mlx5.h\"\n\n#define MLX5_SGMT_TYPE(SGMT) MLX5_SGMT_TYPE_##SGMT\n#define MLX5_SGMT_STR_ASSING(SGMT)[MLX5_SGMT_TYPE(SGMT)] = #SGMT\nstatic const char *const mlx5_rsc_sgmt_name[] = {\n\tMLX5_SGMT_STR_ASSING(HW_CQPC),\n\tMLX5_SGMT_STR_ASSING(HW_SQPC),\n\tMLX5_SGMT_STR_ASSING(HW_RQPC),\n\tMLX5_SGMT_STR_ASSING(FULL_SRQC),\n\tMLX5_SGMT_STR_ASSING(FULL_CQC),\n\tMLX5_SGMT_STR_ASSING(FULL_EQC),\n\tMLX5_SGMT_STR_ASSING(FULL_QPC),\n\tMLX5_SGMT_STR_ASSING(SND_BUFF),\n\tMLX5_SGMT_STR_ASSING(RCV_BUFF),\n\tMLX5_SGMT_STR_ASSING(SRQ_BUFF),\n\tMLX5_SGMT_STR_ASSING(CQ_BUFF),\n\tMLX5_SGMT_STR_ASSING(EQ_BUFF),\n\tMLX5_SGMT_STR_ASSING(SX_SLICE),\n\tMLX5_SGMT_STR_ASSING(SX_SLICE_ALL),\n\tMLX5_SGMT_STR_ASSING(RDB),\n\tMLX5_SGMT_STR_ASSING(RX_SLICE_ALL),\n\tMLX5_SGMT_STR_ASSING(PRM_QUERY_QP),\n\tMLX5_SGMT_STR_ASSING(PRM_QUERY_CQ),\n\tMLX5_SGMT_STR_ASSING(PRM_QUERY_MKEY),\n};\n\nstruct mlx5_rsc_dump {\n\tu32 pdn;\n\tu32 mkey;\n\tu32 number_of_menu_items;\n\tu16 fw_segment_type[MLX5_SGMT_TYPE_NUM];\n};\n\nstruct mlx5_rsc_dump_cmd {\n\tu64 mem_size;\n\tu8 cmd[MLX5_ST_SZ_BYTES(resource_dump)];\n};\n\nstatic int mlx5_rsc_dump_sgmt_get_by_name(char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlx5_rsc_sgmt_name); i++)\n\t\tif (!strcmp(name, mlx5_rsc_sgmt_name[i]))\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\n#define MLX5_RSC_DUMP_MENU_HEADER_SIZE (MLX5_ST_SZ_BYTES(resource_dump_info_segment) + \\\n\t\t\t\t\tMLX5_ST_SZ_BYTES(resource_dump_command_segment) + \\\n\t\t\t\t\tMLX5_ST_SZ_BYTES(resource_dump_menu_segment))\n\nstatic int mlx5_rsc_dump_read_menu_sgmt(struct mlx5_rsc_dump *rsc_dump, struct page *page,\n\t\t\t\t\tint read_size, int start_idx)\n{\n\tvoid *data = page_address(page);\n\tenum mlx5_sgmt_type sgmt_idx;\n\tint num_of_items;\n\tchar *sgmt_name;\n\tvoid *member;\n\tint size = 0;\n\tvoid *menu;\n\tint i;\n\n\tif (!start_idx) {\n\t\tmenu = MLX5_ADDR_OF(menu_resource_dump_response, data, menu);\n\t\trsc_dump->number_of_menu_items = MLX5_GET(resource_dump_menu_segment, menu,\n\t\t\t\t\t\t\t  num_of_records);\n\t\tsize = MLX5_RSC_DUMP_MENU_HEADER_SIZE;\n\t\tdata += size;\n\t}\n\tnum_of_items = rsc_dump->number_of_menu_items;\n\n\tfor (i = 0; start_idx + i < num_of_items; i++) {\n\t\tsize += MLX5_ST_SZ_BYTES(resource_dump_menu_record);\n\t\tif (size >= read_size)\n\t\t\treturn start_idx + i;\n\n\t\tmember = data + MLX5_ST_SZ_BYTES(resource_dump_menu_record) * i;\n\t\tsgmt_name =  MLX5_ADDR_OF(resource_dump_menu_record, member, segment_name);\n\t\tsgmt_idx = mlx5_rsc_dump_sgmt_get_by_name(sgmt_name);\n\t\tif (sgmt_idx == -EINVAL)\n\t\t\tcontinue;\n\t\trsc_dump->fw_segment_type[sgmt_idx] = MLX5_GET(resource_dump_menu_record,\n\t\t\t\t\t\t\t       member, segment_type);\n\t}\n\treturn 0;\n}\n\nstatic int mlx5_rsc_dump_trigger(struct mlx5_core_dev *dev, struct mlx5_rsc_dump_cmd *cmd,\n\t\t\t\t struct page *page)\n{\n\tstruct mlx5_rsc_dump *rsc_dump = dev->rsc_dump;\n\tstruct device *ddev = mlx5_core_dma_dev(dev);\n\tu32 out_seq_num;\n\tu32 in_seq_num;\n\tdma_addr_t dma;\n\tint err;\n\n\tdma = dma_map_page(ddev, page, 0, cmd->mem_size, DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(ddev, dma)))\n\t\treturn -ENOMEM;\n\n\tin_seq_num = MLX5_GET(resource_dump, cmd->cmd, seq_num);\n\tMLX5_SET(resource_dump, cmd->cmd, mkey, rsc_dump->mkey);\n\tMLX5_SET64(resource_dump, cmd->cmd, address, dma);\n\n\terr = mlx5_core_access_reg(dev, cmd->cmd, sizeof(cmd->cmd), cmd->cmd,\n\t\t\t\t   sizeof(cmd->cmd), MLX5_REG_RESOURCE_DUMP, 0, 1);\n\tif (err) {\n\t\tmlx5_core_err(dev, \"Resource dump: Failed to access err %d\\n\", err);\n\t\tgoto out;\n\t}\n\tout_seq_num = MLX5_GET(resource_dump, cmd->cmd, seq_num);\n\tif (out_seq_num && (in_seq_num + 1 != out_seq_num))\n\t\terr = -EIO;\nout:\n\tdma_unmap_page(ddev, dma, cmd->mem_size, DMA_FROM_DEVICE);\n\treturn err;\n}\n\nstruct mlx5_rsc_dump_cmd *mlx5_rsc_dump_cmd_create(struct mlx5_core_dev *dev,\n\t\t\t\t\t\t   struct mlx5_rsc_key *key)\n{\n\tstruct mlx5_rsc_dump_cmd *cmd;\n\tint sgmt_type;\n\n\tif (IS_ERR_OR_NULL(dev->rsc_dump))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tsgmt_type = dev->rsc_dump->fw_segment_type[key->rsc];\n\tif (!sgmt_type && key->rsc != MLX5_SGMT_TYPE_MENU)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tmlx5_core_err(dev, \"Resource dump: Failed to allocate command\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tMLX5_SET(resource_dump, cmd->cmd, segment_type, sgmt_type);\n\tMLX5_SET(resource_dump, cmd->cmd, index1, key->index1);\n\tMLX5_SET(resource_dump, cmd->cmd, index2, key->index2);\n\tMLX5_SET(resource_dump, cmd->cmd, num_of_obj1, key->num_of_obj1);\n\tMLX5_SET(resource_dump, cmd->cmd, num_of_obj2, key->num_of_obj2);\n\tMLX5_SET(resource_dump, cmd->cmd, size, key->size);\n\tcmd->mem_size = key->size;\n\treturn cmd;\n}\nEXPORT_SYMBOL(mlx5_rsc_dump_cmd_create);\n\nvoid mlx5_rsc_dump_cmd_destroy(struct mlx5_rsc_dump_cmd *cmd)\n{\n\tkfree(cmd);\n}\nEXPORT_SYMBOL(mlx5_rsc_dump_cmd_destroy);\n\nint mlx5_rsc_dump_next(struct mlx5_core_dev *dev, struct mlx5_rsc_dump_cmd *cmd,\n\t\t       struct page *page, int *size)\n{\n\tbool more_dump;\n\tint err;\n\n\tif (IS_ERR_OR_NULL(dev->rsc_dump))\n\t\treturn -EOPNOTSUPP;\n\n\terr = mlx5_rsc_dump_trigger(dev, cmd, page);\n\tif (err) {\n\t\tmlx5_core_err(dev, \"Resource dump: Failed to trigger dump, %d\\n\", err);\n\t\treturn err;\n\t}\n\t*size = MLX5_GET(resource_dump, cmd->cmd, size);\n\tmore_dump = MLX5_GET(resource_dump, cmd->cmd, more_dump);\n\n\treturn more_dump;\n}\nEXPORT_SYMBOL(mlx5_rsc_dump_next);\n\n#define MLX5_RSC_DUMP_MENU_SEGMENT 0xffff\nstatic int mlx5_rsc_dump_menu(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_rsc_dump_cmd *cmd = NULL;\n\tstruct mlx5_rsc_key key = {};\n\tstruct page *page;\n\tint start_idx = 0;\n\tint size;\n\tint err;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tkey.rsc = MLX5_SGMT_TYPE_MENU;\n\tkey.size = PAGE_SIZE;\n\tcmd  = mlx5_rsc_dump_cmd_create(dev, &key);\n\tif (IS_ERR(cmd)) {\n\t\terr = PTR_ERR(cmd);\n\t\tgoto free_page;\n\t}\n\tMLX5_SET(resource_dump, cmd->cmd, segment_type, MLX5_RSC_DUMP_MENU_SEGMENT);\n\n\tdo {\n\t\terr = mlx5_rsc_dump_next(dev, cmd, page, &size);\n\t\tif (err < 0)\n\t\t\tgoto destroy_cmd;\n\n\t\tstart_idx = mlx5_rsc_dump_read_menu_sgmt(dev->rsc_dump, page, size, start_idx);\n\n\t} while (err > 0);\n\ndestroy_cmd:\n\tmlx5_rsc_dump_cmd_destroy(cmd);\nfree_page:\n\t__free_page(page);\n\n\treturn err;\n}\n\nstatic int mlx5_rsc_dump_create_mkey(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t     u32 *mkey)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_mkey_in);\n\tvoid *mkc;\n\tu32 *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\tMLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);\n\tMLX5_SET(mkc, mkc, lw, 1);\n\tMLX5_SET(mkc, mkc, lr, 1);\n\n\tMLX5_SET(mkc, mkc, pd, pdn);\n\tMLX5_SET(mkc, mkc, length64, 1);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\n\terr = mlx5_core_create_mkey(mdev, mkey, in, inlen);\n\n\tkvfree(in);\n\treturn err;\n}\n\nstruct mlx5_rsc_dump *mlx5_rsc_dump_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_rsc_dump *rsc_dump;\n\n\tif (!MLX5_CAP_DEBUG(dev, resource_dump)) {\n\t\tmlx5_core_dbg(dev, \"Resource dump: capability not present\\n\");\n\t\treturn NULL;\n\t}\n\trsc_dump = kzalloc(sizeof(*rsc_dump), GFP_KERNEL);\n\tif (!rsc_dump)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn rsc_dump;\n}\n\nvoid mlx5_rsc_dump_destroy(struct mlx5_core_dev *dev)\n{\n\tif (IS_ERR_OR_NULL(dev->rsc_dump))\n\t\treturn;\n\tkfree(dev->rsc_dump);\n}\n\nint mlx5_rsc_dump_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_rsc_dump *rsc_dump = dev->rsc_dump;\n\tint err;\n\n\tif (IS_ERR_OR_NULL(dev->rsc_dump))\n\t\treturn 0;\n\n\terr = mlx5_core_alloc_pd(dev, &rsc_dump->pdn);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"Resource dump: Failed to allocate PD %d\\n\", err);\n\t\treturn err;\n\t}\n\terr = mlx5_rsc_dump_create_mkey(dev, rsc_dump->pdn, &rsc_dump->mkey);\n\tif (err) {\n\t\tmlx5_core_err(dev, \"Resource dump: Failed to create mkey, %d\\n\", err);\n\t\tgoto free_pd;\n\t}\n\terr = mlx5_rsc_dump_menu(dev);\n\tif (err) {\n\t\tmlx5_core_err(dev, \"Resource dump: Failed to read menu, %d\\n\", err);\n\t\tgoto destroy_mkey;\n\t}\n\treturn err;\n\ndestroy_mkey:\n\tmlx5_core_destroy_mkey(dev, rsc_dump->mkey);\nfree_pd:\n\tmlx5_core_dealloc_pd(dev, rsc_dump->pdn);\n\treturn err;\n}\n\nvoid mlx5_rsc_dump_cleanup(struct mlx5_core_dev *dev)\n{\n\tif (IS_ERR_OR_NULL(dev->rsc_dump))\n\t\treturn;\n\n\tmlx5_core_destroy_mkey(dev, dev->rsc_dump->mkey);\n\tmlx5_core_dealloc_pd(dev, dev->rsc_dump->pdn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}