{
  "module_name": "en_dcbnl.c",
  "hash_id": "d9d5f157b5c921e9a39be919857d3b6da40eb52757bedf51eecdb9284950d21f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c",
  "human_readable_source": " \n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include \"en.h\"\n#include \"en/port.h\"\n#include \"en/port_buffer.h\"\n\n#define MLX5E_MAX_BW_ALLOC 100  \n\n#define MLX5E_100MB (100000)\n#define MLX5E_1GB   (1000000)\n\n#define MLX5E_CEE_STATE_UP    1\n#define MLX5E_CEE_STATE_DOWN  0\n\n \n#define MLX5E_MAX_CABLE_LENGTH 1000\n\nenum {\n\tMLX5E_VENDOR_TC_GROUP_NUM = 7,\n\tMLX5E_LOWEST_PRIO_GROUP   = 0,\n};\n\nenum {\n\tMLX5_DCB_CHG_RESET,\n\tMLX5_DCB_NO_CHG,\n\tMLX5_DCB_CHG_NO_RESET,\n};\n\n#define MLX5_DSCP_SUPPORTED(mdev) (MLX5_CAP_GEN(mdev, qcam_reg)  && \\\n\t\t\t\t   MLX5_CAP_QCAM_REG(mdev, qpts) && \\\n\t\t\t\t   MLX5_CAP_QCAM_REG(mdev, qpdpm))\n\nstatic int mlx5e_set_trust_state(struct mlx5e_priv *priv, u8 trust_state);\nstatic int mlx5e_set_dscp2prio(struct mlx5e_priv *priv, u8 dscp, u8 prio);\n\n \nstatic int mlx5e_dcbnl_set_dcbx_mode(struct mlx5e_priv *priv,\n\t\t\t\t     enum mlx5_dcbx_oper_mode mode)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu32 param[MLX5_ST_SZ_DW(dcbx_param)];\n\tint err;\n\n\terr = mlx5_query_port_dcbx_param(mdev, param);\n\tif (err)\n\t\treturn err;\n\n\tMLX5_SET(dcbx_param, param, version_admin, mode);\n\tif (mode != MLX5E_DCBX_PARAM_VER_OPER_HOST)\n\t\tMLX5_SET(dcbx_param, param, willing_admin, 1);\n\n\treturn mlx5_set_port_dcbx_param(mdev, param);\n}\n\nstatic int mlx5e_dcbnl_switch_to_host_mode(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_dcbx *dcbx = &priv->dcbx;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, dcbx))\n\t\treturn 0;\n\n\tif (dcbx->mode == MLX5E_DCBX_PARAM_VER_OPER_HOST)\n\t\treturn 0;\n\n\terr = mlx5e_dcbnl_set_dcbx_mode(priv, MLX5E_DCBX_PARAM_VER_OPER_HOST);\n\tif (err)\n\t\treturn err;\n\n\tdcbx->mode = MLX5E_DCBX_PARAM_VER_OPER_HOST;\n\treturn 0;\n}\n\nstatic int mlx5e_dcbnl_ieee_getets(struct net_device *netdev,\n\t\t\t\t   struct ieee_ets *ets)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 tc_group[IEEE_8021QAZ_MAX_TCS];\n\tbool is_tc_group_6_exist = false;\n\tbool is_zero_bw_ets_tc = false;\n\tint err = 0;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, ets))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlx5_query_port_prio_tc(mdev, i, &ets->prio_tc[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tets->ets_cap = mlx5_max_tc(priv->mdev) + 1;\n\tfor (i = 0; i < ets->ets_cap; i++) {\n\t\terr = mlx5_query_port_tc_group(mdev, i, &tc_group[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlx5_query_port_tc_bw_alloc(mdev, i, &ets->tc_tx_bw[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (ets->tc_tx_bw[i] < MLX5E_MAX_BW_ALLOC &&\n\t\t    tc_group[i] == (MLX5E_LOWEST_PRIO_GROUP + 1))\n\t\t\tis_zero_bw_ets_tc = true;\n\n\t\tif (tc_group[i] == (MLX5E_VENDOR_TC_GROUP_NUM - 1))\n\t\t\tis_tc_group_6_exist = true;\n\t}\n\n\t \n\tif (is_zero_bw_ets_tc) {\n\t\tfor (i = 0; i < ets->ets_cap; i++)\n\t\t\tif (tc_group[i] == MLX5E_LOWEST_PRIO_GROUP)\n\t\t\t\tets->tc_tx_bw[i] = 0;\n\t}\n\n\t \n\tfor (i = 0; i < ets->ets_cap; i++) {\n\t\tif (ets->tc_tx_bw[i] < MLX5E_MAX_BW_ALLOC)\n\t\t\tpriv->dcbx.tc_tsa[i] = IEEE_8021QAZ_TSA_ETS;\n\t\telse if (tc_group[i] == MLX5E_VENDOR_TC_GROUP_NUM &&\n\t\t\t !is_tc_group_6_exist)\n\t\t\tpriv->dcbx.tc_tsa[i] = IEEE_8021QAZ_TSA_VENDOR;\n\t}\n\tmemcpy(ets->tc_tsa, priv->dcbx.tc_tsa, sizeof(ets->tc_tsa));\n\n\treturn err;\n}\n\nstatic void mlx5e_build_tc_group(struct ieee_ets *ets, u8 *tc_group, int max_tc)\n{\n\tbool any_tc_mapped_to_ets = false;\n\tbool ets_zero_bw = false;\n\tint strict_group;\n\tint i;\n\n\tfor (i = 0; i <= max_tc; i++) {\n\t\tif (ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS) {\n\t\t\tany_tc_mapped_to_ets = true;\n\t\t\tif (!ets->tc_tx_bw[i])\n\t\t\t\tets_zero_bw = true;\n\t\t}\n\t}\n\n\t \n\tstrict_group = MLX5E_LOWEST_PRIO_GROUP;\n\tif (any_tc_mapped_to_ets)\n\t\tstrict_group++;\n\tif (ets_zero_bw)\n\t\tstrict_group++;\n\n\tfor (i = 0; i <= max_tc; i++) {\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_VENDOR:\n\t\t\ttc_group[i] = MLX5E_VENDOR_TC_GROUP_NUM;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\ttc_group[i] = strict_group++;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\ttc_group[i] = MLX5E_LOWEST_PRIO_GROUP;\n\t\t\tif (ets->tc_tx_bw[i] && ets_zero_bw)\n\t\t\t\ttc_group[i] = MLX5E_LOWEST_PRIO_GROUP + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void mlx5e_build_tc_tx_bw(struct ieee_ets *ets, u8 *tc_tx_bw,\n\t\t\t\t u8 *tc_group, int max_tc)\n{\n\tint bw_for_ets_zero_bw_tc = 0;\n\tint last_ets_zero_bw_tc = -1;\n\tint num_ets_zero_bw = 0;\n\tint i;\n\n\tfor (i = 0; i <= max_tc; i++) {\n\t\tif (ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS &&\n\t\t    !ets->tc_tx_bw[i]) {\n\t\t\tnum_ets_zero_bw++;\n\t\t\tlast_ets_zero_bw_tc = i;\n\t\t}\n\t}\n\n\tif (num_ets_zero_bw)\n\t\tbw_for_ets_zero_bw_tc = MLX5E_MAX_BW_ALLOC / num_ets_zero_bw;\n\n\tfor (i = 0; i <= max_tc; i++) {\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_VENDOR:\n\t\t\ttc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\ttc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\ttc_tx_bw[i] = ets->tc_tx_bw[i] ?\n\t\t\t\t      ets->tc_tx_bw[i] :\n\t\t\t\t      bw_for_ets_zero_bw_tc;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (last_ets_zero_bw_tc != -1)\n\t\ttc_tx_bw[last_ets_zero_bw_tc] +=\n\t\t\tMLX5E_MAX_BW_ALLOC % num_ets_zero_bw;\n}\n\n \nstatic int mlx5e_dcbnl_ieee_setets_core(struct mlx5e_priv *priv, struct ieee_ets *ets)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 tc_tx_bw[IEEE_8021QAZ_MAX_TCS];\n\tu8 tc_group[IEEE_8021QAZ_MAX_TCS];\n\tint max_tc = mlx5_max_tc(mdev);\n\tint err, i;\n\n\tmlx5e_build_tc_group(ets, tc_group, max_tc);\n\tmlx5e_build_tc_tx_bw(ets, tc_tx_bw, tc_group, max_tc);\n\n\terr = mlx5_set_port_prio_tc(mdev, ets->prio_tc);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_set_port_tc_group(mdev, tc_group);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_set_port_tc_bw_alloc(mdev, tc_tx_bw);\n\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(priv->dcbx.tc_tsa, ets->tc_tsa, sizeof(ets->tc_tsa));\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tnetdev_dbg(priv->netdev, \"%s: prio_%d <=> tc_%d\\n\",\n\t\t\t   __func__, i, ets->prio_tc[i]);\n\t\tnetdev_dbg(priv->netdev, \"%s: tc_%d <=> tx_bw_%d%%, group_%d\\n\",\n\t\t\t   __func__, i, tc_tx_bw[i], tc_group[i]);\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5e_dbcnl_validate_ets(struct net_device *netdev,\n\t\t\t\t    struct ieee_ets *ets,\n\t\t\t\t    bool zero_sum_allowed)\n{\n\tbool have_ets_tc = false;\n\tint bw_sum = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tif (ets->prio_tc[i] >= MLX5E_MAX_PRIORITY) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Failed to validate ETS: priority value greater than max(%d)\\n\",\n\t\t\t\t    MLX5E_MAX_PRIORITY);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tif (ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS) {\n\t\t\thave_ets_tc = true;\n\t\t\tbw_sum += ets->tc_tx_bw[i];\n\t\t}\n\t}\n\n\tif (have_ets_tc && bw_sum != 100) {\n\t\tif (bw_sum || (!bw_sum && !zero_sum_allowed))\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Failed to validate ETS: BW sum is illegal\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int mlx5e_dcbnl_ieee_setets(struct net_device *netdev,\n\t\t\t\t   struct ieee_ets *ets)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, ets))\n\t\treturn -EOPNOTSUPP;\n\n\terr = mlx5e_dbcnl_validate_ets(netdev, ets, false);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_dcbnl_ieee_setets_core(priv, ets);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mlx5e_dcbnl_ieee_getpfc(struct net_device *dev,\n\t\t\t\t   struct ieee_pfc *pfc)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_pport_stats *pstats = &priv->stats.pport;\n\tint i;\n\n\tpfc->pfc_cap = mlx5_max_tc(mdev) + 1;\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tpfc->requests[i]    = PPORT_PER_PRIO_GET(pstats, i, tx_pause);\n\t\tpfc->indications[i] = PPORT_PER_PRIO_GET(pstats, i, rx_pause);\n\t}\n\n\tif (MLX5_BUFFER_SUPPORTED(mdev))\n\t\tpfc->delay = priv->dcbx.cable_len;\n\n\treturn mlx5_query_port_pfc(mdev, &pfc->pfc_en, NULL);\n}\n\nstatic int mlx5e_dcbnl_ieee_setpfc(struct net_device *dev,\n\t\t\t\t   struct ieee_pfc *pfc)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu32 old_cable_len = priv->dcbx.cable_len;\n\tstruct ieee_pfc pfc_new;\n\tu32 changed = 0;\n\tu8 curr_pfc_en;\n\tint ret = 0;\n\n\t \n\tmlx5_query_port_pfc(mdev, &curr_pfc_en, NULL);\n\tif (pfc->pfc_en != curr_pfc_en) {\n\t\tret = mlx5_set_port_pfc(mdev, pfc->pfc_en, pfc->pfc_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmlx5_toggle_port_link(mdev);\n\t\tchanged |= MLX5E_PORT_BUFFER_PFC;\n\t}\n\n\tif (pfc->delay &&\n\t    pfc->delay < MLX5E_MAX_CABLE_LENGTH &&\n\t    pfc->delay != priv->dcbx.cable_len) {\n\t\tpriv->dcbx.cable_len = pfc->delay;\n\t\tchanged |= MLX5E_PORT_BUFFER_CABLE_LEN;\n\t}\n\n\tif (MLX5_BUFFER_SUPPORTED(mdev)) {\n\t\tpfc_new.pfc_en = (changed & MLX5E_PORT_BUFFER_PFC) ? pfc->pfc_en : curr_pfc_en;\n\t\tif (priv->dcbx.manual_buffer)\n\t\t\tret = mlx5e_port_manual_buffer_config(priv, changed,\n\t\t\t\t\t\t\t      dev->mtu, &pfc_new,\n\t\t\t\t\t\t\t      NULL, NULL);\n\n\t\tif (ret && (changed & MLX5E_PORT_BUFFER_CABLE_LEN))\n\t\t\tpriv->dcbx.cable_len = old_cable_len;\n\t}\n\n\tif (!ret) {\n\t\tnetdev_dbg(dev,\n\t\t\t   \"%s: PFC per priority bit mask: 0x%x\\n\",\n\t\t\t   __func__, pfc->pfc_en);\n\t}\n\treturn ret;\n}\n\nstatic u8 mlx5e_dcbnl_getdcbx(struct net_device *dev)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn priv->dcbx.cap;\n}\n\nstatic u8 mlx5e_dcbnl_setdcbx(struct net_device *dev, u8 mode)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5e_dcbx *dcbx = &priv->dcbx;\n\n\tif (mode & DCB_CAP_DCBX_LLD_MANAGED)\n\t\treturn 1;\n\n\tif ((!mode) && MLX5_CAP_GEN(priv->mdev, dcbx)) {\n\t\tif (dcbx->mode == MLX5E_DCBX_PARAM_VER_OPER_AUTO)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!mlx5e_dcbnl_set_dcbx_mode(priv, MLX5E_DCBX_PARAM_VER_OPER_AUTO)) {\n\t\t\tdcbx->mode = MLX5E_DCBX_PARAM_VER_OPER_AUTO;\n\t\t\tdcbx->cap &= ~DCB_CAP_DCBX_HOST;\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif (!(mode & DCB_CAP_DCBX_HOST))\n\t\treturn 1;\n\n\tif (mlx5e_dcbnl_switch_to_host_mode(netdev_priv(dev)))\n\t\treturn 1;\n\n\tdcbx->cap = mode;\n\n\treturn 0;\n}\n\nstatic int mlx5e_dcbnl_ieee_setapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct dcb_app temp;\n\tbool is_new;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, vport_group_manager) ||\n\t    !MLX5_DSCP_SUPPORTED(priv->mdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((app->selector != IEEE_8021QAZ_APP_SEL_DSCP) ||\n\t    (app->protocol >= MLX5E_MAX_DSCP))\n\t\treturn -EINVAL;\n\n\t \n\ttemp.selector = IEEE_8021QAZ_APP_SEL_DSCP;\n\ttemp.protocol = app->protocol;\n\ttemp.priority = priv->dcbx_dp.dscp2prio[app->protocol];\n\n\t \n\tif (!priv->dcbx.dscp_app_cnt) {\n\t\terr =  mlx5e_set_trust_state(priv, MLX5_QPTS_TRUST_DSCP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (app->priority != priv->dcbx_dp.dscp2prio[app->protocol]) {\n\t\terr = mlx5e_set_dscp2prio(priv, app->protocol, app->priority);\n\t\tif (err)\n\t\t\tgoto fw_err;\n\t}\n\n\t \n\tis_new = false;\n\terr = dcb_ieee_delapp(dev, &temp);\n\tif (err)\n\t\tis_new = true;\n\n\t \n\terr = dcb_ieee_setapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\tif (is_new)\n\t\tpriv->dcbx.dscp_app_cnt++;\n\n\treturn err;\n\nfw_err:\n\tmlx5e_set_trust_state(priv, MLX5_QPTS_TRUST_PCP);\n\treturn err;\n}\n\nstatic int mlx5e_dcbnl_ieee_delapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tif  (!MLX5_CAP_GEN(priv->mdev, vport_group_manager) ||\n\t     !MLX5_DSCP_SUPPORTED(priv->mdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((app->selector != IEEE_8021QAZ_APP_SEL_DSCP) ||\n\t    (app->protocol >= MLX5E_MAX_DSCP))\n\t\treturn -EINVAL;\n\n\t \n\tif (!priv->dcbx.dscp_app_cnt)\n\t\treturn -ENOENT;\n\n\t \n\tif (app->priority != priv->dcbx_dp.dscp2prio[app->protocol])\n\t\treturn -ENOENT;\n\n\t \n\terr = dcb_ieee_delapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mlx5e_set_dscp2prio(priv, app->protocol, 0);\n\tif (err)\n\t\tgoto fw_err;\n\n\tpriv->dcbx.dscp_app_cnt--;\n\n\t \n\tif (!priv->dcbx.dscp_app_cnt)\n\t\terr = mlx5e_set_trust_state(priv, MLX5_QPTS_TRUST_PCP);\n\n\treturn err;\n\nfw_err:\n\tmlx5e_set_trust_state(priv, MLX5_QPTS_TRUST_PCP);\n\treturn err;\n}\n\nstatic int mlx5e_dcbnl_ieee_getmaxrate(struct net_device *netdev,\n\t\t\t\t       struct ieee_maxrate *maxrate)\n{\n\tstruct mlx5e_priv *priv    = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 max_bw_value[IEEE_8021QAZ_MAX_TCS];\n\tu8 max_bw_unit[IEEE_8021QAZ_MAX_TCS];\n\tint err;\n\tint i;\n\n\terr = mlx5_query_port_ets_rate_limit(mdev, max_bw_value, max_bw_unit);\n\tif (err)\n\t\treturn err;\n\n\tmemset(maxrate->tc_maxrate, 0, sizeof(maxrate->tc_maxrate));\n\n\tfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\n\t\tswitch (max_bw_unit[i]) {\n\t\tcase MLX5_100_MBPS_UNIT:\n\t\t\tmaxrate->tc_maxrate[i] = max_bw_value[i] * MLX5E_100MB;\n\t\t\tbreak;\n\t\tcase MLX5_GBPS_UNIT:\n\t\t\tmaxrate->tc_maxrate[i] = max_bw_value[i] * MLX5E_1GB;\n\t\t\tbreak;\n\t\tcase MLX5_BW_NO_LIMIT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(true, \"non-supported BW unit\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_dcbnl_ieee_setmaxrate(struct net_device *netdev,\n\t\t\t\t       struct ieee_maxrate *maxrate)\n{\n\tstruct mlx5e_priv *priv    = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 max_bw_value[IEEE_8021QAZ_MAX_TCS];\n\tu8 max_bw_unit[IEEE_8021QAZ_MAX_TCS];\n\t__u64 upper_limit_mbps = roundup(255 * MLX5E_100MB, MLX5E_1GB);\n\tint i;\n\n\tmemset(max_bw_value, 0, sizeof(max_bw_value));\n\tmemset(max_bw_unit, 0, sizeof(max_bw_unit));\n\n\tfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\n\t\tif (!maxrate->tc_maxrate[i]) {\n\t\t\tmax_bw_unit[i]  = MLX5_BW_NO_LIMIT;\n\t\t\tcontinue;\n\t\t}\n\t\tif (maxrate->tc_maxrate[i] < upper_limit_mbps) {\n\t\t\tmax_bw_value[i] = div_u64(maxrate->tc_maxrate[i],\n\t\t\t\t\t\t  MLX5E_100MB);\n\t\t\tmax_bw_value[i] = max_bw_value[i] ? max_bw_value[i] : 1;\n\t\t\tmax_bw_unit[i]  = MLX5_100_MBPS_UNIT;\n\t\t} else {\n\t\t\tmax_bw_value[i] = div_u64(maxrate->tc_maxrate[i],\n\t\t\t\t\t\t  MLX5E_1GB);\n\t\t\tmax_bw_unit[i]  = MLX5_GBPS_UNIT;\n\t\t}\n\t}\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tnetdev_dbg(netdev, \"%s: tc_%d <=> max_bw %d Gbps\\n\",\n\t\t\t   __func__, i, max_bw_value[i]);\n\t}\n\n\treturn mlx5_modify_port_ets_rate_limit(mdev, max_bw_value, max_bw_unit);\n}\n\nstatic u8 mlx5e_dcbnl_setall(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct ieee_ets ets;\n\tstruct ieee_pfc pfc;\n\tint err = -EOPNOTSUPP;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(mdev, ets))\n\t\tgoto out;\n\n\tmemset(&ets, 0, sizeof(ets));\n\tmemset(&pfc, 0, sizeof(pfc));\n\n\tets.ets_cap = IEEE_8021QAZ_MAX_TCS;\n\tfor (i = 0; i < CEE_DCBX_MAX_PGS; i++) {\n\t\tets.tc_tx_bw[i] = cee_cfg->pg_bw_pct[i];\n\t\tets.tc_rx_bw[i] = cee_cfg->pg_bw_pct[i];\n\t\tets.tc_tsa[i]   = IEEE_8021QAZ_TSA_ETS;\n\t\tets.prio_tc[i]  = cee_cfg->prio_to_pg_map[i];\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"%s: Priority group %d: tx_bw %d, rx_bw %d, prio_tc %d\\n\",\n\t\t\t   __func__, i, ets.tc_tx_bw[i], ets.tc_rx_bw[i],\n\t\t\t   ets.prio_tc[i]);\n\t}\n\n\terr = mlx5e_dbcnl_validate_ets(netdev, &ets, true);\n\tif (err)\n\t\tgoto out;\n\n\terr = mlx5e_dcbnl_ieee_setets_core(priv, &ets);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, Failed to set ETS: %d\\n\", __func__, err);\n\t\tgoto out;\n\t}\n\n\t \n\tpfc.pfc_cap = mlx5_max_tc(mdev) + 1;\n\tif (!cee_cfg->pfc_enable)\n\t\tpfc.pfc_en = 0;\n\telse\n\t\tfor (i = 0; i < CEE_DCBX_MAX_PRIO; i++)\n\t\t\tpfc.pfc_en |= cee_cfg->pfc_setting[i] << i;\n\n\terr = mlx5e_dcbnl_ieee_setpfc(netdev, &pfc);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, Failed to set PFC: %d\\n\", __func__, err);\n\t\tgoto out;\n\t}\nout:\n\treturn err ? MLX5_DCB_NO_CHG : MLX5_DCB_CHG_RESET;\n}\n\nstatic u8 mlx5e_dcbnl_getstate(struct net_device *netdev)\n{\n\treturn MLX5E_CEE_STATE_UP;\n}\n\nstatic void mlx5e_dcbnl_getpermhwaddr(struct net_device *netdev,\n\t\t\t\t      u8 *perm_addr)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tif (!perm_addr)\n\t\treturn;\n\n\tmemset(perm_addr, 0xff, MAX_ADDR_LEN);\n\n\tmlx5_query_mac_address(priv->mdev, perm_addr);\n}\n\nstatic void mlx5e_dcbnl_setpgtccfgtx(struct net_device *netdev,\n\t\t\t\t     int priority, u8 prio_type,\n\t\t\t\t     u8 pgid, u8 bw_pct, u8 up_map)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\n\n\tif (priority >= CEE_DCBX_MAX_PRIO) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, priority is out of range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (pgid >= CEE_DCBX_MAX_PGS) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, priority group is out of range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcee_cfg->prio_to_pg_map[priority] = pgid;\n}\n\nstatic void mlx5e_dcbnl_setpgbwgcfgtx(struct net_device *netdev,\n\t\t\t\t      int pgid, u8 bw_pct)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\n\n\tif (pgid >= CEE_DCBX_MAX_PGS) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, priority group is out of range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcee_cfg->pg_bw_pct[pgid] = bw_pct;\n}\n\nstatic void mlx5e_dcbnl_getpgtccfgtx(struct net_device *netdev,\n\t\t\t\t     int priority, u8 *prio_type,\n\t\t\t\t     u8 *pgid, u8 *bw_pct, u8 *up_map)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, ets)) {\n\t\tnetdev_err(netdev, \"%s, ets is not supported\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (priority >= CEE_DCBX_MAX_PRIO) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, priority is out of range\\n\", __func__);\n\t\treturn;\n\t}\n\n\t*prio_type = 0;\n\t*bw_pct = 0;\n\t*up_map = 0;\n\n\tif (mlx5_query_port_prio_tc(mdev, priority, pgid))\n\t\t*pgid = 0;\n}\n\nstatic void mlx5e_dcbnl_getpgbwgcfgtx(struct net_device *netdev,\n\t\t\t\t      int pgid, u8 *bw_pct)\n{\n\tstruct ieee_ets ets;\n\n\tif (pgid >= CEE_DCBX_MAX_PGS) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, priority group is out of range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmlx5e_dcbnl_ieee_getets(netdev, &ets);\n\t*bw_pct = ets.tc_tx_bw[pgid];\n}\n\nstatic void mlx5e_dcbnl_setpfccfg(struct net_device *netdev,\n\t\t\t\t  int priority, u8 setting)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\n\n\tif (priority >= CEE_DCBX_MAX_PRIO) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, priority is out of range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (setting > 1)\n\t\treturn;\n\n\tcee_cfg->pfc_setting[priority] = setting;\n}\n\nstatic int\nmlx5e_dcbnl_get_priority_pfc(struct net_device *netdev,\n\t\t\t     int priority, u8 *setting)\n{\n\tstruct ieee_pfc pfc;\n\tint err;\n\n\terr = mlx5e_dcbnl_ieee_getpfc(netdev, &pfc);\n\n\tif (err)\n\t\t*setting = 0;\n\telse\n\t\t*setting = (pfc.pfc_en >> priority) & 0x01;\n\n\treturn err;\n}\n\nstatic void mlx5e_dcbnl_getpfccfg(struct net_device *netdev,\n\t\t\t\t  int priority, u8 *setting)\n{\n\tif (priority >= CEE_DCBX_MAX_PRIO) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s, priority is out of range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!setting)\n\t\treturn;\n\n\tmlx5e_dcbnl_get_priority_pfc(netdev, priority, setting);\n}\n\nstatic u8 mlx5e_dcbnl_getcap(struct net_device *netdev,\n\t\t\t     int capid, u8 *cap)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 rval = 0;\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PG:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_UP2TC:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PG_TCS:\n\t\t*cap = 1 << mlx5_max_tc(mdev);\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 1 << mlx5_max_tc(mdev);\n\t\tbreak;\n\tcase DCB_CAP_ATTR_GSP:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_BCN:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = priv->dcbx.cap |\n\t\t       DCB_CAP_DCBX_VER_CEE |\n\t\t       DCB_CAP_DCBX_VER_IEEE;\n\t\tbreak;\n\tdefault:\n\t\t*cap = 0;\n\t\trval = 1;\n\t\tbreak;\n\t}\n\n\treturn rval;\n}\n\nstatic int mlx5e_dcbnl_getnumtcs(struct net_device *netdev,\n\t\t\t\t int tcs_id, u8 *num)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tswitch (tcs_id) {\n\tcase DCB_NUMTCS_ATTR_PG:\n\tcase DCB_NUMTCS_ATTR_PFC:\n\t\t*num = mlx5_max_tc(mdev) + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 mlx5e_dcbnl_getpfcstate(struct net_device *netdev)\n{\n\tstruct ieee_pfc pfc;\n\n\tif (mlx5e_dcbnl_ieee_getpfc(netdev, &pfc))\n\t\treturn MLX5E_CEE_STATE_DOWN;\n\n\treturn pfc.pfc_en ? MLX5E_CEE_STATE_UP : MLX5E_CEE_STATE_DOWN;\n}\n\nstatic void mlx5e_dcbnl_setpfcstate(struct net_device *netdev, u8 state)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\n\n\tif ((state != MLX5E_CEE_STATE_UP) && (state != MLX5E_CEE_STATE_DOWN))\n\t\treturn;\n\n\tcee_cfg->pfc_enable = state;\n}\n\nstatic int mlx5e_dcbnl_getbuffer(struct net_device *dev,\n\t\t\t\t struct dcbnl_buffer *dcb_buffer)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_port_buffer port_buffer;\n\tu8 buffer[MLX5E_MAX_PRIORITY];\n\tint i, err;\n\n\tif (!MLX5_BUFFER_SUPPORTED(mdev))\n\t\treturn -EOPNOTSUPP;\n\n\terr = mlx5e_port_query_priority2buffer(mdev, buffer);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < MLX5E_MAX_PRIORITY; i++)\n\t\tdcb_buffer->prio2buffer[i] = buffer[i];\n\n\terr = mlx5e_port_query_buffer(priv, &port_buffer);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++)\n\t\tdcb_buffer->buffer_size[i] = port_buffer.buffer[i].size;\n\tdcb_buffer->total_size = port_buffer.port_buffer_size -\n\t\t\t\t port_buffer.internal_buffers_size;\n\n\treturn 0;\n}\n\nstatic int mlx5e_dcbnl_setbuffer(struct net_device *dev,\n\t\t\t\t struct dcbnl_buffer *dcb_buffer)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_port_buffer port_buffer;\n\tu8 old_prio2buffer[MLX5E_MAX_PRIORITY];\n\tu32 *buffer_size = NULL;\n\tu8 *prio2buffer = NULL;\n\tu32 changed = 0;\n\tint i, err;\n\n\tif (!MLX5_BUFFER_SUPPORTED(mdev))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < DCBX_MAX_BUFFERS; i++)\n\t\tmlx5_core_dbg(mdev, \"buffer[%d]=%d\\n\", i, dcb_buffer->buffer_size[i]);\n\n\tfor (i = 0; i < MLX5E_MAX_PRIORITY; i++)\n\t\tmlx5_core_dbg(mdev, \"priority %d buffer%d\\n\", i, dcb_buffer->prio2buffer[i]);\n\n\terr = mlx5e_port_query_priority2buffer(mdev, old_prio2buffer);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < MLX5E_MAX_PRIORITY; i++) {\n\t\tif (dcb_buffer->prio2buffer[i] != old_prio2buffer[i]) {\n\t\t\tchanged |= MLX5E_PORT_BUFFER_PRIO2BUFFER;\n\t\t\tprio2buffer = dcb_buffer->prio2buffer;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terr = mlx5e_port_query_buffer(priv, &port_buffer);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++) {\n\t\tif (port_buffer.buffer[i].size != dcb_buffer->buffer_size[i]) {\n\t\t\tchanged |= MLX5E_PORT_BUFFER_SIZE;\n\t\t\tbuffer_size = dcb_buffer->buffer_size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!changed)\n\t\treturn 0;\n\n\tpriv->dcbx.manual_buffer = true;\n\terr = mlx5e_port_manual_buffer_config(priv, changed, dev->mtu, NULL,\n\t\t\t\t\t      buffer_size, prio2buffer);\n\treturn err;\n}\n\nstatic const struct dcbnl_rtnl_ops mlx5e_dcbnl_ops = {\n\t.ieee_getets\t= mlx5e_dcbnl_ieee_getets,\n\t.ieee_setets\t= mlx5e_dcbnl_ieee_setets,\n\t.ieee_getmaxrate = mlx5e_dcbnl_ieee_getmaxrate,\n\t.ieee_setmaxrate = mlx5e_dcbnl_ieee_setmaxrate,\n\t.ieee_getpfc\t= mlx5e_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t= mlx5e_dcbnl_ieee_setpfc,\n\t.ieee_setapp    = mlx5e_dcbnl_ieee_setapp,\n\t.ieee_delapp    = mlx5e_dcbnl_ieee_delapp,\n\t.getdcbx\t= mlx5e_dcbnl_getdcbx,\n\t.setdcbx\t= mlx5e_dcbnl_setdcbx,\n\t.dcbnl_getbuffer = mlx5e_dcbnl_getbuffer,\n\t.dcbnl_setbuffer = mlx5e_dcbnl_setbuffer,\n\n \n\t.setall         = mlx5e_dcbnl_setall,\n\t.getstate       = mlx5e_dcbnl_getstate,\n\t.getpermhwaddr  = mlx5e_dcbnl_getpermhwaddr,\n\n\t.setpgtccfgtx   = mlx5e_dcbnl_setpgtccfgtx,\n\t.setpgbwgcfgtx  = mlx5e_dcbnl_setpgbwgcfgtx,\n\t.getpgtccfgtx   = mlx5e_dcbnl_getpgtccfgtx,\n\t.getpgbwgcfgtx  = mlx5e_dcbnl_getpgbwgcfgtx,\n\n\t.setpfccfg      = mlx5e_dcbnl_setpfccfg,\n\t.getpfccfg      = mlx5e_dcbnl_getpfccfg,\n\t.getcap         = mlx5e_dcbnl_getcap,\n\t.getnumtcs      = mlx5e_dcbnl_getnumtcs,\n\t.getpfcstate    = mlx5e_dcbnl_getpfcstate,\n\t.setpfcstate    = mlx5e_dcbnl_setpfcstate,\n};\n\nvoid mlx5e_dcbnl_build_netdev(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tif (MLX5_CAP_GEN(mdev, vport_group_manager) && MLX5_CAP_GEN(mdev, qos))\n\t\tnetdev->dcbnl_ops = &mlx5e_dcbnl_ops;\n}\n\nstatic void mlx5e_dcbnl_query_dcbx_mode(struct mlx5e_priv *priv,\n\t\t\t\t\tenum mlx5_dcbx_oper_mode *mode)\n{\n\tu32 out[MLX5_ST_SZ_DW(dcbx_param)];\n\n\t*mode = MLX5E_DCBX_PARAM_VER_OPER_HOST;\n\n\tif (!mlx5_query_port_dcbx_param(priv->mdev, out))\n\t\t*mode = MLX5_GET(dcbx_param, out, version_oper);\n\n\t \n\tif (*mode != MLX5E_DCBX_PARAM_VER_OPER_HOST)\n\t\t*mode = MLX5E_DCBX_PARAM_VER_OPER_AUTO;\n}\n\nstatic void mlx5e_ets_init(struct mlx5e_priv *priv)\n{\n\tstruct ieee_ets ets;\n\tint err;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, ets))\n\t\treturn;\n\n\tmemset(&ets, 0, sizeof(ets));\n\tets.ets_cap = mlx5_max_tc(priv->mdev) + 1;\n\tfor (i = 0; i < ets.ets_cap; i++) {\n\t\tets.tc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;\n\t\tets.tc_tsa[i] = IEEE_8021QAZ_TSA_VENDOR;\n\t\tets.prio_tc[i] = i;\n\t}\n\n\tif (ets.ets_cap > 1) {\n\t\t \n\t\tets.prio_tc[0] = 1;\n\t\tets.prio_tc[1] = 0;\n\t}\n\n\terr = mlx5e_dcbnl_ieee_setets_core(priv, &ets);\n\tif (err)\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"%s, Failed to init ETS: %d\\n\", __func__, err);\n}\n\nenum {\n\tINIT,\n\tDELETE,\n};\n\nstatic void mlx5e_dcbnl_dscp_app(struct mlx5e_priv *priv, int action)\n{\n\tstruct dcb_app temp;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, vport_group_manager))\n\t\treturn;\n\n\tif (!MLX5_DSCP_SUPPORTED(priv->mdev))\n\t\treturn;\n\n\t \n\tif (priv->dcbx_dp.trust_state != MLX5_QPTS_TRUST_DSCP)\n\t\treturn;\n\n\ttemp.selector = IEEE_8021QAZ_APP_SEL_DSCP;\n\tfor (i = 0; i < MLX5E_MAX_DSCP; i++) {\n\t\ttemp.protocol = i;\n\t\ttemp.priority = priv->dcbx_dp.dscp2prio[i];\n\t\tif (action == INIT)\n\t\t\tdcb_ieee_setapp(priv->netdev, &temp);\n\t\telse\n\t\t\tdcb_ieee_delapp(priv->netdev, &temp);\n\t}\n\n\tpriv->dcbx.dscp_app_cnt = (action == INIT) ? MLX5E_MAX_DSCP : 0;\n}\n\nvoid mlx5e_dcbnl_init_app(struct mlx5e_priv *priv)\n{\n\tmlx5e_dcbnl_dscp_app(priv, INIT);\n}\n\nvoid mlx5e_dcbnl_delete_app(struct mlx5e_priv *priv)\n{\n\tmlx5e_dcbnl_dscp_app(priv, DELETE);\n}\n\nstatic void mlx5e_params_calc_trust_tx_min_inline_mode(struct mlx5_core_dev *mdev,\n\t\t\t\t\t\t       struct mlx5e_params *params,\n\t\t\t\t\t\t       u8 trust_state)\n{\n\tmlx5_query_min_inline(mdev, &params->tx_min_inline_mode);\n\tif (trust_state == MLX5_QPTS_TRUST_DSCP &&\n\t    params->tx_min_inline_mode == MLX5_INLINE_MODE_L2)\n\t\tparams->tx_min_inline_mode = MLX5_INLINE_MODE_IP;\n}\n\nstatic int mlx5e_update_trust_state_hw(struct mlx5e_priv *priv, void *context)\n{\n\tu8 *trust_state = context;\n\tint err;\n\n\terr = mlx5_set_trust_state(priv->mdev, *trust_state);\n\tif (err)\n\t\treturn err;\n\tWRITE_ONCE(priv->dcbx_dp.trust_state, *trust_state);\n\n\treturn 0;\n}\n\nstatic int mlx5e_set_trust_state(struct mlx5e_priv *priv, u8 trust_state)\n{\n\tstruct mlx5e_params new_params;\n\tbool reset = true;\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\n\tnew_params = priv->channels.params;\n\tmlx5e_params_calc_trust_tx_min_inline_mode(priv->mdev, &new_params,\n\t\t\t\t\t\t   trust_state);\n\n\t \n\tif (new_params.tx_min_inline_mode == priv->channels.params.tx_min_inline_mode)\n\t\treset = false;\n\n\terr = mlx5e_safe_switch_params(priv, &new_params,\n\t\t\t\t       mlx5e_update_trust_state_hw,\n\t\t\t\t       &trust_state, reset);\n\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_set_dscp2prio(struct mlx5e_priv *priv, u8 dscp, u8 prio)\n{\n\tint err;\n\n\terr = mlx5_set_dscp2prio(priv->mdev, dscp, prio);\n\tif (err)\n\t\treturn err;\n\n\tpriv->dcbx_dp.dscp2prio[dscp] = prio;\n\treturn err;\n}\n\nstatic int mlx5e_trust_initialize(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 trust_state;\n\tint err;\n\n\tif (!MLX5_DSCP_SUPPORTED(mdev)) {\n\t\tWRITE_ONCE(priv->dcbx_dp.trust_state, MLX5_QPTS_TRUST_PCP);\n\t\treturn 0;\n\t}\n\n\terr = mlx5_query_trust_state(priv->mdev, &trust_state);\n\tif (err)\n\t\treturn err;\n\tWRITE_ONCE(priv->dcbx_dp.trust_state, trust_state);\n\n\tif (priv->dcbx_dp.trust_state == MLX5_QPTS_TRUST_PCP && priv->dcbx.dscp_app_cnt) {\n\t\t \n\t\tpriv->dcbx_dp.trust_state = MLX5_QPTS_TRUST_DSCP;\n\t\tmlx5e_dcbnl_delete_app(priv);\n\t\tpriv->dcbx_dp.trust_state = MLX5_QPTS_TRUST_PCP;\n\t}\n\n\tmlx5e_params_calc_trust_tx_min_inline_mode(priv->mdev, &priv->channels.params,\n\t\t\t\t\t\t   priv->dcbx_dp.trust_state);\n\n\terr = mlx5_query_dscp2prio(priv->mdev, priv->dcbx_dp.dscp2prio);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#define MLX5E_BUFFER_CELL_SHIFT 7\n\nstatic u16 mlx5e_query_port_buffers_cell_size(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu32 out[MLX5_ST_SZ_DW(sbcam_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(sbcam_reg)] = {};\n\n\tif (!MLX5_CAP_GEN(mdev, sbcam_reg))\n\t\treturn (1 << MLX5E_BUFFER_CELL_SHIFT);\n\n\tif (mlx5_core_access_reg(mdev, in, sizeof(in), out, sizeof(out),\n\t\t\t\t MLX5_REG_SBCAM, 0, 0))\n\t\treturn (1 << MLX5E_BUFFER_CELL_SHIFT);\n\n\treturn MLX5_GET(sbcam_reg, out, cap_cell_size);\n}\n\nvoid mlx5e_dcbnl_initialize(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_dcbx *dcbx = &priv->dcbx;\n\n\tmlx5e_trust_initialize(priv);\n\n\tif (!MLX5_CAP_GEN(priv->mdev, qos))\n\t\treturn;\n\n\tif (MLX5_CAP_GEN(priv->mdev, dcbx))\n\t\tmlx5e_dcbnl_query_dcbx_mode(priv, &dcbx->mode);\n\n\tpriv->dcbx.cap = DCB_CAP_DCBX_VER_CEE |\n\t\t\t DCB_CAP_DCBX_VER_IEEE;\n\tif (priv->dcbx.mode == MLX5E_DCBX_PARAM_VER_OPER_HOST)\n\t\tpriv->dcbx.cap |= DCB_CAP_DCBX_HOST;\n\n\tpriv->dcbx.port_buff_cell_sz = mlx5e_query_port_buffers_cell_size(priv);\n\tpriv->dcbx.manual_buffer = false;\n\tpriv->dcbx.cable_len = MLX5E_DEFAULT_CABLE_LEN;\n\n\tmlx5e_ets_init(priv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}