{
  "module_name": "gid.c",
  "hash_id": "610747d152efb28e09749dd2c1ce3d73d02c34533665276e8534384484e6853f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/gid.c",
  "human_readable_source": " \n\n#include <linux/mlx5/driver.h>\n#include <linux/etherdevice.h>\n#include <linux/idr.h>\n#include \"mlx5_core.h\"\n#include \"lib/mlx5.h\"\n\nvoid mlx5_init_reserved_gids(struct mlx5_core_dev *dev)\n{\n\tunsigned int tblsz = MLX5_CAP_ROCE(dev, roce_address_table_size);\n\n\tida_init(&dev->roce.reserved_gids.ida);\n\tdev->roce.reserved_gids.start = tblsz;\n\tdev->roce.reserved_gids.count = 0;\n}\n\nvoid mlx5_cleanup_reserved_gids(struct mlx5_core_dev *dev)\n{\n\tWARN_ON(!ida_is_empty(&dev->roce.reserved_gids.ida));\n\tdev->roce.reserved_gids.start = 0;\n\tdev->roce.reserved_gids.count = 0;\n\tida_destroy(&dev->roce.reserved_gids.ida);\n}\n\nint mlx5_core_reserve_gids(struct mlx5_core_dev *dev, unsigned int count)\n{\n\tif (dev->roce.reserved_gids.start < count) {\n\t\tmlx5_core_warn(dev, \"GID table exhausted attempting to reserve %d more GIDs\\n\",\n\t\t\t       count);\n\t\treturn -ENOMEM;\n\t}\n\tif (dev->roce.reserved_gids.count + count > MLX5_MAX_RESERVED_GIDS) {\n\t\tmlx5_core_warn(dev, \"Unable to reserve %d more GIDs\\n\", count);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->roce.reserved_gids.start -= count;\n\tdev->roce.reserved_gids.count += count;\n\tmlx5_core_dbg(dev, \"Reserved %u GIDs starting at %u\\n\",\n\t\t      dev->roce.reserved_gids.count,\n\t\t      dev->roce.reserved_gids.start);\n\treturn 0;\n}\n\nvoid mlx5_core_unreserve_gids(struct mlx5_core_dev *dev, unsigned int count)\n{\n\tWARN(count > dev->roce.reserved_gids.count, \"Unreserving %u GIDs when only %u reserved\",\n\t     count, dev->roce.reserved_gids.count);\n\n\tdev->roce.reserved_gids.start += count;\n\tdev->roce.reserved_gids.count -= count;\n\tmlx5_core_dbg(dev, \"%u GIDs starting at %u left reserved\\n\",\n\t\t      dev->roce.reserved_gids.count,\n\t\t      dev->roce.reserved_gids.start);\n}\n\nint mlx5_core_reserved_gid_alloc(struct mlx5_core_dev *dev, int *gid_index)\n{\n\tint end = dev->roce.reserved_gids.start +\n\t\t  dev->roce.reserved_gids.count - 1;\n\tint index = 0;\n\n\tindex = ida_alloc_range(&dev->roce.reserved_gids.ida,\n\t\t\t\tdev->roce.reserved_gids.start, end,\n\t\t\t\tGFP_KERNEL);\n\tif (index < 0)\n\t\treturn index;\n\n\tmlx5_core_dbg(dev, \"Allocating reserved GID %u\\n\", index);\n\t*gid_index = index;\n\treturn 0;\n}\n\nvoid mlx5_core_reserved_gid_free(struct mlx5_core_dev *dev, int gid_index)\n{\n\tmlx5_core_dbg(dev, \"Freeing reserved GID %u\\n\", gid_index);\n\tida_free(&dev->roce.reserved_gids.ida, gid_index);\n}\n\nunsigned int mlx5_core_reserved_gids_count(struct mlx5_core_dev *dev)\n{\n\treturn dev->roce.reserved_gids.count;\n}\nEXPORT_SYMBOL_GPL(mlx5_core_reserved_gids_count);\n\nint mlx5_core_roce_gid_set(struct mlx5_core_dev *dev, unsigned int index,\n\t\t\t   u8 roce_version, u8 roce_l3_type, const u8 *gid,\n\t\t\t   const u8 *mac, bool vlan, u16 vlan_id, u8 port_num)\n{\n#define MLX5_SET_RA(p, f, v) MLX5_SET(roce_addr_layout, p, f, v)\n\tu32 in[MLX5_ST_SZ_DW(set_roce_address_in)] = {};\n\tvoid *in_addr = MLX5_ADDR_OF(set_roce_address_in, in, roce_address);\n\tchar *addr_l3_addr = MLX5_ADDR_OF(roce_addr_layout, in_addr,\n\t\t\t\t\t  source_l3_address);\n\tvoid *addr_mac = MLX5_ADDR_OF(roce_addr_layout, in_addr,\n\t\t\t\t      source_mac_47_32);\n\tint gidsz = MLX5_FLD_SZ_BYTES(roce_addr_layout, source_l3_address);\n\n\tif (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\n\t\treturn -EINVAL;\n\n\tif (gid) {\n\t\tif (vlan) {\n\t\t\tMLX5_SET_RA(in_addr, vlan_valid, 1);\n\t\t\tMLX5_SET_RA(in_addr, vlan_id, vlan_id);\n\t\t}\n\n\t\tether_addr_copy(addr_mac, mac);\n\t\tmemcpy(addr_l3_addr, gid, gidsz);\n\t}\n\tMLX5_SET_RA(in_addr, roce_version, roce_version);\n\tMLX5_SET_RA(in_addr, roce_l3_type, roce_l3_type);\n\n\tif (MLX5_CAP_GEN(dev, num_vhca_ports) > 0)\n\t\tMLX5_SET(set_roce_address_in, in, vhca_port_num, port_num);\n\n\tMLX5_SET(set_roce_address_in, in, roce_address_index, index);\n\tMLX5_SET(set_roce_address_in, in, opcode, MLX5_CMD_OP_SET_ROCE_ADDRESS);\n\treturn mlx5_cmd_exec_in(dev, set_roce_address, in);\n}\nEXPORT_SYMBOL(mlx5_core_roce_gid_set);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}