{
  "module_name": "helper.c",
  "hash_id": "84a17db665e87ffeaa61b14fb1d9efa58eb66ea0270e5e863cbd1ac3f6a4a33d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/acl/helper.c",
  "human_readable_source": "\n \n\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"helper.h\"\n\nstruct mlx5_flow_table *\nesw_acl_table_create(struct mlx5_eswitch *esw, struct mlx5_vport *vport, int ns, int size)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_namespace *root_ns;\n\tstruct mlx5_flow_table *acl;\n\tint acl_supported;\n\tu16 vport_num;\n\tint err;\n\n\tacl_supported = (ns == MLX5_FLOW_NAMESPACE_ESW_INGRESS) ?\n\t\t\tMLX5_CAP_ESW_INGRESS_ACL(dev, ft_support) :\n\t\t\tMLX5_CAP_ESW_EGRESS_ACL(dev, ft_support);\n\n\tif (!acl_supported)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tvport_num = vport->vport;\n\tesw_debug(dev, \"Create vport[%d] %s ACL table\\n\", vport_num,\n\t\t  ns == MLX5_FLOW_NAMESPACE_ESW_INGRESS ? \"ingress\" : \"egress\");\n\n\troot_ns = mlx5_get_flow_vport_acl_namespace(dev, ns, vport->index);\n\tif (!root_ns) {\n\t\tesw_warn(dev, \"Failed to get E-Switch root namespace for vport (%d)\\n\",\n\t\t\t vport_num);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tft_attr.max_fte = size;\n\tif (vport_num || mlx5_core_is_ecpf(esw->dev))\n\t\tft_attr.flags = MLX5_FLOW_TABLE_OTHER_VPORT;\n\tacl = mlx5_create_vport_flow_table(root_ns, &ft_attr, vport_num);\n\tif (IS_ERR(acl)) {\n\t\terr = PTR_ERR(acl);\n\t\tesw_warn(dev, \"vport[%d] create %s ACL table, err(%d)\\n\", vport_num,\n\t\t\t ns == MLX5_FLOW_NAMESPACE_ESW_INGRESS ? \"ingress\" : \"egress\", err);\n\t}\n\treturn acl;\n}\n\nint esw_egress_acl_vlan_create(struct mlx5_eswitch *esw,\n\t\t\t       struct mlx5_vport *vport,\n\t\t\t       struct mlx5_flow_destination *fwd_dest,\n\t\t\t       u16 vlan_id, u32 flow_action)\n{\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\n\tif (vport->egress.allowed_vlan)\n\t\treturn -EEXIST;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.cvlan_tag);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_value, outer_headers.cvlan_tag);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.first_vid);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.first_vid, vlan_id);\n\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\tflow_act.action = flow_action;\n\tvport->egress.allowed_vlan =\n\t\tmlx5_add_flow_rules(vport->egress.acl, spec,\n\t\t\t\t    &flow_act, fwd_dest, 0);\n\tif (IS_ERR(vport->egress.allowed_vlan)) {\n\t\terr = PTR_ERR(vport->egress.allowed_vlan);\n\t\tesw_warn(esw->dev,\n\t\t\t \"vport[%d] configure egress vlan rule failed, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tvport->egress.allowed_vlan = NULL;\n\t}\n\n\tkvfree(spec);\n\treturn err;\n}\n\nvoid esw_acl_egress_vlan_destroy(struct mlx5_vport *vport)\n{\n\tif (!IS_ERR_OR_NULL(vport->egress.allowed_vlan)) {\n\t\tmlx5_del_flow_rules(vport->egress.allowed_vlan);\n\t\tvport->egress.allowed_vlan = NULL;\n\t}\n}\n\nint esw_acl_egress_vlan_grp_create(struct mlx5_eswitch *esw, struct mlx5_vport *vport)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *vlan_grp;\n\tvoid *match_criteria;\n\tu32 *flow_group_in;\n\tint ret = 0;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_flow_group_in, flow_group_in,\n\t\t match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tmatch_criteria = MLX5_ADDR_OF(create_flow_group_in,\n\t\t\t\t      flow_group_in, match_criteria);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.cvlan_tag);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.first_vid);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 0);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 0);\n\n\tvlan_grp = mlx5_create_flow_group(vport->egress.acl, flow_group_in);\n\tif (IS_ERR(vlan_grp)) {\n\t\tret = PTR_ERR(vlan_grp);\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create E-Switch vport[%d] egress pop vlans flow group, err(%d)\\n\",\n\t\t\t vport->vport, ret);\n\t\tgoto out;\n\t}\n\tvport->egress.vlan_grp = vlan_grp;\n\nout:\n\tkvfree(flow_group_in);\n\treturn ret;\n}\n\nvoid esw_acl_egress_vlan_grp_destroy(struct mlx5_vport *vport)\n{\n\tif (!IS_ERR_OR_NULL(vport->egress.vlan_grp)) {\n\t\tmlx5_destroy_flow_group(vport->egress.vlan_grp);\n\t\tvport->egress.vlan_grp = NULL;\n\t}\n}\n\nvoid esw_acl_egress_table_destroy(struct mlx5_vport *vport)\n{\n\tif (IS_ERR_OR_NULL(vport->egress.acl))\n\t\treturn;\n\n\tmlx5_destroy_flow_table(vport->egress.acl);\n\tvport->egress.acl = NULL;\n}\n\nvoid esw_acl_ingress_table_destroy(struct mlx5_vport *vport)\n{\n\tif (!vport->ingress.acl)\n\t\treturn;\n\n\tmlx5_destroy_flow_table(vport->ingress.acl);\n\tvport->ingress.acl = NULL;\n}\n\nvoid esw_acl_ingress_allow_rule_destroy(struct mlx5_vport *vport)\n{\n\tif (!vport->ingress.allow_rule)\n\t\treturn;\n\n\tmlx5_del_flow_rules(vport->ingress.allow_rule);\n\tvport->ingress.allow_rule = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}