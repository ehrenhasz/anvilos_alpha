{
  "module_name": "rss.c",
  "hash_id": "b960d1e85f228ce2bf9dec026b0536d0a9103390714f0060a2c2b766cb71c8b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/rss.c",
  "human_readable_source": "\n\n\n#include \"rss.h\"\n\n#define mlx5e_rss_warn(__dev, format, ...)\t\t\t\\\n\tdev_warn((__dev)->device, \"%s:%d:(pid %d): \" format,\t\\\n\t\t __func__, __LINE__, current->pid,\t\t\\\n\t\t ##__VA_ARGS__)\n\nstatic const struct mlx5e_rss_params_traffic_type rss_default_config[MLX5E_NUM_INDIR_TIRS] = {\n\t[MLX5_TT_IPV4_TCP] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,\n\t\t.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,\n\t\t.rx_hash_fields = MLX5_HASH_IP_L4PORTS,\n\t},\n\t[MLX5_TT_IPV6_TCP] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,\n\t\t.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,\n\t\t.rx_hash_fields = MLX5_HASH_IP_L4PORTS,\n\t},\n\t[MLX5_TT_IPV4_UDP] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,\n\t\t.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,\n\t\t.rx_hash_fields = MLX5_HASH_IP_L4PORTS,\n\t},\n\t[MLX5_TT_IPV6_UDP] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,\n\t\t.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,\n\t\t.rx_hash_fields = MLX5_HASH_IP_L4PORTS,\n\t},\n\t[MLX5_TT_IPV4_IPSEC_AH] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,\n\t\t.l4_prot_type = 0,\n\t\t.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,\n\t},\n\t[MLX5_TT_IPV6_IPSEC_AH] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,\n\t\t.l4_prot_type = 0,\n\t\t.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,\n\t},\n\t[MLX5_TT_IPV4_IPSEC_ESP] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,\n\t\t.l4_prot_type = 0,\n\t\t.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,\n\t},\n\t[MLX5_TT_IPV6_IPSEC_ESP] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,\n\t\t.l4_prot_type = 0,\n\t\t.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,\n\t},\n\t[MLX5_TT_IPV4] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,\n\t\t.l4_prot_type = 0,\n\t\t.rx_hash_fields = MLX5_HASH_IP,\n\t},\n\t[MLX5_TT_IPV6] = {\n\t\t.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,\n\t\t.l4_prot_type = 0,\n\t\t.rx_hash_fields = MLX5_HASH_IP,\n\t},\n};\n\nstruct mlx5e_rss_params_traffic_type\nmlx5e_rss_get_default_tt_config(enum mlx5_traffic_types tt)\n{\n\treturn rss_default_config[tt];\n}\n\nstruct mlx5e_rss {\n\tstruct mlx5e_rss_params_hash hash;\n\tstruct mlx5e_rss_params_indir indir;\n\tu32 rx_hash_fields[MLX5E_NUM_INDIR_TIRS];\n\tstruct mlx5e_tir *tir[MLX5E_NUM_INDIR_TIRS];\n\tstruct mlx5e_tir *inner_tir[MLX5E_NUM_INDIR_TIRS];\n\tstruct mlx5e_rqt rqt;\n\tstruct mlx5_core_dev *mdev;\n\tu32 drop_rqn;\n\tbool inner_ft_support;\n\tbool enabled;\n\trefcount_t refcnt;\n};\n\nstruct mlx5e_rss *mlx5e_rss_alloc(void)\n{\n\treturn kvzalloc(sizeof(struct mlx5e_rss), GFP_KERNEL);\n}\n\nvoid mlx5e_rss_free(struct mlx5e_rss *rss)\n{\n\tkvfree(rss);\n}\n\nstatic void mlx5e_rss_params_init(struct mlx5e_rss *rss)\n{\n\tenum mlx5_traffic_types tt;\n\n\trss->hash.hfunc = ETH_RSS_HASH_TOP;\n\tnetdev_rss_key_fill(rss->hash.toeplitz_hash_key,\n\t\t\t    sizeof(rss->hash.toeplitz_hash_key));\n\tfor (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)\n\t\trss->rx_hash_fields[tt] =\n\t\t\tmlx5e_rss_get_default_tt_config(tt).rx_hash_fields;\n}\n\nstatic struct mlx5e_tir **rss_get_tirp(struct mlx5e_rss *rss, enum mlx5_traffic_types tt,\n\t\t\t\t       bool inner)\n{\n\treturn inner ? &rss->inner_tir[tt] : &rss->tir[tt];\n}\n\nstatic struct mlx5e_tir *rss_get_tir(struct mlx5e_rss *rss, enum mlx5_traffic_types tt,\n\t\t\t\t     bool inner)\n{\n\treturn *rss_get_tirp(rss, tt, inner);\n}\n\nstatic struct mlx5e_rss_params_traffic_type\nmlx5e_rss_get_tt_config(struct mlx5e_rss *rss, enum mlx5_traffic_types tt)\n{\n\tstruct mlx5e_rss_params_traffic_type rss_tt;\n\n\trss_tt = mlx5e_rss_get_default_tt_config(tt);\n\trss_tt.rx_hash_fields = rss->rx_hash_fields[tt];\n\treturn rss_tt;\n}\n\nstatic int mlx5e_rss_create_tir(struct mlx5e_rss *rss,\n\t\t\t\tenum mlx5_traffic_types tt,\n\t\t\t\tconst struct mlx5e_packet_merge_param *init_pkt_merge_param,\n\t\t\t\tbool inner)\n{\n\tstruct mlx5e_rss_params_traffic_type rss_tt;\n\tstruct mlx5e_tir_builder *builder;\n\tstruct mlx5e_tir **tir_p;\n\tstruct mlx5e_tir *tir;\n\tu32 rqtn;\n\tint err;\n\n\tif (inner && !rss->inner_ft_support) {\n\t\tmlx5e_rss_warn(rss->mdev,\n\t\t\t       \"Cannot create inner indirect TIR[%d], RSS inner FT is not supported.\\n\",\n\t\t\t       tt);\n\t\treturn -EINVAL;\n\t}\n\n\ttir_p = rss_get_tirp(rss, tt, inner);\n\tif (*tir_p)\n\t\treturn -EINVAL;\n\n\ttir = kvzalloc(sizeof(*tir), GFP_KERNEL);\n\tif (!tir)\n\t\treturn -ENOMEM;\n\n\tbuilder = mlx5e_tir_builder_alloc(false);\n\tif (!builder) {\n\t\terr = -ENOMEM;\n\t\tgoto free_tir;\n\t}\n\n\trqtn = mlx5e_rqt_get_rqtn(&rss->rqt);\n\tmlx5e_tir_builder_build_rqt(builder, rss->mdev->mlx5e_res.hw_objs.td.tdn,\n\t\t\t\t    rqtn, rss->inner_ft_support);\n\tmlx5e_tir_builder_build_packet_merge(builder, init_pkt_merge_param);\n\trss_tt = mlx5e_rss_get_tt_config(rss, tt);\n\tmlx5e_tir_builder_build_rss(builder, &rss->hash, &rss_tt, inner);\n\n\terr = mlx5e_tir_init(tir, builder, rss->mdev, true);\n\tmlx5e_tir_builder_free(builder);\n\tif (err) {\n\t\tmlx5e_rss_warn(rss->mdev, \"Failed to create %sindirect TIR: err = %d, tt = %d\\n\",\n\t\t\t       inner ? \"inner \" : \"\", err, tt);\n\t\tgoto free_tir;\n\t}\n\n\t*tir_p = tir;\n\treturn 0;\n\nfree_tir:\n\tkvfree(tir);\n\treturn err;\n}\n\nstatic void mlx5e_rss_destroy_tir(struct mlx5e_rss *rss, enum mlx5_traffic_types tt,\n\t\t\t\t  bool inner)\n{\n\tstruct mlx5e_tir **tir_p;\n\tstruct mlx5e_tir *tir;\n\n\ttir_p = rss_get_tirp(rss, tt, inner);\n\tif (!*tir_p)\n\t\treturn;\n\n\ttir = *tir_p;\n\tmlx5e_tir_destroy(tir);\n\tkvfree(tir);\n\t*tir_p = NULL;\n}\n\nstatic int mlx5e_rss_create_tirs(struct mlx5e_rss *rss,\n\t\t\t\t const struct mlx5e_packet_merge_param *init_pkt_merge_param,\n\t\t\t\t bool inner)\n{\n\tenum mlx5_traffic_types tt, max_tt;\n\tint err;\n\n\tfor (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {\n\t\terr = mlx5e_rss_create_tir(rss, tt, init_pkt_merge_param, inner);\n\t\tif (err)\n\t\t\tgoto err_destroy_tirs;\n\t}\n\n\treturn 0;\n\nerr_destroy_tirs:\n\tmax_tt = tt;\n\tfor (tt = 0; tt < max_tt; tt++)\n\t\tmlx5e_rss_destroy_tir(rss, tt, inner);\n\treturn err;\n}\n\nstatic void mlx5e_rss_destroy_tirs(struct mlx5e_rss *rss, bool inner)\n{\n\tenum mlx5_traffic_types tt;\n\n\tfor (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)\n\t\tmlx5e_rss_destroy_tir(rss, tt, inner);\n}\n\nstatic int mlx5e_rss_update_tir(struct mlx5e_rss *rss, enum mlx5_traffic_types tt,\n\t\t\t\tbool inner)\n{\n\tstruct mlx5e_rss_params_traffic_type rss_tt;\n\tstruct mlx5e_tir_builder *builder;\n\tstruct mlx5e_tir *tir;\n\tint err;\n\n\ttir = rss_get_tir(rss, tt, inner);\n\tif (!tir)\n\t\treturn 0;\n\n\tbuilder = mlx5e_tir_builder_alloc(true);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\trss_tt = mlx5e_rss_get_tt_config(rss, tt);\n\n\tmlx5e_tir_builder_build_rss(builder, &rss->hash, &rss_tt, inner);\n\terr = mlx5e_tir_modify(tir, builder);\n\n\tmlx5e_tir_builder_free(builder);\n\treturn err;\n}\n\nstatic int mlx5e_rss_update_tirs(struct mlx5e_rss *rss)\n{\n\tenum mlx5_traffic_types tt;\n\tint err, retval;\n\n\tretval = 0;\n\n\tfor (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {\n\t\terr = mlx5e_rss_update_tir(rss, tt, false);\n\t\tif (err) {\n\t\t\tretval = retval ? : err;\n\t\t\tmlx5e_rss_warn(rss->mdev,\n\t\t\t\t       \"Failed to update RSS hash of indirect TIR for traffic type %d: err = %d\\n\",\n\t\t\t\t       tt, err);\n\t\t}\n\n\t\tif (!rss->inner_ft_support)\n\t\t\tcontinue;\n\n\t\terr = mlx5e_rss_update_tir(rss, tt, true);\n\t\tif (err) {\n\t\t\tretval = retval ? : err;\n\t\t\tmlx5e_rss_warn(rss->mdev,\n\t\t\t\t       \"Failed to update RSS hash of inner indirect TIR for traffic type %d: err = %d\\n\",\n\t\t\t\t       tt, err);\n\t\t}\n\t}\n\treturn retval;\n}\n\nint mlx5e_rss_init_no_tirs(struct mlx5e_rss *rss, struct mlx5_core_dev *mdev,\n\t\t\t   bool inner_ft_support, u32 drop_rqn)\n{\n\trss->mdev = mdev;\n\trss->inner_ft_support = inner_ft_support;\n\trss->drop_rqn = drop_rqn;\n\n\tmlx5e_rss_params_init(rss);\n\trefcount_set(&rss->refcnt, 1);\n\n\treturn mlx5e_rqt_init_direct(&rss->rqt, mdev, true, drop_rqn);\n}\n\nint mlx5e_rss_init(struct mlx5e_rss *rss, struct mlx5_core_dev *mdev,\n\t\t   bool inner_ft_support, u32 drop_rqn,\n\t\t   const struct mlx5e_packet_merge_param *init_pkt_merge_param)\n{\n\tint err;\n\n\terr = mlx5e_rss_init_no_tirs(rss, mdev, inner_ft_support, drop_rqn);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = mlx5e_rss_create_tirs(rss, init_pkt_merge_param, false);\n\tif (err)\n\t\tgoto err_destroy_rqt;\n\n\tif (inner_ft_support) {\n\t\terr = mlx5e_rss_create_tirs(rss, init_pkt_merge_param, true);\n\t\tif (err)\n\t\t\tgoto err_destroy_tirs;\n\t}\n\n\treturn 0;\n\nerr_destroy_tirs:\n\tmlx5e_rss_destroy_tirs(rss, false);\nerr_destroy_rqt:\n\tmlx5e_rqt_destroy(&rss->rqt);\nerr_out:\n\treturn err;\n}\n\nint mlx5e_rss_cleanup(struct mlx5e_rss *rss)\n{\n\tif (!refcount_dec_if_one(&rss->refcnt))\n\t\treturn -EBUSY;\n\n\tmlx5e_rss_destroy_tirs(rss, false);\n\n\tif (rss->inner_ft_support)\n\t\tmlx5e_rss_destroy_tirs(rss, true);\n\n\tmlx5e_rqt_destroy(&rss->rqt);\n\n\treturn 0;\n}\n\nvoid mlx5e_rss_refcnt_inc(struct mlx5e_rss *rss)\n{\n\trefcount_inc(&rss->refcnt);\n}\n\nvoid mlx5e_rss_refcnt_dec(struct mlx5e_rss *rss)\n{\n\trefcount_dec(&rss->refcnt);\n}\n\nunsigned int mlx5e_rss_refcnt_read(struct mlx5e_rss *rss)\n{\n\treturn refcount_read(&rss->refcnt);\n}\n\nu32 mlx5e_rss_get_tirn(struct mlx5e_rss *rss, enum mlx5_traffic_types tt,\n\t\t       bool inner)\n{\n\tstruct mlx5e_tir *tir;\n\n\tWARN_ON(inner && !rss->inner_ft_support);\n\ttir = rss_get_tir(rss, tt, inner);\n\tWARN_ON(!tir);\n\n\treturn mlx5e_tir_get_tirn(tir);\n}\n\n \nint mlx5e_rss_obtain_tirn(struct mlx5e_rss *rss,\n\t\t\t  enum mlx5_traffic_types tt,\n\t\t\t  const struct mlx5e_packet_merge_param *init_pkt_merge_param,\n\t\t\t  bool inner, u32 *tirn)\n{\n\tstruct mlx5e_tir *tir;\n\n\ttir = rss_get_tir(rss, tt, inner);\n\tif (!tir) {  \n\t\tint err;\n\n\t\terr = mlx5e_rss_create_tir(rss, tt, init_pkt_merge_param, inner);\n\t\tif (err)\n\t\t\treturn err;\n\t\ttir = rss_get_tir(rss, tt, inner);\n\t}\n\n\t*tirn = mlx5e_tir_get_tirn(tir);\n\treturn 0;\n}\n\nstatic int mlx5e_rss_apply(struct mlx5e_rss *rss, u32 *rqns, unsigned int num_rqns)\n{\n\tint err;\n\n\terr = mlx5e_rqt_redirect_indir(&rss->rqt, rqns, num_rqns, rss->hash.hfunc, &rss->indir);\n\tif (err)\n\t\tmlx5e_rss_warn(rss->mdev, \"Failed to redirect RQT %#x to channels: err = %d\\n\",\n\t\t\t       mlx5e_rqt_get_rqtn(&rss->rqt), err);\n\treturn err;\n}\n\nvoid mlx5e_rss_enable(struct mlx5e_rss *rss, u32 *rqns, unsigned int num_rqns)\n{\n\trss->enabled = true;\n\tmlx5e_rss_apply(rss, rqns, num_rqns);\n}\n\nvoid mlx5e_rss_disable(struct mlx5e_rss *rss)\n{\n\tint err;\n\n\trss->enabled = false;\n\terr = mlx5e_rqt_redirect_direct(&rss->rqt, rss->drop_rqn);\n\tif (err)\n\t\tmlx5e_rss_warn(rss->mdev, \"Failed to redirect RQT %#x to drop RQ %#x: err = %d\\n\",\n\t\t\t       mlx5e_rqt_get_rqtn(&rss->rqt), rss->drop_rqn, err);\n}\n\nint mlx5e_rss_packet_merge_set_param(struct mlx5e_rss *rss,\n\t\t\t\t     struct mlx5e_packet_merge_param *pkt_merge_param)\n{\n\tstruct mlx5e_tir_builder *builder;\n\tenum mlx5_traffic_types tt;\n\tint err, final_err;\n\n\tbuilder = mlx5e_tir_builder_alloc(true);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\tmlx5e_tir_builder_build_packet_merge(builder, pkt_merge_param);\n\n\tfinal_err = 0;\n\n\tfor (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {\n\t\tstruct mlx5e_tir *tir;\n\n\t\ttir = rss_get_tir(rss, tt, false);\n\t\tif (!tir)\n\t\t\tgoto inner_tir;\n\t\terr = mlx5e_tir_modify(tir, builder);\n\t\tif (err) {\n\t\t\tmlx5e_rss_warn(rss->mdev, \"Failed to update packet merge state of indirect TIR %#x for traffic type %d: err = %d\\n\",\n\t\t\t\t       mlx5e_tir_get_tirn(tir), tt, err);\n\t\t\tif (!final_err)\n\t\t\t\tfinal_err = err;\n\t\t}\n\ninner_tir:\n\t\tif (!rss->inner_ft_support)\n\t\t\tcontinue;\n\n\t\ttir = rss_get_tir(rss, tt, true);\n\t\tif (!tir)\n\t\t\tcontinue;\n\t\terr = mlx5e_tir_modify(tir, builder);\n\t\tif (err) {\n\t\t\tmlx5e_rss_warn(rss->mdev, \"Failed to update packet merge state of inner indirect TIR %#x for traffic type %d: err = %d\\n\",\n\t\t\t\t       mlx5e_tir_get_tirn(tir), tt, err);\n\t\t\tif (!final_err)\n\t\t\t\tfinal_err = err;\n\t\t}\n\t}\n\n\tmlx5e_tir_builder_free(builder);\n\treturn final_err;\n}\n\nint mlx5e_rss_get_rxfh(struct mlx5e_rss *rss, u32 *indir, u8 *key, u8 *hfunc)\n{\n\tunsigned int i;\n\n\tif (indir)\n\t\tfor (i = 0; i < MLX5E_INDIR_RQT_SIZE; i++)\n\t\t\tindir[i] = rss->indir.table[i];\n\n\tif (key)\n\t\tmemcpy(key, rss->hash.toeplitz_hash_key,\n\t\t       sizeof(rss->hash.toeplitz_hash_key));\n\n\tif (hfunc)\n\t\t*hfunc = rss->hash.hfunc;\n\n\treturn 0;\n}\n\nint mlx5e_rss_set_rxfh(struct mlx5e_rss *rss, const u32 *indir,\n\t\t       const u8 *key, const u8 *hfunc,\n\t\t       u32 *rqns, unsigned int num_rqns)\n{\n\tbool changed_indir = false;\n\tbool changed_hash = false;\n\tstruct mlx5e_rss *old_rss;\n\tint err = 0;\n\n\told_rss = mlx5e_rss_alloc();\n\tif (!old_rss)\n\t\treturn -ENOMEM;\n\n\t*old_rss = *rss;\n\n\tif (hfunc && *hfunc != rss->hash.hfunc) {\n\t\tswitch (*hfunc) {\n\t\tcase ETH_RSS_HASH_XOR:\n\t\tcase ETH_RSS_HASH_TOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tchanged_hash = true;\n\t\tchanged_indir = true;\n\t\trss->hash.hfunc = *hfunc;\n\t}\n\n\tif (key) {\n\t\tif (rss->hash.hfunc == ETH_RSS_HASH_TOP)\n\t\t\tchanged_hash = true;\n\t\tmemcpy(rss->hash.toeplitz_hash_key, key,\n\t\t       sizeof(rss->hash.toeplitz_hash_key));\n\t}\n\n\tif (indir) {\n\t\tunsigned int i;\n\n\t\tchanged_indir = true;\n\n\t\tfor (i = 0; i < MLX5E_INDIR_RQT_SIZE; i++)\n\t\t\trss->indir.table[i] = indir[i];\n\t}\n\n\tif (changed_indir && rss->enabled) {\n\t\terr = mlx5e_rss_apply(rss, rqns, num_rqns);\n\t\tif (err) {\n\t\t\t*rss = *old_rss;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (changed_hash)\n\t\tmlx5e_rss_update_tirs(rss);\n\nout:\n\tmlx5e_rss_free(old_rss);\n\treturn err;\n}\n\nstruct mlx5e_rss_params_hash mlx5e_rss_get_hash(struct mlx5e_rss *rss)\n{\n\treturn rss->hash;\n}\n\nu8 mlx5e_rss_get_hash_fields(struct mlx5e_rss *rss, enum mlx5_traffic_types tt)\n{\n\treturn rss->rx_hash_fields[tt];\n}\n\nint mlx5e_rss_set_hash_fields(struct mlx5e_rss *rss, enum mlx5_traffic_types tt,\n\t\t\t      u8 rx_hash_fields)\n{\n\tu8 old_rx_hash_fields;\n\tint err;\n\n\told_rx_hash_fields = rss->rx_hash_fields[tt];\n\n\tif (old_rx_hash_fields == rx_hash_fields)\n\t\treturn 0;\n\n\trss->rx_hash_fields[tt] = rx_hash_fields;\n\n\terr = mlx5e_rss_update_tir(rss, tt, false);\n\tif (err) {\n\t\trss->rx_hash_fields[tt] = old_rx_hash_fields;\n\t\tmlx5e_rss_warn(rss->mdev,\n\t\t\t       \"Failed to update RSS hash fields of indirect TIR for traffic type %d: err = %d\\n\",\n\t\t\t       tt, err);\n\t\treturn err;\n\t}\n\n\tif (!(rss->inner_ft_support))\n\t\treturn 0;\n\n\terr = mlx5e_rss_update_tir(rss, tt, true);\n\tif (err) {\n\t\t \n\t\trss->rx_hash_fields[tt] = old_rx_hash_fields;\n\t\tmlx5e_rss_warn(rss->mdev,\n\t\t\t       \"Failed to update RSS hash fields of inner indirect TIR for traffic type %d: err = %d\\n\",\n\t\t\t       tt, err);\n\t\tif (mlx5e_rss_update_tir(rss, tt, false))\n\t\t\tmlx5e_rss_warn(rss->mdev,\n\t\t\t\t       \"Partial update of RSS hash fields happened: failed to revert indirect TIR for traffic type %d to the old values\\n\",\n\t\t\t\t       tt);\n\t}\n\n\treturn err;\n}\n\nvoid mlx5e_rss_set_indir_uniform(struct mlx5e_rss *rss, unsigned int nch)\n{\n\tmlx5e_rss_params_indir_init_uniform(&rss->indir, nch);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}