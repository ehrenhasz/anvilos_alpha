{
  "module_name": "reporter_vnic.c",
  "hash_id": "8e4c8df1cb99e3a1d489624a0c22d6b3257936f32ed094f204cd539c74d66373",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/diag/reporter_vnic.c",
  "human_readable_source": "\n \n\n#include \"reporter_vnic.h\"\n#include \"en_stats.h\"\n#include \"devlink.h\"\n\n#define VNIC_ENV_GET64(vnic_env_stats, c) \\\n\tMLX5_GET64(query_vnic_env_out, (vnic_env_stats)->query_vnic_env_out, \\\n\t\t vport_env.c)\n\nstruct mlx5_vnic_diag_stats {\n\t__be64 query_vnic_env_out[MLX5_ST_SZ_QW(query_vnic_env_out)];\n};\n\nint mlx5_reporter_vnic_diagnose_counters(struct mlx5_core_dev *dev,\n\t\t\t\t\t struct devlink_fmsg *fmsg,\n\t\t\t\t\t u16 vport_num, bool other_vport)\n{\n\tu32 in[MLX5_ST_SZ_DW(query_vnic_env_in)] = {};\n\tstruct mlx5_vnic_diag_stats vnic;\n\tint err;\n\n\tMLX5_SET(query_vnic_env_in, in, opcode, MLX5_CMD_OP_QUERY_VNIC_ENV);\n\tMLX5_SET(query_vnic_env_in, in, vport_number, vport_num);\n\tMLX5_SET(query_vnic_env_in, in, other_vport, !!other_vport);\n\n\terr = mlx5_cmd_exec_inout(dev, query_vnic_env, in, &vnic.query_vnic_env_out);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_pair_nest_start(fmsg, \"vNIC env counters\");\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_obj_nest_start(fmsg);\n\tif (err)\n\t\treturn err;\n\n\tif (MLX5_CAP_GEN(dev, vnic_env_queue_counters)) {\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"total_error_queues\",\n\t\t\t\t\t\tVNIC_ENV_GET(&vnic, total_error_queues));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"send_queue_priority_update_flow\",\n\t\t\t\t\t\tVNIC_ENV_GET(&vnic,\n\t\t\t\t\t\t\t     send_queue_priority_update_flow));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, eq_overrun_count)) {\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"comp_eq_overrun\",\n\t\t\t\t\t\tVNIC_ENV_GET(&vnic, comp_eq_overrun));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"async_eq_overrun\",\n\t\t\t\t\t\tVNIC_ENV_GET(&vnic, async_eq_overrun));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, vnic_env_cq_overrun)) {\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"cq_overrun\",\n\t\t\t\t\t\tVNIC_ENV_GET(&vnic, cq_overrun));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, invalid_command_count)) {\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"invalid_command\",\n\t\t\t\t\t\tVNIC_ENV_GET(&vnic, invalid_command));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, quota_exceeded_count)) {\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"quota_exceeded_command\",\n\t\t\t\t\t\tVNIC_ENV_GET(&vnic, quota_exceeded_command));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, nic_receive_steering_discard)) {\n\t\terr = devlink_fmsg_u64_pair_put(fmsg, \"nic_receive_steering_discard\",\n\t\t\t\t\t\tVNIC_ENV_GET64(&vnic,\n\t\t\t\t\t\t\t       nic_receive_steering_discard));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, vnic_env_cnt_steering_fail)) {\n\t\terr = devlink_fmsg_u64_pair_put(fmsg, \"generated_pkt_steering_fail\",\n\t\t\t\t\t\tVNIC_ENV_GET64(&vnic,\n\t\t\t\t\t\t\t       generated_pkt_steering_fail));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = devlink_fmsg_u64_pair_put(fmsg, \"handled_pkt_steering_fail\",\n\t\t\t\t\t\tVNIC_ENV_GET64(&vnic, handled_pkt_steering_fail));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = devlink_fmsg_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_pair_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mlx5_reporter_vnic_diagnose(struct devlink_health_reporter *reporter,\n\t\t\t\t       struct devlink_fmsg *fmsg,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\n\treturn mlx5_reporter_vnic_diagnose_counters(dev, fmsg, 0, false);\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_reporter_vnic_ops = {\n\t.name = \"vnic\",\n\t.diagnose = mlx5_reporter_vnic_diagnose,\n};\n\nvoid mlx5_reporter_vnic_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct devlink *devlink = priv_to_devlink(dev);\n\n\thealth->vnic_reporter =\n\t\tdevlink_health_reporter_create(devlink,\n\t\t\t\t\t       &mlx5_reporter_vnic_ops,\n\t\t\t\t\t       0, dev);\n\tif (IS_ERR(health->vnic_reporter))\n\t\tmlx5_core_warn(dev,\n\t\t\t       \"Failed to create vnic reporter, err = %ld\\n\",\n\t\t\t       PTR_ERR(health->vnic_reporter));\n}\n\nvoid mlx5_reporter_vnic_destroy(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tif (!IS_ERR_OR_NULL(health->vnic_reporter))\n\t\tdevlink_health_reporter_destroy(health->vnic_reporter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}