{
  "module_name": "conn.c",
  "hash_id": "00f829b0ba6bf13d95a69e65b8c7e968904f1e324b242eddd3ccf9307c027318",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c",
  "human_readable_source": " \n\n#include <net/addrconf.h>\n#include <linux/etherdevice.h>\n#include <linux/mlx5/vport.h>\n\n#include \"mlx5_core.h\"\n#include \"lib/mlx5.h\"\n#include \"fpga/conn.h\"\n\n#define MLX5_FPGA_PKEY 0xFFFF\n#define MLX5_FPGA_PKEY_INDEX 0  \n#define MLX5_FPGA_RECV_SIZE 2048\n#define MLX5_FPGA_PORT_NUM 1\n#define MLX5_FPGA_CQ_BUDGET 64\n\nstatic int mlx5_fpga_conn_map_buf(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct device *dma_device;\n\tint err = 0;\n\n\tif (unlikely(!buf->sg[0].data))\n\t\tgoto out;\n\n\tdma_device = mlx5_core_dma_dev(conn->fdev->mdev);\n\tbuf->sg[0].dma_addr = dma_map_single(dma_device, buf->sg[0].data,\n\t\t\t\t\t     buf->sg[0].size, buf->dma_dir);\n\terr = dma_mapping_error(dma_device, buf->sg[0].dma_addr);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev, \"DMA error on sg 0: %d\\n\", err);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!buf->sg[1].data)\n\t\tgoto out;\n\n\tbuf->sg[1].dma_addr = dma_map_single(dma_device, buf->sg[1].data,\n\t\t\t\t\t     buf->sg[1].size, buf->dma_dir);\n\terr = dma_mapping_error(dma_device, buf->sg[1].dma_addr);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev, \"DMA error on sg 1: %d\\n\", err);\n\t\tdma_unmap_single(dma_device, buf->sg[0].dma_addr,\n\t\t\t\t buf->sg[0].size, buf->dma_dir);\n\t\terr = -ENOMEM;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_unmap_buf(struct mlx5_fpga_conn *conn,\n\t\t\t\t     struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct device *dma_device;\n\n\tdma_device = mlx5_core_dma_dev(conn->fdev->mdev);\n\tif (buf->sg[1].data)\n\t\tdma_unmap_single(dma_device, buf->sg[1].dma_addr,\n\t\t\t\t buf->sg[1].size, buf->dma_dir);\n\n\tif (likely(buf->sg[0].data))\n\t\tdma_unmap_single(dma_device, buf->sg[0].dma_addr,\n\t\t\t\t buf->sg[0].size, buf->dma_dir);\n}\n\nstatic int mlx5_fpga_conn_post_recv(struct mlx5_fpga_conn *conn,\n\t\t\t\t    struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct mlx5_wqe_data_seg *data;\n\tunsigned int ix;\n\tint err = 0;\n\n\terr = mlx5_fpga_conn_map_buf(conn, buf);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (unlikely(conn->qp.rq.pc - conn->qp.rq.cc >= conn->qp.rq.size)) {\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\treturn -EBUSY;\n\t}\n\n\tix = conn->qp.rq.pc & (conn->qp.rq.size - 1);\n\tdata = mlx5_wq_cyc_get_wqe(&conn->qp.wq.rq, ix);\n\tdata->byte_count = cpu_to_be32(buf->sg[0].size);\n\tdata->lkey = cpu_to_be32(conn->fdev->conn_res.mkey);\n\tdata->addr = cpu_to_be64(buf->sg[0].dma_addr);\n\n\tconn->qp.rq.pc++;\n\tconn->qp.rq.bufs[ix] = buf;\n\n\t \n\tdma_wmb();\n\t*conn->qp.wq.rq.db = cpu_to_be32(conn->qp.rq.pc & 0xffff);\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_notify_hw(struct mlx5_fpga_conn *conn, void *wqe)\n{\n\t \n\tdma_wmb();\n\t*conn->qp.wq.sq.db = cpu_to_be32(conn->qp.sq.pc);\n\t \n\twmb();\n\tmlx5_write64(wqe, conn->fdev->conn_res.uar->map + MLX5_BF_OFFSET);\n}\n\nstatic void mlx5_fpga_conn_post_send(struct mlx5_fpga_conn *conn,\n\t\t\t\t     struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct mlx5_wqe_ctrl_seg *ctrl;\n\tstruct mlx5_wqe_data_seg *data;\n\tunsigned int ix, sgi;\n\tint size = 1;\n\n\tix = conn->qp.sq.pc & (conn->qp.sq.size - 1);\n\n\tctrl = mlx5_wq_cyc_get_wqe(&conn->qp.wq.sq, ix);\n\tdata = (void *)(ctrl + 1);\n\n\tfor (sgi = 0; sgi < ARRAY_SIZE(buf->sg); sgi++) {\n\t\tif (!buf->sg[sgi].data)\n\t\t\tbreak;\n\t\tdata->byte_count = cpu_to_be32(buf->sg[sgi].size);\n\t\tdata->lkey = cpu_to_be32(conn->fdev->conn_res.mkey);\n\t\tdata->addr = cpu_to_be64(buf->sg[sgi].dma_addr);\n\t\tdata++;\n\t\tsize++;\n\t}\n\n\tctrl->imm = 0;\n\tctrl->fm_ce_se = MLX5_WQE_CTRL_CQ_UPDATE;\n\tctrl->opmod_idx_opcode = cpu_to_be32(((conn->qp.sq.pc & 0xffff) << 8) |\n\t\t\t\t\t     MLX5_OPCODE_SEND);\n\tctrl->qpn_ds = cpu_to_be32(size | (conn->qp.qpn << 8));\n\n\tconn->qp.sq.pc++;\n\tconn->qp.sq.bufs[ix] = buf;\n\tmlx5_fpga_conn_notify_hw(conn, ctrl);\n}\n\nint mlx5_fpga_conn_send(struct mlx5_fpga_conn *conn,\n\t\t\tstruct mlx5_fpga_dma_buf *buf)\n{\n\tunsigned long flags;\n\tint err;\n\n\tif (!conn->qp.active)\n\t\treturn -ENOTCONN;\n\n\tbuf->dma_dir = DMA_TO_DEVICE;\n\terr = mlx5_fpga_conn_map_buf(conn, buf);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irqsave(&conn->qp.sq.lock, flags);\n\n\tif (conn->qp.sq.pc - conn->qp.sq.cc >= conn->qp.sq.size) {\n\t\tlist_add_tail(&buf->list, &conn->qp.sq.backlog);\n\t\tgoto out_unlock;\n\t}\n\n\tmlx5_fpga_conn_post_send(conn, buf);\n\nout_unlock:\n\tspin_unlock_irqrestore(&conn->qp.sq.lock, flags);\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_post_recv_buf(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_dma_buf *buf;\n\tint err;\n\n\tbuf = kzalloc(sizeof(*buf) + MLX5_FPGA_RECV_SIZE, 0);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->sg[0].data = (void *)(buf + 1);\n\tbuf->sg[0].size = MLX5_FPGA_RECV_SIZE;\n\tbuf->dma_dir = DMA_FROM_DEVICE;\n\n\terr = mlx5_fpga_conn_post_recv(conn, buf);\n\tif (err)\n\t\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_create_mkey(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t      u32 *mkey)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_mkey_in);\n\tvoid *mkc;\n\tu32 *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\tMLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);\n\tMLX5_SET(mkc, mkc, lw, 1);\n\tMLX5_SET(mkc, mkc, lr, 1);\n\n\tMLX5_SET(mkc, mkc, pd, pdn);\n\tMLX5_SET(mkc, mkc, length64, 1);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\n\terr = mlx5_core_create_mkey(mdev, mkey, in, inlen);\n\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_rq_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_cqe64 *cqe, u8 status)\n{\n\tstruct mlx5_fpga_dma_buf *buf;\n\tint ix, err;\n\n\tix = be16_to_cpu(cqe->wqe_counter) & (conn->qp.rq.size - 1);\n\tbuf = conn->qp.rq.bufs[ix];\n\tconn->qp.rq.bufs[ix] = NULL;\n\tconn->qp.rq.cc++;\n\n\tif (unlikely(status && (status != MLX5_CQE_SYNDROME_WR_FLUSH_ERR)))\n\t\tmlx5_fpga_warn(conn->fdev, \"RQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t       buf, conn->fpga_qpn, status);\n\telse\n\t\tmlx5_fpga_dbg(conn->fdev, \"RQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t      buf, conn->fpga_qpn, status);\n\n\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\n\tif (unlikely(status || !conn->qp.active)) {\n\t\tconn->qp.active = false;\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tbuf->sg[0].size = be32_to_cpu(cqe->byte_cnt);\n\tmlx5_fpga_dbg(conn->fdev, \"Message with %u bytes received successfully\\n\",\n\t\t      buf->sg[0].size);\n\tconn->recv_cb(conn->cb_arg, buf);\n\n\tbuf->sg[0].size = MLX5_FPGA_RECV_SIZE;\n\terr = mlx5_fpga_conn_post_recv(conn, buf);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev,\n\t\t\t       \"Failed to re-post recv buf: %d\\n\", err);\n\t\tkfree(buf);\n\t}\n}\n\nstatic void mlx5_fpga_conn_sq_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_cqe64 *cqe, u8 status)\n{\n\tstruct mlx5_fpga_dma_buf *buf, *nextbuf;\n\tunsigned long flags;\n\tint ix;\n\n\tspin_lock_irqsave(&conn->qp.sq.lock, flags);\n\n\tix = be16_to_cpu(cqe->wqe_counter) & (conn->qp.sq.size - 1);\n\tbuf = conn->qp.sq.bufs[ix];\n\tconn->qp.sq.bufs[ix] = NULL;\n\tconn->qp.sq.cc++;\n\n\t \n\tif (unlikely(!list_empty(&conn->qp.sq.backlog))) {\n\t\tif (likely(conn->qp.active)) {\n\t\t\tnextbuf = list_first_entry(&conn->qp.sq.backlog,\n\t\t\t\t\t\t   struct mlx5_fpga_dma_buf, list);\n\t\t\tlist_del(&nextbuf->list);\n\t\t\tmlx5_fpga_conn_post_send(conn, nextbuf);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&conn->qp.sq.lock, flags);\n\n\tif (unlikely(status && (status != MLX5_CQE_SYNDROME_WR_FLUSH_ERR)))\n\t\tmlx5_fpga_warn(conn->fdev, \"SQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t       buf, conn->fpga_qpn, status);\n\telse\n\t\tmlx5_fpga_dbg(conn->fdev, \"SQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t      buf, conn->fpga_qpn, status);\n\n\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\n\tif (likely(buf->complete))\n\t\tbuf->complete(conn, conn->fdev, buf, status);\n\n\tif (unlikely(status))\n\t\tconn->qp.active = false;\n}\n\nstatic void mlx5_fpga_conn_handle_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t      struct mlx5_cqe64 *cqe)\n{\n\tu8 opcode, status = 0;\n\n\topcode = get_cqe_opcode(cqe);\n\n\tswitch (opcode) {\n\tcase MLX5_CQE_REQ_ERR:\n\t\tstatus = ((struct mlx5_err_cqe *)cqe)->syndrome;\n\t\tfallthrough;\n\tcase MLX5_CQE_REQ:\n\t\tmlx5_fpga_conn_sq_cqe(conn, cqe, status);\n\t\tbreak;\n\n\tcase MLX5_CQE_RESP_ERR:\n\t\tstatus = ((struct mlx5_err_cqe *)cqe)->syndrome;\n\t\tfallthrough;\n\tcase MLX5_CQE_RESP_SEND:\n\t\tmlx5_fpga_conn_rq_cqe(conn, cqe, status);\n\t\tbreak;\n\tdefault:\n\t\tmlx5_fpga_warn(conn->fdev, \"Unexpected cqe opcode %u\\n\",\n\t\t\t       opcode);\n\t}\n}\n\nstatic void mlx5_fpga_conn_arm_cq(struct mlx5_fpga_conn *conn)\n{\n\tmlx5_cq_arm(&conn->cq.mcq, MLX5_CQ_DB_REQ_NOT,\n\t\t    conn->fdev->conn_res.uar->map, conn->cq.wq.cc);\n}\n\nstatic inline void mlx5_fpga_conn_cqes(struct mlx5_fpga_conn *conn,\n\t\t\t\t       unsigned int budget)\n{\n\tstruct mlx5_cqe64 *cqe;\n\n\twhile (budget) {\n\t\tcqe = mlx5_cqwq_get_cqe(&conn->cq.wq);\n\t\tif (!cqe)\n\t\t\tbreak;\n\n\t\tbudget--;\n\t\tmlx5_cqwq_pop(&conn->cq.wq);\n\t\tmlx5_fpga_conn_handle_cqe(conn, cqe);\n\t\tmlx5_cqwq_update_db_record(&conn->cq.wq);\n\t}\n\tif (!budget) {\n\t\ttasklet_schedule(&conn->cq.tasklet);\n\t\treturn;\n\t}\n\n\tmlx5_fpga_dbg(conn->fdev, \"Re-arming CQ with cc# %u\\n\", conn->cq.wq.cc);\n\t \n\twmb();\n\tmlx5_fpga_conn_arm_cq(conn);\n}\n\nstatic void mlx5_fpga_conn_cq_tasklet(struct tasklet_struct *t)\n{\n\tstruct mlx5_fpga_conn *conn = from_tasklet(conn, t, cq.tasklet);\n\n\tif (unlikely(!conn->qp.active))\n\t\treturn;\n\tmlx5_fpga_conn_cqes(conn, MLX5_FPGA_CQ_BUDGET);\n}\n\nstatic void mlx5_fpga_conn_cq_complete(struct mlx5_core_cq *mcq,\n\t\t\t\t       struct mlx5_eqe *eqe)\n{\n\tstruct mlx5_fpga_conn *conn;\n\n\tconn = container_of(mcq, struct mlx5_fpga_conn, cq.mcq);\n\tif (unlikely(!conn->qp.active))\n\t\treturn;\n\tmlx5_fpga_conn_cqes(conn, MLX5_FPGA_CQ_BUDGET);\n}\n\nstatic int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_comp_eqn_get(mdev, smp_processor_id(), &eqn);\n\tif (err) {\n\t\tkvfree(in);\n\t\tgoto err_cqwq;\n\t}\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn_or_apu_element, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_setup(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_destroy_cq(struct mlx5_fpga_conn *conn)\n{\n\ttasklet_disable(&conn->cq.tasklet);\n\ttasklet_kill(&conn->cq.tasklet);\n\tmlx5_core_destroy_cq(conn->fdev->mdev, &conn->cq.mcq);\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\n}\n\nstatic int mlx5_fpga_conn_create_wq(struct mlx5_fpga_conn *conn, void *qpc)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tstruct mlx5_wq_param wqp;\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\treturn mlx5_wq_qp_create(mdev, &wqp, qpc, &conn->qp.wq,\n\t\t\t\t &conn->qp.wq_ctrl);\n}\n\nstatic int mlx5_fpga_conn_create_qp(struct mlx5_fpga_conn *conn,\n\t\t\t\t    unsigned int tx_size, unsigned int rx_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tu32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_qpc[MLX5_ST_SZ_DW(qpc)] = {};\n\tvoid *in = NULL, *qpc;\n\tint err, inlen;\n\n\tconn->qp.rq.pc = 0;\n\tconn->qp.rq.cc = 0;\n\tconn->qp.rq.size = roundup_pow_of_two(rx_size);\n\tconn->qp.sq.pc = 0;\n\tconn->qp.sq.cc = 0;\n\tconn->qp.sq.size = roundup_pow_of_two(tx_size);\n\n\tMLX5_SET(qpc, temp_qpc, log_rq_stride, ilog2(MLX5_SEND_WQE_DS) - 4);\n\tMLX5_SET(qpc, temp_qpc, log_rq_size, ilog2(conn->qp.rq.size));\n\tMLX5_SET(qpc, temp_qpc, log_sq_size, ilog2(conn->qp.sq.size));\n\terr = mlx5_fpga_conn_create_wq(conn, temp_qpc);\n\tif (err)\n\t\tgoto out;\n\n\tconn->qp.rq.bufs = kvcalloc(conn->qp.rq.size,\n\t\t\t\t    sizeof(conn->qp.rq.bufs[0]),\n\t\t\t\t    GFP_KERNEL);\n\tif (!conn->qp.rq.bufs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wq;\n\t}\n\n\tconn->qp.sq.bufs = kvcalloc(conn->qp.sq.size,\n\t\t\t\t    sizeof(conn->qp.sq.bufs[0]),\n\t\t\t\t    GFP_KERNEL);\n\tif (!conn->qp.sq.bufs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rq_bufs;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\tMLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) *\n\t\tconn->qp.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_sq_bufs;\n\t}\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\tMLX5_SET(qpc, qpc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(qpc, qpc, log_page_size,\n\t\t conn->qp.wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(qpc, qpc, fre, 1);\n\tMLX5_SET(qpc, qpc, rlky, 1);\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_RC);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, pd, fdev->conn_res.pdn);\n\tMLX5_SET(qpc, qpc, log_rq_stride, ilog2(MLX5_SEND_WQE_DS) - 4);\n\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(conn->qp.rq.size));\n\tMLX5_SET(qpc, qpc, rq_type, MLX5_NON_ZERO_RQ);\n\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(conn->qp.sq.size));\n\tMLX5_SET(qpc, qpc, cqn_snd, conn->cq.mcq.cqn);\n\tMLX5_SET(qpc, qpc, cqn_rcv, conn->cq.mcq.cqn);\n\tMLX5_SET(qpc, qpc, ts_format, mlx5_get_qp_default_ts(mdev));\n\tMLX5_SET64(qpc, qpc, dbr_addr, conn->qp.wq_ctrl.db.dma);\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == 1)\n\t\tMLX5_SET(qpc, qpc, user_index, 0xFFFFFF);\n\n\tmlx5_fill_page_frag_array(&conn->qp.wq_ctrl.buf,\n\t\t\t\t  (__be64 *)MLX5_ADDR_OF(create_qp_in, in, pas));\n\n\tMLX5_SET(create_qp_in, in, opcode, MLX5_CMD_OP_CREATE_QP);\n\terr = mlx5_cmd_exec(mdev, in, inlen, out, sizeof(out));\n\tif (err)\n\t\tgoto err_sq_bufs;\n\n\tconn->qp.qpn = MLX5_GET(create_qp_out, out, qpn);\n\tmlx5_fpga_dbg(fdev, \"Created QP #0x%x\\n\", conn->qp.qpn);\n\n\tgoto out;\n\nerr_sq_bufs:\n\tkvfree(conn->qp.sq.bufs);\nerr_rq_bufs:\n\tkvfree(conn->qp.rq.bufs);\nerr_wq:\n\tmlx5_wq_destroy(&conn->qp.wq_ctrl);\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_free_recv_bufs(struct mlx5_fpga_conn *conn)\n{\n\tint ix;\n\n\tfor (ix = 0; ix < conn->qp.rq.size; ix++) {\n\t\tif (!conn->qp.rq.bufs[ix])\n\t\t\tcontinue;\n\t\tmlx5_fpga_conn_unmap_buf(conn, conn->qp.rq.bufs[ix]);\n\t\tkfree(conn->qp.rq.bufs[ix]);\n\t\tconn->qp.rq.bufs[ix] = NULL;\n\t}\n}\n\nstatic void mlx5_fpga_conn_flush_send_bufs(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_dma_buf *buf, *temp;\n\tint ix;\n\n\tfor (ix = 0; ix < conn->qp.sq.size; ix++) {\n\t\tbuf = conn->qp.sq.bufs[ix];\n\t\tif (!buf)\n\t\t\tcontinue;\n\t\tconn->qp.sq.bufs[ix] = NULL;\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\tif (!buf->complete)\n\t\t\tcontinue;\n\t\tbuf->complete(conn, conn->fdev, buf, MLX5_CQE_SYNDROME_WR_FLUSH_ERR);\n\t}\n\tlist_for_each_entry_safe(buf, temp, &conn->qp.sq.backlog, list) {\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\tif (!buf->complete)\n\t\t\tcontinue;\n\t\tbuf->complete(conn, conn->fdev, buf, MLX5_CQE_SYNDROME_WR_FLUSH_ERR);\n\t}\n}\n\nstatic void mlx5_fpga_conn_destroy_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_core_dev *dev = conn->fdev->mdev;\n\tu32 in[MLX5_ST_SZ_DW(destroy_qp_in)] = {};\n\n\tMLX5_SET(destroy_qp_in, in, opcode, MLX5_CMD_OP_DESTROY_QP);\n\tMLX5_SET(destroy_qp_in, in, qpn, conn->qp.qpn);\n\tmlx5_cmd_exec_in(dev, destroy_qp, in);\n\n\tmlx5_fpga_conn_free_recv_bufs(conn);\n\tmlx5_fpga_conn_flush_send_bufs(conn);\n\tkvfree(conn->qp.sq.bufs);\n\tkvfree(conn->qp.rq.bufs);\n\tmlx5_wq_destroy(&conn->qp.wq_ctrl);\n}\n\nstatic int mlx5_fpga_conn_reset_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_core_dev *mdev = conn->fdev->mdev;\n\tu32 in[MLX5_ST_SZ_DW(qp_2rst_in)] = {};\n\n\tmlx5_fpga_dbg(conn->fdev, \"Modifying QP %u to RST\\n\", conn->qp.qpn);\n\n\tMLX5_SET(qp_2rst_in, in, opcode, MLX5_CMD_OP_2RST_QP);\n\tMLX5_SET(qp_2rst_in, in, qpn, conn->qp.qpn);\n\n\treturn mlx5_cmd_exec_in(mdev, qp_2rst, in);\n}\n\nstatic int mlx5_fpga_conn_init_qp(struct mlx5_fpga_conn *conn)\n{\n\tu32 in[MLX5_ST_SZ_DW(rst2init_qp_in)] = {};\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc;\n\n\tmlx5_fpga_dbg(conn->fdev, \"Modifying QP %u to INIT\\n\", conn->qp.qpn);\n\n\tqpc = MLX5_ADDR_OF(rst2init_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_RC);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, primary_address_path.pkey_index, MLX5_FPGA_PKEY_INDEX);\n\tMLX5_SET(qpc, qpc, primary_address_path.vhca_port_num, MLX5_FPGA_PORT_NUM);\n\tMLX5_SET(qpc, qpc, pd, conn->fdev->conn_res.pdn);\n\tMLX5_SET(qpc, qpc, cqn_snd, conn->cq.mcq.cqn);\n\tMLX5_SET(qpc, qpc, cqn_rcv, conn->cq.mcq.cqn);\n\tMLX5_SET64(qpc, qpc, dbr_addr, conn->qp.wq_ctrl.db.dma);\n\n\tMLX5_SET(rst2init_qp_in, in, opcode, MLX5_CMD_OP_RST2INIT_QP);\n\tMLX5_SET(rst2init_qp_in, in, qpn, conn->qp.qpn);\n\n\treturn mlx5_cmd_exec_in(mdev, rst2init_qp, in);\n}\n\nstatic int mlx5_fpga_conn_rtr_qp(struct mlx5_fpga_conn *conn)\n{\n\tu32 in[MLX5_ST_SZ_DW(init2rtr_qp_in)] = {};\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc;\n\n\tmlx5_fpga_dbg(conn->fdev, \"QP RTR\\n\");\n\n\tqpc = MLX5_ADDR_OF(init2rtr_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, mtu, MLX5_QPC_MTU_1K_BYTES);\n\tMLX5_SET(qpc, qpc, log_msg_max, (u8)MLX5_CAP_GEN(mdev, log_max_msg));\n\tMLX5_SET(qpc, qpc, remote_qpn, conn->fpga_qpn);\n\tMLX5_SET(qpc, qpc, next_rcv_psn,\n\t\t MLX5_GET(fpga_qpc, conn->fpga_qpc, next_send_psn));\n\tMLX5_SET(qpc, qpc, primary_address_path.pkey_index, MLX5_FPGA_PKEY_INDEX);\n\tMLX5_SET(qpc, qpc, primary_address_path.vhca_port_num, MLX5_FPGA_PORT_NUM);\n\tether_addr_copy(MLX5_ADDR_OF(qpc, qpc, primary_address_path.rmac_47_32),\n\t\t\tMLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, fpga_mac_47_32));\n\tMLX5_SET(qpc, qpc, primary_address_path.udp_sport,\n\t\t MLX5_CAP_ROCE(mdev, r_roce_min_src_udp_port));\n\tMLX5_SET(qpc, qpc, primary_address_path.src_addr_index,\n\t\t conn->qp.sgid_index);\n\tMLX5_SET(qpc, qpc, primary_address_path.hop_limit, 0);\n\tmemcpy(MLX5_ADDR_OF(qpc, qpc, primary_address_path.rgid_rip),\n\t       MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, fpga_ip),\n\t       MLX5_FLD_SZ_BYTES(qpc, primary_address_path.rgid_rip));\n\n\tMLX5_SET(init2rtr_qp_in, in, opcode, MLX5_CMD_OP_INIT2RTR_QP);\n\tMLX5_SET(init2rtr_qp_in, in, qpn, conn->qp.qpn);\n\n\treturn mlx5_cmd_exec_in(mdev, init2rtr_qp, in);\n}\n\nstatic int mlx5_fpga_conn_rts_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tu32 in[MLX5_ST_SZ_DW(rtr2rts_qp_in)] = {};\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc;\n\n\tmlx5_fpga_dbg(conn->fdev, \"QP RTS\\n\");\n\n\tqpc = MLX5_ADDR_OF(rtr2rts_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, log_ack_req_freq, 8);\n\tMLX5_SET(qpc, qpc, min_rnr_nak, 0x12);\n\tMLX5_SET(qpc, qpc, primary_address_path.ack_timeout, 0x12);  \n\tMLX5_SET(qpc, qpc, next_send_psn,\n\t\t MLX5_GET(fpga_qpc, conn->fpga_qpc, next_rcv_psn));\n\tMLX5_SET(qpc, qpc, retry_count, 7);\n\tMLX5_SET(qpc, qpc, rnr_retry, 7);  \n\n\tMLX5_SET(rtr2rts_qp_in, in, opcode, MLX5_CMD_OP_RTR2RTS_QP);\n\tMLX5_SET(rtr2rts_qp_in, in, qpn, conn->qp.qpn);\n\tMLX5_SET(rtr2rts_qp_in, in, opt_param_mask, MLX5_QP_OPTPAR_RNR_TIMEOUT);\n\n\treturn mlx5_cmd_exec_in(mdev, rtr2rts_qp, in);\n}\n\nstatic int mlx5_fpga_conn_connect(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tint err;\n\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_ACTIVE);\n\terr = mlx5_fpga_modify_qp(conn->fdev->mdev, conn->fpga_qpn,\n\t\t\t\t  MLX5_FPGA_QPC_STATE, &conn->fpga_qpc);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to activate FPGA RC QP: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = mlx5_fpga_conn_reset_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state to reset\\n\");\n\t\tgoto err_fpga_qp;\n\t}\n\n\terr = mlx5_fpga_conn_init_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to modify QP from RESET to INIT\\n\");\n\t\tgoto err_fpga_qp;\n\t}\n\tconn->qp.active = true;\n\n\twhile (!mlx5_fpga_conn_post_recv_buf(conn))\n\t\t;\n\n\terr = mlx5_fpga_conn_rtr_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state from INIT to RTR\\n\");\n\t\tgoto err_recv_bufs;\n\t}\n\n\terr = mlx5_fpga_conn_rts_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state from RTR to RTS\\n\");\n\t\tgoto err_recv_bufs;\n\t}\n\tgoto out;\n\nerr_recv_bufs:\n\tmlx5_fpga_conn_free_recv_bufs(conn);\nerr_fpga_qp:\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_INIT);\n\tif (mlx5_fpga_modify_qp(conn->fdev->mdev, conn->fpga_qpn,\n\t\t\t\tMLX5_FPGA_QPC_STATE, &conn->fpga_qpc))\n\t\tmlx5_fpga_err(fdev, \"Failed to revert FPGA QP to INIT\\n\");\nout:\n\treturn err;\n}\n\nstruct mlx5_fpga_conn *mlx5_fpga_conn_create(struct mlx5_fpga_device *fdev,\n\t\t\t\t\t     struct mlx5_fpga_conn_attr *attr,\n\t\t\t\t\t     enum mlx5_ifc_fpga_qp_type qp_type)\n{\n\tstruct mlx5_fpga_conn *ret, *conn;\n\tu8 *remote_mac, *remote_ip;\n\tint err;\n\n\tif (!attr->recv_cb)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconn->fdev = fdev;\n\tINIT_LIST_HEAD(&conn->qp.sq.backlog);\n\n\tspin_lock_init(&conn->qp.sq.lock);\n\n\tconn->recv_cb = attr->recv_cb;\n\tconn->cb_arg = attr->cb_arg;\n\n\tremote_mac = MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, remote_mac_47_32);\n\terr = mlx5_query_mac_address(fdev->mdev, remote_mac);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to query local MAC: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err;\n\t}\n\n\t \n\tremote_ip = MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, remote_ip);\n\tremote_ip[0] = 0xfe;\n\tremote_ip[1] = 0x80;\n\taddrconf_addr_eui48(&remote_ip[8], remote_mac);\n\n\terr = mlx5_core_reserved_gid_alloc(fdev->mdev, &conn->qp.sgid_index);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to allocate SGID: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err;\n\t}\n\n\terr = mlx5_core_roce_gid_set(fdev->mdev, conn->qp.sgid_index,\n\t\t\t\t     MLX5_ROCE_VERSION_2,\n\t\t\t\t     MLX5_ROCE_L3_TYPE_IPV6,\n\t\t\t\t     remote_ip, remote_mac, true, 0,\n\t\t\t\t     MLX5_FPGA_PORT_NUM);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to set SGID: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_rsvd_gid;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Reserved SGID index %u\\n\", conn->qp.sgid_index);\n\n\t \n\terr = mlx5_fpga_conn_create_cq(conn,\n\t\t\t\t       (attr->tx_size + attr->rx_size) * 2);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create CQ: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_gid;\n\t}\n\n\tmlx5_fpga_conn_arm_cq(conn);\n\n\terr = mlx5_fpga_conn_create_qp(conn, attr->tx_size, attr->rx_size);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create QP: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_cq;\n\t}\n\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_INIT);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, qp_type, qp_type);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, st, MLX5_FPGA_QPC_ST_RC);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, ether_type, ETH_P_8021Q);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, vid, 0);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, next_rcv_psn, 1);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, next_send_psn, 0);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, pkey, MLX5_FPGA_PKEY);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, remote_qpn, conn->qp.qpn);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, rnr_retry, 7);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, retry_count, 7);\n\n\terr = mlx5_fpga_create_qp(fdev->mdev, &conn->fpga_qpc,\n\t\t\t\t  &conn->fpga_qpn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create FPGA RC QP: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_qp;\n\t}\n\n\terr = mlx5_fpga_conn_connect(conn);\n\tif (err) {\n\t\tret = ERR_PTR(err);\n\t\tgoto err_conn;\n\t}\n\n\tmlx5_fpga_dbg(fdev, \"FPGA QPN is %u\\n\", conn->fpga_qpn);\n\tret = conn;\n\tgoto out;\n\nerr_conn:\n\tmlx5_fpga_destroy_qp(conn->fdev->mdev, conn->fpga_qpn);\nerr_qp:\n\tmlx5_fpga_conn_destroy_qp(conn);\nerr_cq:\n\tmlx5_fpga_conn_destroy_cq(conn);\nerr_gid:\n\tmlx5_core_roce_gid_set(fdev->mdev, conn->qp.sgid_index, 0, 0, NULL,\n\t\t\t       NULL, false, 0, MLX5_FPGA_PORT_NUM);\nerr_rsvd_gid:\n\tmlx5_core_reserved_gid_free(fdev->mdev, conn->qp.sgid_index);\nerr:\n\tkfree(conn);\nout:\n\treturn ret;\n}\n\nvoid mlx5_fpga_conn_destroy(struct mlx5_fpga_conn *conn)\n{\n\tconn->qp.active = false;\n\ttasklet_disable(&conn->cq.tasklet);\n\tsynchronize_irq(conn->cq.mcq.irqn);\n\n\tmlx5_fpga_destroy_qp(conn->fdev->mdev, conn->fpga_qpn);\n\tmlx5_fpga_conn_destroy_qp(conn);\n\tmlx5_fpga_conn_destroy_cq(conn);\n\n\tmlx5_core_roce_gid_set(conn->fdev->mdev, conn->qp.sgid_index, 0, 0,\n\t\t\t       NULL, NULL, false, 0, MLX5_FPGA_PORT_NUM);\n\tmlx5_core_reserved_gid_free(conn->fdev->mdev, conn->qp.sgid_index);\n\tkfree(conn);\n}\n\nint mlx5_fpga_conn_device_init(struct mlx5_fpga_device *fdev)\n{\n\tint err;\n\n\terr = mlx5_nic_vport_enable_roce(fdev->mdev);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to enable RoCE: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tfdev->conn_res.uar = mlx5_get_uars_page(fdev->mdev);\n\tif (IS_ERR(fdev->conn_res.uar)) {\n\t\terr = PTR_ERR(fdev->conn_res.uar);\n\t\tmlx5_fpga_err(fdev, \"get_uars_page failed, %d\\n\", err);\n\t\tgoto err_roce;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Allocated UAR index %u\\n\",\n\t\t      fdev->conn_res.uar->index);\n\n\terr = mlx5_core_alloc_pd(fdev->mdev, &fdev->conn_res.pdn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"alloc pd failed, %d\\n\", err);\n\t\tgoto err_uar;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Allocated PD %u\\n\", fdev->conn_res.pdn);\n\n\terr = mlx5_fpga_conn_create_mkey(fdev->mdev, fdev->conn_res.pdn,\n\t\t\t\t\t &fdev->conn_res.mkey);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"create mkey failed, %d\\n\", err);\n\t\tgoto err_dealloc_pd;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Created mkey 0x%x\\n\", fdev->conn_res.mkey);\n\n\treturn 0;\n\nerr_dealloc_pd:\n\tmlx5_core_dealloc_pd(fdev->mdev, fdev->conn_res.pdn);\nerr_uar:\n\tmlx5_put_uars_page(fdev->mdev, fdev->conn_res.uar);\nerr_roce:\n\tmlx5_nic_vport_disable_roce(fdev->mdev);\nout:\n\treturn err;\n}\n\nvoid mlx5_fpga_conn_device_cleanup(struct mlx5_fpga_device *fdev)\n{\n\tmlx5_core_destroy_mkey(fdev->mdev, fdev->conn_res.mkey);\n\tmlx5_core_dealloc_pd(fdev->mdev, fdev->conn_res.pdn);\n\tmlx5_put_uars_page(fdev->mdev, fdev->conn_res.uar);\n\tmlx5_nic_vport_disable_roce(fdev->mdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}