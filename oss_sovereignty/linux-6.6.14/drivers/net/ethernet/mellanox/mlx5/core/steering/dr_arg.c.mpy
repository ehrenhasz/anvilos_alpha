{
  "module_name": "dr_arg.c",
  "hash_id": "fafc06efaceed55ac895ccac0efaff6206e316cb5015484ec35133c2cff174ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_arg.c",
  "human_readable_source": "\n\n\n#include \"dr_types.h\"\n\n#define DR_ICM_MODIFY_HDR_GRANULARITY_4K 12\n\n \nenum dr_arg_chunk_size {\n\tDR_ARG_CHUNK_SIZE_1,\n\tDR_ARG_CHUNK_SIZE_MIN = DR_ARG_CHUNK_SIZE_1,  \n\tDR_ARG_CHUNK_SIZE_2,\n\tDR_ARG_CHUNK_SIZE_3,\n\tDR_ARG_CHUNK_SIZE_4,\n\tDR_ARG_CHUNK_SIZE_MAX,\n};\n\n \nstruct dr_arg_pool {\n\tenum dr_arg_chunk_size log_chunk_size;\n\tstruct mlx5dr_domain *dmn;\n\tstruct list_head free_list;\n\tstruct mutex mutex;  \n};\n\nstruct mlx5dr_arg_mgr {\n\tstruct mlx5dr_domain *dmn;\n\tstruct dr_arg_pool *pools[DR_ARG_CHUNK_SIZE_MAX];\n};\n\nstatic int dr_arg_pool_alloc_objs(struct dr_arg_pool *pool)\n{\n\tstruct mlx5dr_arg_obj *arg_obj, *tmp_arg;\n\tstruct list_head cur_list;\n\tu16 object_range;\n\tint num_of_objects;\n\tu32 obj_id = 0;\n\tint i, ret;\n\n\tINIT_LIST_HEAD(&cur_list);\n\n\tobject_range =\n\t\tpool->dmn->info.caps.log_header_modify_argument_granularity;\n\n\tobject_range =\n\t\tmax_t(u32, pool->dmn->info.caps.log_header_modify_argument_granularity,\n\t\t      DR_ICM_MODIFY_HDR_GRANULARITY_4K);\n\tobject_range =\n\t\tmin_t(u32, pool->dmn->info.caps.log_header_modify_argument_max_alloc,\n\t\t      object_range);\n\n\tif (pool->log_chunk_size > object_range) {\n\t\tmlx5dr_err(pool->dmn, \"Required chunk size (%d) is not supported\\n\",\n\t\t\t   pool->log_chunk_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tnum_of_objects = (1 << (object_range - pool->log_chunk_size));\n\t \n\tret = mlx5dr_cmd_create_modify_header_arg(pool->dmn->mdev,\n\t\t\t\t\t\t  object_range,\n\t\t\t\t\t\t  pool->dmn->pdn,\n\t\t\t\t\t\t  &obj_id);\n\tif (ret) {\n\t\tmlx5dr_err(pool->dmn, \"failed allocating object with range: %d:\\n\",\n\t\t\t   object_range);\n\t\treturn -EAGAIN;\n\t}\n\n\tfor (i = 0; i < num_of_objects; i++) {\n\t\targ_obj = kzalloc(sizeof(*arg_obj), GFP_KERNEL);\n\t\tif (!arg_obj) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto clean_arg_obj;\n\t\t}\n\n\t\targ_obj->log_chunk_size = pool->log_chunk_size;\n\n\t\tlist_add_tail(&arg_obj->list_node, &cur_list);\n\n\t\targ_obj->obj_id = obj_id;\n\t\targ_obj->obj_offset = i * (1 << pool->log_chunk_size);\n\t}\n\tlist_splice_tail_init(&cur_list, &pool->free_list);\n\n\treturn 0;\n\nclean_arg_obj:\n\tmlx5dr_cmd_destroy_modify_header_arg(pool->dmn->mdev, obj_id);\n\tlist_for_each_entry_safe(arg_obj, tmp_arg, &cur_list, list_node) {\n\t\tlist_del(&arg_obj->list_node);\n\t\tkfree(arg_obj);\n\t}\n\treturn ret;\n}\n\nstatic struct mlx5dr_arg_obj *dr_arg_pool_get_arg_obj(struct dr_arg_pool *pool)\n{\n\tstruct mlx5dr_arg_obj *arg_obj = NULL;\n\tint ret;\n\n\tmutex_lock(&pool->mutex);\n\tif (list_empty(&pool->free_list)) {\n\t\tret = dr_arg_pool_alloc_objs(pool);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\targ_obj = list_first_entry_or_null(&pool->free_list,\n\t\t\t\t\t   struct mlx5dr_arg_obj,\n\t\t\t\t\t   list_node);\n\tWARN(!arg_obj, \"couldn't get dr arg obj from pool\");\n\n\tif (arg_obj)\n\t\tlist_del_init(&arg_obj->list_node);\n\nout:\n\tmutex_unlock(&pool->mutex);\n\treturn arg_obj;\n}\n\nstatic void dr_arg_pool_put_arg_obj(struct dr_arg_pool *pool,\n\t\t\t\t    struct mlx5dr_arg_obj *arg_obj)\n{\n\tmutex_lock(&pool->mutex);\n\tlist_add(&arg_obj->list_node, &pool->free_list);\n\tmutex_unlock(&pool->mutex);\n}\n\nstatic struct dr_arg_pool *dr_arg_pool_create(struct mlx5dr_domain *dmn,\n\t\t\t\t\t      enum dr_arg_chunk_size chunk_size)\n{\n\tstruct dr_arg_pool *pool;\n\n\tpool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpool->dmn = dmn;\n\n\tINIT_LIST_HEAD(&pool->free_list);\n\tmutex_init(&pool->mutex);\n\n\tpool->log_chunk_size = chunk_size;\n\tif (dr_arg_pool_alloc_objs(pool))\n\t\tgoto free_pool;\n\n\treturn pool;\n\nfree_pool:\n\tkfree(pool);\n\n\treturn NULL;\n}\n\nstatic void dr_arg_pool_destroy(struct dr_arg_pool *pool)\n{\n\tstruct mlx5dr_arg_obj *arg_obj, *tmp_arg;\n\n\tlist_for_each_entry_safe(arg_obj, tmp_arg, &pool->free_list, list_node) {\n\t\tlist_del(&arg_obj->list_node);\n\t\tif (!arg_obj->obj_offset)  \n\t\t\tmlx5dr_cmd_destroy_modify_header_arg(pool->dmn->mdev, arg_obj->obj_id);\n\t\tkfree(arg_obj);\n\t}\n\n\tmutex_destroy(&pool->mutex);\n\tkfree(pool);\n}\n\nstatic enum dr_arg_chunk_size dr_arg_get_chunk_size(u16 num_of_actions)\n{\n\tif (num_of_actions <= 8)\n\t\treturn DR_ARG_CHUNK_SIZE_1;\n\tif (num_of_actions <= 16)\n\t\treturn DR_ARG_CHUNK_SIZE_2;\n\tif (num_of_actions <= 32)\n\t\treturn DR_ARG_CHUNK_SIZE_3;\n\tif (num_of_actions <= 64)\n\t\treturn DR_ARG_CHUNK_SIZE_4;\n\n\treturn DR_ARG_CHUNK_SIZE_MAX;\n}\n\nu32 mlx5dr_arg_get_obj_id(struct mlx5dr_arg_obj *arg_obj)\n{\n\treturn (arg_obj->obj_id + arg_obj->obj_offset);\n}\n\nstruct mlx5dr_arg_obj *mlx5dr_arg_get_obj(struct mlx5dr_arg_mgr *mgr,\n\t\t\t\t\t  u16 num_of_actions,\n\t\t\t\t\t  u8 *data)\n{\n\tu32 size = dr_arg_get_chunk_size(num_of_actions);\n\tstruct mlx5dr_arg_obj *arg_obj;\n\tint ret;\n\n\tif (size >= DR_ARG_CHUNK_SIZE_MAX)\n\t\treturn NULL;\n\n\targ_obj = dr_arg_pool_get_arg_obj(mgr->pools[size]);\n\tif (!arg_obj) {\n\t\tmlx5dr_err(mgr->dmn, \"Failed allocating args object for modify header\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tret = mlx5dr_send_postsend_args(mgr->dmn,\n\t\t\t\t\tmlx5dr_arg_get_obj_id(arg_obj),\n\t\t\t\t\tnum_of_actions, data);\n\tif (ret) {\n\t\tmlx5dr_err(mgr->dmn, \"Failed writing args object\\n\");\n\t\tgoto put_obj;\n\t}\n\n\treturn arg_obj;\n\nput_obj:\n\tmlx5dr_arg_put_obj(mgr, arg_obj);\n\treturn NULL;\n}\n\nvoid mlx5dr_arg_put_obj(struct mlx5dr_arg_mgr *mgr,\n\t\t\tstruct mlx5dr_arg_obj *arg_obj)\n{\n\tdr_arg_pool_put_arg_obj(mgr->pools[arg_obj->log_chunk_size], arg_obj);\n}\n\nstruct mlx5dr_arg_mgr*\nmlx5dr_arg_mgr_create(struct mlx5dr_domain *dmn)\n{\n\tstruct mlx5dr_arg_mgr *pool_mgr;\n\tint i;\n\n\tif (!mlx5dr_domain_is_support_ptrn_arg(dmn))\n\t\treturn NULL;\n\n\tpool_mgr = kzalloc(sizeof(*pool_mgr), GFP_KERNEL);\n\tif (!pool_mgr)\n\t\treturn NULL;\n\n\tpool_mgr->dmn = dmn;\n\n\tfor (i = 0; i < DR_ARG_CHUNK_SIZE_MAX; i++) {\n\t\tpool_mgr->pools[i] = dr_arg_pool_create(dmn, i);\n\t\tif (!pool_mgr->pools[i])\n\t\t\tgoto clean_pools;\n\t}\n\n\treturn pool_mgr;\n\nclean_pools:\n\tfor (i--; i >= 0; i--)\n\t\tdr_arg_pool_destroy(pool_mgr->pools[i]);\n\n\tkfree(pool_mgr);\n\treturn NULL;\n}\n\nvoid mlx5dr_arg_mgr_destroy(struct mlx5dr_arg_mgr *mgr)\n{\n\tstruct dr_arg_pool **pools;\n\tint i;\n\n\tif (!mgr)\n\t\treturn;\n\n\tpools = mgr->pools;\n\tfor (i = 0; i < DR_ARG_CHUNK_SIZE_MAX; i++)\n\t\tdr_arg_pool_destroy(pools[i]);\n\n\tkfree(mgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}