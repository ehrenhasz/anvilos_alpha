{
  "module_name": "en_tc.c",
  "hash_id": "aab26b8a755eeaca9f34ca82636aa378b6728d2bc8c852011234eee6f1cfd548",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c",
  "human_readable_source": " \n\n#include <net/flow_dissector.h>\n#include <net/flow_offload.h>\n#include <net/sch_generic.h>\n#include <net/pkt_cls.h>\n#include <linux/mlx5/fs.h>\n#include <linux/mlx5/device.h>\n#include <linux/rhashtable.h>\n#include <linux/refcount.h>\n#include <linux/completion.h>\n#include <net/arp.h>\n#include <net/ipv6_stubs.h>\n#include <net/bareudp.h>\n#include <net/bonding.h>\n#include <net/dst_metadata.h>\n#include \"devlink.h\"\n#include \"en.h\"\n#include \"en/tc/post_act.h\"\n#include \"en/tc/act_stats.h\"\n#include \"en_rep.h\"\n#include \"en/rep/tc.h\"\n#include \"en/rep/neigh.h\"\n#include \"en_tc.h\"\n#include \"eswitch.h\"\n#include \"fs_core.h\"\n#include \"en/port.h\"\n#include \"en/tc_tun.h\"\n#include \"en/mapping.h\"\n#include \"en/tc_ct.h\"\n#include \"en/mod_hdr.h\"\n#include \"en/tc_tun_encap.h\"\n#include \"en/tc/sample.h\"\n#include \"en/tc/act/act.h\"\n#include \"en/tc/post_meter.h\"\n#include \"lib/devcom.h\"\n#include \"lib/geneve.h\"\n#include \"lib/fs_chains.h\"\n#include \"diag/en_tc_tracepoint.h\"\n#include <asm/div64.h>\n#include \"lag/lag.h\"\n#include \"lag/mp.h\"\n\n#define MLX5E_TC_TABLE_NUM_GROUPS 4\n#define MLX5E_TC_TABLE_MAX_GROUP_SIZE BIT(18)\n\nstruct mlx5e_tc_table {\n\t \n\tstruct mutex\t\t\tt_lock;\n\tstruct mlx5e_priv\t\t*priv;\n\tstruct mlx5_flow_table\t\t*t;\n\tstruct mlx5_flow_table\t\t*miss_t;\n\tstruct mlx5_fs_chains           *chains;\n\tstruct mlx5e_post_act\t\t*post_act;\n\n\tstruct rhashtable               ht;\n\n\tstruct mod_hdr_tbl mod_hdr;\n\tstruct mutex hairpin_tbl_lock;  \n\tDECLARE_HASHTABLE(hairpin_tbl, 8);\n\n\tstruct notifier_block     netdevice_nb;\n\tstruct netdev_net_notifier\tnetdevice_nn;\n\n\tstruct mlx5_tc_ct_priv         *ct;\n\tstruct mapping_ctx             *mapping;\n\tstruct dentry                  *dfs_root;\n\n\t \n\tstruct mlx5e_tc_act_stats_handle *action_stats_handle;\n};\n\nstruct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[] = {\n\t[MAPPED_OBJ_TO_REG] = {\n\t\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_0,\n\t\t.moffset = 0,\n\t\t.mlen = 16,\n\t},\n\t[VPORT_TO_REG] = {\n\t\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_0,\n\t\t.moffset = 16,\n\t\t.mlen = 16,\n\t},\n\t[TUNNEL_TO_REG] = {\n\t\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_1,\n\t\t.moffset = 8,\n\t\t.mlen = ESW_TUN_OPTS_BITS + ESW_TUN_ID_BITS,\n\t\t.soffset = MLX5_BYTE_OFF(fte_match_param,\n\t\t\t\t\t misc_parameters_2.metadata_reg_c_1),\n\t},\n\t[ZONE_TO_REG] = zone_to_reg_ct,\n\t[ZONE_RESTORE_TO_REG] = zone_restore_to_reg_ct,\n\t[CTSTATE_TO_REG] = ctstate_to_reg_ct,\n\t[MARK_TO_REG] = mark_to_reg_ct,\n\t[LABELS_TO_REG] = labels_to_reg_ct,\n\t[FTEID_TO_REG] = fteid_to_reg_ct,\n\t \n\t[NIC_MAPPED_OBJ_TO_REG] = {\n\t\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_B,\n\t\t.moffset = 0,\n\t\t.mlen = 16,\n\t},\n\t[NIC_ZONE_RESTORE_TO_REG] = nic_zone_restore_to_reg_ct,\n\t[PACKET_COLOR_TO_REG] = packet_color_to_reg,\n};\n\nstruct mlx5e_tc_jump_state {\n\tu32 jump_count;\n\tbool jump_target;\n\tstruct mlx5_flow_attr *jumping_attr;\n\n\tenum flow_action_id last_id;\n\tu32 last_index;\n};\n\nstruct mlx5e_tc_table *mlx5e_tc_table_alloc(void)\n{\n\tstruct mlx5e_tc_table *tc;\n\n\ttc = kvzalloc(sizeof(*tc), GFP_KERNEL);\n\treturn tc ? tc : ERR_PTR(-ENOMEM);\n}\n\nvoid mlx5e_tc_table_free(struct mlx5e_tc_table *tc)\n{\n\tkvfree(tc);\n}\n\nstruct mlx5_fs_chains *mlx5e_nic_chains(struct mlx5e_tc_table *tc)\n{\n\treturn tc->chains;\n}\n\n \nstatic struct lock_class_key tc_ht_lock_key;\nstatic struct lock_class_key tc_ht_wq_key;\n\nstatic void mlx5e_put_flow_tunnel_id(struct mlx5e_tc_flow *flow);\nstatic void free_flow_post_acts(struct mlx5e_tc_flow *flow);\nstatic void mlx5_free_flow_attr_actions(struct mlx5e_tc_flow *flow,\n\t\t\t\t\tstruct mlx5_flow_attr *attr);\n\nvoid\nmlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,\n\t\t\t    enum mlx5e_tc_attr_to_reg type,\n\t\t\t    u32 val,\n\t\t\t    u32 mask)\n{\n\tvoid *headers_c = spec->match_criteria, *headers_v = spec->match_value, *fmask, *fval;\n\tint soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;\n\tint moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;\n\tint match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;\n\tu32 max_mask = GENMASK(match_len - 1, 0);\n\t__be32 curr_mask_be, curr_val_be;\n\tu32 curr_mask, curr_val;\n\n\tfmask = headers_c + soffset;\n\tfval = headers_v + soffset;\n\n\tmemcpy(&curr_mask_be, fmask, 4);\n\tmemcpy(&curr_val_be, fval, 4);\n\n\tcurr_mask = be32_to_cpu(curr_mask_be);\n\tcurr_val = be32_to_cpu(curr_val_be);\n\n\t\n\tWARN_ON(mask > max_mask);\n\tmask <<= moffset;\n\tval <<= moffset;\n\tmax_mask <<= moffset;\n\n\t\n\tcurr_mask &= ~max_mask;\n\tcurr_val &= ~max_mask;\n\n\t\n\tcurr_mask |= mask;\n\tcurr_val |= val;\n\n\t\n\tcurr_mask_be = cpu_to_be32(curr_mask);\n\tcurr_val_be = cpu_to_be32(curr_val);\n\n\tmemcpy(fmask, &curr_mask_be, 4);\n\tmemcpy(fval, &curr_val_be, 4);\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;\n}\n\nvoid\nmlx5e_tc_match_to_reg_get_match(struct mlx5_flow_spec *spec,\n\t\t\t\tenum mlx5e_tc_attr_to_reg type,\n\t\t\t\tu32 *val,\n\t\t\t\tu32 *mask)\n{\n\tvoid *headers_c = spec->match_criteria, *headers_v = spec->match_value, *fmask, *fval;\n\tint soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;\n\tint moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;\n\tint match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;\n\tu32 max_mask = GENMASK(match_len - 1, 0);\n\t__be32 curr_mask_be, curr_val_be;\n\tu32 curr_mask, curr_val;\n\n\tfmask = headers_c + soffset;\n\tfval = headers_v + soffset;\n\n\tmemcpy(&curr_mask_be, fmask, 4);\n\tmemcpy(&curr_val_be, fval, 4);\n\n\tcurr_mask = be32_to_cpu(curr_mask_be);\n\tcurr_val = be32_to_cpu(curr_val_be);\n\n\t*mask = (curr_mask >> moffset) & max_mask;\n\t*val = (curr_val >> moffset) & max_mask;\n}\n\nint\nmlx5e_tc_match_to_reg_set_and_get_id(struct mlx5_core_dev *mdev,\n\t\t\t\t     struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,\n\t\t\t\t     enum mlx5_flow_namespace_type ns,\n\t\t\t\t     enum mlx5e_tc_attr_to_reg type,\n\t\t\t\t     u32 data)\n{\n\tint moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;\n\tint mfield = mlx5e_tc_attr_to_reg_mappings[type].mfield;\n\tint mlen = mlx5e_tc_attr_to_reg_mappings[type].mlen;\n\tchar *modact;\n\tint err;\n\n\tmodact = mlx5e_mod_hdr_alloc(mdev, ns, mod_hdr_acts);\n\tif (IS_ERR(modact))\n\t\treturn PTR_ERR(modact);\n\n\t \n\tif (mlen == 32)\n\t\tmlen = 0;\n\n\tMLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, modact, field, mfield);\n\tMLX5_SET(set_action_in, modact, offset, moffset);\n\tMLX5_SET(set_action_in, modact, length, mlen);\n\tMLX5_SET(set_action_in, modact, data, data);\n\terr = mod_hdr_acts->num_actions;\n\tmod_hdr_acts->num_actions++;\n\n\treturn err;\n}\n\nstatic struct mlx5e_tc_act_stats_handle  *\nget_act_stats_handle(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\n\tif (is_mdev_switchdev_mode(priv->mdev)) {\n\t\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\t\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\t\treturn uplink_priv->action_stats_handle;\n\t}\n\n\treturn tc->action_stats_handle;\n}\n\nstruct mlx5e_tc_int_port_priv *\nmlx5e_get_int_port_priv(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\n\tif (is_mdev_switchdev_mode(priv->mdev)) {\n\t\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\t\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\t\treturn uplink_priv->int_port_priv;\n\t}\n\n\treturn NULL;\n}\n\nstruct mlx5e_flow_meters *\nmlx5e_get_flow_meters(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_eswitch *esw = dev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct mlx5e_priv *priv;\n\n\tif (is_mdev_switchdev_mode(dev)) {\n\t\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\t\tuplink_priv = &uplink_rpriv->uplink_priv;\n\t\tpriv = netdev_priv(uplink_rpriv->netdev);\n\t\tif (!uplink_priv->flow_meters)\n\t\t\tuplink_priv->flow_meters =\n\t\t\t\tmlx5e_flow_meters_init(priv,\n\t\t\t\t\t\t       MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\t\t       uplink_priv->post_act);\n\t\tif (!IS_ERR(uplink_priv->flow_meters))\n\t\t\treturn uplink_priv->flow_meters;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlx5_tc_ct_priv *\nget_ct_priv(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\n\tif (is_mdev_switchdev_mode(priv->mdev)) {\n\t\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\t\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\t\treturn uplink_priv->ct_priv;\n\t}\n\n\treturn tc->ct;\n}\n\nstatic struct mlx5e_tc_psample *\nget_sample_priv(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\n\tif (is_mdev_switchdev_mode(priv->mdev)) {\n\t\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\t\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\t\treturn uplink_priv->tc_psample;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlx5e_post_act *\nget_post_action(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\n\tif (is_mdev_switchdev_mode(priv->mdev)) {\n\t\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\t\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\t\treturn uplink_priv->post_act;\n\t}\n\n\treturn tc->post_act;\n}\n\nstruct mlx5_flow_handle *\nmlx5_tc_rule_insert(struct mlx5e_priv *priv,\n\t\t    struct mlx5_flow_spec *spec,\n\t\t    struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\n\tif (is_mdev_switchdev_mode(priv->mdev))\n\t\treturn mlx5_eswitch_add_offloaded_rule(esw, spec, attr);\n\n\treturn\tmlx5e_add_offloaded_nic_rule(priv, spec, attr);\n}\n\nvoid\nmlx5_tc_rule_delete(struct mlx5e_priv *priv,\n\t\t    struct mlx5_flow_handle *rule,\n\t\t    struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\n\tif (is_mdev_switchdev_mode(priv->mdev)) {\n\t\tmlx5_eswitch_del_offloaded_rule(esw, rule, attr);\n\t\treturn;\n\t}\n\n\tmlx5e_del_offloaded_nic_rule(priv, rule, attr);\n}\n\nstatic bool\nis_flow_meter_action(struct mlx5_flow_attr *attr)\n{\n\treturn (((attr->action & MLX5_FLOW_CONTEXT_ACTION_EXECUTE_ASO) &&\n\t\t (attr->exe_aso_type == MLX5_EXE_ASO_FLOW_METER)) ||\n\t\tattr->flags & MLX5_ATTR_FLAG_MTU);\n}\n\nstatic int\nmlx5e_tc_add_flow_meter(struct mlx5e_priv *priv,\n\t\t\tstruct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_post_act *post_act = get_post_action(priv);\n\tstruct mlx5e_post_meter_priv *post_meter;\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5e_flow_meter_handle *meter;\n\tenum mlx5e_post_meter_type type;\n\n\tif (IS_ERR(post_act))\n\t\treturn PTR_ERR(post_act);\n\n\tmeter = mlx5e_tc_meter_replace(priv->mdev, &attr->meter_attr.params);\n\tif (IS_ERR(meter)) {\n\t\tmlx5_core_err(priv->mdev, \"Failed to get flow meter\\n\");\n\t\treturn PTR_ERR(meter);\n\t}\n\n\tns_type = mlx5e_tc_meter_get_namespace(meter->flow_meters);\n\ttype = meter->params.mtu ? MLX5E_POST_METER_MTU : MLX5E_POST_METER_RATE;\n\tpost_meter = mlx5e_post_meter_init(priv, ns_type, post_act,\n\t\t\t\t\t   type,\n\t\t\t\t\t   meter->act_counter, meter->drop_counter,\n\t\t\t\t\t   attr->branch_true, attr->branch_false);\n\tif (IS_ERR(post_meter)) {\n\t\tmlx5_core_err(priv->mdev, \"Failed to init post meter\\n\");\n\t\tgoto err_meter_init;\n\t}\n\n\tattr->meter_attr.meter = meter;\n\tattr->meter_attr.post_meter = post_meter;\n\tattr->dest_ft = mlx5e_post_meter_get_ft(post_meter);\n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\n\treturn 0;\n\nerr_meter_init:\n\tmlx5e_tc_meter_put(meter);\n\treturn PTR_ERR(post_meter);\n}\n\nstatic void\nmlx5e_tc_del_flow_meter(struct mlx5_eswitch *esw, struct mlx5_flow_attr *attr)\n{\n\tmlx5e_post_meter_cleanup(esw, attr->meter_attr.post_meter);\n\tmlx5e_tc_meter_put(attr->meter_attr.meter);\n}\n\nstruct mlx5_flow_handle *\nmlx5e_tc_rule_offload(struct mlx5e_priv *priv,\n\t\t      struct mlx5_flow_spec *spec,\n\t\t      struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tint err;\n\n\tif (!is_mdev_switchdev_mode(priv->mdev))\n\t\treturn mlx5e_add_offloaded_nic_rule(priv, spec, attr);\n\n\tif (attr->flags & MLX5_ATTR_FLAG_SAMPLE)\n\t\treturn mlx5e_tc_sample_offload(get_sample_priv(priv), spec, attr);\n\n\tif (is_flow_meter_action(attr)) {\n\t\terr = mlx5e_tc_add_flow_meter(priv, attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\treturn mlx5_eswitch_add_offloaded_rule(esw, spec, attr);\n}\n\nvoid\nmlx5e_tc_rule_unoffload(struct mlx5e_priv *priv,\n\t\t\tstruct mlx5_flow_handle *rule,\n\t\t\tstruct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\n\tif (!is_mdev_switchdev_mode(priv->mdev)) {\n\t\tmlx5e_del_offloaded_nic_rule(priv, rule, attr);\n\t\treturn;\n\t}\n\n\tif (attr->flags & MLX5_ATTR_FLAG_SAMPLE) {\n\t\tmlx5e_tc_sample_unoffload(get_sample_priv(priv), rule, attr);\n\t\treturn;\n\t}\n\n\tmlx5_eswitch_del_offloaded_rule(esw, rule, attr);\n\n\tif (attr->meter_attr.meter)\n\t\tmlx5e_tc_del_flow_meter(esw, attr);\n}\n\nint\nmlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,\n\t\t\t  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,\n\t\t\t  enum mlx5_flow_namespace_type ns,\n\t\t\t  enum mlx5e_tc_attr_to_reg type,\n\t\t\t  u32 data)\n{\n\tint ret = mlx5e_tc_match_to_reg_set_and_get_id(mdev, mod_hdr_acts, ns, type, data);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nvoid mlx5e_tc_match_to_reg_mod_hdr_change(struct mlx5_core_dev *mdev,\n\t\t\t\t\t  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,\n\t\t\t\t\t  enum mlx5e_tc_attr_to_reg type,\n\t\t\t\t\t  int act_id, u32 data)\n{\n\tint moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;\n\tint mfield = mlx5e_tc_attr_to_reg_mappings[type].mfield;\n\tint mlen = mlx5e_tc_attr_to_reg_mappings[type].mlen;\n\tchar *modact;\n\n\tmodact = mlx5e_mod_hdr_get_item(mod_hdr_acts, act_id);\n\n\t \n\tif (mlen == 32)\n\t\tmlen = 0;\n\n\tMLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, modact, field, mfield);\n\tMLX5_SET(set_action_in, modact, offset, moffset);\n\tMLX5_SET(set_action_in, modact, length, mlen);\n\tMLX5_SET(set_action_in, modact, data, data);\n}\n\nstruct mlx5e_hairpin {\n\tstruct mlx5_hairpin *pair;\n\n\tstruct mlx5_core_dev *func_mdev;\n\tstruct mlx5e_priv *func_priv;\n\tu32 tdn;\n\tstruct mlx5e_tir direct_tir;\n\n\tint num_channels;\n\tu8 log_num_packets;\n\tstruct mlx5e_rqt indir_rqt;\n\tstruct mlx5e_tir indir_tir[MLX5E_NUM_INDIR_TIRS];\n\tstruct mlx5_ttc_table *ttc;\n};\n\nstruct mlx5e_hairpin_entry {\n\t \n\tstruct hlist_node hairpin_hlist;\n\n\t \n\tspinlock_t flows_lock;\n\t \n\tstruct list_head flows;\n\t \n\tstruct list_head dead_peer_wait_list;\n\n\tu16 peer_vhca_id;\n\tu8 prio;\n\tstruct mlx5e_hairpin *hp;\n\trefcount_t refcnt;\n\tstruct completion res_ready;\n};\n\nstatic void mlx5e_tc_del_flow(struct mlx5e_priv *priv,\n\t\t\t      struct mlx5e_tc_flow *flow);\n\nstruct mlx5e_tc_flow *mlx5e_flow_get(struct mlx5e_tc_flow *flow)\n{\n\tif (!flow || !refcount_inc_not_zero(&flow->refcnt))\n\t\treturn ERR_PTR(-EINVAL);\n\treturn flow;\n}\n\nvoid mlx5e_flow_put(struct mlx5e_priv *priv, struct mlx5e_tc_flow *flow)\n{\n\tif (refcount_dec_and_test(&flow->refcnt)) {\n\t\tmlx5e_tc_del_flow(priv, flow);\n\t\tkfree_rcu(flow, rcu_head);\n\t}\n}\n\nbool mlx5e_is_eswitch_flow(struct mlx5e_tc_flow *flow)\n{\n\treturn flow_flag_test(flow, ESWITCH);\n}\n\nbool mlx5e_is_ft_flow(struct mlx5e_tc_flow *flow)\n{\n\treturn flow_flag_test(flow, FT);\n}\n\nbool mlx5e_is_offloaded_flow(struct mlx5e_tc_flow *flow)\n{\n\treturn flow_flag_test(flow, OFFLOADED);\n}\n\nint mlx5e_get_flow_namespace(struct mlx5e_tc_flow *flow)\n{\n\treturn mlx5e_is_eswitch_flow(flow) ?\n\t\tMLX5_FLOW_NAMESPACE_FDB : MLX5_FLOW_NAMESPACE_KERNEL;\n}\n\nstatic struct mlx5_core_dev *\nget_flow_counter_dev(struct mlx5e_tc_flow *flow)\n{\n\treturn mlx5e_is_eswitch_flow(flow) ? flow->attr->esw_attr->counter_dev : flow->priv->mdev;\n}\n\nstatic struct mod_hdr_tbl *\nget_mod_hdr_table(struct mlx5e_priv *priv, struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\n\treturn mlx5e_get_flow_namespace(flow) == MLX5_FLOW_NAMESPACE_FDB ?\n\t\t&esw->offloads.mod_hdr :\n\t\t&tc->mod_hdr;\n}\n\nint mlx5e_tc_attach_mod_hdr(struct mlx5e_priv *priv,\n\t\t\t    struct mlx5e_tc_flow *flow,\n\t\t\t    struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_mod_hdr_handle *mh;\n\n\tmh = mlx5e_mod_hdr_attach(priv->mdev, get_mod_hdr_table(priv, flow),\n\t\t\t\t  mlx5e_get_flow_namespace(flow),\n\t\t\t\t  &attr->parse_attr->mod_hdr_acts);\n\tif (IS_ERR(mh))\n\t\treturn PTR_ERR(mh);\n\n\tWARN_ON(attr->modify_hdr);\n\tattr->modify_hdr = mlx5e_mod_hdr_get(mh);\n\tattr->mh = mh;\n\n\treturn 0;\n}\n\nvoid mlx5e_tc_detach_mod_hdr(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5e_tc_flow *flow,\n\t\t\t     struct mlx5_flow_attr *attr)\n{\n\t \n\tif (!attr->mh)\n\t\treturn;\n\n\tmlx5e_mod_hdr_detach(priv->mdev, get_mod_hdr_table(priv, flow),\n\t\t\t     attr->mh);\n\tattr->mh = NULL;\n}\n\nstatic\nstruct mlx5_core_dev *mlx5e_hairpin_get_mdev(struct net *net, int ifindex)\n{\n\tstruct mlx5_core_dev *mdev;\n\tstruct net_device *netdev;\n\tstruct mlx5e_priv *priv;\n\n\tnetdev = dev_get_by_index(net, ifindex);\n\tif (!netdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpriv = netdev_priv(netdev);\n\tmdev = priv->mdev;\n\tdev_put(netdev);\n\n\t \n\treturn mdev;\n}\n\nstatic int mlx5e_hairpin_create_transport(struct mlx5e_hairpin *hp)\n{\n\tstruct mlx5e_tir_builder *builder;\n\tint err;\n\n\tbuilder = mlx5e_tir_builder_alloc(false);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_alloc_transport_domain(hp->func_mdev, &hp->tdn);\n\tif (err)\n\t\tgoto out;\n\n\tmlx5e_tir_builder_build_inline(builder, hp->tdn, hp->pair->rqn[0]);\n\terr = mlx5e_tir_init(&hp->direct_tir, builder, hp->func_mdev, false);\n\tif (err)\n\t\tgoto create_tir_err;\n\nout:\n\tmlx5e_tir_builder_free(builder);\n\treturn err;\n\ncreate_tir_err:\n\tmlx5_core_dealloc_transport_domain(hp->func_mdev, hp->tdn);\n\n\tgoto out;\n}\n\nstatic void mlx5e_hairpin_destroy_transport(struct mlx5e_hairpin *hp)\n{\n\tmlx5e_tir_destroy(&hp->direct_tir);\n\tmlx5_core_dealloc_transport_domain(hp->func_mdev, hp->tdn);\n}\n\nstatic int mlx5e_hairpin_create_indirect_rqt(struct mlx5e_hairpin *hp)\n{\n\tstruct mlx5e_priv *priv = hp->func_priv;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_rss_params_indir *indir;\n\tint err;\n\n\tindir = kvmalloc(sizeof(*indir), GFP_KERNEL);\n\tif (!indir)\n\t\treturn -ENOMEM;\n\n\tmlx5e_rss_params_indir_init_uniform(indir, hp->num_channels);\n\terr = mlx5e_rqt_init_indir(&hp->indir_rqt, mdev, hp->pair->rqn, hp->num_channels,\n\t\t\t\t   mlx5e_rx_res_get_current_hash(priv->rx_res).hfunc,\n\t\t\t\t   indir);\n\n\tkvfree(indir);\n\treturn err;\n}\n\nstatic int mlx5e_hairpin_create_indirect_tirs(struct mlx5e_hairpin *hp)\n{\n\tstruct mlx5e_priv *priv = hp->func_priv;\n\tstruct mlx5e_rss_params_hash rss_hash;\n\tenum mlx5_traffic_types tt, max_tt;\n\tstruct mlx5e_tir_builder *builder;\n\tint err = 0;\n\n\tbuilder = mlx5e_tir_builder_alloc(false);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\trss_hash = mlx5e_rx_res_get_current_hash(priv->rx_res);\n\n\tfor (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {\n\t\tstruct mlx5e_rss_params_traffic_type rss_tt;\n\n\t\trss_tt = mlx5e_rss_get_default_tt_config(tt);\n\n\t\tmlx5e_tir_builder_build_rqt(builder, hp->tdn,\n\t\t\t\t\t    mlx5e_rqt_get_rqtn(&hp->indir_rqt),\n\t\t\t\t\t    false);\n\t\tmlx5e_tir_builder_build_rss(builder, &rss_hash, &rss_tt, false);\n\n\t\terr = mlx5e_tir_init(&hp->indir_tir[tt], builder, hp->func_mdev, false);\n\t\tif (err) {\n\t\t\tmlx5_core_warn(hp->func_mdev, \"create indirect tirs failed, %d\\n\", err);\n\t\t\tgoto err_destroy_tirs;\n\t\t}\n\n\t\tmlx5e_tir_builder_clear(builder);\n\t}\n\nout:\n\tmlx5e_tir_builder_free(builder);\n\treturn err;\n\nerr_destroy_tirs:\n\tmax_tt = tt;\n\tfor (tt = 0; tt < max_tt; tt++)\n\t\tmlx5e_tir_destroy(&hp->indir_tir[tt]);\n\n\tgoto out;\n}\n\nstatic void mlx5e_hairpin_destroy_indirect_tirs(struct mlx5e_hairpin *hp)\n{\n\tint tt;\n\n\tfor (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)\n\t\tmlx5e_tir_destroy(&hp->indir_tir[tt]);\n}\n\nstatic void mlx5e_hairpin_set_ttc_params(struct mlx5e_hairpin *hp,\n\t\t\t\t\t struct ttc_params *ttc_params)\n{\n\tstruct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;\n\tint tt;\n\n\tmemset(ttc_params, 0, sizeof(*ttc_params));\n\n\tttc_params->ns = mlx5_get_flow_namespace(hp->func_mdev,\n\t\t\t\t\t\t MLX5_FLOW_NAMESPACE_KERNEL);\n\tfor (tt = 0; tt < MLX5_NUM_TT; tt++) {\n\t\tttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\t\tttc_params->dests[tt].tir_num =\n\t\t\ttt == MLX5_TT_ANY ?\n\t\t\t\tmlx5e_tir_get_tirn(&hp->direct_tir) :\n\t\t\t\tmlx5e_tir_get_tirn(&hp->indir_tir[tt]);\n\t}\n\n\tft_attr->level = MLX5E_TC_TTC_FT_LEVEL;\n\tft_attr->prio = MLX5E_TC_PRIO;\n}\n\nstatic int mlx5e_hairpin_rss_init(struct mlx5e_hairpin *hp)\n{\n\tstruct mlx5e_priv *priv = hp->func_priv;\n\tstruct ttc_params ttc_params;\n\tstruct mlx5_ttc_table *ttc;\n\tint err;\n\n\terr = mlx5e_hairpin_create_indirect_rqt(hp);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_hairpin_create_indirect_tirs(hp);\n\tif (err)\n\t\tgoto err_create_indirect_tirs;\n\n\tmlx5e_hairpin_set_ttc_params(hp, &ttc_params);\n\thp->ttc = mlx5_create_ttc_table(priv->mdev, &ttc_params);\n\tif (IS_ERR(hp->ttc)) {\n\t\terr = PTR_ERR(hp->ttc);\n\t\tgoto err_create_ttc_table;\n\t}\n\n\tttc = mlx5e_fs_get_ttc(priv->fs, false);\n\tnetdev_dbg(priv->netdev, \"add hairpin: using %d channels rss ttc table id %x\\n\",\n\t\t   hp->num_channels,\n\t\t   mlx5_get_ttc_flow_table(ttc)->id);\n\n\treturn 0;\n\nerr_create_ttc_table:\n\tmlx5e_hairpin_destroy_indirect_tirs(hp);\nerr_create_indirect_tirs:\n\tmlx5e_rqt_destroy(&hp->indir_rqt);\n\n\treturn err;\n}\n\nstatic void mlx5e_hairpin_rss_cleanup(struct mlx5e_hairpin *hp)\n{\n\tmlx5_destroy_ttc_table(hp->ttc);\n\tmlx5e_hairpin_destroy_indirect_tirs(hp);\n\tmlx5e_rqt_destroy(&hp->indir_rqt);\n}\n\nstatic struct mlx5e_hairpin *\nmlx5e_hairpin_create(struct mlx5e_priv *priv, struct mlx5_hairpin_params *params,\n\t\t     int peer_ifindex)\n{\n\tstruct mlx5_core_dev *func_mdev, *peer_mdev;\n\tstruct mlx5e_hairpin *hp;\n\tstruct mlx5_hairpin *pair;\n\tint err;\n\n\thp = kzalloc(sizeof(*hp), GFP_KERNEL);\n\tif (!hp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfunc_mdev = priv->mdev;\n\tpeer_mdev = mlx5e_hairpin_get_mdev(dev_net(priv->netdev), peer_ifindex);\n\tif (IS_ERR(peer_mdev)) {\n\t\terr = PTR_ERR(peer_mdev);\n\t\tgoto create_pair_err;\n\t}\n\n\tpair = mlx5_core_hairpin_create(func_mdev, peer_mdev, params);\n\tif (IS_ERR(pair)) {\n\t\terr = PTR_ERR(pair);\n\t\tgoto create_pair_err;\n\t}\n\thp->pair = pair;\n\thp->func_mdev = func_mdev;\n\thp->func_priv = priv;\n\thp->num_channels = params->num_channels;\n\thp->log_num_packets = params->log_num_packets;\n\n\terr = mlx5e_hairpin_create_transport(hp);\n\tif (err)\n\t\tgoto create_transport_err;\n\n\tif (hp->num_channels > 1) {\n\t\terr = mlx5e_hairpin_rss_init(hp);\n\t\tif (err)\n\t\t\tgoto rss_init_err;\n\t}\n\n\treturn hp;\n\nrss_init_err:\n\tmlx5e_hairpin_destroy_transport(hp);\ncreate_transport_err:\n\tmlx5_core_hairpin_destroy(hp->pair);\ncreate_pair_err:\n\tkfree(hp);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlx5e_hairpin_destroy(struct mlx5e_hairpin *hp)\n{\n\tif (hp->num_channels > 1)\n\t\tmlx5e_hairpin_rss_cleanup(hp);\n\tmlx5e_hairpin_destroy_transport(hp);\n\tmlx5_core_hairpin_destroy(hp->pair);\n\tkvfree(hp);\n}\n\nstatic inline u32 hash_hairpin_info(u16 peer_vhca_id, u8 prio)\n{\n\treturn (peer_vhca_id << 16 | prio);\n}\n\nstatic struct mlx5e_hairpin_entry *mlx5e_hairpin_get(struct mlx5e_priv *priv,\n\t\t\t\t\t\t     u16 peer_vhca_id, u8 prio)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5e_hairpin_entry *hpe;\n\tu32 hash_key = hash_hairpin_info(peer_vhca_id, prio);\n\n\thash_for_each_possible(tc->hairpin_tbl, hpe,\n\t\t\t       hairpin_hlist, hash_key) {\n\t\tif (hpe->peer_vhca_id == peer_vhca_id && hpe->prio == prio) {\n\t\t\trefcount_inc(&hpe->refcnt);\n\t\t\treturn hpe;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void mlx5e_hairpin_put(struct mlx5e_priv *priv,\n\t\t\t      struct mlx5e_hairpin_entry *hpe)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\t \n\tif (!refcount_dec_and_mutex_lock(&hpe->refcnt, &tc->hairpin_tbl_lock))\n\t\treturn;\n\thash_del(&hpe->hairpin_hlist);\n\tmutex_unlock(&tc->hairpin_tbl_lock);\n\n\tif (!IS_ERR_OR_NULL(hpe->hp)) {\n\t\tnetdev_dbg(priv->netdev, \"del hairpin: peer %s\\n\",\n\t\t\t   dev_name(hpe->hp->pair->peer_mdev->device));\n\n\t\tmlx5e_hairpin_destroy(hpe->hp);\n\t}\n\n\tWARN_ON(!list_empty(&hpe->flows));\n\tkfree(hpe);\n}\n\n#define UNKNOWN_MATCH_PRIO 8\n\nstatic int mlx5e_hairpin_get_prio(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5_flow_spec *spec, u8 *match_prio,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tvoid *headers_c, *headers_v;\n\tu8 prio_val, prio_mask = 0;\n\tbool vlan_present;\n\n#ifdef CONFIG_MLX5_CORE_EN_DCB\n\tif (priv->dcbx_dp.trust_state != MLX5_QPTS_TRUST_PCP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"only PCP trust state supported for hairpin\");\n\t\treturn -EOPNOTSUPP;\n\t}\n#endif\n\theaders_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, outer_headers);\n\theaders_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, outer_headers);\n\n\tvlan_present = MLX5_GET(fte_match_set_lyr_2_4, headers_v, cvlan_tag);\n\tif (vlan_present) {\n\t\tprio_mask = MLX5_GET(fte_match_set_lyr_2_4, headers_c, first_prio);\n\t\tprio_val = MLX5_GET(fte_match_set_lyr_2_4, headers_v, first_prio);\n\t}\n\n\tif (!vlan_present || !prio_mask) {\n\t\tprio_val = UNKNOWN_MATCH_PRIO;\n\t} else if (prio_mask != 0x7) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"masked priority match not supported for hairpin\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*match_prio = prio_val;\n\treturn 0;\n}\n\nstatic int debugfs_hairpin_num_active_get(void *data, u64 *val)\n{\n\tstruct mlx5e_tc_table *tc = data;\n\tstruct mlx5e_hairpin_entry *hpe;\n\tu32 cnt = 0;\n\tu32 bkt;\n\n\tmutex_lock(&tc->hairpin_tbl_lock);\n\thash_for_each(tc->hairpin_tbl, bkt, hpe, hairpin_hlist)\n\t\tcnt++;\n\tmutex_unlock(&tc->hairpin_tbl_lock);\n\n\t*val = cnt;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_hairpin_num_active,\n\t\t\t debugfs_hairpin_num_active_get, NULL, \"%llu\\n\");\n\nstatic int debugfs_hairpin_table_dump_show(struct seq_file *file, void *priv)\n\n{\n\tstruct mlx5e_tc_table *tc = file->private;\n\tstruct mlx5e_hairpin_entry *hpe;\n\tu32 bkt;\n\n\tmutex_lock(&tc->hairpin_tbl_lock);\n\thash_for_each(tc->hairpin_tbl, bkt, hpe, hairpin_hlist)\n\t\tseq_printf(file,\n\t\t\t   \"Hairpin peer_vhca_id %u prio %u refcnt %u num_channels %u num_packets %lu\\n\",\n\t\t\t   hpe->peer_vhca_id, hpe->prio,\n\t\t\t   refcount_read(&hpe->refcnt), hpe->hp->num_channels,\n\t\t\t   BIT(hpe->hp->log_num_packets));\n\tmutex_unlock(&tc->hairpin_tbl_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_hairpin_table_dump);\n\nstatic void mlx5e_tc_debugfs_init(struct mlx5e_tc_table *tc,\n\t\t\t\t  struct dentry *dfs_root)\n{\n\tif (IS_ERR_OR_NULL(dfs_root))\n\t\treturn;\n\n\ttc->dfs_root = debugfs_create_dir(\"tc\", dfs_root);\n\n\tdebugfs_create_file(\"hairpin_num_active\", 0444, tc->dfs_root, tc,\n\t\t\t    &fops_hairpin_num_active);\n\tdebugfs_create_file(\"hairpin_table_dump\", 0444, tc->dfs_root, tc,\n\t\t\t    &debugfs_hairpin_table_dump_fops);\n}\n\nstatic int mlx5e_hairpin_flow_add(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5e_tc_flow *flow,\n\t\t\t\t  struct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct devlink *devlink = priv_to_devlink(priv->mdev);\n\tint peer_ifindex = parse_attr->mirred_ifindex[0];\n\tunion devlink_param_value val = {};\n\tstruct mlx5_hairpin_params params;\n\tstruct mlx5_core_dev *peer_mdev;\n\tstruct mlx5e_hairpin_entry *hpe;\n\tstruct mlx5e_hairpin *hp;\n\tu8 match_prio;\n\tu16 peer_id;\n\tint err;\n\n\tpeer_mdev = mlx5e_hairpin_get_mdev(dev_net(priv->netdev), peer_ifindex);\n\tif (IS_ERR(peer_mdev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid ifindex of mirred device\");\n\t\treturn PTR_ERR(peer_mdev);\n\t}\n\n\tif (!MLX5_CAP_GEN(priv->mdev, hairpin) || !MLX5_CAP_GEN(peer_mdev, hairpin)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"hairpin is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpeer_id = MLX5_CAP_GEN(peer_mdev, vhca_id);\n\terr = mlx5e_hairpin_get_prio(priv, &parse_attr->spec, &match_prio,\n\t\t\t\t     extack);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&tc->hairpin_tbl_lock);\n\thpe = mlx5e_hairpin_get(priv, peer_id, match_prio);\n\tif (hpe) {\n\t\tmutex_unlock(&tc->hairpin_tbl_lock);\n\t\twait_for_completion(&hpe->res_ready);\n\n\t\tif (IS_ERR(hpe->hp)) {\n\t\t\terr = -EREMOTEIO;\n\t\t\tgoto out_err;\n\t\t}\n\t\tgoto attach_flow;\n\t}\n\n\thpe = kzalloc(sizeof(*hpe), GFP_KERNEL);\n\tif (!hpe) {\n\t\tmutex_unlock(&tc->hairpin_tbl_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&hpe->flows_lock);\n\tINIT_LIST_HEAD(&hpe->flows);\n\tINIT_LIST_HEAD(&hpe->dead_peer_wait_list);\n\thpe->peer_vhca_id = peer_id;\n\thpe->prio = match_prio;\n\trefcount_set(&hpe->refcnt, 1);\n\tinit_completion(&hpe->res_ready);\n\n\thash_add(tc->hairpin_tbl, &hpe->hairpin_hlist,\n\t\t hash_hairpin_info(peer_id, match_prio));\n\tmutex_unlock(&tc->hairpin_tbl_lock);\n\n\terr = devl_param_driverinit_value_get(\n\t\tdevlink, MLX5_DEVLINK_PARAM_ID_HAIRPIN_QUEUE_SIZE, &val);\n\tif (err) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tparams.log_num_packets = ilog2(val.vu32);\n\tparams.log_data_size =\n\t\tclamp_t(u32,\n\t\t\tparams.log_num_packets +\n\t\t\t\tMLX5_MPWRQ_MIN_LOG_STRIDE_SZ(priv->mdev),\n\t\t\tMLX5_CAP_GEN(priv->mdev, log_min_hairpin_wq_data_sz),\n\t\t\tMLX5_CAP_GEN(priv->mdev, log_max_hairpin_wq_data_sz));\n\n\tparams.q_counter = priv->q_counter;\n\terr = devl_param_driverinit_value_get(\n\t\tdevlink, MLX5_DEVLINK_PARAM_ID_HAIRPIN_NUM_QUEUES, &val);\n\tif (err) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tparams.num_channels = val.vu32;\n\n\thp = mlx5e_hairpin_create(priv, &params, peer_ifindex);\n\thpe->hp = hp;\n\tcomplete_all(&hpe->res_ready);\n\tif (IS_ERR(hp)) {\n\t\terr = PTR_ERR(hp);\n\t\tgoto out_err;\n\t}\n\n\tnetdev_dbg(priv->netdev, \"add hairpin: tirn %x rqn %x peer %s sqn %x prio %d (log) data %d packets %d\\n\",\n\t\t   mlx5e_tir_get_tirn(&hp->direct_tir), hp->pair->rqn[0],\n\t\t   dev_name(hp->pair->peer_mdev->device),\n\t\t   hp->pair->sqn[0], match_prio, params.log_data_size, params.log_num_packets);\n\nattach_flow:\n\tif (hpe->hp->num_channels > 1) {\n\t\tflow_flag_set(flow, HAIRPIN_RSS);\n\t\tflow->attr->nic_attr->hairpin_ft =\n\t\t\tmlx5_get_ttc_flow_table(hpe->hp->ttc);\n\t} else {\n\t\tflow->attr->nic_attr->hairpin_tirn = mlx5e_tir_get_tirn(&hpe->hp->direct_tir);\n\t}\n\n\tflow->hpe = hpe;\n\tspin_lock(&hpe->flows_lock);\n\tlist_add(&flow->hairpin, &hpe->flows);\n\tspin_unlock(&hpe->flows_lock);\n\n\treturn 0;\n\nout_err:\n\tmlx5e_hairpin_put(priv, hpe);\n\treturn err;\n}\n\nstatic void mlx5e_hairpin_flow_del(struct mlx5e_priv *priv,\n\t\t\t\t   struct mlx5e_tc_flow *flow)\n{\n\t \n\tif (!flow->hpe)\n\t\treturn;\n\n\tspin_lock(&flow->hpe->flows_lock);\n\tlist_del(&flow->hairpin);\n\tspin_unlock(&flow->hpe->flows_lock);\n\n\tmlx5e_hairpin_put(priv, flow->hpe);\n\tflow->hpe = NULL;\n}\n\nstruct mlx5_flow_handle *\nmlx5e_add_offloaded_nic_rule(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5_flow_spec *spec,\n\t\t\t     struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_flow_context *flow_context = &spec->flow_context;\n\tstruct mlx5e_vlan_table *vlan = mlx5e_fs_get_vlan(priv->fs);\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_nic_flow_attr *nic_attr = attr->nic_attr;\n\tstruct mlx5_flow_destination dest[2] = {};\n\tstruct mlx5_fs_chains *nic_chains;\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = attr->action,\n\t\t.flags    = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_table *ft;\n\tint dest_ix = 0;\n\n\tnic_chains = mlx5e_nic_chains(tc);\n\tflow_context->flags |= FLOW_CONTEXT_HAS_TAG;\n\tflow_context->flow_tag = nic_attr->flow_tag;\n\n\tif (attr->dest_ft) {\n\t\tdest[dest_ix].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\tdest[dest_ix].ft = attr->dest_ft;\n\t\tdest_ix++;\n\t} else if (nic_attr->hairpin_ft) {\n\t\tdest[dest_ix].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\tdest[dest_ix].ft = nic_attr->hairpin_ft;\n\t\tdest_ix++;\n\t} else if (nic_attr->hairpin_tirn) {\n\t\tdest[dest_ix].type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\t\tdest[dest_ix].tir_num = nic_attr->hairpin_tirn;\n\t\tdest_ix++;\n\t} else if (attr->action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {\n\t\tdest[dest_ix].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\tif (attr->dest_chain) {\n\t\t\tdest[dest_ix].ft = mlx5_chains_get_table(nic_chains,\n\t\t\t\t\t\t\t\t attr->dest_chain, 1,\n\t\t\t\t\t\t\t\t MLX5E_TC_FT_LEVEL);\n\t\t\tif (IS_ERR(dest[dest_ix].ft))\n\t\t\t\treturn ERR_CAST(dest[dest_ix].ft);\n\t\t} else {\n\t\t\tdest[dest_ix].ft = mlx5e_vlan_get_flowtable(vlan);\n\t\t}\n\t\tdest_ix++;\n\t}\n\n\tif (dest[0].type == MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE &&\n\t    MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, ignore_flow_level))\n\t\tflow_act.flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;\n\n\tif (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\tdest[dest_ix].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\t\tdest[dest_ix].counter_id = mlx5_fc_id(attr->counter);\n\t\tdest_ix++;\n\t}\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)\n\t\tflow_act.modify_hdr = attr->modify_hdr;\n\n\tmutex_lock(&tc->t_lock);\n\tif (IS_ERR_OR_NULL(tc->t)) {\n\t\t \n\t\ttc->t =\n\t\t\tmlx5_chains_get_table(nic_chains, 0, 1, MLX5E_TC_FT_LEVEL);\n\n\t\tif (IS_ERR(tc->t)) {\n\t\t\tmutex_unlock(&tc->t_lock);\n\t\t\tnetdev_err(priv->netdev,\n\t\t\t\t   \"Failed to create tc offload table\\n\");\n\t\t\trule = ERR_CAST(tc->t);\n\t\t\tgoto err_ft_get;\n\t\t}\n\t}\n\tmutex_unlock(&tc->t_lock);\n\n\tif (attr->chain || attr->prio)\n\t\tft = mlx5_chains_get_table(nic_chains,\n\t\t\t\t\t   attr->chain, attr->prio,\n\t\t\t\t\t   MLX5E_TC_FT_LEVEL);\n\telse\n\t\tft = attr->ft;\n\n\tif (IS_ERR(ft)) {\n\t\trule = ERR_CAST(ft);\n\t\tgoto err_ft_get;\n\t}\n\n\tif (attr->outer_match_level != MLX5_MATCH_NONE)\n\t\tspec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;\n\n\trule = mlx5_add_flow_rules(ft, spec,\n\t\t\t\t   &flow_act, dest, dest_ix);\n\tif (IS_ERR(rule))\n\t\tgoto err_rule;\n\n\treturn rule;\n\nerr_rule:\n\tif (attr->chain || attr->prio)\n\t\tmlx5_chains_put_table(nic_chains,\n\t\t\t\t      attr->chain, attr->prio,\n\t\t\t\t      MLX5E_TC_FT_LEVEL);\nerr_ft_get:\n\tif (attr->dest_chain)\n\t\tmlx5_chains_put_table(nic_chains,\n\t\t\t\t      attr->dest_chain, 1,\n\t\t\t\t      MLX5E_TC_FT_LEVEL);\n\n\treturn ERR_CAST(rule);\n}\n\nstatic int\nalloc_flow_attr_counter(struct mlx5_core_dev *counter_dev,\n\t\t\tstruct mlx5_flow_attr *attr)\n\n{\n\tstruct mlx5_fc *counter;\n\n\tcounter = mlx5_fc_create(counter_dev, true);\n\tif (IS_ERR(counter))\n\t\treturn PTR_ERR(counter);\n\n\tattr->counter = counter;\n\treturn 0;\n}\n\nstatic int\nmlx5e_tc_add_nic_flow(struct mlx5e_priv *priv,\n\t\t      struct mlx5e_tc_flow *flow,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\tstruct mlx5_core_dev *dev = priv->mdev;\n\tint err;\n\n\tparse_attr = attr->parse_attr;\n\n\tif (flow_flag_test(flow, HAIRPIN)) {\n\t\terr = mlx5e_hairpin_flow_add(priv, flow, parse_attr, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\terr = alloc_flow_attr_counter(dev, attr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {\n\t\terr = mlx5e_tc_attach_mod_hdr(priv, flow, attr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tflow->rule[0] = mlx5e_add_offloaded_nic_rule(priv, &parse_attr->spec, attr);\n\treturn PTR_ERR_OR_ZERO(flow->rule[0]);\n}\n\nvoid mlx5e_del_offloaded_nic_rule(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5_flow_handle *rule,\n\t\t\t\t  struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_fs_chains *nic_chains;\n\n\tnic_chains = mlx5e_nic_chains(tc);\n\tmlx5_del_flow_rules(rule);\n\n\tif (attr->chain || attr->prio)\n\t\tmlx5_chains_put_table(nic_chains, attr->chain, attr->prio,\n\t\t\t\t      MLX5E_TC_FT_LEVEL);\n\n\tif (attr->dest_chain)\n\t\tmlx5_chains_put_table(nic_chains, attr->dest_chain, 1,\n\t\t\t\t      MLX5E_TC_FT_LEVEL);\n}\n\nstatic void mlx5e_tc_del_nic_flow(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\n\tflow_flag_clear(flow, OFFLOADED);\n\n\tif (!IS_ERR_OR_NULL(flow->rule[0]))\n\t\tmlx5e_del_offloaded_nic_rule(priv, flow->rule[0], attr);\n\n\t \n\tmutex_lock(&tc->t_lock);\n\tif (!mlx5e_tc_num_filters(priv, MLX5_TC_FLAG(NIC_OFFLOAD)) &&\n\t    !IS_ERR_OR_NULL(tc->t)) {\n\t\tmlx5_chains_put_table(mlx5e_nic_chains(tc), 0, 1, MLX5E_TC_FT_LEVEL);\n\t\ttc->t = NULL;\n\t}\n\tmutex_unlock(&tc->t_lock);\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {\n\t\tmlx5e_mod_hdr_dealloc(&attr->parse_attr->mod_hdr_acts);\n\t\tmlx5e_tc_detach_mod_hdr(priv, flow, attr);\n\t}\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_COUNT)\n\t\tmlx5_fc_destroy(priv->mdev, attr->counter);\n\n\tif (flow_flag_test(flow, HAIRPIN))\n\t\tmlx5e_hairpin_flow_del(priv, flow);\n\n\tfree_flow_post_acts(flow);\n\tmlx5_tc_ct_delete_flow(get_ct_priv(flow->priv), attr);\n\n\tkvfree(attr->parse_attr);\n\tkfree(flow->attr);\n}\n\nstruct mlx5_flow_handle *\nmlx5e_tc_offload_fdb_rules(struct mlx5_eswitch *esw,\n\t\t\t   struct mlx5e_tc_flow *flow,\n\t\t\t   struct mlx5_flow_spec *spec,\n\t\t\t   struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_flow_handle *rule;\n\n\tif (attr->flags & MLX5_ATTR_FLAG_SLOW_PATH)\n\t\treturn mlx5_eswitch_add_offloaded_rule(esw, spec, attr);\n\n\trule = mlx5e_tc_rule_offload(flow->priv, spec, attr);\n\n\tif (IS_ERR(rule))\n\t\treturn rule;\n\n\tif (attr->esw_attr->split_count) {\n\t\tflow->rule[1] = mlx5_eswitch_add_fwd_rule(esw, spec, attr);\n\t\tif (IS_ERR(flow->rule[1]))\n\t\t\tgoto err_rule1;\n\t}\n\n\treturn rule;\n\nerr_rule1:\n\tmlx5e_tc_rule_unoffload(flow->priv, rule, attr);\n\treturn flow->rule[1];\n}\n\nvoid mlx5e_tc_unoffload_fdb_rules(struct mlx5_eswitch *esw,\n\t\t\t\t  struct mlx5e_tc_flow *flow,\n\t\t\t\t  struct mlx5_flow_attr *attr)\n{\n\tflow_flag_clear(flow, OFFLOADED);\n\n\tif (attr->flags & MLX5_ATTR_FLAG_SLOW_PATH)\n\t\treturn mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);\n\n\tif (attr->esw_attr->split_count)\n\t\tmlx5_eswitch_del_fwd_rule(esw, flow->rule[1], attr);\n\n\tmlx5e_tc_rule_unoffload(flow->priv, flow->rule[0], attr);\n}\n\nstruct mlx5_flow_handle *\nmlx5e_tc_offload_to_slow_path(struct mlx5_eswitch *esw,\n\t\t\t      struct mlx5e_tc_flow *flow,\n\t\t\t      struct mlx5_flow_spec *spec)\n{\n\tstruct mlx5e_tc_mod_hdr_acts mod_acts = {};\n\tstruct mlx5e_mod_hdr_handle *mh = NULL;\n\tstruct mlx5_flow_attr *slow_attr;\n\tstruct mlx5_flow_handle *rule;\n\tbool fwd_and_modify_cap;\n\tu32 chain_mapping = 0;\n\tint err;\n\n\tslow_attr = mlx5_alloc_flow_attr(MLX5_FLOW_NAMESPACE_FDB);\n\tif (!slow_attr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(slow_attr, flow->attr, ESW_FLOW_ATTR_SZ);\n\tslow_attr->action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tslow_attr->esw_attr->split_count = 0;\n\tslow_attr->flags |= MLX5_ATTR_FLAG_SLOW_PATH;\n\n\tfwd_and_modify_cap = MLX5_CAP_ESW_FLOWTABLE((esw)->dev, fdb_modify_header_fwd_to_table);\n\tif (!fwd_and_modify_cap)\n\t\tgoto skip_restore;\n\n\terr = mlx5_chains_get_chain_mapping(esw_chains(esw), flow->attr->chain, &chain_mapping);\n\tif (err)\n\t\tgoto err_get_chain;\n\n\terr = mlx5e_tc_match_to_reg_set(esw->dev, &mod_acts, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\tMAPPED_OBJ_TO_REG, chain_mapping);\n\tif (err)\n\t\tgoto err_reg_set;\n\n\tmh = mlx5e_mod_hdr_attach(esw->dev, get_mod_hdr_table(flow->priv, flow),\n\t\t\t\t  MLX5_FLOW_NAMESPACE_FDB, &mod_acts);\n\tif (IS_ERR(mh)) {\n\t\terr = PTR_ERR(mh);\n\t\tgoto err_attach;\n\t}\n\n\tslow_attr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\tslow_attr->modify_hdr = mlx5e_mod_hdr_get(mh);\n\nskip_restore:\n\trule = mlx5e_tc_offload_fdb_rules(esw, flow, spec, slow_attr);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tgoto err_offload;\n\t}\n\n\tflow->attr->slow_mh = mh;\n\tflow->chain_mapping = chain_mapping;\n\tflow_flag_set(flow, SLOW);\n\n\tmlx5e_mod_hdr_dealloc(&mod_acts);\n\tkfree(slow_attr);\n\n\treturn rule;\n\nerr_offload:\n\tif (fwd_and_modify_cap)\n\t\tmlx5e_mod_hdr_detach(esw->dev, get_mod_hdr_table(flow->priv, flow), mh);\nerr_attach:\nerr_reg_set:\n\tif (fwd_and_modify_cap)\n\t\tmlx5_chains_put_chain_mapping(esw_chains(esw), chain_mapping);\nerr_get_chain:\n\tmlx5e_mod_hdr_dealloc(&mod_acts);\n\tkfree(slow_attr);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5e_tc_unoffload_from_slow_path(struct mlx5_eswitch *esw,\n\t\t\t\t       struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5e_mod_hdr_handle *slow_mh = flow->attr->slow_mh;\n\tstruct mlx5_flow_attr *slow_attr;\n\n\tslow_attr = mlx5_alloc_flow_attr(MLX5_FLOW_NAMESPACE_FDB);\n\tif (!slow_attr) {\n\t\tmlx5_core_warn(flow->priv->mdev, \"Unable to alloc attr to unoffload slow path rule\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(slow_attr, flow->attr, ESW_FLOW_ATTR_SZ);\n\tslow_attr->action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tslow_attr->esw_attr->split_count = 0;\n\tslow_attr->flags |= MLX5_ATTR_FLAG_SLOW_PATH;\n\tif (slow_mh) {\n\t\tslow_attr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t\tslow_attr->modify_hdr = mlx5e_mod_hdr_get(slow_mh);\n\t}\n\tmlx5e_tc_unoffload_fdb_rules(esw, flow, slow_attr);\n\tif (slow_mh) {\n\t\tmlx5e_mod_hdr_detach(esw->dev, get_mod_hdr_table(flow->priv, flow), slow_mh);\n\t\tmlx5_chains_put_chain_mapping(esw_chains(esw), flow->chain_mapping);\n\t\tflow->chain_mapping = 0;\n\t\tflow->attr->slow_mh = NULL;\n\t}\n\tflow_flag_clear(flow, SLOW);\n\tkfree(slow_attr);\n}\n\n \nstatic void unready_flow_add(struct mlx5e_tc_flow *flow,\n\t\t\t     struct list_head *unready_flows)\n{\n\tflow_flag_set(flow, NOT_READY);\n\tlist_add_tail(&flow->unready, unready_flows);\n}\n\n \nstatic void unready_flow_del(struct mlx5e_tc_flow *flow)\n{\n\tlist_del(&flow->unready);\n\tflow_flag_clear(flow, NOT_READY);\n}\n\nstatic void add_unready_flow(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mlx5_eswitch *esw;\n\n\tesw = flow->priv->mdev->priv.eswitch;\n\trpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &rpriv->uplink_priv;\n\n\tmutex_lock(&uplink_priv->unready_flows_lock);\n\tunready_flow_add(flow, &uplink_priv->unready_flows);\n\tmutex_unlock(&uplink_priv->unready_flows_lock);\n}\n\nstatic void remove_unready_flow(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mlx5_eswitch *esw;\n\n\tesw = flow->priv->mdev->priv.eswitch;\n\trpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &rpriv->uplink_priv;\n\n\tmutex_lock(&uplink_priv->unready_flows_lock);\n\tif (flow_flag_test(flow, NOT_READY))\n\t\tunready_flow_del(flow);\n\tmutex_unlock(&uplink_priv->unready_flows_lock);\n}\n\nbool mlx5e_tc_is_vf_tunnel(struct net_device *out_dev, struct net_device *route_dev)\n{\n\tstruct mlx5_core_dev *out_mdev, *route_mdev;\n\tstruct mlx5e_priv *out_priv, *route_priv;\n\n\tout_priv = netdev_priv(out_dev);\n\tout_mdev = out_priv->mdev;\n\troute_priv = netdev_priv(route_dev);\n\troute_mdev = route_priv->mdev;\n\n\tif (out_mdev->coredev_type != MLX5_COREDEV_PF)\n\t\treturn false;\n\n\tif (route_mdev->coredev_type != MLX5_COREDEV_VF &&\n\t    route_mdev->coredev_type != MLX5_COREDEV_SF)\n\t\treturn false;\n\n\treturn mlx5e_same_hw_devs(out_priv, route_priv);\n}\n\nint mlx5e_tc_query_route_vport(struct net_device *out_dev, struct net_device *route_dev, u16 *vport)\n{\n\tstruct mlx5e_priv *out_priv, *route_priv;\n\tstruct mlx5_core_dev *route_mdev;\n\tstruct mlx5_devcom_comp_dev *pos;\n\tstruct mlx5_eswitch *esw;\n\tu16 vhca_id;\n\tint err;\n\n\tout_priv = netdev_priv(out_dev);\n\tesw = out_priv->mdev->priv.eswitch;\n\troute_priv = netdev_priv(route_dev);\n\troute_mdev = route_priv->mdev;\n\n\tvhca_id = MLX5_CAP_GEN(route_mdev, vhca_id);\n\terr = mlx5_eswitch_vhca_id_to_vport(esw, vhca_id, vport);\n\tif (!err)\n\t\treturn err;\n\n\tif (!mlx5_lag_is_active(out_priv->mdev))\n\t\treturn err;\n\n\trcu_read_lock();\n\terr = -ENODEV;\n\tmlx5_devcom_for_each_peer_entry_rcu(esw->devcom, esw, pos) {\n\t\terr = mlx5_eswitch_vhca_id_to_vport(esw, vhca_id, vport);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic int\nverify_attr_actions(u32 actions, struct netlink_ext_ack *extack)\n{\n\tif (!(actions &\n\t      (MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_DROP))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Rule must have at least one forward/drop action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!(~actions &\n\t      (MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_DROP))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Rule cannot support forward+drop action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (actions & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR &&\n\t    actions & MLX5_FLOW_CONTEXT_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Drop with modify header action is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nhas_encap_dests(struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tint out_index;\n\n\tfor (out_index = 0; out_index < MLX5_MAX_FLOW_FWD_VPORTS; out_index++)\n\t\tif (esw_attr->dests[out_index].flags & MLX5_ESW_DEST_ENCAP)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\npost_process_attr(struct mlx5e_tc_flow *flow,\n\t\t  struct mlx5_flow_attr *attr,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tbool vf_tun;\n\tint err = 0;\n\n\terr = verify_attr_actions(attr->action, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\tif (mlx5e_is_eswitch_flow(flow) && has_encap_dests(attr)) {\n\t\terr = mlx5e_tc_tun_encap_dests_set(flow->priv, flow, attr, extack, &vf_tun);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {\n\t\terr = mlx5e_tc_attach_mod_hdr(flow->priv, flow, attr);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tif (attr->branch_true &&\n\t    attr->branch_true->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {\n\t\terr = mlx5e_tc_attach_mod_hdr(flow->priv, flow, attr->branch_true);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tif (attr->branch_false &&\n\t    attr->branch_false->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {\n\t\terr = mlx5e_tc_attach_mod_hdr(flow->priv, flow, attr->branch_false);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\terr = alloc_flow_attr_counter(get_flow_counter_dev(flow), attr);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\nerr_out:\n\treturn err;\n}\n\nstatic int\nmlx5e_tc_add_fdb_flow(struct mlx5e_priv *priv,\n\t\t      struct mlx5e_tc_flow *flow,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\tstruct mlx5_esw_flow_attr *esw_attr;\n\tu32 max_prio, max_chain;\n\tint err = 0;\n\n\tparse_attr = attr->parse_attr;\n\tesw_attr = attr->esw_attr;\n\n\t \n\tmax_chain = mlx5_chains_get_chain_range(esw_chains(esw));\n\tif (!mlx5e_is_ft_flow(flow) && attr->chain > max_chain) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Requested chain is out of supported range\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\tmax_prio = mlx5_chains_get_prio_range(esw_chains(esw));\n\tif (attr->prio > max_prio) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Requested priority is out of supported range\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\tif (flow_flag_test(flow, TUN_RX)) {\n\t\terr = mlx5e_attach_decap_route(priv, flow);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tif (!attr->chain && esw_attr->int_port &&\n\t\t    attr->action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {\n\t\t\t \n\t\t\tu32 metadata = mlx5_eswitch_get_vport_metadata_for_set(esw,\n\t\t\t\t\t\t\t\t\tesw_attr->in_rep->vport);\n\n\t\t\terr = mlx5e_tc_match_to_reg_set(priv->mdev, &parse_attr->mod_hdr_acts,\n\t\t\t\t\t\t\tMLX5_FLOW_NAMESPACE_FDB, VPORT_TO_REG,\n\t\t\t\t\t\t\tmetadata);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t\t}\n\t}\n\n\tif (flow_flag_test(flow, L3_TO_L2_DECAP)) {\n\t\terr = mlx5e_attach_decap(priv, flow, extack);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tif (netif_is_ovs_master(parse_attr->filter_dev)) {\n\t\tstruct mlx5e_tc_int_port *int_port;\n\n\t\tif (attr->chain) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Internal port rule is only supported on chain 0\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (attr->dest_chain) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Internal port rule offload doesn't support goto action\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tint_port = mlx5e_tc_int_port_get(mlx5e_get_int_port_priv(priv),\n\t\t\t\t\t\t parse_attr->filter_dev->ifindex,\n\t\t\t\t\t\t flow_flag_test(flow, EGRESS) ?\n\t\t\t\t\t\t MLX5E_TC_INT_PORT_EGRESS :\n\t\t\t\t\t\t MLX5E_TC_INT_PORT_INGRESS);\n\t\tif (IS_ERR(int_port)) {\n\t\t\terr = PTR_ERR(int_port);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tesw_attr->int_port = int_port;\n\t}\n\n\terr = post_process_attr(flow, attr, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = mlx5e_tc_act_stats_add_flow(get_act_stats_handle(priv), flow);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tif (flow_flag_test(flow, SLOW))\n\t\tflow->rule[0] = mlx5e_tc_offload_to_slow_path(esw, flow, &parse_attr->spec);\n\telse\n\t\tflow->rule[0] = mlx5e_tc_offload_fdb_rules(esw, flow, &parse_attr->spec, attr);\n\n\tif (IS_ERR(flow->rule[0])) {\n\t\terr = PTR_ERR(flow->rule[0]);\n\t\tgoto err_out;\n\t}\n\tflow_flag_set(flow, OFFLOADED);\n\n\treturn 0;\n\nerr_out:\n\tflow_flag_set(flow, FAILED);\n\treturn err;\n}\n\nstatic bool mlx5_flow_has_geneve_opt(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_flow_spec *spec = &flow->attr->parse_attr->spec;\n\tvoid *headers_v = MLX5_ADDR_OF(fte_match_param,\n\t\t\t\t       spec->match_value,\n\t\t\t\t       misc_parameters_3);\n\tu32 geneve_tlv_opt_0_data = MLX5_GET(fte_match_set_misc3,\n\t\t\t\t\t     headers_v,\n\t\t\t\t\t     geneve_tlv_option_0_data);\n\n\treturn !!geneve_tlv_opt_0_data;\n}\n\nstatic void free_branch_attr(struct mlx5e_tc_flow *flow, struct mlx5_flow_attr *attr)\n{\n\tif (!attr)\n\t\treturn;\n\n\tmlx5_free_flow_attr_actions(flow, attr);\n\tkvfree(attr->parse_attr);\n\tkfree(attr);\n}\n\nstatic void mlx5e_tc_del_fdb_flow(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\n\tmlx5e_put_flow_tunnel_id(flow);\n\n\tremove_unready_flow(flow);\n\n\tif (mlx5e_is_offloaded_flow(flow)) {\n\t\tif (flow_flag_test(flow, SLOW))\n\t\t\tmlx5e_tc_unoffload_from_slow_path(esw, flow);\n\t\telse\n\t\t\tmlx5e_tc_unoffload_fdb_rules(esw, flow, attr);\n\t}\n\tcomplete_all(&flow->del_hw_done);\n\n\tif (mlx5_flow_has_geneve_opt(flow))\n\t\tmlx5_geneve_tlv_option_del(priv->mdev->geneve);\n\n\tif (flow->decap_route)\n\t\tmlx5e_detach_decap_route(priv, flow);\n\n\tmlx5_tc_ct_match_del(get_ct_priv(priv), &flow->attr->ct_attr);\n\n\tif (flow_flag_test(flow, L3_TO_L2_DECAP))\n\t\tmlx5e_detach_decap(priv, flow);\n\n\tmlx5e_tc_act_stats_del_flow(get_act_stats_handle(priv), flow);\n\n\tfree_flow_post_acts(flow);\n\tmlx5_free_flow_attr_actions(flow, attr);\n\n\tkvfree(attr->esw_attr->rx_tun_attr);\n\tkvfree(attr->parse_attr);\n\tkfree(flow->attr);\n}\n\nstruct mlx5_fc *mlx5e_tc_get_counter(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_flow_attr *attr;\n\n\tattr = list_first_entry(&flow->attrs, struct mlx5_flow_attr, list);\n\treturn attr->counter;\n}\n\n \nvoid mlx5e_put_flow_list(struct mlx5e_priv *priv, struct list_head *flow_list)\n{\n\tstruct mlx5e_tc_flow *flow, *tmp;\n\n\tlist_for_each_entry_safe(flow, tmp, flow_list, tmp_list)\n\t\tmlx5e_flow_put(priv, flow);\n}\n\nstatic void mlx5e_tc_del_fdb_peer_flow(struct mlx5e_tc_flow *flow,\n\t\t\t\t       int peer_index)\n{\n\tstruct mlx5_eswitch *esw = flow->priv->mdev->priv.eswitch;\n\tstruct mlx5e_tc_flow *peer_flow;\n\tstruct mlx5e_tc_flow *tmp;\n\n\tif (!flow_flag_test(flow, ESWITCH) ||\n\t    !flow_flag_test(flow, DUP))\n\t\treturn;\n\n\tmutex_lock(&esw->offloads.peer_mutex);\n\tlist_del(&flow->peer[peer_index]);\n\tmutex_unlock(&esw->offloads.peer_mutex);\n\n\tlist_for_each_entry_safe(peer_flow, tmp, &flow->peer_flows, peer_flows) {\n\t\tif (peer_index != mlx5_get_dev_index(peer_flow->priv->mdev))\n\t\t\tcontinue;\n\t\tif (refcount_dec_and_test(&peer_flow->refcnt)) {\n\t\t\tmlx5e_tc_del_fdb_flow(peer_flow->priv, peer_flow);\n\t\t\tlist_del(&peer_flow->peer_flows);\n\t\t\tkfree(peer_flow);\n\t\t}\n\t}\n\n\tif (list_empty(&flow->peer_flows))\n\t\tflow_flag_clear(flow, DUP);\n}\n\nstatic void mlx5e_tc_del_fdb_peers_flow(struct mlx5e_tc_flow *flow)\n{\n\tint i;\n\n\tfor (i = 0; i < MLX5_MAX_PORTS; i++) {\n\t\tif (i == mlx5_get_dev_index(flow->priv->mdev))\n\t\t\tcontinue;\n\t\tmlx5e_tc_del_fdb_peer_flow(flow, i);\n\t}\n}\n\nstatic void mlx5e_tc_del_flow(struct mlx5e_priv *priv,\n\t\t\t      struct mlx5e_tc_flow *flow)\n{\n\tif (mlx5e_is_eswitch_flow(flow)) {\n\t\tstruct mlx5_devcom_comp_dev *devcom = flow->priv->mdev->priv.eswitch->devcom;\n\n\t\tif (!mlx5_devcom_for_each_peer_begin(devcom)) {\n\t\t\tmlx5e_tc_del_fdb_flow(priv, flow);\n\t\t\treturn;\n\t\t}\n\n\t\tmlx5e_tc_del_fdb_peers_flow(flow);\n\t\tmlx5_devcom_for_each_peer_end(devcom);\n\t\tmlx5e_tc_del_fdb_flow(priv, flow);\n\t} else {\n\t\tmlx5e_tc_del_nic_flow(priv, flow);\n\t}\n}\n\nstatic bool flow_requires_tunnel_mapping(u32 chain, struct flow_cls_offload *f)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_action *flow_action = &rule->action;\n\tconst struct flow_action_entry *act;\n\tint i;\n\n\tif (chain)\n\t\treturn false;\n\n\tflow_action_for_each(i, act, flow_action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_GOTO:\n\t\t\treturn true;\n\t\tcase FLOW_ACTION_SAMPLE:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int\nenc_opts_is_dont_care_or_full_match(struct mlx5e_priv *priv,\n\t\t\t\t    struct flow_dissector_key_enc_opts *opts,\n\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t    bool *dont_care)\n{\n\tstruct geneve_opt *opt;\n\tint off = 0;\n\n\t*dont_care = true;\n\n\twhile (opts->len > off) {\n\t\topt = (struct geneve_opt *)&opts->data[off];\n\n\t\tif (!(*dont_care) || opt->opt_class || opt->type ||\n\t\t    memchr_inv(opt->opt_data, 0, opt->length * 4)) {\n\t\t\t*dont_care = false;\n\n\t\t\tif (opt->opt_class != htons(U16_MAX) ||\n\t\t\t    opt->type != U8_MAX) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Partial match of tunnel options in chain > 0 isn't supported\");\n\t\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t\t    \"Partial match of tunnel options in chain > 0 isn't supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\n\t\toff += sizeof(struct geneve_opt) + opt->length * 4;\n\t}\n\n\treturn 0;\n}\n\n#define COPY_DISSECTOR(rule, diss_key, dst)\\\n({ \\\n\tstruct flow_rule *__rule = (rule);\\\n\ttypeof(dst) __dst = dst;\\\n\\\n\tmemcpy(__dst,\\\n\t       skb_flow_dissector_target(__rule->match.dissector,\\\n\t\t\t\t\t diss_key,\\\n\t\t\t\t\t __rule->match.key),\\\n\t       sizeof(*__dst));\\\n})\n\nstatic int mlx5e_get_flow_tunnel_id(struct mlx5e_priv *priv,\n\t\t\t\t    struct mlx5e_tc_flow *flow,\n\t\t\t\t    struct flow_cls_offload *f,\n\t\t\t\t    struct net_device *filter_dev)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct mlx5e_tc_mod_hdr_acts *mod_hdr_acts;\n\tstruct flow_match_enc_opts enc_opts_match;\n\tstruct tunnel_match_enc_opts tun_enc_opts;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct tunnel_match_key tunnel_key;\n\tbool enc_opts_is_dont_care = true;\n\tu32 tun_id, enc_opts_id = 0;\n\tstruct mlx5_eswitch *esw;\n\tu32 value, mask;\n\tint err;\n\n\tesw = priv->mdev->priv.eswitch;\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\tmemset(&tunnel_key, 0, sizeof(tunnel_key));\n\tCOPY_DISSECTOR(rule, FLOW_DISSECTOR_KEY_ENC_CONTROL,\n\t\t       &tunnel_key.enc_control);\n\tif (tunnel_key.enc_control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS)\n\t\tCOPY_DISSECTOR(rule, FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS,\n\t\t\t       &tunnel_key.enc_ipv4);\n\telse\n\t\tCOPY_DISSECTOR(rule, FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS,\n\t\t\t       &tunnel_key.enc_ipv6);\n\tCOPY_DISSECTOR(rule, FLOW_DISSECTOR_KEY_ENC_IP, &tunnel_key.enc_ip);\n\tCOPY_DISSECTOR(rule, FLOW_DISSECTOR_KEY_ENC_PORTS,\n\t\t       &tunnel_key.enc_tp);\n\tCOPY_DISSECTOR(rule, FLOW_DISSECTOR_KEY_ENC_KEYID,\n\t\t       &tunnel_key.enc_key_id);\n\ttunnel_key.filter_ifindex = filter_dev->ifindex;\n\n\terr = mapping_add(uplink_priv->tunnel_mapping, &tunnel_key, &tun_id);\n\tif (err)\n\t\treturn err;\n\n\tflow_rule_match_enc_opts(rule, &enc_opts_match);\n\terr = enc_opts_is_dont_care_or_full_match(priv,\n\t\t\t\t\t\t  enc_opts_match.mask,\n\t\t\t\t\t\t  extack,\n\t\t\t\t\t\t  &enc_opts_is_dont_care);\n\tif (err)\n\t\tgoto err_enc_opts;\n\n\tif (!enc_opts_is_dont_care) {\n\t\tmemset(&tun_enc_opts, 0, sizeof(tun_enc_opts));\n\t\tmemcpy(&tun_enc_opts.key, enc_opts_match.key,\n\t\t       sizeof(*enc_opts_match.key));\n\t\tmemcpy(&tun_enc_opts.mask, enc_opts_match.mask,\n\t\t       sizeof(*enc_opts_match.mask));\n\n\t\terr = mapping_add(uplink_priv->tunnel_enc_opts_mapping,\n\t\t\t\t  &tun_enc_opts, &enc_opts_id);\n\t\tif (err)\n\t\t\tgoto err_enc_opts;\n\t}\n\n\tvalue = tun_id << ENC_OPTS_BITS | enc_opts_id;\n\tmask = enc_opts_id ? TUNNEL_ID_MASK :\n\t\t\t     (TUNNEL_ID_MASK & ~ENC_OPTS_BITS_MASK);\n\n\tif (attr->chain) {\n\t\tmlx5e_tc_match_to_reg_match(&attr->parse_attr->spec,\n\t\t\t\t\t    TUNNEL_TO_REG, value, mask);\n\t} else {\n\t\tmod_hdr_acts = &attr->parse_attr->mod_hdr_acts;\n\t\terr = mlx5e_tc_match_to_reg_set(priv->mdev,\n\t\t\t\t\t\tmod_hdr_acts, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\t\tTUNNEL_TO_REG, value);\n\t\tif (err)\n\t\t\tgoto err_set;\n\n\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t}\n\n\tflow->attr->tunnel_id = value;\n\treturn 0;\n\nerr_set:\n\tif (enc_opts_id)\n\t\tmapping_remove(uplink_priv->tunnel_enc_opts_mapping,\n\t\t\t       enc_opts_id);\nerr_enc_opts:\n\tmapping_remove(uplink_priv->tunnel_mapping, tun_id);\n\treturn err;\n}\n\nstatic void mlx5e_put_flow_tunnel_id(struct mlx5e_tc_flow *flow)\n{\n\tu32 enc_opts_id = flow->attr->tunnel_id & ENC_OPTS_BITS_MASK;\n\tu32 tun_id = flow->attr->tunnel_id >> ENC_OPTS_BITS;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct mlx5_eswitch *esw;\n\n\tesw = flow->priv->mdev->priv.eswitch;\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\tif (tun_id)\n\t\tmapping_remove(uplink_priv->tunnel_mapping, tun_id);\n\tif (enc_opts_id)\n\t\tmapping_remove(uplink_priv->tunnel_enc_opts_mapping,\n\t\t\t       enc_opts_id);\n}\n\nvoid mlx5e_tc_set_ethertype(struct mlx5_core_dev *mdev,\n\t\t\t    struct flow_match_basic *match, bool outer,\n\t\t\t    void *headers_c, void *headers_v)\n{\n\tbool ip_version_cap;\n\n\tip_version_cap = outer ?\n\t\tMLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\t  ft_field_support.outer_ip_version) :\n\t\tMLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\t  ft_field_support.inner_ip_version);\n\n\tif (ip_version_cap && match->mask->n_proto == htons(0xFFFF) &&\n\t    (match->key->n_proto == htons(ETH_P_IP) ||\n\t     match->key->n_proto == htons(ETH_P_IPV6))) {\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, ip_version);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_version,\n\t\t\t match->key->n_proto == htons(ETH_P_IP) ? 4 : 6);\n\t} else {\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ethertype,\n\t\t\t ntohs(match->mask->n_proto));\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ethertype,\n\t\t\t ntohs(match->key->n_proto));\n\t}\n}\n\nu8 mlx5e_tc_get_ip_version(struct mlx5_flow_spec *spec, bool outer)\n{\n\tvoid *headers_v;\n\tu16 ethertype;\n\tu8 ip_version;\n\n\tif (outer)\n\t\theaders_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, outer_headers);\n\telse\n\t\theaders_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, inner_headers);\n\n\tip_version = MLX5_GET(fte_match_set_lyr_2_4, headers_v, ip_version);\n\t \n\tif (!ip_version) {\n\t\tethertype = MLX5_GET(fte_match_set_lyr_2_4, headers_v, ethertype);\n\t\tif (ethertype == ETH_P_IP || ethertype == ETH_P_ARP)\n\t\t\tip_version = 4;\n\t\telse if (ethertype == ETH_P_IPV6)\n\t\t\tip_version = 6;\n\t}\n\treturn ip_version;\n}\n\n \n\nstatic int mlx5e_tc_verify_tunnel_ecn(struct mlx5e_priv *priv,\n\t\t\t\t      struct flow_cls_offload *f,\n\t\t\t\t      bool *match_inner_ecn)\n{\n\tu8 outer_ecn_mask = 0, outer_ecn_key = 0, inner_ecn_mask = 0, inner_ecn_key = 0;\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_match_ip match;\n\n\t*match_inner_ecn = true;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IP)) {\n\t\tflow_rule_match_enc_ip(rule, &match);\n\t\touter_ecn_key = match.key->tos & INET_ECN_MASK;\n\t\touter_ecn_mask = match.mask->tos & INET_ECN_MASK;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {\n\t\tflow_rule_match_ip(rule, &match);\n\t\tinner_ecn_key = match.key->tos & INET_ECN_MASK;\n\t\tinner_ecn_mask = match.mask->tos & INET_ECN_MASK;\n\t}\n\n\tif (outer_ecn_mask != 0 && outer_ecn_mask != INET_ECN_MASK) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Partial match on enc_tos ecn bits isn't supported\");\n\t\tnetdev_warn(priv->netdev, \"Partial match on enc_tos ecn bits isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!outer_ecn_mask) {\n\t\tif (!inner_ecn_mask)\n\t\t\treturn 0;\n\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on tos ecn bits without also matching enc_tos ecn bits isn't supported\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on tos ecn bits without also matching enc_tos ecn bits isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (inner_ecn_mask && inner_ecn_mask != INET_ECN_MASK) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Partial match on tos ecn bits with match on enc_tos ecn bits isn't supported\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Partial match on tos ecn bits with match on enc_tos ecn bits isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!inner_ecn_mask)\n\t\treturn 0;\n\n\t \n\n\tif (outer_ecn_key == INET_ECN_ECT_1) {\n\t\t \n\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Match on enc_tos ecn = ECT(1) isn't supported\");\n\t\tnetdev_warn(priv->netdev, \"Match on enc_tos ecn = ECT(1) isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (outer_ecn_key != INET_ECN_CE)\n\t\treturn 0;\n\n\tif (inner_ecn_key != INET_ECN_CE) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Match on tos enc_tos ecn = CE while match on tos ecn != CE isn't supported\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Match on tos enc_tos ecn = CE while match on tos ecn != CE isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\t*match_inner_ecn = false;\n\n\treturn 0;\n}\n\nstatic int parse_tunnel_attr(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5e_tc_flow *flow,\n\t\t\t     struct mlx5_flow_spec *spec,\n\t\t\t     struct flow_cls_offload *f,\n\t\t\t     struct net_device *filter_dev,\n\t\t\t     u8 *match_level,\n\t\t\t     bool *match_inner)\n{\n\tstruct mlx5e_tc_tunnel *tunnel = mlx5e_get_tc_tun(filter_dev);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tbool needs_mapping, sets_mapping;\n\tint err;\n\n\tif (!mlx5e_is_eswitch_flow(flow)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Match on tunnel is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tneeds_mapping = !!flow->attr->chain;\n\tsets_mapping = flow_requires_tunnel_mapping(flow->attr->chain, f);\n\t*match_inner = !needs_mapping;\n\n\tif ((needs_mapping || sets_mapping) &&\n\t    !mlx5_eswitch_reg_c1_loopback_enabled(esw)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Chains on tunnel devices isn't supported without register loopback support\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Chains on tunnel devices isn't supported without register loopback support\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!flow->attr->chain) {\n\t\terr = mlx5e_tc_tun_parse(filter_dev, priv, spec, f,\n\t\t\t\t\t match_level);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Failed to parse tunnel attributes\");\n\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t    \"Failed to parse tunnel attributes\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (!netif_is_bareudp(filter_dev))\n\t\t\tflow->attr->action |= MLX5_FLOW_CONTEXT_ACTION_DECAP;\n\t\terr = mlx5e_tc_set_attr_rx_tun(flow, spec);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (tunnel) {\n\t\tstruct mlx5_flow_spec *tmp_spec;\n\n\t\ttmp_spec = kvzalloc(sizeof(*tmp_spec), GFP_KERNEL);\n\t\tif (!tmp_spec) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to allocate memory for tunnel tmp spec\");\n\t\t\tnetdev_warn(priv->netdev, \"Failed to allocate memory for tunnel tmp spec\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(tmp_spec, spec, sizeof(*tmp_spec));\n\n\t\terr = mlx5e_tc_tun_parse(filter_dev, priv, tmp_spec, f, match_level);\n\t\tif (err) {\n\t\t\tkvfree(tmp_spec);\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to parse tunnel attributes\");\n\t\t\tnetdev_warn(priv->netdev, \"Failed to parse tunnel attributes\");\n\t\t\treturn err;\n\t\t}\n\t\terr = mlx5e_tc_set_attr_rx_tun(flow, tmp_spec);\n\t\tkvfree(tmp_spec);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!needs_mapping && !sets_mapping)\n\t\treturn 0;\n\n\treturn mlx5e_get_flow_tunnel_id(priv, flow, f, filter_dev);\n}\n\nstatic void *get_match_inner_headers_criteria(struct mlx5_flow_spec *spec)\n{\n\treturn MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t    inner_headers);\n}\n\nstatic void *get_match_inner_headers_value(struct mlx5_flow_spec *spec)\n{\n\treturn MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t    inner_headers);\n}\n\nstatic void *get_match_outer_headers_criteria(struct mlx5_flow_spec *spec)\n{\n\treturn MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t    outer_headers);\n}\n\nstatic void *get_match_outer_headers_value(struct mlx5_flow_spec *spec)\n{\n\treturn MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t    outer_headers);\n}\n\nvoid *mlx5e_get_match_headers_value(u32 flags, struct mlx5_flow_spec *spec)\n{\n\treturn (flags & MLX5_FLOW_CONTEXT_ACTION_DECAP) ?\n\t\tget_match_inner_headers_value(spec) :\n\t\tget_match_outer_headers_value(spec);\n}\n\nvoid *mlx5e_get_match_headers_criteria(u32 flags, struct mlx5_flow_spec *spec)\n{\n\treturn (flags & MLX5_FLOW_CONTEXT_ACTION_DECAP) ?\n\t\tget_match_inner_headers_criteria(spec) :\n\t\tget_match_outer_headers_criteria(spec);\n}\n\nstatic int mlx5e_flower_parse_meta(struct net_device *filter_dev,\n\t\t\t\t   struct flow_cls_offload *f)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct net_device *ingress_dev;\n\tstruct flow_match_meta match;\n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_META))\n\t\treturn 0;\n\n\tflow_rule_match_meta(rule, &match);\n\n\tif (match.mask->l2_miss) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack, \"Can't match on \\\"l2_miss\\\"\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!match.mask->ingress_ifindex)\n\t\treturn 0;\n\n\tif (match.mask->ingress_ifindex != 0xFFFFFFFF) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported ingress ifindex mask\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tingress_dev = __dev_get_by_index(dev_net(filter_dev),\n\t\t\t\t\t match.key->ingress_ifindex);\n\tif (!ingress_dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can't find the ingress port to match on\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (ingress_dev != filter_dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can't match on the ingress filter port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool skip_key_basic(struct net_device *filter_dev,\n\t\t\t   struct flow_cls_offload *f)\n{\n\t \n\tif (netif_is_bareudp(filter_dev) && f->common.chain_index == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int __parse_cls_flower(struct mlx5e_priv *priv,\n\t\t\t      struct mlx5e_tc_flow *flow,\n\t\t\t      struct mlx5_flow_spec *spec,\n\t\t\t      struct flow_cls_offload *f,\n\t\t\t      struct net_device *filter_dev,\n\t\t\t      u8 *inner_match_level, u8 *outer_match_level)\n{\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tvoid *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t       outer_headers);\n\tvoid *headers_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t       outer_headers);\n\tvoid *misc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    misc_parameters);\n\tvoid *misc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    misc_parameters);\n\tvoid *misc_c_3 = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    misc_parameters_3);\n\tvoid *misc_v_3 = MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    misc_parameters_3);\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tenum fs_flow_table_type fs_type;\n\tbool match_inner_ecn = true;\n\tu16 addr_type = 0;\n\tu8 ip_proto = 0;\n\tu8 *match_level;\n\tint err;\n\n\tfs_type = mlx5e_is_eswitch_flow(flow) ? FS_FT_FDB : FS_FT_NIC_RX;\n\tmatch_level = outer_match_level;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_META) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CVLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_KEYID) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_PORTS)\t|\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_TCP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IP)  |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CT) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_OPTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ICMP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_MPLS))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported key\");\n\t\tnetdev_dbg(priv->netdev, \"Unsupported key used: 0x%llx\\n\",\n\t\t\t   dissector->used_keys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mlx5e_get_tc_tun(filter_dev)) {\n\t\tbool match_inner = false;\n\n\t\terr = parse_tunnel_attr(priv, flow, spec, f, filter_dev,\n\t\t\t\t\touter_match_level, &match_inner);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (match_inner) {\n\t\t\t \n\t\t\tmatch_level = inner_match_level;\n\t\t\theaders_c = get_match_inner_headers_criteria(spec);\n\t\t\theaders_v = get_match_inner_headers_value(spec);\n\t\t}\n\n\t\terr = mlx5e_tc_verify_tunnel_ecn(priv, f, &match_inner_ecn);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mlx5e_flower_parse_meta(filter_dev, f);\n\tif (err)\n\t\treturn err;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC) &&\n\t    !skip_key_basic(filter_dev, f)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tmlx5e_tc_set_ethertype(priv->mdev, &match,\n\t\t\t\t       match_level == outer_match_level,\n\t\t\t\t       headers_c, headers_v);\n\n\t\tif (match.mask->n_proto)\n\t\t\t*match_level = MLX5_MATCH_L2;\n\t}\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN) ||\n\t    is_vlan_dev(filter_dev)) {\n\t\tstruct flow_dissector_key_vlan filter_dev_mask;\n\t\tstruct flow_dissector_key_vlan filter_dev_key;\n\t\tstruct flow_match_vlan match;\n\n\t\tif (is_vlan_dev(filter_dev)) {\n\t\t\tmatch.key = &filter_dev_key;\n\t\t\tmatch.key->vlan_id = vlan_dev_vlan_id(filter_dev);\n\t\t\tmatch.key->vlan_tpid = vlan_dev_vlan_proto(filter_dev);\n\t\t\tmatch.key->vlan_priority = 0;\n\t\t\tmatch.mask = &filter_dev_mask;\n\t\t\tmemset(match.mask, 0xff, sizeof(*match.mask));\n\t\t\tmatch.mask->vlan_priority = 0;\n\t\t} else {\n\t\t\tflow_rule_match_vlan(rule, &match);\n\t\t}\n\t\tif (match.mask->vlan_id ||\n\t\t    match.mask->vlan_priority ||\n\t\t    match.mask->vlan_tpid) {\n\t\t\tif (match.key->vlan_tpid == htons(ETH_P_8021AD)) {\n\t\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t svlan_tag, 1);\n\t\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t svlan_tag, 1);\n\t\t\t} else {\n\t\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t cvlan_tag, 1);\n\t\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t cvlan_tag, 1);\n\t\t\t}\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, first_vid,\n\t\t\t\t match.mask->vlan_id);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, first_vid,\n\t\t\t\t match.key->vlan_id);\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, first_prio,\n\t\t\t\t match.mask->vlan_priority);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, first_prio,\n\t\t\t\t match.key->vlan_priority);\n\n\t\t\t*match_level = MLX5_MATCH_L2;\n\n\t\t\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN) &&\n\t\t\t    match.mask->vlan_eth_type &&\n\t\t\t    MLX5_CAP_FLOWTABLE_TYPE(priv->mdev,\n\t\t\t\t\t\t    ft_field_support.outer_second_vid,\n\t\t\t\t\t\t    fs_type)) {\n\t\t\t\tMLX5_SET(fte_match_set_misc, misc_c,\n\t\t\t\t\t outer_second_cvlan_tag, 1);\n\t\t\t\tspec->match_criteria_enable |=\n\t\t\t\t\tMLX5_MATCH_MISC_PARAMETERS;\n\t\t\t}\n\t\t}\n\t} else if (*match_level != MLX5_MATCH_NONE) {\n\t\t \n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, cvlan_tag, 1);\n\t\t*match_level = MLX5_MATCH_L2;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_cvlan(rule, &match);\n\t\tif (match.mask->vlan_id ||\n\t\t    match.mask->vlan_priority ||\n\t\t    match.mask->vlan_tpid) {\n\t\t\tif (!MLX5_CAP_FLOWTABLE_TYPE(priv->mdev, ft_field_support.outer_second_vid,\n\t\t\t\t\t\t     fs_type)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Matching on CVLAN is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tif (match.key->vlan_tpid == htons(ETH_P_8021AD)) {\n\t\t\t\tMLX5_SET(fte_match_set_misc, misc_c,\n\t\t\t\t\t outer_second_svlan_tag, 1);\n\t\t\t\tMLX5_SET(fte_match_set_misc, misc_v,\n\t\t\t\t\t outer_second_svlan_tag, 1);\n\t\t\t} else {\n\t\t\t\tMLX5_SET(fte_match_set_misc, misc_c,\n\t\t\t\t\t outer_second_cvlan_tag, 1);\n\t\t\t\tMLX5_SET(fte_match_set_misc, misc_v,\n\t\t\t\t\t outer_second_cvlan_tag, 1);\n\t\t\t}\n\n\t\t\tMLX5_SET(fte_match_set_misc, misc_c, outer_second_vid,\n\t\t\t\t match.mask->vlan_id);\n\t\t\tMLX5_SET(fte_match_set_misc, misc_v, outer_second_vid,\n\t\t\t\t match.key->vlan_id);\n\t\t\tMLX5_SET(fte_match_set_misc, misc_c, outer_second_prio,\n\t\t\t\t match.mask->vlan_priority);\n\t\t\tMLX5_SET(fte_match_set_misc, misc_v, outer_second_prio,\n\t\t\t\t match.key->vlan_priority);\n\n\t\t\t*match_level = MLX5_MATCH_L2;\n\t\t\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t     dmac_47_16),\n\t\t\t\tmatch.mask->dst);\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t     dmac_47_16),\n\t\t\t\tmatch.key->dst);\n\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t     smac_47_16),\n\t\t\t\tmatch.mask->src);\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t     smac_47_16),\n\t\t\t\tmatch.key->src);\n\n\t\tif (!is_zero_ether_addr(match.mask->src) ||\n\t\t    !is_zero_ether_addr(match.mask->dst))\n\t\t\t*match_level = MLX5_MATCH_L2;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(rule, &match);\n\t\taddr_type = match.key->addr_type;\n\n\t\t \n\t\tif (match.mask->flags & FLOW_DIS_FIRST_FRAG) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Match on frag first/later is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (match.mask->flags & FLOW_DIS_IS_FRAGMENT) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, frag, 1);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, frag,\n\t\t\t\t match.key->flags & FLOW_DIS_IS_FRAGMENT);\n\n\t\t\t \n\t\t\tif (!(match.key->flags & FLOW_DIS_IS_FRAGMENT))\n\t\t\t\t*match_level = MLX5_MATCH_L2;\n\t \n\t\t\telse\n\t\t\t\t*match_level = MLX5_MATCH_L3;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tip_proto = match.key->ip_proto;\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ip_protocol,\n\t\t\t match.mask->ip_proto);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_protocol,\n\t\t\t match.key->ip_proto);\n\n\t\tif (match.mask->ip_proto)\n\t\t\t*match_level = MLX5_MATCH_L3;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_ipv4_addrs(rule, &match);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &match.mask->src, sizeof(match.mask->src));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &match.key->src, sizeof(match.key->src));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &match.mask->dst, sizeof(match.mask->dst));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &match.key->dst, sizeof(match.key->dst));\n\n\t\tif (match.mask->src || match.mask->dst)\n\t\t\t*match_level = MLX5_MATCH_L3;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\tstruct flow_match_ipv6_addrs match;\n\n\t\tflow_rule_match_ipv6_addrs(rule, &match);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       &match.mask->src, sizeof(match.mask->src));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       &match.key->src, sizeof(match.key->src));\n\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       &match.mask->dst, sizeof(match.mask->dst));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       &match.key->dst, sizeof(match.key->dst));\n\n\t\tif (ipv6_addr_type(&match.mask->src) != IPV6_ADDR_ANY ||\n\t\t    ipv6_addr_type(&match.mask->dst) != IPV6_ADDR_ANY)\n\t\t\t*match_level = MLX5_MATCH_L3;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {\n\t\tstruct flow_match_ip match;\n\n\t\tflow_rule_match_ip(rule, &match);\n\t\tif (match_inner_ecn) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ip_ecn,\n\t\t\t\t match.mask->tos & 0x3);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_ecn,\n\t\t\t\t match.key->tos & 0x3);\n\t\t}\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ip_dscp,\n\t\t\t match.mask->tos >> 2);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_dscp,\n\t\t\t match.key->tos  >> 2);\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ttl_hoplimit,\n\t\t\t match.mask->ttl);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ttl_hoplimit,\n\t\t\t match.key->ttl);\n\n\t\tif (match.mask->ttl &&\n\t\t    !MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,\n\t\t\t\t\t\tft_field_support.outer_ipv4_ttl)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matching on TTL is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (match.mask->tos || match.mask->ttl)\n\t\t\t*match_level = MLX5_MATCH_L3;\n\t}\n\n\t \n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_ports(rule, &match);\n\t\tswitch (ip_proto) {\n\t\tcase IPPROTO_TCP:\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t tcp_sport, ntohs(match.mask->src));\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t tcp_sport, ntohs(match.key->src));\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t tcp_dport, ntohs(match.mask->dst));\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t tcp_dport, ntohs(match.key->dst));\n\t\t\tbreak;\n\n\t\tcase IPPROTO_UDP:\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t udp_sport, ntohs(match.mask->src));\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t udp_sport, ntohs(match.key->src));\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t udp_dport, ntohs(match.mask->dst));\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t udp_dport, ntohs(match.key->dst));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only UDP and TCP transports are supported for L4 matching\");\n\t\t\tnetdev_err(priv->netdev,\n\t\t\t\t   \"Only UDP and TCP transport are supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (match.mask->src || match.mask->dst)\n\t\t\t*match_level = MLX5_MATCH_L4;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_TCP)) {\n\t\tstruct flow_match_tcp match;\n\n\t\tflow_rule_match_tcp(rule, &match);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, tcp_flags,\n\t\t\t ntohs(match.mask->flags));\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, tcp_flags,\n\t\t\t ntohs(match.key->flags));\n\n\t\tif (match.mask->flags)\n\t\t\t*match_level = MLX5_MATCH_L4;\n\t}\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ICMP)) {\n\t\tstruct flow_match_icmp match;\n\n\t\tflow_rule_match_icmp(rule, &match);\n\t\tswitch (ip_proto) {\n\t\tcase IPPROTO_ICMP:\n\t\t\tif (!(MLX5_CAP_GEN(priv->mdev, flex_parser_protocols) &\n\t\t\t      MLX5_FLEX_PROTO_ICMP)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Match on Flex protocols for ICMP is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_c_3, icmp_type,\n\t\t\t\t match.mask->type);\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_v_3, icmp_type,\n\t\t\t\t match.key->type);\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_c_3, icmp_code,\n\t\t\t\t match.mask->code);\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_v_3, icmp_code,\n\t\t\t\t match.key->code);\n\t\t\tbreak;\n\t\tcase IPPROTO_ICMPV6:\n\t\t\tif (!(MLX5_CAP_GEN(priv->mdev, flex_parser_protocols) &\n\t\t\t      MLX5_FLEX_PROTO_ICMPV6)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Match on Flex protocols for ICMPV6 is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_c_3, icmpv6_type,\n\t\t\t\t match.mask->type);\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_v_3, icmpv6_type,\n\t\t\t\t match.key->type);\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_c_3, icmpv6_code,\n\t\t\t\t match.mask->code);\n\t\t\tMLX5_SET(fte_match_set_misc3, misc_v_3, icmpv6_code,\n\t\t\t\t match.key->code);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Code and type matching only with ICMP and ICMPv6\");\n\t\t\tnetdev_err(priv->netdev,\n\t\t\t\t   \"Code and type matching only with ICMP and ICMPv6\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (match.mask->code || match.mask->type) {\n\t\t\t*match_level = MLX5_MATCH_L4;\n\t\t\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_3;\n\t\t}\n\t}\n\t \n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_MPLS) &&\n\t    !netif_is_bareudp(filter_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on MPLS is supported only for MPLS over UDP\");\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"Matching on MPLS is supported only for MPLS over UDP\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_cls_flower(struct mlx5e_priv *priv,\n\t\t\t    struct mlx5e_tc_flow *flow,\n\t\t\t    struct mlx5_flow_spec *spec,\n\t\t\t    struct flow_cls_offload *f,\n\t\t\t    struct net_device *filter_dev)\n{\n\tu8 inner_match_level, outer_match_level, non_tunnel_match_level;\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct mlx5_core_dev *dev = priv->mdev;\n\tstruct mlx5_eswitch *esw = dev->priv.eswitch;\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5_eswitch_rep *rep;\n\tbool is_eswitch_flow;\n\tint err;\n\n\tinner_match_level = MLX5_MATCH_NONE;\n\touter_match_level = MLX5_MATCH_NONE;\n\n\terr = __parse_cls_flower(priv, flow, spec, f, filter_dev,\n\t\t\t\t &inner_match_level, &outer_match_level);\n\tnon_tunnel_match_level = (inner_match_level == MLX5_MATCH_NONE) ?\n\t\t\t\t outer_match_level : inner_match_level;\n\n\tis_eswitch_flow = mlx5e_is_eswitch_flow(flow);\n\tif (!err && is_eswitch_flow) {\n\t\trep = rpriv->rep;\n\t\tif (rep->vport != MLX5_VPORT_UPLINK &&\n\t\t    (esw->offloads.inline_mode != MLX5_INLINE_MODE_NONE &&\n\t\t    esw->offloads.inline_mode < non_tunnel_match_level)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Flow is not offloaded due to min inline setting\");\n\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t    \"Flow is not offloaded due to min inline setting, required %d actual %d\\n\",\n\t\t\t\t    non_tunnel_match_level, esw->offloads.inline_mode);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tflow->attr->inner_match_level = inner_match_level;\n\tflow->attr->outer_match_level = outer_match_level;\n\n\n\treturn err;\n}\n\nstruct mlx5_fields {\n\tu8  field;\n\tu8  field_bsize;\n\tu32 field_mask;\n\tu32 offset;\n\tu32 match_offset;\n};\n\n#define OFFLOAD(fw_field, field_bsize, field_mask, field, off, match_field) \\\n\t\t{MLX5_ACTION_IN_FIELD_OUT_ ## fw_field, field_bsize, field_mask, \\\n\t\t offsetof(struct pedit_headers, field) + (off), \\\n\t\t MLX5_BYTE_OFF(fte_match_set_lyr_2_4, match_field)}\n\n \n#define SAME_VAL_MASK(type, valp, maskp, matchvalp, matchmaskp) ({ \\\n\ttype matchmaskx = *(type *)(matchmaskp); \\\n\ttype matchvalx = *(type *)(matchvalp); \\\n\ttype maskx = *(type *)(maskp); \\\n\ttype valx = *(type *)(valp); \\\n\t\\\n\t(valx & maskx) == (matchvalx & matchmaskx) && !(maskx & (maskx ^ \\\n\t\t\t\t\t\t\t\t matchmaskx)); \\\n})\n\nstatic bool cmp_val_mask(void *valp, void *maskp, void *matchvalp,\n\t\t\t void *matchmaskp, u8 bsize)\n{\n\tbool same = false;\n\n\tswitch (bsize) {\n\tcase 8:\n\t\tsame = SAME_VAL_MASK(u8, valp, maskp, matchvalp, matchmaskp);\n\t\tbreak;\n\tcase 16:\n\t\tsame = SAME_VAL_MASK(u16, valp, maskp, matchvalp, matchmaskp);\n\t\tbreak;\n\tcase 32:\n\t\tsame = SAME_VAL_MASK(u32, valp, maskp, matchvalp, matchmaskp);\n\t\tbreak;\n\t}\n\n\treturn same;\n}\n\nstatic struct mlx5_fields fields[] = {\n\tOFFLOAD(DMAC_47_16, 32, U32_MAX, eth.h_dest[0], 0, dmac_47_16),\n\tOFFLOAD(DMAC_15_0,  16, U16_MAX, eth.h_dest[4], 0, dmac_15_0),\n\tOFFLOAD(SMAC_47_16, 32, U32_MAX, eth.h_source[0], 0, smac_47_16),\n\tOFFLOAD(SMAC_15_0,  16, U16_MAX, eth.h_source[4], 0, smac_15_0),\n\tOFFLOAD(ETHERTYPE,  16, U16_MAX, eth.h_proto, 0, ethertype),\n\tOFFLOAD(FIRST_VID,  16, U16_MAX, vlan.h_vlan_TCI, 0, first_vid),\n\n\tOFFLOAD(IP_DSCP, 8,    0xfc, ip4.tos,   0, ip_dscp),\n\tOFFLOAD(IP_TTL,  8,  U8_MAX, ip4.ttl,   0, ttl_hoplimit),\n\tOFFLOAD(SIPV4,  32, U32_MAX, ip4.saddr, 0, src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\tOFFLOAD(DIPV4,  32, U32_MAX, ip4.daddr, 0, dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\n\tOFFLOAD(SIPV6_127_96, 32, U32_MAX, ip6.saddr.s6_addr32[0], 0,\n\t\tsrc_ipv4_src_ipv6.ipv6_layout.ipv6[0]),\n\tOFFLOAD(SIPV6_95_64,  32, U32_MAX, ip6.saddr.s6_addr32[1], 0,\n\t\tsrc_ipv4_src_ipv6.ipv6_layout.ipv6[4]),\n\tOFFLOAD(SIPV6_63_32,  32, U32_MAX, ip6.saddr.s6_addr32[2], 0,\n\t\tsrc_ipv4_src_ipv6.ipv6_layout.ipv6[8]),\n\tOFFLOAD(SIPV6_31_0,   32, U32_MAX, ip6.saddr.s6_addr32[3], 0,\n\t\tsrc_ipv4_src_ipv6.ipv6_layout.ipv6[12]),\n\tOFFLOAD(DIPV6_127_96, 32, U32_MAX, ip6.daddr.s6_addr32[0], 0,\n\t\tdst_ipv4_dst_ipv6.ipv6_layout.ipv6[0]),\n\tOFFLOAD(DIPV6_95_64,  32, U32_MAX, ip6.daddr.s6_addr32[1], 0,\n\t\tdst_ipv4_dst_ipv6.ipv6_layout.ipv6[4]),\n\tOFFLOAD(DIPV6_63_32,  32, U32_MAX, ip6.daddr.s6_addr32[2], 0,\n\t\tdst_ipv4_dst_ipv6.ipv6_layout.ipv6[8]),\n\tOFFLOAD(DIPV6_31_0,   32, U32_MAX, ip6.daddr.s6_addr32[3], 0,\n\t\tdst_ipv4_dst_ipv6.ipv6_layout.ipv6[12]),\n\tOFFLOAD(IPV6_HOPLIMIT, 8,  U8_MAX, ip6.hop_limit, 0, ttl_hoplimit),\n\tOFFLOAD(IP_DSCP, 16,  0x0fc0, ip6, 0, ip_dscp),\n\n\tOFFLOAD(TCP_SPORT, 16, U16_MAX, tcp.source,  0, tcp_sport),\n\tOFFLOAD(TCP_DPORT, 16, U16_MAX, tcp.dest,    0, tcp_dport),\n\t \n\tOFFLOAD(TCP_FLAGS,  8,  U8_MAX, tcp.ack_seq, 5, tcp_flags),\n\n\tOFFLOAD(UDP_SPORT, 16, U16_MAX, udp.source, 0, udp_sport),\n\tOFFLOAD(UDP_DPORT, 16, U16_MAX, udp.dest,   0, udp_dport),\n};\n\nstatic u32 mask_field_get(void *mask, struct mlx5_fields *f)\n{\n\tswitch (f->field_bsize) {\n\tcase 32:\n\t\treturn be32_to_cpu(*(__be32 *)mask) & f->field_mask;\n\tcase 16:\n\t\treturn be16_to_cpu(*(__be16 *)mask) & (u16)f->field_mask;\n\tdefault:\n\t\treturn *(u8 *)mask & (u8)f->field_mask;\n\t}\n}\n\nstatic void mask_field_clear(void *mask, struct mlx5_fields *f)\n{\n\tswitch (f->field_bsize) {\n\tcase 32:\n\t\t*(__be32 *)mask &= ~cpu_to_be32(f->field_mask);\n\t\tbreak;\n\tcase 16:\n\t\t*(__be16 *)mask &= ~cpu_to_be16((u16)f->field_mask);\n\t\tbreak;\n\tdefault:\n\t\t*(u8 *)mask &= ~(u8)f->field_mask;\n\t\tbreak;\n\t}\n}\n\nstatic int offload_pedit_fields(struct mlx5e_priv *priv,\n\t\t\t\tint namespace,\n\t\t\t\tstruct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t\t\tu32 *action_flags,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct pedit_headers *set_masks, *add_masks, *set_vals, *add_vals;\n\tstruct pedit_headers_action *hdrs = parse_attr->hdrs;\n\tvoid *headers_c, *headers_v, *action, *vals_p;\n\tstruct mlx5e_tc_mod_hdr_acts *mod_acts;\n\tvoid *s_masks_p, *a_masks_p;\n\tint i, first, last, next_z;\n\tstruct mlx5_fields *f;\n\tunsigned long mask;\n\tu32 s_mask, a_mask;\n\tu8 cmd;\n\n\tmod_acts = &parse_attr->mod_hdr_acts;\n\theaders_c = mlx5e_get_match_headers_criteria(*action_flags, &parse_attr->spec);\n\theaders_v = mlx5e_get_match_headers_value(*action_flags, &parse_attr->spec);\n\n\tset_masks = &hdrs[0].masks;\n\tadd_masks = &hdrs[1].masks;\n\tset_vals = &hdrs[0].vals;\n\tadd_vals = &hdrs[1].vals;\n\n\tfor (i = 0; i < ARRAY_SIZE(fields); i++) {\n\t\tbool skip;\n\n\t\tf = &fields[i];\n\t\ts_masks_p = (void *)set_masks + f->offset;\n\t\ta_masks_p = (void *)add_masks + f->offset;\n\n\t\ts_mask = mask_field_get(s_masks_p, f);\n\t\ta_mask = mask_field_get(a_masks_p, f);\n\n\t\tif (!s_mask && !a_mask)  \n\t\t\tcontinue;\n\n\t\tif (s_mask && a_mask) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"can't set and add to the same HW field\");\n\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t    \"mlx5: can't set and add to the same HW field (%x)\\n\",\n\t\t\t\t    f->field);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tskip = false;\n\t\tif (s_mask) {\n\t\t\tvoid *match_mask = headers_c + f->match_offset;\n\t\t\tvoid *match_val = headers_v + f->match_offset;\n\n\t\t\tcmd  = MLX5_ACTION_TYPE_SET;\n\t\t\tmask = s_mask;\n\t\t\tvals_p = (void *)set_vals + f->offset;\n\t\t\t \n\t\t\tif (cmp_val_mask(vals_p, s_masks_p, match_val,\n\t\t\t\t\t match_mask, f->field_bsize))\n\t\t\t\tskip = true;\n\t\t\t \n\t\t\tmask_field_clear(s_masks_p, f);\n\t\t} else {\n\t\t\tcmd  = MLX5_ACTION_TYPE_ADD;\n\t\t\tmask = a_mask;\n\t\t\tvals_p = (void *)add_vals + f->offset;\n\t\t\t \n\t\t\tif (!mask_field_get(vals_p, f))\n\t\t\t\tskip = true;\n\t\t\t \n\t\t\tmask_field_clear(a_masks_p, f);\n\t\t}\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tfirst = find_first_bit(&mask, f->field_bsize);\n\t\tnext_z = find_next_zero_bit(&mask, f->field_bsize, first);\n\t\tlast  = find_last_bit(&mask, f->field_bsize);\n\t\tif (first < next_z && next_z < last) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"rewrite of few sub-fields isn't supported\");\n\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t    \"mlx5: rewrite of few sub-fields (mask %lx) isn't offloaded\\n\",\n\t\t\t\t    mask);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\taction = mlx5e_mod_hdr_alloc(priv->mdev, namespace, mod_acts);\n\t\tif (IS_ERR(action)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"too many pedit actions, can't offload\");\n\t\t\tmlx5_core_warn(priv->mdev,\n\t\t\t\t       \"mlx5: parsed %d pedit actions, can't do more\\n\",\n\t\t\t\t       mod_acts->num_actions);\n\t\t\treturn PTR_ERR(action);\n\t\t}\n\n\t\tMLX5_SET(set_action_in, action, action_type, cmd);\n\t\tMLX5_SET(set_action_in, action, field, f->field);\n\n\t\tif (cmd == MLX5_ACTION_TYPE_SET) {\n\t\t\tunsigned long field_mask = f->field_mask;\n\t\t\tint start;\n\n\t\t\t \n\t\t\tstart = find_first_bit(&field_mask, f->field_bsize);\n\n\t\t\tMLX5_SET(set_action_in, action, offset, first - start);\n\t\t\t \n\t\t\tMLX5_SET(set_action_in, action, length, (last - first + 1));\n\t\t}\n\n\t\tif (f->field_bsize == 32)\n\t\t\tMLX5_SET(set_action_in, action, data, ntohl(*(__be32 *)vals_p) >> first);\n\t\telse if (f->field_bsize == 16)\n\t\t\tMLX5_SET(set_action_in, action, data, ntohs(*(__be16 *)vals_p) >> first);\n\t\telse if (f->field_bsize == 8)\n\t\t\tMLX5_SET(set_action_in, action, data, *(u8 *)vals_p >> first);\n\n\t\t++mod_acts->num_actions;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pedit_headers zero_masks = {};\n\nstatic int verify_offload_pedit_fields(struct mlx5e_priv *priv,\n\t\t\t\t       struct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct pedit_headers *cmd_masks;\n\tu8 cmd;\n\n\tfor (cmd = 0; cmd < __PEDIT_CMD_MAX; cmd++) {\n\t\tcmd_masks = &parse_attr->hdrs[cmd].masks;\n\t\tif (memcmp(cmd_masks, &zero_masks, sizeof(zero_masks))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"attempt to offload an unsupported field\");\n\t\t\tnetdev_warn(priv->netdev, \"attempt to offload an unsupported field (cmd %d)\\n\", cmd);\n\t\t\tprint_hex_dump(KERN_WARNING, \"mask: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, cmd_masks, sizeof(zero_masks), true);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int alloc_tc_pedit_action(struct mlx5e_priv *priv, int namespace,\n\t\t\t\t struct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t\t\t u32 *action_flags,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = offload_pedit_fields(priv, namespace, parse_attr, action_flags, extack);\n\tif (err)\n\t\tgoto out_dealloc_parsed_actions;\n\n\terr = verify_offload_pedit_fields(priv, parse_attr, extack);\n\tif (err)\n\t\tgoto out_dealloc_parsed_actions;\n\n\treturn 0;\n\nout_dealloc_parsed_actions:\n\tmlx5e_mod_hdr_dealloc(&parse_attr->mod_hdr_acts);\n\treturn err;\n}\n\nstruct ip_ttl_word {\n\t__u8\tttl;\n\t__u8\tprotocol;\n\t__sum16\tcheck;\n};\n\nstruct ipv6_hoplimit_word {\n\t__be16\tpayload_len;\n\t__u8\tnexthdr;\n\t__u8\thop_limit;\n};\n\nstatic bool\nis_flow_action_modify_ip_header(struct flow_action *flow_action)\n{\n\tconst struct flow_action_entry *act;\n\tu32 mask, offset;\n\tu8 htype;\n\tint i;\n\n\t \n\tflow_action_for_each(i, act, flow_action) {\n\t\tif (act->id != FLOW_ACTION_MANGLE &&\n\t\t    act->id != FLOW_ACTION_ADD)\n\t\t\tcontinue;\n\n\t\thtype = act->mangle.htype;\n\t\toffset = act->mangle.offset;\n\t\tmask = ~act->mangle.mask;\n\n\t\tif (htype == FLOW_ACT_MANGLE_HDR_TYPE_IP4) {\n\t\t\tstruct ip_ttl_word *ttl_word =\n\t\t\t\t(struct ip_ttl_word *)&mask;\n\n\t\t\tif (offset != offsetof(struct iphdr, ttl) ||\n\t\t\t    ttl_word->protocol ||\n\t\t\t    ttl_word->check)\n\t\t\t\treturn true;\n\t\t} else if (htype == FLOW_ACT_MANGLE_HDR_TYPE_IP6) {\n\t\t\tstruct ipv6_hoplimit_word *hoplimit_word =\n\t\t\t\t(struct ipv6_hoplimit_word *)&mask;\n\n\t\t\tif (offset != offsetof(struct ipv6hdr, payload_len) ||\n\t\t\t    hoplimit_word->payload_len ||\n\t\t\t    hoplimit_word->nexthdr)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool modify_header_match_supported(struct mlx5e_priv *priv,\n\t\t\t\t\t  struct mlx5_flow_spec *spec,\n\t\t\t\t\t  struct flow_action *flow_action,\n\t\t\t\t\t  u32 actions,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tbool modify_ip_header;\n\tvoid *headers_c;\n\tvoid *headers_v;\n\tu16 ethertype;\n\tu8 ip_proto;\n\n\theaders_c = mlx5e_get_match_headers_criteria(actions, spec);\n\theaders_v = mlx5e_get_match_headers_value(actions, spec);\n\tethertype = MLX5_GET(fte_match_set_lyr_2_4, headers_v, ethertype);\n\n\t \n\tif (MLX5_GET(fte_match_set_lyr_2_4, headers_c, ip_version) == 0 &&\n\t    ethertype != ETH_P_IP && ethertype != ETH_P_IPV6)\n\t\tgoto out_ok;\n\n\tmodify_ip_header = is_flow_action_modify_ip_header(flow_action);\n\tip_proto = MLX5_GET(fte_match_set_lyr_2_4, headers_v, ip_protocol);\n\tif (modify_ip_header && ip_proto != IPPROTO_TCP &&\n\t    ip_proto != IPPROTO_UDP && ip_proto != IPPROTO_ICMP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"can't offload re-write of non TCP/UDP\");\n\t\tnetdev_info(priv->netdev, \"can't offload re-write of ip proto %d\\n\",\n\t\t\t    ip_proto);\n\t\treturn false;\n\t}\n\nout_ok:\n\treturn true;\n}\n\nstatic bool\nactions_match_supported_fdb(struct mlx5e_priv *priv,\n\t\t\t    struct mlx5e_tc_flow *flow,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = flow->attr->esw_attr;\n\n\tif (esw_attr->split_count > 0 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"current firmware doesn't support split rule for port mirroring\");\n\t\tnetdev_warn_once(priv->netdev,\n\t\t\t\t \"current firmware doesn't support split rule for port mirroring\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nactions_match_supported(struct mlx5e_priv *priv,\n\t\t\tstruct flow_action *flow_action,\n\t\t\tu32 actions,\n\t\t\tstruct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t\tstruct mlx5e_tc_flow *flow,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (actions & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR &&\n\t    !modify_header_match_supported(priv, &parse_attr->spec, flow_action, actions,\n\t\t\t\t\t   extack))\n\t\treturn false;\n\n\tif (mlx5e_is_eswitch_flow(flow) &&\n\t    !actions_match_supported_fdb(priv, flow, extack))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool same_port_devs(struct mlx5e_priv *priv, struct mlx5e_priv *peer_priv)\n{\n\treturn priv->mdev == peer_priv->mdev;\n}\n\nbool mlx5e_same_hw_devs(struct mlx5e_priv *priv, struct mlx5e_priv *peer_priv)\n{\n\tstruct mlx5_core_dev *fmdev, *pmdev;\n\tu64 fsystem_guid, psystem_guid;\n\n\tfmdev = priv->mdev;\n\tpmdev = peer_priv->mdev;\n\n\tfsystem_guid = mlx5_query_nic_system_image_guid(fmdev);\n\tpsystem_guid = mlx5_query_nic_system_image_guid(pmdev);\n\n\treturn (fsystem_guid == psystem_guid);\n}\n\nstatic int\nactions_prepare_mod_hdr_actions(struct mlx5e_priv *priv,\n\t\t\t\tstruct mlx5e_tc_flow *flow,\n\t\t\t\tstruct mlx5_flow_attr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;\n\tstruct pedit_headers_action *hdrs = parse_attr->hdrs;\n\tenum mlx5_flow_namespace_type ns_type;\n\tint err;\n\n\tif (!hdrs[TCA_PEDIT_KEY_EX_CMD_SET].pedits &&\n\t    !hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].pedits)\n\t\treturn 0;\n\n\tns_type = mlx5e_get_flow_namespace(flow);\n\n\terr = alloc_tc_pedit_action(priv, ns_type, parse_attr, &attr->action, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (parse_attr->mod_hdr_acts.num_actions > 0)\n\t\treturn 0;\n\n\t \n\tattr->action &= ~MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\tmlx5e_mod_hdr_dealloc(&parse_attr->mod_hdr_acts);\n\n\tif (ns_type != MLX5_FLOW_NAMESPACE_FDB)\n\t\treturn 0;\n\n\tif (!((attr->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP) ||\n\t      (attr->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH)))\n\t\tattr->esw_attr->split_count = 0;\n\n\treturn 0;\n}\n\nstatic struct mlx5_flow_attr*\nmlx5e_clone_flow_attr_for_post_act(struct mlx5_flow_attr *attr,\n\t\t\t\t   enum mlx5_flow_namespace_type ns_type)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tu32 attr_sz = ns_to_attr_sz(ns_type);\n\tstruct mlx5_flow_attr *attr2;\n\n\tattr2 = mlx5_alloc_flow_attr(ns_type);\n\tparse_attr = kvzalloc(sizeof(*parse_attr), GFP_KERNEL);\n\tif (!attr2 || !parse_attr) {\n\t\tkvfree(parse_attr);\n\t\tkfree(attr2);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(attr2, attr, attr_sz);\n\tINIT_LIST_HEAD(&attr2->list);\n\tparse_attr->filter_dev = attr->parse_attr->filter_dev;\n\tattr2->action = 0;\n\tattr2->counter = NULL;\n\tattr2->tc_act_cookies_count = 0;\n\tattr2->flags = 0;\n\tattr2->parse_attr = parse_attr;\n\tattr2->dest_chain = 0;\n\tattr2->dest_ft = NULL;\n\tattr2->act_id_restore_rule = NULL;\n\tmemset(&attr2->ct_attr, 0, sizeof(attr2->ct_attr));\n\n\tif (ns_type == MLX5_FLOW_NAMESPACE_FDB) {\n\t\tattr2->esw_attr->out_count = 0;\n\t\tattr2->esw_attr->split_count = 0;\n\t}\n\n\tattr2->branch_true = NULL;\n\tattr2->branch_false = NULL;\n\tattr2->jumping_attr = NULL;\n\treturn attr2;\n}\n\nstruct mlx5_flow_attr *\nmlx5e_tc_get_encap_attr(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr;\n\tstruct mlx5_flow_attr *attr;\n\tint i;\n\n\tlist_for_each_entry(attr, &flow->attrs, list) {\n\t\tesw_attr = attr->esw_attr;\n\t\tfor (i = 0; i < MLX5_MAX_FLOW_FWD_VPORTS; i++) {\n\t\t\tif (esw_attr->dests[i].flags & MLX5_ESW_DEST_ENCAP)\n\t\t\t\treturn attr;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nvoid\nmlx5e_tc_unoffload_flow_post_acts(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5e_post_act *post_act = get_post_action(flow->priv);\n\tstruct mlx5_flow_attr *attr;\n\n\tlist_for_each_entry(attr, &flow->attrs, list) {\n\t\tif (list_is_last(&attr->list, &flow->attrs))\n\t\t\tbreak;\n\n\t\tmlx5e_tc_post_act_unoffload(post_act, attr->post_act_handle);\n\t}\n}\n\nstatic void\nfree_flow_post_acts(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_flow_attr *attr, *tmp;\n\n\tlist_for_each_entry_safe(attr, tmp, &flow->attrs, list) {\n\t\tif (list_is_last(&attr->list, &flow->attrs))\n\t\t\tbreak;\n\n\t\tmlx5_free_flow_attr_actions(flow, attr);\n\n\t\tlist_del(&attr->list);\n\t\tkvfree(attr->parse_attr);\n\t\tkfree(attr);\n\t}\n}\n\nint\nmlx5e_tc_offload_flow_post_acts(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5e_post_act *post_act = get_post_action(flow->priv);\n\tstruct mlx5_flow_attr *attr;\n\tint err = 0;\n\n\tlist_for_each_entry(attr, &flow->attrs, list) {\n\t\tif (list_is_last(&attr->list, &flow->attrs))\n\t\t\tbreak;\n\n\t\terr = mlx5e_tc_post_act_offload(post_act, attr->post_act_handle);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int\nalloc_flow_post_acts(struct mlx5e_tc_flow *flow, struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_post_act *post_act = get_post_action(flow->priv);\n\tstruct mlx5_flow_attr *attr, *next_attr = NULL;\n\tstruct mlx5e_post_act_handle *handle;\n\tint err;\n\n\t \n\tlist_for_each_entry(attr, &flow->attrs, list) {\n\t\tif (!next_attr) {\n\t\t\t \n\t\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\t}\n\n\t\tif (next_attr && !(attr->flags & MLX5_ATTR_FLAG_TERMINATING)) {\n\t\t\terr = mlx5e_tc_act_set_next_post_act(flow, attr, next_attr);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tif (list_is_last(&attr->list, &flow->attrs))\n\t\t\tbreak;\n\n\t\terr = actions_prepare_mod_hdr_actions(flow->priv, flow, attr, extack);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\terr = post_process_attr(flow, attr, extack);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\thandle = mlx5e_tc_post_act_add(post_act, attr);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tattr->post_act_handle = handle;\n\n\t\tif (attr->jumping_attr) {\n\t\t\terr = mlx5e_tc_act_set_next_post_act(flow, attr->jumping_attr, attr);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\n\t\tnext_attr = attr;\n\t}\n\n\tif (flow_flag_test(flow, SLOW))\n\t\tgoto out;\n\n\terr = mlx5e_tc_offload_flow_post_acts(flow);\n\tif (err)\n\t\tgoto out_free;\n\nout:\n\treturn 0;\n\nout_free:\n\tfree_flow_post_acts(flow);\n\treturn err;\n}\n\nstatic int\nset_branch_dest_ft(struct mlx5e_priv *priv, struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_post_act *post_act = get_post_action(priv);\n\n\tif (IS_ERR(post_act))\n\t\treturn PTR_ERR(post_act);\n\n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tattr->dest_ft = mlx5e_tc_post_act_get_ft(post_act);\n\n\treturn 0;\n}\n\nstatic int\nalloc_branch_attr(struct mlx5e_tc_flow *flow,\n\t\t  struct mlx5e_tc_act_branch_ctrl *cond,\n\t\t  struct mlx5_flow_attr **cond_attr,\n\t\t  u32 *jump_count,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_flow_attr *attr;\n\tint err = 0;\n\n\t*cond_attr = mlx5e_clone_flow_attr_for_post_act(flow->attr,\n\t\t\t\t\t\t\tmlx5e_get_flow_namespace(flow));\n\tif (!(*cond_attr))\n\t\treturn -ENOMEM;\n\n\tattr = *cond_attr;\n\n\tswitch (cond->act_id) {\n\tcase FLOW_ACTION_DROP:\n\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_DROP;\n\t\tbreak;\n\tcase FLOW_ACTION_ACCEPT:\n\tcase FLOW_ACTION_PIPE:\n\t\terr = set_branch_dest_ft(flow->priv, attr);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tbreak;\n\tcase FLOW_ACTION_JUMP:\n\t\tif (*jump_count) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot offload flows with nested jumps\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out_err;\n\t\t}\n\t\t*jump_count = cond->extval;\n\t\terr = set_branch_dest_ft(flow->priv, attr);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\treturn err;\nout_err:\n\tkfree(*cond_attr);\n\t*cond_attr = NULL;\n\treturn err;\n}\n\nstatic void\ndec_jump_count(struct flow_action_entry *act, struct mlx5e_tc_act *tc_act,\n\t       struct mlx5_flow_attr *attr, struct mlx5e_priv *priv,\n\t       struct mlx5e_tc_jump_state *jump_state)\n{\n\tif (!jump_state->jump_count)\n\t\treturn;\n\n\t \n\tif (act->id == jump_state->last_id && act->hw_index == jump_state->last_index)\n\t\treturn;\n\n\tjump_state->last_id = act->id;\n\tjump_state->last_index = act->hw_index;\n\n\t \n\tif (--jump_state->jump_count > 1)\n\t\treturn;\n\n\tif (jump_state->jump_count == 1) {  \n\n\t\t \n\t\tjump_state->jump_target = true;\n\n\t\tif (tc_act->is_terminating_action) {  \n\t\t\tattr->flags |= MLX5_ATTR_FLAG_TERMINATING;\n\t\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\t} else {  \n\t\t\tstruct mlx5e_post_act *post_act;\n\n\t\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t\t\tpost_act = get_post_action(priv);\n\t\t\tattr->dest_ft = mlx5e_tc_post_act_get_ft(post_act);\n\t\t}\n\t} else if (jump_state->jump_count == 0) {  \n\t\t \n\t\tattr->jumping_attr = jump_state->jumping_attr;\n\t}\n}\n\nstatic int\nparse_branch_ctrl(struct flow_action_entry *act, struct mlx5e_tc_act *tc_act,\n\t\t  struct mlx5e_tc_flow *flow, struct mlx5_flow_attr *attr,\n\t\t  struct mlx5e_tc_jump_state *jump_state,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_act_branch_ctrl cond_true, cond_false;\n\tu32 jump_count = jump_state->jump_count;\n\tint err;\n\n\tif (!tc_act->get_branch_ctrl)\n\t\treturn 0;\n\n\ttc_act->get_branch_ctrl(act, &cond_true, &cond_false);\n\n\terr = alloc_branch_attr(flow, &cond_true,\n\t\t\t\t&attr->branch_true, &jump_count, extack);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (jump_count)\n\t\tjump_state->jumping_attr = attr->branch_true;\n\n\terr = alloc_branch_attr(flow, &cond_false,\n\t\t\t\t&attr->branch_false, &jump_count, extack);\n\tif (err)\n\t\tgoto err_branch_false;\n\n\tif (jump_count && !jump_state->jumping_attr)\n\t\tjump_state->jumping_attr = attr->branch_false;\n\n\tjump_state->jump_count = jump_count;\n\n\t \n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\tflow_flag_set(flow, USE_ACT_STATS);\n\n\treturn 0;\n\nerr_branch_false:\n\tfree_branch_attr(flow, attr->branch_true);\nout_err:\n\treturn err;\n}\n\nstatic int\nparse_tc_actions(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t struct flow_action *flow_action)\n{\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct mlx5e_tc_flow *flow = parse_state->flow;\n\tstruct mlx5e_tc_jump_state jump_state = {};\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5e_priv *priv = flow->priv;\n\tstruct mlx5_flow_attr *prev_attr;\n\tstruct flow_action_entry *act;\n\tstruct mlx5e_tc_act *tc_act;\n\tint err, i, i_split = 0;\n\tbool is_missable;\n\n\tns_type = mlx5e_get_flow_namespace(flow);\n\tlist_add(&attr->list, &flow->attrs);\n\n\tflow_action_for_each(i, act, flow_action) {\n\t\tjump_state.jump_target = false;\n\t\tis_missable = false;\n\t\tprev_attr = attr;\n\n\t\ttc_act = mlx5e_tc_act_get(act->id, ns_type);\n\t\tif (!tc_act) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Not implemented offload action\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out_free_post_acts;\n\t\t}\n\n\t\tif (tc_act->can_offload && !tc_act->can_offload(parse_state, act, i, attr)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out_free_post_acts;\n\t\t}\n\n\t\terr = tc_act->parse_action(parse_state, act, priv, attr);\n\t\tif (err)\n\t\t\tgoto out_free_post_acts;\n\n\t\tdec_jump_count(act, tc_act, attr, priv, &jump_state);\n\n\t\terr = parse_branch_ctrl(act, tc_act, flow, attr, &jump_state, extack);\n\t\tif (err)\n\t\t\tgoto out_free_post_acts;\n\n\t\tparse_state->actions |= attr->action;\n\n\t\t \n\t\tif (jump_state.jump_target ||\n\t\t    (tc_act->is_multi_table_act &&\n\t\t    tc_act->is_multi_table_act(priv, act, attr) &&\n\t\t    i < flow_action->num_entries - 1)) {\n\t\t\tis_missable = tc_act->is_missable ? tc_act->is_missable(act) : false;\n\n\t\t\terr = mlx5e_tc_act_post_parse(parse_state, flow_action, i_split, i, attr,\n\t\t\t\t\t\t      ns_type);\n\t\t\tif (err)\n\t\t\t\tgoto out_free_post_acts;\n\n\t\t\tattr = mlx5e_clone_flow_attr_for_post_act(flow->attr, ns_type);\n\t\t\tif (!attr) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_free_post_acts;\n\t\t\t}\n\n\t\t\ti_split = i + 1;\n\t\t\tparse_state->if_count = 0;\n\t\t\tlist_add(&attr->list, &flow->attrs);\n\t\t}\n\n\t\tif (is_missable) {\n\t\t\t \n\t\t\tprev_attr->action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\t\tflow_flag_set(flow, USE_ACT_STATS);\n\n\t\t\tattr->tc_act_cookies[attr->tc_act_cookies_count++] = act->cookie;\n\t\t} else if (!tc_act->stats_action) {\n\t\t\tprev_attr->tc_act_cookies[prev_attr->tc_act_cookies_count++] = act->cookie;\n\t\t}\n\t}\n\n\terr = mlx5e_tc_act_post_parse(parse_state, flow_action, i_split, i, attr, ns_type);\n\tif (err)\n\t\tgoto out_free_post_acts;\n\n\terr = alloc_flow_post_acts(flow, extack);\n\tif (err)\n\t\tgoto out_free_post_acts;\n\n\treturn 0;\n\nout_free_post_acts:\n\tfree_flow_post_acts(flow);\n\n\treturn err;\n}\n\nstatic int\nflow_action_supported(struct flow_action *flow_action,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tif (!flow_action_has_entries(flow_action)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Flow action doesn't have any entries\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!flow_action_hw_stats_check(flow_action, extack,\n\t\t\t\t\tFLOW_ACTION_HW_STATS_DELAYED_BIT)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Flow action HW stats type is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nparse_tc_nic_actions(struct mlx5e_priv *priv,\n\t\t     struct flow_action *flow_action,\n\t\t     struct mlx5e_tc_flow *flow,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_act_parse_state *parse_state;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\tint err;\n\n\terr = flow_action_supported(flow_action, extack);\n\tif (err)\n\t\treturn err;\n\n\tattr->nic_attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;\n\tparse_attr = attr->parse_attr;\n\tparse_state = &parse_attr->parse_state;\n\tmlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);\n\tparse_state->ct_priv = get_ct_priv(priv);\n\n\terr = parse_tc_actions(parse_state, flow_action);\n\tif (err)\n\t\treturn err;\n\n\terr = actions_prepare_mod_hdr_actions(priv, flow, attr, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_attr_actions(attr->action, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!actions_match_supported(priv, flow_action, parse_state->actions,\n\t\t\t\t     parse_attr, flow, extack))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic bool is_merged_eswitch_vfs(struct mlx5e_priv *priv,\n\t\t\t\t  struct net_device *peer_netdev)\n{\n\tstruct mlx5e_priv *peer_priv;\n\n\tpeer_priv = netdev_priv(peer_netdev);\n\n\treturn (MLX5_CAP_ESW(priv->mdev, merged_eswitch) &&\n\t\tmlx5e_eswitch_vf_rep(priv->netdev) &&\n\t\tmlx5e_eswitch_vf_rep(peer_netdev) &&\n\t\tmlx5e_same_hw_devs(priv, peer_priv));\n}\n\nstatic bool same_hw_reps(struct mlx5e_priv *priv,\n\t\t\t struct net_device *peer_netdev)\n{\n\tstruct mlx5e_priv *peer_priv;\n\n\tpeer_priv = netdev_priv(peer_netdev);\n\n\treturn mlx5e_eswitch_rep(priv->netdev) &&\n\t       mlx5e_eswitch_rep(peer_netdev) &&\n\t       mlx5e_same_hw_devs(priv, peer_priv);\n}\n\nstatic bool is_lag_dev(struct mlx5e_priv *priv,\n\t\t       struct net_device *peer_netdev)\n{\n\treturn ((mlx5_lag_is_sriov(priv->mdev) ||\n\t\t mlx5_lag_is_multipath(priv->mdev)) &&\n\t\t same_hw_reps(priv, peer_netdev));\n}\n\nstatic bool is_multiport_eligible(struct mlx5e_priv *priv, struct net_device *out_dev)\n{\n\treturn same_hw_reps(priv, out_dev) && mlx5_lag_is_mpesw(priv->mdev);\n}\n\nbool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,\n\t\t\t\t    struct net_device *out_dev)\n{\n\tif (is_merged_eswitch_vfs(priv, out_dev))\n\t\treturn true;\n\n\tif (is_multiport_eligible(priv, out_dev))\n\t\treturn true;\n\n\tif (is_lag_dev(priv, out_dev))\n\t\treturn true;\n\n\treturn mlx5e_eswitch_rep(out_dev) &&\n\t       same_port_devs(priv, netdev_priv(out_dev));\n}\n\nint mlx5e_set_fwd_to_int_port_actions(struct mlx5e_priv *priv,\n\t\t\t\t      struct mlx5_flow_attr *attr,\n\t\t\t\t      int ifindex,\n\t\t\t\t      enum mlx5e_tc_int_port_type type,\n\t\t\t\t      u32 *action,\n\t\t\t\t      int out_index)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct mlx5e_tc_int_port_priv *int_port_priv;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5e_tc_int_port *dest_int_port;\n\tint err;\n\n\tparse_attr = attr->parse_attr;\n\tint_port_priv = mlx5e_get_int_port_priv(priv);\n\n\tdest_int_port = mlx5e_tc_int_port_get(int_port_priv, ifindex, type);\n\tif (IS_ERR(dest_int_port))\n\t\treturn PTR_ERR(dest_int_port);\n\n\terr = mlx5e_tc_match_to_reg_set(priv->mdev, &parse_attr->mod_hdr_acts,\n\t\t\t\t\tMLX5_FLOW_NAMESPACE_FDB, VPORT_TO_REG,\n\t\t\t\t\tmlx5e_tc_int_port_get_metadata(dest_int_port));\n\tif (err) {\n\t\tmlx5e_tc_int_port_put(int_port_priv, dest_int_port);\n\t\treturn err;\n\t}\n\n\t*action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\n\tesw_attr->dest_int_port = dest_int_port;\n\tesw_attr->dests[out_index].flags |= MLX5_ESW_DEST_CHAIN_WITH_SRC_PORT_CHANGE;\n\tesw_attr->split_count = out_index;\n\n\t \n\tattr->dest_chain = 0;\n\n\treturn 0;\n}\n\nstatic int\nparse_tc_fdb_actions(struct mlx5e_priv *priv,\n\t\t     struct flow_action *flow_action,\n\t\t     struct mlx5e_tc_flow *flow,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_act_parse_state *parse_state;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\tstruct mlx5_esw_flow_attr *esw_attr;\n\tstruct net_device *filter_dev;\n\tint err;\n\n\terr = flow_action_supported(flow_action, extack);\n\tif (err)\n\t\treturn err;\n\n\tesw_attr = attr->esw_attr;\n\tparse_attr = attr->parse_attr;\n\tfilter_dev = parse_attr->filter_dev;\n\tparse_state = &parse_attr->parse_state;\n\tmlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);\n\tparse_state->ct_priv = get_ct_priv(priv);\n\n\terr = parse_tc_actions(parse_state, flow_action);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((netif_is_ovs_master(filter_dev) || esw_attr->dest_int_port) &&\n\t    esw_attr->out_count > 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Rules with internal port can have only one destination\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif ((mlx5e_get_tc_tun(filter_dev) || netif_is_ovs_master(filter_dev)) &&\n\t    esw_attr->dest_int_port) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Forwarding from tunnel/internal port to internal port is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = actions_prepare_mod_hdr_actions(priv, flow, attr, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!actions_match_supported(priv, flow_action, parse_state->actions,\n\t\t\t\t     parse_attr, flow, extack))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic void get_flags(int flags, unsigned long *flow_flags)\n{\n\tunsigned long __flow_flags = 0;\n\n\tif (flags & MLX5_TC_FLAG(INGRESS))\n\t\t__flow_flags |= BIT(MLX5E_TC_FLOW_FLAG_INGRESS);\n\tif (flags & MLX5_TC_FLAG(EGRESS))\n\t\t__flow_flags |= BIT(MLX5E_TC_FLOW_FLAG_EGRESS);\n\n\tif (flags & MLX5_TC_FLAG(ESW_OFFLOAD))\n\t\t__flow_flags |= BIT(MLX5E_TC_FLOW_FLAG_ESWITCH);\n\tif (flags & MLX5_TC_FLAG(NIC_OFFLOAD))\n\t\t__flow_flags |= BIT(MLX5E_TC_FLOW_FLAG_NIC);\n\tif (flags & MLX5_TC_FLAG(FT_OFFLOAD))\n\t\t__flow_flags |= BIT(MLX5E_TC_FLOW_FLAG_FT);\n\n\t*flow_flags = __flow_flags;\n}\n\nstatic const struct rhashtable_params tc_ht_params = {\n\t.head_offset = offsetof(struct mlx5e_tc_flow, node),\n\t.key_offset = offsetof(struct mlx5e_tc_flow, cookie),\n\t.key_len = sizeof(((struct mlx5e_tc_flow *)0)->cookie),\n\t.automatic_shrinking = true,\n};\n\nstatic struct rhashtable *get_tc_ht(struct mlx5e_priv *priv,\n\t\t\t\t    unsigned long flags)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5e_rep_priv *rpriv;\n\n\tif (flags & MLX5_TC_FLAG(ESW_OFFLOAD)) {\n\t\trpriv = priv->ppriv;\n\t\treturn &rpriv->tc_ht;\n\t} else  \n\t\treturn &tc->ht;\n}\n\nstatic bool is_peer_flow_needed(struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = flow->attr->esw_attr;\n\tstruct mlx5_flow_attr *attr = flow->attr;\n\tbool is_rep_ingress = esw_attr->in_rep->vport != MLX5_VPORT_UPLINK &&\n\t\tflow_flag_test(flow, INGRESS);\n\tbool act_is_encap = !!(attr->action &\n\t\t\t       MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT);\n\tbool esw_paired = mlx5_devcom_comp_is_ready(esw_attr->in_mdev->priv.eswitch->devcom);\n\n\tif (!esw_paired)\n\t\treturn false;\n\n\tif ((mlx5_lag_is_sriov(esw_attr->in_mdev) ||\n\t     mlx5_lag_is_multipath(esw_attr->in_mdev)) &&\n\t    (is_rep_ingress || act_is_encap))\n\t\treturn true;\n\n\tif (mlx5_lag_is_mpesw(esw_attr->in_mdev))\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct mlx5_flow_attr *\nmlx5_alloc_flow_attr(enum mlx5_flow_namespace_type type)\n{\n\tu32 ex_attr_size = (type == MLX5_FLOW_NAMESPACE_FDB)  ?\n\t\t\t\tsizeof(struct mlx5_esw_flow_attr) :\n\t\t\t\tsizeof(struct mlx5_nic_flow_attr);\n\tstruct mlx5_flow_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr) + ex_attr_size, GFP_KERNEL);\n\tif (!attr)\n\t\treturn attr;\n\n\tINIT_LIST_HEAD(&attr->list);\n\treturn attr;\n}\n\nstatic void\nmlx5_free_flow_attr_actions(struct mlx5e_tc_flow *flow, struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_core_dev *counter_dev = get_flow_counter_dev(flow);\n\tstruct mlx5_esw_flow_attr *esw_attr;\n\n\tif (!attr)\n\t\treturn;\n\n\tif (attr->post_act_handle)\n\t\tmlx5e_tc_post_act_del(get_post_action(flow->priv), attr->post_act_handle);\n\n\tmlx5e_tc_tun_encap_dests_unset(flow->priv, flow, attr);\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_COUNT)\n\t\tmlx5_fc_destroy(counter_dev, attr->counter);\n\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {\n\t\tmlx5e_mod_hdr_dealloc(&attr->parse_attr->mod_hdr_acts);\n\t\tmlx5e_tc_detach_mod_hdr(flow->priv, flow, attr);\n\t}\n\n\tif (mlx5e_is_eswitch_flow(flow)) {\n\t\tesw_attr = attr->esw_attr;\n\n\t\tif (esw_attr->int_port)\n\t\t\tmlx5e_tc_int_port_put(mlx5e_get_int_port_priv(flow->priv),\n\t\t\t\t\t      esw_attr->int_port);\n\n\t\tif (esw_attr->dest_int_port)\n\t\t\tmlx5e_tc_int_port_put(mlx5e_get_int_port_priv(flow->priv),\n\t\t\t\t\t      esw_attr->dest_int_port);\n\t}\n\n\tmlx5_tc_ct_delete_flow(get_ct_priv(flow->priv), attr);\n\n\tfree_branch_attr(flow, attr->branch_true);\n\tfree_branch_attr(flow, attr->branch_false);\n}\n\nstatic int\nmlx5e_alloc_flow(struct mlx5e_priv *priv, int attr_size,\n\t\t struct flow_cls_offload *f, unsigned long flow_flags,\n\t\t struct mlx5e_tc_flow_parse_attr **__parse_attr,\n\t\t struct mlx5e_tc_flow **__flow)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5_flow_attr *attr;\n\tstruct mlx5e_tc_flow *flow;\n\tint err = -ENOMEM;\n\tint out_index;\n\n\tflow = kzalloc(sizeof(*flow), GFP_KERNEL);\n\tparse_attr = kvzalloc(sizeof(*parse_attr), GFP_KERNEL);\n\tif (!parse_attr || !flow)\n\t\tgoto err_free;\n\n\tflow->flags = flow_flags;\n\tflow->cookie = f->cookie;\n\tflow->priv = priv;\n\n\tattr = mlx5_alloc_flow_attr(mlx5e_get_flow_namespace(flow));\n\tif (!attr)\n\t\tgoto err_free;\n\n\tflow->attr = attr;\n\n\tfor (out_index = 0; out_index < MLX5_MAX_FLOW_FWD_VPORTS; out_index++)\n\t\tINIT_LIST_HEAD(&flow->encaps[out_index].list);\n\tINIT_LIST_HEAD(&flow->hairpin);\n\tINIT_LIST_HEAD(&flow->l3_to_l2_reformat);\n\tINIT_LIST_HEAD(&flow->attrs);\n\tINIT_LIST_HEAD(&flow->peer_flows);\n\trefcount_set(&flow->refcnt, 1);\n\tinit_completion(&flow->init_done);\n\tinit_completion(&flow->del_hw_done);\n\n\t*__flow = flow;\n\t*__parse_attr = parse_attr;\n\n\treturn 0;\n\nerr_free:\n\tkfree(flow);\n\tkvfree(parse_attr);\n\treturn err;\n}\n\nstatic void\nmlx5e_flow_attr_init(struct mlx5_flow_attr *attr,\n\t\t     struct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t     struct flow_cls_offload *f)\n{\n\tattr->parse_attr = parse_attr;\n\tattr->chain = f->common.chain_index;\n\tattr->prio = f->common.prio;\n}\n\nstatic void\nmlx5e_flow_esw_attr_init(struct mlx5_flow_attr *attr,\n\t\t\t struct mlx5e_priv *priv,\n\t\t\t struct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t\t struct flow_cls_offload *f,\n\t\t\t struct mlx5_eswitch_rep *in_rep,\n\t\t\t struct mlx5_core_dev *in_mdev)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\n\tmlx5e_flow_attr_init(attr, parse_attr, f);\n\n\tesw_attr->in_rep = in_rep;\n\tesw_attr->in_mdev = in_mdev;\n\n\tif (MLX5_CAP_ESW(esw->dev, counter_eswitch_affinity) ==\n\t    MLX5_COUNTER_SOURCE_ESWITCH)\n\t\tesw_attr->counter_dev = in_mdev;\n\telse\n\t\tesw_attr->counter_dev = priv->mdev;\n}\n\nstatic struct mlx5e_tc_flow *\n__mlx5e_add_fdb_flow(struct mlx5e_priv *priv,\n\t\t     struct flow_cls_offload *f,\n\t\t     unsigned long flow_flags,\n\t\t     struct net_device *filter_dev,\n\t\t     struct mlx5_eswitch_rep *in_rep,\n\t\t     struct mlx5_core_dev *in_mdev)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5e_tc_flow *flow;\n\tint attr_size, err;\n\n\tflow_flags |= BIT(MLX5E_TC_FLOW_FLAG_ESWITCH);\n\tattr_size  = sizeof(struct mlx5_esw_flow_attr);\n\terr = mlx5e_alloc_flow(priv, attr_size, f, flow_flags,\n\t\t\t       &parse_attr, &flow);\n\tif (err)\n\t\tgoto out;\n\n\tparse_attr->filter_dev = filter_dev;\n\tmlx5e_flow_esw_attr_init(flow->attr,\n\t\t\t\t priv, parse_attr,\n\t\t\t\t f, in_rep, in_mdev);\n\n\terr = parse_cls_flower(flow->priv, flow, &parse_attr->spec,\n\t\t\t       f, filter_dev);\n\tif (err)\n\t\tgoto err_free;\n\n\t \n\terr = mlx5_tc_ct_match_add(get_ct_priv(priv), &parse_attr->spec, f,\n\t\t\t\t   &flow->attr->ct_attr, extack);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = parse_tc_fdb_actions(priv, &rule->action, flow, extack);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = mlx5e_tc_add_fdb_flow(priv, flow, extack);\n\tcomplete_all(&flow->init_done);\n\tif (err) {\n\t\tif (!(err == -ENETUNREACH && mlx5_lag_is_multipath(in_mdev)))\n\t\t\tgoto err_free;\n\n\t\tadd_unready_flow(flow);\n\t}\n\n\treturn flow;\n\nerr_free:\n\tmlx5e_flow_put(priv, flow);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic int mlx5e_tc_add_fdb_peer_flow(struct flow_cls_offload *f,\n\t\t\t\t      struct mlx5e_tc_flow *flow,\n\t\t\t\t      unsigned long flow_flags,\n\t\t\t\t      struct mlx5_eswitch *peer_esw)\n{\n\tstruct mlx5e_priv *priv = flow->priv, *peer_priv;\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_esw_flow_attr *attr = flow->attr->esw_attr;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tint i = mlx5_get_dev_index(peer_esw->dev);\n\tstruct mlx5e_rep_priv *peer_urpriv;\n\tstruct mlx5e_tc_flow *peer_flow;\n\tstruct mlx5_core_dev *in_mdev;\n\tint err = 0;\n\n\tpeer_urpriv = mlx5_eswitch_get_uplink_priv(peer_esw, REP_ETH);\n\tpeer_priv = netdev_priv(peer_urpriv->netdev);\n\n\t \n\tif (attr->in_rep->vport == MLX5_VPORT_UPLINK && !mlx5_lag_is_mpesw(priv->mdev))\n\t\tin_mdev = peer_priv->mdev;\n\telse\n\t\tin_mdev = priv->mdev;\n\n\tparse_attr = flow->attr->parse_attr;\n\tpeer_flow = __mlx5e_add_fdb_flow(peer_priv, f, flow_flags,\n\t\t\t\t\t parse_attr->filter_dev,\n\t\t\t\t\t attr->in_rep, in_mdev);\n\tif (IS_ERR(peer_flow)) {\n\t\terr = PTR_ERR(peer_flow);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&peer_flow->peer_flows, &flow->peer_flows);\n\tflow_flag_set(flow, DUP);\n\tmutex_lock(&esw->offloads.peer_mutex);\n\tlist_add_tail(&flow->peer[i], &esw->offloads.peer_flows[i]);\n\tmutex_unlock(&esw->offloads.peer_mutex);\n\nout:\n\treturn err;\n}\n\nstatic int\nmlx5e_add_fdb_flow(struct mlx5e_priv *priv,\n\t\t   struct flow_cls_offload *f,\n\t\t   unsigned long flow_flags,\n\t\t   struct net_device *filter_dev,\n\t\t   struct mlx5e_tc_flow **__flow)\n{\n\tstruct mlx5_devcom_comp_dev *devcom = priv->mdev->priv.eswitch->devcom, *pos;\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5_eswitch_rep *in_rep = rpriv->rep;\n\tstruct mlx5_core_dev *in_mdev = priv->mdev;\n\tstruct mlx5_eswitch *peer_esw;\n\tstruct mlx5e_tc_flow *flow;\n\tint err;\n\n\tflow = __mlx5e_add_fdb_flow(priv, f, flow_flags, filter_dev, in_rep,\n\t\t\t\t    in_mdev);\n\tif (IS_ERR(flow))\n\t\treturn PTR_ERR(flow);\n\n\tif (!is_peer_flow_needed(flow)) {\n\t\t*__flow = flow;\n\t\treturn 0;\n\t}\n\n\tif (!mlx5_devcom_for_each_peer_begin(devcom)) {\n\t\terr = -ENODEV;\n\t\tgoto clean_flow;\n\t}\n\n\tmlx5_devcom_for_each_peer_entry(devcom, peer_esw, pos) {\n\t\terr = mlx5e_tc_add_fdb_peer_flow(f, flow, flow_flags, peer_esw);\n\t\tif (err)\n\t\t\tgoto peer_clean;\n\t}\n\n\tmlx5_devcom_for_each_peer_end(devcom);\n\n\t*__flow = flow;\n\treturn 0;\n\npeer_clean:\n\tmlx5e_tc_del_fdb_peers_flow(flow);\n\tmlx5_devcom_for_each_peer_end(devcom);\nclean_flow:\n\tmlx5e_tc_del_fdb_flow(priv, flow);\n\treturn err;\n}\n\nstatic int\nmlx5e_add_nic_flow(struct mlx5e_priv *priv,\n\t\t   struct flow_cls_offload *f,\n\t\t   unsigned long flow_flags,\n\t\t   struct net_device *filter_dev,\n\t\t   struct mlx5e_tc_flow **__flow)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct mlx5e_tc_flow *flow;\n\tint attr_size, err;\n\n\tif (!MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, ignore_flow_level)) {\n\t\tif (!tc_cls_can_offload_and_chain0(priv->netdev, &f->common))\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (!tc_can_offload_extack(priv->netdev, f->common.extack)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tflow_flags |= BIT(MLX5E_TC_FLOW_FLAG_NIC);\n\tattr_size  = sizeof(struct mlx5_nic_flow_attr);\n\terr = mlx5e_alloc_flow(priv, attr_size, f, flow_flags,\n\t\t\t       &parse_attr, &flow);\n\tif (err)\n\t\tgoto out;\n\n\tparse_attr->filter_dev = filter_dev;\n\tmlx5e_flow_attr_init(flow->attr, parse_attr, f);\n\n\terr = parse_cls_flower(flow->priv, flow, &parse_attr->spec,\n\t\t\t       f, filter_dev);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = mlx5_tc_ct_match_add(get_ct_priv(priv), &parse_attr->spec, f,\n\t\t\t\t   &flow->attr->ct_attr, extack);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = parse_tc_nic_actions(priv, &rule->action, flow, extack);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = mlx5e_tc_add_nic_flow(priv, flow, extack);\n\tif (err)\n\t\tgoto err_free;\n\n\tflow_flag_set(flow, OFFLOADED);\n\t*__flow = flow;\n\n\treturn 0;\n\nerr_free:\n\tflow_flag_set(flow, FAILED);\n\tmlx5e_mod_hdr_dealloc(&parse_attr->mod_hdr_acts);\n\tmlx5e_flow_put(priv, flow);\nout:\n\treturn err;\n}\n\nstatic int\nmlx5e_tc_add_flow(struct mlx5e_priv *priv,\n\t\t  struct flow_cls_offload *f,\n\t\t  unsigned long flags,\n\t\t  struct net_device *filter_dev,\n\t\t  struct mlx5e_tc_flow **flow)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tunsigned long flow_flags;\n\tint err;\n\n\tget_flags(flags, &flow_flags);\n\n\tif (!tc_can_offload_extack(priv->netdev, f->common.extack))\n\t\treturn -EOPNOTSUPP;\n\n\tif (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)\n\t\terr = mlx5e_add_fdb_flow(priv, f, flow_flags,\n\t\t\t\t\t filter_dev, flow);\n\telse\n\t\terr = mlx5e_add_nic_flow(priv, f, flow_flags,\n\t\t\t\t\t filter_dev, flow);\n\n\treturn err;\n}\n\nstatic bool is_flow_rule_duplicate_allowed(struct net_device *dev,\n\t\t\t\t\t   struct mlx5e_rep_priv *rpriv)\n{\n\t \n\treturn netif_is_lag_port(dev) && rpriv && rpriv->rep->vport != MLX5_VPORT_UPLINK;\n}\n\n \nstatic bool is_tc_ipsec_order_check_needed(struct net_device *filter, struct mlx5e_priv *priv)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_EN_IPSEC))\n\t\treturn false;\n\n\tif (filter != priv->netdev)\n\t\treturn false;\n\n\tif (mlx5e_eswitch_vf_rep(priv->netdev))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mlx5e_tc_block_ipsec_offload(struct net_device *filter, struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tif (!is_tc_ipsec_order_check_needed(filter, priv))\n\t\treturn 0;\n\n\tif (mdev->num_block_tc)\n\t\treturn -EBUSY;\n\n\tmdev->num_block_ipsec++;\n\n\treturn 0;\n}\n\nstatic void mlx5e_tc_unblock_ipsec_offload(struct net_device *filter, struct mlx5e_priv *priv)\n{\n\tif (!is_tc_ipsec_order_check_needed(filter, priv))\n\t\treturn;\n\n\tpriv->mdev->num_block_ipsec--;\n}\n\nint mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,\n\t\t\t   struct flow_cls_offload *f, unsigned long flags)\n{\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct rhashtable *tc_ht = get_tc_ht(priv, flags);\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5e_tc_flow *flow;\n\tint err = 0;\n\n\tif (!mlx5_esw_hold(priv->mdev))\n\t\treturn -EBUSY;\n\n\terr = mlx5e_tc_block_ipsec_offload(dev, priv);\n\tif (err)\n\t\tgoto esw_release;\n\n\tmlx5_esw_get(priv->mdev);\n\n\trcu_read_lock();\n\tflow = rhashtable_lookup(tc_ht, &f->cookie, tc_ht_params);\n\tif (flow) {\n\t\t \n\t\tif (is_flow_rule_duplicate_allowed(dev, rpriv) && flow->orig_dev != dev)\n\t\t\tgoto rcu_unlock;\n\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"flow cookie already exists, ignoring\");\n\t\tnetdev_warn_once(priv->netdev,\n\t\t\t\t \"flow cookie %lx already exists, ignoring\\n\",\n\t\t\t\t f->cookie);\n\t\terr = -EEXIST;\n\t\tgoto rcu_unlock;\n\t}\nrcu_unlock:\n\trcu_read_unlock();\n\tif (flow)\n\t\tgoto out;\n\n\ttrace_mlx5e_configure_flower(f);\n\terr = mlx5e_tc_add_flow(priv, f, flags, dev, &flow);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (is_flow_rule_duplicate_allowed(dev, rpriv))\n\t\tflow->orig_dev = dev;\n\n\terr = rhashtable_lookup_insert_fast(tc_ht, &flow->node, tc_ht_params);\n\tif (err)\n\t\tgoto err_free;\n\n\tmlx5_esw_release(priv->mdev);\n\treturn 0;\n\nerr_free:\n\tmlx5e_flow_put(priv, flow);\nout:\n\tmlx5e_tc_unblock_ipsec_offload(dev, priv);\n\tmlx5_esw_put(priv->mdev);\nesw_release:\n\tmlx5_esw_release(priv->mdev);\n\treturn err;\n}\n\nstatic bool same_flow_direction(struct mlx5e_tc_flow *flow, int flags)\n{\n\tbool dir_ingress = !!(flags & MLX5_TC_FLAG(INGRESS));\n\tbool dir_egress = !!(flags & MLX5_TC_FLAG(EGRESS));\n\n\treturn flow_flag_test(flow, INGRESS) == dir_ingress &&\n\t\tflow_flag_test(flow, EGRESS) == dir_egress;\n}\n\nint mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,\n\t\t\tstruct flow_cls_offload *f, unsigned long flags)\n{\n\tstruct rhashtable *tc_ht = get_tc_ht(priv, flags);\n\tstruct mlx5e_tc_flow *flow;\n\tint err;\n\n\trcu_read_lock();\n\tflow = rhashtable_lookup(tc_ht, &f->cookie, tc_ht_params);\n\tif (!flow || !same_flow_direction(flow, flags)) {\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t \n\tif (flow_flag_test_and_set(flow, DELETED)) {\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\trhashtable_remove_fast(tc_ht, &flow->node, tc_ht_params);\n\trcu_read_unlock();\n\n\ttrace_mlx5e_delete_flower(f);\n\tmlx5e_flow_put(priv, flow);\n\n\tmlx5e_tc_unblock_ipsec_offload(dev, priv);\n\tmlx5_esw_put(priv->mdev);\n\treturn 0;\n\nerrout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nint mlx5e_tc_fill_action_stats(struct mlx5e_priv *priv,\n\t\t\t       struct flow_offload_action *fl_act)\n{\n\treturn mlx5e_tc_act_stats_fill_stats(get_act_stats_handle(priv), fl_act);\n}\n\nint mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,\n\t\t       struct flow_cls_offload *f, unsigned long flags)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct rhashtable *tc_ht = get_tc_ht(priv, flags);\n\tstruct mlx5e_tc_flow *flow;\n\tstruct mlx5_fc *counter;\n\tu64 lastuse = 0;\n\tu64 packets = 0;\n\tu64 bytes = 0;\n\tint err = 0;\n\n\trcu_read_lock();\n\tflow = mlx5e_flow_get(rhashtable_lookup(tc_ht, &f->cookie,\n\t\t\t\t\t\ttc_ht_params));\n\trcu_read_unlock();\n\tif (IS_ERR(flow))\n\t\treturn PTR_ERR(flow);\n\n\tif (!same_flow_direction(flow, flags)) {\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (mlx5e_is_offloaded_flow(flow)) {\n\t\tif (flow_flag_test(flow, USE_ACT_STATS)) {\n\t\t\tf->use_act_stats = true;\n\t\t} else {\n\t\t\tcounter = mlx5e_tc_get_counter(flow);\n\t\t\tif (!counter)\n\t\t\t\tgoto errout;\n\n\t\t\tmlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);\n\t\t}\n\t}\n\n\t \n\tif (esw && !mlx5_devcom_for_each_peer_begin(esw->devcom))\n\t\tgoto out;\n\n\tif (flow_flag_test(flow, DUP)) {\n\t\tstruct mlx5e_tc_flow *peer_flow;\n\n\t\tlist_for_each_entry(peer_flow, &flow->peer_flows, peer_flows) {\n\t\t\tu64 packets2;\n\t\t\tu64 lastuse2;\n\t\t\tu64 bytes2;\n\n\t\t\tif (!flow_flag_test(peer_flow, OFFLOADED))\n\t\t\t\tcontinue;\n\t\t\tif (flow_flag_test(flow, USE_ACT_STATS)) {\n\t\t\t\tf->use_act_stats = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcounter = mlx5e_tc_get_counter(peer_flow);\n\t\t\tif (!counter)\n\t\t\t\tgoto no_peer_counter;\n\t\t\tmlx5_fc_query_cached(counter, &bytes2, &packets2,\n\t\t\t\t\t     &lastuse2);\n\n\t\t\tbytes += bytes2;\n\t\t\tpackets += packets2;\n\t\t\tlastuse = max_t(u64, lastuse, lastuse2);\n\t\t}\n\t}\n\nno_peer_counter:\n\tif (esw)\n\t\tmlx5_devcom_for_each_peer_end(esw->devcom);\nout:\n\tflow_stats_update(&f->stats, bytes, packets, 0, lastuse,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\ttrace_mlx5e_stats_flower(f);\nerrout:\n\tmlx5e_flow_put(priv, flow);\n\treturn err;\n}\n\nstatic int apply_police_params(struct mlx5e_priv *priv, u64 rate,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5_eswitch *esw;\n\tu32 rate_mbps = 0;\n\tu16 vport_num;\n\tint err;\n\n\tvport_num = rpriv->rep->vport;\n\tif (vport_num >= MLX5_VPORT_ECPF) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Ingress rate limit is supported only for Eswitch ports connected to VFs\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tesw = priv->mdev->priv.eswitch;\n\t \n\tif (rate) {\n\t\trate = (rate * BITS_PER_BYTE) + 500000;\n\t\tdo_div(rate, 1000000);\n\t\trate_mbps = max_t(u32, rate, 1);\n\t}\n\n\terr = mlx5_esw_qos_modify_vport_rate(esw, vport_num, rate_mbps);\n\tif (err)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"failed applying action to hardware\");\n\n\treturn err;\n}\n\nstatic int\ntc_matchall_police_validate(const struct flow_action *action,\n\t\t\t    const struct flow_action_entry *act,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (act->police.notexceed.act_id != FLOW_ACTION_CONTINUE) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is not continue\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id == FLOW_ACTION_ACCEPT &&\n\t    !flow_action_is_last_entry(action, act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is ok, but action is not last\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.peakrate_bytes_ps ||\n\t    act->police.avrate || act->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int scan_tc_matchall_fdb_actions(struct mlx5e_priv *priv,\n\t\t\t\t\tstruct flow_action *flow_action,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tconst struct flow_action_entry *act;\n\tint err;\n\tint i;\n\n\tif (!flow_action_has_entries(flow_action)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"matchall called with no action\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!flow_offload_has_one_action(flow_action)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"matchall policing support only a single action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!flow_action_basic_hw_stats_check(flow_action, extack)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Flow action HW stats type is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tflow_action_for_each(i, act, flow_action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_POLICE:\n\t\t\terr = tc_matchall_police_validate(flow_action, act, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = apply_police_params(priv, act->police.rate_bytes_ps, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tmlx5e_stats_copy_rep_stats(&rpriv->prev_vf_vport_stats,\n\t\t\t\t\t\t   &priv->stats.rep_stats);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"mlx5 supports only police action for matchall\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mlx5e_tc_configure_matchall(struct mlx5e_priv *priv,\n\t\t\t\tstruct tc_cls_matchall_offload *ma)\n{\n\tstruct netlink_ext_ack *extack = ma->common.extack;\n\n\tif (ma->common.prio != 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"only priority 1 is supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn scan_tc_matchall_fdb_actions(priv, &ma->rule->action, extack);\n}\n\nint mlx5e_tc_delete_matchall(struct mlx5e_priv *priv,\n\t\t\t     struct tc_cls_matchall_offload *ma)\n{\n\tstruct netlink_ext_ack *extack = ma->common.extack;\n\n\treturn apply_police_params(priv, 0, extack);\n}\n\nvoid mlx5e_tc_stats_matchall(struct mlx5e_priv *priv,\n\t\t\t     struct tc_cls_matchall_offload *ma)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct rtnl_link_stats64 cur_stats;\n\tu64 dbytes;\n\tu64 dpkts;\n\n\tmlx5e_stats_copy_rep_stats(&cur_stats, &priv->stats.rep_stats);\n\tdpkts = cur_stats.rx_packets - rpriv->prev_vf_vport_stats.rx_packets;\n\tdbytes = cur_stats.rx_bytes - rpriv->prev_vf_vport_stats.rx_bytes;\n\trpriv->prev_vf_vport_stats = cur_stats;\n\tflow_stats_update(&ma->stats, dbytes, dpkts, 0, jiffies,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n}\n\nstatic void mlx5e_tc_hairpin_update_dead_peer(struct mlx5e_priv *priv,\n\t\t\t\t\t      struct mlx5e_priv *peer_priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_core_dev *peer_mdev = peer_priv->mdev;\n\tstruct mlx5e_hairpin_entry *hpe, *tmp;\n\tLIST_HEAD(init_wait_list);\n\tu16 peer_vhca_id;\n\tint bkt;\n\n\tif (!mlx5e_same_hw_devs(priv, peer_priv))\n\t\treturn;\n\n\tpeer_vhca_id = MLX5_CAP_GEN(peer_mdev, vhca_id);\n\n\tmutex_lock(&tc->hairpin_tbl_lock);\n\thash_for_each(tc->hairpin_tbl, bkt, hpe, hairpin_hlist)\n\t\tif (refcount_inc_not_zero(&hpe->refcnt))\n\t\t\tlist_add(&hpe->dead_peer_wait_list, &init_wait_list);\n\tmutex_unlock(&tc->hairpin_tbl_lock);\n\n\tlist_for_each_entry_safe(hpe, tmp, &init_wait_list, dead_peer_wait_list) {\n\t\twait_for_completion(&hpe->res_ready);\n\t\tif (!IS_ERR_OR_NULL(hpe->hp) && hpe->peer_vhca_id == peer_vhca_id)\n\t\t\tmlx5_core_hairpin_clear_dead_peer(hpe->hp->pair);\n\n\t\tmlx5e_hairpin_put(priv, hpe);\n\t}\n}\n\nstatic int mlx5e_tc_netdev_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tstruct mlx5e_priv *peer_priv;\n\tstruct mlx5e_tc_table *tc;\n\tstruct mlx5e_priv *priv;\n\n\tif (ndev->netdev_ops != &mlx5e_netdev_ops ||\n\t    event != NETDEV_UNREGISTER ||\n\t    ndev->reg_state == NETREG_REGISTERED)\n\t\treturn NOTIFY_DONE;\n\n\ttc = container_of(this, struct mlx5e_tc_table, netdevice_nb);\n\tpriv = tc->priv;\n\tpeer_priv = netdev_priv(ndev);\n\tif (priv == peer_priv ||\n\t    !(priv->netdev->features & NETIF_F_HW_TC))\n\t\treturn NOTIFY_DONE;\n\n\tmlx5e_tc_hairpin_update_dead_peer(priv, peer_priv);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int mlx5e_tc_nic_create_miss_table(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_flow_table **ft = &tc->miss_t;\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_namespace *ns;\n\tint err = 0;\n\n\tft_attr.max_fte = 1;\n\tft_attr.autogroup.max_num_groups = 1;\n\tft_attr.level = MLX5E_TC_MISS_LEVEL;\n\tft_attr.prio = 0;\n\tns = mlx5_get_flow_namespace(priv->mdev, MLX5_FLOW_NAMESPACE_KERNEL);\n\n\t*ft = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);\n\tif (IS_ERR(*ft)) {\n\t\terr = PTR_ERR(*ft);\n\t\tnetdev_err(priv->netdev, \"failed to create tc nic miss table err=%d\\n\", err);\n\t}\n\n\treturn err;\n}\n\nstatic void mlx5e_tc_nic_destroy_miss_table(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\n\tmlx5_destroy_flow_table(tc->miss_t);\n}\n\nint mlx5e_tc_nic_init(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tstruct mlx5_core_dev *dev = priv->mdev;\n\tstruct mapping_ctx *chains_mapping;\n\tstruct mlx5_chains_attr attr = {};\n\tu64 mapping_id;\n\tint err;\n\n\tmlx5e_mod_hdr_tbl_init(&tc->mod_hdr);\n\tmutex_init(&tc->t_lock);\n\tmutex_init(&tc->hairpin_tbl_lock);\n\thash_init(tc->hairpin_tbl);\n\ttc->priv = priv;\n\n\terr = rhashtable_init(&tc->ht, &tc_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tlockdep_set_class(&tc->ht.mutex, &tc_ht_lock_key);\n\tlockdep_init_map(&tc->ht.run_work.lockdep_map, \"tc_ht_wq_key\", &tc_ht_wq_key, 0);\n\n\tmapping_id = mlx5_query_nic_system_image_guid(dev);\n\n\tchains_mapping = mapping_create_for_id(mapping_id, MAPPING_TYPE_CHAIN,\n\t\t\t\t\t       sizeof(struct mlx5_mapped_obj),\n\t\t\t\t\t       MLX5E_TC_TABLE_CHAIN_TAG_MASK, true);\n\n\tif (IS_ERR(chains_mapping)) {\n\t\terr = PTR_ERR(chains_mapping);\n\t\tgoto err_mapping;\n\t}\n\ttc->mapping = chains_mapping;\n\n\terr = mlx5e_tc_nic_create_miss_table(priv);\n\tif (err)\n\t\tgoto err_chains;\n\n\tif (MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, ignore_flow_level))\n\t\tattr.flags = MLX5_CHAINS_AND_PRIOS_SUPPORTED |\n\t\t\tMLX5_CHAINS_IGNORE_FLOW_LEVEL_SUPPORTED;\n\tattr.ns = MLX5_FLOW_NAMESPACE_KERNEL;\n\tattr.max_grp_num = MLX5E_TC_TABLE_NUM_GROUPS;\n\tattr.default_ft = tc->miss_t;\n\tattr.mapping = chains_mapping;\n\tattr.fs_base_prio = MLX5E_TC_PRIO;\n\n\ttc->chains = mlx5_chains_create(dev, &attr);\n\tif (IS_ERR(tc->chains)) {\n\t\terr = PTR_ERR(tc->chains);\n\t\tgoto err_miss;\n\t}\n\n\tmlx5_chains_print_info(tc->chains);\n\n\ttc->post_act = mlx5e_tc_post_act_init(priv, tc->chains, MLX5_FLOW_NAMESPACE_KERNEL);\n\ttc->ct = mlx5_tc_ct_init(priv, tc->chains, &tc->mod_hdr,\n\t\t\t\t MLX5_FLOW_NAMESPACE_KERNEL, tc->post_act);\n\n\ttc->netdevice_nb.notifier_call = mlx5e_tc_netdev_event;\n\terr = register_netdevice_notifier_dev_net(priv->netdev,\n\t\t\t\t\t\t  &tc->netdevice_nb,\n\t\t\t\t\t\t  &tc->netdevice_nn);\n\tif (err) {\n\t\ttc->netdevice_nb.notifier_call = NULL;\n\t\tmlx5_core_warn(priv->mdev, \"Failed to register netdev notifier\\n\");\n\t\tgoto err_reg;\n\t}\n\n\tmlx5e_tc_debugfs_init(tc, mlx5e_fs_get_debugfs_root(priv->fs));\n\n\ttc->action_stats_handle = mlx5e_tc_act_stats_create();\n\tif (IS_ERR(tc->action_stats_handle)) {\n\t\terr = PTR_ERR(tc->action_stats_handle);\n\t\tgoto err_act_stats;\n\t}\n\n\treturn 0;\n\nerr_act_stats:\n\tunregister_netdevice_notifier_dev_net(priv->netdev,\n\t\t\t\t\t      &tc->netdevice_nb,\n\t\t\t\t\t      &tc->netdevice_nn);\nerr_reg:\n\tmlx5_tc_ct_clean(tc->ct);\n\tmlx5e_tc_post_act_destroy(tc->post_act);\n\tmlx5_chains_destroy(tc->chains);\nerr_miss:\n\tmlx5e_tc_nic_destroy_miss_table(priv);\nerr_chains:\n\tmapping_destroy(chains_mapping);\nerr_mapping:\n\trhashtable_destroy(&tc->ht);\n\treturn err;\n}\n\nstatic void _mlx5e_tc_del_flow(void *ptr, void *arg)\n{\n\tstruct mlx5e_tc_flow *flow = ptr;\n\tstruct mlx5e_priv *priv = flow->priv;\n\n\tmlx5e_tc_del_flow(priv, flow);\n\tkfree(flow);\n}\n\nvoid mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\n\tdebugfs_remove_recursive(tc->dfs_root);\n\n\tif (tc->netdevice_nb.notifier_call)\n\t\tunregister_netdevice_notifier_dev_net(priv->netdev,\n\t\t\t\t\t\t      &tc->netdevice_nb,\n\t\t\t\t\t\t      &tc->netdevice_nn);\n\n\tmlx5e_mod_hdr_tbl_destroy(&tc->mod_hdr);\n\tmutex_destroy(&tc->hairpin_tbl_lock);\n\n\trhashtable_free_and_destroy(&tc->ht, _mlx5e_tc_del_flow, NULL);\n\n\tif (!IS_ERR_OR_NULL(tc->t)) {\n\t\tmlx5_chains_put_table(tc->chains, 0, 1, MLX5E_TC_FT_LEVEL);\n\t\ttc->t = NULL;\n\t}\n\tmutex_destroy(&tc->t_lock);\n\n\tmlx5_tc_ct_clean(tc->ct);\n\tmlx5e_tc_post_act_destroy(tc->post_act);\n\tmapping_destroy(tc->mapping);\n\tmlx5_chains_destroy(tc->chains);\n\tmlx5e_tc_nic_destroy_miss_table(priv);\n\tmlx5e_tc_act_stats_free(tc->action_stats_handle);\n}\n\nint mlx5e_tc_ht_init(struct rhashtable *tc_ht)\n{\n\tint err;\n\n\terr = rhashtable_init(tc_ht, &tc_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tlockdep_set_class(&tc_ht->mutex, &tc_ht_lock_key);\n\tlockdep_init_map(&tc_ht->run_work.lockdep_map, \"tc_ht_wq_key\", &tc_ht_wq_key, 0);\n\n\treturn 0;\n}\n\nvoid mlx5e_tc_ht_cleanup(struct rhashtable *tc_ht)\n{\n\trhashtable_free_and_destroy(tc_ht, _mlx5e_tc_del_flow, NULL);\n}\n\nint mlx5e_tc_esw_init(struct mlx5_rep_uplink_priv *uplink_priv)\n{\n\tconst size_t sz_enc_opts = sizeof(struct tunnel_match_enc_opts);\n\tstruct netdev_phys_item_id ppid;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mapping_ctx *mapping;\n\tstruct mlx5_eswitch *esw;\n\tstruct mlx5e_priv *priv;\n\tu64 mapping_id, key;\n\tint err = 0;\n\n\trpriv = container_of(uplink_priv, struct mlx5e_rep_priv, uplink_priv);\n\tpriv = netdev_priv(rpriv->netdev);\n\tesw = priv->mdev->priv.eswitch;\n\n\tuplink_priv->post_act = mlx5e_tc_post_act_init(priv, esw_chains(esw),\n\t\t\t\t\t\t       MLX5_FLOW_NAMESPACE_FDB);\n\tuplink_priv->ct_priv = mlx5_tc_ct_init(netdev_priv(priv->netdev),\n\t\t\t\t\t       esw_chains(esw),\n\t\t\t\t\t       &esw->offloads.mod_hdr,\n\t\t\t\t\t       MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\t       uplink_priv->post_act);\n\n\tuplink_priv->int_port_priv = mlx5e_tc_int_port_init(netdev_priv(priv->netdev));\n\n\tuplink_priv->tc_psample = mlx5e_tc_sample_init(esw, uplink_priv->post_act);\n\n\tmapping_id = mlx5_query_nic_system_image_guid(esw->dev);\n\n\tmapping = mapping_create_for_id(mapping_id, MAPPING_TYPE_TUNNEL,\n\t\t\t\t\tsizeof(struct tunnel_match_key),\n\t\t\t\t\tTUNNEL_INFO_BITS_MASK, true);\n\n\tif (IS_ERR(mapping)) {\n\t\terr = PTR_ERR(mapping);\n\t\tgoto err_tun_mapping;\n\t}\n\tuplink_priv->tunnel_mapping = mapping;\n\n\t \n\tmapping = mapping_create_for_id(mapping_id, MAPPING_TYPE_TUNNEL_ENC_OPTS,\n\t\t\t\t\tsz_enc_opts, ENC_OPTS_BITS_MASK - 2, true);\n\tif (IS_ERR(mapping)) {\n\t\terr = PTR_ERR(mapping);\n\t\tgoto err_enc_opts_mapping;\n\t}\n\tuplink_priv->tunnel_enc_opts_mapping = mapping;\n\n\tuplink_priv->encap = mlx5e_tc_tun_init(priv);\n\tif (IS_ERR(uplink_priv->encap)) {\n\t\terr = PTR_ERR(uplink_priv->encap);\n\t\tgoto err_register_fib_notifier;\n\t}\n\n\tuplink_priv->action_stats_handle = mlx5e_tc_act_stats_create();\n\tif (IS_ERR(uplink_priv->action_stats_handle)) {\n\t\terr = PTR_ERR(uplink_priv->action_stats_handle);\n\t\tgoto err_action_counter;\n\t}\n\n\terr = dev_get_port_parent_id(priv->netdev, &ppid, false);\n\tif (!err) {\n\t\tmemcpy(&key, &ppid.id, sizeof(key));\n\t\tmlx5_esw_offloads_devcom_init(esw, key);\n\t}\n\n\treturn 0;\n\nerr_action_counter:\n\tmlx5e_tc_tun_cleanup(uplink_priv->encap);\nerr_register_fib_notifier:\n\tmapping_destroy(uplink_priv->tunnel_enc_opts_mapping);\nerr_enc_opts_mapping:\n\tmapping_destroy(uplink_priv->tunnel_mapping);\nerr_tun_mapping:\n\tmlx5e_tc_sample_cleanup(uplink_priv->tc_psample);\n\tmlx5e_tc_int_port_cleanup(uplink_priv->int_port_priv);\n\tmlx5_tc_ct_clean(uplink_priv->ct_priv);\n\tnetdev_warn(priv->netdev,\n\t\t    \"Failed to initialize tc (eswitch), err: %d\", err);\n\tmlx5e_tc_post_act_destroy(uplink_priv->post_act);\n\treturn err;\n}\n\nvoid mlx5e_tc_esw_cleanup(struct mlx5_rep_uplink_priv *uplink_priv)\n{\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mlx5_eswitch *esw;\n\tstruct mlx5e_priv *priv;\n\n\trpriv = container_of(uplink_priv, struct mlx5e_rep_priv, uplink_priv);\n\tpriv = netdev_priv(rpriv->netdev);\n\tesw = priv->mdev->priv.eswitch;\n\n\tmlx5_esw_offloads_devcom_cleanup(esw);\n\n\tmlx5e_tc_tun_cleanup(uplink_priv->encap);\n\n\tmapping_destroy(uplink_priv->tunnel_enc_opts_mapping);\n\tmapping_destroy(uplink_priv->tunnel_mapping);\n\n\tmlx5e_tc_sample_cleanup(uplink_priv->tc_psample);\n\tmlx5e_tc_int_port_cleanup(uplink_priv->int_port_priv);\n\tmlx5_tc_ct_clean(uplink_priv->ct_priv);\n\tmlx5e_flow_meters_cleanup(uplink_priv->flow_meters);\n\tmlx5e_tc_post_act_destroy(uplink_priv->post_act);\n\tmlx5e_tc_act_stats_free(uplink_priv->action_stats_handle);\n}\n\nint mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags)\n{\n\tstruct rhashtable *tc_ht = get_tc_ht(priv, flags);\n\n\treturn atomic_read(&tc_ht->nelems);\n}\n\nvoid mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw)\n{\n\tstruct mlx5e_tc_flow *flow, *tmp;\n\tint i;\n\n\tfor (i = 0; i < MLX5_MAX_PORTS; i++) {\n\t\tif (i == mlx5_get_dev_index(esw->dev))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(flow, tmp, &esw->offloads.peer_flows[i], peer[i])\n\t\t\tmlx5e_tc_del_fdb_peers_flow(flow);\n\t}\n}\n\nvoid mlx5e_tc_reoffload_flows_work(struct work_struct *work)\n{\n\tstruct mlx5_rep_uplink_priv *rpriv =\n\t\tcontainer_of(work, struct mlx5_rep_uplink_priv,\n\t\t\t     reoffload_flows_work);\n\tstruct mlx5e_tc_flow *flow, *tmp;\n\n\tmutex_lock(&rpriv->unready_flows_lock);\n\tlist_for_each_entry_safe(flow, tmp, &rpriv->unready_flows, unready) {\n\t\tif (!mlx5e_tc_add_fdb_flow(flow->priv, flow, NULL))\n\t\t\tunready_flow_del(flow);\n\t}\n\tmutex_unlock(&rpriv->unready_flows_lock);\n}\n\nstatic int mlx5e_setup_tc_cls_flower(struct mlx5e_priv *priv,\n\t\t\t\t     struct flow_cls_offload *cls_flower,\n\t\t\t\t     unsigned long flags)\n{\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn mlx5e_configure_flower(priv->netdev, priv, cls_flower,\n\t\t\t\t\t      flags);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn mlx5e_delete_flower(priv->netdev, priv, cls_flower,\n\t\t\t\t\t   flags);\n\tcase FLOW_CLS_STATS:\n\t\treturn mlx5e_stats_flower(priv->netdev, priv, cls_flower,\n\t\t\t\t\t  flags);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t    void *cb_priv)\n{\n\tunsigned long flags = MLX5_TC_FLAG(INGRESS);\n\tstruct mlx5e_priv *priv = cb_priv;\n\n\tif (!priv->netdev || !netif_device_present(priv->netdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mlx5e_is_uplink_rep(priv))\n\t\tflags |= MLX5_TC_FLAG(ESW_OFFLOAD);\n\telse\n\t\tflags |= MLX5_TC_FLAG(NIC_OFFLOAD);\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn mlx5e_setup_tc_cls_flower(priv, type_data, flags);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic bool mlx5e_tc_restore_tunnel(struct mlx5e_priv *priv, struct sk_buff *skb,\n\t\t\t\t    struct mlx5e_tc_update_priv *tc_priv,\n\t\t\t\t    u32 tunnel_id)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct tunnel_match_enc_opts enc_opts = {};\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct metadata_dst *tun_dst;\n\tstruct tunnel_match_key key;\n\tu32 tun_id, enc_opts_id;\n\tstruct net_device *dev;\n\tint err;\n\n\tenc_opts_id = tunnel_id & ENC_OPTS_BITS_MASK;\n\ttun_id = tunnel_id >> ENC_OPTS_BITS;\n\n\tif (!tun_id)\n\t\treturn true;\n\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\terr = mapping_find(uplink_priv->tunnel_mapping, tun_id, &key);\n\tif (err) {\n\t\tnetdev_dbg(priv->netdev,\n\t\t\t   \"Couldn't find tunnel for tun_id: %d, err: %d\\n\",\n\t\t\t   tun_id, err);\n\t\treturn false;\n\t}\n\n\tif (enc_opts_id) {\n\t\terr = mapping_find(uplink_priv->tunnel_enc_opts_mapping,\n\t\t\t\t   enc_opts_id, &enc_opts);\n\t\tif (err) {\n\t\t\tnetdev_dbg(priv->netdev,\n\t\t\t\t   \"Couldn't find tunnel (opts) for tun_id: %d, err: %d\\n\",\n\t\t\t\t   enc_opts_id, err);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tswitch (key.enc_control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\ttun_dst = __ip_tun_set_dst(key.enc_ipv4.src, key.enc_ipv4.dst,\n\t\t\t\t\t   key.enc_ip.tos, key.enc_ip.ttl,\n\t\t\t\t\t   key.enc_tp.dst, TUNNEL_KEY,\n\t\t\t\t\t   key32_to_tunnel_id(key.enc_key_id.keyid),\n\t\t\t\t\t   enc_opts.key.len);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\ttun_dst = __ipv6_tun_set_dst(&key.enc_ipv6.src, &key.enc_ipv6.dst,\n\t\t\t\t\t     key.enc_ip.tos, key.enc_ip.ttl,\n\t\t\t\t\t     key.enc_tp.dst, 0, TUNNEL_KEY,\n\t\t\t\t\t     key32_to_tunnel_id(key.enc_key_id.keyid),\n\t\t\t\t\t     enc_opts.key.len);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(priv->netdev,\n\t\t\t   \"Couldn't restore tunnel, unsupported addr_type: %d\\n\",\n\t\t\t   key.enc_control.addr_type);\n\t\treturn false;\n\t}\n\n\tif (!tun_dst) {\n\t\tnetdev_dbg(priv->netdev, \"Couldn't restore tunnel, no tun_dst\\n\");\n\t\treturn false;\n\t}\n\n\ttun_dst->u.tun_info.key.tp_src = key.enc_tp.src;\n\n\tif (enc_opts.key.len)\n\t\tip_tunnel_info_opts_set(&tun_dst->u.tun_info,\n\t\t\t\t\tenc_opts.key.data,\n\t\t\t\t\tenc_opts.key.len,\n\t\t\t\t\tenc_opts.key.dst_opt_type);\n\n\tskb_dst_set(skb, (struct dst_entry *)tun_dst);\n\tdev = dev_get_by_index(&init_net, key.filter_ifindex);\n\tif (!dev) {\n\t\tnetdev_dbg(priv->netdev,\n\t\t\t   \"Couldn't find tunnel device with ifindex: %d\\n\",\n\t\t\t   key.filter_ifindex);\n\t\treturn false;\n\t}\n\n\t \n\ttc_priv->fwd_dev = dev;\n\n\tskb->dev = dev;\n\n\treturn true;\n}\n\nstatic bool mlx5e_tc_restore_skb_tc_meta(struct sk_buff *skb, struct mlx5_tc_ct_priv *ct_priv,\n\t\t\t\t\t struct mlx5_mapped_obj *mapped_obj, u32 zone_restore_id,\n\t\t\t\t\t u32 tunnel_id,  struct mlx5e_tc_update_priv *tc_priv)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(skb->dev);\n\tstruct tc_skb_ext *tc_skb_ext;\n\tu64 act_miss_cookie;\n\tu32 chain;\n\n\tchain = mapped_obj->type == MLX5_MAPPED_OBJ_CHAIN ? mapped_obj->chain : 0;\n\tact_miss_cookie = mapped_obj->type == MLX5_MAPPED_OBJ_ACT_MISS ?\n\t\t\t  mapped_obj->act_miss_cookie : 0;\n\tif (chain || act_miss_cookie) {\n\t\tif (!mlx5e_tc_ct_restore_flow(ct_priv, skb, zone_restore_id))\n\t\t\treturn false;\n\n\t\ttc_skb_ext = tc_skb_ext_alloc(skb);\n\t\tif (!tc_skb_ext) {\n\t\t\tWARN_ON(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (act_miss_cookie) {\n\t\t\ttc_skb_ext->act_miss_cookie = act_miss_cookie;\n\t\t\ttc_skb_ext->act_miss = 1;\n\t\t} else {\n\t\t\ttc_skb_ext->chain = chain;\n\t\t}\n\t}\n\n\tif (tc_priv)\n\t\treturn mlx5e_tc_restore_tunnel(priv, skb, tc_priv, tunnel_id);\n\n\treturn true;\n}\n\nstatic void mlx5e_tc_restore_skb_sample(struct mlx5e_priv *priv, struct sk_buff *skb,\n\t\t\t\t\tstruct mlx5_mapped_obj *mapped_obj,\n\t\t\t\t\tstruct mlx5e_tc_update_priv *tc_priv)\n{\n\tif (!mlx5e_tc_restore_tunnel(priv, skb, tc_priv, mapped_obj->sample.tunnel_id)) {\n\t\tnetdev_dbg(priv->netdev,\n\t\t\t   \"Failed to restore tunnel info for sampled packet\\n\");\n\t\treturn;\n\t}\n\tmlx5e_tc_sample_skb(skb, mapped_obj);\n}\n\nstatic bool mlx5e_tc_restore_skb_int_port(struct mlx5e_priv *priv, struct sk_buff *skb,\n\t\t\t\t\t  struct mlx5_mapped_obj *mapped_obj,\n\t\t\t\t\t  struct mlx5e_tc_update_priv *tc_priv,\n\t\t\t\t\t  u32 tunnel_id)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tbool forward_tx = false;\n\n\t \n\tif (tunnel_id)\n\t\treturn mlx5e_tc_restore_tunnel(priv, skb, tc_priv, tunnel_id);\n\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\tif (mlx5e_tc_int_port_dev_fwd(uplink_priv->int_port_priv, skb,\n\t\t\t\t      mapped_obj->int_port_metadata, &forward_tx)) {\n\t\t \n\t\ttc_priv->fwd_dev = skb->dev;\n\t\ttc_priv->forward_tx = forward_tx;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool mlx5e_tc_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb,\n\t\t\t struct mapping_ctx *mapping_ctx, u32 mapped_obj_id,\n\t\t\t struct mlx5_tc_ct_priv *ct_priv,\n\t\t\t u32 zone_restore_id, u32 tunnel_id,\n\t\t\t struct mlx5e_tc_update_priv *tc_priv)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(skb->dev);\n\tstruct mlx5_mapped_obj mapped_obj;\n\tint err;\n\n\terr = mapping_find(mapping_ctx, mapped_obj_id, &mapped_obj);\n\tif (err) {\n\t\tnetdev_dbg(skb->dev,\n\t\t\t   \"Couldn't find mapped object for mapped_obj_id: %d, err: %d\\n\",\n\t\t\t   mapped_obj_id, err);\n\t\treturn false;\n\t}\n\n\tswitch (mapped_obj.type) {\n\tcase MLX5_MAPPED_OBJ_CHAIN:\n\tcase MLX5_MAPPED_OBJ_ACT_MISS:\n\t\treturn mlx5e_tc_restore_skb_tc_meta(skb, ct_priv, &mapped_obj, zone_restore_id,\n\t\t\t\t\t\t    tunnel_id, tc_priv);\n\tcase MLX5_MAPPED_OBJ_SAMPLE:\n\t\tmlx5e_tc_restore_skb_sample(priv, skb, &mapped_obj, tc_priv);\n\t\ttc_priv->skb_done = true;\n\t\treturn true;\n\tcase MLX5_MAPPED_OBJ_INT_PORT_METADATA:\n\t\treturn mlx5e_tc_restore_skb_int_port(priv, skb, &mapped_obj, tc_priv, tunnel_id);\n\tdefault:\n\t\tnetdev_dbg(priv->netdev, \"Invalid mapped object type: %d\\n\", mapped_obj.type);\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nbool mlx5e_tc_update_skb_nic(struct mlx5_cqe64 *cqe, struct sk_buff *skb)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(skb->dev);\n\tu32 mapped_obj_id, reg_b, zone_restore_id;\n\tstruct mlx5_tc_ct_priv *ct_priv;\n\tstruct mapping_ctx *mapping_ctx;\n\tstruct mlx5e_tc_table *tc;\n\n\treg_b = be32_to_cpu(cqe->ft_metadata);\n\ttc = mlx5e_fs_get_tc(priv->fs);\n\tmapped_obj_id = reg_b & MLX5E_TC_TABLE_CHAIN_TAG_MASK;\n\tzone_restore_id = (reg_b >> MLX5_REG_MAPPING_MOFFSET(NIC_ZONE_RESTORE_TO_REG)) &\n\t\t\t  ESW_ZONE_ID_MASK;\n\tct_priv = tc->ct;\n\tmapping_ctx = tc->mapping;\n\n\treturn mlx5e_tc_update_skb(cqe, skb, mapping_ctx, mapped_obj_id, ct_priv, zone_restore_id,\n\t\t\t\t   0, NULL);\n}\n\nstatic struct mapping_ctx *\nmlx5e_get_priv_obj_mapping(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tc_table *tc;\n\tstruct mlx5_eswitch *esw;\n\tstruct mapping_ctx *ctx;\n\n\tif (is_mdev_switchdev_mode(priv->mdev)) {\n\t\tesw = priv->mdev->priv.eswitch;\n\t\tctx = esw->offloads.reg_c0_obj_pool;\n\t} else {\n\t\ttc = mlx5e_fs_get_tc(priv->fs);\n\t\tctx = tc->mapping;\n\t}\n\n\treturn ctx;\n}\n\nint mlx5e_tc_action_miss_mapping_get(struct mlx5e_priv *priv, struct mlx5_flow_attr *attr,\n\t\t\t\t     u64 act_miss_cookie, u32 *act_miss_mapping)\n{\n\tstruct mlx5_mapped_obj mapped_obj = {};\n\tstruct mlx5_eswitch *esw;\n\tstruct mapping_ctx *ctx;\n\tint err;\n\n\tctx = mlx5e_get_priv_obj_mapping(priv);\n\tmapped_obj.type = MLX5_MAPPED_OBJ_ACT_MISS;\n\tmapped_obj.act_miss_cookie = act_miss_cookie;\n\terr = mapping_add(ctx, &mapped_obj, act_miss_mapping);\n\tif (err)\n\t\treturn err;\n\n\tif (!is_mdev_switchdev_mode(priv->mdev))\n\t\treturn 0;\n\n\tesw = priv->mdev->priv.eswitch;\n\tattr->act_id_restore_rule = esw_add_restore_rule(esw, *act_miss_mapping);\n\tif (IS_ERR(attr->act_id_restore_rule)) {\n\t\terr = PTR_ERR(attr->act_id_restore_rule);\n\t\tgoto err_rule;\n\t}\n\n\treturn 0;\n\nerr_rule:\n\tmapping_remove(ctx, *act_miss_mapping);\n\treturn err;\n}\n\nvoid mlx5e_tc_action_miss_mapping_put(struct mlx5e_priv *priv, struct mlx5_flow_attr *attr,\n\t\t\t\t      u32 act_miss_mapping)\n{\n\tstruct mapping_ctx *ctx = mlx5e_get_priv_obj_mapping(priv);\n\n\tif (is_mdev_switchdev_mode(priv->mdev))\n\t\tmlx5_del_flow_rules(attr->act_id_restore_rule);\n\tmapping_remove(ctx, act_miss_mapping);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}