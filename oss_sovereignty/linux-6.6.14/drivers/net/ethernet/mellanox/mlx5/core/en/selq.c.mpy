{
  "module_name": "selq.c",
  "hash_id": "fb361c8fbd99258a065c3eef705e876b747e70aef7b058c12128c6e1a223c346",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/selq.c",
  "human_readable_source": "\n \n\n#include \"selq.h\"\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/rcupdate.h>\n#include \"en.h\"\n#include \"en/ptp.h\"\n#include \"en/htb.h\"\n\nstruct mlx5e_selq_params {\n\tunsigned int num_regular_queues;\n\tunsigned int num_channels;\n\tunsigned int num_tcs;\n\tunion {\n\t\tu8 is_special_queues;\n\t\tstruct {\n\t\t\tbool is_htb : 1;\n\t\t\tbool is_ptp : 1;\n\t\t};\n\t};\n\tu16 htb_maj_id;\n\tu16 htb_defcls;\n};\n\nint mlx5e_selq_init(struct mlx5e_selq *selq, struct mutex *state_lock)\n{\n\tstruct mlx5e_selq_params *init_params;\n\n\tselq->state_lock = state_lock;\n\n\tselq->standby = kvzalloc(sizeof(*selq->standby), GFP_KERNEL);\n\tif (!selq->standby)\n\t\treturn -ENOMEM;\n\n\tinit_params = kvzalloc(sizeof(*selq->active), GFP_KERNEL);\n\tif (!init_params) {\n\t\tkvfree(selq->standby);\n\t\tselq->standby = NULL;\n\t\treturn -ENOMEM;\n\t}\n\t \n\t*init_params = (struct mlx5e_selq_params) {\n\t\t.num_regular_queues = 1,\n\t\t.num_channels = 1,\n\t\t.num_tcs = 1,\n\t\t.is_htb = false,\n\t\t.is_ptp = false,\n\t\t.htb_maj_id = 0,\n\t\t.htb_defcls = 0,\n\t};\n\trcu_assign_pointer(selq->active, init_params);\n\n\treturn 0;\n}\n\nvoid mlx5e_selq_cleanup(struct mlx5e_selq *selq)\n{\n\tWARN_ON_ONCE(selq->is_prepared);\n\n\tkvfree(selq->standby);\n\tselq->standby = NULL;\n\tselq->is_prepared = true;\n\n\tmlx5e_selq_apply(selq);\n\n\tkvfree(selq->standby);\n\tselq->standby = NULL;\n}\n\nvoid mlx5e_selq_prepare_params(struct mlx5e_selq *selq, struct mlx5e_params *params)\n{\n\tstruct mlx5e_selq_params *selq_active;\n\n\tlockdep_assert_held(selq->state_lock);\n\tWARN_ON_ONCE(selq->is_prepared);\n\n\tselq->is_prepared = true;\n\n\tselq_active = rcu_dereference_protected(selq->active,\n\t\t\t\t\t\tlockdep_is_held(selq->state_lock));\n\t*selq->standby = *selq_active;\n\tselq->standby->num_channels = params->num_channels;\n\tselq->standby->num_tcs = mlx5e_get_dcb_num_tc(params);\n\tselq->standby->num_regular_queues =\n\t\tselq->standby->num_channels * selq->standby->num_tcs;\n\tselq->standby->is_ptp = MLX5E_GET_PFLAG(params, MLX5E_PFLAG_TX_PORT_TS);\n}\n\nbool mlx5e_selq_is_htb_enabled(struct mlx5e_selq *selq)\n{\n\tstruct mlx5e_selq_params *selq_active =\n\t\trcu_dereference_protected(selq->active, lockdep_is_held(selq->state_lock));\n\n\treturn selq_active->htb_maj_id;\n}\n\nvoid mlx5e_selq_prepare_htb(struct mlx5e_selq *selq, u16 htb_maj_id, u16 htb_defcls)\n{\n\tstruct mlx5e_selq_params *selq_active;\n\n\tlockdep_assert_held(selq->state_lock);\n\tWARN_ON_ONCE(selq->is_prepared);\n\n\tselq->is_prepared = true;\n\n\tselq_active = rcu_dereference_protected(selq->active,\n\t\t\t\t\t\tlockdep_is_held(selq->state_lock));\n\t*selq->standby = *selq_active;\n\tselq->standby->is_htb = htb_maj_id;\n\tselq->standby->htb_maj_id = htb_maj_id;\n\tselq->standby->htb_defcls = htb_defcls;\n}\n\nvoid mlx5e_selq_apply(struct mlx5e_selq *selq)\n{\n\tstruct mlx5e_selq_params *old_params;\n\n\tWARN_ON_ONCE(!selq->is_prepared);\n\n\tselq->is_prepared = false;\n\n\told_params = rcu_replace_pointer(selq->active, selq->standby,\n\t\t\t\t\t lockdep_is_held(selq->state_lock));\n\tsynchronize_net();  \n\tselq->standby = old_params;\n}\n\nvoid mlx5e_selq_cancel(struct mlx5e_selq *selq)\n{\n\tlockdep_assert_held(selq->state_lock);\n\tWARN_ON_ONCE(!selq->is_prepared);\n\n\tselq->is_prepared = false;\n}\n\n#ifdef CONFIG_MLX5_CORE_EN_DCB\nstatic int mlx5e_get_dscp_up(struct mlx5e_priv *priv, struct sk_buff *skb)\n{\n\tint dscp_cp = 0;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tdscp_cp = ipv4_get_dsfield(ip_hdr(skb)) >> 2;\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tdscp_cp = ipv6_get_dsfield(ipv6_hdr(skb)) >> 2;\n\n\treturn priv->dcbx_dp.dscp2prio[dscp_cp];\n}\n#endif\n\nstatic int mlx5e_get_up(struct mlx5e_priv *priv, struct sk_buff *skb)\n{\n#ifdef CONFIG_MLX5_CORE_EN_DCB\n\tif (READ_ONCE(priv->dcbx_dp.trust_state) == MLX5_QPTS_TRUST_DSCP)\n\t\treturn mlx5e_get_dscp_up(priv, skb);\n#endif\n\tif (skb_vlan_tag_present(skb))\n\t\treturn skb_vlan_tag_get_prio(skb);\n\treturn 0;\n}\n\nstatic u16 mlx5e_select_ptpsq(struct net_device *dev, struct sk_buff *skb,\n\t\t\t      struct mlx5e_selq_params *selq)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tint up;\n\n\tup = selq->num_tcs > 1 ? mlx5e_get_up(priv, skb) : 0;\n\n\treturn selq->num_regular_queues + up;\n}\n\nstatic int mlx5e_select_htb_queue(struct mlx5e_priv *priv, struct sk_buff *skb,\n\t\t\t\t  struct mlx5e_selq_params *selq)\n{\n\tu16 classid;\n\n\t \n\tif ((TC_H_MAJ(skb->priority) >> 16) == selq->htb_maj_id)\n\t\tclassid = TC_H_MIN(skb->priority);\n\telse\n\t\tclassid = selq->htb_defcls;\n\n\tif (!classid)\n\t\treturn 0;\n\n\treturn mlx5e_htb_get_txq_by_classid(priv->htb, classid);\n}\n\nu16 mlx5e_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t       struct net_device *sb_dev)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5e_selq_params *selq;\n\tint txq_ix, up;\n\n\tselq = rcu_dereference_bh(priv->selq.active);\n\n\t \n\tif (unlikely(!selq))\n\t\treturn 0;\n\n\tif (likely(!selq->is_special_queues)) {\n\t\t \n\n\t\ttxq_ix = netdev_pick_tx(dev, skb, NULL);\n\n\t\tif (selq->num_tcs <= 1)\n\t\t\treturn txq_ix;\n\n\t\tup = mlx5e_get_up(priv, skb);\n\n\t\t \n\t\treturn mlx5e_txq_to_ch_ix(txq_ix, selq->num_channels) +\n\t\t\tup * selq->num_channels;\n\t}\n\n\tif (unlikely(selq->htb_maj_id)) {\n\t\t \n\n\t\ttxq_ix = mlx5e_select_htb_queue(priv, skb, selq);\n\t\tif (txq_ix > 0)\n\t\t\treturn txq_ix;\n\n\t\tif (unlikely(selq->is_ptp && mlx5e_use_ptpsq(skb)))\n\t\t\treturn selq->num_channels;\n\n\t\ttxq_ix = netdev_pick_tx(dev, skb, NULL);\n\n\t\t \n\t\treturn mlx5e_txq_to_ch_ix_htb(txq_ix, selq->num_channels);\n\t}\n\n\t \n\n\tif (mlx5e_use_ptpsq(skb))\n\t\treturn mlx5e_select_ptpsq(dev, skb, selq);\n\n\ttxq_ix = netdev_pick_tx(dev, skb, NULL);\n\n\t \n\ttxq_ix = mlx5e_txq_to_ch_ix(txq_ix, selq->num_channels);\n\n\tif (selq->num_tcs <= 1)\n\t\treturn txq_ix;\n\n\tup = mlx5e_get_up(priv, skb);\n\n\treturn txq_ix + up * selq->num_channels;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}