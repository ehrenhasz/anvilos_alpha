{
  "module_name": "tout.c",
  "hash_id": "cc982d3bb03c0c3da47d6fc637a24ca16f2795dc51466a1d970fceb507ff2fce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/tout.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/driver.h>\n#include \"lib/tout.h\"\n\nstruct mlx5_timeouts {\n\tu64 to[MAX_TIMEOUT_TYPES];\n};\n\nstatic const u32 tout_def_sw_val[MAX_TIMEOUT_TYPES] = {\n\t[MLX5_TO_FW_PRE_INIT_TIMEOUT_MS] = 120000,\n\t[MLX5_TO_FW_PRE_INIT_ON_RECOVERY_TIMEOUT_MS] = 7200000,\n\t[MLX5_TO_FW_PRE_INIT_WARN_MESSAGE_INTERVAL_MS] = 20000,\n\t[MLX5_TO_FW_PRE_INIT_WAIT_MS] = 2,\n\t[MLX5_TO_FW_INIT_MS] = 2000,\n\t[MLX5_TO_CMD_MS] = 60000,\n\t[MLX5_TO_PCI_TOGGLE_MS] =  2000,\n\t[MLX5_TO_HEALTH_POLL_INTERVAL_MS] =  2000,\n\t[MLX5_TO_FULL_CRDUMP_MS] = 60000,\n\t[MLX5_TO_FW_RESET_MS] = 60000,\n\t[MLX5_TO_FLUSH_ON_ERROR_MS] = 2000,\n\t[MLX5_TO_PCI_SYNC_UPDATE_MS] = 5000,\n\t[MLX5_TO_TEARDOWN_MS] = 3000,\n\t[MLX5_TO_FSM_REACTIVATE_MS] = 5000,\n\t[MLX5_TO_RECLAIM_PAGES_MS] = 5000,\n\t[MLX5_TO_RECLAIM_VFS_PAGES_MS] = 120000,\n\t[MLX5_TO_RESET_UNLOAD_MS] = 300000\n};\n\nstatic void tout_set(struct mlx5_core_dev *dev, u64 val, enum mlx5_timeouts_types type)\n{\n\tdev->timeouts->to[type] = val;\n}\n\nint mlx5_tout_init(struct mlx5_core_dev *dev)\n{\n\tint i;\n\n\tdev->timeouts = kmalloc(sizeof(*dev->timeouts), GFP_KERNEL);\n\tif (!dev->timeouts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAX_TIMEOUT_TYPES; i++)\n\t\ttout_set(dev, tout_def_sw_val[i], i);\n\n\treturn 0;\n}\n\nvoid mlx5_tout_cleanup(struct mlx5_core_dev *dev)\n{\n\tkfree(dev->timeouts);\n}\n\n \nstatic u64 tout_convert_reg_field_to_ms(u32 to_mul, u32 to_val)\n{\n\tu64 msec = to_val;\n\n\tto_mul &= 0x3;\n\t \n\tif (to_mul)\n\t\tmsec *= 1000 * int_pow(60, to_mul - 1);\n\n\treturn msec;\n}\n\nstatic u64 tout_convert_iseg_to_ms(u32 iseg_to)\n{\n\treturn tout_convert_reg_field_to_ms(iseg_to >> 29, iseg_to & 0xfffff);\n}\n\nstatic bool tout_is_supported(struct mlx5_core_dev *dev)\n{\n\treturn !!ioread32be(&dev->iseg->cmd_q_init_to);\n}\n\nvoid mlx5_tout_query_iseg(struct mlx5_core_dev *dev)\n{\n\tu32 to;\n\n\tif (!tout_is_supported(dev))\n\t\treturn;\n\n\tto = ioread32be(&dev->iseg->cmd_q_init_to);\n\ttout_set(dev, tout_convert_iseg_to_ms(to), MLX5_TO_FW_INIT_MS);\n\n\tto = ioread32be(&dev->iseg->cmd_exec_to);\n\ttout_set(dev, tout_convert_iseg_to_ms(to), MLX5_TO_CMD_MS);\n}\n\nu64 _mlx5_tout_ms(struct mlx5_core_dev *dev, enum mlx5_timeouts_types type)\n{\n\treturn dev->timeouts->to[type];\n}\n\n#define MLX5_TIMEOUT_QUERY(fld, reg_out) \\\n\t({ \\\n\tstruct mlx5_ifc_default_timeout_bits *time_field; \\\n\tu32 to_multi, to_value; \\\n\tu64 to_val_ms; \\\n\t\\\n\ttime_field = MLX5_ADDR_OF(dtor_reg, reg_out, fld); \\\n\tto_multi = MLX5_GET(default_timeout, time_field, to_multiplier); \\\n\tto_value = MLX5_GET(default_timeout, time_field, to_value); \\\n\tto_val_ms = tout_convert_reg_field_to_ms(to_multi, to_value); \\\n\tto_val_ms; \\\n\t})\n\n#define MLX5_TIMEOUT_FILL(fld, reg_out, dev, to_type, to_extra) \\\n\t({ \\\n\tu64 fw_to = MLX5_TIMEOUT_QUERY(fld, reg_out); \\\n\tif (fw_to) \\\n\t\ttout_set(dev, fw_to + (to_extra), to_type); \\\n\tfw_to; \\\n\t})\n\nstatic int tout_query_dtor(struct mlx5_core_dev *dev)\n{\n\tu64 pcie_toggle_to_val, tear_down_to_val;\n\tu32 out[MLX5_ST_SZ_DW(dtor_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(dtor_reg)] = {};\n\tint err;\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out), MLX5_REG_DTOR, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tpcie_toggle_to_val = MLX5_TIMEOUT_FILL(pcie_toggle_to, out, dev, MLX5_TO_PCI_TOGGLE_MS, 0);\n\tMLX5_TIMEOUT_FILL(fw_reset_to, out, dev, MLX5_TO_FW_RESET_MS, pcie_toggle_to_val);\n\n\ttear_down_to_val = MLX5_TIMEOUT_FILL(tear_down_to, out, dev, MLX5_TO_TEARDOWN_MS, 0);\n\tMLX5_TIMEOUT_FILL(pci_sync_update_to, out, dev, MLX5_TO_PCI_SYNC_UPDATE_MS,\n\t\t\t  tear_down_to_val);\n\n\tMLX5_TIMEOUT_FILL(health_poll_to, out, dev, MLX5_TO_HEALTH_POLL_INTERVAL_MS, 0);\n\tMLX5_TIMEOUT_FILL(full_crdump_to, out, dev, MLX5_TO_FULL_CRDUMP_MS, 0);\n\tMLX5_TIMEOUT_FILL(flush_on_err_to, out, dev, MLX5_TO_FLUSH_ON_ERROR_MS, 0);\n\tMLX5_TIMEOUT_FILL(fsm_reactivate_to, out, dev, MLX5_TO_FSM_REACTIVATE_MS, 0);\n\tMLX5_TIMEOUT_FILL(reclaim_pages_to, out, dev, MLX5_TO_RECLAIM_PAGES_MS, 0);\n\tMLX5_TIMEOUT_FILL(reclaim_vfs_pages_to, out, dev, MLX5_TO_RECLAIM_VFS_PAGES_MS, 0);\n\tMLX5_TIMEOUT_FILL(reset_unload_to, out, dev, MLX5_TO_RESET_UNLOAD_MS, 0);\n\n\treturn 0;\n}\n\nint mlx5_tout_query_dtor(struct mlx5_core_dev *dev)\n{\n\tif (tout_is_supported(dev))\n\t\treturn tout_query_dtor(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}