{
  "module_name": "devlink.c",
  "hash_id": "bb6817e55fdef70813df569a33c8f343240a4caf4bec9dc2f78b8ec92c25dcfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/devlink.c",
  "human_readable_source": "\n \n\n#include <devlink.h>\n\n#include \"mlx5_core.h\"\n#include \"fw_reset.h\"\n#include \"fs_core.h\"\n#include \"eswitch.h\"\n#include \"esw/qos.h\"\n#include \"sf/dev/dev.h\"\n#include \"sf/sf.h\"\n\nstatic int mlx5_devlink_flash_update(struct devlink *devlink,\n\t\t\t\t     struct devlink_flash_update_params *params,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\n\treturn mlx5_firmware_flash(dev, params->fw, extack);\n}\n\nstatic u8 mlx5_fw_ver_major(u32 version)\n{\n\treturn (version >> 24) & 0xff;\n}\n\nstatic u8 mlx5_fw_ver_minor(u32 version)\n{\n\treturn (version >> 16) & 0xff;\n}\n\nstatic u16 mlx5_fw_ver_subminor(u32 version)\n{\n\treturn version & 0xffff;\n}\n\n#define DEVLINK_FW_STRING_LEN 32\n\nstatic int\nmlx5_devlink_info_get(struct devlink *devlink, struct devlink_info_req *req,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tchar version_str[DEVLINK_FW_STRING_LEN];\n\tu32 running_fw, stored_fw;\n\tint err;\n\n\terr = devlink_info_version_fixed_put(req, \"fw.psid\", dev->board_id);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_fw_version_query(dev, &running_fw, &stored_fw);\n\tif (err)\n\t\treturn err;\n\n\tsnprintf(version_str, sizeof(version_str), \"%d.%d.%04d\",\n\t\t mlx5_fw_ver_major(running_fw), mlx5_fw_ver_minor(running_fw),\n\t\t mlx5_fw_ver_subminor(running_fw));\n\terr = devlink_info_version_running_put(req, \"fw.version\", version_str);\n\tif (err)\n\t\treturn err;\n\terr = devlink_info_version_running_put(req,\n\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_FW,\n\t\t\t\t\t       version_str);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (stored_fw == 0)\n\t\tstored_fw = running_fw;\n\n\tsnprintf(version_str, sizeof(version_str), \"%d.%d.%04d\",\n\t\t mlx5_fw_ver_major(stored_fw), mlx5_fw_ver_minor(stored_fw),\n\t\t mlx5_fw_ver_subminor(stored_fw));\n\terr = devlink_info_version_stored_put(req, \"fw.version\", version_str);\n\tif (err)\n\t\treturn err;\n\treturn devlink_info_version_stored_put(req,\n\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_FW,\n\t\t\t\t\t       version_str);\n}\n\nstatic int mlx5_devlink_reload_fw_activate(struct devlink *devlink, struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tu8 reset_level, reset_type, net_port_alive;\n\tint err;\n\n\terr = mlx5_fw_reset_query(dev, &reset_level, &reset_type);\n\tif (err)\n\t\treturn err;\n\tif (!(reset_level & MLX5_MFRL_REG_RESET_LEVEL3)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"FW activate requires reboot\");\n\t\treturn -EINVAL;\n\t}\n\n\tnet_port_alive = !!(reset_type & MLX5_MFRL_REG_RESET_TYPE_NET_PORT_ALIVE);\n\terr = mlx5_fw_reset_set_reset_sync(dev, net_port_alive, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_fw_reset_wait_reset_done(dev);\n\tif (err)\n\t\treturn err;\n\n\tmlx5_unload_one_devl_locked(dev, true);\n\terr = mlx5_health_wait_pci_up(dev);\n\tif (err)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"FW activate aborted, PCI reads fail after reset\");\n\n\treturn err;\n}\n\nstatic int mlx5_devlink_trigger_fw_live_patch(struct devlink *devlink,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tu8 reset_level;\n\tint err;\n\n\terr = mlx5_fw_reset_query(dev, &reset_level, NULL);\n\tif (err)\n\t\treturn err;\n\tif (!(reset_level & MLX5_MFRL_REG_RESET_LEVEL0)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"FW upgrade to the stored FW can't be done by FW live patching\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn mlx5_fw_reset_set_live_patch(dev);\n}\n\nstatic int mlx5_devlink_reload_down(struct devlink *devlink, bool netns_change,\n\t\t\t\t    enum devlink_reload_action action,\n\t\t\t\t    enum devlink_reload_limit limit,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct pci_dev *pdev = dev->pdev;\n\tbool sf_dev_allocated;\n\tint ret = 0;\n\n\tif (mlx5_dev_is_lightweight(dev)) {\n\t\tif (action != DEVLINK_RELOAD_ACTION_DRIVER_REINIT)\n\t\t\treturn -EOPNOTSUPP;\n\t\tmlx5_unload_one_light(dev);\n\t\treturn 0;\n\t}\n\n\tsf_dev_allocated = mlx5_sf_dev_allocated(dev);\n\tif (sf_dev_allocated) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"reload is unsupported when SFs are allocated\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mlx5_lag_is_active(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"reload is unsupported in Lag mode\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mlx5_core_is_mp_slave(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"reload is unsupported for multi port slave\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mlx5_core_is_pf(dev) && pci_num_vf(pdev))\n\t\tNL_SET_ERR_MSG_MOD(extack, \"reload while VFs are present is unfavorable\");\n\n\tswitch (action) {\n\tcase DEVLINK_RELOAD_ACTION_DRIVER_REINIT:\n\t\tmlx5_unload_one_devl_locked(dev, false);\n\t\tbreak;\n\tcase DEVLINK_RELOAD_ACTION_FW_ACTIVATE:\n\t\tif (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)\n\t\t\tret = mlx5_devlink_trigger_fw_live_patch(devlink, extack);\n\t\telse\n\t\t\tret = mlx5_devlink_reload_fw_activate(devlink, extack);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int mlx5_devlink_reload_up(struct devlink *devlink, enum devlink_reload_action action,\n\t\t\t\t  enum devlink_reload_limit limit, u32 *actions_performed,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tint ret = 0;\n\n\t*actions_performed = BIT(action);\n\tswitch (action) {\n\tcase DEVLINK_RELOAD_ACTION_DRIVER_REINIT:\n\t\tif (mlx5_dev_is_lightweight(dev)) {\n\t\t\tmlx5_fw_reporters_create(dev);\n\t\t\treturn mlx5_init_one_devl_locked(dev);\n\t\t}\n\t\tret = mlx5_load_one_devl_locked(dev, false);\n\t\tbreak;\n\tcase DEVLINK_RELOAD_ACTION_FW_ACTIVATE:\n\t\tif (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)\n\t\t\tbreak;\n\t\t \n\t\t*actions_performed |= BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);\n\t\tret = mlx5_load_one_devl_locked(dev, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = mlx5_fw_reset_verify_fw_complete(dev, extack);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic struct mlx5_devlink_trap *mlx5_find_trap_by_id(struct mlx5_core_dev *dev, int trap_id)\n{\n\tstruct mlx5_devlink_trap *dl_trap;\n\n\tlist_for_each_entry(dl_trap, &dev->priv.traps, list)\n\t\tif (dl_trap->trap.id == trap_id)\n\t\t\treturn dl_trap;\n\n\treturn NULL;\n}\n\nstatic int mlx5_devlink_trap_init(struct devlink *devlink, const struct devlink_trap *trap,\n\t\t\t\t  void *trap_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct mlx5_devlink_trap *dl_trap;\n\n\tdl_trap = kzalloc(sizeof(*dl_trap), GFP_KERNEL);\n\tif (!dl_trap)\n\t\treturn -ENOMEM;\n\n\tdl_trap->trap.id = trap->id;\n\tdl_trap->trap.action = DEVLINK_TRAP_ACTION_DROP;\n\tdl_trap->item = trap_ctx;\n\n\tif (mlx5_find_trap_by_id(dev, trap->id)) {\n\t\tkfree(dl_trap);\n\t\tmlx5_core_err(dev, \"Devlink trap: Trap 0x%x already found\", trap->id);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&dl_trap->list, &dev->priv.traps);\n\treturn 0;\n}\n\nstatic void mlx5_devlink_trap_fini(struct devlink *devlink, const struct devlink_trap *trap,\n\t\t\t\t   void *trap_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct mlx5_devlink_trap *dl_trap;\n\n\tdl_trap = mlx5_find_trap_by_id(dev, trap->id);\n\tif (!dl_trap) {\n\t\tmlx5_core_err(dev, \"Devlink trap: Missing trap id 0x%x\", trap->id);\n\t\treturn;\n\t}\n\tlist_del(&dl_trap->list);\n\tkfree(dl_trap);\n}\n\nstatic int mlx5_devlink_trap_action_set(struct devlink *devlink,\n\t\t\t\t\tconst struct devlink_trap *trap,\n\t\t\t\t\tenum devlink_trap_action action,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct mlx5_devlink_trap_event_ctx trap_event_ctx;\n\tenum devlink_trap_action action_orig;\n\tstruct mlx5_devlink_trap *dl_trap;\n\tint err;\n\n\tif (is_mdev_switchdev_mode(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Devlink traps can't be set in switchdev mode\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdl_trap = mlx5_find_trap_by_id(dev, trap->id);\n\tif (!dl_trap) {\n\t\tmlx5_core_err(dev, \"Devlink trap: Set action on invalid trap id 0x%x\", trap->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (action != DEVLINK_TRAP_ACTION_DROP && action != DEVLINK_TRAP_ACTION_TRAP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (action == dl_trap->trap.action)\n\t\treturn 0;\n\n\taction_orig = dl_trap->trap.action;\n\tdl_trap->trap.action = action;\n\ttrap_event_ctx.trap = &dl_trap->trap;\n\ttrap_event_ctx.err = 0;\n\terr = mlx5_blocking_notifier_call_chain(dev, MLX5_DRIVER_EVENT_TYPE_TRAP,\n\t\t\t\t\t\t&trap_event_ctx);\n\tif (err == NOTIFY_BAD)\n\t\tdl_trap->trap.action = action_orig;\n\n\treturn trap_event_ctx.err;\n}\n\nstatic const struct devlink_ops mlx5_devlink_ops = {\n#ifdef CONFIG_MLX5_ESWITCH\n\t.eswitch_mode_set = mlx5_devlink_eswitch_mode_set,\n\t.eswitch_mode_get = mlx5_devlink_eswitch_mode_get,\n\t.eswitch_inline_mode_set = mlx5_devlink_eswitch_inline_mode_set,\n\t.eswitch_inline_mode_get = mlx5_devlink_eswitch_inline_mode_get,\n\t.eswitch_encap_mode_set = mlx5_devlink_eswitch_encap_mode_set,\n\t.eswitch_encap_mode_get = mlx5_devlink_eswitch_encap_mode_get,\n\t.rate_leaf_tx_share_set = mlx5_esw_devlink_rate_leaf_tx_share_set,\n\t.rate_leaf_tx_max_set = mlx5_esw_devlink_rate_leaf_tx_max_set,\n\t.rate_node_tx_share_set = mlx5_esw_devlink_rate_node_tx_share_set,\n\t.rate_node_tx_max_set = mlx5_esw_devlink_rate_node_tx_max_set,\n\t.rate_node_new = mlx5_esw_devlink_rate_node_new,\n\t.rate_node_del = mlx5_esw_devlink_rate_node_del,\n\t.rate_leaf_parent_set = mlx5_esw_devlink_rate_parent_set,\n#endif\n#ifdef CONFIG_MLX5_SF_MANAGER\n\t.port_new = mlx5_devlink_sf_port_new,\n#endif\n\t.flash_update = mlx5_devlink_flash_update,\n\t.info_get = mlx5_devlink_info_get,\n\t.reload_actions = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |\n\t\t\t  BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE),\n\t.reload_limits = BIT(DEVLINK_RELOAD_LIMIT_NO_RESET),\n\t.reload_down = mlx5_devlink_reload_down,\n\t.reload_up = mlx5_devlink_reload_up,\n\t.trap_init = mlx5_devlink_trap_init,\n\t.trap_fini = mlx5_devlink_trap_fini,\n\t.trap_action_set = mlx5_devlink_trap_action_set,\n};\n\nvoid mlx5_devlink_trap_report(struct mlx5_core_dev *dev, int trap_id, struct sk_buff *skb,\n\t\t\t      struct devlink_port *dl_port)\n{\n\tstruct devlink *devlink = priv_to_devlink(dev);\n\tstruct mlx5_devlink_trap *dl_trap;\n\n\tdl_trap = mlx5_find_trap_by_id(dev, trap_id);\n\tif (!dl_trap) {\n\t\tmlx5_core_err(dev, \"Devlink trap: Report on invalid trap id 0x%x\", trap_id);\n\t\treturn;\n\t}\n\n\tif (dl_trap->trap.action != DEVLINK_TRAP_ACTION_TRAP) {\n\t\tmlx5_core_dbg(dev, \"Devlink trap: Trap id %d has action %d\", trap_id,\n\t\t\t      dl_trap->trap.action);\n\t\treturn;\n\t}\n\tdevlink_trap_report(devlink, skb, dl_trap->item, dl_port, NULL);\n}\n\nint mlx5_devlink_trap_get_num_active(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_devlink_trap *dl_trap;\n\tint count = 0;\n\n\tlist_for_each_entry(dl_trap, &dev->priv.traps, list)\n\t\tif (dl_trap->trap.action == DEVLINK_TRAP_ACTION_TRAP)\n\t\t\tcount++;\n\n\treturn count;\n}\n\nint mlx5_devlink_traps_get_action(struct mlx5_core_dev *dev, int trap_id,\n\t\t\t\t  enum devlink_trap_action *action)\n{\n\tstruct mlx5_devlink_trap *dl_trap;\n\n\tdl_trap = mlx5_find_trap_by_id(dev, trap_id);\n\tif (!dl_trap) {\n\t\tmlx5_core_err(dev, \"Devlink trap: Get action on invalid trap id 0x%x\",\n\t\t\t      trap_id);\n\t\treturn -EINVAL;\n\t}\n\n\t*action = dl_trap->trap.action;\n\treturn 0;\n}\n\nstruct devlink *mlx5_devlink_alloc(struct device *dev)\n{\n\treturn devlink_alloc(&mlx5_devlink_ops, sizeof(struct mlx5_core_dev),\n\t\t\t     dev);\n}\n\nvoid mlx5_devlink_free(struct devlink *devlink)\n{\n\tdevlink_free(devlink);\n}\n\nstatic int mlx5_devlink_enable_roce_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t     union devlink_param_value val,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tbool new_state = val.vbool;\n\n\tif (new_state && !MLX5_CAP_GEN(dev, roce) &&\n\t    !(MLX5_CAP_GEN(dev, roce_rw_supported) && MLX5_CAP_GEN_MAX(dev, roce))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Device doesn't support RoCE\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (mlx5_core_is_mp_slave(dev) || mlx5_lag_is_active(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Multi port slave/Lag device can't configure RoCE\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_MLX5_ESWITCH\nstatic int mlx5_devlink_large_group_num_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t\t union devlink_param_value val,\n\t\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint group_num = val.vu32;\n\n\tif (group_num < 1 || group_num > 1024) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Unsupported group number, supported range is 1-1024\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int mlx5_devlink_eq_depth_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t  union devlink_param_value val,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn (val.vu32 >= 64 && val.vu32 <= 4096) ? 0 : -EINVAL;\n}\n\nstatic int\nmlx5_devlink_hairpin_num_queues_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t union devlink_param_value val,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn val.vu32 ? 0 : -EINVAL;\n}\n\nstatic int\nmlx5_devlink_hairpin_queue_size_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t union devlink_param_value val,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tu32 val32 = val.vu32;\n\n\tif (!is_power_of_2(val32)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Value is not power of two\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (val32 > BIT(MLX5_CAP_GEN(dev, log_max_hairpin_num_packets))) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(\n\t\t\textack, \"Maximum hairpin queue size is %lu\",\n\t\t\tBIT(MLX5_CAP_GEN(dev, log_max_hairpin_num_packets)));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlx5_devlink_hairpin_params_init_values(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tunion devlink_param_value value;\n\tu32 link_speed = 0;\n\tu64 link_speed64;\n\n\t \n\tmlx5_port_max_linkspeed(dev, &link_speed);\n\tlink_speed = max_t(u32, link_speed, 50000);\n\tlink_speed64 = link_speed;\n\tdo_div(link_speed64, 50000);\n\n\tvalue.vu32 = link_speed64;\n\tdevl_param_driverinit_value_set(\n\t\tdevlink, MLX5_DEVLINK_PARAM_ID_HAIRPIN_NUM_QUEUES, value);\n\n\tvalue.vu32 =\n\t\tBIT(min_t(u32, 16 - MLX5_MPWRQ_MIN_LOG_STRIDE_SZ(dev),\n\t\t\t  MLX5_CAP_GEN(dev, log_max_hairpin_num_packets)));\n\tdevl_param_driverinit_value_set(\n\t\tdevlink, MLX5_DEVLINK_PARAM_ID_HAIRPIN_QUEUE_SIZE, value);\n}\n\nstatic const struct devlink_param mlx5_devlink_params[] = {\n\tDEVLINK_PARAM_GENERIC(ENABLE_ROCE, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, mlx5_devlink_enable_roce_validate),\n#ifdef CONFIG_MLX5_ESWITCH\n\tDEVLINK_PARAM_DRIVER(MLX5_DEVLINK_PARAM_ID_ESW_LARGE_GROUP_NUM,\n\t\t\t     \"fdb_large_groups\", DEVLINK_PARAM_TYPE_U32,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t     NULL, NULL,\n\t\t\t     mlx5_devlink_large_group_num_validate),\n#endif\n\tDEVLINK_PARAM_GENERIC(IO_EQ_SIZE, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, mlx5_devlink_eq_depth_validate),\n\tDEVLINK_PARAM_GENERIC(EVENT_EQ_SIZE, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, mlx5_devlink_eq_depth_validate),\n};\n\nstatic void mlx5_devlink_set_params_init_values(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tunion devlink_param_value value;\n\n\tvalue.vbool = MLX5_CAP_GEN(dev, roce) && !mlx5_dev_is_lightweight(dev);\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE,\n\t\t\t\t\tvalue);\n\n#ifdef CONFIG_MLX5_ESWITCH\n\tvalue.vu32 = ESW_OFFLOADS_DEFAULT_NUM_GROUPS;\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tMLX5_DEVLINK_PARAM_ID_ESW_LARGE_GROUP_NUM,\n\t\t\t\t\tvalue);\n#endif\n\n\tvalue.vu32 = MLX5_COMP_EQ_SIZE;\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_IO_EQ_SIZE,\n\t\t\t\t\tvalue);\n\n\tvalue.vu32 = MLX5_NUM_ASYNC_EQE;\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_EVENT_EQ_SIZE,\n\t\t\t\t\tvalue);\n}\n\nstatic const struct devlink_param mlx5_devlink_eth_params[] = {\n\tDEVLINK_PARAM_GENERIC(ENABLE_ETH, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, NULL),\n\tDEVLINK_PARAM_DRIVER(MLX5_DEVLINK_PARAM_ID_HAIRPIN_NUM_QUEUES,\n\t\t\t     \"hairpin_num_queues\", DEVLINK_PARAM_TYPE_U32,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_DRIVERINIT), NULL, NULL,\n\t\t\t     mlx5_devlink_hairpin_num_queues_validate),\n\tDEVLINK_PARAM_DRIVER(MLX5_DEVLINK_PARAM_ID_HAIRPIN_QUEUE_SIZE,\n\t\t\t     \"hairpin_queue_size\", DEVLINK_PARAM_TYPE_U32,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_DRIVERINIT), NULL, NULL,\n\t\t\t     mlx5_devlink_hairpin_queue_size_validate),\n};\n\nstatic int mlx5_devlink_eth_params_register(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tunion devlink_param_value value;\n\tint err;\n\n\tif (!mlx5_eth_supported(dev))\n\t\treturn 0;\n\n\terr = devl_params_register(devlink, mlx5_devlink_eth_params,\n\t\t\t\t   ARRAY_SIZE(mlx5_devlink_eth_params));\n\tif (err)\n\t\treturn err;\n\n\tvalue.vbool = !mlx5_dev_is_lightweight(dev);\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_ENABLE_ETH,\n\t\t\t\t\tvalue);\n\n\tmlx5_devlink_hairpin_params_init_values(devlink);\n\n\treturn 0;\n}\n\nstatic void mlx5_devlink_eth_params_unregister(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\n\tif (!mlx5_eth_supported(dev))\n\t\treturn;\n\n\tdevl_params_unregister(devlink, mlx5_devlink_eth_params,\n\t\t\t       ARRAY_SIZE(mlx5_devlink_eth_params));\n}\n\nstatic int mlx5_devlink_enable_rdma_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t     union devlink_param_value val,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tbool new_state = val.vbool;\n\n\tif (new_state && !mlx5_rdma_supported(dev))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic const struct devlink_param mlx5_devlink_rdma_params[] = {\n\tDEVLINK_PARAM_GENERIC(ENABLE_RDMA, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, mlx5_devlink_enable_rdma_validate),\n};\n\nstatic int mlx5_devlink_rdma_params_register(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tunion devlink_param_value value;\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))\n\t\treturn 0;\n\n\terr = devl_params_register(devlink, mlx5_devlink_rdma_params,\n\t\t\t\t   ARRAY_SIZE(mlx5_devlink_rdma_params));\n\tif (err)\n\t\treturn err;\n\n\tvalue.vbool = !mlx5_dev_is_lightweight(dev);\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA,\n\t\t\t\t\tvalue);\n\treturn 0;\n}\n\nstatic void mlx5_devlink_rdma_params_unregister(struct devlink *devlink)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))\n\t\treturn;\n\n\tdevl_params_unregister(devlink, mlx5_devlink_rdma_params,\n\t\t\t       ARRAY_SIZE(mlx5_devlink_rdma_params));\n}\n\nstatic const struct devlink_param mlx5_devlink_vnet_params[] = {\n\tDEVLINK_PARAM_GENERIC(ENABLE_VNET, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, NULL),\n};\n\nstatic int mlx5_devlink_vnet_params_register(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tunion devlink_param_value value;\n\tint err;\n\n\tif (!mlx5_vnet_supported(dev))\n\t\treturn 0;\n\n\terr = devl_params_register(devlink, mlx5_devlink_vnet_params,\n\t\t\t\t   ARRAY_SIZE(mlx5_devlink_vnet_params));\n\tif (err)\n\t\treturn err;\n\n\tvalue.vbool = !mlx5_dev_is_lightweight(dev);\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_ENABLE_VNET,\n\t\t\t\t\tvalue);\n\treturn 0;\n}\n\nstatic void mlx5_devlink_vnet_params_unregister(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\n\tif (!mlx5_vnet_supported(dev))\n\t\treturn;\n\n\tdevl_params_unregister(devlink, mlx5_devlink_vnet_params,\n\t\t\t       ARRAY_SIZE(mlx5_devlink_vnet_params));\n}\n\nstatic int mlx5_devlink_auxdev_params_register(struct devlink *devlink)\n{\n\tint err;\n\n\terr = mlx5_devlink_eth_params_register(devlink);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_devlink_rdma_params_register(devlink);\n\tif (err)\n\t\tgoto rdma_err;\n\n\terr = mlx5_devlink_vnet_params_register(devlink);\n\tif (err)\n\t\tgoto vnet_err;\n\treturn 0;\n\nvnet_err:\n\tmlx5_devlink_rdma_params_unregister(devlink);\nrdma_err:\n\tmlx5_devlink_eth_params_unregister(devlink);\n\treturn err;\n}\n\nstatic void mlx5_devlink_auxdev_params_unregister(struct devlink *devlink)\n{\n\tmlx5_devlink_vnet_params_unregister(devlink);\n\tmlx5_devlink_rdma_params_unregister(devlink);\n\tmlx5_devlink_eth_params_unregister(devlink);\n}\n\nstatic int mlx5_devlink_max_uc_list_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t     union devlink_param_value val,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\n\tif (val.vu32 == 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"max_macs value must be greater than 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(val.vu32)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only power of 2 values are supported for max_macs\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ilog2(val.vu32) >\n\t    MLX5_CAP_GEN_MAX(dev, log_max_current_uc_list)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"max_macs value is out of the supported range\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct devlink_param mlx5_devlink_max_uc_list_params[] = {\n\tDEVLINK_PARAM_GENERIC(MAX_MACS, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, mlx5_devlink_max_uc_list_validate),\n};\n\nstatic int mlx5_devlink_max_uc_list_params_register(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tunion devlink_param_value value;\n\tint err;\n\n\tif (!MLX5_CAP_GEN_MAX(dev, log_max_current_uc_list_wr_supported))\n\t\treturn 0;\n\n\terr = devl_params_register(devlink, mlx5_devlink_max_uc_list_params,\n\t\t\t\t   ARRAY_SIZE(mlx5_devlink_max_uc_list_params));\n\tif (err)\n\t\treturn err;\n\n\tvalue.vu32 = 1 << MLX5_CAP_GEN(dev, log_max_current_uc_list);\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_MAX_MACS,\n\t\t\t\t\tvalue);\n\treturn 0;\n}\n\nstatic void\nmlx5_devlink_max_uc_list_params_unregister(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\n\tif (!MLX5_CAP_GEN_MAX(dev, log_max_current_uc_list_wr_supported))\n\t\treturn;\n\n\tdevl_params_unregister(devlink, mlx5_devlink_max_uc_list_params,\n\t\t\t       ARRAY_SIZE(mlx5_devlink_max_uc_list_params));\n}\n\n#define MLX5_TRAP_DROP(_id, _group_id)\t\t\t\t\t\\\n\tDEVLINK_TRAP_GENERIC(DROP, DROP, _id,\t\t\t\t\\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id, \\\n\t\t\t     DEVLINK_TRAP_METADATA_TYPE_F_IN_PORT)\n\nstatic const struct devlink_trap mlx5_traps_arr[] = {\n\tMLX5_TRAP_DROP(INGRESS_VLAN_FILTER, L2_DROPS),\n\tMLX5_TRAP_DROP(DMAC_FILTER, L2_DROPS),\n};\n\nstatic const struct devlink_trap_group mlx5_trap_groups_arr[] = {\n\tDEVLINK_TRAP_GROUP_GENERIC(L2_DROPS, 0),\n};\n\nint mlx5_devlink_traps_register(struct devlink *devlink)\n{\n\tstruct mlx5_core_dev *core_dev = devlink_priv(devlink);\n\tint err;\n\n\terr = devl_trap_groups_register(devlink, mlx5_trap_groups_arr,\n\t\t\t\t\tARRAY_SIZE(mlx5_trap_groups_arr));\n\tif (err)\n\t\treturn err;\n\n\terr = devl_traps_register(devlink, mlx5_traps_arr, ARRAY_SIZE(mlx5_traps_arr),\n\t\t\t\t  &core_dev->priv);\n\tif (err)\n\t\tgoto err_trap_group;\n\treturn 0;\n\nerr_trap_group:\n\tdevl_trap_groups_unregister(devlink, mlx5_trap_groups_arr,\n\t\t\t\t    ARRAY_SIZE(mlx5_trap_groups_arr));\n\treturn err;\n}\n\nvoid mlx5_devlink_traps_unregister(struct devlink *devlink)\n{\n\tdevl_traps_unregister(devlink, mlx5_traps_arr, ARRAY_SIZE(mlx5_traps_arr));\n\tdevl_trap_groups_unregister(devlink, mlx5_trap_groups_arr,\n\t\t\t\t    ARRAY_SIZE(mlx5_trap_groups_arr));\n}\n\nint mlx5_devlink_params_register(struct devlink *devlink)\n{\n\tint err;\n\n\t \n\n\terr = devl_params_register(devlink, mlx5_devlink_params,\n\t\t\t\t   ARRAY_SIZE(mlx5_devlink_params));\n\tif (err)\n\t\treturn err;\n\n\tmlx5_devlink_set_params_init_values(devlink);\n\n\terr = mlx5_devlink_auxdev_params_register(devlink);\n\tif (err)\n\t\tgoto auxdev_reg_err;\n\n\terr = mlx5_devlink_max_uc_list_params_register(devlink);\n\tif (err)\n\t\tgoto max_uc_list_err;\n\n\treturn 0;\n\nmax_uc_list_err:\n\tmlx5_devlink_auxdev_params_unregister(devlink);\nauxdev_reg_err:\n\tdevl_params_unregister(devlink, mlx5_devlink_params,\n\t\t\t       ARRAY_SIZE(mlx5_devlink_params));\n\treturn err;\n}\n\nvoid mlx5_devlink_params_unregister(struct devlink *devlink)\n{\n\tmlx5_devlink_max_uc_list_params_unregister(devlink);\n\tmlx5_devlink_auxdev_params_unregister(devlink);\n\tdevl_params_unregister(devlink, mlx5_devlink_params,\n\t\t\t       ARRAY_SIZE(mlx5_devlink_params));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}