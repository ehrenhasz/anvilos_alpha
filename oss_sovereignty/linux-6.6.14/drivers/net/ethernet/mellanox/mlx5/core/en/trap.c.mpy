{
  "module_name": "trap.c",
  "hash_id": "c383a84bd42253a92432b728050b769895d26accd6d47a3714b7c84ac624dc1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c",
  "human_readable_source": "\n \n\n#include \"en/txrx.h\"\n#include \"en/params.h\"\n#include \"en/trap.h\"\n\nstatic int mlx5e_trap_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct mlx5e_trap *trap_ctx = container_of(napi, struct mlx5e_trap, napi);\n\tstruct mlx5e_ch_stats *ch_stats = trap_ctx->stats;\n\tstruct mlx5e_rq *rq = &trap_ctx->rq;\n\tbool busy = false;\n\tint work_done = 0;\n\n\trcu_read_lock();\n\n\tch_stats->poll++;\n\n\twork_done = mlx5e_poll_rx_cq(&rq->cq, budget);\n\tbusy |= work_done == budget;\n\tbusy |= rq->post_wqes(rq);\n\n\tif (busy) {\n\t\twork_done = budget;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!napi_complete_done(napi, work_done)))\n\t\tgoto out;\n\n\tmlx5e_cq_arm(&rq->cq);\n\nout:\n\trcu_read_unlock();\n\treturn work_done;\n}\n\nstatic void mlx5e_init_trap_rq(struct mlx5e_trap *t, struct mlx5e_params *params,\n\t\t\t       struct mlx5e_rq *rq)\n{\n\tstruct mlx5_core_dev *mdev = t->mdev;\n\tstruct mlx5e_priv *priv = t->priv;\n\n\trq->wq_type      = params->rq_wq_type;\n\trq->pdev         = t->pdev;\n\trq->netdev       = priv->netdev;\n\trq->priv         = priv;\n\trq->clock        = &mdev->clock;\n\trq->tstamp       = &priv->tstamp;\n\trq->mdev         = mdev;\n\trq->hw_mtu       = MLX5E_SW2HW_MTU(params, params->sw_mtu);\n\trq->stats        = &priv->trap_stats.rq;\n\trq->ptp_cyc2time = mlx5_rq_ts_translator(mdev);\n\txdp_rxq_info_unused(&rq->xdp_rxq);\n\tmlx5e_rq_set_trap_handlers(rq, params);\n}\n\nstatic int mlx5e_open_trap_rq(struct mlx5e_priv *priv, struct mlx5e_trap *t)\n{\n\tstruct mlx5e_rq_param *rq_param = &t->rq_param;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_create_cq_param ccp = {};\n\tstruct dim_cq_moder trap_moder = {};\n\tstruct mlx5e_rq *rq = &t->rq;\n\tint node;\n\tint err;\n\n\tnode = dev_to_node(mdev->device);\n\n\tccp.node     = node;\n\tccp.ch_stats = t->stats;\n\tccp.napi     = &t->napi;\n\tccp.ix       = 0;\n\terr = mlx5e_open_cq(priv, trap_moder, &rq_param->cqp, &ccp, &rq->cq);\n\tif (err)\n\t\treturn err;\n\n\tmlx5e_init_trap_rq(t, &t->params, rq);\n\terr = mlx5e_open_rq(&t->params, rq_param, NULL, node, rq);\n\tif (err)\n\t\tgoto err_destroy_cq;\n\n\treturn 0;\n\nerr_destroy_cq:\n\tmlx5e_close_cq(&rq->cq);\n\n\treturn err;\n}\n\nstatic void mlx5e_close_trap_rq(struct mlx5e_rq *rq)\n{\n\tmlx5e_close_rq(rq);\n\tmlx5e_close_cq(&rq->cq);\n}\n\nstatic int mlx5e_create_trap_direct_rq_tir(struct mlx5_core_dev *mdev, struct mlx5e_tir *tir,\n\t\t\t\t\t   u32 rqn)\n{\n\tstruct mlx5e_tir_builder *builder;\n\tint err;\n\n\tbuilder = mlx5e_tir_builder_alloc(false);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\tmlx5e_tir_builder_build_inline(builder, mdev->mlx5e_res.hw_objs.td.tdn, rqn);\n\terr = mlx5e_tir_init(tir, builder, mdev, true);\n\n\tmlx5e_tir_builder_free(builder);\n\n\treturn err;\n}\n\nstatic void mlx5e_build_trap_params(struct mlx5_core_dev *mdev,\n\t\t\t\t    int max_mtu, u16 q_counter,\n\t\t\t\t    struct mlx5e_trap *t)\n{\n\tstruct mlx5e_params *params = &t->params;\n\n\tparams->rq_wq_type = MLX5_WQ_TYPE_CYCLIC;\n\tmlx5e_init_rq_type_params(mdev, params);\n\tparams->sw_mtu = max_mtu;\n\tmlx5e_build_rq_param(mdev, params, NULL, q_counter, &t->rq_param);\n}\n\nstatic struct mlx5e_trap *mlx5e_open_trap(struct mlx5e_priv *priv)\n{\n\tint cpu = mlx5_comp_vector_get_cpu(priv->mdev, 0);\n\tstruct net_device *netdev = priv->netdev;\n\tstruct mlx5e_trap *t;\n\tint err;\n\n\tt = kvzalloc_node(sizeof(*t), GFP_KERNEL, cpu_to_node(cpu));\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmlx5e_build_trap_params(priv->mdev, netdev->max_mtu, priv->q_counter, t);\n\n\tt->priv     = priv;\n\tt->mdev     = priv->mdev;\n\tt->tstamp   = &priv->tstamp;\n\tt->pdev     = mlx5_core_dma_dev(priv->mdev);\n\tt->netdev   = priv->netdev;\n\tt->mkey_be  = cpu_to_be32(priv->mdev->mlx5e_res.hw_objs.mkey);\n\tt->stats    = &priv->trap_stats.ch;\n\n\tnetif_napi_add(netdev, &t->napi, mlx5e_trap_napi_poll);\n\n\terr = mlx5e_open_trap_rq(priv, t);\n\tif (unlikely(err))\n\t\tgoto err_napi_del;\n\n\terr = mlx5e_create_trap_direct_rq_tir(t->mdev, &t->tir, t->rq.rqn);\n\tif (err)\n\t\tgoto err_close_trap_rq;\n\n\treturn t;\n\nerr_close_trap_rq:\n\tmlx5e_close_trap_rq(&t->rq);\nerr_napi_del:\n\tnetif_napi_del(&t->napi);\n\tkvfree(t);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5e_close_trap(struct mlx5e_trap *trap)\n{\n\tmlx5e_tir_destroy(&trap->tir);\n\tmlx5e_close_trap_rq(&trap->rq);\n\tnetif_napi_del(&trap->napi);\n\tkvfree(trap);\n}\n\nstatic void mlx5e_activate_trap(struct mlx5e_trap *trap)\n{\n\tnapi_enable(&trap->napi);\n\tmlx5e_activate_rq(&trap->rq);\n\tmlx5e_trigger_napi_sched(&trap->napi);\n}\n\nvoid mlx5e_deactivate_trap(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_trap *trap = priv->en_trap;\n\n\tmlx5e_deactivate_rq(&trap->rq);\n\tnapi_disable(&trap->napi);\n}\n\nstatic struct mlx5e_trap *mlx5e_add_trap_queue(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_trap *trap;\n\n\ttrap = mlx5e_open_trap(priv);\n\tif (IS_ERR(trap))\n\t\tgoto out;\n\n\tmlx5e_activate_trap(trap);\nout:\n\treturn trap;\n}\n\nstatic void mlx5e_del_trap_queue(struct mlx5e_priv *priv)\n{\n\tmlx5e_deactivate_trap(priv);\n\tmlx5e_close_trap(priv->en_trap);\n\tpriv->en_trap = NULL;\n}\n\nstatic int mlx5e_trap_get_tirn(struct mlx5e_trap *en_trap)\n{\n\treturn en_trap->tir.tirn;\n}\n\nstatic int mlx5e_handle_action_trap(struct mlx5e_priv *priv, int trap_id)\n{\n\tbool open_queue = !priv->en_trap;\n\tstruct mlx5e_trap *trap;\n\tint err;\n\n\tif (open_queue) {\n\t\ttrap = mlx5e_add_trap_queue(priv);\n\t\tif (IS_ERR(trap))\n\t\t\treturn PTR_ERR(trap);\n\t\tpriv->en_trap = trap;\n\t}\n\n\tswitch (trap_id) {\n\tcase DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER:\n\t\terr = mlx5e_add_vlan_trap(priv->fs, trap_id, mlx5e_trap_get_tirn(priv->en_trap));\n\t\tif (err)\n\t\t\tgoto err_out;\n\t\tbreak;\n\tcase DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER:\n\t\terr = mlx5e_add_mac_trap(priv->fs, trap_id, mlx5e_trap_get_tirn(priv->en_trap));\n\t\tif (err)\n\t\t\tgoto err_out;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(priv->netdev, \"%s: Unknown trap id %d\\n\", __func__, trap_id);\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\treturn 0;\n\nerr_out:\n\tif (open_queue)\n\t\tmlx5e_del_trap_queue(priv);\n\treturn err;\n}\n\nstatic int mlx5e_handle_action_drop(struct mlx5e_priv *priv, int trap_id)\n{\n\tswitch (trap_id) {\n\tcase DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER:\n\t\tmlx5e_remove_vlan_trap(priv->fs);\n\t\tbreak;\n\tcase DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER:\n\t\tmlx5e_remove_mac_trap(priv->fs);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(priv->netdev, \"%s: Unknown trap id %d\\n\", __func__, trap_id);\n\t\treturn -EINVAL;\n\t}\n\tif (priv->en_trap && !mlx5_devlink_trap_get_num_active(priv->mdev))\n\t\tmlx5e_del_trap_queue(priv);\n\n\treturn 0;\n}\n\nint mlx5e_handle_trap_event(struct mlx5e_priv *priv, struct mlx5_trap_ctx *trap_ctx)\n{\n\tint err = 0;\n\n\t \n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state))\n\t\treturn 0;\n\n\tswitch (trap_ctx->action) {\n\tcase DEVLINK_TRAP_ACTION_TRAP:\n\t\terr = mlx5e_handle_action_trap(priv, trap_ctx->id);\n\t\tbreak;\n\tcase DEVLINK_TRAP_ACTION_DROP:\n\t\terr = mlx5e_handle_action_drop(priv, trap_ctx->id);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(priv->netdev, \"%s: Unsupported action %d\\n\", __func__,\n\t\t\t    trap_ctx->action);\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int mlx5e_apply_trap(struct mlx5e_priv *priv, int trap_id, bool enable)\n{\n\tenum devlink_trap_action action;\n\tint err;\n\n\terr = mlx5_devlink_traps_get_action(priv->mdev, trap_id, &action);\n\tif (err)\n\t\treturn err;\n\tif (action == DEVLINK_TRAP_ACTION_TRAP)\n\t\terr = enable ? mlx5e_handle_action_trap(priv, trap_id) :\n\t\t\t       mlx5e_handle_action_drop(priv, trap_id);\n\treturn err;\n}\n\nstatic const int mlx5e_traps_arr[] = {\n\tDEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER,\n\tDEVLINK_TRAP_GENERIC_ID_DMAC_FILTER,\n};\n\nint mlx5e_apply_traps(struct mlx5e_priv *priv, bool enable)\n{\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlx5e_traps_arr); i++) {\n\t\terr = mlx5e_apply_trap(priv, mlx5e_traps_arr[i], enable);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}