{
  "module_name": "dm.c",
  "hash_id": "1c95ce4fe68ddae4ff3016d6e6de920b54afbe7b20e5bc427ac3c8252c2b4305",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/dm.c",
  "human_readable_source": "\n\n\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/device.h>\n\n#include \"mlx5_core.h\"\n#include \"lib/mlx5.h\"\n\nstruct mlx5_dm {\n\t \n\tspinlock_t lock;\n\tunsigned long *steering_sw_icm_alloc_blocks;\n\tunsigned long *header_modify_sw_icm_alloc_blocks;\n\tunsigned long *header_modify_pattern_sw_icm_alloc_blocks;\n};\n\nstruct mlx5_dm *mlx5_dm_create(struct mlx5_core_dev *dev)\n{\n\tu64 header_modify_pattern_icm_blocks = 0;\n\tu64 header_modify_icm_blocks = 0;\n\tu64 steering_icm_blocks = 0;\n\tstruct mlx5_dm *dm;\n\tbool support_v2;\n\n\tif (!(MLX5_CAP_GEN_64(dev, general_obj_types) & MLX5_GENERAL_OBJ_TYPES_CAP_SW_ICM))\n\t\treturn NULL;\n\n\tdm = kzalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&dm->lock);\n\n\tif (MLX5_CAP64_DEV_MEM(dev, steering_sw_icm_start_address)) {\n\t\tsteering_icm_blocks =\n\t\t\tBIT(MLX5_CAP_DEV_MEM(dev, log_steering_sw_icm_size) -\n\t\t\t    MLX5_LOG_SW_ICM_BLOCK_SIZE(dev));\n\n\t\tdm->steering_sw_icm_alloc_blocks =\n\t\t\tbitmap_zalloc(steering_icm_blocks, GFP_KERNEL);\n\t\tif (!dm->steering_sw_icm_alloc_blocks)\n\t\t\tgoto err_steering;\n\t}\n\n\tif (MLX5_CAP64_DEV_MEM(dev, header_modify_sw_icm_start_address)) {\n\t\theader_modify_icm_blocks =\n\t\t\tBIT(MLX5_CAP_DEV_MEM(dev, log_header_modify_sw_icm_size) -\n\t\t\t    MLX5_LOG_SW_ICM_BLOCK_SIZE(dev));\n\n\t\tdm->header_modify_sw_icm_alloc_blocks =\n\t\t\tbitmap_zalloc(header_modify_icm_blocks, GFP_KERNEL);\n\t\tif (!dm->header_modify_sw_icm_alloc_blocks)\n\t\t\tgoto err_modify_hdr;\n\t}\n\n\tsupport_v2 = MLX5_CAP_FLOWTABLE_NIC_RX(dev, sw_owner_v2) &&\n\t\t     MLX5_CAP_FLOWTABLE_NIC_TX(dev, sw_owner_v2) &&\n\t\t     MLX5_CAP64_DEV_MEM(dev, header_modify_pattern_sw_icm_start_address);\n\n\tif (support_v2) {\n\t\theader_modify_pattern_icm_blocks =\n\t\t\tBIT(MLX5_CAP_DEV_MEM(dev, log_header_modify_pattern_sw_icm_size) -\n\t\t\t    MLX5_LOG_SW_ICM_BLOCK_SIZE(dev));\n\n\t\tdm->header_modify_pattern_sw_icm_alloc_blocks =\n\t\t\tbitmap_zalloc(header_modify_pattern_icm_blocks, GFP_KERNEL);\n\t\tif (!dm->header_modify_pattern_sw_icm_alloc_blocks)\n\t\t\tgoto err_pattern;\n\t}\n\n\treturn dm;\n\nerr_pattern:\n\tbitmap_free(dm->header_modify_sw_icm_alloc_blocks);\n\nerr_modify_hdr:\n\tbitmap_free(dm->steering_sw_icm_alloc_blocks);\n\nerr_steering:\n\tkfree(dm);\n\n\treturn ERR_PTR(-ENOMEM);\n}\n\nvoid mlx5_dm_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_dm *dm = dev->dm;\n\n\tif (!dev->dm)\n\t\treturn;\n\n\tif (dm->steering_sw_icm_alloc_blocks) {\n\t\tWARN_ON(!bitmap_empty(dm->steering_sw_icm_alloc_blocks,\n\t\t\t\t      BIT(MLX5_CAP_DEV_MEM(dev, log_steering_sw_icm_size) -\n\t\t\t\t\t  MLX5_LOG_SW_ICM_BLOCK_SIZE(dev))));\n\t\tbitmap_free(dm->steering_sw_icm_alloc_blocks);\n\t}\n\n\tif (dm->header_modify_sw_icm_alloc_blocks) {\n\t\tWARN_ON(!bitmap_empty(dm->header_modify_sw_icm_alloc_blocks,\n\t\t\t\t      BIT(MLX5_CAP_DEV_MEM(dev,\n\t\t\t\t\t\t\t   log_header_modify_sw_icm_size) -\n\t\t\t\t      MLX5_LOG_SW_ICM_BLOCK_SIZE(dev))));\n\t\tbitmap_free(dm->header_modify_sw_icm_alloc_blocks);\n\t}\n\n\tif (dm->header_modify_pattern_sw_icm_alloc_blocks) {\n\t\tWARN_ON(!bitmap_empty(dm->header_modify_pattern_sw_icm_alloc_blocks,\n\t\t\t\t      BIT(MLX5_CAP_DEV_MEM(dev,\n\t\t\t\t\t\t\t   log_header_modify_pattern_sw_icm_size) -\n\t\t\t\t\t  MLX5_LOG_SW_ICM_BLOCK_SIZE(dev))));\n\t\tbitmap_free(dm->header_modify_pattern_sw_icm_alloc_blocks);\n\t}\n\n\tkfree(dm);\n}\n\nint mlx5_dm_sw_icm_alloc(struct mlx5_core_dev *dev, enum mlx5_sw_icm_type type,\n\t\t\t u64 length, u32 log_alignment, u16 uid,\n\t\t\t phys_addr_t *addr, u32 *obj_id)\n{\n\tu32 num_blocks = DIV_ROUND_UP_ULL(length, MLX5_SW_ICM_BLOCK_SIZE(dev));\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {};\n\tu32 in[MLX5_ST_SZ_DW(create_sw_icm_in)] = {};\n\tstruct mlx5_dm *dm = dev->dm;\n\tunsigned long *block_map;\n\tu64 icm_start_addr;\n\tu32 log_icm_size;\n\tu64 align_mask;\n\tu32 max_blocks;\n\tu64 block_idx;\n\tvoid *sw_icm;\n\tint ret;\n\n\tif (!dev->dm)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!length || (length & (length - 1)) ||\n\t    length & (MLX5_SW_ICM_BLOCK_SIZE(dev) - 1))\n\t\treturn -EINVAL;\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_OBJ_TYPE_SW_ICM);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, uid, uid);\n\n\tswitch (type) {\n\tcase MLX5_SW_ICM_TYPE_STEERING:\n\t\ticm_start_addr = MLX5_CAP64_DEV_MEM(dev, steering_sw_icm_start_address);\n\t\tlog_icm_size = MLX5_CAP_DEV_MEM(dev, log_steering_sw_icm_size);\n\t\tblock_map = dm->steering_sw_icm_alloc_blocks;\n\t\tbreak;\n\tcase MLX5_SW_ICM_TYPE_HEADER_MODIFY:\n\t\ticm_start_addr = MLX5_CAP64_DEV_MEM(dev, header_modify_sw_icm_start_address);\n\t\tlog_icm_size = MLX5_CAP_DEV_MEM(dev,\n\t\t\t\t\t\tlog_header_modify_sw_icm_size);\n\t\tblock_map = dm->header_modify_sw_icm_alloc_blocks;\n\t\tbreak;\n\tcase MLX5_SW_ICM_TYPE_HEADER_MODIFY_PATTERN:\n\t\ticm_start_addr = MLX5_CAP64_DEV_MEM(dev,\n\t\t\t\t\t\t    header_modify_pattern_sw_icm_start_address);\n\t\tlog_icm_size = MLX5_CAP_DEV_MEM(dev,\n\t\t\t\t\t\tlog_header_modify_pattern_sw_icm_size);\n\t\tblock_map = dm->header_modify_pattern_sw_icm_alloc_blocks;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!block_map)\n\t\treturn -EOPNOTSUPP;\n\n\tmax_blocks = BIT(log_icm_size - MLX5_LOG_SW_ICM_BLOCK_SIZE(dev));\n\n\tif (log_alignment < MLX5_LOG_SW_ICM_BLOCK_SIZE(dev))\n\t\tlog_alignment = MLX5_LOG_SW_ICM_BLOCK_SIZE(dev);\n\talign_mask = BIT(log_alignment - MLX5_LOG_SW_ICM_BLOCK_SIZE(dev)) - 1;\n\n\tspin_lock(&dm->lock);\n\tblock_idx = bitmap_find_next_zero_area(block_map, max_blocks, 0,\n\t\t\t\t\t       num_blocks, align_mask);\n\n\tif (block_idx < max_blocks)\n\t\tbitmap_set(block_map,\n\t\t\t   block_idx, num_blocks);\n\n\tspin_unlock(&dm->lock);\n\n\tif (block_idx >= max_blocks)\n\t\treturn -ENOMEM;\n\n\tsw_icm = MLX5_ADDR_OF(create_sw_icm_in, in, sw_icm);\n\ticm_start_addr += block_idx << MLX5_LOG_SW_ICM_BLOCK_SIZE(dev);\n\tMLX5_SET64(sw_icm, sw_icm, sw_icm_start_addr,\n\t\t   icm_start_addr);\n\tMLX5_SET(sw_icm, sw_icm, log_sw_icm_size, ilog2(length));\n\n\tret = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\n\tif (ret) {\n\t\tspin_lock(&dm->lock);\n\t\tbitmap_clear(block_map,\n\t\t\t     block_idx, num_blocks);\n\t\tspin_unlock(&dm->lock);\n\n\t\treturn ret;\n\t}\n\n\t*addr = icm_start_addr;\n\t*obj_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_dm_sw_icm_alloc);\n\nint mlx5_dm_sw_icm_dealloc(struct mlx5_core_dev *dev, enum mlx5_sw_icm_type type,\n\t\t\t   u64 length, u16 uid, phys_addr_t addr, u32 obj_id)\n{\n\tu32 num_blocks = DIV_ROUND_UP_ULL(length, MLX5_SW_ICM_BLOCK_SIZE(dev));\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {};\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tstruct mlx5_dm *dm = dev->dm;\n\tunsigned long *block_map;\n\tu64 icm_start_addr;\n\tu64 start_idx;\n\tint err;\n\n\tif (!dev->dm)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase MLX5_SW_ICM_TYPE_STEERING:\n\t\ticm_start_addr = MLX5_CAP64_DEV_MEM(dev, steering_sw_icm_start_address);\n\t\tblock_map = dm->steering_sw_icm_alloc_blocks;\n\t\tbreak;\n\tcase MLX5_SW_ICM_TYPE_HEADER_MODIFY:\n\t\ticm_start_addr = MLX5_CAP64_DEV_MEM(dev, header_modify_sw_icm_start_address);\n\t\tblock_map = dm->header_modify_sw_icm_alloc_blocks;\n\t\tbreak;\n\tcase MLX5_SW_ICM_TYPE_HEADER_MODIFY_PATTERN:\n\t\ticm_start_addr = MLX5_CAP64_DEV_MEM(dev,\n\t\t\t\t\t\t    header_modify_pattern_sw_icm_start_address);\n\t\tblock_map = dm->header_modify_pattern_sw_icm_alloc_blocks;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_OBJ_TYPE_SW_ICM);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, obj_id);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, uid, uid);\n\n\terr =  mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tstart_idx = (addr - icm_start_addr) >> MLX5_LOG_SW_ICM_BLOCK_SIZE(dev);\n\tspin_lock(&dm->lock);\n\tbitmap_clear(block_map,\n\t\t     start_idx, num_blocks);\n\tspin_unlock(&dm->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_dm_sw_icm_dealloc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}