{
  "module_name": "aso.c",
  "hash_id": "3f5c62a201677de37a98cf4e3f63866a2f57c908072b49e9b99cf72a2a325be0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/aso.c",
  "human_readable_source": "\n\n\n#include <linux/mlx5/device.h>\n#include <linux/mlx5/transobj.h>\n#include \"clock.h\"\n#include \"aso.h\"\n#include \"wq.h\"\n\nstruct mlx5_aso_cq {\n\t \n\tstruct mlx5_cqwq           wq;\n\n\t \n\tstruct mlx5_core_cq        mcq;\n\n\t \n\tstruct mlx5_core_dev      *mdev;\n\tstruct mlx5_wq_ctrl        wq_ctrl;\n} ____cacheline_aligned_in_smp;\n\nstruct mlx5_aso {\n\t \n\tu16                        cc;\n\tu16                        pc;\n\n\tstruct mlx5_wqe_ctrl_seg  *doorbell_cseg;\n\tstruct mlx5_aso_cq         cq;\n\n\t \n\tstruct mlx5_wq_cyc         wq;\n\tvoid __iomem              *uar_map;\n\tu32                        sqn;\n\n\t \n\tstruct mlx5_wq_ctrl        wq_ctrl;\n\n} ____cacheline_aligned_in_smp;\n\nstatic void mlx5_aso_free_cq(struct mlx5_aso_cq *cq)\n{\n\tmlx5_wq_destroy(&cq->wq_ctrl);\n}\n\nstatic int mlx5_aso_alloc_cq(struct mlx5_core_dev *mdev, int numa_node,\n\t\t\t     void *cqc_data, struct mlx5_aso_cq *cq)\n{\n\tstruct mlx5_core_cq *mcq = &cq->mcq;\n\tstruct mlx5_wq_param param;\n\tint err;\n\tu32 i;\n\n\tparam.buf_numa_node = numa_node;\n\tparam.db_numa_node = numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &param, cqc_data, &cq->wq, &cq->wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tmcq->cqe_sz     = 64;\n\tmcq->set_ci_db  = cq->wq_ctrl.db.db;\n\tmcq->arm_db     = cq->wq_ctrl.db.db + 1;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&cq->wq); i++) {\n\t\tstruct mlx5_cqe64 *cqe = mlx5_cqwq_get_wqe(&cq->wq, i);\n\n\t\tcqe->op_own = 0xf1;\n\t}\n\n\tcq->mdev = mdev;\n\n\treturn 0;\n}\n\nstatic int create_aso_cq(struct mlx5_aso_cq *cq, void *cqc_data)\n{\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_core_dev *mdev = cq->mdev;\n\tstruct mlx5_core_cq *mcq = &cq->mcq;\n\tvoid *in, *cqc;\n\tint inlen, eqn;\n\tint err;\n\n\terr = mlx5_comp_eqn_get(mdev, 0, &eqn);\n\tif (err)\n\t\treturn err;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * cq->wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\n\tmemcpy(cqc, cqc_data, MLX5_ST_SZ_BYTES(cqc));\n\n\tmlx5_fill_page_frag_array(&cq->wq_ctrl.buf,\n\t\t\t\t  (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas));\n\n\tMLX5_SET(cqc,   cqc, cq_period_mode, DIM_CQ_PERIOD_MODE_START_FROM_EQE);\n\tMLX5_SET(cqc,   cqc, c_eqn_or_apu_element, eqn);\n\tMLX5_SET(cqc,   cqc, uar_page,      mdev->priv.uar->index);\n\tMLX5_SET(cqc,   cqc, log_page_size, cq->wq_ctrl.buf.page_shift -\n\t\t\t\t\t    MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr,      cq->wq_ctrl.db.dma);\n\n\terr = mlx5_core_create_cq(mdev, mcq, in, inlen, out, sizeof(out));\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void mlx5_aso_destroy_cq(struct mlx5_aso_cq *cq)\n{\n\tmlx5_core_destroy_cq(cq->mdev, &cq->mcq);\n\tmlx5_wq_destroy(&cq->wq_ctrl);\n}\n\nstatic int mlx5_aso_create_cq(struct mlx5_core_dev *mdev, int numa_node,\n\t\t\t      struct mlx5_aso_cq *cq)\n{\n\tvoid *cqc_data;\n\tint err;\n\n\tcqc_data = kvzalloc(MLX5_ST_SZ_BYTES(cqc), GFP_KERNEL);\n\tif (!cqc_data)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(cqc, cqc_data, log_cq_size, 1);\n\tMLX5_SET(cqc, cqc_data, uar_page, mdev->priv.uar->index);\n\tif (MLX5_CAP_GEN(mdev, cqe_128_always) && cache_line_size() >= 128)\n\t\tMLX5_SET(cqc, cqc_data, cqe_sz, CQE_STRIDE_128_PAD);\n\n\terr = mlx5_aso_alloc_cq(mdev, numa_node, cqc_data, cq);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Failed to alloc aso wq cq, err=%d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\terr = create_aso_cq(cq, cqc_data);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Failed to create aso wq cq, err=%d\\n\", err);\n\t\tgoto err_free_cq;\n\t}\n\n\tkvfree(cqc_data);\n\treturn 0;\n\nerr_free_cq:\n\tmlx5_aso_free_cq(cq);\nerr_out:\n\tkvfree(cqc_data);\n\treturn err;\n}\n\nstatic int mlx5_aso_alloc_sq(struct mlx5_core_dev *mdev, int numa_node,\n\t\t\t     void *sqc_data, struct mlx5_aso *sq)\n{\n\tvoid *sqc_wq = MLX5_ADDR_OF(sqc, sqc_data, wq);\n\tstruct mlx5_wq_cyc *wq = &sq->wq;\n\tstruct mlx5_wq_param param;\n\tint err;\n\n\tsq->uar_map = mdev->mlx5e_res.hw_objs.bfreg.map;\n\n\tparam.db_numa_node = numa_node;\n\tparam.buf_numa_node = numa_node;\n\terr = mlx5_wq_cyc_create(mdev, &param, sqc_wq, wq, &sq->wq_ctrl);\n\tif (err)\n\t\treturn err;\n\twq->db = &wq->db[MLX5_SND_DBR];\n\n\treturn 0;\n}\n\nstatic int create_aso_sq(struct mlx5_core_dev *mdev, int pdn,\n\t\t\t void *sqc_data, struct mlx5_aso *sq)\n{\n\tvoid *in, *sqc, *wq;\n\tint inlen, err;\n\tu8 ts_format;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) +\n\t\tsizeof(u64) * sq->wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmemcpy(sqc, sqc_data, MLX5_ST_SZ_BYTES(sqc));\n\tMLX5_SET(sqc,  sqc, cqn, sq->cq.mcq.cqn);\n\n\tMLX5_SET(sqc,  sqc, state, MLX5_SQC_STATE_RST);\n\tMLX5_SET(sqc,  sqc, flush_in_error_en, 1);\n\n\tts_format = mlx5_is_real_time_sq(mdev) ?\n\t\t\tMLX5_TIMESTAMP_FORMAT_REAL_TIME :\n\t\t\tMLX5_TIMESTAMP_FORMAT_FREE_RUNNING;\n\tMLX5_SET(sqc, sqc, ts_format, ts_format);\n\n\tMLX5_SET(wq,   wq, wq_type,       MLX5_WQ_TYPE_CYCLIC);\n\tMLX5_SET(wq,   wq, uar_page,      mdev->mlx5e_res.hw_objs.bfreg.index);\n\tMLX5_SET(wq,   wq, log_wq_pg_sz,  sq->wq_ctrl.buf.page_shift -\n\t\t\t\t\t  MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(wq, wq, dbr_addr,      sq->wq_ctrl.db.dma);\n\n\tmlx5_fill_page_frag_array(&sq->wq_ctrl.buf,\n\t\t\t\t  (__be64 *)MLX5_ADDR_OF(wq, wq, pas));\n\n\terr = mlx5_core_create_sq(mdev, in, inlen, &sq->sqn);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int mlx5_aso_set_sq_rdy(struct mlx5_core_dev *mdev, u32 sqn)\n{\n\tvoid *in, *sqc;\n\tint inlen, err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_sq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_sq_in, in, sq_state, MLX5_SQC_STATE_RST);\n\tsqc = MLX5_ADDR_OF(modify_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RDY);\n\n\terr = mlx5_core_modify_sq(mdev, sqn, in);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int mlx5_aso_create_sq_rdy(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t  void *sqc_data, struct mlx5_aso *sq)\n{\n\tint err;\n\n\terr = create_aso_sq(mdev, pdn, sqc_data, sq);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_aso_set_sq_rdy(mdev, sq->sqn);\n\tif (err)\n\t\tmlx5_core_destroy_sq(mdev, sq->sqn);\n\n\treturn err;\n}\n\nstatic void mlx5_aso_free_sq(struct mlx5_aso *sq)\n{\n\tmlx5_wq_destroy(&sq->wq_ctrl);\n}\n\nstatic void mlx5_aso_destroy_sq(struct mlx5_aso *sq)\n{\n\tmlx5_core_destroy_sq(sq->cq.mdev, sq->sqn);\n\tmlx5_aso_free_sq(sq);\n}\n\nstatic int mlx5_aso_create_sq(struct mlx5_core_dev *mdev, int numa_node,\n\t\t\t      u32 pdn, struct mlx5_aso *sq)\n{\n\tvoid *sqc_data, *wq;\n\tint err;\n\n\tsqc_data = kvzalloc(MLX5_ST_SZ_BYTES(sqc), GFP_KERNEL);\n\tif (!sqc_data)\n\t\treturn -ENOMEM;\n\n\twq = MLX5_ADDR_OF(sqc, sqc_data, wq);\n\tMLX5_SET(wq, wq, log_wq_stride, ilog2(MLX5_SEND_WQE_BB));\n\tMLX5_SET(wq, wq, pd, pdn);\n\tMLX5_SET(wq, wq, log_wq_sz, 1);\n\n\terr = mlx5_aso_alloc_sq(mdev, numa_node, sqc_data, sq);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Failed to alloc aso wq sq, err=%d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\terr = mlx5_aso_create_sq_rdy(mdev, pdn, sqc_data, sq);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Failed to open aso wq sq, err=%d\\n\", err);\n\t\tgoto err_free_asosq;\n\t}\n\n\tmlx5_core_dbg(mdev, \"aso sq->sqn = 0x%x\\n\", sq->sqn);\n\n\tkvfree(sqc_data);\n\treturn 0;\n\nerr_free_asosq:\n\tmlx5_aso_free_sq(sq);\nerr_out:\n\tkvfree(sqc_data);\n\treturn err;\n}\n\nstruct mlx5_aso *mlx5_aso_create(struct mlx5_core_dev *mdev, u32 pdn)\n{\n\tint numa_node = dev_to_node(mlx5_core_dma_dev(mdev));\n\tstruct mlx5_aso *aso;\n\tint err;\n\n\taso = kzalloc(sizeof(*aso), GFP_KERNEL);\n\tif (!aso)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlx5_aso_create_cq(mdev, numa_node, &aso->cq);\n\tif (err)\n\t\tgoto err_cq;\n\n\terr = mlx5_aso_create_sq(mdev, numa_node, pdn, aso);\n\tif (err)\n\t\tgoto err_sq;\n\n\treturn aso;\n\nerr_sq:\n\tmlx5_aso_destroy_cq(&aso->cq);\nerr_cq:\n\tkfree(aso);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5_aso_destroy(struct mlx5_aso *aso)\n{\n\tmlx5_aso_destroy_sq(aso);\n\tmlx5_aso_destroy_cq(&aso->cq);\n\tkfree(aso);\n}\n\nvoid mlx5_aso_build_wqe(struct mlx5_aso *aso, u8 ds_cnt,\n\t\t\tstruct mlx5_aso_wqe *aso_wqe,\n\t\t\tu32 obj_id, u32 opc_mode)\n{\n\tstruct mlx5_wqe_ctrl_seg *cseg = &aso_wqe->ctrl;\n\n\tcseg->opmod_idx_opcode = cpu_to_be32((opc_mode << MLX5_WQE_CTRL_WQE_OPC_MOD_SHIFT) |\n\t\t\t\t\t     (aso->pc << MLX5_WQE_CTRL_WQE_INDEX_SHIFT) |\n\t\t\t\t\t     MLX5_OPCODE_ACCESS_ASO);\n\tcseg->qpn_ds     = cpu_to_be32((aso->sqn << MLX5_WQE_CTRL_QPN_SHIFT) | ds_cnt);\n\tcseg->fm_ce_se   = MLX5_WQE_CTRL_CQ_UPDATE;\n\tcseg->general_id = cpu_to_be32(obj_id);\n}\n\nstruct mlx5_aso_wqe *mlx5_aso_get_wqe(struct mlx5_aso *aso)\n{\n\tstruct mlx5_aso_wqe *wqe;\n\tu16 pi;\n\n\tpi = mlx5_wq_cyc_ctr2ix(&aso->wq, aso->pc);\n\twqe = mlx5_wq_cyc_get_wqe(&aso->wq, pi);\n\tmemset(wqe, 0, sizeof(*wqe));\n\treturn wqe;\n}\n\nvoid mlx5_aso_post_wqe(struct mlx5_aso *aso, bool with_data,\n\t\t       struct mlx5_wqe_ctrl_seg *doorbell_cseg)\n{\n\tdoorbell_cseg->fm_ce_se |= MLX5_WQE_CTRL_CQ_UPDATE;\n\t \n\tdma_wmb();\n\n\tif (with_data)\n\t\taso->pc += MLX5_ASO_WQEBBS_DATA;\n\telse\n\t\taso->pc += MLX5_ASO_WQEBBS;\n\t*aso->wq.db = cpu_to_be32(aso->pc);\n\n\t \n\twmb();\n\n\tmlx5_write64((__be32 *)doorbell_cseg, aso->uar_map);\n\n\t \n\tWRITE_ONCE(doorbell_cseg, NULL);\n}\n\nint mlx5_aso_poll_cq(struct mlx5_aso *aso, bool with_data)\n{\n\tstruct mlx5_aso_cq *cq = &aso->cq;\n\tstruct mlx5_cqe64 *cqe;\n\n\tcqe = mlx5_cqwq_get_cqe(&cq->wq);\n\tif (!cqe)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tmlx5_cqwq_pop(&cq->wq);\n\n\tif (unlikely(get_cqe_opcode(cqe) != MLX5_CQE_REQ)) {\n\t\tstruct mlx5_err_cqe *err_cqe;\n\n\t\tmlx5_core_err(cq->mdev, \"Bad OP in ASOSQ CQE: 0x%x\\n\",\n\t\t\t      get_cqe_opcode(cqe));\n\n\t\terr_cqe = (struct mlx5_err_cqe *)cqe;\n\t\tmlx5_core_err(cq->mdev, \"vendor_err_synd=%x\\n\",\n\t\t\t      err_cqe->vendor_err_synd);\n\t\tmlx5_core_err(cq->mdev, \"syndrome=%x\\n\",\n\t\t\t      err_cqe->syndrome);\n\t\tprint_hex_dump(KERN_WARNING, \"\", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, err_cqe,\n\t\t\t       sizeof(*err_cqe), false);\n\t}\n\n\tmlx5_cqwq_update_db_record(&cq->wq);\n\n\t \n\twmb();\n\n\tif (with_data)\n\t\taso->cc += MLX5_ASO_WQEBBS_DATA;\n\telse\n\t\taso->cc += MLX5_ASO_WQEBBS;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}