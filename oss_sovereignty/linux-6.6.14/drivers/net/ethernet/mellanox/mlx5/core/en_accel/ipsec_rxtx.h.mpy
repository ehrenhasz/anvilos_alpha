{
  "module_name": "ipsec_rxtx.h",
  "hash_id": "d7c4d28ba78a07bd353e239cd62387f2f934da0ed27bf6aa027e6189233c89a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.h",
  "human_readable_source": " \n\n#ifndef __MLX5E_IPSEC_RXTX_H__\n#define __MLX5E_IPSEC_RXTX_H__\n\n#include <linux/skbuff.h>\n#include <net/xfrm.h>\n#include \"en.h\"\n#include \"en/txrx.h\"\n\n \n#define MLX5_IPSEC_METADATA_MARKER(metadata)  (((metadata) >> 31) & 0x1)\n#define MLX5_IPSEC_METADATA_SYNDROM(metadata) (((metadata) >> 24) & GENMASK(5, 0))\n#define MLX5_IPSEC_METADATA_HANDLE(metadata)  ((metadata) & GENMASK(23, 0))\n#define MLX5_IPSEC_METADATA_CREATE(id, syndrome) ((id) | ((syndrome) << 24))\n\nstruct mlx5e_accel_tx_ipsec_state {\n\tstruct xfrm_offload *xo;\n\tstruct xfrm_state *x;\n\tu32 tailen;\n\tu32 plen;\n};\n\n#ifdef CONFIG_MLX5_EN_IPSEC\n\nvoid mlx5e_ipsec_inverse_table_init(void);\nvoid mlx5e_ipsec_set_iv_esn(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t    struct xfrm_offload *xo);\nvoid mlx5e_ipsec_set_iv(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\tstruct xfrm_offload *xo);\nbool mlx5e_ipsec_handle_tx_skb(struct net_device *netdev,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct mlx5e_accel_tx_ipsec_state *ipsec_st);\nvoid mlx5e_ipsec_handle_tx_wqe(struct mlx5e_tx_wqe *wqe,\n\t\t\t       struct mlx5e_accel_tx_ipsec_state *ipsec_st,\n\t\t\t       struct mlx5_wqe_inline_seg *inlseg);\nvoid mlx5e_ipsec_offload_handle_rx_skb(struct net_device *netdev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       u32 ipsec_meta_data);\nint mlx5_esw_ipsec_rx_make_metadata(struct mlx5e_priv *priv, u32 id, u32 *metadata);\nstatic inline unsigned int mlx5e_ipsec_tx_ids_len(struct mlx5e_accel_tx_ipsec_state *ipsec_st)\n{\n\treturn ipsec_st->tailen;\n}\n\nstatic inline bool mlx5_ipsec_is_rx_flow(struct mlx5_cqe64 *cqe)\n{\n\treturn MLX5_IPSEC_METADATA_MARKER(be32_to_cpu(cqe->ft_metadata));\n}\n\nstatic inline bool mlx5e_ipsec_eseg_meta(struct mlx5_wqe_eth_seg *eseg)\n{\n\treturn eseg->flow_table_metadata & cpu_to_be32(MLX5_ETH_WQE_FT_META_IPSEC);\n}\n\nvoid mlx5e_ipsec_tx_build_eseg(struct mlx5e_priv *priv, struct sk_buff *skb,\n\t\t\t       struct mlx5_wqe_eth_seg *eseg);\n\nstatic inline netdev_features_t\nmlx5e_ipsec_feature_check(struct sk_buff *skb, netdev_features_t features)\n{\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct sec_path *sp = skb_sec_path(skb);\n\n\tif (sp && sp->len && xo) {\n\t\tstruct xfrm_state *x = sp->xvec[0];\n\n\t\tif (!x || !x->xso.offload_handle)\n\t\t\tgoto out_disable;\n\n\t\tif (xo->inner_ipproto) {\n\t\t\t \n\t\t\tif (x->props.mode == XFRM_MODE_TUNNEL)\n\t\t\t\tgoto out_disable;\n\n\t\t\t \n\t\t\tif (xo->inner_ipproto != IPPROTO_UDP &&\n\t\t\t    xo->inner_ipproto != IPPROTO_TCP)\n\t\t\t\tgoto out_disable;\n\t\t}\n\n\t\treturn features;\n\n\t}\n\n\t \nout_disable:\n\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n}\n\nstatic inline bool\nmlx5e_ipsec_txwqe_build_eseg_csum(struct mlx5e_txqsq *sq, struct sk_buff *skb,\n\t\t\t\t  struct mlx5_wqe_eth_seg *eseg)\n{\n\tu8 inner_ipproto;\n\n\tif (!mlx5e_ipsec_eseg_meta(eseg))\n\t\treturn false;\n\n\teseg->cs_flags = MLX5_ETH_WQE_L3_CSUM;\n\tinner_ipproto = xfrm_offload(skb)->inner_ipproto;\n\tif (inner_ipproto) {\n\t\teseg->cs_flags |= MLX5_ETH_WQE_L3_INNER_CSUM;\n\t\tif (inner_ipproto == IPPROTO_TCP || inner_ipproto == IPPROTO_UDP)\n\t\t\teseg->cs_flags |= MLX5_ETH_WQE_L4_INNER_CSUM;\n\t} else if (likely(skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\teseg->cs_flags |= MLX5_ETH_WQE_L4_CSUM;\n\t\tsq->stats->csum_partial_inner++;\n\t}\n\n\treturn true;\n}\n#else\nstatic inline\nvoid mlx5e_ipsec_offload_handle_rx_skb(struct net_device *netdev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       u32 ipsec_meta_data)\n{}\n\nstatic inline bool mlx5e_ipsec_eseg_meta(struct mlx5_wqe_eth_seg *eseg)\n{\n\treturn false;\n}\n\nstatic inline bool mlx5_ipsec_is_rx_flow(struct mlx5_cqe64 *cqe) { return false; }\nstatic inline netdev_features_t\nmlx5e_ipsec_feature_check(struct sk_buff *skb, netdev_features_t features)\n{ return features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK); }\n\nstatic inline bool\nmlx5e_ipsec_txwqe_build_eseg_csum(struct mlx5e_txqsq *sq, struct sk_buff *skb,\n\t\t\t\t  struct mlx5_wqe_eth_seg *eseg)\n{\n\treturn false;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}