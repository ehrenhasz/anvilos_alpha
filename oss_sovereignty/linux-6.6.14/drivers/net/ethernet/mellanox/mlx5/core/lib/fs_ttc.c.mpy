{
  "module_name": "fs_ttc.c",
  "hash_id": "dee4c991d68f093908c116dd80d4c87c5beab686faeb9b707c5059b74db0e1f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/fs_ttc.c",
  "human_readable_source": "\n\n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/mlx5/fs.h>\n#include <linux/mlx5/driver.h>\n#include \"mlx5_core.h\"\n#include \"lib/fs_ttc.h\"\n\n#define MLX5_TTC_NUM_GROUPS\t3\n#define MLX5_TTC_GROUP1_SIZE\t(BIT(3) + MLX5_NUM_TUNNEL_TT)\n#define MLX5_TTC_GROUP2_SIZE\t BIT(1)\n#define MLX5_TTC_GROUP3_SIZE\t BIT(0)\n#define MLX5_TTC_TABLE_SIZE\t(MLX5_TTC_GROUP1_SIZE +\\\n\t\t\t\t MLX5_TTC_GROUP2_SIZE +\\\n\t\t\t\t MLX5_TTC_GROUP3_SIZE)\n\n#define MLX5_INNER_TTC_NUM_GROUPS\t3\n#define MLX5_INNER_TTC_GROUP1_SIZE\tBIT(3)\n#define MLX5_INNER_TTC_GROUP2_SIZE\tBIT(1)\n#define MLX5_INNER_TTC_GROUP3_SIZE\tBIT(0)\n#define MLX5_INNER_TTC_TABLE_SIZE\t(MLX5_INNER_TTC_GROUP1_SIZE +\\\n\t\t\t\t\t MLX5_INNER_TTC_GROUP2_SIZE +\\\n\t\t\t\t\t MLX5_INNER_TTC_GROUP3_SIZE)\n\n \nstruct mlx5_ttc_table {\n\tint num_groups;\n\tstruct mlx5_flow_table *t;\n\tstruct mlx5_flow_group **g;\n\tstruct mlx5_ttc_rule rules[MLX5_NUM_TT];\n\tstruct mlx5_flow_handle *tunnel_rules[MLX5_NUM_TUNNEL_TT];\n};\n\nstruct mlx5_flow_table *mlx5_get_ttc_flow_table(struct mlx5_ttc_table *ttc)\n{\n\treturn ttc->t;\n}\n\nstatic void mlx5_cleanup_ttc_rules(struct mlx5_ttc_table *ttc)\n{\n\tint i;\n\n\tfor (i = 0; i < MLX5_NUM_TT; i++) {\n\t\tif (!IS_ERR_OR_NULL(ttc->rules[i].rule)) {\n\t\t\tmlx5_del_flow_rules(ttc->rules[i].rule);\n\t\t\tttc->rules[i].rule = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MLX5_NUM_TUNNEL_TT; i++) {\n\t\tif (!IS_ERR_OR_NULL(ttc->tunnel_rules[i])) {\n\t\t\tmlx5_del_flow_rules(ttc->tunnel_rules[i]);\n\t\t\tttc->tunnel_rules[i] = NULL;\n\t\t}\n\t}\n}\n\nstruct mlx5_etype_proto {\n\tu16 etype;\n\tu8 proto;\n};\n\nstatic struct mlx5_etype_proto ttc_rules[] = {\n\t[MLX5_TT_IPV4_TCP] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = IPPROTO_TCP,\n\t},\n\t[MLX5_TT_IPV6_TCP] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = IPPROTO_TCP,\n\t},\n\t[MLX5_TT_IPV4_UDP] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = IPPROTO_UDP,\n\t},\n\t[MLX5_TT_IPV6_UDP] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = IPPROTO_UDP,\n\t},\n\t[MLX5_TT_IPV4_IPSEC_AH] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = IPPROTO_AH,\n\t},\n\t[MLX5_TT_IPV6_IPSEC_AH] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = IPPROTO_AH,\n\t},\n\t[MLX5_TT_IPV4_IPSEC_ESP] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = IPPROTO_ESP,\n\t},\n\t[MLX5_TT_IPV6_IPSEC_ESP] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = IPPROTO_ESP,\n\t},\n\t[MLX5_TT_IPV4] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = 0,\n\t},\n\t[MLX5_TT_IPV6] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = 0,\n\t},\n\t[MLX5_TT_ANY] = {\n\t\t.etype = 0,\n\t\t.proto = 0,\n\t},\n};\n\nstatic struct mlx5_etype_proto ttc_tunnel_rules[] = {\n\t[MLX5_TT_IPV4_GRE] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = IPPROTO_GRE,\n\t},\n\t[MLX5_TT_IPV6_GRE] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = IPPROTO_GRE,\n\t},\n\t[MLX5_TT_IPV4_IPIP] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = IPPROTO_IPIP,\n\t},\n\t[MLX5_TT_IPV6_IPIP] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = IPPROTO_IPIP,\n\t},\n\t[MLX5_TT_IPV4_IPV6] = {\n\t\t.etype = ETH_P_IP,\n\t\t.proto = IPPROTO_IPV6,\n\t},\n\t[MLX5_TT_IPV6_IPV6] = {\n\t\t.etype = ETH_P_IPV6,\n\t\t.proto = IPPROTO_IPV6,\n\t},\n\n};\n\nu8 mlx5_get_proto_by_tunnel_type(enum mlx5_tunnel_types tt)\n{\n\treturn ttc_tunnel_rules[tt].proto;\n}\n\nstatic bool mlx5_tunnel_proto_supported_rx(struct mlx5_core_dev *mdev,\n\t\t\t\t\t   u8 proto_type)\n{\n\tswitch (proto_type) {\n\tcase IPPROTO_GRE:\n\t\treturn MLX5_CAP_ETH(mdev, tunnel_stateless_gre);\n\tcase IPPROTO_IPIP:\n\tcase IPPROTO_IPV6:\n\t\treturn (MLX5_CAP_ETH(mdev, tunnel_stateless_ip_over_ip) ||\n\t\t\tMLX5_CAP_ETH(mdev, tunnel_stateless_ip_over_ip_rx));\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mlx5_tunnel_any_rx_proto_supported(struct mlx5_core_dev *mdev)\n{\n\tint tt;\n\n\tfor (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {\n\t\tif (mlx5_tunnel_proto_supported_rx(mdev,\n\t\t\t\t\t\t   ttc_tunnel_rules[tt].proto))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mlx5_tunnel_inner_ft_supported(struct mlx5_core_dev *mdev)\n{\n\treturn (mlx5_tunnel_any_rx_proto_supported(mdev) &&\n\t\tMLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\t  ft_field_support.inner_ip_version));\n}\n\nstatic u8 mlx5_etype_to_ipv(u16 ethertype)\n{\n\tif (ethertype == ETH_P_IP)\n\t\treturn 4;\n\n\tif (ethertype == ETH_P_IPV6)\n\t\treturn 6;\n\n\treturn 0;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_generate_ttc_rule(struct mlx5_core_dev *dev, struct mlx5_flow_table *ft,\n\t\t       struct mlx5_flow_destination *dest, u16 etype, u8 proto)\n{\n\tint match_ipv_outer =\n\t\tMLX5_CAP_FLOWTABLE_NIC_RX(dev,\n\t\t\t\t\t  ft_field_support.outer_ip_version);\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\tu8 ipv;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (proto) {\n\t\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);\n\t\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, proto);\n\t}\n\n\tipv = mlx5_etype_to_ipv(etype);\n\tif (match_ipv_outer && ipv) {\n\t\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_version);\n\t\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version, ipv);\n\t} else if (etype) {\n\t\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ethertype);\n\t\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ethertype, etype);\n\t}\n\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(dev, \"%s: add rule failed\\n\", __func__);\n\t}\n\n\tkvfree(spec);\n\treturn err ? ERR_PTR(err) : rule;\n}\n\nstatic int mlx5_generate_ttc_table_rules(struct mlx5_core_dev *dev,\n\t\t\t\t\t struct ttc_params *params,\n\t\t\t\t\t struct mlx5_ttc_table *ttc)\n{\n\tstruct mlx5_flow_handle **trules;\n\tstruct mlx5_ttc_rule *rules;\n\tstruct mlx5_flow_table *ft;\n\tint tt;\n\tint err;\n\n\tft = ttc->t;\n\trules = ttc->rules;\n\tfor (tt = 0; tt < MLX5_NUM_TT; tt++) {\n\t\tstruct mlx5_ttc_rule *rule = &rules[tt];\n\n\t\tif (test_bit(tt, params->ignore_dests))\n\t\t\tcontinue;\n\t\trule->rule = mlx5_generate_ttc_rule(dev, ft, &params->dests[tt],\n\t\t\t\t\t\t    ttc_rules[tt].etype,\n\t\t\t\t\t\t    ttc_rules[tt].proto);\n\t\tif (IS_ERR(rule->rule)) {\n\t\t\terr = PTR_ERR(rule->rule);\n\t\t\trule->rule = NULL;\n\t\t\tgoto del_rules;\n\t\t}\n\t\trule->default_dest = params->dests[tt];\n\t}\n\n\tif (!params->inner_ttc || !mlx5_tunnel_inner_ft_supported(dev))\n\t\treturn 0;\n\n\ttrules    = ttc->tunnel_rules;\n\tfor (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {\n\t\tif (!mlx5_tunnel_proto_supported_rx(dev,\n\t\t\t\t\t\t    ttc_tunnel_rules[tt].proto))\n\t\t\tcontinue;\n\t\tif (test_bit(tt, params->ignore_tunnel_dests))\n\t\t\tcontinue;\n\t\ttrules[tt] = mlx5_generate_ttc_rule(dev, ft,\n\t\t\t\t\t\t    &params->tunnel_dests[tt],\n\t\t\t\t\t\t    ttc_tunnel_rules[tt].etype,\n\t\t\t\t\t\t    ttc_tunnel_rules[tt].proto);\n\t\tif (IS_ERR(trules[tt])) {\n\t\t\terr = PTR_ERR(trules[tt]);\n\t\t\ttrules[tt] = NULL;\n\t\t\tgoto del_rules;\n\t\t}\n\t}\n\n\treturn 0;\n\ndel_rules:\n\tmlx5_cleanup_ttc_rules(ttc);\n\treturn err;\n}\n\nstatic int mlx5_create_ttc_table_groups(struct mlx5_ttc_table *ttc,\n\t\t\t\t\tbool use_ipv)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tttc->g = kcalloc(MLX5_TTC_NUM_GROUPS, sizeof(*ttc->g), GFP_KERNEL);\n\tif (!ttc->g)\n\t\treturn -ENOMEM;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\tkfree(ttc->g);\n\t\tttc->g = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ip_protocol);\n\tif (use_ipv)\n\t\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ip_version);\n\telse\n\t\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_TTC_GROUP1_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);\n\tif (IS_ERR(ttc->g[ttc->num_groups]))\n\t\tgoto err;\n\tttc->num_groups++;\n\n\t \n\tMLX5_SET(fte_match_param, mc, outer_headers.ip_protocol, 0);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_TTC_GROUP2_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);\n\tif (IS_ERR(ttc->g[ttc->num_groups]))\n\t\tgoto err;\n\tttc->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_TTC_GROUP3_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);\n\tif (IS_ERR(ttc->g[ttc->num_groups]))\n\t\tgoto err;\n\tttc->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ttc->g[ttc->num_groups]);\n\tttc->g[ttc->num_groups] = NULL;\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_generate_inner_ttc_rule(struct mlx5_core_dev *dev,\n\t\t\t     struct mlx5_flow_table *ft,\n\t\t\t     struct mlx5_flow_destination *dest,\n\t\t\t     u16 etype, u8 proto)\n{\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\tu8 ipv;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tipv = mlx5_etype_to_ipv(etype);\n\tif (etype && ipv) {\n\t\tspec->match_criteria_enable = MLX5_MATCH_INNER_HEADERS;\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, inner_headers.ip_version);\n\t\tMLX5_SET(fte_match_param, spec->match_value, inner_headers.ip_version, ipv);\n\t}\n\n\tif (proto) {\n\t\tspec->match_criteria_enable = MLX5_MATCH_INNER_HEADERS;\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, inner_headers.ip_protocol);\n\t\tMLX5_SET(fte_match_param, spec->match_value, inner_headers.ip_protocol, proto);\n\t}\n\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(dev, \"%s: add inner TTC rule failed\\n\", __func__);\n\t}\n\n\tkvfree(spec);\n\treturn err ? ERR_PTR(err) : rule;\n}\n\nstatic int mlx5_generate_inner_ttc_table_rules(struct mlx5_core_dev *dev,\n\t\t\t\t\t       struct ttc_params *params,\n\t\t\t\t\t       struct mlx5_ttc_table *ttc)\n{\n\tstruct mlx5_ttc_rule *rules;\n\tstruct mlx5_flow_table *ft;\n\tint err;\n\tint tt;\n\n\tft = ttc->t;\n\trules = ttc->rules;\n\n\tfor (tt = 0; tt < MLX5_NUM_TT; tt++) {\n\t\tstruct mlx5_ttc_rule *rule = &rules[tt];\n\n\t\tif (test_bit(tt, params->ignore_dests))\n\t\t\tcontinue;\n\t\trule->rule = mlx5_generate_inner_ttc_rule(dev, ft,\n\t\t\t\t\t\t\t  &params->dests[tt],\n\t\t\t\t\t\t\t  ttc_rules[tt].etype,\n\t\t\t\t\t\t\t  ttc_rules[tt].proto);\n\t\tif (IS_ERR(rule->rule)) {\n\t\t\terr = PTR_ERR(rule->rule);\n\t\t\trule->rule = NULL;\n\t\t\tgoto del_rules;\n\t\t}\n\t\trule->default_dest = params->dests[tt];\n\t}\n\n\treturn 0;\n\ndel_rules:\n\n\tmlx5_cleanup_ttc_rules(ttc);\n\treturn err;\n}\n\nstatic int mlx5_create_inner_ttc_table_groups(struct mlx5_ttc_table *ttc)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tttc->g = kcalloc(MLX5_INNER_TTC_NUM_GROUPS, sizeof(*ttc->g),\n\t\t\t GFP_KERNEL);\n\tif (!ttc->g)\n\t\treturn -ENOMEM;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\tkfree(ttc->g);\n\t\tttc->g = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, inner_headers.ip_protocol);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, inner_headers.ip_version);\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_INNER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_INNER_TTC_GROUP1_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);\n\tif (IS_ERR(ttc->g[ttc->num_groups]))\n\t\tgoto err;\n\tttc->num_groups++;\n\n\t \n\tMLX5_SET(fte_match_param, mc, inner_headers.ip_protocol, 0);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_INNER_TTC_GROUP2_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);\n\tif (IS_ERR(ttc->g[ttc->num_groups]))\n\t\tgoto err;\n\tttc->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_INNER_TTC_GROUP3_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);\n\tif (IS_ERR(ttc->g[ttc->num_groups]))\n\t\tgoto err;\n\tttc->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ttc->g[ttc->num_groups]);\n\tttc->g[ttc->num_groups] = NULL;\n\tkvfree(in);\n\n\treturn err;\n}\n\nstruct mlx5_ttc_table *mlx5_create_inner_ttc_table(struct mlx5_core_dev *dev,\n\t\t\t\t\t\t   struct ttc_params *params)\n{\n\tstruct mlx5_ttc_table *ttc;\n\tint err;\n\n\tttc = kvzalloc(sizeof(*ttc), GFP_KERNEL);\n\tif (!ttc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tWARN_ON_ONCE(params->ft_attr.max_fte);\n\tparams->ft_attr.max_fte = MLX5_INNER_TTC_TABLE_SIZE;\n\tttc->t = mlx5_create_flow_table(params->ns, &params->ft_attr);\n\tif (IS_ERR(ttc->t)) {\n\t\terr = PTR_ERR(ttc->t);\n\t\tkvfree(ttc);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = mlx5_create_inner_ttc_table_groups(ttc);\n\tif (err)\n\t\tgoto destroy_ft;\n\n\terr = mlx5_generate_inner_ttc_table_rules(dev, params, ttc);\n\tif (err)\n\t\tgoto destroy_ft;\n\n\treturn ttc;\n\ndestroy_ft:\n\tmlx5_destroy_ttc_table(ttc);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5_destroy_ttc_table(struct mlx5_ttc_table *ttc)\n{\n\tint i;\n\n\tmlx5_cleanup_ttc_rules(ttc);\n\tfor (i = ttc->num_groups - 1; i >= 0; i--) {\n\t\tif (!IS_ERR_OR_NULL(ttc->g[i]))\n\t\t\tmlx5_destroy_flow_group(ttc->g[i]);\n\t\tttc->g[i] = NULL;\n\t}\n\n\tkfree(ttc->g);\n\tmlx5_destroy_flow_table(ttc->t);\n\tkvfree(ttc);\n}\n\nstruct mlx5_ttc_table *mlx5_create_ttc_table(struct mlx5_core_dev *dev,\n\t\t\t\t\t     struct ttc_params *params)\n{\n\tbool match_ipv_outer =\n\t\tMLX5_CAP_FLOWTABLE_NIC_RX(dev,\n\t\t\t\t\t  ft_field_support.outer_ip_version);\n\tstruct mlx5_ttc_table *ttc;\n\tint err;\n\n\tttc = kvzalloc(sizeof(*ttc), GFP_KERNEL);\n\tif (!ttc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tWARN_ON_ONCE(params->ft_attr.max_fte);\n\tparams->ft_attr.max_fte = MLX5_TTC_TABLE_SIZE;\n\tttc->t = mlx5_create_flow_table(params->ns, &params->ft_attr);\n\tif (IS_ERR(ttc->t)) {\n\t\terr = PTR_ERR(ttc->t);\n\t\tkvfree(ttc);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = mlx5_create_ttc_table_groups(ttc, match_ipv_outer);\n\tif (err)\n\t\tgoto destroy_ft;\n\n\terr = mlx5_generate_ttc_table_rules(dev, params, ttc);\n\tif (err)\n\t\tgoto destroy_ft;\n\n\treturn ttc;\n\ndestroy_ft:\n\tmlx5_destroy_ttc_table(ttc);\n\treturn ERR_PTR(err);\n}\n\nint mlx5_ttc_fwd_dest(struct mlx5_ttc_table *ttc, enum mlx5_traffic_types type,\n\t\t      struct mlx5_flow_destination *new_dest)\n{\n\treturn mlx5_modify_rule_destination(ttc->rules[type].rule, new_dest,\n\t\t\t\t\t    NULL);\n}\n\nstruct mlx5_flow_destination\nmlx5_ttc_get_default_dest(struct mlx5_ttc_table *ttc,\n\t\t\t  enum mlx5_traffic_types type)\n{\n\tstruct mlx5_flow_destination *dest = &ttc->rules[type].default_dest;\n\n\tWARN_ONCE(dest->type != MLX5_FLOW_DESTINATION_TYPE_TIR,\n\t\t  \"TTC[%d] default dest is not setup yet\", type);\n\n\treturn *dest;\n}\n\nint mlx5_ttc_fwd_default_dest(struct mlx5_ttc_table *ttc,\n\t\t\t      enum mlx5_traffic_types type)\n{\n\tstruct mlx5_flow_destination dest = mlx5_ttc_get_default_dest(ttc, type);\n\n\treturn mlx5_ttc_fwd_dest(ttc, type, &dest);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}