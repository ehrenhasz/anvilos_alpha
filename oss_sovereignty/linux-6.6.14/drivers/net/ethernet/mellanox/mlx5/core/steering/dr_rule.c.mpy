{
  "module_name": "dr_rule.c",
  "hash_id": "d9672b0b78dba2ff1f4ce11c243bd9c3cc61ab24eef0bb13aebc77e6a931dd2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_rule.c",
  "human_readable_source": "\n \n\n#include \"dr_types.h\"\n\n#if defined(CONFIG_FRAME_WARN) && (CONFIG_FRAME_WARN < 2048)\n \n#define DR_RULE_MAX_STES_OPTIMIZED 0\n#else\n#define DR_RULE_MAX_STES_OPTIMIZED 5\n#endif\n#define DR_RULE_MAX_STE_CHAIN_OPTIMIZED (DR_RULE_MAX_STES_OPTIMIZED + DR_ACTION_MAX_STES)\n\nstatic int dr_rule_append_to_miss_list(struct mlx5dr_domain *dmn,\n\t\t\t\t       enum mlx5dr_domain_nic_type nic_type,\n\t\t\t\t       struct mlx5dr_ste *new_last_ste,\n\t\t\t\t       struct list_head *miss_list,\n\t\t\t\t       struct list_head *send_list)\n{\n\tstruct mlx5dr_ste_ctx *ste_ctx = dmn->ste_ctx;\n\tstruct mlx5dr_ste_send_info *ste_info_last;\n\tstruct mlx5dr_ste *last_ste;\n\n\t \n\tlast_ste = list_last_entry(miss_list, struct mlx5dr_ste, miss_list_node);\n\tWARN_ON(!last_ste);\n\n\tste_info_last = mlx5dr_send_info_alloc(dmn, nic_type);\n\tif (!ste_info_last)\n\t\treturn -ENOMEM;\n\n\tmlx5dr_ste_set_miss_addr(ste_ctx, mlx5dr_ste_get_hw_ste(last_ste),\n\t\t\t\t mlx5dr_ste_get_icm_addr(new_last_ste));\n\tlist_add_tail(&new_last_ste->miss_list_node, miss_list);\n\n\tmlx5dr_send_fill_and_append_ste_send_info(last_ste, DR_STE_SIZE_CTRL,\n\t\t\t\t\t\t  0, mlx5dr_ste_get_hw_ste(last_ste),\n\t\t\t\t\t\t  ste_info_last, send_list, true);\n\n\treturn 0;\n}\n\nstatic void dr_rule_set_last_ste_miss_addr(struct mlx5dr_matcher *matcher,\n\t\t\t\t\t   struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\t\t   u8 *hw_ste)\n{\n\tstruct mlx5dr_ste_ctx *ste_ctx = matcher->tbl->dmn->ste_ctx;\n\tu64 icm_addr;\n\n\tif (mlx5dr_ste_is_miss_addr_set(ste_ctx, hw_ste))\n\t\treturn;\n\n\ticm_addr = mlx5dr_icm_pool_get_chunk_icm_addr(nic_matcher->e_anchor->chunk);\n\tmlx5dr_ste_set_miss_addr(ste_ctx, hw_ste, icm_addr);\n}\n\nstatic struct mlx5dr_ste *\ndr_rule_create_collision_htbl(struct mlx5dr_matcher *matcher,\n\t\t\t      struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t      u8 *hw_ste)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_ste_htbl *new_htbl;\n\tstruct mlx5dr_ste *ste;\n\n\t \n\tnew_htbl = mlx5dr_ste_htbl_alloc(dmn->ste_icm_pool,\n\t\t\t\t\t DR_CHUNK_SIZE_1,\n\t\t\t\t\t MLX5DR_STE_LU_TYPE_DONT_CARE,\n\t\t\t\t\t 0);\n\tif (!new_htbl) {\n\t\tmlx5dr_dbg(dmn, \"Failed allocating collision table\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tste = new_htbl->chunk->ste_arr;\n\tdr_rule_set_last_ste_miss_addr(matcher, nic_matcher, hw_ste);\n\tmlx5dr_htbl_get(new_htbl);\n\n\treturn ste;\n}\n\nstatic struct mlx5dr_ste *\ndr_rule_create_collision_entry(struct mlx5dr_matcher *matcher,\n\t\t\t       struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t       u8 *hw_ste,\n\t\t\t       struct mlx5dr_ste *orig_ste)\n{\n\tstruct mlx5dr_ste *ste;\n\n\tste = dr_rule_create_collision_htbl(matcher, nic_matcher, hw_ste);\n\tif (!ste) {\n\t\tmlx5dr_dbg(matcher->tbl->dmn, \"Failed creating collision entry\\n\");\n\t\treturn NULL;\n\t}\n\n\tste->ste_chain_location = orig_ste->ste_chain_location;\n\tste->htbl->pointing_ste = orig_ste->htbl->pointing_ste;\n\n\t \n\tste->htbl->chunk->miss_list = mlx5dr_ste_get_miss_list(orig_ste);\n\n\t \n\tif (mlx5dr_ste_create_next_htbl(matcher, nic_matcher, ste, hw_ste,\n\t\t\t\t\tDR_CHUNK_SIZE_1)) {\n\t\tmlx5dr_dbg(matcher->tbl->dmn, \"Failed allocating table\\n\");\n\t\tgoto free_tbl;\n\t}\n\n\treturn ste;\n\nfree_tbl:\n\tmlx5dr_ste_free(ste, matcher, nic_matcher);\n\treturn NULL;\n}\n\nstatic int\ndr_rule_handle_one_ste_in_update_list(struct mlx5dr_ste_send_info *ste_info,\n\t\t\t\t      struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\n\tlist_del(&ste_info->send_list);\n\n\t \n\tif (ste_info->size == DR_STE_SIZE_CTRL)\n\t\tmemcpy(mlx5dr_ste_get_hw_ste(ste_info->ste),\n\t\t       ste_info->data, DR_STE_SIZE_CTRL);\n\telse\n\t\tmemcpy(mlx5dr_ste_get_hw_ste(ste_info->ste),\n\t\t       ste_info->data, DR_STE_SIZE_REDUCED);\n\n\tret = mlx5dr_send_postsend_ste(dmn, ste_info->ste, ste_info->data,\n\t\t\t\t       ste_info->size, ste_info->offset);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmlx5dr_send_info_free(ste_info);\n\treturn ret;\n}\n\nstatic int dr_rule_send_update_list(struct list_head *send_ste_list,\n\t\t\t\t    struct mlx5dr_domain *dmn,\n\t\t\t\t    bool is_reverse)\n{\n\tstruct mlx5dr_ste_send_info *ste_info, *tmp_ste_info;\n\tint ret;\n\n\tif (is_reverse) {\n\t\tlist_for_each_entry_safe_reverse(ste_info, tmp_ste_info,\n\t\t\t\t\t\t send_ste_list, send_list) {\n\t\t\tret = dr_rule_handle_one_ste_in_update_list(ste_info,\n\t\t\t\t\t\t\t\t    dmn);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry_safe(ste_info, tmp_ste_info,\n\t\t\t\t\t send_ste_list, send_list) {\n\t\t\tret = dr_rule_handle_one_ste_in_update_list(ste_info,\n\t\t\t\t\t\t\t\t    dmn);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct mlx5dr_ste *\ndr_rule_find_ste_in_miss_list(struct list_head *miss_list, u8 *hw_ste)\n{\n\tstruct mlx5dr_ste *ste;\n\n\tif (list_empty(miss_list))\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(ste, miss_list, miss_list_node) {\n\t\tif (mlx5dr_ste_equal_tag(mlx5dr_ste_get_hw_ste(ste), hw_ste))\n\t\t\treturn ste;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlx5dr_ste *\ndr_rule_rehash_handle_collision(struct mlx5dr_matcher *matcher,\n\t\t\t\tstruct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\tstruct list_head *update_list,\n\t\t\t\tstruct mlx5dr_ste *col_ste,\n\t\t\t\tu8 *hw_ste)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_ste *new_ste;\n\tint ret;\n\n\tnew_ste = dr_rule_create_collision_htbl(matcher, nic_matcher, hw_ste);\n\tif (!new_ste)\n\t\treturn NULL;\n\n\t \n\tnew_ste->htbl->pointing_ste = col_ste->htbl->pointing_ste;\n\n\t \n\tnew_ste->htbl->chunk->miss_list = mlx5dr_ste_get_miss_list(col_ste);\n\n\t \n\tret = dr_rule_append_to_miss_list(dmn, nic_matcher->nic_tbl->nic_dmn->type,\n\t\t\t\t\t  new_ste, mlx5dr_ste_get_miss_list(col_ste),\n\t\t\t\t\t  update_list);\n\tif (ret) {\n\t\tmlx5dr_dbg(dmn, \"Failed update dup entry\\n\");\n\t\tgoto err_exit;\n\t}\n\n\treturn new_ste;\n\nerr_exit:\n\tmlx5dr_ste_free(new_ste, matcher, nic_matcher);\n\treturn NULL;\n}\n\nstatic void dr_rule_rehash_copy_ste_ctrl(struct mlx5dr_matcher *matcher,\n\t\t\t\t\t struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\t\t struct mlx5dr_ste *cur_ste,\n\t\t\t\t\t struct mlx5dr_ste *new_ste)\n{\n\tnew_ste->next_htbl = cur_ste->next_htbl;\n\tnew_ste->ste_chain_location = cur_ste->ste_chain_location;\n\n\tif (new_ste->next_htbl)\n\t\tnew_ste->next_htbl->pointing_ste = new_ste;\n\n\t \n\tnew_ste->refcount = cur_ste->refcount;\n\n\t \n\tmlx5dr_rule_set_last_member(cur_ste->rule_rx_tx, new_ste, false);\n}\n\nstatic struct mlx5dr_ste *\ndr_rule_rehash_copy_ste(struct mlx5dr_matcher *matcher,\n\t\t\tstruct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\tstruct mlx5dr_ste *cur_ste,\n\t\t\tstruct mlx5dr_ste_htbl *new_htbl,\n\t\t\tstruct list_head *update_list)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_ste_send_info *ste_info;\n\tbool use_update_list = false;\n\tu8 hw_ste[DR_STE_SIZE] = {};\n\tstruct mlx5dr_ste *new_ste;\n\tint new_idx;\n\tu8 sb_idx;\n\n\t \n\tsb_idx = cur_ste->ste_chain_location - 1;\n\tmlx5dr_ste_set_bit_mask(hw_ste, nic_matcher->ste_builder[sb_idx].bit_mask);\n\n\t \n\tmemcpy(hw_ste, mlx5dr_ste_get_hw_ste(cur_ste), DR_STE_SIZE_REDUCED);\n\tdr_rule_set_last_ste_miss_addr(matcher, nic_matcher, hw_ste);\n\n\tnew_idx = mlx5dr_ste_calc_hash_index(hw_ste, new_htbl);\n\tnew_ste = &new_htbl->chunk->ste_arr[new_idx];\n\n\tif (mlx5dr_ste_is_not_used(new_ste)) {\n\t\tmlx5dr_htbl_get(new_htbl);\n\t\tlist_add_tail(&new_ste->miss_list_node,\n\t\t\t      mlx5dr_ste_get_miss_list(new_ste));\n\t} else {\n\t\tnew_ste = dr_rule_rehash_handle_collision(matcher,\n\t\t\t\t\t\t\t  nic_matcher,\n\t\t\t\t\t\t\t  update_list,\n\t\t\t\t\t\t\t  new_ste,\n\t\t\t\t\t\t\t  hw_ste);\n\t\tif (!new_ste) {\n\t\t\tmlx5dr_dbg(dmn, \"Failed adding collision entry, index: %d\\n\",\n\t\t\t\t   new_idx);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_htbl->ctrl.num_of_collisions++;\n\t\tuse_update_list = true;\n\t}\n\n\tmemcpy(mlx5dr_ste_get_hw_ste(new_ste), hw_ste, DR_STE_SIZE_REDUCED);\n\n\tnew_htbl->ctrl.num_of_valid_entries++;\n\n\tif (use_update_list) {\n\t\tste_info = mlx5dr_send_info_alloc(dmn,\n\t\t\t\t\t\t  nic_matcher->nic_tbl->nic_dmn->type);\n\t\tif (!ste_info)\n\t\t\tgoto err_exit;\n\n\t\tmlx5dr_send_fill_and_append_ste_send_info(new_ste, DR_STE_SIZE, 0,\n\t\t\t\t\t\t\t  hw_ste, ste_info,\n\t\t\t\t\t\t\t  update_list, true);\n\t}\n\n\tdr_rule_rehash_copy_ste_ctrl(matcher, nic_matcher, cur_ste, new_ste);\n\n\treturn new_ste;\n\nerr_exit:\n\tmlx5dr_ste_free(new_ste, matcher, nic_matcher);\n\treturn NULL;\n}\n\nstatic int dr_rule_rehash_copy_miss_list(struct mlx5dr_matcher *matcher,\n\t\t\t\t\t struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\t\t struct list_head *cur_miss_list,\n\t\t\t\t\t struct mlx5dr_ste_htbl *new_htbl,\n\t\t\t\t\t struct list_head *update_list)\n{\n\tstruct mlx5dr_ste *tmp_ste, *cur_ste, *new_ste;\n\n\tif (list_empty(cur_miss_list))\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(cur_ste, tmp_ste, cur_miss_list, miss_list_node) {\n\t\tnew_ste = dr_rule_rehash_copy_ste(matcher,\n\t\t\t\t\t\t  nic_matcher,\n\t\t\t\t\t\t  cur_ste,\n\t\t\t\t\t\t  new_htbl,\n\t\t\t\t\t\t  update_list);\n\t\tif (!new_ste)\n\t\t\tgoto err_insert;\n\n\t\tlist_del(&cur_ste->miss_list_node);\n\t\tmlx5dr_htbl_put(cur_ste->htbl);\n\t}\n\treturn 0;\n\nerr_insert:\n\tmlx5dr_err(matcher->tbl->dmn, \"Fatal error during resize\\n\");\n\tWARN_ON(true);\n\treturn -EINVAL;\n}\n\nstatic int dr_rule_rehash_copy_htbl(struct mlx5dr_matcher *matcher,\n\t\t\t\t    struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\t    struct mlx5dr_ste_htbl *cur_htbl,\n\t\t\t\t    struct mlx5dr_ste_htbl *new_htbl,\n\t\t\t\t    struct list_head *update_list)\n{\n\tstruct mlx5dr_ste *cur_ste;\n\tint cur_entries;\n\tint err = 0;\n\tint i;\n\n\tcur_entries = mlx5dr_icm_pool_chunk_size_to_entries(cur_htbl->chunk->size);\n\n\tif (cur_entries < 1) {\n\t\tmlx5dr_dbg(matcher->tbl->dmn, \"Invalid number of entries\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cur_entries; i++) {\n\t\tcur_ste = &cur_htbl->chunk->ste_arr[i];\n\t\tif (mlx5dr_ste_is_not_used(cur_ste))  \n\t\t\tcontinue;\n\n\t\terr = dr_rule_rehash_copy_miss_list(matcher,\n\t\t\t\t\t\t    nic_matcher,\n\t\t\t\t\t\t    mlx5dr_ste_get_miss_list(cur_ste),\n\t\t\t\t\t\t    new_htbl,\n\t\t\t\t\t\t    update_list);\n\t\tif (err)\n\t\t\tgoto clean_copy;\n\n\t\t \n\t\terr = dr_rule_send_update_list(update_list, matcher->tbl->dmn, false);\n\t\tif (err) {\n\t\t\tmlx5dr_dbg(matcher->tbl->dmn, \"Failed updating table to HW\\n\");\n\t\t\tgoto clean_copy;\n\t\t}\n\t}\n\nclean_copy:\n\treturn err;\n}\n\nstatic struct mlx5dr_ste_htbl *\ndr_rule_rehash_htbl(struct mlx5dr_rule *rule,\n\t\t    struct mlx5dr_rule_rx_tx *nic_rule,\n\t\t    struct mlx5dr_ste_htbl *cur_htbl,\n\t\t    u8 ste_location,\n\t\t    struct list_head *update_list,\n\t\t    enum mlx5dr_icm_chunk_size new_size)\n{\n\tstruct mlx5dr_ste_send_info *del_ste_info, *tmp_ste_info;\n\tstruct mlx5dr_matcher *matcher = rule->matcher;\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_matcher_rx_tx *nic_matcher;\n\tstruct mlx5dr_ste_send_info *ste_info;\n\tstruct mlx5dr_htbl_connect_info info;\n\tstruct mlx5dr_domain_rx_tx *nic_dmn;\n\tu8 formatted_ste[DR_STE_SIZE] = {};\n\tLIST_HEAD(rehash_table_send_list);\n\tstruct mlx5dr_ste *ste_to_update;\n\tstruct mlx5dr_ste_htbl *new_htbl;\n\tint err;\n\n\tnic_matcher = nic_rule->nic_matcher;\n\tnic_dmn = nic_matcher->nic_tbl->nic_dmn;\n\n\tste_info = mlx5dr_send_info_alloc(dmn,\n\t\t\t\t\t  nic_matcher->nic_tbl->nic_dmn->type);\n\tif (!ste_info)\n\t\treturn NULL;\n\n\tnew_htbl = mlx5dr_ste_htbl_alloc(dmn->ste_icm_pool,\n\t\t\t\t\t new_size,\n\t\t\t\t\t cur_htbl->lu_type,\n\t\t\t\t\t cur_htbl->byte_mask);\n\tif (!new_htbl) {\n\t\tmlx5dr_err(dmn, \"Failed to allocate new hash table\\n\");\n\t\tgoto free_ste_info;\n\t}\n\n\t \n\tinfo.type = CONNECT_MISS;\n\tinfo.miss_icm_addr = mlx5dr_icm_pool_get_chunk_icm_addr(nic_matcher->e_anchor->chunk);\n\tmlx5dr_ste_set_formatted_ste(dmn->ste_ctx,\n\t\t\t\t     dmn->info.caps.gvmi,\n\t\t\t\t     nic_dmn->type,\n\t\t\t\t     new_htbl,\n\t\t\t\t     formatted_ste,\n\t\t\t\t     &info);\n\n\tnew_htbl->pointing_ste = cur_htbl->pointing_ste;\n\tnew_htbl->pointing_ste->next_htbl = new_htbl;\n\terr = dr_rule_rehash_copy_htbl(matcher,\n\t\t\t\t       nic_matcher,\n\t\t\t\t       cur_htbl,\n\t\t\t\t       new_htbl,\n\t\t\t\t       &rehash_table_send_list);\n\tif (err)\n\t\tgoto free_new_htbl;\n\n\tif (mlx5dr_send_postsend_htbl(dmn, new_htbl, formatted_ste,\n\t\t\t\t      nic_matcher->ste_builder[ste_location - 1].bit_mask)) {\n\t\tmlx5dr_err(dmn, \"Failed writing table to HW\\n\");\n\t\tgoto free_new_htbl;\n\t}\n\n\t \n\tif (dr_rule_send_update_list(&rehash_table_send_list, dmn, false)) {\n\t\tmlx5dr_err(dmn, \"Failed updating table to HW\\n\");\n\t\tgoto free_ste_list;\n\t}\n\n\t \n\tif (ste_location == 1) {\n\t\t \n\t\tstruct mlx5dr_ste_htbl *prev_htbl = cur_htbl->pointing_ste->htbl;\n\n\t\t \n\t\tmlx5dr_htbl_get(new_htbl);\n\t\tmlx5dr_htbl_put(cur_htbl);\n\n\t\tnic_matcher->s_htbl = new_htbl;\n\n\t\t \n\t\tmlx5dr_ste_set_hit_addr(dmn->ste_ctx,\n\t\t\t\t\tprev_htbl->chunk->hw_ste_arr,\n\t\t\t\t\tmlx5dr_icm_pool_get_chunk_icm_addr(new_htbl->chunk),\n\t\t\t\t\tmlx5dr_icm_pool_get_chunk_num_of_entries(new_htbl->chunk));\n\n\t\tste_to_update = &prev_htbl->chunk->ste_arr[0];\n\t} else {\n\t\tmlx5dr_ste_set_hit_addr_by_next_htbl(dmn->ste_ctx,\n\t\t\t\t\t\t     mlx5dr_ste_get_hw_ste(cur_htbl->pointing_ste),\n\t\t\t\t\t\t     new_htbl);\n\t\tste_to_update = cur_htbl->pointing_ste;\n\t}\n\n\tmlx5dr_send_fill_and_append_ste_send_info(ste_to_update, DR_STE_SIZE_CTRL,\n\t\t\t\t\t\t  0, mlx5dr_ste_get_hw_ste(ste_to_update),\n\t\t\t\t\t\t  ste_info, update_list, false);\n\n\treturn new_htbl;\n\nfree_ste_list:\n\t \n\tlist_for_each_entry_safe(del_ste_info, tmp_ste_info,\n\t\t\t\t &rehash_table_send_list, send_list) {\n\t\tlist_del(&del_ste_info->send_list);\n\t\tmlx5dr_send_info_free(del_ste_info);\n\t}\n\nfree_new_htbl:\n\tmlx5dr_ste_htbl_free(new_htbl);\nfree_ste_info:\n\tmlx5dr_send_info_free(ste_info);\n\tmlx5dr_info(dmn, \"Failed creating rehash table\\n\");\n\treturn NULL;\n}\n\nstatic struct mlx5dr_ste_htbl *dr_rule_rehash(struct mlx5dr_rule *rule,\n\t\t\t\t\t      struct mlx5dr_rule_rx_tx *nic_rule,\n\t\t\t\t\t      struct mlx5dr_ste_htbl *cur_htbl,\n\t\t\t\t\t      u8 ste_location,\n\t\t\t\t\t      struct list_head *update_list)\n{\n\tstruct mlx5dr_domain *dmn = rule->matcher->tbl->dmn;\n\tenum mlx5dr_icm_chunk_size new_size;\n\n\tnew_size = mlx5dr_icm_next_higher_chunk(cur_htbl->chunk->size);\n\tnew_size = min_t(u32, new_size, dmn->info.max_log_sw_icm_sz);\n\n\tif (new_size == cur_htbl->chunk->size)\n\t\treturn NULL;  \n\n\treturn dr_rule_rehash_htbl(rule, nic_rule, cur_htbl, ste_location,\n\t\t\t\t   update_list, new_size);\n}\n\nstatic struct mlx5dr_ste *\ndr_rule_handle_collision(struct mlx5dr_matcher *matcher,\n\t\t\t struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t struct mlx5dr_ste *ste,\n\t\t\t u8 *hw_ste,\n\t\t\t struct list_head *miss_list,\n\t\t\t struct list_head *send_list)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_ste_send_info *ste_info;\n\tstruct mlx5dr_ste *new_ste;\n\n\tste_info = mlx5dr_send_info_alloc(dmn,\n\t\t\t\t\t  nic_matcher->nic_tbl->nic_dmn->type);\n\tif (!ste_info)\n\t\treturn NULL;\n\n\tnew_ste = dr_rule_create_collision_entry(matcher, nic_matcher, hw_ste, ste);\n\tif (!new_ste)\n\t\tgoto free_send_info;\n\n\tif (dr_rule_append_to_miss_list(dmn, nic_matcher->nic_tbl->nic_dmn->type,\n\t\t\t\t\tnew_ste, miss_list, send_list)) {\n\t\tmlx5dr_dbg(dmn, \"Failed to update prev miss_list\\n\");\n\t\tgoto err_exit;\n\t}\n\n\tmlx5dr_send_fill_and_append_ste_send_info(new_ste, DR_STE_SIZE, 0, hw_ste,\n\t\t\t\t\t\t  ste_info, send_list, false);\n\n\tste->htbl->ctrl.num_of_collisions++;\n\tste->htbl->ctrl.num_of_valid_entries++;\n\n\treturn new_ste;\n\nerr_exit:\n\tmlx5dr_ste_free(new_ste, matcher, nic_matcher);\nfree_send_info:\n\tmlx5dr_send_info_free(ste_info);\n\treturn NULL;\n}\n\nstatic void dr_rule_remove_action_members(struct mlx5dr_rule *rule)\n{\n\tstruct mlx5dr_rule_action_member *action_mem;\n\tstruct mlx5dr_rule_action_member *tmp;\n\n\tlist_for_each_entry_safe(action_mem, tmp, &rule->rule_actions_list, list) {\n\t\tlist_del(&action_mem->list);\n\t\trefcount_dec(&action_mem->action->refcount);\n\t\tkvfree(action_mem);\n\t}\n}\n\nstatic int dr_rule_add_action_members(struct mlx5dr_rule *rule,\n\t\t\t\t      size_t num_actions,\n\t\t\t\t      struct mlx5dr_action *actions[])\n{\n\tstruct mlx5dr_rule_action_member *action_mem;\n\tint i;\n\n\tfor (i = 0; i < num_actions; i++) {\n\t\taction_mem = kvzalloc(sizeof(*action_mem), GFP_KERNEL);\n\t\tif (!action_mem)\n\t\t\tgoto free_action_members;\n\n\t\taction_mem->action = actions[i];\n\t\tINIT_LIST_HEAD(&action_mem->list);\n\t\tlist_add_tail(&action_mem->list, &rule->rule_actions_list);\n\t\trefcount_inc(&action_mem->action->refcount);\n\t}\n\n\treturn 0;\n\nfree_action_members:\n\tdr_rule_remove_action_members(rule);\n\treturn -ENOMEM;\n}\n\nvoid mlx5dr_rule_set_last_member(struct mlx5dr_rule_rx_tx *nic_rule,\n\t\t\t\t struct mlx5dr_ste *ste,\n\t\t\t\t bool force)\n{\n\t \n\tif (ste->next_htbl && !force)\n\t\treturn;\n\n\t \n\tste->rule_rx_tx = nic_rule;\n\tnic_rule->last_rule_ste = ste;\n}\n\nstatic struct mlx5dr_ste *dr_rule_get_pointed_ste(struct mlx5dr_ste *curr_ste)\n{\n\tstruct mlx5dr_ste *first_ste;\n\n\tfirst_ste = list_first_entry(mlx5dr_ste_get_miss_list(curr_ste),\n\t\t\t\t     struct mlx5dr_ste, miss_list_node);\n\n\treturn first_ste->htbl->pointing_ste;\n}\n\nint mlx5dr_rule_get_reverse_rule_members(struct mlx5dr_ste **ste_arr,\n\t\t\t\t\t struct mlx5dr_ste *curr_ste,\n\t\t\t\t\t int *num_of_stes)\n{\n\tbool first = false;\n\n\t*num_of_stes = 0;\n\n\tif (!curr_ste)\n\t\treturn -ENOENT;\n\n\t \n\twhile (!first) {\n\t\tfirst = curr_ste->ste_chain_location == 1;\n\t\tste_arr[*num_of_stes] = curr_ste;\n\t\t*num_of_stes += 1;\n\t\tcurr_ste = dr_rule_get_pointed_ste(curr_ste);\n\t}\n\n\treturn 0;\n}\n\nstatic void dr_rule_clean_rule_members(struct mlx5dr_rule *rule,\n\t\t\t\t       struct mlx5dr_rule_rx_tx *nic_rule)\n{\n\tstruct mlx5dr_ste *ste_arr[DR_RULE_MAX_STES + DR_ACTION_MAX_STES];\n\tstruct mlx5dr_ste *curr_ste = nic_rule->last_rule_ste;\n\tint i;\n\n\tif (mlx5dr_rule_get_reverse_rule_members(ste_arr, curr_ste, &i))\n\t\treturn;\n\n\twhile (i--)\n\t\tmlx5dr_ste_put(ste_arr[i], rule->matcher, nic_rule->nic_matcher);\n}\n\nstatic u16 dr_get_bits_per_mask(u16 byte_mask)\n{\n\tu16 bits = 0;\n\n\twhile (byte_mask) {\n\t\tbyte_mask = byte_mask & (byte_mask - 1);\n\t\tbits++;\n\t}\n\n\treturn bits;\n}\n\nstatic bool dr_rule_need_enlarge_hash(struct mlx5dr_ste_htbl *htbl,\n\t\t\t\t      struct mlx5dr_domain *dmn,\n\t\t\t\t      struct mlx5dr_domain_rx_tx *nic_dmn)\n{\n\tstruct mlx5dr_ste_htbl_ctrl *ctrl = &htbl->ctrl;\n\tint threshold;\n\n\tif (dmn->info.max_log_sw_icm_sz <= htbl->chunk->size)\n\t\treturn false;\n\n\tif (!mlx5dr_ste_htbl_may_grow(htbl))\n\t\treturn false;\n\n\tif (dr_get_bits_per_mask(htbl->byte_mask) * BITS_PER_BYTE <= htbl->chunk->size)\n\t\treturn false;\n\n\tthreshold = mlx5dr_ste_htbl_increase_threshold(htbl);\n\tif (ctrl->num_of_collisions >= threshold &&\n\t    (ctrl->num_of_valid_entries - ctrl->num_of_collisions) >= threshold)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int dr_rule_handle_action_stes(struct mlx5dr_rule *rule,\n\t\t\t\t      struct mlx5dr_rule_rx_tx *nic_rule,\n\t\t\t\t      struct list_head *send_ste_list,\n\t\t\t\t      struct mlx5dr_ste *last_ste,\n\t\t\t\t      u8 *hw_ste_arr,\n\t\t\t\t      u32 new_hw_ste_arr_sz)\n{\n\tstruct mlx5dr_matcher_rx_tx *nic_matcher = nic_rule->nic_matcher;\n\tstruct mlx5dr_ste_send_info *ste_info_arr[DR_ACTION_MAX_STES];\n\tu8 num_of_builders = nic_matcher->num_of_builders;\n\tstruct mlx5dr_matcher *matcher = rule->matcher;\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tu8 *curr_hw_ste, *prev_hw_ste;\n\tstruct mlx5dr_ste *action_ste;\n\tint i, k;\n\n\t \n\n\tfor (i = num_of_builders, k = 0; i < new_hw_ste_arr_sz; i++, k++) {\n\t\tcurr_hw_ste = hw_ste_arr + i * DR_STE_SIZE;\n\t\tprev_hw_ste = (i == 0) ? curr_hw_ste : hw_ste_arr + ((i - 1) * DR_STE_SIZE);\n\t\taction_ste = dr_rule_create_collision_htbl(matcher,\n\t\t\t\t\t\t\t   nic_matcher,\n\t\t\t\t\t\t\t   curr_hw_ste);\n\t\tif (!action_ste)\n\t\t\treturn -ENOMEM;\n\n\t\tmlx5dr_ste_get(action_ste);\n\n\t\taction_ste->htbl->pointing_ste = last_ste;\n\t\tlast_ste->next_htbl = action_ste->htbl;\n\t\tlast_ste = action_ste;\n\n\t\t \n\t\tlist_add_tail(&action_ste->miss_list_node,\n\t\t\t      mlx5dr_ste_get_miss_list(action_ste));\n\n\t\tste_info_arr[k] = mlx5dr_send_info_alloc(dmn,\n\t\t\t\t\t\t\t nic_matcher->nic_tbl->nic_dmn->type);\n\t\tif (!ste_info_arr[k])\n\t\t\tgoto err_exit;\n\n\t\t \n\t\tmlx5dr_ste_set_hit_addr_by_next_htbl(dmn->ste_ctx,\n\t\t\t\t\t\t     prev_hw_ste,\n\t\t\t\t\t\t     action_ste->htbl);\n\n\t\tmlx5dr_rule_set_last_member(nic_rule, action_ste, true);\n\n\t\tmlx5dr_send_fill_and_append_ste_send_info(action_ste, DR_STE_SIZE, 0,\n\t\t\t\t\t\t\t  curr_hw_ste,\n\t\t\t\t\t\t\t  ste_info_arr[k],\n\t\t\t\t\t\t\t  send_ste_list, false);\n\t}\n\n\tlast_ste->next_htbl = NULL;\n\n\treturn 0;\n\nerr_exit:\n\tmlx5dr_ste_put(action_ste, matcher, nic_matcher);\n\treturn -ENOMEM;\n}\n\nstatic int dr_rule_handle_empty_entry(struct mlx5dr_matcher *matcher,\n\t\t\t\t      struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\t      struct mlx5dr_ste_htbl *cur_htbl,\n\t\t\t\t      struct mlx5dr_ste *ste,\n\t\t\t\t      u8 ste_location,\n\t\t\t\t      u8 *hw_ste,\n\t\t\t\t      struct list_head *miss_list,\n\t\t\t\t      struct list_head *send_list)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_ste_send_info *ste_info;\n\n\t \n\tmlx5dr_htbl_get(cur_htbl);\n\n\t \n\tlist_add_tail(&ste->miss_list_node, miss_list);\n\n\tdr_rule_set_last_ste_miss_addr(matcher, nic_matcher, hw_ste);\n\n\tste->ste_chain_location = ste_location;\n\n\tste_info = mlx5dr_send_info_alloc(dmn,\n\t\t\t\t\t  nic_matcher->nic_tbl->nic_dmn->type);\n\tif (!ste_info)\n\t\tgoto clean_ste_setting;\n\n\tif (mlx5dr_ste_create_next_htbl(matcher,\n\t\t\t\t\tnic_matcher,\n\t\t\t\t\tste,\n\t\t\t\t\thw_ste,\n\t\t\t\t\tDR_CHUNK_SIZE_1)) {\n\t\tmlx5dr_dbg(dmn, \"Failed allocating table\\n\");\n\t\tgoto clean_ste_info;\n\t}\n\n\tcur_htbl->ctrl.num_of_valid_entries++;\n\n\tmlx5dr_send_fill_and_append_ste_send_info(ste, DR_STE_SIZE, 0, hw_ste,\n\t\t\t\t\t\t  ste_info, send_list, false);\n\n\treturn 0;\n\nclean_ste_info:\n\tmlx5dr_send_info_free(ste_info);\nclean_ste_setting:\n\tlist_del_init(&ste->miss_list_node);\n\tmlx5dr_htbl_put(cur_htbl);\n\n\treturn -ENOMEM;\n}\n\nstatic struct mlx5dr_ste *\ndr_rule_handle_ste_branch(struct mlx5dr_rule *rule,\n\t\t\t  struct mlx5dr_rule_rx_tx *nic_rule,\n\t\t\t  struct list_head *send_ste_list,\n\t\t\t  struct mlx5dr_ste_htbl *cur_htbl,\n\t\t\t  u8 *hw_ste,\n\t\t\t  u8 ste_location,\n\t\t\t  struct mlx5dr_ste_htbl **put_htbl)\n{\n\tstruct mlx5dr_matcher *matcher = rule->matcher;\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_matcher_rx_tx *nic_matcher;\n\tstruct mlx5dr_domain_rx_tx *nic_dmn;\n\tstruct mlx5dr_ste_htbl *new_htbl;\n\tstruct mlx5dr_ste *matched_ste;\n\tstruct list_head *miss_list;\n\tbool skip_rehash = false;\n\tstruct mlx5dr_ste *ste;\n\tint index;\n\n\tnic_matcher = nic_rule->nic_matcher;\n\tnic_dmn = nic_matcher->nic_tbl->nic_dmn;\n\nagain:\n\tindex = mlx5dr_ste_calc_hash_index(hw_ste, cur_htbl);\n\tmiss_list = &cur_htbl->chunk->miss_list[index];\n\tste = &cur_htbl->chunk->ste_arr[index];\n\n\tif (mlx5dr_ste_is_not_used(ste)) {\n\t\tif (dr_rule_handle_empty_entry(matcher, nic_matcher, cur_htbl,\n\t\t\t\t\t       ste, ste_location,\n\t\t\t\t\t       hw_ste, miss_list,\n\t\t\t\t\t       send_ste_list))\n\t\t\treturn NULL;\n\t} else {\n\t\t \n\t\tmatched_ste = dr_rule_find_ste_in_miss_list(miss_list, hw_ste);\n\t\tif (matched_ste) {\n\t\t\t \n\t\t\tif (!mlx5dr_ste_is_last_in_rule(nic_matcher, ste_location))\n\t\t\t\treturn matched_ste;\n\n\t\t\tmlx5dr_dbg(dmn, \"Duplicate rule inserted\\n\");\n\t\t}\n\n\t\tif (!skip_rehash && dr_rule_need_enlarge_hash(cur_htbl, dmn, nic_dmn)) {\n\t\t\t \n\t\t\tskip_rehash = true;\n\n\t\t\t \n\t\t\t*put_htbl = cur_htbl;\n\t\t\tmlx5dr_htbl_get(cur_htbl);\n\n\t\t\tnew_htbl = dr_rule_rehash(rule, nic_rule, cur_htbl,\n\t\t\t\t\t\t  ste_location, send_ste_list);\n\t\t\tif (!new_htbl) {\n\t\t\t\tmlx5dr_err(dmn, \"Failed creating rehash table, htbl-log_size: %d\\n\",\n\t\t\t\t\t   cur_htbl->chunk->size);\n\t\t\t\tmlx5dr_htbl_put(cur_htbl);\n\t\t\t} else {\n\t\t\t\tcur_htbl = new_htbl;\n\t\t\t}\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t \n\t\t\tste = dr_rule_handle_collision(matcher,\n\t\t\t\t\t\t       nic_matcher,\n\t\t\t\t\t\t       ste,\n\t\t\t\t\t\t       hw_ste,\n\t\t\t\t\t\t       miss_list,\n\t\t\t\t\t\t       send_ste_list);\n\t\t\tif (!ste) {\n\t\t\t\tmlx5dr_dbg(dmn, \"failed adding collision entry, index: %d\\n\",\n\t\t\t\t\t   index);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn ste;\n}\n\nstatic bool dr_rule_cmp_value_to_mask(u8 *mask, u8 *value,\n\t\t\t\t      u32 s_idx, u32 e_idx)\n{\n\tu32 i;\n\n\tfor (i = s_idx; i < e_idx; i++) {\n\t\tif (value[i] & ~mask[i]) {\n\t\t\tpr_info(\"Rule parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool dr_rule_verify(struct mlx5dr_matcher *matcher,\n\t\t\t   struct mlx5dr_match_parameters *value,\n\t\t\t   struct mlx5dr_match_param *param)\n{\n\tu8 match_criteria = matcher->match_criteria;\n\tsize_t value_size = value->match_sz;\n\tu8 *mask_p = (u8 *)&matcher->mask;\n\tu8 *param_p = (u8 *)param;\n\tu32 s_idx, e_idx;\n\n\tif (!value_size ||\n\t    (value_size > DR_SZ_MATCH_PARAM || (value_size % sizeof(u32)))) {\n\t\tmlx5dr_err(matcher->tbl->dmn, \"Rule parameters length is incorrect\\n\");\n\t\treturn false;\n\t}\n\n\tmlx5dr_ste_copy_param(matcher->match_criteria, param, value, false);\n\n\tif (match_criteria & DR_MATCHER_CRITERIA_OUTER) {\n\t\ts_idx = offsetof(struct mlx5dr_match_param, outer);\n\t\te_idx = min(s_idx + sizeof(param->outer), value_size);\n\n\t\tif (!dr_rule_cmp_value_to_mask(mask_p, param_p, s_idx, e_idx)) {\n\t\t\tmlx5dr_err(matcher->tbl->dmn, \"Rule outer parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (match_criteria & DR_MATCHER_CRITERIA_MISC) {\n\t\ts_idx = offsetof(struct mlx5dr_match_param, misc);\n\t\te_idx = min(s_idx + sizeof(param->misc), value_size);\n\n\t\tif (!dr_rule_cmp_value_to_mask(mask_p, param_p, s_idx, e_idx)) {\n\t\t\tmlx5dr_err(matcher->tbl->dmn, \"Rule misc parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (match_criteria & DR_MATCHER_CRITERIA_INNER) {\n\t\ts_idx = offsetof(struct mlx5dr_match_param, inner);\n\t\te_idx = min(s_idx + sizeof(param->inner), value_size);\n\n\t\tif (!dr_rule_cmp_value_to_mask(mask_p, param_p, s_idx, e_idx)) {\n\t\t\tmlx5dr_err(matcher->tbl->dmn, \"Rule inner parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (match_criteria & DR_MATCHER_CRITERIA_MISC2) {\n\t\ts_idx = offsetof(struct mlx5dr_match_param, misc2);\n\t\te_idx = min(s_idx + sizeof(param->misc2), value_size);\n\n\t\tif (!dr_rule_cmp_value_to_mask(mask_p, param_p, s_idx, e_idx)) {\n\t\t\tmlx5dr_err(matcher->tbl->dmn, \"Rule misc2 parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (match_criteria & DR_MATCHER_CRITERIA_MISC3) {\n\t\ts_idx = offsetof(struct mlx5dr_match_param, misc3);\n\t\te_idx = min(s_idx + sizeof(param->misc3), value_size);\n\n\t\tif (!dr_rule_cmp_value_to_mask(mask_p, param_p, s_idx, e_idx)) {\n\t\t\tmlx5dr_err(matcher->tbl->dmn, \"Rule misc3 parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (match_criteria & DR_MATCHER_CRITERIA_MISC4) {\n\t\ts_idx = offsetof(struct mlx5dr_match_param, misc4);\n\t\te_idx = min(s_idx + sizeof(param->misc4), value_size);\n\n\t\tif (!dr_rule_cmp_value_to_mask(mask_p, param_p, s_idx, e_idx)) {\n\t\t\tmlx5dr_err(matcher->tbl->dmn,\n\t\t\t\t   \"Rule misc4 parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (match_criteria & DR_MATCHER_CRITERIA_MISC5) {\n\t\ts_idx = offsetof(struct mlx5dr_match_param, misc5);\n\t\te_idx = min(s_idx + sizeof(param->misc5), value_size);\n\n\t\tif (!dr_rule_cmp_value_to_mask(mask_p, param_p, s_idx, e_idx)) {\n\t\t\tmlx5dr_err(matcher->tbl->dmn, \"Rule misc5 parameters contains a value not specified by mask\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int dr_rule_destroy_rule_nic(struct mlx5dr_rule *rule,\n\t\t\t\t    struct mlx5dr_rule_rx_tx *nic_rule)\n{\n\t \n\tif (!nic_rule->last_rule_ste)\n\t\treturn 0;\n\n\tmlx5dr_domain_nic_lock(nic_rule->nic_matcher->nic_tbl->nic_dmn);\n\tdr_rule_clean_rule_members(rule, nic_rule);\n\n\tnic_rule->nic_matcher->rules--;\n\tif (!nic_rule->nic_matcher->rules)\n\t\tmlx5dr_matcher_remove_from_tbl_nic(rule->matcher->tbl->dmn,\n\t\t\t\t\t\t   nic_rule->nic_matcher);\n\n\tmlx5dr_domain_nic_unlock(nic_rule->nic_matcher->nic_tbl->nic_dmn);\n\n\treturn 0;\n}\n\nstatic int dr_rule_destroy_rule_fdb(struct mlx5dr_rule *rule)\n{\n\tdr_rule_destroy_rule_nic(rule, &rule->rx);\n\tdr_rule_destroy_rule_nic(rule, &rule->tx);\n\treturn 0;\n}\n\nstatic int dr_rule_destroy_rule(struct mlx5dr_rule *rule)\n{\n\tstruct mlx5dr_domain *dmn = rule->matcher->tbl->dmn;\n\n\tmlx5dr_dbg_rule_del(rule);\n\n\tswitch (dmn->type) {\n\tcase MLX5DR_DOMAIN_TYPE_NIC_RX:\n\t\tdr_rule_destroy_rule_nic(rule, &rule->rx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_NIC_TX:\n\t\tdr_rule_destroy_rule_nic(rule, &rule->tx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_FDB:\n\t\tdr_rule_destroy_rule_fdb(rule);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdr_rule_remove_action_members(rule);\n\tkfree(rule);\n\treturn 0;\n}\n\nstatic enum mlx5dr_ipv dr_rule_get_ipv(struct mlx5dr_match_spec *spec)\n{\n\tif (spec->ip_version == 6 || spec->ethertype == ETH_P_IPV6)\n\t\treturn DR_RULE_IPV6;\n\n\treturn DR_RULE_IPV4;\n}\n\nstatic bool dr_rule_skip(enum mlx5dr_domain_type domain,\n\t\t\t enum mlx5dr_domain_nic_type nic_type,\n\t\t\t struct mlx5dr_match_param *mask,\n\t\t\t struct mlx5dr_match_param *value,\n\t\t\t u32 flow_source)\n{\n\tbool rx = nic_type == DR_DOMAIN_NIC_TYPE_RX;\n\n\tif (domain != MLX5DR_DOMAIN_TYPE_FDB)\n\t\treturn false;\n\n\tif (mask->misc.source_port) {\n\t\tif (rx && value->misc.source_port != MLX5_VPORT_UPLINK)\n\t\t\treturn true;\n\n\t\tif (!rx && value->misc.source_port == MLX5_VPORT_UPLINK)\n\t\t\treturn true;\n\t}\n\n\tif (rx && flow_source == MLX5_FLOW_CONTEXT_FLOW_SOURCE_LOCAL_VPORT)\n\t\treturn true;\n\n\tif (!rx && flow_source == MLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\ndr_rule_create_rule_nic(struct mlx5dr_rule *rule,\n\t\t\tstruct mlx5dr_rule_rx_tx *nic_rule,\n\t\t\tstruct mlx5dr_match_param *param,\n\t\t\tsize_t num_actions,\n\t\t\tstruct mlx5dr_action *actions[])\n{\n\tu8 hw_ste_arr_optimized[DR_RULE_MAX_STE_CHAIN_OPTIMIZED * DR_STE_SIZE] = {};\n\tstruct mlx5dr_ste_send_info *ste_info, *tmp_ste_info;\n\tstruct mlx5dr_matcher *matcher = rule->matcher;\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_matcher_rx_tx *nic_matcher;\n\tstruct mlx5dr_domain_rx_tx *nic_dmn;\n\tstruct mlx5dr_ste_htbl *htbl = NULL;\n\tstruct mlx5dr_ste_htbl *cur_htbl;\n\tstruct mlx5dr_ste *ste = NULL;\n\tLIST_HEAD(send_ste_list);\n\tbool hw_ste_arr_is_opt;\n\tu8 *hw_ste_arr = NULL;\n\tu32 new_hw_ste_arr_sz;\n\tint ret, i;\n\n\tnic_matcher = nic_rule->nic_matcher;\n\tnic_dmn = nic_matcher->nic_tbl->nic_dmn;\n\n\tif (dr_rule_skip(dmn->type, nic_dmn->type, &matcher->mask, param,\n\t\t\t rule->flow_source))\n\t\treturn 0;\n\n\tmlx5dr_domain_nic_lock(nic_dmn);\n\n\tret = mlx5dr_matcher_select_builders(matcher,\n\t\t\t\t\t     nic_matcher,\n\t\t\t\t\t     dr_rule_get_ipv(&param->outer),\n\t\t\t\t\t     dr_rule_get_ipv(&param->inner));\n\tif (ret)\n\t\tgoto err_unlock;\n\n\thw_ste_arr_is_opt = nic_matcher->num_of_builders <= DR_RULE_MAX_STES_OPTIMIZED;\n\tif (likely(hw_ste_arr_is_opt)) {\n\t\thw_ste_arr = hw_ste_arr_optimized;\n\t} else {\n\t\thw_ste_arr = kzalloc((nic_matcher->num_of_builders + DR_ACTION_MAX_STES) *\n\t\t\t\t     DR_STE_SIZE, GFP_KERNEL);\n\n\t\tif (!hw_ste_arr) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tret = mlx5dr_matcher_add_to_tbl_nic(dmn, nic_matcher);\n\tif (ret)\n\t\tgoto free_hw_ste;\n\n\t \n\tret = mlx5dr_ste_build_ste_arr(matcher, nic_matcher, param, hw_ste_arr);\n\tif (ret)\n\t\tgoto remove_from_nic_tbl;\n\n\t \n\tret = mlx5dr_actions_build_ste_arr(matcher, nic_matcher, actions,\n\t\t\t\t\t   num_actions, hw_ste_arr,\n\t\t\t\t\t   &new_hw_ste_arr_sz);\n\tif (ret)\n\t\tgoto remove_from_nic_tbl;\n\n\tcur_htbl = nic_matcher->s_htbl;\n\n\t \n\tfor (i = 0; i < nic_matcher->num_of_builders; i++) {\n\t\t \n\t\tu8 *cur_hw_ste_ent = hw_ste_arr + (i * DR_STE_SIZE);\n\n\t\tste = dr_rule_handle_ste_branch(rule,\n\t\t\t\t\t\tnic_rule,\n\t\t\t\t\t\t&send_ste_list,\n\t\t\t\t\t\tcur_htbl,\n\t\t\t\t\t\tcur_hw_ste_ent,\n\t\t\t\t\t\ti + 1,\n\t\t\t\t\t\t&htbl);\n\t\tif (!ste) {\n\t\t\tmlx5dr_err(dmn, \"Failed creating next branch\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto free_rule;\n\t\t}\n\n\t\tcur_htbl = ste->next_htbl;\n\n\t\tmlx5dr_ste_get(ste);\n\t\tmlx5dr_rule_set_last_member(nic_rule, ste, true);\n\t}\n\n\t \n\tret = dr_rule_handle_action_stes(rule, nic_rule, &send_ste_list,\n\t\t\t\t\t ste, hw_ste_arr, new_hw_ste_arr_sz);\n\tif (ret) {\n\t\tmlx5dr_dbg(dmn, \"Failed apply actions\\n\");\n\t\tgoto free_rule;\n\t}\n\tret = dr_rule_send_update_list(&send_ste_list, dmn, true);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Failed sending ste!\\n\");\n\t\tgoto free_rule;\n\t}\n\n\tif (htbl)\n\t\tmlx5dr_htbl_put(htbl);\n\n\tnic_matcher->rules++;\n\n\tmlx5dr_domain_nic_unlock(nic_dmn);\n\n\tif (unlikely(!hw_ste_arr_is_opt))\n\t\tkfree(hw_ste_arr);\n\n\treturn 0;\n\nfree_rule:\n\tdr_rule_clean_rule_members(rule, nic_rule);\n\t \n\tlist_for_each_entry_safe(ste_info, tmp_ste_info, &send_ste_list, send_list) {\n\t\tlist_del(&ste_info->send_list);\n\t\tmlx5dr_send_info_free(ste_info);\n\t}\n\nremove_from_nic_tbl:\n\tif (!nic_matcher->rules)\n\t\tmlx5dr_matcher_remove_from_tbl_nic(dmn, nic_matcher);\n\nfree_hw_ste:\n\tif (!hw_ste_arr_is_opt)\n\t\tkfree(hw_ste_arr);\n\nerr_unlock:\n\tmlx5dr_domain_nic_unlock(nic_dmn);\n\n\treturn ret;\n}\n\nstatic int\ndr_rule_create_rule_fdb(struct mlx5dr_rule *rule,\n\t\t\tstruct mlx5dr_match_param *param,\n\t\t\tsize_t num_actions,\n\t\t\tstruct mlx5dr_action *actions[])\n{\n\tstruct mlx5dr_match_param copy_param = {};\n\tint ret;\n\n\t \n\tmemcpy(&copy_param, param, sizeof(struct mlx5dr_match_param));\n\n\tret = dr_rule_create_rule_nic(rule, &rule->rx, param,\n\t\t\t\t      num_actions, actions);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dr_rule_create_rule_nic(rule, &rule->tx, &copy_param,\n\t\t\t\t      num_actions, actions);\n\tif (ret)\n\t\tgoto destroy_rule_nic_rx;\n\n\treturn 0;\n\ndestroy_rule_nic_rx:\n\tdr_rule_destroy_rule_nic(rule, &rule->rx);\n\treturn ret;\n}\n\nstatic struct mlx5dr_rule *\ndr_rule_create_rule(struct mlx5dr_matcher *matcher,\n\t\t    struct mlx5dr_match_parameters *value,\n\t\t    size_t num_actions,\n\t\t    struct mlx5dr_action *actions[],\n\t\t    u32 flow_source)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_match_param param = {};\n\tstruct mlx5dr_rule *rule;\n\tint ret;\n\n\tif (!dr_rule_verify(matcher, value, &param))\n\t\treturn NULL;\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn NULL;\n\n\trule->matcher = matcher;\n\trule->flow_source = flow_source;\n\tINIT_LIST_HEAD(&rule->rule_actions_list);\n\n\tret = dr_rule_add_action_members(rule, num_actions, actions);\n\tif (ret)\n\t\tgoto free_rule;\n\n\tswitch (dmn->type) {\n\tcase MLX5DR_DOMAIN_TYPE_NIC_RX:\n\t\trule->rx.nic_matcher = &matcher->rx;\n\t\tret = dr_rule_create_rule_nic(rule, &rule->rx, &param,\n\t\t\t\t\t      num_actions, actions);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_NIC_TX:\n\t\trule->tx.nic_matcher = &matcher->tx;\n\t\tret = dr_rule_create_rule_nic(rule, &rule->tx, &param,\n\t\t\t\t\t      num_actions, actions);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_FDB:\n\t\trule->rx.nic_matcher = &matcher->rx;\n\t\trule->tx.nic_matcher = &matcher->tx;\n\t\tret = dr_rule_create_rule_fdb(rule, &param,\n\t\t\t\t\t      num_actions, actions);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tgoto remove_action_members;\n\n\tINIT_LIST_HEAD(&rule->dbg_node);\n\tmlx5dr_dbg_rule_add(rule);\n\treturn rule;\n\nremove_action_members:\n\tdr_rule_remove_action_members(rule);\nfree_rule:\n\tkfree(rule);\n\tmlx5dr_err(dmn, \"Failed creating rule\\n\");\n\treturn NULL;\n}\n\nstruct mlx5dr_rule *mlx5dr_rule_create(struct mlx5dr_matcher *matcher,\n\t\t\t\t       struct mlx5dr_match_parameters *value,\n\t\t\t\t       size_t num_actions,\n\t\t\t\t       struct mlx5dr_action *actions[],\n\t\t\t\t       u32 flow_source)\n{\n\tstruct mlx5dr_rule *rule;\n\n\trefcount_inc(&matcher->refcount);\n\n\trule = dr_rule_create_rule(matcher, value, num_actions, actions, flow_source);\n\tif (!rule)\n\t\trefcount_dec(&matcher->refcount);\n\n\treturn rule;\n}\n\nint mlx5dr_rule_destroy(struct mlx5dr_rule *rule)\n{\n\tstruct mlx5dr_matcher *matcher = rule->matcher;\n\tint ret;\n\n\tret = dr_rule_destroy_rule(rule);\n\tif (!ret)\n\t\trefcount_dec(&matcher->refcount);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}