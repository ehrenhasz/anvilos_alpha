{
  "module_name": "rx_res.c",
  "hash_id": "a56787e7160eed2072cad8b1c516b4e34d604be74a316e2594c8b0c441cfb133",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c",
  "human_readable_source": "\n \n\n#include \"rx_res.h\"\n#include \"channels.h\"\n#include \"params.h\"\n\n#define MLX5E_MAX_NUM_RSS 16\n\nstruct mlx5e_rx_res {\n\tstruct mlx5_core_dev *mdev;\n\tenum mlx5e_rx_res_features features;\n\tunsigned int max_nch;\n\tu32 drop_rqn;\n\n\tstruct mlx5e_packet_merge_param pkt_merge_param;\n\tstruct rw_semaphore pkt_merge_param_sem;\n\n\tstruct mlx5e_rss *rss[MLX5E_MAX_NUM_RSS];\n\tbool rss_active;\n\tu32 rss_rqns[MLX5E_INDIR_RQT_SIZE];\n\tunsigned int rss_nch;\n\n\tstruct {\n\t\tstruct mlx5e_rqt direct_rqt;\n\t\tstruct mlx5e_tir direct_tir;\n\t} *channels;\n\n\tstruct {\n\t\tstruct mlx5e_rqt rqt;\n\t\tstruct mlx5e_tir tir;\n\t} ptp;\n};\n\n \n\nstatic int mlx5e_rx_res_rss_init_def(struct mlx5e_rx_res *res,\n\t\t\t\t     unsigned int init_nch)\n{\n\tbool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;\n\tstruct mlx5e_rss *rss;\n\tint err;\n\n\tif (WARN_ON(res->rss[0]))\n\t\treturn -EINVAL;\n\n\trss = mlx5e_rss_alloc();\n\tif (!rss)\n\t\treturn -ENOMEM;\n\n\terr = mlx5e_rss_init(rss, res->mdev, inner_ft_support, res->drop_rqn,\n\t\t\t     &res->pkt_merge_param);\n\tif (err)\n\t\tgoto err_rss_free;\n\n\tmlx5e_rss_set_indir_uniform(rss, init_nch);\n\n\tres->rss[0] = rss;\n\n\treturn 0;\n\nerr_rss_free:\n\tmlx5e_rss_free(rss);\n\treturn err;\n}\n\nint mlx5e_rx_res_rss_init(struct mlx5e_rx_res *res, u32 *rss_idx, unsigned int init_nch)\n{\n\tbool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;\n\tstruct mlx5e_rss *rss;\n\tint err, i;\n\n\tfor (i = 1; i < MLX5E_MAX_NUM_RSS; i++)\n\t\tif (!res->rss[i])\n\t\t\tbreak;\n\n\tif (i == MLX5E_MAX_NUM_RSS)\n\t\treturn -ENOSPC;\n\n\trss = mlx5e_rss_alloc();\n\tif (!rss)\n\t\treturn -ENOMEM;\n\n\terr = mlx5e_rss_init_no_tirs(rss, res->mdev, inner_ft_support, res->drop_rqn);\n\tif (err)\n\t\tgoto err_rss_free;\n\n\tmlx5e_rss_set_indir_uniform(rss, init_nch);\n\tif (res->rss_active)\n\t\tmlx5e_rss_enable(rss, res->rss_rqns, res->rss_nch);\n\n\tres->rss[i] = rss;\n\t*rss_idx = i;\n\n\treturn 0;\n\nerr_rss_free:\n\tmlx5e_rss_free(rss);\n\treturn err;\n}\n\nstatic int __mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res, u32 rss_idx)\n{\n\tstruct mlx5e_rss *rss = res->rss[rss_idx];\n\tint err;\n\n\terr = mlx5e_rss_cleanup(rss);\n\tif (err)\n\t\treturn err;\n\n\tmlx5e_rss_free(rss);\n\tres->rss[rss_idx] = NULL;\n\n\treturn 0;\n}\n\nint mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res, u32 rss_idx)\n{\n\tstruct mlx5e_rss *rss;\n\n\tif (rss_idx >= MLX5E_MAX_NUM_RSS)\n\t\treturn -EINVAL;\n\n\trss = res->rss[rss_idx];\n\tif (!rss)\n\t\treturn -EINVAL;\n\n\treturn __mlx5e_rx_res_rss_destroy(res, rss_idx);\n}\n\nstatic void mlx5e_rx_res_rss_destroy_all(struct mlx5e_rx_res *res)\n{\n\tint i;\n\n\tfor (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {\n\t\tstruct mlx5e_rss *rss = res->rss[i];\n\t\tint err;\n\n\t\tif (!rss)\n\t\t\tcontinue;\n\n\t\terr = __mlx5e_rx_res_rss_destroy(res, i);\n\t\tif (err) {\n\t\t\tunsigned int refcount;\n\n\t\t\trefcount = mlx5e_rss_refcnt_read(rss);\n\t\t\tmlx5_core_warn(res->mdev,\n\t\t\t\t       \"Failed to destroy RSS context %d, refcount = %u, err = %d\\n\",\n\t\t\t\t       i, refcount, err);\n\t\t}\n\t}\n}\n\nstatic void mlx5e_rx_res_rss_enable(struct mlx5e_rx_res *res)\n{\n\tint i;\n\n\tres->rss_active = true;\n\n\tfor (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {\n\t\tstruct mlx5e_rss *rss = res->rss[i];\n\n\t\tif (!rss)\n\t\t\tcontinue;\n\t\tmlx5e_rss_enable(rss, res->rss_rqns, res->rss_nch);\n\t}\n}\n\nstatic void mlx5e_rx_res_rss_disable(struct mlx5e_rx_res *res)\n{\n\tint i;\n\n\tres->rss_active = false;\n\n\tfor (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {\n\t\tstruct mlx5e_rss *rss = res->rss[i];\n\n\t\tif (!rss)\n\t\t\tcontinue;\n\t\tmlx5e_rss_disable(rss);\n\t}\n}\n\n \nvoid mlx5e_rx_res_rss_set_indir_uniform(struct mlx5e_rx_res *res, unsigned int nch)\n{\n\tWARN_ON_ONCE(res->rss_active);\n\tmlx5e_rss_set_indir_uniform(res->rss[0], nch);\n}\n\nint mlx5e_rx_res_rss_get_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,\n\t\t\t      u32 *indir, u8 *key, u8 *hfunc)\n{\n\tstruct mlx5e_rss *rss;\n\n\tif (rss_idx >= MLX5E_MAX_NUM_RSS)\n\t\treturn -EINVAL;\n\n\trss = res->rss[rss_idx];\n\tif (!rss)\n\t\treturn -ENOENT;\n\n\treturn mlx5e_rss_get_rxfh(rss, indir, key, hfunc);\n}\n\nint mlx5e_rx_res_rss_set_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,\n\t\t\t      const u32 *indir, const u8 *key, const u8 *hfunc)\n{\n\tstruct mlx5e_rss *rss;\n\n\tif (rss_idx >= MLX5E_MAX_NUM_RSS)\n\t\treturn -EINVAL;\n\n\trss = res->rss[rss_idx];\n\tif (!rss)\n\t\treturn -ENOENT;\n\n\treturn mlx5e_rss_set_rxfh(rss, indir, key, hfunc, res->rss_rqns, res->rss_nch);\n}\n\nint mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, u32 rss_idx,\n\t\t\t\t     enum mlx5_traffic_types tt)\n{\n\tstruct mlx5e_rss *rss;\n\n\tif (rss_idx >= MLX5E_MAX_NUM_RSS)\n\t\treturn -EINVAL;\n\n\trss = res->rss[rss_idx];\n\tif (!rss)\n\t\treturn -ENOENT;\n\n\treturn mlx5e_rss_get_hash_fields(rss, tt);\n}\n\nint mlx5e_rx_res_rss_set_hash_fields(struct mlx5e_rx_res *res, u32 rss_idx,\n\t\t\t\t     enum mlx5_traffic_types tt, u8 rx_hash_fields)\n{\n\tstruct mlx5e_rss *rss;\n\n\tif (rss_idx >= MLX5E_MAX_NUM_RSS)\n\t\treturn -EINVAL;\n\n\trss = res->rss[rss_idx];\n\tif (!rss)\n\t\treturn -ENOENT;\n\n\treturn mlx5e_rss_set_hash_fields(rss, tt, rx_hash_fields);\n}\n\nint mlx5e_rx_res_rss_cnt(struct mlx5e_rx_res *res)\n{\n\tint i, cnt;\n\n\tcnt = 0;\n\tfor (i = 0; i < MLX5E_MAX_NUM_RSS; i++)\n\t\tif (res->rss[i])\n\t\t\tcnt++;\n\n\treturn cnt;\n}\n\nint mlx5e_rx_res_rss_index(struct mlx5e_rx_res *res, struct mlx5e_rss *rss)\n{\n\tint i;\n\n\tif (!rss)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MLX5E_MAX_NUM_RSS; i++)\n\t\tif (rss == res->rss[i])\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstruct mlx5e_rss *mlx5e_rx_res_rss_get(struct mlx5e_rx_res *res, u32 rss_idx)\n{\n\tif (rss_idx >= MLX5E_MAX_NUM_RSS)\n\t\treturn NULL;\n\n\treturn res->rss[rss_idx];\n}\n\n \n\nstruct mlx5e_rx_res *mlx5e_rx_res_alloc(void)\n{\n\treturn kvzalloc(sizeof(struct mlx5e_rx_res), GFP_KERNEL);\n}\n\nstatic int mlx5e_rx_res_channels_init(struct mlx5e_rx_res *res)\n{\n\tbool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;\n\tstruct mlx5e_tir_builder *builder;\n\tint err = 0;\n\tint ix;\n\n\tbuilder = mlx5e_tir_builder_alloc(false);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\tres->channels = kvcalloc(res->max_nch, sizeof(*res->channels), GFP_KERNEL);\n\tif (!res->channels) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (ix = 0; ix < res->max_nch; ix++) {\n\t\terr = mlx5e_rqt_init_direct(&res->channels[ix].direct_rqt,\n\t\t\t\t\t    res->mdev, false, res->drop_rqn);\n\t\tif (err) {\n\t\t\tmlx5_core_warn(res->mdev, \"Failed to create a direct RQT: err = %d, ix = %u\\n\",\n\t\t\t\t       err, ix);\n\t\t\tgoto err_destroy_direct_rqts;\n\t\t}\n\t}\n\n\tfor (ix = 0; ix < res->max_nch; ix++) {\n\t\tmlx5e_tir_builder_build_rqt(builder, res->mdev->mlx5e_res.hw_objs.td.tdn,\n\t\t\t\t\t    mlx5e_rqt_get_rqtn(&res->channels[ix].direct_rqt),\n\t\t\t\t\t    inner_ft_support);\n\t\tmlx5e_tir_builder_build_packet_merge(builder, &res->pkt_merge_param);\n\t\tmlx5e_tir_builder_build_direct(builder);\n\n\t\terr = mlx5e_tir_init(&res->channels[ix].direct_tir, builder, res->mdev, true);\n\t\tif (err) {\n\t\t\tmlx5_core_warn(res->mdev, \"Failed to create a direct TIR: err = %d, ix = %u\\n\",\n\t\t\t\t       err, ix);\n\t\t\tgoto err_destroy_direct_tirs;\n\t\t}\n\n\t\tmlx5e_tir_builder_clear(builder);\n\t}\n\n\tgoto out;\n\nerr_destroy_direct_tirs:\n\twhile (--ix >= 0)\n\t\tmlx5e_tir_destroy(&res->channels[ix].direct_tir);\n\n\tix = res->max_nch;\nerr_destroy_direct_rqts:\n\twhile (--ix >= 0)\n\t\tmlx5e_rqt_destroy(&res->channels[ix].direct_rqt);\n\n\tkvfree(res->channels);\n\nout:\n\tmlx5e_tir_builder_free(builder);\n\n\treturn err;\n}\n\nstatic int mlx5e_rx_res_ptp_init(struct mlx5e_rx_res *res)\n{\n\tbool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;\n\tstruct mlx5e_tir_builder *builder;\n\tint err;\n\n\tbuilder = mlx5e_tir_builder_alloc(false);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\terr = mlx5e_rqt_init_direct(&res->ptp.rqt, res->mdev, false, res->drop_rqn);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tmlx5e_tir_builder_build_rqt(builder, res->mdev->mlx5e_res.hw_objs.td.tdn,\n\t\t\t\t    mlx5e_rqt_get_rqtn(&res->ptp.rqt),\n\t\t\t\t    inner_ft_support);\n\tmlx5e_tir_builder_build_direct(builder);\n\n\terr = mlx5e_tir_init(&res->ptp.tir, builder, res->mdev, true);\n\tif (err)\n\t\tgoto err_destroy_ptp_rqt;\n\n\tgoto out;\n\nerr_destroy_ptp_rqt:\n\tmlx5e_rqt_destroy(&res->ptp.rqt);\n\nout:\n\tmlx5e_tir_builder_free(builder);\n\treturn err;\n}\n\nstatic void mlx5e_rx_res_channels_destroy(struct mlx5e_rx_res *res)\n{\n\tunsigned int ix;\n\n\tfor (ix = 0; ix < res->max_nch; ix++) {\n\t\tmlx5e_tir_destroy(&res->channels[ix].direct_tir);\n\t\tmlx5e_rqt_destroy(&res->channels[ix].direct_rqt);\n\t}\n\n\tkvfree(res->channels);\n}\n\nstatic void mlx5e_rx_res_ptp_destroy(struct mlx5e_rx_res *res)\n{\n\tmlx5e_tir_destroy(&res->ptp.tir);\n\tmlx5e_rqt_destroy(&res->ptp.rqt);\n}\n\nint mlx5e_rx_res_init(struct mlx5e_rx_res *res, struct mlx5_core_dev *mdev,\n\t\t      enum mlx5e_rx_res_features features, unsigned int max_nch,\n\t\t      u32 drop_rqn, const struct mlx5e_packet_merge_param *init_pkt_merge_param,\n\t\t      unsigned int init_nch)\n{\n\tint err;\n\n\tres->mdev = mdev;\n\tres->features = features;\n\tres->max_nch = max_nch;\n\tres->drop_rqn = drop_rqn;\n\n\tres->pkt_merge_param = *init_pkt_merge_param;\n\tinit_rwsem(&res->pkt_merge_param_sem);\n\n\terr = mlx5e_rx_res_rss_init_def(res, init_nch);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = mlx5e_rx_res_channels_init(res);\n\tif (err)\n\t\tgoto err_rss_destroy;\n\n\terr = mlx5e_rx_res_ptp_init(res);\n\tif (err)\n\t\tgoto err_channels_destroy;\n\n\treturn 0;\n\nerr_channels_destroy:\n\tmlx5e_rx_res_channels_destroy(res);\nerr_rss_destroy:\n\t__mlx5e_rx_res_rss_destroy(res, 0);\nerr_out:\n\treturn err;\n}\n\nvoid mlx5e_rx_res_destroy(struct mlx5e_rx_res *res)\n{\n\tmlx5e_rx_res_ptp_destroy(res);\n\tmlx5e_rx_res_channels_destroy(res);\n\tmlx5e_rx_res_rss_destroy_all(res);\n}\n\nvoid mlx5e_rx_res_free(struct mlx5e_rx_res *res)\n{\n\tkvfree(res);\n}\n\nu32 mlx5e_rx_res_get_tirn_direct(struct mlx5e_rx_res *res, unsigned int ix)\n{\n\treturn mlx5e_tir_get_tirn(&res->channels[ix].direct_tir);\n}\n\nu32 mlx5e_rx_res_get_tirn_rss(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)\n{\n\tstruct mlx5e_rss *rss = res->rss[0];\n\n\treturn mlx5e_rss_get_tirn(rss, tt, false);\n}\n\nu32 mlx5e_rx_res_get_tirn_rss_inner(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)\n{\n\tstruct mlx5e_rss *rss = res->rss[0];\n\n\treturn mlx5e_rss_get_tirn(rss, tt, true);\n}\n\nu32 mlx5e_rx_res_get_tirn_ptp(struct mlx5e_rx_res *res)\n{\n\tWARN_ON(!(res->features & MLX5E_RX_RES_FEATURE_PTP));\n\treturn mlx5e_tir_get_tirn(&res->ptp.tir);\n}\n\nstatic u32 mlx5e_rx_res_get_rqtn_direct(struct mlx5e_rx_res *res, unsigned int ix)\n{\n\treturn mlx5e_rqt_get_rqtn(&res->channels[ix].direct_rqt);\n}\n\nstatic void mlx5e_rx_res_channel_activate_direct(struct mlx5e_rx_res *res,\n\t\t\t\t\t\t struct mlx5e_channels *chs,\n\t\t\t\t\t\t unsigned int ix)\n{\n\tu32 rqn = res->rss_rqns[ix];\n\tint err;\n\n\terr = mlx5e_rqt_redirect_direct(&res->channels[ix].direct_rqt, rqn);\n\tif (err)\n\t\tmlx5_core_warn(res->mdev, \"Failed to redirect direct RQT %#x to RQ %#x (channel %u): err = %d\\n\",\n\t\t\t       mlx5e_rqt_get_rqtn(&res->channels[ix].direct_rqt),\n\t\t\t       rqn, ix, err);\n}\n\nstatic void mlx5e_rx_res_channel_deactivate_direct(struct mlx5e_rx_res *res,\n\t\t\t\t\t\t   unsigned int ix)\n{\n\tint err;\n\n\terr = mlx5e_rqt_redirect_direct(&res->channels[ix].direct_rqt, res->drop_rqn);\n\tif (err)\n\t\tmlx5_core_warn(res->mdev, \"Failed to redirect direct RQT %#x to drop RQ %#x (channel %u): err = %d\\n\",\n\t\t\t       mlx5e_rqt_get_rqtn(&res->channels[ix].direct_rqt),\n\t\t\t       res->drop_rqn, ix, err);\n}\n\nvoid mlx5e_rx_res_channels_activate(struct mlx5e_rx_res *res, struct mlx5e_channels *chs)\n{\n\tunsigned int nch, ix;\n\tint err;\n\n\tnch = mlx5e_channels_get_num(chs);\n\n\tfor (ix = 0; ix < chs->num; ix++) {\n\t\tif (mlx5e_channels_is_xsk(chs, ix))\n\t\t\tmlx5e_channels_get_xsk_rqn(chs, ix, &res->rss_rqns[ix]);\n\t\telse\n\t\t\tmlx5e_channels_get_regular_rqn(chs, ix, &res->rss_rqns[ix]);\n\t}\n\tres->rss_nch = chs->num;\n\n\tmlx5e_rx_res_rss_enable(res);\n\n\tfor (ix = 0; ix < nch; ix++)\n\t\tmlx5e_rx_res_channel_activate_direct(res, chs, ix);\n\tfor (ix = nch; ix < res->max_nch; ix++)\n\t\tmlx5e_rx_res_channel_deactivate_direct(res, ix);\n\n\tif (res->features & MLX5E_RX_RES_FEATURE_PTP) {\n\t\tu32 rqn;\n\n\t\tif (!mlx5e_channels_get_ptp_rqn(chs, &rqn))\n\t\t\trqn = res->drop_rqn;\n\n\t\terr = mlx5e_rqt_redirect_direct(&res->ptp.rqt, rqn);\n\t\tif (err)\n\t\t\tmlx5_core_warn(res->mdev, \"Failed to redirect direct RQT %#x to RQ %#x (PTP): err = %d\\n\",\n\t\t\t\t       mlx5e_rqt_get_rqtn(&res->ptp.rqt),\n\t\t\t\t       rqn, err);\n\t}\n}\n\nvoid mlx5e_rx_res_channels_deactivate(struct mlx5e_rx_res *res)\n{\n\tunsigned int ix;\n\tint err;\n\n\tmlx5e_rx_res_rss_disable(res);\n\n\tfor (ix = 0; ix < res->max_nch; ix++)\n\t\tmlx5e_rx_res_channel_deactivate_direct(res, ix);\n\n\tif (res->features & MLX5E_RX_RES_FEATURE_PTP) {\n\t\terr = mlx5e_rqt_redirect_direct(&res->ptp.rqt, res->drop_rqn);\n\t\tif (err)\n\t\t\tmlx5_core_warn(res->mdev, \"Failed to redirect direct RQT %#x to drop RQ %#x (PTP): err = %d\\n\",\n\t\t\t\t       mlx5e_rqt_get_rqtn(&res->ptp.rqt),\n\t\t\t\t       res->drop_rqn, err);\n\t}\n}\n\nvoid mlx5e_rx_res_xsk_update(struct mlx5e_rx_res *res, struct mlx5e_channels *chs,\n\t\t\t     unsigned int ix, bool xsk)\n{\n\tif (xsk)\n\t\tmlx5e_channels_get_xsk_rqn(chs, ix, &res->rss_rqns[ix]);\n\telse\n\t\tmlx5e_channels_get_regular_rqn(chs, ix, &res->rss_rqns[ix]);\n\n\tmlx5e_rx_res_rss_enable(res);\n\n\tmlx5e_rx_res_channel_activate_direct(res, chs, ix);\n}\n\nint mlx5e_rx_res_packet_merge_set_param(struct mlx5e_rx_res *res,\n\t\t\t\t\tstruct mlx5e_packet_merge_param *pkt_merge_param)\n{\n\tstruct mlx5e_tir_builder *builder;\n\tint err, final_err;\n\tunsigned int ix;\n\n\tbuilder = mlx5e_tir_builder_alloc(true);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\tdown_write(&res->pkt_merge_param_sem);\n\tres->pkt_merge_param = *pkt_merge_param;\n\n\tmlx5e_tir_builder_build_packet_merge(builder, pkt_merge_param);\n\n\tfinal_err = 0;\n\n\tfor (ix = 0; ix < MLX5E_MAX_NUM_RSS; ix++) {\n\t\tstruct mlx5e_rss *rss = res->rss[ix];\n\n\t\tif (!rss)\n\t\t\tcontinue;\n\n\t\terr = mlx5e_rss_packet_merge_set_param(rss, pkt_merge_param);\n\t\tif (err)\n\t\t\tfinal_err = final_err ? : err;\n\t}\n\n\tfor (ix = 0; ix < res->max_nch; ix++) {\n\t\terr = mlx5e_tir_modify(&res->channels[ix].direct_tir, builder);\n\t\tif (err) {\n\t\t\tmlx5_core_warn(res->mdev, \"Failed to update packet merge state of direct TIR %#x for channel %u: err = %d\\n\",\n\t\t\t\t       mlx5e_tir_get_tirn(&res->channels[ix].direct_tir), ix, err);\n\t\t\tif (!final_err)\n\t\t\t\tfinal_err = err;\n\t\t}\n\t}\n\n\tup_write(&res->pkt_merge_param_sem);\n\tmlx5e_tir_builder_free(builder);\n\treturn final_err;\n}\n\nstruct mlx5e_rss_params_hash mlx5e_rx_res_get_current_hash(struct mlx5e_rx_res *res)\n{\n\treturn mlx5e_rss_get_hash(res->rss[0]);\n}\n\nint mlx5e_rx_res_tls_tir_create(struct mlx5e_rx_res *res, unsigned int rxq,\n\t\t\t\tstruct mlx5e_tir *tir)\n{\n\tbool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;\n\tstruct mlx5e_tir_builder *builder;\n\tu32 rqtn;\n\tint err;\n\n\tbuilder = mlx5e_tir_builder_alloc(false);\n\tif (!builder)\n\t\treturn -ENOMEM;\n\n\trqtn = mlx5e_rx_res_get_rqtn_direct(res, rxq);\n\n\tmlx5e_tir_builder_build_rqt(builder, res->mdev->mlx5e_res.hw_objs.td.tdn, rqtn,\n\t\t\t\t    inner_ft_support);\n\tmlx5e_tir_builder_build_direct(builder);\n\tmlx5e_tir_builder_build_tls(builder);\n\tdown_read(&res->pkt_merge_param_sem);\n\tmlx5e_tir_builder_build_packet_merge(builder, &res->pkt_merge_param);\n\terr = mlx5e_tir_init(tir, builder, res->mdev, false);\n\tup_read(&res->pkt_merge_param_sem);\n\n\tmlx5e_tir_builder_free(builder);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}