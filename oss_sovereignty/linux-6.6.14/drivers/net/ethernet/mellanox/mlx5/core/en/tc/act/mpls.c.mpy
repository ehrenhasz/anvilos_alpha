{
  "module_name": "mpls.c",
  "hash_id": "40ed008b80f747c336f3a85f225c4dc711f8ba3408b912f188ad28bcaada7d01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mpls.c",
  "human_readable_source": "\n\n\n#include <net/bareudp.h>\n#include \"act.h\"\n#include \"en/tc_priv.h\"\n\nstatic bool\ntc_act_can_offload_mpls_push(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t\t     const struct flow_action_entry *act,\n\t\t\t     int act_index,\n\t\t\t     struct mlx5_flow_attr *attr)\n{\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct mlx5e_priv *priv = parse_state->flow->priv;\n\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev, reformat_l2_to_l3_tunnel) ||\n\t    act->mpls_push.proto != htons(ETH_P_MPLS_UC)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"mpls push is supported only for mpls_uc protocol\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\ncopy_mpls_info(struct mlx5e_mpls_info *mpls_info,\n\t       const struct flow_action_entry *act)\n{\n\tmpls_info->label = act->mpls_push.label;\n\tmpls_info->tc = act->mpls_push.tc;\n\tmpls_info->bos = act->mpls_push.bos;\n\tmpls_info->ttl = act->mpls_push.ttl;\n}\n\nstatic int\ntc_act_parse_mpls_push(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t       const struct flow_action_entry *act,\n\t\t       struct mlx5e_priv *priv,\n\t\t       struct mlx5_flow_attr *attr)\n{\n\tparse_state->mpls_push = true;\n\tcopy_mpls_info(&parse_state->mpls_info, act);\n\n\treturn 0;\n}\n\nstatic bool\ntc_act_can_offload_mpls_pop(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t\t    const struct flow_action_entry *act,\n\t\t\t    int act_index,\n\t\t\t    struct mlx5_flow_attr *attr)\n{\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct net_device *filter_dev;\n\n\tfilter_dev = attr->parse_attr->filter_dev;\n\n\t \n\tif ((act_index == 1 && !parse_state->decap) || act_index > 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"mpls pop supported only as first action or with decap\");\n\t\treturn false;\n\t}\n\n\tif (!netif_is_bareudp(filter_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"mpls pop supported only on bareudp devices\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int\ntc_act_parse_mpls_pop(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t      const struct flow_action_entry *act,\n\t\t      struct mlx5e_priv *priv,\n\t\t      struct mlx5_flow_attr *attr)\n{\n\tattr->esw_attr->eth.h_proto = act->mpls_pop.proto;\n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\tflow_flag_set(parse_state->flow, L3_TO_L2_DECAP);\n\n\treturn 0;\n}\n\nstruct mlx5e_tc_act mlx5e_tc_act_mpls_push = {\n\t.can_offload = tc_act_can_offload_mpls_push,\n\t.parse_action = tc_act_parse_mpls_push,\n};\n\nstruct mlx5e_tc_act mlx5e_tc_act_mpls_pop = {\n\t.can_offload = tc_act_can_offload_mpls_pop,\n\t.parse_action = tc_act_parse_mpls_pop,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}