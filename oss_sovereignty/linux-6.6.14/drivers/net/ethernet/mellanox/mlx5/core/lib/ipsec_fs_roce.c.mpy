{
  "module_name": "ipsec_fs_roce.c",
  "hash_id": "52f776605b48129a85ffb974fcb7cadc621537301f3edec72bd0c2277d6f15c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/ipsec_fs_roce.c",
  "human_readable_source": "\n \n\n#include \"fs_core.h\"\n#include \"lib/ipsec_fs_roce.h\"\n#include \"mlx5_core.h\"\n\nstruct mlx5_ipsec_miss {\n\tstruct mlx5_flow_group *group;\n\tstruct mlx5_flow_handle *rule;\n};\n\nstruct mlx5_ipsec_rx_roce {\n\tstruct mlx5_flow_group *g;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_ipsec_miss roce_miss;\n\n\tstruct mlx5_flow_table *ft_rdma;\n\tstruct mlx5_flow_namespace *ns_rdma;\n};\n\nstruct mlx5_ipsec_tx_roce {\n\tstruct mlx5_flow_group *g;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_namespace *ns;\n};\n\nstruct mlx5_ipsec_fs {\n\tstruct mlx5_ipsec_rx_roce ipv4_rx;\n\tstruct mlx5_ipsec_rx_roce ipv6_rx;\n\tstruct mlx5_ipsec_tx_roce tx;\n};\n\nstatic void ipsec_fs_roce_setup_udp_dport(struct mlx5_flow_spec *spec,\n\t\t\t\t\t  u16 dport)\n{\n\tspec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, IPPROTO_UDP);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.udp_dport);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.udp_dport, dport);\n}\n\nstatic int\nipsec_fs_roce_rx_rule_setup(struct mlx5_core_dev *mdev,\n\t\t\t    struct mlx5_flow_destination *default_dst,\n\t\t\t    struct mlx5_ipsec_rx_roce *roce)\n{\n\tstruct mlx5_flow_destination dst = {};\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tipsec_fs_roce_setup_udp_dport(spec, ROCE_V2_UDP_DPORT);\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tdst.type = MLX5_FLOW_DESTINATION_TYPE_TABLE_TYPE;\n\tdst.ft = roce->ft_rdma;\n\trule = mlx5_add_flow_rules(roce->ft, spec, &flow_act, &dst, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Fail to add RX RoCE IPsec rule err=%d\\n\",\n\t\t\t      err);\n\t\tgoto fail_add_rule;\n\t}\n\n\troce->rule = rule;\n\n\tmemset(spec, 0, sizeof(*spec));\n\trule = mlx5_add_flow_rules(roce->ft, spec, &flow_act, default_dst, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Fail to add RX RoCE IPsec miss rule err=%d\\n\",\n\t\t\t      err);\n\t\tgoto fail_add_default_rule;\n\t}\n\n\troce->roce_miss.rule = rule;\n\n\tkvfree(spec);\n\treturn 0;\n\nfail_add_default_rule:\n\tmlx5_del_flow_rules(roce->rule);\nfail_add_rule:\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic int ipsec_fs_roce_tx_rule_setup(struct mlx5_core_dev *mdev,\n\t\t\t\t       struct mlx5_ipsec_tx_roce *roce,\n\t\t\t\t       struct mlx5_flow_table *pol_ft)\n{\n\tstruct mlx5_flow_destination dst = {};\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tint err = 0;\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tdst.type = MLX5_FLOW_DESTINATION_TYPE_TABLE_TYPE;\n\tdst.ft = pol_ft;\n\trule = mlx5_add_flow_rules(roce->ft, NULL, &flow_act, &dst,\n\t\t\t\t   1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Fail to add TX RoCE IPsec rule err=%d\\n\",\n\t\t\t      err);\n\t\tgoto out;\n\t}\n\troce->rule = rule;\n\nout:\n\treturn err;\n}\n\nvoid mlx5_ipsec_fs_roce_tx_destroy(struct mlx5_ipsec_fs *ipsec_roce)\n{\n\tstruct mlx5_ipsec_tx_roce *tx_roce;\n\n\tif (!ipsec_roce)\n\t\treturn;\n\n\ttx_roce = &ipsec_roce->tx;\n\n\tmlx5_del_flow_rules(tx_roce->rule);\n\tmlx5_destroy_flow_group(tx_roce->g);\n\tmlx5_destroy_flow_table(tx_roce->ft);\n}\n\n#define MLX5_TX_ROCE_GROUP_SIZE BIT(0)\n\nint mlx5_ipsec_fs_roce_tx_create(struct mlx5_core_dev *mdev,\n\t\t\t\t struct mlx5_ipsec_fs *ipsec_roce,\n\t\t\t\t struct mlx5_flow_table *pol_ft)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_ipsec_tx_roce *roce;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_group *g;\n\tint ix = 0;\n\tint err;\n\tu32 *in;\n\n\tif (!ipsec_roce)\n\t\treturn 0;\n\n\troce = &ipsec_roce->tx;\n\n\tin = kvzalloc(MLX5_ST_SZ_BYTES(create_flow_group_in), GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tft_attr.max_fte = 1;\n\tft = mlx5_create_flow_table(roce->ns, &ft_attr);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec tx ft err=%d\\n\", err);\n\t\tgoto free_in;\n\t}\n\n\troce->ft = ft;\n\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_TX_ROCE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tg = mlx5_create_flow_group(ft, in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec tx group err=%d\\n\", err);\n\t\tgoto destroy_table;\n\t}\n\troce->g = g;\n\n\terr = ipsec_fs_roce_tx_rule_setup(mdev, roce, pol_ft);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec tx rules err=%d\\n\", err);\n\t\tgoto destroy_group;\n\t}\n\n\tkvfree(in);\n\treturn 0;\n\ndestroy_group:\n\tmlx5_destroy_flow_group(roce->g);\ndestroy_table:\n\tmlx5_destroy_flow_table(ft);\nfree_in:\n\tkvfree(in);\n\treturn err;\n}\n\nstruct mlx5_flow_table *mlx5_ipsec_fs_roce_ft_get(struct mlx5_ipsec_fs *ipsec_roce, u32 family)\n{\n\tstruct mlx5_ipsec_rx_roce *rx_roce;\n\n\tif (!ipsec_roce)\n\t\treturn NULL;\n\n\trx_roce = (family == AF_INET) ? &ipsec_roce->ipv4_rx :\n\t\t\t\t\t&ipsec_roce->ipv6_rx;\n\n\treturn rx_roce->ft;\n}\n\nvoid mlx5_ipsec_fs_roce_rx_destroy(struct mlx5_ipsec_fs *ipsec_roce, u32 family)\n{\n\tstruct mlx5_ipsec_rx_roce *rx_roce;\n\n\tif (!ipsec_roce)\n\t\treturn;\n\n\trx_roce = (family == AF_INET) ? &ipsec_roce->ipv4_rx :\n\t\t\t\t\t&ipsec_roce->ipv6_rx;\n\n\tmlx5_del_flow_rules(rx_roce->roce_miss.rule);\n\tmlx5_del_flow_rules(rx_roce->rule);\n\tmlx5_destroy_flow_table(rx_roce->ft_rdma);\n\tmlx5_destroy_flow_group(rx_roce->roce_miss.group);\n\tmlx5_destroy_flow_group(rx_roce->g);\n\tmlx5_destroy_flow_table(rx_roce->ft);\n}\n\n#define MLX5_RX_ROCE_GROUP_SIZE BIT(0)\n\nint mlx5_ipsec_fs_roce_rx_create(struct mlx5_core_dev *mdev,\n\t\t\t\t struct mlx5_ipsec_fs *ipsec_roce,\n\t\t\t\t struct mlx5_flow_namespace *ns,\n\t\t\t\t struct mlx5_flow_destination *default_dst,\n\t\t\t\t u32 family, u32 level, u32 prio)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_ipsec_rx_roce *roce;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_group *g;\n\tvoid *outer_headers_c;\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tif (!ipsec_roce)\n\t\treturn 0;\n\n\troce = (family == AF_INET) ? &ipsec_roce->ipv4_rx :\n\t\t\t\t     &ipsec_roce->ipv6_rx;\n\n\tft_attr.max_fte = 2;\n\tft_attr.level = level;\n\tft_attr.prio = prio;\n\tft = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec rx ft at nic err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\troce->ft = ft;\n\n\tin = kvzalloc(MLX5_ST_SZ_BYTES(create_flow_group_in), GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_nomem;\n\t}\n\n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\touter_headers_c = MLX5_ADDR_OF(fte_match_param, mc, outer_headers);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ip_protocol);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, udp_dport);\n\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_RX_ROCE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tg = mlx5_create_flow_group(ft, in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec rx group at nic err=%d\\n\", err);\n\t\tgoto fail_group;\n\t}\n\troce->g = g;\n\n\tmemset(in, 0, MLX5_ST_SZ_BYTES(create_flow_group_in));\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_RX_ROCE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tg = mlx5_create_flow_group(ft, in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec rx miss group at nic err=%d\\n\", err);\n\t\tgoto fail_mgroup;\n\t}\n\troce->roce_miss.group = g;\n\n\tmemset(&ft_attr, 0, sizeof(ft_attr));\n\tif (family == AF_INET)\n\t\tft_attr.level = 1;\n\tft = mlx5_create_flow_table(roce->ns_rdma, &ft_attr);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec rx ft at rdma err=%d\\n\", err);\n\t\tgoto fail_rdma_table;\n\t}\n\n\troce->ft_rdma = ft;\n\n\terr = ipsec_fs_roce_rx_rule_setup(mdev, default_dst, roce);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Fail to create RoCE IPsec rx rules err=%d\\n\", err);\n\t\tgoto fail_setup_rule;\n\t}\n\n\tkvfree(in);\n\treturn 0;\n\nfail_setup_rule:\n\tmlx5_destroy_flow_table(roce->ft_rdma);\nfail_rdma_table:\n\tmlx5_destroy_flow_group(roce->roce_miss.group);\nfail_mgroup:\n\tmlx5_destroy_flow_group(roce->g);\nfail_group:\n\tkvfree(in);\nfail_nomem:\n\tmlx5_destroy_flow_table(roce->ft);\n\treturn err;\n}\n\nvoid mlx5_ipsec_fs_roce_cleanup(struct mlx5_ipsec_fs *ipsec_roce)\n{\n\tkfree(ipsec_roce);\n}\n\nstruct mlx5_ipsec_fs *mlx5_ipsec_fs_roce_init(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_ipsec_fs *roce_ipsec;\n\tstruct mlx5_flow_namespace *ns;\n\n\tns = mlx5_get_flow_namespace(mdev, MLX5_FLOW_NAMESPACE_RDMA_RX_IPSEC);\n\tif (!ns) {\n\t\tmlx5_core_err(mdev, \"Failed to get RoCE rx ns\\n\");\n\t\treturn NULL;\n\t}\n\n\troce_ipsec = kzalloc(sizeof(*roce_ipsec), GFP_KERNEL);\n\tif (!roce_ipsec)\n\t\treturn NULL;\n\n\troce_ipsec->ipv4_rx.ns_rdma = ns;\n\troce_ipsec->ipv6_rx.ns_rdma = ns;\n\n\tns = mlx5_get_flow_namespace(mdev, MLX5_FLOW_NAMESPACE_RDMA_TX_IPSEC);\n\tif (!ns) {\n\t\tmlx5_core_err(mdev, \"Failed to get RoCE tx ns\\n\");\n\t\tgoto err_tx;\n\t}\n\n\troce_ipsec->tx.ns = ns;\n\n\treturn roce_ipsec;\n\nerr_tx:\n\tkfree(roce_ipsec);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}