{
  "module_name": "ktls_txrx.c",
  "hash_id": "ac98f2b88054609a102817af7a391e14aed9bf5af8c8d0e657cb0b7c2ebd87cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_txrx.c",
  "human_readable_source": "\n \n\n#include \"en_accel/ktls_txrx.h\"\n#include \"en_accel/ktls_utils.h\"\n\nenum {\n\tMLX5E_STATIC_PARAMS_CONTEXT_TLS_1_2 = 0x2,\n};\n\nenum {\n\tMLX5E_ENCRYPTION_STANDARD_TLS = 0x1,\n};\n\n#define EXTRACT_INFO_FIELDS do { \\\n\tsalt    = info->salt;    \\\n\trec_seq = info->rec_seq; \\\n\tsalt_sz    = sizeof(info->salt);    \\\n\trec_seq_sz = sizeof(info->rec_seq); \\\n} while (0)\n\nstatic void\nfill_static_params(struct mlx5_wqe_tls_static_params_seg *params,\n\t\t   union mlx5e_crypto_info *crypto_info,\n\t\t   u32 key_id, u32 resync_tcp_sn)\n{\n\tchar *initial_rn, *gcm_iv;\n\tu16 salt_sz, rec_seq_sz;\n\tchar *salt, *rec_seq;\n\tu8 tls_version;\n\tu8 *ctx;\n\n\tctx = params->ctx;\n\n\tswitch (crypto_info->crypto_info.cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128: {\n\t\tstruct tls12_crypto_info_aes_gcm_128 *info =\n\t\t\t&crypto_info->crypto_info_128;\n\n\t\tEXTRACT_INFO_FIELDS;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_GCM_256: {\n\t\tstruct tls12_crypto_info_aes_gcm_256 *info =\n\t\t\t&crypto_info->crypto_info_256;\n\n\t\tEXTRACT_INFO_FIELDS;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ONCE(1, \"Unsupported cipher type %u\\n\",\n\t\t\t  crypto_info->crypto_info.cipher_type);\n\t\treturn;\n\t}\n\n\tgcm_iv      = MLX5_ADDR_OF(tls_static_params, ctx, gcm_iv);\n\tinitial_rn  = MLX5_ADDR_OF(tls_static_params, ctx, initial_record_number);\n\n\tmemcpy(gcm_iv,      salt,    salt_sz);\n\tmemcpy(initial_rn,  rec_seq, rec_seq_sz);\n\n\ttls_version = MLX5E_STATIC_PARAMS_CONTEXT_TLS_1_2;\n\n\tMLX5_SET(tls_static_params, ctx, tls_version, tls_version);\n\tMLX5_SET(tls_static_params, ctx, const_1, 1);\n\tMLX5_SET(tls_static_params, ctx, const_2, 2);\n\tMLX5_SET(tls_static_params, ctx, encryption_standard,\n\t\t MLX5E_ENCRYPTION_STANDARD_TLS);\n\tMLX5_SET(tls_static_params, ctx, resync_tcp_sn, resync_tcp_sn);\n\tMLX5_SET(tls_static_params, ctx, dek_index, key_id);\n}\n\nvoid\nmlx5e_ktls_build_static_params(struct mlx5e_set_tls_static_params_wqe *wqe,\n\t\t\t       u16 pc, u32 sqn,\n\t\t\t       union mlx5e_crypto_info *crypto_info,\n\t\t\t       u32 tis_tir_num, u32 key_id, u32 resync_tcp_sn,\n\t\t\t       bool fence, enum tls_offload_ctx_dir direction)\n{\n\tstruct mlx5_wqe_umr_ctrl_seg *ucseg = &wqe->uctrl;\n\tstruct mlx5_wqe_ctrl_seg     *cseg  = &wqe->ctrl;\n\tu8 opmod = direction == TLS_OFFLOAD_CTX_DIR_TX ?\n\t\tMLX5_OPC_MOD_TLS_TIS_STATIC_PARAMS :\n\t\tMLX5_OPC_MOD_TLS_TIR_STATIC_PARAMS;\n\n#define STATIC_PARAMS_DS_CNT DIV_ROUND_UP(sizeof(*wqe), MLX5_SEND_WQE_DS)\n\n\tcseg->opmod_idx_opcode = cpu_to_be32((pc << 8) | MLX5_OPCODE_UMR | (opmod << 24));\n\tcseg->qpn_ds           = cpu_to_be32((sqn << MLX5_WQE_CTRL_QPN_SHIFT) |\n\t\t\t\t\t     STATIC_PARAMS_DS_CNT);\n\tcseg->fm_ce_se         = fence ? MLX5_FENCE_MODE_INITIATOR_SMALL : 0;\n\tcseg->tis_tir_num      = cpu_to_be32(tis_tir_num << 8);\n\n\tucseg->flags = MLX5_UMR_INLINE;\n\tucseg->bsf_octowords = cpu_to_be16(MLX5_ST_SZ_BYTES(tls_static_params) / 16);\n\n\tfill_static_params(&wqe->params, crypto_info, key_id, resync_tcp_sn);\n}\n\nstatic void\nfill_progress_params(struct mlx5_wqe_tls_progress_params_seg *params, u32 tis_tir_num,\n\t\t     u32 next_record_tcp_sn)\n{\n\tu8 *ctx = params->ctx;\n\n\tparams->tis_tir_num = cpu_to_be32(tis_tir_num);\n\n\tMLX5_SET(tls_progress_params, ctx, next_record_tcp_sn,\n\t\t next_record_tcp_sn);\n\tMLX5_SET(tls_progress_params, ctx, record_tracker_state,\n\t\t MLX5E_TLS_PROGRESS_PARAMS_RECORD_TRACKER_STATE_START);\n\tMLX5_SET(tls_progress_params, ctx, auth_state,\n\t\t MLX5E_TLS_PROGRESS_PARAMS_AUTH_STATE_NO_OFFLOAD);\n}\n\nvoid\nmlx5e_ktls_build_progress_params(struct mlx5e_set_tls_progress_params_wqe *wqe,\n\t\t\t\t u16 pc, u32 sqn,\n\t\t\t\t u32 tis_tir_num, bool fence,\n\t\t\t\t u32 next_record_tcp_sn,\n\t\t\t\t enum tls_offload_ctx_dir direction)\n{\n\tstruct mlx5_wqe_ctrl_seg *cseg = &wqe->ctrl;\n\tu8 opmod = direction == TLS_OFFLOAD_CTX_DIR_TX ?\n\t\tMLX5_OPC_MOD_TLS_TIS_PROGRESS_PARAMS :\n\t\tMLX5_OPC_MOD_TLS_TIR_PROGRESS_PARAMS;\n\n#define PROGRESS_PARAMS_DS_CNT DIV_ROUND_UP(sizeof(*wqe), MLX5_SEND_WQE_DS)\n\n\tcseg->opmod_idx_opcode =\n\t\tcpu_to_be32((pc << 8) | MLX5_OPCODE_SET_PSV | (opmod << 24));\n\tcseg->qpn_ds           = cpu_to_be32((sqn << MLX5_WQE_CTRL_QPN_SHIFT) |\n\t\t\t\t\t     PROGRESS_PARAMS_DS_CNT);\n\tcseg->fm_ce_se         = fence ? MLX5_FENCE_MODE_INITIATOR_SMALL : 0;\n\n\tfill_progress_params(&wqe->params, tis_tir_num, next_record_tcp_sn);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}