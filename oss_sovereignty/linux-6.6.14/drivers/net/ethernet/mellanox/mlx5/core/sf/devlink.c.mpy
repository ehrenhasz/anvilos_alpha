{
  "module_name": "devlink.c",
  "hash_id": "b6bb69f8549d0292995a245faf5afb93988fdc87d834b35438c7222eba4149a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/sf/devlink.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/driver.h>\n#include \"eswitch.h\"\n#include \"priv.h\"\n#include \"sf/dev/dev.h\"\n#include \"mlx5_ifc_vhca_event.h\"\n#include \"vhca_event.h\"\n#include \"ecpf.h\"\n#define CREATE_TRACE_POINTS\n#include \"diag/sf_tracepoint.h\"\n\nstruct mlx5_sf {\n\tstruct mlx5_devlink_port dl_port;\n\tunsigned int port_index;\n\tu32 controller;\n\tu16 id;\n\tu16 hw_fn_id;\n\tu16 hw_state;\n};\n\nstruct mlx5_sf_table {\n\tstruct mlx5_core_dev *dev;  \n\tstruct xarray port_indices;  \n\trefcount_t refcount;\n\tstruct completion disable_complete;\n\tstruct mutex sf_state_lock;  \n\tstruct notifier_block esw_nb;\n\tstruct notifier_block vhca_nb;\n};\n\nstatic struct mlx5_sf *\nmlx5_sf_lookup_by_index(struct mlx5_sf_table *table, unsigned int port_index)\n{\n\treturn xa_load(&table->port_indices, port_index);\n}\n\nstatic struct mlx5_sf *\nmlx5_sf_lookup_by_function_id(struct mlx5_sf_table *table, unsigned int fn_id)\n{\n\tunsigned long index;\n\tstruct mlx5_sf *sf;\n\n\txa_for_each(&table->port_indices, index, sf) {\n\t\tif (sf->hw_fn_id == fn_id)\n\t\t\treturn sf;\n\t}\n\treturn NULL;\n}\n\nstatic int mlx5_sf_id_insert(struct mlx5_sf_table *table, struct mlx5_sf *sf)\n{\n\treturn xa_insert(&table->port_indices, sf->port_index, sf, GFP_KERNEL);\n}\n\nstatic void mlx5_sf_id_erase(struct mlx5_sf_table *table, struct mlx5_sf *sf)\n{\n\txa_erase(&table->port_indices, sf->port_index);\n}\n\nstatic struct mlx5_sf *\nmlx5_sf_alloc(struct mlx5_sf_table *table, struct mlx5_eswitch *esw,\n\t      u32 controller, u32 sfnum, struct netlink_ext_ack *extack)\n{\n\tunsigned int dl_port_index;\n\tstruct mlx5_sf *sf;\n\tu16 hw_fn_id;\n\tint id_err;\n\tint err;\n\n\tif (!mlx5_esw_offloads_controller_valid(esw, controller)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid controller number\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tid_err = mlx5_sf_hw_table_sf_alloc(table->dev, controller, sfnum);\n\tif (id_err < 0) {\n\t\terr = id_err;\n\t\tgoto id_err;\n\t}\n\n\tsf = kzalloc(sizeof(*sf), GFP_KERNEL);\n\tif (!sf) {\n\t\terr = -ENOMEM;\n\t\tgoto alloc_err;\n\t}\n\tsf->id = id_err;\n\thw_fn_id = mlx5_sf_sw_to_hw_id(table->dev, controller, sf->id);\n\tdl_port_index = mlx5_esw_vport_to_devlink_port_index(table->dev, hw_fn_id);\n\tsf->port_index = dl_port_index;\n\tsf->hw_fn_id = hw_fn_id;\n\tsf->hw_state = MLX5_VHCA_STATE_ALLOCATED;\n\tsf->controller = controller;\n\n\terr = mlx5_sf_id_insert(table, sf);\n\tif (err)\n\t\tgoto insert_err;\n\n\treturn sf;\n\ninsert_err:\n\tkfree(sf);\nalloc_err:\n\tmlx5_sf_hw_table_sf_free(table->dev, controller, id_err);\nid_err:\n\tif (err == -EEXIST)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"SF already exist. Choose different sfnum\");\n\treturn ERR_PTR(err);\n}\n\nstatic void mlx5_sf_free(struct mlx5_sf_table *table, struct mlx5_sf *sf)\n{\n\tmlx5_sf_id_erase(table, sf);\n\tmlx5_sf_hw_table_sf_free(table->dev, sf->controller, sf->id);\n\ttrace_mlx5_sf_free(table->dev, sf->port_index, sf->controller, sf->hw_fn_id);\n\tkfree(sf);\n}\n\nstatic struct mlx5_sf_table *mlx5_sf_table_try_get(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_table *table = dev->priv.sf_table;\n\n\tif (!table)\n\t\treturn NULL;\n\n\treturn refcount_inc_not_zero(&table->refcount) ? table : NULL;\n}\n\nstatic void mlx5_sf_table_put(struct mlx5_sf_table *table)\n{\n\tif (refcount_dec_and_test(&table->refcount))\n\t\tcomplete(&table->disable_complete);\n}\n\nstatic enum devlink_port_fn_state mlx5_sf_to_devlink_state(u8 hw_state)\n{\n\tswitch (hw_state) {\n\tcase MLX5_VHCA_STATE_ACTIVE:\n\tcase MLX5_VHCA_STATE_IN_USE:\n\t\treturn DEVLINK_PORT_FN_STATE_ACTIVE;\n\tcase MLX5_VHCA_STATE_INVALID:\n\tcase MLX5_VHCA_STATE_ALLOCATED:\n\tcase MLX5_VHCA_STATE_TEARDOWN_REQUEST:\n\tdefault:\n\t\treturn DEVLINK_PORT_FN_STATE_INACTIVE;\n\t}\n}\n\nstatic enum devlink_port_fn_opstate mlx5_sf_to_devlink_opstate(u8 hw_state)\n{\n\tswitch (hw_state) {\n\tcase MLX5_VHCA_STATE_IN_USE:\n\tcase MLX5_VHCA_STATE_TEARDOWN_REQUEST:\n\t\treturn DEVLINK_PORT_FN_OPSTATE_ATTACHED;\n\tcase MLX5_VHCA_STATE_INVALID:\n\tcase MLX5_VHCA_STATE_ALLOCATED:\n\tcase MLX5_VHCA_STATE_ACTIVE:\n\tdefault:\n\t\treturn DEVLINK_PORT_FN_OPSTATE_DETACHED;\n\t}\n}\n\nstatic bool mlx5_sf_is_active(const struct mlx5_sf *sf)\n{\n\treturn sf->hw_state == MLX5_VHCA_STATE_ACTIVE || sf->hw_state == MLX5_VHCA_STATE_IN_USE;\n}\n\nint mlx5_devlink_sf_port_fn_state_get(struct devlink_port *dl_port,\n\t\t\t\t      enum devlink_port_fn_state *state,\n\t\t\t\t      enum devlink_port_fn_opstate *opstate,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(dl_port->devlink);\n\tstruct mlx5_sf_table *table;\n\tstruct mlx5_sf *sf;\n\tint err = 0;\n\n\ttable = mlx5_sf_table_try_get(dev);\n\tif (!table)\n\t\treturn -EOPNOTSUPP;\n\n\tsf = mlx5_sf_lookup_by_index(table, dl_port->index);\n\tif (!sf) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto sf_err;\n\t}\n\tmutex_lock(&table->sf_state_lock);\n\t*state = mlx5_sf_to_devlink_state(sf->hw_state);\n\t*opstate = mlx5_sf_to_devlink_opstate(sf->hw_state);\n\tmutex_unlock(&table->sf_state_lock);\nsf_err:\n\tmlx5_sf_table_put(table);\n\treturn err;\n}\n\nstatic int mlx5_sf_activate(struct mlx5_core_dev *dev, struct mlx5_sf *sf,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (mlx5_sf_is_active(sf))\n\t\treturn 0;\n\tif (sf->hw_state != MLX5_VHCA_STATE_ALLOCATED) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"SF is inactivated but it is still attached\");\n\t\treturn -EBUSY;\n\t}\n\n\terr = mlx5_cmd_sf_enable_hca(dev, sf->hw_fn_id);\n\tif (err)\n\t\treturn err;\n\n\tsf->hw_state = MLX5_VHCA_STATE_ACTIVE;\n\ttrace_mlx5_sf_activate(dev, sf->port_index, sf->controller, sf->hw_fn_id);\n\treturn 0;\n}\n\nstatic int mlx5_sf_deactivate(struct mlx5_core_dev *dev, struct mlx5_sf *sf)\n{\n\tint err;\n\n\tif (!mlx5_sf_is_active(sf))\n\t\treturn 0;\n\n\terr = mlx5_cmd_sf_disable_hca(dev, sf->hw_fn_id);\n\tif (err)\n\t\treturn err;\n\n\tsf->hw_state = MLX5_VHCA_STATE_TEARDOWN_REQUEST;\n\ttrace_mlx5_sf_deactivate(dev, sf->port_index, sf->controller, sf->hw_fn_id);\n\treturn 0;\n}\n\nstatic int mlx5_sf_state_set(struct mlx5_core_dev *dev, struct mlx5_sf_table *table,\n\t\t\t     struct mlx5_sf *sf,\n\t\t\t     enum devlink_port_fn_state state,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint err = 0;\n\n\tmutex_lock(&table->sf_state_lock);\n\tif (state == mlx5_sf_to_devlink_state(sf->hw_state))\n\t\tgoto out;\n\tif (state == DEVLINK_PORT_FN_STATE_ACTIVE)\n\t\terr = mlx5_sf_activate(dev, sf, extack);\n\telse if (state == DEVLINK_PORT_FN_STATE_INACTIVE)\n\t\terr = mlx5_sf_deactivate(dev, sf);\n\telse\n\t\terr = -EINVAL;\nout:\n\tmutex_unlock(&table->sf_state_lock);\n\treturn err;\n}\n\nint mlx5_devlink_sf_port_fn_state_set(struct devlink_port *dl_port,\n\t\t\t\t      enum devlink_port_fn_state state,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(dl_port->devlink);\n\tstruct mlx5_sf_table *table;\n\tstruct mlx5_sf *sf;\n\tint err;\n\n\ttable = mlx5_sf_table_try_get(dev);\n\tif (!table) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port state set is only supported in eswitch switchdev mode or SF ports are disabled.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tsf = mlx5_sf_lookup_by_index(table, dl_port->index);\n\tif (!sf) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\terr = mlx5_sf_state_set(dev, table, sf, state, extack);\nout:\n\tmlx5_sf_table_put(table);\n\treturn err;\n}\n\nstatic int mlx5_sf_add(struct mlx5_core_dev *dev, struct mlx5_sf_table *table,\n\t\t       const struct devlink_port_new_attrs *new_attr,\n\t\t       struct netlink_ext_ack *extack,\n\t\t       struct devlink_port **dl_port)\n{\n\tstruct mlx5_eswitch *esw = dev->priv.eswitch;\n\tstruct mlx5_sf *sf;\n\tint err;\n\n\tsf = mlx5_sf_alloc(table, esw, new_attr->controller, new_attr->sfnum, extack);\n\tif (IS_ERR(sf))\n\t\treturn PTR_ERR(sf);\n\n\terr = mlx5_eswitch_load_sf_vport(esw, sf->hw_fn_id, MLX5_VPORT_UC_ADDR_CHANGE,\n\t\t\t\t\t &sf->dl_port, new_attr->controller, new_attr->sfnum);\n\tif (err)\n\t\tgoto esw_err;\n\t*dl_port = &sf->dl_port.dl_port;\n\ttrace_mlx5_sf_add(dev, sf->port_index, sf->controller, sf->hw_fn_id, new_attr->sfnum);\n\treturn 0;\n\nesw_err:\n\tmlx5_sf_free(table, sf);\n\treturn err;\n}\n\nstatic int\nmlx5_sf_new_check_attr(struct mlx5_core_dev *dev, const struct devlink_port_new_attrs *new_attr,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tif (new_attr->flavour != DEVLINK_PORT_FLAVOUR_PCI_SF) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Driver supports only SF port addition\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (new_attr->port_index_valid) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Driver does not support user defined port index assignment\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!new_attr->sfnum_valid) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"User must provide unique sfnum. Driver does not support auto assignment\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (new_attr->controller_valid && new_attr->controller &&\n\t    !mlx5_core_is_ecpf_esw_manager(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"External controller is unsupported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (new_attr->pfnum != mlx5_get_dev_index(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid pfnum supplied\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nint mlx5_devlink_sf_port_new(struct devlink *devlink,\n\t\t\t     const struct devlink_port_new_attrs *new_attr,\n\t\t\t     struct netlink_ext_ack *extack,\n\t\t\t     struct devlink_port **dl_port)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct mlx5_sf_table *table;\n\tint err;\n\n\terr = mlx5_sf_new_check_attr(dev, new_attr, extack);\n\tif (err)\n\t\treturn err;\n\n\ttable = mlx5_sf_table_try_get(dev);\n\tif (!table) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port add is only supported in eswitch switchdev mode or SF ports are disabled.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\terr = mlx5_sf_add(dev, table, new_attr, extack, dl_port);\n\tmlx5_sf_table_put(table);\n\treturn err;\n}\n\nstatic void mlx5_sf_dealloc(struct mlx5_sf_table *table, struct mlx5_sf *sf)\n{\n\tif (sf->hw_state == MLX5_VHCA_STATE_ALLOCATED) {\n\t\tmlx5_sf_free(table, sf);\n\t} else if (mlx5_sf_is_active(sf)) {\n\t\t \n\t\tmlx5_cmd_sf_disable_hca(table->dev, sf->hw_fn_id);\n\t\tmlx5_sf_hw_table_sf_deferred_free(table->dev, sf->controller, sf->id);\n\t\tkfree(sf);\n\t} else {\n\t\tmlx5_sf_hw_table_sf_deferred_free(table->dev, sf->controller, sf->id);\n\t\tkfree(sf);\n\t}\n}\n\nint mlx5_devlink_sf_port_del(struct devlink *devlink,\n\t\t\t     struct devlink_port *dl_port,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct mlx5_eswitch *esw = dev->priv.eswitch;\n\tstruct mlx5_sf_table *table;\n\tstruct mlx5_sf *sf;\n\tint err = 0;\n\n\ttable = mlx5_sf_table_try_get(dev);\n\tif (!table) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port del is only supported in eswitch switchdev mode or SF ports are disabled.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tsf = mlx5_sf_lookup_by_index(table, dl_port->index);\n\tif (!sf) {\n\t\terr = -ENODEV;\n\t\tgoto sf_err;\n\t}\n\n\tmlx5_eswitch_unload_sf_vport(esw, sf->hw_fn_id);\n\tmlx5_sf_id_erase(table, sf);\n\n\tmutex_lock(&table->sf_state_lock);\n\tmlx5_sf_dealloc(table, sf);\n\tmutex_unlock(&table->sf_state_lock);\nsf_err:\n\tmlx5_sf_table_put(table);\n\treturn err;\n}\n\nstatic bool mlx5_sf_state_update_check(const struct mlx5_sf *sf, u8 new_state)\n{\n\tif (sf->hw_state == MLX5_VHCA_STATE_ACTIVE && new_state == MLX5_VHCA_STATE_IN_USE)\n\t\treturn true;\n\n\tif (sf->hw_state == MLX5_VHCA_STATE_IN_USE && new_state == MLX5_VHCA_STATE_ACTIVE)\n\t\treturn true;\n\n\tif (sf->hw_state == MLX5_VHCA_STATE_TEARDOWN_REQUEST &&\n\t    new_state == MLX5_VHCA_STATE_ALLOCATED)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int mlx5_sf_vhca_event(struct notifier_block *nb, unsigned long opcode, void *data)\n{\n\tstruct mlx5_sf_table *table = container_of(nb, struct mlx5_sf_table, vhca_nb);\n\tconst struct mlx5_vhca_state_event *event = data;\n\tbool update = false;\n\tstruct mlx5_sf *sf;\n\n\ttable = mlx5_sf_table_try_get(table->dev);\n\tif (!table)\n\t\treturn 0;\n\n\tmutex_lock(&table->sf_state_lock);\n\tsf = mlx5_sf_lookup_by_function_id(table, event->function_id);\n\tif (!sf)\n\t\tgoto sf_err;\n\n\t \n\tupdate = mlx5_sf_state_update_check(sf, event->new_vhca_state);\n\tif (update)\n\t\tsf->hw_state = event->new_vhca_state;\n\ttrace_mlx5_sf_update_state(table->dev, sf->port_index, sf->controller,\n\t\t\t\t   sf->hw_fn_id, sf->hw_state);\nsf_err:\n\tmutex_unlock(&table->sf_state_lock);\n\tmlx5_sf_table_put(table);\n\treturn 0;\n}\n\nstatic void mlx5_sf_table_enable(struct mlx5_sf_table *table)\n{\n\tinit_completion(&table->disable_complete);\n\trefcount_set(&table->refcount, 1);\n}\n\nstatic void mlx5_sf_deactivate_all(struct mlx5_sf_table *table)\n{\n\tstruct mlx5_eswitch *esw = table->dev->priv.eswitch;\n\tunsigned long index;\n\tstruct mlx5_sf *sf;\n\n\t \n\txa_for_each(&table->port_indices, index, sf) {\n\t\tmlx5_eswitch_unload_sf_vport(esw, sf->hw_fn_id);\n\t\tmlx5_sf_id_erase(table, sf);\n\t\tmlx5_sf_dealloc(table, sf);\n\t}\n}\n\nstatic void mlx5_sf_table_disable(struct mlx5_sf_table *table)\n{\n\tif (!refcount_read(&table->refcount))\n\t\treturn;\n\n\t \n\tmlx5_sf_table_put(table);\n\twait_for_completion(&table->disable_complete);\n\n\tmlx5_sf_deactivate_all(table);\n}\n\nstatic int mlx5_sf_esw_event(struct notifier_block *nb, unsigned long event, void *data)\n{\n\tstruct mlx5_sf_table *table = container_of(nb, struct mlx5_sf_table, esw_nb);\n\tconst struct mlx5_esw_event_info *mode = data;\n\n\tswitch (mode->new_mode) {\n\tcase MLX5_ESWITCH_OFFLOADS:\n\t\tmlx5_sf_table_enable(table);\n\t\tbreak;\n\tcase MLX5_ESWITCH_LEGACY:\n\t\tmlx5_sf_table_disable(table);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic bool mlx5_sf_table_supported(const struct mlx5_core_dev *dev)\n{\n\treturn dev->priv.eswitch && MLX5_ESWITCH_MANAGER(dev) &&\n\t       mlx5_sf_hw_table_supported(dev);\n}\n\nint mlx5_sf_table_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_table *table;\n\tint err;\n\n\tif (!mlx5_sf_table_supported(dev) || !mlx5_vhca_event_supported(dev))\n\t\treturn 0;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&table->sf_state_lock);\n\ttable->dev = dev;\n\txa_init(&table->port_indices);\n\tdev->priv.sf_table = table;\n\trefcount_set(&table->refcount, 0);\n\ttable->esw_nb.notifier_call = mlx5_sf_esw_event;\n\terr = mlx5_esw_event_notifier_register(dev->priv.eswitch, &table->esw_nb);\n\tif (err)\n\t\tgoto reg_err;\n\n\ttable->vhca_nb.notifier_call = mlx5_sf_vhca_event;\n\terr = mlx5_vhca_event_notifier_register(table->dev, &table->vhca_nb);\n\tif (err)\n\t\tgoto vhca_err;\n\n\treturn 0;\n\nvhca_err:\n\tmlx5_esw_event_notifier_unregister(dev->priv.eswitch, &table->esw_nb);\nreg_err:\n\tmutex_destroy(&table->sf_state_lock);\n\tkfree(table);\n\tdev->priv.sf_table = NULL;\n\treturn err;\n}\n\nvoid mlx5_sf_table_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_table *table = dev->priv.sf_table;\n\n\tif (!table)\n\t\treturn;\n\n\tmlx5_vhca_event_notifier_unregister(table->dev, &table->vhca_nb);\n\tmlx5_esw_event_notifier_unregister(dev->priv.eswitch, &table->esw_nb);\n\tWARN_ON(refcount_read(&table->refcount));\n\tmutex_destroy(&table->sf_state_lock);\n\tWARN_ON(!xa_empty(&table->port_indices));\n\tkfree(table);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}