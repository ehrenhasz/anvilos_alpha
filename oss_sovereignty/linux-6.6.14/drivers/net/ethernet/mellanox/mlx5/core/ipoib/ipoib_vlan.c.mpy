{
  "module_name": "ipoib_vlan.c",
  "hash_id": "7d7e114b50b65e58e7a7f113d0ee0724aa5efca2e504c3e51e31d9f18bcb44d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib_vlan.c",
  "human_readable_source": " \n\n#include <linux/hash.h>\n#include \"ipoib.h\"\n\n#define MLX5I_MAX_LOG_PKEY_SUP 7\n\nstruct qpn_to_netdev {\n\tstruct net_device *netdev;\n\tstruct hlist_node hlist;\n\tu32 underlay_qpn;\n};\n\nstruct mlx5i_pkey_qpn_ht {\n\tstruct hlist_head buckets[1 << MLX5I_MAX_LOG_PKEY_SUP];\n\tspinlock_t ht_lock;  \n};\n\nint mlx5i_pkey_qpn_ht_init(struct net_device *netdev)\n{\n\tstruct mlx5i_priv *ipriv = netdev_priv(netdev);\n\tstruct mlx5i_pkey_qpn_ht *qpn_htbl;\n\n\tqpn_htbl = kzalloc(sizeof(*qpn_htbl), GFP_KERNEL);\n\tif (!qpn_htbl)\n\t\treturn -ENOMEM;\n\n\tipriv->qpn_htbl = qpn_htbl;\n\tspin_lock_init(&qpn_htbl->ht_lock);\n\n\treturn 0;\n}\n\nvoid mlx5i_pkey_qpn_ht_cleanup(struct net_device *netdev)\n{\n\tstruct mlx5i_priv *ipriv = netdev_priv(netdev);\n\n\tkfree(ipriv->qpn_htbl);\n}\n\nstatic struct qpn_to_netdev *mlx5i_find_qpn_to_netdev_node(struct hlist_head *buckets,\n\t\t\t\t\t\t\t   u32 qpn)\n{\n\tstruct hlist_head *h = &buckets[hash_32(qpn, MLX5I_MAX_LOG_PKEY_SUP)];\n\tstruct qpn_to_netdev *node;\n\n\thlist_for_each_entry(node, h, hlist) {\n\t\tif (node->underlay_qpn == qpn)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nint mlx5i_pkey_add_qpn(struct net_device *netdev, u32 qpn)\n{\n\tstruct mlx5i_priv *ipriv = netdev_priv(netdev);\n\tstruct mlx5i_pkey_qpn_ht *ht = ipriv->qpn_htbl;\n\tu8 key = hash_32(qpn, MLX5I_MAX_LOG_PKEY_SUP);\n\tstruct qpn_to_netdev *new_node;\n\n\tnew_node = kzalloc(sizeof(*new_node), GFP_KERNEL);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_node->netdev = netdev;\n\tnew_node->underlay_qpn = qpn;\n\tspin_lock_bh(&ht->ht_lock);\n\thlist_add_head(&new_node->hlist, &ht->buckets[key]);\n\tspin_unlock_bh(&ht->ht_lock);\n\n\treturn 0;\n}\n\nint mlx5i_pkey_del_qpn(struct net_device *netdev, u32 qpn)\n{\n\tstruct mlx5e_priv *epriv = mlx5i_epriv(netdev);\n\tstruct mlx5i_priv *ipriv = epriv->ppriv;\n\tstruct mlx5i_pkey_qpn_ht *ht = ipriv->qpn_htbl;\n\tstruct qpn_to_netdev *node;\n\n\tnode = mlx5i_find_qpn_to_netdev_node(ht->buckets, qpn);\n\tif (!node) {\n\t\tmlx5_core_warn(epriv->mdev, \"QPN to netdev delete from HT failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&ht->ht_lock);\n\thlist_del_init(&node->hlist);\n\tspin_unlock_bh(&ht->ht_lock);\n\tkfree(node);\n\n\treturn 0;\n}\n\nstruct net_device *mlx5i_pkey_get_netdev(struct net_device *netdev, u32 qpn)\n{\n\tstruct mlx5i_priv *ipriv = netdev_priv(netdev);\n\tstruct qpn_to_netdev *node;\n\n\tnode = mlx5i_find_qpn_to_netdev_node(ipriv->qpn_htbl->buckets, qpn);\n\tif (!node)\n\t\treturn NULL;\n\n\treturn node->netdev;\n}\n\nstatic int mlx5i_pkey_open(struct net_device *netdev);\nstatic int mlx5i_pkey_close(struct net_device *netdev);\nstatic int mlx5i_pkey_dev_init(struct net_device *dev);\nstatic void mlx5i_pkey_dev_cleanup(struct net_device *netdev);\nstatic int mlx5i_pkey_change_mtu(struct net_device *netdev, int new_mtu);\nstatic int mlx5i_pkey_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);\n\nstatic const struct net_device_ops mlx5i_pkey_netdev_ops = {\n\t.ndo_open                = mlx5i_pkey_open,\n\t.ndo_stop                = mlx5i_pkey_close,\n\t.ndo_init                = mlx5i_pkey_dev_init,\n\t.ndo_get_stats64         = mlx5i_get_stats,\n\t.ndo_uninit              = mlx5i_pkey_dev_cleanup,\n\t.ndo_change_mtu          = mlx5i_pkey_change_mtu,\n\t.ndo_eth_ioctl            = mlx5i_pkey_ioctl,\n};\n\n \nstatic int mlx5i_pkey_dev_init(struct net_device *dev)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\tstruct mlx5i_priv *ipriv, *parent_ipriv;\n\tstruct net_device *parent_dev;\n\n\tipriv = priv->ppriv;\n\n\t \n\tparent_dev = mlx5i_parent_get(dev);\n\tif (!parent_dev) {\n\t\tmlx5_core_warn(priv->mdev, \"failed to get parent device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->num_rx_queues < parent_dev->real_num_rx_queues) {\n\t\tmlx5_core_warn(priv->mdev,\n\t\t\t       \"failed to create child device with rx queues [%d] less than parent's [%d]\\n\",\n\t\t\t       dev->num_rx_queues,\n\t\t\t       parent_dev->real_num_rx_queues);\n\t\tmlx5i_parent_put(dev);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tparent_ipriv = netdev_priv(parent_dev);\n\tipriv->qpn_htbl = parent_ipriv->qpn_htbl;\n\n\treturn mlx5i_dev_init(dev);\n}\n\nstatic int mlx5i_pkey_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\treturn mlx5i_ioctl(dev, ifr, cmd);\n}\n\nstatic void mlx5i_pkey_dev_cleanup(struct net_device *netdev)\n{\n\tmlx5i_parent_put(netdev);\n\treturn mlx5i_dev_cleanup(netdev);\n}\n\nstatic int mlx5i_pkey_open(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *epriv = mlx5i_epriv(netdev);\n\tstruct mlx5i_priv *ipriv = epriv->ppriv;\n\tstruct mlx5_core_dev *mdev = epriv->mdev;\n\tint err;\n\n\tmutex_lock(&epriv->state_lock);\n\n\tset_bit(MLX5E_STATE_OPENED, &epriv->state);\n\n\terr = mlx5i_init_underlay_qp(epriv);\n\tif (err) {\n\t\tmlx5_core_warn(mdev, \"prepare child underlay qp state failed, %d\\n\", err);\n\t\tgoto err_release_lock;\n\t}\n\n\terr = mlx5_fs_add_rx_underlay_qpn(mdev, ipriv->qpn);\n\tif (err) {\n\t\tmlx5_core_warn(mdev, \"attach child underlay qp to ft failed, %d\\n\", err);\n\t\tgoto err_unint_underlay_qp;\n\t}\n\n\terr = mlx5i_create_tis(mdev, ipriv->qpn, &epriv->tisn[0][0]);\n\tif (err) {\n\t\tmlx5_core_warn(mdev, \"create child tis failed, %d\\n\", err);\n\t\tgoto err_remove_rx_uderlay_qp;\n\t}\n\n\terr = mlx5e_open_channels(epriv, &epriv->channels);\n\tif (err) {\n\t\tmlx5_core_warn(mdev, \"opening child channels failed, %d\\n\", err);\n\t\tgoto err_clear_state_opened_flag;\n\t}\n\terr = epriv->profile->update_rx(epriv);\n\tif (err)\n\t\tgoto err_close_channels;\n\tmlx5e_activate_priv_channels(epriv);\n\tmutex_unlock(&epriv->state_lock);\n\n\treturn 0;\n\nerr_close_channels:\n\tmlx5e_close_channels(&epriv->channels);\nerr_clear_state_opened_flag:\n\tmlx5e_destroy_tis(mdev, epriv->tisn[0][0]);\nerr_remove_rx_uderlay_qp:\n\tmlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qpn);\nerr_unint_underlay_qp:\n\tmlx5i_uninit_underlay_qp(epriv);\nerr_release_lock:\n\tclear_bit(MLX5E_STATE_OPENED, &epriv->state);\n\tmutex_unlock(&epriv->state_lock);\n\treturn err;\n}\n\nstatic int mlx5i_pkey_close(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tmutex_lock(&priv->state_lock);\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state))\n\t\tgoto unlock;\n\n\tclear_bit(MLX5E_STATE_OPENED, &priv->state);\n\n\tnetif_carrier_off(priv->netdev);\n\tmlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qpn);\n\tmlx5i_uninit_underlay_qp(priv);\n\tmlx5e_deactivate_priv_channels(priv);\n\tmlx5e_close_channels(&priv->channels);\n\tmlx5e_destroy_tis(mdev, priv->tisn[0][0]);\nunlock:\n\tmutex_unlock(&priv->state_lock);\n\treturn 0;\n}\n\nstatic int mlx5i_pkey_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\n\tmutex_lock(&priv->state_lock);\n\tnetdev->mtu = new_mtu;\n\tmutex_unlock(&priv->state_lock);\n\n\treturn 0;\n}\n\n \nstatic int mlx5i_pkey_init(struct mlx5_core_dev *mdev,\n\t\t\t   struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv  = mlx5i_epriv(netdev);\n\tint err;\n\n\terr = mlx5i_init(mdev, netdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tnetdev->netdev_ops = &mlx5i_pkey_netdev_ops;\n\n\t \n\tnetdev->ethtool_ops = &mlx5i_pkey_ethtool_ops;\n\n\t \n\tpriv->channels.params.log_rq_mtu_frames = MLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE;\n\n\treturn 0;\n}\n\n \nstatic void mlx5i_pkey_cleanup(struct mlx5e_priv *priv)\n{\n\tmlx5i_cleanup(priv);\n}\n\nstatic int mlx5i_pkey_init_tx(struct mlx5e_priv *priv)\n{\n\tint err;\n\n\terr = mlx5i_create_underlay_qp(priv);\n\tif (err)\n\t\tmlx5_core_warn(priv->mdev, \"create child underlay QP failed, %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void mlx5i_pkey_cleanup_tx(struct mlx5e_priv *priv)\n{\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\n\tmlx5i_destroy_underlay_qp(priv->mdev, ipriv->qpn);\n}\n\nstatic int mlx5i_pkey_init_rx(struct mlx5e_priv *priv)\n{\n\t \n\treturn 0;\n}\n\nstatic void mlx5i_pkey_cleanup_rx(struct mlx5e_priv *priv)\n{\n\t \n}\n\nstatic const struct mlx5e_profile mlx5i_pkey_nic_profile = {\n\t.init\t\t   = mlx5i_pkey_init,\n\t.cleanup\t   = mlx5i_pkey_cleanup,\n\t.init_tx\t   = mlx5i_pkey_init_tx,\n\t.cleanup_tx\t   = mlx5i_pkey_cleanup_tx,\n\t.init_rx\t   = mlx5i_pkey_init_rx,\n\t.cleanup_rx\t   = mlx5i_pkey_cleanup_rx,\n\t.enable\t\t   = NULL,\n\t.disable\t   = NULL,\n\t.update_rx\t   = mlx5i_update_nic_rx,\n\t.update_stats\t   = NULL,\n\t.rx_handlers       = &mlx5i_rx_handlers,\n\t.max_tc\t\t   = MLX5I_MAX_NUM_TC,\n};\n\nconst struct mlx5e_profile *mlx5i_pkey_get_profile(void)\n{\n\treturn &mlx5i_pkey_nic_profile;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}