{
  "module_name": "macsec.c",
  "hash_id": "2e0c6b0acf47d1c32c7390457cbd7d408e22d8219dbe30e44e190f1a2c5f8051",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_accel/macsec.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/device.h>\n#include <linux/mlx5/mlx5_ifc.h>\n#include <linux/xarray.h>\n#include <linux/if_vlan.h>\n\n#include \"en.h\"\n#include \"lib/aso.h\"\n#include \"lib/crypto.h\"\n#include \"en_accel/macsec.h\"\n\n#define MLX5_MACSEC_EPN_SCOPE_MID 0x80000000L\n#define MLX5E_MACSEC_ASO_CTX_SZ MLX5_ST_SZ_BYTES(macsec_aso)\n\nenum mlx5_macsec_aso_event_arm {\n\tMLX5E_ASO_EPN_ARM = BIT(0),\n};\n\nenum {\n\tMLX5_MACSEC_ASO_REMOVE_FLOW_PKT_CNT_OFFSET,\n};\n\nstruct mlx5e_macsec_handle {\n\tstruct mlx5e_macsec *macsec;\n\tu32 obj_id;\n\tu8 idx;\n};\n\nenum {\n\tMLX5_MACSEC_EPN,\n};\n\nstruct mlx5e_macsec_aso_out {\n\tu8 event_arm;\n\tu32 mode_param;\n};\n\nstruct mlx5e_macsec_aso_in {\n\tu8 mode;\n\tu32 obj_id;\n};\n\nstruct mlx5e_macsec_epn_state {\n\tu32 epn_msb;\n\tu8 epn_enabled;\n\tu8 overlap;\n};\n\nstruct mlx5e_macsec_async_work {\n\tstruct mlx5e_macsec *macsec;\n\tstruct mlx5_core_dev *mdev;\n\tstruct work_struct work;\n\tu32 obj_id;\n};\n\nstruct mlx5e_macsec_sa {\n\tbool active;\n\tu8  assoc_num;\n\tu32 macsec_obj_id;\n\tu32 enc_key_id;\n\tu32 next_pn;\n\tsci_t sci;\n\tssci_t ssci;\n\tsalt_t salt;\n\n\tunion mlx5_macsec_rule *macsec_rule;\n\tstruct rcu_head rcu_head;\n\tstruct mlx5e_macsec_epn_state epn_state;\n};\n\nstruct mlx5e_macsec_rx_sc;\nstruct mlx5e_macsec_rx_sc_xarray_element {\n\tu32 fs_id;\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n};\n\nstruct mlx5e_macsec_rx_sc {\n\tbool active;\n\tsci_t sci;\n\tstruct mlx5e_macsec_sa *rx_sa[MACSEC_NUM_AN];\n\tstruct list_head rx_sc_list_element;\n\tstruct mlx5e_macsec_rx_sc_xarray_element *sc_xarray_element;\n\tstruct metadata_dst *md_dst;\n\tstruct rcu_head rcu_head;\n};\n\nstruct mlx5e_macsec_umr {\n\tu8 __aligned(64) ctx[MLX5_ST_SZ_BYTES(macsec_aso)];\n\tdma_addr_t dma_addr;\n\tu32 mkey;\n};\n\nstruct mlx5e_macsec_aso {\n\t \n\tstruct mlx5_aso *maso;\n\t \n\tstruct mutex aso_lock;\n\t \n\tstruct mlx5e_macsec_umr *umr;\n\n\tu32 pdn;\n};\n\nstruct mlx5e_macsec_device {\n\tconst struct net_device *netdev;\n\tstruct mlx5e_macsec_sa *tx_sa[MACSEC_NUM_AN];\n\tstruct list_head macsec_rx_sc_list_head;\n\tunsigned char *dev_addr;\n\tstruct list_head macsec_device_list_element;\n};\n\nstruct mlx5e_macsec {\n\tstruct list_head macsec_device_list_head;\n\tint num_of_devices;\n\tstruct mutex lock;  \n\n\t \n\tstruct xarray sc_xarray;\n\n\tstruct mlx5_core_dev *mdev;\n\n\t \n\tstruct mlx5e_macsec_aso aso;\n\n\tstruct notifier_block nb;\n\tstruct workqueue_struct *wq;\n};\n\nstruct mlx5_macsec_obj_attrs {\n\tu32 aso_pdn;\n\tu32 next_pn;\n\t__be64 sci;\n\tu32 enc_key_id;\n\tbool encrypt;\n\tstruct mlx5e_macsec_epn_state epn_state;\n\tsalt_t salt;\n\t__be32 ssci;\n\tbool replay_protect;\n\tu32 replay_window;\n};\n\nstruct mlx5_aso_ctrl_param {\n\tu8   data_mask_mode;\n\tu8   condition_0_operand;\n\tu8   condition_1_operand;\n\tu8   condition_0_offset;\n\tu8   condition_1_offset;\n\tu8   data_offset;\n\tu8   condition_operand;\n\tu32  condition_0_data;\n\tu32  condition_0_mask;\n\tu32  condition_1_data;\n\tu32  condition_1_mask;\n\tu64  bitwise_data;\n\tu64  data_mask;\n};\n\nstatic int mlx5e_macsec_aso_reg_mr(struct mlx5_core_dev *mdev, struct mlx5e_macsec_aso *aso)\n{\n\tstruct mlx5e_macsec_umr *umr;\n\tstruct device *dma_device;\n\tdma_addr_t dma_addr;\n\tint err;\n\n\tumr = kzalloc(sizeof(*umr), GFP_KERNEL);\n\tif (!umr) {\n\t\terr = -ENOMEM;\n\t\treturn err;\n\t}\n\n\tdma_device = mlx5_core_dma_dev(mdev);\n\tdma_addr = dma_map_single(dma_device, umr->ctx, sizeof(umr->ctx), DMA_BIDIRECTIONAL);\n\terr = dma_mapping_error(dma_device, dma_addr);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Can't map dma device, err=%d\\n\", err);\n\t\tgoto out_dma;\n\t}\n\n\terr = mlx5e_create_mkey(mdev, aso->pdn, &umr->mkey);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Can't create mkey, err=%d\\n\", err);\n\t\tgoto out_mkey;\n\t}\n\n\tumr->dma_addr = dma_addr;\n\n\taso->umr = umr;\n\n\treturn 0;\n\nout_mkey:\n\tdma_unmap_single(dma_device, dma_addr, sizeof(umr->ctx), DMA_BIDIRECTIONAL);\nout_dma:\n\tkfree(umr);\n\treturn err;\n}\n\nstatic void mlx5e_macsec_aso_dereg_mr(struct mlx5_core_dev *mdev, struct mlx5e_macsec_aso *aso)\n{\n\tstruct mlx5e_macsec_umr *umr = aso->umr;\n\n\tmlx5_core_destroy_mkey(mdev, umr->mkey);\n\tdma_unmap_single(&mdev->pdev->dev, umr->dma_addr, sizeof(umr->ctx), DMA_BIDIRECTIONAL);\n\tkfree(umr);\n}\n\nstatic int macsec_set_replay_protection(struct mlx5_macsec_obj_attrs *attrs, void *aso_ctx)\n{\n\tu8 window_sz;\n\n\tif (!attrs->replay_protect)\n\t\treturn 0;\n\n\tswitch (attrs->replay_window) {\n\tcase 256:\n\t\twindow_sz = MLX5_MACSEC_ASO_REPLAY_WIN_256BIT;\n\t\tbreak;\n\tcase 128:\n\t\twindow_sz = MLX5_MACSEC_ASO_REPLAY_WIN_128BIT;\n\t\tbreak;\n\tcase 64:\n\t\twindow_sz = MLX5_MACSEC_ASO_REPLAY_WIN_64BIT;\n\t\tbreak;\n\tcase 32:\n\t\twindow_sz = MLX5_MACSEC_ASO_REPLAY_WIN_32BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tMLX5_SET(macsec_aso, aso_ctx, window_size, window_sz);\n\tMLX5_SET(macsec_aso, aso_ctx, mode, MLX5_MACSEC_ASO_REPLAY_PROTECTION);\n\n\treturn 0;\n}\n\nstatic int mlx5e_macsec_create_object(struct mlx5_core_dev *mdev,\n\t\t\t\t      struct mlx5_macsec_obj_attrs *attrs,\n\t\t\t\t      bool is_tx,\n\t\t\t\t      u32 *macsec_obj_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_macsec_obj_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\tvoid *aso_ctx;\n\tvoid *obj;\n\tint err;\n\n\tobj = MLX5_ADDR_OF(create_macsec_obj_in, in, macsec_object);\n\taso_ctx = MLX5_ADDR_OF(macsec_offload_obj, obj, macsec_aso);\n\n\tMLX5_SET(macsec_offload_obj, obj, confidentiality_en, attrs->encrypt);\n\tMLX5_SET(macsec_offload_obj, obj, dekn, attrs->enc_key_id);\n\tMLX5_SET(macsec_offload_obj, obj, aso_return_reg, MLX5_MACSEC_ASO_REG_C_4_5);\n\tMLX5_SET(macsec_offload_obj, obj, macsec_aso_access_pd, attrs->aso_pdn);\n\tMLX5_SET(macsec_aso, aso_ctx, mode_parameter, attrs->next_pn);\n\n\t \n\tif (attrs->epn_state.epn_enabled) {\n\t\tvoid *salt_p;\n\t\tint i;\n\n\t\tMLX5_SET(macsec_aso, aso_ctx, epn_event_arm, 1);\n\t\tMLX5_SET(macsec_offload_obj, obj, epn_en, 1);\n\t\tMLX5_SET(macsec_offload_obj, obj, epn_msb, attrs->epn_state.epn_msb);\n\t\tMLX5_SET(macsec_offload_obj, obj, epn_overlap, attrs->epn_state.overlap);\n\t\tMLX5_SET64(macsec_offload_obj, obj, sci, (__force u64)attrs->ssci);\n\t\tsalt_p = MLX5_ADDR_OF(macsec_offload_obj, obj, salt);\n\t\tfor (i = 0; i < 3 ; i++)\n\t\t\tmemcpy((u32 *)salt_p + i, &attrs->salt.bytes[4 * (2 - i)], 4);\n\t} else {\n\t\tMLX5_SET64(macsec_offload_obj, obj, sci, (__force u64)(attrs->sci));\n\t}\n\n\tMLX5_SET(macsec_aso, aso_ctx, valid, 0x1);\n\tif (is_tx) {\n\t\tMLX5_SET(macsec_aso, aso_ctx, mode, MLX5_MACSEC_ASO_INC_SN);\n\t} else {\n\t\terr = macsec_set_replay_protection(attrs, aso_ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_GENERAL_OBJECT_TYPES_MACSEC);\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (err) {\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"MACsec offload: Failed to create MACsec object (err = %d)\\n\",\n\t\t\t      err);\n\t\treturn err;\n\t}\n\n\t*macsec_obj_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\n\treturn err;\n}\n\nstatic void mlx5e_macsec_destroy_object(struct mlx5_core_dev *mdev, u32 macsec_obj_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_GENERAL_OBJECT_TYPES_MACSEC);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, macsec_obj_id);\n\n\tmlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n}\n\nstatic void mlx5e_macsec_cleanup_sa(struct mlx5e_macsec *macsec,\n\t\t\t\t    struct mlx5e_macsec_sa *sa,\n\t\t\t\t    bool is_tx, struct net_device *netdev, u32 fs_id)\n{\n\tint action =  (is_tx) ?  MLX5_ACCEL_MACSEC_ACTION_ENCRYPT :\n\t\t\t\t MLX5_ACCEL_MACSEC_ACTION_DECRYPT;\n\n\tif (!sa->macsec_rule)\n\t\treturn;\n\n\tmlx5_macsec_fs_del_rule(macsec->mdev->macsec_fs, sa->macsec_rule, action, netdev,\n\t\t\t\tfs_id);\n\tmlx5e_macsec_destroy_object(macsec->mdev, sa->macsec_obj_id);\n\tsa->macsec_rule = NULL;\n}\n\nstatic int mlx5e_macsec_init_sa(struct macsec_context *ctx,\n\t\t\t\tstruct mlx5e_macsec_sa *sa,\n\t\t\t\tbool encrypt, bool is_tx, u32 *fs_id)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tstruct mlx5e_macsec *macsec = priv->macsec;\n\tstruct mlx5_macsec_rule_attrs rule_attrs;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5_macsec_obj_attrs obj_attrs;\n\tunion mlx5_macsec_rule *macsec_rule;\n\tint err;\n\n\tobj_attrs.next_pn = sa->next_pn;\n\tobj_attrs.sci = cpu_to_be64((__force u64)sa->sci);\n\tobj_attrs.enc_key_id = sa->enc_key_id;\n\tobj_attrs.encrypt = encrypt;\n\tobj_attrs.aso_pdn = macsec->aso.pdn;\n\tobj_attrs.epn_state = sa->epn_state;\n\n\tif (sa->epn_state.epn_enabled) {\n\t\tobj_attrs.ssci = cpu_to_be32((__force u32)sa->ssci);\n\t\tmemcpy(&obj_attrs.salt, &sa->salt, sizeof(sa->salt));\n\t}\n\n\tobj_attrs.replay_window = ctx->secy->replay_window;\n\tobj_attrs.replay_protect = ctx->secy->replay_protect;\n\n\terr = mlx5e_macsec_create_object(mdev, &obj_attrs, is_tx, &sa->macsec_obj_id);\n\tif (err)\n\t\treturn err;\n\n\trule_attrs.macsec_obj_id = sa->macsec_obj_id;\n\trule_attrs.sci = sa->sci;\n\trule_attrs.assoc_num = sa->assoc_num;\n\trule_attrs.action = (is_tx) ? MLX5_ACCEL_MACSEC_ACTION_ENCRYPT :\n\t\t\t\t      MLX5_ACCEL_MACSEC_ACTION_DECRYPT;\n\n\tmacsec_rule = mlx5_macsec_fs_add_rule(mdev->macsec_fs, ctx, &rule_attrs, fs_id);\n\tif (!macsec_rule) {\n\t\terr = -ENOMEM;\n\t\tgoto destroy_macsec_object;\n\t}\n\n\tsa->macsec_rule = macsec_rule;\n\n\treturn 0;\n\ndestroy_macsec_object:\n\tmlx5e_macsec_destroy_object(mdev, sa->macsec_obj_id);\n\n\treturn err;\n}\n\nstatic struct mlx5e_macsec_rx_sc *\nmlx5e_macsec_get_rx_sc_from_sc_list(const struct list_head *list, sci_t sci)\n{\n\tstruct mlx5e_macsec_rx_sc *iter;\n\n\tlist_for_each_entry_rcu(iter, list, rx_sc_list_element) {\n\t\tif (iter->sci == sci)\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstatic int macsec_rx_sa_active_update(struct macsec_context *ctx,\n\t\t\t\t      struct mlx5e_macsec_sa *rx_sa,\n\t\t\t\t      bool active, u32 *fs_id)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tstruct mlx5e_macsec *macsec = priv->macsec;\n\tint err = 0;\n\n\tif (rx_sa->active == active)\n\t\treturn 0;\n\n\trx_sa->active = active;\n\tif (!active) {\n\t\tmlx5e_macsec_cleanup_sa(macsec, rx_sa, false, ctx->secy->netdev, *fs_id);\n\t\treturn 0;\n\t}\n\n\terr = mlx5e_macsec_init_sa(ctx, rx_sa, true, false, fs_id);\n\tif (err)\n\t\trx_sa->active = false;\n\n\treturn err;\n}\n\nstatic bool mlx5e_macsec_secy_features_validate(struct macsec_context *ctx)\n{\n\tconst struct net_device *netdev = ctx->netdev;\n\tconst struct macsec_secy *secy = ctx->secy;\n\n\tif (secy->validate_frames != MACSEC_VALIDATE_STRICT) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"MACsec offload is supported only when validate_frame is in strict mode\\n\");\n\t\treturn false;\n\t}\n\n\tif (secy->icv_len != MACSEC_DEFAULT_ICV_LEN) {\n\t\tnetdev_err(netdev, \"MACsec offload is supported only when icv_len is %d\\n\",\n\t\t\t   MACSEC_DEFAULT_ICV_LEN);\n\t\treturn false;\n\t}\n\n\tif (!secy->protect_frames) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"MACsec offload is supported only when protect_frames is set\\n\");\n\t\treturn false;\n\t}\n\n\tif (!ctx->secy->tx_sc.encrypt) {\n\t\tnetdev_err(netdev, \"MACsec offload: encrypt off isn't supported\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct mlx5e_macsec_device *\nmlx5e_macsec_get_macsec_device_context(const struct mlx5e_macsec *macsec,\n\t\t\t\t       const struct macsec_context *ctx)\n{\n\tstruct mlx5e_macsec_device *iter;\n\tconst struct list_head *list;\n\n\tlist = &macsec->macsec_device_list_head;\n\tlist_for_each_entry_rcu(iter, list, macsec_device_list_element) {\n\t\tif (iter->netdev == ctx->secy->netdev)\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstatic void update_macsec_epn(struct mlx5e_macsec_sa *sa, const struct macsec_key *key,\n\t\t\t      const pn_t *next_pn_halves, ssci_t ssci)\n{\n\tstruct mlx5e_macsec_epn_state *epn_state = &sa->epn_state;\n\n\tsa->ssci = ssci;\n\tsa->salt = key->salt;\n\tepn_state->epn_enabled = 1;\n\tepn_state->epn_msb = next_pn_halves->upper;\n\tepn_state->overlap = next_pn_halves->lower < MLX5_MACSEC_EPN_SCOPE_MID ? 0 : 1;\n}\n\nstatic int mlx5e_macsec_add_txsa(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_tx_sc *tx_sc = &ctx->secy->tx_sc;\n\tconst struct macsec_tx_sa *ctx_tx_sa = ctx->sa.tx_sa;\n\tconst struct macsec_secy *secy = ctx->secy;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 assoc_num = ctx->sa.assoc_num;\n\tstruct mlx5e_macsec_sa *tx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (macsec_device->tx_sa[assoc_num]) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload tx_sa: %d already exist\\n\", assoc_num);\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\ttx_sa = kzalloc(sizeof(*tx_sa), GFP_KERNEL);\n\tif (!tx_sa) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttx_sa->active = ctx_tx_sa->active;\n\ttx_sa->next_pn = ctx_tx_sa->next_pn_halves.lower;\n\ttx_sa->sci = secy->sci;\n\ttx_sa->assoc_num = assoc_num;\n\n\tif (secy->xpn)\n\t\tupdate_macsec_epn(tx_sa, &ctx_tx_sa->key, &ctx_tx_sa->next_pn_halves,\n\t\t\t\t  ctx_tx_sa->ssci);\n\n\terr = mlx5_create_encryption_key(mdev, ctx->sa.key, secy->key_len,\n\t\t\t\t\t MLX5_ACCEL_OBJ_MACSEC_KEY,\n\t\t\t\t\t &tx_sa->enc_key_id);\n\tif (err)\n\t\tgoto destroy_sa;\n\n\tmacsec_device->tx_sa[assoc_num] = tx_sa;\n\tif (!secy->operational ||\n\t    assoc_num != tx_sc->encoding_sa ||\n\t    !tx_sa->active)\n\t\tgoto out;\n\n\terr = mlx5e_macsec_init_sa(ctx, tx_sa, tx_sc->encrypt, true, NULL);\n\tif (err)\n\t\tgoto destroy_encryption_key;\n\n\tmutex_unlock(&macsec->lock);\n\n\treturn 0;\n\ndestroy_encryption_key:\n\tmacsec_device->tx_sa[assoc_num] = NULL;\n\tmlx5_destroy_encryption_key(mdev, tx_sa->enc_key_id);\ndestroy_sa:\n\tkfree(tx_sa);\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_upd_txsa(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_tx_sc *tx_sc = &ctx->secy->tx_sc;\n\tconst struct macsec_tx_sa *ctx_tx_sa = ctx->sa.tx_sa;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tu8 assoc_num = ctx->sa.assoc_num;\n\tstruct mlx5e_macsec_sa *tx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tstruct net_device *netdev;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tnetdev = ctx->netdev;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttx_sa = macsec_device->tx_sa[assoc_num];\n\tif (!tx_sa) {\n\t\tnetdev_err(netdev, \"MACsec offload: TX sa 0x%x doesn't exist\\n\", assoc_num);\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (ctx->sa.update_pn) {\n\t\tnetdev_err(netdev, \"MACsec offload: update TX sa %d PN isn't supported\\n\",\n\t\t\t   assoc_num);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tx_sa->active == ctx_tx_sa->active)\n\t\tgoto out;\n\n\ttx_sa->active = ctx_tx_sa->active;\n\tif (tx_sa->assoc_num != tx_sc->encoding_sa)\n\t\tgoto out;\n\n\tif (ctx_tx_sa->active) {\n\t\terr = mlx5e_macsec_init_sa(ctx, tx_sa, tx_sc->encrypt, true, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tif (!tx_sa->macsec_rule) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlx5e_macsec_cleanup_sa(macsec, tx_sa, true, ctx->secy->netdev, 0);\n\t}\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_del_txsa(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tstruct mlx5e_macsec_device *macsec_device;\n\tu8 assoc_num = ctx->sa.assoc_num;\n\tstruct mlx5e_macsec_sa *tx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttx_sa = macsec_device->tx_sa[assoc_num];\n\tif (!tx_sa) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: TX sa 0x%x doesn't exist\\n\", assoc_num);\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tmlx5e_macsec_cleanup_sa(macsec, tx_sa, true, ctx->secy->netdev, 0);\n\tmlx5_destroy_encryption_key(macsec->mdev, tx_sa->enc_key_id);\n\tkfree_rcu_mightsleep(tx_sa);\n\tmacsec_device->tx_sa[assoc_num] = NULL;\n\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_add_rxsc(struct macsec_context *ctx)\n{\n\tstruct mlx5e_macsec_rx_sc_xarray_element *sc_xarray_element;\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_rx_sc *ctx_rx_sc = ctx->rx_sc;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n\tstruct list_head *rx_sc_list;\n\tstruct mlx5e_macsec *macsec;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trx_sc_list = &macsec_device->macsec_rx_sc_list_head;\n\trx_sc = mlx5e_macsec_get_rx_sc_from_sc_list(rx_sc_list, ctx_rx_sc->sci);\n\tif (rx_sc) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: rx_sc (sci %lld) already exists\\n\",\n\t\t\t   ctx_rx_sc->sci);\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\trx_sc = kzalloc(sizeof(*rx_sc), GFP_KERNEL);\n\tif (!rx_sc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsc_xarray_element = kzalloc(sizeof(*sc_xarray_element), GFP_KERNEL);\n\tif (!sc_xarray_element) {\n\t\terr = -ENOMEM;\n\t\tgoto destroy_rx_sc;\n\t}\n\n\tsc_xarray_element->rx_sc = rx_sc;\n\terr = xa_alloc(&macsec->sc_xarray, &sc_xarray_element->fs_id, sc_xarray_element,\n\t\t       XA_LIMIT(1, MLX5_MACEC_RX_FS_ID_MAX), GFP_KERNEL);\n\tif (err) {\n\t\tif (err == -EBUSY)\n\t\t\tnetdev_err(ctx->netdev,\n\t\t\t\t   \"MACsec offload: unable to create entry for RX SC (%d Rx SCs already allocated)\\n\",\n\t\t\t\t   MLX5_MACEC_RX_FS_ID_MAX);\n\t\tgoto destroy_sc_xarray_elemenet;\n\t}\n\n\trx_sc->md_dst = metadata_dst_alloc(0, METADATA_MACSEC, GFP_KERNEL);\n\tif (!rx_sc->md_dst) {\n\t\terr = -ENOMEM;\n\t\tgoto erase_xa_alloc;\n\t}\n\n\trx_sc->sci = ctx_rx_sc->sci;\n\trx_sc->active = ctx_rx_sc->active;\n\tlist_add_rcu(&rx_sc->rx_sc_list_element, rx_sc_list);\n\n\trx_sc->sc_xarray_element = sc_xarray_element;\n\trx_sc->md_dst->u.macsec_info.sci = rx_sc->sci;\n\tmutex_unlock(&macsec->lock);\n\n\treturn 0;\n\nerase_xa_alloc:\n\txa_erase(&macsec->sc_xarray, sc_xarray_element->fs_id);\ndestroy_sc_xarray_elemenet:\n\tkfree(sc_xarray_element);\ndestroy_rx_sc:\n\tkfree(rx_sc);\n\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_upd_rxsc(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_rx_sc *ctx_rx_sc = ctx->rx_sc;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n\tstruct mlx5e_macsec_sa *rx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tstruct list_head *list;\n\tint i;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist = &macsec_device->macsec_rx_sc_list_head;\n\trx_sc = mlx5e_macsec_get_rx_sc_from_sc_list(list, ctx_rx_sc->sci);\n\tif (!rx_sc) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (rx_sc->active == ctx_rx_sc->active)\n\t\tgoto out;\n\n\trx_sc->active = ctx_rx_sc->active;\n\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\trx_sa = rx_sc->rx_sa[i];\n\t\tif (!rx_sa)\n\t\t\tcontinue;\n\n\t\terr = macsec_rx_sa_active_update(ctx, rx_sa, rx_sa->active && ctx_rx_sc->active,\n\t\t\t\t\t\t &rx_sc->sc_xarray_element->fs_id);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic void macsec_del_rxsc_ctx(struct mlx5e_macsec *macsec, struct mlx5e_macsec_rx_sc *rx_sc,\n\t\t\t\tstruct net_device *netdev)\n{\n\tstruct mlx5e_macsec_sa *rx_sa;\n\tint i;\n\n\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\trx_sa = rx_sc->rx_sa[i];\n\t\tif (!rx_sa)\n\t\t\tcontinue;\n\n\t\tmlx5e_macsec_cleanup_sa(macsec, rx_sa, false, netdev,\n\t\t\t\t\trx_sc->sc_xarray_element->fs_id);\n\t\tmlx5_destroy_encryption_key(macsec->mdev, rx_sa->enc_key_id);\n\n\t\tkfree(rx_sa);\n\t\trx_sc->rx_sa[i] = NULL;\n\t}\n\n\t \n\tlist_del_rcu(&rx_sc->rx_sc_list_element);\n\txa_erase(&macsec->sc_xarray, rx_sc->sc_xarray_element->fs_id);\n\tmetadata_dst_free(rx_sc->md_dst);\n\tkfree(rx_sc->sc_xarray_element);\n\tkfree_rcu_mightsleep(rx_sc);\n}\n\nstatic int mlx5e_macsec_del_rxsc(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n\tstruct mlx5e_macsec *macsec;\n\tstruct list_head *list;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist = &macsec_device->macsec_rx_sc_list_head;\n\trx_sc = mlx5e_macsec_get_rx_sc_from_sc_list(list, ctx->rx_sc->sci);\n\tif (!rx_sc) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload rx_sc sci %lld doesn't exist\\n\",\n\t\t\t   ctx->sa.rx_sa->sc->sci);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmacsec_del_rxsc_ctx(macsec, rx_sc, ctx->secy->netdev);\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_add_rxsa(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_rx_sa *ctx_rx_sa = ctx->sa.rx_sa;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 assoc_num = ctx->sa.assoc_num;\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n\tsci_t sci = ctx_rx_sa->sc->sci;\n\tstruct mlx5e_macsec_sa *rx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tstruct list_head *list;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist = &macsec_device->macsec_rx_sc_list_head;\n\trx_sc = mlx5e_macsec_get_rx_sc_from_sc_list(list, sci);\n\tif (!rx_sc) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload rx_sc sci %lld doesn't exist\\n\",\n\t\t\t   ctx->sa.rx_sa->sc->sci);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (rx_sc->rx_sa[assoc_num]) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload rx_sc sci %lld rx_sa %d already exist\\n\",\n\t\t\t   sci, assoc_num);\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\trx_sa = kzalloc(sizeof(*rx_sa), GFP_KERNEL);\n\tif (!rx_sa) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trx_sa->active = ctx_rx_sa->active;\n\trx_sa->next_pn = ctx_rx_sa->next_pn;\n\trx_sa->sci = sci;\n\trx_sa->assoc_num = assoc_num;\n\n\tif (ctx->secy->xpn)\n\t\tupdate_macsec_epn(rx_sa, &ctx_rx_sa->key, &ctx_rx_sa->next_pn_halves,\n\t\t\t\t  ctx_rx_sa->ssci);\n\n\terr = mlx5_create_encryption_key(mdev, ctx->sa.key, ctx->secy->key_len,\n\t\t\t\t\t MLX5_ACCEL_OBJ_MACSEC_KEY,\n\t\t\t\t\t &rx_sa->enc_key_id);\n\tif (err)\n\t\tgoto destroy_sa;\n\n\trx_sc->rx_sa[assoc_num] = rx_sa;\n\tif (!rx_sa->active)\n\t\tgoto out;\n\n\t\n\terr = mlx5e_macsec_init_sa(ctx, rx_sa, true, false, &rx_sc->sc_xarray_element->fs_id);\n\tif (err)\n\t\tgoto destroy_encryption_key;\n\n\tgoto out;\n\ndestroy_encryption_key:\n\trx_sc->rx_sa[assoc_num] = NULL;\n\tmlx5_destroy_encryption_key(mdev, rx_sa->enc_key_id);\ndestroy_sa:\n\tkfree(rx_sa);\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_upd_rxsa(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_rx_sa *ctx_rx_sa = ctx->sa.rx_sa;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tu8 assoc_num = ctx->sa.assoc_num;\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n\tsci_t sci = ctx_rx_sa->sc->sci;\n\tstruct mlx5e_macsec_sa *rx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tstruct list_head *list;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist = &macsec_device->macsec_rx_sc_list_head;\n\trx_sc = mlx5e_macsec_get_rx_sc_from_sc_list(list, sci);\n\tif (!rx_sc) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload rx_sc sci %lld doesn't exist\\n\",\n\t\t\t   ctx->sa.rx_sa->sc->sci);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trx_sa = rx_sc->rx_sa[assoc_num];\n\tif (!rx_sa) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload rx_sc sci %lld rx_sa %d doesn't exist\\n\",\n\t\t\t   sci, assoc_num);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ctx->sa.update_pn) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload update RX sa %d PN isn't supported\\n\",\n\t\t\t   assoc_num);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = macsec_rx_sa_active_update(ctx, rx_sa, ctx_rx_sa->active,\n\t\t\t\t\t &rx_sc->sc_xarray_element->fs_id);\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_del_rxsa(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tstruct mlx5e_macsec_device *macsec_device;\n\tsci_t sci = ctx->sa.rx_sa->sc->sci;\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n\tu8 assoc_num = ctx->sa.assoc_num;\n\tstruct mlx5e_macsec_sa *rx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tstruct list_head *list;\n\tint err = 0;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist = &macsec_device->macsec_rx_sc_list_head;\n\trx_sc = mlx5e_macsec_get_rx_sc_from_sc_list(list, sci);\n\tif (!rx_sc) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload rx_sc sci %lld doesn't exist\\n\",\n\t\t\t   ctx->sa.rx_sa->sc->sci);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trx_sa = rx_sc->rx_sa[assoc_num];\n\tif (!rx_sa) {\n\t\tnetdev_err(ctx->netdev,\n\t\t\t   \"MACsec offload rx_sc sci %lld rx_sa %d doesn't exist\\n\",\n\t\t\t   sci, assoc_num);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmlx5e_macsec_cleanup_sa(macsec, rx_sa, false, ctx->secy->netdev,\n\t\t\t\trx_sc->sc_xarray_element->fs_id);\n\tmlx5_destroy_encryption_key(macsec->mdev, rx_sa->enc_key_id);\n\tkfree(rx_sa);\n\trx_sc->rx_sa[assoc_num] = NULL;\n\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_add_secy(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct net_device *dev = ctx->secy->netdev;\n\tconst struct net_device *netdev = ctx->netdev;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5e_macsec *macsec;\n\tint err = 0;\n\n\tif (!mlx5e_macsec_secy_features_validate(ctx))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->macsec->lock);\n\tmacsec = priv->macsec;\n\tif (mlx5e_macsec_get_macsec_device_context(macsec, ctx)) {\n\t\tnetdev_err(netdev, \"MACsec offload: MACsec net_device already exist\\n\");\n\t\tgoto out;\n\t}\n\n\tif (macsec->num_of_devices >= MLX5_MACSEC_NUM_OF_SUPPORTED_INTERFACES) {\n\t\tnetdev_err(netdev, \"Currently, only %d MACsec offload devices can be set\\n\",\n\t\t\t   MLX5_MACSEC_NUM_OF_SUPPORTED_INTERFACES);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tmacsec_device = kzalloc(sizeof(*macsec_device), GFP_KERNEL);\n\tif (!macsec_device) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmacsec_device->dev_addr = kmemdup(dev->dev_addr, dev->addr_len, GFP_KERNEL);\n\tif (!macsec_device->dev_addr) {\n\t\tkfree(macsec_device);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmacsec_device->netdev = dev;\n\n\tINIT_LIST_HEAD_RCU(&macsec_device->macsec_rx_sc_list_head);\n\tlist_add_rcu(&macsec_device->macsec_device_list_element, &macsec->macsec_device_list_head);\n\n\t++macsec->num_of_devices;\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int macsec_upd_secy_hw_address(struct macsec_context *ctx,\n\t\t\t\t      struct mlx5e_macsec_device *macsec_device)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct net_device *dev = ctx->secy->netdev;\n\tstruct mlx5e_macsec *macsec = priv->macsec;\n\tstruct mlx5e_macsec_rx_sc *rx_sc, *tmp;\n\tstruct mlx5e_macsec_sa *rx_sa;\n\tstruct list_head *list;\n\tint i, err = 0;\n\n\n\tlist = &macsec_device->macsec_rx_sc_list_head;\n\tlist_for_each_entry_safe(rx_sc, tmp, list, rx_sc_list_element) {\n\t\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\t\trx_sa = rx_sc->rx_sa[i];\n\t\t\tif (!rx_sa || !rx_sa->macsec_rule)\n\t\t\t\tcontinue;\n\n\t\t\tmlx5e_macsec_cleanup_sa(macsec, rx_sa, false, ctx->secy->netdev,\n\t\t\t\t\t\trx_sc->sc_xarray_element->fs_id);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(rx_sc, tmp, list, rx_sc_list_element) {\n\t\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\t\trx_sa = rx_sc->rx_sa[i];\n\t\t\tif (!rx_sa)\n\t\t\t\tcontinue;\n\n\t\t\tif (rx_sa->active) {\n\t\t\t\terr = mlx5e_macsec_init_sa(ctx, rx_sa, true, false,\n\t\t\t\t\t\t\t   &rx_sc->sc_xarray_element->fs_id);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemcpy(macsec_device->dev_addr, dev->dev_addr, dev->addr_len);\nout:\n\treturn err;\n}\n\n \nstatic int mlx5e_macsec_upd_secy(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_tx_sc *tx_sc = &ctx->secy->tx_sc;\n\tconst struct net_device *dev = ctx->secy->netdev;\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5e_macsec_sa *tx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tint i, err = 0;\n\n\tif (!mlx5e_macsec_secy_features_validate(ctx))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->macsec->lock);\n\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!memcmp(macsec_device->dev_addr, dev->dev_addr, dev->addr_len)) {\n\t\terr = macsec_upd_secy_hw_address(ctx, macsec_device);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\ttx_sa = macsec_device->tx_sa[i];\n\t\tif (!tx_sa)\n\t\t\tcontinue;\n\n\t\tmlx5e_macsec_cleanup_sa(macsec, tx_sa, true, ctx->secy->netdev, 0);\n\t}\n\n\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\ttx_sa = macsec_device->tx_sa[i];\n\t\tif (!tx_sa)\n\t\t\tcontinue;\n\n\t\tif (tx_sa->assoc_num == tx_sc->encoding_sa && tx_sa->active) {\n\t\t\terr = mlx5e_macsec_init_sa(ctx, tx_sa, tx_sc->encrypt, true, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_macsec_del_secy(struct macsec_context *ctx)\n{\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(ctx->netdev);\n\tstruct mlx5e_macsec_device *macsec_device;\n\tstruct mlx5e_macsec_rx_sc *rx_sc, *tmp;\n\tstruct mlx5e_macsec_sa *tx_sa;\n\tstruct mlx5e_macsec *macsec;\n\tstruct list_head *list;\n\tint err = 0;\n\tint i;\n\n\tmutex_lock(&priv->macsec->lock);\n\tmacsec = priv->macsec;\n\tmacsec_device = mlx5e_macsec_get_macsec_device_context(macsec, ctx);\n\tif (!macsec_device) {\n\t\tnetdev_err(ctx->netdev, \"MACsec offload: Failed to find device context\\n\");\n\t\terr = -EINVAL;\n\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\ttx_sa = macsec_device->tx_sa[i];\n\t\tif (!tx_sa)\n\t\t\tcontinue;\n\n\t\tmlx5e_macsec_cleanup_sa(macsec, tx_sa, true, ctx->secy->netdev, 0);\n\t\tmlx5_destroy_encryption_key(macsec->mdev, tx_sa->enc_key_id);\n\t\tkfree(tx_sa);\n\t\tmacsec_device->tx_sa[i] = NULL;\n\t}\n\n\tlist = &macsec_device->macsec_rx_sc_list_head;\n\tlist_for_each_entry_safe(rx_sc, tmp, list, rx_sc_list_element)\n\t\tmacsec_del_rxsc_ctx(macsec, rx_sc, ctx->secy->netdev);\n\n\tkfree(macsec_device->dev_addr);\n\tmacsec_device->dev_addr = NULL;\n\n\tlist_del_rcu(&macsec_device->macsec_device_list_element);\n\t--macsec->num_of_devices;\n\tkfree(macsec_device);\n\nout:\n\tmutex_unlock(&macsec->lock);\n\n\treturn err;\n}\n\nstatic void macsec_build_accel_attrs(struct mlx5e_macsec_sa *sa,\n\t\t\t\t     struct mlx5_macsec_obj_attrs *attrs)\n{\n\tattrs->epn_state.epn_msb = sa->epn_state.epn_msb;\n\tattrs->epn_state.overlap = sa->epn_state.overlap;\n}\n\nstatic void macsec_aso_build_wqe_ctrl_seg(struct mlx5e_macsec_aso *macsec_aso,\n\t\t\t\t\t  struct mlx5_wqe_aso_ctrl_seg *aso_ctrl,\n\t\t\t\t\t  struct mlx5_aso_ctrl_param *param)\n{\n\tstruct mlx5e_macsec_umr *umr = macsec_aso->umr;\n\n\tmemset(aso_ctrl, 0, sizeof(*aso_ctrl));\n\taso_ctrl->va_l = cpu_to_be32(umr->dma_addr | ASO_CTRL_READ_EN);\n\taso_ctrl->va_h = cpu_to_be32((u64)umr->dma_addr >> 32);\n\taso_ctrl->l_key = cpu_to_be32(umr->mkey);\n\n\tif (!param)\n\t\treturn;\n\n\taso_ctrl->data_mask_mode = param->data_mask_mode << 6;\n\taso_ctrl->condition_1_0_operand = param->condition_1_operand |\n\t\t\t\t\t\tparam->condition_0_operand << 4;\n\taso_ctrl->condition_1_0_offset = param->condition_1_offset |\n\t\t\t\t\t\tparam->condition_0_offset << 4;\n\taso_ctrl->data_offset_condition_operand = param->data_offset |\n\t\t\t\t\t\tparam->condition_operand << 6;\n\taso_ctrl->condition_0_data = cpu_to_be32(param->condition_0_data);\n\taso_ctrl->condition_0_mask = cpu_to_be32(param->condition_0_mask);\n\taso_ctrl->condition_1_data = cpu_to_be32(param->condition_1_data);\n\taso_ctrl->condition_1_mask = cpu_to_be32(param->condition_1_mask);\n\taso_ctrl->bitwise_data = cpu_to_be64(param->bitwise_data);\n\taso_ctrl->data_mask = cpu_to_be64(param->data_mask);\n}\n\nstatic int mlx5e_macsec_modify_obj(struct mlx5_core_dev *mdev, struct mlx5_macsec_obj_attrs *attrs,\n\t\t\t\t   u32 macsec_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(modify_macsec_obj_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(query_macsec_obj_out)];\n\tu64 modify_field_select = 0;\n\tvoid *obj;\n\tint err;\n\n\t \n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_QUERY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_GENERAL_OBJECT_TYPES_MACSEC);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, macsec_id);\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Query MACsec object failed (Object id %d), err = %d\\n\",\n\t\t\t      macsec_id, err);\n\t\treturn err;\n\t}\n\n\tobj = MLX5_ADDR_OF(query_macsec_obj_out, out, macsec_object);\n\tmodify_field_select = MLX5_GET64(macsec_offload_obj, obj, modify_field_select);\n\n\t \n\tif (!(modify_field_select & MLX5_MODIFY_MACSEC_BITMASK_EPN_OVERLAP) ||\n\t    !(modify_field_select & MLX5_MODIFY_MACSEC_BITMASK_EPN_MSB)) {\n\t\tmlx5_core_dbg(mdev, \"MACsec object field is not modifiable (Object id %d)\\n\",\n\t\t\t      macsec_id);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tobj = MLX5_ADDR_OF(modify_macsec_obj_in, in, macsec_object);\n\tMLX5_SET64(macsec_offload_obj, obj, modify_field_select,\n\t\t   MLX5_MODIFY_MACSEC_BITMASK_EPN_OVERLAP | MLX5_MODIFY_MACSEC_BITMASK_EPN_MSB);\n\tMLX5_SET(macsec_offload_obj, obj, epn_msb, attrs->epn_state.epn_msb);\n\tMLX5_SET(macsec_offload_obj, obj, epn_overlap, attrs->epn_state.overlap);\n\n\t \n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_MODIFY_GENERAL_OBJECT);\n\n\treturn mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n}\n\nstatic void macsec_aso_build_ctrl(struct mlx5e_macsec_aso *aso,\n\t\t\t\t  struct mlx5_wqe_aso_ctrl_seg *aso_ctrl,\n\t\t\t\t  struct mlx5e_macsec_aso_in *in)\n{\n\tstruct mlx5_aso_ctrl_param param = {};\n\n\tparam.data_mask_mode = MLX5_ASO_DATA_MASK_MODE_BITWISE_64BIT;\n\tparam.condition_0_operand = MLX5_ASO_ALWAYS_TRUE;\n\tparam.condition_1_operand = MLX5_ASO_ALWAYS_TRUE;\n\tif (in->mode == MLX5_MACSEC_EPN) {\n\t\tparam.data_offset = MLX5_MACSEC_ASO_REMOVE_FLOW_PKT_CNT_OFFSET;\n\t\tparam.bitwise_data = BIT_ULL(54);\n\t\tparam.data_mask = param.bitwise_data;\n\t}\n\tmacsec_aso_build_wqe_ctrl_seg(aso, aso_ctrl, &param);\n}\n\nstatic int macsec_aso_set_arm_event(struct mlx5_core_dev *mdev, struct mlx5e_macsec *macsec,\n\t\t\t\t    struct mlx5e_macsec_aso_in *in)\n{\n\tstruct mlx5e_macsec_aso *aso;\n\tstruct mlx5_aso_wqe *aso_wqe;\n\tstruct mlx5_aso *maso;\n\tint err;\n\n\taso = &macsec->aso;\n\tmaso = aso->maso;\n\n\tmutex_lock(&aso->aso_lock);\n\taso_wqe = mlx5_aso_get_wqe(maso);\n\tmlx5_aso_build_wqe(maso, MLX5_MACSEC_ASO_DS_CNT, aso_wqe, in->obj_id,\n\t\t\t   MLX5_ACCESS_ASO_OPC_MOD_MACSEC);\n\tmacsec_aso_build_ctrl(aso, &aso_wqe->aso_ctrl, in);\n\tmlx5_aso_post_wqe(maso, false, &aso_wqe->ctrl);\n\terr = mlx5_aso_poll_cq(maso, false);\n\tmutex_unlock(&aso->aso_lock);\n\n\treturn err;\n}\n\nstatic int macsec_aso_query(struct mlx5_core_dev *mdev, struct mlx5e_macsec *macsec,\n\t\t\t    struct mlx5e_macsec_aso_in *in, struct mlx5e_macsec_aso_out *out)\n{\n\tstruct mlx5e_macsec_aso *aso;\n\tstruct mlx5_aso_wqe *aso_wqe;\n\tstruct mlx5_aso *maso;\n\tunsigned long expires;\n\tint err;\n\n\taso = &macsec->aso;\n\tmaso = aso->maso;\n\n\tmutex_lock(&aso->aso_lock);\n\n\taso_wqe = mlx5_aso_get_wqe(maso);\n\tmlx5_aso_build_wqe(maso, MLX5_MACSEC_ASO_DS_CNT, aso_wqe, in->obj_id,\n\t\t\t   MLX5_ACCESS_ASO_OPC_MOD_MACSEC);\n\tmacsec_aso_build_wqe_ctrl_seg(aso, &aso_wqe->aso_ctrl, NULL);\n\n\tmlx5_aso_post_wqe(maso, false, &aso_wqe->ctrl);\n\texpires = jiffies + msecs_to_jiffies(10);\n\tdo {\n\t\terr = mlx5_aso_poll_cq(maso, false);\n\t\tif (err)\n\t\t\tusleep_range(2, 10);\n\t} while (err && time_is_after_jiffies(expires));\n\n\tif (err)\n\t\tgoto err_out;\n\n\tif (MLX5_GET(macsec_aso, aso->umr->ctx, epn_event_arm))\n\t\tout->event_arm |= MLX5E_ASO_EPN_ARM;\n\n\tout->mode_param = MLX5_GET(macsec_aso, aso->umr->ctx, mode_parameter);\n\nerr_out:\n\tmutex_unlock(&aso->aso_lock);\n\treturn err;\n}\n\nstatic struct mlx5e_macsec_sa *get_macsec_tx_sa_from_obj_id(const struct mlx5e_macsec *macsec,\n\t\t\t\t\t\t\t    const u32 obj_id)\n{\n\tconst struct list_head *device_list;\n\tstruct mlx5e_macsec_sa *macsec_sa;\n\tstruct mlx5e_macsec_device *iter;\n\tint i;\n\n\tdevice_list = &macsec->macsec_device_list_head;\n\n\tlist_for_each_entry(iter, device_list, macsec_device_list_element) {\n\t\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\t\tmacsec_sa = iter->tx_sa[i];\n\t\t\tif (!macsec_sa || !macsec_sa->active)\n\t\t\t\tcontinue;\n\t\t\tif (macsec_sa->macsec_obj_id == obj_id)\n\t\t\t\treturn macsec_sa;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlx5e_macsec_sa *get_macsec_rx_sa_from_obj_id(const struct mlx5e_macsec *macsec,\n\t\t\t\t\t\t\t    const u32 obj_id)\n{\n\tconst struct list_head *device_list, *sc_list;\n\tstruct mlx5e_macsec_rx_sc *mlx5e_rx_sc;\n\tstruct mlx5e_macsec_sa *macsec_sa;\n\tstruct mlx5e_macsec_device *iter;\n\tint i;\n\n\tdevice_list = &macsec->macsec_device_list_head;\n\n\tlist_for_each_entry(iter, device_list, macsec_device_list_element) {\n\t\tsc_list = &iter->macsec_rx_sc_list_head;\n\t\tlist_for_each_entry(mlx5e_rx_sc, sc_list, rx_sc_list_element) {\n\t\t\tfor (i = 0; i < MACSEC_NUM_AN; ++i) {\n\t\t\t\tmacsec_sa = mlx5e_rx_sc->rx_sa[i];\n\t\t\t\tif (!macsec_sa || !macsec_sa->active)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (macsec_sa->macsec_obj_id == obj_id)\n\t\t\t\t\treturn macsec_sa;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void macsec_epn_update(struct mlx5e_macsec *macsec, struct mlx5_core_dev *mdev,\n\t\t\t      struct mlx5e_macsec_sa *sa, u32 obj_id, u32 mode_param)\n{\n\tstruct mlx5_macsec_obj_attrs attrs = {};\n\tstruct mlx5e_macsec_aso_in in = {};\n\n\t \n\n\tif (mode_param < MLX5_MACSEC_EPN_SCOPE_MID) {\n\t\tsa->epn_state.epn_msb++;\n\t\tsa->epn_state.overlap = 0;\n\t} else {\n\t\tsa->epn_state.overlap = 1;\n\t}\n\n\tmacsec_build_accel_attrs(sa, &attrs);\n\tmlx5e_macsec_modify_obj(mdev, &attrs, obj_id);\n\n\t \n\tin.obj_id = obj_id;\n\tin.mode = MLX5_MACSEC_EPN;\n\tmacsec_aso_set_arm_event(mdev, macsec, &in);\n}\n\nstatic void macsec_async_event(struct work_struct *work)\n{\n\tstruct mlx5e_macsec_async_work *async_work;\n\tstruct mlx5e_macsec_aso_out out = {};\n\tstruct mlx5e_macsec_aso_in in = {};\n\tstruct mlx5e_macsec_sa *macsec_sa;\n\tstruct mlx5e_macsec *macsec;\n\tstruct mlx5_core_dev *mdev;\n\tu32 obj_id;\n\n\tasync_work = container_of(work, struct mlx5e_macsec_async_work, work);\n\tmacsec = async_work->macsec;\n\tmutex_lock(&macsec->lock);\n\n\tmdev = async_work->mdev;\n\tobj_id = async_work->obj_id;\n\tmacsec_sa = get_macsec_tx_sa_from_obj_id(macsec, obj_id);\n\tif (!macsec_sa) {\n\t\tmacsec_sa = get_macsec_rx_sa_from_obj_id(macsec, obj_id);\n\t\tif (!macsec_sa) {\n\t\t\tmlx5_core_dbg(mdev, \"MACsec SA is not found (SA object id %d)\\n\", obj_id);\n\t\t\tgoto out_async_work;\n\t\t}\n\t}\n\n\t \n\tin.obj_id = obj_id;\n\tmacsec_aso_query(mdev, macsec, &in, &out);\n\n\t \n\tif (macsec_sa->epn_state.epn_enabled && !(out.event_arm & MLX5E_ASO_EPN_ARM))\n\t\tmacsec_epn_update(macsec, mdev, macsec_sa, obj_id, out.mode_param);\n\nout_async_work:\n\tkfree(async_work);\n\tmutex_unlock(&macsec->lock);\n}\n\nstatic int macsec_obj_change_event(struct notifier_block *nb, unsigned long event, void *data)\n{\n\tstruct mlx5e_macsec *macsec = container_of(nb, struct mlx5e_macsec, nb);\n\tstruct mlx5e_macsec_async_work *async_work;\n\tstruct mlx5_eqe_obj_change *obj_change;\n\tstruct mlx5_eqe *eqe = data;\n\tu16 obj_type;\n\tu32 obj_id;\n\n\tif (event != MLX5_EVENT_TYPE_OBJECT_CHANGE)\n\t\treturn NOTIFY_DONE;\n\n\tobj_change = &eqe->data.obj_change;\n\tobj_type = be16_to_cpu(obj_change->obj_type);\n\tobj_id = be32_to_cpu(obj_change->obj_id);\n\n\tif (obj_type != MLX5_GENERAL_OBJECT_TYPES_MACSEC)\n\t\treturn NOTIFY_DONE;\n\n\tasync_work = kzalloc(sizeof(*async_work), GFP_ATOMIC);\n\tif (!async_work)\n\t\treturn NOTIFY_DONE;\n\n\tasync_work->macsec = macsec;\n\tasync_work->mdev = macsec->mdev;\n\tasync_work->obj_id = obj_id;\n\n\tINIT_WORK(&async_work->work, macsec_async_event);\n\n\tWARN_ON(!queue_work(macsec->wq, &async_work->work));\n\n\treturn NOTIFY_OK;\n}\n\nstatic int mlx5e_macsec_aso_init(struct mlx5e_macsec_aso *aso, struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_aso *maso;\n\tint err;\n\n\terr = mlx5_core_alloc_pd(mdev, &aso->pdn);\n\tif (err) {\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"MACsec offload: Failed to alloc pd for MACsec ASO, err=%d\\n\",\n\t\t\t      err);\n\t\treturn err;\n\t}\n\n\tmaso = mlx5_aso_create(mdev, aso->pdn);\n\tif (IS_ERR(maso)) {\n\t\terr = PTR_ERR(maso);\n\t\tgoto err_aso;\n\t}\n\n\terr = mlx5e_macsec_aso_reg_mr(mdev, aso);\n\tif (err)\n\t\tgoto err_aso_reg;\n\n\tmutex_init(&aso->aso_lock);\n\n\taso->maso = maso;\n\n\treturn 0;\n\nerr_aso_reg:\n\tmlx5_aso_destroy(maso);\nerr_aso:\n\tmlx5_core_dealloc_pd(mdev, aso->pdn);\n\treturn err;\n}\n\nstatic void mlx5e_macsec_aso_cleanup(struct mlx5e_macsec_aso *aso, struct mlx5_core_dev *mdev)\n{\n\tif (!aso)\n\t\treturn;\n\n\tmlx5e_macsec_aso_dereg_mr(mdev, aso);\n\n\tmlx5_aso_destroy(aso->maso);\n\n\tmlx5_core_dealloc_pd(mdev, aso->pdn);\n}\n\nstatic const struct macsec_ops macsec_offload_ops = {\n\t.mdo_add_txsa = mlx5e_macsec_add_txsa,\n\t.mdo_upd_txsa = mlx5e_macsec_upd_txsa,\n\t.mdo_del_txsa = mlx5e_macsec_del_txsa,\n\t.mdo_add_rxsc = mlx5e_macsec_add_rxsc,\n\t.mdo_upd_rxsc = mlx5e_macsec_upd_rxsc,\n\t.mdo_del_rxsc = mlx5e_macsec_del_rxsc,\n\t.mdo_add_rxsa = mlx5e_macsec_add_rxsa,\n\t.mdo_upd_rxsa = mlx5e_macsec_upd_rxsa,\n\t.mdo_del_rxsa = mlx5e_macsec_del_rxsa,\n\t.mdo_add_secy = mlx5e_macsec_add_secy,\n\t.mdo_upd_secy = mlx5e_macsec_upd_secy,\n\t.mdo_del_secy = mlx5e_macsec_del_secy,\n};\n\nbool mlx5e_macsec_handle_tx_skb(struct mlx5e_macsec *macsec, struct sk_buff *skb)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tu32 fs_id;\n\n\tfs_id = mlx5_macsec_fs_get_fs_id_from_hashtable(macsec->mdev->macsec_fs,\n\t\t\t\t\t\t\t&md_dst->u.macsec_info.sci);\n\tif (!fs_id)\n\t\tgoto err_out;\n\n\treturn true;\n\nerr_out:\n\tdev_kfree_skb_any(skb);\n\treturn false;\n}\n\nvoid mlx5e_macsec_tx_build_eseg(struct mlx5e_macsec *macsec,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct mlx5_wqe_eth_seg *eseg)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tu32 fs_id;\n\n\tfs_id = mlx5_macsec_fs_get_fs_id_from_hashtable(macsec->mdev->macsec_fs,\n\t\t\t\t\t\t\t&md_dst->u.macsec_info.sci);\n\tif (!fs_id)\n\t\treturn;\n\n\teseg->flow_table_metadata = cpu_to_be32(MLX5_ETH_WQE_FT_META_MACSEC | fs_id << 2);\n}\n\nvoid mlx5e_macsec_offload_handle_rx_skb(struct net_device *netdev,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct mlx5_cqe64 *cqe)\n{\n\tstruct mlx5e_macsec_rx_sc_xarray_element *sc_xarray_element;\n\tu32 macsec_meta_data = be32_to_cpu(cqe->ft_metadata);\n\tstruct mlx5e_priv *priv = macsec_netdev_priv(netdev);\n\tstruct mlx5e_macsec_rx_sc *rx_sc;\n\tstruct mlx5e_macsec *macsec;\n\tu32  fs_id;\n\n\tmacsec = priv->macsec;\n\tif (!macsec)\n\t\treturn;\n\n\tfs_id = MLX5_MACSEC_RX_METADAT_HANDLE(macsec_meta_data);\n\n\trcu_read_lock();\n\tsc_xarray_element = xa_load(&macsec->sc_xarray, fs_id);\n\trx_sc = sc_xarray_element->rx_sc;\n\tif (rx_sc) {\n\t\tdst_hold(&rx_sc->md_dst->dst);\n\t\tskb_dst_set(skb, &rx_sc->md_dst->dst);\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid mlx5e_macsec_build_netdev(struct mlx5e_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\n\tif (!mlx5e_is_macsec_device(priv->mdev))\n\t\treturn;\n\n\t \n\tmlx5_core_dbg(priv->mdev, \"mlx5e: MACsec acceleration enabled\\n\");\n\tnetdev->macsec_ops = &macsec_offload_ops;\n\tnetdev->features |= NETIF_F_HW_MACSEC;\n\tnetif_keep_dst(netdev);\n}\n\nint mlx5e_macsec_init(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_macsec *macsec = NULL;\n\tstruct mlx5_macsec_fs *macsec_fs;\n\tint err;\n\n\tif (!mlx5e_is_macsec_device(priv->mdev)) {\n\t\tmlx5_core_dbg(mdev, \"Not a MACsec offload device\\n\");\n\t\treturn 0;\n\t}\n\n\tmacsec = kzalloc(sizeof(*macsec), GFP_KERNEL);\n\tif (!macsec)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&macsec->macsec_device_list_head);\n\tmutex_init(&macsec->lock);\n\n\terr = mlx5e_macsec_aso_init(&macsec->aso, priv->mdev);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"MACsec offload: Failed to init aso, err=%d\\n\", err);\n\t\tgoto err_aso;\n\t}\n\n\tmacsec->wq = alloc_ordered_workqueue(\"mlx5e_macsec_%s\", 0, priv->netdev->name);\n\tif (!macsec->wq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wq;\n\t}\n\n\txa_init_flags(&macsec->sc_xarray, XA_FLAGS_ALLOC1);\n\n\tpriv->macsec = macsec;\n\n\tmacsec->mdev = mdev;\n\n\tmacsec_fs = mlx5_macsec_fs_init(mdev);\n\tif (!macsec_fs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tmdev->macsec_fs = macsec_fs;\n\n\tmacsec->nb.notifier_call = macsec_obj_change_event;\n\tmlx5_notifier_register(mdev, &macsec->nb);\n\n\tmlx5_core_dbg(mdev, \"MACsec attached to netdevice\\n\");\n\n\treturn 0;\n\nerr_out:\n\tdestroy_workqueue(macsec->wq);\nerr_wq:\n\tmlx5e_macsec_aso_cleanup(&macsec->aso, priv->mdev);\nerr_aso:\n\tkfree(macsec);\n\tpriv->macsec = NULL;\n\treturn err;\n}\n\nvoid mlx5e_macsec_cleanup(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_macsec *macsec = priv->macsec;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tif (!macsec)\n\t\treturn;\n\n\tmlx5_notifier_unregister(mdev, &macsec->nb);\n\tmlx5_macsec_fs_cleanup(mdev->macsec_fs);\n\tdestroy_workqueue(macsec->wq);\n\tmlx5e_macsec_aso_cleanup(&macsec->aso, mdev);\n\tmutex_destroy(&macsec->lock);\n\tkfree(macsec);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}