{
  "module_name": "meter.c",
  "hash_id": "2e2bddc3cb8872c417348ad673f16057bc42901e7e7b9415a34a3b95675feadf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/meter.c",
  "human_readable_source": "\n\n\n#include <linux/math64.h>\n#include \"lib/aso.h\"\n#include \"en/tc/post_act.h\"\n#include \"meter.h\"\n#include \"en/tc_priv.h\"\n\n#define MLX5_START_COLOR_SHIFT 28\n#define MLX5_METER_MODE_SHIFT 24\n#define MLX5_CBS_EXP_SHIFT 24\n#define MLX5_CBS_MAN_SHIFT 16\n#define MLX5_CIR_EXP_SHIFT 8\n\n \n#define MLX5_CONST_CIR 8000000000ULL\n#define MLX5_CALC_CIR(m, e)  ((MLX5_CONST_CIR * (m)) >> (e))\n#define MLX5_MAX_CIR ((MLX5_CONST_CIR * 0x100) - 1)\n\n \n#define MLX5_CALC_CBS(m, e)  ((m) << (e))\n#define MLX5_MAX_CBS ((0x100ULL << 0x1F) - 1)\n#define MLX5_MAX_HW_CBS 0x7FFFFFFF\n\nstruct mlx5e_flow_meter_aso_obj {\n\tstruct list_head entry;\n\tint base_id;\n\tint total_meters;\n\n\tunsigned long meters_map[];  \n};\n\nstruct mlx5e_flow_meters {\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5_aso *aso;\n\tstruct mutex aso_lock;  \n\tint log_granularity;\n\tu32 pdn;\n\n\tDECLARE_HASHTABLE(hashtbl, 8);\n\n\tstruct mutex sync_lock;  \n\tstruct list_head partial_list;\n\tstruct list_head full_list;\n\n\tstruct mlx5_core_dev *mdev;\n\tstruct mlx5e_post_act *post_act;\n};\n\nstatic void\nmlx5e_flow_meter_cir_calc(u64 cir, u8 *man, u8 *exp)\n{\n\ts64 _cir, _delta, delta = S64_MAX;\n\tu8 e, _man = 0, _exp = 0;\n\tu64 m;\n\n\tfor (e = 0; e <= 0x1F; e++) {  \n\t\tm = cir << e;\n\t\tif ((s64)m < 0)  \n\t\t\tbreak;\n\t\tm = div64_u64(m, MLX5_CONST_CIR);\n\t\tif (m > 0xFF)  \n\t\t\tcontinue;\n\t\t_cir = MLX5_CALC_CIR(m, e);\n\t\t_delta = cir - _cir;\n\t\tif (_delta < delta) {\n\t\t\t_man = m;\n\t\t\t_exp = e;\n\t\t\tif (!_delta)\n\t\t\t\tgoto found;\n\t\t\tdelta = _delta;\n\t\t}\n\t}\n\nfound:\n\t*man = _man;\n\t*exp = _exp;\n}\n\nstatic void\nmlx5e_flow_meter_cbs_calc(u64 cbs, u8 *man, u8 *exp)\n{\n\ts64 _cbs, _delta, delta = S64_MAX;\n\tu8 e, _man = 0, _exp = 0;\n\tu64 m;\n\n\tfor (e = 0; e <= 0x1F; e++) {  \n\t\tm = cbs >> e;\n\t\tif (m > 0xFF)  \n\t\t\tcontinue;\n\t\t_cbs = MLX5_CALC_CBS(m, e);\n\t\t_delta = cbs - _cbs;\n\t\tif (_delta < delta) {\n\t\t\t_man = m;\n\t\t\t_exp = e;\n\t\t\tif (!_delta)\n\t\t\t\tgoto found;\n\t\t\tdelta = _delta;\n\t\t}\n\t}\n\nfound:\n\t*man = _man;\n\t*exp = _exp;\n}\n\nint\nmlx5e_tc_meter_modify(struct mlx5_core_dev *mdev,\n\t\t      struct mlx5e_flow_meter_handle *meter,\n\t\t      struct mlx5e_flow_meter_params *meter_params)\n{\n\tstruct mlx5_wqe_aso_ctrl_seg *aso_ctrl;\n\tstruct mlx5_wqe_aso_data_seg *aso_data;\n\tstruct mlx5e_flow_meters *flow_meters;\n\tu8 cir_man, cir_exp, cbs_man, cbs_exp;\n\tstruct mlx5_aso_wqe *aso_wqe;\n\tunsigned long expires;\n\tstruct mlx5_aso *aso;\n\tu64 rate, burst;\n\tu8 ds_cnt;\n\tint err;\n\n\trate = meter_params->rate;\n\tburst = meter_params->burst;\n\n\t \n\tif (meter_params->mode == MLX5_RATE_LIMIT_PPS) {\n\t\trate <<= 10;\n\t\tburst <<= 7;\n\t}\n\n\tif (!rate || rate > MLX5_MAX_CIR || !burst || burst > MLX5_MAX_CBS)\n\t\treturn -EINVAL;\n\n\t \n\tif (burst > MLX5_MAX_HW_CBS) {\n\t\tmlx5_core_warn(mdev,\n\t\t\t       \"burst(%lld) is too large, use HW allowed value(%d)\\n\",\n\t\t\t       burst, MLX5_MAX_HW_CBS);\n\t\tburst = MLX5_MAX_HW_CBS;\n\t}\n\n\tmlx5_core_dbg(mdev, \"meter mode=%d\\n\", meter_params->mode);\n\tmlx5e_flow_meter_cir_calc(rate, &cir_man, &cir_exp);\n\tmlx5_core_dbg(mdev, \"rate=%lld, cir=%lld, exp=%d, man=%d\\n\",\n\t\t      rate, MLX5_CALC_CIR(cir_man, cir_exp), cir_exp, cir_man);\n\tmlx5e_flow_meter_cbs_calc(burst, &cbs_man, &cbs_exp);\n\tmlx5_core_dbg(mdev, \"burst=%lld, cbs=%lld, exp=%d, man=%d\\n\",\n\t\t      burst, MLX5_CALC_CBS((u64)cbs_man, cbs_exp), cbs_exp, cbs_man);\n\n\tif (!cir_man || !cbs_man)\n\t\treturn -EINVAL;\n\n\tflow_meters = meter->flow_meters;\n\taso = flow_meters->aso;\n\n\tmutex_lock(&flow_meters->aso_lock);\n\taso_wqe = mlx5_aso_get_wqe(aso);\n\tds_cnt = DIV_ROUND_UP(sizeof(struct mlx5_aso_wqe_data), MLX5_SEND_WQE_DS);\n\tmlx5_aso_build_wqe(aso, ds_cnt, aso_wqe, meter->obj_id,\n\t\t\t   MLX5_ACCESS_ASO_OPC_MOD_FLOW_METER);\n\n\taso_ctrl = &aso_wqe->aso_ctrl;\n\taso_ctrl->data_mask_mode = MLX5_ASO_DATA_MASK_MODE_BYTEWISE_64BYTE << 6;\n\taso_ctrl->condition_1_0_operand = MLX5_ASO_ALWAYS_TRUE |\n\t\t\t\t\t  MLX5_ASO_ALWAYS_TRUE << 4;\n\taso_ctrl->data_offset_condition_operand = MLX5_ASO_LOGICAL_OR << 6;\n\taso_ctrl->data_mask = cpu_to_be64(0x80FFFFFFULL << (meter->idx ? 0 : 32));\n\n\taso_data = (struct mlx5_wqe_aso_data_seg *)(aso_wqe + 1);\n\tmemset(aso_data, 0, sizeof(*aso_data));\n\taso_data->bytewise_data[meter->idx * 8] = cpu_to_be32((0x1 << 31) |  \n\t\t\t\t\t(MLX5_FLOW_METER_COLOR_GREEN << MLX5_START_COLOR_SHIFT));\n\tif (meter_params->mode == MLX5_RATE_LIMIT_PPS)\n\t\taso_data->bytewise_data[meter->idx * 8] |=\n\t\t\tcpu_to_be32(MLX5_FLOW_METER_MODE_NUM_PACKETS << MLX5_METER_MODE_SHIFT);\n\telse\n\t\taso_data->bytewise_data[meter->idx * 8] |=\n\t\t\tcpu_to_be32(MLX5_FLOW_METER_MODE_BYTES_IP_LENGTH << MLX5_METER_MODE_SHIFT);\n\n\taso_data->bytewise_data[meter->idx * 8 + 2] = cpu_to_be32((cbs_exp << MLX5_CBS_EXP_SHIFT) |\n\t\t\t\t\t\t\t\t  (cbs_man << MLX5_CBS_MAN_SHIFT) |\n\t\t\t\t\t\t\t\t  (cir_exp << MLX5_CIR_EXP_SHIFT) |\n\t\t\t\t\t\t\t\t  cir_man);\n\n\tmlx5_aso_post_wqe(aso, true, &aso_wqe->ctrl);\n\n\t \n\texpires = jiffies + msecs_to_jiffies(10);\n\tdo {\n\t\terr = mlx5_aso_poll_cq(aso, true);\n\t\tif (err)\n\t\t\tusleep_range(2, 10);\n\t} while (err && time_is_after_jiffies(expires));\n\tmutex_unlock(&flow_meters->aso_lock);\n\n\treturn err;\n}\n\nstatic int\nmlx5e_flow_meter_create_aso_obj(struct mlx5e_flow_meters *flow_meters, int *obj_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_flow_meter_aso_obj_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\tstruct mlx5_core_dev *mdev = flow_meters->mdev;\n\tvoid *obj, *param;\n\tint err;\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_GENERAL_OBJECT_TYPES_FLOW_METER_ASO);\n\tparam = MLX5_ADDR_OF(general_obj_in_cmd_hdr, in, op_param);\n\tMLX5_SET(general_obj_create_param, param, log_obj_range,\n\t\t flow_meters->log_granularity);\n\n\tobj = MLX5_ADDR_OF(create_flow_meter_aso_obj_in, in, flow_meter_aso_obj);\n\tMLX5_SET(flow_meter_aso_obj, obj, meter_aso_access_pd, flow_meters->pdn);\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (!err) {\n\t\t*obj_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\t\tmlx5_core_dbg(mdev, \"flow meter aso obj(0x%x) created\\n\", *obj_id);\n\t}\n\n\treturn err;\n}\n\nstatic void\nmlx5e_flow_meter_destroy_aso_obj(struct mlx5_core_dev *mdev, u32 obj_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_GENERAL_OBJECT_TYPES_FLOW_METER_ASO);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, obj_id);\n\n\tmlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tmlx5_core_dbg(mdev, \"flow meter aso obj(0x%x) destroyed\\n\", obj_id);\n}\n\nstatic struct mlx5e_flow_meter_handle *\n__mlx5e_flow_meter_alloc(struct mlx5e_flow_meters *flow_meters, bool alloc_aso)\n{\n\tstruct mlx5_core_dev *mdev = flow_meters->mdev;\n\tstruct mlx5e_flow_meter_aso_obj *meters_obj;\n\tstruct mlx5e_flow_meter_handle *meter;\n\tstruct mlx5_fc *counter;\n\tint err, pos, total;\n\tu32 id;\n\n\tmeter = kzalloc(sizeof(*meter), GFP_KERNEL);\n\tif (!meter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcounter = mlx5_fc_create(mdev, true);\n\tif (IS_ERR(counter)) {\n\t\terr = PTR_ERR(counter);\n\t\tgoto err_drop_counter;\n\t}\n\tmeter->drop_counter = counter;\n\n\tcounter = mlx5_fc_create(mdev, true);\n\tif (IS_ERR(counter)) {\n\t\terr = PTR_ERR(counter);\n\t\tgoto err_act_counter;\n\t}\n\tmeter->act_counter = counter;\n\n\tif (!alloc_aso)\n\t\tgoto no_aso;\n\n\tmeters_obj = list_first_entry_or_null(&flow_meters->partial_list,\n\t\t\t\t\t      struct mlx5e_flow_meter_aso_obj,\n\t\t\t\t\t      entry);\n\t \n\ttotal = 1 << (flow_meters->log_granularity + 1);\n\tif (!meters_obj) {\n\t\terr = mlx5e_flow_meter_create_aso_obj(flow_meters, &id);\n\t\tif (err) {\n\t\t\tmlx5_core_err(mdev, \"Failed to create flow meter ASO object\\n\");\n\t\t\tgoto err_create;\n\t\t}\n\n\t\tmeters_obj = kzalloc(sizeof(*meters_obj) + BITS_TO_BYTES(total),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!meters_obj) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\tmeters_obj->base_id = id;\n\t\tmeters_obj->total_meters = total;\n\t\tlist_add(&meters_obj->entry, &flow_meters->partial_list);\n\t\tpos = 0;\n\t} else {\n\t\tpos = find_first_zero_bit(meters_obj->meters_map, total);\n\t\tif (bitmap_weight(meters_obj->meters_map, total) == total - 1) {\n\t\t\tlist_del(&meters_obj->entry);\n\t\t\tlist_add(&meters_obj->entry, &flow_meters->full_list);\n\t\t}\n\t}\n\n\tbitmap_set(meters_obj->meters_map, pos, 1);\n\tmeter->meters_obj = meters_obj;\n\tmeter->obj_id = meters_obj->base_id + pos / 2;\n\tmeter->idx = pos % 2;\n\nno_aso:\n\tmeter->flow_meters = flow_meters;\n\tmlx5_core_dbg(mdev, \"flow meter allocated, obj_id=0x%x, index=%d\\n\",\n\t\t      meter->obj_id, meter->idx);\n\n\treturn meter;\n\nerr_mem:\n\tmlx5e_flow_meter_destroy_aso_obj(mdev, id);\nerr_create:\n\tmlx5_fc_destroy(mdev, meter->act_counter);\nerr_act_counter:\n\tmlx5_fc_destroy(mdev, meter->drop_counter);\nerr_drop_counter:\n\tkfree(meter);\n\treturn ERR_PTR(err);\n}\n\nstatic void\n__mlx5e_flow_meter_free(struct mlx5e_flow_meter_handle *meter)\n{\n\tstruct mlx5e_flow_meters *flow_meters = meter->flow_meters;\n\tstruct mlx5_core_dev *mdev = flow_meters->mdev;\n\tstruct mlx5e_flow_meter_aso_obj *meters_obj;\n\tint n, pos;\n\n\tmlx5_fc_destroy(mdev, meter->act_counter);\n\tmlx5_fc_destroy(mdev, meter->drop_counter);\n\n\tif (meter->params.mtu)\n\t\tgoto out_no_aso;\n\n\tmeters_obj = meter->meters_obj;\n\tpos = (meter->obj_id - meters_obj->base_id) * 2 + meter->idx;\n\tbitmap_clear(meters_obj->meters_map, pos, 1);\n\tn = bitmap_weight(meters_obj->meters_map, meters_obj->total_meters);\n\tif (n == 0) {\n\t\tlist_del(&meters_obj->entry);\n\t\tmlx5e_flow_meter_destroy_aso_obj(mdev, meters_obj->base_id);\n\t\tkfree(meters_obj);\n\t} else if (n == meters_obj->total_meters - 1) {\n\t\tlist_del(&meters_obj->entry);\n\t\tlist_add(&meters_obj->entry, &flow_meters->partial_list);\n\t}\n\nout_no_aso:\n\tmlx5_core_dbg(mdev, \"flow meter freed, obj_id=0x%x, index=%d\\n\",\n\t\t      meter->obj_id, meter->idx);\n\tkfree(meter);\n}\n\nstatic struct mlx5e_flow_meter_handle *\n__mlx5e_tc_meter_get(struct mlx5e_flow_meters *flow_meters, u32 index)\n{\n\tstruct mlx5e_flow_meter_handle *meter;\n\n\thash_for_each_possible(flow_meters->hashtbl, meter, hlist, index)\n\t\tif (meter->params.index == index)\n\t\t\tgoto add_ref;\n\n\treturn ERR_PTR(-ENOENT);\n\nadd_ref:\n\tmeter->refcnt++;\n\n\treturn meter;\n}\n\nstruct mlx5e_flow_meter_handle *\nmlx5e_tc_meter_get(struct mlx5_core_dev *mdev, struct mlx5e_flow_meter_params *params)\n{\n\tstruct mlx5e_flow_meters *flow_meters;\n\tstruct mlx5e_flow_meter_handle *meter;\n\n\tflow_meters = mlx5e_get_flow_meters(mdev);\n\tif (!flow_meters)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tmutex_lock(&flow_meters->sync_lock);\n\tmeter = __mlx5e_tc_meter_get(flow_meters, params->index);\n\tmutex_unlock(&flow_meters->sync_lock);\n\n\treturn meter;\n}\n\nstatic void\n__mlx5e_tc_meter_put(struct mlx5e_flow_meter_handle *meter)\n{\n\tif (--meter->refcnt == 0) {\n\t\thash_del(&meter->hlist);\n\t\t__mlx5e_flow_meter_free(meter);\n\t}\n}\n\nvoid\nmlx5e_tc_meter_put(struct mlx5e_flow_meter_handle *meter)\n{\n\tstruct mlx5e_flow_meters *flow_meters = meter->flow_meters;\n\n\tmutex_lock(&flow_meters->sync_lock);\n\t__mlx5e_tc_meter_put(meter);\n\tmutex_unlock(&flow_meters->sync_lock);\n}\n\nstatic struct mlx5e_flow_meter_handle *\nmlx5e_tc_meter_alloc(struct mlx5e_flow_meters *flow_meters,\n\t\t     struct mlx5e_flow_meter_params *params)\n{\n\tstruct mlx5e_flow_meter_handle *meter;\n\n\tmeter = __mlx5e_flow_meter_alloc(flow_meters, !params->mtu);\n\tif (IS_ERR(meter))\n\t\treturn meter;\n\n\thash_add(flow_meters->hashtbl, &meter->hlist, params->index);\n\tmeter->params.index = params->index;\n\tmeter->params.mtu = params->mtu;\n\tmeter->refcnt++;\n\n\treturn meter;\n}\n\nstatic int\n__mlx5e_tc_meter_update(struct mlx5e_flow_meter_handle *meter,\n\t\t\tstruct mlx5e_flow_meter_params *params)\n{\n\tstruct mlx5_core_dev *mdev = meter->flow_meters->mdev;\n\tint err = 0;\n\n\tif (meter->params.mode != params->mode || meter->params.rate != params->rate ||\n\t    meter->params.burst != params->burst) {\n\t\terr = mlx5e_tc_meter_modify(mdev, meter, params);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmeter->params.mode = params->mode;\n\t\tmeter->params.rate = params->rate;\n\t\tmeter->params.burst = params->burst;\n\t}\n\nout:\n\treturn err;\n}\n\nint\nmlx5e_tc_meter_update(struct mlx5e_flow_meter_handle *meter,\n\t\t      struct mlx5e_flow_meter_params *params)\n{\n\tstruct mlx5_core_dev *mdev = meter->flow_meters->mdev;\n\tstruct mlx5e_flow_meters *flow_meters;\n\tint err;\n\n\tflow_meters = mlx5e_get_flow_meters(mdev);\n\tif (!flow_meters)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&flow_meters->sync_lock);\n\terr = __mlx5e_tc_meter_update(meter, params);\n\tmutex_unlock(&flow_meters->sync_lock);\n\treturn err;\n}\n\nstruct mlx5e_flow_meter_handle *\nmlx5e_tc_meter_replace(struct mlx5_core_dev *mdev, struct mlx5e_flow_meter_params *params)\n{\n\tstruct mlx5e_flow_meters *flow_meters;\n\tstruct mlx5e_flow_meter_handle *meter;\n\tint err;\n\n\tflow_meters = mlx5e_get_flow_meters(mdev);\n\tif (!flow_meters)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tmutex_lock(&flow_meters->sync_lock);\n\tmeter = __mlx5e_tc_meter_get(flow_meters, params->index);\n\tif (IS_ERR(meter)) {\n\t\tmeter = mlx5e_tc_meter_alloc(flow_meters, params);\n\t\tif (IS_ERR(meter)) {\n\t\t\terr = PTR_ERR(meter);\n\t\t\tgoto err_get;\n\t\t}\n\t}\n\n\terr = __mlx5e_tc_meter_update(meter, params);\n\tif (err)\n\t\tgoto err_update;\n\n\tmutex_unlock(&flow_meters->sync_lock);\n\treturn meter;\n\nerr_update:\n\t__mlx5e_tc_meter_put(meter);\nerr_get:\n\tmutex_unlock(&flow_meters->sync_lock);\n\treturn ERR_PTR(err);\n}\n\nenum mlx5_flow_namespace_type\nmlx5e_tc_meter_get_namespace(struct mlx5e_flow_meters *flow_meters)\n{\n\treturn flow_meters->ns_type;\n}\n\nstruct mlx5e_flow_meters *\nmlx5e_flow_meters_init(struct mlx5e_priv *priv,\n\t\t       enum mlx5_flow_namespace_type ns_type,\n\t\t       struct mlx5e_post_act *post_act)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_flow_meters *flow_meters;\n\tint err;\n\n\tif (!(MLX5_CAP_GEN_64(mdev, general_obj_types) &\n\t      MLX5_HCA_CAP_GENERAL_OBJECT_TYPES_FLOW_METER_ASO))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (IS_ERR_OR_NULL(post_act)) {\n\t\tnetdev_dbg(priv->netdev,\n\t\t\t   \"flow meter offload is not supported, post action is missing\\n\");\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tflow_meters = kzalloc(sizeof(*flow_meters), GFP_KERNEL);\n\tif (!flow_meters)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlx5_core_alloc_pd(mdev, &flow_meters->pdn);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Failed to alloc pd for flow meter aso, err=%d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\tflow_meters->aso = mlx5_aso_create(mdev, flow_meters->pdn);\n\tif (IS_ERR(flow_meters->aso)) {\n\t\tmlx5_core_warn(mdev, \"Failed to create aso wqe for flow meter\\n\");\n\t\terr = PTR_ERR(flow_meters->aso);\n\t\tgoto err_sq;\n\t}\n\n\tmutex_init(&flow_meters->sync_lock);\n\tINIT_LIST_HEAD(&flow_meters->partial_list);\n\tINIT_LIST_HEAD(&flow_meters->full_list);\n\n\tflow_meters->ns_type = ns_type;\n\tflow_meters->mdev = mdev;\n\tflow_meters->post_act = post_act;\n\tmutex_init(&flow_meters->aso_lock);\n\tflow_meters->log_granularity = min_t(int, 6,\n\t\t\t\t\t     MLX5_CAP_QOS(mdev, log_meter_aso_max_alloc));\n\n\treturn flow_meters;\n\nerr_sq:\n\tmlx5_core_dealloc_pd(mdev, flow_meters->pdn);\nerr_out:\n\tkfree(flow_meters);\n\treturn ERR_PTR(err);\n}\n\nvoid\nmlx5e_flow_meters_cleanup(struct mlx5e_flow_meters *flow_meters)\n{\n\tif (IS_ERR_OR_NULL(flow_meters))\n\t\treturn;\n\n\tmlx5_aso_destroy(flow_meters->aso);\n\tmlx5_core_dealloc_pd(flow_meters->mdev, flow_meters->pdn);\n\tkfree(flow_meters);\n}\n\nvoid\nmlx5e_tc_meter_get_stats(struct mlx5e_flow_meter_handle *meter,\n\t\t\t u64 *bytes, u64 *packets, u64 *drops, u64 *lastuse)\n{\n\tu64 bytes1, packets1, lastuse1;\n\tu64 bytes2, packets2, lastuse2;\n\n\tmlx5_fc_query_cached(meter->act_counter, &bytes1, &packets1, &lastuse1);\n\tmlx5_fc_query_cached(meter->drop_counter, &bytes2, &packets2, &lastuse2);\n\n\t*bytes = bytes1 + bytes2;\n\t*packets = packets1 + packets2;\n\t*drops = packets2;\n\t*lastuse = max_t(u64, lastuse1, lastuse2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}