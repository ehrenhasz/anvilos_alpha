{
  "module_name": "ipsec_fs.c",
  "hash_id": "78b3d285710a33035e878eb1f1c330da09a8a42d75a4be1feb8ca3e23b73da7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include \"en.h\"\n#include \"en/fs.h\"\n#include \"eswitch.h\"\n#include \"ipsec.h\"\n#include \"fs_core.h\"\n#include \"lib/ipsec_fs_roce.h\"\n#include \"lib/fs_chains.h\"\n#include \"esw/ipsec_fs.h\"\n#include \"en_rep.h\"\n\n#define NUM_IPSEC_FTE BIT(15)\n#define MLX5_REFORMAT_TYPE_ADD_ESP_TRANSPORT_SIZE 16\n#define IPSEC_TUNNEL_DEFAULT_TTL 0x40\n\nstruct mlx5e_ipsec_fc {\n\tstruct mlx5_fc *cnt;\n\tstruct mlx5_fc *drop;\n};\n\nstruct mlx5e_ipsec_tx {\n\tstruct mlx5e_ipsec_ft ft;\n\tstruct mlx5e_ipsec_miss pol;\n\tstruct mlx5e_ipsec_miss sa;\n\tstruct mlx5e_ipsec_rule status;\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5e_ipsec_fc *fc;\n\tstruct mlx5_fs_chains *chains;\n\tu8 allow_tunnel_mode : 1;\n};\n\n \nstatic enum mlx5_traffic_types family2tt(u32 family)\n{\n\tif (family == AF_INET)\n\t\treturn MLX5_TT_IPV4_IPSEC_ESP;\n\treturn MLX5_TT_IPV6_IPSEC_ESP;\n}\n\nstatic struct mlx5e_ipsec_rx *ipsec_rx(struct mlx5e_ipsec *ipsec, u32 family, int type)\n{\n\tif (ipsec->is_uplink_rep && type == XFRM_DEV_OFFLOAD_PACKET)\n\t\treturn ipsec->rx_esw;\n\n\tif (family == AF_INET)\n\t\treturn ipsec->rx_ipv4;\n\n\treturn ipsec->rx_ipv6;\n}\n\nstatic struct mlx5e_ipsec_tx *ipsec_tx(struct mlx5e_ipsec *ipsec, int type)\n{\n\tif (ipsec->is_uplink_rep && type == XFRM_DEV_OFFLOAD_PACKET)\n\t\treturn ipsec->tx_esw;\n\n\treturn ipsec->tx;\n}\n\nstatic struct mlx5_fs_chains *\nipsec_chains_create(struct mlx5_core_dev *mdev, struct mlx5_flow_table *miss_ft,\n\t\t    enum mlx5_flow_namespace_type ns, int base_prio,\n\t\t    int base_level, struct mlx5_flow_table **root_ft)\n{\n\tstruct mlx5_chains_attr attr = {};\n\tstruct mlx5_fs_chains *chains;\n\tstruct mlx5_flow_table *ft;\n\tint err;\n\n\tattr.flags = MLX5_CHAINS_AND_PRIOS_SUPPORTED |\n\t\t     MLX5_CHAINS_IGNORE_FLOW_LEVEL_SUPPORTED;\n\tattr.max_grp_num = 2;\n\tattr.default_ft = miss_ft;\n\tattr.ns = ns;\n\tattr.fs_base_prio = base_prio;\n\tattr.fs_base_level = base_level;\n\tchains = mlx5_chains_create(mdev, &attr);\n\tif (IS_ERR(chains))\n\t\treturn chains;\n\n\t \n\tft = mlx5_chains_get_table(chains, 0, 1, 0);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_chains_get;\n\t}\n\n\t*root_ft = ft;\n\treturn chains;\n\nerr_chains_get:\n\tmlx5_chains_destroy(chains);\n\treturn ERR_PTR(err);\n}\n\nstatic void ipsec_chains_destroy(struct mlx5_fs_chains *chains)\n{\n\tmlx5_chains_put_table(chains, 0, 1, 0);\n\tmlx5_chains_destroy(chains);\n}\n\nstatic struct mlx5_flow_table *\nipsec_chains_get_table(struct mlx5_fs_chains *chains, u32 prio)\n{\n\treturn mlx5_chains_get_table(chains, 0, prio + 1, 0);\n}\n\nstatic void ipsec_chains_put_table(struct mlx5_fs_chains *chains, u32 prio)\n{\n\tmlx5_chains_put_table(chains, 0, prio + 1, 0);\n}\n\nstatic struct mlx5_flow_table *ipsec_ft_create(struct mlx5_flow_namespace *ns,\n\t\t\t\t\t       int level, int prio,\n\t\t\t\t\t       int max_num_groups, u32 flags)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\n\tft_attr.autogroup.num_reserved_entries = 1;\n\tft_attr.autogroup.max_num_groups = max_num_groups;\n\tft_attr.max_fte = NUM_IPSEC_FTE;\n\tft_attr.level = level;\n\tft_attr.prio = prio;\n\tft_attr.flags = flags;\n\n\treturn mlx5_create_auto_grouped_flow_table(ns, &ft_attr);\n}\n\nstatic void ipsec_rx_status_drop_destroy(struct mlx5e_ipsec *ipsec,\n\t\t\t\t\t struct mlx5e_ipsec_rx *rx)\n{\n\tmlx5_del_flow_rules(rx->status_drop.rule);\n\tmlx5_destroy_flow_group(rx->status_drop.group);\n\tmlx5_fc_destroy(ipsec->mdev, rx->status_drop_cnt);\n}\n\nstatic void ipsec_rx_status_pass_destroy(struct mlx5e_ipsec *ipsec,\n\t\t\t\t\t struct mlx5e_ipsec_rx *rx)\n{\n\tmlx5_del_flow_rules(rx->status.rule);\n\n\tif (rx != ipsec->rx_esw)\n\t\treturn;\n\n#ifdef CONFIG_MLX5_ESWITCH\n\tmlx5_chains_put_table(esw_chains(ipsec->mdev->priv.eswitch), 0, 1, 0);\n#endif\n}\n\nstatic int ipsec_rx_status_drop_create(struct mlx5e_ipsec *ipsec,\n\t\t\t\t       struct mlx5e_ipsec_rx *rx)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_table *ft = rx->ft.status;\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_fc *flow_counter;\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5_flow_group *g;\n\tu32 *flow_group_in;\n\tint err = 0;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!flow_group_in || !spec) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, ft->max_fte - 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, ft->max_fte - 1);\n\tg = mlx5_create_flow_group(ft, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to add ipsec rx status drop flow group, err=%d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\tflow_counter = mlx5_fc_create(mdev, false);\n\tif (IS_ERR(flow_counter)) {\n\t\terr = PTR_ERR(flow_counter);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to add ipsec rx status drop rule counter, err=%d\\n\", err);\n\t\tgoto err_cnt;\n\t}\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP | MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest.counter_id = mlx5_fc_id(flow_counter);\n\tif (rx == ipsec->rx_esw)\n\t\tspec->flow_context.flow_source = MLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK;\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to add ipsec rx status drop rule, err=%d\\n\", err);\n\t\tgoto err_rule;\n\t}\n\n\trx->status_drop.group = g;\n\trx->status_drop.rule = rule;\n\trx->status_drop_cnt = flow_counter;\n\n\tkvfree(flow_group_in);\n\tkvfree(spec);\n\treturn 0;\n\nerr_rule:\n\tmlx5_fc_destroy(mdev, flow_counter);\nerr_cnt:\n\tmlx5_destroy_flow_group(g);\nerr_out:\n\tkvfree(flow_group_in);\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic int ipsec_rx_status_pass_create(struct mlx5e_ipsec *ipsec,\n\t\t\t\t       struct mlx5e_ipsec_rx *rx,\n\t\t\t\t       struct mlx5_flow_destination *dest)\n{\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t misc_parameters_2.ipsec_syndrome);\n\tMLX5_SET(fte_match_param, spec->match_value,\n\t\t misc_parameters_2.ipsec_syndrome, 0);\n\tif (rx == ipsec->rx_esw)\n\t\tspec->flow_context.flow_source = MLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK;\n\tspec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;\n\tflow_act.flags = FLOW_ACT_NO_APPEND;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\trule = mlx5_add_flow_rules(rx->ft.status, spec, &flow_act, dest, 2);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_warn(ipsec->mdev,\n\t\t\t       \"Failed to add ipsec rx status pass rule, err=%d\\n\", err);\n\t\tgoto err_rule;\n\t}\n\n\trx->status.rule = rule;\n\tkvfree(spec);\n\treturn 0;\n\nerr_rule:\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic void mlx5_ipsec_rx_status_destroy(struct mlx5e_ipsec *ipsec,\n\t\t\t\t\t struct mlx5e_ipsec_rx *rx)\n{\n\tipsec_rx_status_pass_destroy(ipsec, rx);\n\tipsec_rx_status_drop_destroy(ipsec, rx);\n}\n\nstatic int mlx5_ipsec_rx_status_create(struct mlx5e_ipsec *ipsec,\n\t\t\t\t       struct mlx5e_ipsec_rx *rx,\n\t\t\t\t       struct mlx5_flow_destination *dest)\n{\n\tint err;\n\n\terr = ipsec_rx_status_drop_create(ipsec, rx);\n\tif (err)\n\t\treturn err;\n\n\terr = ipsec_rx_status_pass_create(ipsec, rx, dest);\n\tif (err)\n\t\tgoto err_pass_create;\n\n\treturn 0;\n\nerr_pass_create:\n\tipsec_rx_status_drop_destroy(ipsec, rx);\n\treturn err;\n}\n\nstatic int ipsec_miss_create(struct mlx5_core_dev *mdev,\n\t\t\t     struct mlx5_flow_table *ft,\n\t\t\t     struct mlx5e_ipsec_miss *miss,\n\t\t\t     struct mlx5_flow_destination *dest)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_spec *spec;\n\tu32 *flow_group_in;\n\tint err = 0;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!flow_group_in || !spec) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, ft->max_fte - 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, ft->max_fte - 1);\n\tmiss->group = mlx5_create_flow_group(ft, flow_group_in);\n\tif (IS_ERR(miss->group)) {\n\t\terr = PTR_ERR(miss->group);\n\t\tmlx5_core_err(mdev, \"fail to create IPsec miss_group err=%d\\n\",\n\t\t\t      err);\n\t\tgoto out;\n\t}\n\n\t \n\tmiss->rule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, 1);\n\tif (IS_ERR(miss->rule)) {\n\t\tmlx5_destroy_flow_group(miss->group);\n\t\terr = PTR_ERR(miss->rule);\n\t\tmlx5_core_err(mdev, \"fail to create IPsec miss_rule err=%d\\n\",\n\t\t\t      err);\n\t\tgoto out;\n\t}\nout:\n\tkvfree(flow_group_in);\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic void ipsec_rx_ft_disconnect(struct mlx5e_ipsec *ipsec, u32 family)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(ipsec->fs, false);\n\n\tmlx5_ttc_fwd_default_dest(ttc, family2tt(family));\n}\n\nstatic void rx_destroy(struct mlx5_core_dev *mdev, struct mlx5e_ipsec *ipsec,\n\t\t       struct mlx5e_ipsec_rx *rx, u32 family)\n{\n\t \n\tif (rx != ipsec->rx_esw)\n\t\tipsec_rx_ft_disconnect(ipsec, family);\n\n\tif (rx->chains) {\n\t\tipsec_chains_destroy(rx->chains);\n\t} else {\n\t\tmlx5_del_flow_rules(rx->pol.rule);\n\t\tmlx5_destroy_flow_group(rx->pol.group);\n\t\tmlx5_destroy_flow_table(rx->ft.pol);\n\t}\n\n\tmlx5_del_flow_rules(rx->sa.rule);\n\tmlx5_destroy_flow_group(rx->sa.group);\n\tmlx5_destroy_flow_table(rx->ft.sa);\n\tif (rx->allow_tunnel_mode)\n\t\tmlx5_eswitch_unblock_encap(mdev);\n\tmlx5_ipsec_rx_status_destroy(ipsec, rx);\n\tmlx5_destroy_flow_table(rx->ft.status);\n\n\tmlx5_ipsec_fs_roce_rx_destroy(ipsec->roce, family);\n}\n\nstatic void ipsec_rx_create_attr_set(struct mlx5e_ipsec *ipsec,\n\t\t\t\t     struct mlx5e_ipsec_rx *rx,\n\t\t\t\t     u32 family,\n\t\t\t\t     struct mlx5e_ipsec_rx_create_attr *attr)\n{\n\tif (rx == ipsec->rx_esw) {\n\t\t \n\t\tattr->ns = ipsec->tx_esw->ns;\n\t\tmlx5_esw_ipsec_rx_create_attr_set(ipsec, attr);\n\t\treturn;\n\t}\n\n\tattr->ns = mlx5e_fs_get_ns(ipsec->fs, false);\n\tattr->ttc = mlx5e_fs_get_ttc(ipsec->fs, false);\n\tattr->family = family;\n\tattr->prio = MLX5E_NIC_PRIO;\n\tattr->pol_level = MLX5E_ACCEL_FS_POL_FT_LEVEL;\n\tattr->sa_level = MLX5E_ACCEL_FS_ESP_FT_LEVEL;\n\tattr->status_level = MLX5E_ACCEL_FS_ESP_FT_ERR_LEVEL;\n\tattr->chains_ns = MLX5_FLOW_NAMESPACE_KERNEL;\n}\n\nstatic int ipsec_rx_status_pass_dest_get(struct mlx5e_ipsec *ipsec,\n\t\t\t\t\t struct mlx5e_ipsec_rx *rx,\n\t\t\t\t\t struct mlx5e_ipsec_rx_create_attr *attr,\n\t\t\t\t\t struct mlx5_flow_destination *dest)\n{\n\tstruct mlx5_flow_table *ft;\n\tint err;\n\n\tif (rx == ipsec->rx_esw)\n\t\treturn mlx5_esw_ipsec_rx_status_pass_dest_get(ipsec, dest);\n\n\t*dest = mlx5_ttc_get_default_dest(attr->ttc, family2tt(attr->family));\n\terr = mlx5_ipsec_fs_roce_rx_create(ipsec->mdev, ipsec->roce, attr->ns, dest,\n\t\t\t\t\t   attr->family, MLX5E_ACCEL_FS_ESP_FT_ROCE_LEVEL,\n\t\t\t\t\t   attr->prio);\n\tif (err)\n\t\treturn err;\n\n\tft = mlx5_ipsec_fs_roce_ft_get(ipsec->roce, attr->family);\n\tif (ft) {\n\t\tdest->type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\tdest->ft = ft;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipsec_rx_ft_connect(struct mlx5e_ipsec *ipsec,\n\t\t\t\tstruct mlx5e_ipsec_rx *rx,\n\t\t\t\tstruct mlx5e_ipsec_rx_create_attr *attr)\n{\n\tstruct mlx5_flow_destination dest = {};\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = rx->ft.pol;\n\tmlx5_ttc_fwd_dest(attr->ttc, family2tt(attr->family), &dest);\n}\n\nstatic int rx_create(struct mlx5_core_dev *mdev, struct mlx5e_ipsec *ipsec,\n\t\t     struct mlx5e_ipsec_rx *rx, u32 family)\n{\n\tstruct mlx5e_ipsec_rx_create_attr attr;\n\tstruct mlx5_flow_destination dest[2];\n\tstruct mlx5_flow_table *ft;\n\tu32 flags = 0;\n\tint err;\n\n\tipsec_rx_create_attr_set(ipsec, rx, family, &attr);\n\n\terr = ipsec_rx_status_pass_dest_get(ipsec, rx, &attr, &dest[0]);\n\tif (err)\n\t\treturn err;\n\n\tft = ipsec_ft_create(attr.ns, attr.status_level, attr.prio, 1, 0);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_fs_ft_status;\n\t}\n\trx->ft.status = ft;\n\n\tdest[1].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest[1].counter_id = mlx5_fc_id(rx->fc->cnt);\n\terr = mlx5_ipsec_rx_status_create(ipsec, rx, dest);\n\tif (err)\n\t\tgoto err_add;\n\n\t \n\tif (mlx5_ipsec_device_caps(mdev) & MLX5_IPSEC_CAP_TUNNEL)\n\t\trx->allow_tunnel_mode = mlx5_eswitch_block_encap(mdev);\n\tif (rx->allow_tunnel_mode)\n\t\tflags = MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\tft = ipsec_ft_create(attr.ns, attr.sa_level, attr.prio, 2, flags);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_fs_ft;\n\t}\n\trx->ft.sa = ft;\n\n\terr = ipsec_miss_create(mdev, rx->ft.sa, &rx->sa, dest);\n\tif (err)\n\t\tgoto err_fs;\n\n\tif (mlx5_ipsec_device_caps(mdev) & MLX5_IPSEC_CAP_PRIO) {\n\t\trx->chains = ipsec_chains_create(mdev, rx->ft.sa,\n\t\t\t\t\t\t attr.chains_ns,\n\t\t\t\t\t\t attr.prio,\n\t\t\t\t\t\t attr.pol_level,\n\t\t\t\t\t\t &rx->ft.pol);\n\t\tif (IS_ERR(rx->chains)) {\n\t\t\terr = PTR_ERR(rx->chains);\n\t\t\tgoto err_pol_ft;\n\t\t}\n\n\t\tgoto connect;\n\t}\n\n\tft = ipsec_ft_create(attr.ns, attr.pol_level, attr.prio, 2, 0);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_pol_ft;\n\t}\n\trx->ft.pol = ft;\n\tmemset(dest, 0x00, 2 * sizeof(*dest));\n\tdest[0].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest[0].ft = rx->ft.sa;\n\terr = ipsec_miss_create(mdev, rx->ft.pol, &rx->pol, dest);\n\tif (err)\n\t\tgoto err_pol_miss;\n\nconnect:\n\t \n\tif (rx != ipsec->rx_esw)\n\t\tipsec_rx_ft_connect(ipsec, rx, &attr);\n\treturn 0;\n\nerr_pol_miss:\n\tmlx5_destroy_flow_table(rx->ft.pol);\nerr_pol_ft:\n\tmlx5_del_flow_rules(rx->sa.rule);\n\tmlx5_destroy_flow_group(rx->sa.group);\nerr_fs:\n\tmlx5_destroy_flow_table(rx->ft.sa);\nerr_fs_ft:\n\tif (rx->allow_tunnel_mode)\n\t\tmlx5_eswitch_unblock_encap(mdev);\n\tmlx5_del_flow_rules(rx->status.rule);\n\tmlx5_modify_header_dealloc(mdev, rx->status.modify_hdr);\nerr_add:\n\tmlx5_destroy_flow_table(rx->ft.status);\nerr_fs_ft_status:\n\tmlx5_ipsec_fs_roce_rx_destroy(ipsec->roce, family);\n\treturn err;\n}\n\nstatic int rx_get(struct mlx5_core_dev *mdev, struct mlx5e_ipsec *ipsec,\n\t\t  struct mlx5e_ipsec_rx *rx, u32 family)\n{\n\tint err;\n\n\tif (rx->ft.refcnt)\n\t\tgoto skip;\n\n\terr = mlx5_eswitch_block_mode(mdev);\n\tif (err)\n\t\treturn err;\n\n\terr = rx_create(mdev, ipsec, rx, family);\n\tif (err) {\n\t\tmlx5_eswitch_unblock_mode(mdev);\n\t\treturn err;\n\t}\n\nskip:\n\trx->ft.refcnt++;\n\treturn 0;\n}\n\nstatic void rx_put(struct mlx5e_ipsec *ipsec, struct mlx5e_ipsec_rx *rx,\n\t\t   u32 family)\n{\n\tif (--rx->ft.refcnt)\n\t\treturn;\n\n\trx_destroy(ipsec->mdev, ipsec, rx, family);\n\tmlx5_eswitch_unblock_mode(ipsec->mdev);\n}\n\nstatic struct mlx5e_ipsec_rx *rx_ft_get(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5e_ipsec *ipsec, u32 family,\n\t\t\t\t\tint type)\n{\n\tstruct mlx5e_ipsec_rx *rx = ipsec_rx(ipsec, family, type);\n\tint err;\n\n\tmutex_lock(&rx->ft.mutex);\n\terr = rx_get(mdev, ipsec, rx, family);\n\tmutex_unlock(&rx->ft.mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn rx;\n}\n\nstatic struct mlx5_flow_table *rx_ft_get_policy(struct mlx5_core_dev *mdev,\n\t\t\t\t\t\tstruct mlx5e_ipsec *ipsec,\n\t\t\t\t\t\tu32 family, u32 prio, int type)\n{\n\tstruct mlx5e_ipsec_rx *rx = ipsec_rx(ipsec, family, type);\n\tstruct mlx5_flow_table *ft;\n\tint err;\n\n\tmutex_lock(&rx->ft.mutex);\n\terr = rx_get(mdev, ipsec, rx, family);\n\tif (err)\n\t\tgoto err_get;\n\n\tft = rx->chains ? ipsec_chains_get_table(rx->chains, prio) : rx->ft.pol;\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_get_ft;\n\t}\n\n\tmutex_unlock(&rx->ft.mutex);\n\treturn ft;\n\nerr_get_ft:\n\trx_put(ipsec, rx, family);\nerr_get:\n\tmutex_unlock(&rx->ft.mutex);\n\treturn ERR_PTR(err);\n}\n\nstatic void rx_ft_put(struct mlx5e_ipsec *ipsec, u32 family, int type)\n{\n\tstruct mlx5e_ipsec_rx *rx = ipsec_rx(ipsec, family, type);\n\n\tmutex_lock(&rx->ft.mutex);\n\trx_put(ipsec, rx, family);\n\tmutex_unlock(&rx->ft.mutex);\n}\n\nstatic void rx_ft_put_policy(struct mlx5e_ipsec *ipsec, u32 family, u32 prio, int type)\n{\n\tstruct mlx5e_ipsec_rx *rx = ipsec_rx(ipsec, family, type);\n\n\tmutex_lock(&rx->ft.mutex);\n\tif (rx->chains)\n\t\tipsec_chains_put_table(rx->chains, prio);\n\n\trx_put(ipsec, rx, family);\n\tmutex_unlock(&rx->ft.mutex);\n}\n\nstatic int ipsec_counter_rule_tx(struct mlx5_core_dev *mdev, struct mlx5e_ipsec_tx *tx)\n{\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *fte;\n\tstruct mlx5_flow_spec *spec;\n\tint err;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\t \n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_ALLOW |\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest.counter_id = mlx5_fc_id(tx->fc->cnt);\n\tfte = mlx5_add_flow_rules(tx->ft.status, spec, &flow_act, &dest, 1);\n\tif (IS_ERR(fte)) {\n\t\terr = PTR_ERR(fte);\n\t\tmlx5_core_err(mdev, \"Fail to add ipsec tx counter rule err=%d\\n\", err);\n\t\tgoto err_rule;\n\t}\n\n\tkvfree(spec);\n\ttx->status.rule = fte;\n\treturn 0;\n\nerr_rule:\n\tkvfree(spec);\n\treturn err;\n}\n\n \nstatic void tx_destroy(struct mlx5e_ipsec *ipsec, struct mlx5e_ipsec_tx *tx,\n\t\t       struct mlx5_ipsec_fs *roce)\n{\n\tmlx5_ipsec_fs_roce_tx_destroy(roce);\n\tif (tx->chains) {\n\t\tipsec_chains_destroy(tx->chains);\n\t} else {\n\t\tmlx5_del_flow_rules(tx->pol.rule);\n\t\tmlx5_destroy_flow_group(tx->pol.group);\n\t\tmlx5_destroy_flow_table(tx->ft.pol);\n\t}\n\n\tif (tx == ipsec->tx_esw) {\n\t\tmlx5_del_flow_rules(tx->sa.rule);\n\t\tmlx5_destroy_flow_group(tx->sa.group);\n\t}\n\tmlx5_destroy_flow_table(tx->ft.sa);\n\tif (tx->allow_tunnel_mode)\n\t\tmlx5_eswitch_unblock_encap(ipsec->mdev);\n\tmlx5_del_flow_rules(tx->status.rule);\n\tmlx5_destroy_flow_table(tx->ft.status);\n}\n\nstatic void ipsec_tx_create_attr_set(struct mlx5e_ipsec *ipsec,\n\t\t\t\t     struct mlx5e_ipsec_tx *tx,\n\t\t\t\t     struct mlx5e_ipsec_tx_create_attr *attr)\n{\n\tif (tx == ipsec->tx_esw) {\n\t\tmlx5_esw_ipsec_tx_create_attr_set(ipsec, attr);\n\t\treturn;\n\t}\n\n\tattr->prio = 0;\n\tattr->pol_level = 0;\n\tattr->sa_level = 1;\n\tattr->cnt_level = 2;\n\tattr->chains_ns = MLX5_FLOW_NAMESPACE_EGRESS_IPSEC;\n}\n\nstatic int tx_create(struct mlx5e_ipsec *ipsec, struct mlx5e_ipsec_tx *tx,\n\t\t     struct mlx5_ipsec_fs *roce)\n{\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\tstruct mlx5e_ipsec_tx_create_attr attr;\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_table *ft;\n\tu32 flags = 0;\n\tint err;\n\n\tipsec_tx_create_attr_set(ipsec, tx, &attr);\n\tft = ipsec_ft_create(tx->ns, attr.cnt_level, attr.prio, 1, 0);\n\tif (IS_ERR(ft))\n\t\treturn PTR_ERR(ft);\n\ttx->ft.status = ft;\n\n\terr = ipsec_counter_rule_tx(mdev, tx);\n\tif (err)\n\t\tgoto err_status_rule;\n\n\tif (mlx5_ipsec_device_caps(mdev) & MLX5_IPSEC_CAP_TUNNEL)\n\t\ttx->allow_tunnel_mode = mlx5_eswitch_block_encap(mdev);\n\tif (tx->allow_tunnel_mode)\n\t\tflags = MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\tft = ipsec_ft_create(tx->ns, attr.sa_level, attr.prio, 4, flags);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_sa_ft;\n\t}\n\ttx->ft.sa = ft;\n\n\tif (tx == ipsec->tx_esw) {\n\t\tdest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\n\t\tdest.vport.num = MLX5_VPORT_UPLINK;\n\t\terr = ipsec_miss_create(mdev, tx->ft.sa, &tx->sa, &dest);\n\t\tif (err)\n\t\t\tgoto err_sa_miss;\n\t\tmemset(&dest, 0, sizeof(dest));\n\t}\n\n\tif (mlx5_ipsec_device_caps(mdev) & MLX5_IPSEC_CAP_PRIO) {\n\t\ttx->chains = ipsec_chains_create(\n\t\t\tmdev, tx->ft.sa, attr.chains_ns, attr.prio, attr.pol_level,\n\t\t\t&tx->ft.pol);\n\t\tif (IS_ERR(tx->chains)) {\n\t\t\terr = PTR_ERR(tx->chains);\n\t\t\tgoto err_pol_ft;\n\t\t}\n\n\t\tgoto connect_roce;\n\t}\n\n\tft = ipsec_ft_create(tx->ns, attr.pol_level, attr.prio, 2, 0);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_pol_ft;\n\t}\n\ttx->ft.pol = ft;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = tx->ft.sa;\n\terr = ipsec_miss_create(mdev, tx->ft.pol, &tx->pol, &dest);\n\tif (err) {\n\t\tmlx5_destroy_flow_table(tx->ft.pol);\n\t\tgoto err_pol_ft;\n\t}\n\nconnect_roce:\n\terr = mlx5_ipsec_fs_roce_tx_create(mdev, roce, tx->ft.pol);\n\tif (err)\n\t\tgoto err_roce;\n\treturn 0;\n\nerr_roce:\n\tif (tx->chains) {\n\t\tipsec_chains_destroy(tx->chains);\n\t} else {\n\t\tmlx5_del_flow_rules(tx->pol.rule);\n\t\tmlx5_destroy_flow_group(tx->pol.group);\n\t\tmlx5_destroy_flow_table(tx->ft.pol);\n\t}\nerr_pol_ft:\n\tif (tx == ipsec->tx_esw) {\n\t\tmlx5_del_flow_rules(tx->sa.rule);\n\t\tmlx5_destroy_flow_group(tx->sa.group);\n\t}\nerr_sa_miss:\n\tmlx5_destroy_flow_table(tx->ft.sa);\nerr_sa_ft:\n\tif (tx->allow_tunnel_mode)\n\t\tmlx5_eswitch_unblock_encap(mdev);\n\tmlx5_del_flow_rules(tx->status.rule);\nerr_status_rule:\n\tmlx5_destroy_flow_table(tx->ft.status);\n\treturn err;\n}\n\nstatic void ipsec_esw_tx_ft_policy_set(struct mlx5_core_dev *mdev,\n\t\t\t\t       struct mlx5_flow_table *ft)\n{\n#ifdef CONFIG_MLX5_ESWITCH\n\tstruct mlx5_eswitch *esw = mdev->priv.eswitch;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct mlx5e_priv *priv;\n\n\tesw->offloads.ft_ipsec_tx_pol = ft;\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tpriv = netdev_priv(uplink_rpriv->netdev);\n\tif (!priv->channels.num)\n\t\treturn;\n\n\tmlx5e_rep_deactivate_channels(priv);\n\tmlx5e_rep_activate_channels(priv);\n#endif\n}\n\nstatic int tx_get(struct mlx5_core_dev *mdev, struct mlx5e_ipsec *ipsec,\n\t\t  struct mlx5e_ipsec_tx *tx)\n{\n\tint err;\n\n\tif (tx->ft.refcnt)\n\t\tgoto skip;\n\n\terr = mlx5_eswitch_block_mode(mdev);\n\tif (err)\n\t\treturn err;\n\n\terr = tx_create(ipsec, tx, ipsec->roce);\n\tif (err) {\n\t\tmlx5_eswitch_unblock_mode(mdev);\n\t\treturn err;\n\t}\n\n\tif (tx == ipsec->tx_esw)\n\t\tipsec_esw_tx_ft_policy_set(mdev, tx->ft.pol);\n\nskip:\n\ttx->ft.refcnt++;\n\treturn 0;\n}\n\nstatic void tx_put(struct mlx5e_ipsec *ipsec, struct mlx5e_ipsec_tx *tx)\n{\n\tif (--tx->ft.refcnt)\n\t\treturn;\n\n\tif (tx == ipsec->tx_esw) {\n\t\tmlx5_esw_ipsec_restore_dest_uplink(ipsec->mdev);\n\t\tipsec_esw_tx_ft_policy_set(ipsec->mdev, NULL);\n\t}\n\n\ttx_destroy(ipsec, tx, ipsec->roce);\n\tmlx5_eswitch_unblock_mode(ipsec->mdev);\n}\n\nstatic struct mlx5_flow_table *tx_ft_get_policy(struct mlx5_core_dev *mdev,\n\t\t\t\t\t\tstruct mlx5e_ipsec *ipsec,\n\t\t\t\t\t\tu32 prio, int type)\n{\n\tstruct mlx5e_ipsec_tx *tx = ipsec_tx(ipsec, type);\n\tstruct mlx5_flow_table *ft;\n\tint err;\n\n\tmutex_lock(&tx->ft.mutex);\n\terr = tx_get(mdev, ipsec, tx);\n\tif (err)\n\t\tgoto err_get;\n\n\tft = tx->chains ? ipsec_chains_get_table(tx->chains, prio) : tx->ft.pol;\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_get_ft;\n\t}\n\n\tmutex_unlock(&tx->ft.mutex);\n\treturn ft;\n\nerr_get_ft:\n\ttx_put(ipsec, tx);\nerr_get:\n\tmutex_unlock(&tx->ft.mutex);\n\treturn ERR_PTR(err);\n}\n\nstatic struct mlx5e_ipsec_tx *tx_ft_get(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5e_ipsec *ipsec, int type)\n{\n\tstruct mlx5e_ipsec_tx *tx = ipsec_tx(ipsec, type);\n\tint err;\n\n\tmutex_lock(&tx->ft.mutex);\n\terr = tx_get(mdev, ipsec, tx);\n\tmutex_unlock(&tx->ft.mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn tx;\n}\n\nstatic void tx_ft_put(struct mlx5e_ipsec *ipsec, int type)\n{\n\tstruct mlx5e_ipsec_tx *tx = ipsec_tx(ipsec, type);\n\n\tmutex_lock(&tx->ft.mutex);\n\ttx_put(ipsec, tx);\n\tmutex_unlock(&tx->ft.mutex);\n}\n\nstatic void tx_ft_put_policy(struct mlx5e_ipsec *ipsec, u32 prio, int type)\n{\n\tstruct mlx5e_ipsec_tx *tx = ipsec_tx(ipsec, type);\n\n\tmutex_lock(&tx->ft.mutex);\n\tif (tx->chains)\n\t\tipsec_chains_put_table(tx->chains, prio);\n\n\ttx_put(ipsec, tx);\n\tmutex_unlock(&tx->ft.mutex);\n}\n\nstatic void setup_fte_addr4(struct mlx5_flow_spec *spec, __be32 *saddr,\n\t\t\t    __be32 *daddr)\n{\n\tif (!*saddr && !*daddr)\n\t\treturn;\n\n\tspec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version, 4);\n\n\tif (*saddr) {\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4), saddr, 4);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4);\n\t}\n\n\tif (*daddr) {\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4), daddr, 4);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\t}\n}\n\nstatic void setup_fte_addr6(struct mlx5_flow_spec *spec, __be32 *saddr,\n\t\t\t    __be32 *daddr)\n{\n\tif (addr6_all_zero(saddr) && addr6_all_zero(daddr))\n\t\treturn;\n\n\tspec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version, 6);\n\n\tif (!addr6_all_zero(saddr)) {\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6), saddr, 16);\n\t\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6), 0xff, 16);\n\t}\n\n\tif (!addr6_all_zero(daddr)) {\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6), daddr, 16);\n\t\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6), 0xff, 16);\n\t}\n}\n\nstatic void setup_fte_esp(struct mlx5_flow_spec *spec)\n{\n\t \n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, IPPROTO_ESP);\n}\n\nstatic void setup_fte_spi(struct mlx5_flow_spec *spec, u32 spi, bool encap)\n{\n\t \n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;\n\n\tif (encap) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t misc_parameters.inner_esp_spi);\n\t\tMLX5_SET(fte_match_param, spec->match_value,\n\t\t\t misc_parameters.inner_esp_spi, spi);\n\t} else {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t misc_parameters.outer_esp_spi);\n\t\tMLX5_SET(fte_match_param, spec->match_value,\n\t\t\t misc_parameters.outer_esp_spi, spi);\n\t}\n}\n\nstatic void setup_fte_no_frags(struct mlx5_flow_spec *spec)\n{\n\t \n\tspec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.frag);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.frag, 0);\n}\n\nstatic void setup_fte_reg_a(struct mlx5_flow_spec *spec)\n{\n\t \n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;\n\n\tMLX5_SET(fte_match_param, spec->match_criteria,\n\t\t misc_parameters_2.metadata_reg_a, MLX5_ETH_WQE_FT_META_IPSEC);\n\tMLX5_SET(fte_match_param, spec->match_value,\n\t\t misc_parameters_2.metadata_reg_a, MLX5_ETH_WQE_FT_META_IPSEC);\n}\n\nstatic void setup_fte_reg_c4(struct mlx5_flow_spec *spec, u32 reqid)\n{\n\t \n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t misc_parameters_2.metadata_reg_c_4);\n\tMLX5_SET(fte_match_param, spec->match_value,\n\t\t misc_parameters_2.metadata_reg_c_4, reqid);\n}\n\nstatic void setup_fte_upper_proto_match(struct mlx5_flow_spec *spec, struct upspec *upspec)\n{\n\tswitch (upspec->proto) {\n\tcase IPPROTO_UDP:\n\t\tif (upspec->dport) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_criteria,\n\t\t\t\t udp_dport, upspec->dport_mask);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_value,\n\t\t\t\t udp_dport, upspec->dport);\n\t\t}\n\t\tif (upspec->sport) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_criteria,\n\t\t\t\t udp_sport, upspec->sport_mask);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_value,\n\t\t\t\t udp_sport, upspec->sport);\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tif (upspec->dport) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_criteria,\n\t\t\t\t tcp_dport, upspec->dport_mask);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_value,\n\t\t\t\t tcp_dport, upspec->dport);\n\t\t}\n\t\tif (upspec->sport) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_criteria,\n\t\t\t\t tcp_sport, upspec->sport_mask);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_value,\n\t\t\t\t tcp_sport, upspec->sport);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tspec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, spec->match_criteria, ip_protocol);\n\tMLX5_SET(fte_match_set_lyr_2_4, spec->match_value, ip_protocol, upspec->proto);\n}\n\nstatic enum mlx5_flow_namespace_type ipsec_fs_get_ns(struct mlx5e_ipsec *ipsec,\n\t\t\t\t\t\t     int type, u8 dir)\n{\n\tif (ipsec->is_uplink_rep && type == XFRM_DEV_OFFLOAD_PACKET)\n\t\treturn MLX5_FLOW_NAMESPACE_FDB;\n\n\tif (dir == XFRM_DEV_OFFLOAD_IN)\n\t\treturn MLX5_FLOW_NAMESPACE_KERNEL;\n\n\treturn MLX5_FLOW_NAMESPACE_EGRESS;\n}\n\nstatic int setup_modify_header(struct mlx5e_ipsec *ipsec, int type, u32 val, u8 dir,\n\t\t\t       struct mlx5_flow_act *flow_act)\n{\n\tenum mlx5_flow_namespace_type ns_type = ipsec_fs_get_ns(ipsec, type, dir);\n\tu8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\tstruct mlx5_modify_hdr *modify_hdr;\n\n\tMLX5_SET(set_action_in, action, action_type, MLX5_ACTION_TYPE_SET);\n\tswitch (dir) {\n\tcase XFRM_DEV_OFFLOAD_IN:\n\t\tMLX5_SET(set_action_in, action, field,\n\t\t\t MLX5_ACTION_IN_FIELD_METADATA_REG_B);\n\t\tbreak;\n\tcase XFRM_DEV_OFFLOAD_OUT:\n\t\tMLX5_SET(set_action_in, action, field,\n\t\t\t MLX5_ACTION_IN_FIELD_METADATA_REG_C_4);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tMLX5_SET(set_action_in, action, data, val);\n\tMLX5_SET(set_action_in, action, offset, 0);\n\tMLX5_SET(set_action_in, action, length, 32);\n\n\tmodify_hdr = mlx5_modify_header_alloc(mdev, ns_type, 1, action);\n\tif (IS_ERR(modify_hdr)) {\n\t\tmlx5_core_err(mdev, \"Failed to allocate modify_header %ld\\n\",\n\t\t\t      PTR_ERR(modify_hdr));\n\t\treturn PTR_ERR(modify_hdr);\n\t}\n\n\tflow_act->modify_hdr = modify_hdr;\n\tflow_act->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\treturn 0;\n}\n\nstatic int\nsetup_pkt_tunnel_reformat(struct mlx5_core_dev *mdev,\n\t\t\t  struct mlx5_accel_esp_xfrm_attrs *attrs,\n\t\t\t  struct mlx5_pkt_reformat_params *reformat_params)\n{\n\tstruct ip_esp_hdr *esp_hdr;\n\tstruct ipv6hdr *ipv6hdr;\n\tstruct ethhdr *eth_hdr;\n\tstruct iphdr *iphdr;\n\tchar *reformatbf;\n\tsize_t bfflen;\n\tvoid *hdr;\n\n\tbfflen = sizeof(*eth_hdr);\n\n\tif (attrs->dir == XFRM_DEV_OFFLOAD_OUT) {\n\t\tbfflen += sizeof(*esp_hdr) + 8;\n\n\t\tswitch (attrs->family) {\n\t\tcase AF_INET:\n\t\t\tbfflen += sizeof(*iphdr);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tbfflen += sizeof(*ipv6hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treformatbf = kzalloc(bfflen, GFP_KERNEL);\n\tif (!reformatbf)\n\t\treturn -ENOMEM;\n\n\teth_hdr = (struct ethhdr *)reformatbf;\n\tswitch (attrs->family) {\n\tcase AF_INET:\n\t\teth_hdr->h_proto = htons(ETH_P_IP);\n\t\tbreak;\n\tcase AF_INET6:\n\t\teth_hdr->h_proto = htons(ETH_P_IPV6);\n\t\tbreak;\n\tdefault:\n\t\tgoto free_reformatbf;\n\t}\n\n\tether_addr_copy(eth_hdr->h_dest, attrs->dmac);\n\tether_addr_copy(eth_hdr->h_source, attrs->smac);\n\n\tswitch (attrs->dir) {\n\tcase XFRM_DEV_OFFLOAD_IN:\n\t\treformat_params->type = MLX5_REFORMAT_TYPE_L3_ESP_TUNNEL_TO_L2;\n\t\tbreak;\n\tcase XFRM_DEV_OFFLOAD_OUT:\n\t\treformat_params->type = MLX5_REFORMAT_TYPE_L2_TO_L3_ESP_TUNNEL;\n\t\treformat_params->param_0 = attrs->authsize;\n\n\t\thdr = reformatbf + sizeof(*eth_hdr);\n\t\tswitch (attrs->family) {\n\t\tcase AF_INET:\n\t\t\tiphdr = (struct iphdr *)hdr;\n\t\t\tmemcpy(&iphdr->saddr, &attrs->saddr.a4, 4);\n\t\t\tmemcpy(&iphdr->daddr, &attrs->daddr.a4, 4);\n\t\t\tiphdr->version = 4;\n\t\t\tiphdr->ihl = 5;\n\t\t\tiphdr->ttl = IPSEC_TUNNEL_DEFAULT_TTL;\n\t\t\tiphdr->protocol = IPPROTO_ESP;\n\t\t\thdr += sizeof(*iphdr);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tipv6hdr = (struct ipv6hdr *)hdr;\n\t\t\tmemcpy(&ipv6hdr->saddr, &attrs->saddr.a6, 16);\n\t\t\tmemcpy(&ipv6hdr->daddr, &attrs->daddr.a6, 16);\n\t\t\tipv6hdr->nexthdr = IPPROTO_ESP;\n\t\t\tipv6hdr->version = 6;\n\t\t\tipv6hdr->hop_limit = IPSEC_TUNNEL_DEFAULT_TTL;\n\t\t\thdr += sizeof(*ipv6hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto free_reformatbf;\n\t\t}\n\n\t\tesp_hdr = (struct ip_esp_hdr *)hdr;\n\t\tesp_hdr->spi = htonl(attrs->spi);\n\t\tbreak;\n\tdefault:\n\t\tgoto free_reformatbf;\n\t}\n\n\treformat_params->size = bfflen;\n\treformat_params->data = reformatbf;\n\treturn 0;\n\nfree_reformatbf:\n\tkfree(reformatbf);\n\treturn -EINVAL;\n}\n\nstatic int get_reformat_type(struct mlx5_accel_esp_xfrm_attrs *attrs)\n{\n\tswitch (attrs->dir) {\n\tcase XFRM_DEV_OFFLOAD_IN:\n\t\tif (attrs->encap)\n\t\t\treturn MLX5_REFORMAT_TYPE_DEL_ESP_TRANSPORT_OVER_UDP;\n\t\treturn MLX5_REFORMAT_TYPE_DEL_ESP_TRANSPORT;\n\tcase XFRM_DEV_OFFLOAD_OUT:\n\t\tif (attrs->family == AF_INET) {\n\t\t\tif (attrs->encap)\n\t\t\t\treturn MLX5_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_UDPV4;\n\t\t\treturn MLX5_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_IPV4;\n\t\t}\n\n\t\tif (attrs->encap)\n\t\t\treturn MLX5_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_UDPV6;\n\t\treturn MLX5_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_IPV6;\n\tdefault:\n\t\tWARN_ON(true);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nsetup_pkt_transport_reformat(struct mlx5_accel_esp_xfrm_attrs *attrs,\n\t\t\t     struct mlx5_pkt_reformat_params *reformat_params)\n{\n\tstruct udphdr *udphdr;\n\tchar *reformatbf;\n\tsize_t bfflen;\n\t__be32 spi;\n\tvoid *hdr;\n\n\treformat_params->type = get_reformat_type(attrs);\n\tif (reformat_params->type < 0)\n\t\treturn reformat_params->type;\n\n\tswitch (attrs->dir) {\n\tcase XFRM_DEV_OFFLOAD_IN:\n\t\tbreak;\n\tcase XFRM_DEV_OFFLOAD_OUT:\n\t\tbfflen = MLX5_REFORMAT_TYPE_ADD_ESP_TRANSPORT_SIZE;\n\t\tif (attrs->encap)\n\t\t\tbfflen += sizeof(*udphdr);\n\n\t\treformatbf = kzalloc(bfflen, GFP_KERNEL);\n\t\tif (!reformatbf)\n\t\t\treturn -ENOMEM;\n\n\t\thdr = reformatbf;\n\t\tif (attrs->encap) {\n\t\t\tudphdr = (struct udphdr *)reformatbf;\n\t\t\tudphdr->source = attrs->sport;\n\t\t\tudphdr->dest = attrs->dport;\n\t\t\thdr += sizeof(*udphdr);\n\t\t}\n\n\t\t \n\t\tspi = htonl(attrs->spi);\n\t\tmemcpy(hdr, &spi, sizeof(spi));\n\n\t\treformat_params->param_0 = attrs->authsize;\n\t\treformat_params->size = bfflen;\n\t\treformat_params->data = reformatbf;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_pkt_reformat(struct mlx5e_ipsec *ipsec,\n\t\t\t      struct mlx5_accel_esp_xfrm_attrs *attrs,\n\t\t\t      struct mlx5_flow_act *flow_act)\n{\n\tenum mlx5_flow_namespace_type ns_type = ipsec_fs_get_ns(ipsec, attrs->type,\n\t\t\t\t\t\t\t\tattrs->dir);\n\tstruct mlx5_pkt_reformat_params reformat_params = {};\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\tstruct mlx5_pkt_reformat *pkt_reformat;\n\tint ret;\n\n\tswitch (attrs->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\tret = setup_pkt_transport_reformat(attrs, &reformat_params);\n\t\tbreak;\n\tcase XFRM_MODE_TUNNEL:\n\t\tret = setup_pkt_tunnel_reformat(mdev, attrs, &reformat_params);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tpkt_reformat =\n\t\tmlx5_packet_reformat_alloc(mdev, &reformat_params, ns_type);\n\tkfree(reformat_params.data);\n\tif (IS_ERR(pkt_reformat))\n\t\treturn PTR_ERR(pkt_reformat);\n\n\tflow_act->pkt_reformat = pkt_reformat;\n\tflow_act->action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\treturn 0;\n}\n\nstatic int rx_add_rule(struct mlx5e_ipsec_sa_entry *sa_entry)\n{\n\tstruct mlx5_accel_esp_xfrm_attrs *attrs = &sa_entry->attrs;\n\tstruct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);\n\tstruct mlx5e_ipsec *ipsec = sa_entry->ipsec;\n\tstruct mlx5_flow_destination dest[2];\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5e_ipsec_rx *rx;\n\tstruct mlx5_fc *counter;\n\tint err = 0;\n\n\trx = rx_ft_get(mdev, ipsec, attrs->family, attrs->type);\n\tif (IS_ERR(rx))\n\t\treturn PTR_ERR(rx);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tif (attrs->family == AF_INET)\n\t\tsetup_fte_addr4(spec, &attrs->saddr.a4, &attrs->daddr.a4);\n\telse\n\t\tsetup_fte_addr6(spec, attrs->saddr.a6, attrs->daddr.a6);\n\n\tsetup_fte_spi(spec, attrs->spi, attrs->encap);\n\tif (!attrs->encap)\n\t\tsetup_fte_esp(spec);\n\tsetup_fte_no_frags(spec);\n\tsetup_fte_upper_proto_match(spec, &attrs->upspec);\n\n\tif (rx != ipsec->rx_esw)\n\t\terr = setup_modify_header(ipsec, attrs->type,\n\t\t\t\t\t  sa_entry->ipsec_obj_id | BIT(31),\n\t\t\t\t\t  XFRM_DEV_OFFLOAD_IN, &flow_act);\n\telse\n\t\terr = mlx5_esw_ipsec_rx_setup_modify_header(sa_entry, &flow_act);\n\n\tif (err)\n\t\tgoto err_mod_header;\n\n\tswitch (attrs->type) {\n\tcase XFRM_DEV_OFFLOAD_PACKET:\n\t\terr = setup_pkt_reformat(ipsec, attrs, &flow_act);\n\t\tif (err)\n\t\t\tgoto err_pkt_reformat;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcounter = mlx5_fc_create(mdev, true);\n\tif (IS_ERR(counter)) {\n\t\terr = PTR_ERR(counter);\n\t\tgoto err_add_cnt;\n\t}\n\tflow_act.crypto.type = MLX5_FLOW_CONTEXT_ENCRYPT_DECRYPT_TYPE_IPSEC;\n\tflow_act.crypto.obj_id = sa_entry->ipsec_obj_id;\n\tflow_act.flags |= FLOW_ACT_NO_APPEND;\n\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_CRYPTO_DECRYPT |\n\t\t\t   MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\tif (attrs->drop)\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_DROP;\n\telse\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tdest[0].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest[0].ft = rx->ft.status;\n\tdest[1].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest[1].counter_id = mlx5_fc_id(counter);\n\trule = mlx5_add_flow_rules(rx->ft.sa, spec, &flow_act, dest, 2);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"fail to add RX ipsec rule err=%d\\n\", err);\n\t\tgoto err_add_flow;\n\t}\n\tkvfree(spec);\n\n\tsa_entry->ipsec_rule.rule = rule;\n\tsa_entry->ipsec_rule.modify_hdr = flow_act.modify_hdr;\n\tsa_entry->ipsec_rule.fc = counter;\n\tsa_entry->ipsec_rule.pkt_reformat = flow_act.pkt_reformat;\n\treturn 0;\n\nerr_add_flow:\n\tmlx5_fc_destroy(mdev, counter);\nerr_add_cnt:\n\tif (flow_act.pkt_reformat)\n\t\tmlx5_packet_reformat_dealloc(mdev, flow_act.pkt_reformat);\nerr_pkt_reformat:\n\tmlx5_modify_header_dealloc(mdev, flow_act.modify_hdr);\nerr_mod_header:\n\tkvfree(spec);\nerr_alloc:\n\trx_ft_put(ipsec, attrs->family, attrs->type);\n\treturn err;\n}\n\nstatic int tx_add_rule(struct mlx5e_ipsec_sa_entry *sa_entry)\n{\n\tstruct mlx5_accel_esp_xfrm_attrs *attrs = &sa_entry->attrs;\n\tstruct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);\n\tstruct mlx5e_ipsec *ipsec = sa_entry->ipsec;\n\tstruct mlx5_flow_destination dest[2];\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5e_ipsec_tx *tx;\n\tstruct mlx5_fc *counter;\n\tint err;\n\n\ttx = tx_ft_get(mdev, ipsec, attrs->type);\n\tif (IS_ERR(tx))\n\t\treturn PTR_ERR(tx);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tif (attrs->family == AF_INET)\n\t\tsetup_fte_addr4(spec, &attrs->saddr.a4, &attrs->daddr.a4);\n\telse\n\t\tsetup_fte_addr6(spec, attrs->saddr.a6, attrs->daddr.a6);\n\n\tsetup_fte_no_frags(spec);\n\tsetup_fte_upper_proto_match(spec, &attrs->upspec);\n\n\tswitch (attrs->type) {\n\tcase XFRM_DEV_OFFLOAD_CRYPTO:\n\t\tsetup_fte_spi(spec, attrs->spi, false);\n\t\tsetup_fte_esp(spec);\n\t\tsetup_fte_reg_a(spec);\n\t\tbreak;\n\tcase XFRM_DEV_OFFLOAD_PACKET:\n\t\tif (attrs->reqid)\n\t\t\tsetup_fte_reg_c4(spec, attrs->reqid);\n\t\terr = setup_pkt_reformat(ipsec, attrs, &flow_act);\n\t\tif (err)\n\t\t\tgoto err_pkt_reformat;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcounter = mlx5_fc_create(mdev, true);\n\tif (IS_ERR(counter)) {\n\t\terr = PTR_ERR(counter);\n\t\tgoto err_add_cnt;\n\t}\n\n\tflow_act.crypto.type = MLX5_FLOW_CONTEXT_ENCRYPT_DECRYPT_TYPE_IPSEC;\n\tflow_act.crypto.obj_id = sa_entry->ipsec_obj_id;\n\tflow_act.flags |= FLOW_ACT_NO_APPEND;\n\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_CRYPTO_ENCRYPT |\n\t\t\t   MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\tif (attrs->drop)\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_DROP;\n\telse\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\n\tdest[0].ft = tx->ft.status;\n\tdest[0].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest[1].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest[1].counter_id = mlx5_fc_id(counter);\n\trule = mlx5_add_flow_rules(tx->ft.sa, spec, &flow_act, dest, 2);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"fail to add TX ipsec rule err=%d\\n\", err);\n\t\tgoto err_add_flow;\n\t}\n\n\tkvfree(spec);\n\tsa_entry->ipsec_rule.rule = rule;\n\tsa_entry->ipsec_rule.fc = counter;\n\tsa_entry->ipsec_rule.pkt_reformat = flow_act.pkt_reformat;\n\treturn 0;\n\nerr_add_flow:\n\tmlx5_fc_destroy(mdev, counter);\nerr_add_cnt:\n\tif (flow_act.pkt_reformat)\n\t\tmlx5_packet_reformat_dealloc(mdev, flow_act.pkt_reformat);\nerr_pkt_reformat:\n\tkvfree(spec);\nerr_alloc:\n\ttx_ft_put(ipsec, attrs->type);\n\treturn err;\n}\n\nstatic int tx_add_policy(struct mlx5e_ipsec_pol_entry *pol_entry)\n{\n\tstruct mlx5_accel_pol_xfrm_attrs *attrs = &pol_entry->attrs;\n\tstruct mlx5_core_dev *mdev = mlx5e_ipsec_pol2dev(pol_entry);\n\tstruct mlx5e_ipsec *ipsec = pol_entry->ipsec;\n\tstruct mlx5_flow_destination dest[2] = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5e_ipsec_tx *tx;\n\tint err, dstn = 0;\n\n\tft = tx_ft_get_policy(mdev, ipsec, attrs->prio, attrs->type);\n\tif (IS_ERR(ft))\n\t\treturn PTR_ERR(ft);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\ttx = ipsec_tx(ipsec, attrs->type);\n\tif (attrs->family == AF_INET)\n\t\tsetup_fte_addr4(spec, &attrs->saddr.a4, &attrs->daddr.a4);\n\telse\n\t\tsetup_fte_addr6(spec, attrs->saddr.a6, attrs->daddr.a6);\n\n\tsetup_fte_no_frags(spec);\n\tsetup_fte_upper_proto_match(spec, &attrs->upspec);\n\n\tswitch (attrs->action) {\n\tcase XFRM_POLICY_ALLOW:\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t\tif (!attrs->reqid)\n\t\t\tbreak;\n\n\t\terr = setup_modify_header(ipsec, attrs->type, attrs->reqid,\n\t\t\t\t\t  XFRM_DEV_OFFLOAD_OUT, &flow_act);\n\t\tif (err)\n\t\t\tgoto err_mod_header;\n\t\tbreak;\n\tcase XFRM_POLICY_BLOCK:\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_DROP |\n\t\t\t\t   MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\tdest[dstn].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\t\tdest[dstn].counter_id = mlx5_fc_id(tx->fc->drop);\n\t\tdstn++;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t\terr = -EINVAL;\n\t\tgoto err_mod_header;\n\t}\n\n\tflow_act.flags |= FLOW_ACT_NO_APPEND;\n\tif (tx == ipsec->tx_esw && tx->chains)\n\t\tflow_act.flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;\n\tdest[dstn].ft = tx->ft.sa;\n\tdest[dstn].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdstn++;\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, dstn);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"fail to add TX ipsec rule err=%d\\n\", err);\n\t\tgoto err_action;\n\t}\n\n\tkvfree(spec);\n\tpol_entry->ipsec_rule.rule = rule;\n\tpol_entry->ipsec_rule.modify_hdr = flow_act.modify_hdr;\n\treturn 0;\n\nerr_action:\n\tif (flow_act.modify_hdr)\n\t\tmlx5_modify_header_dealloc(mdev, flow_act.modify_hdr);\nerr_mod_header:\n\tkvfree(spec);\nerr_alloc:\n\ttx_ft_put_policy(ipsec, attrs->prio, attrs->type);\n\treturn err;\n}\n\nstatic int rx_add_policy(struct mlx5e_ipsec_pol_entry *pol_entry)\n{\n\tstruct mlx5_accel_pol_xfrm_attrs *attrs = &pol_entry->attrs;\n\tstruct mlx5_core_dev *mdev = mlx5e_ipsec_pol2dev(pol_entry);\n\tstruct mlx5e_ipsec *ipsec = pol_entry->ipsec;\n\tstruct mlx5_flow_destination dest[2];\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5e_ipsec_rx *rx;\n\tint err, dstn = 0;\n\n\tft = rx_ft_get_policy(mdev, pol_entry->ipsec, attrs->family, attrs->prio,\n\t\t\t      attrs->type);\n\tif (IS_ERR(ft))\n\t\treturn PTR_ERR(ft);\n\n\trx = ipsec_rx(pol_entry->ipsec, attrs->family, attrs->type);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tif (attrs->family == AF_INET)\n\t\tsetup_fte_addr4(spec, &attrs->saddr.a4, &attrs->daddr.a4);\n\telse\n\t\tsetup_fte_addr6(spec, attrs->saddr.a6, attrs->daddr.a6);\n\n\tsetup_fte_no_frags(spec);\n\tsetup_fte_upper_proto_match(spec, &attrs->upspec);\n\n\tswitch (attrs->action) {\n\tcase XFRM_POLICY_ALLOW:\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t\tbreak;\n\tcase XFRM_POLICY_BLOCK:\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_DROP | MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\tdest[dstn].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\t\tdest[dstn].counter_id = mlx5_fc_id(rx->fc->drop);\n\t\tdstn++;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t\terr = -EINVAL;\n\t\tgoto err_action;\n\t}\n\n\tflow_act.flags |= FLOW_ACT_NO_APPEND;\n\tif (rx == ipsec->rx_esw && rx->chains)\n\t\tflow_act.flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;\n\tdest[dstn].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest[dstn].ft = rx->ft.sa;\n\tdstn++;\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, dstn);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Fail to add RX IPsec policy rule err=%d\\n\", err);\n\t\tgoto err_action;\n\t}\n\n\tkvfree(spec);\n\tpol_entry->ipsec_rule.rule = rule;\n\treturn 0;\n\nerr_action:\n\tkvfree(spec);\nerr_alloc:\n\trx_ft_put_policy(pol_entry->ipsec, attrs->family, attrs->prio, attrs->type);\n\treturn err;\n}\n\nstatic void ipsec_fs_destroy_single_counter(struct mlx5_core_dev *mdev,\n\t\t\t\t\t    struct mlx5e_ipsec_fc *fc)\n{\n\tmlx5_fc_destroy(mdev, fc->drop);\n\tmlx5_fc_destroy(mdev, fc->cnt);\n\tkfree(fc);\n}\n\nstatic void ipsec_fs_destroy_counters(struct mlx5e_ipsec *ipsec)\n{\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\n\tipsec_fs_destroy_single_counter(mdev, ipsec->tx->fc);\n\tipsec_fs_destroy_single_counter(mdev, ipsec->rx_ipv4->fc);\n\tif (ipsec->is_uplink_rep) {\n\t\tipsec_fs_destroy_single_counter(mdev, ipsec->tx_esw->fc);\n\t\tipsec_fs_destroy_single_counter(mdev, ipsec->rx_esw->fc);\n\t}\n}\n\nstatic struct mlx5e_ipsec_fc *ipsec_fs_init_single_counter(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5e_ipsec_fc *fc;\n\tstruct mlx5_fc *counter;\n\tint err;\n\n\tfc = kzalloc(sizeof(*fc), GFP_KERNEL);\n\tif (!fc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcounter = mlx5_fc_create(mdev, false);\n\tif (IS_ERR(counter)) {\n\t\terr = PTR_ERR(counter);\n\t\tgoto err_cnt;\n\t}\n\tfc->cnt = counter;\n\n\tcounter = mlx5_fc_create(mdev, false);\n\tif (IS_ERR(counter)) {\n\t\terr = PTR_ERR(counter);\n\t\tgoto err_drop;\n\t}\n\tfc->drop = counter;\n\n\treturn fc;\n\nerr_drop:\n\tmlx5_fc_destroy(mdev, fc->cnt);\nerr_cnt:\n\tkfree(fc);\n\treturn ERR_PTR(err);\n}\n\nstatic int ipsec_fs_init_counters(struct mlx5e_ipsec *ipsec)\n{\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\tstruct mlx5e_ipsec_fc *fc;\n\tint err;\n\n\tfc = ipsec_fs_init_single_counter(mdev);\n\tif (IS_ERR(fc)) {\n\t\terr = PTR_ERR(fc);\n\t\tgoto err_rx_cnt;\n\t}\n\tipsec->rx_ipv4->fc = fc;\n\n\tfc = ipsec_fs_init_single_counter(mdev);\n\tif (IS_ERR(fc)) {\n\t\terr = PTR_ERR(fc);\n\t\tgoto err_tx_cnt;\n\t}\n\tipsec->tx->fc = fc;\n\n\tif (ipsec->is_uplink_rep) {\n\t\tfc = ipsec_fs_init_single_counter(mdev);\n\t\tif (IS_ERR(fc)) {\n\t\t\terr = PTR_ERR(fc);\n\t\t\tgoto err_rx_esw_cnt;\n\t\t}\n\t\tipsec->rx_esw->fc = fc;\n\n\t\tfc = ipsec_fs_init_single_counter(mdev);\n\t\tif (IS_ERR(fc)) {\n\t\t\terr = PTR_ERR(fc);\n\t\t\tgoto err_tx_esw_cnt;\n\t\t}\n\t\tipsec->tx_esw->fc = fc;\n\t}\n\n\t \n\tipsec->rx_ipv6->fc = ipsec->rx_ipv4->fc;\n\treturn 0;\n\nerr_tx_esw_cnt:\n\tipsec_fs_destroy_single_counter(mdev, ipsec->rx_esw->fc);\nerr_rx_esw_cnt:\n\tipsec_fs_destroy_single_counter(mdev, ipsec->tx->fc);\nerr_tx_cnt:\n\tipsec_fs_destroy_single_counter(mdev, ipsec->rx_ipv4->fc);\nerr_rx_cnt:\n\treturn err;\n}\n\nvoid mlx5e_accel_ipsec_fs_read_stats(struct mlx5e_priv *priv, void *ipsec_stats)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_ipsec *ipsec = priv->ipsec;\n\tstruct mlx5e_ipsec_hw_stats *stats;\n\tstruct mlx5e_ipsec_fc *fc;\n\tu64 packets, bytes;\n\n\tstats = (struct mlx5e_ipsec_hw_stats *)ipsec_stats;\n\n\tstats->ipsec_rx_pkts = 0;\n\tstats->ipsec_rx_bytes = 0;\n\tstats->ipsec_rx_drop_pkts = 0;\n\tstats->ipsec_rx_drop_bytes = 0;\n\tstats->ipsec_tx_pkts = 0;\n\tstats->ipsec_tx_bytes = 0;\n\tstats->ipsec_tx_drop_pkts = 0;\n\tstats->ipsec_tx_drop_bytes = 0;\n\n\tfc = ipsec->rx_ipv4->fc;\n\tmlx5_fc_query(mdev, fc->cnt, &stats->ipsec_rx_pkts, &stats->ipsec_rx_bytes);\n\tmlx5_fc_query(mdev, fc->drop, &stats->ipsec_rx_drop_pkts,\n\t\t      &stats->ipsec_rx_drop_bytes);\n\n\tfc = ipsec->tx->fc;\n\tmlx5_fc_query(mdev, fc->cnt, &stats->ipsec_tx_pkts, &stats->ipsec_tx_bytes);\n\tmlx5_fc_query(mdev, fc->drop, &stats->ipsec_tx_drop_pkts,\n\t\t      &stats->ipsec_tx_drop_bytes);\n\n\tif (ipsec->is_uplink_rep) {\n\t\tfc = ipsec->rx_esw->fc;\n\t\tif (!mlx5_fc_query(mdev, fc->cnt, &packets, &bytes)) {\n\t\t\tstats->ipsec_rx_pkts += packets;\n\t\t\tstats->ipsec_rx_bytes += bytes;\n\t\t}\n\n\t\tif (!mlx5_fc_query(mdev, fc->drop, &packets, &bytes)) {\n\t\t\tstats->ipsec_rx_drop_pkts += packets;\n\t\t\tstats->ipsec_rx_drop_bytes += bytes;\n\t\t}\n\n\t\tfc = ipsec->tx_esw->fc;\n\t\tif (!mlx5_fc_query(mdev, fc->cnt, &packets, &bytes)) {\n\t\t\tstats->ipsec_tx_pkts += packets;\n\t\t\tstats->ipsec_tx_bytes += bytes;\n\t\t}\n\n\t\tif (!mlx5_fc_query(mdev, fc->drop, &packets, &bytes)) {\n\t\t\tstats->ipsec_tx_drop_pkts += packets;\n\t\t\tstats->ipsec_tx_drop_bytes += bytes;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_MLX5_ESWITCH\nstatic int mlx5e_ipsec_block_tc_offload(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_eswitch *esw = mdev->priv.eswitch;\n\tint err = 0;\n\n\tif (esw) {\n\t\terr = mlx5_esw_lock(esw);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (mdev->num_block_ipsec) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tmdev->num_block_tc++;\n\nunlock:\n\tif (esw)\n\t\tmlx5_esw_unlock(esw);\n\n\treturn err;\n}\n#else\nstatic int mlx5e_ipsec_block_tc_offload(struct mlx5_core_dev *mdev)\n{\n\tif (mdev->num_block_ipsec)\n\t\treturn -EBUSY;\n\n\tmdev->num_block_tc++;\n\treturn 0;\n}\n#endif\n\nstatic void mlx5e_ipsec_unblock_tc_offload(struct mlx5_core_dev *mdev)\n{\n\tmdev->num_block_tc--;\n}\n\nint mlx5e_accel_ipsec_fs_add_rule(struct mlx5e_ipsec_sa_entry *sa_entry)\n{\n\tint err;\n\n\tif (sa_entry->attrs.type == XFRM_DEV_OFFLOAD_PACKET) {\n\t\terr = mlx5e_ipsec_block_tc_offload(sa_entry->ipsec->mdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (sa_entry->attrs.dir == XFRM_DEV_OFFLOAD_OUT)\n\t\terr = tx_add_rule(sa_entry);\n\telse\n\t\terr = rx_add_rule(sa_entry);\n\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\tif (sa_entry->attrs.type == XFRM_DEV_OFFLOAD_PACKET)\n\t\tmlx5e_ipsec_unblock_tc_offload(sa_entry->ipsec->mdev);\n\treturn err;\n}\n\nvoid mlx5e_accel_ipsec_fs_del_rule(struct mlx5e_ipsec_sa_entry *sa_entry)\n{\n\tstruct mlx5e_ipsec_rule *ipsec_rule = &sa_entry->ipsec_rule;\n\tstruct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);\n\n\tmlx5_del_flow_rules(ipsec_rule->rule);\n\tmlx5_fc_destroy(mdev, ipsec_rule->fc);\n\tif (ipsec_rule->pkt_reformat)\n\t\tmlx5_packet_reformat_dealloc(mdev, ipsec_rule->pkt_reformat);\n\n\tif (sa_entry->attrs.type == XFRM_DEV_OFFLOAD_PACKET)\n\t\tmlx5e_ipsec_unblock_tc_offload(mdev);\n\n\tif (sa_entry->attrs.dir == XFRM_DEV_OFFLOAD_OUT) {\n\t\ttx_ft_put(sa_entry->ipsec, sa_entry->attrs.type);\n\t\treturn;\n\t}\n\n\tmlx5_modify_header_dealloc(mdev, ipsec_rule->modify_hdr);\n\tmlx5_esw_ipsec_rx_id_mapping_remove(sa_entry);\n\trx_ft_put(sa_entry->ipsec, sa_entry->attrs.family, sa_entry->attrs.type);\n}\n\nint mlx5e_accel_ipsec_fs_add_pol(struct mlx5e_ipsec_pol_entry *pol_entry)\n{\n\tint err;\n\n\terr = mlx5e_ipsec_block_tc_offload(pol_entry->ipsec->mdev);\n\tif (err)\n\t\treturn err;\n\n\tif (pol_entry->attrs.dir == XFRM_DEV_OFFLOAD_OUT)\n\t\terr = tx_add_policy(pol_entry);\n\telse\n\t\terr = rx_add_policy(pol_entry);\n\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\tmlx5e_ipsec_unblock_tc_offload(pol_entry->ipsec->mdev);\n\treturn err;\n}\n\nvoid mlx5e_accel_ipsec_fs_del_pol(struct mlx5e_ipsec_pol_entry *pol_entry)\n{\n\tstruct mlx5e_ipsec_rule *ipsec_rule = &pol_entry->ipsec_rule;\n\tstruct mlx5_core_dev *mdev = mlx5e_ipsec_pol2dev(pol_entry);\n\n\tmlx5_del_flow_rules(ipsec_rule->rule);\n\n\tmlx5e_ipsec_unblock_tc_offload(pol_entry->ipsec->mdev);\n\n\tif (pol_entry->attrs.dir == XFRM_DEV_OFFLOAD_IN) {\n\t\trx_ft_put_policy(pol_entry->ipsec, pol_entry->attrs.family,\n\t\t\t\t pol_entry->attrs.prio, pol_entry->attrs.type);\n\t\treturn;\n\t}\n\n\tif (ipsec_rule->modify_hdr)\n\t\tmlx5_modify_header_dealloc(mdev, ipsec_rule->modify_hdr);\n\n\ttx_ft_put_policy(pol_entry->ipsec, pol_entry->attrs.prio, pol_entry->attrs.type);\n}\n\nvoid mlx5e_accel_ipsec_fs_cleanup(struct mlx5e_ipsec *ipsec)\n{\n\tif (!ipsec->tx)\n\t\treturn;\n\n\tif (ipsec->roce)\n\t\tmlx5_ipsec_fs_roce_cleanup(ipsec->roce);\n\n\tipsec_fs_destroy_counters(ipsec);\n\tmutex_destroy(&ipsec->tx->ft.mutex);\n\tWARN_ON(ipsec->tx->ft.refcnt);\n\tkfree(ipsec->tx);\n\n\tmutex_destroy(&ipsec->rx_ipv4->ft.mutex);\n\tWARN_ON(ipsec->rx_ipv4->ft.refcnt);\n\tkfree(ipsec->rx_ipv4);\n\n\tmutex_destroy(&ipsec->rx_ipv6->ft.mutex);\n\tWARN_ON(ipsec->rx_ipv6->ft.refcnt);\n\tkfree(ipsec->rx_ipv6);\n\n\tif (ipsec->is_uplink_rep) {\n\t\txa_destroy(&ipsec->rx_esw->ipsec_obj_id_map);\n\n\t\tmutex_destroy(&ipsec->tx_esw->ft.mutex);\n\t\tWARN_ON(ipsec->tx_esw->ft.refcnt);\n\t\tkfree(ipsec->tx_esw);\n\n\t\tmutex_destroy(&ipsec->rx_esw->ft.mutex);\n\t\tWARN_ON(ipsec->rx_esw->ft.refcnt);\n\t\tkfree(ipsec->rx_esw);\n\t}\n}\n\nint mlx5e_accel_ipsec_fs_init(struct mlx5e_ipsec *ipsec)\n{\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\tstruct mlx5_flow_namespace *ns, *ns_esw;\n\tint err = -ENOMEM;\n\n\tns = mlx5_get_flow_namespace(ipsec->mdev,\n\t\t\t\t     MLX5_FLOW_NAMESPACE_EGRESS_IPSEC);\n\tif (!ns)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ipsec->is_uplink_rep) {\n\t\tns_esw = mlx5_get_flow_namespace(mdev, MLX5_FLOW_NAMESPACE_FDB);\n\t\tif (!ns_esw)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tipsec->tx_esw = kzalloc(sizeof(*ipsec->tx_esw), GFP_KERNEL);\n\t\tif (!ipsec->tx_esw)\n\t\t\treturn -ENOMEM;\n\n\t\tipsec->rx_esw = kzalloc(sizeof(*ipsec->rx_esw), GFP_KERNEL);\n\t\tif (!ipsec->rx_esw)\n\t\t\tgoto err_rx_esw;\n\t}\n\n\tipsec->tx = kzalloc(sizeof(*ipsec->tx), GFP_KERNEL);\n\tif (!ipsec->tx)\n\t\tgoto err_tx;\n\n\tipsec->rx_ipv4 = kzalloc(sizeof(*ipsec->rx_ipv4), GFP_KERNEL);\n\tif (!ipsec->rx_ipv4)\n\t\tgoto err_rx_ipv4;\n\n\tipsec->rx_ipv6 = kzalloc(sizeof(*ipsec->rx_ipv6), GFP_KERNEL);\n\tif (!ipsec->rx_ipv6)\n\t\tgoto err_rx_ipv6;\n\n\terr = ipsec_fs_init_counters(ipsec);\n\tif (err)\n\t\tgoto err_counters;\n\n\tmutex_init(&ipsec->tx->ft.mutex);\n\tmutex_init(&ipsec->rx_ipv4->ft.mutex);\n\tmutex_init(&ipsec->rx_ipv6->ft.mutex);\n\tipsec->tx->ns = ns;\n\n\tif (ipsec->is_uplink_rep) {\n\t\tmutex_init(&ipsec->tx_esw->ft.mutex);\n\t\tmutex_init(&ipsec->rx_esw->ft.mutex);\n\t\tipsec->tx_esw->ns = ns_esw;\n\t\txa_init_flags(&ipsec->rx_esw->ipsec_obj_id_map, XA_FLAGS_ALLOC1);\n\t} else if (mlx5_ipsec_device_caps(mdev) & MLX5_IPSEC_CAP_ROCE) {\n\t\tipsec->roce = mlx5_ipsec_fs_roce_init(mdev);\n\t}\n\n\treturn 0;\n\nerr_counters:\n\tkfree(ipsec->rx_ipv6);\nerr_rx_ipv6:\n\tkfree(ipsec->rx_ipv4);\nerr_rx_ipv4:\n\tkfree(ipsec->tx);\nerr_tx:\n\tkfree(ipsec->rx_esw);\nerr_rx_esw:\n\tkfree(ipsec->tx_esw);\n\treturn err;\n}\n\nvoid mlx5e_accel_ipsec_fs_modify(struct mlx5e_ipsec_sa_entry *sa_entry)\n{\n\tstruct mlx5e_ipsec_sa_entry sa_entry_shadow = {};\n\tint err;\n\n\tmemcpy(&sa_entry_shadow, sa_entry, sizeof(*sa_entry));\n\tmemset(&sa_entry_shadow.ipsec_rule, 0x00, sizeof(sa_entry->ipsec_rule));\n\n\terr = mlx5e_accel_ipsec_fs_add_rule(&sa_entry_shadow);\n\tif (err)\n\t\treturn;\n\n\tmlx5e_accel_ipsec_fs_del_rule(sa_entry);\n\tmemcpy(sa_entry, &sa_entry_shadow, sizeof(*sa_entry));\n}\n\nbool mlx5e_ipsec_fs_tunnel_enabled(struct mlx5e_ipsec_sa_entry *sa_entry)\n{\n\tstruct mlx5_accel_esp_xfrm_attrs *attrs = &sa_entry->attrs;\n\tstruct mlx5e_ipsec_rx *rx;\n\tstruct mlx5e_ipsec_tx *tx;\n\n\trx = ipsec_rx(sa_entry->ipsec, attrs->family, attrs->type);\n\ttx = ipsec_tx(sa_entry->ipsec, attrs->type);\n\tif (sa_entry->attrs.dir == XFRM_DEV_OFFLOAD_OUT)\n\t\treturn tx->allow_tunnel_mode;\n\n\treturn rx->allow_tunnel_mode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}