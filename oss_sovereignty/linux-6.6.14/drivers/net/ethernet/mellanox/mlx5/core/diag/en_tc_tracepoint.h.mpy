{
  "module_name": "en_tc_tracepoint.h",
  "hash_id": "28e972d613ae16eb46322ee17fe8d9730c5fdf1e7c98015f105e7490792de6b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/diag/en_tc_tracepoint.h",
  "human_readable_source": " \n \n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM mlx5\n\n#if !defined(_MLX5_TC_TP_) || defined(TRACE_HEADER_MULTI_READ)\n#define _MLX5_TC_TP_\n\n#include <linux/tracepoint.h>\n#include <linux/trace_seq.h>\n#include <net/flow_offload.h>\n#include \"en_rep.h\"\n\n#define __parse_action(ids, num) parse_action(p, ids, num)\n\nvoid put_ids_to_array(int *ids,\n\t\t      const struct flow_action_entry *entries,\n\t\t      unsigned int num);\n\nconst char *parse_action(struct trace_seq *p,\n\t\t\t int *ids,\n\t\t\t unsigned int num);\n\nDECLARE_EVENT_CLASS(mlx5e_flower_template,\n\t\t    TP_PROTO(const struct flow_cls_offload *f),\n\t\t    TP_ARGS(f),\n\t\t    TP_STRUCT__entry(__field(void *, cookie)\n\t\t\t\t     __field(unsigned int, num)\n\t\t\t\t     __dynamic_array(int, ids, f->rule ?\n\t\t\t\t\t     f->rule->action.num_entries : 0)\n\t\t\t\t     ),\n\t\t    TP_fast_assign(__entry->cookie = (void *)f->cookie;\n\t\t\t__entry->num = (f->rule ?\n\t\t\t\tf->rule->action.num_entries : 0);\n\t\t\tif (__entry->num)\n\t\t\t\tput_ids_to_array(__get_dynamic_array(ids),\n\t\t\t\t\t\t f->rule->action.entries,\n\t\t\t\t\t\t f->rule->action.num_entries);\n\t\t\t),\n\t\t    TP_printk(\"cookie=%p actions= %s\\n\",\n\t\t\t      __entry->cookie, __entry->num ?\n\t\t\t\t      __parse_action(__get_dynamic_array(ids),\n\t\t\t\t\t\t     __entry->num) : \"NULL\"\n\t\t\t      )\n);\n\nDEFINE_EVENT(mlx5e_flower_template, mlx5e_configure_flower,\n\t     TP_PROTO(const struct flow_cls_offload *f),\n\t     TP_ARGS(f)\n\t     );\n\nDEFINE_EVENT(mlx5e_flower_template, mlx5e_delete_flower,\n\t     TP_PROTO(const struct flow_cls_offload *f),\n\t     TP_ARGS(f)\n\t     );\n\nTRACE_EVENT(mlx5e_stats_flower,\n\t    TP_PROTO(const struct flow_cls_offload *f),\n\t    TP_ARGS(f),\n\t    TP_STRUCT__entry(__field(void *, cookie)\n\t\t\t     __field(u64, bytes)\n\t\t\t     __field(u64, packets)\n\t\t\t     __field(u64, lastused)\n\t\t\t     ),\n\t    TP_fast_assign(__entry->cookie = (void *)f->cookie;\n\t\t__entry->bytes = f->stats.bytes;\n\t\t__entry->packets = f->stats.pkts;\n\t\t__entry->lastused = f->stats.lastused;\n\t\t),\n\t    TP_printk(\"cookie=%p bytes=%llu packets=%llu lastused=%llu\\n\",\n\t\t      __entry->cookie, __entry->bytes,\n\t\t      __entry->packets, __entry->lastused\n\t\t      )\n);\n\nTRACE_EVENT(mlx5e_tc_update_neigh_used_value,\n\t    TP_PROTO(const struct mlx5e_neigh_hash_entry *nhe, bool neigh_used),\n\t    TP_ARGS(nhe, neigh_used),\n\t    TP_STRUCT__entry(__string(devname, nhe->neigh_dev->name)\n\t\t\t     __array(u8, v4, 4)\n\t\t\t     __array(u8, v6, 16)\n\t\t\t     __field(bool, neigh_used)\n\t\t\t     ),\n\t    TP_fast_assign(const struct mlx5e_neigh *mn = &nhe->m_neigh;\n\t\t\tstruct in6_addr *pin6;\n\t\t\t__be32 *p32;\n\n\t\t\t__assign_str(devname, nhe->neigh_dev->name);\n\t\t\t__entry->neigh_used = neigh_used;\n\n\t\t\tp32 = (__be32 *)__entry->v4;\n\t\t\tpin6 = (struct in6_addr *)__entry->v6;\n\t\t\tif (mn->family == AF_INET) {\n\t\t\t\t*p32 = mn->dst_ip.v4;\n\t\t\t\tipv6_addr_set_v4mapped(*p32, pin6);\n\t\t\t} else if (mn->family == AF_INET6) {\n\t\t\t\t*pin6 = mn->dst_ip.v6;\n\t\t\t}\n\t\t\t),\n\t    TP_printk(\"netdev: %s IPv4: %pI4 IPv6: %pI6c neigh_used=%d\\n\",\n\t\t      __get_str(devname), __entry->v4, __entry->v6,\n\t\t      __entry->neigh_used\n\t\t      )\n);\n\n#endif  \n\n \n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH ./diag\n#undef TRACE_INCLUDE_FILE\n#define TRACE_INCLUDE_FILE en_tc_tracepoint\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}