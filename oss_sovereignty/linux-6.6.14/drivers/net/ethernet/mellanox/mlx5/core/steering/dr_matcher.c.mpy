{
  "module_name": "dr_matcher.c",
  "hash_id": "6b76468a2a247f25a476dde3ceef47966f642c1c3c206e70a8782a0b0641f66d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_matcher.c",
  "human_readable_source": "\n \n\n#include \"dr_types.h\"\n\nstatic bool dr_mask_is_smac_set(struct mlx5dr_match_spec *spec)\n{\n\treturn (spec->smac_47_16 || spec->smac_15_0);\n}\n\nstatic bool dr_mask_is_dmac_set(struct mlx5dr_match_spec *spec)\n{\n\treturn (spec->dmac_47_16 || spec->dmac_15_0);\n}\n\nstatic bool dr_mask_is_l3_base_set(struct mlx5dr_match_spec *spec)\n{\n\treturn (spec->ip_protocol || spec->frag || spec->tcp_flags ||\n\t\tspec->ip_ecn || spec->ip_dscp);\n}\n\nstatic bool dr_mask_is_tcp_udp_base_set(struct mlx5dr_match_spec *spec)\n{\n\treturn (spec->tcp_sport || spec->tcp_dport ||\n\t\tspec->udp_sport || spec->udp_dport);\n}\n\nstatic bool dr_mask_is_ipv4_set(struct mlx5dr_match_spec *spec)\n{\n\treturn (spec->dst_ip_31_0 || spec->src_ip_31_0);\n}\n\nstatic bool dr_mask_is_ipv4_5_tuple_set(struct mlx5dr_match_spec *spec)\n{\n\treturn (dr_mask_is_l3_base_set(spec) ||\n\t\tdr_mask_is_tcp_udp_base_set(spec) ||\n\t\tdr_mask_is_ipv4_set(spec));\n}\n\nstatic bool dr_mask_is_eth_l2_tnl_set(struct mlx5dr_match_misc *misc)\n{\n\treturn misc->vxlan_vni;\n}\n\nstatic bool dr_mask_is_ttl_set(struct mlx5dr_match_spec *spec)\n{\n\treturn spec->ttl_hoplimit;\n}\n\nstatic bool dr_mask_is_ipv4_ihl_set(struct mlx5dr_match_spec *spec)\n{\n\treturn spec->ipv4_ihl;\n}\n\n#define DR_MASK_IS_L2_DST(_spec, _misc, _inner_outer) (_spec.first_vid || \\\n\t(_spec).first_cfi || (_spec).first_prio || (_spec).cvlan_tag || \\\n\t(_spec).svlan_tag || (_spec).dmac_47_16 || (_spec).dmac_15_0 || \\\n\t(_spec).ethertype || (_spec).ip_version || \\\n\t(_misc)._inner_outer##_second_vid || \\\n\t(_misc)._inner_outer##_second_cfi || \\\n\t(_misc)._inner_outer##_second_prio || \\\n\t(_misc)._inner_outer##_second_cvlan_tag || \\\n\t(_misc)._inner_outer##_second_svlan_tag)\n\n#define DR_MASK_IS_ETH_L4_SET(_spec, _misc, _inner_outer) ( \\\n\tdr_mask_is_l3_base_set(&(_spec)) || \\\n\tdr_mask_is_tcp_udp_base_set(&(_spec)) || \\\n\tdr_mask_is_ttl_set(&(_spec)) || \\\n\t(_misc)._inner_outer##_ipv6_flow_label)\n\n#define DR_MASK_IS_ETH_L4_MISC_SET(_misc3, _inner_outer) ( \\\n\t(_misc3)._inner_outer##_tcp_seq_num || \\\n\t(_misc3)._inner_outer##_tcp_ack_num)\n\n#define DR_MASK_IS_FIRST_MPLS_SET(_misc2, _inner_outer) ( \\\n\t(_misc2)._inner_outer##_first_mpls_label || \\\n\t(_misc2)._inner_outer##_first_mpls_exp || \\\n\t(_misc2)._inner_outer##_first_mpls_s_bos || \\\n\t(_misc2)._inner_outer##_first_mpls_ttl)\n\nstatic bool dr_mask_is_tnl_gre_set(struct mlx5dr_match_misc *misc)\n{\n\treturn (misc->gre_key_h || misc->gre_key_l ||\n\t\tmisc->gre_protocol || misc->gre_c_present ||\n\t\tmisc->gre_k_present || misc->gre_s_present);\n}\n\n#define DR_MASK_IS_OUTER_MPLS_OVER_GRE_SET(_misc) (\\\n\t(_misc)->outer_first_mpls_over_gre_label || \\\n\t(_misc)->outer_first_mpls_over_gre_exp || \\\n\t(_misc)->outer_first_mpls_over_gre_s_bos || \\\n\t(_misc)->outer_first_mpls_over_gre_ttl)\n\n#define DR_MASK_IS_OUTER_MPLS_OVER_UDP_SET(_misc) (\\\n\t(_misc)->outer_first_mpls_over_udp_label || \\\n\t(_misc)->outer_first_mpls_over_udp_exp || \\\n\t(_misc)->outer_first_mpls_over_udp_s_bos || \\\n\t(_misc)->outer_first_mpls_over_udp_ttl)\n\nstatic bool\ndr_mask_is_vxlan_gpe_set(struct mlx5dr_match_misc3 *misc3)\n{\n\treturn (misc3->outer_vxlan_gpe_vni ||\n\t\tmisc3->outer_vxlan_gpe_next_protocol ||\n\t\tmisc3->outer_vxlan_gpe_flags);\n}\n\nstatic bool\ndr_matcher_supp_vxlan_gpe(struct mlx5dr_cmd_caps *caps)\n{\n\treturn (caps->sw_format_ver >= MLX5_STEERING_FORMAT_CONNECTX_6DX) ||\n\t       (caps->flex_protocols & MLX5_FLEX_PARSER_VXLAN_GPE_ENABLED);\n}\n\nstatic bool\ndr_mask_is_tnl_vxlan_gpe(struct mlx5dr_match_param *mask,\n\t\t\t struct mlx5dr_domain *dmn)\n{\n\treturn dr_mask_is_vxlan_gpe_set(&mask->misc3) &&\n\t       dr_matcher_supp_vxlan_gpe(&dmn->info.caps);\n}\n\nstatic bool dr_mask_is_tnl_geneve_set(struct mlx5dr_match_misc *misc)\n{\n\treturn misc->geneve_vni ||\n\t       misc->geneve_oam ||\n\t       misc->geneve_protocol_type ||\n\t       misc->geneve_opt_len;\n}\n\nstatic bool dr_mask_is_tnl_geneve_tlv_opt(struct mlx5dr_match_misc3 *misc3)\n{\n\treturn misc3->geneve_tlv_option_0_data;\n}\n\nstatic bool\ndr_matcher_supp_flex_parser_ok(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_parser_ok_bits_supp;\n}\n\nstatic bool dr_mask_is_tnl_geneve_tlv_opt_exist_set(struct mlx5dr_match_misc *misc,\n\t\t\t\t\t\t    struct mlx5dr_domain *dmn)\n{\n\treturn dr_matcher_supp_flex_parser_ok(&dmn->info.caps) &&\n\t       misc->geneve_tlv_option_0_exist;\n}\n\nstatic bool\ndr_matcher_supp_tnl_geneve(struct mlx5dr_cmd_caps *caps)\n{\n\treturn (caps->sw_format_ver >= MLX5_STEERING_FORMAT_CONNECTX_6DX) ||\n\t       (caps->flex_protocols & MLX5_FLEX_PARSER_GENEVE_ENABLED);\n}\n\nstatic bool\ndr_mask_is_tnl_geneve(struct mlx5dr_match_param *mask,\n\t\t      struct mlx5dr_domain *dmn)\n{\n\treturn dr_mask_is_tnl_geneve_set(&mask->misc) &&\n\t       dr_matcher_supp_tnl_geneve(&dmn->info.caps);\n}\n\nstatic bool dr_mask_is_tnl_gtpu_set(struct mlx5dr_match_misc3 *misc3)\n{\n\treturn misc3->gtpu_msg_flags || misc3->gtpu_msg_type || misc3->gtpu_teid;\n}\n\nstatic bool dr_matcher_supp_tnl_gtpu(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_ENABLED;\n}\n\nstatic bool dr_mask_is_tnl_gtpu(struct mlx5dr_match_param *mask,\n\t\t\t\tstruct mlx5dr_domain *dmn)\n{\n\treturn dr_mask_is_tnl_gtpu_set(&mask->misc3) &&\n\t       dr_matcher_supp_tnl_gtpu(&dmn->info.caps);\n}\n\nstatic int dr_matcher_supp_tnl_gtpu_dw_0(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_DW_0_ENABLED;\n}\n\nstatic bool dr_mask_is_tnl_gtpu_dw_0(struct mlx5dr_match_param *mask,\n\t\t\t\t     struct mlx5dr_domain *dmn)\n{\n\treturn mask->misc3.gtpu_dw_0 &&\n\t       dr_matcher_supp_tnl_gtpu_dw_0(&dmn->info.caps);\n}\n\nstatic int dr_matcher_supp_tnl_gtpu_teid(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_TEID_ENABLED;\n}\n\nstatic bool dr_mask_is_tnl_gtpu_teid(struct mlx5dr_match_param *mask,\n\t\t\t\t     struct mlx5dr_domain *dmn)\n{\n\treturn mask->misc3.gtpu_teid &&\n\t       dr_matcher_supp_tnl_gtpu_teid(&dmn->info.caps);\n}\n\nstatic int dr_matcher_supp_tnl_gtpu_dw_2(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_DW_2_ENABLED;\n}\n\nstatic bool dr_mask_is_tnl_gtpu_dw_2(struct mlx5dr_match_param *mask,\n\t\t\t\t     struct mlx5dr_domain *dmn)\n{\n\treturn mask->misc3.gtpu_dw_2 &&\n\t       dr_matcher_supp_tnl_gtpu_dw_2(&dmn->info.caps);\n}\n\nstatic int dr_matcher_supp_tnl_gtpu_first_ext(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_FIRST_EXT_DW_0_ENABLED;\n}\n\nstatic bool dr_mask_is_tnl_gtpu_first_ext(struct mlx5dr_match_param *mask,\n\t\t\t\t\t  struct mlx5dr_domain *dmn)\n{\n\treturn mask->misc3.gtpu_first_ext_dw_0 &&\n\t       dr_matcher_supp_tnl_gtpu_first_ext(&dmn->info.caps);\n}\n\nstatic bool dr_mask_is_tnl_gtpu_flex_parser_0(struct mlx5dr_match_param *mask,\n\t\t\t\t\t      struct mlx5dr_domain *dmn)\n{\n\tstruct mlx5dr_cmd_caps *caps = &dmn->info.caps;\n\n\treturn (dr_is_flex_parser_0_id(caps->flex_parser_id_gtpu_dw_0) &&\n\t\tdr_mask_is_tnl_gtpu_dw_0(mask, dmn)) ||\n\t       (dr_is_flex_parser_0_id(caps->flex_parser_id_gtpu_teid) &&\n\t\tdr_mask_is_tnl_gtpu_teid(mask, dmn)) ||\n\t       (dr_is_flex_parser_0_id(caps->flex_parser_id_gtpu_dw_2) &&\n\t\tdr_mask_is_tnl_gtpu_dw_2(mask, dmn)) ||\n\t       (dr_is_flex_parser_0_id(caps->flex_parser_id_gtpu_first_ext_dw_0) &&\n\t\tdr_mask_is_tnl_gtpu_first_ext(mask, dmn));\n}\n\nstatic bool dr_mask_is_tnl_gtpu_flex_parser_1(struct mlx5dr_match_param *mask,\n\t\t\t\t\t      struct mlx5dr_domain *dmn)\n{\n\tstruct mlx5dr_cmd_caps *caps = &dmn->info.caps;\n\n\treturn (dr_is_flex_parser_1_id(caps->flex_parser_id_gtpu_dw_0) &&\n\t\tdr_mask_is_tnl_gtpu_dw_0(mask, dmn)) ||\n\t       (dr_is_flex_parser_1_id(caps->flex_parser_id_gtpu_teid) &&\n\t\tdr_mask_is_tnl_gtpu_teid(mask, dmn)) ||\n\t       (dr_is_flex_parser_1_id(caps->flex_parser_id_gtpu_dw_2) &&\n\t\tdr_mask_is_tnl_gtpu_dw_2(mask, dmn)) ||\n\t       (dr_is_flex_parser_1_id(caps->flex_parser_id_gtpu_first_ext_dw_0) &&\n\t\tdr_mask_is_tnl_gtpu_first_ext(mask, dmn));\n}\n\nstatic bool dr_mask_is_tnl_gtpu_any(struct mlx5dr_match_param *mask,\n\t\t\t\t    struct mlx5dr_domain *dmn)\n{\n\treturn dr_mask_is_tnl_gtpu_flex_parser_0(mask, dmn) ||\n\t       dr_mask_is_tnl_gtpu_flex_parser_1(mask, dmn) ||\n\t       dr_mask_is_tnl_gtpu(mask, dmn);\n}\n\nstatic int dr_matcher_supp_icmp_v4(struct mlx5dr_cmd_caps *caps)\n{\n\treturn (caps->sw_format_ver >= MLX5_STEERING_FORMAT_CONNECTX_6DX) ||\n\t       (caps->flex_protocols & MLX5_FLEX_PARSER_ICMP_V4_ENABLED);\n}\n\nstatic int dr_matcher_supp_icmp_v6(struct mlx5dr_cmd_caps *caps)\n{\n\treturn (caps->sw_format_ver >= MLX5_STEERING_FORMAT_CONNECTX_6DX) ||\n\t       (caps->flex_protocols & MLX5_FLEX_PARSER_ICMP_V6_ENABLED);\n}\n\nstatic bool dr_mask_is_icmpv6_set(struct mlx5dr_match_misc3 *misc3)\n{\n\treturn (misc3->icmpv6_type || misc3->icmpv6_code ||\n\t\tmisc3->icmpv6_header_data);\n}\n\nstatic bool dr_mask_is_icmp(struct mlx5dr_match_param *mask,\n\t\t\t    struct mlx5dr_domain *dmn)\n{\n\tif (DR_MASK_IS_ICMPV4_SET(&mask->misc3))\n\t\treturn dr_matcher_supp_icmp_v4(&dmn->info.caps);\n\telse if (dr_mask_is_icmpv6_set(&mask->misc3))\n\t\treturn dr_matcher_supp_icmp_v6(&dmn->info.caps);\n\n\treturn false;\n}\n\nstatic bool dr_mask_is_wqe_metadata_set(struct mlx5dr_match_misc2 *misc2)\n{\n\treturn misc2->metadata_reg_a;\n}\n\nstatic bool dr_mask_is_reg_c_0_3_set(struct mlx5dr_match_misc2 *misc2)\n{\n\treturn (misc2->metadata_reg_c_0 || misc2->metadata_reg_c_1 ||\n\t\tmisc2->metadata_reg_c_2 || misc2->metadata_reg_c_3);\n}\n\nstatic bool dr_mask_is_reg_c_4_7_set(struct mlx5dr_match_misc2 *misc2)\n{\n\treturn (misc2->metadata_reg_c_4 || misc2->metadata_reg_c_5 ||\n\t\tmisc2->metadata_reg_c_6 || misc2->metadata_reg_c_7);\n}\n\nstatic bool dr_mask_is_gvmi_or_qpn_set(struct mlx5dr_match_misc *misc)\n{\n\treturn (misc->source_sqn || misc->source_port);\n}\n\nstatic bool dr_mask_is_flex_parser_id_0_3_set(u32 flex_parser_id,\n\t\t\t\t\t      u32 flex_parser_value)\n{\n\tif (flex_parser_id)\n\t\treturn flex_parser_id <= DR_STE_MAX_FLEX_0_ID;\n\n\t \n\treturn flex_parser_value;\n}\n\nstatic bool dr_mask_is_flex_parser_0_3_set(struct mlx5dr_match_misc4 *misc4)\n{\n\treturn (dr_mask_is_flex_parser_id_0_3_set(misc4->prog_sample_field_id_0,\n\t\t\t\t\t\t  misc4->prog_sample_field_value_0) ||\n\t\tdr_mask_is_flex_parser_id_0_3_set(misc4->prog_sample_field_id_1,\n\t\t\t\t\t\t  misc4->prog_sample_field_value_1) ||\n\t\tdr_mask_is_flex_parser_id_0_3_set(misc4->prog_sample_field_id_2,\n\t\t\t\t\t\t  misc4->prog_sample_field_value_2) ||\n\t\tdr_mask_is_flex_parser_id_0_3_set(misc4->prog_sample_field_id_3,\n\t\t\t\t\t\t  misc4->prog_sample_field_value_3));\n}\n\nstatic bool dr_mask_is_flex_parser_id_4_7_set(u32 flex_parser_id)\n{\n\treturn flex_parser_id > DR_STE_MAX_FLEX_0_ID &&\n\t       flex_parser_id <= DR_STE_MAX_FLEX_1_ID;\n}\n\nstatic bool dr_mask_is_flex_parser_4_7_set(struct mlx5dr_match_misc4 *misc4)\n{\n\treturn (dr_mask_is_flex_parser_id_4_7_set(misc4->prog_sample_field_id_0) ||\n\t\tdr_mask_is_flex_parser_id_4_7_set(misc4->prog_sample_field_id_1) ||\n\t\tdr_mask_is_flex_parser_id_4_7_set(misc4->prog_sample_field_id_2) ||\n\t\tdr_mask_is_flex_parser_id_4_7_set(misc4->prog_sample_field_id_3));\n}\n\nstatic int dr_matcher_supp_tnl_mpls_over_gre(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_protocols & MLX5_FLEX_PARSER_MPLS_OVER_GRE_ENABLED;\n}\n\nstatic bool dr_mask_is_tnl_mpls_over_gre(struct mlx5dr_match_param *mask,\n\t\t\t\t\t struct mlx5dr_domain *dmn)\n{\n\treturn DR_MASK_IS_OUTER_MPLS_OVER_GRE_SET(&mask->misc2) &&\n\t       dr_matcher_supp_tnl_mpls_over_gre(&dmn->info.caps);\n}\n\nstatic int dr_matcher_supp_tnl_mpls_over_udp(struct mlx5dr_cmd_caps *caps)\n{\n\treturn caps->flex_protocols & MLX5_FLEX_PARSER_MPLS_OVER_UDP_ENABLED;\n}\n\nstatic bool dr_mask_is_tnl_mpls_over_udp(struct mlx5dr_match_param *mask,\n\t\t\t\t\t struct mlx5dr_domain *dmn)\n{\n\treturn DR_MASK_IS_OUTER_MPLS_OVER_UDP_SET(&mask->misc2) &&\n\t       dr_matcher_supp_tnl_mpls_over_udp(&dmn->info.caps);\n}\n\nstatic bool dr_mask_is_tnl_header_0_1_set(struct mlx5dr_match_misc5 *misc5)\n{\n\treturn misc5->tunnel_header_0 || misc5->tunnel_header_1;\n}\n\nint mlx5dr_matcher_select_builders(struct mlx5dr_matcher *matcher,\n\t\t\t\t   struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\t   enum mlx5dr_ipv outer_ipv,\n\t\t\t\t   enum mlx5dr_ipv inner_ipv)\n{\n\tnic_matcher->ste_builder =\n\t\tnic_matcher->ste_builder_arr[outer_ipv][inner_ipv];\n\tnic_matcher->num_of_builders =\n\t\tnic_matcher->num_of_builders_arr[outer_ipv][inner_ipv];\n\n\tif (!nic_matcher->num_of_builders) {\n\t\tmlx5dr_dbg(matcher->tbl->dmn,\n\t\t\t   \"Rule not supported on this matcher due to IP related fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dr_matcher_set_ste_builders(struct mlx5dr_matcher *matcher,\n\t\t\t\t       struct mlx5dr_matcher_rx_tx *nic_matcher,\n\t\t\t\t       enum mlx5dr_ipv outer_ipv,\n\t\t\t\t       enum mlx5dr_ipv inner_ipv)\n{\n\tstruct mlx5dr_domain_rx_tx *nic_dmn = nic_matcher->nic_tbl->nic_dmn;\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_ste_ctx *ste_ctx = dmn->ste_ctx;\n\tstruct mlx5dr_match_param mask = {};\n\tbool allow_empty_match = false;\n\tstruct mlx5dr_ste_build *sb;\n\tbool inner, rx;\n\tint idx = 0;\n\tint ret, i;\n\n\tsb = nic_matcher->ste_builder_arr[outer_ipv][inner_ipv];\n\trx = nic_dmn->type == DR_DOMAIN_NIC_TYPE_RX;\n\n\t \n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_OUTER)\n\t\tmask.outer = matcher->mask.outer;\n\n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_MISC)\n\t\tmask.misc = matcher->mask.misc;\n\n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_INNER)\n\t\tmask.inner = matcher->mask.inner;\n\n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_MISC2)\n\t\tmask.misc2 = matcher->mask.misc2;\n\n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_MISC3)\n\t\tmask.misc3 = matcher->mask.misc3;\n\n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_MISC4)\n\t\tmask.misc4 = matcher->mask.misc4;\n\n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_MISC5)\n\t\tmask.misc5 = matcher->mask.misc5;\n\n\tret = mlx5dr_ste_build_pre_check(dmn, matcher->match_criteria,\n\t\t\t\t\t &matcher->mask, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (dmn->type == MLX5DR_DOMAIN_TYPE_FDB &&\n\t    rx && mask.misc.source_port) {\n\t\tmask.misc.source_port = 0;\n\t\tmask.misc.source_eswitch_owner_vhca_id = 0;\n\t\tallow_empty_match = true;\n\t}\n\n\t \n\tif (matcher->match_criteria & (DR_MATCHER_CRITERIA_OUTER |\n\t\t\t\t       DR_MATCHER_CRITERIA_MISC |\n\t\t\t\t       DR_MATCHER_CRITERIA_MISC2 |\n\t\t\t\t       DR_MATCHER_CRITERIA_MISC3 |\n\t\t\t\t       DR_MATCHER_CRITERIA_MISC5)) {\n\t\tinner = false;\n\n\t\tif (dr_mask_is_wqe_metadata_set(&mask.misc2))\n\t\t\tmlx5dr_ste_build_general_purpose(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t &mask, inner, rx);\n\n\t\tif (dr_mask_is_reg_c_0_3_set(&mask.misc2))\n\t\t\tmlx5dr_ste_build_register_0(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\n\t\tif (dr_mask_is_reg_c_4_7_set(&mask.misc2))\n\t\t\tmlx5dr_ste_build_register_1(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\n\t\tif (dr_mask_is_gvmi_or_qpn_set(&mask.misc) &&\n\t\t    (dmn->type == MLX5DR_DOMAIN_TYPE_FDB ||\n\t\t     dmn->type == MLX5DR_DOMAIN_TYPE_NIC_RX)) {\n\t\t\tmlx5dr_ste_build_src_gvmi_qpn(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t      &mask, dmn, inner, rx);\n\t\t}\n\n\t\tif (dr_mask_is_smac_set(&mask.outer) &&\n\t\t    dr_mask_is_dmac_set(&mask.outer)) {\n\t\t\tmlx5dr_ste_build_eth_l2_src_dst(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t&mask, inner, rx);\n\t\t}\n\n\t\tif (dr_mask_is_smac_set(&mask.outer))\n\t\t\tmlx5dr_ste_build_eth_l2_src(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\n\t\tif (DR_MASK_IS_L2_DST(mask.outer, mask.misc, outer))\n\t\t\tmlx5dr_ste_build_eth_l2_dst(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\n\t\tif (outer_ipv == DR_RULE_IPV6) {\n\t\t\tif (DR_MASK_IS_DST_IP_SET(&mask.outer))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv6_dst(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t &mask, inner, rx);\n\n\t\t\tif (DR_MASK_IS_SRC_IP_SET(&mask.outer))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv6_src(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t &mask, inner, rx);\n\n\t\t\tif (DR_MASK_IS_ETH_L4_SET(mask.outer, mask.misc, outer))\n\t\t\t\tmlx5dr_ste_build_eth_ipv6_l3_l4(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t&mask, inner, rx);\n\t\t} else {\n\t\t\tif (dr_mask_is_ipv4_5_tuple_set(&mask.outer))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv4_5_tuple(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t     &mask, inner, rx);\n\n\t\t\tif (dr_mask_is_ttl_set(&mask.outer) ||\n\t\t\t    dr_mask_is_ipv4_ihl_set(&mask.outer))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv4_misc(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t  &mask, inner, rx);\n\t\t}\n\n\t\tif (dr_mask_is_tnl_vxlan_gpe(&mask, dmn))\n\t\t\tmlx5dr_ste_build_tnl_vxlan_gpe(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t       &mask, inner, rx);\n\t\telse if (dr_mask_is_tnl_geneve(&mask, dmn)) {\n\t\t\tmlx5dr_ste_build_tnl_geneve(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\t\t\tif (dr_mask_is_tnl_geneve_tlv_opt(&mask.misc3))\n\t\t\t\tmlx5dr_ste_build_tnl_geneve_tlv_opt(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t    &mask, &dmn->info.caps,\n\t\t\t\t\t\t\t\t    inner, rx);\n\t\t\tif (dr_mask_is_tnl_geneve_tlv_opt_exist_set(&mask.misc, dmn))\n\t\t\t\tmlx5dr_ste_build_tnl_geneve_tlv_opt_exist(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t\t  &mask, &dmn->info.caps,\n\t\t\t\t\t\t\t\t\t  inner, rx);\n\t\t} else if (dr_mask_is_tnl_gtpu_any(&mask, dmn)) {\n\t\t\tif (dr_mask_is_tnl_gtpu_flex_parser_0(&mask, dmn))\n\t\t\t\tmlx5dr_ste_build_tnl_gtpu_flex_parser_0(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t\t&mask, &dmn->info.caps,\n\t\t\t\t\t\t\t\t\tinner, rx);\n\n\t\t\tif (dr_mask_is_tnl_gtpu_flex_parser_1(&mask, dmn))\n\t\t\t\tmlx5dr_ste_build_tnl_gtpu_flex_parser_1(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t\t&mask, &dmn->info.caps,\n\t\t\t\t\t\t\t\t\tinner, rx);\n\n\t\t\tif (dr_mask_is_tnl_gtpu(&mask, dmn))\n\t\t\t\tmlx5dr_ste_build_tnl_gtpu(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t  &mask, inner, rx);\n\t\t} else if (dr_mask_is_tnl_header_0_1_set(&mask.misc5)) {\n\t\t\tmlx5dr_ste_build_tnl_header_0_1(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t&mask, inner, rx);\n\t\t}\n\n\t\tif (DR_MASK_IS_ETH_L4_MISC_SET(mask.misc3, outer))\n\t\t\tmlx5dr_ste_build_eth_l4_misc(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t     &mask, inner, rx);\n\n\t\tif (DR_MASK_IS_FIRST_MPLS_SET(mask.misc2, outer))\n\t\t\tmlx5dr_ste_build_mpls(ste_ctx, &sb[idx++],\n\t\t\t\t\t      &mask, inner, rx);\n\n\t\tif (dr_mask_is_tnl_mpls_over_gre(&mask, dmn))\n\t\t\tmlx5dr_ste_build_tnl_mpls_over_gre(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t   &mask, &dmn->info.caps,\n\t\t\t\t\t\t\t   inner, rx);\n\t\telse if (dr_mask_is_tnl_mpls_over_udp(&mask, dmn))\n\t\t\tmlx5dr_ste_build_tnl_mpls_over_udp(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t   &mask, &dmn->info.caps,\n\t\t\t\t\t\t\t   inner, rx);\n\n\t\tif (dr_mask_is_icmp(&mask, dmn))\n\t\t\tmlx5dr_ste_build_icmp(ste_ctx, &sb[idx++],\n\t\t\t\t\t      &mask, &dmn->info.caps,\n\t\t\t\t\t      inner, rx);\n\n\t\tif (dr_mask_is_tnl_gre_set(&mask.misc))\n\t\t\tmlx5dr_ste_build_tnl_gre(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t &mask, inner, rx);\n\t}\n\n\t \n\tif (matcher->match_criteria & (DR_MATCHER_CRITERIA_INNER |\n\t\t\t\t       DR_MATCHER_CRITERIA_MISC |\n\t\t\t\t       DR_MATCHER_CRITERIA_MISC2 |\n\t\t\t\t       DR_MATCHER_CRITERIA_MISC3)) {\n\t\tinner = true;\n\n\t\tif (dr_mask_is_eth_l2_tnl_set(&mask.misc))\n\t\t\tmlx5dr_ste_build_eth_l2_tnl(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\n\t\tif (dr_mask_is_smac_set(&mask.inner) &&\n\t\t    dr_mask_is_dmac_set(&mask.inner)) {\n\t\t\tmlx5dr_ste_build_eth_l2_src_dst(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t&mask, inner, rx);\n\t\t}\n\n\t\tif (dr_mask_is_smac_set(&mask.inner))\n\t\t\tmlx5dr_ste_build_eth_l2_src(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\n\t\tif (DR_MASK_IS_L2_DST(mask.inner, mask.misc, inner))\n\t\t\tmlx5dr_ste_build_eth_l2_dst(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t    &mask, inner, rx);\n\n\t\tif (inner_ipv == DR_RULE_IPV6) {\n\t\t\tif (DR_MASK_IS_DST_IP_SET(&mask.inner))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv6_dst(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t &mask, inner, rx);\n\n\t\t\tif (DR_MASK_IS_SRC_IP_SET(&mask.inner))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv6_src(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t &mask, inner, rx);\n\n\t\t\tif (DR_MASK_IS_ETH_L4_SET(mask.inner, mask.misc, inner))\n\t\t\t\tmlx5dr_ste_build_eth_ipv6_l3_l4(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t&mask, inner, rx);\n\t\t} else {\n\t\t\tif (dr_mask_is_ipv4_5_tuple_set(&mask.inner))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv4_5_tuple(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t     &mask, inner, rx);\n\n\t\t\tif (dr_mask_is_ttl_set(&mask.inner) ||\n\t\t\t    dr_mask_is_ipv4_ihl_set(&mask.inner))\n\t\t\t\tmlx5dr_ste_build_eth_l3_ipv4_misc(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t\t  &mask, inner, rx);\n\t\t}\n\n\t\tif (DR_MASK_IS_ETH_L4_MISC_SET(mask.misc3, inner))\n\t\t\tmlx5dr_ste_build_eth_l4_misc(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t     &mask, inner, rx);\n\n\t\tif (DR_MASK_IS_FIRST_MPLS_SET(mask.misc2, inner))\n\t\t\tmlx5dr_ste_build_mpls(ste_ctx, &sb[idx++],\n\t\t\t\t\t      &mask, inner, rx);\n\n\t\tif (dr_mask_is_tnl_mpls_over_gre(&mask, dmn))\n\t\t\tmlx5dr_ste_build_tnl_mpls_over_gre(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t   &mask, &dmn->info.caps,\n\t\t\t\t\t\t\t   inner, rx);\n\t\telse if (dr_mask_is_tnl_mpls_over_udp(&mask, dmn))\n\t\t\tmlx5dr_ste_build_tnl_mpls_over_udp(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t\t   &mask, &dmn->info.caps,\n\t\t\t\t\t\t\t   inner, rx);\n\t}\n\n\tif (matcher->match_criteria & DR_MATCHER_CRITERIA_MISC4) {\n\t\tif (dr_mask_is_flex_parser_0_3_set(&mask.misc4))\n\t\t\tmlx5dr_ste_build_flex_parser_0(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t       &mask, false, rx);\n\n\t\tif (dr_mask_is_flex_parser_4_7_set(&mask.misc4))\n\t\t\tmlx5dr_ste_build_flex_parser_1(ste_ctx, &sb[idx++],\n\t\t\t\t\t\t       &mask, false, rx);\n\t}\n\n\t \n\tif ((!idx && allow_empty_match) ||\n\t    matcher->match_criteria == DR_MATCHER_CRITERIA_EMPTY)\n\t\tmlx5dr_ste_build_empty_always_hit(&sb[idx++], rx);\n\n\tif (idx == 0) {\n\t\tmlx5dr_err(dmn, \"Cannot generate any valid rules from mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < sizeof(struct mlx5dr_match_param); i++) {\n\t\tif (((u8 *)&mask)[i] != 0) {\n\t\t\tmlx5dr_dbg(dmn, \"Mask contains unsupported parameters\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tnic_matcher->ste_builder = sb;\n\tnic_matcher->num_of_builders_arr[outer_ipv][inner_ipv] = idx;\n\n\treturn 0;\n}\n\nstatic int dr_nic_matcher_connect(struct mlx5dr_domain *dmn,\n\t\t\t\t  struct mlx5dr_matcher_rx_tx *curr_nic_matcher,\n\t\t\t\t  struct mlx5dr_matcher_rx_tx *next_nic_matcher,\n\t\t\t\t  struct mlx5dr_matcher_rx_tx *prev_nic_matcher)\n{\n\tstruct mlx5dr_table_rx_tx *nic_tbl = curr_nic_matcher->nic_tbl;\n\tstruct mlx5dr_domain_rx_tx *nic_dmn = nic_tbl->nic_dmn;\n\tstruct mlx5dr_htbl_connect_info info;\n\tstruct mlx5dr_ste_htbl *prev_htbl;\n\tint ret;\n\n\t \n\tif (next_nic_matcher) {\n\t\tinfo.type = CONNECT_HIT;\n\t\tinfo.hit_next_htbl = next_nic_matcher->s_htbl;\n\t} else {\n\t\tinfo.type = CONNECT_MISS;\n\t\tinfo.miss_icm_addr = nic_tbl->default_icm_addr;\n\t}\n\tret = mlx5dr_ste_htbl_init_and_postsend(dmn, nic_dmn,\n\t\t\t\t\t\tcurr_nic_matcher->e_anchor,\n\t\t\t\t\t\t&info, info.type == CONNECT_HIT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tinfo.type = CONNECT_MISS;\n\tinfo.miss_icm_addr = mlx5dr_icm_pool_get_chunk_icm_addr(curr_nic_matcher->e_anchor->chunk);\n\tret = mlx5dr_ste_htbl_init_and_postsend(dmn, nic_dmn,\n\t\t\t\t\t\tcurr_nic_matcher->s_htbl,\n\t\t\t\t\t\t&info, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (prev_nic_matcher)\n\t\tprev_htbl = prev_nic_matcher->e_anchor;\n\telse\n\t\tprev_htbl = nic_tbl->s_anchor;\n\n\tinfo.type = CONNECT_HIT;\n\tinfo.hit_next_htbl = curr_nic_matcher->s_htbl;\n\tret = mlx5dr_ste_htbl_init_and_postsend(dmn, nic_dmn, prev_htbl,\n\t\t\t\t\t\t&info, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcurr_nic_matcher->s_htbl->pointing_ste = prev_htbl->chunk->ste_arr;\n\tprev_htbl->chunk->ste_arr[0].next_htbl = curr_nic_matcher->s_htbl;\n\n\tif (next_nic_matcher) {\n\t\tnext_nic_matcher->s_htbl->pointing_ste =\n\t\t\tcurr_nic_matcher->e_anchor->chunk->ste_arr;\n\t\tcurr_nic_matcher->e_anchor->chunk->ste_arr[0].next_htbl =\n\t\t\tnext_nic_matcher->s_htbl;\n\t}\n\n\treturn 0;\n}\n\nint mlx5dr_matcher_add_to_tbl_nic(struct mlx5dr_domain *dmn,\n\t\t\t\t  struct mlx5dr_matcher_rx_tx *nic_matcher)\n{\n\tstruct mlx5dr_matcher_rx_tx *next_nic_matcher, *prev_nic_matcher, *tmp_nic_matcher;\n\tstruct mlx5dr_table_rx_tx *nic_tbl = nic_matcher->nic_tbl;\n\tbool first = true;\n\tint ret;\n\n\t \n\tif (!list_empty(&nic_matcher->list_node))\n\t\treturn 0;\n\n\tnext_nic_matcher = NULL;\n\tlist_for_each_entry(tmp_nic_matcher, &nic_tbl->nic_matcher_list, list_node) {\n\t\tif (tmp_nic_matcher->prio >= nic_matcher->prio) {\n\t\t\tnext_nic_matcher = tmp_nic_matcher;\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t}\n\n\tprev_nic_matcher = NULL;\n\tif (next_nic_matcher && !first)\n\t\tprev_nic_matcher = list_prev_entry(next_nic_matcher, list_node);\n\telse if (!first)\n\t\tprev_nic_matcher = list_last_entry(&nic_tbl->nic_matcher_list,\n\t\t\t\t\t\t   struct mlx5dr_matcher_rx_tx,\n\t\t\t\t\t\t   list_node);\n\n\tret = dr_nic_matcher_connect(dmn, nic_matcher,\n\t\t\t\t     next_nic_matcher, prev_nic_matcher);\n\tif (ret)\n\t\treturn ret;\n\n\tif (prev_nic_matcher)\n\t\tlist_add(&nic_matcher->list_node, &prev_nic_matcher->list_node);\n\telse if (next_nic_matcher)\n\t\tlist_add_tail(&nic_matcher->list_node, &next_nic_matcher->list_node);\n\telse\n\t\tlist_add(&nic_matcher->list_node, &nic_matcher->nic_tbl->nic_matcher_list);\n\n\treturn ret;\n}\n\nstatic void dr_matcher_uninit_nic(struct mlx5dr_matcher_rx_tx *nic_matcher)\n{\n\tmlx5dr_htbl_put(nic_matcher->s_htbl);\n\tmlx5dr_htbl_put(nic_matcher->e_anchor);\n}\n\nstatic void dr_matcher_uninit_fdb(struct mlx5dr_matcher *matcher)\n{\n\tdr_matcher_uninit_nic(&matcher->rx);\n\tdr_matcher_uninit_nic(&matcher->tx);\n}\n\nstatic void dr_matcher_uninit(struct mlx5dr_matcher *matcher)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\n\tswitch (dmn->type) {\n\tcase MLX5DR_DOMAIN_TYPE_NIC_RX:\n\t\tdr_matcher_uninit_nic(&matcher->rx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_NIC_TX:\n\t\tdr_matcher_uninit_nic(&matcher->tx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_FDB:\n\t\tdr_matcher_uninit_fdb(matcher);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t\tbreak;\n\t}\n}\n\nstatic int dr_matcher_set_all_ste_builders(struct mlx5dr_matcher *matcher,\n\t\t\t\t\t   struct mlx5dr_matcher_rx_tx *nic_matcher)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\n\tdr_matcher_set_ste_builders(matcher, nic_matcher, DR_RULE_IPV4, DR_RULE_IPV4);\n\tdr_matcher_set_ste_builders(matcher, nic_matcher, DR_RULE_IPV4, DR_RULE_IPV6);\n\tdr_matcher_set_ste_builders(matcher, nic_matcher, DR_RULE_IPV6, DR_RULE_IPV4);\n\tdr_matcher_set_ste_builders(matcher, nic_matcher, DR_RULE_IPV6, DR_RULE_IPV6);\n\n\tif (!nic_matcher->ste_builder) {\n\t\tmlx5dr_err(dmn, \"Cannot generate IPv4 or IPv6 rules with given mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dr_matcher_init_nic(struct mlx5dr_matcher *matcher,\n\t\t\t       struct mlx5dr_matcher_rx_tx *nic_matcher)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tint ret;\n\n\tnic_matcher->prio = matcher->prio;\n\tINIT_LIST_HEAD(&nic_matcher->list_node);\n\n\tret = dr_matcher_set_all_ste_builders(matcher, nic_matcher);\n\tif (ret)\n\t\treturn ret;\n\n\tnic_matcher->e_anchor = mlx5dr_ste_htbl_alloc(dmn->ste_icm_pool,\n\t\t\t\t\t\t      DR_CHUNK_SIZE_1,\n\t\t\t\t\t\t      MLX5DR_STE_LU_TYPE_DONT_CARE,\n\t\t\t\t\t\t      0);\n\tif (!nic_matcher->e_anchor)\n\t\treturn -ENOMEM;\n\n\tnic_matcher->s_htbl = mlx5dr_ste_htbl_alloc(dmn->ste_icm_pool,\n\t\t\t\t\t\t    DR_CHUNK_SIZE_1,\n\t\t\t\t\t\t    nic_matcher->ste_builder[0].lu_type,\n\t\t\t\t\t\t    nic_matcher->ste_builder[0].byte_mask);\n\tif (!nic_matcher->s_htbl) {\n\t\tret = -ENOMEM;\n\t\tgoto free_e_htbl;\n\t}\n\n\t \n\tmlx5dr_htbl_get(nic_matcher->s_htbl);\n\tmlx5dr_htbl_get(nic_matcher->e_anchor);\n\n\treturn 0;\n\nfree_e_htbl:\n\tmlx5dr_ste_htbl_free(nic_matcher->e_anchor);\n\treturn ret;\n}\n\nstatic int dr_matcher_init_fdb(struct mlx5dr_matcher *matcher)\n{\n\tint ret;\n\n\tret = dr_matcher_init_nic(matcher, &matcher->rx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dr_matcher_init_nic(matcher, &matcher->tx);\n\tif (ret)\n\t\tgoto uninit_nic_rx;\n\n\treturn 0;\n\nuninit_nic_rx:\n\tdr_matcher_uninit_nic(&matcher->rx);\n\treturn ret;\n}\n\nstatic int dr_matcher_copy_param(struct mlx5dr_matcher *matcher,\n\t\t\t\t struct mlx5dr_match_parameters *mask)\n{\n\tstruct mlx5dr_domain *dmn = matcher->tbl->dmn;\n\tstruct mlx5dr_match_parameters consumed_mask;\n\tint i, ret = 0;\n\n\tif (matcher->match_criteria >= DR_MATCHER_CRITERIA_MAX) {\n\t\tmlx5dr_err(dmn, \"Invalid match criteria attribute\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mask) {\n\t\tif (mask->match_sz > DR_SZ_MATCH_PARAM) {\n\t\t\tmlx5dr_err(dmn, \"Invalid match size attribute\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tconsumed_mask.match_buf = kzalloc(mask->match_sz, GFP_KERNEL);\n\t\tif (!consumed_mask.match_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tconsumed_mask.match_sz = mask->match_sz;\n\t\tmemcpy(consumed_mask.match_buf, mask->match_buf, mask->match_sz);\n\t\tmlx5dr_ste_copy_param(matcher->match_criteria,\n\t\t\t\t      &matcher->mask, &consumed_mask, true);\n\n\t\t \n\t\tfor (i = 0; i < consumed_mask.match_sz; i++) {\n\t\t\tif (!((u8 *)consumed_mask.match_buf)[i])\n\t\t\t\tcontinue;\n\n\t\t\tmlx5dr_dbg(dmn,\n\t\t\t\t   \"Match param mask contains unsupported parameters\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(consumed_mask.match_buf);\n\t}\n\n\treturn ret;\n}\n\nstatic int dr_matcher_init(struct mlx5dr_matcher *matcher,\n\t\t\t   struct mlx5dr_match_parameters *mask)\n{\n\tstruct mlx5dr_table *tbl = matcher->tbl;\n\tstruct mlx5dr_domain *dmn = tbl->dmn;\n\tint ret;\n\n\tret = dr_matcher_copy_param(matcher, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (dmn->type) {\n\tcase MLX5DR_DOMAIN_TYPE_NIC_RX:\n\t\tmatcher->rx.nic_tbl = &tbl->rx;\n\t\tret = dr_matcher_init_nic(matcher, &matcher->rx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_NIC_TX:\n\t\tmatcher->tx.nic_tbl = &tbl->tx;\n\t\tret = dr_matcher_init_nic(matcher, &matcher->tx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_FDB:\n\t\tmatcher->rx.nic_tbl = &tbl->rx;\n\t\tmatcher->tx.nic_tbl = &tbl->tx;\n\t\tret = dr_matcher_init_fdb(matcher);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void dr_matcher_add_to_dbg_list(struct mlx5dr_matcher *matcher)\n{\n\tmutex_lock(&matcher->tbl->dmn->dump_info.dbg_mutex);\n\tlist_add(&matcher->list_node, &matcher->tbl->matcher_list);\n\tmutex_unlock(&matcher->tbl->dmn->dump_info.dbg_mutex);\n}\n\nstatic void dr_matcher_remove_from_dbg_list(struct mlx5dr_matcher *matcher)\n{\n\tmutex_lock(&matcher->tbl->dmn->dump_info.dbg_mutex);\n\tlist_del(&matcher->list_node);\n\tmutex_unlock(&matcher->tbl->dmn->dump_info.dbg_mutex);\n}\n\nstruct mlx5dr_matcher *\nmlx5dr_matcher_create(struct mlx5dr_table *tbl,\n\t\t      u32 priority,\n\t\t      u8 match_criteria_enable,\n\t\t      struct mlx5dr_match_parameters *mask)\n{\n\tstruct mlx5dr_matcher *matcher;\n\tint ret;\n\n\trefcount_inc(&tbl->refcount);\n\n\tmatcher = kzalloc(sizeof(*matcher), GFP_KERNEL);\n\tif (!matcher)\n\t\tgoto dec_ref;\n\n\tmatcher->tbl = tbl;\n\tmatcher->prio = priority;\n\tmatcher->match_criteria = match_criteria_enable;\n\trefcount_set(&matcher->refcount, 1);\n\tINIT_LIST_HEAD(&matcher->list_node);\n\tINIT_LIST_HEAD(&matcher->dbg_rule_list);\n\n\tmlx5dr_domain_lock(tbl->dmn);\n\n\tret = dr_matcher_init(matcher, mask);\n\tif (ret)\n\t\tgoto free_matcher;\n\n\tdr_matcher_add_to_dbg_list(matcher);\n\n\tmlx5dr_domain_unlock(tbl->dmn);\n\n\treturn matcher;\n\nfree_matcher:\n\tmlx5dr_domain_unlock(tbl->dmn);\n\tkfree(matcher);\ndec_ref:\n\trefcount_dec(&tbl->refcount);\n\treturn NULL;\n}\n\nstatic int dr_matcher_disconnect_nic(struct mlx5dr_domain *dmn,\n\t\t\t\t     struct mlx5dr_table_rx_tx *nic_tbl,\n\t\t\t\t     struct mlx5dr_matcher_rx_tx *next_nic_matcher,\n\t\t\t\t     struct mlx5dr_matcher_rx_tx *prev_nic_matcher)\n{\n\tstruct mlx5dr_domain_rx_tx *nic_dmn = nic_tbl->nic_dmn;\n\tstruct mlx5dr_htbl_connect_info info;\n\tstruct mlx5dr_ste_htbl *prev_anchor;\n\n\tif (prev_nic_matcher)\n\t\tprev_anchor = prev_nic_matcher->e_anchor;\n\telse\n\t\tprev_anchor = nic_tbl->s_anchor;\n\n\t \n\tif (next_nic_matcher) {\n\t\tinfo.type = CONNECT_HIT;\n\t\tinfo.hit_next_htbl = next_nic_matcher->s_htbl;\n\t\tnext_nic_matcher->s_htbl->pointing_ste = prev_anchor->chunk->ste_arr;\n\t\tprev_anchor->chunk->ste_arr[0].next_htbl = next_nic_matcher->s_htbl;\n\t} else {\n\t\tinfo.type = CONNECT_MISS;\n\t\tinfo.miss_icm_addr = nic_tbl->default_icm_addr;\n\t\tprev_anchor->chunk->ste_arr[0].next_htbl = NULL;\n\t}\n\n\treturn mlx5dr_ste_htbl_init_and_postsend(dmn, nic_dmn, prev_anchor,\n\t\t\t\t\t\t &info, true);\n}\n\nint mlx5dr_matcher_remove_from_tbl_nic(struct mlx5dr_domain *dmn,\n\t\t\t\t       struct mlx5dr_matcher_rx_tx *nic_matcher)\n{\n\tstruct mlx5dr_matcher_rx_tx *prev_nic_matcher, *next_nic_matcher;\n\tstruct mlx5dr_table_rx_tx *nic_tbl = nic_matcher->nic_tbl;\n\tint ret;\n\n\t \n\tif (list_empty(&nic_matcher->list_node))\n\t\treturn 0;\n\n\tif (list_is_last(&nic_matcher->list_node, &nic_tbl->nic_matcher_list))\n\t\tnext_nic_matcher = NULL;\n\telse\n\t\tnext_nic_matcher = list_next_entry(nic_matcher, list_node);\n\n\tif (nic_matcher->list_node.prev == &nic_tbl->nic_matcher_list)\n\t\tprev_nic_matcher = NULL;\n\telse\n\t\tprev_nic_matcher = list_prev_entry(nic_matcher, list_node);\n\n\tret = dr_matcher_disconnect_nic(dmn, nic_tbl, next_nic_matcher, prev_nic_matcher);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del_init(&nic_matcher->list_node);\n\treturn 0;\n}\n\nint mlx5dr_matcher_destroy(struct mlx5dr_matcher *matcher)\n{\n\tstruct mlx5dr_table *tbl = matcher->tbl;\n\n\tif (WARN_ON_ONCE(refcount_read(&matcher->refcount) > 1))\n\t\treturn -EBUSY;\n\n\tmlx5dr_domain_lock(tbl->dmn);\n\n\tdr_matcher_remove_from_dbg_list(matcher);\n\tdr_matcher_uninit(matcher);\n\trefcount_dec(&matcher->tbl->refcount);\n\n\tmlx5dr_domain_unlock(tbl->dmn);\n\tkfree(matcher);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}