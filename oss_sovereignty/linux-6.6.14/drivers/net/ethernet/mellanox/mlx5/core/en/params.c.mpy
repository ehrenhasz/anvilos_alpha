{
  "module_name": "params.c",
  "hash_id": "217c2398db951d40ca1fff83c20763b4553dfd2a98653ea16b4b1b0c116ccba1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/params.c",
  "human_readable_source": "\n \n\n#include \"en/params.h\"\n#include \"en/txrx.h\"\n#include \"en/port.h\"\n#include \"en_accel/en_accel.h\"\n#include \"en_accel/ipsec.h\"\n#include <net/page_pool/types.h>\n#include <net/xdp_sock_drv.h>\n\nstatic u8 mlx5e_mpwrq_min_page_shift(struct mlx5_core_dev *mdev)\n{\n\tu8 min_page_shift = MLX5_CAP_GEN_2(mdev, log_min_mkey_entity_size);\n\n\treturn min_page_shift ? : 12;\n}\n\nu8 mlx5e_mpwrq_page_shift(struct mlx5_core_dev *mdev, struct mlx5e_xsk_param *xsk)\n{\n\tu8 req_page_shift = xsk ? order_base_2(xsk->chunk_size) : PAGE_SHIFT;\n\tu8 min_page_shift = mlx5e_mpwrq_min_page_shift(mdev);\n\n\t \n\tif (WARN_ON_ONCE(!xsk && req_page_shift < min_page_shift))\n\t\tmin_page_shift = req_page_shift;\n\n\treturn max(req_page_shift, min_page_shift);\n}\n\nenum mlx5e_mpwrq_umr_mode\nmlx5e_mpwrq_umr_mode(struct mlx5_core_dev *mdev, struct mlx5e_xsk_param *xsk)\n{\n\t \n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\tbool unaligned = xsk ? xsk->unaligned : false;\n\tbool oversized = false;\n\n\tif (xsk) {\n\t\toversized = xsk->chunk_size < (1 << page_shift);\n\t\tWARN_ON_ONCE(xsk->chunk_size > (1 << page_shift));\n\t}\n\n\t \n\tif (oversized) {\n\t\t \n\t\tif (xsk->chunk_size % 3 == 0 && is_power_of_2(xsk->chunk_size / 3))\n\t\t\treturn MLX5E_MPWRQ_UMR_MODE_TRIPLE;\n\n\t\treturn MLX5E_MPWRQ_UMR_MODE_OVERSIZED;\n\t}\n\n\t \n\tif (unaligned)\n\t\treturn MLX5E_MPWRQ_UMR_MODE_UNALIGNED;\n\n\t \n\treturn MLX5E_MPWRQ_UMR_MODE_ALIGNED;\n}\n\nu8 mlx5e_mpwrq_umr_entry_size(enum mlx5e_mpwrq_umr_mode mode)\n{\n\tswitch (mode) {\n\tcase MLX5E_MPWRQ_UMR_MODE_ALIGNED:\n\t\treturn sizeof(struct mlx5_mtt);\n\tcase MLX5E_MPWRQ_UMR_MODE_UNALIGNED:\n\t\treturn sizeof(struct mlx5_ksm);\n\tcase MLX5E_MPWRQ_UMR_MODE_OVERSIZED:\n\t\treturn sizeof(struct mlx5_klm) * 2;\n\tcase MLX5E_MPWRQ_UMR_MODE_TRIPLE:\n\t\treturn sizeof(struct mlx5_ksm) * 4;\n\t}\n\tWARN_ONCE(1, \"MPWRQ UMR mode %d is not known\\n\", mode);\n\treturn 0;\n}\n\nu8 mlx5e_mpwrq_log_wqe_sz(struct mlx5_core_dev *mdev, u8 page_shift,\n\t\t\t  enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\tu8 umr_entry_size = mlx5e_mpwrq_umr_entry_size(umr_mode);\n\tu8 max_pages_per_wqe, max_log_mpwqe_size;\n\tu16 max_wqe_size;\n\n\t \n\tmax_wqe_size = mlx5e_get_max_sq_aligned_wqebbs(mdev) * MLX5_SEND_WQE_BB;\n\tmax_pages_per_wqe = ALIGN_DOWN(max_wqe_size - sizeof(struct mlx5e_umr_wqe),\n\t\t\t\t       MLX5_UMR_FLEX_ALIGNMENT) / umr_entry_size;\n\tmax_log_mpwqe_size = ilog2(max_pages_per_wqe) + page_shift;\n\n\tWARN_ON_ONCE(max_log_mpwqe_size < MLX5E_ORDER2_MAX_PACKET_MTU);\n\n\treturn min_t(u8, max_log_mpwqe_size, MLX5_MPWRQ_MAX_LOG_WQE_SZ);\n}\n\nu8 mlx5e_mpwrq_pages_per_wqe(struct mlx5_core_dev *mdev, u8 page_shift,\n\t\t\t     enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\tu8 log_wqe_sz = mlx5e_mpwrq_log_wqe_sz(mdev, page_shift, umr_mode);\n\tu8 pages_per_wqe;\n\n\tpages_per_wqe = log_wqe_sz > page_shift ? (1 << (log_wqe_sz - page_shift)) : 1;\n\n\t \n\tif (WARN_ON_ONCE(pages_per_wqe < 2 && umr_mode == MLX5E_MPWRQ_UMR_MODE_ALIGNED))\n\t\tpages_per_wqe = 2;\n\n\t \n\tBUILD_BUG_ON(MLX5_MPWRQ_MAX_PAGES_PER_WQE > 64);\n\tif (WARN_ON_ONCE(pages_per_wqe > MLX5_MPWRQ_MAX_PAGES_PER_WQE))\n\t\treturn MLX5_MPWRQ_MAX_PAGES_PER_WQE;\n\n\treturn pages_per_wqe;\n}\n\nu16 mlx5e_mpwrq_umr_wqe_sz(struct mlx5_core_dev *mdev, u8 page_shift,\n\t\t\t   enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\tu8 pages_per_wqe = mlx5e_mpwrq_pages_per_wqe(mdev, page_shift, umr_mode);\n\tu8 umr_entry_size = mlx5e_mpwrq_umr_entry_size(umr_mode);\n\tu16 umr_wqe_sz;\n\n\tumr_wqe_sz = sizeof(struct mlx5e_umr_wqe) +\n\t\tALIGN(pages_per_wqe * umr_entry_size, MLX5_UMR_FLEX_ALIGNMENT);\n\n\tWARN_ON_ONCE(DIV_ROUND_UP(umr_wqe_sz, MLX5_SEND_WQE_DS) > MLX5_WQE_CTRL_DS_MASK);\n\n\treturn umr_wqe_sz;\n}\n\nu8 mlx5e_mpwrq_umr_wqebbs(struct mlx5_core_dev *mdev, u8 page_shift,\n\t\t\t  enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\treturn DIV_ROUND_UP(mlx5e_mpwrq_umr_wqe_sz(mdev, page_shift, umr_mode),\n\t\t\t    MLX5_SEND_WQE_BB);\n}\n\nu8 mlx5e_mpwrq_mtts_per_wqe(struct mlx5_core_dev *mdev, u8 page_shift,\n\t\t\t    enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\tu8 pages_per_wqe = mlx5e_mpwrq_pages_per_wqe(mdev, page_shift, umr_mode);\n\n\t \n\treturn ALIGN(pages_per_wqe + 1,\n\t\t     MLX5_SEND_WQE_BB / mlx5e_mpwrq_umr_entry_size(umr_mode));\n}\n\nu32 mlx5e_mpwrq_max_num_entries(struct mlx5_core_dev *mdev,\n\t\t\t\tenum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\t \n\tu32 klm_limit = min(MLX5E_MAX_RQ_NUM_KSMS,\n\t\t\t    1 << MLX5_CAP_GEN(mdev, log_max_klm_list_size));\n\n\tswitch (umr_mode) {\n\tcase MLX5E_MPWRQ_UMR_MODE_ALIGNED:\n\t\treturn MLX5E_MAX_RQ_NUM_MTTS;\n\tcase MLX5E_MPWRQ_UMR_MODE_UNALIGNED:\n\t\treturn klm_limit;\n\tcase MLX5E_MPWRQ_UMR_MODE_OVERSIZED:\n\t\t \n\t\treturn klm_limit / 2;\n\tcase MLX5E_MPWRQ_UMR_MODE_TRIPLE:\n\t\t \n\t\treturn klm_limit / 4;\n\t}\n\tWARN_ONCE(1, \"MPWRQ UMR mode %d is not known\\n\", umr_mode);\n\treturn 0;\n}\n\nstatic u8 mlx5e_mpwrq_max_log_rq_size(struct mlx5_core_dev *mdev, u8 page_shift,\n\t\t\t\t      enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\tu8 mtts_per_wqe = mlx5e_mpwrq_mtts_per_wqe(mdev, page_shift, umr_mode);\n\tu32 max_entries = mlx5e_mpwrq_max_num_entries(mdev, umr_mode);\n\n\treturn ilog2(max_entries / mtts_per_wqe);\n}\n\nu8 mlx5e_mpwrq_max_log_rq_pkts(struct mlx5_core_dev *mdev, u8 page_shift,\n\t\t\t       enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\treturn mlx5e_mpwrq_max_log_rq_size(mdev, page_shift, umr_mode) +\n\t\tmlx5e_mpwrq_log_wqe_sz(mdev, page_shift, umr_mode) -\n\t\tMLX5E_ORDER2_MAX_PACKET_MTU;\n}\n\nu16 mlx5e_get_linear_rq_headroom(struct mlx5e_params *params,\n\t\t\t\t struct mlx5e_xsk_param *xsk)\n{\n\tu16 headroom;\n\n\tif (xsk)\n\t\treturn xsk->headroom;\n\n\theadroom = NET_IP_ALIGN;\n\tif (params->xdp_prog)\n\t\theadroom += XDP_PACKET_HEADROOM;\n\telse\n\t\theadroom += MLX5_RX_HEADROOM;\n\n\treturn headroom;\n}\n\nstatic u32 mlx5e_rx_get_linear_sz_xsk(struct mlx5e_params *params,\n\t\t\t\t      struct mlx5e_xsk_param *xsk)\n{\n\tu32 hw_mtu = MLX5E_SW2HW_MTU(params, params->sw_mtu);\n\n\treturn xsk->headroom + hw_mtu;\n}\n\nstatic u32 mlx5e_rx_get_linear_sz_skb(struct mlx5e_params *params, bool xsk)\n{\n\t \n\tu16 headroom = xsk ? 0 : mlx5e_get_linear_rq_headroom(params, NULL);\n\tu32 hw_mtu = MLX5E_SW2HW_MTU(params, params->sw_mtu);\n\n\treturn MLX5_SKB_FRAG_SZ(headroom + hw_mtu);\n}\n\nstatic u32 mlx5e_rx_get_linear_stride_sz(struct mlx5_core_dev *mdev,\n\t\t\t\t\t struct mlx5e_params *params,\n\t\t\t\t\t struct mlx5e_xsk_param *xsk,\n\t\t\t\t\t bool mpwqe)\n{\n\tu32 sz;\n\n\t \n\tif (xsk)\n\t\treturn mpwqe ? 1 << mlx5e_mpwrq_page_shift(mdev, xsk) : PAGE_SIZE;\n\n\tsz = roundup_pow_of_two(mlx5e_rx_get_linear_sz_skb(params, false));\n\n\t \n\treturn params->xdp_prog && sz < PAGE_SIZE ? PAGE_SIZE : sz;\n}\n\nstatic u8 mlx5e_mpwqe_log_pkts_per_wqe(struct mlx5_core_dev *mdev,\n\t\t\t\t       struct mlx5e_params *params,\n\t\t\t\t       struct mlx5e_xsk_param *xsk)\n{\n\tu32 linear_stride_sz = mlx5e_rx_get_linear_stride_sz(mdev, params, xsk, true);\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\n\treturn mlx5e_mpwrq_log_wqe_sz(mdev, page_shift, umr_mode) -\n\t\torder_base_2(linear_stride_sz);\n}\n\nbool mlx5e_rx_is_linear_skb(struct mlx5_core_dev *mdev,\n\t\t\t    struct mlx5e_params *params,\n\t\t\t    struct mlx5e_xsk_param *xsk)\n{\n\tif (params->packet_merge.type != MLX5E_PACKET_MERGE_NONE)\n\t\treturn false;\n\n\t \n\tif (mlx5e_rx_get_linear_sz_skb(params, xsk) > PAGE_SIZE)\n\t\treturn false;\n\n\t \n\tif (xsk && mlx5e_rx_get_linear_sz_xsk(params, xsk) > xsk->chunk_size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool mlx5e_verify_rx_mpwqe_strides(struct mlx5_core_dev *mdev,\n\t\t\t\t\t  u8 log_stride_sz, u8 log_num_strides,\n\t\t\t\t\t  u8 page_shift,\n\t\t\t\t\t  enum mlx5e_mpwrq_umr_mode umr_mode)\n{\n\tif (log_stride_sz + log_num_strides !=\n\t    mlx5e_mpwrq_log_wqe_sz(mdev, page_shift, umr_mode))\n\t\treturn false;\n\n\tif (log_stride_sz < MLX5_MPWQE_LOG_STRIDE_SZ_BASE ||\n\t    log_stride_sz > MLX5_MPWQE_LOG_STRIDE_SZ_MAX)\n\t\treturn false;\n\n\tif (log_num_strides > MLX5_MPWQE_LOG_NUM_STRIDES_MAX)\n\t\treturn false;\n\n\tif (MLX5_CAP_GEN(mdev, ext_stride_num_range))\n\t\treturn log_num_strides >= MLX5_MPWQE_LOG_NUM_STRIDES_EXT_BASE;\n\n\treturn log_num_strides >= MLX5_MPWQE_LOG_NUM_STRIDES_BASE;\n}\n\nbool mlx5e_verify_params_rx_mpwqe_strides(struct mlx5_core_dev *mdev,\n\t\t\t\t\t  struct mlx5e_params *params,\n\t\t\t\t\t  struct mlx5e_xsk_param *xsk)\n{\n\tu8 log_wqe_num_of_strides = mlx5e_mpwqe_get_log_num_strides(mdev, params, xsk);\n\tu8 log_wqe_stride_size = mlx5e_mpwqe_get_log_stride_size(mdev, params, xsk);\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\n\treturn mlx5e_verify_rx_mpwqe_strides(mdev, log_wqe_stride_size,\n\t\t\t\t\t     log_wqe_num_of_strides,\n\t\t\t\t\t     page_shift, umr_mode);\n}\n\nbool mlx5e_rx_mpwqe_is_linear_skb(struct mlx5_core_dev *mdev,\n\t\t\t\t  struct mlx5e_params *params,\n\t\t\t\t  struct mlx5e_xsk_param *xsk)\n{\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\tu8 log_num_strides;\n\tu8 log_stride_sz;\n\tu8 log_wqe_sz;\n\n\tif (!mlx5e_rx_is_linear_skb(mdev, params, xsk))\n\t\treturn false;\n\n\tlog_stride_sz = order_base_2(mlx5e_rx_get_linear_stride_sz(mdev, params, xsk, true));\n\tlog_wqe_sz = mlx5e_mpwrq_log_wqe_sz(mdev, page_shift, umr_mode);\n\n\tif (log_wqe_sz < log_stride_sz)\n\t\treturn false;\n\n\tlog_num_strides = log_wqe_sz - log_stride_sz;\n\n\treturn mlx5e_verify_rx_mpwqe_strides(mdev, log_stride_sz,\n\t\t\t\t\t     log_num_strides, page_shift,\n\t\t\t\t\t     umr_mode);\n}\n\nu8 mlx5e_mpwqe_get_log_rq_size(struct mlx5_core_dev *mdev,\n\t\t\t       struct mlx5e_params *params,\n\t\t\t       struct mlx5e_xsk_param *xsk)\n{\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\tu8 log_pkts_per_wqe, page_shift, max_log_rq_size;\n\n\tlog_pkts_per_wqe = mlx5e_mpwqe_log_pkts_per_wqe(mdev, params, xsk);\n\tpage_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\tmax_log_rq_size = mlx5e_mpwrq_max_log_rq_size(mdev, page_shift, umr_mode);\n\n\t \n\tif (params->log_rq_mtu_frames <\n\t    log_pkts_per_wqe + MLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE_MPW)\n\t\treturn MLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE_MPW;\n\n\t \n\tif (WARN_ON_ONCE(params->log_rq_mtu_frames > log_pkts_per_wqe + max_log_rq_size))\n\t\treturn max_log_rq_size;\n\n\treturn params->log_rq_mtu_frames - log_pkts_per_wqe;\n}\n\nu8 mlx5e_shampo_get_log_hd_entry_size(struct mlx5_core_dev *mdev,\n\t\t\t\t      struct mlx5e_params *params)\n{\n\treturn order_base_2(DIV_ROUND_UP(MLX5E_RX_MAX_HEAD, MLX5E_SHAMPO_WQ_BASE_HEAD_ENTRY_SIZE));\n}\n\nu8 mlx5e_shampo_get_log_rsrv_size(struct mlx5_core_dev *mdev,\n\t\t\t\t  struct mlx5e_params *params)\n{\n\treturn order_base_2(MLX5E_SHAMPO_WQ_RESRV_SIZE / MLX5E_SHAMPO_WQ_BASE_RESRV_SIZE);\n}\n\nu8 mlx5e_shampo_get_log_pkt_per_rsrv(struct mlx5_core_dev *mdev,\n\t\t\t\t     struct mlx5e_params *params)\n{\n\tu32 resrv_size = BIT(mlx5e_shampo_get_log_rsrv_size(mdev, params)) *\n\t\t\t PAGE_SIZE;\n\n\treturn order_base_2(DIV_ROUND_UP(resrv_size, params->sw_mtu));\n}\n\nu8 mlx5e_mpwqe_get_log_stride_size(struct mlx5_core_dev *mdev,\n\t\t\t\t   struct mlx5e_params *params,\n\t\t\t\t   struct mlx5e_xsk_param *xsk)\n{\n\tif (mlx5e_rx_mpwqe_is_linear_skb(mdev, params, xsk))\n\t\treturn order_base_2(mlx5e_rx_get_linear_stride_sz(mdev, params, xsk, true));\n\n\t \n\tif (params->xdp_prog)\n\t\treturn PAGE_SHIFT;\n\n\treturn MLX5_MPWRQ_DEF_LOG_STRIDE_SZ(mdev);\n}\n\nu8 mlx5e_mpwqe_get_log_num_strides(struct mlx5_core_dev *mdev,\n\t\t\t\t   struct mlx5e_params *params,\n\t\t\t\t   struct mlx5e_xsk_param *xsk)\n{\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\tu8 log_wqe_size, log_stride_size;\n\n\tlog_wqe_size = mlx5e_mpwrq_log_wqe_sz(mdev, page_shift, umr_mode);\n\tlog_stride_size = mlx5e_mpwqe_get_log_stride_size(mdev, params, xsk);\n\tWARN(log_wqe_size < log_stride_size,\n\t     \"Log WQE size %u < log stride size %u (page shift %u, umr mode %d, xsk on? %d)\\n\",\n\t     log_wqe_size, log_stride_size, page_shift, umr_mode, !!xsk);\n\treturn log_wqe_size - log_stride_size;\n}\n\nu8 mlx5e_mpwqe_get_min_wqe_bulk(unsigned int wq_sz)\n{\n#define UMR_WQE_BULK (2)\n\treturn min_t(unsigned int, UMR_WQE_BULK, wq_sz / 2 - 1);\n}\n\nu16 mlx5e_get_rq_headroom(struct mlx5_core_dev *mdev,\n\t\t\t  struct mlx5e_params *params,\n\t\t\t  struct mlx5e_xsk_param *xsk)\n{\n\tu16 linear_headroom = mlx5e_get_linear_rq_headroom(params, xsk);\n\n\tif (params->rq_wq_type == MLX5_WQ_TYPE_CYCLIC)\n\t\treturn linear_headroom;\n\n\tif (mlx5e_rx_mpwqe_is_linear_skb(mdev, params, xsk))\n\t\treturn linear_headroom;\n\n\tif (params->packet_merge.type == MLX5E_PACKET_MERGE_SHAMPO)\n\t\treturn linear_headroom;\n\n\treturn 0;\n}\n\nu16 mlx5e_calc_sq_stop_room(struct mlx5_core_dev *mdev, struct mlx5e_params *params)\n{\n\tbool is_mpwqe = MLX5E_GET_PFLAG(params, MLX5E_PFLAG_SKB_TX_MPWQE);\n\tu16 stop_room;\n\n\tstop_room  = mlx5e_ktls_get_stop_room(mdev, params);\n\tstop_room += mlx5e_stop_room_for_max_wqe(mdev);\n\tif (is_mpwqe)\n\t\t \n\t\tstop_room += mlx5e_stop_room_for_mpwqe(mdev);\n\n\treturn stop_room;\n}\n\nint mlx5e_validate_params(struct mlx5_core_dev *mdev, struct mlx5e_params *params)\n{\n\tsize_t sq_size = 1 << params->log_sq_size;\n\tu16 stop_room;\n\n\tstop_room = mlx5e_calc_sq_stop_room(mdev, params);\n\tif (stop_room >= sq_size) {\n\t\tmlx5_core_err(mdev, \"Stop room %u is bigger than the SQ size %zu\\n\",\n\t\t\t      stop_room, sq_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dim_cq_moder mlx5e_get_def_tx_moderation(u8 cq_period_mode)\n{\n\tstruct dim_cq_moder moder = {};\n\n\tmoder.cq_period_mode = cq_period_mode;\n\tmoder.pkts = MLX5E_PARAMS_DEFAULT_TX_CQ_MODERATION_PKTS;\n\tmoder.usec = MLX5E_PARAMS_DEFAULT_TX_CQ_MODERATION_USEC;\n\tif (cq_period_mode == MLX5_CQ_PERIOD_MODE_START_FROM_CQE)\n\t\tmoder.usec = MLX5E_PARAMS_DEFAULT_TX_CQ_MODERATION_USEC_FROM_CQE;\n\n\treturn moder;\n}\n\nstatic struct dim_cq_moder mlx5e_get_def_rx_moderation(u8 cq_period_mode)\n{\n\tstruct dim_cq_moder moder = {};\n\n\tmoder.cq_period_mode = cq_period_mode;\n\tmoder.pkts = MLX5E_PARAMS_DEFAULT_RX_CQ_MODERATION_PKTS;\n\tmoder.usec = MLX5E_PARAMS_DEFAULT_RX_CQ_MODERATION_USEC;\n\tif (cq_period_mode == MLX5_CQ_PERIOD_MODE_START_FROM_CQE)\n\t\tmoder.usec = MLX5E_PARAMS_DEFAULT_RX_CQ_MODERATION_USEC_FROM_CQE;\n\n\treturn moder;\n}\n\nstatic u8 mlx5_to_net_dim_cq_period_mode(u8 cq_period_mode)\n{\n\treturn cq_period_mode == MLX5_CQ_PERIOD_MODE_START_FROM_CQE ?\n\t\tDIM_CQ_PERIOD_MODE_START_FROM_CQE :\n\t\tDIM_CQ_PERIOD_MODE_START_FROM_EQE;\n}\n\nvoid mlx5e_reset_tx_moderation(struct mlx5e_params *params, u8 cq_period_mode)\n{\n\tif (params->tx_dim_enabled) {\n\t\tu8 dim_period_mode = mlx5_to_net_dim_cq_period_mode(cq_period_mode);\n\n\t\tparams->tx_cq_moderation = net_dim_get_def_tx_moderation(dim_period_mode);\n\t} else {\n\t\tparams->tx_cq_moderation = mlx5e_get_def_tx_moderation(cq_period_mode);\n\t}\n}\n\nvoid mlx5e_reset_rx_moderation(struct mlx5e_params *params, u8 cq_period_mode)\n{\n\tif (params->rx_dim_enabled) {\n\t\tu8 dim_period_mode = mlx5_to_net_dim_cq_period_mode(cq_period_mode);\n\n\t\tparams->rx_cq_moderation = net_dim_get_def_rx_moderation(dim_period_mode);\n\t} else {\n\t\tparams->rx_cq_moderation = mlx5e_get_def_rx_moderation(cq_period_mode);\n\t}\n}\n\nvoid mlx5e_set_tx_cq_mode_params(struct mlx5e_params *params, u8 cq_period_mode)\n{\n\tmlx5e_reset_tx_moderation(params, cq_period_mode);\n\tMLX5E_SET_PFLAG(params, MLX5E_PFLAG_TX_CQE_BASED_MODER,\n\t\t\tparams->tx_cq_moderation.cq_period_mode ==\n\t\t\t\tMLX5_CQ_PERIOD_MODE_START_FROM_CQE);\n}\n\nvoid mlx5e_set_rx_cq_mode_params(struct mlx5e_params *params, u8 cq_period_mode)\n{\n\tmlx5e_reset_rx_moderation(params, cq_period_mode);\n\tMLX5E_SET_PFLAG(params, MLX5E_PFLAG_RX_CQE_BASED_MODER,\n\t\t\tparams->rx_cq_moderation.cq_period_mode ==\n\t\t\t\tMLX5_CQ_PERIOD_MODE_START_FROM_CQE);\n}\n\nbool slow_pci_heuristic(struct mlx5_core_dev *mdev)\n{\n\tu32 link_speed = 0;\n\tu32 pci_bw = 0;\n\n\tmlx5_port_max_linkspeed(mdev, &link_speed);\n\tpci_bw = pcie_bandwidth_available(mdev->pdev, NULL, NULL, NULL);\n\tmlx5_core_dbg_once(mdev, \"Max link speed = %d, PCI BW = %d\\n\",\n\t\t\t   link_speed, pci_bw);\n\n#define MLX5E_SLOW_PCI_RATIO (2)\n\n\treturn link_speed && pci_bw &&\n\t\tlink_speed > MLX5E_SLOW_PCI_RATIO * pci_bw;\n}\n\nint mlx5e_mpwrq_validate_regular(struct mlx5_core_dev *mdev, struct mlx5e_params *params)\n{\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, NULL);\n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, NULL);\n\n\tif (!mlx5e_check_fragmented_striding_rq_cap(mdev, page_shift, umr_mode))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nint mlx5e_mpwrq_validate_xsk(struct mlx5_core_dev *mdev, struct mlx5e_params *params,\n\t\t\t     struct mlx5e_xsk_param *xsk)\n{\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\tu16 max_mtu_pkts;\n\n\tif (!mlx5e_check_fragmented_striding_rq_cap(mdev, page_shift, umr_mode)) {\n\t\tmlx5_core_err(mdev, \"Striding RQ for XSK can't be activated with page_shift %u and umr_mode %d\\n\",\n\t\t\t      page_shift, umr_mode);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!mlx5e_rx_mpwqe_is_linear_skb(mdev, params, xsk)) {\n\t\tmlx5_core_err(mdev, \"Striding RQ linear mode for XSK can't be activated with current params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmax_mtu_pkts = min_t(u8, MLX5E_PARAMS_MAXIMUM_LOG_RQ_SIZE,\n\t\t\t     mlx5e_mpwrq_max_log_rq_pkts(mdev, page_shift, xsk->unaligned));\n\tif (params->log_rq_mtu_frames > max_mtu_pkts) {\n\t\tmlx5_core_err(mdev, \"Current RQ length %d is too big for XSK with given frame size %u\\n\",\n\t\t\t      1 << params->log_rq_mtu_frames, xsk->chunk_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid mlx5e_init_rq_type_params(struct mlx5_core_dev *mdev,\n\t\t\t       struct mlx5e_params *params)\n{\n\tparams->log_rq_mtu_frames = is_kdump_kernel() ?\n\t\tMLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE :\n\t\tMLX5E_PARAMS_DEFAULT_LOG_RQ_SIZE;\n}\n\nvoid mlx5e_set_rq_type(struct mlx5_core_dev *mdev, struct mlx5e_params *params)\n{\n\tparams->rq_wq_type = MLX5E_GET_PFLAG(params, MLX5E_PFLAG_RX_STRIDING_RQ) ?\n\t\tMLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ :\n\t\tMLX5_WQ_TYPE_CYCLIC;\n}\n\nvoid mlx5e_build_rq_params(struct mlx5_core_dev *mdev,\n\t\t\t   struct mlx5e_params *params)\n{\n\t \n\tif ((!MLX5E_GET_PFLAG(params, MLX5E_PFLAG_RX_CQE_COMPRESS) ||\n\t     MLX5_CAP_GEN(mdev, mini_cqe_resp_stride_index)) &&\n\t    !mlx5e_mpwrq_validate_regular(mdev, params) &&\n\t    (mlx5e_rx_mpwqe_is_linear_skb(mdev, params, NULL) ||\n\t     !mlx5e_rx_is_linear_skb(mdev, params, NULL)))\n\t\tMLX5E_SET_PFLAG(params, MLX5E_PFLAG_RX_STRIDING_RQ, true);\n\tmlx5e_set_rq_type(mdev, params);\n\tmlx5e_init_rq_type_params(mdev, params);\n}\n\n \n\nvoid mlx5e_build_create_cq_param(struct mlx5e_create_cq_param *ccp, struct mlx5e_channel *c)\n{\n\t*ccp = (struct mlx5e_create_cq_param) {\n\t\t.napi = &c->napi,\n\t\t.ch_stats = c->stats,\n\t\t.node = cpu_to_node(c->cpu),\n\t\t.ix = c->ix,\n\t};\n}\n\nstatic int mlx5e_max_nonlinear_mtu(int first_frag_size, int frag_size, bool xdp)\n{\n\tif (xdp)\n\t\t \n\t\treturn first_frag_size + (MLX5E_MAX_RX_FRAGS - 1) * frag_size;\n\n\t \n\treturn first_frag_size + (MLX5E_MAX_RX_FRAGS - 2) * frag_size + PAGE_SIZE;\n}\n\nstatic void mlx5e_rx_compute_wqe_bulk_params(struct mlx5e_params *params,\n\t\t\t\t\t     struct mlx5e_rq_frags_info *info)\n{\n\tu16 bulk_bound_rq_size = (1 << params->log_rq_mtu_frames) / 4;\n\tu32 bulk_bound_rq_size_in_bytes;\n\tu32 sum_frag_strides = 0;\n\tu32 wqe_bulk_in_bytes;\n\tu16 split_factor;\n\tu32 wqe_bulk;\n\tint i;\n\n\tfor (i = 0; i < info->num_frags; i++)\n\t\tsum_frag_strides += info->arr[i].frag_stride;\n\n\t \n\tif (sum_frag_strides > PAGE_SIZE)\n\t\tsum_frag_strides = ALIGN(sum_frag_strides, PAGE_SIZE);\n\n\tbulk_bound_rq_size_in_bytes = bulk_bound_rq_size * sum_frag_strides;\n\n#define MAX_WQE_BULK_BYTES(xdp) ((xdp ? 256 : 512) * 1024)\n\n\t \n\twqe_bulk_in_bytes = min_t(u32, MAX_WQE_BULK_BYTES(params->xdp_prog),\n\t\t\t\t  bulk_bound_rq_size_in_bytes);\n\twqe_bulk = DIV_ROUND_UP(wqe_bulk_in_bytes, sum_frag_strides);\n\n\t \n\tinfo->wqe_bulk = max_t(u16, info->wqe_index_mask + 1, wqe_bulk);\n\n\tsplit_factor = DIV_ROUND_UP(MAX_WQE_BULK_BYTES(params->xdp_prog),\n\t\t\t\t    PP_ALLOC_CACHE_REFILL * PAGE_SIZE);\n\tinfo->refill_unit = DIV_ROUND_UP(info->wqe_bulk, split_factor);\n}\n\n#define DEFAULT_FRAG_SIZE (2048)\n\nstatic int mlx5e_build_rq_frags_info(struct mlx5_core_dev *mdev,\n\t\t\t\t     struct mlx5e_params *params,\n\t\t\t\t     struct mlx5e_xsk_param *xsk,\n\t\t\t\t     struct mlx5e_rq_frags_info *info,\n\t\t\t\t     u32 *xdp_frag_size)\n{\n\tu32 byte_count = MLX5E_SW2HW_MTU(params, params->sw_mtu);\n\tint frag_size_max = DEFAULT_FRAG_SIZE;\n\tint first_frag_size_max;\n\tu32 buf_size = 0;\n\tu16 headroom;\n\tint max_mtu;\n\tint i;\n\n\tif (mlx5e_rx_is_linear_skb(mdev, params, xsk)) {\n\t\tint frag_stride;\n\n\t\tfrag_stride = mlx5e_rx_get_linear_stride_sz(mdev, params, xsk, false);\n\n\t\tinfo->arr[0].frag_size = byte_count;\n\t\tinfo->arr[0].frag_stride = frag_stride;\n\t\tinfo->num_frags = 1;\n\n\t\t \n\t\tinfo->wqe_index_mask = (PAGE_SIZE / frag_stride) - 1;\n\n\t\tgoto out;\n\t}\n\n\theadroom = mlx5e_get_linear_rq_headroom(params, xsk);\n\tfirst_frag_size_max = SKB_WITH_OVERHEAD(frag_size_max - headroom);\n\n\tmax_mtu = mlx5e_max_nonlinear_mtu(first_frag_size_max, frag_size_max,\n\t\t\t\t\t  params->xdp_prog);\n\tif (byte_count > max_mtu || params->xdp_prog) {\n\t\tfrag_size_max = PAGE_SIZE;\n\t\tfirst_frag_size_max = SKB_WITH_OVERHEAD(frag_size_max - headroom);\n\n\t\tmax_mtu = mlx5e_max_nonlinear_mtu(first_frag_size_max, frag_size_max,\n\t\t\t\t\t\t  params->xdp_prog);\n\t\tif (byte_count > max_mtu) {\n\t\t\tmlx5_core_err(mdev, \"MTU %u is too big for non-linear legacy RQ (max %d)\\n\",\n\t\t\t\t      params->sw_mtu, max_mtu);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ti = 0;\n\twhile (buf_size < byte_count) {\n\t\tint frag_size = byte_count - buf_size;\n\n\t\tif (i == 0)\n\t\t\tfrag_size = min(frag_size, first_frag_size_max);\n\t\telse if (i < MLX5E_MAX_RX_FRAGS - 1)\n\t\t\tfrag_size = min(frag_size, frag_size_max);\n\n\t\tinfo->arr[i].frag_size = frag_size;\n\t\tbuf_size += frag_size;\n\n\t\tif (params->xdp_prog) {\n\t\t\t \n\t\t\tinfo->arr[i].frag_stride = frag_size_max;\n\t\t} else {\n\t\t\tif (i == 0) {\n\t\t\t\t \n\t\t\t\tfrag_size += headroom;\n\t\t\t\tfrag_size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\t\t\t}\n\t\t\tinfo->arr[i].frag_stride = roundup_pow_of_two(frag_size);\n\t\t}\n\n\t\ti++;\n\t}\n\tinfo->num_frags = i;\n\n\t \n\tif (frag_size_max == PAGE_SIZE) {\n\t\t \n\t\tinfo->wqe_index_mask = 0;\n\t} else {\n\t\t \n\t\tWARN_ON(PAGE_SIZE != 2 * DEFAULT_FRAG_SIZE);\n\n\t\t \n\t\tinfo->wqe_index_mask = info->num_frags % 2;\n\t}\n\nout:\n\t \n\tmlx5e_rx_compute_wqe_bulk_params(params, info);\n\n\tmlx5_core_dbg(mdev, \"%s: wqe_bulk = %u, wqe_bulk_refill_unit = %u\\n\",\n\t\t      __func__, info->wqe_bulk, info->refill_unit);\n\n\tinfo->log_num_frags = order_base_2(info->num_frags);\n\n\t*xdp_frag_size = info->num_frags > 1 && params->xdp_prog ? PAGE_SIZE : 0;\n\n\treturn 0;\n}\n\nstatic u8 mlx5e_get_rqwq_log_stride(u8 wq_type, int ndsegs)\n{\n\tint sz = sizeof(struct mlx5_wqe_data_seg) * ndsegs;\n\n\tswitch (wq_type) {\n\tcase MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ:\n\t\tsz += sizeof(struct mlx5e_rx_wqe_ll);\n\t\tbreak;\n\tdefault:  \n\t\tsz += sizeof(struct mlx5e_rx_wqe_cyc);\n\t}\n\n\treturn order_base_2(sz);\n}\n\nstatic void mlx5e_build_common_cq_param(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5e_cq_param *param)\n{\n\tvoid *cqc = param->cqc;\n\n\tMLX5_SET(cqc, cqc, uar_page, mdev->priv.uar->index);\n\tif (MLX5_CAP_GEN(mdev, cqe_128_always) && cache_line_size() >= 128)\n\t\tMLX5_SET(cqc, cqc, cqe_sz, CQE_STRIDE_128_PAD);\n}\n\nstatic u32 mlx5e_shampo_get_log_cq_size(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5e_params *params,\n\t\t\t\t\tstruct mlx5e_xsk_param *xsk)\n{\n\tint rsrv_size = BIT(mlx5e_shampo_get_log_rsrv_size(mdev, params)) * PAGE_SIZE;\n\tu16 num_strides = BIT(mlx5e_mpwqe_get_log_num_strides(mdev, params, xsk));\n\tint pkt_per_rsrv = BIT(mlx5e_shampo_get_log_pkt_per_rsrv(mdev, params));\n\tu8 log_stride_sz = mlx5e_mpwqe_get_log_stride_size(mdev, params, xsk);\n\tint wq_size = BIT(mlx5e_mpwqe_get_log_rq_size(mdev, params, xsk));\n\tint wqe_size = BIT(log_stride_sz) * num_strides;\n\n\t \n\treturn order_base_2((wqe_size / rsrv_size) * wq_size * (pkt_per_rsrv + 1));\n}\n\nstatic void mlx5e_build_rx_cq_param(struct mlx5_core_dev *mdev,\n\t\t\t\t    struct mlx5e_params *params,\n\t\t\t\t    struct mlx5e_xsk_param *xsk,\n\t\t\t\t    struct mlx5e_cq_param *param)\n{\n\tbool hw_stridx = false;\n\tvoid *cqc = param->cqc;\n\tu8 log_cq_size;\n\n\tswitch (params->rq_wq_type) {\n\tcase MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ:\n\t\thw_stridx = MLX5_CAP_GEN(mdev, mini_cqe_resp_stride_index);\n\t\tif (params->packet_merge.type == MLX5E_PACKET_MERGE_SHAMPO)\n\t\t\tlog_cq_size = mlx5e_shampo_get_log_cq_size(mdev, params, xsk);\n\t\telse\n\t\t\tlog_cq_size = mlx5e_mpwqe_get_log_rq_size(mdev, params, xsk) +\n\t\t\t\tmlx5e_mpwqe_get_log_num_strides(mdev, params, xsk);\n\t\tbreak;\n\tdefault:  \n\t\tlog_cq_size = params->log_rq_mtu_frames;\n\t}\n\n\tMLX5_SET(cqc, cqc, log_cq_size, log_cq_size);\n\tif (MLX5E_GET_PFLAG(params, MLX5E_PFLAG_RX_CQE_COMPRESS)) {\n\t\tMLX5_SET(cqc, cqc, mini_cqe_res_format, hw_stridx ?\n\t\t\t MLX5_CQE_FORMAT_CSUM_STRIDX : MLX5_CQE_FORMAT_CSUM);\n\t\tMLX5_SET(cqc, cqc, cqe_compression_layout,\n\t\t\t MLX5_CAP_GEN(mdev, enhanced_cqe_compression) ?\n\t\t\t MLX5_CQE_COMPRESS_LAYOUT_ENHANCED :\n\t\t\t MLX5_CQE_COMPRESS_LAYOUT_BASIC);\n\t\tMLX5_SET(cqc, cqc, cqe_comp_en, 1);\n\t}\n\n\tmlx5e_build_common_cq_param(mdev, param);\n\tparam->cq_period_mode = params->rx_cq_moderation.cq_period_mode;\n}\n\nstatic u8 rq_end_pad_mode(struct mlx5_core_dev *mdev, struct mlx5e_params *params)\n{\n\tbool lro_en = params->packet_merge.type == MLX5E_PACKET_MERGE_LRO;\n\tbool ro = MLX5_CAP_GEN(mdev, relaxed_ordering_write);\n\n\treturn ro && lro_en ?\n\t\tMLX5_WQ_END_PAD_MODE_NONE : MLX5_WQ_END_PAD_MODE_ALIGN;\n}\n\nint mlx5e_build_rq_param(struct mlx5_core_dev *mdev,\n\t\t\t struct mlx5e_params *params,\n\t\t\t struct mlx5e_xsk_param *xsk,\n\t\t\t u16 q_counter,\n\t\t\t struct mlx5e_rq_param *param)\n{\n\tvoid *rqc = param->rqc;\n\tvoid *wq = MLX5_ADDR_OF(rqc, rqc, wq);\n\tint ndsegs = 1;\n\tint err;\n\n\tswitch (params->rq_wq_type) {\n\tcase MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ: {\n\t\tu8 log_wqe_num_of_strides = mlx5e_mpwqe_get_log_num_strides(mdev, params, xsk);\n\t\tu8 log_wqe_stride_size = mlx5e_mpwqe_get_log_stride_size(mdev, params, xsk);\n\t\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\t\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\n\t\tif (!mlx5e_verify_rx_mpwqe_strides(mdev, log_wqe_stride_size,\n\t\t\t\t\t\t   log_wqe_num_of_strides,\n\t\t\t\t\t\t   page_shift, umr_mode)) {\n\t\t\tmlx5_core_err(mdev,\n\t\t\t\t      \"Bad RX MPWQE params: log_stride_size %u, log_num_strides %u, umr_mode %d\\n\",\n\t\t\t\t      log_wqe_stride_size, log_wqe_num_of_strides,\n\t\t\t\t      umr_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tMLX5_SET(wq, wq, log_wqe_num_of_strides,\n\t\t\t log_wqe_num_of_strides - MLX5_MPWQE_LOG_NUM_STRIDES_BASE);\n\t\tMLX5_SET(wq, wq, log_wqe_stride_size,\n\t\t\t log_wqe_stride_size - MLX5_MPWQE_LOG_STRIDE_SZ_BASE);\n\t\tMLX5_SET(wq, wq, log_wq_sz, mlx5e_mpwqe_get_log_rq_size(mdev, params, xsk));\n\t\tif (params->packet_merge.type == MLX5E_PACKET_MERGE_SHAMPO) {\n\t\t\tMLX5_SET(wq, wq, shampo_enable, true);\n\t\t\tMLX5_SET(wq, wq, log_reservation_size,\n\t\t\t\t mlx5e_shampo_get_log_rsrv_size(mdev, params));\n\t\t\tMLX5_SET(wq, wq,\n\t\t\t\t log_max_num_of_packets_per_reservation,\n\t\t\t\t mlx5e_shampo_get_log_pkt_per_rsrv(mdev, params));\n\t\t\tMLX5_SET(wq, wq, log_headers_entry_size,\n\t\t\t\t mlx5e_shampo_get_log_hd_entry_size(mdev, params));\n\t\t\tMLX5_SET(rqc, rqc, reservation_timeout,\n\t\t\t\t params->packet_merge.timeout);\n\t\t\tMLX5_SET(rqc, rqc, shampo_match_criteria_type,\n\t\t\t\t params->packet_merge.shampo.match_criteria_type);\n\t\t\tMLX5_SET(rqc, rqc, shampo_no_match_alignment_granularity,\n\t\t\t\t params->packet_merge.shampo.alignment_granularity);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:  \n\t\tMLX5_SET(wq, wq, log_wq_sz, params->log_rq_mtu_frames);\n\t\terr = mlx5e_build_rq_frags_info(mdev, params, xsk, &param->frags_info,\n\t\t\t\t\t\t&param->xdp_frag_size);\n\t\tif (err)\n\t\t\treturn err;\n\t\tndsegs = param->frags_info.num_frags;\n\t}\n\n\tMLX5_SET(wq, wq, wq_type,          params->rq_wq_type);\n\tMLX5_SET(wq, wq, end_padding_mode, rq_end_pad_mode(mdev, params));\n\tMLX5_SET(wq, wq, log_wq_stride,\n\t\t mlx5e_get_rqwq_log_stride(params->rq_wq_type, ndsegs));\n\tMLX5_SET(wq, wq, pd,               mdev->mlx5e_res.hw_objs.pdn);\n\tMLX5_SET(rqc, rqc, counter_set_id, q_counter);\n\tMLX5_SET(rqc, rqc, vsd,            params->vlan_strip_disable);\n\tMLX5_SET(rqc, rqc, scatter_fcs,    params->scatter_fcs_en);\n\n\tparam->wq.buf_numa_node = dev_to_node(mlx5_core_dma_dev(mdev));\n\tmlx5e_build_rx_cq_param(mdev, params, xsk, &param->cqp);\n\n\treturn 0;\n}\n\nvoid mlx5e_build_drop_rq_param(struct mlx5_core_dev *mdev,\n\t\t\t       u16 q_counter,\n\t\t\t       struct mlx5e_rq_param *param)\n{\n\tvoid *rqc = param->rqc;\n\tvoid *wq = MLX5_ADDR_OF(rqc, rqc, wq);\n\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\tMLX5_SET(wq, wq, log_wq_stride,\n\t\t mlx5e_get_rqwq_log_stride(MLX5_WQ_TYPE_CYCLIC, 1));\n\tMLX5_SET(rqc, rqc, counter_set_id, q_counter);\n\n\tparam->wq.buf_numa_node = dev_to_node(mlx5_core_dma_dev(mdev));\n}\n\nvoid mlx5e_build_tx_cq_param(struct mlx5_core_dev *mdev,\n\t\t\t     struct mlx5e_params *params,\n\t\t\t     struct mlx5e_cq_param *param)\n{\n\tvoid *cqc = param->cqc;\n\n\tMLX5_SET(cqc, cqc, log_cq_size, params->log_sq_size);\n\n\tmlx5e_build_common_cq_param(mdev, param);\n\tparam->cq_period_mode = params->tx_cq_moderation.cq_period_mode;\n}\n\nvoid mlx5e_build_sq_param_common(struct mlx5_core_dev *mdev,\n\t\t\t\t struct mlx5e_sq_param *param)\n{\n\tvoid *sqc = param->sqc;\n\tvoid *wq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tMLX5_SET(wq, wq, log_wq_stride, ilog2(MLX5_SEND_WQE_BB));\n\tMLX5_SET(wq, wq, pd,            mdev->mlx5e_res.hw_objs.pdn);\n\n\tparam->wq.buf_numa_node = dev_to_node(mlx5_core_dma_dev(mdev));\n}\n\nvoid mlx5e_build_sq_param(struct mlx5_core_dev *mdev,\n\t\t\t  struct mlx5e_params *params,\n\t\t\t  struct mlx5e_sq_param *param)\n{\n\tvoid *sqc = param->sqc;\n\tvoid *wq = MLX5_ADDR_OF(sqc, sqc, wq);\n\tbool allow_swp;\n\n\tallow_swp =\n\t\tmlx5_geneve_tx_allowed(mdev) || !!mlx5_ipsec_device_caps(mdev);\n\tmlx5e_build_sq_param_common(mdev, param);\n\tMLX5_SET(wq, wq, log_wq_sz, params->log_sq_size);\n\tMLX5_SET(sqc, sqc, allow_swp, allow_swp);\n\tparam->is_mpw = MLX5E_GET_PFLAG(params, MLX5E_PFLAG_SKB_TX_MPWQE);\n\tparam->stop_room = mlx5e_calc_sq_stop_room(mdev, params);\n\tmlx5e_build_tx_cq_param(mdev, params, &param->cqp);\n}\n\nstatic void mlx5e_build_ico_cq_param(struct mlx5_core_dev *mdev,\n\t\t\t\t     u8 log_wq_size,\n\t\t\t\t     struct mlx5e_cq_param *param)\n{\n\tvoid *cqc = param->cqc;\n\n\tMLX5_SET(cqc, cqc, log_cq_size, log_wq_size);\n\n\tmlx5e_build_common_cq_param(mdev, param);\n\n\tparam->cq_period_mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n}\n\n \nu32 mlx5e_shampo_hd_per_wqe(struct mlx5_core_dev *mdev,\n\t\t\t    struct mlx5e_params *params,\n\t\t\t    struct mlx5e_rq_param *rq_param)\n{\n\tint resv_size = BIT(mlx5e_shampo_get_log_rsrv_size(mdev, params)) * PAGE_SIZE;\n\tu16 num_strides = BIT(mlx5e_mpwqe_get_log_num_strides(mdev, params, NULL));\n\tint pkt_per_resv = BIT(mlx5e_shampo_get_log_pkt_per_rsrv(mdev, params));\n\tu8 log_stride_sz = mlx5e_mpwqe_get_log_stride_size(mdev, params, NULL);\n\tint wqe_size = BIT(log_stride_sz) * num_strides;\n\tu32 hd_per_wqe;\n\n\t \n\thd_per_wqe = (wqe_size / resv_size) * pkt_per_resv;\n\tmlx5_core_dbg(mdev, \"%s hd_per_wqe = %d rsrv_size = %d wqe_size = %d pkt_per_resv = %d\\n\",\n\t\t      __func__, hd_per_wqe, resv_size, wqe_size, pkt_per_resv);\n\treturn hd_per_wqe;\n}\n\n \nu32 mlx5e_shampo_hd_per_wq(struct mlx5_core_dev *mdev,\n\t\t\t   struct mlx5e_params *params,\n\t\t\t   struct mlx5e_rq_param *rq_param)\n{\n\tvoid *wqc = MLX5_ADDR_OF(rqc, rq_param->rqc, wq);\n\tint wq_size = BIT(MLX5_GET(wq, wqc, log_wq_sz));\n\tu32 hd_per_wqe, hd_per_wq;\n\n\thd_per_wqe = mlx5e_shampo_hd_per_wqe(mdev, params, rq_param);\n\thd_per_wq = roundup_pow_of_two(hd_per_wqe * wq_size);\n\treturn hd_per_wq;\n}\n\nstatic u32 mlx5e_shampo_icosq_sz(struct mlx5_core_dev *mdev,\n\t\t\t\t struct mlx5e_params *params,\n\t\t\t\t struct mlx5e_rq_param *rq_param)\n{\n\tint max_num_of_umr_per_wqe, max_hd_per_wqe, max_klm_per_umr, rest;\n\tvoid *wqc = MLX5_ADDR_OF(rqc, rq_param->rqc, wq);\n\tint wq_size = BIT(MLX5_GET(wq, wqc, log_wq_sz));\n\tu32 wqebbs;\n\n\tmax_klm_per_umr = MLX5E_MAX_KLM_PER_WQE(mdev);\n\tmax_hd_per_wqe = mlx5e_shampo_hd_per_wqe(mdev, params, rq_param);\n\tmax_num_of_umr_per_wqe = max_hd_per_wqe / max_klm_per_umr;\n\trest = max_hd_per_wqe % max_klm_per_umr;\n\twqebbs = MLX5E_KLM_UMR_WQEBBS(max_klm_per_umr) * max_num_of_umr_per_wqe;\n\tif (rest)\n\t\twqebbs += MLX5E_KLM_UMR_WQEBBS(rest);\n\twqebbs *= wq_size;\n\treturn wqebbs;\n}\n\nstatic u32 mlx5e_mpwrq_total_umr_wqebbs(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5e_params *params,\n\t\t\t\t\tstruct mlx5e_xsk_param *xsk)\n{\n\tenum mlx5e_mpwrq_umr_mode umr_mode = mlx5e_mpwrq_umr_mode(mdev, xsk);\n\tu8 page_shift = mlx5e_mpwrq_page_shift(mdev, xsk);\n\tu8 umr_wqebbs;\n\n\tumr_wqebbs = mlx5e_mpwrq_umr_wqebbs(mdev, page_shift, umr_mode);\n\n\treturn umr_wqebbs * (1 << mlx5e_mpwqe_get_log_rq_size(mdev, params, xsk));\n}\n\nstatic u8 mlx5e_build_icosq_log_wq_sz(struct mlx5_core_dev *mdev,\n\t\t\t\t      struct mlx5e_params *params,\n\t\t\t\t      struct mlx5e_rq_param *rqp)\n{\n\tu32 wqebbs, total_pages, useful_space;\n\n\t \n\tif (params->rq_wq_type != MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ)\n\t\treturn MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE;\n\n\t \n\twqebbs = mlx5e_mpwrq_total_umr_wqebbs(mdev, params, NULL);\n\n\t \n\tif (params->xdp_prog) {\n\t\tu32 max_xsk_wqebbs = 0;\n\t\tu8 frame_shift;\n\n\t\tfor (frame_shift = XDP_UMEM_MIN_CHUNK_SHIFT;\n\t\t     frame_shift <= PAGE_SHIFT; frame_shift++) {\n\t\t\t \n\t\t\tstruct mlx5e_xsk_param xsk = {\n\t\t\t\t.chunk_size = 1 << frame_shift,\n\t\t\t\t.unaligned = false,\n\t\t\t};\n\n\t\t\t \n\t\t\tmax_xsk_wqebbs = max(max_xsk_wqebbs,\n\t\t\t\tmlx5e_mpwrq_total_umr_wqebbs(mdev, params, &xsk));\n\n\t\t\t \n\t\t\txsk.unaligned = true;\n\t\t\tmax_xsk_wqebbs = max(max_xsk_wqebbs,\n\t\t\t\tmlx5e_mpwrq_total_umr_wqebbs(mdev, params, &xsk));\n\n\t\t\t \n\t\t\txsk.chunk_size -= 1;\n\t\t\tmax_xsk_wqebbs = max(max_xsk_wqebbs,\n\t\t\t\tmlx5e_mpwrq_total_umr_wqebbs(mdev, params, &xsk));\n\n\t\t\t \n\t\t\txsk.chunk_size = (1 << frame_shift) / 4 * 3;\n\t\t\tmax_xsk_wqebbs = max(max_xsk_wqebbs,\n\t\t\t\tmlx5e_mpwrq_total_umr_wqebbs(mdev, params, &xsk));\n\t\t}\n\n\t\twqebbs += max_xsk_wqebbs;\n\t}\n\n\tif (params->packet_merge.type == MLX5E_PACKET_MERGE_SHAMPO)\n\t\twqebbs += mlx5e_shampo_icosq_sz(mdev, params, rqp);\n\n\t \n\tuseful_space = PAGE_SIZE - mlx5e_get_max_sq_wqebbs(mdev) + MLX5_SEND_WQE_BB;\n\ttotal_pages = DIV_ROUND_UP(wqebbs * MLX5_SEND_WQE_BB, useful_space);\n\twqebbs = total_pages * (PAGE_SIZE / MLX5_SEND_WQE_BB);\n\n\treturn max_t(u8, MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE, order_base_2(wqebbs));\n}\n\nstatic u8 mlx5e_build_async_icosq_log_wq_sz(struct mlx5_core_dev *mdev)\n{\n\tif (mlx5e_is_ktls_rx(mdev))\n\t\treturn MLX5E_PARAMS_DEFAULT_LOG_SQ_SIZE;\n\n\treturn MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE;\n}\n\nstatic void mlx5e_build_icosq_param(struct mlx5_core_dev *mdev,\n\t\t\t\t    u8 log_wq_size,\n\t\t\t\t    struct mlx5e_sq_param *param)\n{\n\tvoid *sqc = param->sqc;\n\tvoid *wq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmlx5e_build_sq_param_common(mdev, param);\n\n\tMLX5_SET(wq, wq, log_wq_sz, log_wq_size);\n\tMLX5_SET(sqc, sqc, reg_umr, MLX5_CAP_ETH(mdev, reg_umr_sq));\n\tmlx5e_build_ico_cq_param(mdev, log_wq_size, &param->cqp);\n}\n\nstatic void mlx5e_build_async_icosq_param(struct mlx5_core_dev *mdev,\n\t\t\t\t\t  u8 log_wq_size,\n\t\t\t\t\t  struct mlx5e_sq_param *param)\n{\n\tvoid *sqc = param->sqc;\n\tvoid *wq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmlx5e_build_sq_param_common(mdev, param);\n\tparam->stop_room = mlx5e_stop_room_for_wqe(mdev, 1);  \n\tparam->is_tls = mlx5e_is_ktls_rx(mdev);\n\tif (param->is_tls)\n\t\tparam->stop_room += mlx5e_stop_room_for_wqe(mdev, 1);  \n\tMLX5_SET(sqc, sqc, reg_umr, MLX5_CAP_ETH(mdev, reg_umr_sq));\n\tMLX5_SET(wq, wq, log_wq_sz, log_wq_size);\n\tmlx5e_build_ico_cq_param(mdev, log_wq_size, &param->cqp);\n}\n\nvoid mlx5e_build_xdpsq_param(struct mlx5_core_dev *mdev,\n\t\t\t     struct mlx5e_params *params,\n\t\t\t     struct mlx5e_xsk_param *xsk,\n\t\t\t     struct mlx5e_sq_param *param)\n{\n\tvoid *sqc = param->sqc;\n\tvoid *wq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmlx5e_build_sq_param_common(mdev, param);\n\tMLX5_SET(wq, wq, log_wq_sz, params->log_sq_size);\n\tparam->is_mpw = MLX5E_GET_PFLAG(params, MLX5E_PFLAG_XDP_TX_MPWQE);\n\tparam->is_xdp_mb = !mlx5e_rx_is_linear_skb(mdev, params, xsk);\n\tmlx5e_build_tx_cq_param(mdev, params, &param->cqp);\n}\n\nint mlx5e_build_channel_param(struct mlx5_core_dev *mdev,\n\t\t\t      struct mlx5e_params *params,\n\t\t\t      u16 q_counter,\n\t\t\t      struct mlx5e_channel_param *cparam)\n{\n\tu8 icosq_log_wq_sz, async_icosq_log_wq_sz;\n\tint err;\n\n\terr = mlx5e_build_rq_param(mdev, params, NULL, q_counter, &cparam->rq);\n\tif (err)\n\t\treturn err;\n\n\ticosq_log_wq_sz = mlx5e_build_icosq_log_wq_sz(mdev, params, &cparam->rq);\n\tasync_icosq_log_wq_sz = mlx5e_build_async_icosq_log_wq_sz(mdev);\n\n\tmlx5e_build_sq_param(mdev, params, &cparam->txq_sq);\n\tmlx5e_build_xdpsq_param(mdev, params, NULL, &cparam->xdp_sq);\n\tmlx5e_build_icosq_param(mdev, icosq_log_wq_sz, &cparam->icosq);\n\tmlx5e_build_async_icosq_param(mdev, async_icosq_log_wq_sz, &cparam->async_icosq);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}