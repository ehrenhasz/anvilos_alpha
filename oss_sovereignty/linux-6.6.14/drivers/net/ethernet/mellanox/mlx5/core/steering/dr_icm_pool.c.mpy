{
  "module_name": "dr_icm_pool.c",
  "hash_id": "9fb14e06486577d49d3640f5986e23ec289460ec6af8dd8b1a177a97896002cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_icm_pool.c",
  "human_readable_source": "\n \n\n#include \"dr_types.h\"\n\n#define DR_ICM_MODIFY_HDR_ALIGN_BASE 64\n#define DR_ICM_POOL_STE_HOT_MEM_PERCENT 25\n#define DR_ICM_POOL_MODIFY_HDR_PTRN_HOT_MEM_PERCENT 50\n#define DR_ICM_POOL_MODIFY_ACTION_HOT_MEM_PERCENT 90\n\nstruct mlx5dr_icm_hot_chunk {\n\tstruct mlx5dr_icm_buddy_mem *buddy_mem;\n\tunsigned int seg;\n\tenum mlx5dr_icm_chunk_size size;\n};\n\nstruct mlx5dr_icm_pool {\n\tenum mlx5dr_icm_type icm_type;\n\tenum mlx5dr_icm_chunk_size max_log_chunk_sz;\n\tstruct mlx5dr_domain *dmn;\n\tstruct kmem_cache *chunks_kmem_cache;\n\n\t \n\tstruct mutex mutex;  \n\tstruct list_head buddy_mem_list;\n\n\t \n\tstruct mlx5dr_icm_hot_chunk *hot_chunks_arr;\n\tu32 hot_chunks_num;\n\tu64 hot_memory_size;\n\t \n\tu64 th;\n};\n\nstruct mlx5dr_icm_dm {\n\tu32 obj_id;\n\tenum mlx5_sw_icm_type type;\n\tphys_addr_t addr;\n\tsize_t length;\n};\n\nstruct mlx5dr_icm_mr {\n\tu32 mkey;\n\tstruct mlx5dr_icm_dm dm;\n\tstruct mlx5dr_domain *dmn;\n\tsize_t length;\n\tu64 icm_start_addr;\n};\n\nstatic int dr_icm_create_dm_mkey(struct mlx5_core_dev *mdev,\n\t\t\t\t u32 pd, u64 length, u64 start_addr, int mode,\n\t\t\t\t u32 *mkey)\n{\n\tu32 inlen = MLX5_ST_SZ_BYTES(create_mkey_in);\n\tu32 in[MLX5_ST_SZ_DW(create_mkey_in)] = {};\n\tvoid *mkc;\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\n\tMLX5_SET(mkc, mkc, access_mode_1_0, mode);\n\tMLX5_SET(mkc, mkc, access_mode_4_2, (mode >> 2) & 0x7);\n\tMLX5_SET(mkc, mkc, lw, 1);\n\tMLX5_SET(mkc, mkc, lr, 1);\n\tif (mode == MLX5_MKC_ACCESS_MODE_SW_ICM) {\n\t\tMLX5_SET(mkc, mkc, rw, 1);\n\t\tMLX5_SET(mkc, mkc, rr, 1);\n\t}\n\n\tMLX5_SET64(mkc, mkc, len, length);\n\tMLX5_SET(mkc, mkc, pd, pd);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\tMLX5_SET64(mkc, mkc, start_addr, start_addr);\n\n\treturn mlx5_core_create_mkey(mdev, mkey, in, inlen);\n}\n\nu64 mlx5dr_icm_pool_get_chunk_mr_addr(struct mlx5dr_icm_chunk *chunk)\n{\n\tu32 offset = mlx5dr_icm_pool_dm_type_to_entry_size(chunk->buddy_mem->pool->icm_type);\n\n\treturn (u64)offset * chunk->seg;\n}\n\nu32 mlx5dr_icm_pool_get_chunk_rkey(struct mlx5dr_icm_chunk *chunk)\n{\n\treturn chunk->buddy_mem->icm_mr->mkey;\n}\n\nu64 mlx5dr_icm_pool_get_chunk_icm_addr(struct mlx5dr_icm_chunk *chunk)\n{\n\tu32 size = mlx5dr_icm_pool_dm_type_to_entry_size(chunk->buddy_mem->pool->icm_type);\n\n\treturn (u64)chunk->buddy_mem->icm_mr->icm_start_addr + size * chunk->seg;\n}\n\nu32 mlx5dr_icm_pool_get_chunk_byte_size(struct mlx5dr_icm_chunk *chunk)\n{\n\treturn mlx5dr_icm_pool_chunk_size_to_byte(chunk->size,\n\t\t\tchunk->buddy_mem->pool->icm_type);\n}\n\nu32 mlx5dr_icm_pool_get_chunk_num_of_entries(struct mlx5dr_icm_chunk *chunk)\n{\n\treturn mlx5dr_icm_pool_chunk_size_to_entries(chunk->size);\n}\n\nstatic struct mlx5dr_icm_mr *\ndr_icm_pool_mr_create(struct mlx5dr_icm_pool *pool)\n{\n\tstruct mlx5_core_dev *mdev = pool->dmn->mdev;\n\tenum mlx5_sw_icm_type dm_type = 0;\n\tstruct mlx5dr_icm_mr *icm_mr;\n\tsize_t log_align_base = 0;\n\tint err;\n\n\ticm_mr = kvzalloc(sizeof(*icm_mr), GFP_KERNEL);\n\tif (!icm_mr)\n\t\treturn NULL;\n\n\ticm_mr->dmn = pool->dmn;\n\n\ticm_mr->dm.length = mlx5dr_icm_pool_chunk_size_to_byte(pool->max_log_chunk_sz,\n\t\t\t\t\t\t\t       pool->icm_type);\n\n\tswitch (pool->icm_type) {\n\tcase DR_ICM_TYPE_STE:\n\t\tdm_type = MLX5_SW_ICM_TYPE_STEERING;\n\t\tlog_align_base = ilog2(icm_mr->dm.length);\n\t\tbreak;\n\tcase DR_ICM_TYPE_MODIFY_ACTION:\n\t\tdm_type = MLX5_SW_ICM_TYPE_HEADER_MODIFY;\n\t\t \n\t\tlog_align_base = ilog2(DR_ICM_MODIFY_HDR_ALIGN_BASE);\n\t\tbreak;\n\tcase DR_ICM_TYPE_MODIFY_HDR_PTRN:\n\t\tdm_type = MLX5_SW_ICM_TYPE_HEADER_MODIFY_PATTERN;\n\t\t \n\t\tlog_align_base = ilog2(DR_ICM_MODIFY_HDR_ALIGN_BASE);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(pool->icm_type);\n\t}\n\n\ticm_mr->dm.type = dm_type;\n\n\terr = mlx5_dm_sw_icm_alloc(mdev, icm_mr->dm.type, icm_mr->dm.length,\n\t\t\t\t   log_align_base, 0, &icm_mr->dm.addr,\n\t\t\t\t   &icm_mr->dm.obj_id);\n\tif (err) {\n\t\tmlx5dr_err(pool->dmn, \"Failed to allocate SW ICM memory, err (%d)\\n\", err);\n\t\tgoto free_icm_mr;\n\t}\n\n\t \n\terr = dr_icm_create_dm_mkey(mdev, pool->dmn->pdn,\n\t\t\t\t    icm_mr->dm.length,\n\t\t\t\t    icm_mr->dm.addr,\n\t\t\t\t    MLX5_MKC_ACCESS_MODE_SW_ICM,\n\t\t\t\t    &icm_mr->mkey);\n\tif (err) {\n\t\tmlx5dr_err(pool->dmn, \"Failed to create SW ICM MKEY, err (%d)\\n\", err);\n\t\tgoto free_dm;\n\t}\n\n\ticm_mr->icm_start_addr = icm_mr->dm.addr;\n\n\tif (icm_mr->icm_start_addr & (BIT(log_align_base) - 1)) {\n\t\tmlx5dr_err(pool->dmn, \"Failed to get Aligned ICM mem (asked: %zu)\\n\",\n\t\t\t   log_align_base);\n\t\tgoto free_mkey;\n\t}\n\n\treturn icm_mr;\n\nfree_mkey:\n\tmlx5_core_destroy_mkey(mdev, icm_mr->mkey);\nfree_dm:\n\tmlx5_dm_sw_icm_dealloc(mdev, icm_mr->dm.type, icm_mr->dm.length, 0,\n\t\t\t       icm_mr->dm.addr, icm_mr->dm.obj_id);\nfree_icm_mr:\n\tkvfree(icm_mr);\n\treturn NULL;\n}\n\nstatic void dr_icm_pool_mr_destroy(struct mlx5dr_icm_mr *icm_mr)\n{\n\tstruct mlx5_core_dev *mdev = icm_mr->dmn->mdev;\n\tstruct mlx5dr_icm_dm *dm = &icm_mr->dm;\n\n\tmlx5_core_destroy_mkey(mdev, icm_mr->mkey);\n\tmlx5_dm_sw_icm_dealloc(mdev, dm->type, dm->length, 0,\n\t\t\t       dm->addr, dm->obj_id);\n\tkvfree(icm_mr);\n}\n\nstatic int dr_icm_buddy_get_ste_size(struct mlx5dr_icm_buddy_mem *buddy)\n{\n\t \n\treturn DR_STE_SIZE_REDUCED;\n}\n\nstatic void dr_icm_chunk_ste_init(struct mlx5dr_icm_chunk *chunk, int offset)\n{\n\tint num_of_entries = mlx5dr_icm_pool_get_chunk_num_of_entries(chunk);\n\tstruct mlx5dr_icm_buddy_mem *buddy = chunk->buddy_mem;\n\tint ste_size = dr_icm_buddy_get_ste_size(buddy);\n\tint index = offset / DR_STE_SIZE;\n\n\tchunk->ste_arr = &buddy->ste_arr[index];\n\tchunk->miss_list = &buddy->miss_list[index];\n\tchunk->hw_ste_arr = buddy->hw_ste_arr + index * ste_size;\n\n\tmemset(chunk->hw_ste_arr, 0, num_of_entries * ste_size);\n\tmemset(chunk->ste_arr, 0,\n\t       num_of_entries * sizeof(chunk->ste_arr[0]));\n}\n\nstatic int dr_icm_buddy_init_ste_cache(struct mlx5dr_icm_buddy_mem *buddy)\n{\n\tint num_of_entries =\n\t\tmlx5dr_icm_pool_chunk_size_to_entries(buddy->pool->max_log_chunk_sz);\n\n\tbuddy->ste_arr = kvcalloc(num_of_entries,\n\t\t\t\t  sizeof(struct mlx5dr_ste), GFP_KERNEL);\n\tif (!buddy->ste_arr)\n\t\treturn -ENOMEM;\n\n\t \n\tbuddy->hw_ste_arr = kvcalloc(num_of_entries,\n\t\t\t\t     dr_icm_buddy_get_ste_size(buddy), GFP_KERNEL);\n\tif (!buddy->hw_ste_arr)\n\t\tgoto free_ste_arr;\n\n\tbuddy->miss_list = kvmalloc(num_of_entries * sizeof(struct list_head), GFP_KERNEL);\n\tif (!buddy->miss_list)\n\t\tgoto free_hw_ste_arr;\n\n\treturn 0;\n\nfree_hw_ste_arr:\n\tkvfree(buddy->hw_ste_arr);\nfree_ste_arr:\n\tkvfree(buddy->ste_arr);\n\treturn -ENOMEM;\n}\n\nstatic void dr_icm_buddy_cleanup_ste_cache(struct mlx5dr_icm_buddy_mem *buddy)\n{\n\tkvfree(buddy->ste_arr);\n\tkvfree(buddy->hw_ste_arr);\n\tkvfree(buddy->miss_list);\n}\n\nstatic int dr_icm_buddy_create(struct mlx5dr_icm_pool *pool)\n{\n\tstruct mlx5dr_icm_buddy_mem *buddy;\n\tstruct mlx5dr_icm_mr *icm_mr;\n\n\ticm_mr = dr_icm_pool_mr_create(pool);\n\tif (!icm_mr)\n\t\treturn -ENOMEM;\n\n\tbuddy = kvzalloc(sizeof(*buddy), GFP_KERNEL);\n\tif (!buddy)\n\t\tgoto free_mr;\n\n\tif (mlx5dr_buddy_init(buddy, pool->max_log_chunk_sz))\n\t\tgoto err_free_buddy;\n\n\tbuddy->icm_mr = icm_mr;\n\tbuddy->pool = pool;\n\n\tif (pool->icm_type == DR_ICM_TYPE_STE) {\n\t\t \n\t\tif (dr_icm_buddy_init_ste_cache(buddy))\n\t\t\tgoto err_cleanup_buddy;\n\t}\n\n\t \n\tlist_add(&buddy->list_node, &pool->buddy_mem_list);\n\n\tpool->dmn->num_buddies[pool->icm_type]++;\n\n\treturn 0;\n\nerr_cleanup_buddy:\n\tmlx5dr_buddy_cleanup(buddy);\nerr_free_buddy:\n\tkvfree(buddy);\nfree_mr:\n\tdr_icm_pool_mr_destroy(icm_mr);\n\treturn -ENOMEM;\n}\n\nstatic void dr_icm_buddy_destroy(struct mlx5dr_icm_buddy_mem *buddy)\n{\n\tenum mlx5dr_icm_type icm_type = buddy->pool->icm_type;\n\n\tdr_icm_pool_mr_destroy(buddy->icm_mr);\n\n\tmlx5dr_buddy_cleanup(buddy);\n\n\tif (icm_type == DR_ICM_TYPE_STE)\n\t\tdr_icm_buddy_cleanup_ste_cache(buddy);\n\n\tbuddy->pool->dmn->num_buddies[icm_type]--;\n\n\tkvfree(buddy);\n}\n\nstatic void\ndr_icm_chunk_init(struct mlx5dr_icm_chunk *chunk,\n\t\t  struct mlx5dr_icm_pool *pool,\n\t\t  enum mlx5dr_icm_chunk_size chunk_size,\n\t\t  struct mlx5dr_icm_buddy_mem *buddy_mem_pool,\n\t\t  unsigned int seg)\n{\n\tint offset;\n\n\tchunk->seg = seg;\n\tchunk->size = chunk_size;\n\tchunk->buddy_mem = buddy_mem_pool;\n\n\tif (pool->icm_type == DR_ICM_TYPE_STE) {\n\t\toffset = mlx5dr_icm_pool_dm_type_to_entry_size(pool->icm_type) * seg;\n\t\tdr_icm_chunk_ste_init(chunk, offset);\n\t}\n\n\tbuddy_mem_pool->used_memory += mlx5dr_icm_pool_get_chunk_byte_size(chunk);\n}\n\nstatic bool dr_icm_pool_is_sync_required(struct mlx5dr_icm_pool *pool)\n{\n\treturn pool->hot_memory_size > pool->th;\n}\n\nstatic void dr_icm_pool_clear_hot_chunks_arr(struct mlx5dr_icm_pool *pool)\n{\n\tstruct mlx5dr_icm_hot_chunk *hot_chunk;\n\tu32 i, num_entries;\n\n\tfor (i = 0; i < pool->hot_chunks_num; i++) {\n\t\thot_chunk = &pool->hot_chunks_arr[i];\n\t\tnum_entries = mlx5dr_icm_pool_chunk_size_to_entries(hot_chunk->size);\n\t\tmlx5dr_buddy_free_mem(hot_chunk->buddy_mem,\n\t\t\t\t      hot_chunk->seg, ilog2(num_entries));\n\t\thot_chunk->buddy_mem->used_memory -=\n\t\t\tmlx5dr_icm_pool_chunk_size_to_byte(hot_chunk->size,\n\t\t\t\t\t\t\t   pool->icm_type);\n\t}\n\n\tpool->hot_chunks_num = 0;\n\tpool->hot_memory_size = 0;\n}\n\nstatic int dr_icm_pool_sync_all_buddy_pools(struct mlx5dr_icm_pool *pool)\n{\n\tstruct mlx5dr_icm_buddy_mem *buddy, *tmp_buddy;\n\tint err;\n\n\terr = mlx5dr_cmd_sync_steering(pool->dmn->mdev);\n\tif (err) {\n\t\tmlx5dr_err(pool->dmn, \"Failed to sync to HW (err: %d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tdr_icm_pool_clear_hot_chunks_arr(pool);\n\n\tlist_for_each_entry_safe(buddy, tmp_buddy, &pool->buddy_mem_list, list_node) {\n\t\tif (!buddy->used_memory && pool->icm_type == DR_ICM_TYPE_STE)\n\t\t\tdr_icm_buddy_destroy(buddy);\n\t}\n\n\treturn 0;\n}\n\nstatic int dr_icm_handle_buddies_get_mem(struct mlx5dr_icm_pool *pool,\n\t\t\t\t\t enum mlx5dr_icm_chunk_size chunk_size,\n\t\t\t\t\t struct mlx5dr_icm_buddy_mem **buddy,\n\t\t\t\t\t unsigned int *seg)\n{\n\tstruct mlx5dr_icm_buddy_mem *buddy_mem_pool;\n\tbool new_mem = false;\n\tint err;\n\nalloc_buddy_mem:\n\t \n\tlist_for_each_entry(buddy_mem_pool, &pool->buddy_mem_list, list_node) {\n\t\terr = mlx5dr_buddy_alloc_mem(buddy_mem_pool,\n\t\t\t\t\t     chunk_size, seg);\n\t\tif (!err)\n\t\t\tgoto found;\n\n\t\tif (WARN_ON(new_mem)) {\n\t\t\t \n\t\t\tmlx5dr_err(pool->dmn,\n\t\t\t\t   \"No memory for order: %d\\n\",\n\t\t\t\t   chunk_size);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\terr = dr_icm_buddy_create(pool);\n\tif (err) {\n\t\tmlx5dr_err(pool->dmn,\n\t\t\t   \"Failed creating buddy for order %d\\n\",\n\t\t\t   chunk_size);\n\t\tgoto out;\n\t}\n\n\t \n\tnew_mem = true;\n\tgoto alloc_buddy_mem;\n\nfound:\n\t*buddy = buddy_mem_pool;\nout:\n\treturn err;\n}\n\n \nstruct mlx5dr_icm_chunk *\nmlx5dr_icm_alloc_chunk(struct mlx5dr_icm_pool *pool,\n\t\t       enum mlx5dr_icm_chunk_size chunk_size)\n{\n\tstruct mlx5dr_icm_chunk *chunk = NULL;\n\tstruct mlx5dr_icm_buddy_mem *buddy;\n\tunsigned int seg;\n\tint ret;\n\n\tif (chunk_size > pool->max_log_chunk_sz)\n\t\treturn NULL;\n\n\tmutex_lock(&pool->mutex);\n\t \n\tret = dr_icm_handle_buddies_get_mem(pool, chunk_size, &buddy, &seg);\n\tif (ret)\n\t\tgoto out;\n\n\tchunk = kmem_cache_alloc(pool->chunks_kmem_cache, GFP_KERNEL);\n\tif (!chunk)\n\t\tgoto out_err;\n\n\tdr_icm_chunk_init(chunk, pool, chunk_size, buddy, seg);\n\n\tgoto out;\n\nout_err:\n\tmlx5dr_buddy_free_mem(buddy, seg, chunk_size);\nout:\n\tmutex_unlock(&pool->mutex);\n\treturn chunk;\n}\n\nvoid mlx5dr_icm_free_chunk(struct mlx5dr_icm_chunk *chunk)\n{\n\tstruct mlx5dr_icm_buddy_mem *buddy = chunk->buddy_mem;\n\tstruct mlx5dr_icm_pool *pool = buddy->pool;\n\tstruct mlx5dr_icm_hot_chunk *hot_chunk;\n\tstruct kmem_cache *chunks_cache;\n\n\tchunks_cache = pool->chunks_kmem_cache;\n\n\t \n\tmutex_lock(&pool->mutex);\n\n\tpool->hot_memory_size += mlx5dr_icm_pool_get_chunk_byte_size(chunk);\n\n\thot_chunk = &pool->hot_chunks_arr[pool->hot_chunks_num++];\n\thot_chunk->buddy_mem = chunk->buddy_mem;\n\thot_chunk->seg = chunk->seg;\n\thot_chunk->size = chunk->size;\n\n\tkmem_cache_free(chunks_cache, chunk);\n\n\t \n\tif (dr_icm_pool_is_sync_required(pool))\n\t\tdr_icm_pool_sync_all_buddy_pools(pool);\n\n\tmutex_unlock(&pool->mutex);\n}\n\nstruct mlx5dr_ste_htbl *mlx5dr_icm_pool_alloc_htbl(struct mlx5dr_icm_pool *pool)\n{\n\treturn kmem_cache_alloc(pool->dmn->htbls_kmem_cache, GFP_KERNEL);\n}\n\nvoid mlx5dr_icm_pool_free_htbl(struct mlx5dr_icm_pool *pool, struct mlx5dr_ste_htbl *htbl)\n{\n\tkmem_cache_free(pool->dmn->htbls_kmem_cache, htbl);\n}\n\nstruct mlx5dr_icm_pool *mlx5dr_icm_pool_create(struct mlx5dr_domain *dmn,\n\t\t\t\t\t       enum mlx5dr_icm_type icm_type)\n{\n\tu32 num_of_chunks, entry_size;\n\tstruct mlx5dr_icm_pool *pool;\n\tu32 max_hot_size = 0;\n\n\tpool = kvzalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpool->dmn = dmn;\n\tpool->icm_type = icm_type;\n\tpool->chunks_kmem_cache = dmn->chunks_kmem_cache;\n\n\tINIT_LIST_HEAD(&pool->buddy_mem_list);\n\tmutex_init(&pool->mutex);\n\n\tswitch (icm_type) {\n\tcase DR_ICM_TYPE_STE:\n\t\tpool->max_log_chunk_sz = dmn->info.max_log_sw_icm_sz;\n\t\tmax_hot_size = mlx5dr_icm_pool_chunk_size_to_byte(pool->max_log_chunk_sz,\n\t\t\t\t\t\t\t\t  pool->icm_type) *\n\t\t\t       DR_ICM_POOL_STE_HOT_MEM_PERCENT / 100;\n\t\tbreak;\n\tcase DR_ICM_TYPE_MODIFY_ACTION:\n\t\tpool->max_log_chunk_sz = dmn->info.max_log_action_icm_sz;\n\t\tmax_hot_size = mlx5dr_icm_pool_chunk_size_to_byte(pool->max_log_chunk_sz,\n\t\t\t\t\t\t\t\t  pool->icm_type) *\n\t\t\t       DR_ICM_POOL_MODIFY_ACTION_HOT_MEM_PERCENT / 100;\n\t\tbreak;\n\tcase DR_ICM_TYPE_MODIFY_HDR_PTRN:\n\t\tpool->max_log_chunk_sz = dmn->info.max_log_modify_hdr_pattern_icm_sz;\n\t\tmax_hot_size = mlx5dr_icm_pool_chunk_size_to_byte(pool->max_log_chunk_sz,\n\t\t\t\t\t\t\t\t  pool->icm_type) *\n\t\t\t       DR_ICM_POOL_MODIFY_HDR_PTRN_HOT_MEM_PERCENT / 100;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(icm_type);\n\t}\n\n\tentry_size = mlx5dr_icm_pool_dm_type_to_entry_size(pool->icm_type);\n\n\tnum_of_chunks = DIV_ROUND_UP(max_hot_size, entry_size) + 1;\n\tpool->th = max_hot_size;\n\n\tpool->hot_chunks_arr = kvcalloc(num_of_chunks,\n\t\t\t\t\tsizeof(struct mlx5dr_icm_hot_chunk),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!pool->hot_chunks_arr)\n\t\tgoto free_pool;\n\n\treturn pool;\n\nfree_pool:\n\tkvfree(pool);\n\treturn NULL;\n}\n\nvoid mlx5dr_icm_pool_destroy(struct mlx5dr_icm_pool *pool)\n{\n\tstruct mlx5dr_icm_buddy_mem *buddy, *tmp_buddy;\n\n\tdr_icm_pool_clear_hot_chunks_arr(pool);\n\n\tlist_for_each_entry_safe(buddy, tmp_buddy, &pool->buddy_mem_list, list_node)\n\t\tdr_icm_buddy_destroy(buddy);\n\n\tkvfree(pool->hot_chunks_arr);\n\tmutex_destroy(&pool->mutex);\n\tkvfree(pool);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}