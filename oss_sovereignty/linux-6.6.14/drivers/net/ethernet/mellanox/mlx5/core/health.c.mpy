{
  "module_name": "health.c",
  "hash_id": "f83e7fbad7cbe7b53ab0938056a30804a246d13fbeb197c0cda1f4c0f0e8028e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/health.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/hardirq.h>\n#include <linux/mlx5/driver.h>\n#include <linux/kern_levels.h>\n#include \"mlx5_core.h\"\n#include \"lib/eq.h\"\n#include \"lib/mlx5.h\"\n#include \"lib/events.h\"\n#include \"lib/pci_vsc.h\"\n#include \"lib/tout.h\"\n#include \"diag/fw_tracer.h\"\n#include \"diag/reporter_vnic.h\"\n\nenum {\n\tMAX_MISSES\t\t\t= 3,\n};\n\nenum {\n\tMLX5_DROP_HEALTH_WORK,\n};\n\nenum  {\n\tMLX5_SENSOR_NO_ERR\t\t= 0,\n\tMLX5_SENSOR_PCI_COMM_ERR\t= 1,\n\tMLX5_SENSOR_PCI_ERR\t\t= 2,\n\tMLX5_SENSOR_NIC_DISABLED\t= 3,\n\tMLX5_SENSOR_NIC_SW_RESET\t= 4,\n\tMLX5_SENSOR_FW_SYND_RFR\t\t= 5,\n};\n\nenum {\n\tMLX5_SEVERITY_MASK\t\t= 0x7,\n\tMLX5_SEVERITY_VALID_MASK\t= 0x8,\n};\n\nu8 mlx5_get_nic_state(struct mlx5_core_dev *dev)\n{\n\treturn (ioread32be(&dev->iseg->cmdq_addr_l_sz) >> 8) & 7;\n}\n\nvoid mlx5_set_nic_state(struct mlx5_core_dev *dev, u8 state)\n{\n\tu32 cur_cmdq_addr_l_sz;\n\n\tcur_cmdq_addr_l_sz = ioread32be(&dev->iseg->cmdq_addr_l_sz);\n\tiowrite32be((cur_cmdq_addr_l_sz & 0xFFFFF000) |\n\t\t    state << MLX5_NIC_IFC_OFFSET,\n\t\t    &dev->iseg->cmdq_addr_l_sz);\n}\n\nstatic bool sensor_pci_not_working(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\n\t \n\treturn (ioread32be(&h->fw_ver) == 0xffffffff);\n}\n\nstatic int mlx5_health_get_rfr(u8 rfr_severity)\n{\n\treturn rfr_severity >> MLX5_RFR_BIT_OFFSET;\n}\n\nstatic bool sensor_fw_synd_rfr(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu8 synd = ioread8(&h->synd);\n\tu8 rfr;\n\n\trfr = mlx5_health_get_rfr(ioread8(&h->rfr_severity));\n\n\tif (rfr && synd)\n\t\tmlx5_core_dbg(dev, \"FW requests reset, synd: %d\\n\", synd);\n\treturn rfr && synd;\n}\n\nu32 mlx5_health_check_fatal_sensors(struct mlx5_core_dev *dev)\n{\n\tif (sensor_pci_not_working(dev))\n\t\treturn MLX5_SENSOR_PCI_COMM_ERR;\n\tif (pci_channel_offline(dev->pdev))\n\t\treturn MLX5_SENSOR_PCI_ERR;\n\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)\n\t\treturn MLX5_SENSOR_NIC_DISABLED;\n\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_SW_RESET)\n\t\treturn MLX5_SENSOR_NIC_SW_RESET;\n\tif (sensor_fw_synd_rfr(dev))\n\t\treturn MLX5_SENSOR_FW_SYND_RFR;\n\n\treturn MLX5_SENSOR_NO_ERR;\n}\n\nstatic int lock_sem_sw_reset(struct mlx5_core_dev *dev, bool lock)\n{\n\tenum mlx5_vsc_state state;\n\tint ret;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EBUSY;\n\n\t \n\tret = mlx5_vsc_gw_lock(dev);\n\tif (ret == -EBUSY)\n\t\treturn -EINVAL;\n\tif (ret)\n\t\treturn ret;\n\n\tstate = lock ? MLX5_VSC_LOCK : MLX5_VSC_UNLOCK;\n\t \n\tret = mlx5_vsc_sem_set_space(dev, MLX5_SEMAPHORE_SW_RESET, state);\n\tif (ret)\n\t\tmlx5_core_warn(dev, \"Failed to lock SW reset semaphore\\n\");\n\n\t \n\tmlx5_vsc_gw_unlock(dev);\n\n\treturn ret;\n}\n\nstatic bool reset_fw_if_needed(struct mlx5_core_dev *dev)\n{\n\tbool supported = (ioread32be(&dev->iseg->initializing) >>\n\t\t\t  MLX5_FW_RESET_SUPPORTED_OFFSET) & 1;\n\tu32 fatal_error;\n\n\tif (!supported)\n\t\treturn false;\n\n\t \n\tfatal_error = mlx5_health_check_fatal_sensors(dev);\n\tif (fatal_error == MLX5_SENSOR_PCI_COMM_ERR ||\n\t    fatal_error == MLX5_SENSOR_NIC_DISABLED ||\n\t    fatal_error == MLX5_SENSOR_NIC_SW_RESET) {\n\t\tmlx5_core_warn(dev, \"Not issuing FW reset. Either it's already done or won't help.\");\n\t\treturn false;\n\t}\n\n\tmlx5_core_warn(dev, \"Issuing FW Reset\\n\");\n\t \n\tmlx5_set_nic_state(dev, MLX5_NIC_IFC_SW_RESET);\n\n\treturn true;\n}\n\nstatic void enter_error_state(struct mlx5_core_dev *dev, bool force)\n{\n\tif (mlx5_health_check_fatal_sensors(dev) || force) {  \n\t\tdev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\n\t\tmlx5_cmd_flush(dev);\n\t}\n\n\tmlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_SYS_ERROR, (void *)1);\n}\n\nvoid mlx5_enter_error_state(struct mlx5_core_dev *dev, bool force)\n{\n\tbool err_detected = false;\n\n\t \n\tif ((mlx5_health_check_fatal_sensors(dev) || force) &&\n\t    dev->state == MLX5_DEVICE_STATE_UP) {\n\t\tdev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\n\t\terr_detected = true;\n\t}\n\tmutex_lock(&dev->intf_state_mutex);\n\tif (!err_detected && dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto unlock; \n\n\tenter_error_state(dev, force);\nunlock:\n\tmutex_unlock(&dev->intf_state_mutex);\n}\n\nvoid mlx5_error_sw_reset(struct mlx5_core_dev *dev)\n{\n\tunsigned long end, delay_ms = mlx5_tout_ms(dev, PCI_TOGGLE);\n\tint lock = -EBUSY;\n\n\tmutex_lock(&dev->intf_state_mutex);\n\tif (dev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto unlock;\n\n\tmlx5_core_err(dev, \"start\\n\");\n\n\tif (mlx5_health_check_fatal_sensors(dev) == MLX5_SENSOR_FW_SYND_RFR) {\n\t\t \n\t\tlock = lock_sem_sw_reset(dev, true);\n\n\t\tif (lock == -EBUSY) {\n\t\t\tdelay_ms = mlx5_tout_ms(dev, FULL_CRDUMP);\n\t\t\tgoto recover_from_sw_reset;\n\t\t}\n\t\t \n\t\treset_fw_if_needed(dev);\n\t}\n\nrecover_from_sw_reset:\n\t \n\tend = jiffies + msecs_to_jiffies(delay_ms);\n\tdo {\n\t\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t} while (!time_after(jiffies, end));\n\n\tif (mlx5_get_nic_state(dev) != MLX5_NIC_IFC_DISABLED) {\n\t\tdev_err(&dev->pdev->dev, \"NIC IFC still %d after %lums.\\n\",\n\t\t\tmlx5_get_nic_state(dev), delay_ms);\n\t}\n\n\t \n\tif (!lock)\n\t\tlock_sem_sw_reset(dev, false);\n\n\tmlx5_core_err(dev, \"end\\n\");\n\nunlock:\n\tmutex_unlock(&dev->intf_state_mutex);\n}\n\nstatic void mlx5_handle_bad_state(struct mlx5_core_dev *dev)\n{\n\tu8 nic_interface = mlx5_get_nic_state(dev);\n\n\tswitch (nic_interface) {\n\tcase MLX5_NIC_IFC_FULL:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is full driver\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_DISABLED:\n\t\tmlx5_core_warn(dev, \"starting teardown\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_NO_DRAM_NIC:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is no dram nic\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_SW_RESET:\n\t\t \n\t\tif (dev->priv.health.fatal_error != MLX5_SENSOR_PCI_COMM_ERR)\n\t\t\tmlx5_core_warn(dev, \"NIC SW reset in progress\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is has invalid value %d\\n\",\n\t\t\t       nic_interface);\n\t}\n\n\tmlx5_disable_device(dev);\n}\n\nint mlx5_health_wait_pci_up(struct mlx5_core_dev *dev)\n{\n\tunsigned long end;\n\n\tend = jiffies + msecs_to_jiffies(mlx5_tout_ms(dev, FW_RESET));\n\twhile (sensor_pci_not_working(dev)) {\n\t\tif (time_after(jiffies, end))\n\t\t\treturn -ETIMEDOUT;\n\t\tif (test_bit(MLX5_BREAK_FW_WAIT, &dev->intf_state)) {\n\t\t\tmlx5_core_warn(dev, \"device is being removed, stop waiting for PCI\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmsleep(100);\n\t}\n\treturn 0;\n}\n\nstatic int mlx5_health_try_recover(struct mlx5_core_dev *dev)\n{\n\tmlx5_core_warn(dev, \"handling bad device here\\n\");\n\tmlx5_handle_bad_state(dev);\n\tif (mlx5_health_wait_pci_up(dev)) {\n\t\tmlx5_core_err(dev, \"health recovery flow aborted, PCI reads still not working\\n\");\n\t\treturn -EIO;\n\t}\n\tmlx5_core_err(dev, \"starting health recovery flow\\n\");\n\tif (mlx5_recover_device(dev) || mlx5_health_check_fatal_sensors(dev)) {\n\t\tmlx5_core_err(dev, \"health recovery failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmlx5_core_info(dev, \"health recovery succeeded\\n\");\n\treturn 0;\n}\n\nstatic const char *hsynd_str(u8 synd)\n{\n\tswitch (synd) {\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_FW_INTERNAL_ERR:\n\t\treturn \"firmware internal error\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_DEAD_IRISC:\n\t\treturn \"irisc not responding\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_HW_FATAL_ERR:\n\t\treturn \"unrecoverable hardware error\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_FW_CRC_ERR:\n\t\treturn \"firmware CRC error\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_ICM_FETCH_PCI_ERR:\n\t\treturn \"ICM fetch PCI error\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_ICM_PAGE_ERR:\n\t\treturn \"HW fatal error\\n\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_ASYNCHRONOUS_EQ_BUF_OVERRUN:\n\t\treturn \"async EQ buffer overrun\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_EQ_IN_ERR:\n\t\treturn \"EQ error\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_EQ_INV:\n\t\treturn \"Invalid EQ referenced\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_FFSER_ERR:\n\t\treturn \"FFSER error\";\n\tcase MLX5_INITIAL_SEG_HEALTH_SYNDROME_HIGH_TEMP_ERR:\n\t\treturn \"High temperature\";\n\tdefault:\n\t\treturn \"unrecognized error\";\n\t}\n}\n\nstatic const char *mlx5_loglevel_str(int level)\n{\n\tswitch (level) {\n\tcase LOGLEVEL_EMERG:\n\t\treturn \"EMERGENCY\";\n\tcase LOGLEVEL_ALERT:\n\t\treturn \"ALERT\";\n\tcase LOGLEVEL_CRIT:\n\t\treturn \"CRITICAL\";\n\tcase LOGLEVEL_ERR:\n\t\treturn \"ERROR\";\n\tcase LOGLEVEL_WARNING:\n\t\treturn \"WARNING\";\n\tcase LOGLEVEL_NOTICE:\n\t\treturn \"NOTICE\";\n\tcase LOGLEVEL_INFO:\n\t\treturn \"INFO\";\n\tcase LOGLEVEL_DEBUG:\n\t\treturn \"DEBUG\";\n\t}\n\treturn \"Unknown log level\";\n}\n\nstatic int mlx5_health_get_severity(u8 rfr_severity)\n{\n\treturn rfr_severity & MLX5_SEVERITY_VALID_MASK ?\n\t       rfr_severity & MLX5_SEVERITY_MASK : LOGLEVEL_ERR;\n}\n\nstatic void print_health_info(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu8 rfr_severity;\n\tint severity;\n\tint i;\n\n\t \n\tif (!ioread8(&h->synd))\n\t\treturn;\n\n\tif (ioread32be(&h->fw_ver) == 0xFFFFFFFF) {\n\t\tmlx5_log(dev, LOGLEVEL_ERR, \"PCI slot is unavailable\\n\");\n\t\treturn;\n\t}\n\n\trfr_severity = ioread8(&h->rfr_severity);\n\tseverity  = mlx5_health_get_severity(rfr_severity);\n\tmlx5_log(dev, severity, \"Health issue observed, %s, severity(%d) %s:\\n\",\n\t\t hsynd_str(ioread8(&h->synd)), severity, mlx5_loglevel_str(severity));\n\n\tfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++)\n\t\tmlx5_log(dev, severity, \"assert_var[%d] 0x%08x\\n\", i,\n\t\t\t ioread32be(h->assert_var + i));\n\n\tmlx5_log(dev, severity, \"assert_exit_ptr 0x%08x\\n\", ioread32be(&h->assert_exit_ptr));\n\tmlx5_log(dev, severity, \"assert_callra 0x%08x\\n\", ioread32be(&h->assert_callra));\n\tmlx5_log(dev, severity, \"fw_ver %d.%d.%d\", fw_rev_maj(dev), fw_rev_min(dev),\n\t\t fw_rev_sub(dev));\n\tmlx5_log(dev, severity, \"time %u\\n\", ioread32be(&h->time));\n\tmlx5_log(dev, severity, \"hw_id 0x%08x\\n\", ioread32be(&h->hw_id));\n\tmlx5_log(dev, severity, \"rfr %d\\n\", mlx5_health_get_rfr(rfr_severity));\n\tmlx5_log(dev, severity, \"severity %d (%s)\\n\", severity, mlx5_loglevel_str(severity));\n\tmlx5_log(dev, severity, \"irisc_index %d\\n\", ioread8(&h->irisc_index));\n\tmlx5_log(dev, severity, \"synd 0x%x: %s\\n\", ioread8(&h->synd),\n\t\t hsynd_str(ioread8(&h->synd)));\n\tmlx5_log(dev, severity, \"ext_synd 0x%04x\\n\", ioread16be(&h->ext_synd));\n\tmlx5_log(dev, severity, \"raw fw_ver 0x%08x\\n\", ioread32be(&h->fw_ver));\n}\n\nstatic int\nmlx5_fw_reporter_diagnose(struct devlink_health_reporter *reporter,\n\t\t\t  struct devlink_fmsg *fmsg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu8 synd;\n\tint err;\n\n\tsynd = ioread8(&h->synd);\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"Syndrome\", synd);\n\tif (err || !synd)\n\t\treturn err;\n\treturn devlink_fmsg_string_pair_put(fmsg, \"Description\", hsynd_str(synd));\n}\n\nstruct mlx5_fw_reporter_ctx {\n\tu8 err_synd;\n\tint miss_counter;\n};\n\nstatic int\nmlx5_fw_reporter_ctx_pairs_put(struct devlink_fmsg *fmsg,\n\t\t\t       struct mlx5_fw_reporter_ctx *fw_reporter_ctx)\n{\n\tint err;\n\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"syndrome\",\n\t\t\t\t       fw_reporter_ctx->err_synd);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"fw_miss_counter\",\n\t\t\t\t\tfw_reporter_ctx->miss_counter);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int\nmlx5_fw_reporter_heath_buffer_data_put(struct mlx5_core_dev *dev,\n\t\t\t\t       struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu8 rfr_severity;\n\tint err;\n\tint i;\n\n\tif (!ioread8(&h->synd))\n\t\treturn 0;\n\n\terr = devlink_fmsg_pair_nest_start(fmsg, \"health buffer\");\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_obj_nest_start(fmsg);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"assert_var\");\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++) {\n\t\terr = devlink_fmsg_u32_put(fmsg, ioread32be(h->assert_var + i));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"assert_exit_ptr\",\n\t\t\t\t\tioread32be(&h->assert_exit_ptr));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"assert_callra\",\n\t\t\t\t\tioread32be(&h->assert_callra));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"time\", ioread32be(&h->time));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"hw_id\", ioread32be(&h->hw_id));\n\tif (err)\n\t\treturn err;\n\trfr_severity = ioread8(&h->rfr_severity);\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"rfr\", mlx5_health_get_rfr(rfr_severity));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"severity\", mlx5_health_get_severity(rfr_severity));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"irisc_index\",\n\t\t\t\t       ioread8(&h->irisc_index));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"synd\", ioread8(&h->synd));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"ext_synd\",\n\t\t\t\t\tioread16be(&h->ext_synd));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"raw_fw_ver\",\n\t\t\t\t\tioread32be(&h->fw_ver));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\treturn devlink_fmsg_pair_nest_end(fmsg);\n}\n\nstatic int\nmlx5_fw_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t      struct devlink_fmsg *fmsg, void *priv_ctx,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tint err;\n\n\terr = mlx5_fw_tracer_trigger_core_dump_general(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mlx5_fw_reporter_heath_buffer_data_put(dev, fmsg);\n\tif (err)\n\t\treturn err;\n\treturn mlx5_fw_tracer_get_saved_traces_objects(dev->tracer, fmsg);\n}\n\nstatic void mlx5_fw_reporter_err_work(struct work_struct *work)\n{\n\tstruct mlx5_fw_reporter_ctx fw_reporter_ctx;\n\tstruct mlx5_core_health *health;\n\n\thealth = container_of(work, struct mlx5_core_health, report_work);\n\n\tif (IS_ERR_OR_NULL(health->fw_reporter))\n\t\treturn;\n\n\tfw_reporter_ctx.err_synd = health->synd;\n\tfw_reporter_ctx.miss_counter = health->miss_counter;\n\tif (fw_reporter_ctx.err_synd) {\n\t\tdevlink_health_report(health->fw_reporter,\n\t\t\t\t      \"FW syndrome reported\", &fw_reporter_ctx);\n\t\treturn;\n\t}\n\tif (fw_reporter_ctx.miss_counter)\n\t\tdevlink_health_report(health->fw_reporter,\n\t\t\t\t      \"FW miss counter reported\",\n\t\t\t\t      &fw_reporter_ctx);\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_fw_reporter_ops = {\n\t\t.name = \"fw\",\n\t\t.diagnose = mlx5_fw_reporter_diagnose,\n\t\t.dump = mlx5_fw_reporter_dump,\n};\n\nstatic int\nmlx5_fw_fatal_reporter_recover(struct devlink_health_reporter *reporter,\n\t\t\t       void *priv_ctx,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\n\treturn mlx5_health_try_recover(dev);\n}\n\nstatic int\nmlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tint err;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\tgoto free_data;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\n\terr = devlink_fmsg_binary_pair_put(fmsg, \"crdump_data\", cr_data, crdump_size);\n\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}\n\nstatic void mlx5_fw_fatal_reporter_err_work(struct work_struct *work)\n{\n\tstruct mlx5_fw_reporter_ctx fw_reporter_ctx;\n\tstruct mlx5_core_health *health;\n\tstruct mlx5_core_dev *dev;\n\tstruct devlink *devlink;\n\tstruct mlx5_priv *priv;\n\n\thealth = container_of(work, struct mlx5_core_health, fatal_report_work);\n\tpriv = container_of(health, struct mlx5_priv, health);\n\tdev = container_of(priv, struct mlx5_core_dev, priv);\n\tdevlink = priv_to_devlink(dev);\n\n\tmutex_lock(&dev->intf_state_mutex);\n\tif (test_bit(MLX5_DROP_HEALTH_WORK, &health->flags)) {\n\t\tmlx5_core_err(dev, \"health works are not permitted at this stage\\n\");\n\t\tmutex_unlock(&dev->intf_state_mutex);\n\t\treturn;\n\t}\n\tmutex_unlock(&dev->intf_state_mutex);\n\tenter_error_state(dev, false);\n\tif (IS_ERR_OR_NULL(health->fw_fatal_reporter)) {\n\t\tdevl_lock(devlink);\n\t\tif (mlx5_health_try_recover(dev))\n\t\t\tmlx5_core_err(dev, \"health recovery failed\\n\");\n\t\tdevl_unlock(devlink);\n\t\treturn;\n\t}\n\tfw_reporter_ctx.err_synd = health->synd;\n\tfw_reporter_ctx.miss_counter = health->miss_counter;\n\tif (devlink_health_report(health->fw_fatal_reporter,\n\t\t\t\t  \"FW fatal error reported\", &fw_reporter_ctx) == -ECANCELED) {\n\t\t \n\t\tmlx5_core_err(dev, \"Driver is in error state. Unloading\\n\");\n\t\tmlx5_unload_one(dev, false);\n\t}\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_fw_fatal_reporter_ops = {\n\t\t.name = \"fw_fatal\",\n\t\t.recover = mlx5_fw_fatal_reporter_recover,\n\t\t.dump = mlx5_fw_fatal_reporter_dump,\n};\n\n#define MLX5_FW_REPORTER_ECPF_GRACEFUL_PERIOD 180000\n#define MLX5_FW_REPORTER_PF_GRACEFUL_PERIOD 60000\n#define MLX5_FW_REPORTER_VF_GRACEFUL_PERIOD 30000\n#define MLX5_FW_REPORTER_DEFAULT_GRACEFUL_PERIOD MLX5_FW_REPORTER_VF_GRACEFUL_PERIOD\n\nvoid mlx5_fw_reporters_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct devlink *devlink = priv_to_devlink(dev);\n\tu64 grace_period;\n\n\tif (mlx5_core_is_ecpf(dev)) {\n\t\tgrace_period = MLX5_FW_REPORTER_ECPF_GRACEFUL_PERIOD;\n\t} else if (mlx5_core_is_pf(dev)) {\n\t\tgrace_period = MLX5_FW_REPORTER_PF_GRACEFUL_PERIOD;\n\t} else {\n\t\t \n\t\tgrace_period = MLX5_FW_REPORTER_DEFAULT_GRACEFUL_PERIOD;\n\t}\n\n\thealth->fw_reporter =\n\t\tdevl_health_reporter_create(devlink, &mlx5_fw_reporter_ops,\n\t\t\t\t\t    0, dev);\n\tif (IS_ERR(health->fw_reporter))\n\t\tmlx5_core_warn(dev, \"Failed to create fw reporter, err = %ld\\n\",\n\t\t\t       PTR_ERR(health->fw_reporter));\n\n\thealth->fw_fatal_reporter =\n\t\tdevl_health_reporter_create(devlink,\n\t\t\t\t\t    &mlx5_fw_fatal_reporter_ops,\n\t\t\t\t\t    grace_period,\n\t\t\t\t\t    dev);\n\tif (IS_ERR(health->fw_fatal_reporter))\n\t\tmlx5_core_warn(dev, \"Failed to create fw fatal reporter, err = %ld\\n\",\n\t\t\t       PTR_ERR(health->fw_fatal_reporter));\n}\n\nstatic void mlx5_fw_reporters_destroy(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tif (!IS_ERR_OR_NULL(health->fw_reporter))\n\t\tdevlink_health_reporter_destroy(health->fw_reporter);\n\n\tif (!IS_ERR_OR_NULL(health->fw_fatal_reporter))\n\t\tdevlink_health_reporter_destroy(health->fw_fatal_reporter);\n}\n\nstatic unsigned long get_next_poll_jiffies(struct mlx5_core_dev *dev)\n{\n\tunsigned long next;\n\n\tget_random_bytes(&next, sizeof(next));\n\tnext %= HZ;\n\tnext += jiffies + msecs_to_jiffies(mlx5_tout_ms(dev, HEALTH_POLL_INTERVAL));\n\n\treturn next;\n}\n\nvoid mlx5_trigger_health_work(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tif (!mlx5_dev_is_lightweight(dev))\n\t\tqueue_work(health->wq, &health->fatal_report_work);\n}\n\n#define MLX5_MSEC_PER_HOUR (MSEC_PER_SEC * 60 * 60)\nstatic void mlx5_health_log_ts_update(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tu32 out[MLX5_ST_SZ_DW(mrtc_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(mrtc_reg)] = {};\n\tstruct mlx5_core_health *health;\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_priv *priv;\n\tu64 now_us;\n\n\thealth = container_of(dwork, struct mlx5_core_health, update_fw_log_ts_work);\n\tpriv = container_of(health, struct mlx5_priv, health);\n\tdev = container_of(priv, struct mlx5_core_dev, priv);\n\n\tnow_us =  ktime_to_us(ktime_get_real());\n\n\tMLX5_SET(mrtc_reg, in, time_h, now_us >> 32);\n\tMLX5_SET(mrtc_reg, in, time_l, now_us & 0xFFFFFFFF);\n\tmlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out), MLX5_REG_MRTC, 0, 1);\n\n\tqueue_delayed_work(health->wq, &health->update_fw_log_ts_work,\n\t\t\t   msecs_to_jiffies(MLX5_MSEC_PER_HOUR));\n}\n\nstatic void poll_health(struct timer_list *t)\n{\n\tstruct mlx5_core_dev *dev = from_timer(dev, t, priv.health.timer);\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu32 fatal_error;\n\tu8 prev_synd;\n\tu32 count;\n\n\tif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto out;\n\n\tfatal_error = mlx5_health_check_fatal_sensors(dev);\n\n\tif (fatal_error && !health->fatal_error) {\n\t\tmlx5_core_err(dev, \"Fatal error %u detected\\n\", fatal_error);\n\t\tdev->priv.health.fatal_error = fatal_error;\n\t\tprint_health_info(dev);\n\t\tdev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\n\t\tmlx5_trigger_health_work(dev);\n\t\treturn;\n\t}\n\n\tcount = ioread32be(health->health_counter);\n\tif (count == health->prev)\n\t\t++health->miss_counter;\n\telse\n\t\thealth->miss_counter = 0;\n\n\thealth->prev = count;\n\tif (health->miss_counter == MAX_MISSES) {\n\t\tmlx5_core_err(dev, \"device's health compromised - reached miss count\\n\");\n\t\tprint_health_info(dev);\n\t\tqueue_work(health->wq, &health->report_work);\n\t}\n\n\tprev_synd = health->synd;\n\thealth->synd = ioread8(&h->synd);\n\tif (health->synd && health->synd != prev_synd)\n\t\tqueue_work(health->wq, &health->report_work);\n\nout:\n\tmod_timer(&health->timer, get_next_poll_jiffies(dev));\n}\n\nvoid mlx5_start_health_poll(struct mlx5_core_dev *dev)\n{\n\tu64 poll_interval_ms =  mlx5_tout_ms(dev, HEALTH_POLL_INTERVAL);\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\ttimer_setup(&health->timer, poll_health, 0);\n\thealth->fatal_error = MLX5_SENSOR_NO_ERR;\n\tclear_bit(MLX5_DROP_HEALTH_WORK, &health->flags);\n\thealth->health = &dev->iseg->health;\n\thealth->health_counter = &dev->iseg->health_counter;\n\n\thealth->timer.expires = jiffies + msecs_to_jiffies(poll_interval_ms);\n\tadd_timer(&health->timer);\n}\n\nvoid mlx5_stop_health_poll(struct mlx5_core_dev *dev, bool disable_health)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tif (disable_health)\n\t\tset_bit(MLX5_DROP_HEALTH_WORK, &health->flags);\n\n\tdel_timer_sync(&health->timer);\n}\n\nvoid mlx5_start_health_fw_log_up(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tif (mlx5_core_is_pf(dev) && MLX5_CAP_MCAM_REG(dev, mrtc))\n\t\tqueue_delayed_work(health->wq, &health->update_fw_log_ts_work, 0);\n}\n\nvoid mlx5_drain_health_wq(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tset_bit(MLX5_DROP_HEALTH_WORK, &health->flags);\n\tcancel_delayed_work_sync(&health->update_fw_log_ts_work);\n\tcancel_work_sync(&health->report_work);\n\tcancel_work_sync(&health->fatal_report_work);\n}\n\nvoid mlx5_health_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tcancel_delayed_work_sync(&health->update_fw_log_ts_work);\n\tdestroy_workqueue(health->wq);\n\tmlx5_reporter_vnic_destroy(dev);\n\tmlx5_fw_reporters_destroy(dev);\n}\n\nint mlx5_health_init(struct mlx5_core_dev *dev)\n{\n\tstruct devlink *devlink = priv_to_devlink(dev);\n\tstruct mlx5_core_health *health;\n\tchar *name;\n\n\tif (!mlx5_dev_is_lightweight(dev)) {\n\t\tdevl_lock(devlink);\n\t\tmlx5_fw_reporters_create(dev);\n\t\tdevl_unlock(devlink);\n\t}\n\tmlx5_reporter_vnic_create(dev);\n\n\thealth = &dev->priv.health;\n\tname = kmalloc(64, GFP_KERNEL);\n\tif (!name)\n\t\tgoto out_err;\n\n\tstrcpy(name, \"mlx5_health\");\n\tstrcat(name, dev_name(dev->device));\n\thealth->wq = create_singlethread_workqueue(name);\n\tkfree(name);\n\tif (!health->wq)\n\t\tgoto out_err;\n\tINIT_WORK(&health->fatal_report_work, mlx5_fw_fatal_reporter_err_work);\n\tINIT_WORK(&health->report_work, mlx5_fw_reporter_err_work);\n\tINIT_DELAYED_WORK(&health->update_fw_log_ts_work, mlx5_health_log_ts_update);\n\n\treturn 0;\n\nout_err:\n\tmlx5_reporter_vnic_destroy(dev);\n\tmlx5_fw_reporters_destroy(dev);\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}