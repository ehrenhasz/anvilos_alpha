{
  "module_name": "hwmon.c",
  "hash_id": "42fdb1fbb640a6697515b6f8d30e4549f7590c954a58f724b17c46179a82a902",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/hwmon.c",
  "human_readable_source": "\n\n\n#include <linux/hwmon.h>\n#include <linux/bitmap.h>\n#include <linux/mlx5/device.h>\n#include <linux/mlx5/mlx5_ifc.h>\n#include <linux/mlx5/port.h>\n#include \"mlx5_core.h\"\n#include \"hwmon.h\"\n\n#define CHANNELS_TYPE_NUM 2  \n#define CHIP_CONFIG_NUM 1\n\n \n#define to_mtmp_module_sensor_idx(idx) (64 + (idx))\n\n \n#define mtmp_temp_to_mdeg(temp) ((temp) * 125)\n\nstruct temp_channel_desc {\n\tu32 sensor_index;\n\tchar sensor_name[32];\n};\n\n \nstruct mlx5_hwmon {\n\tstruct mlx5_core_dev *mdev;\n\tstruct device *hwmon_dev;\n\tstruct hwmon_channel_info chip_info;\n\tu32 chip_channel_config[CHIP_CONFIG_NUM + 1];\n\tstruct hwmon_channel_info temp_info;\n\tu32 *temp_channel_config;\n\tconst struct hwmon_channel_info *channel_info[CHANNELS_TYPE_NUM + 1];\n\tstruct hwmon_chip_info chip;\n\tstruct temp_channel_desc *temp_channel_desc;\n\tu32 asic_platform_scount;\n\tu32 module_scount;\n};\n\nstatic int mlx5_hwmon_query_mtmp(struct mlx5_core_dev *mdev, u32 sensor_index, u32 *mtmp_out)\n{\n\tu32 mtmp_in[MLX5_ST_SZ_DW(mtmp_reg)] = {};\n\n\tMLX5_SET(mtmp_reg, mtmp_in, sensor_index, sensor_index);\n\n\treturn mlx5_core_access_reg(mdev, mtmp_in,  sizeof(mtmp_in),\n\t\t\t\t    mtmp_out, MLX5_ST_SZ_BYTES(mtmp_reg),\n\t\t\t\t    MLX5_REG_MTMP, 0, 0);\n}\n\nstatic int mlx5_hwmon_reset_max_temp(struct mlx5_core_dev *mdev, int sensor_index)\n{\n\tu32 mtmp_out[MLX5_ST_SZ_DW(mtmp_reg)] = {};\n\tu32 mtmp_in[MLX5_ST_SZ_DW(mtmp_reg)] = {};\n\n\tMLX5_SET(mtmp_reg, mtmp_in, sensor_index, sensor_index);\n\tMLX5_SET(mtmp_reg, mtmp_in, mtr, 1);\n\n\treturn mlx5_core_access_reg(mdev, mtmp_in,  sizeof(mtmp_in),\n\t\t\t\t    mtmp_out, sizeof(mtmp_out),\n\t\t\t\t    MLX5_REG_MTMP, 0, 0);\n}\n\nstatic int mlx5_hwmon_enable_max_temp(struct mlx5_core_dev *mdev, int sensor_index)\n{\n\tu32 mtmp_out[MLX5_ST_SZ_DW(mtmp_reg)] = {};\n\tu32 mtmp_in[MLX5_ST_SZ_DW(mtmp_reg)] = {};\n\tint err;\n\n\terr = mlx5_hwmon_query_mtmp(mdev, sensor_index, mtmp_in);\n\tif (err)\n\t\treturn err;\n\n\tMLX5_SET(mtmp_reg, mtmp_in, mte, 1);\n\treturn mlx5_core_access_reg(mdev, mtmp_in,  sizeof(mtmp_in),\n\t\t\t\t    mtmp_out, sizeof(mtmp_out),\n\t\t\t\t    MLX5_REG_MTMP, 0, 1);\n}\n\nstatic int mlx5_hwmon_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t   int channel, long *val)\n{\n\tstruct mlx5_hwmon *hwmon = dev_get_drvdata(dev);\n\tu32 mtmp_out[MLX5_ST_SZ_DW(mtmp_reg)] = {};\n\tint err;\n\n\tif (type != hwmon_temp)\n\t\treturn -EOPNOTSUPP;\n\n\terr = mlx5_hwmon_query_mtmp(hwmon->mdev, hwmon->temp_channel_desc[channel].sensor_index,\n\t\t\t\t    mtmp_out);\n\tif (err)\n\t\treturn err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t*val = mtmp_temp_to_mdeg(MLX5_GET(mtmp_reg, mtmp_out, temperature));\n\t\treturn 0;\n\tcase hwmon_temp_highest:\n\t\t*val = mtmp_temp_to_mdeg(MLX5_GET(mtmp_reg, mtmp_out, max_temperature));\n\t\treturn 0;\n\tcase hwmon_temp_crit:\n\t\t*val = mtmp_temp_to_mdeg(MLX5_GET(mtmp_reg, mtmp_out, temp_threshold_hi));\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlx5_hwmon_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t    int channel, long val)\n{\n\tstruct mlx5_hwmon *hwmon = dev_get_drvdata(dev);\n\n\tif (type != hwmon_temp || attr != hwmon_temp_reset_history)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_hwmon_reset_max_temp(hwmon->mdev,\n\t\t\t\thwmon->temp_channel_desc[channel].sensor_index);\n}\n\nstatic umode_t mlx5_hwmon_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t     int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_highest:\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_label:\n\t\treturn 0444;\n\tcase hwmon_temp_reset_history:\n\t\treturn 0200;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int mlx5_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t  int channel, const char **str)\n{\n\tstruct mlx5_hwmon *hwmon = dev_get_drvdata(dev);\n\n\tif (type != hwmon_temp || attr != hwmon_temp_label)\n\t\treturn -EOPNOTSUPP;\n\n\t*str = (const char *)hwmon->temp_channel_desc[channel].sensor_name;\n\treturn 0;\n}\n\nstatic const struct hwmon_ops mlx5_hwmon_ops = {\n\t.read = mlx5_hwmon_read,\n\t.read_string = mlx5_hwmon_read_string,\n\t.is_visible = mlx5_hwmon_is_visible,\n\t.write = mlx5_hwmon_write,\n};\n\nstatic int mlx5_hwmon_init_channels_names(struct mlx5_hwmon *hwmon)\n{\n\tu32 i;\n\n\tfor (i = 0; i < hwmon->asic_platform_scount + hwmon->module_scount; i++) {\n\t\tu32 mtmp_out[MLX5_ST_SZ_DW(mtmp_reg)] = {};\n\t\tchar *sensor_name;\n\t\tint err;\n\n\t\terr = mlx5_hwmon_query_mtmp(hwmon->mdev, hwmon->temp_channel_desc[i].sensor_index,\n\t\t\t\t\t    mtmp_out);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tsensor_name = MLX5_ADDR_OF(mtmp_reg, mtmp_out, sensor_name_hi);\n\t\tif (!*sensor_name) {\n\t\t\tsnprintf(hwmon->temp_channel_desc[i].sensor_name,\n\t\t\t\t sizeof(hwmon->temp_channel_desc[i].sensor_name), \"sensor%u\",\n\t\t\t\t hwmon->temp_channel_desc[i].sensor_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(&hwmon->temp_channel_desc[i].sensor_name, sensor_name,\n\t\t       MLX5_FLD_SZ_BYTES(mtmp_reg, sensor_name_hi) +\n\t\t       MLX5_FLD_SZ_BYTES(mtmp_reg, sensor_name_lo));\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5_hwmon_get_module_sensor_index(struct mlx5_core_dev *mdev, u32 *module_index)\n{\n\tint module_num;\n\tint err;\n\n\terr = mlx5_query_module_num(mdev, &module_num);\n\tif (err)\n\t\treturn err;\n\n\t*module_index = to_mtmp_module_sensor_idx(module_num);\n\n\treturn 0;\n}\n\nstatic int mlx5_hwmon_init_sensors_indexes(struct mlx5_hwmon *hwmon, u64 sensor_map)\n{\n\tDECLARE_BITMAP(smap, BITS_PER_TYPE(sensor_map));\n\tunsigned long bit_pos;\n\tint err = 0;\n\tint i = 0;\n\n\tbitmap_from_u64(smap, sensor_map);\n\n\tfor_each_set_bit(bit_pos, smap, BITS_PER_TYPE(sensor_map)) {\n\t\thwmon->temp_channel_desc[i].sensor_index = bit_pos;\n\t\ti++;\n\t}\n\n\tif (hwmon->module_scount)\n\t\terr = mlx5_hwmon_get_module_sensor_index(hwmon->mdev,\n\t\t\t\t\t\t\t &hwmon->temp_channel_desc[i].sensor_index);\n\n\treturn err;\n}\n\nstatic void mlx5_hwmon_channel_info_init(struct mlx5_hwmon *hwmon)\n{\n\tint i;\n\n\thwmon->channel_info[0] = &hwmon->chip_info;\n\thwmon->channel_info[1] = &hwmon->temp_info;\n\n\thwmon->chip_channel_config[0] = HWMON_C_REGISTER_TZ;\n\thwmon->chip_info.config = (const u32 *)hwmon->chip_channel_config;\n\thwmon->chip_info.type = hwmon_chip;\n\n\tfor (i = 0; i < hwmon->asic_platform_scount + hwmon->module_scount; i++)\n\t\thwmon->temp_channel_config[i] = HWMON_T_INPUT | HWMON_T_HIGHEST | HWMON_T_CRIT |\n\t\t\t\t\t     HWMON_T_RESET_HISTORY | HWMON_T_LABEL;\n\n\thwmon->temp_info.config = (const u32 *)hwmon->temp_channel_config;\n\thwmon->temp_info.type = hwmon_temp;\n}\n\nstatic int mlx5_hwmon_is_module_mon_cap(struct mlx5_core_dev *mdev, bool *mon_cap)\n{\n\tu32 mtmp_out[MLX5_ST_SZ_DW(mtmp_reg)];\n\tu32 module_index;\n\tint err;\n\n\terr = mlx5_hwmon_get_module_sensor_index(mdev, &module_index);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_hwmon_query_mtmp(mdev, module_index, mtmp_out);\n\tif (err)\n\t\treturn err;\n\n\tif (MLX5_GET(mtmp_reg, mtmp_out, temperature))\n\t\t*mon_cap = true;\n\n\treturn 0;\n}\n\nstatic int mlx5_hwmon_get_sensors_count(struct mlx5_core_dev *mdev, u32 *asic_platform_scount)\n{\n\tu32 mtcap_out[MLX5_ST_SZ_DW(mtcap_reg)] = {};\n\tu32 mtcap_in[MLX5_ST_SZ_DW(mtcap_reg)] = {};\n\tint err;\n\n\terr = mlx5_core_access_reg(mdev, mtcap_in,  sizeof(mtcap_in),\n\t\t\t\t   mtcap_out, sizeof(mtcap_out),\n\t\t\t\t   MLX5_REG_MTCAP, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\t*asic_platform_scount = MLX5_GET(mtcap_reg, mtcap_out, sensor_count);\n\n\treturn 0;\n}\n\nstatic void mlx5_hwmon_free(struct mlx5_hwmon *hwmon)\n{\n\tif (!hwmon)\n\t\treturn;\n\n\tkfree(hwmon->temp_channel_config);\n\tkfree(hwmon->temp_channel_desc);\n\tkfree(hwmon);\n}\n\nstatic struct mlx5_hwmon *mlx5_hwmon_alloc(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_hwmon *hwmon;\n\tbool mon_cap = false;\n\tu32 sensors_count;\n\tint err;\n\n\thwmon = kzalloc(sizeof(*mdev->hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlx5_hwmon_get_sensors_count(mdev, &hwmon->asic_platform_scount);\n\tif (err)\n\t\tgoto err_free_hwmon;\n\n\t \n\terr = mlx5_hwmon_is_module_mon_cap(mdev, &mon_cap);\n\tif (err)\n\t\tgoto err_free_hwmon;\n\n\thwmon->module_scount = mon_cap ? 1 : 0;\n\tsensors_count = hwmon->asic_platform_scount + hwmon->module_scount;\n\thwmon->temp_channel_desc = kcalloc(sensors_count, sizeof(*hwmon->temp_channel_desc),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!hwmon->temp_channel_desc) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_hwmon;\n\t}\n\n\t \n\thwmon->temp_channel_config = kcalloc(sensors_count + 1, sizeof(*hwmon->temp_channel_config),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!hwmon->temp_channel_config) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_temp_channel_desc;\n\t}\n\n\thwmon->mdev = mdev;\n\n\treturn hwmon;\n\nerr_free_temp_channel_desc:\n\tkfree(hwmon->temp_channel_desc);\nerr_free_hwmon:\n\tkfree(hwmon);\n\treturn ERR_PTR(err);\n}\n\nstatic int mlx5_hwmon_dev_init(struct mlx5_hwmon *hwmon)\n{\n\tu32 mtcap_out[MLX5_ST_SZ_DW(mtcap_reg)] = {};\n\tu32 mtcap_in[MLX5_ST_SZ_DW(mtcap_reg)] = {};\n\tint err;\n\tint i;\n\n\terr =  mlx5_core_access_reg(hwmon->mdev, mtcap_in,  sizeof(mtcap_in),\n\t\t\t\t    mtcap_out, sizeof(mtcap_out),\n\t\t\t\t    MLX5_REG_MTCAP, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tmlx5_hwmon_channel_info_init(hwmon);\n\tmlx5_hwmon_init_sensors_indexes(hwmon, MLX5_GET64(mtcap_reg, mtcap_out, sensor_map));\n\terr = mlx5_hwmon_init_channels_names(hwmon);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < hwmon->asic_platform_scount + hwmon->module_scount; i++) {\n\t\terr = mlx5_hwmon_enable_max_temp(hwmon->mdev,\n\t\t\t\t\t\t hwmon->temp_channel_desc[i].sensor_index);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thwmon->chip.ops = &mlx5_hwmon_ops;\n\thwmon->chip.info = (const struct hwmon_channel_info **)hwmon->channel_info;\n\n\treturn 0;\n}\n\nint mlx5_hwmon_dev_register(struct mlx5_core_dev *mdev)\n{\n\tstruct device *dev = mdev->device;\n\tstruct mlx5_hwmon *hwmon;\n\tint err;\n\n\tif (!MLX5_CAP_MCAM_REG(mdev, mtmp))\n\t\treturn 0;\n\n\thwmon = mlx5_hwmon_alloc(mdev);\n\tif (IS_ERR(hwmon))\n\t\treturn PTR_ERR(hwmon);\n\n\terr = mlx5_hwmon_dev_init(hwmon);\n\tif (err)\n\t\tgoto err_free_hwmon;\n\n\thwmon->hwmon_dev = hwmon_device_register_with_info(dev, \"mlx5\",\n\t\t\t\t\t\t\t   hwmon,\n\t\t\t\t\t\t\t   &hwmon->chip,\n\t\t\t\t\t\t\t   NULL);\n\tif (IS_ERR(hwmon->hwmon_dev)) {\n\t\terr = PTR_ERR(hwmon->hwmon_dev);\n\t\tgoto err_free_hwmon;\n\t}\n\n\tmdev->hwmon = hwmon;\n\treturn 0;\n\nerr_free_hwmon:\n\tmlx5_hwmon_free(hwmon);\n\treturn err;\n}\n\nvoid mlx5_hwmon_dev_unregister(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_hwmon *hwmon = mdev->hwmon;\n\n\tif (!hwmon)\n\t\treturn;\n\n\thwmon_device_unregister(hwmon->hwmon_dev);\n\tmlx5_hwmon_free(hwmon);\n\tmdev->hwmon = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}