{
  "module_name": "port.c",
  "hash_id": "8421c2de1d7b62339a61cb3b09b6ed415b88bf4e4db632189e574528b5c0a252",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/port.c",
  "human_readable_source": " \n\n#include <linux/mlx5/port.h>\n#include \"mlx5_core.h\"\n\n \nint mlx5_access_reg(struct mlx5_core_dev *dev, void *data_in, int size_in,\n\t\t    void *data_out, int size_out, u16 reg_id, int arg,\n\t\t    int write, bool verbose)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(access_register_out) + size_out;\n\tint inlen = MLX5_ST_SZ_BYTES(access_register_in) + size_in;\n\tint err = -ENOMEM;\n\tu32 *out = NULL;\n\tu32 *in = NULL;\n\tvoid *data;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!in || !out)\n\t\tgoto out;\n\n\tdata = MLX5_ADDR_OF(access_register_in, in, register_data);\n\tmemcpy(data, data_in, size_in);\n\n\tMLX5_SET(access_register_in, in, opcode, MLX5_CMD_OP_ACCESS_REG);\n\tMLX5_SET(access_register_in, in, op_mod, !write);\n\tMLX5_SET(access_register_in, in, argument, arg);\n\tMLX5_SET(access_register_in, in, register_id, reg_id);\n\n\terr = mlx5_cmd_do(dev, in, inlen, out, outlen);\n\tif (verbose)\n\t\terr = mlx5_cmd_check(dev, err, in, out);\n\tif (err)\n\t\tgoto out;\n\n\tdata = MLX5_ADDR_OF(access_register_out, out, register_data);\n\tmemcpy(data_out, data, size_out);\n\nout:\n\tkvfree(out);\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_access_reg);\n\nint mlx5_core_access_reg(struct mlx5_core_dev *dev, void *data_in,\n\t\t\t int size_in, void *data_out, int size_out,\n\t\t\t u16 reg_id, int arg, int write)\n{\n\treturn mlx5_access_reg(dev, data_in, size_in, data_out, size_out,\n\t\t\t       reg_id, arg, write, true);\n}\nEXPORT_SYMBOL_GPL(mlx5_core_access_reg);\n\nint mlx5_query_pcam_reg(struct mlx5_core_dev *dev, u32 *pcam, u8 feature_group,\n\t\t\tu8 access_reg_group)\n{\n\tu32 in[MLX5_ST_SZ_DW(pcam_reg)] = {0};\n\tint sz = MLX5_ST_SZ_BYTES(pcam_reg);\n\n\tMLX5_SET(pcam_reg, in, feature_group, feature_group);\n\tMLX5_SET(pcam_reg, in, access_reg_group, access_reg_group);\n\n\treturn mlx5_core_access_reg(dev, in, sz, pcam, sz, MLX5_REG_PCAM, 0, 0);\n}\n\nint mlx5_query_mcam_reg(struct mlx5_core_dev *dev, u32 *mcam, u8 feature_group,\n\t\t\tu8 access_reg_group)\n{\n\tu32 in[MLX5_ST_SZ_DW(mcam_reg)] = {0};\n\tint sz = MLX5_ST_SZ_BYTES(mcam_reg);\n\n\tMLX5_SET(mcam_reg, in, feature_group, feature_group);\n\tMLX5_SET(mcam_reg, in, access_reg_group, access_reg_group);\n\n\treturn mlx5_core_access_reg(dev, in, sz, mcam, sz, MLX5_REG_MCAM, 0, 0);\n}\n\nint mlx5_query_qcam_reg(struct mlx5_core_dev *mdev, u32 *qcam,\n\t\t\tu8 feature_group, u8 access_reg_group)\n{\n\tu32 in[MLX5_ST_SZ_DW(qcam_reg)] = {};\n\tint sz = MLX5_ST_SZ_BYTES(qcam_reg);\n\n\tMLX5_SET(qcam_reg, in, feature_group, feature_group);\n\tMLX5_SET(qcam_reg, in, access_reg_group, access_reg_group);\n\n\treturn mlx5_core_access_reg(mdev, in, sz, qcam, sz, MLX5_REG_QCAM, 0, 0);\n}\n\nstruct mlx5_reg_pcap {\n\tu8\t\t\trsvd0;\n\tu8\t\t\tport_num;\n\tu8\t\t\trsvd1[2];\n\t__be32\t\t\tcaps_127_96;\n\t__be32\t\t\tcaps_95_64;\n\t__be32\t\t\tcaps_63_32;\n\t__be32\t\t\tcaps_31_0;\n};\n\nint mlx5_set_port_caps(struct mlx5_core_dev *dev, u8 port_num, u32 caps)\n{\n\tstruct mlx5_reg_pcap in;\n\tstruct mlx5_reg_pcap out;\n\n\tmemset(&in, 0, sizeof(in));\n\tin.caps_127_96 = cpu_to_be32(caps);\n\tin.port_num = port_num;\n\n\treturn mlx5_core_access_reg(dev, &in, sizeof(in), &out,\n\t\t\t\t    sizeof(out), MLX5_REG_PCAP, 0, 1);\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_caps);\n\nint mlx5_query_port_ptys(struct mlx5_core_dev *dev, u32 *ptys,\n\t\t\t int ptys_size, int proto_mask, u8 local_port)\n{\n\tu32 in[MLX5_ST_SZ_DW(ptys_reg)] = {0};\n\n\tMLX5_SET(ptys_reg, in, local_port, local_port);\n\tMLX5_SET(ptys_reg, in, proto_mask, proto_mask);\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), ptys,\n\t\t\t\t    ptys_size, MLX5_REG_PTYS, 0, 0);\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_ptys);\n\nint mlx5_set_port_beacon(struct mlx5_core_dev *dev, u16 beacon_duration)\n{\n\tu32 in[MLX5_ST_SZ_DW(mlcr_reg)]  = {0};\n\tu32 out[MLX5_ST_SZ_DW(mlcr_reg)];\n\n\tMLX5_SET(mlcr_reg, in, local_port, 1);\n\tMLX5_SET(mlcr_reg, in, beacon_duration, beacon_duration);\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t    sizeof(out), MLX5_REG_MLCR, 0, 1);\n}\n\nint mlx5_query_ib_port_oper(struct mlx5_core_dev *dev, u16 *link_width_oper,\n\t\t\t    u16 *proto_oper, u8 local_port)\n{\n\tu32 out[MLX5_ST_SZ_DW(ptys_reg)];\n\tint err;\n\n\terr = mlx5_query_port_ptys(dev, out, sizeof(out), MLX5_PTYS_IB,\n\t\t\t\t   local_port);\n\tif (err)\n\t\treturn err;\n\n\t*link_width_oper = MLX5_GET(ptys_reg, out, ib_link_width_oper);\n\t*proto_oper = MLX5_GET(ptys_reg, out, ib_proto_oper);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mlx5_query_ib_port_oper);\n\n \nvoid mlx5_toggle_port_link(struct mlx5_core_dev *dev)\n{\n\tenum mlx5_port_status ps;\n\n\tmlx5_query_port_admin_status(dev, &ps);\n\tmlx5_set_port_admin_status(dev, MLX5_PORT_DOWN);\n\tif (ps == MLX5_PORT_UP)\n\t\tmlx5_set_port_admin_status(dev, MLX5_PORT_UP);\n}\nEXPORT_SYMBOL_GPL(mlx5_toggle_port_link);\n\nint mlx5_set_port_admin_status(struct mlx5_core_dev *dev,\n\t\t\t       enum mlx5_port_status status)\n{\n\tu32 in[MLX5_ST_SZ_DW(paos_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(paos_reg)];\n\n\tMLX5_SET(paos_reg, in, local_port, 1);\n\tMLX5_SET(paos_reg, in, admin_status, status);\n\tMLX5_SET(paos_reg, in, ase, 1);\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t    sizeof(out), MLX5_REG_PAOS, 0, 1);\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_admin_status);\n\nint mlx5_query_port_admin_status(struct mlx5_core_dev *dev,\n\t\t\t\t enum mlx5_port_status *status)\n{\n\tu32 in[MLX5_ST_SZ_DW(paos_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(paos_reg)];\n\tint err;\n\n\tMLX5_SET(paos_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_PAOS, 0, 0);\n\tif (err)\n\t\treturn err;\n\t*status = MLX5_GET(paos_reg, out, admin_status);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_admin_status);\n\nstatic void mlx5_query_port_mtu(struct mlx5_core_dev *dev, u16 *admin_mtu,\n\t\t\t\tu16 *max_mtu, u16 *oper_mtu, u8 port)\n{\n\tu32 in[MLX5_ST_SZ_DW(pmtu_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(pmtu_reg)];\n\n\tMLX5_SET(pmtu_reg, in, local_port, port);\n\tmlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t     sizeof(out), MLX5_REG_PMTU, 0, 0);\n\n\tif (max_mtu)\n\t\t*max_mtu  = MLX5_GET(pmtu_reg, out, max_mtu);\n\tif (oper_mtu)\n\t\t*oper_mtu = MLX5_GET(pmtu_reg, out, oper_mtu);\n\tif (admin_mtu)\n\t\t*admin_mtu = MLX5_GET(pmtu_reg, out, admin_mtu);\n}\n\nint mlx5_set_port_mtu(struct mlx5_core_dev *dev, u16 mtu, u8 port)\n{\n\tu32 in[MLX5_ST_SZ_DW(pmtu_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(pmtu_reg)];\n\n\tMLX5_SET(pmtu_reg, in, admin_mtu, mtu);\n\tMLX5_SET(pmtu_reg, in, local_port, port);\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_PMTU, 0, 1);\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_mtu);\n\nvoid mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, u16 *max_mtu,\n\t\t\t     u8 port)\n{\n\tmlx5_query_port_mtu(dev, NULL, max_mtu, NULL, port);\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_max_mtu);\n\nvoid mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, u16 *oper_mtu,\n\t\t\t      u8 port)\n{\n\tmlx5_query_port_mtu(dev, NULL, NULL, oper_mtu, port);\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_oper_mtu);\n\nint mlx5_query_module_num(struct mlx5_core_dev *dev, int *module_num)\n{\n\tu32 in[MLX5_ST_SZ_DW(pmlp_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(pmlp_reg)];\n\tint err;\n\n\tMLX5_SET(pmlp_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),\n\t\t\t\t   MLX5_REG_PMLP, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\t*module_num = MLX5_GET(lane_2_module_mapping,\n\t\t\t       MLX5_ADDR_OF(pmlp_reg, out, lane0_module_mapping),\n\t\t\t       module);\n\n\treturn 0;\n}\n\nstatic int mlx5_query_module_id(struct mlx5_core_dev *dev, int module_num,\n\t\t\t\tu8 *module_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(mcia_reg)] = {};\n\tu32 out[MLX5_ST_SZ_DW(mcia_reg)];\n\tint err, status;\n\tu8 *ptr;\n\n\tMLX5_SET(mcia_reg, in, i2c_device_address, MLX5_I2C_ADDR_LOW);\n\tMLX5_SET(mcia_reg, in, module, module_num);\n\tMLX5_SET(mcia_reg, in, device_address, 0);\n\tMLX5_SET(mcia_reg, in, page_number, 0);\n\tMLX5_SET(mcia_reg, in, size, 1);\n\tMLX5_SET(mcia_reg, in, l, 0);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_MCIA, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tstatus = MLX5_GET(mcia_reg, out, status);\n\tif (status) {\n\t\tmlx5_core_err(dev, \"query_mcia_reg failed: status: 0x%x\\n\",\n\t\t\t      status);\n\t\treturn -EIO;\n\t}\n\tptr = MLX5_ADDR_OF(mcia_reg, out, dword_0);\n\n\t*module_id = ptr[0];\n\n\treturn 0;\n}\n\nstatic int mlx5_qsfp_eeprom_page(u16 offset)\n{\n\tif (offset < MLX5_EEPROM_PAGE_LENGTH)\n\t\t \n\t\treturn 0;\n\n\t \n\treturn 1 + ((offset - MLX5_EEPROM_PAGE_LENGTH) /\n\t\t    MLX5_EEPROM_HIGH_PAGE_LENGTH);\n}\n\nstatic int mlx5_qsfp_eeprom_high_page_offset(int page_num)\n{\n\tif (!page_num)  \n\t\treturn 0;\n\n\t \n\treturn page_num * MLX5_EEPROM_HIGH_PAGE_LENGTH;\n}\n\nstatic void mlx5_qsfp_eeprom_params_set(u16 *i2c_addr, int *page_num, u16 *offset)\n{\n\t*i2c_addr = MLX5_I2C_ADDR_LOW;\n\t*page_num = mlx5_qsfp_eeprom_page(*offset);\n\t*offset -=  mlx5_qsfp_eeprom_high_page_offset(*page_num);\n}\n\nstatic void mlx5_sfp_eeprom_params_set(u16 *i2c_addr, int *page_num, u16 *offset)\n{\n\t*i2c_addr = MLX5_I2C_ADDR_LOW;\n\t*page_num = 0;\n\n\tif (*offset < MLX5_EEPROM_PAGE_LENGTH)\n\t\treturn;\n\n\t*i2c_addr = MLX5_I2C_ADDR_HIGH;\n\t*offset -= MLX5_EEPROM_PAGE_LENGTH;\n}\n\nstatic int mlx5_mcia_max_bytes(struct mlx5_core_dev *dev)\n{\n\t \n\treturn (MLX5_CAP_MCAM_FEATURE(dev, mcia_32dwords) ? 32 : 12) * sizeof(u32);\n}\n\nstatic int mlx5_query_mcia(struct mlx5_core_dev *dev,\n\t\t\t   struct mlx5_module_eeprom_query_params *params, u8 *data)\n{\n\tu32 in[MLX5_ST_SZ_DW(mcia_reg)] = {};\n\tu32 out[MLX5_ST_SZ_DW(mcia_reg)];\n\tint status, err;\n\tvoid *ptr;\n\tu16 size;\n\n\tsize = min_t(int, params->size, mlx5_mcia_max_bytes(dev));\n\n\tMLX5_SET(mcia_reg, in, l, 0);\n\tMLX5_SET(mcia_reg, in, size, size);\n\tMLX5_SET(mcia_reg, in, module, params->module_number);\n\tMLX5_SET(mcia_reg, in, device_address, params->offset);\n\tMLX5_SET(mcia_reg, in, page_number, params->page);\n\tMLX5_SET(mcia_reg, in, i2c_device_address, params->i2c_address);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_MCIA, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tstatus = MLX5_GET(mcia_reg, out, status);\n\tif (status) {\n\t\tmlx5_core_err(dev, \"query_mcia_reg failed: status: 0x%x\\n\",\n\t\t\t      status);\n\t\treturn -EIO;\n\t}\n\n\tptr = MLX5_ADDR_OF(mcia_reg, out, dword_0);\n\tmemcpy(data, ptr, size);\n\n\treturn size;\n}\n\nint mlx5_query_module_eeprom(struct mlx5_core_dev *dev,\n\t\t\t     u16 offset, u16 size, u8 *data)\n{\n\tstruct mlx5_module_eeprom_query_params query = {0};\n\tu8 module_id;\n\tint err;\n\n\terr = mlx5_query_module_num(dev, &query.module_number);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_query_module_id(dev, query.module_number, &module_id);\n\tif (err)\n\t\treturn err;\n\n\tswitch (module_id) {\n\tcase MLX5_MODULE_ID_SFP:\n\t\tmlx5_sfp_eeprom_params_set(&query.i2c_address, &query.page, &offset);\n\t\tbreak;\n\tcase MLX5_MODULE_ID_QSFP:\n\tcase MLX5_MODULE_ID_QSFP_PLUS:\n\tcase MLX5_MODULE_ID_QSFP28:\n\t\tmlx5_qsfp_eeprom_params_set(&query.i2c_address, &query.page, &offset);\n\t\tbreak;\n\tdefault:\n\t\tmlx5_core_err(dev, \"Module ID not recognized: 0x%x\\n\", module_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > MLX5_EEPROM_PAGE_LENGTH)\n\t\t \n\t\tsize = MLX5_EEPROM_PAGE_LENGTH - offset;\n\n\tquery.size = size;\n\tquery.offset = offset;\n\n\treturn mlx5_query_mcia(dev, &query, data);\n}\nEXPORT_SYMBOL_GPL(mlx5_query_module_eeprom);\n\nint mlx5_query_module_eeprom_by_page(struct mlx5_core_dev *dev,\n\t\t\t\t     struct mlx5_module_eeprom_query_params *params,\n\t\t\t\t     u8 *data)\n{\n\tint err;\n\n\terr = mlx5_query_module_num(dev, &params->module_number);\n\tif (err)\n\t\treturn err;\n\n\tif (params->i2c_address != MLX5_I2C_ADDR_HIGH &&\n\t    params->i2c_address != MLX5_I2C_ADDR_LOW) {\n\t\tmlx5_core_err(dev, \"I2C address not recognized: 0x%x\\n\", params->i2c_address);\n\t\treturn -EINVAL;\n\t}\n\n\treturn mlx5_query_mcia(dev, params, data);\n}\nEXPORT_SYMBOL_GPL(mlx5_query_module_eeprom_by_page);\n\nstatic int mlx5_query_port_pvlc(struct mlx5_core_dev *dev, u32 *pvlc,\n\t\t\t\tint pvlc_size,  u8 local_port)\n{\n\tu32 in[MLX5_ST_SZ_DW(pvlc_reg)] = {0};\n\n\tMLX5_SET(pvlc_reg, in, local_port, local_port);\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), pvlc,\n\t\t\t\t    pvlc_size, MLX5_REG_PVLC, 0, 0);\n}\n\nint mlx5_query_port_vl_hw_cap(struct mlx5_core_dev *dev,\n\t\t\t      u8 *vl_hw_cap, u8 local_port)\n{\n\tu32 out[MLX5_ST_SZ_DW(pvlc_reg)];\n\tint err;\n\n\terr = mlx5_query_port_pvlc(dev, out, sizeof(out), local_port);\n\tif (err)\n\t\treturn err;\n\n\t*vl_hw_cap = MLX5_GET(pvlc_reg, out, vl_hw_cap);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_vl_hw_cap);\n\nstatic int mlx5_query_pfcc_reg(struct mlx5_core_dev *dev, u32 *out,\n\t\t\t       u32 out_size)\n{\n\tu32 in[MLX5_ST_SZ_DW(pfcc_reg)] = {0};\n\n\tMLX5_SET(pfcc_reg, in, local_port, 1);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t    out_size, MLX5_REG_PFCC, 0, 0);\n}\n\nint mlx5_set_port_pause(struct mlx5_core_dev *dev, u32 rx_pause, u32 tx_pause)\n{\n\tu32 in[MLX5_ST_SZ_DW(pfcc_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(pfcc_reg)];\n\n\tMLX5_SET(pfcc_reg, in, local_port, 1);\n\tMLX5_SET(pfcc_reg, in, pptx, tx_pause);\n\tMLX5_SET(pfcc_reg, in, pprx, rx_pause);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t    sizeof(out), MLX5_REG_PFCC, 0, 1);\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_pause);\n\nint mlx5_query_port_pause(struct mlx5_core_dev *dev,\n\t\t\t  u32 *rx_pause, u32 *tx_pause)\n{\n\tu32 out[MLX5_ST_SZ_DW(pfcc_reg)];\n\tint err;\n\n\terr = mlx5_query_pfcc_reg(dev, out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tif (rx_pause)\n\t\t*rx_pause = MLX5_GET(pfcc_reg, out, pprx);\n\n\tif (tx_pause)\n\t\t*tx_pause = MLX5_GET(pfcc_reg, out, pptx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_pause);\n\nint mlx5_set_port_stall_watermark(struct mlx5_core_dev *dev,\n\t\t\t\t  u16 stall_critical_watermark,\n\t\t\t\t  u16 stall_minor_watermark)\n{\n\tu32 in[MLX5_ST_SZ_DW(pfcc_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(pfcc_reg)];\n\n\tMLX5_SET(pfcc_reg, in, local_port, 1);\n\tMLX5_SET(pfcc_reg, in, pptx_mask_n, 1);\n\tMLX5_SET(pfcc_reg, in, pprx_mask_n, 1);\n\tMLX5_SET(pfcc_reg, in, ppan_mask_n, 1);\n\tMLX5_SET(pfcc_reg, in, critical_stall_mask, 1);\n\tMLX5_SET(pfcc_reg, in, minor_stall_mask, 1);\n\tMLX5_SET(pfcc_reg, in, device_stall_critical_watermark,\n\t\t stall_critical_watermark);\n\tMLX5_SET(pfcc_reg, in, device_stall_minor_watermark, stall_minor_watermark);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t    sizeof(out), MLX5_REG_PFCC, 0, 1);\n}\n\nint mlx5_query_port_stall_watermark(struct mlx5_core_dev *dev,\n\t\t\t\t    u16 *stall_critical_watermark,\n\t\t\t\t    u16 *stall_minor_watermark)\n{\n\tu32 out[MLX5_ST_SZ_DW(pfcc_reg)];\n\tint err;\n\n\terr = mlx5_query_pfcc_reg(dev, out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tif (stall_critical_watermark)\n\t\t*stall_critical_watermark = MLX5_GET(pfcc_reg, out,\n\t\t\t\t\t\t     device_stall_critical_watermark);\n\n\tif (stall_minor_watermark)\n\t\t*stall_minor_watermark = MLX5_GET(pfcc_reg, out,\n\t\t\t\t\t\t  device_stall_minor_watermark);\n\n\treturn 0;\n}\n\nint mlx5_set_port_pfc(struct mlx5_core_dev *dev, u8 pfc_en_tx, u8 pfc_en_rx)\n{\n\tu32 in[MLX5_ST_SZ_DW(pfcc_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(pfcc_reg)];\n\n\tMLX5_SET(pfcc_reg, in, local_port, 1);\n\tMLX5_SET(pfcc_reg, in, pfctx, pfc_en_tx);\n\tMLX5_SET(pfcc_reg, in, pfcrx, pfc_en_rx);\n\tMLX5_SET_TO_ONES(pfcc_reg, in, prio_mask_tx);\n\tMLX5_SET_TO_ONES(pfcc_reg, in, prio_mask_rx);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t    sizeof(out), MLX5_REG_PFCC, 0, 1);\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_pfc);\n\nint mlx5_query_port_pfc(struct mlx5_core_dev *dev, u8 *pfc_en_tx, u8 *pfc_en_rx)\n{\n\tu32 out[MLX5_ST_SZ_DW(pfcc_reg)];\n\tint err;\n\n\terr = mlx5_query_pfcc_reg(dev, out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tif (pfc_en_tx)\n\t\t*pfc_en_tx = MLX5_GET(pfcc_reg, out, pfctx);\n\n\tif (pfc_en_rx)\n\t\t*pfc_en_rx = MLX5_GET(pfcc_reg, out, pfcrx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_pfc);\n\nint mlx5_max_tc(struct mlx5_core_dev *mdev)\n{\n\tu8 num_tc = MLX5_CAP_GEN(mdev, max_tc) ? : 8;\n\n\treturn num_tc - 1;\n}\n\nint mlx5_query_port_dcbx_param(struct mlx5_core_dev *mdev, u32 *out)\n{\n\tu32 in[MLX5_ST_SZ_DW(dcbx_param)] = {0};\n\n\tMLX5_SET(dcbx_param, in, port_number, 1);\n\n\treturn  mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t    sizeof(in), MLX5_REG_DCBX_PARAM, 0, 0);\n}\n\nint mlx5_set_port_dcbx_param(struct mlx5_core_dev *mdev, u32 *in)\n{\n\tu32 out[MLX5_ST_SZ_DW(dcbx_param)];\n\n\tMLX5_SET(dcbx_param, in, port_number, 1);\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(out), out,\n\t\t\t\t    sizeof(out), MLX5_REG_DCBX_PARAM, 0, 1);\n}\n\nint mlx5_set_port_prio_tc(struct mlx5_core_dev *mdev, u8 *prio_tc)\n{\n\tu32 in[MLX5_ST_SZ_DW(qtct_reg)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(qtct_reg)];\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (prio_tc[i] > mlx5_max_tc(mdev))\n\t\t\treturn -EINVAL;\n\n\t\tMLX5_SET(qtct_reg, in, prio, i);\n\t\tMLX5_SET(qtct_reg, in, tclass, prio_tc[i]);\n\n\t\terr = mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t\t   sizeof(out), MLX5_REG_QTCT, 0, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_prio_tc);\n\nint mlx5_query_port_prio_tc(struct mlx5_core_dev *mdev,\n\t\t\t    u8 prio, u8 *tc)\n{\n\tu32 in[MLX5_ST_SZ_DW(qtct_reg)];\n\tu32 out[MLX5_ST_SZ_DW(qtct_reg)];\n\tint err;\n\n\tmemset(in, 0, sizeof(in));\n\tmemset(out, 0, sizeof(out));\n\n\tMLX5_SET(qtct_reg, in, port_number, 1);\n\tMLX5_SET(qtct_reg, in, prio, prio);\n\n\terr = mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_QTCT, 0, 0);\n\tif (!err)\n\t\t*tc = MLX5_GET(qtct_reg, out, tclass);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_prio_tc);\n\nstatic int mlx5_set_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *in,\n\t\t\t\t   int inlen)\n{\n\tu32 out[MLX5_ST_SZ_DW(qetc_reg)];\n\n\tif (!MLX5_CAP_GEN(mdev, ets))\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_core_access_reg(mdev, in, inlen, out, sizeof(out),\n\t\t\t\t    MLX5_REG_QETCR, 0, 1);\n}\n\nstatic int mlx5_query_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *out,\n\t\t\t\t     int outlen)\n{\n\tu32 in[MLX5_ST_SZ_DW(qetc_reg)];\n\n\tif (!MLX5_CAP_GEN(mdev, ets))\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(in, 0, sizeof(in));\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), out, outlen,\n\t\t\t\t    MLX5_REG_QETCR, 0, 0);\n}\n\nint mlx5_set_port_tc_group(struct mlx5_core_dev *mdev, u8 *tc_group)\n{\n\tu32 in[MLX5_ST_SZ_DW(qetc_reg)] = {0};\n\tint i;\n\n\tfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\n\t\tMLX5_SET(qetc_reg, in, tc_configuration[i].g, 1);\n\t\tMLX5_SET(qetc_reg, in, tc_configuration[i].group, tc_group[i]);\n\t}\n\n\treturn mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_tc_group);\n\nint mlx5_query_port_tc_group(struct mlx5_core_dev *mdev,\n\t\t\t     u8 tc, u8 *tc_group)\n{\n\tu32 out[MLX5_ST_SZ_DW(qetc_reg)];\n\tvoid *ets_tcn_conf;\n\tint err;\n\n\terr = mlx5_query_port_qetcr_reg(mdev, out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tets_tcn_conf = MLX5_ADDR_OF(qetc_reg, out,\n\t\t\t\t    tc_configuration[tc]);\n\n\t*tc_group = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,\n\t\t\t     group);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_tc_group);\n\nint mlx5_set_port_tc_bw_alloc(struct mlx5_core_dev *mdev, u8 *tc_bw)\n{\n\tu32 in[MLX5_ST_SZ_DW(qetc_reg)] = {0};\n\tint i;\n\n\tfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\n\t\tMLX5_SET(qetc_reg, in, tc_configuration[i].b, 1);\n\t\tMLX5_SET(qetc_reg, in, tc_configuration[i].bw_allocation, tc_bw[i]);\n\t}\n\n\treturn mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_tc_bw_alloc);\n\nint mlx5_query_port_tc_bw_alloc(struct mlx5_core_dev *mdev,\n\t\t\t\tu8 tc, u8 *bw_pct)\n{\n\tu32 out[MLX5_ST_SZ_DW(qetc_reg)];\n\tvoid *ets_tcn_conf;\n\tint err;\n\n\terr = mlx5_query_port_qetcr_reg(mdev, out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tets_tcn_conf = MLX5_ADDR_OF(qetc_reg, out,\n\t\t\t\t    tc_configuration[tc]);\n\n\t*bw_pct = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,\n\t\t\t   bw_allocation);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_tc_bw_alloc);\n\nint mlx5_modify_port_ets_rate_limit(struct mlx5_core_dev *mdev,\n\t\t\t\t    u8 *max_bw_value,\n\t\t\t\t    u8 *max_bw_units)\n{\n\tu32 in[MLX5_ST_SZ_DW(qetc_reg)] = {0};\n\tvoid *ets_tcn_conf;\n\tint i;\n\n\tMLX5_SET(qetc_reg, in, port_number, 1);\n\n\tfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\n\t\tets_tcn_conf = MLX5_ADDR_OF(qetc_reg, in, tc_configuration[i]);\n\n\t\tMLX5_SET(ets_tcn_config_reg, ets_tcn_conf, r, 1);\n\t\tMLX5_SET(ets_tcn_config_reg, ets_tcn_conf, max_bw_units,\n\t\t\t max_bw_units[i]);\n\t\tMLX5_SET(ets_tcn_config_reg, ets_tcn_conf, max_bw_value,\n\t\t\t max_bw_value[i]);\n\t}\n\n\treturn mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));\n}\nEXPORT_SYMBOL_GPL(mlx5_modify_port_ets_rate_limit);\n\nint mlx5_query_port_ets_rate_limit(struct mlx5_core_dev *mdev,\n\t\t\t\t   u8 *max_bw_value,\n\t\t\t\t   u8 *max_bw_units)\n{\n\tu32 out[MLX5_ST_SZ_DW(qetc_reg)];\n\tvoid *ets_tcn_conf;\n\tint err;\n\tint i;\n\n\terr = mlx5_query_port_qetcr_reg(mdev, out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\n\t\tets_tcn_conf = MLX5_ADDR_OF(qetc_reg, out, tc_configuration[i]);\n\n\t\tmax_bw_value[i] = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,\n\t\t\t\t\t   max_bw_value);\n\t\tmax_bw_units[i] = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,\n\t\t\t\t\t   max_bw_units);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_ets_rate_limit);\n\nint mlx5_set_port_wol(struct mlx5_core_dev *mdev, u8 wol_mode)\n{\n\tu32 in[MLX5_ST_SZ_DW(set_wol_rol_in)] = {};\n\n\tMLX5_SET(set_wol_rol_in, in, opcode, MLX5_CMD_OP_SET_WOL_ROL);\n\tMLX5_SET(set_wol_rol_in, in, wol_mode_valid, 1);\n\tMLX5_SET(set_wol_rol_in, in, wol_mode, wol_mode);\n\treturn mlx5_cmd_exec_in(mdev, set_wol_rol, in);\n}\nEXPORT_SYMBOL_GPL(mlx5_set_port_wol);\n\nint mlx5_query_port_wol(struct mlx5_core_dev *mdev, u8 *wol_mode)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_wol_rol_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_wol_rol_in)] = {};\n\tint err;\n\n\tMLX5_SET(query_wol_rol_in, in, opcode, MLX5_CMD_OP_QUERY_WOL_ROL);\n\terr = mlx5_cmd_exec_inout(mdev, query_wol_rol, in, out);\n\tif (!err)\n\t\t*wol_mode = MLX5_GET(query_wol_rol_out, out, wol_mode);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_port_wol);\n\nint mlx5_query_ports_check(struct mlx5_core_dev *mdev, u32 *out, int outlen)\n{\n\tu32 in[MLX5_ST_SZ_DW(pcmr_reg)] = {0};\n\n\tMLX5_SET(pcmr_reg, in, local_port, 1);\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t    outlen, MLX5_REG_PCMR, 0, 0);\n}\n\nint mlx5_set_ports_check(struct mlx5_core_dev *mdev, u32 *in, int inlen)\n{\n\tu32 out[MLX5_ST_SZ_DW(pcmr_reg)];\n\n\treturn mlx5_core_access_reg(mdev, in, inlen, out,\n\t\t\t\t    sizeof(out), MLX5_REG_PCMR, 0, 1);\n}\n\nint mlx5_set_port_fcs(struct mlx5_core_dev *mdev, u8 enable)\n{\n\tu32 in[MLX5_ST_SZ_DW(pcmr_reg)] = {0};\n\tint err;\n\n\terr = mlx5_query_ports_check(mdev, in, sizeof(in));\n\tif (err)\n\t\treturn err;\n\tMLX5_SET(pcmr_reg, in, local_port, 1);\n\tMLX5_SET(pcmr_reg, in, fcs_chk, enable);\n\treturn mlx5_set_ports_check(mdev, in, sizeof(in));\n}\n\nvoid mlx5_query_port_fcs(struct mlx5_core_dev *mdev, bool *supported,\n\t\t\t bool *enabled)\n{\n\tu32 out[MLX5_ST_SZ_DW(pcmr_reg)];\n\t \n\t*supported = false;\n\t*enabled = true;\n\n\tif (!MLX5_CAP_GEN(mdev, ports_check))\n\t\treturn;\n\n\tif (mlx5_query_ports_check(mdev, out, sizeof(out)))\n\t\treturn;\n\n\t*supported = !!(MLX5_GET(pcmr_reg, out, fcs_cap));\n\t*enabled = !!(MLX5_GET(pcmr_reg, out, fcs_chk));\n}\n\nint mlx5_query_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size)\n{\n\tu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), mtpps,\n\t\t\t\t    mtpps_size, MLX5_REG_MTPPS, 0, 0);\n}\n\nint mlx5_set_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size)\n{\n\tu32 out[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\n\n\treturn mlx5_core_access_reg(mdev, mtpps, mtpps_size, out,\n\t\t\t\t    sizeof(out), MLX5_REG_MTPPS, 0, 1);\n}\n\nint mlx5_query_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 *arm, u8 *mode)\n{\n\tu32 out[MLX5_ST_SZ_DW(mtppse_reg)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(mtppse_reg)] = {0};\n\tint err = 0;\n\n\tMLX5_SET(mtppse_reg, in, pin, pin);\n\n\terr = mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_MTPPSE, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\t*arm = MLX5_GET(mtppse_reg, in, event_arm);\n\t*mode = MLX5_GET(mtppse_reg, in, event_generation_mode);\n\n\treturn err;\n}\n\nint mlx5_set_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 arm, u8 mode)\n{\n\tu32 out[MLX5_ST_SZ_DW(mtppse_reg)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(mtppse_reg)] = {0};\n\n\tMLX5_SET(mtppse_reg, in, pin, pin);\n\tMLX5_SET(mtppse_reg, in, event_arm, arm);\n\tMLX5_SET(mtppse_reg, in, event_generation_mode, mode);\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t    sizeof(out), MLX5_REG_MTPPSE, 0, 1);\n}\n\nint mlx5_set_trust_state(struct mlx5_core_dev *mdev, u8 trust_state)\n{\n\tu32 out[MLX5_ST_SZ_DW(qpts_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(qpts_reg)] = {};\n\tint err;\n\n\tMLX5_SET(qpts_reg, in, local_port, 1);\n\tMLX5_SET(qpts_reg, in, trust_state, trust_state);\n\n\terr = mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_QPTS, 0, 1);\n\treturn err;\n}\n\nint mlx5_query_trust_state(struct mlx5_core_dev *mdev, u8 *trust_state)\n{\n\tu32 out[MLX5_ST_SZ_DW(qpts_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(qpts_reg)] = {};\n\tint err;\n\n\tMLX5_SET(qpts_reg, in, local_port, 1);\n\n\terr = mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_QPTS, 0, 0);\n\tif (!err)\n\t\t*trust_state = MLX5_GET(qpts_reg, out, trust_state);\n\n\treturn err;\n}\n\nint mlx5_set_dscp2prio(struct mlx5_core_dev *mdev, u8 dscp, u8 prio)\n{\n\tint sz = MLX5_ST_SZ_BYTES(qpdpm_reg);\n\tvoid *qpdpm_dscp;\n\tvoid *out;\n\tvoid *in;\n\tint err;\n\n\tin = kzalloc(sz, GFP_KERNEL);\n\tout = kzalloc(sz, GFP_KERNEL);\n\tif (!in || !out) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpdpm_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_QPDPM, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(in, out, sz);\n\tMLX5_SET(qpdpm_reg, in, local_port, 1);\n\n\t \n\tqpdpm_dscp = MLX5_ADDR_OF(qpdpm_reg, in, dscp[dscp]);\n\tMLX5_SET16(qpdpm_dscp_reg, qpdpm_dscp, prio, prio);\n\tMLX5_SET16(qpdpm_dscp_reg, qpdpm_dscp, e, 1);\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_QPDPM, 0, 1);\n\nout:\n\tkfree(in);\n\tkfree(out);\n\treturn err;\n}\n\n \n#define MLX5E_SUPPORTED_DSCP 64\nint mlx5_query_dscp2prio(struct mlx5_core_dev *mdev, u8 *dscp2prio)\n{\n\tint sz = MLX5_ST_SZ_BYTES(qpdpm_reg);\n\tvoid *qpdpm_dscp;\n\tvoid *out;\n\tvoid *in;\n\tint err;\n\tint i;\n\n\tin = kzalloc(sz, GFP_KERNEL);\n\tout = kzalloc(sz, GFP_KERNEL);\n\tif (!in || !out) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpdpm_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_QPDPM, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\tfor (i = 0; i < (MLX5E_SUPPORTED_DSCP); i++) {\n\t\tqpdpm_dscp = MLX5_ADDR_OF(qpdpm_reg, out, dscp[i]);\n\t\tdscp2prio[i] = MLX5_GET16(qpdpm_dscp_reg, qpdpm_dscp, prio);\n\t}\n\nout:\n\tkfree(in);\n\tkfree(out);\n\treturn err;\n}\n\n \nstatic const u32 mlx5e_link_speed[MLX5E_LINK_MODES_NUMBER] = {\n\t[MLX5E_1000BASE_CX_SGMII] = 1000,\n\t[MLX5E_1000BASE_KX]       = 1000,\n\t[MLX5E_10GBASE_CX4]       = 10000,\n\t[MLX5E_10GBASE_KX4]       = 10000,\n\t[MLX5E_10GBASE_KR]        = 10000,\n\t[MLX5E_20GBASE_KR2]       = 20000,\n\t[MLX5E_40GBASE_CR4]       = 40000,\n\t[MLX5E_40GBASE_KR4]       = 40000,\n\t[MLX5E_56GBASE_R4]        = 56000,\n\t[MLX5E_10GBASE_CR]        = 10000,\n\t[MLX5E_10GBASE_SR]        = 10000,\n\t[MLX5E_10GBASE_ER]        = 10000,\n\t[MLX5E_40GBASE_SR4]       = 40000,\n\t[MLX5E_40GBASE_LR4]       = 40000,\n\t[MLX5E_50GBASE_SR2]       = 50000,\n\t[MLX5E_100GBASE_CR4]      = 100000,\n\t[MLX5E_100GBASE_SR4]      = 100000,\n\t[MLX5E_100GBASE_KR4]      = 100000,\n\t[MLX5E_100GBASE_LR4]      = 100000,\n\t[MLX5E_100BASE_TX]        = 100,\n\t[MLX5E_1000BASE_T]        = 1000,\n\t[MLX5E_10GBASE_T]         = 10000,\n\t[MLX5E_25GBASE_CR]        = 25000,\n\t[MLX5E_25GBASE_KR]        = 25000,\n\t[MLX5E_25GBASE_SR]        = 25000,\n\t[MLX5E_50GBASE_CR2]       = 50000,\n\t[MLX5E_50GBASE_KR2]       = 50000,\n};\n\nstatic const u32 mlx5e_ext_link_speed[MLX5E_EXT_LINK_MODES_NUMBER] = {\n\t[MLX5E_SGMII_100M] = 100,\n\t[MLX5E_1000BASE_X_SGMII] = 1000,\n\t[MLX5E_5GBASE_R] = 5000,\n\t[MLX5E_10GBASE_XFI_XAUI_1] = 10000,\n\t[MLX5E_40GBASE_XLAUI_4_XLPPI_4] = 40000,\n\t[MLX5E_25GAUI_1_25GBASE_CR_KR] = 25000,\n\t[MLX5E_50GAUI_2_LAUI_2_50GBASE_CR2_KR2] = 50000,\n\t[MLX5E_50GAUI_1_LAUI_1_50GBASE_CR_KR] = 50000,\n\t[MLX5E_CAUI_4_100GBASE_CR4_KR4] = 100000,\n\t[MLX5E_100GAUI_2_100GBASE_CR2_KR2] = 100000,\n\t[MLX5E_200GAUI_4_200GBASE_CR4_KR4] = 200000,\n\t[MLX5E_400GAUI_8] = 400000,\n\t[MLX5E_100GAUI_1_100GBASE_CR_KR] = 100000,\n\t[MLX5E_200GAUI_2_200GBASE_CR2_KR2] = 200000,\n\t[MLX5E_400GAUI_4_400GBASE_CR4_KR4] = 400000,\n};\n\nint mlx5_port_query_eth_proto(struct mlx5_core_dev *dev, u8 port, bool ext,\n\t\t\t      struct mlx5_port_eth_proto *eproto)\n{\n\tu32 out[MLX5_ST_SZ_DW(ptys_reg)];\n\tint err;\n\n\tif (!eproto)\n\t\treturn -EINVAL;\n\n\terr = mlx5_query_port_ptys(dev, out, sizeof(out), MLX5_PTYS_EN, port);\n\tif (err)\n\t\treturn err;\n\n\teproto->cap   = MLX5_GET_ETH_PROTO(ptys_reg, out, ext,\n\t\t\t\t\t   eth_proto_capability);\n\teproto->admin = MLX5_GET_ETH_PROTO(ptys_reg, out, ext, eth_proto_admin);\n\teproto->oper  = MLX5_GET_ETH_PROTO(ptys_reg, out, ext, eth_proto_oper);\n\treturn 0;\n}\n\nbool mlx5_ptys_ext_supported(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_port_eth_proto eproto;\n\tint err;\n\n\tif (MLX5_CAP_PCAM_FEATURE(mdev, ptys_extended_ethernet))\n\t\treturn true;\n\n\terr = mlx5_port_query_eth_proto(mdev, 1, true, &eproto);\n\tif (err)\n\t\treturn false;\n\n\treturn !!eproto.cap;\n}\n\nstatic void mlx5e_port_get_speed_arr(struct mlx5_core_dev *mdev,\n\t\t\t\t     const u32 **arr, u32 *size,\n\t\t\t\t     bool force_legacy)\n{\n\tbool ext = force_legacy ? false : mlx5_ptys_ext_supported(mdev);\n\n\t*size = ext ? ARRAY_SIZE(mlx5e_ext_link_speed) :\n\t\t      ARRAY_SIZE(mlx5e_link_speed);\n\t*arr  = ext ? mlx5e_ext_link_speed : mlx5e_link_speed;\n}\n\nu32 mlx5_port_ptys2speed(struct mlx5_core_dev *mdev, u32 eth_proto_oper,\n\t\t\t bool force_legacy)\n{\n\tunsigned long temp = eth_proto_oper;\n\tconst u32 *table;\n\tu32 speed = 0;\n\tu32 max_size;\n\tint i;\n\n\tmlx5e_port_get_speed_arr(mdev, &table, &max_size, force_legacy);\n\ti = find_first_bit(&temp, max_size);\n\tif (i < max_size)\n\t\tspeed = table[i];\n\treturn speed;\n}\n\nu32 mlx5_port_speed2linkmodes(struct mlx5_core_dev *mdev, u32 speed,\n\t\t\t      bool force_legacy)\n{\n\tu32 link_modes = 0;\n\tconst u32 *table;\n\tu32 max_size;\n\tint i;\n\n\tmlx5e_port_get_speed_arr(mdev, &table, &max_size, force_legacy);\n\tfor (i = 0; i < max_size; ++i) {\n\t\tif (table[i] == speed)\n\t\t\tlink_modes |= MLX5E_PROT_MASK(i);\n\t}\n\treturn link_modes;\n}\n\nint mlx5_port_max_linkspeed(struct mlx5_core_dev *mdev, u32 *speed)\n{\n\tstruct mlx5_port_eth_proto eproto;\n\tu32 max_speed = 0;\n\tconst u32 *table;\n\tu32 max_size;\n\tbool ext;\n\tint err;\n\tint i;\n\n\text = mlx5_ptys_ext_supported(mdev);\n\terr = mlx5_port_query_eth_proto(mdev, 1, ext, &eproto);\n\tif (err)\n\t\treturn err;\n\n\tmlx5e_port_get_speed_arr(mdev, &table, &max_size, false);\n\tfor (i = 0; i < max_size; ++i)\n\t\tif (eproto.cap & MLX5E_PROT_MASK(i))\n\t\t\tmax_speed = max(max_speed, table[i]);\n\n\t*speed = max_speed;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}