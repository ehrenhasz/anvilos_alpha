{
  "module_name": "fs_tt_redirect.c",
  "hash_id": "a978e4037167f7381016e99d5d809c30fbdc9523d235f058c9a2fd420110ecbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c",
  "human_readable_source": "\n \n\n#include \"en/fs_tt_redirect.h\"\n#include \"fs_core.h\"\n#include \"mlx5_core.h\"\n\nenum fs_udp_type {\n\tFS_IPV4_UDP,\n\tFS_IPV6_UDP,\n\tFS_UDP_NUM_TYPES,\n};\n\nstruct mlx5e_fs_udp {\n\tstruct mlx5e_flow_table tables[FS_UDP_NUM_TYPES];\n\tstruct mlx5_flow_handle *default_rules[FS_UDP_NUM_TYPES];\n\tint ref_cnt;\n};\n\nstruct mlx5e_fs_any {\n\tstruct mlx5e_flow_table table;\n\tstruct mlx5_flow_handle *default_rule;\n\tint ref_cnt;\n};\n\nstatic char *fs_udp_type2str(enum fs_udp_type i)\n{\n\tswitch (i) {\n\tcase FS_IPV4_UDP:\n\t\treturn \"UDP v4\";\n\tdefault:  \n\t\treturn \"UDP v6\";\n\t}\n}\n\nstatic enum mlx5_traffic_types fs_udp2tt(enum fs_udp_type i)\n{\n\tswitch (i) {\n\tcase FS_IPV4_UDP:\n\t\treturn MLX5_TT_IPV4_UDP;\n\tdefault:  \n\t\treturn MLX5_TT_IPV6_UDP;\n\t}\n}\n\nstatic enum fs_udp_type tt2fs_udp(enum mlx5_traffic_types i)\n{\n\tswitch (i) {\n\tcase MLX5_TT_IPV4_UDP:\n\t\treturn FS_IPV4_UDP;\n\tcase MLX5_TT_IPV6_UDP:\n\t\treturn FS_IPV6_UDP;\n\tdefault:\n\t\treturn FS_UDP_NUM_TYPES;\n\t}\n}\n\nvoid mlx5e_fs_tt_redirect_del_rule(struct mlx5_flow_handle *rule)\n{\n\tmlx5_del_flow_rules(rule);\n}\n\nstatic void fs_udp_set_dport_flow(struct mlx5_flow_spec *spec, enum fs_udp_type type,\n\t\t\t\t  u16 udp_dport)\n{\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, IPPROTO_UDP);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version,\n\t\t type == FS_IPV4_UDP ? 4 : 6);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.udp_dport);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.udp_dport, udp_dport);\n}\n\nstruct mlx5_flow_handle *\nmlx5e_fs_tt_redirect_udp_add_rule(struct mlx5e_flow_steering *fs,\n\t\t\t\t  enum mlx5_traffic_types ttc_type,\n\t\t\t\t  u32 tir_num, u16 d_port)\n{\n\tstruct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);\n\tenum fs_udp_type type = tt2fs_udp(ttc_type);\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_table *ft = NULL;\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err;\n\n\tif (type == FS_UDP_NUM_TYPES)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tft = fs_udp->tables[type].t;\n\n\tfs_udp_set_dport_flow(spec, type, d_port);\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\tdest.tir_num = tir_num;\n\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);\n\tkvfree(spec);\n\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tfs_err(fs, \"%s: add %s rule failed, err %d\\n\",\n\t\t       __func__, fs_udp_type2str(type), err);\n\t}\n\treturn rule;\n}\n\nstatic int fs_udp_add_default_rule(struct mlx5e_flow_steering *fs, enum fs_udp_type type)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tstruct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);\n\tstruct mlx5e_flow_table *fs_udp_t;\n\tstruct mlx5_flow_destination dest;\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tint err;\n\n\tfs_udp_t = &fs_udp->tables[type];\n\n\tdest = mlx5_ttc_get_default_dest(ttc, fs_udp2tt(type));\n\trule = mlx5_add_flow_rules(fs_udp_t->t, NULL, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tfs_err(fs, \"%s: add default rule failed, fs type=%d, err %d\\n\",\n\t\t       __func__, type, err);\n\t\treturn err;\n\t}\n\n\tfs_udp->default_rules[type] = rule;\n\treturn 0;\n}\n\n#define MLX5E_FS_UDP_NUM_GROUPS\t(2)\n#define MLX5E_FS_UDP_GROUP1_SIZE\t(BIT(16))\n#define MLX5E_FS_UDP_GROUP2_SIZE\t(BIT(0))\n#define MLX5E_FS_UDP_TABLE_SIZE\t\t(MLX5E_FS_UDP_GROUP1_SIZE +\\\n\t\t\t\t\t MLX5E_FS_UDP_GROUP2_SIZE)\nstatic int fs_udp_create_groups(struct mlx5e_flow_table *ft, enum fs_udp_type type)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tvoid *outer_headers_c;\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tft->g = kcalloc(MLX5E_FS_UDP_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif  (!in || !ft->g) {\n\t\tkfree(ft->g);\n\t\tft->g = NULL;\n\t\tkvfree(in);\n\t\treturn -ENOMEM;\n\t}\n\n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\touter_headers_c = MLX5_ADDR_OF(fte_match_param, mc, outer_headers);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ip_protocol);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ip_version);\n\n\tswitch (type) {\n\tcase FS_IPV4_UDP:\n\tcase FS_IPV6_UDP:\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, udp_dport);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_FS_UDP_GROUP1_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_FS_UDP_GROUP2_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ft->g[ft->num_groups]);\n\tft->g[ft->num_groups] = NULL;\nout:\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int fs_udp_create_table(struct mlx5e_flow_steering *fs, enum fs_udp_type type)\n{\n\tstruct mlx5_flow_namespace *ns = mlx5e_fs_get_ns(fs, false);\n\tstruct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5e_flow_table *ft;\n\tint err;\n\n\tft = &fs_udp->tables[type];\n\tft->num_groups = 0;\n\n\tft_attr.max_fte = MLX5E_FS_UDP_TABLE_SIZE;\n\tft_attr.level = MLX5E_FS_TT_UDP_FT_LEVEL;\n\tft_attr.prio = MLX5E_NIC_PRIO;\n\n\tft->t = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft->t)) {\n\t\terr = PTR_ERR(ft->t);\n\t\tft->t = NULL;\n\t\treturn err;\n\t}\n\n\tmlx5_core_dbg(mlx5e_fs_get_mdev(fs), \"Created fs %s table id %u level %u\\n\",\n\t\t      fs_udp_type2str(type), ft->t->id, ft->t->level);\n\n\terr = fs_udp_create_groups(ft, type);\n\tif (err)\n\t\tgoto err;\n\n\terr = fs_udp_add_default_rule(fs, type);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tmlx5e_destroy_flow_table(ft);\n\treturn err;\n}\n\nstatic void fs_udp_destroy_table(struct mlx5e_fs_udp *fs_udp, int i)\n{\n\tif (IS_ERR_OR_NULL(fs_udp->tables[i].t))\n\t\treturn;\n\n\tmlx5_del_flow_rules(fs_udp->default_rules[i]);\n\tmlx5e_destroy_flow_table(&fs_udp->tables[i]);\n\tfs_udp->tables[i].t = NULL;\n}\n\nstatic int fs_udp_disable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tint err, i;\n\n\tfor (i = 0; i < FS_UDP_NUM_TYPES; i++) {\n\t\t \n\t\terr = mlx5_ttc_fwd_default_dest(ttc, fs_udp2tt(i));\n\t\tif (err) {\n\t\t\tfs_err(fs, \"%s: modify ttc[%d] default destination failed, err(%d)\\n\",\n\t\t\t       __func__, fs_udp2tt(i), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fs_udp_enable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tstruct mlx5e_fs_udp *udp = mlx5e_fs_get_udp(fs);\n\tstruct mlx5_flow_destination dest = {};\n\tint err, i;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tfor (i = 0; i < FS_UDP_NUM_TYPES; i++) {\n\t\tdest.ft = udp->tables[i].t;\n\n\t\t \n\t\terr = mlx5_ttc_fwd_dest(ttc, fs_udp2tt(i), &dest);\n\t\tif (err) {\n\t\t\tfs_err(fs, \"%s: modify ttc[%d] destination to accel failed, err(%d)\\n\",\n\t\t\t       __func__, fs_udp2tt(i), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid mlx5e_fs_tt_redirect_udp_destroy(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);\n\tint i;\n\n\tif (!fs_udp)\n\t\treturn;\n\n\tif (--fs_udp->ref_cnt)\n\t\treturn;\n\n\tfs_udp_disable(fs);\n\n\tfor (i = 0; i < FS_UDP_NUM_TYPES; i++)\n\t\tfs_udp_destroy_table(fs_udp, i);\n\n\tkfree(fs_udp);\n\tmlx5e_fs_set_udp(fs, NULL);\n}\n\nint mlx5e_fs_tt_redirect_udp_create(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_fs_udp *udp = mlx5e_fs_get_udp(fs);\n\tint i, err;\n\n\tif (udp) {\n\t\tudp->ref_cnt++;\n\t\treturn 0;\n\t}\n\n\tudp = kzalloc(sizeof(*udp), GFP_KERNEL);\n\tif (!udp)\n\t\treturn -ENOMEM;\n\tmlx5e_fs_set_udp(fs, udp);\n\n\tfor (i = 0; i < FS_UDP_NUM_TYPES; i++) {\n\t\terr = fs_udp_create_table(fs, i);\n\t\tif (err)\n\t\t\tgoto err_destroy_tables;\n\t}\n\n\terr = fs_udp_enable(fs);\n\tif (err)\n\t\tgoto err_destroy_tables;\n\n\tudp->ref_cnt = 1;\n\n\treturn 0;\n\nerr_destroy_tables:\n\twhile (--i >= 0)\n\t\tfs_udp_destroy_table(udp, i);\n\n\tkfree(udp);\n\tmlx5e_fs_set_udp(fs, NULL);\n\treturn err;\n}\n\nstatic void fs_any_set_ethertype_flow(struct mlx5_flow_spec *spec, u16 ether_type)\n{\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ethertype);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ethertype, ether_type);\n}\n\nstruct mlx5_flow_handle *\nmlx5e_fs_tt_redirect_any_add_rule(struct mlx5e_flow_steering *fs,\n\t\t\t\t  u32 tir_num, u16 ether_type)\n{\n\tstruct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_table *ft = NULL;\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tft = fs_any->table.t;\n\n\tfs_any_set_ethertype_flow(spec, ether_type);\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\tdest.tir_num = tir_num;\n\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);\n\tkvfree(spec);\n\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tfs_err(fs, \"%s: add ANY rule failed, err %d\\n\",\n\t\t       __func__, err);\n\t}\n\treturn rule;\n}\n\nstatic int fs_any_add_default_rule(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tstruct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);\n\tstruct mlx5e_flow_table *fs_any_t;\n\tstruct mlx5_flow_destination dest;\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tint err;\n\n\tfs_any_t = &fs_any->table;\n\tdest = mlx5_ttc_get_default_dest(ttc, MLX5_TT_ANY);\n\trule = mlx5_add_flow_rules(fs_any_t->t, NULL, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tfs_err(fs, \"%s: add default rule failed, fs type=ANY, err %d\\n\",\n\t\t       __func__, err);\n\t\treturn err;\n\t}\n\n\tfs_any->default_rule = rule;\n\treturn 0;\n}\n\n#define MLX5E_FS_ANY_NUM_GROUPS\t(2)\n#define MLX5E_FS_ANY_GROUP1_SIZE\t(BIT(16))\n#define MLX5E_FS_ANY_GROUP2_SIZE\t(BIT(0))\n#define MLX5E_FS_ANY_TABLE_SIZE\t\t(MLX5E_FS_ANY_GROUP1_SIZE +\\\n\t\t\t\t\t MLX5E_FS_ANY_GROUP2_SIZE)\n\nstatic int fs_any_create_groups(struct mlx5e_flow_table *ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tvoid *outer_headers_c;\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tft->g = kcalloc(MLX5E_FS_UDP_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif  (!in || !ft->g) {\n\t\tkfree(ft->g);\n\t\tkvfree(in);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\touter_headers_c = MLX5_ADDR_OF(fte_match_param, mc, outer_headers);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ethertype);\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_FS_ANY_GROUP1_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_FS_ANY_GROUP2_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ft->g[ft->num_groups]);\n\tft->g[ft->num_groups] = NULL;\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int fs_any_create_table(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_flow_namespace *ns = mlx5e_fs_get_ns(fs, false);\n\tstruct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);\n\tstruct mlx5e_flow_table *ft = &fs_any->table;\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tint err;\n\n\tft->num_groups = 0;\n\n\tft_attr.max_fte = MLX5E_FS_UDP_TABLE_SIZE;\n\tft_attr.level = MLX5E_FS_TT_ANY_FT_LEVEL;\n\tft_attr.prio = MLX5E_NIC_PRIO;\n\n\tft->t = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft->t)) {\n\t\terr = PTR_ERR(ft->t);\n\t\tft->t = NULL;\n\t\treturn err;\n\t}\n\n\tmlx5_core_dbg(mlx5e_fs_get_mdev(fs), \"Created fs ANY table id %u level %u\\n\",\n\t\t      ft->t->id, ft->t->level);\n\n\terr = fs_any_create_groups(ft);\n\tif (err)\n\t\tgoto err;\n\n\terr = fs_any_add_default_rule(fs);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tmlx5e_destroy_flow_table(ft);\n\treturn err;\n}\n\nstatic int fs_any_disable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tint err;\n\n\t \n\terr = mlx5_ttc_fwd_default_dest(ttc, MLX5_TT_ANY);\n\tif (err) {\n\t\tfs_err(fs,\n\t\t       \"%s: modify ttc[%d] default destination failed, err(%d)\\n\",\n\t\t       __func__, MLX5_TT_ANY, err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fs_any_enable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tstruct mlx5e_fs_any *any = mlx5e_fs_get_any(fs);\n\tstruct mlx5_flow_destination dest = {};\n\tint err;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = any->table.t;\n\n\t \n\terr = mlx5_ttc_fwd_dest(ttc, MLX5_TT_ANY, &dest);\n\tif (err) {\n\t\tfs_err(fs,\n\t\t       \"%s: modify ttc[%d] destination to accel failed, err(%d)\\n\",\n\t\t       __func__, MLX5_TT_ANY, err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void fs_any_destroy_table(struct mlx5e_fs_any *fs_any)\n{\n\tif (IS_ERR_OR_NULL(fs_any->table.t))\n\t\treturn;\n\n\tmlx5_del_flow_rules(fs_any->default_rule);\n\tmlx5e_destroy_flow_table(&fs_any->table);\n\tfs_any->table.t = NULL;\n}\n\nvoid mlx5e_fs_tt_redirect_any_destroy(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);\n\n\tif (!fs_any)\n\t\treturn;\n\n\tif (--fs_any->ref_cnt)\n\t\treturn;\n\n\tfs_any_disable(fs);\n\n\tfs_any_destroy_table(fs_any);\n\n\tkfree(fs_any);\n\tmlx5e_fs_set_any(fs, NULL);\n}\n\nint mlx5e_fs_tt_redirect_any_create(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);\n\tint err;\n\n\tif (fs_any) {\n\t\tfs_any->ref_cnt++;\n\t\treturn 0;\n\t}\n\n\tfs_any = kzalloc(sizeof(*fs_any), GFP_KERNEL);\n\tif (!fs_any)\n\t\treturn -ENOMEM;\n\tmlx5e_fs_set_any(fs, fs_any);\n\n\terr = fs_any_create_table(fs);\n\tif (err)\n\t\tgoto err_free_any;\n\n\terr = fs_any_enable(fs);\n\tif (err)\n\t\tgoto err_destroy_table;\n\n\tfs_any->ref_cnt = 1;\n\n\treturn 0;\n\nerr_destroy_table:\n\tfs_any_destroy_table(fs_any);\nerr_free_any:\n\tmlx5e_fs_set_any(fs, NULL);\n\tkfree(fs_any);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}