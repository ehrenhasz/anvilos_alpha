{
  "module_name": "tc_tun.c",
  "hash_id": "4ba7aa0b8814eed3328acf8903b71f42d3a5040bff3dde668484ee49e38bac8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c",
  "human_readable_source": " \n \n\n#include <net/inet_ecn.h>\n#include <net/vxlan.h>\n#include <net/gre.h>\n#include <net/geneve.h>\n#include <net/bareudp.h>\n#include \"en/tc_tun.h\"\n#include \"en/tc_priv.h\"\n#include \"en_tc.h\"\n#include \"rep/tc.h\"\n#include \"rep/neigh.h\"\n#include \"lag/lag.h\"\n#include \"lag/mp.h\"\n\nstruct mlx5e_tc_tun_route_attr {\n\tstruct net_device *out_dev;\n\tstruct net_device *route_dev;\n\tunion {\n\t\tstruct flowi4 fl4;\n\t\tstruct flowi6 fl6;\n\t} fl;\n\tstruct neighbour *n;\n\tu8 ttl;\n};\n\n#define TC_TUN_ROUTE_ATTR_INIT(name) struct mlx5e_tc_tun_route_attr name = {}\n\nstatic void mlx5e_tc_tun_route_attr_cleanup(struct mlx5e_tc_tun_route_attr *attr)\n{\n\tif (attr->n)\n\t\tneigh_release(attr->n);\n\tif (attr->route_dev)\n\t\tdev_put(attr->route_dev);\n}\n\nstruct mlx5e_tc_tunnel *mlx5e_get_tc_tun(struct net_device *tunnel_dev)\n{\n\tif (netif_is_vxlan(tunnel_dev))\n\t\treturn &vxlan_tunnel;\n\telse if (netif_is_geneve(tunnel_dev))\n\t\treturn &geneve_tunnel;\n\telse if (netif_is_gretap(tunnel_dev) ||\n\t\t netif_is_ip6gretap(tunnel_dev))\n\t\treturn &gre_tunnel;\n\telse if (netif_is_bareudp(tunnel_dev))\n\t\treturn &mplsoudp_tunnel;\n\telse\n\t\treturn NULL;\n}\n\nstatic int get_route_and_out_devs(struct mlx5e_priv *priv,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  struct net_device **route_dev,\n\t\t\t\t  struct net_device **out_dev)\n{\n\tstruct net_device *uplink_dev, *uplink_upper, *real_dev;\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tbool dst_is_lag_dev;\n\n\treal_dev = is_vlan_dev(dev) ? vlan_dev_real_dev(dev) : dev;\n\tuplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);\n\n\trcu_read_lock();\n\tuplink_upper = netdev_master_upper_dev_get_rcu(uplink_dev);\n\t \n\tif (uplink_upper)\n\t\tdev_hold(uplink_upper);\n\trcu_read_unlock();\n\n\tdst_is_lag_dev = (uplink_upper &&\n\t\t\t  netif_is_lag_master(uplink_upper) &&\n\t\t\t  real_dev == uplink_upper &&\n\t\t\t  mlx5_lag_is_sriov(priv->mdev));\n\tif (uplink_upper)\n\t\tdev_put(uplink_upper);\n\n\t \n\t*route_dev = dev;\n\tif (!netdev_port_same_parent_id(priv->netdev, real_dev) ||\n\t    dst_is_lag_dev || is_vlan_dev(*route_dev) ||\n\t    netif_is_ovs_master(*route_dev))\n\t\t*out_dev = uplink_dev;\n\telse if (mlx5e_eswitch_rep(dev) &&\n\t\t mlx5e_is_valid_eswitch_fwd_dev(priv, dev))\n\t\t*out_dev = *route_dev;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tif (!mlx5e_eswitch_uplink_rep(*out_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mlx5e_eswitch_uplink_rep(priv->netdev) && *out_dev != priv->netdev &&\n\t    !mlx5_lag_is_mpesw(priv->mdev))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int mlx5e_route_lookup_ipv4_get(struct mlx5e_priv *priv,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       struct mlx5e_tc_tun_route_attr *attr)\n{\n\tstruct net_device *route_dev;\n\tstruct net_device *out_dev;\n\tstruct neighbour *n;\n\tstruct rtable *rt;\n\n#if IS_ENABLED(CONFIG_INET)\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct net_device *uplink_dev;\n\tint ret;\n\n\tif (mlx5_lag_is_multipath(mdev)) {\n\t\tstruct mlx5_eswitch *esw = mdev->priv.eswitch;\n\n\t\tuplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);\n\t\tattr->fl.fl4.flowi4_oif = uplink_dev->ifindex;\n\t} else {\n\t\tstruct mlx5e_tc_tunnel *tunnel = mlx5e_get_tc_tun(dev);\n\n\t\tif (tunnel && tunnel->get_remote_ifindex)\n\t\t\tattr->fl.fl4.flowi4_oif = tunnel->get_remote_ifindex(dev);\n\t}\n\n\trt = ip_route_output_key(dev_net(dev), &attr->fl.fl4);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_type != RTN_UNICAST) {\n\t\tret = -ENETUNREACH;\n\t\tgoto err_rt_release;\n\t}\n\n\tif (mlx5_lag_is_multipath(mdev) && rt->rt_gw_family != AF_INET) {\n\t\tret = -ENETUNREACH;\n\t\tgoto err_rt_release;\n\t}\n#else\n\treturn -EOPNOTSUPP;\n#endif\n\n\tret = get_route_and_out_devs(priv, rt->dst.dev, &route_dev, &out_dev);\n\tif (ret < 0)\n\t\tgoto err_rt_release;\n\tdev_hold(route_dev);\n\n\tif (!attr->ttl)\n\t\tattr->ttl = ip4_dst_hoplimit(&rt->dst);\n\tn = dst_neigh_lookup(&rt->dst, &attr->fl.fl4.daddr);\n\tif (!n) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dev_release;\n\t}\n\n\tip_rt_put(rt);\n\tattr->route_dev = route_dev;\n\tattr->out_dev = out_dev;\n\tattr->n = n;\n\treturn 0;\n\nerr_dev_release:\n\tdev_put(route_dev);\nerr_rt_release:\n\tip_rt_put(rt);\n\treturn ret;\n}\n\nstatic void mlx5e_route_lookup_ipv4_put(struct mlx5e_tc_tun_route_attr *attr)\n{\n\tmlx5e_tc_tun_route_attr_cleanup(attr);\n}\n\nstatic const char *mlx5e_netdev_kind(struct net_device *dev)\n{\n\tif (dev->rtnl_link_ops)\n\t\treturn dev->rtnl_link_ops->kind;\n\telse\n\t\treturn \"unknown\";\n}\n\nstatic int mlx5e_gen_ip_tunnel_header(char buf[], __u8 *ip_proto,\n\t\t\t\t      struct mlx5e_encap_entry *e)\n{\n\tif (!e->tunnel) {\n\t\tpr_warn(\"mlx5: Cannot generate tunnel header for this tunnel\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn e->tunnel->generate_ip_tun_hdr(buf, ip_proto, e);\n}\n\nstatic char *gen_eth_tnl_hdr(char *buf, struct net_device *dev,\n\t\t\t     struct mlx5e_encap_entry *e,\n\t\t\t     u16 proto)\n{\n\tstruct ethhdr *eth = (struct ethhdr *)buf;\n\tchar *ip;\n\n\tether_addr_copy(eth->h_dest, e->h_dest);\n\tether_addr_copy(eth->h_source, dev->dev_addr);\n\tif (is_vlan_dev(dev)) {\n\t\tstruct vlan_hdr *vlan = (struct vlan_hdr *)\n\t\t\t\t\t((char *)eth + ETH_HLEN);\n\t\tip = (char *)vlan + VLAN_HLEN;\n\t\teth->h_proto = vlan_dev_vlan_proto(dev);\n\t\tvlan->h_vlan_TCI = htons(vlan_dev_vlan_id(dev));\n\t\tvlan->h_vlan_encapsulated_proto = htons(proto);\n\t} else {\n\t\teth->h_proto = htons(proto);\n\t\tip = (char *)eth + ETH_HLEN;\n\t}\n\n\treturn ip;\n}\n\nint mlx5e_tc_tun_create_header_ipv4(struct mlx5e_priv *priv,\n\t\t\t\t    struct net_device *mirred_dev,\n\t\t\t\t    struct mlx5e_encap_entry *e)\n{\n\tint max_encap_size = MLX5_CAP_ESW(priv->mdev, max_encap_header_size);\n\tconst struct ip_tunnel_key *tun_key = &e->tun_info->key;\n\tstruct mlx5_pkt_reformat_params reformat_params;\n\tstruct mlx5e_neigh m_neigh = {};\n\tTC_TUN_ROUTE_ATTR_INIT(attr);\n\tint ipv4_encap_size;\n\tchar *encap_header;\n\tstruct iphdr *ip;\n\tu8 nud_state;\n\tint err;\n\n\t \n\tattr.fl.fl4.flowi4_tos = tun_key->tos & ~INET_ECN_MASK;\n\tattr.fl.fl4.daddr = tun_key->u.ipv4.dst;\n\tattr.fl.fl4.saddr = tun_key->u.ipv4.src;\n\tattr.ttl = tun_key->ttl;\n\n\terr = mlx5e_route_lookup_ipv4_get(priv, mirred_dev, &attr);\n\tif (err)\n\t\treturn err;\n\n\tipv4_encap_size =\n\t\t(is_vlan_dev(attr.route_dev) ? VLAN_ETH_HLEN : ETH_HLEN) +\n\t\tsizeof(struct iphdr) +\n\t\te->tunnel->calc_hlen(e);\n\n\tif (max_encap_size < ipv4_encap_size) {\n\t\tmlx5_core_warn(priv->mdev, \"encap size %d too big, max supported is %d\\n\",\n\t\t\t       ipv4_encap_size, max_encap_size);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto release_neigh;\n\t}\n\n\tencap_header = kzalloc(ipv4_encap_size, GFP_KERNEL);\n\tif (!encap_header) {\n\t\terr = -ENOMEM;\n\t\tgoto release_neigh;\n\t}\n\n\tm_neigh.family = attr.n->ops->family;\n\tmemcpy(&m_neigh.dst_ip, attr.n->primary_key, attr.n->tbl->key_len);\n\te->out_dev = attr.out_dev;\n\te->route_dev_ifindex = attr.route_dev->ifindex;\n\n\t \n\terr = mlx5e_rep_encap_entry_attach(netdev_priv(attr.out_dev), e, &m_neigh, attr.n->dev);\n\tif (err)\n\t\tgoto free_encap;\n\n\tread_lock_bh(&attr.n->lock);\n\tnud_state = attr.n->nud_state;\n\tether_addr_copy(e->h_dest, attr.n->ha);\n\tread_unlock_bh(&attr.n->lock);\n\n\t \n\tip = (struct iphdr *)gen_eth_tnl_hdr(encap_header, attr.route_dev, e,\n\t\t\t\t\t     ETH_P_IP);\n\n\t \n\tip->tos = tun_key->tos;\n\tip->version = 0x4;\n\tip->ihl = 0x5;\n\tip->ttl = attr.ttl;\n\tip->daddr = attr.fl.fl4.daddr;\n\tip->saddr = attr.fl.fl4.saddr;\n\n\t \n\terr = mlx5e_gen_ip_tunnel_header((char *)ip + sizeof(struct iphdr),\n\t\t\t\t\t &ip->protocol, e);\n\tif (err)\n\t\tgoto destroy_neigh_entry;\n\n\te->encap_size = ipv4_encap_size;\n\te->encap_header = encap_header;\n\n\tif (!(nud_state & NUD_VALID)) {\n\t\tneigh_event_send(attr.n, NULL);\n\t\t \n\t\tgoto release_neigh;\n\t}\n\n\tmemset(&reformat_params, 0, sizeof(reformat_params));\n\treformat_params.type = e->reformat_type;\n\treformat_params.size = ipv4_encap_size;\n\treformat_params.data = encap_header;\n\te->pkt_reformat = mlx5_packet_reformat_alloc(priv->mdev, &reformat_params,\n\t\t\t\t\t\t     MLX5_FLOW_NAMESPACE_FDB);\n\tif (IS_ERR(e->pkt_reformat)) {\n\t\terr = PTR_ERR(e->pkt_reformat);\n\t\tgoto destroy_neigh_entry;\n\t}\n\n\te->flags |= MLX5_ENCAP_ENTRY_VALID;\n\tmlx5e_rep_queue_neigh_stats_work(netdev_priv(attr.out_dev));\n\tmlx5e_route_lookup_ipv4_put(&attr);\n\treturn err;\n\ndestroy_neigh_entry:\n\tmlx5e_rep_encap_entry_detach(netdev_priv(e->out_dev), e);\nfree_encap:\n\tkfree(encap_header);\nrelease_neigh:\n\tmlx5e_route_lookup_ipv4_put(&attr);\n\treturn err;\n}\n\nint mlx5e_tc_tun_update_header_ipv4(struct mlx5e_priv *priv,\n\t\t\t\t    struct net_device *mirred_dev,\n\t\t\t\t    struct mlx5e_encap_entry *e)\n{\n\tint max_encap_size = MLX5_CAP_ESW(priv->mdev, max_encap_header_size);\n\tconst struct ip_tunnel_key *tun_key = &e->tun_info->key;\n\tstruct mlx5_pkt_reformat_params reformat_params;\n\tTC_TUN_ROUTE_ATTR_INIT(attr);\n\tint ipv4_encap_size;\n\tchar *encap_header;\n\tstruct iphdr *ip;\n\tu8 nud_state;\n\tint err;\n\n\t \n\tattr.fl.fl4.flowi4_tos = tun_key->tos & ~INET_ECN_MASK;\n\tattr.fl.fl4.daddr = tun_key->u.ipv4.dst;\n\tattr.fl.fl4.saddr = tun_key->u.ipv4.src;\n\tattr.ttl = tun_key->ttl;\n\n\terr = mlx5e_route_lookup_ipv4_get(priv, mirred_dev, &attr);\n\tif (err)\n\t\treturn err;\n\n\tipv4_encap_size =\n\t\t(is_vlan_dev(attr.route_dev) ? VLAN_ETH_HLEN : ETH_HLEN) +\n\t\tsizeof(struct iphdr) +\n\t\te->tunnel->calc_hlen(e);\n\n\tif (max_encap_size < ipv4_encap_size) {\n\t\tmlx5_core_warn(priv->mdev, \"encap size %d too big, max supported is %d\\n\",\n\t\t\t       ipv4_encap_size, max_encap_size);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto release_neigh;\n\t}\n\n\tencap_header = kzalloc(ipv4_encap_size, GFP_KERNEL);\n\tif (!encap_header) {\n\t\terr = -ENOMEM;\n\t\tgoto release_neigh;\n\t}\n\n\te->route_dev_ifindex = attr.route_dev->ifindex;\n\n\tread_lock_bh(&attr.n->lock);\n\tnud_state = attr.n->nud_state;\n\tether_addr_copy(e->h_dest, attr.n->ha);\n\tWRITE_ONCE(e->nhe->neigh_dev, attr.n->dev);\n\tread_unlock_bh(&attr.n->lock);\n\n\t \n\tip = (struct iphdr *)gen_eth_tnl_hdr(encap_header, attr.route_dev, e,\n\t\t\t\t\t     ETH_P_IP);\n\n\t \n\tip->tos = tun_key->tos;\n\tip->version = 0x4;\n\tip->ihl = 0x5;\n\tip->ttl = attr.ttl;\n\tip->daddr = attr.fl.fl4.daddr;\n\tip->saddr = attr.fl.fl4.saddr;\n\n\t \n\terr = mlx5e_gen_ip_tunnel_header((char *)ip + sizeof(struct iphdr),\n\t\t\t\t\t &ip->protocol, e);\n\tif (err)\n\t\tgoto free_encap;\n\n\te->encap_size = ipv4_encap_size;\n\tkfree(e->encap_header);\n\te->encap_header = encap_header;\n\n\tif (!(nud_state & NUD_VALID)) {\n\t\tneigh_event_send(attr.n, NULL);\n\t\t \n\t\tgoto release_neigh;\n\t}\n\n\tmemset(&reformat_params, 0, sizeof(reformat_params));\n\treformat_params.type = e->reformat_type;\n\treformat_params.size = ipv4_encap_size;\n\treformat_params.data = encap_header;\n\te->pkt_reformat = mlx5_packet_reformat_alloc(priv->mdev, &reformat_params,\n\t\t\t\t\t\t     MLX5_FLOW_NAMESPACE_FDB);\n\tif (IS_ERR(e->pkt_reformat)) {\n\t\terr = PTR_ERR(e->pkt_reformat);\n\t\tgoto free_encap;\n\t}\n\n\te->flags |= MLX5_ENCAP_ENTRY_VALID;\n\tmlx5e_rep_queue_neigh_stats_work(netdev_priv(attr.out_dev));\n\tmlx5e_route_lookup_ipv4_put(&attr);\n\treturn err;\n\nfree_encap:\n\tkfree(encap_header);\nrelease_neigh:\n\tmlx5e_route_lookup_ipv4_put(&attr);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_INET) && IS_ENABLED(CONFIG_IPV6)\nstatic int mlx5e_route_lookup_ipv6_get(struct mlx5e_priv *priv,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       struct mlx5e_tc_tun_route_attr *attr)\n{\n\tstruct mlx5e_tc_tunnel *tunnel = mlx5e_get_tc_tun(dev);\n\tstruct net_device *route_dev;\n\tstruct net_device *out_dev;\n\tstruct dst_entry *dst;\n\tstruct neighbour *n;\n\tint ret;\n\n\tif (tunnel && tunnel->get_remote_ifindex)\n\t\tattr->fl.fl6.flowi6_oif = tunnel->get_remote_ifindex(dev);\n\tdst = ipv6_stub->ipv6_dst_lookup_flow(dev_net(dev), NULL, &attr->fl.fl6,\n\t\t\t\t\t      NULL);\n\tif (IS_ERR(dst))\n\t\treturn PTR_ERR(dst);\n\n\tif (!attr->ttl)\n\t\tattr->ttl = ip6_dst_hoplimit(dst);\n\n\tret = get_route_and_out_devs(priv, dst->dev, &route_dev, &out_dev);\n\tif (ret < 0)\n\t\tgoto err_dst_release;\n\n\tdev_hold(route_dev);\n\tn = dst_neigh_lookup(dst, &attr->fl.fl6.daddr);\n\tif (!n) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dev_release;\n\t}\n\n\tdst_release(dst);\n\tattr->out_dev = out_dev;\n\tattr->route_dev = route_dev;\n\tattr->n = n;\n\treturn 0;\n\nerr_dev_release:\n\tdev_put(route_dev);\nerr_dst_release:\n\tdst_release(dst);\n\treturn ret;\n}\n\nstatic void mlx5e_route_lookup_ipv6_put(struct mlx5e_tc_tun_route_attr *attr)\n{\n\tmlx5e_tc_tun_route_attr_cleanup(attr);\n}\n\nint mlx5e_tc_tun_create_header_ipv6(struct mlx5e_priv *priv,\n\t\t\t\t    struct net_device *mirred_dev,\n\t\t\t\t    struct mlx5e_encap_entry *e)\n{\n\tint max_encap_size = MLX5_CAP_ESW(priv->mdev, max_encap_header_size);\n\tconst struct ip_tunnel_key *tun_key = &e->tun_info->key;\n\tstruct mlx5_pkt_reformat_params reformat_params;\n\tstruct mlx5e_neigh m_neigh = {};\n\tTC_TUN_ROUTE_ATTR_INIT(attr);\n\tstruct ipv6hdr *ip6h;\n\tint ipv6_encap_size;\n\tchar *encap_header;\n\tu8 nud_state;\n\tint err;\n\n\tattr.ttl = tun_key->ttl;\n\tattr.fl.fl6.flowlabel = ip6_make_flowinfo(tun_key->tos, tun_key->label);\n\tattr.fl.fl6.daddr = tun_key->u.ipv6.dst;\n\tattr.fl.fl6.saddr = tun_key->u.ipv6.src;\n\n\terr = mlx5e_route_lookup_ipv6_get(priv, mirred_dev, &attr);\n\tif (err)\n\t\treturn err;\n\n\tipv6_encap_size =\n\t\t(is_vlan_dev(attr.route_dev) ? VLAN_ETH_HLEN : ETH_HLEN) +\n\t\tsizeof(struct ipv6hdr) +\n\t\te->tunnel->calc_hlen(e);\n\n\tif (max_encap_size < ipv6_encap_size) {\n\t\tmlx5_core_warn(priv->mdev, \"encap size %d too big, max supported is %d\\n\",\n\t\t\t       ipv6_encap_size, max_encap_size);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto release_neigh;\n\t}\n\n\tencap_header = kzalloc(ipv6_encap_size, GFP_KERNEL);\n\tif (!encap_header) {\n\t\terr = -ENOMEM;\n\t\tgoto release_neigh;\n\t}\n\n\tm_neigh.family = attr.n->ops->family;\n\tmemcpy(&m_neigh.dst_ip, attr.n->primary_key, attr.n->tbl->key_len);\n\te->out_dev = attr.out_dev;\n\te->route_dev_ifindex = attr.route_dev->ifindex;\n\n\t \n\terr = mlx5e_rep_encap_entry_attach(netdev_priv(attr.out_dev), e, &m_neigh, attr.n->dev);\n\tif (err)\n\t\tgoto free_encap;\n\n\tread_lock_bh(&attr.n->lock);\n\tnud_state = attr.n->nud_state;\n\tether_addr_copy(e->h_dest, attr.n->ha);\n\tread_unlock_bh(&attr.n->lock);\n\n\t \n\tip6h = (struct ipv6hdr *)gen_eth_tnl_hdr(encap_header, attr.route_dev, e,\n\t\t\t\t\t\t ETH_P_IPV6);\n\n\t \n\tip6_flow_hdr(ip6h, tun_key->tos, 0);\n\t \n\tip6h->hop_limit   = attr.ttl;\n\tip6h->daddr\t  = attr.fl.fl6.daddr;\n\tip6h->saddr\t  = attr.fl.fl6.saddr;\n\n\t \n\terr = mlx5e_gen_ip_tunnel_header((char *)ip6h + sizeof(struct ipv6hdr),\n\t\t\t\t\t &ip6h->nexthdr, e);\n\tif (err)\n\t\tgoto destroy_neigh_entry;\n\n\te->encap_size = ipv6_encap_size;\n\te->encap_header = encap_header;\n\n\tif (!(nud_state & NUD_VALID)) {\n\t\tneigh_event_send(attr.n, NULL);\n\t\t \n\t\tgoto release_neigh;\n\t}\n\n\tmemset(&reformat_params, 0, sizeof(reformat_params));\n\treformat_params.type = e->reformat_type;\n\treformat_params.size = ipv6_encap_size;\n\treformat_params.data = encap_header;\n\te->pkt_reformat = mlx5_packet_reformat_alloc(priv->mdev, &reformat_params,\n\t\t\t\t\t\t     MLX5_FLOW_NAMESPACE_FDB);\n\tif (IS_ERR(e->pkt_reformat)) {\n\t\terr = PTR_ERR(e->pkt_reformat);\n\t\tgoto destroy_neigh_entry;\n\t}\n\n\te->flags |= MLX5_ENCAP_ENTRY_VALID;\n\tmlx5e_rep_queue_neigh_stats_work(netdev_priv(attr.out_dev));\n\tmlx5e_route_lookup_ipv6_put(&attr);\n\treturn err;\n\ndestroy_neigh_entry:\n\tmlx5e_rep_encap_entry_detach(netdev_priv(e->out_dev), e);\nfree_encap:\n\tkfree(encap_header);\nrelease_neigh:\n\tmlx5e_route_lookup_ipv6_put(&attr);\n\treturn err;\n}\n\nint mlx5e_tc_tun_update_header_ipv6(struct mlx5e_priv *priv,\n\t\t\t\t    struct net_device *mirred_dev,\n\t\t\t\t    struct mlx5e_encap_entry *e)\n{\n\tint max_encap_size = MLX5_CAP_ESW(priv->mdev, max_encap_header_size);\n\tconst struct ip_tunnel_key *tun_key = &e->tun_info->key;\n\tstruct mlx5_pkt_reformat_params reformat_params;\n\tTC_TUN_ROUTE_ATTR_INIT(attr);\n\tstruct ipv6hdr *ip6h;\n\tint ipv6_encap_size;\n\tchar *encap_header;\n\tu8 nud_state;\n\tint err;\n\n\tattr.ttl = tun_key->ttl;\n\n\tattr.fl.fl6.flowlabel = ip6_make_flowinfo(tun_key->tos, tun_key->label);\n\tattr.fl.fl6.daddr = tun_key->u.ipv6.dst;\n\tattr.fl.fl6.saddr = tun_key->u.ipv6.src;\n\n\terr = mlx5e_route_lookup_ipv6_get(priv, mirred_dev, &attr);\n\tif (err)\n\t\treturn err;\n\n\tipv6_encap_size =\n\t\t(is_vlan_dev(attr.route_dev) ? VLAN_ETH_HLEN : ETH_HLEN) +\n\t\tsizeof(struct ipv6hdr) +\n\t\te->tunnel->calc_hlen(e);\n\n\tif (max_encap_size < ipv6_encap_size) {\n\t\tmlx5_core_warn(priv->mdev, \"encap size %d too big, max supported is %d\\n\",\n\t\t\t       ipv6_encap_size, max_encap_size);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto release_neigh;\n\t}\n\n\tencap_header = kzalloc(ipv6_encap_size, GFP_KERNEL);\n\tif (!encap_header) {\n\t\terr = -ENOMEM;\n\t\tgoto release_neigh;\n\t}\n\n\te->route_dev_ifindex = attr.route_dev->ifindex;\n\n\tread_lock_bh(&attr.n->lock);\n\tnud_state = attr.n->nud_state;\n\tether_addr_copy(e->h_dest, attr.n->ha);\n\tWRITE_ONCE(e->nhe->neigh_dev, attr.n->dev);\n\tread_unlock_bh(&attr.n->lock);\n\n\t \n\tip6h = (struct ipv6hdr *)gen_eth_tnl_hdr(encap_header, attr.route_dev, e,\n\t\t\t\t\t\t ETH_P_IPV6);\n\n\t \n\tip6_flow_hdr(ip6h, tun_key->tos, 0);\n\t \n\tip6h->hop_limit   = attr.ttl;\n\tip6h->daddr\t  = attr.fl.fl6.daddr;\n\tip6h->saddr\t  = attr.fl.fl6.saddr;\n\n\t \n\terr = mlx5e_gen_ip_tunnel_header((char *)ip6h + sizeof(struct ipv6hdr),\n\t\t\t\t\t &ip6h->nexthdr, e);\n\tif (err)\n\t\tgoto free_encap;\n\n\te->encap_size = ipv6_encap_size;\n\tkfree(e->encap_header);\n\te->encap_header = encap_header;\n\n\tif (!(nud_state & NUD_VALID)) {\n\t\tneigh_event_send(attr.n, NULL);\n\t\t \n\t\tgoto release_neigh;\n\t}\n\n\tmemset(&reformat_params, 0, sizeof(reformat_params));\n\treformat_params.type = e->reformat_type;\n\treformat_params.size = ipv6_encap_size;\n\treformat_params.data = encap_header;\n\te->pkt_reformat = mlx5_packet_reformat_alloc(priv->mdev, &reformat_params,\n\t\t\t\t\t\t     MLX5_FLOW_NAMESPACE_FDB);\n\tif (IS_ERR(e->pkt_reformat)) {\n\t\terr = PTR_ERR(e->pkt_reformat);\n\t\tgoto free_encap;\n\t}\n\n\te->flags |= MLX5_ENCAP_ENTRY_VALID;\n\tmlx5e_rep_queue_neigh_stats_work(netdev_priv(attr.out_dev));\n\tmlx5e_route_lookup_ipv6_put(&attr);\n\treturn err;\n\nfree_encap:\n\tkfree(encap_header);\nrelease_neigh:\n\tmlx5e_route_lookup_ipv6_put(&attr);\n\treturn err;\n}\n#endif\n\nint mlx5e_tc_tun_route_lookup(struct mlx5e_priv *priv,\n\t\t\t      struct mlx5_flow_spec *spec,\n\t\t\t      struct mlx5_flow_attr *flow_attr,\n\t\t\t      struct net_device *filter_dev)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = flow_attr->esw_attr;\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5e_tc_int_port *int_port;\n\tTC_TUN_ROUTE_ATTR_INIT(attr);\n\tu16 vport_num;\n\tint err = 0;\n\n\tif (flow_attr->tun_ip_version == 4) {\n\t\t \n\t\tattr.fl.fl4.saddr = esw_attr->rx_tun_attr->dst_ip.v4;\n\t\tattr.fl.fl4.daddr = esw_attr->rx_tun_attr->src_ip.v4;\n\t\terr = mlx5e_route_lookup_ipv4_get(priv, filter_dev, &attr);\n\t}\n#if IS_ENABLED(CONFIG_INET) && IS_ENABLED(CONFIG_IPV6)\n\telse if (flow_attr->tun_ip_version == 6) {\n\t\t \n\t\tattr.fl.fl6.saddr = esw_attr->rx_tun_attr->dst_ip.v6;\n\t\tattr.fl.fl6.daddr = esw_attr->rx_tun_attr->src_ip.v6;\n\t\terr = mlx5e_route_lookup_ipv6_get(priv, filter_dev, &attr);\n\t}\n#endif\n\telse\n\t\treturn 0;\n\n\tif (err)\n\t\treturn err;\n\n\tif (attr.route_dev->netdev_ops == &mlx5e_netdev_ops &&\n\t    mlx5e_tc_is_vf_tunnel(attr.out_dev, attr.route_dev)) {\n\t\terr = mlx5e_tc_query_route_vport(attr.out_dev, attr.route_dev, &vport_num);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tesw_attr->rx_tun_attr->decap_vport = vport_num;\n\t} else if (netif_is_ovs_master(attr.route_dev) && mlx5e_tc_int_port_supported(esw)) {\n\t\tint_port = mlx5e_tc_int_port_get(mlx5e_get_int_port_priv(priv),\n\t\t\t\t\t\t attr.route_dev->ifindex,\n\t\t\t\t\t\t MLX5E_TC_INT_PORT_INGRESS);\n\t\tif (IS_ERR(int_port)) {\n\t\t\terr = PTR_ERR(int_port);\n\t\t\tgoto out;\n\t\t}\n\t\tesw_attr->int_port = int_port;\n\t}\n\nout:\n\tif (flow_attr->tun_ip_version == 4)\n\t\tmlx5e_route_lookup_ipv4_put(&attr);\n#if IS_ENABLED(CONFIG_INET) && IS_ENABLED(CONFIG_IPV6)\n\telse if (flow_attr->tun_ip_version == 6)\n\t\tmlx5e_route_lookup_ipv6_put(&attr);\n#endif\n\treturn err;\n}\n\nbool mlx5e_tc_tun_device_to_offload(struct mlx5e_priv *priv,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct mlx5e_tc_tunnel *tunnel = mlx5e_get_tc_tun(netdev);\n\n\tif (tunnel && tunnel->can_offload(priv))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint mlx5e_tc_tun_init_encap_attr(struct net_device *tunnel_dev,\n\t\t\t\t struct mlx5e_priv *priv,\n\t\t\t\t struct mlx5e_encap_entry *e,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_tunnel *tunnel = mlx5e_get_tc_tun(tunnel_dev);\n\n\tif (!tunnel) {\n\t\te->reformat_type = -1;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn tunnel->init_encap_attr(tunnel_dev, priv, e, extack);\n}\n\nint mlx5e_tc_tun_parse(struct net_device *filter_dev,\n\t\t       struct mlx5e_priv *priv,\n\t\t       struct mlx5_flow_spec *spec,\n\t\t       struct flow_cls_offload *f,\n\t\t       u8 *match_level)\n{\n\tstruct mlx5e_tc_tunnel *tunnel = mlx5e_get_tc_tun(filter_dev);\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tvoid *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t       outer_headers);\n\tvoid *headers_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t       outer_headers);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tint err = 0;\n\n\tif (!tunnel) {\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"decapsulation offload is not supported for %s net device\\n\",\n\t\t\t    mlx5e_netdev_kind(filter_dev));\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t*match_level = tunnel->match_level;\n\n\tif (tunnel->parse_udp_ports) {\n\t\terr = tunnel->parse_udp_ports(priv, spec, f,\n\t\t\t\t\t      headers_c, headers_v);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tunnel->parse_tunnel) {\n\t\terr = tunnel->parse_tunnel(priv, spec, f,\n\t\t\t\t\t   headers_c, headers_v);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_CONTROL)) {\n\t\tstruct flow_dissector_key_basic key_basic = {};\n\t\tstruct flow_dissector_key_basic mask_basic = {\n\t\t\t.n_proto = htons(0xFFFF),\n\t\t};\n\t\tstruct flow_match_basic match_basic = {\n\t\t\t.key = &key_basic, .mask = &mask_basic,\n\t\t};\n\t\tstruct flow_match_control match;\n\t\tu16 addr_type;\n\n\t\tflow_rule_match_enc_control(rule, &match);\n\t\taddr_type = match.key->addr_type;\n\n\t\t \n\t\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\t\tstruct flow_match_ipv4_addrs match;\n\n\t\t\tflow_rule_match_enc_ipv4_addrs(rule, &match);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t src_ipv4_src_ipv6.ipv4_layout.ipv4,\n\t\t\t\t ntohl(match.mask->src));\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t src_ipv4_src_ipv6.ipv4_layout.ipv4,\n\t\t\t\t ntohl(match.key->src));\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t dst_ipv4_dst_ipv6.ipv4_layout.ipv4,\n\t\t\t\t ntohl(match.mask->dst));\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t dst_ipv4_dst_ipv6.ipv4_layout.ipv4,\n\t\t\t\t ntohl(match.key->dst));\n\n\t\t\tkey_basic.n_proto = htons(ETH_P_IP);\n\t\t\tmlx5e_tc_set_ethertype(priv->mdev, &match_basic, true,\n\t\t\t\t\t       headers_c, headers_v);\n\t\t} else if (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\t\tstruct flow_match_ipv6_addrs match;\n\n\t\t\tflow_rule_match_enc_ipv6_addrs(rule, &match);\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t\t       &match.mask->src, MLX5_FLD_SZ_BYTES(ipv6_layout,\n\t\t\t\t\t\t\t\t   ipv6));\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t\t       &match.key->src, MLX5_FLD_SZ_BYTES(ipv6_layout,\n\t\t\t\t\t\t\t\t  ipv6));\n\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t\t       &match.mask->dst, MLX5_FLD_SZ_BYTES(ipv6_layout,\n\t\t\t\t\t\t\t\t   ipv6));\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t\t       &match.key->dst, MLX5_FLD_SZ_BYTES(ipv6_layout,\n\t\t\t\t\t\t\t\t  ipv6));\n\n\t\t\tkey_basic.n_proto = htons(ETH_P_IPV6);\n\t\t\tmlx5e_tc_set_ethertype(priv->mdev, &match_basic, true,\n\t\t\t\t\t       headers_c, headers_v);\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IP)) {\n\t\tstruct flow_match_ip match;\n\n\t\tflow_rule_match_enc_ip(rule, &match);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ip_ecn,\n\t\t\t match.mask->tos & 0x3);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_ecn,\n\t\t\t match.key->tos & 0x3);\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ip_dscp,\n\t\t\t match.mask->tos >> 2);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_dscp,\n\t\t\t match.key->tos  >> 2);\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ttl_hoplimit,\n\t\t\t match.mask->ttl);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ttl_hoplimit,\n\t\t\t match.key->ttl);\n\n\t\tif (match.mask->ttl &&\n\t\t    !MLX5_CAP_ESW_FLOWTABLE_FDB\n\t\t\t(priv->mdev,\n\t\t\t ft_field_support.outer_ipv4_ttl)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matching on TTL is not supported\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, frag, 1);\n\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, frag, 0);\n\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nint mlx5e_tc_tun_parse_udp_ports(struct mlx5e_priv *priv,\n\t\t\t\t struct mlx5_flow_spec *spec,\n\t\t\t\t struct flow_cls_offload *f,\n\t\t\t\t void *headers_c,\n\t\t\t\t void *headers_v)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_match_ports enc_ports;\n\n\t \n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_PORTS)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"UDP tunnel decap filter must include enc_dst_port condition\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"UDP tunnel decap filter must include enc_dst_port condition\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tflow_rule_match_enc_ports(rule, &enc_ports);\n\n\tif (memchr_inv(&enc_ports.mask->dst, 0xff,\n\t\t       sizeof(enc_ports.mask->dst))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"UDP tunnel decap filter must match enc_dst_port fully\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"UDP tunnel decap filter must match enc_dst_port fully\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, ip_protocol);\n\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_protocol, IPPROTO_UDP);\n\n\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, udp_dport,\n\t\t ntohs(enc_ports.mask->dst));\n\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, udp_dport,\n\t\t ntohs(enc_ports.key->dst));\n\n\t \n\n\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, udp_sport,\n\t\t ntohs(enc_ports.mask->src));\n\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, udp_sport,\n\t\t ntohs(enc_ports.key->src));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}