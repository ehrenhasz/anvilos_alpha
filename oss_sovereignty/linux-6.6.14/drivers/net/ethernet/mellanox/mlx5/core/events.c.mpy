{
  "module_name": "events.c",
  "hash_id": "4b4f9fc289af809ffa19fc1a95f41d5651b19bfc02333d8db2a3b3f59b790db2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/events.c",
  "human_readable_source": "\n\n\n#include <linux/mlx5/driver.h>\n\n#include \"mlx5_core.h\"\n#include \"lib/eq.h\"\n#include \"lib/events.h\"\n\nstruct mlx5_event_nb {\n\tstruct mlx5_nb  nb;\n\tvoid           *ctx;\n};\n\n \nstatic int any_notifier(struct notifier_block *, unsigned long, void *);\nstatic int temp_warn(struct notifier_block *, unsigned long, void *);\nstatic int port_module(struct notifier_block *, unsigned long, void *);\nstatic int pcie_core(struct notifier_block *, unsigned long, void *);\n\n \nstatic int forward_event(struct notifier_block *, unsigned long, void *);\n\nstatic struct mlx5_nb events_nbs_ref[] = {\n\t \n\t{.nb.notifier_call = any_notifier,  .event_type = MLX5_EVENT_TYPE_NOTIFY_ANY },\n\t{.nb.notifier_call = temp_warn,     .event_type = MLX5_EVENT_TYPE_TEMP_WARN_EVENT },\n\t{.nb.notifier_call = port_module,   .event_type = MLX5_EVENT_TYPE_PORT_MODULE_EVENT },\n\t{.nb.notifier_call = pcie_core,     .event_type = MLX5_EVENT_TYPE_GENERAL_EVENT },\n\n\t \n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_PORT_CHANGE },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_GENERAL_EVENT },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_OBJECT_CHANGE },\n\t \n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_DCT_DRAINED },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_PATH_MIG },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_COMM_EST },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_SQ_DRAINED },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_SRQ_LAST_WQE },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_WQ_CATAS_ERROR },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_PATH_MIG_FAILED },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_WQ_ACCESS_ERROR },\n\t \n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_SRQ_CATAS_ERROR },\n\t{.nb.notifier_call = forward_event,   .event_type = MLX5_EVENT_TYPE_SRQ_RQ_LIMIT },\n};\n\nstruct mlx5_events {\n\tstruct mlx5_core_dev *dev;\n\tstruct workqueue_struct *wq;\n\tstruct mlx5_event_nb  notifiers[ARRAY_SIZE(events_nbs_ref)];\n\t \n\tstruct atomic_notifier_head fw_nh;\n\t \n\tstruct mlx5_pme_stats pme_stats;\n\t \n\tstruct work_struct pcie_core_work;\n\t \n\tstruct blocking_notifier_head sw_nh;\n};\n\nstatic const char *eqe_type_str(u8 type)\n{\n\tswitch (type) {\n\tcase MLX5_EVENT_TYPE_COMP:\n\t\treturn \"MLX5_EVENT_TYPE_COMP\";\n\tcase MLX5_EVENT_TYPE_PATH_MIG:\n\t\treturn \"MLX5_EVENT_TYPE_PATH_MIG\";\n\tcase MLX5_EVENT_TYPE_COMM_EST:\n\t\treturn \"MLX5_EVENT_TYPE_COMM_EST\";\n\tcase MLX5_EVENT_TYPE_SQ_DRAINED:\n\t\treturn \"MLX5_EVENT_TYPE_SQ_DRAINED\";\n\tcase MLX5_EVENT_TYPE_SRQ_LAST_WQE:\n\t\treturn \"MLX5_EVENT_TYPE_SRQ_LAST_WQE\";\n\tcase MLX5_EVENT_TYPE_SRQ_RQ_LIMIT:\n\t\treturn \"MLX5_EVENT_TYPE_SRQ_RQ_LIMIT\";\n\tcase MLX5_EVENT_TYPE_CQ_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_CQ_ERROR\";\n\tcase MLX5_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_WQ_CATAS_ERROR\";\n\tcase MLX5_EVENT_TYPE_PATH_MIG_FAILED:\n\t\treturn \"MLX5_EVENT_TYPE_PATH_MIG_FAILED\";\n\tcase MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR\";\n\tcase MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_WQ_ACCESS_ERROR\";\n\tcase MLX5_EVENT_TYPE_SRQ_CATAS_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_SRQ_CATAS_ERROR\";\n\tcase MLX5_EVENT_TYPE_INTERNAL_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_INTERNAL_ERROR\";\n\tcase MLX5_EVENT_TYPE_PORT_CHANGE:\n\t\treturn \"MLX5_EVENT_TYPE_PORT_CHANGE\";\n\tcase MLX5_EVENT_TYPE_GPIO_EVENT:\n\t\treturn \"MLX5_EVENT_TYPE_GPIO_EVENT\";\n\tcase MLX5_EVENT_TYPE_PORT_MODULE_EVENT:\n\t\treturn \"MLX5_EVENT_TYPE_PORT_MODULE_EVENT\";\n\tcase MLX5_EVENT_TYPE_TEMP_WARN_EVENT:\n\t\treturn \"MLX5_EVENT_TYPE_TEMP_WARN_EVENT\";\n\tcase MLX5_EVENT_TYPE_REMOTE_CONFIG:\n\t\treturn \"MLX5_EVENT_TYPE_REMOTE_CONFIG\";\n\tcase MLX5_EVENT_TYPE_DB_BF_CONGESTION:\n\t\treturn \"MLX5_EVENT_TYPE_DB_BF_CONGESTION\";\n\tcase MLX5_EVENT_TYPE_STALL_EVENT:\n\t\treturn \"MLX5_EVENT_TYPE_STALL_EVENT\";\n\tcase MLX5_EVENT_TYPE_CMD:\n\t\treturn \"MLX5_EVENT_TYPE_CMD\";\n\tcase MLX5_EVENT_TYPE_ESW_FUNCTIONS_CHANGED:\n\t\treturn \"MLX5_EVENT_TYPE_ESW_FUNCTIONS_CHANGED\";\n\tcase MLX5_EVENT_TYPE_VHCA_STATE_CHANGE:\n\t\treturn \"MLX5_EVENT_TYPE_VHCA_STATE_CHANGE\";\n\tcase MLX5_EVENT_TYPE_PAGE_REQUEST:\n\t\treturn \"MLX5_EVENT_TYPE_PAGE_REQUEST\";\n\tcase MLX5_EVENT_TYPE_PAGE_FAULT:\n\t\treturn \"MLX5_EVENT_TYPE_PAGE_FAULT\";\n\tcase MLX5_EVENT_TYPE_PPS_EVENT:\n\t\treturn \"MLX5_EVENT_TYPE_PPS_EVENT\";\n\tcase MLX5_EVENT_TYPE_NIC_VPORT_CHANGE:\n\t\treturn \"MLX5_EVENT_TYPE_NIC_VPORT_CHANGE\";\n\tcase MLX5_EVENT_TYPE_FPGA_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_FPGA_ERROR\";\n\tcase MLX5_EVENT_TYPE_FPGA_QP_ERROR:\n\t\treturn \"MLX5_EVENT_TYPE_FPGA_QP_ERROR\";\n\tcase MLX5_EVENT_TYPE_GENERAL_EVENT:\n\t\treturn \"MLX5_EVENT_TYPE_GENERAL_EVENT\";\n\tcase MLX5_EVENT_TYPE_MONITOR_COUNTER:\n\t\treturn \"MLX5_EVENT_TYPE_MONITOR_COUNTER\";\n\tcase MLX5_EVENT_TYPE_DEVICE_TRACER:\n\t\treturn \"MLX5_EVENT_TYPE_DEVICE_TRACER\";\n\tcase MLX5_EVENT_TYPE_OBJECT_CHANGE:\n\t\treturn \"MLX5_EVENT_TYPE_OBJECT_CHANGE\";\n\tdefault:\n\t\treturn \"Unrecognized event\";\n\t}\n}\n\n \nstatic int any_notifier(struct notifier_block *nb,\n\t\t\tunsigned long type, void *data)\n{\n\tstruct mlx5_event_nb *event_nb = mlx5_nb_cof(nb, struct mlx5_event_nb, nb);\n\tstruct mlx5_events   *events   = event_nb->ctx;\n\tstruct mlx5_eqe      *eqe      = data;\n\n\tmlx5_core_dbg(events->dev, \"Async eqe type %s, subtype (%d)\\n\",\n\t\t      eqe_type_str(eqe->type), eqe->sub_type);\n\treturn NOTIFY_OK;\n}\n\n \nstatic int temp_warn(struct notifier_block *nb, unsigned long type, void *data)\n{\n\tstruct mlx5_event_nb *event_nb = mlx5_nb_cof(nb, struct mlx5_event_nb, nb);\n\tstruct mlx5_events   *events   = event_nb->ctx;\n\tstruct mlx5_eqe      *eqe      = data;\n\tu64 value_lsb;\n\tu64 value_msb;\n\n\tvalue_lsb = be64_to_cpu(eqe->data.temp_warning.sensor_warning_lsb);\n\tvalue_msb = be64_to_cpu(eqe->data.temp_warning.sensor_warning_msb);\n\n\tmlx5_core_warn(events->dev,\n\t\t       \"High temperature on sensors with bit set %llx %llx\",\n\t\t       value_msb, value_lsb);\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic const char *mlx5_pme_status_to_string(enum port_module_event_status_type status)\n{\n\tswitch (status) {\n\tcase MLX5_MODULE_STATUS_PLUGGED:\n\t\treturn \"Cable plugged\";\n\tcase MLX5_MODULE_STATUS_UNPLUGGED:\n\t\treturn \"Cable unplugged\";\n\tcase MLX5_MODULE_STATUS_ERROR:\n\t\treturn \"Cable error\";\n\tcase MLX5_MODULE_STATUS_DISABLED:\n\t\treturn \"Cable disabled\";\n\tdefault:\n\t\treturn \"Unknown status\";\n\t}\n}\n\nstatic const char *mlx5_pme_error_to_string(enum port_module_event_error_type error)\n{\n\tswitch (error) {\n\tcase MLX5_MODULE_EVENT_ERROR_POWER_BUDGET_EXCEEDED:\n\t\treturn \"Power budget exceeded\";\n\tcase MLX5_MODULE_EVENT_ERROR_LONG_RANGE_FOR_NON_MLNX:\n\t\treturn \"Long Range for non MLNX cable\";\n\tcase MLX5_MODULE_EVENT_ERROR_BUS_STUCK:\n\t\treturn \"Bus stuck (I2C or data shorted)\";\n\tcase MLX5_MODULE_EVENT_ERROR_NO_EEPROM_RETRY_TIMEOUT:\n\t\treturn \"No EEPROM/retry timeout\";\n\tcase MLX5_MODULE_EVENT_ERROR_ENFORCE_PART_NUMBER_LIST:\n\t\treturn \"Enforce part number list\";\n\tcase MLX5_MODULE_EVENT_ERROR_UNKNOWN_IDENTIFIER:\n\t\treturn \"Unknown identifier\";\n\tcase MLX5_MODULE_EVENT_ERROR_HIGH_TEMPERATURE:\n\t\treturn \"High Temperature\";\n\tcase MLX5_MODULE_EVENT_ERROR_BAD_CABLE:\n\t\treturn \"Bad or shorted cable/module\";\n\tcase MLX5_MODULE_EVENT_ERROR_PCIE_POWER_SLOT_EXCEEDED:\n\t\treturn \"One or more network ports have been powered down due to insufficient/unadvertised power on the PCIe slot\";\n\tdefault:\n\t\treturn \"Unknown error\";\n\t}\n}\n\n \nstatic int port_module(struct notifier_block *nb, unsigned long type, void *data)\n{\n\tstruct mlx5_event_nb *event_nb = mlx5_nb_cof(nb, struct mlx5_event_nb, nb);\n\tstruct mlx5_events   *events   = event_nb->ctx;\n\tstruct mlx5_eqe      *eqe      = data;\n\n\tenum port_module_event_status_type module_status;\n\tenum port_module_event_error_type error_type;\n\tstruct mlx5_eqe_port_module *module_event_eqe;\n\tconst char *status_str;\n\tu8 module_num;\n\n\tmodule_event_eqe = &eqe->data.port_module;\n\tmodule_status = module_event_eqe->module_status &\n\t\t\tPORT_MODULE_EVENT_MODULE_STATUS_MASK;\n\terror_type = module_event_eqe->error_type &\n\t\t     PORT_MODULE_EVENT_ERROR_TYPE_MASK;\n\n\tif (module_status < MLX5_MODULE_STATUS_NUM)\n\t\tevents->pme_stats.status_counters[module_status]++;\n\n\tif (module_status == MLX5_MODULE_STATUS_ERROR)\n\t\tif (error_type < MLX5_MODULE_EVENT_ERROR_NUM)\n\t\t\tevents->pme_stats.error_counters[error_type]++;\n\n\tif (!printk_ratelimit())\n\t\treturn NOTIFY_OK;\n\n\tmodule_num = module_event_eqe->module;\n\tstatus_str = mlx5_pme_status_to_string(module_status);\n\tif (module_status == MLX5_MODULE_STATUS_ERROR) {\n\t\tconst char *error_str = mlx5_pme_error_to_string(error_type);\n\n\t\tmlx5_core_err(events->dev,\n\t\t\t      \"Port module event[error]: module %u, %s, %s\\n\",\n\t\t\t      module_num, status_str, error_str);\n\t} else {\n\t\tmlx5_core_info(events->dev,\n\t\t\t       \"Port module event: module %u, %s\\n\",\n\t\t\t       module_num, status_str);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nenum {\n\tMLX5_PCI_POWER_COULD_NOT_BE_READ = 0x0,\n\tMLX5_PCI_POWER_SUFFICIENT_REPORTED = 0x1,\n\tMLX5_PCI_POWER_INSUFFICIENT_REPORTED = 0x2,\n};\n\nstatic void mlx5_pcie_event(struct work_struct *work)\n{\n\tu32 out[MLX5_ST_SZ_DW(mpein_reg)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(mpein_reg)] = {0};\n\tstruct mlx5_events *events;\n\tstruct mlx5_core_dev *dev;\n\tu8 power_status;\n\tu16 pci_power;\n\n\tevents = container_of(work, struct mlx5_events, pcie_core_work);\n\tdev  = events->dev;\n\n\tif (!MLX5_CAP_MCAM_FEATURE(dev, pci_status_and_power))\n\t\treturn;\n\n\tmlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),\n\t\t\t     MLX5_REG_MPEIN, 0, 0);\n\tpower_status = MLX5_GET(mpein_reg, out, pwr_status);\n\tpci_power = MLX5_GET(mpein_reg, out, pci_power);\n\n\tswitch (power_status) {\n\tcase MLX5_PCI_POWER_COULD_NOT_BE_READ:\n\t\tmlx5_core_info_rl(dev,\n\t\t\t\t  \"PCIe slot power capability was not advertised.\\n\");\n\t\tbreak;\n\tcase MLX5_PCI_POWER_INSUFFICIENT_REPORTED:\n\t\tmlx5_core_warn_rl(dev,\n\t\t\t\t  \"Detected insufficient power on the PCIe slot (%uW).\\n\",\n\t\t\t\t  pci_power);\n\t\tbreak;\n\tcase MLX5_PCI_POWER_SUFFICIENT_REPORTED:\n\t\tmlx5_core_info_rl(dev,\n\t\t\t\t  \"PCIe slot advertised sufficient power (%uW).\\n\",\n\t\t\t\t  pci_power);\n\t\tbreak;\n\t}\n}\n\nstatic int pcie_core(struct notifier_block *nb, unsigned long type, void *data)\n{\n\tstruct mlx5_event_nb    *event_nb = mlx5_nb_cof(nb,\n\t\t\t\t\t\t\tstruct mlx5_event_nb,\n\t\t\t\t\t\t\tnb);\n\tstruct mlx5_events      *events   = event_nb->ctx;\n\tstruct mlx5_eqe         *eqe      = data;\n\n\tswitch (eqe->sub_type) {\n\tcase MLX5_GENERAL_SUBTYPE_PCI_POWER_CHANGE_EVENT:\n\t\t\tqueue_work(events->wq, &events->pcie_core_work);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nvoid mlx5_get_pme_stats(struct mlx5_core_dev *dev, struct mlx5_pme_stats *stats)\n{\n\t*stats = dev->priv.events->pme_stats;\n}\n\n \nstatic int forward_event(struct notifier_block *nb, unsigned long event, void *data)\n{\n\tstruct mlx5_event_nb *event_nb = mlx5_nb_cof(nb, struct mlx5_event_nb, nb);\n\tstruct mlx5_events   *events   = event_nb->ctx;\n\tstruct mlx5_eqe      *eqe      = data;\n\n\tmlx5_core_dbg(events->dev, \"Async eqe type %s, subtype (%d) forward to interfaces\\n\",\n\t\t      eqe_type_str(eqe->type), eqe->sub_type);\n\tatomic_notifier_call_chain(&events->fw_nh, event, data);\n\treturn NOTIFY_OK;\n}\n\nint mlx5_events_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_events *events = kzalloc(sizeof(*events), GFP_KERNEL);\n\n\tif (!events)\n\t\treturn -ENOMEM;\n\n\tATOMIC_INIT_NOTIFIER_HEAD(&events->fw_nh);\n\tevents->dev = dev;\n\tdev->priv.events = events;\n\tevents->wq = create_singlethread_workqueue(\"mlx5_events\");\n\tif (!events->wq) {\n\t\tkfree(events);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_WORK(&events->pcie_core_work, mlx5_pcie_event);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&events->sw_nh);\n\n\treturn 0;\n}\n\nvoid mlx5_events_cleanup(struct mlx5_core_dev *dev)\n{\n\tdestroy_workqueue(dev->priv.events->wq);\n\tkvfree(dev->priv.events);\n}\n\nvoid mlx5_events_start(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_events *events = dev->priv.events;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(events_nbs_ref); i++) {\n\t\tevents->notifiers[i].nb  = events_nbs_ref[i];\n\t\tevents->notifiers[i].ctx = events;\n\t\tmlx5_eq_notifier_register(dev, &events->notifiers[i].nb);\n\t}\n}\n\nvoid mlx5_events_stop(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_events *events = dev->priv.events;\n\tint i;\n\n\tfor (i = ARRAY_SIZE(events_nbs_ref) - 1; i >= 0 ; i--)\n\t\tmlx5_eq_notifier_unregister(dev, &events->notifiers[i].nb);\n\tflush_workqueue(events->wq);\n}\n\n \nint mlx5_notifier_register(struct mlx5_core_dev *dev, struct notifier_block *nb)\n{\n\tstruct mlx5_events *events = dev->priv.events;\n\n\treturn atomic_notifier_chain_register(&events->fw_nh, nb);\n}\nEXPORT_SYMBOL(mlx5_notifier_register);\n\nint mlx5_notifier_unregister(struct mlx5_core_dev *dev, struct notifier_block *nb)\n{\n\tstruct mlx5_events *events = dev->priv.events;\n\n\treturn atomic_notifier_chain_unregister(&events->fw_nh, nb);\n}\nEXPORT_SYMBOL(mlx5_notifier_unregister);\n\nint mlx5_notifier_call_chain(struct mlx5_events *events, unsigned int event, void *data)\n{\n\treturn atomic_notifier_call_chain(&events->fw_nh, event, data);\n}\n\n \nint mlx5_blocking_notifier_register(struct mlx5_core_dev *dev, struct notifier_block *nb)\n{\n\tstruct mlx5_events *events = dev->priv.events;\n\n\treturn blocking_notifier_chain_register(&events->sw_nh, nb);\n}\nEXPORT_SYMBOL(mlx5_blocking_notifier_register);\n\nint mlx5_blocking_notifier_unregister(struct mlx5_core_dev *dev, struct notifier_block *nb)\n{\n\tstruct mlx5_events *events = dev->priv.events;\n\n\treturn blocking_notifier_chain_unregister(&events->sw_nh, nb);\n}\nEXPORT_SYMBOL(mlx5_blocking_notifier_unregister);\n\nint mlx5_blocking_notifier_call_chain(struct mlx5_core_dev *dev, unsigned int event,\n\t\t\t\t      void *data)\n{\n\tstruct mlx5_events *events = dev->priv.events;\n\n\treturn blocking_notifier_call_chain(&events->sw_nh, event, data);\n}\n\nvoid mlx5_events_work_enqueue(struct mlx5_core_dev *dev, struct work_struct *work)\n{\n\tqueue_work(dev->priv.events->wq, work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}