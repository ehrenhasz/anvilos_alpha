{
  "module_name": "irq_affinity.c",
  "hash_id": "176f7eb6ff513e58cd18d74fdff8e5ba871c6179a784dbff962b3c091aea3590",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/irq_affinity.c",
  "human_readable_source": "\n \n\n#include \"mlx5_core.h\"\n#include \"mlx5_irq.h\"\n#include \"pci_irq.h\"\n\nstatic void cpu_put(struct mlx5_irq_pool *pool, int cpu)\n{\n\tpool->irqs_per_cpu[cpu]--;\n}\n\nstatic void cpu_get(struct mlx5_irq_pool *pool, int cpu)\n{\n\tpool->irqs_per_cpu[cpu]++;\n}\n\n \nstatic int cpu_get_least_loaded(struct mlx5_irq_pool *pool,\n\t\t\t\tconst struct cpumask *req_mask)\n{\n\tint best_cpu = -1;\n\tint cpu;\n\n\tfor_each_cpu_and(cpu, req_mask, cpu_online_mask) {\n\t\t \n\t\tif (!pool->irqs_per_cpu[cpu]) {\n\t\t\tbest_cpu = cpu;\n\t\t\tbreak;\n\t\t}\n\t\tif (best_cpu < 0)\n\t\t\tbest_cpu = cpu;\n\t\tif (pool->irqs_per_cpu[cpu] < pool->irqs_per_cpu[best_cpu])\n\t\t\tbest_cpu = cpu;\n\t}\n\tif (best_cpu == -1) {\n\t\t \n\t\tmlx5_core_err(pool->dev, \"NO online CPUs in req_mask (%*pbl)\\n\",\n\t\t\t      cpumask_pr_args(req_mask));\n\t\tbest_cpu = cpumask_first(cpu_online_mask);\n\t}\n\tpool->irqs_per_cpu[best_cpu]++;\n\treturn best_cpu;\n}\n\n \nstatic struct mlx5_irq *\nirq_pool_request_irq(struct mlx5_irq_pool *pool, struct irq_affinity_desc *af_desc)\n{\n\tstruct irq_affinity_desc auto_desc = {};\n\tu32 irq_index;\n\tint err;\n\n\terr = xa_alloc(&pool->irqs, &irq_index, NULL, pool->xa_num_irqs, GFP_KERNEL);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (pool->irqs_per_cpu) {\n\t\tif (cpumask_weight(&af_desc->mask) > 1)\n\t\t\t \n\t\t\tcpumask_set_cpu(cpu_get_least_loaded(pool, &af_desc->mask),\n\t\t\t\t\t&auto_desc.mask);\n\t\telse\n\t\t\tcpu_get(pool, cpumask_first(&af_desc->mask));\n\t}\n\treturn mlx5_irq_alloc(pool, irq_index,\n\t\t\t      cpumask_empty(&auto_desc.mask) ? af_desc : &auto_desc,\n\t\t\t      NULL);\n}\n\n \nstatic struct mlx5_irq *\nirq_pool_find_least_loaded(struct mlx5_irq_pool *pool, const struct cpumask *req_mask)\n{\n\tint start = pool->xa_num_irqs.min;\n\tint end = pool->xa_num_irqs.max;\n\tstruct mlx5_irq *irq = NULL;\n\tstruct mlx5_irq *iter;\n\tint irq_refcount = 0;\n\tunsigned long index;\n\n\tlockdep_assert_held(&pool->lock);\n\txa_for_each_range(&pool->irqs, index, iter, start, end) {\n\t\tstruct cpumask *iter_mask = mlx5_irq_get_affinity_mask(iter);\n\t\tint iter_refcount = mlx5_irq_read_locked(iter);\n\n\t\tif (!cpumask_subset(iter_mask, req_mask))\n\t\t\t \n\t\t\tcontinue;\n\t\tif (iter_refcount < pool->min_threshold)\n\t\t\t \n\t\t\treturn iter;\n\t\tif (!irq || iter_refcount < irq_refcount) {\n\t\t\t \n\t\t\tirq_refcount = iter_refcount;\n\t\t\tirq = iter;\n\t\t}\n\t}\n\treturn irq;\n}\n\n \nstruct mlx5_irq *\nmlx5_irq_affinity_request(struct mlx5_irq_pool *pool, struct irq_affinity_desc *af_desc)\n{\n\tstruct mlx5_irq *least_loaded_irq, *new_irq;\n\n\tmutex_lock(&pool->lock);\n\tleast_loaded_irq = irq_pool_find_least_loaded(pool, &af_desc->mask);\n\tif (least_loaded_irq &&\n\t    mlx5_irq_read_locked(least_loaded_irq) < pool->min_threshold)\n\t\tgoto out;\n\t \n\tnew_irq = irq_pool_request_irq(pool, af_desc);\n\tif (IS_ERR(new_irq)) {\n\t\tif (!least_loaded_irq) {\n\t\t\t \n\t\t\tmlx5_core_err(pool->dev, \"Didn't find a matching IRQ. err = %ld\\n\",\n\t\t\t\t      PTR_ERR(new_irq));\n\t\t\tmutex_unlock(&pool->lock);\n\t\t\treturn new_irq;\n\t\t}\n\t\t \n\t\tgoto out;\n\t}\n\tleast_loaded_irq = new_irq;\n\tgoto unlock;\nout:\n\tmlx5_irq_get_locked(least_loaded_irq);\n\tif (mlx5_irq_read_locked(least_loaded_irq) > pool->max_threshold)\n\t\tmlx5_core_dbg(pool->dev, \"IRQ %u overloaded, pool_name: %s, %u EQs on this irq\\n\",\n\t\t\t      pci_irq_vector(pool->dev->pdev,\n\t\t\t\t\t     mlx5_irq_get_index(least_loaded_irq)), pool->name,\n\t\t\t      mlx5_irq_read_locked(least_loaded_irq) / MLX5_EQ_REFS_PER_IRQ);\nunlock:\n\tmutex_unlock(&pool->lock);\n\treturn least_loaded_irq;\n}\n\nvoid mlx5_irq_affinity_irq_release(struct mlx5_core_dev *dev, struct mlx5_irq *irq)\n{\n\tstruct mlx5_irq_pool *pool = mlx5_irq_pool_get(dev);\n\tint cpu;\n\n\tcpu = cpumask_first(mlx5_irq_get_affinity_mask(irq));\n\tsynchronize_irq(pci_irq_vector(pool->dev->pdev,\n\t\t\t\t       mlx5_irq_get_index(irq)));\n\tif (mlx5_irq_put(irq))\n\t\tif (pool->irqs_per_cpu)\n\t\t\tcpu_put(pool, cpu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}