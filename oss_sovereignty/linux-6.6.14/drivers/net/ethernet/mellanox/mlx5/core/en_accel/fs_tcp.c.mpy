{
  "module_name": "fs_tcp.c",
  "hash_id": "d75d46354f697a2083a044d70d43a18425f0e50388a66bb067b67a5bccade957",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c",
  "human_readable_source": "\n \n\n#include <mlx5_core.h>\n#include \"en_accel/fs_tcp.h\"\n#include \"fs_core.h\"\n\nenum accel_fs_tcp_type {\n\tACCEL_FS_IPV4_TCP,\n\tACCEL_FS_IPV6_TCP,\n\tACCEL_FS_TCP_NUM_TYPES,\n};\n\nstruct mlx5e_accel_fs_tcp {\n\tstruct mlx5e_flow_table tables[ACCEL_FS_TCP_NUM_TYPES];\n\tstruct mlx5_flow_handle *default_rules[ACCEL_FS_TCP_NUM_TYPES];\n};\n\nstatic enum mlx5_traffic_types fs_accel2tt(enum accel_fs_tcp_type i)\n{\n\tswitch (i) {\n\tcase ACCEL_FS_IPV4_TCP:\n\t\treturn MLX5_TT_IPV4_TCP;\n\tdefault:  \n\t\treturn MLX5_TT_IPV6_TCP;\n\t}\n}\n\nstatic void accel_fs_tcp_set_ipv4_flow(struct mlx5_flow_spec *spec, struct sock *sk)\n{\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, IPPROTO_TCP);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version, 4);\n\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t       &inet_sk(sk)->inet_daddr, 4);\n\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t       &inet_sk(sk)->inet_rcv_saddr, 4);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void accel_fs_tcp_set_ipv6_flow(struct mlx5_flow_spec *spec, struct sock *sk)\n{\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, IPPROTO_TCP);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version, 6);\n\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t       &sk->sk_v6_daddr, 16);\n\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t       &inet6_sk(sk)->saddr, 16);\n\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t       0xff, 16);\n\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t       0xff, 16);\n}\n#endif\n\nvoid mlx5e_accel_fs_del_sk(struct mlx5_flow_handle *rule)\n{\n\tmlx5_del_flow_rules(rule);\n}\n\nstruct mlx5_flow_handle *mlx5e_accel_fs_add_sk(struct mlx5e_flow_steering *fs,\n\t\t\t\t\t       struct sock *sk, u32 tirn,\n\t\t\t\t\t       uint32_t flow_tag)\n{\n\tstruct mlx5e_accel_fs_tcp *fs_tcp = mlx5e_fs_get_accel_tcp(fs);\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5e_flow_table *ft = NULL;\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *flow;\n\tstruct mlx5_flow_spec *spec;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\taccel_fs_tcp_set_ipv4_flow(spec, sk);\n\t\tft = &fs_tcp->tables[ACCEL_FS_IPV4_TCP];\n\t\tfs_dbg(fs, \"%s flow is %pI4:%d -> %pI4:%d\\n\", __func__,\n\t\t       &inet_sk(sk)->inet_rcv_saddr,\n\t\t       inet_sk(sk)->inet_sport,\n\t\t       &inet_sk(sk)->inet_daddr,\n\t\t       inet_sk(sk)->inet_dport);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (!ipv6_only_sock(sk) &&\n\t\t    ipv6_addr_type(&sk->sk_v6_daddr) == IPV6_ADDR_MAPPED) {\n\t\t\taccel_fs_tcp_set_ipv4_flow(spec, sk);\n\t\t\tft = &fs_tcp->tables[ACCEL_FS_IPV4_TCP];\n\t\t} else {\n\t\t\taccel_fs_tcp_set_ipv6_flow(spec, sk);\n\t\t\tft = &fs_tcp->tables[ACCEL_FS_IPV6_TCP];\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ft) {\n\t\tflow = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.tcp_dport);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.tcp_sport);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.tcp_dport,\n\t\t ntohs(inet_sk(sk)->inet_sport));\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.tcp_sport,\n\t\t ntohs(inet_sk(sk)->inet_dport));\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\tdest.tir_num = tirn;\n\tif (flow_tag != MLX5_FS_DEFAULT_FLOW_TAG) {\n\t\tspec->flow_context.flow_tag = flow_tag;\n\t\tspec->flow_context.flags = FLOW_CONTEXT_HAS_TAG;\n\t}\n\n\tflow = mlx5_add_flow_rules(ft->t, spec, &flow_act, &dest, 1);\n\n\tif (IS_ERR(flow))\n\t\tfs_err(fs, \"mlx5_add_flow_rules() failed, flow is %ld\\n\", PTR_ERR(flow));\n\nout:\n\tkvfree(spec);\n\treturn flow;\n}\n\nstatic int accel_fs_tcp_add_default_rule(struct mlx5e_flow_steering *fs,\n\t\t\t\t\t enum accel_fs_tcp_type type)\n{\n\tstruct mlx5e_accel_fs_tcp *fs_tcp = mlx5e_fs_get_accel_tcp(fs);\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tstruct mlx5e_flow_table *accel_fs_t;\n\tstruct mlx5_flow_destination dest;\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tint err = 0;\n\n\taccel_fs_t = &fs_tcp->tables[type];\n\n\tdest = mlx5_ttc_get_default_dest(ttc, fs_accel2tt(type));\n\trule = mlx5_add_flow_rules(accel_fs_t->t, NULL, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tfs_err(fs, \"%s: add default rule failed, accel_fs type=%d, err %d\\n\",\n\t\t       __func__, type, err);\n\t\treturn err;\n\t}\n\n\tfs_tcp->default_rules[type] = rule;\n\treturn 0;\n}\n\n#define MLX5E_ACCEL_FS_TCP_NUM_GROUPS\t(2)\n#define MLX5E_ACCEL_FS_TCP_GROUP1_SIZE\t(BIT(16) - 1)\n#define MLX5E_ACCEL_FS_TCP_GROUP2_SIZE\t(BIT(0))\n#define MLX5E_ACCEL_FS_TCP_TABLE_SIZE\t(MLX5E_ACCEL_FS_TCP_GROUP1_SIZE +\\\n\t\t\t\t\t MLX5E_ACCEL_FS_TCP_GROUP2_SIZE)\nstatic int accel_fs_tcp_create_groups(struct mlx5e_flow_table *ft,\n\t\t\t\t      enum accel_fs_tcp_type type)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tvoid *outer_headers_c;\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tft->g = kcalloc(MLX5E_ACCEL_FS_TCP_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif  (!in || !ft->g) {\n\t\tkfree(ft->g);\n\t\tft->g = NULL;\n\t\tkvfree(in);\n\t\treturn -ENOMEM;\n\t}\n\n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\touter_headers_c = MLX5_ADDR_OF(fte_match_param, mc, outer_headers);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ip_protocol);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ip_version);\n\n\tswitch (type) {\n\tcase ACCEL_FS_IPV4_TCP:\n\tcase ACCEL_FS_IPV6_TCP:\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, tcp_dport);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, tcp_sport);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ACCEL_FS_IPV4_TCP:\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t src_ipv4_src_ipv6.ipv4_layout.ipv4);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\t\tbreak;\n\tcase ACCEL_FS_IPV6_TCP:\n\t\tmemset(MLX5_ADDR_OF(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       0xff, 16);\n\t\tmemset(MLX5_ADDR_OF(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       0xff, 16);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_ACCEL_FS_TCP_GROUP1_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_ACCEL_FS_TCP_GROUP2_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ft->g[ft->num_groups]);\n\tft->g[ft->num_groups] = NULL;\nout:\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int accel_fs_tcp_create_table(struct mlx5e_flow_steering *fs, enum accel_fs_tcp_type type)\n{\n\tstruct mlx5e_accel_fs_tcp *accel_tcp = mlx5e_fs_get_accel_tcp(fs);\n\tstruct mlx5_flow_namespace *ns = mlx5e_fs_get_ns(fs, false);\n\tstruct mlx5e_flow_table *ft = &accel_tcp->tables[type];\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tint err;\n\n\tft->num_groups = 0;\n\n\tft_attr.max_fte = MLX5E_ACCEL_FS_TCP_TABLE_SIZE;\n\tft_attr.level = MLX5E_ACCEL_FS_TCP_FT_LEVEL;\n\tft_attr.prio = MLX5E_NIC_PRIO;\n\n\tft->t = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft->t)) {\n\t\terr = PTR_ERR(ft->t);\n\t\tft->t = NULL;\n\t\treturn err;\n\t}\n\n\tfs_dbg(fs, \"Created fs accel table id %u level %u\\n\",\n\t       ft->t->id, ft->t->level);\n\n\terr = accel_fs_tcp_create_groups(ft, type);\n\tif (err)\n\t\tgoto err;\n\n\terr = accel_fs_tcp_add_default_rule(fs, type);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tmlx5e_destroy_flow_table(ft);\n\treturn err;\n}\n\nstatic int accel_fs_tcp_disable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tint err, i;\n\n\tfor (i = 0; i < ACCEL_FS_TCP_NUM_TYPES; i++) {\n\t\t \n\t\terr = mlx5_ttc_fwd_default_dest(ttc, fs_accel2tt(i));\n\t\tif (err) {\n\t\t\tfs_err(fs,\n\t\t\t       \"%s: modify ttc[%d] default destination failed, err(%d)\\n\",\n\t\t\t       __func__, fs_accel2tt(i), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int accel_fs_tcp_enable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_accel_fs_tcp *accel_tcp = mlx5e_fs_get_accel_tcp(fs);\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tstruct mlx5_flow_destination dest = {};\n\tint err, i;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tfor (i = 0; i < ACCEL_FS_TCP_NUM_TYPES; i++) {\n\t\tdest.ft = accel_tcp->tables[i].t;\n\n\t\t \n\t\terr = mlx5_ttc_fwd_dest(ttc, fs_accel2tt(i), &dest);\n\t\tif (err) {\n\t\t\tfs_err(fs, \"%s: modify ttc[%d] destination to accel failed, err(%d)\\n\",\n\t\t\t       __func__, fs_accel2tt(i), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void accel_fs_tcp_destroy_table(struct mlx5e_flow_steering *fs, int i)\n{\n\tstruct mlx5e_accel_fs_tcp *fs_tcp = mlx5e_fs_get_accel_tcp(fs);\n\n\tif (IS_ERR_OR_NULL(fs_tcp->tables[i].t))\n\t\treturn;\n\n\tmlx5_del_flow_rules(fs_tcp->default_rules[i]);\n\tmlx5e_destroy_flow_table(&fs_tcp->tables[i]);\n\tfs_tcp->tables[i].t = NULL;\n}\n\nvoid mlx5e_accel_fs_tcp_destroy(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_accel_fs_tcp *accel_tcp = mlx5e_fs_get_accel_tcp(fs);\n\tint i;\n\n\tif (!accel_tcp)\n\t\treturn;\n\n\taccel_fs_tcp_disable(fs);\n\n\tfor (i = 0; i < ACCEL_FS_TCP_NUM_TYPES; i++)\n\t\taccel_fs_tcp_destroy_table(fs, i);\n\n\tkfree(accel_tcp);\n\tmlx5e_fs_set_accel_tcp(fs, NULL);\n}\n\nint mlx5e_accel_fs_tcp_create(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_accel_fs_tcp *accel_tcp;\n\tint i, err;\n\n\tif (!MLX5_CAP_FLOWTABLE_NIC_RX(mlx5e_fs_get_mdev(fs), ft_field_support.outer_ip_version))\n\t\treturn -EOPNOTSUPP;\n\n\taccel_tcp = kzalloc(sizeof(*accel_tcp), GFP_KERNEL);\n\tif (!accel_tcp)\n\t\treturn -ENOMEM;\n\tmlx5e_fs_set_accel_tcp(fs, accel_tcp);\n\n\tfor (i = 0; i < ACCEL_FS_TCP_NUM_TYPES; i++) {\n\t\terr = accel_fs_tcp_create_table(fs, i);\n\t\tif (err)\n\t\t\tgoto err_destroy_tables;\n\t}\n\n\terr = accel_fs_tcp_enable(fs);\n\tif (err)\n\t\tgoto err_destroy_tables;\n\n\treturn 0;\n\nerr_destroy_tables:\n\twhile (--i >= 0)\n\t\taccel_fs_tcp_destroy_table(fs, i);\n\tkfree(accel_tcp);\n\tmlx5e_fs_set_accel_tcp(fs, NULL);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}