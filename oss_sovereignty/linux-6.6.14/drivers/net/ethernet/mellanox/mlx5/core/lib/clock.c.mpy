{
  "module_name": "clock.c",
  "hash_id": "faec3911aa55d67041fb3ccc6e293b7cdce201142f12498b733532fdb6f73905",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/clock.c",
  "human_readable_source": " \n\n#include <linux/clocksource.h>\n#include <linux/highmem.h>\n#include <linux/log2.h>\n#include <linux/ptp_clock_kernel.h>\n#include <rdma/mlx5-abi.h>\n#include \"lib/eq.h\"\n#include \"en.h\"\n#include \"clock.h\"\n\nenum {\n\tMLX5_PIN_MODE_IN\t\t= 0x0,\n\tMLX5_PIN_MODE_OUT\t\t= 0x1,\n};\n\nenum {\n\tMLX5_OUT_PATTERN_PULSE\t\t= 0x0,\n\tMLX5_OUT_PATTERN_PERIODIC\t= 0x1,\n};\n\nenum {\n\tMLX5_EVENT_MODE_DISABLE\t= 0x0,\n\tMLX5_EVENT_MODE_REPETETIVE\t= 0x1,\n\tMLX5_EVENT_MODE_ONCE_TILL_ARM\t= 0x2,\n};\n\nenum {\n\tMLX5_MTPPS_FS_ENABLE\t\t\t= BIT(0x0),\n\tMLX5_MTPPS_FS_PATTERN\t\t\t= BIT(0x2),\n\tMLX5_MTPPS_FS_PIN_MODE\t\t\t= BIT(0x3),\n\tMLX5_MTPPS_FS_TIME_STAMP\t\t= BIT(0x4),\n\tMLX5_MTPPS_FS_OUT_PULSE_DURATION\t= BIT(0x5),\n\tMLX5_MTPPS_FS_ENH_OUT_PER_ADJ\t\t= BIT(0x7),\n\tMLX5_MTPPS_FS_NPPS_PERIOD               = BIT(0x9),\n\tMLX5_MTPPS_FS_OUT_PULSE_DURATION_NS     = BIT(0xa),\n};\n\nenum {\n\tMLX5_MTUTC_OPERATION_ADJUST_TIME_MIN          = S16_MIN,\n\tMLX5_MTUTC_OPERATION_ADJUST_TIME_MAX          = S16_MAX,\n\tMLX5_MTUTC_OPERATION_ADJUST_TIME_EXTENDED_MIN = -200000,\n\tMLX5_MTUTC_OPERATION_ADJUST_TIME_EXTENDED_MAX = 200000,\n};\n\nstatic bool mlx5_real_time_mode(struct mlx5_core_dev *mdev)\n{\n\treturn (mlx5_is_real_time_rq(mdev) || mlx5_is_real_time_sq(mdev));\n}\n\nstatic bool mlx5_npps_real_time_supported(struct mlx5_core_dev *mdev)\n{\n\treturn (mlx5_real_time_mode(mdev) &&\n\t\tMLX5_CAP_MCAM_FEATURE(mdev, npps_period) &&\n\t\tMLX5_CAP_MCAM_FEATURE(mdev, out_pulse_duration_ns));\n}\n\nstatic bool mlx5_modify_mtutc_allowed(struct mlx5_core_dev *mdev)\n{\n\treturn MLX5_CAP_MCAM_FEATURE(mdev, ptpcyc2realtime_modify);\n}\n\nstatic u32 mlx5_ptp_shift_constant(u32 dev_freq_khz)\n{\n\t \n\n\treturn min(ilog2(dev_freq_khz) + 16,\n\t\t   ilog2((U32_MAX / NSEC_PER_MSEC) * dev_freq_khz));\n}\n\nstatic s32 mlx5_ptp_getmaxphase(struct ptp_clock_info *ptp)\n{\n\tstruct mlx5_clock *clock = container_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_core_dev *mdev;\n\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\n\treturn MLX5_CAP_MCAM_FEATURE(mdev, mtutc_time_adjustment_extended_range) ?\n\t\t       MLX5_MTUTC_OPERATION_ADJUST_TIME_EXTENDED_MAX :\n\t\t\t     MLX5_MTUTC_OPERATION_ADJUST_TIME_MAX;\n}\n\nstatic bool mlx5_is_mtutc_time_adj_cap(struct mlx5_core_dev *mdev, s64 delta)\n{\n\ts64 max = mlx5_ptp_getmaxphase(&mdev->clock.ptp_info);\n\n\tif (delta < -max || delta > max)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mlx5_set_mtutc(struct mlx5_core_dev *dev, u32 *mtutc, u32 size)\n{\n\tu32 out[MLX5_ST_SZ_DW(mtutc_reg)] = {};\n\n\tif (!MLX5_CAP_MCAM_REG(dev, mtutc))\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_core_access_reg(dev, mtutc, size, out, sizeof(out),\n\t\t\t\t    MLX5_REG_MTUTC, 0, 1);\n}\n\nstatic u64 mlx5_read_time(struct mlx5_core_dev *dev,\n\t\t\t  struct ptp_system_timestamp *sts,\n\t\t\t  bool real_time)\n{\n\tu32 timer_h, timer_h1, timer_l;\n\n\ttimer_h = ioread32be(real_time ? &dev->iseg->real_time_h :\n\t\t\t     &dev->iseg->internal_timer_h);\n\tptp_read_system_prets(sts);\n\ttimer_l = ioread32be(real_time ? &dev->iseg->real_time_l :\n\t\t\t     &dev->iseg->internal_timer_l);\n\tptp_read_system_postts(sts);\n\ttimer_h1 = ioread32be(real_time ? &dev->iseg->real_time_h :\n\t\t\t      &dev->iseg->internal_timer_h);\n\tif (timer_h != timer_h1) {\n\t\t \n\t\tptp_read_system_prets(sts);\n\t\ttimer_l = ioread32be(real_time ? &dev->iseg->real_time_l :\n\t\t\t\t     &dev->iseg->internal_timer_l);\n\t\tptp_read_system_postts(sts);\n\t}\n\n\treturn real_time ? REAL_TIME_TO_NS(timer_h1, timer_l) :\n\t\t\t   (u64)timer_l | (u64)timer_h1 << 32;\n}\n\nstatic u64 read_internal_timer(const struct cyclecounter *cc)\n{\n\tstruct mlx5_timer *timer = container_of(cc, struct mlx5_timer, cycles);\n\tstruct mlx5_clock *clock = container_of(timer, struct mlx5_clock, timer);\n\tstruct mlx5_core_dev *mdev = container_of(clock, struct mlx5_core_dev,\n\t\t\t\t\t\t  clock);\n\n\treturn mlx5_read_time(mdev, NULL, false) & cc->mask;\n}\n\nstatic void mlx5_update_clock_info_page(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_ib_clock_info *clock_info = mdev->clock_info;\n\tstruct mlx5_clock *clock = &mdev->clock;\n\tstruct mlx5_timer *timer;\n\tu32 sign;\n\n\tif (!clock_info)\n\t\treturn;\n\n\tsign = smp_load_acquire(&clock_info->sign);\n\tsmp_store_mb(clock_info->sign,\n\t\t     sign | MLX5_IB_CLOCK_INFO_KERNEL_UPDATING);\n\n\ttimer = &clock->timer;\n\tclock_info->cycles = timer->tc.cycle_last;\n\tclock_info->mult   = timer->cycles.mult;\n\tclock_info->nsec   = timer->tc.nsec;\n\tclock_info->frac   = timer->tc.frac;\n\n\tsmp_store_release(&clock_info->sign,\n\t\t\t  sign + MLX5_IB_CLOCK_INFO_KERNEL_UPDATING * 2);\n}\n\nstatic void mlx5_pps_out(struct work_struct *work)\n{\n\tstruct mlx5_pps *pps_info = container_of(work, struct mlx5_pps,\n\t\t\t\t\t\t out_work);\n\tstruct mlx5_clock *clock = container_of(pps_info, struct mlx5_clock,\n\t\t\t\t\t\tpps_info);\n\tstruct mlx5_core_dev *mdev = container_of(clock, struct mlx5_core_dev,\n\t\t\t\t\t\t  clock);\n\tu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < clock->ptp_info.n_pins; i++) {\n\t\tu64 tstart;\n\n\t\twrite_seqlock_irqsave(&clock->lock, flags);\n\t\ttstart = clock->pps_info.start[i];\n\t\tclock->pps_info.start[i] = 0;\n\t\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\t\tif (!tstart)\n\t\t\tcontinue;\n\n\t\tMLX5_SET(mtpps_reg, in, pin, i);\n\t\tMLX5_SET64(mtpps_reg, in, time_stamp, tstart);\n\t\tMLX5_SET(mtpps_reg, in, field_select, MLX5_MTPPS_FS_TIME_STAMP);\n\t\tmlx5_set_mtpps(mdev, in, sizeof(in));\n\t}\n}\n\nstatic void mlx5_timestamp_overflow(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct mlx5_core_dev *mdev;\n\tstruct mlx5_timer *timer;\n\tstruct mlx5_clock *clock;\n\tunsigned long flags;\n\n\ttimer = container_of(dwork, struct mlx5_timer, overflow_work);\n\tclock = container_of(timer, struct mlx5_clock, timer);\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto out;\n\n\twrite_seqlock_irqsave(&clock->lock, flags);\n\ttimecounter_read(&timer->tc);\n\tmlx5_update_clock_info_page(mdev);\n\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\nout:\n\tschedule_delayed_work(&timer->overflow_work, timer->overflow_period);\n}\n\nstatic int mlx5_ptp_settime_real_time(struct mlx5_core_dev *mdev,\n\t\t\t\t      const struct timespec64 *ts)\n{\n\tu32 in[MLX5_ST_SZ_DW(mtutc_reg)] = {};\n\n\tif (!mlx5_modify_mtutc_allowed(mdev))\n\t\treturn 0;\n\n\tif (ts->tv_sec < 0 || ts->tv_sec > U32_MAX ||\n\t    ts->tv_nsec < 0 || ts->tv_nsec > NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\tMLX5_SET(mtutc_reg, in, operation, MLX5_MTUTC_OPERATION_SET_TIME_IMMEDIATE);\n\tMLX5_SET(mtutc_reg, in, utc_sec, ts->tv_sec);\n\tMLX5_SET(mtutc_reg, in, utc_nsec, ts->tv_nsec);\n\n\treturn mlx5_set_mtutc(mdev, in, sizeof(in));\n}\n\nstatic int mlx5_ptp_settime(struct ptp_clock_info *ptp, const struct timespec64 *ts)\n{\n\tstruct mlx5_clock *clock = container_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_timer *timer = &clock->timer;\n\tstruct mlx5_core_dev *mdev;\n\tunsigned long flags;\n\tint err;\n\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\terr = mlx5_ptp_settime_real_time(mdev, ts);\n\tif (err)\n\t\treturn err;\n\n\twrite_seqlock_irqsave(&clock->lock, flags);\n\ttimecounter_init(&timer->tc, &timer->cycles, timespec64_to_ns(ts));\n\tmlx5_update_clock_info_page(mdev);\n\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\n\treturn 0;\n}\n\nstatic\nstruct timespec64 mlx5_ptp_gettimex_real_time(struct mlx5_core_dev *mdev,\n\t\t\t\t\t      struct ptp_system_timestamp *sts)\n{\n\tstruct timespec64 ts;\n\tu64 time;\n\n\ttime = mlx5_read_time(mdev, sts, true);\n\tts = ns_to_timespec64(time);\n\treturn ts;\n}\n\nstatic int mlx5_ptp_gettimex(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t     struct ptp_system_timestamp *sts)\n{\n\tstruct mlx5_clock *clock = container_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_timer *timer = &clock->timer;\n\tstruct mlx5_core_dev *mdev;\n\tunsigned long flags;\n\tu64 cycles, ns;\n\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\tif (mlx5_real_time_mode(mdev)) {\n\t\t*ts = mlx5_ptp_gettimex_real_time(mdev, sts);\n\t\tgoto out;\n\t}\n\n\twrite_seqlock_irqsave(&clock->lock, flags);\n\tcycles = mlx5_read_time(mdev, sts, false);\n\tns = timecounter_cyc2time(&timer->tc, cycles);\n\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\t*ts = ns_to_timespec64(ns);\nout:\n\treturn 0;\n}\n\nstatic int mlx5_ptp_adjtime_real_time(struct mlx5_core_dev *mdev, s64 delta)\n{\n\tu32 in[MLX5_ST_SZ_DW(mtutc_reg)] = {};\n\n\tif (!mlx5_modify_mtutc_allowed(mdev))\n\t\treturn 0;\n\n\t \n\tif (!mlx5_is_mtutc_time_adj_cap(mdev, delta)) {\n\t\tstruct timespec64 ts;\n\t\ts64 ns;\n\n\t\tts = mlx5_ptp_gettimex_real_time(mdev, NULL);\n\t\tns = timespec64_to_ns(&ts) + delta;\n\t\tts = ns_to_timespec64(ns);\n\t\treturn mlx5_ptp_settime_real_time(mdev, &ts);\n\t}\n\n\tMLX5_SET(mtutc_reg, in, operation, MLX5_MTUTC_OPERATION_ADJUST_TIME);\n\tMLX5_SET(mtutc_reg, in, time_adjustment, delta);\n\n\treturn mlx5_set_mtutc(mdev, in, sizeof(in));\n}\n\nstatic int mlx5_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct mlx5_clock *clock = container_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_timer *timer = &clock->timer;\n\tstruct mlx5_core_dev *mdev;\n\tunsigned long flags;\n\tint err;\n\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\n\terr = mlx5_ptp_adjtime_real_time(mdev, delta);\n\tif (err)\n\t\treturn err;\n\twrite_seqlock_irqsave(&clock->lock, flags);\n\ttimecounter_adjtime(&timer->tc, delta);\n\tmlx5_update_clock_info_page(mdev);\n\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mlx5_ptp_adjphase(struct ptp_clock_info *ptp, s32 delta)\n{\n\tstruct mlx5_clock *clock = container_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_core_dev *mdev;\n\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\n\treturn mlx5_ptp_adjtime_real_time(mdev, delta);\n}\n\nstatic int mlx5_ptp_freq_adj_real_time(struct mlx5_core_dev *mdev, long scaled_ppm)\n{\n\tu32 in[MLX5_ST_SZ_DW(mtutc_reg)] = {};\n\n\tif (!mlx5_modify_mtutc_allowed(mdev))\n\t\treturn 0;\n\n\tMLX5_SET(mtutc_reg, in, operation, MLX5_MTUTC_OPERATION_ADJUST_FREQ_UTC);\n\n\tif (MLX5_CAP_MCAM_FEATURE(mdev, mtutc_freq_adj_units)) {\n\t\tMLX5_SET(mtutc_reg, in, freq_adj_units,\n\t\t\t MLX5_MTUTC_FREQ_ADJ_UNITS_SCALED_PPM);\n\t\tMLX5_SET(mtutc_reg, in, freq_adjustment, scaled_ppm);\n\t} else {\n\t\tMLX5_SET(mtutc_reg, in, freq_adj_units, MLX5_MTUTC_FREQ_ADJ_UNITS_PPB);\n\t\tMLX5_SET(mtutc_reg, in, freq_adjustment, scaled_ppm_to_ppb(scaled_ppm));\n\t}\n\n\treturn mlx5_set_mtutc(mdev, in, sizeof(in));\n}\n\nstatic int mlx5_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct mlx5_clock *clock = container_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_timer *timer = &clock->timer;\n\tstruct mlx5_core_dev *mdev;\n\tunsigned long flags;\n\tu32 mult;\n\tint err;\n\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\n\terr = mlx5_ptp_freq_adj_real_time(mdev, scaled_ppm);\n\tif (err)\n\t\treturn err;\n\n\tmult = (u32)adjust_by_scaled_ppm(timer->nominal_c_mult, scaled_ppm);\n\n\twrite_seqlock_irqsave(&clock->lock, flags);\n\ttimecounter_read(&timer->tc);\n\ttimer->cycles.mult = mult;\n\tmlx5_update_clock_info_page(mdev);\n\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mlx5_extts_configure(struct ptp_clock_info *ptp,\n\t\t\t\tstruct ptp_clock_request *rq,\n\t\t\t\tint on)\n{\n\tstruct mlx5_clock *clock =\n\t\t\tcontainer_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_core_dev *mdev =\n\t\t\tcontainer_of(clock, struct mlx5_core_dev, clock);\n\tu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\n\tu32 field_select = 0;\n\tu8 pin_mode = 0;\n\tu8 pattern = 0;\n\tint pin = -1;\n\tint err = 0;\n\n\tif (!MLX5_PPS_CAP(mdev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\tPTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((rq->extts.flags & PTP_STRICT_FLAGS) &&\n\t    (rq->extts.flags & PTP_ENABLE_FEATURE) &&\n\t    (rq->extts.flags & PTP_EXTTS_EDGES) == PTP_EXTTS_EDGES)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rq->extts.index >= clock->ptp_info.n_pins)\n\t\treturn -EINVAL;\n\n\tpin = ptp_find_pin(clock->ptp, PTP_PF_EXTTS, rq->extts.index);\n\tif (pin < 0)\n\t\treturn -EBUSY;\n\n\tif (on) {\n\t\tpin_mode = MLX5_PIN_MODE_IN;\n\t\tpattern = !!(rq->extts.flags & PTP_FALLING_EDGE);\n\t\tfield_select = MLX5_MTPPS_FS_PIN_MODE |\n\t\t\t       MLX5_MTPPS_FS_PATTERN |\n\t\t\t       MLX5_MTPPS_FS_ENABLE;\n\t} else {\n\t\tfield_select = MLX5_MTPPS_FS_ENABLE;\n\t}\n\n\tMLX5_SET(mtpps_reg, in, pin, pin);\n\tMLX5_SET(mtpps_reg, in, pin_mode, pin_mode);\n\tMLX5_SET(mtpps_reg, in, pattern, pattern);\n\tMLX5_SET(mtpps_reg, in, enable, on);\n\tMLX5_SET(mtpps_reg, in, field_select, field_select);\n\n\terr = mlx5_set_mtpps(mdev, in, sizeof(in));\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5_set_mtppse(mdev, pin, 0,\n\t\t\t       MLX5_EVENT_MODE_REPETETIVE & on);\n}\n\nstatic u64 find_target_cycles(struct mlx5_core_dev *mdev, s64 target_ns)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\tu64 cycles_now, cycles_delta;\n\tu64 nsec_now, nsec_delta;\n\tstruct mlx5_timer *timer;\n\tunsigned long flags;\n\n\ttimer = &clock->timer;\n\n\tcycles_now = mlx5_read_time(mdev, NULL, false);\n\twrite_seqlock_irqsave(&clock->lock, flags);\n\tnsec_now = timecounter_cyc2time(&timer->tc, cycles_now);\n\tnsec_delta = target_ns - nsec_now;\n\tcycles_delta = div64_u64(nsec_delta << timer->cycles.shift,\n\t\t\t\t timer->cycles.mult);\n\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\n\treturn cycles_now + cycles_delta;\n}\n\nstatic u64 perout_conf_internal_timer(struct mlx5_core_dev *mdev, s64 sec)\n{\n\tstruct timespec64 ts = {};\n\ts64 target_ns;\n\n\tts.tv_sec = sec;\n\ttarget_ns = timespec64_to_ns(&ts);\n\n\treturn find_target_cycles(mdev, target_ns);\n}\n\nstatic u64 perout_conf_real_time(s64 sec, u32 nsec)\n{\n\treturn (u64)nsec | (u64)sec << 32;\n}\n\nstatic int perout_conf_1pps(struct mlx5_core_dev *mdev, struct ptp_clock_request *rq,\n\t\t\t    u64 *time_stamp, bool real_time)\n{\n\tstruct timespec64 ts;\n\ts64 ns;\n\n\tts.tv_nsec = rq->perout.period.nsec;\n\tts.tv_sec = rq->perout.period.sec;\n\tns = timespec64_to_ns(&ts);\n\n\tif ((ns >> 1) != 500000000LL)\n\t\treturn -EINVAL;\n\n\t*time_stamp = real_time ? perout_conf_real_time(rq->perout.start.sec, 0) :\n\t\t      perout_conf_internal_timer(mdev, rq->perout.start.sec);\n\n\treturn 0;\n}\n\n#define MLX5_MAX_PULSE_DURATION (BIT(__mlx5_bit_sz(mtpps_reg, out_pulse_duration_ns)) - 1)\nstatic int mlx5_perout_conf_out_pulse_duration(struct mlx5_core_dev *mdev,\n\t\t\t\t\t       struct ptp_clock_request *rq,\n\t\t\t\t\t       u32 *out_pulse_duration_ns)\n{\n\tstruct mlx5_pps *pps_info = &mdev->clock.pps_info;\n\tu32 out_pulse_duration;\n\tstruct timespec64 ts;\n\n\tif (rq->perout.flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\tts.tv_sec = rq->perout.on.sec;\n\t\tts.tv_nsec = rq->perout.on.nsec;\n\t\tout_pulse_duration = (u32)timespec64_to_ns(&ts);\n\t} else {\n\t\t \n\t\tts.tv_sec = rq->perout.period.sec;\n\t\tts.tv_nsec = rq->perout.period.nsec;\n\t\tout_pulse_duration = (u32)timespec64_to_ns(&ts) >> 1;\n\t}\n\n\tif (out_pulse_duration < pps_info->min_out_pulse_duration_ns ||\n\t    out_pulse_duration > MLX5_MAX_PULSE_DURATION) {\n\t\tmlx5_core_err(mdev, \"NPPS pulse duration %u is not in [%llu, %lu]\\n\",\n\t\t\t      out_pulse_duration, pps_info->min_out_pulse_duration_ns,\n\t\t\t      MLX5_MAX_PULSE_DURATION);\n\t\treturn -EINVAL;\n\t}\n\t*out_pulse_duration_ns = out_pulse_duration;\n\n\treturn 0;\n}\n\nstatic int perout_conf_npps_real_time(struct mlx5_core_dev *mdev, struct ptp_clock_request *rq,\n\t\t\t\t      u32 *field_select, u32 *out_pulse_duration_ns,\n\t\t\t\t      u64 *period, u64 *time_stamp)\n{\n\tstruct mlx5_pps *pps_info = &mdev->clock.pps_info;\n\tstruct ptp_clock_time *time = &rq->perout.start;\n\tstruct timespec64 ts;\n\n\tts.tv_sec = rq->perout.period.sec;\n\tts.tv_nsec = rq->perout.period.nsec;\n\tif (timespec64_to_ns(&ts) < pps_info->min_npps_period) {\n\t\tmlx5_core_err(mdev, \"NPPS period is lower than minimal npps period %llu\\n\",\n\t\t\t      pps_info->min_npps_period);\n\t\treturn -EINVAL;\n\t}\n\t*period = perout_conf_real_time(rq->perout.period.sec, rq->perout.period.nsec);\n\n\tif (mlx5_perout_conf_out_pulse_duration(mdev, rq, out_pulse_duration_ns))\n\t\treturn -EINVAL;\n\n\t*time_stamp = perout_conf_real_time(time->sec, time->nsec);\n\t*field_select |= MLX5_MTPPS_FS_NPPS_PERIOD |\n\t\t\t MLX5_MTPPS_FS_OUT_PULSE_DURATION_NS;\n\n\treturn 0;\n}\n\nstatic bool mlx5_perout_verify_flags(struct mlx5_core_dev *mdev, unsigned int flags)\n{\n\treturn ((!mlx5_npps_real_time_supported(mdev) && flags) ||\n\t\t(mlx5_npps_real_time_supported(mdev) && flags & ~PTP_PEROUT_DUTY_CYCLE));\n}\n\nstatic int mlx5_perout_configure(struct ptp_clock_info *ptp,\n\t\t\t\t struct ptp_clock_request *rq,\n\t\t\t\t int on)\n{\n\tstruct mlx5_clock *clock =\n\t\t\tcontainer_of(ptp, struct mlx5_clock, ptp_info);\n\tstruct mlx5_core_dev *mdev =\n\t\t\tcontainer_of(clock, struct mlx5_core_dev, clock);\n\tbool rt_mode = mlx5_real_time_mode(mdev);\n\tu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\n\tu32 out_pulse_duration_ns = 0;\n\tu32 field_select = 0;\n\tu64 npps_period = 0;\n\tu64 time_stamp = 0;\n\tu8 pin_mode = 0;\n\tu8 pattern = 0;\n\tint pin = -1;\n\tint err = 0;\n\n\tif (!MLX5_PPS_CAP(mdev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (mlx5_perout_verify_flags(mdev, rq->perout.flags))\n\t\treturn -EOPNOTSUPP;\n\n\tif (rq->perout.index >= clock->ptp_info.n_pins)\n\t\treturn -EINVAL;\n\n\tfield_select = MLX5_MTPPS_FS_ENABLE;\n\tpin = ptp_find_pin(clock->ptp, PTP_PF_PEROUT, rq->perout.index);\n\tif (pin < 0)\n\t\treturn -EBUSY;\n\n\tif (on) {\n\t\tbool rt_mode = mlx5_real_time_mode(mdev);\n\n\t\tpin_mode = MLX5_PIN_MODE_OUT;\n\t\tpattern = MLX5_OUT_PATTERN_PERIODIC;\n\n\t\tif (rt_mode &&  rq->perout.start.sec > U32_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tfield_select |= MLX5_MTPPS_FS_PIN_MODE |\n\t\t\t\tMLX5_MTPPS_FS_PATTERN |\n\t\t\t\tMLX5_MTPPS_FS_TIME_STAMP;\n\n\t\tif (mlx5_npps_real_time_supported(mdev))\n\t\t\terr = perout_conf_npps_real_time(mdev, rq, &field_select,\n\t\t\t\t\t\t\t &out_pulse_duration_ns, &npps_period,\n\t\t\t\t\t\t\t &time_stamp);\n\t\telse\n\t\t\terr = perout_conf_1pps(mdev, rq, &time_stamp, rt_mode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tMLX5_SET(mtpps_reg, in, pin, pin);\n\tMLX5_SET(mtpps_reg, in, pin_mode, pin_mode);\n\tMLX5_SET(mtpps_reg, in, pattern, pattern);\n\tMLX5_SET(mtpps_reg, in, enable, on);\n\tMLX5_SET64(mtpps_reg, in, time_stamp, time_stamp);\n\tMLX5_SET(mtpps_reg, in, field_select, field_select);\n\tMLX5_SET64(mtpps_reg, in, npps_period, npps_period);\n\tMLX5_SET(mtpps_reg, in, out_pulse_duration_ns, out_pulse_duration_ns);\n\terr = mlx5_set_mtpps(mdev, in, sizeof(in));\n\tif (err)\n\t\treturn err;\n\n\tif (rt_mode)\n\t\treturn 0;\n\n\treturn mlx5_set_mtppse(mdev, pin, 0,\n\t\t\t       MLX5_EVENT_MODE_REPETETIVE & on);\n}\n\nstatic int mlx5_pps_configure(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *rq,\n\t\t\t      int on)\n{\n\tstruct mlx5_clock *clock =\n\t\t\tcontainer_of(ptp, struct mlx5_clock, ptp_info);\n\n\tclock->pps_info.enabled = !!on;\n\treturn 0;\n}\n\nstatic int mlx5_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t   struct ptp_clock_request *rq,\n\t\t\t   int on)\n{\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn mlx5_extts_configure(ptp, rq, on);\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn mlx5_perout_configure(ptp, rq, on);\n\tcase PTP_CLK_REQ_PPS:\n\t\treturn mlx5_pps_configure(ptp, rq, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nenum {\n\tMLX5_MTPPS_REG_CAP_PIN_X_MODE_SUPPORT_PPS_IN = BIT(0),\n\tMLX5_MTPPS_REG_CAP_PIN_X_MODE_SUPPORT_PPS_OUT = BIT(1),\n};\n\nstatic int mlx5_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t   enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct mlx5_clock *clock = container_of(ptp, struct mlx5_clock,\n\t\t\t\t\t\tptp_info);\n\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\t\treturn 0;\n\tcase PTP_PF_EXTTS:\n\t\treturn !(clock->pps_info.pin_caps[pin] &\n\t\t\t MLX5_MTPPS_REG_CAP_PIN_X_MODE_SUPPORT_PPS_IN);\n\tcase PTP_PF_PEROUT:\n\t\treturn !(clock->pps_info.pin_caps[pin] &\n\t\t\t MLX5_MTPPS_REG_CAP_PIN_X_MODE_SUPPORT_PPS_OUT);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct ptp_clock_info mlx5_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"mlx5_ptp\",\n\t.max_adj\t= 50000000,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= mlx5_ptp_adjfine,\n\t.adjphase\t= mlx5_ptp_adjphase,\n\t.getmaxphase    = mlx5_ptp_getmaxphase,\n\t.adjtime\t= mlx5_ptp_adjtime,\n\t.gettimex64\t= mlx5_ptp_gettimex,\n\t.settime64\t= mlx5_ptp_settime,\n\t.enable\t\t= NULL,\n\t.verify\t\t= NULL,\n};\n\nstatic int mlx5_query_mtpps_pin_mode(struct mlx5_core_dev *mdev, u8 pin,\n\t\t\t\t     u32 *mtpps, u32 mtpps_size)\n{\n\tu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {};\n\n\tMLX5_SET(mtpps_reg, in, pin, pin);\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), mtpps,\n\t\t\t\t    mtpps_size, MLX5_REG_MTPPS, 0, 0);\n}\n\nstatic int mlx5_get_pps_pin_mode(struct mlx5_clock *clock, u8 pin)\n{\n\tstruct mlx5_core_dev *mdev = container_of(clock, struct mlx5_core_dev, clock);\n\n\tu32 out[MLX5_ST_SZ_DW(mtpps_reg)] = {};\n\tu8 mode;\n\tint err;\n\n\terr = mlx5_query_mtpps_pin_mode(mdev, pin, out, sizeof(out));\n\tif (err || !MLX5_GET(mtpps_reg, out, enable))\n\t\treturn PTP_PF_NONE;\n\n\tmode = MLX5_GET(mtpps_reg, out, pin_mode);\n\n\tif (mode == MLX5_PIN_MODE_IN)\n\t\treturn PTP_PF_EXTTS;\n\telse if (mode == MLX5_PIN_MODE_OUT)\n\t\treturn PTP_PF_PEROUT;\n\n\treturn PTP_PF_NONE;\n}\n\nstatic void mlx5_init_pin_config(struct mlx5_clock *clock)\n{\n\tint i;\n\n\tif (!clock->ptp_info.n_pins)\n\t\treturn;\n\n\tclock->ptp_info.pin_config =\n\t\t\tkcalloc(clock->ptp_info.n_pins,\n\t\t\t\tsizeof(*clock->ptp_info.pin_config),\n\t\t\t\tGFP_KERNEL);\n\tif (!clock->ptp_info.pin_config)\n\t\treturn;\n\tclock->ptp_info.enable = mlx5_ptp_enable;\n\tclock->ptp_info.verify = mlx5_ptp_verify;\n\tclock->ptp_info.pps = 1;\n\n\tfor (i = 0; i < clock->ptp_info.n_pins; i++) {\n\t\tsnprintf(clock->ptp_info.pin_config[i].name,\n\t\t\t sizeof(clock->ptp_info.pin_config[i].name),\n\t\t\t \"mlx5_pps%d\", i);\n\t\tclock->ptp_info.pin_config[i].index = i;\n\t\tclock->ptp_info.pin_config[i].func = mlx5_get_pps_pin_mode(clock, i);\n\t\tclock->ptp_info.pin_config[i].chan = 0;\n\t}\n}\n\nstatic void mlx5_get_pps_caps(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\tu32 out[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\n\n\tmlx5_query_mtpps(mdev, out, sizeof(out));\n\n\tclock->ptp_info.n_pins = MLX5_GET(mtpps_reg, out,\n\t\t\t\t\t  cap_number_of_pps_pins);\n\tclock->ptp_info.n_ext_ts = MLX5_GET(mtpps_reg, out,\n\t\t\t\t\t    cap_max_num_of_pps_in_pins);\n\tclock->ptp_info.n_per_out = MLX5_GET(mtpps_reg, out,\n\t\t\t\t\t     cap_max_num_of_pps_out_pins);\n\n\tif (MLX5_CAP_MCAM_FEATURE(mdev, npps_period))\n\t\tclock->pps_info.min_npps_period = 1 << MLX5_GET(mtpps_reg, out,\n\t\t\t\t\t\t\t\tcap_log_min_npps_period);\n\tif (MLX5_CAP_MCAM_FEATURE(mdev, out_pulse_duration_ns))\n\t\tclock->pps_info.min_out_pulse_duration_ns = 1 << MLX5_GET(mtpps_reg, out,\n\t\t\t\t\t\t\t\tcap_log_min_out_pulse_duration_ns);\n\n\tclock->pps_info.pin_caps[0] = MLX5_GET(mtpps_reg, out, cap_pin_0_mode);\n\tclock->pps_info.pin_caps[1] = MLX5_GET(mtpps_reg, out, cap_pin_1_mode);\n\tclock->pps_info.pin_caps[2] = MLX5_GET(mtpps_reg, out, cap_pin_2_mode);\n\tclock->pps_info.pin_caps[3] = MLX5_GET(mtpps_reg, out, cap_pin_3_mode);\n\tclock->pps_info.pin_caps[4] = MLX5_GET(mtpps_reg, out, cap_pin_4_mode);\n\tclock->pps_info.pin_caps[5] = MLX5_GET(mtpps_reg, out, cap_pin_5_mode);\n\tclock->pps_info.pin_caps[6] = MLX5_GET(mtpps_reg, out, cap_pin_6_mode);\n\tclock->pps_info.pin_caps[7] = MLX5_GET(mtpps_reg, out, cap_pin_7_mode);\n}\n\nstatic void ts_next_sec(struct timespec64 *ts)\n{\n\tts->tv_sec += 1;\n\tts->tv_nsec = 0;\n}\n\nstatic u64 perout_conf_next_event_timer(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5_clock *clock)\n{\n\tstruct timespec64 ts;\n\ts64 target_ns;\n\n\tmlx5_ptp_gettimex(&clock->ptp_info, &ts, NULL);\n\tts_next_sec(&ts);\n\ttarget_ns = timespec64_to_ns(&ts);\n\n\treturn find_target_cycles(mdev, target_ns);\n}\n\nstatic int mlx5_pps_event(struct notifier_block *nb,\n\t\t\t  unsigned long type, void *data)\n{\n\tstruct mlx5_clock *clock = mlx5_nb_cof(nb, struct mlx5_clock, pps_nb);\n\tstruct ptp_clock_event ptp_event;\n\tstruct mlx5_eqe *eqe = data;\n\tint pin = eqe->data.pps.pin;\n\tstruct mlx5_core_dev *mdev;\n\tunsigned long flags;\n\tu64 ns;\n\n\tmdev = container_of(clock, struct mlx5_core_dev, clock);\n\n\tswitch (clock->ptp_info.pin_config[pin].func) {\n\tcase PTP_PF_EXTTS:\n\t\tptp_event.index = pin;\n\t\tptp_event.timestamp = mlx5_real_time_mode(mdev) ?\n\t\t\tmlx5_real_time_cyc2time(clock,\n\t\t\t\t\t\tbe64_to_cpu(eqe->data.pps.time_stamp)) :\n\t\t\tmlx5_timecounter_cyc2time(clock,\n\t\t\t\t\t\t  be64_to_cpu(eqe->data.pps.time_stamp));\n\t\tif (clock->pps_info.enabled) {\n\t\t\tptp_event.type = PTP_CLOCK_PPSUSR;\n\t\t\tptp_event.pps_times.ts_real =\n\t\t\t\t\tns_to_timespec64(ptp_event.timestamp);\n\t\t} else {\n\t\t\tptp_event.type = PTP_CLOCK_EXTTS;\n\t\t}\n\t\t \n\t\tptp_clock_event(clock->ptp, &ptp_event);\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\t\tns = perout_conf_next_event_timer(mdev, clock);\n\t\twrite_seqlock_irqsave(&clock->lock, flags);\n\t\tclock->pps_info.start[pin] = ns;\n\t\twrite_sequnlock_irqrestore(&clock->lock, flags);\n\t\tschedule_work(&clock->pps_info.out_work);\n\t\tbreak;\n\tdefault:\n\t\tmlx5_core_err(mdev, \" Unhandled clock PPS event, func %d\\n\",\n\t\t\t      clock->ptp_info.pin_config[pin].func);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic void mlx5_timecounter_init(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\tstruct mlx5_timer *timer = &clock->timer;\n\tu32 dev_freq;\n\n\tdev_freq = MLX5_CAP_GEN(mdev, device_frequency_khz);\n\ttimer->cycles.read = read_internal_timer;\n\ttimer->cycles.shift = mlx5_ptp_shift_constant(dev_freq);\n\ttimer->cycles.mult = clocksource_khz2mult(dev_freq,\n\t\t\t\t\t\t  timer->cycles.shift);\n\ttimer->nominal_c_mult = timer->cycles.mult;\n\ttimer->cycles.mask = CLOCKSOURCE_MASK(41);\n\n\ttimecounter_init(&timer->tc, &timer->cycles,\n\t\t\t ktime_to_ns(ktime_get_real()));\n}\n\nstatic void mlx5_init_overflow_period(struct mlx5_clock *clock)\n{\n\tstruct mlx5_core_dev *mdev = container_of(clock, struct mlx5_core_dev, clock);\n\tstruct mlx5_ib_clock_info *clock_info = mdev->clock_info;\n\tstruct mlx5_timer *timer = &clock->timer;\n\tu64 overflow_cycles;\n\tu64 frac = 0;\n\tu64 ns;\n\n\t \n\toverflow_cycles = div64_u64(~0ULL >> 1, timer->cycles.mult);\n\toverflow_cycles = min(overflow_cycles, div_u64(timer->cycles.mask, 3));\n\n\tns = cyclecounter_cyc2ns(&timer->cycles, overflow_cycles,\n\t\t\t\t frac, &frac);\n\tdo_div(ns, NSEC_PER_SEC / HZ);\n\ttimer->overflow_period = ns;\n\n\tINIT_DELAYED_WORK(&timer->overflow_work, mlx5_timestamp_overflow);\n\tif (timer->overflow_period)\n\t\tschedule_delayed_work(&timer->overflow_work, 0);\n\telse\n\t\tmlx5_core_warn(mdev,\n\t\t\t       \"invalid overflow period, overflow_work is not scheduled\\n\");\n\n\tif (clock_info)\n\t\tclock_info->overflow_period = timer->overflow_period;\n}\n\nstatic void mlx5_init_clock_info(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\tstruct mlx5_ib_clock_info *info;\n\tstruct mlx5_timer *timer;\n\n\tmdev->clock_info = (struct mlx5_ib_clock_info *)get_zeroed_page(GFP_KERNEL);\n\tif (!mdev->clock_info) {\n\t\tmlx5_core_warn(mdev, \"Failed to allocate IB clock info page\\n\");\n\t\treturn;\n\t}\n\n\tinfo = mdev->clock_info;\n\ttimer = &clock->timer;\n\n\tinfo->nsec = timer->tc.nsec;\n\tinfo->cycles = timer->tc.cycle_last;\n\tinfo->mask = timer->cycles.mask;\n\tinfo->mult = timer->nominal_c_mult;\n\tinfo->shift = timer->cycles.shift;\n\tinfo->frac = timer->tc.frac;\n}\n\nstatic void mlx5_init_timer_clock(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\n\tmlx5_timecounter_init(mdev);\n\tmlx5_init_clock_info(mdev);\n\tmlx5_init_overflow_period(clock);\n\tclock->ptp_info = mlx5_ptp_clock_info;\n\n\tif (mlx5_real_time_mode(mdev)) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_real_ts64(&ts);\n\t\tmlx5_ptp_settime(&clock->ptp_info, &ts);\n\t}\n}\n\nstatic void mlx5_init_pps(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\n\tif (!MLX5_PPS_CAP(mdev))\n\t\treturn;\n\n\tmlx5_get_pps_caps(mdev);\n\tmlx5_init_pin_config(clock);\n}\n\nvoid mlx5_init_clock(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\n\tif (!MLX5_CAP_GEN(mdev, device_frequency_khz)) {\n\t\tmlx5_core_warn(mdev, \"invalid device_frequency_khz, aborting HW clock init\\n\");\n\t\treturn;\n\t}\n\n\tseqlock_init(&clock->lock);\n\tmlx5_init_timer_clock(mdev);\n\tINIT_WORK(&clock->pps_info.out_work, mlx5_pps_out);\n\n\t \n\tclock->ptp_info = mlx5_ptp_clock_info;\n\n\t \n\tmlx5_init_pps(mdev);\n\n\tclock->ptp = ptp_clock_register(&clock->ptp_info,\n\t\t\t\t\t&mdev->pdev->dev);\n\tif (IS_ERR(clock->ptp)) {\n\t\tmlx5_core_warn(mdev, \"ptp_clock_register failed %ld\\n\",\n\t\t\t       PTR_ERR(clock->ptp));\n\t\tclock->ptp = NULL;\n\t}\n\n\tMLX5_NB_INIT(&clock->pps_nb, mlx5_pps_event, PPS_EVENT);\n\tmlx5_eq_notifier_register(mdev, &clock->pps_nb);\n}\n\nvoid mlx5_cleanup_clock(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_clock *clock = &mdev->clock;\n\n\tif (!MLX5_CAP_GEN(mdev, device_frequency_khz))\n\t\treturn;\n\n\tmlx5_eq_notifier_unregister(mdev, &clock->pps_nb);\n\tif (clock->ptp) {\n\t\tptp_clock_unregister(clock->ptp);\n\t\tclock->ptp = NULL;\n\t}\n\n\tcancel_work_sync(&clock->pps_info.out_work);\n\tcancel_delayed_work_sync(&clock->timer.overflow_work);\n\n\tif (mdev->clock_info) {\n\t\tfree_page((unsigned long)mdev->clock_info);\n\t\tmdev->clock_info = NULL;\n\t}\n\n\tkfree(clock->ptp_info.pin_config);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}