{
  "module_name": "goto.c",
  "hash_id": "53467aa7b37b43933ff810eebd755ecbe86b18c843a64b1d530cc23d920c5a16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/goto.c",
  "human_readable_source": "\n\n\n#include \"act.h\"\n#include \"en/tc_priv.h\"\n#include \"eswitch.h\"\n\nstatic int\nvalidate_goto_chain(struct mlx5e_priv *priv,\n\t\t    struct mlx5e_tc_flow *flow,\n\t\t    struct mlx5_flow_attr *attr,\n\t\t    const struct flow_action_entry *act,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_tc_table *tc = mlx5e_fs_get_tc(priv->fs);\n\tbool is_esw = mlx5e_is_eswitch_flow(flow);\n\tbool ft_flow = mlx5e_is_ft_flow(flow);\n\tu32 dest_chain = act->chain_index;\n\tstruct mlx5_fs_chains *chains;\n\tstruct mlx5_eswitch *esw;\n\tu32 reformat_and_fwd;\n\tu32 max_chain;\n\n\tesw = priv->mdev->priv.eswitch;\n\tchains = is_esw ? esw_chains(esw) : mlx5e_nic_chains(tc);\n\tmax_chain = mlx5_chains_get_chain_range(chains);\n\treformat_and_fwd = is_esw ?\n\t\t\t   MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev, reformat_and_fwd_to_table) :\n\t\t\t   MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, reformat_and_fwd_to_table);\n\n\tif (ft_flow) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Goto action is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!mlx5_chains_backwards_supported(chains) &&\n\t    dest_chain <= attr->chain) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Goto lower numbered chain isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (dest_chain > max_chain) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Requested destination chain is out of supported range\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (attr->action & (MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT |\n\t\t\t    MLX5_FLOW_CONTEXT_ACTION_DECAP) &&\n\t    !reformat_and_fwd) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Goto chain is not allowed if action has reformat or decap\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\ntc_act_can_offload_goto(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t\tconst struct flow_action_entry *act,\n\t\t\tint act_index,\n\t\t\tstruct mlx5_flow_attr *attr)\n{\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct mlx5e_tc_flow *flow = parse_state->flow;\n\n\tif (validate_goto_chain(flow->priv, flow, attr, act, extack))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\ntc_act_parse_goto(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t  const struct flow_action_entry *act,\n\t\t  struct mlx5e_priv *priv,\n\t\t  struct mlx5_flow_attr *attr)\n{\n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tattr->dest_chain = act->chain_index;\n\n\treturn 0;\n}\n\nstatic int\ntc_act_post_parse_goto(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t       struct mlx5e_priv *priv,\n\t\t       struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct mlx5e_tc_flow *flow = parse_state->flow;\n\n\tif (!attr->dest_chain)\n\t\treturn 0;\n\n\tif (parse_state->decap) {\n\t\t \n\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Decap with goto isn't supported\");\n\t\tnetdev_warn(priv->netdev, \"Decap with goto isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!mlx5e_is_eswitch_flow(flow) && parse_attr->mirred_ifindex[0]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Mirroring goto chain rules isn't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstruct mlx5e_tc_act mlx5e_tc_act_goto = {\n\t.can_offload = tc_act_can_offload_goto,\n\t.parse_action = tc_act_parse_goto,\n\t.post_parse = tc_act_post_parse_goto,\n\t.is_terminating_action = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}