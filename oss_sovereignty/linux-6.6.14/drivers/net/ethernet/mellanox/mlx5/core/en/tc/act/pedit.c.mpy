{
  "module_name": "pedit.c",
  "hash_id": "770d45efaa45ebf46923e6d025fa87b5c25987571763dd5387327b638d56322b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c",
  "human_readable_source": "\n\n\n#include <linux/if_vlan.h>\n#include \"act.h\"\n#include \"pedit.h\"\n#include \"en/tc_priv.h\"\n#include \"en/mod_hdr.h\"\n\nstatic int pedit_header_offsets[] = {\n\t[FLOW_ACT_MANGLE_HDR_TYPE_ETH] = offsetof(struct pedit_headers, eth),\n\t[FLOW_ACT_MANGLE_HDR_TYPE_IP4] = offsetof(struct pedit_headers, ip4),\n\t[FLOW_ACT_MANGLE_HDR_TYPE_IP6] = offsetof(struct pedit_headers, ip6),\n\t[FLOW_ACT_MANGLE_HDR_TYPE_TCP] = offsetof(struct pedit_headers, tcp),\n\t[FLOW_ACT_MANGLE_HDR_TYPE_UDP] = offsetof(struct pedit_headers, udp),\n};\n\n#define pedit_header(_ph, _htype) ((void *)(_ph) + pedit_header_offsets[_htype])\n\nstatic int\nset_pedit_val(u8 hdr_type, u32 mask, u32 val, u32 offset,\n\t      struct pedit_headers_action *hdrs,\n\t      struct netlink_ext_ack *extack)\n{\n\tu32 *curr_pmask, *curr_pval;\n\n\tcurr_pmask = (u32 *)(pedit_header(&hdrs->masks, hdr_type) + offset);\n\tcurr_pval  = (u32 *)(pedit_header(&hdrs->vals, hdr_type) + offset);\n\n\tif (*curr_pmask & mask) {  \n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"curr_pmask and new mask same. Acting twice on same location\");\n\t\tgoto out_err;\n\t}\n\n\t*curr_pmask |= mask;\n\t*curr_pval  |= (val & mask);\n\n\treturn 0;\n\nout_err:\n\treturn -EOPNOTSUPP;\n}\n\nint\nmlx5e_tc_act_pedit_parse_action(struct mlx5e_priv *priv,\n\t\t\t\tconst struct flow_action_entry *act, int namespace,\n\t\t\t\tstruct pedit_headers_action *hdrs,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tu8 cmd = (act->id == FLOW_ACTION_MANGLE) ? 0 : 1;\n\tu8 htype = act->mangle.htype;\n\tint err = -EOPNOTSUPP;\n\tu32 mask, val, offset;\n\n\tif (htype == FLOW_ACT_MANGLE_UNSPEC) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"legacy pedit isn't offloaded\");\n\t\tgoto out_err;\n\t}\n\n\tif (!mlx5e_mod_hdr_max_actions(priv->mdev, namespace)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"The pedit offload action is not supported\");\n\t\tgoto out_err;\n\t}\n\n\tmask = act->mangle.mask;\n\tval = act->mangle.val;\n\toffset = act->mangle.offset;\n\n\terr = set_pedit_val(htype, ~mask, val, offset, &hdrs[cmd], extack);\n\tif (err)\n\t\tgoto out_err;\n\n\thdrs[cmd].pedits++;\n\n\treturn 0;\nout_err:\n\treturn err;\n}\n\nstatic int\ntc_act_parse_pedit(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t   const struct flow_action_entry *act,\n\t\t   struct mlx5e_priv *priv,\n\t\t   struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct mlx5e_tc_flow *flow = parse_state->flow;\n\tenum mlx5_flow_namespace_type ns_type;\n\tint err;\n\n\tns_type = mlx5e_get_flow_namespace(flow);\n\n\terr = mlx5e_tc_act_pedit_parse_action(flow->priv, act, ns_type, attr->parse_attr->hdrs,\n\t\t\t\t\t      parse_state->extack);\n\tif (err)\n\t\treturn err;\n\n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\n\tif (ns_type == MLX5_FLOW_NAMESPACE_FDB) {\n\t\tesw_attr->split_count = esw_attr->out_count;\n\t\tparse_state->if_count = 0;\n\t}\n\n\treturn 0;\n}\n\nstruct mlx5e_tc_act mlx5e_tc_act_pedit = {\n\t.parse_action = tc_act_parse_pedit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}