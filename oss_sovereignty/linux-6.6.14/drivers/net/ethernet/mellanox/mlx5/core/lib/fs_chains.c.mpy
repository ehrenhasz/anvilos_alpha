{
  "module_name": "fs_chains.c",
  "hash_id": "db87880750258bd64aa465d9ed4853294374171b0ba97f9eba55ad2f5316ee9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/fs_chains.c",
  "human_readable_source": "\n\n\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/mlx5_ifc.h>\n#include <linux/mlx5/fs.h>\n\n#include \"lib/fs_chains.h\"\n#include \"fs_ft_pool.h\"\n#include \"en/mapping.h\"\n#include \"fs_core.h\"\n#include \"en_tc.h\"\n\n#define chains_lock(chains) ((chains)->lock)\n#define chains_ht(chains) ((chains)->chains_ht)\n#define prios_ht(chains) ((chains)->prios_ht)\n#define chains_default_ft(chains) ((chains)->chains_default_ft)\n#define chains_end_ft(chains) ((chains)->chains_end_ft)\n#define FT_TBL_SZ (64 * 1024)\n\nstruct mlx5_fs_chains {\n\tstruct mlx5_core_dev *dev;\n\n\tstruct rhashtable chains_ht;\n\tstruct rhashtable prios_ht;\n\t \n\tstruct mutex lock;\n\n\tstruct mlx5_flow_table *chains_default_ft;\n\tstruct mlx5_flow_table *chains_end_ft;\n\tstruct mapping_ctx *chains_mapping;\n\n\tenum mlx5_flow_namespace_type ns;\n\tu32 group_num;\n\tu32 flags;\n\tint fs_base_prio;\n\tint fs_base_level;\n};\n\nstruct fs_chain {\n\tstruct rhash_head node;\n\n\tu32 chain;\n\n\tint ref;\n\tint id;\n\n\tstruct mlx5_fs_chains *chains;\n\tstruct list_head prios_list;\n\tstruct mlx5_flow_handle *restore_rule;\n\tstruct mlx5_modify_hdr *miss_modify_hdr;\n};\n\nstruct prio_key {\n\tu32 chain;\n\tu32 prio;\n\tu32 level;\n};\n\nstruct prio {\n\tstruct rhash_head node;\n\tstruct list_head list;\n\n\tstruct prio_key key;\n\n\tint ref;\n\n\tstruct fs_chain *chain;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_table *next_ft;\n\tstruct mlx5_flow_group *miss_group;\n\tstruct mlx5_flow_handle *miss_rule;\n};\n\nstatic const struct rhashtable_params chain_params = {\n\t.head_offset = offsetof(struct fs_chain, node),\n\t.key_offset = offsetof(struct fs_chain, chain),\n\t.key_len = sizeof_field(struct fs_chain, chain),\n\t.automatic_shrinking = true,\n};\n\nstatic const struct rhashtable_params prio_params = {\n\t.head_offset = offsetof(struct prio, node),\n\t.key_offset = offsetof(struct prio, key),\n\t.key_len = sizeof_field(struct prio, key),\n\t.automatic_shrinking = true,\n};\n\nbool mlx5_chains_prios_supported(struct mlx5_fs_chains *chains)\n{\n\treturn chains->flags & MLX5_CHAINS_AND_PRIOS_SUPPORTED;\n}\n\nbool mlx5_chains_ignore_flow_level_supported(struct mlx5_fs_chains *chains)\n{\n\treturn chains->flags & MLX5_CHAINS_IGNORE_FLOW_LEVEL_SUPPORTED;\n}\n\nbool mlx5_chains_backwards_supported(struct mlx5_fs_chains *chains)\n{\n\treturn mlx5_chains_prios_supported(chains) &&\n\t       mlx5_chains_ignore_flow_level_supported(chains);\n}\n\nu32 mlx5_chains_get_chain_range(struct mlx5_fs_chains *chains)\n{\n\tif (!mlx5_chains_prios_supported(chains))\n\t\treturn 1;\n\n\tif (mlx5_chains_ignore_flow_level_supported(chains))\n\t\treturn UINT_MAX - 1;\n\n\t \n\treturn FDB_TC_MAX_CHAIN;\n}\n\nu32 mlx5_chains_get_nf_ft_chain(struct mlx5_fs_chains *chains)\n{\n\treturn mlx5_chains_get_chain_range(chains) + 1;\n}\n\nu32 mlx5_chains_get_prio_range(struct mlx5_fs_chains *chains)\n{\n\tif (mlx5_chains_ignore_flow_level_supported(chains))\n\t\treturn UINT_MAX;\n\n\tif (!chains->dev->priv.eswitch ||\n\t    chains->dev->priv.eswitch->mode != MLX5_ESWITCH_OFFLOADS)\n\t\treturn 1;\n\n\t \n\treturn FDB_TC_MAX_PRIO;\n}\n\nstatic unsigned int mlx5_chains_get_level_range(struct mlx5_fs_chains *chains)\n{\n\tif (mlx5_chains_ignore_flow_level_supported(chains))\n\t\treturn UINT_MAX;\n\n\t \n\treturn FDB_TC_LEVELS_PER_PRIO;\n}\n\nvoid\nmlx5_chains_set_end_ft(struct mlx5_fs_chains *chains,\n\t\t       struct mlx5_flow_table *ft)\n{\n\tchains_end_ft(chains) = ft;\n}\n\nstatic struct mlx5_flow_table *\nmlx5_chains_create_table(struct mlx5_fs_chains *chains,\n\t\t\t u32 chain, u32 prio, u32 level)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_table *ft;\n\tint sz;\n\n\tif (chains->flags & MLX5_CHAINS_FT_TUNNEL_SUPPORTED)\n\t\tft_attr.flags |= (MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT |\n\t\t\t\t  MLX5_FLOW_TABLE_TUNNEL_EN_DECAP);\n\n\tsz = (chain == mlx5_chains_get_nf_ft_chain(chains)) ? FT_TBL_SZ : POOL_NEXT_SIZE;\n\tft_attr.max_fte = sz;\n\n\t \n\tft_attr.next_ft = chains_default_ft(chains);\n\n\t \n\tif (!mlx5_chains_ignore_flow_level_supported(chains) ||\n\t    (chain == 0 && prio == 1 && level == 0)) {\n\t\tft_attr.level = chains->fs_base_level;\n\t\tft_attr.prio = chains->fs_base_prio + prio - 1;\n\t\tns = (chains->ns == MLX5_FLOW_NAMESPACE_FDB) ?\n\t\t\tmlx5_get_fdb_sub_ns(chains->dev, chain) :\n\t\t\tmlx5_get_flow_namespace(chains->dev, chains->ns);\n\t} else {\n\t\tft_attr.flags |= MLX5_FLOW_TABLE_UNMANAGED;\n\t\tft_attr.prio = chains->fs_base_prio;\n\t\t \n\t\tft_attr.level = chains->fs_base_level + 1;\n\t\tns = mlx5_get_flow_namespace(chains->dev, chains->ns);\n\t}\n\n\tft_attr.autogroup.num_reserved_entries = 2;\n\tft_attr.autogroup.max_num_groups = chains->group_num;\n\tft = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft)) {\n\t\tmlx5_core_warn(chains->dev, \"Failed to create chains table err %d (chain: %d, prio: %d, level: %d, size: %d)\\n\",\n\t\t\t       (int)PTR_ERR(ft), chain, prio, level, sz);\n\t\treturn ft;\n\t}\n\n\treturn ft;\n}\n\nstatic int\ncreate_chain_restore(struct fs_chain *chain)\n{\n\tstruct mlx5_eswitch *esw = chain->chains->dev->priv.eswitch;\n\tu8 modact[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5_fs_chains *chains = chain->chains;\n\tenum mlx5e_tc_attr_to_reg mapped_obj_to_reg;\n\tstruct mlx5_modify_hdr *mod_hdr;\n\tu32 index;\n\tint err;\n\n\tif (chain->chain == mlx5_chains_get_nf_ft_chain(chains) ||\n\t    !mlx5_chains_prios_supported(chains) ||\n\t    !chains->chains_mapping)\n\t\treturn 0;\n\n\terr = mlx5_chains_get_chain_mapping(chains, chain->chain, &index);\n\tif (err)\n\t\treturn err;\n\tif (index == MLX5_FS_DEFAULT_FLOW_TAG) {\n\t\t \n\t\terr = mlx5_chains_get_chain_mapping(chains, chain->chain, &index);\n\t\tmapping_remove(chains->chains_mapping, MLX5_FS_DEFAULT_FLOW_TAG);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tchain->id = index;\n\n\tif (chains->ns == MLX5_FLOW_NAMESPACE_FDB) {\n\t\tmapped_obj_to_reg = MAPPED_OBJ_TO_REG;\n\t\tchain->restore_rule = esw_add_restore_rule(esw, chain->id);\n\t\tif (IS_ERR(chain->restore_rule)) {\n\t\t\terr = PTR_ERR(chain->restore_rule);\n\t\t\tgoto err_rule;\n\t\t}\n\t} else if (chains->ns == MLX5_FLOW_NAMESPACE_KERNEL) {\n\t\t \n\t\tmapped_obj_to_reg = NIC_MAPPED_OBJ_TO_REG;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto err_rule;\n\t}\n\n\tMLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, modact, field,\n\t\t mlx5e_tc_attr_to_reg_mappings[mapped_obj_to_reg].mfield);\n\tMLX5_SET(set_action_in, modact, offset,\n\t\t mlx5e_tc_attr_to_reg_mappings[mapped_obj_to_reg].moffset);\n\tMLX5_SET(set_action_in, modact, length,\n\t\t mlx5e_tc_attr_to_reg_mappings[mapped_obj_to_reg].mlen == 32 ?\n\t\t 0 : mlx5e_tc_attr_to_reg_mappings[mapped_obj_to_reg].mlen);\n\tMLX5_SET(set_action_in, modact, data, chain->id);\n\tmod_hdr = mlx5_modify_header_alloc(chains->dev, chains->ns,\n\t\t\t\t\t   1, modact);\n\tif (IS_ERR(mod_hdr)) {\n\t\terr = PTR_ERR(mod_hdr);\n\t\tgoto err_mod_hdr;\n\t}\n\tchain->miss_modify_hdr = mod_hdr;\n\n\treturn 0;\n\nerr_mod_hdr:\n\tif (!IS_ERR_OR_NULL(chain->restore_rule))\n\t\tmlx5_del_flow_rules(chain->restore_rule);\nerr_rule:\n\t \n\tmapping_remove(chains->chains_mapping, chain->id);\n\treturn err;\n}\n\nstatic void destroy_chain_restore(struct fs_chain *chain)\n{\n\tstruct mlx5_fs_chains *chains = chain->chains;\n\n\tif (!chain->miss_modify_hdr)\n\t\treturn;\n\n\tif (chain->restore_rule)\n\t\tmlx5_del_flow_rules(chain->restore_rule);\n\n\tmlx5_modify_header_dealloc(chains->dev, chain->miss_modify_hdr);\n\tmapping_remove(chains->chains_mapping, chain->id);\n}\n\nstatic struct fs_chain *\nmlx5_chains_create_chain(struct mlx5_fs_chains *chains, u32 chain)\n{\n\tstruct fs_chain *chain_s = NULL;\n\tint err;\n\n\tchain_s = kvzalloc(sizeof(*chain_s), GFP_KERNEL);\n\tif (!chain_s)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchain_s->chains = chains;\n\tchain_s->chain = chain;\n\tINIT_LIST_HEAD(&chain_s->prios_list);\n\n\terr = create_chain_restore(chain_s);\n\tif (err)\n\t\tgoto err_restore;\n\n\terr = rhashtable_insert_fast(&chains_ht(chains), &chain_s->node,\n\t\t\t\t     chain_params);\n\tif (err)\n\t\tgoto err_insert;\n\n\treturn chain_s;\n\nerr_insert:\n\tdestroy_chain_restore(chain_s);\nerr_restore:\n\tkvfree(chain_s);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlx5_chains_destroy_chain(struct fs_chain *chain)\n{\n\tstruct mlx5_fs_chains *chains = chain->chains;\n\n\trhashtable_remove_fast(&chains_ht(chains), &chain->node,\n\t\t\t       chain_params);\n\n\tdestroy_chain_restore(chain);\n\tkvfree(chain);\n}\n\nstatic struct fs_chain *\nmlx5_chains_get_chain(struct mlx5_fs_chains *chains, u32 chain)\n{\n\tstruct fs_chain *chain_s;\n\n\tchain_s = rhashtable_lookup_fast(&chains_ht(chains), &chain,\n\t\t\t\t\t chain_params);\n\tif (!chain_s) {\n\t\tchain_s = mlx5_chains_create_chain(chains, chain);\n\t\tif (IS_ERR(chain_s))\n\t\t\treturn chain_s;\n\t}\n\n\tchain_s->ref++;\n\n\treturn chain_s;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_chains_add_miss_rule(struct fs_chain *chain,\n\t\t\t  struct mlx5_flow_table *ft,\n\t\t\t  struct mlx5_flow_table *next_ft)\n{\n\tstruct mlx5_fs_chains *chains = chain->chains;\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act act = {};\n\n\tact.flags  = FLOW_ACT_NO_APPEND;\n\tif (mlx5_chains_ignore_flow_level_supported(chain->chains))\n\t\tact.flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;\n\n\tact.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tdest.type  = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = next_ft;\n\n\tif (chains->chains_mapping && next_ft == chains_end_ft(chains) &&\n\t    chain->chain != mlx5_chains_get_nf_ft_chain(chains) &&\n\t    mlx5_chains_prios_supported(chains)) {\n\t\tact.modify_hdr = chain->miss_modify_hdr;\n\t\tact.action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t}\n\n\treturn mlx5_add_flow_rules(ft, NULL, &act, &dest, 1);\n}\n\nstatic int\nmlx5_chains_update_prio_prevs(struct prio *prio,\n\t\t\t      struct mlx5_flow_table *next_ft)\n{\n\tstruct mlx5_flow_handle *miss_rules[FDB_TC_LEVELS_PER_PRIO + 1] = {};\n\tstruct fs_chain *chain = prio->chain;\n\tstruct prio *pos;\n\tint n = 0, err;\n\n\tif (prio->key.level)\n\t\treturn 0;\n\n\t \n\tpos = prio;\n\tlist_for_each_entry_continue_reverse(pos,\n\t\t\t\t\t     &chain->prios_list,\n\t\t\t\t\t     list) {\n\t\tmiss_rules[n] = mlx5_chains_add_miss_rule(chain,\n\t\t\t\t\t\t\t  pos->ft,\n\t\t\t\t\t\t\t  next_ft);\n\t\tif (IS_ERR(miss_rules[n])) {\n\t\t\terr = PTR_ERR(miss_rules[n]);\n\t\t\tgoto err_prev_rule;\n\t\t}\n\n\t\tn++;\n\t\tif (!pos->key.level)\n\t\t\tbreak;\n\t}\n\n\t \n\tn = 0;\n\tpos = prio;\n\tlist_for_each_entry_continue_reverse(pos,\n\t\t\t\t\t     &chain->prios_list,\n\t\t\t\t\t     list) {\n\t\tmlx5_del_flow_rules(pos->miss_rule);\n\n\t\tpos->miss_rule = miss_rules[n];\n\t\tpos->next_ft = next_ft;\n\n\t\tn++;\n\t\tif (!pos->key.level)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr_prev_rule:\n\twhile (--n >= 0)\n\t\tmlx5_del_flow_rules(miss_rules[n]);\n\n\treturn err;\n}\n\nstatic void\nmlx5_chains_put_chain(struct fs_chain *chain)\n{\n\tif (--chain->ref == 0)\n\t\tmlx5_chains_destroy_chain(chain);\n}\n\nstatic struct prio *\nmlx5_chains_create_prio(struct mlx5_fs_chains *chains,\n\t\t\tu32 chain, u32 prio, u32 level)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_handle *miss_rule;\n\tstruct mlx5_flow_group *miss_group;\n\tstruct mlx5_flow_table *next_ft;\n\tstruct mlx5_flow_table *ft;\n\tstruct fs_chain *chain_s;\n\tstruct list_head *pos;\n\tstruct prio *prio_s;\n\tu32 *flow_group_in;\n\tint err;\n\n\tchain_s = mlx5_chains_get_chain(chains, chain);\n\tif (IS_ERR(chain_s))\n\t\treturn ERR_CAST(chain_s);\n\n\tprio_s = kvzalloc(sizeof(*prio_s), GFP_KERNEL);\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!prio_s || !flow_group_in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\t \n\n\t \n\tnext_ft = (chain == mlx5_chains_get_nf_ft_chain(chains)) ?\n\t\t  chains_default_ft(chains) :\n\t\t  chains_end_ft(chains);\n\tlist_for_each(pos, &chain_s->prios_list) {\n\t\tstruct prio *p = list_entry(pos, struct prio, list);\n\n\t\t \n\t\tif (prio < p->key.prio || (prio == p->key.prio &&\n\t\t\t\t\t   level < p->key.level)) {\n\t\t\t \n\t\t\tnext_ft = p->key.level == 0 ? p->ft : p->next_ft;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tft = mlx5_chains_create_table(chains, chain, prio, level);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_create;\n\t}\n\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index,\n\t\t ft->max_fte - 2);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index,\n\t\t ft->max_fte - 1);\n\tmiss_group = mlx5_create_flow_group(ft, flow_group_in);\n\tif (IS_ERR(miss_group)) {\n\t\terr = PTR_ERR(miss_group);\n\t\tgoto err_group;\n\t}\n\n\t \n\tmiss_rule = mlx5_chains_add_miss_rule(chain_s, ft, next_ft);\n\tif (IS_ERR(miss_rule)) {\n\t\terr = PTR_ERR(miss_rule);\n\t\tgoto err_miss_rule;\n\t}\n\n\tprio_s->miss_group = miss_group;\n\tprio_s->miss_rule = miss_rule;\n\tprio_s->next_ft = next_ft;\n\tprio_s->chain = chain_s;\n\tprio_s->key.chain = chain;\n\tprio_s->key.prio = prio;\n\tprio_s->key.level = level;\n\tprio_s->ft = ft;\n\n\terr = rhashtable_insert_fast(&prios_ht(chains), &prio_s->node,\n\t\t\t\t     prio_params);\n\tif (err)\n\t\tgoto err_insert;\n\n\tlist_add(&prio_s->list, pos->prev);\n\n\t \n\terr = mlx5_chains_update_prio_prevs(prio_s, ft);\n\tif (err)\n\t\tgoto err_update;\n\n\tkvfree(flow_group_in);\n\treturn prio_s;\n\nerr_update:\n\tlist_del(&prio_s->list);\n\trhashtable_remove_fast(&prios_ht(chains), &prio_s->node,\n\t\t\t       prio_params);\nerr_insert:\n\tmlx5_del_flow_rules(miss_rule);\nerr_miss_rule:\n\tmlx5_destroy_flow_group(miss_group);\nerr_group:\n\tmlx5_destroy_flow_table(ft);\nerr_create:\nerr_alloc:\n\tkvfree(prio_s);\n\tkvfree(flow_group_in);\n\tmlx5_chains_put_chain(chain_s);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlx5_chains_destroy_prio(struct mlx5_fs_chains *chains,\n\t\t\t struct prio *prio)\n{\n\tstruct fs_chain *chain = prio->chain;\n\n\tWARN_ON(mlx5_chains_update_prio_prevs(prio,\n\t\t\t\t\t      prio->next_ft));\n\n\tlist_del(&prio->list);\n\trhashtable_remove_fast(&prios_ht(chains), &prio->node,\n\t\t\t       prio_params);\n\tmlx5_del_flow_rules(prio->miss_rule);\n\tmlx5_destroy_flow_group(prio->miss_group);\n\tmlx5_destroy_flow_table(prio->ft);\n\tmlx5_chains_put_chain(chain);\n\tkvfree(prio);\n}\n\nstruct mlx5_flow_table *\nmlx5_chains_get_table(struct mlx5_fs_chains *chains, u32 chain, u32 prio,\n\t\t      u32 level)\n{\n\tstruct mlx5_flow_table *prev_fts;\n\tstruct prio *prio_s;\n\tstruct prio_key key;\n\tint l = 0;\n\n\tif ((chain > mlx5_chains_get_chain_range(chains) &&\n\t     chain != mlx5_chains_get_nf_ft_chain(chains)) ||\n\t    prio > mlx5_chains_get_prio_range(chains) ||\n\t    level > mlx5_chains_get_level_range(chains))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\t \n\tfor (l = 0; l < level; l++) {\n\t\tprev_fts = mlx5_chains_get_table(chains, chain, prio, l);\n\t\tif (IS_ERR(prev_fts)) {\n\t\t\tprio_s = ERR_CAST(prev_fts);\n\t\t\tgoto err_get_prevs;\n\t\t}\n\t}\n\n\tkey.chain = chain;\n\tkey.prio = prio;\n\tkey.level = level;\n\n\tmutex_lock(&chains_lock(chains));\n\tprio_s = rhashtable_lookup_fast(&prios_ht(chains), &key,\n\t\t\t\t\tprio_params);\n\tif (!prio_s) {\n\t\tprio_s = mlx5_chains_create_prio(chains, chain,\n\t\t\t\t\t\t prio, level);\n\t\tif (IS_ERR(prio_s))\n\t\t\tgoto err_create_prio;\n\t}\n\n\t++prio_s->ref;\n\tmutex_unlock(&chains_lock(chains));\n\n\treturn prio_s->ft;\n\nerr_create_prio:\n\tmutex_unlock(&chains_lock(chains));\nerr_get_prevs:\n\twhile (--l >= 0)\n\t\tmlx5_chains_put_table(chains, chain, prio, l);\n\treturn ERR_CAST(prio_s);\n}\n\nvoid\nmlx5_chains_put_table(struct mlx5_fs_chains *chains, u32 chain, u32 prio,\n\t\t      u32 level)\n{\n\tstruct prio *prio_s;\n\tstruct prio_key key;\n\n\tkey.chain = chain;\n\tkey.prio = prio;\n\tkey.level = level;\n\n\tmutex_lock(&chains_lock(chains));\n\tprio_s = rhashtable_lookup_fast(&prios_ht(chains), &key,\n\t\t\t\t\tprio_params);\n\tif (!prio_s)\n\t\tgoto err_get_prio;\n\n\tif (--prio_s->ref == 0)\n\t\tmlx5_chains_destroy_prio(chains, prio_s);\n\tmutex_unlock(&chains_lock(chains));\n\n\twhile (level-- > 0)\n\t\tmlx5_chains_put_table(chains, chain, prio, level);\n\n\treturn;\n\nerr_get_prio:\n\tmutex_unlock(&chains_lock(chains));\n\tWARN_ONCE(1,\n\t\t  \"Couldn't find table: (chain: %d prio: %d level: %d)\",\n\t\t  chain, prio, level);\n}\n\nstruct mlx5_flow_table *\nmlx5_chains_get_tc_end_ft(struct mlx5_fs_chains *chains)\n{\n\treturn chains_end_ft(chains);\n}\n\nstruct mlx5_flow_table *\nmlx5_chains_create_global_table(struct mlx5_fs_chains *chains)\n{\n\tu32 chain, prio, level;\n\tint err;\n\n\tif (!mlx5_chains_ignore_flow_level_supported(chains)) {\n\t\terr = -EOPNOTSUPP;\n\n\t\tmlx5_core_warn(chains->dev,\n\t\t\t       \"Couldn't create global flow table, ignore_flow_level not supported.\");\n\t\tgoto err_ignore;\n\t}\n\n\tchain = mlx5_chains_get_chain_range(chains),\n\tprio = mlx5_chains_get_prio_range(chains);\n\tlevel = mlx5_chains_get_level_range(chains);\n\n\treturn mlx5_chains_create_table(chains, chain, prio, level);\n\nerr_ignore:\n\treturn ERR_PTR(err);\n}\n\nvoid\nmlx5_chains_destroy_global_table(struct mlx5_fs_chains *chains,\n\t\t\t\t struct mlx5_flow_table *ft)\n{\n\tmlx5_destroy_flow_table(ft);\n}\n\nstatic struct mlx5_fs_chains *\nmlx5_chains_init(struct mlx5_core_dev *dev, struct mlx5_chains_attr *attr)\n{\n\tstruct mlx5_fs_chains *chains;\n\tint err;\n\n\tchains = kzalloc(sizeof(*chains), GFP_KERNEL);\n\tif (!chains)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchains->dev = dev;\n\tchains->flags = attr->flags;\n\tchains->ns = attr->ns;\n\tchains->group_num = attr->max_grp_num;\n\tchains->chains_mapping = attr->mapping;\n\tchains->fs_base_prio = attr->fs_base_prio;\n\tchains->fs_base_level = attr->fs_base_level;\n\tchains_default_ft(chains) = chains_end_ft(chains) = attr->default_ft;\n\n\terr = rhashtable_init(&chains_ht(chains), &chain_params);\n\tif (err)\n\t\tgoto init_chains_ht_err;\n\n\terr = rhashtable_init(&prios_ht(chains), &prio_params);\n\tif (err)\n\t\tgoto init_prios_ht_err;\n\n\tmutex_init(&chains_lock(chains));\n\n\treturn chains;\n\ninit_prios_ht_err:\n\trhashtable_destroy(&chains_ht(chains));\ninit_chains_ht_err:\n\tkfree(chains);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlx5_chains_cleanup(struct mlx5_fs_chains *chains)\n{\n\tmutex_destroy(&chains_lock(chains));\n\trhashtable_destroy(&prios_ht(chains));\n\trhashtable_destroy(&chains_ht(chains));\n\n\tkfree(chains);\n}\n\nstruct mlx5_fs_chains *\nmlx5_chains_create(struct mlx5_core_dev *dev, struct mlx5_chains_attr *attr)\n{\n\tstruct mlx5_fs_chains *chains;\n\n\tchains = mlx5_chains_init(dev, attr);\n\n\treturn chains;\n}\n\nvoid\nmlx5_chains_destroy(struct mlx5_fs_chains *chains)\n{\n\tmlx5_chains_cleanup(chains);\n}\n\nint\nmlx5_chains_get_chain_mapping(struct mlx5_fs_chains *chains, u32 chain,\n\t\t\t      u32 *chain_mapping)\n{\n\tstruct mapping_ctx *ctx = chains->chains_mapping;\n\tstruct mlx5_mapped_obj mapped_obj = {};\n\n\tmapped_obj.type = MLX5_MAPPED_OBJ_CHAIN;\n\tmapped_obj.chain = chain;\n\treturn mapping_add(ctx, &mapped_obj, chain_mapping);\n}\n\nint\nmlx5_chains_put_chain_mapping(struct mlx5_fs_chains *chains, u32 chain_mapping)\n{\n\tstruct mapping_ctx *ctx = chains->chains_mapping;\n\n\treturn mapping_remove(ctx, chain_mapping);\n}\n\nvoid\nmlx5_chains_print_info(struct mlx5_fs_chains *chains)\n{\n\tmlx5_core_dbg(chains->dev, \"Flow table chains groups(%d)\\n\", chains->group_num);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}