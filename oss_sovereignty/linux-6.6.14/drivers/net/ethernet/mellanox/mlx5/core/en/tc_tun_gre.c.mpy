{
  "module_name": "tc_tun_gre.c",
  "hash_id": "49a13772ce264c95f14b714ef76f5b8da8f4cf05cdbea639357b76e8940a35c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun_gre.c",
  "human_readable_source": "\n \n\n#include <net/gre.h>\n#include \"en/tc_tun.h\"\n\nstatic bool mlx5e_tc_tun_can_offload_gretap(struct mlx5e_priv *priv)\n{\n\treturn !!MLX5_CAP_ESW(priv->mdev, nvgre_encap_decap);\n}\n\nstatic int mlx5e_tc_tun_calc_hlen_gretap(struct mlx5e_encap_entry *e)\n{\n\treturn gre_calc_hlen(e->tun_info->key.tun_flags);\n}\n\nstatic int mlx5e_tc_tun_init_encap_attr_gretap(struct net_device *tunnel_dev,\n\t\t\t\t\t       struct mlx5e_priv *priv,\n\t\t\t\t\t       struct mlx5e_encap_entry *e,\n\t\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\te->tunnel = &gre_tunnel;\n\te->reformat_type = MLX5_REFORMAT_TYPE_L2_TO_NVGRE;\n\treturn 0;\n}\n\nstatic int mlx5e_gen_ip_tunnel_header_gretap(char buf[],\n\t\t\t\t\t     __u8 *ip_proto,\n\t\t\t\t\t     struct mlx5e_encap_entry *e)\n{\n\tconst struct ip_tunnel_key *tun_key  = &e->tun_info->key;\n\tstruct gre_base_hdr *greh = (struct gre_base_hdr *)(buf);\n\t__be32 tun_id = tunnel_id_to_key32(tun_key->tun_id);\n\tint hdr_len;\n\n\t*ip_proto = IPPROTO_GRE;\n\n\t \n\tif (tun_key->tun_flags & (TUNNEL_CSUM | TUNNEL_SEQ))\n\t\treturn -EOPNOTSUPP;\n\n\tgreh->protocol = htons(ETH_P_TEB);\n\n\t \n\thdr_len\t= mlx5e_tc_tun_calc_hlen_gretap(e);\n\tgreh->flags = gre_tnl_flags_to_gre_flags(tun_key->tun_flags);\n\tif (tun_key->tun_flags & TUNNEL_KEY) {\n\t\t__be32 *ptr = (__be32 *)(((u8 *)greh) + hdr_len - 4);\n\t\t*ptr = tun_id;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_gretap(struct mlx5e_priv *priv,\n\t\t\t\t     struct mlx5_flow_spec *spec,\n\t\t\t\t     struct flow_cls_offload *f,\n\t\t\t\t     void *headers_c,\n\t\t\t\t     void *headers_v)\n{\n\tvoid *misc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);\n\tvoid *misc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, ip_protocol);\n\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_protocol, IPPROTO_GRE);\n\n\t \n\tMLX5_SET_TO_ONES(fte_match_set_misc, misc_c, gre_protocol);\n\tMLX5_SET(fte_match_set_misc, misc_v, gre_protocol, ETH_P_TEB);\n\n\t \n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID)) {\n\t\tstruct flow_match_enc_keyid enc_keyid;\n\n\t\tflow_rule_match_enc_keyid(rule, &enc_keyid);\n\t\tMLX5_SET(fte_match_set_misc, misc_c,\n\t\t\t gre_key.key, be32_to_cpu(enc_keyid.mask->keyid));\n\t\tMLX5_SET(fte_match_set_misc, misc_v,\n\t\t\t gre_key.key, be32_to_cpu(enc_keyid.key->keyid));\n\t}\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;\n\n\treturn 0;\n}\n\nstruct mlx5e_tc_tunnel gre_tunnel = {\n\t.tunnel_type          = MLX5E_TC_TUNNEL_TYPE_GRETAP,\n\t.match_level          = MLX5_MATCH_L3,\n\t.can_offload          = mlx5e_tc_tun_can_offload_gretap,\n\t.calc_hlen            = mlx5e_tc_tun_calc_hlen_gretap,\n\t.init_encap_attr      = mlx5e_tc_tun_init_encap_attr_gretap,\n\t.generate_ip_tun_hdr  = mlx5e_gen_ip_tunnel_header_gretap,\n\t.parse_udp_ports      = NULL,\n\t.parse_tunnel         = mlx5e_tc_tun_parse_gretap,\n\t.encap_info_equal     = mlx5e_tc_tun_encap_info_equal_generic,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}