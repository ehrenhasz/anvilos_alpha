{
  "module_name": "ipoib.c",
  "hash_id": "b51e556ec928c85a96410b8be56428f3a07193454e20dc8ca695db35c8be603d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c",
  "human_readable_source": " \n\n#include <rdma/ib_verbs.h>\n#include <linux/mlx5/fs.h>\n#include \"en.h\"\n#include \"en/params.h\"\n#include \"ipoib.h\"\n#include \"en/fs_ethtool.h\"\n\n#define IB_DEFAULT_Q_KEY   0xb1b\n#define MLX5I_PARAMS_DEFAULT_LOG_RQ_SIZE 9\n\nstatic int mlx5i_open(struct net_device *netdev);\nstatic int mlx5i_close(struct net_device *netdev);\nstatic int mlx5i_change_mtu(struct net_device *netdev, int new_mtu);\n\nstatic const struct net_device_ops mlx5i_netdev_ops = {\n\t.ndo_open                = mlx5i_open,\n\t.ndo_stop                = mlx5i_close,\n\t.ndo_get_stats64         = mlx5i_get_stats,\n\t.ndo_init                = mlx5i_dev_init,\n\t.ndo_uninit              = mlx5i_dev_cleanup,\n\t.ndo_change_mtu          = mlx5i_change_mtu,\n\t.ndo_eth_ioctl            = mlx5i_ioctl,\n};\n\n \nstatic void mlx5i_build_nic_params(struct mlx5_core_dev *mdev,\n\t\t\t\t   struct mlx5e_params *params)\n{\n\t \n\tMLX5E_SET_PFLAG(params, MLX5E_PFLAG_RX_STRIDING_RQ, false);\n\tmlx5e_set_rq_type(mdev, params);\n\tmlx5e_init_rq_type_params(mdev, params);\n\n\t \n\tparams->log_rq_mtu_frames = is_kdump_kernel() ?\n\t\tMLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE :\n\t\tMLX5I_PARAMS_DEFAULT_LOG_RQ_SIZE;\n\n\tparams->packet_merge.type = MLX5E_PACKET_MERGE_NONE;\n\tparams->hard_mtu = MLX5_IB_GRH_BYTES + MLX5_IPOIB_HARD_LEN;\n\n\t \n\tparams->rx_cqe_compress_def = false;\n\tMLX5E_SET_PFLAG(params, MLX5E_PFLAG_RX_CQE_COMPRESS, params->rx_cqe_compress_def);\n}\n\n \nint mlx5i_init(struct mlx5_core_dev *mdev, struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv  = mlx5i_epriv(netdev);\n\n\tnetif_carrier_off(netdev);\n\tmlx5e_set_netdev_mtu_boundaries(priv);\n\tnetdev->mtu = netdev->max_mtu;\n\n\tmlx5e_build_nic_params(priv, NULL, netdev->mtu);\n\tmlx5i_build_nic_params(mdev, &priv->channels.params);\n\n\tmlx5e_timestamp_init(priv);\n\n\t \n\tnetdev->hw_features    |= NETIF_F_SG;\n\tnetdev->hw_features    |= NETIF_F_IP_CSUM;\n\tnetdev->hw_features    |= NETIF_F_IPV6_CSUM;\n\tnetdev->hw_features    |= NETIF_F_GRO;\n\tnetdev->hw_features    |= NETIF_F_TSO;\n\tnetdev->hw_features    |= NETIF_F_TSO6;\n\tnetdev->hw_features    |= NETIF_F_RXCSUM;\n\tnetdev->hw_features    |= NETIF_F_RXHASH;\n\n\tnetdev->netdev_ops = &mlx5i_netdev_ops;\n\tnetdev->ethtool_ops = &mlx5i_ethtool_ops;\n\n\treturn 0;\n}\n\n \nvoid mlx5i_cleanup(struct mlx5e_priv *priv)\n{\n\tmlx5e_priv_cleanup(priv);\n}\n\nstatic void mlx5i_grp_sw_update_stats(struct mlx5e_priv *priv)\n{\n\tstruct rtnl_link_stats64 s = {};\n\tint i, j;\n\n\tfor (i = 0; i < priv->stats_nch; i++) {\n\t\tstruct mlx5e_channel_stats *channel_stats;\n\t\tstruct mlx5e_rq_stats *rq_stats;\n\n\t\tchannel_stats = priv->channel_stats[i];\n\t\trq_stats = &channel_stats->rq;\n\n\t\ts.rx_packets += rq_stats->packets;\n\t\ts.rx_bytes   += rq_stats->bytes;\n\n\t\tfor (j = 0; j < priv->max_opened_tc; j++) {\n\t\t\tstruct mlx5e_sq_stats *sq_stats = &channel_stats->sq[j];\n\n\t\t\ts.tx_packets           += sq_stats->packets;\n\t\t\ts.tx_bytes             += sq_stats->bytes;\n\t\t\ts.tx_dropped           += sq_stats->dropped;\n\t\t}\n\t}\n\n\tmemset(&priv->stats.sw, 0, sizeof(s));\n\n\tpriv->stats.sw.rx_packets = s.rx_packets;\n\tpriv->stats.sw.rx_bytes = s.rx_bytes;\n\tpriv->stats.sw.tx_packets = s.tx_packets;\n\tpriv->stats.sw.tx_bytes = s.tx_bytes;\n\tpriv->stats.sw.tx_queue_dropped = s.tx_dropped;\n}\n\nvoid mlx5i_get_stats(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct mlx5e_priv     *priv   = mlx5i_epriv(dev);\n\tstruct mlx5e_sw_stats *sstats = &priv->stats.sw;\n\n\tmlx5i_grp_sw_update_stats(priv);\n\n\tstats->rx_packets = sstats->rx_packets;\n\tstats->rx_bytes   = sstats->rx_bytes;\n\tstats->tx_packets = sstats->tx_packets;\n\tstats->tx_bytes   = sstats->tx_bytes;\n\tstats->tx_dropped = sstats->tx_queue_dropped;\n}\n\nstruct net_device *mlx5i_parent_get(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\tstruct mlx5i_priv *ipriv, *parent_ipriv;\n\tstruct net_device *parent_dev;\n\tint parent_ifindex;\n\n\tipriv = priv->ppriv;\n\n\tparent_ifindex = netdev->netdev_ops->ndo_get_iflink(netdev);\n\tparent_dev = dev_get_by_index(dev_net(netdev), parent_ifindex);\n\tif (!parent_dev)\n\t\treturn NULL;\n\n\tparent_ipriv = netdev_priv(parent_dev);\n\n\tASSERT_RTNL();\n\tparent_ipriv->num_sub_interfaces++;\n\n\tipriv->parent_dev = parent_dev;\n\n\treturn parent_dev;\n}\n\nvoid mlx5i_parent_put(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\tstruct mlx5i_priv *ipriv, *parent_ipriv;\n\n\tipriv = priv->ppriv;\n\tparent_ipriv = netdev_priv(ipriv->parent_dev);\n\n\tASSERT_RTNL();\n\tparent_ipriv->num_sub_interfaces--;\n\n\tdev_put(ipriv->parent_dev);\n}\n\nint mlx5i_init_underlay_qp(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\tint ret;\n\n\t{\n\t\tu32 in[MLX5_ST_SZ_DW(rst2init_qp_in)] = {};\n\t\tu32 *qpc;\n\n\t\tqpc = MLX5_ADDR_OF(rst2init_qp_in, in, qpc);\n\n\t\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\t\tMLX5_SET(qpc, qpc, primary_address_path.pkey_index,\n\t\t\t ipriv->pkey_index);\n\t\tMLX5_SET(qpc, qpc, primary_address_path.vhca_port_num, 1);\n\t\tMLX5_SET(qpc, qpc, q_key, IB_DEFAULT_Q_KEY);\n\n\t\tMLX5_SET(rst2init_qp_in, in, opcode, MLX5_CMD_OP_RST2INIT_QP);\n\t\tMLX5_SET(rst2init_qp_in, in, qpn, ipriv->qpn);\n\t\tret = mlx5_cmd_exec_in(mdev, rst2init_qp, in);\n\t\tif (ret)\n\t\t\tgoto err_qp_modify_to_err;\n\t}\n\t{\n\t\tu32 in[MLX5_ST_SZ_DW(init2rtr_qp_in)] = {};\n\n\t\tMLX5_SET(init2rtr_qp_in, in, opcode, MLX5_CMD_OP_INIT2RTR_QP);\n\t\tMLX5_SET(init2rtr_qp_in, in, qpn, ipriv->qpn);\n\t\tret = mlx5_cmd_exec_in(mdev, init2rtr_qp, in);\n\t\tif (ret)\n\t\t\tgoto err_qp_modify_to_err;\n\t}\n\t{\n\t\tu32 in[MLX5_ST_SZ_DW(rtr2rts_qp_in)] = {};\n\n\t\tMLX5_SET(rtr2rts_qp_in, in, opcode, MLX5_CMD_OP_RTR2RTS_QP);\n\t\tMLX5_SET(rtr2rts_qp_in, in, qpn, ipriv->qpn);\n\t\tret = mlx5_cmd_exec_in(mdev, rtr2rts_qp, in);\n\t\tif (ret)\n\t\t\tgoto err_qp_modify_to_err;\n\t}\n\treturn 0;\n\nerr_qp_modify_to_err:\n\t{\n\t\tu32 in[MLX5_ST_SZ_DW(qp_2err_in)] = {};\n\n\t\tMLX5_SET(qp_2err_in, in, opcode, MLX5_CMD_OP_2ERR_QP);\n\t\tMLX5_SET(qp_2err_in, in, qpn, ipriv->qpn);\n\t\tmlx5_cmd_exec_in(mdev, qp_2err, in);\n\t}\n\treturn ret;\n}\n\nvoid mlx5i_uninit_underlay_qp(struct mlx5e_priv *priv)\n{\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu32 in[MLX5_ST_SZ_DW(qp_2rst_in)] = {};\n\n\tMLX5_SET(qp_2rst_in, in, opcode, MLX5_CMD_OP_2RST_QP);\n\tMLX5_SET(qp_2rst_in, in, qpn, ipriv->qpn);\n\tmlx5_cmd_exec_in(mdev, qp_2rst, in);\n}\n\n#define MLX5_QP_ENHANCED_ULP_STATELESS_MODE 2\n\nint mlx5i_create_underlay_qp(struct mlx5e_priv *priv)\n{\n\tconst unsigned char *dev_addr = priv->netdev->dev_addr;\n\tu32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(create_qp_in)] = {};\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\tvoid *addr_path;\n\tint qpn = 0;\n\tint ret = 0;\n\tvoid *qpc;\n\n\tif (MLX5_CAP_GEN(priv->mdev, mkey_by_name)) {\n\t\tqpn = (dev_addr[1] << 16) + (dev_addr[2] << 8) + dev_addr[3];\n\t\tMLX5_SET(create_qp_in, in, input_qpn, qpn);\n\t}\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\tMLX5_SET(qpc, qpc, ts_format, mlx5_get_qp_default_ts(priv->mdev));\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_UD);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode,\n\t\t MLX5_QP_ENHANCED_ULP_STATELESS_MODE);\n\n\taddr_path = MLX5_ADDR_OF(qpc, qpc, primary_address_path);\n\tMLX5_SET(ads, addr_path, vhca_port_num, 1);\n\tMLX5_SET(ads, addr_path, grh, 1);\n\n\tMLX5_SET(create_qp_in, in, opcode, MLX5_CMD_OP_CREATE_QP);\n\tret = mlx5_cmd_exec_inout(priv->mdev, create_qp, in, out);\n\tif (ret)\n\t\treturn ret;\n\n\tipriv->qpn = MLX5_GET(create_qp_out, out, qpn);\n\n\treturn 0;\n}\n\nvoid mlx5i_destroy_underlay_qp(struct mlx5_core_dev *mdev, u32 qpn)\n{\n\tu32 in[MLX5_ST_SZ_DW(destroy_qp_in)] = {};\n\n\tMLX5_SET(destroy_qp_in, in, opcode, MLX5_CMD_OP_DESTROY_QP);\n\tMLX5_SET(destroy_qp_in, in, qpn, qpn);\n\tmlx5_cmd_exec_in(mdev, destroy_qp, in);\n}\n\nint mlx5i_update_nic_rx(struct mlx5e_priv *priv)\n{\n\treturn mlx5e_refresh_tirs(priv, true, true);\n}\n\nint mlx5i_create_tis(struct mlx5_core_dev *mdev, u32 underlay_qpn, u32 *tisn)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_tis_in)] = {};\n\tvoid *tisc;\n\n\ttisc = MLX5_ADDR_OF(create_tis_in, in, ctx);\n\n\tMLX5_SET(tisc, tisc, underlay_qpn, underlay_qpn);\n\n\treturn mlx5e_create_tis(mdev, in, tisn);\n}\n\nstatic int mlx5i_init_tx(struct mlx5e_priv *priv)\n{\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\tint err;\n\n\terr = mlx5i_create_underlay_qp(priv);\n\tif (err) {\n\t\tmlx5_core_warn(priv->mdev, \"create underlay QP failed, %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = mlx5i_create_tis(priv->mdev, ipriv->qpn, &priv->tisn[0][0]);\n\tif (err) {\n\t\tmlx5_core_warn(priv->mdev, \"create tis failed, %d\\n\", err);\n\t\tgoto err_destroy_underlay_qp;\n\t}\n\n\treturn 0;\n\nerr_destroy_underlay_qp:\n\tmlx5i_destroy_underlay_qp(priv->mdev, ipriv->qpn);\n\treturn err;\n}\n\nstatic void mlx5i_cleanup_tx(struct mlx5e_priv *priv)\n{\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\n\tmlx5e_destroy_tis(priv->mdev, priv->tisn[0][0]);\n\tmlx5i_destroy_underlay_qp(priv->mdev, ipriv->qpn);\n}\n\nstatic int mlx5i_create_flow_steering(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_flow_namespace *ns =\n\t\tmlx5_get_flow_namespace(priv->mdev, MLX5_FLOW_NAMESPACE_KERNEL);\n\tint err;\n\n\n\tif (!ns)\n\t\treturn -EINVAL;\n\n\tmlx5e_fs_set_ns(priv->fs, ns, false);\n\terr = mlx5e_arfs_create_tables(priv->fs, priv->rx_res,\n\t\t\t\t       !!(priv->netdev->hw_features & NETIF_F_NTUPLE));\n\tif (err) {\n\t\tnetdev_err(priv->netdev, \"Failed to create arfs tables, err=%d\\n\",\n\t\t\t   err);\n\t\tpriv->netdev->hw_features &= ~NETIF_F_NTUPLE;\n\t}\n\n\terr = mlx5e_create_ttc_table(priv->fs, priv->rx_res);\n\tif (err) {\n\t\tnetdev_err(priv->netdev, \"Failed to create ttc table, err=%d\\n\",\n\t\t\t   err);\n\t\tgoto err_destroy_arfs_tables;\n\t}\n\n\tmlx5e_ethtool_init_steering(priv->fs);\n\n\treturn 0;\n\nerr_destroy_arfs_tables:\n\tmlx5e_arfs_destroy_tables(priv->fs,\n\t\t\t\t  !!(priv->netdev->hw_features & NETIF_F_NTUPLE));\n\n\treturn err;\n}\n\nstatic void mlx5i_destroy_flow_steering(struct mlx5e_priv *priv)\n{\n\tmlx5e_destroy_ttc_table(priv->fs);\n\tmlx5e_arfs_destroy_tables(priv->fs,\n\t\t\t\t  !!(priv->netdev->hw_features & NETIF_F_NTUPLE));\n\tmlx5e_ethtool_cleanup_steering(priv->fs);\n}\n\nstatic int mlx5i_init_rx(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint err;\n\n\tpriv->fs = mlx5e_fs_init(priv->profile, mdev,\n\t\t\t\t !test_bit(MLX5E_STATE_DESTROYING, &priv->state),\n\t\t\t\t priv->dfs_root);\n\tif (!priv->fs) {\n\t\tnetdev_err(priv->netdev, \"FS allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->rx_res = mlx5e_rx_res_alloc();\n\tif (!priv->rx_res) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_fs;\n\t}\n\n\tmlx5e_create_q_counters(priv);\n\n\terr = mlx5e_open_drop_rq(priv, &priv->drop_rq);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"open drop rq failed, %d\\n\", err);\n\t\tgoto err_destroy_q_counters;\n\t}\n\n\terr = mlx5e_rx_res_init(priv->rx_res, priv->mdev, 0,\n\t\t\t\tpriv->max_nch, priv->drop_rq.rqn,\n\t\t\t\t&priv->channels.params.packet_merge,\n\t\t\t\tpriv->channels.params.num_channels);\n\tif (err)\n\t\tgoto err_close_drop_rq;\n\n\terr = mlx5i_create_flow_steering(priv);\n\tif (err)\n\t\tgoto err_destroy_rx_res;\n\n\treturn 0;\n\nerr_destroy_rx_res:\n\tmlx5e_rx_res_destroy(priv->rx_res);\nerr_close_drop_rq:\n\tmlx5e_close_drop_rq(&priv->drop_rq);\nerr_destroy_q_counters:\n\tmlx5e_destroy_q_counters(priv);\n\tmlx5e_rx_res_free(priv->rx_res);\n\tpriv->rx_res = NULL;\nerr_free_fs:\n\tmlx5e_fs_cleanup(priv->fs);\n\treturn err;\n}\n\nstatic void mlx5i_cleanup_rx(struct mlx5e_priv *priv)\n{\n\tmlx5i_destroy_flow_steering(priv);\n\tmlx5e_rx_res_destroy(priv->rx_res);\n\tmlx5e_close_drop_rq(&priv->drop_rq);\n\tmlx5e_destroy_q_counters(priv);\n\tmlx5e_rx_res_free(priv->rx_res);\n\tpriv->rx_res = NULL;\n\tmlx5e_fs_cleanup(priv->fs);\n}\n\n \nstatic mlx5e_stats_grp_t mlx5i_stats_grps[] = {\n\t&MLX5E_STATS_GRP(sw),\n\t&MLX5E_STATS_GRP(qcnt),\n\t&MLX5E_STATS_GRP(vnic_env),\n\t&MLX5E_STATS_GRP(vport),\n\t&MLX5E_STATS_GRP(802_3),\n\t&MLX5E_STATS_GRP(2863),\n\t&MLX5E_STATS_GRP(2819),\n\t&MLX5E_STATS_GRP(phy),\n\t&MLX5E_STATS_GRP(pcie),\n\t&MLX5E_STATS_GRP(per_prio),\n\t&MLX5E_STATS_GRP(pme),\n\t&MLX5E_STATS_GRP(channels),\n\t&MLX5E_STATS_GRP(per_port_buff_congest),\n};\n\nstatic unsigned int mlx5i_stats_grps_num(struct mlx5e_priv *priv)\n{\n\treturn ARRAY_SIZE(mlx5i_stats_grps);\n}\n\nstatic const struct mlx5e_profile mlx5i_nic_profile = {\n\t.init\t\t   = mlx5i_init,\n\t.cleanup\t   = mlx5i_cleanup,\n\t.init_tx\t   = mlx5i_init_tx,\n\t.cleanup_tx\t   = mlx5i_cleanup_tx,\n\t.init_rx\t   = mlx5i_init_rx,\n\t.cleanup_rx\t   = mlx5i_cleanup_rx,\n\t.enable\t\t   = NULL,  \n\t.disable\t   = NULL,  \n\t.update_rx\t   = mlx5i_update_nic_rx,\n\t.update_stats\t   = NULL,  \n\t.update_carrier    = NULL,  \n\t.rx_handlers       = &mlx5i_rx_handlers,\n\t.max_tc\t\t   = MLX5I_MAX_NUM_TC,\n\t.stats_grps        = mlx5i_stats_grps,\n\t.stats_grps_num    = mlx5i_stats_grps_num,\n};\n\n \n\nstatic int mlx5i_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\tstruct mlx5e_params new_params;\n\tint err = 0;\n\n\tmutex_lock(&priv->state_lock);\n\n\tnew_params = priv->channels.params;\n\tnew_params.sw_mtu = new_mtu;\n\n\terr = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);\n\tif (err)\n\t\tgoto out;\n\n\tnetdev->mtu = new_params.sw_mtu;\n\nout:\n\tmutex_unlock(&priv->state_lock);\n\treturn err;\n}\n\nint mlx5i_dev_init(struct net_device *dev)\n{\n\tstruct mlx5e_priv    *priv   = mlx5i_epriv(dev);\n\tstruct mlx5i_priv    *ipriv  = priv->ppriv;\n\tu8 addr_mod[3];\n\n\t \n\taddr_mod[0] = (ipriv->qpn >> 16) & 0xff;\n\taddr_mod[1] = (ipriv->qpn >>  8) & 0xff;\n\taddr_mod[2] = (ipriv->qpn) & 0xff;\n\tdev_addr_mod(dev, 1, addr_mod, sizeof(addr_mod));\n\n\t \n\tmlx5i_pkey_add_qpn(dev, ipriv->qpn);\n\n\treturn 0;\n}\n\nint mlx5i_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:\n\t\treturn mlx5e_hwstamp_set(priv, ifr);\n\tcase SIOCGHWTSTAMP:\n\t\treturn mlx5e_hwstamp_get(priv, ifr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nvoid mlx5i_dev_cleanup(struct net_device *dev)\n{\n\tstruct mlx5e_priv    *priv   = mlx5i_epriv(dev);\n\tstruct mlx5i_priv    *ipriv = priv->ppriv;\n\n\tmlx5i_uninit_underlay_qp(priv);\n\n\t \n\tmlx5i_pkey_del_qpn(dev, ipriv->qpn);\n}\n\nstatic int mlx5i_open(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *epriv = mlx5i_epriv(netdev);\n\tstruct mlx5i_priv *ipriv = epriv->ppriv;\n\tstruct mlx5_core_dev *mdev = epriv->mdev;\n\tint err;\n\n\tmutex_lock(&epriv->state_lock);\n\n\tset_bit(MLX5E_STATE_OPENED, &epriv->state);\n\n\terr = mlx5i_init_underlay_qp(epriv);\n\tif (err) {\n\t\tmlx5_core_warn(mdev, \"prepare underlay qp state failed, %d\\n\", err);\n\t\tgoto err_clear_state_opened_flag;\n\t}\n\n\terr = mlx5_fs_add_rx_underlay_qpn(mdev, ipriv->qpn);\n\tif (err) {\n\t\tmlx5_core_warn(mdev, \"attach underlay qp to ft failed, %d\\n\", err);\n\t\tgoto err_reset_qp;\n\t}\n\n\terr = mlx5e_open_channels(epriv, &epriv->channels);\n\tif (err)\n\t\tgoto err_remove_fs_underlay_qp;\n\n\terr = epriv->profile->update_rx(epriv);\n\tif (err)\n\t\tgoto err_close_channels;\n\n\tmlx5e_activate_priv_channels(epriv);\n\n\tmutex_unlock(&epriv->state_lock);\n\treturn 0;\n\nerr_close_channels:\n\tmlx5e_close_channels(&epriv->channels);\nerr_remove_fs_underlay_qp:\n\tmlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qpn);\nerr_reset_qp:\n\tmlx5i_uninit_underlay_qp(epriv);\nerr_clear_state_opened_flag:\n\tclear_bit(MLX5E_STATE_OPENED, &epriv->state);\n\tmutex_unlock(&epriv->state_lock);\n\treturn err;\n}\n\nstatic int mlx5i_close(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *epriv = mlx5i_epriv(netdev);\n\tstruct mlx5i_priv *ipriv = epriv->ppriv;\n\tstruct mlx5_core_dev *mdev = epriv->mdev;\n\n\t \n\tmutex_lock(&epriv->state_lock);\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &epriv->state))\n\t\tgoto unlock;\n\n\tclear_bit(MLX5E_STATE_OPENED, &epriv->state);\n\n\tnetif_carrier_off(epriv->netdev);\n\tmlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qpn);\n\tmlx5e_deactivate_priv_channels(epriv);\n\tmlx5e_close_channels(&epriv->channels);\n\tmlx5i_uninit_underlay_qp(epriv);\nunlock:\n\tmutex_unlock(&epriv->state_lock);\n\treturn 0;\n}\n\n \nstatic int mlx5i_attach_mcast(struct net_device *netdev, struct ib_device *hca,\n\t\t\t      union ib_gid *gid, u16 lid, int set_qkey,\n\t\t\t      u32 qkey)\n{\n\tstruct mlx5e_priv    *epriv = mlx5i_epriv(netdev);\n\tstruct mlx5_core_dev *mdev  = epriv->mdev;\n\tstruct mlx5i_priv    *ipriv = epriv->ppriv;\n\tint err;\n\n\tmlx5_core_dbg(mdev, \"attaching QPN 0x%x, MGID %pI6\\n\", ipriv->qpn,\n\t\t      gid->raw);\n\terr = mlx5_core_attach_mcg(mdev, gid, ipriv->qpn);\n\tif (err)\n\t\tmlx5_core_warn(mdev, \"failed attaching QPN 0x%x, MGID %pI6\\n\",\n\t\t\t       ipriv->qpn, gid->raw);\n\n\tif (set_qkey) {\n\t\tmlx5_core_dbg(mdev, \"%s setting qkey 0x%x\\n\",\n\t\t\t      netdev->name, qkey);\n\t\tipriv->qkey = qkey;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5i_detach_mcast(struct net_device *netdev, struct ib_device *hca,\n\t\t\t      union ib_gid *gid, u16 lid)\n{\n\tstruct mlx5e_priv    *epriv = mlx5i_epriv(netdev);\n\tstruct mlx5_core_dev *mdev  = epriv->mdev;\n\tstruct mlx5i_priv    *ipriv = epriv->ppriv;\n\tint err;\n\n\tmlx5_core_dbg(mdev, \"detaching QPN 0x%x, MGID %pI6\\n\", ipriv->qpn,\n\t\t      gid->raw);\n\n\terr = mlx5_core_detach_mcg(mdev, gid, ipriv->qpn);\n\tif (err)\n\t\tmlx5_core_dbg(mdev, \"failed detaching QPN 0x%x, MGID %pI6\\n\",\n\t\t\t      ipriv->qpn, gid->raw);\n\n\treturn err;\n}\n\nstatic int mlx5i_xmit(struct net_device *dev, struct sk_buff *skb,\n\t\t      struct ib_ah *address, u32 dqpn)\n{\n\tstruct mlx5e_priv *epriv = mlx5i_epriv(dev);\n\tstruct mlx5e_txqsq *sq   = epriv->txq2sq[skb_get_queue_mapping(skb)];\n\tstruct mlx5_ib_ah *mah   = to_mah(address);\n\tstruct mlx5i_priv *ipriv = epriv->ppriv;\n\n\tmlx5i_sq_xmit(sq, skb, &mah->av, dqpn, ipriv->qkey, netdev_xmit_more());\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void mlx5i_set_pkey_index(struct net_device *netdev, int id)\n{\n\tstruct mlx5i_priv *ipriv = netdev_priv(netdev);\n\n\tipriv->pkey_index = (u16)id;\n}\n\nstatic int mlx5i_check_required_hca_cap(struct mlx5_core_dev *mdev)\n{\n\tif (MLX5_CAP_GEN(mdev, port_type) != MLX5_CAP_PORT_TYPE_IB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!MLX5_CAP_GEN(mdev, ipoib_enhanced_offloads)) {\n\t\tmlx5_core_warn(mdev, \"IPoIB enhanced offloads are not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlx5_rdma_netdev_free(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5i_priv *ipriv = priv->ppriv;\n\tconst struct mlx5e_profile *profile = priv->profile;\n\n\tmlx5e_detach_netdev(priv);\n\tprofile->cleanup(priv);\n\n\tif (!ipriv->sub_interface) {\n\t\tmlx5i_pkey_qpn_ht_cleanup(netdev);\n\t\tmlx5e_destroy_mdev_resources(mdev);\n\t}\n}\n\nstatic bool mlx5_is_sub_interface(struct mlx5_core_dev *mdev)\n{\n\treturn mdev->mlx5e_res.hw_objs.pdn != 0;\n}\n\nstatic const struct mlx5e_profile *mlx5_get_profile(struct mlx5_core_dev *mdev)\n{\n\tif (mlx5_is_sub_interface(mdev))\n\t\treturn mlx5i_pkey_get_profile();\n\treturn &mlx5i_nic_profile;\n}\n\nstatic int mlx5_rdma_setup_rn(struct ib_device *ibdev, u32 port_num,\n\t\t\t      struct net_device *netdev, void *param)\n{\n\tstruct mlx5_core_dev *mdev = (struct mlx5_core_dev *)param;\n\tconst struct mlx5e_profile *prof = mlx5_get_profile(mdev);\n\tstruct mlx5i_priv *ipriv;\n\tstruct mlx5e_priv *epriv;\n\tstruct rdma_netdev *rn;\n\tint err;\n\n\tipriv = netdev_priv(netdev);\n\tepriv = mlx5i_epriv(netdev);\n\n\tipriv->sub_interface = mlx5_is_sub_interface(mdev);\n\tif (!ipriv->sub_interface) {\n\t\terr = mlx5i_pkey_qpn_ht_init(netdev);\n\t\tif (err) {\n\t\t\tmlx5_core_warn(mdev, \"allocate qpn_to_netdev ht failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = mlx5e_create_mdev_resources(mdev);\n\t\tif (err)\n\t\t\tgoto destroy_ht;\n\t}\n\n\terr = mlx5e_priv_init(epriv, prof, netdev, mdev);\n\tif (err)\n\t\tgoto destroy_mdev_resources;\n\n\tepriv->profile = prof;\n\tepriv->ppriv = ipriv;\n\n\tprof->init(mdev, netdev);\n\n\terr = mlx5e_attach_netdev(epriv);\n\tif (err)\n\t\tgoto detach;\n\tnetif_carrier_off(netdev);\n\n\t \n\trn = &ipriv->rn;\n\trn->hca  = ibdev;\n\trn->send = mlx5i_xmit;\n\trn->attach_mcast = mlx5i_attach_mcast;\n\trn->detach_mcast = mlx5i_detach_mcast;\n\trn->set_id = mlx5i_set_pkey_index;\n\n\tnetdev->priv_destructor = mlx5_rdma_netdev_free;\n\tnetdev->needs_free_netdev = 1;\n\n\treturn 0;\n\ndetach:\n\tprof->cleanup(epriv);\n\tif (ipriv->sub_interface)\n\t\treturn err;\ndestroy_mdev_resources:\n\tmlx5e_destroy_mdev_resources(mdev);\ndestroy_ht:\n\tmlx5i_pkey_qpn_ht_cleanup(netdev);\n\treturn err;\n}\n\nint mlx5_rdma_rn_get_params(struct mlx5_core_dev *mdev,\n\t\t\t    struct ib_device *device,\n\t\t\t    struct rdma_netdev_alloc_params *params)\n{\n\tint nch;\n\tint rc;\n\n\trc = mlx5i_check_required_hca_cap(mdev);\n\tif (rc)\n\t\treturn rc;\n\n\tnch = mlx5e_get_max_num_channels(mdev);\n\n\t*params = (struct rdma_netdev_alloc_params){\n\t\t.sizeof_priv = sizeof(struct mlx5i_priv) +\n\t\t\t       sizeof(struct mlx5e_priv),\n\t\t.txqs = nch * MLX5E_MAX_NUM_TC,\n\t\t.rxqs = nch,\n\t\t.param = mdev,\n\t\t.initialize_rdma_netdev = mlx5_rdma_setup_rn,\n\t};\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mlx5_rdma_rn_get_params);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}