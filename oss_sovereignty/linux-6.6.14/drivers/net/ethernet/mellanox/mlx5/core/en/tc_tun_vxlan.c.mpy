{
  "module_name": "tc_tun_vxlan.c",
  "hash_id": "a0d341447a1926343955e6e3e43e78d4ca94bbbeb56a7b4ffa7298c3be99cc1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun_vxlan.c",
  "human_readable_source": "\n \n\n#include <net/ip_tunnels.h>\n#include <net/vxlan.h>\n#include \"lib/vxlan.h\"\n#include \"en/tc_tun.h\"\n\nstatic bool mlx5e_tc_tun_can_offload_vxlan(struct mlx5e_priv *priv)\n{\n\treturn !!MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap);\n}\n\nstatic int mlx5e_tc_tun_calc_hlen_vxlan(struct mlx5e_encap_entry *e)\n{\n\treturn VXLAN_HLEN;\n}\n\nstatic int mlx5e_tc_tun_check_udp_dport_vxlan(struct mlx5e_priv *priv,\n\t\t\t\t\t      struct flow_cls_offload *f)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_match_ports enc_ports;\n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_PORTS))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_rule_match_enc_ports(rule, &enc_ports);\n\n\t \n\n\tif (!mlx5_vxlan_lookup_port(priv->mdev->vxlan,\n\t\t\t\t    be16_to_cpu(enc_ports.key->dst))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matched UDP dst port is not registered as a VXLAN port\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"UDP port %d is not registered as a VXLAN port\\n\",\n\t\t\t    be16_to_cpu(enc_ports.key->dst));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_udp_ports_vxlan(struct mlx5e_priv *priv,\n\t\t\t\t\t      struct mlx5_flow_spec *spec,\n\t\t\t\t\t      struct flow_cls_offload *f,\n\t\t\t\t\t      void *headers_c,\n\t\t\t\t\t      void *headers_v)\n{\n\tint err = 0;\n\n\terr = mlx5e_tc_tun_parse_udp_ports(priv, spec, f, headers_c, headers_v);\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5e_tc_tun_check_udp_dport_vxlan(priv, f);\n}\n\nstatic int mlx5e_tc_tun_init_encap_attr_vxlan(struct net_device *tunnel_dev,\n\t\t\t\t\t      struct mlx5e_priv *priv,\n\t\t\t\t\t      struct mlx5e_encap_entry *e,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint dst_port = be16_to_cpu(e->tun_info->key.tp_dst);\n\n\te->tunnel = &vxlan_tunnel;\n\n\tif (!mlx5_vxlan_lookup_port(priv->mdev->vxlan, dst_port)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"vxlan udp dport was not registered with the HW\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"%d isn't an offloaded vxlan udp dport\\n\",\n\t\t\t    dst_port);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\te->reformat_type = MLX5_REFORMAT_TYPE_L2_TO_VXLAN;\n\treturn 0;\n}\n\nstatic int mlx5e_gen_ip_tunnel_header_vxlan(char buf[],\n\t\t\t\t\t    __u8 *ip_proto,\n\t\t\t\t\t    struct mlx5e_encap_entry *e)\n{\n\tconst struct ip_tunnel_key *tun_key = &e->tun_info->key;\n\t__be32 tun_id = tunnel_id_to_key32(tun_key->tun_id);\n\tstruct udphdr *udp = (struct udphdr *)(buf);\n\tconst struct vxlan_metadata *md;\n\tstruct vxlanhdr *vxh;\n\n\tif ((tun_key->tun_flags & TUNNEL_VXLAN_OPT) &&\n\t    e->tun_info->options_len != sizeof(*md))\n\t\treturn -EOPNOTSUPP;\n\tvxh = (struct vxlanhdr *)((char *)udp + sizeof(struct udphdr));\n\t*ip_proto = IPPROTO_UDP;\n\n\tudp->dest = tun_key->tp_dst;\n\tvxh->vx_flags = VXLAN_HF_VNI;\n\tvxh->vx_vni = vxlan_vni_field(tun_id);\n\tif (tun_key->tun_flags & TUNNEL_VXLAN_OPT) {\n\t\tmd = ip_tunnel_info_opts(e->tun_info);\n\t\tvxlan_build_gbp_hdr(vxh, md);\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_vxlan_gbp_option(struct mlx5e_priv *priv,\n\t\t\t\t\t       struct mlx5_flow_spec *spec,\n\t\t\t\t\t       struct flow_cls_offload *f)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_match_enc_opts enc_opts;\n\tvoid *misc5_c, *misc5_v;\n\tu32 *gbp, *gbp_mask;\n\n\tflow_rule_match_enc_opts(rule, &enc_opts);\n\n\tif (memchr_inv(&enc_opts.mask->data, 0, sizeof(enc_opts.mask->data)) &&\n\t    !MLX5_CAP_ESW_FT_FIELD_SUPPORT_2(priv->mdev, tunnel_header_0_1)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Matching on VxLAN GBP is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (enc_opts.key->dst_opt_type != TUNNEL_VXLAN_OPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Wrong VxLAN option type: not GBP\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (enc_opts.key->len != sizeof(*gbp) ||\n\t    enc_opts.mask->len != sizeof(*gbp_mask)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN GBP option/mask len is not 32 bits\");\n\t\treturn -EINVAL;\n\t}\n\n\tgbp = (u32 *)&enc_opts.key->data[0];\n\tgbp_mask = (u32 *)&enc_opts.mask->data[0];\n\n\tif (*gbp_mask & ~VXLAN_GBP_MASK) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Wrong VxLAN GBP mask(0x%08X)\\n\", *gbp_mask);\n\t\treturn -EINVAL;\n\t}\n\n\tmisc5_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters_5);\n\tmisc5_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters_5);\n\tMLX5_SET(fte_match_set_misc5, misc5_c, tunnel_header_0, *gbp_mask);\n\tMLX5_SET(fte_match_set_misc5, misc5_v, tunnel_header_0, *gbp);\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_5;\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_vxlan(struct mlx5e_priv *priv,\n\t\t\t\t    struct mlx5_flow_spec *spec,\n\t\t\t\t    struct flow_cls_offload *f,\n\t\t\t\t    void *headers_c,\n\t\t\t\t    void *headers_v)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_match_enc_keyid enc_keyid;\n\tvoid *misc_c, *misc_v;\n\n\tmisc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);\n\tmisc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);\n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID))\n\t\treturn 0;\n\n\tflow_rule_match_enc_keyid(rule, &enc_keyid);\n\n\tif (!enc_keyid.mask->keyid)\n\t\treturn 0;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_OPTS)) {\n\t\tint err;\n\n\t\terr = mlx5e_tc_tun_parse_vxlan_gbp_option(priv, spec, f);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,\n\t\t\t\t\tft_field_support.outer_vxlan_vni)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on VXLAN VNI is not supported\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on VXLAN VNI is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tMLX5_SET(fte_match_set_misc, misc_c, vxlan_vni,\n\t\t be32_to_cpu(enc_keyid.mask->keyid));\n\tMLX5_SET(fte_match_set_misc, misc_v, vxlan_vni,\n\t\t be32_to_cpu(enc_keyid.key->keyid));\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;\n\n\treturn 0;\n}\n\nstatic bool mlx5e_tc_tun_encap_info_equal_vxlan(struct mlx5e_encap_key *a,\n\t\t\t\t\t\tstruct mlx5e_encap_key *b)\n{\n\treturn mlx5e_tc_tun_encap_info_equal_options(a, b, TUNNEL_VXLAN_OPT);\n}\n\nstatic int mlx5e_tc_tun_get_remote_ifindex(struct net_device *mirred_dev)\n{\n\tconst struct vxlan_dev *vxlan = netdev_priv(mirred_dev);\n\tconst struct vxlan_rdst *dst = &vxlan->default_dst;\n\n\treturn dst->remote_ifindex;\n}\n\nstruct mlx5e_tc_tunnel vxlan_tunnel = {\n\t.tunnel_type          = MLX5E_TC_TUNNEL_TYPE_VXLAN,\n\t.match_level          = MLX5_MATCH_L4,\n\t.can_offload          = mlx5e_tc_tun_can_offload_vxlan,\n\t.calc_hlen            = mlx5e_tc_tun_calc_hlen_vxlan,\n\t.init_encap_attr      = mlx5e_tc_tun_init_encap_attr_vxlan,\n\t.generate_ip_tun_hdr  = mlx5e_gen_ip_tunnel_header_vxlan,\n\t.parse_udp_ports      = mlx5e_tc_tun_parse_udp_ports_vxlan,\n\t.parse_tunnel         = mlx5e_tc_tun_parse_vxlan,\n\t.encap_info_equal     = mlx5e_tc_tun_encap_info_equal_vxlan,\n\t.get_remote_ifindex   = mlx5e_tc_tun_get_remote_ifindex,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}