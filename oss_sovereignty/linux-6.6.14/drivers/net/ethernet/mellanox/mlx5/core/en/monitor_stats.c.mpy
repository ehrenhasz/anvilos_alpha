{
  "module_name": "monitor_stats.c",
  "hash_id": "e4895265e23f059fa8fb71d1b2b5580f7493ca3d04e3796cd1c3664afe175ea8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/monitor_stats.c",
  "human_readable_source": " \n \n\n#include \"en.h\"\n#include \"monitor_stats.h\"\n#include \"lib/eq.h\"\n\n \n\n#define NUM_REQ_PPCNT_COUNTER_S1 MLX5_CMD_SET_MONITOR_NUM_PPCNT_COUNTER_SET1\n#define NUM_REQ_Q_COUNTERS_S1    MLX5_CMD_SET_MONITOR_NUM_Q_COUNTERS_SET1\n\nint mlx5e_monitor_counter_supported(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tif (!MLX5_CAP_GEN(mdev, max_num_of_monitor_counters))\n\t\treturn false;\n\tif (MLX5_CAP_PCAM_REG(mdev, ppcnt) &&\n\t    MLX5_CAP_GEN(mdev, num_ppcnt_monitor_counters) <\n\t    NUM_REQ_PPCNT_COUNTER_S1)\n\t\treturn false;\n\tif (MLX5_CAP_GEN(mdev, num_q_monitor_counters) <\n\t    NUM_REQ_Q_COUNTERS_S1)\n\t\treturn false;\n\treturn true;\n}\n\nvoid mlx5e_monitor_counter_arm(struct mlx5e_priv *priv)\n{\n\tu32 in[MLX5_ST_SZ_DW(arm_monitor_counter_in)] = {};\n\n\tMLX5_SET(arm_monitor_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_ARM_MONITOR_COUNTER);\n\tmlx5_cmd_exec_in(priv->mdev, arm_monitor_counter, in);\n}\n\nstatic void mlx5e_monitor_counters_work(struct work_struct *work)\n{\n\tstruct mlx5e_priv *priv = container_of(work, struct mlx5e_priv,\n\t\t\t\t\t       monitor_counters_work);\n\n\tmutex_lock(&priv->state_lock);\n\tmlx5e_stats_update_ndo_stats(priv);\n\tmutex_unlock(&priv->state_lock);\n\tmlx5e_monitor_counter_arm(priv);\n}\n\nstatic int mlx5e_monitor_event_handler(struct notifier_block *nb,\n\t\t\t\t       unsigned long event, void *eqe)\n{\n\tstruct mlx5e_priv *priv = mlx5_nb_cof(nb, struct mlx5e_priv,\n\t\t\t\t\t      monitor_counters_nb);\n\tqueue_work(priv->wq, &priv->monitor_counters_work);\n\treturn NOTIFY_OK;\n}\n\nstatic int fill_monitor_counter_ppcnt_set1(int cnt, u32 *in)\n{\n\tenum mlx5_monitor_counter_ppcnt ppcnt_cnt;\n\n\tfor (ppcnt_cnt = 0;\n\t     ppcnt_cnt < NUM_REQ_PPCNT_COUNTER_S1;\n\t     ppcnt_cnt++, cnt++) {\n\t\tMLX5_SET(set_monitor_counter_in, in,\n\t\t\t monitor_counter[cnt].type,\n\t\t\t MLX5_QUERY_MONITOR_CNT_TYPE_PPCNT);\n\t\tMLX5_SET(set_monitor_counter_in, in,\n\t\t\t monitor_counter[cnt].counter,\n\t\t\t ppcnt_cnt);\n\t}\n\treturn ppcnt_cnt;\n}\n\nstatic int fill_monitor_counter_q_counter_set1(int cnt, int q_counter, u32 *in)\n{\n\tMLX5_SET(set_monitor_counter_in, in,\n\t\t monitor_counter[cnt].type,\n\t\t MLX5_QUERY_MONITOR_CNT_TYPE_Q_COUNTER);\n\tMLX5_SET(set_monitor_counter_in, in,\n\t\t monitor_counter[cnt].counter,\n\t\t MLX5_QUERY_MONITOR_Q_COUNTER_RX_OUT_OF_BUFFER);\n\tMLX5_SET(set_monitor_counter_in, in,\n\t\t monitor_counter[cnt].counter_group_id,\n\t\t q_counter);\n\treturn 1;\n}\n\n \nstatic void mlx5e_set_monitor_counter(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint max_num_of_counters = MLX5_CAP_GEN(mdev, max_num_of_monitor_counters);\n\tint num_q_counters      = MLX5_CAP_GEN(mdev, num_q_monitor_counters);\n\tint num_ppcnt_counters  = !MLX5_CAP_PCAM_REG(mdev, ppcnt) ? 0 :\n\t\t\t\t  MLX5_CAP_GEN(mdev, num_ppcnt_monitor_counters);\n\tu32 in[MLX5_ST_SZ_DW(set_monitor_counter_in)] = {};\n\tint q_counter = priv->q_counter;\n\tint cnt\t= 0;\n\n\tif (num_ppcnt_counters  >=  NUM_REQ_PPCNT_COUNTER_S1 &&\n\t    max_num_of_counters >= (NUM_REQ_PPCNT_COUNTER_S1 + cnt))\n\t\tcnt += fill_monitor_counter_ppcnt_set1(cnt, in);\n\n\tif (num_q_counters      >=  NUM_REQ_Q_COUNTERS_S1 &&\n\t    max_num_of_counters >= (NUM_REQ_Q_COUNTERS_S1 + cnt) &&\n\t    q_counter)\n\t\tcnt += fill_monitor_counter_q_counter_set1(cnt, q_counter, in);\n\n\tMLX5_SET(set_monitor_counter_in, in, num_of_counters, cnt);\n\tMLX5_SET(set_monitor_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_SET_MONITOR_COUNTER);\n\n\tmlx5_cmd_exec_in(mdev, set_monitor_counter, in);\n}\n\n \nvoid mlx5e_monitor_counter_init(struct mlx5e_priv *priv)\n{\n\tINIT_WORK(&priv->monitor_counters_work, mlx5e_monitor_counters_work);\n\tMLX5_NB_INIT(&priv->monitor_counters_nb, mlx5e_monitor_event_handler,\n\t\t     MONITOR_COUNTER);\n\tmlx5_eq_notifier_register(priv->mdev, &priv->monitor_counters_nb);\n\n\tmlx5e_set_monitor_counter(priv);\n\tmlx5e_monitor_counter_arm(priv);\n\tqueue_work(priv->wq, &priv->update_stats_work);\n}\n\n \nvoid mlx5e_monitor_counter_cleanup(struct mlx5e_priv *priv)\n{\n\tu32 in[MLX5_ST_SZ_DW(set_monitor_counter_in)] = {};\n\n\tMLX5_SET(set_monitor_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_SET_MONITOR_COUNTER);\n\n\tmlx5_cmd_exec_in(priv->mdev, set_monitor_counter, in);\n\tmlx5_eq_notifier_unregister(priv->mdev, &priv->monitor_counters_nb);\n\tcancel_work_sync(&priv->monitor_counters_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}