{
  "module_name": "neigh.c",
  "hash_id": "31b46429ba579eaf383c0ebe9762719cefdcfe92f6dc22118f1935441738966d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/rep/neigh.c",
  "human_readable_source": "\n \n\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/rtnetlink.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <net/netevent.h>\n#include <net/arp.h>\n#include \"neigh.h\"\n#include \"tc.h\"\n#include \"en_rep.h\"\n#include \"fs_core.h\"\n#include \"diag/en_rep_tracepoint.h\"\n\nstatic unsigned long mlx5e_rep_ipv6_interval(void)\n{\n\tif (IS_ENABLED(CONFIG_IPV6) && ipv6_stub->nd_tbl)\n\t\treturn NEIGH_VAR(&ipv6_stub->nd_tbl->parms, DELAY_PROBE_TIME);\n\n\treturn ~0UL;\n}\n\nstatic void mlx5e_rep_neigh_update_init_interval(struct mlx5e_rep_priv *rpriv)\n{\n\tunsigned long ipv4_interval = NEIGH_VAR(&arp_tbl.parms, DELAY_PROBE_TIME);\n\tunsigned long ipv6_interval = mlx5e_rep_ipv6_interval();\n\tstruct net_device *netdev = rpriv->netdev;\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\trpriv->neigh_update.min_interval = min_t(unsigned long, ipv6_interval, ipv4_interval);\n\tmlx5_fc_update_sampling_interval(priv->mdev, rpriv->neigh_update.min_interval);\n}\n\nvoid mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;\n\n\tmlx5_fc_queue_stats_work(priv->mdev,\n\t\t\t\t &neigh_update->neigh_stats_work,\n\t\t\t\t neigh_update->min_interval);\n}\n\nstatic bool mlx5e_rep_neigh_entry_hold(struct mlx5e_neigh_hash_entry *nhe)\n{\n\treturn refcount_inc_not_zero(&nhe->refcnt);\n}\n\nstatic void mlx5e_rep_neigh_entry_remove(struct mlx5e_neigh_hash_entry *nhe);\n\nvoid mlx5e_rep_neigh_entry_release(struct mlx5e_neigh_hash_entry *nhe)\n{\n\tif (refcount_dec_and_test(&nhe->refcnt)) {\n\t\tmlx5e_rep_neigh_entry_remove(nhe);\n\t\tkfree_rcu(nhe, rcu);\n\t}\n}\n\nstatic struct mlx5e_neigh_hash_entry *\nmlx5e_get_next_nhe(struct mlx5e_rep_priv *rpriv,\n\t\t   struct mlx5e_neigh_hash_entry *nhe)\n{\n\tstruct mlx5e_neigh_hash_entry *next = NULL;\n\n\trcu_read_lock();\n\n\tfor (next = nhe ?\n\t\t     list_next_or_null_rcu(&rpriv->neigh_update.neigh_list,\n\t\t\t\t\t   &nhe->neigh_list,\n\t\t\t\t\t   struct mlx5e_neigh_hash_entry,\n\t\t\t\t\t   neigh_list) :\n\t\t     list_first_or_null_rcu(&rpriv->neigh_update.neigh_list,\n\t\t\t\t\t    struct mlx5e_neigh_hash_entry,\n\t\t\t\t\t    neigh_list);\n\t     next;\n\t     next = list_next_or_null_rcu(&rpriv->neigh_update.neigh_list,\n\t\t\t\t\t  &next->neigh_list,\n\t\t\t\t\t  struct mlx5e_neigh_hash_entry,\n\t\t\t\t\t  neigh_list))\n\t\tif (mlx5e_rep_neigh_entry_hold(next))\n\t\t\tbreak;\n\n\trcu_read_unlock();\n\n\tif (nhe)\n\t\tmlx5e_rep_neigh_entry_release(nhe);\n\n\treturn next;\n}\n\nstatic void mlx5e_rep_neigh_stats_work(struct work_struct *work)\n{\n\tstruct mlx5e_rep_priv *rpriv = container_of(work, struct mlx5e_rep_priv,\n\t\t\t\t\t\t    neigh_update.neigh_stats_work.work);\n\tstruct net_device *netdev = rpriv->netdev;\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_neigh_hash_entry *nhe = NULL;\n\n\trtnl_lock();\n\tif (!list_empty(&rpriv->neigh_update.neigh_list))\n\t\tmlx5e_rep_queue_neigh_stats_work(priv);\n\n\twhile ((nhe = mlx5e_get_next_nhe(rpriv, nhe)) != NULL)\n\t\tmlx5e_tc_update_neigh_used_value(nhe);\n\n\trtnl_unlock();\n}\n\nstruct neigh_update_work {\n\tstruct work_struct work;\n\tstruct neighbour *n;\n\tstruct mlx5e_neigh_hash_entry *nhe;\n};\n\nstatic void mlx5e_release_neigh_update_work(struct neigh_update_work *update_work)\n{\n\tneigh_release(update_work->n);\n\tmlx5e_rep_neigh_entry_release(update_work->nhe);\n\tkfree(update_work);\n}\n\nstatic void mlx5e_rep_neigh_update(struct work_struct *work)\n{\n\tstruct neigh_update_work *update_work = container_of(work, struct neigh_update_work,\n\t\t\t\t\t\t\t     work);\n\tstruct mlx5e_neigh_hash_entry *nhe = update_work->nhe;\n\tstruct neighbour *n = update_work->n;\n\tstruct mlx5e_encap_entry *e = NULL;\n\tbool neigh_connected, same_dev;\n\tunsigned char ha[ETH_ALEN];\n\tu8 nud_state, dead;\n\n\trtnl_lock();\n\n\t \n\tread_lock_bh(&n->lock);\n\tmemcpy(ha, n->ha, ETH_ALEN);\n\tnud_state = n->nud_state;\n\tdead = n->dead;\n\tsame_dev = READ_ONCE(nhe->neigh_dev) == n->dev;\n\tread_unlock_bh(&n->lock);\n\n\tneigh_connected = (nud_state & NUD_VALID) && !dead;\n\n\ttrace_mlx5e_rep_neigh_update(nhe, ha, neigh_connected);\n\n\tif (!same_dev)\n\t\tgoto out;\n\n\t \n\twhile ((e = mlx5e_get_next_init_encap(nhe, e)) != NULL)\n\t\tmlx5e_rep_update_flows(netdev_priv(e->out_dev), e, neigh_connected, ha);\n\nout:\n\trtnl_unlock();\n\tmlx5e_release_neigh_update_work(update_work);\n}\n\nstatic struct neigh_update_work *mlx5e_alloc_neigh_update_work(struct mlx5e_priv *priv,\n\t\t\t\t\t\t\t       struct neighbour *n)\n{\n\tstruct neigh_update_work *update_work;\n\tstruct mlx5e_neigh_hash_entry *nhe;\n\tstruct mlx5e_neigh m_neigh = {};\n\n\tupdate_work = kzalloc(sizeof(*update_work), GFP_ATOMIC);\n\tif (WARN_ON(!update_work))\n\t\treturn NULL;\n\n\tm_neigh.family = n->ops->family;\n\tmemcpy(&m_neigh.dst_ip, n->primary_key, n->tbl->key_len);\n\n\t \n\trcu_read_lock();\n\tnhe = mlx5e_rep_neigh_entry_lookup(priv, &m_neigh);\n\trcu_read_unlock();\n\tif (!nhe) {\n\t\tkfree(update_work);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&update_work->work, mlx5e_rep_neigh_update);\n\tneigh_hold(n);\n\tupdate_work->n = n;\n\tupdate_work->nhe = nhe;\n\n\treturn update_work;\n}\n\nstatic int mlx5e_rep_netevent_event(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct mlx5e_rep_priv *rpriv = container_of(nb, struct mlx5e_rep_priv,\n\t\t\t\t\t\t    neigh_update.netevent_nb);\n\tstruct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;\n\tstruct net_device *netdev = rpriv->netdev;\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_neigh_hash_entry *nhe = NULL;\n\tstruct neigh_update_work *update_work;\n\tstruct neigh_parms *p;\n\tstruct neighbour *n;\n\tbool found = false;\n\n\tswitch (event) {\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\tn = ptr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (n->tbl != ipv6_stub->nd_tbl && n->tbl != &arp_tbl)\n#else\n\t\tif (n->tbl != &arp_tbl)\n#endif\n\t\t\treturn NOTIFY_DONE;\n\n\t\tupdate_work = mlx5e_alloc_neigh_update_work(priv, n);\n\t\tif (!update_work)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tqueue_work(priv->wq, &update_work->work);\n\t\tbreak;\n\n\tcase NETEVENT_DELAY_PROBE_TIME_UPDATE:\n\t\tp = ptr;\n\n\t\t \n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (!p->dev || (p->tbl != ipv6_stub->nd_tbl && p->tbl != &arp_tbl))\n#else\n\t\tif (!p->dev || p->tbl != &arp_tbl)\n#endif\n\t\t\treturn NOTIFY_DONE;\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(nhe, &neigh_update->neigh_list,\n\t\t\t\t\tneigh_list) {\n\t\t\tif (p->dev == READ_ONCE(nhe->neigh_dev)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!found)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tneigh_update->min_interval = min_t(unsigned long,\n\t\t\t\t\t\t   NEIGH_VAR(p, DELAY_PROBE_TIME),\n\t\t\t\t\t\t   neigh_update->min_interval);\n\t\tmlx5_fc_update_sampling_interval(priv->mdev,\n\t\t\t\t\t\t neigh_update->min_interval);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct rhashtable_params mlx5e_neigh_ht_params = {\n\t.head_offset = offsetof(struct mlx5e_neigh_hash_entry, rhash_node),\n\t.key_offset = offsetof(struct mlx5e_neigh_hash_entry, m_neigh),\n\t.key_len = sizeof(struct mlx5e_neigh),\n\t.automatic_shrinking = true,\n};\n\nint mlx5e_rep_neigh_init(struct mlx5e_rep_priv *rpriv)\n{\n\tstruct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;\n\tint err;\n\n\terr = rhashtable_init(&neigh_update->neigh_ht, &mlx5e_neigh_ht_params);\n\tif (err)\n\t\tgoto out_err;\n\n\tINIT_LIST_HEAD(&neigh_update->neigh_list);\n\tmutex_init(&neigh_update->encap_lock);\n\tINIT_DELAYED_WORK(&neigh_update->neigh_stats_work,\n\t\t\t  mlx5e_rep_neigh_stats_work);\n\tmlx5e_rep_neigh_update_init_interval(rpriv);\n\n\tneigh_update->netevent_nb.notifier_call = mlx5e_rep_netevent_event;\n\terr = register_netevent_notifier(&neigh_update->netevent_nb);\n\tif (err)\n\t\tgoto out_notifier;\n\treturn 0;\n\nout_notifier:\n\tneigh_update->netevent_nb.notifier_call = NULL;\n\trhashtable_destroy(&neigh_update->neigh_ht);\nout_err:\n\tnetdev_warn(rpriv->netdev,\n\t\t    \"Failed to initialize neighbours handling for vport %d\\n\",\n\t\t    rpriv->rep->vport);\n\treturn err;\n}\n\nvoid mlx5e_rep_neigh_cleanup(struct mlx5e_rep_priv *rpriv)\n{\n\tstruct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;\n\tstruct mlx5e_priv *priv = netdev_priv(rpriv->netdev);\n\n\tif (!rpriv->neigh_update.netevent_nb.notifier_call)\n\t\treturn;\n\n\tunregister_netevent_notifier(&neigh_update->netevent_nb);\n\n\tflush_workqueue(priv->wq);  \n\n\tcancel_delayed_work_sync(&rpriv->neigh_update.neigh_stats_work);\n\n\tmutex_destroy(&neigh_update->encap_lock);\n\trhashtable_destroy(&neigh_update->neigh_ht);\n}\n\nstatic int mlx5e_rep_neigh_entry_insert(struct mlx5e_priv *priv,\n\t\t\t\t\tstruct mlx5e_neigh_hash_entry *nhe)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tint err;\n\n\terr = rhashtable_insert_fast(&rpriv->neigh_update.neigh_ht,\n\t\t\t\t     &nhe->rhash_node,\n\t\t\t\t     mlx5e_neigh_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tlist_add_rcu(&nhe->neigh_list, &rpriv->neigh_update.neigh_list);\n\n\treturn err;\n}\n\nstatic void mlx5e_rep_neigh_entry_remove(struct mlx5e_neigh_hash_entry *nhe)\n{\n\tstruct mlx5e_rep_priv *rpriv = nhe->priv->ppriv;\n\n\tmutex_lock(&rpriv->neigh_update.encap_lock);\n\n\tlist_del_rcu(&nhe->neigh_list);\n\n\trhashtable_remove_fast(&rpriv->neigh_update.neigh_ht,\n\t\t\t       &nhe->rhash_node,\n\t\t\t       mlx5e_neigh_ht_params);\n\tmutex_unlock(&rpriv->neigh_update.encap_lock);\n}\n\n \nstruct mlx5e_neigh_hash_entry *\nmlx5e_rep_neigh_entry_lookup(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5e_neigh *m_neigh)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;\n\tstruct mlx5e_neigh_hash_entry *nhe;\n\n\tnhe = rhashtable_lookup_fast(&neigh_update->neigh_ht, m_neigh,\n\t\t\t\t     mlx5e_neigh_ht_params);\n\treturn nhe && mlx5e_rep_neigh_entry_hold(nhe) ? nhe : NULL;\n}\n\nint mlx5e_rep_neigh_entry_create(struct mlx5e_priv *priv,\n\t\t\t\t struct mlx5e_neigh *m_neigh,\n\t\t\t\t struct net_device *neigh_dev,\n\t\t\t\t struct mlx5e_neigh_hash_entry **nhe)\n{\n\tint err;\n\n\t*nhe = kzalloc(sizeof(**nhe), GFP_KERNEL);\n\tif (!*nhe)\n\t\treturn -ENOMEM;\n\n\t(*nhe)->priv = priv;\n\tmemcpy(&(*nhe)->m_neigh, m_neigh, sizeof(*m_neigh));\n\tspin_lock_init(&(*nhe)->encap_list_lock);\n\tINIT_LIST_HEAD(&(*nhe)->encap_list);\n\trefcount_set(&(*nhe)->refcnt, 1);\n\tWRITE_ONCE((*nhe)->neigh_dev, neigh_dev);\n\n\terr = mlx5e_rep_neigh_entry_insert(priv, *nhe);\n\tif (err)\n\t\tgoto out_free;\n\treturn 0;\n\nout_free:\n\tkfree(*nhe);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}