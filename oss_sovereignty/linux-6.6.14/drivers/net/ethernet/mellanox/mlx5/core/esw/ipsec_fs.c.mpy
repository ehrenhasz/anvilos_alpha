{
  "module_name": "ipsec_fs.c",
  "hash_id": "884f270b98303c6a401f7800055ff5fa11d833bd4effe64cf6f2176fcd77311f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/ipsec_fs.c",
  "human_readable_source": "\n\n\n#include \"fs_core.h\"\n#include \"eswitch.h\"\n#include \"en_accel/ipsec.h\"\n#include \"esw/ipsec_fs.h\"\n#if IS_ENABLED(CONFIG_MLX5_CLS_ACT)\n#include \"en/tc_priv.h\"\n#endif\n\nenum {\n\tMLX5_ESW_IPSEC_RX_POL_FT_LEVEL,\n\tMLX5_ESW_IPSEC_RX_ESP_FT_LEVEL,\n\tMLX5_ESW_IPSEC_RX_ESP_FT_CHK_LEVEL,\n};\n\nenum {\n\tMLX5_ESW_IPSEC_TX_POL_FT_LEVEL,\n\tMLX5_ESW_IPSEC_TX_ESP_FT_LEVEL,\n\tMLX5_ESW_IPSEC_TX_ESP_FT_CNT_LEVEL,\n};\n\nvoid mlx5_esw_ipsec_rx_create_attr_set(struct mlx5e_ipsec *ipsec,\n\t\t\t\t       struct mlx5e_ipsec_rx_create_attr *attr)\n{\n\tattr->prio = FDB_CRYPTO_INGRESS;\n\tattr->pol_level = MLX5_ESW_IPSEC_RX_POL_FT_LEVEL;\n\tattr->sa_level = MLX5_ESW_IPSEC_RX_ESP_FT_LEVEL;\n\tattr->status_level = MLX5_ESW_IPSEC_RX_ESP_FT_CHK_LEVEL;\n\tattr->chains_ns = MLX5_FLOW_NAMESPACE_FDB;\n}\n\nint mlx5_esw_ipsec_rx_status_pass_dest_get(struct mlx5e_ipsec *ipsec,\n\t\t\t\t\t   struct mlx5_flow_destination *dest)\n{\n\tdest->type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest->ft = mlx5_chains_get_table(esw_chains(ipsec->mdev->priv.eswitch), 0, 1, 0);\n\n\treturn 0;\n}\n\nint mlx5_esw_ipsec_rx_setup_modify_header(struct mlx5e_ipsec_sa_entry *sa_entry,\n\t\t\t\t\t  struct mlx5_flow_act *flow_act)\n{\n\tu8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5e_ipsec *ipsec = sa_entry->ipsec;\n\tstruct mlx5_core_dev *mdev = ipsec->mdev;\n\tstruct mlx5_modify_hdr *modify_hdr;\n\tu32 mapped_id;\n\tint err;\n\n\terr = xa_alloc_bh(&ipsec->rx_esw->ipsec_obj_id_map, &mapped_id,\n\t\t\t  xa_mk_value(sa_entry->ipsec_obj_id),\n\t\t\t  XA_LIMIT(1, ESW_IPSEC_RX_MAPPED_ID_MASK), 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tMLX5_SET(set_action_in, action, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, action, field,\n\t\t MLX5_ACTION_IN_FIELD_METADATA_REG_C_1);\n\tMLX5_SET(set_action_in, action, offset, ESW_ZONE_ID_BITS);\n\tMLX5_SET(set_action_in, action, length,\n\t\t ESW_TUN_ID_BITS + ESW_TUN_OPTS_BITS);\n\tMLX5_SET(set_action_in, action, data, mapped_id);\n\n\tmodify_hdr = mlx5_modify_header_alloc(mdev, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\t      1, action);\n\tif (IS_ERR(modify_hdr)) {\n\t\terr = PTR_ERR(modify_hdr);\n\t\tgoto err_header_alloc;\n\t}\n\n\tsa_entry->rx_mapped_id = mapped_id;\n\tflow_act->modify_hdr = modify_hdr;\n\tflow_act->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\n\treturn 0;\n\nerr_header_alloc:\n\txa_erase_bh(&ipsec->rx_esw->ipsec_obj_id_map, mapped_id);\n\treturn err;\n}\n\nvoid mlx5_esw_ipsec_rx_id_mapping_remove(struct mlx5e_ipsec_sa_entry *sa_entry)\n{\n\tstruct mlx5e_ipsec *ipsec = sa_entry->ipsec;\n\n\tif (sa_entry->rx_mapped_id)\n\t\txa_erase_bh(&ipsec->rx_esw->ipsec_obj_id_map,\n\t\t\t    sa_entry->rx_mapped_id);\n}\n\nint mlx5_esw_ipsec_rx_ipsec_obj_id_search(struct mlx5e_priv *priv, u32 id,\n\t\t\t\t\t  u32 *ipsec_obj_id)\n{\n\tstruct mlx5e_ipsec *ipsec = priv->ipsec;\n\tvoid *val;\n\n\tval = xa_load(&ipsec->rx_esw->ipsec_obj_id_map, id);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*ipsec_obj_id = xa_to_value(val);\n\n\treturn 0;\n}\n\nvoid mlx5_esw_ipsec_tx_create_attr_set(struct mlx5e_ipsec *ipsec,\n\t\t\t\t       struct mlx5e_ipsec_tx_create_attr *attr)\n{\n\tattr->prio = FDB_CRYPTO_EGRESS;\n\tattr->pol_level = MLX5_ESW_IPSEC_TX_POL_FT_LEVEL;\n\tattr->sa_level = MLX5_ESW_IPSEC_TX_ESP_FT_LEVEL;\n\tattr->cnt_level = MLX5_ESW_IPSEC_TX_ESP_FT_CNT_LEVEL;\n\tattr->chains_ns = MLX5_FLOW_NAMESPACE_FDB;\n}\n\n#if IS_ENABLED(CONFIG_MLX5_CLS_ACT)\nstatic int mlx5_esw_ipsec_modify_flow_dests(struct mlx5_eswitch *esw,\n\t\t\t\t\t    struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr;\n\tstruct mlx5_flow_attr *attr;\n\tint err;\n\n\tattr = flow->attr;\n\tesw_attr = attr->esw_attr;\n\tif (esw_attr->out_count - esw_attr->split_count > 1)\n\t\treturn 0;\n\n\terr = mlx5_eswitch_restore_ipsec_rule(esw, flow->rule[0], esw_attr,\n\t\t\t\t\t      esw_attr->out_count - 1);\n\n\treturn err;\n}\n#endif\n\nvoid mlx5_esw_ipsec_restore_dest_uplink(struct mlx5_core_dev *mdev)\n{\n#if IS_ENABLED(CONFIG_MLX5_CLS_ACT)\n\tstruct mlx5_eswitch *esw = mdev->priv.eswitch;\n\tstruct mlx5_eswitch_rep *rep;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct rhashtable_iter iter;\n\tstruct mlx5e_tc_flow *flow;\n\tunsigned long i;\n\tint err;\n\n\txa_for_each(&esw->offloads.vport_reps, i, rep) {\n\t\trpriv = rep->rep_data[REP_ETH].priv;\n\t\tif (!rpriv || !rpriv->netdev || !atomic_read(&rpriv->tc_ht.nelems))\n\t\t\tcontinue;\n\n\t\trhashtable_walk_enter(&rpriv->tc_ht, &iter);\n\t\trhashtable_walk_start(&iter);\n\t\twhile ((flow = rhashtable_walk_next(&iter)) != NULL) {\n\t\t\tif (IS_ERR(flow))\n\t\t\t\tcontinue;\n\n\t\t\terr = mlx5_esw_ipsec_modify_flow_dests(esw, flow);\n\t\t\tif (err)\n\t\t\t\tmlx5_core_warn_once(mdev,\n\t\t\t\t\t\t    \"Failed to modify flow dests for IPsec\");\n\t\t}\n\t\trhashtable_walk_stop(&iter);\n\t\trhashtable_walk_exit(&iter);\n\t}\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}