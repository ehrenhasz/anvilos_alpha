{
  "module_name": "debugfs.c",
  "hash_id": "0d5d6bfda517cb6318fbb6f6d0b3dbfe1d6c7862375149b8f4fc070251a8834f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lag/debugfs.c",
  "human_readable_source": "\n \n\n#include \"lag.h\"\n\nstatic char *get_str_mode_type(struct mlx5_lag *ldev)\n{\n\tswitch (ldev->mode) {\n\tcase MLX5_LAG_MODE_ROCE: return \"roce\";\n\tcase MLX5_LAG_MODE_SRIOV: return \"switchdev\";\n\tcase MLX5_LAG_MODE_MULTIPATH: return \"multipath\";\n\tcase MLX5_LAG_MODE_MPESW: return \"multiport_eswitch\";\n\tdefault: return \"invalid\";\n\t}\n\n\treturn NULL;\n}\n\nstatic int type_show(struct seq_file *file, void *priv)\n{\n\tstruct mlx5_core_dev *dev = file->private;\n\tstruct mlx5_lag *ldev;\n\tchar *mode = NULL;\n\n\tldev = mlx5_lag_dev(dev);\n\tmutex_lock(&ldev->lock);\n\tif (__mlx5_lag_is_active(ldev))\n\t\tmode = get_str_mode_type(ldev);\n\tmutex_unlock(&ldev->lock);\n\tif (!mode)\n\t\treturn -EINVAL;\n\tseq_printf(file, \"%s\\n\", mode);\n\n\treturn 0;\n}\n\nstatic int port_sel_mode_show(struct seq_file *file, void *priv)\n{\n\tstruct mlx5_core_dev *dev = file->private;\n\tstruct mlx5_lag *ldev;\n\tint ret = 0;\n\tchar *mode;\n\n\tldev = mlx5_lag_dev(dev);\n\tmutex_lock(&ldev->lock);\n\tif (__mlx5_lag_is_active(ldev))\n\t\tmode = mlx5_get_str_port_sel_mode(ldev->mode, ldev->mode_flags);\n\telse\n\t\tret = -EINVAL;\n\tmutex_unlock(&ldev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(file, \"%s\\n\", mode);\n\treturn 0;\n}\n\nstatic int state_show(struct seq_file *file, void *priv)\n{\n\tstruct mlx5_core_dev *dev = file->private;\n\tstruct mlx5_lag *ldev;\n\tbool active;\n\n\tldev = mlx5_lag_dev(dev);\n\tmutex_lock(&ldev->lock);\n\tactive = __mlx5_lag_is_active(ldev);\n\tmutex_unlock(&ldev->lock);\n\tseq_printf(file, \"%s\\n\", active ? \"active\" : \"disabled\");\n\treturn 0;\n}\n\nstatic int flags_show(struct seq_file *file, void *priv)\n{\n\tstruct mlx5_core_dev *dev = file->private;\n\tbool fdb_sel_mode_native;\n\tstruct mlx5_lag *ldev;\n\tbool shared_fdb;\n\tbool lag_active;\n\n\tldev = mlx5_lag_dev(dev);\n\tmutex_lock(&ldev->lock);\n\tlag_active = __mlx5_lag_is_active(ldev);\n\tif (!lag_active)\n\t\tgoto unlock;\n\n\tshared_fdb = test_bit(MLX5_LAG_MODE_FLAG_SHARED_FDB, &ldev->mode_flags);\n\tfdb_sel_mode_native = test_bit(MLX5_LAG_MODE_FLAG_FDB_SEL_MODE_NATIVE,\n\t\t\t\t       &ldev->mode_flags);\n\nunlock:\n\tmutex_unlock(&ldev->lock);\n\tif (!lag_active)\n\t\treturn -EINVAL;\n\n\tseq_printf(file, \"%s:%s\\n\", \"shared_fdb\", shared_fdb ? \"on\" : \"off\");\n\tseq_printf(file, \"%s:%s\\n\", \"fdb_selection_mode\",\n\t\t   fdb_sel_mode_native ? \"native\" : \"affinity\");\n\treturn 0;\n}\n\nstatic int mapping_show(struct seq_file *file, void *priv)\n{\n\tstruct mlx5_core_dev *dev = file->private;\n\tu8 ports[MLX5_MAX_PORTS] = {};\n\tstruct mlx5_lag *ldev;\n\tbool hash = false;\n\tbool lag_active;\n\tint num_ports;\n\tint i;\n\n\tldev = mlx5_lag_dev(dev);\n\tmutex_lock(&ldev->lock);\n\tlag_active = __mlx5_lag_is_active(ldev);\n\tif (lag_active) {\n\t\tif (test_bit(MLX5_LAG_MODE_FLAG_HASH_BASED, &ldev->mode_flags)) {\n\t\t\tmlx5_infer_tx_enabled(&ldev->tracker, ldev->ports, ports,\n\t\t\t\t\t      &num_ports);\n\t\t\thash = true;\n\t\t} else {\n\t\t\tfor (i = 0; i < ldev->ports; i++)\n\t\t\t\tports[i] = ldev->v2p_map[i];\n\t\t\tnum_ports = ldev->ports;\n\t\t}\n\t}\n\tmutex_unlock(&ldev->lock);\n\tif (!lag_active)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tif (hash)\n\t\t\tseq_printf(file, \"%d\\n\", ports[i] + 1);\n\t\telse\n\t\t\tseq_printf(file, \"%d:%d\\n\", i + 1, ports[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int members_show(struct seq_file *file, void *priv)\n{\n\tstruct mlx5_core_dev *dev = file->private;\n\tstruct mlx5_lag *ldev;\n\tint i;\n\n\tldev = mlx5_lag_dev(dev);\n\tmutex_lock(&ldev->lock);\n\tfor (i = 0; i < ldev->ports; i++) {\n\t\tif (!ldev->pf[i].dev)\n\t\t\tcontinue;\n\t\tseq_printf(file, \"%s\\n\", dev_name(ldev->pf[i].dev->device));\n\t}\n\tmutex_unlock(&ldev->lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(type);\nDEFINE_SHOW_ATTRIBUTE(port_sel_mode);\nDEFINE_SHOW_ATTRIBUTE(state);\nDEFINE_SHOW_ATTRIBUTE(flags);\nDEFINE_SHOW_ATTRIBUTE(mapping);\nDEFINE_SHOW_ATTRIBUTE(members);\n\nvoid mlx5_ldev_add_debugfs(struct mlx5_core_dev *dev)\n{\n\tstruct dentry *dbg;\n\n\tdbg = debugfs_create_dir(\"lag\", mlx5_debugfs_get_dev_root(dev));\n\tdev->priv.dbg.lag_debugfs = dbg;\n\n\tdebugfs_create_file(\"type\", 0444, dbg, dev, &type_fops);\n\tdebugfs_create_file(\"port_sel_mode\", 0444, dbg, dev, &port_sel_mode_fops);\n\tdebugfs_create_file(\"state\", 0444, dbg, dev, &state_fops);\n\tdebugfs_create_file(\"flags\", 0444, dbg, dev, &flags_fops);\n\tdebugfs_create_file(\"mapping\", 0444, dbg, dev, &mapping_fops);\n\tdebugfs_create_file(\"members\", 0444, dbg, dev, &members_fops);\n}\n\nvoid mlx5_ldev_remove_debugfs(struct dentry *dbg)\n{\n\tdebugfs_remove_recursive(dbg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}