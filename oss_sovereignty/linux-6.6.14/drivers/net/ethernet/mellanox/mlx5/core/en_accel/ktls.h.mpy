{
  "module_name": "ktls.h",
  "hash_id": "5cb3c0dd61a9b88071003f23d720403c5d76a2fdda33c678ec2870d469a04af1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls.h",
  "human_readable_source": " \n \n\n#ifndef __MLX5E_KTLS_H__\n#define __MLX5E_KTLS_H__\n\n#include <linux/debugfs.h>\n#include <linux/tls.h>\n#include <net/tls.h>\n#include \"en.h\"\n\n#ifdef CONFIG_MLX5_EN_TLS\n#include \"lib/crypto.h\"\n\nstruct mlx5_crypto_dek *mlx5_ktls_create_key(struct mlx5_crypto_dek_pool *dek_pool,\n\t\t\t\t\t     struct tls_crypto_info *crypto_info);\nvoid mlx5_ktls_destroy_key(struct mlx5_crypto_dek_pool *dek_pool,\n\t\t\t   struct mlx5_crypto_dek *dek);\n\nstatic inline bool mlx5e_is_ktls_device(struct mlx5_core_dev *mdev)\n{\n\tif (is_kdump_kernel())\n\t\treturn false;\n\n\tif (!MLX5_CAP_GEN(mdev, tls_tx) && !MLX5_CAP_GEN(mdev, tls_rx))\n\t\treturn false;\n\n\tif (!MLX5_CAP_GEN(mdev, log_max_dek))\n\t\treturn false;\n\n\treturn (MLX5_CAP_TLS(mdev, tls_1_2_aes_gcm_128) ||\n\t\tMLX5_CAP_TLS(mdev, tls_1_2_aes_gcm_256));\n}\n\nstatic inline bool mlx5e_ktls_type_check(struct mlx5_core_dev *mdev,\n\t\t\t\t\t struct tls_crypto_info *crypto_info)\n{\n\tswitch (crypto_info->cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128:\n\t\tif (crypto_info->version == TLS_1_2_VERSION)\n\t\t\treturn MLX5_CAP_TLS(mdev,  tls_1_2_aes_gcm_128);\n\t\tbreak;\n\tcase TLS_CIPHER_AES_GCM_256:\n\t\tif (crypto_info->version == TLS_1_2_VERSION)\n\t\t\treturn MLX5_CAP_TLS(mdev,  tls_1_2_aes_gcm_256);\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nvoid mlx5e_ktls_build_netdev(struct mlx5e_priv *priv);\nint mlx5e_ktls_init_tx(struct mlx5e_priv *priv);\nvoid mlx5e_ktls_cleanup_tx(struct mlx5e_priv *priv);\nint mlx5e_ktls_init_rx(struct mlx5e_priv *priv);\nvoid mlx5e_ktls_cleanup_rx(struct mlx5e_priv *priv);\nint mlx5e_ktls_set_feature_rx(struct net_device *netdev, bool enable);\nstruct mlx5e_ktls_resync_resp *\nmlx5e_ktls_rx_resync_create_resp_list(void);\nvoid mlx5e_ktls_rx_resync_destroy_resp_list(struct mlx5e_ktls_resync_resp *resp_list);\n\nstatic inline bool mlx5e_is_ktls_tx(struct mlx5_core_dev *mdev)\n{\n\treturn !is_kdump_kernel() && MLX5_CAP_GEN(mdev, tls_tx);\n}\n\nbool mlx5e_is_ktls_rx(struct mlx5_core_dev *mdev);\n\nstruct mlx5e_tls_sw_stats {\n\tatomic64_t tx_tls_ctx;\n\tatomic64_t tx_tls_del;\n\tatomic64_t tx_tls_pool_alloc;\n\tatomic64_t tx_tls_pool_free;\n\tatomic64_t rx_tls_ctx;\n\tatomic64_t rx_tls_del;\n};\n\nstruct mlx5e_tls_debugfs {\n\tstruct dentry *dfs;\n\tstruct dentry *dfs_tx;\n};\n\nstruct mlx5e_tls {\n\tstruct mlx5_core_dev *mdev;\n\tstruct mlx5e_tls_sw_stats sw_stats;\n\tstruct workqueue_struct *rx_wq;\n\tstruct mlx5e_tls_tx_pool *tx_pool;\n\tstruct mlx5_crypto_dek_pool *dek_pool;\n\tstruct mlx5e_tls_debugfs debugfs;\n};\n\nint mlx5e_ktls_init(struct mlx5e_priv *priv);\nvoid mlx5e_ktls_cleanup(struct mlx5e_priv *priv);\n\nint mlx5e_ktls_get_count(struct mlx5e_priv *priv);\nint mlx5e_ktls_get_strings(struct mlx5e_priv *priv, uint8_t *data);\nint mlx5e_ktls_get_stats(struct mlx5e_priv *priv, u64 *data);\n\n#else\nstatic inline void mlx5e_ktls_build_netdev(struct mlx5e_priv *priv)\n{\n}\n\nstatic inline int mlx5e_ktls_init_tx(struct mlx5e_priv *priv)\n{\n\treturn 0;\n}\n\nstatic inline void mlx5e_ktls_cleanup_tx(struct mlx5e_priv *priv)\n{\n}\n\nstatic inline int mlx5e_ktls_init_rx(struct mlx5e_priv *priv)\n{\n\treturn 0;\n}\n\nstatic inline void mlx5e_ktls_cleanup_rx(struct mlx5e_priv *priv)\n{\n}\n\nstatic inline int mlx5e_ktls_set_feature_rx(struct net_device *netdev, bool enable)\n{\n\tnetdev_warn(netdev, \"kTLS is not supported\\n\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline struct mlx5e_ktls_resync_resp *\nmlx5e_ktls_rx_resync_create_resp_list(void)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic inline void\nmlx5e_ktls_rx_resync_destroy_resp_list(struct mlx5e_ktls_resync_resp *resp_list) {}\n\nstatic inline bool mlx5e_is_ktls_rx(struct mlx5_core_dev *mdev)\n{\n\treturn false;\n}\n\nstatic inline int mlx5e_ktls_init(struct mlx5e_priv *priv) { return 0; }\nstatic inline void mlx5e_ktls_cleanup(struct mlx5e_priv *priv) { }\nstatic inline int mlx5e_ktls_get_count(struct mlx5e_priv *priv) { return 0; }\nstatic inline int mlx5e_ktls_get_strings(struct mlx5e_priv *priv, uint8_t *data)\n{\n\treturn 0;\n}\n\nstatic inline int mlx5e_ktls_get_stats(struct mlx5e_priv *priv, u64 *data)\n{\n\treturn 0;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}