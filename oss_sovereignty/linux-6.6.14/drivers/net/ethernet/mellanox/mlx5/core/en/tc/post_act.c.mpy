{
  "module_name": "post_act.c",
  "hash_id": "59edfaeb4d93d72bef9e1284f16cf0a47ddac9620fd2cc547363287cad7c7ed0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c",
  "human_readable_source": "\n\n\n#include \"en/tc_priv.h\"\n#include \"en_tc.h\"\n#include \"post_act.h\"\n#include \"mlx5_core.h\"\n#include \"fs_core.h\"\n\nstruct mlx5e_post_act {\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5_fs_chains *chains;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5e_priv *priv;\n\tstruct xarray ids;\n};\n\nstruct mlx5e_post_act_handle {\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5_flow_attr *attr;\n\tstruct mlx5_flow_handle *rule;\n\tu32 id;\n};\n\n#define MLX5_POST_ACTION_BITS MLX5_REG_MAPPING_MBITS(FTEID_TO_REG)\n#define MLX5_POST_ACTION_MASK MLX5_REG_MAPPING_MASK(FTEID_TO_REG)\n#define MLX5_POST_ACTION_MAX MLX5_POST_ACTION_MASK\n\nstruct mlx5e_post_act *\nmlx5e_tc_post_act_init(struct mlx5e_priv *priv, struct mlx5_fs_chains *chains,\n\t\t       enum mlx5_flow_namespace_type ns_type)\n{\n\tenum fs_flow_table_type table_type = ns_type == MLX5_FLOW_NAMESPACE_FDB ?\n\t\t\t\t\t     FS_FT_FDB : FS_FT_NIC_RX;\n\tstruct mlx5e_post_act *post_act;\n\tint err;\n\n\tif (!MLX5_CAP_FLOWTABLE_TYPE(priv->mdev, ignore_flow_level, table_type)) {\n\t\tif (priv->mdev->coredev_type == MLX5_COREDEV_PF)\n\t\t\tmlx5_core_warn(priv->mdev, \"firmware level support is missing\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_check;\n\t}\n\n\tpost_act = kzalloc(sizeof(*post_act), GFP_KERNEL);\n\tif (!post_act) {\n\t\terr = -ENOMEM;\n\t\tgoto err_check;\n\t}\n\tpost_act->ft = mlx5_chains_create_global_table(chains);\n\tif (IS_ERR(post_act->ft)) {\n\t\terr = PTR_ERR(post_act->ft);\n\t\tmlx5_core_warn(priv->mdev, \"failed to create post action table, err: %d\\n\", err);\n\t\tgoto err_ft;\n\t}\n\tpost_act->chains = chains;\n\tpost_act->ns_type = ns_type;\n\tpost_act->priv = priv;\n\txa_init_flags(&post_act->ids, XA_FLAGS_ALLOC1);\n\treturn post_act;\n\nerr_ft:\n\tkfree(post_act);\nerr_check:\n\treturn ERR_PTR(err);\n}\n\nvoid\nmlx5e_tc_post_act_destroy(struct mlx5e_post_act *post_act)\n{\n\tif (IS_ERR_OR_NULL(post_act))\n\t\treturn;\n\n\txa_destroy(&post_act->ids);\n\tmlx5_chains_destroy_global_table(post_act->chains, post_act->ft);\n\tkfree(post_act);\n}\n\nint\nmlx5e_tc_post_act_offload(struct mlx5e_post_act *post_act,\n\t\t\t  struct mlx5e_post_act_handle *handle)\n{\n\tstruct mlx5_flow_spec *spec;\n\tint err;\n\n\tif (IS_ERR(post_act))\n\t\treturn PTR_ERR(post_act);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\t \n\tmlx5e_tc_match_to_reg_match(spec, FTEID_TO_REG, handle->id, MLX5_POST_ACTION_MASK);\n\n\thandle->rule = mlx5e_tc_rule_offload(post_act->priv, spec, handle->attr);\n\tif (IS_ERR(handle->rule)) {\n\t\terr = PTR_ERR(handle->rule);\n\t\tnetdev_warn(post_act->priv->netdev, \"Failed to add post action rule\");\n\t\tgoto err_rule;\n\t}\n\n\tkvfree(spec);\n\treturn 0;\n\nerr_rule:\n\tkvfree(spec);\n\treturn err;\n}\n\nstruct mlx5e_post_act_handle *\nmlx5e_tc_post_act_add(struct mlx5e_post_act *post_act, struct mlx5_flow_attr *post_attr)\n{\n\tstruct mlx5e_post_act_handle *handle;\n\tint err;\n\n\tif (IS_ERR(post_act))\n\t\treturn ERR_CAST(post_act);\n\n\thandle = kzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpost_attr->chain = 0;\n\tpost_attr->prio = 0;\n\tpost_attr->ft = post_act->ft;\n\tpost_attr->inner_match_level = MLX5_MATCH_NONE;\n\tpost_attr->outer_match_level = MLX5_MATCH_NONE;\n\tpost_attr->action &= ~MLX5_FLOW_CONTEXT_ACTION_DECAP;\n\tpost_attr->flags |= MLX5_ATTR_FLAG_NO_IN_PORT;\n\n\thandle->ns_type = post_act->ns_type;\n\t \n\tif (handle->ns_type == MLX5_FLOW_NAMESPACE_FDB)\n\t\tpost_attr->esw_attr->split_count = 0;\n\n\terr = xa_alloc(&post_act->ids, &handle->id, post_attr,\n\t\t       XA_LIMIT(1, MLX5_POST_ACTION_MAX), GFP_KERNEL);\n\tif (err)\n\t\tgoto err_xarray;\n\n\thandle->attr = post_attr;\n\n\treturn handle;\n\nerr_xarray:\n\tkfree(handle);\n\treturn ERR_PTR(err);\n}\n\nvoid\nmlx5e_tc_post_act_unoffload(struct mlx5e_post_act *post_act,\n\t\t\t    struct mlx5e_post_act_handle *handle)\n{\n\tmlx5e_tc_rule_unoffload(post_act->priv, handle->rule, handle->attr);\n\thandle->rule = NULL;\n}\n\nvoid\nmlx5e_tc_post_act_del(struct mlx5e_post_act *post_act, struct mlx5e_post_act_handle *handle)\n{\n\tif (!IS_ERR_OR_NULL(handle->rule))\n\t\tmlx5e_tc_post_act_unoffload(post_act, handle);\n\txa_erase(&post_act->ids, handle->id);\n\tkfree(handle);\n}\n\nstruct mlx5_flow_table *\nmlx5e_tc_post_act_get_ft(struct mlx5e_post_act *post_act)\n{\n\treturn post_act->ft;\n}\n\n \nint\nmlx5e_tc_post_act_set_handle(struct mlx5_core_dev *dev,\n\t\t\t     struct mlx5e_post_act_handle *handle,\n\t\t\t     struct mlx5e_tc_mod_hdr_acts *acts)\n{\n\treturn mlx5e_tc_match_to_reg_set(dev, acts, handle->ns_type, FTEID_TO_REG, handle->id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}