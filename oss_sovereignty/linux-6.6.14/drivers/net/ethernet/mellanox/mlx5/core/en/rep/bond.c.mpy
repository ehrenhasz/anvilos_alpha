{
  "module_name": "bond.c",
  "hash_id": "e1846e855c50472c93a718eac84b01e5ad90d4a5796eeeada8ed26dc92388782",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/rep/bond.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/list.h>\n#include <net/lag.h>\n\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"esw/acl/ofld.h\"\n#include \"en_rep.h\"\n\nstruct mlx5e_rep_bond {\n\tstruct notifier_block nb;\n\tstruct netdev_net_notifier nn;\n\tstruct list_head metadata_list;\n};\n\nstruct mlx5e_rep_bond_slave_entry {\n\tstruct list_head list;\n\tstruct net_device *netdev;\n};\n\nstruct mlx5e_rep_bond_metadata {\n\tstruct list_head list;  \n\tstruct mlx5_eswitch *esw;\n\t  \n\tstruct net_device *lag_dev;\n\tu32 metadata_reg_c_0;\n\n\tstruct list_head slaves_list;  \n\tint slaves;\n};\n\nstatic struct mlx5e_rep_bond_metadata *\nmlx5e_lookup_rep_bond_metadata(struct mlx5_rep_uplink_priv *uplink_priv,\n\t\t\t       const struct net_device *lag_dev)\n{\n\tstruct mlx5e_rep_bond_metadata *found = NULL;\n\tstruct mlx5e_rep_bond_metadata *cur;\n\n\tlist_for_each_entry(cur, &uplink_priv->bond->metadata_list, list) {\n\t\tif (cur->lag_dev == lag_dev) {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic struct mlx5e_rep_bond_slave_entry *\nmlx5e_lookup_rep_bond_slave_entry(struct mlx5e_rep_bond_metadata *mdata,\n\t\t\t\t  const struct net_device *netdev)\n{\n\tstruct mlx5e_rep_bond_slave_entry *found = NULL;\n\tstruct mlx5e_rep_bond_slave_entry *cur;\n\n\tlist_for_each_entry(cur, &mdata->slaves_list, list) {\n\t\tif (cur->netdev == netdev) {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic void mlx5e_rep_bond_metadata_release(struct mlx5e_rep_bond_metadata *mdata)\n{\n\tnetdev_dbg(mdata->lag_dev, \"destroy rep_bond_metadata(%d)\\n\",\n\t\t   mdata->metadata_reg_c_0);\n\tlist_del(&mdata->list);\n\tmlx5_esw_match_metadata_free(mdata->esw, mdata->metadata_reg_c_0);\n\tWARN_ON(!list_empty(&mdata->slaves_list));\n\tkfree(mdata);\n}\n\n \nint mlx5e_rep_bond_enslave(struct mlx5_eswitch *esw, struct net_device *netdev,\n\t\t\t   struct net_device *lag_dev)\n{\n\tstruct mlx5e_rep_bond_slave_entry *s_entry;\n\tstruct mlx5e_rep_bond_metadata *mdata;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mlx5e_priv *priv;\n\tint err;\n\n\tASSERT_RTNL();\n\n\trpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tmdata = mlx5e_lookup_rep_bond_metadata(&rpriv->uplink_priv, lag_dev);\n\tif (!mdata) {\n\t\t \n\t\tmdata = kzalloc(sizeof(*mdata), GFP_KERNEL);\n\t\tif (!mdata)\n\t\t\treturn -ENOMEM;\n\n\t\tmdata->lag_dev = lag_dev;\n\t\tmdata->esw = esw;\n\t\tINIT_LIST_HEAD(&mdata->slaves_list);\n\t\tmdata->metadata_reg_c_0 = mlx5_esw_match_metadata_alloc(esw);\n\t\tif (!mdata->metadata_reg_c_0) {\n\t\t\tkfree(mdata);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tlist_add(&mdata->list, &rpriv->uplink_priv.bond->metadata_list);\n\n\t\tnetdev_dbg(lag_dev, \"create rep_bond_metadata(%d)\\n\",\n\t\t\t   mdata->metadata_reg_c_0);\n\t}\n\n\ts_entry = kzalloc(sizeof(*s_entry), GFP_KERNEL);\n\tif (!s_entry) {\n\t\terr = -ENOMEM;\n\t\tgoto entry_alloc_err;\n\t}\n\n\ts_entry->netdev = netdev;\n\tpriv = netdev_priv(netdev);\n\trpriv = priv->ppriv;\n\n\terr = mlx5_esw_acl_ingress_vport_metadata_update(esw, rpriv->rep->vport,\n\t\t\t\t\t\t\t mdata->metadata_reg_c_0);\n\tif (err)\n\t\tgoto ingress_err;\n\n\tmdata->slaves++;\n\tlist_add_tail(&s_entry->list, &mdata->slaves_list);\n\tnetdev_dbg(netdev, \"enslave rep vport(%d) lag_dev(%s) metadata(0x%x)\\n\",\n\t\t   rpriv->rep->vport, lag_dev->name, mdata->metadata_reg_c_0);\n\n\treturn 0;\n\ningress_err:\n\tkfree(s_entry);\nentry_alloc_err:\n\tif (!mdata->slaves)\n\t\tmlx5e_rep_bond_metadata_release(mdata);\n\treturn err;\n}\n\n \nvoid mlx5e_rep_bond_unslave(struct mlx5_eswitch *esw,\n\t\t\t    const struct net_device *netdev,\n\t\t\t    const struct net_device *lag_dev)\n{\n\tstruct mlx5e_rep_bond_slave_entry *s_entry;\n\tstruct mlx5e_rep_bond_metadata *mdata;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mlx5e_priv *priv;\n\n\tASSERT_RTNL();\n\n\trpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tmdata = mlx5e_lookup_rep_bond_metadata(&rpriv->uplink_priv, lag_dev);\n\tif (!mdata)\n\t\treturn;\n\n\ts_entry = mlx5e_lookup_rep_bond_slave_entry(mdata, netdev);\n\tif (!s_entry)\n\t\treturn;\n\n\tpriv = netdev_priv(netdev);\n\trpriv = priv->ppriv;\n\n\t \n\tmlx5_esw_acl_ingress_vport_metadata_update(esw, rpriv->rep->vport, 0);\n\tmlx5_esw_acl_egress_vport_unbond(esw, rpriv->rep->vport);\n\tmlx5e_rep_bond_update(priv, false);\n\n\tlist_del(&s_entry->list);\n\n\tnetdev_dbg(netdev, \"unslave rep vport(%d) lag_dev(%s) metadata(0x%x)\\n\",\n\t\t   rpriv->rep->vport, lag_dev->name, mdata->metadata_reg_c_0);\n\n\tif (--mdata->slaves == 0)\n\t\tmlx5e_rep_bond_metadata_release(mdata);\n\tkfree(s_entry);\n}\n\nstatic bool mlx5e_rep_is_lag_netdev(struct net_device *netdev)\n{\n\treturn netif_is_lag_port(netdev) && mlx5e_eswitch_vf_rep(netdev);\n}\n\nstatic void mlx5e_rep_changelowerstate_event(struct net_device *netdev, void *ptr)\n{\n\tstruct netdev_notifier_changelowerstate_info *info;\n\tstruct netdev_lag_lower_state_info *lag_info;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct net_device *lag_dev;\n\tstruct mlx5e_priv *priv;\n\tstruct list_head *iter;\n\tstruct net_device *dev;\n\tu16 acl_vport_num;\n\tu16 fwd_vport_num;\n\tint err;\n\n\tinfo = ptr;\n\tlag_info = info->lower_state_info;\n\t \n\tif (!lag_info->tx_enabled)\n\t\treturn;\n\n\tpriv = netdev_priv(netdev);\n\trpriv = priv->ppriv;\n\tfwd_vport_num = rpriv->rep->vport;\n\tlag_dev = netdev_master_upper_dev_get(netdev);\n\tif (!lag_dev)\n\t\treturn;\n\n\tnetdev_dbg(netdev, \"lag_dev(%s)'s slave vport(%d) is txable(%d)\\n\",\n\t\t   lag_dev->name, fwd_vport_num, net_lag_port_dev_txable(netdev));\n\n\t \n\tnetdev_for_each_lower_dev(lag_dev, dev, iter) {\n\t\tpriv = netdev_priv(dev);\n\t\trpriv = priv->ppriv;\n\t\tacl_vport_num = rpriv->rep->vport;\n\t\tif (acl_vport_num != fwd_vport_num) {\n\t\t\t \n\t\t\tmlx5e_rep_bond_update(priv, true);\n\t\t\terr = mlx5_esw_acl_egress_vport_bond(priv->mdev->priv.eswitch,\n\t\t\t\t\t\t\t     fwd_vport_num,\n\t\t\t\t\t\t\t     acl_vport_num);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t    \"configure slave vport(%d) egress fwd, err(%d)\",\n\t\t\t\t\t    acl_vport_num, err);\n\t\t}\n\t}\n\n\t \n\terr = mlx5e_rep_bond_update(netdev_priv(netdev), false);\n\tif (err)\n\t\tnetdev_warn(netdev, \"configure active slave vport(%d) rx_rule, err(%d)\",\n\t\t\t    fwd_vport_num, err);\n}\n\nstatic void mlx5e_rep_changeupper_event(struct net_device *netdev, void *ptr)\n{\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct net_device *lag_dev;\n\tstruct mlx5e_priv *priv;\n\n\tpriv = netdev_priv(netdev);\n\trpriv = priv->ppriv;\n\tlag_dev = info->upper_dev;\n\n\tnetdev_dbg(netdev, \"%sslave vport(%d) lag(%s)\\n\",\n\t\t   info->linking ? \"en\" : \"un\", rpriv->rep->vport, lag_dev->name);\n\n\tif (info->linking)\n\t\tmlx5e_rep_bond_enslave(priv->mdev->priv.eswitch, netdev, lag_dev);\n\telse\n\t\tmlx5e_rep_bond_unslave(priv->mdev->priv.eswitch, netdev, lag_dev);\n}\n\n \nstatic int mlx5e_rep_esw_bond_netevent(struct notifier_block *nb,\n\t\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mlx5e_rep_bond *bond;\n\tstruct mlx5e_priv *priv;\n\n\tif (!mlx5e_rep_is_lag_netdev(netdev))\n\t\treturn NOTIFY_DONE;\n\n\tbond = container_of(nb, struct mlx5e_rep_bond, nb);\n\tpriv = netdev_priv(netdev);\n\trpriv = mlx5_eswitch_get_uplink_priv(priv->mdev->priv.eswitch, REP_ETH);\n\t \n\tif (rpriv->uplink_priv.bond != bond)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGELOWERSTATE:\n\t\tmlx5e_rep_changelowerstate_event(netdev, ptr);\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tmlx5e_rep_changeupper_event(netdev, ptr);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\n \nint mlx5e_rep_bond_init(struct mlx5e_rep_priv *rpriv)\n{\n\tstruct mlx5_rep_uplink_priv *uplink_priv = &rpriv->uplink_priv;\n\tstruct net_device *netdev = rpriv->netdev;\n\tstruct mlx5e_priv *priv;\n\tint ret = 0;\n\n\tpriv = netdev_priv(netdev);\n\tif (!mlx5_esw_acl_egress_fwd2vport_supported(priv->mdev->priv.eswitch))\n\t\tgoto out;\n\n\tuplink_priv->bond = kvzalloc(sizeof(*uplink_priv->bond), GFP_KERNEL);\n\tif (!uplink_priv->bond) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&uplink_priv->bond->metadata_list);\n\tuplink_priv->bond->nb.notifier_call = mlx5e_rep_esw_bond_netevent;\n\tret = register_netdevice_notifier_dev_net(netdev,\n\t\t\t\t\t\t  &uplink_priv->bond->nb,\n\t\t\t\t\t\t  &uplink_priv->bond->nn);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"register bonding netevent notifier, err(%d)\\n\", ret);\n\t\tkvfree(uplink_priv->bond);\n\t\tuplink_priv->bond = NULL;\n\t}\n\nout:\n\treturn ret;\n}\n\nvoid mlx5e_rep_bond_cleanup(struct mlx5e_rep_priv *rpriv)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(rpriv->netdev);\n\n\tif (!mlx5_esw_acl_egress_fwd2vport_supported(priv->mdev->priv.eswitch) ||\n\t    !rpriv->uplink_priv.bond)\n\t\treturn;\n\n\tunregister_netdevice_notifier_dev_net(rpriv->netdev,\n\t\t\t\t\t      &rpriv->uplink_priv.bond->nb,\n\t\t\t\t\t      &rpriv->uplink_priv.bond->nn);\n\tkvfree(rpriv->uplink_priv.bond);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}