{
  "module_name": "vlan.c",
  "hash_id": "d9aaf8a6cc6136f15a05ed45f69dd655eaee4ab172afda774df04011ab8038ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c",
  "human_readable_source": "\n\n\n#include <linux/if_vlan.h>\n#include \"act.h\"\n#include \"vlan.h\"\n#include \"en/tc_priv.h\"\n\nstatic int\nadd_vlan_prio_tag_rewrite_action(struct mlx5e_priv *priv,\n\t\t\t\t struct mlx5e_tc_flow_parse_attr *parse_attr,\n\t\t\t\t u32 *action, struct netlink_ext_ack *extack)\n{\n\tconst struct flow_action_entry prio_tag_act = {\n\t\t.vlan.vid = 0,\n\t\t.vlan.prio =\n\t\t\tMLX5_GET(fte_match_set_lyr_2_4,\n\t\t\t\t mlx5e_get_match_headers_value(*action,\n\t\t\t\t\t\t\t       &parse_attr->spec),\n\t\t\t\t first_prio) &\n\t\t\tMLX5_GET(fte_match_set_lyr_2_4,\n\t\t\t\t mlx5e_get_match_headers_criteria(*action,\n\t\t\t\t\t\t\t\t  &parse_attr->spec),\n\t\t\t\t first_prio),\n\t};\n\n\treturn mlx5e_tc_act_vlan_add_rewrite_action(priv, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\t\t    &prio_tag_act, parse_attr, action,\n\t\t\t\t\t\t    extack);\n}\n\nstatic int\nparse_tc_vlan_action(struct mlx5e_priv *priv,\n\t\t     const struct flow_action_entry *act,\n\t\t     struct mlx5_esw_flow_attr *attr,\n\t\t     u32 *action,\n\t\t     struct netlink_ext_ack *extack,\n\t\t     struct mlx5e_tc_act_parse_state *parse_state)\n{\n\tu8 vlan_idx = attr->total_vlan;\n\n\tif (vlan_idx >= MLX5_FS_VLAN_DEPTH) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Total vlans used is greater than supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!mlx5_eswitch_vlan_actions_supported(priv->mdev, vlan_idx)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"firmware vlan actions is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (act->id) {\n\tcase FLOW_ACTION_VLAN_POP:\n\t\tif (vlan_idx)\n\t\t\t*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2;\n\t\telse\n\t\t\t*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;\n\t\tbreak;\n\tcase FLOW_ACTION_VLAN_PUSH:\n\t\tattr->vlan_vid[vlan_idx] = act->vlan.vid;\n\t\tattr->vlan_prio[vlan_idx] = act->vlan.prio;\n\t\tattr->vlan_proto[vlan_idx] = act->vlan.proto;\n\t\tif (!attr->vlan_proto[vlan_idx])\n\t\t\tattr->vlan_proto[vlan_idx] = htons(ETH_P_8021Q);\n\n\t\tif (vlan_idx)\n\t\t\t*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;\n\t\telse\n\t\t\t*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;\n\t\tbreak;\n\tcase FLOW_ACTION_VLAN_POP_ETH:\n\t\tparse_state->eth_pop = true;\n\t\tbreak;\n\tcase FLOW_ACTION_VLAN_PUSH_ETH:\n\t\tif (!flow_flag_test(parse_state->flow, L3_TO_L2_DECAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tparse_state->eth_push = true;\n\t\tmemcpy(attr->eth.h_dest, act->vlan_push_eth.dst, ETH_ALEN);\n\t\tmemcpy(attr->eth.h_source, act->vlan_push_eth.src, ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unexpected action id for VLAN\");\n\t\treturn -EINVAL;\n\t}\n\n\tattr->total_vlan = vlan_idx + 1;\n\n\treturn 0;\n}\n\nint\nmlx5e_tc_act_vlan_add_push_action(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5_flow_attr *attr,\n\t\t\t\t  struct net_device **out_dev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *vlan_dev = *out_dev;\n\tstruct flow_action_entry vlan_act = {\n\t\t.id = FLOW_ACTION_VLAN_PUSH,\n\t\t.vlan.vid = vlan_dev_vlan_id(vlan_dev),\n\t\t.vlan.proto = vlan_dev_vlan_proto(vlan_dev),\n\t\t.vlan.prio = 0,\n\t};\n\tint err;\n\n\terr = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, &attr->action, extack, NULL);\n\tif (err)\n\t\treturn err;\n\n\trcu_read_lock();\n\t*out_dev = dev_get_by_index_rcu(dev_net(vlan_dev), dev_get_iflink(vlan_dev));\n\trcu_read_unlock();\n\tif (!*out_dev)\n\t\treturn -ENODEV;\n\n\tif (is_vlan_dev(*out_dev))\n\t\terr = mlx5e_tc_act_vlan_add_push_action(priv, attr, out_dev, extack);\n\n\treturn err;\n}\n\nint\nmlx5e_tc_act_vlan_add_pop_action(struct mlx5e_priv *priv,\n\t\t\t\t struct mlx5_flow_attr *attr,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct flow_action_entry vlan_act = {\n\t\t.id = FLOW_ACTION_VLAN_POP,\n\t};\n\tint nest_level, err = 0;\n\n\tnest_level = attr->parse_attr->filter_dev->lower_level -\n\t\t\t\t\t\tpriv->netdev->lower_level;\n\twhile (nest_level--) {\n\t\terr = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, &attr->action,\n\t\t\t\t\t   extack, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int\ntc_act_parse_vlan(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t  const struct flow_action_entry *act,\n\t\t  struct mlx5e_priv *priv,\n\t\t  struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tint err;\n\n\tif (act->id == FLOW_ACTION_VLAN_PUSH &&\n\t    (attr->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP)) {\n\t\t \n\t\tattr->action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;\n\t\terr = mlx5e_tc_act_vlan_add_rewrite_action(priv, MLX5_FLOW_NAMESPACE_FDB, act,\n\t\t\t\t\t\t\t   attr->parse_attr, &attr->action,\n\t\t\t\t\t\t\t   parse_state->extack);\n\t} else {\n\t\terr = parse_tc_vlan_action(priv, act, esw_attr, &attr->action,\n\t\t\t\t\t   parse_state->extack, parse_state);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tesw_attr->split_count = esw_attr->out_count;\n\tparse_state->if_count = 0;\n\n\treturn 0;\n}\n\nstatic int\ntc_act_post_parse_vlan(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t       struct mlx5e_priv *priv,\n\t\t       struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tint err;\n\n\tif (MLX5_CAP_GEN(esw->dev, prio_tag_required) &&\n\t    attr->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP) {\n\t\t \n\t\tattr->action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;\n\t\terr = add_vlan_prio_tag_rewrite_action(priv, parse_attr,\n\t\t\t\t\t\t       &attr->action, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstruct mlx5e_tc_act mlx5e_tc_act_vlan = {\n\t.parse_action = tc_act_parse_vlan,\n\t.post_parse = tc_act_post_parse_vlan,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}