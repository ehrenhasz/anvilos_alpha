{
  "module_name": "ipsec.c",
  "hash_id": "d072bd0e81b74d6ab771e33591b337e1a3d23424123513da8e7389b13ac6f5d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/ipsec.c",
  "human_readable_source": "\n\n\n#include <linux/mlx5/device.h>\n#include <linux/mlx5/vport.h>\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n\nstatic int esw_ipsec_vf_query_generic(struct mlx5_core_dev *dev, u16 vport_num, bool *result)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tvoid *hca_cap, *query_cap;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(dev, vhca_resource_manager))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!mlx5_esw_ipsec_vf_offload_supported(dev)) {\n\t\t*result = false;\n\t\treturn 0;\n\t}\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\tif (!query_cap)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_vport_get_other_func_general_cap(dev, vport_num, query_cap);\n\tif (err)\n\t\tgoto free;\n\n\thca_cap = MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability);\n\t*result = MLX5_GET(cmd_hca_cap, hca_cap, ipsec_offload);\nfree:\n\tkvfree(query_cap);\n\treturn err;\n}\n\nenum esw_vport_ipsec_offload {\n\tMLX5_ESW_VPORT_IPSEC_CRYPTO_OFFLOAD,\n\tMLX5_ESW_VPORT_IPSEC_PACKET_OFFLOAD,\n};\n\nint mlx5_esw_ipsec_vf_offload_get(struct mlx5_core_dev *dev, struct mlx5_vport *vport)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tvoid *hca_cap, *query_cap;\n\tbool ipsec_enabled;\n\tint err;\n\n\t \n\terr = esw_ipsec_vf_query_generic(dev, vport->vport, &ipsec_enabled);\n\tif (err)\n\t\treturn err;\n\n\tif (!ipsec_enabled) {\n\t\tvport->info.ipsec_crypto_enabled = false;\n\t\tvport->info.ipsec_packet_enabled = false;\n\t\treturn 0;\n\t}\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\tif (!query_cap)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_vport_get_other_func_cap(dev, vport->vport, query_cap, MLX5_CAP_IPSEC);\n\tif (err)\n\t\tgoto free;\n\n\thca_cap = MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability);\n\tvport->info.ipsec_crypto_enabled =\n\t\tMLX5_GET(ipsec_cap, hca_cap, ipsec_crypto_offload);\n\tvport->info.ipsec_packet_enabled =\n\t\tMLX5_GET(ipsec_cap, hca_cap, ipsec_full_offload);\nfree:\n\tkvfree(query_cap);\n\treturn err;\n}\n\nstatic int esw_ipsec_vf_set_generic(struct mlx5_core_dev *dev, u16 vport_num, bool ipsec_ofld)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tint set_sz = MLX5_ST_SZ_BYTES(set_hca_cap_in);\n\tvoid *hca_cap, *query_cap, *cap;\n\tint ret;\n\n\tif (!MLX5_CAP_GEN(dev, vhca_resource_manager))\n\t\treturn -EOPNOTSUPP;\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\thca_cap = kvzalloc(set_sz, GFP_KERNEL);\n\tif (!hca_cap || !query_cap) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = mlx5_vport_get_other_func_general_cap(dev, vport_num, query_cap);\n\tif (ret)\n\t\tgoto free;\n\n\tcap = MLX5_ADDR_OF(set_hca_cap_in, hca_cap, capability);\n\tmemcpy(cap, MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability),\n\t       MLX5_UN_SZ_BYTES(hca_cap_union));\n\tMLX5_SET(cmd_hca_cap, cap, ipsec_offload, ipsec_ofld);\n\n\tMLX5_SET(set_hca_cap_in, hca_cap, opcode, MLX5_CMD_OP_SET_HCA_CAP);\n\tMLX5_SET(set_hca_cap_in, hca_cap, other_function, 1);\n\tMLX5_SET(set_hca_cap_in, hca_cap, function_id, vport_num);\n\n\tMLX5_SET(set_hca_cap_in, hca_cap, op_mod,\n\t\t MLX5_SET_HCA_CAP_OP_MOD_GENERAL_DEVICE << 1);\n\tret = mlx5_cmd_exec_in(dev, set_hca_cap, hca_cap);\nfree:\n\tkvfree(hca_cap);\n\tkvfree(query_cap);\n\treturn ret;\n}\n\nstatic int esw_ipsec_vf_set_bytype(struct mlx5_core_dev *dev, struct mlx5_vport *vport,\n\t\t\t\t   bool enable, enum esw_vport_ipsec_offload type)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tint set_sz = MLX5_ST_SZ_BYTES(set_hca_cap_in);\n\tvoid *hca_cap, *query_cap, *cap;\n\tint ret;\n\n\tif (!MLX5_CAP_GEN(dev, vhca_resource_manager))\n\t\treturn -EOPNOTSUPP;\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\thca_cap = kvzalloc(set_sz, GFP_KERNEL);\n\tif (!hca_cap || !query_cap) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = mlx5_vport_get_other_func_cap(dev, vport->vport, query_cap, MLX5_CAP_IPSEC);\n\tif (ret)\n\t\tgoto free;\n\n\tcap = MLX5_ADDR_OF(set_hca_cap_in, hca_cap, capability);\n\tmemcpy(cap, MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability),\n\t       MLX5_UN_SZ_BYTES(hca_cap_union));\n\n\tswitch (type) {\n\tcase MLX5_ESW_VPORT_IPSEC_CRYPTO_OFFLOAD:\n\t\tMLX5_SET(ipsec_cap, cap, ipsec_crypto_offload, enable);\n\t\tbreak;\n\tcase MLX5_ESW_VPORT_IPSEC_PACKET_OFFLOAD:\n\t\tMLX5_SET(ipsec_cap, cap, ipsec_full_offload, enable);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free;\n\t}\n\n\tMLX5_SET(set_hca_cap_in, hca_cap, opcode, MLX5_CMD_OP_SET_HCA_CAP);\n\tMLX5_SET(set_hca_cap_in, hca_cap, other_function, 1);\n\tMLX5_SET(set_hca_cap_in, hca_cap, function_id, vport->vport);\n\n\tMLX5_SET(set_hca_cap_in, hca_cap, op_mod,\n\t\t MLX5_SET_HCA_CAP_OP_MOD_IPSEC << 1);\n\tret = mlx5_cmd_exec_in(dev, set_hca_cap, hca_cap);\nfree:\n\tkvfree(hca_cap);\n\tkvfree(query_cap);\n\treturn ret;\n}\n\nstatic int esw_ipsec_vf_crypto_aux_caps_set(struct mlx5_core_dev *dev, u16 vport_num, bool enable)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tint set_sz = MLX5_ST_SZ_BYTES(set_hca_cap_in);\n\tstruct mlx5_eswitch *esw = dev->priv.eswitch;\n\tvoid *hca_cap, *query_cap, *cap;\n\tint ret;\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\thca_cap = kvzalloc(set_sz, GFP_KERNEL);\n\tif (!hca_cap || !query_cap) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = mlx5_vport_get_other_func_cap(dev, vport_num, query_cap, MLX5_CAP_ETHERNET_OFFLOADS);\n\tif (ret)\n\t\tgoto free;\n\n\tcap = MLX5_ADDR_OF(set_hca_cap_in, hca_cap, capability);\n\tmemcpy(cap, MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability),\n\t       MLX5_UN_SZ_BYTES(hca_cap_union));\n\tMLX5_SET(per_protocol_networking_offload_caps, cap, insert_trailer, enable);\n\tMLX5_SET(set_hca_cap_in, hca_cap, opcode, MLX5_CMD_OP_SET_HCA_CAP);\n\tMLX5_SET(set_hca_cap_in, hca_cap, other_function, 1);\n\tMLX5_SET(set_hca_cap_in, hca_cap, function_id, vport_num);\n\tMLX5_SET(set_hca_cap_in, hca_cap, op_mod,\n\t\t MLX5_SET_HCA_CAP_OP_MOD_ETHERNET_OFFLOADS << 1);\n\tret = mlx5_cmd_exec_in(esw->dev, set_hca_cap, hca_cap);\nfree:\n\tkvfree(hca_cap);\n\tkvfree(query_cap);\n\treturn ret;\n}\n\nstatic int esw_ipsec_vf_offload_set_bytype(struct mlx5_eswitch *esw, struct mlx5_vport *vport,\n\t\t\t\t\t   bool enable, enum esw_vport_ipsec_offload type)\n{\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tint err;\n\n\tif (vport->vport == MLX5_VPORT_PF)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == MLX5_ESW_VPORT_IPSEC_CRYPTO_OFFLOAD) {\n\t\terr = esw_ipsec_vf_crypto_aux_caps_set(dev, vport->vport, enable);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (enable) {\n\t\terr = esw_ipsec_vf_set_generic(dev, vport->vport, enable);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esw_ipsec_vf_set_bytype(dev, vport, enable, type);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = esw_ipsec_vf_set_bytype(dev, vport, enable, type);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = mlx5_esw_ipsec_vf_offload_get(dev, vport);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (!vport->info.ipsec_crypto_enabled &&\n\t\t    !vport->info.ipsec_packet_enabled) {\n\t\t\terr = esw_ipsec_vf_set_generic(dev, vport->vport, enable);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase MLX5_ESW_VPORT_IPSEC_CRYPTO_OFFLOAD:\n\t\tvport->info.ipsec_crypto_enabled = enable;\n\t\tbreak;\n\tcase MLX5_ESW_VPORT_IPSEC_PACKET_OFFLOAD:\n\t\tvport->info.ipsec_packet_enabled = enable;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int esw_ipsec_offload_supported(struct mlx5_core_dev *dev, u16 vport_num)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tvoid *hca_cap, *query_cap;\n\tint ret;\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\tif (!query_cap)\n\t\treturn -ENOMEM;\n\n\tret = mlx5_vport_get_other_func_cap(dev, vport_num, query_cap, MLX5_CAP_GENERAL);\n\tif (ret)\n\t\tgoto free;\n\n\thca_cap = MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability);\n\tif (!MLX5_GET(cmd_hca_cap, hca_cap, log_max_dek))\n\t\tret = -EOPNOTSUPP;\nfree:\n\tkvfree(query_cap);\n\treturn ret;\n}\n\nbool mlx5_esw_ipsec_vf_offload_supported(struct mlx5_core_dev *dev)\n{\n\t \n\treturn MLX5_CAP_FLOWTABLE_NIC_TX(dev, reformat_add_esp_trasport);\n}\n\nint mlx5_esw_ipsec_vf_crypto_offload_supported(struct mlx5_core_dev *dev,\n\t\t\t\t\t       u16 vport_num)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tvoid *hca_cap, *query_cap;\n\tint err;\n\n\tif (!mlx5_esw_ipsec_vf_offload_supported(dev))\n\t\treturn -EOPNOTSUPP;\n\n\terr = esw_ipsec_offload_supported(dev, vport_num);\n\tif (err)\n\t\treturn err;\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\tif (!query_cap)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_vport_get_other_func_cap(dev, vport_num, query_cap, MLX5_CAP_ETHERNET_OFFLOADS);\n\tif (err)\n\t\tgoto free;\n\n\thca_cap = MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability);\n\tif (!MLX5_GET(per_protocol_networking_offload_caps, hca_cap, swp))\n\t\tgoto free;\n\nfree:\n\tkvfree(query_cap);\n\treturn err;\n}\n\nint mlx5_esw_ipsec_vf_packet_offload_supported(struct mlx5_core_dev *dev,\n\t\t\t\t\t       u16 vport_num)\n{\n\tint query_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tvoid *hca_cap, *query_cap;\n\tint ret;\n\n\tif (!mlx5_esw_ipsec_vf_offload_supported(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tret = esw_ipsec_offload_supported(dev, vport_num);\n\tif (ret)\n\t\treturn ret;\n\n\tquery_cap = kvzalloc(query_sz, GFP_KERNEL);\n\tif (!query_cap)\n\t\treturn -ENOMEM;\n\n\tret = mlx5_vport_get_other_func_cap(dev, vport_num, query_cap, MLX5_CAP_FLOW_TABLE);\n\tif (ret)\n\t\tgoto out;\n\n\thca_cap = MLX5_ADDR_OF(query_hca_cap_out, query_cap, capability);\n\tif (!MLX5_GET(flow_table_nic_cap, hca_cap, flow_table_properties_nic_receive.decap)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\nout:\n\tkvfree(query_cap);\n\treturn ret;\n}\n\nint mlx5_esw_ipsec_vf_crypto_offload_set(struct mlx5_eswitch *esw, struct mlx5_vport *vport,\n\t\t\t\t\t bool enable)\n{\n\treturn esw_ipsec_vf_offload_set_bytype(esw, vport, enable,\n\t\t\t\t\t       MLX5_ESW_VPORT_IPSEC_CRYPTO_OFFLOAD);\n}\n\nint mlx5_esw_ipsec_vf_packet_offload_set(struct mlx5_eswitch *esw, struct mlx5_vport *vport,\n\t\t\t\t\t bool enable)\n{\n\treturn esw_ipsec_vf_offload_set_bytype(esw, vport, enable,\n\t\t\t\t\t       MLX5_ESW_VPORT_IPSEC_PACKET_OFFLOAD);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}