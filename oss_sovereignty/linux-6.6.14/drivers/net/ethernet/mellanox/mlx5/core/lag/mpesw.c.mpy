{
  "module_name": "mpesw.c",
  "hash_id": "30e805ba364bc9ecd5d41ecf6b5424591edc0dfe99cecaf16e3a2f6581c13830",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <net/nexthop.h>\n#include \"lag/lag.h\"\n#include \"eswitch.h\"\n#include \"esw/acl/ofld.h\"\n#include \"lib/events.h\"\n\nstatic void mlx5_mpesw_metadata_cleanup(struct mlx5_lag *ldev)\n{\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_eswitch *esw;\n\tu32 pf_metadata;\n\tint i;\n\n\tfor (i = 0; i < ldev->ports; i++) {\n\t\tdev = ldev->pf[i].dev;\n\t\tesw = dev->priv.eswitch;\n\t\tpf_metadata = ldev->lag_mpesw.pf_metadata[i];\n\t\tif (!pf_metadata)\n\t\t\tcontinue;\n\t\tmlx5_esw_acl_ingress_vport_metadata_update(esw, MLX5_VPORT_UPLINK, 0);\n\t\tmlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_MULTIPORT_ESW,\n\t\t\t\t\t (void *)0);\n\t\tmlx5_esw_match_metadata_free(esw, pf_metadata);\n\t\tldev->lag_mpesw.pf_metadata[i] = 0;\n\t}\n}\n\nstatic int mlx5_mpesw_metadata_set(struct mlx5_lag *ldev)\n{\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_eswitch *esw;\n\tu32 pf_metadata;\n\tint i, err;\n\n\tfor (i = 0; i < ldev->ports; i++) {\n\t\tdev = ldev->pf[i].dev;\n\t\tesw = dev->priv.eswitch;\n\t\tpf_metadata = mlx5_esw_match_metadata_alloc(esw);\n\t\tif (!pf_metadata) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto err_metadata;\n\t\t}\n\n\t\tldev->lag_mpesw.pf_metadata[i] = pf_metadata;\n\t\terr = mlx5_esw_acl_ingress_vport_metadata_update(esw, MLX5_VPORT_UPLINK,\n\t\t\t\t\t\t\t\t pf_metadata);\n\t\tif (err)\n\t\t\tgoto err_metadata;\n\t}\n\n\tfor (i = 0; i < ldev->ports; i++) {\n\t\tdev = ldev->pf[i].dev;\n\t\tmlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_MULTIPORT_ESW,\n\t\t\t\t\t (void *)0);\n\t}\n\n\treturn 0;\n\nerr_metadata:\n\tmlx5_mpesw_metadata_cleanup(ldev);\n\treturn err;\n}\n\n#define MLX5_LAG_MPESW_OFFLOADS_SUPPORTED_PORTS 2\nstatic int enable_mpesw(struct mlx5_lag *ldev)\n{\n\tstruct mlx5_core_dev *dev0 = ldev->pf[MLX5_LAG_P1].dev;\n\tstruct mlx5_core_dev *dev1 = ldev->pf[MLX5_LAG_P2].dev;\n\tint err;\n\n\tif (ldev->mode != MLX5_LAG_MODE_NONE)\n\t\treturn -EINVAL;\n\n\tif (ldev->ports > MLX5_LAG_MPESW_OFFLOADS_SUPPORTED_PORTS)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mlx5_eswitch_mode(dev0) != MLX5_ESWITCH_OFFLOADS ||\n\t    !MLX5_CAP_PORT_SELECTION(dev0, port_select_flow_table) ||\n\t    !MLX5_CAP_GEN(dev0, create_lag_when_not_master_up) ||\n\t    !mlx5_lag_check_prereq(ldev))\n\t\treturn -EOPNOTSUPP;\n\n\terr = mlx5_mpesw_metadata_set(ldev);\n\tif (err)\n\t\treturn err;\n\n\tmlx5_lag_remove_devices(ldev);\n\n\terr = mlx5_activate_lag(ldev, NULL, MLX5_LAG_MODE_MPESW, true);\n\tif (err) {\n\t\tmlx5_core_warn(dev0, \"Failed to create LAG in MPESW mode (%d)\\n\", err);\n\t\tgoto err_add_devices;\n\t}\n\n\tdev0->priv.flags &= ~MLX5_PRIV_FLAGS_DISABLE_IB_ADEV;\n\tmlx5_rescan_drivers_locked(dev0);\n\terr = mlx5_eswitch_reload_reps(dev0->priv.eswitch);\n\tif (!err)\n\t\terr = mlx5_eswitch_reload_reps(dev1->priv.eswitch);\n\tif (err)\n\t\tgoto err_rescan_drivers;\n\n\treturn 0;\n\nerr_rescan_drivers:\n\tdev0->priv.flags |= MLX5_PRIV_FLAGS_DISABLE_IB_ADEV;\n\tmlx5_rescan_drivers_locked(dev0);\n\tmlx5_deactivate_lag(ldev);\nerr_add_devices:\n\tmlx5_lag_add_devices(ldev);\n\tmlx5_eswitch_reload_reps(dev0->priv.eswitch);\n\tmlx5_eswitch_reload_reps(dev1->priv.eswitch);\n\tmlx5_mpesw_metadata_cleanup(ldev);\n\treturn err;\n}\n\nstatic void disable_mpesw(struct mlx5_lag *ldev)\n{\n\tif (ldev->mode == MLX5_LAG_MODE_MPESW) {\n\t\tmlx5_mpesw_metadata_cleanup(ldev);\n\t\tmlx5_disable_lag(ldev);\n\t}\n}\n\nstatic void mlx5_mpesw_work(struct work_struct *work)\n{\n\tstruct mlx5_mpesw_work_st *mpesww = container_of(work, struct mlx5_mpesw_work_st, work);\n\tstruct mlx5_lag *ldev = mpesww->lag;\n\n\tmlx5_dev_list_lock();\n\tmutex_lock(&ldev->lock);\n\tif (ldev->mode_changes_in_progress) {\n\t\tmpesww->result = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\n\tif (mpesww->op == MLX5_MPESW_OP_ENABLE)\n\t\tmpesww->result = enable_mpesw(ldev);\n\telse if (mpesww->op == MLX5_MPESW_OP_DISABLE)\n\t\tdisable_mpesw(ldev);\nunlock:\n\tmutex_unlock(&ldev->lock);\n\tmlx5_dev_list_unlock();\n\tcomplete(&mpesww->comp);\n}\n\nstatic int mlx5_lag_mpesw_queue_work(struct mlx5_core_dev *dev,\n\t\t\t\t     enum mpesw_op op)\n{\n\tstruct mlx5_lag *ldev = mlx5_lag_dev(dev);\n\tstruct mlx5_mpesw_work_st *work;\n\tint err = 0;\n\n\tif (!ldev)\n\t\treturn 0;\n\n\twork = kzalloc(sizeof(*work), GFP_KERNEL);\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&work->work, mlx5_mpesw_work);\n\tinit_completion(&work->comp);\n\twork->op = op;\n\twork->lag = ldev;\n\n\tif (!queue_work(ldev->wq, &work->work)) {\n\t\tmlx5_core_warn(dev, \"failed to queue mpesw work\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\twait_for_completion(&work->comp);\n\terr = work->result;\nout:\n\tkfree(work);\n\treturn err;\n}\n\nvoid mlx5_lag_mpesw_disable(struct mlx5_core_dev *dev)\n{\n\tmlx5_lag_mpesw_queue_work(dev, MLX5_MPESW_OP_DISABLE);\n}\n\nint mlx5_lag_mpesw_enable(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_lag_mpesw_queue_work(dev, MLX5_MPESW_OP_ENABLE);\n}\n\nint mlx5_lag_mpesw_do_mirred(struct mlx5_core_dev *mdev,\n\t\t\t     struct net_device *out_dev,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_lag *ldev = mlx5_lag_dev(mdev);\n\n\tif (!netif_is_bond_master(out_dev) || !ldev)\n\t\treturn 0;\n\n\tif (ldev->mode != MLX5_LAG_MODE_MPESW)\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_MOD(extack, \"can't forward to bond in mpesw mode\");\n\treturn -EOPNOTSUPP;\n}\n\nbool mlx5_lag_is_mpesw(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_lag *ldev = mlx5_lag_dev(dev);\n\n\treturn ldev && ldev->mode == MLX5_LAG_MODE_MPESW;\n}\nEXPORT_SYMBOL(mlx5_lag_is_mpesw);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}