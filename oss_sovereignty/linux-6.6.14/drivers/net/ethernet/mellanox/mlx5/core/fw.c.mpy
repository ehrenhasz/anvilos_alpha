{
  "module_name": "fw.c",
  "hash_id": "5ed9e0d983d68ac915f3c6e9b7f146188991cedf9b49b8c7a0367cf0fba5a6a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/fw.c",
  "human_readable_source": " \n\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/eswitch.h>\n#include \"mlx5_core.h\"\n#include \"../../mlxfw/mlxfw.h\"\n#include \"lib/tout.h\"\n\nenum {\n\tMCQS_IDENTIFIER_BOOT_IMG\t= 0x1,\n\tMCQS_IDENTIFIER_OEM_NVCONFIG\t= 0x4,\n\tMCQS_IDENTIFIER_MLNX_NVCONFIG\t= 0x5,\n\tMCQS_IDENTIFIER_CS_TOKEN\t= 0x6,\n\tMCQS_IDENTIFIER_DBG_TOKEN\t= 0x7,\n\tMCQS_IDENTIFIER_GEARBOX\t\t= 0xA,\n};\n\nenum {\n\tMCQS_UPDATE_STATE_IDLE,\n\tMCQS_UPDATE_STATE_IN_PROGRESS,\n\tMCQS_UPDATE_STATE_APPLIED,\n\tMCQS_UPDATE_STATE_ACTIVE,\n\tMCQS_UPDATE_STATE_ACTIVE_PENDING_RESET,\n\tMCQS_UPDATE_STATE_FAILED,\n\tMCQS_UPDATE_STATE_CANCELED,\n\tMCQS_UPDATE_STATE_BUSY,\n};\n\nenum {\n\tMCQI_INFO_TYPE_CAPABILITIES\t  = 0x0,\n\tMCQI_INFO_TYPE_VERSION\t\t  = 0x1,\n\tMCQI_INFO_TYPE_ACTIVATION_METHOD  = 0x5,\n};\n\nenum {\n\tMCQI_FW_RUNNING_VERSION = 0,\n\tMCQI_FW_STORED_VERSION  = 1,\n};\n\nint mlx5_query_board_id(struct mlx5_core_dev *dev)\n{\n\tu32 *out;\n\tint outlen = MLX5_ST_SZ_BYTES(query_adapter_out);\n\tu32 in[MLX5_ST_SZ_DW(query_adapter_in)] = {};\n\tint err;\n\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(query_adapter_in, in, opcode, MLX5_CMD_OP_QUERY_ADAPTER);\n\terr = mlx5_cmd_exec_inout(dev, query_adapter, in, out);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(dev->board_id,\n\t       MLX5_ADDR_OF(query_adapter_out, out,\n\t\t\t    query_adapter_struct.vsd_contd_psid),\n\t       MLX5_FLD_SZ_BYTES(query_adapter_out,\n\t\t\t\t query_adapter_struct.vsd_contd_psid));\n\nout:\n\tkfree(out);\n\treturn err;\n}\n\nint mlx5_core_query_vendor_id(struct mlx5_core_dev *mdev, u32 *vendor_id)\n{\n\tu32 *out;\n\tint outlen = MLX5_ST_SZ_BYTES(query_adapter_out);\n\tu32 in[MLX5_ST_SZ_DW(query_adapter_in)] = {};\n\tint err;\n\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(query_adapter_in, in, opcode, MLX5_CMD_OP_QUERY_ADAPTER);\n\terr = mlx5_cmd_exec_inout(mdev, query_adapter, in, out);\n\tif (err)\n\t\tgoto out;\n\n\t*vendor_id = MLX5_GET(query_adapter_out, out,\n\t\t\t      query_adapter_struct.ieee_vendor_id);\nout:\n\tkfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx5_core_query_vendor_id);\n\nstatic int mlx5_get_pcam_reg(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_query_pcam_reg(dev, dev->caps.pcam,\n\t\t\t\t   MLX5_PCAM_FEATURE_ENHANCED_FEATURES,\n\t\t\t\t   MLX5_PCAM_REGS_5000_TO_507F);\n}\n\nstatic int mlx5_get_mcam_access_reg_group(struct mlx5_core_dev *dev,\n\t\t\t\t\t  enum mlx5_mcam_reg_groups group)\n{\n\treturn mlx5_query_mcam_reg(dev, dev->caps.mcam[group],\n\t\t\t\t   MLX5_MCAM_FEATURE_ENHANCED_FEATURES, group);\n}\n\nstatic int mlx5_get_qcam_reg(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_query_qcam_reg(dev, dev->caps.qcam,\n\t\t\t\t   MLX5_QCAM_FEATURE_ENHANCED_FEATURES,\n\t\t\t\t   MLX5_QCAM_REGS_FIRST_128);\n}\n\nint mlx5_query_hca_caps(struct mlx5_core_dev *dev)\n{\n\tint err;\n\n\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_GENERAL, HCA_CAP_OPMOD_GET_CUR);\n\tif (err)\n\t\treturn err;\n\n\tif (MLX5_CAP_GEN(dev, port_selection_cap)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_PORT_SELECTION, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, hca_cap_2)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_GENERAL_2, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, eth_net_offloads)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_ETHERNET_OFFLOADS,\n\t\t\t\t\t      HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, ipoib_enhanced_offloads)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_IPOIB_ENHANCED_OFFLOADS,\n\t\t\t\t\t      HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, pg)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_ODP, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, atomic)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_ATOMIC, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, roce)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_ROCE, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, nic_flow_table) ||\n\t    MLX5_CAP_GEN(dev, ipoib_enhanced_offloads)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_FLOW_TABLE, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_ESWITCH_MANAGER(dev)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_ESWITCH_FLOW_TABLE,\n\t\t\t\t\t      HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_ESWITCH, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, qos)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_QOS, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, debug))\n\t\tmlx5_core_get_caps_mode(dev, MLX5_CAP_DEBUG, HCA_CAP_OPMOD_GET_CUR);\n\n\tif (MLX5_CAP_GEN(dev, pcam_reg))\n\t\tmlx5_get_pcam_reg(dev);\n\n\tif (MLX5_CAP_GEN(dev, mcam_reg)) {\n\t\tmlx5_get_mcam_access_reg_group(dev, MLX5_MCAM_REGS_FIRST_128);\n\t\tmlx5_get_mcam_access_reg_group(dev, MLX5_MCAM_REGS_0x9100_0x917F);\n\t}\n\n\tif (MLX5_CAP_GEN(dev, qcam_reg))\n\t\tmlx5_get_qcam_reg(dev);\n\n\tif (MLX5_CAP_GEN(dev, device_memory)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_DEV_MEM, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, event_cap)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_DEV_EVENT, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, tls_tx) || MLX5_CAP_GEN(dev, tls_rx)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_TLS, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN_64(dev, general_obj_types) &\n\t\tMLX5_GENERAL_OBJ_TYPES_CAP_VIRTIO_NET_Q) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_VDPA_EMULATION, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, ipsec_offload)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_IPSEC, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, crypto)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_CRYPTO, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN_64(dev, general_obj_types) &\n\t    MLX5_GENERAL_OBJ_TYPES_CAP_MACSEC_OFFLOAD) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_MACSEC, HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MLX5_CAP_GEN(dev, adv_virtualization)) {\n\t\terr = mlx5_core_get_caps_mode(dev, MLX5_CAP_ADV_VIRTUALIZATION,\n\t\t\t\t\t      HCA_CAP_OPMOD_GET_CUR);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint mlx5_cmd_init_hca(struct mlx5_core_dev *dev, uint32_t *sw_owner_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(init_hca_in)] = {};\n\tint i;\n\n\tMLX5_SET(init_hca_in, in, opcode, MLX5_CMD_OP_INIT_HCA);\n\n\tif (MLX5_CAP_GEN(dev, sw_owner_id)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tMLX5_ARRAY_SET(init_hca_in, in, sw_owner_id, i,\n\t\t\t\t       sw_owner_id[i]);\n\t}\n\n\tif (MLX5_CAP_GEN_2_MAX(dev, sw_vhca_id_valid) &&\n\t    dev->priv.sw_vhca_id > 0)\n\t\tMLX5_SET(init_hca_in, in, sw_vhca_id, dev->priv.sw_vhca_id);\n\n\treturn mlx5_cmd_exec_in(dev, init_hca, in);\n}\n\nint mlx5_cmd_teardown_hca(struct mlx5_core_dev *dev)\n{\n\tu32 in[MLX5_ST_SZ_DW(teardown_hca_in)] = {};\n\n\tMLX5_SET(teardown_hca_in, in, opcode, MLX5_CMD_OP_TEARDOWN_HCA);\n\treturn mlx5_cmd_exec_in(dev, teardown_hca, in);\n}\n\nint mlx5_cmd_force_teardown_hca(struct mlx5_core_dev *dev)\n{\n\tu32 out[MLX5_ST_SZ_DW(teardown_hca_out)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(teardown_hca_in)] = {0};\n\tint force_state;\n\tint ret;\n\n\tif (!MLX5_CAP_GEN(dev, force_teardown)) {\n\t\tmlx5_core_dbg(dev, \"force teardown is not supported in the firmware\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tMLX5_SET(teardown_hca_in, in, opcode, MLX5_CMD_OP_TEARDOWN_HCA);\n\tMLX5_SET(teardown_hca_in, in, profile, MLX5_TEARDOWN_HCA_IN_PROFILE_FORCE_CLOSE);\n\n\tret = mlx5_cmd_exec_polling(dev, in, sizeof(in), out, sizeof(out));\n\tif (ret)\n\t\treturn ret;\n\n\tforce_state = MLX5_GET(teardown_hca_out, out, state);\n\tif (force_state == MLX5_TEARDOWN_HCA_OUT_FORCE_STATE_FAIL) {\n\t\tmlx5_core_warn(dev, \"teardown with force mode failed, doing normal teardown\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint mlx5_cmd_fast_teardown_hca(struct mlx5_core_dev *dev)\n{\n\tunsigned long end, delay_ms = mlx5_tout_ms(dev, TEARDOWN);\n\tu32 out[MLX5_ST_SZ_DW(teardown_hca_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(teardown_hca_in)] = {};\n\tint state;\n\tint ret;\n\n\tif (!MLX5_CAP_GEN(dev, fast_teardown)) {\n\t\tmlx5_core_dbg(dev, \"fast teardown is not supported in the firmware\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tMLX5_SET(teardown_hca_in, in, opcode, MLX5_CMD_OP_TEARDOWN_HCA);\n\tMLX5_SET(teardown_hca_in, in, profile,\n\t\t MLX5_TEARDOWN_HCA_IN_PROFILE_PREPARE_FAST_TEARDOWN);\n\n\tret = mlx5_cmd_exec_inout(dev, teardown_hca, in, out);\n\tif (ret)\n\t\treturn ret;\n\n\tstate = MLX5_GET(teardown_hca_out, out, state);\n\tif (state == MLX5_TEARDOWN_HCA_OUT_FORCE_STATE_FAIL) {\n\t\tmlx5_core_warn(dev, \"teardown with fast mode failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmlx5_set_nic_state(dev, MLX5_NIC_IFC_DISABLED);\n\n\t \n\tend = jiffies + msecs_to_jiffies(delay_ms);\n\tdo {\n\t\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t} while (!time_after(jiffies, end));\n\n\tif (mlx5_get_nic_state(dev) != MLX5_NIC_IFC_DISABLED) {\n\t\tdev_err(&dev->pdev->dev, \"NIC IFC still %d after %lums.\\n\",\n\t\t\tmlx5_get_nic_state(dev), delay_ms);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nenum mlxsw_reg_mcc_instruction {\n\tMLX5_REG_MCC_INSTRUCTION_LOCK_UPDATE_HANDLE = 0x01,\n\tMLX5_REG_MCC_INSTRUCTION_RELEASE_UPDATE_HANDLE = 0x02,\n\tMLX5_REG_MCC_INSTRUCTION_UPDATE_COMPONENT = 0x03,\n\tMLX5_REG_MCC_INSTRUCTION_VERIFY_COMPONENT = 0x04,\n\tMLX5_REG_MCC_INSTRUCTION_ACTIVATE = 0x06,\n\tMLX5_REG_MCC_INSTRUCTION_CANCEL = 0x08,\n};\n\nstatic int mlx5_reg_mcc_set(struct mlx5_core_dev *dev,\n\t\t\t    enum mlxsw_reg_mcc_instruction instr,\n\t\t\t    u16 component_index, u32 update_handle,\n\t\t\t    u32 component_size)\n{\n\tu32 out[MLX5_ST_SZ_DW(mcc_reg)];\n\tu32 in[MLX5_ST_SZ_DW(mcc_reg)];\n\n\tmemset(in, 0, sizeof(in));\n\n\tMLX5_SET(mcc_reg, in, instruction, instr);\n\tMLX5_SET(mcc_reg, in, component_index, component_index);\n\tMLX5_SET(mcc_reg, in, update_handle, update_handle);\n\tMLX5_SET(mcc_reg, in, component_size, component_size);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t    sizeof(out), MLX5_REG_MCC, 0, 1);\n}\n\nstatic int mlx5_reg_mcc_query(struct mlx5_core_dev *dev,\n\t\t\t      u32 *update_handle, u8 *error_code,\n\t\t\t      u8 *control_state)\n{\n\tu32 out[MLX5_ST_SZ_DW(mcc_reg)];\n\tu32 in[MLX5_ST_SZ_DW(mcc_reg)];\n\tint err;\n\n\tmemset(in, 0, sizeof(in));\n\tmemset(out, 0, sizeof(out));\n\tMLX5_SET(mcc_reg, in, update_handle, *update_handle);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_MCC, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\t*update_handle = MLX5_GET(mcc_reg, out, update_handle);\n\t*error_code = MLX5_GET(mcc_reg, out, error_code);\n\t*control_state = MLX5_GET(mcc_reg, out, control_state);\n\nout:\n\treturn err;\n}\n\nstatic int mlx5_reg_mcda_set(struct mlx5_core_dev *dev,\n\t\t\t     u32 update_handle,\n\t\t\t     u32 offset, u16 size,\n\t\t\t     u8 *data)\n{\n\tint err, in_size = MLX5_ST_SZ_BYTES(mcda_reg) + size;\n\tu32 out[MLX5_ST_SZ_DW(mcda_reg)];\n\tint i, j, dw_size = size >> 2;\n\t__be32 data_element;\n\tu32 *in;\n\n\tin = kzalloc(in_size, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(mcda_reg, in, update_handle, update_handle);\n\tMLX5_SET(mcda_reg, in, offset, offset);\n\tMLX5_SET(mcda_reg, in, size, size);\n\n\tfor (i = 0; i < dw_size; i++) {\n\t\tj = i * 4;\n\t\tdata_element = htonl(*(u32 *)&data[j]);\n\t\tmemcpy(MLX5_ADDR_OF(mcda_reg, in, data) + j, &data_element, 4);\n\t}\n\n\terr = mlx5_core_access_reg(dev, in, in_size, out,\n\t\t\t\t   sizeof(out), MLX5_REG_MCDA, 0, 1);\n\tkfree(in);\n\treturn err;\n}\n\nstatic int mlx5_reg_mcqi_query(struct mlx5_core_dev *dev,\n\t\t\t       u16 component_index, bool read_pending,\n\t\t\t       u8 info_type, u16 data_size, void *mcqi_data)\n{\n\tu32 out[MLX5_ST_SZ_DW(mcqi_reg) + MLX5_UN_SZ_DW(mcqi_reg_data)] = {};\n\tu32 in[MLX5_ST_SZ_DW(mcqi_reg)] = {};\n\tvoid *data;\n\tint err;\n\n\tMLX5_SET(mcqi_reg, in, component_index, component_index);\n\tMLX5_SET(mcqi_reg, in, read_pending_component, read_pending);\n\tMLX5_SET(mcqi_reg, in, info_type, info_type);\n\tMLX5_SET(mcqi_reg, in, data_size, data_size);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   MLX5_ST_SZ_BYTES(mcqi_reg) + data_size,\n\t\t\t\t   MLX5_REG_MCQI, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tdata = MLX5_ADDR_OF(mcqi_reg, out, data);\n\tmemcpy(mcqi_data, data, data_size);\n\n\treturn 0;\n}\n\nstatic int mlx5_reg_mcqi_caps_query(struct mlx5_core_dev *dev, u16 component_index,\n\t\t\t\t    u32 *max_component_size, u8 *log_mcda_word_size,\n\t\t\t\t    u16 *mcda_max_write_size)\n{\n\tu32 mcqi_reg[MLX5_ST_SZ_DW(mcqi_cap)] = {};\n\tint err;\n\n\terr = mlx5_reg_mcqi_query(dev, component_index, 0,\n\t\t\t\t  MCQI_INFO_TYPE_CAPABILITIES,\n\t\t\t\t  MLX5_ST_SZ_BYTES(mcqi_cap), mcqi_reg);\n\tif (err)\n\t\treturn err;\n\n\t*max_component_size = MLX5_GET(mcqi_cap, mcqi_reg, max_component_size);\n\t*log_mcda_word_size = MLX5_GET(mcqi_cap, mcqi_reg, log_mcda_word_size);\n\t*mcda_max_write_size = MLX5_GET(mcqi_cap, mcqi_reg, mcda_max_write_size);\n\n\treturn 0;\n}\n\nstruct mlx5_mlxfw_dev {\n\tstruct mlxfw_dev mlxfw_dev;\n\tstruct mlx5_core_dev *mlx5_core_dev;\n};\n\nstatic int mlx5_component_query(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\tu16 component_index, u32 *p_max_size,\n\t\t\t\tu8 *p_align_bits, u16 *p_max_write_size)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\n\tif (!MLX5_CAP_GEN(dev, mcam_reg) || !MLX5_CAP_MCAM_REG(dev, mcqi)) {\n\t\tmlx5_core_warn(dev, \"caps query isn't supported by running FW\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn mlx5_reg_mcqi_caps_query(dev, component_index, p_max_size,\n\t\t\t\t\tp_align_bits, p_max_write_size);\n}\n\nstatic int mlx5_fsm_lock(struct mlxfw_dev *mlxfw_dev, u32 *fwhandle)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\tu8 control_state, error_code;\n\tint err;\n\n\t*fwhandle = 0;\n\terr = mlx5_reg_mcc_query(dev, fwhandle, &error_code, &control_state);\n\tif (err)\n\t\treturn err;\n\n\tif (control_state != MLXFW_FSM_STATE_IDLE)\n\t\treturn -EBUSY;\n\n\treturn mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_LOCK_UPDATE_HANDLE,\n\t\t\t\t0, *fwhandle, 0);\n}\n\nstatic int mlx5_fsm_component_update(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t     u16 component_index, u32 component_size)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\n\treturn mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_UPDATE_COMPONENT,\n\t\t\t\tcomponent_index, fwhandle, component_size);\n}\n\nstatic int mlx5_fsm_block_download(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t   u8 *data, u16 size, u32 offset)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\n\treturn mlx5_reg_mcda_set(dev, fwhandle, offset, size, data);\n}\n\nstatic int mlx5_fsm_component_verify(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t     u16 component_index)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\n\treturn mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_VERIFY_COMPONENT,\n\t\t\t\tcomponent_index, fwhandle, 0);\n}\n\nstatic int mlx5_fsm_activate(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\n\treturn mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_ACTIVATE,\t0,\n\t\t\t\tfwhandle, 0);\n}\n\nstatic int mlx5_fsm_query_state(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\tenum mlxfw_fsm_state *fsm_state,\n\t\t\t\tenum mlxfw_fsm_state_err *fsm_state_err)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\tu8 control_state, error_code;\n\tint err;\n\n\terr = mlx5_reg_mcc_query(dev, &fwhandle, &error_code, &control_state);\n\tif (err)\n\t\treturn err;\n\n\t*fsm_state = control_state;\n\t*fsm_state_err = min_t(enum mlxfw_fsm_state_err, error_code,\n\t\t\t       MLXFW_FSM_STATE_ERR_MAX);\n\treturn 0;\n}\n\nstatic void mlx5_fsm_cancel(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\n\tmlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_CANCEL, 0, fwhandle, 0);\n}\n\nstatic void mlx5_fsm_release(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\n\tmlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_RELEASE_UPDATE_HANDLE, 0,\n\t\t\t fwhandle, 0);\n}\n\nstatic int mlx5_fsm_reactivate(struct mlxfw_dev *mlxfw_dev, u8 *status)\n{\n\tstruct mlx5_mlxfw_dev *mlx5_mlxfw_dev =\n\t\tcontainer_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);\n\tstruct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;\n\tu32 out[MLX5_ST_SZ_DW(mirc_reg)];\n\tu32 in[MLX5_ST_SZ_DW(mirc_reg)];\n\tunsigned long exp_time;\n\tint err;\n\n\texp_time = jiffies + msecs_to_jiffies(mlx5_tout_ms(dev, FSM_REACTIVATE));\n\n\tif (!MLX5_CAP_MCAM_REG2(dev, mirc))\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(in, 0, sizeof(in));\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_MIRC, 0, 1);\n\tif (err)\n\t\treturn err;\n\n\tdo {\n\t\tmemset(out, 0, sizeof(out));\n\t\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t\t   sizeof(out), MLX5_REG_MIRC, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*status = MLX5_GET(mirc_reg, out, status_code);\n\t\tif (*status != MLXFW_FSM_REACTIVATE_STATUS_BUSY)\n\t\t\treturn 0;\n\n\t\tmsleep(20);\n\t} while (time_before(jiffies, exp_time));\n\n\treturn 0;\n}\n\nstatic const struct mlxfw_dev_ops mlx5_mlxfw_dev_ops = {\n\t.component_query\t= mlx5_component_query,\n\t.fsm_lock\t\t= mlx5_fsm_lock,\n\t.fsm_component_update\t= mlx5_fsm_component_update,\n\t.fsm_block_download\t= mlx5_fsm_block_download,\n\t.fsm_component_verify\t= mlx5_fsm_component_verify,\n\t.fsm_activate\t\t= mlx5_fsm_activate,\n\t.fsm_reactivate\t\t= mlx5_fsm_reactivate,\n\t.fsm_query_state\t= mlx5_fsm_query_state,\n\t.fsm_cancel\t\t= mlx5_fsm_cancel,\n\t.fsm_release\t\t= mlx5_fsm_release\n};\n\nint mlx5_firmware_flash(struct mlx5_core_dev *dev,\n\t\t\tconst struct firmware *firmware,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx5_mlxfw_dev mlx5_mlxfw_dev = {\n\t\t.mlxfw_dev = {\n\t\t\t.ops = &mlx5_mlxfw_dev_ops,\n\t\t\t.psid = dev->board_id,\n\t\t\t.psid_size = strlen(dev->board_id),\n\t\t\t.devlink = priv_to_devlink(dev),\n\t\t},\n\t\t.mlx5_core_dev = dev\n\t};\n\n\tif (!MLX5_CAP_GEN(dev, mcam_reg)  ||\n\t    !MLX5_CAP_MCAM_REG(dev, mcqi) ||\n\t    !MLX5_CAP_MCAM_REG(dev, mcc)  ||\n\t    !MLX5_CAP_MCAM_REG(dev, mcda)) {\n\t\tpr_info(\"%s flashing isn't supported by the running FW\\n\", __func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn mlxfw_firmware_flash(&mlx5_mlxfw_dev.mlxfw_dev,\n\t\t\t\t    firmware, extack);\n}\n\nstatic int mlx5_reg_mcqi_version_query(struct mlx5_core_dev *dev,\n\t\t\t\t       u16 component_index, bool read_pending,\n\t\t\t\t       u32 *mcqi_version_out)\n{\n\treturn mlx5_reg_mcqi_query(dev, component_index, read_pending,\n\t\t\t\t   MCQI_INFO_TYPE_VERSION,\n\t\t\t\t   MLX5_ST_SZ_BYTES(mcqi_version),\n\t\t\t\t   mcqi_version_out);\n}\n\nstatic int mlx5_reg_mcqs_query(struct mlx5_core_dev *dev, u32 *out,\n\t\t\t       u16 component_index)\n{\n\tu8 out_sz = MLX5_ST_SZ_BYTES(mcqs_reg);\n\tu32 in[MLX5_ST_SZ_DW(mcqs_reg)] = {};\n\tint err;\n\n\tmemset(out, 0, out_sz);\n\n\tMLX5_SET(mcqs_reg, in, component_index, component_index);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t   out_sz, MLX5_REG_MCQS, 0, 0);\n\treturn err;\n}\n\n \nstatic int mlx5_get_boot_img_component_index(struct mlx5_core_dev *dev)\n{\n\tu32 out[MLX5_ST_SZ_DW(mcqs_reg)] = {};\n\tu16 identifier, component_idx = 0;\n\tbool quit;\n\tint err;\n\n\tdo {\n\t\terr = mlx5_reg_mcqs_query(dev, out, component_idx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tidentifier = MLX5_GET(mcqs_reg, out, identifier);\n\t\tquit = !!MLX5_GET(mcqs_reg, out, last_index_flag);\n\t\tquit |= identifier == MCQS_IDENTIFIER_BOOT_IMG;\n\t} while (!quit && ++component_idx);\n\n\tif (identifier != MCQS_IDENTIFIER_BOOT_IMG) {\n\t\tmlx5_core_warn(dev, \"mcqs: can't find boot_img component ix, last scanned idx %d\\n\",\n\t\t\t       component_idx);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn component_idx;\n}\n\nstatic int\nmlx5_fw_image_pending(struct mlx5_core_dev *dev,\n\t\t      int component_index,\n\t\t      bool *pending_version_exists)\n{\n\tu32 out[MLX5_ST_SZ_DW(mcqs_reg)];\n\tu8 component_update_state;\n\tint err;\n\n\terr = mlx5_reg_mcqs_query(dev, out, component_index);\n\tif (err)\n\t\treturn err;\n\n\tcomponent_update_state = MLX5_GET(mcqs_reg, out, component_update_state);\n\n\tif (component_update_state == MCQS_UPDATE_STATE_IDLE) {\n\t\t*pending_version_exists = false;\n\t} else if (component_update_state == MCQS_UPDATE_STATE_ACTIVE_PENDING_RESET) {\n\t\t*pending_version_exists = true;\n\t} else {\n\t\tmlx5_core_warn(dev,\n\t\t\t       \"mcqs: can't read pending fw version while fw state is %d\\n\",\n\t\t\t       component_update_state);\n\t\treturn -ENODATA;\n\t}\n\treturn 0;\n}\n\nint mlx5_fw_version_query(struct mlx5_core_dev *dev,\n\t\t\t  u32 *running_ver, u32 *pending_ver)\n{\n\tu32 reg_mcqi_version[MLX5_ST_SZ_DW(mcqi_version)] = {};\n\tbool pending_version_exists;\n\tint component_index;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(dev, mcam_reg) || !MLX5_CAP_MCAM_REG(dev, mcqi) ||\n\t    !MLX5_CAP_MCAM_REG(dev, mcqs)) {\n\t\tmlx5_core_warn(dev, \"fw query isn't supported by the FW\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcomponent_index = mlx5_get_boot_img_component_index(dev);\n\tif (component_index < 0)\n\t\treturn component_index;\n\n\terr = mlx5_reg_mcqi_version_query(dev, component_index,\n\t\t\t\t\t  MCQI_FW_RUNNING_VERSION,\n\t\t\t\t\t  reg_mcqi_version);\n\tif (err)\n\t\treturn err;\n\n\t*running_ver = MLX5_GET(mcqi_version, reg_mcqi_version, version);\n\n\terr = mlx5_fw_image_pending(dev, component_index, &pending_version_exists);\n\tif (err)\n\t\treturn err;\n\n\tif (!pending_version_exists) {\n\t\t*pending_ver = 0;\n\t\treturn 0;\n\t}\n\n\terr = mlx5_reg_mcqi_version_query(dev, component_index,\n\t\t\t\t\t  MCQI_FW_STORED_VERSION,\n\t\t\t\t\t  reg_mcqi_version);\n\tif (err)\n\t\treturn err;\n\n\t*pending_ver = MLX5_GET(mcqi_version, reg_mcqi_version, version);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}