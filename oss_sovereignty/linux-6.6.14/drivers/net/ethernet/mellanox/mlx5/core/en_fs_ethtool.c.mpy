{
  "module_name": "en_fs_ethtool.c",
  "hash_id": "75007ccabaebc5b4d2ffe7a1d9493ecde224201551c2cbc11d91ac52381d56fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c",
  "human_readable_source": " \n\n#include <linux/mlx5/fs.h>\n#include \"en.h\"\n#include \"en/params.h\"\n#include \"en/xsk/pool.h\"\n#include \"en/fs_ethtool.h\"\n\nstruct mlx5e_ethtool_table {\n\tstruct mlx5_flow_table *ft;\n\tint                    num_rules;\n};\n\n#define ETHTOOL_NUM_L3_L4_FTS 7\n#define ETHTOOL_NUM_L2_FTS 4\n\nstruct mlx5e_ethtool_steering {\n\tstruct mlx5e_ethtool_table      l3_l4_ft[ETHTOOL_NUM_L3_L4_FTS];\n\tstruct mlx5e_ethtool_table      l2_ft[ETHTOOL_NUM_L2_FTS];\n\tstruct list_head                rules;\n\tint                             tot_num_rules;\n};\n\nstatic int flow_type_to_traffic_type(u32 flow_type);\n\nstatic u32 flow_type_mask(u32 flow_type)\n{\n\treturn flow_type & ~(FLOW_EXT | FLOW_MAC_EXT | FLOW_RSS);\n}\n\nstruct mlx5e_ethtool_rule {\n\tstruct list_head             list;\n\tstruct ethtool_rx_flow_spec  flow_spec;\n\tstruct mlx5_flow_handle\t     *rule;\n\tstruct mlx5e_ethtool_table   *eth_ft;\n\tstruct mlx5e_rss             *rss;\n};\n\nstatic void put_flow_table(struct mlx5e_ethtool_table *eth_ft)\n{\n\tif (!--eth_ft->num_rules) {\n\t\tmlx5_destroy_flow_table(eth_ft->ft);\n\t\teth_ft->ft = NULL;\n\t}\n}\n\n#define MLX5E_ETHTOOL_L3_L4_PRIO 0\n#define MLX5E_ETHTOOL_L2_PRIO (MLX5E_ETHTOOL_L3_L4_PRIO + ETHTOOL_NUM_L3_L4_FTS)\n#define MLX5E_ETHTOOL_NUM_ENTRIES 64000\n#define MLX5E_ETHTOOL_NUM_GROUPS  10\nstatic struct mlx5e_ethtool_table *get_flow_table(struct mlx5e_priv *priv,\n\t\t\t\t\t\t  struct ethtool_rx_flow_spec *fs,\n\t\t\t\t\t\t  int num_tuples)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(priv->fs);\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5e_ethtool_table *eth_ft;\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_table *ft;\n\tint max_tuples;\n\tint table_size;\n\tint prio;\n\n\tswitch (flow_type_mask(fs->flow_type)) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase IP_USER_FLOW:\n\tcase IPV6_USER_FLOW:\n\t\tmax_tuples = ETHTOOL_NUM_L3_L4_FTS;\n\t\tprio = MLX5E_ETHTOOL_L3_L4_PRIO + (max_tuples - num_tuples);\n\t\teth_ft = &ethtool->l3_l4_ft[prio];\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\tmax_tuples = ETHTOOL_NUM_L2_FTS;\n\t\tprio = max_tuples - num_tuples;\n\t\teth_ft = &ethtool->l2_ft[prio];\n\t\tprio += MLX5E_ETHTOOL_L2_PRIO;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\teth_ft->num_rules++;\n\tif (eth_ft->ft)\n\t\treturn eth_ft;\n\n\tns = mlx5_get_flow_namespace(priv->mdev,\n\t\t\t\t     MLX5_FLOW_NAMESPACE_ETHTOOL);\n\tif (!ns)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\ttable_size = min_t(u32, BIT(MLX5_CAP_FLOWTABLE(priv->mdev,\n\t\t\t\t\t\t       flow_table_properties_nic_receive.log_max_ft_size)),\n\t\t\t   MLX5E_ETHTOOL_NUM_ENTRIES);\n\n\tft_attr.prio = prio;\n\tft_attr.max_fte = table_size;\n\tft_attr.autogroup.max_num_groups = MLX5E_ETHTOOL_NUM_GROUPS;\n\tft = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft))\n\t\treturn (void *)ft;\n\n\teth_ft->ft = ft;\n\treturn eth_ft;\n}\n\nstatic void mask_spec(u8 *mask, u8 *val, size_t size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++, mask++, val++)\n\t\t*((u8 *)val) = *((u8 *)mask) & *((u8 *)val);\n}\n\n#define MLX5E_FTE_SET(header_p, fld, v)  \\\n\tMLX5_SET(fte_match_set_lyr_2_4, header_p, fld, v)\n\n#define MLX5E_FTE_ADDR_OF(header_p, fld) \\\n\tMLX5_ADDR_OF(fte_match_set_lyr_2_4, header_p, fld)\n\nstatic void\nset_ip4(void *headers_c, void *headers_v, __be32 ip4src_m,\n\t__be32 ip4src_v, __be32 ip4dst_m, __be32 ip4dst_v)\n{\n\tif (ip4src_m) {\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_v, src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &ip4src_v, sizeof(ip4src_v));\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_c, src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &ip4src_m, sizeof(ip4src_m));\n\t}\n\tif (ip4dst_m) {\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_v, dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &ip4dst_v, sizeof(ip4dst_v));\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_c, dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &ip4dst_m, sizeof(ip4dst_m));\n\t}\n\n\tMLX5E_FTE_SET(headers_c, ethertype, 0xffff);\n\tMLX5E_FTE_SET(headers_v, ethertype, ETH_P_IP);\n}\n\nstatic void\nset_ip6(void *headers_c, void *headers_v, __be32 ip6src_m[4],\n\t__be32 ip6src_v[4], __be32 ip6dst_m[4], __be32 ip6dst_v[4])\n{\n\tu8 ip6_sz = MLX5_FLD_SZ_BYTES(ipv6_layout, ipv6);\n\n\tif (!ipv6_addr_any((struct in6_addr *)ip6src_m)) {\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_v, src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       ip6src_v, ip6_sz);\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_c, src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       ip6src_m, ip6_sz);\n\t}\n\tif (!ipv6_addr_any((struct in6_addr *)ip6dst_m)) {\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_v, dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       ip6dst_v, ip6_sz);\n\t\tmemcpy(MLX5E_FTE_ADDR_OF(headers_c, dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       ip6dst_m, ip6_sz);\n\t}\n\n\tMLX5E_FTE_SET(headers_c, ethertype, 0xffff);\n\tMLX5E_FTE_SET(headers_v, ethertype, ETH_P_IPV6);\n}\n\nstatic void\nset_tcp(void *headers_c, void *headers_v, __be16 psrc_m, __be16 psrc_v,\n\t__be16 pdst_m, __be16 pdst_v)\n{\n\tif (psrc_m) {\n\t\tMLX5E_FTE_SET(headers_c, tcp_sport, ntohs(psrc_m));\n\t\tMLX5E_FTE_SET(headers_v, tcp_sport, ntohs(psrc_v));\n\t}\n\tif (pdst_m) {\n\t\tMLX5E_FTE_SET(headers_c, tcp_dport, ntohs(pdst_m));\n\t\tMLX5E_FTE_SET(headers_v, tcp_dport, ntohs(pdst_v));\n\t}\n\n\tMLX5E_FTE_SET(headers_c, ip_protocol, 0xffff);\n\tMLX5E_FTE_SET(headers_v, ip_protocol, IPPROTO_TCP);\n}\n\nstatic void\nset_udp(void *headers_c, void *headers_v, __be16 psrc_m, __be16 psrc_v,\n\t__be16 pdst_m, __be16 pdst_v)\n{\n\tif (psrc_m) {\n\t\tMLX5E_FTE_SET(headers_c, udp_sport, ntohs(psrc_m));\n\t\tMLX5E_FTE_SET(headers_v, udp_sport, ntohs(psrc_v));\n\t}\n\n\tif (pdst_m) {\n\t\tMLX5E_FTE_SET(headers_c, udp_dport, ntohs(pdst_m));\n\t\tMLX5E_FTE_SET(headers_v, udp_dport, ntohs(pdst_v));\n\t}\n\n\tMLX5E_FTE_SET(headers_c, ip_protocol, 0xffff);\n\tMLX5E_FTE_SET(headers_v, ip_protocol, IPPROTO_UDP);\n}\n\nstatic void\nparse_tcp4(void *headers_c, void *headers_v, struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_tcpip4_spec *l4_mask = &fs->m_u.tcp_ip4_spec;\n\tstruct ethtool_tcpip4_spec *l4_val  = &fs->h_u.tcp_ip4_spec;\n\n\tset_ip4(headers_c, headers_v, l4_mask->ip4src, l4_val->ip4src,\n\t\tl4_mask->ip4dst, l4_val->ip4dst);\n\n\tset_tcp(headers_c, headers_v, l4_mask->psrc, l4_val->psrc,\n\t\tl4_mask->pdst, l4_val->pdst);\n}\n\nstatic void\nparse_udp4(void *headers_c, void *headers_v, struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_tcpip4_spec *l4_mask = &fs->m_u.udp_ip4_spec;\n\tstruct ethtool_tcpip4_spec *l4_val  = &fs->h_u.udp_ip4_spec;\n\n\tset_ip4(headers_c, headers_v, l4_mask->ip4src, l4_val->ip4src,\n\t\tl4_mask->ip4dst, l4_val->ip4dst);\n\n\tset_udp(headers_c, headers_v, l4_mask->psrc, l4_val->psrc,\n\t\tl4_mask->pdst, l4_val->pdst);\n}\n\nstatic void\nparse_ip4(void *headers_c, void *headers_v, struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_usrip4_spec *l3_mask = &fs->m_u.usr_ip4_spec;\n\tstruct ethtool_usrip4_spec *l3_val  = &fs->h_u.usr_ip4_spec;\n\n\tset_ip4(headers_c, headers_v, l3_mask->ip4src, l3_val->ip4src,\n\t\tl3_mask->ip4dst, l3_val->ip4dst);\n\n\tif (l3_mask->proto) {\n\t\tMLX5E_FTE_SET(headers_c, ip_protocol, l3_mask->proto);\n\t\tMLX5E_FTE_SET(headers_v, ip_protocol, l3_val->proto);\n\t}\n}\n\nstatic void\nparse_ip6(void *headers_c, void *headers_v, struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_usrip6_spec *l3_mask = &fs->m_u.usr_ip6_spec;\n\tstruct ethtool_usrip6_spec *l3_val  = &fs->h_u.usr_ip6_spec;\n\n\tset_ip6(headers_c, headers_v, l3_mask->ip6src,\n\t\tl3_val->ip6src, l3_mask->ip6dst, l3_val->ip6dst);\n\n\tif (l3_mask->l4_proto) {\n\t\tMLX5E_FTE_SET(headers_c, ip_protocol, l3_mask->l4_proto);\n\t\tMLX5E_FTE_SET(headers_v, ip_protocol, l3_val->l4_proto);\n\t}\n}\n\nstatic void\nparse_tcp6(void *headers_c, void *headers_v, struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_tcpip6_spec *l4_mask = &fs->m_u.tcp_ip6_spec;\n\tstruct ethtool_tcpip6_spec *l4_val  = &fs->h_u.tcp_ip6_spec;\n\n\tset_ip6(headers_c, headers_v, l4_mask->ip6src,\n\t\tl4_val->ip6src, l4_mask->ip6dst, l4_val->ip6dst);\n\n\tset_tcp(headers_c, headers_v, l4_mask->psrc, l4_val->psrc,\n\t\tl4_mask->pdst, l4_val->pdst);\n}\n\nstatic void\nparse_udp6(void *headers_c, void *headers_v, struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_tcpip6_spec *l4_mask = &fs->m_u.udp_ip6_spec;\n\tstruct ethtool_tcpip6_spec *l4_val  = &fs->h_u.udp_ip6_spec;\n\n\tset_ip6(headers_c, headers_v, l4_mask->ip6src,\n\t\tl4_val->ip6src, l4_mask->ip6dst, l4_val->ip6dst);\n\n\tset_udp(headers_c, headers_v, l4_mask->psrc, l4_val->psrc,\n\t\tl4_mask->pdst, l4_val->pdst);\n}\n\nstatic void\nparse_ether(void *headers_c, void *headers_v, struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethhdr *eth_mask = &fs->m_u.ether_spec;\n\tstruct ethhdr *eth_val = &fs->h_u.ether_spec;\n\n\tmask_spec((u8 *)eth_mask, (u8 *)eth_val, sizeof(*eth_mask));\n\tether_addr_copy(MLX5E_FTE_ADDR_OF(headers_c, smac_47_16), eth_mask->h_source);\n\tether_addr_copy(MLX5E_FTE_ADDR_OF(headers_v, smac_47_16), eth_val->h_source);\n\tether_addr_copy(MLX5E_FTE_ADDR_OF(headers_c, dmac_47_16), eth_mask->h_dest);\n\tether_addr_copy(MLX5E_FTE_ADDR_OF(headers_v, dmac_47_16), eth_val->h_dest);\n\tMLX5E_FTE_SET(headers_c, ethertype, ntohs(eth_mask->h_proto));\n\tMLX5E_FTE_SET(headers_v, ethertype, ntohs(eth_val->h_proto));\n}\n\nstatic void\nset_cvlan(void *headers_c, void *headers_v, __be16 vlan_tci)\n{\n\tMLX5E_FTE_SET(headers_c, cvlan_tag, 1);\n\tMLX5E_FTE_SET(headers_v, cvlan_tag, 1);\n\tMLX5E_FTE_SET(headers_c, first_vid, 0xfff);\n\tMLX5E_FTE_SET(headers_v, first_vid, ntohs(vlan_tci));\n}\n\nstatic void\nset_dmac(void *headers_c, void *headers_v,\n\t unsigned char m_dest[ETH_ALEN], unsigned char v_dest[ETH_ALEN])\n{\n\tether_addr_copy(MLX5E_FTE_ADDR_OF(headers_c, dmac_47_16), m_dest);\n\tether_addr_copy(MLX5E_FTE_ADDR_OF(headers_v, dmac_47_16), v_dest);\n}\n\nstatic int set_flow_attrs(u32 *match_c, u32 *match_v,\n\t\t\t  struct ethtool_rx_flow_spec *fs)\n{\n\tvoid *outer_headers_c = MLX5_ADDR_OF(fte_match_param, match_c,\n\t\t\t\t\t     outer_headers);\n\tvoid *outer_headers_v = MLX5_ADDR_OF(fte_match_param, match_v,\n\t\t\t\t\t     outer_headers);\n\tu32 flow_type = flow_type_mask(fs->flow_type);\n\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tparse_tcp4(outer_headers_c, outer_headers_v, fs);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tparse_udp4(outer_headers_c, outer_headers_v, fs);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tparse_ip4(outer_headers_c, outer_headers_v, fs);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tparse_tcp6(outer_headers_c, outer_headers_v, fs);\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tparse_udp6(outer_headers_c, outer_headers_v, fs);\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tparse_ip6(outer_headers_c, outer_headers_v, fs);\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\tparse_ether(outer_headers_c, outer_headers_v, fs);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((fs->flow_type & FLOW_EXT) &&\n\t    (fs->m_ext.vlan_tci & cpu_to_be16(VLAN_VID_MASK)))\n\t\tset_cvlan(outer_headers_c, outer_headers_v, fs->h_ext.vlan_tci);\n\n\tif (fs->flow_type & FLOW_MAC_EXT &&\n\t    !is_zero_ether_addr(fs->m_ext.h_dest)) {\n\t\tmask_spec(fs->m_ext.h_dest, fs->h_ext.h_dest, ETH_ALEN);\n\t\tset_dmac(outer_headers_c, outer_headers_v, fs->m_ext.h_dest,\n\t\t\t fs->h_ext.h_dest);\n\t}\n\n\treturn 0;\n}\n\nstatic void add_rule_to_list(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5e_ethtool_rule *rule)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(priv->fs);\n\tstruct list_head *head = &ethtool->rules;\n\tstruct mlx5e_ethtool_rule *iter;\n\n\tlist_for_each_entry(iter, &ethtool->rules, list) {\n\t\tif (iter->flow_spec.location > rule->flow_spec.location)\n\t\t\tbreak;\n\t\thead = &iter->list;\n\t}\n\tethtool->tot_num_rules++;\n\tlist_add(&rule->list, head);\n}\n\nstatic bool outer_header_zero(u32 *match_criteria)\n{\n\tint size = MLX5_FLD_SZ_BYTES(fte_match_param, outer_headers);\n\tchar *outer_headers_c = MLX5_ADDR_OF(fte_match_param, match_criteria,\n\t\t\t\t\t     outer_headers);\n\n\treturn outer_headers_c[0] == 0 && !memcmp(outer_headers_c,\n\t\t\t\t\t\t  outer_headers_c + 1,\n\t\t\t\t\t\t  size - 1);\n}\n\nstatic int flow_get_tirn(struct mlx5e_priv *priv,\n\t\t\t struct mlx5e_ethtool_rule *eth_rule,\n\t\t\t struct ethtool_rx_flow_spec *fs,\n\t\t\t u32 rss_context, u32 *tirn)\n{\n\tif (fs->flow_type & FLOW_RSS) {\n\t\tstruct mlx5e_packet_merge_param pkt_merge_param;\n\t\tstruct mlx5e_rss *rss;\n\t\tu32 flow_type;\n\t\tint err;\n\t\tint tt;\n\n\t\trss = mlx5e_rx_res_rss_get(priv->rx_res, rss_context);\n\t\tif (!rss)\n\t\t\treturn -ENOENT;\n\n\t\tflow_type = flow_type_mask(fs->flow_type);\n\t\ttt = flow_type_to_traffic_type(flow_type);\n\t\tif (tt < 0)\n\t\t\treturn -EINVAL;\n\n\t\tpkt_merge_param = priv->channels.params.packet_merge;\n\t\terr = mlx5e_rss_obtain_tirn(rss, tt, &pkt_merge_param, false, tirn);\n\t\tif (err)\n\t\t\treturn err;\n\t\teth_rule->rss = rss;\n\t\tmlx5e_rss_refcnt_inc(eth_rule->rss);\n\t} else {\n\t\t*tirn = mlx5e_rx_res_get_tirn_direct(priv->rx_res, fs->ring_cookie);\n\t}\n\n\treturn 0;\n}\n\nstatic struct mlx5_flow_handle *\nadd_ethtool_flow_rule(struct mlx5e_priv *priv,\n\t\t      struct mlx5e_ethtool_rule *eth_rule,\n\t\t      struct mlx5_flow_table *ft,\n\t\t      struct ethtool_rx_flow_spec *fs, u32 rss_context)\n{\n\tstruct mlx5_flow_act flow_act = { .flags = FLOW_ACT_NO_APPEND };\n\tstruct mlx5_flow_destination *dst = NULL;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = set_flow_attrs(spec->match_criteria, spec->match_value,\n\t\t\t     fs);\n\tif (err)\n\t\tgoto free;\n\n\tif (fs->ring_cookie == RX_CLS_FLOW_DISC) {\n\t\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;\n\t} else {\n\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\tif (!dst) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\n\t\terr = flow_get_tirn(priv, eth_rule, fs, rss_context, &dst->tir_num);\n\t\tif (err)\n\t\t\tgoto free;\n\n\t\tdst->type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\t\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t}\n\n\tspec->match_criteria_enable = (!outer_header_zero(spec->match_criteria));\n\tspec->flow_context.flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, dst, dst ? 1 : 0);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tnetdev_err(priv->netdev, \"%s: failed to add ethtool steering rule: %d\\n\",\n\t\t\t   __func__, err);\n\t\tgoto free;\n\t}\nfree:\n\tkvfree(spec);\n\tkfree(dst);\n\treturn err ? ERR_PTR(err) : rule;\n}\n\nstatic void del_ethtool_rule(struct mlx5e_flow_steering *fs,\n\t\t\t     struct mlx5e_ethtool_rule *eth_rule)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(fs);\n\tif (eth_rule->rule)\n\t\tmlx5_del_flow_rules(eth_rule->rule);\n\tif (eth_rule->rss)\n\t\tmlx5e_rss_refcnt_dec(eth_rule->rss);\n\tlist_del(&eth_rule->list);\n\tethtool->tot_num_rules--;\n\tput_flow_table(eth_rule->eth_ft);\n\tkfree(eth_rule);\n}\n\nstatic struct mlx5e_ethtool_rule *find_ethtool_rule(struct mlx5e_priv *priv,\n\t\t\t\t\t\t    int location)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(priv->fs);\n\tstruct mlx5e_ethtool_rule *iter;\n\n\tlist_for_each_entry(iter, &ethtool->rules, list) {\n\t\tif (iter->flow_spec.location == location)\n\t\t\treturn iter;\n\t}\n\treturn NULL;\n}\n\nstatic struct mlx5e_ethtool_rule *get_ethtool_rule(struct mlx5e_priv *priv,\n\t\t\t\t\t\t   int location)\n{\n\tstruct mlx5e_ethtool_rule *eth_rule;\n\n\teth_rule = find_ethtool_rule(priv, location);\n\tif (eth_rule)\n\t\tdel_ethtool_rule(priv->fs, eth_rule);\n\n\teth_rule = kzalloc(sizeof(*eth_rule), GFP_KERNEL);\n\tif (!eth_rule)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadd_rule_to_list(priv, eth_rule);\n\treturn eth_rule;\n}\n\n#define MAX_NUM_OF_ETHTOOL_RULES BIT(10)\n\n#define all_ones(field) (field == (__force typeof(field))-1)\n#define all_zeros_or_all_ones(field)\t\t\\\n\t((field) == 0 || (field) == (__force typeof(field))-1)\n\nstatic int validate_ethter(struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethhdr *eth_mask = &fs->m_u.ether_spec;\n\tint ntuples = 0;\n\n\tif (!is_zero_ether_addr(eth_mask->h_dest))\n\t\tntuples++;\n\tif (!is_zero_ether_addr(eth_mask->h_source))\n\t\tntuples++;\n\tif (eth_mask->h_proto)\n\t\tntuples++;\n\treturn ntuples;\n}\n\nstatic int validate_tcpudp4(struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_tcpip4_spec *l4_mask = &fs->m_u.tcp_ip4_spec;\n\tint ntuples = 0;\n\n\tif (l4_mask->tos)\n\t\treturn -EINVAL;\n\n\tif (l4_mask->ip4src)\n\t\tntuples++;\n\tif (l4_mask->ip4dst)\n\t\tntuples++;\n\tif (l4_mask->psrc)\n\t\tntuples++;\n\tif (l4_mask->pdst)\n\t\tntuples++;\n\t \n\treturn ++ntuples;\n}\n\nstatic int validate_ip4(struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_usrip4_spec *l3_mask = &fs->m_u.usr_ip4_spec;\n\tint ntuples = 0;\n\n\tif (l3_mask->l4_4_bytes || l3_mask->tos ||\n\t    fs->h_u.usr_ip4_spec.ip_ver != ETH_RX_NFC_IP4)\n\t\treturn -EINVAL;\n\tif (l3_mask->ip4src)\n\t\tntuples++;\n\tif (l3_mask->ip4dst)\n\t\tntuples++;\n\tif (l3_mask->proto)\n\t\tntuples++;\n\t \n\treturn ++ntuples;\n}\n\nstatic int validate_ip6(struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_usrip6_spec *l3_mask = &fs->m_u.usr_ip6_spec;\n\tint ntuples = 0;\n\n\tif (l3_mask->l4_4_bytes || l3_mask->tclass)\n\t\treturn -EINVAL;\n\tif (!ipv6_addr_any((struct in6_addr *)l3_mask->ip6src))\n\t\tntuples++;\n\n\tif (!ipv6_addr_any((struct in6_addr *)l3_mask->ip6dst))\n\t\tntuples++;\n\tif (l3_mask->l4_proto)\n\t\tntuples++;\n\t \n\treturn ++ntuples;\n}\n\nstatic int validate_tcpudp6(struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethtool_tcpip6_spec *l4_mask = &fs->m_u.tcp_ip6_spec;\n\tint ntuples = 0;\n\n\tif (l4_mask->tclass)\n\t\treturn -EINVAL;\n\n\tif (!ipv6_addr_any((struct in6_addr *)l4_mask->ip6src))\n\t\tntuples++;\n\n\tif (!ipv6_addr_any((struct in6_addr *)l4_mask->ip6dst))\n\t\tntuples++;\n\n\tif (l4_mask->psrc)\n\t\tntuples++;\n\tif (l4_mask->pdst)\n\t\tntuples++;\n\t \n\treturn ++ntuples;\n}\n\nstatic int validate_vlan(struct ethtool_rx_flow_spec *fs)\n{\n\tif (fs->m_ext.vlan_etype ||\n\t    fs->m_ext.vlan_tci != cpu_to_be16(VLAN_VID_MASK))\n\t\treturn -EINVAL;\n\n\tif (fs->m_ext.vlan_tci &&\n\t    (be16_to_cpu(fs->h_ext.vlan_tci) >= VLAN_N_VID))\n\t\treturn -EINVAL;\n\n\treturn 1;\n}\n\nstatic int validate_flow(struct mlx5e_priv *priv,\n\t\t\t struct ethtool_rx_flow_spec *fs)\n{\n\tint num_tuples = 0;\n\tint ret = 0;\n\n\tif (fs->location >= MAX_NUM_OF_ETHTOOL_RULES)\n\t\treturn -ENOSPC;\n\n\tif (fs->ring_cookie != RX_CLS_FLOW_DISC)\n\t\tif (fs->ring_cookie >= priv->channels.params.num_channels)\n\t\t\treturn -EINVAL;\n\n\tswitch (flow_type_mask(fs->flow_type)) {\n\tcase ETHER_FLOW:\n\t\tnum_tuples += validate_ethter(fs);\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\tret = validate_tcpudp4(fs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnum_tuples += ret;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tret = validate_ip4(fs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnum_tuples += ret;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tret = validate_tcpudp6(fs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnum_tuples += ret;\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tret = validate_ip6(fs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnum_tuples += ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\tif ((fs->flow_type & FLOW_EXT)) {\n\t\tret = validate_vlan(fs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnum_tuples += ret;\n\t}\n\n\tif (fs->flow_type & FLOW_MAC_EXT &&\n\t    !is_zero_ether_addr(fs->m_ext.h_dest))\n\t\tnum_tuples++;\n\n\treturn num_tuples;\n}\n\nstatic int\nmlx5e_ethtool_flow_replace(struct mlx5e_priv *priv,\n\t\t\t   struct ethtool_rx_flow_spec *fs, u32 rss_context)\n{\n\tstruct mlx5e_ethtool_table *eth_ft;\n\tstruct mlx5e_ethtool_rule *eth_rule;\n\tstruct mlx5_flow_handle *rule;\n\tint num_tuples;\n\tint err;\n\n\tnum_tuples = validate_flow(priv, fs);\n\tif (num_tuples <= 0) {\n\t\tnetdev_warn(priv->netdev, \"%s: flow is not valid %d\\n\",\n\t\t\t    __func__, num_tuples);\n\t\treturn num_tuples;\n\t}\n\n\teth_ft = get_flow_table(priv, fs, num_tuples);\n\tif (IS_ERR(eth_ft))\n\t\treturn PTR_ERR(eth_ft);\n\n\teth_rule = get_ethtool_rule(priv, fs->location);\n\tif (IS_ERR(eth_rule)) {\n\t\tput_flow_table(eth_ft);\n\t\treturn PTR_ERR(eth_rule);\n\t}\n\n\teth_rule->flow_spec = *fs;\n\teth_rule->eth_ft = eth_ft;\n\n\trule = add_ethtool_flow_rule(priv, eth_rule, eth_ft->ft, fs, rss_context);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tgoto del_ethtool_rule;\n\t}\n\n\teth_rule->rule = rule;\n\n\treturn 0;\n\ndel_ethtool_rule:\n\tdel_ethtool_rule(priv->fs, eth_rule);\n\n\treturn err;\n}\n\nstatic int\nmlx5e_ethtool_flow_remove(struct mlx5e_priv *priv, int location)\n{\n\tstruct mlx5e_ethtool_rule *eth_rule;\n\tint err = 0;\n\n\tif (location >= MAX_NUM_OF_ETHTOOL_RULES)\n\t\treturn -ENOSPC;\n\n\teth_rule = find_ethtool_rule(priv, location);\n\tif (!eth_rule) {\n\t\terr =  -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdel_ethtool_rule(priv->fs, eth_rule);\nout:\n\treturn err;\n}\n\nstatic int\nmlx5e_ethtool_get_flow(struct mlx5e_priv *priv,\n\t\t       struct ethtool_rxnfc *info, int location)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(priv->fs);\n\tstruct mlx5e_ethtool_rule *eth_rule;\n\n\tif (location < 0 || location >= MAX_NUM_OF_ETHTOOL_RULES)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(eth_rule, &ethtool->rules, list) {\n\t\tint index;\n\n\t\tif (eth_rule->flow_spec.location != location)\n\t\t\tcontinue;\n\t\tif (!info)\n\t\t\treturn 0;\n\t\tinfo->fs = eth_rule->flow_spec;\n\t\tif (!eth_rule->rss)\n\t\t\treturn 0;\n\t\tindex = mlx5e_rx_res_rss_index(priv->rx_res, eth_rule->rss);\n\t\tif (index < 0)\n\t\t\treturn index;\n\t\tinfo->rss_context = index;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int\nmlx5e_ethtool_get_all_flows(struct mlx5e_priv *priv,\n\t\t\t    struct ethtool_rxnfc *info, u32 *rule_locs)\n{\n\tint location = 0;\n\tint idx = 0;\n\tint err = 0;\n\n\tinfo->data = MAX_NUM_OF_ETHTOOL_RULES;\n\twhile ((!err || err == -ENOENT) && idx < info->rule_cnt) {\n\t\terr = mlx5e_ethtool_get_flow(priv, NULL, location);\n\t\tif (!err)\n\t\t\trule_locs[idx++] = location;\n\t\tlocation++;\n\t}\n\treturn err;\n}\n\nint mlx5e_ethtool_alloc(struct mlx5e_ethtool_steering **ethtool)\n{\n\t*ethtool =  kvzalloc(sizeof(**ethtool), GFP_KERNEL);\n\tif (!*ethtool)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid mlx5e_ethtool_free(struct mlx5e_ethtool_steering *ethtool)\n{\n\tkvfree(ethtool);\n}\n\nvoid mlx5e_ethtool_cleanup_steering(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(fs);\n\tstruct mlx5e_ethtool_rule *iter;\n\tstruct mlx5e_ethtool_rule *temp;\n\n\tlist_for_each_entry_safe(iter, temp, &ethtool->rules, list)\n\t\tdel_ethtool_rule(fs, iter);\n}\n\nvoid mlx5e_ethtool_init_steering(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(fs);\n\n\tINIT_LIST_HEAD(&ethtool->rules);\n}\n\nstatic int flow_type_to_traffic_type(u32 flow_type)\n{\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\t\treturn MLX5_TT_IPV4_TCP;\n\tcase TCP_V6_FLOW:\n\t\treturn MLX5_TT_IPV6_TCP;\n\tcase UDP_V4_FLOW:\n\t\treturn MLX5_TT_IPV4_UDP;\n\tcase UDP_V6_FLOW:\n\t\treturn MLX5_TT_IPV6_UDP;\n\tcase AH_V4_FLOW:\n\t\treturn MLX5_TT_IPV4_IPSEC_AH;\n\tcase AH_V6_FLOW:\n\t\treturn MLX5_TT_IPV6_IPSEC_AH;\n\tcase ESP_V4_FLOW:\n\t\treturn MLX5_TT_IPV4_IPSEC_ESP;\n\tcase ESP_V6_FLOW:\n\t\treturn MLX5_TT_IPV6_IPSEC_ESP;\n\tcase IPV4_FLOW:\n\t\treturn MLX5_TT_IPV4;\n\tcase IPV6_FLOW:\n\t\treturn MLX5_TT_IPV6;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mlx5e_set_rss_hash_opt(struct mlx5e_priv *priv,\n\t\t\t\t  struct ethtool_rxnfc *nfc)\n{\n\tu8 rx_hash_field = 0;\n\tu32 flow_type = 0;\n\tu32 rss_idx = 0;\n\tint err;\n\tint tt;\n\n\tif (nfc->flow_type & FLOW_RSS)\n\t\trss_idx = nfc->rss_context;\n\n\tflow_type = flow_type_mask(nfc->flow_type);\n\ttt = flow_type_to_traffic_type(flow_type);\n\tif (tt < 0)\n\t\treturn tt;\n\n\t \n\tif (flow_type != TCP_V4_FLOW &&\n\t    flow_type != TCP_V6_FLOW &&\n\t    flow_type != UDP_V4_FLOW &&\n\t    flow_type != UDP_V6_FLOW)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EOPNOTSUPP;\n\n\tif (nfc->data & RXH_IP_SRC)\n\t\trx_hash_field |= MLX5_HASH_FIELD_SEL_SRC_IP;\n\tif (nfc->data & RXH_IP_DST)\n\t\trx_hash_field |= MLX5_HASH_FIELD_SEL_DST_IP;\n\tif (nfc->data & RXH_L4_B_0_1)\n\t\trx_hash_field |= MLX5_HASH_FIELD_SEL_L4_SPORT;\n\tif (nfc->data & RXH_L4_B_2_3)\n\t\trx_hash_field |= MLX5_HASH_FIELD_SEL_L4_DPORT;\n\n\tmutex_lock(&priv->state_lock);\n\terr = mlx5e_rx_res_rss_set_hash_fields(priv->rx_res, rss_idx, tt, rx_hash_field);\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_get_rss_hash_opt(struct mlx5e_priv *priv,\n\t\t\t\t  struct ethtool_rxnfc *nfc)\n{\n\tint hash_field = 0;\n\tu32 flow_type = 0;\n\tu32 rss_idx = 0;\n\tint tt;\n\n\tif (nfc->flow_type & FLOW_RSS)\n\t\trss_idx = nfc->rss_context;\n\n\tflow_type = flow_type_mask(nfc->flow_type);\n\ttt = flow_type_to_traffic_type(flow_type);\n\tif (tt < 0)\n\t\treturn tt;\n\n\thash_field = mlx5e_rx_res_rss_get_hash_fields(priv->rx_res, rss_idx, tt);\n\tif (hash_field < 0)\n\t\treturn hash_field;\n\n\tnfc->data = 0;\n\n\tif (hash_field & MLX5_HASH_FIELD_SEL_SRC_IP)\n\t\tnfc->data |= RXH_IP_SRC;\n\tif (hash_field & MLX5_HASH_FIELD_SEL_DST_IP)\n\t\tnfc->data |= RXH_IP_DST;\n\tif (hash_field & MLX5_HASH_FIELD_SEL_L4_SPORT)\n\t\tnfc->data |= RXH_L4_B_0_1;\n\tif (hash_field & MLX5_HASH_FIELD_SEL_L4_DPORT)\n\t\tnfc->data |= RXH_L4_B_2_3;\n\n\treturn 0;\n}\n\nint mlx5e_ethtool_set_rxnfc(struct mlx5e_priv *priv, struct ethtool_rxnfc *cmd)\n{\n\tint err = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\terr = mlx5e_ethtool_flow_replace(priv, &cmd->fs, cmd->rss_context);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\terr = mlx5e_ethtool_flow_remove(priv, cmd->fs.location);\n\t\tbreak;\n\tcase ETHTOOL_SRXFH:\n\t\terr = mlx5e_set_rss_hash_opt(priv, cmd);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint mlx5e_ethtool_get_rxnfc(struct mlx5e_priv *priv,\n\t\t\t    struct ethtool_rxnfc *info, u32 *rule_locs)\n{\n\tstruct mlx5e_ethtool_steering *ethtool = mlx5e_fs_get_ethtool(priv->fs);\n\tint err = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tinfo->rule_cnt = ethtool->tot_num_rules;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\terr = mlx5e_ethtool_get_flow(priv, info, info->fs.location);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\terr = mlx5e_ethtool_get_all_flows(priv, info, rule_locs);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\terr =  mlx5e_get_rss_hash_opt(priv, info);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}