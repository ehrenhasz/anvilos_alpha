{
  "module_name": "eswitch_offloads_termtbl.c",
  "hash_id": "1c5191f66af293abc12c934e59da43d90dfc92ff3ca08131a23839c05043fe8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c",
  "human_readable_source": "\n\n\n#include <linux/mlx5/fs.h>\n#include \"eswitch.h\"\n#include \"en_tc.h\"\n#include \"fs_core.h\"\n\nstruct mlx5_termtbl_handle {\n\tstruct hlist_node termtbl_hlist;\n\n\tstruct mlx5_flow_table *termtbl;\n\tstruct mlx5_flow_act flow_act;\n\tstruct mlx5_flow_destination dest;\n\n\tstruct mlx5_flow_handle *rule;\n\tint ref_count;\n};\n\nstatic u32\nmlx5_eswitch_termtbl_hash(struct mlx5_flow_act *flow_act,\n\t\t\t  struct mlx5_flow_destination *dest)\n{\n\tu32 hash;\n\n\thash = jhash_1word(flow_act->action, 0);\n\thash = jhash((const void *)&flow_act->vlan,\n\t\t     sizeof(flow_act->vlan), hash);\n\thash = jhash((const void *)&dest->vport.num,\n\t\t     sizeof(dest->vport.num), hash);\n\thash = jhash((const void *)&dest->vport.vhca_id,\n\t\t     sizeof(dest->vport.num), hash);\n\tif (flow_act->pkt_reformat)\n\t\thash = jhash(flow_act->pkt_reformat,\n\t\t\t     sizeof(*flow_act->pkt_reformat),\n\t\t\t     hash);\n\treturn hash;\n}\n\nstatic int\nmlx5_eswitch_termtbl_cmp(struct mlx5_flow_act *flow_act1,\n\t\t\t struct mlx5_flow_destination *dest1,\n\t\t\t struct mlx5_flow_act *flow_act2,\n\t\t\t struct mlx5_flow_destination *dest2)\n{\n\tint ret;\n\n\tret = flow_act1->action != flow_act2->action ||\n\t      dest1->vport.num != dest2->vport.num ||\n\t      dest1->vport.vhca_id != dest2->vport.vhca_id ||\n\t      memcmp(&flow_act1->vlan, &flow_act2->vlan,\n\t\t     sizeof(flow_act1->vlan));\n\tif (ret)\n\t\treturn ret;\n\n\tif (flow_act1->pkt_reformat && flow_act2->pkt_reformat)\n\t\treturn memcmp(flow_act1->pkt_reformat, flow_act2->pkt_reformat,\n\t\t\t      sizeof(*flow_act1->pkt_reformat));\n\n\treturn !(flow_act1->pkt_reformat == flow_act2->pkt_reformat);\n}\n\nstatic int\nmlx5_eswitch_termtbl_create(struct mlx5_core_dev *dev,\n\t\t\t    struct mlx5_termtbl_handle *tt,\n\t\t\t    struct mlx5_flow_act *flow_act)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_namespace *root_ns;\n\tint err, err2;\n\n\troot_ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);\n\tif (!root_ns) {\n\t\tesw_warn(dev, \"Failed to get FDB flow namespace\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tft_attr.flags = MLX5_FLOW_TABLE_TERMINATION | MLX5_FLOW_TABLE_UNMANAGED |\n\t\t\tMLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\tft_attr.prio = FDB_TC_OFFLOAD;\n\tft_attr.max_fte = 1;\n\tft_attr.level = 1;\n\tft_attr.autogroup.max_num_groups = 1;\n\ttt->termtbl = mlx5_create_auto_grouped_flow_table(root_ns, &ft_attr);\n\tif (IS_ERR(tt->termtbl)) {\n\t\terr = PTR_ERR(tt->termtbl);\n\t\tesw_warn(dev, \"Failed to create termination table, err %pe\\n\", tt->termtbl);\n\t\treturn err;\n\t}\n\n\ttt->rule = mlx5_add_flow_rules(tt->termtbl, NULL, flow_act,\n\t\t\t\t       &tt->dest, 1);\n\tif (IS_ERR(tt->rule)) {\n\t\terr = PTR_ERR(tt->rule);\n\t\tesw_warn(dev, \"Failed to create termination table rule, err %pe\\n\", tt->rule);\n\t\tgoto add_flow_err;\n\t}\n\treturn 0;\n\nadd_flow_err:\n\terr2 = mlx5_destroy_flow_table(tt->termtbl);\n\tif (err2)\n\t\tesw_warn(dev, \"Failed to destroy termination table, err %d\\n\", err2);\n\n\treturn err;\n}\n\nstatic struct mlx5_termtbl_handle *\nmlx5_eswitch_termtbl_get_create(struct mlx5_eswitch *esw,\n\t\t\t\tstruct mlx5_flow_act *flow_act,\n\t\t\t\tstruct mlx5_flow_destination *dest,\n\t\t\t\tstruct mlx5_esw_flow_attr *attr)\n{\n\tstruct mlx5_termtbl_handle *tt;\n\tbool found = false;\n\tu32 hash_key;\n\tint err;\n\n\tmutex_lock(&esw->offloads.termtbl_mutex);\n\thash_key = mlx5_eswitch_termtbl_hash(flow_act, dest);\n\thash_for_each_possible(esw->offloads.termtbl_tbl, tt,\n\t\t\t       termtbl_hlist, hash_key) {\n\t\tif (!mlx5_eswitch_termtbl_cmp(&tt->flow_act, &tt->dest,\n\t\t\t\t\t      flow_act, dest)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\tgoto tt_add_ref;\n\n\ttt = kzalloc(sizeof(*tt), GFP_KERNEL);\n\tif (!tt) {\n\t\terr = -ENOMEM;\n\t\tgoto tt_create_err;\n\t}\n\n\ttt->dest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\n\ttt->dest.vport.num = dest->vport.num;\n\ttt->dest.vport.vhca_id = dest->vport.vhca_id;\n\ttt->dest.vport.flags = dest->vport.flags;\n\tmemcpy(&tt->flow_act, flow_act, sizeof(*flow_act));\n\n\terr = mlx5_eswitch_termtbl_create(esw->dev, tt, flow_act);\n\tif (err)\n\t\tgoto tt_create_err;\n\n\thash_add(esw->offloads.termtbl_tbl, &tt->termtbl_hlist, hash_key);\ntt_add_ref:\n\ttt->ref_count++;\n\tmutex_unlock(&esw->offloads.termtbl_mutex);\n\treturn tt;\ntt_create_err:\n\tkfree(tt);\n\tmutex_unlock(&esw->offloads.termtbl_mutex);\n\treturn ERR_PTR(err);\n}\n\nvoid\nmlx5_eswitch_termtbl_put(struct mlx5_eswitch *esw,\n\t\t\t struct mlx5_termtbl_handle *tt)\n{\n\tmutex_lock(&esw->offloads.termtbl_mutex);\n\tif (--tt->ref_count == 0)\n\t\thash_del(&tt->termtbl_hlist);\n\tmutex_unlock(&esw->offloads.termtbl_mutex);\n\n\tif (!tt->ref_count) {\n\t\tmlx5_del_flow_rules(tt->rule);\n\t\tmlx5_destroy_flow_table(tt->termtbl);\n\t\tkfree(tt);\n\t}\n}\n\nstatic void\nmlx5_eswitch_termtbl_actions_move(struct mlx5_flow_act *src,\n\t\t\t\t  struct mlx5_flow_act *dst)\n{\n\tif (src->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH) {\n\t\tsrc->action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;\n\t\tdst->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;\n\t\tmemcpy(&dst->vlan[0], &src->vlan[0], sizeof(src->vlan[0]));\n\t\tmemset(&src->vlan[0], 0, sizeof(src->vlan[0]));\n\n\t\tif (src->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2) {\n\t\t\tsrc->action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;\n\t\t\tdst->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;\n\t\t\tmemcpy(&dst->vlan[1], &src->vlan[1], sizeof(src->vlan[1]));\n\t\t\tmemset(&src->vlan[1], 0, sizeof(src->vlan[1]));\n\t\t}\n\t}\n}\n\nstatic bool mlx5_eswitch_offload_is_uplink_port(const struct mlx5_eswitch *esw,\n\t\t\t\t\t\tconst struct mlx5_flow_spec *spec)\n{\n\tu16 port_mask, port_value;\n\n\tif (MLX5_CAP_ESW_FLOWTABLE(esw->dev, flow_source))\n\t\treturn spec->flow_context.flow_source ==\n\t\t\t\t\tMLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK;\n\n\tport_mask = MLX5_GET(fte_match_param, spec->match_criteria,\n\t\t\t     misc_parameters.source_port);\n\tport_value = MLX5_GET(fte_match_param, spec->match_value,\n\t\t\t      misc_parameters.source_port);\n\treturn (port_mask & port_value) == MLX5_VPORT_UPLINK;\n}\n\nbool\nmlx5_eswitch_termtbl_required(struct mlx5_eswitch *esw,\n\t\t\t      struct mlx5_flow_attr *attr,\n\t\t\t      struct mlx5_flow_act *flow_act,\n\t\t\t      struct mlx5_flow_spec *spec)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tint i;\n\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, termination_table) ||\n\t    !MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, ignore_flow_level) ||\n\t    mlx5e_tc_attr_flags_skip(attr->flags) ||\n\t    (!mlx5_eswitch_offload_is_uplink_port(esw, spec) && !esw_attr->int_port))\n\t\treturn false;\n\n\t \n\tif (flow_act->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH &&\n\t    !(mlx5_fs_get_capabilities(esw->dev, MLX5_FLOW_NAMESPACE_FDB) &\n\t      MLX5_FLOW_STEERING_CAP_VLAN_PUSH_ON_RX))\n\t\treturn true;\n\n\t \n\tfor (i = esw_attr->split_count; i < esw_attr->out_count; i++)\n\t\tif (!esw_attr->dest_int_port && esw_attr->dests[i].vport_valid &&\n\t\t    esw_attr->dests[i].vport == MLX5_VPORT_UPLINK)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstruct mlx5_flow_handle *\nmlx5_eswitch_add_termtbl_rule(struct mlx5_eswitch *esw,\n\t\t\t      struct mlx5_flow_table *fdb,\n\t\t\t      struct mlx5_flow_spec *spec,\n\t\t\t      struct mlx5_esw_flow_attr *attr,\n\t\t\t      struct mlx5_flow_act *flow_act,\n\t\t\t      struct mlx5_flow_destination *dest,\n\t\t\t      int num_dest)\n{\n\tstruct mlx5_flow_act term_tbl_act = {};\n\tstruct mlx5_flow_handle *rule = NULL;\n\tbool term_table_created = false;\n\tint num_vport_dests = 0;\n\tint i, curr_dest;\n\n\tmlx5_eswitch_termtbl_actions_move(flow_act, &term_tbl_act);\n\tterm_tbl_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\n\tfor (i = 0; i < num_dest; i++) {\n\t\tstruct mlx5_termtbl_handle *tt;\n\n\t\t \n\t\tif (dest[i].type != MLX5_FLOW_DESTINATION_TYPE_VPORT)\n\t\t\tcontinue;\n\n\t\tif (attr->dests[num_vport_dests].flags & MLX5_ESW_DEST_ENCAP) {\n\t\t\tterm_tbl_act.action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\t\t\tterm_tbl_act.pkt_reformat = attr->dests[num_vport_dests].pkt_reformat;\n\t\t} else {\n\t\t\tterm_tbl_act.action &= ~MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\t\t\tterm_tbl_act.pkt_reformat = NULL;\n\t\t}\n\n\t\t \n\t\ttt = mlx5_eswitch_termtbl_get_create(esw, &term_tbl_act,\n\t\t\t\t\t\t     &dest[i], attr);\n\t\tif (IS_ERR(tt)) {\n\t\t\tesw_warn(esw->dev, \"Failed to get termination table, err %pe\\n\", tt);\n\t\t\tgoto revert_changes;\n\t\t}\n\t\tattr->dests[num_vport_dests].termtbl = tt;\n\t\tnum_vport_dests++;\n\n\t\t \n\t\tdest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\tdest[i].ft = tt->termtbl;\n\t\tterm_table_created = true;\n\t}\n\n\t \n\tif (!term_table_created)\n\t\tgoto revert_changes;\n\n\t \n\tflow_act->action &= ~MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\tflow_act->pkt_reformat = NULL;\n\tflow_act->flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;\n\trule = mlx5_add_flow_rules(fdb, spec, flow_act, dest, num_dest);\n\tif (IS_ERR(rule))\n\t\tgoto revert_changes;\n\n\tgoto out;\n\nrevert_changes:\n\t \n\tmlx5_eswitch_termtbl_actions_move(&term_tbl_act, flow_act);\n\n\tfor (curr_dest = 0; curr_dest < num_vport_dests; curr_dest++) {\n\t\tstruct mlx5_termtbl_handle *tt = attr->dests[curr_dest].termtbl;\n\n\t\tattr->dests[curr_dest].termtbl = NULL;\n\n\t\t \n\t\tfor (i = 0; i < num_dest; i++) {\n\t\t\tif (dest[i].ft != tt->termtbl)\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&dest[i], 0, sizeof(dest[i]));\n\t\t\tdest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\n\t\t\tdest[i].vport.num = tt->dest.vport.num;\n\t\t\tdest[i].vport.vhca_id = tt->dest.vport.vhca_id;\n\t\t\tmlx5_eswitch_termtbl_put(esw, tt);\n\t\t\tbreak;\n\t\t}\n\t}\n\trule = mlx5_add_flow_rules(fdb, spec, flow_act, dest, num_dest);\nout:\n\treturn rule;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}