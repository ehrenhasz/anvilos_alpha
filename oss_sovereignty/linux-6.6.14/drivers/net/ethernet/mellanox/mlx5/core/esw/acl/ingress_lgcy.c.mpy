{
  "module_name": "ingress_lgcy.c",
  "hash_id": "a5249622aefc399eb3b982d5bb291aff4ddb0ef19f4274db04c10e27360f5637",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/acl/ingress_lgcy.c",
  "human_readable_source": "\n \n\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"helper.h\"\n#include \"lgcy.h\"\n\nstatic void esw_acl_ingress_lgcy_rules_destroy(struct mlx5_vport *vport)\n{\n\tif (vport->ingress.legacy.drop_rule) {\n\t\tmlx5_del_flow_rules(vport->ingress.legacy.drop_rule);\n\t\tvport->ingress.legacy.drop_rule = NULL;\n\t}\n\tesw_acl_ingress_allow_rule_destroy(vport);\n}\n\nstatic int esw_acl_ingress_lgcy_groups_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t      struct mlx5_vport *vport)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_group *g;\n\tvoid *match_criteria;\n\tu32 *flow_group_in;\n\tint err;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\tmatch_criteria = MLX5_ADDR_OF(create_flow_group_in, flow_group_in, match_criteria);\n\n\tMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.cvlan_tag);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.smac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.smac_15_0);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 0);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 0);\n\n\tg = mlx5_create_flow_group(vport->ingress.acl, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tesw_warn(dev, \"vport[%d] ingress create untagged spoofchk flow group, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tgoto spoof_err;\n\t}\n\tvport->ingress.legacy.allow_untagged_spoofchk_grp = g;\n\n\tmemset(flow_group_in, 0, inlen);\n\tMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.cvlan_tag);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 1);\n\n\tg = mlx5_create_flow_group(vport->ingress.acl, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tesw_warn(dev, \"vport[%d] ingress create untagged flow group, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tgoto untagged_err;\n\t}\n\tvport->ingress.legacy.allow_untagged_only_grp = g;\n\n\tmemset(flow_group_in, 0, inlen);\n\tMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.smac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.smac_15_0);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 2);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 2);\n\n\tg = mlx5_create_flow_group(vport->ingress.acl, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tesw_warn(dev, \"vport[%d] ingress create spoofchk flow group, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tgoto allow_spoof_err;\n\t}\n\tvport->ingress.legacy.allow_spoofchk_only_grp = g;\n\n\tmemset(flow_group_in, 0, inlen);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 3);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 3);\n\n\tg = mlx5_create_flow_group(vport->ingress.acl, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tesw_warn(dev, \"vport[%d] ingress create drop flow group, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tgoto drop_err;\n\t}\n\tvport->ingress.legacy.drop_grp = g;\n\tkvfree(flow_group_in);\n\treturn 0;\n\ndrop_err:\n\tif (!IS_ERR_OR_NULL(vport->ingress.legacy.allow_spoofchk_only_grp)) {\n\t\tmlx5_destroy_flow_group(vport->ingress.legacy.allow_spoofchk_only_grp);\n\t\tvport->ingress.legacy.allow_spoofchk_only_grp = NULL;\n\t}\nallow_spoof_err:\n\tif (!IS_ERR_OR_NULL(vport->ingress.legacy.allow_untagged_only_grp)) {\n\t\tmlx5_destroy_flow_group(vport->ingress.legacy.allow_untagged_only_grp);\n\t\tvport->ingress.legacy.allow_untagged_only_grp = NULL;\n\t}\nuntagged_err:\n\tif (!IS_ERR_OR_NULL(vport->ingress.legacy.allow_untagged_spoofchk_grp)) {\n\t\tmlx5_destroy_flow_group(vport->ingress.legacy.allow_untagged_spoofchk_grp);\n\t\tvport->ingress.legacy.allow_untagged_spoofchk_grp = NULL;\n\t}\nspoof_err:\n\tkvfree(flow_group_in);\n\treturn err;\n}\n\nstatic void esw_acl_ingress_lgcy_groups_destroy(struct mlx5_vport *vport)\n{\n\tif (vport->ingress.legacy.allow_spoofchk_only_grp) {\n\t\tmlx5_destroy_flow_group(vport->ingress.legacy.allow_spoofchk_only_grp);\n\t\tvport->ingress.legacy.allow_spoofchk_only_grp = NULL;\n\t}\n\tif (vport->ingress.legacy.allow_untagged_only_grp) {\n\t\tmlx5_destroy_flow_group(vport->ingress.legacy.allow_untagged_only_grp);\n\t\tvport->ingress.legacy.allow_untagged_only_grp = NULL;\n\t}\n\tif (vport->ingress.legacy.allow_untagged_spoofchk_grp) {\n\t\tmlx5_destroy_flow_group(vport->ingress.legacy.allow_untagged_spoofchk_grp);\n\t\tvport->ingress.legacy.allow_untagged_spoofchk_grp = NULL;\n\t}\n\tif (vport->ingress.legacy.drop_grp) {\n\t\tmlx5_destroy_flow_group(vport->ingress.legacy.drop_grp);\n\t\tvport->ingress.legacy.drop_grp = NULL;\n\t}\n}\n\nint esw_acl_ingress_lgcy_setup(struct mlx5_eswitch *esw,\n\t\t\t       struct mlx5_vport *vport)\n{\n\tbool vst_mode_steering = esw_vst_mode_is_steering(esw);\n\tstruct mlx5_flow_destination drop_ctr_dst = {};\n\tstruct mlx5_flow_destination *dst = NULL;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_spec *spec = NULL;\n\tstruct mlx5_fc *counter = NULL;\n\tbool vst_check_cvlan = false;\n\tbool vst_push_cvlan = false;\n\t \n\tint table_size = 4;\n\tint dest_num = 0;\n\tint err = 0;\n\tu8 *smac_v;\n\n\tesw_acl_ingress_lgcy_rules_destroy(vport);\n\n\tif (vport->ingress.legacy.drop_counter) {\n\t\tcounter = vport->ingress.legacy.drop_counter;\n\t} else if (MLX5_CAP_ESW_INGRESS_ACL(esw->dev, flow_counter)) {\n\t\tcounter = mlx5_fc_create(esw->dev, false);\n\t\tif (IS_ERR(counter)) {\n\t\t\tesw_warn(esw->dev,\n\t\t\t\t \"vport[%d] configure ingress drop rule counter failed\\n\",\n\t\t\t\t vport->vport);\n\t\t\tcounter = NULL;\n\t\t}\n\t\tvport->ingress.legacy.drop_counter = counter;\n\t}\n\n\tif (!vport->info.vlan && !vport->info.qos && !vport->info.spoofchk) {\n\t\tesw_acl_ingress_lgcy_cleanup(esw, vport);\n\t\treturn 0;\n\t}\n\n\tif (!vport->ingress.acl) {\n\t\tvport->ingress.acl = esw_acl_table_create(esw, vport,\n\t\t\t\t\t\t\t  MLX5_FLOW_NAMESPACE_ESW_INGRESS,\n\t\t\t\t\t\t\t  table_size);\n\t\tif (IS_ERR(vport->ingress.acl)) {\n\t\t\terr = PTR_ERR(vport->ingress.acl);\n\t\t\tvport->ingress.acl = NULL;\n\t\t\treturn err;\n\t\t}\n\n\t\terr = esw_acl_ingress_lgcy_groups_create(esw, vport);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tesw_debug(esw->dev,\n\t\t  \"vport[%d] configure ingress rules, vlan(%d) qos(%d)\\n\",\n\t\t  vport->vport, vport->info.vlan, vport->info.qos);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif ((vport->info.vlan || vport->info.qos)) {\n\t\tif (vst_mode_steering)\n\t\t\tvst_push_cvlan = true;\n\t\telse if (!MLX5_CAP_ESW(esw->dev, vport_cvlan_insert_always))\n\t\t\tvst_check_cvlan = true;\n\t}\n\n\tif (vst_check_cvlan || vport->info.spoofchk)\n\t\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\n\t \n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\tif (vst_push_cvlan) {\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;\n\t\tflow_act.vlan[0].prio = vport->info.qos;\n\t\tflow_act.vlan[0].vid = vport->info.vlan;\n\t\tflow_act.vlan[0].ethtype = ETH_P_8021Q;\n\t}\n\n\tif (vst_check_cvlan)\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.cvlan_tag);\n\n\tif (vport->info.spoofchk) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.smac_47_16);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.smac_15_0);\n\t\tsmac_v = MLX5_ADDR_OF(fte_match_param,\n\t\t\t\t      spec->match_value,\n\t\t\t\t      outer_headers.smac_47_16);\n\t\tether_addr_copy(smac_v, vport->info.mac);\n\t}\n\n\tvport->ingress.allow_rule = mlx5_add_flow_rules(vport->ingress.acl, spec,\n\t\t\t\t\t\t\t&flow_act, NULL, 0);\n\tif (IS_ERR(vport->ingress.allow_rule)) {\n\t\terr = PTR_ERR(vport->ingress.allow_rule);\n\t\tesw_warn(esw->dev,\n\t\t\t \"vport[%d] configure ingress allow rule, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tvport->ingress.allow_rule = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!vst_check_cvlan && !vport->info.spoofchk)\n\t\tgoto out;\n\n\tmemset(&flow_act, 0, sizeof(flow_act));\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;\n\t \n\tif (counter) {\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\tdrop_ctr_dst.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\t\tdrop_ctr_dst.counter_id = mlx5_fc_id(counter);\n\t\tdst = &drop_ctr_dst;\n\t\tdest_num++;\n\t}\n\tvport->ingress.legacy.drop_rule =\n\t\tmlx5_add_flow_rules(vport->ingress.acl, NULL,\n\t\t\t\t    &flow_act, dst, dest_num);\n\tif (IS_ERR(vport->ingress.legacy.drop_rule)) {\n\t\terr = PTR_ERR(vport->ingress.legacy.drop_rule);\n\t\tesw_warn(esw->dev,\n\t\t\t \"vport[%d] configure ingress drop rule, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tvport->ingress.legacy.drop_rule = NULL;\n\t\tgoto out;\n\t}\n\tkvfree(spec);\n\treturn 0;\n\nout:\n\tif (err)\n\t\tesw_acl_ingress_lgcy_cleanup(esw, vport);\n\tkvfree(spec);\n\treturn err;\n}\n\nvoid esw_acl_ingress_lgcy_cleanup(struct mlx5_eswitch *esw,\n\t\t\t\t  struct mlx5_vport *vport)\n{\n\tif (IS_ERR_OR_NULL(vport->ingress.acl))\n\t\tgoto clean_drop_counter;\n\n\tesw_debug(esw->dev, \"Destroy vport[%d] E-Switch ingress ACL\\n\", vport->vport);\n\n\tesw_acl_ingress_lgcy_rules_destroy(vport);\n\tesw_acl_ingress_lgcy_groups_destroy(vport);\n\tesw_acl_ingress_table_destroy(vport);\n\nclean_drop_counter:\n\tif (vport->ingress.legacy.drop_counter) {\n\t\tmlx5_fc_destroy(esw->dev, vport->ingress.legacy.drop_counter);\n\t\tvport->ingress.legacy.drop_counter = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}