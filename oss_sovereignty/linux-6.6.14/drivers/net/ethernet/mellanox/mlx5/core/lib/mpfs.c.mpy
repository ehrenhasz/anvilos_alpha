{
  "module_name": "mpfs.c",
  "hash_id": "51e8b2108d13233605978e682a589e8a0c2c76d57da8445d4a299150830a6199",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/mpfs.c",
  "human_readable_source": " \n\n#include <linux/etherdevice.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/mlx5_ifc.h>\n#include <linux/mlx5/mpfs.h>\n#include <linux/mlx5/eswitch.h>\n#include \"mlx5_core.h\"\n#include \"lib/mpfs.h\"\n\n \nstatic int set_l2table_entry_cmd(struct mlx5_core_dev *dev, u32 index, u8 *mac)\n{\n\tu32 in[MLX5_ST_SZ_DW(set_l2_table_entry_in)] = {};\n\tu8 *in_mac_addr;\n\n\tMLX5_SET(set_l2_table_entry_in, in, opcode, MLX5_CMD_OP_SET_L2_TABLE_ENTRY);\n\tMLX5_SET(set_l2_table_entry_in, in, table_index, index);\n\n\tin_mac_addr = MLX5_ADDR_OF(set_l2_table_entry_in, in, mac_address);\n\tether_addr_copy(&in_mac_addr[2], mac);\n\n\treturn mlx5_cmd_exec_in(dev, set_l2_table_entry, in);\n}\n\nstatic int del_l2table_entry_cmd(struct mlx5_core_dev *dev, u32 index)\n{\n\tu32 in[MLX5_ST_SZ_DW(delete_l2_table_entry_in)] = {};\n\n\tMLX5_SET(delete_l2_table_entry_in, in, opcode, MLX5_CMD_OP_DELETE_L2_TABLE_ENTRY);\n\tMLX5_SET(delete_l2_table_entry_in, in, table_index, index);\n\treturn mlx5_cmd_exec_in(dev, delete_l2_table_entry, in);\n}\n\n \nstruct l2table_node {\n\tstruct l2addr_node node;\n\tu32                index;  \n\tint                ref_count;\n};\n\nstruct mlx5_mpfs {\n\tstruct hlist_head    hash[MLX5_L2_ADDR_HASH_SIZE];\n\tstruct mutex         lock;  \n\tu32                  size;\n\tunsigned long        *bitmap;\n};\n\nstatic int alloc_l2table_index(struct mlx5_mpfs *l2table, u32 *ix)\n{\n\tint err = 0;\n\n\t*ix = find_first_zero_bit(l2table->bitmap, l2table->size);\n\tif (*ix >= l2table->size)\n\t\terr = -ENOSPC;\n\telse\n\t\t__set_bit(*ix, l2table->bitmap);\n\n\treturn err;\n}\n\nstatic void free_l2table_index(struct mlx5_mpfs *l2table, u32 ix)\n{\n\t__clear_bit(ix, l2table->bitmap);\n}\n\nint mlx5_mpfs_init(struct mlx5_core_dev *dev)\n{\n\tint l2table_size = 1 << MLX5_CAP_GEN(dev, log_max_l2_table);\n\tstruct mlx5_mpfs *mpfs;\n\n\tif (!MLX5_ESWITCH_MANAGER(dev) || l2table_size == 1)\n\t\treturn 0;\n\n\tmpfs = kzalloc(sizeof(*mpfs), GFP_KERNEL);\n\tif (!mpfs)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&mpfs->lock);\n\tmpfs->size   = l2table_size;\n\tmpfs->bitmap = bitmap_zalloc(l2table_size, GFP_KERNEL);\n\tif (!mpfs->bitmap) {\n\t\tkfree(mpfs);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->priv.mpfs = mpfs;\n\treturn 0;\n}\n\nvoid mlx5_mpfs_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_mpfs *mpfs = dev->priv.mpfs;\n\n\tif (!mpfs)\n\t\treturn;\n\n\tWARN_ON(!hlist_empty(mpfs->hash));\n\tbitmap_free(mpfs->bitmap);\n\tkfree(mpfs);\n}\n\nint mlx5_mpfs_add_mac(struct mlx5_core_dev *dev, u8 *mac)\n{\n\tstruct mlx5_mpfs *mpfs = dev->priv.mpfs;\n\tstruct l2table_node *l2addr;\n\tint err = 0;\n\tu32 index;\n\n\tif (!mpfs)\n\t\treturn 0;\n\n\tmutex_lock(&mpfs->lock);\n\n\tl2addr = l2addr_hash_find(mpfs->hash, mac, struct l2table_node);\n\tif (l2addr) {\n\t\tl2addr->ref_count++;\n\t\tgoto out;\n\t}\n\n\terr = alloc_l2table_index(mpfs, &index);\n\tif (err)\n\t\tgoto out;\n\n\tl2addr = l2addr_hash_add(mpfs->hash, mac, struct l2table_node, GFP_KERNEL);\n\tif (!l2addr) {\n\t\terr = -ENOMEM;\n\t\tgoto hash_add_err;\n\t}\n\n\terr = set_l2table_entry_cmd(dev, index, mac);\n\tif (err)\n\t\tgoto set_table_entry_err;\n\n\tl2addr->index = index;\n\tl2addr->ref_count = 1;\n\n\tmlx5_core_dbg(dev, \"MPFS mac added %pM, index (%d)\\n\", mac, index);\n\tgoto out;\n\nset_table_entry_err:\n\tl2addr_hash_del(l2addr);\nhash_add_err:\n\tfree_l2table_index(mpfs, index);\nout:\n\tmutex_unlock(&mpfs->lock);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx5_mpfs_add_mac);\n\nint mlx5_mpfs_del_mac(struct mlx5_core_dev *dev, u8 *mac)\n{\n\tstruct mlx5_mpfs *mpfs = dev->priv.mpfs;\n\tstruct l2table_node *l2addr;\n\tint err = 0;\n\tu32 index;\n\n\tif (!mpfs)\n\t\treturn 0;\n\n\tmutex_lock(&mpfs->lock);\n\n\tl2addr = l2addr_hash_find(mpfs->hash, mac, struct l2table_node);\n\tif (!l2addr) {\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tif (--l2addr->ref_count > 0)\n\t\tgoto unlock;\n\n\tindex = l2addr->index;\n\tdel_l2table_entry_cmd(dev, index);\n\tl2addr_hash_del(l2addr);\n\tfree_l2table_index(mpfs, index);\n\tmlx5_core_dbg(dev, \"MPFS mac deleted %pM, index (%d)\\n\", mac, index);\nunlock:\n\tmutex_unlock(&mpfs->lock);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx5_mpfs_del_mac);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}