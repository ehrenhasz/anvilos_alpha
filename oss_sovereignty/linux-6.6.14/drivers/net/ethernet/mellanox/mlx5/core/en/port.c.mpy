{
  "module_name": "port.c",
  "hash_id": "dd452f89f27ff263b607bf8613917d5d5b9e62dcbbafa8568e4c579f6383c6ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/port.c",
  "human_readable_source": " \n\n#include \"port.h\"\n\nvoid mlx5_port_query_eth_autoneg(struct mlx5_core_dev *dev, u8 *an_status,\n\t\t\t\t u8 *an_disable_cap, u8 *an_disable_admin)\n{\n\tu32 out[MLX5_ST_SZ_DW(ptys_reg)];\n\n\t*an_status = 0;\n\t*an_disable_cap = 0;\n\t*an_disable_admin = 0;\n\n\tif (mlx5_query_port_ptys(dev, out, sizeof(out), MLX5_PTYS_EN, 1))\n\t\treturn;\n\n\t*an_status = MLX5_GET(ptys_reg, out, an_status);\n\t*an_disable_cap = MLX5_GET(ptys_reg, out, an_disable_cap);\n\t*an_disable_admin = MLX5_GET(ptys_reg, out, an_disable_admin);\n}\n\nint mlx5_port_set_eth_ptys(struct mlx5_core_dev *dev, bool an_disable,\n\t\t\t   u32 proto_admin, bool ext)\n{\n\tu32 out[MLX5_ST_SZ_DW(ptys_reg)];\n\tu32 in[MLX5_ST_SZ_DW(ptys_reg)];\n\tu8 an_disable_admin;\n\tu8 an_disable_cap;\n\tu8 an_status;\n\n\tmlx5_port_query_eth_autoneg(dev, &an_status, &an_disable_cap,\n\t\t\t\t    &an_disable_admin);\n\tif (!an_disable_cap && an_disable)\n\t\treturn -EPERM;\n\n\tmemset(in, 0, sizeof(in));\n\n\tMLX5_SET(ptys_reg, in, local_port, 1);\n\tMLX5_SET(ptys_reg, in, an_disable_admin, an_disable);\n\tMLX5_SET(ptys_reg, in, proto_mask, MLX5_PTYS_EN);\n\tif (ext)\n\t\tMLX5_SET(ptys_reg, in, ext_eth_proto_admin, proto_admin);\n\telse\n\t\tMLX5_SET(ptys_reg, in, eth_proto_admin, proto_admin);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t    sizeof(out), MLX5_REG_PTYS, 0, 1);\n}\n\nint mlx5e_port_linkspeed(struct mlx5_core_dev *mdev, u32 *speed)\n{\n\tstruct mlx5_port_eth_proto eproto;\n\tbool force_legacy = false;\n\tbool ext;\n\tint err;\n\n\text = mlx5_ptys_ext_supported(mdev);\n\terr = mlx5_port_query_eth_proto(mdev, 1, ext, &eproto);\n\tif (err)\n\t\tgoto out;\n\tif (ext && !eproto.admin) {\n\t\tforce_legacy = true;\n\t\terr = mlx5_port_query_eth_proto(mdev, 1, false, &eproto);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\t*speed = mlx5_port_ptys2speed(mdev, eproto.oper, force_legacy);\n\tif (!(*speed))\n\t\terr = -EINVAL;\n\nout:\n\treturn err;\n}\n\nint mlx5e_port_query_pbmc(struct mlx5_core_dev *mdev, void *out)\n{\n\tint sz = MLX5_ST_SZ_BYTES(pbmc_reg);\n\tvoid *in;\n\tint err;\n\n\tin = kzalloc(sz, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(pbmc_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PBMC, 0, 0);\n\n\tkfree(in);\n\treturn err;\n}\n\nint mlx5e_port_set_pbmc(struct mlx5_core_dev *mdev, void *in)\n{\n\tint sz = MLX5_ST_SZ_BYTES(pbmc_reg);\n\tvoid *out;\n\tint err;\n\n\tout = kzalloc(sz, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(pbmc_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PBMC, 0, 1);\n\n\tkfree(out);\n\treturn err;\n}\n\nint mlx5e_port_query_sbpr(struct mlx5_core_dev *mdev, u32 desc, u8 dir,\n\t\t\t  u8 pool_idx, void *out, int size_out)\n{\n\tu32 in[MLX5_ST_SZ_DW(sbpr_reg)] = {};\n\n\tMLX5_SET(sbpr_reg, in, desc, desc);\n\tMLX5_SET(sbpr_reg, in, dir, dir);\n\tMLX5_SET(sbpr_reg, in, pool, pool_idx);\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), out, size_out, MLX5_REG_SBPR, 0, 0);\n}\n\nint mlx5e_port_set_sbpr(struct mlx5_core_dev *mdev, u32 desc, u8 dir,\n\t\t\tu8 pool_idx, u32 infi_size, u32 size)\n{\n\tu32 out[MLX5_ST_SZ_DW(sbpr_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(sbpr_reg)] = {};\n\n\tMLX5_SET(sbpr_reg, in, desc, desc);\n\tMLX5_SET(sbpr_reg, in, dir, dir);\n\tMLX5_SET(sbpr_reg, in, pool, pool_idx);\n\tMLX5_SET(sbpr_reg, in, infi_size, infi_size);\n\tMLX5_SET(sbpr_reg, in, size, size);\n\tMLX5_SET(sbpr_reg, in, mode, 1);\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), out, sizeof(out), MLX5_REG_SBPR, 0, 1);\n}\n\nstatic int mlx5e_port_query_sbcm(struct mlx5_core_dev *mdev, u32 desc,\n\t\t\t\t u8 pg_buff_idx, u8 dir, void *out,\n\t\t\t\t int size_out)\n{\n\tu32 in[MLX5_ST_SZ_DW(sbcm_reg)] = {};\n\n\tMLX5_SET(sbcm_reg, in, desc, desc);\n\tMLX5_SET(sbcm_reg, in, local_port, 1);\n\tMLX5_SET(sbcm_reg, in, pg_buff, pg_buff_idx);\n\tMLX5_SET(sbcm_reg, in, dir, dir);\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), out, size_out, MLX5_REG_SBCM, 0, 0);\n}\n\nint mlx5e_port_set_sbcm(struct mlx5_core_dev *mdev, u32 desc, u8 pg_buff_idx,\n\t\t\tu8 dir, u8 infi_size, u32 max_buff, u8 pool_idx)\n{\n\tu32 out[MLX5_ST_SZ_DW(sbcm_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(sbcm_reg)] = {};\n\tu32 min_buff;\n\tint err;\n\tu8 exc;\n\n\terr = mlx5e_port_query_sbcm(mdev, desc, pg_buff_idx, dir, out,\n\t\t\t\t    sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\texc = MLX5_GET(sbcm_reg, out, exc);\n\tmin_buff = MLX5_GET(sbcm_reg, out, min_buff);\n\n\tMLX5_SET(sbcm_reg, in, desc, desc);\n\tMLX5_SET(sbcm_reg, in, local_port, 1);\n\tMLX5_SET(sbcm_reg, in, pg_buff, pg_buff_idx);\n\tMLX5_SET(sbcm_reg, in, dir, dir);\n\tMLX5_SET(sbcm_reg, in, exc, exc);\n\tMLX5_SET(sbcm_reg, in, min_buff, min_buff);\n\tMLX5_SET(sbcm_reg, in, infi_max, infi_size);\n\tMLX5_SET(sbcm_reg, in, max_buff, max_buff);\n\tMLX5_SET(sbcm_reg, in, pool, pool_idx);\n\n\treturn mlx5_core_access_reg(mdev, in, sizeof(in), out, sizeof(out), MLX5_REG_SBCM, 0, 1);\n}\n\n \nint mlx5e_port_query_priority2buffer(struct mlx5_core_dev *mdev, u8 *buffer)\n{\n\tint sz = MLX5_ST_SZ_BYTES(pptb_reg);\n\tu32 prio_x_buff;\n\tvoid *out;\n\tvoid *in;\n\tint prio;\n\tint err;\n\n\tin = kzalloc(sz, GFP_KERNEL);\n\tout = kzalloc(sz, GFP_KERNEL);\n\tif (!in || !out) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(pptb_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PPTB, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\tprio_x_buff = MLX5_GET(pptb_reg, out, prio_x_buff);\n\tfor (prio = 0; prio < 8; prio++) {\n\t\tbuffer[prio] = (u8)(prio_x_buff >> (4 * prio)) & 0xF;\n\t\tmlx5_core_dbg(mdev, \"prio %d, buffer %d\\n\", prio, buffer[prio]);\n\t}\nout:\n\tkfree(in);\n\tkfree(out);\n\treturn err;\n}\n\nint mlx5e_port_set_priority2buffer(struct mlx5_core_dev *mdev, u8 *buffer)\n{\n\tint sz = MLX5_ST_SZ_BYTES(pptb_reg);\n\tu32 prio_x_buff;\n\tvoid *out;\n\tvoid *in;\n\tint prio;\n\tint err;\n\n\tin = kzalloc(sz, GFP_KERNEL);\n\tout = kzalloc(sz, GFP_KERNEL);\n\tif (!in || !out) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tMLX5_SET(pptb_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PPTB, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(in, out, sz);\n\tMLX5_SET(pptb_reg, in, local_port, 1);\n\n\t \n\tMLX5_SET(pptb_reg, in, pm, 0xFF);\n\n\tprio_x_buff = 0;\n\tfor (prio = 0; prio < 8; prio++)\n\t\tprio_x_buff |= (buffer[prio] << (4 * prio));\n\tMLX5_SET(pptb_reg, in, prio_x_buff, prio_x_buff);\n\n\terr = mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PPTB, 0, 1);\n\nout:\n\tkfree(in);\n\tkfree(out);\n\treturn err;\n}\n\nenum mlx5e_fec_supported_link_mode {\n\tMLX5E_FEC_SUPPORTED_LINK_MODES_10G_40G,\n\tMLX5E_FEC_SUPPORTED_LINK_MODES_25G,\n\tMLX5E_FEC_SUPPORTED_LINK_MODES_50G,\n\tMLX5E_FEC_SUPPORTED_LINK_MODES_56G,\n\tMLX5E_FEC_SUPPORTED_LINK_MODES_100G,\n\tMLX5E_FEC_SUPPORTED_LINK_MODE_50G_1X,\n\tMLX5E_FEC_SUPPORTED_LINK_MODE_100G_2X,\n\tMLX5E_FEC_SUPPORTED_LINK_MODE_200G_4X,\n\tMLX5E_FEC_SUPPORTED_LINK_MODE_400G_8X,\n\tMLX5E_MAX_FEC_SUPPORTED_LINK_MODE,\n};\n\n#define MLX5E_FEC_FIRST_50G_PER_LANE_MODE MLX5E_FEC_SUPPORTED_LINK_MODE_50G_1X\n\n#define MLX5E_FEC_OVERRIDE_ADMIN_POLICY(buf, policy, write, link)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tu16 *_policy = &(policy);\t\t\t\t\t\t\\\n\t\tu32 *_buf = buf;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (write)\t\t\t\t\t\t\t\t\\\n\t\t\tMLX5_SET(pplm_reg, _buf, fec_override_admin_##link, *_policy);\t\\\n\t\telse\t\t\t\t\t\t\t\t\t\\\n\t\t\t*_policy = MLX5_GET(pplm_reg, _buf, fec_override_admin_##link);\t\\\n\t} while (0)\n\n \nstatic int mlx5e_fec_admin_field(u32 *pplm, u16 *fec_policy, bool write,\n\t\t\t\t enum mlx5e_fec_supported_link_mode link_mode)\n{\n\tswitch (link_mode) {\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_10G_40G:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 10g_40g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_25G:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 25g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_50G:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 50g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_56G:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 56g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_100G:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 100g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_50G_1X:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 50g_1x);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_100G_2X:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 100g_2x);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_200G_4X:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 200g_4x);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_400G_8X:\n\t\tMLX5E_FEC_OVERRIDE_ADMIN_POLICY(pplm, *fec_policy, write, 400g_8x);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#define MLX5E_GET_FEC_OVERRIDE_CAP(buf, link)  \\\n\tMLX5_GET(pplm_reg, buf, fec_override_cap_##link)\n\n \nstatic int mlx5e_get_fec_cap_field(u32 *pplm, u16 *fec_cap,\n\t\t\t\t   enum mlx5e_fec_supported_link_mode link_mode)\n{\n\tswitch (link_mode) {\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_10G_40G:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 10g_40g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_25G:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 25g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_50G:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 50g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_56G:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 56g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODES_100G:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 100g);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_50G_1X:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 50g_1x);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_100G_2X:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 100g_2x);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_200G_4X:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 200g_4x);\n\t\tbreak;\n\tcase MLX5E_FEC_SUPPORTED_LINK_MODE_400G_8X:\n\t\t*fec_cap = MLX5E_GET_FEC_OVERRIDE_CAP(pplm, 400g_8x);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nbool mlx5e_fec_in_caps(struct mlx5_core_dev *dev, int fec_policy)\n{\n\tbool fec_50g_per_lane = MLX5_CAP_PCAM_FEATURE(dev, fec_50G_per_lane_in_pplm);\n\tu32 out[MLX5_ST_SZ_DW(pplm_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(pplm_reg)] = {};\n\tint sz = MLX5_ST_SZ_BYTES(pplm_reg);\n\tint err;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(dev, pcam_reg) || !MLX5_CAP_PCAM_REG(dev, pplm))\n\t\treturn false;\n\n\tMLX5_SET(pplm_reg, in, local_port, 1);\n\terr =  mlx5_core_access_reg(dev, in, sz, out, sz, MLX5_REG_PPLM, 0, 0);\n\tif (err)\n\t\treturn false;\n\n\tfor (i = 0; i < MLX5E_MAX_FEC_SUPPORTED_LINK_MODE; i++) {\n\t\tu16 fec_caps;\n\n\t\tif (i >= MLX5E_FEC_FIRST_50G_PER_LANE_MODE && !fec_50g_per_lane)\n\t\t\tbreak;\n\n\t\tmlx5e_get_fec_cap_field(out, &fec_caps, i);\n\t\tif (fec_caps & fec_policy)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint mlx5e_get_fec_mode(struct mlx5_core_dev *dev, u32 *fec_mode_active,\n\t\t       u16 *fec_configured_mode)\n{\n\tbool fec_50g_per_lane = MLX5_CAP_PCAM_FEATURE(dev, fec_50G_per_lane_in_pplm);\n\tu32 out[MLX5_ST_SZ_DW(pplm_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(pplm_reg)] = {};\n\tint sz = MLX5_ST_SZ_BYTES(pplm_reg);\n\tint err;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(dev, pcam_reg))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!MLX5_CAP_PCAM_REG(dev, pplm))\n\t\treturn -EOPNOTSUPP;\n\n\tMLX5_SET(pplm_reg, in, local_port, 1);\n\terr =  mlx5_core_access_reg(dev, in, sz, out, sz, MLX5_REG_PPLM, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\t*fec_mode_active = MLX5_GET(pplm_reg, out, fec_mode_active);\n\n\tif (!fec_configured_mode)\n\t\tgoto out;\n\n\t*fec_configured_mode = 0;\n\tfor (i = 0; i < MLX5E_MAX_FEC_SUPPORTED_LINK_MODE; i++) {\n\t\tif (i >= MLX5E_FEC_FIRST_50G_PER_LANE_MODE && !fec_50g_per_lane)\n\t\t\tbreak;\n\n\t\tmlx5e_fec_admin_field(out, fec_configured_mode, 0, i);\n\t\tif (*fec_configured_mode != 0)\n\t\t\tgoto out;\n\t}\nout:\n\treturn 0;\n}\n\nint mlx5e_set_fec_mode(struct mlx5_core_dev *dev, u16 fec_policy)\n{\n\tbool fec_50g_per_lane = MLX5_CAP_PCAM_FEATURE(dev, fec_50G_per_lane_in_pplm);\n\tu32 out[MLX5_ST_SZ_DW(pplm_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(pplm_reg)] = {};\n\tint sz = MLX5_ST_SZ_BYTES(pplm_reg);\n\tu16 fec_policy_auto = 0;\n\tint err;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(dev, pcam_reg))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!MLX5_CAP_PCAM_REG(dev, pplm))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fec_policy >= (1 << MLX5E_FEC_LLRS_272_257_1) && !fec_50g_per_lane)\n\t\treturn -EOPNOTSUPP;\n\n\tif (fec_policy && !mlx5e_fec_in_caps(dev, fec_policy))\n\t\treturn -EOPNOTSUPP;\n\n\tMLX5_SET(pplm_reg, in, local_port, 1);\n\terr = mlx5_core_access_reg(dev, in, sz, out, sz, MLX5_REG_PPLM, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tMLX5_SET(pplm_reg, out, local_port, 1);\n\n\tfor (i = 0; i < MLX5E_MAX_FEC_SUPPORTED_LINK_MODE; i++) {\n\t\tu16 conf_fec = fec_policy;\n\t\tu16 fec_caps = 0;\n\n\t\tif (i >= MLX5E_FEC_FIRST_50G_PER_LANE_MODE && !fec_50g_per_lane)\n\t\t\tbreak;\n\n\t\t \n\t\tif (conf_fec == (1 << MLX5E_FEC_RS_528_514) &&\n\t\t    i >= MLX5E_FEC_FIRST_50G_PER_LANE_MODE)\n\t\t\tconf_fec = (1 << MLX5E_FEC_RS_544_514);\n\n\t\tmlx5e_get_fec_cap_field(out, &fec_caps, i);\n\n\t\t \n\t\tif (fec_caps & conf_fec)\n\t\t\tmlx5e_fec_admin_field(out, &conf_fec, 1, i);\n\t\telse\n\t\t\t \n\t\t\tmlx5e_fec_admin_field(out, &fec_policy_auto, 1, i);\n\t}\n\n\treturn mlx5_core_access_reg(dev, out, sz, out, sz, MLX5_REG_PPLM, 0, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}