{
  "module_name": "ptp.h",
  "hash_id": "c799f08c320bd58d49dd829cbed4985fa149e9a4e2dcf3687132de2caec64c34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.h",
  "human_readable_source": " \n \n\n#ifndef __MLX5_EN_PTP_H__\n#define __MLX5_EN_PTP_H__\n\n#include \"en.h\"\n#include \"en_stats.h\"\n#include \"en/txrx.h\"\n#include <linux/ktime.h>\n#include <linux/ptp_classify.h>\n#include <linux/time64.h>\n#include <linux/workqueue.h>\n\n#define MLX5E_PTP_CHANNEL_IX 0\n#define MLX5E_PTP_MAX_LOG_SQ_SIZE (8U)\n#define MLX5E_PTP_TS_CQE_UNDELIVERED_TIMEOUT (1 * NSEC_PER_SEC)\n\nstruct mlx5e_ptp_metadata_fifo {\n\tu8  cc;\n\tu8  pc;\n\tu8  mask;\n\tu8  *data;\n};\n\nstruct mlx5e_ptp_metadata_map {\n\tu16             undelivered_counter;\n\tu16             capacity;\n\tstruct sk_buff  **data;\n};\n\nstruct mlx5e_ptpsq {\n\tstruct mlx5e_txqsq       txqsq;\n\tstruct mlx5e_cq          ts_cq;\n\tstruct mlx5e_ptp_cq_stats *cq_stats;\n\tu16                      ts_cqe_ctr_mask;\n\n\tstruct work_struct                 report_unhealthy_work;\n\tstruct mlx5e_ptp_port_ts_cqe_list  *ts_cqe_pending_list;\n\tstruct mlx5e_ptp_metadata_fifo     metadata_freelist;\n\tstruct mlx5e_ptp_metadata_map      metadata_map;\n};\n\nenum {\n\tMLX5E_PTP_STATE_TX,\n\tMLX5E_PTP_STATE_RX,\n\tMLX5E_PTP_STATE_NUM_STATES,\n};\n\nstruct mlx5e_ptp {\n\t \n\tstruct mlx5e_ptpsq         ptpsq[MLX5E_MAX_NUM_TC];\n\tstruct mlx5e_rq            rq;\n\tstruct napi_struct         napi;\n\tstruct device             *pdev;\n\tstruct net_device         *netdev;\n\t__be32                     mkey_be;\n\tu8                         num_tc;\n\tu8                         lag_port;\n\n\t \n\tstruct mlx5e_ch_stats     *stats;\n\n\t \n\tstruct mlx5e_priv         *priv;\n\tstruct mlx5_core_dev      *mdev;\n\tstruct hwtstamp_config    *tstamp;\n\tDECLARE_BITMAP(state, MLX5E_PTP_STATE_NUM_STATES);\n};\n\nstatic inline bool mlx5e_use_ptpsq(struct sk_buff *skb)\n{\n\tstruct flow_keys fk;\n\n\tif (!(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))\n\t\treturn false;\n\n\tif (!skb_flow_dissect_flow_keys(skb, &fk, 0))\n\t\treturn false;\n\n\tif (fk.basic.n_proto == htons(ETH_P_1588))\n\t\treturn true;\n\n\tif (fk.basic.n_proto != htons(ETH_P_IP) &&\n\t    fk.basic.n_proto != htons(ETH_P_IPV6))\n\t\treturn false;\n\n\treturn (fk.basic.ip_proto == IPPROTO_UDP &&\n\t\tfk.ports.dst == htons(PTP_EV_PORT));\n}\n\nstatic inline void mlx5e_ptp_metadata_fifo_push(struct mlx5e_ptp_metadata_fifo *fifo, u8 metadata)\n{\n\tfifo->data[fifo->mask & fifo->pc++] = metadata;\n}\n\nstatic inline u8\nmlx5e_ptp_metadata_fifo_pop(struct mlx5e_ptp_metadata_fifo *fifo)\n{\n\treturn fifo->data[fifo->mask & fifo->cc++];\n}\n\nstatic inline void\nmlx5e_ptp_metadata_map_put(struct mlx5e_ptp_metadata_map *map,\n\t\t\t   struct sk_buff *skb, u8 metadata)\n{\n\tWARN_ON_ONCE(map->data[metadata]);\n\tmap->data[metadata] = skb;\n}\n\nstatic inline bool mlx5e_ptpsq_metadata_freelist_empty(struct mlx5e_ptpsq *ptpsq)\n{\n\tstruct mlx5e_ptp_metadata_fifo *freelist;\n\n\tif (likely(!ptpsq))\n\t\treturn false;\n\n\tfreelist = &ptpsq->metadata_freelist;\n\n\treturn freelist->pc == freelist->cc;\n}\n\nint mlx5e_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,\n\t\t   u8 lag_port, struct mlx5e_ptp **cp);\nvoid mlx5e_ptp_close(struct mlx5e_ptp *c);\nvoid mlx5e_ptp_activate_channel(struct mlx5e_ptp *c);\nvoid mlx5e_ptp_deactivate_channel(struct mlx5e_ptp *c);\nint mlx5e_ptp_get_rqn(struct mlx5e_ptp *c, u32 *rqn);\nint mlx5e_ptp_alloc_rx_fs(struct mlx5e_flow_steering *fs,\n\t\t\t  const struct mlx5e_profile *profile);\nvoid mlx5e_ptp_free_rx_fs(struct mlx5e_flow_steering *fs,\n\t\t\t  const struct mlx5e_profile *profile);\nint mlx5e_ptp_rx_manage_fs(struct mlx5e_priv *priv, bool set);\n\nvoid mlx5e_ptpsq_track_metadata(struct mlx5e_ptpsq *ptpsq, u8 metadata);\n\nenum {\n\tMLX5E_SKB_CB_CQE_HWTSTAMP  = BIT(0),\n\tMLX5E_SKB_CB_PORT_HWTSTAMP = BIT(1),\n};\n\nvoid mlx5e_skb_cb_hwtstamp_handler(struct sk_buff *skb, int hwtstamp_type,\n\t\t\t\t   ktime_t hwtstamp,\n\t\t\t\t   struct mlx5e_ptp_cq_stats *cq_stats);\n\nvoid mlx5e_skb_cb_hwtstamp_init(struct sk_buff *skb);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}