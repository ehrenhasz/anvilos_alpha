{
  "module_name": "police.c",
  "hash_id": "0182e24abc1eb389d9c7f57a1db26e8f9fa411c3e7f78625f4d7b4fcdedee720",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/police.c",
  "human_readable_source": "\n\n\n#include \"act.h\"\n#include \"en/tc_priv.h\"\n#include \"fs_core.h\"\n\nstatic bool police_act_validate_control(enum flow_action_id act_id,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (act_id != FLOW_ACTION_PIPE &&\n\t    act_id != FLOW_ACTION_ACCEPT &&\n\t    act_id != FLOW_ACTION_JUMP &&\n\t    act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform-exceed action is not pipe, ok, jump or drop\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int police_act_validate(const struct flow_action_entry *act,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (!police_act_validate_control(act->police.exceed.act_id, extack) ||\n\t    !police_act_validate_control(act->police.notexceed.act_id, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tif (act->police.peakrate_bytes_ps ||\n\t    act->police.avrate || act->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\ntc_act_can_offload_police(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t\t  const struct flow_action_entry *act,\n\t\t\t  int act_index,\n\t\t\t  struct mlx5_flow_attr *attr)\n{\n\tint err;\n\n\terr = police_act_validate(act, parse_state->extack);\n\tif (err)\n\t\treturn false;\n\n\treturn !!mlx5e_get_flow_meters(parse_state->flow->priv->mdev);\n}\n\nstatic int\nfill_meter_params_from_act(const struct flow_action_entry *act,\n\t\t\t   struct mlx5e_flow_meter_params *params)\n{\n\tparams->index = act->hw_index;\n\tif (act->police.rate_bytes_ps) {\n\t\tparams->mode = MLX5_RATE_LIMIT_BPS;\n\t\t \n\t\tparams->rate = act->police.rate_bytes_ps << 3;\n\t\tparams->burst = act->police.burst;\n\t} else if (act->police.rate_pkt_ps) {\n\t\tparams->mode = MLX5_RATE_LIMIT_PPS;\n\t\tparams->rate = act->police.rate_pkt_ps;\n\t\tparams->burst = act->police.burst_pkt;\n\t} else if (act->police.mtu) {\n\t\tparams->mtu = act->police.mtu;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ntc_act_parse_police(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t    const struct flow_action_entry *act,\n\t\t    struct mlx5e_priv *priv,\n\t\t    struct mlx5_flow_attr *attr)\n{\n\tenum mlx5_flow_namespace_type ns =  mlx5e_get_flow_namespace(parse_state->flow);\n\tstruct mlx5e_flow_meter_params *params = &attr->meter_attr.params;\n\tint err;\n\n\terr = fill_meter_params_from_act(act, params);\n\tif (err)\n\t\treturn err;\n\n\tif (params->mtu) {\n\t\tif (!(mlx5_fs_get_capabilities(priv->mdev, ns) &\n\t\t      MLX5_FLOW_STEERING_CAP_MATCH_RANGES))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t\tattr->flags |= MLX5_ATTR_FLAG_MTU;\n\t} else {\n\t\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_EXECUTE_ASO;\n\t\tattr->exe_aso_type = MLX5_EXE_ASO_FLOW_METER;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\ntc_act_is_multi_table_act_police(struct mlx5e_priv *priv,\n\t\t\t\t const struct flow_action_entry *act,\n\t\t\t\t struct mlx5_flow_attr *attr)\n{\n\treturn true;\n}\n\nstatic int\ntc_act_police_offload(struct mlx5e_priv *priv,\n\t\t      struct flow_offload_action *fl_act,\n\t\t      struct flow_action_entry *act)\n{\n\tstruct mlx5e_flow_meter_params params = {};\n\tstruct mlx5e_flow_meter_handle *meter;\n\tint err = 0;\n\n\terr = police_act_validate(act, fl_act->extack);\n\tif (err)\n\t\treturn err;\n\n\terr = fill_meter_params_from_act(act, &params);\n\tif (err)\n\t\treturn err;\n\n\tmeter = mlx5e_tc_meter_get(priv->mdev, &params);\n\tif (IS_ERR(meter) && PTR_ERR(meter) == -ENOENT) {\n\t\tmeter = mlx5e_tc_meter_replace(priv->mdev, &params);\n\t} else if (!IS_ERR(meter)) {\n\t\terr = mlx5e_tc_meter_update(meter, &params);\n\t\tmlx5e_tc_meter_put(meter);\n\t}\n\n\tif (IS_ERR(meter)) {\n\t\tNL_SET_ERR_MSG_MOD(fl_act->extack, \"Failed to get flow meter\");\n\t\tmlx5_core_err(priv->mdev, \"Failed to get flow meter %d\\n\", params.index);\n\t\terr = PTR_ERR(meter);\n\t}\n\n\treturn err;\n}\n\nstatic int\ntc_act_police_destroy(struct mlx5e_priv *priv,\n\t\t      struct flow_offload_action *fl_act)\n{\n\tstruct mlx5e_flow_meter_params params = {};\n\tstruct mlx5e_flow_meter_handle *meter;\n\n\tparams.index = fl_act->index;\n\tmeter = mlx5e_tc_meter_get(priv->mdev, &params);\n\tif (IS_ERR(meter)) {\n\t\tNL_SET_ERR_MSG_MOD(fl_act->extack, \"Failed to get flow meter\");\n\t\tmlx5_core_err(priv->mdev, \"Failed to get flow meter %d\\n\", params.index);\n\t\treturn PTR_ERR(meter);\n\t}\n\t \n\tmlx5e_tc_meter_put(meter);\n\tmlx5e_tc_meter_put(meter);\n\treturn 0;\n}\n\nstatic int\ntc_act_police_stats(struct mlx5e_priv *priv,\n\t\t    struct flow_offload_action *fl_act)\n{\n\tstruct mlx5e_flow_meter_params params = {};\n\tstruct mlx5e_flow_meter_handle *meter;\n\tu64 bytes, packets, drops, lastuse;\n\n\tparams.index = fl_act->index;\n\tmeter = mlx5e_tc_meter_get(priv->mdev, &params);\n\tif (IS_ERR(meter)) {\n\t\tNL_SET_ERR_MSG_MOD(fl_act->extack, \"Failed to get flow meter\");\n\t\treturn PTR_ERR(meter);\n\t}\n\n\tmlx5e_tc_meter_get_stats(meter, &bytes, &packets, &drops, &lastuse);\n\tflow_stats_update(&fl_act->stats, bytes, packets, drops, lastuse,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\tmlx5e_tc_meter_put(meter);\n\treturn 0;\n}\n\nstatic bool\ntc_act_police_get_branch_ctrl(const struct flow_action_entry *act,\n\t\t\t      struct mlx5e_tc_act_branch_ctrl *cond_true,\n\t\t\t      struct mlx5e_tc_act_branch_ctrl *cond_false)\n{\n\tcond_true->act_id = act->police.notexceed.act_id;\n\tcond_true->extval = act->police.notexceed.extval;\n\n\tcond_false->act_id = act->police.exceed.act_id;\n\tcond_false->extval = act->police.exceed.extval;\n\treturn true;\n}\n\nstruct mlx5e_tc_act mlx5e_tc_act_police = {\n\t.can_offload = tc_act_can_offload_police,\n\t.parse_action = tc_act_parse_police,\n\t.is_multi_table_act = tc_act_is_multi_table_act_police,\n\t.offload_action = tc_act_police_offload,\n\t.destroy_action = tc_act_police_destroy,\n\t.stats_action = tc_act_police_stats,\n\t.get_branch_ctrl = tc_act_police_get_branch_ctrl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}