{
  "module_name": "fs_cmd.c",
  "hash_id": "7139da4d35202c084110522ee207054a6fb973c4aad3473ad0ab637b10088923",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c",
  "human_readable_source": " \n\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/device.h>\n#include <linux/mlx5/mlx5_ifc.h>\n\n#include \"fs_core.h\"\n#include \"fs_cmd.h\"\n#include \"fs_ft_pool.h\"\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n\nstatic int mlx5_cmd_stub_update_root_ft(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\tstruct mlx5_flow_table *ft,\n\t\t\t\t\tu32 underlay_qpn,\n\t\t\t\t\tbool disconnect)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_create_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t   struct mlx5_flow_table *ft,\n\t\t\t\t\t   struct mlx5_flow_table_attr *ft_attr,\n\t\t\t\t\t   struct mlx5_flow_table *next_ft)\n{\n\tint max_fte = ft_attr->max_fte;\n\n\tft->max_fte = max_fte ? roundup_pow_of_two(max_fte) : 1;\n\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_destroy_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t    struct mlx5_flow_table *ft)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_modify_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t   struct mlx5_flow_table *ft,\n\t\t\t\t\t   struct mlx5_flow_table *next_ft)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_create_flow_group(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t   struct mlx5_flow_table *ft,\n\t\t\t\t\t   u32 *in,\n\t\t\t\t\t   struct mlx5_flow_group *fg)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_destroy_flow_group(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t    struct mlx5_flow_table *ft,\n\t\t\t\t\t    struct mlx5_flow_group *fg)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_create_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t    struct mlx5_flow_table *ft,\n\t\t\t\t    struct mlx5_flow_group *group,\n\t\t\t\t    struct fs_fte *fte)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_update_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t    struct mlx5_flow_table *ft,\n\t\t\t\t    struct mlx5_flow_group *group,\n\t\t\t\t    int modify_mask,\n\t\t\t\t    struct fs_fte *fte)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mlx5_cmd_stub_delete_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t    struct mlx5_flow_table *ft,\n\t\t\t\t    struct fs_fte *fte)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_packet_reformat_alloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t       struct mlx5_pkt_reformat_params *params,\n\t\t\t\t\t       enum mlx5_flow_namespace_type namespace,\n\t\t\t\t\t       struct mlx5_pkt_reformat *pkt_reformat)\n{\n\treturn 0;\n}\n\nstatic void mlx5_cmd_stub_packet_reformat_dealloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t\t  struct mlx5_pkt_reformat *pkt_reformat)\n{\n}\n\nstatic int mlx5_cmd_stub_modify_header_alloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t     u8 namespace, u8 num_actions,\n\t\t\t\t\t     void *modify_actions,\n\t\t\t\t\t     struct mlx5_modify_hdr *modify_hdr)\n{\n\treturn 0;\n}\n\nstatic void mlx5_cmd_stub_modify_header_dealloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t\tstruct mlx5_modify_hdr *modify_hdr)\n{\n}\n\nstatic int mlx5_cmd_stub_set_peer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t  struct mlx5_flow_root_namespace *peer_ns,\n\t\t\t\t  u16 peer_vhca_id)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_create_ns(struct mlx5_flow_root_namespace *ns)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_stub_destroy_ns(struct mlx5_flow_root_namespace *ns)\n{\n\treturn 0;\n}\n\nstatic u32 mlx5_cmd_stub_get_capabilities(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t  enum fs_flow_table_type ft_type)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_set_slave_root_fdb(struct mlx5_core_dev *master,\n\t\t\t\t       struct mlx5_core_dev *slave,\n\t\t\t\t       bool ft_id_valid,\n\t\t\t\t       u32 ft_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(set_flow_table_root_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(set_flow_table_root_in)] = {};\n\tstruct mlx5_flow_root_namespace *root;\n\tstruct mlx5_flow_namespace *ns;\n\n\tMLX5_SET(set_flow_table_root_in, in, opcode,\n\t\t MLX5_CMD_OP_SET_FLOW_TABLE_ROOT);\n\tMLX5_SET(set_flow_table_root_in, in, table_type,\n\t\t FS_FT_FDB);\n\tif (ft_id_valid) {\n\t\tMLX5_SET(set_flow_table_root_in, in,\n\t\t\t table_eswitch_owner_vhca_id_valid, 1);\n\t\tMLX5_SET(set_flow_table_root_in, in,\n\t\t\t table_eswitch_owner_vhca_id,\n\t\t\t MLX5_CAP_GEN(master, vhca_id));\n\t\tMLX5_SET(set_flow_table_root_in, in, table_id,\n\t\t\t ft_id);\n\t} else {\n\t\tns = mlx5_get_flow_namespace(slave,\n\t\t\t\t\t     MLX5_FLOW_NAMESPACE_FDB);\n\t\troot = find_root(&ns->node);\n\t\tMLX5_SET(set_flow_table_root_in, in, table_id,\n\t\t\t root->root_ft->id);\n\t}\n\n\treturn mlx5_cmd_exec(slave, in, sizeof(in), out, sizeof(out));\n}\n\nstatic int\nmlx5_cmd_stub_destroy_match_definer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t    int definer_id)\n{\n\treturn 0;\n}\n\nstatic int\nmlx5_cmd_stub_create_match_definer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t   u16 format_id, u32 *match_mask)\n{\n\treturn 0;\n}\n\nstatic int mlx5_cmd_update_root_ft(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t   struct mlx5_flow_table *ft, u32 underlay_qpn,\n\t\t\t\t   bool disconnect)\n{\n\tu32 in[MLX5_ST_SZ_DW(set_flow_table_root_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tint err;\n\n\tif ((MLX5_CAP_GEN(dev, port_type) == MLX5_CAP_PORT_TYPE_IB) &&\n\t    underlay_qpn == 0)\n\t\treturn 0;\n\n\tif (ft->type == FS_FT_FDB &&\n\t    mlx5_lag_is_shared_fdb(dev) &&\n\t    !mlx5_lag_is_master(dev))\n\t\treturn 0;\n\n\tMLX5_SET(set_flow_table_root_in, in, opcode,\n\t\t MLX5_CMD_OP_SET_FLOW_TABLE_ROOT);\n\tMLX5_SET(set_flow_table_root_in, in, table_type, ft->type);\n\n\tif (disconnect)\n\t\tMLX5_SET(set_flow_table_root_in, in, op_mod, 1);\n\telse\n\t\tMLX5_SET(set_flow_table_root_in, in, table_id, ft->id);\n\n\tMLX5_SET(set_flow_table_root_in, in, underlay_qpn, underlay_qpn);\n\tMLX5_SET(set_flow_table_root_in, in, vport_number, ft->vport);\n\tMLX5_SET(set_flow_table_root_in, in, other_vport,\n\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\n\terr = mlx5_cmd_exec_in(dev, set_flow_table_root, in);\n\tif (!err &&\n\t    ft->type == FS_FT_FDB &&\n\t    mlx5_lag_is_shared_fdb(dev) &&\n\t    mlx5_lag_is_master(dev)) {\n\t\tstruct mlx5_core_dev *peer_dev;\n\t\tint i, j;\n\n\t\tmlx5_lag_for_each_peer_mdev(dev, peer_dev, i) {\n\t\t\terr = mlx5_cmd_set_slave_root_fdb(dev, peer_dev, !disconnect,\n\t\t\t\t\t\t\t  (!disconnect) ? ft->id : 0);\n\t\t\tif (err && !disconnect) {\n\t\t\t\tmlx5_lag_for_each_peer_mdev(dev, peer_dev, j) {\n\t\t\t\t\tif (j < i)\n\t\t\t\t\t\tmlx5_cmd_set_slave_root_fdb(dev, peer_dev, 1,\n\t\t\t\t\t\t\t\t\t    ns->root_ft->id);\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tMLX5_SET(set_flow_table_root_in, in, op_mod, 0);\n\t\t\t\tMLX5_SET(set_flow_table_root_in, in, table_id,\n\t\t\t\t\t ns->root_ft->id);\n\t\t\t\tmlx5_cmd_exec_in(dev, set_flow_table_root, in);\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5_cmd_create_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t      struct mlx5_flow_table *ft,\n\t\t\t\t      struct mlx5_flow_table_attr *ft_attr,\n\t\t\t\t      struct mlx5_flow_table *next_ft)\n{\n\tint en_encap = !!(ft->flags & MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT);\n\tint en_decap = !!(ft->flags & MLX5_FLOW_TABLE_TUNNEL_EN_DECAP);\n\tint term = !!(ft->flags & MLX5_FLOW_TABLE_TERMINATION);\n\tu32 out[MLX5_ST_SZ_DW(create_flow_table_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(create_flow_table_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tunsigned int size;\n\tint err;\n\n\tsize = mlx5_ft_pool_get_avail_sz(dev, ft->type, ft_attr->max_fte);\n\tif (!size)\n\t\treturn -ENOSPC;\n\n\tMLX5_SET(create_flow_table_in, in, opcode,\n\t\t MLX5_CMD_OP_CREATE_FLOW_TABLE);\n\n\tMLX5_SET(create_flow_table_in, in, uid, ft_attr->uid);\n\tMLX5_SET(create_flow_table_in, in, table_type, ft->type);\n\tMLX5_SET(create_flow_table_in, in, flow_table_context.level, ft->level);\n\tMLX5_SET(create_flow_table_in, in, flow_table_context.log_size, size ? ilog2(size) : 0);\n\tMLX5_SET(create_flow_table_in, in, vport_number, ft->vport);\n\tMLX5_SET(create_flow_table_in, in, other_vport,\n\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\n\tMLX5_SET(create_flow_table_in, in, flow_table_context.decap_en,\n\t\t en_decap);\n\tMLX5_SET(create_flow_table_in, in, flow_table_context.reformat_en,\n\t\t en_encap);\n\tMLX5_SET(create_flow_table_in, in, flow_table_context.termination_table,\n\t\t term);\n\n\tswitch (ft->op_mod) {\n\tcase FS_FT_OP_MOD_NORMAL:\n\t\tif (next_ft) {\n\t\t\tMLX5_SET(create_flow_table_in, in,\n\t\t\t\t flow_table_context.table_miss_action,\n\t\t\t\t MLX5_FLOW_TABLE_MISS_ACTION_FWD);\n\t\t\tMLX5_SET(create_flow_table_in, in,\n\t\t\t\t flow_table_context.table_miss_id, next_ft->id);\n\t\t} else {\n\t\t\tMLX5_SET(create_flow_table_in, in,\n\t\t\t\t flow_table_context.table_miss_action,\n\t\t\t\t ft->def_miss_action);\n\t\t}\n\t\tbreak;\n\n\tcase FS_FT_OP_MOD_LAG_DEMUX:\n\t\tMLX5_SET(create_flow_table_in, in, op_mod, 0x1);\n\t\tif (next_ft)\n\t\t\tMLX5_SET(create_flow_table_in, in,\n\t\t\t\t flow_table_context.lag_master_next_table_id,\n\t\t\t\t next_ft->id);\n\t\tbreak;\n\t}\n\n\terr = mlx5_cmd_exec_inout(dev, create_flow_table, in, out);\n\tif (!err) {\n\t\tft->id = MLX5_GET(create_flow_table_out, out,\n\t\t\t\t  table_id);\n\t\tft->max_fte = size;\n\t} else {\n\t\tmlx5_ft_pool_put_sz(ns->dev, size);\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5_cmd_destroy_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t       struct mlx5_flow_table *ft)\n{\n\tu32 in[MLX5_ST_SZ_DW(destroy_flow_table_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tint err;\n\n\tMLX5_SET(destroy_flow_table_in, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_FLOW_TABLE);\n\tMLX5_SET(destroy_flow_table_in, in, table_type, ft->type);\n\tMLX5_SET(destroy_flow_table_in, in, table_id, ft->id);\n\tMLX5_SET(destroy_flow_table_in, in, vport_number, ft->vport);\n\tMLX5_SET(destroy_flow_table_in, in, other_vport,\n\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\n\terr = mlx5_cmd_exec_in(dev, destroy_flow_table, in);\n\tif (!err)\n\t\tmlx5_ft_pool_put_sz(ns->dev, ft->max_fte);\n\n\treturn err;\n}\n\nstatic int mlx5_cmd_modify_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t      struct mlx5_flow_table *ft,\n\t\t\t\t      struct mlx5_flow_table *next_ft)\n{\n\tu32 in[MLX5_ST_SZ_DW(modify_flow_table_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\n\tMLX5_SET(modify_flow_table_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_FLOW_TABLE);\n\tMLX5_SET(modify_flow_table_in, in, table_type, ft->type);\n\tMLX5_SET(modify_flow_table_in, in, table_id, ft->id);\n\n\tif (ft->op_mod == FS_FT_OP_MOD_LAG_DEMUX) {\n\t\tMLX5_SET(modify_flow_table_in, in, modify_field_select,\n\t\t\t MLX5_MODIFY_FLOW_TABLE_LAG_NEXT_TABLE_ID);\n\t\tif (next_ft) {\n\t\t\tMLX5_SET(modify_flow_table_in, in,\n\t\t\t\t flow_table_context.lag_master_next_table_id, next_ft->id);\n\t\t} else {\n\t\t\tMLX5_SET(modify_flow_table_in, in,\n\t\t\t\t flow_table_context.lag_master_next_table_id, 0);\n\t\t}\n\t} else {\n\t\tMLX5_SET(modify_flow_table_in, in, vport_number, ft->vport);\n\t\tMLX5_SET(modify_flow_table_in, in, other_vport,\n\t\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\t\tMLX5_SET(modify_flow_table_in, in, modify_field_select,\n\t\t\t MLX5_MODIFY_FLOW_TABLE_MISS_TABLE_ID);\n\t\tif (next_ft) {\n\t\t\tMLX5_SET(modify_flow_table_in, in,\n\t\t\t\t flow_table_context.table_miss_action,\n\t\t\t\t MLX5_FLOW_TABLE_MISS_ACTION_FWD);\n\t\t\tMLX5_SET(modify_flow_table_in, in,\n\t\t\t\t flow_table_context.table_miss_id,\n\t\t\t\t next_ft->id);\n\t\t} else {\n\t\t\tMLX5_SET(modify_flow_table_in, in,\n\t\t\t\t flow_table_context.table_miss_action,\n\t\t\t\t ft->def_miss_action);\n\t\t}\n\t}\n\n\treturn mlx5_cmd_exec_in(dev, modify_flow_table, in);\n}\n\nstatic int mlx5_cmd_create_flow_group(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t      struct mlx5_flow_table *ft,\n\t\t\t\t      u32 *in,\n\t\t\t\t      struct mlx5_flow_group *fg)\n{\n\tu32 out[MLX5_ST_SZ_DW(create_flow_group_out)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tint err;\n\n\tMLX5_SET(create_flow_group_in, in, opcode,\n\t\t MLX5_CMD_OP_CREATE_FLOW_GROUP);\n\tMLX5_SET(create_flow_group_in, in, table_type, ft->type);\n\tMLX5_SET(create_flow_group_in, in, table_id, ft->id);\n\tMLX5_SET(create_flow_group_in, in, vport_number, ft->vport);\n\tMLX5_SET(create_flow_group_in, in, other_vport,\n\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\terr = mlx5_cmd_exec_inout(dev, create_flow_group, in, out);\n\tif (!err)\n\t\tfg->id = MLX5_GET(create_flow_group_out, out,\n\t\t\t\t  group_id);\n\treturn err;\n}\n\nstatic int mlx5_cmd_destroy_flow_group(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t       struct mlx5_flow_table *ft,\n\t\t\t\t       struct mlx5_flow_group *fg)\n{\n\tu32 in[MLX5_ST_SZ_DW(destroy_flow_group_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\n\tMLX5_SET(destroy_flow_group_in, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_FLOW_GROUP);\n\tMLX5_SET(destroy_flow_group_in, in, table_type, ft->type);\n\tMLX5_SET(destroy_flow_group_in, in, table_id, ft->id);\n\tMLX5_SET(destroy_flow_group_in, in, group_id, fg->id);\n\tMLX5_SET(destroy_flow_group_in, in, vport_number, ft->vport);\n\tMLX5_SET(destroy_flow_group_in, in, other_vport,\n\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\treturn mlx5_cmd_exec_in(dev, destroy_flow_group, in);\n}\n\nstatic int mlx5_set_extended_dest(struct mlx5_core_dev *dev,\n\t\t\t\t  struct fs_fte *fte, bool *extended_dest)\n{\n\tint fw_log_max_fdb_encap_uplink =\n\t\tMLX5_CAP_ESW(dev, log_max_fdb_encap_uplink);\n\tint num_fwd_destinations = 0;\n\tstruct mlx5_flow_rule *dst;\n\tint num_encap = 0;\n\n\t*extended_dest = false;\n\tif (!(fte->action.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST))\n\t\treturn 0;\n\n\tlist_for_each_entry(dst, &fte->node.children, node.list) {\n\t\tif (dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_COUNTER ||\n\t\t    dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_NONE)\n\t\t\tcontinue;\n\t\tif ((dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_VPORT ||\n\t\t     dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_UPLINK) &&\n\t\t    dst->dest_attr.vport.flags & MLX5_FLOW_DEST_VPORT_REFORMAT_ID)\n\t\t\tnum_encap++;\n\t\tnum_fwd_destinations++;\n\t}\n\tif (num_fwd_destinations > 1 && num_encap > 0)\n\t\t*extended_dest = true;\n\n\tif (*extended_dest && !fw_log_max_fdb_encap_uplink) {\n\t\tmlx5_core_warn(dev, \"FW does not support extended destination\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (num_encap > (1 << fw_log_max_fdb_encap_uplink)) {\n\t\tmlx5_core_warn(dev, \"FW does not support more than %d encaps\",\n\t\t\t       1 << fw_log_max_fdb_encap_uplink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmlx5_cmd_set_fte_flow_meter(struct fs_fte *fte, void *in_flow_context)\n{\n\tvoid *exe_aso_ctrl;\n\tvoid *execute_aso;\n\n\texecute_aso = MLX5_ADDR_OF(flow_context, in_flow_context,\n\t\t\t\t   execute_aso[0]);\n\tMLX5_SET(execute_aso, execute_aso, valid, 1);\n\tMLX5_SET(execute_aso, execute_aso, aso_object_id,\n\t\t fte->action.exe_aso.object_id);\n\n\texe_aso_ctrl = MLX5_ADDR_OF(execute_aso, execute_aso, exe_aso_ctrl);\n\tMLX5_SET(exe_aso_ctrl_flow_meter, exe_aso_ctrl, return_reg_id,\n\t\t fte->action.exe_aso.return_reg_id);\n\tMLX5_SET(exe_aso_ctrl_flow_meter, exe_aso_ctrl, aso_type,\n\t\t fte->action.exe_aso.type);\n\tMLX5_SET(exe_aso_ctrl_flow_meter, exe_aso_ctrl, init_color,\n\t\t fte->action.exe_aso.flow_meter.init_color);\n\tMLX5_SET(exe_aso_ctrl_flow_meter, exe_aso_ctrl, meter_id,\n\t\t fte->action.exe_aso.flow_meter.meter_idx);\n}\n\nstatic int mlx5_cmd_set_fte(struct mlx5_core_dev *dev,\n\t\t\t    int opmod, int modify_mask,\n\t\t\t    struct mlx5_flow_table *ft,\n\t\t\t    unsigned group_id,\n\t\t\t    struct fs_fte *fte)\n{\n\tu32 out[MLX5_ST_SZ_DW(set_fte_out)] = {0};\n\tbool extended_dest = false;\n\tstruct mlx5_flow_rule *dst;\n\tvoid *in_flow_context, *vlan;\n\tvoid *in_match_value;\n\tint reformat_id = 0;\n\tunsigned int inlen;\n\tint dst_cnt_size;\n\tu32 *in, action;\n\tvoid *in_dests;\n\tint err;\n\n\tif (mlx5_set_extended_dest(dev, fte, &extended_dest))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!extended_dest)\n\t\tdst_cnt_size = MLX5_ST_SZ_BYTES(dest_format_struct);\n\telse\n\t\tdst_cnt_size = MLX5_ST_SZ_BYTES(extended_dest_format);\n\n\tinlen = MLX5_ST_SZ_BYTES(set_fte_in) + fte->dests_size * dst_cnt_size;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(set_fte_in, in, opcode, MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY);\n\tMLX5_SET(set_fte_in, in, op_mod, opmod);\n\tMLX5_SET(set_fte_in, in, modify_enable_mask, modify_mask);\n\tMLX5_SET(set_fte_in, in, table_type, ft->type);\n\tMLX5_SET(set_fte_in, in, table_id,   ft->id);\n\tMLX5_SET(set_fte_in, in, flow_index, fte->index);\n\tMLX5_SET(set_fte_in, in, ignore_flow_level,\n\t\t !!(fte->action.flags & FLOW_ACT_IGNORE_FLOW_LEVEL));\n\n\tMLX5_SET(set_fte_in, in, vport_number, ft->vport);\n\tMLX5_SET(set_fte_in, in, other_vport,\n\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\n\tin_flow_context = MLX5_ADDR_OF(set_fte_in, in, flow_context);\n\tMLX5_SET(flow_context, in_flow_context, group_id, group_id);\n\n\tMLX5_SET(flow_context, in_flow_context, flow_tag,\n\t\t fte->flow_context.flow_tag);\n\tMLX5_SET(flow_context, in_flow_context, flow_source,\n\t\t fte->flow_context.flow_source);\n\n\tMLX5_SET(flow_context, in_flow_context, extended_destination,\n\t\t extended_dest);\n\n\taction = fte->action.action;\n\tif (extended_dest)\n\t\taction &= ~MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\n\tMLX5_SET(flow_context, in_flow_context, action, action);\n\n\tif (!extended_dest && fte->action.pkt_reformat) {\n\t\tstruct mlx5_pkt_reformat *pkt_reformat = fte->action.pkt_reformat;\n\n\t\tif (pkt_reformat->owner == MLX5_FLOW_RESOURCE_OWNER_SW) {\n\t\t\treformat_id = mlx5_fs_dr_action_get_pkt_reformat_id(pkt_reformat);\n\t\t\tif (reformat_id < 0) {\n\t\t\t\tmlx5_core_err(dev,\n\t\t\t\t\t      \"Unsupported SW-owned pkt_reformat type (%d) in FW-owned table\\n\",\n\t\t\t\t\t      pkt_reformat->reformat_type);\n\t\t\t\terr = reformat_id;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else {\n\t\t\treformat_id = fte->action.pkt_reformat->id;\n\t\t}\n\t}\n\n\tMLX5_SET(flow_context, in_flow_context, packet_reformat_id, (u32)reformat_id);\n\n\tif (fte->action.modify_hdr) {\n\t\tif (fte->action.modify_hdr->owner == MLX5_FLOW_RESOURCE_OWNER_SW) {\n\t\t\tmlx5_core_err(dev, \"Can't use SW-owned modify_hdr in FW-owned table\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tMLX5_SET(flow_context, in_flow_context, modify_header_id,\n\t\t\t fte->action.modify_hdr->id);\n\t}\n\n\tMLX5_SET(flow_context, in_flow_context, encrypt_decrypt_type,\n\t\t fte->action.crypto.type);\n\tMLX5_SET(flow_context, in_flow_context, encrypt_decrypt_obj_id,\n\t\t fte->action.crypto.obj_id);\n\n\tvlan = MLX5_ADDR_OF(flow_context, in_flow_context, push_vlan);\n\n\tMLX5_SET(vlan, vlan, ethtype, fte->action.vlan[0].ethtype);\n\tMLX5_SET(vlan, vlan, vid, fte->action.vlan[0].vid);\n\tMLX5_SET(vlan, vlan, prio, fte->action.vlan[0].prio);\n\n\tvlan = MLX5_ADDR_OF(flow_context, in_flow_context, push_vlan_2);\n\n\tMLX5_SET(vlan, vlan, ethtype, fte->action.vlan[1].ethtype);\n\tMLX5_SET(vlan, vlan, vid, fte->action.vlan[1].vid);\n\tMLX5_SET(vlan, vlan, prio, fte->action.vlan[1].prio);\n\n\tin_match_value = MLX5_ADDR_OF(flow_context, in_flow_context,\n\t\t\t\t      match_value);\n\tmemcpy(in_match_value, &fte->val, sizeof(fte->val));\n\n\tin_dests = MLX5_ADDR_OF(flow_context, in_flow_context, destination);\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {\n\t\tint list_size = 0;\n\n\t\tlist_for_each_entry(dst, &fte->node.children, node.list) {\n\t\t\tenum mlx5_flow_destination_type type = dst->dest_attr.type;\n\t\t\tenum mlx5_ifc_flow_destination_type ifc_type;\n\t\t\tunsigned int id;\n\n\t\t\tif (type == MLX5_FLOW_DESTINATION_TYPE_COUNTER)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (type) {\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_NONE:\n\t\t\t\tcontinue;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE_NUM:\n\t\t\t\tid = dst->dest_attr.ft_num;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE:\n\t\t\t\tid = dst->dest_attr.ft->id;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_UPLINK:\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_VPORT:\n\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t destination_eswitch_owner_vhca_id_valid,\n\t\t\t\t\t !!(dst->dest_attr.vport.flags &\n\t\t\t\t\t    MLX5_FLOW_DEST_VPORT_VHCA_ID));\n\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t destination_eswitch_owner_vhca_id,\n\t\t\t\t\t dst->dest_attr.vport.vhca_id);\n\t\t\t\tif (type == MLX5_FLOW_DESTINATION_TYPE_UPLINK) {\n\t\t\t\t\t \n\t\t\t\t\tid = 0;\n\t\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_UPLINK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_VPORT;\n\t\t\t\tid = dst->dest_attr.vport.num;\n\t\t\t\tif (extended_dest &&\n\t\t\t\t    dst->dest_attr.vport.pkt_reformat) {\n\t\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t\t packet_reformat,\n\t\t\t\t\t\t !!(dst->dest_attr.vport.flags &\n\t\t\t\t\t\t    MLX5_FLOW_DEST_VPORT_REFORMAT_ID));\n\t\t\t\t\tMLX5_SET(extended_dest_format, in_dests,\n\t\t\t\t\t\t packet_reformat_id,\n\t\t\t\t\t\t dst->dest_attr.vport.pkt_reformat->id);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_SAMPLER:\n\t\t\t\tid = dst->dest_attr.sampler_id;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_FLOW_SAMPLER;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_TABLE_TYPE:\n\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t destination_table_type, dst->dest_attr.ft->type);\n\t\t\t\tid = dst->dest_attr.ft->id;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_TABLE_TYPE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tid = dst->dest_attr.tir_num;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_TIR;\n\t\t\t}\n\n\t\t\tMLX5_SET(dest_format_struct, in_dests, destination_type,\n\t\t\t\t ifc_type);\n\t\t\tMLX5_SET(dest_format_struct, in_dests, destination_id, id);\n\t\t\tin_dests += dst_cnt_size;\n\t\t\tlist_size++;\n\t\t}\n\n\t\tMLX5_SET(flow_context, in_flow_context, destination_list_size,\n\t\t\t list_size);\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\tint max_list_size = BIT(MLX5_CAP_FLOWTABLE_TYPE(dev,\n\t\t\t\t\tlog_max_flow_counter,\n\t\t\t\t\tft->type));\n\t\tint list_size = 0;\n\n\t\tlist_for_each_entry(dst, &fte->node.children, node.list) {\n\t\t\tif (dst->dest_attr.type !=\n\t\t\t    MLX5_FLOW_DESTINATION_TYPE_COUNTER)\n\t\t\t\tcontinue;\n\n\t\t\tMLX5_SET(flow_counter_list, in_dests, flow_counter_id,\n\t\t\t\t dst->dest_attr.counter_id);\n\t\t\tin_dests += dst_cnt_size;\n\t\t\tlist_size++;\n\t\t}\n\t\tif (list_size > max_list_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tMLX5_SET(flow_context, in_flow_context, flow_counter_list_size,\n\t\t\t list_size);\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_EXECUTE_ASO) {\n\t\tif (fte->action.exe_aso.type == MLX5_EXE_ASO_FLOW_METER) {\n\t\t\tmlx5_cmd_set_fte_flow_meter(fte, in_flow_context);\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\terr = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));\nerr_out:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int mlx5_cmd_create_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t       struct mlx5_flow_table *ft,\n\t\t\t       struct mlx5_flow_group *group,\n\t\t\t       struct fs_fte *fte)\n{\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tunsigned int group_id = group->id;\n\n\treturn mlx5_cmd_set_fte(dev, 0, 0, ft, group_id, fte);\n}\n\nstatic int mlx5_cmd_update_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t       struct mlx5_flow_table *ft,\n\t\t\t       struct mlx5_flow_group *fg,\n\t\t\t       int modify_mask,\n\t\t\t       struct fs_fte *fte)\n{\n\tint opmod;\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tint atomic_mod_cap = MLX5_CAP_FLOWTABLE(dev,\n\t\t\t\t\t\tflow_table_properties_nic_receive.\n\t\t\t\t\t\tflow_modify_en);\n\tif (!atomic_mod_cap)\n\t\treturn -EOPNOTSUPP;\n\topmod = 1;\n\n\treturn\tmlx5_cmd_set_fte(dev, opmod, modify_mask, ft, fg->id, fte);\n}\n\nstatic int mlx5_cmd_delete_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t       struct mlx5_flow_table *ft,\n\t\t\t       struct fs_fte *fte)\n{\n\tu32 in[MLX5_ST_SZ_DW(delete_fte_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\n\tMLX5_SET(delete_fte_in, in, opcode, MLX5_CMD_OP_DELETE_FLOW_TABLE_ENTRY);\n\tMLX5_SET(delete_fte_in, in, table_type, ft->type);\n\tMLX5_SET(delete_fte_in, in, table_id, ft->id);\n\tMLX5_SET(delete_fte_in, in, flow_index, fte->index);\n\tMLX5_SET(delete_fte_in, in, vport_number, ft->vport);\n\tMLX5_SET(delete_fte_in, in, other_vport,\n\t\t !!(ft->flags & MLX5_FLOW_TABLE_OTHER_VPORT));\n\n\treturn mlx5_cmd_exec_in(dev, delete_fte, in);\n}\n\nint mlx5_cmd_fc_bulk_alloc(struct mlx5_core_dev *dev,\n\t\t\t   enum mlx5_fc_bulk_alloc_bitmask alloc_bitmask,\n\t\t\t   u32 *id)\n{\n\tu32 out[MLX5_ST_SZ_DW(alloc_flow_counter_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(alloc_flow_counter_in)] = {};\n\tint err;\n\n\tMLX5_SET(alloc_flow_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_ALLOC_FLOW_COUNTER);\n\tMLX5_SET(alloc_flow_counter_in, in, flow_counter_bulk, alloc_bitmask);\n\n\terr = mlx5_cmd_exec_inout(dev, alloc_flow_counter, in, out);\n\tif (!err)\n\t\t*id = MLX5_GET(alloc_flow_counter_out, out, flow_counter_id);\n\treturn err;\n}\n\nint mlx5_cmd_fc_alloc(struct mlx5_core_dev *dev, u32 *id)\n{\n\treturn mlx5_cmd_fc_bulk_alloc(dev, 0, id);\n}\n\nint mlx5_cmd_fc_free(struct mlx5_core_dev *dev, u32 id)\n{\n\tu32 in[MLX5_ST_SZ_DW(dealloc_flow_counter_in)] = {};\n\n\tMLX5_SET(dealloc_flow_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_DEALLOC_FLOW_COUNTER);\n\tMLX5_SET(dealloc_flow_counter_in, in, flow_counter_id, id);\n\treturn mlx5_cmd_exec_in(dev, dealloc_flow_counter, in);\n}\n\nint mlx5_cmd_fc_query(struct mlx5_core_dev *dev, u32 id,\n\t\t      u64 *packets, u64 *bytes)\n{\n\tu32 out[MLX5_ST_SZ_BYTES(query_flow_counter_out) +\n\t\tMLX5_ST_SZ_BYTES(traffic_counter)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_flow_counter_in)] = {};\n\tvoid *stats;\n\tint err = 0;\n\n\tMLX5_SET(query_flow_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_FLOW_COUNTER);\n\tMLX5_SET(query_flow_counter_in, in, op_mod, 0);\n\tMLX5_SET(query_flow_counter_in, in, flow_counter_id, id);\n\terr = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tstats = MLX5_ADDR_OF(query_flow_counter_out, out, flow_statistics);\n\t*packets = MLX5_GET64(traffic_counter, stats, packets);\n\t*bytes = MLX5_GET64(traffic_counter, stats, octets);\n\treturn 0;\n}\n\nint mlx5_cmd_fc_get_bulk_query_out_len(int bulk_len)\n{\n\treturn MLX5_ST_SZ_BYTES(query_flow_counter_out) +\n\t\tMLX5_ST_SZ_BYTES(traffic_counter) * bulk_len;\n}\n\nint mlx5_cmd_fc_bulk_query(struct mlx5_core_dev *dev, u32 base_id, int bulk_len,\n\t\t\t   u32 *out)\n{\n\tint outlen = mlx5_cmd_fc_get_bulk_query_out_len(bulk_len);\n\tu32 in[MLX5_ST_SZ_DW(query_flow_counter_in)] = {};\n\n\tMLX5_SET(query_flow_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_FLOW_COUNTER);\n\tMLX5_SET(query_flow_counter_in, in, flow_counter_id, base_id);\n\tMLX5_SET(query_flow_counter_in, in, num_of_counters, bulk_len);\n\treturn mlx5_cmd_exec(dev, in, sizeof(in), out, outlen);\n}\n\nstatic int mlx5_cmd_packet_reformat_alloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t  struct mlx5_pkt_reformat_params *params,\n\t\t\t\t\t  enum mlx5_flow_namespace_type namespace,\n\t\t\t\t\t  struct mlx5_pkt_reformat *pkt_reformat)\n{\n\tu32 out[MLX5_ST_SZ_DW(alloc_packet_reformat_context_out)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tvoid *packet_reformat_context_in;\n\tint max_encap_size;\n\tvoid *reformat;\n\tint inlen;\n\tint err;\n\tu32 *in;\n\n\tif (namespace == MLX5_FLOW_NAMESPACE_FDB ||\n\t    namespace == MLX5_FLOW_NAMESPACE_FDB_BYPASS)\n\t\tmax_encap_size = MLX5_CAP_ESW(dev, max_encap_header_size);\n\telse\n\t\tmax_encap_size = MLX5_CAP_FLOWTABLE(dev, max_encap_header_size);\n\n\tif (params->size > max_encap_size) {\n\t\tmlx5_core_warn(dev, \"encap size %zd too big, max supported is %d\\n\",\n\t\t\t       params->size, max_encap_size);\n\t\treturn -EINVAL;\n\t}\n\n\tin = kzalloc(MLX5_ST_SZ_BYTES(alloc_packet_reformat_context_in) +\n\t\t     params->size, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tpacket_reformat_context_in = MLX5_ADDR_OF(alloc_packet_reformat_context_in,\n\t\t\t\t\t\t  in, packet_reformat_context);\n\treformat = MLX5_ADDR_OF(packet_reformat_context_in,\n\t\t\t\tpacket_reformat_context_in,\n\t\t\t\treformat_data);\n\tinlen = reformat - (void *)in + params->size;\n\n\tMLX5_SET(alloc_packet_reformat_context_in, in, opcode,\n\t\t MLX5_CMD_OP_ALLOC_PACKET_REFORMAT_CONTEXT);\n\tMLX5_SET(packet_reformat_context_in, packet_reformat_context_in,\n\t\t reformat_data_size, params->size);\n\tMLX5_SET(packet_reformat_context_in, packet_reformat_context_in,\n\t\t reformat_type, params->type);\n\tMLX5_SET(packet_reformat_context_in, packet_reformat_context_in,\n\t\t reformat_param_0, params->param_0);\n\tMLX5_SET(packet_reformat_context_in, packet_reformat_context_in,\n\t\t reformat_param_1, params->param_1);\n\tif (params->data && params->size)\n\t\tmemcpy(reformat, params->data, params->size);\n\n\terr = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));\n\n\tpkt_reformat->id = MLX5_GET(alloc_packet_reformat_context_out,\n\t\t\t\t    out, packet_reformat_id);\n\tpkt_reformat->owner = MLX5_FLOW_RESOURCE_OWNER_FW;\n\n\tkfree(in);\n\treturn err;\n}\n\nstatic void mlx5_cmd_packet_reformat_dealloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t     struct mlx5_pkt_reformat *pkt_reformat)\n{\n\tu32 in[MLX5_ST_SZ_DW(dealloc_packet_reformat_context_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\n\tMLX5_SET(dealloc_packet_reformat_context_in, in, opcode,\n\t\t MLX5_CMD_OP_DEALLOC_PACKET_REFORMAT_CONTEXT);\n\tMLX5_SET(dealloc_packet_reformat_context_in, in, packet_reformat_id,\n\t\t pkt_reformat->id);\n\n\tmlx5_cmd_exec_in(dev, dealloc_packet_reformat_context, in);\n}\n\nstatic int mlx5_cmd_modify_header_alloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\tu8 namespace, u8 num_actions,\n\t\t\t\t\tvoid *modify_actions,\n\t\t\t\t\tstruct mlx5_modify_hdr *modify_hdr)\n{\n\tu32 out[MLX5_ST_SZ_DW(alloc_modify_header_context_out)] = {};\n\tint max_actions, actions_size, inlen, err;\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tvoid *actions_in;\n\tu8 table_type;\n\tu32 *in;\n\n\tswitch (namespace) {\n\tcase MLX5_FLOW_NAMESPACE_FDB:\n\tcase MLX5_FLOW_NAMESPACE_FDB_BYPASS:\n\t\tmax_actions = MLX5_CAP_ESW_FLOWTABLE_FDB(dev, max_modify_header_actions);\n\t\ttable_type = FS_FT_FDB;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_KERNEL_RX_MACSEC:\n\tcase MLX5_FLOW_NAMESPACE_KERNEL:\n\tcase MLX5_FLOW_NAMESPACE_BYPASS:\n\t\tmax_actions = MLX5_CAP_FLOWTABLE_NIC_RX(dev, max_modify_header_actions);\n\t\ttable_type = FS_FT_NIC_RX;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_EGRESS:\n\tcase MLX5_FLOW_NAMESPACE_EGRESS_IPSEC:\n\tcase MLX5_FLOW_NAMESPACE_EGRESS_MACSEC:\n\t\tmax_actions = MLX5_CAP_FLOWTABLE_NIC_TX(dev, max_modify_header_actions);\n\t\ttable_type = FS_FT_NIC_TX;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_ESW_INGRESS:\n\t\tmax_actions = MLX5_CAP_ESW_INGRESS_ACL(dev, max_modify_header_actions);\n\t\ttable_type = FS_FT_ESW_INGRESS_ACL;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_RDMA_TX_MACSEC:\n\tcase MLX5_FLOW_NAMESPACE_RDMA_TX:\n\t\tmax_actions = MLX5_CAP_FLOWTABLE_RDMA_TX(dev, max_modify_header_actions);\n\t\ttable_type = FS_FT_RDMA_TX;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (num_actions > max_actions) {\n\t\tmlx5_core_warn(dev, \"too many modify header actions %d, max supported %d\\n\",\n\t\t\t       num_actions, max_actions);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tactions_size = MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto) * num_actions;\n\tinlen = MLX5_ST_SZ_BYTES(alloc_modify_header_context_in) + actions_size;\n\n\tin = kzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(alloc_modify_header_context_in, in, opcode,\n\t\t MLX5_CMD_OP_ALLOC_MODIFY_HEADER_CONTEXT);\n\tMLX5_SET(alloc_modify_header_context_in, in, table_type, table_type);\n\tMLX5_SET(alloc_modify_header_context_in, in, num_of_actions, num_actions);\n\n\tactions_in = MLX5_ADDR_OF(alloc_modify_header_context_in, in, actions);\n\tmemcpy(actions_in, modify_actions, actions_size);\n\n\terr = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));\n\n\tmodify_hdr->id = MLX5_GET(alloc_modify_header_context_out, out, modify_header_id);\n\tmodify_hdr->owner = MLX5_FLOW_RESOURCE_OWNER_FW;\n\tkfree(in);\n\treturn err;\n}\n\nstatic void mlx5_cmd_modify_header_dealloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t   struct mlx5_modify_hdr *modify_hdr)\n{\n\tu32 in[MLX5_ST_SZ_DW(dealloc_modify_header_context_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\n\tMLX5_SET(dealloc_modify_header_context_in, in, opcode,\n\t\t MLX5_CMD_OP_DEALLOC_MODIFY_HEADER_CONTEXT);\n\tMLX5_SET(dealloc_modify_header_context_in, in, modify_header_id,\n\t\t modify_hdr->id);\n\n\tmlx5_cmd_exec_in(dev, dealloc_modify_header_context, in);\n}\n\nstatic int mlx5_cmd_destroy_match_definer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t  int definer_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_OBJ_TYPE_MATCH_DEFINER);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, definer_id);\n\n\treturn mlx5_cmd_exec(ns->dev, in, sizeof(in), out, sizeof(out));\n}\n\nstatic int mlx5_cmd_create_match_definer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t u16 format_id, u32 *match_mask)\n{\n\tu32 out[MLX5_ST_SZ_DW(create_match_definer_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(create_match_definer_in)] = {};\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tvoid *ptr;\n\tint err;\n\n\tMLX5_SET(create_match_definer_in, in, general_obj_in_cmd_hdr.opcode,\n\t\t MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(create_match_definer_in, in, general_obj_in_cmd_hdr.obj_type,\n\t\t MLX5_OBJ_TYPE_MATCH_DEFINER);\n\n\tptr = MLX5_ADDR_OF(create_match_definer_in, in, obj_context);\n\tMLX5_SET(match_definer, ptr, format_id, format_id);\n\n\tptr = MLX5_ADDR_OF(match_definer, ptr, match_mask);\n\tmemcpy(ptr, match_mask, MLX5_FLD_SZ_BYTES(match_definer, match_mask));\n\n\terr = mlx5_cmd_exec_inout(dev, create_match_definer, in, out);\n\treturn err ? err : MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n}\n\nstatic u32 mlx5_cmd_get_capabilities(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t     enum fs_flow_table_type ft_type)\n{\n\treturn 0;\n}\n\nstatic const struct mlx5_flow_cmds mlx5_flow_cmds = {\n\t.create_flow_table = mlx5_cmd_create_flow_table,\n\t.destroy_flow_table = mlx5_cmd_destroy_flow_table,\n\t.modify_flow_table = mlx5_cmd_modify_flow_table,\n\t.create_flow_group = mlx5_cmd_create_flow_group,\n\t.destroy_flow_group = mlx5_cmd_destroy_flow_group,\n\t.create_fte = mlx5_cmd_create_fte,\n\t.update_fte = mlx5_cmd_update_fte,\n\t.delete_fte = mlx5_cmd_delete_fte,\n\t.update_root_ft = mlx5_cmd_update_root_ft,\n\t.packet_reformat_alloc = mlx5_cmd_packet_reformat_alloc,\n\t.packet_reformat_dealloc = mlx5_cmd_packet_reformat_dealloc,\n\t.modify_header_alloc = mlx5_cmd_modify_header_alloc,\n\t.modify_header_dealloc = mlx5_cmd_modify_header_dealloc,\n\t.create_match_definer = mlx5_cmd_create_match_definer,\n\t.destroy_match_definer = mlx5_cmd_destroy_match_definer,\n\t.set_peer = mlx5_cmd_stub_set_peer,\n\t.create_ns = mlx5_cmd_stub_create_ns,\n\t.destroy_ns = mlx5_cmd_stub_destroy_ns,\n\t.get_capabilities = mlx5_cmd_get_capabilities,\n};\n\nstatic const struct mlx5_flow_cmds mlx5_flow_cmd_stubs = {\n\t.create_flow_table = mlx5_cmd_stub_create_flow_table,\n\t.destroy_flow_table = mlx5_cmd_stub_destroy_flow_table,\n\t.modify_flow_table = mlx5_cmd_stub_modify_flow_table,\n\t.create_flow_group = mlx5_cmd_stub_create_flow_group,\n\t.destroy_flow_group = mlx5_cmd_stub_destroy_flow_group,\n\t.create_fte = mlx5_cmd_stub_create_fte,\n\t.update_fte = mlx5_cmd_stub_update_fte,\n\t.delete_fte = mlx5_cmd_stub_delete_fte,\n\t.update_root_ft = mlx5_cmd_stub_update_root_ft,\n\t.packet_reformat_alloc = mlx5_cmd_stub_packet_reformat_alloc,\n\t.packet_reformat_dealloc = mlx5_cmd_stub_packet_reformat_dealloc,\n\t.modify_header_alloc = mlx5_cmd_stub_modify_header_alloc,\n\t.modify_header_dealloc = mlx5_cmd_stub_modify_header_dealloc,\n\t.create_match_definer = mlx5_cmd_stub_create_match_definer,\n\t.destroy_match_definer = mlx5_cmd_stub_destroy_match_definer,\n\t.set_peer = mlx5_cmd_stub_set_peer,\n\t.create_ns = mlx5_cmd_stub_create_ns,\n\t.destroy_ns = mlx5_cmd_stub_destroy_ns,\n\t.get_capabilities = mlx5_cmd_stub_get_capabilities,\n};\n\nconst struct mlx5_flow_cmds *mlx5_fs_cmd_get_fw_cmds(void)\n{\n\treturn &mlx5_flow_cmds;\n}\n\nstatic const struct mlx5_flow_cmds *mlx5_fs_cmd_get_stub_cmds(void)\n{\n\treturn &mlx5_flow_cmd_stubs;\n}\n\nconst struct mlx5_flow_cmds *mlx5_fs_cmd_get_default(enum fs_flow_table_type type)\n{\n\tswitch (type) {\n\tcase FS_FT_NIC_RX:\n\tcase FS_FT_ESW_EGRESS_ACL:\n\tcase FS_FT_ESW_INGRESS_ACL:\n\tcase FS_FT_FDB:\n\tcase FS_FT_SNIFFER_RX:\n\tcase FS_FT_SNIFFER_TX:\n\tcase FS_FT_NIC_TX:\n\tcase FS_FT_RDMA_RX:\n\tcase FS_FT_RDMA_TX:\n\tcase FS_FT_PORT_SEL:\n\t\treturn mlx5_fs_cmd_get_fw_cmds();\n\tdefault:\n\t\treturn mlx5_fs_cmd_get_stub_cmds();\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}