{
  "module_name": "en_ethtool.c",
  "hash_id": "4499fe4477b48d150adcf1d8970db4aa75c4086adfd584a9b5233b5f62306473",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c",
  "human_readable_source": " \n\n#include <linux/ethtool_netlink.h>\n\n#include \"en.h\"\n#include \"en/port.h\"\n#include \"en/params.h\"\n#include \"en/ptp.h\"\n#include \"lib/clock.h\"\n#include \"en/fs_ethtool.h\"\n\nvoid mlx5e_ethtool_get_drvinfo(struct mlx5e_priv *priv,\n\t\t\t       struct ethtool_drvinfo *drvinfo)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint count;\n\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME, sizeof(drvinfo->driver));\n\tcount = snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t\t \"%d.%d.%04d (%.16s)\", fw_rev_maj(mdev),\n\t\t\t fw_rev_min(mdev), fw_rev_sub(mdev), mdev->board_id);\n\tif (count >= sizeof(drvinfo->fw_version))\n\t\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t\t \"%d.%d.%04d\", fw_rev_maj(mdev),\n\t\t\t fw_rev_min(mdev), fw_rev_sub(mdev));\n\n\tstrscpy(drvinfo->bus_info, dev_name(mdev->device),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void mlx5e_get_drvinfo(struct net_device *dev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\tmlx5e_ethtool_get_drvinfo(priv, drvinfo);\n}\n\nstruct ptys2ethtool_config {\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(advertised);\n};\n\nstatic\nstruct ptys2ethtool_config ptys2legacy_ethtool_table[MLX5E_LINK_MODES_NUMBER];\nstatic\nstruct ptys2ethtool_config ptys2ext_ethtool_table[MLX5E_EXT_LINK_MODES_NUMBER];\n\n#define MLX5_BUILD_PTYS2ETHTOOL_CONFIG(reg_, table, ...)                  \\\n\t({                                                              \\\n\t\tstruct ptys2ethtool_config *cfg;                        \\\n\t\tconst unsigned int modes[] = { __VA_ARGS__ };           \\\n\t\tunsigned int i, bit, idx;                               \\\n\t\tcfg = &ptys2##table##_ethtool_table[reg_];\t\t\\\n\t\tbitmap_zero(cfg->supported,                             \\\n\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS);            \\\n\t\tbitmap_zero(cfg->advertised,                            \\\n\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS);            \\\n\t\tfor (i = 0 ; i < ARRAY_SIZE(modes) ; ++i) {             \\\n\t\t\tbit = modes[i] % 64;                            \\\n\t\t\tidx = modes[i] / 64;                            \\\n\t\t\t__set_bit(bit, &cfg->supported[idx]);           \\\n\t\t\t__set_bit(bit, &cfg->advertised[idx]);          \\\n\t\t}                                                       \\\n\t})\n\nvoid mlx5e_build_ptys2ethtool_map(void)\n{\n\tmemset(ptys2legacy_ethtool_table, 0, sizeof(ptys2legacy_ethtool_table));\n\tmemset(ptys2ext_ethtool_table, 0, sizeof(ptys2ext_ethtool_table));\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_1000BASE_CX_SGMII, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseKX_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_1000BASE_KX, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseKX_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_CX4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_KX4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_KR, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_20GBASE_KR2, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_40GBASE_CR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_40GBASE_KR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_56GBASE_R4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_CR, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_SR, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_ER, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_40GBASE_SR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_40GBASE_LR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_50GBASE_SR2, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_100GBASE_CR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_100GBASE_SR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_100GBASE_KR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_100GBASE_LR4, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_T, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseT_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_25GBASE_CR, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_25000baseCR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_25GBASE_KR, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_25000baseKR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_25GBASE_SR, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_25000baseSR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_50GBASE_CR2, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_50GBASE_KR2, legacy,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_SGMII_100M, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_100baseT_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_1000BASE_X_SGMII, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseX_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_5GBASE_R, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_5000baseT_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_10GBASE_XFI_XAUI_1, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseR_FEC_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseCR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseSR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseLR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseER_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_40GBASE_XLAUI_4_XLPPI_4, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_25GAUI_1_25GBASE_CR_KR, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_25000baseSR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_50GAUI_2_LAUI_2_50GBASE_CR2_KR2,\n\t\t\t\t       ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_50GAUI_1_LAUI_1_50GBASE_CR_KR, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseKR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseSR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseCR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_50000baseDR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_CAUI_4_100GBASE_CR4_KR4, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_100GAUI_2_100GBASE_CR2_KR2, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_200GAUI_4_200GBASE_CR4_KR4, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_100GAUI_1_100GBASE_CR_KR, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseKR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseSR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseDR_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_100000baseCR_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_200GAUI_2_200GBASE_CR2_KR2, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT);\n\tMLX5_BUILD_PTYS2ETHTOOL_CONFIG(MLX5E_400GAUI_4_400GBASE_CR4_KR4, ext,\n\t\t\t\t       ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT);\n}\n\nstatic void mlx5e_ethtool_get_speed_arr(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct ptys2ethtool_config **arr,\n\t\t\t\t\tu32 *size)\n{\n\tbool ext = mlx5_ptys_ext_supported(mdev);\n\n\t*arr = ext ? ptys2ext_ethtool_table : ptys2legacy_ethtool_table;\n\t*size = ext ? ARRAY_SIZE(ptys2ext_ethtool_table) :\n\t\t      ARRAY_SIZE(ptys2legacy_ethtool_table);\n}\n\ntypedef int (*mlx5e_pflag_handler)(struct net_device *netdev, bool enable);\n\nstruct pflag_desc {\n\tchar name[ETH_GSTRING_LEN];\n\tmlx5e_pflag_handler handler;\n};\n\nstatic const struct pflag_desc mlx5e_priv_flags[MLX5E_NUM_PFLAGS];\n\nint mlx5e_ethtool_get_sset_count(struct mlx5e_priv *priv, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn mlx5e_stats_total_num(priv);\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn MLX5E_NUM_PFLAGS;\n\tcase ETH_SS_TEST:\n\t\treturn mlx5e_self_test_num(priv);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlx5e_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn mlx5e_ethtool_get_sset_count(priv, sset);\n}\n\nvoid mlx5e_ethtool_get_strings(struct mlx5e_priv *priv, u32 stringset, u8 *data)\n{\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tfor (i = 0; i < MLX5E_NUM_PFLAGS; i++)\n\t\t\tstrcpy(data + i * ETH_GSTRING_LEN,\n\t\t\t       mlx5e_priv_flags[i].name);\n\t\tbreak;\n\n\tcase ETH_SS_TEST:\n\t\tmlx5e_self_test_fill_strings(priv, data);\n\t\tbreak;\n\n\tcase ETH_SS_STATS:\n\t\tmlx5e_stats_fill_strings(priv, data);\n\t\tbreak;\n\t}\n}\n\nstatic void mlx5e_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\tmlx5e_ethtool_get_strings(priv, stringset, data);\n}\n\nvoid mlx5e_ethtool_get_ethtool_stats(struct mlx5e_priv *priv,\n\t\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tint idx = 0;\n\n\tmutex_lock(&priv->state_lock);\n\tmlx5e_stats_update(priv);\n\tmutex_unlock(&priv->state_lock);\n\n\tmlx5e_stats_fill(priv, data, idx);\n}\n\nstatic void mlx5e_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_stats *stats,\n\t\t\t\t    u64 *data)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\tmlx5e_ethtool_get_ethtool_stats(priv, stats, data);\n}\n\nvoid mlx5e_ethtool_get_ringparam(struct mlx5e_priv *priv,\n\t\t\t\t struct ethtool_ringparam *param,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_param)\n{\n\t \n\tu8 max_log_mpwrq_pkts = mlx5e_mpwrq_max_log_rq_pkts(priv->mdev,\n\t\t\t\t\t\t\t    PAGE_SHIFT,\n\t\t\t\t\t\t\t    MLX5E_MPWRQ_UMR_MODE_ALIGNED);\n\n\tparam->rx_max_pending = 1 << min_t(u8, MLX5E_PARAMS_MAXIMUM_LOG_RQ_SIZE,\n\t\t\t\t\t   max_log_mpwrq_pkts);\n\tparam->tx_max_pending = 1 << MLX5E_PARAMS_MAXIMUM_LOG_SQ_SIZE;\n\tparam->rx_pending     = 1 << priv->channels.params.log_rq_mtu_frames;\n\tparam->tx_pending     = 1 << priv->channels.params.log_sq_size;\n\n\tkernel_param->tcp_data_split =\n\t\t(priv->channels.params.packet_merge.type == MLX5E_PACKET_MERGE_SHAMPO) ?\n\t\tETHTOOL_TCP_DATA_SPLIT_ENABLED :\n\t\tETHTOOL_TCP_DATA_SPLIT_DISABLED;\n}\n\nstatic void mlx5e_get_ringparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_ringparam *param,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_param,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\tmlx5e_ethtool_get_ringparam(priv, param, kernel_param);\n}\n\nint mlx5e_ethtool_set_ringparam(struct mlx5e_priv *priv,\n\t\t\t\tstruct ethtool_ringparam *param)\n{\n\tstruct mlx5e_params new_params;\n\tu8 log_rq_size;\n\tu8 log_sq_size;\n\tint err = 0;\n\n\tif (param->rx_jumbo_pending) {\n\t\tnetdev_info(priv->netdev, \"%s: rx_jumbo_pending not supported\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (param->rx_mini_pending) {\n\t\tnetdev_info(priv->netdev, \"%s: rx_mini_pending not supported\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param->rx_pending < (1 << MLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE)) {\n\t\tnetdev_info(priv->netdev, \"%s: rx_pending (%d) < min (%d)\\n\",\n\t\t\t    __func__, param->rx_pending,\n\t\t\t    1 << MLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param->tx_pending < (1 << MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE)) {\n\t\tnetdev_info(priv->netdev, \"%s: tx_pending (%d) < min (%d)\\n\",\n\t\t\t    __func__, param->tx_pending,\n\t\t\t    1 << MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tlog_rq_size = order_base_2(param->rx_pending);\n\tlog_sq_size = order_base_2(param->tx_pending);\n\n\tif (log_rq_size == priv->channels.params.log_rq_mtu_frames &&\n\t    log_sq_size == priv->channels.params.log_sq_size)\n\t\treturn 0;\n\n\tmutex_lock(&priv->state_lock);\n\n\tnew_params = priv->channels.params;\n\tnew_params.log_rq_mtu_frames = log_rq_size;\n\tnew_params.log_sq_size = log_sq_size;\n\n\terr = mlx5e_validate_params(priv->mdev, &new_params);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);\n\nunlock:\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_set_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *param,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn mlx5e_ethtool_set_ringparam(priv, param);\n}\n\nvoid mlx5e_ethtool_get_channels(struct mlx5e_priv *priv,\n\t\t\t\tstruct ethtool_channels *ch)\n{\n\tmutex_lock(&priv->state_lock);\n\tch->max_combined   = priv->max_nch;\n\tch->combined_count = priv->channels.params.num_channels;\n\tmutex_unlock(&priv->state_lock);\n}\n\nstatic void mlx5e_get_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *ch)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\tmlx5e_ethtool_get_channels(priv, ch);\n}\n\nint mlx5e_ethtool_set_channels(struct mlx5e_priv *priv,\n\t\t\t       struct ethtool_channels *ch)\n{\n\tstruct mlx5e_params *cur_params = &priv->channels.params;\n\tunsigned int count = ch->combined_count;\n\tstruct mlx5e_params new_params;\n\tbool arfs_enabled;\n\tint rss_cnt;\n\tbool opened;\n\tint err = 0;\n\n\tif (!count) {\n\t\tnetdev_info(priv->netdev, \"%s: combined_count=0 not supported\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cur_params->num_channels == count)\n\t\treturn 0;\n\n\tmutex_lock(&priv->state_lock);\n\n\t \n\tif (mlx5e_selq_is_htb_enabled(&priv->selq)) {\n\t\terr = -EINVAL;\n\t\tnetdev_err(priv->netdev, \"%s: HTB offload is active, cannot change the number of channels\\n\",\n\t\t\t   __func__);\n\t\tgoto out;\n\t}\n\n\t \n\trss_cnt = mlx5e_rx_res_rss_cnt(priv->rx_res) - 1;\n\tif (rss_cnt) {\n\t\terr = -EINVAL;\n\t\tnetdev_err(priv->netdev, \"%s: Non-default RSS contexts exist (%d), cannot change the number of channels\\n\",\n\t\t\t   __func__, rss_cnt);\n\t\tgoto out;\n\t}\n\n\t \n\tif (cur_params->mqprio.mode == TC_MQPRIO_MODE_CHANNEL) {\n\t\terr = -EINVAL;\n\t\tnetdev_err(priv->netdev, \"%s: MQPRIO mode channel offload is active, cannot change the number of channels\\n\",\n\t\t\t   __func__);\n\t\tgoto out;\n\t}\n\n\tnew_params = *cur_params;\n\tnew_params.num_channels = count;\n\n\topened = test_bit(MLX5E_STATE_OPENED, &priv->state);\n\n\tarfs_enabled = opened && (priv->netdev->features & NETIF_F_NTUPLE);\n\tif (arfs_enabled)\n\t\tmlx5e_arfs_disable(priv->fs);\n\n\t \n\terr = mlx5e_safe_switch_params(priv, &new_params,\n\t\t\t\t       mlx5e_num_channels_changed_ctx, NULL, true);\n\n\tif (arfs_enabled) {\n\t\tint err2 = mlx5e_arfs_enable(priv->fs);\n\n\t\tif (err2)\n\t\t\tnetdev_err(priv->netdev, \"%s: mlx5e_arfs_enable failed: %d\\n\",\n\t\t\t\t   __func__, err2);\n\t}\n\nout:\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_set_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *ch)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn mlx5e_ethtool_set_channels(priv, ch);\n}\n\nint mlx5e_ethtool_get_coalesce(struct mlx5e_priv *priv,\n\t\t\t       struct ethtool_coalesce *coal,\n\t\t\t       struct kernel_ethtool_coalesce *kernel_coal)\n{\n\tstruct dim_cq_moder *rx_moder, *tx_moder;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, cq_moderation))\n\t\treturn -EOPNOTSUPP;\n\n\trx_moder = &priv->channels.params.rx_cq_moderation;\n\tcoal->rx_coalesce_usecs\t\t= rx_moder->usec;\n\tcoal->rx_max_coalesced_frames\t= rx_moder->pkts;\n\tcoal->use_adaptive_rx_coalesce\t= priv->channels.params.rx_dim_enabled;\n\n\ttx_moder = &priv->channels.params.tx_cq_moderation;\n\tcoal->tx_coalesce_usecs\t\t= tx_moder->usec;\n\tcoal->tx_max_coalesced_frames\t= tx_moder->pkts;\n\tcoal->use_adaptive_tx_coalesce\t= priv->channels.params.tx_dim_enabled;\n\n\tkernel_coal->use_cqe_mode_rx =\n\t\tMLX5E_GET_PFLAG(&priv->channels.params, MLX5E_PFLAG_RX_CQE_BASED_MODER);\n\tkernel_coal->use_cqe_mode_tx =\n\t\tMLX5E_GET_PFLAG(&priv->channels.params, MLX5E_PFLAG_TX_CQE_BASED_MODER);\n\n\treturn 0;\n}\n\nstatic int mlx5e_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn mlx5e_ethtool_get_coalesce(priv, coal, kernel_coal);\n}\n\n#define MLX5E_MAX_COAL_TIME\t\tMLX5_MAX_CQ_PERIOD\n#define MLX5E_MAX_COAL_FRAMES\t\tMLX5_MAX_CQ_COUNT\n\nstatic void\nmlx5e_set_priv_channels_tx_coalesce(struct mlx5e_priv *priv, struct ethtool_coalesce *coal)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint tc;\n\tint i;\n\n\tfor (i = 0; i < priv->channels.num; ++i) {\n\t\tstruct mlx5e_channel *c = priv->channels.c[i];\n\n\t\tfor (tc = 0; tc < c->num_tc; tc++) {\n\t\t\tmlx5_core_modify_cq_moderation(mdev,\n\t\t\t\t\t\t&c->sq[tc].cq.mcq,\n\t\t\t\t\t\tcoal->tx_coalesce_usecs,\n\t\t\t\t\t\tcoal->tx_max_coalesced_frames);\n\t\t}\n\t}\n}\n\nstatic void\nmlx5e_set_priv_channels_rx_coalesce(struct mlx5e_priv *priv, struct ethtool_coalesce *coal)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint i;\n\n\tfor (i = 0; i < priv->channels.num; ++i) {\n\t\tstruct mlx5e_channel *c = priv->channels.c[i];\n\n\t\tmlx5_core_modify_cq_moderation(mdev, &c->rq.cq.mcq,\n\t\t\t\t\t       coal->rx_coalesce_usecs,\n\t\t\t\t\t       coal->rx_max_coalesced_frames);\n\t}\n}\n\n \nstatic int cqe_mode_to_period_mode(bool val)\n{\n\treturn val ? MLX5_CQ_PERIOD_MODE_START_FROM_CQE : MLX5_CQ_PERIOD_MODE_START_FROM_EQE;\n}\n\nint mlx5e_ethtool_set_coalesce(struct mlx5e_priv *priv,\n\t\t\t       struct ethtool_coalesce *coal,\n\t\t\t       struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct dim_cq_moder *rx_moder, *tx_moder;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_params new_params;\n\tbool reset_rx, reset_tx;\n\tbool reset = true;\n\tu8 cq_period_mode;\n\tint err = 0;\n\n\tif (!MLX5_CAP_GEN(mdev, cq_moderation))\n\t\treturn -EOPNOTSUPP;\n\n\tif (coal->tx_coalesce_usecs > MLX5E_MAX_COAL_TIME ||\n\t    coal->rx_coalesce_usecs > MLX5E_MAX_COAL_TIME) {\n\t\tnetdev_info(priv->netdev, \"%s: maximum coalesce time supported is %lu usecs\\n\",\n\t\t\t    __func__, MLX5E_MAX_COAL_TIME);\n\t\treturn -ERANGE;\n\t}\n\n\tif (coal->tx_max_coalesced_frames > MLX5E_MAX_COAL_FRAMES ||\n\t    coal->rx_max_coalesced_frames > MLX5E_MAX_COAL_FRAMES) {\n\t\tnetdev_info(priv->netdev, \"%s: maximum coalesced frames supported is %lu\\n\",\n\t\t\t    __func__, MLX5E_MAX_COAL_FRAMES);\n\t\treturn -ERANGE;\n\t}\n\n\tif ((kernel_coal->use_cqe_mode_rx || kernel_coal->use_cqe_mode_tx) &&\n\t    !MLX5_CAP_GEN(priv->mdev, cq_period_start_from_cqe)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"cqe_mode_rx/tx is not supported on this device\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&priv->state_lock);\n\tnew_params = priv->channels.params;\n\n\trx_moder          = &new_params.rx_cq_moderation;\n\trx_moder->usec    = coal->rx_coalesce_usecs;\n\trx_moder->pkts    = coal->rx_max_coalesced_frames;\n\tnew_params.rx_dim_enabled = !!coal->use_adaptive_rx_coalesce;\n\n\ttx_moder          = &new_params.tx_cq_moderation;\n\ttx_moder->usec    = coal->tx_coalesce_usecs;\n\ttx_moder->pkts    = coal->tx_max_coalesced_frames;\n\tnew_params.tx_dim_enabled = !!coal->use_adaptive_tx_coalesce;\n\n\treset_rx = !!coal->use_adaptive_rx_coalesce != priv->channels.params.rx_dim_enabled;\n\treset_tx = !!coal->use_adaptive_tx_coalesce != priv->channels.params.tx_dim_enabled;\n\n\tcq_period_mode = cqe_mode_to_period_mode(kernel_coal->use_cqe_mode_rx);\n\tif (cq_period_mode != rx_moder->cq_period_mode) {\n\t\tmlx5e_set_rx_cq_mode_params(&new_params, cq_period_mode);\n\t\treset_rx = true;\n\t}\n\n\tcq_period_mode = cqe_mode_to_period_mode(kernel_coal->use_cqe_mode_tx);\n\tif (cq_period_mode != tx_moder->cq_period_mode) {\n\t\tmlx5e_set_tx_cq_mode_params(&new_params, cq_period_mode);\n\t\treset_tx = true;\n\t}\n\n\tif (reset_rx) {\n\t\tu8 mode = MLX5E_GET_PFLAG(&new_params,\n\t\t\t\t\t  MLX5E_PFLAG_RX_CQE_BASED_MODER);\n\n\t\tmlx5e_reset_rx_moderation(&new_params, mode);\n\t}\n\tif (reset_tx) {\n\t\tu8 mode = MLX5E_GET_PFLAG(&new_params,\n\t\t\t\t\t  MLX5E_PFLAG_TX_CQE_BASED_MODER);\n\n\t\tmlx5e_reset_tx_moderation(&new_params, mode);\n\t}\n\n\t \n\tif (!reset_rx && !reset_tx && test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\tif (!coal->use_adaptive_rx_coalesce)\n\t\t\tmlx5e_set_priv_channels_rx_coalesce(priv, coal);\n\t\tif (!coal->use_adaptive_tx_coalesce)\n\t\t\tmlx5e_set_priv_channels_tx_coalesce(priv, coal);\n\t\treset = false;\n\t}\n\n\terr = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, reset);\n\n\tmutex_unlock(&priv->state_lock);\n\treturn err;\n}\n\nstatic int mlx5e_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn mlx5e_ethtool_set_coalesce(priv, coal, kernel_coal, extack);\n}\n\nstatic void ptys2ethtool_supported_link(struct mlx5_core_dev *mdev,\n\t\t\t\t\tunsigned long *supported_modes,\n\t\t\t\t\tu32 eth_proto_cap)\n{\n\tunsigned long proto_cap = eth_proto_cap;\n\tstruct ptys2ethtool_config *table;\n\tu32 max_size;\n\tint proto;\n\n\tmlx5e_ethtool_get_speed_arr(mdev, &table, &max_size);\n\tfor_each_set_bit(proto, &proto_cap, max_size)\n\t\tbitmap_or(supported_modes, supported_modes,\n\t\t\t  table[proto].supported,\n\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS);\n}\n\nstatic void ptys2ethtool_adver_link(unsigned long *advertising_modes,\n\t\t\t\t    u32 eth_proto_cap, bool ext)\n{\n\tunsigned long proto_cap = eth_proto_cap;\n\tstruct ptys2ethtool_config *table;\n\tu32 max_size;\n\tint proto;\n\n\ttable = ext ? ptys2ext_ethtool_table : ptys2legacy_ethtool_table;\n\tmax_size = ext ? ARRAY_SIZE(ptys2ext_ethtool_table) :\n\t\t\t ARRAY_SIZE(ptys2legacy_ethtool_table);\n\n\tfor_each_set_bit(proto, &proto_cap, max_size)\n\t\tbitmap_or(advertising_modes, advertising_modes,\n\t\t\t  table[proto].advertised,\n\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS);\n}\n\nstatic const u32 pplm_fec_2_ethtool[] = {\n\t[MLX5E_FEC_NOFEC] = ETHTOOL_FEC_OFF,\n\t[MLX5E_FEC_FIRECODE] = ETHTOOL_FEC_BASER,\n\t[MLX5E_FEC_RS_528_514] = ETHTOOL_FEC_RS,\n\t[MLX5E_FEC_RS_544_514] = ETHTOOL_FEC_RS,\n\t[MLX5E_FEC_LLRS_272_257_1] = ETHTOOL_FEC_LLRS,\n};\n\nstatic u32 pplm2ethtool_fec(u_long fec_mode, unsigned long size)\n{\n\tint mode = 0;\n\n\tif (!fec_mode)\n\t\treturn ETHTOOL_FEC_AUTO;\n\n\tmode = find_first_bit(&fec_mode, size);\n\n\tif (mode < ARRAY_SIZE(pplm_fec_2_ethtool))\n\t\treturn pplm_fec_2_ethtool[mode];\n\n\treturn 0;\n}\n\n#define MLX5E_ADVERTISE_SUPPORTED_FEC(mlx5_fec, ethtool_fec)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (mlx5e_fec_in_caps(dev, 1 << (mlx5_fec)))\t\t\\\n\t\t\t__set_bit(ethtool_fec,\t\t\t\t\\\n\t\t\t\t  link_ksettings->link_modes.supported);\\\n\t} while (0)\n\nstatic const u32 pplm_fec_2_ethtool_linkmodes[] = {\n\t[MLX5E_FEC_NOFEC] = ETHTOOL_LINK_MODE_FEC_NONE_BIT,\n\t[MLX5E_FEC_FIRECODE] = ETHTOOL_LINK_MODE_FEC_BASER_BIT,\n\t[MLX5E_FEC_RS_528_514] = ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t[MLX5E_FEC_RS_544_514] = ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t[MLX5E_FEC_LLRS_272_257_1] = ETHTOOL_LINK_MODE_FEC_LLRS_BIT,\n};\n\nstatic int get_fec_supported_advertised(struct mlx5_core_dev *dev,\n\t\t\t\t\tstruct ethtool_link_ksettings *link_ksettings)\n{\n\tunsigned long active_fec_long;\n\tu32 active_fec;\n\tu32 bitn;\n\tint err;\n\n\terr = mlx5e_get_fec_mode(dev, &active_fec, NULL);\n\tif (err)\n\t\treturn (err == -EOPNOTSUPP) ? 0 : err;\n\n\tMLX5E_ADVERTISE_SUPPORTED_FEC(MLX5E_FEC_NOFEC,\n\t\t\t\t      ETHTOOL_LINK_MODE_FEC_NONE_BIT);\n\tMLX5E_ADVERTISE_SUPPORTED_FEC(MLX5E_FEC_FIRECODE,\n\t\t\t\t      ETHTOOL_LINK_MODE_FEC_BASER_BIT);\n\tMLX5E_ADVERTISE_SUPPORTED_FEC(MLX5E_FEC_RS_528_514,\n\t\t\t\t      ETHTOOL_LINK_MODE_FEC_RS_BIT);\n\tMLX5E_ADVERTISE_SUPPORTED_FEC(MLX5E_FEC_LLRS_272_257_1,\n\t\t\t\t      ETHTOOL_LINK_MODE_FEC_LLRS_BIT);\n\n\tactive_fec_long = active_fec;\n\t \n\tbitn = find_first_bit(&active_fec_long, sizeof(active_fec_long) * BITS_PER_BYTE);\n\tif (bitn < ARRAY_SIZE(pplm_fec_2_ethtool_linkmodes))\n\t\t__set_bit(pplm_fec_2_ethtool_linkmodes[bitn],\n\t\t\t  link_ksettings->link_modes.advertising);\n\n\treturn 0;\n}\n\nstatic void ptys2ethtool_supported_advertised_port(struct mlx5_core_dev *mdev,\n\t\t\t\t\t\t   struct ethtool_link_ksettings *link_ksettings,\n\t\t\t\t\t\t   u32 eth_proto_cap, u8 connector_type)\n{\n\tif (!MLX5_CAP_PCAM_FEATURE(mdev, ptys_connector_type)) {\n\t\tif (eth_proto_cap & (MLX5E_PROT_MASK(MLX5E_10GBASE_CR)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_10GBASE_SR)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_40GBASE_CR4)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_40GBASE_SR4)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_100GBASE_SR4)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_1000BASE_CX_SGMII))) {\n\t\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t\t     supported,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t\t     advertising,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t}\n\n\t\tif (eth_proto_cap & (MLX5E_PROT_MASK(MLX5E_100GBASE_KR4)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_40GBASE_KR4)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_10GBASE_KR)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_10GBASE_KX4)\n\t\t\t\t   | MLX5E_PROT_MASK(MLX5E_1000BASE_KX))) {\n\t\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t\t     supported,\n\t\t\t\t\t\t\t     Backplane);\n\t\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t\t     advertising,\n\t\t\t\t\t\t\t     Backplane);\n\t\t}\n\t\treturn;\n\t}\n\n\tswitch (connector_type) {\n\tcase MLX5E_PORT_TP:\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, TP);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, TP);\n\t\tbreak;\n\tcase MLX5E_PORT_AUI:\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, AUI);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, AUI);\n\t\tbreak;\n\tcase MLX5E_PORT_BNC:\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, BNC);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, BNC);\n\t\tbreak;\n\tcase MLX5E_PORT_MII:\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, MII);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, MII);\n\t\tbreak;\n\tcase MLX5E_PORT_FIBRE:\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, FIBRE);\n\t\tbreak;\n\tcase MLX5E_PORT_DA:\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, Backplane);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Backplane);\n\t\tbreak;\n\tcase MLX5E_PORT_NONE:\n\tcase MLX5E_PORT_OTHER:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void get_speed_duplex(struct net_device *netdev,\n\t\t\t     u32 eth_proto_oper, bool force_legacy,\n\t\t\t     u16 data_rate_oper,\n\t\t\t     struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tu32 speed = SPEED_UNKNOWN;\n\tu8 duplex = DUPLEX_UNKNOWN;\n\n\tif (!netif_carrier_ok(netdev))\n\t\tgoto out;\n\n\tspeed = mlx5_port_ptys2speed(priv->mdev, eth_proto_oper, force_legacy);\n\tif (!speed) {\n\t\tif (data_rate_oper)\n\t\t\tspeed = 100 * data_rate_oper;\n\t\telse\n\t\t\tspeed = SPEED_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\tduplex = DUPLEX_FULL;\n\nout:\n\tlink_ksettings->base.speed = speed;\n\tlink_ksettings->base.duplex = duplex;\n}\n\nstatic void get_supported(struct mlx5_core_dev *mdev, u32 eth_proto_cap,\n\t\t\t  struct ethtool_link_ksettings *link_ksettings)\n{\n\tunsigned long *supported = link_ksettings->link_modes.supported;\n\tptys2ethtool_supported_link(mdev, supported, eth_proto_cap);\n\n\tethtool_link_ksettings_add_link_mode(link_ksettings, supported, Pause);\n}\n\nstatic void get_advertising(u32 eth_proto_cap, u8 tx_pause, u8 rx_pause,\n\t\t\t    struct ethtool_link_ksettings *link_ksettings,\n\t\t\t    bool ext)\n{\n\tunsigned long *advertising = link_ksettings->link_modes.advertising;\n\tptys2ethtool_adver_link(advertising, eth_proto_cap, ext);\n\n\tif (rx_pause)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings, advertising, Pause);\n\tif (tx_pause ^ rx_pause)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings, advertising, Asym_Pause);\n}\n\nstatic int ptys2connector_type[MLX5E_CONNECTOR_TYPE_NUMBER] = {\n\t\t[MLX5E_PORT_UNKNOWN]            = PORT_OTHER,\n\t\t[MLX5E_PORT_NONE]               = PORT_NONE,\n\t\t[MLX5E_PORT_TP]                 = PORT_TP,\n\t\t[MLX5E_PORT_AUI]                = PORT_AUI,\n\t\t[MLX5E_PORT_BNC]                = PORT_BNC,\n\t\t[MLX5E_PORT_MII]                = PORT_MII,\n\t\t[MLX5E_PORT_FIBRE]              = PORT_FIBRE,\n\t\t[MLX5E_PORT_DA]                 = PORT_DA,\n\t\t[MLX5E_PORT_OTHER]              = PORT_OTHER,\n\t};\n\nstatic u8 get_connector_port(struct mlx5_core_dev *mdev, u32 eth_proto, u8 connector_type)\n{\n\tif (MLX5_CAP_PCAM_FEATURE(mdev, ptys_connector_type))\n\t\treturn ptys2connector_type[connector_type];\n\n\tif (eth_proto &\n\t    (MLX5E_PROT_MASK(MLX5E_10GBASE_SR)   |\n\t     MLX5E_PROT_MASK(MLX5E_40GBASE_SR4)  |\n\t     MLX5E_PROT_MASK(MLX5E_100GBASE_SR4) |\n\t     MLX5E_PROT_MASK(MLX5E_1000BASE_CX_SGMII))) {\n\t\treturn PORT_FIBRE;\n\t}\n\n\tif (eth_proto &\n\t    (MLX5E_PROT_MASK(MLX5E_40GBASE_CR4) |\n\t     MLX5E_PROT_MASK(MLX5E_10GBASE_CR)  |\n\t     MLX5E_PROT_MASK(MLX5E_100GBASE_CR4))) {\n\t\treturn PORT_DA;\n\t}\n\n\tif (eth_proto &\n\t    (MLX5E_PROT_MASK(MLX5E_10GBASE_KX4) |\n\t     MLX5E_PROT_MASK(MLX5E_10GBASE_KR)  |\n\t     MLX5E_PROT_MASK(MLX5E_40GBASE_KR4) |\n\t     MLX5E_PROT_MASK(MLX5E_100GBASE_KR4))) {\n\t\treturn PORT_NONE;\n\t}\n\n\treturn PORT_OTHER;\n}\n\nstatic void get_lp_advertising(struct mlx5_core_dev *mdev, u32 eth_proto_lp,\n\t\t\t       struct ethtool_link_ksettings *link_ksettings)\n{\n\tunsigned long *lp_advertising = link_ksettings->link_modes.lp_advertising;\n\tbool ext = mlx5_ptys_ext_supported(mdev);\n\n\tptys2ethtool_adver_link(lp_advertising, eth_proto_lp, ext);\n}\n\nint mlx5e_ethtool_get_link_ksettings(struct mlx5e_priv *priv,\n\t\t\t\t     struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu32 out[MLX5_ST_SZ_DW(ptys_reg)] = {};\n\tu32 eth_proto_admin;\n\tu8 an_disable_admin;\n\tu16 data_rate_oper;\n\tu32 eth_proto_oper;\n\tu32 eth_proto_cap;\n\tu8 connector_type;\n\tu32 rx_pause = 0;\n\tu32 tx_pause = 0;\n\tu32 eth_proto_lp;\n\tbool admin_ext;\n\tu8 an_status;\n\tbool ext;\n\tint err;\n\n\terr = mlx5_query_port_ptys(mdev, out, sizeof(out), MLX5_PTYS_EN, 1);\n\tif (err) {\n\t\tnetdev_err(priv->netdev, \"%s: query port ptys failed: %d\\n\",\n\t\t\t   __func__, err);\n\t\tgoto err_query_regs;\n\t}\n\text = !!MLX5_GET_ETH_PROTO(ptys_reg, out, true, eth_proto_capability);\n\teth_proto_cap    = MLX5_GET_ETH_PROTO(ptys_reg, out, ext,\n\t\t\t\t\t      eth_proto_capability);\n\teth_proto_admin  = MLX5_GET_ETH_PROTO(ptys_reg, out, ext,\n\t\t\t\t\t      eth_proto_admin);\n\t \n\tadmin_ext = ext;\n\tif (ext && !eth_proto_admin) {\n\t\teth_proto_admin  = MLX5_GET_ETH_PROTO(ptys_reg, out, false,\n\t\t\t\t\t\t      eth_proto_admin);\n\t\tadmin_ext = false;\n\t}\n\n\teth_proto_oper   = MLX5_GET_ETH_PROTO(ptys_reg, out, admin_ext,\n\t\t\t\t\t      eth_proto_oper);\n\teth_proto_lp\t    = MLX5_GET(ptys_reg, out, eth_proto_lp_advertise);\n\tan_disable_admin    = MLX5_GET(ptys_reg, out, an_disable_admin);\n\tan_status\t    = MLX5_GET(ptys_reg, out, an_status);\n\tconnector_type\t    = MLX5_GET(ptys_reg, out, connector_type);\n\tdata_rate_oper\t    = MLX5_GET(ptys_reg, out, data_rate_oper);\n\n\tmlx5_query_port_pause(mdev, &rx_pause, &tx_pause);\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\n\n\tget_supported(mdev, eth_proto_cap, link_ksettings);\n\tget_advertising(eth_proto_admin, tx_pause, rx_pause, link_ksettings,\n\t\t\tadmin_ext);\n\tget_speed_duplex(priv->netdev, eth_proto_oper, !admin_ext,\n\t\t\t data_rate_oper, link_ksettings);\n\n\teth_proto_oper = eth_proto_oper ? eth_proto_oper : eth_proto_cap;\n\tconnector_type = connector_type < MLX5E_CONNECTOR_TYPE_NUMBER ?\n\t\t\t connector_type : MLX5E_PORT_UNKNOWN;\n\tlink_ksettings->base.port = get_connector_port(mdev, eth_proto_oper, connector_type);\n\tptys2ethtool_supported_advertised_port(mdev, link_ksettings, eth_proto_admin,\n\t\t\t\t\t       connector_type);\n\tget_lp_advertising(mdev, eth_proto_lp, link_ksettings);\n\n\tif (an_status == MLX5_AN_COMPLETE)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     lp_advertising, Autoneg);\n\n\tlink_ksettings->base.autoneg = an_disable_admin ? AUTONEG_DISABLE :\n\t\t\t\t\t\t\t  AUTONEG_ENABLE;\n\tethtool_link_ksettings_add_link_mode(link_ksettings, supported,\n\t\t\t\t\t     Autoneg);\n\n\terr = get_fec_supported_advertised(mdev, link_ksettings);\n\tif (err) {\n\t\tnetdev_dbg(priv->netdev, \"%s: FEC caps query failed: %d\\n\",\n\t\t\t   __func__, err);\n\t\terr = 0;  \n\t}\n\n\tif (!an_disable_admin)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Autoneg);\n\nerr_query_regs:\n\treturn err;\n}\n\nstatic int mlx5e_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn mlx5e_ethtool_get_link_ksettings(priv, link_ksettings);\n}\n\nstatic int mlx5e_speed_validate(struct net_device *netdev, bool ext,\n\t\t\t\tconst unsigned long link_modes, u8 autoneg)\n{\n\t \n\tif (ext)\n\t\treturn 0;\n\n\tif ((link_modes & MLX5E_PROT_MASK(MLX5E_56GBASE_R4)) &&\n\t    autoneg != AUTONEG_ENABLE) {\n\t\tnetdev_err(netdev, \"%s: 56G link speed requires autoneg enabled\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic u32 mlx5e_ethtool2ptys_adver_link(const unsigned long *link_modes)\n{\n\tu32 i, ptys_modes = 0;\n\n\tfor (i = 0; i < MLX5E_LINK_MODES_NUMBER; ++i) {\n\t\tif (*ptys2legacy_ethtool_table[i].advertised == 0)\n\t\t\tcontinue;\n\t\tif (bitmap_intersects(ptys2legacy_ethtool_table[i].advertised,\n\t\t\t\t      link_modes,\n\t\t\t\t      __ETHTOOL_LINK_MODE_MASK_NBITS))\n\t\t\tptys_modes |= MLX5E_PROT_MASK(i);\n\t}\n\n\treturn ptys_modes;\n}\n\nstatic u32 mlx5e_ethtool2ptys_ext_adver_link(const unsigned long *link_modes)\n{\n\tu32 i, ptys_modes = 0;\n\tunsigned long modes[2];\n\n\tfor (i = 0; i < MLX5E_EXT_LINK_MODES_NUMBER; ++i) {\n\t\tif (ptys2ext_ethtool_table[i].advertised[0] == 0 &&\n\t\t    ptys2ext_ethtool_table[i].advertised[1] == 0)\n\t\t\tcontinue;\n\t\tmemset(modes, 0, sizeof(modes));\n\t\tbitmap_and(modes, ptys2ext_ethtool_table[i].advertised,\n\t\t\t   link_modes, __ETHTOOL_LINK_MODE_MASK_NBITS);\n\n\t\tif (modes[0] == ptys2ext_ethtool_table[i].advertised[0] &&\n\t\t    modes[1] == ptys2ext_ethtool_table[i].advertised[1])\n\t\t\tptys_modes |= MLX5E_PROT_MASK(i);\n\t}\n\treturn ptys_modes;\n}\n\nstatic bool ext_link_mode_requested(const unsigned long *adver)\n{\n#define MLX5E_MIN_PTYS_EXT_LINK_MODE_BIT ETHTOOL_LINK_MODE_50000baseKR_Full_BIT\n\tint size = __ETHTOOL_LINK_MODE_MASK_NBITS - MLX5E_MIN_PTYS_EXT_LINK_MODE_BIT;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(modes) = {0,};\n\n\tbitmap_set(modes, MLX5E_MIN_PTYS_EXT_LINK_MODE_BIT, size);\n\treturn bitmap_intersects(modes, adver, __ETHTOOL_LINK_MODE_MASK_NBITS);\n}\n\nstatic bool ext_requested(u8 autoneg, const unsigned long *adver, bool ext_supported)\n{\n\tbool ext_link_mode = ext_link_mode_requested(adver);\n\n\treturn  autoneg == AUTONEG_ENABLE ? ext_link_mode : ext_supported;\n}\n\nint mlx5e_ethtool_set_link_ksettings(struct mlx5e_priv *priv,\n\t\t\t\t     const struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5_port_eth_proto eproto;\n\tconst unsigned long *adver;\n\tbool an_changes = false;\n\tu8 an_disable_admin;\n\tbool ext_supported;\n\tu8 an_disable_cap;\n\tbool an_disable;\n\tu32 link_modes;\n\tu8 an_status;\n\tu8 autoneg;\n\tu32 speed;\n\tbool ext;\n\tint err;\n\n\tu32 (*ethtool2ptys_adver_func)(const unsigned long *adver);\n\n\tadver = link_ksettings->link_modes.advertising;\n\tautoneg = link_ksettings->base.autoneg;\n\tspeed = link_ksettings->base.speed;\n\n\text_supported = mlx5_ptys_ext_supported(mdev);\n\text = ext_requested(autoneg, adver, ext_supported);\n\tif (!ext_supported && ext)\n\t\treturn -EOPNOTSUPP;\n\n\tethtool2ptys_adver_func = ext ? mlx5e_ethtool2ptys_ext_adver_link :\n\t\t\t\t  mlx5e_ethtool2ptys_adver_link;\n\terr = mlx5_port_query_eth_proto(mdev, 1, ext, &eproto);\n\tif (err) {\n\t\tnetdev_err(priv->netdev, \"%s: query port eth proto failed: %d\\n\",\n\t\t\t   __func__, err);\n\t\tgoto out;\n\t}\n\tlink_modes = autoneg == AUTONEG_ENABLE ? ethtool2ptys_adver_func(adver) :\n\t\tmlx5_port_speed2linkmodes(mdev, speed, !ext);\n\n\terr = mlx5e_speed_validate(priv->netdev, ext, link_modes, autoneg);\n\tif (err)\n\t\tgoto out;\n\n\tlink_modes = link_modes & eproto.cap;\n\tif (!link_modes) {\n\t\tnetdev_err(priv->netdev, \"%s: Not supported link mode(s) requested\",\n\t\t\t   __func__);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmlx5_port_query_eth_autoneg(mdev, &an_status, &an_disable_cap,\n\t\t\t\t    &an_disable_admin);\n\n\tan_disable = autoneg == AUTONEG_DISABLE;\n\tan_changes = ((!an_disable && an_disable_admin) ||\n\t\t      (an_disable && !an_disable_admin));\n\n\tif (!an_changes && link_modes == eproto.admin)\n\t\tgoto out;\n\n\tmlx5_port_set_eth_ptys(mdev, an_disable, link_modes, ext);\n\tmlx5_toggle_port_link(mdev);\n\nout:\n\treturn err;\n}\n\nstatic int mlx5e_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn mlx5e_ethtool_set_link_ksettings(priv, link_ksettings);\n}\n\nu32 mlx5e_ethtool_get_rxfh_key_size(struct mlx5e_priv *priv)\n{\n\treturn sizeof_field(struct mlx5e_rss_params_hash, toeplitz_hash_key);\n}\n\nstatic u32 mlx5e_get_rxfh_key_size(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn mlx5e_ethtool_get_rxfh_key_size(priv);\n}\n\nu32 mlx5e_ethtool_get_rxfh_indir_size(struct mlx5e_priv *priv)\n{\n\treturn MLX5E_INDIR_RQT_SIZE;\n}\n\nstatic u32 mlx5e_get_rxfh_indir_size(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn mlx5e_ethtool_get_rxfh_indir_size(priv);\n}\n\nstatic int mlx5e_get_rxfh_context(struct net_device *dev, u32 *indir,\n\t\t\t\t  u8 *key, u8 *hfunc, u32 rss_context)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\terr = mlx5e_rx_res_rss_get_rxfh(priv->rx_res, rss_context, indir, key, hfunc);\n\tmutex_unlock(&priv->state_lock);\n\treturn err;\n}\n\nstatic int mlx5e_set_rxfh_context(struct net_device *dev, const u32 *indir,\n\t\t\t\t  const u8 *key, const u8 hfunc,\n\t\t\t\t  u32 *rss_context, bool delete)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\tif (delete) {\n\t\terr = mlx5e_rx_res_rss_destroy(priv->rx_res, *rss_context);\n\t\tgoto unlock;\n\t}\n\n\tif (*rss_context == ETH_RXFH_CONTEXT_ALLOC) {\n\t\tunsigned int count = priv->channels.params.num_channels;\n\n\t\terr = mlx5e_rx_res_rss_init(priv->rx_res, rss_context, count);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, *rss_context, indir, key,\n\t\t\t\t\thfunc == ETH_RSS_HASH_NO_CHANGE ? NULL : &hfunc);\n\nunlock:\n\tmutex_unlock(&priv->state_lock);\n\treturn err;\n}\n\nint mlx5e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t   u8 *hfunc)\n{\n\treturn mlx5e_get_rxfh_context(netdev, indir, key, hfunc, 0);\n}\n\nint mlx5e_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t   const u8 *key, const u8 hfunc)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\terr = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, 0, indir, key,\n\t\t\t\t\thfunc == ETH_RSS_HASH_NO_CHANGE ? NULL : &hfunc);\n\tmutex_unlock(&priv->state_lock);\n\treturn err;\n}\n\n#define MLX5E_PFC_PREVEN_AUTO_TOUT_MSEC\t\t100\n#define MLX5E_PFC_PREVEN_TOUT_MAX_MSEC\t\t8000\n#define MLX5E_PFC_PREVEN_MINOR_PRECENT\t\t85\n#define MLX5E_PFC_PREVEN_TOUT_MIN_MSEC\t\t80\n#define MLX5E_DEVICE_STALL_MINOR_WATERMARK(critical_tout) \\\n\tmax_t(u16, MLX5E_PFC_PREVEN_TOUT_MIN_MSEC, \\\n\t      (critical_tout * MLX5E_PFC_PREVEN_MINOR_PRECENT) / 100)\n\nstatic int mlx5e_get_pfc_prevention_tout(struct net_device *netdev,\n\t\t\t\t\t u16 *pfc_prevention_tout)\n{\n\tstruct mlx5e_priv *priv    = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tif (!MLX5_CAP_PCAM_FEATURE((priv)->mdev, pfcc_mask) ||\n\t    !MLX5_CAP_DEBUG((priv)->mdev, stall_detect))\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_query_port_stall_watermark(mdev, pfc_prevention_tout, NULL);\n}\n\nstatic int mlx5e_set_pfc_prevention_tout(struct net_device *netdev,\n\t\t\t\t\t u16 pfc_preven)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu16 critical_tout;\n\tu16 minor;\n\n\tif (!MLX5_CAP_PCAM_FEATURE((priv)->mdev, pfcc_mask) ||\n\t    !MLX5_CAP_DEBUG((priv)->mdev, stall_detect))\n\t\treturn -EOPNOTSUPP;\n\n\tcritical_tout = (pfc_preven == PFC_STORM_PREVENTION_AUTO) ?\n\t\t\tMLX5E_PFC_PREVEN_AUTO_TOUT_MSEC :\n\t\t\tpfc_preven;\n\n\tif (critical_tout != PFC_STORM_PREVENTION_DISABLE &&\n\t    (critical_tout > MLX5E_PFC_PREVEN_TOUT_MAX_MSEC ||\n\t     critical_tout < MLX5E_PFC_PREVEN_TOUT_MIN_MSEC)) {\n\t\tnetdev_info(netdev, \"%s: pfc prevention tout not in range (%d-%d)\\n\",\n\t\t\t    __func__, MLX5E_PFC_PREVEN_TOUT_MIN_MSEC,\n\t\t\t    MLX5E_PFC_PREVEN_TOUT_MAX_MSEC);\n\t\treturn -EINVAL;\n\t}\n\n\tminor = MLX5E_DEVICE_STALL_MINOR_WATERMARK(critical_tout);\n\treturn mlx5_set_port_stall_watermark(mdev, critical_tout,\n\t\t\t\t\t     minor);\n}\n\nstatic int mlx5e_get_tunable(struct net_device *dev,\n\t\t\t     const struct ethtool_tunable *tuna,\n\t\t\t     void *data)\n{\n\tint err;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PFC_PREVENTION_TOUT:\n\t\terr = mlx5e_get_pfc_prevention_tout(dev, data);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5e_set_tunable(struct net_device *dev,\n\t\t\t     const struct ethtool_tunable *tuna,\n\t\t\t     const void *data)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PFC_PREVENTION_TOUT:\n\t\terr = mlx5e_set_pfc_prevention_tout(dev, *(u16 *)data);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&priv->state_lock);\n\treturn err;\n}\n\nstatic void mlx5e_get_pause_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_pause_stats *pause_stats)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tmlx5e_stats_pause_get(priv, pause_stats);\n}\n\nvoid mlx5e_ethtool_get_pauseparam(struct mlx5e_priv *priv,\n\t\t\t\t  struct ethtool_pauseparam *pauseparam)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint err;\n\n\terr = mlx5_query_port_pause(mdev, &pauseparam->rx_pause,\n\t\t\t\t    &pauseparam->tx_pause);\n\tif (err) {\n\t\tnetdev_err(priv->netdev, \"%s: mlx5_query_port_pause failed:0x%x\\n\",\n\t\t\t   __func__, err);\n\t}\n}\n\nstatic void mlx5e_get_pauseparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_pauseparam *pauseparam)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tmlx5e_ethtool_get_pauseparam(priv, pauseparam);\n}\n\nint mlx5e_ethtool_set_pauseparam(struct mlx5e_priv *priv,\n\t\t\t\t struct ethtool_pauseparam *pauseparam)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(mdev, vport_group_manager))\n\t\treturn -EOPNOTSUPP;\n\n\tif (pauseparam->autoneg)\n\t\treturn -EINVAL;\n\n\terr = mlx5_set_port_pause(mdev,\n\t\t\t\t  pauseparam->rx_pause ? 1 : 0,\n\t\t\t\t  pauseparam->tx_pause ? 1 : 0);\n\tif (err) {\n\t\tnetdev_err(priv->netdev, \"%s: mlx5_set_port_pause failed:0x%x\\n\",\n\t\t\t   __func__, err);\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5e_set_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pauseparam)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn mlx5e_ethtool_set_pauseparam(priv, pauseparam);\n}\n\nint mlx5e_ethtool_get_ts_info(struct mlx5e_priv *priv,\n\t\t\t      struct ethtool_ts_info *info)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tinfo->phc_index = mlx5_clock_get_ptp_index(mdev);\n\n\tif (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz) ||\n\t    info->phc_index == -1)\n\t\treturn 0;\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) |\n\t\t\t BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic int mlx5e_get_ts_info(struct net_device *dev,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn mlx5e_ethtool_get_ts_info(priv, info);\n}\n\nstatic __u32 mlx5e_get_wol_supported(struct mlx5_core_dev *mdev)\n{\n\t__u32 ret = 0;\n\n\tif (MLX5_CAP_GEN(mdev, wol_g))\n\t\tret |= WAKE_MAGIC;\n\n\tif (MLX5_CAP_GEN(mdev, wol_s))\n\t\tret |= WAKE_MAGICSECURE;\n\n\tif (MLX5_CAP_GEN(mdev, wol_a))\n\t\tret |= WAKE_ARP;\n\n\tif (MLX5_CAP_GEN(mdev, wol_b))\n\t\tret |= WAKE_BCAST;\n\n\tif (MLX5_CAP_GEN(mdev, wol_m))\n\t\tret |= WAKE_MCAST;\n\n\tif (MLX5_CAP_GEN(mdev, wol_u))\n\t\tret |= WAKE_UCAST;\n\n\tif (MLX5_CAP_GEN(mdev, wol_p))\n\t\tret |= WAKE_PHY;\n\n\treturn ret;\n}\n\nstatic __u32 mlx5e_reformat_wol_mode_mlx5_to_linux(u8 mode)\n{\n\t__u32 ret = 0;\n\n\tif (mode & MLX5_WOL_MAGIC)\n\t\tret |= WAKE_MAGIC;\n\n\tif (mode & MLX5_WOL_SECURED_MAGIC)\n\t\tret |= WAKE_MAGICSECURE;\n\n\tif (mode & MLX5_WOL_ARP)\n\t\tret |= WAKE_ARP;\n\n\tif (mode & MLX5_WOL_BROADCAST)\n\t\tret |= WAKE_BCAST;\n\n\tif (mode & MLX5_WOL_MULTICAST)\n\t\tret |= WAKE_MCAST;\n\n\tif (mode & MLX5_WOL_UNICAST)\n\t\tret |= WAKE_UCAST;\n\n\tif (mode & MLX5_WOL_PHY_ACTIVITY)\n\t\tret |= WAKE_PHY;\n\n\treturn ret;\n}\n\nstatic u8 mlx5e_reformat_wol_mode_linux_to_mlx5(__u32 mode)\n{\n\tu8 ret = 0;\n\n\tif (mode & WAKE_MAGIC)\n\t\tret |= MLX5_WOL_MAGIC;\n\n\tif (mode & WAKE_MAGICSECURE)\n\t\tret |= MLX5_WOL_SECURED_MAGIC;\n\n\tif (mode & WAKE_ARP)\n\t\tret |= MLX5_WOL_ARP;\n\n\tif (mode & WAKE_BCAST)\n\t\tret |= MLX5_WOL_BROADCAST;\n\n\tif (mode & WAKE_MCAST)\n\t\tret |= MLX5_WOL_MULTICAST;\n\n\tif (mode & WAKE_UCAST)\n\t\tret |= MLX5_WOL_UNICAST;\n\n\tif (mode & WAKE_PHY)\n\t\tret |= MLX5_WOL_PHY_ACTIVITY;\n\n\treturn ret;\n}\n\nstatic void mlx5e_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 mlx5_wol_mode;\n\tint err;\n\n\tmemset(wol, 0, sizeof(*wol));\n\n\twol->supported = mlx5e_get_wol_supported(mdev);\n\tif (!wol->supported)\n\t\treturn;\n\n\terr = mlx5_query_port_wol(mdev, &mlx5_wol_mode);\n\tif (err)\n\t\treturn;\n\n\twol->wolopts = mlx5e_reformat_wol_mode_mlx5_to_linux(mlx5_wol_mode);\n}\n\nstatic int mlx5e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\t__u32 wol_supported = mlx5e_get_wol_supported(mdev);\n\tu32 mlx5_wol_mode;\n\n\tif (!wol_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wol->wolopts & ~wol_supported)\n\t\treturn -EINVAL;\n\n\tmlx5_wol_mode = mlx5e_reformat_wol_mode_linux_to_mlx5(wol->wolopts);\n\n\treturn mlx5_set_port_wol(mdev, mlx5_wol_mode);\n}\n\nstatic void mlx5e_get_fec_stats(struct net_device *netdev,\n\t\t\t\tstruct ethtool_fec_stats *fec_stats)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tmlx5e_stats_fec_get(priv, fec_stats);\n}\n\nstatic int mlx5e_get_fecparam(struct net_device *netdev,\n\t\t\t      struct ethtool_fecparam *fecparam)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu16 fec_configured;\n\tu32 fec_active;\n\tint err;\n\n\terr = mlx5e_get_fec_mode(mdev, &fec_active, &fec_configured);\n\n\tif (err)\n\t\treturn err;\n\n\tfecparam->active_fec = pplm2ethtool_fec((unsigned long)fec_active,\n\t\t\t\t\t\tsizeof(unsigned long) * BITS_PER_BYTE);\n\n\tif (!fecparam->active_fec)\n\t\treturn -EOPNOTSUPP;\n\n\tfecparam->fec = pplm2ethtool_fec((unsigned long)fec_configured,\n\t\t\t\t\t sizeof(unsigned long) * BITS_PER_BYTE);\n\n\treturn 0;\n}\n\nstatic int mlx5e_set_fecparam(struct net_device *netdev,\n\t\t\t      struct ethtool_fecparam *fecparam)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tunsigned long fec_bitmap;\n\tu16 fec_policy = 0;\n\tint mode;\n\tint err;\n\n\tbitmap_from_arr32(&fec_bitmap, &fecparam->fec, sizeof(fecparam->fec) * BITS_PER_BYTE);\n\tif (bitmap_weight(&fec_bitmap, ETHTOOL_FEC_LLRS_BIT + 1) > 1)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (mode = 0; mode < ARRAY_SIZE(pplm_fec_2_ethtool); mode++) {\n\t\tif (!(pplm_fec_2_ethtool[mode] & fecparam->fec))\n\t\t\tcontinue;\n\t\tfec_policy |= (1 << mode);\n\t\tbreak;\n\t}\n\n\terr = mlx5e_set_fec_mode(mdev, fec_policy);\n\n\tif (err)\n\t\treturn err;\n\n\tmlx5_toggle_port_link(mdev);\n\n\treturn 0;\n}\n\nstatic int mlx5e_set_phys_id(struct net_device *dev,\n\t\t\t     enum ethtool_phys_id_state state)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu16 beacon_duration;\n\n\tif (!MLX5_CAP_GEN(mdev, beacon_led))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tbeacon_duration = MLX5_BEACON_DURATION_INF;\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tbeacon_duration = MLX5_BEACON_DURATION_OFF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn mlx5_set_port_beacon(mdev, beacon_duration);\n}\n\nstatic int mlx5e_get_module_info(struct net_device *netdev,\n\t\t\t\t struct ethtool_modinfo *modinfo)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *dev = priv->mdev;\n\tint size_read = 0;\n\tu8 data[4] = {0};\n\n\tsize_read = mlx5_query_module_eeprom(dev, 0, 2, data);\n\tif (size_read < 2)\n\t\treturn -EIO;\n\n\t \n\tswitch (data[0]) {\n\tcase MLX5_MODULE_ID_QSFP:\n\t\tmodinfo->type       = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\tbreak;\n\tcase MLX5_MODULE_ID_QSFP_PLUS:\n\tcase MLX5_MODULE_ID_QSFP28:\n\t\t \n\t\tif (data[0] == MLX5_MODULE_ID_QSFP28 || data[1] >= 0x3) {\n\t\t\tmodinfo->type       = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\t\t} else {\n\t\t\tmodinfo->type       = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\t}\n\t\tbreak;\n\tcase MLX5_MODULE_ID_SFP:\n\t\tmodinfo->type       = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->netdev, \"%s: cable type not recognized:0x%x\\n\",\n\t\t\t   __func__, data[0]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_get_module_eeprom(struct net_device *netdev,\n\t\t\t\t   struct ethtool_eeprom *ee,\n\t\t\t\t   u8 *data)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint offset = ee->offset;\n\tint size_read;\n\tint i = 0;\n\n\tif (!ee->len)\n\t\treturn -EINVAL;\n\n\tmemset(data, 0, ee->len);\n\n\twhile (i < ee->len) {\n\t\tsize_read = mlx5_query_module_eeprom(mdev, offset, ee->len - i,\n\t\t\t\t\t\t     data + i);\n\n\t\tif (!size_read)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tif (size_read < 0) {\n\t\t\tnetdev_err(priv->netdev, \"%s: mlx5_query_eeprom failed:0x%x\\n\",\n\t\t\t\t   __func__, size_read);\n\t\t\treturn size_read;\n\t\t}\n\n\t\ti += size_read;\n\t\toffset += size_read;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_get_module_eeprom_by_page(struct net_device *netdev,\n\t\t\t\t\t   const struct ethtool_module_eeprom *page_data,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_module_eeprom_query_params query;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 *data = page_data->data;\n\tint size_read;\n\tint i = 0;\n\n\tif (!page_data->length)\n\t\treturn -EINVAL;\n\n\tmemset(data, 0, page_data->length);\n\n\tquery.offset = page_data->offset;\n\tquery.i2c_address = page_data->i2c_address;\n\tquery.bank = page_data->bank;\n\tquery.page = page_data->page;\n\twhile (i < page_data->length) {\n\t\tquery.size = page_data->length - i;\n\t\tsize_read = mlx5_query_module_eeprom_by_page(mdev, &query, data + i);\n\n\t\t \n\t\tif (!size_read)\n\t\t\treturn i;\n\n\t\tif (size_read == -EINVAL)\n\t\t\treturn -EINVAL;\n\t\tif (size_read < 0) {\n\t\t\tnetdev_err(priv->netdev, \"%s: mlx5_query_module_eeprom_by_page failed:0x%x\\n\",\n\t\t\t\t   __func__, size_read);\n\t\t\treturn i;\n\t\t}\n\n\t\ti += size_read;\n\t\tquery.offset += size_read;\n\t}\n\n\treturn i;\n}\n\nint mlx5e_ethtool_flash_device(struct mlx5e_priv *priv,\n\t\t\t       struct ethtool_flash *flash)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct net_device *dev = priv->netdev;\n\tconst struct firmware *fw;\n\tint err;\n\n\tif (flash->region != ETHTOOL_FLASH_ALL_REGIONS)\n\t\treturn -EOPNOTSUPP;\n\n\terr = request_firmware_direct(&fw, flash->data, &dev->dev);\n\tif (err)\n\t\treturn err;\n\n\tdev_hold(dev);\n\trtnl_unlock();\n\n\terr = mlx5_firmware_flash(mdev, fw, NULL);\n\trelease_firmware(fw);\n\n\trtnl_lock();\n\tdev_put(dev);\n\treturn err;\n}\n\nstatic int mlx5e_flash_device(struct net_device *dev,\n\t\t\t      struct ethtool_flash *flash)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn mlx5e_ethtool_flash_device(priv, flash);\n}\n\nstatic int set_pflag_cqe_based_moder(struct net_device *netdev, bool enable,\n\t\t\t\t     bool is_rx_cq)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tu8 cq_period_mode, current_cq_period_mode;\n\tstruct mlx5e_params new_params;\n\n\tif (enable && !MLX5_CAP_GEN(priv->mdev, cq_period_start_from_cqe))\n\t\treturn -EOPNOTSUPP;\n\n\tcq_period_mode = cqe_mode_to_period_mode(enable);\n\n\tcurrent_cq_period_mode = is_rx_cq ?\n\t\tpriv->channels.params.rx_cq_moderation.cq_period_mode :\n\t\tpriv->channels.params.tx_cq_moderation.cq_period_mode;\n\n\tif (cq_period_mode == current_cq_period_mode)\n\t\treturn 0;\n\n\tnew_params = priv->channels.params;\n\tif (is_rx_cq)\n\t\tmlx5e_set_rx_cq_mode_params(&new_params, cq_period_mode);\n\telse\n\t\tmlx5e_set_tx_cq_mode_params(&new_params, cq_period_mode);\n\n\treturn mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);\n}\n\nstatic int set_pflag_tx_cqe_based_moder(struct net_device *netdev, bool enable)\n{\n\treturn set_pflag_cqe_based_moder(netdev, enable, false);\n}\n\nstatic int set_pflag_rx_cqe_based_moder(struct net_device *netdev, bool enable)\n{\n\treturn set_pflag_cqe_based_moder(netdev, enable, true);\n}\n\nint mlx5e_modify_rx_cqe_compression_locked(struct mlx5e_priv *priv, bool new_val, bool rx_filter)\n{\n\tbool curr_val = MLX5E_GET_PFLAG(&priv->channels.params, MLX5E_PFLAG_RX_CQE_COMPRESS);\n\tstruct mlx5e_params new_params;\n\tint err = 0;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, cqe_compression))\n\t\treturn new_val ? -EOPNOTSUPP : 0;\n\n\tif (curr_val == new_val)\n\t\treturn 0;\n\n\tif (new_val && !mlx5e_profile_feature_cap(priv->profile, PTP_RX) && rx_filter) {\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"Profile doesn't support enabling of CQE compression while hardware time-stamping is enabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->channels.params.packet_merge.type == MLX5E_PACKET_MERGE_SHAMPO) {\n\t\tnetdev_warn(priv->netdev, \"Can't set CQE compression with HW-GRO, disable it first.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnew_params = priv->channels.params;\n\tMLX5E_SET_PFLAG(&new_params, MLX5E_PFLAG_RX_CQE_COMPRESS, new_val);\n\tif (rx_filter)\n\t\tnew_params.ptp_rx = new_val;\n\n\tif (new_params.ptp_rx == priv->channels.params.ptp_rx)\n\t\terr = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);\n\telse\n\t\terr = mlx5e_safe_switch_params(priv, &new_params, mlx5e_ptp_rx_manage_fs_ctx,\n\t\t\t\t\t       &new_params.ptp_rx, true);\n\tif (err)\n\t\treturn err;\n\n\tnetdev_dbg(priv->netdev, \"MLX5E: RxCqeCmprss was turned %s\\n\",\n\t\t   MLX5E_GET_PFLAG(&priv->channels.params,\n\t\t\t\t   MLX5E_PFLAG_RX_CQE_COMPRESS) ? \"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nstatic int set_pflag_rx_cqe_compress(struct net_device *netdev,\n\t\t\t\t     bool enable)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tbool rx_filter;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(mdev, cqe_compression))\n\t\treturn -EOPNOTSUPP;\n\n\trx_filter = priv->tstamp.rx_filter != HWTSTAMP_FILTER_NONE;\n\terr = mlx5e_modify_rx_cqe_compression_locked(priv, enable, rx_filter);\n\tif (err)\n\t\treturn err;\n\n\tpriv->channels.params.rx_cqe_compress_def = enable;\n\n\treturn 0;\n}\n\nstatic int set_pflag_rx_striding_rq(struct net_device *netdev, bool enable)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_params new_params;\n\tint err;\n\n\tif (enable) {\n\t\t \n\t\tint err = mlx5e_mpwrq_validate_regular(mdev, &priv->channels.params);\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (priv->channels.params.packet_merge.type != MLX5E_PACKET_MERGE_NONE) {\n\t\tnetdev_warn(netdev, \"Can't set legacy RQ with HW-GRO/LRO, disable them first\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnew_params = priv->channels.params;\n\n\tMLX5E_SET_PFLAG(&new_params, MLX5E_PFLAG_RX_STRIDING_RQ, enable);\n\tmlx5e_set_rq_type(mdev, &new_params);\n\n\terr = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmlx5e_set_xdp_feature(netdev);\n\n\treturn 0;\n}\n\nstatic int set_pflag_rx_no_csum_complete(struct net_device *netdev, bool enable)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5e_channels *channels = &priv->channels;\n\tstruct mlx5e_channel *c;\n\tint i;\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state) ||\n\t    priv->channels.params.xdp_prog)\n\t\treturn 0;\n\n\tfor (i = 0; i < channels->num; i++) {\n\t\tc = channels->c[i];\n\t\tif (enable)\n\t\t\t__set_bit(MLX5E_RQ_STATE_NO_CSUM_COMPLETE, &c->rq.state);\n\t\telse\n\t\t\t__clear_bit(MLX5E_RQ_STATE_NO_CSUM_COMPLETE, &c->rq.state);\n\t}\n\n\treturn 0;\n}\n\nstatic int set_pflag_tx_mpwqe_common(struct net_device *netdev, u32 flag, bool enable)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_params new_params;\n\n\tif (enable && !mlx5e_tx_mpwqe_supported(mdev))\n\t\treturn -EOPNOTSUPP;\n\n\tnew_params = priv->channels.params;\n\n\tMLX5E_SET_PFLAG(&new_params, flag, enable);\n\n\treturn mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);\n}\n\nstatic int set_pflag_xdp_tx_mpwqe(struct net_device *netdev, bool enable)\n{\n\treturn set_pflag_tx_mpwqe_common(netdev, MLX5E_PFLAG_XDP_TX_MPWQE, enable);\n}\n\nstatic int set_pflag_skb_tx_mpwqe(struct net_device *netdev, bool enable)\n{\n\treturn set_pflag_tx_mpwqe_common(netdev, MLX5E_PFLAG_SKB_TX_MPWQE, enable);\n}\n\nstatic int set_pflag_tx_port_ts(struct net_device *netdev, bool enable)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_params new_params;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(mdev, ts_cqe_to_dest_cqn) ||\n\t    !MLX5_CAP_GEN_2(mdev, ts_cqe_metadata_size2wqe_counter))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (mlx5e_selq_is_htb_enabled(&priv->selq)) {\n\t\tnetdev_err(priv->netdev, \"%s: HTB offload is active, cannot change the PTP state\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tnew_params = priv->channels.params;\n\t \n\tif (enable && new_params.mqprio.mode == TC_MQPRIO_MODE_CHANNEL) {\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"%s: MQPRIO mode channel offload is active, cannot set the TX-port-TS\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\tMLX5E_SET_PFLAG(&new_params, MLX5E_PFLAG_TX_PORT_TS, enable);\n\t \n\n\terr = mlx5e_safe_switch_params(priv, &new_params,\n\t\t\t\t       mlx5e_num_channels_changed_ctx, NULL, true);\n\tif (!err)\n\t\tpriv->tx_ptp_opened = true;\n\n\treturn err;\n}\n\nstatic const struct pflag_desc mlx5e_priv_flags[MLX5E_NUM_PFLAGS] = {\n\t{ \"rx_cqe_moder\",        set_pflag_rx_cqe_based_moder },\n\t{ \"tx_cqe_moder\",        set_pflag_tx_cqe_based_moder },\n\t{ \"rx_cqe_compress\",     set_pflag_rx_cqe_compress },\n\t{ \"rx_striding_rq\",      set_pflag_rx_striding_rq },\n\t{ \"rx_no_csum_complete\", set_pflag_rx_no_csum_complete },\n\t{ \"xdp_tx_mpwqe\",        set_pflag_xdp_tx_mpwqe },\n\t{ \"skb_tx_mpwqe\",        set_pflag_skb_tx_mpwqe },\n\t{ \"tx_port_ts\",          set_pflag_tx_port_ts },\n};\n\nstatic int mlx5e_handle_pflag(struct net_device *netdev,\n\t\t\t      u32 wanted_flags,\n\t\t\t      enum mlx5e_priv_flag flag)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tbool enable = !!(wanted_flags & BIT(flag));\n\tu32 changes = wanted_flags ^ priv->channels.params.pflags;\n\tint err;\n\n\tif (!(changes & BIT(flag)))\n\t\treturn 0;\n\n\terr = mlx5e_priv_flags[flag].handler(netdev, enable);\n\tif (err) {\n\t\tnetdev_err(netdev, \"%s private flag '%s' failed err %d\\n\",\n\t\t\t   enable ? \"Enable\" : \"Disable\", mlx5e_priv_flags[flag].name, err);\n\t\treturn err;\n\t}\n\n\tMLX5E_SET_PFLAG(&priv->channels.params, flag, enable);\n\treturn 0;\n}\n\nstatic int mlx5e_set_priv_flags(struct net_device *netdev, u32 pflags)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tenum mlx5e_priv_flag pflag;\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\n\tfor (pflag = 0; pflag < MLX5E_NUM_PFLAGS; pflag++) {\n\t\terr = mlx5e_handle_pflag(netdev, pflags, pflag);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&priv->state_lock);\n\n\t \n\tnetdev_update_features(netdev);\n\n\treturn err;\n}\n\nstatic u32 mlx5e_get_priv_flags(struct net_device *netdev)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\treturn priv->channels.params.pflags;\n}\n\nstatic int mlx5e_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\n\t\t\t   u32 *rule_locs)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\t \n\tif (info->cmd == ETHTOOL_GRXRINGS) {\n\t\tinfo->data = priv->channels.params.num_channels;\n\t\treturn 0;\n\t}\n\n\treturn mlx5e_ethtool_get_rxnfc(priv, info, rule_locs);\n}\n\nstatic int mlx5e_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn mlx5e_ethtool_set_rxnfc(priv, cmd);\n}\n\nstatic int query_port_status_opcode(struct mlx5_core_dev *mdev, u32 *status_opcode)\n{\n\tstruct mlx5_ifc_pddr_troubleshooting_page_bits *pddr_troubleshooting_page;\n\tu32 in[MLX5_ST_SZ_DW(pddr_reg)] = {};\n\tu32 out[MLX5_ST_SZ_DW(pddr_reg)];\n\tint err;\n\n\tMLX5_SET(pddr_reg, in, local_port, 1);\n\tMLX5_SET(pddr_reg, in, page_select,\n\t\t MLX5_PDDR_REG_PAGE_SELECT_TROUBLESHOOTING_INFO_PAGE);\n\n\tpddr_troubleshooting_page = MLX5_ADDR_OF(pddr_reg, in, page_data);\n\tMLX5_SET(pddr_troubleshooting_page, pddr_troubleshooting_page,\n\t\t group_opcode, MLX5_PDDR_REG_TRBLSH_GROUP_OPCODE_MONITOR);\n\terr = mlx5_core_access_reg(mdev, in, sizeof(in), out,\n\t\t\t\t   sizeof(out), MLX5_REG_PDDR, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tpddr_troubleshooting_page = MLX5_ADDR_OF(pddr_reg, out, page_data);\n\t*status_opcode = MLX5_GET(pddr_troubleshooting_page, pddr_troubleshooting_page,\n\t\t\t\t  status_opcode);\n\treturn 0;\n}\n\nstruct mlx5e_ethtool_link_ext_state_opcode_mapping {\n\tu32 status_opcode;\n\tenum ethtool_link_ext_state link_ext_state;\n\tu8 link_ext_substate;\n};\n\nstatic const struct mlx5e_ethtool_link_ext_state_opcode_mapping\nmlx5e_link_ext_state_opcode_map[] = {\n\t \n\t{2, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED},\n\t{3, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED},\n\t{4, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED},\n\t{36, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE},\n\t{38, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE},\n\t{39, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD},\n\n\t \n\t{5, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED},\n\t{6, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT},\n\t{7, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY},\n\t{8, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE, 0},\n\t{14, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT},\n\n\t \n\t{9, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK},\n\t{10, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK},\n\t{11, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS},\n\t{12, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED},\n\t{13, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED},\n\n\t \n\t{15, ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY, 0},\n\t{17, ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS},\n\t{42, ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE},\n\n\t \n\t{1024, ETHTOOL_LINK_EXT_STATE_NO_CABLE, 0},\n\n\t \n\t{16, ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE},\n\t{20, ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE},\n\t{29, ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE},\n\t{1025, ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE},\n\t{1029, ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE},\n\t{1031, ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE, 0},\n\n\t \n\t{1027, ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE, 0},\n\n\t \n\t{23, ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE, 0},\n\n\t \n\t{1032, ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED, 0},\n\n\t \n\t{1030, ETHTOOL_LINK_EXT_STATE_OVERHEAT, 0},\n};\n\nstatic void\nmlx5e_set_link_ext_state(struct mlx5e_ethtool_link_ext_state_opcode_mapping\n\t\t\t link_ext_state_mapping,\n\t\t\t struct ethtool_link_ext_state_info *link_ext_state_info)\n{\n\tswitch (link_ext_state_mapping.link_ext_state) {\n\tcase ETHTOOL_LINK_EXT_STATE_AUTONEG:\n\t\tlink_ext_state_info->autoneg =\n\t\t\tlink_ext_state_mapping.link_ext_substate;\n\t\tbreak;\n\tcase ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE:\n\t\tlink_ext_state_info->link_training =\n\t\t\tlink_ext_state_mapping.link_ext_substate;\n\t\tbreak;\n\tcase ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH:\n\t\tlink_ext_state_info->link_logical_mismatch =\n\t\t\tlink_ext_state_mapping.link_ext_substate;\n\t\tbreak;\n\tcase ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY:\n\t\tlink_ext_state_info->bad_signal_integrity =\n\t\t\tlink_ext_state_mapping.link_ext_substate;\n\t\tbreak;\n\tcase ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE:\n\t\tlink_ext_state_info->cable_issue =\n\t\t\tlink_ext_state_mapping.link_ext_substate;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tlink_ext_state_info->link_ext_state = link_ext_state_mapping.link_ext_state;\n}\n\nstatic int\nmlx5e_get_link_ext_state(struct net_device *dev,\n\t\t\t struct ethtool_link_ext_state_info *link_ext_state_info)\n{\n\tstruct mlx5e_ethtool_link_ext_state_opcode_mapping link_ext_state_mapping;\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tu32 status_opcode = 0;\n\tint i;\n\n\t \n\tif (netif_carrier_ok(dev))\n\t\treturn -ENODATA;\n\n\tif (query_port_status_opcode(priv->mdev, &status_opcode) ||\n\t    !status_opcode)\n\t\treturn -ENODATA;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlx5e_link_ext_state_opcode_map); i++) {\n\t\tlink_ext_state_mapping = mlx5e_link_ext_state_opcode_map[i];\n\t\tif (link_ext_state_mapping.status_opcode == status_opcode) {\n\t\t\tmlx5e_set_link_ext_state(link_ext_state_mapping,\n\t\t\t\t\t\t link_ext_state_info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENODATA;\n}\n\nstatic void mlx5e_get_eth_phy_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_eth_phy_stats *phy_stats)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tmlx5e_stats_eth_phy_get(priv, phy_stats);\n}\n\nstatic void mlx5e_get_eth_mac_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_eth_mac_stats *mac_stats)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tmlx5e_stats_eth_mac_get(priv, mac_stats);\n}\n\nstatic void mlx5e_get_eth_ctrl_stats(struct net_device *netdev,\n\t\t\t\t     struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tmlx5e_stats_eth_ctrl_get(priv, ctrl_stats);\n}\n\nstatic void mlx5e_get_rmon_stats(struct net_device *netdev,\n\t\t\t\t struct ethtool_rmon_stats *rmon_stats,\n\t\t\t\t const struct ethtool_rmon_hist_range **ranges)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\n\tmlx5e_stats_rmon_get(priv, rmon_stats, ranges);\n}\n\nconst struct ethtool_ops mlx5e_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE |\n\t\t\t\t     ETHTOOL_COALESCE_USE_CQE,\n\t.get_drvinfo       = mlx5e_get_drvinfo,\n\t.get_link          = ethtool_op_get_link,\n\t.get_link_ext_state  = mlx5e_get_link_ext_state,\n\t.get_strings       = mlx5e_get_strings,\n\t.get_sset_count    = mlx5e_get_sset_count,\n\t.get_ethtool_stats = mlx5e_get_ethtool_stats,\n\t.get_ringparam     = mlx5e_get_ringparam,\n\t.set_ringparam     = mlx5e_set_ringparam,\n\t.get_channels      = mlx5e_get_channels,\n\t.set_channels      = mlx5e_set_channels,\n\t.get_coalesce      = mlx5e_get_coalesce,\n\t.set_coalesce      = mlx5e_set_coalesce,\n\t.get_link_ksettings  = mlx5e_get_link_ksettings,\n\t.set_link_ksettings  = mlx5e_set_link_ksettings,\n\t.get_rxfh_key_size   = mlx5e_get_rxfh_key_size,\n\t.get_rxfh_indir_size = mlx5e_get_rxfh_indir_size,\n\t.get_rxfh          = mlx5e_get_rxfh,\n\t.set_rxfh          = mlx5e_set_rxfh,\n\t.get_rxfh_context  = mlx5e_get_rxfh_context,\n\t.set_rxfh_context  = mlx5e_set_rxfh_context,\n\t.get_rxnfc         = mlx5e_get_rxnfc,\n\t.set_rxnfc         = mlx5e_set_rxnfc,\n\t.get_tunable       = mlx5e_get_tunable,\n\t.set_tunable       = mlx5e_set_tunable,\n\t.get_pause_stats   = mlx5e_get_pause_stats,\n\t.get_pauseparam    = mlx5e_get_pauseparam,\n\t.set_pauseparam    = mlx5e_set_pauseparam,\n\t.get_ts_info       = mlx5e_get_ts_info,\n\t.set_phys_id       = mlx5e_set_phys_id,\n\t.get_wol\t   = mlx5e_get_wol,\n\t.set_wol\t   = mlx5e_set_wol,\n\t.get_module_info   = mlx5e_get_module_info,\n\t.get_module_eeprom = mlx5e_get_module_eeprom,\n\t.get_module_eeprom_by_page = mlx5e_get_module_eeprom_by_page,\n\t.flash_device      = mlx5e_flash_device,\n\t.get_priv_flags    = mlx5e_get_priv_flags,\n\t.set_priv_flags    = mlx5e_set_priv_flags,\n\t.self_test         = mlx5e_self_test,\n\t.get_fec_stats     = mlx5e_get_fec_stats,\n\t.get_fecparam      = mlx5e_get_fecparam,\n\t.set_fecparam      = mlx5e_set_fecparam,\n\t.get_eth_phy_stats = mlx5e_get_eth_phy_stats,\n\t.get_eth_mac_stats = mlx5e_get_eth_mac_stats,\n\t.get_eth_ctrl_stats = mlx5e_get_eth_ctrl_stats,\n\t.get_rmon_stats    = mlx5e_get_rmon_stats,\n\t.get_link_ext_stats = mlx5e_get_link_ext_stats\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}