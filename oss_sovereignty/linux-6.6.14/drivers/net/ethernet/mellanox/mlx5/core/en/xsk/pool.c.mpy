{
  "module_name": "pool.c",
  "hash_id": "6bdd8df7266fb918510be94773244903d5ac63582e88e7003f33dac93a8ab814",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/pool.c",
  "human_readable_source": "\n \n\n#include <net/xdp_sock_drv.h>\n#include \"pool.h\"\n#include \"setup.h\"\n#include \"en/params.h\"\n\nstatic int mlx5e_xsk_map_pool(struct mlx5e_priv *priv,\n\t\t\t      struct xsk_buff_pool *pool)\n{\n\tstruct device *dev = mlx5_core_dma_dev(priv->mdev);\n\n\treturn xsk_pool_dma_map(pool, dev, DMA_ATTR_SKIP_CPU_SYNC);\n}\n\nstatic void mlx5e_xsk_unmap_pool(struct mlx5e_priv *priv,\n\t\t\t\t struct xsk_buff_pool *pool)\n{\n\treturn xsk_pool_dma_unmap(pool, DMA_ATTR_SKIP_CPU_SYNC);\n}\n\nstatic int mlx5e_xsk_get_pools(struct mlx5e_xsk *xsk)\n{\n\tif (!xsk->pools) {\n\t\txsk->pools = kcalloc(MLX5E_MAX_NUM_CHANNELS,\n\t\t\t\t     sizeof(*xsk->pools), GFP_KERNEL);\n\t\tif (unlikely(!xsk->pools))\n\t\t\treturn -ENOMEM;\n\t}\n\n\txsk->refcnt++;\n\txsk->ever_used = true;\n\n\treturn 0;\n}\n\nstatic void mlx5e_xsk_put_pools(struct mlx5e_xsk *xsk)\n{\n\tif (!--xsk->refcnt) {\n\t\tkfree(xsk->pools);\n\t\txsk->pools = NULL;\n\t}\n}\n\nstatic int mlx5e_xsk_add_pool(struct mlx5e_xsk *xsk, struct xsk_buff_pool *pool, u16 ix)\n{\n\tint err;\n\n\terr = mlx5e_xsk_get_pools(xsk);\n\tif (unlikely(err))\n\t\treturn err;\n\n\txsk->pools[ix] = pool;\n\treturn 0;\n}\n\nstatic void mlx5e_xsk_remove_pool(struct mlx5e_xsk *xsk, u16 ix)\n{\n\txsk->pools[ix] = NULL;\n\n\tmlx5e_xsk_put_pools(xsk);\n}\n\nstatic bool mlx5e_xsk_is_pool_sane(struct xsk_buff_pool *pool)\n{\n\treturn xsk_pool_get_headroom(pool) <= 0xffff &&\n\t\txsk_pool_get_chunk_size(pool) <= 0xffff;\n}\n\nvoid mlx5e_build_xsk_param(struct xsk_buff_pool *pool, struct mlx5e_xsk_param *xsk)\n{\n\txsk->headroom = xsk_pool_get_headroom(pool);\n\txsk->chunk_size = xsk_pool_get_chunk_size(pool);\n\txsk->unaligned = pool->unaligned;\n}\n\nstatic int mlx5e_xsk_enable_locked(struct mlx5e_priv *priv,\n\t\t\t\t   struct xsk_buff_pool *pool, u16 ix)\n{\n\tstruct mlx5e_params *params = &priv->channels.params;\n\tstruct mlx5e_xsk_param xsk;\n\tstruct mlx5e_channel *c;\n\tint err;\n\n\tif (unlikely(mlx5e_xsk_get_pool(&priv->channels.params, &priv->xsk, ix)))\n\t\treturn -EBUSY;\n\n\tif (unlikely(!mlx5e_xsk_is_pool_sane(pool)))\n\t\treturn -EINVAL;\n\n\terr = mlx5e_xsk_map_pool(priv, pool);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = mlx5e_xsk_add_pool(&priv->xsk, pool, ix);\n\tif (unlikely(err))\n\t\tgoto err_unmap_pool;\n\n\tmlx5e_build_xsk_param(pool, &xsk);\n\n\tif (priv->channels.params.rq_wq_type == MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ &&\n\t    mlx5e_mpwrq_umr_mode(priv->mdev, &xsk) == MLX5E_MPWRQ_UMR_MODE_OVERSIZED) {\n\t\tconst char *recommendation = is_power_of_2(xsk.chunk_size) ?\n\t\t\t\"Upgrade firmware\" : \"Disable striding RQ\";\n\n\t\tmlx5_core_warn(priv->mdev, \"Expected slowdown with XSK frame size %u. %s for better performance.\\n\",\n\t\t\t       xsk.chunk_size, recommendation);\n\t}\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\t \n\t\tgoto validate_closed;\n\t}\n\n\tif (!params->xdp_prog) {\n\t\t \n\t\tgoto validate_closed;\n\t}\n\n\tc = priv->channels.c[ix];\n\n\terr = mlx5e_open_xsk(priv, params, &xsk, pool, c);\n\tif (unlikely(err))\n\t\tgoto err_remove_pool;\n\n\tmlx5e_activate_xsk(c);\n\tmlx5e_trigger_napi_icosq(c);\n\n\t \n\n\tmlx5e_rx_res_xsk_update(priv->rx_res, &priv->channels, ix, true);\n\n\tmlx5e_deactivate_rq(&c->rq);\n\tmlx5e_flush_rq(&c->rq, MLX5_RQC_STATE_RDY);\n\n\treturn 0;\n\nerr_remove_pool:\n\tmlx5e_xsk_remove_pool(&priv->xsk, ix);\n\nerr_unmap_pool:\n\tmlx5e_xsk_unmap_pool(priv, pool);\n\n\treturn err;\n\nvalidate_closed:\n\t \n\tif (!mlx5e_validate_xsk_param(params, &xsk, priv->mdev)) {\n\t\terr = -EINVAL;\n\t\tgoto err_remove_pool;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_xsk_disable_locked(struct mlx5e_priv *priv, u16 ix)\n{\n\tstruct xsk_buff_pool *pool = mlx5e_xsk_get_pool(&priv->channels.params,\n\t\t\t\t\t\t   &priv->xsk, ix);\n\tstruct mlx5e_channel *c;\n\n\tif (unlikely(!pool))\n\t\treturn -EINVAL;\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state))\n\t\tgoto remove_pool;\n\n\t \n\tif (!priv->channels.params.xdp_prog)\n\t\tgoto remove_pool;\n\n\tc = priv->channels.c[ix];\n\n\tmlx5e_activate_rq(&c->rq);\n\tmlx5e_trigger_napi_icosq(c);\n\tmlx5e_wait_for_min_rx_wqes(&c->rq, MLX5E_RQ_WQES_TIMEOUT);\n\n\tmlx5e_rx_res_xsk_update(priv->rx_res, &priv->channels, ix, false);\n\n\tmlx5e_deactivate_xsk(c);\n\tmlx5e_close_xsk(c);\n\nremove_pool:\n\tmlx5e_xsk_remove_pool(&priv->xsk, ix);\n\tmlx5e_xsk_unmap_pool(priv, pool);\n\n\treturn 0;\n}\n\nstatic int mlx5e_xsk_enable_pool(struct mlx5e_priv *priv, struct xsk_buff_pool *pool,\n\t\t\t\t u16 ix)\n{\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\terr = mlx5e_xsk_enable_locked(priv, pool, ix);\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\nstatic int mlx5e_xsk_disable_pool(struct mlx5e_priv *priv, u16 ix)\n{\n\tint err;\n\n\tmutex_lock(&priv->state_lock);\n\terr = mlx5e_xsk_disable_locked(priv, ix);\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\nint mlx5e_xsk_setup_pool(struct net_device *dev, struct xsk_buff_pool *pool, u16 qid)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5e_params *params = &priv->channels.params;\n\n\tif (unlikely(qid >= params->num_channels))\n\t\treturn -EINVAL;\n\n\treturn pool ? mlx5e_xsk_enable_pool(priv, pool, qid) :\n\t\t      mlx5e_xsk_disable_pool(priv, qid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}