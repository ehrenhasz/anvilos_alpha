{
  "module_name": "tc_tun_geneve.c",
  "hash_id": "448720bc98aac797ad30c2b71b1d1951b64ff59eeda2f380d0291abf88c51b89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun_geneve.c",
  "human_readable_source": "\n \n\n#include <net/geneve.h>\n#include \"lib/geneve.h\"\n#include \"en/tc_tun.h\"\n\n#define MLX5E_GENEVE_VER 0\n\nstatic bool mlx5e_tc_tun_can_offload_geneve(struct mlx5e_priv *priv)\n{\n\treturn !!(MLX5_CAP_GEN(priv->mdev, flex_parser_protocols) & MLX5_FLEX_PROTO_GENEVE);\n}\n\nstatic int mlx5e_tc_tun_calc_hlen_geneve(struct mlx5e_encap_entry *e)\n{\n\treturn sizeof(struct udphdr) +\n\t       sizeof(struct genevehdr) +\n\t       e->tun_info->options_len;\n}\n\nstatic int mlx5e_tc_tun_check_udp_dport_geneve(struct mlx5e_priv *priv,\n\t\t\t\t\t       struct flow_cls_offload *f)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_match_ports enc_ports;\n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_PORTS))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_rule_match_enc_ports(rule, &enc_ports);\n\n\t \n\tif (be16_to_cpu(enc_ports.key->dst) != GENEVE_UDP_PORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matched UDP dst port is not registered as a GENEVE port\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"UDP port %d is not registered as a GENEVE port\\n\",\n\t\t\t    be16_to_cpu(enc_ports.key->dst));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_udp_ports_geneve(struct mlx5e_priv *priv,\n\t\t\t\t\t       struct mlx5_flow_spec *spec,\n\t\t\t\t\t       struct flow_cls_offload *f,\n\t\t\t\t\t       void *headers_c,\n\t\t\t\t\t       void *headers_v)\n{\n\tint err;\n\n\terr = mlx5e_tc_tun_parse_udp_ports(priv, spec, f, headers_c, headers_v);\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5e_tc_tun_check_udp_dport_geneve(priv, f);\n}\n\nstatic int mlx5e_tc_tun_init_encap_attr_geneve(struct net_device *tunnel_dev,\n\t\t\t\t\t       struct mlx5e_priv *priv,\n\t\t\t\t\t       struct mlx5e_encap_entry *e,\n\t\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\te->tunnel = &geneve_tunnel;\n\n\t \n\te->reformat_type = MLX5_REFORMAT_TYPE_L2_TO_VXLAN;\n\treturn 0;\n}\n\nstatic void mlx5e_tunnel_id_to_vni(__be64 tun_id, __u8 *vni)\n{\n#ifdef __BIG_ENDIAN\n\tvni[0] = (__force __u8)(tun_id >> 16);\n\tvni[1] = (__force __u8)(tun_id >> 8);\n\tvni[2] = (__force __u8)tun_id;\n#else\n\tvni[0] = (__force __u8)((__force u64)tun_id >> 40);\n\tvni[1] = (__force __u8)((__force u64)tun_id >> 48);\n\tvni[2] = (__force __u8)((__force u64)tun_id >> 56);\n#endif\n}\n\nstatic int mlx5e_gen_ip_tunnel_header_geneve(char buf[],\n\t\t\t\t\t     __u8 *ip_proto,\n\t\t\t\t\t     struct mlx5e_encap_entry *e)\n{\n\tconst struct ip_tunnel_info *tun_info = e->tun_info;\n\tstruct udphdr *udp = (struct udphdr *)(buf);\n\tstruct genevehdr *geneveh;\n\n\tgeneveh = (struct genevehdr *)((char *)udp + sizeof(struct udphdr));\n\n\t*ip_proto = IPPROTO_UDP;\n\n\tudp->dest = tun_info->key.tp_dst;\n\n\tmemset(geneveh, 0, sizeof(*geneveh));\n\tgeneveh->ver = MLX5E_GENEVE_VER;\n\tgeneveh->opt_len = tun_info->options_len / 4;\n\tgeneveh->oam = !!(tun_info->key.tun_flags & TUNNEL_OAM);\n\tgeneveh->critical = !!(tun_info->key.tun_flags & TUNNEL_CRIT_OPT);\n\tmlx5e_tunnel_id_to_vni(tun_info->key.tun_id, geneveh->vni);\n\tgeneveh->proto_type = htons(ETH_P_TEB);\n\n\tif (tun_info->key.tun_flags & TUNNEL_GENEVE_OPT) {\n\t\tif (!geneveh->opt_len)\n\t\t\treturn -EOPNOTSUPP;\n\t\tip_tunnel_info_opts_get(geneveh->options, tun_info);\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_geneve_vni(struct mlx5e_priv *priv,\n\t\t\t\t\t struct mlx5_flow_spec *spec,\n\t\t\t\t\t struct flow_cls_offload *f)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_match_enc_keyid enc_keyid;\n\tvoid *misc_c, *misc_v;\n\n\tmisc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);\n\tmisc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);\n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID))\n\t\treturn 0;\n\n\tflow_rule_match_enc_keyid(rule, &enc_keyid);\n\n\tif (!enc_keyid.mask->keyid)\n\t\treturn 0;\n\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev, ft_field_support.outer_geneve_vni)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Matching on GENEVE VNI is not supported\");\n\t\tnetdev_warn(priv->netdev, \"Matching on GENEVE VNI is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tMLX5_SET(fte_match_set_misc, misc_c, geneve_vni, be32_to_cpu(enc_keyid.mask->keyid));\n\tMLX5_SET(fte_match_set_misc, misc_v, geneve_vni, be32_to_cpu(enc_keyid.key->keyid));\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_geneve_options(struct mlx5e_priv *priv,\n\t\t\t\t\t     struct mlx5_flow_spec *spec,\n\t\t\t\t\t     struct flow_cls_offload *f)\n{\n\tu8 max_tlv_option_data_len = MLX5_CAP_GEN(priv->mdev, max_geneve_tlv_option_data_len);\n\tu8 max_tlv_options = MLX5_CAP_GEN(priv->mdev, max_geneve_tlv_options);\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tvoid *misc_c, *misc_v, *misc_3_c, *misc_3_v;\n\tstruct geneve_opt *option_key, *option_mask;\n\t__be32 opt_data_key = 0, opt_data_mask = 0;\n\tstruct flow_match_enc_opts enc_opts;\n\tint res = 0;\n\n\tmisc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);\n\tmisc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);\n\tmisc_3_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters_3);\n\tmisc_3_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters_3);\n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_OPTS))\n\t\treturn 0;\n\n\tflow_rule_match_enc_opts(rule, &enc_opts);\n\n\tif (memchr_inv(&enc_opts.mask->data, 0, sizeof(enc_opts.mask->data)) &&\n\t    !MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,\n\t\t\t\t\tft_field_support.geneve_tlv_option_0_data)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on GENEVE options is not supported\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on GENEVE options is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\tif (enc_opts.key->dst_opt_type != TUNNEL_GENEVE_OPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on GENEVE options: option type is not GENEVE\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on GENEVE options: option type is not GENEVE\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (enc_opts.mask->len &&\n\t    !MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,\n\t\t\t\t\tft_field_support.outer_geneve_opt_len)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Matching on GENEVE options len is not supported\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on GENEVE options len is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\tif ((enc_opts.key->len / 4) > ((max_tlv_option_data_len + 1) * max_tlv_options)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on GENEVE options: unsupported options len\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on GENEVE options: unsupported options len (len=%d)\\n\",\n\t\t\t    enc_opts.key->len);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tMLX5_SET(fte_match_set_misc, misc_c, geneve_opt_len, enc_opts.mask->len / 4);\n\tMLX5_SET(fte_match_set_misc, misc_v, geneve_opt_len, enc_opts.key->len / 4);\n\n\t \n\toption_key = (struct geneve_opt *)&enc_opts.key->data[0];\n\toption_mask = (struct geneve_opt *)&enc_opts.mask->data[0];\n\n\tif (option_mask->opt_class == 0 && option_mask->type == 0 &&\n\t    !memchr_inv(option_mask->opt_data, 0, option_mask->length * 4))\n\t\treturn 0;\n\n\tif (option_key->length > max_tlv_option_data_len) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on GENEVE options: unsupported option len\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on GENEVE options: unsupported option len (key=%d, mask=%d)\\n\",\n\t\t\t    option_key->length, option_mask->length);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!memchr_inv(option_key->opt_data, 0, option_key->length * 4)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on GENEVE options: can't match on 0 data field\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on GENEVE options: can't match on 0 data field\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tres = mlx5_geneve_tlv_option_add(priv->mdev->geneve, option_key);\n\tif (res) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Matching on GENEVE options: failed creating TLV opt object\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Matching on GENEVE options: failed creating TLV opt object (class:type:len = 0x%x:0x%x:%d)\\n\",\n\t\t\t    be16_to_cpu(option_key->opt_class),\n\t\t\t    option_key->type, option_key->length);\n\t\treturn res;\n\t}\n\n\t \n\n\tmemcpy(&opt_data_key, option_key->opt_data, option_key->length * 4);\n\tmemcpy(&opt_data_mask, option_mask->opt_data, option_mask->length * 4);\n\tMLX5_SET(fte_match_set_misc3, misc_3_v,\n\t\t geneve_tlv_option_0_data, be32_to_cpu(opt_data_key));\n\tMLX5_SET(fte_match_set_misc3, misc_3_c,\n\t\t geneve_tlv_option_0_data, be32_to_cpu(opt_data_mask));\n\tif (MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,\n\t\t\t\t       ft_field_support.geneve_tlv_option_0_exist)) {\n\t\tMLX5_SET_TO_ONES(fte_match_set_misc, misc_c, geneve_tlv_option_0_exist);\n\t\tMLX5_SET_TO_ONES(fte_match_set_misc, misc_v, geneve_tlv_option_0_exist);\n\t}\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_3;\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_geneve_params(struct mlx5e_priv *priv,\n\t\t\t\t\t    struct mlx5_flow_spec *spec,\n\t\t\t\t\t    struct flow_cls_offload *f)\n{\n\tvoid *misc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);\n\tvoid *misc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,  misc_parameters);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\n\t \n\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev, ft_field_support.outer_geneve_oam)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Matching on GENEVE OAM is not supported\");\n\t\tnetdev_warn(priv->netdev, \"Matching on GENEVE OAM is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tMLX5_SET_TO_ONES(fte_match_set_misc, misc_c, geneve_oam);\n\tMLX5_SET(fte_match_set_misc, misc_v, geneve_oam, 0);\n\n\t \n\n\tif (MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,\n\t\t\t\t       ft_field_support.outer_geneve_protocol_type)) {\n\t\tMLX5_SET_TO_ONES(fte_match_set_misc, misc_c, geneve_protocol_type);\n\t\tMLX5_SET(fte_match_set_misc, misc_v, geneve_protocol_type, ETH_P_TEB);\n\t}\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;\n\n\treturn 0;\n}\n\nstatic int mlx5e_tc_tun_parse_geneve(struct mlx5e_priv *priv,\n\t\t\t\t     struct mlx5_flow_spec *spec,\n\t\t\t\t     struct flow_cls_offload *f,\n\t\t\t\t     void *headers_c,\n\t\t\t\t     void *headers_v)\n{\n\tint err;\n\n\terr = mlx5e_tc_tun_parse_geneve_params(priv, spec, f);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_tc_tun_parse_geneve_vni(priv, spec, f);\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5e_tc_tun_parse_geneve_options(priv, spec, f);\n}\n\nstatic bool mlx5e_tc_tun_encap_info_equal_geneve(struct mlx5e_encap_key *a,\n\t\t\t\t\t\t struct mlx5e_encap_key *b)\n{\n\treturn mlx5e_tc_tun_encap_info_equal_options(a, b, TUNNEL_GENEVE_OPT);\n}\n\nstruct mlx5e_tc_tunnel geneve_tunnel = {\n\t.tunnel_type          = MLX5E_TC_TUNNEL_TYPE_GENEVE,\n\t.match_level          = MLX5_MATCH_L4,\n\t.can_offload          = mlx5e_tc_tun_can_offload_geneve,\n\t.calc_hlen            = mlx5e_tc_tun_calc_hlen_geneve,\n\t.init_encap_attr      = mlx5e_tc_tun_init_encap_attr_geneve,\n\t.generate_ip_tun_hdr  = mlx5e_gen_ip_tunnel_header_geneve,\n\t.parse_udp_ports      = mlx5e_tc_tun_parse_udp_ports_geneve,\n\t.parse_tunnel         = mlx5e_tc_tun_parse_geneve,\n\t.encap_info_equal     = mlx5e_tc_tun_encap_info_equal_geneve,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}