{
  "module_name": "en_selftest.c",
  "hash_id": "b11bba242bc064fd9bb7a43e97cf943ff80cf84a031fc91c5c17708b1c8c90b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c",
  "human_readable_source": " \n\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <net/udp.h>\n#include \"en.h\"\n#include \"en/port.h\"\n#include \"eswitch.h\"\n\nstatic int mlx5e_test_health_info(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_core_health *health = &priv->mdev->priv.health;\n\n\treturn health->fatal_error ? 1 : 0;\n}\n\nstatic int mlx5e_test_link_state(struct mlx5e_priv *priv)\n{\n\tu8 port_state;\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\treturn 1;\n\n\tport_state = mlx5_query_vport_state(priv->mdev, MLX5_VPORT_STATE_OP_MOD_VNIC_VPORT, 0);\n\treturn port_state == VPORT_STATE_UP ? 0 : 1;\n}\n\nstatic int mlx5e_test_link_speed(struct mlx5e_priv *priv)\n{\n\tu32 speed;\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\treturn 1;\n\n\treturn mlx5e_port_linkspeed(priv->mdev, &speed);\n}\n\nstruct mlx5ehdr {\n\t__be32 version;\n\t__be64 magic;\n};\n\n#ifdef CONFIG_INET\n \n#define MLX5E_TEST_PKT_SIZE (sizeof(struct ethhdr) + sizeof(struct iphdr) +\\\n\t\t\t     sizeof(struct udphdr) + sizeof(struct mlx5ehdr))\n#define MLX5E_TEST_MAGIC 0x5AEED15C001ULL\n\nstatic struct sk_buff *mlx5e_test_get_udp_skb(struct mlx5e_priv *priv)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct mlx5ehdr *mlxh;\n\tstruct ethhdr *ethh;\n\tstruct udphdr *udph;\n\tstruct iphdr *iph;\n\tint    iplen;\n\n\tskb = netdev_alloc_skb(priv->netdev, MLX5E_TEST_PKT_SIZE);\n\tif (!skb) {\n\t\tnetdev_err(priv->netdev, \"\\tFailed to alloc loopback skb\\n\");\n\t\treturn NULL;\n\t}\n\n\tnet_prefetchw(skb->data);\n\tskb_reserve(skb, NET_IP_ALIGN);\n\n\t \n\tethh = skb_push(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = skb_put(skb, sizeof(struct iphdr));\n\n\tskb_set_transport_header(skb, skb->len);\n\tudph = skb_put(skb, sizeof(struct udphdr));\n\n\t \n\tether_addr_copy(ethh->h_dest, priv->netdev->dev_addr);\n\teth_zero_addr(ethh->h_source);\n\tethh->h_proto = htons(ETH_P_IP);\n\n\t \n\tudph->source = htons(9);\n\tudph->dest = htons(9);  \n\tudph->len = htons(sizeof(struct mlx5ehdr) + sizeof(struct udphdr));\n\tudph->check = 0;\n\n\t \n\tiph->ihl = 5;\n\tiph->ttl = 32;\n\tiph->version = 4;\n\tiph->protocol = IPPROTO_UDP;\n\tiplen = sizeof(struct iphdr) + sizeof(struct udphdr) +\n\t\tsizeof(struct mlx5ehdr);\n\tiph->tot_len = htons(iplen);\n\tiph->frag_off = 0;\n\tiph->saddr = 0;\n\tiph->daddr = 0;\n\tiph->tos = 0;\n\tiph->id = 0;\n\tip_send_check(iph);\n\n\t \n\tmlxh = skb_put(skb, sizeof(*mlxh));\n\tmlxh->version = 0;\n\tmlxh->magic = cpu_to_be64(MLX5E_TEST_MAGIC);\n\n\tskb->csum = 0;\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\tudp4_hwcsum(skb, iph->saddr, iph->daddr);\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb->pkt_type = PACKET_HOST;\n\tskb->dev = priv->netdev;\n\n\treturn skb;\n}\n\nstruct mlx5e_lbt_priv {\n\tstruct packet_type pt;\n\tstruct completion comp;\n\tbool loopback_ok;\n\tbool local_lb;\n};\n\nstatic int\nmlx5e_test_loopback_validate(struct sk_buff *skb,\n\t\t\t     struct net_device *ndev,\n\t\t\t     struct packet_type *pt,\n\t\t\t     struct net_device *orig_ndev)\n{\n\tstruct mlx5e_lbt_priv *lbtp = pt->af_packet_priv;\n\tstruct mlx5ehdr *mlxh;\n\tstruct ethhdr *ethh;\n\tstruct udphdr *udph;\n\tstruct iphdr *iph;\n\n\t \n\tif (MLX5E_TEST_PKT_SIZE - ETH_HLEN > skb_headlen(skb))\n\t\tgoto out;\n\n\tethh = (struct ethhdr *)skb_mac_header(skb);\n\tif (!ether_addr_equal(ethh->h_dest, orig_ndev->dev_addr))\n\t\tgoto out;\n\n\tiph = ip_hdr(skb);\n\tif (iph->protocol != IPPROTO_UDP)\n\t\tgoto out;\n\n\t \n\tudph = (struct udphdr *)((u8 *)iph + 4 * iph->ihl);\n\tif (udph->dest != htons(9))\n\t\tgoto out;\n\n\tmlxh = (struct mlx5ehdr *)((char *)udph + sizeof(*udph));\n\tif (mlxh->magic != cpu_to_be64(MLX5E_TEST_MAGIC))\n\t\tgoto out;  \n\n\t \n\tlbtp->loopback_ok = true;\n\tcomplete(&lbtp->comp);\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int mlx5e_test_loopback_setup(struct mlx5e_priv *priv,\n\t\t\t\t     struct mlx5e_lbt_priv *lbtp)\n{\n\tint err = 0;\n\n\t \n\terr = mlx5_nic_vport_query_local_lb(priv->mdev, &lbtp->local_lb);\n\tif (err)\n\t\treturn err;\n\n\tif (!lbtp->local_lb) {\n\t\terr = mlx5_nic_vport_update_local_lb(priv->mdev, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mlx5e_refresh_tirs(priv, true, false);\n\tif (err)\n\t\tgoto out;\n\n\tlbtp->loopback_ok = false;\n\tinit_completion(&lbtp->comp);\n\n\tlbtp->pt.type = htons(ETH_P_IP);\n\tlbtp->pt.func = mlx5e_test_loopback_validate;\n\tlbtp->pt.dev = priv->netdev;\n\tlbtp->pt.af_packet_priv = lbtp;\n\tdev_add_pack(&lbtp->pt);\n\n\treturn 0;\n\nout:\n\tif (!lbtp->local_lb)\n\t\tmlx5_nic_vport_update_local_lb(priv->mdev, false);\n\n\treturn err;\n}\n\nstatic void mlx5e_test_loopback_cleanup(struct mlx5e_priv *priv,\n\t\t\t\t\tstruct mlx5e_lbt_priv *lbtp)\n{\n\tif (!lbtp->local_lb)\n\t\tmlx5_nic_vport_update_local_lb(priv->mdev, false);\n\n\tdev_remove_pack(&lbtp->pt);\n\tmlx5e_refresh_tirs(priv, false, false);\n}\n\nstatic int mlx5e_cond_loopback(struct mlx5e_priv *priv)\n{\n\tif (is_mdev_switchdev_mode(priv->mdev))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n#define MLX5E_LB_VERIFY_TIMEOUT (msecs_to_jiffies(200))\nstatic int mlx5e_test_loopback(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_lbt_priv *lbtp;\n\tstruct sk_buff *skb = NULL;\n\tint err;\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"\\tCan't perform loopback test while device is down\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlbtp = kzalloc(sizeof(*lbtp), GFP_KERNEL);\n\tif (!lbtp)\n\t\treturn -ENOMEM;\n\tlbtp->loopback_ok = false;\n\n\terr = mlx5e_test_loopback_setup(priv, lbtp);\n\tif (err)\n\t\tgoto out;\n\n\tskb = mlx5e_test_get_udp_skb(priv);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tskb_set_queue_mapping(skb, 0);\n\terr = dev_queue_xmit(skb);\n\tif (err) {\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"\\tFailed to xmit loopback packet err(%d)\\n\",\n\t\t\t   err);\n\t\tgoto cleanup;\n\t}\n\n\twait_for_completion_timeout(&lbtp->comp, MLX5E_LB_VERIFY_TIMEOUT);\n\terr = !lbtp->loopback_ok;\n\ncleanup:\n\tmlx5e_test_loopback_cleanup(priv, lbtp);\nout:\n\tkfree(lbtp);\n\treturn err;\n}\n#endif\n\ntypedef int (*mlx5e_st_func)(struct mlx5e_priv *);\n\nstruct mlx5e_st {\n\tchar name[ETH_GSTRING_LEN];\n\tmlx5e_st_func st_func;\n\tmlx5e_st_func cond_func;\n};\n\nstatic struct mlx5e_st mlx5e_sts[] = {\n\t{ \"Link Test\", mlx5e_test_link_state },\n\t{ \"Speed Test\", mlx5e_test_link_speed },\n\t{ \"Health Test\", mlx5e_test_health_info },\n#ifdef CONFIG_INET\n\t{ \"Loopback Test\", mlx5e_test_loopback, mlx5e_cond_loopback },\n#endif\n};\n\n#define MLX5E_ST_NUM ARRAY_SIZE(mlx5e_sts)\n\nvoid mlx5e_self_test(struct net_device *ndev, struct ethtool_test *etest,\n\t\t     u64 *buf)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(ndev);\n\tint i, count = 0;\n\n\tmutex_lock(&priv->state_lock);\n\tnetdev_info(ndev, \"Self test begin..\\n\");\n\n\tfor (i = 0; i < MLX5E_ST_NUM; i++) {\n\t\tstruct mlx5e_st st = mlx5e_sts[i];\n\n\t\tif (st.cond_func && st.cond_func(priv))\n\t\t\tcontinue;\n\t\tnetdev_info(ndev, \"\\t[%d] %s start..\\n\", i, st.name);\n\t\tbuf[count] = st.st_func(priv);\n\t\tnetdev_info(ndev, \"\\t[%d] %s end: result(%lld)\\n\", i, st.name, buf[count]);\n\t\tcount++;\n\t}\n\n\tmutex_unlock(&priv->state_lock);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (buf[i]) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnetdev_info(ndev, \"Self test out: status flags(0x%x)\\n\",\n\t\t    etest->flags);\n}\n\nint mlx5e_self_test_fill_strings(struct mlx5e_priv *priv, u8 *data)\n{\n\tint i, count = 0;\n\n\tfor (i = 0; i < MLX5E_ST_NUM; i++) {\n\t\tstruct mlx5e_st st = mlx5e_sts[i];\n\n\t\tif (st.cond_func && st.cond_func(priv))\n\t\t\tcontinue;\n\t\tif (data)\n\t\t\tstrcpy(data + count * ETH_GSTRING_LEN, st.name);\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nint mlx5e_self_test_num(struct mlx5e_priv *priv)\n{\n\treturn mlx5e_self_test_fill_strings(priv, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}