{
  "module_name": "mod_hdr.c",
  "hash_id": "a297aa8061695896754b6af96c87ce4a241bb9f984b117a5d7f9c63cc746497b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/mod_hdr.c",
  "human_readable_source": "\n\n\n#include <linux/jhash.h>\n#include \"mod_hdr.h\"\n\n#define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)\n\nstruct mod_hdr_key {\n\tint num_actions;\n\tvoid *actions;\n};\n\nstruct mlx5e_mod_hdr_handle {\n\t \n\tstruct hlist_node mod_hdr_hlist;\n\n\tstruct mod_hdr_key key;\n\n\tstruct mlx5_modify_hdr *modify_hdr;\n\n\trefcount_t refcnt;\n\tstruct completion res_ready;\n\tint compl_result;\n};\n\nstatic u32 hash_mod_hdr_info(struct mod_hdr_key *key)\n{\n\treturn jhash(key->actions,\n\t\t     key->num_actions * MLX5_MH_ACT_SZ, 0);\n}\n\nstatic int cmp_mod_hdr_info(struct mod_hdr_key *a, struct mod_hdr_key *b)\n{\n\tif (a->num_actions != b->num_actions)\n\t\treturn 1;\n\n\treturn memcmp(a->actions, b->actions,\n\t\t      a->num_actions * MLX5_MH_ACT_SZ);\n}\n\nvoid mlx5e_mod_hdr_tbl_init(struct mod_hdr_tbl *tbl)\n{\n\tmutex_init(&tbl->lock);\n\thash_init(tbl->hlist);\n}\n\nvoid mlx5e_mod_hdr_tbl_destroy(struct mod_hdr_tbl *tbl)\n{\n\tWARN_ON(!hash_empty(tbl->hlist));\n\tmutex_destroy(&tbl->lock);\n}\n\nstatic struct mlx5e_mod_hdr_handle *mod_hdr_get(struct mod_hdr_tbl *tbl,\n\t\t\t\t\t\tstruct mod_hdr_key *key,\n\t\t\t\t\t\tu32 hash_key)\n{\n\tstruct mlx5e_mod_hdr_handle *mh, *found = NULL;\n\n\thash_for_each_possible(tbl->hlist, mh, mod_hdr_hlist, hash_key) {\n\t\tif (!cmp_mod_hdr_info(&mh->key, key)) {\n\t\t\trefcount_inc(&mh->refcnt);\n\t\t\tfound = mh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstruct mlx5e_mod_hdr_handle *\nmlx5e_mod_hdr_attach(struct mlx5_core_dev *mdev,\n\t\t     struct mod_hdr_tbl *tbl,\n\t\t     enum mlx5_flow_namespace_type namespace,\n\t\t     struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts)\n{\n\tint num_actions, actions_size, err;\n\tstruct mlx5e_mod_hdr_handle *mh;\n\tstruct mod_hdr_key key;\n\tu32 hash_key;\n\n\tnum_actions  = mod_hdr_acts->num_actions;\n\tactions_size = MLX5_MH_ACT_SZ * num_actions;\n\n\tkey.actions = mod_hdr_acts->actions;\n\tkey.num_actions = num_actions;\n\n\thash_key = hash_mod_hdr_info(&key);\n\n\tmutex_lock(&tbl->lock);\n\tmh = mod_hdr_get(tbl, &key, hash_key);\n\tif (mh) {\n\t\tmutex_unlock(&tbl->lock);\n\t\twait_for_completion(&mh->res_ready);\n\n\t\tif (mh->compl_result < 0) {\n\t\t\terr = -EREMOTEIO;\n\t\t\tgoto attach_header_err;\n\t\t}\n\t\tgoto attach_header;\n\t}\n\n\tmh = kzalloc(sizeof(*mh) + actions_size, GFP_KERNEL);\n\tif (!mh) {\n\t\tmutex_unlock(&tbl->lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmh->key.actions = (void *)mh + sizeof(*mh);\n\tmemcpy(mh->key.actions, key.actions, actions_size);\n\tmh->key.num_actions = num_actions;\n\trefcount_set(&mh->refcnt, 1);\n\tinit_completion(&mh->res_ready);\n\n\thash_add(tbl->hlist, &mh->mod_hdr_hlist, hash_key);\n\tmutex_unlock(&tbl->lock);\n\n\tmh->modify_hdr = mlx5_modify_header_alloc(mdev, namespace,\n\t\t\t\t\t\t  mh->key.num_actions,\n\t\t\t\t\t\t  mh->key.actions);\n\tif (IS_ERR(mh->modify_hdr)) {\n\t\terr = PTR_ERR(mh->modify_hdr);\n\t\tmh->compl_result = err;\n\t\tgoto alloc_header_err;\n\t}\n\tmh->compl_result = 1;\n\tcomplete_all(&mh->res_ready);\n\nattach_header:\n\treturn mh;\n\nalloc_header_err:\n\tcomplete_all(&mh->res_ready);\nattach_header_err:\n\tmlx5e_mod_hdr_detach(mdev, tbl, mh);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5e_mod_hdr_detach(struct mlx5_core_dev *mdev,\n\t\t\t  struct mod_hdr_tbl *tbl,\n\t\t\t  struct mlx5e_mod_hdr_handle *mh)\n{\n\tif (!refcount_dec_and_mutex_lock(&mh->refcnt, &tbl->lock))\n\t\treturn;\n\thash_del(&mh->mod_hdr_hlist);\n\tmutex_unlock(&tbl->lock);\n\n\tif (mh->compl_result > 0)\n\t\tmlx5_modify_header_dealloc(mdev, mh->modify_hdr);\n\n\tkfree(mh);\n}\n\nstruct mlx5_modify_hdr *mlx5e_mod_hdr_get(struct mlx5e_mod_hdr_handle *mh)\n{\n\treturn mh->modify_hdr;\n}\n\nchar *\nmlx5e_mod_hdr_alloc(struct mlx5_core_dev *mdev, int namespace,\n\t\t    struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts)\n{\n\tint new_num_actions, max_hw_actions;\n\tsize_t new_sz, old_sz;\n\tvoid *ret;\n\n\tif (mod_hdr_acts->num_actions < mod_hdr_acts->max_actions)\n\t\tgoto out;\n\n\tmax_hw_actions = mlx5e_mod_hdr_max_actions(mdev, namespace);\n\tnew_num_actions = min(max_hw_actions,\n\t\t\t      mod_hdr_acts->actions ?\n\t\t\t      mod_hdr_acts->max_actions * 2 : 1);\n\tif (mod_hdr_acts->max_actions == new_num_actions)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_sz = MLX5_MH_ACT_SZ * new_num_actions;\n\told_sz = mod_hdr_acts->max_actions * MLX5_MH_ACT_SZ;\n\n\tif (mod_hdr_acts->is_static) {\n\t\tret = kzalloc(new_sz, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tmemcpy(ret, mod_hdr_acts->actions, old_sz);\n\t\t\tmod_hdr_acts->is_static = false;\n\t\t}\n\t} else {\n\t\tret = krealloc(mod_hdr_acts->actions, new_sz, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tmemset(ret + old_sz, 0, new_sz - old_sz);\n\t}\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmod_hdr_acts->actions = ret;\n\tmod_hdr_acts->max_actions = new_num_actions;\n\nout:\n\treturn mod_hdr_acts->actions + (mod_hdr_acts->num_actions * MLX5_MH_ACT_SZ);\n}\n\nvoid\nmlx5e_mod_hdr_dealloc(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts)\n{\n\tif (!mod_hdr_acts->is_static)\n\t\tkfree(mod_hdr_acts->actions);\n\n\tmod_hdr_acts->actions = NULL;\n\tmod_hdr_acts->num_actions = 0;\n\tmod_hdr_acts->max_actions = 0;\n}\n\nchar *\nmlx5e_mod_hdr_get_item(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts, int pos)\n{\n\treturn mod_hdr_acts->actions + (pos * MLX5_MH_ACT_SZ);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}