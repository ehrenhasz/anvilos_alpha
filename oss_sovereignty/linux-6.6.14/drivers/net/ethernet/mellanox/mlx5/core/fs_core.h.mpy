{
  "module_name": "fs_core.h",
  "hash_id": "7ebc434e4380ce764a1d002104ef39d36980b2c764417ca0abf4aced74545ddc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h",
  "human_readable_source": " \n\n#ifndef _MLX5_FS_CORE_\n#define _MLX5_FS_CORE_\n\n#include <linux/refcount.h>\n#include <linux/mlx5/fs.h>\n#include <linux/rhashtable.h>\n#include <linux/llist.h>\n#include <steering/fs_dr.h>\n\n#define FDB_TC_MAX_CHAIN 3\n#define FDB_FT_CHAIN (FDB_TC_MAX_CHAIN + 1)\n#define FDB_TC_SLOW_PATH_CHAIN (FDB_FT_CHAIN + 1)\n\n \n#define FDB_NUM_CHAINS (FDB_FT_CHAIN + 1)\n\n#define FDB_TC_MAX_PRIO 16\n#define FDB_TC_LEVELS_PER_PRIO 2\n\nstruct mlx5_flow_definer {\n\tenum mlx5_flow_namespace_type ns_type;\n\tu32 id;\n};\n\nenum mlx5_flow_resource_owner {\n\tMLX5_FLOW_RESOURCE_OWNER_FW,\n\tMLX5_FLOW_RESOURCE_OWNER_SW,\n};\n\nstruct mlx5_modify_hdr {\n\tenum mlx5_flow_namespace_type ns_type;\n\tenum mlx5_flow_resource_owner owner;\n\tunion {\n\t\tstruct mlx5_fs_dr_action action;\n\t\tu32 id;\n\t};\n};\n\nstruct mlx5_pkt_reformat {\n\tenum mlx5_flow_namespace_type ns_type;\n\tint reformat_type;  \n\tenum mlx5_flow_resource_owner owner;\n\tunion {\n\t\tstruct mlx5_fs_dr_action action;\n\t\tu32 id;\n\t};\n};\n\n \n\nenum fs_node_type {\n\tFS_TYPE_NAMESPACE,\n\tFS_TYPE_PRIO,\n\tFS_TYPE_PRIO_CHAINS,\n\tFS_TYPE_FLOW_TABLE,\n\tFS_TYPE_FLOW_GROUP,\n\tFS_TYPE_FLOW_ENTRY,\n\tFS_TYPE_FLOW_DEST\n};\n\nenum fs_flow_table_type {\n\tFS_FT_NIC_RX          = 0x0,\n\tFS_FT_NIC_TX          = 0x1,\n\tFS_FT_ESW_EGRESS_ACL  = 0x2,\n\tFS_FT_ESW_INGRESS_ACL = 0x3,\n\tFS_FT_FDB             = 0X4,\n\tFS_FT_SNIFFER_RX\t= 0X5,\n\tFS_FT_SNIFFER_TX\t= 0X6,\n\tFS_FT_RDMA_RX\t\t= 0X7,\n\tFS_FT_RDMA_TX\t\t= 0X8,\n\tFS_FT_PORT_SEL\t\t= 0X9,\n\tFS_FT_MAX_TYPE = FS_FT_PORT_SEL,\n};\n\nenum fs_flow_table_op_mod {\n\tFS_FT_OP_MOD_NORMAL,\n\tFS_FT_OP_MOD_LAG_DEMUX,\n};\n\nenum fs_fte_status {\n\tFS_FTE_STATUS_EXISTING = 1UL << 0,\n};\n\nenum mlx5_flow_steering_mode {\n\tMLX5_FLOW_STEERING_MODE_DMFS,\n\tMLX5_FLOW_STEERING_MODE_SMFS\n};\n\nenum mlx5_flow_steering_capabilty {\n\tMLX5_FLOW_STEERING_CAP_VLAN_PUSH_ON_RX = 1UL << 0,\n\tMLX5_FLOW_STEERING_CAP_VLAN_POP_ON_TX = 1UL << 1,\n\tMLX5_FLOW_STEERING_CAP_MATCH_RANGES = 1UL << 2,\n};\n\nstruct mlx5_flow_steering {\n\tstruct mlx5_core_dev *dev;\n\tenum   mlx5_flow_steering_mode\tmode;\n\tstruct kmem_cache\t\t*fgs_cache;\n\tstruct kmem_cache               *ftes_cache;\n\tstruct mlx5_flow_root_namespace *root_ns;\n\tstruct mlx5_flow_root_namespace *fdb_root_ns;\n\tstruct mlx5_flow_namespace\t**fdb_sub_ns;\n\tstruct mlx5_flow_root_namespace **esw_egress_root_ns;\n\tstruct mlx5_flow_root_namespace **esw_ingress_root_ns;\n\tstruct mlx5_flow_root_namespace\t*sniffer_tx_root_ns;\n\tstruct mlx5_flow_root_namespace\t*sniffer_rx_root_ns;\n\tstruct mlx5_flow_root_namespace\t*rdma_rx_root_ns;\n\tstruct mlx5_flow_root_namespace\t*rdma_tx_root_ns;\n\tstruct mlx5_flow_root_namespace\t*egress_root_ns;\n\tstruct mlx5_flow_root_namespace\t*port_sel_root_ns;\n\tint esw_egress_acl_vports;\n\tint esw_ingress_acl_vports;\n};\n\nstruct fs_node {\n\tstruct list_head\tlist;\n\tstruct list_head\tchildren;\n\tenum fs_node_type\ttype;\n\tstruct fs_node\t\t*parent;\n\tstruct fs_node\t\t*root;\n\t \n\tstruct rw_semaphore\tlock;\n\trefcount_t\t\trefcount;\n\tbool\t\t\tactive;\n\tvoid\t\t\t(*del_hw_func)(struct fs_node *);\n\tvoid\t\t\t(*del_sw_func)(struct fs_node *);\n\tatomic_t\t\tversion;\n};\n\nstruct mlx5_flow_rule {\n\tstruct fs_node\t\t\t\tnode;\n\tstruct mlx5_flow_table\t\t\t*ft;\n\tstruct mlx5_flow_destination\t\tdest_attr;\n\t \n\tstruct list_head\t\t\tnext_ft;\n\tu32\t\t\t\t\tsw_action;\n};\n\nstruct mlx5_flow_handle {\n\tint num_rules;\n\tstruct mlx5_flow_rule *rule[];\n};\n\n \nstruct mlx5_flow_table {\n\tstruct fs_node\t\t\tnode;\n\tstruct mlx5_fs_dr_table\t\tfs_dr_table;\n\tu32\t\t\t\tid;\n\tu16\t\t\t\tvport;\n\tunsigned int\t\t\tmax_fte;\n\tunsigned int\t\t\tlevel;\n\tenum fs_flow_table_type\t\ttype;\n\tenum fs_flow_table_op_mod\top_mod;\n\tstruct {\n\t\tbool\t\t\tactive;\n\t\tunsigned int\t\trequired_groups;\n\t\tunsigned int\t\tgroup_size;\n\t\tunsigned int\t\tnum_groups;\n\t\tunsigned int\t\tmax_fte;\n\t} autogroup;\n\t \n\tstruct mutex\t\t\tlock;\n\t \n\tstruct list_head\t\tfwd_rules;\n\tu32\t\t\t\tflags;\n\tstruct rhltable\t\t\tfgs_hash;\n\tenum mlx5_flow_table_miss_action def_miss_action;\n\tstruct mlx5_flow_namespace\t*ns;\n};\n\nstruct mlx5_ft_underlay_qp {\n\tstruct list_head list;\n\tu32 qpn;\n};\n\n#define MLX5_FTE_MATCH_PARAM_RESERVED\treserved_at_e00\n \n#define MLX5_ST_SZ_DW_MATCH_PARAM\t\t\t\t\t    \\\n\t((MLX5_BYTE_OFF(fte_match_param, MLX5_FTE_MATCH_PARAM_RESERVED) / sizeof(u32)) + \\\n\t BUILD_BUG_ON_ZERO(MLX5_ST_SZ_BYTES(fte_match_param) !=\t\t     \\\n\t\t\t   MLX5_FLD_SZ_BYTES(fte_match_param,\t\t     \\\n\t\t\t\t\t     MLX5_FTE_MATCH_PARAM_RESERVED) +\\\n\t\t\t   MLX5_BYTE_OFF(fte_match_param,\t\t     \\\n\t\t\t\t\t MLX5_FTE_MATCH_PARAM_RESERVED)))\n\n \nstruct fs_fte {\n\tstruct fs_node\t\t\tnode;\n\tstruct mlx5_fs_dr_rule\t\tfs_dr_rule;\n\tu32\t\t\t\tval[MLX5_ST_SZ_DW_MATCH_PARAM];\n\tu32\t\t\t\tdests_size;\n\tu32\t\t\t\tfwd_dests;\n\tu32\t\t\t\tindex;\n\tstruct mlx5_flow_context\tflow_context;\n\tstruct mlx5_flow_act\t\taction;\n\tenum fs_fte_status\t\tstatus;\n\tstruct mlx5_fc\t\t\t*counter;\n\tstruct rhash_head\t\thash;\n\tint\t\t\t\tmodify_mask;\n};\n\n \nstruct fs_prio {\n\tstruct fs_node\t\t\tnode;\n\tunsigned int\t\t\tnum_levels;\n\tunsigned int\t\t\tstart_level;\n\tunsigned int\t\t\tprio;\n\tunsigned int\t\t\tnum_ft;\n};\n\n \nstruct mlx5_flow_namespace {\n\t \n\tstruct\tfs_node\t\t\tnode;\n\tenum mlx5_flow_table_miss_action def_miss_action;\n};\n\nstruct mlx5_flow_group_mask {\n\tu8\tmatch_criteria_enable;\n\tu32\tmatch_criteria[MLX5_ST_SZ_DW_MATCH_PARAM];\n};\n\n \nstruct mlx5_flow_group {\n\tstruct fs_node\t\t\tnode;\n\tstruct mlx5_fs_dr_matcher\tfs_dr_matcher;\n\tstruct mlx5_flow_group_mask\tmask;\n\tu32\t\t\t\tstart_index;\n\tu32\t\t\t\tmax_ftes;\n\tstruct ida\t\t\tfte_allocator;\n\tu32\t\t\t\tid;\n\tstruct rhashtable\t\tftes_hash;\n\tstruct rhlist_head\t\thash;\n};\n\nstruct mlx5_flow_root_namespace {\n\tstruct mlx5_flow_namespace\tns;\n\tenum   mlx5_flow_steering_mode\tmode;\n\tstruct mlx5_fs_dr_domain\tfs_dr_domain;\n\tenum   fs_flow_table_type\ttable_type;\n\tstruct mlx5_core_dev\t\t*dev;\n\tstruct mlx5_flow_table\t\t*root_ft;\n\t \n\tstruct mutex\t\t\tchain_lock;\n\tstruct list_head\t\tunderlay_qpns;\n\tconst struct mlx5_flow_cmds\t*cmds;\n};\n\nint mlx5_init_fc_stats(struct mlx5_core_dev *dev);\nvoid mlx5_cleanup_fc_stats(struct mlx5_core_dev *dev);\nvoid mlx5_fc_queue_stats_work(struct mlx5_core_dev *dev,\n\t\t\t      struct delayed_work *dwork,\n\t\t\t      unsigned long delay);\nvoid mlx5_fc_update_sampling_interval(struct mlx5_core_dev *dev,\n\t\t\t\t      unsigned long interval);\n\nconst struct mlx5_flow_cmds *mlx5_fs_cmd_get_fw_cmds(void);\n\nint mlx5_flow_namespace_set_peer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t struct mlx5_flow_root_namespace *peer_ns,\n\t\t\t\t u16 peer_vhca_id);\n\nint mlx5_flow_namespace_set_mode(struct mlx5_flow_namespace *ns,\n\t\t\t\t enum mlx5_flow_steering_mode mode);\n\nint mlx5_fs_core_alloc(struct mlx5_core_dev *dev);\nvoid mlx5_fs_core_free(struct mlx5_core_dev *dev);\nint mlx5_fs_core_init(struct mlx5_core_dev *dev);\nvoid mlx5_fs_core_cleanup(struct mlx5_core_dev *dev);\n\nint mlx5_fs_egress_acls_init(struct mlx5_core_dev *dev, int total_vports);\nvoid mlx5_fs_egress_acls_cleanup(struct mlx5_core_dev *dev);\nint mlx5_fs_ingress_acls_init(struct mlx5_core_dev *dev, int total_vports);\nvoid mlx5_fs_ingress_acls_cleanup(struct mlx5_core_dev *dev);\n\nu32 mlx5_fs_get_capabilities(struct mlx5_core_dev *dev, enum mlx5_flow_namespace_type type);\n\nstruct mlx5_flow_root_namespace *find_root(struct fs_node *node);\n\n#define fs_get_obj(v, _node)  {v = container_of((_node), typeof(*v), node); }\n\n#define fs_list_for_each_entry(pos, root)\t\t\\\n\tlist_for_each_entry(pos, root, node.list)\n\n#define fs_list_for_each_entry_safe(pos, tmp, root)\t\t\\\n\tlist_for_each_entry_safe(pos, tmp, root, node.list)\n\n#define fs_for_each_ns_or_ft_reverse(pos, prio)\t\t\t\t\\\n\tlist_for_each_entry_reverse(pos, &(prio)->node.children, list)\n\n#define fs_for_each_ns_or_ft(pos, prio)\t\t\t\t\t\\\n\tlist_for_each_entry(pos, (&(prio)->node.children), list)\n\n#define fs_for_each_prio(pos, ns)\t\t\t\\\n\tfs_list_for_each_entry(pos, &(ns)->node.children)\n\n#define fs_for_each_ns(pos, prio)\t\t\t\\\n\tfs_list_for_each_entry(pos, &(prio)->node.children)\n\n#define fs_for_each_ft(pos, prio)\t\t\t\\\n\tfs_list_for_each_entry(pos, &(prio)->node.children)\n\n#define fs_for_each_ft_safe(pos, tmp, prio)\t\t\t\\\n\tfs_list_for_each_entry_safe(pos, tmp, &(prio)->node.children)\n\n#define fs_for_each_fg(pos, ft)\t\t\t\\\n\tfs_list_for_each_entry(pos, &(ft)->node.children)\n\n#define fs_for_each_fte(pos, fg)\t\t\t\\\n\tfs_list_for_each_entry(pos, &(fg)->node.children)\n\n#define fs_for_each_dst(pos, fte)\t\t\t\\\n\tfs_list_for_each_entry(pos, &(fte)->node.children)\n\n#define MLX5_CAP_FLOWTABLE_TYPE(mdev, cap, type) (\t\t\\\n\t(type == FS_FT_NIC_RX) ? MLX5_CAP_FLOWTABLE_NIC_RX(mdev, cap) :\t\t\\\n\t(type == FS_FT_NIC_TX) ? MLX5_CAP_FLOWTABLE_NIC_TX(mdev, cap) :\t\t\\\n\t(type == FS_FT_ESW_EGRESS_ACL) ? MLX5_CAP_ESW_EGRESS_ACL(mdev, cap) :\t\t\\\n\t(type == FS_FT_ESW_INGRESS_ACL) ? MLX5_CAP_ESW_INGRESS_ACL(mdev, cap) :\t\t\\\n\t(type == FS_FT_FDB) ? MLX5_CAP_ESW_FLOWTABLE_FDB(mdev, cap) :\t\t\\\n\t(type == FS_FT_SNIFFER_RX) ? MLX5_CAP_FLOWTABLE_SNIFFER_RX(mdev, cap) :\t\t\\\n\t(type == FS_FT_SNIFFER_TX) ? MLX5_CAP_FLOWTABLE_SNIFFER_TX(mdev, cap) :\t\t\\\n\t(type == FS_FT_RDMA_RX) ? MLX5_CAP_FLOWTABLE_RDMA_RX(mdev, cap) :\t\t\\\n\t(type == FS_FT_RDMA_TX) ? MLX5_CAP_FLOWTABLE_RDMA_TX(mdev, cap) :      \\\n\t(type == FS_FT_PORT_SEL) ? MLX5_CAP_FLOWTABLE_PORT_SELECTION(mdev, cap) :      \\\n\t(BUILD_BUG_ON_ZERO(FS_FT_PORT_SEL != FS_FT_MAX_TYPE))\\\n\t)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}