{
  "module_name": "bridge.c",
  "hash_id": "e73f30f274717f48d4bb1a4352041a569105caf724425049dca6397ae6407df3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/if_bridge.h>\n#include <net/netevent.h>\n#include <net/switchdev.h>\n#include \"bridge.h\"\n#include \"esw/bridge.h\"\n#include \"en_rep.h\"\n\n#define MLX5_ESW_BRIDGE_UPDATE_INTERVAL 1000\n\nstruct mlx5_bridge_switchdev_fdb_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct net_device *dev;\n\tstruct mlx5_esw_bridge_offloads *br_offloads;\n\tbool add;\n};\n\nstatic bool mlx5_esw_bridge_dev_same_esw(struct net_device *dev, struct mlx5_eswitch *esw)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\n\treturn esw == priv->mdev->priv.eswitch;\n}\n\nstatic bool mlx5_esw_bridge_dev_same_hw(struct net_device *dev, struct mlx5_eswitch *esw)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5_core_dev *mdev, *esw_mdev;\n\tu64 system_guid, esw_system_guid;\n\n\tmdev = priv->mdev;\n\tesw_mdev = esw->dev;\n\n\tsystem_guid = mlx5_query_nic_system_image_guid(mdev);\n\tesw_system_guid = mlx5_query_nic_system_image_guid(esw_mdev);\n\n\treturn system_guid == esw_system_guid;\n}\n\nstatic struct net_device *\nmlx5_esw_bridge_lag_rep_get(struct net_device *dev, struct mlx5_eswitch *esw)\n{\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tstruct mlx5_core_dev *mdev;\n\t\tstruct mlx5e_priv *priv;\n\n\t\tif (!mlx5e_eswitch_rep(lower))\n\t\t\tcontinue;\n\n\t\tpriv = netdev_priv(lower);\n\t\tmdev = priv->mdev;\n\t\tif (mlx5_lag_is_shared_fdb(mdev) && mlx5_esw_bridge_dev_same_esw(lower, esw))\n\t\t\treturn lower;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct net_device *\nmlx5_esw_bridge_rep_vport_num_vhca_id_get(struct net_device *dev, struct mlx5_eswitch *esw,\n\t\t\t\t\t  u16 *vport_num, u16 *esw_owner_vhca_id)\n{\n\tstruct mlx5e_rep_priv *rpriv;\n\tstruct mlx5e_priv *priv;\n\n\tif (netif_is_lag_master(dev))\n\t\tdev = mlx5_esw_bridge_lag_rep_get(dev, esw);\n\n\tif (!dev || !mlx5e_eswitch_rep(dev) || !mlx5_esw_bridge_dev_same_hw(dev, esw))\n\t\treturn NULL;\n\n\tpriv = netdev_priv(dev);\n\n\tif (!priv->mdev->priv.eswitch->br_offloads)\n\t\treturn NULL;\n\n\trpriv = priv->ppriv;\n\t*vport_num = rpriv->rep->vport;\n\t*esw_owner_vhca_id = MLX5_CAP_GEN(priv->mdev, vhca_id);\n\treturn dev;\n}\n\nstatic struct net_device *\nmlx5_esw_bridge_lower_rep_vport_num_vhca_id_get(struct net_device *dev, struct mlx5_eswitch *esw,\n\t\t\t\t\t\tu16 *vport_num, u16 *esw_owner_vhca_id)\n{\n\tstruct net_device *lower_dev;\n\tstruct list_head *iter;\n\n\tif (netif_is_lag_master(dev) || mlx5e_eswitch_rep(dev))\n\t\treturn mlx5_esw_bridge_rep_vport_num_vhca_id_get(dev, esw, vport_num,\n\t\t\t\t\t\t\t\t esw_owner_vhca_id);\n\n\tnetdev_for_each_lower_dev(dev, lower_dev, iter) {\n\t\tstruct net_device *rep;\n\n\t\tif (netif_is_bridge_master(lower_dev))\n\t\t\tcontinue;\n\n\t\trep = mlx5_esw_bridge_lower_rep_vport_num_vhca_id_get(lower_dev, esw, vport_num,\n\t\t\t\t\t\t\t\t      esw_owner_vhca_id);\n\t\tif (rep)\n\t\t\treturn rep;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mlx5_esw_bridge_is_local(struct net_device *dev, struct net_device *rep,\n\t\t\t\t     struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_core_dev *mdev;\n\tstruct mlx5e_priv *priv;\n\n\tif (!mlx5_esw_bridge_dev_same_esw(rep, esw))\n\t\treturn false;\n\n\tpriv = netdev_priv(rep);\n\tmdev = priv->mdev;\n\tif (netif_is_lag_master(dev))\n\t\treturn mlx5_lag_is_shared_fdb(mdev) && mlx5_lag_is_master(mdev);\n\treturn true;\n}\n\nstatic int mlx5_esw_bridge_port_changeupper(struct notifier_block *nb, void *ptr)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = container_of(nb,\n\t\t\t\t\t\t\t\t    struct mlx5_esw_bridge_offloads,\n\t\t\t\t\t\t\t\t    netdev_nb);\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct net_device *upper = info->upper_dev, *rep;\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tu16 vport_num, esw_owner_vhca_id;\n\tstruct netlink_ext_ack *extack;\n\tint err = 0;\n\n\tif (!netif_is_bridge_master(upper))\n\t\treturn 0;\n\n\trep = mlx5_esw_bridge_rep_vport_num_vhca_id_get(dev, esw, &vport_num, &esw_owner_vhca_id);\n\tif (!rep)\n\t\treturn 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (mlx5_esw_bridge_is_local(dev, rep, esw))\n\t\terr = info->linking ?\n\t\t\tmlx5_esw_bridge_vport_link(upper, vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t   br_offloads, extack) :\n\t\t\tmlx5_esw_bridge_vport_unlink(upper, vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t     br_offloads, extack);\n\telse if (mlx5_esw_bridge_dev_same_hw(rep, esw))\n\t\terr = info->linking ?\n\t\t\tmlx5_esw_bridge_vport_peer_link(upper, vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t\tbr_offloads, extack) :\n\t\t\tmlx5_esw_bridge_vport_peer_unlink(upper, vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t\t  br_offloads, extack);\n\n\treturn err;\n}\n\nstatic int\nmlx5_esw_bridge_changeupper_validate_netdev(void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct net_device *upper = info->upper_dev;\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\n\tif (!netif_is_bridge_master(upper) || !netif_is_lag_master(dev))\n\t\treturn 0;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tstruct mlx5_core_dev *mdev;\n\t\tstruct mlx5e_priv *priv;\n\n\t\tif (!mlx5e_eswitch_rep(lower))\n\t\t\tcontinue;\n\n\t\tpriv = netdev_priv(lower);\n\t\tmdev = priv->mdev;\n\t\tif (!mlx5_lag_is_active(mdev))\n\t\t\treturn -EAGAIN;\n\t\tif (!mlx5_lag_is_shared_fdb(mdev))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5_esw_bridge_switchdev_port_event(struct notifier_block *nb,\n\t\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tint err = 0;\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\terr = mlx5_esw_bridge_changeupper_validate_netdev(ptr);\n\t\tbreak;\n\n\tcase NETDEV_CHANGEUPPER:\n\t\terr = mlx5_esw_bridge_port_changeupper(nb, ptr);\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\nstatic int\nmlx5_esw_bridge_port_obj_add(struct net_device *dev,\n\t\t\t     struct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\t     struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct netlink_ext_ack *extack = switchdev_notifier_info_to_extack(&port_obj_info->info);\n\tconst struct switchdev_obj *obj = port_obj_info->obj;\n\tconst struct switchdev_obj_port_vlan *vlan;\n\tconst struct switchdev_obj_port_mdb *mdb;\n\tu16 vport_num, esw_owner_vhca_id;\n\tint err;\n\n\tif (!mlx5_esw_bridge_rep_vport_num_vhca_id_get(dev, br_offloads->esw, &vport_num,\n\t\t\t\t\t\t       &esw_owner_vhca_id))\n\t\treturn 0;\n\n\tport_obj_info->handled = true;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\t\terr = mlx5_esw_bridge_port_vlan_add(vport_num, esw_owner_vhca_id, vlan->vid,\n\t\t\t\t\t\t    vlan->flags, br_offloads, extack);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tmdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\t\terr = mlx5_esw_bridge_port_mdb_add(dev, vport_num, esw_owner_vhca_id, mdb->addr,\n\t\t\t\t\t\t   mdb->vid, br_offloads, extack);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn err;\n}\n\nstatic int\nmlx5_esw_bridge_port_obj_del(struct net_device *dev,\n\t\t\t     struct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\t     struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tconst struct switchdev_obj *obj = port_obj_info->obj;\n\tconst struct switchdev_obj_port_vlan *vlan;\n\tconst struct switchdev_obj_port_mdb *mdb;\n\tu16 vport_num, esw_owner_vhca_id;\n\n\tif (!mlx5_esw_bridge_rep_vport_num_vhca_id_get(dev, br_offloads->esw, &vport_num,\n\t\t\t\t\t\t       &esw_owner_vhca_id))\n\t\treturn 0;\n\n\tport_obj_info->handled = true;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\t\tmlx5_esw_bridge_port_vlan_del(vport_num, esw_owner_vhca_id, vlan->vid, br_offloads);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tmdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\t\tmlx5_esw_bridge_port_mdb_del(dev, vport_num, esw_owner_vhca_id, mdb->addr, mdb->vid,\n\t\t\t\t\t     br_offloads);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlx5_esw_bridge_port_obj_attr_set(struct net_device *dev,\n\t\t\t\t  struct switchdev_notifier_port_attr_info *port_attr_info,\n\t\t\t\t  struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct netlink_ext_ack *extack = switchdev_notifier_info_to_extack(&port_attr_info->info);\n\tconst struct switchdev_attr *attr = port_attr_info->attr;\n\tu16 vport_num, esw_owner_vhca_id;\n\tint err = 0;\n\n\tif (!mlx5_esw_bridge_lower_rep_vport_num_vhca_id_get(dev, br_offloads->esw, &vport_num,\n\t\t\t\t\t\t\t     &esw_owner_vhca_id))\n\t\treturn 0;\n\n\tport_attr_info->handled = true;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\tif (attr->u.brport_flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Flag is not supported\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\terr = mlx5_esw_bridge_ageing_time_set(vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t      attr->u.ageing_time, br_offloads);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\terr = mlx5_esw_bridge_vlan_filtering_set(vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t\t attr->u.vlan_filtering, br_offloads);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL:\n\t\terr = mlx5_esw_bridge_vlan_proto_set(vport_num,\n\t\t\t\t\t\t     esw_owner_vhca_id,\n\t\t\t\t\t\t     attr->u.vlan_protocol,\n\t\t\t\t\t\t     br_offloads);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED:\n\t\terr = mlx5_esw_bridge_mcast_set(vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t!attr->u.mc_disabled, br_offloads);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5_esw_bridge_event_blocking(struct notifier_block *nb,\n\t\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = container_of(nb,\n\t\t\t\t\t\t\t\t    struct mlx5_esw_bridge_offloads,\n\t\t\t\t\t\t\t\t    nb_blk);\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = mlx5_esw_bridge_port_obj_add(dev, ptr, br_offloads);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = mlx5_esw_bridge_port_obj_del(dev, ptr, br_offloads);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = mlx5_esw_bridge_port_obj_attr_set(dev, ptr, br_offloads);\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\nstatic void\nmlx5_esw_bridge_cleanup_switchdev_fdb_work(struct mlx5_bridge_switchdev_fdb_work *fdb_work)\n{\n\tdev_put(fdb_work->dev);\n\tkfree(fdb_work->fdb_info.addr);\n\tkfree(fdb_work);\n}\n\nstatic void mlx5_esw_bridge_switchdev_fdb_event_work(struct work_struct *work)\n{\n\tstruct mlx5_bridge_switchdev_fdb_work *fdb_work =\n\t\tcontainer_of(work, struct mlx5_bridge_switchdev_fdb_work, work);\n\tstruct switchdev_notifier_fdb_info *fdb_info =\n\t\t&fdb_work->fdb_info;\n\tstruct mlx5_esw_bridge_offloads *br_offloads =\n\t\tfdb_work->br_offloads;\n\tstruct net_device *dev = fdb_work->dev;\n\tu16 vport_num, esw_owner_vhca_id;\n\n\trtnl_lock();\n\n\tif (!mlx5_esw_bridge_rep_vport_num_vhca_id_get(dev, br_offloads->esw, &vport_num,\n\t\t\t\t\t\t       &esw_owner_vhca_id))\n\t\tgoto out;\n\n\tif (fdb_work->add)\n\t\tmlx5_esw_bridge_fdb_create(dev, vport_num, esw_owner_vhca_id, br_offloads,\n\t\t\t\t\t   fdb_info);\n\telse\n\t\tmlx5_esw_bridge_fdb_remove(dev, vport_num, esw_owner_vhca_id, br_offloads,\n\t\t\t\t\t   fdb_info);\n\nout:\n\trtnl_unlock();\n\tmlx5_esw_bridge_cleanup_switchdev_fdb_work(fdb_work);\n}\n\nstatic struct mlx5_bridge_switchdev_fdb_work *\nmlx5_esw_bridge_init_switchdev_fdb_work(struct net_device *dev, bool add,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info *fdb_info,\n\t\t\t\t\tstruct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_bridge_switchdev_fdb_work *work;\n\tu8 *addr;\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&work->work, mlx5_esw_bridge_switchdev_fdb_event_work);\n\tmemcpy(&work->fdb_info, fdb_info, sizeof(work->fdb_info));\n\n\taddr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\tif (!addr) {\n\t\tkfree(work);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tether_addr_copy(addr, fdb_info->addr);\n\twork->fdb_info.addr = addr;\n\n\tdev_hold(dev);\n\twork->dev = dev;\n\twork->br_offloads = br_offloads;\n\twork->add = add;\n\treturn work;\n}\n\nstatic int mlx5_esw_bridge_switchdev_event(struct notifier_block *nb,\n\t\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = container_of(nb,\n\t\t\t\t\t\t\t\t    struct mlx5_esw_bridge_offloads,\n\t\t\t\t\t\t\t\t    nb);\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct mlx5_bridge_switchdev_fdb_work *work;\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tstruct switchdev_notifier_info *info = ptr;\n\tu16 vport_num, esw_owner_vhca_id;\n\tstruct net_device *upper, *rep;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET) {\n\t\tint err = mlx5_esw_bridge_port_obj_attr_set(dev, ptr, br_offloads);\n\n\t\treturn notifier_from_errno(err);\n\t}\n\n\tupper = netdev_master_upper_dev_get_rcu(dev);\n\tif (!upper)\n\t\treturn NOTIFY_DONE;\n\tif (!netif_is_bridge_master(upper))\n\t\treturn NOTIFY_DONE;\n\n\trep = mlx5_esw_bridge_rep_vport_num_vhca_id_get(dev, esw, &vport_num, &esw_owner_vhca_id);\n\tif (!rep)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_BRIDGE:\n\t\tfdb_info = container_of(info,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info,\n\t\t\t\t\tinfo);\n\t\tmlx5_esw_bridge_fdb_update_used(dev, vport_num, esw_owner_vhca_id, br_offloads,\n\t\t\t\t\t\tfdb_info);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_BRIDGE:\n\t\t \n\t\tif (mlx5_esw_bridge_is_local(dev, rep, esw))\n\t\t\tbreak;\n\n\t\tfdb_info = container_of(info,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info,\n\t\t\t\t\tinfo);\n\t\t \n\t\tmlx5_esw_bridge_fdb_mark_deleted(dev, vport_num, esw_owner_vhca_id, br_offloads,\n\t\t\t\t\t\t fdb_info);\n\t\tfallthrough;\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb_info = container_of(info,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info,\n\t\t\t\t\tinfo);\n\n\t\twork = mlx5_esw_bridge_init_switchdev_fdb_work(dev,\n\t\t\t\t\t\t\t       event == SWITCHDEV_FDB_ADD_TO_DEVICE,\n\t\t\t\t\t\t\t       fdb_info,\n\t\t\t\t\t\t\t       br_offloads);\n\t\tif (IS_ERR(work)) {\n\t\t\tWARN_ONCE(1, \"Failed to init switchdev work, err=%ld\",\n\t\t\t\t  PTR_ERR(work));\n\t\t\treturn notifier_from_errno(PTR_ERR(work));\n\t\t}\n\n\t\tqueue_work(br_offloads->wq, &work->work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic void mlx5_esw_bridge_update_work(struct work_struct *work)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = container_of(work,\n\t\t\t\t\t\t\t\t    struct mlx5_esw_bridge_offloads,\n\t\t\t\t\t\t\t\t    update_work.work);\n\n\trtnl_lock();\n\tmlx5_esw_bridge_update(br_offloads);\n\trtnl_unlock();\n\n\tqueue_delayed_work(br_offloads->wq, &br_offloads->update_work,\n\t\t\t   msecs_to_jiffies(MLX5_ESW_BRIDGE_UPDATE_INTERVAL));\n}\n\nvoid mlx5e_rep_bridge_init(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5_eswitch *esw =\n\t\tmdev->priv.eswitch;\n\tint err;\n\n\trtnl_lock();\n\tbr_offloads = mlx5_esw_bridge_init(esw);\n\trtnl_unlock();\n\tif (IS_ERR(br_offloads)) {\n\t\tesw_warn(mdev, \"Failed to init esw bridge (err=%ld)\\n\", PTR_ERR(br_offloads));\n\t\treturn;\n\t}\n\n\tbr_offloads->wq = alloc_ordered_workqueue(\"mlx5_bridge_wq\", 0);\n\tif (!br_offloads->wq) {\n\t\tesw_warn(mdev, \"Failed to allocate bridge offloads workqueue\\n\");\n\t\tgoto err_alloc_wq;\n\t}\n\n\tbr_offloads->nb.notifier_call = mlx5_esw_bridge_switchdev_event;\n\terr = register_switchdev_notifier(&br_offloads->nb);\n\tif (err) {\n\t\tesw_warn(mdev, \"Failed to register switchdev notifier (err=%d)\\n\", err);\n\t\tgoto err_register_swdev;\n\t}\n\n\tbr_offloads->nb_blk.notifier_call = mlx5_esw_bridge_event_blocking;\n\terr = register_switchdev_blocking_notifier(&br_offloads->nb_blk);\n\tif (err) {\n\t\tesw_warn(mdev, \"Failed to register blocking switchdev notifier (err=%d)\\n\", err);\n\t\tgoto err_register_swdev_blk;\n\t}\n\n\tbr_offloads->netdev_nb.notifier_call = mlx5_esw_bridge_switchdev_port_event;\n\terr = register_netdevice_notifier_net(&init_net, &br_offloads->netdev_nb);\n\tif (err) {\n\t\tesw_warn(mdev, \"Failed to register bridge offloads netdevice notifier (err=%d)\\n\",\n\t\t\t err);\n\t\tgoto err_register_netdev;\n\t}\n\tINIT_DELAYED_WORK(&br_offloads->update_work, mlx5_esw_bridge_update_work);\n\tqueue_delayed_work(br_offloads->wq, &br_offloads->update_work,\n\t\t\t   msecs_to_jiffies(MLX5_ESW_BRIDGE_UPDATE_INTERVAL));\n\treturn;\n\nerr_register_netdev:\n\tunregister_switchdev_blocking_notifier(&br_offloads->nb_blk);\nerr_register_swdev_blk:\n\tunregister_switchdev_notifier(&br_offloads->nb);\nerr_register_swdev:\n\tdestroy_workqueue(br_offloads->wq);\nerr_alloc_wq:\n\trtnl_lock();\n\tmlx5_esw_bridge_cleanup(esw);\n\trtnl_unlock();\n}\n\nvoid mlx5e_rep_bridge_cleanup(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5_eswitch *esw =\n\t\tmdev->priv.eswitch;\n\n\tbr_offloads = esw->br_offloads;\n\tif (!br_offloads)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&br_offloads->update_work);\n\tunregister_netdevice_notifier_net(&init_net, &br_offloads->netdev_nb);\n\tunregister_switchdev_blocking_notifier(&br_offloads->nb_blk);\n\tunregister_switchdev_notifier(&br_offloads->nb);\n\tdestroy_workqueue(br_offloads->wq);\n\trtnl_lock();\n\tmlx5_esw_bridge_cleanup(esw);\n\trtnl_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}