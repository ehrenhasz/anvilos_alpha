{
  "module_name": "dev.c",
  "hash_id": "1adda248b3c0102eab91e3a1e82b60223a8a8781aa5f74dcd54236b1743c7ef0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/sf/dev/dev.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/device.h>\n#include \"mlx5_core.h\"\n#include \"dev.h\"\n#include \"sf/vhca_event.h\"\n#include \"sf/sf.h\"\n#include \"sf/mlx5_ifc_vhca_event.h\"\n#include \"ecpf.h\"\n#define CREATE_TRACE_POINTS\n#include \"diag/dev_tracepoint.h\"\n\nstruct mlx5_sf_dev_table {\n\tstruct xarray devices;\n\tunsigned int max_sfs;\n\tphys_addr_t base_address;\n\tu64 sf_bar_length;\n\tstruct notifier_block nb;\n\tstruct mutex table_lock;  \n\tstruct workqueue_struct *active_wq;\n\tstruct work_struct work;\n\tu8 stop_active_wq:1;\n\tstruct mlx5_core_dev *dev;\n};\n\nstatic bool mlx5_sf_dev_supported(const struct mlx5_core_dev *dev)\n{\n\treturn MLX5_CAP_GEN(dev, sf) && mlx5_vhca_event_supported(dev);\n}\n\nbool mlx5_sf_dev_allocated(const struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_dev_table *table = dev->priv.sf_dev_table;\n\n\treturn table && !xa_empty(&table->devices);\n}\n\nstatic ssize_t sfnum_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct auxiliary_device *adev = container_of(dev, struct auxiliary_device, dev);\n\tstruct mlx5_sf_dev *sf_dev = container_of(adev, struct mlx5_sf_dev, adev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", sf_dev->sfnum);\n}\nstatic DEVICE_ATTR_RO(sfnum);\n\nstatic struct attribute *sf_device_attrs[] = {\n\t&dev_attr_sfnum.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group sf_attr_group = {\n\t.attrs = sf_device_attrs,\n};\n\nstatic const struct attribute_group *sf_attr_groups[2] = {\n\t&sf_attr_group,\n\tNULL\n};\n\nstatic void mlx5_sf_dev_release(struct device *device)\n{\n\tstruct auxiliary_device *adev = container_of(device, struct auxiliary_device, dev);\n\tstruct mlx5_sf_dev *sf_dev = container_of(adev, struct mlx5_sf_dev, adev);\n\n\tmlx5_adev_idx_free(adev->id);\n\tkfree(sf_dev);\n}\n\nstatic void mlx5_sf_dev_remove(struct mlx5_core_dev *dev, struct mlx5_sf_dev *sf_dev)\n{\n\tint id;\n\n\tid = sf_dev->adev.id;\n\ttrace_mlx5_sf_dev_del(dev, sf_dev, id);\n\n\tauxiliary_device_delete(&sf_dev->adev);\n\tauxiliary_device_uninit(&sf_dev->adev);\n}\n\nstatic void mlx5_sf_dev_add(struct mlx5_core_dev *dev, u16 sf_index, u16 fn_id, u32 sfnum)\n{\n\tstruct mlx5_sf_dev_table *table = dev->priv.sf_dev_table;\n\tstruct mlx5_sf_dev *sf_dev;\n\tstruct pci_dev *pdev;\n\tint err;\n\tint id;\n\n\tid = mlx5_adev_idx_alloc();\n\tif (id < 0) {\n\t\terr = id;\n\t\tgoto add_err;\n\t}\n\n\tsf_dev = kzalloc(sizeof(*sf_dev), GFP_KERNEL);\n\tif (!sf_dev) {\n\t\tmlx5_adev_idx_free(id);\n\t\terr = -ENOMEM;\n\t\tgoto add_err;\n\t}\n\tpdev = dev->pdev;\n\tsf_dev->adev.id = id;\n\tsf_dev->adev.name = MLX5_SF_DEV_ID_NAME;\n\tsf_dev->adev.dev.release = mlx5_sf_dev_release;\n\tsf_dev->adev.dev.parent = &pdev->dev;\n\tsf_dev->adev.dev.groups = sf_attr_groups;\n\tsf_dev->sfnum = sfnum;\n\tsf_dev->parent_mdev = dev;\n\tsf_dev->fn_id = fn_id;\n\n\tif (!table->max_sfs) {\n\t\tmlx5_adev_idx_free(id);\n\t\tkfree(sf_dev);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto add_err;\n\t}\n\tsf_dev->bar_base_addr = table->base_address + (sf_index * table->sf_bar_length);\n\n\ttrace_mlx5_sf_dev_add(dev, sf_dev, id);\n\n\terr = auxiliary_device_init(&sf_dev->adev);\n\tif (err) {\n\t\tmlx5_adev_idx_free(id);\n\t\tkfree(sf_dev);\n\t\tgoto add_err;\n\t}\n\n\terr = auxiliary_device_add(&sf_dev->adev);\n\tif (err) {\n\t\tauxiliary_device_uninit(&sf_dev->adev);\n\t\tgoto add_err;\n\t}\n\n\terr = xa_insert(&table->devices, sf_index, sf_dev, GFP_KERNEL);\n\tif (err)\n\t\tgoto xa_err;\n\treturn;\n\nxa_err:\n\tmlx5_sf_dev_remove(dev, sf_dev);\nadd_err:\n\tmlx5_core_err(dev, \"SF DEV: fail device add for index=%d sfnum=%d err=%d\\n\",\n\t\t      sf_index, sfnum, err);\n}\n\nstatic void mlx5_sf_dev_del(struct mlx5_core_dev *dev, struct mlx5_sf_dev *sf_dev, u16 sf_index)\n{\n\tstruct mlx5_sf_dev_table *table = dev->priv.sf_dev_table;\n\n\txa_erase(&table->devices, sf_index);\n\tmlx5_sf_dev_remove(dev, sf_dev);\n}\n\nstatic int\nmlx5_sf_dev_state_change_handler(struct notifier_block *nb, unsigned long event_code, void *data)\n{\n\tstruct mlx5_sf_dev_table *table = container_of(nb, struct mlx5_sf_dev_table, nb);\n\tconst struct mlx5_vhca_state_event *event = data;\n\tstruct mlx5_sf_dev *sf_dev;\n\tu16 max_functions;\n\tu16 sf_index;\n\tu16 base_id;\n\n\tmax_functions = mlx5_sf_max_functions(table->dev);\n\tif (!max_functions)\n\t\treturn 0;\n\n\tbase_id = mlx5_sf_start_function_id(table->dev);\n\tif (event->function_id < base_id || event->function_id >= (base_id + max_functions))\n\t\treturn 0;\n\n\tsf_index = event->function_id - base_id;\n\tmutex_lock(&table->table_lock);\n\tsf_dev = xa_load(&table->devices, sf_index);\n\tswitch (event->new_vhca_state) {\n\tcase MLX5_VHCA_STATE_INVALID:\n\tcase MLX5_VHCA_STATE_ALLOCATED:\n\t\tif (sf_dev)\n\t\t\tmlx5_sf_dev_del(table->dev, sf_dev, sf_index);\n\t\tbreak;\n\tcase MLX5_VHCA_STATE_TEARDOWN_REQUEST:\n\t\tif (sf_dev)\n\t\t\tmlx5_sf_dev_del(table->dev, sf_dev, sf_index);\n\t\telse\n\t\t\tmlx5_core_err(table->dev,\n\t\t\t\t      \"SF DEV: teardown state for invalid dev index=%d sfnum=0x%x\\n\",\n\t\t\t\t      sf_index, event->sw_function_id);\n\t\tbreak;\n\tcase MLX5_VHCA_STATE_ACTIVE:\n\t\tif (!sf_dev)\n\t\t\tmlx5_sf_dev_add(table->dev, sf_index, event->function_id,\n\t\t\t\t\tevent->sw_function_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&table->table_lock);\n\treturn 0;\n}\n\nstatic int mlx5_sf_dev_vhca_arm_all(struct mlx5_sf_dev_table *table)\n{\n\tstruct mlx5_core_dev *dev = table->dev;\n\tu16 max_functions;\n\tu16 function_id;\n\tint err = 0;\n\tint i;\n\n\tmax_functions = mlx5_sf_max_functions(dev);\n\tfunction_id = mlx5_sf_start_function_id(dev);\n\t \n\tfor (i = 0; i < max_functions; i++) {\n\t\terr = mlx5_vhca_event_arm(dev, function_id);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfunction_id++;\n\t}\n\treturn 0;\n}\n\nstatic void mlx5_sf_dev_add_active_work(struct work_struct *work)\n{\n\tstruct mlx5_sf_dev_table *table = container_of(work, struct mlx5_sf_dev_table, work);\n\tu32 out[MLX5_ST_SZ_DW(query_vhca_state_out)] = {};\n\tstruct mlx5_core_dev *dev = table->dev;\n\tu16 max_functions;\n\tu16 function_id;\n\tu16 sw_func_id;\n\tint err = 0;\n\tu8 state;\n\tint i;\n\n\tmax_functions = mlx5_sf_max_functions(dev);\n\tfunction_id = mlx5_sf_start_function_id(dev);\n\tfor (i = 0; i < max_functions; i++, function_id++) {\n\t\tif (table->stop_active_wq)\n\t\t\treturn;\n\t\terr = mlx5_cmd_query_vhca_state(dev, function_id, out, sizeof(out));\n\t\tif (err)\n\t\t\t \n\t\t\tcontinue;\n\t\tstate = MLX5_GET(query_vhca_state_out, out, vhca_state_context.vhca_state);\n\t\tif (state != MLX5_VHCA_STATE_ACTIVE)\n\t\t\tcontinue;\n\n\t\tsw_func_id = MLX5_GET(query_vhca_state_out, out, vhca_state_context.sw_function_id);\n\t\tmutex_lock(&table->table_lock);\n\t\t \n\t\tif (!xa_load(&table->devices, i))\n\t\t\tmlx5_sf_dev_add(dev, i, function_id, sw_func_id);\n\t\t \n\t\tmutex_unlock(&table->table_lock);\n\t}\n}\n\n \nstatic int mlx5_sf_dev_queue_active_work(struct mlx5_sf_dev_table *table)\n{\n\tif (MLX5_CAP_GEN(table->dev, eswitch_manager))\n\t\treturn 0;  \n\n\t \n\ttable->active_wq = create_singlethread_workqueue(\"mlx5_active_sf\");\n\tif (!table->active_wq)\n\t\treturn -ENOMEM;\n\tINIT_WORK(&table->work, &mlx5_sf_dev_add_active_work);\n\tqueue_work(table->active_wq, &table->work);\n\treturn 0;\n}\n\nstatic void mlx5_sf_dev_destroy_active_work(struct mlx5_sf_dev_table *table)\n{\n\tif (table->active_wq) {\n\t\ttable->stop_active_wq = true;\n\t\tdestroy_workqueue(table->active_wq);\n\t}\n}\n\nvoid mlx5_sf_dev_table_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_dev_table *table;\n\tunsigned int max_sfs;\n\tint err;\n\n\tif (!mlx5_sf_dev_supported(dev))\n\t\treturn;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table) {\n\t\terr = -ENOMEM;\n\t\tgoto table_err;\n\t}\n\n\ttable->nb.notifier_call = mlx5_sf_dev_state_change_handler;\n\ttable->dev = dev;\n\tif (MLX5_CAP_GEN(dev, max_num_sf))\n\t\tmax_sfs = MLX5_CAP_GEN(dev, max_num_sf);\n\telse\n\t\tmax_sfs = 1 << MLX5_CAP_GEN(dev, log_max_sf);\n\ttable->sf_bar_length = 1 << (MLX5_CAP_GEN(dev, log_min_sf_size) + 12);\n\ttable->base_address = pci_resource_start(dev->pdev, 2);\n\ttable->max_sfs = max_sfs;\n\txa_init(&table->devices);\n\tmutex_init(&table->table_lock);\n\tdev->priv.sf_dev_table = table;\n\n\terr = mlx5_vhca_event_notifier_register(dev, &table->nb);\n\tif (err)\n\t\tgoto vhca_err;\n\n\terr = mlx5_sf_dev_queue_active_work(table);\n\tif (err)\n\t\tgoto add_active_err;\n\n\terr = mlx5_sf_dev_vhca_arm_all(table);\n\tif (err)\n\t\tgoto arm_err;\n\tmlx5_core_dbg(dev, \"SF DEV: max sf devices=%d\\n\", max_sfs);\n\treturn;\n\narm_err:\n\tmlx5_sf_dev_destroy_active_work(table);\nadd_active_err:\n\tmlx5_vhca_event_notifier_unregister(dev, &table->nb);\nvhca_err:\n\ttable->max_sfs = 0;\n\tkfree(table);\n\tdev->priv.sf_dev_table = NULL;\ntable_err:\n\tmlx5_core_err(dev, \"SF DEV table create err = %d\\n\", err);\n}\n\nstatic void mlx5_sf_dev_destroy_all(struct mlx5_sf_dev_table *table)\n{\n\tstruct mlx5_sf_dev *sf_dev;\n\tunsigned long index;\n\n\txa_for_each(&table->devices, index, sf_dev) {\n\t\txa_erase(&table->devices, index);\n\t\tmlx5_sf_dev_remove(table->dev, sf_dev);\n\t}\n}\n\nvoid mlx5_sf_dev_table_destroy(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_dev_table *table = dev->priv.sf_dev_table;\n\n\tif (!table)\n\t\treturn;\n\n\tmlx5_sf_dev_destroy_active_work(table);\n\tmlx5_vhca_event_notifier_unregister(dev, &table->nb);\n\tmutex_destroy(&table->table_lock);\n\n\t \n\tmlx5_sf_dev_destroy_all(table);\n\n\tWARN_ON(!xa_empty(&table->devices));\n\tkfree(table);\n\tdev->priv.sf_dev_table = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}