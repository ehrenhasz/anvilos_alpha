{
  "module_name": "en_txrx.c",
  "hash_id": "7e97fcb4fd54c7a1b63bdd0daac982df3c80d53106f22d9b46420c49aa232ab3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c",
  "human_readable_source": " \n\n#include <linux/irq.h>\n#include <net/xdp_sock_drv.h>\n#include \"en.h\"\n#include \"en/txrx.h\"\n#include \"en/xdp.h\"\n#include \"en/xsk/rx.h\"\n#include \"en/xsk/tx.h\"\n#include \"en_accel/ktls_txrx.h\"\n\nstatic inline bool mlx5e_channel_no_affinity_change(struct mlx5e_channel *c)\n{\n\tint current_cpu = smp_processor_id();\n\n\treturn cpumask_test_cpu(current_cpu, c->aff_mask);\n}\n\nstatic void mlx5e_handle_tx_dim(struct mlx5e_txqsq *sq)\n{\n\tstruct mlx5e_sq_stats *stats = sq->stats;\n\tstruct dim_sample dim_sample = {};\n\n\tif (unlikely(!test_bit(MLX5E_SQ_STATE_DIM, &sq->state)))\n\t\treturn;\n\n\tdim_update_sample(sq->cq.event_ctr, stats->packets, stats->bytes, &dim_sample);\n\tnet_dim(&sq->dim, dim_sample);\n}\n\nstatic void mlx5e_handle_rx_dim(struct mlx5e_rq *rq)\n{\n\tstruct mlx5e_rq_stats *stats = rq->stats;\n\tstruct dim_sample dim_sample = {};\n\n\tif (unlikely(!test_bit(MLX5E_RQ_STATE_DIM, &rq->state)))\n\t\treturn;\n\n\tdim_update_sample(rq->cq.event_ctr, stats->packets, stats->bytes, &dim_sample);\n\tnet_dim(&rq->dim, dim_sample);\n}\n\nvoid mlx5e_trigger_irq(struct mlx5e_icosq *sq)\n{\n\tstruct mlx5_wq_cyc *wq = &sq->wq;\n\tstruct mlx5e_tx_wqe *nopwqe;\n\tu16 pi = mlx5_wq_cyc_ctr2ix(wq, sq->pc);\n\n\tsq->db.wqe_info[pi] = (struct mlx5e_icosq_wqe_info) {\n\t\t.wqe_type   = MLX5E_ICOSQ_WQE_NOP,\n\t\t.num_wqebbs = 1,\n\t};\n\n\tnopwqe = mlx5e_post_nop(wq, sq->sqn, &sq->pc);\n\tmlx5e_notify_hw(wq, sq->pc, sq->uar_map, &nopwqe->ctrl);\n}\n\nstatic bool mlx5e_napi_xsk_post(struct mlx5e_xdpsq *xsksq, struct mlx5e_rq *xskrq)\n{\n\tbool need_wakeup = xsk_uses_need_wakeup(xskrq->xsk_pool);\n\tbool busy_xsk = false, xsk_rx_alloc_err;\n\n\t \n\tif (need_wakeup && xsksq->pc == xsksq->cc)\n\t\txsk_set_tx_need_wakeup(xsksq->xsk_pool);\n\tbusy_xsk |= mlx5e_xsk_tx(xsksq, MLX5E_TX_XSK_POLL_BUDGET);\n\t \n\tif (need_wakeup && xsksq->pc != xsksq->cc)\n\t\txsk_clear_tx_need_wakeup(xsksq->xsk_pool);\n\n\t \n\tif (need_wakeup && !mlx5e_rqwq_get_cur_sz(xskrq))\n\t\txsk_set_rx_need_wakeup(xskrq->xsk_pool);\n\txsk_rx_alloc_err = INDIRECT_CALL_2(xskrq->post_wqes,\n\t\t\t\t\t   mlx5e_post_rx_mpwqes,\n\t\t\t\t\t   mlx5e_post_rx_wqes,\n\t\t\t\t\t   xskrq);\n\t \n\tif (!need_wakeup)\n\t\tbusy_xsk |= xsk_rx_alloc_err;\n\telse if (xsk_rx_alloc_err)\n\t\txsk_set_rx_need_wakeup(xskrq->xsk_pool);\n\telse\n\t\txsk_clear_rx_need_wakeup(xskrq->xsk_pool);\n\n\treturn busy_xsk;\n}\n\nint mlx5e_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct mlx5e_channel *c = container_of(napi, struct mlx5e_channel,\n\t\t\t\t\t       napi);\n\tstruct mlx5e_ch_stats *ch_stats = c->stats;\n\tstruct mlx5e_xdpsq *xsksq = &c->xsksq;\n\tstruct mlx5e_txqsq __rcu **qos_sqs;\n\tstruct mlx5e_rq *xskrq = &c->xskrq;\n\tstruct mlx5e_rq *rq = &c->rq;\n\tbool aff_change = false;\n\tbool busy_xsk = false;\n\tbool busy = false;\n\tint work_done = 0;\n\tu16 qos_sqs_size;\n\tbool xsk_open;\n\tint i;\n\n\trcu_read_lock();\n\n\tqos_sqs = rcu_dereference(c->qos_sqs);\n\n\txsk_open = test_bit(MLX5E_CHANNEL_STATE_XSK, c->state);\n\n\tch_stats->poll++;\n\n\tfor (i = 0; i < c->num_tc; i++)\n\t\tbusy |= mlx5e_poll_tx_cq(&c->sq[i].cq, budget);\n\n\tif (unlikely(qos_sqs)) {\n\t\tsmp_rmb();  \n\t\tqos_sqs_size = READ_ONCE(c->qos_sqs_size);\n\n\t\tfor (i = 0; i < qos_sqs_size; i++) {\n\t\t\tstruct mlx5e_txqsq *sq = rcu_dereference(qos_sqs[i]);\n\n\t\t\tif (sq)\n\t\t\t\tbusy |= mlx5e_poll_tx_cq(&sq->cq, budget);\n\t\t}\n\t}\n\n\t \n\tif (unlikely(!budget))\n\t\tgoto out;\n\n\tbusy |= mlx5e_poll_xdpsq_cq(&c->xdpsq.cq);\n\n\tif (c->xdp)\n\t\tbusy |= mlx5e_poll_xdpsq_cq(&c->rq_xdpsq.cq);\n\n\tif (xsk_open)\n\t\twork_done = mlx5e_poll_rx_cq(&xskrq->cq, budget);\n\n\tif (likely(budget - work_done))\n\t\twork_done += mlx5e_poll_rx_cq(&rq->cq, budget - work_done);\n\n\tbusy |= work_done == budget;\n\n\tmlx5e_poll_ico_cq(&c->icosq.cq);\n\tif (mlx5e_poll_ico_cq(&c->async_icosq.cq))\n\t\t \n\t\tclear_bit(MLX5E_SQ_STATE_PENDING_XSK_TX, &c->async_icosq.state);\n\n\t \n\tif (unlikely(mlx5e_ktls_rx_pending_resync_list(c, budget)))\n\t\tbusy |= mlx5e_ktls_rx_handle_resync_list(c, budget);\n\n\tbusy |= INDIRECT_CALL_2(rq->post_wqes,\n\t\t\t\tmlx5e_post_rx_mpwqes,\n\t\t\t\tmlx5e_post_rx_wqes,\n\t\t\t\trq);\n\tif (xsk_open) {\n\t\tbusy |= mlx5e_poll_xdpsq_cq(&xsksq->cq);\n\t\tbusy_xsk |= mlx5e_napi_xsk_post(xsksq, xskrq);\n\t}\n\n\tbusy |= busy_xsk;\n\n\tif (busy) {\n\t\tif (likely(mlx5e_channel_no_affinity_change(c))) {\n\t\t\twork_done = budget;\n\t\t\tgoto out;\n\t\t}\n\t\tch_stats->aff_change++;\n\t\taff_change = true;\n\t\tif (work_done == budget)\n\t\t\twork_done--;\n\t}\n\n\tif (unlikely(!napi_complete_done(napi, work_done)))\n\t\tgoto out;\n\n\tch_stats->arm++;\n\n\tfor (i = 0; i < c->num_tc; i++) {\n\t\tmlx5e_handle_tx_dim(&c->sq[i]);\n\t\tmlx5e_cq_arm(&c->sq[i].cq);\n\t}\n\tif (unlikely(qos_sqs)) {\n\t\tfor (i = 0; i < qos_sqs_size; i++) {\n\t\t\tstruct mlx5e_txqsq *sq = rcu_dereference(qos_sqs[i]);\n\n\t\t\tif (sq) {\n\t\t\t\tmlx5e_handle_tx_dim(sq);\n\t\t\t\tmlx5e_cq_arm(&sq->cq);\n\t\t\t}\n\t\t}\n\t}\n\n\tmlx5e_handle_rx_dim(rq);\n\n\tmlx5e_cq_arm(&rq->cq);\n\tmlx5e_cq_arm(&c->icosq.cq);\n\tmlx5e_cq_arm(&c->async_icosq.cq);\n\tmlx5e_cq_arm(&c->xdpsq.cq);\n\n\tif (xsk_open) {\n\t\tmlx5e_handle_rx_dim(xskrq);\n\t\tmlx5e_cq_arm(&xsksq->cq);\n\t\tmlx5e_cq_arm(&xskrq->cq);\n\t}\n\n\tif (unlikely(aff_change && busy_xsk)) {\n\t\tmlx5e_trigger_irq(&c->icosq);\n\t\tch_stats->force_irq++;\n\t}\n\nout:\n\trcu_read_unlock();\n\n\treturn work_done;\n}\n\nvoid mlx5e_completion_event(struct mlx5_core_cq *mcq, struct mlx5_eqe *eqe)\n{\n\tstruct mlx5e_cq *cq = container_of(mcq, struct mlx5e_cq, mcq);\n\n\tnapi_schedule(cq->napi);\n\tcq->event_ctr++;\n\tcq->ch_stats->events++;\n}\n\nvoid mlx5e_cq_error_event(struct mlx5_core_cq *mcq, enum mlx5_event event)\n{\n\tstruct mlx5e_cq *cq = container_of(mcq, struct mlx5e_cq, mcq);\n\tstruct net_device *netdev = cq->netdev;\n\n\tnetdev_err(netdev, \"%s: cqn=0x%.6x event=0x%.2x\\n\",\n\t\t   __func__, mcq->cqn, event);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}