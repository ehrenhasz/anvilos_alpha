{
  "module_name": "geneve.c",
  "hash_id": "71c01e0ee84ae486070bd00eb778e6479fe5beec2a315265ed94beef6b5198a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/geneve.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include \"mlx5_core.h\"\n#include \"geneve.h\"\n\nstruct mlx5_geneve {\n\tstruct mlx5_core_dev *mdev;\n\t__be16 opt_class;\n\tu8 opt_type;\n\tu32 obj_id;\n\tstruct mutex sync_lock;  \n\tu32 refcount;\n};\n\nstatic int mlx5_geneve_tlv_option_create(struct mlx5_core_dev *mdev,\n\t\t\t\t\t __be16 class,\n\t\t\t\t\t u8 type,\n\t\t\t\t\t u8 len)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_geneve_tlv_option_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {};\n\tu64 general_obj_types;\n\tvoid *hdr, *opt;\n\tu16 obj_id;\n\tint err;\n\n\tgeneral_obj_types = MLX5_CAP_GEN_64(mdev, general_obj_types);\n\tif (!(general_obj_types & MLX5_GENERAL_OBJ_TYPES_CAP_GENEVE_TLV_OPT))\n\t\treturn -EINVAL;\n\n\thdr = MLX5_ADDR_OF(create_geneve_tlv_option_in, in, hdr);\n\topt = MLX5_ADDR_OF(create_geneve_tlv_option_in, in, geneve_tlv_opt);\n\n\tMLX5_SET(general_obj_in_cmd_hdr, hdr, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, hdr, obj_type, MLX5_OBJ_TYPE_GENEVE_TLV_OPT);\n\n\tMLX5_SET(geneve_tlv_option, opt, option_class, be16_to_cpu(class));\n\tMLX5_SET(geneve_tlv_option, opt, option_type, type);\n\tMLX5_SET(geneve_tlv_option, opt, option_data_length, len);\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tobj_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\treturn obj_id;\n}\n\nstatic void mlx5_geneve_tlv_option_destroy(struct mlx5_core_dev *mdev, u16 obj_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {};\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_OBJ_TYPE_GENEVE_TLV_OPT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, obj_id);\n\n\tmlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n}\n\nint mlx5_geneve_tlv_option_add(struct mlx5_geneve *geneve, struct geneve_opt *opt)\n{\n\tint res = 0;\n\n\tif (IS_ERR_OR_NULL(geneve))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&geneve->sync_lock);\n\n\tif (geneve->refcount) {\n\t\tif (geneve->opt_class == opt->opt_class &&\n\t\t    geneve->opt_type == opt->type) {\n\t\t\t \n\t\t\tgeneve->refcount++;\n\t\t} else {\n\t\t\t \n\t\t\tmlx5_core_warn(geneve->mdev,\n\t\t\t\t       \"Won't create Geneve TLV opt object with class:type:len = 0x%x:0x%x:%d (another class:type already exists)\\n\",\n\t\t\t\t       be16_to_cpu(opt->opt_class),\n\t\t\t\t       opt->type,\n\t\t\t\t       opt->length);\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\t \n\n\t\tres = mlx5_geneve_tlv_option_create(geneve->mdev,\n\t\t\t\t\t\t    opt->opt_class,\n\t\t\t\t\t\t    opt->type,\n\t\t\t\t\t\t    opt->length);\n\t\tif (res < 0) {\n\t\t\tmlx5_core_warn(geneve->mdev,\n\t\t\t\t       \"Failed creating Geneve TLV opt object class:type:len = 0x%x:0x%x:%d (err=%d)\\n\",\n\t\t\t\t       be16_to_cpu(opt->opt_class),\n\t\t\t\t       opt->type, opt->length, res);\n\t\t\tgoto unlock;\n\t\t}\n\t\tgeneve->opt_class = opt->opt_class;\n\t\tgeneve->opt_type = opt->type;\n\t\tgeneve->obj_id = res;\n\t\tgeneve->refcount++;\n\t\tres = 0;\n\t}\n\nunlock:\n\tmutex_unlock(&geneve->sync_lock);\n\treturn res;\n}\n\nvoid mlx5_geneve_tlv_option_del(struct mlx5_geneve *geneve)\n{\n\tif (IS_ERR_OR_NULL(geneve))\n\t\treturn;\n\n\tmutex_lock(&geneve->sync_lock);\n\tif (--geneve->refcount == 0) {\n\t\t \n\t\tmlx5_geneve_tlv_option_destroy(geneve->mdev, geneve->obj_id);\n\n\t\tgeneve->opt_class = 0;\n\t\tgeneve->opt_type = 0;\n\t\tgeneve->obj_id = 0;\n\t}\n\tmutex_unlock(&geneve->sync_lock);\n}\n\nstruct mlx5_geneve *mlx5_geneve_create(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_geneve *geneve =\n\t\tkzalloc(sizeof(*geneve), GFP_KERNEL);\n\n\tif (!geneve)\n\t\treturn ERR_PTR(-ENOMEM);\n\tgeneve->mdev = mdev;\n\tmutex_init(&geneve->sync_lock);\n\n\treturn geneve;\n}\n\nvoid mlx5_geneve_destroy(struct mlx5_geneve *geneve)\n{\n\tif (IS_ERR_OR_NULL(geneve))\n\t\treturn;\n\n\t \n\tif (geneve->refcount)\n\t\tmlx5_geneve_tlv_option_destroy(geneve->mdev, geneve->obj_id);\n\n\tkfree(geneve);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}