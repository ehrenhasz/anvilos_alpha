{
  "module_name": "legacy.c",
  "hash_id": "59793024941d27d359dce9c24bd73563e382ca67f11f1262a13d8f827a0066ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/legacy.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/mlx5_ifc.h>\n#include <linux/mlx5/vport.h>\n#include <linux/mlx5/fs.h>\n#include \"esw/acl/lgcy.h\"\n#include \"esw/legacy.h\"\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"fs_core.h\"\n#include \"fs_ft_pool.h\"\n#include \"esw/qos.h\"\n\nenum {\n\tLEGACY_VEPA_PRIO = 0,\n\tLEGACY_FDB_PRIO,\n};\n\nstatic int esw_create_legacy_vepa_table(struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_namespace *root_ns;\n\tstruct mlx5_flow_table *fdb;\n\tint err;\n\n\troot_ns = mlx5_get_fdb_sub_ns(dev, 0);\n\tif (!root_ns) {\n\t\tesw_warn(dev, \"Failed to get FDB flow namespace\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tft_attr.prio = LEGACY_VEPA_PRIO;\n\tft_attr.max_fte = 2;\n\tft_attr.autogroup.max_num_groups = 2;\n\tfdb = mlx5_create_auto_grouped_flow_table(root_ns, &ft_attr);\n\tif (IS_ERR(fdb)) {\n\t\terr = PTR_ERR(fdb);\n\t\tesw_warn(dev, \"Failed to create VEPA FDB err %d\\n\", err);\n\t\treturn err;\n\t}\n\tesw->fdb_table.legacy.vepa_fdb = fdb;\n\n\treturn 0;\n}\n\nstatic void esw_destroy_legacy_fdb_table(struct mlx5_eswitch *esw)\n{\n\tesw_debug(esw->dev, \"Destroy FDB Table\\n\");\n\tif (!esw->fdb_table.legacy.fdb)\n\t\treturn;\n\n\tif (esw->fdb_table.legacy.promisc_grp)\n\t\tmlx5_destroy_flow_group(esw->fdb_table.legacy.promisc_grp);\n\tif (esw->fdb_table.legacy.allmulti_grp)\n\t\tmlx5_destroy_flow_group(esw->fdb_table.legacy.allmulti_grp);\n\tif (esw->fdb_table.legacy.addr_grp)\n\t\tmlx5_destroy_flow_group(esw->fdb_table.legacy.addr_grp);\n\tmlx5_destroy_flow_table(esw->fdb_table.legacy.fdb);\n\n\tesw->fdb_table.legacy.fdb = NULL;\n\tesw->fdb_table.legacy.addr_grp = NULL;\n\tesw->fdb_table.legacy.allmulti_grp = NULL;\n\tesw->fdb_table.legacy.promisc_grp = NULL;\n\tatomic64_set(&esw->user_count, 0);\n}\n\nstatic int esw_create_legacy_fdb_table(struct mlx5_eswitch *esw)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_namespace *root_ns;\n\tstruct mlx5_flow_table *fdb;\n\tstruct mlx5_flow_group *g;\n\tvoid *match_criteria;\n\tint table_size;\n\tu32 *flow_group_in;\n\tu8 *dmac;\n\tint err = 0;\n\n\tesw_debug(dev, \"Create FDB log_max_size(%d)\\n\",\n\t\t  MLX5_CAP_ESW_FLOWTABLE_FDB(dev, log_max_ft_size));\n\n\troot_ns = mlx5_get_fdb_sub_ns(dev, 0);\n\tif (!root_ns) {\n\t\tesw_warn(dev, \"Failed to get FDB flow namespace\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\tft_attr.max_fte = POOL_NEXT_SIZE;\n\tft_attr.prio = LEGACY_FDB_PRIO;\n\tfdb = mlx5_create_flow_table(root_ns, &ft_attr);\n\tif (IS_ERR(fdb)) {\n\t\terr = PTR_ERR(fdb);\n\t\tesw_warn(dev, \"Failed to create FDB Table err %d\\n\", err);\n\t\tgoto out;\n\t}\n\tesw->fdb_table.legacy.fdb = fdb;\n\ttable_size = fdb->max_fte;\n\n\t \n\tMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS);\n\tmatch_criteria = MLX5_ADDR_OF(create_flow_group_in, flow_group_in, match_criteria);\n\tdmac = MLX5_ADDR_OF(fte_match_param, match_criteria, outer_headers.dmac_47_16);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 0);\n\t \n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, table_size - 3);\n\teth_broadcast_addr(dmac);\n\tg = mlx5_create_flow_group(fdb, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tesw_warn(dev, \"Failed to create flow group err(%d)\\n\", err);\n\t\tgoto out;\n\t}\n\tesw->fdb_table.legacy.addr_grp = g;\n\n\t \n\tMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, table_size - 2);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, table_size - 2);\n\teth_zero_addr(dmac);\n\tdmac[0] = 0x01;\n\tg = mlx5_create_flow_group(fdb, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tesw_warn(dev, \"Failed to create allmulti flow group err(%d)\\n\", err);\n\t\tgoto out;\n\t}\n\tesw->fdb_table.legacy.allmulti_grp = g;\n\n\t \n\teth_zero_addr(dmac);\n\tMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\n\t\t MLX5_MATCH_MISC_PARAMETERS);\n\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, misc_parameters.source_port);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, table_size - 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, table_size - 1);\n\tg = mlx5_create_flow_group(fdb, flow_group_in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tesw_warn(dev, \"Failed to create promisc flow group err(%d)\\n\", err);\n\t\tgoto out;\n\t}\n\tesw->fdb_table.legacy.promisc_grp = g;\n\nout:\n\tif (err)\n\t\tesw_destroy_legacy_fdb_table(esw);\n\n\tkvfree(flow_group_in);\n\treturn err;\n}\n\nstatic void esw_destroy_legacy_vepa_table(struct mlx5_eswitch *esw)\n{\n\tesw_debug(esw->dev, \"Destroy VEPA Table\\n\");\n\tif (!esw->fdb_table.legacy.vepa_fdb)\n\t\treturn;\n\n\tmlx5_destroy_flow_table(esw->fdb_table.legacy.vepa_fdb);\n\tesw->fdb_table.legacy.vepa_fdb = NULL;\n}\n\nstatic int esw_create_legacy_table(struct mlx5_eswitch *esw)\n{\n\tint err;\n\n\tmemset(&esw->fdb_table.legacy, 0, sizeof(struct legacy_fdb));\n\tatomic64_set(&esw->user_count, 0);\n\n\terr = esw_create_legacy_vepa_table(esw);\n\tif (err)\n\t\treturn err;\n\n\terr = esw_create_legacy_fdb_table(esw);\n\tif (err)\n\t\tesw_destroy_legacy_vepa_table(esw);\n\n\treturn err;\n}\n\nstatic void esw_cleanup_vepa_rules(struct mlx5_eswitch *esw)\n{\n\tif (esw->fdb_table.legacy.vepa_uplink_rule)\n\t\tmlx5_del_flow_rules(esw->fdb_table.legacy.vepa_uplink_rule);\n\n\tif (esw->fdb_table.legacy.vepa_star_rule)\n\t\tmlx5_del_flow_rules(esw->fdb_table.legacy.vepa_star_rule);\n\n\tesw->fdb_table.legacy.vepa_uplink_rule = NULL;\n\tesw->fdb_table.legacy.vepa_star_rule = NULL;\n}\n\nstatic void esw_destroy_legacy_table(struct mlx5_eswitch *esw)\n{\n\tesw_cleanup_vepa_rules(esw);\n\tesw_destroy_legacy_fdb_table(esw);\n\tesw_destroy_legacy_vepa_table(esw);\n}\n\n#define MLX5_LEGACY_SRIOV_VPORT_EVENTS (MLX5_VPORT_UC_ADDR_CHANGE | \\\n\t\t\t\t\tMLX5_VPORT_MC_ADDR_CHANGE | \\\n\t\t\t\t\tMLX5_VPORT_PROMISC_CHANGE)\n\nint esw_legacy_enable(struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_vport *vport;\n\tunsigned long i;\n\tint ret;\n\n\tret = esw_create_legacy_table(esw);\n\tif (ret)\n\t\treturn ret;\n\n\tmlx5_esw_for_each_vf_vport(esw, i, vport, esw->esw_funcs.num_vfs)\n\t\tvport->info.link_state = MLX5_VPORT_ADMIN_STATE_AUTO;\n\n\tret = mlx5_eswitch_enable_pf_vf_vports(esw, MLX5_LEGACY_SRIOV_VPORT_EVENTS);\n\tif (ret)\n\t\tesw_destroy_legacy_table(esw);\n\treturn ret;\n}\n\nvoid esw_legacy_disable(struct mlx5_eswitch *esw)\n{\n\tstruct esw_mc_addr *mc_promisc;\n\n\tmlx5_eswitch_disable_pf_vf_vports(esw);\n\n\tmc_promisc = &esw->mc_promisc;\n\tif (mc_promisc->uplink_rule)\n\t\tmlx5_del_flow_rules(mc_promisc->uplink_rule);\n\n\tesw_destroy_legacy_table(esw);\n}\n\nstatic int _mlx5_eswitch_set_vepa_locked(struct mlx5_eswitch *esw,\n\t\t\t\t\t u8 setting)\n{\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *flow_rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\tvoid *misc;\n\n\tif (!setting) {\n\t\tesw_cleanup_vepa_rules(esw);\n\t\treturn 0;\n\t}\n\n\tif (esw->fdb_table.legacy.vepa_uplink_rule)\n\t\treturn 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\t \n\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);\n\tMLX5_SET(fte_match_set_misc, misc, source_port, MLX5_VPORT_UPLINK);\n\n\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);\n\tMLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);\n\n\tspec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = esw->fdb_table.legacy.fdb;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tflow_rule = mlx5_add_flow_rules(esw->fdb_table.legacy.vepa_fdb, spec,\n\t\t\t\t\t&flow_act, &dest, 1);\n\tif (IS_ERR(flow_rule)) {\n\t\terr = PTR_ERR(flow_rule);\n\t\tgoto out;\n\t}\n\tesw->fdb_table.legacy.vepa_uplink_rule = flow_rule;\n\n\t \n\tmemset(&dest, 0, sizeof(dest));\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\n\tdest.vport.num = MLX5_VPORT_UPLINK;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tflow_rule = mlx5_add_flow_rules(esw->fdb_table.legacy.vepa_fdb, NULL,\n\t\t\t\t\t&flow_act, &dest, 1);\n\tif (IS_ERR(flow_rule)) {\n\t\terr = PTR_ERR(flow_rule);\n\t\tgoto out;\n\t}\n\tesw->fdb_table.legacy.vepa_star_rule = flow_rule;\n\nout:\n\tkvfree(spec);\n\tif (err)\n\t\tesw_cleanup_vepa_rules(esw);\n\treturn err;\n}\n\nint mlx5_eswitch_set_vepa(struct mlx5_eswitch *esw, u8 setting)\n{\n\tint err = 0;\n\n\tif (!esw)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!mlx5_esw_allowed(esw))\n\t\treturn -EPERM;\n\n\tmutex_lock(&esw->state_lock);\n\tif (esw->mode != MLX5_ESWITCH_LEGACY) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = _mlx5_eswitch_set_vepa_locked(esw, setting);\n\nout:\n\tmutex_unlock(&esw->state_lock);\n\treturn err;\n}\n\nint mlx5_eswitch_get_vepa(struct mlx5_eswitch *esw, u8 *setting)\n{\n\tif (!esw)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!mlx5_esw_allowed(esw))\n\t\treturn -EPERM;\n\n\tif (esw->mode != MLX5_ESWITCH_LEGACY)\n\t\treturn -EOPNOTSUPP;\n\n\t*setting = esw->fdb_table.legacy.vepa_uplink_rule ? 1 : 0;\n\treturn 0;\n}\n\nint esw_legacy_vport_acl_setup(struct mlx5_eswitch *esw, struct mlx5_vport *vport)\n{\n\tint ret;\n\n\t \n\tif (mlx5_esw_is_manager_vport(esw, vport->vport))\n\t\treturn 0;\n\n\tret = esw_acl_ingress_lgcy_setup(esw, vport);\n\tif (ret)\n\t\tgoto ingress_err;\n\n\tret = esw_acl_egress_lgcy_setup(esw, vport);\n\tif (ret)\n\t\tgoto egress_err;\n\n\treturn 0;\n\negress_err:\n\tesw_acl_ingress_lgcy_cleanup(esw, vport);\ningress_err:\n\treturn ret;\n}\n\nvoid esw_legacy_vport_acl_cleanup(struct mlx5_eswitch *esw, struct mlx5_vport *vport)\n{\n\tif (mlx5_esw_is_manager_vport(esw, vport->vport))\n\t\treturn;\n\n\tesw_acl_egress_lgcy_cleanup(esw, vport);\n\tesw_acl_ingress_lgcy_cleanup(esw, vport);\n}\n\nint mlx5_esw_query_vport_drop_stats(struct mlx5_core_dev *dev,\n\t\t\t\t    struct mlx5_vport *vport,\n\t\t\t\t    struct mlx5_vport_drop_stats *stats)\n{\n\tu64 rx_discard_vport_down, tx_discard_vport_down;\n\tstruct mlx5_eswitch *esw = dev->priv.eswitch;\n\tu64 bytes = 0;\n\tint err = 0;\n\n\tif (esw->mode != MLX5_ESWITCH_LEGACY)\n\t\treturn 0;\n\n\tmutex_lock(&esw->state_lock);\n\tif (!vport->enabled)\n\t\tgoto unlock;\n\n\tif (!IS_ERR_OR_NULL(vport->egress.legacy.drop_counter))\n\t\tmlx5_fc_query(dev, vport->egress.legacy.drop_counter,\n\t\t\t      &stats->rx_dropped, &bytes);\n\n\tif (vport->ingress.legacy.drop_counter)\n\t\tmlx5_fc_query(dev, vport->ingress.legacy.drop_counter,\n\t\t\t      &stats->tx_dropped, &bytes);\n\n\tif (!MLX5_CAP_GEN(dev, receive_discard_vport_down) &&\n\t    !MLX5_CAP_GEN(dev, transmit_discard_vport_down))\n\t\tgoto unlock;\n\n\terr = mlx5_query_vport_down_stats(dev, vport->vport, 1,\n\t\t\t\t\t  &rx_discard_vport_down,\n\t\t\t\t\t  &tx_discard_vport_down);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (MLX5_CAP_GEN(dev, receive_discard_vport_down))\n\t\tstats->rx_dropped += rx_discard_vport_down;\n\tif (MLX5_CAP_GEN(dev, transmit_discard_vport_down))\n\t\tstats->tx_dropped += tx_discard_vport_down;\n\nunlock:\n\tmutex_unlock(&esw->state_lock);\n\treturn err;\n}\n\nint mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,\n\t\t\t\tu16 vport, u16 vlan, u8 qos)\n{\n\tu8 set_flags = 0;\n\tint err = 0;\n\n\tif (!mlx5_esw_allowed(esw))\n\t\treturn vlan ? -EPERM : 0;\n\n\tif (vlan || qos)\n\t\tset_flags = SET_VLAN_STRIP | SET_VLAN_INSERT;\n\n\tmutex_lock(&esw->state_lock);\n\tif (esw->mode != MLX5_ESWITCH_LEGACY) {\n\t\tif (!vlan)\n\t\t\tgoto unlock;  \n\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\terr = __mlx5_eswitch_set_vport_vlan(esw, vport, vlan, qos, set_flags);\n\nunlock:\n\tmutex_unlock(&esw->state_lock);\n\treturn err;\n}\n\nint mlx5_eswitch_set_vport_spoofchk(struct mlx5_eswitch *esw,\n\t\t\t\t    u16 vport, bool spoofchk)\n{\n\tstruct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);\n\tbool pschk;\n\tint err = 0;\n\n\tif (!mlx5_esw_allowed(esw))\n\t\treturn -EPERM;\n\tif (IS_ERR(evport))\n\t\treturn PTR_ERR(evport);\n\n\tmutex_lock(&esw->state_lock);\n\tif (esw->mode != MLX5_ESWITCH_LEGACY) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\tpschk = evport->info.spoofchk;\n\tevport->info.spoofchk = spoofchk;\n\tif (pschk && !is_valid_ether_addr(evport->info.mac))\n\t\tmlx5_core_warn(esw->dev,\n\t\t\t       \"Spoofchk in set while MAC is invalid, vport(%d)\\n\",\n\t\t\t       evport->vport);\n\tif (evport->enabled && esw->mode == MLX5_ESWITCH_LEGACY)\n\t\terr = esw_acl_ingress_lgcy_setup(esw, evport);\n\tif (err)\n\t\tevport->info.spoofchk = pschk;\n\nunlock:\n\tmutex_unlock(&esw->state_lock);\n\treturn err;\n}\n\nint mlx5_eswitch_set_vport_trust(struct mlx5_eswitch *esw,\n\t\t\t\t u16 vport, bool setting)\n{\n\tstruct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);\n\tint err = 0;\n\n\tif (!mlx5_esw_allowed(esw))\n\t\treturn -EPERM;\n\tif (IS_ERR(evport))\n\t\treturn PTR_ERR(evport);\n\n\tmutex_lock(&esw->state_lock);\n\tif (esw->mode != MLX5_ESWITCH_LEGACY) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\tevport->info.trusted = setting;\n\tif (evport->enabled)\n\t\tesw_vport_change_handle_locked(evport);\n\nunlock:\n\tmutex_unlock(&esw->state_lock);\n\treturn err;\n}\n\nint mlx5_eswitch_set_vport_rate(struct mlx5_eswitch *esw, u16 vport,\n\t\t\t\tu32 max_rate, u32 min_rate)\n{\n\tstruct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);\n\tint err;\n\n\tif (!mlx5_esw_allowed(esw))\n\t\treturn -EPERM;\n\tif (IS_ERR(evport))\n\t\treturn PTR_ERR(evport);\n\n\tmutex_lock(&esw->state_lock);\n\terr = mlx5_esw_qos_set_vport_rate(esw, evport, max_rate, min_rate);\n\tmutex_unlock(&esw->state_lock);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}