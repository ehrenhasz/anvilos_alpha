{
  "module_name": "dev.c",
  "hash_id": "b935c44c0c2a6c74431e55cd0520d1642a229a2783f56b7e3c3d5224284ece7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/dev.c",
  "human_readable_source": " \n\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/eswitch.h>\n#include <linux/mlx5/mlx5_ifc_vdpa.h>\n#include <linux/mlx5/vport.h>\n#include \"mlx5_core.h\"\n#include \"devlink.h\"\n#include \"lag/lag.h\"\n\n \nstatic DEFINE_MUTEX(mlx5_intf_mutex);\nstatic DEFINE_IDA(mlx5_adev_ida);\n\nstatic bool is_eth_rep_supported(struct mlx5_core_dev *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_ESWITCH))\n\t\treturn false;\n\n\tif (!MLX5_ESWITCH_MANAGER(dev))\n\t\treturn false;\n\n\tif (!is_mdev_switchdev_mode(dev))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool mlx5_eth_supported(struct mlx5_core_dev *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_CORE_EN))\n\t\treturn false;\n\n\tif (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\n\t\treturn false;\n\n\tif (!MLX5_CAP_GEN(dev, eth_net_offloads)) {\n\t\tmlx5_core_warn(dev, \"Missing eth_net_offloads capability\\n\");\n\t\treturn false;\n\t}\n\n\tif (!MLX5_CAP_GEN(dev, nic_flow_table)) {\n\t\tmlx5_core_warn(dev, \"Missing nic_flow_table capability\\n\");\n\t\treturn false;\n\t}\n\n\tif (!MLX5_CAP_ETH(dev, csum_cap)) {\n\t\tmlx5_core_warn(dev, \"Missing csum_cap capability\\n\");\n\t\treturn false;\n\t}\n\n\tif (!MLX5_CAP_ETH(dev, max_lso_cap)) {\n\t\tmlx5_core_warn(dev, \"Missing max_lso_cap capability\\n\");\n\t\treturn false;\n\t}\n\n\tif (!MLX5_CAP_ETH(dev, vlan_cap)) {\n\t\tmlx5_core_warn(dev, \"Missing vlan_cap capability\\n\");\n\t\treturn false;\n\t}\n\n\tif (!MLX5_CAP_ETH(dev, rss_ind_tbl_cap)) {\n\t\tmlx5_core_warn(dev, \"Missing rss_ind_tbl_cap capability\\n\");\n\t\treturn false;\n\t}\n\n\tif (MLX5_CAP_FLOWTABLE(dev,\n\t\t\t       flow_table_properties_nic_receive.max_ft_level) < 3) {\n\t\tmlx5_core_warn(dev, \"max_ft_level < 3\\n\");\n\t\treturn false;\n\t}\n\n\tif (!MLX5_CAP_ETH(dev, self_lb_en_modifiable))\n\t\tmlx5_core_warn(dev, \"Self loop back prevention is not supported\\n\");\n\tif (!MLX5_CAP_GEN(dev, cq_moderation))\n\t\tmlx5_core_warn(dev, \"CQ moderation is not supported\\n\");\n\n\treturn true;\n}\n\nbool mlx5_vnet_supported(struct mlx5_core_dev *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_VDPA_NET))\n\t\treturn false;\n\n\tif (mlx5_core_is_pf(dev))\n\t\treturn false;\n\n\tif (!(MLX5_CAP_GEN_64(dev, general_obj_types) &\n\t      MLX5_GENERAL_OBJ_TYPES_CAP_VIRTIO_NET_Q))\n\t\treturn false;\n\n\tif (!(MLX5_CAP_DEV_VDPA_EMULATION(dev, event_mode) &\n\t      MLX5_VIRTIO_Q_EVENT_MODE_QP_MODE))\n\t\treturn false;\n\n\tif (!MLX5_CAP_DEV_VDPA_EMULATION(dev, eth_frame_offload_type))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool is_vnet_enabled(struct mlx5_core_dev *dev)\n{\n\tunion devlink_param_value val;\n\tint err;\n\n\terr = devl_param_driverinit_value_get(priv_to_devlink(dev),\n\t\t\t\t\t      DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET,\n\t\t\t\t\t      &val);\n\treturn err ? false : val.vbool;\n}\n\nstatic bool is_ib_rep_supported(struct mlx5_core_dev *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))\n\t\treturn false;\n\n\tif (dev->priv.flags & MLX5_PRIV_FLAGS_DISABLE_IB_ADEV)\n\t\treturn false;\n\n\tif (!is_eth_rep_supported(dev))\n\t\treturn false;\n\n\tif (mlx5_core_mp_enabled(dev))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool is_mp_supported(struct mlx5_core_dev *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))\n\t\treturn false;\n\n\tif (dev->priv.flags & MLX5_PRIV_FLAGS_DISABLE_IB_ADEV)\n\t\treturn false;\n\n\tif (is_ib_rep_supported(dev))\n\t\treturn false;\n\n\tif (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\n\t\treturn false;\n\n\tif (!mlx5_core_is_mp_slave(dev))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool mlx5_rdma_supported(struct mlx5_core_dev *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))\n\t\treturn false;\n\n\tif (dev->priv.flags & MLX5_PRIV_FLAGS_DISABLE_IB_ADEV)\n\t\treturn false;\n\n\tif (is_ib_rep_supported(dev))\n\t\treturn false;\n\n\tif (is_mp_supported(dev))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool is_ib_enabled(struct mlx5_core_dev *dev)\n{\n\tunion devlink_param_value val;\n\tint err;\n\n\terr = devl_param_driverinit_value_get(priv_to_devlink(dev),\n\t\t\t\t\t      DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA,\n\t\t\t\t\t      &val);\n\treturn err ? false : val.vbool;\n}\n\nenum {\n\tMLX5_INTERFACE_PROTOCOL_ETH,\n\tMLX5_INTERFACE_PROTOCOL_ETH_REP,\n\n\tMLX5_INTERFACE_PROTOCOL_IB,\n\tMLX5_INTERFACE_PROTOCOL_IB_REP,\n\tMLX5_INTERFACE_PROTOCOL_MPIB,\n\n\tMLX5_INTERFACE_PROTOCOL_VNET,\n};\n\nstatic const struct mlx5_adev_device {\n\tconst char *suffix;\n\tbool (*is_supported)(struct mlx5_core_dev *dev);\n\tbool (*is_enabled)(struct mlx5_core_dev *dev);\n} mlx5_adev_devices[] = {\n\t[MLX5_INTERFACE_PROTOCOL_VNET] = { .suffix = \"vnet\",\n\t\t\t\t\t   .is_supported = &mlx5_vnet_supported,\n\t\t\t\t\t   .is_enabled = &is_vnet_enabled },\n\t[MLX5_INTERFACE_PROTOCOL_IB] = { .suffix = \"rdma\",\n\t\t\t\t\t .is_supported = &mlx5_rdma_supported,\n\t\t\t\t\t .is_enabled = &is_ib_enabled },\n\t[MLX5_INTERFACE_PROTOCOL_ETH] = { .suffix = \"eth\",\n\t\t\t\t\t  .is_supported = &mlx5_eth_supported,\n\t\t\t\t\t  .is_enabled = &mlx5_core_is_eth_enabled },\n\t[MLX5_INTERFACE_PROTOCOL_ETH_REP] = { .suffix = \"eth-rep\",\n\t\t\t\t\t   .is_supported = &is_eth_rep_supported },\n\t[MLX5_INTERFACE_PROTOCOL_IB_REP] = { .suffix = \"rdma-rep\",\n\t\t\t\t\t   .is_supported = &is_ib_rep_supported },\n\t[MLX5_INTERFACE_PROTOCOL_MPIB] = { .suffix = \"multiport\",\n\t\t\t\t\t   .is_supported = &is_mp_supported },\n};\n\nint mlx5_adev_idx_alloc(void)\n{\n\treturn ida_alloc(&mlx5_adev_ida, GFP_KERNEL);\n}\n\nvoid mlx5_adev_idx_free(int idx)\n{\n\tida_free(&mlx5_adev_ida, idx);\n}\n\nint mlx5_adev_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\n\tpriv->adev = kcalloc(ARRAY_SIZE(mlx5_adev_devices),\n\t\t\t     sizeof(struct mlx5_adev *), GFP_KERNEL);\n\tif (!priv->adev)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid mlx5_adev_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\n\tkfree(priv->adev);\n}\n\nstatic void adev_release(struct device *dev)\n{\n\tstruct mlx5_adev *mlx5_adev =\n\t\tcontainer_of(dev, struct mlx5_adev, adev.dev);\n\tstruct mlx5_priv *priv = &mlx5_adev->mdev->priv;\n\tint idx = mlx5_adev->idx;\n\n\tkfree(mlx5_adev);\n\tpriv->adev[idx] = NULL;\n}\n\nstatic struct mlx5_adev *add_adev(struct mlx5_core_dev *dev, int idx)\n{\n\tconst char *suffix = mlx5_adev_devices[idx].suffix;\n\tstruct auxiliary_device *adev;\n\tstruct mlx5_adev *madev;\n\tint ret;\n\n\tmadev = kzalloc(sizeof(*madev), GFP_KERNEL);\n\tif (!madev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadev = &madev->adev;\n\tadev->id = dev->priv.adev_idx;\n\tadev->name = suffix;\n\tadev->dev.parent = dev->device;\n\tadev->dev.release = adev_release;\n\tmadev->mdev = dev;\n\tmadev->idx = idx;\n\n\tret = auxiliary_device_init(adev);\n\tif (ret) {\n\t\tkfree(madev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = auxiliary_device_add(adev);\n\tif (ret) {\n\t\tauxiliary_device_uninit(adev);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn madev;\n}\n\nstatic void del_adev(struct auxiliary_device *adev)\n{\n\tauxiliary_device_delete(adev);\n\tauxiliary_device_uninit(adev);\n}\n\nvoid mlx5_dev_set_lightweight(struct mlx5_core_dev *dev)\n{\n\tmutex_lock(&mlx5_intf_mutex);\n\tdev->priv.flags |= MLX5_PRIV_FLAGS_DISABLE_ALL_ADEV;\n\tmutex_unlock(&mlx5_intf_mutex);\n}\n\nbool mlx5_dev_is_lightweight(struct mlx5_core_dev *dev)\n{\n\treturn dev->priv.flags & MLX5_PRIV_FLAGS_DISABLE_ALL_ADEV;\n}\n\nint mlx5_attach_device(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\tstruct auxiliary_device *adev;\n\tstruct auxiliary_driver *adrv;\n\tint ret = 0, i;\n\n\tdevl_assert_locked(priv_to_devlink(dev));\n\tmutex_lock(&mlx5_intf_mutex);\n\tpriv->flags &= ~MLX5_PRIV_FLAGS_DETACH;\n\tfor (i = 0; i < ARRAY_SIZE(mlx5_adev_devices); i++) {\n\t\tif (!priv->adev[i]) {\n\t\t\tbool is_supported = false;\n\n\t\t\tif (mlx5_adev_devices[i].is_enabled) {\n\t\t\t\tbool enabled;\n\n\t\t\t\tenabled = mlx5_adev_devices[i].is_enabled(dev);\n\t\t\t\tif (!enabled)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (mlx5_adev_devices[i].is_supported)\n\t\t\t\tis_supported = mlx5_adev_devices[i].is_supported(dev);\n\n\t\t\tif (!is_supported)\n\t\t\t\tcontinue;\n\n\t\t\tpriv->adev[i] = add_adev(dev, i);\n\t\t\tif (IS_ERR(priv->adev[i])) {\n\t\t\t\tret = PTR_ERR(priv->adev[i]);\n\t\t\t\tpriv->adev[i] = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tadev = &priv->adev[i]->adev;\n\n\t\t\t \n\t\t\tif (!adev->dev.driver)\n\t\t\t\tcontinue;\n\t\t\tadrv = to_auxiliary_drv(adev->dev.driver);\n\n\t\t\tif (adrv->resume)\n\t\t\t\tret = adrv->resume(adev);\n\t\t}\n\t\tif (ret) {\n\t\t\tmlx5_core_warn(dev, \"Device[%d] (%s) failed to load\\n\",\n\t\t\t\t       i, mlx5_adev_devices[i].suffix);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&mlx5_intf_mutex);\n\treturn ret;\n}\n\nvoid mlx5_detach_device(struct mlx5_core_dev *dev, bool suspend)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\tstruct auxiliary_device *adev;\n\tstruct auxiliary_driver *adrv;\n\tpm_message_t pm = {};\n\tint i;\n\n\tdevl_assert_locked(priv_to_devlink(dev));\n\tmutex_lock(&mlx5_intf_mutex);\n\tfor (i = ARRAY_SIZE(mlx5_adev_devices) - 1; i >= 0; i--) {\n\t\tif (!priv->adev[i])\n\t\t\tcontinue;\n\n\t\tif (mlx5_adev_devices[i].is_enabled) {\n\t\t\tbool enabled;\n\n\t\t\tenabled = mlx5_adev_devices[i].is_enabled(dev);\n\t\t\tif (!enabled)\n\t\t\t\tgoto skip_suspend;\n\t\t}\n\n\t\tadev = &priv->adev[i]->adev;\n\t\t \n\t\tif (!adev->dev.driver)\n\t\t\tgoto skip_suspend;\n\n\t\tadrv = to_auxiliary_drv(adev->dev.driver);\n\n\t\tif (adrv->suspend && suspend) {\n\t\t\tadrv->suspend(adev, pm);\n\t\t\tcontinue;\n\t\t}\n\nskip_suspend:\n\t\tdel_adev(&priv->adev[i]->adev);\n\t\tpriv->adev[i] = NULL;\n\t}\n\tpriv->flags |= MLX5_PRIV_FLAGS_DETACH;\n\tmutex_unlock(&mlx5_intf_mutex);\n}\n\nint mlx5_register_device(struct mlx5_core_dev *dev)\n{\n\tint ret;\n\n\tdevl_assert_locked(priv_to_devlink(dev));\n\tmutex_lock(&mlx5_intf_mutex);\n\tdev->priv.flags &= ~MLX5_PRIV_FLAGS_DISABLE_ALL_ADEV;\n\tret = mlx5_rescan_drivers_locked(dev);\n\tmutex_unlock(&mlx5_intf_mutex);\n\tif (ret)\n\t\tmlx5_unregister_device(dev);\n\n\treturn ret;\n}\n\nvoid mlx5_unregister_device(struct mlx5_core_dev *dev)\n{\n\tdevl_assert_locked(priv_to_devlink(dev));\n\tmutex_lock(&mlx5_intf_mutex);\n\tdev->priv.flags = MLX5_PRIV_FLAGS_DISABLE_ALL_ADEV;\n\tmlx5_rescan_drivers_locked(dev);\n\tmutex_unlock(&mlx5_intf_mutex);\n}\n\nstatic int add_drivers(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlx5_adev_devices); i++) {\n\t\tbool is_supported = false;\n\n\t\tif (priv->adev[i])\n\t\t\tcontinue;\n\n\t\tif (mlx5_adev_devices[i].is_enabled &&\n\t\t    !(mlx5_adev_devices[i].is_enabled(dev)))\n\t\t\tcontinue;\n\n\t\tif (mlx5_adev_devices[i].is_supported)\n\t\t\tis_supported = mlx5_adev_devices[i].is_supported(dev);\n\n\t\tif (!is_supported)\n\t\t\tcontinue;\n\n\t\tpriv->adev[i] = add_adev(dev, i);\n\t\tif (IS_ERR(priv->adev[i])) {\n\t\t\tmlx5_core_warn(dev, \"Device[%d] (%s) failed to load\\n\",\n\t\t\t\t       i, mlx5_adev_devices[i].suffix);\n\t\t\t \n\t\t\tret = PTR_ERR(priv->adev[i]);\n\t\t\tpriv->adev[i] = NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void delete_drivers(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\tbool delete_all;\n\tint i;\n\n\tdelete_all = priv->flags & MLX5_PRIV_FLAGS_DISABLE_ALL_ADEV;\n\n\tfor (i = ARRAY_SIZE(mlx5_adev_devices) - 1; i >= 0; i--) {\n\t\tbool is_supported = false;\n\n\t\tif (!priv->adev[i])\n\t\t\tcontinue;\n\n\t\tif (mlx5_adev_devices[i].is_enabled) {\n\t\t\tbool enabled;\n\n\t\t\tenabled = mlx5_adev_devices[i].is_enabled(dev);\n\t\t\tif (!enabled)\n\t\t\t\tgoto del_adev;\n\t\t}\n\n\t\tif (mlx5_adev_devices[i].is_supported && !delete_all)\n\t\t\tis_supported = mlx5_adev_devices[i].is_supported(dev);\n\n\t\tif (is_supported)\n\t\t\tcontinue;\n\ndel_adev:\n\t\tdel_adev(&priv->adev[i]->adev);\n\t\tpriv->adev[i] = NULL;\n\t}\n}\n\n \nint mlx5_rescan_drivers_locked(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\n\tlockdep_assert_held(&mlx5_intf_mutex);\n\tif (priv->flags & MLX5_PRIV_FLAGS_DETACH)\n\t\treturn 0;\n\n\tdelete_drivers(dev);\n\tif (priv->flags & MLX5_PRIV_FLAGS_DISABLE_ALL_ADEV)\n\t\treturn 0;\n\n\treturn add_drivers(dev);\n}\n\nbool mlx5_same_hw_devs(struct mlx5_core_dev *dev, struct mlx5_core_dev *peer_dev)\n{\n\tu64 fsystem_guid, psystem_guid;\n\n\tfsystem_guid = mlx5_query_nic_system_image_guid(dev);\n\tpsystem_guid = mlx5_query_nic_system_image_guid(peer_dev);\n\n\treturn (fsystem_guid && psystem_guid && fsystem_guid == psystem_guid);\n}\n\nstatic u32 mlx5_gen_pci_id(const struct mlx5_core_dev *dev)\n{\n\treturn (u32)((pci_domain_nr(dev->pdev->bus) << 16) |\n\t\t     (dev->pdev->bus->number << 8) |\n\t\t     PCI_SLOT(dev->pdev->devfn));\n}\n\nstatic int _next_phys_dev(struct mlx5_core_dev *mdev,\n\t\t\t  const struct mlx5_core_dev *curr)\n{\n\tif (!mlx5_core_is_pf(mdev))\n\t\treturn 0;\n\n\tif (mdev == curr)\n\t\treturn 0;\n\n\tif (!mlx5_same_hw_devs(mdev, (struct mlx5_core_dev *)curr) &&\n\t    mlx5_gen_pci_id(mdev) != mlx5_gen_pci_id(curr))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void *pci_get_other_drvdata(struct device *this, struct device *other)\n{\n\tif (this->driver != other->driver)\n\t\treturn NULL;\n\n\treturn pci_get_drvdata(to_pci_dev(other));\n}\n\nstatic int next_phys_dev_lag(struct device *dev, const void *data)\n{\n\tstruct mlx5_core_dev *mdev, *this = (struct mlx5_core_dev *)data;\n\n\tmdev = pci_get_other_drvdata(this->device, dev);\n\tif (!mdev)\n\t\treturn 0;\n\n\tif (!mlx5_lag_is_supported(mdev))\n\t\treturn 0;\n\n\treturn _next_phys_dev(mdev, data);\n}\n\nstatic struct mlx5_core_dev *mlx5_get_next_dev(struct mlx5_core_dev *dev,\n\t\t\t\t\t       int (*match)(struct device *dev, const void *data))\n{\n\tstruct device *next;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn NULL;\n\n\tnext = bus_find_device(&pci_bus_type, NULL, dev, match);\n\tif (!next)\n\t\treturn NULL;\n\n\tput_device(next);\n\treturn pci_get_drvdata(to_pci_dev(next));\n}\n\n \nstruct mlx5_core_dev *mlx5_get_next_phys_dev_lag(struct mlx5_core_dev *dev)\n{\n\tlockdep_assert_held(&mlx5_intf_mutex);\n\treturn mlx5_get_next_dev(dev, &next_phys_dev_lag);\n}\n\nvoid mlx5_dev_list_lock(void)\n{\n\tmutex_lock(&mlx5_intf_mutex);\n}\nvoid mlx5_dev_list_unlock(void)\n{\n\tmutex_unlock(&mlx5_intf_mutex);\n}\n\nint mlx5_dev_list_trylock(void)\n{\n\treturn mutex_trylock(&mlx5_intf_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}