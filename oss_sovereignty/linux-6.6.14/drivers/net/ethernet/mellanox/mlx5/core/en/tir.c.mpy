{
  "module_name": "tir.c",
  "hash_id": "b26c7e47ec8d3c4e0a8822193193209366237146e96413e6d4975ec5990b06af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tir.c",
  "human_readable_source": "\n \n\n#include \"tir.h\"\n#include \"params.h\"\n#include <linux/mlx5/transobj.h>\n\n#define MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ (64 * 1024)\n\n \n#define MLX5E_TIR_CMD_IN_SZ_DW ( \\\n\tMLX5_ST_SZ_DW(create_tir_in) > MLX5_ST_SZ_DW(modify_tir_in) ? \\\n\tMLX5_ST_SZ_DW(create_tir_in) : MLX5_ST_SZ_DW(modify_tir_in) \\\n)\n\nstruct mlx5e_tir_builder {\n\tu32 in[MLX5E_TIR_CMD_IN_SZ_DW];\n\tbool modify;\n};\n\nstruct mlx5e_tir_builder *mlx5e_tir_builder_alloc(bool modify)\n{\n\tstruct mlx5e_tir_builder *builder;\n\n\tbuilder = kvzalloc(sizeof(*builder), GFP_KERNEL);\n\tbuilder->modify = modify;\n\n\treturn builder;\n}\n\nvoid mlx5e_tir_builder_free(struct mlx5e_tir_builder *builder)\n{\n\tkvfree(builder);\n}\n\nvoid mlx5e_tir_builder_clear(struct mlx5e_tir_builder *builder)\n{\n\tmemset(builder->in, 0, sizeof(builder->in));\n}\n\nstatic void *mlx5e_tir_builder_get_tirc(struct mlx5e_tir_builder *builder)\n{\n\tif (builder->modify)\n\t\treturn MLX5_ADDR_OF(modify_tir_in, builder->in, ctx);\n\treturn MLX5_ADDR_OF(create_tir_in, builder->in, ctx);\n}\n\nvoid mlx5e_tir_builder_build_inline(struct mlx5e_tir_builder *builder, u32 tdn, u32 rqn)\n{\n\tvoid *tirc = mlx5e_tir_builder_get_tirc(builder);\n\n\tWARN_ON(builder->modify);\n\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\tMLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_DIRECT);\n\tMLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_NONE);\n\tMLX5_SET(tirc, tirc, inline_rqn, rqn);\n}\n\nvoid mlx5e_tir_builder_build_rqt(struct mlx5e_tir_builder *builder, u32 tdn,\n\t\t\t\t u32 rqtn, bool inner_ft_support)\n{\n\tvoid *tirc = mlx5e_tir_builder_get_tirc(builder);\n\n\tWARN_ON(builder->modify);\n\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\tMLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);\n\tMLX5_SET(tirc, tirc, indirect_table, rqtn);\n\tMLX5_SET(tirc, tirc, tunneled_offload_en, inner_ft_support);\n}\n\nvoid mlx5e_tir_builder_build_packet_merge(struct mlx5e_tir_builder *builder,\n\t\t\t\t\t  const struct mlx5e_packet_merge_param *pkt_merge_param)\n{\n\tvoid *tirc = mlx5e_tir_builder_get_tirc(builder);\n\tconst unsigned int rough_max_l2_l3_hdr_sz = 256;\n\n\tif (builder->modify)\n\t\tMLX5_SET(modify_tir_in, builder->in, bitmask.packet_merge, 1);\n\n\tswitch (pkt_merge_param->type) {\n\tcase MLX5E_PACKET_MERGE_LRO:\n\t\tMLX5_SET(tirc, tirc, packet_merge_mask,\n\t\t\t MLX5_TIRC_PACKET_MERGE_MASK_IPV4_LRO |\n\t\t\t MLX5_TIRC_PACKET_MERGE_MASK_IPV6_LRO);\n\t\tMLX5_SET(tirc, tirc, lro_max_ip_payload_size,\n\t\t\t (MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ - rough_max_l2_l3_hdr_sz) >> 8);\n\t\tMLX5_SET(tirc, tirc, lro_timeout_period_usecs, pkt_merge_param->timeout);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mlx5e_hfunc_to_hw(u8 hfunc)\n{\n\tswitch (hfunc) {\n\tcase ETH_RSS_HASH_TOP:\n\t\treturn MLX5_RX_HASH_FN_TOEPLITZ;\n\tcase ETH_RSS_HASH_XOR:\n\t\treturn MLX5_RX_HASH_FN_INVERTED_XOR8;\n\tdefault:\n\t\treturn MLX5_RX_HASH_FN_NONE;\n\t}\n}\n\nvoid mlx5e_tir_builder_build_rss(struct mlx5e_tir_builder *builder,\n\t\t\t\t const struct mlx5e_rss_params_hash *rss_hash,\n\t\t\t\t const struct mlx5e_rss_params_traffic_type *rss_tt,\n\t\t\t\t bool inner)\n{\n\tvoid *tirc = mlx5e_tir_builder_get_tirc(builder);\n\tvoid *hfso;\n\n\tif (builder->modify)\n\t\tMLX5_SET(modify_tir_in, builder->in, bitmask.hash, 1);\n\n\tMLX5_SET(tirc, tirc, rx_hash_fn, mlx5e_hfunc_to_hw(rss_hash->hfunc));\n\tif (rss_hash->hfunc == ETH_RSS_HASH_TOP) {\n\t\tconst size_t len = MLX5_FLD_SZ_BYTES(tirc, rx_hash_toeplitz_key);\n\t\tvoid *rss_key = MLX5_ADDR_OF(tirc, tirc, rx_hash_toeplitz_key);\n\n\t\tMLX5_SET(tirc, tirc, rx_hash_symmetric, 1);\n\t\tmemcpy(rss_key, rss_hash->toeplitz_hash_key, len);\n\t}\n\n\tif (inner)\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner);\n\telse\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);\n\tMLX5_SET(rx_hash_field_select, hfso, l3_prot_type, rss_tt->l3_prot_type);\n\tMLX5_SET(rx_hash_field_select, hfso, l4_prot_type, rss_tt->l4_prot_type);\n\tMLX5_SET(rx_hash_field_select, hfso, selected_fields, rss_tt->rx_hash_fields);\n}\n\nvoid mlx5e_tir_builder_build_direct(struct mlx5e_tir_builder *builder)\n{\n\tvoid *tirc = mlx5e_tir_builder_get_tirc(builder);\n\n\tWARN_ON(builder->modify);\n\n\tMLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_INVERTED_XOR8);\n}\n\nvoid mlx5e_tir_builder_build_tls(struct mlx5e_tir_builder *builder)\n{\n\tvoid *tirc = mlx5e_tir_builder_get_tirc(builder);\n\n\tWARN_ON(builder->modify);\n\n\tMLX5_SET(tirc, tirc, tls_en, 1);\n\tMLX5_SET(tirc, tirc, self_lb_block,\n\t\t MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST |\n\t\t MLX5_TIRC_SELF_LB_BLOCK_BLOCK_MULTICAST);\n}\n\nint mlx5e_tir_init(struct mlx5e_tir *tir, struct mlx5e_tir_builder *builder,\n\t\t   struct mlx5_core_dev *mdev, bool reg)\n{\n\tint err;\n\n\ttir->mdev = mdev;\n\n\terr = mlx5_core_create_tir(tir->mdev, builder->in, &tir->tirn);\n\tif (err)\n\t\treturn err;\n\n\tif (reg) {\n\t\tstruct mlx5e_hw_objs *res = &tir->mdev->mlx5e_res.hw_objs;\n\n\t\tmutex_lock(&res->td.list_lock);\n\t\tlist_add(&tir->list, &res->td.tirs_list);\n\t\tmutex_unlock(&res->td.list_lock);\n\t} else {\n\t\tINIT_LIST_HEAD(&tir->list);\n\t}\n\n\treturn 0;\n}\n\nvoid mlx5e_tir_destroy(struct mlx5e_tir *tir)\n{\n\tstruct mlx5e_hw_objs *res = &tir->mdev->mlx5e_res.hw_objs;\n\n\t \n\tif (!list_empty(&tir->list)) {\n\t\tmutex_lock(&res->td.list_lock);\n\t\tlist_del(&tir->list);\n\t\tmutex_unlock(&res->td.list_lock);\n\t}\n\n\tmlx5_core_destroy_tir(tir->mdev, tir->tirn);\n}\n\nint mlx5e_tir_modify(struct mlx5e_tir *tir, struct mlx5e_tir_builder *builder)\n{\n\treturn mlx5_core_modify_tir(tir->mdev, tir->tirn, builder->in);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}