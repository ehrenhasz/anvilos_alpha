{
  "module_name": "port_buffer.c",
  "hash_id": "687d65e51fa985198ad82c514192db797205dd9ec3f712d6a0736bad8273e686",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/port_buffer.c",
  "human_readable_source": " \n#include \"port_buffer.h\"\n\nint mlx5e_port_query_buffer(struct mlx5e_priv *priv,\n\t\t\t    struct mlx5e_port_buffer *port_buffer)\n{\n\tu16 port_buff_cell_sz = priv->dcbx.port_buff_cell_sz;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint sz = MLX5_ST_SZ_BYTES(pbmc_reg);\n\tu32 total_used = 0;\n\tvoid *buffer;\n\tvoid *out;\n\tint err;\n\tint i;\n\n\tout = kzalloc(sz, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5e_port_query_pbmc(mdev, out);\n\tif (err)\n\t\tgoto out;\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++) {\n\t\tbuffer = MLX5_ADDR_OF(pbmc_reg, out, buffer[i]);\n\t\tport_buffer->buffer[i].lossy =\n\t\t\tMLX5_GET(bufferx_reg, buffer, lossy);\n\t\tport_buffer->buffer[i].epsb =\n\t\t\tMLX5_GET(bufferx_reg, buffer, epsb);\n\t\tport_buffer->buffer[i].size =\n\t\t\tMLX5_GET(bufferx_reg, buffer, size) * port_buff_cell_sz;\n\t\tport_buffer->buffer[i].xon =\n\t\t\tMLX5_GET(bufferx_reg, buffer, xon_threshold) * port_buff_cell_sz;\n\t\tport_buffer->buffer[i].xoff =\n\t\t\tMLX5_GET(bufferx_reg, buffer, xoff_threshold) * port_buff_cell_sz;\n\t\ttotal_used += port_buffer->buffer[i].size;\n\n\t\tnetdev_dbg(priv->netdev, \"buffer %d: size=%d, xon=%d, xoff=%d, epsb=%d, lossy=%d\\n\",\n\t\t\t   i,\n\t\t\t   port_buffer->buffer[i].size,\n\t\t\t   port_buffer->buffer[i].xon,\n\t\t\t   port_buffer->buffer[i].xoff,\n\t\t\t   port_buffer->buffer[i].epsb,\n\t\t\t   port_buffer->buffer[i].lossy);\n\t}\n\n\tport_buffer->internal_buffers_size = 0;\n\tfor (i = MLX5E_MAX_NETWORK_BUFFER; i < MLX5E_TOTAL_BUFFERS; i++) {\n\t\tbuffer = MLX5_ADDR_OF(pbmc_reg, out, buffer[i]);\n\t\tport_buffer->internal_buffers_size +=\n\t\t\tMLX5_GET(bufferx_reg, buffer, size) * port_buff_cell_sz;\n\t}\n\n\tport_buffer->port_buffer_size =\n\t\tMLX5_GET(pbmc_reg, out, port_buffer_size) * port_buff_cell_sz;\n\tport_buffer->headroom_size = total_used;\n\tport_buffer->spare_buffer_size = port_buffer->port_buffer_size -\n\t\t\t\t\t port_buffer->internal_buffers_size -\n\t\t\t\t\t port_buffer->headroom_size;\n\n\tnetdev_dbg(priv->netdev,\n\t\t   \"total buffer size=%u, headroom buffer size=%u, internal buffers size=%u, spare buffer size=%u\\n\",\n\t\t   port_buffer->port_buffer_size, port_buffer->headroom_size,\n\t\t   port_buffer->internal_buffers_size,\n\t\t   port_buffer->spare_buffer_size);\nout:\n\tkfree(out);\n\treturn err;\n}\n\nstruct mlx5e_buffer_pool {\n\tu32 infi_size;\n\tu32 size;\n\tu32 buff_occupancy;\n};\n\nstatic int mlx5e_port_query_pool(struct mlx5_core_dev *mdev,\n\t\t\t\t struct mlx5e_buffer_pool *buffer_pool,\n\t\t\t\t u32 desc, u8 dir, u8 pool_idx)\n{\n\tu32 out[MLX5_ST_SZ_DW(sbpr_reg)] = {};\n\tint err;\n\n\terr = mlx5e_port_query_sbpr(mdev, desc, dir, pool_idx, out,\n\t\t\t\t    sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\tbuffer_pool->size = MLX5_GET(sbpr_reg, out, size);\n\tbuffer_pool->infi_size = MLX5_GET(sbpr_reg, out, infi_size);\n\tbuffer_pool->buff_occupancy = MLX5_GET(sbpr_reg, out, buff_occupancy);\n\n\treturn err;\n}\n\nenum {\n\tMLX5_INGRESS_DIR = 0,\n\tMLX5_EGRESS_DIR = 1,\n};\n\nenum {\n\tMLX5_LOSSY_POOL = 0,\n\tMLX5_LOSSLESS_POOL = 1,\n};\n\n \n#define MLX5_SB_POOL_NO_THRESHOLD  0\n \n#define MLX5_SB_POOL_THRESHOLD 13\n\n \nstruct mlx5_sbcm_params {\n\tu8 pool_idx;\n\tu8 max_buff;\n\tu8 infi_size;\n};\n\nstatic const struct mlx5_sbcm_params sbcm_default = {\n\t.pool_idx = MLX5_LOSSY_POOL,\n\t.max_buff = MLX5_SB_POOL_NO_THRESHOLD,\n\t.infi_size = 0,\n};\n\nstatic const struct mlx5_sbcm_params sbcm_lossy = {\n\t.pool_idx = MLX5_LOSSY_POOL,\n\t.max_buff = MLX5_SB_POOL_NO_THRESHOLD,\n\t.infi_size = 1,\n};\n\nstatic const struct mlx5_sbcm_params sbcm_lossless = {\n\t.pool_idx = MLX5_LOSSLESS_POOL,\n\t.max_buff = MLX5_SB_POOL_THRESHOLD,\n\t.infi_size = 0,\n};\n\nstatic const struct mlx5_sbcm_params sbcm_lossless_no_threshold = {\n\t.pool_idx = MLX5_LOSSLESS_POOL,\n\t.max_buff = MLX5_SB_POOL_NO_THRESHOLD,\n\t.infi_size = 1,\n};\n\n \nstatic const struct mlx5_sbcm_params *\nselect_sbcm_params(struct mlx5e_bufferx_reg *buffer, u8 lossless_buff_count)\n{\n\tif (buffer->size == 0)\n\t\treturn &sbcm_default;\n\n\tif (buffer->lossy)\n\t\treturn &sbcm_lossy;\n\n\tif (lossless_buff_count > 1)\n\t\treturn &sbcm_lossless;\n\n\treturn &sbcm_lossless_no_threshold;\n}\n\nstatic int port_update_pool_cfg(struct mlx5_core_dev *mdev,\n\t\t\t\tstruct mlx5e_port_buffer *port_buffer)\n{\n\tconst struct mlx5_sbcm_params *p;\n\tu8 lossless_buff_count = 0;\n\tint err;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(mdev, sbcam_reg))\n\t\treturn 0;\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++)\n\t\tlossless_buff_count += ((port_buffer->buffer[i].size) &&\n\t\t\t\t       (!(port_buffer->buffer[i].lossy)));\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++) {\n\t\tp = select_sbcm_params(&port_buffer->buffer[i], lossless_buff_count);\n\t\terr = mlx5e_port_set_sbcm(mdev, 0, i,\n\t\t\t\t\t  MLX5_INGRESS_DIR,\n\t\t\t\t\t  p->infi_size,\n\t\t\t\t\t  p->max_buff,\n\t\t\t\t\t  p->pool_idx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int port_update_shared_buffer(struct mlx5_core_dev *mdev,\n\t\t\t\t     u32 current_headroom_size,\n\t\t\t\t     u32 new_headroom_size)\n{\n\tstruct mlx5e_buffer_pool lossless_ipool;\n\tstruct mlx5e_buffer_pool lossy_epool;\n\tu32 lossless_ipool_size;\n\tu32 shared_buffer_size;\n\tu32 total_buffer_size;\n\tu32 lossy_epool_size;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(mdev, sbcam_reg))\n\t\treturn 0;\n\n\terr = mlx5e_port_query_pool(mdev, &lossy_epool, 0, MLX5_EGRESS_DIR,\n\t\t\t\t    MLX5_LOSSY_POOL);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_port_query_pool(mdev, &lossless_ipool, 0, MLX5_INGRESS_DIR,\n\t\t\t\t    MLX5_LOSSLESS_POOL);\n\tif (err)\n\t\treturn err;\n\n\ttotal_buffer_size = current_headroom_size + lossy_epool.size +\n\t\t\t    lossless_ipool.size;\n\tshared_buffer_size = total_buffer_size - new_headroom_size;\n\n\tif (shared_buffer_size < 4) {\n\t\tpr_err(\"Requested port buffer is too large, not enough space left for shared buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlossy_epool_size = (shared_buffer_size / 4) * 3;\n\tlossless_ipool_size = shared_buffer_size / 4;\n\n\tmlx5e_port_set_sbpr(mdev, 0, MLX5_EGRESS_DIR, MLX5_LOSSY_POOL, 0,\n\t\t\t    lossy_epool_size);\n\tmlx5e_port_set_sbpr(mdev, 0, MLX5_INGRESS_DIR, MLX5_LOSSLESS_POOL, 0,\n\t\t\t    lossless_ipool_size);\n\treturn 0;\n}\n\nstatic int port_set_buffer(struct mlx5e_priv *priv,\n\t\t\t   struct mlx5e_port_buffer *port_buffer)\n{\n\tu16 port_buff_cell_sz = priv->dcbx.port_buff_cell_sz;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint sz = MLX5_ST_SZ_BYTES(pbmc_reg);\n\tu32 new_headroom_size = 0;\n\tu32 current_headroom_size;\n\tvoid *in;\n\tint err;\n\tint i;\n\n\tcurrent_headroom_size = port_buffer->headroom_size;\n\n\tin = kzalloc(sz, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\terr = mlx5e_port_query_pbmc(mdev, in);\n\tif (err)\n\t\tgoto out;\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++) {\n\t\tvoid *buffer = MLX5_ADDR_OF(pbmc_reg, in, buffer[i]);\n\t\tu64 size = port_buffer->buffer[i].size;\n\t\tu64 xoff = port_buffer->buffer[i].xoff;\n\t\tu64 xon = port_buffer->buffer[i].xon;\n\n\t\tnew_headroom_size += size;\n\t\tdo_div(size, port_buff_cell_sz);\n\t\tdo_div(xoff, port_buff_cell_sz);\n\t\tdo_div(xon, port_buff_cell_sz);\n\t\tMLX5_SET(bufferx_reg, buffer, size, size);\n\t\tMLX5_SET(bufferx_reg, buffer, lossy, port_buffer->buffer[i].lossy);\n\t\tMLX5_SET(bufferx_reg, buffer, xoff_threshold, xoff);\n\t\tMLX5_SET(bufferx_reg, buffer, xon_threshold, xon);\n\t}\n\n\tnew_headroom_size /= port_buff_cell_sz;\n\tcurrent_headroom_size /= port_buff_cell_sz;\n\terr = port_update_shared_buffer(priv->mdev, current_headroom_size,\n\t\t\t\t\tnew_headroom_size);\n\tif (err)\n\t\tgoto out;\n\n\terr = port_update_pool_cfg(priv->mdev, port_buffer);\n\tif (err)\n\t\tgoto out;\n\n\terr = mlx5e_port_set_pbmc(mdev, in);\nout:\n\tkfree(in);\n\treturn err;\n}\n\n \nstatic u32 calculate_xoff(struct mlx5e_priv *priv, unsigned int mtu)\n{\n\tu32 speed;\n\tu32 xoff;\n\tint err;\n\n\terr = mlx5e_port_linkspeed(priv->mdev, &speed);\n\tif (err)\n\t\tspeed = SPEED_40000;\n\tspeed = max_t(u32, speed, SPEED_40000);\n\n\txoff = (301 + 216 * priv->dcbx.cable_len / 100) * speed / 1000 + 272 * mtu / 100;\n\n\tnetdev_dbg(priv->netdev, \"%s: xoff=%d\\n\", __func__, xoff);\n\treturn xoff;\n}\n\nstatic int update_xoff_threshold(struct mlx5e_port_buffer *port_buffer,\n\t\t\t\t u32 xoff, unsigned int max_mtu, u16 port_buff_cell_sz)\n{\n\tint i;\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++) {\n\t\tif (port_buffer->buffer[i].lossy) {\n\t\t\tport_buffer->buffer[i].xoff = 0;\n\t\t\tport_buffer->buffer[i].xon  = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (port_buffer->buffer[i].size <\n\t\t    (xoff + max_mtu + port_buff_cell_sz)) {\n\t\t\tpr_err(\"buffer_size[%d]=%d is not enough for lossless buffer\\n\",\n\t\t\t       i, port_buffer->buffer[i].size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tport_buffer->buffer[i].xoff = port_buffer->buffer[i].size - xoff;\n\t\tport_buffer->buffer[i].xon  =\n\t\t\tport_buffer->buffer[i].xoff - max_mtu;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int update_buffer_lossy(struct mlx5_core_dev *mdev,\n\t\t\t       unsigned int max_mtu,\n\t\t\t       u8 pfc_en, u8 *buffer, u32 xoff, u16 port_buff_cell_sz,\n\t\t\t       struct mlx5e_port_buffer *port_buffer,\n\t\t\t       bool *change)\n{\n\tbool changed = false;\n\tu8 lossy_count;\n\tu8 prio_count;\n\tu8 lossy;\n\tint prio;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++) {\n\t\tprio_count = 0;\n\t\tlossy_count = 0;\n\n\t\tfor (prio = 0; prio < MLX5E_MAX_PRIORITY; prio++) {\n\t\t\tif (buffer[prio] != i)\n\t\t\t\tcontinue;\n\n\t\t\tprio_count++;\n\t\t\tlossy_count += !(pfc_en & (1 << prio));\n\t\t}\n\n\t\tif (lossy_count == prio_count)\n\t\t\tlossy = 1;\n\t\telse  \n\t\t\tlossy = 0;\n\n\t\tif (lossy != port_buffer->buffer[i].lossy) {\n\t\t\tport_buffer->buffer[i].lossy = lossy;\n\t\t\tchanged = true;\n\t\t}\n\t}\n\n\tif (changed) {\n\t\terr = update_xoff_threshold(port_buffer, xoff, max_mtu, port_buff_cell_sz);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = port_update_pool_cfg(mdev, port_buffer);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*change = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int fill_pfc_en(struct mlx5_core_dev *mdev, u8 *pfc_en)\n{\n\tu32 g_rx_pause, g_tx_pause;\n\tint err;\n\n\terr = mlx5_query_port_pause(mdev, &g_rx_pause, &g_tx_pause);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (g_rx_pause || g_tx_pause)\n\t\t*pfc_en = 0xff;\n\telse\n\t\terr = mlx5_query_port_pfc(mdev, pfc_en, NULL);\n\n\treturn err;\n}\n\n#define MINIMUM_MAX_MTU 9216\nint mlx5e_port_manual_buffer_config(struct mlx5e_priv *priv,\n\t\t\t\t    u32 change, unsigned int mtu,\n\t\t\t\t    struct ieee_pfc *pfc,\n\t\t\t\t    u32 *buffer_size,\n\t\t\t\t    u8 *prio2buffer)\n{\n\tu16 port_buff_cell_sz = priv->dcbx.port_buff_cell_sz;\n\tstruct net_device *netdev = priv->netdev;\n\tstruct mlx5e_port_buffer port_buffer;\n\tu32 xoff = calculate_xoff(priv, mtu);\n\tbool update_prio2buffer = false;\n\tu8 buffer[MLX5E_MAX_PRIORITY];\n\tbool update_buffer = false;\n\tunsigned int max_mtu;\n\tu32 total_used = 0;\n\tu8 curr_pfc_en;\n\tint err;\n\tint i;\n\n\tnetdev_dbg(netdev, \"%s: change=%x\\n\", __func__, change);\n\tmax_mtu = max_t(unsigned int, priv->netdev->max_mtu, MINIMUM_MAX_MTU);\n\n\terr = mlx5e_port_query_buffer(priv, &port_buffer);\n\tif (err)\n\t\treturn err;\n\n\tif (change & MLX5E_PORT_BUFFER_CABLE_LEN) {\n\t\tupdate_buffer = true;\n\t\terr = update_xoff_threshold(&port_buffer, xoff, max_mtu, port_buff_cell_sz);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (change & MLX5E_PORT_BUFFER_PFC) {\n\t\tnetdev_dbg(netdev, \"%s: requested PFC per priority bitmask: 0x%x\\n\",\n\t\t\t   __func__, pfc->pfc_en);\n\t\terr = mlx5e_port_query_priority2buffer(priv->mdev, buffer);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = update_buffer_lossy(priv->mdev, max_mtu, pfc->pfc_en, buffer, xoff,\n\t\t\t\t\t  port_buff_cell_sz, &port_buffer,\n\t\t\t\t\t  &update_buffer);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (change & MLX5E_PORT_BUFFER_PRIO2BUFFER) {\n\t\tupdate_prio2buffer = true;\n\t\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++)\n\t\t\tnetdev_dbg(priv->netdev, \"%s: requested to map prio[%d] to buffer %d\\n\",\n\t\t\t\t   __func__, i, prio2buffer[i]);\n\n\t\terr = fill_pfc_en(priv->mdev, &curr_pfc_en);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = update_buffer_lossy(priv->mdev, max_mtu, curr_pfc_en, prio2buffer, xoff,\n\t\t\t\t\t  port_buff_cell_sz, &port_buffer, &update_buffer);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (change & MLX5E_PORT_BUFFER_SIZE) {\n\t\tfor (i = 0; i < MLX5E_MAX_NETWORK_BUFFER; i++) {\n\t\t\tnetdev_dbg(priv->netdev, \"%s: buffer[%d]=%d\\n\", __func__, i, buffer_size[i]);\n\t\t\tif (!port_buffer.buffer[i].lossy && !buffer_size[i]) {\n\t\t\t\tnetdev_dbg(priv->netdev, \"%s: lossless buffer[%d] size cannot be zero\\n\",\n\t\t\t\t\t   __func__, i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tport_buffer.buffer[i].size = buffer_size[i];\n\t\t\ttotal_used += buffer_size[i];\n\t\t}\n\n\t\tnetdev_dbg(priv->netdev, \"%s: total buffer requested=%d\\n\", __func__, total_used);\n\n\t\tif (total_used > port_buffer.headroom_size &&\n\t\t    (total_used - port_buffer.headroom_size) >\n\t\t\t    port_buffer.spare_buffer_size)\n\t\t\treturn -EINVAL;\n\n\t\tupdate_buffer = true;\n\t\terr = update_xoff_threshold(&port_buffer, xoff, max_mtu, port_buff_cell_sz);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!update_buffer && xoff != priv->dcbx.xoff) {\n\t\tupdate_buffer = true;\n\t\terr = update_xoff_threshold(&port_buffer, xoff, max_mtu, port_buff_cell_sz);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tpriv->dcbx.xoff = xoff;\n\n\t \n\tif (update_buffer) {\n\t\terr = port_set_buffer(priv, &port_buffer);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (update_prio2buffer)\n\t\terr = mlx5e_port_set_priority2buffer(priv->mdev, prio2buffer);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}