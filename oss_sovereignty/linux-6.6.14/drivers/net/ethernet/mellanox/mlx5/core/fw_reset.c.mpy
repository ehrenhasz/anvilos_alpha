{
  "module_name": "fw_reset.c",
  "hash_id": "f3da239535cd6f1b48120c3fa78be46a324fc223b42f3ae696c9fb93f782bb60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/fw_reset.c",
  "human_readable_source": "\n \n\n#include <devlink.h>\n\n#include \"fw_reset.h\"\n#include \"diag/fw_tracer.h\"\n#include \"lib/tout.h\"\n\nenum {\n\tMLX5_FW_RESET_FLAGS_RESET_REQUESTED,\n\tMLX5_FW_RESET_FLAGS_NACK_RESET_REQUEST,\n\tMLX5_FW_RESET_FLAGS_PENDING_COMP,\n\tMLX5_FW_RESET_FLAGS_DROP_NEW_REQUESTS,\n\tMLX5_FW_RESET_FLAGS_RELOAD_REQUIRED\n};\n\nstruct mlx5_fw_reset {\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_nb nb;\n\tstruct workqueue_struct *wq;\n\tstruct work_struct fw_live_patch_work;\n\tstruct work_struct reset_request_work;\n\tstruct work_struct reset_unload_work;\n\tstruct work_struct reset_reload_work;\n\tstruct work_struct reset_now_work;\n\tstruct work_struct reset_abort_work;\n\tunsigned long reset_flags;\n\tstruct timer_list timer;\n\tstruct completion done;\n\tint ret;\n};\n\nenum {\n\tMLX5_FW_RST_STATE_IDLE = 0,\n\tMLX5_FW_RST_STATE_TOGGLE_REQ = 4,\n};\n\nenum {\n\tMLX5_RST_STATE_BIT_NUM = 12,\n\tMLX5_RST_ACK_BIT_NUM = 22,\n};\n\nstatic u8 mlx5_get_fw_rst_state(struct mlx5_core_dev *dev)\n{\n\treturn (ioread32be(&dev->iseg->initializing) >> MLX5_RST_STATE_BIT_NUM) & 0xF;\n}\n\nstatic void mlx5_set_fw_rst_ack(struct mlx5_core_dev *dev)\n{\n\tiowrite32be(BIT(MLX5_RST_ACK_BIT_NUM), &dev->iseg->initializing);\n}\n\nstatic int mlx5_fw_reset_enable_remote_dev_reset_set(struct devlink *devlink, u32 id,\n\t\t\t\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct mlx5_fw_reset *fw_reset;\n\n\tfw_reset = dev->priv.fw_reset;\n\n\tif (ctx->val.vbool)\n\t\tclear_bit(MLX5_FW_RESET_FLAGS_NACK_RESET_REQUEST, &fw_reset->reset_flags);\n\telse\n\t\tset_bit(MLX5_FW_RESET_FLAGS_NACK_RESET_REQUEST, &fw_reset->reset_flags);\n\treturn 0;\n}\n\nstatic int mlx5_fw_reset_enable_remote_dev_reset_get(struct devlink *devlink, u32 id,\n\t\t\t\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_priv(devlink);\n\tstruct mlx5_fw_reset *fw_reset;\n\n\tfw_reset = dev->priv.fw_reset;\n\n\tctx->val.vbool = !test_bit(MLX5_FW_RESET_FLAGS_NACK_RESET_REQUEST,\n\t\t\t\t   &fw_reset->reset_flags);\n\treturn 0;\n}\n\nstatic int mlx5_reg_mfrl_set(struct mlx5_core_dev *dev, u8 reset_level,\n\t\t\t     u8 reset_type_sel, u8 sync_resp, bool sync_start)\n{\n\tu32 out[MLX5_ST_SZ_DW(mfrl_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(mfrl_reg)] = {};\n\n\tMLX5_SET(mfrl_reg, in, reset_level, reset_level);\n\tMLX5_SET(mfrl_reg, in, rst_type_sel, reset_type_sel);\n\tMLX5_SET(mfrl_reg, in, pci_sync_for_fw_update_resp, sync_resp);\n\tMLX5_SET(mfrl_reg, in, pci_sync_for_fw_update_start, sync_start);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out), MLX5_REG_MFRL, 0, 1);\n}\n\nstatic int mlx5_reg_mfrl_query(struct mlx5_core_dev *dev, u8 *reset_level,\n\t\t\t       u8 *reset_type, u8 *reset_state)\n{\n\tu32 out[MLX5_ST_SZ_DW(mfrl_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(mfrl_reg)] = {};\n\tint err;\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out), MLX5_REG_MFRL, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (reset_level)\n\t\t*reset_level = MLX5_GET(mfrl_reg, out, reset_level);\n\tif (reset_type)\n\t\t*reset_type = MLX5_GET(mfrl_reg, out, reset_type);\n\tif (reset_state)\n\t\t*reset_state = MLX5_GET(mfrl_reg, out, reset_state);\n\n\treturn 0;\n}\n\nint mlx5_fw_reset_query(struct mlx5_core_dev *dev, u8 *reset_level, u8 *reset_type)\n{\n\treturn mlx5_reg_mfrl_query(dev, reset_level, reset_type, NULL);\n}\n\nstatic int mlx5_fw_reset_get_reset_state_err(struct mlx5_core_dev *dev,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu8 reset_state;\n\n\tif (mlx5_reg_mfrl_query(dev, NULL, NULL, &reset_state))\n\t\tgoto out;\n\n\tif (!reset_state)\n\t\treturn 0;\n\n\tswitch (reset_state) {\n\tcase MLX5_MFRL_REG_RESET_STATE_IN_NEGOTIATION:\n\tcase MLX5_MFRL_REG_RESET_STATE_RESET_IN_PROGRESS:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Sync reset still in progress\");\n\t\treturn -EBUSY;\n\tcase MLX5_MFRL_REG_RESET_STATE_NEG_TIMEOUT:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Sync reset negotiation timeout\");\n\t\treturn -ETIMEDOUT;\n\tcase MLX5_MFRL_REG_RESET_STATE_NACK:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"One of the hosts disabled reset\");\n\t\treturn -EPERM;\n\tcase MLX5_MFRL_REG_RESET_STATE_UNLOAD_TIMEOUT:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Sync reset unload timeout\");\n\t\treturn -ETIMEDOUT;\n\t}\n\nout:\n\tNL_SET_ERR_MSG_MOD(extack, \"Sync reset failed\");\n\treturn -EIO;\n}\n\nint mlx5_fw_reset_set_reset_sync(struct mlx5_core_dev *dev, u8 reset_type_sel,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\tu32 out[MLX5_ST_SZ_DW(mfrl_reg)] = {};\n\tu32 in[MLX5_ST_SZ_DW(mfrl_reg)] = {};\n\tint err, rst_res;\n\n\tset_bit(MLX5_FW_RESET_FLAGS_PENDING_COMP, &fw_reset->reset_flags);\n\n\tMLX5_SET(mfrl_reg, in, reset_level, MLX5_MFRL_REG_RESET_LEVEL3);\n\tMLX5_SET(mfrl_reg, in, rst_type_sel, reset_type_sel);\n\tMLX5_SET(mfrl_reg, in, pci_sync_for_fw_update_start, 1);\n\terr = mlx5_access_reg(dev, in, sizeof(in), out, sizeof(out),\n\t\t\t      MLX5_REG_MFRL, 0, 1, false);\n\tif (!err)\n\t\treturn 0;\n\n\tclear_bit(MLX5_FW_RESET_FLAGS_PENDING_COMP, &fw_reset->reset_flags);\n\tif (err == -EREMOTEIO && MLX5_CAP_MCAM_FEATURE(dev, reset_state)) {\n\t\trst_res = mlx5_fw_reset_get_reset_state_err(dev, extack);\n\t\treturn rst_res ? rst_res : err;\n\t}\n\n\tNL_SET_ERR_MSG_MOD(extack, \"Sync reset command failed\");\n\treturn mlx5_cmd_check(dev, err, in, out);\n}\n\nint mlx5_fw_reset_verify_fw_complete(struct mlx5_core_dev *dev,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu8 rst_state;\n\tint err;\n\n\terr = mlx5_fw_reset_get_reset_state_err(dev, extack);\n\tif (err)\n\t\treturn err;\n\n\trst_state = mlx5_get_fw_rst_state(dev);\n\tif (!rst_state)\n\t\treturn 0;\n\n\tmlx5_core_err(dev, \"Sync reset did not complete, state=%d\\n\", rst_state);\n\tNL_SET_ERR_MSG_MOD(extack, \"Sync reset did not complete successfully\");\n\treturn rst_state;\n}\n\nint mlx5_fw_reset_set_live_patch(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_reg_mfrl_set(dev, MLX5_MFRL_REG_RESET_LEVEL0, 0, 0, false);\n}\n\nstatic void mlx5_fw_reset_complete_reload(struct mlx5_core_dev *dev, bool unloaded)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\t \n\tif (test_bit(MLX5_FW_RESET_FLAGS_PENDING_COMP, &fw_reset->reset_flags)) {\n\t\tcomplete(&fw_reset->done);\n\t} else {\n\t\tif (!unloaded)\n\t\t\tmlx5_unload_one(dev, false);\n\t\tif (mlx5_health_wait_pci_up(dev))\n\t\t\tmlx5_core_err(dev, \"reset reload flow aborted, PCI reads still not working\\n\");\n\t\telse\n\t\t\tmlx5_load_one(dev, true);\n\t\tdevlink_remote_reload_actions_performed(priv_to_devlink(dev), 0,\n\t\t\t\t\t\t\tBIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |\n\t\t\t\t\t\t\tBIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE));\n\t}\n}\n\nstatic void mlx5_stop_sync_reset_poll(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\tdel_timer_sync(&fw_reset->timer);\n}\n\nstatic int mlx5_sync_reset_clear_reset_requested(struct mlx5_core_dev *dev, bool poll_health)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\tif (!test_and_clear_bit(MLX5_FW_RESET_FLAGS_RESET_REQUESTED, &fw_reset->reset_flags)) {\n\t\tmlx5_core_warn(dev, \"Reset request was already cleared\\n\");\n\t\treturn -EALREADY;\n\t}\n\n\tmlx5_stop_sync_reset_poll(dev);\n\tif (poll_health)\n\t\tmlx5_start_health_poll(dev);\n\treturn 0;\n}\n\nstatic void mlx5_sync_reset_reload_work(struct work_struct *work)\n{\n\tstruct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,\n\t\t\t\t\t\t      reset_reload_work);\n\tstruct mlx5_core_dev *dev = fw_reset->dev;\n\n\tmlx5_sync_reset_clear_reset_requested(dev, false);\n\tmlx5_enter_error_state(dev, true);\n\tmlx5_fw_reset_complete_reload(dev, false);\n}\n\n#define MLX5_RESET_POLL_INTERVAL\t(HZ / 10)\nstatic void poll_sync_reset(struct timer_list *t)\n{\n\tstruct mlx5_fw_reset *fw_reset = from_timer(fw_reset, t, timer);\n\tstruct mlx5_core_dev *dev = fw_reset->dev;\n\tu32 fatal_error;\n\n\tif (!test_bit(MLX5_FW_RESET_FLAGS_RESET_REQUESTED, &fw_reset->reset_flags))\n\t\treturn;\n\n\tfatal_error = mlx5_health_check_fatal_sensors(dev);\n\n\tif (fatal_error) {\n\t\tmlx5_core_warn(dev, \"Got Device Reset\\n\");\n\t\tif (!test_bit(MLX5_FW_RESET_FLAGS_DROP_NEW_REQUESTS, &fw_reset->reset_flags))\n\t\t\tqueue_work(fw_reset->wq, &fw_reset->reset_reload_work);\n\t\telse\n\t\t\tmlx5_core_err(dev, \"Device is being removed, Drop new reset work\\n\");\n\t\treturn;\n\t}\n\n\tmod_timer(&fw_reset->timer, round_jiffies(jiffies + MLX5_RESET_POLL_INTERVAL));\n}\n\nstatic void mlx5_start_sync_reset_poll(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\ttimer_setup(&fw_reset->timer, poll_sync_reset, 0);\n\tfw_reset->timer.expires = round_jiffies(jiffies + MLX5_RESET_POLL_INTERVAL);\n\tadd_timer(&fw_reset->timer);\n}\n\nstatic int mlx5_fw_reset_set_reset_sync_ack(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_reg_mfrl_set(dev, MLX5_MFRL_REG_RESET_LEVEL3, 0, 1, false);\n}\n\nstatic int mlx5_fw_reset_set_reset_sync_nack(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_reg_mfrl_set(dev, MLX5_MFRL_REG_RESET_LEVEL3, 0, 2, false);\n}\n\nstatic int mlx5_sync_reset_set_reset_requested(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\tif (test_and_set_bit(MLX5_FW_RESET_FLAGS_RESET_REQUESTED, &fw_reset->reset_flags)) {\n\t\tmlx5_core_warn(dev, \"Reset request was already set\\n\");\n\t\treturn -EALREADY;\n\t}\n\tmlx5_stop_health_poll(dev, true);\n\tmlx5_start_sync_reset_poll(dev);\n\treturn 0;\n}\n\nstatic void mlx5_fw_live_patch_event(struct work_struct *work)\n{\n\tstruct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,\n\t\t\t\t\t\t      fw_live_patch_work);\n\tstruct mlx5_core_dev *dev = fw_reset->dev;\n\n\tmlx5_core_info(dev, \"Live patch updated firmware version: %d.%d.%d\\n\", fw_rev_maj(dev),\n\t\t       fw_rev_min(dev), fw_rev_sub(dev));\n\n\tif (mlx5_fw_tracer_reload(dev->tracer))\n\t\tmlx5_core_err(dev, \"Failed to reload FW tracer\\n\");\n}\n\n#if IS_ENABLED(CONFIG_HOTPLUG_PCI_PCIE)\nstatic int mlx5_check_hotplug_interrupt(struct mlx5_core_dev *dev)\n{\n\tstruct pci_dev *bridge = dev->pdev->bus->self;\n\tu16 reg16;\n\tint err;\n\n\tif (!bridge)\n\t\treturn -EOPNOTSUPP;\n\n\terr = pcie_capability_read_word(bridge, PCI_EXP_SLTCTL, &reg16);\n\tif (err)\n\t\treturn err;\n\n\tif ((reg16 & PCI_EXP_SLTCTL_HPIE) && (reg16 & PCI_EXP_SLTCTL_DLLSCE)) {\n\t\tmlx5_core_warn(dev, \"FW reset is not supported as HotPlug is enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int mlx5_check_dev_ids(struct mlx5_core_dev *dev, u16 dev_id)\n{\n\tstruct pci_bus *bridge_bus = dev->pdev->bus;\n\tstruct pci_dev *sdev;\n\tu16 sdev_id;\n\tint err;\n\n\t \n\tlist_for_each_entry(sdev, &bridge_bus->devices, bus_list) {\n\t\terr = pci_read_config_word(sdev, PCI_DEVICE_ID, &sdev_id);\n\t\tif (err)\n\t\t\treturn pcibios_err_to_errno(err);\n\t\tif (sdev_id != dev_id) {\n\t\t\tmlx5_core_warn(dev, \"unrecognized dev_id (0x%x)\\n\", sdev_id);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool mlx5_is_reset_now_capable(struct mlx5_core_dev *dev)\n{\n\tu16 dev_id;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(dev, fast_teardown)) {\n\t\tmlx5_core_warn(dev, \"fast teardown is not supported by firmware\\n\");\n\t\treturn false;\n\t}\n\n#if IS_ENABLED(CONFIG_HOTPLUG_PCI_PCIE)\n\terr = mlx5_check_hotplug_interrupt(dev);\n\tif (err)\n\t\treturn false;\n#endif\n\n\terr = pci_read_config_word(dev->pdev, PCI_DEVICE_ID, &dev_id);\n\tif (err)\n\t\treturn false;\n\treturn (!mlx5_check_dev_ids(dev, dev_id));\n}\n\nstatic void mlx5_sync_reset_request_event(struct work_struct *work)\n{\n\tstruct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,\n\t\t\t\t\t\t      reset_request_work);\n\tstruct mlx5_core_dev *dev = fw_reset->dev;\n\tint err;\n\n\tif (test_bit(MLX5_FW_RESET_FLAGS_NACK_RESET_REQUEST, &fw_reset->reset_flags) ||\n\t    !mlx5_is_reset_now_capable(dev)) {\n\t\terr = mlx5_fw_reset_set_reset_sync_nack(dev);\n\t\tmlx5_core_warn(dev, \"PCI Sync FW Update Reset Nack %s\",\n\t\t\t       err ? \"Failed\" : \"Sent\");\n\t\treturn;\n\t}\n\tif (mlx5_sync_reset_set_reset_requested(dev))\n\t\treturn;\n\n\terr = mlx5_fw_reset_set_reset_sync_ack(dev);\n\tif (err)\n\t\tmlx5_core_warn(dev, \"PCI Sync FW Update Reset Ack Failed. Error code: %d\\n\", err);\n\telse\n\t\tmlx5_core_warn(dev, \"PCI Sync FW Update Reset Ack. Device reset is expected.\\n\");\n}\n\nstatic int mlx5_pci_link_toggle(struct mlx5_core_dev *dev)\n{\n\tstruct pci_bus *bridge_bus = dev->pdev->bus;\n\tstruct pci_dev *bridge = bridge_bus->self;\n\tunsigned long timeout;\n\tstruct pci_dev *sdev;\n\tu16 reg16, dev_id;\n\tint cap, err;\n\n\terr = pci_read_config_word(dev->pdev, PCI_DEVICE_ID, &dev_id);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\terr = mlx5_check_dev_ids(dev, dev_id);\n\tif (err)\n\t\treturn err;\n\tcap = pci_find_capability(bridge, PCI_CAP_ID_EXP);\n\tif (!cap)\n\t\treturn -EOPNOTSUPP;\n\n\tlist_for_each_entry(sdev, &bridge_bus->devices, bus_list) {\n\t\tpci_save_state(sdev);\n\t\tpci_cfg_access_lock(sdev);\n\t}\n\t \n\terr = pcie_capability_set_word(bridge, PCI_EXP_LNKCTL, PCI_EXP_LNKCTL_LD);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\tmsleep(500);\n\terr = pcie_capability_clear_word(bridge, PCI_EXP_LNKCTL, PCI_EXP_LNKCTL_LD);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\t \n\tif (!bridge->link_active_reporting) {\n\t\tmlx5_core_warn(dev, \"No PCI link reporting capability\\n\");\n\t\tmsleep(1000);\n\t\tgoto restore;\n\t}\n\n\ttimeout = jiffies + msecs_to_jiffies(mlx5_tout_ms(dev, PCI_TOGGLE));\n\tdo {\n\t\terr = pci_read_config_word(bridge, cap + PCI_EXP_LNKSTA, &reg16);\n\t\tif (err)\n\t\t\treturn pcibios_err_to_errno(err);\n\t\tif (reg16 & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t} while (!time_after(jiffies, timeout));\n\n\tif (reg16 & PCI_EXP_LNKSTA_DLLLA) {\n\t\tmlx5_core_info(dev, \"PCI Link up\\n\");\n\t} else {\n\t\tmlx5_core_err(dev, \"PCI link not ready (0x%04x) after %llu ms\\n\",\n\t\t\t      reg16, mlx5_tout_ms(dev, PCI_TOGGLE));\n\t\terr = -ETIMEDOUT;\n\t\tgoto restore;\n\t}\n\n\tdo {\n\t\terr = pci_read_config_word(dev->pdev, PCI_DEVICE_ID, &reg16);\n\t\tif (err)\n\t\t\treturn pcibios_err_to_errno(err);\n\t\tif (reg16 == dev_id)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t} while (!time_after(jiffies, timeout));\n\n\tif (reg16 == dev_id) {\n\t\tmlx5_core_info(dev, \"Firmware responds to PCI config cycles again\\n\");\n\t} else {\n\t\tmlx5_core_err(dev, \"Firmware is not responsive (0x%04x) after %llu ms\\n\",\n\t\t\t      reg16, mlx5_tout_ms(dev, PCI_TOGGLE));\n\t\terr = -ETIMEDOUT;\n\t}\n\nrestore:\n\tlist_for_each_entry(sdev, &bridge_bus->devices, bus_list) {\n\t\tpci_cfg_access_unlock(sdev);\n\t\tpci_restore_state(sdev);\n\t}\n\n\treturn err;\n}\n\nstatic void mlx5_sync_reset_now_event(struct work_struct *work)\n{\n\tstruct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,\n\t\t\t\t\t\t      reset_now_work);\n\tstruct mlx5_core_dev *dev = fw_reset->dev;\n\tint err;\n\n\tif (mlx5_sync_reset_clear_reset_requested(dev, false))\n\t\treturn;\n\n\tmlx5_core_warn(dev, \"Sync Reset now. Device is going to reset.\\n\");\n\n\terr = mlx5_cmd_fast_teardown_hca(dev);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"Fast teardown failed, no reset done, err %d\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = mlx5_pci_link_toggle(dev);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"mlx5_pci_link_toggle failed, no reset done, err %d\\n\", err);\n\t\tset_bit(MLX5_FW_RESET_FLAGS_RELOAD_REQUIRED, &fw_reset->reset_flags);\n\t}\n\n\tmlx5_enter_error_state(dev, true);\ndone:\n\tfw_reset->ret = err;\n\tmlx5_fw_reset_complete_reload(dev, false);\n}\n\nstatic void mlx5_sync_reset_unload_event(struct work_struct *work)\n{\n\tstruct mlx5_fw_reset *fw_reset;\n\tstruct mlx5_core_dev *dev;\n\tunsigned long timeout;\n\tbool reset_action;\n\tu8 rst_state;\n\tint err;\n\n\tfw_reset = container_of(work, struct mlx5_fw_reset, reset_unload_work);\n\tdev = fw_reset->dev;\n\n\tif (mlx5_sync_reset_clear_reset_requested(dev, false))\n\t\treturn;\n\n\tmlx5_core_warn(dev, \"Sync Reset Unload. Function is forced down.\\n\");\n\n\terr = mlx5_cmd_fast_teardown_hca(dev);\n\tif (err)\n\t\tmlx5_core_warn(dev, \"Fast teardown failed, unloading, err %d\\n\", err);\n\telse\n\t\tmlx5_enter_error_state(dev, true);\n\n\tif (test_bit(MLX5_FW_RESET_FLAGS_PENDING_COMP, &fw_reset->reset_flags))\n\t\tmlx5_unload_one_devl_locked(dev, false);\n\telse\n\t\tmlx5_unload_one(dev, false);\n\n\tmlx5_set_fw_rst_ack(dev);\n\tmlx5_core_warn(dev, \"Sync Reset Unload done, device reset expected\\n\");\n\n\treset_action = false;\n\ttimeout = jiffies + msecs_to_jiffies(mlx5_tout_ms(dev, RESET_UNLOAD));\n\tdo {\n\t\trst_state = mlx5_get_fw_rst_state(dev);\n\t\tif (rst_state == MLX5_FW_RST_STATE_TOGGLE_REQ ||\n\t\t    rst_state == MLX5_FW_RST_STATE_IDLE) {\n\t\t\treset_action = true;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t} while (!time_after(jiffies, timeout));\n\n\tif (!reset_action) {\n\t\tmlx5_core_err(dev, \"Got timeout waiting for sync reset action, state = %u\\n\",\n\t\t\t      rst_state);\n\t\tfw_reset->ret = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\tmlx5_core_warn(dev, \"Sync Reset, got reset action. rst_state = %u\\n\", rst_state);\n\tif (rst_state == MLX5_FW_RST_STATE_TOGGLE_REQ) {\n\t\terr = mlx5_pci_link_toggle(dev);\n\t\tif (err) {\n\t\t\tmlx5_core_warn(dev, \"mlx5_pci_link_toggle failed, err %d\\n\", err);\n\t\t\tfw_reset->ret = err;\n\t\t}\n\t}\n\ndone:\n\tmlx5_fw_reset_complete_reload(dev, true);\n}\n\nstatic void mlx5_sync_reset_abort_event(struct work_struct *work)\n{\n\tstruct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,\n\t\t\t\t\t\t      reset_abort_work);\n\tstruct mlx5_core_dev *dev = fw_reset->dev;\n\n\tif (mlx5_sync_reset_clear_reset_requested(dev, true))\n\t\treturn;\n\tmlx5_core_warn(dev, \"PCI Sync FW Update Reset Aborted.\\n\");\n}\n\nstatic void mlx5_sync_reset_events_handle(struct mlx5_fw_reset *fw_reset, struct mlx5_eqe *eqe)\n{\n\tstruct mlx5_eqe_sync_fw_update *sync_fw_update_eqe;\n\tu8 sync_event_rst_type;\n\n\tsync_fw_update_eqe = &eqe->data.sync_fw_update;\n\tsync_event_rst_type = sync_fw_update_eqe->sync_rst_state & SYNC_RST_STATE_MASK;\n\tswitch (sync_event_rst_type) {\n\tcase MLX5_SYNC_RST_STATE_RESET_REQUEST:\n\t\tqueue_work(fw_reset->wq, &fw_reset->reset_request_work);\n\t\tbreak;\n\tcase MLX5_SYNC_RST_STATE_RESET_UNLOAD:\n\t\tqueue_work(fw_reset->wq, &fw_reset->reset_unload_work);\n\t\tbreak;\n\tcase MLX5_SYNC_RST_STATE_RESET_NOW:\n\t\tqueue_work(fw_reset->wq, &fw_reset->reset_now_work);\n\t\tbreak;\n\tcase MLX5_SYNC_RST_STATE_RESET_ABORT:\n\t\tqueue_work(fw_reset->wq, &fw_reset->reset_abort_work);\n\t\tbreak;\n\t}\n}\n\nstatic int fw_reset_event_notifier(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct mlx5_fw_reset *fw_reset = mlx5_nb_cof(nb, struct mlx5_fw_reset, nb);\n\tstruct mlx5_eqe *eqe = data;\n\n\tif (test_bit(MLX5_FW_RESET_FLAGS_DROP_NEW_REQUESTS, &fw_reset->reset_flags))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (eqe->sub_type) {\n\tcase MLX5_GENERAL_SUBTYPE_FW_LIVE_PATCH_EVENT:\n\t\tqueue_work(fw_reset->wq, &fw_reset->fw_live_patch_work);\n\t\tbreak;\n\tcase MLX5_GENERAL_SUBTYPE_PCI_SYNC_FOR_FW_UPDATE_EVENT:\n\t\tmlx5_sync_reset_events_handle(fw_reset, eqe);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nint mlx5_fw_reset_wait_reset_done(struct mlx5_core_dev *dev)\n{\n\tunsigned long pci_sync_update_timeout = mlx5_tout_ms(dev, PCI_SYNC_UPDATE);\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\tunsigned long timeout;\n\tint err;\n\n\tif (MLX5_CAP_GEN(dev, pci_sync_for_fw_update_with_driver_unload))\n\t\tpci_sync_update_timeout += mlx5_tout_ms(dev, RESET_UNLOAD);\n\ttimeout = msecs_to_jiffies(pci_sync_update_timeout);\n\tif (!wait_for_completion_timeout(&fw_reset->done, timeout)) {\n\t\tmlx5_core_warn(dev, \"FW sync reset timeout after %lu seconds\\n\",\n\t\t\t       pci_sync_update_timeout / 1000);\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\terr = fw_reset->ret;\n\tif (test_and_clear_bit(MLX5_FW_RESET_FLAGS_RELOAD_REQUIRED, &fw_reset->reset_flags)) {\n\t\tmlx5_unload_one_devl_locked(dev, false);\n\t\tmlx5_load_one_devl_locked(dev, true);\n\t}\nout:\n\tclear_bit(MLX5_FW_RESET_FLAGS_PENDING_COMP, &fw_reset->reset_flags);\n\treturn err;\n}\n\nvoid mlx5_fw_reset_events_start(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\tMLX5_NB_INIT(&fw_reset->nb, fw_reset_event_notifier, GENERAL_EVENT);\n\tmlx5_eq_notifier_register(dev, &fw_reset->nb);\n}\n\nvoid mlx5_fw_reset_events_stop(struct mlx5_core_dev *dev)\n{\n\tmlx5_eq_notifier_unregister(dev, &dev->priv.fw_reset->nb);\n}\n\nvoid mlx5_drain_fw_reset(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\tset_bit(MLX5_FW_RESET_FLAGS_DROP_NEW_REQUESTS, &fw_reset->reset_flags);\n\tcancel_work_sync(&fw_reset->fw_live_patch_work);\n\tcancel_work_sync(&fw_reset->reset_request_work);\n\tcancel_work_sync(&fw_reset->reset_unload_work);\n\tcancel_work_sync(&fw_reset->reset_reload_work);\n\tcancel_work_sync(&fw_reset->reset_now_work);\n\tcancel_work_sync(&fw_reset->reset_abort_work);\n}\n\nstatic const struct devlink_param mlx5_fw_reset_devlink_params[] = {\n\tDEVLINK_PARAM_GENERIC(ENABLE_REMOTE_DEV_RESET, BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t      mlx5_fw_reset_enable_remote_dev_reset_get,\n\t\t\t      mlx5_fw_reset_enable_remote_dev_reset_set, NULL),\n};\n\nint mlx5_fw_reset_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_reset *fw_reset = kzalloc(sizeof(*fw_reset), GFP_KERNEL);\n\tint err;\n\n\tif (!fw_reset)\n\t\treturn -ENOMEM;\n\tfw_reset->wq = create_singlethread_workqueue(\"mlx5_fw_reset_events\");\n\tif (!fw_reset->wq) {\n\t\tkfree(fw_reset);\n\t\treturn -ENOMEM;\n\t}\n\n\tfw_reset->dev = dev;\n\tdev->priv.fw_reset = fw_reset;\n\n\terr = devl_params_register(priv_to_devlink(dev),\n\t\t\t\t   mlx5_fw_reset_devlink_params,\n\t\t\t\t   ARRAY_SIZE(mlx5_fw_reset_devlink_params));\n\tif (err) {\n\t\tdestroy_workqueue(fw_reset->wq);\n\t\tkfree(fw_reset);\n\t\treturn err;\n\t}\n\n\tINIT_WORK(&fw_reset->fw_live_patch_work, mlx5_fw_live_patch_event);\n\tINIT_WORK(&fw_reset->reset_request_work, mlx5_sync_reset_request_event);\n\tINIT_WORK(&fw_reset->reset_unload_work, mlx5_sync_reset_unload_event);\n\tINIT_WORK(&fw_reset->reset_reload_work, mlx5_sync_reset_reload_work);\n\tINIT_WORK(&fw_reset->reset_now_work, mlx5_sync_reset_now_event);\n\tINIT_WORK(&fw_reset->reset_abort_work, mlx5_sync_reset_abort_event);\n\n\tinit_completion(&fw_reset->done);\n\treturn 0;\n}\n\nvoid mlx5_fw_reset_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;\n\n\tdevl_params_unregister(priv_to_devlink(dev),\n\t\t\t       mlx5_fw_reset_devlink_params,\n\t\t\t       ARRAY_SIZE(mlx5_fw_reset_devlink_params));\n\tdestroy_workqueue(fw_reset->wq);\n\tkfree(dev->priv.fw_reset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}