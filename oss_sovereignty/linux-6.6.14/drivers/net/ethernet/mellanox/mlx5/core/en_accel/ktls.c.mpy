{
  "module_name": "ktls.c",
  "hash_id": "02e37741ba73aea986ba68de01857a163bf83cd36fe9959b3485a1fbfdaeb036",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls.c",
  "human_readable_source": "\n\n\n#include <linux/debugfs.h>\n#include \"en.h\"\n#include \"lib/mlx5.h\"\n#include \"lib/crypto.h\"\n#include \"en_accel/ktls.h\"\n#include \"en_accel/ktls_utils.h\"\n#include \"en_accel/fs_tcp.h\"\n\nstruct mlx5_crypto_dek *mlx5_ktls_create_key(struct mlx5_crypto_dek_pool *dek_pool,\n\t\t\t\t\t     struct tls_crypto_info *crypto_info)\n{\n\tconst void *key;\n\tu32 sz_bytes;\n\n\tswitch (crypto_info->cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128: {\n\t\tstruct tls12_crypto_info_aes_gcm_128 *info =\n\t\t\t(struct tls12_crypto_info_aes_gcm_128 *)crypto_info;\n\n\t\tkey      = info->key;\n\t\tsz_bytes = sizeof(info->key);\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_GCM_256: {\n\t\tstruct tls12_crypto_info_aes_gcm_256 *info =\n\t\t\t(struct tls12_crypto_info_aes_gcm_256 *)crypto_info;\n\n\t\tkey      = info->key;\n\t\tsz_bytes = sizeof(info->key);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn mlx5_crypto_dek_create(dek_pool, key, sz_bytes);\n}\n\nvoid mlx5_ktls_destroy_key(struct mlx5_crypto_dek_pool *dek_pool,\n\t\t\t   struct mlx5_crypto_dek *dek)\n{\n\tmlx5_crypto_dek_destroy(dek_pool, dek);\n}\n\nstatic int mlx5e_ktls_add(struct net_device *netdev, struct sock *sk,\n\t\t\t  enum tls_offload_ctx_dir direction,\n\t\t\t  struct tls_crypto_info *crypto_info,\n\t\t\t  u32 start_offload_tcp_sn)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tint err;\n\n\tif (!mlx5e_ktls_type_check(mdev, crypto_info))\n\t\treturn -EOPNOTSUPP;\n\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX)\n\t\terr = mlx5e_ktls_add_tx(netdev, sk, crypto_info, start_offload_tcp_sn);\n\telse\n\t\terr = mlx5e_ktls_add_rx(netdev, sk, crypto_info, start_offload_tcp_sn);\n\n\treturn err;\n}\n\nstatic void mlx5e_ktls_del(struct net_device *netdev,\n\t\t\t   struct tls_context *tls_ctx,\n\t\t\t   enum tls_offload_ctx_dir direction)\n{\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX)\n\t\tmlx5e_ktls_del_tx(netdev, tls_ctx);\n\telse\n\t\tmlx5e_ktls_del_rx(netdev, tls_ctx);\n}\n\nstatic int mlx5e_ktls_resync(struct net_device *netdev,\n\t\t\t     struct sock *sk, u32 seq, u8 *rcd_sn,\n\t\t\t     enum tls_offload_ctx_dir direction)\n{\n\tif (unlikely(direction != TLS_OFFLOAD_CTX_DIR_RX))\n\t\treturn -EOPNOTSUPP;\n\n\tmlx5e_ktls_rx_resync(netdev, sk, seq, rcd_sn);\n\treturn 0;\n}\n\nstatic const struct tlsdev_ops mlx5e_ktls_ops = {\n\t.tls_dev_add = mlx5e_ktls_add,\n\t.tls_dev_del = mlx5e_ktls_del,\n\t.tls_dev_resync = mlx5e_ktls_resync,\n};\n\nbool mlx5e_is_ktls_rx(struct mlx5_core_dev *mdev)\n{\n\tu8 max_sq_wqebbs = mlx5e_get_max_sq_wqebbs(mdev);\n\n\tif (is_kdump_kernel() || !MLX5_CAP_GEN(mdev, tls_rx))\n\t\treturn false;\n\n\t \n\tif (WARN_ON_ONCE(max_sq_wqebbs < MLX5E_TLS_SET_STATIC_PARAMS_WQEBBS))\n\t\treturn false;\n\tif (WARN_ON_ONCE(max_sq_wqebbs < MLX5E_TLS_SET_PROGRESS_PARAMS_WQEBBS))\n\t\treturn false;\n\tif (WARN_ON_ONCE(max_sq_wqebbs < MLX5E_KTLS_GET_PROGRESS_WQEBBS))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid mlx5e_ktls_build_netdev(struct mlx5e_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\n\tif (!mlx5e_is_ktls_tx(mdev) && !mlx5e_is_ktls_rx(mdev))\n\t\treturn;\n\n\tif (mlx5e_is_ktls_tx(mdev)) {\n\t\tnetdev->hw_features |= NETIF_F_HW_TLS_TX;\n\t\tnetdev->features    |= NETIF_F_HW_TLS_TX;\n\t}\n\n\tif (mlx5e_is_ktls_rx(mdev))\n\t\tnetdev->hw_features |= NETIF_F_HW_TLS_RX;\n\n\tnetdev->tlsdev_ops = &mlx5e_ktls_ops;\n}\n\nint mlx5e_ktls_set_feature_rx(struct net_device *netdev, bool enable)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tint err = 0;\n\n\tmutex_lock(&priv->state_lock);\n\tif (enable)\n\t\terr = mlx5e_accel_fs_tcp_create(priv->fs);\n\telse\n\t\tmlx5e_accel_fs_tcp_destroy(priv->fs);\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\nint mlx5e_ktls_init_rx(struct mlx5e_priv *priv)\n{\n\tint err;\n\n\tif (!mlx5e_is_ktls_rx(priv->mdev))\n\t\treturn 0;\n\n\tpriv->tls->rx_wq = create_singlethread_workqueue(\"mlx5e_tls_rx\");\n\tif (!priv->tls->rx_wq)\n\t\treturn -ENOMEM;\n\n\tif (priv->netdev->features & NETIF_F_HW_TLS_RX) {\n\t\terr = mlx5e_accel_fs_tcp_create(priv->fs);\n\t\tif (err) {\n\t\t\tdestroy_workqueue(priv->tls->rx_wq);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid mlx5e_ktls_cleanup_rx(struct mlx5e_priv *priv)\n{\n\tif (!mlx5e_is_ktls_rx(priv->mdev))\n\t\treturn;\n\n\tif (priv->netdev->features & NETIF_F_HW_TLS_RX)\n\t\tmlx5e_accel_fs_tcp_destroy(priv->fs);\n\n\tdestroy_workqueue(priv->tls->rx_wq);\n}\n\nstatic void mlx5e_tls_debugfs_init(struct mlx5e_tls *tls,\n\t\t\t\t   struct dentry *dfs_root)\n{\n\tif (IS_ERR_OR_NULL(dfs_root))\n\t\treturn;\n\n\ttls->debugfs.dfs = debugfs_create_dir(\"tls\", dfs_root);\n}\n\nint mlx5e_ktls_init(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tls *tls;\n\n\tif (!mlx5e_is_ktls_device(priv->mdev))\n\t\treturn 0;\n\n\ttls = kzalloc(sizeof(*tls), GFP_KERNEL);\n\tif (!tls)\n\t\treturn -ENOMEM;\n\ttls->mdev = priv->mdev;\n\n\tpriv->tls = tls;\n\n\tmlx5e_tls_debugfs_init(tls, priv->dfs_root);\n\n\treturn 0;\n}\n\nvoid mlx5e_ktls_cleanup(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_tls *tls = priv->tls;\n\n\tif (!mlx5e_is_ktls_device(priv->mdev))\n\t\treturn;\n\n\tdebugfs_remove_recursive(tls->debugfs.dfs);\n\ttls->debugfs.dfs = NULL;\n\n\tkfree(priv->tls);\n\tpriv->tls = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}