{
  "module_name": "ingress_ofld.c",
  "hash_id": "000f3f0321311e880de38276adfca2bfd626febecdce2f3171bc7dcfe00ce6b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/acl/ingress_ofld.c",
  "human_readable_source": "\n \n\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"helper.h\"\n#include \"ofld.h\"\n\nstatic bool\nesw_acl_ingress_prio_tag_enabled(struct mlx5_eswitch *esw,\n\t\t\t\t const struct mlx5_vport *vport)\n{\n\treturn (MLX5_CAP_GEN(esw->dev, prio_tag_required) &&\n\t\tmlx5_eswitch_is_vf_vport(esw, vport->vport));\n}\n\nstatic int esw_acl_ingress_prio_tag_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t   struct mlx5_vport *vport)\n{\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\n\t \n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\t \n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.cvlan_tag);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.cvlan_tag, 0);\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH |\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\tflow_act.vlan[0].ethtype = ETH_P_8021Q;\n\tflow_act.vlan[0].vid = 0;\n\tflow_act.vlan[0].prio = 0;\n\n\tif (vport->ingress.offloads.modify_metadata_rule) {\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t\tflow_act.modify_hdr = vport->ingress.offloads.modify_metadata;\n\t}\n\n\tvport->ingress.allow_rule = mlx5_add_flow_rules(vport->ingress.acl, spec,\n\t\t\t\t\t\t\t&flow_act, NULL, 0);\n\tif (IS_ERR(vport->ingress.allow_rule)) {\n\t\terr = PTR_ERR(vport->ingress.allow_rule);\n\t\tesw_warn(esw->dev,\n\t\t\t \"vport[%d] configure ingress untagged allow rule, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tvport->ingress.allow_rule = NULL;\n\t}\n\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic int esw_acl_ingress_mod_metadata_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t       struct mlx5_vport *vport)\n{\n\tu8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tint err = 0;\n\tu32 key;\n\n\tkey = mlx5_eswitch_get_vport_metadata_for_match(esw, vport->vport);\n\tkey >>= ESW_SOURCE_PORT_METADATA_OFFSET;\n\n\tMLX5_SET(set_action_in, action, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, action, field,\n\t\t MLX5_ACTION_IN_FIELD_METADATA_REG_C_0);\n\tMLX5_SET(set_action_in, action, data, key);\n\tMLX5_SET(set_action_in, action, offset,\n\t\t ESW_SOURCE_PORT_METADATA_OFFSET);\n\tMLX5_SET(set_action_in, action, length,\n\t\t ESW_SOURCE_PORT_METADATA_BITS);\n\n\tvport->ingress.offloads.modify_metadata =\n\t\tmlx5_modify_header_alloc(esw->dev, MLX5_FLOW_NAMESPACE_ESW_INGRESS,\n\t\t\t\t\t 1, action);\n\tif (IS_ERR(vport->ingress.offloads.modify_metadata)) {\n\t\terr = PTR_ERR(vport->ingress.offloads.modify_metadata);\n\t\tesw_warn(esw->dev,\n\t\t\t \"failed to alloc modify header for vport %d ingress acl (%d)\\n\",\n\t\t\t vport->vport, err);\n\t\treturn err;\n\t}\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_MOD_HDR | MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\tflow_act.modify_hdr = vport->ingress.offloads.modify_metadata;\n\tflow_act.fg = vport->ingress.offloads.metadata_allmatch_grp;\n\tvport->ingress.offloads.modify_metadata_rule =\n\t\t\t\tmlx5_add_flow_rules(vport->ingress.acl,\n\t\t\t\t\t\t    NULL, &flow_act, NULL, 0);\n\tif (IS_ERR(vport->ingress.offloads.modify_metadata_rule)) {\n\t\terr = PTR_ERR(vport->ingress.offloads.modify_metadata_rule);\n\t\tesw_warn(esw->dev,\n\t\t\t \"failed to add setting metadata rule for vport %d ingress acl, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tmlx5_modify_header_dealloc(esw->dev, vport->ingress.offloads.modify_metadata);\n\t\tvport->ingress.offloads.modify_metadata_rule = NULL;\n\t}\n\treturn err;\n}\n\nstatic void esw_acl_ingress_mod_metadata_destroy(struct mlx5_eswitch *esw,\n\t\t\t\t\t\t struct mlx5_vport *vport)\n{\n\tif (!vport->ingress.offloads.modify_metadata_rule)\n\t\treturn;\n\n\tmlx5_del_flow_rules(vport->ingress.offloads.modify_metadata_rule);\n\tmlx5_modify_header_dealloc(esw->dev, vport->ingress.offloads.modify_metadata);\n\tvport->ingress.offloads.modify_metadata_rule = NULL;\n}\n\nstatic int esw_acl_ingress_src_port_drop_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t\tstruct mlx5_vport *vport)\n{\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *flow_rule;\n\tint err = 0;\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;\n\tflow_act.fg = vport->ingress.offloads.drop_grp;\n\tflow_rule = mlx5_add_flow_rules(vport->ingress.acl, NULL, &flow_act, NULL, 0);\n\tif (IS_ERR(flow_rule)) {\n\t\terr = PTR_ERR(flow_rule);\n\t\tgoto out;\n\t}\n\n\tvport->ingress.offloads.drop_rule = flow_rule;\nout:\n\treturn err;\n}\n\nstatic void esw_acl_ingress_src_port_drop_destroy(struct mlx5_eswitch *esw,\n\t\t\t\t\t\t  struct mlx5_vport *vport)\n{\n\tif (!vport->ingress.offloads.drop_rule)\n\t\treturn;\n\n\tmlx5_del_flow_rules(vport->ingress.offloads.drop_rule);\n\tvport->ingress.offloads.drop_rule = NULL;\n}\n\nstatic int esw_acl_ingress_ofld_rules_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t     struct mlx5_vport *vport)\n{\n\tint err;\n\n\tif (mlx5_eswitch_vport_match_metadata_enabled(esw)) {\n\t\terr = esw_acl_ingress_mod_metadata_create(esw, vport);\n\t\tif (err) {\n\t\t\tesw_warn(esw->dev,\n\t\t\t\t \"vport(%d) create ingress modify metadata, err(%d)\\n\",\n\t\t\t\t vport->vport, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (esw_acl_ingress_prio_tag_enabled(esw, vport)) {\n\t\terr = esw_acl_ingress_prio_tag_create(esw, vport);\n\t\tif (err) {\n\t\t\tesw_warn(esw->dev,\n\t\t\t\t \"vport(%d) create ingress prio tag rule, err(%d)\\n\",\n\t\t\t\t vport->vport, err);\n\t\t\tgoto prio_tag_err;\n\t\t}\n\t}\n\n\treturn 0;\n\nprio_tag_err:\n\tesw_acl_ingress_mod_metadata_destroy(esw, vport);\n\treturn err;\n}\n\nstatic void esw_acl_ingress_ofld_rules_destroy(struct mlx5_eswitch *esw,\n\t\t\t\t\t       struct mlx5_vport *vport)\n{\n\tesw_acl_ingress_allow_rule_destroy(vport);\n\tesw_acl_ingress_mod_metadata_destroy(esw, vport);\n\tesw_acl_ingress_src_port_drop_destroy(esw, vport);\n}\n\nstatic int esw_acl_ingress_ofld_groups_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t      struct mlx5_vport *vport)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *g;\n\tvoid *match_criteria;\n\tu32 *flow_group_in;\n\tu32 flow_index = 0;\n\tint ret = 0;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\tif (vport->vport == MLX5_VPORT_UPLINK) {\n\t\t \n\t\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, flow_index);\n\t\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, flow_index);\n\n\t\tg = mlx5_create_flow_group(vport->ingress.acl, flow_group_in);\n\t\tif (IS_ERR(g)) {\n\t\t\tret = PTR_ERR(g);\n\t\t\tesw_warn(esw->dev, \"vport[%d] ingress create drop flow group, err(%d)\\n\",\n\t\t\t\t vport->vport, ret);\n\t\t\tgoto drop_err;\n\t\t}\n\t\tvport->ingress.offloads.drop_grp = g;\n\t\tflow_index++;\n\t}\n\n\tif (esw_acl_ingress_prio_tag_enabled(esw, vport)) {\n\t\t \n\t\tmemset(flow_group_in, 0, inlen);\n\t\tmatch_criteria = MLX5_ADDR_OF(create_flow_group_in,\n\t\t\t\t\t      flow_group_in, match_criteria);\n\t\tMLX5_SET(create_flow_group_in, flow_group_in,\n\t\t\t match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\t\tMLX5_SET_TO_ONES(fte_match_param, match_criteria, outer_headers.cvlan_tag);\n\t\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, flow_index);\n\t\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, flow_index);\n\n\t\tg = mlx5_create_flow_group(vport->ingress.acl, flow_group_in);\n\t\tif (IS_ERR(g)) {\n\t\t\tret = PTR_ERR(g);\n\t\t\tesw_warn(esw->dev, \"vport[%d] ingress create untagged flow group, err(%d)\\n\",\n\t\t\t\t vport->vport, ret);\n\t\t\tgoto prio_tag_err;\n\t\t}\n\t\tvport->ingress.offloads.metadata_prio_tag_grp = g;\n\t\tflow_index++;\n\t}\n\n\tif (mlx5_eswitch_vport_match_metadata_enabled(esw)) {\n\t\t \n\t\tmemset(flow_group_in, 0, inlen);\n\t\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, flow_index);\n\t\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, flow_index);\n\n\t\tg = mlx5_create_flow_group(vport->ingress.acl, flow_group_in);\n\t\tif (IS_ERR(g)) {\n\t\t\tret = PTR_ERR(g);\n\t\t\tesw_warn(esw->dev, \"vport[%d] ingress create drop flow group, err(%d)\\n\",\n\t\t\t\t vport->vport, ret);\n\t\t\tgoto metadata_err;\n\t\t}\n\t\tvport->ingress.offloads.metadata_allmatch_grp = g;\n\t}\n\n\tkvfree(flow_group_in);\n\treturn 0;\n\nmetadata_err:\n\tif (!IS_ERR_OR_NULL(vport->ingress.offloads.metadata_prio_tag_grp)) {\n\t\tmlx5_destroy_flow_group(vport->ingress.offloads.metadata_prio_tag_grp);\n\t\tvport->ingress.offloads.metadata_prio_tag_grp = NULL;\n\t}\nprio_tag_err:\n\tif (!IS_ERR_OR_NULL(vport->ingress.offloads.drop_grp)) {\n\t\tmlx5_destroy_flow_group(vport->ingress.offloads.drop_grp);\n\t\tvport->ingress.offloads.drop_grp = NULL;\n\t}\ndrop_err:\n\tkvfree(flow_group_in);\n\treturn ret;\n}\n\nstatic void esw_acl_ingress_ofld_groups_destroy(struct mlx5_vport *vport)\n{\n\tif (vport->ingress.offloads.metadata_allmatch_grp) {\n\t\tmlx5_destroy_flow_group(vport->ingress.offloads.metadata_allmatch_grp);\n\t\tvport->ingress.offloads.metadata_allmatch_grp = NULL;\n\t}\n\n\tif (vport->ingress.offloads.metadata_prio_tag_grp) {\n\t\tmlx5_destroy_flow_group(vport->ingress.offloads.metadata_prio_tag_grp);\n\t\tvport->ingress.offloads.metadata_prio_tag_grp = NULL;\n\t}\n\n\tif (vport->ingress.offloads.drop_grp) {\n\t\tmlx5_destroy_flow_group(vport->ingress.offloads.drop_grp);\n\t\tvport->ingress.offloads.drop_grp = NULL;\n\t}\n}\n\nint esw_acl_ingress_ofld_setup(struct mlx5_eswitch *esw,\n\t\t\t       struct mlx5_vport *vport)\n{\n\tint num_ftes = 0;\n\tint err;\n\n\tif (!mlx5_eswitch_vport_match_metadata_enabled(esw) &&\n\t    !esw_acl_ingress_prio_tag_enabled(esw, vport))\n\t\treturn 0;\n\n\tesw_acl_ingress_allow_rule_destroy(vport);\n\n\tif (mlx5_eswitch_vport_match_metadata_enabled(esw))\n\t\tnum_ftes++;\n\tif (vport->vport == MLX5_VPORT_UPLINK)\n\t\tnum_ftes++;\n\tif (esw_acl_ingress_prio_tag_enabled(esw, vport))\n\t\tnum_ftes++;\n\n\tvport->ingress.acl = esw_acl_table_create(esw, vport,\n\t\t\t\t\t\t  MLX5_FLOW_NAMESPACE_ESW_INGRESS,\n\t\t\t\t\t\t  num_ftes);\n\tif (IS_ERR(vport->ingress.acl)) {\n\t\terr = PTR_ERR(vport->ingress.acl);\n\t\tvport->ingress.acl = NULL;\n\t\treturn err;\n\t}\n\n\terr = esw_acl_ingress_ofld_groups_create(esw, vport);\n\tif (err)\n\t\tgoto group_err;\n\n\tesw_debug(esw->dev,\n\t\t  \"vport[%d] configure ingress rules\\n\", vport->vport);\n\n\terr = esw_acl_ingress_ofld_rules_create(esw, vport);\n\tif (err)\n\t\tgoto rules_err;\n\n\treturn 0;\n\nrules_err:\n\tesw_acl_ingress_ofld_groups_destroy(vport);\ngroup_err:\n\tesw_acl_ingress_table_destroy(vport);\n\treturn err;\n}\n\nvoid esw_acl_ingress_ofld_cleanup(struct mlx5_eswitch *esw,\n\t\t\t\t  struct mlx5_vport *vport)\n{\n\tesw_acl_ingress_ofld_rules_destroy(esw, vport);\n\tesw_acl_ingress_ofld_groups_destroy(vport);\n\tesw_acl_ingress_table_destroy(vport);\n}\n\n \nint mlx5_esw_acl_ingress_vport_metadata_update(struct mlx5_eswitch *esw, u16 vport_num,\n\t\t\t\t\t       u32 metadata)\n{\n\tstruct mlx5_vport *vport = mlx5_eswitch_get_vport(esw, vport_num);\n\tint err;\n\n\tif (WARN_ON_ONCE(IS_ERR(vport))) {\n\t\tesw_warn(esw->dev, \"vport(%d) invalid!\\n\", vport_num);\n\t\treturn PTR_ERR(vport);\n\t}\n\n\tesw_acl_ingress_ofld_rules_destroy(esw, vport);\n\n\tvport->metadata = metadata ? metadata : vport->default_metadata;\n\n\t \n\terr = esw_acl_ingress_ofld_rules_create(esw, vport);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tvport->metadata = vport->default_metadata;\n\treturn err;\n}\n\nint mlx5_esw_acl_ingress_vport_drop_rule_create(struct mlx5_eswitch *esw, u16 vport_num)\n{\n\tstruct mlx5_vport *vport = mlx5_eswitch_get_vport(esw, vport_num);\n\n\tif (IS_ERR(vport)) {\n\t\tesw_warn(esw->dev, \"vport(%d) invalid!\\n\", vport_num);\n\t\treturn PTR_ERR(vport);\n\t}\n\n\treturn esw_acl_ingress_src_port_drop_create(esw, vport);\n}\n\nvoid mlx5_esw_acl_ingress_vport_drop_rule_destroy(struct mlx5_eswitch *esw, u16 vport_num)\n{\n\tstruct mlx5_vport *vport = mlx5_eswitch_get_vport(esw, vport_num);\n\n\tif (WARN_ON_ONCE(IS_ERR(vport))) {\n\t\tesw_warn(esw->dev, \"vport(%d) invalid!\\n\", vport_num);\n\t\treturn;\n\t}\n\n\tesw_acl_ingress_src_port_drop_destroy(esw, vport);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}