{
  "module_name": "crdump.c",
  "hash_id": "01b553ce0524d046dab05c0c0b5ca5c4af271491a593a0f05535553cccec0ebb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/diag/crdump.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/driver.h>\n#include \"mlx5_core.h\"\n#include \"lib/pci_vsc.h\"\n#include \"lib/mlx5.h\"\n\n#define BAD_ACCESS\t\t\t0xBADACCE5\n#define MLX5_PROTECTED_CR_SCAN_CRSPACE\t0x7\n\nstatic bool mlx5_crdump_enabled(struct mlx5_core_dev *dev)\n{\n\treturn !!dev->priv.health.crdump_size;\n}\n\nstatic int mlx5_crdump_fill(struct mlx5_core_dev *dev, u32 *cr_data)\n{\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tint i, ret;\n\n\tfor (i = 0; i < (crdump_size / 4); i++)\n\t\tcr_data[i] = BAD_ACCESS;\n\n\tret = mlx5_vsc_gw_read_block_fast(dev, cr_data, crdump_size);\n\tif (ret <= 0) {\n\t\tif (ret == 0)\n\t\t\treturn -EIO;\n\t\treturn ret;\n\t}\n\n\tif (crdump_size != ret) {\n\t\tmlx5_core_warn(dev, \"failed to read full dump, read %d out of %u\\n\",\n\t\t\t       ret, crdump_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint mlx5_crdump_collect(struct mlx5_core_dev *dev, u32 *cr_data)\n{\n\tint ret;\n\n\tif (!mlx5_crdump_enabled(dev))\n\t\treturn -ENODEV;\n\n\tret = mlx5_vsc_gw_lock(dev);\n\tif (ret) {\n\t\tmlx5_core_warn(dev, \"crdump: failed to lock vsc gw err %d\\n\",\n\t\t\t       ret);\n\t\treturn ret;\n\t}\n\t \n\tret = mlx5_vsc_sem_set_space(dev, MLX5_SEMAPHORE_SW_RESET,\n\t\t\t\t     MLX5_VSC_LOCK);\n\tif (ret) {\n\t\tmlx5_core_warn(dev, \"Failed to lock SW reset semaphore\\n\");\n\t\tgoto unlock_gw;\n\t}\n\n\tret = mlx5_vsc_gw_set_space(dev, MLX5_VSC_SPACE_SCAN_CRSPACE, NULL);\n\tif (ret)\n\t\tgoto unlock_sem;\n\n\tret = mlx5_crdump_fill(dev, cr_data);\n\nunlock_sem:\n\tmlx5_vsc_sem_set_space(dev, MLX5_SEMAPHORE_SW_RESET, MLX5_VSC_UNLOCK);\nunlock_gw:\n\tmlx5_vsc_gw_unlock(dev);\n\treturn ret;\n}\n\nint mlx5_crdump_enable(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_priv *priv = &dev->priv;\n\tu32 space_size;\n\tint ret;\n\n\tif (!mlx5_core_is_pf(dev) || !mlx5_vsc_accessible(dev) ||\n\t    mlx5_crdump_enabled(dev))\n\t\treturn 0;\n\n\tret = mlx5_vsc_gw_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mlx5_vsc_gw_set_space(dev, MLX5_VSC_SPACE_SCAN_CRSPACE,\n\t\t\t\t    &space_size);\n\tif (ret) {\n\t\t \n\t\tmlx5_vsc_gw_unlock(dev);\n\t\treturn 0;\n\t}\n\n\tif (!space_size) {\n\t\tmlx5_core_warn(dev, \"Invalid Crspace size, zero\\n\");\n\t\tmlx5_vsc_gw_unlock(dev);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mlx5_vsc_gw_unlock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->health.crdump_size = space_size;\n\treturn 0;\n}\n\nvoid mlx5_crdump_disable(struct mlx5_core_dev *dev)\n{\n\tdev->priv.health.crdump_size = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}