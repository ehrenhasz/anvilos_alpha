{
  "module_name": "mirred.c",
  "hash_id": "0bae5f049f208bb78e3e9aaa58f9d9c3a3ae2a89d4410607545dde0eb8d53853",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred.c",
  "human_readable_source": "\n\n\n#include <linux/if_macvlan.h>\n#include <linux/if_vlan.h>\n#include <net/bareudp.h>\n#include <net/bonding.h>\n#include \"act.h\"\n#include \"vlan.h\"\n#include \"en/tc_tun_encap.h\"\n#include \"en/tc_priv.h\"\n#include \"en_rep.h\"\n#include \"lag/lag.h\"\n\nstatic bool\nsame_vf_reps(struct mlx5e_priv *priv, struct net_device *out_dev)\n{\n\treturn mlx5e_eswitch_vf_rep(priv->netdev) &&\n\t       priv->netdev == out_dev;\n}\n\nstatic int\nverify_uplink_forwarding(struct mlx5e_priv *priv,\n\t\t\t struct mlx5_flow_attr *attr,\n\t\t\t struct net_device *out_dev,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5e_rep_priv *rep_priv;\n\n\t \n\trep_priv = mlx5e_rep_to_rep_priv(attr->esw_attr->in_rep);\n\n\tif (!(mlx5e_eswitch_uplink_rep(rep_priv->netdev) &&\n\t      mlx5e_eswitch_uplink_rep(out_dev)))\n\t\treturn 0;\n\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev,\n\t\t\t\t\ttermination_table_raw_traffic)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"devices are both uplink, can't offload forwarding\");\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (out_dev != rep_priv->netdev) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"devices are not the same uplink, can't offload forwarding\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic bool\nis_duplicated_output_device(struct net_device *dev,\n\t\t\t    struct net_device *out_dev,\n\t\t\t    int *ifindexes, int if_count,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint i;\n\n\tfor (i = 0; i < if_count; i++) {\n\t\tif (ifindexes[i] == out_dev->ifindex) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"can't duplicate output to same device\");\n\t\t\tnetdev_err(dev, \"can't duplicate output to same device: %s\\n\",\n\t\t\t\t   out_dev->name);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct net_device *\nget_fdb_out_dev(struct net_device *uplink_dev, struct net_device *out_dev)\n{\n\tstruct net_device *fdb_out_dev = out_dev;\n\tstruct net_device *uplink_upper;\n\n\trcu_read_lock();\n\tuplink_upper = netdev_master_upper_dev_get_rcu(uplink_dev);\n\tif (uplink_upper && netif_is_lag_master(uplink_upper) &&\n\t    uplink_upper == out_dev) {\n\t\tfdb_out_dev = uplink_dev;\n\t} else if (netif_is_lag_master(out_dev)) {\n\t\tfdb_out_dev = bond_option_active_slave_get_rcu(netdev_priv(out_dev));\n\t\tif (fdb_out_dev &&\n\t\t    (!mlx5e_eswitch_rep(fdb_out_dev) ||\n\t\t     !netdev_port_same_parent_id(fdb_out_dev, uplink_dev)))\n\t\t\tfdb_out_dev = NULL;\n\t}\n\trcu_read_unlock();\n\treturn fdb_out_dev;\n}\n\nstatic bool\ntc_act_can_offload_mirred(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t\t  const struct flow_action_entry *act,\n\t\t\t  int act_index,\n\t\t\t  struct mlx5_flow_attr *attr)\n{\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct mlx5e_tc_flow *flow = parse_state->flow;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tstruct net_device *out_dev = act->dev;\n\tstruct mlx5e_priv *priv = flow->priv;\n\tstruct mlx5_esw_flow_attr *esw_attr;\n\n\tparse_attr = attr->parse_attr;\n\tesw_attr = attr->esw_attr;\n\n\tif (!out_dev) {\n\t\t \n\t\treturn false;\n\t}\n\n\tif (parse_state->mpls_push && !netif_is_bareudp(out_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"mpls is supported only through a bareudp device\");\n\t\treturn false;\n\t}\n\n\tif (parse_state->eth_pop && !parse_state->mpls_push) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"vlan pop eth is supported only with mpls push\");\n\t\treturn false;\n\t}\n\n\tif (flow_flag_test(parse_state->flow, L3_TO_L2_DECAP) && !parse_state->eth_push) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"mpls pop is only supported with vlan eth push\");\n\t\treturn false;\n\t}\n\n\tif (mlx5e_is_ft_flow(flow) && out_dev == priv->netdev) {\n\t\t \n\t\treturn false;\n\t}\n\n\tif (esw_attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"can't support more output ports, can't offload forwarding\");\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"can't support more than %d output ports, can't offload forwarding\\n\",\n\t\t\t    esw_attr->out_count);\n\t\treturn false;\n\t}\n\n\tif (parse_state->encap ||\n\t    netdev_port_same_parent_id(priv->netdev, out_dev) ||\n\t    netif_is_ovs_master(out_dev))\n\t\treturn true;\n\n\tif (parse_attr->filter_dev != priv->netdev) {\n\t\t \n\t\treturn false;\n\t}\n\n\tNL_SET_ERR_MSG_MOD(extack, \"devices are not on same switch HW, can't offload forwarding\");\n\n\treturn false;\n}\n\nstatic int\nparse_mirred_encap(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t   const struct flow_action_entry *act,\n\t\t   struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct net_device *out_dev = act->dev;\n\n\tparse_attr->mirred_ifindex[esw_attr->out_count] = out_dev->ifindex;\n\tparse_attr->tun_info[esw_attr->out_count] =\n\t\tmlx5e_dup_tun_info(parse_state->tun_info);\n\n\tif (!parse_attr->tun_info[esw_attr->out_count])\n\t\treturn -ENOMEM;\n\n\tparse_state->encap = false;\n\n\tif (parse_state->mpls_push) {\n\t\tmemcpy(&parse_attr->mpls_info[esw_attr->out_count],\n\t\t       &parse_state->mpls_info, sizeof(parse_state->mpls_info));\n\t\tparse_state->mpls_push = false;\n\t}\n\tesw_attr->dests[esw_attr->out_count].flags |= MLX5_ESW_DEST_ENCAP;\n\tesw_attr->out_count++;\n\t \n\n\treturn 0;\n}\n\nstatic int\nparse_mirred(struct mlx5e_tc_act_parse_state *parse_state,\n\t     const struct flow_action_entry *act,\n\t     struct mlx5e_priv *priv,\n\t     struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct netlink_ext_ack *extack = parse_state->extack;\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct net_device *out_dev = act->dev;\n\tstruct net_device *uplink_dev;\n\tstruct mlx5e_priv *out_priv;\n\tstruct mlx5_eswitch *esw;\n\tint *ifindexes;\n\tint if_count;\n\tint err;\n\n\tesw = priv->mdev->priv.eswitch;\n\tuplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);\n\tifindexes = parse_state->ifindexes;\n\tif_count = parse_state->if_count;\n\n\tif (is_duplicated_output_device(priv->netdev, out_dev, ifindexes, if_count, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tparse_state->ifindexes[if_count] = out_dev->ifindex;\n\tparse_state->if_count++;\n\n\tif (mlx5_lag_mpesw_do_mirred(priv->mdev, out_dev, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tif (netif_is_macvlan(out_dev))\n\t\tout_dev = macvlan_dev_real_dev(out_dev);\n\n\tout_dev = get_fdb_out_dev(uplink_dev, out_dev);\n\tif (!out_dev)\n\t\treturn -ENODEV;\n\n\tif (is_vlan_dev(out_dev)) {\n\t\terr = mlx5e_tc_act_vlan_add_push_action(priv, attr, &out_dev, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (is_vlan_dev(parse_attr->filter_dev)) {\n\t\terr = mlx5e_tc_act_vlan_add_pop_action(priv, attr, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = verify_uplink_forwarding(priv, attr, out_dev, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!mlx5e_is_valid_eswitch_fwd_dev(priv, out_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"devices are not on same switch HW, can't offload forwarding\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (same_vf_reps(priv, out_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"can't forward from a VF to itself\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tout_priv = netdev_priv(out_dev);\n\trpriv = out_priv->ppriv;\n\tesw_attr->dests[esw_attr->out_count].vport_valid = true;\n\tesw_attr->dests[esw_attr->out_count].vport = rpriv->rep->vport;\n\tesw_attr->dests[esw_attr->out_count].mdev = out_priv->mdev;\n\n\tesw_attr->out_count++;\n\n\treturn 0;\n}\n\nstatic int\nparse_mirred_ovs_master(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t\tconst struct flow_action_entry *act,\n\t\t\tstruct mlx5e_priv *priv,\n\t\t\tstruct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct net_device *out_dev = act->dev;\n\tint err;\n\n\terr = mlx5e_set_fwd_to_int_port_actions(priv, attr, out_dev->ifindex,\n\t\t\t\t\t\tMLX5E_TC_INT_PORT_EGRESS,\n\t\t\t\t\t\t&attr->action, esw_attr->out_count);\n\tif (err)\n\t\treturn err;\n\n\tparse_state->if_count = 0;\n\tesw_attr->out_count++;\n\treturn 0;\n}\n\nstatic int\ntc_act_parse_mirred(struct mlx5e_tc_act_parse_state *parse_state,\n\t\t    const struct flow_action_entry *act,\n\t\t    struct mlx5e_priv *priv,\n\t\t    struct mlx5_flow_attr *attr)\n{\n\tstruct net_device *out_dev = act->dev;\n\tint err = -EOPNOTSUPP;\n\n\tif (parse_state->encap)\n\t\terr = parse_mirred_encap(parse_state, act, attr);\n\telse if (netdev_port_same_parent_id(priv->netdev, out_dev))\n\t\terr = parse_mirred(parse_state, act, priv, attr);\n\telse if (netif_is_ovs_master(out_dev))\n\t\terr = parse_mirred_ovs_master(parse_state, act, priv, attr);\n\n\tif (err)\n\t\treturn err;\n\n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\n\treturn 0;\n}\n\nstruct mlx5e_tc_act mlx5e_tc_act_mirred = {\n\t.can_offload = tc_act_can_offload_mirred,\n\t.parse_action = tc_act_parse_mirred,\n\t.is_terminating_action = false,\n};\n\nstruct mlx5e_tc_act mlx5e_tc_act_redirect = {\n\t.can_offload = tc_act_can_offload_mirred,\n\t.parse_action = tc_act_parse_mirred,\n\t.is_terminating_action = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}