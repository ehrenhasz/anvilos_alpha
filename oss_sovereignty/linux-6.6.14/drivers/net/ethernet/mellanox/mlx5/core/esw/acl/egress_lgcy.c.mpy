{
  "module_name": "egress_lgcy.c",
  "hash_id": "a87c701f85b0f362cde00b0c156f2aa3860ae70d33a8a334498153c1ef97d92d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/acl/egress_lgcy.c",
  "human_readable_source": "\n \n\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"helper.h\"\n#include \"lgcy.h\"\n\nstatic void esw_acl_egress_lgcy_rules_destroy(struct mlx5_vport *vport)\n{\n\tesw_acl_egress_vlan_destroy(vport);\n\tif (!IS_ERR_OR_NULL(vport->egress.legacy.drop_rule)) {\n\t\tmlx5_del_flow_rules(vport->egress.legacy.drop_rule);\n\t\tvport->egress.legacy.drop_rule = NULL;\n\t}\n}\n\nstatic int esw_acl_egress_lgcy_groups_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t     struct mlx5_vport *vport)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_group *drop_grp;\n\tu32 *flow_group_in;\n\tint err = 0;\n\n\terr = esw_acl_egress_vlan_grp_create(esw, vport);\n\tif (err)\n\t\treturn err;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in) {\n\t\terr = -ENOMEM;\n\t\tgoto alloc_err;\n\t}\n\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 1);\n\tdrop_grp = mlx5_create_flow_group(vport->egress.acl, flow_group_in);\n\tif (IS_ERR(drop_grp)) {\n\t\terr = PTR_ERR(drop_grp);\n\t\tesw_warn(dev, \"Failed to create E-Switch vport[%d] egress drop flow group, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tgoto drop_grp_err;\n\t}\n\n\tvport->egress.legacy.drop_grp = drop_grp;\n\tkvfree(flow_group_in);\n\treturn 0;\n\ndrop_grp_err:\n\tkvfree(flow_group_in);\nalloc_err:\n\tesw_acl_egress_vlan_grp_destroy(vport);\n\treturn err;\n}\n\nstatic void esw_acl_egress_lgcy_groups_destroy(struct mlx5_vport *vport)\n{\n\tif (!IS_ERR_OR_NULL(vport->egress.legacy.drop_grp)) {\n\t\tmlx5_destroy_flow_group(vport->egress.legacy.drop_grp);\n\t\tvport->egress.legacy.drop_grp = NULL;\n\t}\n\tesw_acl_egress_vlan_grp_destroy(vport);\n}\n\nint esw_acl_egress_lgcy_setup(struct mlx5_eswitch *esw,\n\t\t\t      struct mlx5_vport *vport)\n{\n\tbool vst_mode_steering = esw_vst_mode_is_steering(esw);\n\tstruct mlx5_flow_destination drop_ctr_dst = {};\n\tstruct mlx5_flow_destination *dst = NULL;\n\tstruct mlx5_fc *drop_counter = NULL;\n\tstruct mlx5_flow_act flow_act = {};\n\t \n\tint table_size = 2;\n\tint dest_num = 0;\n\tint actions_flag;\n\tint err = 0;\n\n\tif (vport->egress.legacy.drop_counter) {\n\t\tdrop_counter = vport->egress.legacy.drop_counter;\n\t} else if (MLX5_CAP_ESW_EGRESS_ACL(esw->dev, flow_counter)) {\n\t\tdrop_counter = mlx5_fc_create(esw->dev, false);\n\t\tif (IS_ERR(drop_counter)) {\n\t\t\tesw_warn(esw->dev,\n\t\t\t\t \"vport[%d] configure egress drop rule counter err(%ld)\\n\",\n\t\t\t\t vport->vport, PTR_ERR(drop_counter));\n\t\t\tdrop_counter = NULL;\n\t\t}\n\t\tvport->egress.legacy.drop_counter = drop_counter;\n\t}\n\n\tesw_acl_egress_lgcy_rules_destroy(vport);\n\n\tif (!vport->info.vlan && !vport->info.qos) {\n\t\tesw_acl_egress_lgcy_cleanup(esw, vport);\n\t\treturn 0;\n\t}\n\n\tif (!vport->egress.acl) {\n\t\tvport->egress.acl = esw_acl_table_create(esw, vport,\n\t\t\t\t\t\t\t MLX5_FLOW_NAMESPACE_ESW_EGRESS,\n\t\t\t\t\t\t\t table_size);\n\t\tif (IS_ERR(vport->egress.acl)) {\n\t\t\terr = PTR_ERR(vport->egress.acl);\n\t\t\tvport->egress.acl = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = esw_acl_egress_lgcy_groups_create(esw, vport);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tesw_debug(esw->dev,\n\t\t  \"vport[%d] configure egress rules, vlan(%d) qos(%d)\\n\",\n\t\t  vport->vport, vport->info.vlan, vport->info.qos);\n\n\t \n\tactions_flag = MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\tif (vst_mode_steering)\n\t\tactions_flag |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;\n\terr = esw_egress_acl_vlan_create(esw, vport, NULL, vport->info.vlan,\n\t\t\t\t\t actions_flag);\n\tif (err)\n\t\tgoto out;\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;\n\n\t \n\tif (drop_counter) {\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\tdrop_ctr_dst.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\t\tdrop_ctr_dst.counter_id = mlx5_fc_id(drop_counter);\n\t\tdst = &drop_ctr_dst;\n\t\tdest_num++;\n\t}\n\tvport->egress.legacy.drop_rule =\n\t\tmlx5_add_flow_rules(vport->egress.acl, NULL,\n\t\t\t\t    &flow_act, dst, dest_num);\n\tif (IS_ERR(vport->egress.legacy.drop_rule)) {\n\t\terr = PTR_ERR(vport->egress.legacy.drop_rule);\n\t\tesw_warn(esw->dev,\n\t\t\t \"vport[%d] configure egress drop rule failed, err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tvport->egress.legacy.drop_rule = NULL;\n\t\tgoto out;\n\t}\n\n\treturn err;\n\nout:\n\tesw_acl_egress_lgcy_cleanup(esw, vport);\n\treturn err;\n}\n\nvoid esw_acl_egress_lgcy_cleanup(struct mlx5_eswitch *esw,\n\t\t\t\t struct mlx5_vport *vport)\n{\n\tif (IS_ERR_OR_NULL(vport->egress.acl))\n\t\tgoto clean_drop_counter;\n\n\tesw_debug(esw->dev, \"Destroy vport[%d] E-Switch egress ACL\\n\", vport->vport);\n\n\tesw_acl_egress_lgcy_rules_destroy(vport);\n\tesw_acl_egress_lgcy_groups_destroy(vport);\n\tesw_acl_egress_table_destroy(vport);\n\nclean_drop_counter:\n\tif (vport->egress.legacy.drop_counter) {\n\t\tmlx5_fc_destroy(esw->dev, vport->egress.legacy.drop_counter);\n\t\tvport->egress.legacy.drop_counter = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}