{
  "module_name": "mapping.c",
  "hash_id": "f139daf2a29a0342a26f1d94b0e795f9c0f450a69aa2286f2e7dbfba5cea4388",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/mapping.c",
  "human_readable_source": "\n \n\n#include <linux/jhash.h>\n#include <linux/slab.h>\n#include <linux/xarray.h>\n#include <linux/hashtable.h>\n#include <linux/refcount.h>\n\n#include \"mapping.h\"\n\n#define MAPPING_GRACE_PERIOD 2000\n\nstatic LIST_HEAD(shared_ctx_list);\nstatic DEFINE_MUTEX(shared_ctx_lock);\n\nstruct mapping_ctx {\n\tstruct xarray xarray;\n\tDECLARE_HASHTABLE(ht, 8);\n\tstruct mutex lock;  \n\tunsigned long max_id;\n\tsize_t data_size;\n\tbool delayed_removal;\n\tstruct delayed_work dwork;\n\tstruct list_head pending_list;\n\tspinlock_t pending_list_lock;  \n\tu64 id;\n\tu8 type;\n\tstruct list_head list;\n\trefcount_t refcount;\n};\n\nstruct mapping_item {\n\tstruct rcu_head rcu;\n\tstruct list_head list;\n\tunsigned long timeout;\n\tstruct hlist_node node;\n\tint cnt;\n\tu32 id;\n\tchar data[];\n};\n\nint mapping_add(struct mapping_ctx *ctx, void *data, u32 *id)\n{\n\tstruct mapping_item *mi;\n\tint err = -ENOMEM;\n\tu32 hash_key;\n\n\tmutex_lock(&ctx->lock);\n\n\thash_key = jhash(data, ctx->data_size, 0);\n\thash_for_each_possible(ctx->ht, mi, node, hash_key) {\n\t\tif (!memcmp(data, mi->data, ctx->data_size))\n\t\t\tgoto attach;\n\t}\n\n\tmi = kzalloc(sizeof(*mi) + ctx->data_size, GFP_KERNEL);\n\tif (!mi)\n\t\tgoto err_alloc;\n\n\tmemcpy(mi->data, data, ctx->data_size);\n\thash_add(ctx->ht, &mi->node, hash_key);\n\n\terr = xa_alloc(&ctx->xarray, &mi->id, mi, XA_LIMIT(1, ctx->max_id),\n\t\t       GFP_KERNEL);\n\tif (err)\n\t\tgoto err_assign;\nattach:\n\t++mi->cnt;\n\t*id = mi->id;\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn 0;\n\nerr_assign:\n\thash_del(&mi->node);\n\tkfree(mi);\nerr_alloc:\n\tmutex_unlock(&ctx->lock);\n\n\treturn err;\n}\n\nstatic void mapping_remove_and_free(struct mapping_ctx *ctx,\n\t\t\t\t    struct mapping_item *mi)\n{\n\txa_erase(&ctx->xarray, mi->id);\n\tkfree_rcu(mi, rcu);\n}\n\nstatic void mapping_free_item(struct mapping_ctx *ctx,\n\t\t\t      struct mapping_item *mi)\n{\n\tif (!ctx->delayed_removal) {\n\t\tmapping_remove_and_free(ctx, mi);\n\t\treturn;\n\t}\n\n\tmi->timeout = jiffies + msecs_to_jiffies(MAPPING_GRACE_PERIOD);\n\n\tspin_lock(&ctx->pending_list_lock);\n\tlist_add_tail(&mi->list, &ctx->pending_list);\n\tspin_unlock(&ctx->pending_list_lock);\n\n\tschedule_delayed_work(&ctx->dwork, MAPPING_GRACE_PERIOD);\n}\n\nint mapping_remove(struct mapping_ctx *ctx, u32 id)\n{\n\tunsigned long index = id;\n\tstruct mapping_item *mi;\n\tint err = -ENOENT;\n\n\tmutex_lock(&ctx->lock);\n\tmi = xa_load(&ctx->xarray, index);\n\tif (!mi)\n\t\tgoto out;\n\terr = 0;\n\n\tif (--mi->cnt > 0)\n\t\tgoto out;\n\n\thash_del(&mi->node);\n\tmapping_free_item(ctx, mi);\nout:\n\tmutex_unlock(&ctx->lock);\n\n\treturn err;\n}\n\nint mapping_find(struct mapping_ctx *ctx, u32 id, void *data)\n{\n\tunsigned long index = id;\n\tstruct mapping_item *mi;\n\tint err = -ENOENT;\n\n\trcu_read_lock();\n\tmi = xa_load(&ctx->xarray, index);\n\tif (!mi)\n\t\tgoto err_find;\n\n\tmemcpy(data, mi->data, ctx->data_size);\n\terr = 0;\n\nerr_find:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic void\nmapping_remove_and_free_list(struct mapping_ctx *ctx, struct list_head *list)\n{\n\tstruct mapping_item *mi;\n\n\tlist_for_each_entry(mi, list, list)\n\t\tmapping_remove_and_free(ctx, mi);\n}\n\nstatic void mapping_work_handler(struct work_struct *work)\n{\n\tunsigned long min_timeout = 0, now = jiffies;\n\tstruct mapping_item *mi, *next;\n\tLIST_HEAD(pending_items);\n\tstruct mapping_ctx *ctx;\n\n\tctx = container_of(work, struct mapping_ctx, dwork.work);\n\n\tspin_lock(&ctx->pending_list_lock);\n\tlist_for_each_entry_safe(mi, next, &ctx->pending_list, list) {\n\t\tif (time_after(now, mi->timeout))\n\t\t\tlist_move(&mi->list, &pending_items);\n\t\telse if (!min_timeout ||\n\t\t\t time_before(mi->timeout, min_timeout))\n\t\t\tmin_timeout = mi->timeout;\n\t}\n\tspin_unlock(&ctx->pending_list_lock);\n\n\tmapping_remove_and_free_list(ctx, &pending_items);\n\n\tif (min_timeout)\n\t\tschedule_delayed_work(&ctx->dwork, abs(min_timeout - now));\n}\n\nstatic void mapping_flush_work(struct mapping_ctx *ctx)\n{\n\tif (!ctx->delayed_removal)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&ctx->dwork);\n\tmapping_remove_and_free_list(ctx, &ctx->pending_list);\n}\n\nstruct mapping_ctx *\nmapping_create(size_t data_size, u32 max_id, bool delayed_removal)\n{\n\tstruct mapping_ctx *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->max_id = max_id ? max_id : UINT_MAX;\n\tctx->data_size = data_size;\n\n\tif (delayed_removal) {\n\t\tINIT_DELAYED_WORK(&ctx->dwork, mapping_work_handler);\n\t\tINIT_LIST_HEAD(&ctx->pending_list);\n\t\tspin_lock_init(&ctx->pending_list_lock);\n\t\tctx->delayed_removal = true;\n\t}\n\n\tmutex_init(&ctx->lock);\n\txa_init_flags(&ctx->xarray, XA_FLAGS_ALLOC1);\n\n\trefcount_set(&ctx->refcount, 1);\n\tINIT_LIST_HEAD(&ctx->list);\n\n\treturn ctx;\n}\n\nstruct mapping_ctx *\nmapping_create_for_id(u64 id, u8 type, size_t data_size, u32 max_id, bool delayed_removal)\n{\n\tstruct mapping_ctx *ctx;\n\n\tmutex_lock(&shared_ctx_lock);\n\tlist_for_each_entry(ctx, &shared_ctx_list, list) {\n\t\tif (ctx->id == id && ctx->type == type) {\n\t\t\tif (refcount_inc_not_zero(&ctx->refcount))\n\t\t\t\tgoto unlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx = mapping_create(data_size, max_id, delayed_removal);\n\tif (IS_ERR(ctx))\n\t\tgoto unlock;\n\n\tctx->id = id;\n\tctx->type = type;\n\tlist_add(&ctx->list, &shared_ctx_list);\n\nunlock:\n\tmutex_unlock(&shared_ctx_lock);\n\treturn ctx;\n}\n\nvoid mapping_destroy(struct mapping_ctx *ctx)\n{\n\tif (!refcount_dec_and_test(&ctx->refcount))\n\t\treturn;\n\n\tmutex_lock(&shared_ctx_lock);\n\tlist_del(&ctx->list);\n\tmutex_unlock(&shared_ctx_lock);\n\n\tmapping_flush_work(ctx);\n\txa_destroy(&ctx->xarray);\n\tmutex_destroy(&ctx->lock);\n\n\tkfree(ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}