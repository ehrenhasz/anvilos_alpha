{
  "module_name": "vport.c",
  "hash_id": "780339175278407bb01fb156a53b70eeff776044a0fdfd36b76aef0349e47bf2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/vport.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/etherdevice.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/vport.h>\n#include <linux/mlx5/eswitch.h>\n#include \"mlx5_core.h\"\n#include \"sf/sf.h\"\n\n \nstatic DEFINE_MUTEX(mlx5_roce_en_lock);\n\nu8 mlx5_query_vport_state(struct mlx5_core_dev *mdev, u8 opmod, u16 vport)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_vport_state_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_vport_state_in)] = {};\n\tint err;\n\n\tMLX5_SET(query_vport_state_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_VPORT_STATE);\n\tMLX5_SET(query_vport_state_in, in, op_mod, opmod);\n\tMLX5_SET(query_vport_state_in, in, vport_number, vport);\n\tif (vport)\n\t\tMLX5_SET(query_vport_state_in, in, other_vport, 1);\n\n\terr = mlx5_cmd_exec_inout(mdev, query_vport_state, in, out);\n\tif (err)\n\t\treturn 0;\n\n\treturn MLX5_GET(query_vport_state_out, out, state);\n}\n\nint mlx5_modify_vport_admin_state(struct mlx5_core_dev *mdev, u8 opmod,\n\t\t\t\t  u16 vport, u8 other_vport, u8 state)\n{\n\tu32 in[MLX5_ST_SZ_DW(modify_vport_state_in)] = {};\n\n\tMLX5_SET(modify_vport_state_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_VPORT_STATE);\n\tMLX5_SET(modify_vport_state_in, in, op_mod, opmod);\n\tMLX5_SET(modify_vport_state_in, in, vport_number, vport);\n\tMLX5_SET(modify_vport_state_in, in, other_vport, other_vport);\n\tMLX5_SET(modify_vport_state_in, in, admin_state, state);\n\n\treturn mlx5_cmd_exec_in(mdev, modify_vport_state, in);\n}\n\nstatic int mlx5_query_nic_vport_context(struct mlx5_core_dev *mdev, u16 vport,\n\t\t\t\t\tu32 *out)\n{\n\tu32 in[MLX5_ST_SZ_DW(query_nic_vport_context_in)] = {};\n\n\tMLX5_SET(query_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_NIC_VPORT_CONTEXT);\n\tMLX5_SET(query_nic_vport_context_in, in, vport_number, vport);\n\tif (vport)\n\t\tMLX5_SET(query_nic_vport_context_in, in, other_vport, 1);\n\n\treturn mlx5_cmd_exec_inout(mdev, query_nic_vport_context, in, out);\n}\n\nint mlx5_query_nic_vport_min_inline(struct mlx5_core_dev *mdev,\n\t\t\t\t    u16 vport, u8 *min_inline)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_nic_vport_context_out)] = {};\n\tint err;\n\n\terr = mlx5_query_nic_vport_context(mdev, vport, out);\n\tif (!err)\n\t\t*min_inline = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t\t       nic_vport_context.min_wqe_inline_mode);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_min_inline);\n\nvoid mlx5_query_min_inline(struct mlx5_core_dev *mdev,\n\t\t\t   u8 *min_inline_mode)\n{\n\tswitch (MLX5_CAP_ETH(mdev, wqe_inline_mode)) {\n\tcase MLX5_CAP_INLINE_MODE_VPORT_CONTEXT:\n\t\tif (!mlx5_query_nic_vport_min_inline(mdev, 0, min_inline_mode))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase MLX5_CAP_INLINE_MODE_L2:\n\t\t*min_inline_mode = MLX5_INLINE_MODE_L2;\n\t\tbreak;\n\tcase MLX5_CAP_INLINE_MODE_NOT_REQUIRED:\n\t\t*min_inline_mode = MLX5_INLINE_MODE_NONE;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mlx5_query_min_inline);\n\nint mlx5_modify_nic_vport_min_inline(struct mlx5_core_dev *mdev,\n\t\t\t\t     u16 vport, u8 min_inline)\n{\n\tu32 in[MLX5_ST_SZ_DW(modify_nic_vport_context_in)] = {};\n\tvoid *nic_vport_ctx;\n\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t field_select.min_inline, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in, vport_number, vport);\n\tMLX5_SET(modify_nic_vport_context_in, in, other_vport, 1);\n\n\tnic_vport_ctx = MLX5_ADDR_OF(modify_nic_vport_context_in,\n\t\t\t\t     in, nic_vport_context);\n\tMLX5_SET(nic_vport_context, nic_vport_ctx,\n\t\t min_wqe_inline_mode, min_inline);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\treturn mlx5_cmd_exec_in(mdev, modify_nic_vport_context, in);\n}\n\nint mlx5_query_nic_vport_mac_address(struct mlx5_core_dev *mdev,\n\t\t\t\t     u16 vport, bool other, u8 *addr)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_nic_vport_context_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_nic_vport_context_in)] = {};\n\tu8 *out_addr;\n\tint err;\n\n\tout_addr = MLX5_ADDR_OF(query_nic_vport_context_out, out,\n\t\t\t\tnic_vport_context.permanent_address);\n\n\tMLX5_SET(query_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_NIC_VPORT_CONTEXT);\n\tMLX5_SET(query_nic_vport_context_in, in, vport_number, vport);\n\tMLX5_SET(query_nic_vport_context_in, in, other_vport, other);\n\n\terr = mlx5_cmd_exec_inout(mdev, query_nic_vport_context, in, out);\n\tif (!err)\n\t\tether_addr_copy(addr, &out_addr[2]);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_mac_address);\n\nint mlx5_query_mac_address(struct mlx5_core_dev *mdev, u8 *addr)\n{\n\treturn mlx5_query_nic_vport_mac_address(mdev, 0, false, addr);\n}\nEXPORT_SYMBOL_GPL(mlx5_query_mac_address);\n\nint mlx5_modify_nic_vport_mac_address(struct mlx5_core_dev *mdev,\n\t\t\t\t      u16 vport, const u8 *addr)\n{\n\tvoid *in;\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tint err;\n\tvoid *nic_vport_ctx;\n\tu8 *perm_mac;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t field_select.permanent_address, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in, vport_number, vport);\n\tMLX5_SET(modify_nic_vport_context_in, in, other_vport, 1);\n\n\tnic_vport_ctx = MLX5_ADDR_OF(modify_nic_vport_context_in,\n\t\t\t\t     in, nic_vport_context);\n\tperm_mac = MLX5_ADDR_OF(nic_vport_context, nic_vport_ctx,\n\t\t\t\tpermanent_address);\n\n\tether_addr_copy(&perm_mac[2], addr);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(mdev, modify_nic_vport_context, in);\n\n\tkvfree(in);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_mac_address);\n\nint mlx5_query_nic_vport_mtu(struct mlx5_core_dev *mdev, u16 *mtu)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);\n\tu32 *out;\n\tint err;\n\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_nic_vport_context(mdev, 0, out);\n\tif (!err)\n\t\t*mtu = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t\tnic_vport_context.mtu);\n\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_mtu);\n\nint mlx5_modify_nic_vport_mtu(struct mlx5_core_dev *mdev, u16 mtu)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tvoid *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in, field_select.mtu, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in, nic_vport_context.mtu, mtu);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(mdev, modify_nic_vport_context, in);\n\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_mtu);\n\nint mlx5_query_nic_vport_mac_list(struct mlx5_core_dev *dev,\n\t\t\t\t  u16 vport,\n\t\t\t\t  enum mlx5_list_type list_type,\n\t\t\t\t  u8 addr_list[][ETH_ALEN],\n\t\t\t\t  int *list_size)\n{\n\tu32 in[MLX5_ST_SZ_DW(query_nic_vport_context_in)] = {0};\n\tvoid *nic_vport_ctx;\n\tint max_list_size;\n\tint req_list_size;\n\tint out_sz;\n\tvoid *out;\n\tint err;\n\tint i;\n\n\treq_list_size = *list_size;\n\n\tmax_list_size = list_type == MLX5_NVPRT_LIST_TYPE_UC ?\n\t\t1 << MLX5_CAP_GEN(dev, log_max_current_uc_list) :\n\t\t1 << MLX5_CAP_GEN(dev, log_max_current_mc_list);\n\n\tif (req_list_size > max_list_size) {\n\t\tmlx5_core_warn(dev, \"Requested list size (%d) > (%d) max_list_size\\n\",\n\t\t\t       req_list_size, max_list_size);\n\t\treq_list_size = max_list_size;\n\t}\n\n\tout_sz = MLX5_ST_SZ_BYTES(query_nic_vport_context_out) +\n\t\t\treq_list_size * MLX5_ST_SZ_BYTES(mac_address_layout);\n\n\tout = kvzalloc(out_sz, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(query_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_NIC_VPORT_CONTEXT);\n\tMLX5_SET(query_nic_vport_context_in, in, allowed_list_type, list_type);\n\tMLX5_SET(query_nic_vport_context_in, in, vport_number, vport);\n\tif (vport || mlx5_core_is_ecpf(dev))\n\t\tMLX5_SET(query_nic_vport_context_in, in, other_vport, 1);\n\n\terr = mlx5_cmd_exec(dev, in, sizeof(in), out, out_sz);\n\tif (err)\n\t\tgoto out;\n\n\tnic_vport_ctx = MLX5_ADDR_OF(query_nic_vport_context_out, out,\n\t\t\t\t     nic_vport_context);\n\treq_list_size = MLX5_GET(nic_vport_context, nic_vport_ctx,\n\t\t\t\t allowed_list_size);\n\n\t*list_size = req_list_size;\n\tfor (i = 0; i < req_list_size; i++) {\n\t\tu8 *mac_addr = MLX5_ADDR_OF(nic_vport_context,\n\t\t\t\t\tnic_vport_ctx,\n\t\t\t\t\tcurrent_uc_mac_address[i]) + 2;\n\t\tether_addr_copy(addr_list[i], mac_addr);\n\t}\nout:\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_mac_list);\n\nint mlx5_modify_nic_vport_mac_list(struct mlx5_core_dev *dev,\n\t\t\t\t   enum mlx5_list_type list_type,\n\t\t\t\t   u8 addr_list[][ETH_ALEN],\n\t\t\t\t   int list_size)\n{\n\tu32 out[MLX5_ST_SZ_DW(modify_nic_vport_context_out)] = {};\n\tvoid *nic_vport_ctx;\n\tint max_list_size;\n\tint in_sz;\n\tvoid *in;\n\tint err;\n\tint i;\n\n\tmax_list_size = list_type == MLX5_NVPRT_LIST_TYPE_UC ?\n\t\t 1 << MLX5_CAP_GEN(dev, log_max_current_uc_list) :\n\t\t 1 << MLX5_CAP_GEN(dev, log_max_current_mc_list);\n\n\tif (list_size > max_list_size)\n\t\treturn -ENOSPC;\n\n\tin_sz = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in) +\n\t\tlist_size * MLX5_ST_SZ_BYTES(mac_address_layout);\n\n\tin = kvzalloc(in_sz, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t field_select.addresses_list, 1);\n\n\tnic_vport_ctx = MLX5_ADDR_OF(modify_nic_vport_context_in, in,\n\t\t\t\t     nic_vport_context);\n\n\tMLX5_SET(nic_vport_context, nic_vport_ctx,\n\t\t allowed_list_type, list_type);\n\tMLX5_SET(nic_vport_context, nic_vport_ctx,\n\t\t allowed_list_size, list_size);\n\n\tfor (i = 0; i < list_size; i++) {\n\t\tu8 *curr_mac = MLX5_ADDR_OF(nic_vport_context,\n\t\t\t\t\t    nic_vport_ctx,\n\t\t\t\t\t    current_uc_mac_address[i]) + 2;\n\t\tether_addr_copy(curr_mac, addr_list[i]);\n\t}\n\n\terr = mlx5_cmd_exec(dev, in, in_sz, out, sizeof(out));\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_mac_list);\n\nint mlx5_modify_nic_vport_vlans(struct mlx5_core_dev *dev,\n\t\t\t\tu16 vlans[],\n\t\t\t\tint list_size)\n{\n\tu32 out[MLX5_ST_SZ_DW(modify_nic_vport_context_out)];\n\tvoid *nic_vport_ctx;\n\tint max_list_size;\n\tint in_sz;\n\tvoid *in;\n\tint err;\n\tint i;\n\n\tmax_list_size = 1 << MLX5_CAP_GEN(dev, log_max_vlan_list);\n\n\tif (list_size > max_list_size)\n\t\treturn -ENOSPC;\n\n\tin_sz = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in) +\n\t\tlist_size * MLX5_ST_SZ_BYTES(vlan_layout);\n\n\tmemset(out, 0, sizeof(out));\n\tin = kvzalloc(in_sz, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t field_select.addresses_list, 1);\n\n\tnic_vport_ctx = MLX5_ADDR_OF(modify_nic_vport_context_in, in,\n\t\t\t\t     nic_vport_context);\n\n\tMLX5_SET(nic_vport_context, nic_vport_ctx,\n\t\t allowed_list_type, MLX5_NVPRT_LIST_TYPE_VLAN);\n\tMLX5_SET(nic_vport_context, nic_vport_ctx,\n\t\t allowed_list_size, list_size);\n\n\tfor (i = 0; i < list_size; i++) {\n\t\tvoid *vlan_addr = MLX5_ADDR_OF(nic_vport_context,\n\t\t\t\t\t       nic_vport_ctx,\n\t\t\t\t\t       current_uc_mac_address[i]);\n\t\tMLX5_SET(vlan_layout, vlan_addr, vlan, vlans[i]);\n\t}\n\n\terr = mlx5_cmd_exec(dev, in, in_sz, out, sizeof(out));\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_vlans);\n\nint mlx5_query_nic_vport_system_image_guid(struct mlx5_core_dev *mdev,\n\t\t\t\t\t   u64 *system_image_guid)\n{\n\tu32 *out;\n\tint outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);\n\tint err;\n\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_nic_vport_context(mdev, 0, out);\n\tif (err)\n\t\tgoto out;\n\n\t*system_image_guid = MLX5_GET64(query_nic_vport_context_out, out,\n\t\t\t\t\tnic_vport_context.system_image_guid);\nout:\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_system_image_guid);\n\nint mlx5_query_nic_vport_node_guid(struct mlx5_core_dev *mdev, u64 *node_guid)\n{\n\tu32 *out;\n\tint outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);\n\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tmlx5_query_nic_vport_context(mdev, 0, out);\n\n\t*node_guid = MLX5_GET64(query_nic_vport_context_out, out,\n\t\t\t\tnic_vport_context.node_guid);\n\n\tkvfree(out);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_node_guid);\n\nint mlx5_modify_nic_vport_node_guid(struct mlx5_core_dev *mdev,\n\t\t\t\t    u16 vport, u64 node_guid)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tvoid *nic_vport_context;\n\tvoid *in;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(mdev, vport_group_manager))\n\t\treturn -EACCES;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t field_select.node_guid, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in, vport_number, vport);\n\tMLX5_SET(modify_nic_vport_context_in, in, other_vport, 1);\n\n\tnic_vport_context = MLX5_ADDR_OF(modify_nic_vport_context_in,\n\t\t\t\t\t in, nic_vport_context);\n\tMLX5_SET64(nic_vport_context, nic_vport_context, node_guid, node_guid);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(mdev, modify_nic_vport_context, in);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nint mlx5_query_nic_vport_qkey_viol_cntr(struct mlx5_core_dev *mdev,\n\t\t\t\t\tu16 *qkey_viol_cntr)\n{\n\tu32 *out;\n\tint outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);\n\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tmlx5_query_nic_vport_context(mdev, 0, out);\n\n\t*qkey_viol_cntr = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t\t   nic_vport_context.qkey_violation_counter);\n\n\tkvfree(out);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_qkey_viol_cntr);\n\nint mlx5_query_hca_vport_gid(struct mlx5_core_dev *dev, u8 other_vport,\n\t\t\t     u8 port_num, u16  vf_num, u16 gid_index,\n\t\t\t     union ib_gid *gid)\n{\n\tint in_sz = MLX5_ST_SZ_BYTES(query_hca_vport_gid_in);\n\tint out_sz = MLX5_ST_SZ_BYTES(query_hca_vport_gid_out);\n\tint is_group_manager;\n\tvoid *out = NULL;\n\tvoid *in = NULL;\n\tunion ib_gid *tmp;\n\tint tbsz;\n\tint nout;\n\tint err;\n\n\tis_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);\n\ttbsz = mlx5_get_gid_table_len(MLX5_CAP_GEN(dev, gid_table_size));\n\tmlx5_core_dbg(dev, \"vf_num %d, index %d, gid_table_size %d\\n\",\n\t\t      vf_num, gid_index, tbsz);\n\n\tif (gid_index > tbsz && gid_index != 0xffff)\n\t\treturn -EINVAL;\n\n\tif (gid_index == 0xffff)\n\t\tnout = tbsz;\n\telse\n\t\tnout = 1;\n\n\tout_sz += nout * sizeof(*gid);\n\n\tin = kvzalloc(in_sz, GFP_KERNEL);\n\tout = kvzalloc(out_sz, GFP_KERNEL);\n\tif (!in || !out) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(query_hca_vport_gid_in, in, opcode, MLX5_CMD_OP_QUERY_HCA_VPORT_GID);\n\tif (other_vport) {\n\t\tif (is_group_manager) {\n\t\t\tMLX5_SET(query_hca_vport_gid_in, in, vport_number, vf_num);\n\t\t\tMLX5_SET(query_hca_vport_gid_in, in, other_vport, 1);\n\t\t} else {\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tMLX5_SET(query_hca_vport_gid_in, in, gid_index, gid_index);\n\n\tif (MLX5_CAP_GEN(dev, num_ports) == 2)\n\t\tMLX5_SET(query_hca_vport_gid_in, in, port_num, port_num);\n\n\terr = mlx5_cmd_exec(dev, in, in_sz, out, out_sz);\n\tif (err)\n\t\tgoto out;\n\n\ttmp = out + MLX5_ST_SZ_BYTES(query_hca_vport_gid_out);\n\tgid->global.subnet_prefix = tmp->global.subnet_prefix;\n\tgid->global.interface_id = tmp->global.interface_id;\n\nout:\n\tkvfree(in);\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_hca_vport_gid);\n\nint mlx5_query_hca_vport_pkey(struct mlx5_core_dev *dev, u8 other_vport,\n\t\t\t      u8 port_num, u16 vf_num, u16 pkey_index,\n\t\t\t      u16 *pkey)\n{\n\tint in_sz = MLX5_ST_SZ_BYTES(query_hca_vport_pkey_in);\n\tint out_sz = MLX5_ST_SZ_BYTES(query_hca_vport_pkey_out);\n\tint is_group_manager;\n\tvoid *out = NULL;\n\tvoid *in = NULL;\n\tvoid *pkarr;\n\tint nout;\n\tint tbsz;\n\tint err;\n\tint i;\n\n\tis_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);\n\n\ttbsz = mlx5_to_sw_pkey_sz(MLX5_CAP_GEN(dev, pkey_table_size));\n\tif (pkey_index > tbsz && pkey_index != 0xffff)\n\t\treturn -EINVAL;\n\n\tif (pkey_index == 0xffff)\n\t\tnout = tbsz;\n\telse\n\t\tnout = 1;\n\n\tout_sz += nout * MLX5_ST_SZ_BYTES(pkey);\n\n\tin = kvzalloc(in_sz, GFP_KERNEL);\n\tout = kvzalloc(out_sz, GFP_KERNEL);\n\tif (!in || !out) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(query_hca_vport_pkey_in, in, opcode, MLX5_CMD_OP_QUERY_HCA_VPORT_PKEY);\n\tif (other_vport) {\n\t\tif (is_group_manager) {\n\t\t\tMLX5_SET(query_hca_vport_pkey_in, in, vport_number, vf_num);\n\t\t\tMLX5_SET(query_hca_vport_pkey_in, in, other_vport, 1);\n\t\t} else {\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tMLX5_SET(query_hca_vport_pkey_in, in, pkey_index, pkey_index);\n\n\tif (MLX5_CAP_GEN(dev, num_ports) == 2)\n\t\tMLX5_SET(query_hca_vport_pkey_in, in, port_num, port_num);\n\n\terr = mlx5_cmd_exec(dev, in, in_sz, out, out_sz);\n\tif (err)\n\t\tgoto out;\n\n\tpkarr = MLX5_ADDR_OF(query_hca_vport_pkey_out, out, pkey);\n\tfor (i = 0; i < nout; i++, pkey++, pkarr += MLX5_ST_SZ_BYTES(pkey))\n\t\t*pkey = MLX5_GET_PR(pkey, pkarr, pkey);\n\nout:\n\tkvfree(in);\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_hca_vport_pkey);\n\nint mlx5_query_hca_vport_context(struct mlx5_core_dev *dev,\n\t\t\t\t u8 other_vport, u8 port_num,\n\t\t\t\t u16 vf_num,\n\t\t\t\t struct mlx5_hca_vport_context *rep)\n{\n\tint out_sz = MLX5_ST_SZ_BYTES(query_hca_vport_context_out);\n\tint in[MLX5_ST_SZ_DW(query_hca_vport_context_in)] = {};\n\tint is_group_manager;\n\tvoid *out;\n\tvoid *ctx;\n\tint err;\n\n\tis_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);\n\n\tout = kvzalloc(out_sz, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(query_hca_vport_context_in, in, opcode, MLX5_CMD_OP_QUERY_HCA_VPORT_CONTEXT);\n\n\tif (other_vport) {\n\t\tif (is_group_manager) {\n\t\t\tMLX5_SET(query_hca_vport_context_in, in, other_vport, 1);\n\t\t\tMLX5_SET(query_hca_vport_context_in, in, vport_number, vf_num);\n\t\t} else {\n\t\t\terr = -EPERM;\n\t\t\tgoto ex;\n\t\t}\n\t}\n\n\tif (MLX5_CAP_GEN(dev, num_ports) == 2)\n\t\tMLX5_SET(query_hca_vport_context_in, in, port_num, port_num);\n\n\terr = mlx5_cmd_exec_inout(dev, query_hca_vport_context, in, out);\n\tif (err)\n\t\tgoto ex;\n\n\tctx = MLX5_ADDR_OF(query_hca_vport_context_out, out, hca_vport_context);\n\trep->field_select = MLX5_GET_PR(hca_vport_context, ctx, field_select);\n\trep->sm_virt_aware = MLX5_GET_PR(hca_vport_context, ctx, sm_virt_aware);\n\trep->has_smi = MLX5_GET_PR(hca_vport_context, ctx, has_smi);\n\trep->has_raw = MLX5_GET_PR(hca_vport_context, ctx, has_raw);\n\trep->policy = MLX5_GET_PR(hca_vport_context, ctx, vport_state_policy);\n\trep->phys_state = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t      port_physical_state);\n\trep->vport_state = MLX5_GET_PR(hca_vport_context, ctx, vport_state);\n\trep->port_physical_state = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t\t       port_physical_state);\n\trep->port_guid = MLX5_GET64_PR(hca_vport_context, ctx, port_guid);\n\trep->node_guid = MLX5_GET64_PR(hca_vport_context, ctx, node_guid);\n\trep->cap_mask1 = MLX5_GET_PR(hca_vport_context, ctx, cap_mask1);\n\trep->cap_mask1_perm = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t\t  cap_mask1_field_select);\n\trep->cap_mask2 = MLX5_GET_PR(hca_vport_context, ctx, cap_mask2);\n\trep->cap_mask2_perm = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t\t  cap_mask2_field_select);\n\trep->lid = MLX5_GET_PR(hca_vport_context, ctx, lid);\n\trep->init_type_reply = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t\t   init_type_reply);\n\trep->lmc = MLX5_GET_PR(hca_vport_context, ctx, lmc);\n\trep->subnet_timeout = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t\t  subnet_timeout);\n\trep->sm_lid = MLX5_GET_PR(hca_vport_context, ctx, sm_lid);\n\trep->sm_sl = MLX5_GET_PR(hca_vport_context, ctx, sm_sl);\n\trep->qkey_violation_counter = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t\t\t  qkey_violation_counter);\n\trep->pkey_violation_counter = MLX5_GET_PR(hca_vport_context, ctx,\n\t\t\t\t\t\t  pkey_violation_counter);\n\trep->grh_required = MLX5_GET_PR(hca_vport_context, ctx, grh_required);\n\trep->sys_image_guid = MLX5_GET64_PR(hca_vport_context, ctx,\n\t\t\t\t\t    system_image_guid);\n\nex:\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_hca_vport_context);\n\nint mlx5_query_hca_vport_system_image_guid(struct mlx5_core_dev *dev,\n\t\t\t\t\t   u64 *sys_image_guid)\n{\n\tstruct mlx5_hca_vport_context *rep;\n\tint err;\n\n\trep = kvzalloc(sizeof(*rep), GFP_KERNEL);\n\tif (!rep)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_hca_vport_context(dev, 0, 1, 0, rep);\n\tif (!err)\n\t\t*sys_image_guid = rep->sys_image_guid;\n\n\tkvfree(rep);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_hca_vport_system_image_guid);\n\nint mlx5_query_hca_vport_node_guid(struct mlx5_core_dev *dev,\n\t\t\t\t   u64 *node_guid)\n{\n\tstruct mlx5_hca_vport_context *rep;\n\tint err;\n\n\trep = kvzalloc(sizeof(*rep), GFP_KERNEL);\n\tif (!rep)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_hca_vport_context(dev, 0, 1, 0, rep);\n\tif (!err)\n\t\t*node_guid = rep->node_guid;\n\n\tkvfree(rep);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_hca_vport_node_guid);\n\nint mlx5_query_nic_vport_promisc(struct mlx5_core_dev *mdev,\n\t\t\t\t u16 vport,\n\t\t\t\t int *promisc_uc,\n\t\t\t\t int *promisc_mc,\n\t\t\t\t int *promisc_all)\n{\n\tu32 *out;\n\tint outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);\n\tint err;\n\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_nic_vport_context(mdev, vport, out);\n\tif (err)\n\t\tgoto out;\n\n\t*promisc_uc = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t       nic_vport_context.promisc_uc);\n\t*promisc_mc = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t       nic_vport_context.promisc_mc);\n\t*promisc_all = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t\tnic_vport_context.promisc_all);\n\nout:\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_vport_promisc);\n\nint mlx5_modify_nic_vport_promisc(struct mlx5_core_dev *mdev,\n\t\t\t\t  int promisc_uc,\n\t\t\t\t  int promisc_mc,\n\t\t\t\t  int promisc_all)\n{\n\tvoid *in;\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in, field_select.promisc, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.promisc_uc, promisc_uc);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.promisc_mc, promisc_mc);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.promisc_all, promisc_all);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(mdev, modify_nic_vport_context, in);\n\n\tkvfree(in);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_promisc);\n\nenum {\n\tUC_LOCAL_LB,\n\tMC_LOCAL_LB\n};\n\nint mlx5_nic_vport_update_local_lb(struct mlx5_core_dev *mdev, bool enable)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tvoid *in;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(mdev, disable_local_lb_mc) &&\n\t    !MLX5_CAP_GEN(mdev, disable_local_lb_uc))\n\t\treturn 0;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.disable_mc_local_lb, !enable);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.disable_uc_local_lb, !enable);\n\n\tif (MLX5_CAP_GEN(mdev, disable_local_lb_mc))\n\t\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t\t field_select.disable_mc_local_lb, 1);\n\n\tif (MLX5_CAP_GEN(mdev, disable_local_lb_uc))\n\t\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t\t field_select.disable_uc_local_lb, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(mdev, modify_nic_vport_context, in);\n\n\tif (!err)\n\t\tmlx5_core_dbg(mdev, \"%s local_lb\\n\",\n\t\t\t      enable ? \"enable\" : \"disable\");\n\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_nic_vport_update_local_lb);\n\nint mlx5_nic_vport_query_local_lb(struct mlx5_core_dev *mdev, bool *status)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);\n\tu32 *out;\n\tint value;\n\tint err;\n\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_nic_vport_context(mdev, 0, out);\n\tif (err)\n\t\tgoto out;\n\n\tvalue = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t nic_vport_context.disable_mc_local_lb) << MC_LOCAL_LB;\n\n\tvalue |= MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t  nic_vport_context.disable_uc_local_lb) << UC_LOCAL_LB;\n\n\t*status = !value;\n\nout:\n\tkvfree(out);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_nic_vport_query_local_lb);\n\nenum mlx5_vport_roce_state {\n\tMLX5_VPORT_ROCE_DISABLED = 0,\n\tMLX5_VPORT_ROCE_ENABLED  = 1,\n};\n\nstatic int mlx5_nic_vport_update_roce_state(struct mlx5_core_dev *mdev,\n\t\t\t\t\t    enum mlx5_vport_roce_state state)\n{\n\tvoid *in;\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in, field_select.roce_en, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in, nic_vport_context.roce_en,\n\t\t state);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(mdev, modify_nic_vport_context, in);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nint mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev)\n{\n\tint err = 0;\n\n\tmutex_lock(&mlx5_roce_en_lock);\n\tif (!mdev->roce.roce_en)\n\t\terr = mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_ENABLED);\n\n\tif (!err)\n\t\tmdev->roce.roce_en++;\n\tmutex_unlock(&mlx5_roce_en_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_nic_vport_enable_roce);\n\nint mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev)\n{\n\tint err = 0;\n\n\tmutex_lock(&mlx5_roce_en_lock);\n\tif (mdev->roce.roce_en) {\n\t\tmdev->roce.roce_en--;\n\t\tif (mdev->roce.roce_en == 0)\n\t\t\terr = mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_DISABLED);\n\n\t\tif (err)\n\t\t\tmdev->roce.roce_en++;\n\t}\n\tmutex_unlock(&mlx5_roce_en_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx5_nic_vport_disable_roce);\n\nint mlx5_core_query_vport_counter(struct mlx5_core_dev *dev, u8 other_vport,\n\t\t\t\t  int vf, u8 port_num, void *out)\n{\n\tint in_sz = MLX5_ST_SZ_BYTES(query_vport_counter_in);\n\tint is_group_manager;\n\tvoid *in;\n\tint err;\n\n\tis_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);\n\tin = kvzalloc(in_sz, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\treturn err;\n\t}\n\n\tMLX5_SET(query_vport_counter_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_VPORT_COUNTER);\n\tif (other_vport) {\n\t\tif (is_group_manager) {\n\t\t\tMLX5_SET(query_vport_counter_in, in, other_vport, 1);\n\t\t\tMLX5_SET(query_vport_counter_in, in, vport_number, vf + 1);\n\t\t} else {\n\t\t\terr = -EPERM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\tif (MLX5_CAP_GEN(dev, num_ports) == 2)\n\t\tMLX5_SET(query_vport_counter_in, in, port_num, port_num);\n\n\terr = mlx5_cmd_exec_inout(dev, query_vport_counter, in, out);\nfree:\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_core_query_vport_counter);\n\nint mlx5_query_vport_down_stats(struct mlx5_core_dev *mdev, u16 vport,\n\t\t\t\tu8 other_vport, u64 *rx_discard_vport_down,\n\t\t\t\tu64 *tx_discard_vport_down)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_vnic_env_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_vnic_env_in)] = {};\n\tint err;\n\n\tMLX5_SET(query_vnic_env_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_VNIC_ENV);\n\tMLX5_SET(query_vnic_env_in, in, op_mod, 0);\n\tMLX5_SET(query_vnic_env_in, in, vport_number, vport);\n\tMLX5_SET(query_vnic_env_in, in, other_vport, other_vport);\n\n\terr = mlx5_cmd_exec_inout(mdev, query_vnic_env, in, out);\n\tif (err)\n\t\treturn err;\n\n\t*rx_discard_vport_down = MLX5_GET64(query_vnic_env_out, out,\n\t\t\t\t\t    vport_env.receive_discard_vport_down);\n\t*tx_discard_vport_down = MLX5_GET64(query_vnic_env_out, out,\n\t\t\t\t\t    vport_env.transmit_discard_vport_down);\n\treturn 0;\n}\n\nint mlx5_core_modify_hca_vport_context(struct mlx5_core_dev *dev,\n\t\t\t\t       u8 other_vport, u8 port_num,\n\t\t\t\t       int vf,\n\t\t\t\t       struct mlx5_hca_vport_context *req)\n{\n\tint in_sz = MLX5_ST_SZ_BYTES(modify_hca_vport_context_in);\n\tint is_group_manager;\n\tvoid *ctx;\n\tvoid *in;\n\tint err;\n\n\tmlx5_core_dbg(dev, \"vf %d\\n\", vf);\n\tis_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);\n\tin = kvzalloc(in_sz, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_hca_vport_context_in, in, opcode, MLX5_CMD_OP_MODIFY_HCA_VPORT_CONTEXT);\n\tif (other_vport) {\n\t\tif (is_group_manager) {\n\t\t\tMLX5_SET(modify_hca_vport_context_in, in, other_vport, 1);\n\t\t\tMLX5_SET(modify_hca_vport_context_in, in, vport_number, vf);\n\t\t} else {\n\t\t\terr = -EPERM;\n\t\t\tgoto ex;\n\t\t}\n\t}\n\n\tif (MLX5_CAP_GEN(dev, num_ports) > 1)\n\t\tMLX5_SET(modify_hca_vport_context_in, in, port_num, port_num);\n\n\tctx = MLX5_ADDR_OF(modify_hca_vport_context_in, in, hca_vport_context);\n\tMLX5_SET(hca_vport_context, ctx, field_select, req->field_select);\n\tif (req->field_select & MLX5_HCA_VPORT_SEL_STATE_POLICY)\n\t\tMLX5_SET(hca_vport_context, ctx, vport_state_policy,\n\t\t\t req->policy);\n\tif (req->field_select & MLX5_HCA_VPORT_SEL_PORT_GUID)\n\t\tMLX5_SET64(hca_vport_context, ctx, port_guid, req->port_guid);\n\tif (req->field_select & MLX5_HCA_VPORT_SEL_NODE_GUID)\n\t\tMLX5_SET64(hca_vport_context, ctx, node_guid, req->node_guid);\n\tMLX5_SET(hca_vport_context, ctx, cap_mask1, req->cap_mask1);\n\tMLX5_SET(hca_vport_context, ctx, cap_mask1_field_select,\n\t\t req->cap_mask1_perm);\n\terr = mlx5_cmd_exec_in(dev, modify_hca_vport_context, in);\nex:\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_core_modify_hca_vport_context);\n\nint mlx5_nic_vport_affiliate_multiport(struct mlx5_core_dev *master_mdev,\n\t\t\t\t       struct mlx5_core_dev *port_mdev)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tvoid *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_nic_vport_enable_roce(port_mdev);\n\tif (err)\n\t\tgoto free;\n\n\tMLX5_SET(modify_nic_vport_context_in, in, field_select.affiliation, 1);\n\tif (MLX5_CAP_GEN_2(master_mdev, sw_vhca_id_valid)) {\n\t\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t\t nic_vport_context.vhca_id_type, VHCA_ID_TYPE_SW);\n\t\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t\t nic_vport_context.affiliated_vhca_id,\n\t\t\t MLX5_CAP_GEN_2(master_mdev, sw_vhca_id));\n\t} else {\n\t\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t\t nic_vport_context.affiliated_vhca_id,\n\t\t\t MLX5_CAP_GEN(master_mdev, vhca_id));\n\t}\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.affiliation_criteria,\n\t\t MLX5_CAP_GEN(port_mdev, affiliate_nic_vport_criteria));\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(port_mdev, modify_nic_vport_context, in);\n\tif (err)\n\t\tmlx5_nic_vport_disable_roce(port_mdev);\n\nfree:\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_nic_vport_affiliate_multiport);\n\nint mlx5_nic_vport_unaffiliate_multiport(struct mlx5_core_dev *port_mdev)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);\n\tvoid *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_nic_vport_context_in, in, field_select.affiliation, 1);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.affiliated_vhca_id, 0);\n\tMLX5_SET(modify_nic_vport_context_in, in,\n\t\t nic_vport_context.affiliation_criteria, 0);\n\tMLX5_SET(modify_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\n\n\terr = mlx5_cmd_exec_in(port_mdev, modify_nic_vport_context, in);\n\tif (!err)\n\t\tmlx5_nic_vport_disable_roce(port_mdev);\n\n\tkvfree(in);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_nic_vport_unaffiliate_multiport);\n\nu64 mlx5_query_nic_system_image_guid(struct mlx5_core_dev *mdev)\n{\n\tint port_type_cap = MLX5_CAP_GEN(mdev, port_type);\n\tu64 tmp;\n\tint err;\n\n\tif (mdev->sys_image_guid)\n\t\treturn mdev->sys_image_guid;\n\n\tif (port_type_cap == MLX5_CAP_PORT_TYPE_ETH)\n\t\terr = mlx5_query_nic_vport_system_image_guid(mdev, &tmp);\n\telse\n\t\terr = mlx5_query_hca_vport_system_image_guid(mdev, &tmp);\n\n\tmdev->sys_image_guid = err ? 0 : tmp;\n\n\treturn mdev->sys_image_guid;\n}\nEXPORT_SYMBOL_GPL(mlx5_query_nic_system_image_guid);\n\nint mlx5_vport_get_other_func_cap(struct mlx5_core_dev *dev, u16 vport, void *out,\n\t\t\t\t  u16 opmod)\n{\n\tbool ec_vf_func = mlx5_core_is_ec_vf_vport(dev, vport);\n\tu8 in[MLX5_ST_SZ_BYTES(query_hca_cap_in)] = {};\n\n\topmod = (opmod << 1) | (HCA_CAP_OPMOD_GET_MAX & 0x01);\n\tMLX5_SET(query_hca_cap_in, in, opcode, MLX5_CMD_OP_QUERY_HCA_CAP);\n\tMLX5_SET(query_hca_cap_in, in, op_mod, opmod);\n\tMLX5_SET(query_hca_cap_in, in, function_id, mlx5_vport_to_func_id(dev, vport, ec_vf_func));\n\tMLX5_SET(query_hca_cap_in, in, other_function, true);\n\tMLX5_SET(query_hca_cap_in, in, ec_vf_function, ec_vf_func);\n\treturn mlx5_cmd_exec_inout(dev, query_hca_cap, in, out);\n}\nEXPORT_SYMBOL_GPL(mlx5_vport_get_other_func_cap);\n\nint mlx5_vport_set_other_func_cap(struct mlx5_core_dev *dev, const void *hca_cap,\n\t\t\t\t  u16 vport, u16 opmod)\n{\n\tbool ec_vf_func = mlx5_core_is_ec_vf_vport(dev, vport);\n\tint set_sz = MLX5_ST_SZ_BYTES(set_hca_cap_in);\n\tvoid *set_hca_cap;\n\tvoid *set_ctx;\n\tint ret;\n\n\tset_ctx = kzalloc(set_sz, GFP_KERNEL);\n\tif (!set_ctx)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(set_hca_cap_in, set_ctx, opcode, MLX5_CMD_OP_SET_HCA_CAP);\n\tMLX5_SET(set_hca_cap_in, set_ctx, op_mod, opmod << 1);\n\tset_hca_cap = MLX5_ADDR_OF(set_hca_cap_in, set_ctx, capability);\n\tmemcpy(set_hca_cap, hca_cap, MLX5_ST_SZ_BYTES(cmd_hca_cap));\n\tMLX5_SET(set_hca_cap_in, set_ctx, function_id,\n\t\t mlx5_vport_to_func_id(dev, vport, ec_vf_func));\n\tMLX5_SET(set_hca_cap_in, set_ctx, other_function, true);\n\tMLX5_SET(set_hca_cap_in, set_ctx, ec_vf_function, ec_vf_func);\n\tret = mlx5_cmd_exec_in(dev, set_hca_cap, set_ctx);\n\n\tkfree(set_ctx);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}