{
  "module_name": "tc_ct.h",
  "hash_id": "3ad12ae3630d09a7780de0f891e1fad552d8d9622859a6e92a1548ac4d8d185d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h",
  "human_readable_source": " \n \n\n#ifndef __MLX5_EN_TC_CT_H__\n#define __MLX5_EN_TC_CT_H__\n\n#include <net/pkt_cls.h>\n#include <linux/mlx5/fs.h>\n#include <net/tc_act/tc_ct.h>\n\n#include \"en.h\"\n\nstruct mlx5_flow_attr;\nstruct mlx5e_tc_mod_hdr_acts;\nstruct mlx5_rep_uplink_priv;\nstruct mlx5e_tc_flow;\nstruct mlx5e_priv;\n\nstruct mlx5_fs_chains;\nstruct mlx5_tc_ct_priv;\nstruct mlx5_ct_flow;\n\nstruct nf_flowtable;\n\nstruct mlx5_ct_attr {\n\tu16 zone;\n\tu16 ct_action;\n\tstruct nf_flowtable *nf_ft;\n\tu32 ct_labels_id;\n\tu32 act_miss_mapping;\n\tu64 act_miss_cookie;\n\tbool offloaded;\n\tstruct mlx5_ct_ft *ft;\n};\n\n#define zone_to_reg_ct {\\\n\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_2,\\\n\t.moffset = 0,\\\n\t.mlen = 16,\\\n\t.soffset = MLX5_BYTE_OFF(fte_match_param,\\\n\t\t\t\t misc_parameters_2.metadata_reg_c_2),\\\n}\n\n#define ctstate_to_reg_ct {\\\n\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_2,\\\n\t.moffset = 16,\\\n\t.mlen = 16,\\\n\t.soffset = MLX5_BYTE_OFF(fte_match_param,\\\n\t\t\t\t misc_parameters_2.metadata_reg_c_2),\\\n}\n\n#define mark_to_reg_ct {\\\n\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_3,\\\n\t.moffset = 0,\\\n\t.mlen = 32,\\\n\t.soffset = MLX5_BYTE_OFF(fte_match_param,\\\n\t\t\t\t misc_parameters_2.metadata_reg_c_3),\\\n}\n\n#define labels_to_reg_ct {\\\n\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_4,\\\n\t.moffset = 0,\\\n\t.mlen = 32,\\\n\t.soffset = MLX5_BYTE_OFF(fte_match_param,\\\n\t\t\t\t misc_parameters_2.metadata_reg_c_4),\\\n}\n\n \n#define fteid_to_reg_ct {\\\n\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_5,\\\n\t.moffset = 8,\\\n\t.mlen = 24,\\\n\t.soffset = MLX5_BYTE_OFF(fte_match_param,\\\n\t\t\t\t misc_parameters_2.metadata_reg_c_5),\\\n}\n\n#define zone_restore_to_reg_ct {\\\n\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_1,\\\n\t.moffset = 0,\\\n\t.mlen = ESW_ZONE_ID_BITS,\\\n\t.soffset = MLX5_BYTE_OFF(fte_match_param,\\\n\t\t\t\t misc_parameters_2.metadata_reg_c_1),\\\n}\n\n#define nic_zone_restore_to_reg_ct {\\\n\t.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_B,\\\n\t.moffset = 16,\\\n\t.mlen = ESW_ZONE_ID_BITS,\\\n}\n\n#define MLX5_CT_ZONE_BITS MLX5_REG_MAPPING_MBITS(ZONE_TO_REG)\n#define MLX5_CT_ZONE_MASK MLX5_REG_MAPPING_MASK(ZONE_TO_REG)\n\n#if IS_ENABLED(CONFIG_MLX5_TC_CT)\n\nstruct mlx5_tc_ct_priv *\nmlx5_tc_ct_init(struct mlx5e_priv *priv, struct mlx5_fs_chains *chains,\n\t\tstruct mod_hdr_tbl *mod_hdr,\n\t\tenum mlx5_flow_namespace_type ns_type,\n\t\tstruct mlx5e_post_act *post_act);\nvoid\nmlx5_tc_ct_clean(struct mlx5_tc_ct_priv *ct_priv);\n\nvoid\nmlx5_tc_ct_match_del(struct mlx5_tc_ct_priv *priv, struct mlx5_ct_attr *ct_attr);\n\nint\nmlx5_tc_ct_match_add(struct mlx5_tc_ct_priv *priv,\n\t\t     struct mlx5_flow_spec *spec,\n\t\t     struct flow_cls_offload *f,\n\t\t     struct mlx5_ct_attr *ct_attr,\n\t\t     struct netlink_ext_ack *extack);\nint mlx5_tc_ct_add_no_trk_match(struct mlx5_flow_spec *spec);\nint\nmlx5_tc_ct_parse_action(struct mlx5_tc_ct_priv *priv,\n\t\t\tstruct mlx5_flow_attr *attr,\n\t\t\tconst struct flow_action_entry *act,\n\t\t\tstruct netlink_ext_ack *extack);\n\nint\nmlx5_tc_ct_flow_offload(struct mlx5_tc_ct_priv *priv, struct mlx5_flow_attr *attr);\n\nvoid\nmlx5_tc_ct_delete_flow(struct mlx5_tc_ct_priv *priv,\n\t\t       struct mlx5_flow_attr *attr);\n\nbool\nmlx5e_tc_ct_restore_flow(struct mlx5_tc_ct_priv *ct_priv,\n\t\t\t struct sk_buff *skb, u8 zone_restore_id);\n\n#else  \n\nstatic inline struct mlx5_tc_ct_priv *\nmlx5_tc_ct_init(struct mlx5e_priv *priv, struct mlx5_fs_chains *chains,\n\t\tstruct mod_hdr_tbl *mod_hdr,\n\t\tenum mlx5_flow_namespace_type ns_type,\n\t\tstruct mlx5e_post_act *post_act)\n{\n\treturn NULL;\n}\n\nstatic inline void\nmlx5_tc_ct_clean(struct mlx5_tc_ct_priv *ct_priv)\n{\n}\n\nstatic inline void\nmlx5_tc_ct_match_del(struct mlx5_tc_ct_priv *priv, struct mlx5_ct_attr *ct_attr) {}\n\nstatic inline int\nmlx5_tc_ct_match_add(struct mlx5_tc_ct_priv *priv,\n\t\t     struct mlx5_flow_spec *spec,\n\t\t     struct flow_cls_offload *f,\n\t\t     struct mlx5_ct_attr *ct_attr,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\n\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CT))\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_MOD(extack, \"mlx5 tc ct offload isn't enabled.\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int\nmlx5_tc_ct_add_no_trk_match(struct mlx5_flow_spec *spec)\n{\n\treturn 0;\n}\n\nstatic inline int\nmlx5_tc_ct_parse_action(struct mlx5_tc_ct_priv *priv,\n\t\t\tstruct mlx5_flow_attr *attr,\n\t\t\tconst struct flow_action_entry *act,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG_MOD(extack, \"mlx5 tc ct offload isn't enabled.\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int\nmlx5_tc_ct_flow_offload(struct mlx5_tc_ct_priv *priv,\n\t\t\tstruct mlx5_flow_attr *attr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void\nmlx5_tc_ct_delete_flow(struct mlx5_tc_ct_priv *priv,\n\t\t       struct mlx5_flow_attr *attr)\n{\n}\n\nstatic inline bool\nmlx5e_tc_ct_restore_flow(struct mlx5_tc_ct_priv *ct_priv,\n\t\t\t struct sk_buff *skb, u8 zone_restore_id)\n{\n\tif (!zone_restore_id)\n\t\treturn true;\n\n\treturn false;\n}\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}