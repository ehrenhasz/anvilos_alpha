{
  "module_name": "vxlan.c",
  "hash_id": "54c3214398150a7720e05707a9f6150b2dbd443bb2b2c457ea9304e48cf17b87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/refcount.h>\n#include <linux/mlx5/driver.h>\n#include <net/vxlan.h>\n#include \"mlx5_core.h\"\n#include \"vxlan.h\"\n\nstruct mlx5_vxlan {\n\tstruct mlx5_core_dev\t\t*mdev;\n\t \n\tDECLARE_HASHTABLE(htable, 4);\n\tstruct mutex                    sync_lock;  \n};\n\nstruct mlx5_vxlan_port {\n\tstruct hlist_node hlist;\n\tu16 udp_port;\n};\n\nstatic int mlx5_vxlan_core_add_port_cmd(struct mlx5_core_dev *mdev, u16 port)\n{\n\tu32 in[MLX5_ST_SZ_DW(add_vxlan_udp_dport_in)] = {};\n\n\tMLX5_SET(add_vxlan_udp_dport_in, in, opcode,\n\t\t MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT);\n\tMLX5_SET(add_vxlan_udp_dport_in, in, vxlan_udp_port, port);\n\treturn mlx5_cmd_exec_in(mdev, add_vxlan_udp_dport, in);\n}\n\nstatic int mlx5_vxlan_core_del_port_cmd(struct mlx5_core_dev *mdev, u16 port)\n{\n\tu32 in[MLX5_ST_SZ_DW(delete_vxlan_udp_dport_in)] = {};\n\n\tMLX5_SET(delete_vxlan_udp_dport_in, in, opcode,\n\t\t MLX5_CMD_OP_DELETE_VXLAN_UDP_DPORT);\n\tMLX5_SET(delete_vxlan_udp_dport_in, in, vxlan_udp_port, port);\n\treturn mlx5_cmd_exec_in(mdev, delete_vxlan_udp_dport, in);\n}\n\nbool mlx5_vxlan_lookup_port(struct mlx5_vxlan *vxlan, u16 port)\n{\n\tstruct mlx5_vxlan_port *vxlanp;\n\tbool found = false;\n\n\tif (!mlx5_vxlan_allowed(vxlan))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\thash_for_each_possible_rcu(vxlan->htable, vxlanp, hlist, port)\n\t\tif (vxlanp->udp_port == port) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\n\treturn found;\n}\n\nstatic struct mlx5_vxlan_port *vxlan_lookup_port(struct mlx5_vxlan *vxlan, u16 port)\n{\n\tstruct mlx5_vxlan_port *vxlanp;\n\n\thash_for_each_possible(vxlan->htable, vxlanp, hlist, port)\n\t\tif (vxlanp->udp_port == port)\n\t\t\treturn vxlanp;\n\treturn NULL;\n}\n\nint mlx5_vxlan_add_port(struct mlx5_vxlan *vxlan, u16 port)\n{\n\tstruct mlx5_vxlan_port *vxlanp;\n\tint ret;\n\n\tvxlanp = kzalloc(sizeof(*vxlanp), GFP_KERNEL);\n\tif (!vxlanp)\n\t\treturn -ENOMEM;\n\tvxlanp->udp_port = port;\n\n\tret = mlx5_vxlan_core_add_port_cmd(vxlan->mdev, port);\n\tif (ret) {\n\t\tkfree(vxlanp);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&vxlan->sync_lock);\n\thash_add_rcu(vxlan->htable, &vxlanp->hlist, port);\n\tmutex_unlock(&vxlan->sync_lock);\n\n\treturn 0;\n}\n\nint mlx5_vxlan_del_port(struct mlx5_vxlan *vxlan, u16 port)\n{\n\tstruct mlx5_vxlan_port *vxlanp;\n\tint ret = 0;\n\n\tmutex_lock(&vxlan->sync_lock);\n\n\tvxlanp = vxlan_lookup_port(vxlan, port);\n\tif (WARN_ON(!vxlanp)) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\thash_del_rcu(&vxlanp->hlist);\n\tsynchronize_rcu();\n\tmlx5_vxlan_core_del_port_cmd(vxlan->mdev, port);\n\tkfree(vxlanp);\n\nout_unlock:\n\tmutex_unlock(&vxlan->sync_lock);\n\treturn ret;\n}\n\nstruct mlx5_vxlan *mlx5_vxlan_create(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_vxlan *vxlan;\n\n\tif (!MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) || !mlx5_core_is_pf(mdev))\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tvxlan = kzalloc(sizeof(*vxlan), GFP_KERNEL);\n\tif (!vxlan)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvxlan->mdev = mdev;\n\tmutex_init(&vxlan->sync_lock);\n\thash_init(vxlan->htable);\n\n\t \n\tmlx5_vxlan_add_port(vxlan, IANA_VXLAN_UDP_PORT);\n\n\treturn vxlan;\n}\n\nvoid mlx5_vxlan_destroy(struct mlx5_vxlan *vxlan)\n{\n\tif (!mlx5_vxlan_allowed(vxlan))\n\t\treturn;\n\n\tmlx5_vxlan_del_port(vxlan, IANA_VXLAN_UDP_PORT);\n\tWARN_ON(!hash_empty(vxlan->htable));\n\n\tkfree(vxlan);\n}\n\nvoid mlx5_vxlan_reset_to_default(struct mlx5_vxlan *vxlan)\n{\n\tstruct mlx5_vxlan_port *vxlanp;\n\tstruct hlist_node *tmp;\n\tint bkt;\n\n\tif (!mlx5_vxlan_allowed(vxlan))\n\t\treturn;\n\n\thash_for_each_safe(vxlan->htable, bkt, tmp, vxlanp, hlist) {\n\t\t \n\t\tif (vxlanp->udp_port == IANA_VXLAN_UDP_PORT)\n\t\t\tcontinue;\n\t\tmlx5_vxlan_del_port(vxlan, vxlanp->udp_port);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}