{
  "module_name": "devlink_port.c",
  "hash_id": "675e9ad6cde795dceb25d8af1edb22820aa5a968526b96469f902d0415e3b0b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/driver.h>\n#include \"eswitch.h\"\n\nstatic void\nmlx5_esw_get_port_parent_id(struct mlx5_core_dev *dev, struct netdev_phys_item_id *ppid)\n{\n\tu64 parent_id;\n\n\tparent_id = mlx5_query_nic_system_image_guid(dev);\n\tppid->id_len = sizeof(parent_id);\n\tmemcpy(ppid->id, &parent_id, sizeof(parent_id));\n}\n\nstatic bool mlx5_esw_devlink_port_supported(struct mlx5_eswitch *esw, u16 vport_num)\n{\n\treturn (mlx5_core_is_ecpf(esw->dev) && vport_num == MLX5_VPORT_PF) ||\n\t       mlx5_eswitch_is_vf_vport(esw, vport_num) ||\n\t       mlx5_core_is_ec_vf_vport(esw->dev, vport_num);\n}\n\nstatic void mlx5_esw_offloads_pf_vf_devlink_port_attrs_set(struct mlx5_eswitch *esw,\n\t\t\t\t\t\t\t   u16 vport_num,\n\t\t\t\t\t\t\t   struct devlink_port *dl_port)\n{\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct netdev_phys_item_id ppid = {};\n\tu32 controller_num = 0;\n\tbool external;\n\tu16 pfnum;\n\n\tmlx5_esw_get_port_parent_id(dev, &ppid);\n\tpfnum = mlx5_get_dev_index(dev);\n\texternal = mlx5_core_is_ecpf_esw_manager(dev);\n\tif (external)\n\t\tcontroller_num = dev->priv.eswitch->offloads.host_number + 1;\n\n\tif (vport_num == MLX5_VPORT_PF) {\n\t\tmemcpy(dl_port->attrs.switch_id.id, ppid.id, ppid.id_len);\n\t\tdl_port->attrs.switch_id.id_len = ppid.id_len;\n\t\tdevlink_port_attrs_pci_pf_set(dl_port, controller_num, pfnum, external);\n\t} else if (mlx5_eswitch_is_vf_vport(esw, vport_num)) {\n\t\tmemcpy(dl_port->attrs.switch_id.id, ppid.id, ppid.id_len);\n\t\tdl_port->attrs.switch_id.id_len = ppid.id_len;\n\t\tdevlink_port_attrs_pci_vf_set(dl_port, controller_num, pfnum,\n\t\t\t\t\t      vport_num - 1, external);\n\t}  else if (mlx5_core_is_ec_vf_vport(esw->dev, vport_num)) {\n\t\tmemcpy(dl_port->attrs.switch_id.id, ppid.id, ppid.id_len);\n\t\tdl_port->attrs.switch_id.id_len = ppid.id_len;\n\t\tdevlink_port_attrs_pci_vf_set(dl_port, 0, pfnum,\n\t\t\t\t\t      vport_num - 1, false);\n\t}\n}\n\nint mlx5_esw_offloads_pf_vf_devlink_port_init(struct mlx5_eswitch *esw,\n\t\t\t\t\t      struct mlx5_vport *vport)\n{\n\tstruct mlx5_devlink_port *dl_port;\n\tu16 vport_num = vport->vport;\n\n\tif (!mlx5_esw_devlink_port_supported(esw, vport_num))\n\t\treturn 0;\n\n\tdl_port = kzalloc(sizeof(*dl_port), GFP_KERNEL);\n\tif (!dl_port)\n\t\treturn -ENOMEM;\n\n\tmlx5_esw_offloads_pf_vf_devlink_port_attrs_set(esw, vport_num,\n\t\t\t\t\t\t       &dl_port->dl_port);\n\n\tvport->dl_port = dl_port;\n\tmlx5_devlink_port_init(dl_port, vport);\n\treturn 0;\n}\n\nvoid mlx5_esw_offloads_pf_vf_devlink_port_cleanup(struct mlx5_eswitch *esw,\n\t\t\t\t\t\t  struct mlx5_vport *vport)\n{\n\tif (!vport->dl_port)\n\t\treturn;\n\n\tkfree(vport->dl_port);\n\tvport->dl_port = NULL;\n}\n\nstatic const struct devlink_port_ops mlx5_esw_pf_vf_dl_port_ops = {\n\t.port_fn_hw_addr_get = mlx5_devlink_port_fn_hw_addr_get,\n\t.port_fn_hw_addr_set = mlx5_devlink_port_fn_hw_addr_set,\n\t.port_fn_roce_get = mlx5_devlink_port_fn_roce_get,\n\t.port_fn_roce_set = mlx5_devlink_port_fn_roce_set,\n\t.port_fn_migratable_get = mlx5_devlink_port_fn_migratable_get,\n\t.port_fn_migratable_set = mlx5_devlink_port_fn_migratable_set,\n#ifdef CONFIG_XFRM_OFFLOAD\n\t.port_fn_ipsec_crypto_get = mlx5_devlink_port_fn_ipsec_crypto_get,\n\t.port_fn_ipsec_crypto_set = mlx5_devlink_port_fn_ipsec_crypto_set,\n\t.port_fn_ipsec_packet_get = mlx5_devlink_port_fn_ipsec_packet_get,\n\t.port_fn_ipsec_packet_set = mlx5_devlink_port_fn_ipsec_packet_set,\n#endif  \n};\n\nstatic void mlx5_esw_offloads_sf_devlink_port_attrs_set(struct mlx5_eswitch *esw,\n\t\t\t\t\t\t\tstruct devlink_port *dl_port,\n\t\t\t\t\t\t\tu32 controller, u32 sfnum)\n{\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct netdev_phys_item_id ppid = {};\n\tu16 pfnum;\n\n\tpfnum = mlx5_get_dev_index(dev);\n\tmlx5_esw_get_port_parent_id(dev, &ppid);\n\tmemcpy(dl_port->attrs.switch_id.id, &ppid.id[0], ppid.id_len);\n\tdl_port->attrs.switch_id.id_len = ppid.id_len;\n\tdevlink_port_attrs_pci_sf_set(dl_port, controller, pfnum, sfnum, !!controller);\n}\n\nint mlx5_esw_offloads_sf_devlink_port_init(struct mlx5_eswitch *esw, struct mlx5_vport *vport,\n\t\t\t\t\t   struct mlx5_devlink_port *dl_port,\n\t\t\t\t\t   u32 controller, u32 sfnum)\n{\n\tmlx5_esw_offloads_sf_devlink_port_attrs_set(esw, &dl_port->dl_port, controller, sfnum);\n\n\tvport->dl_port = dl_port;\n\tmlx5_devlink_port_init(dl_port, vport);\n\treturn 0;\n}\n\nvoid mlx5_esw_offloads_sf_devlink_port_cleanup(struct mlx5_eswitch *esw, struct mlx5_vport *vport)\n{\n\tvport->dl_port = NULL;\n}\n\nstatic const struct devlink_port_ops mlx5_esw_dl_sf_port_ops = {\n#ifdef CONFIG_MLX5_SF_MANAGER\n\t.port_del = mlx5_devlink_sf_port_del,\n#endif\n\t.port_fn_hw_addr_get = mlx5_devlink_port_fn_hw_addr_get,\n\t.port_fn_hw_addr_set = mlx5_devlink_port_fn_hw_addr_set,\n\t.port_fn_roce_get = mlx5_devlink_port_fn_roce_get,\n\t.port_fn_roce_set = mlx5_devlink_port_fn_roce_set,\n#ifdef CONFIG_MLX5_SF_MANAGER\n\t.port_fn_state_get = mlx5_devlink_sf_port_fn_state_get,\n\t.port_fn_state_set = mlx5_devlink_sf_port_fn_state_set,\n#endif\n};\n\nint mlx5_esw_offloads_devlink_port_register(struct mlx5_eswitch *esw, struct mlx5_vport *vport)\n{\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tconst struct devlink_port_ops *ops;\n\tstruct mlx5_devlink_port *dl_port;\n\tu16 vport_num = vport->vport;\n\tunsigned int dl_port_index;\n\tstruct devlink *devlink;\n\tint err;\n\n\tdl_port = vport->dl_port;\n\tif (!dl_port)\n\t\treturn 0;\n\n\tif (mlx5_esw_is_sf_vport(esw, vport_num))\n\t\tops = &mlx5_esw_dl_sf_port_ops;\n\telse if (mlx5_eswitch_is_pf_vf_vport(esw, vport_num))\n\t\tops = &mlx5_esw_pf_vf_dl_port_ops;\n\telse\n\t\tops = NULL;\n\n\tdevlink = priv_to_devlink(dev);\n\tdl_port_index = mlx5_esw_vport_to_devlink_port_index(dev, vport_num);\n\terr = devl_port_register_with_ops(devlink, &dl_port->dl_port, dl_port_index, ops);\n\tif (err)\n\t\treturn err;\n\n\terr = devl_rate_leaf_create(&dl_port->dl_port, vport, NULL);\n\tif (err)\n\t\tgoto rate_err;\n\n\treturn 0;\n\nrate_err:\n\tdevl_port_unregister(&dl_port->dl_port);\n\treturn err;\n}\n\nvoid mlx5_esw_offloads_devlink_port_unregister(struct mlx5_eswitch *esw, struct mlx5_vport *vport)\n{\n\tstruct mlx5_devlink_port *dl_port;\n\n\tif (!vport->dl_port)\n\t\treturn;\n\tdl_port = vport->dl_port;\n\n\tmlx5_esw_qos_vport_update_group(esw, vport, NULL, NULL);\n\tdevl_rate_leaf_destroy(&dl_port->dl_port);\n\n\tdevl_port_unregister(&dl_port->dl_port);\n}\n\nstruct devlink_port *mlx5_esw_offloads_devlink_port(struct mlx5_eswitch *esw, u16 vport_num)\n{\n\tstruct mlx5_vport *vport;\n\n\tvport = mlx5_eswitch_get_vport(esw, vport_num);\n\treturn IS_ERR(vport) ? ERR_CAST(vport) : &vport->dl_port->dl_port;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}