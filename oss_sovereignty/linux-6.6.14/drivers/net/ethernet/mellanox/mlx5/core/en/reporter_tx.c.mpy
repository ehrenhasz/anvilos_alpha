{
  "module_name": "reporter_tx.c",
  "hash_id": "d2edb1f67bd2b86df13d5ad3e84a32aa5fc290997ba3c4789ea6b332fb42372c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c",
  "human_readable_source": " \n \n\n#include \"health.h\"\n#include \"en/ptp.h\"\n#include \"en/devlink.h\"\n#include \"lib/tout.h\"\n\n \nstatic const char * const sq_sw_state_type_name[] = {\n\t[MLX5E_SQ_STATE_ENABLED] = \"enabled\",\n\t[MLX5E_SQ_STATE_MPWQE] = \"mpwqe\",\n\t[MLX5E_SQ_STATE_RECOVERING] = \"recovering\",\n\t[MLX5E_SQ_STATE_IPSEC] = \"ipsec\",\n\t[MLX5E_SQ_STATE_DIM] = \"dim\",\n\t[MLX5E_SQ_STATE_VLAN_NEED_L2_INLINE] = \"vlan_need_l2_inline\",\n\t[MLX5E_SQ_STATE_PENDING_XSK_TX] = \"pending_xsk_tx\",\n\t[MLX5E_SQ_STATE_PENDING_TLS_RX_RESYNC] = \"pending_tls_rx_resync\",\n\t[MLX5E_SQ_STATE_XDP_MULTIBUF] = \"xdp_multibuf\",\n};\n\nstatic int mlx5e_wait_for_sq_flush(struct mlx5e_txqsq *sq)\n{\n\tstruct mlx5_core_dev *dev = sq->mdev;\n\tunsigned long exp_time;\n\n\texp_time = jiffies + msecs_to_jiffies(mlx5_tout_ms(dev, FLUSH_ON_ERROR));\n\n\twhile (time_before(jiffies, exp_time)) {\n\t\tif (sq->cc == sq->pc)\n\t\t\treturn 0;\n\n\t\tmsleep(20);\n\t}\n\n\tnetdev_err(sq->netdev,\n\t\t   \"Wait for SQ 0x%x flush timeout (sq cc = 0x%x, sq pc = 0x%x)\\n\",\n\t\t   sq->sqn, sq->cc, sq->pc);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void mlx5e_reset_txqsq_cc_pc(struct mlx5e_txqsq *sq)\n{\n\tWARN_ONCE(sq->cc != sq->pc,\n\t\t  \"SQ 0x%x: cc (0x%x) != pc (0x%x)\\n\",\n\t\t  sq->sqn, sq->cc, sq->pc);\n\tsq->cc = 0;\n\tsq->dma_fifo_cc = 0;\n\tsq->pc = 0;\n}\n\nstatic int mlx5e_health_sq_put_sw_state(struct devlink_fmsg *fmsg, struct mlx5e_txqsq *sq)\n{\n\tint err;\n\tint i;\n\n\tBUILD_BUG_ON_MSG(ARRAY_SIZE(sq_sw_state_type_name) != MLX5E_NUM_SQ_STATES,\n\t\t\t \"sq_sw_state_type_name string array must be consistent with MLX5E_SQ_STATE_* enum in en.h\");\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"SW State\");\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(sq_sw_state_type_name); ++i) {\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, sq_sw_state_type_name[i],\n\t\t\t\t\t\ttest_bit(i, &sq->state));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n}\n\nstatic int mlx5e_tx_reporter_err_cqe_recover(void *ctx)\n{\n\tstruct mlx5_core_dev *mdev;\n\tstruct net_device *dev;\n\tstruct mlx5e_txqsq *sq;\n\tu8 state;\n\tint err;\n\n\tsq = ctx;\n\tmdev = sq->mdev;\n\tdev = sq->netdev;\n\n\tif (!test_bit(MLX5E_SQ_STATE_RECOVERING, &sq->state))\n\t\treturn 0;\n\n\terr = mlx5_core_query_sq_state(mdev, sq->sqn, &state);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to query SQ 0x%x state. err = %d\\n\",\n\t\t\t   sq->sqn, err);\n\t\tgoto out;\n\t}\n\n\tif (state != MLX5_SQC_STATE_ERR)\n\t\tgoto out;\n\n\tmlx5e_tx_disable_queue(sq->txq);\n\n\terr = mlx5e_wait_for_sq_flush(sq);\n\tif (err)\n\t\tgoto out;\n\n\t \n\n\terr = mlx5e_health_sq_to_ready(mdev, dev, sq->sqn);\n\tif (err)\n\t\tgoto out;\n\n\tmlx5e_reset_txqsq_cc_pc(sq);\n\tsq->stats->recover++;\n\tclear_bit(MLX5E_SQ_STATE_RECOVERING, &sq->state);\n\tmlx5e_activate_txqsq(sq);\n\tif (sq->channel)\n\t\tmlx5e_trigger_napi_icosq(sq->channel);\n\telse\n\t\tmlx5e_trigger_napi_sched(sq->cq.napi);\n\n\treturn 0;\nout:\n\tclear_bit(MLX5E_SQ_STATE_RECOVERING, &sq->state);\n\treturn err;\n}\n\nstruct mlx5e_tx_timeout_ctx {\n\tstruct mlx5e_txqsq *sq;\n\tsigned int status;\n};\n\nstatic int mlx5e_tx_reporter_timeout_recover(void *ctx)\n{\n\tstruct mlx5e_tx_timeout_ctx *to_ctx;\n\tstruct mlx5e_priv *priv;\n\tstruct mlx5_eq_comp *eq;\n\tstruct mlx5e_txqsq *sq;\n\tint err;\n\n\tto_ctx = ctx;\n\tsq = to_ctx->sq;\n\teq = sq->cq.mcq.eq;\n\tpriv = sq->priv;\n\terr = mlx5e_health_channel_eq_recover(sq->netdev, eq, sq->cq.ch_stats);\n\tif (!err) {\n\t\tto_ctx->status = 0;  \n\t\treturn err;\n\t}\n\n\terr = mlx5e_safe_reopen_channels(priv);\n\tif (!err) {\n\t\tto_ctx->status = 1;  \n\t\treturn err;\n\t}\n\n\tto_ctx->status = err;\n\tclear_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);\n\tnetdev_err(priv->netdev,\n\t\t   \"mlx5e_safe_reopen_channels failed recovering from a tx_timeout, err(%d).\\n\",\n\t\t   err);\n\n\treturn err;\n}\n\nstatic int mlx5e_tx_reporter_ptpsq_unhealthy_recover(void *ctx)\n{\n\tstruct mlx5e_ptpsq *ptpsq = ctx;\n\tstruct mlx5e_channels *chs;\n\tstruct net_device *netdev;\n\tstruct mlx5e_priv *priv;\n\tint carrier_ok;\n\tint err;\n\n\tif (!test_bit(MLX5E_SQ_STATE_RECOVERING, &ptpsq->txqsq.state))\n\t\treturn 0;\n\n\tpriv = ptpsq->txqsq.priv;\n\n\tmutex_lock(&priv->state_lock);\n\tchs = &priv->channels;\n\tnetdev = priv->netdev;\n\n\tcarrier_ok = netif_carrier_ok(netdev);\n\tnetif_carrier_off(netdev);\n\n\tmlx5e_deactivate_priv_channels(priv);\n\n\tmlx5e_ptp_close(chs->ptp);\n\terr = mlx5e_ptp_open(priv, &chs->params, chs->c[0]->lag_port, &chs->ptp);\n\n\tmlx5e_activate_priv_channels(priv);\n\n\t \n\tif (carrier_ok)\n\t\tnetif_carrier_on(netdev);\n\n\tmutex_unlock(&priv->state_lock);\n\n\treturn err;\n}\n\n \nstatic int mlx5e_tx_reporter_recover_from_ctx(struct mlx5e_err_ctx *err_ctx)\n{\n\treturn err_ctx->recover(err_ctx->ctx);\n}\n\nstatic int mlx5e_tx_reporter_recover(struct devlink_health_reporter *reporter,\n\t\t\t\t     void *context,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = devlink_health_reporter_priv(reporter);\n\tstruct mlx5e_err_ctx *err_ctx = context;\n\n\treturn err_ctx ? mlx5e_tx_reporter_recover_from_ctx(err_ctx) :\n\t\t\t mlx5e_health_recover_channels(priv);\n}\n\nstatic int\nmlx5e_tx_reporter_build_diagnose_output_sq_common(struct devlink_fmsg *fmsg,\n\t\t\t\t\t\t  struct mlx5e_txqsq *sq, int tc)\n{\n\tbool stopped = netif_xmit_stopped(sq->txq);\n\tstruct mlx5e_priv *priv = sq->priv;\n\tu8 state;\n\tint err;\n\n\terr = mlx5_core_query_sq_state(priv->mdev, sq->sqn, &state);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"tc\", tc);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"txq ix\", sq->txq_ix);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"sqn\", sq->sqn);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"HW state\", state);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_bool_pair_put(fmsg, \"stopped\", stopped);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"cc\", sq->cc);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"pc\", sq->pc);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_sq_put_sw_state(fmsg, sq);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_cq_diag_fmsg(&sq->cq, fmsg);\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5e_health_eq_diag_fmsg(sq->cq.mcq.eq, fmsg);\n}\n\nstatic int\nmlx5e_tx_reporter_build_diagnose_output(struct devlink_fmsg *fmsg,\n\t\t\t\t\tstruct mlx5e_txqsq *sq, int tc)\n{\n\tint err;\n\n\terr = devlink_fmsg_obj_nest_start(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"channel ix\", sq->ch_ix);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_tx_reporter_build_diagnose_output_sq_common(fmsg, sq, tc);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nmlx5e_tx_reporter_build_diagnose_output_ptpsq(struct devlink_fmsg *fmsg,\n\t\t\t\t\t      struct mlx5e_ptpsq *ptpsq, int tc)\n{\n\tint err;\n\n\terr = devlink_fmsg_obj_nest_start(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_string_pair_put(fmsg, \"channel\", \"ptp\");\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_tx_reporter_build_diagnose_output_sq_common(fmsg, &ptpsq->txqsq, tc);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"Port TS\");\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_cq_diag_fmsg(&ptpsq->ts_cq, fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nmlx5e_tx_reporter_diagnose_generic_txqsq(struct devlink_fmsg *fmsg,\n\t\t\t\t\t struct mlx5e_txqsq *txqsq)\n{\n\tu32 sq_stride, sq_sz;\n\tbool real_time;\n\tint err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"SQ\");\n\tif (err)\n\t\treturn err;\n\n\treal_time =  mlx5_is_real_time_sq(txqsq->mdev);\n\tsq_sz = mlx5_wq_cyc_get_size(&txqsq->wq);\n\tsq_stride = MLX5_SEND_WQE_BB;\n\n\terr = devlink_fmsg_u64_pair_put(fmsg, \"stride size\", sq_stride);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"size\", sq_sz);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_string_pair_put(fmsg, \"ts_format\", real_time ? \"RT\" : \"FRC\");\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_cq_common_diag_fmsg(&txqsq->cq, fmsg);\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n}\n\nstatic int\nmlx5e_tx_reporter_diagnose_generic_tx_port_ts(struct devlink_fmsg *fmsg,\n\t\t\t\t\t      struct mlx5e_ptpsq *ptpsq)\n{\n\tint err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"Port TS\");\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_cq_common_diag_fmsg(&ptpsq->ts_cq, fmsg);\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n}\n\nstatic int\nmlx5e_tx_reporter_diagnose_common_config(struct devlink_health_reporter *reporter,\n\t\t\t\t\t struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5e_priv *priv = devlink_health_reporter_priv(reporter);\n\tstruct mlx5e_txqsq *generic_sq = priv->txq2sq[0];\n\tstruct mlx5e_ptp *ptp_ch = priv->channels.ptp;\n\tstruct mlx5e_ptpsq *generic_ptpsq;\n\tint err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"Common Config\");\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_tx_reporter_diagnose_generic_txqsq(fmsg, generic_sq);\n\tif (err)\n\t\treturn err;\n\n\tif (!ptp_ch || !test_bit(MLX5E_PTP_STATE_TX, ptp_ch->state))\n\t\tgoto out;\n\n\tgeneric_ptpsq = &ptp_ch->ptpsq[0];\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"PTP\");\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_tx_reporter_diagnose_generic_txqsq(fmsg, &generic_ptpsq->txqsq);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_tx_reporter_diagnose_generic_tx_port_ts(fmsg, generic_ptpsq);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\nout:\n\treturn mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n}\n\nstatic int mlx5e_tx_reporter_diagnose(struct devlink_health_reporter *reporter,\n\t\t\t\t      struct devlink_fmsg *fmsg,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = devlink_health_reporter_priv(reporter);\n\tstruct mlx5e_ptp *ptp_ch = priv->channels.ptp;\n\n\tint i, tc, err = 0;\n\n\tmutex_lock(&priv->state_lock);\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state))\n\t\tgoto unlock;\n\n\terr = mlx5e_tx_reporter_diagnose_common_config(reporter, fmsg);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"SQs\");\n\tif (err)\n\t\tgoto unlock;\n\n\tfor (i = 0; i < priv->channels.num; i++) {\n\t\tstruct mlx5e_channel *c = priv->channels.c[i];\n\n\t\tfor (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {\n\t\t\tstruct mlx5e_txqsq *sq = &c->sq[tc];\n\n\t\t\terr = mlx5e_tx_reporter_build_diagnose_output(fmsg, sq, tc);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (!ptp_ch || !test_bit(MLX5E_PTP_STATE_TX, ptp_ch->state))\n\t\tgoto close_sqs_nest;\n\n\tfor (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {\n\t\terr = mlx5e_tx_reporter_build_diagnose_output_ptpsq(fmsg,\n\t\t\t\t\t\t\t\t    &ptp_ch->ptpsq[tc],\n\t\t\t\t\t\t\t\t    tc);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\nclose_sqs_nest:\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\tif (err)\n\t\tgoto unlock;\n\nunlock:\n\tmutex_unlock(&priv->state_lock);\n\treturn err;\n}\n\nstatic int mlx5e_tx_reporter_dump_sq(struct mlx5e_priv *priv, struct devlink_fmsg *fmsg,\n\t\t\t\t     void *ctx)\n{\n\tstruct mlx5_rsc_key key = {};\n\tstruct mlx5e_txqsq *sq = ctx;\n\tint err;\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state))\n\t\treturn 0;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"SX Slice\");\n\tif (err)\n\t\treturn err;\n\n\tkey.size = PAGE_SIZE;\n\tkey.rsc = MLX5_SGMT_TYPE_SX_SLICE_ALL;\n\terr = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"SQ\");\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"QPC\");\n\tif (err)\n\t\treturn err;\n\n\tkey.rsc = MLX5_SGMT_TYPE_FULL_QPC;\n\tkey.index1 = sq->sqn;\n\tkey.num_of_obj1 = 1;\n\n\terr = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"send_buff\");\n\tif (err)\n\t\treturn err;\n\n\tkey.rsc = MLX5_SGMT_TYPE_SND_BUFF;\n\tkey.num_of_obj2 = MLX5_RSC_DUMP_ALL;\n\terr = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\treturn mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n}\n\nstatic int mlx5e_tx_reporter_timeout_dump(struct mlx5e_priv *priv, struct devlink_fmsg *fmsg,\n\t\t\t\t\t  void *ctx)\n{\n\tstruct mlx5e_tx_timeout_ctx *to_ctx = ctx;\n\n\treturn mlx5e_tx_reporter_dump_sq(priv, fmsg, to_ctx->sq);\n}\n\nstatic int mlx5e_tx_reporter_ptpsq_unhealthy_dump(struct mlx5e_priv *priv,\n\t\t\t\t\t\t  struct devlink_fmsg *fmsg,\n\t\t\t\t\t\t  void *ctx)\n{\n\tstruct mlx5e_ptpsq *ptpsq = ctx;\n\n\treturn mlx5e_tx_reporter_dump_sq(priv, fmsg, &ptpsq->txqsq);\n}\n\nstatic int mlx5e_tx_reporter_dump_all_sqs(struct mlx5e_priv *priv,\n\t\t\t\t\t  struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5e_ptp *ptp_ch = priv->channels.ptp;\n\tstruct mlx5_rsc_key key = {};\n\tint i, tc, err;\n\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state))\n\t\treturn 0;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_start(fmsg, \"SX Slice\");\n\tif (err)\n\t\treturn err;\n\n\tkey.size = PAGE_SIZE;\n\tkey.rsc = MLX5_SGMT_TYPE_SX_SLICE_ALL;\n\terr = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_health_fmsg_named_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"SQs\");\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < priv->channels.num; i++) {\n\t\tstruct mlx5e_channel *c = priv->channels.c[i];\n\n\t\tfor (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {\n\t\t\tstruct mlx5e_txqsq *sq = &c->sq[tc];\n\n\t\t\terr = mlx5e_health_queue_dump(priv, fmsg, sq->sqn, \"SQ\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (ptp_ch && test_bit(MLX5E_PTP_STATE_TX, ptp_ch->state)) {\n\t\tfor (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {\n\t\t\tstruct mlx5e_txqsq *sq = &ptp_ch->ptpsq[tc].txqsq;\n\n\t\t\terr = mlx5e_health_queue_dump(priv, fmsg, sq->sqn, \"PTP SQ\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn devlink_fmsg_arr_pair_nest_end(fmsg);\n}\n\nstatic int mlx5e_tx_reporter_dump_from_ctx(struct mlx5e_priv *priv,\n\t\t\t\t\t   struct mlx5e_err_ctx *err_ctx,\n\t\t\t\t\t   struct devlink_fmsg *fmsg)\n{\n\treturn err_ctx->dump(priv, fmsg, err_ctx->ctx);\n}\n\nstatic int mlx5e_tx_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t\t  struct devlink_fmsg *fmsg, void *context,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = devlink_health_reporter_priv(reporter);\n\tstruct mlx5e_err_ctx *err_ctx = context;\n\n\treturn err_ctx ? mlx5e_tx_reporter_dump_from_ctx(priv, err_ctx, fmsg) :\n\t\t\t mlx5e_tx_reporter_dump_all_sqs(priv, fmsg);\n}\n\nvoid mlx5e_reporter_tx_err_cqe(struct mlx5e_txqsq *sq)\n{\n\tchar err_str[MLX5E_REPORTER_PER_Q_MAX_LEN];\n\tstruct mlx5e_priv *priv = sq->priv;\n\tstruct mlx5e_err_ctx err_ctx = {};\n\n\terr_ctx.ctx = sq;\n\terr_ctx.recover = mlx5e_tx_reporter_err_cqe_recover;\n\terr_ctx.dump = mlx5e_tx_reporter_dump_sq;\n\tsnprintf(err_str, sizeof(err_str), \"ERR CQE on SQ: 0x%x\", sq->sqn);\n\n\tmlx5e_health_report(priv, priv->tx_reporter, err_str, &err_ctx);\n}\n\nint mlx5e_reporter_tx_timeout(struct mlx5e_txqsq *sq)\n{\n\tchar err_str[MLX5E_REPORTER_PER_Q_MAX_LEN];\n\tstruct mlx5e_tx_timeout_ctx to_ctx = {};\n\tstruct mlx5e_priv *priv = sq->priv;\n\tstruct mlx5e_err_ctx err_ctx = {};\n\n\tto_ctx.sq = sq;\n\terr_ctx.ctx = &to_ctx;\n\terr_ctx.recover = mlx5e_tx_reporter_timeout_recover;\n\terr_ctx.dump = mlx5e_tx_reporter_timeout_dump;\n\tsnprintf(err_str, sizeof(err_str),\n\t\t \"TX timeout on queue: %d, SQ: 0x%x, CQ: 0x%x, SQ Cons: 0x%x SQ Prod: 0x%x, usecs since last trans: %u\",\n\t\t sq->ch_ix, sq->sqn, sq->cq.mcq.cqn, sq->cc, sq->pc,\n\t\t jiffies_to_usecs(jiffies - READ_ONCE(sq->txq->trans_start)));\n\n\tmlx5e_health_report(priv, priv->tx_reporter, err_str, &err_ctx);\n\treturn to_ctx.status;\n}\n\nvoid mlx5e_reporter_tx_ptpsq_unhealthy(struct mlx5e_ptpsq *ptpsq)\n{\n\tstruct mlx5e_ptp_metadata_map *map = &ptpsq->metadata_map;\n\tchar err_str[MLX5E_REPORTER_PER_Q_MAX_LEN];\n\tstruct mlx5e_txqsq *txqsq = &ptpsq->txqsq;\n\tstruct mlx5e_cq *ts_cq = &ptpsq->ts_cq;\n\tstruct mlx5e_priv *priv = txqsq->priv;\n\tstruct mlx5e_err_ctx err_ctx = {};\n\n\terr_ctx.ctx = ptpsq;\n\terr_ctx.recover = mlx5e_tx_reporter_ptpsq_unhealthy_recover;\n\terr_ctx.dump = mlx5e_tx_reporter_ptpsq_unhealthy_dump;\n\tsnprintf(err_str, sizeof(err_str),\n\t\t \"Unhealthy TX port TS queue: %d, SQ: 0x%x, CQ: 0x%x, Undelivered CQEs: %u Map Capacity: %u\",\n\t\t txqsq->ch_ix, txqsq->sqn, ts_cq->mcq.cqn, map->undelivered_counter, map->capacity);\n\n\tmlx5e_health_report(priv, priv->tx_reporter, err_str, &err_ctx);\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_tx_reporter_ops = {\n\t\t.name = \"tx\",\n\t\t.recover = mlx5e_tx_reporter_recover,\n\t\t.diagnose = mlx5e_tx_reporter_diagnose,\n\t\t.dump = mlx5e_tx_reporter_dump,\n};\n\n#define MLX5_REPORTER_TX_GRACEFUL_PERIOD 500\n\nvoid mlx5e_reporter_tx_create(struct mlx5e_priv *priv)\n{\n\tstruct devlink_health_reporter *reporter;\n\n\treporter = devlink_port_health_reporter_create(priv->netdev->devlink_port,\n\t\t\t\t\t\t       &mlx5_tx_reporter_ops,\n\t\t\t\t\t\t       MLX5_REPORTER_TX_GRACEFUL_PERIOD, priv);\n\tif (IS_ERR(reporter)) {\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Failed to create tx reporter, err = %ld\\n\",\n\t\t\t    PTR_ERR(reporter));\n\t\treturn;\n\t}\n\tpriv->tx_reporter = reporter;\n}\n\nvoid mlx5e_reporter_tx_destroy(struct mlx5e_priv *priv)\n{\n\tif (!priv->tx_reporter)\n\t\treturn;\n\n\tdevlink_health_reporter_destroy(priv->tx_reporter);\n\tpriv->tx_reporter = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}