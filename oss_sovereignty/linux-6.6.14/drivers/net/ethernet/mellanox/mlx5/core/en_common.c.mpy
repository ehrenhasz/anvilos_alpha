{
  "module_name": "en_common.c",
  "hash_id": "b1f9f0dfd1c944ca1ac5a973f47ac48fb1e93763d264a886d98924fa8ceca256",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_common.c",
  "human_readable_source": " \n\n#include \"en.h\"\n#include \"lib/crypto.h\"\n\n \n\nvoid mlx5e_mkey_set_relaxed_ordering(struct mlx5_core_dev *mdev, void *mkc)\n{\n\tbool ro_write = MLX5_CAP_GEN(mdev, relaxed_ordering_write);\n\tbool ro_read = MLX5_CAP_GEN(mdev, relaxed_ordering_read) ||\n\t\t       (pcie_relaxed_ordering_enabled(mdev->pdev) &&\n\t\t\tMLX5_CAP_GEN(mdev, relaxed_ordering_read_pci_enabled));\n\n\tMLX5_SET(mkc, mkc, relaxed_ordering_read, ro_read);\n\tMLX5_SET(mkc, mkc, relaxed_ordering_write, ro_write);\n}\n\nint mlx5e_create_mkey(struct mlx5_core_dev *mdev, u32 pdn, u32 *mkey)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_mkey_in);\n\tvoid *mkc;\n\tu32 *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\tMLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);\n\tMLX5_SET(mkc, mkc, lw, 1);\n\tMLX5_SET(mkc, mkc, lr, 1);\n\tmlx5e_mkey_set_relaxed_ordering(mdev, mkc);\n\tMLX5_SET(mkc, mkc, pd, pdn);\n\tMLX5_SET(mkc, mkc, length64, 1);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\n\terr = mlx5_core_create_mkey(mdev, mkey, in, inlen);\n\n\tkvfree(in);\n\treturn err;\n}\n\nint mlx5e_create_mdev_resources(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5e_hw_objs *res = &mdev->mlx5e_res.hw_objs;\n\tint err;\n\n\terr = mlx5_core_alloc_pd(mdev, &res->pdn);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"alloc pd failed, %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = mlx5_core_alloc_transport_domain(mdev, &res->td.tdn);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"alloc td failed, %d\\n\", err);\n\t\tgoto err_dealloc_pd;\n\t}\n\n\terr = mlx5e_create_mkey(mdev, res->pdn, &res->mkey);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"create mkey failed, %d\\n\", err);\n\t\tgoto err_dealloc_transport_domain;\n\t}\n\n\terr = mlx5_alloc_bfreg(mdev, &res->bfreg, false, false);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"alloc bfreg failed, %d\\n\", err);\n\t\tgoto err_destroy_mkey;\n\t}\n\n\tINIT_LIST_HEAD(&res->td.tirs_list);\n\tmutex_init(&res->td.list_lock);\n\n\tmdev->mlx5e_res.dek_priv = mlx5_crypto_dek_init(mdev);\n\tif (IS_ERR(mdev->mlx5e_res.dek_priv)) {\n\t\tmlx5_core_err(mdev, \"crypto dek init failed, %ld\\n\",\n\t\t\t      PTR_ERR(mdev->mlx5e_res.dek_priv));\n\t\tmdev->mlx5e_res.dek_priv = NULL;\n\t}\n\n\treturn 0;\n\nerr_destroy_mkey:\n\tmlx5_core_destroy_mkey(mdev, res->mkey);\nerr_dealloc_transport_domain:\n\tmlx5_core_dealloc_transport_domain(mdev, res->td.tdn);\nerr_dealloc_pd:\n\tmlx5_core_dealloc_pd(mdev, res->pdn);\n\treturn err;\n}\n\nvoid mlx5e_destroy_mdev_resources(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5e_hw_objs *res = &mdev->mlx5e_res.hw_objs;\n\n\tmlx5_crypto_dek_cleanup(mdev->mlx5e_res.dek_priv);\n\tmdev->mlx5e_res.dek_priv = NULL;\n\tmlx5_free_bfreg(mdev, &res->bfreg);\n\tmlx5_core_destroy_mkey(mdev, res->mkey);\n\tmlx5_core_dealloc_transport_domain(mdev, res->td.tdn);\n\tmlx5_core_dealloc_pd(mdev, res->pdn);\n\tmemset(res, 0, sizeof(*res));\n}\n\nint mlx5e_refresh_tirs(struct mlx5e_priv *priv, bool enable_uc_lb,\n\t\t       bool enable_mc_lb)\n{\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5e_tir *tir;\n\tu8 lb_flags = 0;\n\tint err  = 0;\n\tu32 tirn = 0;\n\tint inlen;\n\tvoid *in;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_tir_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tif (enable_uc_lb)\n\t\tlb_flags = MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST;\n\n\tif (enable_mc_lb)\n\t\tlb_flags |= MLX5_TIRC_SELF_LB_BLOCK_BLOCK_MULTICAST;\n\n\tif (lb_flags)\n\t\tMLX5_SET(modify_tir_in, in, ctx.self_lb_block, lb_flags);\n\n\tMLX5_SET(modify_tir_in, in, bitmask.self_lb_en, 1);\n\n\tmutex_lock(&mdev->mlx5e_res.hw_objs.td.list_lock);\n\tlist_for_each_entry(tir, &mdev->mlx5e_res.hw_objs.td.tirs_list, list) {\n\t\ttirn = tir->tirn;\n\t\terr = mlx5_core_modify_tir(mdev, tirn, in);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&mdev->mlx5e_res.hw_objs.td.list_lock);\n\n\tkvfree(in);\n\tif (err)\n\t\tnetdev_err(priv->netdev, \"refresh tir(0x%x) failed, %d\\n\", tirn, err);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}