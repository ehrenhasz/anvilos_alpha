{
  "module_name": "tc.c",
  "hash_id": "8ad641f29a19ee041ea6e31fd13cde0f4ef1c60587cb6683be5cc554a7428087",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/if_macvlan.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/rtnetlink.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include \"tc.h\"\n#include \"neigh.h\"\n#include \"en_rep.h\"\n#include \"eswitch.h\"\n#include \"lib/fs_chains.h\"\n#include \"en/tc_ct.h\"\n#include \"en/mapping.h\"\n#include \"en/tc_tun.h\"\n#include \"lib/port_tun.h\"\n#include \"en/tc/sample.h\"\n#include \"en_accel/ipsec_rxtx.h\"\n#include \"en/tc/int_port.h\"\n#include \"en/tc/act/act.h\"\n\nstruct mlx5e_rep_indr_block_priv {\n\tstruct net_device *netdev;\n\tstruct mlx5e_rep_priv *rpriv;\n\tenum flow_block_binder_type binder_type;\n\n\tstruct list_head list;\n};\n\nint mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,\n\t\t\t\t struct mlx5e_encap_entry *e,\n\t\t\t\t struct mlx5e_neigh *m_neigh,\n\t\t\t\t struct net_device *neigh_dev)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5_rep_uplink_priv *uplink_priv = &rpriv->uplink_priv;\n\tstruct mlx5_tun_entropy *tun_entropy = &uplink_priv->tun_entropy;\n\tstruct mlx5e_neigh_hash_entry *nhe;\n\tint err;\n\n\terr = mlx5_tun_entropy_refcount_inc(tun_entropy, e->reformat_type);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&rpriv->neigh_update.encap_lock);\n\tnhe = mlx5e_rep_neigh_entry_lookup(priv, m_neigh);\n\tif (!nhe) {\n\t\terr = mlx5e_rep_neigh_entry_create(priv, m_neigh, neigh_dev, &nhe);\n\t\tif (err) {\n\t\t\tmutex_unlock(&rpriv->neigh_update.encap_lock);\n\t\t\tmlx5_tun_entropy_refcount_dec(tun_entropy,\n\t\t\t\t\t\t      e->reformat_type);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\te->nhe = nhe;\n\tspin_lock(&nhe->encap_list_lock);\n\tlist_add_rcu(&e->encap_list, &nhe->encap_list);\n\tspin_unlock(&nhe->encap_list_lock);\n\n\tmutex_unlock(&rpriv->neigh_update.encap_lock);\n\n\treturn 0;\n}\n\nvoid mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5e_encap_entry *e)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\tstruct mlx5_rep_uplink_priv *uplink_priv = &rpriv->uplink_priv;\n\tstruct mlx5_tun_entropy *tun_entropy = &uplink_priv->tun_entropy;\n\n\tif (!e->nhe)\n\t\treturn;\n\n\tspin_lock(&e->nhe->encap_list_lock);\n\tlist_del_rcu(&e->encap_list);\n\tspin_unlock(&e->nhe->encap_list_lock);\n\n\tmlx5e_rep_neigh_entry_release(e->nhe);\n\te->nhe = NULL;\n\tmlx5_tun_entropy_refcount_dec(tun_entropy, e->reformat_type);\n}\n\nvoid mlx5e_rep_update_flows(struct mlx5e_priv *priv,\n\t\t\t    struct mlx5e_encap_entry *e,\n\t\t\t    bool neigh_connected,\n\t\t\t    unsigned char ha[ETH_ALEN])\n{\n\tstruct ethhdr *eth = (struct ethhdr *)e->encap_header;\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tbool encap_connected;\n\tLIST_HEAD(flow_list);\n\n\tASSERT_RTNL();\n\n\tmutex_lock(&esw->offloads.encap_tbl_lock);\n\tencap_connected = !!(e->flags & MLX5_ENCAP_ENTRY_VALID);\n\tif (encap_connected == neigh_connected && ether_addr_equal(e->h_dest, ha))\n\t\tgoto unlock;\n\n\tmlx5e_take_all_encap_flows(e, &flow_list);\n\n\tif ((e->flags & MLX5_ENCAP_ENTRY_VALID) &&\n\t    (!neigh_connected || !ether_addr_equal(e->h_dest, ha)))\n\t\tmlx5e_tc_encap_flows_del(priv, e, &flow_list);\n\n\tif (neigh_connected && !(e->flags & MLX5_ENCAP_ENTRY_VALID)) {\n\t\tstruct net_device *route_dev;\n\n\t\tether_addr_copy(e->h_dest, ha);\n\t\tether_addr_copy(eth->h_dest, ha);\n\t\t \n\t\troute_dev = __dev_get_by_index(dev_net(priv->netdev), e->route_dev_ifindex);\n\t\tif (route_dev)\n\t\t\tether_addr_copy(eth->h_source, route_dev->dev_addr);\n\n\t\tmlx5e_tc_encap_flows_add(priv, e, &flow_list);\n\t}\nunlock:\n\tmutex_unlock(&esw->offloads.encap_tbl_lock);\n\tmlx5e_put_flow_list(priv, &flow_list);\n}\n\nstatic int\nmlx5e_rep_setup_tc_cls_flower(struct mlx5e_priv *priv,\n\t\t\t      struct flow_cls_offload *cls_flower, int flags)\n{\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn mlx5e_configure_flower(priv->netdev, priv, cls_flower,\n\t\t\t\t\t      flags);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn mlx5e_delete_flower(priv->netdev, priv, cls_flower,\n\t\t\t\t\t   flags);\n\tcase FLOW_CLS_STATS:\n\t\treturn mlx5e_stats_flower(priv->netdev, priv, cls_flower,\n\t\t\t\t\t  flags);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic\nint mlx5e_rep_setup_tc_cls_matchall(struct mlx5e_priv *priv,\n\t\t\t\t    struct tc_cls_matchall_offload *ma)\n{\n\tswitch (ma->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn mlx5e_tc_configure_matchall(priv, ma);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\treturn mlx5e_tc_delete_matchall(priv, ma);\n\tcase TC_CLSMATCHALL_STATS:\n\t\tmlx5e_tc_stats_matchall(priv, ma);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlx5e_rep_setup_tc_cb(enum tc_setup_type type, void *type_data,\n\t\t\t\t void *cb_priv)\n{\n\tunsigned long flags = MLX5_TC_FLAG(INGRESS) | MLX5_TC_FLAG(ESW_OFFLOAD);\n\tstruct mlx5e_priv *priv = cb_priv;\n\n\tif (!priv->netdev || !netif_device_present(priv->netdev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn mlx5e_rep_setup_tc_cls_flower(priv, type_data, flags);\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn mlx5e_rep_setup_tc_cls_matchall(priv, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlx5e_rep_setup_ft_cb(enum tc_setup_type type, void *type_data,\n\t\t\t\t void *cb_priv)\n{\n\tstruct flow_cls_offload tmp, *f = type_data;\n\tstruct mlx5e_priv *priv = cb_priv;\n\tstruct mlx5_eswitch *esw;\n\tunsigned long flags;\n\tint err;\n\n\tflags = MLX5_TC_FLAG(INGRESS) |\n\t\tMLX5_TC_FLAG(ESW_OFFLOAD) |\n\t\tMLX5_TC_FLAG(FT_OFFLOAD);\n\tesw = priv->mdev->priv.eswitch;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\tmemcpy(&tmp, f, sizeof(*f));\n\n\t\tif (!mlx5_chains_prios_supported(esw_chains(esw)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tmp.common.prio >= mlx5_chains_get_prio_range(esw_chains(esw)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (tmp.common.chain_index != 0)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ttmp.common.chain_index = mlx5_chains_get_nf_ft_chain(esw_chains(esw));\n\t\ttmp.common.prio++;\n\t\terr = mlx5e_rep_setup_tc_cls_flower(priv, &tmp, flags);\n\t\tmemcpy(&f->stats, &tmp.stats, sizeof(f->stats));\n\t\treturn err;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(mlx5e_rep_block_tc_cb_list);\nstatic LIST_HEAD(mlx5e_rep_block_ft_cb_list);\nint mlx5e_rep_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t       void *type_data)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct flow_block_offload *f = type_data;\n\n\tf->unlocked_driver_cb = true;\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &mlx5e_rep_block_tc_cb_list,\n\t\t\t\t\t\t  mlx5e_rep_setup_tc_cb,\n\t\t\t\t\t\t  priv, priv, true);\n\tcase TC_SETUP_FT:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &mlx5e_rep_block_ft_cb_list,\n\t\t\t\t\t\t  mlx5e_rep_setup_ft_cb,\n\t\t\t\t\t\t  priv, priv, true);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint mlx5e_rep_tc_init(struct mlx5e_rep_priv *rpriv)\n{\n\tstruct mlx5_rep_uplink_priv *uplink_priv = &rpriv->uplink_priv;\n\tint err;\n\n\tmutex_init(&uplink_priv->unready_flows_lock);\n\tINIT_LIST_HEAD(&uplink_priv->unready_flows);\n\n\t \n\terr = mlx5e_tc_esw_init(uplink_priv);\n\treturn err;\n}\n\nvoid mlx5e_rep_tc_cleanup(struct mlx5e_rep_priv *rpriv)\n{\n\t \n\tmlx5e_tc_esw_cleanup(&rpriv->uplink_priv);\n\tmutex_destroy(&rpriv->uplink_priv.unready_flows_lock);\n}\n\nvoid mlx5e_rep_tc_enable(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\n\tINIT_WORK(&rpriv->uplink_priv.reoffload_flows_work,\n\t\t  mlx5e_tc_reoffload_flows_work);\n}\n\nvoid mlx5e_rep_tc_disable(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\n\tcancel_work_sync(&rpriv->uplink_priv.reoffload_flows_work);\n}\n\nint mlx5e_rep_tc_event_port_affinity(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_rep_priv *rpriv = priv->ppriv;\n\n\tqueue_work(priv->wq, &rpriv->uplink_priv.reoffload_flows_work);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct mlx5e_rep_indr_block_priv *\nmlx5e_rep_indr_block_priv_lookup(struct mlx5e_rep_priv *rpriv,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t enum flow_block_binder_type binder_type)\n{\n\tstruct mlx5e_rep_indr_block_priv *cb_priv;\n\n\tlist_for_each_entry(cb_priv,\n\t\t\t    &rpriv->uplink_priv.tc_indr_block_priv_list,\n\t\t\t    list)\n\t\tif (cb_priv->netdev == netdev &&\n\t\t    cb_priv->binder_type == binder_type)\n\t\t\treturn cb_priv;\n\n\treturn NULL;\n}\n\nstatic int\nmlx5e_rep_indr_offload(struct net_device *netdev,\n\t\t       struct flow_cls_offload *flower,\n\t\t       struct mlx5e_rep_indr_block_priv *indr_priv,\n\t\t       unsigned long flags)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(indr_priv->rpriv->netdev);\n\tint err = 0;\n\n\tif (!netif_device_present(indr_priv->rpriv->netdev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\terr = mlx5e_configure_flower(netdev, priv, flower, flags);\n\t\tbreak;\n\tcase FLOW_CLS_DESTROY:\n\t\terr = mlx5e_delete_flower(netdev, priv, flower, flags);\n\t\tbreak;\n\tcase FLOW_CLS_STATS:\n\t\terr = mlx5e_stats_flower(netdev, priv, flower, flags);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5e_rep_indr_setup_tc_cb(enum tc_setup_type type,\n\t\t\t\t      void *type_data, void *indr_priv)\n{\n\tunsigned long flags = MLX5_TC_FLAG(ESW_OFFLOAD);\n\tstruct mlx5e_rep_indr_block_priv *priv = indr_priv;\n\n\tflags |= (priv->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS) ?\n\t\tMLX5_TC_FLAG(EGRESS) :\n\t\tMLX5_TC_FLAG(INGRESS);\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn mlx5e_rep_indr_offload(priv->netdev, type_data, priv,\n\t\t\t\t\t      flags);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlx5e_rep_indr_setup_ft_cb(enum tc_setup_type type,\n\t\t\t\t      void *type_data, void *indr_priv)\n{\n\tstruct mlx5e_rep_indr_block_priv *priv = indr_priv;\n\tstruct flow_cls_offload *f = type_data;\n\tstruct flow_cls_offload tmp;\n\tstruct mlx5e_priv *mpriv;\n\tstruct mlx5_eswitch *esw;\n\tunsigned long flags;\n\tint err;\n\n\tmpriv = netdev_priv(priv->rpriv->netdev);\n\tesw = mpriv->mdev->priv.eswitch;\n\n\tflags = MLX5_TC_FLAG(EGRESS) |\n\t\tMLX5_TC_FLAG(ESW_OFFLOAD) |\n\t\tMLX5_TC_FLAG(FT_OFFLOAD);\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\tmemcpy(&tmp, f, sizeof(*f));\n\n\t\t \n\t\tif (!mlx5_chains_prios_supported(esw_chains(esw)) ||\n\t\t    tmp.common.prio >= mlx5_chains_get_prio_range(esw_chains(esw)) ||\n\t\t    tmp.common.chain_index)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ttmp.common.chain_index = mlx5_chains_get_nf_ft_chain(esw_chains(esw));\n\t\ttmp.common.prio++;\n\t\terr = mlx5e_rep_indr_offload(priv->netdev, &tmp, priv, flags);\n\t\tmemcpy(&f->stats, &tmp.stats, sizeof(f->stats));\n\t\treturn err;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void mlx5e_rep_indr_block_unbind(void *cb_priv)\n{\n\tstruct mlx5e_rep_indr_block_priv *indr_priv = cb_priv;\n\n\tlist_del(&indr_priv->list);\n\tkfree(indr_priv);\n}\n\nstatic LIST_HEAD(mlx5e_block_cb_list);\n\nstatic bool mlx5e_rep_macvlan_mode_supported(const struct net_device *dev)\n{\n\tstruct macvlan_dev *macvlan = netdev_priv(dev);\n\n\treturn macvlan->mode == MACVLAN_MODE_PASSTHRU;\n}\n\nstatic bool\nmlx5e_rep_check_indr_block_supported(struct mlx5e_rep_priv *rpriv,\n\t\t\t\t     struct net_device *netdev,\n\t\t\t\t     struct flow_block_offload *f)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(rpriv->netdev);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct net_device *macvlan_real_dev;\n\n\tif (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS &&\n\t    f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS)\n\t\treturn false;\n\n\tif (mlx5e_tc_tun_device_to_offload(priv, netdev))\n\t\treturn true;\n\n\tif (is_vlan_dev(netdev) && vlan_dev_real_dev(netdev) == rpriv->netdev)\n\t\treturn true;\n\n\tif (netif_is_macvlan(netdev)) {\n\t\tif (!mlx5e_rep_macvlan_mode_supported(netdev)) {\n\t\t\tnetdev_warn(netdev, \"Offloading ingress filter is supported only with macvlan passthru mode\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmacvlan_real_dev = macvlan_dev_real_dev(netdev);\n\n\t\tif (macvlan_real_dev == rpriv->netdev)\n\t\t\treturn true;\n\t\tif (netif_is_bond_master(macvlan_real_dev))\n\t\t\treturn true;\n\t}\n\n\tif (netif_is_ovs_master(netdev) && f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS &&\n\t    mlx5e_tc_int_port_supported(esw))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\nmlx5e_rep_indr_setup_block(struct net_device *netdev, struct Qdisc *sch,\n\t\t\t   struct mlx5e_rep_priv *rpriv,\n\t\t\t   struct flow_block_offload *f,\n\t\t\t   flow_setup_cb_t *setup_cb,\n\t\t\t   void *data,\n\t\t\t   void (*cleanup)(struct flow_block_cb *block_cb))\n{\n\tstruct mlx5e_rep_indr_block_priv *indr_priv;\n\tstruct flow_block_cb *block_cb;\n\n\tif (!mlx5e_rep_check_indr_block_supported(rpriv, netdev, f))\n\t\treturn -EOPNOTSUPP;\n\n\tf->unlocked_driver_cb = true;\n\tf->driver_block_list = &mlx5e_block_cb_list;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tindr_priv = mlx5e_rep_indr_block_priv_lookup(rpriv, netdev, f->binder_type);\n\t\tif (indr_priv)\n\t\t\treturn -EEXIST;\n\n\t\tindr_priv = kmalloc(sizeof(*indr_priv), GFP_KERNEL);\n\t\tif (!indr_priv)\n\t\t\treturn -ENOMEM;\n\n\t\tindr_priv->netdev = netdev;\n\t\tindr_priv->rpriv = rpriv;\n\t\tindr_priv->binder_type = f->binder_type;\n\t\tlist_add(&indr_priv->list,\n\t\t\t &rpriv->uplink_priv.tc_indr_block_priv_list);\n\n\t\tblock_cb = flow_indr_block_cb_alloc(setup_cb, indr_priv, indr_priv,\n\t\t\t\t\t\t    mlx5e_rep_indr_block_unbind,\n\t\t\t\t\t\t    f, netdev, sch, data, rpriv,\n\t\t\t\t\t\t    cleanup);\n\t\tif (IS_ERR(block_cb)) {\n\t\t\tlist_del(&indr_priv->list);\n\t\t\tkfree(indr_priv);\n\t\t\treturn PTR_ERR(block_cb);\n\t\t}\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &mlx5e_block_cb_list);\n\n\t\treturn 0;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tindr_priv = mlx5e_rep_indr_block_priv_lookup(rpriv, netdev, f->binder_type);\n\t\tif (!indr_priv)\n\t\t\treturn -ENOENT;\n\n\t\tblock_cb = flow_block_cb_lookup(f->block, setup_cb, indr_priv);\n\t\tif (!block_cb)\n\t\t\treturn -ENOENT;\n\n\t\tflow_indr_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlx5e_rep_indr_replace_act(struct mlx5e_rep_priv *rpriv,\n\t\t\t   struct flow_offload_action *fl_act)\n\n{\n\tstruct mlx5e_priv *priv = netdev_priv(rpriv->netdev);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct flow_action_entry *action;\n\tstruct mlx5e_tc_act *act;\n\tbool add = false;\n\tint i;\n\n\t \n\tif (!flow_offload_has_one_action(&fl_act->action))\n\t\treturn -EOPNOTSUPP;\n\n\tif (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)\n\t\tns_type = MLX5_FLOW_NAMESPACE_FDB;\n\telse\n\t\tns_type = MLX5_FLOW_NAMESPACE_KERNEL;\n\n\tflow_action_for_each(i, action, &fl_act->action) {\n\t\tact = mlx5e_tc_act_get(action->id, ns_type);\n\t\tif (!act)\n\t\t\tcontinue;\n\n\t\tif (!act->offload_action)\n\t\t\tcontinue;\n\n\t\tif (!act->offload_action(priv, fl_act, action))\n\t\t\tadd = true;\n\t}\n\n\treturn add ? 0 : -EOPNOTSUPP;\n}\n\nstatic int\nmlx5e_rep_indr_destroy_act(struct mlx5e_rep_priv *rpriv,\n\t\t\t   struct flow_offload_action *fl_act)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(rpriv->netdev);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5e_tc_act *act;\n\n\tif (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)\n\t\tns_type = MLX5_FLOW_NAMESPACE_FDB;\n\telse\n\t\tns_type = MLX5_FLOW_NAMESPACE_KERNEL;\n\n\tact = mlx5e_tc_act_get(fl_act->id, ns_type);\n\tif (!act || !act->destroy_action)\n\t\treturn -EOPNOTSUPP;\n\n\treturn act->destroy_action(priv, fl_act);\n}\n\nstatic int\nmlx5e_rep_indr_stats_act(struct mlx5e_rep_priv *rpriv,\n\t\t\t struct flow_offload_action *fl_act)\n\n{\n\tstruct mlx5e_priv *priv = netdev_priv(rpriv->netdev);\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5e_tc_act *act;\n\n\tif (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)\n\t\tns_type = MLX5_FLOW_NAMESPACE_FDB;\n\telse\n\t\tns_type = MLX5_FLOW_NAMESPACE_KERNEL;\n\n\tact = mlx5e_tc_act_get(fl_act->id, ns_type);\n\tif (!act || !act->stats_action)\n\t\treturn mlx5e_tc_fill_action_stats(priv, fl_act);\n\n\treturn act->stats_action(priv, fl_act);\n}\n\nstatic int\nmlx5e_rep_indr_setup_act(struct mlx5e_rep_priv *rpriv,\n\t\t\t struct flow_offload_action *fl_act)\n{\n\tswitch (fl_act->command) {\n\tcase FLOW_ACT_REPLACE:\n\t\treturn mlx5e_rep_indr_replace_act(rpriv, fl_act);\n\tcase FLOW_ACT_DESTROY:\n\t\treturn mlx5e_rep_indr_destroy_act(rpriv, fl_act);\n\tcase FLOW_ACT_STATS:\n\t\treturn mlx5e_rep_indr_stats_act(rpriv, fl_act);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nmlx5e_rep_indr_no_dev_setup(struct mlx5e_rep_priv *rpriv,\n\t\t\t    enum tc_setup_type type,\n\t\t\t    void *data)\n{\n\tif (!data)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_ACT:\n\t\treturn mlx5e_rep_indr_setup_act(rpriv, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic\nint mlx5e_rep_indr_setup_cb(struct net_device *netdev, struct Qdisc *sch, void *cb_priv,\n\t\t\t    enum tc_setup_type type, void *type_data,\n\t\t\t    void *data,\n\t\t\t    void (*cleanup)(struct flow_block_cb *block_cb))\n{\n\tif (!netdev)\n\t\treturn mlx5e_rep_indr_no_dev_setup(cb_priv, type, data);\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn mlx5e_rep_indr_setup_block(netdev, sch, cb_priv, type_data,\n\t\t\t\t\t\t  mlx5e_rep_indr_setup_tc_cb,\n\t\t\t\t\t\t  data, cleanup);\n\tcase TC_SETUP_FT:\n\t\treturn mlx5e_rep_indr_setup_block(netdev, sch, cb_priv, type_data,\n\t\t\t\t\t\t  mlx5e_rep_indr_setup_ft_cb,\n\t\t\t\t\t\t  data, cleanup);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint mlx5e_rep_tc_netdevice_event_register(struct mlx5e_rep_priv *rpriv)\n{\n\tstruct mlx5_rep_uplink_priv *uplink_priv = &rpriv->uplink_priv;\n\n\t \n\tINIT_LIST_HEAD(&uplink_priv->tc_indr_block_priv_list);\n\n\treturn flow_indr_dev_register(mlx5e_rep_indr_setup_cb, rpriv);\n}\n\nvoid mlx5e_rep_tc_netdevice_event_unregister(struct mlx5e_rep_priv *rpriv)\n{\n\tflow_indr_dev_unregister(mlx5e_rep_indr_setup_cb, rpriv,\n\t\t\t\t mlx5e_rep_indr_block_unbind);\n}\n\nvoid mlx5e_rep_tc_receive(struct mlx5_cqe64 *cqe, struct mlx5e_rq *rq,\n\t\t\t  struct sk_buff *skb)\n{\n\tu32 reg_c0, reg_c1, zone_restore_id, tunnel_id;\n\tstruct mlx5e_tc_update_priv tc_priv = {};\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct mlx5_tc_ct_priv *ct_priv;\n\tstruct mapping_ctx *mapping_ctx;\n\tstruct mlx5_eswitch *esw;\n\tstruct mlx5e_priv *priv;\n\n\treg_c0 = (be32_to_cpu(cqe->sop_drop_qpn) & MLX5E_TC_FLOW_ID_MASK);\n\tif (!reg_c0 || reg_c0 == MLX5_FS_DEFAULT_FLOW_TAG)\n\t\tgoto forward;\n\n\t \n\tskb->mark = 0;\n\n\tpriv = netdev_priv(skb->dev);\n\tesw = priv->mdev->priv.eswitch;\n\tmapping_ctx = esw->offloads.reg_c0_obj_pool;\n\treg_c1 = be32_to_cpu(cqe->ft_metadata);\n\tzone_restore_id = reg_c1 & ESW_ZONE_ID_MASK;\n\ttunnel_id = (reg_c1 >> ESW_TUN_OFFSET) & TUNNEL_ID_MASK;\n\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &uplink_rpriv->uplink_priv;\n\tct_priv = uplink_priv->ct_priv;\n\n#ifdef CONFIG_MLX5_EN_IPSEC\n\tif (!(tunnel_id >> ESW_TUN_OPTS_BITS)) {\n\t\tu32 mapped_id;\n\t\tu32 metadata;\n\n\t\tmapped_id = tunnel_id & ESW_IPSEC_RX_MAPPED_ID_MASK;\n\t\tif (mapped_id &&\n\t\t    !mlx5_esw_ipsec_rx_make_metadata(priv, mapped_id, &metadata))\n\t\t\tmlx5e_ipsec_offload_handle_rx_skb(priv->netdev, skb, metadata);\n\t}\n#endif\n\n\tif (!mlx5e_tc_update_skb(cqe, skb, mapping_ctx, reg_c0, ct_priv,\n\t\t\t\t zone_restore_id, tunnel_id, &tc_priv))\n\t\tgoto free_skb;\n\nforward:\n\tif (tc_priv.skb_done)\n\t\tgoto free_skb;\n\n\tif (tc_priv.forward_tx)\n\t\tdev_queue_xmit(skb);\n\telse\n\t\tnapi_gro_receive(rq->cq.napi, skb);\n\n\tdev_put(tc_priv.fwd_dev);\n\n\treturn;\n\nfree_skb:\n\tdev_put(tc_priv.fwd_dev);\n\tdev_kfree_skb_any(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}