{
  "module_name": "bridge_debugfs.c",
  "hash_id": "c2aa6c8e0428a8b31a47bfdadec9dd489d6c767ab85bf2941aaad4ba563e1a73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include \"bridge.h\"\n#include \"bridge_priv.h\"\n\nstatic void *mlx5_esw_bridge_debugfs_start(struct seq_file *seq, loff_t *pos);\nstatic void *mlx5_esw_bridge_debugfs_next(struct seq_file *seq, void *v, loff_t *pos);\nstatic void mlx5_esw_bridge_debugfs_stop(struct seq_file *seq, void *v);\nstatic int mlx5_esw_bridge_debugfs_show(struct seq_file *seq, void *v);\n\nstatic const struct seq_operations mlx5_esw_bridge_debugfs_sops = {\n\t.start\t= mlx5_esw_bridge_debugfs_start,\n\t.next\t= mlx5_esw_bridge_debugfs_next,\n\t.stop\t= mlx5_esw_bridge_debugfs_stop,\n\t.show\t= mlx5_esw_bridge_debugfs_show,\n};\nDEFINE_SEQ_ATTRIBUTE(mlx5_esw_bridge_debugfs);\n\nstatic void *mlx5_esw_bridge_debugfs_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct mlx5_esw_bridge *bridge = seq->private;\n\n\trtnl_lock();\n\treturn *pos ? seq_list_start(&bridge->fdb_list, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *mlx5_esw_bridge_debugfs_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct mlx5_esw_bridge *bridge = seq->private;\n\n\treturn seq_list_next(v == SEQ_START_TOKEN ? &bridge->fdb_list : v, &bridge->fdb_list, pos);\n}\n\nstatic void mlx5_esw_bridge_debugfs_stop(struct seq_file *seq, void *v)\n{\n\trtnl_unlock();\n}\n\nstatic int mlx5_esw_bridge_debugfs_show(struct seq_file *seq, void *v)\n{\n\tstruct mlx5_esw_bridge_fdb_entry *entry;\n\tu64 packets, bytes, lastuse;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq, \"%-16s %-17s %4s %20s %20s %20s %5s\\n\",\n\t\t\t   \"DEV\", \"MAC\", \"VLAN\", \"PACKETS\", \"BYTES\", \"LASTUSE\", \"FLAGS\");\n\t\treturn 0;\n\t}\n\n\tentry = list_entry(v, struct mlx5_esw_bridge_fdb_entry, list);\n\tmlx5_fc_query_cached_raw(entry->ingress_counter, &bytes, &packets, &lastuse);\n\tseq_printf(seq, \"%-16s %-17pM %4d %20llu %20llu %20llu %#5x\\n\",\n\t\t   entry->dev->name, entry->key.addr, entry->key.vid, packets, bytes, lastuse,\n\t\t   entry->flags);\n\treturn 0;\n}\n\nvoid mlx5_esw_bridge_debugfs_init(struct net_device *br_netdev, struct mlx5_esw_bridge *bridge)\n{\n\tif (!bridge->br_offloads->debugfs_root)\n\t\treturn;\n\n\tbridge->debugfs_dir = debugfs_create_dir(br_netdev->name,\n\t\t\t\t\t\t bridge->br_offloads->debugfs_root);\n\tdebugfs_create_file(\"fdb\", 0400, bridge->debugfs_dir, bridge,\n\t\t\t    &mlx5_esw_bridge_debugfs_fops);\n}\n\nvoid mlx5_esw_bridge_debugfs_cleanup(struct mlx5_esw_bridge *bridge)\n{\n\tdebugfs_remove_recursive(bridge->debugfs_dir);\n\tbridge->debugfs_dir = NULL;\n}\n\nvoid mlx5_esw_bridge_debugfs_offloads_init(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tif (!br_offloads->esw->debugfs_root)\n\t\treturn;\n\n\tbr_offloads->debugfs_root = debugfs_create_dir(\"bridge\", br_offloads->esw->debugfs_root);\n}\n\nvoid mlx5_esw_bridge_debugfs_offloads_cleanup(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tdebugfs_remove_recursive(br_offloads->debugfs_root);\n\tbr_offloads->debugfs_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}