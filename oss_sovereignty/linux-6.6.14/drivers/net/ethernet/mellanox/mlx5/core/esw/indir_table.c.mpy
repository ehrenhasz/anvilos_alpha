{
  "module_name": "indir_table.c",
  "hash_id": "64d57f2260954b448b86b461a6dddf24b0dc892a8323afca64ffe055278da900",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/indir_table.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/idr.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/mlx5_ifc.h>\n#include <linux/mlx5/vport.h>\n#include <linux/mlx5/fs.h>\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"en.h\"\n#include \"en_tc.h\"\n#include \"fs_core.h\"\n#include \"esw/indir_table.h\"\n#include \"lib/fs_chains.h\"\n#include \"en/mod_hdr.h\"\n\n#define MLX5_ESW_INDIR_TABLE_SIZE 2\n#define MLX5_ESW_INDIR_TABLE_RECIRC_IDX (MLX5_ESW_INDIR_TABLE_SIZE - 2)\n#define MLX5_ESW_INDIR_TABLE_FWD_IDX (MLX5_ESW_INDIR_TABLE_SIZE - 1)\n\nstruct mlx5_esw_indir_table_rule {\n\tstruct mlx5_flow_handle *handle;\n\tstruct mlx5_modify_hdr *mh;\n\trefcount_t refcnt;\n};\n\nstruct mlx5_esw_indir_table_entry {\n\tstruct hlist_node hlist;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_group *recirc_grp;\n\tstruct mlx5_flow_group *fwd_grp;\n\tstruct mlx5_flow_handle *fwd_rule;\n\tstruct mlx5_esw_indir_table_rule *recirc_rule;\n\tint fwd_ref;\n\n\tu16 vport;\n};\n\nstruct mlx5_esw_indir_table {\n\tstruct mutex lock;  \n\tDECLARE_HASHTABLE(table, 8);\n};\n\nstruct mlx5_esw_indir_table *\nmlx5_esw_indir_table_init(void)\n{\n\tstruct mlx5_esw_indir_table *indir = kvzalloc(sizeof(*indir), GFP_KERNEL);\n\n\tif (!indir)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&indir->lock);\n\thash_init(indir->table);\n\treturn indir;\n}\n\nvoid\nmlx5_esw_indir_table_destroy(struct mlx5_esw_indir_table *indir)\n{\n\tmutex_destroy(&indir->lock);\n\tkvfree(indir);\n}\n\nbool\nmlx5_esw_indir_table_needed(struct mlx5_eswitch *esw,\n\t\t\t    struct mlx5_flow_attr *attr,\n\t\t\t    u16 vport_num,\n\t\t\t    struct mlx5_core_dev *dest_mdev)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tbool vf_sf_vport;\n\n\tvf_sf_vport = mlx5_eswitch_is_vf_vport(esw, vport_num) ||\n\t\t      mlx5_esw_is_sf_vport(esw, vport_num);\n\n\t \n\treturn esw_attr->in_rep->vport == MLX5_VPORT_UPLINK &&\n\t\tvf_sf_vport &&\n\t\tesw->dev == dest_mdev &&\n\t\tattr->flags & MLX5_ATTR_FLAG_SRC_REWRITE;\n}\n\nu16\nmlx5_esw_indir_table_decap_vport(struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\n\treturn esw_attr->rx_tun_attr ? esw_attr->rx_tun_attr->decap_vport : 0;\n}\n\nstatic int mlx5_esw_indir_table_rule_get(struct mlx5_eswitch *esw,\n\t\t\t\t\t struct mlx5_flow_attr *attr,\n\t\t\t\t\t struct mlx5_esw_indir_table_entry *e)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct mlx5_fs_chains *chains = esw_chains(esw);\n\tstruct mlx5e_tc_mod_hdr_acts mod_acts = {};\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_esw_indir_table_rule *rule;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *handle;\n\tint err = 0;\n\tu32 data;\n\n\tif (e->recirc_rule) {\n\t\trefcount_inc(&e->recirc_rule->refcnt);\n\t\treturn 0;\n\t}\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn -ENOMEM;\n\n\t \n\tdata = mlx5_eswitch_get_vport_metadata_for_set(esw, esw_attr->rx_tun_attr->decap_vport);\n\terr = mlx5e_tc_match_to_reg_set(esw->dev, &mod_acts, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\tVPORT_TO_REG, data);\n\tif (err)\n\t\tgoto err_mod_hdr_regc0;\n\n\terr = mlx5e_tc_match_to_reg_set(esw->dev, &mod_acts, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\tTUNNEL_TO_REG, ESW_TUN_SLOW_TABLE_GOTO_VPORT);\n\tif (err)\n\t\tgoto err_mod_hdr_regc1;\n\n\tflow_act.modify_hdr = mlx5_modify_header_alloc(esw->dev, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\t\t       mod_acts.num_actions, mod_acts.actions);\n\tif (IS_ERR(flow_act.modify_hdr)) {\n\t\terr = PTR_ERR(flow_act.modify_hdr);\n\t\tgoto err_mod_hdr_alloc;\n\t}\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\tflow_act.flags = FLOW_ACT_IGNORE_FLOW_LEVEL | FLOW_ACT_NO_APPEND;\n\tflow_act.fg = e->recirc_grp;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = mlx5_chains_get_table(chains, 0, 1, 0);\n\tif (IS_ERR(dest.ft)) {\n\t\terr = PTR_ERR(dest.ft);\n\t\tgoto err_table;\n\t}\n\thandle = mlx5_add_flow_rules(e->ft, NULL, &flow_act, &dest, 1);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto err_handle;\n\t}\n\n\tmlx5e_mod_hdr_dealloc(&mod_acts);\n\trule->handle = handle;\n\trule->mh = flow_act.modify_hdr;\n\trefcount_set(&rule->refcnt, 1);\n\te->recirc_rule = rule;\n\treturn 0;\n\nerr_handle:\n\tmlx5_chains_put_table(chains, 0, 1, 0);\nerr_table:\n\tmlx5_modify_header_dealloc(esw->dev, flow_act.modify_hdr);\nerr_mod_hdr_alloc:\nerr_mod_hdr_regc1:\n\tmlx5e_mod_hdr_dealloc(&mod_acts);\nerr_mod_hdr_regc0:\n\tkfree(rule);\n\treturn err;\n}\n\nstatic void mlx5_esw_indir_table_rule_put(struct mlx5_eswitch *esw,\n\t\t\t\t\t  struct mlx5_esw_indir_table_entry *e)\n{\n\tstruct mlx5_esw_indir_table_rule *rule = e->recirc_rule;\n\tstruct mlx5_fs_chains *chains = esw_chains(esw);\n\n\tif (!rule)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&rule->refcnt))\n\t\treturn;\n\n\tmlx5_del_flow_rules(rule->handle);\n\tmlx5_chains_put_table(chains, 0, 1, 0);\n\tmlx5_modify_header_dealloc(esw->dev, rule->mh);\n\tkfree(rule);\n\te->recirc_rule = NULL;\n}\n\nstatic int mlx5_create_indir_recirc_group(struct mlx5_esw_indir_table_entry *e)\n{\n\tint err = 0, inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tu32 *in;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index, 0);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index, MLX5_ESW_INDIR_TABLE_RECIRC_IDX);\n\te->recirc_grp = mlx5_create_flow_group(e->ft, in);\n\tif (IS_ERR(e->recirc_grp))\n\t\terr = PTR_ERR(e->recirc_grp);\n\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int mlx5_create_indir_fwd_group(struct mlx5_eswitch *esw,\n\t\t\t\t       struct mlx5_esw_indir_table_entry *e)\n{\n\tint err = 0, inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tu32 *in;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\t \n\tMLX5_SET(create_flow_group_in, in, start_flow_index, MLX5_ESW_INDIR_TABLE_FWD_IDX);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index, MLX5_ESW_INDIR_TABLE_FWD_IDX);\n\te->fwd_grp = mlx5_create_flow_group(e->ft, in);\n\tif (IS_ERR(e->fwd_grp)) {\n\t\terr = PTR_ERR(e->fwd_grp);\n\t\tgoto err_out;\n\t}\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tflow_act.fg = e->fwd_grp;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\n\tdest.vport.num = e->vport;\n\tdest.vport.vhca_id = MLX5_CAP_GEN(esw->dev, vhca_id);\n\tdest.vport.flags = MLX5_FLOW_DEST_VPORT_VHCA_ID;\n\te->fwd_rule = mlx5_add_flow_rules(e->ft, NULL, &flow_act, &dest, 1);\n\tif (IS_ERR(e->fwd_rule)) {\n\t\tmlx5_destroy_flow_group(e->fwd_grp);\n\t\terr = PTR_ERR(e->fwd_rule);\n\t}\n\nerr_out:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic struct mlx5_esw_indir_table_entry *\nmlx5_esw_indir_table_entry_create(struct mlx5_eswitch *esw, struct mlx5_flow_attr *attr,\n\t\t\t\t  u16 vport, bool decap)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_namespace *root_ns;\n\tstruct mlx5_esw_indir_table_entry *e;\n\tstruct mlx5_flow_table *ft;\n\tint err = 0;\n\n\troot_ns = mlx5_get_flow_namespace(esw->dev, MLX5_FLOW_NAMESPACE_FDB);\n\tif (!root_ns)\n\t\treturn ERR_PTR(-ENOENT);\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tft_attr.prio = FDB_TC_OFFLOAD;\n\tft_attr.max_fte = MLX5_ESW_INDIR_TABLE_SIZE;\n\tft_attr.flags = MLX5_FLOW_TABLE_UNMANAGED;\n\tft_attr.level = 1;\n\n\tft = mlx5_create_flow_table(root_ns, &ft_attr);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto tbl_err;\n\t}\n\te->ft = ft;\n\te->vport = vport;\n\te->fwd_ref = !decap;\n\n\terr = mlx5_create_indir_recirc_group(e);\n\tif (err)\n\t\tgoto recirc_grp_err;\n\n\tif (decap) {\n\t\terr = mlx5_esw_indir_table_rule_get(esw, attr, e);\n\t\tif (err)\n\t\t\tgoto recirc_rule_err;\n\t}\n\n\terr = mlx5_create_indir_fwd_group(esw, e);\n\tif (err)\n\t\tgoto fwd_grp_err;\n\n\thash_add(esw->fdb_table.offloads.indir->table, &e->hlist,\n\t\t vport << 16);\n\n\treturn e;\n\nfwd_grp_err:\n\tif (decap)\n\t\tmlx5_esw_indir_table_rule_put(esw, e);\nrecirc_rule_err:\n\tmlx5_destroy_flow_group(e->recirc_grp);\nrecirc_grp_err:\n\tmlx5_destroy_flow_table(e->ft);\ntbl_err:\n\tkfree(e);\n\treturn ERR_PTR(err);\n}\n\nstatic struct mlx5_esw_indir_table_entry *\nmlx5_esw_indir_table_entry_lookup(struct mlx5_eswitch *esw, u16 vport)\n{\n\tstruct mlx5_esw_indir_table_entry *e;\n\tu32 key = vport << 16;\n\n\thash_for_each_possible(esw->fdb_table.offloads.indir->table, e, hlist, key)\n\t\tif (e->vport == vport)\n\t\t\treturn e;\n\n\treturn NULL;\n}\n\nstruct mlx5_flow_table *mlx5_esw_indir_table_get(struct mlx5_eswitch *esw,\n\t\t\t\t\t\t struct mlx5_flow_attr *attr,\n\t\t\t\t\t\t u16 vport, bool decap)\n{\n\tstruct mlx5_esw_indir_table_entry *e;\n\tint err;\n\n\tmutex_lock(&esw->fdb_table.offloads.indir->lock);\n\te = mlx5_esw_indir_table_entry_lookup(esw, vport);\n\tif (e) {\n\t\tif (!decap) {\n\t\t\te->fwd_ref++;\n\t\t} else {\n\t\t\terr = mlx5_esw_indir_table_rule_get(esw, attr, e);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\te = mlx5_esw_indir_table_entry_create(esw, attr, vport, decap);\n\t\tif (IS_ERR(e)) {\n\t\t\terr = PTR_ERR(e);\n\t\t\tesw_warn(esw->dev, \"Failed to create indirection table, err %d.\\n\", err);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tmutex_unlock(&esw->fdb_table.offloads.indir->lock);\n\treturn e->ft;\n\nout_err:\n\tmutex_unlock(&esw->fdb_table.offloads.indir->lock);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5_esw_indir_table_put(struct mlx5_eswitch *esw,\n\t\t\t      u16 vport, bool decap)\n{\n\tstruct mlx5_esw_indir_table_entry *e;\n\n\tmutex_lock(&esw->fdb_table.offloads.indir->lock);\n\te = mlx5_esw_indir_table_entry_lookup(esw, vport);\n\tif (!e)\n\t\tgoto out;\n\n\tif (!decap)\n\t\te->fwd_ref--;\n\telse\n\t\tmlx5_esw_indir_table_rule_put(esw, e);\n\n\tif (e->fwd_ref || e->recirc_rule)\n\t\tgoto out;\n\n\thash_del(&e->hlist);\n\tmlx5_destroy_flow_group(e->recirc_grp);\n\tmlx5_del_flow_rules(e->fwd_rule);\n\tmlx5_destroy_flow_group(e->fwd_grp);\n\tmlx5_destroy_flow_table(e->ft);\n\tkfree(e);\nout:\n\tmutex_unlock(&esw->fdb_table.offloads.indir->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}