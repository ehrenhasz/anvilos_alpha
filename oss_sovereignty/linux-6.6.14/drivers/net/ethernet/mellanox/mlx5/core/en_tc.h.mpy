{
  "module_name": "en_tc.h",
  "hash_id": "7357cde842b5e32a68fe3a23311e8eecf5d21ee25d03e144181f9af27690ac26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h",
  "human_readable_source": " \n\n#ifndef __MLX5_EN_TC_H__\n#define __MLX5_EN_TC_H__\n\n#include <net/pkt_cls.h>\n#include \"en.h\"\n#include \"eswitch.h\"\n#include \"en/tc_ct.h\"\n#include \"en/tc_tun.h\"\n#include \"en/tc/int_port.h\"\n#include \"en/tc/meter.h\"\n#include \"en_rep.h\"\n\n#define MLX5E_TC_FLOW_ID_MASK 0x0000ffff\n\n#ifdef CONFIG_MLX5_ESWITCH\n\n#define NIC_FLOW_ATTR_SZ (sizeof(struct mlx5_flow_attr) +\\\n\t\t\t  sizeof(struct mlx5_nic_flow_attr))\n#define ESW_FLOW_ATTR_SZ (sizeof(struct mlx5_flow_attr) +\\\n\t\t\t  sizeof(struct mlx5_esw_flow_attr))\n#define ns_to_attr_sz(ns) (((ns) == MLX5_FLOW_NAMESPACE_FDB) ?\\\n\t\t\t    ESW_FLOW_ATTR_SZ :\\\n\t\t\t    NIC_FLOW_ATTR_SZ)\n\nstruct mlx5_fs_chains *mlx5e_nic_chains(struct mlx5e_tc_table *tc);\nint mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags);\n\nstruct mlx5e_tc_update_priv {\n\tstruct net_device *fwd_dev;\n\tbool skb_done;\n\tbool forward_tx;\n};\n\nstruct mlx5_nic_flow_attr {\n\tu32 flow_tag;\n\tu32 hairpin_tirn;\n\tstruct mlx5_flow_table *hairpin_ft;\n};\n\nstruct mlx5_flow_attr {\n\tu32 action;\n\tunsigned long tc_act_cookies[TCA_ACT_MAX_PRIO];\n\tstruct mlx5_fc *counter;\n\tstruct mlx5_modify_hdr *modify_hdr;\n\tstruct mlx5e_mod_hdr_handle *mh;  \n\tstruct mlx5e_mod_hdr_handle *slow_mh;  \n\tstruct mlx5_ct_attr ct_attr;\n\tstruct mlx5e_sample_attr sample_attr;\n\tstruct mlx5e_meter_attr meter_attr;\n\tstruct mlx5e_tc_flow_parse_attr *parse_attr;\n\tu32 chain;\n\tu16 prio;\n\tu16 tc_act_cookies_count;\n\tu32 dest_chain;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_table *dest_ft;\n\tu8 inner_match_level;\n\tu8 outer_match_level;\n\tu8 tun_ip_version;\n\tint tunnel_id;  \n\tu32 flags;\n\tu32 exe_aso_type;\n\tstruct list_head list;\n\tstruct mlx5e_post_act_handle *post_act_handle;\n\tstruct mlx5_flow_attr *branch_true;\n\tstruct mlx5_flow_attr *branch_false;\n\tstruct mlx5_flow_attr *jumping_attr;\n\tstruct mlx5_flow_handle *act_id_restore_rule;\n\t \n\tunion {\n\t\tDECLARE_FLEX_ARRAY(struct mlx5_esw_flow_attr, esw_attr);\n\t\tDECLARE_FLEX_ARRAY(struct mlx5_nic_flow_attr, nic_attr);\n\t};\n};\n\nenum {\n\tMLX5_ATTR_FLAG_VLAN_HANDLED  = BIT(0),\n\tMLX5_ATTR_FLAG_SLOW_PATH     = BIT(1),\n\tMLX5_ATTR_FLAG_NO_IN_PORT    = BIT(2),\n\tMLX5_ATTR_FLAG_SRC_REWRITE   = BIT(3),\n\tMLX5_ATTR_FLAG_SAMPLE        = BIT(4),\n\tMLX5_ATTR_FLAG_ACCEPT        = BIT(5),\n\tMLX5_ATTR_FLAG_CT            = BIT(6),\n\tMLX5_ATTR_FLAG_TERMINATING   = BIT(7),\n\tMLX5_ATTR_FLAG_MTU           = BIT(8),\n};\n\n \nstatic inline bool\nmlx5e_tc_attr_flags_skip(u32 attr_flags)\n{\n\treturn attr_flags & (MLX5_ATTR_FLAG_SLOW_PATH | MLX5_ATTR_FLAG_ACCEPT);\n}\n\nstruct mlx5_rx_tun_attr {\n\tu16 decap_vport;\n\tunion {\n\t\t__be32 v4;\n\t\tstruct in6_addr v6;\n\t} src_ip;  \n\tunion {\n\t\t__be32 v4;\n\t\tstruct in6_addr v6;\n\t} dst_ip;  \n};\n\n#define MLX5E_TC_TABLE_CHAIN_TAG_BITS 16\n#define MLX5E_TC_TABLE_CHAIN_TAG_MASK GENMASK(MLX5E_TC_TABLE_CHAIN_TAG_BITS - 1, 0)\n\n#define MLX5E_TC_MAX_INT_PORT_NUM (8)\n\n#if IS_ENABLED(CONFIG_MLX5_CLS_ACT)\n\nstruct tunnel_match_key {\n\tstruct flow_dissector_key_control enc_control;\n\tstruct flow_dissector_key_keyid enc_key_id;\n\tstruct flow_dissector_key_ports enc_tp;\n\tstruct flow_dissector_key_ip enc_ip;\n\tunion {\n\t\tstruct flow_dissector_key_ipv4_addrs enc_ipv4;\n\t\tstruct flow_dissector_key_ipv6_addrs enc_ipv6;\n\t};\n\n\tint filter_ifindex;\n};\n\nstruct tunnel_match_enc_opts {\n\tstruct flow_dissector_key_enc_opts key;\n\tstruct flow_dissector_key_enc_opts mask;\n};\n\n \n#define TUNNEL_INFO_BITS 12\n#define TUNNEL_INFO_BITS_MASK GENMASK(TUNNEL_INFO_BITS - 1, 0)\n#define ENC_OPTS_BITS 11\n#define ENC_OPTS_BITS_MASK GENMASK(ENC_OPTS_BITS - 1, 0)\n#define TUNNEL_ID_BITS (TUNNEL_INFO_BITS + ENC_OPTS_BITS)\n#define TUNNEL_ID_MASK GENMASK(TUNNEL_ID_BITS - 1, 0)\n\nenum {\n\tMLX5E_TC_FLAG_INGRESS_BIT,\n\tMLX5E_TC_FLAG_EGRESS_BIT,\n\tMLX5E_TC_FLAG_NIC_OFFLOAD_BIT,\n\tMLX5E_TC_FLAG_ESW_OFFLOAD_BIT,\n\tMLX5E_TC_FLAG_FT_OFFLOAD_BIT,\n\tMLX5E_TC_FLAG_LAST_EXPORTED_BIT = MLX5E_TC_FLAG_FT_OFFLOAD_BIT,\n};\n\n#define MLX5_TC_FLAG(flag) BIT(MLX5E_TC_FLAG_##flag##_BIT)\n\nint mlx5e_tc_esw_init(struct mlx5_rep_uplink_priv *uplink_priv);\nvoid mlx5e_tc_esw_cleanup(struct mlx5_rep_uplink_priv *uplink_priv);\n\nint mlx5e_tc_ht_init(struct rhashtable *tc_ht);\nvoid mlx5e_tc_ht_cleanup(struct rhashtable *tc_ht);\n\nint mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,\n\t\t\t   struct flow_cls_offload *f, unsigned long flags);\nint mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,\n\t\t\tstruct flow_cls_offload *f, unsigned long flags);\n\nint mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,\n\t\t       struct flow_cls_offload *f, unsigned long flags);\nint mlx5e_tc_fill_action_stats(struct mlx5e_priv *priv,\n\t\t\t       struct flow_offload_action *fl_act);\n\nint mlx5e_tc_configure_matchall(struct mlx5e_priv *priv,\n\t\t\t\tstruct tc_cls_matchall_offload *f);\nint mlx5e_tc_delete_matchall(struct mlx5e_priv *priv,\n\t\t\t     struct tc_cls_matchall_offload *f);\nvoid mlx5e_tc_stats_matchall(struct mlx5e_priv *priv,\n\t\t\t     struct tc_cls_matchall_offload *ma);\n\nstruct mlx5e_encap_entry;\nvoid mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,\n\t\t\t      struct mlx5e_encap_entry *e,\n\t\t\t      struct list_head *flow_list);\nvoid mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,\n\t\t\t      struct mlx5e_encap_entry *e,\n\t\t\t      struct list_head *flow_list);\nbool mlx5e_encap_take(struct mlx5e_encap_entry *e);\nvoid mlx5e_encap_put(struct mlx5e_priv *priv, struct mlx5e_encap_entry *e);\n\nvoid mlx5e_take_all_encap_flows(struct mlx5e_encap_entry *e, struct list_head *flow_list);\nvoid mlx5e_put_flow_list(struct mlx5e_priv *priv, struct list_head *flow_list);\n\nstruct mlx5e_neigh_hash_entry;\nstruct mlx5e_encap_entry *\nmlx5e_get_next_init_encap(struct mlx5e_neigh_hash_entry *nhe,\n\t\t\t  struct mlx5e_encap_entry *e);\nvoid mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);\n\nvoid mlx5e_tc_reoffload_flows_work(struct work_struct *work);\n\nenum mlx5e_tc_attr_to_reg {\n\tMAPPED_OBJ_TO_REG,\n\tVPORT_TO_REG,\n\tTUNNEL_TO_REG,\n\tCTSTATE_TO_REG,\n\tZONE_TO_REG,\n\tZONE_RESTORE_TO_REG,\n\tMARK_TO_REG,\n\tLABELS_TO_REG,\n\tFTEID_TO_REG,\n\tNIC_MAPPED_OBJ_TO_REG,\n\tNIC_ZONE_RESTORE_TO_REG,\n\tPACKET_COLOR_TO_REG,\n};\n\nstruct mlx5e_tc_attr_to_reg_mapping {\n\tint mfield;  \n\tint moffset;  \n\tint mlen;  \n\n\tint soffset;  \n};\n\nextern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];\n\n#define MLX5_REG_MAPPING_MOFFSET(reg_id) (mlx5e_tc_attr_to_reg_mappings[reg_id].moffset)\n#define MLX5_REG_MAPPING_MBITS(reg_id) (mlx5e_tc_attr_to_reg_mappings[reg_id].mlen)\n#define MLX5_REG_MAPPING_MASK(reg_id) (GENMASK(mlx5e_tc_attr_to_reg_mappings[reg_id].mlen - 1, 0))\n\nbool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,\n\t\t\t\t    struct net_device *out_dev);\n\nint mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,\n\t\t\t      struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,\n\t\t\t      enum mlx5_flow_namespace_type ns,\n\t\t\t      enum mlx5e_tc_attr_to_reg type,\n\t\t\t      u32 data);\n\nvoid mlx5e_tc_match_to_reg_mod_hdr_change(struct mlx5_core_dev *mdev,\n\t\t\t\t\t  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,\n\t\t\t\t\t  enum mlx5e_tc_attr_to_reg type,\n\t\t\t\t\t  int act_id, u32 data);\n\nvoid mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,\n\t\t\t\t enum mlx5e_tc_attr_to_reg type,\n\t\t\t\t u32 data,\n\t\t\t\t u32 mask);\n\nvoid mlx5e_tc_match_to_reg_get_match(struct mlx5_flow_spec *spec,\n\t\t\t\t     enum mlx5e_tc_attr_to_reg type,\n\t\t\t\t     u32 *data,\n\t\t\t\t     u32 *mask);\n\nint mlx5e_tc_match_to_reg_set_and_get_id(struct mlx5_core_dev *mdev,\n\t\t\t\t\t struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,\n\t\t\t\t\t enum mlx5_flow_namespace_type ns,\n\t\t\t\t\t enum mlx5e_tc_attr_to_reg type,\n\t\t\t\t\t u32 data);\n\nint mlx5e_tc_attach_mod_hdr(struct mlx5e_priv *priv,\n\t\t\t    struct mlx5e_tc_flow *flow,\n\t\t\t    struct mlx5_flow_attr *attr);\n\nvoid mlx5e_tc_detach_mod_hdr(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5e_tc_flow *flow,\n\t\t\t     struct mlx5_flow_attr *attr);\n\nvoid mlx5e_tc_set_ethertype(struct mlx5_core_dev *mdev,\n\t\t\t    struct flow_match_basic *match, bool outer,\n\t\t\t    void *headers_c, void *headers_v);\n\nint mlx5e_tc_nic_init(struct mlx5e_priv *priv);\nvoid mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv);\n\nint mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t    void *cb_priv);\n\nstruct mlx5_flow_handle *\nmlx5e_add_offloaded_nic_rule(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5_flow_spec *spec,\n\t\t\t     struct mlx5_flow_attr *attr);\nvoid mlx5e_del_offloaded_nic_rule(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5_flow_handle *rule,\n\t\t\t\t  struct mlx5_flow_attr *attr);\n\nstruct mlx5_flow_handle *\nmlx5_tc_rule_insert(struct mlx5e_priv *priv,\n\t\t    struct mlx5_flow_spec *spec,\n\t\t    struct mlx5_flow_attr *attr);\nvoid\nmlx5_tc_rule_delete(struct mlx5e_priv *priv,\n\t\t    struct mlx5_flow_handle *rule,\n\t\t    struct mlx5_flow_attr *attr);\n\nbool mlx5e_tc_is_vf_tunnel(struct net_device *out_dev, struct net_device *route_dev);\nint mlx5e_tc_query_route_vport(struct net_device *out_dev, struct net_device *route_dev,\n\t\t\t       u16 *vport);\n\nint mlx5e_set_fwd_to_int_port_actions(struct mlx5e_priv *priv,\n\t\t\t\t      struct mlx5_flow_attr *attr,\n\t\t\t\t      int ifindex,\n\t\t\t\t      enum mlx5e_tc_int_port_type type,\n\t\t\t\t      u32 *action,\n\t\t\t\t      int out_index);\n#else  \nstatic inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }\nstatic inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}\nstatic inline int mlx5e_tc_ht_init(struct rhashtable *tc_ht) { return 0; }\nstatic inline void mlx5e_tc_ht_cleanup(struct rhashtable *tc_ht) {}\nstatic inline int\nmlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)\n{ return -EOPNOTSUPP; }\n\n#endif  \n\nstruct mlx5_flow_attr *mlx5_alloc_flow_attr(enum mlx5_flow_namespace_type type);\n\nstruct mlx5_flow_handle *\nmlx5e_add_offloaded_nic_rule(struct mlx5e_priv *priv,\n\t\t\t     struct mlx5_flow_spec *spec,\n\t\t\t     struct mlx5_flow_attr *attr);\nvoid mlx5e_del_offloaded_nic_rule(struct mlx5e_priv *priv,\n\t\t\t\t  struct mlx5_flow_handle *rule,\n\t\t\t\t  struct mlx5_flow_attr *attr);\n\n#else  \nstatic inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }\nstatic inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}\nstatic inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv,\n\t\t\t\t\tunsigned long flags)\n{\n\treturn 0;\n}\n\nstatic inline int\nmlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)\n{ return -EOPNOTSUPP; }\n#endif\n\n#if IS_ENABLED(CONFIG_MLX5_CLS_ACT)\nstruct mlx5e_tc_table *mlx5e_tc_table_alloc(void);\nvoid mlx5e_tc_table_free(struct mlx5e_tc_table *tc);\nstatic inline bool mlx5e_cqe_regb_chain(struct mlx5_cqe64 *cqe)\n{\n\tu32 chain, reg_b;\n\n\treg_b = be32_to_cpu(cqe->ft_metadata);\n\n\tif (reg_b >> (MLX5E_TC_TABLE_CHAIN_TAG_BITS + ESW_ZONE_ID_BITS))\n\t\treturn false;\n\n\tchain = reg_b & MLX5E_TC_TABLE_CHAIN_TAG_MASK;\n\tif (chain)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool mlx5e_tc_update_skb_nic(struct mlx5_cqe64 *cqe, struct sk_buff *skb);\nbool mlx5e_tc_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb,\n\t\t\t struct mapping_ctx *mapping_ctx, u32 mapped_obj_id,\n\t\t\t struct mlx5_tc_ct_priv *ct_priv,\n\t\t\t u32 zone_restore_id, u32 tunnel_id,\n\t\t\t struct mlx5e_tc_update_priv *tc_priv);\n#else  \nstatic inline struct mlx5e_tc_table *mlx5e_tc_table_alloc(void) { return NULL; }\nstatic inline void mlx5e_tc_table_free(struct mlx5e_tc_table *tc) {}\nstatic inline bool mlx5e_cqe_regb_chain(struct mlx5_cqe64 *cqe)\n{ return false; }\nstatic inline bool\nmlx5e_tc_update_skb_nic(struct mlx5_cqe64 *cqe, struct sk_buff *skb)\n{ return true; }\n#endif\n\nint mlx5e_tc_action_miss_mapping_get(struct mlx5e_priv *priv, struct mlx5_flow_attr *attr,\n\t\t\t\t     u64 act_miss_cookie, u32 *act_miss_mapping);\nvoid mlx5e_tc_action_miss_mapping_put(struct mlx5e_priv *priv, struct mlx5_flow_attr *attr,\n\t\t\t\t      u32 act_miss_mapping);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}