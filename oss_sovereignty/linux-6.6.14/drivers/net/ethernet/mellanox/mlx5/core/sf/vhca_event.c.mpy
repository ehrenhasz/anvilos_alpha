{
  "module_name": "vhca_event.c",
  "hash_id": "7f32a623a3e24f06b69d49eb94ba93efadc2c857b7cc2703836d958139433941",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/sf/vhca_event.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/driver.h>\n#include \"mlx5_ifc_vhca_event.h\"\n#include \"mlx5_core.h\"\n#include \"vhca_event.h\"\n#include \"ecpf.h\"\n#define CREATE_TRACE_POINTS\n#include \"diag/vhca_tracepoint.h\"\n\nstruct mlx5_vhca_state_notifier {\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_nb nb;\n\tstruct blocking_notifier_head n_head;\n};\n\nstruct mlx5_vhca_event_work {\n\tstruct work_struct work;\n\tstruct mlx5_vhca_state_notifier *notifier;\n\tstruct mlx5_vhca_state_event event;\n};\n\nint mlx5_cmd_query_vhca_state(struct mlx5_core_dev *dev, u16 function_id, u32 *out, u32 outlen)\n{\n\tu32 in[MLX5_ST_SZ_DW(query_vhca_state_in)] = {};\n\n\tMLX5_SET(query_vhca_state_in, in, opcode, MLX5_CMD_OP_QUERY_VHCA_STATE);\n\tMLX5_SET(query_vhca_state_in, in, function_id, function_id);\n\tMLX5_SET(query_vhca_state_in, in, embedded_cpu_function, 0);\n\n\treturn mlx5_cmd_exec(dev, in, sizeof(in), out, outlen);\n}\n\nstatic int mlx5_cmd_modify_vhca_state(struct mlx5_core_dev *dev, u16 function_id,\n\t\t\t\t      u32 *in, u32 inlen)\n{\n\tu32 out[MLX5_ST_SZ_DW(modify_vhca_state_out)] = {};\n\n\tMLX5_SET(modify_vhca_state_in, in, opcode, MLX5_CMD_OP_MODIFY_VHCA_STATE);\n\tMLX5_SET(modify_vhca_state_in, in, function_id, function_id);\n\tMLX5_SET(modify_vhca_state_in, in, embedded_cpu_function, 0);\n\n\treturn mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));\n}\n\nint mlx5_modify_vhca_sw_id(struct mlx5_core_dev *dev, u16 function_id, u32 sw_fn_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(modify_vhca_state_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(modify_vhca_state_in)] = {};\n\n\tMLX5_SET(modify_vhca_state_in, in, opcode, MLX5_CMD_OP_MODIFY_VHCA_STATE);\n\tMLX5_SET(modify_vhca_state_in, in, function_id, function_id);\n\tMLX5_SET(modify_vhca_state_in, in, embedded_cpu_function, 0);\n\tMLX5_SET(modify_vhca_state_in, in, vhca_state_field_select.sw_function_id, 1);\n\tMLX5_SET(modify_vhca_state_in, in, vhca_state_context.sw_function_id, sw_fn_id);\n\n\treturn mlx5_cmd_exec_inout(dev, modify_vhca_state, in, out);\n}\n\nint mlx5_vhca_event_arm(struct mlx5_core_dev *dev, u16 function_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(modify_vhca_state_in)] = {};\n\n\tMLX5_SET(modify_vhca_state_in, in, vhca_state_context.arm_change_event, 1);\n\tMLX5_SET(modify_vhca_state_in, in, vhca_state_field_select.arm_change_event, 1);\n\n\treturn mlx5_cmd_modify_vhca_state(dev, function_id, in, sizeof(in));\n}\n\nstatic void\nmlx5_vhca_event_notify(struct mlx5_core_dev *dev, struct mlx5_vhca_state_event *event)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_vhca_state_out)] = {};\n\tint err;\n\n\terr = mlx5_cmd_query_vhca_state(dev, event->function_id, out, sizeof(out));\n\tif (err)\n\t\treturn;\n\n\tevent->sw_function_id = MLX5_GET(query_vhca_state_out, out,\n\t\t\t\t\t vhca_state_context.sw_function_id);\n\tevent->new_vhca_state = MLX5_GET(query_vhca_state_out, out,\n\t\t\t\t\t vhca_state_context.vhca_state);\n\n\tmlx5_vhca_event_arm(dev, event->function_id);\n\ttrace_mlx5_sf_vhca_event(dev, event);\n\n\tblocking_notifier_call_chain(&dev->priv.vhca_state_notifier->n_head, 0, event);\n}\n\nstatic void mlx5_vhca_state_work_handler(struct work_struct *_work)\n{\n\tstruct mlx5_vhca_event_work *work = container_of(_work, struct mlx5_vhca_event_work, work);\n\tstruct mlx5_vhca_state_notifier *notifier = work->notifier;\n\tstruct mlx5_core_dev *dev = notifier->dev;\n\n\tmlx5_vhca_event_notify(dev, &work->event);\n\tkfree(work);\n}\n\nstatic int\nmlx5_vhca_state_change_notifier(struct notifier_block *nb, unsigned long type, void *data)\n{\n\tstruct mlx5_vhca_state_notifier *notifier =\n\t\t\t\tmlx5_nb_cof(nb, struct mlx5_vhca_state_notifier, nb);\n\tstruct mlx5_vhca_event_work *work;\n\tstruct mlx5_eqe *eqe = data;\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn NOTIFY_DONE;\n\tINIT_WORK(&work->work, &mlx5_vhca_state_work_handler);\n\twork->notifier = notifier;\n\twork->event.function_id = be16_to_cpu(eqe->data.vhca_state.function_id);\n\tmlx5_events_work_enqueue(notifier->dev, &work->work);\n\treturn NOTIFY_OK;\n}\n\nvoid mlx5_vhca_state_cap_handle(struct mlx5_core_dev *dev, void *set_hca_cap)\n{\n\tif (!mlx5_vhca_event_supported(dev))\n\t\treturn;\n\n\tMLX5_SET(cmd_hca_cap, set_hca_cap, vhca_state, 1);\n\tMLX5_SET(cmd_hca_cap, set_hca_cap, event_on_vhca_state_allocated, 1);\n\tMLX5_SET(cmd_hca_cap, set_hca_cap, event_on_vhca_state_active, 1);\n\tMLX5_SET(cmd_hca_cap, set_hca_cap, event_on_vhca_state_in_use, 1);\n\tMLX5_SET(cmd_hca_cap, set_hca_cap, event_on_vhca_state_teardown_request, 1);\n}\n\nint mlx5_vhca_event_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_vhca_state_notifier *notifier;\n\n\tif (!mlx5_vhca_event_supported(dev))\n\t\treturn 0;\n\n\tnotifier = kzalloc(sizeof(*notifier), GFP_KERNEL);\n\tif (!notifier)\n\t\treturn -ENOMEM;\n\n\tdev->priv.vhca_state_notifier = notifier;\n\tnotifier->dev = dev;\n\tBLOCKING_INIT_NOTIFIER_HEAD(&notifier->n_head);\n\tMLX5_NB_INIT(&notifier->nb, mlx5_vhca_state_change_notifier, VHCA_STATE_CHANGE);\n\treturn 0;\n}\n\nvoid mlx5_vhca_event_cleanup(struct mlx5_core_dev *dev)\n{\n\tif (!mlx5_vhca_event_supported(dev))\n\t\treturn;\n\n\tkfree(dev->priv.vhca_state_notifier);\n\tdev->priv.vhca_state_notifier = NULL;\n}\n\nvoid mlx5_vhca_event_start(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_vhca_state_notifier *notifier;\n\n\tif (!dev->priv.vhca_state_notifier)\n\t\treturn;\n\n\tnotifier = dev->priv.vhca_state_notifier;\n\tmlx5_eq_notifier_register(dev, &notifier->nb);\n}\n\nvoid mlx5_vhca_event_stop(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_vhca_state_notifier *notifier;\n\n\tif (!dev->priv.vhca_state_notifier)\n\t\treturn;\n\n\tnotifier = dev->priv.vhca_state_notifier;\n\tmlx5_eq_notifier_unregister(dev, &notifier->nb);\n}\n\nint mlx5_vhca_event_notifier_register(struct mlx5_core_dev *dev, struct notifier_block *nb)\n{\n\tif (!dev->priv.vhca_state_notifier)\n\t\treturn -EOPNOTSUPP;\n\treturn blocking_notifier_chain_register(&dev->priv.vhca_state_notifier->n_head, nb);\n}\n\nvoid mlx5_vhca_event_notifier_unregister(struct mlx5_core_dev *dev, struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&dev->priv.vhca_state_notifier->n_head, nb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}