{
  "module_name": "htb.c",
  "hash_id": "f7a1259b2ab2c1c07f13a3930f71f3201f55eaab74c9477bd148713df619aeb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/htb.c",
  "human_readable_source": "\n \n\n#include <net/pkt_cls.h>\n#include \"htb.h\"\n#include \"en.h\"\n#include \"../qos.h\"\n\nstruct mlx5e_qos_node {\n\tstruct hlist_node hnode;\n\tstruct mlx5e_qos_node *parent;\n\tu64 rate;\n\tu32 bw_share;\n\tu32 max_average_bw;\n\tu32 hw_id;\n\tu32 classid;  \n\tu16 qid;\n};\n\nstruct mlx5e_htb {\n\tDECLARE_HASHTABLE(qos_tc2node, order_base_2(MLX5E_QOS_MAX_LEAF_NODES));\n\tDECLARE_BITMAP(qos_used_qids, MLX5E_QOS_MAX_LEAF_NODES);\n\tstruct mlx5_core_dev *mdev;\n\tstruct net_device *netdev;\n\tstruct mlx5e_priv *priv;\n\tstruct mlx5e_selq *selq;\n};\n\n#define MLX5E_QOS_QID_INNER 0xffff\n#define MLX5E_HTB_CLASSID_ROOT 0xffffffff\n\n \n\nint mlx5e_htb_enumerate_leaves(struct mlx5e_htb *htb, mlx5e_fp_htb_enumerate callback, void *data)\n{\n\tstruct mlx5e_qos_node *node = NULL;\n\tint bkt, err;\n\n\thash_for_each(htb->qos_tc2node, bkt, node, hnode) {\n\t\tif (node->qid == MLX5E_QOS_QID_INNER)\n\t\t\tcontinue;\n\t\terr = callback(data, node->qid, node->hw_id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint mlx5e_htb_cur_leaf_nodes(struct mlx5e_htb *htb)\n{\n\tint last;\n\n\tlast = find_last_bit(htb->qos_used_qids, mlx5e_qos_max_leaf_nodes(htb->mdev));\n\treturn last == mlx5e_qos_max_leaf_nodes(htb->mdev) ? 0 : last + 1;\n}\n\nstatic int mlx5e_htb_find_unused_qos_qid(struct mlx5e_htb *htb)\n{\n\tint size = mlx5e_qos_max_leaf_nodes(htb->mdev);\n\tstruct mlx5e_priv *priv = htb->priv;\n\tint res;\n\n\tWARN_ONCE(!mutex_is_locked(&priv->state_lock), \"%s: state_lock is not held\\n\", __func__);\n\tres = find_first_zero_bit(htb->qos_used_qids, size);\n\n\treturn res == size ? -ENOSPC : res;\n}\n\nstatic struct mlx5e_qos_node *\nmlx5e_htb_node_create_leaf(struct mlx5e_htb *htb, u16 classid, u16 qid,\n\t\t\t   struct mlx5e_qos_node *parent)\n{\n\tstruct mlx5e_qos_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnode->parent = parent;\n\n\tnode->qid = qid;\n\t__set_bit(qid, htb->qos_used_qids);\n\n\tnode->classid = classid;\n\thash_add_rcu(htb->qos_tc2node, &node->hnode, classid);\n\n\tmlx5e_update_tx_netdev_queues(htb->priv);\n\n\treturn node;\n}\n\nstatic struct mlx5e_qos_node *mlx5e_htb_node_create_root(struct mlx5e_htb *htb)\n{\n\tstruct mlx5e_qos_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnode->qid = MLX5E_QOS_QID_INNER;\n\tnode->classid = MLX5E_HTB_CLASSID_ROOT;\n\thash_add_rcu(htb->qos_tc2node, &node->hnode, node->classid);\n\n\treturn node;\n}\n\nstatic struct mlx5e_qos_node *mlx5e_htb_node_find(struct mlx5e_htb *htb, u32 classid)\n{\n\tstruct mlx5e_qos_node *node = NULL;\n\n\thash_for_each_possible(htb->qos_tc2node, node, hnode, classid) {\n\t\tif (node->classid == classid)\n\t\t\tbreak;\n\t}\n\n\treturn node;\n}\n\nstatic struct mlx5e_qos_node *mlx5e_htb_node_find_rcu(struct mlx5e_htb *htb, u32 classid)\n{\n\tstruct mlx5e_qos_node *node = NULL;\n\n\thash_for_each_possible_rcu(htb->qos_tc2node, node, hnode, classid) {\n\t\tif (node->classid == classid)\n\t\t\tbreak;\n\t}\n\n\treturn node;\n}\n\nstatic void mlx5e_htb_node_delete(struct mlx5e_htb *htb, struct mlx5e_qos_node *node)\n{\n\thash_del_rcu(&node->hnode);\n\tif (node->qid != MLX5E_QOS_QID_INNER) {\n\t\t__clear_bit(node->qid, htb->qos_used_qids);\n\t\tmlx5e_update_tx_netdev_queues(htb->priv);\n\t}\n\t \n\tsynchronize_net();\n\tkfree(node);\n}\n\n \n\nint mlx5e_htb_get_txq_by_classid(struct mlx5e_htb *htb, u16 classid)\n{\n\tstruct mlx5e_qos_node *node;\n\tu16 qid;\n\tint res;\n\n\trcu_read_lock();\n\n\tnode = mlx5e_htb_node_find_rcu(htb, classid);\n\tif (!node) {\n\t\tres = -ENOENT;\n\t\tgoto out;\n\t}\n\tqid = READ_ONCE(node->qid);\n\tif (qid == MLX5E_QOS_QID_INNER) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tres = mlx5e_qid_from_qos(&htb->priv->channels, qid);\n\nout:\n\trcu_read_unlock();\n\treturn res;\n}\n\n \n\nstatic int\nmlx5e_htb_root_add(struct mlx5e_htb *htb, u16 htb_maj_id, u16 htb_defcls,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = htb->priv;\n\tstruct mlx5e_qos_node *root;\n\tbool opened;\n\tint err;\n\n\tqos_dbg(htb->mdev, \"TC_HTB_CREATE handle %04x:, default :%04x\\n\", htb_maj_id, htb_defcls);\n\n\tmlx5e_selq_prepare_htb(htb->selq, htb_maj_id, htb_defcls);\n\n\topened = test_bit(MLX5E_STATE_OPENED, &priv->state);\n\tif (opened) {\n\t\terr = mlx5e_qos_alloc_queues(priv, &priv->channels);\n\t\tif (err)\n\t\t\tgoto err_cancel_selq;\n\t}\n\n\troot = mlx5e_htb_node_create_root(htb);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto err_free_queues;\n\t}\n\n\terr = mlx5_qos_create_root_node(htb->mdev, &root->hw_id);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware error. Try upgrading firmware.\");\n\t\tgoto err_sw_node_delete;\n\t}\n\n\tmlx5e_selq_apply(htb->selq);\n\n\treturn 0;\n\nerr_sw_node_delete:\n\tmlx5e_htb_node_delete(htb, root);\n\nerr_free_queues:\n\tif (opened)\n\t\tmlx5e_qos_close_all_queues(&priv->channels);\nerr_cancel_selq:\n\tmlx5e_selq_cancel(htb->selq);\n\treturn err;\n}\n\nstatic int mlx5e_htb_root_del(struct mlx5e_htb *htb)\n{\n\tstruct mlx5e_priv *priv = htb->priv;\n\tstruct mlx5e_qos_node *root;\n\tint err;\n\n\tqos_dbg(htb->mdev, \"TC_HTB_DESTROY\\n\");\n\n\t \n\tsynchronize_net();\n\n\tmlx5e_selq_prepare_htb(htb->selq, 0, 0);\n\tmlx5e_selq_apply(htb->selq);\n\n\troot = mlx5e_htb_node_find(htb, MLX5E_HTB_CLASSID_ROOT);\n\tif (!root) {\n\t\tqos_err(htb->mdev, \"Failed to find the root node in the QoS tree\\n\");\n\t\treturn -ENOENT;\n\t}\n\terr = mlx5_qos_destroy_node(htb->mdev, root->hw_id);\n\tif (err)\n\t\tqos_err(htb->mdev, \"Failed to destroy root node %u, err = %d\\n\",\n\t\t\troot->hw_id, err);\n\tmlx5e_htb_node_delete(htb, root);\n\n\tmlx5e_qos_deactivate_all_queues(&priv->channels);\n\tmlx5e_qos_close_all_queues(&priv->channels);\n\n\treturn err;\n}\n\nstatic int mlx5e_htb_convert_rate(struct mlx5e_htb *htb, u64 rate,\n\t\t\t\t  struct mlx5e_qos_node *parent, u32 *bw_share)\n{\n\tu64 share = 0;\n\n\twhile (parent->classid != MLX5E_HTB_CLASSID_ROOT && !parent->max_average_bw)\n\t\tparent = parent->parent;\n\n\tif (parent->max_average_bw)\n\t\tshare = div64_u64(div_u64(rate * 100, BYTES_IN_MBIT),\n\t\t\t\t  parent->max_average_bw);\n\telse\n\t\tshare = 101;\n\n\t*bw_share = share == 0 ? 1 : share > 100 ? 0 : share;\n\n\tqos_dbg(htb->mdev, \"Convert: rate %llu, parent ceil %llu -> bw_share %u\\n\",\n\t\trate, (u64)parent->max_average_bw * BYTES_IN_MBIT, *bw_share);\n\n\treturn 0;\n}\n\nstatic void mlx5e_htb_convert_ceil(struct mlx5e_htb *htb, u64 ceil, u32 *max_average_bw)\n{\n\t \n\t*max_average_bw = max_t(u32, div_u64(ceil, BYTES_IN_MBIT), 1);\n\n\tqos_dbg(htb->mdev, \"Convert: ceil %llu -> max_average_bw %u\\n\",\n\t\tceil, *max_average_bw);\n}\n\nint\nmlx5e_htb_leaf_alloc_queue(struct mlx5e_htb *htb, u16 classid,\n\t\t\t   u32 parent_classid, u64 rate, u64 ceil,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_qos_node *node, *parent;\n\tstruct mlx5e_priv *priv = htb->priv;\n\tint qid;\n\tint err;\n\n\tqos_dbg(htb->mdev, \"TC_HTB_LEAF_ALLOC_QUEUE classid %04x, parent %04x, rate %llu, ceil %llu\\n\",\n\t\tclassid, parent_classid, rate, ceil);\n\n\tqid = mlx5e_htb_find_unused_qos_qid(htb);\n\tif (qid < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Maximum amount of leaf classes is reached.\");\n\t\treturn qid;\n\t}\n\n\tparent = mlx5e_htb_node_find(htb, parent_classid);\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\tnode = mlx5e_htb_node_create_leaf(htb, classid, qid, parent);\n\tif (IS_ERR(node))\n\t\treturn PTR_ERR(node);\n\n\tnode->rate = rate;\n\tmlx5e_htb_convert_rate(htb, rate, node->parent, &node->bw_share);\n\tmlx5e_htb_convert_ceil(htb, ceil, &node->max_average_bw);\n\n\terr = mlx5_qos_create_leaf_node(htb->mdev, node->parent->hw_id,\n\t\t\t\t\tnode->bw_share, node->max_average_bw,\n\t\t\t\t\t&node->hw_id);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware error when creating a leaf node.\");\n\t\tqos_err(htb->mdev, \"Failed to create a leaf node (class %04x), err = %d\\n\",\n\t\t\tclassid, err);\n\t\tmlx5e_htb_node_delete(htb, node);\n\t\treturn err;\n\t}\n\n\tif (test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\terr = mlx5e_open_qos_sq(priv, &priv->channels, node->qid, node->hw_id);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Error creating an SQ.\");\n\t\t\tqos_warn(htb->mdev, \"Failed to create a QoS SQ (class %04x), err = %d\\n\",\n\t\t\t\t classid, err);\n\t\t} else {\n\t\t\tmlx5e_activate_qos_sq(priv, node->qid, node->hw_id);\n\t\t}\n\t}\n\n\treturn mlx5e_qid_from_qos(&priv->channels, node->qid);\n}\n\nint\nmlx5e_htb_leaf_to_inner(struct mlx5e_htb *htb, u16 classid, u16 child_classid,\n\t\t\tu64 rate, u64 ceil, struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_qos_node *node, *child;\n\tstruct mlx5e_priv *priv = htb->priv;\n\tint err, tmp_err;\n\tu32 new_hw_id;\n\tu16 qid;\n\n\tqos_dbg(htb->mdev, \"TC_HTB_LEAF_TO_INNER classid %04x, upcoming child %04x, rate %llu, ceil %llu\\n\",\n\t\tclassid, child_classid, rate, ceil);\n\n\tnode = mlx5e_htb_node_find(htb, classid);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\terr = mlx5_qos_create_inner_node(htb->mdev, node->parent->hw_id,\n\t\t\t\t\t node->bw_share, node->max_average_bw,\n\t\t\t\t\t &new_hw_id);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware error when creating an inner node.\");\n\t\tqos_err(htb->mdev, \"Failed to create an inner node (class %04x), err = %d\\n\",\n\t\t\tclassid, err);\n\t\treturn err;\n\t}\n\n\t \n\tchild = mlx5e_htb_node_create_leaf(htb, child_classid, node->qid, node);\n\tif (IS_ERR(child)) {\n\t\terr = PTR_ERR(child);\n\t\tgoto err_destroy_hw_node;\n\t}\n\n\tchild->rate = rate;\n\tmlx5e_htb_convert_rate(htb, rate, node, &child->bw_share);\n\tmlx5e_htb_convert_ceil(htb, ceil, &child->max_average_bw);\n\n\terr = mlx5_qos_create_leaf_node(htb->mdev, new_hw_id, child->bw_share,\n\t\t\t\t\tchild->max_average_bw, &child->hw_id);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware error when creating a leaf node.\");\n\t\tqos_err(htb->mdev, \"Failed to create a leaf node (class %04x), err = %d\\n\",\n\t\t\tclassid, err);\n\t\tgoto err_delete_sw_node;\n\t}\n\n\t \n\n\tqid = node->qid;\n\t \n\tWRITE_ONCE(node->qid, MLX5E_QOS_QID_INNER);\n\n\tif (test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\tmlx5e_deactivate_qos_sq(priv, qid);\n\t\tmlx5e_close_qos_sq(priv, qid);\n\t}\n\n\terr = mlx5_qos_destroy_node(htb->mdev, node->hw_id);\n\tif (err)  \n\t\tqos_warn(htb->mdev, \"Failed to destroy leaf node %u (class %04x), err = %d\\n\",\n\t\t\t node->hw_id, classid, err);\n\n\tnode->hw_id = new_hw_id;\n\n\tif (test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\terr = mlx5e_open_qos_sq(priv, &priv->channels, child->qid, child->hw_id);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Error creating an SQ.\");\n\t\t\tqos_warn(htb->mdev, \"Failed to create a QoS SQ (class %04x), err = %d\\n\",\n\t\t\t\t classid, err);\n\t\t} else {\n\t\t\tmlx5e_activate_qos_sq(priv, child->qid, child->hw_id);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_delete_sw_node:\n\tchild->qid = MLX5E_QOS_QID_INNER;\n\tmlx5e_htb_node_delete(htb, child);\n\nerr_destroy_hw_node:\n\ttmp_err = mlx5_qos_destroy_node(htb->mdev, new_hw_id);\n\tif (tmp_err)  \n\t\tqos_warn(htb->mdev, \"Failed to roll back creation of an inner node %u (class %04x), err = %d\\n\",\n\t\t\t new_hw_id, classid, tmp_err);\n\treturn err;\n}\n\nstatic struct mlx5e_qos_node *mlx5e_htb_node_find_by_qid(struct mlx5e_htb *htb, u16 qid)\n{\n\tstruct mlx5e_qos_node *node = NULL;\n\tint bkt;\n\n\thash_for_each(htb->qos_tc2node, bkt, node, hnode)\n\t\tif (node->qid == qid)\n\t\t\tbreak;\n\n\treturn node;\n}\n\nint mlx5e_htb_leaf_del(struct mlx5e_htb *htb, u16 *classid,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = htb->priv;\n\tstruct mlx5e_qos_node *node;\n\tstruct netdev_queue *txq;\n\tu16 qid, moved_qid;\n\tbool opened;\n\tint err;\n\n\tqos_dbg(htb->mdev, \"TC_HTB_LEAF_DEL classid %04x\\n\", *classid);\n\n\tnode = mlx5e_htb_node_find(htb, *classid);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\t \n\tqid = node->qid;\n\n\topened = test_bit(MLX5E_STATE_OPENED, &priv->state);\n\tif (opened) {\n\t\ttxq = netdev_get_tx_queue(htb->netdev,\n\t\t\t\t\t  mlx5e_qid_from_qos(&priv->channels, qid));\n\t\tmlx5e_deactivate_qos_sq(priv, qid);\n\t\tmlx5e_close_qos_sq(priv, qid);\n\t}\n\n\terr = mlx5_qos_destroy_node(htb->mdev, node->hw_id);\n\tif (err)  \n\t\tqos_warn(htb->mdev, \"Failed to destroy leaf node %u (class %04x), err = %d\\n\",\n\t\t\t node->hw_id, *classid, err);\n\n\tmlx5e_htb_node_delete(htb, node);\n\n\tmoved_qid = mlx5e_htb_cur_leaf_nodes(htb);\n\n\tif (moved_qid == 0) {\n\t\t \n\t\tif (opened)\n\t\t\tmlx5e_reactivate_qos_sq(priv, qid, txq);\n\t\treturn 0;\n\t}\n\tmoved_qid--;\n\n\tif (moved_qid < qid) {\n\t\t \n\t\tWARN(moved_qid != qid - 1, \"Gaps in queue numeration: destroyed queue %u, the highest queue is %u\",\n\t\t     qid, moved_qid);\n\t\tif (opened)\n\t\t\tmlx5e_reactivate_qos_sq(priv, qid, txq);\n\t\treturn 0;\n\t}\n\n\tWARN(moved_qid == qid, \"Can't move node with qid %u to itself\", qid);\n\tqos_dbg(htb->mdev, \"Moving QoS SQ %u to %u\\n\", moved_qid, qid);\n\n\tnode = mlx5e_htb_node_find_by_qid(htb, moved_qid);\n\tWARN(!node, \"Could not find a node with qid %u to move to queue %u\",\n\t     moved_qid, qid);\n\n\t \n\tWRITE_ONCE(node->qid, MLX5E_QOS_QID_INNER);\n\t__clear_bit(moved_qid, priv->htb->qos_used_qids);\n\n\tif (opened) {\n\t\ttxq = netdev_get_tx_queue(htb->netdev,\n\t\t\t\t\t  mlx5e_qid_from_qos(&priv->channels, moved_qid));\n\t\tmlx5e_deactivate_qos_sq(priv, moved_qid);\n\t\tmlx5e_close_qos_sq(priv, moved_qid);\n\t}\n\n\t \n\tmlx5e_reset_qdisc(htb->netdev, moved_qid);\n\n\t__set_bit(qid, htb->qos_used_qids);\n\tWRITE_ONCE(node->qid, qid);\n\n\tif (test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\terr = mlx5e_open_qos_sq(priv, &priv->channels, node->qid, node->hw_id);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Error creating an SQ.\");\n\t\t\tqos_warn(htb->mdev, \"Failed to create a QoS SQ (class %04x) while moving qid %u to %u, err = %d\\n\",\n\t\t\t\t node->classid, moved_qid, qid, err);\n\t\t} else {\n\t\t\tmlx5e_activate_qos_sq(priv, node->qid, node->hw_id);\n\t\t}\n\t}\n\n\tmlx5e_update_tx_netdev_queues(priv);\n\tif (opened)\n\t\tmlx5e_reactivate_qos_sq(priv, moved_qid, txq);\n\n\t*classid = node->classid;\n\treturn 0;\n}\n\nint\nmlx5e_htb_leaf_del_last(struct mlx5e_htb *htb, u16 classid, bool force,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_qos_node *node, *parent;\n\tstruct mlx5e_priv *priv = htb->priv;\n\tu32 old_hw_id, new_hw_id;\n\tint err, saved_err = 0;\n\tu16 qid;\n\n\tqos_dbg(htb->mdev, \"TC_HTB_LEAF_DEL_LAST%s classid %04x\\n\",\n\t\tforce ? \"_FORCE\" : \"\", classid);\n\n\tnode = mlx5e_htb_node_find(htb, classid);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\terr = mlx5_qos_create_leaf_node(htb->mdev, node->parent->parent->hw_id,\n\t\t\t\t\tnode->parent->bw_share,\n\t\t\t\t\tnode->parent->max_average_bw,\n\t\t\t\t\t&new_hw_id);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware error when creating a leaf node.\");\n\t\tqos_err(htb->mdev, \"Failed to create a leaf node (class %04x), err = %d\\n\",\n\t\t\tclassid, err);\n\t\tif (!force)\n\t\t\treturn err;\n\t\tsaved_err = err;\n\t}\n\n\t \n\tqid = node->qid;\n\t \n\tWRITE_ONCE(node->qid, MLX5E_QOS_QID_INNER);\n\n\tif (test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\tmlx5e_deactivate_qos_sq(priv, qid);\n\t\tmlx5e_close_qos_sq(priv, qid);\n\t}\n\n\t \n\tmlx5e_reset_qdisc(htb->netdev, qid);\n\n\terr = mlx5_qos_destroy_node(htb->mdev, node->hw_id);\n\tif (err)  \n\t\tqos_warn(htb->mdev, \"Failed to destroy leaf node %u (class %04x), err = %d\\n\",\n\t\t\t node->hw_id, classid, err);\n\n\tparent = node->parent;\n\tmlx5e_htb_node_delete(htb, node);\n\n\tnode = parent;\n\tWRITE_ONCE(node->qid, qid);\n\n\t \n\tif (saved_err)\n\t\treturn saved_err;\n\n\told_hw_id = node->hw_id;\n\tnode->hw_id = new_hw_id;\n\n\tif (test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\terr = mlx5e_open_qos_sq(priv, &priv->channels, node->qid, node->hw_id);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Error creating an SQ.\");\n\t\t\tqos_warn(htb->mdev, \"Failed to create a QoS SQ (class %04x), err = %d\\n\",\n\t\t\t\t classid, err);\n\t\t} else {\n\t\t\tmlx5e_activate_qos_sq(priv, node->qid, node->hw_id);\n\t\t}\n\t}\n\n\terr = mlx5_qos_destroy_node(htb->mdev, old_hw_id);\n\tif (err)  \n\t\tqos_warn(htb->mdev, \"Failed to destroy leaf node %u (class %04x), err = %d\\n\",\n\t\t\t node->hw_id, classid, err);\n\n\treturn 0;\n}\n\nstatic int\nmlx5e_htb_update_children(struct mlx5e_htb *htb, struct mlx5e_qos_node *node,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_qos_node *child;\n\tint err = 0;\n\tint bkt;\n\n\thash_for_each(htb->qos_tc2node, bkt, child, hnode) {\n\t\tu32 old_bw_share = child->bw_share;\n\t\tint err_one;\n\n\t\tif (child->parent != node)\n\t\t\tcontinue;\n\n\t\tmlx5e_htb_convert_rate(htb, child->rate, node, &child->bw_share);\n\t\tif (child->bw_share == old_bw_share)\n\t\t\tcontinue;\n\n\t\terr_one = mlx5_qos_update_node(htb->mdev, child->bw_share,\n\t\t\t\t\t       child->max_average_bw, child->hw_id);\n\t\tif (!err && err_one) {\n\t\t\terr = err_one;\n\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware error when modifying a child node.\");\n\t\t\tqos_err(htb->mdev, \"Failed to modify a child node (class %04x), err = %d\\n\",\n\t\t\t\tnode->classid, err);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint\nmlx5e_htb_node_modify(struct mlx5e_htb *htb, u16 classid, u64 rate, u64 ceil,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tu32 bw_share, max_average_bw;\n\tstruct mlx5e_qos_node *node;\n\tbool ceil_changed = false;\n\tint err;\n\n\tqos_dbg(htb->mdev, \"TC_HTB_LEAF_MODIFY classid %04x, rate %llu, ceil %llu\\n\",\n\t\tclassid, rate, ceil);\n\n\tnode = mlx5e_htb_node_find(htb, classid);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tnode->rate = rate;\n\tmlx5e_htb_convert_rate(htb, rate, node->parent, &bw_share);\n\tmlx5e_htb_convert_ceil(htb, ceil, &max_average_bw);\n\n\terr = mlx5_qos_update_node(htb->mdev, bw_share,\n\t\t\t\t   max_average_bw, node->hw_id);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware error when modifying a node.\");\n\t\tqos_err(htb->mdev, \"Failed to modify a node (class %04x), err = %d\\n\",\n\t\t\tclassid, err);\n\t\treturn err;\n\t}\n\n\tif (max_average_bw != node->max_average_bw)\n\t\tceil_changed = true;\n\n\tnode->bw_share = bw_share;\n\tnode->max_average_bw = max_average_bw;\n\n\tif (ceil_changed)\n\t\terr = mlx5e_htb_update_children(htb, node, extack);\n\n\treturn err;\n}\n\nstruct mlx5e_htb *mlx5e_htb_alloc(void)\n{\n\treturn kvzalloc(sizeof(struct mlx5e_htb), GFP_KERNEL);\n}\n\nvoid mlx5e_htb_free(struct mlx5e_htb *htb)\n{\n\tkvfree(htb);\n}\n\nint mlx5e_htb_init(struct mlx5e_htb *htb, struct tc_htb_qopt_offload *htb_qopt,\n\t\t   struct net_device *netdev, struct mlx5_core_dev *mdev,\n\t\t   struct mlx5e_selq *selq, struct mlx5e_priv *priv)\n{\n\thtb->mdev = mdev;\n\thtb->netdev = netdev;\n\thtb->selq = selq;\n\thtb->priv = priv;\n\thash_init(htb->qos_tc2node);\n\treturn mlx5e_htb_root_add(htb, htb_qopt->parent_classid, htb_qopt->classid,\n\t\t\t\t  htb_qopt->extack);\n}\n\nvoid mlx5e_htb_cleanup(struct mlx5e_htb *htb)\n{\n\tmlx5e_htb_root_del(htb);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}