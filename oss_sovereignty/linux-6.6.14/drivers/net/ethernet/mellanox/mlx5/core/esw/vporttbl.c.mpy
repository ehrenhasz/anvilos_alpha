{
  "module_name": "vporttbl.c",
  "hash_id": "fcabd04ac98d6609797100aaa88a1a2fc898737dfd6b3ceb4a4cdab9ad640c91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/vporttbl.c",
  "human_readable_source": "\n\n\n#include \"eswitch.h\"\n\n \nstruct mlx5_vport_key {\n\tu32 chain;\n\tu16 prio;\n\tu16 vport;\n\tu16 vhca_id;\n\tstruct esw_vport_tbl_namespace *vport_ns;\n} __packed;\n\nstruct mlx5_vport_table {\n\tstruct hlist_node hlist;\n\tstruct mlx5_flow_table *fdb;\n\tu32 num_rules;\n\tstruct mlx5_vport_key key;\n};\n\nstatic void\nesw_vport_tbl_init(struct mlx5_eswitch *esw, struct esw_vport_tbl_namespace *ns)\n{\n\tif (esw->offloads.encap != DEVLINK_ESWITCH_ENCAP_MODE_NONE)\n\t\tns->flags |= (MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT |\n\t\t\t      MLX5_FLOW_TABLE_TUNNEL_EN_DECAP);\n}\n\nstatic struct mlx5_flow_table *\nesw_vport_tbl_create(struct mlx5_eswitch *esw, struct mlx5_flow_namespace *ns,\n\t\t     const struct esw_vport_tbl_namespace *vport_ns)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_table *fdb;\n\n\tif (vport_ns->max_num_groups)\n\t\tft_attr.autogroup.max_num_groups = vport_ns->max_num_groups;\n\telse\n\t\tft_attr.autogroup.max_num_groups = esw->params.large_group_num;\n\tft_attr.max_fte = vport_ns->max_fte;\n\tft_attr.prio = FDB_PER_VPORT;\n\tft_attr.flags = vport_ns->flags;\n\tfdb = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);\n\tif (IS_ERR(fdb)) {\n\t\tesw_warn(esw->dev, \"Failed to create per vport FDB Table err %ld\\n\",\n\t\t\t PTR_ERR(fdb));\n\t}\n\n\treturn fdb;\n}\n\nstatic u32 flow_attr_to_vport_key(struct mlx5_eswitch *esw,\n\t\t\t\t  struct mlx5_vport_tbl_attr *attr,\n\t\t\t\t  struct mlx5_vport_key *key)\n{\n\tkey->vport = attr->vport;\n\tkey->chain = attr->chain;\n\tkey->prio = attr->prio;\n\tkey->vhca_id = MLX5_CAP_GEN(esw->dev, vhca_id);\n\tkey->vport_ns  = attr->vport_ns;\n\treturn jhash(key, sizeof(*key), 0);\n}\n\n \nstatic struct mlx5_vport_table *\nesw_vport_tbl_lookup(struct mlx5_eswitch *esw, struct mlx5_vport_key *skey, u32 key)\n{\n\tstruct mlx5_vport_table *e;\n\n\thash_for_each_possible(esw->fdb_table.offloads.vports.table, e, hlist, key)\n\t\tif (!memcmp(&e->key, skey, sizeof(*skey)))\n\t\t\treturn e;\n\n\treturn NULL;\n}\n\nstruct mlx5_flow_table *\nmlx5_esw_vporttbl_get(struct mlx5_eswitch *esw, struct mlx5_vport_tbl_attr *attr)\n{\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_table *fdb;\n\tstruct mlx5_vport_table *e;\n\tstruct mlx5_vport_key skey;\n\tu32 hkey;\n\n\tmutex_lock(&esw->fdb_table.offloads.vports.lock);\n\tesw_vport_tbl_init(esw, attr->vport_ns);\n\thkey = flow_attr_to_vport_key(esw, attr, &skey);\n\te = esw_vport_tbl_lookup(esw, &skey, hkey);\n\tif (e) {\n\t\te->num_rules++;\n\t\tgoto out;\n\t}\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e) {\n\t\tfdb = ERR_PTR(-ENOMEM);\n\t\tgoto err_alloc;\n\t}\n\n\tns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);\n\tif (!ns) {\n\t\tesw_warn(dev, \"Failed to get FDB namespace\\n\");\n\t\tfdb = ERR_PTR(-ENOENT);\n\t\tgoto err_ns;\n\t}\n\n\tfdb = esw_vport_tbl_create(esw, ns, attr->vport_ns);\n\tif (IS_ERR(fdb))\n\t\tgoto err_ns;\n\n\te->fdb = fdb;\n\te->num_rules = 1;\n\te->key = skey;\n\thash_add(esw->fdb_table.offloads.vports.table, &e->hlist, hkey);\nout:\n\tmutex_unlock(&esw->fdb_table.offloads.vports.lock);\n\treturn e->fdb;\n\nerr_ns:\n\tkfree(e);\nerr_alloc:\n\tmutex_unlock(&esw->fdb_table.offloads.vports.lock);\n\treturn fdb;\n}\n\nvoid\nmlx5_esw_vporttbl_put(struct mlx5_eswitch *esw, struct mlx5_vport_tbl_attr *attr)\n{\n\tstruct mlx5_vport_table *e;\n\tstruct mlx5_vport_key key;\n\tu32 hkey;\n\n\tmutex_lock(&esw->fdb_table.offloads.vports.lock);\n\tesw_vport_tbl_init(esw, attr->vport_ns);\n\thkey = flow_attr_to_vport_key(esw, attr, &key);\n\te = esw_vport_tbl_lookup(esw, &key, hkey);\n\tif (!e || --e->num_rules)\n\t\tgoto out;\n\n\thash_del(&e->hlist);\n\tmlx5_destroy_flow_table(e->fdb);\n\tkfree(e);\nout:\n\tmutex_unlock(&esw->fdb_table.offloads.vports.lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}