{
  "module_name": "fs_dr.c",
  "hash_id": "10e5dac18b14f24aa46d5ea4362c0173b9b1835e14dbc3986693f6768902a95d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/fs_dr.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/vport.h>\n#include \"mlx5_core.h\"\n#include \"fs_core.h\"\n#include \"fs_cmd.h\"\n#include \"mlx5dr.h\"\n#include \"fs_dr.h\"\n#include \"dr_types.h\"\n\nstatic bool dr_is_fw_term_table(struct mlx5_flow_table *ft)\n{\n\tif (ft->flags & MLX5_FLOW_TABLE_TERMINATION)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int mlx5_cmd_dr_update_root_ft(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t      struct mlx5_flow_table *ft,\n\t\t\t\t      u32 underlay_qpn,\n\t\t\t\t      bool disconnect)\n{\n\treturn mlx5_fs_cmd_get_fw_cmds()->update_root_ft(ns, ft, underlay_qpn,\n\t\t\t\t\t\t\t disconnect);\n}\n\nstatic int set_miss_action(struct mlx5_flow_root_namespace *ns,\n\t\t\t   struct mlx5_flow_table *ft,\n\t\t\t   struct mlx5_flow_table *next_ft)\n{\n\tstruct mlx5dr_action *old_miss_action;\n\tstruct mlx5dr_action *action = NULL;\n\tstruct mlx5dr_table *next_tbl;\n\tint err;\n\n\tnext_tbl = next_ft ? next_ft->fs_dr_table.dr_table : NULL;\n\tif (next_tbl) {\n\t\taction = mlx5dr_action_create_dest_table(next_tbl);\n\t\tif (!action)\n\t\t\treturn -EINVAL;\n\t}\n\told_miss_action = ft->fs_dr_table.miss_action;\n\terr = mlx5dr_table_set_miss_action(ft->fs_dr_table.dr_table, action);\n\tif (err && action) {\n\t\terr = mlx5dr_action_destroy(action);\n\t\tif (err)\n\t\t\tmlx5_core_err(ns->dev,\n\t\t\t\t      \"Failed to destroy action (%d)\\n\", err);\n\t\taction = NULL;\n\t}\n\tft->fs_dr_table.miss_action = action;\n\tif (old_miss_action) {\n\t\terr = mlx5dr_action_destroy(old_miss_action);\n\t\tif (err)\n\t\t\tmlx5_core_err(ns->dev, \"Failed to destroy action (%d)\\n\",\n\t\t\t\t      err);\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5_cmd_dr_create_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t struct mlx5_flow_table *ft,\n\t\t\t\t\t struct mlx5_flow_table_attr *ft_attr,\n\t\t\t\t\t struct mlx5_flow_table *next_ft)\n{\n\tstruct mlx5dr_table *tbl;\n\tu32 flags;\n\tint err;\n\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->create_flow_table(ns, ft,\n\t\t\t\t\t\t\t\t    ft_attr,\n\t\t\t\t\t\t\t\t    next_ft);\n\tflags = ft->flags;\n\t \n\tif (!MLX5_CAP_FLOWTABLE(ns->dev, sw_owner_reformat_supported))\n\t\tflags = ft->flags & ~(MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT |\n\t\t\t\t      MLX5_FLOW_TABLE_TUNNEL_EN_DECAP);\n\n\ttbl = mlx5dr_table_create(ns->fs_dr_domain.dr_domain, ft->level, flags,\n\t\t\t\t  ft_attr->uid);\n\tif (!tbl) {\n\t\tmlx5_core_err(ns->dev, \"Failed creating dr flow_table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tft->fs_dr_table.dr_table = tbl;\n\tft->id = mlx5dr_table_get_id(tbl);\n\n\tif (next_ft) {\n\t\terr = set_miss_action(ns, ft, next_ft);\n\t\tif (err) {\n\t\t\tmlx5dr_table_destroy(tbl);\n\t\t\tft->fs_dr_table.dr_table = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tft->max_fte = INT_MAX;\n\n\treturn 0;\n}\n\nstatic int mlx5_cmd_dr_destroy_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t  struct mlx5_flow_table *ft)\n{\n\tstruct mlx5dr_action *action = ft->fs_dr_table.miss_action;\n\tint err;\n\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->destroy_flow_table(ns, ft);\n\n\terr = mlx5dr_table_destroy(ft->fs_dr_table.dr_table);\n\tif (err) {\n\t\tmlx5_core_err(ns->dev, \"Failed to destroy flow_table (%d)\\n\",\n\t\t\t      err);\n\t\treturn err;\n\t}\n\tif (action) {\n\t\terr = mlx5dr_action_destroy(action);\n\t\tif (err) {\n\t\t\tmlx5_core_err(ns->dev, \"Failed to destroy action(%d)\\n\",\n\t\t\t\t      err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5_cmd_dr_modify_flow_table(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t struct mlx5_flow_table *ft,\n\t\t\t\t\t struct mlx5_flow_table *next_ft)\n{\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->modify_flow_table(ns, ft, next_ft);\n\n\treturn set_miss_action(ns, ft, next_ft);\n}\n\nstatic int mlx5_cmd_dr_create_flow_group(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t struct mlx5_flow_table *ft,\n\t\t\t\t\t u32 *in,\n\t\t\t\t\t struct mlx5_flow_group *fg)\n{\n\tstruct mlx5dr_matcher *matcher;\n\tu32 priority = MLX5_GET(create_flow_group_in, in,\n\t\t\t\tstart_flow_index);\n\tu8 match_criteria_enable = MLX5_GET(create_flow_group_in,\n\t\t\t\t\t    in,\n\t\t\t\t\t    match_criteria_enable);\n\tstruct mlx5dr_match_parameters mask;\n\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->create_flow_group(ns, ft, in,\n\t\t\t\t\t\t\t\t    fg);\n\n\tmask.match_buf = MLX5_ADDR_OF(create_flow_group_in,\n\t\t\t\t      in, match_criteria);\n\tmask.match_sz = sizeof(fg->mask.match_criteria);\n\n\tmatcher = mlx5dr_matcher_create(ft->fs_dr_table.dr_table,\n\t\t\t\t\tpriority,\n\t\t\t\t\tmatch_criteria_enable,\n\t\t\t\t\t&mask);\n\tif (!matcher) {\n\t\tmlx5_core_err(ns->dev, \"Failed creating matcher\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfg->fs_dr_matcher.dr_matcher = matcher;\n\treturn 0;\n}\n\nstatic int mlx5_cmd_dr_destroy_flow_group(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t  struct mlx5_flow_table *ft,\n\t\t\t\t\t  struct mlx5_flow_group *fg)\n{\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->destroy_flow_group(ns, ft, fg);\n\n\treturn mlx5dr_matcher_destroy(fg->fs_dr_matcher.dr_matcher);\n}\n\nstatic struct mlx5dr_action *create_vport_action(struct mlx5dr_domain *domain,\n\t\t\t\t\t\t struct mlx5_flow_rule *dst)\n{\n\tstruct mlx5_flow_destination *dest_attr = &dst->dest_attr;\n\n\treturn mlx5dr_action_create_dest_vport(domain, dest_attr->vport.num,\n\t\t\t\t\t       dest_attr->vport.flags &\n\t\t\t\t\t       MLX5_FLOW_DEST_VPORT_VHCA_ID,\n\t\t\t\t\t       dest_attr->vport.vhca_id);\n}\n\nstatic struct mlx5dr_action *create_uplink_action(struct mlx5dr_domain *domain,\n\t\t\t\t\t\t  struct mlx5_flow_rule *dst)\n{\n\tstruct mlx5_flow_destination *dest_attr = &dst->dest_attr;\n\n\treturn mlx5dr_action_create_dest_vport(domain, MLX5_VPORT_UPLINK, 1,\n\t\t\t\t\t       dest_attr->vport.vhca_id);\n}\n\nstatic struct mlx5dr_action *create_ft_action(struct mlx5dr_domain *domain,\n\t\t\t\t\t      struct mlx5_flow_rule *dst)\n{\n\tstruct mlx5_flow_table *dest_ft = dst->dest_attr.ft;\n\n\tif (mlx5dr_is_fw_table(dest_ft))\n\t\treturn mlx5dr_action_create_dest_flow_fw_table(domain, dest_ft);\n\treturn mlx5dr_action_create_dest_table(dest_ft->fs_dr_table.dr_table);\n}\n\nstatic struct mlx5dr_action *create_range_action(struct mlx5dr_domain *domain,\n\t\t\t\t\t\t struct mlx5_flow_rule *dst)\n{\n\treturn mlx5dr_action_create_dest_match_range(domain,\n\t\t\t\t\t\t     dst->dest_attr.range.field,\n\t\t\t\t\t\t     dst->dest_attr.range.hit_ft,\n\t\t\t\t\t\t     dst->dest_attr.range.miss_ft,\n\t\t\t\t\t\t     dst->dest_attr.range.min,\n\t\t\t\t\t\t     dst->dest_attr.range.max);\n}\n\nstatic struct mlx5dr_action *create_action_push_vlan(struct mlx5dr_domain *domain,\n\t\t\t\t\t\t     struct mlx5_fs_vlan *vlan)\n{\n\tu16 n_ethtype = vlan->ethtype;\n\tu8  prio = vlan->prio;\n\tu16 vid = vlan->vid;\n\tu32 vlan_hdr;\n\n\tvlan_hdr = (u32)n_ethtype << 16 | (u32)(prio) << 12 |  (u32)vid;\n\treturn mlx5dr_action_create_push_vlan(domain, htonl(vlan_hdr));\n}\n\nstatic bool contain_vport_reformat_action(struct mlx5_flow_rule *dst)\n{\n\treturn (dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_VPORT ||\n\t\tdst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_UPLINK) &&\n\t\tdst->dest_attr.vport.flags & MLX5_FLOW_DEST_VPORT_REFORMAT_ID;\n}\n\n \n#define MLX5_FLOW_CONTEXT_ACTION_MAX  34\nstatic int mlx5_cmd_dr_create_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t  struct mlx5_flow_table *ft,\n\t\t\t\t  struct mlx5_flow_group *group,\n\t\t\t\t  struct fs_fte *fte)\n{\n\tstruct mlx5dr_domain *domain = ns->fs_dr_domain.dr_domain;\n\tstruct mlx5dr_action_dest *term_actions;\n\tstruct mlx5dr_match_parameters params;\n\tstruct mlx5_core_dev *dev = ns->dev;\n\tstruct mlx5dr_action **fs_dr_actions;\n\tstruct mlx5dr_action *tmp_action;\n\tstruct mlx5dr_action **actions;\n\tbool delay_encap_set = false;\n\tstruct mlx5dr_rule *rule;\n\tstruct mlx5_flow_rule *dst;\n\tint fs_dr_num_actions = 0;\n\tint num_term_actions = 0;\n\tint num_actions = 0;\n\tsize_t match_sz;\n\tint err = 0;\n\tint i;\n\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->create_fte(ns, ft, group, fte);\n\n\tactions = kcalloc(MLX5_FLOW_CONTEXT_ACTION_MAX, sizeof(*actions),\n\t\t\t  GFP_KERNEL);\n\tif (!actions) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tfs_dr_actions = kcalloc(MLX5_FLOW_CONTEXT_ACTION_MAX,\n\t\t\t\tsizeof(*fs_dr_actions), GFP_KERNEL);\n\tif (!fs_dr_actions) {\n\t\terr = -ENOMEM;\n\t\tgoto free_actions_alloc;\n\t}\n\n\tterm_actions = kcalloc(MLX5_FLOW_CONTEXT_ACTION_MAX,\n\t\t\t       sizeof(*term_actions), GFP_KERNEL);\n\tif (!term_actions) {\n\t\terr = -ENOMEM;\n\t\tgoto free_fs_dr_actions_alloc;\n\t}\n\n\tmatch_sz = sizeof(fte->val);\n\n\t \n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {\n\t\tlist_for_each_entry(dst, &fte->node.children, node.list) {\n\t\t\tif (!contain_vport_reformat_action(dst))\n\t\t\t\tcontinue;\n\n\t\t\tfte->action.action &= ~MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_DECAP) {\n\t\tenum mlx5dr_action_reformat_type decap_type =\n\t\t\tDR_ACTION_REFORMAT_TYP_TNL_L2_TO_L2;\n\n\t\ttmp_action = mlx5dr_action_create_packet_reformat(domain,\n\t\t\t\t\t\t\t\t  decap_type,\n\t\t\t\t\t\t\t\t  0, 0, 0,\n\t\t\t\t\t\t\t\t  NULL);\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT) {\n\t\tbool is_decap;\n\n\t\tif (fte->action.pkt_reformat->owner == MLX5_FLOW_RESOURCE_OWNER_FW) {\n\t\t\terr = -EINVAL;\n\t\t\tmlx5dr_err(domain, \"FW-owned reformat can't be used in SW rule\\n\");\n\t\t\tgoto free_actions;\n\t\t}\n\n\t\tis_decap = fte->action.pkt_reformat->reformat_type ==\n\t\t\t   MLX5_REFORMAT_TYPE_L3_TUNNEL_TO_L2;\n\n\t\tif (is_decap)\n\t\t\tactions[num_actions++] =\n\t\t\t\tfte->action.pkt_reformat->action.dr_action;\n\t\telse\n\t\t\tdelay_encap_set = true;\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP) {\n\t\ttmp_action =\n\t\t\tmlx5dr_action_create_pop_vlan();\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2) {\n\t\ttmp_action =\n\t\t\tmlx5dr_action_create_pop_vlan();\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)\n\t\tactions[num_actions++] =\n\t\t\tfte->action.modify_hdr->action.dr_action;\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH) {\n\t\ttmp_action = create_action_push_vlan(domain, &fte->action.vlan[0]);\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2) {\n\t\ttmp_action = create_action_push_vlan(domain, &fte->action.vlan[1]);\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\tif (delay_encap_set)\n\t\tactions[num_actions++] =\n\t\t\tfte->action.pkt_reformat->action.dr_action;\n\n\t \n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_DROP) {\n\t\ttmp_action = mlx5dr_action_create_drop();\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tterm_actions[num_term_actions++].dest = tmp_action;\n\t}\n\n\tif (fte->flow_context.flow_tag) {\n\t\ttmp_action =\n\t\t\tmlx5dr_action_create_tag(fte->flow_context.flow_tag);\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {\n\t\tlist_for_each_entry(dst, &fte->node.children, node.list) {\n\t\t\tenum mlx5_flow_destination_type type = dst->dest_attr.type;\n\t\t\tu32 id;\n\n\t\t\tif (fs_dr_num_actions == MLX5_FLOW_CONTEXT_ACTION_MAX ||\n\t\t\t    num_term_actions == MLX5_FLOW_CONTEXT_ACTION_MAX) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto free_actions;\n\t\t\t}\n\n\t\t\tif (type == MLX5_FLOW_DESTINATION_TYPE_COUNTER)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (type) {\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE:\n\t\t\t\ttmp_action = create_ft_action(domain, dst);\n\t\t\t\tif (!tmp_action) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto free_actions;\n\t\t\t\t}\n\t\t\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\t\t\tterm_actions[num_term_actions++].dest = tmp_action;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_UPLINK:\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_VPORT:\n\t\t\t\ttmp_action = type == MLX5_FLOW_DESTINATION_TYPE_VPORT ?\n\t\t\t\t\t     create_vport_action(domain, dst) :\n\t\t\t\t\t     create_uplink_action(domain, dst);\n\t\t\t\tif (!tmp_action) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto free_actions;\n\t\t\t\t}\n\t\t\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\t\t\tterm_actions[num_term_actions].dest = tmp_action;\n\n\t\t\t\tif (dst->dest_attr.vport.flags &\n\t\t\t\t    MLX5_FLOW_DEST_VPORT_REFORMAT_ID)\n\t\t\t\t\tterm_actions[num_term_actions].reformat =\n\t\t\t\t\t\tdst->dest_attr.vport.pkt_reformat->action.dr_action;\n\n\t\t\t\tnum_term_actions++;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE_NUM:\n\t\t\t\tid = dst->dest_attr.ft_num;\n\t\t\t\ttmp_action = mlx5dr_action_create_dest_table_num(domain,\n\t\t\t\t\t\t\t\t\t\t id);\n\t\t\t\tif (!tmp_action) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto free_actions;\n\t\t\t\t}\n\t\t\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\t\t\tterm_actions[num_term_actions++].dest = tmp_action;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_SAMPLER:\n\t\t\t\tid = dst->dest_attr.sampler_id;\n\t\t\t\ttmp_action = mlx5dr_action_create_flow_sampler(domain,\n\t\t\t\t\t\t\t\t\t       id);\n\t\t\t\tif (!tmp_action) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto free_actions;\n\t\t\t\t}\n\t\t\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\t\t\tterm_actions[num_term_actions++].dest = tmp_action;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_RANGE:\n\t\t\t\ttmp_action = create_range_action(domain, dst);\n\t\t\t\tif (!tmp_action) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto free_actions;\n\t\t\t\t}\n\t\t\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\t\t\tterm_actions[num_term_actions++].dest = tmp_action;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto free_actions;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\tlist_for_each_entry(dst, &fte->node.children, node.list) {\n\t\t\tu32 id;\n\n\t\t\tif (dst->dest_attr.type !=\n\t\t\t    MLX5_FLOW_DESTINATION_TYPE_COUNTER)\n\t\t\t\tcontinue;\n\n\t\t\tif (num_actions == MLX5_FLOW_CONTEXT_ACTION_MAX ||\n\t\t\t    fs_dr_num_actions == MLX5_FLOW_CONTEXT_ACTION_MAX) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto free_actions;\n\t\t\t}\n\n\t\t\tid = dst->dest_attr.counter_id;\n\t\t\ttmp_action =\n\t\t\t\tmlx5dr_action_create_flow_counter(id);\n\t\t\tif (!tmp_action) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto free_actions;\n\t\t\t}\n\n\t\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\t\tactions[num_actions++] = tmp_action;\n\t\t}\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_EXECUTE_ASO) {\n\t\tif (fte->action.exe_aso.type != MLX5_EXE_ASO_FLOW_METER) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free_actions;\n\t\t}\n\n\t\ttmp_action =\n\t\t\tmlx5dr_action_create_aso(domain,\n\t\t\t\t\t\t fte->action.exe_aso.object_id,\n\t\t\t\t\t\t fte->action.exe_aso.return_reg_id,\n\t\t\t\t\t\t fte->action.exe_aso.type,\n\t\t\t\t\t\t fte->action.exe_aso.flow_meter.init_color,\n\t\t\t\t\t\t fte->action.exe_aso.flow_meter.meter_idx);\n\t\tif (!tmp_action) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\tparams.match_sz = match_sz;\n\tparams.match_buf = (u64 *)fte->val;\n\tif (num_term_actions == 1) {\n\t\tif (term_actions->reformat) {\n\t\t\tif (num_actions == MLX5_FLOW_CONTEXT_ACTION_MAX) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto free_actions;\n\t\t\t}\n\t\t\tactions[num_actions++] = term_actions->reformat;\n\t\t}\n\n\t\tif (num_actions == MLX5_FLOW_CONTEXT_ACTION_MAX) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tactions[num_actions++] = term_actions->dest;\n\t} else if (num_term_actions > 1) {\n\t\tbool ignore_flow_level =\n\t\t\t!!(fte->action.flags & FLOW_ACT_IGNORE_FLOW_LEVEL);\n\t\tu32 flow_source = fte->flow_context.flow_source;\n\n\t\tif (num_actions == MLX5_FLOW_CONTEXT_ACTION_MAX ||\n\t\t    fs_dr_num_actions == MLX5_FLOW_CONTEXT_ACTION_MAX) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free_actions;\n\t\t}\n\t\ttmp_action = mlx5dr_action_create_mult_dest_tbl(domain,\n\t\t\t\t\t\t\t\tterm_actions,\n\t\t\t\t\t\t\t\tnum_term_actions,\n\t\t\t\t\t\t\t\tignore_flow_level,\n\t\t\t\t\t\t\t\tflow_source);\n\t\tif (!tmp_action) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free_actions;\n\t\t}\n\t\tfs_dr_actions[fs_dr_num_actions++] = tmp_action;\n\t\tactions[num_actions++] = tmp_action;\n\t}\n\n\trule = mlx5dr_rule_create(group->fs_dr_matcher.dr_matcher,\n\t\t\t\t  &params,\n\t\t\t\t  num_actions,\n\t\t\t\t  actions,\n\t\t\t\t  fte->flow_context.flow_source);\n\tif (!rule) {\n\t\terr = -EINVAL;\n\t\tgoto free_actions;\n\t}\n\n\tkfree(term_actions);\n\tkfree(actions);\n\n\tfte->fs_dr_rule.dr_rule = rule;\n\tfte->fs_dr_rule.num_actions = fs_dr_num_actions;\n\tfte->fs_dr_rule.dr_actions = fs_dr_actions;\n\n\treturn 0;\n\nfree_actions:\n\t \n\tfor (i = fs_dr_num_actions - 1; i >= 0; i--)\n\t\tif (!IS_ERR_OR_NULL(fs_dr_actions[i]))\n\t\t\tmlx5dr_action_destroy(fs_dr_actions[i]);\n\n\tkfree(term_actions);\nfree_fs_dr_actions_alloc:\n\tkfree(fs_dr_actions);\nfree_actions_alloc:\n\tkfree(actions);\nout_err:\n\tmlx5_core_err(dev, \"Failed to create dr rule err(%d)\\n\", err);\n\treturn err;\n}\n\nstatic int mlx5_cmd_dr_packet_reformat_alloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t     struct mlx5_pkt_reformat_params *params,\n\t\t\t\t\t     enum mlx5_flow_namespace_type namespace,\n\t\t\t\t\t     struct mlx5_pkt_reformat *pkt_reformat)\n{\n\tstruct mlx5dr_domain *dr_domain = ns->fs_dr_domain.dr_domain;\n\tstruct mlx5dr_action *action;\n\tint dr_reformat;\n\n\tswitch (params->type) {\n\tcase MLX5_REFORMAT_TYPE_L2_TO_VXLAN:\n\tcase MLX5_REFORMAT_TYPE_L2_TO_NVGRE:\n\tcase MLX5_REFORMAT_TYPE_L2_TO_L2_TUNNEL:\n\t\tdr_reformat = DR_ACTION_REFORMAT_TYP_L2_TO_TNL_L2;\n\t\tbreak;\n\tcase MLX5_REFORMAT_TYPE_L3_TUNNEL_TO_L2:\n\t\tdr_reformat = DR_ACTION_REFORMAT_TYP_TNL_L3_TO_L2;\n\t\tbreak;\n\tcase MLX5_REFORMAT_TYPE_L2_TO_L3_TUNNEL:\n\t\tdr_reformat = DR_ACTION_REFORMAT_TYP_L2_TO_TNL_L3;\n\t\tbreak;\n\tcase MLX5_REFORMAT_TYPE_INSERT_HDR:\n\t\tdr_reformat = DR_ACTION_REFORMAT_TYP_INSERT_HDR;\n\t\tbreak;\n\tcase MLX5_REFORMAT_TYPE_REMOVE_HDR:\n\t\tdr_reformat = DR_ACTION_REFORMAT_TYP_REMOVE_HDR;\n\t\tbreak;\n\tdefault:\n\t\tmlx5_core_err(ns->dev, \"Packet-reformat not supported(%d)\\n\",\n\t\t\t      params->type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\taction = mlx5dr_action_create_packet_reformat(dr_domain,\n\t\t\t\t\t\t      dr_reformat,\n\t\t\t\t\t\t      params->param_0,\n\t\t\t\t\t\t      params->param_1,\n\t\t\t\t\t\t      params->size,\n\t\t\t\t\t\t      params->data);\n\tif (!action) {\n\t\tmlx5_core_err(ns->dev, \"Failed allocating packet-reformat action\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpkt_reformat->owner = MLX5_FLOW_RESOURCE_OWNER_SW;\n\tpkt_reformat->action.dr_action = action;\n\n\treturn 0;\n}\n\nstatic void mlx5_cmd_dr_packet_reformat_dealloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t\tstruct mlx5_pkt_reformat *pkt_reformat)\n{\n\tmlx5dr_action_destroy(pkt_reformat->action.dr_action);\n}\n\nstatic int mlx5_cmd_dr_modify_header_alloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t   u8 namespace, u8 num_actions,\n\t\t\t\t\t   void *modify_actions,\n\t\t\t\t\t   struct mlx5_modify_hdr *modify_hdr)\n{\n\tstruct mlx5dr_domain *dr_domain = ns->fs_dr_domain.dr_domain;\n\tstruct mlx5dr_action *action;\n\tsize_t actions_sz;\n\n\tactions_sz = MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto) *\n\t\tnum_actions;\n\taction = mlx5dr_action_create_modify_header(dr_domain, 0,\n\t\t\t\t\t\t    actions_sz,\n\t\t\t\t\t\t    modify_actions);\n\tif (!action) {\n\t\tmlx5_core_err(ns->dev, \"Failed allocating modify-header action\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmodify_hdr->owner = MLX5_FLOW_RESOURCE_OWNER_SW;\n\tmodify_hdr->action.dr_action = action;\n\n\treturn 0;\n}\n\nstatic void mlx5_cmd_dr_modify_header_dealloc(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t      struct mlx5_modify_hdr *modify_hdr)\n{\n\tmlx5dr_action_destroy(modify_hdr->action.dr_action);\n}\n\nstatic int\nmlx5_cmd_dr_destroy_match_definer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t  int definer_id)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mlx5_cmd_dr_create_match_definer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\t    u16 format_id, u32 *match_mask)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mlx5_cmd_dr_delete_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t  struct mlx5_flow_table *ft,\n\t\t\t\t  struct fs_fte *fte)\n{\n\tstruct mlx5_fs_dr_rule *rule = &fte->fs_dr_rule;\n\tint err;\n\tint i;\n\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->delete_fte(ns, ft, fte);\n\n\terr = mlx5dr_rule_destroy(rule->dr_rule);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = rule->num_actions - 1; i >= 0; i--)\n\t\tif (!IS_ERR_OR_NULL(rule->dr_actions[i]))\n\t\t\tmlx5dr_action_destroy(rule->dr_actions[i]);\n\n\tkfree(rule->dr_actions);\n\treturn 0;\n}\n\nstatic int mlx5_cmd_dr_update_fte(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t  struct mlx5_flow_table *ft,\n\t\t\t\t  struct mlx5_flow_group *group,\n\t\t\t\t  int modify_mask,\n\t\t\t\t  struct fs_fte *fte)\n{\n\tstruct fs_fte fte_tmp = {};\n\tint ret;\n\n\tif (dr_is_fw_term_table(ft))\n\t\treturn mlx5_fs_cmd_get_fw_cmds()->update_fte(ns, ft, group, modify_mask, fte);\n\n\t \n\tfte_tmp.fs_dr_rule = fte->fs_dr_rule;\n\tmemset(&fte->fs_dr_rule, 0, sizeof(struct mlx5_fs_dr_rule));\n\n\t \n\tret = mlx5_cmd_dr_create_fte(ns, ft, group, fte);\n\tif (ret)\n\t\tgoto restore_fte;\n\n\tret = mlx5_cmd_dr_delete_fte(ns, ft, &fte_tmp);\n\tWARN_ONCE(ret, \"dr update fte duplicate rule deletion failed\\n\");\n\treturn ret;\n\nrestore_fte:\n\tfte->fs_dr_rule = fte_tmp.fs_dr_rule;\n\treturn ret;\n}\n\nstatic int mlx5_cmd_dr_set_peer(struct mlx5_flow_root_namespace *ns,\n\t\t\t\tstruct mlx5_flow_root_namespace *peer_ns,\n\t\t\t\tu16 peer_vhca_id)\n{\n\tstruct mlx5dr_domain *peer_domain = NULL;\n\n\tif (peer_ns)\n\t\tpeer_domain = peer_ns->fs_dr_domain.dr_domain;\n\tmlx5dr_domain_set_peer(ns->fs_dr_domain.dr_domain,\n\t\t\t       peer_domain, peer_vhca_id);\n\treturn 0;\n}\n\nstatic int mlx5_cmd_dr_create_ns(struct mlx5_flow_root_namespace *ns)\n{\n\tns->fs_dr_domain.dr_domain =\n\t\tmlx5dr_domain_create(ns->dev,\n\t\t\t\t     MLX5DR_DOMAIN_TYPE_FDB);\n\tif (!ns->fs_dr_domain.dr_domain) {\n\t\tmlx5_core_err(ns->dev, \"Failed to create dr flow namespace\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int mlx5_cmd_dr_destroy_ns(struct mlx5_flow_root_namespace *ns)\n{\n\treturn mlx5dr_domain_destroy(ns->fs_dr_domain.dr_domain);\n}\n\nstatic u32 mlx5_cmd_dr_get_capabilities(struct mlx5_flow_root_namespace *ns,\n\t\t\t\t\tenum fs_flow_table_type ft_type)\n{\n\tu32 steering_caps = 0;\n\n\tif (ft_type != FS_FT_FDB ||\n\t    MLX5_CAP_GEN(ns->dev, steering_format_version) == MLX5_STEERING_FORMAT_CONNECTX_5)\n\t\treturn 0;\n\n\tsteering_caps |= MLX5_FLOW_STEERING_CAP_VLAN_PUSH_ON_RX;\n\tsteering_caps |= MLX5_FLOW_STEERING_CAP_VLAN_POP_ON_TX;\n\n\tif (mlx5dr_supp_match_ranges(ns->dev))\n\t\tsteering_caps |= MLX5_FLOW_STEERING_CAP_MATCH_RANGES;\n\n\treturn steering_caps;\n}\n\nint mlx5_fs_dr_action_get_pkt_reformat_id(struct mlx5_pkt_reformat *pkt_reformat)\n{\n\tswitch (pkt_reformat->reformat_type) {\n\tcase MLX5_REFORMAT_TYPE_L2_TO_VXLAN:\n\tcase MLX5_REFORMAT_TYPE_L2_TO_NVGRE:\n\tcase MLX5_REFORMAT_TYPE_L2_TO_L2_TUNNEL:\n\tcase MLX5_REFORMAT_TYPE_L2_TO_L3_TUNNEL:\n\tcase MLX5_REFORMAT_TYPE_INSERT_HDR:\n\t\treturn mlx5dr_action_get_pkt_reformat_id(pkt_reformat->action.dr_action);\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nbool mlx5_fs_dr_is_supported(struct mlx5_core_dev *dev)\n{\n\treturn mlx5dr_is_supported(dev);\n}\n\nstatic const struct mlx5_flow_cmds mlx5_flow_cmds_dr = {\n\t.create_flow_table = mlx5_cmd_dr_create_flow_table,\n\t.destroy_flow_table = mlx5_cmd_dr_destroy_flow_table,\n\t.modify_flow_table = mlx5_cmd_dr_modify_flow_table,\n\t.create_flow_group = mlx5_cmd_dr_create_flow_group,\n\t.destroy_flow_group = mlx5_cmd_dr_destroy_flow_group,\n\t.create_fte = mlx5_cmd_dr_create_fte,\n\t.update_fte = mlx5_cmd_dr_update_fte,\n\t.delete_fte = mlx5_cmd_dr_delete_fte,\n\t.update_root_ft = mlx5_cmd_dr_update_root_ft,\n\t.packet_reformat_alloc = mlx5_cmd_dr_packet_reformat_alloc,\n\t.packet_reformat_dealloc = mlx5_cmd_dr_packet_reformat_dealloc,\n\t.modify_header_alloc = mlx5_cmd_dr_modify_header_alloc,\n\t.modify_header_dealloc = mlx5_cmd_dr_modify_header_dealloc,\n\t.create_match_definer = mlx5_cmd_dr_create_match_definer,\n\t.destroy_match_definer = mlx5_cmd_dr_destroy_match_definer,\n\t.set_peer = mlx5_cmd_dr_set_peer,\n\t.create_ns = mlx5_cmd_dr_create_ns,\n\t.destroy_ns = mlx5_cmd_dr_destroy_ns,\n\t.get_capabilities = mlx5_cmd_dr_get_capabilities,\n};\n\nconst struct mlx5_flow_cmds *mlx5_fs_cmd_get_dr_cmds(void)\n{\n\t\treturn &mlx5_flow_cmds_dr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}