{
  "module_name": "lag.h",
  "hash_id": "46fc3a3c86867c1f9b5e2f8fa4067fcf8ee6932a94e4fdde019bbc98e4b7fcc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lag/lag.h",
  "human_readable_source": " \n \n\n#ifndef __MLX5_LAG_H__\n#define __MLX5_LAG_H__\n\n#include <linux/debugfs.h>\n\n#define MLX5_LAG_MAX_HASH_BUCKETS 16\n#include \"mlx5_core.h\"\n#include \"mp.h\"\n#include \"port_sel.h\"\n#include \"mpesw.h\"\n\nenum {\n\tMLX5_LAG_P1,\n\tMLX5_LAG_P2,\n};\n\nenum {\n\tMLX5_LAG_FLAG_NDEVS_READY,\n};\n\nenum {\n\tMLX5_LAG_MODE_FLAG_HASH_BASED,\n\tMLX5_LAG_MODE_FLAG_SHARED_FDB,\n\tMLX5_LAG_MODE_FLAG_FDB_SEL_MODE_NATIVE,\n};\n\nenum mlx5_lag_mode {\n\tMLX5_LAG_MODE_NONE,\n\tMLX5_LAG_MODE_ROCE,\n\tMLX5_LAG_MODE_SRIOV,\n\tMLX5_LAG_MODE_MULTIPATH,\n\tMLX5_LAG_MODE_MPESW,\n};\n\nstruct lag_func {\n\tstruct mlx5_core_dev *dev;\n\tstruct net_device    *netdev;\n\tbool has_drop;\n};\n\n \nstruct lag_tracker {\n\tenum   netdev_lag_tx_type           tx_type;\n\tstruct netdev_lag_lower_state_info  netdev_state[MLX5_MAX_PORTS];\n\tunsigned int is_bonded:1;\n\tunsigned int has_inactive:1;\n\tenum netdev_lag_hash hash_type;\n};\n\n \nstruct mlx5_lag {\n\tenum mlx5_lag_mode        mode;\n\tunsigned long\t\t  mode_flags;\n\tunsigned long\t\t  state_flags;\n\tu8\t\t\t  ports;\n\tu8\t\t\t  buckets;\n\tint\t\t\t  mode_changes_in_progress;\n\tu8\t\t\t  v2p_map[MLX5_MAX_PORTS * MLX5_LAG_MAX_HASH_BUCKETS];\n\tstruct kref               ref;\n\tstruct lag_func           pf[MLX5_MAX_PORTS];\n\tstruct lag_tracker        tracker;\n\tstruct workqueue_struct   *wq;\n\tstruct delayed_work       bond_work;\n\tstruct notifier_block     nb;\n\tstruct lag_mp             lag_mp;\n\tstruct mlx5_lag_port_sel  port_sel;\n\t \n\tstruct mutex\t\t  lock;\n\tstruct lag_mpesw\t  lag_mpesw;\n};\n\nstatic inline struct mlx5_lag *\nmlx5_lag_dev(struct mlx5_core_dev *dev)\n{\n\treturn dev->priv.lag;\n}\n\nstatic inline bool\n__mlx5_lag_is_active(struct mlx5_lag *ldev)\n{\n\treturn ldev->mode != MLX5_LAG_MODE_NONE;\n}\n\nstatic inline bool\nmlx5_lag_is_ready(struct mlx5_lag *ldev)\n{\n\treturn test_bit(MLX5_LAG_FLAG_NDEVS_READY, &ldev->state_flags);\n}\n\nbool mlx5_lag_check_prereq(struct mlx5_lag *ldev);\nvoid mlx5_modify_lag(struct mlx5_lag *ldev,\n\t\t     struct lag_tracker *tracker);\nint mlx5_activate_lag(struct mlx5_lag *ldev,\n\t\t      struct lag_tracker *tracker,\n\t\t      enum mlx5_lag_mode mode,\n\t\t      bool shared_fdb);\nint mlx5_lag_dev_get_netdev_idx(struct mlx5_lag *ldev,\n\t\t\t\tstruct net_device *ndev);\n\nchar *mlx5_get_str_port_sel_mode(enum mlx5_lag_mode mode, unsigned long flags);\nvoid mlx5_infer_tx_enabled(struct lag_tracker *tracker, u8 num_ports,\n\t\t\t   u8 *ports, int *num_enabled);\n\nvoid mlx5_ldev_add_debugfs(struct mlx5_core_dev *dev);\nvoid mlx5_ldev_remove_debugfs(struct dentry *dbg);\nvoid mlx5_disable_lag(struct mlx5_lag *ldev);\nvoid mlx5_lag_remove_devices(struct mlx5_lag *ldev);\nint mlx5_deactivate_lag(struct mlx5_lag *ldev);\nvoid mlx5_lag_add_devices(struct mlx5_lag *ldev);\n\nstatic inline bool mlx5_lag_is_supported(struct mlx5_core_dev *dev)\n{\n\tif (!MLX5_CAP_GEN(dev, vport_group_manager) ||\n\t    !MLX5_CAP_GEN(dev, lag_master) ||\n\t    MLX5_CAP_GEN(dev, num_lag_ports) < 2 ||\n\t    MLX5_CAP_GEN(dev, num_lag_ports) > MLX5_MAX_PORTS)\n\t\treturn false;\n\treturn true;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}