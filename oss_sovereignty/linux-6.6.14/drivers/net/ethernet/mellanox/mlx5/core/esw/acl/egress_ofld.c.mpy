{
  "module_name": "egress_ofld.c",
  "hash_id": "692e943d03eb1cfef160f8f777497cab7e3c42b37db8384818f97841384e5264",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/acl/egress_ofld.c",
  "human_readable_source": "\n \n\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"helper.h\"\n#include \"ofld.h\"\n\nstatic void esw_acl_egress_ofld_fwd2vport_destroy(struct mlx5_vport *vport)\n{\n\tif (!vport->egress.offloads.fwd_rule)\n\t\treturn;\n\n\tmlx5_del_flow_rules(vport->egress.offloads.fwd_rule);\n\tvport->egress.offloads.fwd_rule = NULL;\n}\n\nvoid esw_acl_egress_ofld_bounce_rule_destroy(struct mlx5_vport *vport, int rule_index)\n{\n\tstruct mlx5_flow_handle *bounce_rule =\n\t\txa_load(&vport->egress.offloads.bounce_rules, rule_index);\n\n\tif (!bounce_rule)\n\t\treturn;\n\n\tmlx5_del_flow_rules(bounce_rule);\n\txa_erase(&vport->egress.offloads.bounce_rules, rule_index);\n}\n\nstatic void esw_acl_egress_ofld_bounce_rules_destroy(struct mlx5_vport *vport)\n{\n\tstruct mlx5_flow_handle *bounce_rule;\n\tunsigned long i;\n\n\txa_for_each(&vport->egress.offloads.bounce_rules, i, bounce_rule) {\n\t\tmlx5_del_flow_rules(bounce_rule);\n\t\txa_erase(&vport->egress.offloads.bounce_rules, i);\n\t}\n}\n\nstatic int esw_acl_egress_ofld_fwd2vport_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t\tstruct mlx5_vport *vport,\n\t\t\t\t\t\tstruct mlx5_flow_destination *fwd_dest)\n{\n\tstruct mlx5_flow_act flow_act = {};\n\tint err = 0;\n\n\tesw_debug(esw->dev, \"vport(%d) configure egress acl rule fwd2vport(%d)\\n\",\n\t\t  vport->vport, fwd_dest->vport.num);\n\n\t \n\tesw_acl_egress_ofld_fwd2vport_destroy(vport);\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\n\tvport->egress.offloads.fwd_rule =\n\t\tmlx5_add_flow_rules(vport->egress.acl, NULL,\n\t\t\t\t    &flow_act, fwd_dest, 1);\n\tif (IS_ERR(vport->egress.offloads.fwd_rule)) {\n\t\terr = PTR_ERR(vport->egress.offloads.fwd_rule);\n\t\tesw_warn(esw->dev,\n\t\t\t \"vport(%d) failed to add fwd2vport acl rule err(%d)\\n\",\n\t\t\t vport->vport, err);\n\t\tvport->egress.offloads.fwd_rule = NULL;\n\t}\n\n\treturn err;\n}\n\nstatic int esw_acl_egress_ofld_rules_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t    struct mlx5_vport *vport,\n\t\t\t\t\t    struct mlx5_flow_destination *fwd_dest)\n{\n\tint err = 0;\n\tint action;\n\n\tif (MLX5_CAP_GEN(esw->dev, prio_tag_required)) {\n\t\t \n\t\tesw_debug(esw->dev,\n\t\t\t  \"vport[%d] configure prio tag egress rules\\n\", vport->vport);\n\n\t\taction = MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;\n\t\taction |= fwd_dest ? MLX5_FLOW_CONTEXT_ACTION_FWD_DEST :\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\n\t\t \n\t\terr = esw_egress_acl_vlan_create(esw, vport, fwd_dest, 0, action);\n\t\tif (err)\n\t\t\tgoto prio_err;\n\t}\n\n\tif (fwd_dest) {\n\t\terr = esw_acl_egress_ofld_fwd2vport_create(esw, vport, fwd_dest);\n\t\tif (err)\n\t\t\tgoto fwd_err;\n\t}\n\n\treturn 0;\n\nfwd_err:\n\tesw_acl_egress_vlan_destroy(vport);\nprio_err:\n\treturn err;\n}\n\nstatic void esw_acl_egress_ofld_rules_destroy(struct mlx5_vport *vport)\n{\n\tesw_acl_egress_vlan_destroy(vport);\n\tesw_acl_egress_ofld_fwd2vport_destroy(vport);\n\tesw_acl_egress_ofld_bounce_rules_destroy(vport);\n}\n\nstatic int esw_acl_egress_ofld_groups_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t     struct mlx5_vport *vport)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fwd_grp;\n\tu32 *flow_group_in;\n\tu32 flow_index = 0;\n\tint ret = 0;\n\n\tif (MLX5_CAP_GEN(esw->dev, prio_tag_required)) {\n\t\tret = esw_acl_egress_vlan_grp_create(esw, vport);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tflow_index++;\n\t}\n\n\tif (!mlx5_esw_acl_egress_fwd2vport_supported(esw))\n\t\tgoto out;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in) {\n\t\tret = -ENOMEM;\n\t\tgoto fwd_grp_err;\n\t}\n\n\t \n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, flow_index);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, flow_index);\n\tfwd_grp = mlx5_create_flow_group(vport->egress.acl, flow_group_in);\n\tif (IS_ERR(fwd_grp)) {\n\t\tret = PTR_ERR(fwd_grp);\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create vport[%d] egress fwd2vport flow group, err(%d)\\n\",\n\t\t\t vport->vport, ret);\n\t\tkvfree(flow_group_in);\n\t\tgoto fwd_grp_err;\n\t}\n\tvport->egress.offloads.fwd_grp = fwd_grp;\n\tkvfree(flow_group_in);\n\treturn 0;\n\nfwd_grp_err:\n\tesw_acl_egress_vlan_grp_destroy(vport);\nout:\n\treturn ret;\n}\n\nstatic void esw_acl_egress_ofld_groups_destroy(struct mlx5_vport *vport)\n{\n\tif (!IS_ERR_OR_NULL(vport->egress.offloads.fwd_grp)) {\n\t\tmlx5_destroy_flow_group(vport->egress.offloads.fwd_grp);\n\t\tvport->egress.offloads.fwd_grp = NULL;\n\t}\n\n\tif (!IS_ERR_OR_NULL(vport->egress.offloads.bounce_grp)) {\n\t\tmlx5_destroy_flow_group(vport->egress.offloads.bounce_grp);\n\t\tvport->egress.offloads.bounce_grp = NULL;\n\t}\n\n\tesw_acl_egress_vlan_grp_destroy(vport);\n}\n\nstatic bool esw_acl_egress_needed(struct mlx5_eswitch *esw, u16 vport_num)\n{\n\treturn mlx5_eswitch_is_vf_vport(esw, vport_num) || mlx5_esw_is_sf_vport(esw, vport_num);\n}\n\nint esw_acl_egress_ofld_setup(struct mlx5_eswitch *esw, struct mlx5_vport *vport)\n{\n\tint table_size = 0;\n\tint err;\n\n\tif (!mlx5_esw_acl_egress_fwd2vport_supported(esw) &&\n\t    !MLX5_CAP_GEN(esw->dev, prio_tag_required))\n\t\treturn 0;\n\n\tif (!esw_acl_egress_needed(esw, vport->vport))\n\t\treturn 0;\n\n\tesw_acl_egress_ofld_rules_destroy(vport);\n\n\tif (mlx5_esw_acl_egress_fwd2vport_supported(esw))\n\t\ttable_size++;\n\tif (MLX5_CAP_GEN(esw->dev, prio_tag_required))\n\t\ttable_size++;\n\tvport->egress.acl = esw_acl_table_create(esw, vport,\n\t\t\t\t\t\t MLX5_FLOW_NAMESPACE_ESW_EGRESS, table_size);\n\tif (IS_ERR(vport->egress.acl)) {\n\t\terr = PTR_ERR(vport->egress.acl);\n\t\tvport->egress.acl = NULL;\n\t\treturn err;\n\t}\n\tvport->egress.type = VPORT_EGRESS_ACL_TYPE_DEFAULT;\n\n\terr = esw_acl_egress_ofld_groups_create(esw, vport);\n\tif (err)\n\t\tgoto group_err;\n\n\tesw_debug(esw->dev, \"vport[%d] configure egress rules\\n\", vport->vport);\n\n\terr = esw_acl_egress_ofld_rules_create(esw, vport, NULL);\n\tif (err)\n\t\tgoto rules_err;\n\n\treturn 0;\n\nrules_err:\n\tesw_acl_egress_ofld_groups_destroy(vport);\ngroup_err:\n\tesw_acl_egress_table_destroy(vport);\n\treturn err;\n}\n\nvoid esw_acl_egress_ofld_cleanup(struct mlx5_vport *vport)\n{\n\tesw_acl_egress_ofld_rules_destroy(vport);\n\tesw_acl_egress_ofld_groups_destroy(vport);\n\tesw_acl_egress_table_destroy(vport);\n}\n\nint mlx5_esw_acl_egress_vport_bond(struct mlx5_eswitch *esw, u16 active_vport_num,\n\t\t\t\t   u16 passive_vport_num)\n{\n\tstruct mlx5_vport *passive_vport = mlx5_eswitch_get_vport(esw, passive_vport_num);\n\tstruct mlx5_vport *active_vport = mlx5_eswitch_get_vport(esw, active_vport_num);\n\tstruct mlx5_flow_destination fwd_dest = {};\n\n\tif (IS_ERR(active_vport))\n\t\treturn PTR_ERR(active_vport);\n\tif (IS_ERR(passive_vport))\n\t\treturn PTR_ERR(passive_vport);\n\n\t \n\tesw_acl_egress_ofld_rules_destroy(active_vport);\n\tesw_acl_egress_ofld_rules_create(esw, active_vport, NULL);\n\n\t \n\tesw_acl_egress_ofld_rules_destroy(passive_vport);\n\tfwd_dest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\n\tfwd_dest.vport.num = active_vport_num;\n\tfwd_dest.vport.vhca_id = MLX5_CAP_GEN(esw->dev, vhca_id);\n\tfwd_dest.vport.flags = MLX5_FLOW_DEST_VPORT_VHCA_ID;\n\n\treturn esw_acl_egress_ofld_rules_create(esw, passive_vport, &fwd_dest);\n}\n\nint mlx5_esw_acl_egress_vport_unbond(struct mlx5_eswitch *esw, u16 vport_num)\n{\n\tstruct mlx5_vport *vport = mlx5_eswitch_get_vport(esw, vport_num);\n\n\tif (IS_ERR(vport))\n\t\treturn PTR_ERR(vport);\n\n\tesw_acl_egress_ofld_rules_destroy(vport);\n\treturn esw_acl_egress_ofld_rules_create(esw, vport, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}