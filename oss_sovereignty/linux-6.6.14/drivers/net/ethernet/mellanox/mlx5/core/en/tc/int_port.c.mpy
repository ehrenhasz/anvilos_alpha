{
  "module_name": "int_port.c",
  "hash_id": "09f365adfb824c323a8c18b6a985d23a16a95dcf5fb957a068735d5cc600eec8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/int_port.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/fs.h>\n#include \"en/mapping.h\"\n#include \"en/tc/int_port.h\"\n#include \"en.h\"\n#include \"en_rep.h\"\n#include \"en_tc.h\"\n\nstruct mlx5e_tc_int_port {\n\tenum mlx5e_tc_int_port_type type;\n\tint ifindex;\n\tu32 match_metadata;\n\tu32 mapping;\n\tstruct list_head list;\n\tstruct mlx5_flow_handle *rx_rule;\n\trefcount_t refcnt;\n\tstruct rcu_head rcu_head;\n};\n\nstruct mlx5e_tc_int_port_priv {\n\tstruct mlx5_core_dev *dev;\n\tstruct mutex int_ports_lock;  \n\tstruct list_head int_ports;  \n\tu16 num_ports;\n\tbool ul_rep_rx_ready;  \n\tstruct mapping_ctx *metadata_mapping;  \n};\n\nbool mlx5e_tc_int_port_supported(const struct mlx5_eswitch *esw)\n{\n\treturn mlx5_eswitch_vport_match_metadata_enabled(esw) &&\n\t       MLX5_CAP_GEN(esw->dev, reg_c_preserve);\n}\n\nu32 mlx5e_tc_int_port_get_metadata(struct mlx5e_tc_int_port *int_port)\n{\n\treturn int_port->match_metadata;\n}\n\nint mlx5e_tc_int_port_get_flow_source(struct mlx5e_tc_int_port *int_port)\n{\n\t \n\treturn int_port->type == MLX5E_TC_INT_PORT_EGRESS ?\n\t\tMLX5_FLOW_CONTEXT_FLOW_SOURCE_ANY_VPORT :\n\t\tMLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK;\n}\n\nu32 mlx5e_tc_int_port_get_metadata_for_match(struct mlx5e_tc_int_port *int_port)\n{\n\treturn int_port->match_metadata << (32 - ESW_SOURCE_PORT_METADATA_BITS);\n}\n\nstatic struct mlx5_flow_handle *\nmlx5e_int_port_create_rx_rule(struct mlx5_eswitch *esw,\n\t\t\t      struct mlx5e_tc_int_port *int_port,\n\t\t\t      struct mlx5_flow_destination *dest)\n\n{\n\tstruct mlx5_flow_context *flow_context;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *flow_rule;\n\tstruct mlx5_flow_spec *spec;\n\tvoid *misc;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters_2);\n\tMLX5_SET(fte_match_set_misc2, misc, metadata_reg_c_0,\n\t\t mlx5e_tc_int_port_get_metadata_for_match(int_port));\n\n\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters_2);\n\tMLX5_SET(fte_match_set_misc2, misc, metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_mask());\n\n\tspec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;\n\n\t \n\tflow_context = &spec->flow_context;\n\tflow_context->flags |= FLOW_CONTEXT_HAS_TAG;\n\tflow_context->flow_tag = int_port->mapping;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tflow_rule = mlx5_add_flow_rules(esw->offloads.ft_offloads, spec,\n\t\t\t\t\t&flow_act, dest, 1);\n\tif (IS_ERR(flow_rule))\n\t\tmlx5_core_warn(esw->dev, \"ft offloads: Failed to add internal vport rx rule err %ld\\n\",\n\t\t\t       PTR_ERR(flow_rule));\n\n\tkvfree(spec);\n\n\treturn flow_rule;\n}\n\nstatic struct mlx5e_tc_int_port *\nmlx5e_int_port_lookup(struct mlx5e_tc_int_port_priv *priv,\n\t\t      int ifindex,\n\t\t      enum mlx5e_tc_int_port_type type)\n{\n\tstruct mlx5e_tc_int_port *int_port;\n\n\tif (!priv->ul_rep_rx_ready)\n\t\tgoto not_found;\n\n\tlist_for_each_entry(int_port, &priv->int_ports, list)\n\t\tif (int_port->ifindex == ifindex && int_port->type == type) {\n\t\t\trefcount_inc(&int_port->refcnt);\n\t\t\treturn int_port;\n\t\t}\n\nnot_found:\n\treturn NULL;\n}\n\nstatic int mlx5e_int_port_metadata_alloc(struct mlx5e_tc_int_port_priv *priv,\n\t\t\t\t\t int ifindex, enum mlx5e_tc_int_port_type type,\n\t\t\t\t\t u32 *id)\n{\n\tu32 mapped_key[2] = {type, ifindex};\n\tint err;\n\n\terr = mapping_add(priv->metadata_mapping, mapped_key, id);\n\tif (err)\n\t\treturn err;\n\n\t \n\t*id |= 0xf << ESW_VPORT_BITS;\n\n\treturn 0;\n}\n\nstatic void mlx5e_int_port_metadata_free(struct mlx5e_tc_int_port_priv *priv,\n\t\t\t\t\t u32 id)\n{\n\tid &= (1 << ESW_VPORT_BITS) - 1;\n\tmapping_remove(priv->metadata_mapping, id);\n}\n\n \nstatic struct mlx5e_tc_int_port *\nmlx5e_int_port_add(struct mlx5e_tc_int_port_priv *priv,\n\t\t   int ifindex,\n\t\t   enum mlx5e_tc_int_port_type type)\n{\n\tstruct mlx5_eswitch *esw = priv->dev->priv.eswitch;\n\tstruct mlx5_mapped_obj mapped_obj = {};\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct mlx5e_tc_int_port *int_port;\n\tstruct mlx5_flow_destination dest;\n\tstruct mapping_ctx *ctx;\n\tu32 match_metadata;\n\tu32 mapping;\n\tint err;\n\n\tif (priv->num_ports == MLX5E_TC_MAX_INT_PORT_NUM) {\n\t\tmlx5_core_dbg(priv->dev, \"Cannot add a new int port, max supported %d\",\n\t\t\t      MLX5E_TC_MAX_INT_PORT_NUM);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tint_port = kzalloc(sizeof(*int_port), GFP_KERNEL);\n\tif (!int_port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlx5e_int_port_metadata_alloc(priv, ifindex, type, &match_metadata);\n\tif (err) {\n\t\tmlx5_core_warn(esw->dev, \"Cannot add a new internal port, metadata allocation failed for ifindex %d\",\n\t\t\t       ifindex);\n\t\tgoto err_metadata;\n\t}\n\n\t \n\tctx = esw->offloads.reg_c0_obj_pool;\n\tmapped_obj.type = MLX5_MAPPED_OBJ_INT_PORT_METADATA;\n\tmapped_obj.int_port_metadata = match_metadata;\n\terr = mapping_add(ctx, &mapped_obj, &mapping);\n\tif (err)\n\t\tgoto err_map;\n\n\tint_port->type = type;\n\tint_port->ifindex = ifindex;\n\tint_port->match_metadata = match_metadata;\n\tint_port->mapping = mapping;\n\n\t \n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = uplink_rpriv->root_ft;\n\n\tint_port->rx_rule = mlx5e_int_port_create_rx_rule(esw, int_port, &dest);\n\tif (IS_ERR(int_port->rx_rule)) {\n\t\terr = PTR_ERR(int_port->rx_rule);\n\t\tmlx5_core_warn(esw->dev, \"Can't add internal port rx rule, err %d\", err);\n\t\tgoto err_rx_rule;\n\t}\n\n\trefcount_set(&int_port->refcnt, 1);\n\tlist_add_rcu(&int_port->list, &priv->int_ports);\n\tpriv->num_ports++;\n\n\treturn int_port;\n\nerr_rx_rule:\n\tmapping_remove(ctx, int_port->mapping);\n\nerr_map:\n\tmlx5e_int_port_metadata_free(priv, match_metadata);\n\nerr_metadata:\n\tkfree(int_port);\n\n\treturn ERR_PTR(err);\n}\n\n \nstatic void\nmlx5e_int_port_remove(struct mlx5e_tc_int_port_priv *priv,\n\t\t      struct mlx5e_tc_int_port *int_port)\n{\n\tstruct mlx5_eswitch *esw = priv->dev->priv.eswitch;\n\tstruct mapping_ctx *ctx;\n\n\tctx = esw->offloads.reg_c0_obj_pool;\n\n\tlist_del_rcu(&int_port->list);\n\n\t \n\tif (int_port->rx_rule)\n\t\tmlx5_del_flow_rules(int_port->rx_rule);\n\tmapping_remove(ctx, int_port->mapping);\n\tmlx5e_int_port_metadata_free(priv, int_port->match_metadata);\n\tkfree_rcu_mightsleep(int_port);\n\tpriv->num_ports--;\n}\n\n \nstatic struct mlx5e_tc_int_port *\nmlx5e_int_port_get_from_metadata(struct mlx5e_tc_int_port_priv *priv,\n\t\t\t\t u32 metadata)\n{\n\tstruct mlx5e_tc_int_port *int_port;\n\n\tlist_for_each_entry_rcu(int_port, &priv->int_ports, list)\n\t\tif (int_port->match_metadata == metadata)\n\t\t\treturn int_port;\n\n\treturn NULL;\n}\n\nstruct mlx5e_tc_int_port *\nmlx5e_tc_int_port_get(struct mlx5e_tc_int_port_priv *priv,\n\t\t      int ifindex,\n\t\t      enum mlx5e_tc_int_port_type type)\n{\n\tstruct mlx5e_tc_int_port *int_port;\n\n\tif (!priv)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tmutex_lock(&priv->int_ports_lock);\n\n\t \n\tif (!priv->ul_rep_rx_ready) {\n\t\tint_port = ERR_PTR(-EOPNOTSUPP);\n\t\tgoto done;\n\t}\n\n\tint_port = mlx5e_int_port_lookup(priv, ifindex, type);\n\tif (int_port)\n\t\tgoto done;\n\n\t \n\tint_port = mlx5e_int_port_add(priv, ifindex, type);\n\ndone:\n\tmutex_unlock(&priv->int_ports_lock);\n\n\treturn int_port;\n}\n\nvoid\nmlx5e_tc_int_port_put(struct mlx5e_tc_int_port_priv *priv,\n\t\t      struct mlx5e_tc_int_port *int_port)\n{\n\tif (!refcount_dec_and_mutex_lock(&int_port->refcnt, &priv->int_ports_lock))\n\t\treturn;\n\n\tmlx5e_int_port_remove(priv, int_port);\n\tmutex_unlock(&priv->int_ports_lock);\n}\n\nstruct mlx5e_tc_int_port_priv *\nmlx5e_tc_int_port_init(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5e_tc_int_port_priv *int_port_priv;\n\tu64 mapping_id;\n\n\tif (!mlx5e_tc_int_port_supported(esw))\n\t\treturn NULL;\n\n\tint_port_priv = kzalloc(sizeof(*int_port_priv), GFP_KERNEL);\n\tif (!int_port_priv)\n\t\treturn NULL;\n\n\tmapping_id = mlx5_query_nic_system_image_guid(priv->mdev);\n\n\tint_port_priv->metadata_mapping = mapping_create_for_id(mapping_id, MAPPING_TYPE_INT_PORT,\n\t\t\t\t\t\t\t\tsizeof(u32) * 2,\n\t\t\t\t\t\t\t\t(1 << ESW_VPORT_BITS) - 1, true);\n\tif (IS_ERR(int_port_priv->metadata_mapping)) {\n\t\tmlx5_core_warn(priv->mdev, \"Can't allocate metadata mapping of int port offload, err=%ld\\n\",\n\t\t\t       PTR_ERR(int_port_priv->metadata_mapping));\n\t\tgoto err_mapping;\n\t}\n\n\tint_port_priv->dev = priv->mdev;\n\tmutex_init(&int_port_priv->int_ports_lock);\n\tINIT_LIST_HEAD(&int_port_priv->int_ports);\n\n\treturn int_port_priv;\n\nerr_mapping:\n\tkfree(int_port_priv);\n\n\treturn NULL;\n}\n\nvoid\nmlx5e_tc_int_port_cleanup(struct mlx5e_tc_int_port_priv *priv)\n{\n\tif (!priv)\n\t\treturn;\n\n\tmutex_destroy(&priv->int_ports_lock);\n\tmapping_destroy(priv->metadata_mapping);\n\tkfree(priv);\n}\n\n \nvoid mlx5e_tc_int_port_init_rep_rx(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_tc_int_port_priv *ppriv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\tppriv = uplink_priv->int_port_priv;\n\n\tif (!ppriv)\n\t\treturn;\n\n\tmutex_lock(&ppriv->int_ports_lock);\n\tppriv->ul_rep_rx_ready = true;\n\tmutex_unlock(&ppriv->int_ports_lock);\n}\n\nvoid mlx5e_tc_int_port_cleanup_rep_rx(struct mlx5e_priv *priv)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_rep_uplink_priv *uplink_priv;\n\tstruct mlx5e_tc_int_port_priv *ppriv;\n\tstruct mlx5e_rep_priv *uplink_rpriv;\n\tstruct mlx5e_tc_int_port *int_port;\n\n\tuplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);\n\tuplink_priv = &uplink_rpriv->uplink_priv;\n\n\tppriv = uplink_priv->int_port_priv;\n\n\tif (!ppriv)\n\t\treturn;\n\n\tmutex_lock(&ppriv->int_ports_lock);\n\n\tppriv->ul_rep_rx_ready = false;\n\n\tlist_for_each_entry(int_port, &ppriv->int_ports, list) {\n\t\tif (!IS_ERR_OR_NULL(int_port->rx_rule))\n\t\t\tmlx5_del_flow_rules(int_port->rx_rule);\n\n\t\tint_port->rx_rule = NULL;\n\t}\n\n\tmutex_unlock(&ppriv->int_ports_lock);\n}\n\nbool\nmlx5e_tc_int_port_dev_fwd(struct mlx5e_tc_int_port_priv *priv,\n\t\t\t  struct sk_buff *skb, u32 int_vport_metadata,\n\t\t\t  bool *forward_tx)\n{\n\tenum mlx5e_tc_int_port_type fwd_type;\n\tstruct mlx5e_tc_int_port *int_port;\n\tstruct net_device *dev;\n\tint ifindex;\n\n\tif (!priv)\n\t\treturn false;\n\n\trcu_read_lock();\n\tint_port = mlx5e_int_port_get_from_metadata(priv, int_vport_metadata);\n\tif (!int_port) {\n\t\trcu_read_unlock();\n\t\tmlx5_core_dbg(priv->dev, \"Unable to find int port with metadata 0x%.8x\\n\",\n\t\t\t      int_vport_metadata);\n\t\treturn false;\n\t}\n\n\tifindex = int_port->ifindex;\n\tfwd_type = int_port->type;\n\trcu_read_unlock();\n\n\tdev = dev_get_by_index(&init_net, ifindex);\n\tif (!dev) {\n\t\tmlx5_core_dbg(priv->dev,\n\t\t\t      \"Couldn't find internal port device with ifindex: %d\\n\",\n\t\t\t      ifindex);\n\t\treturn false;\n\t}\n\n\tskb->skb_iif = dev->ifindex;\n\tskb->dev = dev;\n\n\tif (fwd_type == MLX5E_TC_INT_PORT_INGRESS) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tskb_set_redirected(skb, true);\n\t\t*forward_tx = false;\n\t} else {\n\t\tskb_reset_network_header(skb);\n\t\tskb_push_rcsum(skb, skb->mac_len);\n\t\tskb_set_redirected(skb, false);\n\t\t*forward_tx = true;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}