{
  "module_name": "bridge.c",
  "hash_id": "b7dbdecfb03f959f5b4eb6038e4635cc4f77b141eb073dbac83746e15e0d9635",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c",
  "human_readable_source": "\n \n\n#include <linux/build_bug.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <net/netevent.h>\n#include <net/switchdev.h>\n#include \"lib/devcom.h\"\n#include \"bridge.h\"\n#include \"eswitch.h\"\n#include \"bridge_priv.h\"\n#define CREATE_TRACE_POINTS\n#include \"diag/bridge_tracepoint.h\"\n\nstatic const struct rhashtable_params fdb_ht_params = {\n\t.key_offset = offsetof(struct mlx5_esw_bridge_fdb_entry, key),\n\t.key_len = sizeof(struct mlx5_esw_bridge_fdb_key),\n\t.head_offset = offsetof(struct mlx5_esw_bridge_fdb_entry, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic void\nmlx5_esw_bridge_fdb_offload_notify(struct net_device *dev, const unsigned char *addr, u16 vid,\n\t\t\t\t   unsigned long val)\n{\n\tstruct switchdev_notifier_fdb_info send_info = {};\n\n\tsend_info.addr = addr;\n\tsend_info.vid = vid;\n\tsend_info.offloaded = true;\n\tcall_switchdev_notifiers(val, dev, &send_info.info, NULL);\n}\n\nstatic void\nmlx5_esw_bridge_fdb_del_notify(struct mlx5_esw_bridge_fdb_entry *entry)\n{\n\tif (!(entry->flags & (MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER | MLX5_ESW_BRIDGE_FLAG_PEER)))\n\t\tmlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,\n\t\t\t\t\t\t   entry->key.vid,\n\t\t\t\t\t\t   SWITCHDEV_FDB_DEL_TO_BRIDGE);\n}\n\nstatic bool mlx5_esw_bridge_pkt_reformat_vlan_pop_supported(struct mlx5_eswitch *esw)\n{\n\treturn BIT(MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, reformat_remove)) &&\n\t\tMLX5_CAP_GEN_2(esw->dev, max_reformat_remove_size) >= sizeof(struct vlan_hdr) &&\n\t\tMLX5_CAP_GEN_2(esw->dev, max_reformat_remove_offset) >=\n\t\toffsetof(struct vlan_ethhdr, h_vlan_proto);\n}\n\nstatic struct mlx5_pkt_reformat *\nmlx5_esw_bridge_pkt_reformat_vlan_pop_create(struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_pkt_reformat_params reformat_params = {};\n\n\treformat_params.type = MLX5_REFORMAT_TYPE_REMOVE_HDR;\n\treformat_params.param_0 = MLX5_REFORMAT_CONTEXT_ANCHOR_MAC_START;\n\treformat_params.param_1 = offsetof(struct vlan_ethhdr, h_vlan_proto);\n\treformat_params.size = sizeof(struct vlan_hdr);\n\treturn mlx5_packet_reformat_alloc(esw->dev, &reformat_params, MLX5_FLOW_NAMESPACE_FDB);\n}\n\nstruct mlx5_flow_table *\nmlx5_esw_bridge_table_create(int max_fte, u32 level, struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_table *fdb;\n\n\tns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);\n\tif (!ns) {\n\t\tesw_warn(dev, \"Failed to get FDB namespace\\n\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tft_attr.flags = MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\tft_attr.max_fte = max_fte;\n\tft_attr.level = level;\n\tft_attr.prio = FDB_BR_OFFLOAD;\n\tfdb = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(fdb))\n\t\tesw_warn(dev, \"Failed to create bridge FDB Table (err=%ld)\\n\", PTR_ERR(fdb));\n\n\treturn fdb;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_vlan_proto_fg_create(unsigned int from, unsigned int to, u16 vlan_proto,\n\t\t\t\t\t     struct mlx5_eswitch *esw,\n\t\t\t\t\t     struct mlx5_flow_table *ingress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_2);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.smac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.smac_15_0);\n\tif (vlan_proto == ETH_P_8021Q)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.cvlan_tag);\n\telse if (vlan_proto == ETH_P_8021AD)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.svlan_tag);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.first_vid);\n\n\tMLX5_SET(fte_match_param, match, misc_parameters_2.metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_mask());\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index, from);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index, to);\n\n\tfg = mlx5_create_flow_group(ingress_ft, in);\n\tkvfree(in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create VLAN(proto=%x) flow group for bridge ingress table (err=%ld)\\n\",\n\t\t\t vlan_proto, PTR_ERR(fg));\n\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_vlan_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t       struct mlx5_flow_table *ingress_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_VLAN_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_INGRESS_TABLE_VLAN_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_ingress_vlan_proto_fg_create(from, to, ETH_P_8021Q, esw, ingress_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_qinq_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t       struct mlx5_flow_table *ingress_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_QINQ_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_INGRESS_TABLE_QINQ_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_ingress_vlan_proto_fg_create(from, to, ETH_P_8021AD, esw,\n\t\t\t\t\t\t\t    ingress_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_vlan_proto_filter_fg_create(unsigned int from, unsigned int to,\n\t\t\t\t\t\t    u16 vlan_proto, struct mlx5_eswitch *esw,\n\t\t\t\t\t\t    struct mlx5_flow_table *ingress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_2);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.smac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.smac_15_0);\n\tif (vlan_proto == ETH_P_8021Q)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.cvlan_tag);\n\telse if (vlan_proto == ETH_P_8021AD)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.svlan_tag);\n\tMLX5_SET(fte_match_param, match, misc_parameters_2.metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_mask());\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index, from);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index, to);\n\n\tfg = mlx5_create_flow_group(ingress_ft, in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create bridge ingress table VLAN filter flow group (err=%ld)\\n\",\n\t\t\t PTR_ERR(fg));\n\tkvfree(in);\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_vlan_filter_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t      struct mlx5_flow_table *ingress_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_VLAN_FILTER_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_INGRESS_TABLE_VLAN_FILTER_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_ingress_vlan_proto_filter_fg_create(from, to, ETH_P_8021Q, esw,\n\t\t\t\t\t\t\t\t   ingress_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_qinq_filter_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t\t      struct mlx5_flow_table *ingress_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_QINQ_FILTER_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_INGRESS_TABLE_QINQ_FILTER_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_ingress_vlan_proto_filter_fg_create(from, to, ETH_P_8021AD, esw,\n\t\t\t\t\t\t\t\t   ingress_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_mac_fg_create(struct mlx5_eswitch *esw, struct mlx5_flow_table *ingress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_2);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.smac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.smac_15_0);\n\n\tMLX5_SET(fte_match_param, match, misc_parameters_2.metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_mask());\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index,\n\t\t MLX5_ESW_BRIDGE_INGRESS_TABLE_MAC_GRP_IDX_FROM);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index,\n\t\t MLX5_ESW_BRIDGE_INGRESS_TABLE_MAC_GRP_IDX_TO);\n\n\tfg = mlx5_create_flow_group(ingress_ft, in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create MAC flow group for bridge ingress table (err=%ld)\\n\",\n\t\t\t PTR_ERR(fg));\n\n\tkvfree(in);\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_egress_vlan_proto_fg_create(unsigned int from, unsigned int to, u16 vlan_proto,\n\t\t\t\t\t    struct mlx5_eswitch *esw,\n\t\t\t\t\t    struct mlx5_flow_table *egress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.dmac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.dmac_15_0);\n\tif (vlan_proto == ETH_P_8021Q)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.cvlan_tag);\n\telse if (vlan_proto == ETH_P_8021AD)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.svlan_tag);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.first_vid);\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index, from);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index, to);\n\n\tfg = mlx5_create_flow_group(egress_ft, in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create VLAN flow group for bridge egress table (err=%ld)\\n\",\n\t\t\t PTR_ERR(fg));\n\tkvfree(in);\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_egress_vlan_fg_create(struct mlx5_eswitch *esw, struct mlx5_flow_table *egress_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_EGRESS_TABLE_VLAN_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_EGRESS_TABLE_VLAN_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_egress_vlan_proto_fg_create(from, to, ETH_P_8021Q, esw, egress_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_egress_qinq_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t      struct mlx5_flow_table *egress_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_EGRESS_TABLE_QINQ_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_EGRESS_TABLE_QINQ_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_egress_vlan_proto_fg_create(from, to, ETH_P_8021AD, esw, egress_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_egress_mac_fg_create(struct mlx5_eswitch *esw, struct mlx5_flow_table *egress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.dmac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.dmac_15_0);\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index,\n\t\t MLX5_ESW_BRIDGE_EGRESS_TABLE_MAC_GRP_IDX_FROM);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index,\n\t\t MLX5_ESW_BRIDGE_EGRESS_TABLE_MAC_GRP_IDX_TO);\n\n\tfg = mlx5_create_flow_group(egress_ft, in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create bridge egress table MAC flow group (err=%ld)\\n\",\n\t\t\t PTR_ERR(fg));\n\tkvfree(in);\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_egress_miss_fg_create(struct mlx5_eswitch *esw, struct mlx5_flow_table *egress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable, MLX5_MATCH_MISC_PARAMETERS_2);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET(fte_match_param, match, misc_parameters_2.metadata_reg_c_1, ESW_TUN_MASK);\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index,\n\t\t MLX5_ESW_BRIDGE_EGRESS_TABLE_MISS_GRP_IDX_FROM);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index,\n\t\t MLX5_ESW_BRIDGE_EGRESS_TABLE_MISS_GRP_IDX_TO);\n\n\tfg = mlx5_create_flow_group(egress_ft, in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create bridge egress table miss flow group (err=%ld)\\n\",\n\t\t\t PTR_ERR(fg));\n\tkvfree(in);\n\treturn fg;\n}\n\nstatic int\nmlx5_esw_bridge_ingress_table_init(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_flow_group *mac_fg, *qinq_filter_fg, *qinq_fg, *vlan_filter_fg, *vlan_fg;\n\tstruct mlx5_flow_table *ingress_ft, *skip_ft;\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tint err;\n\n\tif (!mlx5_eswitch_vport_match_metadata_enabled(esw))\n\t\treturn -EOPNOTSUPP;\n\n\tingress_ft = mlx5_esw_bridge_table_create(MLX5_ESW_BRIDGE_INGRESS_TABLE_SIZE,\n\t\t\t\t\t\t  MLX5_ESW_BRIDGE_LEVEL_INGRESS_TABLE,\n\t\t\t\t\t\t  esw);\n\tif (IS_ERR(ingress_ft))\n\t\treturn PTR_ERR(ingress_ft);\n\n\tskip_ft = mlx5_esw_bridge_table_create(MLX5_ESW_BRIDGE_SKIP_TABLE_SIZE,\n\t\t\t\t\t       MLX5_ESW_BRIDGE_LEVEL_SKIP_TABLE,\n\t\t\t\t\t       esw);\n\tif (IS_ERR(skip_ft)) {\n\t\terr = PTR_ERR(skip_ft);\n\t\tgoto err_skip_tbl;\n\t}\n\n\tvlan_fg = mlx5_esw_bridge_ingress_vlan_fg_create(esw, ingress_ft);\n\tif (IS_ERR(vlan_fg)) {\n\t\terr = PTR_ERR(vlan_fg);\n\t\tgoto err_vlan_fg;\n\t}\n\n\tvlan_filter_fg = mlx5_esw_bridge_ingress_vlan_filter_fg_create(esw, ingress_ft);\n\tif (IS_ERR(vlan_filter_fg)) {\n\t\terr = PTR_ERR(vlan_filter_fg);\n\t\tgoto err_vlan_filter_fg;\n\t}\n\n\tqinq_fg = mlx5_esw_bridge_ingress_qinq_fg_create(esw, ingress_ft);\n\tif (IS_ERR(qinq_fg)) {\n\t\terr = PTR_ERR(qinq_fg);\n\t\tgoto err_qinq_fg;\n\t}\n\n\tqinq_filter_fg = mlx5_esw_bridge_ingress_qinq_filter_fg_create(esw, ingress_ft);\n\tif (IS_ERR(qinq_filter_fg)) {\n\t\terr = PTR_ERR(qinq_filter_fg);\n\t\tgoto err_qinq_filter_fg;\n\t}\n\n\tmac_fg = mlx5_esw_bridge_ingress_mac_fg_create(esw, ingress_ft);\n\tif (IS_ERR(mac_fg)) {\n\t\terr = PTR_ERR(mac_fg);\n\t\tgoto err_mac_fg;\n\t}\n\n\tbr_offloads->ingress_ft = ingress_ft;\n\tbr_offloads->skip_ft = skip_ft;\n\tbr_offloads->ingress_vlan_fg = vlan_fg;\n\tbr_offloads->ingress_vlan_filter_fg = vlan_filter_fg;\n\tbr_offloads->ingress_qinq_fg = qinq_fg;\n\tbr_offloads->ingress_qinq_filter_fg = qinq_filter_fg;\n\tbr_offloads->ingress_mac_fg = mac_fg;\n\treturn 0;\n\nerr_mac_fg:\n\tmlx5_destroy_flow_group(qinq_filter_fg);\nerr_qinq_filter_fg:\n\tmlx5_destroy_flow_group(qinq_fg);\nerr_qinq_fg:\n\tmlx5_destroy_flow_group(vlan_filter_fg);\nerr_vlan_filter_fg:\n\tmlx5_destroy_flow_group(vlan_fg);\nerr_vlan_fg:\n\tmlx5_destroy_flow_table(skip_ft);\nerr_skip_tbl:\n\tmlx5_destroy_flow_table(ingress_ft);\n\treturn err;\n}\n\nstatic void\nmlx5_esw_bridge_ingress_table_cleanup(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tmlx5_destroy_flow_group(br_offloads->ingress_mac_fg);\n\tbr_offloads->ingress_mac_fg = NULL;\n\tmlx5_destroy_flow_group(br_offloads->ingress_qinq_filter_fg);\n\tbr_offloads->ingress_qinq_filter_fg = NULL;\n\tmlx5_destroy_flow_group(br_offloads->ingress_qinq_fg);\n\tbr_offloads->ingress_qinq_fg = NULL;\n\tmlx5_destroy_flow_group(br_offloads->ingress_vlan_filter_fg);\n\tbr_offloads->ingress_vlan_filter_fg = NULL;\n\tmlx5_destroy_flow_group(br_offloads->ingress_vlan_fg);\n\tbr_offloads->ingress_vlan_fg = NULL;\n\tmlx5_destroy_flow_table(br_offloads->skip_ft);\n\tbr_offloads->skip_ft = NULL;\n\tmlx5_destroy_flow_table(br_offloads->ingress_ft);\n\tbr_offloads->ingress_ft = NULL;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_egress_miss_flow_create(struct mlx5_flow_table *egress_ft,\n\t\t\t\t\tstruct mlx5_flow_table *skip_ft,\n\t\t\t\t\tstruct mlx5_pkt_reformat *pkt_reformat);\n\nstatic int\nmlx5_esw_bridge_egress_table_init(struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t  struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_flow_group *miss_fg = NULL, *mac_fg, *vlan_fg, *qinq_fg;\n\tstruct mlx5_pkt_reformat *miss_pkt_reformat = NULL;\n\tstruct mlx5_flow_handle *miss_handle = NULL;\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tstruct mlx5_flow_table *egress_ft;\n\tint err;\n\n\tegress_ft = mlx5_esw_bridge_table_create(MLX5_ESW_BRIDGE_EGRESS_TABLE_SIZE,\n\t\t\t\t\t\t MLX5_ESW_BRIDGE_LEVEL_EGRESS_TABLE,\n\t\t\t\t\t\t esw);\n\tif (IS_ERR(egress_ft))\n\t\treturn PTR_ERR(egress_ft);\n\n\tvlan_fg = mlx5_esw_bridge_egress_vlan_fg_create(esw, egress_ft);\n\tif (IS_ERR(vlan_fg)) {\n\t\terr = PTR_ERR(vlan_fg);\n\t\tgoto err_vlan_fg;\n\t}\n\n\tqinq_fg = mlx5_esw_bridge_egress_qinq_fg_create(esw, egress_ft);\n\tif (IS_ERR(qinq_fg)) {\n\t\terr = PTR_ERR(qinq_fg);\n\t\tgoto err_qinq_fg;\n\t}\n\n\tmac_fg = mlx5_esw_bridge_egress_mac_fg_create(esw, egress_ft);\n\tif (IS_ERR(mac_fg)) {\n\t\terr = PTR_ERR(mac_fg);\n\t\tgoto err_mac_fg;\n\t}\n\n\tif (mlx5_esw_bridge_pkt_reformat_vlan_pop_supported(esw)) {\n\t\tmiss_fg = mlx5_esw_bridge_egress_miss_fg_create(esw, egress_ft);\n\t\tif (IS_ERR(miss_fg)) {\n\t\t\tesw_warn(esw->dev, \"Failed to create miss flow group (err=%ld)\\n\",\n\t\t\t\t PTR_ERR(miss_fg));\n\t\t\tmiss_fg = NULL;\n\t\t\tgoto skip_miss_flow;\n\t\t}\n\n\t\tmiss_pkt_reformat = mlx5_esw_bridge_pkt_reformat_vlan_pop_create(esw);\n\t\tif (IS_ERR(miss_pkt_reformat)) {\n\t\t\tesw_warn(esw->dev,\n\t\t\t\t \"Failed to alloc packet reformat REMOVE_HEADER (err=%ld)\\n\",\n\t\t\t\t PTR_ERR(miss_pkt_reformat));\n\t\t\tmiss_pkt_reformat = NULL;\n\t\t\tmlx5_destroy_flow_group(miss_fg);\n\t\t\tmiss_fg = NULL;\n\t\t\tgoto skip_miss_flow;\n\t\t}\n\n\t\tmiss_handle = mlx5_esw_bridge_egress_miss_flow_create(egress_ft,\n\t\t\t\t\t\t\t\t      br_offloads->skip_ft,\n\t\t\t\t\t\t\t\t      miss_pkt_reformat);\n\t\tif (IS_ERR(miss_handle)) {\n\t\t\tesw_warn(esw->dev, \"Failed to create miss flow (err=%ld)\\n\",\n\t\t\t\t PTR_ERR(miss_handle));\n\t\t\tmiss_handle = NULL;\n\t\t\tmlx5_packet_reformat_dealloc(esw->dev, miss_pkt_reformat);\n\t\t\tmiss_pkt_reformat = NULL;\n\t\t\tmlx5_destroy_flow_group(miss_fg);\n\t\t\tmiss_fg = NULL;\n\t\t\tgoto skip_miss_flow;\n\t\t}\n\t}\nskip_miss_flow:\n\n\tbridge->egress_ft = egress_ft;\n\tbridge->egress_vlan_fg = vlan_fg;\n\tbridge->egress_qinq_fg = qinq_fg;\n\tbridge->egress_mac_fg = mac_fg;\n\tbridge->egress_miss_fg = miss_fg;\n\tbridge->egress_miss_pkt_reformat = miss_pkt_reformat;\n\tbridge->egress_miss_handle = miss_handle;\n\treturn 0;\n\nerr_mac_fg:\n\tmlx5_destroy_flow_group(qinq_fg);\nerr_qinq_fg:\n\tmlx5_destroy_flow_group(vlan_fg);\nerr_vlan_fg:\n\tmlx5_destroy_flow_table(egress_ft);\n\treturn err;\n}\n\nstatic void\nmlx5_esw_bridge_egress_table_cleanup(struct mlx5_esw_bridge *bridge)\n{\n\tif (bridge->egress_miss_handle)\n\t\tmlx5_del_flow_rules(bridge->egress_miss_handle);\n\tif (bridge->egress_miss_pkt_reformat)\n\t\tmlx5_packet_reformat_dealloc(bridge->br_offloads->esw->dev,\n\t\t\t\t\t     bridge->egress_miss_pkt_reformat);\n\tif (bridge->egress_miss_fg)\n\t\tmlx5_destroy_flow_group(bridge->egress_miss_fg);\n\tmlx5_destroy_flow_group(bridge->egress_mac_fg);\n\tmlx5_destroy_flow_group(bridge->egress_qinq_fg);\n\tmlx5_destroy_flow_group(bridge->egress_vlan_fg);\n\tmlx5_destroy_flow_table(bridge->egress_ft);\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_ingress_flow_with_esw_create(u16 vport_num, const unsigned char *addr,\n\t\t\t\t\t     struct mlx5_esw_bridge_vlan *vlan, u32 counter_id,\n\t\t\t\t\t     struct mlx5_esw_bridge *bridge,\n\t\t\t\t\t     struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = bridge->br_offloads;\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_COUNT,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_destination dests[2] = {};\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\tu8 *smac_v, *smac_c;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_2;\n\n\tsmac_v = MLX5_ADDR_OF(fte_match_param, rule_spec->match_value,\n\t\t\t      outer_headers.smac_47_16);\n\tether_addr_copy(smac_v, addr);\n\tsmac_c = MLX5_ADDR_OF(fte_match_param, rule_spec->match_criteria,\n\t\t\t      outer_headers.smac_47_16);\n\teth_broadcast_addr(smac_c);\n\n\tMLX5_SET(fte_match_param, rule_spec->match_criteria,\n\t\t misc_parameters_2.metadata_reg_c_0, mlx5_eswitch_get_vport_metadata_mask());\n\tMLX5_SET(fte_match_param, rule_spec->match_value, misc_parameters_2.metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_for_match(esw, vport_num));\n\n\tif (vlan && vlan->pkt_reformat_push) {\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT |\n\t\t\tMLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t\tflow_act.pkt_reformat = vlan->pkt_reformat_push;\n\t\tflow_act.modify_hdr = vlan->pkt_mod_hdr_push_mark;\n\t} else if (vlan) {\n\t\tif (bridge->vlan_proto == ETH_P_8021Q) {\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t\t outer_headers.cvlan_tag);\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t\t outer_headers.cvlan_tag);\n\t\t} else if (bridge->vlan_proto == ETH_P_8021AD) {\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t\t outer_headers.svlan_tag);\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t\t outer_headers.svlan_tag);\n\t\t}\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t outer_headers.first_vid);\n\t\tMLX5_SET(fte_match_param, rule_spec->match_value, outer_headers.first_vid,\n\t\t\t vlan->vid);\n\t}\n\n\tdests[0].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdests[0].ft = bridge->egress_ft;\n\tdests[1].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdests[1].counter_id = counter_id;\n\n\thandle = mlx5_add_flow_rules(br_offloads->ingress_ft, rule_spec, &flow_act, dests,\n\t\t\t\t     ARRAY_SIZE(dests));\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_ingress_flow_create(u16 vport_num, const unsigned char *addr,\n\t\t\t\t    struct mlx5_esw_bridge_vlan *vlan, u32 counter_id,\n\t\t\t\t    struct mlx5_esw_bridge *bridge)\n{\n\treturn mlx5_esw_bridge_ingress_flow_with_esw_create(vport_num, addr, vlan, counter_id,\n\t\t\t\t\t\t\t    bridge, bridge->br_offloads->esw);\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_ingress_flow_peer_create(u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t\t const unsigned char *addr,\n\t\t\t\t\t struct mlx5_esw_bridge_vlan *vlan, u32 counter_id,\n\t\t\t\t\t struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_devcom_comp_dev *devcom = bridge->br_offloads->esw->devcom, *pos;\n\tstruct mlx5_eswitch *tmp, *peer_esw = NULL;\n\tstatic struct mlx5_flow_handle *handle;\n\n\tif (!mlx5_devcom_for_each_peer_begin(devcom))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmlx5_devcom_for_each_peer_entry(devcom, tmp, pos) {\n\t\tif (mlx5_esw_is_owner(tmp, vport_num, esw_owner_vhca_id)) {\n\t\t\tpeer_esw = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!peer_esw) {\n\t\thandle = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t}\n\n\thandle = mlx5_esw_bridge_ingress_flow_with_esw_create(vport_num, addr, vlan, counter_id,\n\t\t\t\t\t\t\t      bridge, peer_esw);\n\nout:\n\tmlx5_devcom_for_each_peer_end(devcom);\n\treturn handle;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_ingress_filter_flow_create(u16 vport_num, const unsigned char *addr,\n\t\t\t\t\t   struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = bridge->br_offloads;\n\tstruct mlx5_flow_destination dest = {\n\t\t.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE,\n\t\t.ft = br_offloads->skip_ft,\n\t};\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\tu8 *smac_v, *smac_c;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_2;\n\n\tsmac_v = MLX5_ADDR_OF(fte_match_param, rule_spec->match_value,\n\t\t\t      outer_headers.smac_47_16);\n\tether_addr_copy(smac_v, addr);\n\tsmac_c = MLX5_ADDR_OF(fte_match_param, rule_spec->match_criteria,\n\t\t\t      outer_headers.smac_47_16);\n\teth_broadcast_addr(smac_c);\n\n\tMLX5_SET(fte_match_param, rule_spec->match_criteria,\n\t\t misc_parameters_2.metadata_reg_c_0, mlx5_eswitch_get_vport_metadata_mask());\n\tMLX5_SET(fte_match_param, rule_spec->match_value, misc_parameters_2.metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_for_match(br_offloads->esw, vport_num));\n\n\tif (bridge->vlan_proto == ETH_P_8021Q) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t outer_headers.cvlan_tag);\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t outer_headers.cvlan_tag);\n\t} else if (bridge->vlan_proto == ETH_P_8021AD) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t outer_headers.svlan_tag);\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t outer_headers.svlan_tag);\n\t}\n\n\thandle = mlx5_add_flow_rules(br_offloads->ingress_ft, rule_spec, &flow_act, &dest, 1);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_egress_flow_create(u16 vport_num, u16 esw_owner_vhca_id, const unsigned char *addr,\n\t\t\t\t   struct mlx5_esw_bridge_vlan *vlan,\n\t\t\t\t   struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_flow_destination dest = {\n\t\t.type = MLX5_FLOW_DESTINATION_TYPE_VPORT,\n\t\t.vport.num = vport_num,\n\t};\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\tu8 *dmac_v, *dmac_c;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (MLX5_CAP_ESW_FLOWTABLE(bridge->br_offloads->esw->dev, flow_source) &&\n\t    vport_num == MLX5_VPORT_UPLINK)\n\t\trule_spec->flow_context.flow_source =\n\t\t\tMLX5_FLOW_CONTEXT_FLOW_SOURCE_LOCAL_VPORT;\n\trule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\n\tdmac_v = MLX5_ADDR_OF(fte_match_param, rule_spec->match_value,\n\t\t\t      outer_headers.dmac_47_16);\n\tether_addr_copy(dmac_v, addr);\n\tdmac_c = MLX5_ADDR_OF(fte_match_param, rule_spec->match_criteria,\n\t\t\t      outer_headers.dmac_47_16);\n\teth_broadcast_addr(dmac_c);\n\n\tif (vlan) {\n\t\tif (vlan->pkt_reformat_pop) {\n\t\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\t\t\tflow_act.pkt_reformat = vlan->pkt_reformat_pop;\n\t\t}\n\n\t\tif (bridge->vlan_proto == ETH_P_8021Q) {\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t\t outer_headers.cvlan_tag);\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t\t outer_headers.cvlan_tag);\n\t\t} else if (bridge->vlan_proto == ETH_P_8021AD) {\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t\t outer_headers.svlan_tag);\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t\t outer_headers.svlan_tag);\n\t\t}\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t outer_headers.first_vid);\n\t\tMLX5_SET(fte_match_param, rule_spec->match_value, outer_headers.first_vid,\n\t\t\t vlan->vid);\n\t}\n\n\tif (MLX5_CAP_ESW(bridge->br_offloads->esw->dev, merged_eswitch)) {\n\t\tdest.vport.flags = MLX5_FLOW_DEST_VPORT_VHCA_ID;\n\t\tdest.vport.vhca_id = esw_owner_vhca_id;\n\t}\n\thandle = mlx5_add_flow_rules(bridge->egress_ft, rule_spec, &flow_act, &dest, 1);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_egress_miss_flow_create(struct mlx5_flow_table *egress_ft,\n\t\t\t\t\tstruct mlx5_flow_table *skip_ft,\n\t\t\t\t\tstruct mlx5_pkt_reformat *pkt_reformat)\n{\n\tstruct mlx5_flow_destination dest = {\n\t\t.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE,\n\t\t.ft = skip_ft,\n\t};\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |\n\t\tMLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t\t.pkt_reformat = pkt_reformat,\n\t};\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trule_spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;\n\n\tMLX5_SET(fte_match_param, rule_spec->match_criteria,\n\t\t misc_parameters_2.metadata_reg_c_1, ESW_TUN_MASK);\n\tMLX5_SET(fte_match_param, rule_spec->match_value, misc_parameters_2.metadata_reg_c_1,\n\t\t ESW_TUN_BRIDGE_INGRESS_PUSH_VLAN_MARK);\n\n\thandle = mlx5_add_flow_rules(egress_ft, rule_spec, &flow_act, &dest, 1);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic struct mlx5_esw_bridge *mlx5_esw_bridge_create(struct net_device *br_netdev,\n\t\t\t\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge *bridge;\n\tint err;\n\n\tbridge = kvzalloc(sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbridge->br_offloads = br_offloads;\n\terr = mlx5_esw_bridge_egress_table_init(br_offloads, bridge);\n\tif (err)\n\t\tgoto err_egress_tbl;\n\n\terr = rhashtable_init(&bridge->fdb_ht, &fdb_ht_params);\n\tif (err)\n\t\tgoto err_fdb_ht;\n\n\terr = mlx5_esw_bridge_mdb_init(bridge);\n\tif (err)\n\t\tgoto err_mdb_ht;\n\n\tINIT_LIST_HEAD(&bridge->fdb_list);\n\tbridge->ifindex = br_netdev->ifindex;\n\tbridge->refcnt = 1;\n\tbridge->ageing_time = clock_t_to_jiffies(BR_DEFAULT_AGEING_TIME);\n\tbridge->vlan_proto = ETH_P_8021Q;\n\tlist_add(&bridge->list, &br_offloads->bridges);\n\tmlx5_esw_bridge_debugfs_init(br_netdev, bridge);\n\n\treturn bridge;\n\nerr_mdb_ht:\n\trhashtable_destroy(&bridge->fdb_ht);\nerr_fdb_ht:\n\tmlx5_esw_bridge_egress_table_cleanup(bridge);\nerr_egress_tbl:\n\tkvfree(bridge);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlx5_esw_bridge_get(struct mlx5_esw_bridge *bridge)\n{\n\tbridge->refcnt++;\n}\n\nstatic void mlx5_esw_bridge_put(struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\tstruct mlx5_esw_bridge *bridge)\n{\n\tif (--bridge->refcnt)\n\t\treturn;\n\n\tmlx5_esw_bridge_debugfs_cleanup(bridge);\n\tmlx5_esw_bridge_egress_table_cleanup(bridge);\n\tmlx5_esw_bridge_mcast_disable(bridge);\n\tlist_del(&bridge->list);\n\tmlx5_esw_bridge_mdb_cleanup(bridge);\n\trhashtable_destroy(&bridge->fdb_ht);\n\tkvfree(bridge);\n\n\tif (list_empty(&br_offloads->bridges))\n\t\tmlx5_esw_bridge_ingress_table_cleanup(br_offloads);\n}\n\nstatic struct mlx5_esw_bridge *\nmlx5_esw_bridge_lookup(struct net_device *br_netdev, struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge *bridge;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(bridge, &br_offloads->bridges, list) {\n\t\tif (bridge->ifindex == br_netdev->ifindex) {\n\t\t\tmlx5_esw_bridge_get(bridge);\n\t\t\treturn bridge;\n\t\t}\n\t}\n\n\tif (!br_offloads->ingress_ft) {\n\t\tint err = mlx5_esw_bridge_ingress_table_init(br_offloads);\n\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\tbridge = mlx5_esw_bridge_create(br_netdev, br_offloads);\n\tif (IS_ERR(bridge) && list_empty(&br_offloads->bridges))\n\t\tmlx5_esw_bridge_ingress_table_cleanup(br_offloads);\n\treturn bridge;\n}\n\nstatic unsigned long mlx5_esw_bridge_port_key_from_data(u16 vport_num, u16 esw_owner_vhca_id)\n{\n\treturn vport_num | (unsigned long)esw_owner_vhca_id << sizeof(vport_num) * BITS_PER_BYTE;\n}\n\nunsigned long mlx5_esw_bridge_port_key(struct mlx5_esw_bridge_port *port)\n{\n\treturn mlx5_esw_bridge_port_key_from_data(port->vport_num, port->esw_owner_vhca_id);\n}\n\nstatic int mlx5_esw_bridge_port_insert(struct mlx5_esw_bridge_port *port,\n\t\t\t\t       struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\treturn xa_insert(&br_offloads->ports, mlx5_esw_bridge_port_key(port), port, GFP_KERNEL);\n}\n\nstatic struct mlx5_esw_bridge_port *\nmlx5_esw_bridge_port_lookup(u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t    struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\treturn xa_load(&br_offloads->ports, mlx5_esw_bridge_port_key_from_data(vport_num,\n\t\t\t\t\t\t\t\t\t       esw_owner_vhca_id));\n}\n\nstatic void mlx5_esw_bridge_port_erase(struct mlx5_esw_bridge_port *port,\n\t\t\t\t       struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\txa_erase(&br_offloads->ports, mlx5_esw_bridge_port_key(port));\n}\n\nstatic struct mlx5_esw_bridge *\nmlx5_esw_bridge_from_port_lookup(u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge_port *port;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!port)\n\t\treturn NULL;\n\n\treturn port->bridge;\n}\n\nstatic void mlx5_esw_bridge_fdb_entry_refresh(struct mlx5_esw_bridge_fdb_entry *entry)\n{\n\ttrace_mlx5_esw_bridge_fdb_entry_refresh(entry);\n\n\tmlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,\n\t\t\t\t\t   entry->key.vid,\n\t\t\t\t\t   SWITCHDEV_FDB_ADD_TO_BRIDGE);\n}\n\nstatic void\nmlx5_esw_bridge_fdb_entry_cleanup(struct mlx5_esw_bridge_fdb_entry *entry,\n\t\t\t\t  struct mlx5_esw_bridge *bridge)\n{\n\ttrace_mlx5_esw_bridge_fdb_entry_cleanup(entry);\n\n\trhashtable_remove_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);\n\tmlx5_del_flow_rules(entry->egress_handle);\n\tif (entry->filter_handle)\n\t\tmlx5_del_flow_rules(entry->filter_handle);\n\tmlx5_del_flow_rules(entry->ingress_handle);\n\tmlx5_fc_destroy(bridge->br_offloads->esw->dev, entry->ingress_counter);\n\tlist_del(&entry->vlan_list);\n\tlist_del(&entry->list);\n\tkvfree(entry);\n}\n\nstatic void\nmlx5_esw_bridge_fdb_entry_notify_and_cleanup(struct mlx5_esw_bridge_fdb_entry *entry,\n\t\t\t\t\t     struct mlx5_esw_bridge *bridge)\n{\n\tmlx5_esw_bridge_fdb_del_notify(entry);\n\tmlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);\n}\n\nstatic void mlx5_esw_bridge_fdb_flush(struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_fdb_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list)\n\t\tmlx5_esw_bridge_fdb_entry_notify_and_cleanup(entry, bridge);\n}\n\nstatic struct mlx5_esw_bridge_vlan *\nmlx5_esw_bridge_vlan_lookup(u16 vid, struct mlx5_esw_bridge_port *port)\n{\n\treturn xa_load(&port->vlans, vid);\n}\n\nstatic int\nmlx5_esw_bridge_vlan_push_create(u16 vlan_proto, struct mlx5_esw_bridge_vlan *vlan,\n\t\t\t\t struct mlx5_eswitch *esw)\n{\n\tstruct {\n\t\t__be16\th_vlan_proto;\n\t\t__be16\th_vlan_TCI;\n\t} vlan_hdr = { htons(vlan_proto), htons(vlan->vid) };\n\tstruct mlx5_pkt_reformat_params reformat_params = {};\n\tstruct mlx5_pkt_reformat *pkt_reformat;\n\n\tif (!BIT(MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, reformat_insert)) ||\n\t    MLX5_CAP_GEN_2(esw->dev, max_reformat_insert_size) < sizeof(vlan_hdr) ||\n\t    MLX5_CAP_GEN_2(esw->dev, max_reformat_insert_offset) <\n\t    offsetof(struct vlan_ethhdr, h_vlan_proto)) {\n\t\tesw_warn(esw->dev, \"Packet reformat INSERT_HEADER is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treformat_params.type = MLX5_REFORMAT_TYPE_INSERT_HDR;\n\treformat_params.param_0 = MLX5_REFORMAT_CONTEXT_ANCHOR_MAC_START;\n\treformat_params.param_1 = offsetof(struct vlan_ethhdr, h_vlan_proto);\n\treformat_params.size = sizeof(vlan_hdr);\n\treformat_params.data = &vlan_hdr;\n\tpkt_reformat = mlx5_packet_reformat_alloc(esw->dev,\n\t\t\t\t\t\t  &reformat_params,\n\t\t\t\t\t\t  MLX5_FLOW_NAMESPACE_FDB);\n\tif (IS_ERR(pkt_reformat)) {\n\t\tesw_warn(esw->dev, \"Failed to alloc packet reformat INSERT_HEADER (err=%ld)\\n\",\n\t\t\t PTR_ERR(pkt_reformat));\n\t\treturn PTR_ERR(pkt_reformat);\n\t}\n\n\tvlan->pkt_reformat_push = pkt_reformat;\n\treturn 0;\n}\n\nstatic void\nmlx5_esw_bridge_vlan_push_cleanup(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)\n{\n\tmlx5_packet_reformat_dealloc(esw->dev, vlan->pkt_reformat_push);\n\tvlan->pkt_reformat_push = NULL;\n}\n\nstatic int\nmlx5_esw_bridge_vlan_pop_create(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_pkt_reformat *pkt_reformat;\n\n\tif (!mlx5_esw_bridge_pkt_reformat_vlan_pop_supported(esw)) {\n\t\tesw_warn(esw->dev, \"Packet reformat REMOVE_HEADER is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpkt_reformat = mlx5_esw_bridge_pkt_reformat_vlan_pop_create(esw);\n\tif (IS_ERR(pkt_reformat)) {\n\t\tesw_warn(esw->dev, \"Failed to alloc packet reformat REMOVE_HEADER (err=%ld)\\n\",\n\t\t\t PTR_ERR(pkt_reformat));\n\t\treturn PTR_ERR(pkt_reformat);\n\t}\n\n\tvlan->pkt_reformat_pop = pkt_reformat;\n\treturn 0;\n}\n\nstatic void\nmlx5_esw_bridge_vlan_pop_cleanup(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)\n{\n\tmlx5_packet_reformat_dealloc(esw->dev, vlan->pkt_reformat_pop);\n\tvlan->pkt_reformat_pop = NULL;\n}\n\nstatic int\nmlx5_esw_bridge_vlan_push_mark_create(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)\n{\n\tu8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5_modify_hdr *pkt_mod_hdr;\n\n\tMLX5_SET(set_action_in, action, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, action, field, MLX5_ACTION_IN_FIELD_METADATA_REG_C_1);\n\tMLX5_SET(set_action_in, action, offset, 8);\n\tMLX5_SET(set_action_in, action, length, ESW_TUN_OPTS_BITS + ESW_TUN_ID_BITS);\n\tMLX5_SET(set_action_in, action, data, ESW_TUN_BRIDGE_INGRESS_PUSH_VLAN);\n\n\tpkt_mod_hdr = mlx5_modify_header_alloc(esw->dev, MLX5_FLOW_NAMESPACE_FDB, 1, action);\n\tif (IS_ERR(pkt_mod_hdr))\n\t\treturn PTR_ERR(pkt_mod_hdr);\n\n\tvlan->pkt_mod_hdr_push_mark = pkt_mod_hdr;\n\treturn 0;\n}\n\nstatic void\nmlx5_esw_bridge_vlan_push_mark_cleanup(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)\n{\n\tmlx5_modify_header_dealloc(esw->dev, vlan->pkt_mod_hdr_push_mark);\n\tvlan->pkt_mod_hdr_push_mark = NULL;\n}\n\nstatic int\nmlx5_esw_bridge_vlan_push_pop_fhs_create(u16 vlan_proto, struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t struct mlx5_esw_bridge_vlan *vlan)\n{\n\treturn mlx5_esw_bridge_vlan_mcast_init(vlan_proto, port, vlan);\n}\n\nstatic void\nmlx5_esw_bridge_vlan_push_pop_fhs_cleanup(struct mlx5_esw_bridge_vlan *vlan)\n{\n\tmlx5_esw_bridge_vlan_mcast_cleanup(vlan);\n}\n\nstatic int\nmlx5_esw_bridge_vlan_push_pop_create(u16 vlan_proto, u16 flags, struct mlx5_esw_bridge_port *port,\n\t\t\t\t     struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)\n{\n\tint err;\n\n\tif (flags & BRIDGE_VLAN_INFO_PVID) {\n\t\terr = mlx5_esw_bridge_vlan_push_create(vlan_proto, vlan, esw);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlx5_esw_bridge_vlan_push_mark_create(vlan, esw);\n\t\tif (err)\n\t\t\tgoto err_vlan_push_mark;\n\t}\n\n\tif (flags & BRIDGE_VLAN_INFO_UNTAGGED) {\n\t\terr = mlx5_esw_bridge_vlan_pop_create(vlan, esw);\n\t\tif (err)\n\t\t\tgoto err_vlan_pop;\n\n\t\terr = mlx5_esw_bridge_vlan_push_pop_fhs_create(vlan_proto, port, vlan);\n\t\tif (err)\n\t\t\tgoto err_vlan_pop_fhs;\n\t}\n\n\treturn 0;\n\nerr_vlan_pop_fhs:\n\tmlx5_esw_bridge_vlan_pop_cleanup(vlan, esw);\nerr_vlan_pop:\n\tif (vlan->pkt_mod_hdr_push_mark)\n\t\tmlx5_esw_bridge_vlan_push_mark_cleanup(vlan, esw);\nerr_vlan_push_mark:\n\tif (vlan->pkt_reformat_push)\n\t\tmlx5_esw_bridge_vlan_push_cleanup(vlan, esw);\n\treturn err;\n}\n\nstatic struct mlx5_esw_bridge_vlan *\nmlx5_esw_bridge_vlan_create(u16 vlan_proto, u16 vid, u16 flags, struct mlx5_esw_bridge_port *port,\n\t\t\t    struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\tint err;\n\n\tvlan = kvzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvlan->vid = vid;\n\tvlan->flags = flags;\n\tINIT_LIST_HEAD(&vlan->fdb_list);\n\n\terr = mlx5_esw_bridge_vlan_push_pop_create(vlan_proto, flags, port, vlan, esw);\n\tif (err)\n\t\tgoto err_vlan_push_pop;\n\n\terr = xa_insert(&port->vlans, vid, vlan, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_xa_insert;\n\n\ttrace_mlx5_esw_bridge_vlan_create(vlan);\n\treturn vlan;\n\nerr_xa_insert:\n\tif (vlan->mcast_handle)\n\t\tmlx5_esw_bridge_vlan_push_pop_fhs_cleanup(vlan);\n\tif (vlan->pkt_reformat_pop)\n\t\tmlx5_esw_bridge_vlan_pop_cleanup(vlan, esw);\n\tif (vlan->pkt_mod_hdr_push_mark)\n\t\tmlx5_esw_bridge_vlan_push_mark_cleanup(vlan, esw);\n\tif (vlan->pkt_reformat_push)\n\t\tmlx5_esw_bridge_vlan_push_cleanup(vlan, esw);\nerr_vlan_push_pop:\n\tkvfree(vlan);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlx5_esw_bridge_vlan_erase(struct mlx5_esw_bridge_port *port,\n\t\t\t\t       struct mlx5_esw_bridge_vlan *vlan)\n{\n\txa_erase(&port->vlans, vlan->vid);\n}\n\nstatic void mlx5_esw_bridge_vlan_flush(struct mlx5_esw_bridge_port *port,\n\t\t\t\t       struct mlx5_esw_bridge_vlan *vlan,\n\t\t\t\t       struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_eswitch *esw = bridge->br_offloads->esw;\n\tstruct mlx5_esw_bridge_fdb_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &vlan->fdb_list, vlan_list)\n\t\tmlx5_esw_bridge_fdb_entry_notify_and_cleanup(entry, bridge);\n\tmlx5_esw_bridge_port_mdb_vlan_flush(port, vlan);\n\n\tif (vlan->mcast_handle)\n\t\tmlx5_esw_bridge_vlan_push_pop_fhs_cleanup(vlan);\n\tif (vlan->pkt_reformat_pop)\n\t\tmlx5_esw_bridge_vlan_pop_cleanup(vlan, esw);\n\tif (vlan->pkt_mod_hdr_push_mark)\n\t\tmlx5_esw_bridge_vlan_push_mark_cleanup(vlan, esw);\n\tif (vlan->pkt_reformat_push)\n\t\tmlx5_esw_bridge_vlan_push_cleanup(vlan, esw);\n}\n\nstatic void mlx5_esw_bridge_vlan_cleanup(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t struct mlx5_esw_bridge_vlan *vlan,\n\t\t\t\t\t struct mlx5_esw_bridge *bridge)\n{\n\ttrace_mlx5_esw_bridge_vlan_cleanup(vlan);\n\tmlx5_esw_bridge_vlan_flush(port, vlan, bridge);\n\tmlx5_esw_bridge_vlan_erase(port, vlan);\n\tkvfree(vlan);\n}\n\nstatic void mlx5_esw_bridge_port_vlans_flush(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t     struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\tunsigned long index;\n\n\txa_for_each(&port->vlans, index, vlan)\n\t\tmlx5_esw_bridge_vlan_cleanup(port, vlan, bridge);\n}\n\nstatic int mlx5_esw_bridge_port_vlans_recreate(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t       struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = bridge->br_offloads;\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\tunsigned long i;\n\tint err;\n\n\txa_for_each(&port->vlans, i, vlan) {\n\t\tmlx5_esw_bridge_vlan_flush(port, vlan, bridge);\n\t\terr = mlx5_esw_bridge_vlan_push_pop_create(bridge->vlan_proto, vlan->flags, port,\n\t\t\t\t\t\t\t   vlan, br_offloads->esw);\n\t\tif (err) {\n\t\t\tesw_warn(br_offloads->esw->dev,\n\t\t\t\t \"Failed to create VLAN=%u(proto=%x) push/pop actions (vport=%u,err=%d)\\n\",\n\t\t\t\t vlan->vid, bridge->vlan_proto, port->vport_num,\n\t\t\t\t err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlx5_esw_bridge_vlans_recreate(struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = bridge->br_offloads;\n\tstruct mlx5_esw_bridge_port *port;\n\tunsigned long i;\n\tint err;\n\n\txa_for_each(&br_offloads->ports, i, port) {\n\t\tif (port->bridge != bridge)\n\t\t\tcontinue;\n\n\t\terr = mlx5_esw_bridge_port_vlans_recreate(port, bridge);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct mlx5_esw_bridge_vlan *\nmlx5_esw_bridge_port_vlan_lookup(u16 vid, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t struct mlx5_esw_bridge *bridge, struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_esw_bridge_port *port;\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, bridge->br_offloads);\n\tif (!port) {\n\t\t \n\t\tesw_info(esw->dev, \"Failed to lookup bridge port (vport=%u)\\n\", vport_num);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvlan = mlx5_esw_bridge_vlan_lookup(vid, port);\n\tif (!vlan) {\n\t\t \n\t\tesw_info(esw->dev, \"Failed to lookup bridge port vlan metadata (vport=%u)\\n\",\n\t\t\t vport_num);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn vlan;\n}\n\nstatic struct mlx5_esw_bridge_fdb_entry *\nmlx5_esw_bridge_fdb_lookup(struct mlx5_esw_bridge *bridge,\n\t\t\t   const unsigned char *addr, u16 vid)\n{\n\tstruct mlx5_esw_bridge_fdb_key key = {};\n\n\tether_addr_copy(key.addr, addr);\n\tkey.vid = vid;\n\treturn rhashtable_lookup_fast(&bridge->fdb_ht, &key, fdb_ht_params);\n}\n\nstatic struct mlx5_esw_bridge_fdb_entry *\nmlx5_esw_bridge_fdb_entry_init(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t       const unsigned char *addr, u16 vid, bool added_by_user, bool peer,\n\t\t\t       struct mlx5_eswitch *esw, struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_vlan *vlan = NULL;\n\tstruct mlx5_esw_bridge_fdb_entry *entry;\n\tstruct mlx5_flow_handle *handle;\n\tstruct mlx5_fc *counter;\n\tint err;\n\n\tif (bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG && vid) {\n\t\tvlan = mlx5_esw_bridge_port_vlan_lookup(vid, vport_num, esw_owner_vhca_id, bridge,\n\t\t\t\t\t\t\tesw);\n\t\tif (IS_ERR(vlan))\n\t\t\treturn ERR_CAST(vlan);\n\t}\n\n\tentry = mlx5_esw_bridge_fdb_lookup(bridge, addr, vid);\n\tif (entry)\n\t\tmlx5_esw_bridge_fdb_entry_notify_and_cleanup(entry, bridge);\n\n\tentry = kvzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tether_addr_copy(entry->key.addr, addr);\n\tentry->key.vid = vid;\n\tentry->dev = dev;\n\tentry->vport_num = vport_num;\n\tentry->esw_owner_vhca_id = esw_owner_vhca_id;\n\tentry->lastuse = jiffies;\n\tif (added_by_user)\n\t\tentry->flags |= MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER;\n\tif (peer)\n\t\tentry->flags |= MLX5_ESW_BRIDGE_FLAG_PEER;\n\n\tcounter = mlx5_fc_create(esw->dev, true);\n\tif (IS_ERR(counter)) {\n\t\terr = PTR_ERR(counter);\n\t\tgoto err_ingress_fc_create;\n\t}\n\tentry->ingress_counter = counter;\n\n\thandle = peer ?\n\t\tmlx5_esw_bridge_ingress_flow_peer_create(vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t\t addr, vlan, mlx5_fc_id(counter),\n\t\t\t\t\t\t\t bridge) :\n\t\tmlx5_esw_bridge_ingress_flow_create(vport_num, addr, vlan,\n\t\t\t\t\t\t    mlx5_fc_id(counter), bridge);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tesw_warn(esw->dev, \"Failed to create ingress flow(vport=%u,err=%d,peer=%d)\\n\",\n\t\t\t vport_num, err, peer);\n\t\tgoto err_ingress_flow_create;\n\t}\n\tentry->ingress_handle = handle;\n\n\tif (bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG) {\n\t\thandle = mlx5_esw_bridge_ingress_filter_flow_create(vport_num, addr, bridge);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tesw_warn(esw->dev, \"Failed to create ingress filter(vport=%u,err=%d)\\n\",\n\t\t\t\t vport_num, err);\n\t\t\tgoto err_ingress_filter_flow_create;\n\t\t}\n\t\tentry->filter_handle = handle;\n\t}\n\n\thandle = mlx5_esw_bridge_egress_flow_create(vport_num, esw_owner_vhca_id, addr, vlan,\n\t\t\t\t\t\t    bridge);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tesw_warn(esw->dev, \"Failed to create egress flow(vport=%u,err=%d)\\n\",\n\t\t\t vport_num, err);\n\t\tgoto err_egress_flow_create;\n\t}\n\tentry->egress_handle = handle;\n\n\terr = rhashtable_insert_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);\n\tif (err) {\n\t\tesw_warn(esw->dev, \"Failed to insert FDB flow(vport=%u,err=%d)\\n\", vport_num, err);\n\t\tgoto err_ht_init;\n\t}\n\n\tif (vlan)\n\t\tlist_add(&entry->vlan_list, &vlan->fdb_list);\n\telse\n\t\tINIT_LIST_HEAD(&entry->vlan_list);\n\tlist_add(&entry->list, &bridge->fdb_list);\n\n\ttrace_mlx5_esw_bridge_fdb_entry_init(entry);\n\treturn entry;\n\nerr_ht_init:\n\tmlx5_del_flow_rules(entry->egress_handle);\nerr_egress_flow_create:\n\tif (entry->filter_handle)\n\t\tmlx5_del_flow_rules(entry->filter_handle);\nerr_ingress_filter_flow_create:\n\tmlx5_del_flow_rules(entry->ingress_handle);\nerr_ingress_flow_create:\n\tmlx5_fc_destroy(esw->dev, entry->ingress_counter);\nerr_ingress_fc_create:\n\tkvfree(entry);\n\treturn ERR_PTR(err);\n}\n\nint mlx5_esw_bridge_ageing_time_set(u16 vport_num, u16 esw_owner_vhca_id, unsigned long ageing_time,\n\t\t\t\t    struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge *bridge;\n\n\tbridge = mlx5_esw_bridge_from_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tbridge->ageing_time = clock_t_to_jiffies(ageing_time);\n\treturn 0;\n}\n\nint mlx5_esw_bridge_vlan_filtering_set(u16 vport_num, u16 esw_owner_vhca_id, bool enable,\n\t\t\t\t       struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge *bridge;\n\tbool filtering;\n\n\tbridge = mlx5_esw_bridge_from_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tfiltering = bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;\n\tif (filtering == enable)\n\t\treturn 0;\n\n\tmlx5_esw_bridge_fdb_flush(bridge);\n\tmlx5_esw_bridge_mdb_flush(bridge);\n\tif (enable)\n\t\tbridge->flags |= MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;\n\telse\n\t\tbridge->flags &= ~MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;\n\n\treturn 0;\n}\n\nint mlx5_esw_bridge_vlan_proto_set(u16 vport_num, u16 esw_owner_vhca_id, u16 proto,\n\t\t\t\t   struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge *bridge;\n\n\tbridge = mlx5_esw_bridge_from_port_lookup(vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t  br_offloads);\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (bridge->vlan_proto == proto)\n\t\treturn 0;\n\tif (proto != ETH_P_8021Q && proto != ETH_P_8021AD) {\n\t\tesw_warn(br_offloads->esw->dev, \"Can't set unsupported VLAN protocol %x\", proto);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmlx5_esw_bridge_fdb_flush(bridge);\n\tmlx5_esw_bridge_mdb_flush(bridge);\n\tbridge->vlan_proto = proto;\n\tmlx5_esw_bridge_vlans_recreate(bridge);\n\n\treturn 0;\n}\n\nint mlx5_esw_bridge_mcast_set(u16 vport_num, u16 esw_owner_vhca_id, bool enable,\n\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tstruct mlx5_esw_bridge *bridge;\n\tint err = 0;\n\tbool mcast;\n\n\tif (!(MLX5_CAP_ESW_FLOWTABLE((esw)->dev, fdb_multi_path_any_table) ||\n\t      MLX5_CAP_ESW_FLOWTABLE((esw)->dev, fdb_multi_path_any_table_limit_regc)) ||\n\t    !MLX5_CAP_ESW_FLOWTABLE((esw)->dev, fdb_uplink_hairpin) ||\n\t    !MLX5_CAP_ESW_FLOWTABLE_FDB((esw)->dev, ignore_flow_level))\n\t\treturn -EOPNOTSUPP;\n\n\tbridge = mlx5_esw_bridge_from_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tmcast = bridge->flags & MLX5_ESW_BRIDGE_MCAST_FLAG;\n\tif (mcast == enable)\n\t\treturn 0;\n\n\tif (enable)\n\t\terr = mlx5_esw_bridge_mcast_enable(bridge);\n\telse\n\t\tmlx5_esw_bridge_mcast_disable(bridge);\n\n\treturn err;\n}\n\nstatic int mlx5_esw_bridge_vport_init(u16 vport_num, u16 esw_owner_vhca_id, u16 flags,\n\t\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t      struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tstruct mlx5_esw_bridge_port *port;\n\tint err;\n\n\tport = kvzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->vport_num = vport_num;\n\tport->esw_owner_vhca_id = esw_owner_vhca_id;\n\tport->bridge = bridge;\n\tport->flags |= flags;\n\txa_init(&port->vlans);\n\n\terr = mlx5_esw_bridge_port_mcast_init(port);\n\tif (err) {\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to initialize port multicast (vport=%u,esw_owner_vhca_id=%u,err=%d)\\n\",\n\t\t\t port->vport_num, port->esw_owner_vhca_id, err);\n\t\tgoto err_port_mcast;\n\t}\n\n\terr = mlx5_esw_bridge_port_insert(port, br_offloads);\n\tif (err) {\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to insert port metadata (vport=%u,esw_owner_vhca_id=%u,err=%d)\\n\",\n\t\t\t port->vport_num, port->esw_owner_vhca_id, err);\n\t\tgoto err_port_insert;\n\t}\n\ttrace_mlx5_esw_bridge_vport_init(port);\n\n\treturn 0;\n\nerr_port_insert:\n\tmlx5_esw_bridge_port_mcast_cleanup(port);\nerr_port_mcast:\n\tkvfree(port);\n\treturn err;\n}\n\nstatic int mlx5_esw_bridge_vport_cleanup(struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t\t struct mlx5_esw_bridge_port *port)\n{\n\tu16 vport_num = port->vport_num, esw_owner_vhca_id = port->esw_owner_vhca_id;\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_esw_bridge_fdb_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list)\n\t\tif (entry->vport_num == vport_num && entry->esw_owner_vhca_id == esw_owner_vhca_id)\n\t\t\tmlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);\n\n\ttrace_mlx5_esw_bridge_vport_cleanup(port);\n\tmlx5_esw_bridge_port_vlans_flush(port, bridge);\n\tmlx5_esw_bridge_port_mcast_cleanup(port);\n\tmlx5_esw_bridge_port_erase(port, br_offloads);\n\tkvfree(port);\n\tmlx5_esw_bridge_put(br_offloads, bridge);\n\treturn 0;\n}\n\nstatic int mlx5_esw_bridge_vport_link_with_flags(struct net_device *br_netdev, u16 vport_num,\n\t\t\t\t\t\t u16 esw_owner_vhca_id, u16 flags,\n\t\t\t\t\t\t struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_esw_bridge *bridge;\n\tint err;\n\n\tbridge = mlx5_esw_bridge_lookup(br_netdev, br_offloads);\n\tif (IS_ERR(bridge)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Error checking for existing bridge with same ifindex\");\n\t\treturn PTR_ERR(bridge);\n\t}\n\n\terr = mlx5_esw_bridge_vport_init(vport_num, esw_owner_vhca_id, flags, br_offloads, bridge);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Error initializing port\");\n\t\tgoto err_vport;\n\t}\n\treturn 0;\n\nerr_vport:\n\tmlx5_esw_bridge_put(br_offloads, bridge);\n\treturn err;\n}\n\nint mlx5_esw_bridge_vport_link(struct net_device *br_netdev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t       struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn mlx5_esw_bridge_vport_link_with_flags(br_netdev, vport_num, esw_owner_vhca_id, 0,\n\t\t\t\t\t\t     br_offloads, extack);\n}\n\nint mlx5_esw_bridge_vport_unlink(struct net_device *br_netdev, u16 vport_num,\n\t\t\t\t u16 esw_owner_vhca_id,\n\t\t\t\t struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_esw_bridge_port *port;\n\tint err;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!port) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port is not attached to any bridge\");\n\t\treturn -EINVAL;\n\t}\n\tif (port->bridge->ifindex != br_netdev->ifindex) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port is attached to another bridge\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mlx5_esw_bridge_vport_cleanup(br_offloads, port);\n\tif (err)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port cleanup failed\");\n\treturn err;\n}\n\nint mlx5_esw_bridge_vport_peer_link(struct net_device *br_netdev, u16 vport_num,\n\t\t\t\t    u16 esw_owner_vhca_id,\n\t\t\t\t    struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (!MLX5_CAP_ESW(br_offloads->esw->dev, merged_eswitch))\n\t\treturn 0;\n\n\treturn mlx5_esw_bridge_vport_link_with_flags(br_netdev, vport_num, esw_owner_vhca_id,\n\t\t\t\t\t\t     MLX5_ESW_BRIDGE_PORT_FLAG_PEER,\n\t\t\t\t\t\t     br_offloads, extack);\n}\n\nint mlx5_esw_bridge_vport_peer_unlink(struct net_device *br_netdev, u16 vport_num,\n\t\t\t\t      u16 esw_owner_vhca_id,\n\t\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn mlx5_esw_bridge_vport_unlink(br_netdev, vport_num, esw_owner_vhca_id, br_offloads,\n\t\t\t\t\t    extack);\n}\n\nint mlx5_esw_bridge_port_vlan_add(u16 vport_num, u16 esw_owner_vhca_id, u16 vid, u16 flags,\n\t\t\t\t  struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_esw_bridge_port *port;\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!port)\n\t\treturn -EINVAL;\n\n\tvlan = mlx5_esw_bridge_vlan_lookup(vid, port);\n\tif (vlan) {\n\t\tif (vlan->flags == flags)\n\t\t\treturn 0;\n\t\tmlx5_esw_bridge_vlan_cleanup(port, vlan, port->bridge);\n\t}\n\n\tvlan = mlx5_esw_bridge_vlan_create(port->bridge->vlan_proto, vid, flags, port,\n\t\t\t\t\t   br_offloads->esw);\n\tif (IS_ERR(vlan)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to create VLAN entry\");\n\t\treturn PTR_ERR(vlan);\n\t}\n\treturn 0;\n}\n\nvoid mlx5_esw_bridge_port_vlan_del(u16 vport_num, u16 esw_owner_vhca_id, u16 vid,\n\t\t\t\t   struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge_port *port;\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!port)\n\t\treturn;\n\n\tvlan = mlx5_esw_bridge_vlan_lookup(vid, port);\n\tif (!vlan)\n\t\treturn;\n\tmlx5_esw_bridge_vlan_cleanup(port, vlan, port->bridge);\n}\n\nvoid mlx5_esw_bridge_fdb_update_used(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t     struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t     struct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct mlx5_esw_bridge_fdb_entry *entry;\n\tstruct mlx5_esw_bridge *bridge;\n\n\tbridge = mlx5_esw_bridge_from_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!bridge)\n\t\treturn;\n\n\tentry = mlx5_esw_bridge_fdb_lookup(bridge, fdb_info->addr, fdb_info->vid);\n\tif (!entry) {\n\t\tesw_debug(br_offloads->esw->dev,\n\t\t\t  \"FDB update entry with specified key not found (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t  fdb_info->addr, fdb_info->vid, vport_num);\n\t\treturn;\n\t}\n\n\tentry->lastuse = jiffies;\n}\n\nvoid mlx5_esw_bridge_fdb_mark_deleted(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t      struct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct mlx5_esw_bridge_fdb_entry *entry;\n\tstruct mlx5_esw_bridge *bridge;\n\n\tbridge = mlx5_esw_bridge_from_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!bridge)\n\t\treturn;\n\n\tentry = mlx5_esw_bridge_fdb_lookup(bridge, fdb_info->addr, fdb_info->vid);\n\tif (!entry) {\n\t\tesw_debug(br_offloads->esw->dev,\n\t\t\t  \"FDB mark deleted entry with specified key not found (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t  fdb_info->addr, fdb_info->vid, vport_num);\n\t\treturn;\n\t}\n\n\tentry->flags |= MLX5_ESW_BRIDGE_FLAG_DELETED;\n}\n\nvoid mlx5_esw_bridge_fdb_create(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\tstruct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\tstruct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct mlx5_esw_bridge_fdb_entry *entry;\n\tstruct mlx5_esw_bridge_port *port;\n\tstruct mlx5_esw_bridge *bridge;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!port)\n\t\treturn;\n\n\tbridge = port->bridge;\n\tentry = mlx5_esw_bridge_fdb_entry_init(dev, vport_num, esw_owner_vhca_id, fdb_info->addr,\n\t\t\t\t\t       fdb_info->vid, fdb_info->added_by_user,\n\t\t\t\t\t       port->flags & MLX5_ESW_BRIDGE_PORT_FLAG_PEER,\n\t\t\t\t\t       br_offloads->esw, bridge);\n\tif (IS_ERR(entry))\n\t\treturn;\n\n\tif (entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER)\n\t\tmlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,\n\t\t\t\t\t\t   SWITCHDEV_FDB_OFFLOADED);\n\telse if (!(entry->flags & MLX5_ESW_BRIDGE_FLAG_PEER))\n\t\t \n\t\tmlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,\n\t\t\t\t\t\t   SWITCHDEV_FDB_ADD_TO_BRIDGE);\n}\n\nvoid mlx5_esw_bridge_fdb_remove(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\tstruct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\tstruct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tstruct mlx5_esw_bridge_fdb_entry *entry;\n\tstruct mlx5_esw_bridge *bridge;\n\n\tbridge = mlx5_esw_bridge_from_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!bridge)\n\t\treturn;\n\n\tentry = mlx5_esw_bridge_fdb_lookup(bridge, fdb_info->addr, fdb_info->vid);\n\tif (!entry) {\n\t\tesw_debug(esw->dev,\n\t\t\t  \"FDB remove entry with specified key not found (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t  fdb_info->addr, fdb_info->vid, vport_num);\n\t\treturn;\n\t}\n\n\tmlx5_esw_bridge_fdb_entry_notify_and_cleanup(entry, bridge);\n}\n\nvoid mlx5_esw_bridge_update(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge_fdb_entry *entry, *tmp;\n\tstruct mlx5_esw_bridge *bridge;\n\n\tlist_for_each_entry(bridge, &br_offloads->bridges, list) {\n\t\tlist_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list) {\n\t\t\tunsigned long lastuse =\n\t\t\t\t(unsigned long)mlx5_fc_query_lastuse(entry->ingress_counter);\n\n\t\t\tif (entry->flags & (MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER |\n\t\t\t\t\t    MLX5_ESW_BRIDGE_FLAG_DELETED))\n\t\t\t\tcontinue;\n\n\t\t\tif (time_after(lastuse, entry->lastuse))\n\t\t\t\tmlx5_esw_bridge_fdb_entry_refresh(entry);\n\t\t\telse if (!(entry->flags & MLX5_ESW_BRIDGE_FLAG_PEER) &&\n\t\t\t\t time_is_before_jiffies(entry->lastuse + bridge->ageing_time))\n\t\t\t\tmlx5_esw_bridge_fdb_entry_notify_and_cleanup(entry, bridge);\n\t\t}\n\t}\n}\n\nint mlx5_esw_bridge_port_mdb_add(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t\t struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\tstruct mlx5_esw_bridge_port *port;\n\tstruct mlx5_esw_bridge *bridge;\n\tint err;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!port) {\n\t\tesw_warn(br_offloads->esw->dev,\n\t\t\t \"Failed to lookup bridge port to add MDB (MAC=%pM,vport=%u)\\n\",\n\t\t\t addr, vport_num);\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t       \"Failed to lookup bridge port to add MDB (MAC=%pM,vport=%u)\\n\",\n\t\t\t\t       addr, vport_num);\n\t\treturn -EINVAL;\n\t}\n\n\tbridge = port->bridge;\n\tif (bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG && vid) {\n\t\tvlan = mlx5_esw_bridge_vlan_lookup(vid, port);\n\t\tif (!vlan) {\n\t\t\tesw_warn(br_offloads->esw->dev,\n\t\t\t\t \"Failed to lookup bridge port vlan metadata to create MDB (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t\t addr, vid, vport_num);\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Failed to lookup bridge port vlan metadata to create MDB (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t\t\t       addr, vid, vport_num);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = mlx5_esw_bridge_port_mdb_attach(dev, port, addr, vid);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Failed to add MDB (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t\t       addr, vid, vport_num);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid mlx5_esw_bridge_port_mdb_del(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t  const unsigned char *addr, u16 vid,\n\t\t\t\t  struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge_port *port;\n\n\tport = mlx5_esw_bridge_port_lookup(vport_num, esw_owner_vhca_id, br_offloads);\n\tif (!port)\n\t\treturn;\n\n\tmlx5_esw_bridge_port_mdb_detach(dev, port, addr, vid);\n}\n\nstatic void mlx5_esw_bridge_flush(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge_port *port;\n\tunsigned long i;\n\n\txa_for_each(&br_offloads->ports, i, port)\n\t\tmlx5_esw_bridge_vport_cleanup(br_offloads, port);\n\n\tWARN_ONCE(!list_empty(&br_offloads->bridges),\n\t\t  \"Cleaning up bridge offloads while still having bridges attached\\n\");\n}\n\nstruct mlx5_esw_bridge_offloads *mlx5_esw_bridge_init(struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads;\n\n\tASSERT_RTNL();\n\n\tbr_offloads = kvzalloc(sizeof(*br_offloads), GFP_KERNEL);\n\tif (!br_offloads)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&br_offloads->bridges);\n\txa_init(&br_offloads->ports);\n\tbr_offloads->esw = esw;\n\tesw->br_offloads = br_offloads;\n\tmlx5_esw_bridge_debugfs_offloads_init(br_offloads);\n\n\treturn br_offloads;\n}\n\nvoid mlx5_esw_bridge_cleanup(struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = esw->br_offloads;\n\n\tASSERT_RTNL();\n\n\tif (!br_offloads)\n\t\treturn;\n\n\tmlx5_esw_bridge_flush(br_offloads);\n\tWARN_ON(!xa_empty(&br_offloads->ports));\n\tmlx5_esw_bridge_debugfs_offloads_cleanup(br_offloads);\n\n\tesw->br_offloads = NULL;\n\tkvfree(br_offloads);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}