{
  "module_name": "crypto.c",
  "hash_id": "22119bcde0abe472b7b7e93afe22ee6fe1c59a1df0efdefb4cb09348cc04aff4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c",
  "human_readable_source": "\n\n\n#include \"mlx5_core.h\"\n#include \"lib/crypto.h\"\n\n#define MLX5_CRYPTO_DEK_POOLS_NUM (MLX5_ACCEL_OBJ_TYPE_KEY_NUM - 1)\n#define type2idx(type) ((type) - 1)\n\n#define MLX5_CRYPTO_DEK_POOL_SYNC_THRESH 128\n\n \n#define MLX5_CRYPTO_DEK_CALC_FREED(a) \\\n\t({ typeof(a) _a = (a); \\\n\t   _a->num_deks - _a->avail_deks - _a->in_use_deks; })\n\n#define MLX5_CRYPTO_DEK_POOL_CALC_FREED(pool) MLX5_CRYPTO_DEK_CALC_FREED(pool)\n#define MLX5_CRYPTO_DEK_BULK_CALC_FREED(bulk) MLX5_CRYPTO_DEK_CALC_FREED(bulk)\n\n#define MLX5_CRYPTO_DEK_BULK_IDLE(bulk) \\\n\t({ typeof(bulk) _bulk = (bulk); \\\n\t   _bulk->avail_deks == _bulk->num_deks; })\n\nenum {\n\tMLX5_CRYPTO_DEK_ALL_TYPE = BIT(0),\n};\n\nstruct mlx5_crypto_dek_pool {\n\tstruct mlx5_core_dev *mdev;\n\tu32 key_purpose;\n\tint num_deks;  \n\tint avail_deks;  \n\tint in_use_deks;  \n\tstruct mutex lock;  \n\tstruct list_head partial_list;  \n\tstruct list_head full_list;  \n\tstruct list_head avail_list;  \n\n\t \n\tstruct list_head sync_list;\n\n\tbool syncing;\n\tstruct list_head wait_for_free;\n\tstruct work_struct sync_work;\n\n\tspinlock_t destroy_lock;  \n\tstruct list_head destroy_list;\n\tstruct work_struct destroy_work;\n};\n\nstruct mlx5_crypto_dek_bulk {\n\tstruct mlx5_core_dev *mdev;\n\tint base_obj_id;\n\tint avail_start;  \n\tint num_deks;  \n\tint avail_deks;  \n\tint in_use_deks;  \n\tstruct list_head entry;\n\n\t \n\tunsigned long *in_use;\n\n\t \n\tunsigned long *need_sync;\n};\n\nstruct mlx5_crypto_dek_priv {\n\tstruct mlx5_core_dev *mdev;\n\tint log_dek_obj_range;\n};\n\nstruct mlx5_crypto_dek {\n\tstruct mlx5_crypto_dek_bulk *bulk;\n\tstruct list_head entry;\n\tu32 obj_id;\n};\n\nu32 mlx5_crypto_dek_get_id(struct mlx5_crypto_dek *dek)\n{\n\treturn dek->obj_id;\n}\n\nstatic int mlx5_crypto_dek_get_key_sz(struct mlx5_core_dev *mdev,\n\t\t\t\t      u32 sz_bytes, u8 *key_sz_p)\n{\n\tu32 sz_bits = sz_bytes * BITS_PER_BYTE;\n\n\tswitch (sz_bits) {\n\tcase 128:\n\t\t*key_sz_p = MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_128;\n\t\tbreak;\n\tcase 256:\n\t\t*key_sz_p = MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_256;\n\t\tbreak;\n\tdefault:\n\t\tmlx5_core_err(mdev, \"Crypto offload error, invalid key size (%u bits)\\n\",\n\t\t\t      sz_bits);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5_crypto_dek_fill_key(struct mlx5_core_dev *mdev, u8 *key_obj,\n\t\t\t\t    const void *key, u32 sz_bytes)\n{\n\tvoid *dst;\n\tu8 key_sz;\n\tint err;\n\n\terr = mlx5_crypto_dek_get_key_sz(mdev, sz_bytes, &key_sz);\n\tif (err)\n\t\treturn err;\n\n\tMLX5_SET(encryption_key_obj, key_obj, key_size, key_sz);\n\n\tif (sz_bytes == 16)\n\t\t \n\t\tdst = MLX5_ADDR_OF(encryption_key_obj, key_obj, key[1]);\n\telse\n\t\tdst = MLX5_ADDR_OF(encryption_key_obj, key_obj, key);\n\n\tmemcpy(dst, key, sz_bytes);\n\n\treturn 0;\n}\n\nstatic int mlx5_crypto_cmd_sync_crypto(struct mlx5_core_dev *mdev,\n\t\t\t\t       int crypto_type)\n{\n\tu32 in[MLX5_ST_SZ_DW(sync_crypto_in)] = {};\n\tint err;\n\n\tmlx5_core_dbg(mdev,\n\t\t      \"Execute SYNC_CRYPTO command with crypto_type(0x%x)\\n\",\n\t\t      crypto_type);\n\n\tMLX5_SET(sync_crypto_in, in, opcode, MLX5_CMD_OP_SYNC_CRYPTO);\n\tMLX5_SET(sync_crypto_in, in, crypto_type, crypto_type);\n\n\terr = mlx5_cmd_exec_in(mdev, sync_crypto, in);\n\tif (err)\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to exec sync crypto, type=%d, err=%d\\n\",\n\t\t\t      crypto_type, err);\n\n\treturn err;\n}\n\nstatic int mlx5_crypto_create_dek_bulk(struct mlx5_core_dev *mdev,\n\t\t\t\t       u32 key_purpose, int log_obj_range,\n\t\t\t\t       u32 *obj_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_encryption_key_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\tvoid *obj, *param;\n\tint err;\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_GENERAL_OBJECT_TYPES_ENCRYPTION_KEY);\n\tparam = MLX5_ADDR_OF(general_obj_in_cmd_hdr, in, op_param);\n\tMLX5_SET(general_obj_create_param, param, log_obj_range, log_obj_range);\n\n\tobj = MLX5_ADDR_OF(create_encryption_key_in, in, encryption_key_object);\n\tMLX5_SET(encryption_key_obj, obj, key_purpose, key_purpose);\n\tMLX5_SET(encryption_key_obj, obj, pd, mdev->mlx5e_res.hw_objs.pdn);\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\t*obj_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\tmlx5_core_dbg(mdev, \"DEK objects created, bulk=%d, obj_id=%d\\n\",\n\t\t      1 << log_obj_range, *obj_id);\n\n\treturn 0;\n}\n\nstatic int mlx5_crypto_modify_dek_key(struct mlx5_core_dev *mdev,\n\t\t\t\t      const void *key, u32 sz_bytes, u32 key_purpose,\n\t\t\t\t      u32 obj_id, u32 obj_offset)\n{\n\tu32 in[MLX5_ST_SZ_DW(modify_encryption_key_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\tvoid *obj, *param;\n\tint err;\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_MODIFY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_GENERAL_OBJECT_TYPES_ENCRYPTION_KEY);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, obj_id);\n\n\tparam = MLX5_ADDR_OF(general_obj_in_cmd_hdr, in, op_param);\n\tMLX5_SET(general_obj_query_param, param, obj_offset, obj_offset);\n\n\tobj = MLX5_ADDR_OF(modify_encryption_key_in, in, encryption_key_object);\n\tMLX5_SET64(encryption_key_obj, obj, modify_field_select, 1);\n\tMLX5_SET(encryption_key_obj, obj, key_purpose, key_purpose);\n\tMLX5_SET(encryption_key_obj, obj, pd, mdev->mlx5e_res.hw_objs.pdn);\n\n\terr = mlx5_crypto_dek_fill_key(mdev, obj, key, sz_bytes);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\n\t \n\tmemzero_explicit(in, sizeof(in));\n\n\treturn err;\n}\n\nstatic int mlx5_crypto_create_dek_key(struct mlx5_core_dev *mdev,\n\t\t\t\t      const void *key, u32 sz_bytes,\n\t\t\t\t      u32 key_purpose, u32 *p_key_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_encryption_key_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\tu64 general_obj_types;\n\tvoid *obj;\n\tint err;\n\n\tgeneral_obj_types = MLX5_CAP_GEN_64(mdev, general_obj_types);\n\tif (!(general_obj_types &\n\t      MLX5_HCA_CAP_GENERAL_OBJECT_TYPES_ENCRYPTION_KEY))\n\t\treturn -EINVAL;\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_GENERAL_OBJECT_TYPES_ENCRYPTION_KEY);\n\n\tobj = MLX5_ADDR_OF(create_encryption_key_in, in, encryption_key_object);\n\tMLX5_SET(encryption_key_obj, obj, key_purpose, key_purpose);\n\tMLX5_SET(encryption_key_obj, obj, pd, mdev->mlx5e_res.hw_objs.pdn);\n\n\terr = mlx5_crypto_dek_fill_key(mdev, obj, key, sz_bytes);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (!err)\n\t\t*p_key_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\n\t \n\tmemzero_explicit(in, sizeof(in));\n\n\treturn err;\n}\n\nstatic void mlx5_crypto_destroy_dek_key(struct mlx5_core_dev *mdev, u32 key_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_GENERAL_OBJECT_TYPES_ENCRYPTION_KEY);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, key_id);\n\n\tmlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n}\n\nint mlx5_create_encryption_key(struct mlx5_core_dev *mdev,\n\t\t\t       const void *key, u32 sz_bytes,\n\t\t\t       u32 key_type, u32 *p_key_id)\n{\n\treturn mlx5_crypto_create_dek_key(mdev, key, sz_bytes, key_type, p_key_id);\n}\n\nvoid mlx5_destroy_encryption_key(struct mlx5_core_dev *mdev, u32 key_id)\n{\n\tmlx5_crypto_destroy_dek_key(mdev, key_id);\n}\n\nstatic struct mlx5_crypto_dek_bulk *\nmlx5_crypto_dek_bulk_create(struct mlx5_crypto_dek_pool *pool)\n{\n\tstruct mlx5_crypto_dek_priv *dek_priv = pool->mdev->mlx5e_res.dek_priv;\n\tstruct mlx5_core_dev *mdev = pool->mdev;\n\tstruct mlx5_crypto_dek_bulk *bulk;\n\tint num_deks, base_obj_id;\n\tint err;\n\n\tbulk = kzalloc(sizeof(*bulk), GFP_KERNEL);\n\tif (!bulk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnum_deks = 1 << dek_priv->log_dek_obj_range;\n\tbulk->need_sync = bitmap_zalloc(num_deks, GFP_KERNEL);\n\tif (!bulk->need_sync) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tbulk->in_use = bitmap_zalloc(num_deks, GFP_KERNEL);\n\tif (!bulk->in_use) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terr = mlx5_crypto_create_dek_bulk(mdev, pool->key_purpose,\n\t\t\t\t\t  dek_priv->log_dek_obj_range,\n\t\t\t\t\t  &base_obj_id);\n\tif (err)\n\t\tgoto err_out;\n\n\tbulk->base_obj_id = base_obj_id;\n\tbulk->num_deks = num_deks;\n\tbulk->avail_deks = num_deks;\n\tbulk->mdev = mdev;\n\n\treturn bulk;\n\nerr_out:\n\tbitmap_free(bulk->in_use);\n\tbitmap_free(bulk->need_sync);\n\tkfree(bulk);\n\treturn ERR_PTR(err);\n}\n\nstatic struct mlx5_crypto_dek_bulk *\nmlx5_crypto_dek_pool_add_bulk(struct mlx5_crypto_dek_pool *pool)\n{\n\tstruct mlx5_crypto_dek_bulk *bulk;\n\n\tbulk = mlx5_crypto_dek_bulk_create(pool);\n\tif (IS_ERR(bulk))\n\t\treturn bulk;\n\n\tpool->avail_deks += bulk->num_deks;\n\tpool->num_deks += bulk->num_deks;\n\tlist_add(&bulk->entry, &pool->partial_list);\n\n\treturn bulk;\n}\n\nstatic void mlx5_crypto_dek_bulk_free(struct mlx5_crypto_dek_bulk *bulk)\n{\n\tmlx5_crypto_destroy_dek_key(bulk->mdev, bulk->base_obj_id);\n\tbitmap_free(bulk->need_sync);\n\tbitmap_free(bulk->in_use);\n\tkfree(bulk);\n}\n\nstatic void mlx5_crypto_dek_pool_remove_bulk(struct mlx5_crypto_dek_pool *pool,\n\t\t\t\t\t     struct mlx5_crypto_dek_bulk *bulk,\n\t\t\t\t\t     bool delay)\n{\n\tpool->num_deks -= bulk->num_deks;\n\tpool->avail_deks -= bulk->avail_deks;\n\tpool->in_use_deks -= bulk->in_use_deks;\n\tlist_del(&bulk->entry);\n\tif (!delay)\n\t\tmlx5_crypto_dek_bulk_free(bulk);\n}\n\nstatic struct mlx5_crypto_dek_bulk *\nmlx5_crypto_dek_pool_pop(struct mlx5_crypto_dek_pool *pool, u32 *obj_offset)\n{\n\tstruct mlx5_crypto_dek_bulk *bulk;\n\tint pos;\n\n\tmutex_lock(&pool->lock);\n\tbulk = list_first_entry_or_null(&pool->partial_list,\n\t\t\t\t\tstruct mlx5_crypto_dek_bulk, entry);\n\n\tif (bulk) {\n\t\tpos = find_next_zero_bit(bulk->need_sync, bulk->num_deks,\n\t\t\t\t\t bulk->avail_start);\n\t\tif (pos == bulk->num_deks) {\n\t\t\tmlx5_core_err(pool->mdev, \"Wrong DEK bulk avail_start.\\n\");\n\t\t\tpos = find_first_zero_bit(bulk->need_sync, bulk->num_deks);\n\t\t}\n\t\tWARN_ON(pos == bulk->num_deks);\n\t} else {\n\t\tbulk = list_first_entry_or_null(&pool->avail_list,\n\t\t\t\t\t\tstruct mlx5_crypto_dek_bulk,\n\t\t\t\t\t\tentry);\n\t\tif (bulk) {\n\t\t\tlist_move(&bulk->entry, &pool->partial_list);\n\t\t} else {\n\t\t\tbulk = mlx5_crypto_dek_pool_add_bulk(pool);\n\t\t\tif (IS_ERR(bulk))\n\t\t\t\tgoto out;\n\t\t}\n\t\tpos = 0;\n\t}\n\n\t*obj_offset = pos;\n\tbitmap_set(bulk->need_sync, pos, 1);\n\tbitmap_set(bulk->in_use, pos, 1);\n\tbulk->in_use_deks++;\n\tbulk->avail_deks--;\n\tif (!bulk->avail_deks) {\n\t\tlist_move(&bulk->entry, &pool->full_list);\n\t\tbulk->avail_start = bulk->num_deks;\n\t} else {\n\t\tbulk->avail_start = pos + 1;\n\t}\n\tpool->avail_deks--;\n\tpool->in_use_deks++;\n\nout:\n\tmutex_unlock(&pool->lock);\n\treturn bulk;\n}\n\nstatic bool mlx5_crypto_dek_need_sync(struct mlx5_crypto_dek_pool *pool)\n{\n\treturn !pool->syncing &&\n\t       MLX5_CRYPTO_DEK_POOL_CALC_FREED(pool) > MLX5_CRYPTO_DEK_POOL_SYNC_THRESH;\n}\n\nstatic int mlx5_crypto_dek_free_locked(struct mlx5_crypto_dek_pool *pool,\n\t\t\t\t       struct mlx5_crypto_dek *dek)\n{\n\tstruct mlx5_crypto_dek_bulk *bulk = dek->bulk;\n\tint obj_offset;\n\tbool old_val;\n\tint err = 0;\n\n\tobj_offset = dek->obj_id - bulk->base_obj_id;\n\told_val = test_and_clear_bit(obj_offset, bulk->in_use);\n\tWARN_ON_ONCE(!old_val);\n\tif (!old_val) {\n\t\terr = -ENOENT;\n\t\tgoto out_free;\n\t}\n\tpool->in_use_deks--;\n\tbulk->in_use_deks--;\n\tif (!bulk->avail_deks && !bulk->in_use_deks)\n\t\tlist_move(&bulk->entry, &pool->sync_list);\n\n\tif (mlx5_crypto_dek_need_sync(pool) && schedule_work(&pool->sync_work))\n\t\tpool->syncing = true;\n\nout_free:\n\tkfree(dek);\n\treturn err;\n}\n\nstatic int mlx5_crypto_dek_pool_push(struct mlx5_crypto_dek_pool *pool,\n\t\t\t\t     struct mlx5_crypto_dek *dek)\n{\n\tint err = 0;\n\n\tmutex_lock(&pool->lock);\n\tif (pool->syncing)\n\t\tlist_add(&dek->entry, &pool->wait_for_free);\n\telse\n\t\terr = mlx5_crypto_dek_free_locked(pool, dek);\n\tmutex_unlock(&pool->lock);\n\n\treturn err;\n}\n\n \nstatic void mlx5_crypto_dek_bulk_reset_synced(struct mlx5_crypto_dek_pool *pool,\n\t\t\t\t\t      struct mlx5_crypto_dek_bulk *bulk)\n{\n\tunsigned long *need_sync = bulk->need_sync;\n\tunsigned long *in_use = bulk->in_use;\n\tint i, freed, reused, avail_next;\n\tbool first = true;\n\n\tfreed = MLX5_CRYPTO_DEK_BULK_CALC_FREED(bulk);\n\n\tfor (i = 0; freed && i < BITS_TO_LONGS(bulk->num_deks);\n\t\t\ti++, need_sync++, in_use++) {\n\t\treused = hweight_long((*need_sync) ^ (*in_use));\n\t\tif (!reused)\n\t\t\tcontinue;\n\n\t\tbulk->avail_deks += reused;\n\t\tpool->avail_deks += reused;\n\t\t*need_sync = *in_use;\n\t\tif (first) {\n\t\t\tavail_next = i * BITS_PER_TYPE(long);\n\t\t\tif (bulk->avail_start > avail_next)\n\t\t\t\tbulk->avail_start = avail_next;\n\t\t\tfirst = false;\n\t\t}\n\n\t\tfreed -= reused;\n\t}\n}\n\n \nstatic bool mlx5_crypto_dek_bulk_handle_avail(struct mlx5_crypto_dek_pool *pool,\n\t\t\t\t\t      struct mlx5_crypto_dek_bulk *bulk,\n\t\t\t\t\t      struct list_head *destroy_list)\n{\n\tif (list_empty(&pool->avail_list)) {\n\t\tlist_move(&bulk->entry, &pool->avail_list);\n\t\treturn true;\n\t}\n\n\tmlx5_crypto_dek_pool_remove_bulk(pool, bulk, true);\n\tlist_add(&bulk->entry, destroy_list);\n\treturn false;\n}\n\nstatic void mlx5_crypto_dek_pool_splice_destroy_list(struct mlx5_crypto_dek_pool *pool,\n\t\t\t\t\t\t     struct list_head *list,\n\t\t\t\t\t\t     struct list_head *head)\n{\n\tspin_lock(&pool->destroy_lock);\n\tlist_splice_init(list, head);\n\tspin_unlock(&pool->destroy_lock);\n}\n\nstatic void mlx5_crypto_dek_pool_free_wait_keys(struct mlx5_crypto_dek_pool *pool)\n{\n\tstruct mlx5_crypto_dek *dek, *next;\n\n\tlist_for_each_entry_safe(dek, next, &pool->wait_for_free, entry) {\n\t\tlist_del(&dek->entry);\n\t\tmlx5_crypto_dek_free_locked(pool, dek);\n\t}\n}\n\n \nstatic void mlx5_crypto_dek_pool_reset_synced(struct mlx5_crypto_dek_pool *pool)\n{\n\tstruct mlx5_crypto_dek_bulk *bulk, *tmp;\n\tLIST_HEAD(destroy_list);\n\n\tlist_for_each_entry_safe(bulk, tmp, &pool->partial_list, entry) {\n\t\tmlx5_crypto_dek_bulk_reset_synced(pool, bulk);\n\t\tif (MLX5_CRYPTO_DEK_BULK_IDLE(bulk))\n\t\t\tmlx5_crypto_dek_bulk_handle_avail(pool, bulk, &destroy_list);\n\t}\n\n\tlist_for_each_entry_safe(bulk, tmp, &pool->full_list, entry) {\n\t\tmlx5_crypto_dek_bulk_reset_synced(pool, bulk);\n\n\t\tif (!bulk->avail_deks)\n\t\t\tcontinue;\n\n\t\tif (MLX5_CRYPTO_DEK_BULK_IDLE(bulk))\n\t\t\tmlx5_crypto_dek_bulk_handle_avail(pool, bulk, &destroy_list);\n\t\telse\n\t\t\tlist_move(&bulk->entry, &pool->partial_list);\n\t}\n\n\tlist_for_each_entry_safe(bulk, tmp, &pool->sync_list, entry) {\n\t\tbulk->avail_deks = bulk->num_deks;\n\t\tpool->avail_deks += bulk->num_deks;\n\t\tif (mlx5_crypto_dek_bulk_handle_avail(pool, bulk, &destroy_list)) {\n\t\t\tmemset(bulk->need_sync, 0, BITS_TO_BYTES(bulk->num_deks));\n\t\t\tbulk->avail_start = 0;\n\t\t}\n\t}\n\n\tmlx5_crypto_dek_pool_free_wait_keys(pool);\n\n\tif (!list_empty(&destroy_list)) {\n\t\tmlx5_crypto_dek_pool_splice_destroy_list(pool, &destroy_list,\n\t\t\t\t\t\t\t &pool->destroy_list);\n\t\tschedule_work(&pool->destroy_work);\n\t}\n}\n\nstatic void mlx5_crypto_dek_sync_work_fn(struct work_struct *work)\n{\n\tstruct mlx5_crypto_dek_pool *pool =\n\t\tcontainer_of(work, struct mlx5_crypto_dek_pool, sync_work);\n\tint err;\n\n\terr = mlx5_crypto_cmd_sync_crypto(pool->mdev, BIT(pool->key_purpose));\n\tmutex_lock(&pool->lock);\n\tif (!err)\n\t\tmlx5_crypto_dek_pool_reset_synced(pool);\n\tpool->syncing = false;\n\tmutex_unlock(&pool->lock);\n}\n\nstruct mlx5_crypto_dek *mlx5_crypto_dek_create(struct mlx5_crypto_dek_pool *dek_pool,\n\t\t\t\t\t       const void *key, u32 sz_bytes)\n{\n\tstruct mlx5_crypto_dek_priv *dek_priv = dek_pool->mdev->mlx5e_res.dek_priv;\n\tstruct mlx5_core_dev *mdev = dek_pool->mdev;\n\tu32 key_purpose = dek_pool->key_purpose;\n\tstruct mlx5_crypto_dek_bulk *bulk;\n\tstruct mlx5_crypto_dek *dek;\n\tint obj_offset;\n\tint err;\n\n\tdek = kzalloc(sizeof(*dek), GFP_KERNEL);\n\tif (!dek)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!dek_priv) {\n\t\terr = mlx5_crypto_create_dek_key(mdev, key, sz_bytes,\n\t\t\t\t\t\t key_purpose, &dek->obj_id);\n\t\tgoto out;\n\t}\n\n\tbulk = mlx5_crypto_dek_pool_pop(dek_pool, &obj_offset);\n\tif (IS_ERR(bulk)) {\n\t\terr = PTR_ERR(bulk);\n\t\tgoto out;\n\t}\n\n\tdek->bulk = bulk;\n\tdek->obj_id = bulk->base_obj_id + obj_offset;\n\terr = mlx5_crypto_modify_dek_key(mdev, key, sz_bytes, key_purpose,\n\t\t\t\t\t bulk->base_obj_id, obj_offset);\n\tif (err) {\n\t\tmlx5_crypto_dek_pool_push(dek_pool, dek);\n\t\treturn ERR_PTR(err);\n\t}\n\nout:\n\tif (err) {\n\t\tkfree(dek);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn dek;\n}\n\nvoid mlx5_crypto_dek_destroy(struct mlx5_crypto_dek_pool *dek_pool,\n\t\t\t     struct mlx5_crypto_dek *dek)\n{\n\tstruct mlx5_crypto_dek_priv *dek_priv = dek_pool->mdev->mlx5e_res.dek_priv;\n\tstruct mlx5_core_dev *mdev = dek_pool->mdev;\n\n\tif (!dek_priv) {\n\t\tmlx5_crypto_destroy_dek_key(mdev, dek->obj_id);\n\t\tkfree(dek);\n\t} else {\n\t\tmlx5_crypto_dek_pool_push(dek_pool, dek);\n\t}\n}\n\nstatic void mlx5_crypto_dek_free_destroy_list(struct list_head *destroy_list)\n{\n\tstruct mlx5_crypto_dek_bulk *bulk, *tmp;\n\n\tlist_for_each_entry_safe(bulk, tmp, destroy_list, entry)\n\t\tmlx5_crypto_dek_bulk_free(bulk);\n}\n\nstatic void mlx5_crypto_dek_destroy_work_fn(struct work_struct *work)\n{\n\tstruct mlx5_crypto_dek_pool *pool =\n\t\tcontainer_of(work, struct mlx5_crypto_dek_pool, destroy_work);\n\tLIST_HEAD(destroy_list);\n\n\tmlx5_crypto_dek_pool_splice_destroy_list(pool, &pool->destroy_list,\n\t\t\t\t\t\t &destroy_list);\n\tmlx5_crypto_dek_free_destroy_list(&destroy_list);\n}\n\nstruct mlx5_crypto_dek_pool *\nmlx5_crypto_dek_pool_create(struct mlx5_core_dev *mdev, int key_purpose)\n{\n\tstruct mlx5_crypto_dek_pool *pool;\n\n\tpool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpool->mdev = mdev;\n\tpool->key_purpose = key_purpose;\n\n\tmutex_init(&pool->lock);\n\tINIT_LIST_HEAD(&pool->avail_list);\n\tINIT_LIST_HEAD(&pool->partial_list);\n\tINIT_LIST_HEAD(&pool->full_list);\n\tINIT_LIST_HEAD(&pool->sync_list);\n\tINIT_LIST_HEAD(&pool->wait_for_free);\n\tINIT_WORK(&pool->sync_work, mlx5_crypto_dek_sync_work_fn);\n\tspin_lock_init(&pool->destroy_lock);\n\tINIT_LIST_HEAD(&pool->destroy_list);\n\tINIT_WORK(&pool->destroy_work, mlx5_crypto_dek_destroy_work_fn);\n\n\treturn pool;\n}\n\nvoid mlx5_crypto_dek_pool_destroy(struct mlx5_crypto_dek_pool *pool)\n{\n\tstruct mlx5_crypto_dek_bulk *bulk, *tmp;\n\n\tcancel_work_sync(&pool->sync_work);\n\tcancel_work_sync(&pool->destroy_work);\n\n\tmlx5_crypto_dek_pool_free_wait_keys(pool);\n\n\tlist_for_each_entry_safe(bulk, tmp, &pool->avail_list, entry)\n\t\tmlx5_crypto_dek_pool_remove_bulk(pool, bulk, false);\n\n\tlist_for_each_entry_safe(bulk, tmp, &pool->full_list, entry)\n\t\tmlx5_crypto_dek_pool_remove_bulk(pool, bulk, false);\n\n\tlist_for_each_entry_safe(bulk, tmp, &pool->sync_list, entry)\n\t\tmlx5_crypto_dek_pool_remove_bulk(pool, bulk, false);\n\n\tlist_for_each_entry_safe(bulk, tmp, &pool->partial_list, entry)\n\t\tmlx5_crypto_dek_pool_remove_bulk(pool, bulk, false);\n\n\tmlx5_crypto_dek_free_destroy_list(&pool->destroy_list);\n\n\tmutex_destroy(&pool->lock);\n\n\tkfree(pool);\n}\n\nvoid mlx5_crypto_dek_cleanup(struct mlx5_crypto_dek_priv *dek_priv)\n{\n\tif (!dek_priv)\n\t\treturn;\n\n\tkfree(dek_priv);\n}\n\nstruct mlx5_crypto_dek_priv *mlx5_crypto_dek_init(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_crypto_dek_priv *dek_priv;\n\tint err;\n\n\tif (!MLX5_CAP_CRYPTO(mdev, log_dek_max_alloc))\n\t\treturn NULL;\n\n\tdek_priv = kzalloc(sizeof(*dek_priv), GFP_KERNEL);\n\tif (!dek_priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdek_priv->mdev = mdev;\n\tdek_priv->log_dek_obj_range = min_t(int, 12,\n\t\t\t\t\t    MLX5_CAP_CRYPTO(mdev, log_dek_max_alloc));\n\n\t \n\terr = mlx5_crypto_cmd_sync_crypto(mdev, MLX5_CRYPTO_DEK_ALL_TYPE);\n\tif (err)\n\t\tgoto err_sync_crypto;\n\n\tmlx5_core_dbg(mdev, \"Crypto DEK enabled, %d deks per alloc (max %d), total %d\\n\",\n\t\t      1 << dek_priv->log_dek_obj_range,\n\t\t      1 << MLX5_CAP_CRYPTO(mdev, log_dek_max_alloc),\n\t\t      1 << MLX5_CAP_CRYPTO(mdev, log_max_num_deks));\n\n\treturn dek_priv;\n\nerr_sync_crypto:\n\tkfree(dek_priv);\n\treturn ERR_PTR(err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}