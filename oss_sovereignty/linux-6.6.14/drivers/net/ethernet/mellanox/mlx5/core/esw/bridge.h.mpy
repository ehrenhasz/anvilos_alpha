{
  "module_name": "bridge.h",
  "hash_id": "16d560fb2d513a0cf747a0fbd20c41f5e2eda94020e10e2b3214ffe04b6a6dc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h",
  "human_readable_source": " \n \n\n#ifndef __MLX5_ESW_BRIDGE_H__\n#define __MLX5_ESW_BRIDGE_H__\n\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/xarray.h>\n#include \"eswitch.h\"\n\nstruct dentry;\nstruct mlx5_flow_table;\nstruct mlx5_flow_group;\n\nstruct mlx5_esw_bridge_offloads {\n\tstruct mlx5_eswitch *esw;\n\tstruct list_head bridges;\n\tstruct xarray ports;\n\tstruct dentry *debugfs_root;\n\n\tstruct notifier_block netdev_nb;\n\tstruct notifier_block nb_blk;\n\tstruct notifier_block nb;\n\tstruct workqueue_struct *wq;\n\tstruct delayed_work update_work;\n\n\tstruct mlx5_flow_table *ingress_ft;\n\tstruct mlx5_flow_group *ingress_igmp_fg;\n\tstruct mlx5_flow_group *ingress_mld_fg;\n\tstruct mlx5_flow_group *ingress_vlan_fg;\n\tstruct mlx5_flow_group *ingress_vlan_filter_fg;\n\tstruct mlx5_flow_group *ingress_qinq_fg;\n\tstruct mlx5_flow_group *ingress_qinq_filter_fg;\n\tstruct mlx5_flow_group *ingress_mac_fg;\n\n\tstruct mlx5_flow_handle *igmp_handle;\n\tstruct mlx5_flow_handle *mld_query_handle;\n\tstruct mlx5_flow_handle *mld_report_handle;\n\tstruct mlx5_flow_handle *mld_done_handle;\n\n\tstruct mlx5_flow_table *skip_ft;\n};\n\nstruct mlx5_esw_bridge_offloads *mlx5_esw_bridge_init(struct mlx5_eswitch *esw);\nvoid mlx5_esw_bridge_cleanup(struct mlx5_eswitch *esw);\nint mlx5_esw_bridge_vport_link(struct net_device *br_netdev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t       struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t       struct netlink_ext_ack *extack);\nint mlx5_esw_bridge_vport_unlink(struct net_device *br_netdev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t struct netlink_ext_ack *extack);\nint mlx5_esw_bridge_vport_peer_link(struct net_device *br_netdev, u16 vport_num,\n\t\t\t\t    u16 esw_owner_vhca_id,\n\t\t\t\t    struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t    struct netlink_ext_ack *extack);\nint mlx5_esw_bridge_vport_peer_unlink(struct net_device *br_netdev, u16 vport_num,\n\t\t\t\t      u16 esw_owner_vhca_id,\n\t\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t      struct netlink_ext_ack *extack);\nvoid mlx5_esw_bridge_fdb_update_used(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t     struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t     struct switchdev_notifier_fdb_info *fdb_info);\nvoid mlx5_esw_bridge_fdb_mark_deleted(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t      struct switchdev_notifier_fdb_info *fdb_info);\nvoid mlx5_esw_bridge_fdb_create(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\tstruct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\tstruct switchdev_notifier_fdb_info *fdb_info);\nvoid mlx5_esw_bridge_fdb_remove(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\tstruct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\tstruct switchdev_notifier_fdb_info *fdb_info);\nvoid mlx5_esw_bridge_update(struct mlx5_esw_bridge_offloads *br_offloads);\nint mlx5_esw_bridge_ageing_time_set(u16 vport_num, u16 esw_owner_vhca_id, unsigned long ageing_time,\n\t\t\t\t    struct mlx5_esw_bridge_offloads *br_offloads);\nint mlx5_esw_bridge_vlan_filtering_set(u16 vport_num, u16 esw_owner_vhca_id, bool enable,\n\t\t\t\t       struct mlx5_esw_bridge_offloads *br_offloads);\nint mlx5_esw_bridge_vlan_proto_set(u16 vport_num, u16 esw_owner_vhca_id, u16 proto,\n\t\t\t\t   struct mlx5_esw_bridge_offloads *br_offloads);\nint mlx5_esw_bridge_mcast_set(u16 vport_num, u16 esw_owner_vhca_id, bool enable,\n\t\t\t      struct mlx5_esw_bridge_offloads *br_offloads);\nint mlx5_esw_bridge_port_vlan_add(u16 vport_num, u16 esw_owner_vhca_id, u16 vid, u16 flags,\n\t\t\t\t  struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t  struct netlink_ext_ack *extack);\nvoid mlx5_esw_bridge_port_vlan_del(u16 vport_num, u16 esw_owner_vhca_id, u16 vid,\n\t\t\t\t   struct mlx5_esw_bridge_offloads *br_offloads);\n\nint mlx5_esw_bridge_port_mdb_add(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t\t struct mlx5_esw_bridge_offloads *br_offloads,\n\t\t\t\t struct netlink_ext_ack *extack);\nvoid mlx5_esw_bridge_port_mdb_del(struct net_device *dev, u16 vport_num, u16 esw_owner_vhca_id,\n\t\t\t\t  const unsigned char *addr, u16 vid,\n\t\t\t\t  struct mlx5_esw_bridge_offloads *br_offloads);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}