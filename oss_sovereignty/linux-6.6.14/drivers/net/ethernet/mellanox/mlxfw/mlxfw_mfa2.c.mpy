{
  "module_name": "mlxfw_mfa2.c",
  "hash_id": "fb18406aea116c4fa8eb0d9318020a84ee00123616bea79ead8638ca2a3159d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxfw/mlxfw_mfa2.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"mlxfw_mfa2: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/vmalloc.h>\n#include <linux/xz.h>\n#include \"mlxfw_mfa2.h\"\n#include \"mlxfw_mfa2_file.h\"\n#include \"mlxfw_mfa2_tlv.h\"\n#include \"mlxfw_mfa2_format.h\"\n#include \"mlxfw_mfa2_tlv_multi.h\"\n\n \n\nstatic const u8 mlxfw_mfa2_fingerprint[] = \"MLNX.MFA2.XZ.00!\";\nstatic const int mlxfw_mfa2_fingerprint_len =\n\t\t\tsizeof(mlxfw_mfa2_fingerprint) - 1;\n\nstatic const u8 mlxfw_mfa2_comp_magic[] = \"#BIN.COMPONENT!#\";\nstatic const int mlxfw_mfa2_comp_magic_len = sizeof(mlxfw_mfa2_comp_magic) - 1;\n\nbool mlxfw_mfa2_check(const struct firmware *fw)\n{\n\tif (fw->size < sizeof(mlxfw_mfa2_fingerprint))\n\t\treturn false;\n\n\treturn memcmp(fw->data, mlxfw_mfa2_fingerprint,\n\t\t      mlxfw_mfa2_fingerprint_len) == 0;\n}\n\nstatic bool\nmlxfw_mfa2_tlv_multi_validate(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t      const struct mlxfw_mfa2_tlv_multi *multi)\n{\n\tconst struct mlxfw_mfa2_tlv *tlv;\n\tu16 idx;\n\n\t \n\tmlxfw_mfa2_tlv_multi_foreach(mfa2_file, tlv, idx, multi) {\n\t\tif (!tlv) {\n\t\t\tpr_err(\"Multi has invalid child\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool\nmlxfw_mfa2_file_dev_validate(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t     const struct mlxfw_mfa2_tlv *dev_tlv,\n\t\t\t     u16 dev_idx)\n{\n\tconst struct mlxfw_mfa2_tlv_component_ptr *cptr;\n\tconst struct mlxfw_mfa2_tlv_multi *multi;\n\tconst struct mlxfw_mfa2_tlv_psid *psid;\n\tconst struct mlxfw_mfa2_tlv *tlv;\n\tu16 cptr_count;\n\tu16 cptr_idx;\n\tint err;\n\n\tpr_debug(\"Device %d\\n\", dev_idx);\n\n\tmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, dev_tlv);\n\tif (!multi) {\n\t\tpr_err(\"Device %d is not a valid TLV error\\n\", dev_idx);\n\t\treturn false;\n\t}\n\n\tif (!mlxfw_mfa2_tlv_multi_validate(mfa2_file, multi))\n\t\treturn false;\n\n\t \n\ttlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, multi,\n\t\t\t\t\t      MLXFW_MFA2_TLV_PSID, 0);\n\tif (!tlv) {\n\t\tpr_err(\"Device %d does not have PSID\\n\", dev_idx);\n\t\treturn false;\n\t}\n\n\tpsid = mlxfw_mfa2_tlv_psid_get(mfa2_file, tlv);\n\tif (!psid) {\n\t\tpr_err(\"Device %d PSID TLV is not valid\\n\", dev_idx);\n\t\treturn false;\n\t}\n\n\tprint_hex_dump_debug(\"  -- Device PSID \", DUMP_PREFIX_NONE, 16, 16,\n\t\t\t     psid->psid, be16_to_cpu(tlv->len), true);\n\n\t \n\terr = mlxfw_mfa2_tlv_multi_child_count(mfa2_file, multi,\n\t\t\t\t\t       MLXFW_MFA2_TLV_COMPONENT_PTR,\n\t\t\t\t\t       &cptr_count);\n\tif (err)\n\t\treturn false;\n\n\tif (cptr_count == 0) {\n\t\tpr_err(\"Device %d has no components\\n\", dev_idx);\n\t\treturn false;\n\t}\n\n\tfor (cptr_idx = 0; cptr_idx < cptr_count; cptr_idx++) {\n\t\ttlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, multi,\n\t\t\t\t\t\t      MLXFW_MFA2_TLV_COMPONENT_PTR,\n\t\t\t\t\t\t      cptr_idx);\n\t\tif (!tlv)\n\t\t\treturn false;\n\n\t\tcptr = mlxfw_mfa2_tlv_component_ptr_get(mfa2_file, tlv);\n\t\tif (!cptr) {\n\t\t\tpr_err(\"Device %d COMPONENT_PTR TLV is not valid\\n\",\n\t\t\t       dev_idx);\n\t\t\treturn false;\n\t\t}\n\n\t\tpr_debug(\"  -- Component index %d\\n\",\n\t\t\t be16_to_cpu(cptr->component_index));\n\t}\n\treturn true;\n}\n\nstatic bool\nmlxfw_mfa2_file_comp_validate(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t      const struct mlxfw_mfa2_tlv *comp_tlv,\n\t\t\t      u16 comp_idx)\n{\n\tconst struct mlxfw_mfa2_tlv_component_descriptor *cdesc;\n\tconst struct mlxfw_mfa2_tlv_multi *multi;\n\tconst struct mlxfw_mfa2_tlv *tlv;\n\n\tpr_debug(\"Component %d\\n\", comp_idx);\n\n\tmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, comp_tlv);\n\tif (!multi) {\n\t\tpr_err(\"Component %d is not a valid TLV error\\n\", comp_idx);\n\t\treturn false;\n\t}\n\n\tif (!mlxfw_mfa2_tlv_multi_validate(mfa2_file, multi))\n\t\treturn false;\n\n\t \n\ttlv = mlxfw_mfa2_tlv_multi_child(mfa2_file, multi);\n\tif (!tlv) {\n\t\tpr_err(\"Component descriptor %d multi TLV error\\n\", comp_idx);\n\t\treturn false;\n\t}\n\n\tcdesc = mlxfw_mfa2_tlv_component_descriptor_get(mfa2_file, tlv);\n\tif (!cdesc) {\n\t\tpr_err(\"Component %d does not have a valid descriptor\\n\",\n\t\t       comp_idx);\n\t\treturn false;\n\t}\n\tpr_debug(\"  -- Component type %d\\n\", be16_to_cpu(cdesc->identifier));\n\tpr_debug(\"  -- Offset 0x%llx and size %d\\n\",\n\t\t ((u64) be32_to_cpu(cdesc->cb_offset_h) << 32)\n\t\t | be32_to_cpu(cdesc->cb_offset_l), be32_to_cpu(cdesc->size));\n\n\treturn true;\n}\n\nstatic bool mlxfw_mfa2_file_validate(const struct mlxfw_mfa2_file *mfa2_file)\n{\n\tconst struct mlxfw_mfa2_tlv *tlv;\n\tu16 idx;\n\n\tpr_debug(\"Validating file\\n\");\n\n\t \n\tmlxfw_mfa2_tlv_foreach(mfa2_file, tlv, idx, mfa2_file->first_dev,\n\t\t\t       mfa2_file->dev_count) {\n\t\tif (!tlv) {\n\t\t\tpr_err(\"Device TLV error\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (!mlxfw_mfa2_file_dev_validate(mfa2_file, tlv, idx))\n\t\t\treturn false;\n\t}\n\n\t \n\tmlxfw_mfa2_tlv_foreach(mfa2_file, tlv, idx, mfa2_file->first_component,\n\t\t\t       mfa2_file->component_count) {\n\t\tif (!tlv) {\n\t\t\tpr_err(\"Device TLV error\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (!mlxfw_mfa2_file_comp_validate(mfa2_file, tlv, idx))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct mlxfw_mfa2_file *mlxfw_mfa2_file_init(const struct firmware *fw)\n{\n\tconst struct mlxfw_mfa2_tlv_package_descriptor *pd;\n\tconst struct mlxfw_mfa2_tlv_multi *multi;\n\tconst struct mlxfw_mfa2_tlv *multi_child;\n\tconst struct mlxfw_mfa2_tlv *first_tlv;\n\tstruct mlxfw_mfa2_file *mfa2_file;\n\tconst void *first_tlv_ptr;\n\tconst void *cb_top_ptr;\n\n\tmfa2_file = kzalloc(sizeof(*mfa2_file), GFP_KERNEL);\n\tif (!mfa2_file)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmfa2_file->fw = fw;\n\tfirst_tlv_ptr = fw->data + NLA_ALIGN(mlxfw_mfa2_fingerprint_len);\n\tfirst_tlv = mlxfw_mfa2_tlv_get(mfa2_file, first_tlv_ptr);\n\tif (!first_tlv) {\n\t\tpr_err(\"Could not parse package descriptor TLV\\n\");\n\t\tgoto err_out;\n\t}\n\n\tmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, first_tlv);\n\tif (!multi) {\n\t\tpr_err(\"First TLV is not of valid multi type\\n\");\n\t\tgoto err_out;\n\t}\n\n\tmulti_child = mlxfw_mfa2_tlv_multi_child(mfa2_file, multi);\n\tif (!multi_child)\n\t\tgoto err_out;\n\n\tpd = mlxfw_mfa2_tlv_package_descriptor_get(mfa2_file, multi_child);\n\tif (!pd) {\n\t\tpr_err(\"Could not parse package descriptor TLV\\n\");\n\t\tgoto err_out;\n\t}\n\n\tmfa2_file->first_dev = mlxfw_mfa2_tlv_next(mfa2_file, first_tlv);\n\tif (!mfa2_file->first_dev) {\n\t\tpr_err(\"First device TLV is not valid\\n\");\n\t\tgoto err_out;\n\t}\n\n\tmfa2_file->dev_count = be16_to_cpu(pd->num_devices);\n\tmfa2_file->first_component = mlxfw_mfa2_tlv_advance(mfa2_file,\n\t\t\t\t\t\t\t    mfa2_file->first_dev,\n\t\t\t\t\t\t\t    mfa2_file->dev_count);\n\tmfa2_file->component_count = be16_to_cpu(pd->num_components);\n\tmfa2_file->cb = fw->data + NLA_ALIGN(be32_to_cpu(pd->cb_offset));\n\tif (!mlxfw_mfa2_valid_ptr(mfa2_file, mfa2_file->cb)) {\n\t\tpr_err(\"Component block is out side the file\\n\");\n\t\tgoto err_out;\n\t}\n\tmfa2_file->cb_archive_size = be32_to_cpu(pd->cb_archive_size);\n\tcb_top_ptr = mfa2_file->cb + mfa2_file->cb_archive_size - 1;\n\tif (!mlxfw_mfa2_valid_ptr(mfa2_file, cb_top_ptr)) {\n\t\tpr_err(\"Component block size is too big\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (!mlxfw_mfa2_file_validate(mfa2_file))\n\t\tgoto err_out;\n\treturn mfa2_file;\nerr_out:\n\tkfree(mfa2_file);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic const struct mlxfw_mfa2_tlv_multi *\nmlxfw_mfa2_tlv_dev_get(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t       const char *psid, u16 psid_size)\n{\n\tconst struct mlxfw_mfa2_tlv_psid *tlv_psid;\n\tconst struct mlxfw_mfa2_tlv_multi *dev_multi;\n\tconst struct mlxfw_mfa2_tlv *dev_tlv;\n\tconst struct mlxfw_mfa2_tlv *tlv;\n\tu32 idx;\n\n\t \n\tmlxfw_mfa2_tlv_foreach(mfa2_file, dev_tlv, idx, mfa2_file->first_dev,\n\t\t\t       mfa2_file->dev_count) {\n\t\tif (!dev_tlv)\n\t\t\treturn NULL;\n\n\t\tdev_multi = mlxfw_mfa2_tlv_multi_get(mfa2_file, dev_tlv);\n\t\tif (!dev_multi)\n\t\t\treturn NULL;\n\n\t\t \n\t\ttlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, dev_multi,\n\t\t\t\t\t\t      MLXFW_MFA2_TLV_PSID, 0);\n\t\tif (!tlv)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(tlv->len) != psid_size)\n\t\t\tcontinue;\n\n\t\ttlv_psid = mlxfw_mfa2_tlv_psid_get(mfa2_file, tlv);\n\t\tif (!tlv_psid)\n\t\t\treturn NULL;\n\n\t\tif (memcmp(psid, tlv_psid->psid, psid_size) == 0)\n\t\t\treturn dev_multi;\n\t}\n\n\treturn NULL;\n}\n\nint mlxfw_mfa2_file_component_count(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t\t    const char *psid, u32 psid_size,\n\t\t\t\t    u32 *p_count)\n{\n\tconst struct mlxfw_mfa2_tlv_multi *dev_multi;\n\tu16 count;\n\tint err;\n\n\tdev_multi = mlxfw_mfa2_tlv_dev_get(mfa2_file, psid, psid_size);\n\tif (!dev_multi)\n\t\treturn -EINVAL;\n\n\terr = mlxfw_mfa2_tlv_multi_child_count(mfa2_file, dev_multi,\n\t\t\t\t\t       MLXFW_MFA2_TLV_COMPONENT_PTR,\n\t\t\t\t\t       &count);\n\tif (err)\n\t\treturn err;\n\n\t*p_count = count;\n\treturn 0;\n}\n\nstatic int mlxfw_mfa2_xz_dec_run(struct xz_dec *xz_dec, struct xz_buf *xz_buf,\n\t\t\t\t bool *finished)\n{\n\tenum xz_ret xz_ret;\n\n\txz_ret = xz_dec_run(xz_dec, xz_buf);\n\n\tswitch (xz_ret) {\n\tcase XZ_STREAM_END:\n\t\t*finished = true;\n\t\treturn 0;\n\tcase XZ_OK:\n\t\t*finished = false;\n\t\treturn 0;\n\tcase XZ_MEM_ERROR:\n\t\tpr_err(\"xz no memory\\n\");\n\t\treturn -ENOMEM;\n\tcase XZ_DATA_ERROR:\n\t\tpr_err(\"xz file corrupted\\n\");\n\t\treturn -EINVAL;\n\tcase XZ_FORMAT_ERROR:\n\t\tpr_err(\"xz format not found\\n\");\n\t\treturn -EINVAL;\n\tcase XZ_OPTIONS_ERROR:\n\t\tpr_err(\"unsupported xz option\\n\");\n\t\treturn -EINVAL;\n\tcase XZ_MEMLIMIT_ERROR:\n\t\tpr_err(\"xz dictionary too small\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\tpr_err(\"xz error %d\\n\", xz_ret);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mlxfw_mfa2_file_cb_offset_xz(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t\t\toff_t off, size_t size, u8 *buf)\n{\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf dec_buf;\n\toff_t curr_off = 0;\n\tbool finished;\n\tint err;\n\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32) -1);\n\tif (!xz_dec)\n\t\treturn -EINVAL;\n\n\tdec_buf.in_size = mfa2_file->cb_archive_size;\n\tdec_buf.in = mfa2_file->cb;\n\tdec_buf.in_pos = 0;\n\tdec_buf.out = buf;\n\n\t \n\tdo {\n\t\tdec_buf.out_pos = 0;\n\t\tdec_buf.out_size = min_t(size_t, size, off - curr_off);\n\t\tif (dec_buf.out_size == 0)\n\t\t\tbreak;\n\n\t\terr = mlxfw_mfa2_xz_dec_run(xz_dec, &dec_buf, &finished);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (finished) {\n\t\t\tpr_err(\"xz section too short\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr_off += dec_buf.out_pos;\n\t} while (curr_off != off);\n\n\t \n\tdec_buf.out_pos = 0;\n\tdec_buf.out_size = size;\n\terr = mlxfw_mfa2_xz_dec_run(xz_dec, &dec_buf, &finished);\nout:\n\txz_dec_end(xz_dec);\n\treturn err;\n}\n\nstatic const struct mlxfw_mfa2_tlv_component_descriptor *\nmlxfw_mfa2_file_component_tlv_get(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t\t  u16 comp_index)\n{\n\tconst struct mlxfw_mfa2_tlv_multi *multi;\n\tconst struct mlxfw_mfa2_tlv *multi_child;\n\tconst struct mlxfw_mfa2_tlv *comp_tlv;\n\n\tif (comp_index > mfa2_file->component_count)\n\t\treturn NULL;\n\n\tcomp_tlv = mlxfw_mfa2_tlv_advance(mfa2_file, mfa2_file->first_component,\n\t\t\t\t\t  comp_index);\n\tif (!comp_tlv)\n\t\treturn NULL;\n\n\tmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, comp_tlv);\n\tif (!multi)\n\t\treturn NULL;\n\n\tmulti_child = mlxfw_mfa2_tlv_multi_child(mfa2_file, multi);\n\tif (!multi_child)\n\t\treturn NULL;\n\n\treturn mlxfw_mfa2_tlv_component_descriptor_get(mfa2_file, multi_child);\n}\n\nstruct mlxfw_mfa2_comp_data {\n\tstruct mlxfw_mfa2_component comp;\n\tu8 buff[];\n};\n\nstatic const struct mlxfw_mfa2_tlv_component_descriptor *\nmlxfw_mfa2_file_component_find(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t       const char *psid, int psid_size,\n\t\t\t       int component_index)\n{\n\tconst struct mlxfw_mfa2_tlv_component_ptr *cptr;\n\tconst struct mlxfw_mfa2_tlv_multi *dev_multi;\n\tconst struct mlxfw_mfa2_tlv *cptr_tlv;\n\tu16 comp_idx;\n\n\tdev_multi = mlxfw_mfa2_tlv_dev_get(mfa2_file, psid, psid_size);\n\tif (!dev_multi)\n\t\treturn NULL;\n\n\tcptr_tlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, dev_multi,\n\t\t\t\t\t\t   MLXFW_MFA2_TLV_COMPONENT_PTR,\n\t\t\t\t\t\t   component_index);\n\tif (!cptr_tlv)\n\t\treturn NULL;\n\n\tcptr = mlxfw_mfa2_tlv_component_ptr_get(mfa2_file, cptr_tlv);\n\tif (!cptr)\n\t\treturn NULL;\n\n\tcomp_idx = be16_to_cpu(cptr->component_index);\n\treturn mlxfw_mfa2_file_component_tlv_get(mfa2_file, comp_idx);\n}\n\nstruct mlxfw_mfa2_component *\nmlxfw_mfa2_file_component_get(const struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t      const char *psid, int psid_size,\n\t\t\t      int component_index)\n{\n\tconst struct mlxfw_mfa2_tlv_component_descriptor *comp;\n\tstruct mlxfw_mfa2_comp_data *comp_data;\n\tu32 comp_buf_size;\n\toff_t cb_offset;\n\tu32 comp_size;\n\tint err;\n\n\tcomp = mlxfw_mfa2_file_component_find(mfa2_file, psid, psid_size,\n\t\t\t\t\t      component_index);\n\tif (!comp)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcb_offset = (u64) be32_to_cpu(comp->cb_offset_h) << 32 |\n\t\t    be32_to_cpu(comp->cb_offset_l);\n\tcomp_size = be32_to_cpu(comp->size);\n\tcomp_buf_size = comp_size + mlxfw_mfa2_comp_magic_len;\n\n\tcomp_data = vzalloc(sizeof(*comp_data) + comp_buf_size);\n\tif (!comp_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcomp_data->comp.data_size = comp_size;\n\tcomp_data->comp.index = be16_to_cpu(comp->identifier);\n\terr = mlxfw_mfa2_file_cb_offset_xz(mfa2_file, cb_offset, comp_buf_size,\n\t\t\t\t\t   comp_data->buff);\n\tif (err) {\n\t\tpr_err(\"Component could not be reached in CB\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (memcmp(comp_data->buff, mlxfw_mfa2_comp_magic,\n\t\t   mlxfw_mfa2_comp_magic_len) != 0) {\n\t\tpr_err(\"Component has wrong magic\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tcomp_data->comp.data = comp_data->buff + mlxfw_mfa2_comp_magic_len;\n\treturn &comp_data->comp;\nerr_out:\n\tvfree(comp_data);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxfw_mfa2_file_component_put(struct mlxfw_mfa2_component *comp)\n{\n\tconst struct mlxfw_mfa2_comp_data *comp_data;\n\n\tcomp_data = container_of(comp, struct mlxfw_mfa2_comp_data, comp);\n\tvfree(comp_data);\n}\n\nvoid mlxfw_mfa2_file_fini(struct mlxfw_mfa2_file *mfa2_file)\n{\n\tkfree(mfa2_file);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}