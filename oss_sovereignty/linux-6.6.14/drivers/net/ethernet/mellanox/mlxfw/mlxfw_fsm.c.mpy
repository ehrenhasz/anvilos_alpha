{
  "module_name": "mlxfw_fsm.c",
  "hash_id": "b92b68ea17c84669df1abaa8c1a5d4b6e861e0a2fe6f9510e9db848c56358482",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxfw/mlxfw_fsm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"mlxfw: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\n#include \"mlxfw.h\"\n#include \"mlxfw_mfa2.h\"\n\n#define MLXFW_FSM_STATE_WAIT_CYCLE_MS 200\n#define MLXFW_FSM_STATE_WAIT_TIMEOUT_MS 30000\n#define MLXFW_FSM_STATE_WAIT_ROUNDS \\\n\t(MLXFW_FSM_STATE_WAIT_TIMEOUT_MS / MLXFW_FSM_STATE_WAIT_CYCLE_MS)\n#define MLXFW_FSM_MAX_COMPONENT_SIZE (10 * (1 << 20))\n\nstatic const int mlxfw_fsm_state_errno[] = {\n\t[MLXFW_FSM_STATE_ERR_ERROR] = -EIO,\n\t[MLXFW_FSM_STATE_ERR_REJECTED_DIGEST_ERR] = -EBADMSG,\n\t[MLXFW_FSM_STATE_ERR_REJECTED_NOT_APPLICABLE] = -ENOENT,\n\t[MLXFW_FSM_STATE_ERR_REJECTED_UNKNOWN_KEY] = -ENOKEY,\n\t[MLXFW_FSM_STATE_ERR_REJECTED_AUTH_FAILED] = -EACCES,\n\t[MLXFW_FSM_STATE_ERR_REJECTED_UNSIGNED] = -EKEYREVOKED,\n\t[MLXFW_FSM_STATE_ERR_REJECTED_KEY_NOT_APPLICABLE] = -EKEYREJECTED,\n\t[MLXFW_FSM_STATE_ERR_REJECTED_BAD_FORMAT] = -ENOEXEC,\n\t[MLXFW_FSM_STATE_ERR_BLOCKED_PENDING_RESET] = -EBUSY,\n\t[MLXFW_FSM_STATE_ERR_MAX] = -EINVAL\n};\n\n#define MLXFW_ERR_PRFX \"Firmware flash failed: \"\n#define MLXFW_ERR_MSG(fwdev, extack, msg, err) do { \\\n\tmlxfw_err(fwdev, \"%s, err (%d)\\n\", MLXFW_ERR_PRFX msg, err); \\\n\tNL_SET_ERR_MSG_MOD(extack, MLXFW_ERR_PRFX msg); \\\n} while (0)\n\nstatic int mlxfw_fsm_state_err(struct mlxfw_dev *mlxfw_dev,\n\t\t\t       struct netlink_ext_ack *extack,\n\t\t\t       enum mlxfw_fsm_state_err err)\n{\n\tenum mlxfw_fsm_state_err fsm_state_err;\n\n\tfsm_state_err = min_t(enum mlxfw_fsm_state_err, err,\n\t\t\t      MLXFW_FSM_STATE_ERR_MAX);\n\n\tswitch (fsm_state_err) {\n\tcase MLXFW_FSM_STATE_ERR_ERROR:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"general error\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_REJECTED_DIGEST_ERR:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"component hash mismatch\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_REJECTED_NOT_APPLICABLE:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"component not applicable\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_REJECTED_UNKNOWN_KEY:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"unknown key\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_REJECTED_AUTH_FAILED:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"authentication failed\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_REJECTED_UNSIGNED:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"component was not signed\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_REJECTED_KEY_NOT_APPLICABLE:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"key not applicable\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_REJECTED_BAD_FORMAT:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"bad format\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_BLOCKED_PENDING_RESET:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"pending reset\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_STATE_ERR_OK:\n\tcase MLXFW_FSM_STATE_ERR_MAX:\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"unknown error\", err);\n\t\tbreak;\n\t}\n\n\treturn mlxfw_fsm_state_errno[fsm_state_err];\n};\n\nstatic int mlxfw_fsm_state_wait(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\tenum mlxfw_fsm_state fsm_state,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tenum mlxfw_fsm_state_err fsm_state_err;\n\tenum mlxfw_fsm_state curr_fsm_state;\n\tint times;\n\tint err;\n\n\ttimes = MLXFW_FSM_STATE_WAIT_ROUNDS;\nretry:\n\terr = mlxfw_dev->ops->fsm_query_state(mlxfw_dev, fwhandle,\n\t\t\t\t\t      &curr_fsm_state, &fsm_state_err);\n\tif (err) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"FSM state query failed\", err);\n\t\treturn err;\n\t}\n\n\tif (fsm_state_err != MLXFW_FSM_STATE_ERR_OK)\n\t\treturn mlxfw_fsm_state_err(mlxfw_dev, extack, fsm_state_err);\n\n\tif (curr_fsm_state != fsm_state) {\n\t\tif (--times == 0) {\n\t\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t\t      \"Timeout reached on FSM state change\", -ETIMEDOUT);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(MLXFW_FSM_STATE_WAIT_CYCLE_MS);\n\t\tgoto retry;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlxfw_fsm_reactivate_err(struct mlxfw_dev *mlxfw_dev,\n\t\t\t struct netlink_ext_ack *extack, u8 err)\n{\n\tenum mlxfw_fsm_reactivate_status status;\n\n#define MXFW_REACT_PRFX \"Reactivate FSM: \"\n#define MLXFW_REACT_ERR(msg, err) \\\n\tMLXFW_ERR_MSG(mlxfw_dev, extack, MXFW_REACT_PRFX msg, err)\n\n\tstatus = min_t(enum mlxfw_fsm_reactivate_status, err,\n\t\t       MLXFW_FSM_REACTIVATE_STATUS_MAX);\n\n\tswitch (status) {\n\tcase MLXFW_FSM_REACTIVATE_STATUS_BUSY:\n\t\tMLXFW_REACT_ERR(\"busy\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_PROHIBITED_FW_VER_ERR:\n\t\tMLXFW_REACT_ERR(\"prohibited fw ver\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_FIRST_PAGE_COPY_FAILED:\n\t\tMLXFW_REACT_ERR(\"first page copy failed\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_FIRST_PAGE_ERASE_FAILED:\n\t\tMLXFW_REACT_ERR(\"first page erase failed\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_FIRST_PAGE_RESTORE_FAILED:\n\t\tMLXFW_REACT_ERR(\"first page restore failed\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_CANDIDATE_FW_DEACTIVATION_FAILED:\n\t\tMLXFW_REACT_ERR(\"candidate fw deactivation failed\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_ERR_DEVICE_RESET_REQUIRED:\n\t\tMLXFW_REACT_ERR(\"device reset required\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_ERR_FW_PROGRAMMING_NEEDED:\n\t\tMLXFW_REACT_ERR(\"fw programming needed\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_FW_ALREADY_ACTIVATED:\n\t\tMLXFW_REACT_ERR(\"fw already activated\", err);\n\t\tbreak;\n\tcase MLXFW_FSM_REACTIVATE_STATUS_OK:\n\tcase MLXFW_FSM_REACTIVATE_STATUS_MAX:\n\t\tMLXFW_REACT_ERR(\"unexpected error\", err);\n\t\tbreak;\n\t}\n\treturn -EREMOTEIO;\n};\n\nstatic int mlxfw_fsm_reactivate(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tbool *supported)\n{\n\tu8 status;\n\tint err;\n\n\tif (!mlxfw_dev->ops->fsm_reactivate)\n\t\treturn 0;\n\n\terr = mlxfw_dev->ops->fsm_reactivate(mlxfw_dev, &status);\n\tif (err == -EOPNOTSUPP) {\n\t\t*supported = false;\n\t\treturn 0;\n\t}\n\n\tif (err) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"Could not reactivate firmware flash\", err);\n\t\treturn err;\n\t}\n\n\tif (status == MLXFW_FSM_REACTIVATE_STATUS_OK ||\n\t    status == MLXFW_FSM_REACTIVATE_STATUS_FW_ALREADY_ACTIVATED)\n\t\treturn 0;\n\n\treturn mlxfw_fsm_reactivate_err(mlxfw_dev, extack, status);\n}\n\nstatic void mlxfw_status_notify(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\tconst char *msg, const char *comp_name,\n\t\t\t\tu32 done_bytes, u32 total_bytes)\n{\n\tdevlink_flash_update_status_notify(mlxfw_dev->devlink, msg, comp_name,\n\t\t\t\t\t   done_bytes, total_bytes);\n}\n\n#define MLXFW_ALIGN_DOWN(x, align_bits) ((x) & ~((1 << (align_bits)) - 1))\n#define MLXFW_ALIGN_UP(x, align_bits) \\\n\t\tMLXFW_ALIGN_DOWN((x) + ((1 << (align_bits)) - 1), (align_bits))\n\nstatic int mlxfw_flash_component(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t u32 fwhandle,\n\t\t\t\t struct mlxfw_mfa2_component *comp,\n\t\t\t\t bool reactivate_supp,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tu16 comp_max_write_size;\n\tu8 comp_align_bits;\n\tu32 comp_max_size;\n\tchar comp_name[8];\n\tu16 block_size;\n\tu8 *block_ptr;\n\tu32 offset;\n\tint err;\n\n\tsprintf(comp_name, \"%u\", comp->index);\n\n\terr = mlxfw_dev->ops->component_query(mlxfw_dev, comp->index,\n\t\t\t\t\t      &comp_max_size, &comp_align_bits,\n\t\t\t\t\t      &comp_max_write_size);\n\tif (err) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack, \"FSM component query failed\", err);\n\t\treturn err;\n\t}\n\n\tcomp_max_size = min_t(u32, comp_max_size, MLXFW_FSM_MAX_COMPONENT_SIZE);\n\tif (comp->data_size > comp_max_size) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"Component size is bigger than limit\", -EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tcomp_max_write_size = MLXFW_ALIGN_DOWN(comp_max_write_size,\n\t\t\t\t\t       comp_align_bits);\n\n\tmlxfw_dbg(mlxfw_dev, \"Component update\\n\");\n\tmlxfw_status_notify(mlxfw_dev, \"Updating component\", comp_name, 0, 0);\n\terr = mlxfw_dev->ops->fsm_component_update(mlxfw_dev, fwhandle,\n\t\t\t\t\t\t   comp->index,\n\t\t\t\t\t\t   comp->data_size);\n\tif (err) {\n\t\tif (!reactivate_supp)\n\t\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t\t      \"FSM component update failed, FW reactivate is not supported\",\n\t\t\t\t      err);\n\t\telse\n\t\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t\t      \"FSM component update failed\", err);\n\t\treturn err;\n\t}\n\n\terr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\n\t\t\t\t   MLXFW_FSM_STATE_DOWNLOAD, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\tmlxfw_dbg(mlxfw_dev, \"Component download\\n\");\n\tmlxfw_status_notify(mlxfw_dev, \"Downloading component\",\n\t\t\t    comp_name, 0, comp->data_size);\n\tfor (offset = 0;\n\t     offset < MLXFW_ALIGN_UP(comp->data_size, comp_align_bits);\n\t     offset += comp_max_write_size) {\n\t\tblock_ptr = comp->data + offset;\n\t\tblock_size = (u16) min_t(u32, comp->data_size - offset,\n\t\t\t\t\t comp_max_write_size);\n\t\terr = mlxfw_dev->ops->fsm_block_download(mlxfw_dev, fwhandle,\n\t\t\t\t\t\t\t block_ptr, block_size,\n\t\t\t\t\t\t\t offset);\n\t\tif (err) {\n\t\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t\t      \"Component download failed\", err);\n\t\t\tgoto err_out;\n\t\t}\n\t\tmlxfw_status_notify(mlxfw_dev, \"Downloading component\",\n\t\t\t\t    comp_name, offset + block_size,\n\t\t\t\t    comp->data_size);\n\t}\n\n\tmlxfw_dbg(mlxfw_dev, \"Component verify\\n\");\n\tmlxfw_status_notify(mlxfw_dev, \"Verifying component\", comp_name, 0, 0);\n\terr = mlxfw_dev->ops->fsm_component_verify(mlxfw_dev, fwhandle,\n\t\t\t\t\t\t   comp->index);\n\tif (err) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"FSM component verify failed\", err);\n\t\tgoto err_out;\n\t}\n\n\terr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\n\t\t\t\t   MLXFW_FSM_STATE_LOCKED, extack);\n\tif (err)\n\t\tgoto err_out;\n\treturn 0;\n\nerr_out:\n\tmlxfw_dev->ops->fsm_cancel(mlxfw_dev, fwhandle);\n\treturn err;\n}\n\nstatic int mlxfw_flash_components(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t  struct mlxfw_mfa2_file *mfa2_file,\n\t\t\t\t  bool reactivate_supp,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tu32 component_count;\n\tint err;\n\tint i;\n\n\terr = mlxfw_mfa2_file_component_count(mfa2_file, mlxfw_dev->psid,\n\t\t\t\t\t      mlxfw_dev->psid_size,\n\t\t\t\t\t      &component_count);\n\tif (err) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"Could not find device PSID in MFA2 file\", err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < component_count; i++) {\n\t\tstruct mlxfw_mfa2_component *comp;\n\n\t\tcomp = mlxfw_mfa2_file_component_get(mfa2_file, mlxfw_dev->psid,\n\t\t\t\t\t\t     mlxfw_dev->psid_size, i);\n\t\tif (IS_ERR(comp)) {\n\t\t\terr = PTR_ERR(comp);\n\t\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t\t      \"Failed to get MFA2 component\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tmlxfw_info(mlxfw_dev, \"Flashing component type %d\\n\",\n\t\t\t   comp->index);\n\t\terr = mlxfw_flash_component(mlxfw_dev, fwhandle, comp,\n\t\t\t\t\t    reactivate_supp, extack);\n\t\tmlxfw_mfa2_file_component_put(comp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint mlxfw_firmware_flash(struct mlxfw_dev *mlxfw_dev,\n\t\t\t const struct firmware *firmware,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxfw_mfa2_file *mfa2_file;\n\tbool reactivate_supp = true;\n\tu32 fwhandle;\n\tint err;\n\n\tif (!mlxfw_mfa2_check(firmware)) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"Firmware file is not MFA2\", -EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmfa2_file = mlxfw_mfa2_file_init(firmware);\n\tif (IS_ERR(mfa2_file)) {\n\t\terr = PTR_ERR(mfa2_file);\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"Failed to initialize MFA2 firmware file\", err);\n\t\treturn err;\n\t}\n\n\tmlxfw_info(mlxfw_dev, \"Initialize firmware flash process\\n\");\n\tmlxfw_status_notify(mlxfw_dev, \"Initializing firmware flash process\",\n\t\t\t    NULL, 0, 0);\n\terr = mlxfw_dev->ops->fsm_lock(mlxfw_dev, &fwhandle);\n\tif (err) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"Could not lock the firmware FSM\", err);\n\t\tgoto err_fsm_lock;\n\t}\n\n\terr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\n\t\t\t\t   MLXFW_FSM_STATE_LOCKED, extack);\n\tif (err)\n\t\tgoto err_state_wait_idle_to_locked;\n\n\terr = mlxfw_fsm_reactivate(mlxfw_dev, extack, &reactivate_supp);\n\tif (err)\n\t\tgoto err_fsm_reactivate;\n\n\terr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\n\t\t\t\t   MLXFW_FSM_STATE_LOCKED, extack);\n\tif (err)\n\t\tgoto err_state_wait_reactivate_to_locked;\n\n\terr = mlxfw_flash_components(mlxfw_dev, fwhandle, mfa2_file,\n\t\t\t\t     reactivate_supp, extack);\n\tif (err)\n\t\tgoto err_flash_components;\n\n\tmlxfw_dbg(mlxfw_dev, \"Activate image\\n\");\n\tmlxfw_status_notify(mlxfw_dev, \"Activating image\", NULL, 0, 0);\n\terr = mlxfw_dev->ops->fsm_activate(mlxfw_dev, fwhandle);\n\tif (err) {\n\t\tMLXFW_ERR_MSG(mlxfw_dev, extack,\n\t\t\t      \"Could not activate the downloaded image\", err);\n\t\tgoto err_fsm_activate;\n\t}\n\n\terr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\n\t\t\t\t   MLXFW_FSM_STATE_LOCKED, extack);\n\tif (err)\n\t\tgoto err_state_wait_activate_to_locked;\n\n\tmlxfw_dbg(mlxfw_dev, \"Handle release\\n\");\n\tmlxfw_dev->ops->fsm_release(mlxfw_dev, fwhandle);\n\n\tmlxfw_info(mlxfw_dev, \"Firmware flash done\\n\");\n\tmlxfw_status_notify(mlxfw_dev, \"Firmware flash done\", NULL, 0, 0);\n\tmlxfw_mfa2_file_fini(mfa2_file);\n\treturn 0;\n\nerr_state_wait_activate_to_locked:\nerr_fsm_activate:\nerr_flash_components:\nerr_state_wait_reactivate_to_locked:\nerr_fsm_reactivate:\nerr_state_wait_idle_to_locked:\n\tmlxfw_dev->ops->fsm_release(mlxfw_dev, fwhandle);\nerr_fsm_lock:\n\tmlxfw_mfa2_file_fini(mfa2_file);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxfw_firmware_flash);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Yotam Gigi <yotamg@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox firmware flash lib\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}