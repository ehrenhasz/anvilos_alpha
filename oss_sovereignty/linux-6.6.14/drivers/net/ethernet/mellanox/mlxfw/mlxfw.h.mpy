{
  "module_name": "mlxfw.h",
  "hash_id": "ff0b62816a71860158e095cdf07fb7d9664d2b67b3ce279eba8989af8b42633a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxfw/mlxfw.h",
  "human_readable_source": " \n \n\n#ifndef _MLXFW_H\n#define _MLXFW_H\n\n#include <linux/firmware.h>\n#include <linux/netlink.h>\n#include <linux/device.h>\n#include <net/devlink.h>\n\nstruct mlxfw_dev {\n\tconst struct mlxfw_dev_ops *ops;\n\tconst char *psid;\n\tu16 psid_size;\n\tstruct devlink *devlink;\n};\n\nstatic inline\nstruct device *mlxfw_dev_dev(struct mlxfw_dev *mlxfw_dev)\n{\n\treturn devlink_to_dev(mlxfw_dev->devlink);\n}\n\n#define MLXFW_PRFX \"mlxfw: \"\n\n#define mlxfw_info(mlxfw_dev, fmt, ...) \\\n\tdev_info(mlxfw_dev_dev(mlxfw_dev), MLXFW_PRFX fmt, ## __VA_ARGS__)\n#define mlxfw_err(mlxfw_dev, fmt, ...) \\\n\tdev_err(mlxfw_dev_dev(mlxfw_dev), MLXFW_PRFX fmt, ## __VA_ARGS__)\n#define mlxfw_dbg(mlxfw_dev, fmt, ...) \\\n\tdev_dbg(mlxfw_dev_dev(mlxfw_dev), MLXFW_PRFX fmt, ## __VA_ARGS__)\n\nenum mlxfw_fsm_state {\n\tMLXFW_FSM_STATE_IDLE,\n\tMLXFW_FSM_STATE_LOCKED,\n\tMLXFW_FSM_STATE_INITIALIZE,\n\tMLXFW_FSM_STATE_DOWNLOAD,\n\tMLXFW_FSM_STATE_VERIFY,\n\tMLXFW_FSM_STATE_APPLY,\n\tMLXFW_FSM_STATE_ACTIVATE,\n};\n\nenum mlxfw_fsm_state_err {\n\tMLXFW_FSM_STATE_ERR_OK,\n\tMLXFW_FSM_STATE_ERR_ERROR,\n\tMLXFW_FSM_STATE_ERR_REJECTED_DIGEST_ERR,\n\tMLXFW_FSM_STATE_ERR_REJECTED_NOT_APPLICABLE,\n\tMLXFW_FSM_STATE_ERR_REJECTED_UNKNOWN_KEY,\n\tMLXFW_FSM_STATE_ERR_REJECTED_AUTH_FAILED,\n\tMLXFW_FSM_STATE_ERR_REJECTED_UNSIGNED,\n\tMLXFW_FSM_STATE_ERR_REJECTED_KEY_NOT_APPLICABLE,\n\tMLXFW_FSM_STATE_ERR_REJECTED_BAD_FORMAT,\n\tMLXFW_FSM_STATE_ERR_BLOCKED_PENDING_RESET,\n\tMLXFW_FSM_STATE_ERR_MAX,\n};\n\nenum mlxfw_fsm_reactivate_status {\n\tMLXFW_FSM_REACTIVATE_STATUS_OK,\n\tMLXFW_FSM_REACTIVATE_STATUS_BUSY,\n\tMLXFW_FSM_REACTIVATE_STATUS_PROHIBITED_FW_VER_ERR,\n\tMLXFW_FSM_REACTIVATE_STATUS_FIRST_PAGE_COPY_FAILED,\n\tMLXFW_FSM_REACTIVATE_STATUS_FIRST_PAGE_ERASE_FAILED,\n\tMLXFW_FSM_REACTIVATE_STATUS_FIRST_PAGE_RESTORE_FAILED,\n\tMLXFW_FSM_REACTIVATE_STATUS_CANDIDATE_FW_DEACTIVATION_FAILED,\n\tMLXFW_FSM_REACTIVATE_STATUS_FW_ALREADY_ACTIVATED,\n\tMLXFW_FSM_REACTIVATE_STATUS_ERR_DEVICE_RESET_REQUIRED,\n\tMLXFW_FSM_REACTIVATE_STATUS_ERR_FW_PROGRAMMING_NEEDED,\n\tMLXFW_FSM_REACTIVATE_STATUS_MAX,\n};\n\nstruct mlxfw_dev_ops {\n\tint (*component_query)(struct mlxfw_dev *mlxfw_dev, u16 component_index,\n\t\t\t       u32 *p_max_size, u8 *p_align_bits,\n\t\t\t       u16 *p_max_write_size);\n\n\tint (*fsm_lock)(struct mlxfw_dev *mlxfw_dev, u32 *fwhandle);\n\n\tint (*fsm_component_update)(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t    u16 component_index, u32 component_size);\n\n\tint (*fsm_block_download)(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t  u8 *data, u16 size, u32 offset);\n\n\tint (*fsm_component_verify)(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t    u16 component_index);\n\n\tint (*fsm_activate)(struct mlxfw_dev *mlxfw_dev, u32 fwhandle);\n\n\tint (*fsm_reactivate)(struct mlxfw_dev *mlxfw_dev, u8 *status);\n\n\tint (*fsm_query_state)(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t       enum mlxfw_fsm_state *fsm_state,\n\t\t\t       enum mlxfw_fsm_state_err *fsm_state_err);\n\n\tvoid (*fsm_cancel)(struct mlxfw_dev *mlxfw_dev, u32 fwhandle);\n\n\tvoid (*fsm_release)(struct mlxfw_dev *mlxfw_dev, u32 fwhandle);\n};\n\n#if IS_REACHABLE(CONFIG_MLXFW)\nint mlxfw_firmware_flash(struct mlxfw_dev *mlxfw_dev,\n\t\t\t const struct firmware *firmware,\n\t\t\t struct netlink_ext_ack *extack);\n#else\nstatic inline\nint mlxfw_firmware_flash(struct mlxfw_dev *mlxfw_dev,\n\t\t\t const struct firmware *firmware,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}