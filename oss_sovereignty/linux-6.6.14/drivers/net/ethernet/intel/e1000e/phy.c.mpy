{
  "module_name": "phy.c",
  "hash_id": "3d525bf52123f599f3f16d6f637a8038b24d8a64ac7e47563a08c45c847efa64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/phy.c",
  "human_readable_source": "\n \n\n#include \"e1000.h\"\n#include <linux/ethtool.h>\n\nstatic s32 e1000_wait_autoneg(struct e1000_hw *hw);\nstatic s32 e1000_access_phy_wakeup_reg_bm(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u16 *data, bool read, bool page_set);\nstatic u32 e1000_get_phy_addr_for_hv_page(u32 page);\nstatic s32 e1000_access_phy_debug_regs_hv(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u16 *data, bool read);\n\n \nstatic const u16 e1000_m88_cable_length_table[] = {\n\t0, 50, 80, 110, 140, 140, E1000_CABLE_LENGTH_UNDEFINED\n};\n\n#define M88E1000_CABLE_LENGTH_TABLE_SIZE \\\n\t\tARRAY_SIZE(e1000_m88_cable_length_table)\n\nstatic const u16 e1000_igp_2_cable_length_table[] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 8, 11, 13, 16, 18, 21, 0, 0, 0, 3,\n\t6, 10, 13, 16, 19, 23, 26, 29, 32, 35, 38, 41, 6, 10, 14, 18, 22,\n\t26, 30, 33, 37, 41, 44, 48, 51, 54, 58, 61, 21, 26, 31, 35, 40,\n\t44, 49, 53, 57, 61, 65, 68, 72, 75, 79, 82, 40, 45, 51, 56, 61,\n\t66, 70, 75, 79, 83, 87, 91, 94, 98, 101, 104, 60, 66, 72, 77, 82,\n\t87, 92, 96, 100, 104, 108, 111, 114, 117, 119, 121, 83, 89, 95,\n\t100, 105, 109, 113, 116, 119, 122, 124, 104, 109, 114, 118, 121,\n\t124\n};\n\n#define IGP02E1000_CABLE_LENGTH_TABLE_SIZE \\\n\t\tARRAY_SIZE(e1000_igp_2_cable_length_table)\n\n \ns32 e1000e_check_reset_block_generic(struct e1000_hw *hw)\n{\n\tu32 manc;\n\n\tmanc = er32(MANC);\n\n\treturn (manc & E1000_MANC_BLK_PHY_RST_ON_IDE) ? E1000_BLK_PHY_RESET : 0;\n}\n\n \ns32 e1000e_get_phy_id(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu16 phy_id;\n\tu16 retry_count = 0;\n\n\tif (!phy->ops.read_reg)\n\t\treturn 0;\n\n\twhile (retry_count < 2) {\n\t\tret_val = e1e_rphy(hw, MII_PHYSID1, &phy_id);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy->id = (u32)(phy_id << 16);\n\t\tusleep_range(20, 40);\n\t\tret_val = e1e_rphy(hw, MII_PHYSID2, &phy_id);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy->id |= (u32)(phy_id & PHY_REVISION_MASK);\n\t\tphy->revision = (u32)(phy_id & ~PHY_REVISION_MASK);\n\n\t\tif (phy->id != 0 && phy->id != PHY_REVISION_MASK)\n\t\t\treturn 0;\n\n\t\tretry_count++;\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_phy_reset_dsp(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tret_val = e1e_wphy(hw, M88E1000_PHY_GEN_CONTROL, 0xC1);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1e_wphy(hw, M88E1000_PHY_GEN_CONTROL, 0);\n}\n\n \ns32 e1000e_read_phy_reg_mdic(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 i, mdic = 0;\n\n\tif (offset > MAX_PHY_REG_ADDRESS) {\n\t\te_dbg(\"PHY Address %d is out of range\\n\", offset);\n\t\treturn -E1000_ERR_PARAM;\n\t}\n\n\t \n\tmdic = ((offset << E1000_MDIC_REG_SHIFT) |\n\t\t(phy->addr << E1000_MDIC_PHY_SHIFT) |\n\t\t(E1000_MDIC_OP_READ));\n\n\tew32(MDIC, mdic);\n\n\t \n\tfor (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {\n\t\tudelay(50);\n\t\tmdic = er32(MDIC);\n\t\tif (mdic & E1000_MDIC_READY)\n\t\t\tbreak;\n\t}\n\tif (!(mdic & E1000_MDIC_READY)) {\n\t\te_dbg(\"MDI Read PHY Reg Address %d did not complete\\n\", offset);\n\t\treturn -E1000_ERR_PHY;\n\t}\n\tif (mdic & E1000_MDIC_ERROR) {\n\t\te_dbg(\"MDI Read PHY Reg Address %d Error\\n\", offset);\n\t\treturn -E1000_ERR_PHY;\n\t}\n\tif (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != offset) {\n\t\te_dbg(\"MDI Read offset error - requested %d, returned %d\\n\",\n\t\t      offset,\n\t\t      (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);\n\t\treturn -E1000_ERR_PHY;\n\t}\n\t*data = (u16)mdic;\n\n\t \n\tif (hw->mac.type == e1000_pch2lan)\n\t\tudelay(100);\n\n\treturn 0;\n}\n\n \ns32 e1000e_write_phy_reg_mdic(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 i, mdic = 0;\n\n\tif (offset > MAX_PHY_REG_ADDRESS) {\n\t\te_dbg(\"PHY Address %d is out of range\\n\", offset);\n\t\treturn -E1000_ERR_PARAM;\n\t}\n\n\t \n\tmdic = (((u32)data) |\n\t\t(offset << E1000_MDIC_REG_SHIFT) |\n\t\t(phy->addr << E1000_MDIC_PHY_SHIFT) |\n\t\t(E1000_MDIC_OP_WRITE));\n\n\tew32(MDIC, mdic);\n\n\t \n\tfor (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {\n\t\tudelay(50);\n\t\tmdic = er32(MDIC);\n\t\tif (mdic & E1000_MDIC_READY)\n\t\t\tbreak;\n\t}\n\tif (!(mdic & E1000_MDIC_READY)) {\n\t\te_dbg(\"MDI Write PHY Reg Address %d did not complete\\n\", offset);\n\t\treturn -E1000_ERR_PHY;\n\t}\n\tif (mdic & E1000_MDIC_ERROR) {\n\t\te_dbg(\"MDI Write PHY Red Address %d Error\\n\", offset);\n\t\treturn -E1000_ERR_PHY;\n\t}\n\tif (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != offset) {\n\t\te_dbg(\"MDI Write offset error - requested %d, returned %d\\n\",\n\t\t      offset,\n\t\t      (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\t \n\tif (hw->mac.type == e1000_pch2lan)\n\t\tudelay(100);\n\n\treturn 0;\n}\n\n \ns32 e1000e_read_phy_reg_m88(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\ts32 ret_val;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000e_read_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t   data);\n\n\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_write_phy_reg_m88(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\ts32 ret_val;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t    data);\n\n\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_set_page_igp(struct e1000_hw *hw, u16 page)\n{\n\te_dbg(\"Setting page 0x%x\\n\", page);\n\n\thw->phy.addr = 1;\n\n\treturn e1000e_write_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT, page);\n}\n\n \nstatic s32 __e1000e_read_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 *data,\n\t\t\t\t     bool locked)\n{\n\ts32 ret_val = 0;\n\n\tif (!locked) {\n\t\tif (!hw->phy.ops.acquire)\n\t\t\treturn 0;\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG)\n\t\tret_val = e1000e_write_phy_reg_mdic(hw,\n\t\t\t\t\t\t    IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t    (u16)offset);\n\tif (!ret_val)\n\t\tret_val = e1000e_read_phy_reg_mdic(hw,\n\t\t\t\t\t\t   MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t\t   data);\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_read_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn __e1000e_read_phy_reg_igp(hw, offset, data, false);\n}\n\n \ns32 e1000e_read_phy_reg_igp_locked(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn __e1000e_read_phy_reg_igp(hw, offset, data, true);\n}\n\n \nstatic s32 __e1000e_write_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 data,\n\t\t\t\t      bool locked)\n{\n\ts32 ret_val = 0;\n\n\tif (!locked) {\n\t\tif (!hw->phy.ops.acquire)\n\t\t\treturn 0;\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG)\n\t\tret_val = e1000e_write_phy_reg_mdic(hw,\n\t\t\t\t\t\t    IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t    (u16)offset);\n\tif (!ret_val)\n\t\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS &\n\t\t\t\t\t\t    offset, data);\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_write_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn __e1000e_write_phy_reg_igp(hw, offset, data, false);\n}\n\n \ns32 e1000e_write_phy_reg_igp_locked(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn __e1000e_write_phy_reg_igp(hw, offset, data, true);\n}\n\n \nstatic s32 __e1000_read_kmrn_reg(struct e1000_hw *hw, u32 offset, u16 *data,\n\t\t\t\t bool locked)\n{\n\tu32 kmrnctrlsta;\n\n\tif (!locked) {\n\t\ts32 ret_val = 0;\n\n\t\tif (!hw->phy.ops.acquire)\n\t\t\treturn 0;\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\n\t\t       E1000_KMRNCTRLSTA_OFFSET) | E1000_KMRNCTRLSTA_REN;\n\tew32(KMRNCTRLSTA, kmrnctrlsta);\n\te1e_flush();\n\n\tudelay(2);\n\n\tkmrnctrlsta = er32(KMRNCTRLSTA);\n\t*data = (u16)kmrnctrlsta;\n\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn 0;\n}\n\n \ns32 e1000e_read_kmrn_reg(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn __e1000_read_kmrn_reg(hw, offset, data, false);\n}\n\n \ns32 e1000e_read_kmrn_reg_locked(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn __e1000_read_kmrn_reg(hw, offset, data, true);\n}\n\n \nstatic s32 __e1000_write_kmrn_reg(struct e1000_hw *hw, u32 offset, u16 data,\n\t\t\t\t  bool locked)\n{\n\tu32 kmrnctrlsta;\n\n\tif (!locked) {\n\t\ts32 ret_val = 0;\n\n\t\tif (!hw->phy.ops.acquire)\n\t\t\treturn 0;\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\n\t\t       E1000_KMRNCTRLSTA_OFFSET) | data;\n\tew32(KMRNCTRLSTA, kmrnctrlsta);\n\te1e_flush();\n\n\tudelay(2);\n\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn 0;\n}\n\n \ns32 e1000e_write_kmrn_reg(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn __e1000_write_kmrn_reg(hw, offset, data, false);\n}\n\n \ns32 e1000e_write_kmrn_reg_locked(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn __e1000_write_kmrn_reg(hw, offset, data, true);\n}\n\n \nstatic s32 e1000_set_master_slave_mode(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\t \n\tret_val = e1e_rphy(hw, MII_CTRL1000, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\thw->phy.original_ms_type = (phy_data & CTL1000_ENABLE_MASTER) ?\n\t    ((phy_data & CTL1000_AS_MASTER) ?\n\t     e1000_ms_force_master : e1000_ms_force_slave) : e1000_ms_auto;\n\n\tswitch (hw->phy.ms_type) {\n\tcase e1000_ms_force_master:\n\t\tphy_data |= (CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);\n\t\tbreak;\n\tcase e1000_ms_force_slave:\n\t\tphy_data |= CTL1000_ENABLE_MASTER;\n\t\tphy_data &= ~(CTL1000_AS_MASTER);\n\t\tbreak;\n\tcase e1000_ms_auto:\n\t\tphy_data &= ~CTL1000_ENABLE_MASTER;\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn e1e_wphy(hw, MII_CTRL1000, phy_data);\n}\n\n \ns32 e1000_copper_link_setup_82577(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\t \n\tret_val = e1e_rphy(hw, I82577_CFG_REG, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data |= I82577_CFG_ASSERT_CRS_ON_TX;\n\n\t \n\tphy_data |= I82577_CFG_ENABLE_DOWNSHIFT;\n\n\tret_val = e1e_wphy(hw, I82577_CFG_REG, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1e_rphy(hw, I82577_PHY_CTRL_2, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\tphy_data &= ~I82577_PHY_CTRL2_MDIX_CFG_MASK;\n\t \n\tswitch (hw->phy.mdix) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\tphy_data |= I82577_PHY_CTRL2_MANUAL_MDIX;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tphy_data |= I82577_PHY_CTRL2_AUTO_MDI_MDIX;\n\t\tbreak;\n\t}\n\tret_val = e1e_wphy(hw, I82577_PHY_CTRL_2, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1000_set_master_slave_mode(hw);\n}\n\n \ns32 e1000e_copper_link_setup_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\t \n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (phy->type != e1000_phy_bm)\n\t\tphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\n\n\t \n\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\n\tswitch (phy->mdix) {\n\tcase 1:\n\t\tphy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;\n\t\tbreak;\n\tcase 2:\n\t\tphy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;\n\t\tbreak;\n\tcase 3:\n\t\tphy_data |= M88E1000_PSCR_AUTO_X_1000T;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tphy_data |= M88E1000_PSCR_AUTO_X_MODE;\n\t\tbreak;\n\t}\n\n\t \n\tphy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;\n\tif (phy->disable_polarity_correction)\n\t\tphy_data |= M88E1000_PSCR_POLARITY_REVERSAL;\n\n\t \n\tif (phy->type == e1000_phy_bm) {\n\t\t \n\t\tif (phy->id == BME1000_E_PHY_ID_R2) {\n\t\t\tphy_data &= ~BME1000_PSCR_ENABLE_DOWNSHIFT;\n\t\t\tret_val = e1e_wphy(hw, M88E1000_PHY_SPEC_CTRL,\n\t\t\t\t\t   phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\t \n\t\t\tret_val = phy->ops.commit(hw);\n\t\t\tif (ret_val) {\n\t\t\t\te_dbg(\"Error committing the PHY changes\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\n\t\tphy_data |= BME1000_PSCR_ENABLE_DOWNSHIFT;\n\t}\n\n\tret_val = e1e_wphy(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif ((phy->type == e1000_phy_m88) &&\n\t    (phy->revision < E1000_REVISION_4) &&\n\t    (phy->id != BME1000_E_PHY_ID_R2)) {\n\t\t \n\t\tret_val = e1e_rphy(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_data |= M88E1000_EPSCR_TX_CLK_25;\n\n\t\tif ((phy->revision == 2) && (phy->id == M88E1111_I_PHY_ID)) {\n\t\t\t \n\t\t\tphy_data &= ~M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK;\n\t\t\tphy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;\n\t\t} else {\n\t\t\t \n\t\t\tphy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |\n\t\t\t\t      M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);\n\t\t\tphy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |\n\t\t\t\t     M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);\n\t\t}\n\t\tret_val = e1e_wphy(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif ((phy->type == e1000_phy_bm) && (phy->id == BME1000_E_PHY_ID_R2)) {\n\t\t \n\t\tret_val = e1e_wphy(hw, 29, 0x0003);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tret_val = e1e_wphy(hw, 30, 0x0000);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tif (phy->ops.commit) {\n\t\tret_val = phy->ops.commit(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error committing the PHY changes\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\tif (phy->type == e1000_phy_82578) {\n\t\tret_val = e1e_rphy(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tphy_data |= I82578_EPSCR_DOWNSHIFT_ENABLE;\n\t\tphy_data &= ~I82578_EPSCR_DOWNSHIFT_COUNTER_MASK;\n\t\tret_val = e1e_wphy(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_copper_link_setup_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = e1000_phy_hw_reset(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error resetting the PHY.\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tmsleep(100);\n\n\t \n\tif (hw->phy.ops.set_d0_lplu_state) {\n\t\tret_val = hw->phy.ops.set_d0_lplu_state(hw, false);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error Disabling LPLU D0\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\t \n\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CTRL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata &= ~IGP01E1000_PSCR_AUTO_MDIX;\n\n\tswitch (phy->mdix) {\n\tcase 1:\n\t\tdata &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\t\tbreak;\n\tcase 2:\n\t\tdata |= IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tdata |= IGP01E1000_PSCR_AUTO_MDIX;\n\t\tbreak;\n\t}\n\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CTRL, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (hw->mac.autoneg) {\n\t\t \n\t\tif (phy->autoneg_advertised == ADVERTISE_1000_FULL) {\n\t\t\t \n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\t \n\t\t\tret_val = e1e_rphy(hw, MII_CTRL1000, &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata &= ~CTL1000_ENABLE_MASTER;\n\t\t\tret_val = e1e_wphy(hw, MII_CTRL1000, data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\n\t\tret_val = e1000_set_master_slave_mode(hw);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_phy_setup_autoneg(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 mii_autoneg_adv_reg;\n\tu16 mii_1000t_ctrl_reg = 0;\n\n\tphy->autoneg_advertised &= phy->autoneg_mask;\n\n\t \n\tret_val = e1e_rphy(hw, MII_ADVERTISE, &mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (phy->autoneg_mask & ADVERTISE_1000_FULL) {\n\t\t \n\t\tret_val = e1e_rphy(hw, MII_CTRL1000, &mii_1000t_ctrl_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\n\t \n\tmii_autoneg_adv_reg &= ~(ADVERTISE_100FULL |\n\t\t\t\t ADVERTISE_100HALF |\n\t\t\t\t ADVERTISE_10FULL | ADVERTISE_10HALF);\n\tmii_1000t_ctrl_reg &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);\n\n\te_dbg(\"autoneg_advertised %x\\n\", phy->autoneg_advertised);\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_10_HALF) {\n\t\te_dbg(\"Advertise 10mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= ADVERTISE_10HALF;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_10_FULL) {\n\t\te_dbg(\"Advertise 10mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= ADVERTISE_10FULL;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_100_HALF) {\n\t\te_dbg(\"Advertise 100mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= ADVERTISE_100HALF;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_100_FULL) {\n\t\te_dbg(\"Advertise 100mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= ADVERTISE_100FULL;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_1000_HALF)\n\t\te_dbg(\"Advertise 1000mb Half duplex request denied!\\n\");\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_1000_FULL) {\n\t\te_dbg(\"Advertise 1000mb Full duplex\\n\");\n\t\tmii_1000t_ctrl_reg |= ADVERTISE_1000FULL;\n\t}\n\n\t \n\tswitch (hw->fc.current_mode) {\n\tcase e1000_fc_none:\n\t\t \n\t\tmii_autoneg_adv_reg &=\n\t\t    ~(ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP);\n\t\tphy->autoneg_advertised &=\n\t\t    ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);\n\t\tbreak;\n\tcase e1000_fc_rx_pause:\n\t\t \n\t\tmii_autoneg_adv_reg |=\n\t\t    (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP);\n\t\tphy->autoneg_advertised |=\n\t\t    (ADVERTISED_Pause | ADVERTISED_Asym_Pause);\n\t\tbreak;\n\tcase e1000_fc_tx_pause:\n\t\t \n\t\tmii_autoneg_adv_reg |= ADVERTISE_PAUSE_ASYM;\n\t\tmii_autoneg_adv_reg &= ~ADVERTISE_PAUSE_CAP;\n\t\tphy->autoneg_advertised |= ADVERTISED_Asym_Pause;\n\t\tphy->autoneg_advertised &= ~ADVERTISED_Pause;\n\t\tbreak;\n\tcase e1000_fc_full:\n\t\t \n\t\tmii_autoneg_adv_reg |=\n\t\t    (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP);\n\t\tphy->autoneg_advertised |=\n\t\t    (ADVERTISED_Pause | ADVERTISED_Asym_Pause);\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Flow control param set incorrectly\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tret_val = e1e_wphy(hw, MII_ADVERTISE, mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te_dbg(\"Auto-Neg Advertising %x\\n\", mii_autoneg_adv_reg);\n\n\tif (phy->autoneg_mask & ADVERTISE_1000_FULL)\n\t\tret_val = e1e_wphy(hw, MII_CTRL1000, mii_1000t_ctrl_reg);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_copper_link_autoneg(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_ctrl;\n\n\t \n\tphy->autoneg_advertised &= phy->autoneg_mask;\n\n\t \n\tif (!phy->autoneg_advertised)\n\t\tphy->autoneg_advertised = phy->autoneg_mask;\n\n\te_dbg(\"Reconfiguring auto-neg advertisement params\\n\");\n\tret_val = e1000_phy_setup_autoneg(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Setting up Auto-Negotiation\\n\");\n\t\treturn ret_val;\n\t}\n\te_dbg(\"Restarting Auto-Neg\\n\");\n\n\t \n\tret_val = e1e_rphy(hw, MII_BMCR, &phy_ctrl);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_ctrl |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\tret_val = e1e_wphy(hw, MII_BMCR, phy_ctrl);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (phy->autoneg_wait_to_complete) {\n\t\tret_val = e1000_wait_autoneg(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error while waiting for autoneg to complete\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\thw->mac.get_link_status = true;\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_setup_copper_link(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tbool link;\n\n\tif (hw->mac.autoneg) {\n\t\t \n\t\tret_val = e1000_copper_link_autoneg(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else {\n\t\t \n\t\te_dbg(\"Forcing Speed and Duplex\\n\");\n\t\tret_val = hw->phy.ops.force_speed_duplex(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error Forcing Speed and Duplex\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tret_val = e1000e_phy_has_link_generic(hw, COPPER_LINK_UP_LIMIT, 10,\n\t\t\t\t\t      &link);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (link) {\n\t\te_dbg(\"Valid link established!!!\\n\");\n\t\thw->mac.ops.config_collision_dist(hw);\n\t\tret_val = e1000e_config_fc_after_link_up(hw);\n\t} else {\n\t\te_dbg(\"Unable to establish link!!!\\n\");\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_phy_force_speed_duplex_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tret_val = e1e_rphy(hw, MII_BMCR, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te1000e_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\tret_val = e1e_wphy(hw, MII_BMCR, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;\n\tphy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\n\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te_dbg(\"IGP PSCR: %X\\n\", phy_data);\n\n\tudelay(1);\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\te_dbg(\"Waiting for forced speed/duplex link on IGP phy.\\n\");\n\n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!link)\n\t\t\te_dbg(\"Link taking longer than expected.\\n\");\n\n\t\t \n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_phy_force_speed_duplex_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\t \n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\tret_val = e1e_wphy(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te_dbg(\"M88E1000 PSCR: %X\\n\", phy_data);\n\n\tret_val = e1e_rphy(hw, MII_BMCR, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te1000e_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\tret_val = e1e_wphy(hw, MII_BMCR, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (hw->phy.ops.commit) {\n\t\tret_val = hw->phy.ops.commit(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\te_dbg(\"Waiting for forced speed/duplex link on M88 phy.\\n\");\n\n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!link) {\n\t\t\tif (hw->phy.type != e1000_phy_m88) {\n\t\t\t\te_dbg(\"Link taking longer than expected.\\n\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret_val = e1e_wphy(hw, M88E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t   0x001d);\n\t\t\t\tif (ret_val)\n\t\t\t\t\treturn ret_val;\n\t\t\t\tret_val = e1000e_phy_reset_dsp(hw);\n\t\t\t\tif (ret_val)\n\t\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (hw->phy.type != e1000_phy_m88)\n\t\treturn 0;\n\n\tret_val = e1e_rphy(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tphy_data |= M88E1000_EPSCR_TX_CLK_25;\n\tret_val = e1e_wphy(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\n\tret_val = e1e_wphy(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_phy_force_speed_duplex_ife(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = e1e_rphy(hw, MII_BMCR, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te1000e_phy_force_speed_duplex_setup(hw, &data);\n\n\tret_val = e1e_wphy(hw, MII_BMCR, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1e_rphy(hw, IFE_PHY_MDIX_CONTROL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata &= ~IFE_PMC_AUTO_MDIX;\n\tdata &= ~IFE_PMC_FORCE_MDIX;\n\n\tret_val = e1e_wphy(hw, IFE_PHY_MDIX_CONTROL, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te_dbg(\"IFE PMC: %X\\n\", data);\n\n\tudelay(1);\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\te_dbg(\"Waiting for forced speed/duplex link on IFE phy.\\n\");\n\n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!link)\n\t\t\te_dbg(\"Link taking longer than expected.\\n\");\n\n\t\t \n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn 0;\n}\n\n \nvoid e1000e_phy_force_speed_duplex_setup(struct e1000_hw *hw, u16 *phy_ctrl)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 ctrl;\n\n\t \n\thw->fc.current_mode = e1000_fc_none;\n\n\t \n\tctrl = er32(CTRL);\n\tctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tctrl &= ~E1000_CTRL_SPD_SEL;\n\n\t \n\tctrl &= ~E1000_CTRL_ASDE;\n\n\t \n\t*phy_ctrl &= ~BMCR_ANENABLE;\n\n\t \n\tif (mac->forced_speed_duplex & E1000_ALL_HALF_DUPLEX) {\n\t\tctrl &= ~E1000_CTRL_FD;\n\t\t*phy_ctrl &= ~BMCR_FULLDPLX;\n\t\te_dbg(\"Half Duplex\\n\");\n\t} else {\n\t\tctrl |= E1000_CTRL_FD;\n\t\t*phy_ctrl |= BMCR_FULLDPLX;\n\t\te_dbg(\"Full Duplex\\n\");\n\t}\n\n\t \n\tif (mac->forced_speed_duplex & E1000_ALL_100_SPEED) {\n\t\tctrl |= E1000_CTRL_SPD_100;\n\t\t*phy_ctrl |= BMCR_SPEED100;\n\t\t*phy_ctrl &= ~BMCR_SPEED1000;\n\t\te_dbg(\"Forcing 100mb\\n\");\n\t} else {\n\t\tctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\n\t\t*phy_ctrl &= ~(BMCR_SPEED1000 | BMCR_SPEED100);\n\t\te_dbg(\"Forcing 10mb\\n\");\n\t}\n\n\thw->mac.ops.config_collision_dist(hw);\n\n\tew32(CTRL, ctrl);\n}\n\n \ns32 e1000e_set_d3_lplu_state(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = e1e_rphy(hw, IGP02E1000_PHY_POWER_MGMT, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!active) {\n\t\tdata &= ~IGP02E1000_PM_D3_LPLU;\n\t\tret_val = e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata |= IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t} else if (phy->smart_speed == e1000_smart_speed_off) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t} else if ((phy->autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_NOT_GIG) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_10_SPEED)) {\n\t\tdata |= IGP02E1000_PM_D3_LPLU;\n\t\tret_val = e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG, data);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_check_downshift(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, offset, mask;\n\n\tswitch (phy->type) {\n\tcase e1000_phy_m88:\n\tcase e1000_phy_gg82563:\n\tcase e1000_phy_bm:\n\tcase e1000_phy_82578:\n\t\toffset = M88E1000_PHY_SPEC_STATUS;\n\t\tmask = M88E1000_PSSR_DOWNSHIFT;\n\t\tbreak;\n\tcase e1000_phy_igp_2:\n\tcase e1000_phy_igp_3:\n\t\toffset = IGP01E1000_PHY_LINK_HEALTH;\n\t\tmask = IGP01E1000_PLHR_SS_DOWNGRADE;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tphy->speed_downgraded = false;\n\t\treturn 0;\n\t}\n\n\tret_val = e1e_rphy(hw, offset, &phy_data);\n\n\tif (!ret_val)\n\t\tphy->speed_downgraded = !!(phy_data & mask);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_check_polarity_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_STATUS, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = ((data & M88E1000_PSSR_REV_POLARITY)\n\t\t\t\t       ? e1000_rev_polarity_reversed\n\t\t\t\t       : e1000_rev_polarity_normal);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_check_polarity_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data, offset, mask;\n\n\t \n\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_STATUS, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif ((data & IGP01E1000_PSSR_SPEED_MASK) ==\n\t    IGP01E1000_PSSR_SPEED_1000MBPS) {\n\t\toffset = IGP01E1000_PHY_PCS_INIT_REG;\n\t\tmask = IGP01E1000_PHY_POLARITY_MASK;\n\t} else {\n\t\t \n\t\toffset = IGP01E1000_PHY_PORT_STATUS;\n\t\tmask = IGP01E1000_PSSR_POLARITY_REVERSED;\n\t}\n\n\tret_val = e1e_rphy(hw, offset, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = ((data & mask)\n\t\t\t\t       ? e1000_rev_polarity_reversed\n\t\t\t\t       : e1000_rev_polarity_normal);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_check_polarity_ife(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, offset, mask;\n\n\t \n\tif (phy->polarity_correction) {\n\t\toffset = IFE_PHY_EXTENDED_STATUS_CONTROL;\n\t\tmask = IFE_PESC_POLARITY_REVERSED;\n\t} else {\n\t\toffset = IFE_PHY_SPECIAL_CONTROL;\n\t\tmask = IFE_PSC_FORCE_POLARITY;\n\t}\n\n\tret_val = e1e_rphy(hw, offset, &phy_data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = ((phy_data & mask)\n\t\t\t\t       ? e1000_rev_polarity_reversed\n\t\t\t\t       : e1000_rev_polarity_normal);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_wait_autoneg(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 i, phy_status;\n\n\t \n\tfor (i = PHY_AUTO_NEG_LIMIT; i > 0; i--) {\n\t\tret_val = e1e_rphy(hw, MII_BMSR, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tret_val = e1e_rphy(hw, MII_BMSR, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & BMSR_ANEGCOMPLETE)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\t \n\treturn ret_val;\n}\n\n \ns32 e1000e_phy_has_link_generic(struct e1000_hw *hw, u32 iterations,\n\t\t\t\tu32 usec_interval, bool *success)\n{\n\ts32 ret_val = 0;\n\tu16 i, phy_status;\n\n\t*success = false;\n\tfor (i = 0; i < iterations; i++) {\n\t\t \n\t\tret_val = e1e_rphy(hw, MII_BMSR, &phy_status);\n\t\tif (ret_val) {\n\t\t\t \n\t\t\tif (usec_interval >= 1000)\n\t\t\t\tmsleep(usec_interval / 1000);\n\t\t\telse\n\t\t\t\tudelay(usec_interval);\n\t\t}\n\t\tret_val = e1e_rphy(hw, MII_BMSR, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & BMSR_LSTATUS) {\n\t\t\t*success = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (usec_interval >= 1000)\n\t\t\tmsleep(usec_interval / 1000);\n\t\telse\n\t\t\tudelay(usec_interval);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_get_cable_length_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, index;\n\n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tindex = ((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>\n\t\t M88E1000_PSSR_CABLE_LENGTH_SHIFT);\n\n\tif (index >= M88E1000_CABLE_LENGTH_TABLE_SIZE - 1)\n\t\treturn -E1000_ERR_PHY;\n\n\tphy->min_cable_length = e1000_m88_cable_length_table[index];\n\tphy->max_cable_length = e1000_m88_cable_length_table[index + 1];\n\n\tphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\n\n\treturn 0;\n}\n\n \ns32 e1000e_get_cable_length_igp_2(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, i, agc_value = 0;\n\tu16 cur_agc_index, max_agc_index = 0;\n\tu16 min_agc_index = IGP02E1000_CABLE_LENGTH_TABLE_SIZE - 1;\n\tstatic const u16 agc_reg_array[IGP02E1000_PHY_CHANNEL_NUM] = {\n\t\tIGP02E1000_PHY_AGC_A,\n\t\tIGP02E1000_PHY_AGC_B,\n\t\tIGP02E1000_PHY_AGC_C,\n\t\tIGP02E1000_PHY_AGC_D\n\t};\n\n\t \n\tfor (i = 0; i < IGP02E1000_PHY_CHANNEL_NUM; i++) {\n\t\tret_val = e1e_rphy(hw, agc_reg_array[i], &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tcur_agc_index = ((phy_data >> IGP02E1000_AGC_LENGTH_SHIFT) &\n\t\t\t\t IGP02E1000_AGC_LENGTH_MASK);\n\n\t\t \n\t\tif ((cur_agc_index >= IGP02E1000_CABLE_LENGTH_TABLE_SIZE) ||\n\t\t    (cur_agc_index == 0))\n\t\t\treturn -E1000_ERR_PHY;\n\n\t\t \n\t\tif (e1000_igp_2_cable_length_table[min_agc_index] >\n\t\t    e1000_igp_2_cable_length_table[cur_agc_index])\n\t\t\tmin_agc_index = cur_agc_index;\n\t\tif (e1000_igp_2_cable_length_table[max_agc_index] <\n\t\t    e1000_igp_2_cable_length_table[cur_agc_index])\n\t\t\tmax_agc_index = cur_agc_index;\n\n\t\tagc_value += e1000_igp_2_cable_length_table[cur_agc_index];\n\t}\n\n\tagc_value -= (e1000_igp_2_cable_length_table[min_agc_index] +\n\t\t      e1000_igp_2_cable_length_table[max_agc_index]);\n\tagc_value /= (IGP02E1000_PHY_CHANNEL_NUM - 2);\n\n\t \n\tphy->min_cable_length = (((agc_value - IGP02E1000_AGC_RANGE) > 0) ?\n\t\t\t\t (agc_value - IGP02E1000_AGC_RANGE) : 0);\n\tphy->max_cable_length = agc_value + IGP02E1000_AGC_RANGE;\n\n\tphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\n\n\treturn 0;\n}\n\n \ns32 e1000e_get_phy_info_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tif (phy->media_type != e1000_media_type_copper) {\n\t\te_dbg(\"Phy info is only valid for copper media\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!link) {\n\t\te_dbg(\"Phy info is only valid if link is up\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy->polarity_correction = !!(phy_data &\n\t\t\t\t      M88E1000_PSCR_POLARITY_REVERSAL);\n\n\tret_val = e1000_check_polarity_m88(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy->is_mdix = !!(phy_data & M88E1000_PSSR_MDIX);\n\n\tif ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {\n\t\tret_val = hw->phy.ops.get_cable_length(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1e_rphy(hw, MII_STAT1000, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy->local_rx = (phy_data & LPA_1000LOCALRXOK)\n\t\t    ? e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (phy_data & LPA_1000REMRXOK)\n\t\t    ? e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\t} else {\n\t\t \n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_get_phy_info_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!link) {\n\t\te_dbg(\"Phy info is only valid if link is up\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tphy->polarity_correction = true;\n\n\tret_val = e1000_check_polarity_igp(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_STATUS, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy->is_mdix = !!(data & IGP01E1000_PSSR_MDIX);\n\n\tif ((data & IGP01E1000_PSSR_SPEED_MASK) ==\n\t    IGP01E1000_PSSR_SPEED_1000MBPS) {\n\t\tret_val = phy->ops.get_cable_length(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1e_rphy(hw, MII_STAT1000, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy->local_rx = (data & LPA_1000LOCALRXOK)\n\t\t    ? e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (data & LPA_1000REMRXOK)\n\t\t    ? e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\t} else {\n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000_get_phy_info_ife(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!link) {\n\t\te_dbg(\"Phy info is only valid if link is up\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tret_val = e1e_rphy(hw, IFE_PHY_SPECIAL_CONTROL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\tphy->polarity_correction = !(data & IFE_PSC_AUTO_POLARITY_DISABLE);\n\n\tif (phy->polarity_correction) {\n\t\tret_val = e1000_check_polarity_ife(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else {\n\t\t \n\t\tphy->cable_polarity = ((data & IFE_PSC_FORCE_POLARITY)\n\t\t\t\t       ? e1000_rev_polarity_reversed\n\t\t\t\t       : e1000_rev_polarity_normal);\n\t}\n\n\tret_val = e1e_rphy(hw, IFE_PHY_MDIX_CONTROL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy->is_mdix = !!(data & IFE_PMC_MDIX_STATUS);\n\n\t \n\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\n\treturn 0;\n}\n\n \ns32 e1000e_phy_sw_reset(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_ctrl;\n\n\tret_val = e1e_rphy(hw, MII_BMCR, &phy_ctrl);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_ctrl |= BMCR_RESET;\n\tret_val = e1e_wphy(hw, MII_BMCR, phy_ctrl);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tudelay(1);\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_phy_hw_reset_generic(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu32 ctrl;\n\n\tif (phy->ops.check_reset_block) {\n\t\tret_val = phy->ops.check_reset_block(hw);\n\t\tif (ret_val)\n\t\t\treturn 0;\n\t}\n\n\tret_val = phy->ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tctrl = er32(CTRL);\n\tew32(CTRL, ctrl | E1000_CTRL_PHY_RST);\n\te1e_flush();\n\n\tudelay(phy->reset_delay_us);\n\n\tew32(CTRL, ctrl);\n\te1e_flush();\n\n\tusleep_range(150, 300);\n\n\tphy->ops.release(hw);\n\n\treturn phy->ops.get_cfg_done(hw);\n}\n\n \ns32 e1000e_get_cfg_done_generic(struct e1000_hw __always_unused *hw)\n{\n\tmdelay(10);\n\n\treturn 0;\n}\n\n \ns32 e1000e_phy_init_script_igp3(struct e1000_hw *hw)\n{\n\te_dbg(\"Running IGP 3 PHY init script\\n\");\n\n\t \n\t \n\te1e_wphy(hw, 0x2F5B, 0x9018);\n\t \n\te1e_wphy(hw, 0x2F52, 0x0000);\n\t \n\te1e_wphy(hw, 0x2FB1, 0x8B24);\n\t \n\te1e_wphy(hw, 0x2FB2, 0xF8F0);\n\t \n\te1e_wphy(hw, 0x2010, 0x10B0);\n\t \n\te1e_wphy(hw, 0x2011, 0x0000);\n\t \n\te1e_wphy(hw, 0x20DD, 0x249A);\n\t \n\te1e_wphy(hw, 0x20DE, 0x00D3);\n\t \n\te1e_wphy(hw, 0x28B4, 0x04CE);\n\t \n\te1e_wphy(hw, 0x2F70, 0x29E4);\n\t \n\te1e_wphy(hw, 0x0000, 0x0140);\n\t \n\te1e_wphy(hw, 0x1F30, 0x1606);\n\t \n\te1e_wphy(hw, 0x1F31, 0xB814);\n\t \n\te1e_wphy(hw, 0x1F35, 0x002A);\n\t \n\te1e_wphy(hw, 0x1F3E, 0x0067);\n\t \n\te1e_wphy(hw, 0x1F54, 0x0065);\n\t \n\te1e_wphy(hw, 0x1F55, 0x002A);\n\t \n\te1e_wphy(hw, 0x1F56, 0x002A);\n\t \n\te1e_wphy(hw, 0x1F72, 0x3FB0);\n\t \n\te1e_wphy(hw, 0x1F76, 0xC0FF);\n\t \n\te1e_wphy(hw, 0x1F77, 0x1DEC);\n\t \n\te1e_wphy(hw, 0x1F78, 0xF9EF);\n\t \n\te1e_wphy(hw, 0x1F79, 0x0210);\n\t \n\te1e_wphy(hw, 0x1895, 0x0003);\n\t \n\te1e_wphy(hw, 0x1796, 0x0008);\n\t \n\te1e_wphy(hw, 0x1798, 0xD008);\n\t \n\te1e_wphy(hw, 0x1898, 0xD918);\n\t \n\te1e_wphy(hw, 0x187A, 0x0800);\n\t \n\te1e_wphy(hw, 0x0019, 0x008D);\n\t \n\te1e_wphy(hw, 0x001B, 0x2080);\n\t \n\te1e_wphy(hw, 0x0014, 0x0045);\n\t \n\te1e_wphy(hw, 0x0000, 0x1340);\n\n\treturn 0;\n}\n\n \nenum e1000_phy_type e1000e_get_phy_type_from_id(u32 phy_id)\n{\n\tenum e1000_phy_type phy_type = e1000_phy_unknown;\n\n\tswitch (phy_id) {\n\tcase M88E1000_I_PHY_ID:\n\tcase M88E1000_E_PHY_ID:\n\tcase M88E1111_I_PHY_ID:\n\tcase M88E1011_I_PHY_ID:\n\t\tphy_type = e1000_phy_m88;\n\t\tbreak;\n\tcase IGP01E1000_I_PHY_ID:\t \n\t\tphy_type = e1000_phy_igp_2;\n\t\tbreak;\n\tcase GG82563_E_PHY_ID:\n\t\tphy_type = e1000_phy_gg82563;\n\t\tbreak;\n\tcase IGP03E1000_E_PHY_ID:\n\t\tphy_type = e1000_phy_igp_3;\n\t\tbreak;\n\tcase IFE_E_PHY_ID:\n\tcase IFE_PLUS_E_PHY_ID:\n\tcase IFE_C_E_PHY_ID:\n\t\tphy_type = e1000_phy_ife;\n\t\tbreak;\n\tcase BME1000_E_PHY_ID:\n\tcase BME1000_E_PHY_ID_R2:\n\t\tphy_type = e1000_phy_bm;\n\t\tbreak;\n\tcase I82578_E_PHY_ID:\n\t\tphy_type = e1000_phy_82578;\n\t\tbreak;\n\tcase I82577_E_PHY_ID:\n\t\tphy_type = e1000_phy_82577;\n\t\tbreak;\n\tcase I82579_E_PHY_ID:\n\t\tphy_type = e1000_phy_82579;\n\t\tbreak;\n\tcase I217_E_PHY_ID:\n\t\tphy_type = e1000_phy_i217;\n\t\tbreak;\n\tdefault:\n\t\tphy_type = e1000_phy_unknown;\n\t\tbreak;\n\t}\n\treturn phy_type;\n}\n\n \ns32 e1000e_determine_phy_address(struct e1000_hw *hw)\n{\n\tu32 phy_addr = 0;\n\tu32 i;\n\tenum e1000_phy_type phy_type = e1000_phy_unknown;\n\n\thw->phy.id = phy_type;\n\n\tfor (phy_addr = 0; phy_addr < E1000_MAX_PHY_ADDR; phy_addr++) {\n\t\thw->phy.addr = phy_addr;\n\t\ti = 0;\n\n\t\tdo {\n\t\t\te1000e_get_phy_id(hw);\n\t\t\tphy_type = e1000e_get_phy_type_from_id(hw->phy.id);\n\n\t\t\t \n\t\t\tif (phy_type != e1000_phy_unknown)\n\t\t\t\treturn 0;\n\n\t\t\tusleep_range(1000, 2000);\n\t\t\ti++;\n\t\t} while (i < 10);\n\t}\n\n\treturn -E1000_ERR_PHY_TYPE;\n}\n\n \nstatic u32 e1000_get_phy_addr_for_bm_page(u32 page, u32 reg)\n{\n\tu32 phy_addr = 2;\n\n\tif ((page >= 768) || (page == 0 && reg == 25) || (reg == 31))\n\t\tphy_addr = 1;\n\n\treturn phy_addr;\n}\n\n \ns32 e1000e_write_phy_reg_bm(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\ts32 ret_val;\n\tu32 page = offset >> IGP_PAGE_SHIFT;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, &data,\n\t\t\t\t\t\t\t false, false);\n\t\tgoto release;\n\t}\n\n\thw->phy.addr = e1000_get_phy_addr_for_bm_page(page, offset);\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\tu32 page_shift, page_select;\n\n\t\t \n\t\tif (hw->phy.addr == 1) {\n\t\t\tpage_shift = IGP_PAGE_SHIFT;\n\t\t\tpage_select = IGP01E1000_PHY_PAGE_SELECT;\n\t\t} else {\n\t\t\tpage_shift = 0;\n\t\t\tpage_select = BM_PHY_PAGE_SELECT;\n\t\t}\n\n\t\t \n\t\tret_val = e1000e_write_phy_reg_mdic(hw, page_select,\n\t\t\t\t\t\t    (page << page_shift));\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t    data);\n\nrelease:\n\thw->phy.ops.release(hw);\n\treturn ret_val;\n}\n\n \ns32 e1000e_read_phy_reg_bm(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\ts32 ret_val;\n\tu32 page = offset >> IGP_PAGE_SHIFT;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, data,\n\t\t\t\t\t\t\t true, false);\n\t\tgoto release;\n\t}\n\n\thw->phy.addr = e1000_get_phy_addr_for_bm_page(page, offset);\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\tu32 page_shift, page_select;\n\n\t\t \n\t\tif (hw->phy.addr == 1) {\n\t\t\tpage_shift = IGP_PAGE_SHIFT;\n\t\t\tpage_select = IGP01E1000_PHY_PAGE_SELECT;\n\t\t} else {\n\t\t\tpage_shift = 0;\n\t\t\tpage_select = BM_PHY_PAGE_SELECT;\n\t\t}\n\n\t\t \n\t\tret_val = e1000e_write_phy_reg_mdic(hw, page_select,\n\t\t\t\t\t\t    (page << page_shift));\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\tret_val = e1000e_read_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t   data);\nrelease:\n\thw->phy.ops.release(hw);\n\treturn ret_val;\n}\n\n \ns32 e1000e_read_phy_reg_bm2(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\ts32 ret_val;\n\tu16 page = (u16)(offset >> IGP_PAGE_SHIFT);\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, data,\n\t\t\t\t\t\t\t true, false);\n\t\tgoto release;\n\t}\n\n\thw->phy.addr = 1;\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\t \n\t\tret_val = e1000e_write_phy_reg_mdic(hw, BM_PHY_PAGE_SELECT,\n\t\t\t\t\t\t    page);\n\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\tret_val = e1000e_read_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t   data);\nrelease:\n\thw->phy.ops.release(hw);\n\treturn ret_val;\n}\n\n \ns32 e1000e_write_phy_reg_bm2(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\ts32 ret_val;\n\tu16 page = (u16)(offset >> IGP_PAGE_SHIFT);\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, &data,\n\t\t\t\t\t\t\t false, false);\n\t\tgoto release;\n\t}\n\n\thw->phy.addr = 1;\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\t \n\t\tret_val = e1000e_write_phy_reg_mdic(hw, BM_PHY_PAGE_SELECT,\n\t\t\t\t\t\t    page);\n\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t    data);\n\nrelease:\n\thw->phy.ops.release(hw);\n\treturn ret_val;\n}\n\n \ns32 e1000_enable_phy_wakeup_reg_access_bm(struct e1000_hw *hw, u16 *phy_reg)\n{\n\ts32 ret_val;\n\tu16 temp;\n\n\t \n\thw->phy.addr = 1;\n\n\t \n\tret_val = e1000_set_page_igp(hw, (BM_PORT_CTRL_PAGE << IGP_PAGE_SHIFT));\n\tif (ret_val) {\n\t\te_dbg(\"Could not set Port Control page\\n\");\n\t\treturn ret_val;\n\t}\n\n\tret_val = e1000e_read_phy_reg_mdic(hw, BM_WUC_ENABLE_REG, phy_reg);\n\tif (ret_val) {\n\t\te_dbg(\"Could not read PHY register %d.%d\\n\",\n\t\t      BM_PORT_CTRL_PAGE, BM_WUC_ENABLE_REG);\n\t\treturn ret_val;\n\t}\n\n\t \n\ttemp = *phy_reg;\n\ttemp |= BM_WUC_ENABLE_BIT;\n\ttemp &= ~(BM_WUC_ME_WU_BIT | BM_WUC_HOST_WU_BIT);\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, BM_WUC_ENABLE_REG, temp);\n\tif (ret_val) {\n\t\te_dbg(\"Could not write PHY register %d.%d\\n\",\n\t\t      BM_PORT_CTRL_PAGE, BM_WUC_ENABLE_REG);\n\t\treturn ret_val;\n\t}\n\n\t \n\treturn e1000_set_page_igp(hw, (BM_WUC_PAGE << IGP_PAGE_SHIFT));\n}\n\n \ns32 e1000_disable_phy_wakeup_reg_access_bm(struct e1000_hw *hw, u16 *phy_reg)\n{\n\ts32 ret_val;\n\n\t \n\tret_val = e1000_set_page_igp(hw, (BM_PORT_CTRL_PAGE << IGP_PAGE_SHIFT));\n\tif (ret_val) {\n\t\te_dbg(\"Could not set Port Control page\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tret_val = e1000e_write_phy_reg_mdic(hw, BM_WUC_ENABLE_REG, *phy_reg);\n\tif (ret_val)\n\t\te_dbg(\"Could not restore PHY register %d.%d\\n\",\n\t\t      BM_PORT_CTRL_PAGE, BM_WUC_ENABLE_REG);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_access_phy_wakeup_reg_bm(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u16 *data, bool read, bool page_set)\n{\n\ts32 ret_val;\n\tu16 reg = BM_PHY_REG_NUM(offset);\n\tu16 page = BM_PHY_REG_PAGE(offset);\n\tu16 phy_reg = 0;\n\n\t \n\tif ((hw->mac.type == e1000_pchlan) &&\n\t    (!(er32(PHY_CTRL) & E1000_PHY_CTRL_GBE_DISABLE)))\n\t\te_dbg(\"Attempting to access page %d while gig enabled.\\n\",\n\t\t      page);\n\n\tif (!page_set) {\n\t\t \n\t\tret_val = e1000_enable_phy_wakeup_reg_access_bm(hw, &phy_reg);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Could not enable PHY wakeup reg access\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\te_dbg(\"Accessing PHY page %d reg 0x%x\\n\", page, reg);\n\n\t \n\tret_val = e1000e_write_phy_reg_mdic(hw, BM_WUC_ADDRESS_OPCODE, reg);\n\tif (ret_val) {\n\t\te_dbg(\"Could not write address opcode to page %d\\n\", page);\n\t\treturn ret_val;\n\t}\n\n\tif (read) {\n\t\t \n\t\tret_val = e1000e_read_phy_reg_mdic(hw, BM_WUC_DATA_OPCODE,\n\t\t\t\t\t\t   data);\n\t} else {\n\t\t \n\t\tret_val = e1000e_write_phy_reg_mdic(hw, BM_WUC_DATA_OPCODE,\n\t\t\t\t\t\t    *data);\n\t}\n\n\tif (ret_val) {\n\t\te_dbg(\"Could not access PHY reg %d.%d\\n\", page, reg);\n\t\treturn ret_val;\n\t}\n\n\tif (!page_set)\n\t\tret_val = e1000_disable_phy_wakeup_reg_access_bm(hw, &phy_reg);\n\n\treturn ret_val;\n}\n\n \nvoid e1000_power_up_phy_copper(struct e1000_hw *hw)\n{\n\tu16 mii_reg = 0;\n\tint ret;\n\n\t \n\tret = e1e_rphy(hw, MII_BMCR, &mii_reg);\n\tif (ret) {\n\t\te_dbg(\"Error reading PHY register\\n\");\n\t\treturn;\n\t}\n\tmii_reg &= ~BMCR_PDOWN;\n\te1e_wphy(hw, MII_BMCR, mii_reg);\n}\n\n \nvoid e1000_power_down_phy_copper(struct e1000_hw *hw)\n{\n\tu16 mii_reg = 0;\n\tint ret;\n\n\t \n\tret = e1e_rphy(hw, MII_BMCR, &mii_reg);\n\tif (ret) {\n\t\te_dbg(\"Error reading PHY register\\n\");\n\t\treturn;\n\t}\n\tmii_reg |= BMCR_PDOWN;\n\te1e_wphy(hw, MII_BMCR, mii_reg);\n\tusleep_range(1000, 2000);\n}\n\n \nstatic s32 __e1000_read_phy_reg_hv(struct e1000_hw *hw, u32 offset, u16 *data,\n\t\t\t\t   bool locked, bool page_set)\n{\n\ts32 ret_val;\n\tu16 page = BM_PHY_REG_PAGE(offset);\n\tu16 reg = BM_PHY_REG_NUM(offset);\n\tu32 phy_addr = hw->phy.addr = e1000_get_phy_addr_for_hv_page(page);\n\n\tif (!locked) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, data,\n\t\t\t\t\t\t\t true, page_set);\n\t\tgoto out;\n\t}\n\n\tif (page > 0 && page < HV_INTC_FC_PAGE_START) {\n\t\tret_val = e1000_access_phy_debug_regs_hv(hw, offset,\n\t\t\t\t\t\t\t data, true);\n\t\tgoto out;\n\t}\n\n\tif (!page_set) {\n\t\tif (page == HV_INTC_FC_PAGE_START)\n\t\t\tpage = 0;\n\n\t\tif (reg > MAX_PHY_MULTI_PAGE_REG) {\n\t\t\t \n\t\t\tret_val = e1000_set_page_igp(hw,\n\t\t\t\t\t\t     (page << IGP_PAGE_SHIFT));\n\n\t\t\thw->phy.addr = phy_addr;\n\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\te_dbg(\"reading PHY page %d (or 0x%x shifted) reg 0x%x\\n\", page,\n\t      page << IGP_PAGE_SHIFT, reg);\n\n\tret_val = e1000e_read_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & reg, data);\nout:\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_read_phy_reg_hv(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn __e1000_read_phy_reg_hv(hw, offset, data, false, false);\n}\n\n \ns32 e1000_read_phy_reg_hv_locked(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn __e1000_read_phy_reg_hv(hw, offset, data, true, false);\n}\n\n \ns32 e1000_read_phy_reg_page_hv(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn __e1000_read_phy_reg_hv(hw, offset, data, true, true);\n}\n\n \nstatic s32 __e1000_write_phy_reg_hv(struct e1000_hw *hw, u32 offset, u16 data,\n\t\t\t\t    bool locked, bool page_set)\n{\n\ts32 ret_val;\n\tu16 page = BM_PHY_REG_PAGE(offset);\n\tu16 reg = BM_PHY_REG_NUM(offset);\n\tu32 phy_addr = hw->phy.addr = e1000_get_phy_addr_for_hv_page(page);\n\n\tif (!locked) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, &data,\n\t\t\t\t\t\t\t false, page_set);\n\t\tgoto out;\n\t}\n\n\tif (page > 0 && page < HV_INTC_FC_PAGE_START) {\n\t\tret_val = e1000_access_phy_debug_regs_hv(hw, offset,\n\t\t\t\t\t\t\t &data, false);\n\t\tgoto out;\n\t}\n\n\tif (!page_set) {\n\t\tif (page == HV_INTC_FC_PAGE_START)\n\t\t\tpage = 0;\n\n\t\t \n\t\tif ((hw->phy.type == e1000_phy_82578) &&\n\t\t    (hw->phy.revision >= 1) &&\n\t\t    (hw->phy.addr == 2) &&\n\t\t    !(MAX_PHY_REG_ADDRESS & reg) && (data & BIT(11))) {\n\t\t\tu16 data2 = 0x7EFF;\n\n\t\t\tret_val = e1000_access_phy_debug_regs_hv(hw,\n\t\t\t\t\t\t\t\t BIT(6) | 0x3,\n\t\t\t\t\t\t\t\t &data2, false);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (reg > MAX_PHY_MULTI_PAGE_REG) {\n\t\t\t \n\t\t\tret_val = e1000_set_page_igp(hw,\n\t\t\t\t\t\t     (page << IGP_PAGE_SHIFT));\n\n\t\t\thw->phy.addr = phy_addr;\n\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\te_dbg(\"writing PHY page %d (or 0x%x shifted) reg 0x%x\\n\", page,\n\t      page << IGP_PAGE_SHIFT, reg);\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & reg,\n\t\t\t\t\t    data);\n\nout:\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_write_phy_reg_hv(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn __e1000_write_phy_reg_hv(hw, offset, data, false, false);\n}\n\n \ns32 e1000_write_phy_reg_hv_locked(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn __e1000_write_phy_reg_hv(hw, offset, data, true, false);\n}\n\n \ns32 e1000_write_phy_reg_page_hv(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn __e1000_write_phy_reg_hv(hw, offset, data, true, true);\n}\n\n \nstatic u32 e1000_get_phy_addr_for_hv_page(u32 page)\n{\n\tu32 phy_addr = 2;\n\n\tif (page >= HV_INTC_FC_PAGE_START)\n\t\tphy_addr = 1;\n\n\treturn phy_addr;\n}\n\n \nstatic s32 e1000_access_phy_debug_regs_hv(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u16 *data, bool read)\n{\n\ts32 ret_val;\n\tu32 addr_reg;\n\tu32 data_reg;\n\n\t \n\taddr_reg = ((hw->phy.type == e1000_phy_82578) ?\n\t\t    I82578_ADDR_REG : I82577_ADDR_REG);\n\tdata_reg = addr_reg + 1;\n\n\t \n\thw->phy.addr = 2;\n\n\t \n\tret_val = e1000e_write_phy_reg_mdic(hw, addr_reg, (u16)offset & 0x3F);\n\tif (ret_val) {\n\t\te_dbg(\"Could not write the Address Offset port register\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tif (read)\n\t\tret_val = e1000e_read_phy_reg_mdic(hw, data_reg, data);\n\telse\n\t\tret_val = e1000e_write_phy_reg_mdic(hw, data_reg, *data);\n\n\tif (ret_val)\n\t\te_dbg(\"Could not access the Data port register\\n\");\n\n\treturn ret_val;\n}\n\n \ns32 e1000_link_stall_workaround_hv(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 data;\n\n\tif (hw->phy.type != e1000_phy_82578)\n\t\treturn 0;\n\n\t \n\tret_val = e1e_rphy(hw, MII_BMCR, &data);\n\tif (ret_val) {\n\t\te_dbg(\"Error reading PHY register\\n\");\n\t\treturn ret_val;\n\t}\n\tif (data & BMCR_LOOPBACK)\n\t\treturn 0;\n\n\t \n\tret_val = e1e_rphy(hw, BM_CS_STATUS, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata &= (BM_CS_STATUS_LINK_UP | BM_CS_STATUS_RESOLVED |\n\t\t BM_CS_STATUS_SPEED_MASK);\n\n\tif (data != (BM_CS_STATUS_LINK_UP | BM_CS_STATUS_RESOLVED |\n\t\t     BM_CS_STATUS_SPEED_1000))\n\t\treturn 0;\n\n\tmsleep(200);\n\n\t \n\tret_val = e1e_wphy(hw, HV_MUX_DATA_CTRL,\n\t\t\t   (HV_MUX_DATA_CTRL_GEN_TO_MAC |\n\t\t\t    HV_MUX_DATA_CTRL_FORCE_SPEED));\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1e_wphy(hw, HV_MUX_DATA_CTRL, HV_MUX_DATA_CTRL_GEN_TO_MAC);\n}\n\n \ns32 e1000_check_polarity_82577(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = e1e_rphy(hw, I82577_PHY_STATUS_2, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = ((data & I82577_PHY_STATUS2_REV_POLARITY)\n\t\t\t\t       ? e1000_rev_polarity_reversed\n\t\t\t\t       : e1000_rev_polarity_normal);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_phy_force_speed_duplex_82577(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tret_val = e1e_rphy(hw, MII_BMCR, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te1000e_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\tret_val = e1e_wphy(hw, MII_BMCR, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tudelay(1);\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\te_dbg(\"Waiting for forced speed/duplex link on 82577 phy\\n\");\n\n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!link)\n\t\t\te_dbg(\"Link taking longer than expected.\\n\");\n\n\t\t \n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000_get_phy_info_82577(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!link) {\n\t\te_dbg(\"Phy info is only valid if link is up\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tphy->polarity_correction = true;\n\n\tret_val = e1000_check_polarity_82577(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1e_rphy(hw, I82577_PHY_STATUS_2, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy->is_mdix = !!(data & I82577_PHY_STATUS2_MDIX);\n\n\tif ((data & I82577_PHY_STATUS2_SPEED_MASK) ==\n\t    I82577_PHY_STATUS2_SPEED_1000MBPS) {\n\t\tret_val = hw->phy.ops.get_cable_length(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1e_rphy(hw, MII_STAT1000, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy->local_rx = (data & LPA_1000LOCALRXOK)\n\t\t    ? e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (data & LPA_1000REMRXOK)\n\t\t    ? e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\t} else {\n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000_get_cable_length_82577(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, length;\n\n\tret_val = e1e_rphy(hw, I82577_PHY_DIAG_STATUS, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tlength = ((phy_data & I82577_DSTATUS_CABLE_LENGTH) >>\n\t\t  I82577_DSTATUS_CABLE_LENGTH_SHIFT);\n\n\tif (length == E1000_CABLE_LENGTH_UNDEFINED)\n\t\treturn -E1000_ERR_PHY;\n\n\tphy->cable_length = length;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}