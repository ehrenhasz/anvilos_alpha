{
  "module_name": "mac.c",
  "hash_id": "3dbe9b3bcbcc6e7175c1b34edd3dbe97fd6cb9c6d39210f7d745064f035fb726",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/mac.c",
  "human_readable_source": "\n \n\n#include \"e1000.h\"\n\n \ns32 e1000e_get_bus_info_pcie(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tstruct e1000_bus_info *bus = &hw->bus;\n\tstruct e1000_adapter *adapter = hw->adapter;\n\tu16 pcie_link_status, cap_offset;\n\n\tcap_offset = adapter->pdev->pcie_cap;\n\tif (!cap_offset) {\n\t\tbus->width = e1000_bus_width_unknown;\n\t} else {\n\t\tpci_read_config_word(adapter->pdev,\n\t\t\t\t     cap_offset + PCIE_LINK_STATUS,\n\t\t\t\t     &pcie_link_status);\n\t\tbus->width = (enum e1000_bus_width)((pcie_link_status &\n\t\t\t\t\t\t     PCIE_LINK_WIDTH_MASK) >>\n\t\t\t\t\t\t    PCIE_LINK_WIDTH_SHIFT);\n\t}\n\n\tmac->ops.set_lan_id(hw);\n\n\treturn 0;\n}\n\n \nvoid e1000_set_lan_id_multi_port_pcie(struct e1000_hw *hw)\n{\n\tstruct e1000_bus_info *bus = &hw->bus;\n\tu32 reg;\n\n\t \n\treg = er32(STATUS);\n\tbus->func = (reg & E1000_STATUS_FUNC_MASK) >> E1000_STATUS_FUNC_SHIFT;\n}\n\n \nvoid e1000_set_lan_id_single_port(struct e1000_hw *hw)\n{\n\tstruct e1000_bus_info *bus = &hw->bus;\n\n\tbus->func = 0;\n}\n\n \nvoid e1000_clear_vfta_generic(struct e1000_hw *hw)\n{\n\tu32 offset;\n\n\tfor (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_VFTA, offset, 0);\n\t\te1e_flush();\n\t}\n}\n\n \nvoid e1000_write_vfta_generic(struct e1000_hw *hw, u32 offset, u32 value)\n{\n\tE1000_WRITE_REG_ARRAY(hw, E1000_VFTA, offset, value);\n\te1e_flush();\n}\n\n \nvoid e1000e_init_rx_addrs(struct e1000_hw *hw, u16 rar_count)\n{\n\tu32 i;\n\tu8 mac_addr[ETH_ALEN] = { 0 };\n\n\t \n\te_dbg(\"Programming MAC Address into RAR[0]\\n\");\n\n\thw->mac.ops.rar_set(hw, hw->mac.addr, 0);\n\n\t \n\te_dbg(\"Clearing RAR[1-%u]\\n\", rar_count - 1);\n\tfor (i = 1; i < rar_count; i++)\n\t\thw->mac.ops.rar_set(hw, mac_addr, i);\n}\n\n \ns32 e1000_check_alt_mac_addr_generic(struct e1000_hw *hw)\n{\n\tu32 i;\n\ts32 ret_val;\n\tu16 offset, nvm_alt_mac_addr_offset, nvm_data;\n\tu8 alt_mac_addr[ETH_ALEN];\n\n\tret_val = e1000_read_nvm(hw, NVM_COMPAT, 1, &nvm_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (hw->mac.type == e1000_82573)\n\t\treturn 0;\n\n\tret_val = e1000_read_nvm(hw, NVM_ALT_MAC_ADDR_PTR, 1,\n\t\t\t\t &nvm_alt_mac_addr_offset);\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tif ((nvm_alt_mac_addr_offset == 0xFFFF) ||\n\t    (nvm_alt_mac_addr_offset == 0x0000))\n\t\t \n\t\treturn 0;\n\n\tif (hw->bus.func == E1000_FUNC_1)\n\t\tnvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN1;\n\tfor (i = 0; i < ETH_ALEN; i += 2) {\n\t\toffset = nvm_alt_mac_addr_offset + (i >> 1);\n\t\tret_val = e1000_read_nvm(hw, offset, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"NVM Read Error\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\talt_mac_addr[i] = (u8)(nvm_data & 0xFF);\n\t\talt_mac_addr[i + 1] = (u8)(nvm_data >> 8);\n\t}\n\n\t \n\tif (is_multicast_ether_addr(alt_mac_addr)) {\n\t\te_dbg(\"Ignoring Alternate Mac Address with MC bit set\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\thw->mac.ops.rar_set(hw, alt_mac_addr, 0);\n\n\treturn 0;\n}\n\nu32 e1000e_rar_get_count_generic(struct e1000_hw *hw)\n{\n\treturn hw->mac.rar_entry_count;\n}\n\n \nint e1000e_rar_set_generic(struct e1000_hw *hw, u8 *addr, u32 index)\n{\n\tu32 rar_low, rar_high;\n\n\t \n\trar_low = ((u32)addr[0] | ((u32)addr[1] << 8) |\n\t\t   ((u32)addr[2] << 16) | ((u32)addr[3] << 24));\n\n\trar_high = ((u32)addr[4] | ((u32)addr[5] << 8));\n\n\t \n\tif (rar_low || rar_high)\n\t\trar_high |= E1000_RAH_AV;\n\n\t \n\tew32(RAL(index), rar_low);\n\te1e_flush();\n\tew32(RAH(index), rar_high);\n\te1e_flush();\n\n\treturn 0;\n}\n\n \nstatic u32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)\n{\n\tu32 hash_value, hash_mask;\n\tu8 bit_shift = 0;\n\n\t \n\thash_mask = (hw->mac.mta_reg_count * 32) - 1;\n\n\t \n\twhile (hash_mask >> bit_shift != 0xFF)\n\t\tbit_shift++;\n\n\t \n\tswitch (hw->mac.mc_filter_type) {\n\tdefault:\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tbit_shift += 1;\n\t\tbreak;\n\tcase 2:\n\t\tbit_shift += 2;\n\t\tbreak;\n\tcase 3:\n\t\tbit_shift += 4;\n\t\tbreak;\n\t}\n\n\thash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\n\t\t\t\t   (((u16)mc_addr[5]) << bit_shift)));\n\n\treturn hash_value;\n}\n\n \nvoid e1000e_update_mc_addr_list_generic(struct e1000_hw *hw,\n\t\t\t\t\tu8 *mc_addr_list, u32 mc_addr_count)\n{\n\tu32 hash_value, hash_bit, hash_reg;\n\tint i;\n\n\t \n\tmemset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));\n\n\t \n\tfor (i = 0; (u32)i < mc_addr_count; i++) {\n\t\thash_value = e1000_hash_mc_addr(hw, mc_addr_list);\n\n\t\thash_reg = (hash_value >> 5) & (hw->mac.mta_reg_count - 1);\n\t\thash_bit = hash_value & 0x1F;\n\n\t\thw->mac.mta_shadow[hash_reg] |= BIT(hash_bit);\n\t\tmc_addr_list += (ETH_ALEN);\n\t}\n\n\t \n\tfor (i = hw->mac.mta_reg_count - 1; i >= 0; i--)\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, hw->mac.mta_shadow[i]);\n\te1e_flush();\n}\n\n \nvoid e1000e_clear_hw_cntrs_base(struct e1000_hw *hw)\n{\n\ter32(CRCERRS);\n\ter32(SYMERRS);\n\ter32(MPC);\n\ter32(SCC);\n\ter32(ECOL);\n\ter32(MCC);\n\ter32(LATECOL);\n\ter32(COLC);\n\ter32(DC);\n\ter32(SEC);\n\ter32(RLEC);\n\ter32(XONRXC);\n\ter32(XONTXC);\n\ter32(XOFFRXC);\n\ter32(XOFFTXC);\n\ter32(FCRUC);\n\ter32(GPRC);\n\ter32(BPRC);\n\ter32(MPRC);\n\ter32(GPTC);\n\ter32(GORCL);\n\ter32(GORCH);\n\ter32(GOTCL);\n\ter32(GOTCH);\n\ter32(RNBC);\n\ter32(RUC);\n\ter32(RFC);\n\ter32(ROC);\n\ter32(RJC);\n\ter32(TORL);\n\ter32(TORH);\n\ter32(TOTL);\n\ter32(TOTH);\n\ter32(TPR);\n\ter32(TPT);\n\ter32(MPTC);\n\ter32(BPTC);\n}\n\n \ns32 e1000e_check_for_copper_link(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val;\n\tbool link;\n\n\t \n\tif (!mac->get_link_status)\n\t\treturn 0;\n\tmac->get_link_status = false;\n\n\t \n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val || !link)\n\t\tgoto out;\n\n\t \n\te1000e_check_downshift(hw);\n\n\t \n\tif (!mac->autoneg)\n\t\treturn -E1000_ERR_CONFIG;\n\n\t \n\tmac->ops.config_collision_dist(hw);\n\n\t \n\tret_val = e1000e_config_fc_after_link_up(hw);\n\tif (ret_val)\n\t\te_dbg(\"Error configuring flow control\\n\");\n\n\treturn ret_val;\n\nout:\n\tmac->get_link_status = true;\n\treturn ret_val;\n}\n\n \ns32 e1000e_check_for_fiber_link(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 rxcw;\n\tu32 ctrl;\n\tu32 status;\n\ts32 ret_val;\n\n\tctrl = er32(CTRL);\n\tstatus = er32(STATUS);\n\trxcw = er32(RXCW);\n\n\t \n\t \n\tif ((ctrl & E1000_CTRL_SWDPIN1) && !(status & E1000_STATUS_LU) &&\n\t    !(rxcw & E1000_RXCW_C)) {\n\t\tif (!mac->autoneg_failed) {\n\t\t\tmac->autoneg_failed = true;\n\t\t\treturn 0;\n\t\t}\n\t\te_dbg(\"NOT Rx'ing /C/, disable AutoNeg and force link.\\n\");\n\n\t\t \n\t\tew32(TXCW, (mac->txcw & ~E1000_TXCW_ANE));\n\n\t\t \n\t\tctrl = er32(CTRL);\n\t\tctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);\n\t\tew32(CTRL, ctrl);\n\n\t\t \n\t\tret_val = e1000e_config_fc_after_link_up(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error configuring flow control\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t} else if ((ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {\n\t\t \n\t\te_dbg(\"Rx'ing /C/, enable AutoNeg and stop forcing link.\\n\");\n\t\tew32(TXCW, mac->txcw);\n\t\tew32(CTRL, (ctrl & ~E1000_CTRL_SLU));\n\n\t\tmac->serdes_has_link = true;\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_check_for_serdes_link(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 rxcw;\n\tu32 ctrl;\n\tu32 status;\n\ts32 ret_val;\n\n\tctrl = er32(CTRL);\n\tstatus = er32(STATUS);\n\trxcw = er32(RXCW);\n\n\t \n\t \n\tif (!(status & E1000_STATUS_LU) && !(rxcw & E1000_RXCW_C)) {\n\t\tif (!mac->autoneg_failed) {\n\t\t\tmac->autoneg_failed = true;\n\t\t\treturn 0;\n\t\t}\n\t\te_dbg(\"NOT Rx'ing /C/, disable AutoNeg and force link.\\n\");\n\n\t\t \n\t\tew32(TXCW, (mac->txcw & ~E1000_TXCW_ANE));\n\n\t\t \n\t\tctrl = er32(CTRL);\n\t\tctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);\n\t\tew32(CTRL, ctrl);\n\n\t\t \n\t\tret_val = e1000e_config_fc_after_link_up(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error configuring flow control\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t} else if ((ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {\n\t\t \n\t\te_dbg(\"Rx'ing /C/, enable AutoNeg and stop forcing link.\\n\");\n\t\tew32(TXCW, mac->txcw);\n\t\tew32(CTRL, (ctrl & ~E1000_CTRL_SLU));\n\n\t\tmac->serdes_has_link = true;\n\t} else if (!(E1000_TXCW_ANE & er32(TXCW))) {\n\t\t \n\t\t \n\t\tusleep_range(10, 20);\n\t\trxcw = er32(RXCW);\n\t\tif (rxcw & E1000_RXCW_SYNCH) {\n\t\t\tif (!(rxcw & E1000_RXCW_IV)) {\n\t\t\t\tmac->serdes_has_link = true;\n\t\t\t\te_dbg(\"SERDES: Link up - forced.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tmac->serdes_has_link = false;\n\t\t\te_dbg(\"SERDES: Link down - force failed.\\n\");\n\t\t}\n\t}\n\n\tif (E1000_TXCW_ANE & er32(TXCW)) {\n\t\tstatus = er32(STATUS);\n\t\tif (status & E1000_STATUS_LU) {\n\t\t\t \n\t\t\tusleep_range(10, 20);\n\t\t\trxcw = er32(RXCW);\n\t\t\tif (rxcw & E1000_RXCW_SYNCH) {\n\t\t\t\tif (!(rxcw & E1000_RXCW_IV)) {\n\t\t\t\t\tmac->serdes_has_link = true;\n\t\t\t\t\te_dbg(\"SERDES: Link up - autoneg completed successfully.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tmac->serdes_has_link = false;\n\t\t\t\t\te_dbg(\"SERDES: Link down - invalid codewords detected in autoneg.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmac->serdes_has_link = false;\n\t\t\t\te_dbg(\"SERDES: Link down - no sync.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tmac->serdes_has_link = false;\n\t\t\te_dbg(\"SERDES: Link down - autoneg failed\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_set_default_fc_generic(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 nvm_data;\n\n\t \n\tret_val = e1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &nvm_data);\n\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tif (!(nvm_data & NVM_WORD0F_PAUSE_MASK))\n\t\thw->fc.requested_mode = e1000_fc_none;\n\telse if ((nvm_data & NVM_WORD0F_PAUSE_MASK) == NVM_WORD0F_ASM_DIR)\n\t\thw->fc.requested_mode = e1000_fc_tx_pause;\n\telse\n\t\thw->fc.requested_mode = e1000_fc_full;\n\n\treturn 0;\n}\n\n \ns32 e1000e_setup_link_generic(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\t \n\tif (hw->phy.ops.check_reset_block && hw->phy.ops.check_reset_block(hw))\n\t\treturn 0;\n\n\t \n\tif (hw->fc.requested_mode == e1000_fc_default) {\n\t\tret_val = e1000_set_default_fc_generic(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\thw->fc.current_mode = hw->fc.requested_mode;\n\n\te_dbg(\"After fix-ups FlowControl is now = %x\\n\", hw->fc.current_mode);\n\n\t \n\tret_val = hw->mac.ops.setup_physical_interface(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\te_dbg(\"Initializing the Flow Control address, type and timer regs\\n\");\n\tew32(FCT, FLOW_CONTROL_TYPE);\n\tew32(FCAH, FLOW_CONTROL_ADDRESS_HIGH);\n\tew32(FCAL, FLOW_CONTROL_ADDRESS_LOW);\n\n\tew32(FCTTV, hw->fc.pause_time);\n\n\treturn e1000e_set_fc_watermarks(hw);\n}\n\n \nstatic s32 e1000_commit_fc_settings_generic(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 txcw;\n\n\t \n\tswitch (hw->fc.current_mode) {\n\tcase e1000_fc_none:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD);\n\t\tbreak;\n\tcase e1000_fc_rx_pause:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);\n\t\tbreak;\n\tcase e1000_fc_tx_pause:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);\n\t\tbreak;\n\tcase e1000_fc_full:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Flow control param set incorrectly\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tew32(TXCW, txcw);\n\tmac->txcw = txcw;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_poll_fiber_serdes_link_generic(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 i, status;\n\ts32 ret_val;\n\n\t \n\tfor (i = 0; i < FIBER_LINK_UP_LIMIT; i++) {\n\t\tusleep_range(10000, 11000);\n\t\tstatus = er32(STATUS);\n\t\tif (status & E1000_STATUS_LU)\n\t\t\tbreak;\n\t}\n\tif (i == FIBER_LINK_UP_LIMIT) {\n\t\te_dbg(\"Never got a valid link from auto-neg!!!\\n\");\n\t\tmac->autoneg_failed = true;\n\t\t \n\t\tret_val = mac->ops.check_for_link(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error while checking for link\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tmac->autoneg_failed = false;\n\t} else {\n\t\tmac->autoneg_failed = false;\n\t\te_dbg(\"Valid Link Found\\n\");\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_setup_fiber_serdes_link(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\n\tctrl = er32(CTRL);\n\n\t \n\tctrl &= ~E1000_CTRL_LRST;\n\n\thw->mac.ops.config_collision_dist(hw);\n\n\tret_val = e1000_commit_fc_settings_generic(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\te_dbg(\"Auto-negotiation enabled\\n\");\n\n\tew32(CTRL, ctrl);\n\te1e_flush();\n\tusleep_range(1000, 2000);\n\n\t \n\tif (hw->phy.media_type == e1000_media_type_internal_serdes ||\n\t    (er32(CTRL) & E1000_CTRL_SWDPIN1)) {\n\t\tret_val = e1000_poll_fiber_serdes_link_generic(hw);\n\t} else {\n\t\te_dbg(\"No signal detected\\n\");\n\t}\n\n\treturn ret_val;\n}\n\n \nvoid e1000e_config_collision_dist_generic(struct e1000_hw *hw)\n{\n\tu32 tctl;\n\n\ttctl = er32(TCTL);\n\n\ttctl &= ~E1000_TCTL_COLD;\n\ttctl |= E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT;\n\n\tew32(TCTL, tctl);\n\te1e_flush();\n}\n\n \ns32 e1000e_set_fc_watermarks(struct e1000_hw *hw)\n{\n\tu32 fcrtl = 0, fcrth = 0;\n\n\t \n\tif (hw->fc.current_mode & e1000_fc_tx_pause) {\n\t\t \n\t\tfcrtl = hw->fc.low_water;\n\t\tif (hw->fc.send_xon)\n\t\t\tfcrtl |= E1000_FCRTL_XONE;\n\n\t\tfcrth = hw->fc.high_water;\n\t}\n\tew32(FCRTL, fcrtl);\n\tew32(FCRTH, fcrth);\n\n\treturn 0;\n}\n\n \ns32 e1000e_force_mac_fc(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\n\tctrl = er32(CTRL);\n\n\t \n\te_dbg(\"hw->fc.current_mode = %u\\n\", hw->fc.current_mode);\n\n\tswitch (hw->fc.current_mode) {\n\tcase e1000_fc_none:\n\t\tctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));\n\t\tbreak;\n\tcase e1000_fc_rx_pause:\n\t\tctrl &= (~E1000_CTRL_TFCE);\n\t\tctrl |= E1000_CTRL_RFCE;\n\t\tbreak;\n\tcase e1000_fc_tx_pause:\n\t\tctrl &= (~E1000_CTRL_RFCE);\n\t\tctrl |= E1000_CTRL_TFCE;\n\t\tbreak;\n\tcase e1000_fc_full:\n\t\tctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Flow control param set incorrectly\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tew32(CTRL, ctrl);\n\n\treturn 0;\n}\n\n \ns32 e1000e_config_fc_after_link_up(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val = 0;\n\tu32 pcs_status_reg, pcs_adv_reg, pcs_lp_ability_reg, pcs_ctrl_reg;\n\tu16 mii_status_reg, mii_nway_adv_reg, mii_nway_lp_ability_reg;\n\tu16 speed, duplex;\n\n\t \n\tif (mac->autoneg_failed) {\n\t\tif (hw->phy.media_type == e1000_media_type_fiber ||\n\t\t    hw->phy.media_type == e1000_media_type_internal_serdes)\n\t\t\tret_val = e1000e_force_mac_fc(hw);\n\t} else {\n\t\tif (hw->phy.media_type == e1000_media_type_copper)\n\t\t\tret_val = e1000e_force_mac_fc(hw);\n\t}\n\n\tif (ret_val) {\n\t\te_dbg(\"Error forcing flow control settings\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tif ((hw->phy.media_type == e1000_media_type_copper) && mac->autoneg) {\n\t\t \n\t\tret_val = e1e_rphy(hw, MII_BMSR, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1e_rphy(hw, MII_BMSR, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!(mii_status_reg & BMSR_ANEGCOMPLETE)) {\n\t\t\te_dbg(\"Copper PHY and Auto Neg has not completed.\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\tret_val = e1e_rphy(hw, MII_ADVERTISE, &mii_nway_adv_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1e_rphy(hw, MII_LPA, &mii_nway_lp_ability_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tif ((mii_nway_adv_reg & ADVERTISE_PAUSE_CAP) &&\n\t\t    (mii_nway_lp_ability_reg & LPA_PAUSE_CAP)) {\n\t\t\t \n\t\t\tif (hw->fc.requested_mode == e1000_fc_full) {\n\t\t\t\thw->fc.current_mode = e1000_fc_full;\n\t\t\t\te_dbg(\"Flow Control = FULL.\\n\");\n\t\t\t} else {\n\t\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\t\te_dbg(\"Flow Control = Rx PAUSE frames only.\\n\");\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (!(mii_nway_adv_reg & ADVERTISE_PAUSE_CAP) &&\n\t\t\t (mii_nway_adv_reg & ADVERTISE_PAUSE_ASYM) &&\n\t\t\t (mii_nway_lp_ability_reg & LPA_PAUSE_CAP) &&\n\t\t\t (mii_nway_lp_ability_reg & LPA_PAUSE_ASYM)) {\n\t\t\thw->fc.current_mode = e1000_fc_tx_pause;\n\t\t\te_dbg(\"Flow Control = Tx PAUSE frames only.\\n\");\n\t\t}\n\t\t \n\t\telse if ((mii_nway_adv_reg & ADVERTISE_PAUSE_CAP) &&\n\t\t\t (mii_nway_adv_reg & ADVERTISE_PAUSE_ASYM) &&\n\t\t\t !(mii_nway_lp_ability_reg & LPA_PAUSE_CAP) &&\n\t\t\t (mii_nway_lp_ability_reg & LPA_PAUSE_ASYM)) {\n\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\te_dbg(\"Flow Control = Rx PAUSE frames only.\\n\");\n\t\t} else {\n\t\t\t \n\t\t\thw->fc.current_mode = e1000_fc_none;\n\t\t\te_dbg(\"Flow Control = NONE.\\n\");\n\t\t}\n\n\t\t \n\t\tret_val = mac->ops.get_link_up_info(hw, &speed, &duplex);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error getting link speed and duplex\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tif (duplex == HALF_DUPLEX)\n\t\t\thw->fc.current_mode = e1000_fc_none;\n\n\t\t \n\t\tret_val = e1000e_force_mac_fc(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error forcing flow control settings\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tif ((hw->phy.media_type == e1000_media_type_internal_serdes) &&\n\t    mac->autoneg) {\n\t\t \n\t\tpcs_status_reg = er32(PCS_LSTAT);\n\n\t\tif (!(pcs_status_reg & E1000_PCS_LSTS_AN_COMPLETE)) {\n\t\t\te_dbg(\"PCS Auto Neg has not completed.\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\tpcs_adv_reg = er32(PCS_ANADV);\n\t\tpcs_lp_ability_reg = er32(PCS_LPAB);\n\n\t\t \n\t\tif ((pcs_adv_reg & E1000_TXCW_PAUSE) &&\n\t\t    (pcs_lp_ability_reg & E1000_TXCW_PAUSE)) {\n\t\t\t \n\t\t\tif (hw->fc.requested_mode == e1000_fc_full) {\n\t\t\t\thw->fc.current_mode = e1000_fc_full;\n\t\t\t\te_dbg(\"Flow Control = FULL.\\n\");\n\t\t\t} else {\n\t\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\t\te_dbg(\"Flow Control = Rx PAUSE frames only.\\n\");\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (!(pcs_adv_reg & E1000_TXCW_PAUSE) &&\n\t\t\t (pcs_adv_reg & E1000_TXCW_ASM_DIR) &&\n\t\t\t (pcs_lp_ability_reg & E1000_TXCW_PAUSE) &&\n\t\t\t (pcs_lp_ability_reg & E1000_TXCW_ASM_DIR)) {\n\t\t\thw->fc.current_mode = e1000_fc_tx_pause;\n\t\t\te_dbg(\"Flow Control = Tx PAUSE frames only.\\n\");\n\t\t}\n\t\t \n\t\telse if ((pcs_adv_reg & E1000_TXCW_PAUSE) &&\n\t\t\t (pcs_adv_reg & E1000_TXCW_ASM_DIR) &&\n\t\t\t !(pcs_lp_ability_reg & E1000_TXCW_PAUSE) &&\n\t\t\t (pcs_lp_ability_reg & E1000_TXCW_ASM_DIR)) {\n\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\te_dbg(\"Flow Control = Rx PAUSE frames only.\\n\");\n\t\t} else {\n\t\t\t \n\t\t\thw->fc.current_mode = e1000_fc_none;\n\t\t\te_dbg(\"Flow Control = NONE.\\n\");\n\t\t}\n\n\t\t \n\t\tpcs_ctrl_reg = er32(PCS_LCTL);\n\t\tpcs_ctrl_reg |= E1000_PCS_LCTL_FORCE_FCTRL;\n\t\tew32(PCS_LCTL, pcs_ctrl_reg);\n\n\t\tret_val = e1000e_force_mac_fc(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error forcing flow control settings\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_get_speed_and_duplex_copper(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t       u16 *duplex)\n{\n\tu32 status;\n\n\tstatus = er32(STATUS);\n\tif (status & E1000_STATUS_SPEED_1000)\n\t\t*speed = SPEED_1000;\n\telse if (status & E1000_STATUS_SPEED_100)\n\t\t*speed = SPEED_100;\n\telse\n\t\t*speed = SPEED_10;\n\n\tif (status & E1000_STATUS_FD)\n\t\t*duplex = FULL_DUPLEX;\n\telse\n\t\t*duplex = HALF_DUPLEX;\n\n\te_dbg(\"%u Mbps, %s Duplex\\n\",\n\t      *speed == SPEED_1000 ? 1000 : *speed == SPEED_100 ? 100 : 10,\n\t      *duplex == FULL_DUPLEX ? \"Full\" : \"Half\");\n\n\treturn 0;\n}\n\n \ns32 e1000e_get_speed_and_duplex_fiber_serdes(struct e1000_hw __always_unused\n\t\t\t\t\t     *hw, u16 *speed, u16 *duplex)\n{\n\t*speed = SPEED_1000;\n\t*duplex = FULL_DUPLEX;\n\n\treturn 0;\n}\n\n \ns32 e1000e_get_hw_semaphore(struct e1000_hw *hw)\n{\n\tu32 swsm;\n\ts32 timeout = hw->nvm.word_size + 1;\n\ts32 i = 0;\n\n\t \n\twhile (i < timeout) {\n\t\tswsm = er32(SWSM);\n\t\tif (!(swsm & E1000_SWSM_SMBI))\n\t\t\tbreak;\n\n\t\tudelay(100);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\te_dbg(\"Driver can't access device - SMBI bit is set.\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tswsm = er32(SWSM);\n\t\tew32(SWSM, swsm | E1000_SWSM_SWESMBI);\n\n\t\t \n\t\tif (er32(SWSM) & E1000_SWSM_SWESMBI)\n\t\t\tbreak;\n\n\t\tudelay(100);\n\t}\n\n\tif (i == timeout) {\n\t\t \n\t\te1000e_put_hw_semaphore(hw);\n\t\te_dbg(\"Driver can't access the NVM\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\treturn 0;\n}\n\n \nvoid e1000e_put_hw_semaphore(struct e1000_hw *hw)\n{\n\tu32 swsm;\n\n\tswsm = er32(SWSM);\n\tswsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);\n\tew32(SWSM, swsm);\n}\n\n \ns32 e1000e_get_auto_rd_done(struct e1000_hw *hw)\n{\n\ts32 i = 0;\n\n\twhile (i < AUTO_READ_DONE_TIMEOUT) {\n\t\tif (er32(EECD) & E1000_EECD_AUTO_RD)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\ti++;\n\t}\n\n\tif (i == AUTO_READ_DONE_TIMEOUT) {\n\t\te_dbg(\"Auto read by HW from NVM has not completed.\\n\");\n\t\treturn -E1000_ERR_RESET;\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_valid_led_default(struct e1000_hw *hw, u16 *data)\n{\n\ts32 ret_val;\n\n\tret_val = e1000_read_nvm(hw, NVM_ID_LED_SETTINGS, 1, data);\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tif (*data == ID_LED_RESERVED_0000 || *data == ID_LED_RESERVED_FFFF)\n\t\t*data = ID_LED_DEFAULT;\n\n\treturn 0;\n}\n\n \ns32 e1000e_id_led_init_generic(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val;\n\tconst u32 ledctl_mask = 0x000000FF;\n\tconst u32 ledctl_on = E1000_LEDCTL_MODE_LED_ON;\n\tconst u32 ledctl_off = E1000_LEDCTL_MODE_LED_OFF;\n\tu16 data, i, temp;\n\tconst u16 led_mask = 0x0F;\n\n\tret_val = hw->nvm.ops.valid_led_default(hw, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tmac->ledctl_default = er32(LEDCTL);\n\tmac->ledctl_mode1 = mac->ledctl_default;\n\tmac->ledctl_mode2 = mac->ledctl_default;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttemp = (data >> (i << 2)) & led_mask;\n\t\tswitch (temp) {\n\t\tcase ID_LED_ON1_DEF2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\t\tmac->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode1 |= ledctl_on << (i << 3);\n\t\t\tbreak;\n\t\tcase ID_LED_OFF1_DEF2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\tmac->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode1 |= ledctl_off << (i << 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tswitch (temp) {\n\t\tcase ID_LED_DEF1_ON2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\t\tmac->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode2 |= ledctl_on << (i << 3);\n\t\t\tbreak;\n\t\tcase ID_LED_DEF1_OFF2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\tmac->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode2 |= ledctl_off << (i << 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_setup_led_generic(struct e1000_hw *hw)\n{\n\tu32 ledctl;\n\n\tif (hw->mac.ops.setup_led != e1000e_setup_led_generic)\n\t\treturn -E1000_ERR_CONFIG;\n\n\tif (hw->phy.media_type == e1000_media_type_fiber) {\n\t\tledctl = er32(LEDCTL);\n\t\thw->mac.ledctl_default = ledctl;\n\t\t \n\t\tledctl &= ~(E1000_LEDCTL_LED0_IVRT | E1000_LEDCTL_LED0_BLINK |\n\t\t\t    E1000_LEDCTL_LED0_MODE_MASK);\n\t\tledctl |= (E1000_LEDCTL_MODE_LED_OFF <<\n\t\t\t   E1000_LEDCTL_LED0_MODE_SHIFT);\n\t\tew32(LEDCTL, ledctl);\n\t} else if (hw->phy.media_type == e1000_media_type_copper) {\n\t\tew32(LEDCTL, hw->mac.ledctl_mode1);\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_cleanup_led_generic(struct e1000_hw *hw)\n{\n\tew32(LEDCTL, hw->mac.ledctl_default);\n\treturn 0;\n}\n\n \ns32 e1000e_blink_led_generic(struct e1000_hw *hw)\n{\n\tu32 ledctl_blink = 0;\n\tu32 i;\n\n\tif (hw->phy.media_type == e1000_media_type_fiber) {\n\t\t \n\t\tledctl_blink = E1000_LEDCTL_LED0_BLINK |\n\t\t    (E1000_LEDCTL_MODE_LED_ON << E1000_LEDCTL_LED0_MODE_SHIFT);\n\t} else {\n\t\t \n\t\tledctl_blink = hw->mac.ledctl_mode2;\n\t\tfor (i = 0; i < 32; i += 8) {\n\t\t\tu32 mode = (hw->mac.ledctl_mode2 >> i) &\n\t\t\t    E1000_LEDCTL_LED0_MODE_MASK;\n\t\t\tu32 led_default = hw->mac.ledctl_default >> i;\n\n\t\t\tif ((!(led_default & E1000_LEDCTL_LED0_IVRT) &&\n\t\t\t     (mode == E1000_LEDCTL_MODE_LED_ON)) ||\n\t\t\t    ((led_default & E1000_LEDCTL_LED0_IVRT) &&\n\t\t\t     (mode == E1000_LEDCTL_MODE_LED_OFF))) {\n\t\t\t\tledctl_blink &=\n\t\t\t\t    ~(E1000_LEDCTL_LED0_MODE_MASK << i);\n\t\t\t\tledctl_blink |= (E1000_LEDCTL_LED0_BLINK |\n\t\t\t\t\t\t E1000_LEDCTL_MODE_LED_ON) << i;\n\t\t\t}\n\t\t}\n\t}\n\n\tew32(LEDCTL, ledctl_blink);\n\n\treturn 0;\n}\n\n \ns32 e1000e_led_on_generic(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\n\tswitch (hw->phy.media_type) {\n\tcase e1000_media_type_fiber:\n\t\tctrl = er32(CTRL);\n\t\tctrl &= ~E1000_CTRL_SWDPIN0;\n\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\tew32(CTRL, ctrl);\n\t\tbreak;\n\tcase e1000_media_type_copper:\n\t\tew32(LEDCTL, hw->mac.ledctl_mode2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_led_off_generic(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\n\tswitch (hw->phy.media_type) {\n\tcase e1000_media_type_fiber:\n\t\tctrl = er32(CTRL);\n\t\tctrl |= E1000_CTRL_SWDPIN0;\n\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\tew32(CTRL, ctrl);\n\t\tbreak;\n\tcase e1000_media_type_copper:\n\t\tew32(LEDCTL, hw->mac.ledctl_mode1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nvoid e1000e_set_pcie_no_snoop(struct e1000_hw *hw, u32 no_snoop)\n{\n\tu32 gcr;\n\n\tif (no_snoop) {\n\t\tgcr = er32(GCR);\n\t\tgcr &= ~(PCIE_NO_SNOOP_ALL);\n\t\tgcr |= no_snoop;\n\t\tew32(GCR, gcr);\n\t}\n}\n\n \ns32 e1000e_disable_pcie_master(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 timeout = MASTER_DISABLE_TIMEOUT;\n\n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_GIO_MASTER_DISABLE;\n\tew32(CTRL, ctrl);\n\n\twhile (timeout) {\n\t\tif (!(er32(STATUS) & E1000_STATUS_GIO_MASTER_ENABLE))\n\t\t\tbreak;\n\t\tusleep_range(100, 200);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\te_dbg(\"Master requests are pending.\\n\");\n\t\treturn -E1000_ERR_MASTER_REQUESTS_PENDING;\n\t}\n\n\treturn 0;\n}\n\n \nvoid e1000e_reset_adaptive(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\n\tif (!mac->adaptive_ifs) {\n\t\te_dbg(\"Not in Adaptive IFS mode!\\n\");\n\t\treturn;\n\t}\n\n\tmac->current_ifs_val = 0;\n\tmac->ifs_min_val = IFS_MIN;\n\tmac->ifs_max_val = IFS_MAX;\n\tmac->ifs_step_size = IFS_STEP;\n\tmac->ifs_ratio = IFS_RATIO;\n\n\tmac->in_ifs_mode = false;\n\tew32(AIT, 0);\n}\n\n \nvoid e1000e_update_adaptive(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\n\tif (!mac->adaptive_ifs) {\n\t\te_dbg(\"Not in Adaptive IFS mode!\\n\");\n\t\treturn;\n\t}\n\n\tif ((mac->collision_delta * mac->ifs_ratio) > mac->tx_packet_delta) {\n\t\tif (mac->tx_packet_delta > MIN_NUM_XMITS) {\n\t\t\tmac->in_ifs_mode = true;\n\t\t\tif (mac->current_ifs_val < mac->ifs_max_val) {\n\t\t\t\tif (!mac->current_ifs_val)\n\t\t\t\t\tmac->current_ifs_val = mac->ifs_min_val;\n\t\t\t\telse\n\t\t\t\t\tmac->current_ifs_val +=\n\t\t\t\t\t    mac->ifs_step_size;\n\t\t\t\tew32(AIT, mac->current_ifs_val);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (mac->in_ifs_mode &&\n\t\t    (mac->tx_packet_delta <= MIN_NUM_XMITS)) {\n\t\t\tmac->current_ifs_val = 0;\n\t\t\tmac->in_ifs_mode = false;\n\t\t\tew32(AIT, 0);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}