{
  "module_name": "manage.c",
  "hash_id": "3af108bf2d9e30f9b6997a7f823af878a83216c1c972f64c4ce3f88df711bcce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/manage.c",
  "human_readable_source": "\n \n\n#include \"e1000.h\"\n\n \nstatic u8 e1000_calculate_checksum(u8 *buffer, u32 length)\n{\n\tu32 i;\n\tu8 sum = 0;\n\n\tif (!buffer)\n\t\treturn 0;\n\n\tfor (i = 0; i < length; i++)\n\t\tsum += buffer[i];\n\n\treturn (u8)(0 - sum);\n}\n\n \nstatic s32 e1000_mng_enable_host_if(struct e1000_hw *hw)\n{\n\tu32 hicr;\n\tu8 i;\n\n\tif (!hw->mac.arc_subsystem_valid) {\n\t\te_dbg(\"ARC subsystem not valid.\\n\");\n\t\treturn -E1000_ERR_HOST_INTERFACE_COMMAND;\n\t}\n\n\t \n\thicr = er32(HICR);\n\tif (!(hicr & E1000_HICR_EN)) {\n\t\te_dbg(\"E1000_HOST_EN bit disabled.\\n\");\n\t\treturn -E1000_ERR_HOST_INTERFACE_COMMAND;\n\t}\n\t \n\tfor (i = 0; i < E1000_MNG_DHCP_COMMAND_TIMEOUT; i++) {\n\t\thicr = er32(HICR);\n\t\tif (!(hicr & E1000_HICR_C))\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\n\tif (i == E1000_MNG_DHCP_COMMAND_TIMEOUT) {\n\t\te_dbg(\"Previous command timeout failed.\\n\");\n\t\treturn -E1000_ERR_HOST_INTERFACE_COMMAND;\n\t}\n\n\treturn 0;\n}\n\n \nbool e1000e_check_mng_mode_generic(struct e1000_hw *hw)\n{\n\tu32 fwsm = er32(FWSM);\n\n\treturn (fwsm & E1000_FWSM_MODE_MASK) ==\n\t    (E1000_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT);\n}\n\n \nbool e1000e_enable_tx_pkt_filtering(struct e1000_hw *hw)\n{\n\tstruct e1000_host_mng_dhcp_cookie *hdr = &hw->mng_cookie;\n\tu32 *buffer = (u32 *)&hw->mng_cookie;\n\tu32 offset;\n\ts32 ret_val, hdr_csum, csum;\n\tu8 i, len;\n\n\thw->mac.tx_pkt_filtering = true;\n\n\t \n\tif (!hw->mac.ops.check_mng_mode(hw)) {\n\t\thw->mac.tx_pkt_filtering = false;\n\t\treturn hw->mac.tx_pkt_filtering;\n\t}\n\n\t \n\tret_val = e1000_mng_enable_host_if(hw);\n\tif (ret_val) {\n\t\thw->mac.tx_pkt_filtering = false;\n\t\treturn hw->mac.tx_pkt_filtering;\n\t}\n\n\t \n\tlen = E1000_MNG_DHCP_COOKIE_LENGTH >> 2;\n\toffset = E1000_MNG_DHCP_COOKIE_OFFSET >> 2;\n\tfor (i = 0; i < len; i++)\n\t\t*(buffer + i) = E1000_READ_REG_ARRAY(hw, E1000_HOST_IF,\n\t\t\t\t\t\t     offset + i);\n\thdr_csum = hdr->checksum;\n\thdr->checksum = 0;\n\tcsum = e1000_calculate_checksum((u8 *)hdr,\n\t\t\t\t\tE1000_MNG_DHCP_COOKIE_LENGTH);\n\t \n\tif ((hdr_csum != csum) || (hdr->signature != E1000_IAMT_SIGNATURE)) {\n\t\thw->mac.tx_pkt_filtering = true;\n\t\treturn hw->mac.tx_pkt_filtering;\n\t}\n\n\t \n\tif (!(hdr->status & E1000_MNG_DHCP_COOKIE_STATUS_PARSING))\n\t\thw->mac.tx_pkt_filtering = false;\n\n\treturn hw->mac.tx_pkt_filtering;\n}\n\n \nstatic s32 e1000_mng_write_cmd_header(struct e1000_hw *hw,\n\t\t\t\t      struct e1000_host_mng_command_header *hdr)\n{\n\tu16 i, length = sizeof(struct e1000_host_mng_command_header);\n\n\t \n\n\thdr->checksum = e1000_calculate_checksum((u8 *)hdr, length);\n\n\tlength >>= 2;\n\t \n\tfor (i = 0; i < length; i++) {\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, i, *((u32 *)hdr + i));\n\t\te1e_flush();\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_mng_host_if_write(struct e1000_hw *hw, u8 *buffer,\n\t\t\t\t   u16 length, u16 offset, u8 *sum)\n{\n\tu8 *tmp;\n\tu8 *bufptr = buffer;\n\tu32 data = 0;\n\tu16 remaining, i, j, prev_bytes;\n\n\t \n\n\tif (length == 0 || offset + length > E1000_HI_MAX_MNG_DATA_LENGTH)\n\t\treturn -E1000_ERR_PARAM;\n\n\ttmp = (u8 *)&data;\n\tprev_bytes = offset & 0x3;\n\toffset >>= 2;\n\n\tif (prev_bytes) {\n\t\tdata = E1000_READ_REG_ARRAY(hw, E1000_HOST_IF, offset);\n\t\tfor (j = prev_bytes; j < sizeof(u32); j++) {\n\t\t\t*(tmp + j) = *bufptr++;\n\t\t\t*sum += *(tmp + j);\n\t\t}\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, offset, data);\n\t\tlength -= j - prev_bytes;\n\t\toffset++;\n\t}\n\n\tremaining = length & 0x3;\n\tlength -= remaining;\n\n\t \n\tlength >>= 2;\n\n\t \n\tfor (i = 0; i < length; i++) {\n\t\tfor (j = 0; j < sizeof(u32); j++) {\n\t\t\t*(tmp + j) = *bufptr++;\n\t\t\t*sum += *(tmp + j);\n\t\t}\n\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, offset + i, data);\n\t}\n\tif (remaining) {\n\t\tfor (j = 0; j < sizeof(u32); j++) {\n\t\t\tif (j < remaining)\n\t\t\t\t*(tmp + j) = *bufptr++;\n\t\t\telse\n\t\t\t\t*(tmp + j) = 0;\n\n\t\t\t*sum += *(tmp + j);\n\t\t}\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, offset + i, data);\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_mng_write_dhcp_info(struct e1000_hw *hw, u8 *buffer, u16 length)\n{\n\tstruct e1000_host_mng_command_header hdr;\n\ts32 ret_val;\n\tu32 hicr;\n\n\thdr.command_id = E1000_MNG_DHCP_TX_PAYLOAD_CMD;\n\thdr.command_length = length;\n\thdr.reserved1 = 0;\n\thdr.reserved2 = 0;\n\thdr.checksum = 0;\n\n\t \n\tret_val = e1000_mng_enable_host_if(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1000_mng_host_if_write(hw, buffer, length,\n\t\t\t\t\t  sizeof(hdr), &(hdr.checksum));\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1000_mng_write_cmd_header(hw, &hdr);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\thicr = er32(HICR);\n\tew32(HICR, hicr | E1000_HICR_C);\n\n\treturn 0;\n}\n\n \nbool e1000e_enable_mng_pass_thru(struct e1000_hw *hw)\n{\n\tu32 manc;\n\tu32 fwsm, factps;\n\n\tmanc = er32(MANC);\n\n\tif (!(manc & E1000_MANC_RCV_TCO_EN))\n\t\treturn false;\n\n\tif (hw->mac.has_fwsm) {\n\t\tfwsm = er32(FWSM);\n\t\tfactps = er32(FACTPS);\n\n\t\tif (!(factps & E1000_FACTPS_MNGCG) &&\n\t\t    ((fwsm & E1000_FWSM_MODE_MASK) ==\n\t\t     (e1000_mng_mode_pt << E1000_FWSM_MODE_SHIFT)))\n\t\t\treturn true;\n\t} else if ((hw->mac.type == e1000_82574) ||\n\t\t   (hw->mac.type == e1000_82583)) {\n\t\tu16 data;\n\t\ts32 ret_val;\n\n\t\tfactps = er32(FACTPS);\n\t\tret_val = e1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &data);\n\t\tif (ret_val)\n\t\t\treturn false;\n\n\t\tif (!(factps & E1000_FACTPS_MNGCG) &&\n\t\t    ((data & E1000_NVM_INIT_CTRL2_MNGM) ==\n\t\t     (e1000_mng_mode_pt << 13)))\n\t\t\treturn true;\n\t} else if ((manc & E1000_MANC_SMBUS_EN) &&\n\t\t   !(manc & E1000_MANC_ASF_EN)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}