{
  "module_name": "80003es2lan.c",
  "hash_id": "5336b6e2c5f374dff6e58f62ef49c190a821167b4da9f18b96c9ca139ebb0981",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/80003es2lan.c",
  "human_readable_source": "\n \n\n \n\n#include \"e1000.h\"\n\n \nstatic const u16 e1000_gg82563_cable_length_table[] = {\n\t0, 60, 115, 150, 150, 60, 115, 150, 180, 180, 0xFF\n};\n\n#define GG82563_CABLE_LENGTH_TABLE_SIZE \\\n\t\tARRAY_SIZE(e1000_gg82563_cable_length_table)\n\nstatic s32 e1000_setup_copper_link_80003es2lan(struct e1000_hw *hw);\nstatic s32 e1000_acquire_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask);\nstatic void e1000_release_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask);\nstatic void e1000_initialize_hw_bits_80003es2lan(struct e1000_hw *hw);\nstatic void e1000_clear_hw_cntrs_80003es2lan(struct e1000_hw *hw);\nstatic s32 e1000_cfg_kmrn_1000_80003es2lan(struct e1000_hw *hw);\nstatic s32 e1000_cfg_kmrn_10_100_80003es2lan(struct e1000_hw *hw, u16 duplex);\nstatic s32 e1000_read_kmrn_reg_80003es2lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t   u16 *data);\nstatic s32 e1000_write_kmrn_reg_80003es2lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t    u16 data);\nstatic void e1000_power_down_phy_copper_80003es2lan(struct e1000_hw *hw);\n\n \nstatic s32 e1000_init_phy_params_80003es2lan(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\n\tif (hw->phy.media_type != e1000_media_type_copper) {\n\t\tphy->type = e1000_phy_none;\n\t\treturn 0;\n\t} else {\n\t\tphy->ops.power_up = e1000_power_up_phy_copper;\n\t\tphy->ops.power_down = e1000_power_down_phy_copper_80003es2lan;\n\t}\n\n\tphy->addr = 1;\n\tphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\tphy->reset_delay_us = 100;\n\tphy->type = e1000_phy_gg82563;\n\n\t \n\tret_val = e1000e_get_phy_id(hw);\n\n\t \n\tif (phy->id != GG82563_E_PHY_ID)\n\t\treturn -E1000_ERR_PHY;\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_init_nvm_params_80003es2lan(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = er32(EECD);\n\tu16 size;\n\n\tnvm->opcode_bits = 8;\n\tnvm->delay_usec = 1;\n\tswitch (nvm->override) {\n\tcase e1000_nvm_override_spi_large:\n\t\tnvm->page_size = 32;\n\t\tnvm->address_bits = 16;\n\t\tbreak;\n\tcase e1000_nvm_override_spi_small:\n\t\tnvm->page_size = 8;\n\t\tnvm->address_bits = 8;\n\t\tbreak;\n\tdefault:\n\t\tnvm->page_size = eecd & E1000_EECD_ADDR_BITS ? 32 : 8;\n\t\tnvm->address_bits = eecd & E1000_EECD_ADDR_BITS ? 16 : 8;\n\t\tbreak;\n\t}\n\n\tnvm->type = e1000_nvm_eeprom_spi;\n\n\tsize = (u16)((eecd & E1000_EECD_SIZE_EX_MASK) >>\n\t\t     E1000_EECD_SIZE_EX_SHIFT);\n\n\t \n\tsize += NVM_WORD_SIZE_BASE_SHIFT;\n\n\t \n\tif (size > 14)\n\t\tsize = 14;\n\tnvm->word_size = BIT(size);\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_init_mac_params_80003es2lan(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\n\t \n\tswitch (hw->adapter->pdev->device) {\n\tcase E1000_DEV_ID_80003ES2LAN_SERDES_DPT:\n\t\thw->phy.media_type = e1000_media_type_internal_serdes;\n\t\tmac->ops.check_for_link = e1000e_check_for_serdes_link;\n\t\tmac->ops.setup_physical_interface =\n\t\t    e1000e_setup_fiber_serdes_link;\n\t\tbreak;\n\tdefault:\n\t\thw->phy.media_type = e1000_media_type_copper;\n\t\tmac->ops.check_for_link = e1000e_check_for_copper_link;\n\t\tmac->ops.setup_physical_interface =\n\t\t    e1000_setup_copper_link_80003es2lan;\n\t\tbreak;\n\t}\n\n\t \n\tmac->mta_reg_count = 128;\n\t \n\tmac->rar_entry_count = E1000_RAR_ENTRIES;\n\t \n\tmac->has_fwsm = true;\n\t \n\tmac->arc_subsystem_valid = !!(er32(FWSM) & E1000_FWSM_MODE_MASK);\n\t \n\tmac->adaptive_ifs = false;\n\n\t \n\thw->mac.ops.set_lan_id(hw);\n\n\treturn 0;\n}\n\nstatic s32 e1000_get_variants_80003es2lan(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 rc;\n\n\trc = e1000_init_mac_params_80003es2lan(hw);\n\tif (rc)\n\t\treturn rc;\n\n\trc = e1000_init_nvm_params_80003es2lan(hw);\n\tif (rc)\n\t\treturn rc;\n\n\trc = e1000_init_phy_params_80003es2lan(hw);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_acquire_phy_80003es2lan(struct e1000_hw *hw)\n{\n\tu16 mask;\n\n\tmask = hw->bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;\n\treturn e1000_acquire_swfw_sync_80003es2lan(hw, mask);\n}\n\n \nstatic void e1000_release_phy_80003es2lan(struct e1000_hw *hw)\n{\n\tu16 mask;\n\n\tmask = hw->bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;\n\te1000_release_swfw_sync_80003es2lan(hw, mask);\n}\n\n \nstatic s32 e1000_acquire_mac_csr_80003es2lan(struct e1000_hw *hw)\n{\n\tu16 mask;\n\n\tmask = E1000_SWFW_CSR_SM;\n\n\treturn e1000_acquire_swfw_sync_80003es2lan(hw, mask);\n}\n\n \nstatic void e1000_release_mac_csr_80003es2lan(struct e1000_hw *hw)\n{\n\tu16 mask;\n\n\tmask = E1000_SWFW_CSR_SM;\n\n\te1000_release_swfw_sync_80003es2lan(hw, mask);\n}\n\n \nstatic s32 e1000_acquire_nvm_80003es2lan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tret_val = e1000_acquire_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000e_acquire_nvm(hw);\n\n\tif (ret_val)\n\t\te1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_release_nvm_80003es2lan(struct e1000_hw *hw)\n{\n\te1000e_release_nvm(hw);\n\te1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\n}\n\n \nstatic s32 e1000_acquire_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)\n{\n\tu32 swfw_sync;\n\tu32 swmask = mask;\n\tu32 fwmask = mask << 16;\n\ts32 i = 0;\n\ts32 timeout = 50;\n\n\twhile (i < timeout) {\n\t\tif (e1000e_get_hw_semaphore(hw))\n\t\t\treturn -E1000_ERR_SWFW_SYNC;\n\n\t\tswfw_sync = er32(SW_FW_SYNC);\n\t\tif (!(swfw_sync & (fwmask | swmask)))\n\t\t\tbreak;\n\n\t\t \n\t\te1000e_put_hw_semaphore(hw);\n\t\tmdelay(5);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\te_dbg(\"Driver can't access resource, SW_FW_SYNC timeout.\\n\");\n\t\treturn -E1000_ERR_SWFW_SYNC;\n\t}\n\n\tswfw_sync |= swmask;\n\tew32(SW_FW_SYNC, swfw_sync);\n\n\te1000e_put_hw_semaphore(hw);\n\n\treturn 0;\n}\n\n \nstatic void e1000_release_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)\n{\n\tu32 swfw_sync;\n\n\twhile (e1000e_get_hw_semaphore(hw) != 0)\n\t\t;  \n\n\tswfw_sync = er32(SW_FW_SYNC);\n\tswfw_sync &= ~mask;\n\tew32(SW_FW_SYNC, swfw_sync);\n\n\te1000e_put_hw_semaphore(hw);\n}\n\n \nstatic s32 e1000_read_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw,\n\t\t\t\t\t\t  u32 offset, u16 *data)\n{\n\ts32 ret_val;\n\tu32 page_select;\n\tu16 temp;\n\n\tret_val = e1000_acquire_phy_80003es2lan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif ((offset & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG) {\n\t\tpage_select = GG82563_PHY_PAGE_SELECT;\n\t} else {\n\t\t \n\t\tpage_select = GG82563_PHY_PAGE_SELECT_ALT;\n\t}\n\n\ttemp = (u16)((u16)offset >> GG82563_PAGE_SHIFT);\n\tret_val = e1000e_write_phy_reg_mdic(hw, page_select, temp);\n\tif (ret_val) {\n\t\te1000_release_phy_80003es2lan(hw);\n\t\treturn ret_val;\n\t}\n\n\tif (hw->dev_spec.e80003es2lan.mdic_wa_enable) {\n\t\t \n\t\tusleep_range(200, 400);\n\n\t\t \n\t\tret_val = e1000e_read_phy_reg_mdic(hw, page_select, &temp);\n\n\t\tif (((u16)offset >> GG82563_PAGE_SHIFT) != temp) {\n\t\t\te1000_release_phy_80003es2lan(hw);\n\t\t\treturn -E1000_ERR_PHY;\n\t\t}\n\n\t\tusleep_range(200, 400);\n\n\t\tret_val = e1000e_read_phy_reg_mdic(hw,\n\t\t\t\t\t\t   MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t\t   data);\n\n\t\tusleep_range(200, 400);\n\t} else {\n\t\tret_val = e1000e_read_phy_reg_mdic(hw,\n\t\t\t\t\t\t   MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t\t   data);\n\t}\n\n\te1000_release_phy_80003es2lan(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw,\n\t\t\t\t\t\t   u32 offset, u16 data)\n{\n\ts32 ret_val;\n\tu32 page_select;\n\tu16 temp;\n\n\tret_val = e1000_acquire_phy_80003es2lan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif ((offset & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG) {\n\t\tpage_select = GG82563_PHY_PAGE_SELECT;\n\t} else {\n\t\t \n\t\tpage_select = GG82563_PHY_PAGE_SELECT_ALT;\n\t}\n\n\ttemp = (u16)((u16)offset >> GG82563_PAGE_SHIFT);\n\tret_val = e1000e_write_phy_reg_mdic(hw, page_select, temp);\n\tif (ret_val) {\n\t\te1000_release_phy_80003es2lan(hw);\n\t\treturn ret_val;\n\t}\n\n\tif (hw->dev_spec.e80003es2lan.mdic_wa_enable) {\n\t\t \n\t\tusleep_range(200, 400);\n\n\t\t \n\t\tret_val = e1000e_read_phy_reg_mdic(hw, page_select, &temp);\n\n\t\tif (((u16)offset >> GG82563_PAGE_SHIFT) != temp) {\n\t\t\te1000_release_phy_80003es2lan(hw);\n\t\t\treturn -E1000_ERR_PHY;\n\t\t}\n\n\t\tusleep_range(200, 400);\n\n\t\tret_val = e1000e_write_phy_reg_mdic(hw,\n\t\t\t\t\t\t    MAX_PHY_REG_ADDRESS &\n\t\t\t\t\t\t    offset, data);\n\n\t\tusleep_range(200, 400);\n\t} else {\n\t\tret_val = e1000e_write_phy_reg_mdic(hw,\n\t\t\t\t\t\t    MAX_PHY_REG_ADDRESS &\n\t\t\t\t\t\t    offset, data);\n\t}\n\n\te1000_release_phy_80003es2lan(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_nvm_80003es2lan(struct e1000_hw *hw, u16 offset,\n\t\t\t\t       u16 words, u16 *data)\n{\n\treturn e1000e_write_nvm_spi(hw, offset, words, data);\n}\n\n \nstatic s32 e1000_get_cfg_done_80003es2lan(struct e1000_hw *hw)\n{\n\ts32 timeout = PHY_CFG_TIMEOUT;\n\tu32 mask = E1000_NVM_CFG_DONE_PORT_0;\n\n\tif (hw->bus.func == 1)\n\t\tmask = E1000_NVM_CFG_DONE_PORT_1;\n\n\twhile (timeout) {\n\t\tif (er32(EEMNGCTL) & mask)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\ttimeout--;\n\t}\n\tif (!timeout) {\n\t\te_dbg(\"MNG configuration cycle has not completed.\\n\");\n\t\treturn -E1000_ERR_RESET;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_phy_force_speed_duplex_80003es2lan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\t \n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data &= ~GG82563_PSCR_CROSSOVER_MODE_AUTO;\n\tret_val = e1e_wphy(hw, GG82563_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te_dbg(\"GG82563 PSCR: %X\\n\", phy_data);\n\n\tret_val = e1e_rphy(hw, MII_BMCR, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te1000e_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\t \n\tphy_data |= BMCR_RESET;\n\n\tret_val = e1e_wphy(hw, MII_BMCR, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tudelay(1);\n\n\tif (hw->phy.autoneg_wait_to_complete) {\n\t\te_dbg(\"Waiting for forced speed/duplex link on GG82563 phy.\\n\");\n\n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!link) {\n\t\t\t \n\t\t\tret_val = e1000e_phy_reset_dsp(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\tret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t\t      100000, &link);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tret_val = e1e_rphy(hw, GG82563_PHY_MAC_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tphy_data &= ~GG82563_MSCR_TX_CLK_MASK;\n\tif (hw->mac.forced_speed_duplex & E1000_ALL_10_SPEED)\n\t\tphy_data |= GG82563_MSCR_TX_CLK_10MBPS_2_5;\n\telse\n\t\tphy_data |= GG82563_MSCR_TX_CLK_100MBPS_25;\n\n\t \n\tphy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;\n\tret_val = e1e_wphy(hw, GG82563_PHY_MAC_SPEC_CTRL, phy_data);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_get_cable_length_80003es2lan(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, index;\n\n\tret_val = e1e_rphy(hw, GG82563_PHY_DSP_DISTANCE, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tindex = phy_data & GG82563_DSPD_CABLE_LENGTH;\n\n\tif (index >= GG82563_CABLE_LENGTH_TABLE_SIZE - 5)\n\t\treturn -E1000_ERR_PHY;\n\n\tphy->min_cable_length = e1000_gg82563_cable_length_table[index];\n\tphy->max_cable_length = e1000_gg82563_cable_length_table[index + 5];\n\n\tphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_get_link_up_info_80003es2lan(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t\t      u16 *duplex)\n{\n\ts32 ret_val;\n\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\tret_val = e1000e_get_speed_and_duplex_copper(hw, speed, duplex);\n\t\thw->phy.ops.cfg_on_link_up(hw);\n\t} else {\n\t\tret_val = e1000e_get_speed_and_duplex_fiber_serdes(hw,\n\t\t\t\t\t\t\t\t   speed,\n\t\t\t\t\t\t\t\t   duplex);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_reset_hw_80003es2lan(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\tu16 kum_reg_data;\n\n\t \n\tret_val = e1000e_disable_pcie_master(hw);\n\tif (ret_val)\n\t\te_dbg(\"PCI-E Master disable polling has failed.\\n\");\n\n\te_dbg(\"Masking off all interrupts\\n\");\n\tew32(IMC, 0xffffffff);\n\n\tew32(RCTL, 0);\n\tew32(TCTL, E1000_TCTL_PSP);\n\te1e_flush();\n\n\tusleep_range(10000, 11000);\n\n\tctrl = er32(CTRL);\n\n\tret_val = e1000_acquire_phy_80003es2lan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te_dbg(\"Issuing a global reset to MAC\\n\");\n\tew32(CTRL, ctrl | E1000_CTRL_RST);\n\te1000_release_phy_80003es2lan(hw);\n\n\t \n\tret_val =\n\t    e1000_read_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\n\t\t\t\t\t    &kum_reg_data);\n\tif (!ret_val) {\n\t\tkum_reg_data |= E1000_KMRNCTRLSTA_IBIST_DISABLE;\n\t\tret_val = e1000_write_kmrn_reg_80003es2lan(hw,\n\t\t\t\t\t\t E1000_KMRNCTRLSTA_INBAND_PARAM,\n\t\t\t\t\t\t kum_reg_data);\n\t\tif (ret_val)\n\t\t\te_dbg(\"Error disabling far-end loopback\\n\");\n\t} else {\n\t\te_dbg(\"Error disabling far-end loopback\\n\");\n\t}\n\n\tret_val = e1000e_get_auto_rd_done(hw);\n\tif (ret_val)\n\t\t \n\t\treturn ret_val;\n\n\t \n\tew32(IMC, 0xffffffff);\n\ter32(ICR);\n\n\treturn e1000_check_alt_mac_addr_generic(hw);\n}\n\n \nstatic s32 e1000_init_hw_80003es2lan(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 reg_data;\n\ts32 ret_val;\n\tu16 kum_reg_data;\n\tu16 i;\n\n\te1000_initialize_hw_bits_80003es2lan(hw);\n\n\t \n\tret_val = mac->ops.id_led_init(hw);\n\t \n\tif (ret_val)\n\t\te_dbg(\"Error initializing identification LED\\n\");\n\n\t \n\te_dbg(\"Initializing the IEEE VLAN\\n\");\n\tmac->ops.clear_vfta(hw);\n\n\t \n\te1000e_init_rx_addrs(hw, mac->rar_entry_count);\n\n\t \n\te_dbg(\"Zeroing the MTA\\n\");\n\tfor (i = 0; i < mac->mta_reg_count; i++)\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);\n\n\t \n\tret_val = mac->ops.setup_link(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val =\n\t    e1000_read_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\n\t\t\t\t\t    &kum_reg_data);\n\tif (!ret_val) {\n\t\tkum_reg_data |= E1000_KMRNCTRLSTA_IBIST_DISABLE;\n\t\tret_val = e1000_write_kmrn_reg_80003es2lan(hw,\n\t\t\t\t\t\t E1000_KMRNCTRLSTA_INBAND_PARAM,\n\t\t\t\t\t\t kum_reg_data);\n\t\tif (ret_val)\n\t\t\te_dbg(\"Error disabling far-end loopback\\n\");\n\t} else {\n\t\te_dbg(\"Error disabling far-end loopback\\n\");\n\t}\n\n\t \n\treg_data = er32(TXDCTL(0));\n\treg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\n\t\t    E1000_TXDCTL_FULL_TX_DESC_WB | E1000_TXDCTL_COUNT_DESC);\n\tew32(TXDCTL(0), reg_data);\n\n\t \n\treg_data = er32(TXDCTL(1));\n\treg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\n\t\t    E1000_TXDCTL_FULL_TX_DESC_WB | E1000_TXDCTL_COUNT_DESC);\n\tew32(TXDCTL(1), reg_data);\n\n\t \n\treg_data = er32(TCTL);\n\treg_data |= E1000_TCTL_RTLC;\n\tew32(TCTL, reg_data);\n\n\t \n\treg_data = er32(TCTL_EXT);\n\treg_data &= ~E1000_TCTL_EXT_GCEX_MASK;\n\treg_data |= DEFAULT_TCTL_EXT_GCEX_80003ES2LAN;\n\tew32(TCTL_EXT, reg_data);\n\n\t \n\treg_data = er32(TIPG);\n\treg_data &= ~E1000_TIPG_IPGT_MASK;\n\treg_data |= DEFAULT_TIPG_IPGT_1000_80003ES2LAN;\n\tew32(TIPG, reg_data);\n\n\treg_data = E1000_READ_REG_ARRAY(hw, E1000_FFLT, 0x0001);\n\treg_data &= ~0x00100000;\n\tE1000_WRITE_REG_ARRAY(hw, E1000_FFLT, 0x0001, reg_data);\n\n\t \n\thw->dev_spec.e80003es2lan.mdic_wa_enable = true;\n\n\tret_val =\n\t    e1000_read_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_OFFSET >>\n\t\t\t\t\t    E1000_KMRNCTRLSTA_OFFSET_SHIFT, &i);\n\tif (!ret_val) {\n\t\tif ((i & E1000_KMRNCTRLSTA_OPMODE_MASK) ==\n\t\t    E1000_KMRNCTRLSTA_OPMODE_INBAND_MDIO)\n\t\t\thw->dev_spec.e80003es2lan.mdic_wa_enable = false;\n\t}\n\n\t \n\te1000_clear_hw_cntrs_80003es2lan(hw);\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_initialize_hw_bits_80003es2lan(struct e1000_hw *hw)\n{\n\tu32 reg;\n\n\t \n\treg = er32(TXDCTL(0));\n\treg |= BIT(22);\n\tew32(TXDCTL(0), reg);\n\n\t \n\treg = er32(TXDCTL(1));\n\treg |= BIT(22);\n\tew32(TXDCTL(1), reg);\n\n\t \n\treg = er32(TARC(0));\n\treg &= ~(0xF << 27);\t \n\tif (hw->phy.media_type != e1000_media_type_copper)\n\t\treg &= ~BIT(20);\n\tew32(TARC(0), reg);\n\n\t \n\treg = er32(TARC(1));\n\tif (er32(TCTL) & E1000_TCTL_MULR)\n\t\treg &= ~BIT(28);\n\telse\n\t\treg |= BIT(28);\n\tew32(TARC(1), reg);\n\n\t \n\treg = er32(RFCTL);\n\treg |= (E1000_RFCTL_IPV6_EX_DIS | E1000_RFCTL_NEW_IPV6_EXT_DIS);\n\tew32(RFCTL, reg);\n}\n\n \nstatic s32 e1000_copper_link_setup_gg82563_80003es2lan(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu32 reg;\n\tu16 data;\n\n\tret_val = e1e_rphy(hw, GG82563_PHY_MAC_SPEC_CTRL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata |= GG82563_MSCR_ASSERT_CRS_ON_TX;\n\t \n\tdata |= GG82563_MSCR_TX_CLK_1000MBPS_25;\n\n\tret_val = e1e_wphy(hw, GG82563_PHY_MAC_SPEC_CTRL, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1e_rphy(hw, GG82563_PHY_SPEC_CTRL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata &= ~GG82563_PSCR_CROSSOVER_MODE_MASK;\n\n\tswitch (phy->mdix) {\n\tcase 1:\n\t\tdata |= GG82563_PSCR_CROSSOVER_MODE_MDI;\n\t\tbreak;\n\tcase 2:\n\t\tdata |= GG82563_PSCR_CROSSOVER_MODE_MDIX;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tdata |= GG82563_PSCR_CROSSOVER_MODE_AUTO;\n\t\tbreak;\n\t}\n\n\t \n\tdata &= ~GG82563_PSCR_POLARITY_REVERSAL_DISABLE;\n\tif (phy->disable_polarity_correction)\n\t\tdata |= GG82563_PSCR_POLARITY_REVERSAL_DISABLE;\n\n\tret_val = e1e_wphy(hw, GG82563_PHY_SPEC_CTRL, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = hw->phy.ops.commit(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Resetting the PHY\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\treg = E1000_KMRNCTRLSTA_OFFSET_FIFO_CTRL;\n\tdata = (E1000_KMRNCTRLSTA_FIFO_CTRL_RX_BYPASS |\n\t\tE1000_KMRNCTRLSTA_FIFO_CTRL_TX_BYPASS);\n\tret_val = e1000_write_kmrn_reg_80003es2lan(hw, reg, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treg = E1000_KMRNCTRLSTA_OFFSET_MAC2PHY_OPMODE;\n\tret_val = e1000_read_kmrn_reg_80003es2lan(hw, reg, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\tdata |= E1000_KMRNCTRLSTA_OPMODE_E_IDLE;\n\tret_val = e1000_write_kmrn_reg_80003es2lan(hw, reg, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1e_rphy(hw, GG82563_PHY_SPEC_CTRL_2, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata &= ~GG82563_PSCR2_REVERSE_AUTO_NEG;\n\tret_val = e1e_wphy(hw, GG82563_PHY_SPEC_CTRL_2, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treg = er32(CTRL_EXT);\n\treg &= ~E1000_CTRL_EXT_LINK_MODE_MASK;\n\tew32(CTRL_EXT, reg);\n\n\tret_val = e1e_rphy(hw, GG82563_PHY_PWR_MGMT_CTRL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (!hw->mac.ops.check_mng_mode(hw)) {\n\t\t \n\t\tdata |= GG82563_PMCR_ENABLE_ELECTRICAL_IDLE;\n\t\tret_val = e1e_wphy(hw, GG82563_PHY_PWR_MGMT_CTRL, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tdata &= ~GG82563_KMCR_PASS_FALSE_CARRIER;\n\t\tret_val = e1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tret_val = e1e_rphy(hw, GG82563_PHY_INBAND_CTRL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata |= GG82563_ICR_DIS_PADDING;\n\tret_val = e1e_wphy(hw, GG82563_PHY_INBAND_CTRL, data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_setup_copper_link_80003es2lan(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\tu16 reg_data;\n\n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_SLU;\n\tctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tew32(CTRL, ctrl);\n\n\t \n\tret_val = e1000_write_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 4),\n\t\t\t\t\t\t   0xFFFF);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = e1000_read_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 9),\n\t\t\t\t\t\t  &reg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\treg_data |= 0x3F;\n\tret_val = e1000_write_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 9),\n\t\t\t\t\t\t   reg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val =\n\t    e1000_read_kmrn_reg_80003es2lan(hw,\n\t\t\t\t\t    E1000_KMRNCTRLSTA_OFFSET_INB_CTRL,\n\t\t\t\t\t    &reg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\treg_data |= E1000_KMRNCTRLSTA_INB_CTRL_DIS_PADDING;\n\tret_val =\n\t    e1000_write_kmrn_reg_80003es2lan(hw,\n\t\t\t\t\t     E1000_KMRNCTRLSTA_OFFSET_INB_CTRL,\n\t\t\t\t\t     reg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000_copper_link_setup_gg82563_80003es2lan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1000e_setup_copper_link(hw);\n}\n\n \nstatic s32 e1000_cfg_on_link_up_80003es2lan(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 speed;\n\tu16 duplex;\n\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\tret_val = e1000e_get_speed_and_duplex_copper(hw, &speed,\n\t\t\t\t\t\t\t     &duplex);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (speed == SPEED_1000)\n\t\t\tret_val = e1000_cfg_kmrn_1000_80003es2lan(hw);\n\t\telse\n\t\t\tret_val = e1000_cfg_kmrn_10_100_80003es2lan(hw, duplex);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_cfg_kmrn_10_100_80003es2lan(struct e1000_hw *hw, u16 duplex)\n{\n\ts32 ret_val;\n\tu32 tipg;\n\tu32 i = 0;\n\tu16 reg_data, reg_data2;\n\n\treg_data = E1000_KMRNCTRLSTA_HD_CTRL_10_100_DEFAULT;\n\tret_val =\n\t    e1000_write_kmrn_reg_80003es2lan(hw,\n\t\t\t\t\t     E1000_KMRNCTRLSTA_OFFSET_HD_CTRL,\n\t\t\t\t\t     reg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\ttipg = er32(TIPG);\n\ttipg &= ~E1000_TIPG_IPGT_MASK;\n\ttipg |= DEFAULT_TIPG_IPGT_10_100_80003ES2LAN;\n\tew32(TIPG, tipg);\n\n\tdo {\n\t\tret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data2);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\ti++;\n\t} while ((reg_data != reg_data2) && (i < GG82563_MAX_KMRN_RETRY));\n\n\tif (duplex == HALF_DUPLEX)\n\t\treg_data |= GG82563_KMCR_PASS_FALSE_CARRIER;\n\telse\n\t\treg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;\n\n\treturn e1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);\n}\n\n \nstatic s32 e1000_cfg_kmrn_1000_80003es2lan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 reg_data, reg_data2;\n\tu32 tipg;\n\tu32 i = 0;\n\n\treg_data = E1000_KMRNCTRLSTA_HD_CTRL_1000_DEFAULT;\n\tret_val =\n\t    e1000_write_kmrn_reg_80003es2lan(hw,\n\t\t\t\t\t     E1000_KMRNCTRLSTA_OFFSET_HD_CTRL,\n\t\t\t\t\t     reg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\ttipg = er32(TIPG);\n\ttipg &= ~E1000_TIPG_IPGT_MASK;\n\ttipg |= DEFAULT_TIPG_IPGT_1000_80003ES2LAN;\n\tew32(TIPG, tipg);\n\n\tdo {\n\t\tret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data2);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\ti++;\n\t} while ((reg_data != reg_data2) && (i < GG82563_MAX_KMRN_RETRY));\n\n\treg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;\n\n\treturn e1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);\n}\n\n \nstatic s32 e1000_read_kmrn_reg_80003es2lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t   u16 *data)\n{\n\tu32 kmrnctrlsta;\n\ts32 ret_val;\n\n\tret_val = e1000_acquire_mac_csr_80003es2lan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\n\t\t       E1000_KMRNCTRLSTA_OFFSET) | E1000_KMRNCTRLSTA_REN;\n\tew32(KMRNCTRLSTA, kmrnctrlsta);\n\te1e_flush();\n\n\tudelay(2);\n\n\tkmrnctrlsta = er32(KMRNCTRLSTA);\n\t*data = (u16)kmrnctrlsta;\n\n\te1000_release_mac_csr_80003es2lan(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_kmrn_reg_80003es2lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t    u16 data)\n{\n\tu32 kmrnctrlsta;\n\ts32 ret_val;\n\n\tret_val = e1000_acquire_mac_csr_80003es2lan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\n\t\t       E1000_KMRNCTRLSTA_OFFSET) | data;\n\tew32(KMRNCTRLSTA, kmrnctrlsta);\n\te1e_flush();\n\n\tudelay(2);\n\n\te1000_release_mac_csr_80003es2lan(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_read_mac_addr_80003es2lan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\t \n\tret_val = e1000_check_alt_mac_addr_generic(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1000_read_mac_addr_generic(hw);\n}\n\n \nstatic void e1000_power_down_phy_copper_80003es2lan(struct e1000_hw *hw)\n{\n\t \n\tif (!(hw->mac.ops.check_mng_mode(hw) ||\n\t      hw->phy.ops.check_reset_block(hw)))\n\t\te1000_power_down_phy_copper(hw);\n}\n\n \nstatic void e1000_clear_hw_cntrs_80003es2lan(struct e1000_hw *hw)\n{\n\te1000e_clear_hw_cntrs_base(hw);\n\n\ter32(PRC64);\n\ter32(PRC127);\n\ter32(PRC255);\n\ter32(PRC511);\n\ter32(PRC1023);\n\ter32(PRC1522);\n\ter32(PTC64);\n\ter32(PTC127);\n\ter32(PTC255);\n\ter32(PTC511);\n\ter32(PTC1023);\n\ter32(PTC1522);\n\n\ter32(ALGNERRC);\n\ter32(RXERRC);\n\ter32(TNCRS);\n\ter32(CEXTERR);\n\ter32(TSCTC);\n\ter32(TSCTFC);\n\n\ter32(MGTPRC);\n\ter32(MGTPDC);\n\ter32(MGTPTC);\n\n\ter32(IAC);\n\ter32(ICRXOC);\n\n\ter32(ICRXPTC);\n\ter32(ICRXATC);\n\ter32(ICTXPTC);\n\ter32(ICTXATC);\n\ter32(ICTXQEC);\n\ter32(ICTXQMTC);\n\ter32(ICRXDMTC);\n}\n\nstatic const struct e1000_mac_operations es2_mac_ops = {\n\t.read_mac_addr\t\t= e1000_read_mac_addr_80003es2lan,\n\t.id_led_init\t\t= e1000e_id_led_init_generic,\n\t.blink_led\t\t= e1000e_blink_led_generic,\n\t.check_mng_mode\t\t= e1000e_check_mng_mode_generic,\n\t \n\t.cleanup_led\t\t= e1000e_cleanup_led_generic,\n\t.clear_hw_cntrs\t\t= e1000_clear_hw_cntrs_80003es2lan,\n\t.get_bus_info\t\t= e1000e_get_bus_info_pcie,\n\t.set_lan_id\t\t= e1000_set_lan_id_multi_port_pcie,\n\t.get_link_up_info\t= e1000_get_link_up_info_80003es2lan,\n\t.led_on\t\t\t= e1000e_led_on_generic,\n\t.led_off\t\t= e1000e_led_off_generic,\n\t.update_mc_addr_list\t= e1000e_update_mc_addr_list_generic,\n\t.write_vfta\t\t= e1000_write_vfta_generic,\n\t.clear_vfta\t\t= e1000_clear_vfta_generic,\n\t.reset_hw\t\t= e1000_reset_hw_80003es2lan,\n\t.init_hw\t\t= e1000_init_hw_80003es2lan,\n\t.setup_link\t\t= e1000e_setup_link_generic,\n\t \n\t.setup_led\t\t= e1000e_setup_led_generic,\n\t.config_collision_dist\t= e1000e_config_collision_dist_generic,\n\t.rar_set\t\t= e1000e_rar_set_generic,\n\t.rar_get_count\t\t= e1000e_rar_get_count_generic,\n};\n\nstatic const struct e1000_phy_operations es2_phy_ops = {\n\t.acquire\t\t= e1000_acquire_phy_80003es2lan,\n\t.check_polarity\t\t= e1000_check_polarity_m88,\n\t.check_reset_block\t= e1000e_check_reset_block_generic,\n\t.commit\t\t\t= e1000e_phy_sw_reset,\n\t.force_speed_duplex\t= e1000_phy_force_speed_duplex_80003es2lan,\n\t.get_cfg_done\t\t= e1000_get_cfg_done_80003es2lan,\n\t.get_cable_length\t= e1000_get_cable_length_80003es2lan,\n\t.get_info\t\t= e1000e_get_phy_info_m88,\n\t.read_reg\t\t= e1000_read_phy_reg_gg82563_80003es2lan,\n\t.release\t\t= e1000_release_phy_80003es2lan,\n\t.reset\t\t\t= e1000e_phy_hw_reset_generic,\n\t.set_d0_lplu_state\t= NULL,\n\t.set_d3_lplu_state\t= e1000e_set_d3_lplu_state,\n\t.write_reg\t\t= e1000_write_phy_reg_gg82563_80003es2lan,\n\t.cfg_on_link_up\t\t= e1000_cfg_on_link_up_80003es2lan,\n};\n\nstatic const struct e1000_nvm_operations es2_nvm_ops = {\n\t.acquire\t\t= e1000_acquire_nvm_80003es2lan,\n\t.read\t\t\t= e1000e_read_nvm_eerd,\n\t.release\t\t= e1000_release_nvm_80003es2lan,\n\t.reload\t\t\t= e1000e_reload_nvm_generic,\n\t.update\t\t\t= e1000e_update_nvm_checksum_generic,\n\t.valid_led_default\t= e1000e_valid_led_default,\n\t.validate\t\t= e1000e_validate_nvm_checksum_generic,\n\t.write\t\t\t= e1000_write_nvm_80003es2lan,\n};\n\nconst struct e1000_info e1000_es2_info = {\n\t.mac\t\t\t= e1000_80003es2lan,\n\t.flags\t\t\t= FLAG_HAS_HW_VLAN_FILTER\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_APME_IN_CTRL3\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_RX_NEEDS_RESTART  \n\t\t\t\t  | FLAG_TARC_SET_BIT_ZERO  \n\t\t\t\t  | FLAG_APME_CHECK_PORT_B\n\t\t\t\t  | FLAG_DISABLE_FC_PAUSE_TIME,  \n\t.flags2\t\t\t= FLAG2_DMA_BURST,\n\t.pba\t\t\t= 38,\n\t.max_hw_frame_size\t= DEFAULT_JUMBO,\n\t.get_variants\t\t= e1000_get_variants_80003es2lan,\n\t.mac_ops\t\t= &es2_mac_ops,\n\t.phy_ops\t\t= &es2_phy_ops,\n\t.nvm_ops\t\t= &es2_nvm_ops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}