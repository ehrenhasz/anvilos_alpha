{
  "module_name": "e1000.h",
  "hash_id": "9d36b7b1796212bfe507f71ba5f9b462f8dd1a8a9505d2534a9c4a534407f3ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/e1000.h",
  "human_readable_source": " \n \n\n \n\n#ifndef _E1000_H_\n#define _E1000_H_\n\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/io.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/crc32.h>\n#include <linux/if_vlan.h>\n#include <linux/timecounter.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_classify.h>\n#include <linux/mii.h>\n#include <linux/mdio.h>\n#include <linux/mutex.h>\n#include <linux/pm_qos.h>\n#include \"hw.h\"\n\nstruct e1000_info;\n\n#define e_dbg(format, arg...) \\\n\tnetdev_dbg(hw->adapter->netdev, format, ## arg)\n#define e_err(format, arg...) \\\n\tnetdev_err(adapter->netdev, format, ## arg)\n#define e_info(format, arg...) \\\n\tnetdev_info(adapter->netdev, format, ## arg)\n#define e_warn(format, arg...) \\\n\tnetdev_warn(adapter->netdev, format, ## arg)\n#define e_notice(format, arg...) \\\n\tnetdev_notice(adapter->netdev, format, ## arg)\n\n \n#define E1000E_INT_MODE_LEGACY\t\t0\n#define E1000E_INT_MODE_MSI\t\t1\n#define E1000E_INT_MODE_MSIX\t\t2\n\n \n#define E1000_DEFAULT_TXD\t\t256\n#define E1000_MAX_TXD\t\t\t4096\n#define E1000_MIN_TXD\t\t\t64\n\n#define E1000_DEFAULT_RXD\t\t256\n#define E1000_MAX_RXD\t\t\t4096\n#define E1000_MIN_RXD\t\t\t64\n\n#define E1000_MIN_ITR_USECS\t\t10  \n#define E1000_MAX_ITR_USECS\t\t10000  \n\n#define E1000_FC_PAUSE_TIME\t\t0x0680  \n\n \n \n#define E1000_RX_BUFFER_WRITE\t\t16  \n\n#define AUTO_ALL_MODES\t\t\t0\n#define E1000_EEPROM_APME\t\t0x0400\n\n#define E1000_MNG_VLAN_NONE\t\t(-1)\n\n#define DEFAULT_JUMBO\t\t\t9234\n\n \n#define LINK_TIMEOUT\t\t100\n\n \n#define E1000_CHECK_RESET_COUNT\t\t25\n\n#define PCICFG_DESC_RING_STATUS\t\t0xe4\n#define FLUSH_DESC_REQUIRED\t\t0x100\n\n \n#define E1000_TXDCTL_DMA_BURST_ENABLE                          \\\n\t(E1000_TXDCTL_GRAN |    \\\n\t E1000_TXDCTL_COUNT_DESC |                             \\\n\t (1u << 16) |  \\\n\t (1u << 8)  |                               \\\n\t 0x1f)         \n\n#define E1000_RXDCTL_DMA_BURST_ENABLE                          \\\n\t(0x01000000 |           \\\n\t (4u << 16) |           \\\n\t (4u << 8)  |           \\\n\t 0x20)         \n\n#define E1000_TIDV_FPD BIT(31)\n#define E1000_RDTR_FPD BIT(31)\n\nenum e1000_boards {\n\tboard_82571,\n\tboard_82572,\n\tboard_82573,\n\tboard_82574,\n\tboard_82583,\n\tboard_80003es2lan,\n\tboard_ich8lan,\n\tboard_ich9lan,\n\tboard_ich10lan,\n\tboard_pchlan,\n\tboard_pch2lan,\n\tboard_pch_lpt,\n\tboard_pch_spt,\n\tboard_pch_cnp,\n\tboard_pch_tgp,\n\tboard_pch_adp,\n\tboard_pch_mtp\n};\n\nstruct e1000_ps_page {\n\tstruct page *page;\n\tu64 dma;  \n};\n\n \nstruct e1000_buffer {\n\tdma_addr_t dma;\n\tstruct sk_buff *skb;\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tunsigned long time_stamp;\n\t\t\tu16 length;\n\t\t\tu16 next_to_watch;\n\t\t\tunsigned int segs;\n\t\t\tunsigned int bytecount;\n\t\t\tu16 mapped_as_page;\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tstruct e1000_ps_page *ps_pages;\n\t\t\tstruct page *page;\n\t\t};\n\t};\n};\n\nstruct e1000_ring {\n\tstruct e1000_adapter *adapter;\t \n\tvoid *desc;\t\t\t \n\tdma_addr_t dma;\t\t\t \n\tunsigned int size;\t\t \n\tunsigned int count;\t\t \n\n\tu16 next_to_use;\n\tu16 next_to_clean;\n\n\tvoid __iomem *head;\n\tvoid __iomem *tail;\n\n\t \n\tstruct e1000_buffer *buffer_info;\n\n\tchar name[IFNAMSIZ + 5];\n\tu32 ims_val;\n\tu32 itr_val;\n\tvoid __iomem *itr_register;\n\tint set_itr;\n\n\tstruct sk_buff *rx_skb_top;\n};\n\n \nstruct e1000_phy_regs {\n\tu16 bmcr;\t\t \n\tu16 bmsr;\t\t \n\tu16 advertise;\t\t \n\tu16 lpa;\t\t \n\tu16 expansion;\t\t \n\tu16 ctrl1000;\t\t \n\tu16 stat1000;\t\t \n\tu16 estatus;\t\t \n};\n\n \nstruct e1000_adapter {\n\tstruct timer_list watchdog_timer;\n\tstruct timer_list phy_info_timer;\n\tstruct timer_list blink_timer;\n\n\tstruct work_struct reset_task;\n\tstruct work_struct watchdog_task;\n\n\tconst struct e1000_info *ei;\n\n\tunsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];\n\tu32 bd_number;\n\tu32 rx_buffer_len;\n\tu16 mng_vlan_id;\n\tu16 link_speed;\n\tu16 link_duplex;\n\tu16 eeprom_vers;\n\n\t \n\tunsigned long state;\n\n\t \n\tu32 itr;\n\tu32 itr_setting;\n\tu16 tx_itr;\n\tu16 rx_itr;\n\n\t \n\tstruct e1000_ring *tx_ring ____cacheline_aligned_in_smp;\n\tu32 tx_fifo_limit;\n\n\tstruct napi_struct napi;\n\n\tunsigned int uncorr_errors;\t \n\tunsigned int corr_errors;\t \n\tunsigned int restart_queue;\n\tu32 txd_cmd;\n\n\tbool detect_tx_hung;\n\tbool tx_hang_recheck;\n\tu8 tx_timeout_factor;\n\n\tu32 tx_int_delay;\n\tu32 tx_abs_int_delay;\n\n\tunsigned int total_tx_bytes;\n\tunsigned int total_tx_packets;\n\tunsigned int total_rx_bytes;\n\tunsigned int total_rx_packets;\n\n\t \n\tu64 tpt_old;\n\tu64 colc_old;\n\tu32 gotc;\n\tu64 gotc_old;\n\tu32 tx_timeout_count;\n\tu32 tx_fifo_head;\n\tu32 tx_head_addr;\n\tu32 tx_fifo_size;\n\tu32 tx_dma_failed;\n\tu32 tx_hwtstamp_timeouts;\n\tu32 tx_hwtstamp_skipped;\n\n\t \n\tbool (*clean_rx)(struct e1000_ring *ring, int *work_done,\n\t\t\t int work_to_do) ____cacheline_aligned_in_smp;\n\tvoid (*alloc_rx_buf)(struct e1000_ring *ring, int cleaned_count,\n\t\t\t     gfp_t gfp);\n\tstruct e1000_ring *rx_ring;\n\n\tu32 rx_int_delay;\n\tu32 rx_abs_int_delay;\n\n\t \n\tu64 hw_csum_err;\n\tu64 hw_csum_good;\n\tu64 rx_hdr_split;\n\tu32 gorc;\n\tu64 gorc_old;\n\tu32 alloc_rx_buff_failed;\n\tu32 rx_dma_failed;\n\tu32 rx_hwtstamp_cleared;\n\n\tunsigned int rx_ps_pages;\n\tu16 rx_ps_bsize0;\n\tu32 max_frame_size;\n\tu32 min_frame_size;\n\n\t \n\tstruct net_device *netdev;\n\tstruct pci_dev *pdev;\n\n\t \n\tstruct e1000_hw hw;\n\n\tspinlock_t stats64_lock;\t \n\tstruct e1000_hw_stats stats;\n\tstruct e1000_phy_info phy_info;\n\tstruct e1000_phy_stats phy_stats;\n\n\t \n\tstruct e1000_phy_regs phy_regs;\n\n\tstruct e1000_ring test_tx_ring;\n\tstruct e1000_ring test_rx_ring;\n\tu32 test_icr;\n\n\tu32 msg_enable;\n\tunsigned int num_vectors;\n\tstruct msix_entry *msix_entries;\n\tint int_mode;\n\tu32 eiac_mask;\n\n\tu32 eeprom_wol;\n\tu32 wol;\n\tu32 pba;\n\tu32 max_hw_frame_size;\n\n\tbool fc_autoneg;\n\n\tunsigned int flags;\n\tunsigned int flags2;\n\tstruct work_struct downshift_task;\n\tstruct work_struct update_phy_task;\n\tstruct work_struct print_hang_task;\n\n\tint phy_hang_count;\n\n\tu16 tx_ring_count;\n\tu16 rx_ring_count;\n\n\tstruct hwtstamp_config hwtstamp_config;\n\tstruct delayed_work systim_overflow_work;\n\tstruct sk_buff *tx_hwtstamp_skb;\n\tunsigned long tx_hwtstamp_start;\n\tstruct work_struct tx_hwtstamp_work;\n\tspinlock_t systim_lock;\t \n\tstruct cyclecounter cc;\n\tstruct timecounter tc;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\tstruct pm_qos_request pm_qos_req;\n\tlong ptp_delta;\n\n\tu16 eee_advert;\n};\n\nstruct e1000_info {\n\tenum e1000_mac_type\tmac;\n\tunsigned int\t\tflags;\n\tunsigned int\t\tflags2;\n\tu32\t\t\tpba;\n\tu32\t\t\tmax_hw_frame_size;\n\ts32\t\t\t(*get_variants)(struct e1000_adapter *);\n\tconst struct e1000_mac_operations *mac_ops;\n\tconst struct e1000_phy_operations *phy_ops;\n\tconst struct e1000_nvm_operations *nvm_ops;\n};\n\ns32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca);\n\n \n#define INCVALUE_96MHZ\t\t125\n#define INCVALUE_SHIFT_96MHZ\t17\n#define INCPERIOD_SHIFT_96MHZ\t2\n#define INCPERIOD_96MHZ\t\t(12 >> INCPERIOD_SHIFT_96MHZ)\n\n#define INCVALUE_25MHZ\t\t40\n#define INCVALUE_SHIFT_25MHZ\t18\n#define INCPERIOD_25MHZ\t\t1\n\n#define INCVALUE_24MHZ\t\t125\n#define INCVALUE_SHIFT_24MHZ\t14\n#define INCPERIOD_24MHZ\t\t3\n\n#define INCVALUE_38400KHZ\t26\n#define INCVALUE_SHIFT_38400KHZ\t19\n#define INCPERIOD_38400KHZ\t1\n\n \n#define E1000_SYSTIM_OVERFLOW_PERIOD\t(HZ * 60 * 60 * 4)\n#define E1000_MAX_82574_SYSTIM_REREADS\t50\n#define E1000_82574_SYSTIM_EPSILON\t(1ULL << 35ULL)\n\n \n#define FLAG_HAS_AMT                      BIT(0)\n#define FLAG_HAS_FLASH                    BIT(1)\n#define FLAG_HAS_HW_VLAN_FILTER           BIT(2)\n#define FLAG_HAS_WOL                      BIT(3)\n \n#define FLAG_HAS_CTRLEXT_ON_LOAD          BIT(5)\n#define FLAG_HAS_SWSM_ON_LOAD             BIT(6)\n#define FLAG_HAS_JUMBO_FRAMES             BIT(7)\n#define FLAG_READ_ONLY_NVM                BIT(8)\n#define FLAG_IS_ICH                       BIT(9)\n#define FLAG_HAS_MSIX                     BIT(10)\n#define FLAG_HAS_SMART_POWER_DOWN         BIT(11)\n#define FLAG_IS_QUAD_PORT_A               BIT(12)\n#define FLAG_IS_QUAD_PORT                 BIT(13)\n#define FLAG_HAS_HW_TIMESTAMP             BIT(14)\n#define FLAG_APME_IN_WUC                  BIT(15)\n#define FLAG_APME_IN_CTRL3                BIT(16)\n#define FLAG_APME_CHECK_PORT_B            BIT(17)\n#define FLAG_DISABLE_FC_PAUSE_TIME        BIT(18)\n#define FLAG_NO_WAKE_UCAST                BIT(19)\n#define FLAG_MNG_PT_ENABLED               BIT(20)\n#define FLAG_RESET_OVERWRITES_LAA         BIT(21)\n#define FLAG_TARC_SPEED_MODE_BIT          BIT(22)\n#define FLAG_TARC_SET_BIT_ZERO            BIT(23)\n#define FLAG_RX_NEEDS_RESTART             BIT(24)\n#define FLAG_LSC_GIG_SPEED_DROP           BIT(25)\n#define FLAG_SMART_POWER_DOWN             BIT(26)\n#define FLAG_MSI_ENABLED                  BIT(27)\n \n#define FLAG_TSO_FORCE                    BIT(29)\n#define FLAG_RESTART_NOW                  BIT(30)\n#define FLAG_MSI_TEST_FAILED              BIT(31)\n\n#define FLAG2_CRC_STRIPPING               BIT(0)\n#define FLAG2_HAS_PHY_WAKEUP              BIT(1)\n#define FLAG2_IS_DISCARDING               BIT(2)\n#define FLAG2_DISABLE_ASPM_L1             BIT(3)\n#define FLAG2_HAS_PHY_STATS               BIT(4)\n#define FLAG2_HAS_EEE                     BIT(5)\n#define FLAG2_DMA_BURST                   BIT(6)\n#define FLAG2_DISABLE_ASPM_L0S            BIT(7)\n#define FLAG2_DISABLE_AIM                 BIT(8)\n#define FLAG2_CHECK_PHY_HANG              BIT(9)\n#define FLAG2_NO_DISABLE_RX               BIT(10)\n#define FLAG2_PCIM2PCI_ARBITER_WA         BIT(11)\n#define FLAG2_DFLT_CRC_STRIPPING          BIT(12)\n#define FLAG2_CHECK_RX_HWTSTAMP           BIT(13)\n#define FLAG2_CHECK_SYSTIM_OVERFLOW       BIT(14)\n#define FLAG2_ENABLE_S0IX_FLOWS           BIT(15)\n\n#define E1000_RX_DESC_PS(R, i)\t    \\\n\t(&(((union e1000_rx_desc_packet_split *)((R).desc))[i]))\n#define E1000_RX_DESC_EXT(R, i)\t    \\\n\t(&(((union e1000_rx_desc_extended *)((R).desc))[i]))\n#define E1000_GET_DESC(R, i, type)\t(&(((struct type *)((R).desc))[i]))\n#define E1000_TX_DESC(R, i)\t\tE1000_GET_DESC(R, i, e1000_tx_desc)\n#define E1000_CONTEXT_DESC(R, i)\tE1000_GET_DESC(R, i, e1000_context_desc)\n\nenum e1000_state_t {\n\t__E1000_TESTING,\n\t__E1000_RESETTING,\n\t__E1000_ACCESS_SHARED_RESOURCE,\n\t__E1000_DOWN\n};\n\nenum latency_range {\n\tlowest_latency = 0,\n\tlow_latency = 1,\n\tbulk_latency = 2,\n\tlatency_invalid = 255\n};\n\nextern char e1000e_driver_name[];\n\nvoid e1000e_check_options(struct e1000_adapter *adapter);\nvoid e1000e_set_ethtool_ops(struct net_device *netdev);\n\nint e1000e_open(struct net_device *netdev);\nint e1000e_close(struct net_device *netdev);\nvoid e1000e_up(struct e1000_adapter *adapter);\nvoid e1000e_down(struct e1000_adapter *adapter, bool reset);\nvoid e1000e_reinit_locked(struct e1000_adapter *adapter);\nvoid e1000e_reset(struct e1000_adapter *adapter);\nvoid e1000e_power_up_phy(struct e1000_adapter *adapter);\nint e1000e_setup_rx_resources(struct e1000_ring *ring);\nint e1000e_setup_tx_resources(struct e1000_ring *ring);\nvoid e1000e_free_rx_resources(struct e1000_ring *ring);\nvoid e1000e_free_tx_resources(struct e1000_ring *ring);\nvoid e1000e_get_stats64(struct net_device *netdev,\n\t\t\tstruct rtnl_link_stats64 *stats);\nvoid e1000e_set_interrupt_capability(struct e1000_adapter *adapter);\nvoid e1000e_reset_interrupt_capability(struct e1000_adapter *adapter);\nvoid e1000e_get_hw_control(struct e1000_adapter *adapter);\nvoid e1000e_release_hw_control(struct e1000_adapter *adapter);\nvoid e1000e_write_itr(struct e1000_adapter *adapter, u32 itr);\n\nextern unsigned int copybreak;\n\nextern const struct e1000_info e1000_82571_info;\nextern const struct e1000_info e1000_82572_info;\nextern const struct e1000_info e1000_82573_info;\nextern const struct e1000_info e1000_82574_info;\nextern const struct e1000_info e1000_82583_info;\nextern const struct e1000_info e1000_ich8_info;\nextern const struct e1000_info e1000_ich9_info;\nextern const struct e1000_info e1000_ich10_info;\nextern const struct e1000_info e1000_pch_info;\nextern const struct e1000_info e1000_pch2_info;\nextern const struct e1000_info e1000_pch_lpt_info;\nextern const struct e1000_info e1000_pch_spt_info;\nextern const struct e1000_info e1000_pch_cnp_info;\nextern const struct e1000_info e1000_pch_tgp_info;\nextern const struct e1000_info e1000_pch_adp_info;\nextern const struct e1000_info e1000_pch_mtp_info;\nextern const struct e1000_info e1000_es2_info;\n\nvoid e1000e_ptp_init(struct e1000_adapter *adapter);\nvoid e1000e_ptp_remove(struct e1000_adapter *adapter);\n\nu64 e1000e_read_systim(struct e1000_adapter *adapter,\n\t\t       struct ptp_system_timestamp *sts);\n\nstatic inline s32 e1000_phy_hw_reset(struct e1000_hw *hw)\n{\n\treturn hw->phy.ops.reset(hw);\n}\n\nstatic inline s32 e1e_rphy(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn hw->phy.ops.read_reg(hw, offset, data);\n}\n\nstatic inline s32 e1e_rphy_locked(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn hw->phy.ops.read_reg_locked(hw, offset, data);\n}\n\nstatic inline s32 e1e_wphy(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn hw->phy.ops.write_reg(hw, offset, data);\n}\n\nstatic inline s32 e1e_wphy_locked(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn hw->phy.ops.write_reg_locked(hw, offset, data);\n}\n\nvoid e1000e_reload_nvm_generic(struct e1000_hw *hw);\n\nstatic inline s32 e1000e_read_mac_addr(struct e1000_hw *hw)\n{\n\tif (hw->mac.ops.read_mac_addr)\n\t\treturn hw->mac.ops.read_mac_addr(hw);\n\n\treturn e1000_read_mac_addr_generic(hw);\n}\n\nstatic inline s32 e1000_validate_nvm_checksum(struct e1000_hw *hw)\n{\n\treturn hw->nvm.ops.validate(hw);\n}\n\nstatic inline s32 e1000e_update_nvm_checksum(struct e1000_hw *hw)\n{\n\treturn hw->nvm.ops.update(hw);\n}\n\nstatic inline s32 e1000_read_nvm(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t u16 *data)\n{\n\treturn hw->nvm.ops.read(hw, offset, words, data);\n}\n\nstatic inline s32 e1000_write_nvm(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t  u16 *data)\n{\n\treturn hw->nvm.ops.write(hw, offset, words, data);\n}\n\nstatic inline s32 e1000_get_phy_info(struct e1000_hw *hw)\n{\n\treturn hw->phy.ops.get_info(hw);\n}\n\nstatic inline u32 __er32(struct e1000_hw *hw, unsigned long reg)\n{\n\treturn readl(hw->hw_addr + reg);\n}\n\n#define er32(reg)\t__er32(hw, E1000_##reg)\n\nvoid __ew32(struct e1000_hw *hw, unsigned long reg, u32 val);\n\n#define ew32(reg, val)\t__ew32(hw, E1000_##reg, (val))\n\n#define e1e_flush()\ter32(STATUS)\n\n#define E1000_WRITE_REG_ARRAY(a, reg, offset, value) \\\n\t(__ew32((a), (reg + ((offset) << 2)), (value)))\n\n#define E1000_READ_REG_ARRAY(a, reg, offset) \\\n\t(readl((a)->hw_addr + reg + ((offset) << 2)))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}