{
  "module_name": "ethtool.c",
  "hash_id": "7b453a1fef6fe8022ae3a20f895e7b0e99ef1815df0293fa81bcc04f7a50f2b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/vmalloc.h>\n#include <linux/pm_runtime.h>\n\n#include \"e1000.h\"\n\nenum { NETDEV_STATS, E1000_STATS };\n\nstruct e1000_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint type;\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\nstatic const char e1000e_priv_flags_strings[][ETH_GSTRING_LEN] = {\n#define E1000E_PRIV_FLAGS_S0IX_ENABLED\tBIT(0)\n\t\"s0ix-enabled\",\n};\n\n#define E1000E_PRIV_FLAGS_STR_LEN ARRAY_SIZE(e1000e_priv_flags_strings)\n\n#define E1000_STAT(str, m) { \\\n\t\t.stat_string = str, \\\n\t\t.type = E1000_STATS, \\\n\t\t.sizeof_stat = sizeof(((struct e1000_adapter *)0)->m), \\\n\t\t.stat_offset = offsetof(struct e1000_adapter, m) }\n#define E1000_NETDEV_STAT(str, m) { \\\n\t\t.stat_string = str, \\\n\t\t.type = NETDEV_STATS, \\\n\t\t.sizeof_stat = sizeof(((struct rtnl_link_stats64 *)0)->m), \\\n\t\t.stat_offset = offsetof(struct rtnl_link_stats64, m) }\n\nstatic const struct e1000_stats e1000_gstrings_stats[] = {\n\tE1000_STAT(\"rx_packets\", stats.gprc),\n\tE1000_STAT(\"tx_packets\", stats.gptc),\n\tE1000_STAT(\"rx_bytes\", stats.gorc),\n\tE1000_STAT(\"tx_bytes\", stats.gotc),\n\tE1000_STAT(\"rx_broadcast\", stats.bprc),\n\tE1000_STAT(\"tx_broadcast\", stats.bptc),\n\tE1000_STAT(\"rx_multicast\", stats.mprc),\n\tE1000_STAT(\"tx_multicast\", stats.mptc),\n\tE1000_NETDEV_STAT(\"rx_errors\", rx_errors),\n\tE1000_NETDEV_STAT(\"tx_errors\", tx_errors),\n\tE1000_NETDEV_STAT(\"tx_dropped\", tx_dropped),\n\tE1000_STAT(\"multicast\", stats.mprc),\n\tE1000_STAT(\"collisions\", stats.colc),\n\tE1000_NETDEV_STAT(\"rx_length_errors\", rx_length_errors),\n\tE1000_NETDEV_STAT(\"rx_over_errors\", rx_over_errors),\n\tE1000_STAT(\"rx_crc_errors\", stats.crcerrs),\n\tE1000_NETDEV_STAT(\"rx_frame_errors\", rx_frame_errors),\n\tE1000_STAT(\"rx_no_buffer_count\", stats.rnbc),\n\tE1000_STAT(\"rx_missed_errors\", stats.mpc),\n\tE1000_STAT(\"tx_aborted_errors\", stats.ecol),\n\tE1000_STAT(\"tx_carrier_errors\", stats.tncrs),\n\tE1000_NETDEV_STAT(\"tx_fifo_errors\", tx_fifo_errors),\n\tE1000_NETDEV_STAT(\"tx_heartbeat_errors\", tx_heartbeat_errors),\n\tE1000_STAT(\"tx_window_errors\", stats.latecol),\n\tE1000_STAT(\"tx_abort_late_coll\", stats.latecol),\n\tE1000_STAT(\"tx_deferred_ok\", stats.dc),\n\tE1000_STAT(\"tx_single_coll_ok\", stats.scc),\n\tE1000_STAT(\"tx_multi_coll_ok\", stats.mcc),\n\tE1000_STAT(\"tx_timeout_count\", tx_timeout_count),\n\tE1000_STAT(\"tx_restart_queue\", restart_queue),\n\tE1000_STAT(\"rx_long_length_errors\", stats.roc),\n\tE1000_STAT(\"rx_short_length_errors\", stats.ruc),\n\tE1000_STAT(\"rx_align_errors\", stats.algnerrc),\n\tE1000_STAT(\"tx_tcp_seg_good\", stats.tsctc),\n\tE1000_STAT(\"tx_tcp_seg_failed\", stats.tsctfc),\n\tE1000_STAT(\"rx_flow_control_xon\", stats.xonrxc),\n\tE1000_STAT(\"rx_flow_control_xoff\", stats.xoffrxc),\n\tE1000_STAT(\"tx_flow_control_xon\", stats.xontxc),\n\tE1000_STAT(\"tx_flow_control_xoff\", stats.xofftxc),\n\tE1000_STAT(\"rx_csum_offload_good\", hw_csum_good),\n\tE1000_STAT(\"rx_csum_offload_errors\", hw_csum_err),\n\tE1000_STAT(\"rx_header_split\", rx_hdr_split),\n\tE1000_STAT(\"alloc_rx_buff_failed\", alloc_rx_buff_failed),\n\tE1000_STAT(\"tx_smbus\", stats.mgptc),\n\tE1000_STAT(\"rx_smbus\", stats.mgprc),\n\tE1000_STAT(\"dropped_smbus\", stats.mgpdc),\n\tE1000_STAT(\"rx_dma_failed\", rx_dma_failed),\n\tE1000_STAT(\"tx_dma_failed\", tx_dma_failed),\n\tE1000_STAT(\"rx_hwtstamp_cleared\", rx_hwtstamp_cleared),\n\tE1000_STAT(\"uncorr_ecc_errors\", uncorr_errors),\n\tE1000_STAT(\"corr_ecc_errors\", corr_errors),\n\tE1000_STAT(\"tx_hwtstamp_timeouts\", tx_hwtstamp_timeouts),\n\tE1000_STAT(\"tx_hwtstamp_skipped\", tx_hwtstamp_skipped),\n};\n\n#define E1000_GLOBAL_STATS_LEN\tARRAY_SIZE(e1000_gstrings_stats)\n#define E1000_STATS_LEN (E1000_GLOBAL_STATS_LEN)\nstatic const char e1000_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register test  (offline)\", \"Eeprom test    (offline)\",\n\t\"Interrupt test (offline)\", \"Loopback test  (offline)\",\n\t\"Link test   (on/offline)\"\n};\n\n#define E1000_TEST_LEN ARRAY_SIZE(e1000_gstrings_test)\n\nstatic int e1000_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tu32 speed, supported, advertising, lp_advertising, lpa_t;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\tsupported = (SUPPORTED_10baseT_Half |\n\t\t\t     SUPPORTED_10baseT_Full |\n\t\t\t     SUPPORTED_100baseT_Half |\n\t\t\t     SUPPORTED_100baseT_Full |\n\t\t\t     SUPPORTED_1000baseT_Full |\n\t\t\t     SUPPORTED_Asym_Pause |\n\t\t\t     SUPPORTED_Autoneg |\n\t\t\t     SUPPORTED_Pause |\n\t\t\t     SUPPORTED_TP);\n\t\tif (hw->phy.type == e1000_phy_ife)\n\t\t\tsupported &= ~SUPPORTED_1000baseT_Full;\n\t\tadvertising = ADVERTISED_TP;\n\n\t\tif (hw->mac.autoneg == 1) {\n\t\t\tadvertising |= ADVERTISED_Autoneg;\n\t\t\t \n\t\t\tadvertising |= hw->phy.autoneg_advertised;\n\t\t}\n\n\t\tcmd->base.port = PORT_TP;\n\t\tcmd->base.phy_address = hw->phy.addr;\n\t} else {\n\t\tsupported   = (SUPPORTED_1000baseT_Full |\n\t\t\t       SUPPORTED_FIBRE |\n\t\t\t       SUPPORTED_Autoneg);\n\n\t\tadvertising = (ADVERTISED_1000baseT_Full |\n\t\t\t       ADVERTISED_FIBRE |\n\t\t\t       ADVERTISED_Autoneg);\n\n\t\tcmd->base.port = PORT_FIBRE;\n\t}\n\n\tspeed = SPEED_UNKNOWN;\n\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\n\tif (netif_running(netdev)) {\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tspeed = adapter->link_speed;\n\t\t\tcmd->base.duplex = adapter->link_duplex - 1;\n\t\t}\n\t} else if (!pm_runtime_suspended(netdev->dev.parent)) {\n\t\tu32 status = er32(STATUS);\n\n\t\tif (status & E1000_STATUS_LU) {\n\t\t\tif (status & E1000_STATUS_SPEED_1000)\n\t\t\t\tspeed = SPEED_1000;\n\t\t\telse if (status & E1000_STATUS_SPEED_100)\n\t\t\t\tspeed = SPEED_100;\n\t\t\telse\n\t\t\t\tspeed = SPEED_10;\n\n\t\t\tif (status & E1000_STATUS_FD)\n\t\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\t\telse\n\t\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t\t}\n\t}\n\n\tcmd->base.speed = speed;\n\tcmd->base.autoneg = ((hw->phy.media_type == e1000_media_type_fiber) ||\n\t\t\t hw->mac.autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\t \n\tif ((hw->phy.media_type == e1000_media_type_copper) &&\n\t    netif_carrier_ok(netdev))\n\t\tcmd->base.eth_tp_mdix = hw->phy.is_mdix ?\n\t\t\tETH_TP_MDI_X : ETH_TP_MDI;\n\telse\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\n\tif (hw->phy.mdix == AUTO_ALL_MODES)\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\n\telse\n\t\tcmd->base.eth_tp_mdix_ctrl = hw->phy.mdix;\n\n\tif (hw->phy.media_type != e1000_media_type_copper)\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_INVALID;\n\n\tlpa_t = mii_stat1000_to_ethtool_lpa_t(adapter->phy_regs.stat1000);\n\tlp_advertising = lpa_t |\n\tmii_lpa_to_ethtool_lpa_t(adapter->phy_regs.lpa);\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,\n\t\t\t\t\t\tlp_advertising);\n\n\treturn 0;\n}\n\nstatic int e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx)\n{\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\n\tmac->autoneg = 0;\n\n\t \n\tif ((spd & 1) || (dplx & ~1))\n\t\tgoto err_inval;\n\n\t \n\tif ((adapter->hw.phy.media_type == e1000_media_type_fiber) &&\n\t    (spd != SPEED_1000) && (dplx != DUPLEX_FULL)) {\n\t\tgoto err_inval;\n\t}\n\n\tswitch (spd + dplx) {\n\tcase SPEED_10 + DUPLEX_HALF:\n\t\tmac->forced_speed_duplex = ADVERTISE_10_HALF;\n\t\tbreak;\n\tcase SPEED_10 + DUPLEX_FULL:\n\t\tmac->forced_speed_duplex = ADVERTISE_10_FULL;\n\t\tbreak;\n\tcase SPEED_100 + DUPLEX_HALF:\n\t\tmac->forced_speed_duplex = ADVERTISE_100_HALF;\n\t\tbreak;\n\tcase SPEED_100 + DUPLEX_FULL:\n\t\tmac->forced_speed_duplex = ADVERTISE_100_FULL;\n\t\tbreak;\n\tcase SPEED_1000 + DUPLEX_FULL:\n\t\tif (adapter->hw.phy.media_type == e1000_media_type_copper) {\n\t\t\tmac->autoneg = 1;\n\t\t\tadapter->hw.phy.autoneg_advertised =\n\t\t\t\tADVERTISE_1000_FULL;\n\t\t} else {\n\t\t\tmac->forced_speed_duplex = ADVERTISE_1000_FULL;\n\t\t}\n\t\tbreak;\n\tcase SPEED_1000 + DUPLEX_HALF:\t \n\tdefault:\n\t\tgoto err_inval;\n\t}\n\n\t \n\tadapter->hw.phy.mdix = AUTO_ALL_MODES;\n\n\treturn 0;\n\nerr_inval:\n\te_err(\"Unsupported Speed/Duplex configuration\\n\");\n\treturn -EINVAL;\n}\n\nstatic int e1000_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint ret_val = 0;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\t \n\tif (hw->phy.ops.check_reset_block &&\n\t    hw->phy.ops.check_reset_block(hw)) {\n\t\te_err(\"Cannot change link characteristics when SoL/IDER is active.\\n\");\n\t\tret_val = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\tif (hw->phy.media_type != e1000_media_type_copper) {\n\t\t\tret_val = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((cmd->base.eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&\n\t\t    (cmd->base.autoneg != AUTONEG_ENABLE)) {\n\t\t\te_err(\"forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\\n\");\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\thw->mac.autoneg = 1;\n\t\tif (hw->phy.media_type == e1000_media_type_fiber)\n\t\t\thw->phy.autoneg_advertised = ADVERTISED_1000baseT_Full |\n\t\t\t    ADVERTISED_FIBRE | ADVERTISED_Autoneg;\n\t\telse\n\t\t\thw->phy.autoneg_advertised = advertising |\n\t\t\t    ADVERTISED_TP | ADVERTISED_Autoneg;\n\t\tadvertising = hw->phy.autoneg_advertised;\n\t\tif (adapter->fc_autoneg)\n\t\t\thw->fc.requested_mode = e1000_fc_default;\n\t} else {\n\t\tu32 speed = cmd->base.speed;\n\t\t \n\t\tif (e1000_set_spd_dplx(adapter, speed, cmd->base.duplex)) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\t \n\t\tif (cmd->base.eth_tp_mdix_ctrl == ETH_TP_MDI_AUTO)\n\t\t\thw->phy.mdix = AUTO_ALL_MODES;\n\t\telse\n\t\t\thw->phy.mdix = cmd->base.eth_tp_mdix_ctrl;\n\t}\n\n\t \n\tif (netif_running(adapter->netdev)) {\n\t\te1000e_down(adapter, true);\n\t\te1000e_up(adapter);\n\t} else {\n\t\te1000e_reset(adapter);\n\t}\n\nout:\n\tpm_runtime_put_sync(netdev->dev.parent);\n\tclear_bit(__E1000_RESETTING, &adapter->state);\n\treturn ret_val;\n}\n\nstatic void e1000_get_pauseparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tpause->autoneg =\n\t    (adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);\n\n\tif (hw->fc.current_mode == e1000_fc_rx_pause) {\n\t\tpause->rx_pause = 1;\n\t} else if (hw->fc.current_mode == e1000_fc_tx_pause) {\n\t\tpause->tx_pause = 1;\n\t} else if (hw->fc.current_mode == e1000_fc_full) {\n\t\tpause->rx_pause = 1;\n\t\tpause->tx_pause = 1;\n\t}\n}\n\nstatic int e1000_set_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint retval = 0;\n\n\tadapter->fc_autoneg = pause->autoneg;\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tif (adapter->fc_autoneg == AUTONEG_ENABLE) {\n\t\thw->fc.requested_mode = e1000_fc_default;\n\t\tif (netif_running(adapter->netdev)) {\n\t\t\te1000e_down(adapter, true);\n\t\t\te1000e_up(adapter);\n\t\t} else {\n\t\t\te1000e_reset(adapter);\n\t\t}\n\t} else {\n\t\tif (pause->rx_pause && pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_full;\n\t\telse if (pause->rx_pause && !pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_rx_pause;\n\t\telse if (!pause->rx_pause && pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_tx_pause;\n\t\telse if (!pause->rx_pause && !pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_none;\n\n\t\thw->fc.current_mode = hw->fc.requested_mode;\n\n\t\tif (hw->phy.media_type == e1000_media_type_fiber) {\n\t\t\tretval = hw->mac.ops.setup_link(hw);\n\t\t\t \n\t\t} else {\n\t\t\tretval = e1000e_force_mac_fc(hw);\n\t\t\tif (retval)\n\t\t\t\tgoto out;\n\t\t\te1000e_set_fc_watermarks(hw);\n\t\t}\n\t}\n\nout:\n\tpm_runtime_put_sync(netdev->dev.parent);\n\tclear_bit(__E1000_RESETTING, &adapter->state);\n\treturn retval;\n}\n\nstatic u32 e1000_get_msglevel(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\treturn adapter->msg_enable;\n}\n\nstatic void e1000_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tadapter->msg_enable = data;\n}\n\nstatic int e1000_get_regs_len(struct net_device __always_unused *netdev)\n{\n#define E1000_REGS_LEN 32\t \n\treturn E1000_REGS_LEN * sizeof(u32);\n}\n\nstatic void e1000_get_regs(struct net_device *netdev,\n\t\t\t   struct ethtool_regs *regs, void *p)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu16 phy_data;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tmemset(p, 0, E1000_REGS_LEN * sizeof(u32));\n\n\tregs->version = (1u << 24) |\n\t\t\t(adapter->pdev->revision << 16) |\n\t\t\tadapter->pdev->device;\n\n\tregs_buff[0] = er32(CTRL);\n\tregs_buff[1] = er32(STATUS);\n\n\tregs_buff[2] = er32(RCTL);\n\tregs_buff[3] = er32(RDLEN(0));\n\tregs_buff[4] = er32(RDH(0));\n\tregs_buff[5] = er32(RDT(0));\n\tregs_buff[6] = er32(RDTR);\n\n\tregs_buff[7] = er32(TCTL);\n\tregs_buff[8] = er32(TDLEN(0));\n\tregs_buff[9] = er32(TDH(0));\n\tregs_buff[10] = er32(TDT(0));\n\tregs_buff[11] = er32(TIDV);\n\n\tregs_buff[12] = adapter->hw.phy.type;\t \n\n\t \n\tif (hw->phy.type == e1000_phy_m88) {\n\t\te1e_rphy(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\t\tregs_buff[13] = (u32)phy_data;  \n\t\tregs_buff[14] = 0;   \n\t\tregs_buff[15] = 0;   \n\t\tregs_buff[16] = 0;   \n\t\te1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\t\tregs_buff[17] = (u32)phy_data;  \n\t\tregs_buff[18] = regs_buff[13];  \n\t\tregs_buff[19] = 0;   \n\t\tregs_buff[20] = regs_buff[17];  \n\t\t \n\t\tregs_buff[22] = adapter->phy_stats.receive_errors;\n\t\tregs_buff[23] = regs_buff[13];  \n\t}\n\tregs_buff[21] = 0;\t \n\te1e_rphy(hw, MII_STAT1000, &phy_data);\n\tregs_buff[24] = (u32)phy_data;\t \n\tregs_buff[25] = regs_buff[24];\t \n\n\tpm_runtime_put_sync(netdev->dev.parent);\n}\n\nstatic int e1000_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\treturn adapter->hw.nvm.word_size * 2;\n}\n\nstatic int e1000_get_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tint first_word;\n\tint last_word;\n\tint ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = adapter->pdev->vendor | (adapter->pdev->device << 16);\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tif (hw->nvm.type == e1000_nvm_eeprom_spi) {\n\t\tret_val = e1000_read_nvm(hw, first_word,\n\t\t\t\t\t last_word - first_word + 1,\n\t\t\t\t\t eeprom_buff);\n\t} else {\n\t\tfor (i = 0; i < last_word - first_word + 1; i++) {\n\t\t\tret_val = e1000_read_nvm(hw, first_word + i, 1,\n\t\t\t\t\t\t &eeprom_buff[i]);\n\t\t\tif (ret_val)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\tif (ret_val) {\n\t\t \n\t\tmemset(eeprom_buff, 0xff, sizeof(u16) *\n\t\t       (last_word - first_word + 1));\n\t} else {\n\t\t \n\t\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\t\tle16_to_cpus(&eeprom_buff[i]);\n\t}\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n}\n\nstatic int e1000_set_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tvoid *ptr;\n\tint max_len;\n\tint first_word;\n\tint last_word;\n\tint ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (eeprom->magic !=\n\t    (adapter->pdev->vendor | (adapter->pdev->device << 16)))\n\t\treturn -EFAULT;\n\n\tif (adapter->flags & FLAG_READ_ONLY_NVM)\n\t\treturn -EINVAL;\n\n\tmax_len = hw->nvm.word_size * 2;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_buff = kmalloc(max_len, GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tptr = (void *)eeprom_buff;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tif (eeprom->offset & 1) {\n\t\t \n\t\t \n\t\tret_val = e1000_read_nvm(hw, first_word, 1, &eeprom_buff[0]);\n\t\tptr++;\n\t}\n\tif (((eeprom->offset + eeprom->len) & 1) && (!ret_val))\n\t\t \n\t\t \n\t\tret_val = e1000_read_nvm(hw, last_word, 1,\n\t\t\t\t\t &eeprom_buff[last_word - first_word]);\n\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(ptr, bytes, eeprom->len);\n\n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tcpu_to_le16s(&eeprom_buff[i]);\n\n\tret_val = e1000_write_nvm(hw, first_word,\n\t\t\t\t  last_word - first_word + 1, eeprom_buff);\n\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tif ((first_word <= NVM_CHECKSUM_REG) ||\n\t    (hw->mac.type == e1000_82583) ||\n\t    (hw->mac.type == e1000_82574) ||\n\t    (hw->mac.type == e1000_82573))\n\t\tret_val = e1000e_update_nvm_checksum(hw);\n\nout:\n\tpm_runtime_put_sync(netdev->dev.parent);\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic void e1000_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver, e1000e_driver_name, sizeof(drvinfo->driver));\n\n\t \n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%d.%d-%d\",\n\t\t (adapter->eeprom_vers & 0xF000) >> 12,\n\t\t (adapter->eeprom_vers & 0x0FF0) >> 4,\n\t\t (adapter->eeprom_vers & 0x000F));\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void e1000_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tring->rx_max_pending = E1000_MAX_RXD;\n\tring->tx_max_pending = E1000_MAX_TXD;\n\tring->rx_pending = adapter->rx_ring_count;\n\tring->tx_pending = adapter->tx_ring_count;\n}\n\nstatic int e1000_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_ring *temp_tx = NULL, *temp_rx = NULL;\n\tint err = 0, size = sizeof(struct e1000_ring);\n\tbool set_tx = false, set_rx = false;\n\tu16 new_rx_count, new_tx_count;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tnew_rx_count = clamp_t(u32, ring->rx_pending, E1000_MIN_RXD,\n\t\t\t       E1000_MAX_RXD);\n\tnew_rx_count = ALIGN(new_rx_count, REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\tnew_tx_count = clamp_t(u32, ring->tx_pending, E1000_MIN_TXD,\n\t\t\t       E1000_MAX_TXD);\n\tnew_tx_count = ALIGN(new_tx_count, REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tif ((new_tx_count == adapter->tx_ring_count) &&\n\t    (new_rx_count == adapter->rx_ring_count))\n\t\t \n\t\treturn 0;\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(adapter->netdev)) {\n\t\t \n\t\tadapter->tx_ring->count = new_tx_count;\n\t\tadapter->rx_ring->count = new_rx_count;\n\t\tadapter->tx_ring_count = new_tx_count;\n\t\tadapter->rx_ring_count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\tset_tx = (new_tx_count != adapter->tx_ring_count);\n\tset_rx = (new_rx_count != adapter->rx_ring_count);\n\n\t \n\tif (set_tx) {\n\t\ttemp_tx = vmalloc(size);\n\t\tif (!temp_tx) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_temp;\n\t\t}\n\t}\n\tif (set_rx) {\n\t\ttemp_rx = vmalloc(size);\n\t\tif (!temp_rx) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_temp;\n\t\t}\n\t}\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\te1000e_down(adapter, true);\n\n\t \n\tif (set_tx) {\n\t\tmemcpy(temp_tx, adapter->tx_ring, size);\n\t\ttemp_tx->count = new_tx_count;\n\t\terr = e1000e_setup_tx_resources(temp_tx);\n\t\tif (err)\n\t\t\tgoto err_setup;\n\t}\n\tif (set_rx) {\n\t\tmemcpy(temp_rx, adapter->rx_ring, size);\n\t\ttemp_rx->count = new_rx_count;\n\t\terr = e1000e_setup_rx_resources(temp_rx);\n\t\tif (err)\n\t\t\tgoto err_setup_rx;\n\t}\n\n\t \n\tif (set_tx) {\n\t\te1000e_free_tx_resources(adapter->tx_ring);\n\t\tmemcpy(adapter->tx_ring, temp_tx, size);\n\t\tadapter->tx_ring_count = new_tx_count;\n\t}\n\tif (set_rx) {\n\t\te1000e_free_rx_resources(adapter->rx_ring);\n\t\tmemcpy(adapter->rx_ring, temp_rx, size);\n\t\tadapter->rx_ring_count = new_rx_count;\n\t}\n\nerr_setup_rx:\n\tif (err && set_tx)\n\t\te1000e_free_tx_resources(temp_tx);\nerr_setup:\n\te1000e_up(adapter);\n\tpm_runtime_put_sync(netdev->dev.parent);\nfree_temp:\n\tvfree(temp_tx);\n\tvfree(temp_rx);\nclear_reset:\n\tclear_bit(__E1000_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic bool reg_pattern_test(struct e1000_adapter *adapter, u64 *data,\n\t\t\t     int reg, int offset, u32 mask, u32 write)\n{\n\tu32 pat, val;\n\tstatic const u32 test[] = {\n\t\t0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF\n\t};\n\tfor (pat = 0; pat < ARRAY_SIZE(test); pat++) {\n\t\tE1000_WRITE_REG_ARRAY(&adapter->hw, reg, offset,\n\t\t\t\t      (test[pat] & write));\n\t\tval = E1000_READ_REG_ARRAY(&adapter->hw, reg, offset);\n\t\tif (val != (test[pat] & write & mask)) {\n\t\t\te_err(\"pattern test failed (reg 0x%05X): got 0x%08X expected 0x%08X\\n\",\n\t\t\t      reg + (offset << 2), val,\n\t\t\t      (test[pat] & write & mask));\n\t\t\t*data = reg;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data,\n\t\t\t      int reg, u32 mask, u32 write)\n{\n\tu32 val;\n\n\t__ew32(&adapter->hw, reg, write & mask);\n\tval = __er32(&adapter->hw, reg);\n\tif ((write & mask) != (val & mask)) {\n\t\te_err(\"set/check test failed (reg 0x%05X): got 0x%08X expected 0x%08X\\n\",\n\t\t      reg, (val & mask), (write & mask));\n\t\t*data = reg;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#define REG_PATTERN_TEST_ARRAY(reg, offset, mask, write)                       \\\n\tdo {                                                                   \\\n\t\tif (reg_pattern_test(adapter, data, reg, offset, mask, write)) \\\n\t\t\treturn 1;                                              \\\n\t} while (0)\n#define REG_PATTERN_TEST(reg, mask, write)                                     \\\n\tREG_PATTERN_TEST_ARRAY(reg, 0, mask, write)\n\n#define REG_SET_AND_CHECK(reg, mask, write)                                    \\\n\tdo {                                                                   \\\n\t\tif (reg_set_and_check(adapter, data, reg, mask, write))        \\\n\t\t\treturn 1;                                              \\\n\t} while (0)\n\nstatic int e1000_reg_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\tu32 value;\n\tu32 before;\n\tu32 after;\n\tu32 i;\n\tu32 toggle;\n\tu32 mask;\n\tu32 wlock_mac = 0;\n\n\t \n\tswitch (mac->type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\tcase e1000_80003es2lan:\n\t\ttoggle = 0x7FFFF3FF;\n\t\tbreak;\n\tdefault:\n\t\ttoggle = 0x7FFFF033;\n\t\tbreak;\n\t}\n\n\tbefore = er32(STATUS);\n\tvalue = (er32(STATUS) & toggle);\n\tew32(STATUS, toggle);\n\tafter = er32(STATUS) & toggle;\n\tif (value != after) {\n\t\te_err(\"failed STATUS register test got: 0x%08X expected: 0x%08X\\n\",\n\t\t      after, value);\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\t \n\tew32(STATUS, before);\n\n\tif (!(adapter->flags & FLAG_IS_ICH)) {\n\t\tREG_PATTERN_TEST(E1000_FCAL, 0xFFFFFFFF, 0xFFFFFFFF);\n\t\tREG_PATTERN_TEST(E1000_FCAH, 0x0000FFFF, 0xFFFFFFFF);\n\t\tREG_PATTERN_TEST(E1000_FCT, 0x0000FFFF, 0xFFFFFFFF);\n\t\tREG_PATTERN_TEST(E1000_VET, 0x0000FFFF, 0xFFFFFFFF);\n\t}\n\n\tREG_PATTERN_TEST(E1000_RDTR, 0x0000FFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(E1000_RDBAH(0), 0xFFFFFFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(E1000_RDLEN(0), 0x000FFF80, 0x000FFFFF);\n\tREG_PATTERN_TEST(E1000_RDH(0), 0x0000FFFF, 0x0000FFFF);\n\tREG_PATTERN_TEST(E1000_RDT(0), 0x0000FFFF, 0x0000FFFF);\n\tREG_PATTERN_TEST(E1000_FCRTH, 0x0000FFF8, 0x0000FFF8);\n\tREG_PATTERN_TEST(E1000_FCTTV, 0x0000FFFF, 0x0000FFFF);\n\tREG_PATTERN_TEST(E1000_TIPG, 0x3FFFFFFF, 0x3FFFFFFF);\n\tREG_PATTERN_TEST(E1000_TDBAH(0), 0xFFFFFFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(E1000_TDLEN(0), 0x000FFF80, 0x000FFFFF);\n\n\tREG_SET_AND_CHECK(E1000_RCTL, 0xFFFFFFFF, 0x00000000);\n\n\tbefore = ((adapter->flags & FLAG_IS_ICH) ? 0x06C3B33E : 0x06DFB3FE);\n\tREG_SET_AND_CHECK(E1000_RCTL, before, 0x003FFFFB);\n\tREG_SET_AND_CHECK(E1000_TCTL, 0xFFFFFFFF, 0x00000000);\n\n\tREG_SET_AND_CHECK(E1000_RCTL, before, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(E1000_RDBAL(0), 0xFFFFFFF0, 0xFFFFFFFF);\n\tif (!(adapter->flags & FLAG_IS_ICH))\n\t\tREG_PATTERN_TEST(E1000_TXCW, 0xC000FFFF, 0x0000FFFF);\n\tREG_PATTERN_TEST(E1000_TDBAL(0), 0xFFFFFFF0, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(E1000_TIDV, 0x0000FFFF, 0x0000FFFF);\n\tmask = 0x8003FFFF;\n\tswitch (mac->type) {\n\tcase e1000_ich10lan:\n\tcase e1000_pchlan:\n\tcase e1000_pch2lan:\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tmask |= BIT(18);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (mac->type >= e1000_pch_lpt)\n\t\twlock_mac = (er32(FWSM) & E1000_FWSM_WLOCK_MAC_MASK) >>\n\t\t    E1000_FWSM_WLOCK_MAC_SHIFT;\n\n\tfor (i = 0; i < mac->rar_entry_count; i++) {\n\t\tif (mac->type >= e1000_pch_lpt) {\n\t\t\t \n\t\t\tif ((wlock_mac == 1) || (wlock_mac && (i > wlock_mac)))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (i == 10)\n\t\t\t\tmask |= BIT(30);\n\t\t\telse\n\t\t\t\tmask &= ~BIT(30);\n\t\t}\n\t\tif (mac->type == e1000_pch2lan) {\n\t\t\t \n\t\t\tif (i == 1)\n\t\t\t\tmask &= 0xFFF4FFFF;\n\t\t\t \n\t\t\tif (i == 4)\n\t\t\t\tmask |= BIT(30);\n\t\t\t \n\t\t\tif (i > 0)\n\t\t\t\ti += 6;\n\t\t}\n\n\t\tREG_PATTERN_TEST_ARRAY(E1000_RA, ((i << 1) + 1), mask,\n\t\t\t\t       0xFFFFFFFF);\n\t\t \n\t\tif ((mac->type == e1000_pch2lan) && (i > 6))\n\t\t\ti -= 6;\n\t}\n\n\tfor (i = 0; i < mac->mta_reg_count; i++)\n\t\tREG_PATTERN_TEST_ARRAY(E1000_MTA, i, 0xFFFFFFFF, 0xFFFFFFFF);\n\n\t*data = 0;\n\n\treturn 0;\n}\n\nstatic int e1000_eeprom_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tu16 temp;\n\tu16 checksum = 0;\n\tu16 i;\n\n\t*data = 0;\n\t \n\tfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {\n\t\tif ((e1000_read_nvm(&adapter->hw, i, 1, &temp)) < 0) {\n\t\t\t*data = 1;\n\t\t\treturn *data;\n\t\t}\n\t\tchecksum += temp;\n\t}\n\n\t \n\tif ((checksum != (u16)NVM_SUM) && !(*data))\n\t\t*data = 2;\n\n\treturn *data;\n}\n\nstatic irqreturn_t e1000_test_intr(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = (struct net_device *)data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tadapter->test_icr |= er32(ICR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 mask;\n\tu32 shared_int = 1;\n\tu32 irq = adapter->pdev->irq;\n\tint i;\n\tint ret_val = 0;\n\tint int_mode = E1000E_INT_MODE_LEGACY;\n\n\t*data = 0;\n\n\t \n\tif (adapter->int_mode == E1000E_INT_MODE_MSIX) {\n\t\tint_mode = adapter->int_mode;\n\t\te1000e_reset_interrupt_capability(adapter);\n\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t\te1000e_set_interrupt_capability(adapter);\n\t}\n\t \n\tif (!request_irq(irq, e1000_test_intr, IRQF_PROBE_SHARED, netdev->name,\n\t\t\t netdev)) {\n\t\tshared_int = 0;\n\t} else if (request_irq(irq, e1000_test_intr, IRQF_SHARED, netdev->name,\n\t\t\t       netdev)) {\n\t\t*data = 1;\n\t\tret_val = -1;\n\t\tgoto out;\n\t}\n\te_info(\"testing %s interrupt\\n\", (shared_int ? \"shared\" : \"unshared\"));\n\n\t \n\tew32(IMC, 0xFFFFFFFF);\n\te1e_flush();\n\tusleep_range(10000, 11000);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\t \n\t\tmask = BIT(i);\n\n\t\tif (adapter->flags & FLAG_IS_ICH) {\n\t\t\tswitch (mask) {\n\t\t\tcase E1000_ICR_RXSEQ:\n\t\t\t\tcontinue;\n\t\t\tcase 0x00000100:\n\t\t\t\tif (adapter->hw.mac.type == e1000_ich8lan ||\n\t\t\t\t    adapter->hw.mac.type == e1000_ich9lan)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\t\t\tew32(IMC, mask);\n\t\t\tew32(ICS, mask);\n\t\t\te1e_flush();\n\t\t\tusleep_range(10000, 11000);\n\n\t\t\tif (adapter->test_icr & mask) {\n\t\t\t\t*data = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tadapter->test_icr = 0;\n\t\tew32(IMS, mask);\n\t\tew32(ICS, mask);\n\t\te1e_flush();\n\t\tusleep_range(10000, 11000);\n\n\t\tif (!(adapter->test_icr & mask)) {\n\t\t\t*data = 4;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\t\t\tew32(IMC, ~mask & 0x00007FFF);\n\t\t\tew32(ICS, ~mask & 0x00007FFF);\n\t\t\te1e_flush();\n\t\t\tusleep_range(10000, 11000);\n\n\t\t\tif (adapter->test_icr) {\n\t\t\t\t*data = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tew32(IMC, 0xFFFFFFFF);\n\te1e_flush();\n\tusleep_range(10000, 11000);\n\n\t \n\tfree_irq(irq, netdev);\n\nout:\n\tif (int_mode == E1000E_INT_MODE_MSIX) {\n\t\te1000e_reset_interrupt_capability(adapter);\n\t\tadapter->int_mode = int_mode;\n\t\te1000e_set_interrupt_capability(adapter);\n\t}\n\n\treturn ret_val;\n}\n\nstatic void e1000_free_desc_rings(struct e1000_adapter *adapter)\n{\n\tstruct e1000_ring *tx_ring = &adapter->test_tx_ring;\n\tstruct e1000_ring *rx_ring = &adapter->test_rx_ring;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_buffer *buffer_info;\n\tint i;\n\n\tif (tx_ring->desc && tx_ring->buffer_info) {\n\t\tfor (i = 0; i < tx_ring->count; i++) {\n\t\t\tbuffer_info = &tx_ring->buffer_info[i];\n\n\t\t\tif (buffer_info->dma)\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t\t buffer_info->dma,\n\t\t\t\t\t\t buffer_info->length,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(buffer_info->skb);\n\t\t}\n\t}\n\n\tif (rx_ring->desc && rx_ring->buffer_info) {\n\t\tfor (i = 0; i < rx_ring->count; i++) {\n\t\t\tbuffer_info = &rx_ring->buffer_info[i];\n\n\t\t\tif (buffer_info->dma)\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t\t buffer_info->dma,\n\t\t\t\t\t\t 2048, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(buffer_info->skb);\n\t\t}\n\t}\n\n\tif (tx_ring->desc) {\n\t\tdma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,\n\t\t\t\t  tx_ring->dma);\n\t\ttx_ring->desc = NULL;\n\t}\n\tif (rx_ring->desc) {\n\t\tdma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,\n\t\t\t\t  rx_ring->dma);\n\t\trx_ring->desc = NULL;\n\t}\n\n\tkfree(tx_ring->buffer_info);\n\ttx_ring->buffer_info = NULL;\n\tkfree(rx_ring->buffer_info);\n\trx_ring->buffer_info = NULL;\n}\n\nstatic int e1000_setup_desc_rings(struct e1000_adapter *adapter)\n{\n\tstruct e1000_ring *tx_ring = &adapter->test_tx_ring;\n\tstruct e1000_ring *rx_ring = &adapter->test_rx_ring;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\tint i;\n\tint ret_val;\n\n\t \n\n\tif (!tx_ring->count)\n\t\ttx_ring->count = E1000_DEFAULT_TXD;\n\n\ttx_ring->buffer_info = kcalloc(tx_ring->count,\n\t\t\t\t       sizeof(struct e1000_buffer), GFP_KERNEL);\n\tif (!tx_ring->buffer_info) {\n\t\tret_val = 1;\n\t\tgoto err_nomem;\n\t}\n\n\ttx_ring->size = tx_ring->count * sizeof(struct e1000_tx_desc);\n\ttx_ring->size = ALIGN(tx_ring->size, 4096);\n\ttx_ring->desc = dma_alloc_coherent(&pdev->dev, tx_ring->size,\n\t\t\t\t\t   &tx_ring->dma, GFP_KERNEL);\n\tif (!tx_ring->desc) {\n\t\tret_val = 2;\n\t\tgoto err_nomem;\n\t}\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\n\tew32(TDBAL(0), ((u64)tx_ring->dma & 0x00000000FFFFFFFF));\n\tew32(TDBAH(0), ((u64)tx_ring->dma >> 32));\n\tew32(TDLEN(0), tx_ring->count * sizeof(struct e1000_tx_desc));\n\tew32(TDH(0), 0);\n\tew32(TDT(0), 0);\n\tew32(TCTL, E1000_TCTL_PSP | E1000_TCTL_EN | E1000_TCTL_MULR |\n\t     E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT |\n\t     E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT);\n\n\tfor (i = 0; i < tx_ring->count; i++) {\n\t\tstruct e1000_tx_desc *tx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\tstruct sk_buff *skb;\n\t\tunsigned int skb_size = 1024;\n\n\t\tskb = alloc_skb(skb_size, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret_val = 3;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\tskb_put(skb, skb_size);\n\t\ttx_ring->buffer_info[i].skb = skb;\n\t\ttx_ring->buffer_info[i].length = skb->len;\n\t\ttx_ring->buffer_info[i].dma =\n\t\t    dma_map_single(&pdev->dev, skb->data, skb->len,\n\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev,\n\t\t\t\t      tx_ring->buffer_info[i].dma)) {\n\t\t\tret_val = 4;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\ttx_desc->buffer_addr = cpu_to_le64(tx_ring->buffer_info[i].dma);\n\t\ttx_desc->lower.data = cpu_to_le32(skb->len);\n\t\ttx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP |\n\t\t\t\t\t\t   E1000_TXD_CMD_IFCS |\n\t\t\t\t\t\t   E1000_TXD_CMD_RS);\n\t\ttx_desc->upper.data = 0;\n\t}\n\n\t \n\n\tif (!rx_ring->count)\n\t\trx_ring->count = E1000_DEFAULT_RXD;\n\n\trx_ring->buffer_info = kcalloc(rx_ring->count,\n\t\t\t\t       sizeof(struct e1000_buffer), GFP_KERNEL);\n\tif (!rx_ring->buffer_info) {\n\t\tret_val = 5;\n\t\tgoto err_nomem;\n\t}\n\n\trx_ring->size = rx_ring->count * sizeof(union e1000_rx_desc_extended);\n\trx_ring->desc = dma_alloc_coherent(&pdev->dev, rx_ring->size,\n\t\t\t\t\t   &rx_ring->dma, GFP_KERNEL);\n\tif (!rx_ring->desc) {\n\t\tret_val = 6;\n\t\tgoto err_nomem;\n\t}\n\trx_ring->next_to_use = 0;\n\trx_ring->next_to_clean = 0;\n\n\trctl = er32(RCTL);\n\tif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\tew32(RDBAL(0), ((u64)rx_ring->dma & 0xFFFFFFFF));\n\tew32(RDBAH(0), ((u64)rx_ring->dma >> 32));\n\tew32(RDLEN(0), rx_ring->size);\n\tew32(RDH(0), 0);\n\tew32(RDT(0), 0);\n\trctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |\n\t    E1000_RCTL_UPE | E1000_RCTL_MPE | E1000_RCTL_LPE |\n\t    E1000_RCTL_SBP | E1000_RCTL_SECRC |\n\t    E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |\n\t    (adapter->hw.mac.mc_filter_type << E1000_RCTL_MO_SHIFT);\n\tew32(RCTL, rctl);\n\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tunion e1000_rx_desc_extended *rx_desc;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = alloc_skb(2048 + NET_IP_ALIGN, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret_val = 7;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\trx_ring->buffer_info[i].skb = skb;\n\t\trx_ring->buffer_info[i].dma =\n\t\t    dma_map_single(&pdev->dev, skb->data, 2048,\n\t\t\t\t   DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev,\n\t\t\t\t      rx_ring->buffer_info[i].dma)) {\n\t\t\tret_val = 8;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\trx_desc->read.buffer_addr =\n\t\t    cpu_to_le64(rx_ring->buffer_info[i].dma);\n\t\tmemset(skb->data, 0x00, skb->len);\n\t}\n\n\treturn 0;\n\nerr_nomem:\n\te1000_free_desc_rings(adapter);\n\treturn ret_val;\n}\n\nstatic void e1000_phy_disable_receiver(struct e1000_adapter *adapter)\n{\n\t \n\te1e_wphy(&adapter->hw, 29, 0x001F);\n\te1e_wphy(&adapter->hw, 30, 0x8FFC);\n\te1e_wphy(&adapter->hw, 29, 0x001A);\n\te1e_wphy(&adapter->hw, 30, 0x8FF0);\n}\n\nstatic int e1000_integrated_phy_loopback(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_reg = 0;\n\tu16 phy_reg = 0;\n\ts32 ret_val = 0;\n\n\thw->mac.autoneg = 0;\n\n\tif (hw->phy.type == e1000_phy_ife) {\n\t\t \n\t\te1e_wphy(hw, MII_BMCR, 0x6100);\n\n\t\t \n\t\tctrl_reg = er32(CTRL);\n\t\tctrl_reg &= ~E1000_CTRL_SPD_SEL;  \n\t\tctrl_reg |= (E1000_CTRL_FRCSPD |  \n\t\t\t     E1000_CTRL_FRCDPX |  \n\t\t\t     E1000_CTRL_SPD_100 | \n\t\t\t     E1000_CTRL_FD);\t  \n\n\t\tew32(CTRL, ctrl_reg);\n\t\te1e_flush();\n\t\tusleep_range(500, 1000);\n\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (hw->phy.type) {\n\tcase e1000_phy_m88:\n\t\t \n\t\te1e_wphy(hw, M88E1000_PHY_SPEC_CTRL, 0x0808);\n\t\t \n\t\te1e_wphy(hw, MII_BMCR, 0x9140);\n\t\t \n\t\te1e_wphy(hw, MII_BMCR, 0x8140);\n\t\tbreak;\n\tcase e1000_phy_gg82563:\n\t\te1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, 0x1CC);\n\t\tbreak;\n\tcase e1000_phy_bm:\n\t\t \n\t\te1e_rphy(hw, PHY_REG(2, 21), &phy_reg);\n\t\tphy_reg &= ~0x0007;\n\t\tphy_reg |= 0x006;\n\t\te1e_wphy(hw, PHY_REG(2, 21), phy_reg);\n\t\t \n\t\thw->phy.ops.commit(hw);\n\t\tusleep_range(1000, 2000);\n\t\t \n\t\te1e_rphy(hw, PHY_REG(769, 16), &phy_reg);\n\t\te1e_wphy(hw, PHY_REG(769, 16), phy_reg | 0x000C);\n\t\t \n\t\te1e_rphy(hw, PHY_REG(776, 16), &phy_reg);\n\t\te1e_wphy(hw, PHY_REG(776, 16), phy_reg | 0x0040);\n\t\t \n\t\te1e_rphy(hw, PHY_REG(769, 16), &phy_reg);\n\t\te1e_wphy(hw, PHY_REG(769, 16), phy_reg | 0x0040);\n\t\t \n\t\te1e_rphy(hw, PHY_REG(769, 20), &phy_reg);\n\t\te1e_wphy(hw, PHY_REG(769, 20), phy_reg | 0x0400);\n\t\tbreak;\n\tcase e1000_phy_82577:\n\tcase e1000_phy_82578:\n\t\t \n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val) {\n\t\t\te_err(\"Cannot setup 1Gbps loopback.\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\te1000_configure_k1_ich8lan(hw, false);\n\t\thw->phy.ops.release(hw);\n\t\tbreak;\n\tcase e1000_phy_82579:\n\t\t \n\t\te1e_rphy(hw, PHY_REG(0, 21), &phy_reg);\n\t\te1e_wphy(hw, PHY_REG(0, 21), phy_reg & ~BIT(3));\n\t\t \n\t\te1e_rphy(hw, PHY_REG(776, 18), &phy_reg);\n\t\te1e_wphy(hw, PHY_REG(776, 18), phy_reg | 1);\n\t\t \n\t\te1e_wphy(hw, I82577_PHY_LBK_CTRL, 0x8001);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\te1e_wphy(hw, MII_BMCR, 0x4140);\n\tmsleep(250);\n\n\t \n\tctrl_reg = er32(CTRL);\n\tctrl_reg &= ~E1000_CTRL_SPD_SEL;  \n\tctrl_reg |= (E1000_CTRL_FRCSPD |  \n\t\t     E1000_CTRL_FRCDPX |  \n\t\t     E1000_CTRL_SPD_1000 | \n\t\t     E1000_CTRL_FD);\t  \n\n\tif (adapter->flags & FLAG_IS_ICH)\n\t\tctrl_reg |= E1000_CTRL_SLU;\t \n\n\tif (hw->phy.media_type == e1000_media_type_copper &&\n\t    hw->phy.type == e1000_phy_m88) {\n\t\tctrl_reg |= E1000_CTRL_ILOS;\t \n\t} else {\n\t\t \n\t\tif ((er32(STATUS) & E1000_STATUS_FD) == 0)\n\t\t\tctrl_reg |= (E1000_CTRL_ILOS | E1000_CTRL_SLU);\n\t}\n\n\tew32(CTRL, ctrl_reg);\n\n\t \n\tif (hw->phy.type == e1000_phy_m88)\n\t\te1000_phy_disable_receiver(adapter);\n\n\tusleep_range(500, 1000);\n\n\treturn 0;\n}\n\nstatic int e1000_set_82571_fiber_loopback(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl = er32(CTRL);\n\tint link;\n\n\t \n\n\t \n\tctrl |= E1000_CTRL_SLU;\n\tew32(CTRL, ctrl);\n\n\t \n\tctrl = er32(TXCW);\n\tctrl &= ~BIT(31);\n\tew32(TXCW, ctrl);\n\n\tlink = (er32(STATUS) & E1000_STATUS_LU);\n\n\tif (!link) {\n\t\t \n\t\tctrl = er32(CTRL);\n\t\tctrl |= E1000_CTRL_ILOS;\n\t\tew32(CTRL, ctrl);\n\t}\n\n\t \n\tew32(SCTL, E1000_SCTL_ENABLE_SERDES_LOOPBACK);\n\te1e_flush();\n\tusleep_range(10000, 11000);\n\n\treturn 0;\n}\n\n \nstatic int e1000_set_es2lan_mac_loopback(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrlext = er32(CTRL_EXT);\n\tu32 ctrl = er32(CTRL);\n\n\t \n\tadapter->tx_fifo_head = ctrlext;\n\n\t \n\tctrlext &= ~E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;\n\tew32(CTRL_EXT, ctrlext);\n\n\t \n\tctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\n\tctrl |= (E1000_CTRL_SLU | E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX |\n\t\t E1000_CTRL_SPD_1000 | E1000_CTRL_FD);\n\tew32(CTRL, ctrl);\n\n\t \n\tctrl = er32(RCTL);\n\tctrl |= E1000_RCTL_LBM_MAC;\n\tew32(RCTL, ctrl);\n\n\t \n#define KMRNCTRLSTA_OPMODE (0x1F << 16)\n#define KMRNCTRLSTA_OPMODE_1GB_FD_GMII 0x0582\n\tew32(KMRNCTRLSTA,\n\t     (KMRNCTRLSTA_OPMODE | KMRNCTRLSTA_OPMODE_1GB_FD_GMII));\n\n\treturn 0;\n}\n\nstatic int e1000_setup_loopback_test(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl, fext_nvm11, tarc0;\n\n\tif (hw->mac.type >= e1000_pch_spt) {\n\t\tfext_nvm11 = er32(FEXTNVM11);\n\t\tfext_nvm11 |= E1000_FEXTNVM11_DISABLE_MULR_FIX;\n\t\tew32(FEXTNVM11, fext_nvm11);\n\t\ttarc0 = er32(TARC(0));\n\t\t \n\t\ttarc0 &= 0xcfffffff;\n\t\t \n\t\ttarc0 |= 0x20000000;\n\t\tew32(TARC(0), tarc0);\n\t}\n\tif (hw->phy.media_type == e1000_media_type_fiber ||\n\t    hw->phy.media_type == e1000_media_type_internal_serdes) {\n\t\tswitch (hw->mac.type) {\n\t\tcase e1000_80003es2lan:\n\t\t\treturn e1000_set_es2lan_mac_loopback(adapter);\n\t\tcase e1000_82571:\n\t\tcase e1000_82572:\n\t\t\treturn e1000_set_82571_fiber_loopback(adapter);\n\t\tdefault:\n\t\t\trctl = er32(RCTL);\n\t\t\trctl |= E1000_RCTL_LBM_TCVR;\n\t\t\tew32(RCTL, rctl);\n\t\t\treturn 0;\n\t\t}\n\t} else if (hw->phy.media_type == e1000_media_type_copper) {\n\t\treturn e1000_integrated_phy_loopback(adapter);\n\t}\n\n\treturn 7;\n}\n\nstatic void e1000_loopback_cleanup(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl, fext_nvm11, tarc0;\n\tu16 phy_reg;\n\n\trctl = er32(RCTL);\n\trctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);\n\tew32(RCTL, rctl);\n\n\tswitch (hw->mac.type) {\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tfext_nvm11 = er32(FEXTNVM11);\n\t\tfext_nvm11 &= ~E1000_FEXTNVM11_DISABLE_MULR_FIX;\n\t\tew32(FEXTNVM11, fext_nvm11);\n\t\ttarc0 = er32(TARC(0));\n\t\t \n\t\t \n\t\ttarc0 &= 0xcfffffff;\n\t\tew32(TARC(0), tarc0);\n\t\tfallthrough;\n\tcase e1000_80003es2lan:\n\t\tif (hw->phy.media_type == e1000_media_type_fiber ||\n\t\t    hw->phy.media_type == e1000_media_type_internal_serdes) {\n\t\t\t \n\t\t\tew32(CTRL_EXT, adapter->tx_fifo_head);\n\t\t\tadapter->tx_fifo_head = 0;\n\t\t}\n\t\tfallthrough;\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\tif (hw->phy.media_type == e1000_media_type_fiber ||\n\t\t    hw->phy.media_type == e1000_media_type_internal_serdes) {\n\t\t\tew32(SCTL, E1000_SCTL_DISABLE_SERDES_LOOPBACK);\n\t\t\te1e_flush();\n\t\t\tusleep_range(10000, 11000);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\thw->mac.autoneg = 1;\n\t\tif (hw->phy.type == e1000_phy_gg82563)\n\t\t\te1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, 0x180);\n\t\te1e_rphy(hw, MII_BMCR, &phy_reg);\n\t\tif (phy_reg & BMCR_LOOPBACK) {\n\t\t\tphy_reg &= ~BMCR_LOOPBACK;\n\t\t\te1e_wphy(hw, MII_BMCR, phy_reg);\n\t\t\tif (hw->phy.ops.commit)\n\t\t\t\thw->phy.ops.commit(hw);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void e1000_create_lbtest_frame(struct sk_buff *skb,\n\t\t\t\t      unsigned int frame_size)\n{\n\tmemset(skb->data, 0xFF, frame_size);\n\tframe_size &= ~1;\n\tmemset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);\n\tskb->data[frame_size / 2 + 10] = 0xBE;\n\tskb->data[frame_size / 2 + 12] = 0xAF;\n}\n\nstatic int e1000_check_lbtest_frame(struct sk_buff *skb,\n\t\t\t\t    unsigned int frame_size)\n{\n\tframe_size &= ~1;\n\tif (*(skb->data + 3) == 0xFF)\n\t\tif ((*(skb->data + frame_size / 2 + 10) == 0xBE) &&\n\t\t    (*(skb->data + frame_size / 2 + 12) == 0xAF))\n\t\t\treturn 0;\n\treturn 13;\n}\n\nstatic int e1000_run_loopback_test(struct e1000_adapter *adapter)\n{\n\tstruct e1000_ring *tx_ring = &adapter->test_tx_ring;\n\tstruct e1000_ring *rx_ring = &adapter->test_rx_ring;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_buffer *buffer_info;\n\tint i, j, k, l;\n\tint lc;\n\tint good_cnt;\n\tint ret_val = 0;\n\tunsigned long time;\n\n\tew32(RDT(0), rx_ring->count - 1);\n\n\t \n\n\tif (rx_ring->count <= tx_ring->count)\n\t\tlc = ((tx_ring->count / 64) * 2) + 1;\n\telse\n\t\tlc = ((rx_ring->count / 64) * 2) + 1;\n\n\tk = 0;\n\tl = 0;\n\t \n\tfor (j = 0; j <= lc; j++) {\n\t\t \n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tbuffer_info = &tx_ring->buffer_info[k];\n\n\t\t\te1000_create_lbtest_frame(buffer_info->skb, 1024);\n\t\t\tdma_sync_single_for_device(&pdev->dev,\n\t\t\t\t\t\t   buffer_info->dma,\n\t\t\t\t\t\t   buffer_info->length,\n\t\t\t\t\t\t   DMA_TO_DEVICE);\n\t\t\tk++;\n\t\t\tif (k == tx_ring->count)\n\t\t\t\tk = 0;\n\t\t}\n\t\tew32(TDT(0), k);\n\t\te1e_flush();\n\t\tmsleep(200);\n\t\ttime = jiffies;\t \n\t\tgood_cnt = 0;\n\t\t \n\t\tdo {\n\t\t\tbuffer_info = &rx_ring->buffer_info[l];\n\n\t\t\tdma_sync_single_for_cpu(&pdev->dev,\n\t\t\t\t\t\tbuffer_info->dma, 2048,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\tret_val = e1000_check_lbtest_frame(buffer_info->skb,\n\t\t\t\t\t\t\t   1024);\n\t\t\tif (!ret_val)\n\t\t\t\tgood_cnt++;\n\t\t\tl++;\n\t\t\tif (l == rx_ring->count)\n\t\t\t\tl = 0;\n\t\t\t \n\t\t} while ((good_cnt < 64) && !time_after(jiffies, time + 20));\n\t\tif (good_cnt != 64) {\n\t\t\tret_val = 13;\t \n\t\t\tbreak;\n\t\t}\n\t\tif (time_after(jiffies, time + 20)) {\n\t\t\tret_val = 14;\t \n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret_val;\n}\n\nstatic int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\tif (hw->phy.ops.check_reset_block &&\n\t    hw->phy.ops.check_reset_block(hw)) {\n\t\te_err(\"Cannot do PHY loopback test when SoL/IDER is active.\\n\");\n\t\t*data = 0;\n\t\tgoto out;\n\t}\n\n\t*data = e1000_setup_desc_rings(adapter);\n\tif (*data)\n\t\tgoto out;\n\n\t*data = e1000_setup_loopback_test(adapter);\n\tif (*data)\n\t\tgoto err_loopback;\n\n\t*data = e1000_run_loopback_test(adapter);\n\te1000_loopback_cleanup(adapter);\n\nerr_loopback:\n\te1000_free_desc_rings(adapter);\nout:\n\treturn *data;\n}\n\nstatic int e1000_link_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t*data = 0;\n\tif (hw->phy.media_type == e1000_media_type_internal_serdes) {\n\t\tint i = 0;\n\n\t\thw->mac.serdes_has_link = false;\n\n\t\t \n\t\tdo {\n\t\t\thw->mac.ops.check_for_link(hw);\n\t\t\tif (hw->mac.serdes_has_link)\n\t\t\t\treturn *data;\n\t\t\tmsleep(20);\n\t\t} while (i++ < 3750);\n\n\t\t*data = 1;\n\t} else {\n\t\thw->mac.ops.check_for_link(hw);\n\t\tif (hw->mac.autoneg)\n\t\t\t \n\t\t\tmsleep_interruptible(5000);\n\n\t\tif (!(er32(STATUS) & E1000_STATUS_LU))\n\t\t\t*data = 1;\n\t}\n\treturn *data;\n}\n\nstatic int e1000e_get_sset_count(struct net_device __always_unused *netdev,\n\t\t\t\t int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn E1000_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn E1000_STATS_LEN;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn E1000E_PRIV_FLAGS_STR_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void e1000_diag_test(struct net_device *netdev,\n\t\t\t    struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tu16 autoneg_advertised;\n\tu8 forced_speed_duplex;\n\tu8 autoneg;\n\tbool if_running = netif_running(netdev);\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tset_bit(__E1000_TESTING, &adapter->state);\n\n\tif (!if_running) {\n\t\t \n\t\tif (adapter->flags & FLAG_HAS_AMT)\n\t\t\te1000e_get_hw_control(adapter);\n\n\t\te1000e_power_up_phy(adapter);\n\n\t\tadapter->hw.phy.autoneg_wait_to_complete = 1;\n\t\te1000e_reset(adapter);\n\t\tadapter->hw.phy.autoneg_wait_to_complete = 0;\n\t}\n\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\t \n\n\t\t \n\t\tautoneg_advertised = adapter->hw.phy.autoneg_advertised;\n\t\tforced_speed_duplex = adapter->hw.mac.forced_speed_duplex;\n\t\tautoneg = adapter->hw.mac.autoneg;\n\n\t\te_info(\"offline testing starting\\n\");\n\n\t\tif (if_running)\n\t\t\t \n\t\t\te1000e_close(netdev);\n\n\t\tif (e1000_reg_test(adapter, &data[0]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\te1000e_reset(adapter);\n\t\tif (e1000_eeprom_test(adapter, &data[1]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\te1000e_reset(adapter);\n\t\tif (e1000_intr_test(adapter, &data[2]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\te1000e_reset(adapter);\n\t\tif (e1000_loopback_test(adapter, &data[3]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tadapter->hw.phy.autoneg_wait_to_complete = 1;\n\t\te1000e_reset(adapter);\n\t\tadapter->hw.phy.autoneg_wait_to_complete = 0;\n\n\t\tif (e1000_link_test(adapter, &data[4]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tadapter->hw.phy.autoneg_advertised = autoneg_advertised;\n\t\tadapter->hw.mac.forced_speed_duplex = forced_speed_duplex;\n\t\tadapter->hw.mac.autoneg = autoneg;\n\t\te1000e_reset(adapter);\n\n\t\tclear_bit(__E1000_TESTING, &adapter->state);\n\t\tif (if_running)\n\t\t\te1000e_open(netdev);\n\t} else {\n\t\t \n\n\t\te_info(\"online testing starting\\n\");\n\n\t\t \n\t\tdata[0] = 0;\n\t\tdata[1] = 0;\n\t\tdata[2] = 0;\n\t\tdata[3] = 0;\n\n\t\tif (e1000_link_test(adapter, &data[4]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tclear_bit(__E1000_TESTING, &adapter->state);\n\t}\n\n\tif (!if_running) {\n\t\te1000e_reset(adapter);\n\n\t\tif (adapter->flags & FLAG_HAS_AMT)\n\t\t\te1000e_release_hw_control(adapter);\n\t}\n\n\tmsleep_interruptible(4 * 1000);\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n}\n\nstatic void e1000_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\twol->supported = 0;\n\twol->wolopts = 0;\n\n\tif (!(adapter->flags & FLAG_HAS_WOL) ||\n\t    !device_can_wakeup(&adapter->pdev->dev))\n\t\treturn;\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST |\n\t    WAKE_BCAST | WAKE_MAGIC | WAKE_PHY;\n\n\t \n\tif (adapter->flags & FLAG_NO_WAKE_UCAST) {\n\t\twol->supported &= ~WAKE_UCAST;\n\n\t\tif (adapter->wol & E1000_WUFC_EX)\n\t\t\te_err(\"Interface does not support directed (unicast) frame wake-up packets\\n\");\n\t}\n\n\tif (adapter->wol & E1000_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & E1000_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & E1000_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & E1000_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tif (adapter->wol & E1000_WUFC_LNKC)\n\t\twol->wolopts |= WAKE_PHY;\n}\n\nstatic int e1000_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (!(adapter->flags & FLAG_HAS_WOL) ||\n\t    !device_can_wakeup(&adapter->pdev->dev) ||\n\t    (wol->wolopts & ~(WAKE_UCAST | WAKE_MCAST | WAKE_BCAST |\n\t\t\t      WAKE_MAGIC | WAKE_PHY)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_UCAST)\n\t\tadapter->wol |= E1000_WUFC_EX;\n\tif (wol->wolopts & WAKE_MCAST)\n\t\tadapter->wol |= E1000_WUFC_MC;\n\tif (wol->wolopts & WAKE_BCAST)\n\t\tadapter->wol |= E1000_WUFC_BC;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= E1000_WUFC_MAG;\n\tif (wol->wolopts & WAKE_PHY)\n\t\tadapter->wol |= E1000_WUFC_LNKC;\n\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\nstatic int e1000_set_phys_id(struct net_device *netdev,\n\t\t\t     enum ethtool_phys_id_state state)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tpm_runtime_get_sync(netdev->dev.parent);\n\n\t\tif (!hw->mac.ops.blink_led)\n\t\t\treturn 2;\t \n\n\t\thw->mac.ops.blink_led(hw);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tif (hw->phy.type == e1000_phy_ife)\n\t\t\te1e_wphy(hw, IFE_PHY_SPECIAL_CONTROL_LED, 0);\n\t\thw->mac.ops.led_off(hw);\n\t\thw->mac.ops.cleanup_led(hw);\n\t\tpm_runtime_put_sync(netdev->dev.parent);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_ON:\n\t\thw->mac.ops.led_on(hw);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\thw->mac.ops.led_off(hw);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int e1000_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->itr_setting <= 4)\n\t\tec->rx_coalesce_usecs = adapter->itr_setting;\n\telse\n\t\tec->rx_coalesce_usecs = 1000000 / adapter->itr_setting;\n\n\treturn 0;\n}\n\nstatic int e1000_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif ((ec->rx_coalesce_usecs > E1000_MAX_ITR_USECS) ||\n\t    ((ec->rx_coalesce_usecs > 4) &&\n\t     (ec->rx_coalesce_usecs < E1000_MIN_ITR_USECS)) ||\n\t    (ec->rx_coalesce_usecs == 2))\n\t\treturn -EINVAL;\n\n\tif (ec->rx_coalesce_usecs == 4) {\n\t\tadapter->itr_setting = 4;\n\t\tadapter->itr = adapter->itr_setting;\n\t} else if (ec->rx_coalesce_usecs <= 3) {\n\t\tadapter->itr = 20000;\n\t\tadapter->itr_setting = ec->rx_coalesce_usecs;\n\t} else {\n\t\tadapter->itr = (1000000 / ec->rx_coalesce_usecs);\n\t\tadapter->itr_setting = adapter->itr & ~3;\n\t}\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tif (adapter->itr_setting != 0)\n\t\te1000e_write_itr(adapter, adapter->itr);\n\telse\n\t\te1000e_write_itr(adapter, 0);\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\treturn 0;\n}\n\nstatic int e1000_nway_reset(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (!netif_running(netdev))\n\t\treturn -EAGAIN;\n\n\tif (!adapter->hw.mac.autoneg)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\te1000e_reinit_locked(adapter);\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\treturn 0;\n}\n\nstatic void e1000_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats __always_unused *stats,\n\t\t\t\t    u64 *data)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct rtnl_link_stats64 net_stats;\n\tint i;\n\tchar *p = NULL;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tdev_get_stats(netdev, &net_stats);\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\tfor (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {\n\t\tswitch (e1000_gstrings_stats[i].type) {\n\t\tcase NETDEV_STATS:\n\t\t\tp = (char *)&net_stats +\n\t\t\t    e1000_gstrings_stats[i].stat_offset;\n\t\t\tbreak;\n\t\tcase E1000_STATS:\n\t\t\tp = (char *)adapter +\n\t\t\t    e1000_gstrings_stats[i].stat_offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata[i] = (e1000_gstrings_stats[i].sizeof_stat ==\n\t\t\t   sizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n}\n\nstatic void e1000_get_strings(struct net_device __always_unused *netdev,\n\t\t\t      u32 stringset, u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {\n\t\t\tmemcpy(p, e1000_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(data, e1000e_priv_flags_strings,\n\t\t       E1000E_PRIV_FLAGS_STR_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic int e1000_get_rxnfc(struct net_device *netdev,\n\t\t\t   struct ethtool_rxnfc *info,\n\t\t\t   u32 __always_unused *rule_locs)\n{\n\tinfo->data = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXFH: {\n\t\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\t\tstruct e1000_hw *hw = &adapter->hw;\n\t\tu32 mrqc;\n\n\t\tpm_runtime_get_sync(netdev->dev.parent);\n\t\tmrqc = er32(MRQC);\n\t\tpm_runtime_put_sync(netdev->dev.parent);\n\n\t\tif (!(mrqc & E1000_MRQC_RSS_FIELD_MASK))\n\t\t\treturn 0;\n\n\t\tswitch (info->flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\t\tif (mrqc & E1000_MRQC_RSS_FIELD_IPV4_TCP)\n\t\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\tfallthrough;\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\tcase AH_ESP_V4_FLOW:\n\t\tcase IPV4_FLOW:\n\t\t\tif (mrqc & E1000_MRQC_RSS_FIELD_IPV4)\n\t\t\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tcase TCP_V6_FLOW:\n\t\t\tif (mrqc & E1000_MRQC_RSS_FIELD_IPV6_TCP)\n\t\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\tfallthrough;\n\t\tcase UDP_V6_FLOW:\n\t\tcase SCTP_V6_FLOW:\n\t\tcase AH_ESP_V6_FLOW:\n\t\tcase IPV6_FLOW:\n\t\t\tif (mrqc & E1000_MRQC_RSS_FIELD_IPV6)\n\t\t\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int e1000e_get_eee(struct net_device *netdev, struct ethtool_eee *edata)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 cap_addr, lpa_addr, pcs_stat_addr, phy_data;\n\tu32 ret_val;\n\n\tif (!(adapter->flags2 & FLAG2_HAS_EEE))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (hw->phy.type) {\n\tcase e1000_phy_82579:\n\t\tcap_addr = I82579_EEE_CAPABILITY;\n\t\tlpa_addr = I82579_EEE_LP_ABILITY;\n\t\tpcs_stat_addr = I82579_EEE_PCS_STATUS;\n\t\tbreak;\n\tcase e1000_phy_i217:\n\t\tcap_addr = I217_EEE_CAPABILITY;\n\t\tlpa_addr = I217_EEE_LP_ABILITY;\n\t\tpcs_stat_addr = I217_EEE_PCS_STATUS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val) {\n\t\tpm_runtime_put_sync(netdev->dev.parent);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret_val = e1000_read_emi_reg_locked(hw, cap_addr, &phy_data);\n\tif (ret_val)\n\t\tgoto release;\n\tedata->supported = mmd_eee_cap_to_ethtool_sup_t(phy_data);\n\n\t \n\tedata->advertised = mmd_eee_adv_to_ethtool_adv_t(adapter->eee_advert);\n\n\t \n\tret_val = e1000_read_emi_reg_locked(hw, lpa_addr, &phy_data);\n\tif (ret_val)\n\t\tgoto release;\n\tedata->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(phy_data);\n\n\t \n\tret_val = e1000_read_emi_reg_locked(hw, pcs_stat_addr, &phy_data);\n\tif (ret_val)\n\t\tgoto release;\n\tif (hw->phy.type == e1000_phy_82579)\n\t\tphy_data <<= 8;\n\n\t \n\tif (phy_data & (E1000_EEE_TX_LPI_RCVD | E1000_EEE_RX_LPI_RCVD))\n\t\tedata->eee_active = true;\n\n\tedata->eee_enabled = !hw->dev_spec.ich8lan.eee_disable;\n\tedata->tx_lpi_enabled = true;\n\tedata->tx_lpi_timer = er32(LPIC) >> E1000_LPIC_LPIET_SHIFT;\n\nrelease:\n\thw->phy.ops.release(hw);\n\tif (ret_val)\n\t\tret_val = -ENODATA;\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\treturn ret_val;\n}\n\nstatic int e1000e_set_eee(struct net_device *netdev, struct ethtool_eee *edata)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct ethtool_eee eee_curr;\n\ts32 ret_val;\n\n\tret_val = e1000e_get_eee(netdev, &eee_curr);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (eee_curr.tx_lpi_enabled != edata->tx_lpi_enabled) {\n\t\te_err(\"Setting EEE tx-lpi is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (eee_curr.tx_lpi_timer != edata->tx_lpi_timer) {\n\t\te_err(\"Setting EEE Tx LPI timer is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (edata->advertised & ~(ADVERTISE_100_FULL | ADVERTISE_1000_FULL)) {\n\t\te_err(\"EEE advertisement supports only 100TX and/or 1000T full-duplex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->eee_advert = ethtool_adv_to_mmd_eee_adv_t(edata->advertised);\n\n\thw->dev_spec.ich8lan.eee_disable = !edata->eee_enabled;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\t \n\tif (netif_running(netdev))\n\t\te1000e_reinit_locked(adapter);\n\telse\n\t\te1000e_reset(adapter);\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\treturn 0;\n}\n\nstatic int e1000e_get_ts_info(struct net_device *netdev,\n\t\t\t      struct ethtool_ts_info *info)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tethtool_op_get_ts_info(netdev, info);\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\n\t\treturn 0;\n\n\tinfo->so_timestamping |= (SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t  SOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t  SOF_TIMESTAMPING_RAW_HARDWARE);\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = (BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\n\t\t\t    BIT(HWTSTAMP_FILTER_ALL));\n\n\tif (adapter->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(adapter->ptp_clock);\n\n\treturn 0;\n}\n\nstatic u32 e1000e_get_priv_flags(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tu32 priv_flags = 0;\n\n\tif (adapter->flags2 & FLAG2_ENABLE_S0IX_FLOWS)\n\t\tpriv_flags |= E1000E_PRIV_FLAGS_S0IX_ENABLED;\n\n\treturn priv_flags;\n}\n\nstatic int e1000e_set_priv_flags(struct net_device *netdev, u32 priv_flags)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tunsigned int flags2 = adapter->flags2;\n\n\tflags2 &= ~FLAG2_ENABLE_S0IX_FLOWS;\n\tif (priv_flags & E1000E_PRIV_FLAGS_S0IX_ENABLED) {\n\t\tstruct e1000_hw *hw = &adapter->hw;\n\n\t\tif (hw->mac.type < e1000_pch_cnp)\n\t\t\treturn -EINVAL;\n\t\tflags2 |= FLAG2_ENABLE_S0IX_FLOWS;\n\t}\n\n\tif (flags2 != adapter->flags2)\n\t\tadapter->flags2 = flags2;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops e1000_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo\t\t= e1000_get_drvinfo,\n\t.get_regs_len\t\t= e1000_get_regs_len,\n\t.get_regs\t\t= e1000_get_regs,\n\t.get_wol\t\t= e1000_get_wol,\n\t.set_wol\t\t= e1000_set_wol,\n\t.get_msglevel\t\t= e1000_get_msglevel,\n\t.set_msglevel\t\t= e1000_set_msglevel,\n\t.nway_reset\t\t= e1000_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= e1000_get_eeprom_len,\n\t.get_eeprom\t\t= e1000_get_eeprom,\n\t.set_eeprom\t\t= e1000_set_eeprom,\n\t.get_ringparam\t\t= e1000_get_ringparam,\n\t.set_ringparam\t\t= e1000_set_ringparam,\n\t.get_pauseparam\t\t= e1000_get_pauseparam,\n\t.set_pauseparam\t\t= e1000_set_pauseparam,\n\t.self_test\t\t= e1000_diag_test,\n\t.get_strings\t\t= e1000_get_strings,\n\t.set_phys_id\t\t= e1000_set_phys_id,\n\t.get_ethtool_stats\t= e1000_get_ethtool_stats,\n\t.get_sset_count\t\t= e1000e_get_sset_count,\n\t.get_coalesce\t\t= e1000_get_coalesce,\n\t.set_coalesce\t\t= e1000_set_coalesce,\n\t.get_rxnfc\t\t= e1000_get_rxnfc,\n\t.get_ts_info\t\t= e1000e_get_ts_info,\n\t.get_eee\t\t= e1000e_get_eee,\n\t.set_eee\t\t= e1000e_set_eee,\n\t.get_link_ksettings\t= e1000_get_link_ksettings,\n\t.set_link_ksettings\t= e1000_set_link_ksettings,\n\t.get_priv_flags\t\t= e1000e_get_priv_flags,\n\t.set_priv_flags\t\t= e1000e_set_priv_flags,\n};\n\nvoid e1000e_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &e1000_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}