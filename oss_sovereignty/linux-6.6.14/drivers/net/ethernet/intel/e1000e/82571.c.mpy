{
  "module_name": "82571.c",
  "hash_id": "d0c692b34219e060c5412565423894da003715b6d344a4a7459a43ab1b166315",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/82571.c",
  "human_readable_source": "\n \n\n \n\n#include \"e1000.h\"\n\nstatic s32 e1000_get_phy_id_82571(struct e1000_hw *hw);\nstatic s32 e1000_setup_copper_link_82571(struct e1000_hw *hw);\nstatic s32 e1000_setup_fiber_serdes_link_82571(struct e1000_hw *hw);\nstatic s32 e1000_check_for_serdes_link_82571(struct e1000_hw *hw);\nstatic s32 e1000_write_nvm_eewr_82571(struct e1000_hw *hw, u16 offset,\n\t\t\t\t      u16 words, u16 *data);\nstatic s32 e1000_fix_nvm_checksum_82571(struct e1000_hw *hw);\nstatic void e1000_initialize_hw_bits_82571(struct e1000_hw *hw);\nstatic void e1000_clear_hw_cntrs_82571(struct e1000_hw *hw);\nstatic bool e1000_check_mng_mode_82574(struct e1000_hw *hw);\nstatic s32 e1000_led_on_82574(struct e1000_hw *hw);\nstatic void e1000_put_hw_semaphore_82571(struct e1000_hw *hw);\nstatic void e1000_power_down_phy_copper_82571(struct e1000_hw *hw);\nstatic void e1000_put_hw_semaphore_82573(struct e1000_hw *hw);\nstatic s32 e1000_get_hw_semaphore_82574(struct e1000_hw *hw);\nstatic void e1000_put_hw_semaphore_82574(struct e1000_hw *hw);\nstatic s32 e1000_set_d0_lplu_state_82574(struct e1000_hw *hw, bool active);\nstatic s32 e1000_set_d3_lplu_state_82574(struct e1000_hw *hw, bool active);\n\n \nstatic s32 e1000_init_phy_params_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\n\tif (hw->phy.media_type != e1000_media_type_copper) {\n\t\tphy->type = e1000_phy_none;\n\t\treturn 0;\n\t}\n\n\tphy->addr = 1;\n\tphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\tphy->reset_delay_us = 100;\n\n\tphy->ops.power_up = e1000_power_up_phy_copper;\n\tphy->ops.power_down = e1000_power_down_phy_copper_82571;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\tphy->type = e1000_phy_igp_2;\n\t\tbreak;\n\tcase e1000_82573:\n\t\tphy->type = e1000_phy_m88;\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tphy->type = e1000_phy_bm;\n\t\tphy->ops.acquire = e1000_get_hw_semaphore_82574;\n\t\tphy->ops.release = e1000_put_hw_semaphore_82574;\n\t\tphy->ops.set_d0_lplu_state = e1000_set_d0_lplu_state_82574;\n\t\tphy->ops.set_d3_lplu_state = e1000_set_d3_lplu_state_82574;\n\t\tbreak;\n\tdefault:\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\t \n\tret_val = e1000_get_phy_id_82571(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error getting PHY ID\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\tif (phy->id != IGP01E1000_I_PHY_ID)\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\tbreak;\n\tcase e1000_82573:\n\t\tif (phy->id != M88E1111_I_PHY_ID)\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tif (phy->id != BME1000_E_PHY_ID_R2)\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\tbreak;\n\tdefault:\n\t\tret_val = -E1000_ERR_PHY;\n\t\tbreak;\n\t}\n\n\tif (ret_val)\n\t\te_dbg(\"PHY ID unknown: type = 0x%08x\\n\", phy->id);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_init_nvm_params_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = er32(EECD);\n\tu16 size;\n\n\tnvm->opcode_bits = 8;\n\tnvm->delay_usec = 1;\n\tswitch (nvm->override) {\n\tcase e1000_nvm_override_spi_large:\n\t\tnvm->page_size = 32;\n\t\tnvm->address_bits = 16;\n\t\tbreak;\n\tcase e1000_nvm_override_spi_small:\n\t\tnvm->page_size = 8;\n\t\tnvm->address_bits = 8;\n\t\tbreak;\n\tdefault:\n\t\tnvm->page_size = eecd & E1000_EECD_ADDR_BITS ? 32 : 8;\n\t\tnvm->address_bits = eecd & E1000_EECD_ADDR_BITS ? 16 : 8;\n\t\tbreak;\n\t}\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tif (((eecd >> 15) & 0x3) == 0x3) {\n\t\t\tnvm->type = e1000_nvm_flash_hw;\n\t\t\tnvm->word_size = 2048;\n\t\t\t \n\t\t\teecd &= ~E1000_EECD_AUPDEN;\n\t\t\tew32(EECD, eecd);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tnvm->type = e1000_nvm_eeprom_spi;\n\t\tsize = (u16)((eecd & E1000_EECD_SIZE_EX_MASK) >>\n\t\t\t     E1000_EECD_SIZE_EX_SHIFT);\n\t\t \n\t\tsize += NVM_WORD_SIZE_BASE_SHIFT;\n\n\t\t \n\t\tif (size > 14)\n\t\t\tsize = 14;\n\t\tnvm->word_size = BIT(size);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tnvm->ops.acquire = e1000_get_hw_semaphore_82574;\n\t\tnvm->ops.release = e1000_put_hw_semaphore_82574;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_init_mac_params_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 swsm = 0;\n\tu32 swsm2 = 0;\n\tbool force_clear_smbi = false;\n\n\t \n\tswitch (hw->adapter->pdev->device) {\n\tcase E1000_DEV_ID_82571EB_FIBER:\n\tcase E1000_DEV_ID_82572EI_FIBER:\n\tcase E1000_DEV_ID_82571EB_QUAD_FIBER:\n\t\thw->phy.media_type = e1000_media_type_fiber;\n\t\tmac->ops.setup_physical_interface =\n\t\t    e1000_setup_fiber_serdes_link_82571;\n\t\tmac->ops.check_for_link = e1000e_check_for_fiber_link;\n\t\tmac->ops.get_link_up_info =\n\t\t    e1000e_get_speed_and_duplex_fiber_serdes;\n\t\tbreak;\n\tcase E1000_DEV_ID_82571EB_SERDES:\n\tcase E1000_DEV_ID_82571EB_SERDES_DUAL:\n\tcase E1000_DEV_ID_82571EB_SERDES_QUAD:\n\tcase E1000_DEV_ID_82572EI_SERDES:\n\t\thw->phy.media_type = e1000_media_type_internal_serdes;\n\t\tmac->ops.setup_physical_interface =\n\t\t    e1000_setup_fiber_serdes_link_82571;\n\t\tmac->ops.check_for_link = e1000_check_for_serdes_link_82571;\n\t\tmac->ops.get_link_up_info =\n\t\t    e1000e_get_speed_and_duplex_fiber_serdes;\n\t\tbreak;\n\tdefault:\n\t\thw->phy.media_type = e1000_media_type_copper;\n\t\tmac->ops.setup_physical_interface =\n\t\t    e1000_setup_copper_link_82571;\n\t\tmac->ops.check_for_link = e1000e_check_for_copper_link;\n\t\tmac->ops.get_link_up_info = e1000e_get_speed_and_duplex_copper;\n\t\tbreak;\n\t}\n\n\t \n\tmac->mta_reg_count = 128;\n\t \n\tmac->rar_entry_count = E1000_RAR_ENTRIES;\n\t \n\tmac->adaptive_ifs = true;\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\t\tmac->ops.set_lan_id = e1000_set_lan_id_single_port;\n\t\tmac->ops.check_mng_mode = e1000e_check_mng_mode_generic;\n\t\tmac->ops.led_on = e1000e_led_on_generic;\n\t\tmac->ops.blink_led = e1000e_blink_led_generic;\n\n\t\t \n\t\tmac->has_fwsm = true;\n\t\t \n\t\tmac->arc_subsystem_valid = !!(er32(FWSM) &\n\t\t\t\t\t      E1000_FWSM_MODE_MASK);\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tmac->ops.set_lan_id = e1000_set_lan_id_single_port;\n\t\tmac->ops.check_mng_mode = e1000_check_mng_mode_82574;\n\t\tmac->ops.led_on = e1000_led_on_82574;\n\t\tbreak;\n\tdefault:\n\t\tmac->ops.check_mng_mode = e1000e_check_mng_mode_generic;\n\t\tmac->ops.led_on = e1000e_led_on_generic;\n\t\tmac->ops.blink_led = e1000e_blink_led_generic;\n\n\t\t \n\t\tmac->has_fwsm = true;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\tswsm2 = er32(SWSM2);\n\n\t\tif (!(swsm2 & E1000_SWSM2_LOCK)) {\n\t\t\t \n\t\t\tew32(SWSM2, swsm2 | E1000_SWSM2_LOCK);\n\t\t\tforce_clear_smbi = true;\n\t\t} else {\n\t\t\tforce_clear_smbi = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tforce_clear_smbi = true;\n\t\tbreak;\n\t}\n\n\tif (force_clear_smbi) {\n\t\t \n\t\tswsm = er32(SWSM);\n\t\tif (swsm & E1000_SWSM_SMBI) {\n\t\t\t \n\t\t\te_dbg(\"Please update your 82571 Bootagent\\n\");\n\t\t}\n\t\tew32(SWSM, swsm & ~E1000_SWSM_SMBI);\n\t}\n\n\t \n\thw->dev_spec.e82571.smb_counter = 0;\n\n\treturn 0;\n}\n\nstatic s32 e1000_get_variants_82571(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstatic int global_quad_port_a;\t \n\tstruct pci_dev *pdev = adapter->pdev;\n\tint is_port_b = er32(STATUS) & E1000_STATUS_FUNC_1;\n\ts32 rc;\n\n\trc = e1000_init_mac_params_82571(hw);\n\tif (rc)\n\t\treturn rc;\n\n\trc = e1000_init_nvm_params_82571(hw);\n\tif (rc)\n\t\treturn rc;\n\n\trc = e1000_init_phy_params_82571(hw);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tswitch (pdev->device) {\n\tcase E1000_DEV_ID_82571EB_QUAD_COPPER:\n\tcase E1000_DEV_ID_82571EB_QUAD_FIBER:\n\tcase E1000_DEV_ID_82571EB_QUAD_COPPER_LP:\n\tcase E1000_DEV_ID_82571PT_QUAD_COPPER:\n\t\tadapter->flags |= FLAG_IS_QUAD_PORT;\n\t\t \n\t\tif (global_quad_port_a == 0)\n\t\t\tadapter->flags |= FLAG_IS_QUAD_PORT_A;\n\t\t \n\t\tglobal_quad_port_a++;\n\t\tif (global_quad_port_a == 4)\n\t\t\tglobal_quad_port_a = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (adapter->hw.mac.type) {\n\tcase e1000_82571:\n\t\t \n\t\tif (((pdev->device == E1000_DEV_ID_82571EB_FIBER) ||\n\t\t     (pdev->device == E1000_DEV_ID_82571EB_SERDES) ||\n\t\t     (pdev->device == E1000_DEV_ID_82571EB_COPPER)) &&\n\t\t    (is_port_b))\n\t\t\tadapter->flags &= ~FLAG_HAS_WOL;\n\t\t \n\t\tif (adapter->flags & FLAG_IS_QUAD_PORT &&\n\t\t    (!(adapter->flags & FLAG_IS_QUAD_PORT_A)))\n\t\t\tadapter->flags &= ~FLAG_HAS_WOL;\n\t\t \n\t\tif (pdev->device == E1000_DEV_ID_82571EB_SERDES_QUAD)\n\t\t\tadapter->flags &= ~FLAG_HAS_WOL;\n\t\tbreak;\n\tcase e1000_82573:\n\t\tif (pdev->device == E1000_DEV_ID_82573L) {\n\t\t\tadapter->flags |= FLAG_HAS_JUMBO_FRAMES;\n\t\t\tadapter->max_hw_frame_size = DEFAULT_JUMBO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_get_phy_id_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_id = 0;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\t \n\t\tphy->id = IGP01E1000_I_PHY_ID;\n\t\tbreak;\n\tcase e1000_82573:\n\t\treturn e1000e_get_phy_id(hw);\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tret_val = e1e_rphy(hw, MII_PHYSID1, &phy_id);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy->id = (u32)(phy_id << 16);\n\t\tusleep_range(20, 40);\n\t\tret_val = e1e_rphy(hw, MII_PHYSID2, &phy_id);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy->id |= (u32)(phy_id);\n\t\tphy->revision = (u32)(phy_id & ~PHY_REVISION_MASK);\n\t\tbreak;\n\tdefault:\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_get_hw_semaphore_82571(struct e1000_hw *hw)\n{\n\tu32 swsm;\n\ts32 sw_timeout = hw->nvm.word_size + 1;\n\ts32 fw_timeout = hw->nvm.word_size + 1;\n\ts32 i = 0;\n\n\t \n\tif (hw->dev_spec.e82571.smb_counter > 2)\n\t\tsw_timeout = 1;\n\n\t \n\twhile (i < sw_timeout) {\n\t\tswsm = er32(SWSM);\n\t\tif (!(swsm & E1000_SWSM_SMBI))\n\t\t\tbreak;\n\n\t\tusleep_range(50, 100);\n\t\ti++;\n\t}\n\n\tif (i == sw_timeout) {\n\t\te_dbg(\"Driver can't access device - SMBI bit is set.\\n\");\n\t\thw->dev_spec.e82571.smb_counter++;\n\t}\n\t \n\tfor (i = 0; i < fw_timeout; i++) {\n\t\tswsm = er32(SWSM);\n\t\tew32(SWSM, swsm | E1000_SWSM_SWESMBI);\n\n\t\t \n\t\tif (er32(SWSM) & E1000_SWSM_SWESMBI)\n\t\t\tbreak;\n\n\t\tusleep_range(50, 100);\n\t}\n\n\tif (i == fw_timeout) {\n\t\t \n\t\te1000_put_hw_semaphore_82571(hw);\n\t\te_dbg(\"Driver can't access the NVM\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void e1000_put_hw_semaphore_82571(struct e1000_hw *hw)\n{\n\tu32 swsm;\n\n\tswsm = er32(SWSM);\n\tswsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);\n\tew32(SWSM, swsm);\n}\n\n \nstatic s32 e1000_get_hw_semaphore_82573(struct e1000_hw *hw)\n{\n\tu32 extcnf_ctrl;\n\ts32 i = 0;\n\n\textcnf_ctrl = er32(EXTCNF_CTRL);\n\tdo {\n\t\textcnf_ctrl |= E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;\n\t\tew32(EXTCNF_CTRL, extcnf_ctrl);\n\t\textcnf_ctrl = er32(EXTCNF_CTRL);\n\n\t\tif (extcnf_ctrl & E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP)\n\t\t\tbreak;\n\n\t\tusleep_range(2000, 4000);\n\t\ti++;\n\t} while (i < MDIO_OWNERSHIP_TIMEOUT);\n\n\tif (i == MDIO_OWNERSHIP_TIMEOUT) {\n\t\t \n\t\te1000_put_hw_semaphore_82573(hw);\n\t\te_dbg(\"Driver can't access the PHY\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void e1000_put_hw_semaphore_82573(struct e1000_hw *hw)\n{\n\tu32 extcnf_ctrl;\n\n\textcnf_ctrl = er32(EXTCNF_CTRL);\n\textcnf_ctrl &= ~E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;\n\tew32(EXTCNF_CTRL, extcnf_ctrl);\n}\n\nstatic DEFINE_MUTEX(swflag_mutex);\n\n \nstatic s32 e1000_get_hw_semaphore_82574(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tmutex_lock(&swflag_mutex);\n\tret_val = e1000_get_hw_semaphore_82573(hw);\n\tif (ret_val)\n\t\tmutex_unlock(&swflag_mutex);\n\treturn ret_val;\n}\n\n \nstatic void e1000_put_hw_semaphore_82574(struct e1000_hw *hw)\n{\n\te1000_put_hw_semaphore_82573(hw);\n\tmutex_unlock(&swflag_mutex);\n}\n\n \nstatic s32 e1000_set_d0_lplu_state_82574(struct e1000_hw *hw, bool active)\n{\n\tu32 data = er32(POEMB);\n\n\tif (active)\n\t\tdata |= E1000_PHY_CTRL_D0A_LPLU;\n\telse\n\t\tdata &= ~E1000_PHY_CTRL_D0A_LPLU;\n\n\tew32(POEMB, data);\n\treturn 0;\n}\n\n \nstatic s32 e1000_set_d3_lplu_state_82574(struct e1000_hw *hw, bool active)\n{\n\tu32 data = er32(POEMB);\n\n\tif (!active) {\n\t\tdata &= ~E1000_PHY_CTRL_NOND0A_LPLU;\n\t} else if ((hw->phy.autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\n\t\t   (hw->phy.autoneg_advertised == E1000_ALL_NOT_GIG) ||\n\t\t   (hw->phy.autoneg_advertised == E1000_ALL_10_SPEED)) {\n\t\tdata |= E1000_PHY_CTRL_NOND0A_LPLU;\n\t}\n\n\tew32(POEMB, data);\n\treturn 0;\n}\n\n \nstatic s32 e1000_acquire_nvm_82571(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tret_val = e1000_get_hw_semaphore_82571(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\t\tbreak;\n\tdefault:\n\t\tret_val = e1000e_acquire_nvm(hw);\n\t\tbreak;\n\t}\n\n\tif (ret_val)\n\t\te1000_put_hw_semaphore_82571(hw);\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_release_nvm_82571(struct e1000_hw *hw)\n{\n\te1000e_release_nvm(hw);\n\te1000_put_hw_semaphore_82571(hw);\n}\n\n \nstatic s32 e1000_write_nvm_82571(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t u16 *data)\n{\n\ts32 ret_val;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tret_val = e1000_write_nvm_eewr_82571(hw, offset, words, data);\n\t\tbreak;\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\tret_val = e1000e_write_nvm_spi(hw, offset, words, data);\n\t\tbreak;\n\tdefault:\n\t\tret_val = -E1000_ERR_NVM;\n\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_update_nvm_checksum_82571(struct e1000_hw *hw)\n{\n\tu32 eecd;\n\ts32 ret_val;\n\tu16 i;\n\n\tret_val = e1000e_update_nvm_checksum_generic(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (hw->nvm.type != e1000_nvm_flash_hw)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < E1000_FLASH_UPDATES; i++) {\n\t\tusleep_range(1000, 2000);\n\t\tif (!(er32(EECD) & E1000_EECD_FLUPD))\n\t\t\tbreak;\n\t}\n\n\tif (i == E1000_FLASH_UPDATES)\n\t\treturn -E1000_ERR_NVM;\n\n\t \n\tif ((er32(FLOP) & 0xFF00) == E1000_STM_OPCODE) {\n\t\t \n\t\tew32(HICR, E1000_HICR_FW_RESET_ENABLE);\n\t\te1e_flush();\n\t\tew32(HICR, E1000_HICR_FW_RESET);\n\t}\n\n\t \n\teecd = er32(EECD) | E1000_EECD_FLUPD;\n\tew32(EECD, eecd);\n\n\tfor (i = 0; i < E1000_FLASH_UPDATES; i++) {\n\t\tusleep_range(1000, 2000);\n\t\tif (!(er32(EECD) & E1000_EECD_FLUPD))\n\t\t\tbreak;\n\t}\n\n\tif (i == E1000_FLASH_UPDATES)\n\t\treturn -E1000_ERR_NVM;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_validate_nvm_checksum_82571(struct e1000_hw *hw)\n{\n\tif (hw->nvm.type == e1000_nvm_flash_hw)\n\t\te1000_fix_nvm_checksum_82571(hw);\n\n\treturn e1000e_validate_nvm_checksum_generic(hw);\n}\n\n \nstatic s32 e1000_write_nvm_eewr_82571(struct e1000_hw *hw, u16 offset,\n\t\t\t\t      u16 words, u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 i, eewr = 0;\n\ts32 ret_val = 0;\n\n\t \n\tif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\n\t    (words == 0)) {\n\t\te_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\teewr = ((data[i] << E1000_NVM_RW_REG_DATA) |\n\t\t\t((offset + i) << E1000_NVM_RW_ADDR_SHIFT) |\n\t\t\tE1000_NVM_RW_REG_START);\n\n\t\tret_val = e1000e_poll_eerd_eewr_done(hw, E1000_NVM_POLL_WRITE);\n\t\tif (ret_val)\n\t\t\tbreak;\n\n\t\tew32(EEWR, eewr);\n\n\t\tret_val = e1000e_poll_eerd_eewr_done(hw, E1000_NVM_POLL_WRITE);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_get_cfg_done_82571(struct e1000_hw *hw)\n{\n\ts32 timeout = PHY_CFG_TIMEOUT;\n\n\twhile (timeout) {\n\t\tif (er32(EEMNGCTL) & E1000_NVM_CFG_DONE_PORT_0)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\ttimeout--;\n\t}\n\tif (!timeout) {\n\t\te_dbg(\"MNG configuration cycle has not completed.\\n\");\n\t\treturn -E1000_ERR_RESET;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_set_d0_lplu_state_82571(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = e1e_rphy(hw, IGP02E1000_PHY_POWER_MGMT, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (active) {\n\t\tdata |= IGP02E1000_PM_D0_LPLU;\n\t\tret_val = e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else {\n\t\tdata &= ~IGP02E1000_PM_D0_LPLU;\n\t\tret_val = e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata |= IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t} else if (phy->smart_speed == e1000_smart_speed_off) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_reset_hw_82571(struct e1000_hw *hw)\n{\n\tu32 ctrl, ctrl_ext, eecd, tctl;\n\ts32 ret_val;\n\n\t \n\tret_val = e1000e_disable_pcie_master(hw);\n\tif (ret_val)\n\t\te_dbg(\"PCI-E Master disable polling has failed.\\n\");\n\n\te_dbg(\"Masking off all interrupts\\n\");\n\tew32(IMC, 0xffffffff);\n\n\tew32(RCTL, 0);\n\ttctl = er32(TCTL);\n\ttctl &= ~E1000_TCTL_EN;\n\tew32(TCTL, tctl);\n\te1e_flush();\n\n\tusleep_range(10000, 11000);\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\t\tret_val = e1000_get_hw_semaphore_82573(hw);\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tret_val = e1000_get_hw_semaphore_82574(hw);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tctrl = er32(CTRL);\n\n\te_dbg(\"Issuing a global reset to MAC\\n\");\n\tew32(CTRL, ctrl | E1000_CTRL_RST);\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\t\t \n\t\tif (!ret_val)\n\t\t\te1000_put_hw_semaphore_82573(hw);\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\t \n\t\tif (!ret_val)\n\t\t\te1000_put_hw_semaphore_82574(hw);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (hw->nvm.type == e1000_nvm_flash_hw) {\n\t\tusleep_range(10, 20);\n\t\tctrl_ext = er32(CTRL_EXT);\n\t\tctrl_ext |= E1000_CTRL_EXT_EE_RST;\n\t\tew32(CTRL_EXT, ctrl_ext);\n\t\te1e_flush();\n\t}\n\n\tret_val = e1000e_get_auto_rd_done(hw);\n\tif (ret_val)\n\t\t \n\t\treturn ret_val;\n\n\t \n\n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\t \n\t\teecd = er32(EECD);\n\t\teecd &= ~(E1000_EECD_REQ | E1000_EECD_GNT);\n\t\tew32(EECD, eecd);\n\t\tbreak;\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tmsleep(25);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tew32(IMC, 0xffffffff);\n\ter32(ICR);\n\n\tif (hw->mac.type == e1000_82571) {\n\t\t \n\t\tret_val = e1000_check_alt_mac_addr_generic(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\te1000e_set_laa_state_82571(hw, true);\n\t}\n\n\t \n\tif (hw->phy.media_type == e1000_media_type_internal_serdes)\n\t\thw->mac.serdes_link_state = e1000_serdes_link_down;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_init_hw_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 reg_data;\n\ts32 ret_val;\n\tu16 i, rar_count = mac->rar_entry_count;\n\n\te1000_initialize_hw_bits_82571(hw);\n\n\t \n\tret_val = mac->ops.id_led_init(hw);\n\t \n\tif (ret_val)\n\t\te_dbg(\"Error initializing identification LED\\n\");\n\n\t \n\te_dbg(\"Initializing the IEEE VLAN\\n\");\n\tmac->ops.clear_vfta(hw);\n\n\t \n\tif (e1000e_get_laa_state_82571(hw))\n\t\trar_count--;\n\te1000e_init_rx_addrs(hw, rar_count);\n\n\t \n\te_dbg(\"Zeroing the MTA\\n\");\n\tfor (i = 0; i < mac->mta_reg_count; i++)\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);\n\n\t \n\tret_val = mac->ops.setup_link(hw);\n\n\t \n\treg_data = er32(TXDCTL(0));\n\treg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\n\t\t    E1000_TXDCTL_FULL_TX_DESC_WB | E1000_TXDCTL_COUNT_DESC);\n\tew32(TXDCTL(0), reg_data);\n\n\t \n\tswitch (mac->type) {\n\tcase e1000_82573:\n\t\te1000e_enable_tx_pkt_filtering(hw);\n\t\tfallthrough;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\treg_data = er32(GCR);\n\t\treg_data |= E1000_GCR_L1_ACT_WITHOUT_L0S_RX;\n\t\tew32(GCR, reg_data);\n\t\tbreak;\n\tdefault:\n\t\treg_data = er32(TXDCTL(1));\n\t\treg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\n\t\t\t    E1000_TXDCTL_FULL_TX_DESC_WB |\n\t\t\t    E1000_TXDCTL_COUNT_DESC);\n\t\tew32(TXDCTL(1), reg_data);\n\t\tbreak;\n\t}\n\n\t \n\te1000_clear_hw_cntrs_82571(hw);\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_initialize_hw_bits_82571(struct e1000_hw *hw)\n{\n\tu32 reg;\n\n\t \n\treg = er32(TXDCTL(0));\n\treg |= BIT(22);\n\tew32(TXDCTL(0), reg);\n\n\t \n\treg = er32(TXDCTL(1));\n\treg |= BIT(22);\n\tew32(TXDCTL(1), reg);\n\n\t \n\treg = er32(TARC(0));\n\treg &= ~(0xF << 27);\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\treg |= BIT(23) | BIT(24) | BIT(25) | BIT(26);\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\treg |= BIT(26);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tew32(TARC(0), reg);\n\n\t \n\treg = er32(TARC(1));\n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\treg &= ~(BIT(29) | BIT(30));\n\t\treg |= BIT(22) | BIT(24) | BIT(25) | BIT(26);\n\t\tif (er32(TCTL) & E1000_TCTL_MULR)\n\t\t\treg &= ~BIT(28);\n\t\telse\n\t\t\treg |= BIT(28);\n\t\tew32(TARC(1), reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\treg = er32(CTRL);\n\t\treg &= ~BIT(29);\n\t\tew32(CTRL, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\treg = er32(CTRL_EXT);\n\t\treg &= ~BIT(23);\n\t\treg |= BIT(22);\n\t\tew32(CTRL_EXT, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (hw->mac.type == e1000_82571) {\n\t\treg = er32(PBA_ECC);\n\t\treg |= E1000_PBA_ECC_CORR_EN;\n\t\tew32(PBA_ECC, reg);\n\t}\n\n\t \n\tif ((hw->mac.type == e1000_82571) || (hw->mac.type == e1000_82572)) {\n\t\treg = er32(CTRL_EXT);\n\t\treg &= ~E1000_CTRL_EXT_DMA_DYN_CLK_EN;\n\t\tew32(CTRL_EXT, reg);\n\t}\n\n\t \n\tif (hw->mac.type <= e1000_82573) {\n\t\treg = er32(RFCTL);\n\t\treg |= (E1000_RFCTL_IPV6_EX_DIS | E1000_RFCTL_NEW_IPV6_EXT_DIS);\n\t\tew32(RFCTL, reg);\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\treg = er32(GCR);\n\t\treg |= BIT(22);\n\t\tew32(GCR, reg);\n\n\t\t \n\t\treg = er32(GCR2);\n\t\treg |= 1;\n\t\tew32(GCR2, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void e1000_clear_vfta_82571(struct e1000_hw *hw)\n{\n\tu32 offset;\n\tu32 vfta_value = 0;\n\tu32 vfta_offset = 0;\n\tu32 vfta_bit_in_reg = 0;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tif (hw->mng_cookie.vlan_id != 0) {\n\t\t\t \n\t\t\tvfta_offset = (hw->mng_cookie.vlan_id >>\n\t\t\t\t       E1000_VFTA_ENTRY_SHIFT) &\n\t\t\t    E1000_VFTA_ENTRY_MASK;\n\t\t\tvfta_bit_in_reg =\n\t\t\t    BIT(hw->mng_cookie.vlan_id &\n\t\t\t\tE1000_VFTA_ENTRY_BIT_SHIFT_MASK);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tfor (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {\n\t\t \n\t\tvfta_value = (offset == vfta_offset) ? vfta_bit_in_reg : 0;\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_VFTA, offset, vfta_value);\n\t\te1e_flush();\n\t}\n}\n\n \nstatic bool e1000_check_mng_mode_82574(struct e1000_hw *hw)\n{\n\tu16 data;\n\n\te1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &data);\n\treturn (data & E1000_NVM_INIT_CTRL2_MNGM) != 0;\n}\n\n \nstatic s32 e1000_led_on_82574(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\tu32 i;\n\n\tctrl = hw->mac.ledctl_mode2;\n\tif (!(E1000_STATUS_LU & er32(STATUS))) {\n\t\t \n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (((hw->mac.ledctl_mode2 >> (i * 8)) & 0xFF) ==\n\t\t\t    E1000_LEDCTL_MODE_LED_ON)\n\t\t\t\tctrl |= (E1000_LEDCTL_LED0_IVRT << (i * 8));\n\t}\n\tew32(LEDCTL, ctrl);\n\n\treturn 0;\n}\n\n \nbool e1000_check_phy_82574(struct e1000_hw *hw)\n{\n\tu16 status_1kbt = 0;\n\tu16 receive_errors = 0;\n\ts32 ret_val;\n\n\t \n\tret_val = e1e_rphy(hw, E1000_RECEIVE_ERROR_COUNTER, &receive_errors);\n\tif (ret_val)\n\t\treturn false;\n\tif (receive_errors == E1000_RECEIVE_ERROR_MAX) {\n\t\tret_val = e1e_rphy(hw, E1000_BASE1000T_STATUS, &status_1kbt);\n\t\tif (ret_val)\n\t\t\treturn false;\n\t\tif ((status_1kbt & E1000_IDLE_ERROR_COUNT_MASK) ==\n\t\t    E1000_IDLE_ERROR_COUNT_MASK)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic s32 e1000_setup_link_82571(struct e1000_hw *hw)\n{\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tif (hw->fc.requested_mode == e1000_fc_default)\n\t\t\thw->fc.requested_mode = e1000_fc_full;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn e1000e_setup_link_generic(hw);\n}\n\n \nstatic s32 e1000_setup_copper_link_82571(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_SLU;\n\tctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tew32(CTRL, ctrl);\n\n\tswitch (hw->phy.type) {\n\tcase e1000_phy_m88:\n\tcase e1000_phy_bm:\n\t\tret_val = e1000e_copper_link_setup_m88(hw);\n\t\tbreak;\n\tcase e1000_phy_igp_2:\n\t\tret_val = e1000e_copper_link_setup_igp(hw);\n\t\tbreak;\n\tdefault:\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1000e_setup_copper_link(hw);\n}\n\n \nstatic s32 e1000_setup_fiber_serdes_link_82571(struct e1000_hw *hw)\n{\n\tswitch (hw->mac.type) {\n\tcase e1000_82571:\n\tcase e1000_82572:\n\t\t \n\t\tew32(SCTL, E1000_SCTL_DISABLE_SERDES_LOOPBACK);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn e1000e_setup_fiber_serdes_link(hw);\n}\n\n \nstatic s32 e1000_check_for_serdes_link_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 rxcw;\n\tu32 ctrl;\n\tu32 status;\n\tu32 txcw;\n\tu32 i;\n\ts32 ret_val = 0;\n\n\tctrl = er32(CTRL);\n\tstatus = er32(STATUS);\n\ter32(RXCW);\n\t \n\tusleep_range(10, 20);\n\trxcw = er32(RXCW);\n\n\tif ((rxcw & E1000_RXCW_SYNCH) && !(rxcw & E1000_RXCW_IV)) {\n\t\t \n\t\tswitch (mac->serdes_link_state) {\n\t\tcase e1000_serdes_link_autoneg_complete:\n\t\t\tif (!(status & E1000_STATUS_LU)) {\n\t\t\t\t \n\t\t\t\tmac->serdes_link_state =\n\t\t\t\t    e1000_serdes_link_autoneg_progress;\n\t\t\t\tmac->serdes_has_link = false;\n\t\t\t\te_dbg(\"AN_UP     -> AN_PROG\\n\");\n\t\t\t} else {\n\t\t\t\tmac->serdes_has_link = true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase e1000_serdes_link_forced_up:\n\t\t\t \n\t\t\tif (rxcw & E1000_RXCW_C) {\n\t\t\t\t \n\t\t\t\tew32(TXCW, mac->txcw);\n\t\t\t\tew32(CTRL, (ctrl & ~E1000_CTRL_SLU));\n\t\t\t\tmac->serdes_link_state =\n\t\t\t\t    e1000_serdes_link_autoneg_progress;\n\t\t\t\tmac->serdes_has_link = false;\n\t\t\t\te_dbg(\"FORCED_UP -> AN_PROG\\n\");\n\t\t\t} else {\n\t\t\t\tmac->serdes_has_link = true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase e1000_serdes_link_autoneg_progress:\n\t\t\tif (rxcw & E1000_RXCW_C) {\n\t\t\t\t \n\t\t\t\tif (status & E1000_STATUS_LU) {\n\t\t\t\t\tmac->serdes_link_state =\n\t\t\t\t\t    e1000_serdes_link_autoneg_complete;\n\t\t\t\t\te_dbg(\"AN_PROG   -> AN_UP\\n\");\n\t\t\t\t\tmac->serdes_has_link = true;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tmac->serdes_link_state =\n\t\t\t\t\t    e1000_serdes_link_down;\n\t\t\t\t\te_dbg(\"AN_PROG   -> DOWN\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tew32(TXCW, (mac->txcw & ~E1000_TXCW_ANE));\n\t\t\t\tctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);\n\t\t\t\tew32(CTRL, ctrl);\n\n\t\t\t\t \n\t\t\t\tret_val = e1000e_config_fc_after_link_up(hw);\n\t\t\t\tif (ret_val) {\n\t\t\t\t\te_dbg(\"Error config flow control\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmac->serdes_link_state =\n\t\t\t\t    e1000_serdes_link_forced_up;\n\t\t\t\tmac->serdes_has_link = true;\n\t\t\t\te_dbg(\"AN_PROG   -> FORCED_UP\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase e1000_serdes_link_down:\n\t\tdefault:\n\t\t\t \n\t\t\tew32(TXCW, mac->txcw);\n\t\t\tew32(CTRL, (ctrl & ~E1000_CTRL_SLU));\n\t\t\tmac->serdes_link_state =\n\t\t\t    e1000_serdes_link_autoneg_progress;\n\t\t\tmac->serdes_has_link = false;\n\t\t\te_dbg(\"DOWN      -> AN_PROG\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (!(rxcw & E1000_RXCW_SYNCH)) {\n\t\t\tmac->serdes_has_link = false;\n\t\t\tmac->serdes_link_state = e1000_serdes_link_down;\n\t\t\te_dbg(\"ANYSTATE  -> DOWN\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i < AN_RETRY_COUNT; i++) {\n\t\t\t\tusleep_range(10, 20);\n\t\t\t\trxcw = er32(RXCW);\n\t\t\t\tif ((rxcw & E1000_RXCW_SYNCH) &&\n\t\t\t\t    (rxcw & E1000_RXCW_C))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (rxcw & E1000_RXCW_IV) {\n\t\t\t\t\tmac->serdes_has_link = false;\n\t\t\t\t\tmac->serdes_link_state =\n\t\t\t\t\t    e1000_serdes_link_down;\n\t\t\t\t\te_dbg(\"ANYSTATE  -> DOWN\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == AN_RETRY_COUNT) {\n\t\t\t\ttxcw = er32(TXCW);\n\t\t\t\ttxcw |= E1000_TXCW_ANE;\n\t\t\t\tew32(TXCW, txcw);\n\t\t\t\tmac->serdes_link_state =\n\t\t\t\t    e1000_serdes_link_autoneg_progress;\n\t\t\t\tmac->serdes_has_link = false;\n\t\t\t\te_dbg(\"ANYSTATE  -> AN_PROG\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_valid_led_default_82571(struct e1000_hw *hw, u16 *data)\n{\n\ts32 ret_val;\n\n\tret_val = e1000_read_nvm(hw, NVM_ID_LED_SETTINGS, 1, data);\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82573:\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tif (*data == ID_LED_RESERVED_F746)\n\t\t\t*data = ID_LED_DEFAULT_82573;\n\t\tbreak;\n\tdefault:\n\t\tif (*data == ID_LED_RESERVED_0000 ||\n\t\t    *data == ID_LED_RESERVED_FFFF)\n\t\t\t*data = ID_LED_DEFAULT;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nbool e1000e_get_laa_state_82571(struct e1000_hw *hw)\n{\n\tif (hw->mac.type != e1000_82571)\n\t\treturn false;\n\n\treturn hw->dev_spec.e82571.laa_is_present;\n}\n\n \nvoid e1000e_set_laa_state_82571(struct e1000_hw *hw, bool state)\n{\n\tif (hw->mac.type != e1000_82571)\n\t\treturn;\n\n\thw->dev_spec.e82571.laa_is_present = state;\n\n\t \n\tif (state)\n\t\t \n\t\thw->mac.ops.rar_set(hw, hw->mac.addr,\n\t\t\t\t    hw->mac.rar_entry_count - 1);\n}\n\n \nstatic s32 e1000_fix_nvm_checksum_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\ts32 ret_val;\n\tu16 data;\n\n\tif (nvm->type != e1000_nvm_flash_hw)\n\t\treturn 0;\n\n\t \n\tret_val = e1000_read_nvm(hw, 0x10, 1, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!(data & 0x10)) {\n\t\t \n\t\tret_val = e1000_read_nvm(hw, 0x23, 1, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!(data & 0x8000)) {\n\t\t\tdata |= 0x8000;\n\t\t\tret_val = e1000_write_nvm(hw, 0x23, 1, &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tret_val = e1000e_update_nvm_checksum(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_read_mac_addr_82571(struct e1000_hw *hw)\n{\n\tif (hw->mac.type == e1000_82571) {\n\t\ts32 ret_val;\n\n\t\t \n\t\tret_val = e1000_check_alt_mac_addr_generic(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn e1000_read_mac_addr_generic(hw);\n}\n\n \nstatic void e1000_power_down_phy_copper_82571(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tstruct e1000_mac_info *mac = &hw->mac;\n\n\tif (!phy->ops.check_reset_block)\n\t\treturn;\n\n\t \n\tif (!(mac->ops.check_mng_mode(hw) || phy->ops.check_reset_block(hw)))\n\t\te1000_power_down_phy_copper(hw);\n}\n\n \nstatic void e1000_clear_hw_cntrs_82571(struct e1000_hw *hw)\n{\n\te1000e_clear_hw_cntrs_base(hw);\n\n\ter32(PRC64);\n\ter32(PRC127);\n\ter32(PRC255);\n\ter32(PRC511);\n\ter32(PRC1023);\n\ter32(PRC1522);\n\ter32(PTC64);\n\ter32(PTC127);\n\ter32(PTC255);\n\ter32(PTC511);\n\ter32(PTC1023);\n\ter32(PTC1522);\n\n\ter32(ALGNERRC);\n\ter32(RXERRC);\n\ter32(TNCRS);\n\ter32(CEXTERR);\n\ter32(TSCTC);\n\ter32(TSCTFC);\n\n\ter32(MGTPRC);\n\ter32(MGTPDC);\n\ter32(MGTPTC);\n\n\ter32(IAC);\n\ter32(ICRXOC);\n\n\ter32(ICRXPTC);\n\ter32(ICRXATC);\n\ter32(ICTXPTC);\n\ter32(ICTXATC);\n\ter32(ICTXQEC);\n\ter32(ICTXQMTC);\n\ter32(ICRXDMTC);\n}\n\nstatic const struct e1000_mac_operations e82571_mac_ops = {\n\t \n\t \n\t.id_led_init\t\t= e1000e_id_led_init_generic,\n\t.cleanup_led\t\t= e1000e_cleanup_led_generic,\n\t.clear_hw_cntrs\t\t= e1000_clear_hw_cntrs_82571,\n\t.get_bus_info\t\t= e1000e_get_bus_info_pcie,\n\t.set_lan_id\t\t= e1000_set_lan_id_multi_port_pcie,\n\t \n\t \n\t.led_off\t\t= e1000e_led_off_generic,\n\t.update_mc_addr_list\t= e1000e_update_mc_addr_list_generic,\n\t.write_vfta\t\t= e1000_write_vfta_generic,\n\t.clear_vfta\t\t= e1000_clear_vfta_82571,\n\t.reset_hw\t\t= e1000_reset_hw_82571,\n\t.init_hw\t\t= e1000_init_hw_82571,\n\t.setup_link\t\t= e1000_setup_link_82571,\n\t \n\t.setup_led\t\t= e1000e_setup_led_generic,\n\t.config_collision_dist\t= e1000e_config_collision_dist_generic,\n\t.read_mac_addr\t\t= e1000_read_mac_addr_82571,\n\t.rar_set\t\t= e1000e_rar_set_generic,\n\t.rar_get_count\t\t= e1000e_rar_get_count_generic,\n};\n\nstatic const struct e1000_phy_operations e82_phy_ops_igp = {\n\t.acquire\t\t= e1000_get_hw_semaphore_82571,\n\t.check_polarity\t\t= e1000_check_polarity_igp,\n\t.check_reset_block\t= e1000e_check_reset_block_generic,\n\t.commit\t\t\t= NULL,\n\t.force_speed_duplex\t= e1000e_phy_force_speed_duplex_igp,\n\t.get_cfg_done\t\t= e1000_get_cfg_done_82571,\n\t.get_cable_length\t= e1000e_get_cable_length_igp_2,\n\t.get_info\t\t= e1000e_get_phy_info_igp,\n\t.read_reg\t\t= e1000e_read_phy_reg_igp,\n\t.release\t\t= e1000_put_hw_semaphore_82571,\n\t.reset\t\t\t= e1000e_phy_hw_reset_generic,\n\t.set_d0_lplu_state\t= e1000_set_d0_lplu_state_82571,\n\t.set_d3_lplu_state\t= e1000e_set_d3_lplu_state,\n\t.write_reg\t\t= e1000e_write_phy_reg_igp,\n\t.cfg_on_link_up\t\t= NULL,\n};\n\nstatic const struct e1000_phy_operations e82_phy_ops_m88 = {\n\t.acquire\t\t= e1000_get_hw_semaphore_82571,\n\t.check_polarity\t\t= e1000_check_polarity_m88,\n\t.check_reset_block\t= e1000e_check_reset_block_generic,\n\t.commit\t\t\t= e1000e_phy_sw_reset,\n\t.force_speed_duplex\t= e1000e_phy_force_speed_duplex_m88,\n\t.get_cfg_done\t\t= e1000e_get_cfg_done_generic,\n\t.get_cable_length\t= e1000e_get_cable_length_m88,\n\t.get_info\t\t= e1000e_get_phy_info_m88,\n\t.read_reg\t\t= e1000e_read_phy_reg_m88,\n\t.release\t\t= e1000_put_hw_semaphore_82571,\n\t.reset\t\t\t= e1000e_phy_hw_reset_generic,\n\t.set_d0_lplu_state\t= e1000_set_d0_lplu_state_82571,\n\t.set_d3_lplu_state\t= e1000e_set_d3_lplu_state,\n\t.write_reg\t\t= e1000e_write_phy_reg_m88,\n\t.cfg_on_link_up\t\t= NULL,\n};\n\nstatic const struct e1000_phy_operations e82_phy_ops_bm = {\n\t.acquire\t\t= e1000_get_hw_semaphore_82571,\n\t.check_polarity\t\t= e1000_check_polarity_m88,\n\t.check_reset_block\t= e1000e_check_reset_block_generic,\n\t.commit\t\t\t= e1000e_phy_sw_reset,\n\t.force_speed_duplex\t= e1000e_phy_force_speed_duplex_m88,\n\t.get_cfg_done\t\t= e1000e_get_cfg_done_generic,\n\t.get_cable_length\t= e1000e_get_cable_length_m88,\n\t.get_info\t\t= e1000e_get_phy_info_m88,\n\t.read_reg\t\t= e1000e_read_phy_reg_bm2,\n\t.release\t\t= e1000_put_hw_semaphore_82571,\n\t.reset\t\t\t= e1000e_phy_hw_reset_generic,\n\t.set_d0_lplu_state\t= e1000_set_d0_lplu_state_82571,\n\t.set_d3_lplu_state\t= e1000e_set_d3_lplu_state,\n\t.write_reg\t\t= e1000e_write_phy_reg_bm2,\n\t.cfg_on_link_up\t\t= NULL,\n};\n\nstatic const struct e1000_nvm_operations e82571_nvm_ops = {\n\t.acquire\t\t= e1000_acquire_nvm_82571,\n\t.read\t\t\t= e1000e_read_nvm_eerd,\n\t.release\t\t= e1000_release_nvm_82571,\n\t.reload\t\t\t= e1000e_reload_nvm_generic,\n\t.update\t\t\t= e1000_update_nvm_checksum_82571,\n\t.valid_led_default\t= e1000_valid_led_default_82571,\n\t.validate\t\t= e1000_validate_nvm_checksum_82571,\n\t.write\t\t\t= e1000_write_nvm_82571,\n};\n\nconst struct e1000_info e1000_82571_info = {\n\t.mac\t\t\t= e1000_82571,\n\t.flags\t\t\t= FLAG_HAS_HW_VLAN_FILTER\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_APME_IN_CTRL3\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_SMART_POWER_DOWN\n\t\t\t\t  | FLAG_RESET_OVERWRITES_LAA  \n\t\t\t\t  | FLAG_TARC_SPEED_MODE_BIT  \n\t\t\t\t  | FLAG_APME_CHECK_PORT_B,\n\t.flags2\t\t\t= FLAG2_DISABLE_ASPM_L1  \n\t\t\t\t  | FLAG2_DMA_BURST,\n\t.pba\t\t\t= 38,\n\t.max_hw_frame_size\t= DEFAULT_JUMBO,\n\t.get_variants\t\t= e1000_get_variants_82571,\n\t.mac_ops\t\t= &e82571_mac_ops,\n\t.phy_ops\t\t= &e82_phy_ops_igp,\n\t.nvm_ops\t\t= &e82571_nvm_ops,\n};\n\nconst struct e1000_info e1000_82572_info = {\n\t.mac\t\t\t= e1000_82572,\n\t.flags\t\t\t= FLAG_HAS_HW_VLAN_FILTER\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_APME_IN_CTRL3\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_TARC_SPEED_MODE_BIT,  \n\t.flags2\t\t\t= FLAG2_DISABLE_ASPM_L1  \n\t\t\t\t  | FLAG2_DMA_BURST,\n\t.pba\t\t\t= 38,\n\t.max_hw_frame_size\t= DEFAULT_JUMBO,\n\t.get_variants\t\t= e1000_get_variants_82571,\n\t.mac_ops\t\t= &e82571_mac_ops,\n\t.phy_ops\t\t= &e82_phy_ops_igp,\n\t.nvm_ops\t\t= &e82571_nvm_ops,\n};\n\nconst struct e1000_info e1000_82573_info = {\n\t.mac\t\t\t= e1000_82573,\n\t.flags\t\t\t= FLAG_HAS_HW_VLAN_FILTER\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_APME_IN_CTRL3\n\t\t\t\t  | FLAG_HAS_SMART_POWER_DOWN\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_SWSM_ON_LOAD,\n\t.flags2\t\t\t= FLAG2_DISABLE_ASPM_L1\n\t\t\t\t  | FLAG2_DISABLE_ASPM_L0S,\n\t.pba\t\t\t= 20,\n\t.max_hw_frame_size\t= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,\n\t.get_variants\t\t= e1000_get_variants_82571,\n\t.mac_ops\t\t= &e82571_mac_ops,\n\t.phy_ops\t\t= &e82_phy_ops_m88,\n\t.nvm_ops\t\t= &e82571_nvm_ops,\n};\n\nconst struct e1000_info e1000_82574_info = {\n\t.mac\t\t\t= e1000_82574,\n\t.flags\t\t\t= FLAG_HAS_HW_VLAN_FILTER\n\t\t\t\t  | FLAG_HAS_MSIX\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_APME_IN_CTRL3\n\t\t\t\t  | FLAG_HAS_SMART_POWER_DOWN\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD,\n\t.flags2\t\t\t = FLAG2_CHECK_PHY_HANG\n\t\t\t\t  | FLAG2_DISABLE_ASPM_L0S\n\t\t\t\t  | FLAG2_DISABLE_ASPM_L1\n\t\t\t\t  | FLAG2_NO_DISABLE_RX\n\t\t\t\t  | FLAG2_DMA_BURST\n\t\t\t\t  | FLAG2_CHECK_SYSTIM_OVERFLOW,\n\t.pba\t\t\t= 32,\n\t.max_hw_frame_size\t= DEFAULT_JUMBO,\n\t.get_variants\t\t= e1000_get_variants_82571,\n\t.mac_ops\t\t= &e82571_mac_ops,\n\t.phy_ops\t\t= &e82_phy_ops_bm,\n\t.nvm_ops\t\t= &e82571_nvm_ops,\n};\n\nconst struct e1000_info e1000_82583_info = {\n\t.mac\t\t\t= e1000_82583,\n\t.flags\t\t\t= FLAG_HAS_HW_VLAN_FILTER\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_APME_IN_CTRL3\n\t\t\t\t  | FLAG_HAS_SMART_POWER_DOWN\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD,\n\t.flags2\t\t\t= FLAG2_DISABLE_ASPM_L0S\n\t\t\t\t  | FLAG2_DISABLE_ASPM_L1\n\t\t\t\t  | FLAG2_NO_DISABLE_RX\n\t\t\t\t  | FLAG2_CHECK_SYSTIM_OVERFLOW,\n\t.pba\t\t\t= 32,\n\t.max_hw_frame_size\t= DEFAULT_JUMBO,\n\t.get_variants\t\t= e1000_get_variants_82571,\n\t.mac_ops\t\t= &e82571_mac_ops,\n\t.phy_ops\t\t= &e82_phy_ops_bm,\n\t.nvm_ops\t\t= &e82571_nvm_ops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}