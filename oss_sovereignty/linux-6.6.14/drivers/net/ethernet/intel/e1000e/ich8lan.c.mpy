{
  "module_name": "ich8lan.c",
  "hash_id": "dc6a1084340f9d24e6b745eba312cdb68897aeae20fde14c7fee8418aa09a127",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/ich8lan.c",
  "human_readable_source": "\n \n\n \n\n#include \"e1000.h\"\n\n \n \nunion ich8_hws_flash_status {\n\tstruct ich8_hsfsts {\n\t\tu16 flcdone:1;\t \n\t\tu16 flcerr:1;\t \n\t\tu16 dael:1;\t \n\t\tu16 berasesz:2;\t \n\t\tu16 flcinprog:1;\t \n\t\tu16 reserved1:2;\t \n\t\tu16 reserved2:6;\t \n\t\tu16 fldesvalid:1;\t \n\t\tu16 flockdn:1;\t \n\t} hsf_status;\n\tu16 regval;\n};\n\n \n \nunion ich8_hws_flash_ctrl {\n\tstruct ich8_hsflctl {\n\t\tu16 flcgo:1;\t \n\t\tu16 flcycle:2;\t \n\t\tu16 reserved:5;\t \n\t\tu16 fldbcount:2;\t \n\t\tu16 flockdn:6;\t \n\t} hsf_ctrl;\n\tu16 regval;\n};\n\n \nunion ich8_hws_flash_regacc {\n\tstruct ich8_flracc {\n\t\tu32 grra:8;\t \n\t\tu32 grwa:8;\t \n\t\tu32 gmrag:8;\t \n\t\tu32 gmwag:8;\t \n\t} hsf_flregacc;\n\tu16 regval;\n};\n\n \nunion ich8_flash_protected_range {\n\tstruct ich8_pr {\n\t\tu32 base:13;\t \n\t\tu32 reserved1:2;\t \n\t\tu32 rpe:1;\t \n\t\tu32 limit:13;\t \n\t\tu32 reserved2:2;\t \n\t\tu32 wpe:1;\t \n\t} range;\n\tu32 regval;\n};\n\nstatic void e1000_clear_hw_cntrs_ich8lan(struct e1000_hw *hw);\nstatic void e1000_initialize_hw_bits_ich8lan(struct e1000_hw *hw);\nstatic s32 e1000_erase_flash_bank_ich8lan(struct e1000_hw *hw, u32 bank);\nstatic s32 e1000_retry_write_flash_byte_ich8lan(struct e1000_hw *hw,\n\t\t\t\t\t\tu32 offset, u8 byte);\nstatic s32 e1000_read_flash_byte_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t u8 *data);\nstatic s32 e1000_read_flash_word_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t u16 *data);\nstatic s32 e1000_read_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t u8 size, u16 *data);\nstatic s32 e1000_read_flash_data32_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t   u32 *data);\nstatic s32 e1000_read_flash_dword_ich8lan(struct e1000_hw *hw,\n\t\t\t\t\t  u32 offset, u32 *data);\nstatic s32 e1000_write_flash_data32_ich8lan(struct e1000_hw *hw,\n\t\t\t\t\t    u32 offset, u32 data);\nstatic s32 e1000_retry_write_flash_dword_ich8lan(struct e1000_hw *hw,\n\t\t\t\t\t\t u32 offset, u32 dword);\nstatic s32 e1000_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw);\nstatic s32 e1000_cleanup_led_ich8lan(struct e1000_hw *hw);\nstatic s32 e1000_led_on_ich8lan(struct e1000_hw *hw);\nstatic s32 e1000_led_off_ich8lan(struct e1000_hw *hw);\nstatic s32 e1000_id_led_init_pchlan(struct e1000_hw *hw);\nstatic s32 e1000_setup_led_pchlan(struct e1000_hw *hw);\nstatic s32 e1000_cleanup_led_pchlan(struct e1000_hw *hw);\nstatic s32 e1000_led_on_pchlan(struct e1000_hw *hw);\nstatic s32 e1000_led_off_pchlan(struct e1000_hw *hw);\nstatic s32 e1000_set_lplu_state_pchlan(struct e1000_hw *hw, bool active);\nstatic void e1000_power_down_phy_copper_ich8lan(struct e1000_hw *hw);\nstatic void e1000_lan_init_done_ich8lan(struct e1000_hw *hw);\nstatic s32 e1000_k1_gig_workaround_hv(struct e1000_hw *hw, bool link);\nstatic s32 e1000_set_mdio_slow_mode_hv(struct e1000_hw *hw);\nstatic bool e1000_check_mng_mode_ich8lan(struct e1000_hw *hw);\nstatic bool e1000_check_mng_mode_pchlan(struct e1000_hw *hw);\nstatic int e1000_rar_set_pch2lan(struct e1000_hw *hw, u8 *addr, u32 index);\nstatic int e1000_rar_set_pch_lpt(struct e1000_hw *hw, u8 *addr, u32 index);\nstatic u32 e1000_rar_get_count_pch_lpt(struct e1000_hw *hw);\nstatic s32 e1000_k1_workaround_lv(struct e1000_hw *hw);\nstatic void e1000_gate_hw_phy_config_ich8lan(struct e1000_hw *hw, bool gate);\nstatic s32 e1000_disable_ulp_lpt_lp(struct e1000_hw *hw, bool force);\nstatic s32 e1000_setup_copper_link_pch_lpt(struct e1000_hw *hw);\nstatic s32 e1000_oem_bits_config_ich8lan(struct e1000_hw *hw, bool d0_state);\n\nstatic inline u16 __er16flash(struct e1000_hw *hw, unsigned long reg)\n{\n\treturn readw(hw->flash_address + reg);\n}\n\nstatic inline u32 __er32flash(struct e1000_hw *hw, unsigned long reg)\n{\n\treturn readl(hw->flash_address + reg);\n}\n\nstatic inline void __ew16flash(struct e1000_hw *hw, unsigned long reg, u16 val)\n{\n\twritew(val, hw->flash_address + reg);\n}\n\nstatic inline void __ew32flash(struct e1000_hw *hw, unsigned long reg, u32 val)\n{\n\twritel(val, hw->flash_address + reg);\n}\n\n#define er16flash(reg)\t\t__er16flash(hw, (reg))\n#define er32flash(reg)\t\t__er32flash(hw, (reg))\n#define ew16flash(reg, val)\t__ew16flash(hw, (reg), (val))\n#define ew32flash(reg, val)\t__ew32flash(hw, (reg), (val))\n\n \nstatic bool e1000_phy_is_accessible_pchlan(struct e1000_hw *hw)\n{\n\tu16 phy_reg = 0;\n\tu32 phy_id = 0;\n\ts32 ret_val = 0;\n\tu16 retry_count;\n\tu32 mac_reg = 0;\n\n\tfor (retry_count = 0; retry_count < 2; retry_count++) {\n\t\tret_val = e1e_rphy_locked(hw, MII_PHYSID1, &phy_reg);\n\t\tif (ret_val || (phy_reg == 0xFFFF))\n\t\t\tcontinue;\n\t\tphy_id = (u32)(phy_reg << 16);\n\n\t\tret_val = e1e_rphy_locked(hw, MII_PHYSID2, &phy_reg);\n\t\tif (ret_val || (phy_reg == 0xFFFF)) {\n\t\t\tphy_id = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tphy_id |= (u32)(phy_reg & PHY_REVISION_MASK);\n\t\tbreak;\n\t}\n\n\tif (hw->phy.id) {\n\t\tif (hw->phy.id == phy_id)\n\t\t\tgoto out;\n\t} else if (phy_id) {\n\t\thw->phy.id = phy_id;\n\t\thw->phy.revision = (u32)(phy_reg & ~PHY_REVISION_MASK);\n\t\tgoto out;\n\t}\n\n\t \n\tif (hw->mac.type < e1000_pch_lpt) {\n\t\thw->phy.ops.release(hw);\n\t\tret_val = e1000_set_mdio_slow_mode_hv(hw);\n\t\tif (!ret_val)\n\t\t\tret_val = e1000e_get_phy_id(hw);\n\t\thw->phy.ops.acquire(hw);\n\t}\n\n\tif (ret_val)\n\t\treturn false;\nout:\n\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\t \n\t\tif (!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID)) {\n\t\t\t \n\t\t\te1e_rphy_locked(hw, CV_SMB_CTRL, &phy_reg);\n\t\t\tphy_reg &= ~CV_SMB_CTRL_FORCE_SMBUS;\n\t\t\te1e_wphy_locked(hw, CV_SMB_CTRL, phy_reg);\n\n\t\t\t \n\t\t\tmac_reg = er32(CTRL_EXT);\n\t\t\tmac_reg &= ~E1000_CTRL_EXT_FORCE_SMBUS;\n\t\t\tew32(CTRL_EXT, mac_reg);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic void e1000_toggle_lanphypc_pch_lpt(struct e1000_hw *hw)\n{\n\tu32 mac_reg;\n\n\t \n\tmac_reg = er32(FEXTNVM3);\n\tmac_reg &= ~E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK;\n\tmac_reg |= E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC;\n\tew32(FEXTNVM3, mac_reg);\n\n\t \n\tmac_reg = er32(CTRL);\n\tmac_reg |= E1000_CTRL_LANPHYPC_OVERRIDE;\n\tmac_reg &= ~E1000_CTRL_LANPHYPC_VALUE;\n\tew32(CTRL, mac_reg);\n\te1e_flush();\n\tusleep_range(10, 20);\n\tmac_reg &= ~E1000_CTRL_LANPHYPC_OVERRIDE;\n\tew32(CTRL, mac_reg);\n\te1e_flush();\n\n\tif (hw->mac.type < e1000_pch_lpt) {\n\t\tmsleep(50);\n\t} else {\n\t\tu16 count = 20;\n\n\t\tdo {\n\t\t\tusleep_range(5000, 6000);\n\t\t} while (!(er32(CTRL_EXT) & E1000_CTRL_EXT_LPCD) && count--);\n\n\t\tmsleep(30);\n\t}\n}\n\n \nstatic s32 e1000_init_phy_workarounds_pchlan(struct e1000_hw *hw)\n{\n\tstruct e1000_adapter *adapter = hw->adapter;\n\tu32 mac_reg, fwsm = er32(FWSM);\n\ts32 ret_val;\n\n\t \n\te1000_gate_hw_phy_config_ich8lan(hw, true);\n\n\t \n\thw->dev_spec.ich8lan.ulp_state = e1000_ulp_state_unknown;\n\tret_val = e1000_disable_ulp_lpt_lp(hw, true);\n\tif (ret_val)\n\t\te_warn(\"Failed to disable ULP\\n\");\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Failed to initialize PHY flow\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tif (e1000_phy_is_accessible_pchlan(hw))\n\t\t\tbreak;\n\n\t\t \n\t\tmac_reg = er32(CTRL_EXT);\n\t\tmac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;\n\t\tew32(CTRL_EXT, mac_reg);\n\n\t\t \n\t\tmsleep(50);\n\n\t\tfallthrough;\n\tcase e1000_pch2lan:\n\t\tif (e1000_phy_is_accessible_pchlan(hw))\n\t\t\tbreak;\n\n\t\tfallthrough;\n\tcase e1000_pchlan:\n\t\tif ((hw->mac.type == e1000_pchlan) &&\n\t\t    (fwsm & E1000_ICH_FWSM_FW_VALID))\n\t\t\tbreak;\n\n\t\tif (hw->phy.ops.check_reset_block(hw)) {\n\t\t\te_dbg(\"Required LANPHYPC toggle blocked by ME\\n\");\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\te1000_toggle_lanphypc_pch_lpt(hw);\n\t\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\t\tif (e1000_phy_is_accessible_pchlan(hw))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmac_reg = er32(CTRL_EXT);\n\t\t\tmac_reg &= ~E1000_CTRL_EXT_FORCE_SMBUS;\n\t\t\tew32(CTRL_EXT, mac_reg);\n\n\t\t\tif (e1000_phy_is_accessible_pchlan(hw))\n\t\t\t\tbreak;\n\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\thw->phy.ops.release(hw);\n\tif (!ret_val) {\n\n\t\t \n\t\tif (hw->phy.ops.check_reset_block(hw)) {\n\t\t\te_err(\"Reset blocked by ME\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret_val = e1000e_phy_hw_reset_generic(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tret_val = hw->phy.ops.check_reset_block(hw);\n\t\tif (ret_val)\n\t\t\te_err(\"ME blocked access to PHY after reset\\n\");\n\t}\n\nout:\n\t \n\tif ((hw->mac.type == e1000_pch2lan) &&\n\t    !(fwsm & E1000_ICH_FWSM_FW_VALID)) {\n\t\tusleep_range(10000, 11000);\n\t\te1000_gate_hw_phy_config_ich8lan(hw, false);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_init_phy_params_pchlan(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\n\tphy->addr = 1;\n\tphy->reset_delay_us = 100;\n\n\tphy->ops.set_page = e1000_set_page_igp;\n\tphy->ops.read_reg = e1000_read_phy_reg_hv;\n\tphy->ops.read_reg_locked = e1000_read_phy_reg_hv_locked;\n\tphy->ops.read_reg_page = e1000_read_phy_reg_page_hv;\n\tphy->ops.set_d0_lplu_state = e1000_set_lplu_state_pchlan;\n\tphy->ops.set_d3_lplu_state = e1000_set_lplu_state_pchlan;\n\tphy->ops.write_reg = e1000_write_phy_reg_hv;\n\tphy->ops.write_reg_locked = e1000_write_phy_reg_hv_locked;\n\tphy->ops.write_reg_page = e1000_write_phy_reg_page_hv;\n\tphy->ops.power_up = e1000_power_up_phy_copper;\n\tphy->ops.power_down = e1000_power_down_phy_copper_ich8lan;\n\tphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\n\tphy->id = e1000_phy_unknown;\n\n\tret_val = e1000_init_phy_workarounds_pchlan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (phy->id == e1000_phy_unknown)\n\t\tswitch (hw->mac.type) {\n\t\tdefault:\n\t\t\tret_val = e1000e_get_phy_id(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tif ((phy->id != 0) && (phy->id != PHY_REVISION_MASK))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase e1000_pch2lan:\n\t\tcase e1000_pch_lpt:\n\t\tcase e1000_pch_spt:\n\t\tcase e1000_pch_cnp:\n\t\tcase e1000_pch_tgp:\n\t\tcase e1000_pch_adp:\n\t\tcase e1000_pch_mtp:\n\t\tcase e1000_pch_lnp:\n\t\tcase e1000_pch_ptp:\n\t\tcase e1000_pch_nvp:\n\t\t\t \n\t\t\tret_val = e1000_set_mdio_slow_mode_hv(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tret_val = e1000e_get_phy_id(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tbreak;\n\t\t}\n\tphy->type = e1000e_get_phy_type_from_id(phy->id);\n\n\tswitch (phy->type) {\n\tcase e1000_phy_82577:\n\tcase e1000_phy_82579:\n\tcase e1000_phy_i217:\n\t\tphy->ops.check_polarity = e1000_check_polarity_82577;\n\t\tphy->ops.force_speed_duplex =\n\t\t    e1000_phy_force_speed_duplex_82577;\n\t\tphy->ops.get_cable_length = e1000_get_cable_length_82577;\n\t\tphy->ops.get_info = e1000_get_phy_info_82577;\n\t\tphy->ops.commit = e1000e_phy_sw_reset;\n\t\tbreak;\n\tcase e1000_phy_82578:\n\t\tphy->ops.check_polarity = e1000_check_polarity_m88;\n\t\tphy->ops.force_speed_duplex = e1000e_phy_force_speed_duplex_m88;\n\t\tphy->ops.get_cable_length = e1000e_get_cable_length_m88;\n\t\tphy->ops.get_info = e1000e_get_phy_info_m88;\n\t\tbreak;\n\tdefault:\n\t\tret_val = -E1000_ERR_PHY;\n\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_init_phy_params_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 i = 0;\n\n\tphy->addr = 1;\n\tphy->reset_delay_us = 100;\n\n\tphy->ops.power_up = e1000_power_up_phy_copper;\n\tphy->ops.power_down = e1000_power_down_phy_copper_ich8lan;\n\n\t \n\tret_val = e1000e_determine_phy_address(hw);\n\tif (ret_val) {\n\t\tphy->ops.write_reg = e1000e_write_phy_reg_bm;\n\t\tphy->ops.read_reg = e1000e_read_phy_reg_bm;\n\t\tret_val = e1000e_determine_phy_address(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Cannot determine PHY addr. Erroring out\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\tphy->id = 0;\n\twhile ((e1000_phy_unknown == e1000e_get_phy_type_from_id(phy->id)) &&\n\t       (i++ < 100)) {\n\t\tusleep_range(1000, 1100);\n\t\tret_val = e1000e_get_phy_id(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tswitch (phy->id) {\n\tcase IGP03E1000_E_PHY_ID:\n\t\tphy->type = e1000_phy_igp_3;\n\t\tphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\t\tphy->ops.read_reg_locked = e1000e_read_phy_reg_igp_locked;\n\t\tphy->ops.write_reg_locked = e1000e_write_phy_reg_igp_locked;\n\t\tphy->ops.get_info = e1000e_get_phy_info_igp;\n\t\tphy->ops.check_polarity = e1000_check_polarity_igp;\n\t\tphy->ops.force_speed_duplex = e1000e_phy_force_speed_duplex_igp;\n\t\tbreak;\n\tcase IFE_E_PHY_ID:\n\tcase IFE_PLUS_E_PHY_ID:\n\tcase IFE_C_E_PHY_ID:\n\t\tphy->type = e1000_phy_ife;\n\t\tphy->autoneg_mask = E1000_ALL_NOT_GIG;\n\t\tphy->ops.get_info = e1000_get_phy_info_ife;\n\t\tphy->ops.check_polarity = e1000_check_polarity_ife;\n\t\tphy->ops.force_speed_duplex = e1000_phy_force_speed_duplex_ife;\n\t\tbreak;\n\tcase BME1000_E_PHY_ID:\n\t\tphy->type = e1000_phy_bm;\n\t\tphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\t\tphy->ops.read_reg = e1000e_read_phy_reg_bm;\n\t\tphy->ops.write_reg = e1000e_write_phy_reg_bm;\n\t\tphy->ops.commit = e1000e_phy_sw_reset;\n\t\tphy->ops.get_info = e1000e_get_phy_info_m88;\n\t\tphy->ops.check_polarity = e1000_check_polarity_m88;\n\t\tphy->ops.force_speed_duplex = e1000e_phy_force_speed_duplex_m88;\n\t\tbreak;\n\tdefault:\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_init_nvm_params_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu32 gfpreg, sector_base_addr, sector_end_addr;\n\tu16 i;\n\tu32 nvm_size;\n\n\tnvm->type = e1000_nvm_flash_sw;\n\n\tif (hw->mac.type >= e1000_pch_spt) {\n\t\t \n\t\tnvm->flash_base_addr = 0;\n\t\tnvm_size = (((er32(STRAP) >> 1) & 0x1F) + 1)\n\t\t    * NVM_SIZE_MULTIPLIER;\n\t\tnvm->flash_bank_size = nvm_size / 2;\n\t\t \n\t\tnvm->flash_bank_size /= sizeof(u16);\n\t\t \n\t\thw->flash_address = hw->hw_addr + E1000_FLASH_BASE_ADDR;\n\t} else {\n\t\t \n\t\tif (!hw->flash_address) {\n\t\t\te_dbg(\"ERROR: Flash registers not mapped\\n\");\n\t\t\treturn -E1000_ERR_CONFIG;\n\t\t}\n\n\t\tgfpreg = er32flash(ICH_FLASH_GFPREG);\n\n\t\t \n\t\tsector_base_addr = gfpreg & FLASH_GFPREG_BASE_MASK;\n\t\tsector_end_addr = ((gfpreg >> 16) & FLASH_GFPREG_BASE_MASK) + 1;\n\n\t\t \n\t\tnvm->flash_base_addr = sector_base_addr\n\t\t    << FLASH_SECTOR_ADDR_SHIFT;\n\n\t\t \n\t\tnvm->flash_bank_size = ((sector_end_addr - sector_base_addr)\n\t\t\t\t\t<< FLASH_SECTOR_ADDR_SHIFT);\n\t\tnvm->flash_bank_size /= 2;\n\t\t \n\t\tnvm->flash_bank_size /= sizeof(u16);\n\t}\n\n\tnvm->word_size = E1000_ICH8_SHADOW_RAM_WORDS;\n\n\t \n\tfor (i = 0; i < nvm->word_size; i++) {\n\t\tdev_spec->shadow_ram[i].modified = false;\n\t\tdev_spec->shadow_ram[i].value = 0xFFFF;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_init_mac_params_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\n\t \n\thw->phy.media_type = e1000_media_type_copper;\n\n\t \n\tmac->mta_reg_count = 32;\n\t \n\tmac->rar_entry_count = E1000_ICH_RAR_ENTRIES;\n\tif (mac->type == e1000_ich8lan)\n\t\tmac->rar_entry_count--;\n\t \n\tmac->has_fwsm = true;\n\t \n\tmac->arc_subsystem_valid = false;\n\t \n\tmac->adaptive_ifs = true;\n\n\t \n\tswitch (mac->type) {\n\tcase e1000_ich8lan:\n\tcase e1000_ich9lan:\n\tcase e1000_ich10lan:\n\t\t \n\t\tmac->ops.check_mng_mode = e1000_check_mng_mode_ich8lan;\n\t\t \n\t\tmac->ops.id_led_init = e1000e_id_led_init_generic;\n\t\t \n\t\tmac->ops.blink_led = e1000e_blink_led_generic;\n\t\t \n\t\tmac->ops.setup_led = e1000e_setup_led_generic;\n\t\t \n\t\tmac->ops.cleanup_led = e1000_cleanup_led_ich8lan;\n\t\t \n\t\tmac->ops.led_on = e1000_led_on_ich8lan;\n\t\tmac->ops.led_off = e1000_led_off_ich8lan;\n\t\tbreak;\n\tcase e1000_pch2lan:\n\t\tmac->rar_entry_count = E1000_PCH2_RAR_ENTRIES;\n\t\tmac->ops.rar_set = e1000_rar_set_pch2lan;\n\t\tfallthrough;\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\tcase e1000_pchlan:\n\t\t \n\t\tmac->ops.check_mng_mode = e1000_check_mng_mode_pchlan;\n\t\t \n\t\tmac->ops.id_led_init = e1000_id_led_init_pchlan;\n\t\t \n\t\tmac->ops.setup_led = e1000_setup_led_pchlan;\n\t\t \n\t\tmac->ops.cleanup_led = e1000_cleanup_led_pchlan;\n\t\t \n\t\tmac->ops.led_on = e1000_led_on_pchlan;\n\t\tmac->ops.led_off = e1000_led_off_pchlan;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (mac->type >= e1000_pch_lpt) {\n\t\tmac->rar_entry_count = E1000_PCH_LPT_RAR_ENTRIES;\n\t\tmac->ops.rar_set = e1000_rar_set_pch_lpt;\n\t\tmac->ops.setup_physical_interface =\n\t\t    e1000_setup_copper_link_pch_lpt;\n\t\tmac->ops.rar_get_count = e1000_rar_get_count_pch_lpt;\n\t}\n\n\t \n\tif (mac->type == e1000_ich8lan)\n\t\te1000e_set_kmrn_lock_loss_workaround_ich8lan(hw, true);\n\n\treturn 0;\n}\n\n \nstatic s32 __e1000_access_emi_reg_locked(struct e1000_hw *hw, u16 address,\n\t\t\t\t\t u16 *data, bool read)\n{\n\ts32 ret_val;\n\n\tret_val = e1e_wphy_locked(hw, I82579_EMI_ADDR, address);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (read)\n\t\tret_val = e1e_rphy_locked(hw, I82579_EMI_DATA, data);\n\telse\n\t\tret_val = e1e_wphy_locked(hw, I82579_EMI_DATA, *data);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_read_emi_reg_locked(struct e1000_hw *hw, u16 addr, u16 *data)\n{\n\treturn __e1000_access_emi_reg_locked(hw, addr, data, true);\n}\n\n \ns32 e1000_write_emi_reg_locked(struct e1000_hw *hw, u16 addr, u16 data)\n{\n\treturn __e1000_access_emi_reg_locked(hw, addr, &data, false);\n}\n\n \ns32 e1000_set_eee_pchlan(struct e1000_hw *hw)\n{\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\ts32 ret_val;\n\tu16 lpa, pcs_status, adv, adv_addr, lpi_ctrl, data;\n\n\tswitch (hw->phy.type) {\n\tcase e1000_phy_82579:\n\t\tlpa = I82579_EEE_LP_ABILITY;\n\t\tpcs_status = I82579_EEE_PCS_STATUS;\n\t\tadv_addr = I82579_EEE_ADVERTISEMENT;\n\t\tbreak;\n\tcase e1000_phy_i217:\n\t\tlpa = I217_EEE_LP_ABILITY;\n\t\tpcs_status = I217_EEE_PCS_STATUS;\n\t\tadv_addr = I217_EEE_ADVERTISEMENT;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1e_rphy_locked(hw, I82579_LPI_CTRL, &lpi_ctrl);\n\tif (ret_val)\n\t\tgoto release;\n\n\t \n\tlpi_ctrl &= ~I82579_LPI_CTRL_ENABLE_MASK;\n\n\t \n\tif (!dev_spec->eee_disable) {\n\t\t \n\t\tret_val = e1000_read_emi_reg_locked(hw, lpa,\n\t\t\t\t\t\t    &dev_spec->eee_lp_ability);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\t \n\t\tret_val = e1000_read_emi_reg_locked(hw, adv_addr, &adv);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\t \n\t\tif (adv & dev_spec->eee_lp_ability & I82579_EEE_1000_SUPPORTED)\n\t\t\tlpi_ctrl |= I82579_LPI_CTRL_1000_ENABLE;\n\n\t\tif (adv & dev_spec->eee_lp_ability & I82579_EEE_100_SUPPORTED) {\n\t\t\te1e_rphy_locked(hw, MII_LPA, &data);\n\t\t\tif (data & LPA_100FULL)\n\t\t\t\tlpi_ctrl |= I82579_LPI_CTRL_100_ENABLE;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tdev_spec->eee_lp_ability &=\n\t\t\t\t    ~I82579_EEE_100_SUPPORTED;\n\t\t}\n\t}\n\n\tif (hw->phy.type == e1000_phy_82579) {\n\t\tret_val = e1000_read_emi_reg_locked(hw, I82579_LPI_PLL_SHUT,\n\t\t\t\t\t\t    &data);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\tdata &= ~I82579_LPI_100_PLL_SHUT;\n\t\tret_val = e1000_write_emi_reg_locked(hw, I82579_LPI_PLL_SHUT,\n\t\t\t\t\t\t     data);\n\t}\n\n\t \n\tret_val = e1000_read_emi_reg_locked(hw, pcs_status, &data);\n\tif (ret_val)\n\t\tgoto release;\n\n\tret_val = e1e_wphy_locked(hw, I82579_LPI_CTRL, lpi_ctrl);\nrelease:\n\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_k1_workaround_lpt_lp(struct e1000_hw *hw, bool link)\n{\n\tu32 fextnvm6 = er32(FEXTNVM6);\n\tu32 status = er32(STATUS);\n\ts32 ret_val = 0;\n\tu16 reg;\n\n\tif (link && (status & E1000_STATUS_SPEED_1000)) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val =\n\t\t    e1000e_read_kmrn_reg_locked(hw, E1000_KMRNCTRLSTA_K1_CONFIG,\n\t\t\t\t\t\t&reg);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\tret_val =\n\t\t    e1000e_write_kmrn_reg_locked(hw,\n\t\t\t\t\t\t E1000_KMRNCTRLSTA_K1_CONFIG,\n\t\t\t\t\t\t reg &\n\t\t\t\t\t\t ~E1000_KMRNCTRLSTA_K1_ENABLE);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\tusleep_range(10, 20);\n\n\t\tew32(FEXTNVM6, fextnvm6 | E1000_FEXTNVM6_REQ_PLL_CLK);\n\n\t\tret_val =\n\t\t    e1000e_write_kmrn_reg_locked(hw,\n\t\t\t\t\t\t E1000_KMRNCTRLSTA_K1_CONFIG,\n\t\t\t\t\t\t reg);\nrelease:\n\t\thw->phy.ops.release(hw);\n\t} else {\n\t\t \n\t\tfextnvm6 &= ~E1000_FEXTNVM6_REQ_PLL_CLK;\n\n\t\tif ((hw->phy.revision > 5) || !link ||\n\t\t    ((status & E1000_STATUS_SPEED_100) &&\n\t\t     (status & E1000_STATUS_FD)))\n\t\t\tgoto update_fextnvm6;\n\n\t\tret_val = e1e_rphy(hw, I217_INBAND_CTRL, &reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\treg &= ~I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_MASK;\n\n\t\tif (status & E1000_STATUS_SPEED_100) {\n\t\t\t \n\t\t\treg |= 5 << I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT;\n\n\t\t\t \n\t\t\tfextnvm6 &= ~E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION;\n\t\t} else {\n\t\t\t \n\t\t\treg |= 50 <<\n\t\t\t    I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT;\n\n\t\t\t \n\t\t\tfextnvm6 |= E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION;\n\t\t}\n\n\t\tret_val = e1e_wphy(hw, I217_INBAND_CTRL, reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\nupdate_fextnvm6:\n\t\tew32(FEXTNVM6, fextnvm6);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_platform_pm_pch_lpt(struct e1000_hw *hw, bool link)\n{\n\tu32 reg = link << (E1000_LTRV_REQ_SHIFT + E1000_LTRV_NOSNOOP_SHIFT) |\n\t    link << E1000_LTRV_REQ_SHIFT | E1000_LTRV_SEND;\n\tu32 max_ltr_enc_d = 0;\t \n\tu32 lat_enc_d = 0;\t \n\tu16 lat_enc = 0;\t \n\n\tif (link) {\n\t\tu16 speed, duplex, scale = 0;\n\t\tu16 max_snoop, max_nosnoop;\n\t\tu16 max_ltr_enc;\t \n\t\tu64 value;\n\t\tu32 rxa;\n\n\t\tif (!hw->adapter->max_frame_size) {\n\t\t\te_dbg(\"max_frame_size not set.\\n\");\n\t\t\treturn -E1000_ERR_CONFIG;\n\t\t}\n\n\t\thw->mac.ops.get_link_up_info(hw, &speed, &duplex);\n\t\tif (!speed) {\n\t\t\te_dbg(\"Speed not set.\\n\");\n\t\t\treturn -E1000_ERR_CONFIG;\n\t\t}\n\n\t\t \n\t\trxa = er32(PBA) & E1000_PBA_RXA_MASK;\n\n\t\t \n\t\trxa *= 512;\n\t\tvalue = (rxa > hw->adapter->max_frame_size) ?\n\t\t\t(rxa - hw->adapter->max_frame_size) * (16000 / speed) :\n\t\t\t0;\n\n\t\twhile (value > PCI_LTR_VALUE_MASK) {\n\t\t\tscale++;\n\t\t\tvalue = DIV_ROUND_UP(value, BIT(5));\n\t\t}\n\t\tif (scale > E1000_LTRV_SCALE_MAX) {\n\t\t\te_dbg(\"Invalid LTR latency scale %d\\n\", scale);\n\t\t\treturn -E1000_ERR_CONFIG;\n\t\t}\n\t\tlat_enc = (u16)((scale << PCI_LTR_SCALE_SHIFT) | value);\n\n\t\t \n\t\tpci_read_config_word(hw->adapter->pdev, E1000_PCI_LTR_CAP_LPT,\n\t\t\t\t     &max_snoop);\n\t\tpci_read_config_word(hw->adapter->pdev,\n\t\t\t\t     E1000_PCI_LTR_CAP_LPT + 2, &max_nosnoop);\n\t\tmax_ltr_enc = max_t(u16, max_snoop, max_nosnoop);\n\n\t\tlat_enc_d = (lat_enc & E1000_LTRV_VALUE_MASK) *\n\t\t\t     (1U << (E1000_LTRV_SCALE_FACTOR *\n\t\t\t     ((lat_enc & E1000_LTRV_SCALE_MASK)\n\t\t\t     >> E1000_LTRV_SCALE_SHIFT)));\n\n\t\tmax_ltr_enc_d = (max_ltr_enc & E1000_LTRV_VALUE_MASK) *\n\t\t\t\t (1U << (E1000_LTRV_SCALE_FACTOR *\n\t\t\t\t ((max_ltr_enc & E1000_LTRV_SCALE_MASK)\n\t\t\t\t >> E1000_LTRV_SCALE_SHIFT)));\n\n\t\tif (lat_enc_d > max_ltr_enc_d)\n\t\t\tlat_enc = max_ltr_enc;\n\t}\n\n\t \n\treg |= lat_enc | (lat_enc << E1000_LTRV_NOSNOOP_SHIFT);\n\tew32(LTRV, reg);\n\n\treturn 0;\n}\n\n \ns32 e1000_enable_ulp_lpt_lp(struct e1000_hw *hw, bool to_sx)\n{\n\tu32 mac_reg;\n\ts32 ret_val = 0;\n\tu16 phy_reg;\n\tu16 oem_reg = 0;\n\n\tif ((hw->mac.type < e1000_pch_lpt) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPT_I217_LM) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPT_I217_V) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_I218_LM2) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_I218_V2) ||\n\t    (hw->dev_spec.ich8lan.ulp_state == e1000_ulp_state_on))\n\t\treturn 0;\n\n\tif (er32(FWSM) & E1000_ICH_FWSM_FW_VALID) {\n\t\t \n\t\tmac_reg = er32(H2ME);\n\t\tmac_reg |= E1000_H2ME_ULP | E1000_H2ME_ENFORCE_SETTINGS;\n\t\tew32(H2ME, mac_reg);\n\n\t\tgoto out;\n\t}\n\n\tif (!to_sx) {\n\t\tint i = 0;\n\n\t\t \n\t\twhile (!(er32(FEXT) & E1000_FEXT_PHY_CABLE_DISCONNECTED)) {\n\t\t\t \n\t\t\tif (er32(STATUS) & E1000_STATUS_LU)\n\t\t\t\treturn -E1000_ERR_PHY;\n\n\t\t\tif (i++ == 100)\n\t\t\t\tbreak;\n\n\t\t\tmsleep(50);\n\t\t}\n\t\te_dbg(\"CABLE_DISCONNECTED %s set after %dmsec\\n\",\n\t\t      (er32(FEXT) &\n\t\t       E1000_FEXT_PHY_CABLE_DISCONNECTED) ? \"\" : \"not\", i * 50);\n\t}\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = e1000_read_phy_reg_hv_locked(hw, CV_SMB_CTRL, &phy_reg);\n\tif (ret_val)\n\t\tgoto release;\n\tphy_reg |= CV_SMB_CTRL_FORCE_SMBUS;\n\te1000_write_phy_reg_hv_locked(hw, CV_SMB_CTRL, phy_reg);\n\n\t \n\tmac_reg = er32(CTRL_EXT);\n\tmac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;\n\tew32(CTRL_EXT, mac_reg);\n\n\t \n\tif ((hw->phy.type == e1000_phy_i217) && (hw->phy.revision == 6)) {\n\t\tret_val = e1000_read_phy_reg_hv_locked(hw, HV_OEM_BITS,\n\t\t\t\t\t\t       &oem_reg);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\tphy_reg = oem_reg;\n\t\tphy_reg |= HV_OEM_BITS_LPLU | HV_OEM_BITS_GBE_DIS;\n\n\t\tret_val = e1000_write_phy_reg_hv_locked(hw, HV_OEM_BITS,\n\t\t\t\t\t\t\tphy_reg);\n\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\t \n\tret_val = e1000_read_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, &phy_reg);\n\tif (ret_val)\n\t\tgoto release;\n\tphy_reg |= (I218_ULP_CONFIG1_RESET_TO_SMBUS |\n\t\t    I218_ULP_CONFIG1_DISABLE_SMB_PERST);\n\tif (to_sx) {\n\t\tif (er32(WUFC) & E1000_WUFC_LNKC)\n\t\t\tphy_reg |= I218_ULP_CONFIG1_WOL_HOST;\n\t\telse\n\t\t\tphy_reg &= ~I218_ULP_CONFIG1_WOL_HOST;\n\n\t\tphy_reg |= I218_ULP_CONFIG1_STICKY_ULP;\n\t\tphy_reg &= ~I218_ULP_CONFIG1_INBAND_EXIT;\n\t} else {\n\t\tphy_reg |= I218_ULP_CONFIG1_INBAND_EXIT;\n\t\tphy_reg &= ~I218_ULP_CONFIG1_STICKY_ULP;\n\t\tphy_reg &= ~I218_ULP_CONFIG1_WOL_HOST;\n\t}\n\te1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);\n\n\t \n\tmac_reg = er32(FEXTNVM7);\n\tmac_reg |= E1000_FEXTNVM7_DISABLE_SMB_PERST;\n\tew32(FEXTNVM7, mac_reg);\n\n\t \n\tphy_reg |= I218_ULP_CONFIG1_START;\n\te1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);\n\n\tif ((hw->phy.type == e1000_phy_i217) && (hw->phy.revision == 6) &&\n\t    to_sx && (er32(STATUS) & E1000_STATUS_LU)) {\n\t\tret_val = e1000_write_phy_reg_hv_locked(hw, HV_OEM_BITS,\n\t\t\t\t\t\t\toem_reg);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\nrelease:\n\thw->phy.ops.release(hw);\nout:\n\tif (ret_val)\n\t\te_dbg(\"Error in ULP enable flow: %d\\n\", ret_val);\n\telse\n\t\thw->dev_spec.ich8lan.ulp_state = e1000_ulp_state_on;\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_disable_ulp_lpt_lp(struct e1000_hw *hw, bool force)\n{\n\ts32 ret_val = 0;\n\tu32 mac_reg;\n\tu16 phy_reg;\n\tint i = 0;\n\n\tif ((hw->mac.type < e1000_pch_lpt) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPT_I217_LM) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPT_I217_V) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_I218_LM2) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_I218_V2) ||\n\t    (hw->dev_spec.ich8lan.ulp_state == e1000_ulp_state_off))\n\t\treturn 0;\n\n\tif (er32(FWSM) & E1000_ICH_FWSM_FW_VALID) {\n\t\tstruct e1000_adapter *adapter = hw->adapter;\n\t\tbool firmware_bug = false;\n\n\t\tif (force) {\n\t\t\t \n\t\t\tmac_reg = er32(H2ME);\n\t\t\tmac_reg &= ~E1000_H2ME_ULP;\n\t\t\tmac_reg |= E1000_H2ME_ENFORCE_SETTINGS;\n\t\t\tew32(H2ME, mac_reg);\n\t\t}\n\n\t\t \n\t\twhile (er32(FWSM) & E1000_FWSM_ULP_CFG_DONE) {\n\t\t\tif (i++ == 250) {\n\t\t\t\tret_val = -E1000_ERR_PHY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (i > 100 && !firmware_bug)\n\t\t\t\tfirmware_bug = true;\n\n\t\t\tusleep_range(10000, 11000);\n\t\t}\n\t\tif (firmware_bug)\n\t\t\te_warn(\"ULP_CONFIG_DONE took %d msec. This is a firmware bug\\n\",\n\t\t\t       i * 10);\n\t\telse\n\t\t\te_dbg(\"ULP_CONFIG_DONE cleared after %d msec\\n\",\n\t\t\t      i * 10);\n\n\t\tif (force) {\n\t\t\tmac_reg = er32(H2ME);\n\t\t\tmac_reg &= ~E1000_H2ME_ENFORCE_SETTINGS;\n\t\t\tew32(H2ME, mac_reg);\n\t\t} else {\n\t\t\t \n\t\t\tmac_reg = er32(H2ME);\n\t\t\tmac_reg &= ~E1000_H2ME_ULP;\n\t\t\tew32(H2ME, mac_reg);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (force)\n\t\t \n\t\te1000_toggle_lanphypc_pch_lpt(hw);\n\n\t \n\tret_val = e1000_read_phy_reg_hv_locked(hw, CV_SMB_CTRL, &phy_reg);\n\tif (ret_val) {\n\t\t \n\t\tmac_reg = er32(CTRL_EXT);\n\t\tmac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;\n\t\tew32(CTRL_EXT, mac_reg);\n\n\t\tmsleep(50);\n\n\t\tret_val = e1000_read_phy_reg_hv_locked(hw, CV_SMB_CTRL,\n\t\t\t\t\t\t       &phy_reg);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\tphy_reg &= ~CV_SMB_CTRL_FORCE_SMBUS;\n\te1000_write_phy_reg_hv_locked(hw, CV_SMB_CTRL, phy_reg);\n\n\t \n\tmac_reg = er32(CTRL_EXT);\n\tmac_reg &= ~E1000_CTRL_EXT_FORCE_SMBUS;\n\tew32(CTRL_EXT, mac_reg);\n\n\t \n\tret_val = e1000_read_phy_reg_hv_locked(hw, HV_PM_CTRL, &phy_reg);\n\tif (ret_val)\n\t\tgoto release;\n\tphy_reg |= HV_PM_CTRL_K1_ENABLE;\n\te1000_write_phy_reg_hv_locked(hw, HV_PM_CTRL, phy_reg);\n\n\t \n\tret_val = e1000_read_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, &phy_reg);\n\tif (ret_val)\n\t\tgoto release;\n\tphy_reg &= ~(I218_ULP_CONFIG1_IND |\n\t\t     I218_ULP_CONFIG1_STICKY_ULP |\n\t\t     I218_ULP_CONFIG1_RESET_TO_SMBUS |\n\t\t     I218_ULP_CONFIG1_WOL_HOST |\n\t\t     I218_ULP_CONFIG1_INBAND_EXIT |\n\t\t     I218_ULP_CONFIG1_EN_ULP_LANPHYPC |\n\t\t     I218_ULP_CONFIG1_DIS_CLR_STICKY_ON_PERST |\n\t\t     I218_ULP_CONFIG1_DISABLE_SMB_PERST);\n\te1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);\n\n\t \n\tphy_reg |= I218_ULP_CONFIG1_START;\n\te1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);\n\n\t \n\tmac_reg = er32(FEXTNVM7);\n\tmac_reg &= ~E1000_FEXTNVM7_DISABLE_SMB_PERST;\n\tew32(FEXTNVM7, mac_reg);\n\nrelease:\n\thw->phy.ops.release(hw);\n\tif (force) {\n\t\te1000_phy_hw_reset(hw);\n\t\tmsleep(50);\n\t}\nout:\n\tif (ret_val)\n\t\te_dbg(\"Error in ULP disable flow: %d\\n\", ret_val);\n\telse\n\t\thw->dev_spec.ich8lan.ulp_state = e1000_ulp_state_off;\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_check_for_copper_link_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val, tipg_reg = 0;\n\tu16 emi_addr, emi_val = 0;\n\tbool link;\n\tu16 phy_reg;\n\n\t \n\tif (!mac->get_link_status)\n\t\treturn 0;\n\tmac->get_link_status = false;\n\n\t \n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (hw->mac.type == e1000_pchlan) {\n\t\tret_val = e1000_k1_gig_workaround_hv(hw, link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif ((hw->mac.type >= e1000_pch2lan) && link) {\n\t\tu16 speed, duplex;\n\n\t\te1000e_get_speed_and_duplex_copper(hw, &speed, &duplex);\n\t\ttipg_reg = er32(TIPG);\n\t\ttipg_reg &= ~E1000_TIPG_IPGT_MASK;\n\n\t\tif (duplex == HALF_DUPLEX && speed == SPEED_10) {\n\t\t\ttipg_reg |= 0xFF;\n\t\t\t \n\t\t\temi_val = 0;\n\t\t} else if (hw->mac.type >= e1000_pch_spt &&\n\t\t\t   duplex == FULL_DUPLEX && speed != SPEED_1000) {\n\t\t\ttipg_reg |= 0xC;\n\t\t\temi_val = 1;\n\t\t} else {\n\n\t\t\t \n\t\t\ttipg_reg |= 0x08;\n\t\t\temi_val = 1;\n\t\t}\n\n\t\tew32(TIPG, tipg_reg);\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (hw->mac.type == e1000_pch2lan)\n\t\t\temi_addr = I82579_RX_CONFIG;\n\t\telse\n\t\t\temi_addr = I217_RX_CONFIG;\n\t\tret_val = e1000_write_emi_reg_locked(hw, emi_addr, emi_val);\n\n\t\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\t\tu16 phy_reg;\n\n\t\t\te1e_rphy_locked(hw, I217_PLL_CLOCK_GATE_REG, &phy_reg);\n\t\t\tphy_reg &= ~I217_PLL_CLOCK_GATE_MASK;\n\t\t\tif (speed == SPEED_100 || speed == SPEED_10)\n\t\t\t\tphy_reg |= 0x3E8;\n\t\t\telse\n\t\t\t\tphy_reg |= 0xFA;\n\t\t\te1e_wphy_locked(hw, I217_PLL_CLOCK_GATE_REG, phy_reg);\n\n\t\t\tif (speed == SPEED_1000) {\n\t\t\t\thw->phy.ops.read_reg_locked(hw, HV_PM_CTRL,\n\t\t\t\t\t\t\t    &phy_reg);\n\n\t\t\t\tphy_reg |= HV_PM_CTRL_K1_CLK_REQ;\n\n\t\t\t\thw->phy.ops.write_reg_locked(hw, HV_PM_CTRL,\n\t\t\t\t\t\t\t     phy_reg);\n\t\t\t}\n\t\t}\n\t\thw->phy.ops.release(hw);\n\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (hw->mac.type >= e1000_pch_spt) {\n\t\t\tu16 data;\n\t\t\tu16 ptr_gap;\n\n\t\t\tif (speed == SPEED_1000) {\n\t\t\t\tret_val = hw->phy.ops.acquire(hw);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tret_val = e1e_rphy_locked(hw,\n\t\t\t\t\t\t\t  PHY_REG(776, 20),\n\t\t\t\t\t\t\t  &data);\n\t\t\t\tif (ret_val) {\n\t\t\t\t\thw->phy.ops.release(hw);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tptr_gap = (data & (0x3FF << 2)) >> 2;\n\t\t\t\tif (ptr_gap < 0x18) {\n\t\t\t\t\tdata &= ~(0x3FF << 2);\n\t\t\t\t\tdata |= (0x18 << 2);\n\t\t\t\t\tret_val =\n\t\t\t\t\t    e1e_wphy_locked(hw,\n\t\t\t\t\t\t\t    PHY_REG(776, 20),\n\t\t\t\t\t\t\t    data);\n\t\t\t\t}\n\t\t\t\thw->phy.ops.release(hw);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret_val = hw->phy.ops.acquire(hw);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tret_val = e1e_wphy_locked(hw,\n\t\t\t\t\t\t\t  PHY_REG(776, 20),\n\t\t\t\t\t\t\t  0xC023);\n\t\t\t\thw->phy.ops.release(hw);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tgoto out;\n\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\tu32 mac_reg;\n\n\t\tmac_reg = er32(FEXTNVM4);\n\t\tmac_reg &= ~E1000_FEXTNVM4_BEACON_DURATION_MASK;\n\t\tmac_reg |= E1000_FEXTNVM4_BEACON_DURATION_8USEC;\n\t\tew32(FEXTNVM4, mac_reg);\n\t}\n\n\t \n\tif ((hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPTLP_I218_LM) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPTLP_I218_V) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_I218_LM3) ||\n\t    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_I218_V3)) {\n\t\tret_val = e1000_k1_workaround_lpt_lp(hw, link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\t \n\t\tret_val = e1000_platform_pm_pch_lpt(hw, link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\t \n\thw->dev_spec.ich8lan.eee_lp_ability = 0;\n\n\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\tu32 fextnvm6 = er32(FEXTNVM6);\n\n\t\tif (hw->mac.type == e1000_pch_spt) {\n\t\t\t \n\t\t\tu32 pcieanacfg = er32(PCIEANACFG);\n\n\t\t\tif (pcieanacfg & E1000_FEXTNVM6_K1_OFF_ENABLE)\n\t\t\t\tfextnvm6 |= E1000_FEXTNVM6_K1_OFF_ENABLE;\n\t\t\telse\n\t\t\t\tfextnvm6 &= ~E1000_FEXTNVM6_K1_OFF_ENABLE;\n\t\t}\n\n\t\tew32(FEXTNVM6, fextnvm6);\n\t}\n\n\tif (!link)\n\t\tgoto out;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_pch2lan:\n\t\tret_val = e1000_k1_workaround_lv(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tfallthrough;\n\tcase e1000_pchlan:\n\t\tif (hw->phy.type == e1000_phy_82578) {\n\t\t\tret_val = e1000_link_stall_workaround_hv(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\te1e_rphy(hw, HV_KMRN_FIFO_CTRLSTA, &phy_reg);\n\t\tphy_reg &= ~HV_KMRN_FIFO_CTRLSTA_PREAMBLE_MASK;\n\n\t\tif ((er32(STATUS) & E1000_STATUS_FD) != E1000_STATUS_FD)\n\t\t\tphy_reg |= BIT(HV_KMRN_FIFO_CTRLSTA_PREAMBLE_SHIFT);\n\n\t\te1e_wphy(hw, HV_KMRN_FIFO_CTRLSTA, phy_reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\te1000e_check_downshift(hw);\n\n\t \n\tif (hw->phy.type > e1000_phy_82579) {\n\t\tret_val = e1000_set_eee_pchlan(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tif (!mac->autoneg)\n\t\treturn -E1000_ERR_CONFIG;\n\n\t \n\tmac->ops.config_collision_dist(hw);\n\n\t \n\tret_val = e1000e_config_fc_after_link_up(hw);\n\tif (ret_val)\n\t\te_dbg(\"Error configuring flow control\\n\");\n\n\treturn ret_val;\n\nout:\n\tmac->get_link_status = true;\n\treturn ret_val;\n}\n\nstatic s32 e1000_get_variants_ich8lan(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 rc;\n\n\trc = e1000_init_mac_params_ich8lan(hw);\n\tif (rc)\n\t\treturn rc;\n\n\trc = e1000_init_nvm_params_ich8lan(hw);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_ich8lan:\n\tcase e1000_ich9lan:\n\tcase e1000_ich10lan:\n\t\trc = e1000_init_phy_params_ich8lan(hw);\n\t\tbreak;\n\tcase e1000_pchlan:\n\tcase e1000_pch2lan:\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\trc = e1000_init_phy_params_pchlan(hw);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif ((adapter->hw.phy.type == e1000_phy_ife) ||\n\t    ((adapter->hw.mac.type >= e1000_pch2lan) &&\n\t     (!(er32(CTRL_EXT) & E1000_CTRL_EXT_LSECCK)))) {\n\t\tadapter->flags &= ~FLAG_HAS_JUMBO_FRAMES;\n\t\tadapter->max_hw_frame_size = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\n\t\thw->mac.ops.blink_led = NULL;\n\t}\n\n\tif ((adapter->hw.mac.type == e1000_ich8lan) &&\n\t    (adapter->hw.phy.type != e1000_phy_ife))\n\t\tadapter->flags |= FLAG_LSC_GIG_SPEED_DROP;\n\n\t \n\tif ((adapter->hw.mac.type == e1000_pch2lan) &&\n\t    (er32(FWSM) & E1000_ICH_FWSM_FW_VALID))\n\t\tadapter->flags2 |= FLAG2_PCIM2PCI_ARBITER_WA;\n\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(nvm_mutex);\n\n \nstatic s32 e1000_acquire_nvm_ich8lan(struct e1000_hw __always_unused *hw)\n{\n\tmutex_lock(&nvm_mutex);\n\n\treturn 0;\n}\n\n \nstatic void e1000_release_nvm_ich8lan(struct e1000_hw __always_unused *hw)\n{\n\tmutex_unlock(&nvm_mutex);\n}\n\n \nstatic s32 e1000_acquire_swflag_ich8lan(struct e1000_hw *hw)\n{\n\tu32 extcnf_ctrl, timeout = PHY_CFG_TIMEOUT;\n\ts32 ret_val = 0;\n\n\tif (test_and_set_bit(__E1000_ACCESS_SHARED_RESOURCE,\n\t\t\t     &hw->adapter->state)) {\n\t\te_dbg(\"contention for Phy access\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\twhile (timeout) {\n\t\textcnf_ctrl = er32(EXTCNF_CTRL);\n\t\tif (!(extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG))\n\t\t\tbreak;\n\n\t\tmdelay(1);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\te_dbg(\"SW has already locked the resource.\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\ttimeout = SW_FLAG_TIMEOUT;\n\n\textcnf_ctrl |= E1000_EXTCNF_CTRL_SWFLAG;\n\tew32(EXTCNF_CTRL, extcnf_ctrl);\n\n\twhile (timeout) {\n\t\textcnf_ctrl = er32(EXTCNF_CTRL);\n\t\tif (extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG)\n\t\t\tbreak;\n\n\t\tmdelay(1);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\te_dbg(\"Failed to acquire the semaphore, FW or HW has it: FWSM=0x%8.8x EXTCNF_CTRL=0x%8.8x)\\n\",\n\t\t      er32(FWSM), extcnf_ctrl);\n\t\textcnf_ctrl &= ~E1000_EXTCNF_CTRL_SWFLAG;\n\t\tew32(EXTCNF_CTRL, extcnf_ctrl);\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret_val)\n\t\tclear_bit(__E1000_ACCESS_SHARED_RESOURCE, &hw->adapter->state);\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_release_swflag_ich8lan(struct e1000_hw *hw)\n{\n\tu32 extcnf_ctrl;\n\n\textcnf_ctrl = er32(EXTCNF_CTRL);\n\n\tif (extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG) {\n\t\textcnf_ctrl &= ~E1000_EXTCNF_CTRL_SWFLAG;\n\t\tew32(EXTCNF_CTRL, extcnf_ctrl);\n\t} else {\n\t\te_dbg(\"Semaphore unexpectedly released by sw/fw/hw\\n\");\n\t}\n\n\tclear_bit(__E1000_ACCESS_SHARED_RESOURCE, &hw->adapter->state);\n}\n\n \nstatic bool e1000_check_mng_mode_ich8lan(struct e1000_hw *hw)\n{\n\tu32 fwsm;\n\n\tfwsm = er32(FWSM);\n\treturn (fwsm & E1000_ICH_FWSM_FW_VALID) &&\n\t\t((fwsm & E1000_FWSM_MODE_MASK) ==\n\t\t (E1000_ICH_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT));\n}\n\n \nstatic bool e1000_check_mng_mode_pchlan(struct e1000_hw *hw)\n{\n\tu32 fwsm;\n\n\tfwsm = er32(FWSM);\n\treturn (fwsm & E1000_ICH_FWSM_FW_VALID) &&\n\t    (fwsm & (E1000_ICH_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT));\n}\n\n \nstatic int e1000_rar_set_pch2lan(struct e1000_hw *hw, u8 *addr, u32 index)\n{\n\tu32 rar_low, rar_high;\n\n\t \n\trar_low = ((u32)addr[0] |\n\t\t   ((u32)addr[1] << 8) |\n\t\t   ((u32)addr[2] << 16) | ((u32)addr[3] << 24));\n\n\trar_high = ((u32)addr[4] | ((u32)addr[5] << 8));\n\n\t \n\tif (rar_low || rar_high)\n\t\trar_high |= E1000_RAH_AV;\n\n\tif (index == 0) {\n\t\tew32(RAL(index), rar_low);\n\t\te1e_flush();\n\t\tew32(RAH(index), rar_high);\n\t\te1e_flush();\n\t\treturn 0;\n\t}\n\n\t \n\tif (index < (u32)(hw->mac.rar_entry_count)) {\n\t\ts32 ret_val;\n\n\t\tret_val = e1000_acquire_swflag_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tew32(SHRAL(index - 1), rar_low);\n\t\te1e_flush();\n\t\tew32(SHRAH(index - 1), rar_high);\n\t\te1e_flush();\n\n\t\te1000_release_swflag_ich8lan(hw);\n\n\t\t \n\t\tif ((er32(SHRAL(index - 1)) == rar_low) &&\n\t\t    (er32(SHRAH(index - 1)) == rar_high))\n\t\t\treturn 0;\n\n\t\te_dbg(\"SHRA[%d] might be locked by ME - FWSM=0x%8.8x\\n\",\n\t\t      (index - 1), er32(FWSM));\n\t}\n\nout:\n\te_dbg(\"Failed to write receive address at index %d\\n\", index);\n\treturn -E1000_ERR_CONFIG;\n}\n\n \nstatic u32 e1000_rar_get_count_pch_lpt(struct e1000_hw *hw)\n{\n\tu32 wlock_mac;\n\tu32 num_entries;\n\n\twlock_mac = er32(FWSM) & E1000_FWSM_WLOCK_MAC_MASK;\n\twlock_mac >>= E1000_FWSM_WLOCK_MAC_SHIFT;\n\n\tswitch (wlock_mac) {\n\tcase 0:\n\t\t \n\t\tnum_entries = hw->mac.rar_entry_count;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tnum_entries = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnum_entries = wlock_mac + 1;\n\t\tbreak;\n\t}\n\n\treturn num_entries;\n}\n\n \nstatic int e1000_rar_set_pch_lpt(struct e1000_hw *hw, u8 *addr, u32 index)\n{\n\tu32 rar_low, rar_high;\n\tu32 wlock_mac;\n\n\t \n\trar_low = ((u32)addr[0] | ((u32)addr[1] << 8) |\n\t\t   ((u32)addr[2] << 16) | ((u32)addr[3] << 24));\n\n\trar_high = ((u32)addr[4] | ((u32)addr[5] << 8));\n\n\t \n\tif (rar_low || rar_high)\n\t\trar_high |= E1000_RAH_AV;\n\n\tif (index == 0) {\n\t\tew32(RAL(index), rar_low);\n\t\te1e_flush();\n\t\tew32(RAH(index), rar_high);\n\t\te1e_flush();\n\t\treturn 0;\n\t}\n\n\t \n\tif (index < hw->mac.rar_entry_count) {\n\t\twlock_mac = er32(FWSM) & E1000_FWSM_WLOCK_MAC_MASK;\n\t\twlock_mac >>= E1000_FWSM_WLOCK_MAC_SHIFT;\n\n\t\t \n\t\tif (wlock_mac == 1)\n\t\t\tgoto out;\n\n\t\tif ((wlock_mac == 0) || (index <= wlock_mac)) {\n\t\t\ts32 ret_val;\n\n\t\t\tret_val = e1000_acquire_swflag_ich8lan(hw);\n\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tew32(SHRAL_PCH_LPT(index - 1), rar_low);\n\t\t\te1e_flush();\n\t\t\tew32(SHRAH_PCH_LPT(index - 1), rar_high);\n\t\t\te1e_flush();\n\n\t\t\te1000_release_swflag_ich8lan(hw);\n\n\t\t\t \n\t\t\tif ((er32(SHRAL_PCH_LPT(index - 1)) == rar_low) &&\n\t\t\t    (er32(SHRAH_PCH_LPT(index - 1)) == rar_high))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\nout:\n\te_dbg(\"Failed to write receive address at index %d\\n\", index);\n\treturn -E1000_ERR_CONFIG;\n}\n\n \nstatic s32 e1000_check_reset_block_ich8lan(struct e1000_hw *hw)\n{\n\tbool blocked = false;\n\tint i = 0;\n\n\twhile ((blocked = !(er32(FWSM) & E1000_ICH_FWSM_RSPCIPHY)) &&\n\t       (i++ < 30))\n\t\tusleep_range(10000, 11000);\n\treturn blocked ? E1000_BLK_PHY_RESET : 0;\n}\n\n \nstatic s32 e1000_write_smbus_addr(struct e1000_hw *hw)\n{\n\tu16 phy_data;\n\tu32 strap = er32(STRAP);\n\tu32 freq = (strap & E1000_STRAP_SMT_FREQ_MASK) >>\n\t    E1000_STRAP_SMT_FREQ_SHIFT;\n\ts32 ret_val;\n\n\tstrap &= E1000_STRAP_SMBUS_ADDRESS_MASK;\n\n\tret_val = e1000_read_phy_reg_hv_locked(hw, HV_SMB_ADDR, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data &= ~HV_SMB_ADDR_MASK;\n\tphy_data |= (strap >> E1000_STRAP_SMBUS_ADDRESS_SHIFT);\n\tphy_data |= HV_SMB_ADDR_PEC_EN | HV_SMB_ADDR_VALID;\n\n\tif (hw->phy.type == e1000_phy_i217) {\n\t\t \n\t\tif (freq--) {\n\t\t\tphy_data &= ~HV_SMB_ADDR_FREQ_MASK;\n\t\t\tphy_data |= (freq & BIT(0)) <<\n\t\t\t    HV_SMB_ADDR_FREQ_LOW_SHIFT;\n\t\t\tphy_data |= (freq & BIT(1)) <<\n\t\t\t    (HV_SMB_ADDR_FREQ_HIGH_SHIFT - 1);\n\t\t} else {\n\t\t\te_dbg(\"Unsupported SMB frequency in PHY\\n\");\n\t\t}\n\t}\n\n\treturn e1000_write_phy_reg_hv_locked(hw, HV_SMB_ADDR, phy_data);\n}\n\n \nstatic s32 e1000_sw_lcd_config_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 i, data, cnf_size, cnf_base_addr, sw_cfg_mask;\n\ts32 ret_val = 0;\n\tu16 word_addr, reg_data, reg_addr, phy_page = 0;\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_ich8lan:\n\t\tif (phy->type != e1000_phy_igp_3)\n\t\t\treturn ret_val;\n\n\t\tif ((hw->adapter->pdev->device == E1000_DEV_ID_ICH8_IGP_AMT) ||\n\t\t    (hw->adapter->pdev->device == E1000_DEV_ID_ICH8_IGP_C)) {\n\t\t\tsw_cfg_mask = E1000_FEXTNVM_SW_CONFIG;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase e1000_pchlan:\n\tcase e1000_pch2lan:\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tsw_cfg_mask = E1000_FEXTNVM_SW_CONFIG_ICH8M;\n\t\tbreak;\n\tdefault:\n\t\treturn ret_val;\n\t}\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata = er32(FEXTNVM);\n\tif (!(data & sw_cfg_mask))\n\t\tgoto release;\n\n\t \n\tdata = er32(EXTCNF_CTRL);\n\tif ((hw->mac.type < e1000_pch2lan) &&\n\t    (data & E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE))\n\t\tgoto release;\n\n\tcnf_size = er32(EXTCNF_SIZE);\n\tcnf_size &= E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_MASK;\n\tcnf_size >>= E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_SHIFT;\n\tif (!cnf_size)\n\t\tgoto release;\n\n\tcnf_base_addr = data & E1000_EXTCNF_CTRL_EXT_CNF_POINTER_MASK;\n\tcnf_base_addr >>= E1000_EXTCNF_CTRL_EXT_CNF_POINTER_SHIFT;\n\n\tif (((hw->mac.type == e1000_pchlan) &&\n\t     !(data & E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)) ||\n\t    (hw->mac.type > e1000_pchlan)) {\n\t\t \n\t\tret_val = e1000_write_smbus_addr(hw);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\tdata = er32(LEDCTL);\n\t\tret_val = e1000_write_phy_reg_hv_locked(hw, HV_LED_CONFIG,\n\t\t\t\t\t\t\t(u16)data);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\t \n\n\t \n\tword_addr = (u16)(cnf_base_addr << 1);\n\n\tfor (i = 0; i < cnf_size; i++) {\n\t\tret_val = e1000_read_nvm(hw, (word_addr + i * 2), 1, &reg_data);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\tret_val = e1000_read_nvm(hw, (word_addr + i * 2 + 1),\n\t\t\t\t\t 1, &reg_addr);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t\t \n\t\tif (reg_addr == IGP01E1000_PHY_PAGE_SELECT) {\n\t\t\tphy_page = reg_data;\n\t\t\tcontinue;\n\t\t}\n\n\t\treg_addr &= PHY_REG_MASK;\n\t\treg_addr |= phy_page;\n\n\t\tret_val = e1e_wphy_locked(hw, (u32)reg_addr, reg_data);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\nrelease:\n\thw->phy.ops.release(hw);\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_k1_gig_workaround_hv(struct e1000_hw *hw, bool link)\n{\n\ts32 ret_val = 0;\n\tu16 status_reg = 0;\n\tbool k1_enable = hw->dev_spec.ich8lan.nvm_k1_enabled;\n\n\tif (hw->mac.type != e1000_pchlan)\n\t\treturn 0;\n\n\t \n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (link) {\n\t\tif (hw->phy.type == e1000_phy_82578) {\n\t\t\tret_val = e1e_rphy_locked(hw, BM_CS_STATUS,\n\t\t\t\t\t\t  &status_reg);\n\t\t\tif (ret_val)\n\t\t\t\tgoto release;\n\n\t\t\tstatus_reg &= (BM_CS_STATUS_LINK_UP |\n\t\t\t\t       BM_CS_STATUS_RESOLVED |\n\t\t\t\t       BM_CS_STATUS_SPEED_MASK);\n\n\t\t\tif (status_reg == (BM_CS_STATUS_LINK_UP |\n\t\t\t\t\t   BM_CS_STATUS_RESOLVED |\n\t\t\t\t\t   BM_CS_STATUS_SPEED_1000))\n\t\t\t\tk1_enable = false;\n\t\t}\n\n\t\tif (hw->phy.type == e1000_phy_82577) {\n\t\t\tret_val = e1e_rphy_locked(hw, HV_M_STATUS, &status_reg);\n\t\t\tif (ret_val)\n\t\t\t\tgoto release;\n\n\t\t\tstatus_reg &= (HV_M_STATUS_LINK_UP |\n\t\t\t\t       HV_M_STATUS_AUTONEG_COMPLETE |\n\t\t\t\t       HV_M_STATUS_SPEED_MASK);\n\n\t\t\tif (status_reg == (HV_M_STATUS_LINK_UP |\n\t\t\t\t\t   HV_M_STATUS_AUTONEG_COMPLETE |\n\t\t\t\t\t   HV_M_STATUS_SPEED_1000))\n\t\t\t\tk1_enable = false;\n\t\t}\n\n\t\t \n\t\tret_val = e1e_wphy_locked(hw, PHY_REG(770, 19), 0x0100);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\n\t} else {\n\t\t \n\t\tret_val = e1e_wphy_locked(hw, PHY_REG(770, 19), 0x4100);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\tret_val = e1000_configure_k1_ich8lan(hw, k1_enable);\n\nrelease:\n\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \ns32 e1000_configure_k1_ich8lan(struct e1000_hw *hw, bool k1_enable)\n{\n\ts32 ret_val;\n\tu32 ctrl_reg = 0;\n\tu32 ctrl_ext = 0;\n\tu32 reg = 0;\n\tu16 kmrn_reg = 0;\n\n\tret_val = e1000e_read_kmrn_reg_locked(hw, E1000_KMRNCTRLSTA_K1_CONFIG,\n\t\t\t\t\t      &kmrn_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (k1_enable)\n\t\tkmrn_reg |= E1000_KMRNCTRLSTA_K1_ENABLE;\n\telse\n\t\tkmrn_reg &= ~E1000_KMRNCTRLSTA_K1_ENABLE;\n\n\tret_val = e1000e_write_kmrn_reg_locked(hw, E1000_KMRNCTRLSTA_K1_CONFIG,\n\t\t\t\t\t       kmrn_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tusleep_range(20, 40);\n\tctrl_ext = er32(CTRL_EXT);\n\tctrl_reg = er32(CTRL);\n\n\treg = ctrl_reg & ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\n\treg |= E1000_CTRL_FRCSPD;\n\tew32(CTRL, reg);\n\n\tew32(CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_SPD_BYPS);\n\te1e_flush();\n\tusleep_range(20, 40);\n\tew32(CTRL, ctrl_reg);\n\tew32(CTRL_EXT, ctrl_ext);\n\te1e_flush();\n\tusleep_range(20, 40);\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_oem_bits_config_ich8lan(struct e1000_hw *hw, bool d0_state)\n{\n\ts32 ret_val = 0;\n\tu32 mac_reg;\n\tu16 oem_reg;\n\n\tif (hw->mac.type < e1000_pchlan)\n\t\treturn ret_val;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (hw->mac.type == e1000_pchlan) {\n\t\tmac_reg = er32(EXTCNF_CTRL);\n\t\tif (mac_reg & E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)\n\t\t\tgoto release;\n\t}\n\n\tmac_reg = er32(FEXTNVM);\n\tif (!(mac_reg & E1000_FEXTNVM_SW_CONFIG_ICH8M))\n\t\tgoto release;\n\n\tmac_reg = er32(PHY_CTRL);\n\n\tret_val = e1e_rphy_locked(hw, HV_OEM_BITS, &oem_reg);\n\tif (ret_val)\n\t\tgoto release;\n\n\toem_reg &= ~(HV_OEM_BITS_GBE_DIS | HV_OEM_BITS_LPLU);\n\n\tif (d0_state) {\n\t\tif (mac_reg & E1000_PHY_CTRL_GBE_DISABLE)\n\t\t\toem_reg |= HV_OEM_BITS_GBE_DIS;\n\n\t\tif (mac_reg & E1000_PHY_CTRL_D0A_LPLU)\n\t\t\toem_reg |= HV_OEM_BITS_LPLU;\n\t} else {\n\t\tif (mac_reg & (E1000_PHY_CTRL_GBE_DISABLE |\n\t\t\t       E1000_PHY_CTRL_NOND0A_GBE_DISABLE))\n\t\t\toem_reg |= HV_OEM_BITS_GBE_DIS;\n\n\t\tif (mac_reg & (E1000_PHY_CTRL_D0A_LPLU |\n\t\t\t       E1000_PHY_CTRL_NOND0A_LPLU))\n\t\t\toem_reg |= HV_OEM_BITS_LPLU;\n\t}\n\n\t \n\tif ((d0_state || (hw->mac.type != e1000_pchlan)) &&\n\t    !hw->phy.ops.check_reset_block(hw))\n\t\toem_reg |= HV_OEM_BITS_RESTART_AN;\n\n\tret_val = e1e_wphy_locked(hw, HV_OEM_BITS, oem_reg);\n\nrelease:\n\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_set_mdio_slow_mode_hv(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = e1e_rphy(hw, HV_KMRN_MODE_CTRL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tdata |= HV_KMRN_MDIO_SLOW;\n\n\tret_val = e1e_wphy(hw, HV_KMRN_MODE_CTRL, data);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_hv_phy_workarounds_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 phy_data;\n\n\tif (hw->mac.type != e1000_pchlan)\n\t\treturn 0;\n\n\t \n\tif (hw->phy.type == e1000_phy_82577) {\n\t\tret_val = e1000_set_mdio_slow_mode_hv(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (((hw->phy.type == e1000_phy_82577) &&\n\t     ((hw->phy.revision == 1) || (hw->phy.revision == 2))) ||\n\t    ((hw->phy.type == e1000_phy_82578) && (hw->phy.revision == 1))) {\n\t\t \n\t\tret_val = e1e_wphy(hw, PHY_REG(769, 25), 0x4431);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tret_val = e1e_wphy(hw, HV_KMRN_FIFO_CTRLSTA, 0xA204);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (hw->phy.type == e1000_phy_82578) {\n\t\t \n\t\tif (hw->phy.revision < 2) {\n\t\t\te1000e_phy_sw_reset(hw);\n\t\t\tret_val = e1e_wphy(hw, MII_BMCR, 0x3140);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\thw->phy.addr = 1;\n\tret_val = e1000e_write_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT, 0);\n\thw->phy.ops.release(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1000_k1_gig_workaround_hv(hw, true);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = e1e_rphy_locked(hw, BM_PORT_GEN_CFG, &phy_data);\n\tif (ret_val)\n\t\tgoto release;\n\tret_val = e1e_wphy_locked(hw, BM_PORT_GEN_CFG, phy_data & 0x00FF);\n\tif (ret_val)\n\t\tgoto release;\n\n\t \n\tret_val = e1000_write_emi_reg_locked(hw, I82577_MSE_THRESHOLD, 0x0034);\nrelease:\n\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \nvoid e1000_copy_rx_addrs_to_phy_ich8lan(struct e1000_hw *hw)\n{\n\tu32 mac_reg;\n\tu16 i, phy_reg = 0;\n\ts32 ret_val;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn;\n\tret_val = e1000_enable_phy_wakeup_reg_access_bm(hw, &phy_reg);\n\tif (ret_val)\n\t\tgoto release;\n\n\t \n\tfor (i = 0; i < (hw->mac.rar_entry_count); i++) {\n\t\tmac_reg = er32(RAL(i));\n\t\thw->phy.ops.write_reg_page(hw, BM_RAR_L(i),\n\t\t\t\t\t   (u16)(mac_reg & 0xFFFF));\n\t\thw->phy.ops.write_reg_page(hw, BM_RAR_M(i),\n\t\t\t\t\t   (u16)((mac_reg >> 16) & 0xFFFF));\n\n\t\tmac_reg = er32(RAH(i));\n\t\thw->phy.ops.write_reg_page(hw, BM_RAR_H(i),\n\t\t\t\t\t   (u16)(mac_reg & 0xFFFF));\n\t\thw->phy.ops.write_reg_page(hw, BM_RAR_CTRL(i),\n\t\t\t\t\t   (u16)((mac_reg & E1000_RAH_AV)\n\t\t\t\t\t\t >> 16));\n\t}\n\n\te1000_disable_phy_wakeup_reg_access_bm(hw, &phy_reg);\n\nrelease:\n\thw->phy.ops.release(hw);\n}\n\n \ns32 e1000_lv_jumbo_workaround_ich8lan(struct e1000_hw *hw, bool enable)\n{\n\ts32 ret_val = 0;\n\tu16 phy_reg, data;\n\tu32 mac_reg;\n\tu16 i;\n\n\tif (hw->mac.type < e1000_pch2lan)\n\t\treturn 0;\n\n\t \n\te1e_rphy(hw, PHY_REG(769, 20), &phy_reg);\n\tret_val = e1e_wphy(hw, PHY_REG(769, 20), phy_reg | BIT(14));\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (enable) {\n\t\t \n\t\tfor (i = 0; i < hw->mac.rar_entry_count; i++) {\n\t\t\tu8 mac_addr[ETH_ALEN] = { 0 };\n\t\t\tu32 addr_high, addr_low;\n\n\t\t\taddr_high = er32(RAH(i));\n\t\t\tif (!(addr_high & E1000_RAH_AV))\n\t\t\t\tcontinue;\n\t\t\taddr_low = er32(RAL(i));\n\t\t\tmac_addr[0] = (addr_low & 0xFF);\n\t\t\tmac_addr[1] = ((addr_low >> 8) & 0xFF);\n\t\t\tmac_addr[2] = ((addr_low >> 16) & 0xFF);\n\t\t\tmac_addr[3] = ((addr_low >> 24) & 0xFF);\n\t\t\tmac_addr[4] = (addr_high & 0xFF);\n\t\t\tmac_addr[5] = ((addr_high >> 8) & 0xFF);\n\n\t\t\tew32(PCH_RAICC(i), ~ether_crc_le(ETH_ALEN, mac_addr));\n\t\t}\n\n\t\t \n\t\te1000_copy_rx_addrs_to_phy_ich8lan(hw);\n\n\t\t \n\t\tmac_reg = er32(FFLT_DBG);\n\t\tmac_reg &= ~BIT(14);\n\t\tmac_reg |= (7 << 15);\n\t\tew32(FFLT_DBG, mac_reg);\n\n\t\tmac_reg = er32(RCTL);\n\t\tmac_reg |= E1000_RCTL_SECRC;\n\t\tew32(RCTL, mac_reg);\n\n\t\tret_val = e1000e_read_kmrn_reg(hw,\n\t\t\t\t\t       E1000_KMRNCTRLSTA_CTRL_OFFSET,\n\t\t\t\t\t       &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000e_write_kmrn_reg(hw,\n\t\t\t\t\t\tE1000_KMRNCTRLSTA_CTRL_OFFSET,\n\t\t\t\t\t\tdata | BIT(0));\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000e_read_kmrn_reg(hw,\n\t\t\t\t\t       E1000_KMRNCTRLSTA_HD_CTRL,\n\t\t\t\t\t       &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tdata &= ~(0xF << 8);\n\t\tdata |= (0xB << 8);\n\t\tret_val = e1000e_write_kmrn_reg(hw,\n\t\t\t\t\t\tE1000_KMRNCTRLSTA_HD_CTRL,\n\t\t\t\t\t\tdata);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\te1e_rphy(hw, PHY_REG(769, 23), &data);\n\t\tdata &= ~(0x7F << 5);\n\t\tdata |= (0x37 << 5);\n\t\tret_val = e1e_wphy(hw, PHY_REG(769, 23), data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\te1e_rphy(hw, PHY_REG(769, 16), &data);\n\t\tdata &= ~BIT(13);\n\t\tret_val = e1e_wphy(hw, PHY_REG(769, 16), data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\te1e_rphy(hw, PHY_REG(776, 20), &data);\n\t\tdata &= ~(0x3FF << 2);\n\t\tdata |= (E1000_TX_PTR_GAP << 2);\n\t\tret_val = e1e_wphy(hw, PHY_REG(776, 20), data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1e_wphy(hw, PHY_REG(776, 23), 0xF100);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\te1e_rphy(hw, HV_PM_CTRL, &data);\n\t\tret_val = e1e_wphy(hw, HV_PM_CTRL, data | BIT(10));\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else {\n\t\t \n\t\tmac_reg = er32(FFLT_DBG);\n\t\tmac_reg &= ~(0xF << 14);\n\t\tew32(FFLT_DBG, mac_reg);\n\n\t\tmac_reg = er32(RCTL);\n\t\tmac_reg &= ~E1000_RCTL_SECRC;\n\t\tew32(RCTL, mac_reg);\n\n\t\tret_val = e1000e_read_kmrn_reg(hw,\n\t\t\t\t\t       E1000_KMRNCTRLSTA_CTRL_OFFSET,\n\t\t\t\t\t       &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000e_write_kmrn_reg(hw,\n\t\t\t\t\t\tE1000_KMRNCTRLSTA_CTRL_OFFSET,\n\t\t\t\t\t\tdata & ~BIT(0));\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000e_read_kmrn_reg(hw,\n\t\t\t\t\t       E1000_KMRNCTRLSTA_HD_CTRL,\n\t\t\t\t\t       &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tdata &= ~(0xF << 8);\n\t\tdata |= (0xB << 8);\n\t\tret_val = e1000e_write_kmrn_reg(hw,\n\t\t\t\t\t\tE1000_KMRNCTRLSTA_HD_CTRL,\n\t\t\t\t\t\tdata);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\te1e_rphy(hw, PHY_REG(769, 23), &data);\n\t\tdata &= ~(0x7F << 5);\n\t\tret_val = e1e_wphy(hw, PHY_REG(769, 23), data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\te1e_rphy(hw, PHY_REG(769, 16), &data);\n\t\tdata |= BIT(13);\n\t\tret_val = e1e_wphy(hw, PHY_REG(769, 16), data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\te1e_rphy(hw, PHY_REG(776, 20), &data);\n\t\tdata &= ~(0x3FF << 2);\n\t\tdata |= (0x8 << 2);\n\t\tret_val = e1e_wphy(hw, PHY_REG(776, 20), data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1e_wphy(hw, PHY_REG(776, 23), 0x7E00);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\te1e_rphy(hw, HV_PM_CTRL, &data);\n\t\tret_val = e1e_wphy(hw, HV_PM_CTRL, data & ~BIT(10));\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\treturn e1e_wphy(hw, PHY_REG(769, 20), phy_reg & ~BIT(14));\n}\n\n \nstatic s32 e1000_lv_phy_workarounds_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\tif (hw->mac.type != e1000_pch2lan)\n\t\treturn 0;\n\n\t \n\tret_val = e1000_set_mdio_slow_mode_hv(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\t \n\tret_val = e1000_write_emi_reg_locked(hw, I82579_MSE_THRESHOLD, 0x0034);\n\tif (ret_val)\n\t\tgoto release;\n\t \n\tret_val = e1000_write_emi_reg_locked(hw, I82579_MSE_LINK_DOWN, 0x0005);\nrelease:\n\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_k1_workaround_lv(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 status_reg = 0;\n\n\tif (hw->mac.type != e1000_pch2lan)\n\t\treturn 0;\n\n\t \n\tret_val = e1e_rphy(hw, HV_M_STATUS, &status_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif ((status_reg & (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE))\n\t    == (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE)) {\n\t\tif (status_reg &\n\t\t    (HV_M_STATUS_SPEED_1000 | HV_M_STATUS_SPEED_100)) {\n\t\t\tu16 pm_phy_reg;\n\n\t\t\t \n\t\t\tret_val = e1e_rphy(hw, HV_PM_CTRL, &pm_phy_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tpm_phy_reg &= ~HV_PM_CTRL_K1_ENABLE;\n\t\t\tret_val = e1e_wphy(hw, HV_PM_CTRL, pm_phy_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t} else {\n\t\t\tu32 mac_reg;\n\n\t\t\tmac_reg = er32(FEXTNVM4);\n\t\t\tmac_reg &= ~E1000_FEXTNVM4_BEACON_DURATION_MASK;\n\t\t\tmac_reg |= E1000_FEXTNVM4_BEACON_DURATION_16USEC;\n\t\t\tew32(FEXTNVM4, mac_reg);\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_gate_hw_phy_config_ich8lan(struct e1000_hw *hw, bool gate)\n{\n\tu32 extcnf_ctrl;\n\n\tif (hw->mac.type < e1000_pch2lan)\n\t\treturn;\n\n\textcnf_ctrl = er32(EXTCNF_CTRL);\n\n\tif (gate)\n\t\textcnf_ctrl |= E1000_EXTCNF_CTRL_GATE_PHY_CFG;\n\telse\n\t\textcnf_ctrl &= ~E1000_EXTCNF_CTRL_GATE_PHY_CFG;\n\n\tew32(EXTCNF_CTRL, extcnf_ctrl);\n}\n\n \nstatic void e1000_lan_init_done_ich8lan(struct e1000_hw *hw)\n{\n\tu32 data, loop = E1000_ICH8_LAN_INIT_TIMEOUT;\n\n\t \n\tdo {\n\t\tdata = er32(STATUS);\n\t\tdata &= E1000_STATUS_LAN_INIT_DONE;\n\t\tusleep_range(100, 200);\n\t} while ((!data) && --loop);\n\n\t \n\tif (loop == 0)\n\t\te_dbg(\"LAN_INIT_DONE not set, increase timeout\\n\");\n\n\t \n\tdata = er32(STATUS);\n\tdata &= ~E1000_STATUS_LAN_INIT_DONE;\n\tew32(STATUS, data);\n}\n\n \nstatic s32 e1000_post_phy_reset_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 reg;\n\n\tif (hw->phy.ops.check_reset_block(hw))\n\t\treturn 0;\n\n\t \n\tusleep_range(10000, 11000);\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_pchlan:\n\t\tret_val = e1000_hv_phy_workarounds_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\tcase e1000_pch2lan:\n\t\tret_val = e1000_lv_phy_workarounds_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (hw->mac.type >= e1000_pchlan) {\n\t\te1e_rphy(hw, BM_PORT_GEN_CFG, &reg);\n\t\treg &= ~BM_WUC_HOST_WU_BIT;\n\t\te1e_wphy(hw, BM_PORT_GEN_CFG, reg);\n\t}\n\n\t \n\tret_val = e1000_sw_lcd_config_ich8lan(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1000_oem_bits_config_ich8lan(hw, true);\n\n\tif (hw->mac.type == e1000_pch2lan) {\n\t\t \n\t\tif (!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID)) {\n\t\t\tusleep_range(10000, 11000);\n\t\t\te1000_gate_hw_phy_config_ich8lan(hw, false);\n\t\t}\n\n\t\t \n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000_write_emi_reg_locked(hw,\n\t\t\t\t\t\t     I82579_LPI_UPDATE_TIMER,\n\t\t\t\t\t\t     0x1387);\n\t\thw->phy.ops.release(hw);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_phy_hw_reset_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\t \n\tif ((hw->mac.type == e1000_pch2lan) &&\n\t    !(er32(FWSM) & E1000_ICH_FWSM_FW_VALID))\n\t\te1000_gate_hw_phy_config_ich8lan(hw, true);\n\n\tret_val = e1000e_phy_hw_reset_generic(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1000_post_phy_reset_ich8lan(hw);\n}\n\n \nstatic s32 e1000_set_lplu_state_pchlan(struct e1000_hw *hw, bool active)\n{\n\ts32 ret_val;\n\tu16 oem_reg;\n\n\tret_val = e1e_rphy(hw, HV_OEM_BITS, &oem_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (active)\n\t\toem_reg |= HV_OEM_BITS_LPLU;\n\telse\n\t\toem_reg &= ~HV_OEM_BITS_LPLU;\n\n\tif (!hw->phy.ops.check_reset_block(hw))\n\t\toem_reg |= HV_OEM_BITS_RESTART_AN;\n\n\treturn e1e_wphy(hw, HV_OEM_BITS, oem_reg);\n}\n\n \nstatic s32 e1000_set_d0_lplu_state_ich8lan(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 phy_ctrl;\n\ts32 ret_val = 0;\n\tu16 data;\n\n\tif (phy->type == e1000_phy_ife)\n\t\treturn 0;\n\n\tphy_ctrl = er32(PHY_CTRL);\n\n\tif (active) {\n\t\tphy_ctrl |= E1000_PHY_CTRL_D0A_LPLU;\n\t\tew32(PHY_CTRL, phy_ctrl);\n\n\t\tif (phy->type != e1000_phy_igp_3)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (hw->mac.type == e1000_ich8lan)\n\t\t\te1000e_gig_downshift_workaround_ich8lan(hw);\n\n\t\t \n\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG, data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else {\n\t\tphy_ctrl &= ~E1000_PHY_CTRL_D0A_LPLU;\n\t\tew32(PHY_CTRL, phy_ctrl);\n\n\t\tif (phy->type != e1000_phy_igp_3)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata |= IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t} else if (phy->smart_speed == e1000_smart_speed_off) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_set_d3_lplu_state_ich8lan(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 phy_ctrl;\n\ts32 ret_val = 0;\n\tu16 data;\n\n\tphy_ctrl = er32(PHY_CTRL);\n\n\tif (!active) {\n\t\tphy_ctrl &= ~E1000_PHY_CTRL_NOND0A_LPLU;\n\t\tew32(PHY_CTRL, phy_ctrl);\n\n\t\tif (phy->type != e1000_phy_igp_3)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata |= IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t} else if (phy->smart_speed == e1000_smart_speed_off) {\n\t\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t   data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t} else if ((phy->autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_NOT_GIG) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_10_SPEED)) {\n\t\tphy_ctrl |= E1000_PHY_CTRL_NOND0A_LPLU;\n\t\tew32(PHY_CTRL, phy_ctrl);\n\n\t\tif (phy->type != e1000_phy_igp_3)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (hw->mac.type == e1000_ich8lan)\n\t\t\te1000e_gig_downshift_workaround_ich8lan(hw);\n\n\t\t \n\t\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG, data);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_valid_nvm_bank_detect_ich8lan(struct e1000_hw *hw, u32 *bank)\n{\n\tu32 eecd;\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 bank1_offset = nvm->flash_bank_size * sizeof(u16);\n\tu32 act_offset = E1000_ICH_NVM_SIG_WORD * 2 + 1;\n\tu32 nvm_dword = 0;\n\tu8 sig_byte = 0;\n\ts32 ret_val;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tbank1_offset = nvm->flash_bank_size;\n\t\tact_offset = E1000_ICH_NVM_SIG_WORD;\n\n\t\t \n\t\t*bank = 0;\n\n\t\t \n\t\tret_val = e1000_read_flash_dword_ich8lan(hw, act_offset,\n\t\t\t\t\t\t\t &nvm_dword);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tsig_byte = (u8)((nvm_dword & 0xFF00) >> 8);\n\t\tif ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==\n\t\t    E1000_ICH_NVM_SIG_VALUE) {\n\t\t\t*bank = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tret_val = e1000_read_flash_dword_ich8lan(hw, act_offset +\n\t\t\t\t\t\t\t bank1_offset,\n\t\t\t\t\t\t\t &nvm_dword);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tsig_byte = (u8)((nvm_dword & 0xFF00) >> 8);\n\t\tif ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==\n\t\t    E1000_ICH_NVM_SIG_VALUE) {\n\t\t\t*bank = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\te_dbg(\"ERROR: No valid NVM bank present\\n\");\n\t\treturn -E1000_ERR_NVM;\n\tcase e1000_ich8lan:\n\tcase e1000_ich9lan:\n\t\teecd = er32(EECD);\n\t\tif ((eecd & E1000_EECD_SEC1VAL_VALID_MASK) ==\n\t\t    E1000_EECD_SEC1VAL_VALID_MASK) {\n\t\t\tif (eecd & E1000_EECD_SEC1VAL)\n\t\t\t\t*bank = 1;\n\t\t\telse\n\t\t\t\t*bank = 0;\n\n\t\t\treturn 0;\n\t\t}\n\t\te_dbg(\"Unable to determine valid NVM bank via EEC - reading flash signature\\n\");\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\t*bank = 0;\n\n\t\t \n\t\tret_val = e1000_read_flash_byte_ich8lan(hw, act_offset,\n\t\t\t\t\t\t\t&sig_byte);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tif ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==\n\t\t    E1000_ICH_NVM_SIG_VALUE) {\n\t\t\t*bank = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tret_val = e1000_read_flash_byte_ich8lan(hw, act_offset +\n\t\t\t\t\t\t\tbank1_offset,\n\t\t\t\t\t\t\t&sig_byte);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tif ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==\n\t\t    E1000_ICH_NVM_SIG_VALUE) {\n\t\t\t*bank = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\te_dbg(\"ERROR: No valid NVM bank present\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n}\n\n \nstatic s32 e1000_read_nvm_spt(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t      u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu32 act_offset;\n\ts32 ret_val = 0;\n\tu32 bank = 0;\n\tu32 dword = 0;\n\tu16 offset_to_read;\n\tu16 i;\n\n\tif ((offset >= nvm->word_size) || (words > nvm->word_size - offset) ||\n\t    (words == 0)) {\n\t\te_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\n\tnvm->ops.acquire(hw);\n\n\tret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &bank);\n\tif (ret_val) {\n\t\te_dbg(\"Could not detect valid bank, assuming bank 0\\n\");\n\t\tbank = 0;\n\t}\n\n\tact_offset = (bank) ? nvm->flash_bank_size : 0;\n\tact_offset += offset;\n\n\tret_val = 0;\n\n\tfor (i = 0; i < words; i += 2) {\n\t\tif (words - i == 1) {\n\t\t\tif (dev_spec->shadow_ram[offset + i].modified) {\n\t\t\t\tdata[i] =\n\t\t\t\t    dev_spec->shadow_ram[offset + i].value;\n\t\t\t} else {\n\t\t\t\toffset_to_read = act_offset + i -\n\t\t\t\t    ((act_offset + i) % 2);\n\t\t\t\tret_val =\n\t\t\t\t  e1000_read_flash_dword_ich8lan(hw,\n\t\t\t\t\t\t\t\t offset_to_read,\n\t\t\t\t\t\t\t\t &dword);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((act_offset + i) % 2 == 0)\n\t\t\t\t\tdata[i] = (u16)(dword & 0xFFFF);\n\t\t\t\telse\n\t\t\t\t\tdata[i] = (u16)((dword >> 16) & 0xFFFF);\n\t\t\t}\n\t\t} else {\n\t\t\toffset_to_read = act_offset + i;\n\t\t\tif (!(dev_spec->shadow_ram[offset + i].modified) ||\n\t\t\t    !(dev_spec->shadow_ram[offset + i + 1].modified)) {\n\t\t\t\tret_val =\n\t\t\t\t  e1000_read_flash_dword_ich8lan(hw,\n\t\t\t\t\t\t\t\t offset_to_read,\n\t\t\t\t\t\t\t\t &dword);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dev_spec->shadow_ram[offset + i].modified)\n\t\t\t\tdata[i] =\n\t\t\t\t    dev_spec->shadow_ram[offset + i].value;\n\t\t\telse\n\t\t\t\tdata[i] = (u16)(dword & 0xFFFF);\n\t\t\tif (dev_spec->shadow_ram[offset + i].modified)\n\t\t\t\tdata[i + 1] =\n\t\t\t\t    dev_spec->shadow_ram[offset + i + 1].value;\n\t\t\telse\n\t\t\t\tdata[i + 1] = (u16)(dword >> 16 & 0xFFFF);\n\t\t}\n\t}\n\n\tnvm->ops.release(hw);\n\nout:\n\tif (ret_val)\n\t\te_dbg(\"NVM read error: %d\\n\", ret_val);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_read_nvm_ich8lan(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t  u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu32 act_offset;\n\ts32 ret_val = 0;\n\tu32 bank = 0;\n\tu16 i, word;\n\n\tif ((offset >= nvm->word_size) || (words > nvm->word_size - offset) ||\n\t    (words == 0)) {\n\t\te_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\n\tnvm->ops.acquire(hw);\n\n\tret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &bank);\n\tif (ret_val) {\n\t\te_dbg(\"Could not detect valid bank, assuming bank 0\\n\");\n\t\tbank = 0;\n\t}\n\n\tact_offset = (bank) ? nvm->flash_bank_size : 0;\n\tact_offset += offset;\n\n\tret_val = 0;\n\tfor (i = 0; i < words; i++) {\n\t\tif (dev_spec->shadow_ram[offset + i].modified) {\n\t\t\tdata[i] = dev_spec->shadow_ram[offset + i].value;\n\t\t} else {\n\t\t\tret_val = e1000_read_flash_word_ich8lan(hw,\n\t\t\t\t\t\t\t\tact_offset + i,\n\t\t\t\t\t\t\t\t&word);\n\t\t\tif (ret_val)\n\t\t\t\tbreak;\n\t\t\tdata[i] = word;\n\t\t}\n\t}\n\n\tnvm->ops.release(hw);\n\nout:\n\tif (ret_val)\n\t\te_dbg(\"NVM read error: %d\\n\", ret_val);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_flash_cycle_init_ich8lan(struct e1000_hw *hw)\n{\n\tunion ich8_hws_flash_status hsfsts;\n\ts32 ret_val = -E1000_ERR_NVM;\n\n\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\n\t \n\tif (!hsfsts.hsf_status.fldesvalid) {\n\t\te_dbg(\"Flash descriptor invalid.  SW Sequencing must be used.\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\t \n\thsfsts.hsf_status.flcerr = 1;\n\thsfsts.hsf_status.dael = 1;\n\tif (hw->mac.type >= e1000_pch_spt)\n\t\tew32flash(ICH_FLASH_HSFSTS, hsfsts.regval & 0xFFFF);\n\telse\n\t\tew16flash(ICH_FLASH_HSFSTS, hsfsts.regval);\n\n\t \n\n\tif (!hsfsts.hsf_status.flcinprog) {\n\t\t \n\t\thsfsts.hsf_status.flcdone = 1;\n\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\tew32flash(ICH_FLASH_HSFSTS, hsfsts.regval & 0xFFFF);\n\t\telse\n\t\t\tew16flash(ICH_FLASH_HSFSTS, hsfsts.regval);\n\t\tret_val = 0;\n\t} else {\n\t\ts32 i;\n\n\t\t \n\t\tfor (i = 0; i < ICH_FLASH_READ_COMMAND_TIMEOUT; i++) {\n\t\t\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\t\t\tif (!hsfsts.hsf_status.flcinprog) {\n\t\t\t\tret_val = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\t\tif (!ret_val) {\n\t\t\t \n\t\t\thsfsts.hsf_status.flcdone = 1;\n\t\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\t\tew32flash(ICH_FLASH_HSFSTS,\n\t\t\t\t\t  hsfsts.regval & 0xFFFF);\n\t\t\telse\n\t\t\t\tew16flash(ICH_FLASH_HSFSTS, hsfsts.regval);\n\t\t} else {\n\t\t\te_dbg(\"Flash controller busy, cannot get access\\n\");\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_flash_cycle_ich8lan(struct e1000_hw *hw, u32 timeout)\n{\n\tunion ich8_hws_flash_ctrl hsflctl;\n\tunion ich8_hws_flash_status hsfsts;\n\tu32 i = 0;\n\n\t \n\tif (hw->mac.type >= e1000_pch_spt)\n\t\thsflctl.regval = er32flash(ICH_FLASH_HSFSTS) >> 16;\n\telse\n\t\thsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\n\thsflctl.hsf_ctrl.flcgo = 1;\n\n\tif (hw->mac.type >= e1000_pch_spt)\n\t\tew32flash(ICH_FLASH_HSFSTS, hsflctl.regval << 16);\n\telse\n\t\tew16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\n\n\t \n\tdo {\n\t\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\t\tif (hsfsts.hsf_status.flcdone)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (i++ < timeout);\n\n\tif (hsfsts.hsf_status.flcdone && !hsfsts.hsf_status.flcerr)\n\t\treturn 0;\n\n\treturn -E1000_ERR_NVM;\n}\n\n \nstatic s32 e1000_read_flash_dword_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u32 *data)\n{\n\t \n\toffset <<= 1;\n\treturn e1000_read_flash_data32_ich8lan(hw, offset, data);\n}\n\n \nstatic s32 e1000_read_flash_word_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t u16 *data)\n{\n\t \n\toffset <<= 1;\n\n\treturn e1000_read_flash_data_ich8lan(hw, offset, 2, data);\n}\n\n \nstatic s32 e1000_read_flash_byte_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t u8 *data)\n{\n\ts32 ret_val;\n\tu16 word = 0;\n\n\t \n\tif (hw->mac.type >= e1000_pch_spt)\n\t\treturn -E1000_ERR_NVM;\n\telse\n\t\tret_val = e1000_read_flash_data_ich8lan(hw, offset, 1, &word);\n\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t*data = (u8)word;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_read_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t u8 size, u16 *data)\n{\n\tunion ich8_hws_flash_status hsfsts;\n\tunion ich8_hws_flash_ctrl hsflctl;\n\tu32 flash_linear_addr;\n\tu32 flash_data = 0;\n\ts32 ret_val = -E1000_ERR_NVM;\n\tu8 count = 0;\n\n\tif (size < 1 || size > 2 || offset > ICH_FLASH_LINEAR_ADDR_MASK)\n\t\treturn -E1000_ERR_NVM;\n\n\tflash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK & offset) +\n\t\t\t     hw->nvm.flash_base_addr);\n\n\tdo {\n\t\tudelay(1);\n\t\t \n\t\tret_val = e1000_flash_cycle_init_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\tbreak;\n\n\t\thsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\n\t\t \n\t\thsflctl.hsf_ctrl.fldbcount = size - 1;\n\t\thsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;\n\t\tew16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\n\n\t\tew32flash(ICH_FLASH_FADDR, flash_linear_addr);\n\n\t\tret_val =\n\t\t    e1000_flash_cycle_ich8lan(hw,\n\t\t\t\t\t      ICH_FLASH_READ_COMMAND_TIMEOUT);\n\n\t\t \n\t\tif (!ret_val) {\n\t\t\tflash_data = er32flash(ICH_FLASH_FDATA0);\n\t\t\tif (size == 1)\n\t\t\t\t*data = (u8)(flash_data & 0x000000FF);\n\t\t\telse if (size == 2)\n\t\t\t\t*data = (u16)(flash_data & 0x0000FFFF);\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\t\t\tif (hsfsts.hsf_status.flcerr) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t} else if (!hsfsts.hsf_status.flcdone) {\n\t\t\t\te_dbg(\"Timeout error - flash cycle did not complete.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);\n\n\treturn ret_val;\n}\n\n \n\nstatic s32 e1000_read_flash_data32_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t   u32 *data)\n{\n\tunion ich8_hws_flash_status hsfsts;\n\tunion ich8_hws_flash_ctrl hsflctl;\n\tu32 flash_linear_addr;\n\ts32 ret_val = -E1000_ERR_NVM;\n\tu8 count = 0;\n\n\tif (offset > ICH_FLASH_LINEAR_ADDR_MASK || hw->mac.type < e1000_pch_spt)\n\t\treturn -E1000_ERR_NVM;\n\tflash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK & offset) +\n\t\t\t     hw->nvm.flash_base_addr);\n\n\tdo {\n\t\tudelay(1);\n\t\t \n\t\tret_val = e1000_flash_cycle_init_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\t \n\t\thsflctl.regval = er32flash(ICH_FLASH_HSFSTS) >> 16;\n\n\t\t \n\t\thsflctl.hsf_ctrl.fldbcount = sizeof(u32) - 1;\n\t\thsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;\n\t\t \n\t\tew32flash(ICH_FLASH_HSFSTS, (u32)hsflctl.regval << 16);\n\t\tew32flash(ICH_FLASH_FADDR, flash_linear_addr);\n\n\t\tret_val =\n\t\t   e1000_flash_cycle_ich8lan(hw,\n\t\t\t\t\t     ICH_FLASH_READ_COMMAND_TIMEOUT);\n\n\t\t \n\t\tif (!ret_val) {\n\t\t\t*data = er32flash(ICH_FLASH_FDATA0);\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\t\t\tif (hsfsts.hsf_status.flcerr) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t} else if (!hsfsts.hsf_status.flcdone) {\n\t\t\t\te_dbg(\"Timeout error - flash cycle did not complete.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_nvm_ich8lan(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t   u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu16 i;\n\n\tif ((offset >= nvm->word_size) || (words > nvm->word_size - offset) ||\n\t    (words == 0)) {\n\t\te_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\tnvm->ops.acquire(hw);\n\n\tfor (i = 0; i < words; i++) {\n\t\tdev_spec->shadow_ram[offset + i].modified = true;\n\t\tdev_spec->shadow_ram[offset + i].value = data[i];\n\t}\n\n\tnvm->ops.release(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_update_nvm_checksum_spt(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu32 i, act_offset, new_bank_offset, old_bank_offset, bank;\n\ts32 ret_val;\n\tu32 dword = 0;\n\n\tret_val = e1000e_update_nvm_checksum_generic(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (nvm->type != e1000_nvm_flash_sw)\n\t\tgoto out;\n\n\tnvm->ops.acquire(hw);\n\n\t \n\tret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &bank);\n\tif (ret_val) {\n\t\te_dbg(\"Could not detect valid bank, assuming bank 0\\n\");\n\t\tbank = 0;\n\t}\n\n\tif (bank == 0) {\n\t\tnew_bank_offset = nvm->flash_bank_size;\n\t\told_bank_offset = 0;\n\t\tret_val = e1000_erase_flash_bank_ich8lan(hw, 1);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t} else {\n\t\told_bank_offset = nvm->flash_bank_size;\n\t\tnew_bank_offset = 0;\n\t\tret_val = e1000_erase_flash_bank_ich8lan(hw, 0);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\tfor (i = 0; i < E1000_ICH8_SHADOW_RAM_WORDS; i += 2) {\n\t\t \n\t\tret_val = e1000_read_flash_dword_ich8lan(hw,\n\t\t\t\t\t\t\t i + old_bank_offset,\n\t\t\t\t\t\t\t &dword);\n\n\t\tif (dev_spec->shadow_ram[i].modified) {\n\t\t\tdword &= 0xffff0000;\n\t\t\tdword |= (dev_spec->shadow_ram[i].value & 0xffff);\n\t\t}\n\t\tif (dev_spec->shadow_ram[i + 1].modified) {\n\t\t\tdword &= 0x0000ffff;\n\t\t\tdword |= ((dev_spec->shadow_ram[i + 1].value & 0xffff)\n\t\t\t\t  << 16);\n\t\t}\n\t\tif (ret_val)\n\t\t\tbreak;\n\n\t\t \n\t\tif (i == E1000_ICH_NVM_SIG_WORD - 1)\n\t\t\tdword |= E1000_ICH_NVM_SIG_MASK << 16;\n\n\t\t \n\t\tact_offset = (i + new_bank_offset) << 1;\n\n\t\tusleep_range(100, 200);\n\n\t\t \n\t\tact_offset = i + new_bank_offset;\n\t\tret_val = e1000_retry_write_flash_dword_ich8lan(hw, act_offset,\n\t\t\t\t\t\t\t\tdword);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (ret_val) {\n\t\t \n\t\te_dbg(\"Flash commit failed.\\n\");\n\t\tgoto release;\n\t}\n\n\t \n\tact_offset = new_bank_offset + E1000_ICH_NVM_SIG_WORD;\n\n\t \n\t--act_offset;\n\tret_val = e1000_read_flash_dword_ich8lan(hw, act_offset, &dword);\n\n\tif (ret_val)\n\t\tgoto release;\n\n\tdword &= 0xBFFFFFFF;\n\tret_val = e1000_retry_write_flash_dword_ich8lan(hw, act_offset, dword);\n\n\tif (ret_val)\n\t\tgoto release;\n\n\t \n\tact_offset = old_bank_offset + E1000_ICH_NVM_SIG_WORD - 1;\n\tret_val = e1000_read_flash_dword_ich8lan(hw, act_offset, &dword);\n\n\tif (ret_val)\n\t\tgoto release;\n\n\tdword &= 0x00FFFFFF;\n\tret_val = e1000_retry_write_flash_dword_ich8lan(hw, act_offset, dword);\n\n\tif (ret_val)\n\t\tgoto release;\n\n\t \n\tfor (i = 0; i < E1000_ICH8_SHADOW_RAM_WORDS; i++) {\n\t\tdev_spec->shadow_ram[i].modified = false;\n\t\tdev_spec->shadow_ram[i].value = 0xFFFF;\n\t}\n\nrelease:\n\tnvm->ops.release(hw);\n\n\t \n\tif (!ret_val) {\n\t\tnvm->ops.reload(hw);\n\t\tusleep_range(10000, 11000);\n\t}\n\nout:\n\tif (ret_val)\n\t\te_dbg(\"NVM update error: %d\\n\", ret_val);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_update_nvm_checksum_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu32 i, act_offset, new_bank_offset, old_bank_offset, bank;\n\ts32 ret_val;\n\tu16 data = 0;\n\n\tret_val = e1000e_update_nvm_checksum_generic(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (nvm->type != e1000_nvm_flash_sw)\n\t\tgoto out;\n\n\tnvm->ops.acquire(hw);\n\n\t \n\tret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &bank);\n\tif (ret_val) {\n\t\te_dbg(\"Could not detect valid bank, assuming bank 0\\n\");\n\t\tbank = 0;\n\t}\n\n\tif (bank == 0) {\n\t\tnew_bank_offset = nvm->flash_bank_size;\n\t\told_bank_offset = 0;\n\t\tret_val = e1000_erase_flash_bank_ich8lan(hw, 1);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t} else {\n\t\told_bank_offset = nvm->flash_bank_size;\n\t\tnew_bank_offset = 0;\n\t\tret_val = e1000_erase_flash_bank_ich8lan(hw, 0);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\tfor (i = 0; i < E1000_ICH8_SHADOW_RAM_WORDS; i++) {\n\t\tif (dev_spec->shadow_ram[i].modified) {\n\t\t\tdata = dev_spec->shadow_ram[i].value;\n\t\t} else {\n\t\t\tret_val = e1000_read_flash_word_ich8lan(hw, i +\n\t\t\t\t\t\t\t\told_bank_offset,\n\t\t\t\t\t\t\t\t&data);\n\t\t\tif (ret_val)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i == E1000_ICH_NVM_SIG_WORD)\n\t\t\tdata |= E1000_ICH_NVM_SIG_MASK;\n\n\t\t \n\t\tact_offset = (i + new_bank_offset) << 1;\n\n\t\tusleep_range(100, 200);\n\t\t \n\t\tret_val = e1000_retry_write_flash_byte_ich8lan(hw,\n\t\t\t\t\t\t\t       act_offset,\n\t\t\t\t\t\t\t       (u8)data);\n\t\tif (ret_val)\n\t\t\tbreak;\n\n\t\tusleep_range(100, 200);\n\t\tret_val = e1000_retry_write_flash_byte_ich8lan(hw,\n\t\t\t\t\t\t\t       act_offset + 1,\n\t\t\t\t\t\t\t       (u8)(data >> 8));\n\t\tif (ret_val)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (ret_val) {\n\t\t \n\t\te_dbg(\"Flash commit failed.\\n\");\n\t\tgoto release;\n\t}\n\n\t \n\tact_offset = new_bank_offset + E1000_ICH_NVM_SIG_WORD;\n\tret_val = e1000_read_flash_word_ich8lan(hw, act_offset, &data);\n\tif (ret_val)\n\t\tgoto release;\n\n\tdata &= 0xBFFF;\n\tret_val = e1000_retry_write_flash_byte_ich8lan(hw,\n\t\t\t\t\t\t       act_offset * 2 + 1,\n\t\t\t\t\t\t       (u8)(data >> 8));\n\tif (ret_val)\n\t\tgoto release;\n\n\t \n\tact_offset = (old_bank_offset + E1000_ICH_NVM_SIG_WORD) * 2 + 1;\n\tret_val = e1000_retry_write_flash_byte_ich8lan(hw, act_offset, 0);\n\tif (ret_val)\n\t\tgoto release;\n\n\t \n\tfor (i = 0; i < E1000_ICH8_SHADOW_RAM_WORDS; i++) {\n\t\tdev_spec->shadow_ram[i].modified = false;\n\t\tdev_spec->shadow_ram[i].value = 0xFFFF;\n\t}\n\nrelease:\n\tnvm->ops.release(hw);\n\n\t \n\tif (!ret_val) {\n\t\tnvm->ops.reload(hw);\n\t\tusleep_range(10000, 11000);\n\t}\n\nout:\n\tif (ret_val)\n\t\te_dbg(\"NVM update error: %d\\n\", ret_val);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_validate_nvm_checksum_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 data;\n\tu16 word;\n\tu16 valid_csum_mask;\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tword = NVM_COMPAT;\n\t\tvalid_csum_mask = NVM_COMPAT_VALID_CSUM;\n\t\tbreak;\n\tdefault:\n\t\tword = NVM_FUTURE_INIT_WORD1;\n\t\tvalid_csum_mask = NVM_FUTURE_INIT_WORD1_VALID_CSUM;\n\t\tbreak;\n\t}\n\n\tret_val = e1000_read_nvm(hw, word, 1, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!(data & valid_csum_mask)) {\n\t\te_dbg(\"NVM Checksum valid bit not set\\n\");\n\n\t\tif (hw->mac.type < e1000_pch_tgp) {\n\t\t\tdata |= valid_csum_mask;\n\t\t\tret_val = e1000_write_nvm(hw, word, 1, &data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tret_val = e1000e_update_nvm_checksum(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\treturn e1000e_validate_nvm_checksum_generic(hw);\n}\n\n \nvoid e1000e_write_protect_nvm_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tunion ich8_flash_protected_range pr0;\n\tunion ich8_hws_flash_status hsfsts;\n\tu32 gfpreg;\n\n\tnvm->ops.acquire(hw);\n\n\tgfpreg = er32flash(ICH_FLASH_GFPREG);\n\n\t \n\tpr0.regval = er32flash(ICH_FLASH_PR0);\n\tpr0.range.base = gfpreg & FLASH_GFPREG_BASE_MASK;\n\tpr0.range.limit = ((gfpreg >> 16) & FLASH_GFPREG_BASE_MASK);\n\tpr0.range.wpe = true;\n\tew32flash(ICH_FLASH_PR0, pr0.regval);\n\n\t \n\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\thsfsts.hsf_status.flockdn = true;\n\tew32flash(ICH_FLASH_HSFSTS, hsfsts.regval);\n\n\tnvm->ops.release(hw);\n}\n\n \nstatic s32 e1000_write_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u8 size, u16 data)\n{\n\tunion ich8_hws_flash_status hsfsts;\n\tunion ich8_hws_flash_ctrl hsflctl;\n\tu32 flash_linear_addr;\n\tu32 flash_data = 0;\n\ts32 ret_val;\n\tu8 count = 0;\n\n\tif (hw->mac.type >= e1000_pch_spt) {\n\t\tif (size != 4 || offset > ICH_FLASH_LINEAR_ADDR_MASK)\n\t\t\treturn -E1000_ERR_NVM;\n\t} else {\n\t\tif (size < 1 || size > 2 || offset > ICH_FLASH_LINEAR_ADDR_MASK)\n\t\t\treturn -E1000_ERR_NVM;\n\t}\n\n\tflash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK & offset) +\n\t\t\t     hw->nvm.flash_base_addr);\n\n\tdo {\n\t\tudelay(1);\n\t\t \n\t\tret_val = e1000_flash_cycle_init_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\t \n\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\thsflctl.regval = er32flash(ICH_FLASH_HSFSTS) >> 16;\n\t\telse\n\t\t\thsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\n\n\t\t \n\t\thsflctl.hsf_ctrl.fldbcount = size - 1;\n\t\thsflctl.hsf_ctrl.flcycle = ICH_CYCLE_WRITE;\n\t\t \n\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\tew32flash(ICH_FLASH_HSFSTS, hsflctl.regval << 16);\n\t\telse\n\t\t\tew16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\n\n\t\tew32flash(ICH_FLASH_FADDR, flash_linear_addr);\n\n\t\tif (size == 1)\n\t\t\tflash_data = (u32)data & 0x00FF;\n\t\telse\n\t\t\tflash_data = (u32)data;\n\n\t\tew32flash(ICH_FLASH_FDATA0, flash_data);\n\n\t\t \n\t\tret_val =\n\t\t    e1000_flash_cycle_ich8lan(hw,\n\t\t\t\t\t      ICH_FLASH_WRITE_COMMAND_TIMEOUT);\n\t\tif (!ret_val)\n\t\t\tbreak;\n\n\t\t \n\t\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\t\tif (hsfsts.hsf_status.flcerr)\n\t\t\t \n\t\t\tcontinue;\n\t\tif (!hsfsts.hsf_status.flcdone) {\n\t\t\te_dbg(\"Timeout error - flash cycle did not complete.\\n\");\n\t\t\tbreak;\n\t\t}\n\t} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_flash_data32_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t    u32 data)\n{\n\tunion ich8_hws_flash_status hsfsts;\n\tunion ich8_hws_flash_ctrl hsflctl;\n\tu32 flash_linear_addr;\n\ts32 ret_val;\n\tu8 count = 0;\n\n\tif (hw->mac.type >= e1000_pch_spt) {\n\t\tif (offset > ICH_FLASH_LINEAR_ADDR_MASK)\n\t\t\treturn -E1000_ERR_NVM;\n\t}\n\tflash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK & offset) +\n\t\t\t     hw->nvm.flash_base_addr);\n\tdo {\n\t\tudelay(1);\n\t\t \n\t\tret_val = e1000_flash_cycle_init_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\tbreak;\n\n\t\t \n\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\thsflctl.regval = er32flash(ICH_FLASH_HSFSTS)\n\t\t\t    >> 16;\n\t\telse\n\t\t\thsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\n\n\t\thsflctl.hsf_ctrl.fldbcount = sizeof(u32) - 1;\n\t\thsflctl.hsf_ctrl.flcycle = ICH_CYCLE_WRITE;\n\n\t\t \n\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\tew32flash(ICH_FLASH_HSFSTS, hsflctl.regval << 16);\n\t\telse\n\t\t\tew16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\n\n\t\tew32flash(ICH_FLASH_FADDR, flash_linear_addr);\n\n\t\tew32flash(ICH_FLASH_FDATA0, data);\n\n\t\t \n\t\tret_val =\n\t\t   e1000_flash_cycle_ich8lan(hw,\n\t\t\t\t\t     ICH_FLASH_WRITE_COMMAND_TIMEOUT);\n\n\t\tif (!ret_val)\n\t\t\tbreak;\n\n\t\t \n\t\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\n\t\tif (hsfsts.hsf_status.flcerr)\n\t\t\t \n\t\t\tcontinue;\n\t\tif (!hsfsts.hsf_status.flcdone) {\n\t\t\te_dbg(\"Timeout error - flash cycle did not complete.\\n\");\n\t\t\tbreak;\n\t\t}\n\t} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_flash_byte_ich8lan(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u8 data)\n{\n\tu16 word = (u16)data;\n\n\treturn e1000_write_flash_data_ich8lan(hw, offset, 1, word);\n}\n\n \nstatic s32 e1000_retry_write_flash_dword_ich8lan(struct e1000_hw *hw,\n\t\t\t\t\t\t u32 offset, u32 dword)\n{\n\ts32 ret_val;\n\tu16 program_retries;\n\n\t \n\toffset <<= 1;\n\tret_val = e1000_write_flash_data32_ich8lan(hw, offset, dword);\n\n\tif (!ret_val)\n\t\treturn ret_val;\n\tfor (program_retries = 0; program_retries < 100; program_retries++) {\n\t\te_dbg(\"Retrying Byte %8.8X at offset %u\\n\", dword, offset);\n\t\tusleep_range(100, 200);\n\t\tret_val = e1000_write_flash_data32_ich8lan(hw, offset, dword);\n\t\tif (!ret_val)\n\t\t\tbreak;\n\t}\n\tif (program_retries == 100)\n\t\treturn -E1000_ERR_NVM;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_retry_write_flash_byte_ich8lan(struct e1000_hw *hw,\n\t\t\t\t\t\tu32 offset, u8 byte)\n{\n\ts32 ret_val;\n\tu16 program_retries;\n\n\tret_val = e1000_write_flash_byte_ich8lan(hw, offset, byte);\n\tif (!ret_val)\n\t\treturn ret_val;\n\n\tfor (program_retries = 0; program_retries < 100; program_retries++) {\n\t\te_dbg(\"Retrying Byte %2.2X at offset %u\\n\", byte, offset);\n\t\tusleep_range(100, 200);\n\t\tret_val = e1000_write_flash_byte_ich8lan(hw, offset, byte);\n\t\tif (!ret_val)\n\t\t\tbreak;\n\t}\n\tif (program_retries == 100)\n\t\treturn -E1000_ERR_NVM;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_erase_flash_bank_ich8lan(struct e1000_hw *hw, u32 bank)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tunion ich8_hws_flash_status hsfsts;\n\tunion ich8_hws_flash_ctrl hsflctl;\n\tu32 flash_linear_addr;\n\t \n\tu32 flash_bank_size = nvm->flash_bank_size * 2;\n\ts32 ret_val;\n\ts32 count = 0;\n\ts32 j, iteration, sector_size;\n\n\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\n\t \n\tswitch (hsfsts.hsf_status.berasesz) {\n\tcase 0:\n\t\t \n\t\tsector_size = ICH_FLASH_SEG_SIZE_256;\n\t\titeration = flash_bank_size / ICH_FLASH_SEG_SIZE_256;\n\t\tbreak;\n\tcase 1:\n\t\tsector_size = ICH_FLASH_SEG_SIZE_4K;\n\t\titeration = 1;\n\t\tbreak;\n\tcase 2:\n\t\tsector_size = ICH_FLASH_SEG_SIZE_8K;\n\t\titeration = 1;\n\t\tbreak;\n\tcase 3:\n\t\tsector_size = ICH_FLASH_SEG_SIZE_64K;\n\t\titeration = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\t \n\tflash_linear_addr = hw->nvm.flash_base_addr;\n\tflash_linear_addr += (bank) ? flash_bank_size : 0;\n\n\tfor (j = 0; j < iteration; j++) {\n\t\tdo {\n\t\t\tu32 timeout = ICH_FLASH_ERASE_COMMAND_TIMEOUT;\n\n\t\t\t \n\t\t\tret_val = e1000_flash_cycle_init_ich8lan(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\t \n\t\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\t\thsflctl.regval =\n\t\t\t\t    er32flash(ICH_FLASH_HSFSTS) >> 16;\n\t\t\telse\n\t\t\t\thsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\n\n\t\t\thsflctl.hsf_ctrl.flcycle = ICH_CYCLE_ERASE;\n\t\t\tif (hw->mac.type >= e1000_pch_spt)\n\t\t\t\tew32flash(ICH_FLASH_HSFSTS,\n\t\t\t\t\t  hsflctl.regval << 16);\n\t\t\telse\n\t\t\t\tew16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\n\n\t\t\t \n\t\t\tflash_linear_addr += (j * sector_size);\n\t\t\tew32flash(ICH_FLASH_FADDR, flash_linear_addr);\n\n\t\t\tret_val = e1000_flash_cycle_ich8lan(hw, timeout);\n\t\t\tif (!ret_val)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\thsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\n\t\t\tif (hsfsts.hsf_status.flcerr)\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\telse if (!hsfsts.hsf_status.flcdone)\n\t\t\t\treturn ret_val;\n\t\t} while (++count < ICH_FLASH_CYCLE_REPEAT_COUNT);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_valid_led_default_ich8lan(struct e1000_hw *hw, u16 *data)\n{\n\ts32 ret_val;\n\n\tret_val = e1000_read_nvm(hw, NVM_ID_LED_SETTINGS, 1, data);\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tif (*data == ID_LED_RESERVED_0000 || *data == ID_LED_RESERVED_FFFF)\n\t\t*data = ID_LED_DEFAULT_ICH8LAN;\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_id_led_init_pchlan(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val;\n\tconst u32 ledctl_on = E1000_LEDCTL_MODE_LINK_UP;\n\tconst u32 ledctl_off = E1000_LEDCTL_MODE_LINK_UP | E1000_PHY_LED0_IVRT;\n\tu16 data, i, temp, shift;\n\n\t \n\tret_val = hw->nvm.ops.valid_led_default(hw, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tmac->ledctl_default = er32(LEDCTL);\n\tmac->ledctl_mode1 = mac->ledctl_default;\n\tmac->ledctl_mode2 = mac->ledctl_default;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttemp = (data >> (i << 2)) & E1000_LEDCTL_LED0_MODE_MASK;\n\t\tshift = (i * 5);\n\t\tswitch (temp) {\n\t\tcase ID_LED_ON1_DEF2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\t\tmac->ledctl_mode1 &= ~(E1000_PHY_LED0_MASK << shift);\n\t\t\tmac->ledctl_mode1 |= (ledctl_on << shift);\n\t\t\tbreak;\n\t\tcase ID_LED_OFF1_DEF2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\tmac->ledctl_mode1 &= ~(E1000_PHY_LED0_MASK << shift);\n\t\t\tmac->ledctl_mode1 |= (ledctl_off << shift);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tswitch (temp) {\n\t\tcase ID_LED_DEF1_ON2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\t\tmac->ledctl_mode2 &= ~(E1000_PHY_LED0_MASK << shift);\n\t\t\tmac->ledctl_mode2 |= (ledctl_on << shift);\n\t\t\tbreak;\n\t\tcase ID_LED_DEF1_OFF2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\tmac->ledctl_mode2 &= ~(E1000_PHY_LED0_MASK << shift);\n\t\t\tmac->ledctl_mode2 |= (ledctl_off << shift);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_get_bus_info_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_bus_info *bus = &hw->bus;\n\ts32 ret_val;\n\n\tret_val = e1000e_get_bus_info_pcie(hw);\n\n\t \n\tif (bus->width == e1000_bus_width_unknown)\n\t\tbus->width = e1000_bus_width_pcie_x1;\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_reset_hw_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu16 kum_cfg;\n\tu32 ctrl, reg;\n\ts32 ret_val;\n\n\t \n\tret_val = e1000e_disable_pcie_master(hw);\n\tif (ret_val)\n\t\te_dbg(\"PCI-E Master disable polling has failed.\\n\");\n\n\te_dbg(\"Masking off all interrupts\\n\");\n\tew32(IMC, 0xffffffff);\n\n\t \n\tew32(RCTL, 0);\n\tew32(TCTL, E1000_TCTL_PSP);\n\te1e_flush();\n\n\tusleep_range(10000, 11000);\n\n\t \n\tif (hw->mac.type == e1000_ich8lan) {\n\t\t \n\t\tew32(PBA, E1000_PBA_8K);\n\t\t \n\t\tew32(PBS, E1000_PBS_16K);\n\t}\n\n\tif (hw->mac.type == e1000_pchlan) {\n\t\t \n\t\tret_val = e1000_read_nvm(hw, E1000_NVM_K1_CONFIG, 1, &kum_cfg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (kum_cfg & E1000_NVM_K1_ENABLE)\n\t\t\tdev_spec->nvm_k1_enabled = true;\n\t\telse\n\t\t\tdev_spec->nvm_k1_enabled = false;\n\t}\n\n\tctrl = er32(CTRL);\n\n\tif (!hw->phy.ops.check_reset_block(hw)) {\n\t\t \n\t\tctrl |= E1000_CTRL_PHY_RST;\n\n\t\t \n\t\tif ((hw->mac.type == e1000_pch2lan) &&\n\t\t    !(er32(FWSM) & E1000_ICH_FWSM_FW_VALID))\n\t\t\te1000_gate_hw_phy_config_ich8lan(hw, true);\n\t}\n\tret_val = e1000_acquire_swflag_ich8lan(hw);\n\te_dbg(\"Issuing a global reset to ich8lan\\n\");\n\tew32(CTRL, (ctrl | E1000_CTRL_RST));\n\t \n\tmsleep(20);\n\n\t \n\tif (hw->mac.type == e1000_pch2lan) {\n\t\treg = er32(FEXTNVM3);\n\t\treg &= ~E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK;\n\t\treg |= E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC;\n\t\tew32(FEXTNVM3, reg);\n\t}\n\n\tif (!ret_val)\n\t\tclear_bit(__E1000_ACCESS_SHARED_RESOURCE, &hw->adapter->state);\n\n\tif (ctrl & E1000_CTRL_PHY_RST) {\n\t\tret_val = hw->phy.ops.get_cfg_done(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1000_post_phy_reset_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tif (hw->mac.type == e1000_pchlan)\n\t\tew32(CRC_OFFSET, 0x65656565);\n\n\tew32(IMC, 0xffffffff);\n\ter32(ICR);\n\n\treg = er32(KABGTXD);\n\treg |= E1000_KABGTXD_BGSQLBIAS;\n\tew32(KABGTXD, reg);\n\n\treturn 0;\n}\n\n \nstatic s32 e1000_init_hw_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 ctrl_ext, txdctl, snoop, fflt_dbg;\n\ts32 ret_val;\n\tu16 i;\n\n\te1000_initialize_hw_bits_ich8lan(hw);\n\n\t \n\tret_val = mac->ops.id_led_init(hw);\n\t \n\tif (ret_val)\n\t\te_dbg(\"Error initializing identification LED\\n\");\n\n\t \n\te1000e_init_rx_addrs(hw, mac->rar_entry_count);\n\n\t \n\te_dbg(\"Zeroing the MTA\\n\");\n\tfor (i = 0; i < mac->mta_reg_count; i++)\n\t\tE1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);\n\n\t \n\tif (hw->phy.type == e1000_phy_82578) {\n\t\te1e_rphy(hw, BM_PORT_GEN_CFG, &i);\n\t\ti &= ~BM_WUC_HOST_WU_BIT;\n\t\te1e_wphy(hw, BM_PORT_GEN_CFG, i);\n\t\tret_val = e1000_phy_hw_reset_ich8lan(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tret_val = mac->ops.setup_link(hw);\n\n\t \n\ttxdctl = er32(TXDCTL(0));\n\ttxdctl = ((txdctl & ~E1000_TXDCTL_WTHRESH) |\n\t\t  E1000_TXDCTL_FULL_TX_DESC_WB);\n\ttxdctl = ((txdctl & ~E1000_TXDCTL_PTHRESH) |\n\t\t  E1000_TXDCTL_MAX_TX_DESC_PREFETCH);\n\tew32(TXDCTL(0), txdctl);\n\ttxdctl = er32(TXDCTL(1));\n\ttxdctl = ((txdctl & ~E1000_TXDCTL_WTHRESH) |\n\t\t  E1000_TXDCTL_FULL_TX_DESC_WB);\n\ttxdctl = ((txdctl & ~E1000_TXDCTL_PTHRESH) |\n\t\t  E1000_TXDCTL_MAX_TX_DESC_PREFETCH);\n\tew32(TXDCTL(1), txdctl);\n\n\t \n\tif (mac->type == e1000_ich8lan)\n\t\tsnoop = PCIE_ICH8_SNOOP_ALL;\n\telse\n\t\tsnoop = (u32)~(PCIE_NO_SNOOP_ALL);\n\te1000e_set_pcie_no_snoop(hw, snoop);\n\n\t \n\tif (mac->type >= e1000_pch_tgp) {\n\t\tfflt_dbg = er32(FFLT_DBG);\n\t\tfflt_dbg |= E1000_FFLT_DBG_DONT_GATE_WAKE_DMA_CLK;\n\t\tew32(FFLT_DBG, fflt_dbg);\n\t}\n\n\tctrl_ext = er32(CTRL_EXT);\n\tctrl_ext |= E1000_CTRL_EXT_RO_DIS;\n\tew32(CTRL_EXT, ctrl_ext);\n\n\t \n\te1000_clear_hw_cntrs_ich8lan(hw);\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_initialize_hw_bits_ich8lan(struct e1000_hw *hw)\n{\n\tu32 reg;\n\n\t \n\treg = er32(CTRL_EXT);\n\treg |= BIT(22);\n\t \n\tif (hw->mac.type >= e1000_pchlan)\n\t\treg |= E1000_CTRL_EXT_PHYPDEN;\n\tew32(CTRL_EXT, reg);\n\n\t \n\treg = er32(TXDCTL(0));\n\treg |= BIT(22);\n\tew32(TXDCTL(0), reg);\n\n\t \n\treg = er32(TXDCTL(1));\n\treg |= BIT(22);\n\tew32(TXDCTL(1), reg);\n\n\t \n\treg = er32(TARC(0));\n\tif (hw->mac.type == e1000_ich8lan)\n\t\treg |= BIT(28) | BIT(29);\n\treg |= BIT(23) | BIT(24) | BIT(26) | BIT(27);\n\tew32(TARC(0), reg);\n\n\t \n\treg = er32(TARC(1));\n\tif (er32(TCTL) & E1000_TCTL_MULR)\n\t\treg &= ~BIT(28);\n\telse\n\t\treg |= BIT(28);\n\treg |= BIT(24) | BIT(26) | BIT(30);\n\tew32(TARC(1), reg);\n\n\t \n\tif (hw->mac.type == e1000_ich8lan) {\n\t\treg = er32(STATUS);\n\t\treg &= ~BIT(31);\n\t\tew32(STATUS, reg);\n\t}\n\n\t \n\treg = er32(RFCTL);\n\treg |= (E1000_RFCTL_NFSW_DIS | E1000_RFCTL_NFSR_DIS);\n\n\t \n\tif (hw->mac.type == e1000_ich8lan)\n\t\treg |= (E1000_RFCTL_IPV6_EX_DIS | E1000_RFCTL_NEW_IPV6_EXT_DIS);\n\tew32(RFCTL, reg);\n\n\t \n\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\treg = er32(PBECCSTS);\n\t\treg |= E1000_PBECCSTS_ECC_ENABLE;\n\t\tew32(PBECCSTS, reg);\n\n\t\treg = er32(CTRL);\n\t\treg |= E1000_CTRL_MEHE;\n\t\tew32(CTRL, reg);\n\t}\n}\n\n \nstatic s32 e1000_setup_link_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tif (hw->phy.ops.check_reset_block(hw))\n\t\treturn 0;\n\n\t \n\tif (hw->fc.requested_mode == e1000_fc_default) {\n\t\t \n\t\tif (hw->mac.type == e1000_pchlan)\n\t\t\thw->fc.requested_mode = e1000_fc_rx_pause;\n\t\telse\n\t\t\thw->fc.requested_mode = e1000_fc_full;\n\t}\n\n\t \n\thw->fc.current_mode = hw->fc.requested_mode;\n\n\te_dbg(\"After fix-ups FlowControl is now = %x\\n\", hw->fc.current_mode);\n\n\t \n\tret_val = hw->mac.ops.setup_physical_interface(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tew32(FCTTV, hw->fc.pause_time);\n\tif ((hw->phy.type == e1000_phy_82578) ||\n\t    (hw->phy.type == e1000_phy_82579) ||\n\t    (hw->phy.type == e1000_phy_i217) ||\n\t    (hw->phy.type == e1000_phy_82577)) {\n\t\tew32(FCRTV_PCH, hw->fc.refresh_time);\n\n\t\tret_val = e1e_wphy(hw, PHY_REG(BM_PORT_CTRL_PAGE, 27),\n\t\t\t\t   hw->fc.pause_time);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn e1000e_set_fc_watermarks(hw);\n}\n\n \nstatic s32 e1000_setup_copper_link_ich8lan(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\tu16 reg_data;\n\n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_SLU;\n\tctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tew32(CTRL, ctrl);\n\n\t \n\tret_val = e1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_TIMEOUTS, 0xFFFF);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = e1000e_read_kmrn_reg(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\n\t\t\t\t       &reg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\treg_data |= 0x3F;\n\tret_val = e1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\n\t\t\t\t\treg_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tswitch (hw->phy.type) {\n\tcase e1000_phy_igp_3:\n\t\tret_val = e1000e_copper_link_setup_igp(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\tcase e1000_phy_bm:\n\tcase e1000_phy_82578:\n\t\tret_val = e1000e_copper_link_setup_m88(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\tcase e1000_phy_82577:\n\tcase e1000_phy_82579:\n\t\tret_val = e1000_copper_link_setup_82577(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\tcase e1000_phy_ife:\n\t\tret_val = e1e_rphy(hw, IFE_PHY_MDIX_CONTROL, &reg_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\treg_data &= ~IFE_PMC_AUTO_MDIX;\n\n\t\tswitch (hw->phy.mdix) {\n\t\tcase 1:\n\t\t\treg_data &= ~IFE_PMC_FORCE_MDIX;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\treg_data |= IFE_PMC_FORCE_MDIX;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\treg_data |= IFE_PMC_AUTO_MDIX;\n\t\t\tbreak;\n\t\t}\n\t\tret_val = e1e_wphy(hw, IFE_PHY_MDIX_CONTROL, reg_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn e1000e_setup_copper_link(hw);\n}\n\n \nstatic s32 e1000_setup_copper_link_pch_lpt(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_SLU;\n\tctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tew32(CTRL, ctrl);\n\n\tret_val = e1000_copper_link_setup_82577(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn e1000e_setup_copper_link(hw);\n}\n\n \nstatic s32 e1000_get_link_up_info_ich8lan(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t\t  u16 *duplex)\n{\n\ts32 ret_val;\n\n\tret_val = e1000e_get_speed_and_duplex_copper(hw, speed, duplex);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif ((hw->mac.type == e1000_ich8lan) &&\n\t    (hw->phy.type == e1000_phy_igp_3) && (*speed == SPEED_1000)) {\n\t\tret_val = e1000_kmrn_lock_loss_workaround_ich8lan(hw);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu32 phy_ctrl;\n\ts32 ret_val;\n\tu16 i, data;\n\tbool link;\n\n\tif (!dev_spec->kmrn_lock_loss_workaround_enabled)\n\t\treturn 0;\n\n\t \n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (!link)\n\t\treturn 0;\n\n\tfor (i = 0; i < 10; i++) {\n\t\t \n\t\tret_val = e1e_rphy(hw, IGP3_KMRN_DIAG, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\t \n\t\tret_val = e1e_rphy(hw, IGP3_KMRN_DIAG, &data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tif (!(data & IGP3_KMRN_DIAG_PCS_LOCK_LOSS))\n\t\t\treturn 0;\n\n\t\t \n\t\te1000_phy_hw_reset(hw);\n\t\tmdelay(5);\n\t}\n\t \n\tphy_ctrl = er32(PHY_CTRL);\n\tphy_ctrl |= (E1000_PHY_CTRL_GBE_DISABLE |\n\t\t     E1000_PHY_CTRL_NOND0A_GBE_DISABLE);\n\tew32(PHY_CTRL, phy_ctrl);\n\n\t \n\te1000e_gig_downshift_workaround_ich8lan(hw);\n\n\t \n\treturn -E1000_ERR_PHY;\n}\n\n \nvoid e1000e_set_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw,\n\t\t\t\t\t\t  bool state)\n{\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\n\tif (hw->mac.type != e1000_ich8lan) {\n\t\te_dbg(\"Workaround applies to ICH8 only.\\n\");\n\t\treturn;\n\t}\n\n\tdev_spec->kmrn_lock_loss_workaround_enabled = state;\n}\n\n \nvoid e1000e_igp3_phy_powerdown_workaround_ich8lan(struct e1000_hw *hw)\n{\n\tu32 reg;\n\tu16 data;\n\tu8 retry = 0;\n\n\tif (hw->phy.type != e1000_phy_igp_3)\n\t\treturn;\n\n\t \n\tdo {\n\t\t \n\t\treg = er32(PHY_CTRL);\n\t\treg |= (E1000_PHY_CTRL_GBE_DISABLE |\n\t\t\tE1000_PHY_CTRL_NOND0A_GBE_DISABLE);\n\t\tew32(PHY_CTRL, reg);\n\n\t\t \n\t\tif (hw->mac.type == e1000_ich8lan)\n\t\t\te1000e_gig_downshift_workaround_ich8lan(hw);\n\n\t\t \n\t\te1e_rphy(hw, IGP3_VR_CTRL, &data);\n\t\tdata &= ~IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK;\n\t\te1e_wphy(hw, IGP3_VR_CTRL, data | IGP3_VR_CTRL_MODE_SHUTDOWN);\n\n\t\t \n\t\te1e_rphy(hw, IGP3_VR_CTRL, &data);\n\t\tdata &= IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK;\n\t\tif ((data == IGP3_VR_CTRL_MODE_SHUTDOWN) || retry)\n\t\t\tbreak;\n\n\t\t \n\t\treg = er32(CTRL);\n\t\tew32(CTRL, reg | E1000_CTRL_PHY_RST);\n\t\tretry++;\n\t} while (retry);\n}\n\n \nvoid e1000e_gig_downshift_workaround_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 reg_data;\n\n\tif ((hw->mac.type != e1000_ich8lan) || (hw->phy.type == e1000_phy_ife))\n\t\treturn;\n\n\tret_val = e1000e_read_kmrn_reg(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET,\n\t\t\t\t       &reg_data);\n\tif (ret_val)\n\t\treturn;\n\treg_data |= E1000_KMRNCTRLSTA_DIAG_NELPBK;\n\tret_val = e1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET,\n\t\t\t\t\treg_data);\n\tif (ret_val)\n\t\treturn;\n\treg_data &= ~E1000_KMRNCTRLSTA_DIAG_NELPBK;\n\te1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET, reg_data);\n}\n\n \nvoid e1000_suspend_workarounds_ich8lan(struct e1000_hw *hw)\n{\n\tstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\n\tu32 phy_ctrl;\n\ts32 ret_val;\n\n\tphy_ctrl = er32(PHY_CTRL);\n\tphy_ctrl |= E1000_PHY_CTRL_GBE_DISABLE;\n\n\tif (hw->phy.type == e1000_phy_i217) {\n\t\tu16 phy_reg, device_id = hw->adapter->pdev->device;\n\n\t\tif ((device_id == E1000_DEV_ID_PCH_LPTLP_I218_LM) ||\n\t\t    (device_id == E1000_DEV_ID_PCH_LPTLP_I218_V) ||\n\t\t    (device_id == E1000_DEV_ID_PCH_I218_LM3) ||\n\t\t    (device_id == E1000_DEV_ID_PCH_I218_V3) ||\n\t\t    (hw->mac.type >= e1000_pch_spt)) {\n\t\t\tu32 fextnvm6 = er32(FEXTNVM6);\n\n\t\t\tew32(FEXTNVM6, fextnvm6 & ~E1000_FEXTNVM6_REQ_PLL_CLK);\n\t\t}\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (!dev_spec->eee_disable) {\n\t\t\tu16 eee_advert;\n\n\t\t\tret_val =\n\t\t\t    e1000_read_emi_reg_locked(hw,\n\t\t\t\t\t\t      I217_EEE_ADVERTISEMENT,\n\t\t\t\t\t\t      &eee_advert);\n\t\t\tif (ret_val)\n\t\t\t\tgoto release;\n\n\t\t\t \n\t\t\tif ((eee_advert & I82579_EEE_100_SUPPORTED) &&\n\t\t\t    (dev_spec->eee_lp_ability &\n\t\t\t     I82579_EEE_100_SUPPORTED) &&\n\t\t\t    (hw->phy.autoneg_advertised & ADVERTISE_100_FULL)) {\n\t\t\t\tphy_ctrl &= ~(E1000_PHY_CTRL_D0A_LPLU |\n\t\t\t\t\t      E1000_PHY_CTRL_NOND0A_LPLU);\n\n\t\t\t\t \n\t\t\t\te1e_rphy_locked(hw,\n\t\t\t\t\t\tI217_LPI_GPIO_CTRL, &phy_reg);\n\t\t\t\tphy_reg |= I217_LPI_GPIO_CTRL_AUTO_EN_LPI;\n\t\t\t\te1e_wphy_locked(hw,\n\t\t\t\t\t\tI217_LPI_GPIO_CTRL, phy_reg);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID)) {\n\t\t\t \n\t\t\te1e_rphy_locked(hw, I217_PROXY_CTRL, &phy_reg);\n\t\t\tphy_reg |= I217_PROXY_CTRL_AUTO_DISABLE;\n\t\t\te1e_wphy_locked(hw, I217_PROXY_CTRL, phy_reg);\n\n\t\t\t \n\t\t\te1e_rphy_locked(hw, I217_SxCTRL, &phy_reg);\n\t\t\tphy_reg |= I217_SxCTRL_ENABLE_LPI_RESET;\n\t\t\te1e_wphy_locked(hw, I217_SxCTRL, phy_reg);\n\n\t\t\t \n\t\t\te1e_rphy_locked(hw, I217_MEMPWR, &phy_reg);\n\t\t\tphy_reg &= ~I217_MEMPWR_DISABLE_SMB_RELEASE;\n\t\t\te1e_wphy_locked(hw, I217_MEMPWR, phy_reg);\n\t\t}\n\n\t\t \n\t\te1e_rphy_locked(hw, I217_CGFREG, &phy_reg);\n\t\tphy_reg |= I217_CGFREG_ENABLE_MTA_RESET;\n\t\te1e_wphy_locked(hw, I217_CGFREG, phy_reg);\n\nrelease:\n\t\thw->phy.ops.release(hw);\n\t}\nout:\n\tew32(PHY_CTRL, phy_ctrl);\n\n\tif (hw->mac.type == e1000_ich8lan)\n\t\te1000e_gig_downshift_workaround_ich8lan(hw);\n\n\tif (hw->mac.type >= e1000_pchlan) {\n\t\te1000_oem_bits_config_ich8lan(hw, false);\n\n\t\t \n\t\tif (hw->mac.type == e1000_pchlan)\n\t\t\te1000e_phy_hw_reset_generic(hw);\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn;\n\t\te1000_write_smbus_addr(hw);\n\t\thw->phy.ops.release(hw);\n\t}\n}\n\n \nvoid e1000_resume_workarounds_pchlan(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tif (hw->mac.type < e1000_pch2lan)\n\t\treturn;\n\n\tret_val = e1000_init_phy_workarounds_pchlan(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Failed to init PHY flow ret_val=%d\\n\", ret_val);\n\t\treturn;\n\t}\n\n\t \n\tif (hw->phy.type == e1000_phy_i217) {\n\t\tu16 phy_reg;\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Failed to setup iRST\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\te1e_rphy_locked(hw, I217_LPI_GPIO_CTRL, &phy_reg);\n\t\tphy_reg &= ~I217_LPI_GPIO_CTRL_AUTO_EN_LPI;\n\t\te1e_wphy_locked(hw, I217_LPI_GPIO_CTRL, phy_reg);\n\n\t\tif (!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID)) {\n\t\t\t \n\t\t\tret_val = e1e_rphy_locked(hw, I217_MEMPWR, &phy_reg);\n\t\t\tif (ret_val)\n\t\t\t\tgoto release;\n\t\t\tphy_reg |= I217_MEMPWR_DISABLE_SMB_RELEASE;\n\t\t\te1e_wphy_locked(hw, I217_MEMPWR, phy_reg);\n\n\t\t\t \n\t\t\te1e_wphy_locked(hw, I217_PROXY_CTRL, 0);\n\t\t}\n\t\t \n\t\tret_val = e1e_rphy_locked(hw, I217_CGFREG, &phy_reg);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t\tphy_reg &= ~I217_CGFREG_ENABLE_MTA_RESET;\n\t\te1e_wphy_locked(hw, I217_CGFREG, phy_reg);\nrelease:\n\t\tif (ret_val)\n\t\t\te_dbg(\"Error %d in resume workarounds\\n\", ret_val);\n\t\thw->phy.ops.release(hw);\n\t}\n}\n\n \nstatic s32 e1000_cleanup_led_ich8lan(struct e1000_hw *hw)\n{\n\tif (hw->phy.type == e1000_phy_ife)\n\t\treturn e1e_wphy(hw, IFE_PHY_SPECIAL_CONTROL_LED, 0);\n\n\tew32(LEDCTL, hw->mac.ledctl_default);\n\treturn 0;\n}\n\n \nstatic s32 e1000_led_on_ich8lan(struct e1000_hw *hw)\n{\n\tif (hw->phy.type == e1000_phy_ife)\n\t\treturn e1e_wphy(hw, IFE_PHY_SPECIAL_CONTROL_LED,\n\t\t\t\t(IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_ON));\n\n\tew32(LEDCTL, hw->mac.ledctl_mode2);\n\treturn 0;\n}\n\n \nstatic s32 e1000_led_off_ich8lan(struct e1000_hw *hw)\n{\n\tif (hw->phy.type == e1000_phy_ife)\n\t\treturn e1e_wphy(hw, IFE_PHY_SPECIAL_CONTROL_LED,\n\t\t\t\t(IFE_PSCL_PROBE_MODE |\n\t\t\t\t IFE_PSCL_PROBE_LEDS_OFF));\n\n\tew32(LEDCTL, hw->mac.ledctl_mode1);\n\treturn 0;\n}\n\n \nstatic s32 e1000_setup_led_pchlan(struct e1000_hw *hw)\n{\n\treturn e1e_wphy(hw, HV_LED_CONFIG, (u16)hw->mac.ledctl_mode1);\n}\n\n \nstatic s32 e1000_cleanup_led_pchlan(struct e1000_hw *hw)\n{\n\treturn e1e_wphy(hw, HV_LED_CONFIG, (u16)hw->mac.ledctl_default);\n}\n\n \nstatic s32 e1000_led_on_pchlan(struct e1000_hw *hw)\n{\n\tu16 data = (u16)hw->mac.ledctl_mode2;\n\tu32 i, led;\n\n\t \n\tif (!(er32(STATUS) & E1000_STATUS_LU)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tled = (data >> (i * 5)) & E1000_PHY_LED0_MASK;\n\t\t\tif ((led & E1000_PHY_LED0_MODE_MASK) !=\n\t\t\t    E1000_LEDCTL_MODE_LINK_UP)\n\t\t\t\tcontinue;\n\t\t\tif (led & E1000_PHY_LED0_IVRT)\n\t\t\t\tdata &= ~(E1000_PHY_LED0_IVRT << (i * 5));\n\t\t\telse\n\t\t\t\tdata |= (E1000_PHY_LED0_IVRT << (i * 5));\n\t\t}\n\t}\n\n\treturn e1e_wphy(hw, HV_LED_CONFIG, data);\n}\n\n \nstatic s32 e1000_led_off_pchlan(struct e1000_hw *hw)\n{\n\tu16 data = (u16)hw->mac.ledctl_mode1;\n\tu32 i, led;\n\n\t \n\tif (!(er32(STATUS) & E1000_STATUS_LU)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tled = (data >> (i * 5)) & E1000_PHY_LED0_MASK;\n\t\t\tif ((led & E1000_PHY_LED0_MODE_MASK) !=\n\t\t\t    E1000_LEDCTL_MODE_LINK_UP)\n\t\t\t\tcontinue;\n\t\t\tif (led & E1000_PHY_LED0_IVRT)\n\t\t\t\tdata &= ~(E1000_PHY_LED0_IVRT << (i * 5));\n\t\t\telse\n\t\t\t\tdata |= (E1000_PHY_LED0_IVRT << (i * 5));\n\t\t}\n\t}\n\n\treturn e1e_wphy(hw, HV_LED_CONFIG, data);\n}\n\n \nstatic s32 e1000_get_cfg_done_ich8lan(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu32 bank = 0;\n\tu32 status;\n\n\te1000e_get_cfg_done_generic(hw);\n\n\t \n\tif (hw->mac.type >= e1000_ich10lan) {\n\t\te1000_lan_init_done_ich8lan(hw);\n\t} else {\n\t\tret_val = e1000e_get_auto_rd_done(hw);\n\t\tif (ret_val) {\n\t\t\t \n\t\t\te_dbg(\"Auto Read Done did not complete\\n\");\n\t\t\tret_val = 0;\n\t\t}\n\t}\n\n\t \n\tstatus = er32(STATUS);\n\tif (status & E1000_STATUS_PHYRA)\n\t\tew32(STATUS, status & ~E1000_STATUS_PHYRA);\n\telse\n\t\te_dbg(\"PHY Reset Asserted not set - needs delay\\n\");\n\n\t \n\tif (hw->mac.type <= e1000_ich9lan) {\n\t\tif (!(er32(EECD) & E1000_EECD_PRES) &&\n\t\t    (hw->phy.type == e1000_phy_igp_3)) {\n\t\t\te1000e_phy_init_script_igp3(hw);\n\t\t}\n\t} else {\n\t\tif (e1000_valid_nvm_bank_detect_ich8lan(hw, &bank)) {\n\t\t\t \n\t\t\te_dbg(\"EEPROM not present\\n\");\n\t\t\tret_val = -E1000_ERR_CONFIG;\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic void e1000_power_down_phy_copper_ich8lan(struct e1000_hw *hw)\n{\n\t \n\tif (!(hw->mac.ops.check_mng_mode(hw) ||\n\t      hw->phy.ops.check_reset_block(hw)))\n\t\te1000_power_down_phy_copper(hw);\n}\n\n \nstatic void e1000_clear_hw_cntrs_ich8lan(struct e1000_hw *hw)\n{\n\tu16 phy_data;\n\ts32 ret_val;\n\n\te1000e_clear_hw_cntrs_base(hw);\n\n\ter32(ALGNERRC);\n\ter32(RXERRC);\n\ter32(TNCRS);\n\ter32(CEXTERR);\n\ter32(TSCTC);\n\ter32(TSCTFC);\n\n\ter32(MGTPRC);\n\ter32(MGTPDC);\n\ter32(MGTPTC);\n\n\ter32(IAC);\n\ter32(ICRXOC);\n\n\t \n\tif ((hw->phy.type == e1000_phy_82578) ||\n\t    (hw->phy.type == e1000_phy_82579) ||\n\t    (hw->phy.type == e1000_phy_i217) ||\n\t    (hw->phy.type == e1000_phy_82577)) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn;\n\t\tret_val = hw->phy.ops.set_page(hw,\n\t\t\t\t\t       HV_STATS_PAGE << IGP_PAGE_SHIFT);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t\thw->phy.ops.read_reg_page(hw, HV_SCC_UPPER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_SCC_LOWER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_ECOL_UPPER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_ECOL_LOWER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_MCC_UPPER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_MCC_LOWER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_LATECOL_UPPER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_LATECOL_LOWER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_COLC_UPPER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_COLC_LOWER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_DC_UPPER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_DC_LOWER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_TNCRS_UPPER, &phy_data);\n\t\thw->phy.ops.read_reg_page(hw, HV_TNCRS_LOWER, &phy_data);\nrelease:\n\t\thw->phy.ops.release(hw);\n\t}\n}\n\nstatic const struct e1000_mac_operations ich8_mac_ops = {\n\t \n\t.check_for_link\t\t= e1000_check_for_copper_link_ich8lan,\n\t \n\t.clear_hw_cntrs\t\t= e1000_clear_hw_cntrs_ich8lan,\n\t.get_bus_info\t\t= e1000_get_bus_info_ich8lan,\n\t.set_lan_id\t\t= e1000_set_lan_id_single_port,\n\t.get_link_up_info\t= e1000_get_link_up_info_ich8lan,\n\t \n\t \n\t.update_mc_addr_list\t= e1000e_update_mc_addr_list_generic,\n\t.reset_hw\t\t= e1000_reset_hw_ich8lan,\n\t.init_hw\t\t= e1000_init_hw_ich8lan,\n\t.setup_link\t\t= e1000_setup_link_ich8lan,\n\t.setup_physical_interface = e1000_setup_copper_link_ich8lan,\n\t \n\t.config_collision_dist\t= e1000e_config_collision_dist_generic,\n\t.rar_set\t\t= e1000e_rar_set_generic,\n\t.rar_get_count\t\t= e1000e_rar_get_count_generic,\n};\n\nstatic const struct e1000_phy_operations ich8_phy_ops = {\n\t.acquire\t\t= e1000_acquire_swflag_ich8lan,\n\t.check_reset_block\t= e1000_check_reset_block_ich8lan,\n\t.commit\t\t\t= NULL,\n\t.get_cfg_done\t\t= e1000_get_cfg_done_ich8lan,\n\t.get_cable_length\t= e1000e_get_cable_length_igp_2,\n\t.read_reg\t\t= e1000e_read_phy_reg_igp,\n\t.release\t\t= e1000_release_swflag_ich8lan,\n\t.reset\t\t\t= e1000_phy_hw_reset_ich8lan,\n\t.set_d0_lplu_state\t= e1000_set_d0_lplu_state_ich8lan,\n\t.set_d3_lplu_state\t= e1000_set_d3_lplu_state_ich8lan,\n\t.write_reg\t\t= e1000e_write_phy_reg_igp,\n};\n\nstatic const struct e1000_nvm_operations ich8_nvm_ops = {\n\t.acquire\t\t= e1000_acquire_nvm_ich8lan,\n\t.read\t\t\t= e1000_read_nvm_ich8lan,\n\t.release\t\t= e1000_release_nvm_ich8lan,\n\t.reload\t\t\t= e1000e_reload_nvm_generic,\n\t.update\t\t\t= e1000_update_nvm_checksum_ich8lan,\n\t.valid_led_default\t= e1000_valid_led_default_ich8lan,\n\t.validate\t\t= e1000_validate_nvm_checksum_ich8lan,\n\t.write\t\t\t= e1000_write_nvm_ich8lan,\n};\n\nstatic const struct e1000_nvm_operations spt_nvm_ops = {\n\t.acquire\t\t= e1000_acquire_nvm_ich8lan,\n\t.release\t\t= e1000_release_nvm_ich8lan,\n\t.read\t\t\t= e1000_read_nvm_spt,\n\t.update\t\t\t= e1000_update_nvm_checksum_spt,\n\t.reload\t\t\t= e1000e_reload_nvm_generic,\n\t.valid_led_default\t= e1000_valid_led_default_ich8lan,\n\t.validate\t\t= e1000_validate_nvm_checksum_ich8lan,\n\t.write\t\t\t= e1000_write_nvm_ich8lan,\n};\n\nconst struct e1000_info e1000_ich8_info = {\n\t.mac\t\t\t= e1000_ich8lan,\n\t.flags\t\t\t= FLAG_HAS_WOL\n\t\t\t\t  | FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.pba\t\t\t= 8,\n\t.max_hw_frame_size\t= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &ich8_nvm_ops,\n};\n\nconst struct e1000_info e1000_ich9_info = {\n\t.mac\t\t\t= e1000_ich9lan,\n\t.flags\t\t\t= FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.pba\t\t\t= 18,\n\t.max_hw_frame_size\t= DEFAULT_JUMBO,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &ich8_nvm_ops,\n};\n\nconst struct e1000_info e1000_ich10_info = {\n\t.mac\t\t\t= e1000_ich10lan,\n\t.flags\t\t\t= FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.pba\t\t\t= 18,\n\t.max_hw_frame_size\t= DEFAULT_JUMBO,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &ich8_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch_info = {\n\t.mac\t\t\t= e1000_pchlan,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_DISABLE_FC_PAUSE_TIME  \n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 4096,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &ich8_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch2_info = {\n\t.mac\t\t\t= e1000_pch2lan,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS\n\t\t\t\t  | FLAG2_HAS_EEE\n\t\t\t\t  | FLAG2_CHECK_SYSTIM_OVERFLOW,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 9022,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &ich8_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch_lpt_info = {\n\t.mac\t\t\t= e1000_pch_lpt,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS\n\t\t\t\t  | FLAG2_HAS_EEE\n\t\t\t\t  | FLAG2_CHECK_SYSTIM_OVERFLOW,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 9022,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &ich8_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch_spt_info = {\n\t.mac\t\t\t= e1000_pch_spt,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS\n\t\t\t\t  | FLAG2_HAS_EEE,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 9022,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &spt_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch_cnp_info = {\n\t.mac\t\t\t= e1000_pch_cnp,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS\n\t\t\t\t  | FLAG2_HAS_EEE,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 9022,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &spt_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch_tgp_info = {\n\t.mac\t\t\t= e1000_pch_tgp,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS\n\t\t\t\t  | FLAG2_HAS_EEE,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 9022,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &spt_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch_adp_info = {\n\t.mac\t\t\t= e1000_pch_adp,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS\n\t\t\t\t  | FLAG2_HAS_EEE,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 9022,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &spt_nvm_ops,\n};\n\nconst struct e1000_info e1000_pch_mtp_info = {\n\t.mac\t\t\t= e1000_pch_mtp,\n\t.flags\t\t\t= FLAG_IS_ICH\n\t\t\t\t  | FLAG_HAS_WOL\n\t\t\t\t  | FLAG_HAS_HW_TIMESTAMP\n\t\t\t\t  | FLAG_HAS_CTRLEXT_ON_LOAD\n\t\t\t\t  | FLAG_HAS_AMT\n\t\t\t\t  | FLAG_HAS_FLASH\n\t\t\t\t  | FLAG_HAS_JUMBO_FRAMES\n\t\t\t\t  | FLAG_APME_IN_WUC,\n\t.flags2\t\t\t= FLAG2_HAS_PHY_STATS\n\t\t\t\t  | FLAG2_HAS_EEE,\n\t.pba\t\t\t= 26,\n\t.max_hw_frame_size\t= 9022,\n\t.get_variants\t\t= e1000_get_variants_ich8lan,\n\t.mac_ops\t\t= &ich8_mac_ops,\n\t.phy_ops\t\t= &ich8_phy_ops,\n\t.nvm_ops\t\t= &spt_nvm_ops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}