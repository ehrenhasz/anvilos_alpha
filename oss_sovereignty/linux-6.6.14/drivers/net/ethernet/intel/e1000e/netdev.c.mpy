{
  "module_name": "netdev.c",
  "hash_id": "b839a5b31bf8bc941120fa57b05e98f87241687d0e5d690910257a769f9158be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/netdev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <linux/tcp.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_runtime.h>\n#include <linux/prefetch.h>\n#include <linux/suspend.h>\n\n#include \"e1000.h\"\n#define CREATE_TRACE_POINTS\n#include \"e1000e_trace.h\"\n\nchar e1000e_driver_name[] = \"e1000e\";\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\nstatic const struct e1000_info *e1000_info_tbl[] = {\n\t[board_82571]\t\t= &e1000_82571_info,\n\t[board_82572]\t\t= &e1000_82572_info,\n\t[board_82573]\t\t= &e1000_82573_info,\n\t[board_82574]\t\t= &e1000_82574_info,\n\t[board_82583]\t\t= &e1000_82583_info,\n\t[board_80003es2lan]\t= &e1000_es2_info,\n\t[board_ich8lan]\t\t= &e1000_ich8_info,\n\t[board_ich9lan]\t\t= &e1000_ich9_info,\n\t[board_ich10lan]\t= &e1000_ich10_info,\n\t[board_pchlan]\t\t= &e1000_pch_info,\n\t[board_pch2lan]\t\t= &e1000_pch2_info,\n\t[board_pch_lpt]\t\t= &e1000_pch_lpt_info,\n\t[board_pch_spt]\t\t= &e1000_pch_spt_info,\n\t[board_pch_cnp]\t\t= &e1000_pch_cnp_info,\n\t[board_pch_tgp]\t\t= &e1000_pch_tgp_info,\n\t[board_pch_adp]\t\t= &e1000_pch_adp_info,\n\t[board_pch_mtp]\t\t= &e1000_pch_mtp_info,\n};\n\nstruct e1000_reg_info {\n\tu32 ofs;\n\tchar *name;\n};\n\nstatic const struct e1000_reg_info e1000_reg_info_tbl[] = {\n\t \n\t{E1000_CTRL, \"CTRL\"},\n\t{E1000_STATUS, \"STATUS\"},\n\t{E1000_CTRL_EXT, \"CTRL_EXT\"},\n\n\t \n\t{E1000_ICR, \"ICR\"},\n\n\t \n\t{E1000_RCTL, \"RCTL\"},\n\t{E1000_RDLEN(0), \"RDLEN\"},\n\t{E1000_RDH(0), \"RDH\"},\n\t{E1000_RDT(0), \"RDT\"},\n\t{E1000_RDTR, \"RDTR\"},\n\t{E1000_RXDCTL(0), \"RXDCTL\"},\n\t{E1000_ERT, \"ERT\"},\n\t{E1000_RDBAL(0), \"RDBAL\"},\n\t{E1000_RDBAH(0), \"RDBAH\"},\n\t{E1000_RDFH, \"RDFH\"},\n\t{E1000_RDFT, \"RDFT\"},\n\t{E1000_RDFHS, \"RDFHS\"},\n\t{E1000_RDFTS, \"RDFTS\"},\n\t{E1000_RDFPC, \"RDFPC\"},\n\n\t \n\t{E1000_TCTL, \"TCTL\"},\n\t{E1000_TDBAL(0), \"TDBAL\"},\n\t{E1000_TDBAH(0), \"TDBAH\"},\n\t{E1000_TDLEN(0), \"TDLEN\"},\n\t{E1000_TDH(0), \"TDH\"},\n\t{E1000_TDT(0), \"TDT\"},\n\t{E1000_TIDV, \"TIDV\"},\n\t{E1000_TXDCTL(0), \"TXDCTL\"},\n\t{E1000_TADV, \"TADV\"},\n\t{E1000_TARC(0), \"TARC\"},\n\t{E1000_TDFH, \"TDFH\"},\n\t{E1000_TDFT, \"TDFT\"},\n\t{E1000_TDFHS, \"TDFHS\"},\n\t{E1000_TDFTS, \"TDFTS\"},\n\t{E1000_TDFPC, \"TDFPC\"},\n\n\t \n\t{0, NULL}\n};\n\n \nstatic void __ew32_prepare(struct e1000_hw *hw)\n{\n\ts32 i = E1000_ICH_FWSM_PCIM2PCI_COUNT;\n\n\twhile ((er32(FWSM) & E1000_ICH_FWSM_PCIM2PCI) && --i)\n\t\tudelay(50);\n}\n\nvoid __ew32(struct e1000_hw *hw, unsigned long reg, u32 val)\n{\n\tif (hw->adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t__ew32_prepare(hw);\n\n\twritel(val, hw->hw_addr + reg);\n}\n\n \nstatic void e1000_regdump(struct e1000_hw *hw, struct e1000_reg_info *reginfo)\n{\n\tint n = 0;\n\tchar rname[16];\n\tu32 regs[8];\n\n\tswitch (reginfo->ofs) {\n\tcase E1000_RXDCTL(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_RXDCTL(n));\n\t\tbreak;\n\tcase E1000_TXDCTL(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_TXDCTL(n));\n\t\tbreak;\n\tcase E1000_TARC(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_TARC(n));\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%-15s %08x\\n\",\n\t\t\treginfo->name, __er32(hw, reginfo->ofs));\n\t\treturn;\n\t}\n\n\tsnprintf(rname, 16, \"%s%s\", reginfo->name, \"[0-1]\");\n\tpr_info(\"%-15s %08x %08x\\n\", rname, regs[0], regs[1]);\n}\n\nstatic void e1000e_dump_ps_pages(struct e1000_adapter *adapter,\n\t\t\t\t struct e1000_buffer *bi)\n{\n\tint i;\n\tstruct e1000_ps_page *ps_page;\n\n\tfor (i = 0; i < adapter->rx_ps_pages; i++) {\n\t\tps_page = &bi->ps_pages[i];\n\n\t\tif (ps_page->page) {\n\t\t\tpr_info(\"packet dump for ps_page %d:\\n\", i);\n\t\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, page_address(ps_page->page),\n\t\t\t\t       PAGE_SIZE, true);\n\t\t}\n\t}\n}\n\n \nstatic void e1000e_dump(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_reg_info *reginfo;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tstruct e1000_tx_desc *tx_desc;\n\tstruct my_u0 {\n\t\t__le64 a;\n\t\t__le64 b;\n\t} *u0;\n\tstruct e1000_buffer *buffer_info;\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\tunion e1000_rx_desc_packet_split *rx_desc_ps;\n\tunion e1000_rx_desc_extended *rx_desc;\n\tstruct my_u1 {\n\t\t__le64 a;\n\t\t__le64 b;\n\t\t__le64 c;\n\t\t__le64 d;\n\t} *u1;\n\tu32 staterr;\n\tint i = 0;\n\n\tif (!netif_msg_hw(adapter))\n\t\treturn;\n\n\t \n\tif (netdev) {\n\t\tdev_info(&adapter->pdev->dev, \"Net device Info\\n\");\n\t\tpr_info(\"Device Name     state            trans_start\\n\");\n\t\tpr_info(\"%-15s %016lX %016lX\\n\", netdev->name,\n\t\t\tnetdev->state, dev_trans_start(netdev));\n\t}\n\n\t \n\tdev_info(&adapter->pdev->dev, \"Register Dump\\n\");\n\tpr_info(\" Register Name   Value\\n\");\n\tfor (reginfo = (struct e1000_reg_info *)e1000_reg_info_tbl;\n\t     reginfo->name; reginfo++) {\n\t\te1000_regdump(hw, reginfo);\n\t}\n\n\t \n\tif (!netdev || !netif_running(netdev))\n\t\treturn;\n\n\tdev_info(&adapter->pdev->dev, \"Tx Ring Summary\\n\");\n\tpr_info(\"Queue [NTU] [NTC] [bi(ntc)->dma  ] leng ntw timestamp\\n\");\n\tbuffer_info = &tx_ring->buffer_info[tx_ring->next_to_clean];\n\tpr_info(\" %5d %5X %5X %016llX %04X %3X %016llX\\n\",\n\t\t0, tx_ring->next_to_use, tx_ring->next_to_clean,\n\t\t(unsigned long long)buffer_info->dma,\n\t\tbuffer_info->length,\n\t\tbuffer_info->next_to_watch,\n\t\t(unsigned long long)buffer_info->time_stamp);\n\n\t \n\tif (!netif_msg_tx_done(adapter))\n\t\tgoto rx_ring_summary;\n\n\tdev_info(&adapter->pdev->dev, \"Tx Ring Dump\\n\");\n\n\t \n\tpr_info(\"Tl[desc]     [address 63:0  ] [SpeCssSCmCsLen] [bi->dma       ] leng  ntw timestamp        bi->skb <-- Legacy format\\n\");\n\tpr_info(\"Tc[desc]     [Ce CoCsIpceCoS] [MssHlRSCm0Plen] [bi->dma       ] leng  ntw timestamp        bi->skb <-- Ext Context format\\n\");\n\tpr_info(\"Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi->dma       ] leng  ntw timestamp        bi->skb <-- Ext Data format\\n\");\n\tfor (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {\n\t\tconst char *next_desc;\n\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tu0 = (struct my_u0 *)tx_desc;\n\t\tif (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)\n\t\t\tnext_desc = \" NTC/U\";\n\t\telse if (i == tx_ring->next_to_use)\n\t\t\tnext_desc = \" NTU\";\n\t\telse if (i == tx_ring->next_to_clean)\n\t\t\tnext_desc = \" NTC\";\n\t\telse\n\t\t\tnext_desc = \"\";\n\t\tpr_info(\"T%c[0x%03X]    %016llX %016llX %016llX %04X  %3X %016llX %p%s\\n\",\n\t\t\t(!(le64_to_cpu(u0->b) & BIT(29)) ? 'l' :\n\t\t\t ((le64_to_cpu(u0->b) & BIT(20)) ? 'd' : 'c')),\n\t\t\ti,\n\t\t\t(unsigned long long)le64_to_cpu(u0->a),\n\t\t\t(unsigned long long)le64_to_cpu(u0->b),\n\t\t\t(unsigned long long)buffer_info->dma,\n\t\t\tbuffer_info->length, buffer_info->next_to_watch,\n\t\t\t(unsigned long long)buffer_info->time_stamp,\n\t\t\tbuffer_info->skb, next_desc);\n\n\t\tif (netif_msg_pktdata(adapter) && buffer_info->skb)\n\t\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, buffer_info->skb->data,\n\t\t\t\t       buffer_info->skb->len, true);\n\t}\n\n\t \nrx_ring_summary:\n\tdev_info(&adapter->pdev->dev, \"Rx Ring Summary\\n\");\n\tpr_info(\"Queue [NTU] [NTC]\\n\");\n\tpr_info(\" %5d %5X %5X\\n\",\n\t\t0, rx_ring->next_to_use, rx_ring->next_to_clean);\n\n\t \n\tif (!netif_msg_rx_status(adapter))\n\t\treturn;\n\n\tdev_info(&adapter->pdev->dev, \"Rx Ring Dump\\n\");\n\tswitch (adapter->rx_ps_pages) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\t \n\t\tpr_info(\"R  [desc]      [buffer 0 63:0 ] [buffer 1 63:0 ] [buffer 2 63:0 ] [buffer 3 63:0 ] [bi->dma       ] [bi->skb] <-- Ext Pkt Split format\\n\");\n\t\t \n\t\tpr_info(\"RWB[desc]      [ck ipid mrqhsh] [vl   l0 ee  es] [ l3  l2  l1 hs] [reserved      ] ---------------- [bi->skb] <-- Ext Rx Write-Back format\\n\");\n\t\tfor (i = 0; i < rx_ring->count; i++) {\n\t\t\tconst char *next_desc;\n\t\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\t\trx_desc_ps = E1000_RX_DESC_PS(*rx_ring, i);\n\t\t\tu1 = (struct my_u1 *)rx_desc_ps;\n\t\t\tstaterr =\n\t\t\t    le32_to_cpu(rx_desc_ps->wb.middle.status_error);\n\n\t\t\tif (i == rx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == rx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tif (staterr & E1000_RXD_STAT_DD) {\n\t\t\t\t \n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX %016llX %016llX ---------------- %p%s\\n\",\n\t\t\t\t\t\"RWB\", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->c),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->d),\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\t\t\t} else {\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX %016llX %016llX %016llX %p%s\\n\",\n\t\t\t\t\t\"R  \", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->c),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->d),\n\t\t\t\t\t(unsigned long long)buffer_info->dma,\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\n\t\t\t\tif (netif_msg_pktdata(adapter))\n\t\t\t\t\te1000e_dump_ps_pages(adapter,\n\t\t\t\t\t\t\t     buffer_info);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase 0:\n\t\t \n\t\tpr_info(\"R  [desc]      [buf addr 63:0 ] [reserved 63:0 ] [bi->dma       ] [bi->skb] <-- Ext (Read) format\\n\");\n\t\t \n\t\tpr_info(\"RWB[desc]      [cs ipid    mrq] [vt   ln xe  xs] [bi->skb] <-- Ext (Write-Back) format\\n\");\n\n\t\tfor (i = 0; i < rx_ring->count; i++) {\n\t\t\tconst char *next_desc;\n\n\t\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\t\tu1 = (struct my_u1 *)rx_desc;\n\t\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\n\t\t\tif (i == rx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == rx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tif (staterr & E1000_RXD_STAT_DD) {\n\t\t\t\t \n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX ---------------- %p%s\\n\",\n\t\t\t\t\t\"RWB\", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\t\t\t} else {\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX %016llX %p%s\\n\",\n\t\t\t\t\t\"R  \", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\t(unsigned long long)buffer_info->dma,\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\n\t\t\t\tif (netif_msg_pktdata(adapter) &&\n\t\t\t\t    buffer_info->skb)\n\t\t\t\t\tprint_hex_dump(KERN_INFO, \"\",\n\t\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       buffer_info->skb->data,\n\t\t\t\t\t\t       adapter->rx_buffer_len,\n\t\t\t\t\t\t       true);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int e1000_desc_unused(struct e1000_ring *ring)\n{\n\tif (ring->next_to_clean > ring->next_to_use)\n\t\treturn ring->next_to_clean - ring->next_to_use - 1;\n\n\treturn ring->count + ring->next_to_clean - ring->next_to_use - 1;\n}\n\n \nstatic void e1000e_systim_to_hwtstamp(struct e1000_adapter *adapter,\n\t\t\t\t      struct skb_shared_hwtstamps *hwtstamps,\n\t\t\t\t      u64 systim)\n{\n\tu64 ns;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\tns = timecounter_cyc2time(&adapter->tc, systim);\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\tmemset(hwtstamps, 0, sizeof(*hwtstamps));\n\thwtstamps->hwtstamp = ns_to_ktime(ns);\n}\n\n \nstatic void e1000e_rx_hwtstamp(struct e1000_adapter *adapter, u32 status,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu64 rxstmp;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP) ||\n\t    !(status & E1000_RXDEXT_STATERR_TST) ||\n\t    !(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID))\n\t\treturn;\n\n\t \n\trxstmp = (u64)er32(RXSTMPL);\n\trxstmp |= (u64)er32(RXSTMPH) << 32;\n\te1000e_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), rxstmp);\n\n\tadapter->flags2 &= ~FLAG2_CHECK_RX_HWTSTAMP;\n}\n\n \nstatic void e1000_receive_skb(struct e1000_adapter *adapter,\n\t\t\t      struct net_device *netdev, struct sk_buff *skb,\n\t\t\t      u32 staterr, __le16 vlan)\n{\n\tu16 tag = le16_to_cpu(vlan);\n\n\te1000e_rx_hwtstamp(adapter, staterr, skb);\n\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tif (staterr & E1000_RXD_STAT_VP)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), tag);\n\n\tnapi_gro_receive(&adapter->napi, skb);\n}\n\n \nstatic void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err,\n\t\t\t      struct sk_buff *skb)\n{\n\tu16 status = (u16)status_err;\n\tu8 errors = (u8)(status_err >> 24);\n\n\tskb_checksum_none_assert(skb);\n\n\t \n\tif (!(adapter->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\t \n\tif (status & E1000_RXD_STAT_IXSM)\n\t\treturn;\n\n\t \n\tif (errors & (E1000_RXD_ERR_TCPE | E1000_RXD_ERR_IPE)) {\n\t\t \n\t\tadapter->hw_csum_err++;\n\t\treturn;\n\t}\n\n\t \n\tif (!(status & (E1000_RXD_STAT_TCPCS | E1000_RXD_STAT_UDPCS)))\n\t\treturn;\n\n\t \n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tadapter->hw_csum_good++;\n}\n\nstatic void e1000e_update_rdt_wa(struct e1000_ring *rx_ring, unsigned int i)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t__ew32_prepare(hw);\n\twritel(i, rx_ring->tail);\n\n\tif (unlikely(i != readl(rx_ring->tail))) {\n\t\tu32 rctl = er32(RCTL);\n\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t\te_err(\"ME firmware caused invalid RDT - resetting\\n\");\n\t\tschedule_work(&adapter->reset_task);\n\t}\n}\n\nstatic void e1000e_update_tdt_wa(struct e1000_ring *tx_ring, unsigned int i)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t__ew32_prepare(hw);\n\twritel(i, tx_ring->tail);\n\n\tif (unlikely(i != readl(tx_ring->tail))) {\n\t\tu32 tctl = er32(TCTL);\n\n\t\tew32(TCTL, tctl & ~E1000_TCTL_EN);\n\t\te_err(\"ME firmware caused invalid TDT - resetting\\n\");\n\t\tschedule_work(&adapter->reset_task);\n\t}\n}\n\n \nstatic void e1000_alloc_rx_buffers(struct e1000_ring *rx_ring,\n\t\t\t\t   int cleaned_count, gfp_t gfp)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_extended *rx_desc;\n\tstruct e1000_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int bufsz = adapter->rx_buffer_len;\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\tskb = buffer_info->skb;\n\t\tif (skb) {\n\t\t\tskb_trim(skb, 0);\n\t\t\tgoto map_skb;\n\t\t}\n\n\t\tskb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_info->skb = skb;\nmap_skb:\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev, skb->data,\n\t\t\t\t\t\t  adapter->rx_buffer_len,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\tdev_err(&pdev->dev, \"Rx DMA map failed\\n\");\n\t\t\tadapter->rx_dma_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\trx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {\n\t\t\t \n\t\t\twmb();\n\t\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\t\te1000e_update_rdt_wa(rx_ring, i);\n\t\t\telse\n\t\t\t\twritel(i, rx_ring->tail);\n\t\t}\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\n\trx_ring->next_to_use = i;\n}\n\n \nstatic void e1000_alloc_rx_buffers_ps(struct e1000_ring *rx_ring,\n\t\t\t\t      int cleaned_count, gfp_t gfp)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_packet_split *rx_desc;\n\tstruct e1000_buffer *buffer_info;\n\tstruct e1000_ps_page *ps_page;\n\tstruct sk_buff *skb;\n\tunsigned int i, j;\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\trx_desc = E1000_RX_DESC_PS(*rx_ring, i);\n\n\t\tfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\n\t\t\tps_page = &buffer_info->ps_pages[j];\n\t\t\tif (j >= adapter->rx_ps_pages) {\n\t\t\t\t \n\t\t\t\trx_desc->read.buffer_addr[j + 1] =\n\t\t\t\t    ~cpu_to_le64(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ps_page->page) {\n\t\t\t\tps_page->page = alloc_page(gfp);\n\t\t\t\tif (!ps_page->page) {\n\t\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\t\tgoto no_buffers;\n\t\t\t\t}\n\t\t\t\tps_page->dma = dma_map_page(&pdev->dev,\n\t\t\t\t\t\t\t    ps_page->page,\n\t\t\t\t\t\t\t    0, PAGE_SIZE,\n\t\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&pdev->dev,\n\t\t\t\t\t\t      ps_page->dma)) {\n\t\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\t\"Rx DMA page map failed\\n\");\n\t\t\t\t\tadapter->rx_dma_failed++;\n\t\t\t\t\tgoto no_buffers;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\trx_desc->read.buffer_addr[j + 1] =\n\t\t\t    cpu_to_le64(ps_page->dma);\n\t\t}\n\n\t\tskb = __netdev_alloc_skb_ip_align(netdev, adapter->rx_ps_bsize0,\n\t\t\t\t\t\t  gfp);\n\n\t\tif (!skb) {\n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_info->skb = skb;\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev, skb->data,\n\t\t\t\t\t\t  adapter->rx_ps_bsize0,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\tdev_err(&pdev->dev, \"Rx DMA map failed\\n\");\n\t\t\tadapter->rx_dma_failed++;\n\t\t\t \n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbuffer_info->skb = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\trx_desc->read.buffer_addr[0] = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {\n\t\t\t \n\t\t\twmb();\n\t\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\t\te1000e_update_rdt_wa(rx_ring, i << 1);\n\t\t\telse\n\t\t\t\twritel(i << 1, rx_ring->tail);\n\t\t}\n\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\nno_buffers:\n\trx_ring->next_to_use = i;\n}\n\n \n\nstatic void e1000_alloc_jumbo_rx_buffers(struct e1000_ring *rx_ring,\n\t\t\t\t\t int cleaned_count, gfp_t gfp)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_extended *rx_desc;\n\tstruct e1000_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int bufsz = 256 - 16;\t \n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\tskb = buffer_info->skb;\n\t\tif (skb) {\n\t\t\tskb_trim(skb, 0);\n\t\t\tgoto check_page;\n\t\t}\n\n\t\tskb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);\n\t\tif (unlikely(!skb)) {\n\t\t\t \n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_info->skb = skb;\ncheck_page:\n\t\t \n\t\tif (!buffer_info->page) {\n\t\t\tbuffer_info->page = alloc_page(gfp);\n\t\t\tif (unlikely(!buffer_info->page)) {\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!buffer_info->dma) {\n\t\t\tbuffer_info->dma = dma_map_page(&pdev->dev,\n\t\t\t\t\t\t\tbuffer_info->page, 0,\n\t\t\t\t\t\t\tPAGE_SIZE,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\trx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(++i == rx_ring->count))\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\n\tif (likely(rx_ring->next_to_use != i)) {\n\t\trx_ring->next_to_use = i;\n\t\tif (unlikely(i-- == 0))\n\t\t\ti = (rx_ring->count - 1);\n\n\t\t \n\t\twmb();\n\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\te1000e_update_rdt_wa(rx_ring, i);\n\t\telse\n\t\t\twritel(i, rx_ring->tail);\n\t}\n}\n\nstatic inline void e1000_rx_hash(struct net_device *netdev, __le32 rss,\n\t\t\t\t struct sk_buff *skb)\n{\n\tif (netdev->features & NETIF_F_RXHASH)\n\t\tskb_set_hash(skb, le32_to_cpu(rss), PKT_HASH_TYPE_L3);\n}\n\n \nstatic bool e1000_clean_rx_irq(struct e1000_ring *rx_ring, int *work_done,\n\t\t\t       int work_to_do)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunion e1000_rx_desc_extended *rx_desc, *next_rxd;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tu32 length, staterr;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (staterr & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tdma_rmb();\t \n\n\t\tskb = buffer_info->skb;\n\t\tbuffer_info->skb = NULL;\n\n\t\tprefetch(skb->data - NET_IP_ALIGN);\n\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tnext_rxd = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t adapter->rx_buffer_len, DMA_FROM_DEVICE);\n\t\tbuffer_info->dma = 0;\n\n\t\tlength = le16_to_cpu(rx_desc->wb.upper.length);\n\n\t\t \n\t\tif (unlikely(!(staterr & E1000_RXD_STAT_EOP)))\n\t\t\tadapter->flags2 |= FLAG2_IS_DISCARDING;\n\n\t\tif (adapter->flags2 & FLAG2_IS_DISCARDING) {\n\t\t\t \n\t\t\te_dbg(\"Receive packet consumed multiple buffers\\n\");\n\t\t\t \n\t\t\tbuffer_info->skb = skb;\n\t\t\tif (staterr & E1000_RXD_STAT_EOP)\n\t\t\t\tadapter->flags2 &= ~FLAG2_IS_DISCARDING;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tif (unlikely((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\n\t\t\t     !(netdev->features & NETIF_F_RXALL))) {\n\t\t\t \n\t\t\tbuffer_info->skb = skb;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\t \n\t\tif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\n\t\t\t \n\t\t\tif (netdev->features & NETIF_F_RXFCS)\n\t\t\t\ttotal_rx_bytes -= 4;\n\t\t\telse\n\t\t\t\tlength -= 4;\n\t\t}\n\n\t\ttotal_rx_bytes += length;\n\t\ttotal_rx_packets++;\n\n\t\t \n\t\tif (length < copybreak) {\n\t\t\tstruct sk_buff *new_skb =\n\t\t\t\tnapi_alloc_skb(&adapter->napi, length);\n\t\t\tif (new_skb) {\n\t\t\t\tskb_copy_to_linear_data_offset(new_skb,\n\t\t\t\t\t\t\t       -NET_IP_ALIGN,\n\t\t\t\t\t\t\t       (skb->data -\n\t\t\t\t\t\t\t\tNET_IP_ALIGN),\n\t\t\t\t\t\t\t       (length +\n\t\t\t\t\t\t\t\tNET_IP_ALIGN));\n\t\t\t\t \n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tskb = new_skb;\n\t\t\t}\n\t\t\t \n\t\t}\n\t\t \n\t\tskb_put(skb, length);\n\n\t\t \n\t\te1000_rx_checksum(adapter, staterr, skb);\n\n\t\te1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\n\n\t\te1000_receive_skb(adapter, netdev, skb, staterr,\n\t\t\t\t  rx_desc->wb.upper.vlan);\n\nnext_desc:\n\t\trx_desc->wb.upper.status_error &= cpu_to_le32(~0xFF);\n\n\t\t \n\t\tif (cleaned_count >= E1000_RX_BUFFER_WRITE) {\n\t\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t \n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\n\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = e1000_desc_unused(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\n\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->total_rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\nstatic void e1000_put_txbuf(struct e1000_ring *tx_ring,\n\t\t\t    struct e1000_buffer *buffer_info,\n\t\t\t    bool drop)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\n\tif (buffer_info->dma) {\n\t\tif (buffer_info->mapped_as_page)\n\t\t\tdma_unmap_page(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t       buffer_info->length, DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t\t buffer_info->length, DMA_TO_DEVICE);\n\t\tbuffer_info->dma = 0;\n\t}\n\tif (buffer_info->skb) {\n\t\tif (drop)\n\t\t\tdev_kfree_skb_any(buffer_info->skb);\n\t\telse\n\t\t\tdev_consume_skb_any(buffer_info->skb);\n\t\tbuffer_info->skb = NULL;\n\t}\n\tbuffer_info->time_stamp = 0;\n}\n\nstatic void e1000_print_hw_hang(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     print_hang_task);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tunsigned int i = tx_ring->next_to_clean;\n\tunsigned int eop = tx_ring->buffer_info[i].next_to_watch;\n\tstruct e1000_tx_desc *eop_desc = E1000_TX_DESC(*tx_ring, eop);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 phy_status, phy_1000t_status, phy_ext_status;\n\tu16 pci_status;\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tif (!adapter->tx_hang_recheck && (adapter->flags2 & FLAG2_DMA_BURST)) {\n\t\t \n\t\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\t\t \n\t\te1e_flush();\n\t\t \n\t\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\t\t \n\t\te1e_flush();\n\t\tadapter->tx_hang_recheck = true;\n\t\treturn;\n\t}\n\tadapter->tx_hang_recheck = false;\n\n\tif (er32(TDH(0)) == er32(TDT(0))) {\n\t\te_dbg(\"false hang detected, ignoring\\n\");\n\t\treturn;\n\t}\n\n\t \n\tnetif_stop_queue(netdev);\n\n\te1e_rphy(hw, MII_BMSR, &phy_status);\n\te1e_rphy(hw, MII_STAT1000, &phy_1000t_status);\n\te1e_rphy(hw, MII_ESTATUS, &phy_ext_status);\n\n\tpci_read_config_word(adapter->pdev, PCI_STATUS, &pci_status);\n\n\t \n\te_err(\"Detected Hardware Unit Hang:\\n\"\n\t      \"  TDH                  <%x>\\n\"\n\t      \"  TDT                  <%x>\\n\"\n\t      \"  next_to_use          <%x>\\n\"\n\t      \"  next_to_clean        <%x>\\n\"\n\t      \"buffer_info[next_to_clean]:\\n\"\n\t      \"  time_stamp           <%lx>\\n\"\n\t      \"  next_to_watch        <%x>\\n\"\n\t      \"  jiffies              <%lx>\\n\"\n\t      \"  next_to_watch.status <%x>\\n\"\n\t      \"MAC Status             <%x>\\n\"\n\t      \"PHY Status             <%x>\\n\"\n\t      \"PHY 1000BASE-T Status  <%x>\\n\"\n\t      \"PHY Extended Status    <%x>\\n\"\n\t      \"PCI Status             <%x>\\n\",\n\t      readl(tx_ring->head), readl(tx_ring->tail), tx_ring->next_to_use,\n\t      tx_ring->next_to_clean, tx_ring->buffer_info[eop].time_stamp,\n\t      eop, jiffies, eop_desc->upper.fields.status, er32(STATUS),\n\t      phy_status, phy_1000t_status, phy_ext_status, pci_status);\n\n\te1000e_dump(adapter);\n\n\t \n\tif ((hw->mac.type == e1000_pchlan) && (er32(CTRL) & E1000_CTRL_TFCE))\n\t\te_err(\"Try turning off Tx pause (flow control) via ethtool\\n\");\n}\n\n \nstatic void e1000e_tx_hwtstamp_work(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work, struct e1000_adapter,\n\t\t\t\t\t\t     tx_hwtstamp_work);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_VALID) {\n\t\tstruct sk_buff *skb = adapter->tx_hwtstamp_skb;\n\t\tstruct skb_shared_hwtstamps shhwtstamps;\n\t\tu64 txstmp;\n\n\t\ttxstmp = er32(TXSTMPL);\n\t\ttxstmp |= (u64)er32(TXSTMPH) << 32;\n\n\t\te1000e_systim_to_hwtstamp(adapter, &shhwtstamps, txstmp);\n\n\t\t \n\t\tadapter->tx_hwtstamp_skb = NULL;\n\t\twmb();  \n\n\t\tskb_tstamp_tx(skb, &shhwtstamps);\n\t\tdev_consume_skb_any(skb);\n\t} else if (time_after(jiffies, adapter->tx_hwtstamp_start\n\t\t\t      + adapter->tx_timeout_factor * HZ)) {\n\t\tdev_kfree_skb_any(adapter->tx_hwtstamp_skb);\n\t\tadapter->tx_hwtstamp_skb = NULL;\n\t\tadapter->tx_hwtstamp_timeouts++;\n\t\te_warn(\"clearing Tx timestamp hang\\n\");\n\t} else {\n\t\t \n\t\tschedule_work(&adapter->tx_hwtstamp_work);\n\t}\n}\n\n \nstatic bool e1000_clean_tx_irq(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_tx_desc *tx_desc, *eop_desc;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int i, eop;\n\tunsigned int count = 0;\n\tunsigned int total_tx_bytes = 0, total_tx_packets = 0;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\n\ti = tx_ring->next_to_clean;\n\teop = tx_ring->buffer_info[i].next_to_watch;\n\teop_desc = E1000_TX_DESC(*tx_ring, eop);\n\n\twhile ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&\n\t       (count < tx_ring->count)) {\n\t\tbool cleaned = false;\n\n\t\tdma_rmb();\t\t \n\t\tfor (; !cleaned; count++) {\n\t\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\t\tcleaned = (i == eop);\n\n\t\t\tif (cleaned) {\n\t\t\t\ttotal_tx_packets += buffer_info->segs;\n\t\t\t\ttotal_tx_bytes += buffer_info->bytecount;\n\t\t\t\tif (buffer_info->skb) {\n\t\t\t\t\tbytes_compl += buffer_info->skb->len;\n\t\t\t\t\tpkts_compl++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te1000_put_txbuf(tx_ring, buffer_info, false);\n\t\t\ttx_desc->upper.data = 0;\n\n\t\t\ti++;\n\t\t\tif (i == tx_ring->count)\n\t\t\t\ti = 0;\n\t\t}\n\n\t\tif (i == tx_ring->next_to_use)\n\t\t\tbreak;\n\t\teop = tx_ring->buffer_info[i].next_to_watch;\n\t\teop_desc = E1000_TX_DESC(*tx_ring, eop);\n\t}\n\n\ttx_ring->next_to_clean = i;\n\n\tnetdev_completed_queue(netdev, pkts_compl, bytes_compl);\n\n#define TX_WAKE_THRESHOLD 32\n\tif (count && netif_carrier_ok(netdev) &&\n\t    e1000_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD) {\n\t\t \n\t\tsmp_mb();\n\n\t\tif (netif_queue_stopped(netdev) &&\n\t\t    !(test_bit(__E1000_DOWN, &adapter->state))) {\n\t\t\tnetif_wake_queue(netdev);\n\t\t\t++adapter->restart_queue;\n\t\t}\n\t}\n\n\tif (adapter->detect_tx_hung) {\n\t\t \n\t\tadapter->detect_tx_hung = false;\n\t\tif (tx_ring->buffer_info[i].time_stamp &&\n\t\t    time_after(jiffies, tx_ring->buffer_info[i].time_stamp\n\t\t\t       + (adapter->tx_timeout_factor * HZ)) &&\n\t\t    !(er32(STATUS) & E1000_STATUS_TXOFF))\n\t\t\tschedule_work(&adapter->print_hang_task);\n\t\telse\n\t\t\tadapter->tx_hang_recheck = false;\n\t}\n\tadapter->total_tx_bytes += total_tx_bytes;\n\tadapter->total_tx_packets += total_tx_packets;\n\treturn count < tx_ring->count;\n}\n\n \nstatic bool e1000_clean_rx_irq_ps(struct e1000_ring *rx_ring, int *work_done,\n\t\t\t\t  int work_to_do)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunion e1000_rx_desc_packet_split *rx_desc, *next_rxd;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tstruct e1000_ps_page *ps_page;\n\tstruct sk_buff *skb;\n\tunsigned int i, j;\n\tu32 length, staterr;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC_PS(*rx_ring, i);\n\tstaterr = le32_to_cpu(rx_desc->wb.middle.status_error);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (staterr & E1000_RXD_STAT_DD) {\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tskb = buffer_info->skb;\n\t\tdma_rmb();\t \n\n\t\t \n\t\tprefetch(skb->data - NET_IP_ALIGN);\n\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tnext_rxd = E1000_RX_DESC_PS(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t adapter->rx_ps_bsize0, DMA_FROM_DEVICE);\n\t\tbuffer_info->dma = 0;\n\n\t\t \n\t\tif (!(staterr & E1000_RXD_STAT_EOP))\n\t\t\tadapter->flags2 |= FLAG2_IS_DISCARDING;\n\n\t\tif (adapter->flags2 & FLAG2_IS_DISCARDING) {\n\t\t\te_dbg(\"Packet Split buffers didn't pick up the full packet\\n\");\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tif (staterr & E1000_RXD_STAT_EOP)\n\t\t\t\tadapter->flags2 &= ~FLAG2_IS_DISCARDING;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tif (unlikely((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\n\t\t\t     !(netdev->features & NETIF_F_RXALL))) {\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tlength = le16_to_cpu(rx_desc->wb.middle.length0);\n\n\t\tif (!length) {\n\t\t\te_dbg(\"Last part of the packet spanning multiple descriptors\\n\");\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\t \n\t\tskb_put(skb, length);\n\n\t\t{\n\t\t\t \n\t\t\tint l1 = le16_to_cpu(rx_desc->wb.upper.length[0]);\n\n\t\t\t \n\t\t\tif (l1 && (l1 <= copybreak) &&\n\t\t\t    ((length + l1) <= adapter->rx_ps_bsize0)) {\n\t\t\t\tps_page = &buffer_info->ps_pages[0];\n\n\t\t\t\tdma_sync_single_for_cpu(&pdev->dev,\n\t\t\t\t\t\t\tps_page->dma,\n\t\t\t\t\t\t\tPAGE_SIZE,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tmemcpy(skb_tail_pointer(skb),\n\t\t\t\t       page_address(ps_page->page), l1);\n\t\t\t\tdma_sync_single_for_device(&pdev->dev,\n\t\t\t\t\t\t\t   ps_page->dma,\n\t\t\t\t\t\t\t   PAGE_SIZE,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t\t\t \n\t\t\t\tif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\n\t\t\t\t\tif (!(netdev->features & NETIF_F_RXFCS))\n\t\t\t\t\t\tl1 -= 4;\n\t\t\t\t}\n\n\t\t\t\tskb_put(skb, l1);\n\t\t\t\tgoto copydone;\n\t\t\t}\t \n\t\t}\n\n\t\tfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\n\t\t\tlength = le16_to_cpu(rx_desc->wb.upper.length[j]);\n\t\t\tif (!length)\n\t\t\t\tbreak;\n\n\t\t\tps_page = &buffer_info->ps_pages[j];\n\t\t\tdma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tps_page->dma = 0;\n\t\t\tskb_fill_page_desc(skb, j, ps_page->page, 0, length);\n\t\t\tps_page->page = NULL;\n\t\t\tskb->len += length;\n\t\t\tskb->data_len += length;\n\t\t\tskb->truesize += PAGE_SIZE;\n\t\t}\n\n\t\t \n\t\tif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\n\t\t\tif (!(netdev->features & NETIF_F_RXFCS))\n\t\t\t\tpskb_trim(skb, skb->len - 4);\n\t\t}\n\ncopydone:\n\t\ttotal_rx_bytes += skb->len;\n\t\ttotal_rx_packets++;\n\n\t\te1000_rx_checksum(adapter, staterr, skb);\n\n\t\te1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\n\n\t\tif (rx_desc->wb.upper.header_status &\n\t\t    cpu_to_le16(E1000_RXDPS_HDRSTAT_HDRSP))\n\t\t\tadapter->rx_hdr_split++;\n\n\t\te1000_receive_skb(adapter, netdev, skb, staterr,\n\t\t\t\t  rx_desc->wb.middle.vlan);\n\nnext_desc:\n\t\trx_desc->wb.middle.status_error &= cpu_to_le32(~0xFF);\n\t\tbuffer_info->skb = NULL;\n\n\t\t \n\t\tif (cleaned_count >= E1000_RX_BUFFER_WRITE) {\n\t\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t \n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\n\t\tstaterr = le32_to_cpu(rx_desc->wb.middle.status_error);\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = e1000_desc_unused(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\n\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->total_rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\nstatic void e1000_consume_page(struct e1000_buffer *bi, struct sk_buff *skb,\n\t\t\t       u16 length)\n{\n\tbi->page = NULL;\n\tskb->len += length;\n\tskb->data_len += length;\n\tskb->truesize += PAGE_SIZE;\n}\n\n \nstatic bool e1000_clean_jumbo_rx_irq(struct e1000_ring *rx_ring, int *work_done,\n\t\t\t\t     int work_to_do)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_extended *rx_desc, *next_rxd;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tu32 length, staterr;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\tstruct skb_shared_info *shinfo;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (staterr & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tdma_rmb();\t \n\n\t\tskb = buffer_info->skb;\n\t\tbuffer_info->skb = NULL;\n\n\t\t++i;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tnext_rxd = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tdma_unmap_page(&pdev->dev, buffer_info->dma, PAGE_SIZE,\n\t\t\t       DMA_FROM_DEVICE);\n\t\tbuffer_info->dma = 0;\n\n\t\tlength = le16_to_cpu(rx_desc->wb.upper.length);\n\n\t\t \n\t\tif (unlikely((staterr & E1000_RXD_STAT_EOP) &&\n\t\t\t     ((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\n\t\t\t      !(netdev->features & NETIF_F_RXALL)))) {\n\t\t\t \n\t\t\tbuffer_info->skb = skb;\n\t\t\t \n\t\t\tif (rx_ring->rx_skb_top)\n\t\t\t\tdev_kfree_skb_irq(rx_ring->rx_skb_top);\n\t\t\trx_ring->rx_skb_top = NULL;\n\t\t\tgoto next_desc;\n\t\t}\n#define rxtop (rx_ring->rx_skb_top)\n\t\tif (!(staterr & E1000_RXD_STAT_EOP)) {\n\t\t\t \n\t\t\tif (!rxtop) {\n\t\t\t\t \n\t\t\t\trxtop = skb;\n\t\t\t\tskb_fill_page_desc(rxtop, 0, buffer_info->page,\n\t\t\t\t\t\t   0, length);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tshinfo = skb_shinfo(rxtop);\n\t\t\t\tskb_fill_page_desc(rxtop, shinfo->nr_frags,\n\t\t\t\t\t\t   buffer_info->page, 0,\n\t\t\t\t\t\t   length);\n\t\t\t\t \n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t}\n\t\t\te1000_consume_page(buffer_info, rxtop, length);\n\t\t\tgoto next_desc;\n\t\t} else {\n\t\t\tif (rxtop) {\n\t\t\t\t \n\t\t\t\tshinfo = skb_shinfo(rxtop);\n\t\t\t\tskb_fill_page_desc(rxtop, shinfo->nr_frags,\n\t\t\t\t\t\t   buffer_info->page, 0,\n\t\t\t\t\t\t   length);\n\t\t\t\t \n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tskb = rxtop;\n\t\t\t\trxtop = NULL;\n\t\t\t\te1000_consume_page(buffer_info, skb, length);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (length <= copybreak &&\n\t\t\t\t    skb_tailroom(skb) >= length) {\n\t\t\t\t\tmemcpy(skb_tail_pointer(skb),\n\t\t\t\t\t       page_address(buffer_info->page),\n\t\t\t\t\t       length);\n\t\t\t\t\t \n\t\t\t\t\tskb_put(skb, length);\n\t\t\t\t} else {\n\t\t\t\t\tskb_fill_page_desc(skb, 0,\n\t\t\t\t\t\t\t   buffer_info->page, 0,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t\te1000_consume_page(buffer_info, skb,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\te1000_rx_checksum(adapter, staterr, skb);\n\n\t\te1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\n\n\t\t \n\t\ttotal_rx_bytes += skb->len;\n\t\ttotal_rx_packets++;\n\n\t\t \n\t\tif (!pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\te_err(\"pskb_may_pull failed.\\n\");\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\te1000_receive_skb(adapter, netdev, skb, staterr,\n\t\t\t\t  rx_desc->wb.upper.vlan);\n\nnext_desc:\n\t\trx_desc->wb.upper.status_error &= cpu_to_le32(~0xFF);\n\n\t\t \n\t\tif (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {\n\t\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t \n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\n\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = e1000_desc_unused(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\n\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->total_rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\n \nstatic void e1000_clean_rx_ring(struct e1000_ring *rx_ring)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_buffer *buffer_info;\n\tstruct e1000_ps_page *ps_page;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunsigned int i, j;\n\n\t \n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tif (buffer_info->dma) {\n\t\t\tif (adapter->clean_rx == e1000_clean_rx_irq)\n\t\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t\t adapter->rx_buffer_len,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\telse if (adapter->clean_rx == e1000_clean_jumbo_rx_irq)\n\t\t\t\tdma_unmap_page(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\telse if (adapter->clean_rx == e1000_clean_rx_irq_ps)\n\t\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t\t adapter->rx_ps_bsize0,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tbuffer_info->dma = 0;\n\t\t}\n\n\t\tif (buffer_info->page) {\n\t\t\tput_page(buffer_info->page);\n\t\t\tbuffer_info->page = NULL;\n\t\t}\n\n\t\tif (buffer_info->skb) {\n\t\t\tdev_kfree_skb(buffer_info->skb);\n\t\t\tbuffer_info->skb = NULL;\n\t\t}\n\n\t\tfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\n\t\t\tps_page = &buffer_info->ps_pages[j];\n\t\t\tif (!ps_page->page)\n\t\t\t\tbreak;\n\t\t\tdma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tps_page->dma = 0;\n\t\t\tput_page(ps_page->page);\n\t\t\tps_page->page = NULL;\n\t\t}\n\t}\n\n\t \n\tif (rx_ring->rx_skb_top) {\n\t\tdev_kfree_skb(rx_ring->rx_skb_top);\n\t\trx_ring->rx_skb_top = NULL;\n\t}\n\n\t \n\tmemset(rx_ring->desc, 0, rx_ring->size);\n\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\tadapter->flags2 &= ~FLAG2_IS_DISCARDING;\n}\n\nstatic void e1000e_downshift_workaround(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     downshift_task);\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\te1000e_gig_downshift_workaround_ich8lan(&adapter->hw);\n}\n\n \nstatic irqreturn_t e1000_intr_msi(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = er32(ICR);\n\n\t \n\tif (icr & E1000_ICR_LSC) {\n\t\thw->mac.get_link_status = true;\n\t\t \n\t\tif ((adapter->flags & FLAG_LSC_GIG_SPEED_DROP) &&\n\t\t    (!(er32(STATUS) & E1000_STATUS_LU)))\n\t\t\tschedule_work(&adapter->downshift_task);\n\n\t\t \n\t\tif (netif_carrier_ok(netdev) &&\n\t\t    adapter->flags & FLAG_RX_NEEDS_RESTART) {\n\t\t\t \n\t\t\tu32 rctl = er32(RCTL);\n\n\t\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t\t\tadapter->flags |= FLAG_RESTART_NOW;\n\t\t}\n\t\t \n\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\t \n\tif ((icr & E1000_ICR_ECCER) && (hw->mac.type >= e1000_pch_lpt)) {\n\t\tu32 pbeccsts = er32(PBECCSTS);\n\n\t\tadapter->corr_errors +=\n\t\t    pbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\n\t\tadapter->uncorr_errors +=\n\t\t    (pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\n\t\t    E1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\n\n\t\t \n\t\tschedule_work(&adapter->reset_task);\n\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (napi_schedule_prep(&adapter->napi)) {\n\t\tadapter->total_tx_bytes = 0;\n\t\tadapter->total_tx_packets = 0;\n\t\tadapter->total_rx_bytes = 0;\n\t\tadapter->total_rx_packets = 0;\n\t\t__napi_schedule(&adapter->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t e1000_intr(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl, icr = er32(ICR);\n\n\tif (!icr || test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn IRQ_NONE;\t \n\n\t \n\tif (!(icr & E1000_ICR_INT_ASSERTED))\n\t\treturn IRQ_NONE;\n\n\t \n\n\tif (icr & E1000_ICR_LSC) {\n\t\thw->mac.get_link_status = true;\n\t\t \n\t\tif ((adapter->flags & FLAG_LSC_GIG_SPEED_DROP) &&\n\t\t    (!(er32(STATUS) & E1000_STATUS_LU)))\n\t\t\tschedule_work(&adapter->downshift_task);\n\n\t\t \n\t\tif (netif_carrier_ok(netdev) &&\n\t\t    (adapter->flags & FLAG_RX_NEEDS_RESTART)) {\n\t\t\t \n\t\t\trctl = er32(RCTL);\n\t\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t\t\tadapter->flags |= FLAG_RESTART_NOW;\n\t\t}\n\t\t \n\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\t \n\tif ((icr & E1000_ICR_ECCER) && (hw->mac.type >= e1000_pch_lpt)) {\n\t\tu32 pbeccsts = er32(PBECCSTS);\n\n\t\tadapter->corr_errors +=\n\t\t    pbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\n\t\tadapter->uncorr_errors +=\n\t\t    (pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\n\t\t    E1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\n\n\t\t \n\t\tschedule_work(&adapter->reset_task);\n\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (napi_schedule_prep(&adapter->napi)) {\n\t\tadapter->total_tx_bytes = 0;\n\t\tadapter->total_tx_packets = 0;\n\t\tadapter->total_rx_bytes = 0;\n\t\tadapter->total_rx_packets = 0;\n\t\t__napi_schedule(&adapter->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t e1000_msix_other(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = er32(ICR);\n\n\tif (icr & adapter->eiac_mask)\n\t\tew32(ICS, (icr & adapter->eiac_mask));\n\n\tif (icr & E1000_ICR_LSC) {\n\t\thw->mac.get_link_status = true;\n\t\t \n\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\tew32(IMS, E1000_IMS_OTHER | IMS_OTHER_MASK);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t e1000_intr_msix_tx(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\n\tadapter->total_tx_bytes = 0;\n\tadapter->total_tx_packets = 0;\n\n\tif (!e1000_clean_tx_irq(tx_ring))\n\t\t \n\t\tew32(ICS, tx_ring->ims_val);\n\n\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\tew32(IMS, adapter->tx_ring->ims_val);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t e1000_intr_msix_rx(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\n\t \n\tif (rx_ring->set_itr) {\n\t\tu32 itr = rx_ring->itr_val ?\n\t\t\t  1000000000 / (rx_ring->itr_val * 256) : 0;\n\n\t\twritel(itr, rx_ring->itr_register);\n\t\trx_ring->set_itr = 0;\n\t}\n\n\tif (napi_schedule_prep(&adapter->napi)) {\n\t\tadapter->total_rx_bytes = 0;\n\t\tadapter->total_rx_packets = 0;\n\t\t__napi_schedule(&adapter->napi);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void e1000_configure_msix(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tint vector = 0;\n\tu32 ctrl_ext, ivar = 0;\n\n\tadapter->eiac_mask = 0;\n\n\t \n\tif (hw->mac.type == e1000_82574) {\n\t\tu32 rfctl = er32(RFCTL);\n\n\t\trfctl |= E1000_RFCTL_ACK_DIS;\n\t\tew32(RFCTL, rfctl);\n\t}\n\n\t \n\trx_ring->ims_val = E1000_IMS_RXQ0;\n\tadapter->eiac_mask |= rx_ring->ims_val;\n\tif (rx_ring->itr_val)\n\t\twritel(1000000000 / (rx_ring->itr_val * 256),\n\t\t       rx_ring->itr_register);\n\telse\n\t\twritel(1, rx_ring->itr_register);\n\tivar = E1000_IVAR_INT_ALLOC_VALID | vector;\n\n\t \n\ttx_ring->ims_val = E1000_IMS_TXQ0;\n\tvector++;\n\tif (tx_ring->itr_val)\n\t\twritel(1000000000 / (tx_ring->itr_val * 256),\n\t\t       tx_ring->itr_register);\n\telse\n\t\twritel(1, tx_ring->itr_register);\n\tadapter->eiac_mask |= tx_ring->ims_val;\n\tivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) << 8);\n\n\t \n\tvector++;\n\tivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) << 16);\n\tif (rx_ring->itr_val)\n\t\twritel(1000000000 / (rx_ring->itr_val * 256),\n\t\t       hw->hw_addr + E1000_EITR_82574(vector));\n\telse\n\t\twritel(1, hw->hw_addr + E1000_EITR_82574(vector));\n\n\t \n\tivar |= BIT(31);\n\n\tew32(IVAR, ivar);\n\n\t \n\tctrl_ext = er32(CTRL_EXT) & ~E1000_CTRL_EXT_IAME;\n\tctrl_ext |= E1000_CTRL_EXT_PBA_CLR | E1000_CTRL_EXT_EIAME;\n\tew32(CTRL_EXT, ctrl_ext);\n\te1e_flush();\n}\n\nvoid e1000e_reset_interrupt_capability(struct e1000_adapter *adapter)\n{\n\tif (adapter->msix_entries) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tkfree(adapter->msix_entries);\n\t\tadapter->msix_entries = NULL;\n\t} else if (adapter->flags & FLAG_MSI_ENABLED) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tadapter->flags &= ~FLAG_MSI_ENABLED;\n\t}\n}\n\n \nvoid e1000e_set_interrupt_capability(struct e1000_adapter *adapter)\n{\n\tint err;\n\tint i;\n\n\tswitch (adapter->int_mode) {\n\tcase E1000E_INT_MODE_MSIX:\n\t\tif (adapter->flags & FLAG_HAS_MSIX) {\n\t\t\tadapter->num_vectors = 3;  \n\t\t\tadapter->msix_entries = kcalloc(adapter->num_vectors,\n\t\t\t\t\t\t\tsizeof(struct\n\t\t\t\t\t\t\t       msix_entry),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (adapter->msix_entries) {\n\t\t\t\tstruct e1000_adapter *a = adapter;\n\n\t\t\t\tfor (i = 0; i < adapter->num_vectors; i++)\n\t\t\t\t\tadapter->msix_entries[i].entry = i;\n\n\t\t\t\terr = pci_enable_msix_range(a->pdev,\n\t\t\t\t\t\t\t    a->msix_entries,\n\t\t\t\t\t\t\t    a->num_vectors,\n\t\t\t\t\t\t\t    a->num_vectors);\n\t\t\t\tif (err > 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\te_err(\"Failed to initialize MSI-X interrupts.  Falling back to MSI interrupts.\\n\");\n\t\t\te1000e_reset_interrupt_capability(adapter);\n\t\t}\n\t\tadapter->int_mode = E1000E_INT_MODE_MSI;\n\t\tfallthrough;\n\tcase E1000E_INT_MODE_MSI:\n\t\tif (!pci_enable_msi(adapter->pdev)) {\n\t\t\tadapter->flags |= FLAG_MSI_ENABLED;\n\t\t} else {\n\t\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t\t\te_err(\"Failed to initialize MSI interrupts.  Falling back to legacy interrupts.\\n\");\n\t\t}\n\t\tfallthrough;\n\tcase E1000E_INT_MODE_LEGACY:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tadapter->num_vectors = 1;\n}\n\n \nstatic int e1000_request_msix(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err = 0, vector = 0;\n\n\tif (strlen(netdev->name) < (IFNAMSIZ - 5))\n\t\tsnprintf(adapter->rx_ring->name,\n\t\t\t sizeof(adapter->rx_ring->name) - 1,\n\t\t\t \"%.14s-rx-0\", netdev->name);\n\telse\n\t\tmemcpy(adapter->rx_ring->name, netdev->name, IFNAMSIZ);\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_intr_msix_rx, 0, adapter->rx_ring->name,\n\t\t\t  netdev);\n\tif (err)\n\t\treturn err;\n\tadapter->rx_ring->itr_register = adapter->hw.hw_addr +\n\t    E1000_EITR_82574(vector);\n\tadapter->rx_ring->itr_val = adapter->itr;\n\tvector++;\n\n\tif (strlen(netdev->name) < (IFNAMSIZ - 5))\n\t\tsnprintf(adapter->tx_ring->name,\n\t\t\t sizeof(adapter->tx_ring->name) - 1,\n\t\t\t \"%.14s-tx-0\", netdev->name);\n\telse\n\t\tmemcpy(adapter->tx_ring->name, netdev->name, IFNAMSIZ);\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_intr_msix_tx, 0, adapter->tx_ring->name,\n\t\t\t  netdev);\n\tif (err)\n\t\treturn err;\n\tadapter->tx_ring->itr_register = adapter->hw.hw_addr +\n\t    E1000_EITR_82574(vector);\n\tadapter->tx_ring->itr_val = adapter->itr;\n\tvector++;\n\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_msix_other, 0, netdev->name, netdev);\n\tif (err)\n\t\treturn err;\n\n\te1000_configure_msix(adapter);\n\n\treturn 0;\n}\n\n \nstatic int e1000_request_irq(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\n\tif (adapter->msix_entries) {\n\t\terr = e1000_request_msix(adapter);\n\t\tif (!err)\n\t\t\treturn err;\n\t\t \n\t\te1000e_reset_interrupt_capability(adapter);\n\t\tadapter->int_mode = E1000E_INT_MODE_MSI;\n\t\te1000e_set_interrupt_capability(adapter);\n\t}\n\tif (adapter->flags & FLAG_MSI_ENABLED) {\n\t\terr = request_irq(adapter->pdev->irq, e1000_intr_msi, 0,\n\t\t\t\t  netdev->name, netdev);\n\t\tif (!err)\n\t\t\treturn err;\n\n\t\t \n\t\te1000e_reset_interrupt_capability(adapter);\n\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t}\n\n\terr = request_irq(adapter->pdev->irq, e1000_intr, IRQF_SHARED,\n\t\t\t  netdev->name, netdev);\n\tif (err)\n\t\te_err(\"Unable to allocate interrupt, Error: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void e1000_free_irq(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (adapter->msix_entries) {\n\t\tint vector = 0;\n\n\t\tfree_irq(adapter->msix_entries[vector].vector, netdev);\n\t\tvector++;\n\n\t\tfree_irq(adapter->msix_entries[vector].vector, netdev);\n\t\tvector++;\n\n\t\t \n\t\tfree_irq(adapter->msix_entries[vector].vector, netdev);\n\t\treturn;\n\t}\n\n\tfree_irq(adapter->pdev->irq, netdev);\n}\n\n \nstatic void e1000_irq_disable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tew32(IMC, ~0);\n\tif (adapter->msix_entries)\n\t\tew32(EIAC_82574, 0);\n\te1e_flush();\n\n\tif (adapter->msix_entries) {\n\t\tint i;\n\n\t\tfor (i = 0; i < adapter->num_vectors; i++)\n\t\t\tsynchronize_irq(adapter->msix_entries[i].vector);\n\t} else {\n\t\tsynchronize_irq(adapter->pdev->irq);\n\t}\n}\n\n \nstatic void e1000_irq_enable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (adapter->msix_entries) {\n\t\tew32(EIAC_82574, adapter->eiac_mask & E1000_EIAC_MASK_82574);\n\t\tew32(IMS, adapter->eiac_mask | E1000_IMS_OTHER |\n\t\t     IMS_OTHER_MASK);\n\t} else if (hw->mac.type >= e1000_pch_lpt) {\n\t\tew32(IMS, IMS_ENABLE_MASK | E1000_IMS_ECCER);\n\t} else {\n\t\tew32(IMS, IMS_ENABLE_MASK);\n\t}\n\te1e_flush();\n}\n\n \nvoid e1000e_get_hw_control(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext;\n\tu32 swsm;\n\n\t \n\tif (adapter->flags & FLAG_HAS_SWSM_ON_LOAD) {\n\t\tswsm = er32(SWSM);\n\t\tew32(SWSM, swsm | E1000_SWSM_DRV_LOAD);\n\t} else if (adapter->flags & FLAG_HAS_CTRLEXT_ON_LOAD) {\n\t\tctrl_ext = er32(CTRL_EXT);\n\t\tew32(CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_DRV_LOAD);\n\t}\n}\n\n \nvoid e1000e_release_hw_control(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext;\n\tu32 swsm;\n\n\t \n\tif (adapter->flags & FLAG_HAS_SWSM_ON_LOAD) {\n\t\tswsm = er32(SWSM);\n\t\tew32(SWSM, swsm & ~E1000_SWSM_DRV_LOAD);\n\t} else if (adapter->flags & FLAG_HAS_CTRLEXT_ON_LOAD) {\n\t\tctrl_ext = er32(CTRL_EXT);\n\t\tew32(CTRL_EXT, ctrl_ext & ~E1000_CTRL_EXT_DRV_LOAD);\n\t}\n}\n\n \nstatic int e1000_alloc_ring_dma(struct e1000_adapter *adapter,\n\t\t\t\tstruct e1000_ring *ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tring->desc = dma_alloc_coherent(&pdev->dev, ring->size, &ring->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring->desc)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nint e1000e_setup_tx_resources(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tint err = -ENOMEM, size;\n\n\tsize = sizeof(struct e1000_buffer) * tx_ring->count;\n\ttx_ring->buffer_info = vzalloc(size);\n\tif (!tx_ring->buffer_info)\n\t\tgoto err;\n\n\t \n\ttx_ring->size = tx_ring->count * sizeof(struct e1000_tx_desc);\n\ttx_ring->size = ALIGN(tx_ring->size, 4096);\n\n\terr = e1000_alloc_ring_dma(adapter, tx_ring);\n\tif (err)\n\t\tgoto err;\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\n\treturn 0;\nerr:\n\tvfree(tx_ring->buffer_info);\n\te_err(\"Unable to allocate memory for the transmit descriptor ring\\n\");\n\treturn err;\n}\n\n \nint e1000e_setup_rx_resources(struct e1000_ring *rx_ring)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_buffer *buffer_info;\n\tint i, size, desc_len, err = -ENOMEM;\n\n\tsize = sizeof(struct e1000_buffer) * rx_ring->count;\n\trx_ring->buffer_info = vzalloc(size);\n\tif (!rx_ring->buffer_info)\n\t\tgoto err;\n\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tbuffer_info->ps_pages = kcalloc(PS_PAGE_BUFFERS,\n\t\t\t\t\t\tsizeof(struct e1000_ps_page),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!buffer_info->ps_pages)\n\t\t\tgoto err_pages;\n\t}\n\n\tdesc_len = sizeof(union e1000_rx_desc_packet_split);\n\n\t \n\trx_ring->size = rx_ring->count * desc_len;\n\trx_ring->size = ALIGN(rx_ring->size, 4096);\n\n\terr = e1000_alloc_ring_dma(adapter, rx_ring);\n\tif (err)\n\t\tgoto err_pages;\n\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\trx_ring->rx_skb_top = NULL;\n\n\treturn 0;\n\nerr_pages:\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tkfree(buffer_info->ps_pages);\n\t}\nerr:\n\tvfree(rx_ring->buffer_info);\n\te_err(\"Unable to allocate memory for the receive descriptor ring\\n\");\n\treturn err;\n}\n\n \nstatic void e1000_clean_tx_ring(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned long size;\n\tunsigned int i;\n\n\tfor (i = 0; i < tx_ring->count; i++) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\te1000_put_txbuf(tx_ring, buffer_info, false);\n\t}\n\n\tnetdev_reset_queue(adapter->netdev);\n\tsize = sizeof(struct e1000_buffer) * tx_ring->count;\n\tmemset(tx_ring->buffer_info, 0, size);\n\n\tmemset(tx_ring->desc, 0, tx_ring->size);\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n}\n\n \nvoid e1000e_free_tx_resources(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\te1000_clean_tx_ring(tx_ring);\n\n\tvfree(tx_ring->buffer_info);\n\ttx_ring->buffer_info = NULL;\n\n\tdma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,\n\t\t\t  tx_ring->dma);\n\ttx_ring->desc = NULL;\n}\n\n \nvoid e1000e_free_rx_resources(struct e1000_ring *rx_ring)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i;\n\n\te1000_clean_rx_ring(rx_ring);\n\n\tfor (i = 0; i < rx_ring->count; i++)\n\t\tkfree(rx_ring->buffer_info[i].ps_pages);\n\n\tvfree(rx_ring->buffer_info);\n\trx_ring->buffer_info = NULL;\n\n\tdma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,\n\t\t\t  rx_ring->dma);\n\trx_ring->desc = NULL;\n}\n\n \nstatic unsigned int e1000_update_itr(u16 itr_setting, int packets, int bytes)\n{\n\tunsigned int retval = itr_setting;\n\n\tif (packets == 0)\n\t\treturn itr_setting;\n\n\tswitch (itr_setting) {\n\tcase lowest_latency:\n\t\t \n\t\tif (bytes / packets > 8000)\n\t\t\tretval = bulk_latency;\n\t\telse if ((packets < 5) && (bytes > 512))\n\t\t\tretval = low_latency;\n\t\tbreak;\n\tcase low_latency:\t \n\t\tif (bytes > 10000) {\n\t\t\t \n\t\t\tif (bytes / packets > 8000)\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets < 10) || ((bytes / packets) > 1200))\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets > 35))\n\t\t\t\tretval = lowest_latency;\n\t\t} else if (bytes / packets > 2000) {\n\t\t\tretval = bulk_latency;\n\t\t} else if (packets <= 2 && bytes < 512) {\n\t\t\tretval = lowest_latency;\n\t\t}\n\t\tbreak;\n\tcase bulk_latency:\t \n\t\tif (bytes > 25000) {\n\t\t\tif (packets > 35)\n\t\t\t\tretval = low_latency;\n\t\t} else if (bytes < 6000) {\n\t\t\tretval = low_latency;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\nstatic void e1000_set_itr(struct e1000_adapter *adapter)\n{\n\tu16 current_itr;\n\tu32 new_itr = adapter->itr;\n\n\t \n\tif (adapter->link_speed != SPEED_1000) {\n\t\tnew_itr = 4000;\n\t\tgoto set_itr_now;\n\t}\n\n\tif (adapter->flags2 & FLAG2_DISABLE_AIM) {\n\t\tnew_itr = 0;\n\t\tgoto set_itr_now;\n\t}\n\n\tadapter->tx_itr = e1000_update_itr(adapter->tx_itr,\n\t\t\t\t\t   adapter->total_tx_packets,\n\t\t\t\t\t   adapter->total_tx_bytes);\n\t \n\tif (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)\n\t\tadapter->tx_itr = low_latency;\n\n\tadapter->rx_itr = e1000_update_itr(adapter->rx_itr,\n\t\t\t\t\t   adapter->total_rx_packets,\n\t\t\t\t\t   adapter->total_rx_bytes);\n\t \n\tif (adapter->itr_setting == 3 && adapter->rx_itr == lowest_latency)\n\t\tadapter->rx_itr = low_latency;\n\n\tcurrent_itr = max(adapter->rx_itr, adapter->tx_itr);\n\n\t \n\tswitch (current_itr) {\n\tcase lowest_latency:\n\t\tnew_itr = 70000;\n\t\tbreak;\n\tcase low_latency:\n\t\tnew_itr = 20000;\t \n\t\tbreak;\n\tcase bulk_latency:\n\t\tnew_itr = 4000;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nset_itr_now:\n\tif (new_itr != adapter->itr) {\n\t\t \n\t\tnew_itr = new_itr > adapter->itr ?\n\t\t    min(adapter->itr + (new_itr >> 2), new_itr) : new_itr;\n\t\tadapter->itr = new_itr;\n\t\tadapter->rx_ring->itr_val = new_itr;\n\t\tif (adapter->msix_entries)\n\t\t\tadapter->rx_ring->set_itr = 1;\n\t\telse\n\t\t\te1000e_write_itr(adapter, new_itr);\n\t}\n}\n\n \nvoid e1000e_write_itr(struct e1000_adapter *adapter, u32 itr)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 new_itr = itr ? 1000000000 / (itr * 256) : 0;\n\n\tif (adapter->msix_entries) {\n\t\tint vector;\n\n\t\tfor (vector = 0; vector < adapter->num_vectors; vector++)\n\t\t\twritel(new_itr, hw->hw_addr + E1000_EITR_82574(vector));\n\t} else {\n\t\tew32(ITR, new_itr);\n\t}\n}\n\n \nstatic int e1000_alloc_queues(struct e1000_adapter *adapter)\n{\n\tint size = sizeof(struct e1000_ring);\n\n\tadapter->tx_ring = kzalloc(size, GFP_KERNEL);\n\tif (!adapter->tx_ring)\n\t\tgoto err;\n\tadapter->tx_ring->count = adapter->tx_ring_count;\n\tadapter->tx_ring->adapter = adapter;\n\n\tadapter->rx_ring = kzalloc(size, GFP_KERNEL);\n\tif (!adapter->rx_ring)\n\t\tgoto err;\n\tadapter->rx_ring->count = adapter->rx_ring_count;\n\tadapter->rx_ring->adapter = adapter;\n\n\treturn 0;\nerr:\n\te_err(\"Unable to allocate memory for queues\\n\");\n\tkfree(adapter->rx_ring);\n\tkfree(adapter->tx_ring);\n\treturn -ENOMEM;\n}\n\n \nstatic int e1000e_poll(struct napi_struct *napi, int budget)\n{\n\tstruct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,\n\t\t\t\t\t\t     napi);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *poll_dev = adapter->netdev;\n\tint tx_cleaned = 1, work_done = 0;\n\n\tadapter = netdev_priv(poll_dev);\n\n\tif (!adapter->msix_entries ||\n\t    (adapter->rx_ring->ims_val & adapter->tx_ring->ims_val))\n\t\ttx_cleaned = e1000_clean_tx_irq(adapter->tx_ring);\n\n\tadapter->clean_rx(adapter->rx_ring, &work_done, budget);\n\n\tif (!tx_cleaned || work_done == budget)\n\t\treturn budget;\n\n\t \n\tif (likely(napi_complete_done(napi, work_done))) {\n\t\tif (adapter->itr_setting & 3)\n\t\t\te1000_set_itr(adapter);\n\t\tif (!test_bit(__E1000_DOWN, &adapter->state)) {\n\t\t\tif (adapter->msix_entries)\n\t\t\t\tew32(IMS, adapter->rx_ring->ims_val);\n\t\t\telse\n\t\t\t\te1000_irq_enable(adapter);\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\nstatic int e1000_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t __always_unused __be16 proto, u16 vid)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vfta, index;\n\n\t \n\tif ((adapter->hw.mng_cookie.status &\n\t     E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &&\n\t    (vid == adapter->mng_vlan_id))\n\t\treturn 0;\n\n\t \n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\tindex = (vid >> 5) & 0x7F;\n\t\tvfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);\n\t\tvfta |= BIT((vid & 0x1F));\n\t\thw->mac.ops.write_vfta(hw, index, vfta);\n\t}\n\n\tset_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\nstatic int e1000_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t  __always_unused __be16 proto, u16 vid)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vfta, index;\n\n\tif ((adapter->hw.mng_cookie.status &\n\t     E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &&\n\t    (vid == adapter->mng_vlan_id)) {\n\t\t \n\t\te1000e_release_hw_control(adapter);\n\t\treturn 0;\n\t}\n\n\t \n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\tindex = (vid >> 5) & 0x7F;\n\t\tvfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);\n\t\tvfta &= ~BIT((vid & 0x1F));\n\t\thw->mac.ops.write_vfta(hw, index, vfta);\n\t}\n\n\tclear_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\n \nstatic void e1000e_vlan_filter_disable(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\t \n\t\trctl = er32(RCTL);\n\t\trctl &= ~(E1000_RCTL_VFE | E1000_RCTL_CFIEN);\n\t\tew32(RCTL, rctl);\n\n\t\tif (adapter->mng_vlan_id != (u16)E1000_MNG_VLAN_NONE) {\n\t\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\n\t\t\t\t\t       adapter->mng_vlan_id);\n\t\t\tadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\n\t\t}\n\t}\n}\n\n \nstatic void e1000e_vlan_filter_enable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\t \n\t\trctl = er32(RCTL);\n\t\trctl |= E1000_RCTL_VFE;\n\t\trctl &= ~E1000_RCTL_CFIEN;\n\t\tew32(RCTL, rctl);\n\t}\n}\n\n \nstatic void e1000e_vlan_strip_disable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl;\n\n\t \n\tctrl = er32(CTRL);\n\tctrl &= ~E1000_CTRL_VME;\n\tew32(CTRL, ctrl);\n}\n\n \nstatic void e1000e_vlan_strip_enable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl;\n\n\t \n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_VME;\n\tew32(CTRL, ctrl);\n}\n\nstatic void e1000_update_mng_vlan(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu16 vid = adapter->hw.mng_cookie.vlan_id;\n\tu16 old_vid = adapter->mng_vlan_id;\n\n\tif (adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN) {\n\t\te1000_vlan_rx_add_vid(netdev, htons(ETH_P_8021Q), vid);\n\t\tadapter->mng_vlan_id = vid;\n\t}\n\n\tif ((old_vid != (u16)E1000_MNG_VLAN_NONE) && (vid != old_vid))\n\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q), old_vid);\n}\n\nstatic void e1000_restore_vlan(struct e1000_adapter *adapter)\n{\n\tu16 vid;\n\n\te1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), 0);\n\n\tfor_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)\n\t    e1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);\n}\n\nstatic void e1000_init_manageability_pt(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 manc, manc2h, mdef, i, j;\n\n\tif (!(adapter->flags & FLAG_MNG_PT_ENABLED))\n\t\treturn;\n\n\tmanc = er32(MANC);\n\n\t \n\tmanc |= E1000_MANC_EN_MNG2HOST;\n\tmanc2h = er32(MANC2H);\n\n\tswitch (hw->mac.type) {\n\tdefault:\n\t\tmanc2h |= (E1000_MANC2H_PORT_623 | E1000_MANC2H_PORT_664);\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\t \n\t\tfor (i = 0, j = 0; i < 8; i++) {\n\t\t\tmdef = er32(MDEF(i));\n\n\t\t\t \n\t\t\tif (mdef & ~(E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (mdef)\n\t\t\t\tmanc2h |= BIT(i);\n\n\t\t\tj |= mdef;\n\t\t}\n\n\t\tif (j == (E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))\n\t\t\tbreak;\n\n\t\t \n\t\tfor (i = 0, j = 0; i < 8; i++)\n\t\t\tif (er32(MDEF(i)) == 0) {\n\t\t\t\tew32(MDEF(i), (E1000_MDEF_PORT_623 |\n\t\t\t\t\t       E1000_MDEF_PORT_664));\n\t\t\t\tmanc2h |= BIT(1);\n\t\t\t\tj++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!j)\n\t\t\te_warn(\"Unable to create IPMI pass-through filter\\n\");\n\t\tbreak;\n\t}\n\n\tew32(MANC2H, manc2h);\n\tew32(MANC, manc);\n}\n\n \nstatic void e1000_configure_tx(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tu64 tdba;\n\tu32 tdlen, tctl, tarc;\n\n\t \n\ttdba = tx_ring->dma;\n\ttdlen = tx_ring->count * sizeof(struct e1000_tx_desc);\n\tew32(TDBAL(0), (tdba & DMA_BIT_MASK(32)));\n\tew32(TDBAH(0), (tdba >> 32));\n\tew32(TDLEN(0), tdlen);\n\tew32(TDH(0), 0);\n\tew32(TDT(0), 0);\n\ttx_ring->head = adapter->hw.hw_addr + E1000_TDH(0);\n\ttx_ring->tail = adapter->hw.hw_addr + E1000_TDT(0);\n\n\twritel(0, tx_ring->head);\n\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\te1000e_update_tdt_wa(tx_ring, 0);\n\telse\n\t\twritel(0, tx_ring->tail);\n\n\t \n\tew32(TIDV, adapter->tx_int_delay);\n\t \n\tew32(TADV, adapter->tx_abs_int_delay);\n\n\tif (adapter->flags2 & FLAG2_DMA_BURST) {\n\t\tu32 txdctl = er32(TXDCTL(0));\n\n\t\ttxdctl &= ~(E1000_TXDCTL_PTHRESH | E1000_TXDCTL_HTHRESH |\n\t\t\t    E1000_TXDCTL_WTHRESH);\n\t\t \n\t\ttxdctl |= E1000_TXDCTL_DMA_BURST_ENABLE;\n\t\tew32(TXDCTL(0), txdctl);\n\t}\n\t \n\tew32(TXDCTL(1), er32(TXDCTL(0)));\n\n\t \n\ttctl = er32(TCTL);\n\ttctl &= ~E1000_TCTL_CT;\n\ttctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |\n\t\t(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);\n\n\tif (adapter->flags & FLAG_TARC_SPEED_MODE_BIT) {\n\t\ttarc = er32(TARC(0));\n\t\t \n#define SPEED_MODE_BIT BIT(21)\n\t\ttarc |= SPEED_MODE_BIT;\n\t\tew32(TARC(0), tarc);\n\t}\n\n\t \n\tif (adapter->flags & FLAG_TARC_SET_BIT_ZERO) {\n\t\ttarc = er32(TARC(0));\n\t\ttarc |= 1;\n\t\tew32(TARC(0), tarc);\n\t\ttarc = er32(TARC(1));\n\t\ttarc |= 1;\n\t\tew32(TARC(1), tarc);\n\t}\n\n\t \n\tadapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;\n\n\t \n\tif (adapter->tx_int_delay)\n\t\tadapter->txd_cmd |= E1000_TXD_CMD_IDE;\n\n\t \n\tadapter->txd_cmd |= E1000_TXD_CMD_RS;\n\n\tew32(TCTL, tctl);\n\n\thw->mac.ops.config_collision_dist(hw);\n\n\t \n\tif (hw->mac.type == e1000_pch_spt) {\n\t\tu32 reg_val;\n\n\t\treg_val = er32(IOSFPC);\n\t\treg_val |= E1000_RCTL_RDMTS_HEX;\n\t\tew32(IOSFPC, reg_val);\n\n\t\treg_val = er32(TARC(0));\n\t\t \n\t\treg_val &= ~E1000_TARC0_CB_MULTIQ_3_REQ;\n\t\treg_val |= E1000_TARC0_CB_MULTIQ_2_REQ;\n\t\tew32(TARC(0), reg_val);\n\t}\n}\n\n#define PAGE_USE_COUNT(S) (((S) >> PAGE_SHIFT) + \\\n\t\t\t   (((S) & (PAGE_SIZE - 1)) ? 1 : 0))\n\n \nstatic void e1000_setup_rctl(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl, rfctl;\n\tu32 pages = 0;\n\n\t \n\tif (hw->mac.type >= e1000_pch2lan) {\n\t\ts32 ret_val;\n\n\t\tif (adapter->netdev->mtu > ETH_DATA_LEN)\n\t\t\tret_val = e1000_lv_jumbo_workaround_ich8lan(hw, true);\n\t\telse\n\t\t\tret_val = e1000_lv_jumbo_workaround_ich8lan(hw, false);\n\n\t\tif (ret_val)\n\t\t\te_dbg(\"failed to enable|disable jumbo frame workaround mode\\n\");\n\t}\n\n\t \n\trctl = er32(RCTL);\n\trctl &= ~(3 << E1000_RCTL_MO_SHIFT);\n\trctl |= E1000_RCTL_EN | E1000_RCTL_BAM |\n\t    E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |\n\t    (adapter->hw.mac.mc_filter_type << E1000_RCTL_MO_SHIFT);\n\n\t \n\trctl &= ~E1000_RCTL_SBP;\n\n\t \n\tif (adapter->netdev->mtu <= ETH_DATA_LEN)\n\t\trctl &= ~E1000_RCTL_LPE;\n\telse\n\t\trctl |= E1000_RCTL_LPE;\n\n\t \n\tif (adapter->flags2 & FLAG2_CRC_STRIPPING)\n\t\trctl |= E1000_RCTL_SECRC;\n\n\t \n\tif ((hw->phy.type == e1000_phy_82577) && (rctl & E1000_RCTL_LPE)) {\n\t\tu16 phy_data;\n\n\t\te1e_rphy(hw, PHY_REG(770, 26), &phy_data);\n\t\tphy_data &= 0xfff8;\n\t\tphy_data |= BIT(2);\n\t\te1e_wphy(hw, PHY_REG(770, 26), phy_data);\n\n\t\te1e_rphy(hw, 22, &phy_data);\n\t\tphy_data &= 0x0fff;\n\t\tphy_data |= BIT(14);\n\t\te1e_wphy(hw, 0x10, 0x2823);\n\t\te1e_wphy(hw, 0x11, 0x0003);\n\t\te1e_wphy(hw, 22, phy_data);\n\t}\n\n\t \n\trctl &= ~E1000_RCTL_SZ_4096;\n\trctl |= E1000_RCTL_BSEX;\n\tswitch (adapter->rx_buffer_len) {\n\tcase 2048:\n\tdefault:\n\t\trctl |= E1000_RCTL_SZ_2048;\n\t\trctl &= ~E1000_RCTL_BSEX;\n\t\tbreak;\n\tcase 4096:\n\t\trctl |= E1000_RCTL_SZ_4096;\n\t\tbreak;\n\tcase 8192:\n\t\trctl |= E1000_RCTL_SZ_8192;\n\t\tbreak;\n\tcase 16384:\n\t\trctl |= E1000_RCTL_SZ_16384;\n\t\tbreak;\n\t}\n\n\t \n\trfctl = er32(RFCTL);\n\trfctl |= E1000_RFCTL_EXTEN;\n\tew32(RFCTL, rfctl);\n\n\t \n\tpages = PAGE_USE_COUNT(adapter->netdev->mtu);\n\tif ((pages <= 3) && (PAGE_SIZE <= 16384) && (rctl & E1000_RCTL_LPE))\n\t\tadapter->rx_ps_pages = pages;\n\telse\n\t\tadapter->rx_ps_pages = 0;\n\n\tif (adapter->rx_ps_pages) {\n\t\tu32 psrctl = 0;\n\n\t\t \n\t\trctl |= E1000_RCTL_DTYP_PS;\n\n\t\tpsrctl |= adapter->rx_ps_bsize0 >> E1000_PSRCTL_BSIZE0_SHIFT;\n\n\t\tswitch (adapter->rx_ps_pages) {\n\t\tcase 3:\n\t\t\tpsrctl |= PAGE_SIZE << E1000_PSRCTL_BSIZE3_SHIFT;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tpsrctl |= PAGE_SIZE << E1000_PSRCTL_BSIZE2_SHIFT;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\tpsrctl |= PAGE_SIZE >> E1000_PSRCTL_BSIZE1_SHIFT;\n\t\t\tbreak;\n\t\t}\n\n\t\tew32(PSRCTL, psrctl);\n\t}\n\n\t \n\tif (adapter->netdev->features & NETIF_F_RXALL) {\n\t\t \n\t\trctl |= (E1000_RCTL_SBP |\t \n\t\t\t E1000_RCTL_BAM |\t \n\t\t\t E1000_RCTL_PMCF);\t \n\n\t\trctl &= ~(E1000_RCTL_VFE |\t \n\t\t\t  E1000_RCTL_DPF |\t \n\t\t\t  E1000_RCTL_CFIEN);\t \n\t\t \n\t}\n\n\tew32(RCTL, rctl);\n\t \n\tadapter->flags &= ~FLAG_RESTART_NOW;\n}\n\n \nstatic void e1000_configure_rx(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\tu64 rdba;\n\tu32 rdlen, rctl, rxcsum, ctrl_ext;\n\n\tif (adapter->rx_ps_pages) {\n\t\t \n\t\trdlen = rx_ring->count *\n\t\t    sizeof(union e1000_rx_desc_packet_split);\n\t\tadapter->clean_rx = e1000_clean_rx_irq_ps;\n\t\tadapter->alloc_rx_buf = e1000_alloc_rx_buffers_ps;\n\t} else if (adapter->netdev->mtu > ETH_FRAME_LEN + ETH_FCS_LEN) {\n\t\trdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\n\t\tadapter->clean_rx = e1000_clean_jumbo_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;\n\t} else {\n\t\trdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\n\t\tadapter->clean_rx = e1000_clean_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_rx_buffers;\n\t}\n\n\t \n\trctl = er32(RCTL);\n\tif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(10000, 11000);\n\n\tif (adapter->flags2 & FLAG2_DMA_BURST) {\n\t\t \n\t\tew32(RXDCTL(0), E1000_RXDCTL_DMA_BURST_ENABLE);\n\t\tew32(RXDCTL(1), E1000_RXDCTL_DMA_BURST_ENABLE);\n\t}\n\n\t \n\tew32(RDTR, adapter->rx_int_delay);\n\n\t \n\tew32(RADV, adapter->rx_abs_int_delay);\n\tif ((adapter->itr_setting != 0) && (adapter->itr != 0))\n\t\te1000e_write_itr(adapter, adapter->itr);\n\n\tctrl_ext = er32(CTRL_EXT);\n\t \n\tctrl_ext |= E1000_CTRL_EXT_IAME;\n\tew32(IAM, 0xffffffff);\n\tew32(CTRL_EXT, ctrl_ext);\n\te1e_flush();\n\n\t \n\trdba = rx_ring->dma;\n\tew32(RDBAL(0), (rdba & DMA_BIT_MASK(32)));\n\tew32(RDBAH(0), (rdba >> 32));\n\tew32(RDLEN(0), rdlen);\n\tew32(RDH(0), 0);\n\tew32(RDT(0), 0);\n\trx_ring->head = adapter->hw.hw_addr + E1000_RDH(0);\n\trx_ring->tail = adapter->hw.hw_addr + E1000_RDT(0);\n\n\twritel(0, rx_ring->head);\n\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\te1000e_update_rdt_wa(rx_ring, 0);\n\telse\n\t\twritel(0, rx_ring->tail);\n\n\t \n\trxcsum = er32(RXCSUM);\n\tif (adapter->netdev->features & NETIF_F_RXCSUM)\n\t\trxcsum |= E1000_RXCSUM_TUOFL;\n\telse\n\t\trxcsum &= ~E1000_RXCSUM_TUOFL;\n\tew32(RXCSUM, rxcsum);\n\n\t \n\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\tu32 lat =\n\t\t    ((er32(PBA) & E1000_PBA_RXA_MASK) * 1024 -\n\t\t     adapter->max_frame_size) * 8 / 1000;\n\n\t\tif (adapter->flags & FLAG_IS_ICH) {\n\t\t\tu32 rxdctl = er32(RXDCTL(0));\n\n\t\t\tew32(RXDCTL(0), rxdctl | 0x3 | BIT(8));\n\t\t}\n\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Some CPU C-states have been disabled in order to enable jumbo frames\\n\");\n\t\tcpu_latency_qos_update_request(&adapter->pm_qos_req, lat);\n\t} else {\n\t\tcpu_latency_qos_update_request(&adapter->pm_qos_req,\n\t\t\t\t\t       PM_QOS_DEFAULT_VALUE);\n\t}\n\n\t \n\tew32(RCTL, rctl);\n}\n\n \nstatic int e1000e_write_mc_addr_list(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tu8 *mta_list;\n\tint i;\n\n\tif (netdev_mc_empty(netdev)) {\n\t\t \n\t\thw->mac.ops.update_mc_addr_list(hw, NULL, 0);\n\t\treturn 0;\n\t}\n\n\tmta_list = kcalloc(netdev_mc_count(netdev), ETH_ALEN, GFP_ATOMIC);\n\tif (!mta_list)\n\t\treturn -ENOMEM;\n\n\t \n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, netdev)\n\t    memcpy(mta_list + (i++ * ETH_ALEN), ha->addr, ETH_ALEN);\n\n\thw->mac.ops.update_mc_addr_list(hw, mta_list, i);\n\tkfree(mta_list);\n\n\treturn netdev_mc_count(netdev);\n}\n\n \nstatic int e1000e_write_uc_addr_list(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned int rar_entries;\n\tint count = 0;\n\n\trar_entries = hw->mac.ops.rar_get_count(hw);\n\n\t \n\trar_entries--;\n\n\t \n\tif (adapter->flags & FLAG_RESET_OVERWRITES_LAA)\n\t\trar_entries--;\n\n\t \n\tif (netdev_uc_count(netdev) > rar_entries)\n\t\treturn -ENOMEM;\n\n\tif (!netdev_uc_empty(netdev) && rar_entries) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\t \n\t\tnetdev_for_each_uc_addr(ha, netdev) {\n\t\t\tint ret_val;\n\n\t\t\tif (!rar_entries)\n\t\t\t\tbreak;\n\t\t\tret_val = hw->mac.ops.rar_set(hw, ha->addr, rar_entries--);\n\t\t\tif (ret_val < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t \n\tfor (; rar_entries > 0; rar_entries--) {\n\t\tew32(RAH(rar_entries), 0);\n\t\tew32(RAL(rar_entries), 0);\n\t}\n\te1e_flush();\n\n\treturn count;\n}\n\n \nstatic void e1000e_set_rx_mode(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (pm_runtime_suspended(netdev->dev.parent))\n\t\treturn;\n\n\t \n\trctl = er32(RCTL);\n\n\t \n\trctl &= ~(E1000_RCTL_UPE | E1000_RCTL_MPE);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);\n\t\t \n\t\te1000e_vlan_filter_disable(adapter);\n\t} else {\n\t\tint count;\n\n\t\tif (netdev->flags & IFF_ALLMULTI) {\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\t} else {\n\t\t\t \n\t\t\tcount = e1000e_write_mc_addr_list(netdev);\n\t\t\tif (count < 0)\n\t\t\t\trctl |= E1000_RCTL_MPE;\n\t\t}\n\t\te1000e_vlan_filter_enable(adapter);\n\t\t \n\t\tcount = e1000e_write_uc_addr_list(netdev);\n\t\tif (count < 0)\n\t\t\trctl |= E1000_RCTL_UPE;\n\t}\n\n\tew32(RCTL, rctl);\n\n\tif (netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\te1000e_vlan_strip_enable(adapter);\n\telse\n\t\te1000e_vlan_strip_disable(adapter);\n}\n\nstatic void e1000e_setup_rss_hash(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 mrqc, rxcsum;\n\tu32 rss_key[10];\n\tint i;\n\n\tnetdev_rss_key_fill(rss_key, sizeof(rss_key));\n\tfor (i = 0; i < 10; i++)\n\t\tew32(RSSRK(i), rss_key[i]);\n\n\t \n\tfor (i = 0; i < 32; i++)\n\t\tew32(RETA(i), 0);\n\n\t \n\trxcsum = er32(RXCSUM);\n\trxcsum |= E1000_RXCSUM_PCSD;\n\n\tew32(RXCSUM, rxcsum);\n\n\tmrqc = (E1000_MRQC_RSS_FIELD_IPV4 |\n\t\tE1000_MRQC_RSS_FIELD_IPV4_TCP |\n\t\tE1000_MRQC_RSS_FIELD_IPV6 |\n\t\tE1000_MRQC_RSS_FIELD_IPV6_TCP |\n\t\tE1000_MRQC_RSS_FIELD_IPV6_TCP_EX);\n\n\tew32(MRQC, mrqc);\n}\n\n \ns32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 incvalue, incperiod, shift;\n\n\t \n\tif ((hw->mac.type >= e1000_pch_lpt) &&\n\t    !(er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_ENABLED) &&\n\t    !(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_ENABLED)) {\n\t\tu32 fextnvm7 = er32(FEXTNVM7);\n\n\t\tif (!(fextnvm7 & BIT(0))) {\n\t\t\tew32(FEXTNVM7, fextnvm7 | BIT(0));\n\t\t\te1e_flush();\n\t\t}\n\t}\n\n\tswitch (hw->mac.type) {\n\tcase e1000_pch2lan:\n\t\t \n\t\tincperiod = INCPERIOD_96MHZ;\n\t\tincvalue = INCVALUE_96MHZ;\n\t\tshift = INCVALUE_SHIFT_96MHZ;\n\t\tadapter->cc.shift = shift + INCPERIOD_SHIFT_96MHZ;\n\t\tbreak;\n\tcase e1000_pch_lpt:\n\t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI) {\n\t\t\t \n\t\t\tincperiod = INCPERIOD_96MHZ;\n\t\t\tincvalue = INCVALUE_96MHZ;\n\t\t\tshift = INCVALUE_SHIFT_96MHZ;\n\t\t\tadapter->cc.shift = shift + INCPERIOD_SHIFT_96MHZ;\n\t\t} else {\n\t\t\t \n\t\t\tincperiod = INCPERIOD_25MHZ;\n\t\t\tincvalue = INCVALUE_25MHZ;\n\t\t\tshift = INCVALUE_SHIFT_25MHZ;\n\t\t\tadapter->cc.shift = shift;\n\t\t}\n\t\tbreak;\n\tcase e1000_pch_spt:\n\t\t \n\t\tincperiod = INCPERIOD_24MHZ;\n\t\tincvalue = INCVALUE_24MHZ;\n\t\tshift = INCVALUE_SHIFT_24MHZ;\n\t\tadapter->cc.shift = shift;\n\t\tbreak;\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI) {\n\t\t\t \n\t\t\tincperiod = INCPERIOD_24MHZ;\n\t\t\tincvalue = INCVALUE_24MHZ;\n\t\t\tshift = INCVALUE_SHIFT_24MHZ;\n\t\t\tadapter->cc.shift = shift;\n\t\t} else {\n\t\t\t \n\t\t\tincperiod = INCPERIOD_38400KHZ;\n\t\t\tincvalue = INCVALUE_38400KHZ;\n\t\t\tshift = INCVALUE_SHIFT_38400KHZ;\n\t\t\tadapter->cc.shift = shift;\n\t\t}\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\t \n\t\tincperiod = INCPERIOD_25MHZ;\n\t\tincvalue = INCVALUE_25MHZ;\n\t\tshift = INCVALUE_SHIFT_25MHZ;\n\t\tadapter->cc.shift = shift;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*timinca = ((incperiod << E1000_TIMINCA_INCPERIOD_SHIFT) |\n\t\t    ((incvalue << shift) & E1000_TIMINCA_INCVALUE_MASK));\n\n\treturn 0;\n}\n\n \nstatic int e1000e_config_hwtstamp(struct e1000_adapter *adapter,\n\t\t\t\t  struct hwtstamp_config *config)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tsync_tx_ctl = E1000_TSYNCTXCTL_ENABLED;\n\tu32 tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\n\tu32 rxmtrl = 0;\n\tu16 rxudp = 0;\n\tbool is_l4 = false;\n\tbool is_l2 = false;\n\tu32 regval;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\n\t\treturn -EINVAL;\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\ttsync_tx_ctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ttsync_rx_ctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\n\t\trxmtrl = E1000_RXMTRL_PTP_V1_SYNC_MESSAGE;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\n\t\trxmtrl = E1000_RXMTRL_PTP_V1_DELAY_REQ_MESSAGE;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\t\t \n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_SYNC_MESSAGE;\n\t\tis_l2 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\t \n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_DELAY_REQ_MESSAGE;\n\t\tis_l2 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\t \n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\t\t \n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_SYNC_MESSAGE;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\t \n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\t \n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_DELAY_REQ_MESSAGE;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\t \n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_EVENT_V2;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\t \n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\tcase HWTSTAMP_FILTER_ALL:\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tadapter->hwtstamp_config = *config;\n\n\t \n\tregval = er32(TSYNCTXCTL);\n\tregval &= ~E1000_TSYNCTXCTL_ENABLED;\n\tregval |= tsync_tx_ctl;\n\tew32(TSYNCTXCTL, regval);\n\tif ((er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_ENABLED) !=\n\t    (regval & E1000_TSYNCTXCTL_ENABLED)) {\n\t\te_err(\"Timesync Tx Control register not set as expected\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tregval = er32(TSYNCRXCTL);\n\tregval &= ~(E1000_TSYNCRXCTL_ENABLED | E1000_TSYNCRXCTL_TYPE_MASK);\n\tregval |= tsync_rx_ctl;\n\tew32(TSYNCRXCTL, regval);\n\tif ((er32(TSYNCRXCTL) & (E1000_TSYNCRXCTL_ENABLED |\n\t\t\t\t E1000_TSYNCRXCTL_TYPE_MASK)) !=\n\t    (regval & (E1000_TSYNCRXCTL_ENABLED |\n\t\t       E1000_TSYNCRXCTL_TYPE_MASK))) {\n\t\te_err(\"Timesync Rx Control register not set as expected\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (is_l2)\n\t\trxmtrl |= ETH_P_1588;\n\n\t \n\tew32(RXMTRL, rxmtrl);\n\n\t \n\tif (is_l4) {\n\t\trxudp = PTP_EV_PORT;\n\t\tcpu_to_be16s(&rxudp);\n\t}\n\tew32(RXUDP, rxudp);\n\n\te1e_flush();\n\n\t \n\ter32(RXSTMPH);\n\ter32(TXSTMPH);\n\n\treturn 0;\n}\n\n \nstatic void e1000_configure(struct e1000_adapter *adapter)\n{\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\n\te1000e_set_rx_mode(adapter->netdev);\n\n\te1000_restore_vlan(adapter);\n\te1000_init_manageability_pt(adapter);\n\n\te1000_configure_tx(adapter);\n\n\tif (adapter->netdev->features & NETIF_F_RXHASH)\n\t\te1000e_setup_rss_hash(adapter);\n\te1000_setup_rctl(adapter);\n\te1000_configure_rx(adapter);\n\tadapter->alloc_rx_buf(rx_ring, e1000_desc_unused(rx_ring), GFP_KERNEL);\n}\n\n \nvoid e1000e_power_up_phy(struct e1000_adapter *adapter)\n{\n\tif (adapter->hw.phy.ops.power_up)\n\t\tadapter->hw.phy.ops.power_up(&adapter->hw);\n\n\tadapter->hw.mac.ops.setup_link(&adapter->hw);\n}\n\n \nstatic void e1000_power_down_phy(struct e1000_adapter *adapter)\n{\n\tif (adapter->hw.phy.ops.power_down)\n\t\tadapter->hw.phy.ops.power_down(&adapter->hw);\n}\n\n \nstatic void e1000_flush_tx_ring(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tstruct e1000_tx_desc *tx_desc = NULL;\n\tu32 tdt, tctl, txd_lower = E1000_TXD_CMD_IFCS;\n\tu16 size = 512;\n\n\ttctl = er32(TCTL);\n\tew32(TCTL, tctl | E1000_TCTL_EN);\n\ttdt = er32(TDT(0));\n\tBUG_ON(tdt != tx_ring->next_to_use);\n\ttx_desc =  E1000_TX_DESC(*tx_ring, tx_ring->next_to_use);\n\ttx_desc->buffer_addr = cpu_to_le64(tx_ring->dma);\n\n\ttx_desc->lower.data = cpu_to_le32(txd_lower | size);\n\ttx_desc->upper.data = 0;\n\t \n\twmb();\n\ttx_ring->next_to_use++;\n\tif (tx_ring->next_to_use == tx_ring->count)\n\t\ttx_ring->next_to_use = 0;\n\tew32(TDT(0), tx_ring->next_to_use);\n\tusleep_range(200, 250);\n}\n\n \nstatic void e1000_flush_rx_ring(struct e1000_adapter *adapter)\n{\n\tu32 rctl, rxdctl;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\trctl = er32(RCTL);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(100, 150);\n\n\trxdctl = er32(RXDCTL(0));\n\t \n\trxdctl &= 0xffffc000;\n\n\t \n\trxdctl |= (0x1F | BIT(8) | E1000_RXDCTL_THRESH_UNIT_DESC);\n\n\tew32(RXDCTL(0), rxdctl);\n\t \n\tew32(RCTL, rctl | E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(100, 150);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n}\n\n \n\nstatic void e1000_flush_desc_rings(struct e1000_adapter *adapter)\n{\n\tu16 hang_state;\n\tu32 fext_nvm11, tdlen;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\tfext_nvm11 = er32(FEXTNVM11);\n\tfext_nvm11 |= E1000_FEXTNVM11_DISABLE_MULR_FIX;\n\tew32(FEXTNVM11, fext_nvm11);\n\t \n\ttdlen = er32(TDLEN(0));\n\tpci_read_config_word(adapter->pdev, PCICFG_DESC_RING_STATUS,\n\t\t\t     &hang_state);\n\tif (!(hang_state & FLUSH_DESC_REQUIRED) || !tdlen)\n\t\treturn;\n\te1000_flush_tx_ring(adapter);\n\t \n\tpci_read_config_word(adapter->pdev, PCICFG_DESC_RING_STATUS,\n\t\t\t     &hang_state);\n\tif (hang_state & FLUSH_DESC_REQUIRED)\n\t\te1000_flush_rx_ring(adapter);\n}\n\n \nstatic void e1000e_systim_reset(struct e1000_adapter *adapter)\n{\n\tstruct ptp_clock_info *info = &adapter->ptp_clock_info;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tu32 timinca;\n\ts32 ret_val;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\n\t\treturn;\n\n\tif (info->adjfine) {\n\t\t \n\t\tret_val = info->adjfine(info, adapter->ptp_delta);\n\t} else {\n\t\t \n\t\tret_val = e1000e_get_base_timinca(adapter, &timinca);\n\t\tif (!ret_val)\n\t\t\tew32(TIMINCA, timinca);\n\t}\n\n\tif (ret_val) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Failed to restore TIMINCA clock rate delta: %d\\n\",\n\t\t\t ret_val);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\ttimecounter_init(&adapter->tc, &adapter->cc,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\t \n\te1000e_config_hwtstamp(adapter, &adapter->hwtstamp_config);\n}\n\n \nvoid e1000e_reset(struct e1000_adapter *adapter)\n{\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\tstruct e1000_fc_info *fc = &adapter->hw.fc;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tx_space, min_tx_space, min_rx_space;\n\tu32 pba = adapter->pba;\n\tu16 hwm;\n\n\t \n\tew32(PBA, pba);\n\n\tif (adapter->max_frame_size > (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) {\n\t\t \n\t\tpba = er32(PBA);\n\t\t \n\t\ttx_space = pba >> 16;\n\t\t \n\t\tpba &= 0xffff;\n\t\t \n\t\tmin_tx_space = (adapter->max_frame_size +\n\t\t\t\tsizeof(struct e1000_tx_desc) - ETH_FCS_LEN) * 2;\n\t\tmin_tx_space = ALIGN(min_tx_space, 1024);\n\t\tmin_tx_space >>= 10;\n\t\t \n\t\tmin_rx_space = adapter->max_frame_size;\n\t\tmin_rx_space = ALIGN(min_rx_space, 1024);\n\t\tmin_rx_space >>= 10;\n\n\t\t \n\t\tif ((tx_space < min_tx_space) &&\n\t\t    ((min_tx_space - tx_space) < pba)) {\n\t\t\tpba -= min_tx_space - tx_space;\n\n\t\t\t \n\t\t\tif (pba < min_rx_space)\n\t\t\t\tpba = min_rx_space;\n\t\t}\n\n\t\tew32(PBA, pba);\n\t}\n\n\t \n\tif (adapter->flags & FLAG_DISABLE_FC_PAUSE_TIME)\n\t\tfc->pause_time = 0xFFFF;\n\telse\n\t\tfc->pause_time = E1000_FC_PAUSE_TIME;\n\tfc->send_xon = true;\n\tfc->current_mode = fc->requested_mode;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_ich9lan:\n\tcase e1000_ich10lan:\n\t\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\t\tpba = 14;\n\t\t\tew32(PBA, pba);\n\t\t\tfc->high_water = 0x2800;\n\t\t\tfc->low_water = fc->high_water - 8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\thwm = min(((pba << 10) * 9 / 10),\n\t\t\t  ((pba << 10) - adapter->max_frame_size));\n\n\t\tfc->high_water = hwm & E1000_FCRTH_RTH;\t \n\t\tfc->low_water = fc->high_water - 8;\n\t\tbreak;\n\tcase e1000_pchlan:\n\t\t \n\t\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\t\tfc->high_water = 0x3500;\n\t\t\tfc->low_water = 0x1500;\n\t\t} else {\n\t\t\tfc->high_water = 0x5000;\n\t\t\tfc->low_water = 0x3000;\n\t\t}\n\t\tfc->refresh_time = 0x1000;\n\t\tbreak;\n\tcase e1000_pch2lan:\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tfc->refresh_time = 0xFFFF;\n\t\tfc->pause_time = 0xFFFF;\n\n\t\tif (adapter->netdev->mtu <= ETH_DATA_LEN) {\n\t\t\tfc->high_water = 0x05C20;\n\t\t\tfc->low_water = 0x05048;\n\t\t\tbreak;\n\t\t}\n\n\t\tpba = 14;\n\t\tew32(PBA, pba);\n\t\tfc->high_water = ((pba << 10) * 9 / 10) & E1000_FCRTH_RTH;\n\t\tfc->low_water = ((pba << 10) * 8 / 10) & E1000_FCRTL_RTL;\n\t\tbreak;\n\t}\n\n\t \n\tadapter->tx_fifo_limit = min_t(u32, ((er32(PBA) >> 16) << 10) - 96,\n\t\t\t\t       24 << 10);\n\n\t \n\tif (adapter->itr_setting & 0x3) {\n\t\tif ((adapter->max_frame_size * 2) > (pba << 10)) {\n\t\t\tif (!(adapter->flags2 & FLAG2_DISABLE_AIM)) {\n\t\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\t \"Interrupt Throttle Rate off\\n\");\n\t\t\t\tadapter->flags2 |= FLAG2_DISABLE_AIM;\n\t\t\t\te1000e_write_itr(adapter, 0);\n\t\t\t}\n\t\t} else if (adapter->flags2 & FLAG2_DISABLE_AIM) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Interrupt Throttle Rate on\\n\");\n\t\t\tadapter->flags2 &= ~FLAG2_DISABLE_AIM;\n\t\t\tadapter->itr = 20000;\n\t\t\te1000e_write_itr(adapter, adapter->itr);\n\t\t}\n\t}\n\n\tif (hw->mac.type >= e1000_pch_spt)\n\t\te1000_flush_desc_rings(adapter);\n\t \n\tmac->ops.reset_hw(hw);\n\n\t \n\tif (adapter->flags & FLAG_HAS_AMT)\n\t\te1000e_get_hw_control(adapter);\n\n\tew32(WUC, 0);\n\n\tif (mac->ops.init_hw(hw))\n\t\te_err(\"Hardware Error\\n\");\n\n\te1000_update_mng_vlan(adapter);\n\n\t \n\tew32(VET, ETH_P_8021Q);\n\n\te1000e_reset_adaptive(hw);\n\n\t \n\te1000e_systim_reset(adapter);\n\n\t \n\tif (adapter->flags2 & FLAG2_HAS_EEE) {\n\t\ts32 ret_val;\n\t\tu16 adv_addr;\n\n\t\tswitch (hw->phy.type) {\n\t\tcase e1000_phy_82579:\n\t\t\tadv_addr = I82579_EEE_ADVERTISEMENT;\n\t\t\tbreak;\n\t\tcase e1000_phy_i217:\n\t\t\tadv_addr = I217_EEE_ADVERTISEMENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Invalid PHY type setting EEE advertisement\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"EEE advertisement - unable to acquire PHY\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\te1000_write_emi_reg_locked(hw, adv_addr,\n\t\t\t\t\t   hw->dev_spec.ich8lan.eee_disable ?\n\t\t\t\t\t   0 : adapter->eee_advert);\n\n\t\thw->phy.ops.release(hw);\n\t}\n\n\tif (!netif_running(adapter->netdev) &&\n\t    !test_bit(__E1000_TESTING, &adapter->state))\n\t\te1000_power_down_phy(adapter);\n\n\te1000_get_phy_info(hw);\n\n\tif ((adapter->flags & FLAG_HAS_SMART_POWER_DOWN) &&\n\t    !(adapter->flags & FLAG_SMART_POWER_DOWN)) {\n\t\tu16 phy_data = 0;\n\t\t \n\t\te1e_rphy(hw, IGP02E1000_PHY_POWER_MGMT, &phy_data);\n\t\tphy_data &= ~IGP02E1000_PM_SPD;\n\t\te1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, phy_data);\n\t}\n\tif (hw->mac.type >= e1000_pch_spt && adapter->int_mode == 0) {\n\t\tu32 reg;\n\n\t\t \n\t\treg = er32(FEXTNVM7);\n\t\treg |= E1000_FEXTNVM7_SIDE_CLK_UNGATE;\n\t\tew32(FEXTNVM7, reg);\n\t\t \n\t\treg = er32(FEXTNVM9);\n\t\treg |= E1000_FEXTNVM9_IOSFSB_CLKGATE_DIS |\n\t\t       E1000_FEXTNVM9_IOSFSB_CLKREQ_DIS;\n\t\tew32(FEXTNVM9, reg);\n\t}\n\n}\n\n \nstatic void e1000e_trigger_lsc(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (adapter->msix_entries)\n\t\tew32(ICS, E1000_ICS_LSC | E1000_ICS_OTHER);\n\telse\n\t\tew32(ICS, E1000_ICS_LSC);\n}\n\nvoid e1000e_up(struct e1000_adapter *adapter)\n{\n\t \n\te1000_configure(adapter);\n\n\tclear_bit(__E1000_DOWN, &adapter->state);\n\n\tif (adapter->msix_entries)\n\t\te1000_configure_msix(adapter);\n\te1000_irq_enable(adapter);\n\n\t \n\n\te1000e_trigger_lsc(adapter);\n}\n\nstatic void e1000e_flush_descriptors(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (!(adapter->flags2 & FLAG2_DMA_BURST))\n\t\treturn;\n\n\t \n\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\tew32(RDTR, adapter->rx_int_delay | E1000_RDTR_FPD);\n\n\t \n\te1e_flush();\n\n\t \n\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\tew32(RDTR, adapter->rx_int_delay | E1000_RDTR_FPD);\n\n\t \n\te1e_flush();\n}\n\nstatic void e1000e_update_stats(struct e1000_adapter *adapter);\n\n \nvoid e1000e_down(struct e1000_adapter *adapter, bool reset)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tctl, rctl;\n\n\t \n\tset_bit(__E1000_DOWN, &adapter->state);\n\n\tnetif_carrier_off(netdev);\n\n\t \n\trctl = er32(RCTL);\n\tif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t \n\n\tnetif_stop_queue(netdev);\n\n\t \n\ttctl = er32(TCTL);\n\ttctl &= ~E1000_TCTL_EN;\n\tew32(TCTL, tctl);\n\n\t \n\te1e_flush();\n\tusleep_range(10000, 11000);\n\n\te1000_irq_disable(adapter);\n\n\tnapi_synchronize(&adapter->napi);\n\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_info_timer);\n\n\tspin_lock(&adapter->stats64_lock);\n\te1000e_update_stats(adapter);\n\tspin_unlock(&adapter->stats64_lock);\n\n\te1000e_flush_descriptors(adapter);\n\n\tadapter->link_speed = 0;\n\tadapter->link_duplex = 0;\n\n\t \n\tif ((hw->mac.type >= e1000_pch2lan) &&\n\t    (adapter->netdev->mtu > ETH_DATA_LEN) &&\n\t    e1000_lv_jumbo_workaround_ich8lan(hw, false))\n\t\te_dbg(\"failed to disable jumbo frame workaround mode\\n\");\n\n\tif (!pci_channel_offline(adapter->pdev)) {\n\t\tif (reset)\n\t\t\te1000e_reset(adapter);\n\t\telse if (hw->mac.type >= e1000_pch_spt)\n\t\t\te1000_flush_desc_rings(adapter);\n\t}\n\te1000_clean_tx_ring(adapter->tx_ring);\n\te1000_clean_rx_ring(adapter->rx_ring);\n}\n\nvoid e1000e_reinit_locked(struct e1000_adapter *adapter)\n{\n\tmight_sleep();\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 1100);\n\te1000e_down(adapter, true);\n\te1000e_up(adapter);\n\tclear_bit(__E1000_RESETTING, &adapter->state);\n}\n\n \nstatic u64 e1000e_sanitize_systim(struct e1000_hw *hw, u64 systim,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tu64 time_delta, rem, temp;\n\tu64 systim_next;\n\tu32 incvalue;\n\tint i;\n\n\tincvalue = er32(TIMINCA) & E1000_TIMINCA_INCVALUE_MASK;\n\tfor (i = 0; i < E1000_MAX_82574_SYSTIM_REREADS; i++) {\n\t\t \n\t\tptp_read_system_prets(sts);\n\t\tsystim_next = (u64)er32(SYSTIML);\n\t\tptp_read_system_postts(sts);\n\t\tsystim_next |= (u64)er32(SYSTIMH) << 32;\n\n\t\ttime_delta = systim_next - systim;\n\t\ttemp = time_delta;\n\t\t \n\t\trem = incvalue ? do_div(temp, incvalue) : (time_delta != 0);\n\n\t\tsystim = systim_next;\n\n\t\tif ((time_delta < E1000_82574_SYSTIM_EPSILON) && (rem == 0))\n\t\t\tbreak;\n\t}\n\n\treturn systim;\n}\n\n \nu64 e1000e_read_systim(struct e1000_adapter *adapter,\n\t\t       struct ptp_system_timestamp *sts)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 systimel, systimel_2, systimeh;\n\tu64 systim;\n\t \n\tptp_read_system_prets(sts);\n\tsystimel = er32(SYSTIML);\n\tptp_read_system_postts(sts);\n\tsystimeh = er32(SYSTIMH);\n\t \n\tif (systimel >= (u32)0xffffffff - E1000_TIMINCA_INCVALUE_MASK) {\n\t\tptp_read_system_prets(sts);\n\t\tsystimel_2 = er32(SYSTIML);\n\t\tptp_read_system_postts(sts);\n\t\tif (systimel > systimel_2) {\n\t\t\t \n\t\t\tsystimeh = er32(SYSTIMH);\n\t\t\tsystimel = systimel_2;\n\t\t}\n\t}\n\tsystim = (u64)systimel;\n\tsystim |= (u64)systimeh << 32;\n\n\tif (adapter->flags2 & FLAG2_CHECK_SYSTIM_OVERFLOW)\n\t\tsystim = e1000e_sanitize_systim(hw, systim, sts);\n\n\treturn systim;\n}\n\n \nstatic u64 e1000e_cyclecounter_read(const struct cyclecounter *cc)\n{\n\tstruct e1000_adapter *adapter = container_of(cc, struct e1000_adapter,\n\t\t\t\t\t\t     cc);\n\n\treturn e1000e_read_systim(adapter, NULL);\n}\n\n \nstatic int e1000_sw_init(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tadapter->rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\tadapter->rx_ps_bsize0 = 128;\n\tadapter->max_frame_size = netdev->mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\tadapter->min_frame_size = ETH_ZLEN + ETH_FCS_LEN;\n\tadapter->tx_ring_count = E1000_DEFAULT_TXD;\n\tadapter->rx_ring_count = E1000_DEFAULT_RXD;\n\n\tspin_lock_init(&adapter->stats64_lock);\n\n\te1000e_set_interrupt_capability(adapter);\n\n\tif (e1000_alloc_queues(adapter))\n\t\treturn -ENOMEM;\n\n\t \n\tif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\n\t\tadapter->cc.read = e1000e_cyclecounter_read;\n\t\tadapter->cc.mask = CYCLECOUNTER_MASK(64);\n\t\tadapter->cc.mult = 1;\n\t\t \n\n\t\tspin_lock_init(&adapter->systim_lock);\n\t\tINIT_WORK(&adapter->tx_hwtstamp_work, e1000e_tx_hwtstamp_work);\n\t}\n\n\t \n\te1000_irq_disable(adapter);\n\n\tset_bit(__E1000_DOWN, &adapter->state);\n\treturn 0;\n}\n\n \nstatic irqreturn_t e1000_intr_msi_test(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = er32(ICR);\n\n\te_dbg(\"icr is %08X\\n\", icr);\n\tif (icr & E1000_ICR_RXSEQ) {\n\t\tadapter->flags &= ~FLAG_MSI_TEST_FAILED;\n\t\t \n\t\twmb();\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int e1000_test_msi_interrupt(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err;\n\n\t \n\t \n\ter32(ICR);\n\n\t \n\te1000_free_irq(adapter);\n\te1000e_reset_interrupt_capability(adapter);\n\n\t \n\tadapter->flags |= FLAG_MSI_TEST_FAILED;\n\n\terr = pci_enable_msi(adapter->pdev);\n\tif (err)\n\t\tgoto msi_test_failed;\n\n\terr = request_irq(adapter->pdev->irq, e1000_intr_msi_test, 0,\n\t\t\t  netdev->name, netdev);\n\tif (err) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tgoto msi_test_failed;\n\t}\n\n\t \n\twmb();\n\n\te1000_irq_enable(adapter);\n\n\t \n\tew32(ICS, E1000_ICS_RXSEQ);\n\te1e_flush();\n\tmsleep(100);\n\n\te1000_irq_disable(adapter);\n\n\trmb();\t\t\t \n\n\tif (adapter->flags & FLAG_MSI_TEST_FAILED) {\n\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t\te_info(\"MSI interrupt test failed, using legacy interrupt.\\n\");\n\t} else {\n\t\te_dbg(\"MSI interrupt test succeeded!\\n\");\n\t}\n\n\tfree_irq(adapter->pdev->irq, netdev);\n\tpci_disable_msi(adapter->pdev);\n\nmsi_test_failed:\n\te1000e_set_interrupt_capability(adapter);\n\treturn e1000_request_irq(adapter);\n}\n\n \nstatic int e1000_test_msi(struct e1000_adapter *adapter)\n{\n\tint err;\n\tu16 pci_cmd;\n\n\tif (!(adapter->flags & FLAG_MSI_ENABLED))\n\t\treturn 0;\n\n\t \n\tpci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);\n\tif (pci_cmd & PCI_COMMAND_SERR)\n\t\tpci_write_config_word(adapter->pdev, PCI_COMMAND,\n\t\t\t\t      pci_cmd & ~PCI_COMMAND_SERR);\n\n\terr = e1000_test_msi_interrupt(adapter);\n\n\t \n\tif (pci_cmd & PCI_COMMAND_SERR) {\n\t\tpci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);\n\t\tpci_cmd |= PCI_COMMAND_SERR;\n\t\tpci_write_config_word(adapter->pdev, PCI_COMMAND, pci_cmd);\n\t}\n\n\treturn err;\n}\n\n \nint e1000e_open(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err;\n\n\t \n\tif (test_bit(__E1000_TESTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\n\t \n\terr = e1000e_setup_tx_resources(adapter->tx_ring);\n\tif (err)\n\t\tgoto err_setup_tx;\n\n\t \n\terr = e1000e_setup_rx_resources(adapter->rx_ring);\n\tif (err)\n\t\tgoto err_setup_rx;\n\n\t \n\tif (adapter->flags & FLAG_HAS_AMT) {\n\t\te1000e_get_hw_control(adapter);\n\t\te1000e_reset(adapter);\n\t}\n\n\te1000e_power_up_phy(adapter);\n\n\tadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\n\tif ((adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN))\n\t\te1000_update_mng_vlan(adapter);\n\n\t \n\tcpu_latency_qos_add_request(&adapter->pm_qos_req, PM_QOS_DEFAULT_VALUE);\n\n\t \n\te1000_configure(adapter);\n\n\terr = e1000_request_irq(adapter);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\t \n\tif (adapter->int_mode != E1000E_INT_MODE_LEGACY) {\n\t\terr = e1000_test_msi(adapter);\n\t\tif (err) {\n\t\t\te_err(\"Interrupt allocation failed\\n\");\n\t\t\tgoto err_req_irq;\n\t\t}\n\t}\n\n\t \n\tclear_bit(__E1000_DOWN, &adapter->state);\n\n\tnapi_enable(&adapter->napi);\n\n\te1000_irq_enable(adapter);\n\n\tadapter->tx_hang_recheck = false;\n\n\thw->mac.get_link_status = true;\n\tpm_runtime_put(&pdev->dev);\n\n\te1000e_trigger_lsc(adapter);\n\n\treturn 0;\n\nerr_req_irq:\n\tcpu_latency_qos_remove_request(&adapter->pm_qos_req);\n\te1000e_release_hw_control(adapter);\n\te1000_power_down_phy(adapter);\n\te1000e_free_rx_resources(adapter->rx_ring);\nerr_setup_rx:\n\te1000e_free_tx_resources(adapter->tx_ring);\nerr_setup_tx:\n\te1000e_reset(adapter);\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn err;\n}\n\n \nint e1000e_close(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint count = E1000_CHECK_RESET_COUNT;\n\n\twhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\n\t\tusleep_range(10000, 11000);\n\n\tWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tif (netif_device_present(netdev)) {\n\t\te1000e_down(adapter, true);\n\t\te1000_free_irq(adapter);\n\n\t\t \n\t\tnetdev_info(netdev, \"NIC Link is Down\\n\");\n\t}\n\n\tnapi_disable(&adapter->napi);\n\n\te1000e_free_tx_resources(adapter->tx_ring);\n\te1000e_free_rx_resources(adapter->rx_ring);\n\n\t \n\tif (adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN)\n\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\n\t\t\t\t       adapter->mng_vlan_id);\n\n\t \n\tif ((adapter->flags & FLAG_HAS_AMT) &&\n\t    !test_bit(__E1000_TESTING, &adapter->state))\n\t\te1000e_release_hw_control(adapter);\n\n\tcpu_latency_qos_remove_request(&adapter->pm_qos_req);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn 0;\n}\n\n \nstatic int e1000_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tmemcpy(adapter->hw.mac.addr, addr->sa_data, netdev->addr_len);\n\n\thw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr, 0);\n\n\tif (adapter->flags & FLAG_RESET_OVERWRITES_LAA) {\n\t\t \n\t\te1000e_set_laa_state_82571(&adapter->hw, 1);\n\n\t\t \n\t\thw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr,\n\t\t\t\t    adapter->hw.mac.rar_entry_count - 1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void e1000e_update_phy_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     update_phy_task);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\te1000_get_phy_info(hw);\n\n\t \n\tif (hw->phy.type >= e1000_phy_82579)\n\t\te1000_set_eee_pchlan(hw);\n}\n\n \nstatic void e1000_update_phy_info(struct timer_list *t)\n{\n\tstruct e1000_adapter *adapter = from_timer(adapter, t, phy_info_timer);\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tschedule_work(&adapter->update_phy_task);\n}\n\n \nstatic void e1000e_update_phy_stats(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn;\n\n\t \n\thw->phy.addr = 1;\n\tret_val = e1000e_read_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t   &phy_data);\n\tif (ret_val)\n\t\tgoto release;\n\tif (phy_data != (HV_STATS_PAGE << IGP_PAGE_SHIFT)) {\n\t\tret_val = hw->phy.ops.set_page(hw,\n\t\t\t\t\t       HV_STATS_PAGE << IGP_PAGE_SHIFT);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\t \n\thw->phy.ops.read_reg_page(hw, HV_SCC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_SCC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.scc += phy_data;\n\n\t \n\thw->phy.ops.read_reg_page(hw, HV_ECOL_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_ECOL_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.ecol += phy_data;\n\n\t \n\thw->phy.ops.read_reg_page(hw, HV_MCC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_MCC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.mcc += phy_data;\n\n\t \n\thw->phy.ops.read_reg_page(hw, HV_LATECOL_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_LATECOL_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.latecol += phy_data;\n\n\t \n\thw->phy.ops.read_reg_page(hw, HV_COLC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_COLC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\thw->mac.collision_delta = phy_data;\n\n\t \n\thw->phy.ops.read_reg_page(hw, HV_DC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_DC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.dc += phy_data;\n\n\t \n\thw->phy.ops.read_reg_page(hw, HV_TNCRS_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_TNCRS_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.tncrs += phy_data;\n\nrelease:\n\thw->phy.ops.release(hw);\n}\n\n \nstatic void e1000e_update_stats(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\t \n\tif (adapter->link_speed == 0)\n\t\treturn;\n\tif (pci_channel_offline(pdev))\n\t\treturn;\n\n\tadapter->stats.crcerrs += er32(CRCERRS);\n\tadapter->stats.gprc += er32(GPRC);\n\tadapter->stats.gorc += er32(GORCL);\n\ter32(GORCH);\t\t \n\tadapter->stats.bprc += er32(BPRC);\n\tadapter->stats.mprc += er32(MPRC);\n\tadapter->stats.roc += er32(ROC);\n\n\tadapter->stats.mpc += er32(MPC);\n\n\t \n\tif (adapter->link_duplex == HALF_DUPLEX) {\n\t\tif (adapter->flags2 & FLAG2_HAS_PHY_STATS) {\n\t\t\te1000e_update_phy_stats(adapter);\n\t\t} else {\n\t\t\tadapter->stats.scc += er32(SCC);\n\t\t\tadapter->stats.ecol += er32(ECOL);\n\t\t\tadapter->stats.mcc += er32(MCC);\n\t\t\tadapter->stats.latecol += er32(LATECOL);\n\t\t\tadapter->stats.dc += er32(DC);\n\n\t\t\thw->mac.collision_delta = er32(COLC);\n\n\t\t\tif ((hw->mac.type != e1000_82574) &&\n\t\t\t    (hw->mac.type != e1000_82583))\n\t\t\t\tadapter->stats.tncrs += er32(TNCRS);\n\t\t}\n\t\tadapter->stats.colc += hw->mac.collision_delta;\n\t}\n\n\tadapter->stats.xonrxc += er32(XONRXC);\n\tadapter->stats.xontxc += er32(XONTXC);\n\tadapter->stats.xoffrxc += er32(XOFFRXC);\n\tadapter->stats.xofftxc += er32(XOFFTXC);\n\tadapter->stats.gptc += er32(GPTC);\n\tadapter->stats.gotc += er32(GOTCL);\n\ter32(GOTCH);\t\t \n\tadapter->stats.rnbc += er32(RNBC);\n\tadapter->stats.ruc += er32(RUC);\n\n\tadapter->stats.mptc += er32(MPTC);\n\tadapter->stats.bptc += er32(BPTC);\n\n\t \n\n\thw->mac.tx_packet_delta = er32(TPT);\n\tadapter->stats.tpt += hw->mac.tx_packet_delta;\n\n\tadapter->stats.algnerrc += er32(ALGNERRC);\n\tadapter->stats.rxerrc += er32(RXERRC);\n\tadapter->stats.cexterr += er32(CEXTERR);\n\tadapter->stats.tsctc += er32(TSCTC);\n\tadapter->stats.tsctfc += er32(TSCTFC);\n\n\t \n\tnetdev->stats.multicast = adapter->stats.mprc;\n\tnetdev->stats.collisions = adapter->stats.colc;\n\n\t \n\n\t \n\tnetdev->stats.rx_errors = adapter->stats.rxerrc +\n\t    adapter->stats.crcerrs + adapter->stats.algnerrc +\n\t    adapter->stats.ruc + adapter->stats.roc + adapter->stats.cexterr;\n\tnetdev->stats.rx_length_errors = adapter->stats.ruc +\n\t    adapter->stats.roc;\n\tnetdev->stats.rx_crc_errors = adapter->stats.crcerrs;\n\tnetdev->stats.rx_frame_errors = adapter->stats.algnerrc;\n\tnetdev->stats.rx_missed_errors = adapter->stats.mpc;\n\n\t \n\tnetdev->stats.tx_errors = adapter->stats.ecol + adapter->stats.latecol;\n\tnetdev->stats.tx_aborted_errors = adapter->stats.ecol;\n\tnetdev->stats.tx_window_errors = adapter->stats.latecol;\n\tnetdev->stats.tx_carrier_errors = adapter->stats.tncrs;\n\n\t \n\n\t \n\tadapter->stats.mgptc += er32(MGTPTC);\n\tadapter->stats.mgprc += er32(MGTPRC);\n\tadapter->stats.mgpdc += er32(MGTPDC);\n\n\t \n\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\tu32 pbeccsts = er32(PBECCSTS);\n\n\t\tadapter->corr_errors +=\n\t\t    pbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\n\t\tadapter->uncorr_errors +=\n\t\t    (pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\n\t\t    E1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\n\t}\n}\n\n \nstatic void e1000_phy_read_status(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_phy_regs *phy = &adapter->phy_regs;\n\n\tif (!pm_runtime_suspended((&adapter->pdev->dev)->parent) &&\n\t    (er32(STATUS) & E1000_STATUS_LU) &&\n\t    (adapter->hw.phy.media_type == e1000_media_type_copper)) {\n\t\tint ret_val;\n\n\t\tret_val = e1e_rphy(hw, MII_BMCR, &phy->bmcr);\n\t\tret_val |= e1e_rphy(hw, MII_BMSR, &phy->bmsr);\n\t\tret_val |= e1e_rphy(hw, MII_ADVERTISE, &phy->advertise);\n\t\tret_val |= e1e_rphy(hw, MII_LPA, &phy->lpa);\n\t\tret_val |= e1e_rphy(hw, MII_EXPANSION, &phy->expansion);\n\t\tret_val |= e1e_rphy(hw, MII_CTRL1000, &phy->ctrl1000);\n\t\tret_val |= e1e_rphy(hw, MII_STAT1000, &phy->stat1000);\n\t\tret_val |= e1e_rphy(hw, MII_ESTATUS, &phy->estatus);\n\t\tif (ret_val)\n\t\t\te_warn(\"Error reading PHY register\\n\");\n\t} else {\n\t\t \n\t\tphy->bmcr = (BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_FULLDPLX);\n\t\tphy->bmsr = (BMSR_100FULL | BMSR_100HALF | BMSR_10FULL |\n\t\t\t     BMSR_10HALF | BMSR_ESTATEN | BMSR_ANEGCAPABLE |\n\t\t\t     BMSR_ERCAP);\n\t\tphy->advertise = (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP |\n\t\t\t\t  ADVERTISE_ALL | ADVERTISE_CSMA);\n\t\tphy->lpa = 0;\n\t\tphy->expansion = EXPANSION_ENABLENPAGE;\n\t\tphy->ctrl1000 = ADVERTISE_1000FULL;\n\t\tphy->stat1000 = 0;\n\t\tphy->estatus = (ESTATUS_1000_TFULL | ESTATUS_1000_THALF);\n\t}\n}\n\nstatic void e1000_print_link_info(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl = er32(CTRL);\n\n\t \n\tnetdev_info(adapter->netdev,\n\t\t    \"NIC Link is Up %d Mbps %s Duplex, Flow Control: %s\\n\",\n\t\t    adapter->link_speed,\n\t\t    adapter->link_duplex == FULL_DUPLEX ? \"Full\" : \"Half\",\n\t\t    (ctrl & E1000_CTRL_TFCE) && (ctrl & E1000_CTRL_RFCE) ? \"Rx/Tx\" :\n\t\t    (ctrl & E1000_CTRL_RFCE) ? \"Rx\" :\n\t\t    (ctrl & E1000_CTRL_TFCE) ? \"Tx\" : \"None\");\n}\n\nstatic bool e1000e_has_link(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool link_active = false;\n\ts32 ret_val = 0;\n\n\t \n\tswitch (hw->phy.media_type) {\n\tcase e1000_media_type_copper:\n\t\tif (hw->mac.get_link_status) {\n\t\t\tret_val = hw->mac.ops.check_for_link(hw);\n\t\t\tlink_active = !hw->mac.get_link_status;\n\t\t} else {\n\t\t\tlink_active = true;\n\t\t}\n\t\tbreak;\n\tcase e1000_media_type_fiber:\n\t\tret_val = hw->mac.ops.check_for_link(hw);\n\t\tlink_active = !!(er32(STATUS) & E1000_STATUS_LU);\n\t\tbreak;\n\tcase e1000_media_type_internal_serdes:\n\t\tret_val = hw->mac.ops.check_for_link(hw);\n\t\tlink_active = hw->mac.serdes_has_link;\n\t\tbreak;\n\tdefault:\n\tcase e1000_media_type_unknown:\n\t\tbreak;\n\t}\n\n\tif ((ret_val == -E1000_ERR_PHY) && (hw->phy.type == e1000_phy_igp_3) &&\n\t    (er32(CTRL) & E1000_PHY_CTRL_GBE_DISABLE)) {\n\t\t \n\t\te_info(\"Gigabit has been disabled, downgrading speed\\n\");\n\t}\n\n\treturn link_active;\n}\n\nstatic void e1000e_enable_receives(struct e1000_adapter *adapter)\n{\n\t \n\tif ((adapter->flags & FLAG_RX_NEEDS_RESTART) &&\n\t    (adapter->flags & FLAG_RESTART_NOW)) {\n\t\tstruct e1000_hw *hw = &adapter->hw;\n\t\tu32 rctl = er32(RCTL);\n\n\t\tew32(RCTL, rctl | E1000_RCTL_EN);\n\t\tadapter->flags &= ~FLAG_RESTART_NOW;\n\t}\n}\n\nstatic void e1000e_check_82574_phy_workaround(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\tif (e1000_check_phy_82574(hw))\n\t\tadapter->phy_hang_count++;\n\telse\n\t\tadapter->phy_hang_count = 0;\n\n\tif (adapter->phy_hang_count > 1) {\n\t\tadapter->phy_hang_count = 0;\n\t\te_dbg(\"PHY appears hung - resetting\\n\");\n\t\tschedule_work(&adapter->reset_task);\n\t}\n}\n\n \nstatic void e1000_watchdog(struct timer_list *t)\n{\n\tstruct e1000_adapter *adapter = from_timer(adapter, t, watchdog_timer);\n\n\t \n\tschedule_work(&adapter->watchdog_task);\n\n\t \n}\n\nstatic void e1000_watchdog_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     watchdog_task);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\tstruct e1000_phy_info *phy = &adapter->hw.phy;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tu32 dmoff_exit_timeout = 100, tries = 0;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 link, tctl, pcim_state;\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tlink = e1000e_has_link(adapter);\n\tif ((netif_carrier_ok(netdev)) && link) {\n\t\t \n\t\tpm_runtime_resume(netdev->dev.parent);\n\n\t\te1000e_enable_receives(adapter);\n\t\tgoto link_up;\n\t}\n\n\tif ((e1000e_enable_tx_pkt_filtering(hw)) &&\n\t    (adapter->mng_vlan_id != adapter->hw.mng_cookie.vlan_id))\n\t\te1000_update_mng_vlan(adapter);\n\n\tif (link) {\n\t\tif (!netif_carrier_ok(netdev)) {\n\t\t\tbool txb2b = true;\n\n\t\t\t \n\t\t\tpm_runtime_resume(netdev->dev.parent);\n\n\t\t\t \n\t\t\tif (er32(FWSM) & E1000_ICH_FWSM_FW_VALID) {\n\t\t\t\tpcim_state = er32(STATUS);\n\t\t\t\twhile (pcim_state & E1000_STATUS_PCIM_STATE) {\n\t\t\t\t\tif (tries++ == dmoff_exit_timeout) {\n\t\t\t\t\t\te_dbg(\"Error in exiting dmoff\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tusleep_range(10000, 20000);\n\t\t\t\t\tpcim_state = er32(STATUS);\n\n\t\t\t\t\t \n\t\t\t\t\tif (!(pcim_state & E1000_STATUS_PCIM_STATE))\n\t\t\t\t\t\te1000_phy_hw_reset(&adapter->hw);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\te1000_phy_read_status(adapter);\n\t\t\tmac->ops.get_link_up_info(&adapter->hw,\n\t\t\t\t\t\t  &adapter->link_speed,\n\t\t\t\t\t\t  &adapter->link_duplex);\n\t\t\te1000_print_link_info(adapter);\n\n\t\t\t \n\t\t\te1000e_check_downshift(hw);\n\t\t\tif (phy->speed_downgraded)\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t    \"Link Speed was downgraded by SmartSpeed\\n\");\n\n\t\t\t \n\t\t\tif ((hw->phy.type == e1000_phy_igp_3 ||\n\t\t\t     hw->phy.type == e1000_phy_bm) &&\n\t\t\t    hw->mac.autoneg &&\n\t\t\t    (adapter->link_speed == SPEED_10 ||\n\t\t\t     adapter->link_speed == SPEED_100) &&\n\t\t\t    (adapter->link_duplex == HALF_DUPLEX)) {\n\t\t\t\tu16 autoneg_exp;\n\n\t\t\t\te1e_rphy(hw, MII_EXPANSION, &autoneg_exp);\n\n\t\t\t\tif (!(autoneg_exp & EXPANSION_NWAY))\n\t\t\t\t\te_info(\"Autonegotiated half duplex but link partner cannot autoneg.  Try forcing full duplex if link gets many collisions.\\n\");\n\t\t\t}\n\n\t\t\t \n\t\t\tadapter->tx_timeout_factor = 1;\n\t\t\tswitch (adapter->link_speed) {\n\t\t\tcase SPEED_10:\n\t\t\t\ttxb2b = false;\n\t\t\t\tadapter->tx_timeout_factor = 16;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_100:\n\t\t\t\ttxb2b = false;\n\t\t\t\tadapter->tx_timeout_factor = 10;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((adapter->flags & FLAG_TARC_SPEED_MODE_BIT) &&\n\t\t\t    !txb2b) {\n\t\t\t\tu32 tarc0;\n\n\t\t\t\ttarc0 = er32(TARC(0));\n\t\t\t\ttarc0 &= ~SPEED_MODE_BIT;\n\t\t\t\tew32(TARC(0), tarc0);\n\t\t\t}\n\n\t\t\t \n\t\t\ttctl = er32(TCTL);\n\t\t\ttctl |= E1000_TCTL_EN;\n\t\t\tew32(TCTL, tctl);\n\n\t\t\t \n\t\t\tif (phy->ops.cfg_on_link_up)\n\t\t\t\tphy->ops.cfg_on_link_up(hw);\n\n\t\t\tnetif_wake_queue(netdev);\n\t\t\tnetif_carrier_on(netdev);\n\n\t\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\t\tmod_timer(&adapter->phy_info_timer,\n\t\t\t\t\t  round_jiffies(jiffies + 2 * HZ));\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tadapter->link_speed = 0;\n\t\t\tadapter->link_duplex = 0;\n\t\t\t \n\t\t\tnetdev_info(netdev, \"NIC Link is Down\\n\");\n\t\t\tnetif_carrier_off(netdev);\n\t\t\tnetif_stop_queue(netdev);\n\t\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\t\tmod_timer(&adapter->phy_info_timer,\n\t\t\t\t\t  round_jiffies(jiffies + 2 * HZ));\n\n\t\t\t \n\t\t\tif (adapter->flags & FLAG_RX_NEEDS_RESTART)\n\t\t\t\tadapter->flags |= FLAG_RESTART_NOW;\n\t\t\telse\n\t\t\t\tpm_schedule_suspend(netdev->dev.parent,\n\t\t\t\t\t\t    LINK_TIMEOUT);\n\t\t}\n\t}\n\nlink_up:\n\tspin_lock(&adapter->stats64_lock);\n\te1000e_update_stats(adapter);\n\n\tmac->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;\n\tadapter->tpt_old = adapter->stats.tpt;\n\tmac->collision_delta = adapter->stats.colc - adapter->colc_old;\n\tadapter->colc_old = adapter->stats.colc;\n\n\tadapter->gorc = adapter->stats.gorc - adapter->gorc_old;\n\tadapter->gorc_old = adapter->stats.gorc;\n\tadapter->gotc = adapter->stats.gotc - adapter->gotc_old;\n\tadapter->gotc_old = adapter->stats.gotc;\n\tspin_unlock(&adapter->stats64_lock);\n\n\t \n\tif (!netif_carrier_ok(netdev) &&\n\t    (e1000_desc_unused(tx_ring) + 1 < tx_ring->count))\n\t\tadapter->flags |= FLAG_RESTART_NOW;\n\n\t \n\tif (adapter->flags & FLAG_RESTART_NOW) {\n\t\tschedule_work(&adapter->reset_task);\n\t\t \n\t\treturn;\n\t}\n\n\te1000e_update_adaptive(&adapter->hw);\n\n\t \n\tif (adapter->itr_setting == 4) {\n\t\t \n\t\tu32 goc = (adapter->gotc + adapter->gorc) / 10000;\n\t\tu32 dif = (adapter->gotc > adapter->gorc ?\n\t\t\t   adapter->gotc - adapter->gorc :\n\t\t\t   adapter->gorc - adapter->gotc) / 10000;\n\t\tu32 itr = goc > 0 ? (dif * 6000 / goc + 2000) : 8000;\n\n\t\te1000e_write_itr(adapter, itr);\n\t}\n\n\t \n\tif (adapter->msix_entries)\n\t\tew32(ICS, adapter->rx_ring->ims_val);\n\telse\n\t\tew32(ICS, E1000_ICS_RXDMT0);\n\n\t \n\te1000e_flush_descriptors(adapter);\n\n\t \n\tadapter->detect_tx_hung = true;\n\n\t \n\tif (e1000e_get_laa_state_82571(hw))\n\t\thw->mac.ops.rar_set(hw, adapter->hw.mac.addr, 0);\n\n\tif (adapter->flags2 & FLAG2_CHECK_PHY_HANG)\n\t\te1000e_check_82574_phy_workaround(adapter);\n\n\t \n\tif (adapter->hwtstamp_config.rx_filter != HWTSTAMP_FILTER_NONE) {\n\t\tif ((adapter->flags2 & FLAG2_CHECK_RX_HWTSTAMP) &&\n\t\t    (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID)) {\n\t\t\ter32(RXSTMPH);\n\t\t\tadapter->rx_hwtstamp_cleared++;\n\t\t} else {\n\t\t\tadapter->flags2 |= FLAG2_CHECK_RX_HWTSTAMP;\n\t\t}\n\t}\n\n\t \n\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\tmod_timer(&adapter->watchdog_timer,\n\t\t\t  round_jiffies(jiffies + 2 * HZ));\n}\n\n#define E1000_TX_FLAGS_CSUM\t\t0x00000001\n#define E1000_TX_FLAGS_VLAN\t\t0x00000002\n#define E1000_TX_FLAGS_TSO\t\t0x00000004\n#define E1000_TX_FLAGS_IPV4\t\t0x00000008\n#define E1000_TX_FLAGS_NO_FCS\t\t0x00000010\n#define E1000_TX_FLAGS_HWTSTAMP\t\t0x00000020\n#define E1000_TX_FLAGS_VLAN_MASK\t0xffff0000\n#define E1000_TX_FLAGS_VLAN_SHIFT\t16\n\nstatic int e1000_tso(struct e1000_ring *tx_ring, struct sk_buff *skb,\n\t\t     __be16 protocol)\n{\n\tstruct e1000_context_desc *context_desc;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int i;\n\tu32 cmd_length = 0;\n\tu16 ipcse = 0, mss;\n\tu8 ipcss, ipcso, tucss, tucso, hdr_len;\n\tint err;\n\n\tif (!skb_is_gso(skb))\n\t\treturn 0;\n\n\terr = skb_cow_head(skb, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\thdr_len = skb_tcp_all_headers(skb);\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (protocol == htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\tiph->tot_len = 0;\n\t\tiph->check = 0;\n\t\ttcp_hdr(skb)->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\n\t\t\t\t\t\t\t 0, IPPROTO_TCP, 0);\n\t\tcmd_length = E1000_TXD_CMD_IP;\n\t\tipcse = skb_transport_offset(skb) - 1;\n\t} else if (skb_is_gso_v6(skb)) {\n\t\ttcp_v6_gso_csum_prep(skb);\n\t\tipcse = 0;\n\t}\n\tipcss = skb_network_offset(skb);\n\tipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;\n\ttucss = skb_transport_offset(skb);\n\ttucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;\n\n\tcmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |\n\t\t       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));\n\n\ti = tx_ring->next_to_use;\n\tcontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\n\tbuffer_info = &tx_ring->buffer_info[i];\n\n\tcontext_desc->lower_setup.ip_fields.ipcss = ipcss;\n\tcontext_desc->lower_setup.ip_fields.ipcso = ipcso;\n\tcontext_desc->lower_setup.ip_fields.ipcse = cpu_to_le16(ipcse);\n\tcontext_desc->upper_setup.tcp_fields.tucss = tucss;\n\tcontext_desc->upper_setup.tcp_fields.tucso = tucso;\n\tcontext_desc->upper_setup.tcp_fields.tucse = 0;\n\tcontext_desc->tcp_seg_setup.fields.mss = cpu_to_le16(mss);\n\tcontext_desc->tcp_seg_setup.fields.hdr_len = hdr_len;\n\tcontext_desc->cmd_and_length = cpu_to_le32(cmd_length);\n\n\tbuffer_info->time_stamp = jiffies;\n\tbuffer_info->next_to_watch = i;\n\n\ti++;\n\tif (i == tx_ring->count)\n\t\ti = 0;\n\ttx_ring->next_to_use = i;\n\n\treturn 1;\n}\n\nstatic bool e1000_tx_csum(struct e1000_ring *tx_ring, struct sk_buff *skb,\n\t\t\t  __be16 protocol)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_context_desc *context_desc;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int i;\n\tu8 css;\n\tu32 cmd_len = E1000_TXD_CMD_DEXT;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn false;\n\n\tswitch (protocol) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tif (ip_hdr(skb)->protocol == IPPROTO_TCP)\n\t\t\tcmd_len |= E1000_TXD_CMD_TCP;\n\t\tbreak;\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\t \n\t\tif (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)\n\t\t\tcmd_len |= E1000_TXD_CMD_TCP;\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely(net_ratelimit()))\n\t\t\te_warn(\"checksum_partial proto=%x!\\n\",\n\t\t\t       be16_to_cpu(protocol));\n\t\tbreak;\n\t}\n\n\tcss = skb_checksum_start_offset(skb);\n\n\ti = tx_ring->next_to_use;\n\tbuffer_info = &tx_ring->buffer_info[i];\n\tcontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\n\n\tcontext_desc->lower_setup.ip_config = 0;\n\tcontext_desc->upper_setup.tcp_fields.tucss = css;\n\tcontext_desc->upper_setup.tcp_fields.tucso = css + skb->csum_offset;\n\tcontext_desc->upper_setup.tcp_fields.tucse = 0;\n\tcontext_desc->tcp_seg_setup.data = 0;\n\tcontext_desc->cmd_and_length = cpu_to_le32(cmd_len);\n\n\tbuffer_info->time_stamp = jiffies;\n\tbuffer_info->next_to_watch = i;\n\n\ti++;\n\tif (i == tx_ring->count)\n\t\ti = 0;\n\ttx_ring->next_to_use = i;\n\n\treturn true;\n}\n\nstatic int e1000_tx_map(struct e1000_ring *tx_ring, struct sk_buff *skb,\n\t\t\tunsigned int first, unsigned int max_per_txd,\n\t\t\tunsigned int nr_frags)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int len = skb_headlen(skb);\n\tunsigned int offset = 0, size, count = 0, i;\n\tunsigned int f, bytecount, segs;\n\n\ti = tx_ring->next_to_use;\n\n\twhile (len) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tsize = min(len, max_per_txd);\n\n\t\tbuffer_info->length = size;\n\t\tbuffer_info->time_stamp = jiffies;\n\t\tbuffer_info->next_to_watch = i;\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev,\n\t\t\t\t\t\t  skb->data + offset,\n\t\t\t\t\t\t  size, DMA_TO_DEVICE);\n\t\tbuffer_info->mapped_as_page = false;\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma))\n\t\t\tgoto dma_error;\n\n\t\tlen -= size;\n\t\toffset += size;\n\t\tcount++;\n\n\t\tif (len) {\n\t\t\ti++;\n\t\t\tif (i == tx_ring->count)\n\t\t\t\ti = 0;\n\t\t}\n\t}\n\n\tfor (f = 0; f < nr_frags; f++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[f];\n\n\t\tlen = skb_frag_size(frag);\n\t\toffset = 0;\n\n\t\twhile (len) {\n\t\t\ti++;\n\t\t\tif (i == tx_ring->count)\n\t\t\t\ti = 0;\n\n\t\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\t\tsize = min(len, max_per_txd);\n\n\t\t\tbuffer_info->length = size;\n\t\t\tbuffer_info->time_stamp = jiffies;\n\t\t\tbuffer_info->next_to_watch = i;\n\t\t\tbuffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,\n\t\t\t\t\t\t\t    offset, size,\n\t\t\t\t\t\t\t    DMA_TO_DEVICE);\n\t\t\tbuffer_info->mapped_as_page = true;\n\t\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma))\n\t\t\t\tgoto dma_error;\n\n\t\t\tlen -= size;\n\t\t\toffset += size;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tsegs = skb_shinfo(skb)->gso_segs ? : 1;\n\t \n\tbytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;\n\n\ttx_ring->buffer_info[i].skb = skb;\n\ttx_ring->buffer_info[i].segs = segs;\n\ttx_ring->buffer_info[i].bytecount = bytecount;\n\ttx_ring->buffer_info[first].next_to_watch = i;\n\n\treturn count;\n\ndma_error:\n\tdev_err(&pdev->dev, \"Tx DMA map failed\\n\");\n\tbuffer_info->dma = 0;\n\tif (count)\n\t\tcount--;\n\n\twhile (count--) {\n\t\tif (i == 0)\n\t\t\ti += tx_ring->count;\n\t\ti--;\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\te1000_put_txbuf(tx_ring, buffer_info, true);\n\t}\n\n\treturn 0;\n}\n\nstatic void e1000_tx_queue(struct e1000_ring *tx_ring, int tx_flags, int count)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_tx_desc *tx_desc = NULL;\n\tstruct e1000_buffer *buffer_info;\n\tu32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;\n\tunsigned int i;\n\n\tif (tx_flags & E1000_TX_FLAGS_TSO) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |\n\t\t    E1000_TXD_CMD_TSE;\n\t\ttxd_upper |= E1000_TXD_POPTS_TXSM << 8;\n\n\t\tif (tx_flags & E1000_TX_FLAGS_IPV4)\n\t\t\ttxd_upper |= E1000_TXD_POPTS_IXSM << 8;\n\t}\n\n\tif (tx_flags & E1000_TX_FLAGS_CSUM) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;\n\t\ttxd_upper |= E1000_TXD_POPTS_TXSM << 8;\n\t}\n\n\tif (tx_flags & E1000_TX_FLAGS_VLAN) {\n\t\ttxd_lower |= E1000_TXD_CMD_VLE;\n\t\ttxd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);\n\t}\n\n\tif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\n\t\ttxd_lower &= ~(E1000_TXD_CMD_IFCS);\n\n\tif (unlikely(tx_flags & E1000_TX_FLAGS_HWTSTAMP)) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;\n\t\ttxd_upper |= E1000_TXD_EXTCMD_TSTAMP;\n\t}\n\n\ti = tx_ring->next_to_use;\n\n\tdo {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\ttx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\n\t\ttx_desc->lower.data = cpu_to_le32(txd_lower |\n\t\t\t\t\t\t  buffer_info->length);\n\t\ttx_desc->upper.data = cpu_to_le32(txd_upper);\n\n\t\ti++;\n\t\tif (i == tx_ring->count)\n\t\t\ti = 0;\n\t} while (--count > 0);\n\n\ttx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);\n\n\t \n\tif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\n\t\ttx_desc->lower.data &= ~(cpu_to_le32(E1000_TXD_CMD_IFCS));\n\n\t \n\twmb();\n\n\ttx_ring->next_to_use = i;\n}\n\n#define MINIMUM_DHCP_PACKET_SIZE 282\nstatic int e1000_transfer_dhcp_info(struct e1000_adapter *adapter,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 length, offset;\n\n\tif (skb_vlan_tag_present(skb) &&\n\t    !((skb_vlan_tag_get(skb) == adapter->hw.mng_cookie.vlan_id) &&\n\t      (adapter->hw.mng_cookie.status &\n\t       E1000_MNG_DHCP_COOKIE_STATUS_VLAN)))\n\t\treturn 0;\n\n\tif (skb->len <= MINIMUM_DHCP_PACKET_SIZE)\n\t\treturn 0;\n\n\tif (((struct ethhdr *)skb->data)->h_proto != htons(ETH_P_IP))\n\t\treturn 0;\n\n\t{\n\t\tconst struct iphdr *ip = (struct iphdr *)((u8 *)skb->data + 14);\n\t\tstruct udphdr *udp;\n\n\t\tif (ip->protocol != IPPROTO_UDP)\n\t\t\treturn 0;\n\n\t\tudp = (struct udphdr *)((u8 *)ip + (ip->ihl << 2));\n\t\tif (ntohs(udp->dest) != 67)\n\t\t\treturn 0;\n\n\t\toffset = (u8 *)udp + 8 - skb->data;\n\t\tlength = skb->len - offset;\n\t\treturn e1000e_mng_write_dhcp_info(hw, (u8 *)udp + 8, length);\n\t}\n\n\treturn 0;\n}\n\nstatic int __e1000_maybe_stop_tx(struct e1000_ring *tx_ring, int size)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\n\tnetif_stop_queue(adapter->netdev);\n\t \n\tsmp_mb();\n\n\t \n\tif (e1000_desc_unused(tx_ring) < size)\n\t\treturn -EBUSY;\n\n\t \n\tnetif_start_queue(adapter->netdev);\n\t++adapter->restart_queue;\n\treturn 0;\n}\n\nstatic int e1000_maybe_stop_tx(struct e1000_ring *tx_ring, int size)\n{\n\tBUG_ON(size > tx_ring->count);\n\n\tif (e1000_desc_unused(tx_ring) >= size)\n\t\treturn 0;\n\treturn __e1000_maybe_stop_tx(tx_ring, size);\n}\n\nstatic netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tunsigned int first;\n\tunsigned int tx_flags = 0;\n\tunsigned int len = skb_headlen(skb);\n\tunsigned int nr_frags;\n\tunsigned int mss;\n\tint count = 0;\n\tint tso;\n\tunsigned int f;\n\t__be16 protocol = vlan_get_protocol(skb);\n\n\tif (test_bit(__E1000_DOWN, &adapter->state)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (skb->len <= 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tif (skb_put_padto(skb, 17))\n\t\treturn NETDEV_TX_OK;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (mss) {\n\t\tu8 hdr_len;\n\n\t\t \n\t\thdr_len = skb_tcp_all_headers(skb);\n\t\t \n\t\tif (skb->data_len && (hdr_len == len)) {\n\t\t\tunsigned int pull_size;\n\n\t\t\tpull_size = min_t(unsigned int, 4, skb->data_len);\n\t\t\tif (!__pskb_pull_tail(skb, pull_size)) {\n\t\t\t\te_err(\"__pskb_pull_tail failed.\\n\");\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t\tlen = skb_headlen(skb);\n\t\t}\n\t}\n\n\t \n\tif ((mss) || (skb->ip_summed == CHECKSUM_PARTIAL))\n\t\tcount++;\n\tcount++;\n\n\tcount += DIV_ROUND_UP(len, adapter->tx_fifo_limit);\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tfor (f = 0; f < nr_frags; f++)\n\t\tcount += DIV_ROUND_UP(skb_frag_size(&skb_shinfo(skb)->frags[f]),\n\t\t\t\t      adapter->tx_fifo_limit);\n\n\tif (adapter->hw.mac.tx_pkt_filtering)\n\t\te1000_transfer_dhcp_info(adapter, skb);\n\n\t \n\tif (e1000_maybe_stop_tx(tx_ring, count + 2))\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\ttx_flags |= E1000_TX_FLAGS_VLAN;\n\t\ttx_flags |= (skb_vlan_tag_get(skb) <<\n\t\t\t     E1000_TX_FLAGS_VLAN_SHIFT);\n\t}\n\n\tfirst = tx_ring->next_to_use;\n\n\ttso = e1000_tso(tx_ring, skb, protocol);\n\tif (tso < 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (tso)\n\t\ttx_flags |= E1000_TX_FLAGS_TSO;\n\telse if (e1000_tx_csum(tx_ring, skb, protocol))\n\t\ttx_flags |= E1000_TX_FLAGS_CSUM;\n\n\t \n\tif (protocol == htons(ETH_P_IP))\n\t\ttx_flags |= E1000_TX_FLAGS_IPV4;\n\n\tif (unlikely(skb->no_fcs))\n\t\ttx_flags |= E1000_TX_FLAGS_NO_FCS;\n\n\t \n\tcount = e1000_tx_map(tx_ring, skb, first, adapter->tx_fifo_limit,\n\t\t\t     nr_frags);\n\tif (count) {\n\t\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\n\t\t    (adapter->flags & FLAG_HAS_HW_TIMESTAMP)) {\n\t\t\tif (!adapter->tx_hwtstamp_skb) {\n\t\t\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\t\t\ttx_flags |= E1000_TX_FLAGS_HWTSTAMP;\n\t\t\t\tadapter->tx_hwtstamp_skb = skb_get(skb);\n\t\t\t\tadapter->tx_hwtstamp_start = jiffies;\n\t\t\t\tschedule_work(&adapter->tx_hwtstamp_work);\n\t\t\t} else {\n\t\t\t\tadapter->tx_hwtstamp_skipped++;\n\t\t\t}\n\t\t}\n\n\t\tskb_tx_timestamp(skb);\n\n\t\tnetdev_sent_queue(netdev, skb->len);\n\t\te1000_tx_queue(tx_ring, tx_flags, count);\n\t\t \n\t\te1000_maybe_stop_tx(tx_ring,\n\t\t\t\t    ((MAX_SKB_FRAGS + 1) *\n\t\t\t\t     DIV_ROUND_UP(PAGE_SIZE,\n\t\t\t\t\t\t  adapter->tx_fifo_limit) + 4));\n\n\t\tif (!netdev_xmit_more() ||\n\t\t    netif_xmit_stopped(netdev_get_tx_queue(netdev, 0))) {\n\t\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\t\te1000e_update_tdt_wa(tx_ring,\n\t\t\t\t\t\t     tx_ring->next_to_use);\n\t\t\telse\n\t\t\t\twritel(tx_ring->next_to_use, tx_ring->tail);\n\t\t}\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t\ttx_ring->buffer_info[first].time_stamp = 0;\n\t\ttx_ring->next_to_use = first;\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void e1000_tx_timeout(struct net_device *netdev, unsigned int __always_unused txqueue)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tadapter->tx_timeout_count++;\n\tschedule_work(&adapter->reset_task);\n}\n\nstatic void e1000_reset_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter;\n\tadapter = container_of(work, struct e1000_adapter, reset_task);\n\n\trtnl_lock();\n\t \n\tif (test_bit(__E1000_DOWN, &adapter->state)) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tif (!(adapter->flags & FLAG_RESTART_NOW)) {\n\t\te1000e_dump(adapter);\n\t\te_err(\"Reset adapter unexpectedly\\n\");\n\t}\n\te1000e_reinit_locked(adapter);\n\trtnl_unlock();\n}\n\n \nvoid e1000e_get_stats64(struct net_device *netdev,\n\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tspin_lock(&adapter->stats64_lock);\n\te1000e_update_stats(adapter);\n\t \n\tstats->rx_bytes = adapter->stats.gorc;\n\tstats->rx_packets = adapter->stats.gprc;\n\tstats->tx_bytes = adapter->stats.gotc;\n\tstats->tx_packets = adapter->stats.gptc;\n\tstats->multicast = adapter->stats.mprc;\n\tstats->collisions = adapter->stats.colc;\n\n\t \n\n\t \n\tstats->rx_errors = adapter->stats.rxerrc +\n\t    adapter->stats.crcerrs + adapter->stats.algnerrc +\n\t    adapter->stats.ruc + adapter->stats.roc + adapter->stats.cexterr;\n\tstats->rx_length_errors = adapter->stats.ruc + adapter->stats.roc;\n\tstats->rx_crc_errors = adapter->stats.crcerrs;\n\tstats->rx_frame_errors = adapter->stats.algnerrc;\n\tstats->rx_missed_errors = adapter->stats.mpc;\n\n\t \n\tstats->tx_errors = adapter->stats.ecol + adapter->stats.latecol;\n\tstats->tx_aborted_errors = adapter->stats.ecol;\n\tstats->tx_window_errors = adapter->stats.latecol;\n\tstats->tx_carrier_errors = adapter->stats.tncrs;\n\n\t \n\n\tspin_unlock(&adapter->stats64_lock);\n}\n\n \nstatic int e1000_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tint max_frame = new_mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\t \n\tif ((new_mtu > ETH_DATA_LEN) &&\n\t    !(adapter->flags & FLAG_HAS_JUMBO_FRAMES)) {\n\t\te_err(\"Jumbo Frames not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((adapter->hw.mac.type >= e1000_pch2lan) &&\n\t    !(adapter->flags2 & FLAG2_CRC_STRIPPING) &&\n\t    (new_mtu > ETH_DATA_LEN)) {\n\t\te_err(\"Jumbo Frames not supported on this device when CRC stripping is disabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 1100);\n\t \n\tadapter->max_frame_size = max_frame;\n\tnetdev_dbg(netdev, \"changing MTU from %d to %d\\n\",\n\t\t   netdev->mtu, new_mtu);\n\tnetdev->mtu = new_mtu;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tif (netif_running(netdev))\n\t\te1000e_down(adapter, true);\n\n\t \n\n\tif (max_frame <= 2048)\n\t\tadapter->rx_buffer_len = 2048;\n\telse\n\t\tadapter->rx_buffer_len = 4096;\n\n\t \n\tif (max_frame <= (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN))\n\t\tadapter->rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\n\tif (netif_running(netdev))\n\t\te1000e_up(adapter);\n\telse\n\t\te1000e_reset(adapter);\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\tclear_bit(__E1000_RESETTING, &adapter->state);\n\n\treturn 0;\n}\n\nstatic int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,\n\t\t\t   int cmd)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\tif (adapter->hw.phy.media_type != e1000_media_type_copper)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = adapter->hw.phy.addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\te1000_phy_read_status(adapter);\n\n\t\tswitch (data->reg_num & 0x1F) {\n\t\tcase MII_BMCR:\n\t\t\tdata->val_out = adapter->phy_regs.bmcr;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\tdata->val_out = adapter->phy_regs.bmsr;\n\t\t\tbreak;\n\t\tcase MII_PHYSID1:\n\t\t\tdata->val_out = (adapter->hw.phy.id >> 16);\n\t\t\tbreak;\n\t\tcase MII_PHYSID2:\n\t\t\tdata->val_out = (adapter->hw.phy.id & 0xFFFF);\n\t\t\tbreak;\n\t\tcase MII_ADVERTISE:\n\t\t\tdata->val_out = adapter->phy_regs.advertise;\n\t\t\tbreak;\n\t\tcase MII_LPA:\n\t\t\tdata->val_out = adapter->phy_regs.lpa;\n\t\t\tbreak;\n\t\tcase MII_EXPANSION:\n\t\t\tdata->val_out = adapter->phy_regs.expansion;\n\t\t\tbreak;\n\t\tcase MII_CTRL1000:\n\t\t\tdata->val_out = adapter->phy_regs.ctrl1000;\n\t\t\tbreak;\n\t\tcase MII_STAT1000:\n\t\t\tdata->val_out = adapter->phy_regs.stat1000;\n\t\t\tbreak;\n\t\tcase MII_ESTATUS:\n\t\t\tdata->val_out = adapter->phy_regs.estatus;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic int e1000e_hwtstamp_set(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config config;\n\tint ret_val;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tret_val = e1000e_config_hwtstamp(adapter, &config);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\t \n\t\tconfig.rx_filter = HWTSTAMP_FILTER_SOME;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn copy_to_user(ifr->ifr_data, &config,\n\t\t\t    sizeof(config)) ? -EFAULT : 0;\n}\n\nstatic int e1000e_hwtstamp_get(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\treturn copy_to_user(ifr->ifr_data, &adapter->hwtstamp_config,\n\t\t\t    sizeof(adapter->hwtstamp_config)) ? -EFAULT : 0;\n}\n\nstatic int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn e1000_mii_ioctl(netdev, ifr, cmd);\n\tcase SIOCSHWTSTAMP:\n\t\treturn e1000e_hwtstamp_set(netdev, ifr);\n\tcase SIOCGHWTSTAMP:\n\t\treturn e1000e_hwtstamp_get(netdev, ifr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int e1000_init_phy_wakeup(struct e1000_adapter *adapter, u32 wufc)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 i, mac_reg, wuc;\n\tu16 phy_reg, wuc_enable;\n\tint retval;\n\n\t \n\te1000_copy_rx_addrs_to_phy_ich8lan(hw);\n\n\tretval = hw->phy.ops.acquire(hw);\n\tif (retval) {\n\t\te_err(\"Could not acquire PHY\\n\");\n\t\treturn retval;\n\t}\n\n\t \n\tretval = e1000_enable_phy_wakeup_reg_access_bm(hw, &wuc_enable);\n\tif (retval)\n\t\tgoto release;\n\n\t \n\tfor (i = 0; i < adapter->hw.mac.mta_reg_count; i++) {\n\t\tmac_reg = E1000_READ_REG_ARRAY(hw, E1000_MTA, i);\n\t\thw->phy.ops.write_reg_page(hw, BM_MTA(i),\n\t\t\t\t\t   (u16)(mac_reg & 0xFFFF));\n\t\thw->phy.ops.write_reg_page(hw, BM_MTA(i) + 1,\n\t\t\t\t\t   (u16)((mac_reg >> 16) & 0xFFFF));\n\t}\n\n\t \n\thw->phy.ops.read_reg_page(&adapter->hw, BM_RCTL, &phy_reg);\n\tmac_reg = er32(RCTL);\n\tif (mac_reg & E1000_RCTL_UPE)\n\t\tphy_reg |= BM_RCTL_UPE;\n\tif (mac_reg & E1000_RCTL_MPE)\n\t\tphy_reg |= BM_RCTL_MPE;\n\tphy_reg &= ~(BM_RCTL_MO_MASK);\n\tif (mac_reg & E1000_RCTL_MO_3)\n\t\tphy_reg |= (((mac_reg & E1000_RCTL_MO_3) >> E1000_RCTL_MO_SHIFT)\n\t\t\t    << BM_RCTL_MO_SHIFT);\n\tif (mac_reg & E1000_RCTL_BAM)\n\t\tphy_reg |= BM_RCTL_BAM;\n\tif (mac_reg & E1000_RCTL_PMCF)\n\t\tphy_reg |= BM_RCTL_PMCF;\n\tmac_reg = er32(CTRL);\n\tif (mac_reg & E1000_CTRL_RFCE)\n\t\tphy_reg |= BM_RCTL_RFCE;\n\thw->phy.ops.write_reg_page(&adapter->hw, BM_RCTL, phy_reg);\n\n\twuc = E1000_WUC_PME_EN;\n\tif (wufc & (E1000_WUFC_MAG | E1000_WUFC_LNKC))\n\t\twuc |= E1000_WUC_APME;\n\n\t \n\tew32(WUFC, wufc);\n\tew32(WUC, (E1000_WUC_PHY_WAKE | E1000_WUC_APMPME |\n\t\t   E1000_WUC_PME_STATUS | wuc));\n\n\t \n\thw->phy.ops.write_reg_page(&adapter->hw, BM_WUFC, wufc);\n\thw->phy.ops.write_reg_page(&adapter->hw, BM_WUC, wuc);\n\n\t \n\twuc_enable |= BM_WUC_ENABLE_BIT | BM_WUC_HOST_WU_BIT;\n\tretval = e1000_disable_phy_wakeup_reg_access_bm(hw, &wuc_enable);\n\tif (retval)\n\t\te_err(\"Could not set PHY Host Wakeup bit\\n\");\nrelease:\n\thw->phy.ops.release(hw);\n\n\treturn retval;\n}\n\nstatic void e1000e_flush_lpic(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ret_val;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto fl_out;\n\n\tpr_info(\"EEE TX LPI TIMER: %08X\\n\",\n\t\ter32(LPIC) >> E1000_LPIC_LPIET_SHIFT);\n\n\thw->phy.ops.release(hw);\n\nfl_out:\n\tpm_runtime_put_sync(netdev->dev.parent);\n}\n\n \nstatic void e1000e_s0ix_entry_flow(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 mac_data;\n\tu16 phy_data;\n\n\tif (er32(FWSM) & E1000_ICH_FWSM_FW_VALID &&\n\t    hw->mac.type >= e1000_pch_adp) {\n\t\t \n\t\tmac_data = er32(H2ME);\n\t\tmac_data |= E1000_H2ME_START_DPG;\n\t\tmac_data &= ~E1000_H2ME_EXIT_DPG;\n\t\ttrace_e1000e_trace_mac_register(mac_data);\n\t\tew32(H2ME, mac_data);\n\t} else {\n\t\t \n\t\t \n\t\te1e_rphy(hw, HV_PM_CTRL, &phy_data);\n\t\tphy_data &= ~HV_PM_CTRL_K1_CLK_REQ;\n\t\tphy_data |= BIT(10);\n\t\te1e_wphy(hw, HV_PM_CTRL, phy_data);\n\n\t\t \n\t\te1e_rphy(hw, I217_CGFREG, &phy_data);\n\t\tphy_data |= BIT(5);\n\t\te1e_wphy(hw, I217_CGFREG, phy_data);\n\n\t\t \n\t\te1e_rphy(hw, CV_SMB_CTRL, &phy_data);\n\t\tphy_data |= CV_SMB_CTRL_FORCE_SMBUS;\n\t\te1e_wphy(hw, CV_SMB_CTRL, phy_data);\n\t\tmac_data = er32(CTRL_EXT);\n\t\tmac_data |= E1000_CTRL_EXT_FORCE_SMBUS;\n\t\tew32(CTRL_EXT, mac_data);\n\n\t\t \n\t\te1e_rphy(hw, I82579_DFT_CTRL, &phy_data);\n\t\tphy_data |= BIT(0);\n\t\tphy_data |= BIT(7);\n\t\tphy_data |= BIT(8);\n\t\tphy_data |= BIT(9);\n\t\te1e_wphy(hw, I82579_DFT_CTRL, phy_data);\n\n\t\tmac_data = er32(EXTCNF_CTRL);\n\t\tmac_data |= E1000_EXTCNF_CTRL_GATE_PHY_CFG;\n\t\tew32(EXTCNF_CTRL, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM7);\n\t\tmac_data |= BIT(22);\n\t\tew32(FEXTNVM7, mac_data);\n\n\t\t \n\t\tmac_data = er32(DPGFR);\n\t\tmac_data |= BIT(2);\n\t\tew32(DPGFR, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM12);\n\t\tmac_data |= BIT(12);\n\t\tew32(FEXTNVM12, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM9);\n\t\tmac_data &= ~BIT(28);\n\t\tew32(FEXTNVM9, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM6);\n\t\tmac_data |= BIT(31);\n\t\tew32(FEXTNVM6, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM8);\n\t\tmac_data |= BIT(9);\n\t\tew32(FEXTNVM8, mac_data);\n\n\t\t \n\t\tmac_data = er32(CTRL_EXT);\n\t\tmac_data |= E1000_CTRL_EXT_DMA_DYN_CLK_EN;\n\t\tew32(CTRL_EXT, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM5);\n\t\tmac_data |= BIT(7);\n\t\tew32(FEXTNVM5, mac_data);\n\t}\n\n\t \n\tmac_data = er32(FEXTNVM7);\n\tmac_data |= BIT(31);\n\tmac_data &= ~BIT(0);\n\tew32(FEXTNVM7, mac_data);\n\n\t \n\tmac_data = er32(CTRL_EXT);\n\tmac_data |= BIT(3);\n\tew32(CTRL_EXT, mac_data);\n\n\t \n\tmac_data = er32(TDFH);\n\tif (mac_data)\n\t\tew32(TDFH, 0);\n\tmac_data = er32(TDFT);\n\tif (mac_data)\n\t\tew32(TDFT, 0);\n\tmac_data = er32(TDFHS);\n\tif (mac_data)\n\t\tew32(TDFHS, 0);\n\tmac_data = er32(TDFTS);\n\tif (mac_data)\n\t\tew32(TDFTS, 0);\n\tmac_data = er32(TDFPC);\n\tif (mac_data)\n\t\tew32(TDFPC, 0);\n\tmac_data = er32(RDFH);\n\tif (mac_data)\n\t\tew32(RDFH, 0);\n\tmac_data = er32(RDFT);\n\tif (mac_data)\n\t\tew32(RDFT, 0);\n\tmac_data = er32(RDFHS);\n\tif (mac_data)\n\t\tew32(RDFHS, 0);\n\tmac_data = er32(RDFTS);\n\tif (mac_data)\n\t\tew32(RDFTS, 0);\n\tmac_data = er32(RDFPC);\n\tif (mac_data)\n\t\tew32(RDFPC, 0);\n}\n\nstatic void e1000e_s0ix_exit_flow(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool firmware_bug = false;\n\tu32 mac_data;\n\tu16 phy_data;\n\tu32 i = 0;\n\n\tif (er32(FWSM) & E1000_ICH_FWSM_FW_VALID &&\n\t    hw->mac.type >= e1000_pch_adp) {\n\t\t \n\t\tmac_data = er32(FEXTNVM);\n\t\tmac_data |= BIT(3);\n\t\tew32(FEXTNVM, mac_data);\n\t\t \n\t\tmac_data = er32(H2ME);\n\t\tmac_data &= ~E1000_H2ME_START_DPG;\n\t\tmac_data |= E1000_H2ME_EXIT_DPG;\n\t\ttrace_e1000e_trace_mac_register(mac_data);\n\t\tew32(H2ME, mac_data);\n\n\t\t \n\t\twhile (!(er32(EXFWSM) & E1000_EXFWSM_DPG_EXIT_DONE)) {\n\t\t\tif (i > 100 && !firmware_bug)\n\t\t\t\tfirmware_bug = true;\n\n\t\t\tif (i++ == 250) {\n\t\t\t\te_dbg(\"Timeout (firmware bug): %d msec\\n\",\n\t\t\t\t      i * 10);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tusleep_range(10000, 11000);\n\t\t}\n\t\tif (firmware_bug)\n\t\t\te_warn(\"DPG_EXIT_DONE took %d msec. This is a firmware bug\\n\",\n\t\t\t       i * 10);\n\t\telse\n\t\t\te_dbg(\"DPG_EXIT_DONE cleared after %d msec\\n\", i * 10);\n\t} else {\n\t\t \n\n\t\t \n\t\tmac_data = er32(FEXTNVM7);\n\t\tmac_data &= 0xFFBFFFFF;\n\t\tew32(FEXTNVM7, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM8);\n\t\tmac_data &= ~BIT(9);\n\t\tew32(FEXTNVM8, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM6);\n\t\tmac_data &= ~BIT(31);\n\t\tew32(FEXTNVM6, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM9);\n\t\tmac_data |= BIT(28);\n\t\tew32(FEXTNVM9, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM12);\n\t\tmac_data &= ~BIT(12);\n\t\tew32(FEXTNVM12, mac_data);\n\n\t\t \n\t\tmac_data = er32(DPGFR);\n\t\tmac_data &= ~BIT(2);\n\t\tew32(DPGFR, mac_data);\n\n\t\t \n\t\tmac_data = er32(CTRL_EXT);\n\t\tmac_data &= 0xFFF7FFFF;\n\t\tew32(CTRL_EXT, mac_data);\n\n\t\t \n\t\tmac_data = er32(FEXTNVM5);\n\t\tmac_data &= 0xFFFFFF7F;\n\t\tew32(FEXTNVM5, mac_data);\n\n\t\t \n\t\te1e_rphy(hw, HV_PM_CTRL, &phy_data);\n\t\tphy_data &= 0xFBFF;\n\t\tphy_data |= HV_PM_CTRL_K1_CLK_REQ;\n\t\te1e_wphy(hw, HV_PM_CTRL, phy_data);\n\n\t\t \n\t\te1e_rphy(hw, I217_CGFREG, &phy_data);\n\t\tphy_data &= 0xFFDF;\n\t\te1e_wphy(hw, I217_CGFREG, phy_data);\n\n\t\t \n\t\te1e_rphy(hw, CV_SMB_CTRL, &phy_data);\n\t\tphy_data &= ~CV_SMB_CTRL_FORCE_SMBUS;\n\t\te1e_wphy(hw, CV_SMB_CTRL, phy_data);\n\t\tmac_data = er32(CTRL_EXT);\n\t\tmac_data &= ~E1000_CTRL_EXT_FORCE_SMBUS;\n\t\tew32(CTRL_EXT, mac_data);\n\t}\n\n\t \n\tmac_data = er32(CTRL_EXT);\n\tmac_data &= 0xFFFFFFF7;\n\tew32(CTRL_EXT, mac_data);\n\n\t \n\tmac_data = er32(FEXTNVM7);\n\tmac_data &= ~BIT(31);\n\tmac_data |= BIT(0);\n\tew32(FEXTNVM7, mac_data);\n}\n\nstatic int e1000e_pm_freeze(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tbool present;\n\n\trtnl_lock();\n\n\tpresent = netif_device_present(netdev);\n\tnetif_device_detach(netdev);\n\n\tif (present && netif_running(netdev)) {\n\t\tint count = E1000_CHECK_RESET_COUNT;\n\n\t\twhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\n\t\t\tusleep_range(10000, 11000);\n\n\t\tWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\n\n\t\t \n\t\te1000e_down(adapter, false);\n\t\te1000_free_irq(adapter);\n\t}\n\trtnl_unlock();\n\n\te1000e_reset_interrupt_capability(adapter);\n\n\t \n\te1000e_disable_pcie_master(&adapter->hw);\n\n\treturn 0;\n}\n\nstatic int __e1000_shutdown(struct pci_dev *pdev, bool runtime)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl, ctrl_ext, rctl, status, wufc;\n\tint retval = 0;\n\n\t \n\tif (runtime)\n\t\twufc = E1000_WUFC_LNKC;\n\telse if (device_may_wakeup(&pdev->dev))\n\t\twufc = adapter->wol;\n\telse\n\t\twufc = 0;\n\n\tstatus = er32(STATUS);\n\tif (status & E1000_STATUS_LU)\n\t\twufc &= ~E1000_WUFC_LNKC;\n\n\tif (wufc) {\n\t\te1000_setup_rctl(adapter);\n\t\te1000e_set_rx_mode(netdev);\n\n\t\t \n\t\tif (wufc & E1000_WUFC_MC) {\n\t\t\trctl = er32(RCTL);\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\t\tew32(RCTL, rctl);\n\t\t}\n\n\t\tctrl = er32(CTRL);\n\t\tctrl |= E1000_CTRL_ADVD3WUC;\n\t\tif (!(adapter->flags2 & FLAG2_HAS_PHY_WAKEUP))\n\t\t\tctrl |= E1000_CTRL_EN_PHY_PWR_MGMT;\n\t\tew32(CTRL, ctrl);\n\n\t\tif (adapter->hw.phy.media_type == e1000_media_type_fiber ||\n\t\t    adapter->hw.phy.media_type ==\n\t\t    e1000_media_type_internal_serdes) {\n\t\t\t \n\t\t\tctrl_ext = er32(CTRL_EXT);\n\t\t\tctrl_ext |= E1000_CTRL_EXT_SDP3_DATA;\n\t\t\tew32(CTRL_EXT, ctrl_ext);\n\t\t}\n\n\t\tif (!runtime)\n\t\t\te1000e_power_up_phy(adapter);\n\n\t\tif (adapter->flags & FLAG_IS_ICH)\n\t\t\te1000_suspend_workarounds_ich8lan(&adapter->hw);\n\n\t\tif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\n\t\t\t \n\t\t\tretval = e1000_init_phy_wakeup(adapter, wufc);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\t \n\t\t\tew32(WUFC, wufc);\n\t\t\tew32(WUC, E1000_WUC_PME_EN);\n\t\t}\n\t} else {\n\t\tew32(WUC, 0);\n\t\tew32(WUFC, 0);\n\n\t\te1000_power_down_phy(adapter);\n\t}\n\n\tif (adapter->hw.phy.type == e1000_phy_igp_3) {\n\t\te1000e_igp3_phy_powerdown_workaround_ich8lan(&adapter->hw);\n\t} else if (hw->mac.type >= e1000_pch_lpt) {\n\t\tif (wufc && !(wufc & (E1000_WUFC_EX | E1000_WUFC_MC | E1000_WUFC_BC)))\n\t\t\t \n\t\t\tretval = e1000_enable_ulp_lpt_lp(hw, !runtime);\n\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tif ((hw->phy.type >= e1000_phy_i217) &&\n\t    adapter->eee_advert && hw->dev_spec.ich8lan.eee_lp_ability) {\n\t\tu16 lpi_ctrl = 0;\n\n\t\tretval = hw->phy.ops.acquire(hw);\n\t\tif (!retval) {\n\t\t\tretval = e1e_rphy_locked(hw, I82579_LPI_CTRL,\n\t\t\t\t\t\t &lpi_ctrl);\n\t\t\tif (!retval) {\n\t\t\t\tif (adapter->eee_advert &\n\t\t\t\t    hw->dev_spec.ich8lan.eee_lp_ability &\n\t\t\t\t    I82579_EEE_100_SUPPORTED)\n\t\t\t\t\tlpi_ctrl |= I82579_LPI_CTRL_100_ENABLE;\n\t\t\t\tif (adapter->eee_advert &\n\t\t\t\t    hw->dev_spec.ich8lan.eee_lp_ability &\n\t\t\t\t    I82579_EEE_1000_SUPPORTED)\n\t\t\t\t\tlpi_ctrl |= I82579_LPI_CTRL_1000_ENABLE;\n\n\t\t\t\tretval = e1e_wphy_locked(hw, I82579_LPI_CTRL,\n\t\t\t\t\t\t\t lpi_ctrl);\n\t\t\t}\n\t\t}\n\t\thw->phy.ops.release(hw);\n\t}\n\n\t \n\te1000e_release_hw_control(adapter);\n\n\tpci_clear_master(pdev);\n\n\t \n\tif (adapter->flags & FLAG_IS_QUAD_PORT) {\n\t\tstruct pci_dev *us_dev = pdev->bus->self;\n\t\tu16 devctl;\n\n\t\tif (!us_dev)\n\t\t\treturn 0;\n\n\t\tpcie_capability_read_word(us_dev, PCI_EXP_DEVCTL, &devctl);\n\t\tpcie_capability_write_word(us_dev, PCI_EXP_DEVCTL,\n\t\t\t\t\t   (devctl & ~PCI_EXP_DEVCTL_CERE));\n\n\t\tpci_save_state(pdev);\n\t\tpci_prepare_to_sleep(pdev);\n\n\t\tpcie_capability_write_word(us_dev, PCI_EXP_DEVCTL, devctl);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __e1000e_disable_aspm(struct pci_dev *pdev, u16 state, int locked)\n{\n\tstruct pci_dev *parent = pdev->bus->self;\n\tu16 aspm_dis_mask = 0;\n\tu16 pdev_aspmc, parent_aspmc;\n\n\tswitch (state) {\n\tcase PCIE_LINK_STATE_L0S:\n\tcase PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1:\n\t\taspm_dis_mask |= PCI_EXP_LNKCTL_ASPM_L0S;\n\t\tfallthrough;  \n\tcase PCIE_LINK_STATE_L1:\n\t\taspm_dis_mask |= PCI_EXP_LNKCTL_ASPM_L1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &pdev_aspmc);\n\tpdev_aspmc &= PCI_EXP_LNKCTL_ASPMC;\n\n\tif (parent) {\n\t\tpcie_capability_read_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t  &parent_aspmc);\n\t\tparent_aspmc &= PCI_EXP_LNKCTL_ASPMC;\n\t}\n\n\t \n\tif (!(pdev_aspmc & aspm_dis_mask) &&\n\t    (!parent || !(parent_aspmc & aspm_dis_mask)))\n\t\treturn;\n\n\tdev_info(&pdev->dev, \"Disabling ASPM %s %s\\n\",\n\t\t (aspm_dis_mask & pdev_aspmc & PCI_EXP_LNKCTL_ASPM_L0S) ?\n\t\t \"L0s\" : \"\",\n\t\t (aspm_dis_mask & pdev_aspmc & PCI_EXP_LNKCTL_ASPM_L1) ?\n\t\t \"L1\" : \"\");\n\n#ifdef CONFIG_PCIEASPM\n\tif (locked)\n\t\tpci_disable_link_state_locked(pdev, state);\n\telse\n\t\tpci_disable_link_state(pdev, state);\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &pdev_aspmc);\n\tpdev_aspmc &= PCI_EXP_LNKCTL_ASPMC;\n\n\tif (!(aspm_dis_mask & pdev_aspmc))\n\t\treturn;\n#endif\n\n\t \n\tpcie_capability_clear_word(pdev, PCI_EXP_LNKCTL, aspm_dis_mask);\n\n\tif (parent)\n\t\tpcie_capability_clear_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t   aspm_dis_mask);\n}\n\n \nstatic void e1000e_disable_aspm(struct pci_dev *pdev, u16 state)\n{\n\t__e1000e_disable_aspm(pdev, state, 0);\n}\n\n \nstatic void e1000e_disable_aspm_locked(struct pci_dev *pdev, u16 state)\n{\n\t__e1000e_disable_aspm(pdev, state, 1);\n}\n\nstatic int e1000e_pm_thaw(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tint rc = 0;\n\n\te1000e_set_interrupt_capability(adapter);\n\n\trtnl_lock();\n\tif (netif_running(netdev)) {\n\t\trc = e1000_request_irq(adapter);\n\t\tif (rc)\n\t\t\tgoto err_irq;\n\n\t\te1000e_up(adapter);\n\t}\n\n\tnetif_device_attach(netdev);\nerr_irq:\n\trtnl_unlock();\n\n\treturn rc;\n}\n\nstatic int __e1000_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 aspm_disable_flag = 0;\n\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm(pdev, aspm_disable_flag);\n\n\tpci_set_master(pdev);\n\n\tif (hw->mac.type >= e1000_pch2lan)\n\t\te1000_resume_workarounds_pchlan(&adapter->hw);\n\n\te1000e_power_up_phy(adapter);\n\n\t \n\tif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\n\t\tu16 phy_data;\n\n\t\te1e_rphy(&adapter->hw, BM_WUS, &phy_data);\n\t\tif (phy_data) {\n\t\t\te_info(\"PHY Wakeup cause - %s\\n\",\n\t\t\t       phy_data & E1000_WUS_EX ? \"Unicast Packet\" :\n\t\t\t       phy_data & E1000_WUS_MC ? \"Multicast Packet\" :\n\t\t\t       phy_data & E1000_WUS_BC ? \"Broadcast Packet\" :\n\t\t\t       phy_data & E1000_WUS_MAG ? \"Magic Packet\" :\n\t\t\t       phy_data & E1000_WUS_LNKC ?\n\t\t\t       \"Link Status Change\" : \"other\");\n\t\t}\n\t\te1e_wphy(&adapter->hw, BM_WUS, ~0);\n\t} else {\n\t\tu32 wus = er32(WUS);\n\n\t\tif (wus) {\n\t\t\te_info(\"MAC Wakeup cause - %s\\n\",\n\t\t\t       wus & E1000_WUS_EX ? \"Unicast Packet\" :\n\t\t\t       wus & E1000_WUS_MC ? \"Multicast Packet\" :\n\t\t\t       wus & E1000_WUS_BC ? \"Broadcast Packet\" :\n\t\t\t       wus & E1000_WUS_MAG ? \"Magic Packet\" :\n\t\t\t       wus & E1000_WUS_LNKC ? \"Link Status Change\" :\n\t\t\t       \"other\");\n\t\t}\n\t\tew32(WUS, ~0);\n\t}\n\n\te1000e_reset(adapter);\n\n\te1000_init_manageability_pt(adapter);\n\n\t \n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_get_hw_control(adapter);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int e1000e_pm_prepare(struct device *dev)\n{\n\treturn pm_runtime_suspended(dev) &&\n\t\tpm_suspend_via_firmware();\n}\n\nstatic __maybe_unused int e1000e_pm_suspend(struct device *dev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint rc;\n\n\te1000e_flush_lpic(pdev);\n\n\te1000e_pm_freeze(dev);\n\n\trc = __e1000_shutdown(pdev, false);\n\tif (rc) {\n\t\te1000e_pm_thaw(dev);\n\t} else {\n\t\t \n\t\tif (adapter->flags2 & FLAG2_ENABLE_S0IX_FLOWS)\n\t\t\te1000e_s0ix_entry_flow(adapter);\n\t}\n\n\treturn rc;\n}\n\nstatic __maybe_unused int e1000e_pm_resume(struct device *dev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint rc;\n\n\t \n\tif (adapter->flags2 & FLAG2_ENABLE_S0IX_FLOWS)\n\t\te1000e_s0ix_exit_flow(adapter);\n\n\trc = __e1000_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\treturn e1000e_pm_thaw(dev);\n}\n\nstatic __maybe_unused int e1000e_pm_runtime_idle(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tu16 eee_lp;\n\n\teee_lp = adapter->hw.dev_spec.ich8lan.eee_lp_ability;\n\n\tif (!e1000e_has_link(adapter)) {\n\t\tadapter->hw.dev_spec.ich8lan.eee_lp_ability = eee_lp;\n\t\tpm_schedule_suspend(dev, 5 * MSEC_PER_SEC);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic __maybe_unused int e1000e_pm_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tint rc;\n\n\tpdev->pme_poll = true;\n\n\trc = __e1000_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (netdev->flags & IFF_UP)\n\t\te1000e_up(adapter);\n\n\treturn rc;\n}\n\nstatic __maybe_unused int e1000e_pm_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (netdev->flags & IFF_UP) {\n\t\tint count = E1000_CHECK_RESET_COUNT;\n\n\t\twhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\n\t\t\tusleep_range(10000, 11000);\n\n\t\tWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\n\n\t\t \n\t\te1000e_down(adapter, false);\n\t}\n\n\tif (__e1000_shutdown(pdev, true)) {\n\t\te1000e_pm_runtime_resume(dev);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void e1000_shutdown(struct pci_dev *pdev)\n{\n\te1000e_flush_lpic(pdev);\n\n\te1000e_pm_freeze(&pdev->dev);\n\n\t__e1000_shutdown(pdev, false);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\nstatic irqreturn_t e1000_intr_msix(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->msix_entries) {\n\t\tint vector, msix_irq;\n\n\t\tvector = 0;\n\t\tmsix_irq = adapter->msix_entries[vector].vector;\n\t\tif (disable_hardirq(msix_irq))\n\t\t\te1000_intr_msix_rx(msix_irq, netdev);\n\t\tenable_irq(msix_irq);\n\n\t\tvector++;\n\t\tmsix_irq = adapter->msix_entries[vector].vector;\n\t\tif (disable_hardirq(msix_irq))\n\t\t\te1000_intr_msix_tx(msix_irq, netdev);\n\t\tenable_irq(msix_irq);\n\n\t\tvector++;\n\t\tmsix_irq = adapter->msix_entries[vector].vector;\n\t\tif (disable_hardirq(msix_irq))\n\t\t\te1000_msix_other(msix_irq, netdev);\n\t\tenable_irq(msix_irq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void e1000_netpoll(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tswitch (adapter->int_mode) {\n\tcase E1000E_INT_MODE_MSIX:\n\t\te1000_intr_msix(adapter->pdev->irq, netdev);\n\t\tbreak;\n\tcase E1000E_INT_MODE_MSI:\n\t\tif (disable_hardirq(adapter->pdev->irq))\n\t\t\te1000_intr_msi(adapter->pdev->irq, netdev);\n\t\tenable_irq(adapter->pdev->irq);\n\t\tbreak;\n\tdefault:\t\t \n\t\tif (disable_hardirq(adapter->pdev->irq))\n\t\t\te1000_intr(adapter->pdev->irq, netdev);\n\t\tenable_irq(adapter->pdev->irq);\n\t\tbreak;\n\t}\n}\n#endif\n\n \nstatic pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\te1000e_pm_freeze(&pdev->dev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tpci_disable_device(pdev);\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 aspm_disable_flag = 0;\n\tint err;\n\tpci_ers_result_t result;\n\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm_locked(pdev, aspm_disable_flag);\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset.\\n\");\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tpdev->state_saved = true;\n\t\tpci_restore_state(pdev);\n\t\tpci_set_master(pdev);\n\n\t\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\t\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\t\te1000e_reset(adapter);\n\t\tew32(WUS, ~0);\n\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\treturn result;\n}\n\n \nstatic void e1000_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\te1000_init_manageability_pt(adapter);\n\n\te1000e_pm_thaw(&pdev->dev);\n\n\t \n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_get_hw_control(adapter);\n}\n\nstatic void e1000_print_device_info(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 ret_val;\n\tu8 pba_str[E1000_PBANUM_LENGTH];\n\n\t \n\te_info(\"(PCI Express:2.5GT/s:%s) %pM\\n\",\n\t        \n\t       ((hw->bus.width == e1000_bus_width_pcie_x4) ? \"Width x4\" :\n\t\t\"Width x1\"),\n\t        \n\t       netdev->dev_addr);\n\te_info(\"Intel(R) PRO/%s Network Connection\\n\",\n\t       (hw->phy.type == e1000_phy_ife) ? \"10/100\" : \"1000\");\n\tret_val = e1000_read_pba_string_generic(hw, pba_str,\n\t\t\t\t\t\tE1000_PBANUM_LENGTH);\n\tif (ret_val)\n\t\tstrscpy((char *)pba_str, \"Unknown\", sizeof(pba_str));\n\te_info(\"MAC: %d, PHY: %d, PBA No: %s\\n\",\n\t       hw->mac.type, hw->phy.type, pba_str);\n}\n\nstatic void e1000_eeprom_checks(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint ret_val;\n\tu16 buf = 0;\n\n\tif (hw->mac.type != e1000_82573)\n\t\treturn;\n\n\tret_val = e1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &buf);\n\tle16_to_cpus(&buf);\n\tif (!ret_val && (!(buf & BIT(0)))) {\n\t\t \n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Warning: detected DSPD enabled in EEPROM\\n\");\n\t}\n}\n\nstatic netdev_features_t e1000_fix_features(struct net_device *netdev,\n\t\t\t\t\t    netdev_features_t features)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\tif ((hw->mac.type >= e1000_pch2lan) && (netdev->mtu > ETH_DATA_LEN))\n\t\tfeatures &= ~NETIF_F_RXFCS;\n\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int e1000_set_features(struct net_device *netdev,\n\t\t\t      netdev_features_t features)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tnetdev_features_t changed = features ^ netdev->features;\n\n\tif (changed & (NETIF_F_TSO | NETIF_F_TSO6))\n\t\tadapter->flags |= FLAG_TSO_FORCE;\n\n\tif (!(changed & (NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t NETIF_F_RXCSUM | NETIF_F_RXHASH | NETIF_F_RXFCS |\n\t\t\t NETIF_F_RXALL)))\n\t\treturn 0;\n\n\tif (changed & NETIF_F_RXFCS) {\n\t\tif (features & NETIF_F_RXFCS) {\n\t\t\tadapter->flags2 &= ~FLAG2_CRC_STRIPPING;\n\t\t} else {\n\t\t\t \n\t\t\tif (adapter->flags2 & FLAG2_DFLT_CRC_STRIPPING)\n\t\t\t\tadapter->flags2 |= FLAG2_CRC_STRIPPING;\n\t\t\telse\n\t\t\t\tadapter->flags2 &= ~FLAG2_CRC_STRIPPING;\n\t\t}\n\t}\n\n\tnetdev->features = features;\n\n\tif (netif_running(netdev))\n\t\te1000e_reinit_locked(adapter);\n\telse\n\t\te1000e_reset(adapter);\n\n\treturn 1;\n}\n\nstatic const struct net_device_ops e1000e_netdev_ops = {\n\t.ndo_open\t\t= e1000e_open,\n\t.ndo_stop\t\t= e1000e_close,\n\t.ndo_start_xmit\t\t= e1000_xmit_frame,\n\t.ndo_get_stats64\t= e1000e_get_stats64,\n\t.ndo_set_rx_mode\t= e1000e_set_rx_mode,\n\t.ndo_set_mac_address\t= e1000_set_mac,\n\t.ndo_change_mtu\t\t= e1000_change_mtu,\n\t.ndo_eth_ioctl\t\t= e1000_ioctl,\n\t.ndo_tx_timeout\t\t= e1000_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\n\t.ndo_vlan_rx_add_vid\t= e1000_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= e1000_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= e1000_netpoll,\n#endif\n\t.ndo_set_features = e1000_set_features,\n\t.ndo_fix_features = e1000_fix_features,\n\t.ndo_features_check\t= passthru_features_check,\n};\n\n \nstatic int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct e1000_adapter *adapter;\n\tstruct e1000_hw *hw;\n\tconst struct e1000_info *ei = e1000_info_tbl[ent->driver_data];\n\tresource_size_t mmio_start, mmio_len;\n\tresource_size_t flash_start, flash_len;\n\tstatic int cards_found;\n\tu16 aspm_disable_flag = 0;\n\tu16 eeprom_data = 0;\n\tu16 eeprom_apme_mask = E1000_EEPROM_APME;\n\tint bars, i, err;\n\ts32 ret_val = 0;\n\n\tif (ei->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (ei->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm(pdev, aspm_disable_flag);\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"No usable DMA configuration, aborting\\n\");\n\t\tgoto err_dma;\n\t}\n\n\tbars = pci_select_bars(pdev, IORESOURCE_MEM);\n\terr = pci_request_selected_regions_exclusive(pdev, bars,\n\t\t\t\t\t\t     e1000e_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\tpci_set_master(pdev);\n\t \n\terr = pci_save_state(pdev);\n\tif (err)\n\t\tgoto err_alloc_etherdev;\n\n\terr = -ENOMEM;\n\tnetdev = alloc_etherdev(sizeof(struct e1000_adapter));\n\tif (!netdev)\n\t\tgoto err_alloc_etherdev;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tnetdev->irq = pdev->irq;\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\thw = &adapter->hw;\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->ei = ei;\n\tadapter->pba = ei->pba;\n\tadapter->flags = ei->flags;\n\tadapter->flags2 = ei->flags2;\n\tadapter->hw.adapter = adapter;\n\tadapter->hw.mac.type = ei->mac;\n\tadapter->max_hw_frame_size = ei->max_hw_frame_size;\n\tadapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\n\tmmio_start = pci_resource_start(pdev, 0);\n\tmmio_len = pci_resource_len(pdev, 0);\n\n\terr = -EIO;\n\tadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw.hw_addr)\n\t\tgoto err_ioremap;\n\n\tif ((adapter->flags & FLAG_HAS_FLASH) &&\n\t    (pci_resource_flags(pdev, 1) & IORESOURCE_MEM) &&\n\t    (hw->mac.type < e1000_pch_spt)) {\n\t\tflash_start = pci_resource_start(pdev, 1);\n\t\tflash_len = pci_resource_len(pdev, 1);\n\t\tadapter->hw.flash_address = ioremap(flash_start, flash_len);\n\t\tif (!adapter->hw.flash_address)\n\t\t\tgoto err_flashmap;\n\t}\n\n\t \n\tif (adapter->flags2 & FLAG2_HAS_EEE)\n\t\tadapter->eee_advert = MDIO_EEE_100TX | MDIO_EEE_1000T;\n\n\t \n\tnetdev->netdev_ops = &e1000e_netdev_ops;\n\te1000e_set_ethtool_ops(netdev);\n\tnetdev->watchdog_timeo = 5 * HZ;\n\tnetif_napi_add(netdev, &adapter->napi, e1000e_poll);\n\tstrscpy(netdev->name, pci_name(pdev), sizeof(netdev->name));\n\n\tnetdev->mem_start = mmio_start;\n\tnetdev->mem_end = mmio_start + mmio_len;\n\n\tadapter->bd_number = cards_found++;\n\n\te1000e_check_options(adapter);\n\n\t \n\terr = e1000_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\tmemcpy(&hw->mac.ops, ei->mac_ops, sizeof(hw->mac.ops));\n\tmemcpy(&hw->nvm.ops, ei->nvm_ops, sizeof(hw->nvm.ops));\n\tmemcpy(&hw->phy.ops, ei->phy_ops, sizeof(hw->phy.ops));\n\n\terr = ei->get_variants(adapter);\n\tif (err)\n\t\tgoto err_hw_init;\n\n\tif ((adapter->flags & FLAG_IS_ICH) &&\n\t    (adapter->flags & FLAG_READ_ONLY_NVM) &&\n\t    (hw->mac.type < e1000_pch_spt))\n\t\te1000e_write_protect_nvm_ich8lan(&adapter->hw);\n\n\thw->mac.ops.get_bus_info(&adapter->hw);\n\n\tadapter->hw.phy.autoneg_wait_to_complete = 0;\n\n\t \n\tif (adapter->hw.phy.media_type == e1000_media_type_copper) {\n\t\tadapter->hw.phy.mdix = AUTO_ALL_MODES;\n\t\tadapter->hw.phy.disable_polarity_correction = 0;\n\t\tadapter->hw.phy.ms_type = e1000_ms_hw_default;\n\t}\n\n\tif (hw->phy.ops.check_reset_block && hw->phy.ops.check_reset_block(hw))\n\t\tdev_info(&pdev->dev,\n\t\t\t \"PHY reset is blocked due to SOL/IDER session.\\n\");\n\n\t \n\tnetdev->features = (NETIF_F_SG |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t    NETIF_F_TSO |\n\t\t\t    NETIF_F_TSO6 |\n\t\t\t    NETIF_F_RXHASH |\n\t\t\t    NETIF_F_RXCSUM |\n\t\t\t    NETIF_F_HW_CSUM);\n\n\t \n\tif (!(adapter->flags & FLAG_TSO_FORCE)) {\n\t\tswitch (adapter->link_speed) {\n\t\tcase SPEED_10:\n\t\tcase SPEED_100:\n\t\t\te_info(\"10/100 speed: disabling TSO\\n\");\n\t\t\tnetdev->features &= ~NETIF_F_TSO;\n\t\t\tnetdev->features &= ~NETIF_F_TSO6;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tnetdev->features |= NETIF_F_TSO;\n\t\t\tnetdev->features |= NETIF_F_TSO6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tif (hw->mac.type == e1000_pch_spt) {\n\t\t\tnetdev->features &= ~NETIF_F_TSO;\n\t\t\tnetdev->features &= ~NETIF_F_TSO6;\n\t\t}\n\t}\n\n\t \n\tnetdev->hw_features = netdev->features;\n\tnetdev->hw_features |= NETIF_F_RXFCS;\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\tnetdev->hw_features |= NETIF_F_RXALL;\n\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER)\n\t\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tnetdev->vlan_features |= (NETIF_F_SG |\n\t\t\t\t  NETIF_F_TSO |\n\t\t\t\t  NETIF_F_TSO6 |\n\t\t\t\t  NETIF_F_HW_CSUM);\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tnetdev->features |= NETIF_F_HIGHDMA;\n\tnetdev->vlan_features |= NETIF_F_HIGHDMA;\n\n\t \n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = adapter->max_hw_frame_size -\n\t\t\t  (VLAN_ETH_HLEN + ETH_FCS_LEN);\n\n\tif (e1000e_enable_mng_pass_thru(&adapter->hw))\n\t\tadapter->flags |= FLAG_MNG_PT_ENABLED;\n\n\t \n\tadapter->hw.mac.ops.reset_hw(&adapter->hw);\n\n\t \n\tfor (i = 0;; i++) {\n\t\tif (e1000_validate_nvm_checksum(&adapter->hw) >= 0)\n\t\t\tbreak;\n\t\tif (i == 2) {\n\t\t\tdev_err(&pdev->dev, \"The NVM Checksum Is Not Valid\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_eeprom;\n\t\t}\n\t}\n\n\te1000_eeprom_checks(adapter);\n\n\t \n\tif (e1000e_read_mac_addr(&adapter->hw))\n\t\tdev_err(&pdev->dev,\n\t\t\t\"NVM Read Error while reading MAC address\\n\");\n\n\teth_hw_addr_set(netdev, adapter->hw.mac.addr);\n\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\tdev_err(&pdev->dev, \"Invalid MAC Address: %pM\\n\",\n\t\t\tnetdev->dev_addr);\n\t\terr = -EIO;\n\t\tgoto err_eeprom;\n\t}\n\n\ttimer_setup(&adapter->watchdog_timer, e1000_watchdog, 0);\n\ttimer_setup(&adapter->phy_info_timer, e1000_update_phy_info, 0);\n\n\tINIT_WORK(&adapter->reset_task, e1000_reset_task);\n\tINIT_WORK(&adapter->watchdog_task, e1000_watchdog_task);\n\tINIT_WORK(&adapter->downshift_task, e1000e_downshift_workaround);\n\tINIT_WORK(&adapter->update_phy_task, e1000e_update_phy_task);\n\tINIT_WORK(&adapter->print_hang_task, e1000_print_hw_hang);\n\n\t \n\tadapter->hw.mac.autoneg = 1;\n\tadapter->fc_autoneg = true;\n\tadapter->hw.fc.requested_mode = e1000_fc_default;\n\tadapter->hw.fc.current_mode = e1000_fc_default;\n\tadapter->hw.phy.autoneg_advertised = 0x2f;\n\n\t \n\tif (adapter->flags & FLAG_APME_IN_WUC) {\n\t\t \n\t\teeprom_data = er32(WUC);\n\t\teeprom_apme_mask = E1000_WUC_APME;\n\t\tif ((hw->mac.type > e1000_ich10lan) &&\n\t\t    (eeprom_data & E1000_WUC_PHY_WAKE))\n\t\t\tadapter->flags2 |= FLAG2_HAS_PHY_WAKEUP;\n\t} else if (adapter->flags & FLAG_APME_IN_CTRL3) {\n\t\tif (adapter->flags & FLAG_APME_CHECK_PORT_B &&\n\t\t    (adapter->hw.bus.func == 1))\n\t\t\tret_val = e1000_read_nvm(&adapter->hw,\n\t\t\t\t\t      NVM_INIT_CONTROL3_PORT_B,\n\t\t\t\t\t      1, &eeprom_data);\n\t\telse\n\t\t\tret_val = e1000_read_nvm(&adapter->hw,\n\t\t\t\t\t      NVM_INIT_CONTROL3_PORT_A,\n\t\t\t\t\t      1, &eeprom_data);\n\t}\n\n\t \n\tif (ret_val)\n\t\te_dbg(\"NVM read error getting WoL initial values: %d\\n\", ret_val);\n\telse if (eeprom_data & eeprom_apme_mask)\n\t\tadapter->eeprom_wol |= E1000_WUFC_MAG;\n\n\t \n\tif (!(adapter->flags & FLAG_HAS_WOL))\n\t\tadapter->eeprom_wol = 0;\n\n\t \n\tadapter->wol = adapter->eeprom_wol;\n\n\t \n\tif (adapter->wol || (adapter->flags & FLAG_MNG_PT_ENABLED) ||\n\t    (hw->mac.ops.check_mng_mode(hw)))\n\t\tdevice_wakeup_enable(&pdev->dev);\n\n\t \n\tret_val = e1000_read_nvm(&adapter->hw, 5, 1, &adapter->eeprom_vers);\n\n\tif (ret_val) {\n\t\te_dbg(\"NVM read error getting EEPROM version: %d\\n\", ret_val);\n\t\tadapter->eeprom_vers = 0;\n\t}\n\n\t \n\te1000e_ptp_init(adapter);\n\n\t \n\te1000e_reset(adapter);\n\n\t \n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_get_hw_control(adapter);\n\n\tif (hw->mac.type >= e1000_pch_cnp)\n\t\tadapter->flags2 |= FLAG2_ENABLE_S0IX_FLOWS;\n\n\tstrscpy(netdev->name, \"eth%d\", sizeof(netdev->name));\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\t \n\tnetif_carrier_off(netdev);\n\n\te1000_print_device_info(adapter);\n\n\tdev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_SMART_PREPARE);\n\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n\nerr_register:\n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_release_hw_control(adapter);\nerr_eeprom:\n\tif (hw->phy.ops.check_reset_block && !hw->phy.ops.check_reset_block(hw))\n\t\te1000_phy_hw_reset(&adapter->hw);\nerr_hw_init:\n\tkfree(adapter->tx_ring);\n\tkfree(adapter->rx_ring);\nerr_sw_init:\n\tif ((adapter->hw.flash_address) && (hw->mac.type < e1000_pch_spt))\n\t\tiounmap(adapter->hw.flash_address);\n\te1000e_reset_interrupt_capability(adapter);\nerr_flashmap:\n\tiounmap(adapter->hw.hw_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tpci_release_mem_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void e1000_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\te1000e_ptp_remove(adapter);\n\n\t \n\tset_bit(__E1000_DOWN, &adapter->state);\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_info_timer);\n\n\tcancel_work_sync(&adapter->reset_task);\n\tcancel_work_sync(&adapter->watchdog_task);\n\tcancel_work_sync(&adapter->downshift_task);\n\tcancel_work_sync(&adapter->update_phy_task);\n\tcancel_work_sync(&adapter->print_hang_task);\n\n\tif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\n\t\tcancel_work_sync(&adapter->tx_hwtstamp_work);\n\t\tif (adapter->tx_hwtstamp_skb) {\n\t\t\tdev_consume_skb_any(adapter->tx_hwtstamp_skb);\n\t\t\tadapter->tx_hwtstamp_skb = NULL;\n\t\t}\n\t}\n\n\tunregister_netdev(netdev);\n\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\t \n\te1000e_release_hw_control(adapter);\n\n\te1000e_reset_interrupt_capability(adapter);\n\tkfree(adapter->tx_ring);\n\tkfree(adapter->rx_ring);\n\n\tiounmap(adapter->hw.hw_addr);\n\tif ((adapter->hw.flash_address) &&\n\t    (adapter->hw.mac.type < e1000_pch_spt))\n\t\tiounmap(adapter->hw.flash_address);\n\tpci_release_mem_regions(pdev);\n\n\tfree_netdev(netdev);\n\n\tpci_disable_device(pdev);\n}\n\n \nstatic const struct pci_error_handlers e1000_err_handler = {\n\t.error_detected = e1000_io_error_detected,\n\t.slot_reset = e1000_io_slot_reset,\n\t.resume = e1000_io_resume,\n};\n\nstatic const struct pci_device_id e1000_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_COPPER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_FIBER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_COPPER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_COPPER_LP),\n\t  board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_FIBER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES_DUAL), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES_QUAD), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571PT_QUAD_COPPER), board_82571 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI), board_82572 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_COPPER), board_82572 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_FIBER), board_82572 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_SERDES), board_82572 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82573E), board_82573 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82573E_IAMT), board_82573 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82573L), board_82573 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82574L), board_82574 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82574LA), board_82574 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82583V), board_82583 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_COPPER_DPT),\n\t  board_80003es2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_COPPER_SPT),\n\t  board_80003es2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_SERDES_DPT),\n\t  board_80003es2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_SERDES_SPT),\n\t  board_80003es2lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE_G), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE_GT), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_AMT), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_C), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_M), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_M_AMT), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_82567V_3), board_ich8lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE_G), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE_GT), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_AMT), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_C), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_BM), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M_AMT), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M_V), board_ich9lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_LM), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_LF), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_V), board_ich9lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_LM), board_ich10lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_LF), board_ich10lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_V), board_ich10lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_M_HV_LM), board_pchlan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_M_HV_LC), board_pchlan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_D_HV_DM), board_pchlan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_D_HV_DC), board_pchlan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH2_LV_LM), board_pch2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH2_LV_V), board_pch2lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPT_I217_LM), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPT_I217_V), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPTLP_I218_LM), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPTLP_I218_V), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_LM2), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_V2), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_LM3), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_V3), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM2), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V2), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LBG_I219_LM3), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM4), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V4), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM5), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V5), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_LM6), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_V6), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_LM7), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_V7), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_LM8), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_V8), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_LM9), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_V9), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_LM10), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_V10), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_LM11), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_V11), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_LM12), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_V12), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_LM13), board_pch_tgp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_V13), board_pch_tgp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_LM14), board_pch_tgp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_V14), board_pch_tgp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_LM15), board_pch_tgp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_V15), board_pch_tgp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_RPL_I219_LM23), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_RPL_I219_V23), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_LM16), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_V16), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_LM17), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_V17), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_RPL_I219_LM22), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_RPL_I219_V22), board_pch_adp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_LM18), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_V18), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_LM19), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_V19), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LNP_I219_LM20), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LNP_I219_V20), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LNP_I219_LM21), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LNP_I219_V21), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ARL_I219_LM24), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ARL_I219_V24), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_PTP_I219_LM25), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_PTP_I219_V25), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_PTP_I219_LM26), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_PTP_I219_V26), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_PTP_I219_LM27), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_PTP_I219_V27), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_NVL_I219_LM29), board_pch_mtp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_NVL_I219_V29), board_pch_mtp },\n\n\t{ 0, 0, 0, 0, 0, 0, 0 }\t \n};\nMODULE_DEVICE_TABLE(pci, e1000_pci_tbl);\n\nstatic const struct dev_pm_ops e1000_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.prepare\t= e1000e_pm_prepare,\n\t.suspend\t= e1000e_pm_suspend,\n\t.resume\t\t= e1000e_pm_resume,\n\t.freeze\t\t= e1000e_pm_freeze,\n\t.thaw\t\t= e1000e_pm_thaw,\n\t.poweroff\t= e1000e_pm_suspend,\n\t.restore\t= e1000e_pm_resume,\n#endif\n\tSET_RUNTIME_PM_OPS(e1000e_pm_runtime_suspend, e1000e_pm_runtime_resume,\n\t\t\t   e1000e_pm_runtime_idle)\n};\n\n \nstatic struct pci_driver e1000_driver = {\n\t.name     = e1000e_driver_name,\n\t.id_table = e1000_pci_tbl,\n\t.probe    = e1000_probe,\n\t.remove   = e1000_remove,\n\t.driver   = {\n\t\t.pm = &e1000_pm_ops,\n\t},\n\t.shutdown = e1000_shutdown,\n\t.err_handler = &e1000_err_handler\n};\n\n \nstatic int __init e1000_init_module(void)\n{\n\tpr_info(\"Intel(R) PRO/1000 Network Driver\\n\");\n\tpr_info(\"Copyright(c) 1999 - 2015 Intel Corporation.\\n\");\n\n\treturn pci_register_driver(&e1000_driver);\n}\nmodule_init(e1000_init_module);\n\n \nstatic void __exit e1000_exit_module(void)\n{\n\tpci_unregister_driver(&e1000_driver);\n}\nmodule_exit(e1000_exit_module);\n\nMODULE_AUTHOR(\"Intel Corporation, <linux.nics@intel.com>\");\nMODULE_DESCRIPTION(\"Intel(R) PRO/1000 Network Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}