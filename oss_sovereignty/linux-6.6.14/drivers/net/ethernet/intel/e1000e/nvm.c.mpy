{
  "module_name": "nvm.c",
  "hash_id": "fb31537bf822dfc8cca3330a7bfac92ffa5f5d9d7a659aea500a84aa0454b2fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/nvm.c",
  "human_readable_source": "\n \n\n#include \"e1000.h\"\n\n \nstatic void e1000_raise_eec_clk(struct e1000_hw *hw, u32 *eecd)\n{\n\t*eecd = *eecd | E1000_EECD_SK;\n\tew32(EECD, *eecd);\n\te1e_flush();\n\tudelay(hw->nvm.delay_usec);\n}\n\n \nstatic void e1000_lower_eec_clk(struct e1000_hw *hw, u32 *eecd)\n{\n\t*eecd = *eecd & ~E1000_EECD_SK;\n\tew32(EECD, *eecd);\n\te1e_flush();\n\tudelay(hw->nvm.delay_usec);\n}\n\n \nstatic void e1000_shift_out_eec_bits(struct e1000_hw *hw, u16 data, u16 count)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = er32(EECD);\n\tu32 mask;\n\n\tmask = BIT(count - 1);\n\tif (nvm->type == e1000_nvm_eeprom_spi)\n\t\teecd |= E1000_EECD_DO;\n\n\tdo {\n\t\teecd &= ~E1000_EECD_DI;\n\n\t\tif (data & mask)\n\t\t\teecd |= E1000_EECD_DI;\n\n\t\tew32(EECD, eecd);\n\t\te1e_flush();\n\n\t\tudelay(nvm->delay_usec);\n\n\t\te1000_raise_eec_clk(hw, &eecd);\n\t\te1000_lower_eec_clk(hw, &eecd);\n\n\t\tmask >>= 1;\n\t} while (mask);\n\n\teecd &= ~E1000_EECD_DI;\n\tew32(EECD, eecd);\n}\n\n \nstatic u16 e1000_shift_in_eec_bits(struct e1000_hw *hw, u16 count)\n{\n\tu32 eecd;\n\tu32 i;\n\tu16 data;\n\n\teecd = er32(EECD);\n\teecd &= ~(E1000_EECD_DO | E1000_EECD_DI);\n\tdata = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdata <<= 1;\n\t\te1000_raise_eec_clk(hw, &eecd);\n\n\t\teecd = er32(EECD);\n\n\t\teecd &= ~E1000_EECD_DI;\n\t\tif (eecd & E1000_EECD_DO)\n\t\t\tdata |= 1;\n\n\t\te1000_lower_eec_clk(hw, &eecd);\n\t}\n\n\treturn data;\n}\n\n \ns32 e1000e_poll_eerd_eewr_done(struct e1000_hw *hw, int ee_reg)\n{\n\tu32 attempts = 100000;\n\tu32 i, reg = 0;\n\n\tfor (i = 0; i < attempts; i++) {\n\t\tif (ee_reg == E1000_NVM_POLL_READ)\n\t\t\treg = er32(EERD);\n\t\telse\n\t\t\treg = er32(EEWR);\n\n\t\tif (reg & E1000_NVM_RW_REG_DONE)\n\t\t\treturn 0;\n\n\t\tudelay(5);\n\t}\n\n\treturn -E1000_ERR_NVM;\n}\n\n \ns32 e1000e_acquire_nvm(struct e1000_hw *hw)\n{\n\tu32 eecd = er32(EECD);\n\ts32 timeout = E1000_NVM_GRANT_ATTEMPTS;\n\n\tew32(EECD, eecd | E1000_EECD_REQ);\n\teecd = er32(EECD);\n\n\twhile (timeout) {\n\t\tif (eecd & E1000_EECD_GNT)\n\t\t\tbreak;\n\t\tudelay(5);\n\t\teecd = er32(EECD);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\teecd &= ~E1000_EECD_REQ;\n\t\tew32(EECD, eecd);\n\t\te_dbg(\"Could not acquire NVM grant\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void e1000_standby_nvm(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = er32(EECD);\n\n\tif (nvm->type == e1000_nvm_eeprom_spi) {\n\t\t \n\t\teecd |= E1000_EECD_CS;\n\t\tew32(EECD, eecd);\n\t\te1e_flush();\n\t\tudelay(nvm->delay_usec);\n\t\teecd &= ~E1000_EECD_CS;\n\t\tew32(EECD, eecd);\n\t\te1e_flush();\n\t\tudelay(nvm->delay_usec);\n\t}\n}\n\n \nstatic void e1000_stop_nvm(struct e1000_hw *hw)\n{\n\tu32 eecd;\n\n\teecd = er32(EECD);\n\tif (hw->nvm.type == e1000_nvm_eeprom_spi) {\n\t\t \n\t\teecd |= E1000_EECD_CS;\n\t\te1000_lower_eec_clk(hw, &eecd);\n\t}\n}\n\n \nvoid e1000e_release_nvm(struct e1000_hw *hw)\n{\n\tu32 eecd;\n\n\te1000_stop_nvm(hw);\n\n\teecd = er32(EECD);\n\teecd &= ~E1000_EECD_REQ;\n\tew32(EECD, eecd);\n}\n\n \nstatic s32 e1000_ready_nvm_eeprom(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = er32(EECD);\n\tu8 spi_stat_reg;\n\n\tif (nvm->type == e1000_nvm_eeprom_spi) {\n\t\tu16 timeout = NVM_MAX_RETRY_SPI;\n\n\t\t \n\t\teecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\n\t\tew32(EECD, eecd);\n\t\te1e_flush();\n\t\tudelay(1);\n\n\t\t \n\t\twhile (timeout) {\n\t\t\te1000_shift_out_eec_bits(hw, NVM_RDSR_OPCODE_SPI,\n\t\t\t\t\t\t hw->nvm.opcode_bits);\n\t\t\tspi_stat_reg = (u8)e1000_shift_in_eec_bits(hw, 8);\n\t\t\tif (!(spi_stat_reg & NVM_STATUS_RDY_SPI))\n\t\t\t\tbreak;\n\n\t\t\tudelay(5);\n\t\t\te1000_standby_nvm(hw);\n\t\t\ttimeout--;\n\t\t}\n\n\t\tif (!timeout) {\n\t\t\te_dbg(\"SPI NVM Status error\\n\");\n\t\t\treturn -E1000_ERR_NVM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_read_nvm_eerd(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 i, eerd = 0;\n\ts32 ret_val = 0;\n\n\t \n\tif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\n\t    (words == 0)) {\n\t\te_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\teerd = ((offset + i) << E1000_NVM_RW_ADDR_SHIFT) +\n\t\t    E1000_NVM_RW_REG_START;\n\n\t\tew32(EERD, eerd);\n\t\tret_val = e1000e_poll_eerd_eewr_done(hw, E1000_NVM_POLL_READ);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"NVM read error: %d\\n\", ret_val);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata[i] = (er32(EERD) >> E1000_NVM_RW_REG_DATA);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000e_write_nvm_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\ts32 ret_val = -E1000_ERR_NVM;\n\tu16 widx = 0;\n\n\t \n\tif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\n\t    (words == 0)) {\n\t\te_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\twhile (widx < words) {\n\t\tu8 write_opcode = NVM_WRITE_OPCODE_SPI;\n\n\t\tret_val = nvm->ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1000_ready_nvm_eeprom(hw);\n\t\tif (ret_val) {\n\t\t\tnvm->ops.release(hw);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\te1000_standby_nvm(hw);\n\n\t\t \n\t\te1000_shift_out_eec_bits(hw, NVM_WREN_OPCODE_SPI,\n\t\t\t\t\t nvm->opcode_bits);\n\n\t\te1000_standby_nvm(hw);\n\n\t\t \n\t\tif ((nvm->address_bits == 8) && (offset >= 128))\n\t\t\twrite_opcode |= NVM_A8_OPCODE_SPI;\n\n\t\t \n\t\te1000_shift_out_eec_bits(hw, write_opcode, nvm->opcode_bits);\n\t\te1000_shift_out_eec_bits(hw, (u16)((offset + widx) * 2),\n\t\t\t\t\t nvm->address_bits);\n\n\t\t \n\t\twhile (widx < words) {\n\t\t\tu16 word_out = data[widx];\n\n\t\t\tword_out = (word_out >> 8) | (word_out << 8);\n\t\t\te1000_shift_out_eec_bits(hw, word_out, 16);\n\t\t\twidx++;\n\n\t\t\tif ((((offset + widx) * 2) % nvm->page_size) == 0) {\n\t\t\t\te1000_standby_nvm(hw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tusleep_range(10000, 11000);\n\t\tnvm->ops.release(hw);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 e1000_read_pba_string_generic(struct e1000_hw *hw, u8 *pba_num,\n\t\t\t\t  u32 pba_num_size)\n{\n\ts32 ret_val;\n\tu16 nvm_data;\n\tu16 pba_ptr;\n\tu16 offset;\n\tu16 length;\n\n\tif (pba_num == NULL) {\n\t\te_dbg(\"PBA string buffer was null\\n\");\n\t\treturn -E1000_ERR_INVALID_ARGUMENT;\n\t}\n\n\tret_val = e1000_read_nvm(hw, NVM_PBA_OFFSET_0, 1, &nvm_data);\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tret_val = e1000_read_nvm(hw, NVM_PBA_OFFSET_1, 1, &pba_ptr);\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tif (nvm_data != NVM_PBA_PTR_GUARD) {\n\t\te_dbg(\"NVM PBA number is not stored as string\\n\");\n\n\t\t \n\t\tif (pba_num_size < E1000_PBANUM_LENGTH) {\n\t\t\te_dbg(\"PBA string buffer too small\\n\");\n\t\t\treturn E1000_ERR_NO_SPACE;\n\t\t}\n\n\t\t \n\t\tpba_num[0] = (nvm_data >> 12) & 0xF;\n\t\tpba_num[1] = (nvm_data >> 8) & 0xF;\n\t\tpba_num[2] = (nvm_data >> 4) & 0xF;\n\t\tpba_num[3] = nvm_data & 0xF;\n\t\tpba_num[4] = (pba_ptr >> 12) & 0xF;\n\t\tpba_num[5] = (pba_ptr >> 8) & 0xF;\n\t\tpba_num[6] = '-';\n\t\tpba_num[7] = 0;\n\t\tpba_num[8] = (pba_ptr >> 4) & 0xF;\n\t\tpba_num[9] = pba_ptr & 0xF;\n\n\t\t \n\t\tpba_num[10] = '\\0';\n\n\t\t \n\t\tfor (offset = 0; offset < 10; offset++) {\n\t\t\tif (pba_num[offset] < 0xA)\n\t\t\t\tpba_num[offset] += '0';\n\t\t\telse if (pba_num[offset] < 0x10)\n\t\t\t\tpba_num[offset] += 'A' - 0xA;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret_val = e1000_read_nvm(hw, pba_ptr, 1, &length);\n\tif (ret_val) {\n\t\te_dbg(\"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tif (length == 0xFFFF || length == 0) {\n\t\te_dbg(\"NVM PBA number section invalid length\\n\");\n\t\treturn -E1000_ERR_NVM_PBA_SECTION;\n\t}\n\t \n\tif (pba_num_size < (((u32)length * 2) - 1)) {\n\t\te_dbg(\"PBA string buffer too small\\n\");\n\t\treturn -E1000_ERR_NO_SPACE;\n\t}\n\n\t \n\tpba_ptr++;\n\tlength--;\n\n\tfor (offset = 0; offset < length; offset++) {\n\t\tret_val = e1000_read_nvm(hw, pba_ptr + offset, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"NVM Read Error\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tpba_num[offset * 2] = (u8)(nvm_data >> 8);\n\t\tpba_num[(offset * 2) + 1] = (u8)(nvm_data & 0xFF);\n\t}\n\tpba_num[offset * 2] = '\\0';\n\n\treturn 0;\n}\n\n \ns32 e1000_read_mac_addr_generic(struct e1000_hw *hw)\n{\n\tu32 rar_high;\n\tu32 rar_low;\n\tu16 i;\n\n\trar_high = er32(RAH(0));\n\trar_low = er32(RAL(0));\n\n\tfor (i = 0; i < E1000_RAL_MAC_ADDR_LEN; i++)\n\t\thw->mac.perm_addr[i] = (u8)(rar_low >> (i * 8));\n\n\tfor (i = 0; i < E1000_RAH_MAC_ADDR_LEN; i++)\n\t\thw->mac.perm_addr[i + 4] = (u8)(rar_high >> (i * 8));\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\thw->mac.addr[i] = hw->mac.perm_addr[i];\n\n\treturn 0;\n}\n\n \ns32 e1000e_validate_nvm_checksum_generic(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\n\tfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {\n\t\tret_val = e1000_read_nvm(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"NVM Read Error\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\n\tif (checksum != (u16)NVM_SUM) {\n\t\te_dbg(\"NVM Checksum Invalid\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\treturn 0;\n}\n\n \ns32 e1000e_update_nvm_checksum_generic(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\n\tfor (i = 0; i < NVM_CHECKSUM_REG; i++) {\n\t\tret_val = e1000_read_nvm(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"NVM Read Error while updating checksum.\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\tchecksum = (u16)NVM_SUM - checksum;\n\tret_val = e1000_write_nvm(hw, NVM_CHECKSUM_REG, 1, &checksum);\n\tif (ret_val)\n\t\te_dbg(\"NVM Write Error while updating checksum.\\n\");\n\n\treturn ret_val;\n}\n\n \nvoid e1000e_reload_nvm_generic(struct e1000_hw *hw)\n{\n\tu32 ctrl_ext;\n\n\tusleep_range(10, 20);\n\tctrl_ext = er32(CTRL_EXT);\n\tctrl_ext |= E1000_CTRL_EXT_EE_RST;\n\tew32(CTRL_EXT, ctrl_ext);\n\te1e_flush();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}