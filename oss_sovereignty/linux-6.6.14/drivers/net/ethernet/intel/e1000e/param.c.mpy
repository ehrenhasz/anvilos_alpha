{
  "module_name": "param.c",
  "hash_id": "1561a1e030945d9e797fc3926126fc45f2991388cfc486be49d14a43bb219ee6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/param.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"e1000.h\"\n\n \n#define E1000_MAX_NIC 32\n\n#define OPTION_UNSET   -1\n#define OPTION_DISABLED 0\n#define OPTION_ENABLED  1\n\n#define COPYBREAK_DEFAULT 256\nunsigned int copybreak = COPYBREAK_DEFAULT;\nmodule_param(copybreak, uint, 0644);\nMODULE_PARM_DESC(copybreak,\n\t\t \"Maximum size of packet that is copied to a new buffer on receive\");\n\n \n#define E1000_PARAM_INIT { [0 ... E1000_MAX_NIC] = OPTION_UNSET }\n#define E1000_PARAM(X, desc)\t\t\t\t\t\\\n\tstatic int X[E1000_MAX_NIC+1] = E1000_PARAM_INIT;\t\\\n\tstatic unsigned int num_##X;\t\t\t\t\\\n\tmodule_param_array_named(X, X, int, &num_##X, 0);\t\\\n\tMODULE_PARM_DESC(X, desc);\n\n \nE1000_PARAM(TxIntDelay, \"Transmit Interrupt Delay\");\n#define DEFAULT_TIDV 8\n#define MAX_TXDELAY 0xFFFF\n#define MIN_TXDELAY 0\n\n \nE1000_PARAM(TxAbsIntDelay, \"Transmit Absolute Interrupt Delay\");\n#define DEFAULT_TADV 32\n#define MAX_TXABSDELAY 0xFFFF\n#define MIN_TXABSDELAY 0\n\n \nE1000_PARAM(RxIntDelay, \"Receive Interrupt Delay\");\n#define DEFAULT_RDTR\t0\n#define BURST_RDTR\t0x20\n#define MAX_RXDELAY 0xFFFF\n#define MIN_RXDELAY 0\n\n \nE1000_PARAM(RxAbsIntDelay, \"Receive Absolute Interrupt Delay\");\n#define DEFAULT_RADV\t8\n#define BURST_RADV\t0x20\n#define MAX_RXABSDELAY 0xFFFF\n#define MIN_RXABSDELAY 0\n\n \nE1000_PARAM(InterruptThrottleRate, \"Interrupt Throttling Rate\");\n#define DEFAULT_ITR 3\n#define MAX_ITR 100000\n#define MIN_ITR 100\n\n \nE1000_PARAM(IntMode, \"Interrupt Mode\");\n\n \nE1000_PARAM(SmartPowerDownEnable, \"Enable PHY smart power down\");\n\n \nE1000_PARAM(KumeranLockLoss, \"Enable Kumeran lock loss workaround\");\n\n \nE1000_PARAM(WriteProtectNVM,\n\t    \"Write-protect NVM [WARNING: disabling this can lead to corrupted NVM]\");\n\n \nE1000_PARAM(CrcStripping,\n\t    \"Enable CRC Stripping, disable if your BMC needs the CRC\");\n\nstruct e1000_option {\n\tenum { enable_option, range_option, list_option } type;\n\tconst char *name;\n\tconst char *err;\n\tint def;\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tint min;\n\t\t\tint max;\n\t\t} r;\n\t\t \n\t\tstruct {\n\t\t\tint nr;\n\t\t\tstruct e1000_opt_list {\n\t\t\t\tint i;\n\t\t\t\tchar *str;\n\t\t\t} *p;\n\t\t} l;\n\t} arg;\n};\n\nstatic int e1000_validate_option(unsigned int *value,\n\t\t\t\t const struct e1000_option *opt,\n\t\t\t\t struct e1000_adapter *adapter)\n{\n\tif (*value == OPTION_UNSET) {\n\t\t*value = opt->def;\n\t\treturn 0;\n\t}\n\n\tswitch (opt->type) {\n\tcase enable_option:\n\t\tswitch (*value) {\n\t\tcase OPTION_ENABLED:\n\t\t\tdev_info(&adapter->pdev->dev, \"%s Enabled\\n\",\n\t\t\t\t opt->name);\n\t\t\treturn 0;\n\t\tcase OPTION_DISABLED:\n\t\t\tdev_info(&adapter->pdev->dev, \"%s Disabled\\n\",\n\t\t\t\t opt->name);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase range_option:\n\t\tif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\n\t\t\tdev_info(&adapter->pdev->dev, \"%s set to %i\\n\",\n\t\t\t\t opt->name, *value);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase list_option: {\n\t\tint i;\n\t\tstruct e1000_opt_list *ent;\n\n\t\tfor (i = 0; i < opt->arg.l.nr; i++) {\n\t\t\tent = &opt->arg.l.p[i];\n\t\t\tif (*value == ent->i) {\n\t\t\t\tif (ent->str[0] != '\\0')\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"%s\\n\",\n\t\t\t\t\t\t ent->str);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tdev_info(&adapter->pdev->dev, \"Invalid %s value specified (%i) %s\\n\",\n\t\t opt->name, *value, opt->err);\n\t*value = opt->def;\n\treturn -1;\n}\n\n \nvoid e1000e_check_options(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint bd = adapter->bd_number;\n\n\tif (bd >= E1000_MAX_NIC) {\n\t\tdev_notice(&adapter->pdev->dev,\n\t\t\t   \"Warning: no configuration for board #%i\\n\", bd);\n\t\tdev_notice(&adapter->pdev->dev,\n\t\t\t   \"Using defaults for all values\\n\");\n\t}\n\n\t \n\t{\n\t\tstatic const struct e1000_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Transmit Interrupt Delay\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(DEFAULT_TIDV),\n\t\t\t.def  = DEFAULT_TIDV,\n\t\t\t.arg  = { .r = { .min = MIN_TXDELAY,\n\t\t\t\t\t .max = MAX_TXDELAY } }\n\t\t};\n\n\t\tif (num_TxIntDelay > bd) {\n\t\t\tadapter->tx_int_delay = TxIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->tx_int_delay, &opt,\n\t\t\t\t\t      adapter);\n\t\t} else {\n\t\t\tadapter->tx_int_delay = opt.def;\n\t\t}\n\t}\n\t \n\t{\n\t\tstatic const struct e1000_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Transmit Absolute Interrupt Delay\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(DEFAULT_TADV),\n\t\t\t.def  = DEFAULT_TADV,\n\t\t\t.arg  = { .r = { .min = MIN_TXABSDELAY,\n\t\t\t\t\t .max = MAX_TXABSDELAY } }\n\t\t};\n\n\t\tif (num_TxAbsIntDelay > bd) {\n\t\t\tadapter->tx_abs_int_delay = TxAbsIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->tx_abs_int_delay, &opt,\n\t\t\t\t\t      adapter);\n\t\t} else {\n\t\t\tadapter->tx_abs_int_delay = opt.def;\n\t\t}\n\t}\n\t \n\t{\n\t\tstatic struct e1000_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Receive Interrupt Delay\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(DEFAULT_RDTR),\n\t\t\t.def  = DEFAULT_RDTR,\n\t\t\t.arg  = { .r = { .min = MIN_RXDELAY,\n\t\t\t\t\t .max = MAX_RXDELAY } }\n\t\t};\n\n\t\tif (adapter->flags2 & FLAG2_DMA_BURST)\n\t\t\topt.def = BURST_RDTR;\n\n\t\tif (num_RxIntDelay > bd) {\n\t\t\tadapter->rx_int_delay = RxIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->rx_int_delay, &opt,\n\t\t\t\t\t      adapter);\n\t\t} else {\n\t\t\tadapter->rx_int_delay = opt.def;\n\t\t}\n\t}\n\t \n\t{\n\t\tstatic struct e1000_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Receive Absolute Interrupt Delay\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(DEFAULT_RADV),\n\t\t\t.def  = DEFAULT_RADV,\n\t\t\t.arg  = { .r = { .min = MIN_RXABSDELAY,\n\t\t\t\t\t .max = MAX_RXABSDELAY } }\n\t\t};\n\n\t\tif (adapter->flags2 & FLAG2_DMA_BURST)\n\t\t\topt.def = BURST_RADV;\n\n\t\tif (num_RxAbsIntDelay > bd) {\n\t\t\tadapter->rx_abs_int_delay = RxAbsIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->rx_abs_int_delay, &opt,\n\t\t\t\t\t      adapter);\n\t\t} else {\n\t\t\tadapter->rx_abs_int_delay = opt.def;\n\t\t}\n\t}\n\t \n\t{\n\t\tstatic const struct e1000_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Interrupt Throttling Rate (ints/sec)\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(DEFAULT_ITR),\n\t\t\t.def  = DEFAULT_ITR,\n\t\t\t.arg  = { .r = { .min = MIN_ITR,\n\t\t\t\t\t .max = MAX_ITR } }\n\t\t};\n\n\t\tif (num_InterruptThrottleRate > bd) {\n\t\t\tadapter->itr = InterruptThrottleRate[bd];\n\n\t\t\t \n\t\t\tif ((adapter->itr > 4) &&\n\t\t\t    e1000_validate_option(&adapter->itr, &opt, adapter))\n\t\t\t\tadapter->itr = opt.def;\n\t\t} else {\n\t\t\t \n\t\t\tadapter->itr = opt.def;\n\n\t\t\t \n\t\t\tif (adapter->itr > 4)\n\t\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\t \"%s set to default %d\\n\", opt.name,\n\t\t\t\t\t adapter->itr);\n\t\t}\n\n\t\tadapter->itr_setting = adapter->itr;\n\t\tswitch (adapter->itr) {\n\t\tcase 0:\n\t\t\tdev_info(&adapter->pdev->dev, \"%s turned off\\n\",\n\t\t\t\t opt.name);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s set to dynamic mode\\n\", opt.name);\n\t\t\tadapter->itr = 20000;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s Invalid mode - setting default\\n\",\n\t\t\t\t opt.name);\n\t\t\tadapter->itr_setting = opt.def;\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s set to dynamic conservative mode\\n\",\n\t\t\t\t opt.name);\n\t\t\tadapter->itr = 20000;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s set to simplified (2000-8000 ints) mode\\n\",\n\t\t\t\t opt.name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tadapter->itr_setting &= ~3;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\t{\n\t\tstatic struct e1000_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Interrupt Mode\",\n#ifndef CONFIG_PCI_MSI\n\t\t\t.err  = \"defaulting to 0 (legacy)\",\n\t\t\t.def  = E1000E_INT_MODE_LEGACY,\n\t\t\t.arg  = { .r = { .min = 0,\n\t\t\t\t\t .max = 0 } }\n#endif\n\t\t};\n\n#ifdef CONFIG_PCI_MSI\n\t\tif (adapter->flags & FLAG_HAS_MSIX) {\n\t\t\topt.err = kstrdup(\"defaulting to 2 (MSI-X)\",\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\topt.def = E1000E_INT_MODE_MSIX;\n\t\t\topt.arg.r.max = E1000E_INT_MODE_MSIX;\n\t\t} else {\n\t\t\topt.err = kstrdup(\"defaulting to 1 (MSI)\", GFP_KERNEL);\n\t\t\topt.def = E1000E_INT_MODE_MSI;\n\t\t\topt.arg.r.max = E1000E_INT_MODE_MSI;\n\t\t}\n\n\t\tif (!opt.err) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to allocate memory\\n\");\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (num_IntMode > bd) {\n\t\t\tunsigned int int_mode = IntMode[bd];\n\n\t\t\te1000_validate_option(&int_mode, &opt, adapter);\n\t\t\tadapter->int_mode = int_mode;\n\t\t} else {\n\t\t\tadapter->int_mode = opt.def;\n\t\t}\n\n#ifdef CONFIG_PCI_MSI\n\t\tkfree(opt.err);\n#endif\n\t}\n\t \n\t{\n\t\tstatic const struct e1000_option opt = {\n\t\t\t.type = enable_option,\n\t\t\t.name = \"PHY Smart Power Down\",\n\t\t\t.err  = \"defaulting to Disabled\",\n\t\t\t.def  = OPTION_DISABLED\n\t\t};\n\n\t\tif (num_SmartPowerDownEnable > bd) {\n\t\t\tunsigned int spd = SmartPowerDownEnable[bd];\n\n\t\t\te1000_validate_option(&spd, &opt, adapter);\n\t\t\tif ((adapter->flags & FLAG_HAS_SMART_POWER_DOWN) && spd)\n\t\t\t\tadapter->flags |= FLAG_SMART_POWER_DOWN;\n\t\t}\n\t}\n\t \n\t{\n\t\tstatic const struct e1000_option opt = {\n\t\t\t.type = enable_option,\n\t\t\t.name = \"CRC Stripping\",\n\t\t\t.err  = \"defaulting to Enabled\",\n\t\t\t.def  = OPTION_ENABLED\n\t\t};\n\n\t\tif (num_CrcStripping > bd) {\n\t\t\tunsigned int crc_stripping = CrcStripping[bd];\n\n\t\t\te1000_validate_option(&crc_stripping, &opt, adapter);\n\t\t\tif (crc_stripping == OPTION_ENABLED) {\n\t\t\t\tadapter->flags2 |= FLAG2_CRC_STRIPPING;\n\t\t\t\tadapter->flags2 |= FLAG2_DFLT_CRC_STRIPPING;\n\t\t\t}\n\t\t} else {\n\t\t\tadapter->flags2 |= FLAG2_CRC_STRIPPING;\n\t\t\tadapter->flags2 |= FLAG2_DFLT_CRC_STRIPPING;\n\t\t}\n\t}\n\t \n\t{\n\t\tstatic const struct e1000_option opt = {\n\t\t\t.type = enable_option,\n\t\t\t.name = \"Kumeran Lock Loss Workaround\",\n\t\t\t.err  = \"defaulting to Enabled\",\n\t\t\t.def  = OPTION_ENABLED\n\t\t};\n\t\tbool enabled = opt.def;\n\n\t\tif (num_KumeranLockLoss > bd) {\n\t\t\tunsigned int kmrn_lock_loss = KumeranLockLoss[bd];\n\n\t\t\te1000_validate_option(&kmrn_lock_loss, &opt, adapter);\n\t\t\tenabled = kmrn_lock_loss;\n\t\t}\n\n\t\tif (hw->mac.type == e1000_ich8lan)\n\t\t\te1000e_set_kmrn_lock_loss_workaround_ich8lan(hw,\n\t\t\t\t\t\t\t\t     enabled);\n\t}\n\t \n\t{\n\t\tstatic const struct e1000_option opt = {\n\t\t\t.type = enable_option,\n\t\t\t.name = \"Write-protect NVM\",\n\t\t\t.err  = \"defaulting to Enabled\",\n\t\t\t.def  = OPTION_ENABLED\n\t\t};\n\n\t\tif (adapter->flags & FLAG_IS_ICH) {\n\t\t\tif (num_WriteProtectNVM > bd) {\n\t\t\t\tunsigned int write_protect_nvm =\n\t\t\t\t    WriteProtectNVM[bd];\n\t\t\t\te1000_validate_option(&write_protect_nvm, &opt,\n\t\t\t\t\t\t      adapter);\n\t\t\t\tif (write_protect_nvm)\n\t\t\t\t\tadapter->flags |= FLAG_READ_ONLY_NVM;\n\t\t\t} else {\n\t\t\t\tif (opt.def)\n\t\t\t\t\tadapter->flags |= FLAG_READ_ONLY_NVM;\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}