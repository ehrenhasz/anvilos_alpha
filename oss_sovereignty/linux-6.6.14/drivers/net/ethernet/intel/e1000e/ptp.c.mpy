{
  "module_name": "ptp.c",
  "hash_id": "197e50e6d80632ac7f68a21e9a7a308d16efbe7676112144f99682ef7f456853",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000e/ptp.c",
  "human_readable_source": "\n \n\n \n\n#include \"e1000.h\"\n\n#ifdef CONFIG_E1000E_HWTS\n#include <linux/clocksource.h>\n#include <linux/ktime.h>\n#include <asm/tsc.h>\n#endif\n\n \nstatic int e1000e_phc_adjfine(struct ptp_clock_info *ptp, long delta)\n{\n\tstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tu64 incvalue;\n\tu32 timinca;\n\ts32 ret_val;\n\n\t \n\tret_val = e1000e_get_base_timinca(adapter, &timinca);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\n\tincvalue = timinca & E1000_TIMINCA_INCVALUE_MASK;\n\tincvalue = adjust_by_scaled_ppm(incvalue, delta);\n\n\ttiminca &= ~E1000_TIMINCA_INCVALUE_MASK;\n\ttiminca |= incvalue;\n\n\tew32(TIMINCA, timinca);\n\n\tadapter->ptp_delta = delta;\n\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int e1000e_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\ttimecounter_adjtime(&adapter->tc, delta);\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_E1000E_HWTS\n#define MAX_HW_WAIT_COUNT (3)\n\n \nstatic int e1000e_phc_get_syncdevicetime(ktime_t *device,\n\t\t\t\t\t struct system_counterval_t *system,\n\t\t\t\t\t void *ctx)\n{\n\tstruct e1000_adapter *adapter = (struct e1000_adapter *)ctx;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tint i;\n\tu32 tsync_ctrl;\n\tu64 dev_cycles;\n\tu64 sys_cycles;\n\n\ttsync_ctrl = er32(TSYNCTXCTL);\n\ttsync_ctrl |= E1000_TSYNCTXCTL_START_SYNC |\n\t\tE1000_TSYNCTXCTL_MAX_ALLOWED_DLY_MASK;\n\tew32(TSYNCTXCTL, tsync_ctrl);\n\tfor (i = 0; i < MAX_HW_WAIT_COUNT; ++i) {\n\t\tudelay(1);\n\t\ttsync_ctrl = er32(TSYNCTXCTL);\n\t\tif (tsync_ctrl & E1000_TSYNCTXCTL_SYNC_COMP)\n\t\t\tbreak;\n\t}\n\n\tif (i == MAX_HW_WAIT_COUNT)\n\t\treturn -ETIMEDOUT;\n\n\tdev_cycles = er32(SYSSTMPH);\n\tdev_cycles <<= 32;\n\tdev_cycles |= er32(SYSSTMPL);\n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\t*device = ns_to_ktime(timecounter_cyc2time(&adapter->tc, dev_cycles));\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\tsys_cycles = er32(PLTSTMPH);\n\tsys_cycles <<= 32;\n\tsys_cycles |= er32(PLTSTMPL);\n\t*system = convert_art_to_tsc(sys_cycles);\n\n\treturn 0;\n}\n\n \nstatic int e1000e_phc_getcrosststamp(struct ptp_clock_info *ptp,\n\t\t\t\t     struct system_device_crosststamp *xtstamp)\n{\n\tstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\n\treturn get_device_system_crosststamp(e1000e_phc_get_syncdevicetime,\n\t\t\t\t\t\tadapter, NULL, xtstamp);\n}\n#endif \n\n \nstatic int e1000e_phc_gettimex(struct ptp_clock_info *ptp,\n\t\t\t       struct timespec64 *ts,\n\t\t\t       struct ptp_system_timestamp *sts)\n{\n\tstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tunsigned long flags;\n\tu64 cycles, ns;\n\n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\n\t \n\tcycles = e1000e_read_systim(adapter, sts);\n\tns = timecounter_cyc2time(&adapter->tc, cycles);\n\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\n \nstatic int e1000e_phc_settime(struct ptp_clock_info *ptp,\n\t\t\t      const struct timespec64 *ts)\n{\n\tstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tunsigned long flags;\n\tu64 ns;\n\n\tns = timespec64_to_ns(ts);\n\n\t \n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\ttimecounter_init(&adapter->tc, &adapter->cc, ns);\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int e1000e_phc_enable(struct ptp_clock_info __always_unused *ptp,\n\t\t\t     struct ptp_clock_request __always_unused *request,\n\t\t\t     int __always_unused on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void e1000e_systim_overflow_work(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work, struct e1000_adapter,\n\t\t\t\t\t\t     systim_overflow_work.work);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct timespec64 ts;\n\tu64 ns;\n\n\t \n\tns = timecounter_read(&adapter->tc);\n\n\tts = ns_to_timespec64(ns);\n\te_dbg(\"SYSTIM overflow check at %lld.%09lu\\n\",\n\t      (long long) ts.tv_sec, ts.tv_nsec);\n\n\tschedule_delayed_work(&adapter->systim_overflow_work,\n\t\t\t      E1000_SYSTIM_OVERFLOW_PERIOD);\n}\n\nstatic const struct ptp_clock_info e1000e_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= e1000e_phc_adjfine,\n\t.adjtime\t= e1000e_phc_adjtime,\n\t.gettimex64\t= e1000e_phc_gettimex,\n\t.settime64\t= e1000e_phc_settime,\n\t.enable\t\t= e1000e_phc_enable,\n};\n\n \nvoid e1000e_ptp_init(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tadapter->ptp_clock = NULL;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\n\t\treturn;\n\n\tadapter->ptp_clock_info = e1000e_ptp_clock_info;\n\n\tsnprintf(adapter->ptp_clock_info.name,\n\t\t sizeof(adapter->ptp_clock_info.name), \"%pm\",\n\t\t adapter->netdev->perm_addr);\n\n\tswitch (hw->mac.type) {\n\tcase e1000_pch2lan:\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\tcase e1000_pch_lnp:\n\tcase e1000_pch_ptp:\n\tcase e1000_pch_nvp:\n\t\tif ((hw->mac.type < e1000_pch_lpt) ||\n\t\t    (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI)) {\n\t\t\tadapter->ptp_clock_info.max_adj = 24000000 - 1;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\tadapter->ptp_clock_info.max_adj = 600000000 - 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef CONFIG_E1000E_HWTS\n\t \n\tif (hw->mac.type >= e1000_pch_spt && boot_cpu_has(X86_FEATURE_ART))\n\t\tadapter->ptp_clock_info.getcrosststamp =\n\t\t\te1000e_phc_getcrosststamp;\n#endif \n\n\tINIT_DELAYED_WORK(&adapter->systim_overflow_work,\n\t\t\t  e1000e_systim_overflow_work);\n\n\tschedule_delayed_work(&adapter->systim_overflow_work,\n\t\t\t      E1000_SYSTIM_OVERFLOW_PERIOD);\n\n\tadapter->ptp_clock = ptp_clock_register(&adapter->ptp_clock_info,\n\t\t\t\t\t\t&adapter->pdev->dev);\n\tif (IS_ERR(adapter->ptp_clock)) {\n\t\tadapter->ptp_clock = NULL;\n\t\te_err(\"ptp_clock_register failed\\n\");\n\t} else if (adapter->ptp_clock) {\n\t\te_info(\"registered PHC clock\\n\");\n\t}\n}\n\n \nvoid e1000e_ptp_remove(struct e1000_adapter *adapter)\n{\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&adapter->systim_overflow_work);\n\n\tif (adapter->ptp_clock) {\n\t\tptp_clock_unregister(adapter->ptp_clock);\n\t\tadapter->ptp_clock = NULL;\n\t\te_info(\"removed PHC\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}