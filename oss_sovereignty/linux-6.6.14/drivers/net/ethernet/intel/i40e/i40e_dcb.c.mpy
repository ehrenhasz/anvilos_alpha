{
  "module_name": "i40e_dcb.c",
  "hash_id": "3c1036fc68db5dca281105edf9452aa94b42fde204264955e4d56a95a5cb9ca6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_dcb.c",
  "human_readable_source": "\n \n\n#include \"i40e_adminq.h\"\n#include \"i40e_prototype.h\"\n#include \"i40e_dcb.h\"\n\n \nint i40e_get_dcbx_status(struct i40e_hw *hw, u16 *status)\n{\n\tu32 reg;\n\n\tif (!status)\n\t\treturn -EINVAL;\n\n\treg = rd32(hw, I40E_PRTDCB_GENS);\n\t*status = (u16)((reg & I40E_PRTDCB_GENS_DCBX_STATUS_MASK) >>\n\t\t\tI40E_PRTDCB_GENS_DCBX_STATUS_SHIFT);\n\n\treturn 0;\n}\n\n \nstatic void i40e_parse_ieee_etscfg_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t       struct i40e_dcbx_config *dcbcfg)\n{\n\tstruct i40e_dcb_ets_config *etscfg;\n\tu8 *buf = tlv->tlvinfo;\n\tu16 offset = 0;\n\tu8 priority;\n\tint i;\n\n\t \n\tetscfg = &dcbcfg->etscfg;\n\tetscfg->willing = (u8)((buf[offset] & I40E_IEEE_ETS_WILLING_MASK) >>\n\t\t\t       I40E_IEEE_ETS_WILLING_SHIFT);\n\tetscfg->cbs = (u8)((buf[offset] & I40E_IEEE_ETS_CBS_MASK) >>\n\t\t\t   I40E_IEEE_ETS_CBS_SHIFT);\n\tetscfg->maxtcs = (u8)((buf[offset] & I40E_IEEE_ETS_MAXTC_MASK) >>\n\t\t\t      I40E_IEEE_ETS_MAXTC_SHIFT);\n\n\t \n\toffset++;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tpriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_1_MASK) >>\n\t\t\t\tI40E_IEEE_ETS_PRIO_1_SHIFT);\n\t\tetscfg->prioritytable[i * 2] =  priority;\n\t\tpriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_0_MASK) >>\n\t\t\t\tI40E_IEEE_ETS_PRIO_0_SHIFT);\n\t\tetscfg->prioritytable[i * 2 + 1] = priority;\n\t\toffset++;\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tetscfg->tcbwtable[i] = buf[offset++];\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tetscfg->tsatable[i] = buf[offset++];\n}\n\n \nstatic void i40e_parse_ieee_etsrec_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t       struct i40e_dcbx_config *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\tu16 offset = 0;\n\tu8 priority;\n\tint i;\n\n\t \n\toffset++;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tpriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_1_MASK) >>\n\t\t\t\tI40E_IEEE_ETS_PRIO_1_SHIFT);\n\t\tdcbcfg->etsrec.prioritytable[i*2] =  priority;\n\t\tpriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_0_MASK) >>\n\t\t\t\tI40E_IEEE_ETS_PRIO_0_SHIFT);\n\t\tdcbcfg->etsrec.prioritytable[i*2 + 1] = priority;\n\t\toffset++;\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tdcbcfg->etsrec.tcbwtable[i] = buf[offset++];\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tdcbcfg->etsrec.tsatable[i] = buf[offset++];\n}\n\n \nstatic void i40e_parse_ieee_pfccfg_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t       struct i40e_dcbx_config *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\n\t \n\tdcbcfg->pfc.willing = (u8)((buf[0] & I40E_IEEE_PFC_WILLING_MASK) >>\n\t\t\t\t   I40E_IEEE_PFC_WILLING_SHIFT);\n\tdcbcfg->pfc.mbc = (u8)((buf[0] & I40E_IEEE_PFC_MBC_MASK) >>\n\t\t\t       I40E_IEEE_PFC_MBC_SHIFT);\n\tdcbcfg->pfc.pfccap = (u8)((buf[0] & I40E_IEEE_PFC_CAP_MASK) >>\n\t\t\t\t  I40E_IEEE_PFC_CAP_SHIFT);\n\tdcbcfg->pfc.pfcenable = buf[1];\n}\n\n \nstatic void i40e_parse_ieee_app_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t    struct i40e_dcbx_config *dcbcfg)\n{\n\tu16 typelength;\n\tu16 offset = 0;\n\tu16 length;\n\tint i = 0;\n\tu8 *buf;\n\n\ttypelength = ntohs(tlv->typelength);\n\tlength = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>\n\t\t       I40E_LLDP_TLV_LEN_SHIFT);\n\tbuf = tlv->tlvinfo;\n\n\t \n\tlength -= (sizeof(tlv->ouisubtype) + 1);\n\n\t \n\toffset++;\n\n\t \n\twhile (offset < length) {\n\t\tdcbcfg->app[i].priority = (u8)((buf[offset] &\n\t\t\t\t\t\tI40E_IEEE_APP_PRIO_MASK) >>\n\t\t\t\t\t       I40E_IEEE_APP_PRIO_SHIFT);\n\t\tdcbcfg->app[i].selector = (u8)((buf[offset] &\n\t\t\t\t\t\tI40E_IEEE_APP_SEL_MASK) >>\n\t\t\t\t\t       I40E_IEEE_APP_SEL_SHIFT);\n\t\tdcbcfg->app[i].protocolid = (buf[offset + 1] << 0x8) |\n\t\t\t\t\t     buf[offset + 2];\n\t\t \n\t\toffset += 3;\n\t\ti++;\n\t\tif (i >= I40E_DCBX_MAX_APPS)\n\t\t\tbreak;\n\t}\n\n\tdcbcfg->numapps = i;\n}\n\n \nstatic void i40e_parse_ieee_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\tstruct i40e_dcbx_config *dcbcfg)\n{\n\tu32 ouisubtype;\n\tu8 subtype;\n\n\touisubtype = ntohl(tlv->ouisubtype);\n\tsubtype = (u8)((ouisubtype & I40E_LLDP_TLV_SUBTYPE_MASK) >>\n\t\t       I40E_LLDP_TLV_SUBTYPE_SHIFT);\n\tswitch (subtype) {\n\tcase I40E_IEEE_SUBTYPE_ETS_CFG:\n\t\ti40e_parse_ieee_etscfg_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase I40E_IEEE_SUBTYPE_ETS_REC:\n\t\ti40e_parse_ieee_etsrec_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase I40E_IEEE_SUBTYPE_PFC_CFG:\n\t\ti40e_parse_ieee_pfccfg_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase I40E_IEEE_SUBTYPE_APP_PRI:\n\t\ti40e_parse_ieee_app_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void i40e_parse_cee_pgcfg_tlv(struct i40e_cee_feat_tlv *tlv,\n\t\t\t\t     struct i40e_dcbx_config *dcbcfg)\n{\n\tstruct i40e_dcb_ets_config *etscfg;\n\tu8 *buf = tlv->tlvinfo;\n\tu16 offset = 0;\n\tu8 priority;\n\tint i;\n\n\tetscfg = &dcbcfg->etscfg;\n\n\tif (tlv->en_will_err & I40E_CEE_FEAT_TLV_WILLING_MASK)\n\t\tetscfg->willing = 1;\n\n\tetscfg->cbs = 0;\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tpriority = (u8)((buf[offset] & I40E_CEE_PGID_PRIO_1_MASK) >>\n\t\t\t\t I40E_CEE_PGID_PRIO_1_SHIFT);\n\t\tetscfg->prioritytable[i * 2] =  priority;\n\t\tpriority = (u8)((buf[offset] & I40E_CEE_PGID_PRIO_0_MASK) >>\n\t\t\t\t I40E_CEE_PGID_PRIO_0_SHIFT);\n\t\tetscfg->prioritytable[i * 2 + 1] = priority;\n\t\toffset++;\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tetscfg->tcbwtable[i] = buf[offset++];\n\n\t \n\tetscfg->maxtcs = buf[offset];\n}\n\n \nstatic void i40e_parse_cee_pfccfg_tlv(struct i40e_cee_feat_tlv *tlv,\n\t\t\t\t      struct i40e_dcbx_config *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\n\tif (tlv->en_will_err & I40E_CEE_FEAT_TLV_WILLING_MASK)\n\t\tdcbcfg->pfc.willing = 1;\n\n\t \n\tdcbcfg->pfc.pfcenable = buf[0];\n\tdcbcfg->pfc.pfccap = buf[1];\n}\n\n \nstatic void i40e_parse_cee_app_tlv(struct i40e_cee_feat_tlv *tlv,\n\t\t\t\t   struct i40e_dcbx_config *dcbcfg)\n{\n\tu16 length, typelength, offset = 0;\n\tstruct i40e_cee_app_prio *app;\n\tu8 i;\n\n\ttypelength = ntohs(tlv->hdr.typelen);\n\tlength = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>\n\t\t       I40E_LLDP_TLV_LEN_SHIFT);\n\n\tdcbcfg->numapps = length / sizeof(*app);\n\n\tif (!dcbcfg->numapps)\n\t\treturn;\n\tif (dcbcfg->numapps > I40E_DCBX_MAX_APPS)\n\t\tdcbcfg->numapps = I40E_DCBX_MAX_APPS;\n\n\tfor (i = 0; i < dcbcfg->numapps; i++) {\n\t\tu8 up, selector;\n\n\t\tapp = (struct i40e_cee_app_prio *)(tlv->tlvinfo + offset);\n\t\tfor (up = 0; up < I40E_MAX_USER_PRIORITY; up++) {\n\t\t\tif (app->prio_map & BIT(up))\n\t\t\t\tbreak;\n\t\t}\n\t\tdcbcfg->app[i].priority = up;\n\n\t\t \n\t\tselector = (app->upper_oui_sel & I40E_CEE_APP_SELECTOR_MASK);\n\t\tswitch (selector) {\n\t\tcase I40E_CEE_APP_SEL_ETHTYPE:\n\t\t\tdcbcfg->app[i].selector = I40E_APP_SEL_ETHTYPE;\n\t\t\tbreak;\n\t\tcase I40E_CEE_APP_SEL_TCPIP:\n\t\t\tdcbcfg->app[i].selector = I40E_APP_SEL_TCPIP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdcbcfg->app[i].selector = selector;\n\t\t}\n\n\t\tdcbcfg->app[i].protocolid = ntohs(app->protocol);\n\t\t \n\t\toffset += sizeof(*app);\n\t}\n}\n\n \nstatic void i40e_parse_cee_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t       struct i40e_dcbx_config *dcbcfg)\n{\n\tu16 len, tlvlen, sublen, typelength;\n\tstruct i40e_cee_feat_tlv *sub_tlv;\n\tu8 subtype, feat_tlv_count = 0;\n\tu32 ouisubtype;\n\n\touisubtype = ntohl(tlv->ouisubtype);\n\tsubtype = (u8)((ouisubtype & I40E_LLDP_TLV_SUBTYPE_MASK) >>\n\t\t       I40E_LLDP_TLV_SUBTYPE_SHIFT);\n\t \n\tif (subtype != I40E_CEE_DCBX_TYPE)\n\t\treturn;\n\n\ttypelength = ntohs(tlv->typelength);\n\ttlvlen = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>\n\t\t\tI40E_LLDP_TLV_LEN_SHIFT);\n\tlen = sizeof(tlv->typelength) + sizeof(ouisubtype) +\n\t      sizeof(struct i40e_cee_ctrl_tlv);\n\t \n\tif (tlvlen <= len)\n\t\treturn;\n\n\tsub_tlv = (struct i40e_cee_feat_tlv *)((char *)tlv + len);\n\twhile (feat_tlv_count < I40E_CEE_MAX_FEAT_TYPE) {\n\t\ttypelength = ntohs(sub_tlv->hdr.typelen);\n\t\tsublen = (u16)((typelength &\n\t\t\t\tI40E_LLDP_TLV_LEN_MASK) >>\n\t\t\t\tI40E_LLDP_TLV_LEN_SHIFT);\n\t\tsubtype = (u8)((typelength & I40E_LLDP_TLV_TYPE_MASK) >>\n\t\t\t\tI40E_LLDP_TLV_TYPE_SHIFT);\n\t\tswitch (subtype) {\n\t\tcase I40E_CEE_SUBTYPE_PG_CFG:\n\t\t\ti40e_parse_cee_pgcfg_tlv(sub_tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase I40E_CEE_SUBTYPE_PFC_CFG:\n\t\t\ti40e_parse_cee_pfccfg_tlv(sub_tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase I40E_CEE_SUBTYPE_APP_PRI:\n\t\t\ti40e_parse_cee_app_tlv(sub_tlv, dcbcfg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;  \n\t\t}\n\t\tfeat_tlv_count++;\n\t\t \n\t\tsub_tlv = (struct i40e_cee_feat_tlv *)((char *)sub_tlv +\n\t\t\t\t\t\tsizeof(sub_tlv->hdr.typelen) +\n\t\t\t\t\t\tsublen);\n\t}\n}\n\n \nstatic void i40e_parse_org_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t       struct i40e_dcbx_config *dcbcfg)\n{\n\tu32 ouisubtype;\n\tu32 oui;\n\n\touisubtype = ntohl(tlv->ouisubtype);\n\toui = (u32)((ouisubtype & I40E_LLDP_TLV_OUI_MASK) >>\n\t\t    I40E_LLDP_TLV_OUI_SHIFT);\n\tswitch (oui) {\n\tcase I40E_IEEE_8021QAZ_OUI:\n\t\ti40e_parse_ieee_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase I40E_CEE_DCBX_OUI:\n\t\ti40e_parse_cee_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nint i40e_lldp_to_dcb_config(u8 *lldpmib,\n\t\t\t    struct i40e_dcbx_config *dcbcfg)\n{\n\tstruct i40e_lldp_org_tlv *tlv;\n\tu16 typelength;\n\tu16 offset = 0;\n\tint ret = 0;\n\tu16 length;\n\tu16 type;\n\n\tif (!lldpmib || !dcbcfg)\n\t\treturn -EINVAL;\n\n\t \n\tlldpmib += ETH_HLEN;\n\ttlv = (struct i40e_lldp_org_tlv *)lldpmib;\n\twhile (1) {\n\t\ttypelength = ntohs(tlv->typelength);\n\t\ttype = (u16)((typelength & I40E_LLDP_TLV_TYPE_MASK) >>\n\t\t\t     I40E_LLDP_TLV_TYPE_SHIFT);\n\t\tlength = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>\n\t\t\t       I40E_LLDP_TLV_LEN_SHIFT);\n\t\toffset += sizeof(typelength) + length;\n\n\t\t \n\t\tif ((type == I40E_TLV_TYPE_END) || (offset > I40E_LLDPDU_SIZE))\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase I40E_TLV_TYPE_ORG:\n\t\t\ti40e_parse_org_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttlv = (struct i40e_lldp_org_tlv *)((char *)tlv +\n\t\t\t\t\t\t    sizeof(tlv->typelength) +\n\t\t\t\t\t\t    length);\n\t}\n\n\treturn ret;\n}\n\n \nint i40e_aq_get_dcb_config(struct i40e_hw *hw, u8 mib_type,\n\t\t\t   u8 bridgetype,\n\t\t\t   struct i40e_dcbx_config *dcbcfg)\n{\n\tstruct i40e_virt_mem mem;\n\tint ret = 0;\n\tu8 *lldpmib;\n\n\t \n\tret = i40e_allocate_virt_mem(hw, &mem, I40E_LLDPDU_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tlldpmib = (u8 *)mem.va;\n\tret = i40e_aq_get_lldp_mib(hw, bridgetype, mib_type,\n\t\t\t\t   (void *)lldpmib, I40E_LLDPDU_SIZE,\n\t\t\t\t   NULL, NULL, NULL);\n\tif (ret)\n\t\tgoto free_mem;\n\n\t \n\tret = i40e_lldp_to_dcb_config(lldpmib, dcbcfg);\n\nfree_mem:\n\ti40e_free_virt_mem(hw, &mem);\n\treturn ret;\n}\n\n \nstatic void i40e_cee_to_dcb_v1_config(\n\t\t\tstruct i40e_aqc_get_cee_dcb_cfg_v1_resp *cee_cfg,\n\t\t\tstruct i40e_dcbx_config *dcbcfg)\n{\n\tu16 status, tlv_status = le16_to_cpu(cee_cfg->tlv_status);\n\tu16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);\n\tu8 i, tc, err;\n\n\t \n\tdcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\ttc = (u8)((cee_cfg->oper_prio_tc[i] &\n\t\t\t I40E_CEE_PGID_PRIO_0_MASK) >>\n\t\t\t I40E_CEE_PGID_PRIO_0_SHIFT);\n\t\tdcbcfg->etscfg.prioritytable[i * 2] =  tc;\n\t\ttc = (u8)((cee_cfg->oper_prio_tc[i] &\n\t\t\t I40E_CEE_PGID_PRIO_1_MASK) >>\n\t\t\t I40E_CEE_PGID_PRIO_1_SHIFT);\n\t\tdcbcfg->etscfg.prioritytable[i*2 + 1] = tc;\n\t}\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tdcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {\n\t\t\t \n\t\t\tdcbcfg->etscfg.prioritytable[i] =\n\t\t\t\t\t\tcee_cfg->oper_num_tc - 1;\n\t\t\tdcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;\n\t\t} else {\n\t\t\tdcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;\n\t\t}\n\t}\n\n\t \n\tdcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;\n\tdcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;\n\n\tstatus = (tlv_status & I40E_AQC_CEE_APP_STATUS_MASK) >>\n\t\t  I40E_AQC_CEE_APP_STATUS_SHIFT;\n\terr = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;\n\t \n\tif (!err) {\n\t\t \n\t\tdcbcfg->numapps = I40E_CEE_OPER_MAX_APPS;\n\n\t\t \n\t\tdcbcfg->app[0].priority =\n\t\t\t(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>\n\t\t\t I40E_AQC_CEE_APP_FCOE_SHIFT;\n\t\tdcbcfg->app[0].selector = I40E_APP_SEL_ETHTYPE;\n\t\tdcbcfg->app[0].protocolid = I40E_APP_PROTOID_FCOE;\n\n\t\t \n\t\tdcbcfg->app[1].priority =\n\t\t\t(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>\n\t\t\t I40E_AQC_CEE_APP_ISCSI_SHIFT;\n\t\tdcbcfg->app[1].selector = I40E_APP_SEL_TCPIP;\n\t\tdcbcfg->app[1].protocolid = I40E_APP_PROTOID_ISCSI;\n\n\t\t \n\t\tdcbcfg->app[2].priority =\n\t\t\t(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>\n\t\t\t I40E_AQC_CEE_APP_FIP_SHIFT;\n\t\tdcbcfg->app[2].selector = I40E_APP_SEL_ETHTYPE;\n\t\tdcbcfg->app[2].protocolid = I40E_APP_PROTOID_FIP;\n\t}\n}\n\n \nstatic void i40e_cee_to_dcb_config(\n\t\t\t\tstruct i40e_aqc_get_cee_dcb_cfg_resp *cee_cfg,\n\t\t\t\tstruct i40e_dcbx_config *dcbcfg)\n{\n\tu32 status, tlv_status = le32_to_cpu(cee_cfg->tlv_status);\n\tu16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);\n\tu8 i, tc, err, sync, oper;\n\n\t \n\tdcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\ttc = (u8)((cee_cfg->oper_prio_tc[i] &\n\t\t\t I40E_CEE_PGID_PRIO_0_MASK) >>\n\t\t\t I40E_CEE_PGID_PRIO_0_SHIFT);\n\t\tdcbcfg->etscfg.prioritytable[i * 2] =  tc;\n\t\ttc = (u8)((cee_cfg->oper_prio_tc[i] &\n\t\t\t I40E_CEE_PGID_PRIO_1_MASK) >>\n\t\t\t I40E_CEE_PGID_PRIO_1_SHIFT);\n\t\tdcbcfg->etscfg.prioritytable[i * 2 + 1] = tc;\n\t}\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tdcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {\n\t\t\t \n\t\t\tdcbcfg->etscfg.prioritytable[i] =\n\t\t\t\t\t\tcee_cfg->oper_num_tc - 1;\n\t\t\tdcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;\n\t\t} else {\n\t\t\tdcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;\n\t\t}\n\t}\n\n\t \n\tdcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;\n\tdcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;\n\n\ti = 0;\n\tstatus = (tlv_status & I40E_AQC_CEE_FCOE_STATUS_MASK) >>\n\t\t  I40E_AQC_CEE_FCOE_STATUS_SHIFT;\n\terr = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;\n\tsync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;\n\toper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;\n\t \n\tif (!err && sync && oper) {\n\t\t \n\t\tdcbcfg->app[i].priority =\n\t\t\t(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>\n\t\t\t I40E_AQC_CEE_APP_FCOE_SHIFT;\n\t\tdcbcfg->app[i].selector = I40E_APP_SEL_ETHTYPE;\n\t\tdcbcfg->app[i].protocolid = I40E_APP_PROTOID_FCOE;\n\t\ti++;\n\t}\n\n\tstatus = (tlv_status & I40E_AQC_CEE_ISCSI_STATUS_MASK) >>\n\t\t  I40E_AQC_CEE_ISCSI_STATUS_SHIFT;\n\terr = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;\n\tsync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;\n\toper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;\n\t \n\tif (!err && sync && oper) {\n\t\t \n\t\tdcbcfg->app[i].priority =\n\t\t\t(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>\n\t\t\t I40E_AQC_CEE_APP_ISCSI_SHIFT;\n\t\tdcbcfg->app[i].selector = I40E_APP_SEL_TCPIP;\n\t\tdcbcfg->app[i].protocolid = I40E_APP_PROTOID_ISCSI;\n\t\ti++;\n\t}\n\n\tstatus = (tlv_status & I40E_AQC_CEE_FIP_STATUS_MASK) >>\n\t\t  I40E_AQC_CEE_FIP_STATUS_SHIFT;\n\terr = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;\n\tsync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;\n\toper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;\n\t \n\tif (!err && sync && oper) {\n\t\t \n\t\tdcbcfg->app[i].priority =\n\t\t\t(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>\n\t\t\t I40E_AQC_CEE_APP_FIP_SHIFT;\n\t\tdcbcfg->app[i].selector = I40E_APP_SEL_ETHTYPE;\n\t\tdcbcfg->app[i].protocolid = I40E_APP_PROTOID_FIP;\n\t\ti++;\n\t}\n\tdcbcfg->numapps = i;\n}\n\n \nstatic int i40e_get_ieee_dcb_config(struct i40e_hw *hw)\n{\n\tint ret = 0;\n\n\t \n\thw->local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_IEEE;\n\t \n\tret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_LOCAL, 0,\n\t\t\t\t     &hw->local_dcbx_config);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_REMOTE,\n\t\t\t\t     I40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE,\n\t\t\t\t     &hw->remote_dcbx_config);\n\t \n\tif (hw->aq.asq_last_status == I40E_AQ_RC_ENOENT)\n\t\tret = 0;\n\nout:\n\treturn ret;\n}\n\n \nint i40e_get_dcb_config(struct i40e_hw *hw)\n{\n\tstruct i40e_aqc_get_cee_dcb_cfg_v1_resp cee_v1_cfg;\n\tstruct i40e_aqc_get_cee_dcb_cfg_resp cee_cfg;\n\tint ret = 0;\n\n\t \n\tif ((hw->mac.type == I40E_MAC_XL710) &&\n\t    (((hw->aq.fw_maj_ver == 4) && (hw->aq.fw_min_ver < 33)) ||\n\t      (hw->aq.fw_maj_ver < 4)))\n\t\treturn i40e_get_ieee_dcb_config(hw);\n\n\t \n\tif ((hw->mac.type == I40E_MAC_XL710) &&\n\t    ((hw->aq.fw_maj_ver == 4) && (hw->aq.fw_min_ver == 33))) {\n\t\tret = i40e_aq_get_cee_dcb_config(hw, &cee_v1_cfg,\n\t\t\t\t\t\t sizeof(cee_v1_cfg), NULL);\n\t\tif (!ret) {\n\t\t\t \n\t\t\thw->local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_CEE;\n\t\t\thw->local_dcbx_config.tlv_status =\n\t\t\t\t\tle16_to_cpu(cee_v1_cfg.tlv_status);\n\t\t\ti40e_cee_to_dcb_v1_config(&cee_v1_cfg,\n\t\t\t\t\t\t  &hw->local_dcbx_config);\n\t\t}\n\t} else {\n\t\tret = i40e_aq_get_cee_dcb_config(hw, &cee_cfg,\n\t\t\t\t\t\t sizeof(cee_cfg), NULL);\n\t\tif (!ret) {\n\t\t\t \n\t\t\thw->local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_CEE;\n\t\t\thw->local_dcbx_config.tlv_status =\n\t\t\t\t\tle32_to_cpu(cee_cfg.tlv_status);\n\t\t\ti40e_cee_to_dcb_config(&cee_cfg,\n\t\t\t\t\t       &hw->local_dcbx_config);\n\t\t}\n\t}\n\n\t \n\tif (hw->aq.asq_last_status == I40E_AQ_RC_ENOENT)\n\t\treturn i40e_get_ieee_dcb_config(hw);\n\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_LOCAL, 0,\n\t\t\t\t     &hw->desired_dcbx_config);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_REMOTE,\n\t\t\t\t     I40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE,\n\t\t\t\t     &hw->remote_dcbx_config);\n\t \n\tif (hw->aq.asq_last_status == I40E_AQ_RC_ENOENT)\n\t\tret = 0;\n\nout:\n\treturn ret;\n}\n\n \nint i40e_init_dcb(struct i40e_hw *hw, bool enable_mib_change)\n{\n\tstruct i40e_lldp_variables lldp_cfg;\n\tu8 adminstatus = 0;\n\tint ret = 0;\n\n\tif (!hw->func_caps.dcb)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (hw->flags & I40E_HW_FLAG_FW_LLDP_PERSISTENT) {\n\t\tu8 offset = 0;\n\n\t\tif (hw->mac.type == I40E_MAC_XL710)\n\t\t\toffset = I40E_LLDP_CURRENT_STATUS_XL710_OFFSET;\n\t\telse if (hw->mac.type == I40E_MAC_X722)\n\t\t\toffset = I40E_LLDP_CURRENT_STATUS_X722_OFFSET;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = i40e_read_nvm_module_data(hw,\n\t\t\t\t\t\tI40E_SR_EMP_SR_SETTINGS_PTR,\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\tI40E_LLDP_CURRENT_STATUS_OFFSET,\n\t\t\t\t\t\tI40E_LLDP_CURRENT_STATUS_SIZE,\n\t\t\t\t\t\t&lldp_cfg.adminstatus);\n\t} else {\n\t\tret = i40e_read_lldp_cfg(hw, &lldp_cfg);\n\t}\n\tif (ret)\n\t\treturn -EBUSY;\n\n\t \n\tadminstatus = lldp_cfg.adminstatus >> (hw->port * 4);\n\tadminstatus &= 0xF;\n\n\t \n\tif (!adminstatus) {\n\t\thw->dcbx_status = I40E_DCBX_STATUS_DISABLED;\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = i40e_get_dcbx_status(hw, &hw->dcbx_status);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (hw->dcbx_status == I40E_DCBX_STATUS_DONE ||\n\t    hw->dcbx_status == I40E_DCBX_STATUS_IN_PROGRESS) {\n\t\t \n\t\tret = i40e_get_dcb_config(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (hw->dcbx_status == I40E_DCBX_STATUS_DISABLED) {\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (enable_mib_change)\n\t\tret = i40e_aq_cfg_lldp_mib_change_event(hw, true, NULL);\n\n\treturn ret;\n}\n\n \nint\ni40e_get_fw_lldp_status(struct i40e_hw *hw,\n\t\t\tenum i40e_get_fw_lldp_status_resp *lldp_status)\n{\n\tstruct i40e_virt_mem mem;\n\tu8 *lldpmib;\n\tint ret;\n\n\tif (!lldp_status)\n\t\treturn -EINVAL;\n\n\t \n\tret = i40e_allocate_virt_mem(hw, &mem, I40E_LLDPDU_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tlldpmib = (u8 *)mem.va;\n\tret = i40e_aq_get_lldp_mib(hw, 0, 0, (void *)lldpmib,\n\t\t\t\t   I40E_LLDPDU_SIZE, NULL, NULL, NULL);\n\n\tif (!ret) {\n\t\t*lldp_status = I40E_GET_FW_LLDP_STATUS_ENABLED;\n\t} else if (hw->aq.asq_last_status == I40E_AQ_RC_ENOENT) {\n\t\t \n\t\t*lldp_status = I40E_GET_FW_LLDP_STATUS_ENABLED;\n\t\tret = 0;\n\t} else if (hw->aq.asq_last_status == I40E_AQ_RC_EPERM) {\n\t\t*lldp_status = I40E_GET_FW_LLDP_STATUS_DISABLED;\n\t\tret = 0;\n\t}\n\n\ti40e_free_virt_mem(hw, &mem);\n\treturn ret;\n}\n\n \nstatic void i40e_add_ieee_ets_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t  struct i40e_dcbx_config *dcbcfg)\n{\n\tu8 priority0, priority1, maxtcwilling = 0;\n\tstruct i40e_dcb_ets_config *etscfg;\n\tu16 offset = 0, typelength, i;\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\n\ttypelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |\n\t\t\tI40E_IEEE_ETS_TLV_LENGTH);\n\ttlv->typelength = htons(typelength);\n\n\touisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |\n\t\t\tI40E_IEEE_SUBTYPE_ETS_CFG);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\tetscfg = &dcbcfg->etscfg;\n\tif (etscfg->willing)\n\t\tmaxtcwilling = BIT(I40E_IEEE_ETS_WILLING_SHIFT);\n\tmaxtcwilling |= etscfg->maxtcs & I40E_IEEE_ETS_MAXTC_MASK;\n\tbuf[offset] = maxtcwilling;\n\n\t \n\toffset++;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tpriority0 = etscfg->prioritytable[i * 2] & 0xF;\n\t\tpriority1 = etscfg->prioritytable[i * 2 + 1] & 0xF;\n\t\tbuf[offset] = (priority0 << I40E_IEEE_ETS_PRIO_1_SHIFT) |\n\t\t\t\tpriority1;\n\t\toffset++;\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tbuf[offset++] = etscfg->tcbwtable[i];\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tbuf[offset++] = etscfg->tsatable[i];\n}\n\n \nstatic void i40e_add_ieee_etsrec_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t     struct i40e_dcbx_config *dcbcfg)\n{\n\tstruct i40e_dcb_ets_config *etsrec;\n\tu16 offset = 0, typelength, i;\n\tu8 priority0, priority1;\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\n\ttypelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |\n\t\t\tI40E_IEEE_ETS_TLV_LENGTH);\n\ttlv->typelength = htons(typelength);\n\n\touisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |\n\t\t\tI40E_IEEE_SUBTYPE_ETS_REC);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\tetsrec = &dcbcfg->etsrec;\n\t \n\t \n\toffset++;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tpriority0 = etsrec->prioritytable[i * 2] & 0xF;\n\t\tpriority1 = etsrec->prioritytable[i * 2 + 1] & 0xF;\n\t\tbuf[offset] = (priority0 << I40E_IEEE_ETS_PRIO_1_SHIFT) |\n\t\t\t\tpriority1;\n\t\toffset++;\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tbuf[offset++] = etsrec->tcbwtable[i];\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tbuf[offset++] = etsrec->tsatable[i];\n}\n\n \nstatic void i40e_add_ieee_pfc_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t  struct i40e_dcbx_config *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\tu16 typelength;\n\n\ttypelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |\n\t\t\tI40E_IEEE_PFC_TLV_LENGTH);\n\ttlv->typelength = htons(typelength);\n\n\touisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |\n\t\t\tI40E_IEEE_SUBTYPE_PFC_CFG);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\tif (dcbcfg->pfc.willing)\n\t\tbuf[0] = BIT(I40E_IEEE_PFC_WILLING_SHIFT);\n\n\tif (dcbcfg->pfc.mbc)\n\t\tbuf[0] |= BIT(I40E_IEEE_PFC_MBC_SHIFT);\n\n\tbuf[0] |= dcbcfg->pfc.pfccap & 0xF;\n\tbuf[1] = dcbcfg->pfc.pfcenable;\n}\n\n \nstatic void i40e_add_ieee_app_pri_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t\t      struct i40e_dcbx_config *dcbcfg)\n{\n\tu16 typelength, length, offset = 0;\n\tu8 priority, selector, i = 0;\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\n\t \n\tif (dcbcfg->numapps == 0)\n\t\treturn;\n\touisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |\n\t\t\tI40E_IEEE_SUBTYPE_APP_PRI);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\toffset++;\n\t \n\twhile (i < dcbcfg->numapps) {\n\t\tpriority = dcbcfg->app[i].priority & 0x7;\n\t\tselector = dcbcfg->app[i].selector & 0x7;\n\t\tbuf[offset] = (priority << I40E_IEEE_APP_PRIO_SHIFT) | selector;\n\t\tbuf[offset + 1] = (dcbcfg->app[i].protocolid >> 0x8) & 0xFF;\n\t\tbuf[offset + 2] =  dcbcfg->app[i].protocolid & 0xFF;\n\t\t \n\t\toffset += 3;\n\t\ti++;\n\t\tif (i >= I40E_DCBX_MAX_APPS)\n\t\t\tbreak;\n\t}\n\t \n\tlength = sizeof(tlv->ouisubtype) + 1 + (i * 3);\n\ttypelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |\n\t\t(length & 0x1FF));\n\ttlv->typelength = htons(typelength);\n}\n\n \nstatic void i40e_add_dcb_tlv(struct i40e_lldp_org_tlv *tlv,\n\t\t\t     struct i40e_dcbx_config *dcbcfg,\n\t\t\t     u16 tlvid)\n{\n\tswitch (tlvid) {\n\tcase I40E_IEEE_TLV_ID_ETS_CFG:\n\t\ti40e_add_ieee_ets_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase I40E_IEEE_TLV_ID_ETS_REC:\n\t\ti40e_add_ieee_etsrec_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase I40E_IEEE_TLV_ID_PFC_CFG:\n\t\ti40e_add_ieee_pfc_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase I40E_IEEE_TLV_ID_APP_PRI:\n\t\ti40e_add_ieee_app_pri_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nint i40e_set_dcb_config(struct i40e_hw *hw)\n{\n\tstruct i40e_dcbx_config *dcbcfg;\n\tstruct i40e_virt_mem mem;\n\tu8 mib_type, *lldpmib;\n\tu16 miblen;\n\tint ret;\n\n\t \n\tdcbcfg = &hw->local_dcbx_config;\n\t \n\tret = i40e_allocate_virt_mem(hw, &mem, I40E_LLDPDU_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tmib_type = SET_LOCAL_MIB_AC_TYPE_LOCAL_MIB;\n\tif (dcbcfg->app_mode == I40E_DCBX_APPS_NON_WILLING) {\n\t\tmib_type |= SET_LOCAL_MIB_AC_TYPE_NON_WILLING_APPS <<\n\t\t\t    SET_LOCAL_MIB_AC_TYPE_NON_WILLING_APPS_SHIFT;\n\t}\n\tlldpmib = (u8 *)mem.va;\n\ti40e_dcb_config_to_lldp(lldpmib, &miblen, dcbcfg);\n\tret = i40e_aq_set_lldp_mib(hw, mib_type, (void *)lldpmib, miblen, NULL);\n\n\ti40e_free_virt_mem(hw, &mem);\n\treturn ret;\n}\n\n \nint i40e_dcb_config_to_lldp(u8 *lldpmib, u16 *miblen,\n\t\t\t    struct i40e_dcbx_config *dcbcfg)\n{\n\tu16 length, offset = 0, tlvid, typelength;\n\tstruct i40e_lldp_org_tlv *tlv;\n\n\ttlv = (struct i40e_lldp_org_tlv *)lldpmib;\n\ttlvid = I40E_TLV_ID_START;\n\tdo {\n\t\ti40e_add_dcb_tlv(tlv, dcbcfg, tlvid++);\n\t\ttypelength = ntohs(tlv->typelength);\n\t\tlength = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>\n\t\t\t\tI40E_LLDP_TLV_LEN_SHIFT);\n\t\tif (length)\n\t\t\toffset += length + I40E_IEEE_TLV_HEADER_LENGTH;\n\t\t \n\t\tif (tlvid >= I40E_TLV_ID_END_OF_LLDPPDU ||\n\t\t    offset >= I40E_LLDPDU_SIZE)\n\t\t\tbreak;\n\t\t \n\t\tif (length)\n\t\t\ttlv = (struct i40e_lldp_org_tlv *)((char *)tlv +\n\t\t\t      sizeof(tlv->typelength) + length);\n\t} while (tlvid < I40E_TLV_ID_END_OF_LLDPPDU);\n\t*miblen = offset;\n\treturn 0;\n}\n\n \nvoid i40e_dcb_hw_rx_fifo_config(struct i40e_hw *hw,\n\t\t\t\tenum i40e_dcb_arbiter_mode ets_mode,\n\t\t\t\tenum i40e_dcb_arbiter_mode non_ets_mode,\n\t\t\t\tu32 max_exponent,\n\t\t\t\tu8 lltc_map)\n{\n\tu32 reg = rd32(hw, I40E_PRTDCB_RETSC);\n\n\treg &= ~I40E_PRTDCB_RETSC_ETS_MODE_MASK;\n\treg |= ((u32)ets_mode << I40E_PRTDCB_RETSC_ETS_MODE_SHIFT) &\n\t\tI40E_PRTDCB_RETSC_ETS_MODE_MASK;\n\n\treg &= ~I40E_PRTDCB_RETSC_NON_ETS_MODE_MASK;\n\treg |= ((u32)non_ets_mode << I40E_PRTDCB_RETSC_NON_ETS_MODE_SHIFT) &\n\t\tI40E_PRTDCB_RETSC_NON_ETS_MODE_MASK;\n\n\treg &= ~I40E_PRTDCB_RETSC_ETS_MAX_EXP_MASK;\n\treg |= (max_exponent << I40E_PRTDCB_RETSC_ETS_MAX_EXP_SHIFT) &\n\t\tI40E_PRTDCB_RETSC_ETS_MAX_EXP_MASK;\n\n\treg &= ~I40E_PRTDCB_RETSC_LLTC_MASK;\n\treg |= (lltc_map << I40E_PRTDCB_RETSC_LLTC_SHIFT) &\n\t\tI40E_PRTDCB_RETSC_LLTC_MASK;\n\twr32(hw, I40E_PRTDCB_RETSC, reg);\n}\n\n \nvoid i40e_dcb_hw_rx_cmd_monitor_config(struct i40e_hw *hw,\n\t\t\t\t       u8 num_tc, u8 num_ports)\n{\n\tu32 threshold;\n\tu32 fifo_size;\n\tu32 reg;\n\n\t \n\tswitch (num_ports) {\n\tcase 1:\n\t\tthreshold = I40E_DCB_1_PORT_THRESHOLD;\n\t\tfifo_size = I40E_DCB_1_PORT_FIFO_SIZE;\n\t\tbreak;\n\tcase 2:\n\t\tif (num_tc > 4) {\n\t\t\tthreshold = I40E_DCB_2_PORT_THRESHOLD_HIGH_NUM_TC;\n\t\t\tfifo_size = I40E_DCB_2_PORT_FIFO_SIZE_HIGH_NUM_TC;\n\t\t} else {\n\t\t\tthreshold = I40E_DCB_2_PORT_THRESHOLD_LOW_NUM_TC;\n\t\t\tfifo_size = I40E_DCB_2_PORT_FIFO_SIZE_LOW_NUM_TC;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tif (num_tc > 4) {\n\t\t\tthreshold = I40E_DCB_4_PORT_THRESHOLD_HIGH_NUM_TC;\n\t\t\tfifo_size = I40E_DCB_4_PORT_FIFO_SIZE_HIGH_NUM_TC;\n\t\t} else {\n\t\t\tthreshold = I40E_DCB_4_PORT_THRESHOLD_LOW_NUM_TC;\n\t\t\tfifo_size = I40E_DCB_4_PORT_FIFO_SIZE_LOW_NUM_TC;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ti40e_debug(hw, I40E_DEBUG_DCB, \"Invalid num_ports %u.\\n\",\n\t\t\t   (u32)num_ports);\n\t\treturn;\n\t}\n\n\t \n\treg = rd32(hw, I40E_PRT_SWR_PM_THR);\n\treg &= ~I40E_PRT_SWR_PM_THR_THRESHOLD_MASK;\n\treg |= (threshold << I40E_PRT_SWR_PM_THR_THRESHOLD_SHIFT) &\n\t\tI40E_PRT_SWR_PM_THR_THRESHOLD_MASK;\n\twr32(hw, I40E_PRT_SWR_PM_THR, reg);\n\n\treg = rd32(hw, I40E_PRTDCB_RPPMC);\n\treg &= ~I40E_PRTDCB_RPPMC_RX_FIFO_SIZE_MASK;\n\treg |= (fifo_size << I40E_PRTDCB_RPPMC_RX_FIFO_SIZE_SHIFT) &\n\t\tI40E_PRTDCB_RPPMC_RX_FIFO_SIZE_MASK;\n\twr32(hw, I40E_PRTDCB_RPPMC, reg);\n}\n\n \nvoid i40e_dcb_hw_pfc_config(struct i40e_hw *hw,\n\t\t\t    u8 pfc_en, u8 *prio_tc)\n{\n\tu16 refresh_time = (u16)I40E_DEFAULT_PAUSE_TIME / 2;\n\tu32 link_speed = hw->phy.link_info.link_speed;\n\tu8 first_pfc_prio = 0;\n\tu8 num_pfc_tc = 0;\n\tu8 tc2pfc = 0;\n\tu32 reg;\n\tu8 i;\n\n\t \n\tfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {\n\t\tif (pfc_en & BIT(i)) {\n\t\t\tif (!first_pfc_prio)\n\t\t\t\tfirst_pfc_prio = i;\n\t\t\t \n\t\t\ttc2pfc |= BIT(prio_tc[i]);\n\t\t\tnum_pfc_tc++;\n\t\t}\n\t}\n\n\tswitch (link_speed) {\n\tcase I40E_LINK_SPEED_10GB:\n\t\treg = rd32(hw, I40E_PRTDCB_MFLCN);\n\t\treg |= BIT(I40E_PRTDCB_MFLCN_DPF_SHIFT) &\n\t\t\tI40E_PRTDCB_MFLCN_DPF_MASK;\n\t\treg &= ~I40E_PRTDCB_MFLCN_RFCE_MASK;\n\t\treg &= ~I40E_PRTDCB_MFLCN_RPFCE_MASK;\n\t\tif (pfc_en) {\n\t\t\treg |= BIT(I40E_PRTDCB_MFLCN_RPFCM_SHIFT) &\n\t\t\t\tI40E_PRTDCB_MFLCN_RPFCM_MASK;\n\t\t\treg |= ((u32)pfc_en << I40E_PRTDCB_MFLCN_RPFCE_SHIFT) &\n\t\t\t\tI40E_PRTDCB_MFLCN_RPFCE_MASK;\n\t\t}\n\t\twr32(hw, I40E_PRTDCB_MFLCN, reg);\n\n\t\treg = rd32(hw, I40E_PRTDCB_FCCFG);\n\t\treg &= ~I40E_PRTDCB_FCCFG_TFCE_MASK;\n\t\tif (pfc_en)\n\t\t\treg |= (I40E_DCB_PFC_ENABLED <<\n\t\t\t\tI40E_PRTDCB_FCCFG_TFCE_SHIFT) &\n\t\t\t\tI40E_PRTDCB_FCCFG_TFCE_MASK;\n\t\twr32(hw, I40E_PRTDCB_FCCFG, reg);\n\n\t\t \n\t\tbreak;\n\tcase I40E_LINK_SPEED_40GB:\n\t\treg = rd32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP);\n\t\treg &= ~I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP_MASK;\n\t\twr32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP, reg);\n\n\t\treg = rd32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP);\n\t\treg &= ~I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP_MASK;\n\t\treg |= BIT(I40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP_SHIFT) &\n\t\t\tI40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP_MASK;\n\t\twr32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP, reg);\n\n\t\treg = rd32(hw, I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE);\n\t\treg &= ~I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE_MASK;\n\t\treg |= ((u32)pfc_en <<\n\t\t\t   I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE_SHIFT) &\n\t\t\tI40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE_MASK;\n\t\twr32(hw, I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE, reg);\n\n\t\treg = rd32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE);\n\t\treg &= ~I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE_MASK;\n\t\treg |= ((u32)pfc_en <<\n\t\t\t   I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE_SHIFT) &\n\t\t\tI40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE_MASK;\n\t\twr32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE, reg);\n\n\t\tfor (i = 0; i < I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_MAX_INDEX; i++) {\n\t\t\treg = rd32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER(i));\n\t\t\treg &= ~I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_MASK;\n\t\t\tif (pfc_en) {\n\t\t\t\treg |= ((u32)refresh_time <<\n\t\t\t\t\tI40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_SHIFT) &\n\t\t\t\t\tI40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_MASK;\n\t\t\t}\n\t\t\twr32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER(i), reg);\n\t\t}\n\t\t \n\t\tbreak;\n\t}\n\n\treg = rd32(hw, I40E_PRTDCB_TC2PFC);\n\treg &= ~I40E_PRTDCB_TC2PFC_TC2PFC_MASK;\n\treg |= ((u32)tc2pfc << I40E_PRTDCB_TC2PFC_TC2PFC_SHIFT) &\n\t\tI40E_PRTDCB_TC2PFC_TC2PFC_MASK;\n\twr32(hw, I40E_PRTDCB_TC2PFC, reg);\n\n\treg = rd32(hw, I40E_PRTDCB_RUP);\n\treg &= ~I40E_PRTDCB_RUP_NOVLANUP_MASK;\n\treg |= ((u32)first_pfc_prio << I40E_PRTDCB_RUP_NOVLANUP_SHIFT) &\n\t\t I40E_PRTDCB_RUP_NOVLANUP_MASK;\n\twr32(hw, I40E_PRTDCB_RUP, reg);\n\n\treg = rd32(hw, I40E_PRTDCB_TDPMC);\n\treg &= ~I40E_PRTDCB_TDPMC_TCPM_MODE_MASK;\n\tif (num_pfc_tc > I40E_DCB_PFC_FORCED_NUM_TC) {\n\t\treg |= BIT(I40E_PRTDCB_TDPMC_TCPM_MODE_SHIFT) &\n\t\t\tI40E_PRTDCB_TDPMC_TCPM_MODE_MASK;\n\t}\n\twr32(hw, I40E_PRTDCB_TDPMC, reg);\n\n\treg = rd32(hw, I40E_PRTDCB_TCPMC);\n\treg &= ~I40E_PRTDCB_TCPMC_TCPM_MODE_MASK;\n\tif (num_pfc_tc > I40E_DCB_PFC_FORCED_NUM_TC) {\n\t\treg |= BIT(I40E_PRTDCB_TCPMC_TCPM_MODE_SHIFT) &\n\t\t\tI40E_PRTDCB_TCPMC_TCPM_MODE_MASK;\n\t}\n\twr32(hw, I40E_PRTDCB_TCPMC, reg);\n}\n\n \nvoid i40e_dcb_hw_set_num_tc(struct i40e_hw *hw, u8 num_tc)\n{\n\tu32 reg = rd32(hw, I40E_PRTDCB_GENC);\n\n\treg &= ~I40E_PRTDCB_GENC_NUMTC_MASK;\n\treg |= ((u32)num_tc << I40E_PRTDCB_GENC_NUMTC_SHIFT) &\n\t\tI40E_PRTDCB_GENC_NUMTC_MASK;\n\twr32(hw, I40E_PRTDCB_GENC, reg);\n}\n\n \nu8 i40e_dcb_hw_get_num_tc(struct i40e_hw *hw)\n{\n\tu32 reg = rd32(hw, I40E_PRTDCB_GENC);\n\n\treturn (u8)((reg & I40E_PRTDCB_GENC_NUMTC_MASK) >>\n\t\tI40E_PRTDCB_GENC_NUMTC_SHIFT);\n}\n\n \nvoid i40e_dcb_hw_rx_ets_bw_config(struct i40e_hw *hw, u8 *bw_share,\n\t\t\t\t  u8 *mode, u8 *prio_type)\n{\n\tu32 reg;\n\tu8 i;\n\n\tfor (i = 0; i <= I40E_PRTDCB_RETSTCC_MAX_INDEX; i++) {\n\t\treg = rd32(hw, I40E_PRTDCB_RETSTCC(i));\n\t\treg &= ~(I40E_PRTDCB_RETSTCC_BWSHARE_MASK     |\n\t\t\t I40E_PRTDCB_RETSTCC_UPINTC_MODE_MASK |\n\t\t\t I40E_PRTDCB_RETSTCC_ETSTC_SHIFT);\n\t\treg |= ((u32)bw_share[i] << I40E_PRTDCB_RETSTCC_BWSHARE_SHIFT) &\n\t\t\t I40E_PRTDCB_RETSTCC_BWSHARE_MASK;\n\t\treg |= ((u32)mode[i] << I40E_PRTDCB_RETSTCC_UPINTC_MODE_SHIFT) &\n\t\t\t I40E_PRTDCB_RETSTCC_UPINTC_MODE_MASK;\n\t\treg |= ((u32)prio_type[i] << I40E_PRTDCB_RETSTCC_ETSTC_SHIFT) &\n\t\t\t I40E_PRTDCB_RETSTCC_ETSTC_MASK;\n\t\twr32(hw, I40E_PRTDCB_RETSTCC(i), reg);\n\t}\n}\n\n \nvoid i40e_dcb_hw_rx_up2tc_config(struct i40e_hw *hw, u8 *prio_tc)\n{\n\tu32 reg = rd32(hw, I40E_PRTDCB_RUP2TC);\n#define I40E_UP2TC_REG(val, i) \\\n\t\t(((val) << I40E_PRTDCB_RUP2TC_UP##i##TC_SHIFT) & \\\n\t\t  I40E_PRTDCB_RUP2TC_UP##i##TC_MASK)\n\n\treg |= I40E_UP2TC_REG(prio_tc[0], 0);\n\treg |= I40E_UP2TC_REG(prio_tc[1], 1);\n\treg |= I40E_UP2TC_REG(prio_tc[2], 2);\n\treg |= I40E_UP2TC_REG(prio_tc[3], 3);\n\treg |= I40E_UP2TC_REG(prio_tc[4], 4);\n\treg |= I40E_UP2TC_REG(prio_tc[5], 5);\n\treg |= I40E_UP2TC_REG(prio_tc[6], 6);\n\treg |= I40E_UP2TC_REG(prio_tc[7], 7);\n\n\twr32(hw, I40E_PRTDCB_RUP2TC, reg);\n}\n\n \nvoid i40e_dcb_hw_calculate_pool_sizes(struct i40e_hw *hw,\n\t\t\t\t      u8 num_ports, bool eee_enabled,\n\t\t\t\t      u8 pfc_en, u32 *mfs_tc,\n\t\t\t\t      struct i40e_rx_pb_config *pb_cfg)\n{\n\tu32 pool_size[I40E_MAX_TRAFFIC_CLASS];\n\tu32 high_wm[I40E_MAX_TRAFFIC_CLASS];\n\tu32 low_wm[I40E_MAX_TRAFFIC_CLASS];\n\tu32 total_pool_size = 0;\n\tint shared_pool_size;  \n\tu32 port_pb_size;\n\tu32 mfs_max = 0;\n\tu32 pcirtt;\n\tu8 i;\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (mfs_tc[i] > mfs_max)\n\t\t\tmfs_max = mfs_tc[i];\n\t}\n\n\tpcirtt = I40E_BT2B(I40E_PCIRTT_LINK_SPEED_10G);\n\n\t \n\tport_pb_size = I40E_DEVICE_RPB_SIZE / num_ports;\n\tif (eee_enabled)\n\t\tport_pb_size -= I40E_BT2B(I40E_EEE_TX_LPI_EXIT_TIME);\n\tport_pb_size -= mfs_max;\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (pfc_en & BIT(i)) {\n\t\t\tlow_wm[i] = (I40E_DCB_WATERMARK_START_FACTOR *\n\t\t\t\t     mfs_tc[i]) + pcirtt;\n\t\t\thigh_wm[i] = low_wm[i];\n\t\t\thigh_wm[i] += ((mfs_max > I40E_MAX_FRAME_SIZE)\n\t\t\t\t\t? mfs_max : I40E_MAX_FRAME_SIZE);\n\t\t\tpool_size[i] = high_wm[i];\n\t\t\tpool_size[i] += I40E_BT2B(I40E_STD_DV_TC(mfs_max,\n\t\t\t\t\t\t\t\tmfs_tc[i]));\n\t\t} else {\n\t\t\tlow_wm[i] = 0;\n\t\t\tpool_size[i] = (I40E_DCB_WATERMARK_START_FACTOR *\n\t\t\t\t\tmfs_tc[i]) + pcirtt;\n\t\t\thigh_wm[i] = pool_size[i];\n\t\t}\n\t\ttotal_pool_size += pool_size[i];\n\t}\n\n\tshared_pool_size = port_pb_size - total_pool_size;\n\tif (shared_pool_size > 0) {\n\t\tpb_cfg->shared_pool_size = shared_pool_size;\n\t\tpb_cfg->shared_pool_high_wm = shared_pool_size;\n\t\tpb_cfg->shared_pool_low_wm = 0;\n\t\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t\tpb_cfg->shared_pool_low_thresh[i] = 0;\n\t\t\tpb_cfg->shared_pool_high_thresh[i] = shared_pool_size;\n\t\t\tpb_cfg->tc_pool_size[i] = pool_size[i];\n\t\t\tpb_cfg->tc_pool_high_wm[i] = high_wm[i];\n\t\t\tpb_cfg->tc_pool_low_wm[i] = low_wm[i];\n\t\t}\n\n\t} else {\n\t\ti40e_debug(hw, I40E_DEBUG_DCB,\n\t\t\t   \"The shared pool size for the port is negative %d.\\n\",\n\t\t\t   shared_pool_size);\n\t}\n}\n\n \nvoid i40e_dcb_hw_rx_pb_config(struct i40e_hw *hw,\n\t\t\t      struct i40e_rx_pb_config *old_pb_cfg,\n\t\t\t      struct i40e_rx_pb_config *new_pb_cfg)\n{\n\tu32 old_val;\n\tu32 new_val;\n\tu32 reg;\n\tu8 i;\n\n\t \n\n\t \n\told_val = old_pb_cfg->shared_pool_low_wm;\n\tnew_val = new_pb_cfg->shared_pool_low_wm;\n\tif (new_val < old_val) {\n\t\treg = rd32(hw, I40E_PRTRPB_SLW);\n\t\treg &= ~I40E_PRTRPB_SLW_SLW_MASK;\n\t\treg |= (new_val << I40E_PRTRPB_SLW_SLW_SHIFT) &\n\t\t\tI40E_PRTRPB_SLW_SLW_MASK;\n\t\twr32(hw, I40E_PRTRPB_SLW, reg);\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\told_val = old_pb_cfg->shared_pool_low_thresh[i];\n\t\tnew_val = new_pb_cfg->shared_pool_low_thresh[i];\n\t\tif (new_val < old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_SLT(i));\n\t\t\treg &= ~I40E_PRTRPB_SLT_SLT_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_SLT_SLT_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_SLT_SLT_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_SLT(i), reg);\n\t\t}\n\n\t\told_val = old_pb_cfg->tc_pool_low_wm[i];\n\t\tnew_val = new_pb_cfg->tc_pool_low_wm[i];\n\t\tif (new_val < old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_DLW(i));\n\t\t\treg &= ~I40E_PRTRPB_DLW_DLW_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_DLW_DLW_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_DLW_DLW_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_DLW(i), reg);\n\t\t}\n\t}\n\n\t \n\told_val = old_pb_cfg->shared_pool_high_wm;\n\tnew_val = new_pb_cfg->shared_pool_high_wm;\n\tif (new_val < old_val) {\n\t\treg = rd32(hw, I40E_PRTRPB_SHW);\n\t\treg &= ~I40E_PRTRPB_SHW_SHW_MASK;\n\t\treg |= (new_val << I40E_PRTRPB_SHW_SHW_SHIFT) &\n\t\t\tI40E_PRTRPB_SHW_SHW_MASK;\n\t\twr32(hw, I40E_PRTRPB_SHW, reg);\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\told_val = old_pb_cfg->shared_pool_high_thresh[i];\n\t\tnew_val = new_pb_cfg->shared_pool_high_thresh[i];\n\t\tif (new_val < old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_SHT(i));\n\t\t\treg &= ~I40E_PRTRPB_SHT_SHT_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_SHT_SHT_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_SHT_SHT_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_SHT(i), reg);\n\t\t}\n\n\t\told_val = old_pb_cfg->tc_pool_high_wm[i];\n\t\tnew_val = new_pb_cfg->tc_pool_high_wm[i];\n\t\tif (new_val < old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_DHW(i));\n\t\t\treg &= ~I40E_PRTRPB_DHW_DHW_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_DHW_DHW_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_DHW_DHW_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_DHW(i), reg);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tnew_val = new_pb_cfg->tc_pool_size[i];\n\t\treg = rd32(hw, I40E_PRTRPB_DPS(i));\n\t\treg &= ~I40E_PRTRPB_DPS_DPS_TCN_MASK;\n\t\treg |= (new_val << I40E_PRTRPB_DPS_DPS_TCN_SHIFT) &\n\t\t\tI40E_PRTRPB_DPS_DPS_TCN_MASK;\n\t\twr32(hw, I40E_PRTRPB_DPS(i), reg);\n\t}\n\n\t \n\tnew_val = new_pb_cfg->shared_pool_size;\n\treg = rd32(hw, I40E_PRTRPB_SPS);\n\treg &= ~I40E_PRTRPB_SPS_SPS_MASK;\n\treg |= (new_val << I40E_PRTRPB_SPS_SPS_SHIFT) &\n\t\tI40E_PRTRPB_SPS_SPS_MASK;\n\twr32(hw, I40E_PRTRPB_SPS, reg);\n\n\t \n\told_val = old_pb_cfg->shared_pool_low_wm;\n\tnew_val = new_pb_cfg->shared_pool_low_wm;\n\tif (new_val > old_val) {\n\t\treg = rd32(hw, I40E_PRTRPB_SLW);\n\t\treg &= ~I40E_PRTRPB_SLW_SLW_MASK;\n\t\treg |= (new_val << I40E_PRTRPB_SLW_SLW_SHIFT) &\n\t\t\tI40E_PRTRPB_SLW_SLW_MASK;\n\t\twr32(hw, I40E_PRTRPB_SLW, reg);\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\told_val = old_pb_cfg->shared_pool_low_thresh[i];\n\t\tnew_val = new_pb_cfg->shared_pool_low_thresh[i];\n\t\tif (new_val > old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_SLT(i));\n\t\t\treg &= ~I40E_PRTRPB_SLT_SLT_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_SLT_SLT_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_SLT_SLT_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_SLT(i), reg);\n\t\t}\n\n\t\told_val = old_pb_cfg->tc_pool_low_wm[i];\n\t\tnew_val = new_pb_cfg->tc_pool_low_wm[i];\n\t\tif (new_val > old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_DLW(i));\n\t\t\treg &= ~I40E_PRTRPB_DLW_DLW_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_DLW_DLW_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_DLW_DLW_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_DLW(i), reg);\n\t\t}\n\t}\n\n\t \n\told_val = old_pb_cfg->shared_pool_high_wm;\n\tnew_val = new_pb_cfg->shared_pool_high_wm;\n\tif (new_val > old_val) {\n\t\treg = rd32(hw, I40E_PRTRPB_SHW);\n\t\treg &= ~I40E_PRTRPB_SHW_SHW_MASK;\n\t\treg |= (new_val << I40E_PRTRPB_SHW_SHW_SHIFT) &\n\t\t\tI40E_PRTRPB_SHW_SHW_MASK;\n\t\twr32(hw, I40E_PRTRPB_SHW, reg);\n\t}\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\told_val = old_pb_cfg->shared_pool_high_thresh[i];\n\t\tnew_val = new_pb_cfg->shared_pool_high_thresh[i];\n\t\tif (new_val > old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_SHT(i));\n\t\t\treg &= ~I40E_PRTRPB_SHT_SHT_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_SHT_SHT_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_SHT_SHT_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_SHT(i), reg);\n\t\t}\n\n\t\told_val = old_pb_cfg->tc_pool_high_wm[i];\n\t\tnew_val = new_pb_cfg->tc_pool_high_wm[i];\n\t\tif (new_val > old_val) {\n\t\t\treg = rd32(hw, I40E_PRTRPB_DHW(i));\n\t\t\treg &= ~I40E_PRTRPB_DHW_DHW_TCN_MASK;\n\t\t\treg |= (new_val << I40E_PRTRPB_DHW_DHW_TCN_SHIFT) &\n\t\t\t\tI40E_PRTRPB_DHW_DHW_TCN_MASK;\n\t\t\twr32(hw, I40E_PRTRPB_DHW(i), reg);\n\t\t}\n\t}\n}\n\n \nstatic int _i40e_read_lldp_cfg(struct i40e_hw *hw,\n\t\t\t       struct i40e_lldp_variables *lldp_cfg,\n\t\t\t       u8 module, u32 word_offset)\n{\n\tu32 address, offset = (2 * word_offset);\n\t__le16 raw_mem;\n\tint ret;\n\tu16 mem;\n\n\tret = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i40e_aq_read_nvm(hw, 0x0, module * 2, sizeof(raw_mem), &raw_mem,\n\t\t\t       true, NULL);\n\ti40e_release_nvm(hw);\n\tif (ret)\n\t\treturn ret;\n\n\tmem = le16_to_cpu(raw_mem);\n\t \n\tif (mem & I40E_PTR_TYPE)\n\t\taddress = (0x7FFF & mem) * 4096;\n\telse\n\t\taddress = (0x7FFF & mem) * 2;\n\n\tret = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\tif (ret)\n\t\tgoto err_lldp_cfg;\n\n\tret = i40e_aq_read_nvm(hw, module, offset, sizeof(raw_mem), &raw_mem,\n\t\t\t       true, NULL);\n\ti40e_release_nvm(hw);\n\tif (ret)\n\t\treturn ret;\n\n\tmem = le16_to_cpu(raw_mem);\n\toffset = mem + word_offset;\n\toffset *= 2;\n\n\tret = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\tif (ret)\n\t\tgoto err_lldp_cfg;\n\n\tret = i40e_aq_read_nvm(hw, 0, address + offset,\n\t\t\t       sizeof(struct i40e_lldp_variables), lldp_cfg,\n\t\t\t       true, NULL);\n\ti40e_release_nvm(hw);\n\nerr_lldp_cfg:\n\treturn ret;\n}\n\n \nint i40e_read_lldp_cfg(struct i40e_hw *hw,\n\t\t       struct i40e_lldp_variables *lldp_cfg)\n{\n\tint ret = 0;\n\tu32 mem;\n\n\tif (!lldp_cfg)\n\t\treturn -EINVAL;\n\n\tret = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i40e_aq_read_nvm(hw, I40E_SR_NVM_CONTROL_WORD, 0, sizeof(mem),\n\t\t\t       &mem, true, NULL);\n\ti40e_release_nvm(hw);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (mem & I40E_SR_NVM_MAP_STRUCTURE_TYPE) {\n\t\t \n\t\tret = _i40e_read_lldp_cfg(hw, lldp_cfg, I40E_SR_EMP_MODULE_PTR,\n\t\t\t\t\t  I40E_SR_LLDP_CFG_PTR);\n\t} else {\n\t\t \n\t\tret = _i40e_read_lldp_cfg(hw, lldp_cfg, I40E_EMP_MODULE_PTR,\n\t\t\t\t\t  I40E_NVM_LLDP_CFG_PTR);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}