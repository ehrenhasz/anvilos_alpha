{
  "module_name": "i40e_adminq.c",
  "hash_id": "5d069669bc0bf14b47eebc98f92841d059a683b128a9de3a1651daac49d8a51c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_adminq.c",
  "human_readable_source": "\n \n\n#include \"i40e_type.h\"\n#include \"i40e_register.h\"\n#include \"i40e_adminq.h\"\n#include \"i40e_prototype.h\"\n\nstatic void i40e_resume_aq(struct i40e_hw *hw);\n\n \nstatic void i40e_adminq_init_regs(struct i40e_hw *hw)\n{\n\t \n\tif (i40e_is_vf(hw)) {\n\t\thw->aq.asq.tail = I40E_VF_ATQT1;\n\t\thw->aq.asq.head = I40E_VF_ATQH1;\n\t\thw->aq.asq.len  = I40E_VF_ATQLEN1;\n\t\thw->aq.asq.bal  = I40E_VF_ATQBAL1;\n\t\thw->aq.asq.bah  = I40E_VF_ATQBAH1;\n\t\thw->aq.arq.tail = I40E_VF_ARQT1;\n\t\thw->aq.arq.head = I40E_VF_ARQH1;\n\t\thw->aq.arq.len  = I40E_VF_ARQLEN1;\n\t\thw->aq.arq.bal  = I40E_VF_ARQBAL1;\n\t\thw->aq.arq.bah  = I40E_VF_ARQBAH1;\n\t} else {\n\t\thw->aq.asq.tail = I40E_PF_ATQT;\n\t\thw->aq.asq.head = I40E_PF_ATQH;\n\t\thw->aq.asq.len  = I40E_PF_ATQLEN;\n\t\thw->aq.asq.bal  = I40E_PF_ATQBAL;\n\t\thw->aq.asq.bah  = I40E_PF_ATQBAH;\n\t\thw->aq.arq.tail = I40E_PF_ARQT;\n\t\thw->aq.arq.head = I40E_PF_ARQH;\n\t\thw->aq.arq.len  = I40E_PF_ARQLEN;\n\t\thw->aq.arq.bal  = I40E_PF_ARQBAL;\n\t\thw->aq.arq.bah  = I40E_PF_ARQBAH;\n\t}\n}\n\n \nstatic int i40e_alloc_adminq_asq_ring(struct i40e_hw *hw)\n{\n\tint ret_code;\n\n\tret_code = i40e_allocate_dma_mem(hw, &hw->aq.asq.desc_buf,\n\t\t\t\t\t i40e_mem_atq_ring,\n\t\t\t\t\t (hw->aq.num_asq_entries *\n\t\t\t\t\t sizeof(struct i40e_aq_desc)),\n\t\t\t\t\t I40E_ADMINQ_DESC_ALIGNMENT);\n\tif (ret_code)\n\t\treturn ret_code;\n\n\tret_code = i40e_allocate_virt_mem(hw, &hw->aq.asq.cmd_buf,\n\t\t\t\t\t  (hw->aq.num_asq_entries *\n\t\t\t\t\t  sizeof(struct i40e_asq_cmd_details)));\n\tif (ret_code) {\n\t\ti40e_free_dma_mem(hw, &hw->aq.asq.desc_buf);\n\t\treturn ret_code;\n\t}\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_alloc_adminq_arq_ring(struct i40e_hw *hw)\n{\n\tint ret_code;\n\n\tret_code = i40e_allocate_dma_mem(hw, &hw->aq.arq.desc_buf,\n\t\t\t\t\t i40e_mem_arq_ring,\n\t\t\t\t\t (hw->aq.num_arq_entries *\n\t\t\t\t\t sizeof(struct i40e_aq_desc)),\n\t\t\t\t\t I40E_ADMINQ_DESC_ALIGNMENT);\n\n\treturn ret_code;\n}\n\n \nstatic void i40e_free_adminq_asq(struct i40e_hw *hw)\n{\n\ti40e_free_dma_mem(hw, &hw->aq.asq.desc_buf);\n}\n\n \nstatic void i40e_free_adminq_arq(struct i40e_hw *hw)\n{\n\ti40e_free_dma_mem(hw, &hw->aq.arq.desc_buf);\n}\n\n \nstatic int i40e_alloc_arq_bufs(struct i40e_hw *hw)\n{\n\tstruct i40e_aq_desc *desc;\n\tstruct i40e_dma_mem *bi;\n\tint ret_code;\n\tint i;\n\n\t \n\n\t \n\tret_code = i40e_allocate_virt_mem(hw, &hw->aq.arq.dma_head,\n\t\t(hw->aq.num_arq_entries * sizeof(struct i40e_dma_mem)));\n\tif (ret_code)\n\t\tgoto alloc_arq_bufs;\n\thw->aq.arq.r.arq_bi = (struct i40e_dma_mem *)hw->aq.arq.dma_head.va;\n\n\t \n\tfor (i = 0; i < hw->aq.num_arq_entries; i++) {\n\t\tbi = &hw->aq.arq.r.arq_bi[i];\n\t\tret_code = i40e_allocate_dma_mem(hw, bi,\n\t\t\t\t\t\t i40e_mem_arq_buf,\n\t\t\t\t\t\t hw->aq.arq_buf_size,\n\t\t\t\t\t\t I40E_ADMINQ_DESC_ALIGNMENT);\n\t\tif (ret_code)\n\t\t\tgoto unwind_alloc_arq_bufs;\n\n\t\t \n\t\tdesc = I40E_ADMINQ_DESC(hw->aq.arq, i);\n\n\t\tdesc->flags = cpu_to_le16(I40E_AQ_FLAG_BUF);\n\t\tif (hw->aq.arq_buf_size > I40E_AQ_LARGE_BUF)\n\t\t\tdesc->flags |= cpu_to_le16(I40E_AQ_FLAG_LB);\n\t\tdesc->opcode = 0;\n\t\t \n\t\tdesc->datalen = cpu_to_le16((u16)bi->size);\n\t\tdesc->retval = 0;\n\t\tdesc->cookie_high = 0;\n\t\tdesc->cookie_low = 0;\n\t\tdesc->params.external.addr_high =\n\t\t\tcpu_to_le32(upper_32_bits(bi->pa));\n\t\tdesc->params.external.addr_low =\n\t\t\tcpu_to_le32(lower_32_bits(bi->pa));\n\t\tdesc->params.external.param0 = 0;\n\t\tdesc->params.external.param1 = 0;\n\t}\n\nalloc_arq_bufs:\n\treturn ret_code;\n\nunwind_alloc_arq_bufs:\n\t \n\ti--;\n\tfor (; i >= 0; i--)\n\t\ti40e_free_dma_mem(hw, &hw->aq.arq.r.arq_bi[i]);\n\ti40e_free_virt_mem(hw, &hw->aq.arq.dma_head);\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_alloc_asq_bufs(struct i40e_hw *hw)\n{\n\tstruct i40e_dma_mem *bi;\n\tint ret_code;\n\tint i;\n\n\t \n\tret_code = i40e_allocate_virt_mem(hw, &hw->aq.asq.dma_head,\n\t\t(hw->aq.num_asq_entries * sizeof(struct i40e_dma_mem)));\n\tif (ret_code)\n\t\tgoto alloc_asq_bufs;\n\thw->aq.asq.r.asq_bi = (struct i40e_dma_mem *)hw->aq.asq.dma_head.va;\n\n\t \n\tfor (i = 0; i < hw->aq.num_asq_entries; i++) {\n\t\tbi = &hw->aq.asq.r.asq_bi[i];\n\t\tret_code = i40e_allocate_dma_mem(hw, bi,\n\t\t\t\t\t\t i40e_mem_asq_buf,\n\t\t\t\t\t\t hw->aq.asq_buf_size,\n\t\t\t\t\t\t I40E_ADMINQ_DESC_ALIGNMENT);\n\t\tif (ret_code)\n\t\t\tgoto unwind_alloc_asq_bufs;\n\t}\nalloc_asq_bufs:\n\treturn ret_code;\n\nunwind_alloc_asq_bufs:\n\t \n\ti--;\n\tfor (; i >= 0; i--)\n\t\ti40e_free_dma_mem(hw, &hw->aq.asq.r.asq_bi[i]);\n\ti40e_free_virt_mem(hw, &hw->aq.asq.dma_head);\n\n\treturn ret_code;\n}\n\n \nstatic void i40e_free_arq_bufs(struct i40e_hw *hw)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < hw->aq.num_arq_entries; i++)\n\t\ti40e_free_dma_mem(hw, &hw->aq.arq.r.arq_bi[i]);\n\n\t \n\ti40e_free_dma_mem(hw, &hw->aq.arq.desc_buf);\n\n\t \n\ti40e_free_virt_mem(hw, &hw->aq.arq.dma_head);\n}\n\n \nstatic void i40e_free_asq_bufs(struct i40e_hw *hw)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < hw->aq.num_asq_entries; i++)\n\t\tif (hw->aq.asq.r.asq_bi[i].pa)\n\t\t\ti40e_free_dma_mem(hw, &hw->aq.asq.r.asq_bi[i]);\n\n\t \n\ti40e_free_virt_mem(hw, &hw->aq.asq.cmd_buf);\n\n\t \n\ti40e_free_dma_mem(hw, &hw->aq.asq.desc_buf);\n\n\t \n\ti40e_free_virt_mem(hw, &hw->aq.asq.dma_head);\n}\n\n \nstatic int i40e_config_asq_regs(struct i40e_hw *hw)\n{\n\tint ret_code = 0;\n\tu32 reg = 0;\n\n\t \n\twr32(hw, hw->aq.asq.head, 0);\n\twr32(hw, hw->aq.asq.tail, 0);\n\n\t \n\twr32(hw, hw->aq.asq.len, (hw->aq.num_asq_entries |\n\t\t\t\t  I40E_PF_ATQLEN_ATQENABLE_MASK));\n\twr32(hw, hw->aq.asq.bal, lower_32_bits(hw->aq.asq.desc_buf.pa));\n\twr32(hw, hw->aq.asq.bah, upper_32_bits(hw->aq.asq.desc_buf.pa));\n\n\t \n\treg = rd32(hw, hw->aq.asq.bal);\n\tif (reg != lower_32_bits(hw->aq.asq.desc_buf.pa))\n\t\tret_code = -EIO;\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_config_arq_regs(struct i40e_hw *hw)\n{\n\tint ret_code = 0;\n\tu32 reg = 0;\n\n\t \n\twr32(hw, hw->aq.arq.head, 0);\n\twr32(hw, hw->aq.arq.tail, 0);\n\n\t \n\twr32(hw, hw->aq.arq.len, (hw->aq.num_arq_entries |\n\t\t\t\t  I40E_PF_ARQLEN_ARQENABLE_MASK));\n\twr32(hw, hw->aq.arq.bal, lower_32_bits(hw->aq.arq.desc_buf.pa));\n\twr32(hw, hw->aq.arq.bah, upper_32_bits(hw->aq.arq.desc_buf.pa));\n\n\t \n\twr32(hw, hw->aq.arq.tail, hw->aq.num_arq_entries - 1);\n\n\t \n\treg = rd32(hw, hw->aq.arq.bal);\n\tif (reg != lower_32_bits(hw->aq.arq.desc_buf.pa))\n\t\tret_code = -EIO;\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_init_asq(struct i40e_hw *hw)\n{\n\tint ret_code = 0;\n\n\tif (hw->aq.asq.count > 0) {\n\t\t \n\t\tret_code = -EBUSY;\n\t\tgoto init_adminq_exit;\n\t}\n\n\t \n\tif ((hw->aq.num_asq_entries == 0) ||\n\t    (hw->aq.asq_buf_size == 0)) {\n\t\tret_code = -EIO;\n\t\tgoto init_adminq_exit;\n\t}\n\n\thw->aq.asq.next_to_use = 0;\n\thw->aq.asq.next_to_clean = 0;\n\n\t \n\tret_code = i40e_alloc_adminq_asq_ring(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_exit;\n\n\t \n\tret_code = i40e_alloc_asq_bufs(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_rings;\n\n\t \n\tret_code = i40e_config_asq_regs(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_rings;\n\n\t \n\thw->aq.asq.count = hw->aq.num_asq_entries;\n\tgoto init_adminq_exit;\n\ninit_adminq_free_rings:\n\ti40e_free_adminq_asq(hw);\n\ninit_adminq_exit:\n\treturn ret_code;\n}\n\n \nstatic int i40e_init_arq(struct i40e_hw *hw)\n{\n\tint ret_code = 0;\n\n\tif (hw->aq.arq.count > 0) {\n\t\t \n\t\tret_code = -EBUSY;\n\t\tgoto init_adminq_exit;\n\t}\n\n\t \n\tif ((hw->aq.num_arq_entries == 0) ||\n\t    (hw->aq.arq_buf_size == 0)) {\n\t\tret_code = -EIO;\n\t\tgoto init_adminq_exit;\n\t}\n\n\thw->aq.arq.next_to_use = 0;\n\thw->aq.arq.next_to_clean = 0;\n\n\t \n\tret_code = i40e_alloc_adminq_arq_ring(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_exit;\n\n\t \n\tret_code = i40e_alloc_arq_bufs(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_rings;\n\n\t \n\tret_code = i40e_config_arq_regs(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_rings;\n\n\t \n\thw->aq.arq.count = hw->aq.num_arq_entries;\n\tgoto init_adminq_exit;\n\ninit_adminq_free_rings:\n\ti40e_free_adminq_arq(hw);\n\ninit_adminq_exit:\n\treturn ret_code;\n}\n\n \nstatic int i40e_shutdown_asq(struct i40e_hw *hw)\n{\n\tint ret_code = 0;\n\n\tmutex_lock(&hw->aq.asq_mutex);\n\n\tif (hw->aq.asq.count == 0) {\n\t\tret_code = -EBUSY;\n\t\tgoto shutdown_asq_out;\n\t}\n\n\t \n\twr32(hw, hw->aq.asq.head, 0);\n\twr32(hw, hw->aq.asq.tail, 0);\n\twr32(hw, hw->aq.asq.len, 0);\n\twr32(hw, hw->aq.asq.bal, 0);\n\twr32(hw, hw->aq.asq.bah, 0);\n\n\thw->aq.asq.count = 0;  \n\n\t \n\ti40e_free_asq_bufs(hw);\n\nshutdown_asq_out:\n\tmutex_unlock(&hw->aq.asq_mutex);\n\treturn ret_code;\n}\n\n \nstatic int i40e_shutdown_arq(struct i40e_hw *hw)\n{\n\tint ret_code = 0;\n\n\tmutex_lock(&hw->aq.arq_mutex);\n\n\tif (hw->aq.arq.count == 0) {\n\t\tret_code = -EBUSY;\n\t\tgoto shutdown_arq_out;\n\t}\n\n\t \n\twr32(hw, hw->aq.arq.head, 0);\n\twr32(hw, hw->aq.arq.tail, 0);\n\twr32(hw, hw->aq.arq.len, 0);\n\twr32(hw, hw->aq.arq.bal, 0);\n\twr32(hw, hw->aq.arq.bah, 0);\n\n\thw->aq.arq.count = 0;  \n\n\t \n\ti40e_free_arq_bufs(hw);\n\nshutdown_arq_out:\n\tmutex_unlock(&hw->aq.arq_mutex);\n\treturn ret_code;\n}\n\n \nstatic void i40e_set_hw_flags(struct i40e_hw *hw)\n{\n\tstruct i40e_adminq_info *aq = &hw->aq;\n\n\thw->flags = 0;\n\n\tswitch (hw->mac.type) {\n\tcase I40E_MAC_XL710:\n\t\tif (aq->api_maj_ver > 1 ||\n\t\t    (aq->api_maj_ver == 1 &&\n\t\t     aq->api_min_ver >= I40E_MINOR_VER_GET_LINK_INFO_XL710)) {\n\t\t\thw->flags |= I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE;\n\t\t\thw->flags |= I40E_HW_FLAG_FW_LLDP_STOPPABLE;\n\t\t\t \n\t\t\thw->flags |= I40E_HW_FLAG_802_1AD_CAPABLE;\n\t\t}\n\t\tbreak;\n\tcase I40E_MAC_X722:\n\t\thw->flags |= I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE |\n\t\t\t     I40E_HW_FLAG_NVM_READ_REQUIRES_LOCK;\n\n\t\tif (aq->api_maj_ver > 1 ||\n\t\t    (aq->api_maj_ver == 1 &&\n\t\t     aq->api_min_ver >= I40E_MINOR_VER_FW_LLDP_STOPPABLE_X722))\n\t\t\thw->flags |= I40E_HW_FLAG_FW_LLDP_STOPPABLE;\n\n\t\tif (aq->api_maj_ver > 1 ||\n\t\t    (aq->api_maj_ver == 1 &&\n\t\t     aq->api_min_ver >= I40E_MINOR_VER_GET_LINK_INFO_X722))\n\t\t\thw->flags |= I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE;\n\n\t\tif (aq->api_maj_ver > 1 ||\n\t\t    (aq->api_maj_ver == 1 &&\n\t\t     aq->api_min_ver >= I40E_MINOR_VER_FW_REQUEST_FEC_X722))\n\t\t\thw->flags |= I40E_HW_FLAG_X722_FEC_REQUEST_CAPABLE;\n\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (aq->api_maj_ver > 1 ||\n\t    (aq->api_maj_ver == 1 &&\n\t     aq->api_min_ver >= 5))\n\t\thw->flags |= I40E_HW_FLAG_NVM_READ_REQUIRES_LOCK;\n\n\tif (aq->api_maj_ver > 1 ||\n\t    (aq->api_maj_ver == 1 &&\n\t     aq->api_min_ver >= 8)) {\n\t\thw->flags |= I40E_HW_FLAG_FW_LLDP_PERSISTENT;\n\t\thw->flags |= I40E_HW_FLAG_DROP_MODE;\n\t}\n\n\tif (aq->api_maj_ver > 1 ||\n\t    (aq->api_maj_ver == 1 &&\n\t     aq->api_min_ver >= 9))\n\t\thw->flags |= I40E_HW_FLAG_AQ_PHY_ACCESS_EXTENDED;\n}\n\n \nint i40e_init_adminq(struct i40e_hw *hw)\n{\n\tu16 cfg_ptr, oem_hi, oem_lo;\n\tu16 eetrack_lo, eetrack_hi;\n\tint retry = 0;\n\tint ret_code;\n\n\t \n\tif ((hw->aq.num_arq_entries == 0) ||\n\t    (hw->aq.num_asq_entries == 0) ||\n\t    (hw->aq.arq_buf_size == 0) ||\n\t    (hw->aq.asq_buf_size == 0)) {\n\t\tret_code = -EIO;\n\t\tgoto init_adminq_exit;\n\t}\n\n\t \n\ti40e_adminq_init_regs(hw);\n\n\t \n\thw->aq.asq_cmd_timeout = I40E_ASQ_CMD_TIMEOUT;\n\n\t \n\tret_code = i40e_init_asq(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_destroy_locks;\n\n\t \n\tret_code = i40e_init_arq(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_asq;\n\n\t \n\tdo {\n\t\tret_code = i40e_aq_get_firmware_version(hw,\n\t\t\t\t\t\t\t&hw->aq.fw_maj_ver,\n\t\t\t\t\t\t\t&hw->aq.fw_min_ver,\n\t\t\t\t\t\t\t&hw->aq.fw_build,\n\t\t\t\t\t\t\t&hw->aq.api_maj_ver,\n\t\t\t\t\t\t\t&hw->aq.api_min_ver,\n\t\t\t\t\t\t\tNULL);\n\t\tif (ret_code != -EIO)\n\t\t\tbreak;\n\t\tretry++;\n\t\tmsleep(100);\n\t\ti40e_resume_aq(hw);\n\t} while (retry < 10);\n\tif (ret_code != 0)\n\t\tgoto init_adminq_free_arq;\n\n\t \n\ti40e_set_hw_flags(hw);\n\n\t \n\ti40e_read_nvm_word(hw, I40E_SR_NVM_DEV_STARTER_VERSION,\n\t\t\t   &hw->nvm.version);\n\ti40e_read_nvm_word(hw, I40E_SR_NVM_EETRACK_LO, &eetrack_lo);\n\ti40e_read_nvm_word(hw, I40E_SR_NVM_EETRACK_HI, &eetrack_hi);\n\thw->nvm.eetrack = (eetrack_hi << 16) | eetrack_lo;\n\ti40e_read_nvm_word(hw, I40E_SR_BOOT_CONFIG_PTR, &cfg_ptr);\n\ti40e_read_nvm_word(hw, (cfg_ptr + I40E_NVM_OEM_VER_OFF),\n\t\t\t   &oem_hi);\n\ti40e_read_nvm_word(hw, (cfg_ptr + (I40E_NVM_OEM_VER_OFF + 1)),\n\t\t\t   &oem_lo);\n\thw->nvm.oem_ver = ((u32)oem_hi << 16) | oem_lo;\n\n\tif (hw->mac.type == I40E_MAC_XL710 &&\n\t    hw->aq.api_maj_ver == I40E_FW_API_VERSION_MAJOR &&\n\t    hw->aq.api_min_ver >= I40E_MINOR_VER_GET_LINK_INFO_XL710) {\n\t\thw->flags |= I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE;\n\t\thw->flags |= I40E_HW_FLAG_FW_LLDP_STOPPABLE;\n\t}\n\tif (hw->mac.type == I40E_MAC_X722 &&\n\t    hw->aq.api_maj_ver == I40E_FW_API_VERSION_MAJOR &&\n\t    hw->aq.api_min_ver >= I40E_MINOR_VER_FW_LLDP_STOPPABLE_X722) {\n\t\thw->flags |= I40E_HW_FLAG_FW_LLDP_STOPPABLE;\n\t}\n\n\t \n\tif (hw->aq.api_maj_ver > 1 ||\n\t    (hw->aq.api_maj_ver == 1 &&\n\t     hw->aq.api_min_ver >= 7))\n\t\thw->flags |= I40E_HW_FLAG_802_1AD_CAPABLE;\n\n\tif (hw->aq.api_maj_ver > I40E_FW_API_VERSION_MAJOR) {\n\t\tret_code = -EIO;\n\t\tgoto init_adminq_free_arq;\n\t}\n\n\t \n\ti40e_aq_release_resource(hw, I40E_NVM_RESOURCE_ID, 0, NULL);\n\thw->nvm_release_on_done = false;\n\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\n\tret_code = 0;\n\n\t \n\tgoto init_adminq_exit;\n\ninit_adminq_free_arq:\n\ti40e_shutdown_arq(hw);\ninit_adminq_free_asq:\n\ti40e_shutdown_asq(hw);\ninit_adminq_destroy_locks:\n\ninit_adminq_exit:\n\treturn ret_code;\n}\n\n \nvoid i40e_shutdown_adminq(struct i40e_hw *hw)\n{\n\tif (i40e_check_asq_alive(hw))\n\t\ti40e_aq_queue_shutdown(hw, true);\n\n\ti40e_shutdown_asq(hw);\n\ti40e_shutdown_arq(hw);\n\n\tif (hw->nvm_buff.va)\n\t\ti40e_free_virt_mem(hw, &hw->nvm_buff);\n}\n\n \nstatic u16 i40e_clean_asq(struct i40e_hw *hw)\n{\n\tstruct i40e_adminq_ring *asq = &(hw->aq.asq);\n\tstruct i40e_asq_cmd_details *details;\n\tu16 ntc = asq->next_to_clean;\n\tstruct i40e_aq_desc desc_cb;\n\tstruct i40e_aq_desc *desc;\n\n\tdesc = I40E_ADMINQ_DESC(*asq, ntc);\n\tdetails = I40E_ADMINQ_DETAILS(*asq, ntc);\n\twhile (rd32(hw, hw->aq.asq.head) != ntc) {\n\t\ti40e_debug(hw, I40E_DEBUG_AQ_COMMAND,\n\t\t\t   \"ntc %d head %d.\\n\", ntc, rd32(hw, hw->aq.asq.head));\n\n\t\tif (details->callback) {\n\t\t\tI40E_ADMINQ_CALLBACK cb_func =\n\t\t\t\t\t(I40E_ADMINQ_CALLBACK)details->callback;\n\t\t\tdesc_cb = *desc;\n\t\t\tcb_func(hw, &desc_cb);\n\t\t}\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\tmemset(details, 0, sizeof(*details));\n\t\tntc++;\n\t\tif (ntc == asq->count)\n\t\t\tntc = 0;\n\t\tdesc = I40E_ADMINQ_DESC(*asq, ntc);\n\t\tdetails = I40E_ADMINQ_DETAILS(*asq, ntc);\n\t}\n\n\tasq->next_to_clean = ntc;\n\n\treturn I40E_DESC_UNUSED(asq);\n}\n\n \nstatic bool i40e_asq_done(struct i40e_hw *hw)\n{\n\t \n\treturn rd32(hw, hw->aq.asq.head) == hw->aq.asq.next_to_use;\n\n}\n\n \nstatic int\ni40e_asq_send_command_atomic_exec(struct i40e_hw *hw,\n\t\t\t\t  struct i40e_aq_desc *desc,\n\t\t\t\t  void *buff,  \n\t\t\t\t  u16  buff_size,\n\t\t\t\t  struct i40e_asq_cmd_details *cmd_details,\n\t\t\t\t  bool is_atomic_context)\n{\n\tstruct i40e_dma_mem *dma_buff = NULL;\n\tstruct i40e_asq_cmd_details *details;\n\tstruct i40e_aq_desc *desc_on_ring;\n\tbool cmd_completed = false;\n\tu16  retval = 0;\n\tint status = 0;\n\tu32  val = 0;\n\n\tif (hw->aq.asq.count == 0) {\n\t\ti40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Admin queue not initialized.\\n\");\n\t\tstatus = -EIO;\n\t\tgoto asq_send_command_error;\n\t}\n\n\thw->aq.asq_last_status = I40E_AQ_RC_OK;\n\n\tval = rd32(hw, hw->aq.asq.head);\n\tif (val >= hw->aq.num_asq_entries) {\n\t\ti40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: head overrun at %d\\n\", val);\n\t\tstatus = -ENOSPC;\n\t\tgoto asq_send_command_error;\n\t}\n\n\tdetails = I40E_ADMINQ_DETAILS(hw->aq.asq, hw->aq.asq.next_to_use);\n\tif (cmd_details) {\n\t\t*details = *cmd_details;\n\n\t\t \n\t\tif (details->cookie) {\n\t\t\tdesc->cookie_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(details->cookie));\n\t\t\tdesc->cookie_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(details->cookie));\n\t\t}\n\t} else {\n\t\tmemset(details, 0, sizeof(struct i40e_asq_cmd_details));\n\t}\n\n\t \n\tdesc->flags &= ~cpu_to_le16(details->flags_dis);\n\tdesc->flags |= cpu_to_le16(details->flags_ena);\n\n\tif (buff_size > hw->aq.asq_buf_size) {\n\t\ti40e_debug(hw,\n\t\t\t   I40E_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Invalid buffer size: %d.\\n\",\n\t\t\t   buff_size);\n\t\tstatus = -EINVAL;\n\t\tgoto asq_send_command_error;\n\t}\n\n\tif (details->postpone && !details->async) {\n\t\ti40e_debug(hw,\n\t\t\t   I40E_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Async flag not set along with postpone flag\");\n\t\tstatus = -EINVAL;\n\t\tgoto asq_send_command_error;\n\t}\n\n\t \n\t \n\tif (i40e_clean_asq(hw) == 0) {\n\t\ti40e_debug(hw,\n\t\t\t   I40E_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Error queue is full.\\n\");\n\t\tstatus = -ENOSPC;\n\t\tgoto asq_send_command_error;\n\t}\n\n\t \n\tdesc_on_ring = I40E_ADMINQ_DESC(hw->aq.asq, hw->aq.asq.next_to_use);\n\n\t \n\t*desc_on_ring = *desc;\n\n\t \n\tif (buff != NULL) {\n\t\tdma_buff = &(hw->aq.asq.r.asq_bi[hw->aq.asq.next_to_use]);\n\t\t \n\t\tmemcpy(dma_buff->va, buff, buff_size);\n\t\tdesc_on_ring->datalen = cpu_to_le16(buff_size);\n\n\t\t \n\t\tdesc_on_ring->params.external.addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(dma_buff->pa));\n\t\tdesc_on_ring->params.external.addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_buff->pa));\n\t}\n\n\t \n\ti40e_debug(hw, I40E_DEBUG_AQ_COMMAND, \"AQTX: desc and buffer:\\n\");\n\ti40e_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc_on_ring,\n\t\t      buff, buff_size);\n\t(hw->aq.asq.next_to_use)++;\n\tif (hw->aq.asq.next_to_use == hw->aq.asq.count)\n\t\thw->aq.asq.next_to_use = 0;\n\tif (!details->postpone)\n\t\twr32(hw, hw->aq.asq.tail, hw->aq.asq.next_to_use);\n\n\t \n\tif (!details->async && !details->postpone) {\n\t\tu32 total_delay = 0;\n\n\t\tdo {\n\t\t\t \n\t\t\tif (i40e_asq_done(hw))\n\t\t\t\tbreak;\n\n\t\t\tif (is_atomic_context)\n\t\t\t\tudelay(50);\n\t\t\telse\n\t\t\t\tusleep_range(40, 60);\n\n\t\t\ttotal_delay += 50;\n\t\t} while (total_delay < hw->aq.asq_cmd_timeout);\n\t}\n\n\t \n\tif (i40e_asq_done(hw)) {\n\t\t*desc = *desc_on_ring;\n\t\tif (buff != NULL)\n\t\t\tmemcpy(buff, dma_buff->va, buff_size);\n\t\tretval = le16_to_cpu(desc->retval);\n\t\tif (retval != 0) {\n\t\t\ti40e_debug(hw,\n\t\t\t\t   I40E_DEBUG_AQ_MESSAGE,\n\t\t\t\t   \"AQTX: Command completed with error 0x%X.\\n\",\n\t\t\t\t   retval);\n\n\t\t\t \n\t\t\tretval &= 0xff;\n\t\t}\n\t\tcmd_completed = true;\n\t\tif ((enum i40e_admin_queue_err)retval == I40E_AQ_RC_OK)\n\t\t\tstatus = 0;\n\t\telse if ((enum i40e_admin_queue_err)retval == I40E_AQ_RC_EBUSY)\n\t\t\tstatus = -EBUSY;\n\t\telse\n\t\t\tstatus = -EIO;\n\t\thw->aq.asq_last_status = (enum i40e_admin_queue_err)retval;\n\t}\n\n\ti40e_debug(hw, I40E_DEBUG_AQ_COMMAND,\n\t\t   \"AQTX: desc and buffer writeback:\\n\");\n\ti40e_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, buff, buff_size);\n\n\t \n\tif (details->wb_desc)\n\t\t*details->wb_desc = *desc_on_ring;\n\n\t \n\tif ((!cmd_completed) &&\n\t    (!details->async && !details->postpone)) {\n\t\tif (rd32(hw, hw->aq.asq.len) & I40E_GL_ATQLEN_ATQCRIT_MASK) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\n\t\t\t\t   \"AQTX: AQ Critical error.\\n\");\n\t\t\tstatus = -EIO;\n\t\t} else {\n\t\t\ti40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\n\t\t\t\t   \"AQTX: Writeback timeout.\\n\");\n\t\t\tstatus = -EIO;\n\t\t}\n\t}\n\nasq_send_command_error:\n\treturn status;\n}\n\n \nint\ni40e_asq_send_command_atomic(struct i40e_hw *hw,\n\t\t\t     struct i40e_aq_desc *desc,\n\t\t\t     void *buff,  \n\t\t\t     u16  buff_size,\n\t\t\t     struct i40e_asq_cmd_details *cmd_details,\n\t\t\t     bool is_atomic_context)\n{\n\tint status;\n\n\tmutex_lock(&hw->aq.asq_mutex);\n\tstatus = i40e_asq_send_command_atomic_exec(hw, desc, buff, buff_size,\n\t\t\t\t\t\t   cmd_details,\n\t\t\t\t\t\t   is_atomic_context);\n\n\tmutex_unlock(&hw->aq.asq_mutex);\n\treturn status;\n}\n\nint\ni40e_asq_send_command(struct i40e_hw *hw, struct i40e_aq_desc *desc,\n\t\t      void *buff,   u16  buff_size,\n\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_asq_send_command_atomic(hw, desc, buff, buff_size,\n\t\t\t\t\t    cmd_details, false);\n}\n\n \nint\ni40e_asq_send_command_atomic_v2(struct i40e_hw *hw,\n\t\t\t\tstruct i40e_aq_desc *desc,\n\t\t\t\tvoid *buff,  \n\t\t\t\tu16  buff_size,\n\t\t\t\tstruct i40e_asq_cmd_details *cmd_details,\n\t\t\t\tbool is_atomic_context,\n\t\t\t\tenum i40e_admin_queue_err *aq_status)\n{\n\tint status;\n\n\tmutex_lock(&hw->aq.asq_mutex);\n\tstatus = i40e_asq_send_command_atomic_exec(hw, desc, buff,\n\t\t\t\t\t\t   buff_size,\n\t\t\t\t\t\t   cmd_details,\n\t\t\t\t\t\t   is_atomic_context);\n\tif (aq_status)\n\t\t*aq_status = hw->aq.asq_last_status;\n\tmutex_unlock(&hw->aq.asq_mutex);\n\treturn status;\n}\n\nint\ni40e_asq_send_command_v2(struct i40e_hw *hw, struct i40e_aq_desc *desc,\n\t\t\t void *buff,   u16  buff_size,\n\t\t\t struct i40e_asq_cmd_details *cmd_details,\n\t\t\t enum i40e_admin_queue_err *aq_status)\n{\n\treturn i40e_asq_send_command_atomic_v2(hw, desc, buff, buff_size,\n\t\t\t\t\t       cmd_details, true, aq_status);\n}\n\n \nvoid i40e_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc,\n\t\t\t\t       u16 opcode)\n{\n\t \n\tmemset((void *)desc, 0, sizeof(struct i40e_aq_desc));\n\tdesc->opcode = cpu_to_le16(opcode);\n\tdesc->flags = cpu_to_le16(I40E_AQ_FLAG_SI);\n}\n\n \nint i40e_clean_arq_element(struct i40e_hw *hw,\n\t\t\t   struct i40e_arq_event_info *e,\n\t\t\t   u16 *pending)\n{\n\tu16 ntc = hw->aq.arq.next_to_clean;\n\tstruct i40e_aq_desc *desc;\n\tstruct i40e_dma_mem *bi;\n\tint ret_code = 0;\n\tu16 desc_idx;\n\tu16 datalen;\n\tu16 flags;\n\tu16 ntu;\n\n\t \n\tmemset(&e->desc, 0, sizeof(e->desc));\n\n\t \n\tmutex_lock(&hw->aq.arq_mutex);\n\n\tif (hw->aq.arq.count == 0) {\n\t\ti40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQRX: Admin queue not initialized.\\n\");\n\t\tret_code = -EIO;\n\t\tgoto clean_arq_element_err;\n\t}\n\n\t \n\tntu = rd32(hw, hw->aq.arq.head) & I40E_PF_ARQH_ARQH_MASK;\n\tif (ntu == ntc) {\n\t\t \n\t\tret_code = -EALREADY;\n\t\tgoto clean_arq_element_out;\n\t}\n\n\t \n\tdesc = I40E_ADMINQ_DESC(hw->aq.arq, ntc);\n\tdesc_idx = ntc;\n\n\thw->aq.arq_last_status =\n\t\t(enum i40e_admin_queue_err)le16_to_cpu(desc->retval);\n\tflags = le16_to_cpu(desc->flags);\n\tif (flags & I40E_AQ_FLAG_ERR) {\n\t\tret_code = -EIO;\n\t\ti40e_debug(hw,\n\t\t\t   I40E_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQRX: Event received with error 0x%X.\\n\",\n\t\t\t   hw->aq.arq_last_status);\n\t}\n\n\te->desc = *desc;\n\tdatalen = le16_to_cpu(desc->datalen);\n\te->msg_len = min(datalen, e->buf_len);\n\tif (e->msg_buf != NULL && (e->msg_len != 0))\n\t\tmemcpy(e->msg_buf, hw->aq.arq.r.arq_bi[desc_idx].va,\n\t\t       e->msg_len);\n\n\ti40e_debug(hw, I40E_DEBUG_AQ_COMMAND, \"AQRX: desc and buffer:\\n\");\n\ti40e_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, e->msg_buf,\n\t\t      hw->aq.arq_buf_size);\n\n\t \n\tbi = &hw->aq.arq.r.arq_bi[ntc];\n\tmemset((void *)desc, 0, sizeof(struct i40e_aq_desc));\n\n\tdesc->flags = cpu_to_le16(I40E_AQ_FLAG_BUF);\n\tif (hw->aq.arq_buf_size > I40E_AQ_LARGE_BUF)\n\t\tdesc->flags |= cpu_to_le16(I40E_AQ_FLAG_LB);\n\tdesc->datalen = cpu_to_le16((u16)bi->size);\n\tdesc->params.external.addr_high = cpu_to_le32(upper_32_bits(bi->pa));\n\tdesc->params.external.addr_low = cpu_to_le32(lower_32_bits(bi->pa));\n\n\t \n\twr32(hw, hw->aq.arq.tail, ntc);\n\t \n\tntc++;\n\tif (ntc == hw->aq.num_arq_entries)\n\t\tntc = 0;\n\thw->aq.arq.next_to_clean = ntc;\n\thw->aq.arq.next_to_use = ntu;\n\n\ti40e_nvmupd_check_wait_event(hw, le16_to_cpu(e->desc.opcode), &e->desc);\nclean_arq_element_out:\n\t \n\tif (pending)\n\t\t*pending = (ntc > ntu ? hw->aq.arq.count : 0) + (ntu - ntc);\nclean_arq_element_err:\n\tmutex_unlock(&hw->aq.arq_mutex);\n\n\treturn ret_code;\n}\n\nstatic void i40e_resume_aq(struct i40e_hw *hw)\n{\n\t \n\thw->aq.asq.next_to_use = 0;\n\thw->aq.asq.next_to_clean = 0;\n\n\ti40e_config_asq_regs(hw);\n\n\thw->aq.arq.next_to_use = 0;\n\thw->aq.arq.next_to_clean = 0;\n\n\ti40e_config_arq_regs(hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}