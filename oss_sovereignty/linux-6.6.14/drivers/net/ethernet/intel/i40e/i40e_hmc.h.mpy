{
  "module_name": "i40e_hmc.h",
  "hash_id": "2bb5409c16cdc08795423740e5caf3bddf4f6989dc24d94f4347f04c84e931da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_hmc.h",
  "human_readable_source": " \n \n\n#ifndef _I40E_HMC_H_\n#define _I40E_HMC_H_\n\n#define I40E_HMC_MAX_BP_COUNT 512\n\n \nstruct i40e_hw;\n\n#define I40E_HMC_INFO_SIGNATURE\t\t0x484D5347  \n#define I40E_HMC_PD_CNT_IN_SD\t\t512\n#define I40E_HMC_DIRECT_BP_SIZE\t\t0x200000  \n#define I40E_HMC_PAGED_BP_SIZE\t\t4096\n#define I40E_HMC_PD_BP_BUF_ALIGNMENT\t4096\n\nstruct i40e_hmc_obj_info {\n\tu64 base;\t \n\tu32 max_cnt;\t \n\tu32 cnt;\t \n\tu64 size;\t \n};\n\nenum i40e_sd_entry_type {\n\tI40E_SD_TYPE_INVALID = 0,\n\tI40E_SD_TYPE_PAGED   = 1,\n\tI40E_SD_TYPE_DIRECT  = 2\n};\n\nstruct i40e_hmc_bp {\n\tenum i40e_sd_entry_type entry_type;\n\tstruct i40e_dma_mem addr;  \n\tu32 sd_pd_index;\n\tu32 ref_cnt;\n};\n\nstruct i40e_hmc_pd_entry {\n\tstruct i40e_hmc_bp bp;\n\tu32 sd_index;\n\tbool rsrc_pg;\n\tbool valid;\n};\n\nstruct i40e_hmc_pd_table {\n\tstruct i40e_dma_mem pd_page_addr;  \n\tstruct i40e_hmc_pd_entry  *pd_entry;  \n\tstruct i40e_virt_mem pd_entry_virt_mem;  \n\n\tu32 ref_cnt;\n\tu32 sd_index;\n};\n\nstruct i40e_hmc_sd_entry {\n\tenum i40e_sd_entry_type entry_type;\n\tbool valid;\n\n\tunion {\n\t\tstruct i40e_hmc_pd_table pd_table;\n\t\tstruct i40e_hmc_bp bp;\n\t} u;\n};\n\nstruct i40e_hmc_sd_table {\n\tstruct i40e_virt_mem addr;  \n\tu32 sd_cnt;\n\tu32 ref_cnt;\n\tstruct i40e_hmc_sd_entry *sd_entry;  \n};\n\nstruct i40e_hmc_info {\n\tu32 signature;\n\t \n\tu8 hmc_fn_id;\n\tu16 first_sd_index;  \n\n\t \n\tstruct i40e_hmc_obj_info *hmc_obj;\n\tstruct i40e_virt_mem hmc_obj_virt_mem;\n\tstruct i40e_hmc_sd_table sd_table;\n};\n\n#define I40E_INC_SD_REFCNT(sd_table)\t((sd_table)->ref_cnt++)\n#define I40E_INC_PD_REFCNT(pd_table)\t((pd_table)->ref_cnt++)\n#define I40E_INC_BP_REFCNT(bp)\t\t((bp)->ref_cnt++)\n\n#define I40E_DEC_SD_REFCNT(sd_table)\t((sd_table)->ref_cnt--)\n#define I40E_DEC_PD_REFCNT(pd_table)\t((pd_table)->ref_cnt--)\n#define I40E_DEC_BP_REFCNT(bp)\t\t((bp)->ref_cnt--)\n\n \n#define I40E_SET_PF_SD_ENTRY(hw, pa, sd_index, type)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 val1, val2, val3;\t\t\t\t\t\t\\\n\tval1 = (u32)(upper_32_bits(pa));\t\t\t\t\\\n\tval2 = (u32)(pa) | (I40E_HMC_MAX_BP_COUNT <<\t\t\t\\\n\t\t I40E_PFHMC_SDDATALOW_PMSDBPCOUNT_SHIFT) |\t\t\\\n\t\t((((type) == I40E_SD_TYPE_PAGED) ? 0 : 1) <<\t\t\\\n\t\tI40E_PFHMC_SDDATALOW_PMSDTYPE_SHIFT) |\t\t\t\\\n\t\tBIT(I40E_PFHMC_SDDATALOW_PMSDVALID_SHIFT);\t\t\\\n\tval3 = (sd_index) | BIT_ULL(I40E_PFHMC_SDCMD_PMSDWR_SHIFT);\t\\\n\twr32((hw), I40E_PFHMC_SDDATAHIGH, val1);\t\t\t\\\n\twr32((hw), I40E_PFHMC_SDDATALOW, val2);\t\t\t\t\\\n\twr32((hw), I40E_PFHMC_SDCMD, val3);\t\t\t\t\\\n}\n\n \n#define I40E_CLEAR_PF_SD_ENTRY(hw, sd_index, type)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 val2, val3;\t\t\t\t\t\t\t\\\n\tval2 = (I40E_HMC_MAX_BP_COUNT <<\t\t\t\t\\\n\t\tI40E_PFHMC_SDDATALOW_PMSDBPCOUNT_SHIFT) |\t\t\\\n\t\t((((type) == I40E_SD_TYPE_PAGED) ? 0 : 1) <<\t\t\\\n\t\tI40E_PFHMC_SDDATALOW_PMSDTYPE_SHIFT);\t\t\t\\\n\tval3 = (sd_index) | BIT_ULL(I40E_PFHMC_SDCMD_PMSDWR_SHIFT);\t\\\n\twr32((hw), I40E_PFHMC_SDDATAHIGH, 0);\t\t\t\t\\\n\twr32((hw), I40E_PFHMC_SDDATALOW, val2);\t\t\t\t\\\n\twr32((hw), I40E_PFHMC_SDCMD, val3);\t\t\t\t\\\n}\n\n \n#define I40E_INVALIDATE_PF_HMC_PD(hw, sd_idx, pd_idx)\t\t\t\\\n\twr32((hw), I40E_PFHMC_PDINV,\t\t\t\t\t\\\n\t    (((sd_idx) << I40E_PFHMC_PDINV_PMSDIDX_SHIFT) |\t\t\\\n\t     ((pd_idx) << I40E_PFHMC_PDINV_PMPDIDX_SHIFT)))\n\n \n#define I40E_FIND_SD_INDEX_LIMIT(hmc_info, type, index, cnt, sd_idx, sd_limit)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu64 fpm_addr, fpm_limit;\t\t\t\t\t\\\n\tfpm_addr = (hmc_info)->hmc_obj[(type)].base +\t\t\t\\\n\t\t   (hmc_info)->hmc_obj[(type)].size * (index);\t\t\\\n\tfpm_limit = fpm_addr + (hmc_info)->hmc_obj[(type)].size * (cnt);\\\n\t*(sd_idx) = (u32)(fpm_addr / I40E_HMC_DIRECT_BP_SIZE);\t\t\\\n\t*(sd_limit) = (u32)((fpm_limit - 1) / I40E_HMC_DIRECT_BP_SIZE);\t\\\n\t \t\t\\\n\t*(sd_limit) += 1;\t\t\t\t\t\t\\\n}\n\n \n#define I40E_FIND_PD_INDEX_LIMIT(hmc_info, type, idx, cnt, pd_index, pd_limit)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu64 fpm_adr, fpm_limit;\t\t\t\t\t\t\\\n\tfpm_adr = (hmc_info)->hmc_obj[(type)].base +\t\t\t\\\n\t\t  (hmc_info)->hmc_obj[(type)].size * (idx);\t\t\\\n\tfpm_limit = fpm_adr + (hmc_info)->hmc_obj[(type)].size * (cnt);\t\\\n\t*(pd_index) = (u32)(fpm_adr / I40E_HMC_PAGED_BP_SIZE);\t\t\\\n\t*(pd_limit) = (u32)((fpm_limit - 1) / I40E_HMC_PAGED_BP_SIZE);\t\\\n\t \t\t\\\n\t*(pd_limit) += 1;\t\t\t\t\t\t\\\n}\n\nint i40e_add_sd_table_entry(struct i40e_hw *hw,\n\t\t\t    struct i40e_hmc_info *hmc_info,\n\t\t\t    u32 sd_index,\n\t\t\t    enum i40e_sd_entry_type type,\n\t\t\t    u64 direct_mode_sz);\nint i40e_add_pd_table_entry(struct i40e_hw *hw,\n\t\t\t    struct i40e_hmc_info *hmc_info,\n\t\t\t    u32 pd_index,\n\t\t\t    struct i40e_dma_mem *rsrc_pg);\nint i40e_remove_pd_bp(struct i40e_hw *hw,\n\t\t      struct i40e_hmc_info *hmc_info,\n\t\t      u32 idx);\nint i40e_prep_remove_sd_bp(struct i40e_hmc_info *hmc_info,\n\t\t\t   u32 idx);\nint i40e_remove_sd_bp_new(struct i40e_hw *hw,\n\t\t\t  struct i40e_hmc_info *hmc_info,\n\t\t\t  u32 idx, bool is_pf);\nint i40e_prep_remove_pd_page(struct i40e_hmc_info *hmc_info,\n\t\t\t     u32 idx);\nint i40e_remove_pd_page_new(struct i40e_hw *hw,\n\t\t\t    struct i40e_hmc_info *hmc_info,\n\t\t\t    u32 idx, bool is_pf);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}