{
  "module_name": "i40e_hmc.c",
  "hash_id": "37f1bd2ced6ac4a6d9bb4a9393d9933944b85144e4a874d67aa9444a5f0f1c6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_hmc.c",
  "human_readable_source": "\n \n\n#include \"i40e.h\"\n#include \"i40e_osdep.h\"\n#include \"i40e_register.h\"\n#include \"i40e_alloc.h\"\n#include \"i40e_hmc.h\"\n#include \"i40e_type.h\"\n\n \nint i40e_add_sd_table_entry(struct i40e_hw *hw,\n\t\t\t    struct i40e_hmc_info *hmc_info,\n\t\t\t    u32 sd_index,\n\t\t\t    enum i40e_sd_entry_type type,\n\t\t\t    u64 direct_mode_sz)\n{\n\tenum i40e_memory_type mem_type __attribute__((unused));\n\tstruct i40e_hmc_sd_entry *sd_entry;\n\tbool dma_mem_alloc_done = false;\n\tstruct i40e_dma_mem mem;\n\tint ret_code = 0;\n\tu64 alloc_len;\n\n\tif (NULL == hmc_info->sd_table.sd_entry) {\n\t\tret_code = -EINVAL;\n\t\thw_dbg(hw, \"i40e_add_sd_table_entry: bad sd_entry\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (sd_index >= hmc_info->sd_table.sd_cnt) {\n\t\tret_code = -EINVAL;\n\t\thw_dbg(hw, \"i40e_add_sd_table_entry: bad sd_index\\n\");\n\t\tgoto exit;\n\t}\n\n\tsd_entry = &hmc_info->sd_table.sd_entry[sd_index];\n\tif (!sd_entry->valid) {\n\t\tif (I40E_SD_TYPE_PAGED == type) {\n\t\t\tmem_type = i40e_mem_pd;\n\t\t\talloc_len = I40E_HMC_PAGED_BP_SIZE;\n\t\t} else {\n\t\t\tmem_type = i40e_mem_bp_jumbo;\n\t\t\talloc_len = direct_mode_sz;\n\t\t}\n\n\t\t \n\t\tret_code = i40e_allocate_dma_mem(hw, &mem, mem_type, alloc_len,\n\t\t\t\t\t\t I40E_HMC_PD_BP_BUF_ALIGNMENT);\n\t\tif (ret_code)\n\t\t\tgoto exit;\n\t\tdma_mem_alloc_done = true;\n\t\tif (I40E_SD_TYPE_PAGED == type) {\n\t\t\tret_code = i40e_allocate_virt_mem(hw,\n\t\t\t\t\t&sd_entry->u.pd_table.pd_entry_virt_mem,\n\t\t\t\t\tsizeof(struct i40e_hmc_pd_entry) * 512);\n\t\t\tif (ret_code)\n\t\t\t\tgoto exit;\n\t\t\tsd_entry->u.pd_table.pd_entry =\n\t\t\t\t(struct i40e_hmc_pd_entry *)\n\t\t\t\tsd_entry->u.pd_table.pd_entry_virt_mem.va;\n\t\t\tsd_entry->u.pd_table.pd_page_addr = mem;\n\t\t} else {\n\t\t\tsd_entry->u.bp.addr = mem;\n\t\t\tsd_entry->u.bp.sd_pd_index = sd_index;\n\t\t}\n\t\t \n\t\thmc_info->sd_table.sd_entry[sd_index].entry_type = type;\n\n\t\t \n\t\tI40E_INC_SD_REFCNT(&hmc_info->sd_table);\n\t}\n\t \n\tif (I40E_SD_TYPE_DIRECT == sd_entry->entry_type)\n\t\tI40E_INC_BP_REFCNT(&sd_entry->u.bp);\nexit:\n\tif (ret_code)\n\t\tif (dma_mem_alloc_done)\n\t\t\ti40e_free_dma_mem(hw, &mem);\n\n\treturn ret_code;\n}\n\n \nint i40e_add_pd_table_entry(struct i40e_hw *hw,\n\t\t\t    struct i40e_hmc_info *hmc_info,\n\t\t\t    u32 pd_index,\n\t\t\t    struct i40e_dma_mem *rsrc_pg)\n{\n\tstruct i40e_hmc_pd_table *pd_table;\n\tstruct i40e_hmc_pd_entry *pd_entry;\n\tstruct i40e_dma_mem mem;\n\tstruct i40e_dma_mem *page = &mem;\n\tu32 sd_idx, rel_pd_idx;\n\tint ret_code = 0;\n\tu64 page_desc;\n\tu64 *pd_addr;\n\n\tif (pd_index / I40E_HMC_PD_CNT_IN_SD >= hmc_info->sd_table.sd_cnt) {\n\t\tret_code = -EINVAL;\n\t\thw_dbg(hw, \"i40e_add_pd_table_entry: bad pd_index\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tsd_idx = (pd_index / I40E_HMC_PD_CNT_IN_SD);\n\tif (I40E_SD_TYPE_PAGED !=\n\t    hmc_info->sd_table.sd_entry[sd_idx].entry_type)\n\t\tgoto exit;\n\n\trel_pd_idx = (pd_index % I40E_HMC_PD_CNT_IN_SD);\n\tpd_table = &hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\n\tpd_entry = &pd_table->pd_entry[rel_pd_idx];\n\tif (!pd_entry->valid) {\n\t\tif (rsrc_pg) {\n\t\t\tpd_entry->rsrc_pg = true;\n\t\t\tpage = rsrc_pg;\n\t\t} else {\n\t\t\t \n\t\t\tret_code = i40e_allocate_dma_mem(hw, page, i40e_mem_bp,\n\t\t\t\t\t\tI40E_HMC_PAGED_BP_SIZE,\n\t\t\t\t\t\tI40E_HMC_PD_BP_BUF_ALIGNMENT);\n\t\t\tif (ret_code)\n\t\t\t\tgoto exit;\n\t\t\tpd_entry->rsrc_pg = false;\n\t\t}\n\n\t\tpd_entry->bp.addr = *page;\n\t\tpd_entry->bp.sd_pd_index = pd_index;\n\t\tpd_entry->bp.entry_type = I40E_SD_TYPE_PAGED;\n\t\t \n\t\tpage_desc = page->pa | 0x1;\n\n\t\tpd_addr = (u64 *)pd_table->pd_page_addr.va;\n\t\tpd_addr += rel_pd_idx;\n\n\t\t \n\t\tmemcpy(pd_addr, &page_desc, sizeof(u64));\n\n\t\tpd_entry->sd_index = sd_idx;\n\t\tpd_entry->valid = true;\n\t\tI40E_INC_PD_REFCNT(pd_table);\n\t}\n\tI40E_INC_BP_REFCNT(&pd_entry->bp);\nexit:\n\treturn ret_code;\n}\n\n \nint i40e_remove_pd_bp(struct i40e_hw *hw,\n\t\t      struct i40e_hmc_info *hmc_info,\n\t\t      u32 idx)\n{\n\tstruct i40e_hmc_pd_entry *pd_entry;\n\tstruct i40e_hmc_pd_table *pd_table;\n\tstruct i40e_hmc_sd_entry *sd_entry;\n\tu32 sd_idx, rel_pd_idx;\n\tint ret_code = 0;\n\tu64 *pd_addr;\n\n\t \n\tsd_idx = idx / I40E_HMC_PD_CNT_IN_SD;\n\trel_pd_idx = idx % I40E_HMC_PD_CNT_IN_SD;\n\tif (sd_idx >= hmc_info->sd_table.sd_cnt) {\n\t\tret_code = -EINVAL;\n\t\thw_dbg(hw, \"i40e_remove_pd_bp: bad idx\\n\");\n\t\tgoto exit;\n\t}\n\tsd_entry = &hmc_info->sd_table.sd_entry[sd_idx];\n\tif (I40E_SD_TYPE_PAGED != sd_entry->entry_type) {\n\t\tret_code = -EINVAL;\n\t\thw_dbg(hw, \"i40e_remove_pd_bp: wrong sd_entry type\\n\");\n\t\tgoto exit;\n\t}\n\t \n\tpd_table = &hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\n\tpd_entry = &pd_table->pd_entry[rel_pd_idx];\n\tI40E_DEC_BP_REFCNT(&pd_entry->bp);\n\tif (pd_entry->bp.ref_cnt)\n\t\tgoto exit;\n\n\t \n\tpd_entry->valid = false;\n\tI40E_DEC_PD_REFCNT(pd_table);\n\tpd_addr = (u64 *)pd_table->pd_page_addr.va;\n\tpd_addr += rel_pd_idx;\n\tmemset(pd_addr, 0, sizeof(u64));\n\tI40E_INVALIDATE_PF_HMC_PD(hw, sd_idx, idx);\n\n\t \n\tif (!pd_entry->rsrc_pg)\n\t\tret_code = i40e_free_dma_mem(hw, &pd_entry->bp.addr);\n\tif (ret_code)\n\t\tgoto exit;\n\tif (!pd_table->ref_cnt)\n\t\ti40e_free_virt_mem(hw, &pd_table->pd_entry_virt_mem);\nexit:\n\treturn ret_code;\n}\n\n \nint i40e_prep_remove_sd_bp(struct i40e_hmc_info *hmc_info,\n\t\t\t   u32 idx)\n{\n\tstruct i40e_hmc_sd_entry *sd_entry;\n\tint ret_code = 0;\n\n\t \n\tsd_entry = &hmc_info->sd_table.sd_entry[idx];\n\tI40E_DEC_BP_REFCNT(&sd_entry->u.bp);\n\tif (sd_entry->u.bp.ref_cnt) {\n\t\tret_code = -EBUSY;\n\t\tgoto exit;\n\t}\n\tI40E_DEC_SD_REFCNT(&hmc_info->sd_table);\n\n\t \n\tsd_entry->valid = false;\nexit:\n\treturn ret_code;\n}\n\n \nint i40e_remove_sd_bp_new(struct i40e_hw *hw,\n\t\t\t  struct i40e_hmc_info *hmc_info,\n\t\t\t  u32 idx, bool is_pf)\n{\n\tstruct i40e_hmc_sd_entry *sd_entry;\n\n\tif (!is_pf)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tsd_entry = &hmc_info->sd_table.sd_entry[idx];\n\tI40E_CLEAR_PF_SD_ENTRY(hw, idx, I40E_SD_TYPE_DIRECT);\n\n\treturn i40e_free_dma_mem(hw, &sd_entry->u.bp.addr);\n}\n\n \nint i40e_prep_remove_pd_page(struct i40e_hmc_info *hmc_info,\n\t\t\t     u32 idx)\n{\n\tstruct i40e_hmc_sd_entry *sd_entry;\n\tint ret_code = 0;\n\n\tsd_entry = &hmc_info->sd_table.sd_entry[idx];\n\n\tif (sd_entry->u.pd_table.ref_cnt) {\n\t\tret_code = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\tsd_entry->valid = false;\n\n\tI40E_DEC_SD_REFCNT(&hmc_info->sd_table);\nexit:\n\treturn ret_code;\n}\n\n \nint i40e_remove_pd_page_new(struct i40e_hw *hw,\n\t\t\t    struct i40e_hmc_info *hmc_info,\n\t\t\t    u32 idx, bool is_pf)\n{\n\tstruct i40e_hmc_sd_entry *sd_entry;\n\n\tif (!is_pf)\n\t\treturn -EOPNOTSUPP;\n\n\tsd_entry = &hmc_info->sd_table.sd_entry[idx];\n\tI40E_CLEAR_PF_SD_ENTRY(hw, idx, I40E_SD_TYPE_PAGED);\n\n\treturn  i40e_free_dma_mem(hw, &sd_entry->u.pd_table.pd_page_addr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}