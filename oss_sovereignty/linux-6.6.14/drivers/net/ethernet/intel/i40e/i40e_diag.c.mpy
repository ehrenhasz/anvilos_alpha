{
  "module_name": "i40e_diag.c",
  "hash_id": "759443c03e3246bc680d085b46d17a6089317041e0da347a1925501ea42ab3c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_diag.c",
  "human_readable_source": "\n \n\n#include \"i40e_diag.h\"\n#include \"i40e_prototype.h\"\n\n \nstatic int i40e_diag_reg_pattern_test(struct i40e_hw *hw,\n\t\t\t\t      u32 reg, u32 mask)\n{\n\tstatic const u32 patterns[] = {\n\t\t0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF\n\t};\n\tu32 pat, val, orig_val;\n\tint i;\n\n\torig_val = rd32(hw, reg);\n\tfor (i = 0; i < ARRAY_SIZE(patterns); i++) {\n\t\tpat = patterns[i];\n\t\twr32(hw, reg, (pat & mask));\n\t\tval = rd32(hw, reg);\n\t\tif ((val & mask) != (pat & mask)) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_DIAG,\n\t\t\t\t   \"%s: reg pattern test failed - reg 0x%08x pat 0x%08x val 0x%08x\\n\",\n\t\t\t\t   __func__, reg, pat, val);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\twr32(hw, reg, orig_val);\n\tval = rd32(hw, reg);\n\tif (val != orig_val) {\n\t\ti40e_debug(hw, I40E_DEBUG_DIAG,\n\t\t\t   \"%s: reg restore test failed - reg 0x%08x orig_val 0x%08x val 0x%08x\\n\",\n\t\t\t   __func__, reg, orig_val, val);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nconst struct i40e_diag_reg_test_info i40e_reg_list[] = {\n\t \n\t{I40E_QTX_CTL(0),       0x0000FFBF, 1,\n\t\tI40E_QTX_CTL(1) - I40E_QTX_CTL(0)},\n\t{I40E_PFINT_ITR0(0),    0x00000FFF, 3,\n\t\tI40E_PFINT_ITR0(1) - I40E_PFINT_ITR0(0)},\n\t{I40E_PFINT_ITRN(0, 0), 0x00000FFF, 1,\n\t\tI40E_PFINT_ITRN(0, 1) - I40E_PFINT_ITRN(0, 0)},\n\t{I40E_PFINT_ITRN(1, 0), 0x00000FFF, 1,\n\t\tI40E_PFINT_ITRN(1, 1) - I40E_PFINT_ITRN(1, 0)},\n\t{I40E_PFINT_ITRN(2, 0), 0x00000FFF, 1,\n\t\tI40E_PFINT_ITRN(2, 1) - I40E_PFINT_ITRN(2, 0)},\n\t{I40E_PFINT_STAT_CTL0,  0x0000000C, 1, 0},\n\t{I40E_PFINT_LNKLST0,    0x00001FFF, 1, 0},\n\t{I40E_PFINT_LNKLSTN(0), 0x000007FF, 1,\n\t\tI40E_PFINT_LNKLSTN(1) - I40E_PFINT_LNKLSTN(0)},\n\t{I40E_QINT_TQCTL(0),    0x000000FF, 1,\n\t\tI40E_QINT_TQCTL(1) - I40E_QINT_TQCTL(0)},\n\t{I40E_QINT_RQCTL(0),    0x000000FF, 1,\n\t\tI40E_QINT_RQCTL(1) - I40E_QINT_RQCTL(0)},\n\t{I40E_PFINT_ICR0_ENA,   0xF7F20000, 1, 0},\n\t{ 0 }\n};\n\n \nint i40e_diag_reg_test(struct i40e_hw *hw)\n{\n\tint ret_code = 0;\n\tu32 reg, mask;\n\tu32 elements;\n\tu32 i, j;\n\n\tfor (i = 0; i40e_reg_list[i].offset != 0 &&\n\t\t\t\t\t     !ret_code; i++) {\n\n\t\telements = i40e_reg_list[i].elements;\n\t\t \n\t\tif (i40e_reg_list[i].offset == I40E_QTX_CTL(0) &&\n\t\t    hw->func_caps.num_tx_qp != 0)\n\t\t\telements = hw->func_caps.num_tx_qp;\n\t\tif ((i40e_reg_list[i].offset == I40E_PFINT_ITRN(0, 0) ||\n\t\t     i40e_reg_list[i].offset == I40E_PFINT_ITRN(1, 0) ||\n\t\t     i40e_reg_list[i].offset == I40E_PFINT_ITRN(2, 0) ||\n\t\t     i40e_reg_list[i].offset == I40E_QINT_TQCTL(0) ||\n\t\t     i40e_reg_list[i].offset == I40E_QINT_RQCTL(0)) &&\n\t\t    hw->func_caps.num_msix_vectors != 0)\n\t\t\telements = hw->func_caps.num_msix_vectors - 1;\n\n\t\t \n\t\tmask = i40e_reg_list[i].mask;\n\t\tfor (j = 0; j < elements && !ret_code; j++) {\n\t\t\treg = i40e_reg_list[i].offset +\n\t\t\t      (j * i40e_reg_list[i].stride);\n\t\t\tret_code = i40e_diag_reg_pattern_test(hw, reg, mask);\n\t\t}\n\t}\n\n\treturn ret_code;\n}\n\n \nint i40e_diag_eeprom_test(struct i40e_hw *hw)\n{\n\tint ret_code;\n\tu16 reg_val;\n\n\t \n\tret_code = i40e_read_nvm_word(hw, I40E_SR_NVM_CONTROL_WORD, &reg_val);\n\tif (!ret_code &&\n\t    ((reg_val & I40E_SR_CONTROL_WORD_1_MASK) ==\n\t     BIT(I40E_SR_CONTROL_WORD_1_SHIFT)))\n\t\treturn i40e_validate_nvm_checksum(hw, NULL);\n\telse\n\t\treturn -EIO;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}