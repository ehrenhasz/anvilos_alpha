{
  "module_name": "i40e_nvm.c",
  "hash_id": "a7d0170c43e1e10cfb4147256b250c42b0ebfc9bff4773434b6ed12c2e58f659",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_nvm.c",
  "human_readable_source": "\n \n\n#include \"i40e_prototype.h\"\n\n \nint i40e_init_nvm(struct i40e_hw *hw)\n{\n\tstruct i40e_nvm_info *nvm = &hw->nvm;\n\tint ret_code = 0;\n\tu32 fla, gens;\n\tu8 sr_size;\n\n\t \n\tgens = rd32(hw, I40E_GLNVM_GENS);\n\tsr_size = ((gens & I40E_GLNVM_GENS_SR_SIZE_MASK) >>\n\t\t\t   I40E_GLNVM_GENS_SR_SIZE_SHIFT);\n\t \n\tnvm->sr_size = BIT(sr_size) * I40E_SR_WORDS_IN_1KB;\n\n\t \n\tfla = rd32(hw, I40E_GLNVM_FLA);\n\tif (fla & I40E_GLNVM_FLA_LOCKED_MASK) {  \n\t\t \n\t\tnvm->timeout = I40E_MAX_NVM_TIMEOUT;\n\t\tnvm->blank_nvm_mode = false;\n\t} else {  \n\t\tnvm->blank_nvm_mode = true;\n\t\tret_code = -EIO;\n\t\ti40e_debug(hw, I40E_DEBUG_NVM, \"NVM init error: unsupported blank mode.\\n\");\n\t}\n\n\treturn ret_code;\n}\n\n \nint i40e_acquire_nvm(struct i40e_hw *hw,\n\t\t     enum i40e_aq_resource_access_type access)\n{\n\tu64 gtime, timeout;\n\tu64 time_left = 0;\n\tint ret_code = 0;\n\n\tif (hw->nvm.blank_nvm_mode)\n\t\tgoto i40e_i40e_acquire_nvm_exit;\n\n\tret_code = i40e_aq_request_resource(hw, I40E_NVM_RESOURCE_ID, access,\n\t\t\t\t\t    0, &time_left, NULL);\n\t \n\tgtime = rd32(hw, I40E_GLVFGEN_TIMER);\n\n\t \n\thw->nvm.hw_semaphore_timeout = I40E_MS_TO_GTIME(time_left) + gtime;\n\n\tif (ret_code)\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM acquire type %d failed time_left=%llu ret=%d aq_err=%d\\n\",\n\t\t\t   access, time_left, ret_code, hw->aq.asq_last_status);\n\n\tif (ret_code && time_left) {\n\t\t \n\t\ttimeout = I40E_MS_TO_GTIME(I40E_MAX_NVM_TIMEOUT) + gtime;\n\t\twhile ((gtime < timeout) && time_left) {\n\t\t\tusleep_range(10000, 20000);\n\t\t\tgtime = rd32(hw, I40E_GLVFGEN_TIMER);\n\t\t\tret_code = i40e_aq_request_resource(hw,\n\t\t\t\t\t\t\tI40E_NVM_RESOURCE_ID,\n\t\t\t\t\t\t\taccess, 0, &time_left,\n\t\t\t\t\t\t\tNULL);\n\t\t\tif (!ret_code) {\n\t\t\t\thw->nvm.hw_semaphore_timeout =\n\t\t\t\t\t    I40E_MS_TO_GTIME(time_left) + gtime;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret_code) {\n\t\t\thw->nvm.hw_semaphore_timeout = 0;\n\t\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t\t   \"NVM acquire timed out, wait %llu ms before trying again. status=%d aq_err=%d\\n\",\n\t\t\t\t   time_left, ret_code, hw->aq.asq_last_status);\n\t\t}\n\t}\n\ni40e_i40e_acquire_nvm_exit:\n\treturn ret_code;\n}\n\n \nvoid i40e_release_nvm(struct i40e_hw *hw)\n{\n\tu32 total_delay = 0;\n\tint ret_code = 0;\n\n\tif (hw->nvm.blank_nvm_mode)\n\t\treturn;\n\n\tret_code = i40e_aq_release_resource(hw, I40E_NVM_RESOURCE_ID, 0, NULL);\n\n\t \n\twhile ((ret_code == -EIO) &&\n\t       (total_delay < hw->aq.asq_cmd_timeout)) {\n\t\tusleep_range(1000, 2000);\n\t\tret_code = i40e_aq_release_resource(hw,\n\t\t\t\t\t\t    I40E_NVM_RESOURCE_ID,\n\t\t\t\t\t\t    0, NULL);\n\t\ttotal_delay++;\n\t}\n}\n\n \nstatic int i40e_poll_sr_srctl_done_bit(struct i40e_hw *hw)\n{\n\tint ret_code = -EIO;\n\tu32 srctl, wait_cnt;\n\n\t \n\tfor (wait_cnt = 0; wait_cnt < I40E_SRRD_SRCTL_ATTEMPTS; wait_cnt++) {\n\t\tsrctl = rd32(hw, I40E_GLNVM_SRCTL);\n\t\tif (srctl & I40E_GLNVM_SRCTL_DONE_MASK) {\n\t\t\tret_code = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(5);\n\t}\n\tif (ret_code == -EIO)\n\t\ti40e_debug(hw, I40E_DEBUG_NVM, \"Done bit in GLNVM_SRCTL not set\");\n\treturn ret_code;\n}\n\n \nstatic int i40e_read_nvm_word_srctl(struct i40e_hw *hw, u16 offset,\n\t\t\t\t    u16 *data)\n{\n\tint ret_code = -EIO;\n\tu32 sr_reg;\n\n\tif (offset >= hw->nvm.sr_size) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM read error: offset %d beyond Shadow RAM limit %d\\n\",\n\t\t\t   offset, hw->nvm.sr_size);\n\t\tret_code = -EINVAL;\n\t\tgoto read_nvm_exit;\n\t}\n\n\t \n\tret_code = i40e_poll_sr_srctl_done_bit(hw);\n\tif (!ret_code) {\n\t\t \n\t\tsr_reg = ((u32)offset << I40E_GLNVM_SRCTL_ADDR_SHIFT) |\n\t\t\t BIT(I40E_GLNVM_SRCTL_START_SHIFT);\n\t\twr32(hw, I40E_GLNVM_SRCTL, sr_reg);\n\n\t\t \n\t\tret_code = i40e_poll_sr_srctl_done_bit(hw);\n\t\tif (!ret_code) {\n\t\t\tsr_reg = rd32(hw, I40E_GLNVM_SRDATA);\n\t\t\t*data = (u16)((sr_reg &\n\t\t\t\t       I40E_GLNVM_SRDATA_RDDATA_MASK)\n\t\t\t\t    >> I40E_GLNVM_SRDATA_RDDATA_SHIFT);\n\t\t}\n\t}\n\tif (ret_code)\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM read error: Couldn't access Shadow RAM address: 0x%x\\n\",\n\t\t\t   offset);\n\nread_nvm_exit:\n\treturn ret_code;\n}\n\n \nstatic int i40e_read_nvm_aq(struct i40e_hw *hw,\n\t\t\t    u8 module_pointer, u32 offset,\n\t\t\t    u16 words, void *data,\n\t\t\t    bool last_command)\n{\n\tstruct i40e_asq_cmd_details cmd_details;\n\tint ret_code = -EIO;\n\n\tmemset(&cmd_details, 0, sizeof(cmd_details));\n\tcmd_details.wb_desc = &hw->nvm_wb_desc;\n\n\t \n\tif ((offset + words) > hw->nvm.sr_size)\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM read error: offset %d beyond Shadow RAM limit %d\\n\",\n\t\t\t   (offset + words), hw->nvm.sr_size);\n\telse if (words > I40E_SR_SECTOR_SIZE_IN_WORDS)\n\t\t \n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM read fail error: tried to read %d words, limit is %d.\\n\",\n\t\t\t   words, I40E_SR_SECTOR_SIZE_IN_WORDS);\n\telse if (((offset + (words - 1)) / I40E_SR_SECTOR_SIZE_IN_WORDS)\n\t\t != (offset / I40E_SR_SECTOR_SIZE_IN_WORDS))\n\t\t \n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM read error: cannot spread over two sectors in a single read offset=%d words=%d\\n\",\n\t\t\t   offset, words);\n\telse\n\t\tret_code = i40e_aq_read_nvm(hw, module_pointer,\n\t\t\t\t\t    2 * offset,   \n\t\t\t\t\t    2 * words,    \n\t\t\t\t\t    data, last_command, &cmd_details);\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_read_nvm_word_aq(struct i40e_hw *hw, u16 offset,\n\t\t\t\t u16 *data)\n{\n\tint ret_code = -EIO;\n\n\tret_code = i40e_read_nvm_aq(hw, 0x0, offset, 1, data, true);\n\t*data = le16_to_cpu(*(__le16 *)data);\n\n\treturn ret_code;\n}\n\n \nstatic int __i40e_read_nvm_word(struct i40e_hw *hw,\n\t\t\t\tu16 offset, u16 *data)\n{\n\tif (hw->flags & I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE)\n\t\treturn i40e_read_nvm_word_aq(hw, offset, data);\n\n\treturn i40e_read_nvm_word_srctl(hw, offset, data);\n}\n\n \nint i40e_read_nvm_word(struct i40e_hw *hw, u16 offset,\n\t\t       u16 *data)\n{\n\tint ret_code = 0;\n\n\tif (hw->flags & I40E_HW_FLAG_NVM_READ_REQUIRES_LOCK)\n\t\tret_code = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\tif (ret_code)\n\t\treturn ret_code;\n\n\tret_code = __i40e_read_nvm_word(hw, offset, data);\n\n\tif (hw->flags & I40E_HW_FLAG_NVM_READ_REQUIRES_LOCK)\n\t\ti40e_release_nvm(hw);\n\n\treturn ret_code;\n}\n\n \nint i40e_read_nvm_module_data(struct i40e_hw *hw,\n\t\t\t      u8 module_ptr,\n\t\t\t      u16 module_offset,\n\t\t\t      u16 data_offset,\n\t\t\t      u16 words_data_size,\n\t\t\t      u16 *data_ptr)\n{\n\tu16 specific_ptr = 0;\n\tu16 ptr_value = 0;\n\tu32 offset = 0;\n\tint status;\n\n\tif (module_ptr != 0) {\n\t\tstatus = i40e_read_nvm_word(hw, module_ptr, &ptr_value);\n\t\tif (status) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t\t   \"Reading nvm word failed.Error code: %d.\\n\",\n\t\t\t\t   status);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n#define I40E_NVM_INVALID_PTR_VAL 0x7FFF\n#define I40E_NVM_INVALID_VAL 0xFFFF\n\n\t \n\tif (ptr_value == I40E_NVM_INVALID_PTR_VAL ||\n\t    ptr_value == I40E_NVM_INVALID_VAL) {\n\t\ti40e_debug(hw, I40E_DEBUG_ALL, \"Pointer not initialized.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ptr_value & I40E_PTR_TYPE) {\n\t\t \n\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t   \"Reading nvm data failed. Pointer points outside of the Shared RAM mapped area.\\n\");\n\n\t\treturn -EINVAL;\n\t} else {\n\t\t \n\n\t\tstatus = i40e_read_nvm_word(hw, ptr_value + module_offset,\n\t\t\t\t\t    &specific_ptr);\n\t\tif (status) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t\t   \"Reading nvm word failed.Error code: %d.\\n\",\n\t\t\t\t   status);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\toffset = ptr_value + module_offset + specific_ptr +\n\t\t\tdata_offset;\n\n\t\tstatus = i40e_read_nvm_buffer(hw, offset, &words_data_size,\n\t\t\t\t\t      data_ptr);\n\t\tif (status) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t\t   \"Reading nvm buffer failed.Error code: %d.\\n\",\n\t\t\t\t   status);\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nstatic int i40e_read_nvm_buffer_srctl(struct i40e_hw *hw, u16 offset,\n\t\t\t\t      u16 *words, u16 *data)\n{\n\tint ret_code = 0;\n\tu16 index, word;\n\n\t \n\tfor (word = 0; word < *words; word++) {\n\t\tindex = offset + word;\n\t\tret_code = i40e_read_nvm_word_srctl(hw, index, &data[word]);\n\t\tif (ret_code)\n\t\t\tbreak;\n\t}\n\n\t \n\t*words = word;\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_read_nvm_buffer_aq(struct i40e_hw *hw, u16 offset,\n\t\t\t\t   u16 *words, u16 *data)\n{\n\tbool last_cmd = false;\n\tu16 words_read = 0;\n\tu16 read_size;\n\tint ret_code;\n\tu16 i = 0;\n\n\tdo {\n\t\t \n\t\tif (offset % I40E_SR_SECTOR_SIZE_IN_WORDS)\n\t\t\tread_size = min(*words,\n\t\t\t\t\t(u16)(I40E_SR_SECTOR_SIZE_IN_WORDS -\n\t\t\t\t      (offset % I40E_SR_SECTOR_SIZE_IN_WORDS)));\n\t\telse\n\t\t\tread_size = min((*words - words_read),\n\t\t\t\t\tI40E_SR_SECTOR_SIZE_IN_WORDS);\n\n\t\t \n\t\tif ((words_read + read_size) >= *words)\n\t\t\tlast_cmd = true;\n\n\t\tret_code = i40e_read_nvm_aq(hw, 0x0, offset, read_size,\n\t\t\t\t\t    data + words_read, last_cmd);\n\t\tif (ret_code)\n\t\t\tgoto read_nvm_buffer_aq_exit;\n\n\t\t \n\t\twords_read += read_size;\n\t\toffset += read_size;\n\t} while (words_read < *words);\n\n\tfor (i = 0; i < *words; i++)\n\t\tdata[i] = le16_to_cpu(((__le16 *)data)[i]);\n\nread_nvm_buffer_aq_exit:\n\t*words = words_read;\n\treturn ret_code;\n}\n\n \nstatic int __i40e_read_nvm_buffer(struct i40e_hw *hw,\n\t\t\t\t  u16 offset, u16 *words,\n\t\t\t\t  u16 *data)\n{\n\tif (hw->flags & I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE)\n\t\treturn i40e_read_nvm_buffer_aq(hw, offset, words, data);\n\n\treturn i40e_read_nvm_buffer_srctl(hw, offset, words, data);\n}\n\n \nint i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset,\n\t\t\t u16 *words, u16 *data)\n{\n\tint ret_code = 0;\n\n\tif (hw->flags & I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE) {\n\t\tret_code = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\t\tif (!ret_code) {\n\t\t\tret_code = i40e_read_nvm_buffer_aq(hw, offset, words,\n\t\t\t\t\t\t\t   data);\n\t\t\ti40e_release_nvm(hw);\n\t\t}\n\t} else {\n\t\tret_code = i40e_read_nvm_buffer_srctl(hw, offset, words, data);\n\t}\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_write_nvm_aq(struct i40e_hw *hw, u8 module_pointer,\n\t\t\t     u32 offset, u16 words, void *data,\n\t\t\t     bool last_command)\n{\n\tstruct i40e_asq_cmd_details cmd_details;\n\tint ret_code = -EIO;\n\n\tmemset(&cmd_details, 0, sizeof(cmd_details));\n\tcmd_details.wb_desc = &hw->nvm_wb_desc;\n\n\t \n\tif ((offset + words) > hw->nvm.sr_size)\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM write error: offset %d beyond Shadow RAM limit %d\\n\",\n\t\t\t   (offset + words), hw->nvm.sr_size);\n\telse if (words > I40E_SR_SECTOR_SIZE_IN_WORDS)\n\t\t \n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM write fail error: tried to write %d words, limit is %d.\\n\",\n\t\t\t   words, I40E_SR_SECTOR_SIZE_IN_WORDS);\n\telse if (((offset + (words - 1)) / I40E_SR_SECTOR_SIZE_IN_WORDS)\n\t\t != (offset / I40E_SR_SECTOR_SIZE_IN_WORDS))\n\t\t \n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVM write error: cannot spread over two sectors in a single write offset=%d words=%d\\n\",\n\t\t\t   offset, words);\n\telse\n\t\tret_code = i40e_aq_update_nvm(hw, module_pointer,\n\t\t\t\t\t      2 * offset,   \n\t\t\t\t\t      2 * words,    \n\t\t\t\t\t      data, last_command, 0,\n\t\t\t\t\t      &cmd_details);\n\n\treturn ret_code;\n}\n\n \nstatic int i40e_calc_nvm_checksum(struct i40e_hw *hw,\n\t\t\t\t  u16 *checksum)\n{\n\tstruct i40e_virt_mem vmem;\n\tu16 pcie_alt_module = 0;\n\tu16 checksum_local = 0;\n\tu16 vpd_module = 0;\n\tint ret_code;\n\tu16 *data;\n\tu16 i = 0;\n\n\tret_code = i40e_allocate_virt_mem(hw, &vmem,\n\t\t\t\t    I40E_SR_SECTOR_SIZE_IN_WORDS * sizeof(u16));\n\tif (ret_code)\n\t\tgoto i40e_calc_nvm_checksum_exit;\n\tdata = (u16 *)vmem.va;\n\n\t \n\tret_code = __i40e_read_nvm_word(hw, I40E_SR_VPD_PTR, &vpd_module);\n\tif (ret_code) {\n\t\tret_code = -EIO;\n\t\tgoto i40e_calc_nvm_checksum_exit;\n\t}\n\n\t \n\tret_code = __i40e_read_nvm_word(hw, I40E_SR_PCIE_ALT_AUTO_LOAD_PTR,\n\t\t\t\t\t&pcie_alt_module);\n\tif (ret_code) {\n\t\tret_code = -EIO;\n\t\tgoto i40e_calc_nvm_checksum_exit;\n\t}\n\n\t \n\tfor (i = 0; i < hw->nvm.sr_size; i++) {\n\t\t \n\t\tif ((i % I40E_SR_SECTOR_SIZE_IN_WORDS) == 0) {\n\t\t\tu16 words = I40E_SR_SECTOR_SIZE_IN_WORDS;\n\n\t\t\tret_code = __i40e_read_nvm_buffer(hw, i, &words, data);\n\t\t\tif (ret_code) {\n\t\t\t\tret_code = -EIO;\n\t\t\t\tgoto i40e_calc_nvm_checksum_exit;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i == I40E_SR_SW_CHECKSUM_WORD)\n\t\t\tcontinue;\n\t\t \n\t\tif ((i >= (u32)vpd_module) &&\n\t\t    (i < ((u32)vpd_module +\n\t\t     (I40E_SR_VPD_MODULE_MAX_SIZE / 2)))) {\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif ((i >= (u32)pcie_alt_module) &&\n\t\t    (i < ((u32)pcie_alt_module +\n\t\t     (I40E_SR_PCIE_ALT_MODULE_MAX_SIZE / 2)))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchecksum_local += data[i % I40E_SR_SECTOR_SIZE_IN_WORDS];\n\t}\n\n\t*checksum = (u16)I40E_SR_SW_CHECKSUM_BASE - checksum_local;\n\ni40e_calc_nvm_checksum_exit:\n\ti40e_free_virt_mem(hw, &vmem);\n\treturn ret_code;\n}\n\n \nint i40e_update_nvm_checksum(struct i40e_hw *hw)\n{\n\t__le16 le_sum;\n\tint ret_code;\n\tu16 checksum;\n\n\tret_code = i40e_calc_nvm_checksum(hw, &checksum);\n\tif (!ret_code) {\n\t\tle_sum = cpu_to_le16(checksum);\n\t\tret_code = i40e_write_nvm_aq(hw, 0x00, I40E_SR_SW_CHECKSUM_WORD,\n\t\t\t\t\t     1, &le_sum, true);\n\t}\n\n\treturn ret_code;\n}\n\n \nint i40e_validate_nvm_checksum(struct i40e_hw *hw,\n\t\t\t       u16 *checksum)\n{\n\tu16 checksum_local = 0;\n\tu16 checksum_sr = 0;\n\tint ret_code = 0;\n\n\t \n\tret_code = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\tif (ret_code)\n\t\treturn ret_code;\n\tret_code = i40e_calc_nvm_checksum(hw, &checksum_local);\n\t__i40e_read_nvm_word(hw, I40E_SR_SW_CHECKSUM_WORD, &checksum_sr);\n\ti40e_release_nvm(hw);\n\tif (ret_code)\n\t\treturn ret_code;\n\n\t \n\tif (checksum_local != checksum_sr)\n\t\tret_code = -EIO;\n\n\t \n\tif (checksum)\n\t\t*checksum = checksum_local;\n\n\treturn ret_code;\n}\n\nstatic int i40e_nvmupd_state_init(struct i40e_hw *hw,\n\t\t\t\t  struct i40e_nvm_access *cmd,\n\t\t\t\t  u8 *bytes, int *perrno);\nstatic int i40e_nvmupd_state_reading(struct i40e_hw *hw,\n\t\t\t\t     struct i40e_nvm_access *cmd,\n\t\t\t\t     u8 *bytes, int *perrno);\nstatic int i40e_nvmupd_state_writing(struct i40e_hw *hw,\n\t\t\t\t     struct i40e_nvm_access *cmd,\n\t\t\t\t     u8 *bytes, int *errno);\nstatic enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw,\n\t\t\t\t\t\tstruct i40e_nvm_access *cmd,\n\t\t\t\t\t\tint *perrno);\nstatic int i40e_nvmupd_nvm_erase(struct i40e_hw *hw,\n\t\t\t\t struct i40e_nvm_access *cmd,\n\t\t\t\t int *perrno);\nstatic int i40e_nvmupd_nvm_write(struct i40e_hw *hw,\n\t\t\t\t struct i40e_nvm_access *cmd,\n\t\t\t\t u8 *bytes, int *perrno);\nstatic int i40e_nvmupd_nvm_read(struct i40e_hw *hw,\n\t\t\t\tstruct i40e_nvm_access *cmd,\n\t\t\t\tu8 *bytes, int *perrno);\nstatic int i40e_nvmupd_exec_aq(struct i40e_hw *hw,\n\t\t\t       struct i40e_nvm_access *cmd,\n\t\t\t       u8 *bytes, int *perrno);\nstatic int i40e_nvmupd_get_aq_result(struct i40e_hw *hw,\n\t\t\t\t     struct i40e_nvm_access *cmd,\n\t\t\t\t     u8 *bytes, int *perrno);\nstatic int i40e_nvmupd_get_aq_event(struct i40e_hw *hw,\n\t\t\t\t    struct i40e_nvm_access *cmd,\n\t\t\t\t    u8 *bytes, int *perrno);\nstatic inline u8 i40e_nvmupd_get_module(u32 val)\n{\n\treturn (u8)(val & I40E_NVM_MOD_PNT_MASK);\n}\nstatic inline u8 i40e_nvmupd_get_transaction(u32 val)\n{\n\treturn (u8)((val & I40E_NVM_TRANS_MASK) >> I40E_NVM_TRANS_SHIFT);\n}\n\nstatic inline u8 i40e_nvmupd_get_preservation_flags(u32 val)\n{\n\treturn (u8)((val & I40E_NVM_PRESERVATION_FLAGS_MASK) >>\n\t\t    I40E_NVM_PRESERVATION_FLAGS_SHIFT);\n}\n\nstatic const char * const i40e_nvm_update_state_str[] = {\n\t\"I40E_NVMUPD_INVALID\",\n\t\"I40E_NVMUPD_READ_CON\",\n\t\"I40E_NVMUPD_READ_SNT\",\n\t\"I40E_NVMUPD_READ_LCB\",\n\t\"I40E_NVMUPD_READ_SA\",\n\t\"I40E_NVMUPD_WRITE_ERA\",\n\t\"I40E_NVMUPD_WRITE_CON\",\n\t\"I40E_NVMUPD_WRITE_SNT\",\n\t\"I40E_NVMUPD_WRITE_LCB\",\n\t\"I40E_NVMUPD_WRITE_SA\",\n\t\"I40E_NVMUPD_CSUM_CON\",\n\t\"I40E_NVMUPD_CSUM_SA\",\n\t\"I40E_NVMUPD_CSUM_LCB\",\n\t\"I40E_NVMUPD_STATUS\",\n\t\"I40E_NVMUPD_EXEC_AQ\",\n\t\"I40E_NVMUPD_GET_AQ_RESULT\",\n\t\"I40E_NVMUPD_GET_AQ_EVENT\",\n};\n\n \nint i40e_nvmupd_command(struct i40e_hw *hw,\n\t\t\tstruct i40e_nvm_access *cmd,\n\t\t\tu8 *bytes, int *perrno)\n{\n\tenum i40e_nvmupd_cmd upd_cmd;\n\tint status;\n\n\t \n\t*perrno = 0;\n\n\t \n\tupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\n\n\ti40e_debug(hw, I40E_DEBUG_NVM, \"%s state %d nvm_release_on_hold %d opc 0x%04x cmd 0x%08x config 0x%08x offset 0x%08x data_size 0x%08x\\n\",\n\t\t   i40e_nvm_update_state_str[upd_cmd],\n\t\t   hw->nvmupd_state,\n\t\t   hw->nvm_release_on_done, hw->nvm_wait_opcode,\n\t\t   cmd->command, cmd->config, cmd->offset, cmd->data_size);\n\n\tif (upd_cmd == I40E_NVMUPD_INVALID) {\n\t\t*perrno = -EFAULT;\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_validate_command returns %d errno %d\\n\",\n\t\t\t   upd_cmd, *perrno);\n\t}\n\n\t \n\tif (upd_cmd == I40E_NVMUPD_STATUS) {\n\t\tif (!cmd->data_size) {\n\t\t\t*perrno = -EFAULT;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbytes[0] = hw->nvmupd_state;\n\n\t\tif (cmd->data_size >= 4) {\n\t\t\tbytes[1] = 0;\n\t\t\t*((u16 *)&bytes[2]) = hw->nvm_wait_opcode;\n\t\t}\n\n\t\t \n\t\tif (hw->nvmupd_state == I40E_NVMUPD_STATE_ERROR)\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (hw->nvmupd_state == I40E_NVMUPD_STATE_ERROR) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"Clearing I40E_NVMUPD_STATE_ERROR state without reading\\n\");\n\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\t}\n\n\t \n\tmutex_lock(&hw->aq.arq_mutex);\n\tswitch (hw->nvmupd_state) {\n\tcase I40E_NVMUPD_STATE_INIT:\n\t\tstatus = i40e_nvmupd_state_init(hw, cmd, bytes, perrno);\n\t\tbreak;\n\n\tcase I40E_NVMUPD_STATE_READING:\n\t\tstatus = i40e_nvmupd_state_reading(hw, cmd, bytes, perrno);\n\t\tbreak;\n\n\tcase I40E_NVMUPD_STATE_WRITING:\n\t\tstatus = i40e_nvmupd_state_writing(hw, cmd, bytes, perrno);\n\t\tbreak;\n\n\tcase I40E_NVMUPD_STATE_INIT_WAIT:\n\tcase I40E_NVMUPD_STATE_WRITE_WAIT:\n\t\t \n\t\tif (cmd->offset == 0xffff) {\n\t\t\ti40e_nvmupd_clear_wait_state(hw);\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = -EBUSY;\n\t\t*perrno = -EBUSY;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVMUPD: no such state %d\\n\", hw->nvmupd_state);\n\t\tstatus = -EOPNOTSUPP;\n\t\t*perrno = -ESRCH;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&hw->aq.arq_mutex);\n\treturn status;\n}\n\n \nstatic int i40e_nvmupd_state_init(struct i40e_hw *hw,\n\t\t\t\t  struct i40e_nvm_access *cmd,\n\t\t\t\t  u8 *bytes, int *perrno)\n{\n\tenum i40e_nvmupd_cmd upd_cmd;\n\tint status = 0;\n\n\tupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\n\n\tswitch (upd_cmd) {\n\tcase I40E_NVMUPD_READ_SA:\n\t\tstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\t\tif (status) {\n\t\t\t*perrno = i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t} else {\n\t\t\tstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\n\t\t\ti40e_release_nvm(hw);\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_READ_SNT:\n\t\tstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\t\tif (status) {\n\t\t\t*perrno = i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t} else {\n\t\t\tstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\n\t\t\tif (status)\n\t\t\t\ti40e_release_nvm(hw);\n\t\t\telse\n\t\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_READING;\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_WRITE_ERA:\n\t\tstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\n\t\tif (status) {\n\t\t\t*perrno = i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t} else {\n\t\t\tstatus = i40e_nvmupd_nvm_erase(hw, cmd, perrno);\n\t\t\tif (status) {\n\t\t\t\ti40e_release_nvm(hw);\n\t\t\t} else {\n\t\t\t\thw->nvm_release_on_done = true;\n\t\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_erase;\n\t\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_WRITE_SA:\n\t\tstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\n\t\tif (status) {\n\t\t\t*perrno = i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t} else {\n\t\t\tstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\n\t\t\tif (status) {\n\t\t\t\ti40e_release_nvm(hw);\n\t\t\t} else {\n\t\t\t\thw->nvm_release_on_done = true;\n\t\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\n\t\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_WRITE_SNT:\n\t\tstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\n\t\tif (status) {\n\t\t\t*perrno = i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t} else {\n\t\t\tstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\n\t\t\tif (status) {\n\t\t\t\ti40e_release_nvm(hw);\n\t\t\t} else {\n\t\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\n\t\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_CSUM_SA:\n\t\tstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\n\t\tif (status) {\n\t\t\t*perrno = i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t} else {\n\t\t\tstatus = i40e_update_nvm_checksum(hw);\n\t\t\tif (status) {\n\t\t\t\t*perrno = hw->aq.asq_last_status ?\n\t\t\t\t   i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t       hw->aq.asq_last_status) :\n\t\t\t\t   -EIO;\n\t\t\t\ti40e_release_nvm(hw);\n\t\t\t} else {\n\t\t\t\thw->nvm_release_on_done = true;\n\t\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\n\t\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_EXEC_AQ:\n\t\tstatus = i40e_nvmupd_exec_aq(hw, cmd, bytes, perrno);\n\t\tbreak;\n\n\tcase I40E_NVMUPD_GET_AQ_RESULT:\n\t\tstatus = i40e_nvmupd_get_aq_result(hw, cmd, bytes, perrno);\n\t\tbreak;\n\n\tcase I40E_NVMUPD_GET_AQ_EVENT:\n\t\tstatus = i40e_nvmupd_get_aq_event(hw, cmd, bytes, perrno);\n\t\tbreak;\n\n\tdefault:\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVMUPD: bad cmd %s in init state\\n\",\n\t\t\t   i40e_nvm_update_state_str[upd_cmd]);\n\t\tstatus = -EIO;\n\t\t*perrno = -ESRCH;\n\t\tbreak;\n\t}\n\treturn status;\n}\n\n \nstatic int i40e_nvmupd_state_reading(struct i40e_hw *hw,\n\t\t\t\t     struct i40e_nvm_access *cmd,\n\t\t\t\t     u8 *bytes, int *perrno)\n{\n\tenum i40e_nvmupd_cmd upd_cmd;\n\tint status = 0;\n\n\tupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\n\n\tswitch (upd_cmd) {\n\tcase I40E_NVMUPD_READ_SA:\n\tcase I40E_NVMUPD_READ_CON:\n\t\tstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\n\t\tbreak;\n\n\tcase I40E_NVMUPD_READ_LCB:\n\t\tstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\n\t\ti40e_release_nvm(hw);\n\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\t\tbreak;\n\n\tdefault:\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVMUPD: bad cmd %s in reading state.\\n\",\n\t\t\t   i40e_nvm_update_state_str[upd_cmd]);\n\t\tstatus = -EOPNOTSUPP;\n\t\t*perrno = -ESRCH;\n\t\tbreak;\n\t}\n\treturn status;\n}\n\n \nstatic int i40e_nvmupd_state_writing(struct i40e_hw *hw,\n\t\t\t\t     struct i40e_nvm_access *cmd,\n\t\t\t\t     u8 *bytes, int *perrno)\n{\n\tenum i40e_nvmupd_cmd upd_cmd;\n\tbool retry_attempt = false;\n\tint status = 0;\n\n\tupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\n\nretry:\n\tswitch (upd_cmd) {\n\tcase I40E_NVMUPD_WRITE_CON:\n\t\tstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\n\t\tif (!status) {\n\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_WRITE_LCB:\n\t\tstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\n\t\tif (status) {\n\t\t\t*perrno = hw->aq.asq_last_status ?\n\t\t\t\t   i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t       hw->aq.asq_last_status) :\n\t\t\t\t   -EIO;\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\t\t} else {\n\t\t\thw->nvm_release_on_done = true;\n\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_CSUM_CON:\n\t\t \n\t\tstatus = i40e_update_nvm_checksum(hw);\n\t\tif (status) {\n\t\t\t*perrno = hw->aq.asq_last_status ?\n\t\t\t\t   i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t       hw->aq.asq_last_status) :\n\t\t\t\t   -EIO;\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\t\t} else {\n\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVMUPD_CSUM_LCB:\n\t\t \n\t\tstatus = i40e_update_nvm_checksum(hw);\n\t\tif (status) {\n\t\t\t*perrno = hw->aq.asq_last_status ?\n\t\t\t\t   i40e_aq_rc_to_posix(status,\n\t\t\t\t\t\t       hw->aq.asq_last_status) :\n\t\t\t\t   -EIO;\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\t\t} else {\n\t\t\thw->nvm_release_on_done = true;\n\t\t\thw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\n\t\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVMUPD: bad cmd %s in writing state.\\n\",\n\t\t\t   i40e_nvm_update_state_str[upd_cmd]);\n\t\tstatus = -EOPNOTSUPP;\n\t\t*perrno = -ESRCH;\n\t\tbreak;\n\t}\n\n\t \n\tif (status && (hw->aq.asq_last_status == I40E_AQ_RC_EBUSY) &&\n\t    !retry_attempt) {\n\t\tu32 old_asq_status = hw->aq.asq_last_status;\n\t\tint old_status = status;\n\t\tu32 gtime;\n\n\t\tgtime = rd32(hw, I40E_GLVFGEN_TIMER);\n\t\tif (gtime >= hw->nvm.hw_semaphore_timeout) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t\t   \"NVMUPD: write semaphore expired (%d >= %lld), retrying\\n\",\n\t\t\t\t   gtime, hw->nvm.hw_semaphore_timeout);\n\t\t\ti40e_release_nvm(hw);\n\t\t\tstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\n\t\t\tif (status) {\n\t\t\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t\t\t   \"NVMUPD: write semaphore reacquire failed aq_err = %d\\n\",\n\t\t\t\t\t   hw->aq.asq_last_status);\n\t\t\t\tstatus = old_status;\n\t\t\t\thw->aq.asq_last_status = old_asq_status;\n\t\t\t} else {\n\t\t\t\tretry_attempt = true;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nvoid i40e_nvmupd_clear_wait_state(struct i40e_hw *hw)\n{\n\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t   \"NVMUPD: clearing wait on opcode 0x%04x\\n\",\n\t\t   hw->nvm_wait_opcode);\n\n\tif (hw->nvm_release_on_done) {\n\t\ti40e_release_nvm(hw);\n\t\thw->nvm_release_on_done = false;\n\t}\n\thw->nvm_wait_opcode = 0;\n\n\tif (hw->aq.arq_last_status) {\n\t\thw->nvmupd_state = I40E_NVMUPD_STATE_ERROR;\n\t\treturn;\n\t}\n\n\tswitch (hw->nvmupd_state) {\n\tcase I40E_NVMUPD_STATE_INIT_WAIT:\n\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\t\tbreak;\n\n\tcase I40E_NVMUPD_STATE_WRITE_WAIT:\n\t\thw->nvmupd_state = I40E_NVMUPD_STATE_WRITING;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid i40e_nvmupd_check_wait_event(struct i40e_hw *hw, u16 opcode,\n\t\t\t\t  struct i40e_aq_desc *desc)\n{\n\tu32 aq_desc_len = sizeof(struct i40e_aq_desc);\n\n\tif (opcode == hw->nvm_wait_opcode) {\n\t\tmemcpy(&hw->nvm_aq_event_desc, desc, aq_desc_len);\n\t\ti40e_nvmupd_clear_wait_state(hw);\n\t}\n}\n\n \nstatic enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw,\n\t\t\t\t\t\t struct i40e_nvm_access *cmd,\n\t\t\t\t\t\t int *perrno)\n{\n\tenum i40e_nvmupd_cmd upd_cmd;\n\tu8 module, transaction;\n\n\t \n\tupd_cmd = I40E_NVMUPD_INVALID;\n\n\ttransaction = i40e_nvmupd_get_transaction(cmd->config);\n\tmodule = i40e_nvmupd_get_module(cmd->config);\n\n\t \n\tif ((cmd->data_size < 1) ||\n\t    (cmd->data_size > I40E_NVMUPD_MAX_DATA)) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_validate_command data_size %d\\n\",\n\t\t\t   cmd->data_size);\n\t\t*perrno = -EFAULT;\n\t\treturn I40E_NVMUPD_INVALID;\n\t}\n\n\tswitch (cmd->command) {\n\tcase I40E_NVM_READ:\n\t\tswitch (transaction) {\n\t\tcase I40E_NVM_CON:\n\t\t\tupd_cmd = I40E_NVMUPD_READ_CON;\n\t\t\tbreak;\n\t\tcase I40E_NVM_SNT:\n\t\t\tupd_cmd = I40E_NVMUPD_READ_SNT;\n\t\t\tbreak;\n\t\tcase I40E_NVM_LCB:\n\t\t\tupd_cmd = I40E_NVMUPD_READ_LCB;\n\t\t\tbreak;\n\t\tcase I40E_NVM_SA:\n\t\t\tupd_cmd = I40E_NVMUPD_READ_SA;\n\t\t\tbreak;\n\t\tcase I40E_NVM_EXEC:\n\t\t\tif (module == 0xf)\n\t\t\t\tupd_cmd = I40E_NVMUPD_STATUS;\n\t\t\telse if (module == 0)\n\t\t\t\tupd_cmd = I40E_NVMUPD_GET_AQ_RESULT;\n\t\t\tbreak;\n\t\tcase I40E_NVM_AQE:\n\t\t\tupd_cmd = I40E_NVMUPD_GET_AQ_EVENT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase I40E_NVM_WRITE:\n\t\tswitch (transaction) {\n\t\tcase I40E_NVM_CON:\n\t\t\tupd_cmd = I40E_NVMUPD_WRITE_CON;\n\t\t\tbreak;\n\t\tcase I40E_NVM_SNT:\n\t\t\tupd_cmd = I40E_NVMUPD_WRITE_SNT;\n\t\t\tbreak;\n\t\tcase I40E_NVM_LCB:\n\t\t\tupd_cmd = I40E_NVMUPD_WRITE_LCB;\n\t\t\tbreak;\n\t\tcase I40E_NVM_SA:\n\t\t\tupd_cmd = I40E_NVMUPD_WRITE_SA;\n\t\t\tbreak;\n\t\tcase I40E_NVM_ERA:\n\t\t\tupd_cmd = I40E_NVMUPD_WRITE_ERA;\n\t\t\tbreak;\n\t\tcase I40E_NVM_CSUM:\n\t\t\tupd_cmd = I40E_NVMUPD_CSUM_CON;\n\t\t\tbreak;\n\t\tcase (I40E_NVM_CSUM|I40E_NVM_SA):\n\t\t\tupd_cmd = I40E_NVMUPD_CSUM_SA;\n\t\t\tbreak;\n\t\tcase (I40E_NVM_CSUM|I40E_NVM_LCB):\n\t\t\tupd_cmd = I40E_NVMUPD_CSUM_LCB;\n\t\t\tbreak;\n\t\tcase I40E_NVM_EXEC:\n\t\t\tif (module == 0)\n\t\t\t\tupd_cmd = I40E_NVMUPD_EXEC_AQ;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn upd_cmd;\n}\n\n \nstatic int i40e_nvmupd_exec_aq(struct i40e_hw *hw,\n\t\t\t       struct i40e_nvm_access *cmd,\n\t\t\t       u8 *bytes, int *perrno)\n{\n\tstruct i40e_asq_cmd_details cmd_details;\n\tstruct i40e_aq_desc *aq_desc;\n\tu32 buff_size = 0;\n\tu8 *buff = NULL;\n\tu32 aq_desc_len;\n\tu32 aq_data_len;\n\tint status;\n\n\ti40e_debug(hw, I40E_DEBUG_NVM, \"NVMUPD: %s\\n\", __func__);\n\tif (cmd->offset == 0xffff)\n\t\treturn 0;\n\n\tmemset(&cmd_details, 0, sizeof(cmd_details));\n\tcmd_details.wb_desc = &hw->nvm_wb_desc;\n\n\taq_desc_len = sizeof(struct i40e_aq_desc);\n\tmemset(&hw->nvm_wb_desc, 0, aq_desc_len);\n\n\t \n\tif (cmd->data_size < aq_desc_len) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"NVMUPD: not enough aq desc bytes for exec, size %d < %d\\n\",\n\t\t\t   cmd->data_size, aq_desc_len);\n\t\t*perrno = -EINVAL;\n\t\treturn -EINVAL;\n\t}\n\taq_desc = (struct i40e_aq_desc *)bytes;\n\n\t \n\taq_data_len = cmd->data_size - aq_desc_len;\n\tbuff_size = max_t(u32, aq_data_len, le16_to_cpu(aq_desc->datalen));\n\tif (buff_size) {\n\t\tif (!hw->nvm_buff.va) {\n\t\t\tstatus = i40e_allocate_virt_mem(hw, &hw->nvm_buff,\n\t\t\t\t\t\t\thw->aq.asq_buf_size);\n\t\t\tif (status)\n\t\t\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t\t\t   \"NVMUPD: i40e_allocate_virt_mem for exec buff failed, %d\\n\",\n\t\t\t\t\t   status);\n\t\t}\n\n\t\tif (hw->nvm_buff.va) {\n\t\t\tbuff = hw->nvm_buff.va;\n\t\t\tmemcpy(buff, &bytes[aq_desc_len], aq_data_len);\n\t\t}\n\t}\n\n\tif (cmd->offset)\n\t\tmemset(&hw->nvm_aq_event_desc, 0, aq_desc_len);\n\n\t \n\tstatus = i40e_asq_send_command(hw, aq_desc, buff,\n\t\t\t\t       buff_size, &cmd_details);\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"%s err %pe aq_err %s\\n\",\n\t\t\t   __func__, ERR_PTR(status),\n\t\t\t   i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\n\t\treturn status;\n\t}\n\n\t \n\tif (cmd->offset) {\n\t\thw->nvm_wait_opcode = cmd->offset;\n\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\n\t}\n\n\treturn status;\n}\n\n \nstatic int i40e_nvmupd_get_aq_result(struct i40e_hw *hw,\n\t\t\t\t     struct i40e_nvm_access *cmd,\n\t\t\t\t     u8 *bytes, int *perrno)\n{\n\tu32 aq_total_len;\n\tu32 aq_desc_len;\n\tint remainder;\n\tu8 *buff;\n\n\ti40e_debug(hw, I40E_DEBUG_NVM, \"NVMUPD: %s\\n\", __func__);\n\n\taq_desc_len = sizeof(struct i40e_aq_desc);\n\taq_total_len = aq_desc_len + le16_to_cpu(hw->nvm_wb_desc.datalen);\n\n\t \n\tif (cmd->offset > aq_total_len) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM, \"%s: offset too big %d > %d\\n\",\n\t\t\t   __func__, cmd->offset, aq_total_len);\n\t\t*perrno = -EINVAL;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cmd->data_size > (aq_total_len - cmd->offset)) {\n\t\tint new_len = aq_total_len - cmd->offset;\n\n\t\ti40e_debug(hw, I40E_DEBUG_NVM, \"%s: copy length %d too big, trimming to %d\\n\",\n\t\t\t   __func__, cmd->data_size, new_len);\n\t\tcmd->data_size = new_len;\n\t}\n\n\tremainder = cmd->data_size;\n\tif (cmd->offset < aq_desc_len) {\n\t\tu32 len = aq_desc_len - cmd->offset;\n\n\t\tlen = min(len, cmd->data_size);\n\t\ti40e_debug(hw, I40E_DEBUG_NVM, \"%s: aq_desc bytes %d to %d\\n\",\n\t\t\t   __func__, cmd->offset, cmd->offset + len);\n\n\t\tbuff = ((u8 *)&hw->nvm_wb_desc) + cmd->offset;\n\t\tmemcpy(bytes, buff, len);\n\n\t\tbytes += len;\n\t\tremainder -= len;\n\t\tbuff = hw->nvm_buff.va;\n\t} else {\n\t\tbuff = hw->nvm_buff.va + (cmd->offset - aq_desc_len);\n\t}\n\n\tif (remainder > 0) {\n\t\tint start_byte = buff - (u8 *)hw->nvm_buff.va;\n\n\t\ti40e_debug(hw, I40E_DEBUG_NVM, \"%s: databuf bytes %d to %d\\n\",\n\t\t\t   __func__, start_byte, start_byte + remainder);\n\t\tmemcpy(bytes, buff, remainder);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_nvmupd_get_aq_event(struct i40e_hw *hw,\n\t\t\t\t    struct i40e_nvm_access *cmd,\n\t\t\t\t    u8 *bytes, int *perrno)\n{\n\tu32 aq_total_len;\n\tu32 aq_desc_len;\n\n\ti40e_debug(hw, I40E_DEBUG_NVM, \"NVMUPD: %s\\n\", __func__);\n\n\taq_desc_len = sizeof(struct i40e_aq_desc);\n\taq_total_len = aq_desc_len + le16_to_cpu(hw->nvm_aq_event_desc.datalen);\n\n\t \n\tif (cmd->data_size > aq_total_len) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"%s: copy length %d too big, trimming to %d\\n\",\n\t\t\t   __func__, cmd->data_size, aq_total_len);\n\t\tcmd->data_size = aq_total_len;\n\t}\n\n\tmemcpy(bytes, &hw->nvm_aq_event_desc, cmd->data_size);\n\n\treturn 0;\n}\n\n \nstatic int i40e_nvmupd_nvm_read(struct i40e_hw *hw,\n\t\t\t\tstruct i40e_nvm_access *cmd,\n\t\t\t\tu8 *bytes, int *perrno)\n{\n\tstruct i40e_asq_cmd_details cmd_details;\n\tu8 module, transaction;\n\tint status;\n\tbool last;\n\n\ttransaction = i40e_nvmupd_get_transaction(cmd->config);\n\tmodule = i40e_nvmupd_get_module(cmd->config);\n\tlast = (transaction == I40E_NVM_LCB) || (transaction == I40E_NVM_SA);\n\n\tmemset(&cmd_details, 0, sizeof(cmd_details));\n\tcmd_details.wb_desc = &hw->nvm_wb_desc;\n\n\tstatus = i40e_aq_read_nvm(hw, module, cmd->offset, (u16)cmd->data_size,\n\t\t\t\t  bytes, last, &cmd_details);\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_nvm_read mod 0x%x  off 0x%x  len 0x%x\\n\",\n\t\t\t   module, cmd->offset, cmd->data_size);\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_nvm_read status %d aq %d\\n\",\n\t\t\t   status, hw->aq.asq_last_status);\n\t\t*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\n\t}\n\n\treturn status;\n}\n\n \nstatic int i40e_nvmupd_nvm_erase(struct i40e_hw *hw,\n\t\t\t\t struct i40e_nvm_access *cmd,\n\t\t\t\t int *perrno)\n{\n\tstruct i40e_asq_cmd_details cmd_details;\n\tu8 module, transaction;\n\tint status = 0;\n\tbool last;\n\n\ttransaction = i40e_nvmupd_get_transaction(cmd->config);\n\tmodule = i40e_nvmupd_get_module(cmd->config);\n\tlast = (transaction & I40E_NVM_LCB);\n\n\tmemset(&cmd_details, 0, sizeof(cmd_details));\n\tcmd_details.wb_desc = &hw->nvm_wb_desc;\n\n\tstatus = i40e_aq_erase_nvm(hw, module, cmd->offset, (u16)cmd->data_size,\n\t\t\t\t   last, &cmd_details);\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_nvm_erase mod 0x%x  off 0x%x len 0x%x\\n\",\n\t\t\t   module, cmd->offset, cmd->data_size);\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_nvm_erase status %d aq %d\\n\",\n\t\t\t   status, hw->aq.asq_last_status);\n\t\t*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\n\t}\n\n\treturn status;\n}\n\n \nstatic int i40e_nvmupd_nvm_write(struct i40e_hw *hw,\n\t\t\t\t struct i40e_nvm_access *cmd,\n\t\t\t\t u8 *bytes, int *perrno)\n{\n\tstruct i40e_asq_cmd_details cmd_details;\n\tu8 module, transaction;\n\tu8 preservation_flags;\n\tint status = 0;\n\tbool last;\n\n\ttransaction = i40e_nvmupd_get_transaction(cmd->config);\n\tmodule = i40e_nvmupd_get_module(cmd->config);\n\tlast = (transaction & I40E_NVM_LCB);\n\tpreservation_flags = i40e_nvmupd_get_preservation_flags(cmd->config);\n\n\tmemset(&cmd_details, 0, sizeof(cmd_details));\n\tcmd_details.wb_desc = &hw->nvm_wb_desc;\n\n\tstatus = i40e_aq_update_nvm(hw, module, cmd->offset,\n\t\t\t\t    (u16)cmd->data_size, bytes, last,\n\t\t\t\t    preservation_flags, &cmd_details);\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_nvm_write mod 0x%x off 0x%x len 0x%x\\n\",\n\t\t\t   module, cmd->offset, cmd->data_size);\n\t\ti40e_debug(hw, I40E_DEBUG_NVM,\n\t\t\t   \"i40e_nvmupd_nvm_write status %d aq %d\\n\",\n\t\t\t   status, hw->aq.asq_last_status);\n\t\t*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}