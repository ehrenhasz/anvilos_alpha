{
  "module_name": "i40e_ddp.c",
  "hash_id": "d0c4191843bf9ce402cfd1adf73e8ef34a7de74a041202dd2e3e47eaa9383cc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_ddp.c",
  "human_readable_source": "\n \n\n#include \"i40e.h\"\n\n#include <linux/firmware.h>\n\n \nstatic bool i40e_ddp_profiles_eq(struct i40e_profile_info *a,\n\t\t\t\t struct i40e_profile_info *b)\n{\n\treturn a->track_id == b->track_id &&\n\t\t!memcmp(&a->version, &b->version, sizeof(a->version)) &&\n\t\t!memcmp(&a->name, &b->name, I40E_DDP_NAME_SIZE);\n}\n\n \nstatic int i40e_ddp_does_profile_exist(struct i40e_hw *hw,\n\t\t\t\t       struct i40e_profile_info *pinfo)\n{\n\tstruct i40e_ddp_profile_list *profile_list;\n\tu8 buff[I40E_PROFILE_LIST_SIZE];\n\tint status;\n\tint i;\n\n\tstatus = i40e_aq_get_ddp_list(hw, buff, I40E_PROFILE_LIST_SIZE, 0,\n\t\t\t\t      NULL);\n\tif (status)\n\t\treturn -1;\n\n\tprofile_list = (struct i40e_ddp_profile_list *)buff;\n\tfor (i = 0; i < profile_list->p_count; i++) {\n\t\tif (i40e_ddp_profiles_eq(pinfo, &profile_list->p_info[i]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic bool i40e_ddp_profiles_overlap(struct i40e_profile_info *new,\n\t\t\t\t      struct i40e_profile_info *old)\n{\n\tunsigned int group_id_old = (u8)((old->track_id & 0x00FF0000) >> 16);\n\tunsigned int group_id_new = (u8)((new->track_id & 0x00FF0000) >> 16);\n\n\t \n\tif (group_id_new == 0)\n\t\treturn true;\n\t \n\tif (group_id_new == 0xFF || group_id_old == 0xFF)\n\t\treturn false;\n\t \n\treturn group_id_old != group_id_new;\n}\n\n \nstatic int i40e_ddp_does_profile_overlap(struct i40e_hw *hw,\n\t\t\t\t\t struct i40e_profile_info *pinfo)\n{\n\tstruct i40e_ddp_profile_list *profile_list;\n\tu8 buff[I40E_PROFILE_LIST_SIZE];\n\tint status;\n\tint i;\n\n\tstatus = i40e_aq_get_ddp_list(hw, buff, I40E_PROFILE_LIST_SIZE, 0,\n\t\t\t\t      NULL);\n\tif (status)\n\t\treturn -EIO;\n\n\tprofile_list = (struct i40e_ddp_profile_list *)buff;\n\tfor (i = 0; i < profile_list->p_count; i++) {\n\t\tif (i40e_ddp_profiles_overlap(pinfo,\n\t\t\t\t\t      &profile_list->p_info[i]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int\ni40e_add_pinfo(struct i40e_hw *hw, struct i40e_profile_segment *profile,\n\t       u8 *profile_info_sec, u32 track_id)\n{\n\tstruct i40e_profile_section_header *sec;\n\tstruct i40e_profile_info *pinfo;\n\tu32 offset = 0, info = 0;\n\tint status;\n\n\tsec = (struct i40e_profile_section_header *)profile_info_sec;\n\tsec->tbl_size = 1;\n\tsec->data_end = sizeof(struct i40e_profile_section_header) +\n\t\t\tsizeof(struct i40e_profile_info);\n\tsec->section.type = SECTION_TYPE_INFO;\n\tsec->section.offset = sizeof(struct i40e_profile_section_header);\n\tsec->section.size = sizeof(struct i40e_profile_info);\n\tpinfo = (struct i40e_profile_info *)(profile_info_sec +\n\t\t\t\t\t     sec->section.offset);\n\tpinfo->track_id = track_id;\n\tpinfo->version = profile->version;\n\tpinfo->op = I40E_DDP_ADD_TRACKID;\n\n\t \n\tmemset(pinfo->reserved, 0, sizeof(pinfo->reserved));\n\tmemcpy(pinfo->name, profile->name, I40E_DDP_NAME_SIZE);\n\n\tstatus = i40e_aq_write_ddp(hw, (void *)sec, sec->data_end,\n\t\t\t\t   track_id, &offset, &info, NULL);\n\treturn status;\n}\n\n \nstatic int\ni40e_del_pinfo(struct i40e_hw *hw, struct i40e_profile_segment *profile,\n\t       u8 *profile_info_sec, u32 track_id)\n{\n\tstruct i40e_profile_section_header *sec;\n\tstruct i40e_profile_info *pinfo;\n\tu32 offset = 0, info = 0;\n\tint status;\n\n\tsec = (struct i40e_profile_section_header *)profile_info_sec;\n\tsec->tbl_size = 1;\n\tsec->data_end = sizeof(struct i40e_profile_section_header) +\n\t\t\tsizeof(struct i40e_profile_info);\n\tsec->section.type = SECTION_TYPE_INFO;\n\tsec->section.offset = sizeof(struct i40e_profile_section_header);\n\tsec->section.size = sizeof(struct i40e_profile_info);\n\tpinfo = (struct i40e_profile_info *)(profile_info_sec +\n\t\t\t\t\t     sec->section.offset);\n\tpinfo->track_id = track_id;\n\tpinfo->version = profile->version;\n\tpinfo->op = I40E_DDP_REMOVE_TRACKID;\n\n\t \n\tmemset(pinfo->reserved, 0, sizeof(pinfo->reserved));\n\tmemcpy(pinfo->name, profile->name, I40E_DDP_NAME_SIZE);\n\n\tstatus = i40e_aq_write_ddp(hw, (void *)sec, sec->data_end,\n\t\t\t\t   track_id, &offset, &info, NULL);\n\treturn status;\n}\n\n \nstatic bool i40e_ddp_is_pkg_hdr_valid(struct net_device *netdev,\n\t\t\t\t      struct i40e_package_header *pkg_hdr,\n\t\t\t\t      size_t size_huge)\n{\n\tu32 size = 0xFFFFFFFFU & size_huge;\n\tu32 pkg_hdr_size;\n\tu32 segment;\n\n\tif (!pkg_hdr)\n\t\treturn false;\n\n\tif (pkg_hdr->version.major > 0) {\n\t\tstruct i40e_ddp_version ver = pkg_hdr->version;\n\n\t\tnetdev_err(netdev, \"Unsupported DDP profile version %u.%u.%u.%u\",\n\t\t\t   ver.major, ver.minor, ver.update, ver.draft);\n\t\treturn false;\n\t}\n\tif (size_huge > size) {\n\t\tnetdev_err(netdev, \"Invalid DDP profile - size is bigger than 4G\");\n\t\treturn false;\n\t}\n\tif (size < (sizeof(struct i40e_package_header) + sizeof(u32) +\n\t\tsizeof(struct i40e_metadata_segment) + sizeof(u32) * 2)) {\n\t\tnetdev_err(netdev, \"Invalid DDP profile - size is too small.\");\n\t\treturn false;\n\t}\n\n\tpkg_hdr_size = sizeof(u32) * (pkg_hdr->segment_count + 2U);\n\tif (size < pkg_hdr_size) {\n\t\tnetdev_err(netdev, \"Invalid DDP profile - too many segments\");\n\t\treturn false;\n\t}\n\tfor (segment = 0; segment < pkg_hdr->segment_count; ++segment) {\n\t\tu32 offset = pkg_hdr->segment_offset[segment];\n\n\t\tif (0xFU & offset) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Invalid DDP profile %u segment alignment\",\n\t\t\t\t   segment);\n\t\t\treturn false;\n\t\t}\n\t\tif (pkg_hdr_size > offset || offset >= size) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Invalid DDP profile %u segment offset\",\n\t\t\t\t   segment);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nint i40e_ddp_load(struct net_device *netdev, const u8 *data, size_t size,\n\t\t  bool is_add)\n{\n\tu8 profile_info_sec[sizeof(struct i40e_profile_section_header) +\n\t\t\t    sizeof(struct i40e_profile_info)];\n\tstruct i40e_metadata_segment *metadata_hdr;\n\tstruct i40e_profile_segment *profile_hdr;\n\tstruct i40e_profile_info pinfo;\n\tstruct i40e_package_header *pkg_hdr;\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tu32 track_id;\n\tint istatus;\n\tint status;\n\n\tpkg_hdr = (struct i40e_package_header *)data;\n\tif (!i40e_ddp_is_pkg_hdr_valid(netdev, pkg_hdr, size))\n\t\treturn -EINVAL;\n\n\tif (size < (sizeof(struct i40e_package_header) + sizeof(u32) +\n\t\t    sizeof(struct i40e_metadata_segment) + sizeof(u32) * 2)) {\n\t\tnetdev_err(netdev, \"Invalid DDP recipe size.\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmetadata_hdr = (struct i40e_metadata_segment *)\n\t\ti40e_find_segment_in_package(SEGMENT_TYPE_METADATA, pkg_hdr);\n\tif (!metadata_hdr) {\n\t\tnetdev_err(netdev, \"Failed to find metadata segment in DDP recipe.\");\n\t\treturn -EINVAL;\n\t}\n\n\ttrack_id = metadata_hdr->track_id;\n\tprofile_hdr = (struct i40e_profile_segment *)\n\t\ti40e_find_segment_in_package(SEGMENT_TYPE_I40E, pkg_hdr);\n\tif (!profile_hdr) {\n\t\tnetdev_err(netdev, \"Failed to find profile segment in DDP recipe.\");\n\t\treturn -EINVAL;\n\t}\n\n\tpinfo.track_id = track_id;\n\tpinfo.version = profile_hdr->version;\n\tif (is_add)\n\t\tpinfo.op = I40E_DDP_ADD_TRACKID;\n\telse\n\t\tpinfo.op = I40E_DDP_REMOVE_TRACKID;\n\n\tmemcpy(pinfo.name, profile_hdr->name, I40E_DDP_NAME_SIZE);\n\n\t \n\tistatus = i40e_ddp_does_profile_exist(&pf->hw, &pinfo);\n\tif (istatus < 0) {\n\t\tnetdev_err(netdev, \"Failed to fetch loaded profiles.\");\n\t\treturn istatus;\n\t}\n\tif (is_add) {\n\t\tif (istatus > 0) {\n\t\t\tnetdev_err(netdev, \"DDP profile already loaded.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tistatus = i40e_ddp_does_profile_overlap(&pf->hw, &pinfo);\n\t\tif (istatus < 0) {\n\t\t\tnetdev_err(netdev, \"Failed to fetch loaded profiles.\");\n\t\t\treturn istatus;\n\t\t}\n\t\tif (istatus > 0) {\n\t\t\tnetdev_err(netdev, \"DDP profile overlaps with existing one.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (istatus == 0) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"DDP profile for deletion does not exist.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (is_add) {\n\t\tstatus = i40e_write_profile(&pf->hw, profile_hdr, track_id);\n\t\tif (status) {\n\t\t\tif (status == -ENODEV) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"Profile is not supported by the device.\");\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t\tnetdev_err(netdev, \"Failed to write DDP profile.\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tstatus = i40e_rollback_profile(&pf->hw, profile_hdr, track_id);\n\t\tif (status) {\n\t\t\tnetdev_err(netdev, \"Failed to remove DDP profile.\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tif (is_add) {\n\t\tstatus = i40e_add_pinfo(&pf->hw, profile_hdr, profile_info_sec,\n\t\t\t\t\ttrack_id);\n\t\tif (status) {\n\t\t\tnetdev_err(netdev, \"Failed to add DDP profile info.\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tstatus = i40e_del_pinfo(&pf->hw, profile_hdr, profile_info_sec,\n\t\t\t\t\ttrack_id);\n\t\tif (status) {\n\t\t\tnetdev_err(netdev, \"Failed to restore DDP profile info.\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_ddp_restore(struct i40e_pf *pf)\n{\n\tstruct i40e_ddp_old_profile_list *entry;\n\tstruct net_device *netdev = pf->vsi[pf->lan_vsi]->netdev;\n\tint status = 0;\n\n\tif (!list_empty(&pf->ddp_old_prof)) {\n\t\tentry = list_first_entry(&pf->ddp_old_prof,\n\t\t\t\t\t struct i40e_ddp_old_profile_list,\n\t\t\t\t\t list);\n\t\tstatus = i40e_ddp_load(netdev, entry->old_ddp_buf,\n\t\t\t\t       entry->old_ddp_size, false);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}\n\n \nint i40e_ddp_flash(struct net_device *netdev, struct ethtool_flash *flash)\n{\n\tconst struct firmware *ddp_config;\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tint status = 0;\n\n\t \n\tif (flash->region != I40_DDP_FLASH_REGION) {\n\t\tnetdev_err(netdev, \"Requested firmware region is not recognized by this driver.\");\n\t\treturn -EINVAL;\n\t}\n\tif (pf->hw.bus.func != 0) {\n\t\tnetdev_err(netdev, \"Any DDP operation is allowed only on Phy0 NIC interface\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (strncmp(flash->data, \"-\", 2) != 0) {\n\t\tstruct i40e_ddp_old_profile_list *list_entry;\n\t\tchar profile_name[sizeof(I40E_DDP_PROFILE_PATH)\n\t\t\t\t  + I40E_DDP_PROFILE_NAME_MAX];\n\n\t\tprofile_name[sizeof(profile_name) - 1] = 0;\n\t\tstrncpy(profile_name, I40E_DDP_PROFILE_PATH,\n\t\t\tsizeof(profile_name) - 1);\n\t\tstrncat(profile_name, flash->data, I40E_DDP_PROFILE_NAME_MAX);\n\t\t \n\t\tstatus = request_firmware(&ddp_config, profile_name,\n\t\t\t\t\t  &netdev->dev);\n\t\tif (status) {\n\t\t\tnetdev_err(netdev, \"DDP recipe file request failed.\");\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = i40e_ddp_load(netdev, ddp_config->data,\n\t\t\t\t       ddp_config->size, true);\n\n\t\tif (!status) {\n\t\t\tlist_entry =\n\t\t\t  kzalloc(sizeof(struct i40e_ddp_old_profile_list) +\n\t\t\t\t  ddp_config->size, GFP_KERNEL);\n\t\t\tif (!list_entry) {\n\t\t\t\tnetdev_info(netdev, \"Failed to allocate memory for previous DDP profile data.\");\n\t\t\t\tnetdev_info(netdev, \"New profile loaded but roll-back will be impossible.\");\n\t\t\t} else {\n\t\t\t\tmemcpy(list_entry->old_ddp_buf,\n\t\t\t\t       ddp_config->data, ddp_config->size);\n\t\t\t\tlist_entry->old_ddp_size = ddp_config->size;\n\t\t\t\tlist_add(&list_entry->list, &pf->ddp_old_prof);\n\t\t\t}\n\t\t}\n\n\t\trelease_firmware(ddp_config);\n\t} else {\n\t\tif (!list_empty(&pf->ddp_old_prof)) {\n\t\t\tstatus = i40e_ddp_restore(pf);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"There is no DDP profile to restore.\");\n\t\t\tstatus = -ENOENT;\n\t\t}\n\t}\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}