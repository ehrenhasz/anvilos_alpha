{
  "module_name": "i40e_common.c",
  "hash_id": "44811c9111289d1e016d9e4a5bb214112efca296c856b56ebee8f6d03688e5c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_common.c",
  "human_readable_source": "\n \n\n#include \"i40e.h\"\n#include \"i40e_type.h\"\n#include \"i40e_adminq.h\"\n#include \"i40e_prototype.h\"\n#include <linux/avf/virtchnl.h>\n\n \nint i40e_set_mac_type(struct i40e_hw *hw)\n{\n\tint status = 0;\n\n\tif (hw->vendor_id == PCI_VENDOR_ID_INTEL) {\n\t\tswitch (hw->device_id) {\n\t\tcase I40E_DEV_ID_SFP_XL710:\n\t\tcase I40E_DEV_ID_QEMU:\n\t\tcase I40E_DEV_ID_KX_B:\n\t\tcase I40E_DEV_ID_KX_C:\n\t\tcase I40E_DEV_ID_QSFP_A:\n\t\tcase I40E_DEV_ID_QSFP_B:\n\t\tcase I40E_DEV_ID_QSFP_C:\n\t\tcase I40E_DEV_ID_1G_BASE_T_BC:\n\t\tcase I40E_DEV_ID_5G_BASE_T_BC:\n\t\tcase I40E_DEV_ID_10G_BASE_T:\n\t\tcase I40E_DEV_ID_10G_BASE_T4:\n\t\tcase I40E_DEV_ID_10G_BASE_T_BC:\n\t\tcase I40E_DEV_ID_10G_B:\n\t\tcase I40E_DEV_ID_10G_SFP:\n\t\tcase I40E_DEV_ID_20G_KR2:\n\t\tcase I40E_DEV_ID_20G_KR2_A:\n\t\tcase I40E_DEV_ID_25G_B:\n\t\tcase I40E_DEV_ID_25G_SFP28:\n\t\tcase I40E_DEV_ID_X710_N3000:\n\t\tcase I40E_DEV_ID_XXV710_N3000:\n\t\t\thw->mac.type = I40E_MAC_XL710;\n\t\t\tbreak;\n\t\tcase I40E_DEV_ID_KX_X722:\n\t\tcase I40E_DEV_ID_QSFP_X722:\n\t\tcase I40E_DEV_ID_SFP_X722:\n\t\tcase I40E_DEV_ID_1G_BASE_T_X722:\n\t\tcase I40E_DEV_ID_10G_BASE_T_X722:\n\t\tcase I40E_DEV_ID_SFP_I_X722:\n\t\tcase I40E_DEV_ID_SFP_X722_A:\n\t\t\thw->mac.type = I40E_MAC_X722;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thw->mac.type = I40E_MAC_GENERIC;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tstatus = -ENODEV;\n\t}\n\n\thw_dbg(hw, \"i40e_set_mac_type found mac: %d, returns: %d\\n\",\n\t\t  hw->mac.type, status);\n\treturn status;\n}\n\n \nconst char *i40e_aq_str(struct i40e_hw *hw, enum i40e_admin_queue_err aq_err)\n{\n\tswitch (aq_err) {\n\tcase I40E_AQ_RC_OK:\n\t\treturn \"OK\";\n\tcase I40E_AQ_RC_EPERM:\n\t\treturn \"I40E_AQ_RC_EPERM\";\n\tcase I40E_AQ_RC_ENOENT:\n\t\treturn \"I40E_AQ_RC_ENOENT\";\n\tcase I40E_AQ_RC_ESRCH:\n\t\treturn \"I40E_AQ_RC_ESRCH\";\n\tcase I40E_AQ_RC_EINTR:\n\t\treturn \"I40E_AQ_RC_EINTR\";\n\tcase I40E_AQ_RC_EIO:\n\t\treturn \"I40E_AQ_RC_EIO\";\n\tcase I40E_AQ_RC_ENXIO:\n\t\treturn \"I40E_AQ_RC_ENXIO\";\n\tcase I40E_AQ_RC_E2BIG:\n\t\treturn \"I40E_AQ_RC_E2BIG\";\n\tcase I40E_AQ_RC_EAGAIN:\n\t\treturn \"I40E_AQ_RC_EAGAIN\";\n\tcase I40E_AQ_RC_ENOMEM:\n\t\treturn \"I40E_AQ_RC_ENOMEM\";\n\tcase I40E_AQ_RC_EACCES:\n\t\treturn \"I40E_AQ_RC_EACCES\";\n\tcase I40E_AQ_RC_EFAULT:\n\t\treturn \"I40E_AQ_RC_EFAULT\";\n\tcase I40E_AQ_RC_EBUSY:\n\t\treturn \"I40E_AQ_RC_EBUSY\";\n\tcase I40E_AQ_RC_EEXIST:\n\t\treturn \"I40E_AQ_RC_EEXIST\";\n\tcase I40E_AQ_RC_EINVAL:\n\t\treturn \"I40E_AQ_RC_EINVAL\";\n\tcase I40E_AQ_RC_ENOTTY:\n\t\treturn \"I40E_AQ_RC_ENOTTY\";\n\tcase I40E_AQ_RC_ENOSPC:\n\t\treturn \"I40E_AQ_RC_ENOSPC\";\n\tcase I40E_AQ_RC_ENOSYS:\n\t\treturn \"I40E_AQ_RC_ENOSYS\";\n\tcase I40E_AQ_RC_ERANGE:\n\t\treturn \"I40E_AQ_RC_ERANGE\";\n\tcase I40E_AQ_RC_EFLUSHED:\n\t\treturn \"I40E_AQ_RC_EFLUSHED\";\n\tcase I40E_AQ_RC_BAD_ADDR:\n\t\treturn \"I40E_AQ_RC_BAD_ADDR\";\n\tcase I40E_AQ_RC_EMODE:\n\t\treturn \"I40E_AQ_RC_EMODE\";\n\tcase I40E_AQ_RC_EFBIG:\n\t\treturn \"I40E_AQ_RC_EFBIG\";\n\t}\n\n\tsnprintf(hw->err_str, sizeof(hw->err_str), \"%d\", aq_err);\n\treturn hw->err_str;\n}\n\n \nvoid i40e_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc,\n\t\t   void *buffer, u16 buf_len)\n{\n\tstruct i40e_aq_desc *aq_desc = (struct i40e_aq_desc *)desc;\n\tu32 effective_mask = hw->debug_mask & mask;\n\tchar prefix[27];\n\tu16 len;\n\tu8 *buf = (u8 *)buffer;\n\n\tif (!effective_mask || !desc)\n\t\treturn;\n\n\tlen = le16_to_cpu(aq_desc->datalen);\n\n\ti40e_debug(hw, mask & I40E_DEBUG_AQ_DESCRIPTOR,\n\t\t   \"AQ CMD: opcode 0x%04X, flags 0x%04X, datalen 0x%04X, retval 0x%04X\\n\",\n\t\t   le16_to_cpu(aq_desc->opcode),\n\t\t   le16_to_cpu(aq_desc->flags),\n\t\t   le16_to_cpu(aq_desc->datalen),\n\t\t   le16_to_cpu(aq_desc->retval));\n\ti40e_debug(hw, mask & I40E_DEBUG_AQ_DESCRIPTOR,\n\t\t   \"\\tcookie (h,l) 0x%08X 0x%08X\\n\",\n\t\t   le32_to_cpu(aq_desc->cookie_high),\n\t\t   le32_to_cpu(aq_desc->cookie_low));\n\ti40e_debug(hw, mask & I40E_DEBUG_AQ_DESCRIPTOR,\n\t\t   \"\\tparam (0,1)  0x%08X 0x%08X\\n\",\n\t\t   le32_to_cpu(aq_desc->params.internal.param0),\n\t\t   le32_to_cpu(aq_desc->params.internal.param1));\n\ti40e_debug(hw, mask & I40E_DEBUG_AQ_DESCRIPTOR,\n\t\t   \"\\taddr (h,l)   0x%08X 0x%08X\\n\",\n\t\t   le32_to_cpu(aq_desc->params.external.addr_high),\n\t\t   le32_to_cpu(aq_desc->params.external.addr_low));\n\n\tif (buffer && buf_len != 0 && len != 0 &&\n\t    (effective_mask & I40E_DEBUG_AQ_DESC_BUFFER)) {\n\t\ti40e_debug(hw, mask, \"AQ CMD Buffer:\\n\");\n\t\tif (buf_len < len)\n\t\t\tlen = buf_len;\n\n\t\tsnprintf(prefix, sizeof(prefix),\n\t\t\t \"i40e %02x:%02x.%x: \\t0x\",\n\t\t\t hw->bus.bus_id,\n\t\t\t hw->bus.device,\n\t\t\t hw->bus.func);\n\n\t\tprint_hex_dump(KERN_INFO, prefix, DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, buf, len, false);\n\t}\n}\n\n \nbool i40e_check_asq_alive(struct i40e_hw *hw)\n{\n\tif (hw->aq.asq.len)\n\t\treturn !!(rd32(hw, hw->aq.asq.len) &\n\t\t\t  I40E_PF_ATQLEN_ATQENABLE_MASK);\n\telse\n\t\treturn false;\n}\n\n \nint i40e_aq_queue_shutdown(struct i40e_hw *hw,\n\t\t\t   bool unloading)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_queue_shutdown *cmd =\n\t\t(struct i40e_aqc_queue_shutdown *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_queue_shutdown);\n\n\tif (unloading)\n\t\tcmd->driver_unloading = cpu_to_le32(I40E_AQ_DRIVER_UNLOADING);\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, NULL);\n\n\treturn status;\n}\n\n \nstatic int i40e_aq_get_set_rss_lut(struct i40e_hw *hw,\n\t\t\t\t   u16 vsi_id, bool pf_lut,\n\t\t\t\t   u8 *lut, u16 lut_size,\n\t\t\t\t   bool set)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_get_set_rss_lut *cmd_resp =\n\t\t   (struct i40e_aqc_get_set_rss_lut *)&desc.params.raw;\n\tint status;\n\n\tif (set)\n\t\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t\t  i40e_aqc_opc_set_rss_lut);\n\telse\n\t\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t\t  i40e_aqc_opc_get_rss_lut);\n\n\t \n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_RD);\n\n\tcmd_resp->vsi_id =\n\t\t\tcpu_to_le16((u16)((vsi_id <<\n\t\t\t\t\t  I40E_AQC_SET_RSS_LUT_VSI_ID_SHIFT) &\n\t\t\t\t\t  I40E_AQC_SET_RSS_LUT_VSI_ID_MASK));\n\tcmd_resp->vsi_id |= cpu_to_le16((u16)I40E_AQC_SET_RSS_LUT_VSI_VALID);\n\n\tif (pf_lut)\n\t\tcmd_resp->flags |= cpu_to_le16((u16)\n\t\t\t\t\t((I40E_AQC_SET_RSS_LUT_TABLE_TYPE_PF <<\n\t\t\t\t\tI40E_AQC_SET_RSS_LUT_TABLE_TYPE_SHIFT) &\n\t\t\t\t\tI40E_AQC_SET_RSS_LUT_TABLE_TYPE_MASK));\n\telse\n\t\tcmd_resp->flags |= cpu_to_le16((u16)\n\t\t\t\t\t((I40E_AQC_SET_RSS_LUT_TABLE_TYPE_VSI <<\n\t\t\t\t\tI40E_AQC_SET_RSS_LUT_TABLE_TYPE_SHIFT) &\n\t\t\t\t\tI40E_AQC_SET_RSS_LUT_TABLE_TYPE_MASK));\n\n\tstatus = i40e_asq_send_command(hw, &desc, lut, lut_size, NULL);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id,\n\t\t\tbool pf_lut, u8 *lut, u16 lut_size)\n{\n\treturn i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size,\n\t\t\t\t       false);\n}\n\n \nint i40e_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id,\n\t\t\tbool pf_lut, u8 *lut, u16 lut_size)\n{\n\treturn i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size, true);\n}\n\n \nstatic int i40e_aq_get_set_rss_key(struct i40e_hw *hw,\n\t\t\t\t   u16 vsi_id,\n\t\t\t\t   struct i40e_aqc_get_set_rss_key_data *key,\n\t\t\t\t   bool set)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_get_set_rss_key *cmd_resp =\n\t\t\t(struct i40e_aqc_get_set_rss_key *)&desc.params.raw;\n\tu16 key_size = sizeof(struct i40e_aqc_get_set_rss_key_data);\n\tint status;\n\n\tif (set)\n\t\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t\t  i40e_aqc_opc_set_rss_key);\n\telse\n\t\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t\t  i40e_aqc_opc_get_rss_key);\n\n\t \n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_RD);\n\n\tcmd_resp->vsi_id =\n\t\t\tcpu_to_le16((u16)((vsi_id <<\n\t\t\t\t\t  I40E_AQC_SET_RSS_KEY_VSI_ID_SHIFT) &\n\t\t\t\t\t  I40E_AQC_SET_RSS_KEY_VSI_ID_MASK));\n\tcmd_resp->vsi_id |= cpu_to_le16((u16)I40E_AQC_SET_RSS_KEY_VSI_VALID);\n\n\tstatus = i40e_asq_send_command(hw, &desc, key, key_size, NULL);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_rss_key(struct i40e_hw *hw,\n\t\t\tu16 vsi_id,\n\t\t\tstruct i40e_aqc_get_set_rss_key_data *key)\n{\n\treturn i40e_aq_get_set_rss_key(hw, vsi_id, key, false);\n}\n\n \nint i40e_aq_set_rss_key(struct i40e_hw *hw,\n\t\t\tu16 vsi_id,\n\t\t\tstruct i40e_aqc_get_set_rss_key_data *key)\n{\n\treturn i40e_aq_get_set_rss_key(hw, vsi_id, key, true);\n}\n\n \n\n \n#define I40E_PTT(PTYPE, OUTER_IP, OUTER_IP_VER, OUTER_FRAG, T, TE, TEF, I, PL)\\\n\t[PTYPE] = { \\\n\t\t1, \\\n\t\tI40E_RX_PTYPE_OUTER_##OUTER_IP, \\\n\t\tI40E_RX_PTYPE_OUTER_##OUTER_IP_VER, \\\n\t\tI40E_RX_PTYPE_##OUTER_FRAG, \\\n\t\tI40E_RX_PTYPE_TUNNEL_##T, \\\n\t\tI40E_RX_PTYPE_TUNNEL_END_##TE, \\\n\t\tI40E_RX_PTYPE_##TEF, \\\n\t\tI40E_RX_PTYPE_INNER_PROT_##I, \\\n\t\tI40E_RX_PTYPE_PAYLOAD_LAYER_##PL }\n\n#define I40E_PTT_UNUSED_ENTRY(PTYPE) [PTYPE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n\n \n#define I40E_RX_PTYPE_NOF\t\tI40E_RX_PTYPE_NOT_FRAG\n#define I40E_RX_PTYPE_FRG\t\tI40E_RX_PTYPE_FRAG\n#define I40E_RX_PTYPE_INNER_PROT_TS\tI40E_RX_PTYPE_INNER_PROT_TIMESYNC\n\n \nstruct i40e_rx_ptype_decoded i40e_ptype_lookup[BIT(8)] = {\n\t \n\tI40E_PTT_UNUSED_ENTRY(0),\n\tI40E_PTT(1,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),\n\tI40E_PTT(2,  L2, NONE, NOF, NONE, NONE, NOF, TS,   PAY2),\n\tI40E_PTT(3,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),\n\tI40E_PTT_UNUSED_ENTRY(4),\n\tI40E_PTT_UNUSED_ENTRY(5),\n\tI40E_PTT(6,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),\n\tI40E_PTT(7,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),\n\tI40E_PTT_UNUSED_ENTRY(8),\n\tI40E_PTT_UNUSED_ENTRY(9),\n\tI40E_PTT(10, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),\n\tI40E_PTT(11, L2, NONE, NOF, NONE, NONE, NOF, NONE, NONE),\n\tI40E_PTT(12, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(13, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(14, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(15, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(16, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(17, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(18, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(19, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(20, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(21, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),\n\n\t \n\tI40E_PTT(22, IP, IPV4, FRG, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(23, IP, IPV4, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(24, IP, IPV4, NOF, NONE, NONE, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(25),\n\tI40E_PTT(26, IP, IPV4, NOF, NONE, NONE, NOF, TCP,  PAY4),\n\tI40E_PTT(27, IP, IPV4, NOF, NONE, NONE, NOF, SCTP, PAY4),\n\tI40E_PTT(28, IP, IPV4, NOF, NONE, NONE, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(29, IP, IPV4, NOF, IP_IP, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(30, IP, IPV4, NOF, IP_IP, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(31, IP, IPV4, NOF, IP_IP, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(32),\n\tI40E_PTT(33, IP, IPV4, NOF, IP_IP, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(34, IP, IPV4, NOF, IP_IP, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(35, IP, IPV4, NOF, IP_IP, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(36, IP, IPV4, NOF, IP_IP, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(37, IP, IPV4, NOF, IP_IP, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(38, IP, IPV4, NOF, IP_IP, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(39),\n\tI40E_PTT(40, IP, IPV4, NOF, IP_IP, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(41, IP, IPV4, NOF, IP_IP, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(42, IP, IPV4, NOF, IP_IP, IPV6, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(43, IP, IPV4, NOF, IP_GRENAT, NONE, NOF, NONE, PAY3),\n\n\t \n\tI40E_PTT(44, IP, IPV4, NOF, IP_GRENAT, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(45, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(46, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(47),\n\tI40E_PTT(48, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(49, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(50, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(51, IP, IPV4, NOF, IP_GRENAT, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(52, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(53, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(54),\n\tI40E_PTT(55, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(56, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(57, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(58, IP, IPV4, NOF, IP_GRENAT_MAC, NONE, NOF, NONE, PAY3),\n\n\t \n\tI40E_PTT(59, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(60, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(61, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(62),\n\tI40E_PTT(63, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(64, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(65, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(66, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(67, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(68, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(69),\n\tI40E_PTT(70, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(71, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(72, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(73, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, NONE, NOF, NONE, PAY3),\n\n\t \n\tI40E_PTT(74, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(75, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(76, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(77),\n\tI40E_PTT(78, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(79, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(80, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(81, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(82, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(83, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(84),\n\tI40E_PTT(85, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(86, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(87, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(88, IP, IPV6, FRG, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(89, IP, IPV6, NOF, NONE, NONE, NOF, NONE, PAY3),\n\tI40E_PTT(90, IP, IPV6, NOF, NONE, NONE, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(91),\n\tI40E_PTT(92, IP, IPV6, NOF, NONE, NONE, NOF, TCP,  PAY4),\n\tI40E_PTT(93, IP, IPV6, NOF, NONE, NONE, NOF, SCTP, PAY4),\n\tI40E_PTT(94, IP, IPV6, NOF, NONE, NONE, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(95,  IP, IPV6, NOF, IP_IP, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(96,  IP, IPV6, NOF, IP_IP, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(97,  IP, IPV6, NOF, IP_IP, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(98),\n\tI40E_PTT(99,  IP, IPV6, NOF, IP_IP, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(100, IP, IPV6, NOF, IP_IP, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(101, IP, IPV6, NOF, IP_IP, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(102, IP, IPV6, NOF, IP_IP, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(103, IP, IPV6, NOF, IP_IP, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(104, IP, IPV6, NOF, IP_IP, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(105),\n\tI40E_PTT(106, IP, IPV6, NOF, IP_IP, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(107, IP, IPV6, NOF, IP_IP, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(108, IP, IPV6, NOF, IP_IP, IPV6, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(109, IP, IPV6, NOF, IP_GRENAT, NONE, NOF, NONE, PAY3),\n\n\t \n\tI40E_PTT(110, IP, IPV6, NOF, IP_GRENAT, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(111, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(112, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(113),\n\tI40E_PTT(114, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(115, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(116, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(117, IP, IPV6, NOF, IP_GRENAT, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(118, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(119, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(120),\n\tI40E_PTT(121, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(122, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(123, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(124, IP, IPV6, NOF, IP_GRENAT_MAC, NONE, NOF, NONE, PAY3),\n\n\t \n\tI40E_PTT(125, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(126, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(127, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(128),\n\tI40E_PTT(129, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(130, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(131, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(132, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(133, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(134, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(135),\n\tI40E_PTT(136, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(137, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(138, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(139, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, NONE, NOF, NONE, PAY3),\n\n\t \n\tI40E_PTT(140, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, FRG, NONE, PAY3),\n\tI40E_PTT(141, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, NONE, PAY3),\n\tI40E_PTT(142, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(143),\n\tI40E_PTT(144, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, TCP,  PAY4),\n\tI40E_PTT(145, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, SCTP, PAY4),\n\tI40E_PTT(146, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, ICMP, PAY4),\n\n\t \n\tI40E_PTT(147, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, FRG, NONE, PAY3),\n\tI40E_PTT(148, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, NONE, PAY3),\n\tI40E_PTT(149, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, UDP,  PAY4),\n\tI40E_PTT_UNUSED_ENTRY(150),\n\tI40E_PTT(151, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, TCP,  PAY4),\n\tI40E_PTT(152, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, SCTP, PAY4),\n\tI40E_PTT(153, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, ICMP, PAY4),\n\n\t \n\t[154 ... 255] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n};\n\n \nint i40e_init_shared_code(struct i40e_hw *hw)\n{\n\tu32 port, ari, func_rid;\n\tint status = 0;\n\n\ti40e_set_mac_type(hw);\n\n\tswitch (hw->mac.type) {\n\tcase I40E_MAC_XL710:\n\tcase I40E_MAC_X722:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\thw->phy.get_link_info = true;\n\n\t \n\tport = (rd32(hw, I40E_PFGEN_PORTNUM) & I40E_PFGEN_PORTNUM_PORT_NUM_MASK)\n\t\t\t\t\t   >> I40E_PFGEN_PORTNUM_PORT_NUM_SHIFT;\n\thw->port = (u8)port;\n\tari = (rd32(hw, I40E_GLPCI_CAPSUP) & I40E_GLPCI_CAPSUP_ARI_EN_MASK) >>\n\t\t\t\t\t\t I40E_GLPCI_CAPSUP_ARI_EN_SHIFT;\n\tfunc_rid = rd32(hw, I40E_PF_FUNC_RID);\n\tif (ari)\n\t\thw->pf_id = (u8)(func_rid & 0xff);\n\telse\n\t\thw->pf_id = (u8)(func_rid & 0x7);\n\n\tstatus = i40e_init_nvm(hw);\n\treturn status;\n}\n\n \nstatic int\ni40e_aq_mac_address_read(struct i40e_hw *hw,\n\t\t\t u16 *flags,\n\t\t\t struct i40e_aqc_mac_address_read_data *addrs,\n\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_mac_address_read *cmd_data =\n\t\t(struct i40e_aqc_mac_address_read *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_mac_address_read);\n\tdesc.flags |= cpu_to_le16(I40E_AQ_FLAG_BUF);\n\n\tstatus = i40e_asq_send_command(hw, &desc, addrs,\n\t\t\t\t       sizeof(*addrs), cmd_details);\n\t*flags = le16_to_cpu(cmd_data->command_flags);\n\n\treturn status;\n}\n\n \nint i40e_aq_mac_address_write(struct i40e_hw *hw,\n\t\t\t      u16 flags, u8 *mac_addr,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_mac_address_write *cmd_data =\n\t\t(struct i40e_aqc_mac_address_write *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_mac_address_write);\n\tcmd_data->command_flags = cpu_to_le16(flags);\n\tcmd_data->mac_sah = cpu_to_le16((u16)mac_addr[0] << 8 | mac_addr[1]);\n\tcmd_data->mac_sal = cpu_to_le32(((u32)mac_addr[2] << 24) |\n\t\t\t\t\t((u32)mac_addr[3] << 16) |\n\t\t\t\t\t((u32)mac_addr[4] << 8) |\n\t\t\t\t\tmac_addr[5]);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_get_mac_addr(struct i40e_hw *hw, u8 *mac_addr)\n{\n\tstruct i40e_aqc_mac_address_read_data addrs;\n\tu16 flags = 0;\n\tint status;\n\n\tstatus = i40e_aq_mac_address_read(hw, &flags, &addrs, NULL);\n\n\tif (flags & I40E_AQC_LAN_ADDR_VALID)\n\t\tether_addr_copy(mac_addr, addrs.pf_lan_mac);\n\n\treturn status;\n}\n\n \nint i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr)\n{\n\tstruct i40e_aqc_mac_address_read_data addrs;\n\tu16 flags = 0;\n\tint status;\n\n\tstatus = i40e_aq_mac_address_read(hw, &flags, &addrs, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif (flags & I40E_AQC_PORT_ADDR_VALID)\n\t\tether_addr_copy(mac_addr, addrs.port_mac);\n\telse\n\t\tstatus = -EINVAL;\n\n\treturn status;\n}\n\n \nvoid i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable)\n{\n\tu32 abs_queue_idx = hw->func_caps.base_queue + queue;\n\tu32 reg_block = 0;\n\tu32 reg_val;\n\n\tif (abs_queue_idx >= 128) {\n\t\treg_block = abs_queue_idx / 128;\n\t\tabs_queue_idx %= 128;\n\t}\n\n\treg_val = rd32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block));\n\treg_val &= ~I40E_GLLAN_TXPRE_QDIS_QINDX_MASK;\n\treg_val |= (abs_queue_idx << I40E_GLLAN_TXPRE_QDIS_QINDX_SHIFT);\n\n\tif (enable)\n\t\treg_val |= I40E_GLLAN_TXPRE_QDIS_CLEAR_QDIS_MASK;\n\telse\n\t\treg_val |= I40E_GLLAN_TXPRE_QDIS_SET_QDIS_MASK;\n\n\twr32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block), reg_val);\n}\n\n \nint i40e_read_pba_string(struct i40e_hw *hw, u8 *pba_num,\n\t\t\t u32 pba_num_size)\n{\n\tu16 pba_word = 0;\n\tu16 pba_size = 0;\n\tu16 pba_ptr = 0;\n\tint status = 0;\n\tu16 i = 0;\n\n\tstatus = i40e_read_nvm_word(hw, I40E_SR_PBA_FLAGS, &pba_word);\n\tif (status || (pba_word != 0xFAFA)) {\n\t\thw_dbg(hw, \"Failed to read PBA flags or flag is invalid.\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = i40e_read_nvm_word(hw, I40E_SR_PBA_BLOCK_PTR, &pba_ptr);\n\tif (status) {\n\t\thw_dbg(hw, \"Failed to read PBA Block pointer.\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = i40e_read_nvm_word(hw, pba_ptr, &pba_size);\n\tif (status) {\n\t\thw_dbg(hw, \"Failed to read PBA Block size.\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tpba_size--;\n\tif (pba_num_size < (((u32)pba_size * 2) + 1)) {\n\t\thw_dbg(hw, \"Buffer too small for PBA data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < pba_size; i++) {\n\t\tstatus = i40e_read_nvm_word(hw, (pba_ptr + 1) + i, &pba_word);\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Failed to read PBA Block word %d.\\n\", i);\n\t\t\treturn status;\n\t\t}\n\n\t\tpba_num[(i * 2)] = (pba_word >> 8) & 0xFF;\n\t\tpba_num[(i * 2) + 1] = pba_word & 0xFF;\n\t}\n\tpba_num[(pba_size * 2)] = '\\0';\n\n\treturn status;\n}\n\n \nstatic enum i40e_media_type i40e_get_media_type(struct i40e_hw *hw)\n{\n\tenum i40e_media_type media;\n\n\tswitch (hw->phy.link_info.phy_type) {\n\tcase I40E_PHY_TYPE_10GBASE_SR:\n\tcase I40E_PHY_TYPE_10GBASE_LR:\n\tcase I40E_PHY_TYPE_1000BASE_SX:\n\tcase I40E_PHY_TYPE_1000BASE_LX:\n\tcase I40E_PHY_TYPE_40GBASE_SR4:\n\tcase I40E_PHY_TYPE_40GBASE_LR4:\n\tcase I40E_PHY_TYPE_25GBASE_LR:\n\tcase I40E_PHY_TYPE_25GBASE_SR:\n\t\tmedia = I40E_MEDIA_TYPE_FIBER;\n\t\tbreak;\n\tcase I40E_PHY_TYPE_100BASE_TX:\n\tcase I40E_PHY_TYPE_1000BASE_T:\n\tcase I40E_PHY_TYPE_2_5GBASE_T_LINK_STATUS:\n\tcase I40E_PHY_TYPE_5GBASE_T_LINK_STATUS:\n\tcase I40E_PHY_TYPE_10GBASE_T:\n\t\tmedia = I40E_MEDIA_TYPE_BASET;\n\t\tbreak;\n\tcase I40E_PHY_TYPE_10GBASE_CR1_CU:\n\tcase I40E_PHY_TYPE_40GBASE_CR4_CU:\n\tcase I40E_PHY_TYPE_10GBASE_CR1:\n\tcase I40E_PHY_TYPE_40GBASE_CR4:\n\tcase I40E_PHY_TYPE_10GBASE_SFPP_CU:\n\tcase I40E_PHY_TYPE_40GBASE_AOC:\n\tcase I40E_PHY_TYPE_10GBASE_AOC:\n\tcase I40E_PHY_TYPE_25GBASE_CR:\n\tcase I40E_PHY_TYPE_25GBASE_AOC:\n\tcase I40E_PHY_TYPE_25GBASE_ACC:\n\t\tmedia = I40E_MEDIA_TYPE_DA;\n\t\tbreak;\n\tcase I40E_PHY_TYPE_1000BASE_KX:\n\tcase I40E_PHY_TYPE_10GBASE_KX4:\n\tcase I40E_PHY_TYPE_10GBASE_KR:\n\tcase I40E_PHY_TYPE_40GBASE_KR4:\n\tcase I40E_PHY_TYPE_20GBASE_KR2:\n\tcase I40E_PHY_TYPE_25GBASE_KR:\n\t\tmedia = I40E_MEDIA_TYPE_BACKPLANE;\n\t\tbreak;\n\tcase I40E_PHY_TYPE_SGMII:\n\tcase I40E_PHY_TYPE_XAUI:\n\tcase I40E_PHY_TYPE_XFI:\n\tcase I40E_PHY_TYPE_XLAUI:\n\tcase I40E_PHY_TYPE_XLPPI:\n\tdefault:\n\t\tmedia = I40E_MEDIA_TYPE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn media;\n}\n\n \nstatic int i40e_poll_globr(struct i40e_hw *hw,\n\t\t\t   u32 retry_limit)\n{\n\tu32 cnt, reg = 0;\n\n\tfor (cnt = 0; cnt < retry_limit; cnt++) {\n\t\treg = rd32(hw, I40E_GLGEN_RSTAT);\n\t\tif (!(reg & I40E_GLGEN_RSTAT_DEVSTATE_MASK))\n\t\t\treturn 0;\n\t\tmsleep(100);\n\t}\n\n\thw_dbg(hw, \"Global reset failed.\\n\");\n\thw_dbg(hw, \"I40E_GLGEN_RSTAT = 0x%x\\n\", reg);\n\n\treturn -EIO;\n}\n\n#define I40E_PF_RESET_WAIT_COUNT_A0\t200\n#define I40E_PF_RESET_WAIT_COUNT\t200\n \nint i40e_pf_reset(struct i40e_hw *hw)\n{\n\tu32 cnt = 0;\n\tu32 cnt1 = 0;\n\tu32 reg = 0;\n\tu32 grst_del;\n\n\t \n\tgrst_del = (rd32(hw, I40E_GLGEN_RSTCTL) &\n\t\t    I40E_GLGEN_RSTCTL_GRSTDEL_MASK) >>\n\t\t    I40E_GLGEN_RSTCTL_GRSTDEL_SHIFT;\n\n\t \n\tgrst_del = grst_del * 20;\n\n\tfor (cnt = 0; cnt < grst_del; cnt++) {\n\t\treg = rd32(hw, I40E_GLGEN_RSTAT);\n\t\tif (!(reg & I40E_GLGEN_RSTAT_DEVSTATE_MASK))\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\tif (reg & I40E_GLGEN_RSTAT_DEVSTATE_MASK) {\n\t\thw_dbg(hw, \"Global reset polling failed to complete.\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (cnt1 = 0; cnt1 < I40E_PF_RESET_WAIT_COUNT; cnt1++) {\n\t\treg = rd32(hw, I40E_GLNVM_ULD);\n\t\treg &= (I40E_GLNVM_ULD_CONF_CORE_DONE_MASK |\n\t\t\tI40E_GLNVM_ULD_CONF_GLOBAL_DONE_MASK);\n\t\tif (reg == (I40E_GLNVM_ULD_CONF_CORE_DONE_MASK |\n\t\t\t    I40E_GLNVM_ULD_CONF_GLOBAL_DONE_MASK)) {\n\t\t\thw_dbg(hw, \"Core and Global modules ready %d\\n\", cnt1);\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10000, 20000);\n\t}\n\tif (!(reg & (I40E_GLNVM_ULD_CONF_CORE_DONE_MASK |\n\t\t     I40E_GLNVM_ULD_CONF_GLOBAL_DONE_MASK))) {\n\t\thw_dbg(hw, \"wait for FW Reset complete timedout\\n\");\n\t\thw_dbg(hw, \"I40E_GLNVM_ULD = 0x%x\\n\", reg);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!cnt) {\n\t\tu32 reg2 = 0;\n\t\tif (hw->revision_id == 0)\n\t\t\tcnt = I40E_PF_RESET_WAIT_COUNT_A0;\n\t\telse\n\t\t\tcnt = I40E_PF_RESET_WAIT_COUNT;\n\t\treg = rd32(hw, I40E_PFGEN_CTRL);\n\t\twr32(hw, I40E_PFGEN_CTRL,\n\t\t     (reg | I40E_PFGEN_CTRL_PFSWR_MASK));\n\t\tfor (; cnt; cnt--) {\n\t\t\treg = rd32(hw, I40E_PFGEN_CTRL);\n\t\t\tif (!(reg & I40E_PFGEN_CTRL_PFSWR_MASK))\n\t\t\t\tbreak;\n\t\t\treg2 = rd32(hw, I40E_GLGEN_RSTAT);\n\t\t\tif (reg2 & I40E_GLGEN_RSTAT_DEVSTATE_MASK)\n\t\t\t\tbreak;\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\t\tif (reg2 & I40E_GLGEN_RSTAT_DEVSTATE_MASK) {\n\t\t\tif (i40e_poll_globr(hw, grst_del))\n\t\t\t\treturn -EIO;\n\t\t} else if (reg & I40E_PFGEN_CTRL_PFSWR_MASK) {\n\t\t\thw_dbg(hw, \"PF reset polling failed to complete.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\ti40e_clear_pxe_mode(hw);\n\n\treturn 0;\n}\n\n \nvoid i40e_clear_hw(struct i40e_hw *hw)\n{\n\tu32 num_queues, base_queue;\n\tu32 num_pf_int;\n\tu32 num_vf_int;\n\tu32 num_vfs;\n\tu32 i, j;\n\tu32 val;\n\tu32 eol = 0x7ff;\n\n\t \n\tval = rd32(hw, I40E_GLPCI_CNF2);\n\tnum_pf_int = (val & I40E_GLPCI_CNF2_MSI_X_PF_N_MASK) >>\n\t\t     I40E_GLPCI_CNF2_MSI_X_PF_N_SHIFT;\n\tnum_vf_int = (val & I40E_GLPCI_CNF2_MSI_X_VF_N_MASK) >>\n\t\t     I40E_GLPCI_CNF2_MSI_X_VF_N_SHIFT;\n\n\tval = rd32(hw, I40E_PFLAN_QALLOC);\n\tbase_queue = (val & I40E_PFLAN_QALLOC_FIRSTQ_MASK) >>\n\t\t     I40E_PFLAN_QALLOC_FIRSTQ_SHIFT;\n\tj = (val & I40E_PFLAN_QALLOC_LASTQ_MASK) >>\n\t    I40E_PFLAN_QALLOC_LASTQ_SHIFT;\n\tif (val & I40E_PFLAN_QALLOC_VALID_MASK && j >= base_queue)\n\t\tnum_queues = (j - base_queue) + 1;\n\telse\n\t\tnum_queues = 0;\n\n\tval = rd32(hw, I40E_PF_VT_PFALLOC);\n\ti = (val & I40E_PF_VT_PFALLOC_FIRSTVF_MASK) >>\n\t    I40E_PF_VT_PFALLOC_FIRSTVF_SHIFT;\n\tj = (val & I40E_PF_VT_PFALLOC_LASTVF_MASK) >>\n\t    I40E_PF_VT_PFALLOC_LASTVF_SHIFT;\n\tif (val & I40E_PF_VT_PFALLOC_VALID_MASK && j >= i)\n\t\tnum_vfs = (j - i) + 1;\n\telse\n\t\tnum_vfs = 0;\n\n\t \n\twr32(hw, I40E_PFINT_ICR0_ENA, 0);\n\tval = 0x3 << I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT;\n\tfor (i = 0; i < num_pf_int - 2; i++)\n\t\twr32(hw, I40E_PFINT_DYN_CTLN(i), val);\n\n\t \n\tval = eol << I40E_PFINT_LNKLST0_FIRSTQ_INDX_SHIFT;\n\twr32(hw, I40E_PFINT_LNKLST0, val);\n\tfor (i = 0; i < num_pf_int - 2; i++)\n\t\twr32(hw, I40E_PFINT_LNKLSTN(i), val);\n\tval = eol << I40E_VPINT_LNKLST0_FIRSTQ_INDX_SHIFT;\n\tfor (i = 0; i < num_vfs; i++)\n\t\twr32(hw, I40E_VPINT_LNKLST0(i), val);\n\tfor (i = 0; i < num_vf_int - 2; i++)\n\t\twr32(hw, I40E_VPINT_LNKLSTN(i), val);\n\n\t \n\tfor (i = 0; i < num_queues; i++) {\n\t\tu32 abs_queue_idx = base_queue + i;\n\t\tu32 reg_block = 0;\n\n\t\tif (abs_queue_idx >= 128) {\n\t\t\treg_block = abs_queue_idx / 128;\n\t\t\tabs_queue_idx %= 128;\n\t\t}\n\n\t\tval = rd32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block));\n\t\tval &= ~I40E_GLLAN_TXPRE_QDIS_QINDX_MASK;\n\t\tval |= (abs_queue_idx << I40E_GLLAN_TXPRE_QDIS_QINDX_SHIFT);\n\t\tval |= I40E_GLLAN_TXPRE_QDIS_SET_QDIS_MASK;\n\n\t\twr32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block), val);\n\t}\n\tudelay(400);\n\n\t \n\tfor (i = 0; i < num_queues; i++) {\n\t\twr32(hw, I40E_QINT_TQCTL(i), 0);\n\t\twr32(hw, I40E_QTX_ENA(i), 0);\n\t\twr32(hw, I40E_QINT_RQCTL(i), 0);\n\t\twr32(hw, I40E_QRX_ENA(i), 0);\n\t}\n\n\t \n\tudelay(50);\n}\n\n \nvoid i40e_clear_pxe_mode(struct i40e_hw *hw)\n{\n\tu32 reg;\n\n\tif (i40e_check_asq_alive(hw))\n\t\ti40e_aq_clear_pxe_mode(hw, NULL);\n\n\t \n\treg = rd32(hw, I40E_GLLAN_RCTL_0);\n\n\tif (hw->revision_id == 0) {\n\t\t \n\t\twr32(hw, I40E_GLLAN_RCTL_0, (reg & (~I40E_GLLAN_RCTL_0_PXE_MODE_MASK)));\n\t} else {\n\t\twr32(hw, I40E_GLLAN_RCTL_0, (reg | I40E_GLLAN_RCTL_0_PXE_MODE_MASK));\n\t}\n}\n\n \nstatic u32 i40e_led_is_mine(struct i40e_hw *hw, int idx)\n{\n\tu32 gpio_val = 0;\n\tu32 port;\n\n\tif (!I40E_IS_X710TL_DEVICE(hw->device_id) &&\n\t    !hw->func_caps.led[idx])\n\t\treturn 0;\n\tgpio_val = rd32(hw, I40E_GLGEN_GPIO_CTL(idx));\n\tport = (gpio_val & I40E_GLGEN_GPIO_CTL_PRT_NUM_MASK) >>\n\t\tI40E_GLGEN_GPIO_CTL_PRT_NUM_SHIFT;\n\n\t \n\tif ((gpio_val & I40E_GLGEN_GPIO_CTL_PRT_NUM_NA_MASK) ||\n\t    (port != hw->port))\n\t\treturn 0;\n\n\treturn gpio_val;\n}\n\n#define I40E_FW_LED BIT(4)\n#define I40E_LED_MODE_VALID (I40E_GLGEN_GPIO_CTL_LED_MODE_MASK >> \\\n\t\t\t     I40E_GLGEN_GPIO_CTL_LED_MODE_SHIFT)\n\n#define I40E_LED0 22\n\n#define I40E_PIN_FUNC_SDP 0x0\n#define I40E_PIN_FUNC_LED 0x1\n\n \nu32 i40e_led_get(struct i40e_hw *hw)\n{\n\tu32 mode = 0;\n\tint i;\n\n\t \n\tfor (i = I40E_LED0; i <= I40E_GLGEN_GPIO_CTL_MAX_INDEX; i++) {\n\t\tu32 gpio_val = i40e_led_is_mine(hw, i);\n\n\t\tif (!gpio_val)\n\t\t\tcontinue;\n\n\t\tmode = (gpio_val & I40E_GLGEN_GPIO_CTL_LED_MODE_MASK) >>\n\t\t\tI40E_GLGEN_GPIO_CTL_LED_MODE_SHIFT;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\n \nvoid i40e_led_set(struct i40e_hw *hw, u32 mode, bool blink)\n{\n\tint i;\n\n\tif (mode & ~I40E_LED_MODE_VALID) {\n\t\thw_dbg(hw, \"invalid mode passed in %X\\n\", mode);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = I40E_LED0; i <= I40E_GLGEN_GPIO_CTL_MAX_INDEX; i++) {\n\t\tu32 gpio_val = i40e_led_is_mine(hw, i);\n\n\t\tif (!gpio_val)\n\t\t\tcontinue;\n\n\t\tif (I40E_IS_X710TL_DEVICE(hw->device_id)) {\n\t\t\tu32 pin_func = 0;\n\n\t\t\tif (mode & I40E_FW_LED)\n\t\t\t\tpin_func = I40E_PIN_FUNC_SDP;\n\t\t\telse\n\t\t\t\tpin_func = I40E_PIN_FUNC_LED;\n\n\t\t\tgpio_val &= ~I40E_GLGEN_GPIO_CTL_PIN_FUNC_MASK;\n\t\t\tgpio_val |= ((pin_func <<\n\t\t\t\t     I40E_GLGEN_GPIO_CTL_PIN_FUNC_SHIFT) &\n\t\t\t\t     I40E_GLGEN_GPIO_CTL_PIN_FUNC_MASK);\n\t\t}\n\t\tgpio_val &= ~I40E_GLGEN_GPIO_CTL_LED_MODE_MASK;\n\t\t \n\t\tgpio_val |= ((mode << I40E_GLGEN_GPIO_CTL_LED_MODE_SHIFT) &\n\t\t\t     I40E_GLGEN_GPIO_CTL_LED_MODE_MASK);\n\n\t\tif (blink)\n\t\t\tgpio_val |= BIT(I40E_GLGEN_GPIO_CTL_LED_BLINK_SHIFT);\n\t\telse\n\t\t\tgpio_val &= ~BIT(I40E_GLGEN_GPIO_CTL_LED_BLINK_SHIFT);\n\n\t\twr32(hw, I40E_GLGEN_GPIO_CTL(i), gpio_val);\n\t\tbreak;\n\t}\n}\n\n \n\n \nint\ni40e_aq_get_phy_capabilities(struct i40e_hw *hw,\n\t\t\t     bool qualified_modules, bool report_init,\n\t\t\t     struct i40e_aq_get_phy_abilities_resp *abilities,\n\t\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tu16 abilities_size = sizeof(struct i40e_aq_get_phy_abilities_resp);\n\tu16 max_delay = I40E_MAX_PHY_TIMEOUT, total_delay = 0;\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\tif (!abilities)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t       i40e_aqc_opc_get_phy_abilities);\n\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\t\tif (abilities_size > I40E_AQ_LARGE_BUF)\n\t\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\t\tif (qualified_modules)\n\t\t\tdesc.params.external.param0 |=\n\t\t\tcpu_to_le32(I40E_AQ_PHY_REPORT_QUALIFIED_MODULES);\n\n\t\tif (report_init)\n\t\t\tdesc.params.external.param0 |=\n\t\t\tcpu_to_le32(I40E_AQ_PHY_REPORT_INITIAL_VALUES);\n\n\t\tstatus = i40e_asq_send_command(hw, &desc, abilities,\n\t\t\t\t\t       abilities_size, cmd_details);\n\n\t\tswitch (hw->aq.asq_last_status) {\n\t\tcase I40E_AQ_RC_EIO:\n\t\t\tstatus = -EIO;\n\t\t\tbreak;\n\t\tcase I40E_AQ_RC_EAGAIN:\n\t\t\tusleep_range(1000, 2000);\n\t\t\ttotal_delay++;\n\t\t\tstatus = -EIO;\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t} while ((hw->aq.asq_last_status == I40E_AQ_RC_EAGAIN) &&\n\t\t(total_delay < max_delay));\n\n\tif (status)\n\t\treturn status;\n\n\tif (report_init) {\n\t\tif (hw->mac.type ==  I40E_MAC_XL710 &&\n\t\t    hw->aq.api_maj_ver == I40E_FW_API_VERSION_MAJOR &&\n\t\t    hw->aq.api_min_ver >= I40E_MINOR_VER_GET_LINK_INFO_XL710) {\n\t\t\tstatus = i40e_aq_get_link_info(hw, true, NULL, NULL);\n\t\t} else {\n\t\t\thw->phy.phy_types = le32_to_cpu(abilities->phy_type);\n\t\t\thw->phy.phy_types |=\n\t\t\t\t\t((u64)abilities->phy_type_ext << 32);\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nint i40e_aq_set_phy_config(struct i40e_hw *hw,\n\t\t\t   struct i40e_aq_set_phy_config *config,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aq_set_phy_config *cmd =\n\t\t\t(struct i40e_aq_set_phy_config *)&desc.params.raw;\n\tint status;\n\n\tif (!config)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_phy_config);\n\n\t*cmd = *config;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\nstatic noinline_for_stack int\ni40e_set_fc_status(struct i40e_hw *hw,\n\t\t   struct i40e_aq_get_phy_abilities_resp *abilities,\n\t\t   bool atomic_restart)\n{\n\tstruct i40e_aq_set_phy_config config;\n\tenum i40e_fc_mode fc_mode = hw->fc.requested_mode;\n\tu8 pause_mask = 0x0;\n\n\tswitch (fc_mode) {\n\tcase I40E_FC_FULL:\n\t\tpause_mask |= I40E_AQ_PHY_FLAG_PAUSE_TX;\n\t\tpause_mask |= I40E_AQ_PHY_FLAG_PAUSE_RX;\n\t\tbreak;\n\tcase I40E_FC_RX_PAUSE:\n\t\tpause_mask |= I40E_AQ_PHY_FLAG_PAUSE_RX;\n\t\tbreak;\n\tcase I40E_FC_TX_PAUSE:\n\t\tpause_mask |= I40E_AQ_PHY_FLAG_PAUSE_TX;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmemset(&config, 0, sizeof(struct i40e_aq_set_phy_config));\n\t \n\tconfig.abilities = abilities->abilities & ~(I40E_AQ_PHY_FLAG_PAUSE_TX) &\n\t\t\t   ~(I40E_AQ_PHY_FLAG_PAUSE_RX);\n\t \n\tconfig.abilities |= pause_mask;\n\t \n\tif (config.abilities == abilities->abilities)\n\t\treturn 0;\n\n\t \n\tif (atomic_restart)\n\t\tconfig.abilities |= I40E_AQ_PHY_ENABLE_ATOMIC_LINK;\n\t \n\tconfig.phy_type = abilities->phy_type;\n\tconfig.phy_type_ext = abilities->phy_type_ext;\n\tconfig.link_speed = abilities->link_speed;\n\tconfig.eee_capability = abilities->eee_capability;\n\tconfig.eeer = abilities->eeer_val;\n\tconfig.low_power_ctrl = abilities->d3_lpan;\n\tconfig.fec_config = abilities->fec_cfg_curr_mod_ext_info &\n\t\t\t    I40E_AQ_PHY_FEC_CONFIG_MASK;\n\n\treturn i40e_aq_set_phy_config(hw, &config, NULL);\n}\n\n \nint i40e_set_fc(struct i40e_hw *hw, u8 *aq_failures,\n\t\tbool atomic_restart)\n{\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tint status;\n\n\t*aq_failures = 0x0;\n\n\t \n\tstatus = i40e_aq_get_phy_capabilities(hw, false, false, &abilities,\n\t\t\t\t\t      NULL);\n\tif (status) {\n\t\t*aq_failures |= I40E_SET_FC_AQ_FAIL_GET;\n\t\treturn status;\n\t}\n\n\tstatus = i40e_set_fc_status(hw, &abilities, atomic_restart);\n\tif (status)\n\t\t*aq_failures |= I40E_SET_FC_AQ_FAIL_SET;\n\n\t \n\tstatus = i40e_update_link_info(hw);\n\tif (status) {\n\t\t \n\t\tmsleep(1000);\n\t\tstatus = i40e_update_link_info(hw);\n\t}\n\tif (status)\n\t\t*aq_failures |= I40E_SET_FC_AQ_FAIL_UPDATE;\n\n\treturn status;\n}\n\n \nint i40e_aq_clear_pxe_mode(struct i40e_hw *hw,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_clear_pxe *cmd =\n\t\t(struct i40e_aqc_clear_pxe *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_clear_pxe_mode);\n\n\tcmd->rx_cnt = 0x2;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\twr32(hw, I40E_GLLAN_RCTL_0, 0x1);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_link_restart_an(struct i40e_hw *hw,\n\t\t\t\tbool enable_link,\n\t\t\t\tstruct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_link_restart_an *cmd =\n\t\t(struct i40e_aqc_set_link_restart_an *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_link_restart_an);\n\n\tcmd->command = I40E_AQ_PHY_RESTART_AN;\n\tif (enable_link)\n\t\tcmd->command |= I40E_AQ_PHY_LINK_ENABLE;\n\telse\n\t\tcmd->command &= ~I40E_AQ_PHY_LINK_ENABLE;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_link_info(struct i40e_hw *hw,\n\t\t\t  bool enable_lse, struct i40e_link_status *link,\n\t\t\t  struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_get_link_status *resp =\n\t\t(struct i40e_aqc_get_link_status *)&desc.params.raw;\n\tstruct i40e_link_status *hw_link_info = &hw->phy.link_info;\n\tbool tx_pause, rx_pause;\n\tu16 command_flags;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_get_link_status);\n\n\tif (enable_lse)\n\t\tcommand_flags = I40E_AQ_LSE_ENABLE;\n\telse\n\t\tcommand_flags = I40E_AQ_LSE_DISABLE;\n\tresp->command_flags = cpu_to_le16(command_flags);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (status)\n\t\tgoto aq_get_link_info_exit;\n\n\t \n\thw->phy.link_info_old = *hw_link_info;\n\n\t \n\thw_link_info->phy_type = (enum i40e_aq_phy_type)resp->phy_type;\n\thw->phy.media_type = i40e_get_media_type(hw);\n\thw_link_info->link_speed = (enum i40e_aq_link_speed)resp->link_speed;\n\thw_link_info->link_info = resp->link_info;\n\thw_link_info->an_info = resp->an_info;\n\thw_link_info->fec_info = resp->config & (I40E_AQ_CONFIG_FEC_KR_ENA |\n\t\t\t\t\t\t I40E_AQ_CONFIG_FEC_RS_ENA);\n\thw_link_info->ext_info = resp->ext_info;\n\thw_link_info->loopback = resp->loopback & I40E_AQ_LOOPBACK_MASK;\n\thw_link_info->max_frame_size = le16_to_cpu(resp->max_frame_size);\n\thw_link_info->pacing = resp->config & I40E_AQ_CONFIG_PACING_MASK;\n\n\t \n\ttx_pause = !!(resp->an_info & I40E_AQ_LINK_PAUSE_TX);\n\trx_pause = !!(resp->an_info & I40E_AQ_LINK_PAUSE_RX);\n\tif (tx_pause & rx_pause)\n\t\thw->fc.current_mode = I40E_FC_FULL;\n\telse if (tx_pause)\n\t\thw->fc.current_mode = I40E_FC_TX_PAUSE;\n\telse if (rx_pause)\n\t\thw->fc.current_mode = I40E_FC_RX_PAUSE;\n\telse\n\t\thw->fc.current_mode = I40E_FC_NONE;\n\n\tif (resp->config & I40E_AQ_CONFIG_CRC_ENA)\n\t\thw_link_info->crc_enable = true;\n\telse\n\t\thw_link_info->crc_enable = false;\n\n\tif (resp->command_flags & cpu_to_le16(I40E_AQ_LSE_IS_ENABLED))\n\t\thw_link_info->lse_enable = true;\n\telse\n\t\thw_link_info->lse_enable = false;\n\n\tif ((hw->mac.type == I40E_MAC_XL710) &&\n\t    (hw->aq.fw_maj_ver < 4 || (hw->aq.fw_maj_ver == 4 &&\n\t     hw->aq.fw_min_ver < 40)) && hw_link_info->phy_type == 0xE)\n\t\thw_link_info->phy_type = I40E_PHY_TYPE_10GBASE_SFPP_CU;\n\n\tif (hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE &&\n\t    hw->mac.type != I40E_MAC_X722) {\n\t\t__le32 tmp;\n\n\t\tmemcpy(&tmp, resp->link_type, sizeof(tmp));\n\t\thw->phy.phy_types = le32_to_cpu(tmp);\n\t\thw->phy.phy_types |= ((u64)resp->link_type_ext << 32);\n\t}\n\n\t \n\tif (link)\n\t\t*link = *hw_link_info;\n\n\t \n\thw->phy.get_link_info = false;\n\naq_get_link_info_exit:\n\treturn status;\n}\n\n \nint i40e_aq_set_phy_int_mask(struct i40e_hw *hw,\n\t\t\t     u16 mask,\n\t\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_phy_int_mask *cmd =\n\t\t(struct i40e_aqc_set_phy_int_mask *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_phy_int_mask);\n\n\tcmd->event_mask = cpu_to_le16(mask);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_mac_loopback(struct i40e_hw *hw, bool ena_lpbk,\n\t\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_lb_mode *cmd =\n\t\t(struct i40e_aqc_set_lb_mode *)&desc.params.raw;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_set_lb_modes);\n\tif (ena_lpbk) {\n\t\tif (hw->nvm.version <= I40E_LEGACY_LOOPBACK_NVM_VER)\n\t\t\tcmd->lb_mode = cpu_to_le16(I40E_AQ_LB_MAC_LOCAL_LEGACY);\n\t\telse\n\t\t\tcmd->lb_mode = cpu_to_le16(I40E_AQ_LB_MAC_LOCAL);\n\t}\n\n\treturn i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n}\n\n \nint i40e_aq_set_phy_debug(struct i40e_hw *hw, u8 cmd_flags,\n\t\t\t  struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_phy_debug *cmd =\n\t\t(struct i40e_aqc_set_phy_debug *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_phy_debug);\n\n\tcmd->command_flags = cmd_flags;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nstatic bool i40e_is_aq_api_ver_ge(struct i40e_adminq_info *aq, u16 maj,\n\t\t\t\t  u16 min)\n{\n\treturn (aq->api_maj_ver > maj ||\n\t\t(aq->api_maj_ver == maj && aq->api_min_ver >= min));\n}\n\n \nint i40e_aq_add_vsi(struct i40e_hw *hw,\n\t\t    struct i40e_vsi_context *vsi_ctx,\n\t\t    struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_get_update_vsi *cmd =\n\t\t(struct i40e_aqc_add_get_update_vsi *)&desc.params.raw;\n\tstruct i40e_aqc_add_get_update_vsi_completion *resp =\n\t\t(struct i40e_aqc_add_get_update_vsi_completion *)\n\t\t&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_add_vsi);\n\n\tcmd->uplink_seid = cpu_to_le16(vsi_ctx->uplink_seid);\n\tcmd->connection_type = vsi_ctx->connection_type;\n\tcmd->vf_id = vsi_ctx->vf_num;\n\tcmd->vsi_flags = cpu_to_le16(vsi_ctx->flags);\n\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\n\tstatus = i40e_asq_send_command_atomic(hw, &desc, &vsi_ctx->info,\n\t\t\t\t\t      sizeof(vsi_ctx->info),\n\t\t\t\t\t      cmd_details, true);\n\n\tif (status)\n\t\tgoto aq_add_vsi_exit;\n\n\tvsi_ctx->seid = le16_to_cpu(resp->seid);\n\tvsi_ctx->vsi_number = le16_to_cpu(resp->vsi_number);\n\tvsi_ctx->vsis_allocated = le16_to_cpu(resp->vsi_used);\n\tvsi_ctx->vsis_unallocated = le16_to_cpu(resp->vsi_free);\n\naq_add_vsi_exit:\n\treturn status;\n}\n\n \nint i40e_aq_set_default_vsi(struct i40e_hw *hw,\n\t\t\t    u16 seid,\n\t\t\t    struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)\n\t\t&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tcmd->promiscuous_flags = cpu_to_le16(I40E_AQC_SET_VSI_DEFAULT);\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_DEFAULT);\n\tcmd->seid = cpu_to_le16(seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_clear_default_vsi(struct i40e_hw *hw,\n\t\t\t      u16 seid,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)\n\t\t&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tcmd->promiscuous_flags = cpu_to_le16(0);\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_DEFAULT);\n\tcmd->seid = cpu_to_le16(seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_vsi_unicast_promiscuous(struct i40e_hw *hw,\n\t\t\t\t\tu16 seid, bool set,\n\t\t\t\t\tstruct i40e_asq_cmd_details *cmd_details,\n\t\t\t\t\tbool rx_only_promisc)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;\n\tu16 flags = 0;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\ti40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tif (set) {\n\t\tflags |= I40E_AQC_SET_VSI_PROMISC_UNICAST;\n\t\tif (rx_only_promisc && i40e_is_aq_api_ver_ge(&hw->aq, 1, 5))\n\t\t\tflags |= I40E_AQC_SET_VSI_PROMISC_RX_ONLY;\n\t}\n\n\tcmd->promiscuous_flags = cpu_to_le16(flags);\n\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_UNICAST);\n\tif (i40e_is_aq_api_ver_ge(&hw->aq, 1, 5))\n\t\tcmd->valid_flags |=\n\t\t\tcpu_to_le16(I40E_AQC_SET_VSI_PROMISC_RX_ONLY);\n\n\tcmd->seid = cpu_to_le16(seid);\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_vsi_multicast_promiscuous(struct i40e_hw *hw,\n\t\t\t\t\t  u16 seid, bool set,\n\t\t\t\t\t  struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;\n\tu16 flags = 0;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\ti40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tif (set)\n\t\tflags |= I40E_AQC_SET_VSI_PROMISC_MULTICAST;\n\n\tcmd->promiscuous_flags = cpu_to_le16(flags);\n\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_MULTICAST);\n\n\tcmd->seid = cpu_to_le16(seid);\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_vsi_mc_promisc_on_vlan(struct i40e_hw *hw,\n\t\t\t\t       u16 seid, bool enable,\n\t\t\t\t       u16 vid,\n\t\t\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;\n\tu16 flags = 0;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tif (enable)\n\t\tflags |= I40E_AQC_SET_VSI_PROMISC_MULTICAST;\n\n\tcmd->promiscuous_flags = cpu_to_le16(flags);\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_MULTICAST);\n\tcmd->seid = cpu_to_le16(seid);\n\tcmd->vlan_tag = cpu_to_le16(vid | I40E_AQC_SET_VSI_VLAN_VALID);\n\n\tstatus = i40e_asq_send_command_atomic(hw, &desc, NULL, 0,\n\t\t\t\t\t      cmd_details, true);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_vsi_uc_promisc_on_vlan(struct i40e_hw *hw,\n\t\t\t\t       u16 seid, bool enable,\n\t\t\t\t       u16 vid,\n\t\t\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;\n\tu16 flags = 0;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tif (enable) {\n\t\tflags |= I40E_AQC_SET_VSI_PROMISC_UNICAST;\n\t\tif (i40e_is_aq_api_ver_ge(&hw->aq, 1, 5))\n\t\t\tflags |= I40E_AQC_SET_VSI_PROMISC_RX_ONLY;\n\t}\n\n\tcmd->promiscuous_flags = cpu_to_le16(flags);\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_UNICAST);\n\tif (i40e_is_aq_api_ver_ge(&hw->aq, 1, 5))\n\t\tcmd->valid_flags |=\n\t\t\tcpu_to_le16(I40E_AQC_SET_VSI_PROMISC_RX_ONLY);\n\tcmd->seid = cpu_to_le16(seid);\n\tcmd->vlan_tag = cpu_to_le16(vid | I40E_AQC_SET_VSI_VLAN_VALID);\n\n\tstatus = i40e_asq_send_command_atomic(hw, &desc, NULL, 0,\n\t\t\t\t\t      cmd_details, true);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_vsi_bc_promisc_on_vlan(struct i40e_hw *hw,\n\t\t\t\t       u16 seid, bool enable, u16 vid,\n\t\t\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;\n\tu16 flags = 0;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\ti40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tif (enable)\n\t\tflags |= I40E_AQC_SET_VSI_PROMISC_BROADCAST;\n\n\tcmd->promiscuous_flags = cpu_to_le16(flags);\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_BROADCAST);\n\tcmd->seid = cpu_to_le16(seid);\n\tcmd->vlan_tag = cpu_to_le16(vid | I40E_AQC_SET_VSI_VLAN_VALID);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_vsi_broadcast(struct i40e_hw *hw,\n\t\t\t      u16 seid, bool set_filter,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\ti40e_aqc_opc_set_vsi_promiscuous_modes);\n\n\tif (set_filter)\n\t\tcmd->promiscuous_flags\n\t\t\t    |= cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_BROADCAST);\n\telse\n\t\tcmd->promiscuous_flags\n\t\t\t    &= cpu_to_le16(~I40E_AQC_SET_VSI_PROMISC_BROADCAST);\n\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_BROADCAST);\n\tcmd->seid = cpu_to_le16(seid);\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_vsi_vlan_promisc(struct i40e_hw *hw,\n\t\t\t\t u16 seid, bool enable,\n\t\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_vsi_promiscuous_modes *cmd =\n\t\t(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;\n\tu16 flags = 0;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\ti40e_aqc_opc_set_vsi_promiscuous_modes);\n\tif (enable)\n\t\tflags |= I40E_AQC_SET_VSI_PROMISC_VLAN;\n\n\tcmd->promiscuous_flags = cpu_to_le16(flags);\n\tcmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_VLAN);\n\tcmd->seid = cpu_to_le16(seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_vsi_params(struct i40e_hw *hw,\n\t\t\t   struct i40e_vsi_context *vsi_ctx,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_get_update_vsi *cmd =\n\t\t(struct i40e_aqc_add_get_update_vsi *)&desc.params.raw;\n\tstruct i40e_aqc_add_get_update_vsi_completion *resp =\n\t\t(struct i40e_aqc_add_get_update_vsi_completion *)\n\t\t&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_get_vsi_parameters);\n\n\tcmd->uplink_seid = cpu_to_le16(vsi_ctx->seid);\n\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\n\tstatus = i40e_asq_send_command(hw, &desc, &vsi_ctx->info,\n\t\t\t\t    sizeof(vsi_ctx->info), NULL);\n\n\tif (status)\n\t\tgoto aq_get_vsi_params_exit;\n\n\tvsi_ctx->seid = le16_to_cpu(resp->seid);\n\tvsi_ctx->vsi_number = le16_to_cpu(resp->vsi_number);\n\tvsi_ctx->vsis_allocated = le16_to_cpu(resp->vsi_used);\n\tvsi_ctx->vsis_unallocated = le16_to_cpu(resp->vsi_free);\n\naq_get_vsi_params_exit:\n\treturn status;\n}\n\n \nint i40e_aq_update_vsi_params(struct i40e_hw *hw,\n\t\t\t      struct i40e_vsi_context *vsi_ctx,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_get_update_vsi *cmd =\n\t\t(struct i40e_aqc_add_get_update_vsi *)&desc.params.raw;\n\tstruct i40e_aqc_add_get_update_vsi_completion *resp =\n\t\t(struct i40e_aqc_add_get_update_vsi_completion *)\n\t\t&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_update_vsi_parameters);\n\tcmd->uplink_seid = cpu_to_le16(vsi_ctx->seid);\n\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\n\tstatus = i40e_asq_send_command_atomic(hw, &desc, &vsi_ctx->info,\n\t\t\t\t\t      sizeof(vsi_ctx->info),\n\t\t\t\t\t      cmd_details, true);\n\n\tvsi_ctx->vsis_allocated = le16_to_cpu(resp->vsi_used);\n\tvsi_ctx->vsis_unallocated = le16_to_cpu(resp->vsi_free);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_switch_config(struct i40e_hw *hw,\n\t\t\t      struct i40e_aqc_get_switch_config_resp *buf,\n\t\t\t      u16 buf_size, u16 *start_seid,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_switch_seid *scfg =\n\t\t(struct i40e_aqc_switch_seid *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_get_switch_config);\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tif (buf_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\tscfg->seid = cpu_to_le16(*start_seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, buf, buf_size, cmd_details);\n\t*start_seid = le16_to_cpu(scfg->seid);\n\n\treturn status;\n}\n\n \nint i40e_aq_set_switch_config(struct i40e_hw *hw,\n\t\t\t      u16 flags,\n\t\t\t      u16 valid_flags, u8 mode,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_switch_config *scfg =\n\t\t(struct i40e_aqc_set_switch_config *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_switch_config);\n\tscfg->flags = cpu_to_le16(flags);\n\tscfg->valid_flags = cpu_to_le16(valid_flags);\n\tscfg->mode = mode;\n\tif (hw->flags & I40E_HW_FLAG_802_1AD_CAPABLE) {\n\t\tscfg->switch_tag = cpu_to_le16(hw->switch_tag);\n\t\tscfg->first_tag = cpu_to_le16(hw->first_tag);\n\t\tscfg->second_tag = cpu_to_le16(hw->second_tag);\n\t}\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_firmware_version(struct i40e_hw *hw,\n\t\t\t\t u16 *fw_major_version, u16 *fw_minor_version,\n\t\t\t\t u32 *fw_build,\n\t\t\t\t u16 *api_major_version, u16 *api_minor_version,\n\t\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_get_version *resp =\n\t\t(struct i40e_aqc_get_version *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_get_version);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (!status) {\n\t\tif (fw_major_version)\n\t\t\t*fw_major_version = le16_to_cpu(resp->fw_major);\n\t\tif (fw_minor_version)\n\t\t\t*fw_minor_version = le16_to_cpu(resp->fw_minor);\n\t\tif (fw_build)\n\t\t\t*fw_build = le32_to_cpu(resp->fw_build);\n\t\tif (api_major_version)\n\t\t\t*api_major_version = le16_to_cpu(resp->api_major);\n\t\tif (api_minor_version)\n\t\t\t*api_minor_version = le16_to_cpu(resp->api_minor);\n\t}\n\n\treturn status;\n}\n\n \nint i40e_aq_send_driver_version(struct i40e_hw *hw,\n\t\t\t\tstruct i40e_driver_version *dv,\n\t\t\t\tstruct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_driver_version *cmd =\n\t\t(struct i40e_aqc_driver_version *)&desc.params.raw;\n\tint status;\n\tu16 len;\n\n\tif (dv == NULL)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_driver_version);\n\n\tdesc.flags |= cpu_to_le16(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD);\n\tcmd->driver_major_ver = dv->major_version;\n\tcmd->driver_minor_ver = dv->minor_version;\n\tcmd->driver_build_ver = dv->build_version;\n\tcmd->driver_subbuild_ver = dv->subbuild_version;\n\n\tlen = 0;\n\twhile (len < sizeof(dv->driver_string) &&\n\t       (dv->driver_string[len] < 0x80) &&\n\t       dv->driver_string[len])\n\t\tlen++;\n\tstatus = i40e_asq_send_command(hw, &desc, dv->driver_string,\n\t\t\t\t       len, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_get_link_status(struct i40e_hw *hw, bool *link_up)\n{\n\tint status = 0;\n\n\tif (hw->phy.get_link_info) {\n\t\tstatus = i40e_update_link_info(hw);\n\n\t\tif (status)\n\t\t\ti40e_debug(hw, I40E_DEBUG_LINK, \"get link failed: status %d\\n\",\n\t\t\t\t   status);\n\t}\n\n\t*link_up = hw->phy.link_info.link_info & I40E_AQ_LINK_UP;\n\n\treturn status;\n}\n\n \nnoinline_for_stack int i40e_update_link_info(struct i40e_hw *hw)\n{\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tint status = 0;\n\n\tstatus = i40e_aq_get_link_info(hw, true, NULL, NULL);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif ((hw->phy.link_info.link_info & I40E_AQ_MEDIA_AVAILABLE) &&\n\t    ((hw->phy.link_info.link_info & I40E_AQ_LINK_UP) ||\n\t     !(hw->phy.link_info_old.link_info & I40E_AQ_LINK_UP))) {\n\t\tstatus = i40e_aq_get_phy_capabilities(hw, false, false,\n\t\t\t\t\t\t      &abilities, NULL);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (abilities.fec_cfg_curr_mod_ext_info &\n\t\t    I40E_AQ_ENABLE_FEC_AUTO)\n\t\t\thw->phy.link_info.req_fec_info =\n\t\t\t\t(I40E_AQ_REQUEST_FEC_KR |\n\t\t\t\t I40E_AQ_REQUEST_FEC_RS);\n\t\telse\n\t\t\thw->phy.link_info.req_fec_info =\n\t\t\t\tabilities.fec_cfg_curr_mod_ext_info &\n\t\t\t\t(I40E_AQ_REQUEST_FEC_KR |\n\t\t\t\t I40E_AQ_REQUEST_FEC_RS);\n\n\t\tmemcpy(hw->phy.link_info.module_type, &abilities.module_type,\n\t\t       sizeof(hw->phy.link_info.module_type));\n\t}\n\n\treturn status;\n}\n\n \nint i40e_aq_add_veb(struct i40e_hw *hw, u16 uplink_seid,\n\t\t    u16 downlink_seid, u8 enabled_tc,\n\t\t    bool default_port, u16 *veb_seid,\n\t\t    bool enable_stats,\n\t\t    struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_veb *cmd =\n\t\t(struct i40e_aqc_add_veb *)&desc.params.raw;\n\tstruct i40e_aqc_add_veb_completion *resp =\n\t\t(struct i40e_aqc_add_veb_completion *)&desc.params.raw;\n\tu16 veb_flags = 0;\n\tint status;\n\n\t \n\tif (!!uplink_seid != !!downlink_seid)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_add_veb);\n\n\tcmd->uplink_seid = cpu_to_le16(uplink_seid);\n\tcmd->downlink_seid = cpu_to_le16(downlink_seid);\n\tcmd->enable_tcs = enabled_tc;\n\tif (!uplink_seid)\n\t\tveb_flags |= I40E_AQC_ADD_VEB_FLOATING;\n\tif (default_port)\n\t\tveb_flags |= I40E_AQC_ADD_VEB_PORT_TYPE_DEFAULT;\n\telse\n\t\tveb_flags |= I40E_AQC_ADD_VEB_PORT_TYPE_DATA;\n\n\t \n\tif (!enable_stats)\n\t\tveb_flags |= I40E_AQC_ADD_VEB_ENABLE_DISABLE_STATS;\n\n\tcmd->veb_flags = cpu_to_le16(veb_flags);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (!status && veb_seid)\n\t\t*veb_seid = le16_to_cpu(resp->veb_seid);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_veb_parameters(struct i40e_hw *hw,\n\t\t\t       u16 veb_seid, u16 *switch_id,\n\t\t\t       bool *floating, u16 *statistic_index,\n\t\t\t       u16 *vebs_used, u16 *vebs_free,\n\t\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_get_veb_parameters_completion *cmd_resp =\n\t\t(struct i40e_aqc_get_veb_parameters_completion *)\n\t\t&desc.params.raw;\n\tint status;\n\n\tif (veb_seid == 0)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_get_veb_parameters);\n\tcmd_resp->seid = cpu_to_le16(veb_seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\tif (status)\n\t\tgoto get_veb_exit;\n\n\tif (switch_id)\n\t\t*switch_id = le16_to_cpu(cmd_resp->switch_id);\n\tif (statistic_index)\n\t\t*statistic_index = le16_to_cpu(cmd_resp->statistic_index);\n\tif (vebs_used)\n\t\t*vebs_used = le16_to_cpu(cmd_resp->vebs_used);\n\tif (vebs_free)\n\t\t*vebs_free = le16_to_cpu(cmd_resp->vebs_free);\n\tif (floating) {\n\t\tu16 flags = le16_to_cpu(cmd_resp->veb_flags);\n\n\t\tif (flags & I40E_AQC_ADD_VEB_FLOATING)\n\t\t\t*floating = true;\n\t\telse\n\t\t\t*floating = false;\n\t}\n\nget_veb_exit:\n\treturn status;\n}\n\n \nstatic u16\ni40e_prepare_add_macvlan(struct i40e_aqc_add_macvlan_element_data *mv_list,\n\t\t\t struct i40e_aq_desc *desc, u16 count, u16 seid)\n{\n\tstruct i40e_aqc_macvlan *cmd =\n\t\t(struct i40e_aqc_macvlan *)&desc->params.raw;\n\tu16 buf_size;\n\tint i;\n\n\tbuf_size = count * sizeof(*mv_list);\n\n\t \n\ti40e_fill_default_direct_cmd_desc(desc, i40e_aqc_opc_add_macvlan);\n\tcmd->num_addresses = cpu_to_le16(count);\n\tcmd->seid[0] = cpu_to_le16(I40E_AQC_MACVLAN_CMD_SEID_VALID | seid);\n\tcmd->seid[1] = 0;\n\tcmd->seid[2] = 0;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (is_multicast_ether_addr(mv_list[i].mac_addr))\n\t\t\tmv_list[i].flags |=\n\t\t\t       cpu_to_le16(I40E_AQC_MACVLAN_ADD_USE_SHARED_MAC);\n\n\tdesc->flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tif (buf_size > I40E_AQ_LARGE_BUF)\n\t\tdesc->flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\treturn buf_size;\n}\n\n \nint\ni40e_aq_add_macvlan(struct i40e_hw *hw, u16 seid,\n\t\t    struct i40e_aqc_add_macvlan_element_data *mv_list,\n\t\t    u16 count, struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tu16 buf_size;\n\n\tif (count == 0 || !mv_list || !hw)\n\t\treturn -EINVAL;\n\n\tbuf_size = i40e_prepare_add_macvlan(mv_list, &desc, count, seid);\n\n\treturn i40e_asq_send_command_atomic(hw, &desc, mv_list, buf_size,\n\t\t\t\t\t    cmd_details, true);\n}\n\n \nint\ni40e_aq_add_macvlan_v2(struct i40e_hw *hw, u16 seid,\n\t\t       struct i40e_aqc_add_macvlan_element_data *mv_list,\n\t\t       u16 count, struct i40e_asq_cmd_details *cmd_details,\n\t\t       enum i40e_admin_queue_err *aq_status)\n{\n\tstruct i40e_aq_desc desc;\n\tu16 buf_size;\n\n\tif (count == 0 || !mv_list || !hw)\n\t\treturn -EINVAL;\n\n\tbuf_size = i40e_prepare_add_macvlan(mv_list, &desc, count, seid);\n\n\treturn i40e_asq_send_command_atomic_v2(hw, &desc, mv_list, buf_size,\n\t\t\t\t\t       cmd_details, true, aq_status);\n}\n\n \nint\ni40e_aq_remove_macvlan(struct i40e_hw *hw, u16 seid,\n\t\t       struct i40e_aqc_remove_macvlan_element_data *mv_list,\n\t\t       u16 count, struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_macvlan *cmd =\n\t\t(struct i40e_aqc_macvlan *)&desc.params.raw;\n\tu16 buf_size;\n\tint status;\n\n\tif (count == 0 || !mv_list || !hw)\n\t\treturn -EINVAL;\n\n\tbuf_size = count * sizeof(*mv_list);\n\n\t \n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_remove_macvlan);\n\tcmd->num_addresses = cpu_to_le16(count);\n\tcmd->seid[0] = cpu_to_le16(I40E_AQC_MACVLAN_CMD_SEID_VALID | seid);\n\tcmd->seid[1] = 0;\n\tcmd->seid[2] = 0;\n\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tif (buf_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tstatus = i40e_asq_send_command_atomic(hw, &desc, mv_list, buf_size,\n\t\t\t\t\t      cmd_details, true);\n\n\treturn status;\n}\n\n \nint\ni40e_aq_remove_macvlan_v2(struct i40e_hw *hw, u16 seid,\n\t\t\t  struct i40e_aqc_remove_macvlan_element_data *mv_list,\n\t\t\t  u16 count, struct i40e_asq_cmd_details *cmd_details,\n\t\t\t  enum i40e_admin_queue_err *aq_status)\n{\n\tstruct i40e_aqc_macvlan *cmd;\n\tstruct i40e_aq_desc desc;\n\tu16 buf_size;\n\n\tif (count == 0 || !mv_list || !hw)\n\t\treturn -EINVAL;\n\n\tbuf_size = count * sizeof(*mv_list);\n\n\t \n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_remove_macvlan);\n\tcmd = (struct i40e_aqc_macvlan *)&desc.params.raw;\n\tcmd->num_addresses = cpu_to_le16(count);\n\tcmd->seid[0] = cpu_to_le16(I40E_AQC_MACVLAN_CMD_SEID_VALID | seid);\n\tcmd->seid[1] = 0;\n\tcmd->seid[2] = 0;\n\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tif (buf_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\treturn i40e_asq_send_command_atomic_v2(hw, &desc, mv_list, buf_size,\n\t\t\t\t\t\t cmd_details, true, aq_status);\n}\n\n \nstatic int i40e_mirrorrule_op(struct i40e_hw *hw,\n\t\t\t      u16 opcode, u16 sw_seid, u16 rule_type, u16 id,\n\t\t\t      u16 count, __le16 *mr_list,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details,\n\t\t\t      u16 *rule_id, u16 *rules_used, u16 *rules_free)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_delete_mirror_rule *cmd =\n\t\t(struct i40e_aqc_add_delete_mirror_rule *)&desc.params.raw;\n\tstruct i40e_aqc_add_delete_mirror_rule_completion *resp =\n\t(struct i40e_aqc_add_delete_mirror_rule_completion *)&desc.params.raw;\n\tu16 buf_size;\n\tint status;\n\n\tbuf_size = count * sizeof(*mr_list);\n\n\t \n\ti40e_fill_default_direct_cmd_desc(&desc, opcode);\n\tcmd->seid = cpu_to_le16(sw_seid);\n\tcmd->rule_type = cpu_to_le16(rule_type &\n\t\t\t\t     I40E_AQC_MIRROR_RULE_TYPE_MASK);\n\tcmd->num_entries = cpu_to_le16(count);\n\t \n\tcmd->destination = cpu_to_le16(id);\n\tif (mr_list) {\n\t\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF |\n\t\t\t\t\t\tI40E_AQ_FLAG_RD));\n\t\tif (buf_size > I40E_AQ_LARGE_BUF)\n\t\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\t}\n\n\tstatus = i40e_asq_send_command(hw, &desc, mr_list, buf_size,\n\t\t\t\t       cmd_details);\n\tif (!status ||\n\t    hw->aq.asq_last_status == I40E_AQ_RC_ENOSPC) {\n\t\tif (rule_id)\n\t\t\t*rule_id = le16_to_cpu(resp->rule_id);\n\t\tif (rules_used)\n\t\t\t*rules_used = le16_to_cpu(resp->mirror_rules_used);\n\t\tif (rules_free)\n\t\t\t*rules_free = le16_to_cpu(resp->mirror_rules_free);\n\t}\n\treturn status;\n}\n\n \nint i40e_aq_add_mirrorrule(struct i40e_hw *hw, u16 sw_seid,\n\t\t\t   u16 rule_type, u16 dest_vsi, u16 count,\n\t\t\t   __le16 *mr_list,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details,\n\t\t\t   u16 *rule_id, u16 *rules_used, u16 *rules_free)\n{\n\tif (!(rule_type == I40E_AQC_MIRROR_RULE_TYPE_ALL_INGRESS ||\n\t    rule_type == I40E_AQC_MIRROR_RULE_TYPE_ALL_EGRESS)) {\n\t\tif (count == 0 || !mr_list)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn i40e_mirrorrule_op(hw, i40e_aqc_opc_add_mirror_rule, sw_seid,\n\t\t\t\t  rule_type, dest_vsi, count, mr_list,\n\t\t\t\t  cmd_details, rule_id, rules_used, rules_free);\n}\n\n \nint i40e_aq_delete_mirrorrule(struct i40e_hw *hw, u16 sw_seid,\n\t\t\t      u16 rule_type, u16 rule_id, u16 count,\n\t\t\t      __le16 *mr_list,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details,\n\t\t\t      u16 *rules_used, u16 *rules_free)\n{\n\t \n\tif (rule_type == I40E_AQC_MIRROR_RULE_TYPE_VLAN) {\n\t\t \n\t\tif (count == 0 || !mr_list)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn i40e_mirrorrule_op(hw, i40e_aqc_opc_delete_mirror_rule, sw_seid,\n\t\t\t\t  rule_type, rule_id, count, mr_list,\n\t\t\t\t  cmd_details, NULL, rules_used, rules_free);\n}\n\n \nint i40e_aq_send_msg_to_vf(struct i40e_hw *hw, u16 vfid,\n\t\t\t   u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_pf_vf_message *cmd =\n\t\t(struct i40e_aqc_pf_vf_message *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_send_msg_to_vf);\n\tcmd->id = cpu_to_le32(vfid);\n\tdesc.cookie_high = cpu_to_le32(v_opcode);\n\tdesc.cookie_low = cpu_to_le32(v_retval);\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_SI);\n\tif (msglen) {\n\t\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF |\n\t\t\t\t\t\tI40E_AQ_FLAG_RD));\n\t\tif (msglen > I40E_AQ_LARGE_BUF)\n\t\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\t\tdesc.datalen = cpu_to_le16(msglen);\n\t}\n\tstatus = i40e_asq_send_command(hw, &desc, msg, msglen, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_debug_read_register(struct i40e_hw *hw,\n\t\t\t\tu32 reg_addr, u64 *reg_val,\n\t\t\t\tstruct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_debug_reg_read_write *cmd_resp =\n\t\t(struct i40e_aqc_debug_reg_read_write *)&desc.params.raw;\n\tint status;\n\n\tif (reg_val == NULL)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_debug_read_reg);\n\n\tcmd_resp->address = cpu_to_le32(reg_addr);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (!status) {\n\t\t*reg_val = ((u64)le32_to_cpu(cmd_resp->value_high) << 32) |\n\t\t\t   (u64)le32_to_cpu(cmd_resp->value_low);\n\t}\n\n\treturn status;\n}\n\n \nint i40e_aq_debug_write_register(struct i40e_hw *hw,\n\t\t\t\t u32 reg_addr, u64 reg_val,\n\t\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_debug_reg_read_write *cmd =\n\t\t(struct i40e_aqc_debug_reg_read_write *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_debug_write_reg);\n\n\tcmd->address = cpu_to_le32(reg_addr);\n\tcmd->value_high = cpu_to_le32((u32)(reg_val >> 32));\n\tcmd->value_low = cpu_to_le32((u32)(reg_val & 0xFFFFFFFF));\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_request_resource(struct i40e_hw *hw,\n\t\t\t     enum i40e_aq_resources_ids resource,\n\t\t\t     enum i40e_aq_resource_access_type access,\n\t\t\t     u8 sdp_number, u64 *timeout,\n\t\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_request_resource *cmd_resp =\n\t\t(struct i40e_aqc_request_resource *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_request_resource);\n\n\tcmd_resp->resource_id = cpu_to_le16(resource);\n\tcmd_resp->access_type = cpu_to_le16(access);\n\tcmd_resp->resource_number = cpu_to_le32(sdp_number);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\t \n\tif (!status || hw->aq.asq_last_status == I40E_AQ_RC_EBUSY)\n\t\t*timeout = le32_to_cpu(cmd_resp->timeout);\n\n\treturn status;\n}\n\n \nint i40e_aq_release_resource(struct i40e_hw *hw,\n\t\t\t     enum i40e_aq_resources_ids resource,\n\t\t\t     u8 sdp_number,\n\t\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_request_resource *cmd =\n\t\t(struct i40e_aqc_request_resource *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_release_resource);\n\n\tcmd->resource_id = cpu_to_le16(resource);\n\tcmd->resource_number = cpu_to_le32(sdp_number);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_read_nvm(struct i40e_hw *hw, u8 module_pointer,\n\t\t     u32 offset, u16 length, void *data,\n\t\t     bool last_command,\n\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_nvm_update *cmd =\n\t\t(struct i40e_aqc_nvm_update *)&desc.params.raw;\n\tint status;\n\n\t \n\tif (offset & 0xFF000000) {\n\t\tstatus = -EINVAL;\n\t\tgoto i40e_aq_read_nvm_exit;\n\t}\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_nvm_read);\n\n\t \n\tif (last_command)\n\t\tcmd->command_flags |= I40E_AQ_NVM_LAST_CMD;\n\tcmd->module_pointer = module_pointer;\n\tcmd->offset = cpu_to_le32(offset);\n\tcmd->length = cpu_to_le16(length);\n\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tif (length > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tstatus = i40e_asq_send_command(hw, &desc, data, length, cmd_details);\n\ni40e_aq_read_nvm_exit:\n\treturn status;\n}\n\n \nint i40e_aq_erase_nvm(struct i40e_hw *hw, u8 module_pointer,\n\t\t      u32 offset, u16 length, bool last_command,\n\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_nvm_update *cmd =\n\t\t(struct i40e_aqc_nvm_update *)&desc.params.raw;\n\tint status;\n\n\t \n\tif (offset & 0xFF000000) {\n\t\tstatus = -EINVAL;\n\t\tgoto i40e_aq_erase_nvm_exit;\n\t}\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_nvm_erase);\n\n\t \n\tif (last_command)\n\t\tcmd->command_flags |= I40E_AQ_NVM_LAST_CMD;\n\tcmd->module_pointer = module_pointer;\n\tcmd->offset = cpu_to_le32(offset);\n\tcmd->length = cpu_to_le16(length);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\ni40e_aq_erase_nvm_exit:\n\treturn status;\n}\n\n \nstatic void i40e_parse_discover_capabilities(struct i40e_hw *hw, void *buff,\n\t\t\t\t     u32 cap_count,\n\t\t\t\t     enum i40e_admin_queue_opc list_type_opc)\n{\n\tstruct i40e_aqc_list_capabilities_element_resp *cap;\n\tu32 valid_functions, num_functions;\n\tu32 number, logical_id, phys_id;\n\tstruct i40e_hw_capabilities *p;\n\tu16 id, ocp_cfg_word0;\n\tu8 major_rev;\n\tint status;\n\tu32 i = 0;\n\n\tcap = (struct i40e_aqc_list_capabilities_element_resp *) buff;\n\n\tif (list_type_opc == i40e_aqc_opc_list_dev_capabilities)\n\t\tp = &hw->dev_caps;\n\telse if (list_type_opc == i40e_aqc_opc_list_func_capabilities)\n\t\tp = &hw->func_caps;\n\telse\n\t\treturn;\n\n\tfor (i = 0; i < cap_count; i++, cap++) {\n\t\tid = le16_to_cpu(cap->id);\n\t\tnumber = le32_to_cpu(cap->number);\n\t\tlogical_id = le32_to_cpu(cap->logical_id);\n\t\tphys_id = le32_to_cpu(cap->phys_id);\n\t\tmajor_rev = cap->major_rev;\n\n\t\tswitch (id) {\n\t\tcase I40E_AQ_CAP_ID_SWITCH_MODE:\n\t\t\tp->switch_mode = number;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_MNG_MODE:\n\t\t\tp->management_mode = number;\n\t\t\tif (major_rev > 1) {\n\t\t\t\tp->mng_protocols_over_mctp = logical_id;\n\t\t\t\ti40e_debug(hw, I40E_DEBUG_INIT,\n\t\t\t\t\t   \"HW Capability: Protocols over MCTP = %d\\n\",\n\t\t\t\t\t   p->mng_protocols_over_mctp);\n\t\t\t} else {\n\t\t\t\tp->mng_protocols_over_mctp = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_NPAR_ACTIVE:\n\t\t\tp->npar_enable = number;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_OS2BMC_CAP:\n\t\t\tp->os2bmc = number;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_FUNCTIONS_VALID:\n\t\t\tp->valid_functions = number;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_SRIOV:\n\t\t\tif (number == 1)\n\t\t\t\tp->sr_iov_1_1 = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_VF:\n\t\t\tp->num_vfs = number;\n\t\t\tp->vf_base_id = logical_id;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_VMDQ:\n\t\t\tif (number == 1)\n\t\t\t\tp->vmdq = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_8021QBG:\n\t\t\tif (number == 1)\n\t\t\t\tp->evb_802_1_qbg = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_8021QBR:\n\t\t\tif (number == 1)\n\t\t\t\tp->evb_802_1_qbh = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_VSI:\n\t\t\tp->num_vsis = number;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_DCB:\n\t\t\tif (number == 1) {\n\t\t\t\tp->dcb = true;\n\t\t\t\tp->enabled_tcmap = logical_id;\n\t\t\t\tp->maxtc = phys_id;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_FCOE:\n\t\t\tif (number == 1)\n\t\t\t\tp->fcoe = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_ISCSI:\n\t\t\tif (number == 1)\n\t\t\t\tp->iscsi = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_RSS:\n\t\t\tp->rss = true;\n\t\t\tp->rss_table_size = number;\n\t\t\tp->rss_table_entry_width = logical_id;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_RXQ:\n\t\t\tp->num_rx_qp = number;\n\t\t\tp->base_queue = phys_id;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_TXQ:\n\t\t\tp->num_tx_qp = number;\n\t\t\tp->base_queue = phys_id;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_MSIX:\n\t\t\tp->num_msix_vectors = number;\n\t\t\ti40e_debug(hw, I40E_DEBUG_INIT,\n\t\t\t\t   \"HW Capability: MSIX vector count = %d\\n\",\n\t\t\t\t   p->num_msix_vectors);\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_VF_MSIX:\n\t\t\tp->num_msix_vectors_vf = number;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_FLEX10:\n\t\t\tif (major_rev == 1) {\n\t\t\t\tif (number == 1) {\n\t\t\t\t\tp->flex10_enable = true;\n\t\t\t\t\tp->flex10_capable = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (number & 1)\n\t\t\t\t\tp->flex10_enable = true;\n\t\t\t\tif (number & 2)\n\t\t\t\t\tp->flex10_capable = true;\n\t\t\t}\n\t\t\tp->flex10_mode = logical_id;\n\t\t\tp->flex10_status = phys_id;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_CEM:\n\t\t\tif (number == 1)\n\t\t\t\tp->mgmt_cem = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_IWARP:\n\t\t\tif (number == 1)\n\t\t\t\tp->iwarp = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_LED:\n\t\t\tif (phys_id < I40E_HW_CAP_MAX_GPIO)\n\t\t\t\tp->led[phys_id] = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_SDP:\n\t\t\tif (phys_id < I40E_HW_CAP_MAX_GPIO)\n\t\t\t\tp->sdp[phys_id] = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_MDIO:\n\t\t\tif (number == 1) {\n\t\t\t\tp->mdio_port_num = phys_id;\n\t\t\t\tp->mdio_port_mode = logical_id;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_1588:\n\t\t\tif (number == 1)\n\t\t\t\tp->ieee_1588 = true;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_FLOW_DIRECTOR:\n\t\t\tp->fd = true;\n\t\t\tp->fd_filters_guaranteed = number;\n\t\t\tp->fd_filters_best_effort = logical_id;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_WSR_PROT:\n\t\t\tp->wr_csr_prot = (u64)number;\n\t\t\tp->wr_csr_prot |= (u64)logical_id << 32;\n\t\t\tbreak;\n\t\tcase I40E_AQ_CAP_ID_NVM_MGMT:\n\t\t\tif (number & I40E_NVM_MGMT_SEC_REV_DISABLED)\n\t\t\t\tp->sec_rev_disabled = true;\n\t\t\tif (number & I40E_NVM_MGMT_UPDATE_DISABLED)\n\t\t\t\tp->update_disabled = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p->fcoe)\n\t\ti40e_debug(hw, I40E_DEBUG_ALL, \"device is FCoE capable\\n\");\n\n\t \n\tif (p->npar_enable || p->flex10_enable)\n\t\tp->fcoe = false;\n\n\t \n\thw->num_ports = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 port_cfg_reg = I40E_PRTGEN_CNF + (4 * i);\n\t\tu64 port_cfg = 0;\n\n\t\t \n\t\ti40e_aq_debug_read_register(hw, port_cfg_reg, &port_cfg, NULL);\n\t\tif (!(port_cfg & I40E_PRTGEN_CNF_PORT_DIS_MASK))\n\t\t\thw->num_ports++;\n\t}\n\n\t \n\tif (hw->mac.type == I40E_MAC_X722) {\n\t\tif (!i40e_acquire_nvm(hw, I40E_RESOURCE_READ)) {\n\t\t\tstatus = i40e_aq_read_nvm(hw, I40E_SR_EMP_MODULE_PTR,\n\t\t\t\t\t\t  2 * I40E_SR_OCP_CFG_WORD0,\n\t\t\t\t\t\t  sizeof(ocp_cfg_word0),\n\t\t\t\t\t\t  &ocp_cfg_word0, true, NULL);\n\t\t\tif (!status &&\n\t\t\t    (ocp_cfg_word0 & I40E_SR_OCP_ENABLED))\n\t\t\t\thw->num_ports = 4;\n\t\t\ti40e_release_nvm(hw);\n\t\t}\n\t}\n\n\tvalid_functions = p->valid_functions;\n\tnum_functions = 0;\n\twhile (valid_functions) {\n\t\tif (valid_functions & 1)\n\t\t\tnum_functions++;\n\t\tvalid_functions >>= 1;\n\t}\n\n\t \n\tif (hw->num_ports != 0) {\n\t\thw->partition_id = (hw->pf_id / hw->num_ports) + 1;\n\t\thw->num_partitions = num_functions / hw->num_ports;\n\t}\n\n\t \n\tp->rx_buf_chain_len = I40E_MAX_CHAINED_RX_BUFFERS;\n}\n\n \nint i40e_aq_discover_capabilities(struct i40e_hw *hw,\n\t\t\t\t  void *buff, u16 buff_size, u16 *data_size,\n\t\t\t\t  enum i40e_admin_queue_opc list_type_opc,\n\t\t\t\t  struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aqc_list_capabilites *cmd;\n\tstruct i40e_aq_desc desc;\n\tint status = 0;\n\n\tcmd = (struct i40e_aqc_list_capabilites *)&desc.params.raw;\n\n\tif (list_type_opc != i40e_aqc_opc_list_func_capabilities &&\n\t\tlist_type_opc != i40e_aqc_opc_list_dev_capabilities) {\n\t\tstatus = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\ti40e_fill_default_direct_cmd_desc(&desc, list_type_opc);\n\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tif (buff_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tstatus = i40e_asq_send_command(hw, &desc, buff, buff_size, cmd_details);\n\t*data_size = le16_to_cpu(desc.datalen);\n\n\tif (status)\n\t\tgoto exit;\n\n\ti40e_parse_discover_capabilities(hw, buff, le32_to_cpu(cmd->count),\n\t\t\t\t\t list_type_opc);\n\nexit:\n\treturn status;\n}\n\n \nint i40e_aq_update_nvm(struct i40e_hw *hw, u8 module_pointer,\n\t\t       u32 offset, u16 length, void *data,\n\t\t       bool last_command, u8 preservation_flags,\n\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_nvm_update *cmd =\n\t\t(struct i40e_aqc_nvm_update *)&desc.params.raw;\n\tint status;\n\n\t \n\tif (offset & 0xFF000000) {\n\t\tstatus = -EINVAL;\n\t\tgoto i40e_aq_update_nvm_exit;\n\t}\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_nvm_update);\n\n\t \n\tif (last_command)\n\t\tcmd->command_flags |= I40E_AQ_NVM_LAST_CMD;\n\tif (hw->mac.type == I40E_MAC_X722) {\n\t\tif (preservation_flags == I40E_NVM_PRESERVATION_FLAGS_SELECTED)\n\t\t\tcmd->command_flags |=\n\t\t\t\t(I40E_AQ_NVM_PRESERVATION_FLAGS_SELECTED <<\n\t\t\t\t I40E_AQ_NVM_PRESERVATION_FLAGS_SHIFT);\n\t\telse if (preservation_flags == I40E_NVM_PRESERVATION_FLAGS_ALL)\n\t\t\tcmd->command_flags |=\n\t\t\t\t(I40E_AQ_NVM_PRESERVATION_FLAGS_ALL <<\n\t\t\t\t I40E_AQ_NVM_PRESERVATION_FLAGS_SHIFT);\n\t}\n\tcmd->module_pointer = module_pointer;\n\tcmd->offset = cpu_to_le32(offset);\n\tcmd->length = cpu_to_le16(length);\n\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tif (length > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tstatus = i40e_asq_send_command(hw, &desc, data, length, cmd_details);\n\ni40e_aq_update_nvm_exit:\n\treturn status;\n}\n\n \nint i40e_aq_rearrange_nvm(struct i40e_hw *hw,\n\t\t\t  u8 rearrange_nvm,\n\t\t\t  struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aqc_nvm_update *cmd;\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\tcmd = (struct i40e_aqc_nvm_update *)&desc.params.raw;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_nvm_update);\n\n\trearrange_nvm &= (I40E_AQ_NVM_REARRANGE_TO_FLAT |\n\t\t\t I40E_AQ_NVM_REARRANGE_TO_STRUCT);\n\n\tif (!rearrange_nvm) {\n\t\tstatus = -EINVAL;\n\t\tgoto i40e_aq_rearrange_nvm_exit;\n\t}\n\n\tcmd->command_flags |= rearrange_nvm;\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\ni40e_aq_rearrange_nvm_exit:\n\treturn status;\n}\n\n \nint i40e_aq_get_lldp_mib(struct i40e_hw *hw, u8 bridge_type,\n\t\t\t u8 mib_type, void *buff, u16 buff_size,\n\t\t\t u16 *local_len, u16 *remote_len,\n\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_lldp_get_mib *cmd =\n\t\t(struct i40e_aqc_lldp_get_mib *)&desc.params.raw;\n\tstruct i40e_aqc_lldp_get_mib *resp =\n\t\t(struct i40e_aqc_lldp_get_mib *)&desc.params.raw;\n\tint status;\n\n\tif (buff_size == 0 || !buff)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_lldp_get_mib);\n\t \n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\n\tcmd->type = mib_type & I40E_AQ_LLDP_MIB_TYPE_MASK;\n\tcmd->type |= ((bridge_type << I40E_AQ_LLDP_BRIDGE_TYPE_SHIFT) &\n\t\t       I40E_AQ_LLDP_BRIDGE_TYPE_MASK);\n\n\tdesc.datalen = cpu_to_le16(buff_size);\n\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tif (buff_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tstatus = i40e_asq_send_command(hw, &desc, buff, buff_size, cmd_details);\n\tif (!status) {\n\t\tif (local_len != NULL)\n\t\t\t*local_len = le16_to_cpu(resp->local_len);\n\t\tif (remote_len != NULL)\n\t\t\t*remote_len = le16_to_cpu(resp->remote_len);\n\t}\n\n\treturn status;\n}\n\n \nint\ni40e_aq_set_lldp_mib(struct i40e_hw *hw,\n\t\t     u8 mib_type, void *buff, u16 buff_size,\n\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aqc_lldp_set_local_mib *cmd;\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\tcmd = (struct i40e_aqc_lldp_set_local_mib *)&desc.params.raw;\n\tif (buff_size == 0 || !buff)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_lldp_set_local_mib);\n\t \n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tif (buff_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\tdesc.datalen = cpu_to_le16(buff_size);\n\n\tcmd->type = mib_type;\n\tcmd->length = cpu_to_le16(buff_size);\n\tcmd->address_high = cpu_to_le32(upper_32_bits((uintptr_t)buff));\n\tcmd->address_low = cpu_to_le32(lower_32_bits((uintptr_t)buff));\n\n\tstatus = i40e_asq_send_command(hw, &desc, buff, buff_size, cmd_details);\n\treturn status;\n}\n\n \nint i40e_aq_cfg_lldp_mib_change_event(struct i40e_hw *hw,\n\t\t\t\t      bool enable_update,\n\t\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_lldp_update_mib *cmd =\n\t\t(struct i40e_aqc_lldp_update_mib *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_lldp_update_mib);\n\n\tif (!enable_update)\n\t\tcmd->command |= I40E_AQ_LLDP_MIB_UPDATE_DISABLE;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint\ni40e_aq_restore_lldp(struct i40e_hw *hw, u8 *setting, bool restore,\n\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_lldp_restore *cmd =\n\t\t(struct i40e_aqc_lldp_restore *)&desc.params.raw;\n\tint status;\n\n\tif (!(hw->flags & I40E_HW_FLAG_FW_LLDP_PERSISTENT)) {\n\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t   \"Restore LLDP not supported by current FW version.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_lldp_restore);\n\n\tif (restore)\n\t\tcmd->command |= I40E_AQ_LLDP_AGENT_RESTORE;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (setting)\n\t\t*setting = cmd->command & 1;\n\n\treturn status;\n}\n\n \nint i40e_aq_stop_lldp(struct i40e_hw *hw, bool shutdown_agent,\n\t\t      bool persist,\n\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_lldp_stop *cmd =\n\t\t(struct i40e_aqc_lldp_stop *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_lldp_stop);\n\n\tif (shutdown_agent)\n\t\tcmd->command |= I40E_AQ_LLDP_AGENT_SHUTDOWN;\n\n\tif (persist) {\n\t\tif (hw->flags & I40E_HW_FLAG_FW_LLDP_PERSISTENT)\n\t\t\tcmd->command |= I40E_AQ_LLDP_AGENT_STOP_PERSIST;\n\t\telse\n\t\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t\t   \"Persistent Stop LLDP not supported by current FW version.\\n\");\n\t}\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_start_lldp(struct i40e_hw *hw, bool persist,\n\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_lldp_start *cmd =\n\t\t(struct i40e_aqc_lldp_start *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_lldp_start);\n\n\tcmd->command = I40E_AQ_LLDP_AGENT_START;\n\n\tif (persist) {\n\t\tif (hw->flags & I40E_HW_FLAG_FW_LLDP_PERSISTENT)\n\t\t\tcmd->command |= I40E_AQ_LLDP_AGENT_START_PERSIST;\n\t\telse\n\t\t\ti40e_debug(hw, I40E_DEBUG_ALL,\n\t\t\t\t   \"Persistent Start LLDP not supported by current FW version.\\n\");\n\t}\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint\ni40e_aq_set_dcb_parameters(struct i40e_hw *hw, bool dcb_enable,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_set_dcb_parameters *cmd =\n\t\t(struct i40e_aqc_set_dcb_parameters *)&desc.params.raw;\n\tint status;\n\n\tif (!(hw->flags & I40E_HW_FLAG_FW_LLDP_STOPPABLE))\n\t\treturn -ENODEV;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_dcb_parameters);\n\n\tif (dcb_enable) {\n\t\tcmd->valid_flags = I40E_DCB_VALID;\n\t\tcmd->command = I40E_AQ_DCB_SET_AGENT;\n\t}\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_cee_dcb_config(struct i40e_hw *hw,\n\t\t\t       void *buff, u16 buff_size,\n\t\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\tif (buff_size == 0 || !buff)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_get_cee_dcb_cfg);\n\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tstatus = i40e_asq_send_command(hw, &desc, (void *)buff, buff_size,\n\t\t\t\t       cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_add_udp_tunnel(struct i40e_hw *hw,\n\t\t\t   u16 udp_port, u8 protocol_index,\n\t\t\t   u8 *filter_index,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_udp_tunnel *cmd =\n\t\t(struct i40e_aqc_add_udp_tunnel *)&desc.params.raw;\n\tstruct i40e_aqc_del_udp_tunnel_completion *resp =\n\t\t(struct i40e_aqc_del_udp_tunnel_completion *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_add_udp_tunnel);\n\n\tcmd->udp_port = cpu_to_le16(udp_port);\n\tcmd->protocol_type = protocol_index;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (!status && filter_index)\n\t\t*filter_index = resp->index;\n\n\treturn status;\n}\n\n \nint i40e_aq_del_udp_tunnel(struct i40e_hw *hw, u8 index,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_remove_udp_tunnel *cmd =\n\t\t(struct i40e_aqc_remove_udp_tunnel *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_del_udp_tunnel);\n\n\tcmd->index = index;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_delete_element(struct i40e_hw *hw, u16 seid,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_switch_seid *cmd =\n\t\t(struct i40e_aqc_switch_seid *)&desc.params.raw;\n\tint status;\n\n\tif (seid == 0)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_delete_element);\n\n\tcmd->seid = cpu_to_le16(seid);\n\n\tstatus = i40e_asq_send_command_atomic(hw, &desc, NULL, 0,\n\t\t\t\t\t      cmd_details, true);\n\n\treturn status;\n}\n\n \nint i40e_aq_dcb_updated(struct i40e_hw *hw,\n\t\t\tstruct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_dcb_updated);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nstatic int i40e_aq_tx_sched_cmd(struct i40e_hw *hw, u16 seid,\n\t\t\t\tvoid *buff, u16 buff_size,\n\t\t\t\tenum i40e_admin_queue_opc opcode,\n\t\t\t\tstruct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_tx_sched_ind *cmd =\n\t\t(struct i40e_aqc_tx_sched_ind *)&desc.params.raw;\n\tint status;\n\tbool cmd_param_flag = false;\n\n\tswitch (opcode) {\n\tcase i40e_aqc_opc_configure_vsi_ets_sla_bw_limit:\n\tcase i40e_aqc_opc_configure_vsi_tc_bw:\n\tcase i40e_aqc_opc_enable_switching_comp_ets:\n\tcase i40e_aqc_opc_modify_switching_comp_ets:\n\tcase i40e_aqc_opc_disable_switching_comp_ets:\n\tcase i40e_aqc_opc_configure_switching_comp_ets_bw_limit:\n\tcase i40e_aqc_opc_configure_switching_comp_bw_config:\n\t\tcmd_param_flag = true;\n\t\tbreak;\n\tcase i40e_aqc_opc_query_vsi_bw_config:\n\tcase i40e_aqc_opc_query_vsi_ets_sla_config:\n\tcase i40e_aqc_opc_query_switching_comp_ets_config:\n\tcase i40e_aqc_opc_query_port_ets_config:\n\tcase i40e_aqc_opc_query_switching_comp_bw_config:\n\t\tcmd_param_flag = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ti40e_fill_default_direct_cmd_desc(&desc, opcode);\n\n\t \n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tif (cmd_param_flag)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_RD);\n\tif (buff_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tdesc.datalen = cpu_to_le16(buff_size);\n\n\tcmd->vsi_seid = cpu_to_le16(seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, buff, buff_size, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_config_vsi_bw_limit(struct i40e_hw *hw,\n\t\t\t\tu16 seid, u16 credit, u8 max_credit,\n\t\t\t\tstruct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_configure_vsi_bw_limit *cmd =\n\t\t(struct i40e_aqc_configure_vsi_bw_limit *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_configure_vsi_bw_limit);\n\n\tcmd->vsi_seid = cpu_to_le16(seid);\n\tcmd->credit = cpu_to_le16(credit);\n\tcmd->max_credit = max_credit;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_config_vsi_tc_bw(struct i40e_hw *hw,\n\t\t\t     u16 seid,\n\t\t\t     struct i40e_aqc_configure_vsi_tc_bw_data *bw_data,\n\t\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)bw_data, sizeof(*bw_data),\n\t\t\t\t    i40e_aqc_opc_configure_vsi_tc_bw,\n\t\t\t\t    cmd_details);\n}\n\n \nint\ni40e_aq_config_switch_comp_ets(struct i40e_hw *hw,\n\t\t\t       u16 seid,\n\t\t\t       struct i40e_aqc_configure_switching_comp_ets_data *ets_data,\n\t\t\t       enum i40e_admin_queue_opc opcode,\n\t\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)ets_data,\n\t\t\t\t    sizeof(*ets_data), opcode, cmd_details);\n}\n\n \nint\ni40e_aq_config_switch_comp_bw_config(struct i40e_hw *hw,\n\tu16 seid,\n\tstruct i40e_aqc_configure_switching_comp_bw_config_data *bw_data,\n\tstruct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)bw_data, sizeof(*bw_data),\n\t\t\t    i40e_aqc_opc_configure_switching_comp_bw_config,\n\t\t\t    cmd_details);\n}\n\n \nint\ni40e_aq_query_vsi_bw_config(struct i40e_hw *hw,\n\t\t\t    u16 seid,\n\t\t\t    struct i40e_aqc_query_vsi_bw_config_resp *bw_data,\n\t\t\t    struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)bw_data, sizeof(*bw_data),\n\t\t\t\t    i40e_aqc_opc_query_vsi_bw_config,\n\t\t\t\t    cmd_details);\n}\n\n \nint\ni40e_aq_query_vsi_ets_sla_config(struct i40e_hw *hw,\n\t\t\t\t u16 seid,\n\t\t\t\t struct i40e_aqc_query_vsi_ets_sla_config_resp *bw_data,\n\t\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)bw_data, sizeof(*bw_data),\n\t\t\t\t    i40e_aqc_opc_query_vsi_ets_sla_config,\n\t\t\t\t    cmd_details);\n}\n\n \nint\ni40e_aq_query_switch_comp_ets_config(struct i40e_hw *hw,\n\t\t\t\t     u16 seid,\n\t\t\t\t     struct i40e_aqc_query_switching_comp_ets_config_resp *bw_data,\n\t\t\t\t     struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)bw_data, sizeof(*bw_data),\n\t\t\t\t   i40e_aqc_opc_query_switching_comp_ets_config,\n\t\t\t\t   cmd_details);\n}\n\n \nint\ni40e_aq_query_port_ets_config(struct i40e_hw *hw,\n\t\t\t      u16 seid,\n\t\t\t      struct i40e_aqc_query_port_ets_config_resp *bw_data,\n\t\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)bw_data, sizeof(*bw_data),\n\t\t\t\t    i40e_aqc_opc_query_port_ets_config,\n\t\t\t\t    cmd_details);\n}\n\n \nint\ni40e_aq_query_switch_comp_bw_config(struct i40e_hw *hw,\n\t\t\t\t    u16 seid,\n\t\t\t\t    struct i40e_aqc_query_switching_comp_bw_config_resp *bw_data,\n\t\t\t\t    struct i40e_asq_cmd_details *cmd_details)\n{\n\treturn i40e_aq_tx_sched_cmd(hw, seid, (void *)bw_data, sizeof(*bw_data),\n\t\t\t\t    i40e_aqc_opc_query_switching_comp_bw_config,\n\t\t\t\t    cmd_details);\n}\n\n \nstatic int\ni40e_validate_filter_settings(struct i40e_hw *hw,\n\t\t\t      struct i40e_filter_control_settings *settings)\n{\n\tu32 fcoe_cntx_size, fcoe_filt_size;\n\tu32 fcoe_fmax;\n\tu32 val;\n\n\t \n\tswitch (settings->fcoe_filt_num) {\n\tcase I40E_HASH_FILTER_SIZE_1K:\n\tcase I40E_HASH_FILTER_SIZE_2K:\n\tcase I40E_HASH_FILTER_SIZE_4K:\n\tcase I40E_HASH_FILTER_SIZE_8K:\n\tcase I40E_HASH_FILTER_SIZE_16K:\n\tcase I40E_HASH_FILTER_SIZE_32K:\n\t\tfcoe_filt_size = I40E_HASH_FILTER_BASE_SIZE;\n\t\tfcoe_filt_size <<= (u32)settings->fcoe_filt_num;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (settings->fcoe_cntx_num) {\n\tcase I40E_DMA_CNTX_SIZE_512:\n\tcase I40E_DMA_CNTX_SIZE_1K:\n\tcase I40E_DMA_CNTX_SIZE_2K:\n\tcase I40E_DMA_CNTX_SIZE_4K:\n\t\tfcoe_cntx_size = I40E_DMA_CNTX_BASE_SIZE;\n\t\tfcoe_cntx_size <<= (u32)settings->fcoe_cntx_num;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (settings->pe_filt_num) {\n\tcase I40E_HASH_FILTER_SIZE_1K:\n\tcase I40E_HASH_FILTER_SIZE_2K:\n\tcase I40E_HASH_FILTER_SIZE_4K:\n\tcase I40E_HASH_FILTER_SIZE_8K:\n\tcase I40E_HASH_FILTER_SIZE_16K:\n\tcase I40E_HASH_FILTER_SIZE_32K:\n\tcase I40E_HASH_FILTER_SIZE_64K:\n\tcase I40E_HASH_FILTER_SIZE_128K:\n\tcase I40E_HASH_FILTER_SIZE_256K:\n\tcase I40E_HASH_FILTER_SIZE_512K:\n\tcase I40E_HASH_FILTER_SIZE_1M:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (settings->pe_cntx_num) {\n\tcase I40E_DMA_CNTX_SIZE_512:\n\tcase I40E_DMA_CNTX_SIZE_1K:\n\tcase I40E_DMA_CNTX_SIZE_2K:\n\tcase I40E_DMA_CNTX_SIZE_4K:\n\tcase I40E_DMA_CNTX_SIZE_8K:\n\tcase I40E_DMA_CNTX_SIZE_16K:\n\tcase I40E_DMA_CNTX_SIZE_32K:\n\tcase I40E_DMA_CNTX_SIZE_64K:\n\tcase I40E_DMA_CNTX_SIZE_128K:\n\tcase I40E_DMA_CNTX_SIZE_256K:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = rd32(hw, I40E_GLHMC_FCOEFMAX);\n\tfcoe_fmax = (val & I40E_GLHMC_FCOEFMAX_PMFCOEFMAX_MASK)\n\t\t     >> I40E_GLHMC_FCOEFMAX_PMFCOEFMAX_SHIFT;\n\tif (fcoe_filt_size + fcoe_cntx_size >  fcoe_fmax)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint i40e_set_filter_control(struct i40e_hw *hw,\n\t\t\t    struct i40e_filter_control_settings *settings)\n{\n\tu32 hash_lut_size = 0;\n\tint ret = 0;\n\tu32 val;\n\n\tif (!settings)\n\t\treturn -EINVAL;\n\n\t \n\tret = i40e_validate_filter_settings(hw, settings);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = i40e_read_rx_ctl(hw, I40E_PFQF_CTL_0);\n\n\t \n\tval &= ~I40E_PFQF_CTL_0_PEHSIZE_MASK;\n\tval |= ((u32)settings->pe_filt_num << I40E_PFQF_CTL_0_PEHSIZE_SHIFT) &\n\t\tI40E_PFQF_CTL_0_PEHSIZE_MASK;\n\t \n\tval &= ~I40E_PFQF_CTL_0_PEDSIZE_MASK;\n\tval |= ((u32)settings->pe_cntx_num << I40E_PFQF_CTL_0_PEDSIZE_SHIFT) &\n\t\tI40E_PFQF_CTL_0_PEDSIZE_MASK;\n\n\t \n\tval &= ~I40E_PFQF_CTL_0_PFFCHSIZE_MASK;\n\tval |= ((u32)settings->fcoe_filt_num <<\n\t\t\tI40E_PFQF_CTL_0_PFFCHSIZE_SHIFT) &\n\t\tI40E_PFQF_CTL_0_PFFCHSIZE_MASK;\n\t \n\tval &= ~I40E_PFQF_CTL_0_PFFCDSIZE_MASK;\n\tval |= ((u32)settings->fcoe_cntx_num <<\n\t\t\tI40E_PFQF_CTL_0_PFFCDSIZE_SHIFT) &\n\t\tI40E_PFQF_CTL_0_PFFCDSIZE_MASK;\n\n\t \n\tval &= ~I40E_PFQF_CTL_0_HASHLUTSIZE_MASK;\n\tif (settings->hash_lut_size == I40E_HASH_LUT_SIZE_512)\n\t\thash_lut_size = 1;\n\tval |= (hash_lut_size << I40E_PFQF_CTL_0_HASHLUTSIZE_SHIFT) &\n\t\tI40E_PFQF_CTL_0_HASHLUTSIZE_MASK;\n\n\t \n\tif (settings->enable_fdir)\n\t\tval |= I40E_PFQF_CTL_0_FD_ENA_MASK;\n\tif (settings->enable_ethtype)\n\t\tval |= I40E_PFQF_CTL_0_ETYPE_ENA_MASK;\n\tif (settings->enable_macvlan)\n\t\tval |= I40E_PFQF_CTL_0_MACVLAN_ENA_MASK;\n\n\ti40e_write_rx_ctl(hw, I40E_PFQF_CTL_0, val);\n\n\treturn 0;\n}\n\n \nint i40e_aq_add_rem_control_packet_filter(struct i40e_hw *hw,\n\t\t\t\t\t  u8 *mac_addr, u16 ethtype, u16 flags,\n\t\t\t\t\t  u16 vsi_seid, u16 queue, bool is_add,\n\t\t\t\t\t  struct i40e_control_filter_stats *stats,\n\t\t\t\t\t  struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_remove_control_packet_filter *cmd =\n\t\t(struct i40e_aqc_add_remove_control_packet_filter *)\n\t\t&desc.params.raw;\n\tstruct i40e_aqc_add_remove_control_packet_filter_completion *resp =\n\t\t(struct i40e_aqc_add_remove_control_packet_filter_completion *)\n\t\t&desc.params.raw;\n\tint status;\n\n\tif (vsi_seid == 0)\n\t\treturn -EINVAL;\n\n\tif (is_add) {\n\t\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\ti40e_aqc_opc_add_control_packet_filter);\n\t\tcmd->queue = cpu_to_le16(queue);\n\t} else {\n\t\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\ti40e_aqc_opc_remove_control_packet_filter);\n\t}\n\n\tif (mac_addr)\n\t\tether_addr_copy(cmd->mac, mac_addr);\n\n\tcmd->etype = cpu_to_le16(ethtype);\n\tcmd->flags = cpu_to_le16(flags);\n\tcmd->seid = cpu_to_le16(vsi_seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (!status && stats) {\n\t\tstats->mac_etype_used = le16_to_cpu(resp->mac_etype_used);\n\t\tstats->etype_used = le16_to_cpu(resp->etype_used);\n\t\tstats->mac_etype_free = le16_to_cpu(resp->mac_etype_free);\n\t\tstats->etype_free = le16_to_cpu(resp->etype_free);\n\t}\n\n\treturn status;\n}\n\n \nvoid i40e_add_filter_to_drop_tx_flow_control_frames(struct i40e_hw *hw,\n\t\t\t\t\t\t    u16 seid)\n{\n#define I40E_FLOW_CONTROL_ETHTYPE 0x8808\n\tu16 flag = I40E_AQC_ADD_CONTROL_PACKET_FLAGS_IGNORE_MAC |\n\t\t   I40E_AQC_ADD_CONTROL_PACKET_FLAGS_DROP |\n\t\t   I40E_AQC_ADD_CONTROL_PACKET_FLAGS_TX;\n\tu16 ethtype = I40E_FLOW_CONTROL_ETHTYPE;\n\tint status;\n\n\tstatus = i40e_aq_add_rem_control_packet_filter(hw, NULL, ethtype, flag,\n\t\t\t\t\t\t       seid, 0, true, NULL,\n\t\t\t\t\t\t       NULL);\n\tif (status)\n\t\thw_dbg(hw, \"Ethtype Filter Add failed: Error pruning Tx flow control frames\\n\");\n}\n\n \nstatic int i40e_aq_alternate_read(struct i40e_hw *hw,\n\t\t\t\t  u32 reg_addr0, u32 *reg_val0,\n\t\t\t\t  u32 reg_addr1, u32 *reg_val1)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_alternate_write *cmd_resp =\n\t\t(struct i40e_aqc_alternate_write *)&desc.params.raw;\n\tint status;\n\n\tif (!reg_val0)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_alternate_read);\n\tcmd_resp->address0 = cpu_to_le32(reg_addr0);\n\tcmd_resp->address1 = cpu_to_le32(reg_addr1);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, NULL);\n\n\tif (!status) {\n\t\t*reg_val0 = le32_to_cpu(cmd_resp->data0);\n\n\t\tif (reg_val1)\n\t\t\t*reg_val1 = le32_to_cpu(cmd_resp->data1);\n\t}\n\n\treturn status;\n}\n\n \nint i40e_aq_suspend_port_tx(struct i40e_hw *hw, u16 seid,\n\t\t\t    struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aqc_tx_sched_ind *cmd;\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\tcmd = (struct i40e_aqc_tx_sched_ind *)&desc.params.raw;\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_suspend_port_tx);\n\tcmd->vsi_seid = cpu_to_le16(seid);\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_resume_port_tx(struct i40e_hw *hw,\n\t\t\t   struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_resume_port_tx);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nvoid i40e_set_pci_config_data(struct i40e_hw *hw, u16 link_status)\n{\n\thw->bus.type = i40e_bus_type_pci_express;\n\n\tswitch (link_status & PCI_EXP_LNKSTA_NLW) {\n\tcase PCI_EXP_LNKSTA_NLW_X1:\n\t\thw->bus.width = i40e_bus_width_pcie_x1;\n\t\tbreak;\n\tcase PCI_EXP_LNKSTA_NLW_X2:\n\t\thw->bus.width = i40e_bus_width_pcie_x2;\n\t\tbreak;\n\tcase PCI_EXP_LNKSTA_NLW_X4:\n\t\thw->bus.width = i40e_bus_width_pcie_x4;\n\t\tbreak;\n\tcase PCI_EXP_LNKSTA_NLW_X8:\n\t\thw->bus.width = i40e_bus_width_pcie_x8;\n\t\tbreak;\n\tdefault:\n\t\thw->bus.width = i40e_bus_width_unknown;\n\t\tbreak;\n\t}\n\n\tswitch (link_status & PCI_EXP_LNKSTA_CLS) {\n\tcase PCI_EXP_LNKSTA_CLS_2_5GB:\n\t\thw->bus.speed = i40e_bus_speed_2500;\n\t\tbreak;\n\tcase PCI_EXP_LNKSTA_CLS_5_0GB:\n\t\thw->bus.speed = i40e_bus_speed_5000;\n\t\tbreak;\n\tcase PCI_EXP_LNKSTA_CLS_8_0GB:\n\t\thw->bus.speed = i40e_bus_speed_8000;\n\t\tbreak;\n\tdefault:\n\t\thw->bus.speed = i40e_bus_speed_unknown;\n\t\tbreak;\n\t}\n}\n\n \nint i40e_aq_debug_dump(struct i40e_hw *hw, u8 cluster_id,\n\t\t       u8 table_id, u32 start_index, u16 buff_size,\n\t\t       void *buff, u16 *ret_buff_size,\n\t\t       u8 *ret_next_table, u32 *ret_next_index,\n\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_debug_dump_internals *cmd =\n\t\t(struct i40e_aqc_debug_dump_internals *)&desc.params.raw;\n\tstruct i40e_aqc_debug_dump_internals *resp =\n\t\t(struct i40e_aqc_debug_dump_internals *)&desc.params.raw;\n\tint status;\n\n\tif (buff_size == 0 || !buff)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_debug_dump_internals);\n\t \n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tif (buff_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tcmd->cluster_id = cluster_id;\n\tcmd->table_id = table_id;\n\tcmd->idx = cpu_to_le32(start_index);\n\n\tdesc.datalen = cpu_to_le16(buff_size);\n\n\tstatus = i40e_asq_send_command(hw, &desc, buff, buff_size, cmd_details);\n\tif (!status) {\n\t\tif (ret_buff_size)\n\t\t\t*ret_buff_size = le16_to_cpu(desc.datalen);\n\t\tif (ret_next_table)\n\t\t\t*ret_next_table = resp->table_id;\n\t\tif (ret_next_index)\n\t\t\t*ret_next_index = le32_to_cpu(resp->idx);\n\t}\n\n\treturn status;\n}\n\n \nint i40e_read_bw_from_alt_ram(struct i40e_hw *hw,\n\t\t\t      u32 *max_bw, u32 *min_bw,\n\t\t\t      bool *min_valid, bool *max_valid)\n{\n\tu32 max_bw_addr, min_bw_addr;\n\tint status;\n\n\t \n\tmax_bw_addr = I40E_ALT_STRUCT_FIRST_PF_OFFSET +\n\t\t      I40E_ALT_STRUCT_MAX_BW_OFFSET +\n\t\t      (I40E_ALT_STRUCT_DWORDS_PER_PF * hw->pf_id);\n\tmin_bw_addr = I40E_ALT_STRUCT_FIRST_PF_OFFSET +\n\t\t      I40E_ALT_STRUCT_MIN_BW_OFFSET +\n\t\t      (I40E_ALT_STRUCT_DWORDS_PER_PF * hw->pf_id);\n\n\t \n\tstatus = i40e_aq_alternate_read(hw, max_bw_addr, max_bw,\n\t\t\t\t\tmin_bw_addr, min_bw);\n\n\tif (*min_bw & I40E_ALT_BW_VALID_MASK)\n\t\t*min_valid = true;\n\telse\n\t\t*min_valid = false;\n\n\tif (*max_bw & I40E_ALT_BW_VALID_MASK)\n\t\t*max_valid = true;\n\telse\n\t\t*max_valid = false;\n\n\treturn status;\n}\n\n \nint\ni40e_aq_configure_partition_bw(struct i40e_hw *hw,\n\t\t\t       struct i40e_aqc_configure_partition_bw_data *bw_data,\n\t\t\t       struct i40e_asq_cmd_details *cmd_details)\n{\n\tu16 bwd_size = sizeof(*bw_data);\n\tstruct i40e_aq_desc desc;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_configure_partition_bw);\n\n\t \n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_RD);\n\n\tif (bwd_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tdesc.datalen = cpu_to_le16(bwd_size);\n\n\tstatus = i40e_asq_send_command(hw, &desc, bw_data, bwd_size,\n\t\t\t\t       cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_read_phy_register_clause22(struct i40e_hw *hw,\n\t\t\t\t    u16 reg, u8 phy_addr, u16 *value)\n{\n\tu8 port_num = (u8)hw->func_caps.mdio_port_num;\n\tint status = -EIO;\n\tu32 command = 0;\n\tu16 retry = 1000;\n\n\tcommand = (reg << I40E_GLGEN_MSCA_DEVADD_SHIFT) |\n\t\t  (phy_addr << I40E_GLGEN_MSCA_PHYADD_SHIFT) |\n\t\t  (I40E_MDIO_CLAUSE22_OPCODE_READ_MASK) |\n\t\t  (I40E_MDIO_CLAUSE22_STCODE_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDICMD_MASK);\n\twr32(hw, I40E_GLGEN_MSCA(port_num), command);\n\tdo {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSCA(port_num));\n\t\tif (!(command & I40E_GLGEN_MSCA_MDICMD_MASK)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t\tretry--;\n\t} while (retry);\n\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_PHY,\n\t\t\t   \"PHY: Can't write command to external PHY.\\n\");\n\t} else {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSRWD(port_num));\n\t\t*value = (command & I40E_GLGEN_MSRWD_MDIRDDATA_MASK) >>\n\t\t\t I40E_GLGEN_MSRWD_MDIRDDATA_SHIFT;\n\t}\n\n\treturn status;\n}\n\n \nint i40e_write_phy_register_clause22(struct i40e_hw *hw,\n\t\t\t\t     u16 reg, u8 phy_addr, u16 value)\n{\n\tu8 port_num = (u8)hw->func_caps.mdio_port_num;\n\tint status = -EIO;\n\tu32 command  = 0;\n\tu16 retry = 1000;\n\n\tcommand = value << I40E_GLGEN_MSRWD_MDIWRDATA_SHIFT;\n\twr32(hw, I40E_GLGEN_MSRWD(port_num), command);\n\n\tcommand = (reg << I40E_GLGEN_MSCA_DEVADD_SHIFT) |\n\t\t  (phy_addr << I40E_GLGEN_MSCA_PHYADD_SHIFT) |\n\t\t  (I40E_MDIO_CLAUSE22_OPCODE_WRITE_MASK) |\n\t\t  (I40E_MDIO_CLAUSE22_STCODE_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDICMD_MASK);\n\n\twr32(hw, I40E_GLGEN_MSCA(port_num), command);\n\tdo {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSCA(port_num));\n\t\tif (!(command & I40E_GLGEN_MSCA_MDICMD_MASK)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t\tretry--;\n\t} while (retry);\n\n\treturn status;\n}\n\n \nint i40e_read_phy_register_clause45(struct i40e_hw *hw,\n\t\t\t\t    u8 page, u16 reg, u8 phy_addr, u16 *value)\n{\n\tu8 port_num = hw->func_caps.mdio_port_num;\n\tint status = -EIO;\n\tu32 command = 0;\n\tu16 retry = 1000;\n\n\tcommand = (reg << I40E_GLGEN_MSCA_MDIADD_SHIFT) |\n\t\t  (page << I40E_GLGEN_MSCA_DEVADD_SHIFT) |\n\t\t  (phy_addr << I40E_GLGEN_MSCA_PHYADD_SHIFT) |\n\t\t  (I40E_MDIO_CLAUSE45_OPCODE_ADDRESS_MASK) |\n\t\t  (I40E_MDIO_CLAUSE45_STCODE_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDICMD_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDIINPROGEN_MASK);\n\twr32(hw, I40E_GLGEN_MSCA(port_num), command);\n\tdo {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSCA(port_num));\n\t\tif (!(command & I40E_GLGEN_MSCA_MDICMD_MASK)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tretry--;\n\t} while (retry);\n\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_PHY,\n\t\t\t   \"PHY: Can't write command to external PHY.\\n\");\n\t\tgoto phy_read_end;\n\t}\n\n\tcommand = (page << I40E_GLGEN_MSCA_DEVADD_SHIFT) |\n\t\t  (phy_addr << I40E_GLGEN_MSCA_PHYADD_SHIFT) |\n\t\t  (I40E_MDIO_CLAUSE45_OPCODE_READ_MASK) |\n\t\t  (I40E_MDIO_CLAUSE45_STCODE_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDICMD_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDIINPROGEN_MASK);\n\tstatus = -EIO;\n\tretry = 1000;\n\twr32(hw, I40E_GLGEN_MSCA(port_num), command);\n\tdo {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSCA(port_num));\n\t\tif (!(command & I40E_GLGEN_MSCA_MDICMD_MASK)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tretry--;\n\t} while (retry);\n\n\tif (!status) {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSRWD(port_num));\n\t\t*value = (command & I40E_GLGEN_MSRWD_MDIRDDATA_MASK) >>\n\t\t\t I40E_GLGEN_MSRWD_MDIRDDATA_SHIFT;\n\t} else {\n\t\ti40e_debug(hw, I40E_DEBUG_PHY,\n\t\t\t   \"PHY: Can't read register value from external PHY.\\n\");\n\t}\n\nphy_read_end:\n\treturn status;\n}\n\n \nint i40e_write_phy_register_clause45(struct i40e_hw *hw,\n\t\t\t\t     u8 page, u16 reg, u8 phy_addr, u16 value)\n{\n\tu8 port_num = hw->func_caps.mdio_port_num;\n\tint status = -EIO;\n\tu16 retry = 1000;\n\tu32 command = 0;\n\n\tcommand = (reg << I40E_GLGEN_MSCA_MDIADD_SHIFT) |\n\t\t  (page << I40E_GLGEN_MSCA_DEVADD_SHIFT) |\n\t\t  (phy_addr << I40E_GLGEN_MSCA_PHYADD_SHIFT) |\n\t\t  (I40E_MDIO_CLAUSE45_OPCODE_ADDRESS_MASK) |\n\t\t  (I40E_MDIO_CLAUSE45_STCODE_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDICMD_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDIINPROGEN_MASK);\n\twr32(hw, I40E_GLGEN_MSCA(port_num), command);\n\tdo {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSCA(port_num));\n\t\tif (!(command & I40E_GLGEN_MSCA_MDICMD_MASK)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tretry--;\n\t} while (retry);\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_PHY,\n\t\t\t   \"PHY: Can't write command to external PHY.\\n\");\n\t\tgoto phy_write_end;\n\t}\n\n\tcommand = value << I40E_GLGEN_MSRWD_MDIWRDATA_SHIFT;\n\twr32(hw, I40E_GLGEN_MSRWD(port_num), command);\n\n\tcommand = (page << I40E_GLGEN_MSCA_DEVADD_SHIFT) |\n\t\t  (phy_addr << I40E_GLGEN_MSCA_PHYADD_SHIFT) |\n\t\t  (I40E_MDIO_CLAUSE45_OPCODE_WRITE_MASK) |\n\t\t  (I40E_MDIO_CLAUSE45_STCODE_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDICMD_MASK) |\n\t\t  (I40E_GLGEN_MSCA_MDIINPROGEN_MASK);\n\tstatus = -EIO;\n\tretry = 1000;\n\twr32(hw, I40E_GLGEN_MSCA(port_num), command);\n\tdo {\n\t\tcommand = rd32(hw, I40E_GLGEN_MSCA(port_num));\n\t\tif (!(command & I40E_GLGEN_MSCA_MDICMD_MASK)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tretry--;\n\t} while (retry);\n\nphy_write_end:\n\treturn status;\n}\n\n \nint i40e_write_phy_register(struct i40e_hw *hw,\n\t\t\t    u8 page, u16 reg, u8 phy_addr, u16 value)\n{\n\tint status;\n\n\tswitch (hw->device_id) {\n\tcase I40E_DEV_ID_1G_BASE_T_X722:\n\t\tstatus = i40e_write_phy_register_clause22(hw, reg, phy_addr,\n\t\t\t\t\t\t\t  value);\n\t\tbreak;\n\tcase I40E_DEV_ID_1G_BASE_T_BC:\n\tcase I40E_DEV_ID_5G_BASE_T_BC:\n\tcase I40E_DEV_ID_10G_BASE_T:\n\tcase I40E_DEV_ID_10G_BASE_T4:\n\tcase I40E_DEV_ID_10G_BASE_T_BC:\n\tcase I40E_DEV_ID_10G_BASE_T_X722:\n\tcase I40E_DEV_ID_25G_B:\n\tcase I40E_DEV_ID_25G_SFP28:\n\t\tstatus = i40e_write_phy_register_clause45(hw, page, reg,\n\t\t\t\t\t\t\t  phy_addr, value);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EIO;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nint i40e_read_phy_register(struct i40e_hw *hw,\n\t\t\t   u8 page, u16 reg, u8 phy_addr, u16 *value)\n{\n\tint status;\n\n\tswitch (hw->device_id) {\n\tcase I40E_DEV_ID_1G_BASE_T_X722:\n\t\tstatus = i40e_read_phy_register_clause22(hw, reg, phy_addr,\n\t\t\t\t\t\t\t value);\n\t\tbreak;\n\tcase I40E_DEV_ID_1G_BASE_T_BC:\n\tcase I40E_DEV_ID_5G_BASE_T_BC:\n\tcase I40E_DEV_ID_10G_BASE_T:\n\tcase I40E_DEV_ID_10G_BASE_T4:\n\tcase I40E_DEV_ID_10G_BASE_T_BC:\n\tcase I40E_DEV_ID_10G_BASE_T_X722:\n\tcase I40E_DEV_ID_25G_B:\n\tcase I40E_DEV_ID_25G_SFP28:\n\t\tstatus = i40e_read_phy_register_clause45(hw, page, reg,\n\t\t\t\t\t\t\t phy_addr, value);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EIO;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nu8 i40e_get_phy_address(struct i40e_hw *hw, u8 dev_num)\n{\n\tu8 port_num = hw->func_caps.mdio_port_num;\n\tu32 reg_val = rd32(hw, I40E_GLGEN_MDIO_I2C_SEL(port_num));\n\n\treturn (u8)(reg_val >> ((dev_num + 1) * 5)) & 0x1f;\n}\n\n \nint i40e_blink_phy_link_led(struct i40e_hw *hw,\n\t\t\t    u32 time, u32 interval)\n{\n\tu16 led_addr = I40E_PHY_LED_PROV_REG_1;\n\tu16 gpio_led_port;\n\tu8 phy_addr = 0;\n\tint status = 0;\n\tu16 led_ctl;\n\tu8 port_num;\n\tu16 led_reg;\n\tu32 i;\n\n\ti = rd32(hw, I40E_PFGEN_PORTNUM);\n\tport_num = (u8)(i & I40E_PFGEN_PORTNUM_PORT_NUM_MASK);\n\tphy_addr = i40e_get_phy_address(hw, port_num);\n\n\tfor (gpio_led_port = 0; gpio_led_port < 3; gpio_led_port++,\n\t     led_addr++) {\n\t\tstatus = i40e_read_phy_register_clause45(hw,\n\t\t\t\t\t\t\t I40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\t\t led_addr, phy_addr,\n\t\t\t\t\t\t\t &led_reg);\n\t\tif (status)\n\t\t\tgoto phy_blinking_end;\n\t\tled_ctl = led_reg;\n\t\tif (led_reg & I40E_PHY_LED_LINK_MODE_MASK) {\n\t\t\tled_reg = 0;\n\t\t\tstatus = i40e_write_phy_register_clause45(hw,\n\t\t\t\t\t\t\t I40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\t\t led_addr, phy_addr,\n\t\t\t\t\t\t\t led_reg);\n\t\t\tif (status)\n\t\t\t\tgoto phy_blinking_end;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (time > 0 && interval > 0) {\n\t\tfor (i = 0; i < time * 1000; i += interval) {\n\t\t\tstatus = i40e_read_phy_register_clause45(hw,\n\t\t\t\t\t\tI40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\tled_addr, phy_addr, &led_reg);\n\t\t\tif (status)\n\t\t\t\tgoto restore_config;\n\t\t\tif (led_reg & I40E_PHY_LED_MANUAL_ON)\n\t\t\t\tled_reg = 0;\n\t\t\telse\n\t\t\t\tled_reg = I40E_PHY_LED_MANUAL_ON;\n\t\t\tstatus = i40e_write_phy_register_clause45(hw,\n\t\t\t\t\t\tI40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\tled_addr, phy_addr, led_reg);\n\t\t\tif (status)\n\t\t\t\tgoto restore_config;\n\t\t\tmsleep(interval);\n\t\t}\n\t}\n\nrestore_config:\n\tstatus = i40e_write_phy_register_clause45(hw,\n\t\t\t\t\t\t  I40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\t  led_addr, phy_addr, led_ctl);\n\nphy_blinking_end:\n\treturn status;\n}\n\n \nstatic int i40e_led_get_reg(struct i40e_hw *hw, u16 led_addr,\n\t\t\t    u32 *reg_val)\n{\n\tu8 phy_addr = 0;\n\tu8 port_num;\n\tint status;\n\tu32 i;\n\n\t*reg_val = 0;\n\tif (hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE) {\n\t\tstatus =\n\t\t       i40e_aq_get_phy_register(hw,\n\t\t\t\t\t\tI40E_AQ_PHY_REG_ACCESS_EXTERNAL,\n\t\t\t\t\t\tI40E_PHY_COM_REG_PAGE, true,\n\t\t\t\t\t\tI40E_PHY_LED_PROV_REG_1,\n\t\t\t\t\t\treg_val, NULL);\n\t} else {\n\t\ti = rd32(hw, I40E_PFGEN_PORTNUM);\n\t\tport_num = (u8)(i & I40E_PFGEN_PORTNUM_PORT_NUM_MASK);\n\t\tphy_addr = i40e_get_phy_address(hw, port_num);\n\t\tstatus = i40e_read_phy_register_clause45(hw,\n\t\t\t\t\t\t\t I40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\t\t led_addr, phy_addr,\n\t\t\t\t\t\t\t (u16 *)reg_val);\n\t}\n\treturn status;\n}\n\n \nstatic int i40e_led_set_reg(struct i40e_hw *hw, u16 led_addr,\n\t\t\t    u32 reg_val)\n{\n\tu8 phy_addr = 0;\n\tu8 port_num;\n\tint status;\n\tu32 i;\n\n\tif (hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE) {\n\t\tstatus =\n\t\t       i40e_aq_set_phy_register(hw,\n\t\t\t\t\t\tI40E_AQ_PHY_REG_ACCESS_EXTERNAL,\n\t\t\t\t\t\tI40E_PHY_COM_REG_PAGE, true,\n\t\t\t\t\t\tI40E_PHY_LED_PROV_REG_1,\n\t\t\t\t\t\treg_val, NULL);\n\t} else {\n\t\ti = rd32(hw, I40E_PFGEN_PORTNUM);\n\t\tport_num = (u8)(i & I40E_PFGEN_PORTNUM_PORT_NUM_MASK);\n\t\tphy_addr = i40e_get_phy_address(hw, port_num);\n\t\tstatus = i40e_write_phy_register_clause45(hw,\n\t\t\t\t\t\t\t  I40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\t\t  led_addr, phy_addr,\n\t\t\t\t\t\t\t  (u16)reg_val);\n\t}\n\n\treturn status;\n}\n\n \nint i40e_led_get_phy(struct i40e_hw *hw, u16 *led_addr,\n\t\t     u16 *val)\n{\n\tu16 gpio_led_port;\n\tu8 phy_addr = 0;\n\tu32 reg_val_aq;\n\tint status = 0;\n\tu16 temp_addr;\n\tu16 reg_val;\n\tu8 port_num;\n\tu32 i;\n\n\tif (hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE) {\n\t\tstatus =\n\t\t      i40e_aq_get_phy_register(hw,\n\t\t\t\t\t       I40E_AQ_PHY_REG_ACCESS_EXTERNAL,\n\t\t\t\t\t       I40E_PHY_COM_REG_PAGE, true,\n\t\t\t\t\t       I40E_PHY_LED_PROV_REG_1,\n\t\t\t\t\t       &reg_val_aq, NULL);\n\t\tif (status == 0)\n\t\t\t*val = (u16)reg_val_aq;\n\t\treturn status;\n\t}\n\ttemp_addr = I40E_PHY_LED_PROV_REG_1;\n\ti = rd32(hw, I40E_PFGEN_PORTNUM);\n\tport_num = (u8)(i & I40E_PFGEN_PORTNUM_PORT_NUM_MASK);\n\tphy_addr = i40e_get_phy_address(hw, port_num);\n\n\tfor (gpio_led_port = 0; gpio_led_port < 3; gpio_led_port++,\n\t     temp_addr++) {\n\t\tstatus = i40e_read_phy_register_clause45(hw,\n\t\t\t\t\t\t\t I40E_PHY_COM_REG_PAGE,\n\t\t\t\t\t\t\t temp_addr, phy_addr,\n\t\t\t\t\t\t\t &reg_val);\n\t\tif (status)\n\t\t\treturn status;\n\t\t*val = reg_val;\n\t\tif (reg_val & I40E_PHY_LED_LINK_MODE_MASK) {\n\t\t\t*led_addr = temp_addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn status;\n}\n\n \nint i40e_led_set_phy(struct i40e_hw *hw, bool on,\n\t\t     u16 led_addr, u32 mode)\n{\n\tu32 led_ctl = 0;\n\tu32 led_reg = 0;\n\tint status = 0;\n\n\tstatus = i40e_led_get_reg(hw, led_addr, &led_reg);\n\tif (status)\n\t\treturn status;\n\tled_ctl = led_reg;\n\tif (led_reg & I40E_PHY_LED_LINK_MODE_MASK) {\n\t\tled_reg = 0;\n\t\tstatus = i40e_led_set_reg(hw, led_addr, led_reg);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\tstatus = i40e_led_get_reg(hw, led_addr, &led_reg);\n\tif (status)\n\t\tgoto restore_config;\n\tif (on)\n\t\tled_reg = I40E_PHY_LED_MANUAL_ON;\n\telse\n\t\tled_reg = 0;\n\n\tstatus = i40e_led_set_reg(hw, led_addr, led_reg);\n\tif (status)\n\t\tgoto restore_config;\n\tif (mode & I40E_PHY_LED_MODE_ORIG) {\n\t\tled_ctl = (mode & I40E_PHY_LED_MODE_MASK);\n\t\tstatus = i40e_led_set_reg(hw, led_addr, led_ctl);\n\t}\n\treturn status;\n\nrestore_config:\n\tstatus = i40e_led_set_reg(hw, led_addr, led_ctl);\n\treturn status;\n}\n\n \nint i40e_aq_rx_ctl_read_register(struct i40e_hw *hw,\n\t\t\t\t u32 reg_addr, u32 *reg_val,\n\t\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_rx_ctl_reg_read_write *cmd_resp =\n\t\t(struct i40e_aqc_rx_ctl_reg_read_write *)&desc.params.raw;\n\tint status;\n\n\tif (!reg_val)\n\t\treturn -EINVAL;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_rx_ctl_reg_read);\n\n\tcmd_resp->address = cpu_to_le32(reg_addr);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\tif (status == 0)\n\t\t*reg_val = le32_to_cpu(cmd_resp->value);\n\n\treturn status;\n}\n\n \nu32 i40e_read_rx_ctl(struct i40e_hw *hw, u32 reg_addr)\n{\n\tbool use_register;\n\tint status = 0;\n\tint retry = 5;\n\tu32 val = 0;\n\n\tuse_register = (((hw->aq.api_maj_ver == 1) &&\n\t\t\t(hw->aq.api_min_ver < 5)) ||\n\t\t\t(hw->mac.type == I40E_MAC_X722));\n\tif (!use_register) {\ndo_retry:\n\t\tstatus = i40e_aq_rx_ctl_read_register(hw, reg_addr, &val, NULL);\n\t\tif (hw->aq.asq_last_status == I40E_AQ_RC_EAGAIN && retry) {\n\t\t\tusleep_range(1000, 2000);\n\t\t\tretry--;\n\t\t\tgoto do_retry;\n\t\t}\n\t}\n\n\t \n\tif (status || use_register)\n\t\tval = rd32(hw, reg_addr);\n\n\treturn val;\n}\n\n \nint i40e_aq_rx_ctl_write_register(struct i40e_hw *hw,\n\t\t\t\t  u32 reg_addr, u32 reg_val,\n\t\t\t\t  struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_rx_ctl_reg_read_write *cmd =\n\t\t(struct i40e_aqc_rx_ctl_reg_read_write *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_rx_ctl_reg_write);\n\n\tcmd->address = cpu_to_le32(reg_addr);\n\tcmd->value = cpu_to_le32(reg_val);\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nvoid i40e_write_rx_ctl(struct i40e_hw *hw, u32 reg_addr, u32 reg_val)\n{\n\tbool use_register;\n\tint status = 0;\n\tint retry = 5;\n\n\tuse_register = (((hw->aq.api_maj_ver == 1) &&\n\t\t\t(hw->aq.api_min_ver < 5)) ||\n\t\t\t(hw->mac.type == I40E_MAC_X722));\n\tif (!use_register) {\ndo_retry:\n\t\tstatus = i40e_aq_rx_ctl_write_register(hw, reg_addr,\n\t\t\t\t\t\t       reg_val, NULL);\n\t\tif (hw->aq.asq_last_status == I40E_AQ_RC_EAGAIN && retry) {\n\t\t\tusleep_range(1000, 2000);\n\t\t\tretry--;\n\t\t\tgoto do_retry;\n\t\t}\n\t}\n\n\t \n\tif (status || use_register)\n\t\twr32(hw, reg_addr, reg_val);\n}\n\n \nstatic void i40e_mdio_if_number_selection(struct i40e_hw *hw, bool set_mdio,\n\t\t\t\t\t  u8 mdio_num,\n\t\t\t\t\t  struct i40e_aqc_phy_register_access *cmd)\n{\n\tif (set_mdio && cmd->phy_interface == I40E_AQ_PHY_REG_ACCESS_EXTERNAL) {\n\t\tif (hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_EXTENDED)\n\t\t\tcmd->cmd_flags |=\n\t\t\t\tI40E_AQ_PHY_REG_ACCESS_SET_MDIO_IF_NUMBER |\n\t\t\t\t((mdio_num <<\n\t\t\t\tI40E_AQ_PHY_REG_ACCESS_MDIO_IF_NUMBER_SHIFT) &\n\t\t\t\tI40E_AQ_PHY_REG_ACCESS_MDIO_IF_NUMBER_MASK);\n\t\telse\n\t\t\ti40e_debug(hw, I40E_DEBUG_PHY,\n\t\t\t\t   \"MDIO I/F number selection not supported by current FW version.\\n\");\n\t}\n}\n\n \nint i40e_aq_set_phy_register_ext(struct i40e_hw *hw,\n\t\t\t\t u8 phy_select, u8 dev_addr, bool page_change,\n\t\t\t\t bool set_mdio, u8 mdio_num,\n\t\t\t\t u32 reg_addr, u32 reg_val,\n\t\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_phy_register_access *cmd =\n\t\t(struct i40e_aqc_phy_register_access *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_set_phy_register);\n\n\tcmd->phy_interface = phy_select;\n\tcmd->dev_address = dev_addr;\n\tcmd->reg_address = cpu_to_le32(reg_addr);\n\tcmd->reg_value = cpu_to_le32(reg_val);\n\n\ti40e_mdio_if_number_selection(hw, set_mdio, mdio_num, cmd);\n\n\tif (!page_change)\n\t\tcmd->cmd_flags = I40E_AQ_PHY_REG_ACCESS_DONT_CHANGE_QSFP_PAGE;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\n\treturn status;\n}\n\n \nint i40e_aq_get_phy_register_ext(struct i40e_hw *hw,\n\t\t\t\t u8 phy_select, u8 dev_addr, bool page_change,\n\t\t\t\t bool set_mdio, u8 mdio_num,\n\t\t\t\t u32 reg_addr, u32 *reg_val,\n\t\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_phy_register_access *cmd =\n\t\t(struct i40e_aqc_phy_register_access *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_get_phy_register);\n\n\tcmd->phy_interface = phy_select;\n\tcmd->dev_address = dev_addr;\n\tcmd->reg_address = cpu_to_le32(reg_addr);\n\n\ti40e_mdio_if_number_selection(hw, set_mdio, mdio_num, cmd);\n\n\tif (!page_change)\n\t\tcmd->cmd_flags = I40E_AQ_PHY_REG_ACCESS_DONT_CHANGE_QSFP_PAGE;\n\n\tstatus = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);\n\tif (!status)\n\t\t*reg_val = le32_to_cpu(cmd->reg_value);\n\n\treturn status;\n}\n\n \nint i40e_aq_write_ddp(struct i40e_hw *hw, void *buff,\n\t\t      u16 buff_size, u32 track_id,\n\t\t      u32 *error_offset, u32 *error_info,\n\t\t      struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_write_personalization_profile *cmd =\n\t\t(struct i40e_aqc_write_personalization_profile *)\n\t\t&desc.params.raw;\n\tstruct i40e_aqc_write_ddp_resp *resp;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_write_personalization_profile);\n\n\tdesc.flags |= cpu_to_le16(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD);\n\tif (buff_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\n\tdesc.datalen = cpu_to_le16(buff_size);\n\n\tcmd->profile_track_id = cpu_to_le32(track_id);\n\n\tstatus = i40e_asq_send_command(hw, &desc, buff, buff_size, cmd_details);\n\tif (!status) {\n\t\tresp = (struct i40e_aqc_write_ddp_resp *)&desc.params.raw;\n\t\tif (error_offset)\n\t\t\t*error_offset = le32_to_cpu(resp->error_offset);\n\t\tif (error_info)\n\t\t\t*error_info = le32_to_cpu(resp->error_info);\n\t}\n\n\treturn status;\n}\n\n \nint i40e_aq_get_ddp_list(struct i40e_hw *hw, void *buff,\n\t\t\t u16 buff_size, u8 flags,\n\t\t\t struct i40e_asq_cmd_details *cmd_details)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_get_applied_profiles *cmd =\n\t\t(struct i40e_aqc_get_applied_profiles *)&desc.params.raw;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_get_personalization_profile_list);\n\n\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\tif (buff_size > I40E_AQ_LARGE_BUF)\n\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\tdesc.datalen = cpu_to_le16(buff_size);\n\n\tcmd->flags = flags;\n\n\tstatus = i40e_asq_send_command(hw, &desc, buff, buff_size, cmd_details);\n\n\treturn status;\n}\n\n \nstruct i40e_generic_seg_header *\ni40e_find_segment_in_package(u32 segment_type,\n\t\t\t     struct i40e_package_header *pkg_hdr)\n{\n\tstruct i40e_generic_seg_header *segment;\n\tu32 i;\n\n\t \n\tfor (i = 0; i < pkg_hdr->segment_count; i++) {\n\t\tsegment =\n\t\t\t(struct i40e_generic_seg_header *)((u8 *)pkg_hdr +\n\t\t\t pkg_hdr->segment_offset[i]);\n\n\t\tif (segment->type == segment_type)\n\t\t\treturn segment;\n\t}\n\n\treturn NULL;\n}\n\n \n#define I40E_SECTION_TABLE(profile, sec_tbl)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct i40e_profile_segment *p = (profile);\t\t\\\n\t\tu32 count;\t\t\t\t\t\t\\\n\t\tu32 *nvm;\t\t\t\t\t\t\\\n\t\tcount = p->device_table_count;\t\t\t\t\\\n\t\tnvm = (u32 *)&p->device_table[count];\t\t\t\\\n\t\tsec_tbl = (struct i40e_section_table *)&nvm[nvm[0] + 1]; \\\n\t} while (0)\n\n \n#define I40E_SECTION_HEADER(profile, offset)\t\t\t\t\\\n\t(struct i40e_profile_section_header *)((u8 *)(profile) + (offset))\n\n \nstruct i40e_profile_section_header *\ni40e_find_section_in_profile(u32 section_type,\n\t\t\t     struct i40e_profile_segment *profile)\n{\n\tstruct i40e_profile_section_header *sec;\n\tstruct i40e_section_table *sec_tbl;\n\tu32 sec_off;\n\tu32 i;\n\n\tif (profile->header.type != SEGMENT_TYPE_I40E)\n\t\treturn NULL;\n\n\tI40E_SECTION_TABLE(profile, sec_tbl);\n\n\tfor (i = 0; i < sec_tbl->section_count; i++) {\n\t\tsec_off = sec_tbl->section_offset[i];\n\t\tsec = I40E_SECTION_HEADER(profile, sec_off);\n\t\tif (sec->section.type == section_type)\n\t\t\treturn sec;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int i40e_ddp_exec_aq_section(struct i40e_hw *hw,\n\t\t\t\t    struct i40e_profile_aq_section *aq)\n{\n\tstruct i40e_aq_desc desc;\n\tu8 *msg = NULL;\n\tu16 msglen;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc, aq->opcode);\n\tdesc.flags |= cpu_to_le16(aq->flags);\n\tmemcpy(desc.params.raw, aq->param, sizeof(desc.params.raw));\n\n\tmsglen = aq->datalen;\n\tif (msglen) {\n\t\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF |\n\t\t\t\t\t\tI40E_AQ_FLAG_RD));\n\t\tif (msglen > I40E_AQ_LARGE_BUF)\n\t\t\tdesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\n\t\tdesc.datalen = cpu_to_le16(msglen);\n\t\tmsg = &aq->data[0];\n\t}\n\n\tstatus = i40e_asq_send_command(hw, &desc, msg, msglen, NULL);\n\n\tif (status) {\n\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE,\n\t\t\t   \"unable to exec DDP AQ opcode %u, error %d\\n\",\n\t\t\t   aq->opcode, status);\n\t\treturn status;\n\t}\n\n\t \n\tmemcpy(aq->param, desc.params.raw, sizeof(desc.params.raw));\n\n\treturn 0;\n}\n\n \nstatic int\ni40e_validate_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile,\n\t\t      u32 track_id, bool rollback)\n{\n\tstruct i40e_profile_section_header *sec = NULL;\n\tstruct i40e_section_table *sec_tbl;\n\tu32 vendor_dev_id;\n\tint status = 0;\n\tu32 dev_cnt;\n\tu32 sec_off;\n\tu32 i;\n\n\tif (track_id == I40E_DDP_TRACKID_INVALID) {\n\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE, \"Invalid track_id\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev_cnt = profile->device_table_count;\n\tfor (i = 0; i < dev_cnt; i++) {\n\t\tvendor_dev_id = profile->device_table[i].vendor_dev_id;\n\t\tif ((vendor_dev_id >> 16) == PCI_VENDOR_ID_INTEL &&\n\t\t    hw->device_id == (vendor_dev_id & 0xFFFF))\n\t\t\tbreak;\n\t}\n\tif (dev_cnt && i == dev_cnt) {\n\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE,\n\t\t\t   \"Device doesn't support DDP\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tI40E_SECTION_TABLE(profile, sec_tbl);\n\n\t \n\tfor (i = 0; i < sec_tbl->section_count; i++) {\n\t\tsec_off = sec_tbl->section_offset[i];\n\t\tsec = I40E_SECTION_HEADER(profile, sec_off);\n\t\tif (rollback) {\n\t\t\tif (sec->section.type == SECTION_TYPE_MMIO ||\n\t\t\t    sec->section.type == SECTION_TYPE_AQ ||\n\t\t\t    sec->section.type == SECTION_TYPE_RB_AQ) {\n\t\t\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE,\n\t\t\t\t\t   \"Not a roll-back package\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sec->section.type == SECTION_TYPE_RB_AQ ||\n\t\t\t    sec->section.type == SECTION_TYPE_RB_MMIO) {\n\t\t\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE,\n\t\t\t\t\t   \"Not an original package\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nint\ni40e_write_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile,\n\t\t   u32 track_id)\n{\n\tstruct i40e_profile_section_header *sec = NULL;\n\tstruct i40e_profile_aq_section *ddp_aq;\n\tstruct i40e_section_table *sec_tbl;\n\tu32 offset = 0, info = 0;\n\tu32 section_size = 0;\n\tint status = 0;\n\tu32 sec_off;\n\tu32 i;\n\n\tstatus = i40e_validate_profile(hw, profile, track_id, false);\n\tif (status)\n\t\treturn status;\n\n\tI40E_SECTION_TABLE(profile, sec_tbl);\n\n\tfor (i = 0; i < sec_tbl->section_count; i++) {\n\t\tsec_off = sec_tbl->section_offset[i];\n\t\tsec = I40E_SECTION_HEADER(profile, sec_off);\n\t\t \n\t\tif (sec->section.type == SECTION_TYPE_AQ) {\n\t\t\tddp_aq = (struct i40e_profile_aq_section *)&sec[1];\n\t\t\tstatus = i40e_ddp_exec_aq_section(hw, ddp_aq);\n\t\t\tif (status) {\n\t\t\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE,\n\t\t\t\t\t   \"Failed to execute aq: section %d, opcode %u\\n\",\n\t\t\t\t\t   i, ddp_aq->opcode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsec->section.type = SECTION_TYPE_RB_AQ;\n\t\t}\n\n\t\t \n\t\tif (sec->section.type != SECTION_TYPE_MMIO)\n\t\t\tcontinue;\n\n\t\tsection_size = sec->section.size +\n\t\t\tsizeof(struct i40e_profile_section_header);\n\n\t\t \n\t\tstatus = i40e_aq_write_ddp(hw, (void *)sec, (u16)section_size,\n\t\t\t\t\t   track_id, &offset, &info, NULL);\n\t\tif (status) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE,\n\t\t\t\t   \"Failed to write profile: section %d, offset %d, info %d\\n\",\n\t\t\t\t   i, offset, info);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn status;\n}\n\n \nint\ni40e_rollback_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile,\n\t\t      u32 track_id)\n{\n\tstruct i40e_profile_section_header *sec = NULL;\n\tstruct i40e_section_table *sec_tbl;\n\tu32 offset = 0, info = 0;\n\tu32 section_size = 0;\n\tint status = 0;\n\tu32 sec_off;\n\tint i;\n\n\tstatus = i40e_validate_profile(hw, profile, track_id, true);\n\tif (status)\n\t\treturn status;\n\n\tI40E_SECTION_TABLE(profile, sec_tbl);\n\n\t \n\tfor (i = sec_tbl->section_count - 1; i >= 0; i--) {\n\t\tsec_off = sec_tbl->section_offset[i];\n\t\tsec = I40E_SECTION_HEADER(profile, sec_off);\n\n\t\t \n\t\tif (sec->section.type != SECTION_TYPE_RB_MMIO)\n\t\t\tcontinue;\n\n\t\tsection_size = sec->section.size +\n\t\t\tsizeof(struct i40e_profile_section_header);\n\n\t\t \n\t\tstatus = i40e_aq_write_ddp(hw, (void *)sec, (u16)section_size,\n\t\t\t\t\t   track_id, &offset, &info, NULL);\n\t\tif (status) {\n\t\t\ti40e_debug(hw, I40E_DEBUG_PACKAGE,\n\t\t\t\t   \"Failed to write profile: section %d, offset %d, info %d\\n\",\n\t\t\t\t   i, offset, info);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn status;\n}\n\n \nint\ni40e_add_pinfo_to_list(struct i40e_hw *hw,\n\t\t       struct i40e_profile_segment *profile,\n\t\t       u8 *profile_info_sec, u32 track_id)\n{\n\tstruct i40e_profile_section_header *sec = NULL;\n\tstruct i40e_profile_info *pinfo;\n\tu32 offset = 0, info = 0;\n\tint status = 0;\n\n\tsec = (struct i40e_profile_section_header *)profile_info_sec;\n\tsec->tbl_size = 1;\n\tsec->data_end = sizeof(struct i40e_profile_section_header) +\n\t\t\tsizeof(struct i40e_profile_info);\n\tsec->section.type = SECTION_TYPE_INFO;\n\tsec->section.offset = sizeof(struct i40e_profile_section_header);\n\tsec->section.size = sizeof(struct i40e_profile_info);\n\tpinfo = (struct i40e_profile_info *)(profile_info_sec +\n\t\t\t\t\t     sec->section.offset);\n\tpinfo->track_id = track_id;\n\tpinfo->version = profile->version;\n\tpinfo->op = I40E_DDP_ADD_TRACKID;\n\tmemcpy(pinfo->name, profile->name, I40E_DDP_NAME_SIZE);\n\n\tstatus = i40e_aq_write_ddp(hw, (void *)sec, sec->data_end,\n\t\t\t\t   track_id, &offset, &info, NULL);\n\n\treturn status;\n}\n\n \nint\ni40e_aq_add_cloud_filters(struct i40e_hw *hw, u16 seid,\n\t\t\t  struct i40e_aqc_cloud_filters_element_data *filters,\n\t\t\t  u8 filter_count)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_remove_cloud_filters *cmd =\n\t(struct i40e_aqc_add_remove_cloud_filters *)&desc.params.raw;\n\tu16 buff_len;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_add_cloud_filters);\n\n\tbuff_len = filter_count * sizeof(*filters);\n\tdesc.datalen = cpu_to_le16(buff_len);\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tcmd->num_filters = filter_count;\n\tcmd->seid = cpu_to_le16(seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, filters, buff_len, NULL);\n\n\treturn status;\n}\n\n \nint\ni40e_aq_add_cloud_filters_bb(struct i40e_hw *hw, u16 seid,\n\t\t\t     struct i40e_aqc_cloud_filters_element_bb *filters,\n\t\t\t     u8 filter_count)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_remove_cloud_filters *cmd =\n\t(struct i40e_aqc_add_remove_cloud_filters *)&desc.params.raw;\n\tu16 buff_len;\n\tint status;\n\tint i;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_add_cloud_filters);\n\n\tbuff_len = filter_count * sizeof(*filters);\n\tdesc.datalen = cpu_to_le16(buff_len);\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tcmd->num_filters = filter_count;\n\tcmd->seid = cpu_to_le16(seid);\n\tcmd->big_buffer_flag = I40E_AQC_ADD_CLOUD_CMD_BB;\n\n\tfor (i = 0; i < filter_count; i++) {\n\t\tu16 tnl_type;\n\t\tu32 ti;\n\n\t\ttnl_type = (le16_to_cpu(filters[i].element.flags) &\n\t\t\t   I40E_AQC_ADD_CLOUD_TNL_TYPE_MASK) >>\n\t\t\t   I40E_AQC_ADD_CLOUD_TNL_TYPE_SHIFT;\n\n\t\t \n\t\tif (tnl_type == I40E_AQC_ADD_CLOUD_TNL_TYPE_GENEVE) {\n\t\t\tti = le32_to_cpu(filters[i].element.tenant_id);\n\t\t\tfilters[i].element.tenant_id = cpu_to_le32(ti << 8);\n\t\t}\n\t}\n\n\tstatus = i40e_asq_send_command(hw, &desc, filters, buff_len, NULL);\n\n\treturn status;\n}\n\n \nint\ni40e_aq_rem_cloud_filters(struct i40e_hw *hw, u16 seid,\n\t\t\t  struct i40e_aqc_cloud_filters_element_data *filters,\n\t\t\t  u8 filter_count)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_remove_cloud_filters *cmd =\n\t(struct i40e_aqc_add_remove_cloud_filters *)&desc.params.raw;\n\tu16 buff_len;\n\tint status;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_remove_cloud_filters);\n\n\tbuff_len = filter_count * sizeof(*filters);\n\tdesc.datalen = cpu_to_le16(buff_len);\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tcmd->num_filters = filter_count;\n\tcmd->seid = cpu_to_le16(seid);\n\n\tstatus = i40e_asq_send_command(hw, &desc, filters, buff_len, NULL);\n\n\treturn status;\n}\n\n \nint\ni40e_aq_rem_cloud_filters_bb(struct i40e_hw *hw, u16 seid,\n\t\t\t     struct i40e_aqc_cloud_filters_element_bb *filters,\n\t\t\t     u8 filter_count)\n{\n\tstruct i40e_aq_desc desc;\n\tstruct i40e_aqc_add_remove_cloud_filters *cmd =\n\t(struct i40e_aqc_add_remove_cloud_filters *)&desc.params.raw;\n\tu16 buff_len;\n\tint status;\n\tint i;\n\n\ti40e_fill_default_direct_cmd_desc(&desc,\n\t\t\t\t\t  i40e_aqc_opc_remove_cloud_filters);\n\n\tbuff_len = filter_count * sizeof(*filters);\n\tdesc.datalen = cpu_to_le16(buff_len);\n\tdesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD));\n\tcmd->num_filters = filter_count;\n\tcmd->seid = cpu_to_le16(seid);\n\tcmd->big_buffer_flag = I40E_AQC_ADD_CLOUD_CMD_BB;\n\n\tfor (i = 0; i < filter_count; i++) {\n\t\tu16 tnl_type;\n\t\tu32 ti;\n\n\t\ttnl_type = (le16_to_cpu(filters[i].element.flags) &\n\t\t\t   I40E_AQC_ADD_CLOUD_TNL_TYPE_MASK) >>\n\t\t\t   I40E_AQC_ADD_CLOUD_TNL_TYPE_SHIFT;\n\n\t\t \n\t\tif (tnl_type == I40E_AQC_ADD_CLOUD_TNL_TYPE_GENEVE) {\n\t\t\tti = le32_to_cpu(filters[i].element.tenant_id);\n\t\t\tfilters[i].element.tenant_id = cpu_to_le32(ti << 8);\n\t\t}\n\t}\n\n\tstatus = i40e_asq_send_command(hw, &desc, filters, buff_len, NULL);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}