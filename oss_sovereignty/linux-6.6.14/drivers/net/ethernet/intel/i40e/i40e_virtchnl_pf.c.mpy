{
  "module_name": "i40e_virtchnl_pf.c",
  "hash_id": "85b2eb2a054a93141119d569075b4d4715b4d7b5fef562923678de8873d0aeaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c",
  "human_readable_source": "\n \n\n#include \"i40e.h\"\n\n \n\n \nstatic void i40e_vc_vf_broadcast(struct i40e_pf *pf,\n\t\t\t\t enum virtchnl_ops v_opcode,\n\t\t\t\t int v_retval, u8 *msg,\n\t\t\t\t u16 msglen)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vf *vf = pf->vf;\n\tint i;\n\n\tfor (i = 0; i < pf->num_alloc_vfs; i++, vf++) {\n\t\tint abs_vf_id = vf->vf_id + (int)hw->func_caps.vf_base_id;\n\t\t \n\t\tif (!test_bit(I40E_VF_STATE_INIT, &vf->vf_states) &&\n\t\t    !test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states))\n\t\t\tcontinue;\n\n\t\t \n\t\ti40e_aq_send_msg_to_vf(hw, abs_vf_id, v_opcode, v_retval,\n\t\t\t\t       msg, msglen, NULL);\n\t}\n}\n\n \nstatic u32\ni40e_vc_link_speed2mbps(enum i40e_aq_link_speed link_speed)\n{\n\tswitch (link_speed) {\n\tcase I40E_LINK_SPEED_100MB:\n\t\treturn SPEED_100;\n\tcase I40E_LINK_SPEED_1GB:\n\t\treturn SPEED_1000;\n\tcase I40E_LINK_SPEED_2_5GB:\n\t\treturn SPEED_2500;\n\tcase I40E_LINK_SPEED_5GB:\n\t\treturn SPEED_5000;\n\tcase I40E_LINK_SPEED_10GB:\n\t\treturn SPEED_10000;\n\tcase I40E_LINK_SPEED_20GB:\n\t\treturn SPEED_20000;\n\tcase I40E_LINK_SPEED_25GB:\n\t\treturn SPEED_25000;\n\tcase I40E_LINK_SPEED_40GB:\n\t\treturn SPEED_40000;\n\tcase I40E_LINK_SPEED_UNKNOWN:\n\t\treturn SPEED_UNKNOWN;\n\t}\n\treturn SPEED_UNKNOWN;\n}\n\n \nstatic void i40e_set_vf_link_state(struct i40e_vf *vf,\n\t\t\t\t   struct virtchnl_pf_event *pfe, struct i40e_link_status *ls)\n{\n\tu8 link_status = ls->link_info & I40E_AQ_LINK_UP;\n\n\tif (vf->link_forced)\n\t\tlink_status = vf->link_up;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_CAP_ADV_LINK_SPEED) {\n\t\tpfe->event_data.link_event_adv.link_speed = link_status ?\n\t\t\ti40e_vc_link_speed2mbps(ls->link_speed) : 0;\n\t\tpfe->event_data.link_event_adv.link_status = link_status;\n\t} else {\n\t\tpfe->event_data.link_event.link_speed = link_status ?\n\t\t\ti40e_virtchnl_link_speed(ls->link_speed) : 0;\n\t\tpfe->event_data.link_event.link_status = link_status;\n\t}\n}\n\n \nstatic void i40e_vc_notify_vf_link_state(struct i40e_vf *vf)\n{\n\tstruct virtchnl_pf_event pfe;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_link_status *ls = &pf->hw.phy.link_info;\n\tint abs_vf_id = vf->vf_id + (int)hw->func_caps.vf_base_id;\n\n\tpfe.event = VIRTCHNL_EVENT_LINK_CHANGE;\n\tpfe.severity = PF_EVENT_SEVERITY_INFO;\n\n\ti40e_set_vf_link_state(vf, &pfe, ls);\n\n\ti40e_aq_send_msg_to_vf(hw, abs_vf_id, VIRTCHNL_OP_EVENT,\n\t\t\t       0, (u8 *)&pfe, sizeof(pfe), NULL);\n}\n\n \nvoid i40e_vc_notify_link_state(struct i40e_pf *pf)\n{\n\tint i;\n\n\tfor (i = 0; i < pf->num_alloc_vfs; i++)\n\t\ti40e_vc_notify_vf_link_state(&pf->vf[i]);\n}\n\n \nvoid i40e_vc_notify_reset(struct i40e_pf *pf)\n{\n\tstruct virtchnl_pf_event pfe;\n\n\tpfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;\n\tpfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;\n\ti40e_vc_vf_broadcast(pf, VIRTCHNL_OP_EVENT, 0,\n\t\t\t     (u8 *)&pfe, sizeof(struct virtchnl_pf_event));\n}\n\n#ifdef CONFIG_PCI_IOV\nvoid i40e_restore_all_vfs_msi_state(struct pci_dev *pdev)\n{\n\tu16 vf_id;\n\tu16 pos;\n\n\t \n\tif (!pdev->is_physfn)\n\t\treturn;\n\n\tif (!pci_num_vf(pdev))\n\t\treturn;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\tif (pos) {\n\t\tstruct pci_dev *vf_dev = NULL;\n\n\t\tpci_read_config_word(pdev, pos + PCI_SRIOV_VF_DID, &vf_id);\n\t\twhile ((vf_dev = pci_get_device(pdev->vendor, vf_id, vf_dev))) {\n\t\t\tif (vf_dev->is_virtfn && vf_dev->physfn == pdev)\n\t\t\t\tpci_restore_msi_state(vf_dev);\n\t\t}\n\t}\n}\n#endif  \n\n \nvoid i40e_vc_notify_vf_reset(struct i40e_vf *vf)\n{\n\tstruct virtchnl_pf_event pfe;\n\tint abs_vf_id;\n\n\t \n\tif (!vf || vf->vf_id >= vf->pf->num_alloc_vfs)\n\t\treturn;\n\n\t \n\tif (!test_bit(I40E_VF_STATE_INIT, &vf->vf_states) &&\n\t    !test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states))\n\t\treturn;\n\n\tabs_vf_id = vf->vf_id + (int)vf->pf->hw.func_caps.vf_base_id;\n\n\tpfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;\n\tpfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;\n\ti40e_aq_send_msg_to_vf(&vf->pf->hw, abs_vf_id, VIRTCHNL_OP_EVENT,\n\t\t\t       0, (u8 *)&pfe,\n\t\t\t       sizeof(struct virtchnl_pf_event), NULL);\n}\n \n\n \nstatic void i40e_vc_reset_vf(struct i40e_vf *vf, bool notify_vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tint i;\n\n\tif (notify_vf)\n\t\ti40e_vc_notify_vf_reset(vf);\n\n\t \n\tfor (i = 0; i < 20; i++) {\n\t\t \n\t\tif (test_bit(__I40E_VFS_RELEASING, pf->state))\n\t\t\treturn;\n\t\tif (i40e_reset_vf(vf, false))\n\t\t\treturn;\n\t\tusleep_range(10000, 20000);\n\t}\n\n\tif (notify_vf)\n\t\tdev_warn(&vf->pf->pdev->dev,\n\t\t\t \"Failed to initiate reset for VF %d after 200 milliseconds\\n\",\n\t\t\t vf->vf_id);\n\telse\n\t\tdev_dbg(&vf->pf->pdev->dev,\n\t\t\t\"Failed to initiate reset for VF %d after 200 milliseconds\\n\",\n\t\t\tvf->vf_id);\n}\n\n \nstatic inline bool i40e_vc_isvalid_vsi_id(struct i40e_vf *vf, u16 vsi_id)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = i40e_find_vsi_from_id(pf, vsi_id);\n\n\treturn (vsi && (vsi->vf_id == vf->vf_id));\n}\n\n \nstatic inline bool i40e_vc_isvalid_queue_id(struct i40e_vf *vf, u16 vsi_id,\n\t\t\t\t\t    u16 qid)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = i40e_find_vsi_from_id(pf, vsi_id);\n\n\treturn (vsi && (qid < vsi->alloc_queue_pairs));\n}\n\n \nstatic inline bool i40e_vc_isvalid_vector_id(struct i40e_vf *vf, u32 vector_id)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\n\treturn vector_id < pf->hw.func_caps.num_msix_vectors_vf;\n}\n\n \n\n \nstatic u16 i40e_vc_get_pf_queue_id(struct i40e_vf *vf, u16 vsi_id,\n\t\t\t\t   u8 vsi_queue_id)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = i40e_find_vsi_from_id(pf, vsi_id);\n\tu16 pf_queue_id = I40E_QUEUE_END_OF_LIST;\n\n\tif (!vsi)\n\t\treturn pf_queue_id;\n\n\tif (le16_to_cpu(vsi->info.mapping_flags) &\n\t    I40E_AQ_VSI_QUE_MAP_NONCONTIG)\n\t\tpf_queue_id =\n\t\t\tle16_to_cpu(vsi->info.queue_mapping[vsi_queue_id]);\n\telse\n\t\tpf_queue_id = le16_to_cpu(vsi->info.queue_mapping[0]) +\n\t\t\t      vsi_queue_id;\n\n\treturn pf_queue_id;\n}\n\n \nstatic u16 i40e_get_real_pf_qid(struct i40e_vf *vf, u16 vsi_id, u16 queue_id)\n{\n\tint i;\n\n\tif (vf->adq_enabled) {\n\t\t \n\t\tfor (i = 0; i < vf->num_tc; i++) {\n\t\t\tif (queue_id < vf->ch[i].num_qps) {\n\t\t\t\tvsi_id = vf->ch[i].vsi_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tqueue_id -= vf->ch[i].num_qps;\n\t\t\t}\n\t\t}\n\n\treturn i40e_vc_get_pf_queue_id(vf, vsi_id, queue_id);\n}\n\n \nstatic void i40e_config_irq_link_list(struct i40e_vf *vf, u16 vsi_id,\n\t\t\t\t      struct virtchnl_vector_map *vecmap)\n{\n\tunsigned long linklistmap = 0, tempmap;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 vsi_queue_id, pf_queue_id;\n\tenum i40e_queue_type qtype;\n\tu16 next_q, vector_id, size;\n\tu32 reg, reg_idx;\n\tu16 itr_idx = 0;\n\n\tvector_id = vecmap->vector_id;\n\t \n\tif (0 == vector_id)\n\t\treg_idx = I40E_VPINT_LNKLST0(vf->vf_id);\n\telse\n\t\treg_idx = I40E_VPINT_LNKLSTN(\n\t\t     ((pf->hw.func_caps.num_msix_vectors_vf - 1) * vf->vf_id) +\n\t\t     (vector_id - 1));\n\n\tif (vecmap->rxq_map == 0 && vecmap->txq_map == 0) {\n\t\t \n\t\twr32(hw, reg_idx, I40E_VPINT_LNKLST0_FIRSTQ_INDX_MASK);\n\t\tgoto irq_list_done;\n\t}\n\ttempmap = vecmap->rxq_map;\n\tfor_each_set_bit(vsi_queue_id, &tempmap, I40E_MAX_VSI_QP) {\n\t\tlinklistmap |= (BIT(I40E_VIRTCHNL_SUPPORTED_QTYPES *\n\t\t\t\t    vsi_queue_id));\n\t}\n\n\ttempmap = vecmap->txq_map;\n\tfor_each_set_bit(vsi_queue_id, &tempmap, I40E_MAX_VSI_QP) {\n\t\tlinklistmap |= (BIT(I40E_VIRTCHNL_SUPPORTED_QTYPES *\n\t\t\t\t     vsi_queue_id + 1));\n\t}\n\n\tsize = I40E_MAX_VSI_QP * I40E_VIRTCHNL_SUPPORTED_QTYPES;\n\tnext_q = find_first_bit(&linklistmap, size);\n\tif (unlikely(next_q == size))\n\t\tgoto irq_list_done;\n\n\tvsi_queue_id = next_q / I40E_VIRTCHNL_SUPPORTED_QTYPES;\n\tqtype = next_q % I40E_VIRTCHNL_SUPPORTED_QTYPES;\n\tpf_queue_id = i40e_get_real_pf_qid(vf, vsi_id, vsi_queue_id);\n\treg = ((qtype << I40E_VPINT_LNKLSTN_FIRSTQ_TYPE_SHIFT) | pf_queue_id);\n\n\twr32(hw, reg_idx, reg);\n\n\twhile (next_q < size) {\n\t\tswitch (qtype) {\n\t\tcase I40E_QUEUE_TYPE_RX:\n\t\t\treg_idx = I40E_QINT_RQCTL(pf_queue_id);\n\t\t\titr_idx = vecmap->rxitr_idx;\n\t\t\tbreak;\n\t\tcase I40E_QUEUE_TYPE_TX:\n\t\t\treg_idx = I40E_QINT_TQCTL(pf_queue_id);\n\t\t\titr_idx = vecmap->txitr_idx;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_q = find_next_bit(&linklistmap, size, next_q + 1);\n\t\tif (next_q < size) {\n\t\t\tvsi_queue_id = next_q / I40E_VIRTCHNL_SUPPORTED_QTYPES;\n\t\t\tqtype = next_q % I40E_VIRTCHNL_SUPPORTED_QTYPES;\n\t\t\tpf_queue_id = i40e_get_real_pf_qid(vf,\n\t\t\t\t\t\t\t   vsi_id,\n\t\t\t\t\t\t\t   vsi_queue_id);\n\t\t} else {\n\t\t\tpf_queue_id = I40E_QUEUE_END_OF_LIST;\n\t\t\tqtype = 0;\n\t\t}\n\n\t\t \n\t\treg = (vector_id) |\n\t\t    (qtype << I40E_QINT_RQCTL_NEXTQ_TYPE_SHIFT) |\n\t\t    (pf_queue_id << I40E_QINT_RQCTL_NEXTQ_INDX_SHIFT) |\n\t\t    BIT(I40E_QINT_RQCTL_CAUSE_ENA_SHIFT) |\n\t\t    (itr_idx << I40E_QINT_RQCTL_ITR_INDX_SHIFT);\n\t\twr32(hw, reg_idx, reg);\n\t}\n\n\t \n\tif ((vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_POLLING) &&\n\t    (vector_id == 0)) {\n\t\treg = rd32(hw, I40E_GLINT_CTL);\n\t\tif (!(reg & I40E_GLINT_CTL_DIS_AUTOMASK_VF0_MASK)) {\n\t\t\treg |= I40E_GLINT_CTL_DIS_AUTOMASK_VF0_MASK;\n\t\t\twr32(hw, I40E_GLINT_CTL, reg);\n\t\t}\n\t}\n\nirq_list_done:\n\ti40e_flush(hw);\n}\n\n \nstatic void i40e_release_rdma_qvlist(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct virtchnl_rdma_qvlist_info *qvlist_info = vf->qvlist_info;\n\tu32 msix_vf;\n\tu32 i;\n\n\tif (!vf->qvlist_info)\n\t\treturn;\n\n\tmsix_vf = pf->hw.func_caps.num_msix_vectors_vf;\n\tfor (i = 0; i < qvlist_info->num_vectors; i++) {\n\t\tstruct virtchnl_rdma_qv_info *qv_info;\n\t\tu32 next_q_index, next_q_type;\n\t\tstruct i40e_hw *hw = &pf->hw;\n\t\tu32 v_idx, reg_idx, reg;\n\n\t\tqv_info = &qvlist_info->qv_info[i];\n\t\tif (!qv_info)\n\t\t\tcontinue;\n\t\tv_idx = qv_info->v_idx;\n\t\tif (qv_info->ceq_idx != I40E_QUEUE_INVALID_IDX) {\n\t\t\t \n\t\t\treg_idx = (msix_vf - 1) * vf->vf_id + qv_info->ceq_idx;\n\t\t\treg = rd32(hw, I40E_VPINT_CEQCTL(reg_idx));\n\t\t\tnext_q_index = (reg & I40E_VPINT_CEQCTL_NEXTQ_INDX_MASK)\n\t\t\t\t\t>> I40E_VPINT_CEQCTL_NEXTQ_INDX_SHIFT;\n\t\t\tnext_q_type = (reg & I40E_VPINT_CEQCTL_NEXTQ_TYPE_MASK)\n\t\t\t\t\t>> I40E_VPINT_CEQCTL_NEXTQ_TYPE_SHIFT;\n\n\t\t\treg_idx = ((msix_vf - 1) * vf->vf_id) + (v_idx - 1);\n\t\t\treg = (next_q_index &\n\t\t\t       I40E_VPINT_LNKLSTN_FIRSTQ_INDX_MASK) |\n\t\t\t       (next_q_type <<\n\t\t\t       I40E_VPINT_LNKLSTN_FIRSTQ_TYPE_SHIFT);\n\n\t\t\twr32(hw, I40E_VPINT_LNKLSTN(reg_idx), reg);\n\t\t}\n\t}\n\tkfree(vf->qvlist_info);\n\tvf->qvlist_info = NULL;\n}\n\n \nstatic int\ni40e_config_rdma_qvlist(struct i40e_vf *vf,\n\t\t\tstruct virtchnl_rdma_qvlist_info *qvlist_info)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct virtchnl_rdma_qv_info *qv_info;\n\tu32 v_idx, i, reg_idx, reg;\n\tu32 next_q_idx, next_q_type;\n\tsize_t size;\n\tu32 msix_vf;\n\tint ret = 0;\n\n\tmsix_vf = pf->hw.func_caps.num_msix_vectors_vf;\n\n\tif (qvlist_info->num_vectors > msix_vf) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Incorrect number of iwarp vectors %u. Maximum %u allowed.\\n\",\n\t\t\t qvlist_info->num_vectors,\n\t\t\t msix_vf);\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tkfree(vf->qvlist_info);\n\tsize = virtchnl_struct_size(vf->qvlist_info, qv_info,\n\t\t\t\t    qvlist_info->num_vectors);\n\tvf->qvlist_info = kzalloc(size, GFP_KERNEL);\n\tif (!vf->qvlist_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tvf->qvlist_info->num_vectors = qvlist_info->num_vectors;\n\n\tmsix_vf = pf->hw.func_caps.num_msix_vectors_vf;\n\tfor (i = 0; i < qvlist_info->num_vectors; i++) {\n\t\tqv_info = &qvlist_info->qv_info[i];\n\t\tif (!qv_info)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!i40e_vc_isvalid_vector_id(vf, qv_info->v_idx)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tv_idx = qv_info->v_idx;\n\n\t\tvf->qvlist_info->qv_info[i] = *qv_info;\n\n\t\treg_idx = ((msix_vf - 1) * vf->vf_id) + (v_idx - 1);\n\t\t \n\t\treg = rd32(hw, I40E_VPINT_LNKLSTN(reg_idx));\n\t\tnext_q_idx = ((reg & I40E_VPINT_LNKLSTN_FIRSTQ_INDX_MASK) >>\n\t\t\t\tI40E_VPINT_LNKLSTN_FIRSTQ_INDX_SHIFT);\n\t\tnext_q_type = ((reg & I40E_VPINT_LNKLSTN_FIRSTQ_TYPE_MASK) >>\n\t\t\t\tI40E_VPINT_LNKLSTN_FIRSTQ_TYPE_SHIFT);\n\n\t\tif (qv_info->ceq_idx != I40E_QUEUE_INVALID_IDX) {\n\t\t\treg_idx = (msix_vf - 1) * vf->vf_id + qv_info->ceq_idx;\n\t\t\treg = (I40E_VPINT_CEQCTL_CAUSE_ENA_MASK |\n\t\t\t(v_idx << I40E_VPINT_CEQCTL_MSIX_INDX_SHIFT) |\n\t\t\t(qv_info->itr_idx << I40E_VPINT_CEQCTL_ITR_INDX_SHIFT) |\n\t\t\t(next_q_type << I40E_VPINT_CEQCTL_NEXTQ_TYPE_SHIFT) |\n\t\t\t(next_q_idx << I40E_VPINT_CEQCTL_NEXTQ_INDX_SHIFT));\n\t\t\twr32(hw, I40E_VPINT_CEQCTL(reg_idx), reg);\n\n\t\t\treg_idx = ((msix_vf - 1) * vf->vf_id) + (v_idx - 1);\n\t\t\treg = (qv_info->ceq_idx &\n\t\t\t       I40E_VPINT_LNKLSTN_FIRSTQ_INDX_MASK) |\n\t\t\t       (I40E_QUEUE_TYPE_PE_CEQ <<\n\t\t\t       I40E_VPINT_LNKLSTN_FIRSTQ_TYPE_SHIFT);\n\t\t\twr32(hw, I40E_VPINT_LNKLSTN(reg_idx), reg);\n\t\t}\n\n\t\tif (qv_info->aeq_idx != I40E_QUEUE_INVALID_IDX) {\n\t\t\treg = (I40E_VPINT_AEQCTL_CAUSE_ENA_MASK |\n\t\t\t(v_idx << I40E_VPINT_AEQCTL_MSIX_INDX_SHIFT) |\n\t\t\t(qv_info->itr_idx << I40E_VPINT_AEQCTL_ITR_INDX_SHIFT));\n\n\t\t\twr32(hw, I40E_VPINT_AEQCTL(vf->vf_id), reg);\n\t\t}\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(vf->qvlist_info);\n\tvf->qvlist_info = NULL;\nerr_out:\n\treturn ret;\n}\n\n \nstatic int i40e_config_vsi_tx_queue(struct i40e_vf *vf, u16 vsi_id,\n\t\t\t\t    u16 vsi_queue_id,\n\t\t\t\t    struct virtchnl_txq_info *info)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_hmc_obj_txq tx_ctx;\n\tstruct i40e_vsi *vsi;\n\tu16 pf_queue_id;\n\tu32 qtx_ctl;\n\tint ret = 0;\n\n\tif (!i40e_vc_isvalid_vsi_id(vf, info->vsi_id)) {\n\t\tret = -ENOENT;\n\t\tgoto error_context;\n\t}\n\tpf_queue_id = i40e_vc_get_pf_queue_id(vf, vsi_id, vsi_queue_id);\n\tvsi = i40e_find_vsi_from_id(pf, vsi_id);\n\tif (!vsi) {\n\t\tret = -ENOENT;\n\t\tgoto error_context;\n\t}\n\n\t \n\tmemset(&tx_ctx, 0, sizeof(struct i40e_hmc_obj_txq));\n\n\t \n\ttx_ctx.base = info->dma_ring_addr / 128;\n\ttx_ctx.qlen = info->ring_len;\n\ttx_ctx.rdylist = le16_to_cpu(vsi->info.qs_handle[0]);\n\ttx_ctx.rdylist_act = 0;\n\ttx_ctx.head_wb_ena = info->headwb_enabled;\n\ttx_ctx.head_wb_addr = info->dma_headwb_addr;\n\n\t \n\tret = i40e_clear_lan_tx_queue_context(hw, pf_queue_id);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to clear VF LAN Tx queue context %d, error: %d\\n\",\n\t\t\tpf_queue_id, ret);\n\t\tret = -ENOENT;\n\t\tgoto error_context;\n\t}\n\n\t \n\tret = i40e_set_lan_tx_queue_context(hw, pf_queue_id, &tx_ctx);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to set VF LAN Tx queue context %d error: %d\\n\",\n\t\t\tpf_queue_id, ret);\n\t\tret = -ENOENT;\n\t\tgoto error_context;\n\t}\n\n\t \n\tqtx_ctl = I40E_QTX_CTL_VF_QUEUE;\n\tqtx_ctl |= ((hw->pf_id << I40E_QTX_CTL_PF_INDX_SHIFT)\n\t\t    & I40E_QTX_CTL_PF_INDX_MASK);\n\tqtx_ctl |= (((vf->vf_id + hw->func_caps.vf_base_id)\n\t\t     << I40E_QTX_CTL_VFVM_INDX_SHIFT)\n\t\t    & I40E_QTX_CTL_VFVM_INDX_MASK);\n\twr32(hw, I40E_QTX_CTL(pf_queue_id), qtx_ctl);\n\ti40e_flush(hw);\n\nerror_context:\n\treturn ret;\n}\n\n \nstatic int i40e_config_vsi_rx_queue(struct i40e_vf *vf, u16 vsi_id,\n\t\t\t\t    u16 vsi_queue_id,\n\t\t\t\t    struct virtchnl_rxq_info *info)\n{\n\tu16 pf_queue_id = i40e_vc_get_pf_queue_id(vf, vsi_id, vsi_queue_id);\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = pf->vsi[vf->lan_vsi_idx];\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_hmc_obj_rxq rx_ctx;\n\tint ret = 0;\n\n\t \n\tmemset(&rx_ctx, 0, sizeof(struct i40e_hmc_obj_rxq));\n\n\t \n\trx_ctx.base = info->dma_ring_addr / 128;\n\trx_ctx.qlen = info->ring_len;\n\n\tif (info->splithdr_enabled) {\n\t\trx_ctx.hsplit_0 = I40E_RX_SPLIT_L2      |\n\t\t\t\t  I40E_RX_SPLIT_IP      |\n\t\t\t\t  I40E_RX_SPLIT_TCP_UDP |\n\t\t\t\t  I40E_RX_SPLIT_SCTP;\n\t\t \n\t\tif (info->hdr_size > ((2 * 1024) - 64)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\t\trx_ctx.hbuff = info->hdr_size >> I40E_RXQ_CTX_HBUFF_SHIFT;\n\n\t\t \n\t\trx_ctx.dtype = I40E_RX_DTYPE_HEADER_SPLIT;\n\t}\n\n\t \n\tif (info->databuffer_size > ((16 * 1024) - 128)) {\n\t\tret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\trx_ctx.dbuff = info->databuffer_size >> I40E_RXQ_CTX_DBUFF_SHIFT;\n\n\t \n\tif (info->max_pkt_size >= (16 * 1024) || info->max_pkt_size < 64) {\n\t\tret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\trx_ctx.rxmax = info->max_pkt_size;\n\n\t \n\tif (vsi->info.pvid)\n\t\trx_ctx.rxmax += VLAN_HLEN;\n\n\t \n\trx_ctx.dsize = 1;\n\n\t \n\trx_ctx.lrxqthresh = 1;\n\trx_ctx.crcstrip = 1;\n\trx_ctx.prefena = 1;\n\trx_ctx.l2tsel = 1;\n\n\t \n\tret = i40e_clear_lan_rx_queue_context(hw, pf_queue_id);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to clear VF LAN Rx queue context %d, error: %d\\n\",\n\t\t\tpf_queue_id, ret);\n\t\tret = -ENOENT;\n\t\tgoto error_param;\n\t}\n\n\t \n\tret = i40e_set_lan_rx_queue_context(hw, pf_queue_id, &rx_ctx);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to set VF LAN Rx queue context %d error: %d\\n\",\n\t\t\tpf_queue_id, ret);\n\t\tret = -ENOENT;\n\t\tgoto error_param;\n\t}\n\nerror_param:\n\treturn ret;\n}\n\n \nstatic int i40e_alloc_vsi_res(struct i40e_vf *vf, u8 idx)\n{\n\tstruct i40e_mac_filter *f = NULL;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi;\n\tu64 max_tx_rate = 0;\n\tint ret = 0;\n\n\tvsi = i40e_vsi_setup(pf, I40E_VSI_SRIOV, pf->vsi[pf->lan_vsi]->seid,\n\t\t\t     vf->vf_id);\n\n\tif (!vsi) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"add vsi failed for VF %d, aq_err %d\\n\",\n\t\t\tvf->vf_id, pf->hw.aq.asq_last_status);\n\t\tret = -ENOENT;\n\t\tgoto error_alloc_vsi_res;\n\t}\n\n\tif (!idx) {\n\t\tu64 hena = i40e_pf_get_default_rss_hena(pf);\n\t\tu8 broadcast[ETH_ALEN];\n\n\t\tvf->lan_vsi_idx = vsi->idx;\n\t\tvf->lan_vsi_id = vsi->id;\n\t\t \n\t\tif (vf->port_vlan_id)\n\t\t\ti40e_vsi_add_pvid(vsi, vf->port_vlan_id);\n\n\t\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t\tif (is_valid_ether_addr(vf->default_lan_addr.addr)) {\n\t\t\tf = i40e_add_mac_filter(vsi,\n\t\t\t\t\t\tvf->default_lan_addr.addr);\n\t\t\tif (!f)\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Could not add MAC filter %pM for VF %d\\n\",\n\t\t\t\t\tvf->default_lan_addr.addr, vf->vf_id);\n\t\t}\n\t\teth_broadcast_addr(broadcast);\n\t\tf = i40e_add_mac_filter(vsi, broadcast);\n\t\tif (!f)\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Could not allocate VF broadcast filter\\n\");\n\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t\twr32(&pf->hw, I40E_VFQF_HENA1(0, vf->vf_id), (u32)hena);\n\t\twr32(&pf->hw, I40E_VFQF_HENA1(1, vf->vf_id), (u32)(hena >> 32));\n\t\t \n\t\tret = i40e_sync_vsi_filters(vsi);\n\t\tif (ret)\n\t\t\tdev_err(&pf->pdev->dev, \"Unable to program ucast filters\\n\");\n\t}\n\n\t \n\tif (vf->adq_enabled) {\n\t\tvf->ch[idx].vsi_idx = vsi->idx;\n\t\tvf->ch[idx].vsi_id = vsi->id;\n\t}\n\n\t \n\tif (vf->tx_rate) {\n\t\tmax_tx_rate = vf->tx_rate;\n\t} else if (vf->ch[idx].max_tx_rate) {\n\t\tmax_tx_rate = vf->ch[idx].max_tx_rate;\n\t}\n\n\tif (max_tx_rate) {\n\t\tmax_tx_rate = div_u64(max_tx_rate, I40E_BW_CREDIT_DIVISOR);\n\t\tret = i40e_aq_config_vsi_bw_limit(&pf->hw, vsi->seid,\n\t\t\t\t\t\t  max_tx_rate, 0, NULL);\n\t\tif (ret)\n\t\t\tdev_err(&pf->pdev->dev, \"Unable to set tx rate, VF %d, error code %d.\\n\",\n\t\t\t\tvf->vf_id, ret);\n\t}\n\nerror_alloc_vsi_res:\n\treturn ret;\n}\n\n \nstatic void i40e_map_pf_queues_to_vsi(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg, num_tc = 1;  \n\tu16 vsi_id, qps;\n\tint i, j;\n\n\tif (vf->adq_enabled)\n\t\tnum_tc = vf->num_tc;\n\n\tfor (i = 0; i < num_tc; i++) {\n\t\tif (vf->adq_enabled) {\n\t\t\tqps = vf->ch[i].num_qps;\n\t\t\tvsi_id =  vf->ch[i].vsi_id;\n\t\t} else {\n\t\t\tqps = pf->vsi[vf->lan_vsi_idx]->alloc_queue_pairs;\n\t\t\tvsi_id = vf->lan_vsi_id;\n\t\t}\n\n\t\tfor (j = 0; j < 7; j++) {\n\t\t\tif (j * 2 >= qps) {\n\t\t\t\t \n\t\t\t\treg = 0x07FF07FF;\n\t\t\t} else {\n\t\t\t\tu16 qid = i40e_vc_get_pf_queue_id(vf,\n\t\t\t\t\t\t\t\t  vsi_id,\n\t\t\t\t\t\t\t\t  j * 2);\n\t\t\t\treg = qid;\n\t\t\t\tqid = i40e_vc_get_pf_queue_id(vf, vsi_id,\n\t\t\t\t\t\t\t      (j * 2) + 1);\n\t\t\t\treg |= qid << 16;\n\t\t\t}\n\t\t\ti40e_write_rx_ctl(hw,\n\t\t\t\t\t  I40E_VSILAN_QTABLE(j, vsi_id),\n\t\t\t\t\t  reg);\n\t\t}\n\t}\n}\n\n \nstatic void i40e_map_pf_to_vf_queues(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg, total_qps = 0;\n\tu32 qps, num_tc = 1;  \n\tu16 vsi_id, qid;\n\tint i, j;\n\n\tif (vf->adq_enabled)\n\t\tnum_tc = vf->num_tc;\n\n\tfor (i = 0; i < num_tc; i++) {\n\t\tif (vf->adq_enabled) {\n\t\t\tqps = vf->ch[i].num_qps;\n\t\t\tvsi_id =  vf->ch[i].vsi_id;\n\t\t} else {\n\t\t\tqps = pf->vsi[vf->lan_vsi_idx]->alloc_queue_pairs;\n\t\t\tvsi_id = vf->lan_vsi_id;\n\t\t}\n\n\t\tfor (j = 0; j < qps; j++) {\n\t\t\tqid = i40e_vc_get_pf_queue_id(vf, vsi_id, j);\n\n\t\t\treg = (qid & I40E_VPLAN_QTABLE_QINDEX_MASK);\n\t\t\twr32(hw, I40E_VPLAN_QTABLE(total_qps, vf->vf_id),\n\t\t\t     reg);\n\t\t\ttotal_qps++;\n\t\t}\n\t}\n}\n\n \nstatic void i40e_enable_vf_mappings(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg;\n\n\t \n\ti40e_write_rx_ctl(hw, I40E_VSILAN_QBASE(vf->lan_vsi_id),\n\t\t\t  I40E_VSILAN_QBASE_VSIQTABLE_ENA_MASK);\n\n\t \n\treg = I40E_VPLAN_MAPENA_TXRX_ENA_MASK;\n\twr32(hw, I40E_VPLAN_MAPENA(vf->vf_id), reg);\n\n\ti40e_map_pf_to_vf_queues(vf);\n\ti40e_map_pf_queues_to_vsi(vf);\n\n\ti40e_flush(hw);\n}\n\n \nstatic void i40e_disable_vf_mappings(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint i;\n\n\t \n\twr32(hw, I40E_VPLAN_MAPENA(vf->vf_id), 0);\n\tfor (i = 0; i < I40E_MAX_VSI_QP; i++)\n\t\twr32(hw, I40E_VPLAN_QTABLE(i, vf->vf_id),\n\t\t     I40E_QUEUE_END_OF_LIST);\n\ti40e_flush(hw);\n}\n\n \nstatic void i40e_free_vf_res(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg_idx, reg;\n\tint i, j, msix_vf;\n\n\t \n\tclear_bit(I40E_VF_STATE_INIT, &vf->vf_states);\n\n\t \n\tif (vf->num_queue_pairs > I40E_DEFAULT_QUEUES_PER_VF) {\n\t\tpf->queues_left += vf->num_queue_pairs -\n\t\t\t\t   I40E_DEFAULT_QUEUES_PER_VF;\n\t}\n\n\t \n\tif (vf->lan_vsi_idx) {\n\t\ti40e_vsi_release(pf->vsi[vf->lan_vsi_idx]);\n\t\tvf->lan_vsi_idx = 0;\n\t\tvf->lan_vsi_id = 0;\n\t}\n\n\t \n\tif (vf->adq_enabled && vf->ch[0].vsi_idx) {\n\t\tfor (j = 0; j < vf->num_tc; j++) {\n\t\t\t \n\t\t\tif (j)\n\t\t\t\ti40e_vsi_release(pf->vsi[vf->ch[j].vsi_idx]);\n\t\t\tvf->ch[j].vsi_idx = 0;\n\t\t\tvf->ch[j].vsi_id = 0;\n\t\t}\n\t}\n\tmsix_vf = pf->hw.func_caps.num_msix_vectors_vf;\n\n\t \n\tfor (i = 0; i < msix_vf; i++) {\n\t\t \n\t\tif (0 == i)\n\t\t\treg_idx = I40E_VFINT_DYN_CTL0(vf->vf_id);\n\t\telse\n\t\t\treg_idx = I40E_VFINT_DYN_CTLN(((msix_vf - 1) *\n\t\t\t\t\t\t      (vf->vf_id))\n\t\t\t\t\t\t     + (i - 1));\n\t\twr32(hw, reg_idx, I40E_VFINT_DYN_CTLN_CLEARPBA_MASK);\n\t\ti40e_flush(hw);\n\t}\n\n\t \n\tfor (i = 0; i < msix_vf; i++) {\n\t\t \n\t\tif (0 == i)\n\t\t\treg_idx = I40E_VPINT_LNKLST0(vf->vf_id);\n\t\telse\n\t\t\treg_idx = I40E_VPINT_LNKLSTN(((msix_vf - 1) *\n\t\t\t\t\t\t      (vf->vf_id))\n\t\t\t\t\t\t     + (i - 1));\n\t\treg = (I40E_VPINT_LNKLSTN_FIRSTQ_TYPE_MASK |\n\t\t       I40E_VPINT_LNKLSTN_FIRSTQ_INDX_MASK);\n\t\twr32(hw, reg_idx, reg);\n\t\ti40e_flush(hw);\n\t}\n\t \n\tvf->num_queue_pairs = 0;\n\tclear_bit(I40E_VF_STATE_MC_PROMISC, &vf->vf_states);\n\tclear_bit(I40E_VF_STATE_UC_PROMISC, &vf->vf_states);\n}\n\n \nstatic int i40e_alloc_vf_res(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tint total_queue_pairs = 0;\n\tint ret, idx;\n\n\tif (vf->num_req_queues &&\n\t    vf->num_req_queues <= pf->queues_left + I40E_DEFAULT_QUEUES_PER_VF)\n\t\tpf->num_vf_qps = vf->num_req_queues;\n\telse\n\t\tpf->num_vf_qps = I40E_DEFAULT_QUEUES_PER_VF;\n\n\t \n\tret = i40e_alloc_vsi_res(vf, 0);\n\tif (ret)\n\t\tgoto error_alloc;\n\ttotal_queue_pairs += pf->vsi[vf->lan_vsi_idx]->alloc_queue_pairs;\n\n\t \n\tif (vf->adq_enabled) {\n\t\tif (pf->queues_left >=\n\t\t    (I40E_MAX_VF_QUEUES - I40E_DEFAULT_QUEUES_PER_VF)) {\n\t\t\t \n\t\t\tfor (idx = 1; idx < vf->num_tc; idx++) {\n\t\t\t\tret = i40e_alloc_vsi_res(vf, idx);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error_alloc;\n\t\t\t}\n\t\t\t \n\t\t\ttotal_queue_pairs = I40E_MAX_VF_QUEUES;\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev, \"VF %d: Not enough queues to allocate, disabling ADq\\n\",\n\t\t\t\t vf->vf_id);\n\t\t\tvf->adq_enabled = false;\n\t\t}\n\t}\n\n\t \n\tif (total_queue_pairs > I40E_DEFAULT_QUEUES_PER_VF)\n\t\tpf->queues_left -=\n\t\t\ttotal_queue_pairs - I40E_DEFAULT_QUEUES_PER_VF;\n\n\tif (vf->trusted)\n\t\tset_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);\n\telse\n\t\tclear_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);\n\n\t \n\tvf->num_queue_pairs = total_queue_pairs;\n\n\t \n\tset_bit(I40E_VF_STATE_INIT, &vf->vf_states);\n\nerror_alloc:\n\tif (ret)\n\t\ti40e_free_vf_res(vf);\n\n\treturn ret;\n}\n\n#define VF_DEVICE_STATUS 0xAA\n#define VF_TRANS_PENDING_MASK 0x20\n \nstatic int i40e_quiesce_vf_pci(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint vf_abs_id, i;\n\tu32 reg;\n\n\tvf_abs_id = vf->vf_id + hw->func_caps.vf_base_id;\n\n\twr32(hw, I40E_PF_PCI_CIAA,\n\t     VF_DEVICE_STATUS | (vf_abs_id << I40E_PF_PCI_CIAA_VF_NUM_SHIFT));\n\tfor (i = 0; i < 100; i++) {\n\t\treg = rd32(hw, I40E_PF_PCI_CIAD);\n\t\tif ((reg & VF_TRANS_PENDING_MASK) == 0)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -EIO;\n}\n\n \nstatic int __i40e_getnum_vf_vsi_vlan_filters(struct i40e_vsi *vsi)\n{\n\tstruct i40e_mac_filter *f;\n\tu16 num_vlans = 0, bkt;\n\n\thash_for_each(vsi->mac_filter_hash, bkt, f, hlist) {\n\t\tif (f->vlan >= 0 && f->vlan <= I40E_MAX_VLANID)\n\t\t\tnum_vlans++;\n\t}\n\n\treturn num_vlans;\n}\n\n \nstatic int i40e_getnum_vf_vsi_vlan_filters(struct i40e_vsi *vsi)\n{\n\tint num_vlans;\n\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\tnum_vlans = __i40e_getnum_vf_vsi_vlan_filters(vsi);\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\treturn num_vlans;\n}\n\n \nstatic void i40e_get_vlan_list_sync(struct i40e_vsi *vsi, u16 *num_vlans,\n\t\t\t\t    s16 **vlan_list)\n{\n\tstruct i40e_mac_filter *f;\n\tint i = 0;\n\tint bkt;\n\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t*num_vlans = __i40e_getnum_vf_vsi_vlan_filters(vsi);\n\t*vlan_list = kcalloc(*num_vlans, sizeof(**vlan_list), GFP_ATOMIC);\n\tif (!(*vlan_list))\n\t\tgoto err;\n\n\thash_for_each(vsi->mac_filter_hash, bkt, f, hlist) {\n\t\tif (f->vlan < 0 || f->vlan > I40E_MAX_VLANID)\n\t\t\tcontinue;\n\t\t(*vlan_list)[i++] = f->vlan;\n\t}\nerr:\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n}\n\n \nstatic int\ni40e_set_vsi_promisc(struct i40e_vf *vf, u16 seid, bool multi_enable,\n\t\t     bool unicast_enable, s16 *vl, u16 num_vlans)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint aq_ret, aq_tmp = 0;\n\tint i;\n\n\t \n\tif (!num_vlans || !vl) {\n\t\taq_ret = i40e_aq_set_vsi_multicast_promiscuous(hw, seid,\n\t\t\t\t\t\t\t       multi_enable,\n\t\t\t\t\t\t\t       NULL);\n\t\tif (aq_ret) {\n\t\t\tint aq_err = pf->hw.aq.asq_last_status;\n\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d failed to set multicast promiscuous mode err %pe aq_err %s\\n\",\n\t\t\t\tvf->vf_id,\n\t\t\t\tERR_PTR(aq_ret),\n\t\t\t\ti40e_aq_str(&pf->hw, aq_err));\n\n\t\t\treturn aq_ret;\n\t\t}\n\n\t\taq_ret = i40e_aq_set_vsi_unicast_promiscuous(hw, seid,\n\t\t\t\t\t\t\t     unicast_enable,\n\t\t\t\t\t\t\t     NULL, true);\n\n\t\tif (aq_ret) {\n\t\t\tint aq_err = pf->hw.aq.asq_last_status;\n\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d failed to set unicast promiscuous mode err %pe aq_err %s\\n\",\n\t\t\t\tvf->vf_id,\n\t\t\t\tERR_PTR(aq_ret),\n\t\t\t\ti40e_aq_str(&pf->hw, aq_err));\n\t\t}\n\n\t\treturn aq_ret;\n\t}\n\n\tfor (i = 0; i < num_vlans; i++) {\n\t\taq_ret = i40e_aq_set_vsi_mc_promisc_on_vlan(hw, seid,\n\t\t\t\t\t\t\t    multi_enable,\n\t\t\t\t\t\t\t    vl[i], NULL);\n\t\tif (aq_ret) {\n\t\t\tint aq_err = pf->hw.aq.asq_last_status;\n\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d failed to set multicast promiscuous mode err %pe aq_err %s\\n\",\n\t\t\t\tvf->vf_id,\n\t\t\t\tERR_PTR(aq_ret),\n\t\t\t\ti40e_aq_str(&pf->hw, aq_err));\n\n\t\t\tif (!aq_tmp)\n\t\t\t\taq_tmp = aq_ret;\n\t\t}\n\n\t\taq_ret = i40e_aq_set_vsi_uc_promisc_on_vlan(hw, seid,\n\t\t\t\t\t\t\t    unicast_enable,\n\t\t\t\t\t\t\t    vl[i], NULL);\n\t\tif (aq_ret) {\n\t\t\tint aq_err = pf->hw.aq.asq_last_status;\n\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d failed to set unicast promiscuous mode err %pe aq_err %s\\n\",\n\t\t\t\tvf->vf_id,\n\t\t\t\tERR_PTR(aq_ret),\n\t\t\t\ti40e_aq_str(&pf->hw, aq_err));\n\n\t\t\tif (!aq_tmp)\n\t\t\t\taq_tmp = aq_ret;\n\t\t}\n\t}\n\n\tif (aq_tmp)\n\t\taq_ret = aq_tmp;\n\n\treturn aq_ret;\n}\n\n \nstatic int i40e_config_vf_promiscuous_mode(struct i40e_vf *vf,\n\t\t\t\t\t   u16 vsi_id,\n\t\t\t\t\t   bool allmulti,\n\t\t\t\t\t   bool alluni)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi;\n\tint aq_ret = 0;\n\tu16 num_vlans;\n\ts16 *vl;\n\n\tvsi = i40e_find_vsi_from_id(pf, vsi_id);\n\tif (!i40e_vc_isvalid_vsi_id(vf, vsi_id) || !vsi)\n\t\treturn -EINVAL;\n\n\tif (vf->port_vlan_id) {\n\t\taq_ret = i40e_set_vsi_promisc(vf, vsi->seid, allmulti,\n\t\t\t\t\t      alluni, &vf->port_vlan_id, 1);\n\t\treturn aq_ret;\n\t} else if (i40e_getnum_vf_vsi_vlan_filters(vsi)) {\n\t\ti40e_get_vlan_list_sync(vsi, &num_vlans, &vl);\n\n\t\tif (!vl)\n\t\t\treturn -ENOMEM;\n\n\t\taq_ret = i40e_set_vsi_promisc(vf, vsi->seid, allmulti, alluni,\n\t\t\t\t\t      vl, num_vlans);\n\t\tkfree(vl);\n\t\treturn aq_ret;\n\t}\n\n\t \n\taq_ret = i40e_set_vsi_promisc(vf, vsi->seid, allmulti, alluni,\n\t\t\t\t      NULL, 0);\n\treturn aq_ret;\n}\n\n \nstatic int i40e_sync_vfr_reset(struct i40e_hw *hw, int vf_id)\n{\n\tu32 reg;\n\tint i;\n\n\tfor (i = 0; i < I40E_VFR_WAIT_COUNT; i++) {\n\t\treg = rd32(hw, I40E_VFINT_ICR0_ENA(vf_id)) &\n\t\t\t   I40E_VFINT_ICR0_ADMINQ_MASK;\n\t\tif (reg)\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 200);\n\t}\n\n\treturn -EAGAIN;\n}\n\n \nstatic void i40e_trigger_vf_reset(struct i40e_vf *vf, bool flr)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg, reg_idx, bit_idx;\n\tbool vf_active;\n\tu32 radq;\n\n\t \n\tvf_active = test_and_clear_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states);\n\n\t \n\tclear_bit(I40E_VF_STATE_INIT, &vf->vf_states);\n\n\t \n\tif (!flr) {\n\t\t \n\t\tradq = rd32(hw, I40E_VFINT_ICR0_ENA(vf->vf_id)) &\n\t\t\t    I40E_VFINT_ICR0_ADMINQ_MASK;\n\t\tif (vf_active && !radq)\n\t\t\t \n\t\t\tif (i40e_sync_vfr_reset(hw, vf->vf_id))\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Reset VF %d never finished\\n\",\n\t\t\t\tvf->vf_id);\n\n\t\t \n\t\treg = rd32(hw, I40E_VPGEN_VFRTRIG(vf->vf_id));\n\t\treg |= I40E_VPGEN_VFRTRIG_VFSWR_MASK;\n\t\twr32(hw, I40E_VPGEN_VFRTRIG(vf->vf_id), reg);\n\t\ti40e_flush(hw);\n\t}\n\t \n\treg_idx = (hw->func_caps.vf_base_id + vf->vf_id) / 32;\n\tbit_idx = (hw->func_caps.vf_base_id + vf->vf_id) % 32;\n\twr32(hw, I40E_GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));\n\ti40e_flush(hw);\n\n\tif (i40e_quiesce_vf_pci(vf))\n\t\tdev_err(&pf->pdev->dev, \"VF %d PCI transactions stuck\\n\",\n\t\t\tvf->vf_id);\n}\n\n \nstatic void i40e_cleanup_reset_vf(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg;\n\n\t \n\ti40e_config_vf_promiscuous_mode(vf, vf->lan_vsi_id, false, false);\n\n\t \n\ti40e_free_vf_res(vf);\n\n\t \n\treg = rd32(hw, I40E_VPGEN_VFRTRIG(vf->vf_id));\n\treg &= ~I40E_VPGEN_VFRTRIG_VFSWR_MASK;\n\twr32(hw, I40E_VPGEN_VFRTRIG(vf->vf_id), reg);\n\n\t \n\tif (!i40e_alloc_vf_res(vf)) {\n\t\tint abs_vf_id = vf->vf_id + hw->func_caps.vf_base_id;\n\t\ti40e_enable_vf_mappings(vf);\n\t\tset_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states);\n\t\tclear_bit(I40E_VF_STATE_DISABLED, &vf->vf_states);\n\t\t \n\t\tif (!test_and_clear_bit(I40E_VF_STATE_PRE_ENABLE,\n\t\t\t\t\t&vf->vf_states))\n\t\t\ti40e_notify_client_of_vf_reset(pf, abs_vf_id);\n\t\tvf->num_vlan = 0;\n\t}\n\n\t \n\twr32(hw, I40E_VFGEN_RSTAT1(vf->vf_id), VIRTCHNL_VFR_VFACTIVE);\n}\n\n \nbool i40e_reset_vf(struct i40e_vf *vf, bool flr)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tbool rsd = false;\n\tu32 reg;\n\tint i;\n\n\tif (test_bit(__I40E_VF_RESETS_DISABLED, pf->state))\n\t\treturn true;\n\n\t \n\tif (test_bit(__I40E_VF_DISABLE, pf->state))\n\t\treturn true;\n\n\t \n\tif (test_and_set_bit(I40E_VF_STATE_RESETTING, &vf->vf_states))\n\t\treturn true;\n\n\ti40e_trigger_vf_reset(vf, flr);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\t \n\t\tusleep_range(10000, 20000);\n\t\treg = rd32(hw, I40E_VPGEN_VFRSTAT(vf->vf_id));\n\t\tif (reg & I40E_VPGEN_VFRSTAT_VFRD_MASK) {\n\t\t\trsd = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flr)\n\t\tusleep_range(10000, 20000);\n\n\tif (!rsd)\n\t\tdev_err(&pf->pdev->dev, \"VF reset check timeout on VF %d\\n\",\n\t\t\tvf->vf_id);\n\tusleep_range(10000, 20000);\n\n\t \n\tif (vf->lan_vsi_idx != 0)\n\t\ti40e_vsi_stop_rings(pf->vsi[vf->lan_vsi_idx]);\n\n\ti40e_cleanup_reset_vf(vf);\n\n\ti40e_flush(hw);\n\tusleep_range(20000, 40000);\n\tclear_bit(I40E_VF_STATE_RESETTING, &vf->vf_states);\n\n\treturn true;\n}\n\n \nbool i40e_reset_all_vfs(struct i40e_pf *pf, bool flr)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vf *vf;\n\tint i, v;\n\tu32 reg;\n\n\t \n\tif (!pf->num_alloc_vfs)\n\t\treturn false;\n\n\t \n\tif (test_and_set_bit(__I40E_VF_DISABLE, pf->state))\n\t\treturn false;\n\n\t \n\tfor (v = 0; v < pf->num_alloc_vfs; v++) {\n\t\tvf = &pf->vf[v];\n\t\t \n\t\tif (!test_bit(I40E_VF_STATE_RESETTING, &vf->vf_states))\n\t\t\ti40e_trigger_vf_reset(&pf->vf[v], flr);\n\t}\n\n\t \n\tfor (i = 0, v = 0; i < 10 && v < pf->num_alloc_vfs; i++) {\n\t\tusleep_range(10000, 20000);\n\n\t\t \n\t\twhile (v < pf->num_alloc_vfs) {\n\t\t\tvf = &pf->vf[v];\n\t\t\tif (!test_bit(I40E_VF_STATE_RESETTING, &vf->vf_states)) {\n\t\t\t\treg = rd32(hw, I40E_VPGEN_VFRSTAT(vf->vf_id));\n\t\t\t\tif (!(reg & I40E_VPGEN_VFRSTAT_VFRD_MASK))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tv++;\n\t\t}\n\t}\n\n\tif (flr)\n\t\tusleep_range(10000, 20000);\n\n\t \n\tif (v < pf->num_alloc_vfs)\n\t\tdev_err(&pf->pdev->dev, \"VF reset check timeout on VF %d\\n\",\n\t\t\tpf->vf[v].vf_id);\n\tusleep_range(10000, 20000);\n\n\t \n\tfor (v = 0; v < pf->num_alloc_vfs; v++) {\n\t\t \n\t\tif (pf->vf[v].lan_vsi_idx == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(I40E_VF_STATE_RESETTING, &vf->vf_states))\n\t\t\tcontinue;\n\n\t\ti40e_vsi_stop_rings_no_wait(pf->vsi[pf->vf[v].lan_vsi_idx]);\n\t}\n\n\t \n\tfor (v = 0; v < pf->num_alloc_vfs; v++) {\n\t\t \n\t\tif (pf->vf[v].lan_vsi_idx == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(I40E_VF_STATE_RESETTING, &vf->vf_states))\n\t\t\tcontinue;\n\n\t\ti40e_vsi_wait_queues_disabled(pf->vsi[pf->vf[v].lan_vsi_idx]);\n\t}\n\n\t \n\tmdelay(50);\n\n\t \n\tfor (v = 0; v < pf->num_alloc_vfs; v++) {\n\t\t \n\t\tif (test_bit(I40E_VF_STATE_RESETTING, &vf->vf_states))\n\t\t\tcontinue;\n\n\t\ti40e_cleanup_reset_vf(&pf->vf[v]);\n\t}\n\n\ti40e_flush(hw);\n\tusleep_range(20000, 40000);\n\tclear_bit(__I40E_VF_DISABLE, pf->state);\n\n\treturn true;\n}\n\n \nvoid i40e_free_vfs(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg_idx, bit_idx;\n\tint i, tmp, vf_id;\n\n\tif (!pf->vf)\n\t\treturn;\n\n\tset_bit(__I40E_VFS_RELEASING, pf->state);\n\twhile (test_and_set_bit(__I40E_VF_DISABLE, pf->state))\n\t\tusleep_range(1000, 2000);\n\n\ti40e_notify_client_of_vf_enable(pf, 0);\n\n\t \n\tif (!pci_vfs_assigned(pf->pdev))\n\t\tpci_disable_sriov(pf->pdev);\n\telse\n\t\tdev_warn(&pf->pdev->dev, \"VFs are assigned - not disabling SR-IOV\\n\");\n\n\t \n\tfor (i = 0; i < pf->num_alloc_vfs; i++) {\n\t\tif (test_bit(I40E_VF_STATE_INIT, &pf->vf[i].vf_states))\n\t\t\tcontinue;\n\n\t\ti40e_vsi_stop_rings_no_wait(pf->vsi[pf->vf[i].lan_vsi_idx]);\n\t}\n\n\tfor (i = 0; i < pf->num_alloc_vfs; i++) {\n\t\tif (test_bit(I40E_VF_STATE_INIT, &pf->vf[i].vf_states))\n\t\t\tcontinue;\n\n\t\ti40e_vsi_wait_queues_disabled(pf->vsi[pf->vf[i].lan_vsi_idx]);\n\t}\n\n\t \n\ttmp = pf->num_alloc_vfs;\n\tpf->num_alloc_vfs = 0;\n\tfor (i = 0; i < tmp; i++) {\n\t\tif (test_bit(I40E_VF_STATE_INIT, &pf->vf[i].vf_states))\n\t\t\ti40e_free_vf_res(&pf->vf[i]);\n\t\t \n\t\ti40e_disable_vf_mappings(&pf->vf[i]);\n\t}\n\n\tkfree(pf->vf);\n\tpf->vf = NULL;\n\n\t \n\tif (!pci_vfs_assigned(pf->pdev)) {\n\t\t \n\t\tfor (vf_id = 0; vf_id < tmp; vf_id++) {\n\t\t\treg_idx = (hw->func_caps.vf_base_id + vf_id) / 32;\n\t\t\tbit_idx = (hw->func_caps.vf_base_id + vf_id) % 32;\n\t\t\twr32(hw, I40E_GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));\n\t\t}\n\t}\n\tclear_bit(__I40E_VF_DISABLE, pf->state);\n\tclear_bit(__I40E_VFS_RELEASING, pf->state);\n}\n\n#ifdef CONFIG_PCI_IOV\n \nint i40e_alloc_vfs(struct i40e_pf *pf, u16 num_alloc_vfs)\n{\n\tstruct i40e_vf *vfs;\n\tint i, ret = 0;\n\n\t \n\ti40e_irq_dynamic_disable_icr0(pf);\n\n\t \n\tif (pci_num_vf(pf->pdev) != num_alloc_vfs) {\n\t\tret = pci_enable_sriov(pf->pdev, num_alloc_vfs);\n\t\tif (ret) {\n\t\t\tpf->flags &= ~I40E_FLAG_VEB_MODE_ENABLED;\n\t\t\tpf->num_alloc_vfs = 0;\n\t\t\tgoto err_iov;\n\t\t}\n\t}\n\t \n\tvfs = kcalloc(num_alloc_vfs, sizeof(struct i40e_vf), GFP_KERNEL);\n\tif (!vfs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\tpf->vf = vfs;\n\n\t \n\tfor (i = 0; i < num_alloc_vfs; i++) {\n\t\tvfs[i].pf = pf;\n\t\tvfs[i].parent_type = I40E_SWITCH_ELEMENT_TYPE_VEB;\n\t\tvfs[i].vf_id = i;\n\n\t\t \n\t\tset_bit(I40E_VIRTCHNL_VF_CAP_L2, &vfs[i].vf_caps);\n\t\tvfs[i].spoofchk = true;\n\n\t\tset_bit(I40E_VF_STATE_PRE_ENABLE, &vfs[i].vf_states);\n\n\t}\n\tpf->num_alloc_vfs = num_alloc_vfs;\n\n\t \n\ti40e_reset_all_vfs(pf, false);\n\n\ti40e_notify_client_of_vf_enable(pf, num_alloc_vfs);\n\nerr_alloc:\n\tif (ret)\n\t\ti40e_free_vfs(pf);\nerr_iov:\n\t \n\ti40e_irq_dynamic_enable_icr0(pf);\n\treturn ret;\n}\n\n#endif\n \nstatic int i40e_pci_sriov_enable(struct pci_dev *pdev, int num_vfs)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\tint pre_existing_vfs = pci_num_vf(pdev);\n\tint err = 0;\n\n\tif (test_bit(__I40E_TESTING, pf->state)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Cannot enable SR-IOV virtual functions while the device is undergoing diagnostic testing\\n\");\n\t\terr = -EPERM;\n\t\tgoto err_out;\n\t}\n\n\tif (pre_existing_vfs && pre_existing_vfs != num_vfs)\n\t\ti40e_free_vfs(pf);\n\telse if (pre_existing_vfs && pre_existing_vfs == num_vfs)\n\t\tgoto out;\n\n\tif (num_vfs > pf->num_req_vfs) {\n\t\tdev_warn(&pdev->dev, \"Unable to enable %d VFs. Limited to %d VFs due to device resource constraints.\\n\",\n\t\t\t num_vfs, pf->num_req_vfs);\n\t\terr = -EPERM;\n\t\tgoto err_out;\n\t}\n\n\tdev_info(&pdev->dev, \"Allocating %d VFs.\\n\", num_vfs);\n\terr = i40e_alloc_vfs(pf, num_vfs);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"Failed to enable SR-IOV: %d\\n\", err);\n\t\tgoto err_out;\n\t}\n\nout:\n\treturn num_vfs;\n\nerr_out:\n\treturn err;\n#endif\n\treturn 0;\n}\n\n \nint i40e_pci_sriov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\tint ret = 0;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (num_vfs) {\n\t\tif (!(pf->flags & I40E_FLAG_VEB_MODE_ENABLED)) {\n\t\t\tpf->flags |= I40E_FLAG_VEB_MODE_ENABLED;\n\t\t\ti40e_do_reset_safe(pf, I40E_PF_RESET_AND_REBUILD_FLAG);\n\t\t}\n\t\tret = i40e_pci_sriov_enable(pdev, num_vfs);\n\t\tgoto sriov_configure_out;\n\t}\n\n\tif (!pci_vfs_assigned(pf->pdev)) {\n\t\ti40e_free_vfs(pf);\n\t\tpf->flags &= ~I40E_FLAG_VEB_MODE_ENABLED;\n\t\ti40e_do_reset_safe(pf, I40E_PF_RESET_AND_REBUILD_FLAG);\n\t} else {\n\t\tdev_warn(&pdev->dev, \"Unable to free VFs because some are assigned to VMs.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto sriov_configure_out;\n\t}\nsriov_configure_out:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \n\n \nstatic int i40e_vc_send_msg_to_vf(struct i40e_vf *vf, u32 v_opcode,\n\t\t\t\t  u32 v_retval, u8 *msg, u16 msglen)\n{\n\tstruct i40e_pf *pf;\n\tstruct i40e_hw *hw;\n\tint abs_vf_id;\n\tint aq_ret;\n\n\t \n\tif (!vf || vf->vf_id >= vf->pf->num_alloc_vfs)\n\t\treturn -EINVAL;\n\n\tpf = vf->pf;\n\thw = &pf->hw;\n\tabs_vf_id = vf->vf_id + hw->func_caps.vf_base_id;\n\n\taq_ret = i40e_aq_send_msg_to_vf(hw, abs_vf_id,\tv_opcode, v_retval,\n\t\t\t\t\tmsg, msglen, NULL);\n\tif (aq_ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Unable to send the message to VF %d aq_err %d\\n\",\n\t\t\t vf->vf_id, pf->hw.aq.asq_last_status);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_vc_send_resp_to_vf(struct i40e_vf *vf,\n\t\t\t\t   enum virtchnl_ops opcode,\n\t\t\t\t   int retval)\n{\n\treturn i40e_vc_send_msg_to_vf(vf, opcode, retval, NULL, 0);\n}\n\n \nstatic bool i40e_sync_vf_state(struct i40e_vf *vf, enum i40e_vf_states state)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < I40E_VF_STATE_WAIT_COUNT; i++) {\n\t\tif (test_bit(state, &vf->vf_states))\n\t\t\treturn true;\n\t\tusleep_range(10000, 20000);\n\t}\n\n\treturn test_bit(state, &vf->vf_states);\n}\n\n \nstatic int i40e_vc_get_version_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_version_info info = {\n\t\tVIRTCHNL_VERSION_MAJOR, VIRTCHNL_VERSION_MINOR\n\t};\n\n\tvf->vf_ver = *(struct virtchnl_version_info *)msg;\n\t \n\tif (VF_IS_V10(&vf->vf_ver))\n\t\tinfo.minor = VIRTCHNL_VERSION_MINOR_NO_VF_CAPS;\n\treturn i40e_vc_send_msg_to_vf(vf, VIRTCHNL_OP_VERSION,\n\t\t\t\t      0, (u8 *)&info,\n\t\t\t\t      sizeof(struct virtchnl_version_info));\n}\n\n \nstatic void i40e_del_qch(struct i40e_vf *vf)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tint i;\n\n\t \n\tfor (i = 1; i < vf->num_tc; i++) {\n\t\tif (vf->ch[i].vsi_idx) {\n\t\t\ti40e_vsi_release(pf->vsi[vf->ch[i].vsi_idx]);\n\t\t\tvf->ch[i].vsi_idx = 0;\n\t\t\tvf->ch[i].vsi_id = 0;\n\t\t}\n\t}\n}\n\n \nstatic u16 i40e_vc_get_max_frame_size(struct i40e_vf *vf)\n{\n\tu16 max_frame_size = vf->pf->hw.phy.link_info.max_frame_size;\n\n\tif (vf->port_vlan_id)\n\t\tmax_frame_size -= VLAN_HLEN;\n\n\treturn max_frame_size;\n}\n\n \nstatic int i40e_vc_get_vf_resources_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vf_resource *vfres = NULL;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi;\n\tint num_vsis = 1;\n\tint aq_ret = 0;\n\tsize_t len = 0;\n\tint ret;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_INIT)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tlen = virtchnl_struct_size(vfres, vsi_res, num_vsis);\n\tvfres = kzalloc(len, GFP_KERNEL);\n\tif (!vfres) {\n\t\taq_ret = -ENOMEM;\n\t\tlen = 0;\n\t\tgoto err;\n\t}\n\tif (VF_IS_V11(&vf->vf_ver))\n\t\tvf->driver_caps = *(u32 *)msg;\n\telse\n\t\tvf->driver_caps = VIRTCHNL_VF_OFFLOAD_L2 |\n\t\t\t\t  VIRTCHNL_VF_OFFLOAD_RSS_REG |\n\t\t\t\t  VIRTCHNL_VF_OFFLOAD_VLAN;\n\n\tvfres->vf_cap_flags = VIRTCHNL_VF_OFFLOAD_L2;\n\tvfres->vf_cap_flags |= VIRTCHNL_VF_CAP_ADV_LINK_SPEED;\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\tif (!vsi->info.pvid)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_VLAN;\n\n\tif (i40e_vf_client_capable(pf, vf->vf_id) &&\n\t    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RDMA)) {\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RDMA;\n\t\tset_bit(I40E_VF_STATE_RDMAENA, &vf->vf_states);\n\t} else {\n\t\tclear_bit(I40E_VF_STATE_RDMAENA, &vf->vf_states);\n\t}\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PF) {\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_PF;\n\t} else {\n\t\tif ((pf->hw_features & I40E_HW_RSS_AQ_CAPABLE) &&\n\t\t    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_AQ))\n\t\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_AQ;\n\t\telse\n\t\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_REG;\n\t}\n\n\tif (pf->hw_features & I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE) {\n\t\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)\n\t\t\tvfres->vf_cap_flags |=\n\t\t\t\tVIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;\n\t}\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP;\n\n\tif ((pf->hw_features & I40E_HW_OUTER_UDP_CSUM_CAPABLE) &&\n\t    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_POLLING) {\n\t\tif (pf->flags & I40E_FLAG_MFP_ENABLED) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d requested polling mode: this feature is supported only when the device is running in single function per port (SFP) mode\\n\",\n\t\t\t\t vf->vf_id);\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RX_POLLING;\n\t}\n\n\tif (pf->hw_features & I40E_HW_WB_ON_ITR_CAPABLE) {\n\t\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)\n\t\t\tvfres->vf_cap_flags |=\n\t\t\t\t\tVIRTCHNL_VF_OFFLOAD_WB_ON_ITR;\n\t}\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_REQ_QUEUES)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_REQ_QUEUES;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ADQ)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ADQ;\n\n\tvfres->num_vsis = num_vsis;\n\tvfres->num_queue_pairs = vf->num_queue_pairs;\n\tvfres->max_vectors = pf->hw.func_caps.num_msix_vectors_vf;\n\tvfres->rss_key_size = I40E_HKEY_ARRAY_SIZE;\n\tvfres->rss_lut_size = I40E_VF_HLUT_ARRAY_SIZE;\n\tvfres->max_mtu = i40e_vc_get_max_frame_size(vf);\n\n\tif (vf->lan_vsi_idx) {\n\t\tvfres->vsi_res[0].vsi_id = vf->lan_vsi_id;\n\t\tvfres->vsi_res[0].vsi_type = VIRTCHNL_VSI_SRIOV;\n\t\tvfres->vsi_res[0].num_queue_pairs = vsi->alloc_queue_pairs;\n\t\t \n\t\tvfres->vsi_res[0].qset_handle\n\t\t\t\t\t  = le16_to_cpu(vsi->info.qs_handle[0]);\n\t\tif (!(vf->driver_caps & VIRTCHNL_VF_OFFLOAD_USO) && !vf->pf_set_mac) {\n\t\t\ti40e_del_mac_filter(vsi, vf->default_lan_addr.addr);\n\t\t\teth_zero_addr(vf->default_lan_addr.addr);\n\t\t}\n\t\tether_addr_copy(vfres->vsi_res[0].default_mac_addr,\n\t\t\t\tvf->default_lan_addr.addr);\n\t}\n\tset_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states);\n\nerr:\n\t \n\tret = i40e_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_VF_RESOURCES,\n\t\t\t\t     aq_ret, (u8 *)vfres, len);\n\n\tkfree(vfres);\n\treturn ret;\n}\n\n \nstatic int i40e_vc_config_promiscuous_mode_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_promisc_info *info =\n\t    (struct virtchnl_promisc_info *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tbool allmulti = false;\n\tbool alluni = false;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\tif (!test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Unprivileged VF %d is attempting to configure promiscuous mode\\n\",\n\t\t\tvf->vf_id);\n\n\t\t \n\t\taq_ret = 0;\n\t\tgoto err_out;\n\t}\n\n\tif (info->flags > I40E_MAX_VF_PROMISC_FLAGS) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (!i40e_vc_isvalid_vsi_id(vf, info->vsi_id)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (info->flags & FLAG_VF_MULTICAST_PROMISC)\n\t\tallmulti = true;\n\n\tif (info->flags & FLAG_VF_UNICAST_PROMISC)\n\t\talluni = true;\n\taq_ret = i40e_config_vf_promiscuous_mode(vf, info->vsi_id, allmulti,\n\t\t\t\t\t\t alluni);\n\tif (aq_ret)\n\t\tgoto err_out;\n\n\tif (allmulti) {\n\t\tif (!test_and_set_bit(I40E_VF_STATE_MC_PROMISC,\n\t\t\t\t      &vf->vf_states))\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"VF %d successfully set multicast promiscuous mode\\n\",\n\t\t\t\t vf->vf_id);\n\t} else if (test_and_clear_bit(I40E_VF_STATE_MC_PROMISC,\n\t\t\t\t      &vf->vf_states))\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VF %d successfully unset multicast promiscuous mode\\n\",\n\t\t\t vf->vf_id);\n\n\tif (alluni) {\n\t\tif (!test_and_set_bit(I40E_VF_STATE_UC_PROMISC,\n\t\t\t\t      &vf->vf_states))\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"VF %d successfully set unicast promiscuous mode\\n\",\n\t\t\t\t vf->vf_id);\n\t} else if (test_and_clear_bit(I40E_VF_STATE_UC_PROMISC,\n\t\t\t\t      &vf->vf_states))\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VF %d successfully unset unicast promiscuous mode\\n\",\n\t\t\t vf->vf_id);\n\nerr_out:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf,\n\t\t\t\t       VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_config_queues_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vsi_queue_config_info *qci =\n\t    (struct virtchnl_vsi_queue_config_info *)msg;\n\tstruct virtchnl_queue_pair_info *qpi;\n\tu16 vsi_id, vsi_queue_id = 0;\n\tstruct i40e_pf *pf = vf->pf;\n\tint i, j = 0, idx = 0;\n\tstruct i40e_vsi *vsi;\n\tu16 num_qps_all = 0;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (!i40e_vc_isvalid_vsi_id(vf, qci->vsi_id)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (qci->num_queue_pairs > I40E_MAX_VF_QUEUES) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (vf->adq_enabled) {\n\t\tfor (i = 0; i < vf->num_tc; i++)\n\t\t\tnum_qps_all += vf->ch[i].num_qps;\n\t\tif (num_qps_all != qci->num_queue_pairs) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\t}\n\n\tvsi_id = qci->vsi_id;\n\n\tfor (i = 0; i < qci->num_queue_pairs; i++) {\n\t\tqpi = &qci->qpair[i];\n\n\t\tif (!vf->adq_enabled) {\n\t\t\tif (!i40e_vc_isvalid_queue_id(vf, vsi_id,\n\t\t\t\t\t\t      qpi->txq.queue_id)) {\n\t\t\t\taq_ret = -EINVAL;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\tvsi_queue_id = qpi->txq.queue_id;\n\n\t\t\tif (qpi->txq.vsi_id != qci->vsi_id ||\n\t\t\t    qpi->rxq.vsi_id != qci->vsi_id ||\n\t\t\t    qpi->rxq.queue_id != vsi_queue_id) {\n\t\t\t\taq_ret = -EINVAL;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t}\n\n\t\tif (vf->adq_enabled) {\n\t\t\tif (idx >= ARRAY_SIZE(vf->ch)) {\n\t\t\t\taq_ret = -ENODEV;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t\tvsi_id = vf->ch[idx].vsi_id;\n\t\t}\n\n\t\tif (i40e_config_vsi_rx_queue(vf, vsi_id, vsi_queue_id,\n\t\t\t\t\t     &qpi->rxq) ||\n\t\t    i40e_config_vsi_tx_queue(vf, vsi_id, vsi_queue_id,\n\t\t\t\t\t     &qpi->txq)) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\t \n\t\tif (vf->adq_enabled) {\n\t\t\tif (idx >= ARRAY_SIZE(vf->ch)) {\n\t\t\t\taq_ret = -ENODEV;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t\tif (j == (vf->ch[idx].num_qps - 1)) {\n\t\t\t\tidx++;\n\t\t\t\tj = 0;  \n\t\t\t\tvsi_queue_id = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t\tvsi_queue_id++;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (!vf->adq_enabled) {\n\t\tpf->vsi[vf->lan_vsi_idx]->num_queue_pairs =\n\t\t\tqci->num_queue_pairs;\n\t} else {\n\t\tfor (i = 0; i < vf->num_tc; i++) {\n\t\t\tvsi = pf->vsi[vf->ch[i].vsi_idx];\n\t\t\tvsi->num_queue_pairs = vf->ch[i].num_qps;\n\n\t\t\tif (i40e_update_adq_vsi_queues(vsi, i)) {\n\t\t\t\taq_ret = -EIO;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t}\n\t}\n\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_validate_queue_map(struct i40e_vf *vf, u16 vsi_id,\n\t\t\t\t   unsigned long queuemap)\n{\n\tu16 vsi_queue_id, queue_id;\n\n\tfor_each_set_bit(vsi_queue_id, &queuemap, I40E_MAX_VSI_QP) {\n\t\tif (vf->adq_enabled) {\n\t\t\tvsi_id = vf->ch[vsi_queue_id / I40E_MAX_VF_VSI].vsi_id;\n\t\t\tqueue_id = (vsi_queue_id % I40E_DEFAULT_QUEUES_PER_VF);\n\t\t} else {\n\t\t\tqueue_id = vsi_queue_id;\n\t\t}\n\n\t\tif (!i40e_vc_isvalid_queue_id(vf, vsi_id, queue_id))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_vc_config_irq_map_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_irq_map_info *irqmap_info =\n\t    (struct virtchnl_irq_map_info *)msg;\n\tstruct virtchnl_vector_map *map;\n\tint aq_ret = 0;\n\tu16 vsi_id;\n\tint i;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (irqmap_info->num_vectors >\n\t    vf->pf->hw.func_caps.num_msix_vectors_vf) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < irqmap_info->num_vectors; i++) {\n\t\tmap = &irqmap_info->vecmap[i];\n\t\t \n\t\tif (!i40e_vc_isvalid_vector_id(vf, map->vector_id) ||\n\t\t    !i40e_vc_isvalid_vsi_id(vf, map->vsi_id)) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\t\tvsi_id = map->vsi_id;\n\n\t\tif (i40e_validate_queue_map(vf, vsi_id, map->rxq_map)) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\tif (i40e_validate_queue_map(vf, vsi_id, map->txq_map)) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\ti40e_config_irq_link_list(vf, vsi_id, map);\n\t}\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_CONFIG_IRQ_MAP,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_ctrl_vf_tx_rings(struct i40e_vsi *vsi, unsigned long q_map,\n\t\t\t\t bool enable)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint ret = 0;\n\tu16 q_id;\n\n\tfor_each_set_bit(q_id, &q_map, I40E_MAX_VF_QUEUES) {\n\t\tret = i40e_control_wait_tx_q(vsi->seid, pf,\n\t\t\t\t\t     vsi->base_queue + q_id,\n\t\t\t\t\t     false  , enable);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int i40e_ctrl_vf_rx_rings(struct i40e_vsi *vsi, unsigned long q_map,\n\t\t\t\t bool enable)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint ret = 0;\n\tu16 q_id;\n\n\tfor_each_set_bit(q_id, &q_map, I40E_MAX_VF_QUEUES) {\n\t\tret = i40e_control_wait_rx_q(pf, vsi->base_queue + q_id,\n\t\t\t\t\t     enable);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic bool i40e_vc_validate_vqs_bitmaps(struct virtchnl_queue_select *vqs)\n{\n\tif ((!vqs->rx_queues && !vqs->tx_queues) ||\n\t    vqs->rx_queues >= BIT(I40E_MAX_VF_QUEUES) ||\n\t    vqs->tx_queues >= BIT(I40E_MAX_VF_QUEUES))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int i40e_vc_enable_queues_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_queue_select *vqs =\n\t    (struct virtchnl_queue_select *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tint aq_ret = 0;\n\tint i;\n\n\tif (!test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (!i40e_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (!i40e_vc_validate_vqs_bitmaps(vqs)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\t \n\tif (i40e_ctrl_vf_rx_rings(pf->vsi[vf->lan_vsi_idx], vqs->rx_queues,\n\t\t\t\t  true)) {\n\t\taq_ret = -EIO;\n\t\tgoto error_param;\n\t}\n\tif (i40e_ctrl_vf_tx_rings(pf->vsi[vf->lan_vsi_idx], vqs->tx_queues,\n\t\t\t\t  true)) {\n\t\taq_ret = -EIO;\n\t\tgoto error_param;\n\t}\n\n\t \n\tif (vf->adq_enabled) {\n\t\t \n\t\tfor (i = 1; i < vf->num_tc; i++) {\n\t\t\tif (i40e_vsi_start_rings(pf->vsi[vf->ch[i].vsi_idx]))\n\t\t\t\taq_ret = -EIO;\n\t\t}\n\t}\n\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_ENABLE_QUEUES,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_disable_queues_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_queue_select *vqs =\n\t    (struct virtchnl_queue_select *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (!i40e_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (!i40e_vc_validate_vqs_bitmaps(vqs)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\t \n\tif (i40e_ctrl_vf_tx_rings(pf->vsi[vf->lan_vsi_idx], vqs->tx_queues,\n\t\t\t\t  false)) {\n\t\taq_ret = -EIO;\n\t\tgoto error_param;\n\t}\n\tif (i40e_ctrl_vf_rx_rings(pf->vsi[vf->lan_vsi_idx], vqs->rx_queues,\n\t\t\t\t  false)) {\n\t\taq_ret = -EIO;\n\t\tgoto error_param;\n\t}\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_DISABLE_QUEUES,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_check_enough_queue(struct i40e_vf *vf, u16 needed)\n{\n\tunsigned int  i, cur_queues, more, pool_size;\n\tstruct i40e_lump_tracking *pile;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi;\n\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\tcur_queues = vsi->alloc_queue_pairs;\n\n\t \n\tif (cur_queues >= needed)\n\t\treturn vsi->base_queue;\n\n\tpile = pf->qp_pile;\n\tif (cur_queues > 0) {\n\t\t \n\t\tmore = needed - cur_queues;\n\t\tfor (i = vsi->base_queue + cur_queues;\n\t\t\ti < pile->num_entries; i++) {\n\t\t\tif (pile->list[i] & I40E_PILE_VALID_BIT)\n\t\t\t\tbreak;\n\n\t\t\tif (more-- == 1)\n\t\t\t\t \n\t\t\t\treturn vsi->base_queue;\n\t\t}\n\t}\n\n\tpool_size = 0;\n\tfor (i = 0; i < pile->num_entries; i++) {\n\t\tif (pile->list[i] & I40E_PILE_VALID_BIT) {\n\t\t\tpool_size = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (needed <= ++pool_size)\n\t\t\t \n\t\t\treturn i;\n\t}\n\n\treturn -ENOMEM;\n}\n\n \nstatic int i40e_vc_request_queues_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vf_res_request *vfres =\n\t\t(struct virtchnl_vf_res_request *)msg;\n\tu16 req_pairs = vfres->num_queue_pairs;\n\tu8 cur_pairs = vf->num_queue_pairs;\n\tstruct i40e_pf *pf = vf->pf;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE))\n\t\treturn -EINVAL;\n\n\tif (req_pairs > I40E_MAX_VF_QUEUES) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"VF %d tried to request more than %d queues.\\n\",\n\t\t\tvf->vf_id,\n\t\t\tI40E_MAX_VF_QUEUES);\n\t\tvfres->num_queue_pairs = I40E_MAX_VF_QUEUES;\n\t} else if (req_pairs - cur_pairs > pf->queues_left) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"VF %d requested %d more queues, but only %d left.\\n\",\n\t\t\t vf->vf_id,\n\t\t\t req_pairs - cur_pairs,\n\t\t\t pf->queues_left);\n\t\tvfres->num_queue_pairs = pf->queues_left + cur_pairs;\n\t} else if (i40e_check_enough_queue(vf, req_pairs) < 0) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"VF %d requested %d more queues, but there is not enough for it.\\n\",\n\t\t\t vf->vf_id,\n\t\t\t req_pairs - cur_pairs);\n\t\tvfres->num_queue_pairs = cur_pairs;\n\t} else {\n\t\t \n\t\tvf->num_req_queues = req_pairs;\n\t\ti40e_vc_reset_vf(vf, true);\n\t\treturn 0;\n\t}\n\n\treturn i40e_vc_send_msg_to_vf(vf, VIRTCHNL_OP_REQUEST_QUEUES, 0,\n\t\t\t\t      (u8 *)vfres, sizeof(*vfres));\n}\n\n \nstatic int i40e_vc_get_stats_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_queue_select *vqs =\n\t    (struct virtchnl_queue_select *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_eth_stats stats;\n\tint aq_ret = 0;\n\tstruct i40e_vsi *vsi;\n\n\tmemset(&stats, 0, sizeof(struct i40e_eth_stats));\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (!i40e_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\tif (!vsi) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\ti40e_update_eth_stats(vsi);\n\tstats = vsi->eth_stats;\n\nerror_param:\n\t \n\treturn i40e_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_STATS, aq_ret,\n\t\t\t\t      (u8 *)&stats, sizeof(stats));\n}\n\n#define I40E_MAX_MACVLAN_PER_HW 3072\n#define I40E_MAX_MACVLAN_PER_PF(num_ports) (I40E_MAX_MACVLAN_PER_HW /\t\\\n\t(num_ports))\n \n#define I40E_VC_MAX_MAC_ADDR_PER_VF (16 + 1 + 1)\n#define I40E_VC_MAX_VLAN_PER_VF 16\n\n#define I40E_VC_MAX_MACVLAN_PER_TRUSTED_VF(vf_num, num_ports)\t\t\\\n({\ttypeof(vf_num) vf_num_ = (vf_num);\t\t\t\t\\\n\ttypeof(num_ports) num_ports_ = (num_ports);\t\t\t\\\n\t((I40E_MAX_MACVLAN_PER_PF(num_ports_) - vf_num_ *\t\t\\\n\tI40E_VC_MAX_MAC_ADDR_PER_VF) / vf_num_) +\t\t\t\\\n\tI40E_VC_MAX_MAC_ADDR_PER_VF; })\n \nstatic inline int i40e_check_vf_permission(struct i40e_vf *vf,\n\t\t\t\t\t   struct virtchnl_ether_addr_list *al)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = pf->vsi[vf->lan_vsi_idx];\n\tstruct i40e_hw *hw = &pf->hw;\n\tint mac2add_cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < al->num_elements; i++) {\n\t\tstruct i40e_mac_filter *f;\n\t\tu8 *addr = al->list[i].addr;\n\n\t\tif (is_broadcast_ether_addr(addr) ||\n\t\t    is_zero_ether_addr(addr)) {\n\t\t\tdev_err(&pf->pdev->dev, \"invalid VF MAC addr %pM\\n\",\n\t\t\t\taddr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps) &&\n\t\t    !is_multicast_ether_addr(addr) && vf->pf_set_mac &&\n\t\t    !ether_addr_equal(addr, vf->default_lan_addr.addr)) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF attempting to override administratively set MAC address, bring down and up the VF interface to resume normal operation\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t \n\t\tf = i40e_find_mac(vsi, addr);\n\t\tif (!f)\n\t\t\t++mac2add_cnt;\n\t}\n\n\t \n\tif (!test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {\n\t\tif ((i40e_count_filters(vsi) + mac2add_cnt) >\n\t\t    I40E_VC_MAX_MAC_ADDR_PER_VF) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Cannot add more MAC addresses, VF is not trusted, switch the VF to trusted to add more functionality\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t \n\t} else {\n\t\tif ((i40e_count_filters(vsi) + mac2add_cnt) >\n\t\t    I40E_VC_MAX_MACVLAN_PER_TRUSTED_VF(pf->num_alloc_vfs,\n\t\t\t\t\t\t       hw->num_ports)) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Cannot add more MAC addresses, trusted VF exhausted it's resources\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic u8\ni40e_vc_ether_addr_type(struct virtchnl_ether_addr *vc_ether_addr)\n{\n\treturn vc_ether_addr->type & VIRTCHNL_ETHER_ADDR_TYPE_MASK;\n}\n\n \nstatic bool\ni40e_is_vc_addr_legacy(struct virtchnl_ether_addr *vc_ether_addr)\n{\n\treturn i40e_vc_ether_addr_type(vc_ether_addr) ==\n\t\tVIRTCHNL_ETHER_ADDR_LEGACY;\n}\n\n \nstatic bool\ni40e_is_vc_addr_primary(struct virtchnl_ether_addr *vc_ether_addr)\n{\n\treturn i40e_vc_ether_addr_type(vc_ether_addr) ==\n\t\tVIRTCHNL_ETHER_ADDR_PRIMARY;\n}\n\n \nstatic void\ni40e_update_vf_mac_addr(struct i40e_vf *vf,\n\t\t\tstruct virtchnl_ether_addr *vc_ether_addr)\n{\n\tu8 *mac_addr = vc_ether_addr->addr;\n\n\tif (!is_valid_ether_addr(mac_addr))\n\t\treturn;\n\n\t \n\tif (i40e_is_vc_addr_primary(vc_ether_addr)) {\n\t\tether_addr_copy(vf->default_lan_addr.addr, mac_addr);\n\t} else if (i40e_is_vc_addr_legacy(vc_ether_addr)) {\n\t\tif (is_zero_ether_addr(vf->default_lan_addr.addr))\n\t\t\tether_addr_copy(vf->default_lan_addr.addr, mac_addr);\n\t}\n}\n\n \nstatic int i40e_vc_add_mac_addr_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_ether_addr_list *al =\n\t    (struct virtchnl_ether_addr_list *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint ret = 0;\n\tint i;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE) ||\n\t    !i40e_vc_isvalid_vsi_id(vf, al->vsi_id)) {\n\t\tret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\n\t \n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\n\tret = i40e_check_vf_permission(vf, al);\n\tif (ret) {\n\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t\tgoto error_param;\n\t}\n\n\t \n\tfor (i = 0; i < al->num_elements; i++) {\n\t\tstruct i40e_mac_filter *f;\n\n\t\tf = i40e_find_mac(vsi, al->list[i].addr);\n\t\tif (!f) {\n\t\t\tf = i40e_add_mac_filter(vsi, al->list[i].addr);\n\n\t\t\tif (!f) {\n\t\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\t\"Unable to add MAC filter %pM for VF %d\\n\",\n\t\t\t\t\tal->list[i].addr, vf->vf_id);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t}\n\t\ti40e_update_vf_mac_addr(vf, &al->list[i]);\n\t}\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\t \n\tret = i40e_sync_vsi_filters(vsi);\n\tif (ret)\n\t\tdev_err(&pf->pdev->dev, \"Unable to program VF %d MAC filters, error %d\\n\",\n\t\t\tvf->vf_id, ret);\n\nerror_param:\n\t \n\treturn i40e_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_ETH_ADDR,\n\t\t\t\t      ret, NULL, 0);\n}\n\n \nstatic int i40e_vc_del_mac_addr_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_ether_addr_list *al =\n\t    (struct virtchnl_ether_addr_list *)msg;\n\tbool was_unimac_deleted = false;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint ret = 0;\n\tint i;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE) ||\n\t    !i40e_vc_isvalid_vsi_id(vf, al->vsi_id)) {\n\t\tret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < al->num_elements; i++) {\n\t\tif (is_broadcast_ether_addr(al->list[i].addr) ||\n\t\t    is_zero_ether_addr(al->list[i].addr)) {\n\t\t\tdev_err(&pf->pdev->dev, \"Invalid MAC addr %pM for VF %d\\n\",\n\t\t\t\tal->list[i].addr, vf->vf_id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\t\tif (ether_addr_equal(al->list[i].addr, vf->default_lan_addr.addr))\n\t\t\twas_unimac_deleted = true;\n\t}\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t \n\tfor (i = 0; i < al->num_elements; i++)\n\t\tif (i40e_del_mac_filter(vsi, al->list[i].addr)) {\n\t\t\tret = -EINVAL;\n\t\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t\t\tgoto error_param;\n\t\t}\n\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\tif (was_unimac_deleted)\n\t\teth_zero_addr(vf->default_lan_addr.addr);\n\n\t \n\tret = i40e_sync_vsi_filters(vsi);\n\tif (ret)\n\t\tdev_err(&pf->pdev->dev, \"Unable to program VF %d MAC filters, error %d\\n\",\n\t\t\tvf->vf_id, ret);\n\n\tif (vf->trusted && was_unimac_deleted) {\n\t\tstruct i40e_mac_filter *f;\n\t\tstruct hlist_node *h;\n\t\tu8 *macaddr = NULL;\n\t\tint bkt;\n\n\t\t \n\t\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\t\tif (is_valid_ether_addr(f->macaddr))\n\t\t\t\tmacaddr = f->macaddr;\n\t\t}\n\t\tif (macaddr)\n\t\t\tether_addr_copy(vf->default_lan_addr.addr, macaddr);\n\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t}\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_DEL_ETH_ADDR, ret);\n}\n\n \nstatic int i40e_vc_add_vlan_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vlan_filter_list *vfl =\n\t    (struct virtchnl_vlan_filter_list *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint aq_ret = 0;\n\tint i;\n\n\tif ((vf->num_vlan >= I40E_VC_MAX_VLAN_PER_VF) &&\n\t    !test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"VF is not trusted, switch the VF to trusted to add more VLAN addresses\\n\");\n\t\tgoto error_param;\n\t}\n\tif (!test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states) ||\n\t    !i40e_vc_isvalid_vsi_id(vf, vfl->vsi_id)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\tif (vfl->vlan_id[i] > I40E_MAX_VLANID) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"invalid VF VLAN id %d\\n\", vfl->vlan_id[i]);\n\t\t\tgoto error_param;\n\t\t}\n\t}\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\tif (vsi->info.pvid) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\ti40e_vlan_stripping_enable(vsi);\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\t \n\t\tint ret = i40e_vsi_add_vlan(vsi, vfl->vlan_id[i]);\n\t\tif (!ret)\n\t\t\tvf->num_vlan++;\n\n\t\tif (test_bit(I40E_VF_STATE_UC_PROMISC, &vf->vf_states))\n\t\t\ti40e_aq_set_vsi_uc_promisc_on_vlan(&pf->hw, vsi->seid,\n\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t   vfl->vlan_id[i],\n\t\t\t\t\t\t\t   NULL);\n\t\tif (test_bit(I40E_VF_STATE_MC_PROMISC, &vf->vf_states))\n\t\t\ti40e_aq_set_vsi_mc_promisc_on_vlan(&pf->hw, vsi->seid,\n\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t   vfl->vlan_id[i],\n\t\t\t\t\t\t\t   NULL);\n\n\t\tif (ret)\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Unable to add VLAN filter %d for VF %d, error %d\\n\",\n\t\t\t\tvfl->vlan_id[i], vf->vf_id, ret);\n\t}\n\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_ADD_VLAN, aq_ret);\n}\n\n \nstatic int i40e_vc_remove_vlan_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vlan_filter_list *vfl =\n\t    (struct virtchnl_vlan_filter_list *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint aq_ret = 0;\n\tint i;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE) ||\n\t    !i40e_vc_isvalid_vsi_id(vf, vfl->vsi_id)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\tif (vfl->vlan_id[i] > I40E_MAX_VLANID) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto error_param;\n\t\t}\n\t}\n\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\tif (vsi->info.pvid) {\n\t\tif (vfl->num_elements > 1 || vfl->vlan_id[0])\n\t\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\ti40e_vsi_kill_vlan(vsi, vfl->vlan_id[i]);\n\t\tvf->num_vlan--;\n\n\t\tif (test_bit(I40E_VF_STATE_UC_PROMISC, &vf->vf_states))\n\t\t\ti40e_aq_set_vsi_uc_promisc_on_vlan(&pf->hw, vsi->seid,\n\t\t\t\t\t\t\t   false,\n\t\t\t\t\t\t\t   vfl->vlan_id[i],\n\t\t\t\t\t\t\t   NULL);\n\t\tif (test_bit(I40E_VF_STATE_MC_PROMISC, &vf->vf_states))\n\t\t\ti40e_aq_set_vsi_mc_promisc_on_vlan(&pf->hw, vsi->seid,\n\t\t\t\t\t\t\t   false,\n\t\t\t\t\t\t\t   vfl->vlan_id[i],\n\t\t\t\t\t\t\t   NULL);\n\t}\n\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_DEL_VLAN, aq_ret);\n}\n\n \nstatic int i40e_vc_rdma_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tint abs_vf_id = vf->vf_id + pf->hw.func_caps.vf_base_id;\n\tint aq_ret = 0;\n\n\tif (!test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states) ||\n\t    !test_bit(I40E_VF_STATE_RDMAENA, &vf->vf_states)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\ti40e_notify_client_of_vf_msg(pf->vsi[pf->lan_vsi], abs_vf_id,\n\t\t\t\t     msg, msglen);\n\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_RDMA,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_rdma_qvmap_msg(struct i40e_vf *vf, u8 *msg, bool config)\n{\n\tstruct virtchnl_rdma_qvlist_info *qvlist_info =\n\t\t\t\t(struct virtchnl_rdma_qvlist_info *)msg;\n\tint aq_ret = 0;\n\n\tif (!test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states) ||\n\t    !test_bit(I40E_VF_STATE_RDMAENA, &vf->vf_states)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\tif (config) {\n\t\tif (i40e_config_rdma_qvlist(vf, qvlist_info))\n\t\t\taq_ret = -EINVAL;\n\t} else {\n\t\ti40e_release_rdma_qvlist(vf);\n\t}\n\nerror_param:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf,\n\t\t\t       config ? VIRTCHNL_OP_CONFIG_RDMA_IRQ_MAP :\n\t\t\t       VIRTCHNL_OP_RELEASE_RDMA_IRQ_MAP,\n\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_config_rss_key(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_rss_key *vrk =\n\t\t(struct virtchnl_rss_key *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE) ||\n\t    !i40e_vc_isvalid_vsi_id(vf, vrk->vsi_id) ||\n\t    vrk->key_len != I40E_HKEY_ARRAY_SIZE) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\taq_ret = i40e_config_rss(vsi, vrk->key, NULL, 0);\nerr:\n\t \n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_KEY,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_config_rss_lut(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_rss_lut *vrl =\n\t\t(struct virtchnl_rss_lut *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint aq_ret = 0;\n\tu16 i;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE) ||\n\t    !i40e_vc_isvalid_vsi_id(vf, vrl->vsi_id) ||\n\t    vrl->lut_entries != I40E_VF_HLUT_ARRAY_SIZE) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < vrl->lut_entries; i++)\n\t\tif (vrl->lut[i] >= vf->num_queue_pairs) {\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\taq_ret = i40e_config_rss(vsi, NULL, vrl->lut, I40E_VF_HLUT_ARRAY_SIZE);\n\t \nerr:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_LUT,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_get_rss_hena(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_rss_hena *vrh = NULL;\n\tstruct i40e_pf *pf = vf->pf;\n\tint aq_ret = 0;\n\tint len = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\tlen = sizeof(struct virtchnl_rss_hena);\n\n\tvrh = kzalloc(len, GFP_KERNEL);\n\tif (!vrh) {\n\t\taq_ret = -ENOMEM;\n\t\tlen = 0;\n\t\tgoto err;\n\t}\n\tvrh->hena = i40e_pf_get_default_rss_hena(pf);\nerr:\n\t \n\taq_ret = i40e_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_RSS_HENA_CAPS,\n\t\t\t\t\taq_ret, (u8 *)vrh, len);\n\tkfree(vrh);\n\treturn aq_ret;\n}\n\n \nstatic int i40e_vc_set_rss_hena(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_rss_hena *vrh =\n\t\t(struct virtchnl_rss_hena *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\ti40e_write_rx_ctl(hw, I40E_VFQF_HENA1(0, vf->vf_id), (u32)vrh->hena);\n\ti40e_write_rx_ctl(hw, I40E_VFQF_HENA1(1, vf->vf_id),\n\t\t\t  (u32)(vrh->hena >> 32));\n\n\t \nerr:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_SET_RSS_HENA, aq_ret);\n}\n\n \nstatic int i40e_vc_enable_vlan_stripping(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct i40e_vsi *vsi;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tvsi = vf->pf->vsi[vf->lan_vsi_idx];\n\ti40e_vlan_stripping_enable(vsi);\n\n\t \nerr:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_disable_vlan_stripping(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct i40e_vsi *vsi;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tvsi = vf->pf->vsi[vf->lan_vsi_idx];\n\ti40e_vlan_stripping_disable(vsi);\n\n\t \nerr:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_validate_cloud_filter(struct i40e_vf *vf,\n\t\t\t\t      struct virtchnl_filter *tc_filter)\n{\n\tstruct virtchnl_l4_spec mask = tc_filter->mask.tcp_spec;\n\tstruct virtchnl_l4_spec data = tc_filter->data.tcp_spec;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tstruct i40e_mac_filter *f;\n\tstruct hlist_node *h;\n\tbool found = false;\n\tint bkt;\n\n\tif (tc_filter->action != VIRTCHNL_ACTION_TC_REDIRECT) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VF %d: ADQ doesn't support this action (%d)\\n\",\n\t\t\t vf->vf_id, tc_filter->action);\n\t\tgoto err;\n\t}\n\n\t \n\tif (!tc_filter->action_meta ||\n\t    tc_filter->action_meta > vf->num_tc) {\n\t\tdev_info(&pf->pdev->dev, \"VF %d: Invalid TC number %u\\n\",\n\t\t\t vf->vf_id, tc_filter->action_meta);\n\t\tgoto err;\n\t}\n\n\t \n\tif (mask.dst_mac[0] && !mask.dst_ip[0]) {\n\t\tvsi = pf->vsi[vf->lan_vsi_idx];\n\t\tf = i40e_find_mac(vsi, data.dst_mac);\n\n\t\tif (!f) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Destination MAC %pM doesn't belong to VF %d\\n\",\n\t\t\t\t data.dst_mac, vf->vf_id);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (mask.vlan_id) {\n\t\t\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f,\n\t\t\t\t\t   hlist) {\n\t\t\t\tif (f->vlan == ntohs(data.vlan_id)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"VF %d doesn't have any VLAN id %u\\n\",\n\t\t\t\t\t vf->vf_id, ntohs(data.vlan_id));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (!test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d not trusted, make VF trusted to add advanced mode ADq cloud filters\\n\",\n\t\t\t\tvf->vf_id);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask.dst_mac[0] & data.dst_mac[0]) {\n\t\tif (is_broadcast_ether_addr(data.dst_mac) ||\n\t\t    is_zero_ether_addr(data.dst_mac)) {\n\t\t\tdev_info(&pf->pdev->dev, \"VF %d: Invalid Dest MAC addr %pM\\n\",\n\t\t\t\t vf->vf_id, data.dst_mac);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (mask.src_mac[0] & data.src_mac[0]) {\n\t\tif (is_broadcast_ether_addr(data.src_mac) ||\n\t\t    is_zero_ether_addr(data.src_mac)) {\n\t\t\tdev_info(&pf->pdev->dev, \"VF %d: Invalid Source MAC addr %pM\\n\",\n\t\t\t\t vf->vf_id, data.src_mac);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (mask.dst_port & data.dst_port) {\n\t\tif (!data.dst_port) {\n\t\t\tdev_info(&pf->pdev->dev, \"VF %d: Invalid Dest port\\n\",\n\t\t\t\t vf->vf_id);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (mask.src_port & data.src_port) {\n\t\tif (!data.src_port) {\n\t\t\tdev_info(&pf->pdev->dev, \"VF %d: Invalid Source port\\n\",\n\t\t\t\t vf->vf_id);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (tc_filter->flow_type != VIRTCHNL_TCP_V6_FLOW &&\n\t    tc_filter->flow_type != VIRTCHNL_TCP_V4_FLOW) {\n\t\tdev_info(&pf->pdev->dev, \"VF %d: Invalid Flow type\\n\",\n\t\t\t vf->vf_id);\n\t\tgoto err;\n\t}\n\n\tif (mask.vlan_id & data.vlan_id) {\n\t\tif (ntohs(data.vlan_id) > I40E_MAX_VLANID) {\n\t\t\tdev_info(&pf->pdev->dev, \"VF %d: invalid VLAN ID\\n\",\n\t\t\t\t vf->vf_id);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\treturn -EIO;\n}\n\n \nstatic struct i40e_vsi *i40e_find_vsi_from_seid(struct i40e_vf *vf, u16 seid)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint i;\n\n\tfor (i = 0; i < vf->num_tc ; i++) {\n\t\tvsi = i40e_find_vsi_from_id(pf, vf->ch[i].vsi_id);\n\t\tif (vsi && vsi->seid == seid)\n\t\t\treturn vsi;\n\t}\n\treturn NULL;\n}\n\n \nstatic void i40e_del_all_cloud_filters(struct i40e_vf *vf)\n{\n\tstruct i40e_cloud_filter *cfilter = NULL;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tstruct hlist_node *node;\n\tint ret;\n\n\thlist_for_each_entry_safe(cfilter, node,\n\t\t\t\t  &vf->cloud_filter_list, cloud_node) {\n\t\tvsi = i40e_find_vsi_from_seid(vf, cfilter->seid);\n\n\t\tif (!vsi) {\n\t\t\tdev_err(&pf->pdev->dev, \"VF %d: no VSI found for matching %u seid, can't delete cloud filter\\n\",\n\t\t\t\tvf->vf_id, cfilter->seid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cfilter->dst_port)\n\t\t\tret = i40e_add_del_cloud_filter_big_buf(vsi, cfilter,\n\t\t\t\t\t\t\t\tfalse);\n\t\telse\n\t\t\tret = i40e_add_del_cloud_filter(vsi, cfilter, false);\n\t\tif (ret)\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d: Failed to delete cloud filter, err %pe aq_err %s\\n\",\n\t\t\t\tvf->vf_id, ERR_PTR(ret),\n\t\t\t\ti40e_aq_str(&pf->hw,\n\t\t\t\t\t    pf->hw.aq.asq_last_status));\n\n\t\thlist_del(&cfilter->cloud_node);\n\t\tkfree(cfilter);\n\t\tvf->num_cloud_filters--;\n\t}\n}\n\n \nstatic int i40e_vc_del_cloud_filter(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_filter *vcf = (struct virtchnl_filter *)msg;\n\tstruct virtchnl_l4_spec mask = vcf->mask.tcp_spec;\n\tstruct virtchnl_l4_spec tcf = vcf->data.tcp_spec;\n\tstruct i40e_cloud_filter cfilter, *cf = NULL;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tstruct hlist_node *node;\n\tint aq_ret = 0;\n\tint i, ret;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!vf->adq_enabled) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VF %d: ADq not enabled, can't apply cloud filter\\n\",\n\t\t\t vf->vf_id);\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (i40e_validate_cloud_filter(vf, vcf)) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VF %d: Invalid input, can't apply cloud filter\\n\",\n\t\t\t vf->vf_id);\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmemset(&cfilter, 0, sizeof(cfilter));\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tcfilter.dst_mac[i] = mask.dst_mac[i] & tcf.dst_mac[i];\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tcfilter.src_mac[i] = mask.src_mac[i] & tcf.src_mac[i];\n\n\tcfilter.vlan_id = mask.vlan_id & tcf.vlan_id;\n\tcfilter.dst_port = mask.dst_port & tcf.dst_port;\n\tcfilter.src_port = mask.src_port & tcf.src_port;\n\n\tswitch (vcf->flow_type) {\n\tcase VIRTCHNL_TCP_V4_FLOW:\n\t\tcfilter.n_proto = ETH_P_IP;\n\t\tif (mask.dst_ip[0] & tcf.dst_ip[0])\n\t\t\tmemcpy(&cfilter.ip.v4.dst_ip, tcf.dst_ip,\n\t\t\t       ARRAY_SIZE(tcf.dst_ip));\n\t\telse if (mask.src_ip[0] & tcf.dst_ip[0])\n\t\t\tmemcpy(&cfilter.ip.v4.src_ip, tcf.src_ip,\n\t\t\t       ARRAY_SIZE(tcf.dst_ip));\n\t\tbreak;\n\tcase VIRTCHNL_TCP_V6_FLOW:\n\t\tcfilter.n_proto = ETH_P_IPV6;\n\t\tif (mask.dst_ip[3] & tcf.dst_ip[3])\n\t\t\tmemcpy(&cfilter.ip.v6.dst_ip6, tcf.dst_ip,\n\t\t\t       sizeof(cfilter.ip.v6.dst_ip6));\n\t\tif (mask.src_ip[3] & tcf.src_ip[3])\n\t\t\tmemcpy(&cfilter.ip.v6.src_ip6, tcf.src_ip,\n\t\t\t       sizeof(cfilter.ip.v6.src_ip6));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_info(&pf->pdev->dev, \"VF %d: Flow type not configured\\n\",\n\t\t\t vf->vf_id);\n\t}\n\n\t \n\tvsi = pf->vsi[vf->ch[vcf->action_meta].vsi_idx];\n\tcfilter.seid = vsi->seid;\n\tcfilter.flags = vcf->field_flags;\n\n\t \n\tif (tcf.dst_port)\n\t\tret = i40e_add_del_cloud_filter_big_buf(vsi, &cfilter, false);\n\telse\n\t\tret = i40e_add_del_cloud_filter(vsi, &cfilter, false);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"VF %d: Failed to delete cloud filter, err %pe aq_err %s\\n\",\n\t\t\tvf->vf_id, ERR_PTR(ret),\n\t\t\ti40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\tgoto err;\n\t}\n\n\thlist_for_each_entry_safe(cf, node,\n\t\t\t\t  &vf->cloud_filter_list, cloud_node) {\n\t\tif (cf->seid != cfilter.seid)\n\t\t\tcontinue;\n\t\tif (mask.dst_port)\n\t\t\tif (cfilter.dst_port != cf->dst_port)\n\t\t\t\tcontinue;\n\t\tif (mask.dst_mac[0])\n\t\t\tif (!ether_addr_equal(cf->src_mac, cfilter.src_mac))\n\t\t\t\tcontinue;\n\t\t \n\t\tif (cfilter.n_proto == ETH_P_IP && mask.dst_ip[0])\n\t\t\tif (memcmp(&cfilter.ip.v4.dst_ip, &cf->ip.v4.dst_ip,\n\t\t\t\t   ARRAY_SIZE(tcf.dst_ip)))\n\t\t\t\tcontinue;\n\t\t \n\t\tif (cfilter.n_proto == ETH_P_IPV6 && mask.dst_ip[3])\n\t\t\tif (memcmp(&cfilter.ip.v6.dst_ip6, &cf->ip.v6.dst_ip6,\n\t\t\t\t   sizeof(cfilter.ip.v6.src_ip6)))\n\t\t\t\tcontinue;\n\t\tif (mask.vlan_id)\n\t\t\tif (cfilter.vlan_id != cf->vlan_id)\n\t\t\t\tcontinue;\n\n\t\thlist_del(&cf->cloud_node);\n\t\tkfree(cf);\n\t\tvf->num_cloud_filters--;\n\t}\n\nerr:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_DEL_CLOUD_FILTER,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_add_cloud_filter(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_filter *vcf = (struct virtchnl_filter *)msg;\n\tstruct virtchnl_l4_spec mask = vcf->mask.tcp_spec;\n\tstruct virtchnl_l4_spec tcf = vcf->data.tcp_spec;\n\tstruct i40e_cloud_filter *cfilter = NULL;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_vsi *vsi = NULL;\n\tint aq_ret = 0;\n\tint i;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (!vf->adq_enabled) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VF %d: ADq is not enabled, can't apply cloud filter\\n\",\n\t\t\t vf->vf_id);\n\t\taq_ret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (i40e_validate_cloud_filter(vf, vcf)) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VF %d: Invalid input/s, can't apply cloud filter\\n\",\n\t\t\t vf->vf_id);\n\t\taq_ret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tcfilter = kzalloc(sizeof(*cfilter), GFP_KERNEL);\n\tif (!cfilter) {\n\t\taq_ret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tcfilter->dst_mac[i] = mask.dst_mac[i] & tcf.dst_mac[i];\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tcfilter->src_mac[i] = mask.src_mac[i] & tcf.src_mac[i];\n\n\tcfilter->vlan_id = mask.vlan_id & tcf.vlan_id;\n\tcfilter->dst_port = mask.dst_port & tcf.dst_port;\n\tcfilter->src_port = mask.src_port & tcf.src_port;\n\n\tswitch (vcf->flow_type) {\n\tcase VIRTCHNL_TCP_V4_FLOW:\n\t\tcfilter->n_proto = ETH_P_IP;\n\t\tif (mask.dst_ip[0] & tcf.dst_ip[0])\n\t\t\tmemcpy(&cfilter->ip.v4.dst_ip, tcf.dst_ip,\n\t\t\t       ARRAY_SIZE(tcf.dst_ip));\n\t\telse if (mask.src_ip[0] & tcf.dst_ip[0])\n\t\t\tmemcpy(&cfilter->ip.v4.src_ip, tcf.src_ip,\n\t\t\t       ARRAY_SIZE(tcf.dst_ip));\n\t\tbreak;\n\tcase VIRTCHNL_TCP_V6_FLOW:\n\t\tcfilter->n_proto = ETH_P_IPV6;\n\t\tif (mask.dst_ip[3] & tcf.dst_ip[3])\n\t\t\tmemcpy(&cfilter->ip.v6.dst_ip6, tcf.dst_ip,\n\t\t\t       sizeof(cfilter->ip.v6.dst_ip6));\n\t\tif (mask.src_ip[3] & tcf.src_ip[3])\n\t\t\tmemcpy(&cfilter->ip.v6.src_ip6, tcf.src_ip,\n\t\t\t       sizeof(cfilter->ip.v6.src_ip6));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_info(&pf->pdev->dev, \"VF %d: Flow type not configured\\n\",\n\t\t\t vf->vf_id);\n\t}\n\n\t \n\tvsi = pf->vsi[vf->ch[vcf->action_meta].vsi_idx];\n\tcfilter->seid = vsi->seid;\n\tcfilter->flags = vcf->field_flags;\n\n\t \n\tif (tcf.dst_port)\n\t\taq_ret = i40e_add_del_cloud_filter_big_buf(vsi, cfilter, true);\n\telse\n\t\taq_ret = i40e_add_del_cloud_filter(vsi, cfilter, true);\n\tif (aq_ret) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"VF %d: Failed to add cloud filter, err %pe aq_err %s\\n\",\n\t\t\tvf->vf_id, ERR_PTR(aq_ret),\n\t\t\ti40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\tgoto err_free;\n\t}\n\n\tINIT_HLIST_NODE(&cfilter->cloud_node);\n\thlist_add_head(&cfilter->cloud_node, &vf->cloud_filter_list);\n\t \n\tcfilter = NULL;\n\tvf->num_cloud_filters++;\nerr_free:\n\tkfree(cfilter);\nerr_out:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_ADD_CLOUD_FILTER,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_add_qch_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_tc_info *tci =\n\t\t(struct virtchnl_tc_info *)msg;\n\tstruct i40e_pf *pf = vf->pf;\n\tstruct i40e_link_status *ls = &pf->hw.phy.link_info;\n\tint i, adq_request_qps = 0;\n\tint aq_ret = 0;\n\tu64 speed = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (vf->spoofchk) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Spoof check is ON, turn it OFF to enable ADq\\n\");\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!(vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ADQ)) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"VF %d attempting to enable ADq, but hasn't properly negotiated that capability\\n\",\n\t\t\tvf->vf_id);\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (!tci->num_tc || tci->num_tc > I40E_MAX_VF_VSI) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"VF %d trying to set %u TCs, valid range 1-%u TCs per VF\\n\",\n\t\t\tvf->vf_id, tci->num_tc, I40E_MAX_VF_VSI);\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tfor (i = 0; i < tci->num_tc; i++)\n\t\tif (!tci->list[i].count ||\n\t\t    tci->list[i].count > I40E_DEFAULT_QUEUES_PER_VF) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"VF %d: TC %d trying to set %u queues, valid range 1-%u queues per TC\\n\",\n\t\t\t\tvf->vf_id, i, tci->list[i].count,\n\t\t\t\tI40E_DEFAULT_QUEUES_PER_VF);\n\t\t\taq_ret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t \n\tadq_request_qps = I40E_MAX_VF_QUEUES - I40E_DEFAULT_QUEUES_PER_VF;\n\n\tif (pf->queues_left < adq_request_qps) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"No queues left to allocate to VF %d\\n\",\n\t\t\tvf->vf_id);\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t} else {\n\t\t \n\t\tvf->num_queue_pairs = I40E_MAX_VF_QUEUES;\n\t}\n\n\t \n\tspeed = i40e_vc_link_speed2mbps(ls->link_speed);\n\tif (speed == SPEED_UNKNOWN) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Cannot detect link speed\\n\");\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tvf->num_tc = tci->num_tc;\n\tfor (i = 0; i < vf->num_tc; i++) {\n\t\tif (tci->list[i].max_tx_rate) {\n\t\t\tif (tci->list[i].max_tx_rate > speed) {\n\t\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\t\"Invalid max tx rate %llu specified for VF %d.\",\n\t\t\t\t\ttci->list[i].max_tx_rate,\n\t\t\t\t\tvf->vf_id);\n\t\t\t\taq_ret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tvf->ch[i].max_tx_rate =\n\t\t\t\t\ttci->list[i].max_tx_rate;\n\t\t\t}\n\t\t}\n\t\tvf->ch[i].num_qps = tci->list[i].count;\n\t}\n\n\t \n\tvf->adq_enabled = true;\n\n\t \n\ti40e_vc_reset_vf(vf, true);\n\n\treturn 0;\n\n\t \nerr:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_ENABLE_CHANNELS,\n\t\t\t\t       aq_ret);\n}\n\n \nstatic int i40e_vc_del_qch_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct i40e_pf *pf = vf->pf;\n\tint aq_ret = 0;\n\n\tif (!i40e_sync_vf_state(vf, I40E_VF_STATE_ACTIVE)) {\n\t\taq_ret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (vf->adq_enabled) {\n\t\ti40e_del_all_cloud_filters(vf);\n\t\ti40e_del_qch(vf);\n\t\tvf->adq_enabled = false;\n\t\tvf->num_tc = 0;\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Deleting Queue Channels and cloud filters for ADq on VF %d\\n\",\n\t\t\t vf->vf_id);\n\t} else {\n\t\tdev_info(&pf->pdev->dev, \"VF %d trying to delete queue channels but ADq isn't enabled\\n\",\n\t\t\t vf->vf_id);\n\t\taq_ret = -EINVAL;\n\t}\n\n\t \n\ti40e_vc_reset_vf(vf, true);\n\n\treturn 0;\n\nerr:\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_DISABLE_CHANNELS,\n\t\t\t\t       aq_ret);\n}\n\n \nint i40e_vc_process_vf_msg(struct i40e_pf *pf, s16 vf_id, u32 v_opcode,\n\t\t\t   u32 __always_unused v_retval, u8 *msg, u16 msglen)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tint local_vf_id = vf_id - (s16)hw->func_caps.vf_base_id;\n\tstruct i40e_vf *vf;\n\tint ret;\n\n\tpf->vf_aq_requests++;\n\tif (local_vf_id < 0 || local_vf_id >= pf->num_alloc_vfs)\n\t\treturn -EINVAL;\n\tvf = &(pf->vf[local_vf_id]);\n\n\t \n\tif (test_bit(I40E_VF_STATE_DISABLED, &vf->vf_states))\n\t\treturn -EINVAL;\n\n\t \n\tret = virtchnl_vc_validate_vf_msg(&vf->vf_ver, v_opcode, msg, msglen);\n\n\tif (ret) {\n\t\ti40e_vc_send_resp_to_vf(vf, v_opcode, -EINVAL);\n\t\tdev_err(&pf->pdev->dev, \"Invalid message from VF %d, opcode %d, len %d\\n\",\n\t\t\tlocal_vf_id, v_opcode, msglen);\n\t\treturn ret;\n\t}\n\n\tswitch (v_opcode) {\n\tcase VIRTCHNL_OP_VERSION:\n\t\tret = i40e_vc_get_version_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_VF_RESOURCES:\n\t\tret = i40e_vc_get_vf_resources_msg(vf, msg);\n\t\ti40e_vc_notify_vf_link_state(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_RESET_VF:\n\t\ti40e_vc_reset_vf(vf, false);\n\t\tret = 0;\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE:\n\t\tret = i40e_vc_config_promiscuous_mode_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_VSI_QUEUES:\n\t\tret = i40e_vc_config_queues_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_IRQ_MAP:\n\t\tret = i40e_vc_config_irq_map_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_QUEUES:\n\t\tret = i40e_vc_enable_queues_msg(vf, msg);\n\t\ti40e_vc_notify_vf_link_state(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_QUEUES:\n\t\tret = i40e_vc_disable_queues_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_ETH_ADDR:\n\t\tret = i40e_vc_add_mac_addr_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_ETH_ADDR:\n\t\tret = i40e_vc_del_mac_addr_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_VLAN:\n\t\tret = i40e_vc_add_vlan_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_VLAN:\n\t\tret = i40e_vc_remove_vlan_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_STATS:\n\t\tret = i40e_vc_get_stats_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_RDMA:\n\t\tret = i40e_vc_rdma_msg(vf, msg, msglen);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_RDMA_IRQ_MAP:\n\t\tret = i40e_vc_rdma_qvmap_msg(vf, msg, true);\n\t\tbreak;\n\tcase VIRTCHNL_OP_RELEASE_RDMA_IRQ_MAP:\n\t\tret = i40e_vc_rdma_qvmap_msg(vf, msg, false);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_RSS_KEY:\n\t\tret = i40e_vc_config_rss_key(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_RSS_LUT:\n\t\tret = i40e_vc_config_rss_lut(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_RSS_HENA_CAPS:\n\t\tret = i40e_vc_get_rss_hena(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_SET_RSS_HENA:\n\t\tret = i40e_vc_set_rss_hena(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_VLAN_STRIPPING:\n\t\tret = i40e_vc_enable_vlan_stripping(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_VLAN_STRIPPING:\n\t\tret = i40e_vc_disable_vlan_stripping(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_REQUEST_QUEUES:\n\t\tret = i40e_vc_request_queues_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_CHANNELS:\n\t\tret = i40e_vc_add_qch_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_CHANNELS:\n\t\tret = i40e_vc_del_qch_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_CLOUD_FILTER:\n\t\tret = i40e_vc_add_cloud_filter(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_CLOUD_FILTER:\n\t\tret = i40e_vc_del_cloud_filter(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_UNKNOWN:\n\tdefault:\n\t\tdev_err(&pf->pdev->dev, \"Unsupported opcode %d from VF %d\\n\",\n\t\t\tv_opcode, local_vf_id);\n\t\tret = i40e_vc_send_resp_to_vf(vf, v_opcode,\n\t\t\t\t\t      -EOPNOTSUPP);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nint i40e_vc_process_vflr_event(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg, reg_idx, bit_idx;\n\tstruct i40e_vf *vf;\n\tint vf_id;\n\n\tif (!test_bit(__I40E_VFLR_EVENT_PENDING, pf->state))\n\t\treturn 0;\n\n\t \n\treg = rd32(hw, I40E_PFINT_ICR0_ENA);\n\treg |= I40E_PFINT_ICR0_ENA_VFLR_MASK;\n\twr32(hw, I40E_PFINT_ICR0_ENA, reg);\n\ti40e_flush(hw);\n\n\tclear_bit(__I40E_VFLR_EVENT_PENDING, pf->state);\n\tfor (vf_id = 0; vf_id < pf->num_alloc_vfs; vf_id++) {\n\t\treg_idx = (hw->func_caps.vf_base_id + vf_id) / 32;\n\t\tbit_idx = (hw->func_caps.vf_base_id + vf_id) % 32;\n\t\t \n\t\tvf = &pf->vf[vf_id];\n\t\treg = rd32(hw, I40E_GLGEN_VFLRSTAT(reg_idx));\n\t\tif (reg & BIT(bit_idx))\n\t\t\t \n\t\t\ti40e_reset_vf(vf, true);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_validate_vf(struct i40e_pf *pf, int vf_id)\n{\n\tstruct i40e_vsi *vsi;\n\tstruct i40e_vf *vf;\n\tint ret = 0;\n\n\tif (vf_id >= pf->num_alloc_vfs) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Invalid VF Identifier %d\\n\", vf_id);\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\tvf = &pf->vf[vf_id];\n\tvsi = i40e_find_vsi_from_id(pf, vf->lan_vsi_id);\n\tif (!vsi)\n\t\tret = -EINVAL;\nerr_out:\n\treturn ret;\n}\n\n \nstatic bool i40e_check_vf_init_timeout(struct i40e_vf *vf)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 15; i++) {\n\t\tif (test_bit(I40E_VF_STATE_INIT, &vf->vf_states))\n\t\t\treturn true;\n\t\tmsleep(20);\n\t}\n\n\tif (!test_bit(I40E_VF_STATE_INIT, &vf->vf_states)) {\n\t\tdev_err(&vf->pf->pdev->dev,\n\t\t\t\"VF %d still in reset. Try again.\\n\", vf->vf_id);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint i40e_ndo_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_mac_filter *f;\n\tstruct i40e_vf *vf;\n\tint ret = 0;\n\tstruct hlist_node *h;\n\tint bkt;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pf->pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tret = i40e_validate_vf(pf, vf_id);\n\tif (ret)\n\t\tgoto error_param;\n\n\tvf = &pf->vf[vf_id];\n\tif (!i40e_check_vf_init_timeout(vf)) {\n\t\tret = -EAGAIN;\n\t\tgoto error_param;\n\t}\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\n\tif (is_multicast_ether_addr(mac)) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Invalid Ethernet address %pM for VF %d\\n\", mac, vf_id);\n\t\tret = -EINVAL;\n\t\tgoto error_param;\n\t}\n\n\t \n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\n\t \n\tif (!is_zero_ether_addr(vf->default_lan_addr.addr))\n\t\ti40e_del_mac_filter(vsi, vf->default_lan_addr.addr);\n\n\t \n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist)\n\t\t__i40e_del_filter(vsi, f);\n\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\t \n\tif (i40e_sync_vsi_filters(vsi)) {\n\t\tdev_err(&pf->pdev->dev, \"Unable to program ucast filters\\n\");\n\t\tret = -EIO;\n\t\tgoto error_param;\n\t}\n\tether_addr_copy(vf->default_lan_addr.addr, mac);\n\n\tif (is_zero_ether_addr(mac)) {\n\t\tvf->pf_set_mac = false;\n\t\tdev_info(&pf->pdev->dev, \"Removing MAC on VF %d\\n\", vf_id);\n\t} else {\n\t\tvf->pf_set_mac = true;\n\t\tdev_info(&pf->pdev->dev, \"Setting MAC %pM on VF %d\\n\",\n\t\t\t mac, vf_id);\n\t}\n\n\t \n\ti40e_vc_reset_vf(vf, true);\n\tdev_info(&pf->pdev->dev, \"Bring down and up the VF interface to make this change effective.\\n\");\n\nerror_param:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \nint i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id,\n\t\t\t      u16 vlan_id, u8 qos, __be16 vlan_proto)\n{\n\tu16 vlanprio = vlan_id | (qos << I40E_VLAN_PRIORITY_SHIFT);\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tbool allmulti = false, alluni = false;\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_vsi *vsi;\n\tstruct i40e_vf *vf;\n\tint ret = 0;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pf->pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tret = i40e_validate_vf(pf, vf_id);\n\tif (ret)\n\t\tgoto error_pvid;\n\n\tif ((vlan_id > I40E_MAX_VLANID) || (qos > 7)) {\n\t\tdev_err(&pf->pdev->dev, \"Invalid VF Parameters\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_pvid;\n\t}\n\n\tif (vlan_proto != htons(ETH_P_8021Q)) {\n\t\tdev_err(&pf->pdev->dev, \"VF VLAN protocol is not supported\\n\");\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto error_pvid;\n\t}\n\n\tvf = &pf->vf[vf_id];\n\tif (!i40e_check_vf_init_timeout(vf)) {\n\t\tret = -EAGAIN;\n\t\tgoto error_pvid;\n\t}\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\n\tif (le16_to_cpu(vsi->info.pvid) == vlanprio)\n\t\t \n\t\tgoto error_pvid;\n\n\ti40e_vlan_stripping_enable(vsi);\n\n\t \n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\n\t \n\tif ((!(vlan_id || qos) ||\n\t     vlanprio != le16_to_cpu(vsi->info.pvid)) &&\n\t    vsi->info.pvid) {\n\t\tret = i40e_add_vlan_all_mac(vsi, I40E_VLAN_ANY);\n\t\tif (ret) {\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"add VF VLAN failed, ret=%d aq_err=%d\\n\", ret,\n\t\t\t\t vsi->back->hw.aq.asq_last_status);\n\t\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t\t\tgoto error_pvid;\n\t\t}\n\t}\n\n\tif (vsi->info.pvid) {\n\t\t \n\t\ti40e_rm_vlan_all_mac(vsi, (le16_to_cpu(vsi->info.pvid) &\n\t\t\t\t\t   VLAN_VID_MASK));\n\t}\n\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\t \n\tret = i40e_config_vf_promiscuous_mode(vf, vf->lan_vsi_id,\n\t\t\t\t\t      allmulti, alluni);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev, \"Unable to config VF promiscuous mode\\n\");\n\t\tgoto error_pvid;\n\t}\n\n\tif (vlan_id || qos)\n\t\tret = i40e_vsi_add_pvid(vsi, vlanprio);\n\telse\n\t\ti40e_vsi_remove_pvid(vsi);\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\n\tif (vlan_id) {\n\t\tdev_info(&pf->pdev->dev, \"Setting VLAN %d, QOS 0x%x on VF %d\\n\",\n\t\t\t vlan_id, qos, vf_id);\n\n\t\t \n\t\tret = i40e_add_vlan_all_mac(vsi, vlan_id);\n\t\tif (ret) {\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"add VF VLAN failed, ret=%d aq_err=%d\\n\", ret,\n\t\t\t\t vsi->back->hw.aq.asq_last_status);\n\t\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t\t\tgoto error_pvid;\n\t\t}\n\n\t\t \n\t\ti40e_rm_vlan_all_mac(vsi, I40E_VLAN_ANY);\n\t}\n\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\tif (test_bit(I40E_VF_STATE_UC_PROMISC, &vf->vf_states))\n\t\talluni = true;\n\n\tif (test_bit(I40E_VF_STATE_MC_PROMISC, &vf->vf_states))\n\t\tallmulti = true;\n\n\t \n\ti40e_service_event_schedule(vsi->back);\n\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev, \"Unable to update VF vsi context\\n\");\n\t\tgoto error_pvid;\n\t}\n\n\t \n\tvf->port_vlan_id = le16_to_cpu(vsi->info.pvid);\n\n\ti40e_vc_reset_vf(vf, true);\n\t \n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\n\tret = i40e_config_vf_promiscuous_mode(vf, vsi->id, allmulti, alluni);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev, \"Unable to config vf promiscuous mode\\n\");\n\t\tgoto error_pvid;\n\t}\n\n\tret = 0;\n\nerror_pvid:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \nint i40e_ndo_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate,\n\t\t       int max_tx_rate)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_vsi *vsi;\n\tstruct i40e_vf *vf;\n\tint ret = 0;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pf->pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tret = i40e_validate_vf(pf, vf_id);\n\tif (ret)\n\t\tgoto error;\n\n\tif (min_tx_rate) {\n\t\tdev_err(&pf->pdev->dev, \"Invalid min tx rate (%d) (greater than 0) specified for VF %d.\\n\",\n\t\t\tmin_tx_rate, vf_id);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tvf = &pf->vf[vf_id];\n\tif (!i40e_check_vf_init_timeout(vf)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\n\tret = i40e_set_bw_limit(vsi, vsi->seid, max_tx_rate);\n\tif (ret)\n\t\tgoto error;\n\n\tvf->tx_rate = max_tx_rate;\nerror:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \nint i40e_ndo_get_vf_config(struct net_device *netdev,\n\t\t\t   int vf_id, struct ifla_vf_info *ivi)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_vf *vf;\n\tint ret = 0;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pf->pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tret = i40e_validate_vf(pf, vf_id);\n\tif (ret)\n\t\tgoto error_param;\n\n\tvf = &pf->vf[vf_id];\n\t \n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\tif (!vsi) {\n\t\tret = -ENOENT;\n\t\tgoto error_param;\n\t}\n\n\tivi->vf = vf_id;\n\n\tether_addr_copy(ivi->mac, vf->default_lan_addr.addr);\n\n\tivi->max_tx_rate = vf->tx_rate;\n\tivi->min_tx_rate = 0;\n\tivi->vlan = le16_to_cpu(vsi->info.pvid) & I40E_VLAN_MASK;\n\tivi->qos = (le16_to_cpu(vsi->info.pvid) & I40E_PRIORITY_MASK) >>\n\t\t   I40E_VLAN_PRIORITY_SHIFT;\n\tif (vf->link_forced == false)\n\t\tivi->linkstate = IFLA_VF_LINK_STATE_AUTO;\n\telse if (vf->link_up == true)\n\t\tivi->linkstate = IFLA_VF_LINK_STATE_ENABLE;\n\telse\n\t\tivi->linkstate = IFLA_VF_LINK_STATE_DISABLE;\n\tivi->spoofchk = vf->spoofchk;\n\tivi->trusted = vf->trusted;\n\tret = 0;\n\nerror_param:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \nint i40e_ndo_set_vf_link_state(struct net_device *netdev, int vf_id, int link)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_link_status *ls = &pf->hw.phy.link_info;\n\tstruct virtchnl_pf_event pfe;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vf *vf;\n\tint abs_vf_id;\n\tint ret = 0;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pf->pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (vf_id >= pf->num_alloc_vfs) {\n\t\tdev_err(&pf->pdev->dev, \"Invalid VF Identifier %d\\n\", vf_id);\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\n\tvf = &pf->vf[vf_id];\n\tabs_vf_id = vf->vf_id + hw->func_caps.vf_base_id;\n\n\tpfe.event = VIRTCHNL_EVENT_LINK_CHANGE;\n\tpfe.severity = PF_EVENT_SEVERITY_INFO;\n\n\tswitch (link) {\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\t\tvf->link_forced = false;\n\t\ti40e_set_vf_link_state(vf, &pfe, ls);\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\tvf->link_forced = true;\n\t\tvf->link_up = true;\n\t\ti40e_set_vf_link_state(vf, &pfe, ls);\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tvf->link_forced = true;\n\t\tvf->link_up = false;\n\t\ti40e_set_vf_link_state(vf, &pfe, ls);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\t \n\ti40e_aq_send_msg_to_vf(hw, abs_vf_id, VIRTCHNL_OP_EVENT,\n\t\t\t       0, (u8 *)&pfe, sizeof(pfe), NULL);\n\nerror_out:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \nint i40e_ndo_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool enable)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_vsi_context ctxt;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vf *vf;\n\tint ret = 0;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pf->pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (vf_id >= pf->num_alloc_vfs) {\n\t\tdev_err(&pf->pdev->dev, \"Invalid VF Identifier %d\\n\", vf_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tvf = &(pf->vf[vf_id]);\n\tif (!i40e_check_vf_init_timeout(vf)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (enable == vf->spoofchk)\n\t\tgoto out;\n\n\tvf->spoofchk = enable;\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tctxt.seid = pf->vsi[vf->lan_vsi_idx]->seid;\n\tctxt.pf_num = pf->hw.pf_id;\n\tctxt.info.valid_sections = cpu_to_le16(I40E_AQ_VSI_PROP_SECURITY_VALID);\n\tif (enable)\n\t\tctxt.info.sec_flags |= (I40E_AQ_VSI_SEC_FLAG_ENABLE_VLAN_CHK |\n\t\t\t\t\tI40E_AQ_VSI_SEC_FLAG_ENABLE_MAC_CHK);\n\tret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev, \"Error %d updating VSI parameters\\n\",\n\t\t\tret);\n\t\tret = -EIO;\n\t}\nout:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \nint i40e_ndo_set_vf_trust(struct net_device *netdev, int vf_id, bool setting)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_vf *vf;\n\tint ret = 0;\n\n\tif (test_and_set_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state)) {\n\t\tdev_warn(&pf->pdev->dev, \"Unable to configure VFs, other operation is pending.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (vf_id >= pf->num_alloc_vfs) {\n\t\tdev_err(&pf->pdev->dev, \"Invalid VF Identifier %d\\n\", vf_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (pf->flags & I40E_FLAG_MFP_ENABLED) {\n\t\tdev_err(&pf->pdev->dev, \"Trusted VF not supported in MFP mode.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tvf = &pf->vf[vf_id];\n\n\tif (setting == vf->trusted)\n\t\tgoto out;\n\n\tvf->trusted = setting;\n\n\t \n\tset_bit(__I40E_MACVLAN_SYNC_PENDING, pf->state);\n\tpf->vsi[vf->lan_vsi_idx]->flags |= I40E_VSI_FLAG_FILTER_CHANGED;\n\n\ti40e_vc_reset_vf(vf, true);\n\tdev_info(&pf->pdev->dev, \"VF %u is now %strusted\\n\",\n\t\t vf_id, setting ? \"\" : \"un\");\n\n\tif (vf->adq_enabled) {\n\t\tif (!vf->trusted) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"VF %u no longer Trusted, deleting all cloud filters\\n\",\n\t\t\t\t vf_id);\n\t\t\ti40e_del_all_cloud_filters(vf);\n\t\t}\n\t}\n\nout:\n\tclear_bit(__I40E_VIRTCHNL_OP_PENDING, pf->state);\n\treturn ret;\n}\n\n \nint i40e_get_vf_stats(struct net_device *netdev, int vf_id,\n\t\t      struct ifla_vf_stats *vf_stats)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_eth_stats *stats;\n\tstruct i40e_vsi *vsi;\n\tstruct i40e_vf *vf;\n\n\t \n\tif (i40e_validate_vf(pf, vf_id))\n\t\treturn -EINVAL;\n\n\tvf = &pf->vf[vf_id];\n\tif (!test_bit(I40E_VF_STATE_INIT, &vf->vf_states)) {\n\t\tdev_err(&pf->pdev->dev, \"VF %d in reset. Try again.\\n\", vf_id);\n\t\treturn -EBUSY;\n\t}\n\n\tvsi = pf->vsi[vf->lan_vsi_idx];\n\tif (!vsi)\n\t\treturn -EINVAL;\n\n\ti40e_update_eth_stats(vsi);\n\tstats = &vsi->eth_stats;\n\n\tmemset(vf_stats, 0, sizeof(*vf_stats));\n\n\tvf_stats->rx_packets = stats->rx_unicast + stats->rx_broadcast +\n\t\tstats->rx_multicast;\n\tvf_stats->tx_packets = stats->tx_unicast + stats->tx_broadcast +\n\t\tstats->tx_multicast;\n\tvf_stats->rx_bytes   = stats->rx_bytes;\n\tvf_stats->tx_bytes   = stats->tx_bytes;\n\tvf_stats->broadcast  = stats->rx_broadcast;\n\tvf_stats->multicast  = stats->rx_multicast;\n\tvf_stats->rx_dropped = stats->rx_discards;\n\tvf_stats->tx_dropped = stats->tx_discards;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}