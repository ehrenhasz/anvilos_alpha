{
  "module_name": "i40e_ptp.c",
  "hash_id": "e200639f9e19283ef17545b7307f8698a1a3db5ed805488bd60443d5a79b5184",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_ptp.c",
  "human_readable_source": "\n \n\n#include \"i40e.h\"\n#include <linux/ptp_classify.h>\n#include <linux/posix-clock.h>\n\n \n#define I40E_PTP_40GB_INCVAL\t\t0x0199999999ULL\n#define I40E_PTP_10GB_INCVAL_MULT\t2\n#define I40E_PTP_5GB_INCVAL_MULT\t2\n#define I40E_PTP_1GB_INCVAL_MULT\t20\n#define I40E_ISGN\t\t\t0x80000000\n\n#define I40E_PRTTSYN_CTL1_TSYNTYPE_V1  BIT(I40E_PRTTSYN_CTL1_TSYNTYPE_SHIFT)\n#define I40E_PRTTSYN_CTL1_TSYNTYPE_V2  (2 << \\\n\t\t\t\t\tI40E_PRTTSYN_CTL1_TSYNTYPE_SHIFT)\n#define I40E_SUBDEV_ID_25G_PTP_PIN\t0xB\n\nenum i40e_ptp_pin {\n\tSDP3_2 = 0,\n\tSDP3_3,\n\tGPIO_4\n};\n\nenum i40e_can_set_pins_t {\n\tCANT_DO_PINS = -1,\n\tCAN_SET_PINS,\n\tCAN_DO_PINS\n};\n\nstatic struct ptp_pin_desc sdp_desc[] = {\n\t \n\t{\"SDP3_2\", SDP3_2, PTP_PF_NONE, 0},\n\t{\"SDP3_3\", SDP3_3, PTP_PF_NONE, 1},\n\t{\"GPIO_4\", GPIO_4, PTP_PF_NONE, 1},\n};\n\nenum i40e_ptp_gpio_pin_state {\n\tend = -2,\n\tinvalid,\n\toff,\n\tin_A,\n\tin_B,\n\tout_A,\n\tout_B,\n};\n\nstatic const char * const i40e_ptp_gpio_pin_state2str[] = {\n\t\"off\", \"in_A\", \"in_B\", \"out_A\", \"out_B\"\n};\n\nenum i40e_ptp_led_pin_state {\n\tled_end = -2,\n\tlow = 0,\n\thigh,\n};\n\nstruct i40e_ptp_pins_settings {\n\tenum i40e_ptp_gpio_pin_state sdp3_2;\n\tenum i40e_ptp_gpio_pin_state sdp3_3;\n\tenum i40e_ptp_gpio_pin_state gpio_4;\n\tenum i40e_ptp_led_pin_state led2_0;\n\tenum i40e_ptp_led_pin_state led2_1;\n\tenum i40e_ptp_led_pin_state led3_0;\n\tenum i40e_ptp_led_pin_state led3_1;\n};\n\nstatic const struct i40e_ptp_pins_settings\n\ti40e_ptp_pin_led_allowed_states[] = {\n\t{off,\toff,\toff,\t\thigh,\thigh,\thigh,\thigh},\n\t{off,\tin_A,\toff,\t\thigh,\thigh,\thigh,\tlow},\n\t{off,\tout_A,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{off,\tin_B,\toff,\t\thigh,\thigh,\thigh,\tlow},\n\t{off,\tout_B,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{in_A,\toff,\toff,\t\thigh,\thigh,\thigh,\tlow},\n\t{in_A,\tin_B,\toff,\t\thigh,\thigh,\thigh,\tlow},\n\t{in_A,\tout_B,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{out_A,\toff,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{out_A,\tin_B,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{in_B,\toff,\toff,\t\thigh,\thigh,\thigh,\tlow},\n\t{in_B,\tin_A,\toff,\t\thigh,\thigh,\thigh,\tlow},\n\t{in_B,\tout_A,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{out_B,\toff,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{out_B,\tin_A,\toff,\t\thigh,\tlow,\thigh,\thigh},\n\t{off,\toff,\tin_A,\t\thigh,\thigh,\tlow,\thigh},\n\t{off,\tout_A,\tin_A,\t\thigh,\tlow,\tlow,\thigh},\n\t{off,\tin_B,\tin_A,\t\thigh,\thigh,\tlow,\tlow},\n\t{off,\tout_B,\tin_A,\t\thigh,\tlow,\tlow,\thigh},\n\t{out_A,\toff,\tin_A,\t\thigh,\tlow,\tlow,\thigh},\n\t{out_A,\tin_B,\tin_A,\t\thigh,\tlow,\tlow,\thigh},\n\t{in_B,\toff,\tin_A,\t\thigh,\thigh,\tlow,\tlow},\n\t{in_B,\tout_A,\tin_A,\t\thigh,\tlow,\tlow,\thigh},\n\t{out_B,\toff,\tin_A,\t\thigh,\tlow,\tlow,\thigh},\n\t{off,\toff,\tout_A,\t\tlow,\thigh,\thigh,\thigh},\n\t{off,\tin_A,\tout_A,\t\tlow,\thigh,\thigh,\tlow},\n\t{off,\tin_B,\tout_A,\t\tlow,\thigh,\thigh,\tlow},\n\t{off,\tout_B,\tout_A,\t\tlow,\tlow,\thigh,\thigh},\n\t{in_A,\toff,\tout_A,\t\tlow,\thigh,\thigh,\tlow},\n\t{in_A,\tin_B,\tout_A,\t\tlow,\thigh,\thigh,\tlow},\n\t{in_A,\tout_B,\tout_A,\t\tlow,\tlow,\thigh,\thigh},\n\t{in_B,\toff,\tout_A,\t\tlow,\thigh,\thigh,\tlow},\n\t{in_B,\tin_A,\tout_A,\t\tlow,\thigh,\thigh,\tlow},\n\t{out_B,\toff,\tout_A,\t\tlow,\tlow,\thigh,\thigh},\n\t{out_B,\tin_A,\tout_A,\t\tlow,\tlow,\thigh,\thigh},\n\t{off,\toff,\tin_B,\t\thigh,\thigh,\tlow,\thigh},\n\t{off,\tin_A,\tin_B,\t\thigh,\thigh,\tlow,\tlow},\n\t{off,\tout_A,\tin_B,\t\thigh,\tlow,\tlow,\thigh},\n\t{off,\tout_B,\tin_B,\t\thigh,\tlow,\tlow,\thigh},\n\t{in_A,\toff,\tin_B,\t\thigh,\thigh,\tlow,\tlow},\n\t{in_A,\tout_B,\tin_B,\t\thigh,\tlow,\tlow,\thigh},\n\t{out_A,\toff,\tin_B,\t\thigh,\tlow,\tlow,\thigh},\n\t{out_B,\toff,\tin_B,\t\thigh,\tlow,\tlow,\thigh},\n\t{out_B,\tin_A,\tin_B,\t\thigh,\tlow,\tlow,\thigh},\n\t{off,\toff,\tout_B,\t\tlow,\thigh,\thigh,\thigh},\n\t{off,\tin_A,\tout_B,\t\tlow,\thigh,\thigh,\tlow},\n\t{off,\tout_A,\tout_B,\t\tlow,\tlow,\thigh,\thigh},\n\t{off,\tin_B,\tout_B,\t\tlow,\thigh,\thigh,\tlow},\n\t{in_A,\toff,\tout_B,\t\tlow,\thigh,\thigh,\tlow},\n\t{in_A,\tin_B,\tout_B,\t\tlow,\thigh,\thigh,\tlow},\n\t{out_A,\toff,\tout_B,\t\tlow,\tlow,\thigh,\thigh},\n\t{out_A,\tin_B,\tout_B,\t\tlow,\tlow,\thigh,\thigh},\n\t{in_B,\toff,\tout_B,\t\tlow,\thigh,\thigh,\tlow},\n\t{in_B,\tin_A,\tout_B,\t\tlow,\thigh,\thigh,\tlow},\n\t{in_B,\tout_A,\tout_B,\t\tlow,\tlow,\thigh,\thigh},\n\t{end,\tend,\tend,\tled_end, led_end, led_end, led_end}\n};\n\nstatic int i40e_ptp_set_pins(struct i40e_pf *pf,\n\t\t\t     struct i40e_ptp_pins_settings *pins);\n\n \nstatic void i40e_ptp_extts0_work(struct work_struct *work)\n{\n\tstruct i40e_pf *pf = container_of(work, struct i40e_pf,\n\t\t\t\t\t  ptp_extts0_work);\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct ptp_clock_event event;\n\tu32 hi, lo;\n\n\t \n\tlo = rd32(hw, I40E_PRTTSYN_EVNT_L(0));\n\thi = rd32(hw, I40E_PRTTSYN_EVNT_H(0));\n\n\tevent.timestamp = (((u64)hi) << 32) | lo;\n\n\tevent.type = PTP_CLOCK_EXTTS;\n\tevent.index = hw->pf_id;\n\n\t \n\tptp_clock_event(pf->ptp_clock, &event);\n}\n\n \nstatic bool i40e_is_ptp_pin_dev(struct i40e_hw *hw)\n{\n\treturn hw->device_id == I40E_DEV_ID_25G_SFP28 &&\n\t       hw->subsystem_device_id == I40E_SUBDEV_ID_25G_PTP_PIN;\n}\n\n \nstatic enum i40e_can_set_pins_t i40e_can_set_pins(struct i40e_pf *pf)\n{\n\tif (!i40e_is_ptp_pin_dev(&pf->hw)) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"PTP external clock not supported.\\n\");\n\t\treturn CANT_DO_PINS;\n\t}\n\n\tif (!pf->ptp_pins) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"PTP PIN manipulation not allowed.\\n\");\n\t\treturn CANT_DO_PINS;\n\t}\n\n\tif (pf->hw.pf_id) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"PTP PINs should be accessed via PF0.\\n\");\n\t\treturn CAN_DO_PINS;\n\t}\n\n\treturn CAN_SET_PINS;\n}\n\n \nstatic void i40_ptp_reset_timing_events(struct i40e_pf *pf)\n{\n\tu32 i;\n\n\tspin_lock_bh(&pf->ptp_rx_lock);\n\tfor (i = 0; i <= I40E_PRTTSYN_RXTIME_L_MAX_INDEX; i++) {\n\t\t \n\t\trd32(&pf->hw, I40E_PRTTSYN_RXTIME_L(i));\n\t\trd32(&pf->hw, I40E_PRTTSYN_RXTIME_H(i));\n\t\tpf->latch_events[i] = 0;\n\t}\n\t \n\trd32(&pf->hw, I40E_PRTTSYN_TXTIME_L);\n\trd32(&pf->hw, I40E_PRTTSYN_TXTIME_H);\n\n\tpf->tx_hwtstamp_timeouts = 0;\n\tpf->tx_hwtstamp_skipped = 0;\n\tpf->rx_hwtstamp_cleared = 0;\n\tpf->latch_event_flags = 0;\n\tspin_unlock_bh(&pf->ptp_rx_lock);\n}\n\n \nstatic int i40e_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t   enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic void i40e_ptp_read(struct i40e_pf *pf, struct timespec64 *ts,\n\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 hi, lo;\n\tu64 ns;\n\n\t \n\tptp_read_system_prets(sts);\n\tlo = rd32(hw, I40E_PRTTSYN_TIME_L);\n\tptp_read_system_postts(sts);\n\thi = rd32(hw, I40E_PRTTSYN_TIME_H);\n\n\tns = (((u64)hi) << 32) | lo;\n\n\t*ts = ns_to_timespec64(ns);\n}\n\n \nstatic void i40e_ptp_write(struct i40e_pf *pf, const struct timespec64 *ts)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu64 ns = timespec64_to_ns(ts);\n\n\t \n\twr32(hw, I40E_PRTTSYN_TIME_L, ns & 0xFFFFFFFF);\n\twr32(hw, I40E_PRTTSYN_TIME_H, ns >> 32);\n}\n\n \nstatic void i40e_ptp_convert_to_hwtstamp(struct skb_shared_hwtstamps *hwtstamps,\n\t\t\t\t\t u64 timestamp)\n{\n\tmemset(hwtstamps, 0, sizeof(*hwtstamps));\n\n\thwtstamps->hwtstamp = ns_to_ktime(timestamp);\n}\n\n \nstatic int i40e_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\n\tstruct i40e_hw *hw = &pf->hw;\n\tu64 adj, base_adj;\n\n\tsmp_mb();  \n\tbase_adj = I40E_PTP_40GB_INCVAL * READ_ONCE(pf->ptp_adj_mult);\n\n\tadj = adjust_by_scaled_ppm(base_adj, scaled_ppm);\n\n\twr32(hw, I40E_PRTTSYN_INC_L, adj & 0xFFFFFFFF);\n\twr32(hw, I40E_PRTTSYN_INC_H, adj >> 32);\n\n\treturn 0;\n}\n\n \nstatic void i40e_ptp_set_1pps_signal_hw(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct timespec64 now;\n\tu64 ns;\n\n\twr32(hw, I40E_PRTTSYN_AUX_0(1), 0);\n\twr32(hw, I40E_PRTTSYN_AUX_1(1), I40E_PRTTSYN_AUX_1_INSTNT);\n\twr32(hw, I40E_PRTTSYN_AUX_0(1), I40E_PRTTSYN_AUX_0_OUT_ENABLE);\n\n\ti40e_ptp_read(pf, &now, NULL);\n\tnow.tv_sec += I40E_PTP_2_SEC_DELAY;\n\tnow.tv_nsec = 0;\n\tns = timespec64_to_ns(&now);\n\n\t \n\twr32(hw, I40E_PRTTSYN_TGT_L(1), ns & 0xFFFFFFFF);\n\t \n\twr32(hw, I40E_PRTTSYN_TGT_H(1), ns >> 32);\n\twr32(hw, I40E_PRTTSYN_CLKO(1), I40E_PTP_HALF_SECOND);\n\twr32(hw, I40E_PRTTSYN_AUX_1(1), I40E_PRTTSYN_AUX_1_INSTNT);\n\twr32(hw, I40E_PRTTSYN_AUX_0(1),\n\t     I40E_PRTTSYN_AUX_0_OUT_ENABLE_CLK_MOD);\n}\n\n \nstatic int i40e_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\n\tstruct i40e_hw *hw = &pf->hw;\n\n\tmutex_lock(&pf->tmreg_lock);\n\n\tif (delta > -999999900LL && delta < 999999900LL) {\n\t\tint neg_adj = 0;\n\t\tu32 timadj;\n\t\tu64 tohw;\n\n\t\tif (delta < 0) {\n\t\t\tneg_adj = 1;\n\t\t\ttohw = -delta;\n\t\t} else {\n\t\t\ttohw = delta;\n\t\t}\n\n\t\ttimadj = tohw & 0x3FFFFFFF;\n\t\tif (neg_adj)\n\t\t\ttimadj |= I40E_ISGN;\n\t\twr32(hw, I40E_PRTTSYN_ADJ, timadj);\n\t} else {\n\t\tstruct timespec64 then, now;\n\n\t\tthen = ns_to_timespec64(delta);\n\t\ti40e_ptp_read(pf, &now, NULL);\n\t\tnow = timespec64_add(now, then);\n\t\ti40e_ptp_write(pf, (const struct timespec64 *)&now);\n\t\ti40e_ptp_set_1pps_signal_hw(pf);\n\t}\n\n\tmutex_unlock(&pf->tmreg_lock);\n\n\treturn 0;\n}\n\n \nstatic int i40e_ptp_gettimex(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t     struct ptp_system_timestamp *sts)\n{\n\tstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\n\n\tmutex_lock(&pf->tmreg_lock);\n\ti40e_ptp_read(pf, ts, sts);\n\tmutex_unlock(&pf->tmreg_lock);\n\n\treturn 0;\n}\n\n \nstatic int i40e_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t    const struct timespec64 *ts)\n{\n\tstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\n\n\tmutex_lock(&pf->tmreg_lock);\n\ti40e_ptp_write(pf, ts);\n\tmutex_unlock(&pf->tmreg_lock);\n\n\treturn 0;\n}\n\n \nstatic int i40e_pps_configure(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *rq,\n\t\t\t      int on)\n{\n\tstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\n\n\tif (!!on)\n\t\ti40e_ptp_set_1pps_signal_hw(pf);\n\n\treturn 0;\n}\n\n \nstatic enum i40e_ptp_gpio_pin_state i40e_pin_state(int index, int func)\n{\n\tenum i40e_ptp_gpio_pin_state state = off;\n\n\tif (index == 0 && func == PTP_PF_EXTTS)\n\t\tstate = in_A;\n\tif (index == 1 && func == PTP_PF_EXTTS)\n\t\tstate = in_B;\n\tif (index == 0 && func == PTP_PF_PEROUT)\n\t\tstate = out_A;\n\tif (index == 1 && func == PTP_PF_PEROUT)\n\t\tstate = out_B;\n\n\treturn state;\n}\n\n \nstatic int i40e_ptp_enable_pin(struct i40e_pf *pf, unsigned int chan,\n\t\t\t       enum ptp_pin_function func, int on)\n{\n\tenum i40e_ptp_gpio_pin_state *pin = NULL;\n\tstruct i40e_ptp_pins_settings pins;\n\tint pin_index;\n\n\t \n\tif (pf->hw.pf_id)\n\t\treturn 0;\n\n\t \n\tpins.sdp3_2 = pf->ptp_pins->sdp3_2;\n\tpins.sdp3_3 = pf->ptp_pins->sdp3_3;\n\tpins.gpio_4 = pf->ptp_pins->gpio_4;\n\n\t \n\tif (on) {\n\t\tpin_index = ptp_find_pin(pf->ptp_clock, func, chan);\n\t\tif (pin_index < 0)\n\t\t\treturn -EBUSY;\n\n\t\tswitch (pin_index) {\n\t\tcase SDP3_2:\n\t\t\tpin = &pins.sdp3_2;\n\t\t\tbreak;\n\t\tcase SDP3_3:\n\t\t\tpin = &pins.sdp3_3;\n\t\t\tbreak;\n\t\tcase GPIO_4:\n\t\t\tpin = &pins.gpio_4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*pin = i40e_pin_state(chan, func);\n\t} else {\n\t\tpins.sdp3_2 = off;\n\t\tpins.sdp3_3 = off;\n\t\tpins.gpio_4 = off;\n\t}\n\n\treturn i40e_ptp_set_pins(pf, &pins) ? -EINVAL : 0;\n}\n\n \nstatic int i40e_ptp_feature_enable(struct ptp_clock_info *ptp,\n\t\t\t\t   struct ptp_clock_request *rq,\n\t\t\t\t   int on)\n{\n\tstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\n\n\tenum ptp_pin_function func;\n\tunsigned int chan;\n\n\t \n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tfunc = PTP_PF_EXTTS;\n\t\tchan = rq->extts.index;\n\t\tbreak;\n\tcase PTP_CLK_REQ_PEROUT:\n\t\tfunc = PTP_PF_PEROUT;\n\t\tchan = rq->perout.index;\n\t\tbreak;\n\tcase PTP_CLK_REQ_PPS:\n\t\treturn i40e_pps_configure(ptp, rq, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn i40e_ptp_enable_pin(pf, chan, func, on);\n}\n\n \nstatic u32 i40e_ptp_get_rx_events(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 prttsyn_stat, new_latch_events;\n\tint  i;\n\n\tprttsyn_stat = rd32(hw, I40E_PRTTSYN_STAT_1);\n\tnew_latch_events = prttsyn_stat & ~pf->latch_event_flags;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (new_latch_events & BIT(i))\n\t\t\tpf->latch_events[i] = jiffies;\n\t}\n\n\t \n\tpf->latch_event_flags = prttsyn_stat;\n\n\treturn prttsyn_stat;\n}\n\n \nvoid i40e_ptp_rx_hang(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tunsigned int i, cleared = 0;\n\n\t \n\tif (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_rx)\n\t\treturn;\n\n\tspin_lock_bh(&pf->ptp_rx_lock);\n\n\t \n\ti40e_ptp_get_rx_events(pf);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif ((pf->latch_event_flags & BIT(i)) &&\n\t\t    time_is_before_jiffies(pf->latch_events[i] + HZ)) {\n\t\t\trd32(hw, I40E_PRTTSYN_RXTIME_H(i));\n\t\t\tpf->latch_event_flags &= ~BIT(i);\n\t\t\tcleared++;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&pf->ptp_rx_lock);\n\n\t \n\tif (cleared > 2)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Dropped %d missed RXTIME timestamp events\\n\",\n\t\t\tcleared);\n\n\t \n\tpf->rx_hwtstamp_cleared += cleared;\n}\n\n \nvoid i40e_ptp_tx_hang(struct i40e_pf *pf)\n{\n\tstruct sk_buff *skb;\n\n\tif (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_tx)\n\t\treturn;\n\n\t \n\tif (!test_bit(__I40E_PTP_TX_IN_PROGRESS, pf->state))\n\t\treturn;\n\n\t \n\tif (time_is_before_jiffies(pf->ptp_tx_start + HZ)) {\n\t\tskb = pf->ptp_tx_skb;\n\t\tpf->ptp_tx_skb = NULL;\n\t\tclear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, pf->state);\n\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t\tpf->tx_hwtstamp_timeouts++;\n\t}\n}\n\n \nvoid i40e_ptp_tx_hwtstamp(struct i40e_pf *pf)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct sk_buff *skb = pf->ptp_tx_skb;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 hi, lo;\n\tu64 ns;\n\n\tif (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_tx)\n\t\treturn;\n\n\t \n\tif (!pf->ptp_tx_skb)\n\t\treturn;\n\n\tlo = rd32(hw, I40E_PRTTSYN_TXTIME_L);\n\thi = rd32(hw, I40E_PRTTSYN_TXTIME_H);\n\n\tns = (((u64)hi) << 32) | lo;\n\ti40e_ptp_convert_to_hwtstamp(&shhwtstamps, ns);\n\n\t \n\tpf->ptp_tx_skb = NULL;\n\tclear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, pf->state);\n\n\t \n\tskb_tstamp_tx(skb, &shhwtstamps);\n\tdev_kfree_skb_any(skb);\n}\n\n \nvoid i40e_ptp_rx_hwtstamp(struct i40e_pf *pf, struct sk_buff *skb, u8 index)\n{\n\tu32 prttsyn_stat, hi, lo;\n\tstruct i40e_hw *hw;\n\tu64 ns;\n\n\t \n\tif (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_rx)\n\t\treturn;\n\n\thw = &pf->hw;\n\n\tspin_lock_bh(&pf->ptp_rx_lock);\n\n\t \n\tprttsyn_stat = i40e_ptp_get_rx_events(pf);\n\n\t \n\tif (!(prttsyn_stat & BIT(index))) {\n\t\tspin_unlock_bh(&pf->ptp_rx_lock);\n\t\treturn;\n\t}\n\n\t \n\tpf->latch_event_flags &= ~BIT(index);\n\n\tlo = rd32(hw, I40E_PRTTSYN_RXTIME_L(index));\n\thi = rd32(hw, I40E_PRTTSYN_RXTIME_H(index));\n\n\tspin_unlock_bh(&pf->ptp_rx_lock);\n\n\tns = (((u64)hi) << 32) | lo;\n\n\ti40e_ptp_convert_to_hwtstamp(skb_hwtstamps(skb), ns);\n}\n\n \nvoid i40e_ptp_set_increment(struct i40e_pf *pf)\n{\n\tstruct i40e_link_status *hw_link_info;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu64 incval;\n\tu32 mult;\n\n\thw_link_info = &hw->phy.link_info;\n\n\ti40e_aq_get_link_info(&pf->hw, true, NULL, NULL);\n\n\tswitch (hw_link_info->link_speed) {\n\tcase I40E_LINK_SPEED_10GB:\n\t\tmult = I40E_PTP_10GB_INCVAL_MULT;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_5GB:\n\t\tmult = I40E_PTP_5GB_INCVAL_MULT;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_1GB:\n\t\tmult = I40E_PTP_1GB_INCVAL_MULT;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_100MB:\n\t{\n\t\tstatic int warn_once;\n\n\t\tif (!warn_once) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"1588 functionality is not supported at 100 Mbps. Stopping the PHC.\\n\");\n\t\t\twarn_once++;\n\t\t}\n\t\tmult = 0;\n\t\tbreak;\n\t}\n\tcase I40E_LINK_SPEED_40GB:\n\tdefault:\n\t\tmult = 1;\n\t\tbreak;\n\t}\n\n\t \n\tincval = I40E_PTP_40GB_INCVAL * mult;\n\n\t \n\twr32(hw, I40E_PRTTSYN_INC_L, incval & 0xFFFFFFFF);\n\twr32(hw, I40E_PRTTSYN_INC_H, incval >> 32);\n\n\t \n\tWRITE_ONCE(pf->ptp_adj_mult, mult);\n\tsmp_mb();  \n}\n\n \nint i40e_ptp_get_ts_config(struct i40e_pf *pf, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config *config = &pf->tstamp_config;\n\n\tif (!(pf->flags & I40E_FLAG_PTP))\n\t\treturn -EOPNOTSUPP;\n\n\treturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nstatic void i40e_ptp_free_pins(struct i40e_pf *pf)\n{\n\tif (i40e_is_ptp_pin_dev(&pf->hw)) {\n\t\tkfree(pf->ptp_pins);\n\t\tkfree(pf->ptp_caps.pin_config);\n\t\tpf->ptp_pins = NULL;\n\t}\n}\n\n \nstatic void i40e_ptp_set_pin_hw(struct i40e_hw *hw,\n\t\t\t\tunsigned int pin,\n\t\t\t\tenum i40e_ptp_gpio_pin_state state)\n{\n\tswitch (state) {\n\tcase off:\n\t\twr32(hw, I40E_GLGEN_GPIO_CTL(pin), 0);\n\t\tbreak;\n\tcase in_A:\n\t\twr32(hw, I40E_GLGEN_GPIO_CTL(pin),\n\t\t     I40E_GLGEN_GPIO_CTL_PORT_0_IN_TIMESYNC_0);\n\t\tbreak;\n\tcase in_B:\n\t\twr32(hw, I40E_GLGEN_GPIO_CTL(pin),\n\t\t     I40E_GLGEN_GPIO_CTL_PORT_1_IN_TIMESYNC_0);\n\t\tbreak;\n\tcase out_A:\n\t\twr32(hw, I40E_GLGEN_GPIO_CTL(pin),\n\t\t     I40E_GLGEN_GPIO_CTL_PORT_0_OUT_TIMESYNC_1);\n\t\tbreak;\n\tcase out_B:\n\t\twr32(hw, I40E_GLGEN_GPIO_CTL(pin),\n\t\t     I40E_GLGEN_GPIO_CTL_PORT_1_OUT_TIMESYNC_1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void i40e_ptp_set_led_hw(struct i40e_hw *hw,\n\t\t\t\tunsigned int led,\n\t\t\t\tenum i40e_ptp_led_pin_state state)\n{\n\tswitch (state) {\n\tcase low:\n\t\twr32(hw, I40E_GLGEN_GPIO_SET,\n\t\t     I40E_GLGEN_GPIO_SET_DRV_SDP_DATA | led);\n\t\tbreak;\n\tcase high:\n\t\twr32(hw, I40E_GLGEN_GPIO_SET,\n\t\t     I40E_GLGEN_GPIO_SET_DRV_SDP_DATA |\n\t\t     I40E_GLGEN_GPIO_SET_SDP_DATA_HI | led);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void i40e_ptp_init_leds_hw(struct i40e_hw *hw)\n{\n\twr32(hw, I40E_GLGEN_GPIO_CTL(I40E_LED2_0),\n\t     I40E_GLGEN_GPIO_CTL_LED_INIT);\n\twr32(hw, I40E_GLGEN_GPIO_CTL(I40E_LED2_1),\n\t     I40E_GLGEN_GPIO_CTL_LED_INIT);\n\twr32(hw, I40E_GLGEN_GPIO_CTL(I40E_LED3_0),\n\t     I40E_GLGEN_GPIO_CTL_LED_INIT);\n\twr32(hw, I40E_GLGEN_GPIO_CTL(I40E_LED3_1),\n\t     I40E_GLGEN_GPIO_CTL_LED_INIT);\n}\n\n \nstatic void i40e_ptp_set_pins_hw(struct i40e_pf *pf)\n{\n\tconst struct i40e_ptp_pins_settings *pins = pf->ptp_pins;\n\tstruct i40e_hw *hw = &pf->hw;\n\n\t \n\ti40e_ptp_set_pin_hw(hw, I40E_SDP3_2, off);\n\ti40e_ptp_set_pin_hw(hw, I40E_SDP3_3, off);\n\ti40e_ptp_set_pin_hw(hw, I40E_GPIO_4, off);\n\n\ti40e_ptp_set_pin_hw(hw, I40E_SDP3_2, pins->sdp3_2);\n\ti40e_ptp_set_pin_hw(hw, I40E_SDP3_3, pins->sdp3_3);\n\ti40e_ptp_set_pin_hw(hw, I40E_GPIO_4, pins->gpio_4);\n\n\ti40e_ptp_set_led_hw(hw, I40E_LED2_0, pins->led2_0);\n\ti40e_ptp_set_led_hw(hw, I40E_LED2_1, pins->led2_1);\n\ti40e_ptp_set_led_hw(hw, I40E_LED3_0, pins->led3_0);\n\ti40e_ptp_set_led_hw(hw, I40E_LED3_1, pins->led3_1);\n\n\tdev_info(&pf->pdev->dev,\n\t\t \"PTP configuration set to: SDP3_2: %s,  SDP3_3: %s,  GPIO_4: %s.\\n\",\n\t\t i40e_ptp_gpio_pin_state2str[pins->sdp3_2],\n\t\t i40e_ptp_gpio_pin_state2str[pins->sdp3_3],\n\t\t i40e_ptp_gpio_pin_state2str[pins->gpio_4]);\n}\n\n \nstatic int i40e_ptp_set_pins(struct i40e_pf *pf,\n\t\t\t     struct i40e_ptp_pins_settings *pins)\n{\n\tenum i40e_can_set_pins_t pin_caps = i40e_can_set_pins(pf);\n\tint i = 0;\n\n\tif (pin_caps == CANT_DO_PINS)\n\t\treturn -EOPNOTSUPP;\n\telse if (pin_caps == CAN_DO_PINS)\n\t\treturn 0;\n\n\tif (pins->sdp3_2 == invalid)\n\t\tpins->sdp3_2 = pf->ptp_pins->sdp3_2;\n\tif (pins->sdp3_3 == invalid)\n\t\tpins->sdp3_3 = pf->ptp_pins->sdp3_3;\n\tif (pins->gpio_4 == invalid)\n\t\tpins->gpio_4 = pf->ptp_pins->gpio_4;\n\twhile (i40e_ptp_pin_led_allowed_states[i].sdp3_2 != end) {\n\t\tif (pins->sdp3_2 == i40e_ptp_pin_led_allowed_states[i].sdp3_2 &&\n\t\t    pins->sdp3_3 == i40e_ptp_pin_led_allowed_states[i].sdp3_3 &&\n\t\t    pins->gpio_4 == i40e_ptp_pin_led_allowed_states[i].gpio_4) {\n\t\t\tpins->led2_0 =\n\t\t\t\ti40e_ptp_pin_led_allowed_states[i].led2_0;\n\t\t\tpins->led2_1 =\n\t\t\t\ti40e_ptp_pin_led_allowed_states[i].led2_1;\n\t\t\tpins->led3_0 =\n\t\t\t\ti40e_ptp_pin_led_allowed_states[i].led3_0;\n\t\t\tpins->led3_1 =\n\t\t\t\ti40e_ptp_pin_led_allowed_states[i].led3_1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (i40e_ptp_pin_led_allowed_states[i].sdp3_2 == end) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Unsupported PTP pin configuration: SDP3_2: %s,  SDP3_3: %s,  GPIO_4: %s.\\n\",\n\t\t\t i40e_ptp_gpio_pin_state2str[pins->sdp3_2],\n\t\t\t i40e_ptp_gpio_pin_state2str[pins->sdp3_3],\n\t\t\t i40e_ptp_gpio_pin_state2str[pins->gpio_4]);\n\n\t\treturn -EPERM;\n\t}\n\tmemcpy(pf->ptp_pins, pins, sizeof(*pins));\n\ti40e_ptp_set_pins_hw(pf);\n\ti40_ptp_reset_timing_events(pf);\n\n\treturn 0;\n}\n\n \nint i40e_ptp_alloc_pins(struct i40e_pf *pf)\n{\n\tif (!i40e_is_ptp_pin_dev(&pf->hw))\n\t\treturn 0;\n\n\tpf->ptp_pins =\n\t\tkzalloc(sizeof(struct i40e_ptp_pins_settings), GFP_KERNEL);\n\n\tif (!pf->ptp_pins) {\n\t\tdev_warn(&pf->pdev->dev, \"Cannot allocate memory for PTP pins structure.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpf->ptp_pins->sdp3_2 = off;\n\tpf->ptp_pins->sdp3_3 = off;\n\tpf->ptp_pins->gpio_4 = off;\n\tpf->ptp_pins->led2_0 = high;\n\tpf->ptp_pins->led2_1 = high;\n\tpf->ptp_pins->led3_0 = high;\n\tpf->ptp_pins->led3_1 = high;\n\n\t \n\tif (pf->hw.pf_id)\n\t\treturn 0;\n\n\ti40e_ptp_init_leds_hw(&pf->hw);\n\ti40e_ptp_set_pins_hw(pf);\n\n\treturn 0;\n}\n\n \nstatic int i40e_ptp_set_timestamp_mode(struct i40e_pf *pf,\n\t\t\t\t       struct hwtstamp_config *config)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 tsyntype, regval;\n\n\t \n\tregval = rd32(hw, I40E_PRTTSYN_AUX_0(0));\n\t \n\tregval &= 0;\n\tregval |= (1 << I40E_PRTTSYN_AUX_0_EVNTLVL_SHIFT);\n\t \n\twr32(hw, I40E_PRTTSYN_AUX_0(0), regval);\n\n\t \n\tregval = rd32(hw, I40E_PRTTSYN_CTL0);\n\tregval |= 1 << I40E_PRTTSYN_CTL0_EVENT_INT_ENA_SHIFT;\n\twr32(hw, I40E_PRTTSYN_CTL0, regval);\n\n\tINIT_WORK(&pf->ptp_extts0_work, i40e_ptp_extts0_work);\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tpf->ptp_tx = false;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tpf->ptp_tx = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tpf->ptp_rx = false;\n\t\t \n\t\ttsyntype = I40E_PRTTSYN_CTL1_TSYNTYPE_V1;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\tif (!(pf->hw_features & I40E_HW_PTP_L4_CAPABLE))\n\t\t\treturn -ERANGE;\n\t\tpf->ptp_rx = true;\n\t\ttsyntype = I40E_PRTTSYN_CTL1_V1MESSTYPE0_MASK |\n\t\t\t   I40E_PRTTSYN_CTL1_TSYNTYPE_V1 |\n\t\t\t   I40E_PRTTSYN_CTL1_UDP_ENA_MASK;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tif (!(pf->hw_features & I40E_HW_PTP_L4_CAPABLE))\n\t\t\treturn -ERANGE;\n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tpf->ptp_rx = true;\n\t\ttsyntype = I40E_PRTTSYN_CTL1_V2MESSTYPE0_MASK |\n\t\t\t   I40E_PRTTSYN_CTL1_TSYNTYPE_V2;\n\t\tif (pf->hw_features & I40E_HW_PTP_L4_CAPABLE) {\n\t\t\ttsyntype |= I40E_PRTTSYN_CTL1_UDP_ENA_MASK;\n\t\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\t} else {\n\t\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\t}\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\tcase HWTSTAMP_FILTER_ALL:\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tspin_lock_bh(&pf->ptp_rx_lock);\n\trd32(hw, I40E_PRTTSYN_STAT_0);\n\trd32(hw, I40E_PRTTSYN_TXTIME_H);\n\trd32(hw, I40E_PRTTSYN_RXTIME_H(0));\n\trd32(hw, I40E_PRTTSYN_RXTIME_H(1));\n\trd32(hw, I40E_PRTTSYN_RXTIME_H(2));\n\trd32(hw, I40E_PRTTSYN_RXTIME_H(3));\n\tpf->latch_event_flags = 0;\n\tspin_unlock_bh(&pf->ptp_rx_lock);\n\n\t \n\tregval = rd32(hw, I40E_PRTTSYN_CTL0);\n\tif (pf->ptp_tx)\n\t\tregval |= I40E_PRTTSYN_CTL0_TXTIME_INT_ENA_MASK;\n\telse\n\t\tregval &= ~I40E_PRTTSYN_CTL0_TXTIME_INT_ENA_MASK;\n\twr32(hw, I40E_PRTTSYN_CTL0, regval);\n\n\tregval = rd32(hw, I40E_PFINT_ICR0_ENA);\n\tif (pf->ptp_tx)\n\t\tregval |= I40E_PFINT_ICR0_ENA_TIMESYNC_MASK;\n\telse\n\t\tregval &= ~I40E_PFINT_ICR0_ENA_TIMESYNC_MASK;\n\twr32(hw, I40E_PFINT_ICR0_ENA, regval);\n\n\t \n\tregval = rd32(hw, I40E_PRTTSYN_CTL1);\n\t \n\tregval &= I40E_PRTTSYN_CTL1_TSYNENA_MASK;\n\t \n\tregval |= tsyntype;\n\twr32(hw, I40E_PRTTSYN_CTL1, regval);\n\n\treturn 0;\n}\n\n \nint i40e_ptp_set_ts_config(struct i40e_pf *pf, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (!(pf->flags & I40E_FLAG_PTP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = i40e_ptp_set_timestamp_mode(pf, &config);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpf->tstamp_config = config;\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nstatic int i40e_init_pin_config(struct i40e_pf *pf)\n{\n\tint i;\n\n\tpf->ptp_caps.n_pins = 3;\n\tpf->ptp_caps.n_ext_ts = 2;\n\tpf->ptp_caps.pps = 1;\n\tpf->ptp_caps.n_per_out = 2;\n\n\tpf->ptp_caps.pin_config = kcalloc(pf->ptp_caps.n_pins,\n\t\t\t\t\t  sizeof(*pf->ptp_caps.pin_config),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!pf->ptp_caps.pin_config)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pf->ptp_caps.n_pins; i++) {\n\t\tsnprintf(pf->ptp_caps.pin_config[i].name,\n\t\t\t sizeof(pf->ptp_caps.pin_config[i].name),\n\t\t\t \"%s\", sdp_desc[i].name);\n\t\tpf->ptp_caps.pin_config[i].index = sdp_desc[i].index;\n\t\tpf->ptp_caps.pin_config[i].func = PTP_PF_NONE;\n\t\tpf->ptp_caps.pin_config[i].chan = sdp_desc[i].chan;\n\t}\n\n\tpf->ptp_caps.verify = i40e_ptp_verify;\n\tpf->ptp_caps.enable = i40e_ptp_feature_enable;\n\n\tpf->ptp_caps.pps = 1;\n\n\treturn 0;\n}\n\n \nstatic long i40e_ptp_create_clock(struct i40e_pf *pf)\n{\n\t \n\tif (!IS_ERR_OR_NULL(pf->ptp_clock))\n\t\treturn 0;\n\n\tstrscpy(pf->ptp_caps.name, i40e_driver_name,\n\t\tsizeof(pf->ptp_caps.name) - 1);\n\tpf->ptp_caps.owner = THIS_MODULE;\n\tpf->ptp_caps.max_adj = 999999999;\n\tpf->ptp_caps.adjfine = i40e_ptp_adjfine;\n\tpf->ptp_caps.adjtime = i40e_ptp_adjtime;\n\tpf->ptp_caps.gettimex64 = i40e_ptp_gettimex;\n\tpf->ptp_caps.settime64 = i40e_ptp_settime;\n\tif (i40e_is_ptp_pin_dev(&pf->hw)) {\n\t\tint err = i40e_init_pin_config(pf);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tpf->ptp_clock = ptp_clock_register(&pf->ptp_caps, &pf->pdev->dev);\n\tif (IS_ERR(pf->ptp_clock))\n\t\treturn PTR_ERR(pf->ptp_clock);\n\n\t \n\tpf->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\n\tpf->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\n\n\t \n\tktime_get_real_ts64(&pf->ptp_prev_hw_time);\n\tpf->ptp_reset_start = ktime_get();\n\n\treturn 0;\n}\n\n \nvoid i40e_ptp_save_hw_time(struct i40e_pf *pf)\n{\n\t \n\tif (!(pf->flags & I40E_FLAG_PTP))\n\t\treturn;\n\n\ti40e_ptp_gettimex(&pf->ptp_caps, &pf->ptp_prev_hw_time, NULL);\n\t \n\tpf->ptp_reset_start = ktime_get();\n}\n\n \nvoid i40e_ptp_restore_hw_time(struct i40e_pf *pf)\n{\n\tktime_t delta = ktime_sub(ktime_get(), pf->ptp_reset_start);\n\n\t \n\ttimespec64_add_ns(&pf->ptp_prev_hw_time, ktime_to_ns(delta));\n\n\t \n\ti40e_ptp_settime(&pf->ptp_caps, &pf->ptp_prev_hw_time);\n}\n\n \nvoid i40e_ptp_init(struct i40e_pf *pf)\n{\n\tstruct net_device *netdev = pf->vsi[pf->lan_vsi]->netdev;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 pf_id;\n\tlong err;\n\n\t \n\tpf_id = (rd32(hw, I40E_PRTTSYN_CTL0) & I40E_PRTTSYN_CTL0_PF_ID_MASK) >>\n\t\tI40E_PRTTSYN_CTL0_PF_ID_SHIFT;\n\tif (hw->pf_id != pf_id) {\n\t\tpf->flags &= ~I40E_FLAG_PTP;\n\t\tdev_info(&pf->pdev->dev, \"%s: PTP not supported on %s\\n\",\n\t\t\t __func__,\n\t\t\t netdev->name);\n\t\treturn;\n\t}\n\n\tmutex_init(&pf->tmreg_lock);\n\tspin_lock_init(&pf->ptp_rx_lock);\n\n\t \n\terr = i40e_ptp_create_clock(pf);\n\tif (err) {\n\t\tpf->ptp_clock = NULL;\n\t\tdev_err(&pf->pdev->dev, \"%s: ptp_clock_register failed\\n\",\n\t\t\t__func__);\n\t} else if (pf->ptp_clock) {\n\t\tu32 regval;\n\n\t\tif (pf->hw.debug_mask & I40E_DEBUG_LAN)\n\t\t\tdev_info(&pf->pdev->dev, \"PHC enabled\\n\");\n\t\tpf->flags |= I40E_FLAG_PTP;\n\n\t\t \n\t\tregval = rd32(hw, I40E_PRTTSYN_CTL0);\n\t\tregval |= I40E_PRTTSYN_CTL0_TSYNENA_MASK;\n\t\twr32(hw, I40E_PRTTSYN_CTL0, regval);\n\t\tregval = rd32(hw, I40E_PRTTSYN_CTL1);\n\t\tregval |= I40E_PRTTSYN_CTL1_TSYNENA_MASK;\n\t\twr32(hw, I40E_PRTTSYN_CTL1, regval);\n\n\t\t \n\t\ti40e_ptp_set_increment(pf);\n\n\t\t \n\t\ti40e_ptp_set_timestamp_mode(pf, &pf->tstamp_config);\n\n\t\t \n\t\ti40e_ptp_restore_hw_time(pf);\n\t}\n\n\ti40e_ptp_set_1pps_signal_hw(pf);\n}\n\n \nvoid i40e_ptp_stop(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 regval;\n\n\tpf->flags &= ~I40E_FLAG_PTP;\n\tpf->ptp_tx = false;\n\tpf->ptp_rx = false;\n\n\tif (pf->ptp_tx_skb) {\n\t\tstruct sk_buff *skb = pf->ptp_tx_skb;\n\n\t\tpf->ptp_tx_skb = NULL;\n\t\tclear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, pf->state);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\tif (pf->ptp_clock) {\n\t\tptp_clock_unregister(pf->ptp_clock);\n\t\tpf->ptp_clock = NULL;\n\t\tdev_info(&pf->pdev->dev, \"%s: removed PHC on %s\\n\", __func__,\n\t\t\t pf->vsi[pf->lan_vsi]->netdev->name);\n\t}\n\n\tif (i40e_is_ptp_pin_dev(&pf->hw)) {\n\t\ti40e_ptp_set_pin_hw(hw, I40E_SDP3_2, off);\n\t\ti40e_ptp_set_pin_hw(hw, I40E_SDP3_3, off);\n\t\ti40e_ptp_set_pin_hw(hw, I40E_GPIO_4, off);\n\t}\n\n\tregval = rd32(hw, I40E_PRTTSYN_AUX_0(0));\n\tregval &= ~I40E_PRTTSYN_AUX_0_PTPFLAG_MASK;\n\twr32(hw, I40E_PRTTSYN_AUX_0(0), regval);\n\n\t \n\tregval = rd32(hw, I40E_PRTTSYN_CTL0);\n\tregval &= ~I40E_PRTTSYN_CTL0_EVENT_INT_ENA_MASK;\n\twr32(hw, I40E_PRTTSYN_CTL0, regval);\n\n\ti40e_ptp_free_pins(pf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}