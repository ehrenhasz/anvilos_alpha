{
  "module_name": "i40e_dcb_nl.c",
  "hash_id": "8726079e557f43c3be3acc2ebbdccd972665f3170d564bd92609b5fcdd6ce370",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_I40E_DCB\n#include \"i40e.h\"\n#include <net/dcbnl.h>\n\n#define I40E_DCBNL_STATUS_SUCCESS\t0\n#define I40E_DCBNL_STATUS_ERROR\t\t1\nstatic bool i40e_dcbnl_find_app(struct i40e_dcbx_config *cfg,\n\t\t\t\tstruct i40e_dcb_app_priority_table *app);\n \nstatic void i40e_get_pfc_delay(struct i40e_hw *hw, u16 *delay)\n{\n\tu32 val;\n\n\tval = rd32(hw, I40E_PRTDCB_GENC);\n\t*delay = (u16)((val & I40E_PRTDCB_GENC_PFCLDA_MASK) >>\n\t\t       I40E_PRTDCB_GENC_PFCLDA_SHIFT);\n}\n\n \nstatic int i40e_dcbnl_ieee_getets(struct net_device *dev,\n\t\t\t\t  struct ieee_ets *ets)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\n\tstruct i40e_dcbx_config *dcbxcfg;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tdcbxcfg = &pf->hw.local_dcbx_config;\n\tets->willing = dcbxcfg->etscfg.willing;\n\tets->ets_cap = I40E_MAX_TRAFFIC_CLASS;\n\tets->cbs = dcbxcfg->etscfg.cbs;\n\tmemcpy(ets->tc_tx_bw, dcbxcfg->etscfg.tcbwtable,\n\t\tsizeof(ets->tc_tx_bw));\n\tmemcpy(ets->tc_rx_bw, dcbxcfg->etscfg.tcbwtable,\n\t\tsizeof(ets->tc_rx_bw));\n\tmemcpy(ets->tc_tsa, dcbxcfg->etscfg.tsatable,\n\t\tsizeof(ets->tc_tsa));\n\tmemcpy(ets->prio_tc, dcbxcfg->etscfg.prioritytable,\n\t\tsizeof(ets->prio_tc));\n\tmemcpy(ets->tc_reco_bw, dcbxcfg->etsrec.tcbwtable,\n\t\tsizeof(ets->tc_reco_bw));\n\tmemcpy(ets->tc_reco_tsa, dcbxcfg->etsrec.tsatable,\n\t\tsizeof(ets->tc_reco_tsa));\n\tmemcpy(ets->reco_prio_tc, dcbxcfg->etscfg.prioritytable,\n\t\tsizeof(ets->reco_prio_tc));\n\n\treturn 0;\n}\n\n \nstatic int i40e_dcbnl_ieee_getpfc(struct net_device *dev,\n\t\t\t\t  struct ieee_pfc *pfc)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\n\tstruct i40e_dcbx_config *dcbxcfg;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint i;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tdcbxcfg = &hw->local_dcbx_config;\n\tpfc->pfc_cap = dcbxcfg->pfc.pfccap;\n\tpfc->pfc_en = dcbxcfg->pfc.pfcenable;\n\tpfc->mbc = dcbxcfg->pfc.mbc;\n\ti40e_get_pfc_delay(hw, &pfc->delay);\n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tpfc->requests[i] = pf->stats.priority_xoff_tx[i];\n\t\tpfc->indications[i] = pf->stats.priority_xoff_rx[i];\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_dcbnl_ieee_setets(struct net_device *netdev,\n\t\t\t\t  struct ieee_ets *ets)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tstruct i40e_dcbx_config *old_cfg;\n\tint i, ret;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn -EINVAL;\n\n\told_cfg = &pf->hw.local_dcbx_config;\n\t \n\tpf->tmp_cfg = *old_cfg;\n\n\t \n\tpf->tmp_cfg.etscfg.willing = ets->willing;\n\tpf->tmp_cfg.etscfg.maxtcs = I40E_MAX_TRAFFIC_CLASS;\n\tpf->tmp_cfg.etscfg.cbs = ets->cbs;\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tpf->tmp_cfg.etscfg.tcbwtable[i] = ets->tc_tx_bw[i];\n\t\tpf->tmp_cfg.etscfg.tsatable[i] = ets->tc_tsa[i];\n\t\tpf->tmp_cfg.etscfg.prioritytable[i] = ets->prio_tc[i];\n\t\tpf->tmp_cfg.etsrec.tcbwtable[i] = ets->tc_reco_bw[i];\n\t\tpf->tmp_cfg.etsrec.tsatable[i] = ets->tc_reco_tsa[i];\n\t\tpf->tmp_cfg.etsrec.prioritytable[i] = ets->reco_prio_tc[i];\n\t}\n\n\t \n\tret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed setting DCB ETS configuration err %pe aq_err %s\\n\",\n\t\t\t ERR_PTR(ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_dcbnl_ieee_setpfc(struct net_device *netdev,\n\t\t\t\t  struct ieee_pfc *pfc)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tstruct i40e_dcbx_config *old_cfg;\n\tint ret;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn -EINVAL;\n\n\told_cfg = &pf->hw.local_dcbx_config;\n\t \n\tpf->tmp_cfg = *old_cfg;\n\tif (pfc->pfc_cap)\n\t\tpf->tmp_cfg.pfc.pfccap = pfc->pfc_cap;\n\telse\n\t\tpf->tmp_cfg.pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;\n\tpf->tmp_cfg.pfc.pfcenable = pfc->pfc_en;\n\n\tret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed setting DCB PFC configuration err %pe aq_err %s\\n\",\n\t\t\t ERR_PTR(ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_dcbnl_ieee_setapp(struct net_device *netdev,\n\t\t\t\t  struct dcb_app *app)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tstruct i40e_dcb_app_priority_table new_app;\n\tstruct i40e_dcbx_config *old_cfg;\n\tint ret;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn -EINVAL;\n\n\told_cfg = &pf->hw.local_dcbx_config;\n\tif (old_cfg->numapps == I40E_DCBX_MAX_APPS)\n\t\treturn -EINVAL;\n\n\tret = dcb_ieee_setapp(netdev, app);\n\tif (ret)\n\t\treturn ret;\n\n\tnew_app.selector = app->selector;\n\tnew_app.protocolid = app->protocol;\n\tnew_app.priority = app->priority;\n\t \n\tif (i40e_dcbnl_find_app(old_cfg, &new_app))\n\t\treturn 0;\n\n\t \n\tpf->tmp_cfg = *old_cfg;\n\t \n\tpf->tmp_cfg.app[pf->tmp_cfg.numapps++] = new_app;\n\n\tret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed setting DCB configuration err %pe aq_err %s\\n\",\n\t\t\t ERR_PTR(ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_dcbnl_ieee_delapp(struct net_device *netdev,\n\t\t\t\t  struct dcb_app *app)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tstruct i40e_dcbx_config *old_cfg;\n\tint i, j, ret;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn -EINVAL;\n\n\tret = dcb_ieee_delapp(netdev, app);\n\tif (ret)\n\t\treturn ret;\n\n\told_cfg = &pf->hw.local_dcbx_config;\n\t \n\tif (old_cfg->numapps == 1)\n\t\treturn 0;\n\n\t \n\tpf->tmp_cfg = *old_cfg;\n\n\t \n\tfor (i = 1; i < pf->tmp_cfg.numapps; i++) {\n\t\tif (app->selector == pf->tmp_cfg.app[i].selector &&\n\t\t    app->protocol == pf->tmp_cfg.app[i].protocolid &&\n\t\t    app->priority == pf->tmp_cfg.app[i].priority) {\n\t\t\t \n\t\t\tpf->tmp_cfg.app[i].selector = 0;\n\t\t\tpf->tmp_cfg.app[i].protocolid = 0;\n\t\t\tpf->tmp_cfg.app[i].priority = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == pf->tmp_cfg.numapps)\n\t\treturn -EINVAL;\n\n\tpf->tmp_cfg.numapps--;\n\t \n\tfor (j = i; j < pf->tmp_cfg.numapps; j++)\n\t\tpf->tmp_cfg.app[j] = old_cfg->app[j + 1];\n\n\tret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed setting DCB configuration err %pe aq_err %s\\n\",\n\t\t\t ERR_PTR(ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u8 i40e_dcbnl_getstate(struct net_device *netdev)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tdev_dbg(&pf->pdev->dev, \"DCB state=%d\\n\",\n\t\t!!(pf->flags & I40E_FLAG_DCB_ENABLED));\n\treturn !!(pf->flags & I40E_FLAG_DCB_ENABLED);\n}\n\n \nstatic u8 i40e_dcbnl_setstate(struct net_device *netdev, u8 state)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tint ret = I40E_DCBNL_STATUS_SUCCESS;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn ret;\n\n\tdev_dbg(&pf->pdev->dev, \"new state=%d current state=%d\\n\",\n\t\tstate, (pf->flags & I40E_FLAG_DCB_ENABLED) ? 1 : 0);\n\t \n\tif (!state == !(pf->flags & I40E_FLAG_DCB_ENABLED))\n\t\treturn ret;\n\n\tif (i40e_is_sw_dcb(pf)) {\n\t\tif (state) {\n\t\t\tpf->flags |= I40E_FLAG_DCB_ENABLED;\n\t\t\tmemcpy(&pf->hw.desired_dcbx_config,\n\t\t\t       &pf->hw.local_dcbx_config,\n\t\t\t       sizeof(struct i40e_dcbx_config));\n\t\t} else {\n\t\t\tpf->flags &= ~I40E_FLAG_DCB_ENABLED;\n\t\t}\n\t} else {\n\t\t \n\t\tret = I40E_DCBNL_STATUS_ERROR;\n\t}\n\treturn ret;\n}\n\n \nstatic void i40e_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev, int tc,\n\t\t\t\t\tu8 prio_type, u8 bwg_id, u8 bw_pct,\n\t\t\t\t\tu8 up_map)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tint i;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\n\t \n\tif (tc >= I40E_MAX_TRAFFIC_CLASS)\n\t\treturn;\n\n\t \n\n\t \n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (up_map & BIT(i))\n\t\t\tpf->tmp_cfg.etscfg.prioritytable[i] = tc;\n\t}\n\tpf->tmp_cfg.etscfg.tsatable[tc] = I40E_IEEE_TSA_ETS;\n\tdev_dbg(&pf->pdev->dev,\n\t\t\"Set PG config tc=%d bwg_id=%d prio_type=%d bw_pct=%d up_map=%d\\n\",\n\t\ttc, bwg_id, prio_type, bw_pct, up_map);\n}\n\n \nstatic void i40e_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev, int pgid,\n\t\t\t\t\t u8 bw_pct)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\n\t \n\tif (pgid >= I40E_MAX_TRAFFIC_CLASS)\n\t\treturn;\n\n\tpf->tmp_cfg.etscfg.tcbwtable[pgid] = bw_pct;\n\tdev_dbg(&pf->pdev->dev, \"Set PG BW config tc=%d bw_pct=%d\\n\",\n\t\tpgid, bw_pct);\n}\n\n \nstatic void i40e_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev,\n\t\t\t\t\tint __always_unused prio,\n\t\t\t\t\tu8 __always_unused prio_type,\n\t\t\t\t\tu8 __always_unused pgid,\n\t\t\t\t\tu8 __always_unused bw_pct,\n\t\t\t\t\tu8 __always_unused up_map)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tdev_dbg(&pf->pdev->dev, \"Rx TC PG Config Not Supported.\\n\");\n}\n\n \nstatic void i40e_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev, int pgid,\n\t\t\t\t\t u8 bw_pct)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tdev_dbg(&pf->pdev->dev, \"Rx BWG PG Config Not Supported.\\n\");\n}\n\n \nstatic void i40e_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev, int prio,\n\t\t\t\t\tu8 __always_unused *prio_type,\n\t\t\t\t\tu8 *pgid,\n\t\t\t\t\tu8 __always_unused *bw_pct,\n\t\t\t\t\tu8 __always_unused *up_map)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\n\tif (prio >= I40E_MAX_USER_PRIORITY)\n\t\treturn;\n\n\t*pgid = pf->hw.local_dcbx_config.etscfg.prioritytable[prio];\n\tdev_dbg(&pf->pdev->dev, \"Get PG config prio=%d tc=%d\\n\",\n\t\tprio, *pgid);\n}\n\n \nstatic void i40e_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev, int pgid,\n\t\t\t\t\t u8 *bw_pct)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\n\tif (pgid >= I40E_MAX_TRAFFIC_CLASS)\n\t\treturn;\n\n\t*bw_pct = pf->hw.local_dcbx_config.etscfg.tcbwtable[pgid];\n\tdev_dbg(&pf->pdev->dev, \"Get PG BW config tc=%d bw_pct=%d\\n\",\n\t\tpgid, *bw_pct);\n}\n\n \nstatic void i40e_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev, int prio,\n\t\t\t\t\tu8 *prio_type, u8 *pgid, u8 *bw_pct,\n\t\t\t\t\tu8 *up_map)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\n\tif (prio >= I40E_MAX_USER_PRIORITY)\n\t\treturn;\n\n\t*pgid = pf->hw.local_dcbx_config.etscfg.prioritytable[prio];\n}\n\n \nstatic void i40e_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev, int pgid,\n\t\t\t\t\t u8 *bw_pct)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\t*bw_pct = 0;\n}\n\n \nstatic void i40e_dcbnl_set_pfc_cfg(struct net_device *netdev, int prio,\n\t\t\t\t   u8 setting)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\n\tif (prio >= I40E_MAX_USER_PRIORITY)\n\t\treturn;\n\n\tpf->tmp_cfg.pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;\n\tif (setting)\n\t\tpf->tmp_cfg.pfc.pfcenable |= BIT(prio);\n\telse\n\t\tpf->tmp_cfg.pfc.pfcenable &= ~BIT(prio);\n\tdev_dbg(&pf->pdev->dev,\n\t\t\"Set PFC Config up=%d setting=%d pfcenable=0x%x\\n\",\n\t\tprio, setting, pf->tmp_cfg.pfc.pfcenable);\n}\n\n \nstatic void i40e_dcbnl_get_pfc_cfg(struct net_device *netdev, int prio,\n\t\t\t\t   u8 *setting)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn;\n\n\tif (prio >= I40E_MAX_USER_PRIORITY)\n\t\treturn;\n\n\t*setting = (pf->hw.local_dcbx_config.pfc.pfcenable >> prio) & 0x1;\n\tdev_dbg(&pf->pdev->dev,\n\t\t\"Get PFC Config up=%d setting=%d pfcenable=0x%x\\n\",\n\t\tprio, *setting, pf->hw.local_dcbx_config.pfc.pfcenable);\n}\n\n \nstatic u8 i40e_dcbnl_cee_set_all(struct net_device *netdev)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tint err;\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn I40E_DCBNL_STATUS_ERROR;\n\n\tdev_dbg(&pf->pdev->dev, \"Commit DCB Configuration to the hardware\\n\");\n\terr = i40e_hw_dcb_config(pf, &pf->tmp_cfg);\n\n\treturn err ? I40E_DCBNL_STATUS_ERROR : I40E_DCBNL_STATUS_SUCCESS;\n}\n\n \nstatic u8 i40e_dcbnl_get_cap(struct net_device *netdev, int capid, u8 *cap)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->flags & I40E_FLAG_DCB_CAPABLE))\n\t\treturn I40E_DCBNL_STATUS_ERROR;\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PG:\n\tcase DCB_CAP_ATTR_PFC:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PG_TCS:\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 0x80;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = pf->dcbx_cap;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_UP2TC:\n\tcase DCB_CAP_ATTR_GSP:\n\tcase DCB_CAP_ATTR_BCN:\n\tdefault:\n\t\t*cap = false;\n\t\tbreak;\n\t}\n\n\tdev_dbg(&pf->pdev->dev, \"Get Capability cap=%d capval=0x%x\\n\",\n\t\tcapid, *cap);\n\treturn I40E_DCBNL_STATUS_SUCCESS;\n}\n\n \nstatic int i40e_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tif (!(pf->flags & I40E_FLAG_DCB_CAPABLE))\n\t\treturn -EINVAL;\n\n\t*num = I40E_MAX_TRAFFIC_CLASS;\n\treturn 0;\n}\n\n \nstatic int i40e_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)\n{\n\treturn -EINVAL;\n}\n\n \nstatic u8 i40e_dcbnl_getpfcstate(struct net_device *netdev)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\t \n\tif (pf->hw.local_dcbx_config.pfc.pfcenable)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void i40e_dcbnl_setpfcstate(struct net_device *netdev, u8 state)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\tdev_dbg(&pf->pdev->dev, \"PFC State is modified via PFC config.\\n\");\n}\n\n \nstatic int i40e_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\tstruct dcb_app app = {\n\t\t\t\t.selector = idtype,\n\t\t\t\t.protocol = id,\n\t\t\t     };\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||\n\t    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))\n\t\treturn -EINVAL;\n\n\treturn dcb_getapp(netdev, &app);\n}\n\n \nstatic u8 i40e_dcbnl_setdcbx(struct net_device *netdev, u8 mode)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(netdev);\n\n\t \n\tif (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED)\n\t\treturn I40E_DCBNL_STATUS_ERROR;\n\n\t \n\tif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    ((mode & DCB_CAP_DCBX_VER_IEEE) && (mode & DCB_CAP_DCBX_VER_CEE)) ||\n\t    !(mode & DCB_CAP_DCBX_HOST))\n\t\treturn I40E_DCBNL_STATUS_ERROR;\n\n\t \n\tif (mode == pf->dcbx_cap)\n\t\treturn I40E_DCBNL_STATUS_SUCCESS;\n\n\tpf->dcbx_cap = mode;\n\tif (mode & DCB_CAP_DCBX_VER_CEE)\n\t\tpf->hw.local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_CEE;\n\telse\n\t\tpf->hw.local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_IEEE;\n\n\tdev_dbg(&pf->pdev->dev, \"mode=%d\\n\", mode);\n\treturn I40E_DCBNL_STATUS_SUCCESS;\n}\n\n \nstatic u8 i40e_dcbnl_getdcbx(struct net_device *dev)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\n\n\treturn pf->dcbx_cap;\n}\n\n \nstatic void i40e_dcbnl_get_perm_hw_addr(struct net_device *dev,\n\t\t\t\t\tu8 *perm_addr)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\n\tint i, j;\n\n\tmemset(perm_addr, 0xff, MAX_ADDR_LEN);\n\n\tfor (i = 0; i < dev->addr_len; i++)\n\t\tperm_addr[i] = pf->hw.mac.perm_addr[i];\n\n\tfor (j = 0; j < dev->addr_len; j++, i++)\n\t\tperm_addr[i] = pf->hw.mac.san_addr[j];\n}\n\nstatic const struct dcbnl_rtnl_ops dcbnl_ops = {\n\t.ieee_getets\t= i40e_dcbnl_ieee_getets,\n\t.ieee_getpfc\t= i40e_dcbnl_ieee_getpfc,\n\t.getdcbx\t= i40e_dcbnl_getdcbx,\n\t.getpermhwaddr\t= i40e_dcbnl_get_perm_hw_addr,\n\t.ieee_setets\t= i40e_dcbnl_ieee_setets,\n\t.ieee_setpfc\t= i40e_dcbnl_ieee_setpfc,\n\t.ieee_setapp\t= i40e_dcbnl_ieee_setapp,\n\t.ieee_delapp\t= i40e_dcbnl_ieee_delapp,\n\t.getstate\t= i40e_dcbnl_getstate,\n\t.setstate\t= i40e_dcbnl_setstate,\n\t.setpgtccfgtx\t= i40e_dcbnl_set_pg_tc_cfg_tx,\n\t.setpgbwgcfgtx\t= i40e_dcbnl_set_pg_bwg_cfg_tx,\n\t.setpgtccfgrx\t= i40e_dcbnl_set_pg_tc_cfg_rx,\n\t.setpgbwgcfgrx\t= i40e_dcbnl_set_pg_bwg_cfg_rx,\n\t.getpgtccfgtx\t= i40e_dcbnl_get_pg_tc_cfg_tx,\n\t.getpgbwgcfgtx\t= i40e_dcbnl_get_pg_bwg_cfg_tx,\n\t.getpgtccfgrx\t= i40e_dcbnl_get_pg_tc_cfg_rx,\n\t.getpgbwgcfgrx\t= i40e_dcbnl_get_pg_bwg_cfg_rx,\n\t.setpfccfg\t= i40e_dcbnl_set_pfc_cfg,\n\t.getpfccfg\t= i40e_dcbnl_get_pfc_cfg,\n\t.setall\t\t= i40e_dcbnl_cee_set_all,\n\t.getcap\t\t= i40e_dcbnl_get_cap,\n\t.getnumtcs\t= i40e_dcbnl_getnumtcs,\n\t.setnumtcs\t= i40e_dcbnl_setnumtcs,\n\t.getpfcstate\t= i40e_dcbnl_getpfcstate,\n\t.setpfcstate\t= i40e_dcbnl_setpfcstate,\n\t.getapp\t\t= i40e_dcbnl_getapp,\n\t.setdcbx\t= i40e_dcbnl_setdcbx,\n};\n\n \nvoid i40e_dcbnl_set_all(struct i40e_vsi *vsi)\n{\n\tstruct net_device *dev = vsi->netdev;\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\n\tstruct i40e_dcbx_config *dcbxcfg;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct dcb_app sapp;\n\tu8 prio, tc_map;\n\tint i;\n\n\t \n\tif (pf->dcbx_cap & DCB_CAP_DCBX_HOST)\n\t\treturn;\n\n\t \n\tif (!(pf->flags & I40E_FLAG_DCB_ENABLED))\n\t\treturn;\n\n\t \n\tif ((pf->flags & I40E_FLAG_MFP_ENABLED) && !(hw->func_caps.iscsi))\n\t\treturn;\n\n\tdcbxcfg = &hw->local_dcbx_config;\n\n\t \n\tfor (i = 0; i < dcbxcfg->numapps; i++) {\n\t\tprio = dcbxcfg->app[i].priority;\n\t\ttc_map = BIT(dcbxcfg->etscfg.prioritytable[prio]);\n\n\t\t \n\t\tif (tc_map & vsi->tc_config.enabled_tc) {\n\t\t\tsapp.selector = dcbxcfg->app[i].selector;\n\t\t\tsapp.protocol = dcbxcfg->app[i].protocolid;\n\t\t\tsapp.priority = prio;\n\t\t\tdcb_ieee_setapp(dev, &sapp);\n\t\t}\n\t}\n\n\t \n\tdcbnl_ieee_notify(dev, RTM_SETDCB, DCB_CMD_IEEE_SET, 0, 0);\n}\n\n \nstatic int i40e_dcbnl_vsi_del_app(struct i40e_vsi *vsi,\n\t\t\t\t  struct i40e_dcb_app_priority_table *app)\n{\n\tstruct net_device *dev = vsi->netdev;\n\tstruct dcb_app sapp;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tsapp.selector = app->selector;\n\tsapp.protocol = app->protocolid;\n\tsapp.priority = app->priority;\n\treturn dcb_ieee_delapp(dev, &sapp);\n}\n\n \nstatic void i40e_dcbnl_del_app(struct i40e_pf *pf,\n\t\t\t       struct i40e_dcb_app_priority_table *app)\n{\n\tint v, err;\n\n\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\tif (pf->vsi[v] && pf->vsi[v]->netdev) {\n\t\t\terr = i40e_dcbnl_vsi_del_app(pf->vsi[v], app);\n\t\t\tdev_dbg(&pf->pdev->dev, \"Deleting app for VSI seid=%d err=%d sel=%d proto=0x%x prio=%d\\n\",\n\t\t\t\tpf->vsi[v]->seid, err, app->selector,\n\t\t\t\tapp->protocolid, app->priority);\n\t\t}\n\t}\n}\n\n \nstatic bool i40e_dcbnl_find_app(struct i40e_dcbx_config *cfg,\n\t\t\t\tstruct i40e_dcb_app_priority_table *app)\n{\n\tint i;\n\n\tfor (i = 0; i < cfg->numapps; i++) {\n\t\tif (app->selector == cfg->app[i].selector &&\n\t\t    app->protocolid == cfg->app[i].protocolid &&\n\t\t    app->priority == cfg->app[i].priority)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nvoid i40e_dcbnl_flush_apps(struct i40e_pf *pf,\n\t\t\t   struct i40e_dcbx_config *old_cfg,\n\t\t\t   struct i40e_dcbx_config *new_cfg)\n{\n\tstruct i40e_dcb_app_priority_table app;\n\tint i;\n\n\t \n\tif ((pf->flags & I40E_FLAG_MFP_ENABLED) && !(pf->hw.func_caps.iscsi))\n\t\treturn;\n\n\tfor (i = 0; i < old_cfg->numapps; i++) {\n\t\tapp = old_cfg->app[i];\n\t\t \n\t\tif (!i40e_dcbnl_find_app(new_cfg, &app))\n\t\t\ti40e_dcbnl_del_app(pf, &app);\n\t}\n}\n\n \nvoid i40e_dcbnl_setup(struct i40e_vsi *vsi)\n{\n\tstruct net_device *dev = vsi->netdev;\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\n\n\t \n\tif (!(pf->flags & I40E_FLAG_DCB_CAPABLE))\n\t\treturn;\n\n\tdev->dcbnl_ops = &dcbnl_ops;\n\n\t \n\ti40e_dcbnl_set_all(vsi);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}