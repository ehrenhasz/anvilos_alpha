{
  "module_name": "i40e_debugfs.c",
  "hash_id": "f76c33664759fd2c64e9c8cdf89cb0e539b726265ee6fba50b28c340b31e51e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_debugfs.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_DEBUG_FS\n\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n\n#include \"i40e.h\"\n\nstatic struct dentry *i40e_dbg_root;\n\nenum ring_type {\n\tRING_TYPE_RX,\n\tRING_TYPE_TX,\n\tRING_TYPE_XDP\n};\n\n \nstatic struct i40e_vsi *i40e_dbg_find_vsi(struct i40e_pf *pf, int seid)\n{\n\tint i;\n\n\tif (seid < 0)\n\t\tdev_info(&pf->pdev->dev, \"%d: bad seid\\n\", seid);\n\telse\n\t\tfor (i = 0; i < pf->num_alloc_vsi; i++)\n\t\t\tif (pf->vsi[i] && (pf->vsi[i]->seid == seid))\n\t\t\t\treturn pf->vsi[i];\n\n\treturn NULL;\n}\n\n \nstatic struct i40e_veb *i40e_dbg_find_veb(struct i40e_pf *pf, int seid)\n{\n\tint i;\n\n\tfor (i = 0; i < I40E_MAX_VEB; i++)\n\t\tif (pf->veb[i] && pf->veb[i]->seid == seid)\n\t\t\treturn pf->veb[i];\n\treturn NULL;\n}\n\n \nstatic char i40e_dbg_command_buf[256] = \"\";\n\n \nstatic ssize_t i40e_dbg_command_read(struct file *filp, char __user *buffer,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct i40e_pf *pf = filp->private_data;\n\tint bytes_not_copied;\n\tint buf_size = 256;\n\tchar *buf;\n\tint len;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\tif (count < buf_size)\n\t\treturn -ENOSPC;\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOSPC;\n\n\tlen = snprintf(buf, buf_size, \"%s: %s\\n\",\n\t\t       pf->vsi[pf->lan_vsi]->netdev->name,\n\t\t       i40e_dbg_command_buf);\n\n\tbytes_not_copied = copy_to_user(buffer, buf, len);\n\tkfree(buf);\n\n\tif (bytes_not_copied)\n\t\treturn -EFAULT;\n\n\t*ppos = len;\n\treturn len;\n}\n\nstatic char *i40e_filter_state_string[] = {\n\t\"INVALID\",\n\t\"NEW\",\n\t\"ACTIVE\",\n\t\"FAILED\",\n\t\"REMOVE\",\n};\n\n \nstatic void i40e_dbg_dump_vsi_seid(struct i40e_pf *pf, int seid)\n{\n\tstruct rtnl_link_stats64 *nstat;\n\tstruct i40e_mac_filter *f;\n\tstruct i40e_vsi *vsi;\n\tint i, bkt;\n\n\tvsi = i40e_dbg_find_vsi(pf, seid);\n\tif (!vsi) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"dump %d: seid not found\\n\", seid);\n\t\treturn;\n\t}\n\tdev_info(&pf->pdev->dev, \"vsi seid %d\\n\", seid);\n\tif (vsi->netdev) {\n\t\tstruct net_device *nd = vsi->netdev;\n\n\t\tdev_info(&pf->pdev->dev, \"    netdev: name = %s, state = %lu, flags = 0x%08x\\n\",\n\t\t\t nd->name, nd->state, nd->flags);\n\t\tdev_info(&pf->pdev->dev, \"        features      = 0x%08lx\\n\",\n\t\t\t (unsigned long int)nd->features);\n\t\tdev_info(&pf->pdev->dev, \"        hw_features   = 0x%08lx\\n\",\n\t\t\t (unsigned long int)nd->hw_features);\n\t\tdev_info(&pf->pdev->dev, \"        vlan_features = 0x%08lx\\n\",\n\t\t\t (unsigned long int)nd->vlan_features);\n\t}\n\tdev_info(&pf->pdev->dev,\n\t\t \"    flags = 0x%08lx, netdev_registered = %i, current_netdev_flags = 0x%04x\\n\",\n\t\t vsi->flags, vsi->netdev_registered, vsi->current_netdev_flags);\n\tfor (i = 0; i < BITS_TO_LONGS(__I40E_VSI_STATE_SIZE__); i++)\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    state[%d] = %08lx\\n\",\n\t\t\t i, vsi->state[i]);\n\tif (vsi == pf->vsi[pf->lan_vsi])\n\t\tdev_info(&pf->pdev->dev, \"    MAC address: %pM SAN MAC: %pM Port MAC: %pM\\n\",\n\t\t\t pf->hw.mac.addr,\n\t\t\t pf->hw.mac.san_addr,\n\t\t\t pf->hw.mac.port_addr);\n\thash_for_each(vsi->mac_filter_hash, bkt, f, hlist) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    mac_filter_hash: %pM vid=%d, state %s\\n\",\n\t\t\t f->macaddr, f->vlan,\n\t\t\t i40e_filter_state_string[f->state]);\n\t}\n\tdev_info(&pf->pdev->dev, \"    active_filters %u, promisc_threshold %u, overflow promisc %s\\n\",\n\t\t vsi->active_filters, vsi->promisc_threshold,\n\t\t (test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state) ?\n\t\t  \"ON\" : \"OFF\"));\n\tnstat = i40e_get_vsi_stats_struct(vsi);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\\n\",\n\t\t (unsigned long int)nstat->rx_packets,\n\t\t (unsigned long int)nstat->rx_bytes,\n\t\t (unsigned long int)nstat->rx_errors,\n\t\t (unsigned long int)nstat->rx_dropped);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\\n\",\n\t\t (unsigned long int)nstat->tx_packets,\n\t\t (unsigned long int)nstat->tx_bytes,\n\t\t (unsigned long int)nstat->tx_errors,\n\t\t (unsigned long int)nstat->tx_dropped);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: multicast = %lu, collisions = %lu\\n\",\n\t\t (unsigned long int)nstat->multicast,\n\t\t (unsigned long int)nstat->collisions);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\\n\",\n\t\t (unsigned long int)nstat->rx_length_errors,\n\t\t (unsigned long int)nstat->rx_over_errors,\n\t\t (unsigned long int)nstat->rx_crc_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\\n\",\n\t\t (unsigned long int)nstat->rx_frame_errors,\n\t\t (unsigned long int)nstat->rx_fifo_errors,\n\t\t (unsigned long int)nstat->rx_missed_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\\n\",\n\t\t (unsigned long int)nstat->tx_aborted_errors,\n\t\t (unsigned long int)nstat->tx_carrier_errors,\n\t\t (unsigned long int)nstat->tx_fifo_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: tx_heartbeat_errors = %lu, tx_window_errors = %lu\\n\",\n\t\t (unsigned long int)nstat->tx_heartbeat_errors,\n\t\t (unsigned long int)nstat->tx_window_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats: rx_compressed = %lu, tx_compressed = %lu\\n\",\n\t\t (unsigned long int)nstat->rx_compressed,\n\t\t (unsigned long int)nstat->tx_compressed);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_packets,\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_bytes,\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_dropped);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_packets,\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_bytes,\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_dropped);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: multicast = %lu, collisions = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.multicast,\n\t\t (unsigned long int)vsi->net_stats_offsets.collisions);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_length_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_over_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_crc_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_frame_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_fifo_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_missed_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_aborted_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_carrier_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_fifo_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: tx_heartbeat_errors = %lu, tx_window_errors = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_heartbeat_errors,\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_window_errors);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    net_stats_offsets: rx_compressed = %lu, tx_compressed = %lu\\n\",\n\t\t (unsigned long int)vsi->net_stats_offsets.rx_compressed,\n\t\t (unsigned long int)vsi->net_stats_offsets.tx_compressed);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    tx_restart = %llu, tx_busy = %llu, rx_buf_failed = %llu, rx_page_failed = %llu\\n\",\n\t\t vsi->tx_restart, vsi->tx_busy,\n\t\t vsi->rx_buf_failed, vsi->rx_page_failed);\n\trcu_read_lock();\n\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\tstruct i40e_ring *rx_ring = READ_ONCE(vsi->rx_rings[i]);\n\n\t\tif (!rx_ring)\n\t\t\tcontinue;\n\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: state = %lu, queue_index = %d, reg_idx = %d\\n\",\n\t\t\t i, *rx_ring->state,\n\t\t\t rx_ring->queue_index,\n\t\t\t rx_ring->reg_idx);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: rx_buf_len = %d\\n\",\n\t\t\t i, rx_ring->rx_buf_len);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: next_to_use = %d, next_to_clean = %d, ring_active = %i\\n\",\n\t\t\t i,\n\t\t\t rx_ring->next_to_use,\n\t\t\t rx_ring->next_to_clean,\n\t\t\t rx_ring->ring_active);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: rx_stats: packets = %lld, bytes = %lld, non_eop_descs = %lld\\n\",\n\t\t\t i, rx_ring->stats.packets,\n\t\t\t rx_ring->stats.bytes,\n\t\t\t rx_ring->rx_stats.non_eop_descs);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: rx_stats: alloc_page_failed = %lld, alloc_buff_failed = %lld\\n\",\n\t\t\t i,\n\t\t\t rx_ring->rx_stats.alloc_page_failed,\n\t\t\t rx_ring->rx_stats.alloc_buff_failed);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: rx_stats: realloc_count = 0, page_reuse_count = %lld\\n\",\n\t\t\t i,\n\t\t\t rx_ring->rx_stats.page_reuse_count);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: size = %i\\n\",\n\t\t\t i, rx_ring->size);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    rx_rings[%i]: itr_setting = %d (%s)\\n\",\n\t\t\t i, rx_ring->itr_setting,\n\t\t\t ITR_IS_DYNAMIC(rx_ring->itr_setting) ? \"dynamic\" : \"fixed\");\n\t}\n\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\tstruct i40e_ring *tx_ring = READ_ONCE(vsi->tx_rings[i]);\n\n\t\tif (!tx_ring)\n\t\t\tcontinue;\n\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tx_rings[%i]: state = %lu, queue_index = %d, reg_idx = %d\\n\",\n\t\t\t i, *tx_ring->state,\n\t\t\t tx_ring->queue_index,\n\t\t\t tx_ring->reg_idx);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tx_rings[%i]: next_to_use = %d, next_to_clean = %d, ring_active = %i\\n\",\n\t\t\t i,\n\t\t\t tx_ring->next_to_use,\n\t\t\t tx_ring->next_to_clean,\n\t\t\t tx_ring->ring_active);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tx_rings[%i]: tx_stats: packets = %lld, bytes = %lld, restart_queue = %lld\\n\",\n\t\t\t i, tx_ring->stats.packets,\n\t\t\t tx_ring->stats.bytes,\n\t\t\t tx_ring->tx_stats.restart_queue);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tx_rings[%i]: tx_stats: tx_busy = %lld, tx_done_old = %lld, tx_stopped = %lld\\n\",\n\t\t\t i,\n\t\t\t tx_ring->tx_stats.tx_busy,\n\t\t\t tx_ring->tx_stats.tx_done_old,\n\t\t\t tx_ring->tx_stats.tx_stopped);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tx_rings[%i]: size = %i\\n\",\n\t\t\t i, tx_ring->size);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tx_rings[%i]: DCB tc = %d\\n\",\n\t\t\t i, tx_ring->dcb_tc);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tx_rings[%i]: itr_setting = %d (%s)\\n\",\n\t\t\t i, tx_ring->itr_setting,\n\t\t\t ITR_IS_DYNAMIC(tx_ring->itr_setting) ? \"dynamic\" : \"fixed\");\n\t}\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\t\tstruct i40e_ring *xdp_ring = READ_ONCE(vsi->xdp_rings[i]);\n\n\t\t\tif (!xdp_ring)\n\t\t\t\tcontinue;\n\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"    xdp_rings[%i]: state = %lu, queue_index = %d, reg_idx = %d\\n\",\n\t\t\t\t i, *xdp_ring->state,\n\t\t\t\t xdp_ring->queue_index,\n\t\t\t\t xdp_ring->reg_idx);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"    xdp_rings[%i]: next_to_use = %d, next_to_clean = %d, ring_active = %i\\n\",\n\t\t\t\t i,\n\t\t\t\t xdp_ring->next_to_use,\n\t\t\t\t xdp_ring->next_to_clean,\n\t\t\t\t xdp_ring->ring_active);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"    xdp_rings[%i]: tx_stats: packets = %lld, bytes = %lld, restart_queue = %lld\\n\",\n\t\t\t\t i, xdp_ring->stats.packets,\n\t\t\t\t xdp_ring->stats.bytes,\n\t\t\t\t xdp_ring->tx_stats.restart_queue);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"    xdp_rings[%i]: tx_stats: tx_busy = %lld, tx_done_old = %lld\\n\",\n\t\t\t\t i,\n\t\t\t\t xdp_ring->tx_stats.tx_busy,\n\t\t\t\t xdp_ring->tx_stats.tx_done_old);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"    xdp_rings[%i]: size = %i\\n\",\n\t\t\t\t i, xdp_ring->size);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"    xdp_rings[%i]: DCB tc = %d\\n\",\n\t\t\t\t i, xdp_ring->dcb_tc);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"    xdp_rings[%i]: itr_setting = %d (%s)\\n\",\n\t\t\t\t i, xdp_ring->itr_setting,\n\t\t\t\t ITR_IS_DYNAMIC(xdp_ring->itr_setting) ?\n\t\t\t\t \"dynamic\" : \"fixed\");\n\t\t}\n\t}\n\trcu_read_unlock();\n\tdev_info(&pf->pdev->dev,\n\t\t \"    work_limit = %d\\n\",\n\t\t vsi->work_limit);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    max_frame = %d, rx_buf_len = %d dtype = %d\\n\",\n\t\t vsi->max_frame, vsi->rx_buf_len, 0);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    num_q_vectors = %i, base_vector = %i\\n\",\n\t\t vsi->num_q_vectors, vsi->base_vector);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    seid = %d, id = %d, uplink_seid = %d\\n\",\n\t\t vsi->seid, vsi->id, vsi->uplink_seid);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    base_queue = %d, num_queue_pairs = %d, num_tx_desc = %d, num_rx_desc = %d\\n\",\n\t\t vsi->base_queue, vsi->num_queue_pairs, vsi->num_tx_desc,\n\t\t vsi->num_rx_desc);\n\tdev_info(&pf->pdev->dev, \"    type = %i\\n\", vsi->type);\n\tif (vsi->type == I40E_VSI_SRIOV)\n\t\tdev_info(&pf->pdev->dev, \"    VF ID = %i\\n\", vsi->vf_id);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: valid_sections = 0x%04x, switch_id = 0x%04x\\n\",\n\t\t vsi->info.valid_sections, vsi->info.switch_id);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: sw_reserved[] = 0x%02x 0x%02x\\n\",\n\t\t vsi->info.sw_reserved[0], vsi->info.sw_reserved[1]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: sec_flags = 0x%02x, sec_reserved = 0x%02x\\n\",\n\t\t vsi->info.sec_flags, vsi->info.sec_reserved);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: pvid = 0x%04x, fcoe_pvid = 0x%04x, port_vlan_flags = 0x%02x\\n\",\n\t\t vsi->info.pvid, vsi->info.fcoe_pvid,\n\t\t vsi->info.port_vlan_flags);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: pvlan_reserved[] = 0x%02x 0x%02x 0x%02x\\n\",\n\t\t vsi->info.pvlan_reserved[0], vsi->info.pvlan_reserved[1],\n\t\t vsi->info.pvlan_reserved[2]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: ingress_table = 0x%08x, egress_table = 0x%08x\\n\",\n\t\t vsi->info.ingress_table, vsi->info.egress_table);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: cas_pv_stag = 0x%04x, cas_pv_flags= 0x%02x, cas_pv_reserved = 0x%02x\\n\",\n\t\t vsi->info.cas_pv_tag, vsi->info.cas_pv_flags,\n\t\t vsi->info.cas_pv_reserved);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: queue_mapping[0..7 ] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\\n\",\n\t\t vsi->info.queue_mapping[0], vsi->info.queue_mapping[1],\n\t\t vsi->info.queue_mapping[2], vsi->info.queue_mapping[3],\n\t\t vsi->info.queue_mapping[4], vsi->info.queue_mapping[5],\n\t\t vsi->info.queue_mapping[6], vsi->info.queue_mapping[7]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: queue_mapping[8..15] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\\n\",\n\t\t vsi->info.queue_mapping[8], vsi->info.queue_mapping[9],\n\t\t vsi->info.queue_mapping[10], vsi->info.queue_mapping[11],\n\t\t vsi->info.queue_mapping[12], vsi->info.queue_mapping[13],\n\t\t vsi->info.queue_mapping[14], vsi->info.queue_mapping[15]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: tc_mapping[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\\n\",\n\t\t vsi->info.tc_mapping[0], vsi->info.tc_mapping[1],\n\t\t vsi->info.tc_mapping[2], vsi->info.tc_mapping[3],\n\t\t vsi->info.tc_mapping[4], vsi->info.tc_mapping[5],\n\t\t vsi->info.tc_mapping[6], vsi->info.tc_mapping[7]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: queueing_opt_flags = 0x%02x  queueing_opt_reserved[0..2] = 0x%02x 0x%02x 0x%02x\\n\",\n\t\t vsi->info.queueing_opt_flags,\n\t\t vsi->info.queueing_opt_reserved[0],\n\t\t vsi->info.queueing_opt_reserved[1],\n\t\t vsi->info.queueing_opt_reserved[2]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: up_enable_bits = 0x%02x\\n\",\n\t\t vsi->info.up_enable_bits);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: sched_reserved = 0x%02x, outer_up_table = 0x%04x\\n\",\n\t\t vsi->info.sched_reserved, vsi->info.outer_up_table);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: cmd_reserved[] = 0x%02x 0x%02x 0x%02x 0x0%02x 0x%02x 0x%02x 0x%02x 0x0%02x\\n\",\n\t\t vsi->info.cmd_reserved[0], vsi->info.cmd_reserved[1],\n\t\t vsi->info.cmd_reserved[2], vsi->info.cmd_reserved[3],\n\t\t vsi->info.cmd_reserved[4], vsi->info.cmd_reserved[5],\n\t\t vsi->info.cmd_reserved[6], vsi->info.cmd_reserved[7]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: qs_handle[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\\n\",\n\t\t vsi->info.qs_handle[0], vsi->info.qs_handle[1],\n\t\t vsi->info.qs_handle[2], vsi->info.qs_handle[3],\n\t\t vsi->info.qs_handle[4], vsi->info.qs_handle[5],\n\t\t vsi->info.qs_handle[6], vsi->info.qs_handle[7]);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: stat_counter_idx = 0x%04x, sched_id = 0x%04x\\n\",\n\t\t vsi->info.stat_counter_idx, vsi->info.sched_id);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    info: resp_reserved[] = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\\n\",\n\t\t vsi->info.resp_reserved[0], vsi->info.resp_reserved[1],\n\t\t vsi->info.resp_reserved[2], vsi->info.resp_reserved[3],\n\t\t vsi->info.resp_reserved[4], vsi->info.resp_reserved[5],\n\t\t vsi->info.resp_reserved[6], vsi->info.resp_reserved[7],\n\t\t vsi->info.resp_reserved[8], vsi->info.resp_reserved[9],\n\t\t vsi->info.resp_reserved[10], vsi->info.resp_reserved[11]);\n\tdev_info(&pf->pdev->dev, \"    idx = %d\\n\", vsi->idx);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    tc_config: numtc = %d, enabled_tc = 0x%x\\n\",\n\t\t vsi->tc_config.numtc, vsi->tc_config.enabled_tc);\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    tc_config: tc = %d, qoffset = %d, qcount = %d, netdev_tc = %d\\n\",\n\t\t\t i, vsi->tc_config.tc_info[i].qoffset,\n\t\t\t vsi->tc_config.tc_info[i].qcount,\n\t\t\t vsi->tc_config.tc_info[i].netdev_tc);\n\t}\n\tdev_info(&pf->pdev->dev,\n\t\t \"    bw: bw_limit = %d, bw_max_quanta = %d\\n\",\n\t\t vsi->bw_limit, vsi->bw_max_quanta);\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"    bw[%d]: ets_share_credits = %d, ets_limit_credits = %d, max_quanta = %d\\n\",\n\t\t\t i, vsi->bw_ets_share_credits[i],\n\t\t\t vsi->bw_ets_limit_credits[i],\n\t\t\t vsi->bw_ets_max_quanta[i]);\n\t}\n}\n\n \nstatic void i40e_dbg_dump_aq_desc(struct i40e_pf *pf)\n{\n\tstruct i40e_adminq_ring *ring;\n\tstruct i40e_hw *hw = &pf->hw;\n\tchar hdr[32];\n\tint i;\n\n\tsnprintf(hdr, sizeof(hdr), \"%s %s:         \",\n\t\t dev_driver_string(&pf->pdev->dev),\n\t\t dev_name(&pf->pdev->dev));\n\n\t \n\tdev_info(&pf->pdev->dev, \"AdminQ Tx Ring\\n\");\n\tring = &(hw->aq.asq);\n\tfor (i = 0; i < ring->count; i++) {\n\t\tstruct i40e_aq_desc *d = I40E_ADMINQ_DESC(*ring, i);\n\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"   at[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\\n\",\n\t\t\t i, d->flags, d->opcode, d->datalen, d->retval,\n\t\t\t d->cookie_high, d->cookie_low);\n\t\tprint_hex_dump(KERN_INFO, hdr, DUMP_PREFIX_NONE,\n\t\t\t       16, 1, d->params.raw, 16, 0);\n\t}\n\n\tdev_info(&pf->pdev->dev, \"AdminQ Rx Ring\\n\");\n\tring = &(hw->aq.arq);\n\tfor (i = 0; i < ring->count; i++) {\n\t\tstruct i40e_aq_desc *d = I40E_ADMINQ_DESC(*ring, i);\n\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"   ar[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\\n\",\n\t\t\t i, d->flags, d->opcode, d->datalen, d->retval,\n\t\t\t d->cookie_high, d->cookie_low);\n\t\tprint_hex_dump(KERN_INFO, hdr, DUMP_PREFIX_NONE,\n\t\t\t       16, 1, d->params.raw, 16, 0);\n\t}\n}\n\n \nstatic void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n,\n\t\t\t       struct i40e_pf *pf, enum ring_type type)\n{\n\tbool is_rx_ring = type == RING_TYPE_RX;\n\tstruct i40e_tx_desc *txd;\n\tunion i40e_rx_desc *rxd;\n\tstruct i40e_ring *ring;\n\tstruct i40e_vsi *vsi;\n\tint i;\n\n\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\tif (!vsi) {\n\t\tdev_info(&pf->pdev->dev, \"vsi %d not found\\n\", vsi_seid);\n\t\treturn;\n\t}\n\tif (vsi->type != I40E_VSI_MAIN &&\n\t    vsi->type != I40E_VSI_FDIR &&\n\t    vsi->type != I40E_VSI_VMDQ2) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"vsi %d type %d descriptor rings not available\\n\",\n\t\t\t vsi_seid, vsi->type);\n\t\treturn;\n\t}\n\tif (type == RING_TYPE_XDP && !i40e_enabled_xdp_vsi(vsi)) {\n\t\tdev_info(&pf->pdev->dev, \"XDP not enabled on VSI %d\\n\", vsi_seid);\n\t\treturn;\n\t}\n\tif (ring_id >= vsi->num_queue_pairs || ring_id < 0) {\n\t\tdev_info(&pf->pdev->dev, \"ring %d not found\\n\", ring_id);\n\t\treturn;\n\t}\n\tif (!vsi->tx_rings || !vsi->tx_rings[0]->desc) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"descriptor rings have not been allocated for vsi %d\\n\",\n\t\t\t vsi_seid);\n\t\treturn;\n\t}\n\n\tswitch (type) {\n\tcase RING_TYPE_RX:\n\t\tring = kmemdup(vsi->rx_rings[ring_id], sizeof(*ring), GFP_KERNEL);\n\t\tbreak;\n\tcase RING_TYPE_TX:\n\t\tring = kmemdup(vsi->tx_rings[ring_id], sizeof(*ring), GFP_KERNEL);\n\t\tbreak;\n\tcase RING_TYPE_XDP:\n\t\tring = kmemdup(vsi->xdp_rings[ring_id], sizeof(*ring), GFP_KERNEL);\n\t\tbreak;\n\tdefault:\n\t\tring = NULL;\n\t\tbreak;\n\t}\n\tif (!ring)\n\t\treturn;\n\n\tif (cnt == 2) {\n\t\tswitch (type) {\n\t\tcase RING_TYPE_RX:\n\t\t\tdev_info(&pf->pdev->dev, \"VSI = %02i Rx ring = %02i\\n\", vsi_seid, ring_id);\n\t\t\tbreak;\n\t\tcase RING_TYPE_TX:\n\t\t\tdev_info(&pf->pdev->dev, \"VSI = %02i Tx ring = %02i\\n\", vsi_seid, ring_id);\n\t\t\tbreak;\n\t\tcase RING_TYPE_XDP:\n\t\t\tdev_info(&pf->pdev->dev, \"VSI = %02i XDP ring = %02i\\n\", vsi_seid, ring_id);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < ring->count; i++) {\n\t\t\tif (!is_rx_ring) {\n\t\t\t\ttxd = I40E_TX_DESC(ring, i);\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"   d[%03x] = 0x%016llx 0x%016llx\\n\",\n\t\t\t\t\t i, txd->buffer_addr,\n\t\t\t\t\t txd->cmd_type_offset_bsz);\n\t\t\t} else {\n\t\t\t\trxd = I40E_RX_DESC(ring, i);\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"   d[%03x] = 0x%016llx 0x%016llx\\n\",\n\t\t\t\t\t i, rxd->read.pkt_addr,\n\t\t\t\t\t rxd->read.hdr_addr);\n\t\t\t}\n\t\t}\n\t} else if (cnt == 3) {\n\t\tif (desc_n >= ring->count || desc_n < 0) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"descriptor %d not found\\n\", desc_n);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!is_rx_ring) {\n\t\t\ttxd = I40E_TX_DESC(ring, desc_n);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"vsi = %02i tx ring = %02i d[%03x] = 0x%016llx 0x%016llx\\n\",\n\t\t\t\t vsi_seid, ring_id, desc_n,\n\t\t\t\t txd->buffer_addr, txd->cmd_type_offset_bsz);\n\t\t} else {\n\t\t\trxd = I40E_RX_DESC(ring, desc_n);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"vsi = %02i rx ring = %02i d[%03x] = 0x%016llx 0x%016llx\\n\",\n\t\t\t\t vsi_seid, ring_id, desc_n,\n\t\t\t\t rxd->read.pkt_addr, rxd->read.hdr_addr);\n\t\t}\n\t} else {\n\t\tdev_info(&pf->pdev->dev, \"dump desc rx/tx/xdp <vsi_seid> <ring_id> [<desc_n>]\\n\");\n\t}\n\nout:\n\tkfree(ring);\n}\n\n \nstatic void i40e_dbg_dump_vsi_no_seid(struct i40e_pf *pf)\n{\n\tint i;\n\n\tfor (i = 0; i < pf->num_alloc_vsi; i++)\n\t\tif (pf->vsi[i])\n\t\t\tdev_info(&pf->pdev->dev, \"dump vsi[%d]: %d\\n\",\n\t\t\t\t i, pf->vsi[i]->seid);\n}\n\n \nstatic void i40e_dbg_dump_eth_stats(struct i40e_pf *pf,\n\t\t\t\t    struct i40e_eth_stats *estats)\n{\n\tdev_info(&pf->pdev->dev, \"  ethstats:\\n\");\n\tdev_info(&pf->pdev->dev,\n\t\t \"    rx_bytes = \\t%lld \\trx_unicast = \\t\\t%lld \\trx_multicast = \\t%lld\\n\",\n\t\testats->rx_bytes, estats->rx_unicast, estats->rx_multicast);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    rx_broadcast = \\t%lld \\trx_discards = \\t\\t%lld\\n\",\n\t\t estats->rx_broadcast, estats->rx_discards);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    rx_unknown_protocol = \\t%lld \\ttx_bytes = \\t%lld\\n\",\n\t\t estats->rx_unknown_protocol, estats->tx_bytes);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    tx_unicast = \\t%lld \\ttx_multicast = \\t\\t%lld \\ttx_broadcast = \\t%lld\\n\",\n\t\t estats->tx_unicast, estats->tx_multicast, estats->tx_broadcast);\n\tdev_info(&pf->pdev->dev,\n\t\t \"    tx_discards = \\t%lld \\ttx_errors = \\t\\t%lld\\n\",\n\t\t estats->tx_discards, estats->tx_errors);\n}\n\n \nstatic void i40e_dbg_dump_veb_seid(struct i40e_pf *pf, int seid)\n{\n\tstruct i40e_veb *veb;\n\n\tveb = i40e_dbg_find_veb(pf, seid);\n\tif (!veb) {\n\t\tdev_info(&pf->pdev->dev, \"can't find veb %d\\n\", seid);\n\t\treturn;\n\t}\n\tdev_info(&pf->pdev->dev,\n\t\t \"veb idx=%d,%d stats_ic=%d  seid=%d uplink=%d mode=%s\\n\",\n\t\t veb->idx, veb->veb_idx, veb->stats_idx, veb->seid,\n\t\t veb->uplink_seid,\n\t\t veb->bridge_mode == BRIDGE_MODE_VEPA ? \"VEPA\" : \"VEB\");\n\ti40e_dbg_dump_eth_stats(pf, &veb->stats);\n}\n\n \nstatic void i40e_dbg_dump_veb_all(struct i40e_pf *pf)\n{\n\tstruct i40e_veb *veb;\n\tint i;\n\n\tfor (i = 0; i < I40E_MAX_VEB; i++) {\n\t\tveb = pf->veb[i];\n\t\tif (veb)\n\t\t\ti40e_dbg_dump_veb_seid(pf, veb->seid);\n\t}\n}\n\n \nstatic void i40e_dbg_dump_vf(struct i40e_pf *pf, int vf_id)\n{\n\tstruct i40e_vf *vf;\n\tstruct i40e_vsi *vsi;\n\n\tif (!pf->num_alloc_vfs) {\n\t\tdev_info(&pf->pdev->dev, \"no VFs allocated\\n\");\n\t} else if ((vf_id >= 0) && (vf_id < pf->num_alloc_vfs)) {\n\t\tvf = &pf->vf[vf_id];\n\t\tvsi = pf->vsi[vf->lan_vsi_idx];\n\t\tdev_info(&pf->pdev->dev, \"vf %2d: VSI id=%d, seid=%d, qps=%d\\n\",\n\t\t\t vf_id, vf->lan_vsi_id, vsi->seid, vf->num_queue_pairs);\n\t\tdev_info(&pf->pdev->dev, \"       num MDD=%lld\\n\",\n\t\t\t vf->num_mdd_events);\n\t} else {\n\t\tdev_info(&pf->pdev->dev, \"invalid VF id %d\\n\", vf_id);\n\t}\n}\n\n \nstatic void i40e_dbg_dump_vf_all(struct i40e_pf *pf)\n{\n\tint i;\n\n\tif (!pf->num_alloc_vfs)\n\t\tdev_info(&pf->pdev->dev, \"no VFs enabled!\\n\");\n\telse\n\t\tfor (i = 0; i < pf->num_alloc_vfs; i++)\n\t\t\ti40e_dbg_dump_vf(pf, i);\n}\n\n \nstatic ssize_t i40e_dbg_command_write(struct file *filp,\n\t\t\t\t      const char __user *buffer,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct i40e_pf *pf = filp->private_data;\n\tchar *cmd_buf, *cmd_buf_tmp;\n\tint bytes_not_copied;\n\tstruct i40e_vsi *vsi;\n\tint vsi_seid;\n\tint veb_seid;\n\tint vf_id;\n\tint cnt;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tcmd_buf = kzalloc(count + 1, GFP_KERNEL);\n\tif (!cmd_buf)\n\t\treturn count;\n\tbytes_not_copied = copy_from_user(cmd_buf, buffer, count);\n\tif (bytes_not_copied) {\n\t\tkfree(cmd_buf);\n\t\treturn -EFAULT;\n\t}\n\tcmd_buf[count] = '\\0';\n\n\tcmd_buf_tmp = strchr(cmd_buf, '\\n');\n\tif (cmd_buf_tmp) {\n\t\t*cmd_buf_tmp = '\\0';\n\t\tcount = cmd_buf_tmp - cmd_buf + 1;\n\t}\n\n\tif (strncmp(cmd_buf, \"add vsi\", 7) == 0) {\n\t\tvsi_seid = -1;\n\t\tcnt = sscanf(&cmd_buf[7], \"%i\", &vsi_seid);\n\t\tif (cnt == 0) {\n\t\t\t \n\t\t\tvsi_seid = pf->vsi[pf->lan_vsi]->seid;\n\t\t} else if (vsi_seid < 0) {\n\t\t\tdev_info(&pf->pdev->dev, \"add VSI %d: bad vsi seid\\n\",\n\t\t\t\t vsi_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\t \n\t\tif (!(pf->flags & I40E_FLAG_VEB_MODE_ENABLED)) {\n\t\t\tpf->flags |= I40E_FLAG_VEB_MODE_ENABLED;\n\t\t\ti40e_do_reset_safe(pf, I40E_PF_RESET_FLAG);\n\t\t}\n\n\t\tvsi = i40e_vsi_setup(pf, I40E_VSI_VMDQ2, vsi_seid, 0);\n\t\tif (vsi)\n\t\t\tdev_info(&pf->pdev->dev, \"added VSI %d to relay %d\\n\",\n\t\t\t\t vsi->seid, vsi->uplink_seid);\n\t\telse\n\t\t\tdev_info(&pf->pdev->dev, \"'%s' failed\\n\", cmd_buf);\n\n\t} else if (strncmp(cmd_buf, \"del vsi\", 7) == 0) {\n\t\tcnt = sscanf(&cmd_buf[7], \"%i\", &vsi_seid);\n\t\tif (cnt != 1) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"del vsi: bad command string, cnt=%d\\n\",\n\t\t\t\t cnt);\n\t\t\tgoto command_write_done;\n\t\t}\n\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev, \"del VSI %d: seid not found\\n\",\n\t\t\t\t vsi_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tdev_info(&pf->pdev->dev, \"deleting VSI %d\\n\", vsi_seid);\n\t\ti40e_vsi_release(vsi);\n\n\t} else if (strncmp(cmd_buf, \"add relay\", 9) == 0) {\n\t\tstruct i40e_veb *veb;\n\t\tint uplink_seid, i;\n\n\t\tcnt = sscanf(&cmd_buf[9], \"%i %i\", &uplink_seid, &vsi_seid);\n\t\tif (cnt != 2) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"add relay: bad command string, cnt=%d\\n\",\n\t\t\t\t cnt);\n\t\t\tgoto command_write_done;\n\t\t} else if (uplink_seid < 0) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"add relay %d: bad uplink seid\\n\",\n\t\t\t\t uplink_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"add relay: VSI %d not found\\n\", vsi_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tfor (i = 0; i < I40E_MAX_VEB; i++)\n\t\t\tif (pf->veb[i] && pf->veb[i]->seid == uplink_seid)\n\t\t\t\tbreak;\n\t\tif (i >= I40E_MAX_VEB && uplink_seid != 0 &&\n\t\t    uplink_seid != pf->mac_seid) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"add relay: relay uplink %d not found\\n\",\n\t\t\t\t uplink_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tveb = i40e_veb_setup(pf, 0, uplink_seid, vsi_seid,\n\t\t\t\t     vsi->tc_config.enabled_tc);\n\t\tif (veb)\n\t\t\tdev_info(&pf->pdev->dev, \"added relay %d\\n\", veb->seid);\n\t\telse\n\t\t\tdev_info(&pf->pdev->dev, \"add relay failed\\n\");\n\n\t} else if (strncmp(cmd_buf, \"del relay\", 9) == 0) {\n\t\tint i;\n\t\tcnt = sscanf(&cmd_buf[9], \"%i\", &veb_seid);\n\t\tif (cnt != 1) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"del relay: bad command string, cnt=%d\\n\",\n\t\t\t\t cnt);\n\t\t\tgoto command_write_done;\n\t\t} else if (veb_seid < 0) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"del relay %d: bad relay seid\\n\", veb_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < I40E_MAX_VEB; i++)\n\t\t\tif (pf->veb[i] && pf->veb[i]->seid == veb_seid)\n\t\t\t\tbreak;\n\t\tif (i >= I40E_MAX_VEB) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"del relay: relay %d not found\\n\", veb_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tdev_info(&pf->pdev->dev, \"deleting relay %d\\n\", veb_seid);\n\t\ti40e_veb_release(pf->veb[i]);\n\t} else if (strncmp(cmd_buf, \"add pvid\", 8) == 0) {\n\t\tunsigned int v;\n\t\tint ret;\n\t\tu16 vid;\n\n\t\tcnt = sscanf(&cmd_buf[8], \"%i %u\", &vsi_seid, &v);\n\t\tif (cnt != 2) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"add pvid: bad command string, cnt=%d\\n\", cnt);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev, \"add pvid: VSI %d not found\\n\",\n\t\t\t\t vsi_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tvid = v;\n\t\tret = i40e_vsi_add_pvid(vsi, vid);\n\t\tif (!ret)\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"add pvid: %d added to VSI %d\\n\",\n\t\t\t\t vid, vsi_seid);\n\t\telse\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"add pvid: %d to VSI %d failed, ret=%d\\n\",\n\t\t\t\t vid, vsi_seid, ret);\n\n\t} else if (strncmp(cmd_buf, \"del pvid\", 8) == 0) {\n\n\t\tcnt = sscanf(&cmd_buf[8], \"%i\", &vsi_seid);\n\t\tif (cnt != 1) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"del pvid: bad command string, cnt=%d\\n\",\n\t\t\t\t cnt);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"del pvid: VSI %d not found\\n\", vsi_seid);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\ti40e_vsi_remove_pvid(vsi);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"del pvid: removed from VSI %d\\n\", vsi_seid);\n\n\t} else if (strncmp(cmd_buf, \"dump\", 4) == 0) {\n\t\tif (strncmp(&cmd_buf[5], \"switch\", 6) == 0) {\n\t\t\ti40e_fetch_switch_configuration(pf, true);\n\t\t} else if (strncmp(&cmd_buf[5], \"vsi\", 3) == 0) {\n\t\t\tcnt = sscanf(&cmd_buf[8], \"%i\", &vsi_seid);\n\t\t\tif (cnt > 0)\n\t\t\t\ti40e_dbg_dump_vsi_seid(pf, vsi_seid);\n\t\t\telse\n\t\t\t\ti40e_dbg_dump_vsi_no_seid(pf);\n\t\t} else if (strncmp(&cmd_buf[5], \"veb\", 3) == 0) {\n\t\t\tcnt = sscanf(&cmd_buf[8], \"%i\", &vsi_seid);\n\t\t\tif (cnt > 0)\n\t\t\t\ti40e_dbg_dump_veb_seid(pf, vsi_seid);\n\t\t\telse\n\t\t\t\ti40e_dbg_dump_veb_all(pf);\n\t\t} else if (strncmp(&cmd_buf[5], \"vf\", 2) == 0) {\n\t\t\tcnt = sscanf(&cmd_buf[7], \"%i\", &vf_id);\n\t\t\tif (cnt > 0)\n\t\t\t\ti40e_dbg_dump_vf(pf, vf_id);\n\t\t\telse\n\t\t\t\ti40e_dbg_dump_vf_all(pf);\n\t\t} else if (strncmp(&cmd_buf[5], \"desc\", 4) == 0) {\n\t\t\tint ring_id, desc_n;\n\t\t\tif (strncmp(&cmd_buf[10], \"rx\", 2) == 0) {\n\t\t\t\tcnt = sscanf(&cmd_buf[12], \"%i %i %i\",\n\t\t\t\t\t     &vsi_seid, &ring_id, &desc_n);\n\t\t\t\ti40e_dbg_dump_desc(cnt, vsi_seid, ring_id,\n\t\t\t\t\t\t   desc_n, pf, RING_TYPE_RX);\n\t\t\t} else if (strncmp(&cmd_buf[10], \"tx\", 2)\n\t\t\t\t\t== 0) {\n\t\t\t\tcnt = sscanf(&cmd_buf[12], \"%i %i %i\",\n\t\t\t\t\t     &vsi_seid, &ring_id, &desc_n);\n\t\t\t\ti40e_dbg_dump_desc(cnt, vsi_seid, ring_id,\n\t\t\t\t\t\t   desc_n, pf, RING_TYPE_TX);\n\t\t\t} else if (strncmp(&cmd_buf[10], \"xdp\", 3)\n\t\t\t\t\t== 0) {\n\t\t\t\tcnt = sscanf(&cmd_buf[13], \"%i %i %i\",\n\t\t\t\t\t     &vsi_seid, &ring_id, &desc_n);\n\t\t\t\ti40e_dbg_dump_desc(cnt, vsi_seid, ring_id,\n\t\t\t\t\t\t   desc_n, pf, RING_TYPE_XDP);\n\t\t\t} else if (strncmp(&cmd_buf[10], \"aq\", 2) == 0) {\n\t\t\t\ti40e_dbg_dump_aq_desc(pf);\n\t\t\t} else {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"dump desc tx <vsi_seid> <ring_id> [<desc_n>]\\n\");\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"dump desc rx <vsi_seid> <ring_id> [<desc_n>]\\n\");\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"dump desc xdp <vsi_seid> <ring_id> [<desc_n>]\\n\");\n\t\t\t\tdev_info(&pf->pdev->dev, \"dump desc aq\\n\");\n\t\t\t}\n\t\t} else if (strncmp(&cmd_buf[5], \"reset stats\", 11) == 0) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"core reset count: %d\\n\", pf->corer_count);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"global reset count: %d\\n\", pf->globr_count);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"emp reset count: %d\\n\", pf->empr_count);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"pf reset count: %d\\n\", pf->pfr_count);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"pf tx sluggish count: %d\\n\",\n\t\t\t\t pf->tx_sluggish_count);\n\t\t} else if (strncmp(&cmd_buf[5], \"port\", 4) == 0) {\n\t\t\tstruct i40e_aqc_query_port_ets_config_resp *bw_data;\n\t\t\tstruct i40e_dcbx_config *cfg =\n\t\t\t\t\t\t&pf->hw.local_dcbx_config;\n\t\t\tstruct i40e_dcbx_config *r_cfg =\n\t\t\t\t\t\t&pf->hw.remote_dcbx_config;\n\t\t\tint i, ret;\n\t\t\tu16 switch_id;\n\n\t\t\tbw_data = kzalloc(sizeof(\n\t\t\t\t    struct i40e_aqc_query_port_ets_config_resp),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!bw_data) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\n\t\t\tvsi = pf->vsi[pf->lan_vsi];\n\t\t\tswitch_id =\n\t\t\t\tle16_to_cpu(vsi->info.switch_id) &\n\t\t\t\t\t    I40E_AQ_VSI_SW_ID_MASK;\n\n\t\t\tret = i40e_aq_query_port_ets_config(&pf->hw,\n\t\t\t\t\t\t\t    switch_id,\n\t\t\t\t\t\t\t    bw_data, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Query Port ETS Config AQ command failed =0x%x\\n\",\n\t\t\t\t\t pf->hw.aq.asq_last_status);\n\t\t\t\tkfree(bw_data);\n\t\t\t\tbw_data = NULL;\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"port bw: tc_valid=0x%x tc_strict_prio=0x%x, tc_bw_max=0x%04x,0x%04x\\n\",\n\t\t\t\t bw_data->tc_valid_bits,\n\t\t\t\t bw_data->tc_strict_priority_bits,\n\t\t\t\t le16_to_cpu(bw_data->tc_bw_max[0]),\n\t\t\t\t le16_to_cpu(bw_data->tc_bw_max[1]));\n\t\t\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t\t\tdev_info(&pf->pdev->dev, \"port bw: tc_bw_share=%d tc_bw_limit=%d\\n\",\n\t\t\t\t\t bw_data->tc_bw_share_credits[i],\n\t\t\t\t\t le16_to_cpu(bw_data->tc_bw_limits[i]));\n\t\t\t}\n\n\t\t\tkfree(bw_data);\n\t\t\tbw_data = NULL;\n\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"port dcbx_mode=%d\\n\", cfg->dcbx_mode);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"port ets_cfg: willing=%d cbs=%d, maxtcs=%d\\n\",\n\t\t\t\t cfg->etscfg.willing, cfg->etscfg.cbs,\n\t\t\t\t cfg->etscfg.maxtcs);\n\t\t\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t\t\tdev_info(&pf->pdev->dev, \"port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\\n\",\n\t\t\t\t\t i, cfg->etscfg.prioritytable[i],\n\t\t\t\t\t cfg->etscfg.tcbwtable[i],\n\t\t\t\t\t cfg->etscfg.tsatable[i]);\n\t\t\t}\n\t\t\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t\t\tdev_info(&pf->pdev->dev, \"port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\\n\",\n\t\t\t\t\t i, cfg->etsrec.prioritytable[i],\n\t\t\t\t\t cfg->etsrec.tcbwtable[i],\n\t\t\t\t\t cfg->etsrec.tsatable[i]);\n\t\t\t}\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\\n\",\n\t\t\t\t cfg->pfc.willing, cfg->pfc.mbc,\n\t\t\t\t cfg->pfc.pfccap, cfg->pfc.pfcenable);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"port app_table: num_apps=%d\\n\", cfg->numapps);\n\t\t\tfor (i = 0; i < cfg->numapps; i++) {\n\t\t\t\tdev_info(&pf->pdev->dev, \"port app_table: %d prio=%d selector=%d protocol=0x%x\\n\",\n\t\t\t\t\t i, cfg->app[i].priority,\n\t\t\t\t\t cfg->app[i].selector,\n\t\t\t\t\t cfg->app[i].protocolid);\n\t\t\t}\n\t\t\t \n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"remote port ets_cfg: willing=%d cbs=%d, maxtcs=%d\\n\",\n\t\t\t\t r_cfg->etscfg.willing,\n\t\t\t\t r_cfg->etscfg.cbs, r_cfg->etscfg.maxtcs);\n\t\t\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t\t\tdev_info(&pf->pdev->dev, \"remote port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\\n\",\n\t\t\t\t\t i, r_cfg->etscfg.prioritytable[i],\n\t\t\t\t\t r_cfg->etscfg.tcbwtable[i],\n\t\t\t\t\t r_cfg->etscfg.tsatable[i]);\n\t\t\t}\n\t\t\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t\t\tdev_info(&pf->pdev->dev, \"remote port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\\n\",\n\t\t\t\t\t i, r_cfg->etsrec.prioritytable[i],\n\t\t\t\t\t r_cfg->etsrec.tcbwtable[i],\n\t\t\t\t\t r_cfg->etsrec.tsatable[i]);\n\t\t\t}\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"remote port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\\n\",\n\t\t\t\t r_cfg->pfc.willing,\n\t\t\t\t r_cfg->pfc.mbc,\n\t\t\t\t r_cfg->pfc.pfccap,\n\t\t\t\t r_cfg->pfc.pfcenable);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"remote port app_table: num_apps=%d\\n\",\n\t\t\t\t r_cfg->numapps);\n\t\t\tfor (i = 0; i < r_cfg->numapps; i++) {\n\t\t\t\tdev_info(&pf->pdev->dev, \"remote port app_table: %d prio=%d selector=%d protocol=0x%x\\n\",\n\t\t\t\t\t i, r_cfg->app[i].priority,\n\t\t\t\t\t r_cfg->app[i].selector,\n\t\t\t\t\t r_cfg->app[i].protocolid);\n\t\t\t}\n\t\t} else if (strncmp(&cmd_buf[5], \"debug fwdata\", 12) == 0) {\n\t\t\tint cluster_id, table_id;\n\t\t\tint index, ret;\n\t\t\tu16 buff_len = 4096;\n\t\t\tu32 next_index;\n\t\t\tu8 next_table;\n\t\t\tu8 *buff;\n\t\t\tu16 rlen;\n\n\t\t\tcnt = sscanf(&cmd_buf[18], \"%i %i %i\",\n\t\t\t\t     &cluster_id, &table_id, &index);\n\t\t\tif (cnt != 3) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"dump debug fwdata <cluster_id> <table_id> <index>\\n\");\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"AQ debug dump fwdata params %x %x %x %x\\n\",\n\t\t\t\t cluster_id, table_id, index, buff_len);\n\t\t\tbuff = kzalloc(buff_len, GFP_KERNEL);\n\t\t\tif (!buff)\n\t\t\t\tgoto command_write_done;\n\n\t\t\tret = i40e_aq_debug_dump(&pf->hw, cluster_id, table_id,\n\t\t\t\t\t\t index, buff_len, buff, &rlen,\n\t\t\t\t\t\t &next_table, &next_index,\n\t\t\t\t\t\t NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"debug dump fwdata AQ Failed %d 0x%x\\n\",\n\t\t\t\t\t ret, pf->hw.aq.asq_last_status);\n\t\t\t\tkfree(buff);\n\t\t\t\tbuff = NULL;\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"AQ debug dump fwdata rlen=0x%x next_table=0x%x next_index=0x%x\\n\",\n\t\t\t\t rlen, next_table, next_index);\n\t\t\tprint_hex_dump(KERN_INFO, \"AQ buffer WB: \",\n\t\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t       buff, rlen, true);\n\t\t\tkfree(buff);\n\t\t\tbuff = NULL;\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"dump desc tx <vsi_seid> <ring_id> [<desc_n>], dump desc rx <vsi_seid> <ring_id> [<desc_n>], dump desc xdp <vsi_seid> <ring_id> [<desc_n>],\\n\");\n\t\t\tdev_info(&pf->pdev->dev, \"dump switch\\n\");\n\t\t\tdev_info(&pf->pdev->dev, \"dump vsi [seid]\\n\");\n\t\t\tdev_info(&pf->pdev->dev, \"dump reset stats\\n\");\n\t\t\tdev_info(&pf->pdev->dev, \"dump port\\n\");\n\t\t\tdev_info(&pf->pdev->dev, \"dump vf [vf_id]\\n\");\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"dump debug fwdata <cluster_id> <table_id> <index>\\n\");\n\t\t}\n\t} else if (strncmp(cmd_buf, \"pfr\", 3) == 0) {\n\t\tdev_info(&pf->pdev->dev, \"debugfs: forcing PFR\\n\");\n\t\ti40e_do_reset_safe(pf, BIT(__I40E_PF_RESET_REQUESTED));\n\n\t} else if (strncmp(cmd_buf, \"corer\", 5) == 0) {\n\t\tdev_info(&pf->pdev->dev, \"debugfs: forcing CoreR\\n\");\n\t\ti40e_do_reset_safe(pf, BIT(__I40E_CORE_RESET_REQUESTED));\n\n\t} else if (strncmp(cmd_buf, \"globr\", 5) == 0) {\n\t\tdev_info(&pf->pdev->dev, \"debugfs: forcing GlobR\\n\");\n\t\ti40e_do_reset_safe(pf, BIT(__I40E_GLOBAL_RESET_REQUESTED));\n\n\t} else if (strncmp(cmd_buf, \"read\", 4) == 0) {\n\t\tu32 address;\n\t\tu32 value;\n\n\t\tcnt = sscanf(&cmd_buf[4], \"%i\", &address);\n\t\tif (cnt != 1) {\n\t\t\tdev_info(&pf->pdev->dev, \"read <reg>\\n\");\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\t \n\t\tif (address > (pf->ioremap_len - sizeof(u32))) {\n\t\t\tdev_info(&pf->pdev->dev, \"read reg address 0x%08x too large, max=0x%08lx\\n\",\n\t\t\t\t address, (unsigned long int)(pf->ioremap_len - sizeof(u32)));\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tvalue = rd32(&pf->hw, address);\n\t\tdev_info(&pf->pdev->dev, \"read: 0x%08x = 0x%08x\\n\",\n\t\t\t address, value);\n\n\t} else if (strncmp(cmd_buf, \"write\", 5) == 0) {\n\t\tu32 address, value;\n\n\t\tcnt = sscanf(&cmd_buf[5], \"%i %i\", &address, &value);\n\t\tif (cnt != 2) {\n\t\t\tdev_info(&pf->pdev->dev, \"write <reg> <value>\\n\");\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\t \n\t\tif (address > (pf->ioremap_len - sizeof(u32))) {\n\t\t\tdev_info(&pf->pdev->dev, \"write reg address 0x%08x too large, max=0x%08lx\\n\",\n\t\t\t\t address, (unsigned long int)(pf->ioremap_len - sizeof(u32)));\n\t\t\tgoto command_write_done;\n\t\t}\n\t\twr32(&pf->hw, address, value);\n\t\tvalue = rd32(&pf->hw, address);\n\t\tdev_info(&pf->pdev->dev, \"write: 0x%08x = 0x%08x\\n\",\n\t\t\t address, value);\n\t} else if (strncmp(cmd_buf, \"clear_stats\", 11) == 0) {\n\t\tif (strncmp(&cmd_buf[12], \"vsi\", 3) == 0) {\n\t\t\tcnt = sscanf(&cmd_buf[15], \"%i\", &vsi_seid);\n\t\t\tif (cnt == 0) {\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < pf->num_alloc_vsi; i++)\n\t\t\t\t\ti40e_vsi_reset_stats(pf->vsi[i]);\n\t\t\t\tdev_info(&pf->pdev->dev, \"vsi clear stats called for all vsi's\\n\");\n\t\t\t} else if (cnt == 1) {\n\t\t\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\t\t\tif (!vsi) {\n\t\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t\t \"clear_stats vsi: bad vsi %d\\n\",\n\t\t\t\t\t\t vsi_seid);\n\t\t\t\t\tgoto command_write_done;\n\t\t\t\t}\n\t\t\t\ti40e_vsi_reset_stats(vsi);\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"vsi clear stats called for vsi %d\\n\",\n\t\t\t\t\t vsi_seid);\n\t\t\t} else {\n\t\t\t\tdev_info(&pf->pdev->dev, \"clear_stats vsi [seid]\\n\");\n\t\t\t}\n\t\t} else if (strncmp(&cmd_buf[12], \"port\", 4) == 0) {\n\t\t\tif (pf->hw.partition_id == 1) {\n\t\t\t\ti40e_pf_reset_stats(pf);\n\t\t\t\tdev_info(&pf->pdev->dev, \"port stats cleared\\n\");\n\t\t\t} else {\n\t\t\t\tdev_info(&pf->pdev->dev, \"clear port stats not allowed on this port partition\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev, \"clear_stats vsi [seid] or clear_stats port\\n\");\n\t\t}\n\t} else if (strncmp(cmd_buf, \"send aq_cmd\", 11) == 0) {\n\t\tstruct i40e_aq_desc *desc;\n\t\tint ret;\n\n\t\tdesc = kzalloc(sizeof(struct i40e_aq_desc), GFP_KERNEL);\n\t\tif (!desc)\n\t\t\tgoto command_write_done;\n\t\tcnt = sscanf(&cmd_buf[11],\n\t\t\t     \"%hi %hi %hi %hi %i %i %i %i %i %i\",\n\t\t\t     &desc->flags,\n\t\t\t     &desc->opcode, &desc->datalen, &desc->retval,\n\t\t\t     &desc->cookie_high, &desc->cookie_low,\n\t\t\t     &desc->params.internal.param0,\n\t\t\t     &desc->params.internal.param1,\n\t\t\t     &desc->params.internal.param2,\n\t\t\t     &desc->params.internal.param3);\n\t\tif (cnt != 10) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"send aq_cmd: bad command string, cnt=%d\\n\",\n\t\t\t\t cnt);\n\t\t\tkfree(desc);\n\t\t\tdesc = NULL;\n\t\t\tgoto command_write_done;\n\t\t}\n\t\tret = i40e_asq_send_command(&pf->hw, desc, NULL, 0, NULL);\n\t\tif (!ret) {\n\t\t\tdev_info(&pf->pdev->dev, \"AQ command sent Status : Success\\n\");\n\t\t} else if (ret == -EIO) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"AQ command send failed Opcode %x AQ Error: %d\\n\",\n\t\t\t\t desc->opcode, pf->hw.aq.asq_last_status);\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"AQ command send failed Opcode %x Status: %d\\n\",\n\t\t\t\t desc->opcode, ret);\n\t\t}\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t desc->flags, desc->opcode, desc->datalen, desc->retval,\n\t\t\t desc->cookie_high, desc->cookie_low,\n\t\t\t desc->params.internal.param0,\n\t\t\t desc->params.internal.param1,\n\t\t\t desc->params.internal.param2,\n\t\t\t desc->params.internal.param3);\n\t\tkfree(desc);\n\t\tdesc = NULL;\n\t} else if (strncmp(cmd_buf, \"send indirect aq_cmd\", 20) == 0) {\n\t\tstruct i40e_aq_desc *desc;\n\t\tu16 buffer_len;\n\t\tu8 *buff;\n\t\tint ret;\n\n\t\tdesc = kzalloc(sizeof(struct i40e_aq_desc), GFP_KERNEL);\n\t\tif (!desc)\n\t\t\tgoto command_write_done;\n\t\tcnt = sscanf(&cmd_buf[20],\n\t\t\t     \"%hi %hi %hi %hi %i %i %i %i %i %i %hi\",\n\t\t\t     &desc->flags,\n\t\t\t     &desc->opcode, &desc->datalen, &desc->retval,\n\t\t\t     &desc->cookie_high, &desc->cookie_low,\n\t\t\t     &desc->params.internal.param0,\n\t\t\t     &desc->params.internal.param1,\n\t\t\t     &desc->params.internal.param2,\n\t\t\t     &desc->params.internal.param3,\n\t\t\t     &buffer_len);\n\t\tif (cnt != 11) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"send indirect aq_cmd: bad command string, cnt=%d\\n\",\n\t\t\t\t cnt);\n\t\t\tkfree(desc);\n\t\t\tdesc = NULL;\n\t\t\tgoto command_write_done;\n\t\t}\n\t\t \n\t\tif (buffer_len == 0)\n\t\t\tbuffer_len = 1280;\n\n\t\tbuff = kzalloc(buffer_len, GFP_KERNEL);\n\t\tif (!buff) {\n\t\t\tkfree(desc);\n\t\t\tdesc = NULL;\n\t\t\tgoto command_write_done;\n\t\t}\n\t\tdesc->flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\n\t\tret = i40e_asq_send_command(&pf->hw, desc, buff,\n\t\t\t\t\t    buffer_len, NULL);\n\t\tif (!ret) {\n\t\t\tdev_info(&pf->pdev->dev, \"AQ command sent Status : Success\\n\");\n\t\t} else if (ret == -EIO) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"AQ command send failed Opcode %x AQ Error: %d\\n\",\n\t\t\t\t desc->opcode, pf->hw.aq.asq_last_status);\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"AQ command send failed Opcode %x Status: %d\\n\",\n\t\t\t\t desc->opcode, ret);\n\t\t}\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t desc->flags, desc->opcode, desc->datalen, desc->retval,\n\t\t\t desc->cookie_high, desc->cookie_low,\n\t\t\t desc->params.internal.param0,\n\t\t\t desc->params.internal.param1,\n\t\t\t desc->params.internal.param2,\n\t\t\t desc->params.internal.param3);\n\t\tprint_hex_dump(KERN_INFO, \"AQ buffer WB: \",\n\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       buff, buffer_len, true);\n\t\tkfree(buff);\n\t\tbuff = NULL;\n\t\tkfree(desc);\n\t\tdesc = NULL;\n\t} else if (strncmp(cmd_buf, \"fd current cnt\", 14) == 0) {\n\t\tdev_info(&pf->pdev->dev, \"FD current total filter count for this interface: %d\\n\",\n\t\t\t i40e_get_current_fd_count(pf));\n\t} else if (strncmp(cmd_buf, \"lldp\", 4) == 0) {\n\t\tif (strncmp(&cmd_buf[5], \"stop\", 4) == 0) {\n\t\t\tint ret;\n\n\t\t\tret = i40e_aq_stop_lldp(&pf->hw, false, false, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Stop LLDP AQ command failed =0x%x\\n\",\n\t\t\t\t\t pf->hw.aq.asq_last_status);\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\t\t\tret = i40e_aq_add_rem_control_packet_filter(&pf->hw,\n\t\t\t\t\t\tpf->hw.mac.addr,\n\t\t\t\t\t\tETH_P_LLDP, 0,\n\t\t\t\t\t\tpf->vsi[pf->lan_vsi]->seid,\n\t\t\t\t\t\t0, true, NULL, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t\"%s: Add Control Packet Filter AQ command failed =0x%x\\n\",\n\t\t\t\t\t__func__, pf->hw.aq.asq_last_status);\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n#ifdef CONFIG_I40E_DCB\n\t\t\tpf->dcbx_cap = DCB_CAP_DCBX_HOST |\n\t\t\t\t       DCB_CAP_DCBX_VER_IEEE;\n#endif  \n\t\t} else if (strncmp(&cmd_buf[5], \"start\", 5) == 0) {\n\t\t\tint ret;\n\n\t\t\tret = i40e_aq_add_rem_control_packet_filter(&pf->hw,\n\t\t\t\t\t\tpf->hw.mac.addr,\n\t\t\t\t\t\tETH_P_LLDP, 0,\n\t\t\t\t\t\tpf->vsi[pf->lan_vsi]->seid,\n\t\t\t\t\t\t0, false, NULL, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t\"%s: Remove Control Packet Filter AQ command failed =0x%x\\n\",\n\t\t\t\t\t__func__, pf->hw.aq.asq_last_status);\n\t\t\t\t \n\t\t\t}\n\n\t\t\tret = i40e_aq_start_lldp(&pf->hw, false, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Start LLDP AQ command failed =0x%x\\n\",\n\t\t\t\t\t pf->hw.aq.asq_last_status);\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n#ifdef CONFIG_I40E_DCB\n\t\t\tpf->dcbx_cap = DCB_CAP_DCBX_LLD_MANAGED |\n\t\t\t\t       DCB_CAP_DCBX_VER_IEEE;\n#endif  \n\t\t} else if (strncmp(&cmd_buf[5],\n\t\t\t   \"get local\", 9) == 0) {\n\t\t\tu16 llen, rlen;\n\t\t\tint ret;\n\t\t\tu8 *buff;\n\n\t\t\tbuff = kzalloc(I40E_LLDPDU_SIZE, GFP_KERNEL);\n\t\t\tif (!buff)\n\t\t\t\tgoto command_write_done;\n\n\t\t\tret = i40e_aq_get_lldp_mib(&pf->hw, 0,\n\t\t\t\t\t\t   I40E_AQ_LLDP_MIB_LOCAL,\n\t\t\t\t\t\t   buff, I40E_LLDPDU_SIZE,\n\t\t\t\t\t\t   &llen, &rlen, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Get LLDP MIB (local) AQ command failed =0x%x\\n\",\n\t\t\t\t\t pf->hw.aq.asq_last_status);\n\t\t\t\tkfree(buff);\n\t\t\t\tbuff = NULL;\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\t\t\tdev_info(&pf->pdev->dev, \"LLDP MIB (local)\\n\");\n\t\t\tprint_hex_dump(KERN_INFO, \"LLDP MIB (local): \",\n\t\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t       buff, I40E_LLDPDU_SIZE, true);\n\t\t\tkfree(buff);\n\t\t\tbuff = NULL;\n\t\t} else if (strncmp(&cmd_buf[5], \"get remote\", 10) == 0) {\n\t\t\tu16 llen, rlen;\n\t\t\tint ret;\n\t\t\tu8 *buff;\n\n\t\t\tbuff = kzalloc(I40E_LLDPDU_SIZE, GFP_KERNEL);\n\t\t\tif (!buff)\n\t\t\t\tgoto command_write_done;\n\n\t\t\tret = i40e_aq_get_lldp_mib(&pf->hw,\n\t\t\t\t\tI40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE,\n\t\t\t\t\tI40E_AQ_LLDP_MIB_REMOTE,\n\t\t\t\t\tbuff, I40E_LLDPDU_SIZE,\n\t\t\t\t\t&llen, &rlen, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Get LLDP MIB (remote) AQ command failed =0x%x\\n\",\n\t\t\t\t\t pf->hw.aq.asq_last_status);\n\t\t\t\tkfree(buff);\n\t\t\t\tbuff = NULL;\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\t\t\tdev_info(&pf->pdev->dev, \"LLDP MIB (remote)\\n\");\n\t\t\tprint_hex_dump(KERN_INFO, \"LLDP MIB (remote): \",\n\t\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t       buff, I40E_LLDPDU_SIZE, true);\n\t\t\tkfree(buff);\n\t\t\tbuff = NULL;\n\t\t} else if (strncmp(&cmd_buf[5], \"event on\", 8) == 0) {\n\t\t\tint ret;\n\n\t\t\tret = i40e_aq_cfg_lldp_mib_change_event(&pf->hw,\n\t\t\t\t\t\t\t\ttrue, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Config LLDP MIB Change Event (on) AQ command failed =0x%x\\n\",\n\t\t\t\t\t pf->hw.aq.asq_last_status);\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\t\t} else if (strncmp(&cmd_buf[5], \"event off\", 9) == 0) {\n\t\t\tint ret;\n\n\t\t\tret = i40e_aq_cfg_lldp_mib_change_event(&pf->hw,\n\t\t\t\t\t\t\t\tfalse, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Config LLDP MIB Change Event (off) AQ command failed =0x%x\\n\",\n\t\t\t\t\t pf->hw.aq.asq_last_status);\n\t\t\t\tgoto command_write_done;\n\t\t\t}\n\t\t}\n\t} else if (strncmp(cmd_buf, \"nvm read\", 8) == 0) {\n\t\tu16 buffer_len, bytes;\n\t\tu16 module;\n\t\tu32 offset;\n\t\tu16 *buff;\n\t\tint ret;\n\n\t\tcnt = sscanf(&cmd_buf[8], \"%hx %x %hx\",\n\t\t\t     &module, &offset, &buffer_len);\n\t\tif (cnt == 0) {\n\t\t\tmodule = 0;\n\t\t\toffset = 0;\n\t\t\tbuffer_len = 0;\n\t\t} else if (cnt == 1) {\n\t\t\toffset = 0;\n\t\t\tbuffer_len = 0;\n\t\t} else if (cnt == 2) {\n\t\t\tbuffer_len = 0;\n\t\t} else if (cnt > 3) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"nvm read: bad command string, cnt=%d\\n\", cnt);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\t \n\t\tbuffer_len = min_t(u16, buffer_len, I40E_MAX_AQ_BUF_SIZE/2);\n\n\t\tbytes = 2 * buffer_len;\n\n\t\t \n\t\tbytes = clamp(bytes, (u16)1024, (u16)I40E_MAX_AQ_BUF_SIZE);\n\t\tbuff = kzalloc(bytes, GFP_KERNEL);\n\t\tif (!buff)\n\t\t\tgoto command_write_done;\n\n\t\tret = i40e_acquire_nvm(&pf->hw, I40E_RESOURCE_READ);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Failed Acquiring NVM resource for read err=%d status=0x%x\\n\",\n\t\t\t\t ret, pf->hw.aq.asq_last_status);\n\t\t\tkfree(buff);\n\t\t\tgoto command_write_done;\n\t\t}\n\n\t\tret = i40e_aq_read_nvm(&pf->hw, module, (2 * offset),\n\t\t\t\t       bytes, (u8 *)buff, true, NULL);\n\t\ti40e_release_nvm(&pf->hw);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Read NVM AQ failed err=%d status=0x%x\\n\",\n\t\t\t\t ret, pf->hw.aq.asq_last_status);\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Read NVM module=0x%x offset=0x%x words=%d\\n\",\n\t\t\t\t module, offset, buffer_len);\n\t\t\tif (bytes)\n\t\t\t\tprint_hex_dump(KERN_INFO, \"NVM Dump: \",\n\t\t\t\t\tDUMP_PREFIX_OFFSET, 16, 2,\n\t\t\t\t\tbuff, bytes, true);\n\t\t}\n\t\tkfree(buff);\n\t\tbuff = NULL;\n\t} else {\n\t\tdev_info(&pf->pdev->dev, \"unknown command '%s'\\n\", cmd_buf);\n\t\tdev_info(&pf->pdev->dev, \"available commands\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  add vsi [relay_seid]\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  del vsi [vsi_seid]\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  add relay <uplink_seid> <vsi_seid>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  del relay <relay_seid>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  add pvid <vsi_seid> <vid>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  del pvid <vsi_seid>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump switch\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump vsi [seid]\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump desc tx <vsi_seid> <ring_id> [<desc_n>]\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump desc rx <vsi_seid> <ring_id> [<desc_n>]\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump desc xdp <vsi_seid> <ring_id> [<desc_n>]\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump desc aq\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump reset stats\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  dump debug fwdata <cluster_id> <table_id> <index>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  read <reg>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  write <reg> <value>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  clear_stats vsi [seid]\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  clear_stats port\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  pfr\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  corer\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  globr\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  send aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  send indirect aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3> <buffer_len>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  fd current cnt\");\n\t\tdev_info(&pf->pdev->dev, \"  lldp start\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  lldp stop\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  lldp get local\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  lldp get remote\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  lldp event on\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  lldp event off\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  nvm read [module] [word_offset] [word_count]\\n\");\n\t}\n\ncommand_write_done:\n\tkfree(cmd_buf);\n\tcmd_buf = NULL;\n\treturn count;\n}\n\nstatic const struct file_operations i40e_dbg_command_fops = {\n\t.owner = THIS_MODULE,\n\t.open =  simple_open,\n\t.read =  i40e_dbg_command_read,\n\t.write = i40e_dbg_command_write,\n};\n\n \nstatic char i40e_dbg_netdev_ops_buf[256] = \"\";\n\n \nstatic ssize_t i40e_dbg_netdev_ops_read(struct file *filp, char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct i40e_pf *pf = filp->private_data;\n\tint bytes_not_copied;\n\tint buf_size = 256;\n\tchar *buf;\n\tint len;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\tif (count < buf_size)\n\t\treturn -ENOSPC;\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOSPC;\n\n\tlen = snprintf(buf, buf_size, \"%s: %s\\n\",\n\t\t       pf->vsi[pf->lan_vsi]->netdev->name,\n\t\t       i40e_dbg_netdev_ops_buf);\n\n\tbytes_not_copied = copy_to_user(buffer, buf, len);\n\tkfree(buf);\n\n\tif (bytes_not_copied)\n\t\treturn -EFAULT;\n\n\t*ppos = len;\n\treturn len;\n}\n\n \nstatic ssize_t i40e_dbg_netdev_ops_write(struct file *filp,\n\t\t\t\t\t const char __user *buffer,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct i40e_pf *pf = filp->private_data;\n\tint bytes_not_copied;\n\tstruct i40e_vsi *vsi;\n\tchar *buf_tmp;\n\tint vsi_seid;\n\tint i, cnt;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\tif (count >= sizeof(i40e_dbg_netdev_ops_buf))\n\t\treturn -ENOSPC;\n\n\tmemset(i40e_dbg_netdev_ops_buf, 0, sizeof(i40e_dbg_netdev_ops_buf));\n\tbytes_not_copied = copy_from_user(i40e_dbg_netdev_ops_buf,\n\t\t\t\t\t  buffer, count);\n\tif (bytes_not_copied)\n\t\treturn -EFAULT;\n\ti40e_dbg_netdev_ops_buf[count] = '\\0';\n\n\tbuf_tmp = strchr(i40e_dbg_netdev_ops_buf, '\\n');\n\tif (buf_tmp) {\n\t\t*buf_tmp = '\\0';\n\t\tcount = buf_tmp - i40e_dbg_netdev_ops_buf + 1;\n\t}\n\n\tif (strncmp(i40e_dbg_netdev_ops_buf, \"change_mtu\", 10) == 0) {\n\t\tint mtu;\n\n\t\tcnt = sscanf(&i40e_dbg_netdev_ops_buf[11], \"%i %i\",\n\t\t\t     &vsi_seid, &mtu);\n\t\tif (cnt != 2) {\n\t\t\tdev_info(&pf->pdev->dev, \"change_mtu <vsi_seid> <mtu>\\n\");\n\t\t\tgoto netdev_ops_write_done;\n\t\t}\n\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"change_mtu: VSI %d not found\\n\", vsi_seid);\n\t\t} else if (!vsi->netdev) {\n\t\t\tdev_info(&pf->pdev->dev, \"change_mtu: no netdev for VSI %d\\n\",\n\t\t\t\t vsi_seid);\n\t\t} else if (rtnl_trylock()) {\n\t\t\tvsi->netdev->netdev_ops->ndo_change_mtu(vsi->netdev,\n\t\t\t\t\t\t\t\tmtu);\n\t\t\trtnl_unlock();\n\t\t\tdev_info(&pf->pdev->dev, \"change_mtu called\\n\");\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev, \"Could not acquire RTNL - please try again\\n\");\n\t\t}\n\n\t} else if (strncmp(i40e_dbg_netdev_ops_buf, \"set_rx_mode\", 11) == 0) {\n\t\tcnt = sscanf(&i40e_dbg_netdev_ops_buf[11], \"%i\", &vsi_seid);\n\t\tif (cnt != 1) {\n\t\t\tdev_info(&pf->pdev->dev, \"set_rx_mode <vsi_seid>\\n\");\n\t\t\tgoto netdev_ops_write_done;\n\t\t}\n\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"set_rx_mode: VSI %d not found\\n\", vsi_seid);\n\t\t} else if (!vsi->netdev) {\n\t\t\tdev_info(&pf->pdev->dev, \"set_rx_mode: no netdev for VSI %d\\n\",\n\t\t\t\t vsi_seid);\n\t\t} else if (rtnl_trylock()) {\n\t\t\tvsi->netdev->netdev_ops->ndo_set_rx_mode(vsi->netdev);\n\t\t\trtnl_unlock();\n\t\t\tdev_info(&pf->pdev->dev, \"set_rx_mode called\\n\");\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev, \"Could not acquire RTNL - please try again\\n\");\n\t\t}\n\n\t} else if (strncmp(i40e_dbg_netdev_ops_buf, \"napi\", 4) == 0) {\n\t\tcnt = sscanf(&i40e_dbg_netdev_ops_buf[4], \"%i\", &vsi_seid);\n\t\tif (cnt != 1) {\n\t\t\tdev_info(&pf->pdev->dev, \"napi <vsi_seid>\\n\");\n\t\t\tgoto netdev_ops_write_done;\n\t\t}\n\t\tvsi = i40e_dbg_find_vsi(pf, vsi_seid);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev, \"napi: VSI %d not found\\n\",\n\t\t\t\t vsi_seid);\n\t\t} else if (!vsi->netdev) {\n\t\t\tdev_info(&pf->pdev->dev, \"napi: no netdev for VSI %d\\n\",\n\t\t\t\t vsi_seid);\n\t\t} else {\n\t\t\tfor (i = 0; i < vsi->num_q_vectors; i++)\n\t\t\t\tnapi_schedule(&vsi->q_vectors[i]->napi);\n\t\t\tdev_info(&pf->pdev->dev, \"napi called\\n\");\n\t\t}\n\t} else {\n\t\tdev_info(&pf->pdev->dev, \"unknown command '%s'\\n\",\n\t\t\t i40e_dbg_netdev_ops_buf);\n\t\tdev_info(&pf->pdev->dev, \"available commands\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  change_mtu <vsi_seid> <mtu>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  set_rx_mode <vsi_seid>\\n\");\n\t\tdev_info(&pf->pdev->dev, \"  napi <vsi_seid>\\n\");\n\t}\nnetdev_ops_write_done:\n\treturn count;\n}\n\nstatic const struct file_operations i40e_dbg_netdev_ops_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = i40e_dbg_netdev_ops_read,\n\t.write = i40e_dbg_netdev_ops_write,\n};\n\n \nvoid i40e_dbg_pf_init(struct i40e_pf *pf)\n{\n\tconst char *name = pci_name(pf->pdev);\n\n\tpf->i40e_dbg_pf = debugfs_create_dir(name, i40e_dbg_root);\n\n\tdebugfs_create_file(\"command\", 0600, pf->i40e_dbg_pf, pf,\n\t\t\t    &i40e_dbg_command_fops);\n\n\tdebugfs_create_file(\"netdev_ops\", 0600, pf->i40e_dbg_pf, pf,\n\t\t\t    &i40e_dbg_netdev_ops_fops);\n}\n\n \nvoid i40e_dbg_pf_exit(struct i40e_pf *pf)\n{\n\tdebugfs_remove_recursive(pf->i40e_dbg_pf);\n\tpf->i40e_dbg_pf = NULL;\n}\n\n \nvoid i40e_dbg_init(void)\n{\n\ti40e_dbg_root = debugfs_create_dir(i40e_driver_name, NULL);\n\tif (IS_ERR(i40e_dbg_root))\n\t\tpr_info(\"init of debugfs failed\\n\");\n}\n\n \nvoid i40e_dbg_exit(void)\n{\n\tdebugfs_remove_recursive(i40e_dbg_root);\n\ti40e_dbg_root = NULL;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}