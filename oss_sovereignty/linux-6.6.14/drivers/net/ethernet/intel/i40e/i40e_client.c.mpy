{
  "module_name": "i40e_client.c",
  "hash_id": "0ba4d716fe1a6ef9f511723454f3be8079d3c985148e374c33008d4996de8d29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_client.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/net/intel/i40e_client.h>\n\n#include \"i40e.h\"\n#include \"i40e_prototype.h\"\n\nstatic LIST_HEAD(i40e_devices);\nstatic DEFINE_MUTEX(i40e_device_mutex);\nDEFINE_IDA(i40e_client_ida);\n\nstatic int i40e_client_virtchnl_send(struct i40e_info *ldev,\n\t\t\t\t     struct i40e_client *client,\n\t\t\t\t     u32 vf_id, u8 *msg, u16 len);\n\nstatic int i40e_client_setup_qvlist(struct i40e_info *ldev,\n\t\t\t\t    struct i40e_client *client,\n\t\t\t\t    struct i40e_qvlist_info *qvlist_info);\n\nstatic void i40e_client_request_reset(struct i40e_info *ldev,\n\t\t\t\t      struct i40e_client *client,\n\t\t\t\t      u32 reset_level);\n\nstatic int i40e_client_update_vsi_ctxt(struct i40e_info *ldev,\n\t\t\t\t       struct i40e_client *client,\n\t\t\t\t       bool is_vf, u32 vf_id,\n\t\t\t\t       u32 flag, u32 valid_flag);\n\nstatic struct i40e_ops i40e_lan_ops = {\n\t.virtchnl_send = i40e_client_virtchnl_send,\n\t.setup_qvlist = i40e_client_setup_qvlist,\n\t.request_reset = i40e_client_request_reset,\n\t.update_vsi_ctxt = i40e_client_update_vsi_ctxt,\n};\n\n \nstatic\nint i40e_client_get_params(struct i40e_vsi *vsi, struct i40e_params *params)\n{\n\tstruct i40e_dcbx_config *dcb_cfg = &vsi->back->hw.local_dcbx_config;\n\tint i = 0;\n\n\tfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {\n\t\tu8 tc = dcb_cfg->etscfg.prioritytable[i];\n\t\tu16 qs_handle;\n\n\t\t \n\t\tif (!(vsi->tc_config.enabled_tc & BIT(tc)))\n\t\t\ttc = 0;\n\n\t\tqs_handle = le16_to_cpu(vsi->info.qs_handle[tc]);\n\t\tparams->qos.prio_qos[i].tc = tc;\n\t\tparams->qos.prio_qos[i].qs_handle = qs_handle;\n\t\tif (qs_handle == I40E_AQ_VSI_QS_HANDLE_INVALID) {\n\t\t\tdev_err(&vsi->back->pdev->dev, \"Invalid queue set handle for TC = %d, vsi id = %d\\n\",\n\t\t\t\ttc, vsi->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tparams->mtu = vsi->netdev->mtu;\n\treturn 0;\n}\n\n \nvoid\ni40e_notify_client_of_vf_msg(struct i40e_vsi *vsi, u32 vf_id, u8 *msg, u16 len)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\n\tif (!cdev || !cdev->client)\n\t\treturn;\n\tif (!cdev->client->ops || !cdev->client->ops->virtchnl_receive) {\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Cannot locate client instance virtual channel receive routine\\n\");\n\t\treturn;\n\t}\n\tif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\n\t\tdev_dbg(&pf->pdev->dev, \"Client is not open, abort virtchnl_receive\\n\");\n\t\treturn;\n\t}\n\tcdev->client->ops->virtchnl_receive(&cdev->lan_info, cdev->client,\n\t\t\t\t\t    vf_id, msg, len);\n}\n\n \nvoid i40e_notify_client_of_l2_param_changes(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\tstruct i40e_params params;\n\n\tif (!cdev || !cdev->client)\n\t\treturn;\n\tif (!cdev->client->ops || !cdev->client->ops->l2_param_change) {\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Cannot locate client instance l2_param_change routine\\n\");\n\t\treturn;\n\t}\n\tif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\n\t\tdev_dbg(&vsi->back->pdev->dev, \"Client is not open, abort l2 param change\\n\");\n\t\treturn;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\ti40e_client_get_params(vsi, &params);\n\tmemcpy(&cdev->lan_info.params, &params, sizeof(struct i40e_params));\n\tcdev->client->ops->l2_param_change(&cdev->lan_info, cdev->client,\n\t\t\t\t\t   &params);\n}\n\n \nstatic void i40e_client_release_qvlist(struct i40e_info *ldev)\n{\n\tstruct i40e_qvlist_info *qvlist_info = ldev->qvlist_info;\n\tu32 i;\n\n\tif (!ldev->qvlist_info)\n\t\treturn;\n\n\tfor (i = 0; i < qvlist_info->num_vectors; i++) {\n\t\tstruct i40e_pf *pf = ldev->pf;\n\t\tstruct i40e_qv_info *qv_info;\n\t\tu32 reg_idx;\n\n\t\tqv_info = &qvlist_info->qv_info[i];\n\t\tif (!qv_info)\n\t\t\tcontinue;\n\t\treg_idx = I40E_PFINT_LNKLSTN(qv_info->v_idx - 1);\n\t\twr32(&pf->hw, reg_idx, I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK);\n\t}\n\tkfree(ldev->qvlist_info);\n\tldev->qvlist_info = NULL;\n}\n\n \nvoid i40e_notify_client_of_netdev_close(struct i40e_vsi *vsi, bool reset)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\n\tif (!cdev || !cdev->client)\n\t\treturn;\n\tif (!cdev->client->ops || !cdev->client->ops->close) {\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Cannot locate client instance close routine\\n\");\n\t\treturn;\n\t}\n\tif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\n\t\tdev_dbg(&pf->pdev->dev, \"Client is not open, abort close\\n\");\n\t\treturn;\n\t}\n\tcdev->client->ops->close(&cdev->lan_info, cdev->client, reset);\n\tclear_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\n\ti40e_client_release_qvlist(&cdev->lan_info);\n}\n\n \nvoid i40e_notify_client_of_vf_reset(struct i40e_pf *pf, u32 vf_id)\n{\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\n\tif (!cdev || !cdev->client)\n\t\treturn;\n\tif (!cdev->client->ops || !cdev->client->ops->vf_reset) {\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Cannot locate client instance VF reset routine\\n\");\n\t\treturn;\n\t}\n\tif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED,  &cdev->state)) {\n\t\tdev_dbg(&pf->pdev->dev, \"Client is not open, abort vf-reset\\n\");\n\t\treturn;\n\t}\n\tcdev->client->ops->vf_reset(&cdev->lan_info, cdev->client, vf_id);\n}\n\n \nvoid i40e_notify_client_of_vf_enable(struct i40e_pf *pf, u32 num_vfs)\n{\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\n\tif (!cdev || !cdev->client)\n\t\treturn;\n\tif (!cdev->client->ops || !cdev->client->ops->vf_enable) {\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Cannot locate client instance VF enable routine\\n\");\n\t\treturn;\n\t}\n\tif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED,\n\t\t      &cdev->state)) {\n\t\tdev_dbg(&pf->pdev->dev, \"Client is not open, abort vf-enable\\n\");\n\t\treturn;\n\t}\n\tcdev->client->ops->vf_enable(&cdev->lan_info, cdev->client, num_vfs);\n}\n\n \nint i40e_vf_client_capable(struct i40e_pf *pf, u32 vf_id)\n{\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\tint capable = false;\n\n\tif (!cdev || !cdev->client)\n\t\tgoto out;\n\tif (!cdev->client->ops || !cdev->client->ops->vf_capable) {\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Cannot locate client instance VF capability routine\\n\");\n\t\tgoto out;\n\t}\n\tif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state))\n\t\tgoto out;\n\n\tcapable = cdev->client->ops->vf_capable(&cdev->lan_info,\n\t\t\t\t\t\tcdev->client,\n\t\t\t\t\t\tvf_id);\nout:\n\treturn capable;\n}\n\nvoid i40e_client_update_msix_info(struct i40e_pf *pf)\n{\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\n\tif (!cdev || !cdev->client)\n\t\treturn;\n\n\tcdev->lan_info.msix_count = pf->num_iwarp_msix;\n\tcdev->lan_info.msix_entries = &pf->msix_entries[pf->iwarp_base_vector];\n}\n\nstatic void i40e_auxiliary_dev_release(struct device *dev)\n{\n\tstruct i40e_auxiliary_device *i40e_aux_dev =\n\t\t\tcontainer_of(dev, struct i40e_auxiliary_device, aux_dev.dev);\n\n\tida_free(&i40e_client_ida, i40e_aux_dev->aux_dev.id);\n\tkfree(i40e_aux_dev);\n}\n\nstatic int i40e_register_auxiliary_dev(struct i40e_info *ldev, const char *name)\n{\n\tstruct i40e_auxiliary_device *i40e_aux_dev;\n\tstruct pci_dev *pdev = ldev->pcidev;\n\tstruct auxiliary_device *aux_dev;\n\tint ret;\n\n\ti40e_aux_dev = kzalloc(sizeof(*i40e_aux_dev), GFP_KERNEL);\n\tif (!i40e_aux_dev)\n\t\treturn -ENOMEM;\n\n\ti40e_aux_dev->ldev = ldev;\n\n\taux_dev = &i40e_aux_dev->aux_dev;\n\taux_dev->name = name;\n\taux_dev->dev.parent = &pdev->dev;\n\taux_dev->dev.release = i40e_auxiliary_dev_release;\n\tldev->aux_dev = aux_dev;\n\n\tret = ida_alloc(&i40e_client_ida, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(i40e_aux_dev);\n\t\treturn ret;\n\t}\n\taux_dev->id = ret;\n\n\tret = auxiliary_device_init(aux_dev);\n\tif (ret < 0) {\n\t\tida_free(&i40e_client_ida, aux_dev->id);\n\t\tkfree(i40e_aux_dev);\n\t\treturn ret;\n\t}\n\n\tret = auxiliary_device_add(aux_dev);\n\tif (ret) {\n\t\tauxiliary_device_uninit(aux_dev);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void i40e_client_add_instance(struct i40e_pf *pf)\n{\n\tstruct i40e_client_instance *cdev = NULL;\n\tstruct netdev_hw_addr *mac = NULL;\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\n\tcdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn;\n\n\tcdev->lan_info.pf = (void *)pf;\n\tcdev->lan_info.netdev = vsi->netdev;\n\tcdev->lan_info.pcidev = pf->pdev;\n\tcdev->lan_info.fid = pf->hw.pf_id;\n\tcdev->lan_info.ftype = I40E_CLIENT_FTYPE_PF;\n\tcdev->lan_info.hw_addr = pf->hw.hw_addr;\n\tcdev->lan_info.ops = &i40e_lan_ops;\n\tcdev->lan_info.version.major = I40E_CLIENT_VERSION_MAJOR;\n\tcdev->lan_info.version.minor = I40E_CLIENT_VERSION_MINOR;\n\tcdev->lan_info.version.build = I40E_CLIENT_VERSION_BUILD;\n\tcdev->lan_info.fw_maj_ver = pf->hw.aq.fw_maj_ver;\n\tcdev->lan_info.fw_min_ver = pf->hw.aq.fw_min_ver;\n\tcdev->lan_info.fw_build = pf->hw.aq.fw_build;\n\tset_bit(__I40E_CLIENT_INSTANCE_NONE, &cdev->state);\n\n\tif (i40e_client_get_params(vsi, &cdev->lan_info.params))\n\t\tgoto free_cdev;\n\n\tmac = list_first_entry(&cdev->lan_info.netdev->dev_addrs.list,\n\t\t\t       struct netdev_hw_addr, list);\n\tif (mac)\n\t\tether_addr_copy(cdev->lan_info.lanmac, mac->addr);\n\telse\n\t\tdev_err(&pf->pdev->dev, \"MAC address list is empty!\\n\");\n\n\tpf->cinst = cdev;\n\n\tcdev->lan_info.msix_count = pf->num_iwarp_msix;\n\tcdev->lan_info.msix_entries = &pf->msix_entries[pf->iwarp_base_vector];\n\n\tif (i40e_register_auxiliary_dev(&cdev->lan_info, \"iwarp\"))\n\t\tgoto free_cdev;\n\n\treturn;\n\nfree_cdev:\n\tkfree(cdev);\n\tpf->cinst = NULL;\n}\n\n \nstatic\nvoid i40e_client_del_instance(struct i40e_pf *pf)\n{\n\tkfree(pf->cinst);\n\tpf->cinst = NULL;\n}\n\n \nvoid i40e_client_subtask(struct i40e_pf *pf)\n{\n\tstruct i40e_client *client;\n\tstruct i40e_client_instance *cdev;\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tint ret = 0;\n\n\tif (!test_and_clear_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state))\n\t\treturn;\n\tcdev = pf->cinst;\n\n\t \n\tif (test_bit(__I40E_DOWN, pf->state) ||\n\t    test_bit(__I40E_CONFIG_BUSY, pf->state))\n\t\treturn;\n\n\tif (!cdev || !cdev->client)\n\t\treturn;\n\n\tclient = cdev->client;\n\n\t \n\tif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\n\t\tif (vsi->netdev_registered &&\n\t\t    client->ops && client->ops->open) {\n\t\t\tset_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\n\t\t\tret = client->ops->open(&cdev->lan_info, client);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tclear_bit(__I40E_CLIENT_INSTANCE_OPENED,\n\t\t\t\t\t  &cdev->state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (test_bit(__I40E_VSI_DOWN, vsi->state))\n\t\ti40e_client_update_vsi_ctxt(&cdev->lan_info, client,\n\t\t\t\t\t    0, 0, 0,\n\t\t\t\t\t    I40E_CLIENT_VSI_FLAG_TCP_ENABLE);\n\telse\n\t\ti40e_client_update_vsi_ctxt(&cdev->lan_info, client,\n\t\t\t\t\t    0, 0,\n\t\t\t\t\t    I40E_CLIENT_VSI_FLAG_TCP_ENABLE,\n\t\t\t\t\t    I40E_CLIENT_VSI_FLAG_TCP_ENABLE);\n}\n\n \nint i40e_lan_add_device(struct i40e_pf *pf)\n{\n\tstruct i40e_device *ldev;\n\tint ret = 0;\n\n\tmutex_lock(&i40e_device_mutex);\n\tlist_for_each_entry(ldev, &i40e_devices, list) {\n\t\tif (ldev->pf == pf) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tldev = kzalloc(sizeof(*ldev), GFP_KERNEL);\n\tif (!ldev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tldev->pf = pf;\n\tINIT_LIST_HEAD(&ldev->list);\n\tlist_add(&ldev->list, &i40e_devices);\n\tdev_info(&pf->pdev->dev, \"Added LAN device PF%d bus=0x%02x dev=0x%02x func=0x%02x\\n\",\n\t\t pf->hw.pf_id, pf->hw.bus.bus_id,\n\t\t pf->hw.bus.device, pf->hw.bus.func);\n\n\ti40e_client_add_instance(pf);\n\n\tset_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);\n\ti40e_service_event_schedule(pf);\n\nout:\n\tmutex_unlock(&i40e_device_mutex);\n\treturn ret;\n}\n\n \nint i40e_lan_del_device(struct i40e_pf *pf)\n{\n\tstruct auxiliary_device *aux_dev = pf->cinst->lan_info.aux_dev;\n\tstruct i40e_device *ldev, *tmp;\n\tint ret = -ENODEV;\n\n\tauxiliary_device_delete(aux_dev);\n\tauxiliary_device_uninit(aux_dev);\n\n\t \n\ti40e_client_del_instance(pf);\n\n\tmutex_lock(&i40e_device_mutex);\n\tlist_for_each_entry_safe(ldev, tmp, &i40e_devices, list) {\n\t\tif (ldev->pf == pf) {\n\t\t\tdev_info(&pf->pdev->dev, \"Deleted LAN device PF%d bus=0x%02x dev=0x%02x func=0x%02x\\n\",\n\t\t\t\t pf->hw.pf_id, pf->hw.bus.bus_id,\n\t\t\t\t pf->hw.bus.device, pf->hw.bus.func);\n\t\t\tlist_del(&ldev->list);\n\t\t\tkfree(ldev);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&i40e_device_mutex);\n\treturn ret;\n}\n\n \nstatic int i40e_client_virtchnl_send(struct i40e_info *ldev,\n\t\t\t\t     struct i40e_client *client,\n\t\t\t\t     u32 vf_id, u8 *msg, u16 len)\n{\n\tstruct i40e_pf *pf = ldev->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint err;\n\n\terr = i40e_aq_send_msg_to_vf(hw, vf_id, VIRTCHNL_OP_RDMA,\n\t\t\t\t     0, msg, len, NULL);\n\tif (err)\n\t\tdev_err(&pf->pdev->dev, \"Unable to send iWarp message to VF, error %d, aq status %d\\n\",\n\t\t\terr, hw->aq.asq_last_status);\n\n\treturn err;\n}\n\n \nstatic int i40e_client_setup_qvlist(struct i40e_info *ldev,\n\t\t\t\t    struct i40e_client *client,\n\t\t\t\t    struct i40e_qvlist_info *qvlist_info)\n{\n\tstruct i40e_pf *pf = ldev->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_qv_info *qv_info;\n\tu32 v_idx, i, reg_idx, reg;\n\n\tldev->qvlist_info = kzalloc(struct_size(ldev->qvlist_info, qv_info,\n\t\t\t\t    qvlist_info->num_vectors), GFP_KERNEL);\n\tif (!ldev->qvlist_info)\n\t\treturn -ENOMEM;\n\tldev->qvlist_info->num_vectors = qvlist_info->num_vectors;\n\n\tfor (i = 0; i < qvlist_info->num_vectors; i++) {\n\t\tqv_info = &qvlist_info->qv_info[i];\n\t\tif (!qv_info)\n\t\t\tcontinue;\n\t\tv_idx = qv_info->v_idx;\n\n\t\t \n\t\tif ((v_idx >= (pf->iwarp_base_vector + pf->num_iwarp_msix)) ||\n\t\t    (v_idx < pf->iwarp_base_vector))\n\t\t\tgoto err;\n\n\t\tldev->qvlist_info->qv_info[i] = *qv_info;\n\t\treg_idx = I40E_PFINT_LNKLSTN(v_idx - 1);\n\n\t\tif (qv_info->ceq_idx == I40E_QUEUE_INVALID_IDX) {\n\t\t\t \n\t\t\twr32(hw, reg_idx, I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK);\n\t\t} else {\n\t\t\treg = (qv_info->ceq_idx &\n\t\t\t       I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK) |\n\t\t\t       (I40E_QUEUE_TYPE_PE_CEQ <<\n\t\t\t       I40E_PFINT_LNKLSTN_FIRSTQ_TYPE_SHIFT);\n\t\t\twr32(hw, reg_idx, reg);\n\n\t\t\treg = (I40E_PFINT_CEQCTL_CAUSE_ENA_MASK |\n\t\t\t       (v_idx << I40E_PFINT_CEQCTL_MSIX_INDX_SHIFT) |\n\t\t\t       (qv_info->itr_idx <<\n\t\t\t\tI40E_PFINT_CEQCTL_ITR_INDX_SHIFT) |\n\t\t\t       (I40E_QUEUE_END_OF_LIST <<\n\t\t\t\tI40E_PFINT_CEQCTL_NEXTQ_INDX_SHIFT));\n\t\t\twr32(hw, I40E_PFINT_CEQCTL(qv_info->ceq_idx), reg);\n\t\t}\n\t\tif (qv_info->aeq_idx != I40E_QUEUE_INVALID_IDX) {\n\t\t\treg = (I40E_PFINT_AEQCTL_CAUSE_ENA_MASK |\n\t\t\t       (v_idx << I40E_PFINT_AEQCTL_MSIX_INDX_SHIFT) |\n\t\t\t       (qv_info->itr_idx <<\n\t\t\t\tI40E_PFINT_AEQCTL_ITR_INDX_SHIFT));\n\n\t\t\twr32(hw, I40E_PFINT_AEQCTL, reg);\n\t\t}\n\t}\n\t \n\ti40e_flush(hw);\n\treturn 0;\nerr:\n\tkfree(ldev->qvlist_info);\n\tldev->qvlist_info = NULL;\n\treturn -EINVAL;\n}\n\n \nstatic void i40e_client_request_reset(struct i40e_info *ldev,\n\t\t\t\t      struct i40e_client *client,\n\t\t\t\t      u32 reset_level)\n{\n\tstruct i40e_pf *pf = ldev->pf;\n\n\tswitch (reset_level) {\n\tcase I40E_CLIENT_RESET_LEVEL_PF:\n\t\tset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\n\t\tbreak;\n\tcase I40E_CLIENT_RESET_LEVEL_CORE:\n\t\tset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Client for PF id %d requested an unsupported reset: %d.\\n\",\n\t\t\t pf->hw.pf_id, reset_level);\n\t\tbreak;\n\t}\n\n\ti40e_service_event_schedule(pf);\n}\n\n \nstatic int i40e_client_update_vsi_ctxt(struct i40e_info *ldev,\n\t\t\t\t       struct i40e_client *client,\n\t\t\t\t       bool is_vf, u32 vf_id,\n\t\t\t\t       u32 flag, u32 valid_flag)\n{\n\tstruct i40e_pf *pf = ldev->pf;\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tstruct i40e_vsi_context ctxt;\n\tbool update = true;\n\tint err;\n\n\t \n\tif (is_vf)\n\t\treturn -EINVAL;\n\n\tctxt.seid = pf->main_vsi_seid;\n\tctxt.pf_num = pf->hw.pf_id;\n\terr = i40e_aq_get_vsi_params(&pf->hw, &ctxt, NULL);\n\tctxt.flags = I40E_AQ_VSI_TYPE_PF;\n\tif (err) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get PF vsi config, err %pe aq_err %s\\n\",\n\t\t\t ERR_PTR(err),\n\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\treturn -ENOENT;\n\t}\n\n\tif ((valid_flag & I40E_CLIENT_VSI_FLAG_TCP_ENABLE) &&\n\t    (flag & I40E_CLIENT_VSI_FLAG_TCP_ENABLE)) {\n\t\tctxt.info.valid_sections =\n\t\t\tcpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\n\t\tctxt.info.queueing_opt_flags |= I40E_AQ_VSI_QUE_OPT_TCP_ENA;\n\t} else if ((valid_flag & I40E_CLIENT_VSI_FLAG_TCP_ENABLE) &&\n\t\t  !(flag & I40E_CLIENT_VSI_FLAG_TCP_ENABLE)) {\n\t\tctxt.info.valid_sections =\n\t\t\tcpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\n\t\tctxt.info.queueing_opt_flags &= ~I40E_AQ_VSI_QUE_OPT_TCP_ENA;\n\t} else {\n\t\tupdate = false;\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Client for PF id %d request an unsupported Config: %x.\\n\",\n\t\t\t pf->hw.pf_id, flag);\n\t}\n\n\tif (update) {\n\t\terr = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\n\t\tif (err) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"update VSI ctxt for PE failed, err %pe aq_err %s\\n\",\n\t\t\t\t ERR_PTR(err),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t}\n\t}\n\treturn err;\n}\n\nvoid i40e_client_device_register(struct i40e_info *ldev, struct i40e_client *client)\n{\n\tstruct i40e_pf *pf = ldev->pf;\n\n\tpf->cinst->client = client;\n\tset_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);\n\ti40e_service_event_schedule(pf);\n}\nEXPORT_SYMBOL_GPL(i40e_client_device_register);\n\nvoid i40e_client_device_unregister(struct i40e_info *ldev)\n{\n\tstruct i40e_pf *pf = ldev->pf;\n\tstruct i40e_client_instance *cdev = pf->cinst;\n\n\tif (!cdev)\n\t\treturn;\n\n\twhile (test_and_set_bit(__I40E_SERVICE_SCHED, pf->state))\n\t\tusleep_range(500, 1000);\n\n\tif (test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\n\t\tcdev->client->ops->close(&cdev->lan_info, cdev->client, false);\n\t\tclear_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\n\t\ti40e_client_release_qvlist(&cdev->lan_info);\n\t}\n\n\tpf->cinst->client = NULL;\n\tclear_bit(__I40E_SERVICE_SCHED, pf->state);\n}\nEXPORT_SYMBOL_GPL(i40e_client_device_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}