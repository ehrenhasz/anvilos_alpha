{
  "module_name": "i40e_ethtool.c",
  "hash_id": "27bca39979346d5676957bd9470e67a746fa17ff9fdb9dfbf3d2dbc7a3ed16a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include \"i40e.h\"\n#include \"i40e_diag.h\"\n#include \"i40e_txrx_common.h\"\n\n \n\n \nstruct i40e_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n \n#define I40E_STAT(_type, _name, _stat) { \\\n\t.stat_string = _name, \\\n\t.sizeof_stat = sizeof_field(_type, _stat), \\\n\t.stat_offset = offsetof(_type, _stat) \\\n}\n\n \n#define I40E_NETDEV_STAT(_net_stat) \\\n\tI40E_STAT(struct rtnl_link_stats64, #_net_stat, _net_stat)\n\n \n#define I40E_QUEUE_STAT(_name, _stat) \\\n\tI40E_STAT(struct i40e_ring, _name, _stat)\n\n \nstatic const struct i40e_stats i40e_gstrings_queue_stats[] = {\n\tI40E_QUEUE_STAT(\"%s-%u.packets\", stats.packets),\n\tI40E_QUEUE_STAT(\"%s-%u.bytes\", stats.bytes),\n};\n\n \nstatic void\ni40e_add_one_ethtool_stat(u64 *data, void *pointer,\n\t\t\t  const struct i40e_stats *stat)\n{\n\tchar *p;\n\n\tif (!pointer) {\n\t\t \n\t\t*data = 0;\n\t\treturn;\n\t}\n\n\tp = (char *)pointer + stat->stat_offset;\n\tswitch (stat->sizeof_stat) {\n\tcase sizeof(u64):\n\t\t*data = *((u64 *)p);\n\t\tbreak;\n\tcase sizeof(u32):\n\t\t*data = *((u32 *)p);\n\t\tbreak;\n\tcase sizeof(u16):\n\t\t*data = *((u16 *)p);\n\t\tbreak;\n\tcase sizeof(u8):\n\t\t*data = *((u8 *)p);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"unexpected stat size for %s\",\n\t\t\t  stat->stat_string);\n\t\t*data = 0;\n\t}\n}\n\n \nstatic void\n__i40e_add_ethtool_stats(u64 **data, void *pointer,\n\t\t\t const struct i40e_stats stats[],\n\t\t\t const unsigned int size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++)\n\t\ti40e_add_one_ethtool_stat((*data)++, pointer, &stats[i]);\n}\n\n \n#define i40e_add_ethtool_stats(data, pointer, stats) \\\n\t__i40e_add_ethtool_stats(data, pointer, stats, ARRAY_SIZE(stats))\n\n \nstatic void\ni40e_add_queue_stats(u64 **data, struct i40e_ring *ring)\n{\n\tconst unsigned int size = ARRAY_SIZE(i40e_gstrings_queue_stats);\n\tconst struct i40e_stats *stats = i40e_gstrings_queue_stats;\n\tunsigned int start;\n\tunsigned int i;\n\n\t \n\tdo {\n\t\tstart = !ring ? 0 : u64_stats_fetch_begin(&ring->syncp);\n\t\tfor (i = 0; i < size; i++) {\n\t\t\ti40e_add_one_ethtool_stat(&(*data)[i], ring,\n\t\t\t\t\t\t  &stats[i]);\n\t\t}\n\t} while (ring && u64_stats_fetch_retry(&ring->syncp, start));\n\n\t \n\t*data += size;\n}\n\n \nstatic void __i40e_add_stat_strings(u8 **p, const struct i40e_stats stats[],\n\t\t\t\t    const unsigned int size, ...)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tva_list args;\n\n\t\tva_start(args, size);\n\t\tvsnprintf(*p, ETH_GSTRING_LEN, stats[i].stat_string, args);\n\t\t*p += ETH_GSTRING_LEN;\n\t\tva_end(args);\n\t}\n}\n\n \n#define i40e_add_stat_strings(p, stats, ...) \\\n\t__i40e_add_stat_strings(p, stats, ARRAY_SIZE(stats), ## __VA_ARGS__)\n\n#define I40E_PF_STAT(_name, _stat) \\\n\tI40E_STAT(struct i40e_pf, _name, _stat)\n#define I40E_VSI_STAT(_name, _stat) \\\n\tI40E_STAT(struct i40e_vsi, _name, _stat)\n#define I40E_VEB_STAT(_name, _stat) \\\n\tI40E_STAT(struct i40e_veb, _name, _stat)\n#define I40E_VEB_TC_STAT(_name, _stat) \\\n\tI40E_STAT(struct i40e_cp_veb_tc_stats, _name, _stat)\n#define I40E_PFC_STAT(_name, _stat) \\\n\tI40E_STAT(struct i40e_pfc_stats, _name, _stat)\n\nstatic const struct i40e_stats i40e_gstrings_net_stats[] = {\n\tI40E_NETDEV_STAT(rx_packets),\n\tI40E_NETDEV_STAT(tx_packets),\n\tI40E_NETDEV_STAT(rx_bytes),\n\tI40E_NETDEV_STAT(tx_bytes),\n\tI40E_NETDEV_STAT(rx_errors),\n\tI40E_NETDEV_STAT(tx_errors),\n\tI40E_NETDEV_STAT(rx_dropped),\n\tI40E_NETDEV_STAT(tx_dropped),\n\tI40E_NETDEV_STAT(collisions),\n\tI40E_NETDEV_STAT(rx_length_errors),\n\tI40E_NETDEV_STAT(rx_crc_errors),\n};\n\nstatic const struct i40e_stats i40e_gstrings_veb_stats[] = {\n\tI40E_VEB_STAT(\"veb.rx_bytes\", stats.rx_bytes),\n\tI40E_VEB_STAT(\"veb.tx_bytes\", stats.tx_bytes),\n\tI40E_VEB_STAT(\"veb.rx_unicast\", stats.rx_unicast),\n\tI40E_VEB_STAT(\"veb.tx_unicast\", stats.tx_unicast),\n\tI40E_VEB_STAT(\"veb.rx_multicast\", stats.rx_multicast),\n\tI40E_VEB_STAT(\"veb.tx_multicast\", stats.tx_multicast),\n\tI40E_VEB_STAT(\"veb.rx_broadcast\", stats.rx_broadcast),\n\tI40E_VEB_STAT(\"veb.tx_broadcast\", stats.tx_broadcast),\n\tI40E_VEB_STAT(\"veb.rx_discards\", stats.rx_discards),\n\tI40E_VEB_STAT(\"veb.tx_discards\", stats.tx_discards),\n\tI40E_VEB_STAT(\"veb.tx_errors\", stats.tx_errors),\n\tI40E_VEB_STAT(\"veb.rx_unknown_protocol\", stats.rx_unknown_protocol),\n};\n\nstruct i40e_cp_veb_tc_stats {\n\tu64 tc_rx_packets;\n\tu64 tc_rx_bytes;\n\tu64 tc_tx_packets;\n\tu64 tc_tx_bytes;\n};\n\nstatic const struct i40e_stats i40e_gstrings_veb_tc_stats[] = {\n\tI40E_VEB_TC_STAT(\"veb.tc_%u_tx_packets\", tc_tx_packets),\n\tI40E_VEB_TC_STAT(\"veb.tc_%u_tx_bytes\", tc_tx_bytes),\n\tI40E_VEB_TC_STAT(\"veb.tc_%u_rx_packets\", tc_rx_packets),\n\tI40E_VEB_TC_STAT(\"veb.tc_%u_rx_bytes\", tc_rx_bytes),\n};\n\nstatic const struct i40e_stats i40e_gstrings_misc_stats[] = {\n\tI40E_VSI_STAT(\"rx_unicast\", eth_stats.rx_unicast),\n\tI40E_VSI_STAT(\"tx_unicast\", eth_stats.tx_unicast),\n\tI40E_VSI_STAT(\"rx_multicast\", eth_stats.rx_multicast),\n\tI40E_VSI_STAT(\"tx_multicast\", eth_stats.tx_multicast),\n\tI40E_VSI_STAT(\"rx_broadcast\", eth_stats.rx_broadcast),\n\tI40E_VSI_STAT(\"tx_broadcast\", eth_stats.tx_broadcast),\n\tI40E_VSI_STAT(\"rx_unknown_protocol\", eth_stats.rx_unknown_protocol),\n\tI40E_VSI_STAT(\"tx_linearize\", tx_linearize),\n\tI40E_VSI_STAT(\"tx_force_wb\", tx_force_wb),\n\tI40E_VSI_STAT(\"tx_busy\", tx_busy),\n\tI40E_VSI_STAT(\"tx_stopped\", tx_stopped),\n\tI40E_VSI_STAT(\"rx_alloc_fail\", rx_buf_failed),\n\tI40E_VSI_STAT(\"rx_pg_alloc_fail\", rx_page_failed),\n\tI40E_VSI_STAT(\"rx_cache_reuse\", rx_page_reuse),\n\tI40E_VSI_STAT(\"rx_cache_alloc\", rx_page_alloc),\n\tI40E_VSI_STAT(\"rx_cache_waive\", rx_page_waive),\n\tI40E_VSI_STAT(\"rx_cache_busy\", rx_page_busy),\n\tI40E_VSI_STAT(\"tx_restart\", tx_restart),\n};\n\n \nstatic const struct i40e_stats i40e_gstrings_stats[] = {\n\tI40E_PF_STAT(\"port.rx_bytes\", stats.eth.rx_bytes),\n\tI40E_PF_STAT(\"port.tx_bytes\", stats.eth.tx_bytes),\n\tI40E_PF_STAT(\"port.rx_unicast\", stats.eth.rx_unicast),\n\tI40E_PF_STAT(\"port.tx_unicast\", stats.eth.tx_unicast),\n\tI40E_PF_STAT(\"port.rx_multicast\", stats.eth.rx_multicast),\n\tI40E_PF_STAT(\"port.tx_multicast\", stats.eth.tx_multicast),\n\tI40E_PF_STAT(\"port.rx_broadcast\", stats.eth.rx_broadcast),\n\tI40E_PF_STAT(\"port.tx_broadcast\", stats.eth.tx_broadcast),\n\tI40E_PF_STAT(\"port.tx_errors\", stats.eth.tx_errors),\n\tI40E_PF_STAT(\"port.rx_dropped\", stats.eth.rx_discards),\n\tI40E_PF_STAT(\"port.tx_dropped_link_down\", stats.tx_dropped_link_down),\n\tI40E_PF_STAT(\"port.rx_crc_errors\", stats.crc_errors),\n\tI40E_PF_STAT(\"port.illegal_bytes\", stats.illegal_bytes),\n\tI40E_PF_STAT(\"port.mac_local_faults\", stats.mac_local_faults),\n\tI40E_PF_STAT(\"port.mac_remote_faults\", stats.mac_remote_faults),\n\tI40E_PF_STAT(\"port.tx_timeout\", tx_timeout_count),\n\tI40E_PF_STAT(\"port.rx_csum_bad\", hw_csum_rx_error),\n\tI40E_PF_STAT(\"port.rx_length_errors\", stats.rx_length_errors),\n\tI40E_PF_STAT(\"port.link_xon_rx\", stats.link_xon_rx),\n\tI40E_PF_STAT(\"port.link_xoff_rx\", stats.link_xoff_rx),\n\tI40E_PF_STAT(\"port.link_xon_tx\", stats.link_xon_tx),\n\tI40E_PF_STAT(\"port.link_xoff_tx\", stats.link_xoff_tx),\n\tI40E_PF_STAT(\"port.rx_size_64\", stats.rx_size_64),\n\tI40E_PF_STAT(\"port.rx_size_127\", stats.rx_size_127),\n\tI40E_PF_STAT(\"port.rx_size_255\", stats.rx_size_255),\n\tI40E_PF_STAT(\"port.rx_size_511\", stats.rx_size_511),\n\tI40E_PF_STAT(\"port.rx_size_1023\", stats.rx_size_1023),\n\tI40E_PF_STAT(\"port.rx_size_1522\", stats.rx_size_1522),\n\tI40E_PF_STAT(\"port.rx_size_big\", stats.rx_size_big),\n\tI40E_PF_STAT(\"port.tx_size_64\", stats.tx_size_64),\n\tI40E_PF_STAT(\"port.tx_size_127\", stats.tx_size_127),\n\tI40E_PF_STAT(\"port.tx_size_255\", stats.tx_size_255),\n\tI40E_PF_STAT(\"port.tx_size_511\", stats.tx_size_511),\n\tI40E_PF_STAT(\"port.tx_size_1023\", stats.tx_size_1023),\n\tI40E_PF_STAT(\"port.tx_size_1522\", stats.tx_size_1522),\n\tI40E_PF_STAT(\"port.tx_size_big\", stats.tx_size_big),\n\tI40E_PF_STAT(\"port.rx_undersize\", stats.rx_undersize),\n\tI40E_PF_STAT(\"port.rx_fragments\", stats.rx_fragments),\n\tI40E_PF_STAT(\"port.rx_oversize\", stats.rx_oversize),\n\tI40E_PF_STAT(\"port.rx_jabber\", stats.rx_jabber),\n\tI40E_PF_STAT(\"port.VF_admin_queue_requests\", vf_aq_requests),\n\tI40E_PF_STAT(\"port.arq_overflows\", arq_overflows),\n\tI40E_PF_STAT(\"port.tx_hwtstamp_timeouts\", tx_hwtstamp_timeouts),\n\tI40E_PF_STAT(\"port.rx_hwtstamp_cleared\", rx_hwtstamp_cleared),\n\tI40E_PF_STAT(\"port.tx_hwtstamp_skipped\", tx_hwtstamp_skipped),\n\tI40E_PF_STAT(\"port.fdir_flush_cnt\", fd_flush_cnt),\n\tI40E_PF_STAT(\"port.fdir_atr_match\", stats.fd_atr_match),\n\tI40E_PF_STAT(\"port.fdir_atr_tunnel_match\", stats.fd_atr_tunnel_match),\n\tI40E_PF_STAT(\"port.fdir_atr_status\", stats.fd_atr_status),\n\tI40E_PF_STAT(\"port.fdir_sb_match\", stats.fd_sb_match),\n\tI40E_PF_STAT(\"port.fdir_sb_status\", stats.fd_sb_status),\n\n\t \n\tI40E_PF_STAT(\"port.tx_lpi_status\", stats.tx_lpi_status),\n\tI40E_PF_STAT(\"port.rx_lpi_status\", stats.rx_lpi_status),\n\tI40E_PF_STAT(\"port.tx_lpi_count\", stats.tx_lpi_count),\n\tI40E_PF_STAT(\"port.rx_lpi_count\", stats.rx_lpi_count),\n};\n\nstruct i40e_pfc_stats {\n\tu64 priority_xon_rx;\n\tu64 priority_xoff_rx;\n\tu64 priority_xon_tx;\n\tu64 priority_xoff_tx;\n\tu64 priority_xon_2_xoff;\n};\n\nstatic const struct i40e_stats i40e_gstrings_pfc_stats[] = {\n\tI40E_PFC_STAT(\"port.tx_priority_%u_xon_tx\", priority_xon_tx),\n\tI40E_PFC_STAT(\"port.tx_priority_%u_xoff_tx\", priority_xoff_tx),\n\tI40E_PFC_STAT(\"port.rx_priority_%u_xon_rx\", priority_xon_rx),\n\tI40E_PFC_STAT(\"port.rx_priority_%u_xoff_rx\", priority_xoff_rx),\n\tI40E_PFC_STAT(\"port.rx_priority_%u_xon_2_xoff\", priority_xon_2_xoff),\n};\n\n#define I40E_NETDEV_STATS_LEN\tARRAY_SIZE(i40e_gstrings_net_stats)\n\n#define I40E_MISC_STATS_LEN\tARRAY_SIZE(i40e_gstrings_misc_stats)\n\n#define I40E_VSI_STATS_LEN\t(I40E_NETDEV_STATS_LEN + I40E_MISC_STATS_LEN)\n\n#define I40E_PFC_STATS_LEN\t(ARRAY_SIZE(i40e_gstrings_pfc_stats) * \\\n\t\t\t\t I40E_MAX_USER_PRIORITY)\n\n#define I40E_VEB_STATS_LEN\t(ARRAY_SIZE(i40e_gstrings_veb_stats) + \\\n\t\t\t\t (ARRAY_SIZE(i40e_gstrings_veb_tc_stats) * \\\n\t\t\t\t  I40E_MAX_TRAFFIC_CLASS))\n\n#define I40E_GLOBAL_STATS_LEN\tARRAY_SIZE(i40e_gstrings_stats)\n\n#define I40E_PF_STATS_LEN\t(I40E_GLOBAL_STATS_LEN + \\\n\t\t\t\t I40E_PFC_STATS_LEN + \\\n\t\t\t\t I40E_VEB_STATS_LEN + \\\n\t\t\t\t I40E_VSI_STATS_LEN)\n\n \n#define I40E_QUEUE_STATS_LEN\tARRAY_SIZE(i40e_gstrings_queue_stats)\n\nenum i40e_ethtool_test_id {\n\tI40E_ETH_TEST_REG = 0,\n\tI40E_ETH_TEST_EEPROM,\n\tI40E_ETH_TEST_INTR,\n\tI40E_ETH_TEST_LINK,\n};\n\nstatic const char i40e_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register test  (offline)\",\n\t\"Eeprom test    (offline)\",\n\t\"Interrupt test (offline)\",\n\t\"Link test   (on/offline)\"\n};\n\n#define I40E_TEST_LEN (sizeof(i40e_gstrings_test) / ETH_GSTRING_LEN)\n\nstruct i40e_priv_flags {\n\tchar flag_string[ETH_GSTRING_LEN];\n\tu64 flag;\n\tbool read_only;\n};\n\n#define I40E_PRIV_FLAG(_name, _flag, _read_only) { \\\n\t.flag_string = _name, \\\n\t.flag = _flag, \\\n\t.read_only = _read_only, \\\n}\n\nstatic const struct i40e_priv_flags i40e_gstrings_priv_flags[] = {\n\t \n\tI40E_PRIV_FLAG(\"MFP\", I40E_FLAG_MFP_ENABLED, 1),\n\tI40E_PRIV_FLAG(\"total-port-shutdown\",\n\t\t       I40E_FLAG_TOTAL_PORT_SHUTDOWN_ENABLED, 1),\n\tI40E_PRIV_FLAG(\"LinkPolling\", I40E_FLAG_LINK_POLLING_ENABLED, 0),\n\tI40E_PRIV_FLAG(\"flow-director-atr\", I40E_FLAG_FD_ATR_ENABLED, 0),\n\tI40E_PRIV_FLAG(\"veb-stats\", I40E_FLAG_VEB_STATS_ENABLED, 0),\n\tI40E_PRIV_FLAG(\"hw-atr-eviction\", I40E_FLAG_HW_ATR_EVICT_ENABLED, 0),\n\tI40E_PRIV_FLAG(\"link-down-on-close\",\n\t\t       I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED, 0),\n\tI40E_PRIV_FLAG(\"legacy-rx\", I40E_FLAG_LEGACY_RX, 0),\n\tI40E_PRIV_FLAG(\"disable-source-pruning\",\n\t\t       I40E_FLAG_SOURCE_PRUNING_DISABLED, 0),\n\tI40E_PRIV_FLAG(\"disable-fw-lldp\", I40E_FLAG_DISABLE_FW_LLDP, 0),\n\tI40E_PRIV_FLAG(\"rs-fec\", I40E_FLAG_RS_FEC, 0),\n\tI40E_PRIV_FLAG(\"base-r-fec\", I40E_FLAG_BASE_R_FEC, 0),\n\tI40E_PRIV_FLAG(\"vf-vlan-pruning\",\n\t\t       I40E_FLAG_VF_VLAN_PRUNING, 0),\n};\n\n#define I40E_PRIV_FLAGS_STR_LEN ARRAY_SIZE(i40e_gstrings_priv_flags)\n\n \nstatic const struct i40e_priv_flags i40e_gl_gstrings_priv_flags[] = {\n\tI40E_PRIV_FLAG(\"vf-true-promisc-support\",\n\t\t       I40E_FLAG_TRUE_PROMISC_SUPPORT, 0),\n};\n\n#define I40E_GL_PRIV_FLAGS_STR_LEN ARRAY_SIZE(i40e_gl_gstrings_priv_flags)\n\n \nstatic void i40e_partition_setting_complaint(struct i40e_pf *pf)\n{\n\tdev_info(&pf->pdev->dev,\n\t\t \"The link settings are allowed to be changed only from the first partition of a given port. Please switch to the first partition in order to change the setting.\\n\");\n}\n\n \nstatic void i40e_phy_type_to_ethtool(struct i40e_pf *pf,\n\t\t\t\t     struct ethtool_link_ksettings *ks)\n{\n\tstruct i40e_link_status *hw_link_info = &pf->hw.phy.link_info;\n\tu64 phy_types = pf->hw.phy.phy_types;\n\n\tethtool_link_ksettings_zero_link_mode(ks, supported);\n\tethtool_link_ksettings_zero_link_mode(ks, advertising);\n\n\tif (phy_types & I40E_CAP_PHY_TYPE_SGMII) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\tif (pf->hw_features & I40E_HW_100M_SGMII_CAPABLE) {\n\t\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t\t}\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_XAUI ||\n\t    phy_types & I40E_CAP_PHY_TYPE_XFI ||\n\t    phy_types & I40E_CAP_PHY_TYPE_SFI ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_SFPP_CU ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_AOC) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_10GBASE_T) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_2_5GBASE_T) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     2500baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_2_5GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     2500baseT_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_5GBASE_T) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     5000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_5GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     5000baseT_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_XLAUI ||\n\t    phy_types & I40E_CAP_PHY_TYPE_XLPPI ||\n\t    phy_types & I40E_CAP_PHY_TYPE_40GBASE_AOC)\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseCR4_Full);\n\tif (phy_types & I40E_CAP_PHY_TYPE_40GBASE_CR4_CU ||\n\t    phy_types & I40E_CAP_PHY_TYPE_40GBASE_CR4) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseCR4_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_40GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     40000baseCR4_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_100BASE_TX) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     100baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_100MB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_1000BASE_T) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_40GBASE_SR4) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseSR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseSR4_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_40GBASE_LR4) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseLR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseLR4_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_40GBASE_KR4) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseKR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseKR4_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_20GBASE_KR2) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     20000baseKR2_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_20GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     20000baseKR2_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_10GBASE_KX4) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseKX4_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseKX4_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_10GBASE_KR &&\n\t    !(pf->hw_features & I40E_HW_HAVE_CRT_RETIMER)) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseKR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseKR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_1000BASE_KX &&\n\t    !(pf->hw_features & I40E_HW_HAVE_CRT_RETIMER)) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseKX_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     1000baseKX_Full);\n\t}\n\t \n\tif (phy_types & I40E_CAP_PHY_TYPE_25GBASE_KR) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseKR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_25GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     25000baseKR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_25GBASE_CR) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseCR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_25GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     25000baseCR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_25GBASE_SR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_LR) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseSR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_25GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     25000baseSR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_25GBASE_AOC ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_ACC) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseCR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_25GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     25000baseCR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_25GBASE_KR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_CR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_SR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_LR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_AOC ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_ACC) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_NONE);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_RS);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_BASER);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_25GB) {\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     FEC_NONE);\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     FEC_RS);\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     FEC_BASER);\n\t\t}\n\t}\n\t \n\tif (phy_types & I40E_CAP_PHY_TYPE_10GBASE_CR1 ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_CR1_CU) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseCR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseCR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_10GBASE_SR) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseSR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseSR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_10GBASE_LR) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseLR_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseLR_Full);\n\t}\n\tif (phy_types & I40E_CAP_PHY_TYPE_1000BASE_SX ||\n\t    phy_types & I40E_CAP_PHY_TYPE_1000BASE_LX ||\n\t    phy_types & I40E_CAP_PHY_TYPE_1000BASE_T_OPTICAL) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseX_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     1000baseX_Full);\n\t}\n\t \n\tif (phy_types & I40E_CAP_PHY_TYPE_SGMII ||\n\t    phy_types & I40E_CAP_PHY_TYPE_40GBASE_KR4 ||\n\t    phy_types & I40E_CAP_PHY_TYPE_40GBASE_CR4_CU ||\n\t    phy_types & I40E_CAP_PHY_TYPE_40GBASE_CR4 ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_SR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_LR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_KR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_25GBASE_CR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_20GBASE_KR2 ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_SR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_LR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_KX4 ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_KR ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_CR1_CU ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_CR1 ||\n\t    phy_types & I40E_CAP_PHY_TYPE_10GBASE_T ||\n\t    phy_types & I40E_CAP_PHY_TYPE_5GBASE_T ||\n\t    phy_types & I40E_CAP_PHY_TYPE_2_5GBASE_T ||\n\t    phy_types & I40E_CAP_PHY_TYPE_1000BASE_T_OPTICAL ||\n\t    phy_types & I40E_CAP_PHY_TYPE_1000BASE_T ||\n\t    phy_types & I40E_CAP_PHY_TYPE_1000BASE_SX ||\n\t    phy_types & I40E_CAP_PHY_TYPE_1000BASE_LX ||\n\t    phy_types & I40E_CAP_PHY_TYPE_1000BASE_KX ||\n\t    phy_types & I40E_CAP_PHY_TYPE_100BASE_TX) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Autoneg);\n\t}\n}\n\n \nstatic void i40e_get_settings_link_up_fec(u8 req_fec_info,\n\t\t\t\t\t  struct ethtool_link_ksettings *ks)\n{\n\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_NONE);\n\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_RS);\n\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_BASER);\n\n\tif ((I40E_AQ_SET_FEC_REQUEST_RS & req_fec_info) &&\n\t    (I40E_AQ_SET_FEC_REQUEST_KR & req_fec_info)) {\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     FEC_NONE);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     FEC_BASER);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FEC_RS);\n\t} else if (I40E_AQ_SET_FEC_REQUEST_RS & req_fec_info) {\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FEC_RS);\n\t} else if (I40E_AQ_SET_FEC_REQUEST_KR & req_fec_info) {\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     FEC_BASER);\n\t} else {\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     FEC_NONE);\n\t}\n}\n\n \nstatic void i40e_get_settings_link_up(struct i40e_hw *hw,\n\t\t\t\t      struct ethtool_link_ksettings *ks,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      struct i40e_pf *pf)\n{\n\tstruct i40e_link_status *hw_link_info = &hw->phy.link_info;\n\tstruct ethtool_link_ksettings cap_ksettings;\n\tu32 link_speed = hw_link_info->link_speed;\n\n\t \n\tswitch (hw_link_info->phy_type) {\n\tcase I40E_PHY_TYPE_40GBASE_CR4:\n\tcase I40E_PHY_TYPE_40GBASE_CR4_CU:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseCR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseCR4_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_XLAUI:\n\tcase I40E_PHY_TYPE_XLPPI:\n\tcase I40E_PHY_TYPE_40GBASE_AOC:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseCR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseCR4_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_40GBASE_SR4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseSR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseSR4_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_40GBASE_LR4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseLR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseLR4_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_25GBASE_SR:\n\tcase I40E_PHY_TYPE_25GBASE_LR:\n\tcase I40E_PHY_TYPE_10GBASE_SR:\n\tcase I40E_PHY_TYPE_10GBASE_LR:\n\tcase I40E_PHY_TYPE_1000BASE_SX:\n\tcase I40E_PHY_TYPE_1000BASE_LX:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseSR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     25000baseSR_Full);\n\t\ti40e_get_settings_link_up_fec(hw_link_info->req_fec_info, ks);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseSR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     10000baseSR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseLR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     10000baseLR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseX_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     1000baseX_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tif (hw_link_info->module_type[2] &\n\t\t    I40E_MODULE_TYPE_1000BASE_SX ||\n\t\t    hw_link_info->module_type[2] &\n\t\t    I40E_MODULE_TYPE_1000BASE_LX) {\n\t\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\t\tif (hw_link_info->requested_speeds &\n\t\t\t    I40E_LINK_SPEED_1GB)\n\t\t\t\tethtool_link_ksettings_add_link_mode(\n\t\t\t\t     ks, advertising, 1000baseT_Full);\n\t\t}\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_10GBASE_T:\n\tcase I40E_PHY_TYPE_5GBASE_T_LINK_STATUS:\n\tcase I40E_PHY_TYPE_2_5GBASE_T_LINK_STATUS:\n\tcase I40E_PHY_TYPE_1000BASE_T:\n\tcase I40E_PHY_TYPE_100BASE_TX:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     5000baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     2500baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     100baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_5GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     5000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_2_5GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     2500baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_100MB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_1000BASE_T_OPTICAL:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_10GBASE_CR1_CU:\n\tcase I40E_PHY_TYPE_10GBASE_CR1:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_XAUI:\n\tcase I40E_PHY_TYPE_XFI:\n\tcase I40E_PHY_TYPE_SFI:\n\tcase I40E_PHY_TYPE_10GBASE_SFPP_CU:\n\tcase I40E_PHY_TYPE_10GBASE_AOC:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t\ti40e_get_settings_link_up_fec(hw_link_info->req_fec_info, ks);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_SGMII:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tif (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\tif (pf->hw_features & I40E_HW_100M_SGMII_CAPABLE) {\n\t\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t\t\tif (hw_link_info->requested_speeds &\n\t\t\t    I40E_LINK_SPEED_100MB)\n\t\t\t\tethtool_link_ksettings_add_link_mode(\n\t\t\t\t      ks, advertising, 100baseT_Full);\n\t\t}\n\t\tbreak;\n\tcase I40E_PHY_TYPE_40GBASE_KR4:\n\tcase I40E_PHY_TYPE_25GBASE_KR:\n\tcase I40E_PHY_TYPE_20GBASE_KR2:\n\tcase I40E_PHY_TYPE_10GBASE_KR:\n\tcase I40E_PHY_TYPE_10GBASE_KX4:\n\tcase I40E_PHY_TYPE_1000BASE_KX:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseKR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseKR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     20000baseKR2_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseKR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseKX4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseKX_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     40000baseKR4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     25000baseKR_Full);\n\t\ti40e_get_settings_link_up_fec(hw_link_info->req_fec_info, ks);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     20000baseKR2_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     10000baseKR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     10000baseKX4_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     1000baseKX_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tbreak;\n\tcase I40E_PHY_TYPE_25GBASE_CR:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseCR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     25000baseCR_Full);\n\t\ti40e_get_settings_link_up_fec(hw_link_info->req_fec_info, ks);\n\n\t\tbreak;\n\tcase I40E_PHY_TYPE_25GBASE_AOC:\n\tcase I40E_PHY_TYPE_25GBASE_ACC:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseCR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     25000baseCR_Full);\n\t\ti40e_get_settings_link_up_fec(hw_link_info->req_fec_info, ks);\n\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseCR_Full);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     10000baseCR_Full);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnetdev_info(netdev,\n\t\t\t    \"WARNING: Link is up but PHY type 0x%x is not recognized, or incorrect cable is in use\\n\",\n\t\t\t    hw_link_info->phy_type);\n\t}\n\n\t \n\tmemset(&cap_ksettings, 0, sizeof(struct ethtool_link_ksettings));\n\ti40e_phy_type_to_ethtool(pf, &cap_ksettings);\n\tethtool_intersect_link_masks(ks, &cap_ksettings);\n\n\t \n\tswitch (link_speed) {\n\tcase I40E_LINK_SPEED_40GB:\n\t\tks->base.speed = SPEED_40000;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_25GB:\n\t\tks->base.speed = SPEED_25000;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_20GB:\n\t\tks->base.speed = SPEED_20000;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_10GB:\n\t\tks->base.speed = SPEED_10000;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_5GB:\n\t\tks->base.speed = SPEED_5000;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_2_5GB:\n\t\tks->base.speed = SPEED_2500;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_1GB:\n\t\tks->base.speed = SPEED_1000;\n\t\tbreak;\n\tcase I40E_LINK_SPEED_100MB:\n\t\tks->base.speed = SPEED_100;\n\t\tbreak;\n\tdefault:\n\t\tks->base.speed = SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\tks->base.duplex = DUPLEX_FULL;\n}\n\n \nstatic void i40e_get_settings_link_down(struct i40e_hw *hw,\n\t\t\t\t\tstruct ethtool_link_ksettings *ks,\n\t\t\t\t\tstruct i40e_pf *pf)\n{\n\t \n\ti40e_phy_type_to_ethtool(pf, ks);\n\n\t \n\tks->base.speed = SPEED_UNKNOWN;\n\tks->base.duplex = DUPLEX_UNKNOWN;\n}\n\n \nstatic int i40e_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *ks)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_link_status *hw_link_info = &hw->phy.link_info;\n\tbool link_up = hw_link_info->link_info & I40E_AQ_LINK_UP;\n\n\tethtool_link_ksettings_zero_link_mode(ks, supported);\n\tethtool_link_ksettings_zero_link_mode(ks, advertising);\n\n\tif (link_up)\n\t\ti40e_get_settings_link_up(hw, ks, netdev, pf);\n\telse\n\t\ti40e_get_settings_link_down(hw, ks, pf);\n\n\t \n\t \n\tks->base.autoneg = ((hw_link_info->an_info & I40E_AQ_AN_COMPLETED) ?\n\t\t\t    AUTONEG_ENABLE : AUTONEG_DISABLE);\n\n\t \n\tswitch (hw->phy.media_type) {\n\tcase I40E_MEDIA_TYPE_BACKPLANE:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Backplane);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Backplane);\n\t\tks->base.port = PORT_NONE;\n\t\tbreak;\n\tcase I40E_MEDIA_TYPE_BASET:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, TP);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, TP);\n\t\tks->base.port = PORT_TP;\n\t\tbreak;\n\tcase I40E_MEDIA_TYPE_DA:\n\tcase I40E_MEDIA_TYPE_CX4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FIBRE);\n\t\tks->base.port = PORT_DA;\n\t\tbreak;\n\tcase I40E_MEDIA_TYPE_FIBER:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FIBRE);\n\t\tks->base.port = PORT_FIBRE;\n\t\tbreak;\n\tcase I40E_MEDIA_TYPE_UNKNOWN:\n\tdefault:\n\t\tks->base.port = PORT_OTHER;\n\t\tbreak;\n\t}\n\n\t \n\tethtool_link_ksettings_add_link_mode(ks, supported, Pause);\n\tethtool_link_ksettings_add_link_mode(ks, supported, Asym_Pause);\n\n\tswitch (hw->fc.requested_mode) {\n\tcase I40E_FC_FULL:\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Pause);\n\t\tbreak;\n\tcase I40E_FC_TX_PAUSE:\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tcase I40E_FC_RX_PAUSE:\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Pause);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tdefault:\n\t\tethtool_link_ksettings_del_link_mode(ks, advertising, Pause);\n\t\tethtool_link_ksettings_del_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define I40E_LBIT_SIZE 8\n \nstatic enum i40e_aq_link_speed\ni40e_speed_to_link_speed(__u32 speed, const struct ethtool_link_ksettings *ks)\n{\n\tenum i40e_aq_link_speed link_speed = I40E_LINK_SPEED_UNKNOWN;\n\tbool speed_changed = false;\n\tint i, j;\n\n\tstatic const struct {\n\t\t__u32 speed;\n\t\tenum i40e_aq_link_speed link_speed;\n\t\t__u8 bit[I40E_LBIT_SIZE];\n\t} i40e_speed_lut[] = {\n#define I40E_LBIT(mode) ETHTOOL_LINK_MODE_ ## mode ##_Full_BIT\n\t\t{SPEED_100, I40E_LINK_SPEED_100MB, {I40E_LBIT(100baseT)} },\n\t\t{SPEED_1000, I40E_LINK_SPEED_1GB,\n\t\t {I40E_LBIT(1000baseT), I40E_LBIT(1000baseX),\n\t\t  I40E_LBIT(1000baseKX)} },\n\t\t{SPEED_10000, I40E_LINK_SPEED_10GB,\n\t\t {I40E_LBIT(10000baseT), I40E_LBIT(10000baseKR),\n\t\t  I40E_LBIT(10000baseLR), I40E_LBIT(10000baseCR),\n\t\t  I40E_LBIT(10000baseSR), I40E_LBIT(10000baseKX4)} },\n\n\t\t{SPEED_25000, I40E_LINK_SPEED_25GB,\n\t\t {I40E_LBIT(25000baseCR), I40E_LBIT(25000baseKR),\n\t\t  I40E_LBIT(25000baseSR)} },\n\t\t{SPEED_40000, I40E_LINK_SPEED_40GB,\n\t\t {I40E_LBIT(40000baseKR4), I40E_LBIT(40000baseCR4),\n\t\t  I40E_LBIT(40000baseSR4), I40E_LBIT(40000baseLR4)} },\n\t\t{SPEED_20000, I40E_LINK_SPEED_20GB,\n\t\t {I40E_LBIT(20000baseKR2)} },\n\t\t{SPEED_2500, I40E_LINK_SPEED_2_5GB, {I40E_LBIT(2500baseT)} },\n\t\t{SPEED_5000, I40E_LINK_SPEED_5GB, {I40E_LBIT(2500baseT)} }\n#undef I40E_LBIT\n};\n\n\tfor (i = 0; i < ARRAY_SIZE(i40e_speed_lut); i++) {\n\t\tif (i40e_speed_lut[i].speed == speed) {\n\t\t\tfor (j = 0; j < I40E_LBIT_SIZE; j++) {\n\t\t\t\tif (test_bit(i40e_speed_lut[i].bit[j],\n\t\t\t\t\t     ks->link_modes.supported)) {\n\t\t\t\t\tspeed_changed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!i40e_speed_lut[i].bit[j])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (speed_changed) {\n\t\t\t\tlink_speed = i40e_speed_lut[i].link_speed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn link_speed;\n}\n\n#undef I40E_LBIT_SIZE\n\n \nstatic int i40e_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t   const struct ethtool_link_ksettings *ks)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct ethtool_link_ksettings safe_ks;\n\tstruct ethtool_link_ksettings copy_ks;\n\tstruct i40e_aq_set_phy_config config;\n\tstruct i40e_pf *pf = np->vsi->back;\n\tenum i40e_aq_link_speed link_speed;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_hw *hw = &pf->hw;\n\tbool autoneg_changed = false;\n\tint timeout = 50;\n\tint status = 0;\n\tint err = 0;\n\t__u32 speed;\n\tu8 autoneg;\n\n\t \n\tif (hw->partition_id != 1) {\n\t\ti40e_partition_setting_complaint(pf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (vsi != pf->vsi[pf->lan_vsi])\n\t\treturn -EOPNOTSUPP;\n\tif (hw->phy.media_type != I40E_MEDIA_TYPE_BASET &&\n\t    hw->phy.media_type != I40E_MEDIA_TYPE_FIBER &&\n\t    hw->phy.media_type != I40E_MEDIA_TYPE_BACKPLANE &&\n\t    hw->phy.media_type != I40E_MEDIA_TYPE_DA &&\n\t    hw->phy.link_info.link_info & I40E_AQ_LINK_UP)\n\t\treturn -EOPNOTSUPP;\n\tif (hw->device_id == I40E_DEV_ID_KX_B ||\n\t    hw->device_id == I40E_DEV_ID_KX_C ||\n\t    hw->device_id == I40E_DEV_ID_20G_KR2 ||\n\t    hw->device_id == I40E_DEV_ID_20G_KR2_A ||\n\t    hw->device_id == I40E_DEV_ID_25G_B ||\n\t    hw->device_id == I40E_DEV_ID_KX_X722) {\n\t\tnetdev_info(netdev, \"Changing settings is not supported on backplane.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tmemcpy(&copy_ks, ks, sizeof(struct ethtool_link_ksettings));\n\n\t \n\tautoneg = copy_ks.base.autoneg;\n\tspeed = copy_ks.base.speed;\n\n\t \n\tmemset(&safe_ks, 0, sizeof(struct ethtool_link_ksettings));\n\tsafe_ks.base.cmd = copy_ks.base.cmd;\n\tsafe_ks.base.link_mode_masks_nwords =\n\t\tcopy_ks.base.link_mode_masks_nwords;\n\ti40e_get_link_ksettings(netdev, &safe_ks);\n\n\t \n\tif (!bitmap_subset(copy_ks.link_modes.advertising,\n\t\t\t   safe_ks.link_modes.supported,\n\t\t\t   __ETHTOOL_LINK_MODE_MASK_NBITS))\n\t\treturn -EINVAL;\n\n\t \n\tcopy_ks.base.autoneg = safe_ks.base.autoneg;\n\tcopy_ks.base.speed  = safe_ks.base.speed;\n\n\t \n\tif (memcmp(&copy_ks.base, &safe_ks.base,\n\t\t   sizeof(struct ethtool_link_settings))) {\n\t\tnetdev_err(netdev, \"Only speed and autoneg are supported.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twhile (test_and_set_bit(__I40E_CONFIG_BUSY, pf->state)) {\n\t\ttimeout--;\n\t\tif (!timeout)\n\t\t\treturn -EBUSY;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\tstatus = i40e_aq_get_phy_capabilities(hw, false, false, &abilities,\n\t\t\t\t\t      NULL);\n\tif (status) {\n\t\terr = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\t \n\tmemset(&config, 0, sizeof(struct i40e_aq_set_phy_config));\n\tconfig.abilities = abilities.abilities;\n\n\t \n\tif (autoneg == AUTONEG_ENABLE) {\n\t\t \n\t\tif (!(hw->phy.link_info.an_info & I40E_AQ_AN_COMPLETED)) {\n\t\t\t \n\t\t\tif (!ethtool_link_ksettings_test_link_mode(&safe_ks,\n\t\t\t\t\t\t\t\t   supported,\n\t\t\t\t\t\t\t\t   Autoneg)) {\n\t\t\t\tnetdev_info(netdev, \"Autoneg not supported on this phy\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t\tconfig.abilities = abilities.abilities |\n\t\t\t\t\t   I40E_AQ_PHY_ENABLE_AN;\n\t\t\tautoneg_changed = true;\n\t\t}\n\t} else {\n\t\t \n\t\tif (hw->phy.link_info.an_info & I40E_AQ_AN_COMPLETED) {\n\t\t\t \n\t\t\tif (ethtool_link_ksettings_test_link_mode(&safe_ks,\n\t\t\t\t\t\t\t\t  supported,\n\t\t\t\t\t\t\t\t  Autoneg) &&\n\t\t\t    hw->phy.media_type != I40E_MEDIA_TYPE_BASET) {\n\t\t\t\tnetdev_info(netdev, \"Autoneg cannot be disabled on this phy\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t\tconfig.abilities = abilities.abilities &\n\t\t\t\t\t   ~I40E_AQ_PHY_ENABLE_AN;\n\t\t\tautoneg_changed = true;\n\t\t}\n\t}\n\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100baseT_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_100MB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseT_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseX_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseKX_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_1GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseT_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseKX4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseKR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseCR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseSR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseLR_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_10GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  2500baseT_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_2_5GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  5000baseT_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_5GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  20000baseKR2_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_20GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  25000baseCR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  25000baseKR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  25000baseSR_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_25GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseKR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseCR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseSR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseLR4_Full))\n\t\tconfig.link_speed |= I40E_LINK_SPEED_40GB;\n\n\t \n\tif ((speed != SPEED_UNKNOWN && safe_ks.base.speed != speed) &&\n\t    (autoneg == AUTONEG_DISABLE ||\n\t    (safe_ks.base.autoneg == AUTONEG_DISABLE && !autoneg_changed))) {\n\t\tlink_speed = i40e_speed_to_link_speed(speed, ks);\n\t\tif (link_speed == I40E_LINK_SPEED_UNKNOWN) {\n\t\t\tnetdev_info(netdev, \"Given speed is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t} else {\n\t\t\tconfig.link_speed = link_speed;\n\t\t}\n\t} else {\n\t\tif (safe_ks.base.speed != speed) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Unable to set speed, disable autoneg\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (!config.link_speed)\n\t\tconfig.link_speed = abilities.link_speed;\n\tif (autoneg_changed || abilities.link_speed != config.link_speed) {\n\t\t \n\t\tconfig.phy_type = abilities.phy_type;\n\t\tconfig.phy_type_ext = abilities.phy_type_ext;\n\t\tconfig.eee_capability = abilities.eee_capability;\n\t\tconfig.eeer = abilities.eeer_val;\n\t\tconfig.low_power_ctrl = abilities.d3_lpan;\n\t\tconfig.fec_config = abilities.fec_cfg_curr_mod_ext_info &\n\t\t\t\t    I40E_AQ_PHY_FEC_CONFIG_MASK;\n\n\t\t \n\t\thw->phy.link_info.requested_speeds = config.link_speed;\n\t\t \n\t\tconfig.abilities |= I40E_AQ_PHY_ENABLE_ATOMIC_LINK;\n\t\t \n\t\tif (hw->phy.link_info.link_info & I40E_AQ_LINK_UP) {\n\t\t\t \n\t\t\ti40e_print_link_message(vsi, false);\n\t\t\tnetif_carrier_off(netdev);\n\t\t\tnetif_tx_stop_all_queues(netdev);\n\t\t}\n\n\t\t \n\t\tstatus = i40e_aq_set_phy_config(hw, &config, NULL);\n\t\tif (status) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Set phy config failed, err %pe aq_err %s\\n\",\n\t\t\t\t    ERR_PTR(status),\n\t\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t\terr = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\n\t\tstatus = i40e_update_link_info(hw);\n\t\tif (status)\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"Updating link info failed with err %pe aq_err %s\\n\",\n\t\t\t\t   ERR_PTR(status),\n\t\t\t\t   i40e_aq_str(hw, hw->aq.asq_last_status));\n\n\t} else {\n\t\tnetdev_info(netdev, \"Nothing changed, exiting without setting anything.\\n\");\n\t}\n\ndone:\n\tclear_bit(__I40E_CONFIG_BUSY, pf->state);\n\n\treturn err;\n}\n\nstatic int i40e_set_fec_cfg(struct net_device *netdev, u8 fec_cfg)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint status = 0;\n\tu32 flags = 0;\n\tint err = 0;\n\n\tflags = READ_ONCE(pf->flags);\n\ti40e_set_fec_in_flags(fec_cfg, &flags);\n\n\t \n\tmemset(&abilities, 0, sizeof(abilities));\n\tstatus = i40e_aq_get_phy_capabilities(hw, false, false, &abilities,\n\t\t\t\t\t      NULL);\n\tif (status) {\n\t\terr = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\tif (abilities.fec_cfg_curr_mod_ext_info != fec_cfg) {\n\t\tstruct i40e_aq_set_phy_config config;\n\n\t\tmemset(&config, 0, sizeof(config));\n\t\tconfig.phy_type = abilities.phy_type;\n\t\tconfig.abilities = abilities.abilities |\n\t\t\t\t   I40E_AQ_PHY_ENABLE_ATOMIC_LINK;\n\t\tconfig.phy_type_ext = abilities.phy_type_ext;\n\t\tconfig.link_speed = abilities.link_speed;\n\t\tconfig.eee_capability = abilities.eee_capability;\n\t\tconfig.eeer = abilities.eeer_val;\n\t\tconfig.low_power_ctrl = abilities.d3_lpan;\n\t\tconfig.fec_config = fec_cfg & I40E_AQ_PHY_FEC_CONFIG_MASK;\n\t\tstatus = i40e_aq_set_phy_config(hw, &config, NULL);\n\t\tif (status) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Set phy config failed, err %pe aq_err %s\\n\",\n\t\t\t\t    ERR_PTR(status),\n\t\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t\terr = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\tpf->flags = flags;\n\t\tstatus = i40e_update_link_info(hw);\n\t\tif (status)\n\t\t\t \n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"Updating link info failed with err %pe aq_err %s\\n\",\n\t\t\t\t   ERR_PTR(status),\n\t\t\t\t   i40e_aq_str(hw, hw->aq.asq_last_status));\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int i40e_get_fec_param(struct net_device *netdev,\n\t\t\t      struct ethtool_fecparam *fecparam)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint status = 0;\n\tint err = 0;\n\tu8 fec_cfg;\n\n\t \n\tmemset(&abilities, 0, sizeof(abilities));\n\tstatus = i40e_aq_get_phy_capabilities(hw, false, false, &abilities,\n\t\t\t\t\t      NULL);\n\tif (status) {\n\t\terr = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\tfecparam->fec = 0;\n\tfec_cfg = abilities.fec_cfg_curr_mod_ext_info;\n\tif (fec_cfg & I40E_AQ_SET_FEC_AUTO)\n\t\tfecparam->fec |= ETHTOOL_FEC_AUTO;\n\telse if (fec_cfg & (I40E_AQ_SET_FEC_REQUEST_RS |\n\t\t I40E_AQ_SET_FEC_ABILITY_RS))\n\t\tfecparam->fec |= ETHTOOL_FEC_RS;\n\telse if (fec_cfg & (I40E_AQ_SET_FEC_REQUEST_KR |\n\t\t I40E_AQ_SET_FEC_ABILITY_KR))\n\t\tfecparam->fec |= ETHTOOL_FEC_BASER;\n\tif (fec_cfg == 0)\n\t\tfecparam->fec |= ETHTOOL_FEC_OFF;\n\n\tif (hw->phy.link_info.fec_info & I40E_AQ_CONFIG_FEC_KR_ENA)\n\t\tfecparam->active_fec = ETHTOOL_FEC_BASER;\n\telse if (hw->phy.link_info.fec_info & I40E_AQ_CONFIG_FEC_RS_ENA)\n\t\tfecparam->active_fec = ETHTOOL_FEC_RS;\n\telse\n\t\tfecparam->active_fec = ETHTOOL_FEC_OFF;\ndone:\n\treturn err;\n}\n\nstatic int i40e_set_fec_param(struct net_device *netdev,\n\t\t\t      struct ethtool_fecparam *fecparam)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu8 fec_cfg = 0;\n\n\tif (hw->device_id != I40E_DEV_ID_25G_SFP28 &&\n\t    hw->device_id != I40E_DEV_ID_25G_B &&\n\t    hw->device_id != I40E_DEV_ID_KX_X722)\n\t\treturn -EPERM;\n\n\tif (hw->mac.type == I40E_MAC_X722 &&\n\t    !(hw->flags & I40E_HW_FLAG_X722_FEC_REQUEST_CAPABLE)) {\n\t\tnetdev_err(netdev, \"Setting FEC encoding not supported by firmware. Please update the NVM image.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (fecparam->fec) {\n\tcase ETHTOOL_FEC_AUTO:\n\t\tfec_cfg = I40E_AQ_SET_FEC_AUTO;\n\t\tbreak;\n\tcase ETHTOOL_FEC_RS:\n\t\tfec_cfg = (I40E_AQ_SET_FEC_REQUEST_RS |\n\t\t\t     I40E_AQ_SET_FEC_ABILITY_RS);\n\t\tbreak;\n\tcase ETHTOOL_FEC_BASER:\n\t\tfec_cfg = (I40E_AQ_SET_FEC_REQUEST_KR |\n\t\t\t     I40E_AQ_SET_FEC_ABILITY_KR);\n\t\tbreak;\n\tcase ETHTOOL_FEC_OFF:\n\tcase ETHTOOL_FEC_NONE:\n\t\tfec_cfg = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pf->pdev->dev, \"Unsupported FEC mode: %d\",\n\t\t\t fecparam->fec);\n\t\treturn -EINVAL;\n\t}\n\n\treturn i40e_set_fec_cfg(netdev, fec_cfg);\n}\n\nstatic int i40e_nway_reset(struct net_device *netdev)\n{\n\t \n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tbool link_up = hw->phy.link_info.link_info & I40E_AQ_LINK_UP;\n\tint ret = 0;\n\n\tret = i40e_aq_set_link_restart_an(hw, link_up, NULL);\n\tif (ret) {\n\t\tnetdev_info(netdev, \"link restart failed, err %pe aq_err %s\\n\",\n\t\t\t    ERR_PTR(ret),\n\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void i40e_get_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_link_status *hw_link_info = &hw->phy.link_info;\n\tstruct i40e_dcbx_config *dcbx_cfg = &hw->local_dcbx_config;\n\n\tpause->autoneg =\n\t\t((hw_link_info->an_info & I40E_AQ_AN_COMPLETED) ?\n\t\t  AUTONEG_ENABLE : AUTONEG_DISABLE);\n\n\t \n\tif (dcbx_cfg->pfc.pfcenable) {\n\t\tpause->rx_pause = 0;\n\t\tpause->tx_pause = 0;\n\t\treturn;\n\t}\n\n\tif (hw->fc.current_mode == I40E_FC_RX_PAUSE) {\n\t\tpause->rx_pause = 1;\n\t} else if (hw->fc.current_mode == I40E_FC_TX_PAUSE) {\n\t\tpause->tx_pause = 1;\n\t} else if (hw->fc.current_mode == I40E_FC_FULL) {\n\t\tpause->rx_pause = 1;\n\t\tpause->tx_pause = 1;\n\t}\n}\n\n \nstatic int i40e_set_pauseparam(struct net_device *netdev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_link_status *hw_link_info = &hw->phy.link_info;\n\tstruct i40e_dcbx_config *dcbx_cfg = &hw->local_dcbx_config;\n\tbool link_up = hw_link_info->link_info & I40E_AQ_LINK_UP;\n\tu8 aq_failures;\n\tint err = 0;\n\tint status;\n\tu32 is_an;\n\n\t \n\tif (hw->partition_id != 1) {\n\t\ti40e_partition_setting_complaint(pf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vsi != pf->vsi[pf->lan_vsi])\n\t\treturn -EOPNOTSUPP;\n\n\tis_an = hw_link_info->an_info & I40E_AQ_AN_COMPLETED;\n\tif (pause->autoneg != is_an) {\n\t\tnetdev_info(netdev, \"To change autoneg please use: ethtool -s <dev> autoneg <on|off>\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!test_bit(__I40E_DOWN, pf->state) && !is_an) {\n\t\t \n\t\tnetdev_info(netdev, \"Autoneg did not complete so changing settings may not result in an actual change.\\n\");\n\t}\n\n\tif (dcbx_cfg->pfc.pfcenable) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"Priority flow control enabled. Cannot set link flow control.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (pause->rx_pause && pause->tx_pause)\n\t\thw->fc.requested_mode = I40E_FC_FULL;\n\telse if (pause->rx_pause && !pause->tx_pause)\n\t\thw->fc.requested_mode = I40E_FC_RX_PAUSE;\n\telse if (!pause->rx_pause && pause->tx_pause)\n\t\thw->fc.requested_mode = I40E_FC_TX_PAUSE;\n\telse if (!pause->rx_pause && !pause->tx_pause)\n\t\thw->fc.requested_mode = I40E_FC_NONE;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\ti40e_print_link_message(vsi, false);\n\tnetif_carrier_off(netdev);\n\tnetif_tx_stop_all_queues(netdev);\n\n\t \n\tstatus = i40e_set_fc(hw, &aq_failures, link_up);\n\n\tif (aq_failures & I40E_SET_FC_AQ_FAIL_GET) {\n\t\tnetdev_info(netdev, \"Set fc failed on the get_phy_capabilities call with err %pe aq_err %s\\n\",\n\t\t\t    ERR_PTR(status),\n\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\terr = -EAGAIN;\n\t}\n\tif (aq_failures & I40E_SET_FC_AQ_FAIL_SET) {\n\t\tnetdev_info(netdev, \"Set fc failed on the set_phy_config call with err %pe aq_err %s\\n\",\n\t\t\t    ERR_PTR(status),\n\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\terr = -EAGAIN;\n\t}\n\tif (aq_failures & I40E_SET_FC_AQ_FAIL_UPDATE) {\n\t\tnetdev_info(netdev, \"Set fc failed on the get_link_info call with err %pe aq_err %s\\n\",\n\t\t\t    ERR_PTR(status),\n\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\terr = -EAGAIN;\n\t}\n\n\tif (!test_bit(__I40E_DOWN, pf->state) && is_an) {\n\t\t \n\t\tmsleep(75);\n\t\tif (!test_bit(__I40E_DOWN, pf->state))\n\t\t\treturn i40e_nway_reset(netdev);\n\t}\n\n\treturn err;\n}\n\nstatic u32 i40e_get_msglevel(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tu32 debug_mask = pf->hw.debug_mask;\n\n\tif (debug_mask)\n\t\tnetdev_info(netdev, \"i40e debug_mask: 0x%08X\\n\", debug_mask);\n\n\treturn pf->msg_enable;\n}\n\nstatic void i40e_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\n\tif (I40E_DEBUG_USER & data)\n\t\tpf->hw.debug_mask = data;\n\telse\n\t\tpf->msg_enable = data;\n}\n\nstatic int i40e_get_regs_len(struct net_device *netdev)\n{\n\tint reg_count = 0;\n\tint i;\n\n\tfor (i = 0; i40e_reg_list[i].offset != 0; i++)\n\t\treg_count += i40e_reg_list[i].elements;\n\n\treturn reg_count * sizeof(u32);\n}\n\nstatic void i40e_get_regs(struct net_device *netdev, struct ethtool_regs *regs,\n\t\t\t  void *p)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 *reg_buf = p;\n\tunsigned int i, j, ri;\n\tu32 reg;\n\n\t \n\tregs->version = 1;\n\n\t \n\tri = 0;\n\tfor (i = 0; i40e_reg_list[i].offset != 0; i++) {\n\t\tfor (j = 0; j < i40e_reg_list[i].elements; j++) {\n\t\t\treg = i40e_reg_list[i].offset\n\t\t\t\t+ (j * i40e_reg_list[i].stride);\n\t\t\treg_buf[ri++] = rd32(hw, reg);\n\t\t}\n\t}\n\n}\n\nstatic int i40e_get_eeprom(struct net_device *netdev,\n\t\t\t   struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_hw *hw = &np->vsi->back->hw;\n\tstruct i40e_pf *pf = np->vsi->back;\n\tint ret_val = 0, len, offset;\n\tu8 *eeprom_buff;\n\tu16 i, sectors;\n\tbool last;\n\tu32 magic;\n\n#define I40E_NVM_SECTOR_SIZE  4096\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\t \n\tmagic = hw->vendor_id | (hw->device_id << 16);\n\tif (eeprom->magic && eeprom->magic != magic) {\n\t\tstruct i40e_nvm_access *cmd = (struct i40e_nvm_access *)eeprom;\n\t\tint errno = 0;\n\n\t\t \n\t\tif ((eeprom->magic >> 16) != hw->device_id)\n\t\t\terrno = -EINVAL;\n\t\telse if (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||\n\t\t\t test_bit(__I40E_RESET_INTR_RECEIVED, pf->state))\n\t\t\terrno = -EBUSY;\n\t\telse\n\t\t\tret_val = i40e_nvmupd_command(hw, cmd, bytes, &errno);\n\n\t\tif ((errno || ret_val) && (hw->debug_mask & I40E_DEBUG_NVM))\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"NVMUpdate read failed err=%d status=0x%x errno=%d module=%d offset=0x%x size=%d\\n\",\n\t\t\t\t ret_val, hw->aq.asq_last_status, errno,\n\t\t\t\t (u8)(cmd->config & I40E_NVM_MOD_PNT_MASK),\n\t\t\t\t cmd->offset, cmd->data_size);\n\n\t\treturn errno;\n\t}\n\n\t \n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\n\teeprom_buff = kzalloc(eeprom->len, GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tret_val = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\n\tif (ret_val) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed Acquiring NVM resource for read err=%d status=0x%x\\n\",\n\t\t\t ret_val, hw->aq.asq_last_status);\n\t\tgoto free_buff;\n\t}\n\n\tsectors = eeprom->len / I40E_NVM_SECTOR_SIZE;\n\tsectors += (eeprom->len % I40E_NVM_SECTOR_SIZE) ? 1 : 0;\n\tlen = I40E_NVM_SECTOR_SIZE;\n\tlast = false;\n\tfor (i = 0; i < sectors; i++) {\n\t\tif (i == (sectors - 1)) {\n\t\t\tlen = eeprom->len - (I40E_NVM_SECTOR_SIZE * i);\n\t\t\tlast = true;\n\t\t}\n\t\toffset = eeprom->offset + (I40E_NVM_SECTOR_SIZE * i),\n\t\tret_val = i40e_aq_read_nvm(hw, 0x0, offset, len,\n\t\t\t\t(u8 *)eeprom_buff + (I40E_NVM_SECTOR_SIZE * i),\n\t\t\t\tlast, NULL);\n\t\tif (ret_val && hw->aq.asq_last_status == I40E_AQ_RC_EPERM) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"read NVM failed, invalid offset 0x%x\\n\",\n\t\t\t\t offset);\n\t\t\tbreak;\n\t\t} else if (ret_val &&\n\t\t\t   hw->aq.asq_last_status == I40E_AQ_RC_EACCES) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"read NVM failed, access, offset 0x%x\\n\",\n\t\t\t\t offset);\n\t\t\tbreak;\n\t\t} else if (ret_val) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"read NVM failed offset %d err=%d status=0x%x\\n\",\n\t\t\t\t offset, ret_val, hw->aq.asq_last_status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti40e_release_nvm(hw);\n\tmemcpy(bytes, (u8 *)eeprom_buff, eeprom->len);\nfree_buff:\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic int i40e_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_hw *hw = &np->vsi->back->hw;\n\tu32 val;\n\n#define X722_EEPROM_SCOPE_LIMIT 0x5B9FFF\n\tif (hw->mac.type == I40E_MAC_X722) {\n\t\tval = X722_EEPROM_SCOPE_LIMIT + 1;\n\t\treturn val;\n\t}\n\tval = (rd32(hw, I40E_GLPCI_LBARCTRL)\n\t\t& I40E_GLPCI_LBARCTRL_FL_SIZE_MASK)\n\t\t>> I40E_GLPCI_LBARCTRL_FL_SIZE_SHIFT;\n\t \n\tval = (64 * 1024) * BIT(val);\n\treturn val;\n}\n\nstatic int i40e_set_eeprom(struct net_device *netdev,\n\t\t\t   struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_hw *hw = &np->vsi->back->hw;\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_nvm_access *cmd = (struct i40e_nvm_access *)eeprom;\n\tint ret_val = 0;\n\tint errno = 0;\n\tu32 magic;\n\n\t \n\tmagic = hw->vendor_id | (hw->device_id << 16);\n\tif (eeprom->magic == magic)\n\t\terrno = -EOPNOTSUPP;\n\t \n\telse if (!eeprom->magic || (eeprom->magic >> 16) != hw->device_id)\n\t\terrno = -EINVAL;\n\telse if (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||\n\t\t test_bit(__I40E_RESET_INTR_RECEIVED, pf->state))\n\t\terrno = -EBUSY;\n\telse\n\t\tret_val = i40e_nvmupd_command(hw, cmd, bytes, &errno);\n\n\tif ((errno || ret_val) && (hw->debug_mask & I40E_DEBUG_NVM))\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"NVMUpdate write failed err=%d status=0x%x errno=%d module=%d offset=0x%x size=%d\\n\",\n\t\t\t ret_val, hw->aq.asq_last_status, errno,\n\t\t\t (u8)(cmd->config & I40E_NVM_MOD_PNT_MASK),\n\t\t\t cmd->offset, cmd->data_size);\n\n\treturn errno;\n}\n\nstatic void i40e_get_drvinfo(struct net_device *netdev,\n\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\n\tstrscpy(drvinfo->driver, i40e_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->fw_version, i40e_nvm_version_str(&pf->hw),\n\t\tsizeof(drvinfo->fw_version));\n\tstrscpy(drvinfo->bus_info, pci_name(pf->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\tdrvinfo->n_priv_flags = I40E_PRIV_FLAGS_STR_LEN;\n\tif (pf->hw.pf_id == 0)\n\t\tdrvinfo->n_priv_flags += I40E_GL_PRIV_FLAGS_STR_LEN;\n}\n\nstatic void i40e_get_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\n\tring->rx_max_pending = I40E_MAX_NUM_DESCRIPTORS;\n\tring->tx_max_pending = I40E_MAX_NUM_DESCRIPTORS;\n\tring->rx_mini_max_pending = 0;\n\tring->rx_jumbo_max_pending = 0;\n\tring->rx_pending = vsi->rx_rings[0]->count;\n\tring->tx_pending = vsi->tx_rings[0]->count;\n\tring->rx_mini_pending = 0;\n\tring->rx_jumbo_pending = 0;\n}\n\nstatic bool i40e_active_tx_ring_index(struct i40e_vsi *vsi, u16 index)\n{\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\treturn index < vsi->num_queue_pairs ||\n\t\t\t(index >= vsi->alloc_queue_pairs &&\n\t\t\t index < vsi->alloc_queue_pairs + vsi->num_queue_pairs);\n\t}\n\n\treturn index < vsi->num_queue_pairs;\n}\n\nstatic int i40e_set_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ring,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct i40e_ring *tx_rings = NULL, *rx_rings = NULL;\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_hw *hw = &np->vsi->back->hw;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tu32 new_rx_count, new_tx_count;\n\tu16 tx_alloc_queue_pairs;\n\tint timeout = 50;\n\tint i, err = 0;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tif (ring->tx_pending > I40E_MAX_NUM_DESCRIPTORS ||\n\t    ring->tx_pending < I40E_MIN_NUM_DESCRIPTORS ||\n\t    ring->rx_pending > I40E_MAX_NUM_DESCRIPTORS ||\n\t    ring->rx_pending < I40E_MIN_NUM_DESCRIPTORS) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"Descriptors requested (Tx: %d / Rx: %d) out of range [%d-%d]\\n\",\n\t\t\t    ring->tx_pending, ring->rx_pending,\n\t\t\t    I40E_MIN_NUM_DESCRIPTORS, I40E_MAX_NUM_DESCRIPTORS);\n\t\treturn -EINVAL;\n\t}\n\n\tnew_tx_count = ALIGN(ring->tx_pending, I40E_REQ_DESCRIPTOR_MULTIPLE);\n\tnew_rx_count = ALIGN(ring->rx_pending, I40E_REQ_DESCRIPTOR_MULTIPLE);\n\n\t \n\tif ((new_tx_count == vsi->tx_rings[0]->count) &&\n\t    (new_rx_count == vsi->rx_rings[0]->count))\n\t\treturn 0;\n\n\t \n\tif (i40e_xsk_any_rx_ring_enabled(vsi))\n\t\treturn -EBUSY;\n\n\twhile (test_and_set_bit(__I40E_CONFIG_BUSY, pf->state)) {\n\t\ttimeout--;\n\t\tif (!timeout)\n\t\t\treturn -EBUSY;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (!netif_running(vsi->netdev)) {\n\t\t \n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\t\tvsi->tx_rings[i]->count = new_tx_count;\n\t\t\tvsi->rx_rings[i]->count = new_rx_count;\n\t\t\tif (i40e_enabled_xdp_vsi(vsi))\n\t\t\t\tvsi->xdp_rings[i]->count = new_tx_count;\n\t\t}\n\t\tvsi->num_tx_desc = new_tx_count;\n\t\tvsi->num_rx_desc = new_rx_count;\n\t\tgoto done;\n\t}\n\n\t \n\n\t \n\ttx_alloc_queue_pairs = vsi->alloc_queue_pairs *\n\t\t\t       (i40e_enabled_xdp_vsi(vsi) ? 2 : 1);\n\tif (new_tx_count != vsi->tx_rings[0]->count) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"Changing Tx descriptor count from %d to %d.\\n\",\n\t\t\t    vsi->tx_rings[0]->count, new_tx_count);\n\t\ttx_rings = kcalloc(tx_alloc_queue_pairs,\n\t\t\t\t   sizeof(struct i40e_ring), GFP_KERNEL);\n\t\tif (!tx_rings) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < tx_alloc_queue_pairs; i++) {\n\t\t\tif (!i40e_active_tx_ring_index(vsi, i))\n\t\t\t\tcontinue;\n\n\t\t\ttx_rings[i] = *vsi->tx_rings[i];\n\t\t\ttx_rings[i].count = new_tx_count;\n\t\t\t \n\t\t\ttx_rings[i].desc = NULL;\n\t\t\ttx_rings[i].rx_bi = NULL;\n\t\t\terr = i40e_setup_tx_descriptors(&tx_rings[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tif (!i40e_active_tx_ring_index(vsi, i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ti40e_free_tx_resources(&tx_rings[i]);\n\t\t\t\t}\n\t\t\t\tkfree(tx_rings);\n\t\t\t\ttx_rings = NULL;\n\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (new_rx_count != vsi->rx_rings[0]->count) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"Changing Rx descriptor count from %d to %d\\n\",\n\t\t\t    vsi->rx_rings[0]->count, new_rx_count);\n\t\trx_rings = kcalloc(vsi->alloc_queue_pairs,\n\t\t\t\t   sizeof(struct i40e_ring), GFP_KERNEL);\n\t\tif (!rx_rings) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_tx;\n\t\t}\n\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\t\tu16 unused;\n\n\t\t\t \n\t\t\trx_rings[i] = *vsi->rx_rings[i];\n\t\t\trx_rings[i].count = new_rx_count;\n\t\t\t \n\t\t\trx_rings[i].desc = NULL;\n\t\t\trx_rings[i].rx_bi = NULL;\n\t\t\t \n\t\t\tmemset(&rx_rings[i].xdp_rxq, 0, sizeof(rx_rings[i].xdp_rxq));\n\t\t\t \n\t\t\trx_rings[i].tail = hw->hw_addr + I40E_PRTGEN_STATUS;\n\t\t\terr = i40e_setup_rx_descriptors(&rx_rings[i]);\n\t\t\tif (err)\n\t\t\t\tgoto rx_unwind;\n\n\t\t\t \n\t\t\tunused = I40E_DESC_UNUSED(&rx_rings[i]);\n\t\t\terr = i40e_alloc_rx_buffers(&rx_rings[i], unused);\nrx_unwind:\n\t\t\tif (err) {\n\t\t\t\tdo {\n\t\t\t\t\ti40e_free_rx_resources(&rx_rings[i]);\n\t\t\t\t} while (i--);\n\t\t\t\tkfree(rx_rings);\n\t\t\t\trx_rings = NULL;\n\n\t\t\t\tgoto free_tx;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ti40e_down(vsi);\n\n\tif (tx_rings) {\n\t\tfor (i = 0; i < tx_alloc_queue_pairs; i++) {\n\t\t\tif (i40e_active_tx_ring_index(vsi, i)) {\n\t\t\t\ti40e_free_tx_resources(vsi->tx_rings[i]);\n\t\t\t\t*vsi->tx_rings[i] = tx_rings[i];\n\t\t\t}\n\t\t}\n\t\tkfree(tx_rings);\n\t\ttx_rings = NULL;\n\t}\n\n\tif (rx_rings) {\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\t\ti40e_free_rx_resources(vsi->rx_rings[i]);\n\t\t\t \n\t\t\trx_rings[i].tail = vsi->rx_rings[i]->tail;\n\t\t\t \n\t\t\trx_rings[i].next_to_use = 0;\n\t\t\trx_rings[i].next_to_clean = 0;\n\t\t\trx_rings[i].next_to_alloc = 0;\n\t\t\t \n\t\t\t*vsi->rx_rings[i] = rx_rings[i];\n\t\t}\n\t\tkfree(rx_rings);\n\t\trx_rings = NULL;\n\t}\n\n\tvsi->num_tx_desc = new_tx_count;\n\tvsi->num_rx_desc = new_rx_count;\n\ti40e_up(vsi);\n\nfree_tx:\n\t \n\tif (tx_rings) {\n\t\tfor (i = 0; i < tx_alloc_queue_pairs; i++) {\n\t\t\tif (i40e_active_tx_ring_index(vsi, i))\n\t\t\t\ti40e_free_tx_resources(vsi->tx_rings[i]);\n\t\t}\n\t\tkfree(tx_rings);\n\t\ttx_rings = NULL;\n\t}\n\ndone:\n\tclear_bit(__I40E_CONFIG_BUSY, pf->state);\n\n\treturn err;\n}\n\n \nstatic int i40e_get_stats_count(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tint stats_len;\n\n\tif (vsi == pf->vsi[pf->lan_vsi] && pf->hw.partition_id == 1)\n\t\tstats_len = I40E_PF_STATS_LEN;\n\telse\n\t\tstats_len = I40E_VSI_STATS_LEN;\n\n\t \n\tstats_len += I40E_QUEUE_STATS_LEN * 2 * netdev->num_tx_queues;\n\n\treturn stats_len;\n}\n\nstatic int i40e_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn I40E_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn i40e_get_stats_count(netdev);\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn I40E_PRIV_FLAGS_STR_LEN +\n\t\t\t(pf->hw.pf_id == 0 ? I40E_GL_PRIV_FLAGS_STR_LEN : 0);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic struct i40e_cp_veb_tc_stats\ni40e_get_veb_tc_stats(struct i40e_veb_tc_stats *tc, unsigned int i)\n{\n\tstruct i40e_cp_veb_tc_stats veb_tc = {\n\t\t.tc_rx_packets = tc->tc_rx_packets[i],\n\t\t.tc_rx_bytes = tc->tc_rx_bytes[i],\n\t\t.tc_tx_packets = tc->tc_tx_packets[i],\n\t\t.tc_tx_bytes = tc->tc_tx_bytes[i],\n\t};\n\n\treturn veb_tc;\n}\n\n \nstatic inline struct i40e_pfc_stats\ni40e_get_pfc_stats(struct i40e_pf *pf, unsigned int i)\n{\n#define I40E_GET_PFC_STAT(stat, priority) \\\n\t.stat = pf->stats.stat[priority]\n\n\tstruct i40e_pfc_stats pfc = {\n\t\tI40E_GET_PFC_STAT(priority_xon_rx, i),\n\t\tI40E_GET_PFC_STAT(priority_xoff_rx, i),\n\t\tI40E_GET_PFC_STAT(priority_xon_tx, i),\n\t\tI40E_GET_PFC_STAT(priority_xoff_tx, i),\n\t\tI40E_GET_PFC_STAT(priority_xon_2_xoff, i),\n\t};\n\treturn pfc;\n}\n\n \nstatic void i40e_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_veb *veb = NULL;\n\tunsigned int i;\n\tbool veb_stats;\n\tu64 *p = data;\n\n\ti40e_update_stats(vsi);\n\n\ti40e_add_ethtool_stats(&data, i40e_get_vsi_stats_struct(vsi),\n\t\t\t       i40e_gstrings_net_stats);\n\n\ti40e_add_ethtool_stats(&data, vsi, i40e_gstrings_misc_stats);\n\n\trcu_read_lock();\n\tfor (i = 0; i < netdev->num_tx_queues; i++) {\n\t\ti40e_add_queue_stats(&data, READ_ONCE(vsi->tx_rings[i]));\n\t\ti40e_add_queue_stats(&data, READ_ONCE(vsi->rx_rings[i]));\n\t}\n\trcu_read_unlock();\n\n\tif (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)\n\t\tgoto check_data_pointer;\n\n\tveb_stats = ((pf->lan_veb != I40E_NO_VEB) &&\n\t\t     (pf->lan_veb < I40E_MAX_VEB) &&\n\t\t     (pf->flags & I40E_FLAG_VEB_STATS_ENABLED));\n\n\tif (veb_stats) {\n\t\tveb = pf->veb[pf->lan_veb];\n\t\ti40e_update_veb_stats(veb);\n\t}\n\n\t \n\ti40e_add_ethtool_stats(&data, veb_stats ? veb : NULL,\n\t\t\t       i40e_gstrings_veb_stats);\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tif (veb_stats) {\n\t\t\tstruct i40e_cp_veb_tc_stats veb_tc =\n\t\t\t\ti40e_get_veb_tc_stats(&veb->tc_stats, i);\n\n\t\t\ti40e_add_ethtool_stats(&data, &veb_tc,\n\t\t\t\t\t       i40e_gstrings_veb_tc_stats);\n\t\t} else {\n\t\t\ti40e_add_ethtool_stats(&data, NULL,\n\t\t\t\t\t       i40e_gstrings_veb_tc_stats);\n\t\t}\n\n\ti40e_add_ethtool_stats(&data, pf, i40e_gstrings_stats);\n\n\tfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {\n\t\tstruct i40e_pfc_stats pfc = i40e_get_pfc_stats(pf, i);\n\n\t\ti40e_add_ethtool_stats(&data, &pfc, i40e_gstrings_pfc_stats);\n\t}\n\ncheck_data_pointer:\n\tWARN_ONCE(data - p != i40e_get_stats_count(netdev),\n\t\t  \"ethtool stats count mismatch!\");\n}\n\n \nstatic void i40e_get_stat_strings(struct net_device *netdev, u8 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tunsigned int i;\n\tu8 *p = data;\n\n\ti40e_add_stat_strings(&data, i40e_gstrings_net_stats);\n\n\ti40e_add_stat_strings(&data, i40e_gstrings_misc_stats);\n\n\tfor (i = 0; i < netdev->num_tx_queues; i++) {\n\t\ti40e_add_stat_strings(&data, i40e_gstrings_queue_stats,\n\t\t\t\t      \"tx\", i);\n\t\ti40e_add_stat_strings(&data, i40e_gstrings_queue_stats,\n\t\t\t\t      \"rx\", i);\n\t}\n\n\tif (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)\n\t\tgoto check_data_pointer;\n\n\ti40e_add_stat_strings(&data, i40e_gstrings_veb_stats);\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\ti40e_add_stat_strings(&data, i40e_gstrings_veb_tc_stats, i);\n\n\ti40e_add_stat_strings(&data, i40e_gstrings_stats);\n\n\tfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++)\n\t\ti40e_add_stat_strings(&data, i40e_gstrings_pfc_stats, i);\n\ncheck_data_pointer:\n\tWARN_ONCE(data - p != i40e_get_stats_count(netdev) * ETH_GSTRING_LEN,\n\t\t  \"stat strings count mismatch!\");\n}\n\nstatic void i40e_get_priv_flag_strings(struct net_device *netdev, u8 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tunsigned int i;\n\tu8 *p = data;\n\n\tfor (i = 0; i < I40E_PRIV_FLAGS_STR_LEN; i++)\n\t\tethtool_sprintf(&p, i40e_gstrings_priv_flags[i].flag_string);\n\tif (pf->hw.pf_id != 0)\n\t\treturn;\n\tfor (i = 0; i < I40E_GL_PRIV_FLAGS_STR_LEN; i++)\n\t\tethtool_sprintf(&p, i40e_gl_gstrings_priv_flags[i].flag_string);\n}\n\nstatic void i40e_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t     u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, i40e_gstrings_test,\n\t\t       I40E_TEST_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\ti40e_get_stat_strings(netdev, data);\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\ti40e_get_priv_flag_strings(netdev, data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int i40e_get_ts_info(struct net_device *dev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\n\n\t \n\tif (!(pf->flags & I40E_FLAG_PTP))\n\t\treturn ethtool_op_get_ts_info(dev, info);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tif (pf->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(pf->ptp_clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ);\n\n\tif (pf->hw_features & I40E_HW_PTP_L4_CAPABLE)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\n\t\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);\n\n\treturn 0;\n}\n\nstatic u64 i40e_link_test(struct net_device *netdev, u64 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tbool link_up = false;\n\tint status;\n\n\tnetif_info(pf, hw, netdev, \"link test\\n\");\n\tstatus = i40e_get_link_status(&pf->hw, &link_up);\n\tif (status) {\n\t\tnetif_err(pf, drv, netdev, \"link query timed out, please retry test\\n\");\n\t\t*data = 1;\n\t\treturn *data;\n\t}\n\n\tif (link_up)\n\t\t*data = 0;\n\telse\n\t\t*data = 1;\n\n\treturn *data;\n}\n\nstatic u64 i40e_reg_test(struct net_device *netdev, u64 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\n\tnetif_info(pf, hw, netdev, \"register test\\n\");\n\t*data = i40e_diag_reg_test(&pf->hw);\n\n\treturn *data;\n}\n\nstatic u64 i40e_eeprom_test(struct net_device *netdev, u64 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\n\tnetif_info(pf, hw, netdev, \"eeprom test\\n\");\n\t*data = i40e_diag_eeprom_test(&pf->hw);\n\n\t \n\tpf->hw.nvmupd_state = I40E_NVMUPD_STATE_INIT;\n\n\treturn *data;\n}\n\nstatic u64 i40e_intr_test(struct net_device *netdev, u64 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tu16 swc_old = pf->sw_int_count;\n\n\tnetif_info(pf, hw, netdev, \"interrupt test\\n\");\n\twr32(&pf->hw, I40E_PFINT_DYN_CTL0,\n\t     (I40E_PFINT_DYN_CTL0_INTENA_MASK |\n\t      I40E_PFINT_DYN_CTL0_SWINT_TRIG_MASK |\n\t      I40E_PFINT_DYN_CTL0_ITR_INDX_MASK |\n\t      I40E_PFINT_DYN_CTL0_SW_ITR_INDX_ENA_MASK |\n\t      I40E_PFINT_DYN_CTL0_SW_ITR_INDX_MASK));\n\tusleep_range(1000, 2000);\n\t*data = (swc_old == pf->sw_int_count);\n\n\treturn *data;\n}\n\nstatic inline bool i40e_active_vfs(struct i40e_pf *pf)\n{\n\tstruct i40e_vf *vfs = pf->vf;\n\tint i;\n\n\tfor (i = 0; i < pf->num_alloc_vfs; i++)\n\t\tif (test_bit(I40E_VF_STATE_ACTIVE, &vfs[i].vf_states))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool i40e_active_vmdqs(struct i40e_pf *pf)\n{\n\treturn !!i40e_find_vsi_by_type(pf, I40E_VSI_VMDQ2);\n}\n\nstatic void i40e_diag_test(struct net_device *netdev,\n\t\t\t   struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tbool if_running = netif_running(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\t \n\t\tnetif_info(pf, drv, netdev, \"offline testing starting\\n\");\n\n\t\tset_bit(__I40E_TESTING, pf->state);\n\n\t\tif (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||\n\t\t    test_bit(__I40E_RESET_INTR_RECEIVED, pf->state)) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Cannot start offline testing when PF is in reset state.\\n\");\n\t\t\tgoto skip_ol_tests;\n\t\t}\n\n\t\tif (i40e_active_vfs(pf) || i40e_active_vmdqs(pf)) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Please take active VFs and Netqueues offline and restart the adapter before running NIC diagnostics\\n\");\n\t\t\tgoto skip_ol_tests;\n\t\t}\n\n\t\t \n\t\tif (if_running)\n\t\t\t \n\t\t\ti40e_close(netdev);\n\t\telse\n\t\t\t \n\t\t\ti40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED), true);\n\n\t\tif (i40e_link_test(netdev, &data[I40E_ETH_TEST_LINK]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (i40e_eeprom_test(netdev, &data[I40E_ETH_TEST_EEPROM]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (i40e_intr_test(netdev, &data[I40E_ETH_TEST_INTR]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tif (i40e_reg_test(netdev, &data[I40E_ETH_TEST_REG]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tclear_bit(__I40E_TESTING, pf->state);\n\t\ti40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED), true);\n\n\t\tif (if_running)\n\t\t\ti40e_open(netdev);\n\t} else {\n\t\t \n\t\tnetif_info(pf, drv, netdev, \"online testing starting\\n\");\n\n\t\tif (i40e_link_test(netdev, &data[I40E_ETH_TEST_LINK]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tdata[I40E_ETH_TEST_REG] = 0;\n\t\tdata[I40E_ETH_TEST_EEPROM] = 0;\n\t\tdata[I40E_ETH_TEST_INTR] = 0;\n\t}\n\n\tnetif_info(pf, drv, netdev, \"testing finished\\n\");\n\treturn;\n\nskip_ol_tests:\n\tdata[I40E_ETH_TEST_REG]\t\t= 1;\n\tdata[I40E_ETH_TEST_EEPROM]\t= 1;\n\tdata[I40E_ETH_TEST_INTR]\t= 1;\n\tdata[I40E_ETH_TEST_LINK]\t= 1;\n\teth_test->flags |= ETH_TEST_FL_FAILED;\n\tclear_bit(__I40E_TESTING, pf->state);\n\tnetif_info(pf, drv, netdev, \"testing failed\\n\");\n}\n\nstatic void i40e_get_wol(struct net_device *netdev,\n\t\t\t struct ethtool_wolinfo *wol)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 wol_nvm_bits;\n\n\t \n\ti40e_read_nvm_word(hw, I40E_SR_NVM_WAKE_ON_LAN, &wol_nvm_bits);\n\tif ((BIT(hw->port) & wol_nvm_bits) || (hw->partition_id != 1)) {\n\t\twol->supported = 0;\n\t\twol->wolopts = 0;\n\t} else {\n\t\twol->supported = WAKE_MAGIC;\n\t\twol->wolopts = (pf->wol_en ? WAKE_MAGIC : 0);\n\t}\n}\n\n \nstatic int i40e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 wol_nvm_bits;\n\n\t \n\tif (hw->partition_id != 1) {\n\t\ti40e_partition_setting_complaint(pf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vsi != pf->vsi[pf->lan_vsi])\n\t\treturn -EOPNOTSUPP;\n\n\t \n\ti40e_read_nvm_word(hw, I40E_SR_NVM_WAKE_ON_LAN, &wol_nvm_bits);\n\tif (BIT(hw->port) & wol_nvm_bits)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (pf->wol_en != !!wol->wolopts) {\n\t\tpf->wol_en = !!wol->wolopts;\n\t\tdevice_set_wakeup_enable(&pf->pdev->dev, pf->wol_en);\n\t}\n\n\treturn 0;\n}\n\nstatic int i40e_set_phys_id(struct net_device *netdev,\n\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint blink_freq = 2;\n\tu16 temp_status;\n\tint ret = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tif (!(pf->hw_features & I40E_HW_PHY_CONTROLS_LEDS)) {\n\t\t\tpf->led_status = i40e_led_get(hw);\n\t\t} else {\n\t\t\tif (!(hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE))\n\t\t\t\ti40e_aq_set_phy_debug(hw, I40E_PHY_DEBUG_ALL,\n\t\t\t\t\t\t      NULL);\n\t\t\tret = i40e_led_get_phy(hw, &temp_status,\n\t\t\t\t\t       &pf->phy_led_val);\n\t\t\tpf->led_status = temp_status;\n\t\t}\n\t\treturn blink_freq;\n\tcase ETHTOOL_ID_ON:\n\t\tif (!(pf->hw_features & I40E_HW_PHY_CONTROLS_LEDS))\n\t\t\ti40e_led_set(hw, 0xf, false);\n\t\telse\n\t\t\tret = i40e_led_set_phy(hw, true, pf->led_status, 0);\n\t\tbreak;\n\tcase ETHTOOL_ID_OFF:\n\t\tif (!(pf->hw_features & I40E_HW_PHY_CONTROLS_LEDS))\n\t\t\ti40e_led_set(hw, 0x0, false);\n\t\telse\n\t\t\tret = i40e_led_set_phy(hw, false, pf->led_status, 0);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tif (!(pf->hw_features & I40E_HW_PHY_CONTROLS_LEDS)) {\n\t\t\ti40e_led_set(hw, pf->led_status, false);\n\t\t} else {\n\t\t\tret = i40e_led_set_phy(hw, false, pf->led_status,\n\t\t\t\t\t       (pf->phy_led_val |\n\t\t\t\t\t       I40E_PHY_LED_MODE_ORIG));\n\t\t\tif (!(hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE))\n\t\t\t\ti40e_aq_set_phy_debug(hw, 0, NULL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ret)\n\t\treturn -ENOENT;\n\telse\n\t\treturn 0;\n}\n\n \n\n \nstatic int __i40e_get_coalesce(struct net_device *netdev,\n\t\t\t       struct ethtool_coalesce *ec,\n\t\t\t       int queue)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_ring *rx_ring, *tx_ring;\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\tec->tx_max_coalesced_frames_irq = vsi->work_limit;\n\tec->rx_max_coalesced_frames_irq = vsi->work_limit;\n\n\t \n\tif (queue < 0)\n\t\tqueue = 0;\n\telse if (queue >= vsi->num_queue_pairs)\n\t\treturn -EINVAL;\n\n\trx_ring = vsi->rx_rings[queue];\n\ttx_ring = vsi->tx_rings[queue];\n\n\tif (ITR_IS_DYNAMIC(rx_ring->itr_setting))\n\t\tec->use_adaptive_rx_coalesce = 1;\n\n\tif (ITR_IS_DYNAMIC(tx_ring->itr_setting))\n\t\tec->use_adaptive_tx_coalesce = 1;\n\n\tec->rx_coalesce_usecs = rx_ring->itr_setting & ~I40E_ITR_DYNAMIC;\n\tec->tx_coalesce_usecs = tx_ring->itr_setting & ~I40E_ITR_DYNAMIC;\n\n\t \n\tec->rx_coalesce_usecs_high = vsi->int_rate_limit;\n\tec->tx_coalesce_usecs_high = vsi->int_rate_limit;\n\n\treturn 0;\n}\n\n \nstatic int i40e_get_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ec,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn __i40e_get_coalesce(netdev, ec, -1);\n}\n\n \nstatic int i40e_get_per_queue_coalesce(struct net_device *netdev, u32 queue,\n\t\t\t\t       struct ethtool_coalesce *ec)\n{\n\treturn __i40e_get_coalesce(netdev, ec, queue);\n}\n\n \nstatic void i40e_set_itr_per_queue(struct i40e_vsi *vsi,\n\t\t\t\t   struct ethtool_coalesce *ec,\n\t\t\t\t   int queue)\n{\n\tstruct i40e_ring *rx_ring = vsi->rx_rings[queue];\n\tstruct i40e_ring *tx_ring = vsi->tx_rings[queue];\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_q_vector *q_vector;\n\tu16 intrl;\n\n\tintrl = i40e_intrl_usec_to_reg(vsi->int_rate_limit);\n\n\trx_ring->itr_setting = ITR_REG_ALIGN(ec->rx_coalesce_usecs);\n\ttx_ring->itr_setting = ITR_REG_ALIGN(ec->tx_coalesce_usecs);\n\n\tif (ec->use_adaptive_rx_coalesce)\n\t\trx_ring->itr_setting |= I40E_ITR_DYNAMIC;\n\telse\n\t\trx_ring->itr_setting &= ~I40E_ITR_DYNAMIC;\n\n\tif (ec->use_adaptive_tx_coalesce)\n\t\ttx_ring->itr_setting |= I40E_ITR_DYNAMIC;\n\telse\n\t\ttx_ring->itr_setting &= ~I40E_ITR_DYNAMIC;\n\n\tq_vector = rx_ring->q_vector;\n\tq_vector->rx.target_itr = ITR_TO_REG(rx_ring->itr_setting);\n\n\tq_vector = tx_ring->q_vector;\n\tq_vector->tx.target_itr = ITR_TO_REG(tx_ring->itr_setting);\n\n\t \n\n\twr32(hw, I40E_PFINT_RATEN(q_vector->reg_idx), intrl);\n\ti40e_flush(hw);\n}\n\n \nstatic int __i40e_set_coalesce(struct net_device *netdev,\n\t\t\t       struct ethtool_coalesce *ec,\n\t\t\t       int queue)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tu16 intrl_reg, cur_rx_itr, cur_tx_itr;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tint i;\n\n\tif (ec->tx_max_coalesced_frames_irq || ec->rx_max_coalesced_frames_irq)\n\t\tvsi->work_limit = ec->tx_max_coalesced_frames_irq;\n\n\tif (queue < 0) {\n\t\tcur_rx_itr = vsi->rx_rings[0]->itr_setting;\n\t\tcur_tx_itr = vsi->tx_rings[0]->itr_setting;\n\t} else if (queue < vsi->num_queue_pairs) {\n\t\tcur_rx_itr = vsi->rx_rings[queue]->itr_setting;\n\t\tcur_tx_itr = vsi->tx_rings[queue]->itr_setting;\n\t} else {\n\t\tnetif_info(pf, drv, netdev, \"Invalid queue value, queue range is 0 - %d\\n\",\n\t\t\t   vsi->num_queue_pairs - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tcur_tx_itr &= ~I40E_ITR_DYNAMIC;\n\tcur_rx_itr &= ~I40E_ITR_DYNAMIC;\n\n\t \n\tif (ec->tx_coalesce_usecs_high != vsi->int_rate_limit) {\n\t\tnetif_info(pf, drv, netdev, \"tx-usecs-high is not used, please program rx-usecs-high\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ec->rx_coalesce_usecs_high > INTRL_REG_TO_USEC(I40E_MAX_INTRL)) {\n\t\tnetif_info(pf, drv, netdev, \"Invalid value, rx-usecs-high range is 0-%lu\\n\",\n\t\t\t   INTRL_REG_TO_USEC(I40E_MAX_INTRL));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ec->rx_coalesce_usecs != cur_rx_itr &&\n\t    ec->use_adaptive_rx_coalesce) {\n\t\tnetif_info(pf, drv, netdev, \"RX interrupt moderation cannot be changed if adaptive-rx is enabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ec->rx_coalesce_usecs > I40E_MAX_ITR) {\n\t\tnetif_info(pf, drv, netdev, \"Invalid value, rx-usecs range is 0-8160\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ec->tx_coalesce_usecs != cur_tx_itr &&\n\t    ec->use_adaptive_tx_coalesce) {\n\t\tnetif_info(pf, drv, netdev, \"TX interrupt moderation cannot be changed if adaptive-tx is enabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ec->tx_coalesce_usecs > I40E_MAX_ITR) {\n\t\tnetif_info(pf, drv, netdev, \"Invalid value, tx-usecs range is 0-8160\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ec->use_adaptive_rx_coalesce && !cur_rx_itr)\n\t\tec->rx_coalesce_usecs = I40E_MIN_ITR;\n\n\tif (ec->use_adaptive_tx_coalesce && !cur_tx_itr)\n\t\tec->tx_coalesce_usecs = I40E_MIN_ITR;\n\n\tintrl_reg = i40e_intrl_usec_to_reg(ec->rx_coalesce_usecs_high);\n\tvsi->int_rate_limit = INTRL_REG_TO_USEC(intrl_reg);\n\tif (vsi->int_rate_limit != ec->rx_coalesce_usecs_high) {\n\t\tnetif_info(pf, drv, netdev, \"Interrupt rate limit rounded down to %d\\n\",\n\t\t\t   vsi->int_rate_limit);\n\t}\n\n\t \n\tif (queue < 0) {\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++)\n\t\t\ti40e_set_itr_per_queue(vsi, ec, i);\n\t} else {\n\t\ti40e_set_itr_per_queue(vsi, ec, queue);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_set_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ec,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn __i40e_set_coalesce(netdev, ec, -1);\n}\n\n \nstatic int i40e_set_per_queue_coalesce(struct net_device *netdev, u32 queue,\n\t\t\t\t       struct ethtool_coalesce *ec)\n{\n\treturn __i40e_set_coalesce(netdev, ec, queue);\n}\n\n \nstatic int i40e_get_rss_hash_opts(struct i40e_pf *pf, struct ethtool_rxnfc *cmd)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu8 flow_pctype = 0;\n\tu64 i_set = 0;\n\n\tcmd->data = 0;\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tflow_pctype = I40E_FILTER_PCTYPE_NONF_IPV4_TCP;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tflow_pctype = I40E_FILTER_PCTYPE_NONF_IPV4_UDP;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tflow_pctype = I40E_FILTER_PCTYPE_NONF_IPV6_TCP;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tflow_pctype = I40E_FILTER_PCTYPE_NONF_IPV6_UDP;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\t \n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (flow_pctype) {\n\t\ti_set = (u64)i40e_read_rx_ctl(hw, I40E_GLQF_HASH_INSET(0,\n\t\t\t\t\t      flow_pctype)) |\n\t\t\t((u64)i40e_read_rx_ctl(hw, I40E_GLQF_HASH_INSET(1,\n\t\t\t\t\t       flow_pctype)) << 32);\n\t}\n\n\t \n\tif (i_set) {\n\t\tif (i_set & I40E_L4_SRC_MASK)\n\t\t\tcmd->data |= RXH_L4_B_0_1;\n\t\tif (i_set & I40E_L4_DST_MASK)\n\t\t\tcmd->data |= RXH_L4_B_2_3;\n\n\t\tif (cmd->flow_type == TCP_V4_FLOW ||\n\t\t    cmd->flow_type == UDP_V4_FLOW) {\n\t\t\tif (hw->mac.type == I40E_MAC_X722) {\n\t\t\t\tif (i_set & I40E_X722_L3_SRC_MASK)\n\t\t\t\t\tcmd->data |= RXH_IP_SRC;\n\t\t\t\tif (i_set & I40E_X722_L3_DST_MASK)\n\t\t\t\t\tcmd->data |= RXH_IP_DST;\n\t\t\t} else {\n\t\t\t\tif (i_set & I40E_L3_SRC_MASK)\n\t\t\t\t\tcmd->data |= RXH_IP_SRC;\n\t\t\t\tif (i_set & I40E_L3_DST_MASK)\n\t\t\t\t\tcmd->data |= RXH_IP_DST;\n\t\t\t}\n\t\t} else if (cmd->flow_type == TCP_V6_FLOW ||\n\t\t\t  cmd->flow_type == UDP_V6_FLOW) {\n\t\t\tif (i_set & I40E_L3_V6_SRC_MASK)\n\t\t\t\tcmd->data |= RXH_IP_SRC;\n\t\t\tif (i_set & I40E_L3_V6_DST_MASK)\n\t\t\t\tcmd->data |= RXH_IP_DST;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_check_mask(u64 mask, u64 field)\n{\n\tu64 value = mask & field;\n\n\tif (value == field)\n\t\treturn 1;\n\telse if (!value)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\n \nstatic int i40e_parse_rx_flow_user_data(struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t\tstruct i40e_rx_flow_userdef *data)\n{\n\tu64 value, mask;\n\tint valid;\n\n\t \n\tmemset(data, 0, sizeof(*data));\n\n\tif (!(fsp->flow_type & FLOW_EXT))\n\t\treturn 0;\n\n\tvalue = be64_to_cpu(*((__be64 *)fsp->h_ext.data));\n\tmask = be64_to_cpu(*((__be64 *)fsp->m_ext.data));\n\n#define I40E_USERDEF_FLEX_WORD\t\tGENMASK_ULL(15, 0)\n#define I40E_USERDEF_FLEX_OFFSET\tGENMASK_ULL(31, 16)\n#define I40E_USERDEF_FLEX_FILTER\tGENMASK_ULL(31, 0)\n\n\tvalid = i40e_check_mask(mask, I40E_USERDEF_FLEX_FILTER);\n\tif (valid < 0) {\n\t\treturn -EINVAL;\n\t} else if (valid) {\n\t\tdata->flex_word = value & I40E_USERDEF_FLEX_WORD;\n\t\tdata->flex_offset =\n\t\t\t(value & I40E_USERDEF_FLEX_OFFSET) >> 16;\n\t\tdata->flex_filter = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void i40e_fill_rx_flow_user_data(struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t\tstruct i40e_rx_flow_userdef *data)\n{\n\tu64 value = 0, mask = 0;\n\n\tif (data->flex_filter) {\n\t\tvalue |= data->flex_word;\n\t\tvalue |= (u64)data->flex_offset << 16;\n\t\tmask |= I40E_USERDEF_FLEX_FILTER;\n\t}\n\n\tif (value || mask)\n\t\tfsp->flow_type |= FLOW_EXT;\n\n\t*((__be64 *)fsp->h_ext.data) = cpu_to_be64(value);\n\t*((__be64 *)fsp->m_ext.data) = cpu_to_be64(mask);\n}\n\n \nstatic int i40e_get_ethtool_fdir_all(struct i40e_pf *pf,\n\t\t\t\t     struct ethtool_rxnfc *cmd,\n\t\t\t\t     u32 *rule_locs)\n{\n\tstruct i40e_fdir_filter *rule;\n\tstruct hlist_node *node2;\n\tint cnt = 0;\n\n\t \n\tcmd->data = i40e_get_fd_cnt_all(pf);\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\tif (cnt == cmd->rule_cnt)\n\t\t\treturn -EMSGSIZE;\n\n\t\trule_locs[cnt] = rule->fd_id;\n\t\tcnt++;\n\t}\n\n\tcmd->rule_cnt = cnt;\n\n\treturn 0;\n}\n\n \nstatic int i40e_get_ethtool_fdir_entry(struct i40e_pf *pf,\n\t\t\t\t       struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct i40e_rx_flow_userdef userdef = {0};\n\tstruct i40e_fdir_filter *rule = NULL;\n\tstruct hlist_node *node2;\n\tu64 input_set;\n\tu16 index;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\tif (fsp->location <= rule->fd_id)\n\t\t\tbreak;\n\t}\n\n\tif (!rule || fsp->location != rule->fd_id)\n\t\treturn -EINVAL;\n\n\tfsp->flow_type = rule->flow_type;\n\tif (fsp->flow_type == IP_USER_FLOW) {\n\t\tfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\n\t\tfsp->h_u.usr_ip4_spec.proto = 0;\n\t\tfsp->m_u.usr_ip4_spec.proto = 0;\n\t}\n\n\tif (fsp->flow_type == IPV6_USER_FLOW ||\n\t    fsp->flow_type == UDP_V6_FLOW ||\n\t    fsp->flow_type == TCP_V6_FLOW ||\n\t    fsp->flow_type == SCTP_V6_FLOW) {\n\t\t \n\t\tfsp->h_u.tcp_ip6_spec.psrc = rule->dst_port;\n\t\tfsp->h_u.tcp_ip6_spec.pdst = rule->src_port;\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6dst, rule->src_ip6,\n\t\t       sizeof(__be32) * 4);\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6src, rule->dst_ip6,\n\t\t       sizeof(__be32) * 4);\n\t} else {\n\t\t \n\t\tfsp->h_u.tcp_ip4_spec.psrc = rule->dst_port;\n\t\tfsp->h_u.tcp_ip4_spec.pdst = rule->src_port;\n\t\tfsp->h_u.tcp_ip4_spec.ip4src = rule->dst_ip;\n\t\tfsp->h_u.tcp_ip4_spec.ip4dst = rule->src_ip;\n\t}\n\n\tswitch (rule->flow_type) {\n\tcase SCTP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_SCTP;\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_TCP;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_UDP;\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_SCTP;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_TCP;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_UDP;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_OTHER;\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_OTHER;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN(1, \"Missing input set index for flow_type %d\\n\",\n\t\t     rule->flow_type);\n\t\tinput_set = 0xFFFFFFFFFFFFFFFFULL;\n\t\tgoto no_input_set;\n\t}\n\n\tinput_set = i40e_read_fd_input_set(pf, index);\n\nno_input_set:\n\tif (input_set & I40E_L3_V6_SRC_MASK) {\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[0] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[1] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[2] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[3] = htonl(0xFFFFFFFF);\n\t}\n\n\tif (input_set & I40E_L3_V6_DST_MASK) {\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[0] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[1] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[2] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[3] = htonl(0xFFFFFFFF);\n\t}\n\n\tif (input_set & I40E_L3_SRC_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.ip4src = htonl(0xFFFFFFFF);\n\n\tif (input_set & I40E_L3_DST_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.ip4dst = htonl(0xFFFFFFFF);\n\n\tif (input_set & I40E_L4_SRC_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.psrc = htons(0xFFFF);\n\n\tif (input_set & I40E_L4_DST_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.pdst = htons(0xFFFF);\n\n\tif (rule->dest_ctl == I40E_FILTER_PROGRAM_DESC_DEST_DROP_PACKET)\n\t\tfsp->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfsp->ring_cookie = rule->q_index;\n\n\tif (rule->vlan_tag) {\n\t\tfsp->h_ext.vlan_etype = rule->vlan_etype;\n\t\tfsp->m_ext.vlan_etype = htons(0xFFFF);\n\t\tfsp->h_ext.vlan_tci = rule->vlan_tag;\n\t\tfsp->m_ext.vlan_tci = htons(0xFFFF);\n\t\tfsp->flow_type |= FLOW_EXT;\n\t}\n\n\tif (rule->dest_vsi != pf->vsi[pf->lan_vsi]->id) {\n\t\tstruct i40e_vsi *vsi;\n\n\t\tvsi = i40e_find_vsi_from_id(pf, rule->dest_vsi);\n\t\tif (vsi && vsi->type == I40E_VSI_SRIOV) {\n\t\t\t \n\t\t\tu64 ring_vf = vsi->vf_id + 1;\n\n\t\t\tring_vf <<= ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;\n\t\t\tfsp->ring_cookie |= ring_vf;\n\t\t}\n\t}\n\n\tif (rule->flex_filter) {\n\t\tuserdef.flex_filter = true;\n\t\tuserdef.flex_word = be16_to_cpu(rule->flex_word);\n\t\tuserdef.flex_offset = rule->flex_offset;\n\t}\n\n\ti40e_fill_rx_flow_user_data(fsp, &userdef);\n\n\treturn 0;\n}\n\n \nstatic int i40e_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd,\n\t\t\t  u32 *rule_locs)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = vsi->rss_size;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\tret = i40e_get_rss_hash_opts(pf, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = pf->fdir_pf_active_filters;\n\t\t \n\t\tcmd->data = i40e_get_fd_cnt_all(pf);\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = i40e_get_ethtool_fdir_entry(pf, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tret = i40e_get_ethtool_fdir_all(pf, cmd, rule_locs);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic u64 i40e_get_rss_hash_bits(struct i40e_hw *hw,\n\t\t\t\t  struct ethtool_rxnfc *nfc,\n\t\t\t\t  u64 i_setc)\n{\n\tu64 i_set = i_setc;\n\tu64 src_l3 = 0, dst_l3 = 0;\n\n\tif (nfc->data & RXH_L4_B_0_1)\n\t\ti_set |= I40E_L4_SRC_MASK;\n\telse\n\t\ti_set &= ~I40E_L4_SRC_MASK;\n\tif (nfc->data & RXH_L4_B_2_3)\n\t\ti_set |= I40E_L4_DST_MASK;\n\telse\n\t\ti_set &= ~I40E_L4_DST_MASK;\n\n\tif (nfc->flow_type == TCP_V6_FLOW || nfc->flow_type == UDP_V6_FLOW) {\n\t\tsrc_l3 = I40E_L3_V6_SRC_MASK;\n\t\tdst_l3 = I40E_L3_V6_DST_MASK;\n\t} else if (nfc->flow_type == TCP_V4_FLOW ||\n\t\t  nfc->flow_type == UDP_V4_FLOW) {\n\t\tif (hw->mac.type == I40E_MAC_X722) {\n\t\t\tsrc_l3 = I40E_X722_L3_SRC_MASK;\n\t\t\tdst_l3 = I40E_X722_L3_DST_MASK;\n\t\t} else {\n\t\t\tsrc_l3 = I40E_L3_SRC_MASK;\n\t\t\tdst_l3 = I40E_L3_DST_MASK;\n\t\t}\n\t} else {\n\t\t \n\t\treturn i_set;\n\t}\n\n\tif (nfc->data & RXH_IP_SRC)\n\t\ti_set |= src_l3;\n\telse\n\t\ti_set &= ~src_l3;\n\tif (nfc->data & RXH_IP_DST)\n\t\ti_set |= dst_l3;\n\telse\n\t\ti_set &= ~dst_l3;\n\n\treturn i_set;\n}\n\n#define FLOW_PCTYPES_SIZE 64\n \nstatic int i40e_set_rss_hash_opt(struct i40e_pf *pf, struct ethtool_rxnfc *nfc)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu64 hena = (u64)i40e_read_rx_ctl(hw, I40E_PFQF_HENA(0)) |\n\t\t   ((u64)i40e_read_rx_ctl(hw, I40E_PFQF_HENA(1)) << 32);\n\tDECLARE_BITMAP(flow_pctypes, FLOW_PCTYPES_SIZE);\n\tu64 i_set, i_setc;\n\n\tbitmap_zero(flow_pctypes, FLOW_PCTYPES_SIZE);\n\n\tif (pf->flags & I40E_FLAG_MFP_ENABLED) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Change of RSS hash input set is not supported when MFP mode is enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tset_bit(I40E_FILTER_PCTYPE_NONF_IPV4_TCP, flow_pctypes);\n\t\tif (pf->hw_features & I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE)\n\t\t\tset_bit(I40E_FILTER_PCTYPE_NONF_IPV4_TCP_SYN_NO_ACK,\n\t\t\t\tflow_pctypes);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tset_bit(I40E_FILTER_PCTYPE_NONF_IPV6_TCP, flow_pctypes);\n\t\tif (pf->hw_features & I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE)\n\t\t\tset_bit(I40E_FILTER_PCTYPE_NONF_IPV6_TCP_SYN_NO_ACK,\n\t\t\t\tflow_pctypes);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tset_bit(I40E_FILTER_PCTYPE_NONF_IPV4_UDP, flow_pctypes);\n\t\tif (pf->hw_features & I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE) {\n\t\t\tset_bit(I40E_FILTER_PCTYPE_NONF_UNICAST_IPV4_UDP,\n\t\t\t\tflow_pctypes);\n\t\t\tset_bit(I40E_FILTER_PCTYPE_NONF_MULTICAST_IPV4_UDP,\n\t\t\t\tflow_pctypes);\n\t\t}\n\t\thena |= BIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV4);\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tset_bit(I40E_FILTER_PCTYPE_NONF_IPV6_UDP, flow_pctypes);\n\t\tif (pf->hw_features & I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE) {\n\t\t\tset_bit(I40E_FILTER_PCTYPE_NONF_UNICAST_IPV6_UDP,\n\t\t\t\tflow_pctypes);\n\t\t\tset_bit(I40E_FILTER_PCTYPE_NONF_MULTICAST_IPV6_UDP,\n\t\t\t\tflow_pctypes);\n\t\t}\n\t\thena |= BIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV6);\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tif ((nfc->data & RXH_L4_B_0_1) ||\n\t\t    (nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\thena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_OTHER);\n\t\tbreak;\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tif ((nfc->data & RXH_L4_B_0_1) ||\n\t\t    (nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\thena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_OTHER);\n\t\tbreak;\n\tcase IPV4_FLOW:\n\t\thena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_OTHER) |\n\t\t\tBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV4);\n\t\tbreak;\n\tcase IPV6_FLOW:\n\t\thena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_OTHER) |\n\t\t\tBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV6);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (bitmap_weight(flow_pctypes, FLOW_PCTYPES_SIZE)) {\n\t\tu8 flow_id;\n\n\t\tfor_each_set_bit(flow_id, flow_pctypes, FLOW_PCTYPES_SIZE) {\n\t\t\ti_setc = (u64)i40e_read_rx_ctl(hw, I40E_GLQF_HASH_INSET(0, flow_id)) |\n\t\t\t\t ((u64)i40e_read_rx_ctl(hw, I40E_GLQF_HASH_INSET(1, flow_id)) << 32);\n\t\t\ti_set = i40e_get_rss_hash_bits(&pf->hw, nfc, i_setc);\n\n\t\t\ti40e_write_rx_ctl(hw, I40E_GLQF_HASH_INSET(0, flow_id),\n\t\t\t\t\t  (u32)i_set);\n\t\t\ti40e_write_rx_ctl(hw, I40E_GLQF_HASH_INSET(1, flow_id),\n\t\t\t\t\t  (u32)(i_set >> 32));\n\t\t\thena |= BIT_ULL(flow_id);\n\t\t}\n\t}\n\n\ti40e_write_rx_ctl(hw, I40E_PFQF_HENA(0), (u32)hena);\n\ti40e_write_rx_ctl(hw, I40E_PFQF_HENA(1), (u32)(hena >> 32));\n\ti40e_flush(hw);\n\n\treturn 0;\n}\n\n \nstatic int i40e_update_ethtool_fdir_entry(struct i40e_vsi *vsi,\n\t\t\t\t\t  struct i40e_fdir_filter *input,\n\t\t\t\t\t  u16 sw_idx,\n\t\t\t\t\t  struct ethtool_rxnfc *cmd)\n{\n\tstruct i40e_fdir_filter *rule, *parent;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct hlist_node *node2;\n\tint err = -EINVAL;\n\n\tparent = NULL;\n\trule = NULL;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\t \n\t\tif (rule->fd_id >= sw_idx)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\t \n\tif (rule && (rule->fd_id == sw_idx)) {\n\t\t \n\t\terr = i40e_add_del_fdir(vsi, rule, false);\n\t\thlist_del(&rule->fdir_node);\n\t\tkfree(rule);\n\t\tpf->fdir_pf_active_filters--;\n\t}\n\n\t \n\tif (!input)\n\t\treturn err;\n\n\t \n\tINIT_HLIST_NODE(&input->fdir_node);\n\n\t \n\tif (parent)\n\t\thlist_add_behind(&input->fdir_node, &parent->fdir_node);\n\telse\n\t\thlist_add_head(&input->fdir_node,\n\t\t\t       &pf->fdir_filter_list);\n\n\t \n\tpf->fdir_pf_active_filters++;\n\n\treturn 0;\n}\n\n \nstatic void i40e_prune_flex_pit_list(struct i40e_pf *pf)\n{\n\tstruct i40e_flex_pit *entry, *tmp;\n\tstruct i40e_fdir_filter *rule;\n\n\t \n\tlist_for_each_entry_safe(entry, tmp, &pf->l3_flex_pit_list, list) {\n\t\tbool found = false;\n\n\t\thlist_for_each_entry(rule, &pf->fdir_filter_list, fdir_node) {\n\t\t\tif (rule->flow_type != IP_USER_FLOW)\n\t\t\t\tcontinue;\n\t\t\tif (rule->flex_filter &&\n\t\t\t    rule->flex_offset == entry->src_offset) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!found) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(entry, tmp, &pf->l4_flex_pit_list, list) {\n\t\tbool found = false;\n\n\t\thlist_for_each_entry(rule, &pf->fdir_filter_list, fdir_node) {\n\t\t\t \n\t\t\tif (rule->flow_type == IP_USER_FLOW)\n\t\t\t\tcontinue;\n\t\t\tif (rule->flex_filter &&\n\t\t\t    rule->flex_offset == entry->src_offset) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!found) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n}\n\n \nstatic int i40e_del_fdir_entry(struct i40e_vsi *vsi,\n\t\t\t       struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct i40e_pf *pf = vsi->back;\n\tint ret = 0;\n\n\tif (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||\n\t    test_bit(__I40E_RESET_INTR_RECEIVED, pf->state))\n\t\treturn -EBUSY;\n\n\tif (test_bit(__I40E_FD_FLUSH_REQUESTED, pf->state))\n\t\treturn -EBUSY;\n\n\tret = i40e_update_ethtool_fdir_entry(vsi, NULL, fsp->location, cmd);\n\n\ti40e_prune_flex_pit_list(pf);\n\n\ti40e_fdir_check_and_reenable(pf);\n\treturn ret;\n}\n\n \nstatic u8 i40e_unused_pit_index(struct i40e_pf *pf)\n{\n\tunsigned long available_index = 0xFF;\n\tstruct i40e_flex_pit *entry;\n\n\t \n\n\tlist_for_each_entry(entry, &pf->l4_flex_pit_list, list)\n\t\tclear_bit(entry->pit_index, &available_index);\n\n\tlist_for_each_entry(entry, &pf->l3_flex_pit_list, list)\n\t\tclear_bit(entry->pit_index, &available_index);\n\n\treturn find_first_bit(&available_index, 8);\n}\n\n \nstatic\nstruct i40e_flex_pit *i40e_find_flex_offset(struct list_head *flex_pit_list,\n\t\t\t\t\t    u16 src_offset)\n{\n\tstruct i40e_flex_pit *entry;\n\tint size = 0;\n\n\t \n\tlist_for_each_entry(entry, flex_pit_list, list) {\n\t\tsize++;\n\t\tif (entry->src_offset == src_offset)\n\t\t\treturn entry;\n\t}\n\n\t \n\tif (size >= I40E_FLEX_PIT_TABLE_SIZE)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\treturn NULL;\n}\n\n \nstatic int i40e_add_flex_offset(struct list_head *flex_pit_list,\n\t\t\t\tu16 src_offset,\n\t\t\t\tu8 pit_index)\n{\n\tstruct i40e_flex_pit *new_pit, *entry;\n\n\tnew_pit = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!new_pit)\n\t\treturn -ENOMEM;\n\n\tnew_pit->src_offset = src_offset;\n\tnew_pit->pit_index = pit_index;\n\n\t \n\tlist_for_each_entry(entry, flex_pit_list, list) {\n\t\tif (new_pit->src_offset < entry->src_offset) {\n\t\t\tlist_add_tail(&new_pit->list, &entry->list);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (new_pit->src_offset == entry->src_offset) {\n\t\t\tint err = 0;\n\n\t\t\t \n\t\t\tif (new_pit->pit_index != entry->pit_index)\n\t\t\t\terr = -EINVAL;\n\n\t\t\tkfree(new_pit);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tlist_add_tail(&new_pit->list, flex_pit_list);\n\treturn 0;\n}\n\n \nstatic void __i40e_reprogram_flex_pit(struct i40e_pf *pf,\n\t\t\t\t      struct list_head *flex_pit_list,\n\t\t\t\t      int flex_pit_start)\n{\n\tstruct i40e_flex_pit *entry = NULL;\n\tu16 last_offset = 0;\n\tint i = 0, j = 0;\n\n\t \n\tlist_for_each_entry(entry, flex_pit_list, list) {\n\t\t \n\t\tfor (j = i + 1; j < 3; j++) {\n\t\t\tu16 offset = entry->src_offset + j;\n\t\t\tint index = flex_pit_start + i;\n\t\t\tu32 value = I40E_FLEX_PREP_VAL(I40E_FLEX_DEST_UNUSED,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       offset - 3);\n\n\t\t\tif (offset > I40E_MAX_FLEX_SRC_OFFSET) {\n\t\t\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t\t\t  I40E_PRTQF_FLX_PIT(index),\n\t\t\t\t\t\t  value);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t  I40E_PRTQF_FLX_PIT(flex_pit_start + i),\n\t\t\t\t  I40E_FLEX_PREP_VAL(entry->pit_index + 50,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     entry->src_offset));\n\t\ti++;\n\t}\n\n\t \n\tif (!list_empty(flex_pit_list))\n\t\tlast_offset = list_prev_entry(entry, list)->src_offset + 1;\n\n\tfor (; i < 3; i++, last_offset++) {\n\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t  I40E_PRTQF_FLX_PIT(flex_pit_start + i),\n\t\t\t\t  I40E_FLEX_PREP_VAL(I40E_FLEX_DEST_UNUSED,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     last_offset));\n\t}\n}\n\n \nstatic void i40e_reprogram_flex_pit(struct i40e_pf *pf)\n{\n\t__i40e_reprogram_flex_pit(pf, &pf->l3_flex_pit_list,\n\t\t\t\t  I40E_FLEX_PIT_IDX_START_L3);\n\n\t__i40e_reprogram_flex_pit(pf, &pf->l4_flex_pit_list,\n\t\t\t\t  I40E_FLEX_PIT_IDX_START_L4);\n\n\t \n\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t  I40E_GLQF_ORT(I40E_L3_GLQF_ORT_IDX),\n\t\t\t  I40E_ORT_PREP_VAL(I40E_FLEX_PIT_IDX_START_L3,\n\t\t\t\t\t    3, 1));\n\n\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t  I40E_GLQF_ORT(I40E_L4_GLQF_ORT_IDX),\n\t\t\t  I40E_ORT_PREP_VAL(I40E_FLEX_PIT_IDX_START_L4,\n\t\t\t\t\t    3, 1));\n}\n\n \nstatic const char *i40e_flow_str(struct ethtool_rx_flow_spec *fsp)\n{\n\tswitch (fsp->flow_type & ~FLOW_EXT) {\n\tcase TCP_V4_FLOW:\n\t\treturn \"tcp4\";\n\tcase UDP_V4_FLOW:\n\t\treturn \"udp4\";\n\tcase SCTP_V4_FLOW:\n\t\treturn \"sctp4\";\n\tcase IP_USER_FLOW:\n\t\treturn \"ip4\";\n\tcase TCP_V6_FLOW:\n\t\treturn \"tcp6\";\n\tcase UDP_V6_FLOW:\n\t\treturn \"udp6\";\n\tcase SCTP_V6_FLOW:\n\t\treturn \"sctp6\";\n\tcase IPV6_USER_FLOW:\n\t\treturn \"ip6\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n \nstatic u64 i40e_pit_index_to_mask(int pit_index)\n{\n\tswitch (pit_index) {\n\tcase 0:\n\t\treturn I40E_FLEX_50_MASK;\n\tcase 1:\n\t\treturn I40E_FLEX_51_MASK;\n\tcase 2:\n\t\treturn I40E_FLEX_52_MASK;\n\tcase 3:\n\t\treturn I40E_FLEX_53_MASK;\n\tcase 4:\n\t\treturn I40E_FLEX_54_MASK;\n\tcase 5:\n\t\treturn I40E_FLEX_55_MASK;\n\tcase 6:\n\t\treturn I40E_FLEX_56_MASK;\n\tcase 7:\n\t\treturn I40E_FLEX_57_MASK;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic void i40e_print_input_set(struct i40e_vsi *vsi, u64 old, u64 new)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tbool old_value, new_value;\n\tint i;\n\n\told_value = !!(old & I40E_L3_SRC_MASK);\n\tnew_value = !!(new & I40E_L3_SRC_MASK);\n\tif (old_value != new_value)\n\t\tnetif_info(pf, drv, vsi->netdev, \"L3 source address: %s -> %s\\n\",\n\t\t\t   old_value ? \"ON\" : \"OFF\",\n\t\t\t   new_value ? \"ON\" : \"OFF\");\n\n\told_value = !!(old & I40E_L3_DST_MASK);\n\tnew_value = !!(new & I40E_L3_DST_MASK);\n\tif (old_value != new_value)\n\t\tnetif_info(pf, drv, vsi->netdev, \"L3 destination address: %s -> %s\\n\",\n\t\t\t   old_value ? \"ON\" : \"OFF\",\n\t\t\t   new_value ? \"ON\" : \"OFF\");\n\n\told_value = !!(old & I40E_L4_SRC_MASK);\n\tnew_value = !!(new & I40E_L4_SRC_MASK);\n\tif (old_value != new_value)\n\t\tnetif_info(pf, drv, vsi->netdev, \"L4 source port: %s -> %s\\n\",\n\t\t\t   old_value ? \"ON\" : \"OFF\",\n\t\t\t   new_value ? \"ON\" : \"OFF\");\n\n\told_value = !!(old & I40E_L4_DST_MASK);\n\tnew_value = !!(new & I40E_L4_DST_MASK);\n\tif (old_value != new_value)\n\t\tnetif_info(pf, drv, vsi->netdev, \"L4 destination port: %s -> %s\\n\",\n\t\t\t   old_value ? \"ON\" : \"OFF\",\n\t\t\t   new_value ? \"ON\" : \"OFF\");\n\n\told_value = !!(old & I40E_VERIFY_TAG_MASK);\n\tnew_value = !!(new & I40E_VERIFY_TAG_MASK);\n\tif (old_value != new_value)\n\t\tnetif_info(pf, drv, vsi->netdev, \"SCTP verification tag: %s -> %s\\n\",\n\t\t\t   old_value ? \"ON\" : \"OFF\",\n\t\t\t   new_value ? \"ON\" : \"OFF\");\n\n\t \n\tfor (i = 0; i < I40E_FLEX_INDEX_ENTRIES; i++) {\n\t\tu64 flex_mask = i40e_pit_index_to_mask(i);\n\n\t\told_value = !!(old & flex_mask);\n\t\tnew_value = !!(new & flex_mask);\n\t\tif (old_value != new_value)\n\t\t\tnetif_info(pf, drv, vsi->netdev, \"FLEX index %d: %s -> %s\\n\",\n\t\t\t\t   i,\n\t\t\t\t   old_value ? \"ON\" : \"OFF\",\n\t\t\t\t   new_value ? \"ON\" : \"OFF\");\n\t}\n\n\tnetif_info(pf, drv, vsi->netdev, \"  Current input set: %0llx\\n\",\n\t\t   old);\n\tnetif_info(pf, drv, vsi->netdev, \"Requested input set: %0llx\\n\",\n\t\t   new);\n}\n\n \nstatic int i40e_check_fdir_input_set(struct i40e_vsi *vsi,\n\t\t\t\t     struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t     struct i40e_rx_flow_userdef *userdef)\n{\n\tstatic const __be32 ipv6_full_mask[4] = {cpu_to_be32(0xffffffff),\n\t\tcpu_to_be32(0xffffffff), cpu_to_be32(0xffffffff),\n\t\tcpu_to_be32(0xffffffff)};\n\tstruct ethtool_tcpip6_spec *tcp_ip6_spec;\n\tstruct ethtool_usrip6_spec *usr_ip6_spec;\n\tstruct ethtool_tcpip4_spec *tcp_ip4_spec;\n\tstruct ethtool_usrip4_spec *usr_ip4_spec;\n\tstruct i40e_pf *pf = vsi->back;\n\tu64 current_mask, new_mask;\n\tbool new_flex_offset = false;\n\tbool flex_l3 = false;\n\tu16 *fdir_filter_count;\n\tu16 index, src_offset = 0;\n\tu8 pit_index = 0;\n\tint err;\n\n\tswitch (fsp->flow_type & ~FLOW_EXT) {\n\tcase SCTP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_SCTP;\n\t\tfdir_filter_count = &pf->fd_sctp4_filter_cnt;\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_TCP;\n\t\tfdir_filter_count = &pf->fd_tcp4_filter_cnt;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_UDP;\n\t\tfdir_filter_count = &pf->fd_udp4_filter_cnt;\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_SCTP;\n\t\tfdir_filter_count = &pf->fd_sctp6_filter_cnt;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_TCP;\n\t\tfdir_filter_count = &pf->fd_tcp6_filter_cnt;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_UDP;\n\t\tfdir_filter_count = &pf->fd_udp6_filter_cnt;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_OTHER;\n\t\tfdir_filter_count = &pf->fd_ip4_filter_cnt;\n\t\tflex_l3 = true;\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_OTHER;\n\t\tfdir_filter_count = &pf->fd_ip6_filter_cnt;\n\t\tflex_l3 = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tcurrent_mask = i40e_read_fd_input_set(pf, index);\n\tnew_mask = current_mask;\n\n\t \n\tswitch (fsp->flow_type & ~FLOW_EXT) {\n\tcase SCTP_V4_FLOW:\n\t\tnew_mask &= ~I40E_VERIFY_TAG_MASK;\n\t\tfallthrough;\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\ttcp_ip4_spec = &fsp->m_u.tcp_ip4_spec;\n\n\t\t \n\t\tif (tcp_ip4_spec->ip4src == htonl(0xFFFFFFFF))\n\t\t\tnew_mask |= I40E_L3_SRC_MASK;\n\t\telse if (!tcp_ip4_spec->ip4src)\n\t\t\tnew_mask &= ~I40E_L3_SRC_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tcp_ip4_spec->ip4dst == htonl(0xFFFFFFFF))\n\t\t\tnew_mask |= I40E_L3_DST_MASK;\n\t\telse if (!tcp_ip4_spec->ip4dst)\n\t\t\tnew_mask &= ~I40E_L3_DST_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tcp_ip4_spec->psrc == htons(0xFFFF))\n\t\t\tnew_mask |= I40E_L4_SRC_MASK;\n\t\telse if (!tcp_ip4_spec->psrc)\n\t\t\tnew_mask &= ~I40E_L4_SRC_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tcp_ip4_spec->pdst == htons(0xFFFF))\n\t\t\tnew_mask |= I40E_L4_DST_MASK;\n\t\telse if (!tcp_ip4_spec->pdst)\n\t\t\tnew_mask &= ~I40E_L4_DST_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tcp_ip4_spec->tos)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\tnew_mask &= ~I40E_VERIFY_TAG_MASK;\n\t\tfallthrough;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\ttcp_ip6_spec = &fsp->m_u.tcp_ip6_spec;\n\n\t\t \n\t\tif (ipv6_addr_equal((struct in6_addr *)&tcp_ip6_spec->ip6src,\n\t\t\t\t    (struct in6_addr *)&ipv6_full_mask))\n\t\t\tnew_mask |= I40E_L3_V6_SRC_MASK;\n\t\telse if (ipv6_addr_any((struct in6_addr *)\n\t\t\t\t       &tcp_ip6_spec->ip6src))\n\t\t\tnew_mask &= ~I40E_L3_V6_SRC_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (ipv6_addr_equal((struct in6_addr *)&tcp_ip6_spec->ip6dst,\n\t\t\t\t    (struct in6_addr *)&ipv6_full_mask))\n\t\t\tnew_mask |= I40E_L3_V6_DST_MASK;\n\t\telse if (ipv6_addr_any((struct in6_addr *)\n\t\t\t\t       &tcp_ip6_spec->ip6dst))\n\t\t\tnew_mask &= ~I40E_L3_V6_DST_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tcp_ip6_spec->psrc == htons(0xFFFF))\n\t\t\tnew_mask |= I40E_L4_SRC_MASK;\n\t\telse if (!tcp_ip6_spec->psrc)\n\t\t\tnew_mask &= ~I40E_L4_SRC_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tcp_ip6_spec->pdst == htons(0xFFFF))\n\t\t\tnew_mask |= I40E_L4_DST_MASK;\n\t\telse if (!tcp_ip6_spec->pdst)\n\t\t\tnew_mask &= ~I40E_L4_DST_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (tcp_ip6_spec->tclass)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tusr_ip4_spec = &fsp->m_u.usr_ip4_spec;\n\n\t\t \n\t\tif (usr_ip4_spec->ip4src == htonl(0xFFFFFFFF))\n\t\t\tnew_mask |= I40E_L3_SRC_MASK;\n\t\telse if (!usr_ip4_spec->ip4src)\n\t\t\tnew_mask &= ~I40E_L3_SRC_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (usr_ip4_spec->ip4dst == htonl(0xFFFFFFFF))\n\t\t\tnew_mask |= I40E_L3_DST_MASK;\n\t\telse if (!usr_ip4_spec->ip4dst)\n\t\t\tnew_mask &= ~I40E_L3_DST_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (usr_ip4_spec->l4_4_bytes)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (usr_ip4_spec->tos)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (usr_ip4_spec->ip_ver)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (usr_ip4_spec->proto)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tusr_ip6_spec = &fsp->m_u.usr_ip6_spec;\n\n\t\t \n\t\tif (ipv6_addr_equal((struct in6_addr *)&usr_ip6_spec->ip6src,\n\t\t\t\t    (struct in6_addr *)&ipv6_full_mask))\n\t\t\tnew_mask |= I40E_L3_V6_SRC_MASK;\n\t\telse if (ipv6_addr_any((struct in6_addr *)\n\t\t\t\t       &usr_ip6_spec->ip6src))\n\t\t\tnew_mask &= ~I40E_L3_V6_SRC_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (ipv6_addr_equal((struct in6_addr *)&usr_ip6_spec->ip6dst,\n\t\t\t\t    (struct in6_addr *)&ipv6_full_mask))\n\t\t\tnew_mask |= I40E_L3_V6_DST_MASK;\n\t\telse if (ipv6_addr_any((struct in6_addr *)\n\t\t\t\t       &usr_ip6_spec->ip6dst))\n\t\t\tnew_mask &= ~I40E_L3_V6_DST_MASK;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (usr_ip6_spec->l4_4_bytes)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (usr_ip6_spec->tclass)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (usr_ip6_spec->l4_proto)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (fsp->flow_type & FLOW_EXT) {\n\t\t \n\t\tif (fsp->h_ext.vlan_etype != htons(ETH_P_8021Q) &&\n\t\t    fsp->h_ext.vlan_etype != 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (fsp->m_ext.vlan_tci == htons(0xFFFF))\n\t\t\tnew_mask |= I40E_VLAN_SRC_MASK;\n\t\telse\n\t\t\tnew_mask &= ~I40E_VLAN_SRC_MASK;\n\t}\n\n\t \n\tnew_mask &= ~I40E_FLEX_INPUT_MASK;\n\n\t \n\tif (userdef->flex_filter) {\n\t\tstruct i40e_flex_pit *l3_flex_pit = NULL, *flex_pit = NULL;\n\n\t\t \n\t\tif (userdef->flex_offset & 0x1) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Flexible data offset must be 2-byte aligned\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsrc_offset = userdef->flex_offset >> 1;\n\n\t\t \n\t\tif (src_offset > I40E_MAX_FLEX_SRC_OFFSET) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Flexible data must reside within first 64 bytes of the packet payload\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tflex_pit = i40e_find_flex_offset(&pf->l4_flex_pit_list,\n\t\t\t\t\t\t src_offset);\n\t\tif (IS_ERR(flex_pit))\n\t\t\treturn PTR_ERR(flex_pit);\n\n\t\t \n\t\tif (flex_l3) {\n\t\t\tl3_flex_pit =\n\t\t\t\ti40e_find_flex_offset(&pf->l3_flex_pit_list,\n\t\t\t\t\t\t      src_offset);\n\t\t\tif (IS_ERR(l3_flex_pit))\n\t\t\t\treturn PTR_ERR(l3_flex_pit);\n\n\t\t\tif (flex_pit) {\n\t\t\t\t \n\t\t\t\tif (l3_flex_pit) {\n\t\t\t\t\tif (l3_flex_pit->pit_index !=\n\t\t\t\t\t    flex_pit->pit_index) {\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnew_flex_offset = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflex_pit = l3_flex_pit;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!flex_pit) {\n\t\t\tnew_flex_offset = true;\n\t\t\tpit_index = i40e_unused_pit_index(pf);\n\t\t} else {\n\t\t\tpit_index = flex_pit->pit_index;\n\t\t}\n\n\t\t \n\t\tnew_mask |= i40e_pit_index_to_mask(pit_index);\n\t}\n\n\t \n\tif (new_mask == current_mask && !new_flex_offset)\n\t\treturn 0;\n\n\tnetif_info(pf, drv, vsi->netdev, \"Input set change requested for %s flows:\\n\",\n\t\t   i40e_flow_str(fsp));\n\ti40e_print_input_set(vsi, current_mask, new_mask);\n\tif (new_flex_offset) {\n\t\tnetif_info(pf, drv, vsi->netdev, \"FLEX index %d: Offset -> %d\",\n\t\t\t   pit_index, src_offset);\n\t}\n\n\t \n\tif (pf->flags & I40E_FLAG_MFP_ENABLED) {\n\t\tnetif_err(pf, drv, vsi->netdev, \"Cannot change Flow Director input sets while MFP is enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (*fdir_filter_count) {\n\t\tnetif_err(pf, drv, vsi->netdev, \"Cannot change input set for %s flows until %d preexisting filters are removed\\n\",\n\t\t\t  i40e_flow_str(fsp),\n\t\t\t  *fdir_filter_count);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ti40e_write_fd_input_set(pf, index, new_mask);\n\n\t \n\tif (index == I40E_FILTER_PCTYPE_NONF_IPV4_OTHER)\n\t\ti40e_write_fd_input_set(pf, I40E_FILTER_PCTYPE_FRAG_IPV4,\n\t\t\t\t\tnew_mask);\n\n\t \n\tif (new_flex_offset) {\n\t\terr = i40e_add_flex_offset(&pf->l4_flex_pit_list, src_offset,\n\t\t\t\t\t   pit_index);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (flex_l3) {\n\t\t\terr = i40e_add_flex_offset(&pf->l3_flex_pit_list,\n\t\t\t\t\t\t   src_offset,\n\t\t\t\t\t\t   pit_index);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\ti40e_reprogram_flex_pit(pf);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool i40e_match_fdir_filter(struct i40e_fdir_filter *a,\n\t\t\t\t   struct i40e_fdir_filter *b)\n{\n\t \n\tif (a->dst_ip != b->dst_ip ||\n\t    a->src_ip != b->src_ip ||\n\t    a->dst_port != b->dst_port ||\n\t    a->src_port != b->src_port ||\n\t    a->flow_type != b->flow_type ||\n\t    a->ipl4_proto != b->ipl4_proto ||\n\t    a->vlan_tag != b->vlan_tag ||\n\t    a->vlan_etype != b->vlan_etype)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int i40e_disallow_matching_filters(struct i40e_vsi *vsi,\n\t\t\t\t\t  struct i40e_fdir_filter *input)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_fdir_filter *rule;\n\tstruct hlist_node *node2;\n\n\t \n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\t \n\t\tif (rule->fd_id == input->fd_id)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i40e_match_fdir_filter(rule, input)) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Existing user defined filter %d already matches this flow.\\n\",\n\t\t\t\t rule->fd_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i40e_add_fdir_ethtool(struct i40e_vsi *vsi,\n\t\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tstruct i40e_rx_flow_userdef userdef;\n\tstruct ethtool_rx_flow_spec *fsp;\n\tstruct i40e_fdir_filter *input;\n\tu16 dest_vsi = 0, q_index = 0;\n\tstruct i40e_pf *pf;\n\tint ret = -EINVAL;\n\tu8 dest_ctl;\n\n\tif (!vsi)\n\t\treturn -EINVAL;\n\tpf = vsi->back;\n\n\tif (!(pf->flags & I40E_FLAG_FD_SB_ENABLED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (test_bit(__I40E_FD_SB_AUTO_DISABLED, pf->state))\n\t\treturn -ENOSPC;\n\n\tif (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||\n\t    test_bit(__I40E_RESET_INTR_RECEIVED, pf->state))\n\t\treturn -EBUSY;\n\n\tif (test_bit(__I40E_FD_FLUSH_REQUESTED, pf->state))\n\t\treturn -EBUSY;\n\n\tfsp = (struct ethtool_rx_flow_spec *)&cmd->fs;\n\n\t \n\tif (i40e_parse_rx_flow_user_data(fsp, &userdef))\n\t\treturn -EINVAL;\n\n\t \n\tif (fsp->flow_type & FLOW_MAC_EXT)\n\t\treturn -EINVAL;\n\n\tret = i40e_check_fdir_input_set(vsi, fsp, &userdef);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fsp->location >= (pf->hw.func_caps.fd_filters_best_effort +\n\t\t\t      pf->hw.func_caps.fd_filters_guaranteed)) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fsp->ring_cookie == RX_CLS_FLOW_DISC) {\n\t\tdest_ctl = I40E_FILTER_PROGRAM_DESC_DEST_DROP_PACKET;\n\t} else {\n\t\tu32 ring = ethtool_get_flow_spec_ring(fsp->ring_cookie);\n\t\tu8 vf = ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);\n\n\t\tif (!vf) {\n\t\t\tif (ring >= vsi->num_queue_pairs)\n\t\t\t\treturn -EINVAL;\n\t\t\tdest_vsi = vsi->id;\n\t\t} else {\n\t\t\t \n\t\t\tvf--;\n\n\t\t\tif (vf >= pf->num_alloc_vfs)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ring >= pf->vf[vf].num_queue_pairs)\n\t\t\t\treturn -EINVAL;\n\t\t\tdest_vsi = pf->vf[vf].lan_vsi_id;\n\t\t}\n\t\tdest_ctl = I40E_FILTER_PROGRAM_DESC_DEST_DIRECT_PACKET_QINDEX;\n\t\tq_index = ring;\n\t}\n\n\tinput = kzalloc(sizeof(*input), GFP_KERNEL);\n\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->fd_id = fsp->location;\n\tinput->q_index = q_index;\n\tinput->dest_vsi = dest_vsi;\n\tinput->dest_ctl = dest_ctl;\n\tinput->fd_status = I40E_FILTER_PROGRAM_DESC_FD_STATUS_FD_ID;\n\tinput->cnt_index  = I40E_FD_SB_STAT_IDX(pf->hw.pf_id);\n\tinput->dst_ip = fsp->h_u.tcp_ip4_spec.ip4src;\n\tinput->src_ip = fsp->h_u.tcp_ip4_spec.ip4dst;\n\tinput->flow_type = fsp->flow_type & ~FLOW_EXT;\n\n\tinput->vlan_etype = fsp->h_ext.vlan_etype;\n\tif (!fsp->m_ext.vlan_etype && fsp->h_ext.vlan_tci)\n\t\tinput->vlan_etype = cpu_to_be16(ETH_P_8021Q);\n\tif (fsp->m_ext.vlan_tci && input->vlan_etype)\n\t\tinput->vlan_tag = fsp->h_ext.vlan_tci;\n\tif (input->flow_type == IPV6_USER_FLOW ||\n\t    input->flow_type == UDP_V6_FLOW ||\n\t    input->flow_type == TCP_V6_FLOW ||\n\t    input->flow_type == SCTP_V6_FLOW) {\n\t\t \n\t\tinput->ipl4_proto = fsp->h_u.usr_ip6_spec.l4_proto;\n\t\tinput->dst_port = fsp->h_u.tcp_ip6_spec.psrc;\n\t\tinput->src_port = fsp->h_u.tcp_ip6_spec.pdst;\n\t\tmemcpy(input->dst_ip6, fsp->h_u.ah_ip6_spec.ip6src,\n\t\t       sizeof(__be32) * 4);\n\t\tmemcpy(input->src_ip6, fsp->h_u.ah_ip6_spec.ip6dst,\n\t\t       sizeof(__be32) * 4);\n\t} else {\n\t\t \n\t\tinput->ipl4_proto = fsp->h_u.usr_ip4_spec.proto;\n\t\tinput->dst_port = fsp->h_u.tcp_ip4_spec.psrc;\n\t\tinput->src_port = fsp->h_u.tcp_ip4_spec.pdst;\n\t\tinput->dst_ip = fsp->h_u.tcp_ip4_spec.ip4src;\n\t\tinput->src_ip = fsp->h_u.tcp_ip4_spec.ip4dst;\n\t}\n\n\tif (userdef.flex_filter) {\n\t\tinput->flex_filter = true;\n\t\tinput->flex_word = cpu_to_be16(userdef.flex_word);\n\t\tinput->flex_offset = userdef.flex_offset;\n\t}\n\n\t \n\tret = i40e_disallow_matching_filters(vsi, input);\n\tif (ret)\n\t\tgoto free_filter_memory;\n\n\t \n\ti40e_update_ethtool_fdir_entry(vsi, input, fsp->location, NULL);\n\tret = i40e_add_del_fdir(vsi, input, true);\n\tif (ret)\n\t\tgoto remove_sw_rule;\n\treturn 0;\n\nremove_sw_rule:\n\thlist_del(&input->fdir_node);\n\tpf->fdir_pf_active_filters--;\nfree_filter_memory:\n\tkfree(input);\n\treturn ret;\n}\n\n \nstatic int i40e_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = i40e_set_rss_hash_opt(pf, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = i40e_add_fdir_ethtool(vsi, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = i40e_del_fdir_entry(vsi, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic unsigned int i40e_max_channels(struct i40e_vsi *vsi)\n{\n\t \n\treturn vsi->alloc_queue_pairs;\n}\n\n \nstatic void i40e_get_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *ch)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\n\t \n\tch->max_combined = i40e_max_channels(vsi);\n\n\t \n\tch->other_count = (pf->flags & I40E_FLAG_FD_SB_ENABLED) ? 1 : 0;\n\tch->max_other = ch->other_count;\n\n\t \n\tch->combined_count = vsi->num_queue_pairs;\n}\n\n \nstatic int i40e_set_channels(struct net_device *dev,\n\t\t\t     struct ethtool_channels *ch)\n{\n\tconst u8 drop = I40E_FILTER_PROGRAM_DESC_DEST_DROP_PACKET;\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tunsigned int count = ch->combined_count;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_fdir_filter *rule;\n\tstruct hlist_node *node2;\n\tint new_count;\n\tint err = 0;\n\n\t \n\tif (vsi->type != I40E_VSI_MAIN)\n\t\treturn -EINVAL;\n\n\t \n\tif (i40e_is_tc_mqprio_enabled(pf))\n\t\treturn -EINVAL;\n\n\t \n\tif (!count || ch->rx_count || ch->tx_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (ch->other_count != ((pf->flags & I40E_FLAG_FD_SB_ENABLED) ? 1 : 0))\n\t\treturn -EINVAL;\n\n\t \n\tif (count > i40e_max_channels(vsi))\n\t\treturn -EINVAL;\n\n\t \n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\tif (rule->dest_ctl != drop && count <= rule->q_index) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Existing user defined filter %d assigns flow to queue %d\\n\",\n\t\t\t\t rule->fd_id, rule->q_index);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (err) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Existing filter rules must be deleted to reduce combined channel count to %d\\n\",\n\t\t\tcount);\n\t\treturn err;\n\t}\n\n\t \n\t \n\n\t \n\tnew_count = i40e_reconfig_rss_queues(pf, count);\n\tif (new_count > 0)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\n \nstatic u32 i40e_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn I40E_HKEY_ARRAY_SIZE;\n}\n\n \nstatic u32 i40e_get_rxfh_indir_size(struct net_device *netdev)\n{\n\treturn I40E_HLUT_ARRAY_SIZE;\n}\n\n \nstatic int i40e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t u8 *hfunc)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tu8 *lut, *seed = NULL;\n\tint ret;\n\tu16 i;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\tif (!indir)\n\t\treturn 0;\n\n\tseed = key;\n\tlut = kzalloc(I40E_HLUT_ARRAY_SIZE, GFP_KERNEL);\n\tif (!lut)\n\t\treturn -ENOMEM;\n\tret = i40e_get_rss(vsi, seed, lut, I40E_HLUT_ARRAY_SIZE);\n\tif (ret)\n\t\tgoto out;\n\tfor (i = 0; i < I40E_HLUT_ARRAY_SIZE; i++)\n\t\tindir[i] = (u32)(lut[i]);\n\nout:\n\tkfree(lut);\n\n\treturn ret;\n}\n\n \nstatic int i40e_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\t const u8 *key, const u8 hfunc)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tu8 *seed = NULL;\n\tu16 i;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key) {\n\t\tif (!vsi->rss_hkey_user) {\n\t\t\tvsi->rss_hkey_user = kzalloc(I40E_HKEY_ARRAY_SIZE,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!vsi->rss_hkey_user)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(vsi->rss_hkey_user, key, I40E_HKEY_ARRAY_SIZE);\n\t\tseed = vsi->rss_hkey_user;\n\t}\n\tif (!vsi->rss_lut_user) {\n\t\tvsi->rss_lut_user = kzalloc(I40E_HLUT_ARRAY_SIZE, GFP_KERNEL);\n\t\tif (!vsi->rss_lut_user)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (indir)\n\t\tfor (i = 0; i < I40E_HLUT_ARRAY_SIZE; i++)\n\t\t\tvsi->rss_lut_user[i] = (u8)(indir[i]);\n\telse\n\t\ti40e_fill_rss_lut(pf, vsi->rss_lut_user, I40E_HLUT_ARRAY_SIZE,\n\t\t\t\t  vsi->rss_size);\n\n\treturn i40e_config_rss(vsi, seed, vsi->rss_lut_user,\n\t\t\t       I40E_HLUT_ARRAY_SIZE);\n}\n\n \nstatic u32 i40e_get_priv_flags(struct net_device *dev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tu32 i, j, ret_flags = 0;\n\n\tfor (i = 0; i < I40E_PRIV_FLAGS_STR_LEN; i++) {\n\t\tconst struct i40e_priv_flags *priv_flags;\n\n\t\tpriv_flags = &i40e_gstrings_priv_flags[i];\n\n\t\tif (priv_flags->flag & pf->flags)\n\t\t\tret_flags |= BIT(i);\n\t}\n\n\tif (pf->hw.pf_id != 0)\n\t\treturn ret_flags;\n\n\tfor (j = 0; j < I40E_GL_PRIV_FLAGS_STR_LEN; j++) {\n\t\tconst struct i40e_priv_flags *priv_flags;\n\n\t\tpriv_flags = &i40e_gl_gstrings_priv_flags[j];\n\n\t\tif (priv_flags->flag & pf->flags)\n\t\t\tret_flags |= BIT(i + j);\n\t}\n\n\treturn ret_flags;\n}\n\n \nstatic int i40e_set_priv_flags(struct net_device *dev, u32 flags)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tu64 orig_flags, new_flags, changed_flags;\n\tenum i40e_admin_queue_err adq_err;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tu32 reset_needed = 0;\n\tint status;\n\tu32 i, j;\n\n\torig_flags = READ_ONCE(pf->flags);\n\tnew_flags = orig_flags;\n\n\tfor (i = 0; i < I40E_PRIV_FLAGS_STR_LEN; i++) {\n\t\tconst struct i40e_priv_flags *priv_flags;\n\n\t\tpriv_flags = &i40e_gstrings_priv_flags[i];\n\n\t\tif (flags & BIT(i))\n\t\t\tnew_flags |= priv_flags->flag;\n\t\telse\n\t\t\tnew_flags &= ~(priv_flags->flag);\n\n\t\t \n\t\tif (priv_flags->read_only &&\n\t\t    ((orig_flags ^ new_flags) & ~BIT(i)))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (pf->hw.pf_id != 0)\n\t\tgoto flags_complete;\n\n\tfor (j = 0; j < I40E_GL_PRIV_FLAGS_STR_LEN; j++) {\n\t\tconst struct i40e_priv_flags *priv_flags;\n\n\t\tpriv_flags = &i40e_gl_gstrings_priv_flags[j];\n\n\t\tif (flags & BIT(i + j))\n\t\t\tnew_flags |= priv_flags->flag;\n\t\telse\n\t\t\tnew_flags &= ~(priv_flags->flag);\n\n\t\t \n\t\tif (priv_flags->read_only &&\n\t\t    ((orig_flags ^ new_flags) & ~BIT(i)))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\nflags_complete:\n\tchanged_flags = orig_flags ^ new_flags;\n\n\tif (changed_flags & I40E_FLAG_DISABLE_FW_LLDP)\n\t\treset_needed = I40E_PF_RESET_AND_REBUILD_FLAG;\n\tif (changed_flags & (I40E_FLAG_VEB_STATS_ENABLED |\n\t    I40E_FLAG_LEGACY_RX | I40E_FLAG_SOURCE_PRUNING_DISABLED))\n\t\treset_needed = BIT(__I40E_PF_RESET_REQUESTED);\n\n\t \n\n\t \n\tif ((new_flags & I40E_FLAG_HW_ATR_EVICT_ENABLED) &&\n\t    !(pf->hw_features & I40E_HW_ATR_EVICT_CAPABLE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (changed_flags & I40E_FLAG_DISABLE_FW_LLDP) {\n\t\tif (!(pf->hw.flags & I40E_HW_FLAG_FW_LLDP_STOPPABLE)) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Device does not support changing FW LLDP\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (changed_flags & I40E_FLAG_RS_FEC &&\n\t    pf->hw.device_id != I40E_DEV_ID_25G_SFP28 &&\n\t    pf->hw.device_id != I40E_DEV_ID_25G_B) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Device does not support changing FEC configuration\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (changed_flags & I40E_FLAG_BASE_R_FEC &&\n\t    pf->hw.device_id != I40E_DEV_ID_25G_SFP28 &&\n\t    pf->hw.device_id != I40E_DEV_ID_25G_B &&\n\t    pf->hw.device_id != I40E_DEV_ID_KX_X722) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Device does not support changing FEC configuration\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\t \n\tif ((changed_flags & I40E_FLAG_FD_ATR_ENABLED) &&\n\t    !(new_flags & I40E_FLAG_FD_ATR_ENABLED)) {\n\t\tset_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state);\n\t\tset_bit(__I40E_FD_FLUSH_REQUESTED, pf->state);\n\t}\n\n\tif (changed_flags & I40E_FLAG_TRUE_PROMISC_SUPPORT) {\n\t\tu16 sw_flags = 0, valid_flags = 0;\n\t\tint ret;\n\n\t\tif (!(new_flags & I40E_FLAG_TRUE_PROMISC_SUPPORT))\n\t\t\tsw_flags = I40E_AQ_SET_SWITCH_CFG_PROMISC;\n\t\tvalid_flags = I40E_AQ_SET_SWITCH_CFG_PROMISC;\n\t\tret = i40e_aq_set_switch_config(&pf->hw, sw_flags, valid_flags,\n\t\t\t\t\t\t0, NULL);\n\t\tif (ret && pf->hw.aq.asq_last_status != I40E_AQ_RC_ESRCH) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"couldn't set switch config bits, err %pe aq_err %s\\n\",\n\t\t\t\t ERR_PTR(ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\t \n\t\t}\n\t}\n\n\tif ((changed_flags & I40E_FLAG_RS_FEC) ||\n\t    (changed_flags & I40E_FLAG_BASE_R_FEC)) {\n\t\tu8 fec_cfg = 0;\n\n\t\tif (new_flags & I40E_FLAG_RS_FEC &&\n\t\t    new_flags & I40E_FLAG_BASE_R_FEC) {\n\t\t\tfec_cfg = I40E_AQ_SET_FEC_AUTO;\n\t\t} else if (new_flags & I40E_FLAG_RS_FEC) {\n\t\t\tfec_cfg = (I40E_AQ_SET_FEC_REQUEST_RS |\n\t\t\t\t   I40E_AQ_SET_FEC_ABILITY_RS);\n\t\t} else if (new_flags & I40E_FLAG_BASE_R_FEC) {\n\t\t\tfec_cfg = (I40E_AQ_SET_FEC_REQUEST_KR |\n\t\t\t\t   I40E_AQ_SET_FEC_ABILITY_KR);\n\t\t}\n\t\tif (i40e_set_fec_cfg(dev, fec_cfg))\n\t\t\tdev_warn(&pf->pdev->dev, \"Cannot change FEC config\\n\");\n\t}\n\n\tif ((changed_flags & I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED) &&\n\t    (orig_flags & I40E_FLAG_TOTAL_PORT_SHUTDOWN_ENABLED)) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Setting link-down-on-close not supported on this port (because total-port-shutdown is enabled)\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((changed_flags & I40E_FLAG_VF_VLAN_PRUNING) &&\n\t    pf->num_alloc_vfs) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Changing vf-vlan-pruning flag while VF(s) are active is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((changed_flags & I40E_FLAG_LEGACY_RX) &&\n\t    I40E_2K_TOO_SMALL_WITH_PADDING) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"2k Rx buffer is too small to fit standard MTU and skb_shared_info\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((changed_flags & new_flags &\n\t     I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED) &&\n\t    (new_flags & I40E_FLAG_MFP_ENABLED))\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Turning on link-down-on-close flag may affect other partitions\\n\");\n\n\tif (changed_flags & I40E_FLAG_DISABLE_FW_LLDP) {\n\t\tif (new_flags & I40E_FLAG_DISABLE_FW_LLDP) {\n#ifdef CONFIG_I40E_DCB\n\t\t\ti40e_dcb_sw_default_config(pf);\n#endif  \n\t\t\ti40e_aq_cfg_lldp_mib_change_event(&pf->hw, false, NULL);\n\t\t\ti40e_aq_stop_lldp(&pf->hw, true, false, NULL);\n\t\t} else {\n\t\t\tstatus = i40e_aq_start_lldp(&pf->hw, false, NULL);\n\t\t\tif (status) {\n\t\t\t\tadq_err = pf->hw.aq.asq_last_status;\n\t\t\t\tswitch (adq_err) {\n\t\t\t\tcase I40E_AQ_RC_EEXIST:\n\t\t\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t\t\t \"FW LLDP agent is already running\\n\");\n\t\t\t\t\treset_needed = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase I40E_AQ_RC_EPERM:\n\t\t\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t\t\t \"Device configuration forbids SW from starting the LLDP agent.\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tcase I40E_AQ_RC_EAGAIN:\n\t\t\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t\t\t \"Stop FW LLDP agent command is still being processed, please try again in a second.\\n\");\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\tdefault:\n\t\t\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t\t\t \"Starting FW LLDP agent failed: error: %pe, %s\\n\",\n\t\t\t\t\t\t ERR_PTR(status),\n\t\t\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t\t\t     adq_err));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tpf->flags = new_flags;\n\n\t \n\tif (reset_needed)\n\t\ti40e_do_reset(pf, reset_needed, true);\n\n\treturn 0;\n}\n\n \nstatic int i40e_get_module_info(struct net_device *netdev,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 sff8472_comp = 0;\n\tu32 sff8472_swap = 0;\n\tu32 sff8636_rev = 0;\n\tu32 type = 0;\n\tint status;\n\n\t \n\tif (!(hw->flags & I40E_HW_FLAG_AQ_PHY_ACCESS_CAPABLE)) {\n\t\tnetdev_err(vsi->netdev, \"Module EEPROM memory read not supported. Please update the NVM image.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = i40e_update_link_info(hw);\n\tif (status)\n\t\treturn -EIO;\n\n\tif (hw->phy.link_info.phy_type == I40E_PHY_TYPE_EMPTY) {\n\t\tnetdev_err(vsi->netdev, \"Cannot read module EEPROM memory. No module connected.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttype = hw->phy.link_info.module_type[0];\n\n\tswitch (type) {\n\tcase I40E_MODULE_TYPE_SFP:\n\t\tstatus = i40e_aq_get_phy_register(hw,\n\t\t\t\tI40E_AQ_PHY_REG_ACCESS_EXTERNAL_MODULE,\n\t\t\t\tI40E_I2C_EEPROM_DEV_ADDR, true,\n\t\t\t\tI40E_MODULE_SFF_8472_COMP,\n\t\t\t\t&sff8472_comp, NULL);\n\t\tif (status)\n\t\t\treturn -EIO;\n\n\t\tstatus = i40e_aq_get_phy_register(hw,\n\t\t\t\tI40E_AQ_PHY_REG_ACCESS_EXTERNAL_MODULE,\n\t\t\t\tI40E_I2C_EEPROM_DEV_ADDR, true,\n\t\t\t\tI40E_MODULE_SFF_8472_SWAP,\n\t\t\t\t&sff8472_swap, NULL);\n\t\tif (status)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (sff8472_swap & I40E_MODULE_SFF_ADDR_MODE) {\n\t\t\tnetdev_warn(vsi->netdev, \"Module address swap to access page 0xA2 is not supported.\\n\");\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t} else if (sff8472_comp == 0x00) {\n\t\t\t \n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t} else if (!(sff8472_swap & I40E_MODULE_SFF_DDM_IMPLEMENTED)) {\n\t\t\t \n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\t}\n\t\tbreak;\n\tcase I40E_MODULE_TYPE_QSFP_PLUS:\n\t\t \n\t\tstatus = i40e_aq_get_phy_register(hw,\n\t\t\t\tI40E_AQ_PHY_REG_ACCESS_EXTERNAL_MODULE,\n\t\t\t\t0, true,\n\t\t\t\tI40E_MODULE_REVISION_ADDR,\n\t\t\t\t&sff8636_rev, NULL);\n\t\tif (status)\n\t\t\treturn -EIO;\n\t\t \n\t\tif (sff8636_rev > 0x02) {\n\t\t\t \n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = I40E_MODULE_QSFP_MAX_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = I40E_MODULE_QSFP_MAX_LEN;\n\t\t}\n\t\tbreak;\n\tcase I40E_MODULE_TYPE_QSFP28:\n\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\tmodinfo->eeprom_len = I40E_MODULE_QSFP_MAX_LEN;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(vsi->netdev, \"Module type unrecognized\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int i40e_get_module_eeprom(struct net_device *netdev,\n\t\t\t\t  struct ethtool_eeprom *ee,\n\t\t\t\t  u8 *data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tbool is_sfp = false;\n\tu32 value = 0;\n\tint status;\n\tint i;\n\n\tif (!ee || !ee->len || !data)\n\t\treturn -EINVAL;\n\n\tif (hw->phy.link_info.module_type[0] == I40E_MODULE_TYPE_SFP)\n\t\tis_sfp = true;\n\n\tfor (i = 0; i < ee->len; i++) {\n\t\tu32 offset = i + ee->offset;\n\t\tu32 addr = is_sfp ? I40E_I2C_EEPROM_DEV_ADDR : 0;\n\n\t\t \n\t\tif (is_sfp) {\n\t\t\tif (offset >= ETH_MODULE_SFF_8079_LEN) {\n\t\t\t\toffset -= ETH_MODULE_SFF_8079_LEN;\n\t\t\t\taddr = I40E_I2C_EEPROM_DEV_ADDR2;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (offset >= ETH_MODULE_SFF_8436_LEN) {\n\t\t\t\t \n\t\t\t\toffset -= ETH_MODULE_SFF_8436_LEN / 2;\n\t\t\t\taddr++;\n\t\t\t}\n\t\t}\n\n\t\tstatus = i40e_aq_get_phy_register(hw,\n\t\t\t\tI40E_AQ_PHY_REG_ACCESS_EXTERNAL_MODULE,\n\t\t\t\taddr, true, offset, &value, NULL);\n\t\tif (status)\n\t\t\treturn -EIO;\n\t\tdata[i] = value;\n\t}\n\treturn 0;\n}\n\nstatic int i40e_get_eee(struct net_device *netdev, struct ethtool_eee *edata)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_aq_get_phy_abilities_resp phy_cfg;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint status = 0;\n\n\t \n\tstatus = i40e_aq_get_phy_capabilities(hw, false, true, &phy_cfg, NULL);\n\tif (status)\n\t\treturn -EAGAIN;\n\n\t \n\tif (phy_cfg.eee_capability == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tedata->supported = SUPPORTED_Autoneg;\n\tedata->lp_advertised = edata->supported;\n\n\t \n\tstatus = i40e_aq_get_phy_capabilities(hw, false, false, &phy_cfg, NULL);\n\tif (status)\n\t\treturn -EAGAIN;\n\n\tedata->advertised = phy_cfg.eee_capability ? SUPPORTED_Autoneg : 0U;\n\tedata->eee_enabled = !!edata->advertised;\n\tedata->tx_lpi_enabled = pf->stats.tx_lpi_status;\n\n\tedata->eee_active = pf->stats.tx_lpi_status && pf->stats.rx_lpi_status;\n\n\treturn 0;\n}\n\nstatic int i40e_is_eee_param_supported(struct net_device *netdev,\n\t\t\t\t       struct ethtool_eee *edata)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_ethtool_not_used {\n\t\tu32 value;\n\t\tconst char *name;\n\t} param[] = {\n\t\t{edata->advertised & ~SUPPORTED_Autoneg, \"advertise\"},\n\t\t{edata->tx_lpi_timer, \"tx-timer\"},\n\t\t{edata->tx_lpi_enabled != pf->stats.tx_lpi_status, \"tx-lpi\"}\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(param); i++) {\n\t\tif (param[i].value) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"EEE setting %s not supported\\n\",\n\t\t\t\t    param[i].name);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int i40e_set_eee(struct net_device *netdev, struct ethtool_eee *edata)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct i40e_aq_set_phy_config config;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\t__le16 eee_capability;\n\tint status = 0;\n\n\t \n\tif (i40e_is_eee_param_supported(netdev, edata))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tstatus = i40e_aq_get_phy_capabilities(hw, false, true, &abilities,\n\t\t\t\t\t      NULL);\n\tif (status)\n\t\treturn -EAGAIN;\n\n\t \n\tif (abilities.eee_capability == 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\teee_capability = abilities.eee_capability;\n\n\t \n\tstatus = i40e_aq_get_phy_capabilities(hw, false, false, &abilities,\n\t\t\t\t\t      NULL);\n\tif (status)\n\t\treturn -EAGAIN;\n\n\t \n\tconfig.phy_type = abilities.phy_type;\n\tconfig.phy_type_ext = abilities.phy_type_ext;\n\tconfig.link_speed = abilities.link_speed;\n\tconfig.abilities = abilities.abilities |\n\t\t\t   I40E_AQ_PHY_ENABLE_ATOMIC_LINK;\n\tconfig.eeer = abilities.eeer_val;\n\tconfig.low_power_ctrl = abilities.d3_lpan;\n\tconfig.fec_config = abilities.fec_cfg_curr_mod_ext_info &\n\t\t\t    I40E_AQ_PHY_FEC_CONFIG_MASK;\n\n\t \n\tif (edata->eee_enabled) {\n\t\tconfig.eee_capability = eee_capability;\n\t\tconfig.eeer |= cpu_to_le32(I40E_PRTPM_EEER_TX_LPI_EN_MASK);\n\t} else {\n\t\tconfig.eee_capability = 0;\n\t\tconfig.eeer &= cpu_to_le32(~I40E_PRTPM_EEER_TX_LPI_EN_MASK);\n\t}\n\n\t \n\tstatus = i40e_aq_set_phy_config(hw, &config, NULL);\n\tif (status)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops i40e_ethtool_recovery_mode_ops = {\n\t.get_drvinfo\t\t= i40e_get_drvinfo,\n\t.set_eeprom\t\t= i40e_set_eeprom,\n\t.get_eeprom_len\t\t= i40e_get_eeprom_len,\n\t.get_eeprom\t\t= i40e_get_eeprom,\n};\n\nstatic const struct ethtool_ops i40e_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE |\n\t\t\t\t     ETHTOOL_COALESCE_RX_USECS_HIGH |\n\t\t\t\t     ETHTOOL_COALESCE_TX_USECS_HIGH,\n\t.get_drvinfo\t\t= i40e_get_drvinfo,\n\t.get_regs_len\t\t= i40e_get_regs_len,\n\t.get_regs\t\t= i40e_get_regs,\n\t.nway_reset\t\t= i40e_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_wol\t\t= i40e_get_wol,\n\t.set_wol\t\t= i40e_set_wol,\n\t.set_eeprom\t\t= i40e_set_eeprom,\n\t.get_eeprom_len\t\t= i40e_get_eeprom_len,\n\t.get_eeprom\t\t= i40e_get_eeprom,\n\t.get_ringparam\t\t= i40e_get_ringparam,\n\t.set_ringparam\t\t= i40e_set_ringparam,\n\t.get_pauseparam\t\t= i40e_get_pauseparam,\n\t.set_pauseparam\t\t= i40e_set_pauseparam,\n\t.get_msglevel\t\t= i40e_get_msglevel,\n\t.set_msglevel\t\t= i40e_set_msglevel,\n\t.get_rxnfc\t\t= i40e_get_rxnfc,\n\t.set_rxnfc\t\t= i40e_set_rxnfc,\n\t.self_test\t\t= i40e_diag_test,\n\t.get_strings\t\t= i40e_get_strings,\n\t.get_eee\t\t= i40e_get_eee,\n\t.set_eee\t\t= i40e_set_eee,\n\t.set_phys_id\t\t= i40e_set_phys_id,\n\t.get_sset_count\t\t= i40e_get_sset_count,\n\t.get_ethtool_stats\t= i40e_get_ethtool_stats,\n\t.get_coalesce\t\t= i40e_get_coalesce,\n\t.set_coalesce\t\t= i40e_set_coalesce,\n\t.get_rxfh_key_size\t= i40e_get_rxfh_key_size,\n\t.get_rxfh_indir_size\t= i40e_get_rxfh_indir_size,\n\t.get_rxfh\t\t= i40e_get_rxfh,\n\t.set_rxfh\t\t= i40e_set_rxfh,\n\t.get_channels\t\t= i40e_get_channels,\n\t.set_channels\t\t= i40e_set_channels,\n\t.get_module_info\t= i40e_get_module_info,\n\t.get_module_eeprom\t= i40e_get_module_eeprom,\n\t.get_ts_info\t\t= i40e_get_ts_info,\n\t.get_priv_flags\t\t= i40e_get_priv_flags,\n\t.set_priv_flags\t\t= i40e_set_priv_flags,\n\t.get_per_queue_coalesce\t= i40e_get_per_queue_coalesce,\n\t.set_per_queue_coalesce\t= i40e_set_per_queue_coalesce,\n\t.get_link_ksettings\t= i40e_get_link_ksettings,\n\t.set_link_ksettings\t= i40e_set_link_ksettings,\n\t.get_fecparam = i40e_get_fec_param,\n\t.set_fecparam = i40e_set_fec_param,\n\t.flash_device = i40e_ddp_flash,\n};\n\nvoid i40e_set_ethtool_ops(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf\t\t*pf = np->vsi->back;\n\n\tif (!test_bit(__I40E_RECOVERY_MODE, pf->state))\n\t\tnetdev->ethtool_ops = &i40e_ethtool_ops;\n\telse\n\t\tnetdev->ethtool_ops = &i40e_ethtool_recovery_mode_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}