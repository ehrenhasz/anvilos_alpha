{
  "module_name": "i40e_txrx.h",
  "hash_id": "5b92327d96dd54b731185bae5b1807af7a37a228835ebb1f38c3757f4e30416f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/i40e/i40e_txrx.h",
  "human_readable_source": " \n \n\n#ifndef _I40E_TXRX_H_\n#define _I40E_TXRX_H_\n\n#include <net/xdp.h>\n\n \n#define I40E_DEFAULT_IRQ_WORK      256\n\n \n#define I40E_ITR_DYNAMIC\t0x8000\t \n#define I40E_ITR_MASK\t\t0x1FFE\t \n#define I40E_MIN_ITR\t\t     2\t \n#define I40E_ITR_20K\t\t    50\n#define I40E_ITR_8K\t\t   122\n#define I40E_MAX_ITR\t\t  8160\t \n#define ITR_TO_REG(setting) ((setting) & ~I40E_ITR_DYNAMIC)\n#define ITR_REG_ALIGN(setting) __ALIGN_MASK(setting, ~I40E_ITR_MASK)\n#define ITR_IS_DYNAMIC(setting) (!!((setting) & I40E_ITR_DYNAMIC))\n\n#define I40E_ITR_RX_DEF\t\t(I40E_ITR_20K | I40E_ITR_DYNAMIC)\n#define I40E_ITR_TX_DEF\t\t(I40E_ITR_20K | I40E_ITR_DYNAMIC)\n\n \n#define INTRL_ENA                  BIT(6)\n#define I40E_MAX_INTRL             0x3B     \n#define INTRL_REG_TO_USEC(intrl) ((intrl & ~INTRL_ENA) << 2)\n\n \nstatic inline u16 i40e_intrl_usec_to_reg(int intrl)\n{\n\tif (intrl >> 2)\n\t\treturn ((intrl >> 2) | INTRL_ENA);\n\telse\n\t\treturn 0;\n}\n\n#define I40E_QUEUE_END_OF_LIST 0x7FF\n\n \nenum i40e_dyn_idx_t {\n\tI40E_IDX_ITR0 = 0,\n\tI40E_IDX_ITR1 = 1,\n\tI40E_IDX_ITR2 = 2,\n\tI40E_ITR_NONE = 3\t \n};\n\n \n#define I40E_RX_ITR    I40E_IDX_ITR0\n#define I40E_TX_ITR    I40E_IDX_ITR1\n\n \n#define I40E_DEFAULT_RSS_HENA ( \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_UDP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_SCTP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_TCP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_OTHER) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV4) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_UDP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_TCP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_SCTP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_OTHER) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV6) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_L2_PAYLOAD))\n\n#define I40E_DEFAULT_RSS_HENA_EXPANDED (I40E_DEFAULT_RSS_HENA | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_TCP_SYN_NO_ACK) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_UNICAST_IPV4_UDP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_MULTICAST_IPV4_UDP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_TCP_SYN_NO_ACK) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_UNICAST_IPV6_UDP) | \\\n\tBIT_ULL(I40E_FILTER_PCTYPE_NONF_MULTICAST_IPV6_UDP))\n\n#define i40e_pf_get_default_rss_hena(pf) \\\n\t(((pf)->hw_features & I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE) ? \\\n\t  I40E_DEFAULT_RSS_HENA_EXPANDED : I40E_DEFAULT_RSS_HENA)\n\n \n#define I40E_RXBUFFER_256   256\n#define I40E_RXBUFFER_1536  1536   \n#define I40E_RXBUFFER_2048  2048\n#define I40E_RXBUFFER_3072  3072   \n#define I40E_MAX_RXBUFFER   9728   \n\n \n#define I40E_RX_HDR_SIZE I40E_RXBUFFER_256\n#define I40E_PACKET_HDR_PAD (ETH_HLEN + ETH_FCS_LEN + (VLAN_HLEN * 2))\n#define i40e_rx_desc i40e_16byte_rx_desc\n\n#define I40E_RX_DMA_ATTR \\\n\t(DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING)\n\n \n#if (PAGE_SIZE < 8192)\n#define I40E_2K_TOO_SMALL_WITH_PADDING \\\n((NET_SKB_PAD + I40E_RXBUFFER_1536) > SKB_WITH_OVERHEAD(I40E_RXBUFFER_2048))\n\nstatic inline int i40e_compute_pad(int rx_buf_len)\n{\n\tint page_size, pad_size;\n\n\tpage_size = ALIGN(rx_buf_len, PAGE_SIZE / 2);\n\tpad_size = SKB_WITH_OVERHEAD(page_size) - rx_buf_len;\n\n\treturn pad_size;\n}\n\nstatic inline int i40e_skb_pad(void)\n{\n\tint rx_buf_len;\n\n\t \n\tif (I40E_2K_TOO_SMALL_WITH_PADDING)\n\t\trx_buf_len = I40E_RXBUFFER_3072 + SKB_DATA_ALIGN(NET_IP_ALIGN);\n\telse\n\t\trx_buf_len = I40E_RXBUFFER_1536;\n\n\t \n\trx_buf_len -= NET_IP_ALIGN;\n\n\treturn i40e_compute_pad(rx_buf_len);\n}\n\n#define I40E_SKB_PAD i40e_skb_pad()\n#else\n#define I40E_2K_TOO_SMALL_WITH_PADDING false\n#define I40E_SKB_PAD (NET_SKB_PAD + NET_IP_ALIGN)\n#endif\n\n \nstatic inline bool i40e_test_staterr(union i40e_rx_desc *rx_desc,\n\t\t\t\t     const u64 stat_err_bits)\n{\n\treturn !!(rx_desc->wb.qword1.status_error_len &\n\t\t  cpu_to_le64(stat_err_bits));\n}\n\n \n#define I40E_RX_BUFFER_WRITE\t32\t \n\n#define I40E_RX_NEXT_DESC(r, i, n)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\t(i)++;\t\t\t\t\\\n\t\tif ((i) == (r)->count)\t\t\\\n\t\t\ti = 0;\t\t\t\\\n\t\t(n) = I40E_RX_DESC((r), (i));\t\\\n\t} while (0)\n\n\n#define I40E_MAX_BUFFER_TXD\t8\n#define I40E_MIN_TX_LEN\t\t17\n\n \n#define I40E_MAX_READ_REQ_SIZE\t\t4096\n#define I40E_MAX_DATA_PER_TXD\t\t(16 * 1024 - 1)\n#define I40E_MAX_DATA_PER_TXD_ALIGNED \\\n\t(I40E_MAX_DATA_PER_TXD & ~(I40E_MAX_READ_REQ_SIZE - 1))\n\n \nstatic inline unsigned int i40e_txd_use_count(unsigned int size)\n{\n\treturn ((size * 85) >> 20) + 1;\n}\n\n \n#define DESC_NEEDED (MAX_SKB_FRAGS + 6)\n\n#define I40E_TX_FLAGS_HW_VLAN\t\tBIT(1)\n#define I40E_TX_FLAGS_SW_VLAN\t\tBIT(2)\n#define I40E_TX_FLAGS_TSO\t\tBIT(3)\n#define I40E_TX_FLAGS_IPV4\t\tBIT(4)\n#define I40E_TX_FLAGS_IPV6\t\tBIT(5)\n#define I40E_TX_FLAGS_TSYN\t\tBIT(8)\n#define I40E_TX_FLAGS_FD_SB\t\tBIT(9)\n#define I40E_TX_FLAGS_UDP_TUNNEL\tBIT(10)\n#define I40E_TX_FLAGS_VLAN_MASK\t\t0xffff0000\n#define I40E_TX_FLAGS_VLAN_PRIO_MASK\t0xe0000000\n#define I40E_TX_FLAGS_VLAN_PRIO_SHIFT\t29\n#define I40E_TX_FLAGS_VLAN_SHIFT\t16\n\nstruct i40e_tx_buffer {\n\tstruct i40e_tx_desc *next_to_watch;\n\tunion {\n\t\tstruct xdp_frame *xdpf;\n\t\tstruct sk_buff *skb;\n\t\tvoid *raw_buf;\n\t};\n\tunsigned int bytecount;\n\tunsigned short gso_segs;\n\n\tDEFINE_DMA_UNMAP_ADDR(dma);\n\tDEFINE_DMA_UNMAP_LEN(len);\n\tu32 tx_flags;\n};\n\nstruct i40e_rx_buffer {\n\tdma_addr_t dma;\n\tstruct page *page;\n\t__u32 page_offset;\n\t__u16 pagecnt_bias;\n\t__u32 page_count;\n};\n\nstruct i40e_queue_stats {\n\tu64 packets;\n\tu64 bytes;\n};\n\nstruct i40e_tx_queue_stats {\n\tu64 restart_queue;\n\tu64 tx_busy;\n\tu64 tx_done_old;\n\tu64 tx_linearize;\n\tu64 tx_force_wb;\n\tu64 tx_stopped;\n\tint prev_pkt_ctr;\n};\n\nstruct i40e_rx_queue_stats {\n\tu64 non_eop_descs;\n\tu64 alloc_page_failed;\n\tu64 alloc_buff_failed;\n\tu64 page_reuse_count;\n\tu64 page_alloc_count;\n\tu64 page_waive_count;\n\tu64 page_busy_count;\n};\n\nenum i40e_ring_state_t {\n\t__I40E_TX_FDIR_INIT_DONE,\n\t__I40E_TX_XPS_INIT_DONE,\n\t__I40E_RING_STATE_NBITS  \n};\n\n \n#define I40E_RX_DTYPE_HEADER_SPLIT  1\n#define I40E_RX_SPLIT_L2      0x1\n#define I40E_RX_SPLIT_IP      0x2\n#define I40E_RX_SPLIT_TCP_UDP 0x4\n#define I40E_RX_SPLIT_SCTP    0x8\n\n \nstruct i40e_ring {\n\tstruct i40e_ring *next;\t\t \n\tvoid *desc;\t\t\t \n\tstruct device *dev;\t\t \n\tstruct net_device *netdev;\t \n\tstruct bpf_prog *xdp_prog;\n\tunion {\n\t\tstruct i40e_tx_buffer *tx_bi;\n\t\tstruct i40e_rx_buffer *rx_bi;\n\t\tstruct xdp_buff **rx_bi_zc;\n\t};\n\tDECLARE_BITMAP(state, __I40E_RING_STATE_NBITS);\n\tu16 queue_index;\t\t \n\tu8 dcb_tc;\t\t\t \n\tu8 __iomem *tail;\n\n\t \n\tstruct xdp_buff xdp;\n\n\t \n\tu16 next_to_process;\n\t \n\tu16 itr_setting;\n\n\tu16 count;\t\t\t \n\tu16 reg_idx;\t\t\t \n\tu16 rx_buf_len;\n\n\t \n\tu16 next_to_use;\n\tu16 next_to_clean;\n\tu16 xdp_tx_active;\n\n\tu8 atr_sample_rate;\n\tu8 atr_count;\n\n\tbool ring_active;\t\t \n\tbool arm_wb;\t\t \n\tu8 packet_stride;\n\n\tu16 flags;\n#define I40E_TXR_FLAGS_WB_ON_ITR\t\tBIT(0)\n#define I40E_RXR_FLAGS_BUILD_SKB_ENABLED\tBIT(1)\n#define I40E_TXR_FLAGS_XDP\t\t\tBIT(2)\n\n\t \n\tstruct i40e_queue_stats\tstats;\n\tstruct u64_stats_sync syncp;\n\tunion {\n\t\tstruct i40e_tx_queue_stats tx_stats;\n\t\tstruct i40e_rx_queue_stats rx_stats;\n\t};\n\n\tunsigned int size;\t\t \n\tdma_addr_t dma;\t\t\t \n\n\tstruct i40e_vsi *vsi;\t\t \n\tstruct i40e_q_vector *q_vector;\t \n\n\tstruct rcu_head rcu;\t\t \n\tu16 next_to_alloc;\n\n\tstruct i40e_channel *ch;\n\tu16 rx_offset;\n\tstruct xdp_rxq_info xdp_rxq;\n\tstruct xsk_buff_pool *xsk_pool;\n} ____cacheline_internodealigned_in_smp;\n\nstatic inline bool ring_uses_build_skb(struct i40e_ring *ring)\n{\n\treturn !!(ring->flags & I40E_RXR_FLAGS_BUILD_SKB_ENABLED);\n}\n\nstatic inline void set_ring_build_skb_enabled(struct i40e_ring *ring)\n{\n\tring->flags |= I40E_RXR_FLAGS_BUILD_SKB_ENABLED;\n}\n\nstatic inline void clear_ring_build_skb_enabled(struct i40e_ring *ring)\n{\n\tring->flags &= ~I40E_RXR_FLAGS_BUILD_SKB_ENABLED;\n}\n\nstatic inline bool ring_is_xdp(struct i40e_ring *ring)\n{\n\treturn !!(ring->flags & I40E_TXR_FLAGS_XDP);\n}\n\nstatic inline void set_ring_xdp(struct i40e_ring *ring)\n{\n\tring->flags |= I40E_TXR_FLAGS_XDP;\n}\n\n#define I40E_ITR_ADAPTIVE_MIN_INC\t0x0002\n#define I40E_ITR_ADAPTIVE_MIN_USECS\t0x0002\n#define I40E_ITR_ADAPTIVE_MAX_USECS\t0x007e\n#define I40E_ITR_ADAPTIVE_LATENCY\t0x8000\n#define I40E_ITR_ADAPTIVE_BULK\t\t0x0000\n\nstruct i40e_ring_container {\n\tstruct i40e_ring *ring;\t\t \n\tunsigned long next_update;\t \n\tunsigned int total_bytes;\t \n\tunsigned int total_packets;\t \n\tu16 count;\n\tu16 target_itr;\t\t\t \n\tu16 current_itr;\t\t \n};\n\n \n#define i40e_for_each_ring(pos, head) \\\n\tfor (pos = (head).ring; pos != NULL; pos = pos->next)\n\nstatic inline unsigned int i40e_rx_pg_order(struct i40e_ring *ring)\n{\n#if (PAGE_SIZE < 8192)\n\tif (ring->rx_buf_len > (PAGE_SIZE / 2))\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n#define i40e_rx_pg_size(_ring) (PAGE_SIZE << i40e_rx_pg_order(_ring))\n\nbool i40e_alloc_rx_buffers(struct i40e_ring *rxr, u16 cleaned_count);\nnetdev_tx_t i40e_lan_xmit_frame(struct sk_buff *skb, struct net_device *netdev);\nu16 i40e_lan_select_queue(struct net_device *netdev, struct sk_buff *skb,\n\t\t\t  struct net_device *sb_dev);\nvoid i40e_clean_tx_ring(struct i40e_ring *tx_ring);\nvoid i40e_clean_rx_ring(struct i40e_ring *rx_ring);\nint i40e_setup_tx_descriptors(struct i40e_ring *tx_ring);\nint i40e_setup_rx_descriptors(struct i40e_ring *rx_ring);\nvoid i40e_free_tx_resources(struct i40e_ring *tx_ring);\nvoid i40e_free_rx_resources(struct i40e_ring *rx_ring);\nint i40e_napi_poll(struct napi_struct *napi, int budget);\nvoid i40e_force_wb(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector);\nu32 i40e_get_tx_pending(struct i40e_ring *ring, bool in_sw);\nvoid i40e_detect_recover_hung(struct i40e_vsi *vsi);\nint __i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size);\nbool __i40e_chk_linearize(struct sk_buff *skb);\nint i40e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames,\n\t\t  u32 flags);\nbool i40e_is_non_eop(struct i40e_ring *rx_ring,\n\t\t     union i40e_rx_desc *rx_desc);\n\n \nstatic inline u32 i40e_get_head(struct i40e_ring *tx_ring)\n{\n\tvoid *head = (struct i40e_tx_desc *)tx_ring->desc + tx_ring->count;\n\n\treturn le32_to_cpu(*(volatile __le32 *)head);\n}\n\n \nstatic inline int i40e_xmit_descriptor_count(struct sk_buff *skb)\n{\n\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[0];\n\tunsigned int nr_frags = skb_shinfo(skb)->nr_frags;\n\tint count = 0, size = skb_headlen(skb);\n\n\tfor (;;) {\n\t\tcount += i40e_txd_use_count(size);\n\n\t\tif (!nr_frags--)\n\t\t\tbreak;\n\n\t\tsize = skb_frag_size(frag++);\n\t}\n\n\treturn count;\n}\n\n \nstatic inline int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)\n{\n\tif (likely(I40E_DESC_UNUSED(tx_ring) >= size))\n\t\treturn 0;\n\treturn __i40e_maybe_stop_tx(tx_ring, size);\n}\n\n \nstatic inline bool i40e_chk_linearize(struct sk_buff *skb, int count)\n{\n\t \n\tif (likely(count < I40E_MAX_BUFFER_TXD))\n\t\treturn false;\n\n\tif (skb_is_gso(skb))\n\t\treturn __i40e_chk_linearize(skb);\n\n\t \n\treturn count != I40E_MAX_BUFFER_TXD;\n}\n\n \nstatic inline struct netdev_queue *txring_txq(const struct i40e_ring *ring)\n{\n\treturn netdev_get_tx_queue(ring->netdev, ring->queue_index);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}