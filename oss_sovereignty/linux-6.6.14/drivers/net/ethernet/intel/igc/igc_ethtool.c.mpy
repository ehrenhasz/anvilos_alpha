{
  "module_name": "igc_ethtool.c",
  "hash_id": "f298889c62753875d4a4ac18b9267c3feb357496850c580bf7698849e33e2e5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_ethtool.c",
  "human_readable_source": "\n \n\n \n#include <linux/if_vlan.h>\n#include <linux/pm_runtime.h>\n#include <linux/mdio.h>\n\n#include \"igc.h\"\n#include \"igc_diag.h\"\n\n \nstruct igc_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define IGC_STAT(_name, _stat) { \\\n\t.stat_string = _name, \\\n\t.sizeof_stat = sizeof_field(struct igc_adapter, _stat), \\\n\t.stat_offset = offsetof(struct igc_adapter, _stat) \\\n}\n\nstatic const struct igc_stats igc_gstrings_stats[] = {\n\tIGC_STAT(\"rx_packets\", stats.gprc),\n\tIGC_STAT(\"tx_packets\", stats.gptc),\n\tIGC_STAT(\"rx_bytes\", stats.gorc),\n\tIGC_STAT(\"tx_bytes\", stats.gotc),\n\tIGC_STAT(\"rx_broadcast\", stats.bprc),\n\tIGC_STAT(\"tx_broadcast\", stats.bptc),\n\tIGC_STAT(\"rx_multicast\", stats.mprc),\n\tIGC_STAT(\"tx_multicast\", stats.mptc),\n\tIGC_STAT(\"multicast\", stats.mprc),\n\tIGC_STAT(\"collisions\", stats.colc),\n\tIGC_STAT(\"rx_crc_errors\", stats.crcerrs),\n\tIGC_STAT(\"rx_no_buffer_count\", stats.rnbc),\n\tIGC_STAT(\"rx_missed_errors\", stats.mpc),\n\tIGC_STAT(\"tx_aborted_errors\", stats.ecol),\n\tIGC_STAT(\"tx_carrier_errors\", stats.tncrs),\n\tIGC_STAT(\"tx_window_errors\", stats.latecol),\n\tIGC_STAT(\"tx_abort_late_coll\", stats.latecol),\n\tIGC_STAT(\"tx_deferred_ok\", stats.dc),\n\tIGC_STAT(\"tx_single_coll_ok\", stats.scc),\n\tIGC_STAT(\"tx_multi_coll_ok\", stats.mcc),\n\tIGC_STAT(\"tx_timeout_count\", tx_timeout_count),\n\tIGC_STAT(\"rx_long_length_errors\", stats.roc),\n\tIGC_STAT(\"rx_short_length_errors\", stats.ruc),\n\tIGC_STAT(\"rx_align_errors\", stats.algnerrc),\n\tIGC_STAT(\"tx_tcp_seg_good\", stats.tsctc),\n\tIGC_STAT(\"tx_tcp_seg_failed\", stats.tsctfc),\n\tIGC_STAT(\"rx_flow_control_xon\", stats.xonrxc),\n\tIGC_STAT(\"rx_flow_control_xoff\", stats.xoffrxc),\n\tIGC_STAT(\"tx_flow_control_xon\", stats.xontxc),\n\tIGC_STAT(\"tx_flow_control_xoff\", stats.xofftxc),\n\tIGC_STAT(\"rx_long_byte_count\", stats.gorc),\n\tIGC_STAT(\"tx_dma_out_of_sync\", stats.doosync),\n\tIGC_STAT(\"tx_smbus\", stats.mgptc),\n\tIGC_STAT(\"rx_smbus\", stats.mgprc),\n\tIGC_STAT(\"dropped_smbus\", stats.mgpdc),\n\tIGC_STAT(\"os2bmc_rx_by_bmc\", stats.o2bgptc),\n\tIGC_STAT(\"os2bmc_tx_by_bmc\", stats.b2ospc),\n\tIGC_STAT(\"os2bmc_tx_by_host\", stats.o2bspc),\n\tIGC_STAT(\"os2bmc_rx_by_host\", stats.b2ogprc),\n\tIGC_STAT(\"tx_hwtstamp_timeouts\", tx_hwtstamp_timeouts),\n\tIGC_STAT(\"tx_hwtstamp_skipped\", tx_hwtstamp_skipped),\n\tIGC_STAT(\"rx_hwtstamp_cleared\", rx_hwtstamp_cleared),\n\tIGC_STAT(\"tx_lpi_counter\", stats.tlpic),\n\tIGC_STAT(\"rx_lpi_counter\", stats.rlpic),\n\tIGC_STAT(\"qbv_config_change_errors\", qbv_config_change_errors),\n};\n\n#define IGC_NETDEV_STAT(_net_stat) { \\\n\t.stat_string = __stringify(_net_stat), \\\n\t.sizeof_stat = sizeof_field(struct rtnl_link_stats64, _net_stat), \\\n\t.stat_offset = offsetof(struct rtnl_link_stats64, _net_stat) \\\n}\n\nstatic const struct igc_stats igc_gstrings_net_stats[] = {\n\tIGC_NETDEV_STAT(rx_errors),\n\tIGC_NETDEV_STAT(tx_errors),\n\tIGC_NETDEV_STAT(tx_dropped),\n\tIGC_NETDEV_STAT(rx_length_errors),\n\tIGC_NETDEV_STAT(rx_over_errors),\n\tIGC_NETDEV_STAT(rx_frame_errors),\n\tIGC_NETDEV_STAT(rx_fifo_errors),\n\tIGC_NETDEV_STAT(tx_fifo_errors),\n\tIGC_NETDEV_STAT(tx_heartbeat_errors)\n};\n\nenum igc_diagnostics_results {\n\tTEST_REG = 0,\n\tTEST_EEP,\n\tTEST_IRQ,\n\tTEST_LOOP,\n\tTEST_LINK\n};\n\nstatic const char igc_gstrings_test[][ETH_GSTRING_LEN] = {\n\t[TEST_REG]  = \"Register test  (offline)\",\n\t[TEST_EEP]  = \"Eeprom test    (offline)\",\n\t[TEST_IRQ]  = \"Interrupt test (offline)\",\n\t[TEST_LOOP] = \"Loopback test  (offline)\",\n\t[TEST_LINK] = \"Link test   (on/offline)\"\n};\n\n#define IGC_TEST_LEN (sizeof(igc_gstrings_test) / ETH_GSTRING_LEN)\n\n#define IGC_GLOBAL_STATS_LEN\t\\\n\t(sizeof(igc_gstrings_stats) / sizeof(struct igc_stats))\n#define IGC_NETDEV_STATS_LEN\t\\\n\t(sizeof(igc_gstrings_net_stats) / sizeof(struct igc_stats))\n#define IGC_RX_QUEUE_STATS_LEN \\\n\t(sizeof(struct igc_rx_queue_stats) / sizeof(u64))\n#define IGC_TX_QUEUE_STATS_LEN 3  \n#define IGC_QUEUE_STATS_LEN \\\n\t((((struct igc_adapter *)netdev_priv(netdev))->num_rx_queues * \\\n\t  IGC_RX_QUEUE_STATS_LEN) + \\\n\t (((struct igc_adapter *)netdev_priv(netdev))->num_tx_queues * \\\n\t  IGC_TX_QUEUE_STATS_LEN))\n#define IGC_STATS_LEN \\\n\t(IGC_GLOBAL_STATS_LEN + IGC_NETDEV_STATS_LEN + IGC_QUEUE_STATS_LEN)\n\nstatic const char igc_priv_flags_strings[][ETH_GSTRING_LEN] = {\n#define IGC_PRIV_FLAGS_LEGACY_RX\tBIT(0)\n\t\"legacy-rx\",\n};\n\n#define IGC_PRIV_FLAGS_STR_LEN ARRAY_SIZE(igc_priv_flags_strings)\n\nstatic void igc_ethtool_get_drvinfo(struct net_device *netdev,\n\t\t\t\t    struct ethtool_drvinfo *drvinfo)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tu16 nvm_version = 0;\n\tu16 gphy_version;\n\n\tstrscpy(drvinfo->driver, igc_driver_name, sizeof(drvinfo->driver));\n\n\t \n\thw->nvm.ops.read(hw, IGC_NVM_DEV_STARTER, 1, &nvm_version);\n\n\t \n\tgphy_version = igc_read_phy_fw_version(hw);\n\n\tscnprintf(adapter->fw_version,\n\t\t  sizeof(adapter->fw_version),\n\t\t  \"%x:%x\",\n\t\t  nvm_version,\n\t\t  gphy_version);\n\n\tstrscpy(drvinfo->fw_version, adapter->fw_version,\n\t\tsizeof(drvinfo->fw_version));\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\n\tdrvinfo->n_priv_flags = IGC_PRIV_FLAGS_STR_LEN;\n}\n\nstatic int igc_ethtool_get_regs_len(struct net_device *netdev)\n{\n\treturn IGC_REGS_LEN * sizeof(u32);\n}\n\nstatic void igc_ethtool_get_regs(struct net_device *netdev,\n\t\t\t\t struct ethtool_regs *regs, void *p)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu8 i;\n\n\tmemset(p, 0, IGC_REGS_LEN * sizeof(u32));\n\n\tregs->version = (2u << 24) | (hw->revision_id << 16) | hw->device_id;\n\n\t \n\tregs_buff[0] = rd32(IGC_CTRL);\n\tregs_buff[1] = rd32(IGC_STATUS);\n\tregs_buff[2] = rd32(IGC_CTRL_EXT);\n\tregs_buff[3] = rd32(IGC_MDIC);\n\tregs_buff[4] = rd32(IGC_CONNSW);\n\n\t \n\tregs_buff[5] = rd32(IGC_EECD);\n\n\t \n\t \n\tregs_buff[6] = rd32(IGC_EICS);\n\tregs_buff[7] = rd32(IGC_EICS);\n\tregs_buff[8] = rd32(IGC_EIMS);\n\tregs_buff[9] = rd32(IGC_EIMC);\n\tregs_buff[10] = rd32(IGC_EIAC);\n\tregs_buff[11] = rd32(IGC_EIAM);\n\t \n\tregs_buff[12] = rd32(IGC_ICS);\n\tregs_buff[13] = rd32(IGC_ICS);\n\tregs_buff[14] = rd32(IGC_IMS);\n\tregs_buff[15] = rd32(IGC_IMC);\n\tregs_buff[16] = rd32(IGC_IAC);\n\tregs_buff[17] = rd32(IGC_IAM);\n\n\t \n\tregs_buff[18] = rd32(IGC_FCAL);\n\tregs_buff[19] = rd32(IGC_FCAH);\n\tregs_buff[20] = rd32(IGC_FCTTV);\n\tregs_buff[21] = rd32(IGC_FCRTL);\n\tregs_buff[22] = rd32(IGC_FCRTH);\n\tregs_buff[23] = rd32(IGC_FCRTV);\n\n\t \n\tregs_buff[24] = rd32(IGC_RCTL);\n\tregs_buff[25] = rd32(IGC_RXCSUM);\n\tregs_buff[26] = rd32(IGC_RLPML);\n\tregs_buff[27] = rd32(IGC_RFCTL);\n\n\t \n\tregs_buff[28] = rd32(IGC_TCTL);\n\tregs_buff[29] = rd32(IGC_TIPG);\n\n\t \n\n\t \n\n\t \n\tregs_buff[30] = adapter->stats.crcerrs;\n\tregs_buff[31] = adapter->stats.algnerrc;\n\tregs_buff[32] = adapter->stats.symerrs;\n\tregs_buff[33] = adapter->stats.rxerrc;\n\tregs_buff[34] = adapter->stats.mpc;\n\tregs_buff[35] = adapter->stats.scc;\n\tregs_buff[36] = adapter->stats.ecol;\n\tregs_buff[37] = adapter->stats.mcc;\n\tregs_buff[38] = adapter->stats.latecol;\n\tregs_buff[39] = adapter->stats.colc;\n\tregs_buff[40] = adapter->stats.dc;\n\tregs_buff[41] = adapter->stats.tncrs;\n\tregs_buff[42] = adapter->stats.sec;\n\tregs_buff[43] = adapter->stats.htdpmc;\n\tregs_buff[44] = adapter->stats.rlec;\n\tregs_buff[45] = adapter->stats.xonrxc;\n\tregs_buff[46] = adapter->stats.xontxc;\n\tregs_buff[47] = adapter->stats.xoffrxc;\n\tregs_buff[48] = adapter->stats.xofftxc;\n\tregs_buff[49] = adapter->stats.fcruc;\n\tregs_buff[50] = adapter->stats.prc64;\n\tregs_buff[51] = adapter->stats.prc127;\n\tregs_buff[52] = adapter->stats.prc255;\n\tregs_buff[53] = adapter->stats.prc511;\n\tregs_buff[54] = adapter->stats.prc1023;\n\tregs_buff[55] = adapter->stats.prc1522;\n\tregs_buff[56] = adapter->stats.gprc;\n\tregs_buff[57] = adapter->stats.bprc;\n\tregs_buff[58] = adapter->stats.mprc;\n\tregs_buff[59] = adapter->stats.gptc;\n\tregs_buff[60] = adapter->stats.gorc;\n\tregs_buff[61] = adapter->stats.gotc;\n\tregs_buff[62] = adapter->stats.rnbc;\n\tregs_buff[63] = adapter->stats.ruc;\n\tregs_buff[64] = adapter->stats.rfc;\n\tregs_buff[65] = adapter->stats.roc;\n\tregs_buff[66] = adapter->stats.rjc;\n\tregs_buff[67] = adapter->stats.mgprc;\n\tregs_buff[68] = adapter->stats.mgpdc;\n\tregs_buff[69] = adapter->stats.mgptc;\n\tregs_buff[70] = adapter->stats.tor;\n\tregs_buff[71] = adapter->stats.tot;\n\tregs_buff[72] = adapter->stats.tpr;\n\tregs_buff[73] = adapter->stats.tpt;\n\tregs_buff[74] = adapter->stats.ptc64;\n\tregs_buff[75] = adapter->stats.ptc127;\n\tregs_buff[76] = adapter->stats.ptc255;\n\tregs_buff[77] = adapter->stats.ptc511;\n\tregs_buff[78] = adapter->stats.ptc1023;\n\tregs_buff[79] = adapter->stats.ptc1522;\n\tregs_buff[80] = adapter->stats.mptc;\n\tregs_buff[81] = adapter->stats.bptc;\n\tregs_buff[82] = adapter->stats.tsctc;\n\tregs_buff[83] = adapter->stats.iac;\n\tregs_buff[84] = adapter->stats.rpthc;\n\tregs_buff[85] = adapter->stats.hgptc;\n\tregs_buff[86] = adapter->stats.hgorc;\n\tregs_buff[87] = adapter->stats.hgotc;\n\tregs_buff[88] = adapter->stats.lenerrs;\n\tregs_buff[89] = adapter->stats.scvpc;\n\tregs_buff[90] = adapter->stats.hrmpc;\n\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[91 + i] = rd32(IGC_SRRCTL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[95 + i] = rd32(IGC_PSRTYPE(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[99 + i] = rd32(IGC_RDBAL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[103 + i] = rd32(IGC_RDBAH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[107 + i] = rd32(IGC_RDLEN(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[111 + i] = rd32(IGC_RDH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[115 + i] = rd32(IGC_RDT(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[119 + i] = rd32(IGC_RXDCTL(i));\n\n\tfor (i = 0; i < 10; i++)\n\t\tregs_buff[123 + i] = rd32(IGC_EITR(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[139 + i] = rd32(IGC_RAL(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[145 + i] = rd32(IGC_RAH(i));\n\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[149 + i] = rd32(IGC_TDBAL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[152 + i] = rd32(IGC_TDBAH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[156 + i] = rd32(IGC_TDLEN(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[160 + i] = rd32(IGC_TDH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[164 + i] = rd32(IGC_TDT(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[168 + i] = rd32(IGC_TXDCTL(i));\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[172 + i] = rd32(IGC_RAL(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[188 + i] = rd32(IGC_RAH(i));\n\n\tregs_buff[204] = rd32(IGC_VLANPQF);\n\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[205 + i] = rd32(IGC_ETQF(i));\n\n\tregs_buff[213] = adapter->stats.tlpic;\n\tregs_buff[214] = adapter->stats.rlpic;\n}\n\nstatic void igc_ethtool_get_wol(struct net_device *netdev,\n\t\t\t\tstruct ethtool_wolinfo *wol)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\twol->wolopts = 0;\n\n\tif (!(adapter->flags & IGC_FLAG_WOL_SUPPORTED))\n\t\treturn;\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST |\n\t\t\t WAKE_BCAST | WAKE_MAGIC |\n\t\t\t WAKE_PHY;\n\n\t \n\tswitch (adapter->hw.device_id) {\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adapter->wol & IGC_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & IGC_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & IGC_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & IGC_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tif (adapter->wol & IGC_WUFC_LNKC)\n\t\twol->wolopts |= WAKE_PHY;\n}\n\nstatic int igc_ethtool_set_wol(struct net_device *netdev,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\tif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE | WAKE_FILTER))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(adapter->flags & IGC_FLAG_WOL_SUPPORTED))\n\t\treturn wol->wolopts ? -EOPNOTSUPP : 0;\n\n\t \n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_UCAST)\n\t\tadapter->wol |= IGC_WUFC_EX;\n\tif (wol->wolopts & WAKE_MCAST)\n\t\tadapter->wol |= IGC_WUFC_MC;\n\tif (wol->wolopts & WAKE_BCAST)\n\t\tadapter->wol |= IGC_WUFC_BC;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= IGC_WUFC_MAG;\n\tif (wol->wolopts & WAKE_PHY)\n\t\tadapter->wol |= IGC_WUFC_LNKC;\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\nstatic u32 igc_ethtool_get_msglevel(struct net_device *netdev)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->msg_enable;\n}\n\nstatic void igc_ethtool_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->msg_enable = data;\n}\n\nstatic int igc_ethtool_nway_reset(struct net_device *netdev)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\tigc_reinit_locked(adapter);\n\treturn 0;\n}\n\nstatic u32 igc_ethtool_get_link(struct net_device *netdev)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_mac_info *mac = &adapter->hw.mac;\n\n\t \n\tif (!netif_carrier_ok(netdev))\n\t\tmac->get_link_status = 1;\n\n\treturn igc_has_link(adapter);\n}\n\nstatic int igc_ethtool_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->hw.nvm.word_size * 2;\n}\n\nstatic int igc_ethtool_get_eeprom(struct net_device *netdev,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tint first_word, last_word;\n\tu16 *eeprom_buff;\n\tint ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tif (hw->nvm.type == igc_nvm_eeprom_spi) {\n\t\tret_val = hw->nvm.ops.read(hw, first_word,\n\t\t\t\t\t   last_word - first_word + 1,\n\t\t\t\t\t   eeprom_buff);\n\t} else {\n\t\tfor (i = 0; i < last_word - first_word + 1; i++) {\n\t\t\tret_val = hw->nvm.ops.read(hw, first_word + i, 1,\n\t\t\t\t\t\t   &eeprom_buff[i]);\n\t\t\tif (ret_val)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1),\n\t       eeprom->len);\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n}\n\nstatic int igc_ethtool_set_eeprom(struct net_device *netdev,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tint max_len, first_word, last_word, ret_val = 0;\n\tu16 *eeprom_buff;\n\tvoid *ptr;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hw->mac.type >= igc_i225 &&\n\t    !igc_get_flash_presence_i225(hw)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\n\t\treturn -EFAULT;\n\n\tmax_len = hw->nvm.word_size * 2;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_buff = kmalloc(max_len, GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tptr = (void *)eeprom_buff;\n\n\tif (eeprom->offset & 1) {\n\t\t \n\t\tret_val = hw->nvm.ops.read(hw, first_word, 1,\n\t\t\t\t\t    &eeprom_buff[0]);\n\t\tptr++;\n\t}\n\tif (((eeprom->offset + eeprom->len) & 1) && ret_val == 0) {\n\t\t \n\t\tret_val = hw->nvm.ops.read(hw, last_word, 1,\n\t\t\t\t   &eeprom_buff[last_word - first_word]);\n\t}\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(ptr, bytes, eeprom->len);\n\n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tcpu_to_le16s(&eeprom_buff[i]);\n\n\tret_val = hw->nvm.ops.write(hw, first_word,\n\t\t\t\t    last_word - first_word + 1, eeprom_buff);\n\n\t \n\tif (ret_val == 0)\n\t\thw->nvm.ops.update(hw);\n\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic void\nigc_ethtool_get_ringparam(struct net_device *netdev,\n\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\tring->rx_max_pending = IGC_MAX_RXD;\n\tring->tx_max_pending = IGC_MAX_TXD;\n\tring->rx_pending = adapter->rx_ring_count;\n\tring->tx_pending = adapter->tx_ring_count;\n}\n\nstatic int\nigc_ethtool_set_ringparam(struct net_device *netdev,\n\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_ring *temp_ring;\n\tu16 new_rx_count, new_tx_count;\n\tint i, err = 0;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending)\n\t\treturn -EINVAL;\n\n\tnew_rx_count = min_t(u32, ring->rx_pending, IGC_MAX_RXD);\n\tnew_rx_count = max_t(u16, new_rx_count, IGC_MIN_RXD);\n\tnew_rx_count = ALIGN(new_rx_count, REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\tnew_tx_count = min_t(u32, ring->tx_pending, IGC_MAX_TXD);\n\tnew_tx_count = max_t(u16, new_tx_count, IGC_MIN_TXD);\n\tnew_tx_count = ALIGN(new_tx_count, REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tif (new_tx_count == adapter->tx_ring_count &&\n\t    new_rx_count == adapter->rx_ring_count) {\n\t\t \n\t\treturn 0;\n\t}\n\n\twhile (test_and_set_bit(__IGC_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(adapter->netdev)) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\tadapter->tx_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\tadapter->rx_ring[i]->count = new_rx_count;\n\t\tadapter->tx_ring_count = new_tx_count;\n\t\tadapter->rx_ring_count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\tif (adapter->num_tx_queues > adapter->num_rx_queues)\n\t\ttemp_ring = vmalloc(array_size(sizeof(struct igc_ring),\n\t\t\t\t\t       adapter->num_tx_queues));\n\telse\n\t\ttemp_ring = vmalloc(array_size(sizeof(struct igc_ring),\n\t\t\t\t\t       adapter->num_rx_queues));\n\n\tif (!temp_ring) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_reset;\n\t}\n\n\tigc_down(adapter);\n\n\t \n\tif (new_tx_count != adapter->tx_ring_count) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->tx_ring[i],\n\t\t\t       sizeof(struct igc_ring));\n\n\t\t\ttemp_ring[i].count = new_tx_count;\n\t\t\terr = igc_setup_tx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tigc_free_tx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tigc_free_tx_resources(adapter->tx_ring[i]);\n\n\t\t\tmemcpy(adapter->tx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct igc_ring));\n\t\t}\n\n\t\tadapter->tx_ring_count = new_tx_count;\n\t}\n\n\tif (new_rx_count != adapter->rx_ring_count) {\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->rx_ring[i],\n\t\t\t       sizeof(struct igc_ring));\n\n\t\t\ttemp_ring[i].count = new_rx_count;\n\t\t\terr = igc_setup_rx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tigc_free_rx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tigc_free_rx_resources(adapter->rx_ring[i]);\n\n\t\t\tmemcpy(adapter->rx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct igc_ring));\n\t\t}\n\n\t\tadapter->rx_ring_count = new_rx_count;\n\t}\nerr_setup:\n\tigc_up(adapter);\n\tvfree(temp_ring);\nclear_reset:\n\tclear_bit(__IGC_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic void igc_ethtool_get_pauseparam(struct net_device *netdev,\n\t\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\n\tpause->autoneg =\n\t\t(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);\n\n\tif (hw->fc.current_mode == igc_fc_rx_pause) {\n\t\tpause->rx_pause = 1;\n\t} else if (hw->fc.current_mode == igc_fc_tx_pause) {\n\t\tpause->tx_pause = 1;\n\t} else if (hw->fc.current_mode == igc_fc_full) {\n\t\tpause->rx_pause = 1;\n\t\tpause->tx_pause = 1;\n\t}\n}\n\nstatic int igc_ethtool_set_pauseparam(struct net_device *netdev,\n\t\t\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tint retval = 0;\n\n\tadapter->fc_autoneg = pause->autoneg;\n\n\twhile (test_and_set_bit(__IGC_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (adapter->fc_autoneg == AUTONEG_ENABLE) {\n\t\thw->fc.requested_mode = igc_fc_default;\n\t\tif (netif_running(adapter->netdev)) {\n\t\t\tigc_down(adapter);\n\t\t\tigc_up(adapter);\n\t\t} else {\n\t\t\tigc_reset(adapter);\n\t\t}\n\t} else {\n\t\tif (pause->rx_pause && pause->tx_pause)\n\t\t\thw->fc.requested_mode = igc_fc_full;\n\t\telse if (pause->rx_pause && !pause->tx_pause)\n\t\t\thw->fc.requested_mode = igc_fc_rx_pause;\n\t\telse if (!pause->rx_pause && pause->tx_pause)\n\t\t\thw->fc.requested_mode = igc_fc_tx_pause;\n\t\telse if (!pause->rx_pause && !pause->tx_pause)\n\t\t\thw->fc.requested_mode = igc_fc_none;\n\n\t\thw->fc.current_mode = hw->fc.requested_mode;\n\n\t\tretval = ((hw->phy.media_type == igc_media_type_copper) ?\n\t\t\t  igc_force_mac_fc(hw) : igc_setup_link(hw));\n\t}\n\n\tclear_bit(__IGC_RESETTING, &adapter->state);\n\treturn retval;\n}\n\nstatic void igc_ethtool_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t\t    u8 *data)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, *igc_gstrings_test,\n\t\t       IGC_TEST_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < IGC_GLOBAL_STATS_LEN; i++)\n\t\t\tethtool_sprintf(&p, igc_gstrings_stats[i].stat_string);\n\t\tfor (i = 0; i < IGC_NETDEV_STATS_LEN; i++)\n\t\t\tethtool_sprintf(&p,\n\t\t\t\t\tigc_gstrings_net_stats[i].stat_string);\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_bytes\", i);\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_restart\", i);\n\t\t}\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_bytes\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_drops\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_csum_err\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_alloc_failed\", i);\n\t\t}\n\t\t \n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(data, igc_priv_flags_strings,\n\t\t       IGC_PRIV_FLAGS_STR_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic int igc_ethtool_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn IGC_STATS_LEN;\n\tcase ETH_SS_TEST:\n\t\treturn IGC_TEST_LEN;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn IGC_PRIV_FLAGS_STR_LEN;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic void igc_ethtool_get_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct rtnl_link_stats64 *net_stats = &adapter->stats64;\n\tunsigned int start;\n\tstruct igc_ring *ring;\n\tint i, j;\n\tchar *p;\n\n\tspin_lock(&adapter->stats64_lock);\n\tigc_update_stats(adapter);\n\n\tfor (i = 0; i < IGC_GLOBAL_STATS_LEN; i++) {\n\t\tp = (char *)adapter + igc_gstrings_stats[i].stat_offset;\n\t\tdata[i] = (igc_gstrings_stats[i].sizeof_stat ==\n\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\tfor (j = 0; j < IGC_NETDEV_STATS_LEN; j++, i++) {\n\t\tp = (char *)net_stats + igc_gstrings_net_stats[j].stat_offset;\n\t\tdata[i] = (igc_gstrings_net_stats[j].sizeof_stat ==\n\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\tfor (j = 0; j < adapter->num_tx_queues; j++) {\n\t\tu64\trestart2;\n\n\t\tring = adapter->tx_ring[j];\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->tx_syncp);\n\t\t\tdata[i]   = ring->tx_stats.packets;\n\t\t\tdata[i + 1] = ring->tx_stats.bytes;\n\t\t\tdata[i + 2] = ring->tx_stats.restart_queue;\n\t\t} while (u64_stats_fetch_retry(&ring->tx_syncp, start));\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->tx_syncp2);\n\t\t\trestart2  = ring->tx_stats.restart_queue2;\n\t\t} while (u64_stats_fetch_retry(&ring->tx_syncp2, start));\n\t\tdata[i + 2] += restart2;\n\n\t\ti += IGC_TX_QUEUE_STATS_LEN;\n\t}\n\tfor (j = 0; j < adapter->num_rx_queues; j++) {\n\t\tring = adapter->rx_ring[j];\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->rx_syncp);\n\t\t\tdata[i]   = ring->rx_stats.packets;\n\t\t\tdata[i + 1] = ring->rx_stats.bytes;\n\t\t\tdata[i + 2] = ring->rx_stats.drops;\n\t\t\tdata[i + 3] = ring->rx_stats.csum_err;\n\t\t\tdata[i + 4] = ring->rx_stats.alloc_failed;\n\t\t} while (u64_stats_fetch_retry(&ring->rx_syncp, start));\n\t\ti += IGC_RX_QUEUE_STATS_LEN;\n\t}\n\tspin_unlock(&adapter->stats64_lock);\n}\n\nstatic int igc_ethtool_get_previous_rx_coalesce(struct igc_adapter *adapter)\n{\n\treturn (adapter->rx_itr_setting <= 3) ?\n\t\tadapter->rx_itr_setting : adapter->rx_itr_setting >> 2;\n}\n\nstatic int igc_ethtool_get_previous_tx_coalesce(struct igc_adapter *adapter)\n{\n\treturn (adapter->tx_itr_setting <= 3) ?\n\t\tadapter->tx_itr_setting : adapter->tx_itr_setting >> 2;\n}\n\nstatic int igc_ethtool_get_coalesce(struct net_device *netdev,\n\t\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\tec->rx_coalesce_usecs = igc_ethtool_get_previous_rx_coalesce(adapter);\n\tec->tx_coalesce_usecs = igc_ethtool_get_previous_tx_coalesce(adapter);\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_set_coalesce(struct net_device *netdev,\n\t\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\n\tif (ec->rx_coalesce_usecs > IGC_MAX_ITR_USECS ||\n\t    (ec->rx_coalesce_usecs > 3 &&\n\t     ec->rx_coalesce_usecs < IGC_MIN_ITR_USECS) ||\n\t    ec->rx_coalesce_usecs == 2)\n\t\treturn -EINVAL;\n\n\tif (ec->tx_coalesce_usecs > IGC_MAX_ITR_USECS ||\n\t    (ec->tx_coalesce_usecs > 3 &&\n\t     ec->tx_coalesce_usecs < IGC_MIN_ITR_USECS) ||\n\t    ec->tx_coalesce_usecs == 2)\n\t\treturn -EINVAL;\n\n\tif ((adapter->flags & IGC_FLAG_QUEUE_PAIRS) &&\n\t    ec->tx_coalesce_usecs != igc_ethtool_get_previous_tx_coalesce(adapter)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Queue Pair mode enabled, both Rx and Tx coalescing controlled by rx-usecs\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ec->rx_coalesce_usecs == 0) {\n\t\tif (adapter->flags & IGC_FLAG_DMAC)\n\t\t\tadapter->flags &= ~IGC_FLAG_DMAC;\n\t}\n\n\t \n\tif (ec->rx_coalesce_usecs && ec->rx_coalesce_usecs <= 3)\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs;\n\telse\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs << 2;\n\n\t \n\tif (adapter->flags & IGC_FLAG_QUEUE_PAIRS)\n\t\tadapter->tx_itr_setting = adapter->rx_itr_setting;\n\telse if (ec->tx_coalesce_usecs && ec->tx_coalesce_usecs <= 3)\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs;\n\telse\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs << 2;\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++) {\n\t\tstruct igc_q_vector *q_vector = adapter->q_vector[i];\n\n\t\tq_vector->tx.work_limit = adapter->tx_work_limit;\n\t\tif (q_vector->rx.ring)\n\t\t\tq_vector->itr_val = adapter->rx_itr_setting;\n\t\telse\n\t\t\tq_vector->itr_val = adapter->tx_itr_setting;\n\t\tif (q_vector->itr_val && q_vector->itr_val <= 3)\n\t\t\tq_vector->itr_val = IGC_START_ITR;\n\t\tq_vector->set_itr = 1;\n\t}\n\n\treturn 0;\n}\n\n#define ETHER_TYPE_FULL_MASK ((__force __be16)~0)\n#define VLAN_TCI_FULL_MASK ((__force __be16)~0)\nstatic int igc_ethtool_get_nfc_rule(struct igc_adapter *adapter,\n\t\t\t\t    struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp = &cmd->fs;\n\tstruct igc_nfc_rule *rule = NULL;\n\n\tcmd->data = IGC_MAX_RXNFC_RULES;\n\n\tmutex_lock(&adapter->nfc_rule_lock);\n\n\trule = igc_get_nfc_rule(adapter, fsp->location);\n\tif (!rule)\n\t\tgoto out;\n\n\tfsp->flow_type = ETHER_FLOW;\n\tfsp->ring_cookie = rule->action;\n\n\tif (rule->filter.match_flags & IGC_FILTER_FLAG_ETHER_TYPE) {\n\t\tfsp->h_u.ether_spec.h_proto = htons(rule->filter.etype);\n\t\tfsp->m_u.ether_spec.h_proto = ETHER_TYPE_FULL_MASK;\n\t}\n\n\tif (rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_ETYPE) {\n\t\tfsp->flow_type |= FLOW_EXT;\n\t\tfsp->h_ext.vlan_etype = rule->filter.vlan_etype;\n\t\tfsp->m_ext.vlan_etype = ETHER_TYPE_FULL_MASK;\n\t}\n\n\tif (rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_TCI) {\n\t\tfsp->flow_type |= FLOW_EXT;\n\t\tfsp->h_ext.vlan_tci = htons(rule->filter.vlan_tci);\n\t\tfsp->m_ext.vlan_tci = htons(rule->filter.vlan_tci_mask);\n\t}\n\n\tif (rule->filter.match_flags & IGC_FILTER_FLAG_DST_MAC_ADDR) {\n\t\tether_addr_copy(fsp->h_u.ether_spec.h_dest,\n\t\t\t\trule->filter.dst_addr);\n\t\teth_broadcast_addr(fsp->m_u.ether_spec.h_dest);\n\t}\n\n\tif (rule->filter.match_flags & IGC_FILTER_FLAG_SRC_MAC_ADDR) {\n\t\tether_addr_copy(fsp->h_u.ether_spec.h_source,\n\t\t\t\trule->filter.src_addr);\n\t\teth_broadcast_addr(fsp->m_u.ether_spec.h_source);\n\t}\n\n\tif (rule->filter.match_flags & IGC_FILTER_FLAG_USER_DATA) {\n\t\tfsp->flow_type |= FLOW_EXT;\n\t\tmemcpy(fsp->h_ext.data, rule->filter.user_data, sizeof(fsp->h_ext.data));\n\t\tmemcpy(fsp->m_ext.data, rule->filter.user_mask, sizeof(fsp->m_ext.data));\n\t}\n\n\tmutex_unlock(&adapter->nfc_rule_lock);\n\treturn 0;\n\nout:\n\tmutex_unlock(&adapter->nfc_rule_lock);\n\treturn -EINVAL;\n}\n\nstatic int igc_ethtool_get_nfc_rules(struct igc_adapter *adapter,\n\t\t\t\t     struct ethtool_rxnfc *cmd,\n\t\t\t\t     u32 *rule_locs)\n{\n\tstruct igc_nfc_rule *rule;\n\tint cnt = 0;\n\n\tcmd->data = IGC_MAX_RXNFC_RULES;\n\n\tmutex_lock(&adapter->nfc_rule_lock);\n\n\tlist_for_each_entry(rule, &adapter->nfc_rule_list, list) {\n\t\tif (cnt == cmd->rule_cnt) {\n\t\t\tmutex_unlock(&adapter->nfc_rule_lock);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\trule_locs[cnt] = rule->location;\n\t\tcnt++;\n\t}\n\n\tmutex_unlock(&adapter->nfc_rule_lock);\n\n\tcmd->rule_cnt = cnt;\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_get_rss_hash_opts(struct igc_adapter *adapter,\n\t\t\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tcmd->data = 0;\n\n\t \n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase UDP_V4_FLOW:\n\t\tif (adapter->flags & IGC_FLAG_RSS_FIELD_IPV4_UDP)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase UDP_V6_FLOW:\n\t\tif (adapter->flags & IGC_FLAG_RSS_FIELD_IPV6_UDP)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t struct ethtool_rxnfc *cmd, u32 *rule_locs)\n{\n\tstruct igc_adapter *adapter = netdev_priv(dev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = adapter->num_rx_queues;\n\t\treturn 0;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = adapter->nfc_rule_count;\n\t\treturn 0;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\treturn igc_ethtool_get_nfc_rule(adapter, cmd);\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\treturn igc_ethtool_get_nfc_rules(adapter, cmd, rule_locs);\n\tcase ETHTOOL_GRXFH:\n\t\treturn igc_ethtool_get_rss_hash_opts(adapter, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n#define UDP_RSS_FLAGS (IGC_FLAG_RSS_FIELD_IPV4_UDP | \\\n\t\t       IGC_FLAG_RSS_FIELD_IPV6_UDP)\nstatic int igc_ethtool_set_rss_hash_opt(struct igc_adapter *adapter,\n\t\t\t\t\tstruct ethtool_rxnfc *nfc)\n{\n\tu32 flags = adapter->flags;\n\n\t \n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    !(nfc->data & RXH_L4_B_0_1) ||\n\t\t    !(nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tflags &= ~IGC_FLAG_RSS_FIELD_IPV4_UDP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tflags |= IGC_FLAG_RSS_FIELD_IPV4_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tflags &= ~IGC_FLAG_RSS_FIELD_IPV6_UDP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tflags |= IGC_FLAG_RSS_FIELD_IPV6_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    (nfc->data & RXH_L4_B_0_1) ||\n\t\t    (nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (flags != adapter->flags) {\n\t\tstruct igc_hw *hw = &adapter->hw;\n\t\tu32 mrqc = rd32(IGC_MRQC);\n\n\t\tif ((flags & UDP_RSS_FLAGS) &&\n\t\t    !(adapter->flags & UDP_RSS_FLAGS))\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"Enabling UDP RSS: fragmented packets may arrive out of order to the stack above\\n\");\n\n\t\tadapter->flags = flags;\n\n\t\t \n\t\tmrqc |= IGC_MRQC_RSS_FIELD_IPV4 |\n\t\t\tIGC_MRQC_RSS_FIELD_IPV4_TCP |\n\t\t\tIGC_MRQC_RSS_FIELD_IPV6 |\n\t\t\tIGC_MRQC_RSS_FIELD_IPV6_TCP;\n\n\t\tmrqc &= ~(IGC_MRQC_RSS_FIELD_IPV4_UDP |\n\t\t\t  IGC_MRQC_RSS_FIELD_IPV6_UDP);\n\n\t\tif (flags & IGC_FLAG_RSS_FIELD_IPV4_UDP)\n\t\t\tmrqc |= IGC_MRQC_RSS_FIELD_IPV4_UDP;\n\n\t\tif (flags & IGC_FLAG_RSS_FIELD_IPV6_UDP)\n\t\t\tmrqc |= IGC_MRQC_RSS_FIELD_IPV6_UDP;\n\n\t\twr32(IGC_MRQC, mrqc);\n\t}\n\n\treturn 0;\n}\n\nstatic void igc_ethtool_init_nfc_rule(struct igc_nfc_rule *rule,\n\t\t\t\t      const struct ethtool_rx_flow_spec *fsp)\n{\n\tINIT_LIST_HEAD(&rule->list);\n\n\trule->action = fsp->ring_cookie;\n\trule->location = fsp->location;\n\n\tif ((fsp->flow_type & FLOW_EXT) && fsp->m_ext.vlan_tci) {\n\t\trule->filter.vlan_tci = ntohs(fsp->h_ext.vlan_tci);\n\t\trule->filter.vlan_tci_mask = ntohs(fsp->m_ext.vlan_tci);\n\t\trule->filter.match_flags |= IGC_FILTER_FLAG_VLAN_TCI;\n\t}\n\n\tif (fsp->m_u.ether_spec.h_proto == ETHER_TYPE_FULL_MASK) {\n\t\trule->filter.etype = ntohs(fsp->h_u.ether_spec.h_proto);\n\t\trule->filter.match_flags = IGC_FILTER_FLAG_ETHER_TYPE;\n\t}\n\n\t \n\tif (is_broadcast_ether_addr(fsp->m_u.ether_spec.h_source)) {\n\t\trule->filter.match_flags |= IGC_FILTER_FLAG_SRC_MAC_ADDR;\n\t\tether_addr_copy(rule->filter.src_addr,\n\t\t\t\tfsp->h_u.ether_spec.h_source);\n\t}\n\n\tif (is_broadcast_ether_addr(fsp->m_u.ether_spec.h_dest)) {\n\t\trule->filter.match_flags |= IGC_FILTER_FLAG_DST_MAC_ADDR;\n\t\tether_addr_copy(rule->filter.dst_addr,\n\t\t\t\tfsp->h_u.ether_spec.h_dest);\n\t}\n\n\t \n\tif ((fsp->flow_type & FLOW_EXT) && fsp->h_ext.vlan_etype) {\n\t\trule->filter.vlan_etype = fsp->h_ext.vlan_etype;\n\t\trule->filter.match_flags |= IGC_FILTER_FLAG_VLAN_ETYPE;\n\t}\n\n\t \n\tif ((fsp->flow_type & FLOW_EXT) &&\n\t    (fsp->h_ext.data[0] || fsp->h_ext.data[1])) {\n\t\trule->filter.match_flags |= IGC_FILTER_FLAG_USER_DATA;\n\t\tmemcpy(rule->filter.user_data, fsp->h_ext.data, sizeof(fsp->h_ext.data));\n\t\tmemcpy(rule->filter.user_mask, fsp->m_ext.data, sizeof(fsp->m_ext.data));\n\t}\n\n\t \n\tif ((rule->filter.match_flags & IGC_FILTER_FLAG_USER_DATA) ||\n\t    (rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_ETYPE) ||\n\t    ((rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_TCI) &&\n\t     rule->filter.vlan_tci_mask == ntohs(VLAN_TCI_FULL_MASK)) ||\n\t    (rule->filter.match_flags & (rule->filter.match_flags - 1)))\n\t\trule->flex = true;\n\telse\n\t\trule->flex = false;\n}\n\n \nstatic int igc_ethtool_check_nfc_rule(struct igc_adapter *adapter,\n\t\t\t\t      struct igc_nfc_rule *rule)\n{\n\tstruct net_device *dev = adapter->netdev;\n\tu8 flags = rule->filter.match_flags;\n\tstruct igc_nfc_rule *tmp;\n\n\tif (!flags) {\n\t\tnetdev_dbg(dev, \"Rule with no match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(tmp, &adapter->nfc_rule_list, list) {\n\t\tif (!memcmp(&rule->filter, &tmp->filter,\n\t\t\t    sizeof(rule->filter)) &&\n\t\t    tmp->location != rule->location) {\n\t\t\tnetdev_dbg(dev, \"Rule already exists\\n\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_add_nfc_rule(struct igc_adapter *adapter,\n\t\t\t\t    struct ethtool_rxnfc *cmd)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct igc_nfc_rule *rule, *old_rule;\n\tint err;\n\n\tif (!(netdev->hw_features & NETIF_F_NTUPLE)) {\n\t\tnetdev_dbg(netdev, \"N-tuple filters disabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((fsp->flow_type & ~FLOW_EXT) != ETHER_FLOW) {\n\t\tnetdev_dbg(netdev, \"Only ethernet flow type is supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (fsp->ring_cookie >= adapter->num_rx_queues) {\n\t\tnetdev_dbg(netdev, \"Invalid action\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((fsp->flow_type & FLOW_EXT) &&\n\t    fsp->m_ext.vlan_tci &&\n\t    fsp->m_ext.vlan_tci != htons(VLAN_PRIO_MASK) &&\n\t    fsp->m_ext.vlan_tci != VLAN_TCI_FULL_MASK) {\n\t\tnetdev_dbg(netdev, \"VLAN mask not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif ((fsp->flow_type & FLOW_EXT) &&\n\t    fsp->m_ext.vlan_etype &&\n\t    fsp->m_ext.vlan_etype != ETHER_TYPE_FULL_MASK) {\n\t\tnetdev_dbg(netdev, \"VLAN EtherType mask not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (fsp->location >= IGC_MAX_RXNFC_RULES) {\n\t\tnetdev_dbg(netdev, \"Invalid location\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn -ENOMEM;\n\n\tigc_ethtool_init_nfc_rule(rule, fsp);\n\n\tmutex_lock(&adapter->nfc_rule_lock);\n\n\terr = igc_ethtool_check_nfc_rule(adapter, rule);\n\tif (err)\n\t\tgoto err;\n\n\told_rule = igc_get_nfc_rule(adapter, fsp->location);\n\tif (old_rule)\n\t\tigc_del_nfc_rule(adapter, old_rule);\n\n\terr = igc_add_nfc_rule(adapter, rule);\n\tif (err)\n\t\tgoto err;\n\n\tmutex_unlock(&adapter->nfc_rule_lock);\n\treturn 0;\n\nerr:\n\tmutex_unlock(&adapter->nfc_rule_lock);\n\tkfree(rule);\n\treturn err;\n}\n\nstatic int igc_ethtool_del_nfc_rule(struct igc_adapter *adapter,\n\t\t\t\t    struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct igc_nfc_rule *rule;\n\n\tmutex_lock(&adapter->nfc_rule_lock);\n\n\trule = igc_get_nfc_rule(adapter, fsp->location);\n\tif (!rule) {\n\t\tmutex_unlock(&adapter->nfc_rule_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tigc_del_nfc_rule(adapter, rule);\n\n\tmutex_unlock(&adapter->nfc_rule_lock);\n\treturn 0;\n}\n\nstatic int igc_ethtool_set_rxnfc(struct net_device *dev,\n\t\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tstruct igc_adapter *adapter = netdev_priv(dev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\treturn igc_ethtool_set_rss_hash_opt(adapter, cmd);\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\treturn igc_ethtool_add_nfc_rule(adapter, cmd);\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\treturn igc_ethtool_del_nfc_rule(adapter, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nvoid igc_write_rss_indir_tbl(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 reg = IGC_RETA(0);\n\tu32 shift = 0;\n\tint i = 0;\n\n\twhile (i < IGC_RETA_SIZE) {\n\t\tu32 val = 0;\n\t\tint j;\n\n\t\tfor (j = 3; j >= 0; j--) {\n\t\t\tval <<= 8;\n\t\t\tval |= adapter->rss_indir_tbl[i + j];\n\t\t}\n\n\t\twr32(reg, val << shift);\n\t\treg += 4;\n\t\ti += 4;\n\t}\n}\n\nstatic u32 igc_ethtool_get_rxfh_indir_size(struct net_device *netdev)\n{\n\treturn IGC_RETA_SIZE;\n}\n\nstatic int igc_ethtool_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t\tu8 *hfunc)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (!indir)\n\t\treturn 0;\n\tfor (i = 0; i < IGC_RETA_SIZE; i++)\n\t\tindir[i] = adapter->rss_indir_tbl[i];\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\t\tconst u8 *key, const u8 hfunc)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tu32 num_queues;\n\tint i;\n\n\t \n\tif (key ||\n\t    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\tif (!indir)\n\t\treturn 0;\n\n\tnum_queues = adapter->rss_queues;\n\n\t \n\tfor (i = 0; i < IGC_RETA_SIZE; i++)\n\t\tif (indir[i] >= num_queues)\n\t\t\treturn -EINVAL;\n\n\tfor (i = 0; i < IGC_RETA_SIZE; i++)\n\t\tadapter->rss_indir_tbl[i] = indir[i];\n\n\tigc_write_rss_indir_tbl(adapter);\n\n\treturn 0;\n}\n\nstatic void igc_ethtool_get_channels(struct net_device *netdev,\n\t\t\t\t     struct ethtool_channels *ch)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tch->max_combined = igc_get_max_rss_queues(adapter);\n\n\t \n\tif (adapter->flags & IGC_FLAG_HAS_MSIX) {\n\t\tch->max_other = NON_Q_VECTORS;\n\t\tch->other_count = NON_Q_VECTORS;\n\t}\n\n\tch->combined_count = adapter->rss_queues;\n}\n\nstatic int igc_ethtool_set_channels(struct net_device *netdev,\n\t\t\t\t    struct ethtool_channels *ch)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tunsigned int count = ch->combined_count;\n\tunsigned int max_combined = 0;\n\n\t \n\tif (!count || ch->rx_count || ch->tx_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (ch->other_count != NON_Q_VECTORS)\n\t\treturn -EINVAL;\n\n\t \n\tmax_combined = igc_get_max_rss_queues(adapter);\n\tif (count > max_combined)\n\t\treturn -EINVAL;\n\n\tif (count != adapter->rss_queues) {\n\t\tadapter->rss_queues = count;\n\t\tigc_set_flag_queue_pairs(adapter, max_combined);\n\n\t\t \n\t\treturn igc_reinit_queues(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_get_ts_info(struct net_device *dev,\n\t\t\t\t   struct ethtool_ts_info *info)\n{\n\tstruct igc_adapter *adapter = netdev_priv(dev);\n\n\tif (adapter->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(adapter->ptp_clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n\tswitch (adapter->hw.mac.type) {\n\tcase igc_i225:\n\t\tinfo->so_timestamping =\n\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\t\tinfo->tx_types =\n\t\t\tBIT(HWTSTAMP_TX_OFF) |\n\t\t\tBIT(HWTSTAMP_TX_ON);\n\n\t\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE);\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_ALL);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32 igc_ethtool_get_priv_flags(struct net_device *netdev)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tu32 priv_flags = 0;\n\n\tif (adapter->flags & IGC_FLAG_RX_LEGACY)\n\t\tpriv_flags |= IGC_PRIV_FLAGS_LEGACY_RX;\n\n\treturn priv_flags;\n}\n\nstatic int igc_ethtool_set_priv_flags(struct net_device *netdev, u32 priv_flags)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tunsigned int flags = adapter->flags;\n\n\tflags &= ~IGC_FLAG_RX_LEGACY;\n\tif (priv_flags & IGC_PRIV_FLAGS_LEGACY_RX)\n\t\tflags |= IGC_FLAG_RX_LEGACY;\n\n\tif (flags != adapter->flags) {\n\t\tadapter->flags = flags;\n\n\t\t \n\t\tif (netif_running(netdev))\n\t\t\tigc_reinit_locked(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_get_eee(struct net_device *netdev,\n\t\t\t       struct ethtool_eee *edata)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 eeer;\n\n\tif (hw->dev_spec._base.eee_enable)\n\t\tedata->advertised =\n\t\t\tmmd_eee_adv_to_ethtool_adv_t(adapter->eee_advert);\n\n\t*edata = adapter->eee;\n\tedata->supported = SUPPORTED_Autoneg;\n\n\teeer = rd32(IGC_EEER);\n\n\t \n\tif (eeer & IGC_EEER_EEE_NEG)\n\t\tedata->eee_active = true;\n\n\tif (eeer & IGC_EEER_TX_LPI_EN)\n\t\tedata->tx_lpi_enabled = true;\n\n\tedata->eee_enabled = hw->dev_spec._base.eee_enable;\n\n\tedata->advertised = SUPPORTED_Autoneg;\n\tedata->lp_advertised = SUPPORTED_Autoneg;\n\n\t \n\tif (adapter->link_duplex == HALF_DUPLEX) {\n\t\tedata->eee_enabled = false;\n\t\tedata->eee_active = false;\n\t\tedata->tx_lpi_enabled = false;\n\t\tedata->advertised &= ~edata->advertised;\n\t}\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_set_eee(struct net_device *netdev,\n\t\t\t       struct ethtool_eee *edata)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tstruct ethtool_eee eee_curr;\n\ts32 ret_val;\n\n\tmemset(&eee_curr, 0, sizeof(struct ethtool_eee));\n\n\tret_val = igc_ethtool_get_eee(netdev, &eee_curr);\n\tif (ret_val) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Problem setting EEE advertisement options\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (eee_curr.eee_enabled) {\n\t\tif (eee_curr.tx_lpi_enabled != edata->tx_lpi_enabled) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Setting EEE tx-lpi is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (edata->tx_lpi_timer) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Setting EEE Tx LPI timer is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!edata->eee_enabled) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Setting EEE options are not supported with EEE disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->eee_advert = ethtool_adv_to_mmd_eee_adv_t(edata->advertised);\n\tif (hw->dev_spec._base.eee_enable != edata->eee_enabled) {\n\t\thw->dev_spec._base.eee_enable = edata->eee_enabled;\n\t\tadapter->flags |= IGC_FLAG_EEE;\n\n\t\t \n\t\tif (netif_running(netdev))\n\t\t\tigc_reinit_locked(adapter);\n\t\telse\n\t\t\tigc_reset(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic int igc_ethtool_begin(struct net_device *netdev)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\tpm_runtime_get_sync(&adapter->pdev->dev);\n\treturn 0;\n}\n\nstatic void igc_ethtool_complete(struct net_device *netdev)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\n\tpm_runtime_put(&adapter->pdev->dev);\n}\n\nstatic int igc_ethtool_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 status;\n\tu32 speed;\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\n\t \n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Half);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 100baseT_Half);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 100baseT_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 1000baseT_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 2500baseT_Full);\n\n\t \n\tcmd->base.port = PORT_TP;\n\tcmd->base.phy_address = hw->phy.addr;\n\tethtool_link_ksettings_add_link_mode(cmd, supported, TP);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, TP);\n\n\t \n\tif (hw->phy.autoneg_advertised & ADVERTISE_10_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, 10baseT_Half);\n\tif (hw->phy.autoneg_advertised & ADVERTISE_10_FULL)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, 10baseT_Full);\n\tif (hw->phy.autoneg_advertised & ADVERTISE_100_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, 100baseT_Half);\n\tif (hw->phy.autoneg_advertised & ADVERTISE_100_FULL)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, 100baseT_Full);\n\tif (hw->phy.autoneg_advertised & ADVERTISE_1000_FULL)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, 1000baseT_Full);\n\tif (hw->phy.autoneg_advertised & ADVERTISE_2500_FULL)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, 2500baseT_Full);\n\n\t \n\tif (hw->mac.autoneg == 1) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Autoneg);\n\t}\n\n\t \n\tethtool_link_ksettings_add_link_mode(cmd, supported, Pause);\n\n\tswitch (hw->fc.requested_mode) {\n\tcase igc_fc_full:\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Pause);\n\t\tbreak;\n\tcase igc_fc_rx_pause:\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Pause);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tcase igc_fc_tx_pause:\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tstatus = pm_runtime_suspended(&adapter->pdev->dev) ?\n\t\t 0 : rd32(IGC_STATUS);\n\n\tif (status & IGC_STATUS_LU) {\n\t\tif (status & IGC_STATUS_SPEED_1000) {\n\t\t\t \n\t\t\tif (hw->mac.type == igc_i225 &&\n\t\t\t    (status & IGC_STATUS_SPEED_2500)) {\n\t\t\t\tspeed = SPEED_2500;\n\t\t\t} else {\n\t\t\t\tspeed = SPEED_1000;\n\t\t\t}\n\t\t} else if (status & IGC_STATUS_SPEED_100) {\n\t\t\tspeed = SPEED_100;\n\t\t} else {\n\t\t\tspeed = SPEED_10;\n\t\t}\n\t\tif ((status & IGC_STATUS_FD) ||\n\t\t    hw->phy.media_type != igc_media_type_copper)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t} else {\n\t\tspeed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\tcmd->base.speed = speed;\n\tif (hw->mac.autoneg)\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\t \n\tif (hw->phy.media_type == igc_media_type_copper)\n\t\tcmd->base.eth_tp_mdix = hw->phy.is_mdix ? ETH_TP_MDI_X :\n\t\t\t\t\t\t      ETH_TP_MDI;\n\telse\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\n\tif (hw->phy.mdix == AUTO_ALL_MODES)\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\n\telse\n\t\tcmd->base.eth_tp_mdix_ctrl = hw->phy.mdix;\n\n\treturn 0;\n}\n\nstatic int\nigc_ethtool_set_link_ksettings(struct net_device *netdev,\n\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct net_device *dev = adapter->netdev;\n\tstruct igc_hw *hw = &adapter->hw;\n\tu16 advertised = 0;\n\n\t \n\tif (igc_check_reset_block(hw)) {\n\t\tnetdev_err(dev, \"Cannot change link characteristics when reset is active\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\tif (cmd->base.eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO &&\n\t\t    cmd->base.autoneg != AUTONEG_ENABLE) {\n\t\t\tnetdev_err(dev, \"Forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twhile (test_and_set_bit(__IGC_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t  2500baseT_Full))\n\t\tadvertised |= ADVERTISE_2500_FULL;\n\n\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t  1000baseT_Full))\n\t\tadvertised |= ADVERTISE_1000_FULL;\n\n\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t  100baseT_Full))\n\t\tadvertised |= ADVERTISE_100_FULL;\n\n\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t  100baseT_Half))\n\t\tadvertised |= ADVERTISE_100_HALF;\n\n\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t  10baseT_Full))\n\t\tadvertised |= ADVERTISE_10_FULL;\n\n\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t  10baseT_Half))\n\t\tadvertised |= ADVERTISE_10_HALF;\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\thw->mac.autoneg = 1;\n\t\thw->phy.autoneg_advertised = advertised;\n\t\tif (adapter->fc_autoneg)\n\t\t\thw->fc.requested_mode = igc_fc_default;\n\t} else {\n\t\tnetdev_info(dev, \"Force mode currently not supported\\n\");\n\t}\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\t \n\t\tif (cmd->base.eth_tp_mdix_ctrl == ETH_TP_MDI_AUTO)\n\t\t\thw->phy.mdix = AUTO_ALL_MODES;\n\t\telse\n\t\t\thw->phy.mdix = cmd->base.eth_tp_mdix_ctrl;\n\t}\n\n\t \n\tif (netif_running(adapter->netdev)) {\n\t\tigc_down(adapter);\n\t\tigc_up(adapter);\n\t} else {\n\t\tigc_reset(adapter);\n\t}\n\n\tclear_bit(__IGC_RESETTING, &adapter->state);\n\n\treturn 0;\n}\n\nstatic void igc_ethtool_diag_test(struct net_device *netdev,\n\t\t\t\t  struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tbool if_running = netif_running(netdev);\n\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\tnetdev_info(adapter->netdev, \"Offline testing starting\");\n\t\tset_bit(__IGC_TESTING, &adapter->state);\n\n\t\t \n\t\tif (!igc_link_test(adapter, &data[TEST_LINK]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (if_running)\n\t\t\tigc_close(netdev);\n\t\telse\n\t\t\tigc_reset(adapter);\n\n\t\tnetdev_info(adapter->netdev, \"Register testing starting\");\n\t\tif (!igc_reg_test(adapter, &data[TEST_REG]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tigc_reset(adapter);\n\n\t\tnetdev_info(adapter->netdev, \"EEPROM testing starting\");\n\t\tif (!igc_eeprom_test(adapter, &data[TEST_EEP]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tigc_reset(adapter);\n\n\t\t \n\t\tdata[TEST_LOOP] = 0;\n\t\tdata[TEST_IRQ] = 0;\n\n\t\tclear_bit(__IGC_TESTING, &adapter->state);\n\t\tif (if_running)\n\t\t\tigc_open(netdev);\n\t} else {\n\t\tnetdev_info(adapter->netdev, \"Online testing starting\");\n\n\t\t \n\t\tdata[TEST_REG] = 0;\n\t\tdata[TEST_EEP] = 0;\n\t\tdata[TEST_IRQ] = 0;\n\t\tdata[TEST_LOOP] = 0;\n\n\t\tif (!igc_link_test(adapter, &data[TEST_LINK]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tmsleep_interruptible(4 * 1000);\n}\n\nstatic const struct ethtool_ops igc_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS,\n\t.get_drvinfo\t\t= igc_ethtool_get_drvinfo,\n\t.get_regs_len\t\t= igc_ethtool_get_regs_len,\n\t.get_regs\t\t= igc_ethtool_get_regs,\n\t.get_wol\t\t= igc_ethtool_get_wol,\n\t.set_wol\t\t= igc_ethtool_set_wol,\n\t.get_msglevel\t\t= igc_ethtool_get_msglevel,\n\t.set_msglevel\t\t= igc_ethtool_set_msglevel,\n\t.nway_reset\t\t= igc_ethtool_nway_reset,\n\t.get_link\t\t= igc_ethtool_get_link,\n\t.get_eeprom_len\t\t= igc_ethtool_get_eeprom_len,\n\t.get_eeprom\t\t= igc_ethtool_get_eeprom,\n\t.set_eeprom\t\t= igc_ethtool_set_eeprom,\n\t.get_ringparam\t\t= igc_ethtool_get_ringparam,\n\t.set_ringparam\t\t= igc_ethtool_set_ringparam,\n\t.get_pauseparam\t\t= igc_ethtool_get_pauseparam,\n\t.set_pauseparam\t\t= igc_ethtool_set_pauseparam,\n\t.get_strings\t\t= igc_ethtool_get_strings,\n\t.get_sset_count\t\t= igc_ethtool_get_sset_count,\n\t.get_ethtool_stats\t= igc_ethtool_get_stats,\n\t.get_coalesce\t\t= igc_ethtool_get_coalesce,\n\t.set_coalesce\t\t= igc_ethtool_set_coalesce,\n\t.get_rxnfc\t\t= igc_ethtool_get_rxnfc,\n\t.set_rxnfc\t\t= igc_ethtool_set_rxnfc,\n\t.get_rxfh_indir_size\t= igc_ethtool_get_rxfh_indir_size,\n\t.get_rxfh\t\t= igc_ethtool_get_rxfh,\n\t.set_rxfh\t\t= igc_ethtool_set_rxfh,\n\t.get_ts_info\t\t= igc_ethtool_get_ts_info,\n\t.get_channels\t\t= igc_ethtool_get_channels,\n\t.set_channels\t\t= igc_ethtool_set_channels,\n\t.get_priv_flags\t\t= igc_ethtool_get_priv_flags,\n\t.set_priv_flags\t\t= igc_ethtool_set_priv_flags,\n\t.get_eee\t\t= igc_ethtool_get_eee,\n\t.set_eee\t\t= igc_ethtool_set_eee,\n\t.begin\t\t\t= igc_ethtool_begin,\n\t.complete\t\t= igc_ethtool_complete,\n\t.get_link_ksettings\t= igc_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= igc_ethtool_set_link_ksettings,\n\t.self_test\t\t= igc_ethtool_diag_test,\n};\n\nvoid igc_ethtool_set_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &igc_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}