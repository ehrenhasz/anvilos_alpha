{
  "module_name": "igc_tsn.c",
  "hash_id": "78fbad7b9bd9ff1d02ab44758ffccb390fc3f780bd4f730fc5061d164d3aa4df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_tsn.c",
  "human_readable_source": "\n \n\n#include \"igc.h\"\n#include \"igc_hw.h\"\n#include \"igc_tsn.h\"\n\nstatic bool is_any_launchtime(struct igc_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct igc_ring *ring = adapter->tx_ring[i];\n\n\t\tif (ring->launchtime_enable)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool is_cbs_enabled(struct igc_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct igc_ring *ring = adapter->tx_ring[i];\n\n\t\tif (ring->cbs_enable)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic unsigned int igc_tsn_new_flags(struct igc_adapter *adapter)\n{\n\tunsigned int new_flags = adapter->flags & ~IGC_FLAG_TSN_ANY_ENABLED;\n\n\tif (adapter->taprio_offload_enable)\n\t\tnew_flags |= IGC_FLAG_TSN_QBV_ENABLED;\n\n\tif (is_any_launchtime(adapter))\n\t\tnew_flags |= IGC_FLAG_TSN_QBV_ENABLED;\n\n\tif (is_cbs_enabled(adapter))\n\t\tnew_flags |= IGC_FLAG_TSN_QAV_ENABLED;\n\n\treturn new_flags;\n}\n\nvoid igc_tsn_adjust_txtime_offset(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu16 txoffset;\n\n\tif (!is_any_launchtime(adapter))\n\t\treturn;\n\n\tswitch (adapter->link_speed) {\n\tcase SPEED_10:\n\t\ttxoffset = IGC_TXOFFSET_SPEED_10;\n\t\tbreak;\n\tcase SPEED_100:\n\t\ttxoffset = IGC_TXOFFSET_SPEED_100;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\ttxoffset = IGC_TXOFFSET_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\ttxoffset = IGC_TXOFFSET_SPEED_2500;\n\t\tbreak;\n\tdefault:\n\t\ttxoffset = 0;\n\t\tbreak;\n\t}\n\n\twr32(IGC_GTXOFFSET, txoffset);\n}\n\n \nstatic int igc_tsn_disable_offload(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 tqavctrl;\n\tint i;\n\n\twr32(IGC_GTXOFFSET, 0);\n\twr32(IGC_TXPBS, I225_TXPBSIZE_DEFAULT);\n\twr32(IGC_DTXMXPKTSZ, IGC_DTXMXPKTSZ_DEFAULT);\n\n\ttqavctrl = rd32(IGC_TQAVCTRL);\n\ttqavctrl &= ~(IGC_TQAVCTRL_TRANSMIT_MODE_TSN |\n\t\t      IGC_TQAVCTRL_ENHANCED_QAV | IGC_TQAVCTRL_FUTSCDDIS);\n\n\twr32(IGC_TQAVCTRL, tqavctrl);\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\twr32(IGC_TXQCTL(i), 0);\n\t\twr32(IGC_STQT(i), 0);\n\t\twr32(IGC_ENDQT(i), NSEC_PER_SEC);\n\t}\n\n\twr32(IGC_QBVCYCLET_S, 0);\n\twr32(IGC_QBVCYCLET, NSEC_PER_SEC);\n\n\tadapter->flags &= ~IGC_FLAG_TSN_QBV_ENABLED;\n\n\treturn 0;\n}\n\nstatic int igc_tsn_enable_offload(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 tqavctrl, baset_l, baset_h;\n\tu32 sec, nsec, cycle;\n\tktime_t base_time, systim;\n\tint i;\n\n\twr32(IGC_TSAUXC, 0);\n\twr32(IGC_DTXMXPKTSZ, IGC_DTXMXPKTSZ_TSN);\n\twr32(IGC_TXPBS, IGC_TXPBSIZE_TSN);\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct igc_ring *ring = adapter->tx_ring[i];\n\t\tu32 txqctl = 0;\n\t\tu16 cbs_value;\n\t\tu32 tqavcc;\n\n\t\twr32(IGC_STQT(i), ring->start_time);\n\t\twr32(IGC_ENDQT(i), ring->end_time);\n\n\t\tif (adapter->taprio_offload_enable) {\n\t\t\t \n\t\t\ttxqctl |= IGC_TXQCTL_STRICT_CYCLE |\n\t\t\t\tIGC_TXQCTL_STRICT_END;\n\t\t}\n\n\t\tif (ring->launchtime_enable)\n\t\t\ttxqctl |= IGC_TXQCTL_QUEUE_MODE_LAUNCHT;\n\n\t\t \n\t\tif (i > 1)\n\t\t\tgoto skip_cbs;\n\n\t\tif (ring->cbs_enable) {\n\t\t\tif (i == 0)\n\t\t\t\ttxqctl |= IGC_TXQCTL_QAV_SEL_CBS0;\n\t\t\telse\n\t\t\t\ttxqctl |= IGC_TXQCTL_QAV_SEL_CBS1;\n\n\t\t\t \n\t\t\tcbs_value = DIV_ROUND_UP_ULL(ring->idleslope\n\t\t\t\t\t\t     * 61036ULL, 2500000);\n\n\t\t\ttqavcc = rd32(IGC_TQAVCC(i));\n\t\t\ttqavcc &= ~IGC_TQAVCC_IDLESLOPE_MASK;\n\t\t\ttqavcc |= cbs_value | IGC_TQAVCC_KEEP_CREDITS;\n\t\t\twr32(IGC_TQAVCC(i), tqavcc);\n\n\t\t\twr32(IGC_TQAVHC(i),\n\t\t\t     0x80000000 + ring->hicredit * 0x7736);\n\t\t} else {\n\t\t\t \n\t\t\ttxqctl &= ~(IGC_TXQCTL_QAV_SEL_MASK);\n\n\t\t\t \n\t\t\ttqavcc = rd32(IGC_TQAVCC(i));\n\t\t\ttqavcc &= ~(IGC_TQAVCC_IDLESLOPE_MASK |\n\t\t\t\t    IGC_TQAVCC_KEEP_CREDITS);\n\t\t\twr32(IGC_TQAVCC(i), tqavcc);\n\n\t\t\t \n\t\t\twr32(IGC_TQAVHC(i), 0);\n\t\t}\nskip_cbs:\n\t\twr32(IGC_TXQCTL(i), txqctl);\n\t}\n\n\ttqavctrl = rd32(IGC_TQAVCTRL) & ~IGC_TQAVCTRL_FUTSCDDIS;\n\n\ttqavctrl |= IGC_TQAVCTRL_TRANSMIT_MODE_TSN | IGC_TQAVCTRL_ENHANCED_QAV;\n\n\tadapter->qbv_count++;\n\n\tcycle = adapter->cycle_time;\n\tbase_time = adapter->base_time;\n\n\tnsec = rd32(IGC_SYSTIML);\n\tsec = rd32(IGC_SYSTIMH);\n\n\tsystim = ktime_set(sec, nsec);\n\tif (ktime_compare(systim, base_time) > 0) {\n\t\ts64 n = div64_s64(ktime_sub_ns(systim, base_time), cycle);\n\n\t\tbase_time = ktime_add_ns(base_time, (n + 1) * cycle);\n\n\t\t \n\t\tif ((rd32(IGC_BASET_H) || rd32(IGC_BASET_L)) &&\n\t\t    (adapter->tc_setup_type == TC_SETUP_QDISC_TAPRIO) &&\n\t\t    (adapter->qbv_count > 1))\n\t\t\tadapter->qbv_config_change_errors++;\n\t} else {\n\t\tif (igc_is_device_id_i226(hw)) {\n\t\t\tktime_t adjust_time, expires_time;\n\n\t\t        \n\t\t\tif (!(rd32(IGC_BASET_H) || rd32(IGC_BASET_L)))\n\t\t\t\ttqavctrl |= IGC_TQAVCTRL_FUTSCDDIS;\n\n\t\t\tnsec = rd32(IGC_SYSTIML);\n\t\t\tsec = rd32(IGC_SYSTIMH);\n\t\t\tsystim = ktime_set(sec, nsec);\n\n\t\t\tadjust_time = adapter->base_time;\n\t\t\texpires_time = ktime_sub_ns(adjust_time, systim);\n\t\t\thrtimer_start(&adapter->hrtimer, expires_time, HRTIMER_MODE_REL);\n\t\t}\n\t}\n\n\twr32(IGC_TQAVCTRL, tqavctrl);\n\n\twr32(IGC_QBVCYCLET_S, cycle);\n\twr32(IGC_QBVCYCLET, cycle);\n\n\tbaset_h = div_s64_rem(base_time, NSEC_PER_SEC, &baset_l);\n\twr32(IGC_BASET_H, baset_h);\n\n\t \n\tif (tqavctrl & IGC_TQAVCTRL_FUTSCDDIS)\n\t\twr32(IGC_BASET_L, 0);\n\twr32(IGC_BASET_L, baset_l);\n\n\treturn 0;\n}\n\nint igc_tsn_reset(struct igc_adapter *adapter)\n{\n\tunsigned int new_flags;\n\tint err = 0;\n\n\tnew_flags = igc_tsn_new_flags(adapter);\n\n\tif (!(new_flags & IGC_FLAG_TSN_ANY_ENABLED))\n\t\treturn igc_tsn_disable_offload(adapter);\n\n\terr = igc_tsn_enable_offload(adapter);\n\tif (err < 0)\n\t\treturn err;\n\n\tadapter->flags = new_flags;\n\n\treturn err;\n}\n\nint igc_tsn_offload_apply(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\n\t \n\tif (netif_running(adapter->netdev) &&\n\t    (igc_is_device_id_i225(hw) || !adapter->qbv_count)) {\n\t\tschedule_work(&adapter->reset_task);\n\t\treturn 0;\n\t}\n\n\tigc_tsn_reset(adapter);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}