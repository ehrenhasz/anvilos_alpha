{
  "module_name": "igc_base.c",
  "hash_id": "9a9d900f164add97b14841a4eb414611dd1cedde59b0544426631b803959f48c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_base.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include \"igc_hw.h\"\n#include \"igc_i225.h\"\n#include \"igc_mac.h\"\n#include \"igc_base.h\"\n#include \"igc.h\"\n\n \nstatic s32 igc_reset_hw_base(struct igc_hw *hw)\n{\n\ts32 ret_val;\n\tu32 ctrl;\n\n\t \n\tret_val = igc_disable_pcie_master(hw);\n\tif (ret_val)\n\t\thw_dbg(\"PCI-E Master disable polling has failed\\n\");\n\n\thw_dbg(\"Masking off all interrupts\\n\");\n\twr32(IGC_IMC, 0xffffffff);\n\n\twr32(IGC_RCTL, 0);\n\twr32(IGC_TCTL, IGC_TCTL_PSP);\n\twrfl();\n\n\tusleep_range(10000, 20000);\n\n\tctrl = rd32(IGC_CTRL);\n\n\thw_dbg(\"Issuing a global reset to MAC\\n\");\n\twr32(IGC_CTRL, ctrl | IGC_CTRL_RST);\n\n\tret_val = igc_get_auto_rd_done(hw);\n\tif (ret_val) {\n\t\t \n\t\thw_dbg(\"Auto Read Done did not complete\\n\");\n\t}\n\n\t \n\twr32(IGC_IMC, 0xffffffff);\n\trd32(IGC_ICR);\n\n\treturn ret_val;\n}\n\n \nstatic s32 igc_init_nvm_params_base(struct igc_hw *hw)\n{\n\tstruct igc_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = rd32(IGC_EECD);\n\tu16 size;\n\n\tsize = (u16)((eecd & IGC_EECD_SIZE_EX_MASK) >>\n\t\t     IGC_EECD_SIZE_EX_SHIFT);\n\n\t \n\tsize += NVM_WORD_SIZE_BASE_SHIFT;\n\n\t \n\tif (size > 15)\n\t\tsize = 15;\n\n\tnvm->type = igc_nvm_eeprom_spi;\n\tnvm->word_size = BIT(size);\n\tnvm->opcode_bits = 8;\n\tnvm->delay_usec = 1;\n\n\tnvm->page_size = eecd & IGC_EECD_ADDR_BITS ? 32 : 8;\n\tnvm->address_bits = eecd & IGC_EECD_ADDR_BITS ?\n\t\t\t    16 : 8;\n\n\tif (nvm->word_size == BIT(15))\n\t\tnvm->page_size = 128;\n\n\treturn 0;\n}\n\n \nstatic s32 igc_setup_copper_link_base(struct igc_hw *hw)\n{\n\ts32  ret_val = 0;\n\tu32 ctrl;\n\n\tctrl = rd32(IGC_CTRL);\n\tctrl |= IGC_CTRL_SLU;\n\tctrl &= ~(IGC_CTRL_FRCSPD | IGC_CTRL_FRCDPX);\n\twr32(IGC_CTRL, ctrl);\n\n\tret_val = igc_setup_copper_link(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 igc_init_mac_params_base(struct igc_hw *hw)\n{\n\tstruct igc_dev_spec_base *dev_spec = &hw->dev_spec._base;\n\tstruct igc_mac_info *mac = &hw->mac;\n\n\t \n\tmac->mta_reg_count = 128;\n\tmac->rar_entry_count = IGC_RAR_ENTRIES;\n\n\t \n\tmac->ops.reset_hw = igc_reset_hw_base;\n\n\tmac->ops.acquire_swfw_sync = igc_acquire_swfw_sync_i225;\n\tmac->ops.release_swfw_sync = igc_release_swfw_sync_i225;\n\n\t \n\tif (mac->type == igc_i225)\n\t\tdev_spec->clear_semaphore_once = true;\n\n\t \n\tmac->ops.setup_physical_interface = igc_setup_copper_link_base;\n\n\treturn 0;\n}\n\n \nstatic s32 igc_init_phy_params_base(struct igc_hw *hw)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\n\tphy->autoneg_mask\t= AUTONEG_ADVERTISE_SPEED_DEFAULT_2500;\n\tphy->reset_delay_us\t= 100;\n\n\t \n\thw->bus.func = (rd32(IGC_STATUS) & IGC_STATUS_FUNC_MASK) >>\n\t\t\tIGC_STATUS_FUNC_SHIFT;\n\n\t \n\tret_val = hw->phy.ops.reset(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error resetting the PHY\\n\");\n\t\tgoto out;\n\t}\n\n\tret_val = igc_get_phy_id(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tigc_check_for_copper_link(hw);\n\nout:\n\treturn ret_val;\n}\n\nstatic s32 igc_get_invariants_base(struct igc_hw *hw)\n{\n\tstruct igc_mac_info *mac = &hw->mac;\n\ts32 ret_val = 0;\n\n\tswitch (hw->device_id) {\n\tcase IGC_DEV_ID_I225_LM:\n\tcase IGC_DEV_ID_I225_V:\n\tcase IGC_DEV_ID_I225_I:\n\tcase IGC_DEV_ID_I220_V:\n\tcase IGC_DEV_ID_I225_K:\n\tcase IGC_DEV_ID_I225_K2:\n\tcase IGC_DEV_ID_I226_K:\n\tcase IGC_DEV_ID_I225_LMVP:\n\tcase IGC_DEV_ID_I226_LMVP:\n\tcase IGC_DEV_ID_I225_IT:\n\tcase IGC_DEV_ID_I226_LM:\n\tcase IGC_DEV_ID_I226_V:\n\tcase IGC_DEV_ID_I226_IT:\n\tcase IGC_DEV_ID_I221_V:\n\tcase IGC_DEV_ID_I226_BLANK_NVM:\n\tcase IGC_DEV_ID_I225_BLANK_NVM:\n\t\tmac->type = igc_i225;\n\t\tbreak;\n\tdefault:\n\t\treturn -IGC_ERR_MAC_INIT;\n\t}\n\n\thw->phy.media_type = igc_media_type_copper;\n\n\t \n\tret_val = igc_init_mac_params_base(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = igc_init_nvm_params_base(hw);\n\tswitch (hw->mac.type) {\n\tcase igc_i225:\n\t\tret_val = igc_init_nvm_params_i225(hw);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret_val = igc_init_phy_params_base(hw);\n\tif (ret_val)\n\t\tgoto out;\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igc_acquire_phy_base(struct igc_hw *hw)\n{\n\tu16 mask = IGC_SWFW_PHY0_SM;\n\n\treturn hw->mac.ops.acquire_swfw_sync(hw, mask);\n}\n\n \nstatic void igc_release_phy_base(struct igc_hw *hw)\n{\n\tu16 mask = IGC_SWFW_PHY0_SM;\n\n\thw->mac.ops.release_swfw_sync(hw, mask);\n}\n\n \nstatic s32 igc_init_hw_base(struct igc_hw *hw)\n{\n\tstruct igc_mac_info *mac = &hw->mac;\n\tu16 i, rar_count = mac->rar_entry_count;\n\ts32 ret_val = 0;\n\n\t \n\tigc_init_rx_addrs(hw, rar_count);\n\n\t \n\thw_dbg(\"Zeroing the MTA\\n\");\n\tfor (i = 0; i < mac->mta_reg_count; i++)\n\t\tarray_wr32(IGC_MTA, i, 0);\n\n\t \n\thw_dbg(\"Zeroing the UTA\\n\");\n\tfor (i = 0; i < mac->uta_reg_count; i++)\n\t\tarray_wr32(IGC_UTA, i, 0);\n\n\t \n\tret_val = igc_setup_link(hw);\n\n\t \n\tigc_clear_hw_cntrs_base(hw);\n\n\treturn ret_val;\n}\n\n \nvoid igc_power_down_phy_copper_base(struct igc_hw *hw)\n{\n\t \n\tif (!(igc_enable_mng_pass_thru(hw) || igc_check_reset_block(hw)))\n\t\tigc_power_down_phy_copper(hw);\n}\n\n \nvoid igc_rx_fifo_flush_base(struct igc_hw *hw)\n{\n\tu32 rctl, rlpml, rxdctl[4], rfctl, temp_rctl, rx_enabled;\n\tint i, ms_wait;\n\n\t \n\trfctl = rd32(IGC_RFCTL);\n\trfctl |= IGC_RFCTL_IPV6_EX_DIS;\n\twr32(IGC_RFCTL, rfctl);\n\n\tif (!(rd32(IGC_MANC) & IGC_MANC_RCV_TCO_EN))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\trxdctl[i] = rd32(IGC_RXDCTL(i));\n\t\twr32(IGC_RXDCTL(i),\n\t\t     rxdctl[i] & ~IGC_RXDCTL_QUEUE_ENABLE);\n\t}\n\t \n\tfor (ms_wait = 0; ms_wait < 10; ms_wait++) {\n\t\tusleep_range(1000, 2000);\n\t\trx_enabled = 0;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\trx_enabled |= rd32(IGC_RXDCTL(i));\n\t\tif (!(rx_enabled & IGC_RXDCTL_QUEUE_ENABLE))\n\t\t\tbreak;\n\t}\n\n\tif (ms_wait == 10)\n\t\thw_dbg(\"Queue disable timed out after 10ms\\n\");\n\n\t \n\twr32(IGC_RFCTL, rfctl & ~IGC_RFCTL_LEF);\n\n\trlpml = rd32(IGC_RLPML);\n\twr32(IGC_RLPML, 0);\n\n\trctl = rd32(IGC_RCTL);\n\ttemp_rctl = rctl & ~(IGC_RCTL_EN | IGC_RCTL_SBP);\n\ttemp_rctl |= IGC_RCTL_LPE;\n\n\twr32(IGC_RCTL, temp_rctl);\n\twr32(IGC_RCTL, temp_rctl | IGC_RCTL_EN);\n\twrfl();\n\tusleep_range(2000, 3000);\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\twr32(IGC_RXDCTL(i), rxdctl[i]);\n\twr32(IGC_RCTL, rctl);\n\twrfl();\n\n\twr32(IGC_RLPML, rlpml);\n\twr32(IGC_RFCTL, rfctl);\n\n\t \n\trd32(IGC_ROC);\n\trd32(IGC_RNBC);\n\trd32(IGC_MPC);\n}\n\nbool igc_is_device_id_i225(struct igc_hw *hw)\n{\n\tswitch (hw->device_id) {\n\tcase IGC_DEV_ID_I225_LM:\n\tcase IGC_DEV_ID_I225_V:\n\tcase IGC_DEV_ID_I225_I:\n\tcase IGC_DEV_ID_I225_K:\n\tcase IGC_DEV_ID_I225_K2:\n\tcase IGC_DEV_ID_I225_LMVP:\n\tcase IGC_DEV_ID_I225_IT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nbool igc_is_device_id_i226(struct igc_hw *hw)\n{\n\tswitch (hw->device_id) {\n\tcase IGC_DEV_ID_I226_LM:\n\tcase IGC_DEV_ID_I226_V:\n\tcase IGC_DEV_ID_I226_K:\n\tcase IGC_DEV_ID_I226_IT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct igc_mac_operations igc_mac_ops_base = {\n\t.init_hw\t\t= igc_init_hw_base,\n\t.check_for_link\t\t= igc_check_for_copper_link,\n\t.rar_set\t\t= igc_rar_set,\n\t.read_mac_addr\t\t= igc_read_mac_addr,\n\t.get_speed_and_duplex\t= igc_get_speed_and_duplex_copper,\n};\n\nstatic const struct igc_phy_operations igc_phy_ops_base = {\n\t.acquire\t\t= igc_acquire_phy_base,\n\t.release\t\t= igc_release_phy_base,\n\t.reset\t\t\t= igc_phy_hw_reset,\n\t.read_reg\t\t= igc_read_phy_reg_gpy,\n\t.write_reg\t\t= igc_write_phy_reg_gpy,\n};\n\nconst struct igc_info igc_base_info = {\n\t.get_invariants\t\t= igc_get_invariants_base,\n\t.mac_ops\t\t= &igc_mac_ops_base,\n\t.phy_ops\t\t= &igc_phy_ops_base,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}