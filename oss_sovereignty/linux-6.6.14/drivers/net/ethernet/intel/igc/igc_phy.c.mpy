{
  "module_name": "igc_phy.c",
  "hash_id": "21ac05ffe37799d25c6c81c822bf9bc932fb93ca61685073688cb78010137c80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_phy.c",
  "human_readable_source": "\n \n\n#include \"igc_phy.h\"\n\n \ns32 igc_check_reset_block(struct igc_hw *hw)\n{\n\tu32 manc;\n\n\tmanc = rd32(IGC_MANC);\n\n\treturn (manc & IGC_MANC_BLK_PHY_RST_ON_IDE) ?\n\t\tIGC_ERR_BLK_PHY_RESET : 0;\n}\n\n \ns32 igc_get_phy_id(struct igc_hw *hw)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu16 phy_id;\n\n\tret_val = phy->ops.read_reg(hw, PHY_ID1, &phy_id);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->id = (u32)(phy_id << 16);\n\tusleep_range(200, 500);\n\tret_val = phy->ops.read_reg(hw, PHY_ID2, &phy_id);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->id |= (u32)(phy_id & PHY_REVISION_MASK);\n\tphy->revision = (u32)(phy_id & ~PHY_REVISION_MASK);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igc_phy_has_link(struct igc_hw *hw, u32 iterations,\n\t\t     u32 usec_interval, bool *success)\n{\n\tu16 i, phy_status;\n\ts32 ret_val = 0;\n\n\tfor (i = 0; i < iterations; i++) {\n\t\t \n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val && usec_interval > 0) {\n\t\t\t \n\t\t\tif (usec_interval >= 1000)\n\t\t\t\tmdelay(usec_interval / 1000);\n\t\t\telse\n\t\t\t\tudelay(usec_interval);\n\t\t}\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & MII_SR_LINK_STATUS)\n\t\t\tbreak;\n\t\tif (usec_interval >= 1000)\n\t\t\tmdelay(usec_interval / 1000);\n\t\telse\n\t\t\tudelay(usec_interval);\n\t}\n\n\t*success = (i < iterations) ? true : false;\n\n\treturn ret_val;\n}\n\n \nvoid igc_power_up_phy_copper(struct igc_hw *hw)\n{\n\tu16 mii_reg = 0;\n\n\t \n\thw->phy.ops.read_reg(hw, PHY_CONTROL, &mii_reg);\n\tmii_reg &= ~MII_CR_POWER_DOWN;\n\thw->phy.ops.write_reg(hw, PHY_CONTROL, mii_reg);\n}\n\n \nvoid igc_power_down_phy_copper(struct igc_hw *hw)\n{\n\tu16 mii_reg = 0;\n\n\t \n\thw->phy.ops.read_reg(hw, PHY_CONTROL, &mii_reg);\n\tmii_reg |= MII_CR_POWER_DOWN;\n\n\t \n\t \n\tusleep_range(1000, 2000);\n}\n\n \nvoid igc_check_downshift(struct igc_hw *hw)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\n\t \n\tphy->speed_downgraded = false;\n}\n\n \ns32 igc_phy_hw_reset(struct igc_hw *hw)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\tu32 phpm = 0, timeout = 10000;\n\ts32  ret_val;\n\tu32 ctrl;\n\n\tret_val = igc_check_reset_block(hw);\n\tif (ret_val) {\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\tret_val = phy->ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphpm = rd32(IGC_I225_PHPM);\n\n\tctrl = rd32(IGC_CTRL);\n\twr32(IGC_CTRL, ctrl | IGC_CTRL_PHY_RST);\n\twrfl();\n\n\tudelay(phy->reset_delay_us);\n\n\twr32(IGC_CTRL, ctrl);\n\twrfl();\n\n\t \n\tusleep_range(100, 150);\n\tdo {\n\t\tphpm = rd32(IGC_I225_PHPM);\n\t\ttimeout--;\n\t\tudelay(1);\n\t} while (!(phpm & IGC_PHY_RST_COMP) && timeout);\n\n\tif (!timeout)\n\t\thw_dbg(\"Timeout is expired after a phy reset\\n\");\n\n\tusleep_range(100, 150);\n\n\tphy->ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igc_phy_setup_autoneg(struct igc_hw *hw)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\tu16 aneg_multigbt_an_ctrl = 0;\n\tu16 mii_1000t_ctrl_reg = 0;\n\tu16 mii_autoneg_adv_reg;\n\ts32 ret_val;\n\n\tphy->autoneg_advertised &= phy->autoneg_mask;\n\n\t \n\tret_val = phy->ops.read_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (phy->autoneg_mask & ADVERTISE_1000_FULL) {\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, PHY_1000T_CTRL,\n\t\t\t\t\t    &mii_1000t_ctrl_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (phy->autoneg_mask & ADVERTISE_2500_FULL) {\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, (STANDARD_AN_REG_MASK <<\n\t\t\t\t\t    MMD_DEVADDR_SHIFT) |\n\t\t\t\t\t    ANEG_MULTIGBT_AN_CTRL,\n\t\t\t\t\t    &aneg_multigbt_an_ctrl);\n\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\n\t \n\tmii_autoneg_adv_reg &= ~(NWAY_AR_100TX_FD_CAPS |\n\t\t\t\t NWAY_AR_100TX_HD_CAPS |\n\t\t\t\t NWAY_AR_10T_FD_CAPS   |\n\t\t\t\t NWAY_AR_10T_HD_CAPS);\n\tmii_1000t_ctrl_reg &= ~(CR_1000T_HD_CAPS | CR_1000T_FD_CAPS);\n\n\thw_dbg(\"autoneg_advertised %x\\n\", phy->autoneg_advertised);\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_10_HALF) {\n\t\thw_dbg(\"Advertise 10mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_10_FULL) {\n\t\thw_dbg(\"Advertise 10mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_100_HALF) {\n\t\thw_dbg(\"Advertise 100mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_100_FULL) {\n\t\thw_dbg(\"Advertise 100mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_1000_HALF)\n\t\thw_dbg(\"Advertise 1000mb Half duplex request denied!\\n\");\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_1000_FULL) {\n\t\thw_dbg(\"Advertise 1000mb Full duplex\\n\");\n\t\tmii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_2500_HALF)\n\t\thw_dbg(\"Advertise 2500mb Half duplex request denied!\\n\");\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_2500_FULL) {\n\t\thw_dbg(\"Advertise 2500mb Full duplex\\n\");\n\t\taneg_multigbt_an_ctrl |= CR_2500T_FD_CAPS;\n\t} else {\n\t\taneg_multigbt_an_ctrl &= ~CR_2500T_FD_CAPS;\n\t}\n\n\t \n\tswitch (hw->fc.current_mode) {\n\tcase igc_fc_none:\n\t\t \n\t\tmii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tcase igc_fc_rx_pause:\n\t\t \n\t\tmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tcase igc_fc_tx_pause:\n\t\t \n\t\tmii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;\n\t\tmii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;\n\t\tbreak;\n\tcase igc_fc_full:\n\t\t \n\t\tmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(\"Flow control param set incorrectly\\n\");\n\t\treturn -IGC_ERR_CONFIG;\n\t}\n\n\tret_val = phy->ops.write_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\thw_dbg(\"Auto-Neg Advertising %x\\n\", mii_autoneg_adv_reg);\n\n\tif (phy->autoneg_mask & ADVERTISE_1000_FULL)\n\t\tret_val = phy->ops.write_reg(hw, PHY_1000T_CTRL,\n\t\t\t\t\t     mii_1000t_ctrl_reg);\n\n\tif (phy->autoneg_mask & ADVERTISE_2500_FULL)\n\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\t     (STANDARD_AN_REG_MASK <<\n\t\t\t\t\t     MMD_DEVADDR_SHIFT) |\n\t\t\t\t\t     ANEG_MULTIGBT_AN_CTRL,\n\t\t\t\t\t     aneg_multigbt_an_ctrl);\n\n\treturn ret_val;\n}\n\n \nstatic s32 igc_wait_autoneg(struct igc_hw *hw)\n{\n\tu16 i, phy_status;\n\ts32 ret_val = 0;\n\n\t \n\tfor (i = PHY_AUTO_NEG_LIMIT; i > 0; i--) {\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & MII_SR_AUTONEG_COMPLETE)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\t \n\treturn ret_val;\n}\n\n \nstatic s32 igc_copper_link_autoneg(struct igc_hw *hw)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\tu16 phy_ctrl;\n\ts32 ret_val;\n\n\t \n\tphy->autoneg_advertised &= phy->autoneg_mask;\n\n\t \n\tif (phy->autoneg_advertised == 0)\n\t\tphy->autoneg_advertised = phy->autoneg_mask;\n\n\thw_dbg(\"Reconfiguring auto-neg advertisement params\\n\");\n\tret_val = igc_phy_setup_autoneg(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error Setting up Auto-Negotiation\\n\");\n\t\tgoto out;\n\t}\n\thw_dbg(\"Restarting Auto-Neg\\n\");\n\n\t \n\tret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_ctrl |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);\n\tret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tif (phy->autoneg_wait_to_complete) {\n\t\tret_val = igc_wait_autoneg(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error while waiting for autoneg to complete\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thw->mac.get_link_status = true;\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igc_setup_copper_link(struct igc_hw *hw)\n{\n\ts32 ret_val = 0;\n\tbool link;\n\n\tif (hw->mac.autoneg) {\n\t\t \n\t\tret_val = igc_copper_link_autoneg(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\thw_dbg(\"Forcing Speed and Duplex\\n\");\n\t\tret_val = hw->phy.ops.force_speed_duplex(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error Forcing Speed and Duplex\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret_val = igc_phy_has_link(hw, COPPER_LINK_UP_LIMIT, 10, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (link) {\n\t\thw_dbg(\"Valid link established!!!\\n\");\n\t\tigc_config_collision_dist(hw);\n\t\tret_val = igc_config_fc_after_link_up(hw);\n\t} else {\n\t\thw_dbg(\"Unable to establish link!!!\\n\");\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igc_read_phy_reg_mdic(struct igc_hw *hw, u32 offset, u16 *data)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\tu32 i, mdic = 0;\n\ts32 ret_val = 0;\n\n\tif (offset > MAX_PHY_REG_ADDRESS) {\n\t\thw_dbg(\"PHY Address %d is out of range\\n\", offset);\n\t\tret_val = -IGC_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\t \n\tmdic = ((offset << IGC_MDIC_REG_SHIFT) |\n\t\t(phy->addr << IGC_MDIC_PHY_SHIFT) |\n\t\t(IGC_MDIC_OP_READ));\n\n\twr32(IGC_MDIC, mdic);\n\n\t \n\tfor (i = 0; i < IGC_GEN_POLL_TIMEOUT; i++) {\n\t\tudelay(50);\n\t\tmdic = rd32(IGC_MDIC);\n\t\tif (mdic & IGC_MDIC_READY)\n\t\t\tbreak;\n\t}\n\tif (!(mdic & IGC_MDIC_READY)) {\n\t\thw_dbg(\"MDI Read did not complete\\n\");\n\t\tret_val = -IGC_ERR_PHY;\n\t\tgoto out;\n\t}\n\tif (mdic & IGC_MDIC_ERROR) {\n\t\thw_dbg(\"MDI Error\\n\");\n\t\tret_val = -IGC_ERR_PHY;\n\t\tgoto out;\n\t}\n\t*data = (u16)mdic;\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igc_write_phy_reg_mdic(struct igc_hw *hw, u32 offset, u16 data)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\tu32 i, mdic = 0;\n\ts32 ret_val = 0;\n\n\tif (offset > MAX_PHY_REG_ADDRESS) {\n\t\thw_dbg(\"PHY Address %d is out of range\\n\", offset);\n\t\tret_val = -IGC_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\t \n\tmdic = (((u32)data) |\n\t\t(offset << IGC_MDIC_REG_SHIFT) |\n\t\t(phy->addr << IGC_MDIC_PHY_SHIFT) |\n\t\t(IGC_MDIC_OP_WRITE));\n\n\twr32(IGC_MDIC, mdic);\n\n\t \n\tfor (i = 0; i < IGC_GEN_POLL_TIMEOUT; i++) {\n\t\tudelay(50);\n\t\tmdic = rd32(IGC_MDIC);\n\t\tif (mdic & IGC_MDIC_READY)\n\t\t\tbreak;\n\t}\n\tif (!(mdic & IGC_MDIC_READY)) {\n\t\thw_dbg(\"MDI Write did not complete\\n\");\n\t\tret_val = -IGC_ERR_PHY;\n\t\tgoto out;\n\t}\n\tif (mdic & IGC_MDIC_ERROR) {\n\t\thw_dbg(\"MDI Error\\n\");\n\t\tret_val = -IGC_ERR_PHY;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 __igc_access_xmdio_reg(struct igc_hw *hw, u16 address,\n\t\t\t\t  u8 dev_addr, u16 *data, bool read)\n{\n\ts32 ret_val;\n\n\tret_val = hw->phy.ops.write_reg(hw, IGC_MMDAC, dev_addr);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = hw->phy.ops.write_reg(hw, IGC_MMDAAD, address);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = hw->phy.ops.write_reg(hw, IGC_MMDAC, IGC_MMDAC_FUNC_DATA |\n\t\t\t\t\tdev_addr);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (read)\n\t\tret_val = hw->phy.ops.read_reg(hw, IGC_MMDAAD, data);\n\telse\n\t\tret_val = hw->phy.ops.write_reg(hw, IGC_MMDAAD, *data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = hw->phy.ops.write_reg(hw, IGC_MMDAC, 0);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn ret_val;\n}\n\n \nstatic s32 igc_read_xmdio_reg(struct igc_hw *hw, u16 addr,\n\t\t\t      u8 dev_addr, u16 *data)\n{\n\treturn __igc_access_xmdio_reg(hw, addr, dev_addr, data, true);\n}\n\n \nstatic s32 igc_write_xmdio_reg(struct igc_hw *hw, u16 addr,\n\t\t\t       u8 dev_addr, u16 data)\n{\n\treturn __igc_access_xmdio_reg(hw, addr, dev_addr, &data, false);\n}\n\n \ns32 igc_write_phy_reg_gpy(struct igc_hw *hw, u32 offset, u16 data)\n{\n\tu8 dev_addr = (offset & GPY_MMD_MASK) >> GPY_MMD_SHIFT;\n\ts32 ret_val;\n\n\toffset = offset & GPY_REG_MASK;\n\n\tif (!dev_addr) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = igc_write_phy_reg_mdic(hw, offset, data);\n\t\thw->phy.ops.release(hw);\n\t} else {\n\t\tret_val = igc_write_xmdio_reg(hw, (u16)offset, dev_addr,\n\t\t\t\t\t      data);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 igc_read_phy_reg_gpy(struct igc_hw *hw, u32 offset, u16 *data)\n{\n\tu8 dev_addr = (offset & GPY_MMD_MASK) >> GPY_MMD_SHIFT;\n\ts32 ret_val;\n\n\toffset = offset & GPY_REG_MASK;\n\n\tif (!dev_addr) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = igc_read_phy_reg_mdic(hw, offset, data);\n\t\thw->phy.ops.release(hw);\n\t} else {\n\t\tret_val = igc_read_xmdio_reg(hw, (u16)offset, dev_addr,\n\t\t\t\t\t     data);\n\t}\n\n\treturn ret_val;\n}\n\n \nu16 igc_read_phy_fw_version(struct igc_hw *hw)\n{\n\tstruct igc_phy_info *phy = &hw->phy;\n\tu16 gphy_version = 0;\n\tu16 ret_val;\n\n\t \n\tret_val = phy->ops.read_reg(hw, IGC_GPHY_VERSION, &gphy_version);\n\tif (ret_val)\n\t\thw_dbg(\"igc_phy: read wrong gphy version\\n\");\n\n\treturn gphy_version;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}