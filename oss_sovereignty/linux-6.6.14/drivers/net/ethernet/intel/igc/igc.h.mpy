{
  "module_name": "igc.h",
  "hash_id": "80ff897f4fc3ed7e44784672fdca711ba672015e65e0cb92d45a8f062413ae42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc.h",
  "human_readable_source": " \n \n\n#ifndef _IGC_H_\n#define _IGC_H_\n\n#include <linux/kobject.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/ethtool.h>\n#include <linux/sctp.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/timecounter.h>\n#include <linux/net_tstamp.h>\n#include <linux/bitfield.h>\n#include <linux/hrtimer.h>\n#include <net/xdp.h>\n\n#include \"igc_hw.h\"\n\nvoid igc_ethtool_set_ops(struct net_device *);\n\n \n#define IGC_MAX_RX_QUEUES\t\t4\n#define IGC_MAX_TX_QUEUES\t\t4\n\n#define MAX_Q_VECTORS\t\t\t8\n#define MAX_STD_JUMBO_FRAME_SIZE\t9216\n\n#define MAX_ETYPE_FILTER\t\t8\n#define IGC_RETA_SIZE\t\t\t128\n\n \n#define IGC_N_EXTTS\t2\n#define IGC_N_PEROUT\t2\n#define IGC_N_SDP\t4\n\n#define MAX_FLEX_FILTER\t\t\t32\n\n#define IGC_MAX_TX_TSTAMP_REGS\t\t4\n\nenum igc_mac_filter_type {\n\tIGC_MAC_FILTER_TYPE_DST = 0,\n\tIGC_MAC_FILTER_TYPE_SRC\n};\n\nstruct igc_tx_queue_stats {\n\tu64 packets;\n\tu64 bytes;\n\tu64 restart_queue;\n\tu64 restart_queue2;\n};\n\nstruct igc_rx_queue_stats {\n\tu64 packets;\n\tu64 bytes;\n\tu64 drops;\n\tu64 csum_err;\n\tu64 alloc_failed;\n};\n\nstruct igc_rx_packet_stats {\n\tu64 ipv4_packets;       \n\tu64 ipv4e_packets;      \n\tu64 ipv6_packets;       \n\tu64 ipv6e_packets;      \n\tu64 tcp_packets;        \n\tu64 udp_packets;        \n\tu64 sctp_packets;       \n\tu64 nfs_packets;        \n\tu64 other_packets;\n};\n\nstruct igc_tx_timestamp_request {\n\tstruct sk_buff *skb;    \n\tunsigned long start;    \n\tu32 mask;               \n\tu32 regl;               \n\tu32 regh;               \n\tu32 flags;              \n};\n\nstruct igc_ring_container {\n\tstruct igc_ring *ring;           \n\tunsigned int total_bytes;        \n\tunsigned int total_packets;      \n\tu16 work_limit;                  \n\tu8 count;                        \n\tu8 itr;                          \n};\n\nstruct igc_ring {\n\tstruct igc_q_vector *q_vector;   \n\tstruct net_device *netdev;       \n\tstruct device *dev;              \n\tunion {                          \n\t\tstruct igc_tx_buffer *tx_buffer_info;\n\t\tstruct igc_rx_buffer *rx_buffer_info;\n\t};\n\tvoid *desc;                      \n\tunsigned long flags;             \n\tvoid __iomem *tail;              \n\tdma_addr_t dma;                  \n\tunsigned int size;               \n\n\tu16 count;                       \n\tu8 queue_index;                  \n\tu8 reg_idx;                      \n\tbool launchtime_enable;          \n\tktime_t last_tx_cycle;           \n\tktime_t last_ff_cycle;           \n\n\tu32 start_time;\n\tu32 end_time;\n\tu32 max_sdu;\n\tbool oper_gate_closed;\t\t \n\tbool admin_gate_closed;\t\t \n\n\t \n\tbool cbs_enable;                 \n\ts32 idleslope;                   \n\ts32 sendslope;                   \n\ts32 hicredit;                    \n\ts32 locredit;                    \n\n\t \n\tu16 next_to_clean;\n\tu16 next_to_use;\n\tu16 next_to_alloc;\n\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tstruct igc_tx_queue_stats tx_stats;\n\t\t\tstruct u64_stats_sync tx_syncp;\n\t\t\tstruct u64_stats_sync tx_syncp2;\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\tstruct igc_rx_queue_stats rx_stats;\n\t\t\tstruct igc_rx_packet_stats pkt_stats;\n\t\t\tstruct u64_stats_sync rx_syncp;\n\t\t\tstruct sk_buff *skb;\n\t\t};\n\t};\n\n\tstruct xdp_rxq_info xdp_rxq;\n\tstruct xsk_buff_pool *xsk_pool;\n} ____cacheline_internodealigned_in_smp;\n\n \nstruct igc_adapter {\n\tstruct net_device *netdev;\n\n\tstruct ethtool_eee eee;\n\tu16 eee_advert;\n\n\tunsigned long state;\n\tunsigned int flags;\n\tunsigned int num_q_vectors;\n\n\tstruct msix_entry *msix_entries;\n\n\t \n\tu16 tx_work_limit;\n\tu32 tx_timeout_count;\n\tint num_tx_queues;\n\tstruct igc_ring *tx_ring[IGC_MAX_TX_QUEUES];\n\n\t \n\tint num_rx_queues;\n\tstruct igc_ring *rx_ring[IGC_MAX_RX_QUEUES];\n\n\tstruct timer_list watchdog_timer;\n\tstruct timer_list dma_err_timer;\n\tstruct timer_list phy_info_timer;\n\tstruct hrtimer hrtimer;\n\n\tu32 wol;\n\tu32 en_mng_pt;\n\tu16 link_speed;\n\tu16 link_duplex;\n\n\tu8 port_num;\n\n\tu8 __iomem *io_addr;\n\t \n\tu32 rx_itr_setting;\n\tu32 tx_itr_setting;\n\n\tstruct work_struct reset_task;\n\tstruct work_struct watchdog_task;\n\tstruct work_struct dma_err_task;\n\tbool fc_autoneg;\n\n\tu8 tx_timeout_factor;\n\n\tint msg_enable;\n\tu32 max_frame_size;\n\tu32 min_frame_size;\n\n\tint tc_setup_type;\n\tktime_t base_time;\n\tktime_t cycle_time;\n\tbool taprio_offload_enable;\n\tu32 qbv_config_change_errors;\n\tbool qbv_transition;\n\tunsigned int qbv_count;\n\t \n\tspinlock_t qbv_tx_lock;\n\n\t \n\tstruct pci_dev *pdev;\n\t \n\tspinlock_t stats64_lock;\n\tstruct rtnl_link_stats64 stats64;\n\n\t \n\tstruct igc_hw hw;\n\tstruct igc_hw_stats stats;\n\n\tstruct igc_q_vector *q_vector[MAX_Q_VECTORS];\n\tu32 eims_enable_mask;\n\tu32 eims_other;\n\n\tu16 tx_ring_count;\n\tu16 rx_ring_count;\n\n\tu32 tx_hwtstamp_timeouts;\n\tu32 tx_hwtstamp_skipped;\n\tu32 rx_hwtstamp_cleared;\n\n\tu32 rss_queues;\n\tu32 rss_indir_tbl_init;\n\n\t \n\tstruct mutex nfc_rule_lock;\n\tstruct list_head nfc_rule_list;\n\tunsigned int nfc_rule_count;\n\n\tu8 rss_indir_tbl[IGC_RETA_SIZE];\n\n\tunsigned long link_check_timeout;\n\tstruct igc_info ei;\n\n\tu32 test_icr;\n\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_caps;\n\t \n\tspinlock_t ptp_tx_lock;\n\tstruct igc_tx_timestamp_request tx_tstamp[IGC_MAX_TX_TSTAMP_REGS];\n\tstruct hwtstamp_config tstamp_config;\n\tunsigned int ptp_flags;\n\t \n\tspinlock_t tmreg_lock;\n\tstruct cyclecounter cc;\n\tstruct timecounter tc;\n\tstruct timespec64 prev_ptp_time;  \n\tktime_t ptp_reset_start;  \n\tstruct system_time_snapshot snapshot;\n\n\tchar fw_version[32];\n\n\tstruct bpf_prog *xdp_prog;\n\n\tbool pps_sys_wrap_on;\n\n\tstruct ptp_pin_desc sdp_config[IGC_N_SDP];\n\tstruct {\n\t\tstruct timespec64 start;\n\t\tstruct timespec64 period;\n\t} perout[IGC_N_PEROUT];\n};\n\nvoid igc_up(struct igc_adapter *adapter);\nvoid igc_down(struct igc_adapter *adapter);\nint igc_open(struct net_device *netdev);\nint igc_close(struct net_device *netdev);\nint igc_setup_tx_resources(struct igc_ring *ring);\nint igc_setup_rx_resources(struct igc_ring *ring);\nvoid igc_free_tx_resources(struct igc_ring *ring);\nvoid igc_free_rx_resources(struct igc_ring *ring);\nunsigned int igc_get_max_rss_queues(struct igc_adapter *adapter);\nvoid igc_set_flag_queue_pairs(struct igc_adapter *adapter,\n\t\t\t      const u32 max_rss_queues);\nint igc_reinit_queues(struct igc_adapter *adapter);\nvoid igc_write_rss_indir_tbl(struct igc_adapter *adapter);\nbool igc_has_link(struct igc_adapter *adapter);\nvoid igc_reset(struct igc_adapter *adapter);\nvoid igc_update_stats(struct igc_adapter *adapter);\nvoid igc_disable_rx_ring(struct igc_ring *ring);\nvoid igc_enable_rx_ring(struct igc_ring *ring);\nvoid igc_disable_tx_ring(struct igc_ring *ring);\nvoid igc_enable_tx_ring(struct igc_ring *ring);\nint igc_xsk_wakeup(struct net_device *dev, u32 queue_id, u32 flags);\n\n \nvoid igc_rings_dump(struct igc_adapter *adapter);\nvoid igc_regs_dump(struct igc_adapter *adapter);\n\nextern char igc_driver_name[];\n\n#define IGC_REGS_LEN\t\t\t740\n\n \n#define IGC_PTP_ENABLED\t\tBIT(0)\n\n \n#define IGC_FLAG_HAS_MSI\t\tBIT(0)\n#define IGC_FLAG_QUEUE_PAIRS\t\tBIT(3)\n#define IGC_FLAG_DMAC\t\t\tBIT(4)\n#define IGC_FLAG_PTP\t\t\tBIT(8)\n#define IGC_FLAG_WOL_SUPPORTED\t\tBIT(8)\n#define IGC_FLAG_NEED_LINK_UPDATE\tBIT(9)\n#define IGC_FLAG_HAS_MSIX\t\tBIT(13)\n#define IGC_FLAG_EEE\t\t\tBIT(14)\n#define IGC_FLAG_VLAN_PROMISC\t\tBIT(15)\n#define IGC_FLAG_RX_LEGACY\t\tBIT(16)\n#define IGC_FLAG_TSN_QBV_ENABLED\tBIT(17)\n#define IGC_FLAG_TSN_QAV_ENABLED\tBIT(18)\n\n#define IGC_FLAG_TSN_ANY_ENABLED \\\n\t(IGC_FLAG_TSN_QBV_ENABLED | IGC_FLAG_TSN_QAV_ENABLED)\n\n#define IGC_FLAG_RSS_FIELD_IPV4_UDP\tBIT(6)\n#define IGC_FLAG_RSS_FIELD_IPV6_UDP\tBIT(7)\n\n#define IGC_MRQC_ENABLE_RSS_MQ\t\t0x00000002\n#define IGC_MRQC_RSS_FIELD_IPV4_UDP\t0x00400000\n#define IGC_MRQC_RSS_FIELD_IPV6_UDP\t0x00800000\n\n \nenum igc_rss_type_num {\n\tIGC_RSS_TYPE_NO_HASH\t\t= 0,\n\tIGC_RSS_TYPE_HASH_TCP_IPV4\t= 1,\n\tIGC_RSS_TYPE_HASH_IPV4\t\t= 2,\n\tIGC_RSS_TYPE_HASH_TCP_IPV6\t= 3,\n\tIGC_RSS_TYPE_HASH_IPV6_EX\t= 4,\n\tIGC_RSS_TYPE_HASH_IPV6\t\t= 5,\n\tIGC_RSS_TYPE_HASH_TCP_IPV6_EX\t= 6,\n\tIGC_RSS_TYPE_HASH_UDP_IPV4\t= 7,\n\tIGC_RSS_TYPE_HASH_UDP_IPV6\t= 8,\n\tIGC_RSS_TYPE_HASH_UDP_IPV6_EX\t= 9,\n\tIGC_RSS_TYPE_MAX\t\t= 10,\n};\n#define IGC_RSS_TYPE_MAX_TABLE\t\t16\n#define IGC_RSS_TYPE_MASK\t\tGENMASK(3,0)  \n\n \nstatic inline u32 igc_rss_type(const union igc_adv_rx_desc *rx_desc)\n{\n\t \n\treturn le32_get_bits(rx_desc->wb.lower.lo_dword.data, IGC_RSS_TYPE_MASK);\n}\n\n \n#define IGC_START_ITR\t\t\t648  \n#define IGC_4K_ITR\t\t\t980\n#define IGC_20K_ITR\t\t\t196\n#define IGC_70K_ITR\t\t\t56\n\n#define IGC_DEFAULT_ITR\t\t3  \n#define IGC_MAX_ITR_USECS\t10000\n#define IGC_MIN_ITR_USECS\t10\n#define NON_Q_VECTORS\t\t1\n#define MAX_MSIX_ENTRIES\t10\n\n \n#define IGC_DEFAULT_TXD\t\t256\n#define IGC_DEFAULT_TX_WORK\t128\n#define IGC_MIN_TXD\t\t64\n#define IGC_MAX_TXD\t\t4096\n\n#define IGC_DEFAULT_RXD\t\t256\n#define IGC_MIN_RXD\t\t64\n#define IGC_MAX_RXD\t\t4096\n\n \n#define IGC_RXBUFFER_256\t\t256\n#define IGC_RXBUFFER_2048\t\t2048\n#define IGC_RXBUFFER_3072\t\t3072\n\n#define AUTO_ALL_MODES\t\t0\n#define IGC_RX_HDR_LEN\t\t\tIGC_RXBUFFER_256\n\n \n#define IGC_I225_TX_LATENCY_10\t\t240\n#define IGC_I225_TX_LATENCY_100\t\t58\n#define IGC_I225_TX_LATENCY_1000\t80\n#define IGC_I225_TX_LATENCY_2500\t1325\n#define IGC_I225_RX_LATENCY_10\t\t6450\n#define IGC_I225_RX_LATENCY_100\t\t185\n#define IGC_I225_RX_LATENCY_1000\t300\n#define IGC_I225_RX_LATENCY_2500\t1485\n\n \n#define IGC_RX_PTHRESH\t\t\t8\n#define IGC_RX_HTHRESH\t\t\t8\n#define IGC_TX_PTHRESH\t\t\t8\n#define IGC_TX_HTHRESH\t\t\t1\n#define IGC_RX_WTHRESH\t\t\t4\n#define IGC_TX_WTHRESH\t\t\t16\n\n#define IGC_RX_DMA_ATTR \\\n\t(DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING)\n\n#define IGC_TS_HDR_LEN\t\t\t16\n\n#define IGC_SKB_PAD\t\t\t(NET_SKB_PAD + NET_IP_ALIGN)\n\n#if (PAGE_SIZE < 8192)\n#define IGC_MAX_FRAME_BUILD_SKB \\\n\t(SKB_WITH_OVERHEAD(IGC_RXBUFFER_2048) - IGC_SKB_PAD - IGC_TS_HDR_LEN)\n#else\n#define IGC_MAX_FRAME_BUILD_SKB (IGC_RXBUFFER_2048 - IGC_TS_HDR_LEN)\n#endif\n\n \n#define IGC_RX_BUFFER_WRITE\t16  \n\n \n#define IGC_TX_FLAGS_VLAN_MASK\t0xffff0000\n#define IGC_TX_FLAGS_VLAN_SHIFT\t16\n\n \nstatic inline __le32 igc_test_staterr(union igc_adv_rx_desc *rx_desc,\n\t\t\t\t      const u32 stat_err_bits)\n{\n\treturn rx_desc->wb.upper.status_error & cpu_to_le32(stat_err_bits);\n}\n\nenum igc_state_t {\n\t__IGC_TESTING,\n\t__IGC_RESETTING,\n\t__IGC_DOWN,\n};\n\nenum igc_tx_flags {\n\t \n\tIGC_TX_FLAGS_VLAN\t= 0x01,\n\tIGC_TX_FLAGS_TSO\t= 0x02,\n\tIGC_TX_FLAGS_TSTAMP\t= 0x04,\n\n\t \n\tIGC_TX_FLAGS_IPV4\t= 0x10,\n\tIGC_TX_FLAGS_CSUM\t= 0x20,\n\n\tIGC_TX_FLAGS_TSTAMP_1\t= 0x100,\n\tIGC_TX_FLAGS_TSTAMP_2\t= 0x200,\n\tIGC_TX_FLAGS_TSTAMP_3\t= 0x400,\n};\n\nenum igc_boards {\n\tboard_base,\n};\n\n \n#define IGC_MAX_TXD_PWR\t\t15\n#define IGC_MAX_DATA_PER_TXD\tBIT(IGC_MAX_TXD_PWR)\n\n \n#define TXD_USE_COUNT(S)\tDIV_ROUND_UP((S), IGC_MAX_DATA_PER_TXD)\n#define DESC_NEEDED\t(MAX_SKB_FRAGS + 4)\n\nenum igc_tx_buffer_type {\n\tIGC_TX_BUFFER_TYPE_SKB,\n\tIGC_TX_BUFFER_TYPE_XDP,\n\tIGC_TX_BUFFER_TYPE_XSK,\n};\n\n \nstruct igc_tx_buffer {\n\tunion igc_adv_tx_desc *next_to_watch;\n\tunsigned long time_stamp;\n\tenum igc_tx_buffer_type type;\n\tunion {\n\t\tstruct sk_buff *skb;\n\t\tstruct xdp_frame *xdpf;\n\t};\n\tunsigned int bytecount;\n\tu16 gso_segs;\n\t__be16 protocol;\n\n\tDEFINE_DMA_UNMAP_ADDR(dma);\n\tDEFINE_DMA_UNMAP_LEN(len);\n\tu32 tx_flags;\n};\n\nstruct igc_rx_buffer {\n\tunion {\n\t\tstruct {\n\t\t\tdma_addr_t dma;\n\t\t\tstruct page *page;\n#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)\n\t\t\t__u32 page_offset;\n#else\n\t\t\t__u16 page_offset;\n#endif\n\t\t\t__u16 pagecnt_bias;\n\t\t};\n\t\tstruct xdp_buff *xdp;\n\t};\n};\n\n \nstruct igc_xdp_buff {\n\tstruct xdp_buff xdp;\n\tunion igc_adv_rx_desc *rx_desc;\n\tktime_t rx_ts;  \n};\n\nstruct igc_q_vector {\n\tstruct igc_adapter *adapter;     \n\tvoid __iomem *itr_register;\n\tu32 eims_value;                  \n\n\tu16 itr_val;\n\tu8 set_itr;\n\n\tstruct igc_ring_container rx, tx;\n\n\tstruct napi_struct napi;\n\n\tstruct rcu_head rcu;     \n\tchar name[IFNAMSIZ + 9];\n\tstruct net_device poll_dev;\n\n\t \n\tstruct igc_ring ring[] ____cacheline_internodealigned_in_smp;\n};\n\nenum igc_filter_match_flags {\n\tIGC_FILTER_FLAG_ETHER_TYPE =\tBIT(0),\n\tIGC_FILTER_FLAG_VLAN_TCI   =\tBIT(1),\n\tIGC_FILTER_FLAG_SRC_MAC_ADDR =\tBIT(2),\n\tIGC_FILTER_FLAG_DST_MAC_ADDR =\tBIT(3),\n\tIGC_FILTER_FLAG_USER_DATA =\tBIT(4),\n\tIGC_FILTER_FLAG_VLAN_ETYPE =\tBIT(5),\n};\n\nstruct igc_nfc_filter {\n\tu8 match_flags;\n\tu16 etype;\n\t__be16 vlan_etype;\n\tu16 vlan_tci;\n\tu16 vlan_tci_mask;\n\tu8 src_addr[ETH_ALEN];\n\tu8 dst_addr[ETH_ALEN];\n\tu8 user_data[8];\n\tu8 user_mask[8];\n\tu8 flex_index;\n\tu8 rx_queue;\n\tu8 prio;\n\tu8 immediate_irq;\n\tu8 drop;\n};\n\nstruct igc_nfc_rule {\n\tstruct list_head list;\n\tstruct igc_nfc_filter filter;\n\tu32 location;\n\tu16 action;\n\tbool flex;\n};\n\n \n#define IGC_MAX_RXNFC_RULES\t\t64\n\nstruct igc_flex_filter {\n\tu8 index;\n\tu8 data[128];\n\tu8 mask[16];\n\tu8 length;\n\tu8 rx_queue;\n\tu8 prio;\n\tu8 immediate_irq;\n\tu8 drop;\n};\n\n \nstatic inline u16 igc_desc_unused(const struct igc_ring *ring)\n{\n\tu16 ntc = ring->next_to_clean;\n\tu16 ntu = ring->next_to_use;\n\n\treturn ((ntc > ntu) ? 0 : ring->count) + ntc - ntu - 1;\n}\n\nstatic inline s32 igc_get_phy_info(struct igc_hw *hw)\n{\n\tif (hw->phy.ops.get_phy_info)\n\t\treturn hw->phy.ops.get_phy_info(hw);\n\n\treturn 0;\n}\n\nstatic inline s32 igc_reset_phy(struct igc_hw *hw)\n{\n\tif (hw->phy.ops.reset)\n\t\treturn hw->phy.ops.reset(hw);\n\n\treturn 0;\n}\n\nstatic inline struct netdev_queue *txring_txq(const struct igc_ring *tx_ring)\n{\n\treturn netdev_get_tx_queue(tx_ring->netdev, tx_ring->queue_index);\n}\n\nenum igc_ring_flags_t {\n\tIGC_RING_FLAG_RX_3K_BUFFER,\n\tIGC_RING_FLAG_RX_BUILD_SKB_ENABLED,\n\tIGC_RING_FLAG_RX_SCTP_CSUM,\n\tIGC_RING_FLAG_RX_LB_VLAN_BSWAP,\n\tIGC_RING_FLAG_TX_CTX_IDX,\n\tIGC_RING_FLAG_TX_DETECT_HANG,\n\tIGC_RING_FLAG_AF_XDP_ZC,\n\tIGC_RING_FLAG_TX_HWTSTAMP,\n};\n\n#define ring_uses_large_buffer(ring) \\\n\ttest_bit(IGC_RING_FLAG_RX_3K_BUFFER, &(ring)->flags)\n#define set_ring_uses_large_buffer(ring) \\\n\tset_bit(IGC_RING_FLAG_RX_3K_BUFFER, &(ring)->flags)\n#define clear_ring_uses_large_buffer(ring) \\\n\tclear_bit(IGC_RING_FLAG_RX_3K_BUFFER, &(ring)->flags)\n\n#define ring_uses_build_skb(ring) \\\n\ttest_bit(IGC_RING_FLAG_RX_BUILD_SKB_ENABLED, &(ring)->flags)\n\nstatic inline unsigned int igc_rx_bufsz(struct igc_ring *ring)\n{\n#if (PAGE_SIZE < 8192)\n\tif (ring_uses_large_buffer(ring))\n\t\treturn IGC_RXBUFFER_3072;\n\n\tif (ring_uses_build_skb(ring))\n\t\treturn IGC_MAX_FRAME_BUILD_SKB + IGC_TS_HDR_LEN;\n#endif\n\treturn IGC_RXBUFFER_2048;\n}\n\nstatic inline unsigned int igc_rx_pg_order(struct igc_ring *ring)\n{\n#if (PAGE_SIZE < 8192)\n\tif (ring_uses_large_buffer(ring))\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\nstatic inline s32 igc_read_phy_reg(struct igc_hw *hw, u32 offset, u16 *data)\n{\n\tif (hw->phy.ops.read_reg)\n\t\treturn hw->phy.ops.read_reg(hw, offset, data);\n\n\treturn -EOPNOTSUPP;\n}\n\nvoid igc_reinit_locked(struct igc_adapter *);\nstruct igc_nfc_rule *igc_get_nfc_rule(struct igc_adapter *adapter,\n\t\t\t\t      u32 location);\nint igc_add_nfc_rule(struct igc_adapter *adapter, struct igc_nfc_rule *rule);\nvoid igc_del_nfc_rule(struct igc_adapter *adapter, struct igc_nfc_rule *rule);\n\nvoid igc_ptp_init(struct igc_adapter *adapter);\nvoid igc_ptp_reset(struct igc_adapter *adapter);\nvoid igc_ptp_suspend(struct igc_adapter *adapter);\nvoid igc_ptp_stop(struct igc_adapter *adapter);\nktime_t igc_ptp_rx_pktstamp(struct igc_adapter *adapter, __le32 *buf);\nint igc_ptp_set_ts_config(struct net_device *netdev, struct ifreq *ifr);\nint igc_ptp_get_ts_config(struct net_device *netdev, struct ifreq *ifr);\nvoid igc_ptp_tx_hang(struct igc_adapter *adapter);\nvoid igc_ptp_read(struct igc_adapter *adapter, struct timespec64 *ts);\nvoid igc_ptp_tx_tstamp_event(struct igc_adapter *adapter);\n\n#define igc_rx_pg_size(_ring) (PAGE_SIZE << igc_rx_pg_order(_ring))\n\n#define IGC_TXD_DCMD\t(IGC_ADVTXD_DCMD_EOP | IGC_ADVTXD_DCMD_RS)\n\n#define IGC_RX_DESC(R, i)       \\\n\t(&(((union igc_adv_rx_desc *)((R)->desc))[i]))\n#define IGC_TX_DESC(R, i)       \\\n\t(&(((union igc_adv_tx_desc *)((R)->desc))[i]))\n#define IGC_TX_CTXTDESC(R, i)   \\\n\t(&(((struct igc_adv_tx_context_desc *)((R)->desc))[i]))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}