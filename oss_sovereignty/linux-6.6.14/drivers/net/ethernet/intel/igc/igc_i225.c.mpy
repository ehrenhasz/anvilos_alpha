{
  "module_name": "igc_i225.c",
  "hash_id": "1e1b0a246a32ecbf927dc2de79b6a7e8cb7df6ecfd13ece92811c22935c20c0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_i225.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include \"igc_hw.h\"\n\n \nstatic s32 igc_acquire_nvm_i225(struct igc_hw *hw)\n{\n\treturn igc_acquire_swfw_sync_i225(hw, IGC_SWFW_EEP_SM);\n}\n\n \nstatic void igc_release_nvm_i225(struct igc_hw *hw)\n{\n\tigc_release_swfw_sync_i225(hw, IGC_SWFW_EEP_SM);\n}\n\n \nstatic s32 igc_get_hw_semaphore_i225(struct igc_hw *hw)\n{\n\ts32 timeout = hw->nvm.word_size + 1;\n\ts32 i = 0;\n\tu32 swsm;\n\n\t \n\twhile (i < timeout) {\n\t\tswsm = rd32(IGC_SWSM);\n\t\tif (!(swsm & IGC_SWSM_SMBI))\n\t\t\tbreak;\n\n\t\tusleep_range(500, 600);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\t \n\t\tif (hw->dev_spec._base.clear_semaphore_once) {\n\t\t\thw->dev_spec._base.clear_semaphore_once = false;\n\t\t\tigc_put_hw_semaphore(hw);\n\t\t\tfor (i = 0; i < timeout; i++) {\n\t\t\t\tswsm = rd32(IGC_SWSM);\n\t\t\t\tif (!(swsm & IGC_SWSM_SMBI))\n\t\t\t\t\tbreak;\n\n\t\t\t\tusleep_range(500, 600);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i == timeout) {\n\t\t\thw_dbg(\"Driver can't access device - SMBI bit is set.\\n\");\n\t\t\treturn -IGC_ERR_NVM;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tswsm = rd32(IGC_SWSM);\n\t\twr32(IGC_SWSM, swsm | IGC_SWSM_SWESMBI);\n\n\t\t \n\t\tif (rd32(IGC_SWSM) & IGC_SWSM_SWESMBI)\n\t\t\tbreak;\n\n\t\tusleep_range(500, 600);\n\t}\n\n\tif (i == timeout) {\n\t\t \n\t\tigc_put_hw_semaphore(hw);\n\t\thw_dbg(\"Driver can't access the NVM\\n\");\n\t\treturn -IGC_ERR_NVM;\n\t}\n\n\treturn 0;\n}\n\n \ns32 igc_acquire_swfw_sync_i225(struct igc_hw *hw, u16 mask)\n{\n\ts32 i = 0, timeout = 200;\n\tu32 fwmask = mask << 16;\n\tu32 swmask = mask;\n\ts32 ret_val = 0;\n\tu32 swfw_sync;\n\n\twhile (i < timeout) {\n\t\tif (igc_get_hw_semaphore_i225(hw)) {\n\t\t\tret_val = -IGC_ERR_SWFW_SYNC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswfw_sync = rd32(IGC_SW_FW_SYNC);\n\t\tif (!(swfw_sync & (fwmask | swmask)))\n\t\t\tbreak;\n\n\t\t \n\t\tigc_put_hw_semaphore(hw);\n\t\tmdelay(5);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\thw_dbg(\"Driver can't access resource, SW_FW_SYNC timeout.\\n\");\n\t\tret_val = -IGC_ERR_SWFW_SYNC;\n\t\tgoto out;\n\t}\n\n\tswfw_sync |= swmask;\n\twr32(IGC_SW_FW_SYNC, swfw_sync);\n\n\tigc_put_hw_semaphore(hw);\nout:\n\treturn ret_val;\n}\n\n \nvoid igc_release_swfw_sync_i225(struct igc_hw *hw, u16 mask)\n{\n\tu32 swfw_sync;\n\n\t \n\tif (igc_get_hw_semaphore_i225(hw)) {\n\t\thw_dbg(\"Failed to release SW_FW_SYNC.\\n\");\n\t\treturn;\n\t}\n\n\tswfw_sync = rd32(IGC_SW_FW_SYNC);\n\tswfw_sync &= ~mask;\n\twr32(IGC_SW_FW_SYNC, swfw_sync);\n\n\tigc_put_hw_semaphore(hw);\n}\n\n \nstatic s32 igc_read_nvm_srrd_i225(struct igc_hw *hw, u16 offset, u16 words,\n\t\t\t\t  u16 *data)\n{\n\ts32 status = 0;\n\tu16 i, count;\n\n\t \n\tfor (i = 0; i < words; i += IGC_EERD_EEWR_MAX_COUNT) {\n\t\tcount = (words - i) / IGC_EERD_EEWR_MAX_COUNT > 0 ?\n\t\t\tIGC_EERD_EEWR_MAX_COUNT : (words - i);\n\n\t\tstatus = hw->nvm.ops.acquire(hw);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tstatus = igc_read_nvm_eerd(hw, offset, count, data + i);\n\t\thw->nvm.ops.release(hw);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 igc_write_nvm_srwr(struct igc_hw *hw, u16 offset, u16 words,\n\t\t\t      u16 *data)\n{\n\tstruct igc_nvm_info *nvm = &hw->nvm;\n\ts32 ret_val = -IGC_ERR_NVM;\n\tu32 attempts = 100000;\n\tu32 i, k, eewr = 0;\n\n\t \n\tif (offset >= nvm->word_size || (words > (nvm->word_size - offset)) ||\n\t    words == 0) {\n\t\thw_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\treturn ret_val;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\tret_val = -IGC_ERR_NVM;\n\t\teewr = ((offset + i) << IGC_NVM_RW_ADDR_SHIFT) |\n\t\t\t(data[i] << IGC_NVM_RW_REG_DATA) |\n\t\t\tIGC_NVM_RW_REG_START;\n\n\t\twr32(IGC_SRWR, eewr);\n\n\t\tfor (k = 0; k < attempts; k++) {\n\t\t\tif (IGC_NVM_RW_REG_DONE &\n\t\t\t    rd32(IGC_SRWR)) {\n\t\t\t\tret_val = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(5);\n\t\t}\n\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Shadow RAM write EEWR timed out\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 igc_write_nvm_srwr_i225(struct igc_hw *hw, u16 offset, u16 words,\n\t\t\t\t   u16 *data)\n{\n\ts32 status = 0;\n\tu16 i, count;\n\n\t \n\tfor (i = 0; i < words; i += IGC_EERD_EEWR_MAX_COUNT) {\n\t\tcount = (words - i) / IGC_EERD_EEWR_MAX_COUNT > 0 ?\n\t\t\tIGC_EERD_EEWR_MAX_COUNT : (words - i);\n\n\t\tstatus = hw->nvm.ops.acquire(hw);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tstatus = igc_write_nvm_srwr(hw, offset, count, data + i);\n\t\thw->nvm.ops.release(hw);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 igc_validate_nvm_checksum_i225(struct igc_hw *hw)\n{\n\ts32 (*read_op_ptr)(struct igc_hw *hw, u16 offset, u16 count,\n\t\t\t   u16 *data);\n\ts32 status = 0;\n\n\tstatus = hw->nvm.ops.acquire(hw);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tread_op_ptr = hw->nvm.ops.read;\n\thw->nvm.ops.read = igc_read_nvm_eerd;\n\n\tstatus = igc_validate_nvm_checksum(hw);\n\n\t \n\thw->nvm.ops.read = read_op_ptr;\n\n\thw->nvm.ops.release(hw);\n\nout:\n\treturn status;\n}\n\n \nstatic s32 igc_pool_flash_update_done_i225(struct igc_hw *hw)\n{\n\ts32 ret_val = -IGC_ERR_NVM;\n\tu32 i, reg;\n\n\tfor (i = 0; i < IGC_FLUDONE_ATTEMPTS; i++) {\n\t\treg = rd32(IGC_EECD);\n\t\tif (reg & IGC_EECD_FLUDONE_I225) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(5);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 igc_update_flash_i225(struct igc_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu32 flup;\n\n\tret_val = igc_pool_flash_update_done_i225(hw);\n\tif (ret_val == -IGC_ERR_NVM) {\n\t\thw_dbg(\"Flash update time out\\n\");\n\t\tgoto out;\n\t}\n\n\tflup = rd32(IGC_EECD) | IGC_EECD_FLUPD_I225;\n\twr32(IGC_EECD, flup);\n\n\tret_val = igc_pool_flash_update_done_i225(hw);\n\tif (ret_val)\n\t\thw_dbg(\"Flash update time out\\n\");\n\telse\n\t\thw_dbg(\"Flash update complete\\n\");\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igc_update_nvm_checksum_i225(struct igc_hw *hw)\n{\n\tu16 checksum = 0;\n\ts32 ret_val = 0;\n\tu16 i, nvm_data;\n\n\t \n\tret_val = igc_read_nvm_eerd(hw, 0, 1, &nvm_data);\n\tif (ret_val) {\n\t\thw_dbg(\"EEPROM read failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret_val = hw->nvm.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\n\tfor (i = 0; i < NVM_CHECKSUM_REG; i++) {\n\t\tret_val = igc_read_nvm_eerd(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw->nvm.ops.release(hw);\n\t\t\thw_dbg(\"NVM Read Error while updating checksum.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\tchecksum = (u16)NVM_SUM - checksum;\n\tret_val = igc_write_nvm_srwr(hw, NVM_CHECKSUM_REG, 1,\n\t\t\t\t     &checksum);\n\tif (ret_val) {\n\t\thw->nvm.ops.release(hw);\n\t\thw_dbg(\"NVM Write Error while updating checksum.\\n\");\n\t\tgoto out;\n\t}\n\n\thw->nvm.ops.release(hw);\n\n\tret_val = igc_update_flash_i225(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nbool igc_get_flash_presence_i225(struct igc_hw *hw)\n{\n\tbool ret_val = false;\n\tu32 eec = 0;\n\n\teec = rd32(IGC_EECD);\n\tif (eec & IGC_EECD_FLASH_DETECTED_I225)\n\t\tret_val = true;\n\n\treturn ret_val;\n}\n\n \ns32 igc_init_nvm_params_i225(struct igc_hw *hw)\n{\n\tstruct igc_nvm_info *nvm = &hw->nvm;\n\n\tnvm->ops.acquire = igc_acquire_nvm_i225;\n\tnvm->ops.release = igc_release_nvm_i225;\n\n\t \n\tif (igc_get_flash_presence_i225(hw)) {\n\t\tnvm->ops.read = igc_read_nvm_srrd_i225;\n\t\tnvm->ops.write = igc_write_nvm_srwr_i225;\n\t\tnvm->ops.validate = igc_validate_nvm_checksum_i225;\n\t\tnvm->ops.update = igc_update_nvm_checksum_i225;\n\t} else {\n\t\tnvm->ops.read = igc_read_nvm_eerd;\n\t\tnvm->ops.write = NULL;\n\t\tnvm->ops.validate = NULL;\n\t\tnvm->ops.update = NULL;\n\t}\n\treturn 0;\n}\n\n \ns32 igc_set_eee_i225(struct igc_hw *hw, bool adv2p5G, bool adv1G,\n\t\t     bool adv100M)\n{\n\tu32 ipcnfg, eeer;\n\n\tipcnfg = rd32(IGC_IPCNFG);\n\teeer = rd32(IGC_EEER);\n\n\t \n\tif (hw->dev_spec._base.eee_enable) {\n\t\tu32 eee_su = rd32(IGC_EEE_SU);\n\n\t\tif (adv100M)\n\t\t\tipcnfg |= IGC_IPCNFG_EEE_100M_AN;\n\t\telse\n\t\t\tipcnfg &= ~IGC_IPCNFG_EEE_100M_AN;\n\n\t\tif (adv1G)\n\t\t\tipcnfg |= IGC_IPCNFG_EEE_1G_AN;\n\t\telse\n\t\t\tipcnfg &= ~IGC_IPCNFG_EEE_1G_AN;\n\n\t\tif (adv2p5G)\n\t\t\tipcnfg |= IGC_IPCNFG_EEE_2_5G_AN;\n\t\telse\n\t\t\tipcnfg &= ~IGC_IPCNFG_EEE_2_5G_AN;\n\n\t\teeer |= (IGC_EEER_TX_LPI_EN | IGC_EEER_RX_LPI_EN |\n\t\t\t IGC_EEER_LPI_FC);\n\n\t\t \n\t\tif (eee_su & IGC_EEE_SU_LPI_CLK_STP)\n\t\t\thw_dbg(\"LPI Clock Stop Bit should not be set!\\n\");\n\t} else {\n\t\tipcnfg &= ~(IGC_IPCNFG_EEE_2_5G_AN | IGC_IPCNFG_EEE_1G_AN |\n\t\t\t    IGC_IPCNFG_EEE_100M_AN);\n\t\teeer &= ~(IGC_EEER_TX_LPI_EN | IGC_EEER_RX_LPI_EN |\n\t\t\t  IGC_EEER_LPI_FC);\n\t}\n\twr32(IGC_IPCNFG, ipcnfg);\n\twr32(IGC_EEER, eeer);\n\trd32(IGC_IPCNFG);\n\trd32(IGC_EEER);\n\n\treturn IGC_SUCCESS;\n}\n\n \ns32 igc_set_ltr_i225(struct igc_hw *hw, bool link)\n{\n\tu32 tw_system, ltrc, ltrv, ltr_min, ltr_max, scale_min, scale_max;\n\tu16 speed, duplex;\n\ts32 size;\n\n\t \n\tif (link) {\n\t\thw->mac.ops.get_speed_and_duplex(hw, &speed, &duplex);\n\n\t\t \n\t\tif (hw->dev_spec._base.eee_enable &&\n\t\t    speed != SPEED_10) {\n\t\t\t \n\t\t\tltrc = rd32(IGC_LTRC) |\n\t\t\t       IGC_LTRC_EEEMS_EN;\n\t\t\twr32(IGC_LTRC, ltrc);\n\n\t\t\t \n\t\t\tif (speed == SPEED_100) {\n\t\t\t\ttw_system = ((rd32(IGC_EEE_SU) &\n\t\t\t\t\t     IGC_TW_SYSTEM_100_MASK) >>\n\t\t\t\t\t     IGC_TW_SYSTEM_100_SHIFT) * 500;\n\t\t\t} else {\n\t\t\t\ttw_system = (rd32(IGC_EEE_SU) &\n\t\t\t\t\t     IGC_TW_SYSTEM_1000_MASK) * 500;\n\t\t\t}\n\t\t} else {\n\t\t\ttw_system = 0;\n\t\t}\n\n\t\t \n\t\tsize = rd32(IGC_RXPBS) &\n\t\t       IGC_RXPBS_SIZE_I225_MASK;\n\n\t\t \n\t\tsize *= 1024;\n\t\tsize *= 8;\n\n\t\tif (size < 0) {\n\t\t\thw_dbg(\"Invalid effective Rx buffer size %d\\n\",\n\t\t\t       size);\n\t\t\treturn -IGC_ERR_CONFIG;\n\t\t}\n\n\t\t \n\t\tltr_min = (1000 * size) / speed;\n\t\tltr_max = ltr_min + tw_system;\n\t\tscale_min = (ltr_min / 1024) < 1024 ? IGC_LTRMINV_SCALE_1024 :\n\t\t\t    IGC_LTRMINV_SCALE_32768;\n\t\tscale_max = (ltr_max / 1024) < 1024 ? IGC_LTRMAXV_SCALE_1024 :\n\t\t\t    IGC_LTRMAXV_SCALE_32768;\n\t\tltr_min /= scale_min == IGC_LTRMINV_SCALE_1024 ? 1024 : 32768;\n\t\tltr_min -= 1;\n\t\tltr_max /= scale_max == IGC_LTRMAXV_SCALE_1024 ? 1024 : 32768;\n\t\tltr_max -= 1;\n\n\t\t \n\t\tltrv = rd32(IGC_LTRMINV);\n\t\tif (ltr_min != (ltrv & IGC_LTRMINV_LTRV_MASK)) {\n\t\t\tltrv = IGC_LTRMINV_LSNP_REQ | ltr_min |\n\t\t\t       (scale_min << IGC_LTRMINV_SCALE_SHIFT);\n\t\t\twr32(IGC_LTRMINV, ltrv);\n\t\t}\n\n\t\tltrv = rd32(IGC_LTRMAXV);\n\t\tif (ltr_max != (ltrv & IGC_LTRMAXV_LTRV_MASK)) {\n\t\t\tltrv = IGC_LTRMAXV_LSNP_REQ | ltr_max |\n\t\t\t       (scale_max << IGC_LTRMAXV_SCALE_SHIFT);\n\t\t\twr32(IGC_LTRMAXV, ltrv);\n\t\t}\n\t}\n\n\treturn IGC_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}