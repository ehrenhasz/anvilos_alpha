{
  "module_name": "igc_diag.c",
  "hash_id": "a511d6dd070493a56808525ef906f55fbfd999d3270b7cc679b7e5ab40ea12af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_diag.c",
  "human_readable_source": "\n \n\n#include \"igc.h\"\n#include \"igc_diag.h\"\n\nstatic struct igc_reg_test reg_test[] = {\n\t{ IGC_FCAL,\t1,\tPATTERN_TEST,\t0xFFFFFFFF,\t0xFFFFFFFF },\n\t{ IGC_FCAH,\t1,\tPATTERN_TEST,\t0x0000FFFF,\t0xFFFFFFFF },\n\t{ IGC_FCT,\t1,\tPATTERN_TEST,\t0x0000FFFF,\t0xFFFFFFFF },\n\t{ IGC_RDBAH(0), 4,\tPATTERN_TEST,\t0xFFFFFFFF,\t0xFFFFFFFF },\n\t{ IGC_RDBAL(0),\t4,\tPATTERN_TEST,\t0xFFFFFF80,\t0xFFFFFF80 },\n\t{ IGC_RDLEN(0),\t4,\tPATTERN_TEST,\t0x000FFF80,\t0x000FFFFF },\n\t{ IGC_RDT(0),\t4,\tPATTERN_TEST,\t0x0000FFFF,\t0x0000FFFF },\n\t{ IGC_FCRTH,\t1,\tPATTERN_TEST,\t0x0003FFF0,\t0x0003FFF0 },\n\t{ IGC_FCTTV,\t1,\tPATTERN_TEST,\t0x0000FFFF,\t0x0000FFFF },\n\t{ IGC_TIPG,\t1,\tPATTERN_TEST,\t0x3FFFFFFF,\t0x3FFFFFFF },\n\t{ IGC_TDBAH(0),\t4,\tPATTERN_TEST,\t0xFFFFFFFF,\t0xFFFFFFFF },\n\t{ IGC_TDBAL(0),\t4,\tPATTERN_TEST,\t0xFFFFFF80,\t0xFFFFFF80 },\n\t{ IGC_TDLEN(0),\t4,\tPATTERN_TEST,\t0x000FFF80,\t0x000FFFFF },\n\t{ IGC_TDT(0),\t4,\tPATTERN_TEST,\t0x0000FFFF,\t0x0000FFFF },\n\t{ IGC_RCTL,\t1,\tSET_READ_TEST,\t0xFFFFFFFF,\t0x00000000 },\n\t{ IGC_RCTL,\t1,\tSET_READ_TEST,\t0x04CFB2FE,\t0x003FFFFB },\n\t{ IGC_RCTL,\t1,\tSET_READ_TEST,\t0x04CFB2FE,\t0xFFFFFFFF },\n\t{ IGC_TCTL,\t1,\tSET_READ_TEST,\t0xFFFFFFFF,\t0x00000000 },\n\t{ IGC_RA,\t16,\tTABLE64_TEST_LO,\n\t\t\t\t\t\t0xFFFFFFFF,\t0xFFFFFFFF },\n\t{ IGC_RA,\t16,\tTABLE64_TEST_HI,\n\t\t\t\t\t\t0x900FFFFF,\t0xFFFFFFFF },\n\t{ IGC_MTA,\t128,\tTABLE32_TEST,\n\t\t\t\t\t\t0xFFFFFFFF,\t0xFFFFFFFF },\n\t{ 0, 0, 0, 0}\n};\n\nstatic bool reg_pattern_test(struct igc_adapter *adapter, u64 *data, int reg,\n\t\t\t     u32 mask, u32 write)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 pat, val, before;\n\tstatic const u32 test_pattern[] = {\n\t\t0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF\n\t};\n\n\tfor (pat = 0; pat < ARRAY_SIZE(test_pattern); pat++) {\n\t\tbefore = rd32(reg);\n\t\twr32(reg, test_pattern[pat] & write);\n\t\tval = rd32(reg);\n\t\tif (val != (test_pattern[pat] & write & mask)) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"pattern test reg %04X failed: got 0x%08X expected 0x%08X\",\n\t\t\t\t   reg, val, test_pattern[pat] & write & mask);\n\t\t\t*data = reg;\n\t\t\twr32(reg, before);\n\t\t\treturn false;\n\t\t}\n\t\twr32(reg, before);\n\t}\n\treturn true;\n}\n\nstatic bool reg_set_and_check(struct igc_adapter *adapter, u64 *data, int reg,\n\t\t\t      u32 mask, u32 write)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 val, before;\n\n\tbefore = rd32(reg);\n\twr32(reg, write & mask);\n\tval = rd32(reg);\n\tif ((write & mask) != (val & mask)) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"set/check reg %04X test failed: got 0x%08X expected 0x%08X\",\n\t\t\t   reg, (val & mask), (write & mask));\n\t\t*data = reg;\n\t\twr32(reg, before);\n\t\treturn false;\n\t}\n\twr32(reg, before);\n\treturn true;\n}\n\nbool igc_reg_test(struct igc_adapter *adapter, u64 *data)\n{\n\tstruct igc_reg_test *test = reg_test;\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 value, before, after;\n\tu32 i, toggle, b = false;\n\n\t \n\ttoggle = 0x6800D3;\n\tbefore = rd32(IGC_STATUS);\n\tvalue = before & toggle;\n\twr32(IGC_STATUS, toggle);\n\tafter = rd32(IGC_STATUS) & toggle;\n\tif (value != after) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"failed STATUS register test got: 0x%08X expected: 0x%08X\",\n\t\t\t   after, value);\n\t\t*data = 1;\n\t\treturn false;\n\t}\n\t \n\twr32(IGC_STATUS, before);\n\n\t \n\twhile (test->reg) {\n\t\tfor (i = 0; i < test->array_len; i++) {\n\t\t\tswitch (test->test_type) {\n\t\t\tcase PATTERN_TEST:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 0x40),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase SET_READ_TEST:\n\t\t\t\tb = reg_set_and_check(adapter, data,\n\t\t\t\t\t\t      test->reg + (i * 0x40),\n\t\t\t\t\t\t      test->mask,\n\t\t\t\t\t\t      test->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_LO:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 8),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_HI:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + 4 + (i * 8),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE32_TEST:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 4),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!b)\n\t\t\t\treturn false;\n\t\t}\n\t\ttest++;\n\t}\n\t*data = 0;\n\treturn true;\n}\n\nbool igc_eeprom_test(struct igc_adapter *adapter, u64 *data)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\n\t*data = 0;\n\n\tif (hw->nvm.ops.validate(hw) != IGC_SUCCESS) {\n\t\t*data = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool igc_link_test(struct igc_adapter *adapter, u64 *data)\n{\n\tbool link_up;\n\n\t*data = 0;\n\n\t \n\tif (adapter->hw.mac.autoneg)\n\t\tssleep(5);\n\n\tlink_up = igc_has_link(adapter);\n\tif (!link_up) {\n\t\t*data = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}