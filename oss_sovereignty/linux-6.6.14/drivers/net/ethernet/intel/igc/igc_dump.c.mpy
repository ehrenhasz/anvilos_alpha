{
  "module_name": "igc_dump.c",
  "hash_id": "f54921d328474e0d7ee92512aa3281c80ab58443bad08a21221129926ebcc673",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_dump.c",
  "human_readable_source": "\n \n\n#include \"igc.h\"\n\nstruct igc_reg_info {\n\tu32 ofs;\n\tchar *name;\n};\n\nstatic const struct igc_reg_info igc_reg_info_tbl[] = {\n\t \n\t{IGC_CTRL, \"CTRL\"},\n\t{IGC_STATUS, \"STATUS\"},\n\t{IGC_CTRL_EXT, \"CTRL_EXT\"},\n\t{IGC_MDIC, \"MDIC\"},\n\n\t \n\t{IGC_ICR, \"ICR\"},\n\n\t \n\t{IGC_RCTL, \"RCTL\"},\n\t{IGC_RDLEN(0), \"RDLEN\"},\n\t{IGC_RDH(0), \"RDH\"},\n\t{IGC_RDT(0), \"RDT\"},\n\t{IGC_RXDCTL(0), \"RXDCTL\"},\n\t{IGC_RDBAL(0), \"RDBAL\"},\n\t{IGC_RDBAH(0), \"RDBAH\"},\n\n\t \n\t{IGC_TCTL, \"TCTL\"},\n\t{IGC_TDBAL(0), \"TDBAL\"},\n\t{IGC_TDBAH(0), \"TDBAH\"},\n\t{IGC_TDLEN(0), \"TDLEN\"},\n\t{IGC_TDH(0), \"TDH\"},\n\t{IGC_TDT(0), \"TDT\"},\n\t{IGC_TXDCTL(0), \"TXDCTL\"},\n\n\t \n\t{}\n};\n\n \nstatic void igc_regdump(struct igc_hw *hw, struct igc_reg_info *reginfo)\n{\n\tstruct net_device *dev = igc_get_hw_dev(hw);\n\tint n = 0;\n\tchar rname[16];\n\tu32 regs[8];\n\n\tswitch (reginfo->ofs) {\n\tcase IGC_RDLEN(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_RDLEN(n));\n\t\tbreak;\n\tcase IGC_RDH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_RDH(n));\n\t\tbreak;\n\tcase IGC_RDT(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_RDT(n));\n\t\tbreak;\n\tcase IGC_RXDCTL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_RXDCTL(n));\n\t\tbreak;\n\tcase IGC_RDBAL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_RDBAL(n));\n\t\tbreak;\n\tcase IGC_RDBAH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_RDBAH(n));\n\t\tbreak;\n\tcase IGC_TDBAL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_TDBAL(n));\n\t\tbreak;\n\tcase IGC_TDBAH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_TDBAH(n));\n\t\tbreak;\n\tcase IGC_TDLEN(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_TDLEN(n));\n\t\tbreak;\n\tcase IGC_TDH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_TDH(n));\n\t\tbreak;\n\tcase IGC_TDT(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_TDT(n));\n\t\tbreak;\n\tcase IGC_TXDCTL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(IGC_TXDCTL(n));\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(dev, \"%-15s %08x\\n\", reginfo->name,\n\t\t\t    rd32(reginfo->ofs));\n\t\treturn;\n\t}\n\n\tsnprintf(rname, 16, \"%s%s\", reginfo->name, \"[0-3]\");\n\tnetdev_info(dev, \"%-15s %08x %08x %08x %08x\\n\", rname, regs[0], regs[1],\n\t\t    regs[2], regs[3]);\n}\n\n \nvoid igc_rings_dump(struct igc_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct my_u0 { __le64 a; __le64 b; } *u0;\n\tunion igc_adv_tx_desc *tx_desc;\n\tunion igc_adv_rx_desc *rx_desc;\n\tstruct igc_ring *tx_ring;\n\tstruct igc_ring *rx_ring;\n\tu32 staterr;\n\tu16 i, n;\n\n\tif (!netif_msg_hw(adapter))\n\t\treturn;\n\n\tnetdev_info(netdev, \"Device info: state %016lX trans_start %016lX\\n\",\n\t\t    netdev->state, dev_trans_start(netdev));\n\n\t \n\tif (!netif_running(netdev))\n\t\tgoto exit;\n\n\tnetdev_info(netdev, \"TX Rings Summary\\n\");\n\tnetdev_info(netdev, \"Queue [NTU] [NTC] [bi(ntc)->dma  ] leng ntw timestamp\\n\");\n\tfor (n = 0; n < adapter->num_tx_queues; n++) {\n\t\tstruct igc_tx_buffer *buffer_info;\n\n\t\ttx_ring = adapter->tx_ring[n];\n\t\tbuffer_info = &tx_ring->tx_buffer_info[tx_ring->next_to_clean];\n\n\t\tnetdev_info(netdev, \"%5d %5X %5X %016llX %04X %p %016llX\\n\",\n\t\t\t    n, tx_ring->next_to_use, tx_ring->next_to_clean,\n\t\t\t    (u64)dma_unmap_addr(buffer_info, dma),\n\t\t\t    dma_unmap_len(buffer_info, len),\n\t\t\t    buffer_info->next_to_watch,\n\t\t\t    (u64)buffer_info->time_stamp);\n\t}\n\n\t \n\tif (!netif_msg_tx_done(adapter))\n\t\tgoto rx_ring_summary;\n\n\tnetdev_info(netdev, \"TX Rings Dump\\n\");\n\n\t \n\n\tfor (n = 0; n < adapter->num_tx_queues; n++) {\n\t\ttx_ring = adapter->tx_ring[n];\n\t\tnetdev_info(netdev, \"------------------------------------\\n\");\n\t\tnetdev_info(netdev, \"TX QUEUE INDEX = %d\\n\",\n\t\t\t    tx_ring->queue_index);\n\t\tnetdev_info(netdev, \"------------------------------------\\n\");\n\t\tnetdev_info(netdev, \"T [desc]     [address 63:0  ] [PlPOCIStDDM Ln] [bi->dma       ] leng  ntw timestamp        bi->skb\\n\");\n\n\t\tfor (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {\n\t\t\tconst char *next_desc;\n\t\t\tstruct igc_tx_buffer *buffer_info;\n\n\t\t\ttx_desc = IGC_TX_DESC(tx_ring, i);\n\t\t\tbuffer_info = &tx_ring->tx_buffer_info[i];\n\t\t\tu0 = (struct my_u0 *)tx_desc;\n\t\t\tif (i == tx_ring->next_to_use &&\n\t\t\t    i == tx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC/U\";\n\t\t\telse if (i == tx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == tx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tnetdev_info(netdev, \"T [0x%03X]    %016llX %016llX %016llX %04X  %p %016llX %p%s\\n\",\n\t\t\t\t    i, le64_to_cpu(u0->a),\n\t\t\t\t    le64_to_cpu(u0->b),\n\t\t\t\t    (u64)dma_unmap_addr(buffer_info, dma),\n\t\t\t\t    dma_unmap_len(buffer_info, len),\n\t\t\t\t    buffer_info->next_to_watch,\n\t\t\t\t    (u64)buffer_info->time_stamp,\n\t\t\t\t    buffer_info->skb, next_desc);\n\n\t\t\tif (netif_msg_pktdata(adapter) && buffer_info->skb)\n\t\t\t\tprint_hex_dump(KERN_INFO, \"\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS,\n\t\t\t\t\t       16, 1, buffer_info->skb->data,\n\t\t\t\t\t       dma_unmap_len(buffer_info, len),\n\t\t\t\t\t       true);\n\t\t}\n\t}\n\n\t \nrx_ring_summary:\n\tnetdev_info(netdev, \"RX Rings Summary\\n\");\n\tnetdev_info(netdev, \"Queue [NTU] [NTC]\\n\");\n\tfor (n = 0; n < adapter->num_rx_queues; n++) {\n\t\trx_ring = adapter->rx_ring[n];\n\t\tnetdev_info(netdev, \"%5d %5X %5X\\n\", n, rx_ring->next_to_use,\n\t\t\t    rx_ring->next_to_clean);\n\t}\n\n\t \n\tif (!netif_msg_rx_status(adapter))\n\t\tgoto exit;\n\n\tnetdev_info(netdev, \"RX Rings Dump\\n\");\n\n\t \n\n\tfor (n = 0; n < adapter->num_rx_queues; n++) {\n\t\trx_ring = adapter->rx_ring[n];\n\t\tnetdev_info(netdev, \"------------------------------------\\n\");\n\t\tnetdev_info(netdev, \"RX QUEUE INDEX = %d\\n\",\n\t\t\t    rx_ring->queue_index);\n\t\tnetdev_info(netdev, \"------------------------------------\\n\");\n\t\tnetdev_info(netdev, \"R  [desc]      [ PktBuf     A0] [  HeadBuf   DD] [bi->dma       ] [bi->skb] <-- Adv Rx Read format\\n\");\n\t\tnetdev_info(netdev, \"RWB[desc]      [PcsmIpSHl PtRs] [vl er S cks ln] ---------------- [bi->skb] <-- Adv Rx Write-Back format\\n\");\n\n\t\tfor (i = 0; i < rx_ring->count; i++) {\n\t\t\tconst char *next_desc;\n\t\t\tstruct igc_rx_buffer *buffer_info;\n\n\t\t\tbuffer_info = &rx_ring->rx_buffer_info[i];\n\t\t\trx_desc = IGC_RX_DESC(rx_ring, i);\n\t\t\tu0 = (struct my_u0 *)rx_desc;\n\t\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\n\t\t\tif (i == rx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == rx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tif (staterr & IGC_RXD_STAT_DD) {\n\t\t\t\t \n\t\t\t\tnetdev_info(netdev, \"%s[0x%03X]     %016llX %016llX ---------------- %s\\n\",\n\t\t\t\t\t    \"RWB\", i,\n\t\t\t\t\t    le64_to_cpu(u0->a),\n\t\t\t\t\t    le64_to_cpu(u0->b),\n\t\t\t\t\t    next_desc);\n\t\t\t} else {\n\t\t\t\tnetdev_info(netdev, \"%s[0x%03X]     %016llX %016llX %016llX %s\\n\",\n\t\t\t\t\t    \"R  \", i,\n\t\t\t\t\t    le64_to_cpu(u0->a),\n\t\t\t\t\t    le64_to_cpu(u0->b),\n\t\t\t\t\t    (u64)buffer_info->dma,\n\t\t\t\t\t    next_desc);\n\n\t\t\t\tif (netif_msg_pktdata(adapter) &&\n\t\t\t\t    buffer_info->dma && buffer_info->page) {\n\t\t\t\t\tprint_hex_dump(KERN_INFO, \"\",\n\t\t\t\t\t\t       DUMP_PREFIX_ADDRESS,\n\t\t\t\t\t\t       16, 1,\n\t\t\t\t\t\t       page_address\n\t\t\t\t\t\t       (buffer_info->page) +\n\t\t\t\t\t\t       buffer_info->page_offset,\n\t\t\t\t\t\t       igc_rx_bufsz(rx_ring),\n\t\t\t\t\t\t       true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\treturn;\n}\n\n \nvoid igc_regs_dump(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tstruct igc_reg_info *reginfo;\n\n\t \n\tnetdev_info(adapter->netdev, \"Register Dump\\n\");\n\tnetdev_info(adapter->netdev, \"Register Name   Value\\n\");\n\tfor (reginfo = (struct igc_reg_info *)igc_reg_info_tbl;\n\t     reginfo->name; reginfo++) {\n\t\tigc_regdump(hw, reginfo);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}