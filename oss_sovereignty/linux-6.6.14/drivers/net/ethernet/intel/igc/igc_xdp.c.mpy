{
  "module_name": "igc_xdp.c",
  "hash_id": "1bc4082661369b45f9d19ea02204fe79ff5192f59d912ae7cdc37dcc7ce3bfbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_xdp.c",
  "human_readable_source": "\n \n\n#include <linux/if_vlan.h>\n#include <net/xdp_sock_drv.h>\n\n#include \"igc.h\"\n#include \"igc_xdp.h\"\n\nint igc_xdp_set_prog(struct igc_adapter *adapter, struct bpf_prog *prog,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = adapter->netdev;\n\tbool if_running = netif_running(dev);\n\tstruct bpf_prog *old_prog;\n\n\tif (dev->mtu > ETH_DATA_LEN) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"Jumbo frames not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (if_running)\n\t\tigc_close(dev);\n\n\told_prog = xchg(&adapter->xdp_prog, prog);\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\tif (prog)\n\t\txdp_features_set_redirect_target(dev, true);\n\telse\n\t\txdp_features_clear_redirect_target(dev);\n\n\tif (if_running)\n\t\tigc_open(dev);\n\n\treturn 0;\n}\n\nstatic int igc_xdp_enable_pool(struct igc_adapter *adapter,\n\t\t\t       struct xsk_buff_pool *pool, u16 queue_id)\n{\n\tstruct net_device *ndev = adapter->netdev;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct igc_ring *rx_ring, *tx_ring;\n\tstruct napi_struct *napi;\n\tbool needs_reset;\n\tu32 frame_size;\n\tint err;\n\n\tif (queue_id >= adapter->num_rx_queues ||\n\t    queue_id >= adapter->num_tx_queues)\n\t\treturn -EINVAL;\n\n\tframe_size = xsk_pool_get_rx_frame_size(pool);\n\tif (frame_size < ETH_FRAME_LEN + VLAN_HLEN * 2) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = xsk_pool_dma_map(pool, dev, IGC_RX_DMA_ATTR);\n\tif (err) {\n\t\tnetdev_err(ndev, \"Failed to map xsk pool\\n\");\n\t\treturn err;\n\t}\n\n\tneeds_reset = netif_running(adapter->netdev) && igc_xdp_is_enabled(adapter);\n\n\trx_ring = adapter->rx_ring[queue_id];\n\ttx_ring = adapter->tx_ring[queue_id];\n\t \n\tnapi = &rx_ring->q_vector->napi;\n\n\tif (needs_reset) {\n\t\tigc_disable_rx_ring(rx_ring);\n\t\tigc_disable_tx_ring(tx_ring);\n\t\tnapi_disable(napi);\n\t}\n\n\tset_bit(IGC_RING_FLAG_AF_XDP_ZC, &rx_ring->flags);\n\tset_bit(IGC_RING_FLAG_AF_XDP_ZC, &tx_ring->flags);\n\n\tif (needs_reset) {\n\t\tnapi_enable(napi);\n\t\tigc_enable_rx_ring(rx_ring);\n\t\tigc_enable_tx_ring(tx_ring);\n\n\t\terr = igc_xsk_wakeup(ndev, queue_id, XDP_WAKEUP_RX);\n\t\tif (err) {\n\t\t\txsk_pool_dma_unmap(pool, IGC_RX_DMA_ATTR);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int igc_xdp_disable_pool(struct igc_adapter *adapter, u16 queue_id)\n{\n\tstruct igc_ring *rx_ring, *tx_ring;\n\tstruct xsk_buff_pool *pool;\n\tstruct napi_struct *napi;\n\tbool needs_reset;\n\n\tif (queue_id >= adapter->num_rx_queues ||\n\t    queue_id >= adapter->num_tx_queues)\n\t\treturn -EINVAL;\n\n\tpool = xsk_get_pool_from_qid(adapter->netdev, queue_id);\n\tif (!pool)\n\t\treturn -EINVAL;\n\n\tneeds_reset = netif_running(adapter->netdev) && igc_xdp_is_enabled(adapter);\n\n\trx_ring = adapter->rx_ring[queue_id];\n\ttx_ring = adapter->tx_ring[queue_id];\n\t \n\tnapi = &rx_ring->q_vector->napi;\n\n\tif (needs_reset) {\n\t\tigc_disable_rx_ring(rx_ring);\n\t\tigc_disable_tx_ring(tx_ring);\n\t\tnapi_disable(napi);\n\t}\n\n\txsk_pool_dma_unmap(pool, IGC_RX_DMA_ATTR);\n\tclear_bit(IGC_RING_FLAG_AF_XDP_ZC, &rx_ring->flags);\n\tclear_bit(IGC_RING_FLAG_AF_XDP_ZC, &tx_ring->flags);\n\n\tif (needs_reset) {\n\t\tnapi_enable(napi);\n\t\tigc_enable_rx_ring(rx_ring);\n\t\tigc_enable_tx_ring(tx_ring);\n\t}\n\n\treturn 0;\n}\n\nint igc_xdp_setup_pool(struct igc_adapter *adapter, struct xsk_buff_pool *pool,\n\t\t       u16 queue_id)\n{\n\treturn pool ? igc_xdp_enable_pool(adapter, pool, queue_id) :\n\t\t      igc_xdp_disable_pool(adapter, queue_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}