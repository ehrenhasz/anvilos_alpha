{
  "module_name": "igc_ptp.c",
  "hash_id": "40710778b3061b566d0134f68a8c6b0b758e323cd6ebf158b5383ccbe00cc33c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_ptp.c",
  "human_readable_source": "\n \n\n#include \"igc.h\"\n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/ptp_classify.h>\n#include <linux/clocksource.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n\n#define INCVALUE_MASK\t\t0x7fffffff\n#define ISGN\t\t\t0x80000000\n\n#define IGC_PTP_TX_TIMEOUT\t\t(HZ * 15)\n\n#define IGC_PTM_STAT_SLEEP\t\t2\n#define IGC_PTM_STAT_TIMEOUT\t\t100\n\n \nvoid igc_ptp_read(struct igc_adapter *adapter, struct timespec64 *ts)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 sec, nsec;\n\n\t \n\tnsec = rd32(IGC_SYSTIML);\n\tsec = rd32(IGC_SYSTIMH);\n\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}\n\nstatic void igc_ptp_write_i225(struct igc_adapter *adapter,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\n\twr32(IGC_SYSTIML, ts->tv_nsec);\n\twr32(IGC_SYSTIMH, ts->tv_sec);\n}\n\nstatic int igc_ptp_adjfine_i225(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct igc_adapter *igc = container_of(ptp, struct igc_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct igc_hw *hw = &igc->hw;\n\tint neg_adj = 0;\n\tu64 rate;\n\tu32 inca;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\trate = scaled_ppm;\n\trate <<= 14;\n\trate = div_u64(rate, 78125);\n\n\tinca = rate & INCVALUE_MASK;\n\tif (neg_adj)\n\t\tinca |= ISGN;\n\n\twr32(IGC_TIMINCA, inca);\n\n\treturn 0;\n}\n\nstatic int igc_ptp_adjtime_i225(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct igc_adapter *igc = container_of(ptp, struct igc_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct timespec64 now, then = ns_to_timespec64(delta);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&igc->tmreg_lock, flags);\n\n\tigc_ptp_read(igc, &now);\n\tnow = timespec64_add(now, then);\n\tigc_ptp_write_i225(igc, (const struct timespec64 *)&now);\n\n\tspin_unlock_irqrestore(&igc->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int igc_ptp_gettimex64_i225(struct ptp_clock_info *ptp,\n\t\t\t\t   struct timespec64 *ts,\n\t\t\t\t   struct ptp_system_timestamp *sts)\n{\n\tstruct igc_adapter *igc = container_of(ptp, struct igc_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct igc_hw *hw = &igc->hw;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&igc->tmreg_lock, flags);\n\n\tptp_read_system_prets(sts);\n\tts->tv_nsec = rd32(IGC_SYSTIML);\n\tts->tv_sec = rd32(IGC_SYSTIMH);\n\tptp_read_system_postts(sts);\n\n\tspin_unlock_irqrestore(&igc->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int igc_ptp_settime_i225(struct ptp_clock_info *ptp,\n\t\t\t\tconst struct timespec64 *ts)\n{\n\tstruct igc_adapter *igc = container_of(ptp, struct igc_adapter,\n\t\t\t\t\t       ptp_caps);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&igc->tmreg_lock, flags);\n\n\tigc_ptp_write_i225(igc, ts);\n\n\tspin_unlock_irqrestore(&igc->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic void igc_pin_direction(int pin, int input, u32 *ctrl, u32 *ctrl_ext)\n{\n\tu32 *ptr = pin < 2 ? ctrl : ctrl_ext;\n\tstatic const u32 mask[IGC_N_SDP] = {\n\t\tIGC_CTRL_SDP0_DIR,\n\t\tIGC_CTRL_SDP1_DIR,\n\t\tIGC_CTRL_EXT_SDP2_DIR,\n\t\tIGC_CTRL_EXT_SDP3_DIR,\n\t};\n\n\tif (input)\n\t\t*ptr &= ~mask[pin];\n\telse\n\t\t*ptr |= mask[pin];\n}\n\nstatic void igc_pin_perout(struct igc_adapter *igc, int chan, int pin, int freq)\n{\n\tstatic const u32 igc_aux0_sel_sdp[IGC_N_SDP] = {\n\t\tIGC_AUX0_SEL_SDP0, IGC_AUX0_SEL_SDP1, IGC_AUX0_SEL_SDP2, IGC_AUX0_SEL_SDP3,\n\t};\n\tstatic const u32 igc_aux1_sel_sdp[IGC_N_SDP] = {\n\t\tIGC_AUX1_SEL_SDP0, IGC_AUX1_SEL_SDP1, IGC_AUX1_SEL_SDP2, IGC_AUX1_SEL_SDP3,\n\t};\n\tstatic const u32 igc_ts_sdp_en[IGC_N_SDP] = {\n\t\tIGC_TS_SDP0_EN, IGC_TS_SDP1_EN, IGC_TS_SDP2_EN, IGC_TS_SDP3_EN,\n\t};\n\tstatic const u32 igc_ts_sdp_sel_tt0[IGC_N_SDP] = {\n\t\tIGC_TS_SDP0_SEL_TT0, IGC_TS_SDP1_SEL_TT0,\n\t\tIGC_TS_SDP2_SEL_TT0, IGC_TS_SDP3_SEL_TT0,\n\t};\n\tstatic const u32 igc_ts_sdp_sel_tt1[IGC_N_SDP] = {\n\t\tIGC_TS_SDP0_SEL_TT1, IGC_TS_SDP1_SEL_TT1,\n\t\tIGC_TS_SDP2_SEL_TT1, IGC_TS_SDP3_SEL_TT1,\n\t};\n\tstatic const u32 igc_ts_sdp_sel_fc0[IGC_N_SDP] = {\n\t\tIGC_TS_SDP0_SEL_FC0, IGC_TS_SDP1_SEL_FC0,\n\t\tIGC_TS_SDP2_SEL_FC0, IGC_TS_SDP3_SEL_FC0,\n\t};\n\tstatic const u32 igc_ts_sdp_sel_fc1[IGC_N_SDP] = {\n\t\tIGC_TS_SDP0_SEL_FC1, IGC_TS_SDP1_SEL_FC1,\n\t\tIGC_TS_SDP2_SEL_FC1, IGC_TS_SDP3_SEL_FC1,\n\t};\n\tstatic const u32 igc_ts_sdp_sel_clr[IGC_N_SDP] = {\n\t\tIGC_TS_SDP0_SEL_FC1, IGC_TS_SDP1_SEL_FC1,\n\t\tIGC_TS_SDP2_SEL_FC1, IGC_TS_SDP3_SEL_FC1,\n\t};\n\tstruct igc_hw *hw = &igc->hw;\n\tu32 ctrl, ctrl_ext, tssdp = 0;\n\n\tctrl = rd32(IGC_CTRL);\n\tctrl_ext = rd32(IGC_CTRL_EXT);\n\ttssdp = rd32(IGC_TSSDP);\n\n\tigc_pin_direction(pin, 0, &ctrl, &ctrl_ext);\n\n\t \n\tif ((tssdp & IGC_AUX0_SEL_SDP3) == igc_aux0_sel_sdp[pin])\n\t\ttssdp &= ~IGC_AUX0_TS_SDP_EN;\n\n\tif ((tssdp & IGC_AUX1_SEL_SDP3) == igc_aux1_sel_sdp[pin])\n\t\ttssdp &= ~IGC_AUX1_TS_SDP_EN;\n\n\ttssdp &= ~igc_ts_sdp_sel_clr[pin];\n\tif (freq) {\n\t\tif (chan == 1)\n\t\t\ttssdp |= igc_ts_sdp_sel_fc1[pin];\n\t\telse\n\t\t\ttssdp |= igc_ts_sdp_sel_fc0[pin];\n\t} else {\n\t\tif (chan == 1)\n\t\t\ttssdp |= igc_ts_sdp_sel_tt1[pin];\n\t\telse\n\t\t\ttssdp |= igc_ts_sdp_sel_tt0[pin];\n\t}\n\ttssdp |= igc_ts_sdp_en[pin];\n\n\twr32(IGC_TSSDP, tssdp);\n\twr32(IGC_CTRL, ctrl);\n\twr32(IGC_CTRL_EXT, ctrl_ext);\n}\n\nstatic void igc_pin_extts(struct igc_adapter *igc, int chan, int pin)\n{\n\tstatic const u32 igc_aux0_sel_sdp[IGC_N_SDP] = {\n\t\tIGC_AUX0_SEL_SDP0, IGC_AUX0_SEL_SDP1, IGC_AUX0_SEL_SDP2, IGC_AUX0_SEL_SDP3,\n\t};\n\tstatic const u32 igc_aux1_sel_sdp[IGC_N_SDP] = {\n\t\tIGC_AUX1_SEL_SDP0, IGC_AUX1_SEL_SDP1, IGC_AUX1_SEL_SDP2, IGC_AUX1_SEL_SDP3,\n\t};\n\tstatic const u32 igc_ts_sdp_en[IGC_N_SDP] = {\n\t\tIGC_TS_SDP0_EN, IGC_TS_SDP1_EN, IGC_TS_SDP2_EN, IGC_TS_SDP3_EN,\n\t};\n\tstruct igc_hw *hw = &igc->hw;\n\tu32 ctrl, ctrl_ext, tssdp = 0;\n\n\tctrl = rd32(IGC_CTRL);\n\tctrl_ext = rd32(IGC_CTRL_EXT);\n\ttssdp = rd32(IGC_TSSDP);\n\n\tigc_pin_direction(pin, 1, &ctrl, &ctrl_ext);\n\n\t \n\ttssdp &= ~igc_ts_sdp_en[pin];\n\n\tif (chan == 1) {\n\t\ttssdp &= ~IGC_AUX1_SEL_SDP3;\n\t\ttssdp |= igc_aux1_sel_sdp[pin] | IGC_AUX1_TS_SDP_EN;\n\t} else {\n\t\ttssdp &= ~IGC_AUX0_SEL_SDP3;\n\t\ttssdp |= igc_aux0_sel_sdp[pin] | IGC_AUX0_TS_SDP_EN;\n\t}\n\n\twr32(IGC_TSSDP, tssdp);\n\twr32(IGC_CTRL, ctrl);\n\twr32(IGC_CTRL_EXT, ctrl_ext);\n}\n\nstatic int igc_ptp_feature_enable_i225(struct ptp_clock_info *ptp,\n\t\t\t\t       struct ptp_clock_request *rq, int on)\n{\n\tstruct igc_adapter *igc =\n\t\tcontainer_of(ptp, struct igc_adapter, ptp_caps);\n\tstruct igc_hw *hw = &igc->hw;\n\tunsigned long flags;\n\tstruct timespec64 ts;\n\tint use_freq = 0, pin = -1;\n\tu32 tsim, tsauxc, tsauxc_mask, tsim_mask, trgttiml, trgttimh, freqout;\n\ts64 ns;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\t \n\t\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\t\tPTP_STRICT_FLAGS))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif ((rq->extts.flags & PTP_STRICT_FLAGS) &&\n\t\t    (rq->extts.flags & PTP_ENABLE_FEATURE) &&\n\t\t    (rq->extts.flags & PTP_EXTTS_EDGES) != PTP_EXTTS_EDGES)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (on) {\n\t\t\tpin = ptp_find_pin(igc->ptp_clock, PTP_PF_EXTTS,\n\t\t\t\t\t   rq->extts.index);\n\t\t\tif (pin < 0)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (rq->extts.index == 1) {\n\t\t\ttsauxc_mask = IGC_TSAUXC_EN_TS1;\n\t\t\ttsim_mask = IGC_TSICR_AUTT1;\n\t\t} else {\n\t\t\ttsauxc_mask = IGC_TSAUXC_EN_TS0;\n\t\t\ttsim_mask = IGC_TSICR_AUTT0;\n\t\t}\n\t\tspin_lock_irqsave(&igc->tmreg_lock, flags);\n\t\ttsauxc = rd32(IGC_TSAUXC);\n\t\ttsim = rd32(IGC_TSIM);\n\t\tif (on) {\n\t\t\tigc_pin_extts(igc, rq->extts.index, pin);\n\t\t\ttsauxc |= tsauxc_mask;\n\t\t\ttsim |= tsim_mask;\n\t\t} else {\n\t\t\ttsauxc &= ~tsauxc_mask;\n\t\t\ttsim &= ~tsim_mask;\n\t\t}\n\t\twr32(IGC_TSAUXC, tsauxc);\n\t\twr32(IGC_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igc->tmreg_lock, flags);\n\t\treturn 0;\n\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t \n\t\tif (rq->perout.flags)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (on) {\n\t\t\tpin = ptp_find_pin(igc->ptp_clock, PTP_PF_PEROUT,\n\t\t\t\t\t   rq->perout.index);\n\t\t\tif (pin < 0)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tts.tv_sec = rq->perout.period.sec;\n\t\tts.tv_nsec = rq->perout.period.nsec;\n\t\tns = timespec64_to_ns(&ts);\n\t\tns = ns >> 1;\n\t\tif (on && (ns <= 70000000LL || ns == 125000000LL ||\n\t\t\t   ns == 250000000LL || ns == 500000000LL)) {\n\t\t\tif (ns < 8LL)\n\t\t\t\treturn -EINVAL;\n\t\t\tuse_freq = 1;\n\t\t}\n\t\tts = ns_to_timespec64(ns);\n\t\tif (rq->perout.index == 1) {\n\t\t\tif (use_freq) {\n\t\t\t\ttsauxc_mask = IGC_TSAUXC_EN_CLK1 | IGC_TSAUXC_ST1;\n\t\t\t\ttsim_mask = 0;\n\t\t\t} else {\n\t\t\t\ttsauxc_mask = IGC_TSAUXC_EN_TT1;\n\t\t\t\ttsim_mask = IGC_TSICR_TT1;\n\t\t\t}\n\t\t\ttrgttiml = IGC_TRGTTIML1;\n\t\t\ttrgttimh = IGC_TRGTTIMH1;\n\t\t\tfreqout = IGC_FREQOUT1;\n\t\t} else {\n\t\t\tif (use_freq) {\n\t\t\t\ttsauxc_mask = IGC_TSAUXC_EN_CLK0 | IGC_TSAUXC_ST0;\n\t\t\t\ttsim_mask = 0;\n\t\t\t} else {\n\t\t\t\ttsauxc_mask = IGC_TSAUXC_EN_TT0;\n\t\t\t\ttsim_mask = IGC_TSICR_TT0;\n\t\t\t}\n\t\t\ttrgttiml = IGC_TRGTTIML0;\n\t\t\ttrgttimh = IGC_TRGTTIMH0;\n\t\t\tfreqout = IGC_FREQOUT0;\n\t\t}\n\t\tspin_lock_irqsave(&igc->tmreg_lock, flags);\n\t\ttsauxc = rd32(IGC_TSAUXC);\n\t\ttsim = rd32(IGC_TSIM);\n\t\tif (rq->perout.index == 1) {\n\t\t\ttsauxc &= ~(IGC_TSAUXC_EN_TT1 | IGC_TSAUXC_EN_CLK1 |\n\t\t\t\t    IGC_TSAUXC_ST1);\n\t\t\ttsim &= ~IGC_TSICR_TT1;\n\t\t} else {\n\t\t\ttsauxc &= ~(IGC_TSAUXC_EN_TT0 | IGC_TSAUXC_EN_CLK0 |\n\t\t\t\t    IGC_TSAUXC_ST0);\n\t\t\ttsim &= ~IGC_TSICR_TT0;\n\t\t}\n\t\tif (on) {\n\t\t\tstruct timespec64 safe_start;\n\t\t\tint i = rq->perout.index;\n\n\t\t\tigc_pin_perout(igc, i, pin, use_freq);\n\t\t\tigc_ptp_read(igc, &safe_start);\n\n\t\t\t \n\t\t\tsafe_start.tv_sec += 2;\n\n\t\t\tif (rq->perout.start.sec < safe_start.tv_sec)\n\t\t\t\tigc->perout[i].start.tv_sec = safe_start.tv_sec;\n\t\t\telse\n\t\t\t\tigc->perout[i].start.tv_sec = rq->perout.start.sec;\n\t\t\tigc->perout[i].start.tv_nsec = rq->perout.start.nsec;\n\t\t\tigc->perout[i].period.tv_sec = ts.tv_sec;\n\t\t\tigc->perout[i].period.tv_nsec = ts.tv_nsec;\n\t\t\twr32(trgttimh, (u32)igc->perout[i].start.tv_sec);\n\t\t\t \n\t\t\twr32(trgttiml, (u32)(igc->perout[i].start.tv_nsec |\n\t\t\t\t\t     IGC_TT_IO_TIMER_SEL_SYSTIM0));\n\t\t\tif (use_freq)\n\t\t\t\twr32(freqout, ns);\n\t\t\ttsauxc |= tsauxc_mask;\n\t\t\ttsim |= tsim_mask;\n\t\t}\n\t\twr32(IGC_TSAUXC, tsauxc);\n\t\twr32(IGC_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igc->tmreg_lock, flags);\n\t\treturn 0;\n\n\tcase PTP_CLK_REQ_PPS:\n\t\tspin_lock_irqsave(&igc->tmreg_lock, flags);\n\t\ttsim = rd32(IGC_TSIM);\n\t\tif (on)\n\t\t\ttsim |= IGC_TSICR_SYS_WRAP;\n\t\telse\n\t\t\ttsim &= ~IGC_TSICR_SYS_WRAP;\n\t\tigc->pps_sys_wrap_on = on;\n\t\twr32(IGC_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igc->tmreg_lock, flags);\n\t\treturn 0;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int igc_ptp_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t      enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int igc_ptp_systim_to_hwtstamp(struct igc_adapter *adapter,\n\t\t\t\t      struct skb_shared_hwtstamps *hwtstamps,\n\t\t\t\t      u64 systim)\n{\n\tswitch (adapter->hw.mac.type) {\n\tcase igc_i225:\n\t\tmemset(hwtstamps, 0, sizeof(*hwtstamps));\n\t\t \n\t\thwtstamps->hwtstamp = ktime_set(systim >> 32,\n\t\t\t\t\t\tsystim & 0xFFFFFFFF);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nktime_t igc_ptp_rx_pktstamp(struct igc_adapter *adapter, __le32 *buf)\n{\n\tktime_t timestamp;\n\tu32 secs, nsecs;\n\tint adjust;\n\n\t \n\tnsecs = le32_to_cpu(buf[2]);\n\tsecs = le32_to_cpu(buf[3]);\n\n\ttimestamp = ktime_set(secs, nsecs);\n\n\t \n\tswitch (adapter->link_speed) {\n\tcase SPEED_10:\n\t\tadjust = IGC_I225_RX_LATENCY_10;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tadjust = IGC_I225_RX_LATENCY_100;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tadjust = IGC_I225_RX_LATENCY_1000;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tadjust = IGC_I225_RX_LATENCY_2500;\n\t\tbreak;\n\tdefault:\n\t\tadjust = 0;\n\t\tnetdev_warn_once(adapter->netdev, \"Imprecise timestamp\\n\");\n\t\tbreak;\n\t}\n\n\treturn ktime_sub_ns(timestamp, adjust);\n}\n\nstatic void igc_ptp_disable_rx_timestamp(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 val;\n\tint i;\n\n\twr32(IGC_TSYNCRXCTL, 0);\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tval = rd32(IGC_SRRCTL(i));\n\t\tval &= ~IGC_SRRCTL_TIMESTAMP;\n\t\twr32(IGC_SRRCTL(i), val);\n\t}\n\n\tval = rd32(IGC_RXPBS);\n\tval &= ~IGC_RXPBS_CFG_TS_EN;\n\twr32(IGC_RXPBS, val);\n}\n\nstatic void igc_ptp_enable_rx_timestamp(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 val;\n\tint i;\n\n\tval = rd32(IGC_RXPBS);\n\tval |= IGC_RXPBS_CFG_TS_EN;\n\twr32(IGC_RXPBS, val);\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tval = rd32(IGC_SRRCTL(i));\n\t\t \n\t\tval |= IGC_SRRCTL_TIMER1SEL(0) | IGC_SRRCTL_TIMER0SEL(0) |\n\t\t       IGC_SRRCTL_TIMESTAMP;\n\t\twr32(IGC_SRRCTL(i), val);\n\t}\n\n\tval = IGC_TSYNCRXCTL_ENABLED | IGC_TSYNCRXCTL_TYPE_ALL |\n\t      IGC_TSYNCRXCTL_RXSYNSIG;\n\twr32(IGC_TSYNCRXCTL, val);\n}\n\nstatic void igc_ptp_clear_tx_tstamp(struct igc_adapter *adapter)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&adapter->ptp_tx_lock, flags);\n\n\tfor (i = 0; i < IGC_MAX_TX_TSTAMP_REGS; i++) {\n\t\tstruct igc_tx_timestamp_request *tstamp = &adapter->tx_tstamp[i];\n\n\t\tdev_kfree_skb_any(tstamp->skb);\n\t\ttstamp->skb = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&adapter->ptp_tx_lock, flags);\n}\n\nstatic void igc_ptp_disable_tx_timestamp(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tint i;\n\n\t \n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct igc_ring *tx_ring = adapter->tx_ring[i];\n\n\t\tclear_bit(IGC_RING_FLAG_TX_HWTSTAMP, &tx_ring->flags);\n\t}\n\n\t \n\tigc_ptp_clear_tx_tstamp(adapter);\n\n\twr32(IGC_TSYNCTXCTL, 0);\n}\n\nstatic void igc_ptp_enable_tx_timestamp(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tint i;\n\n\twr32(IGC_TSYNCTXCTL, IGC_TSYNCTXCTL_ENABLED | IGC_TSYNCTXCTL_TXSYNSIG);\n\n\t \n\trd32(IGC_TXSTMPL);\n\trd32(IGC_TXSTMPH);\n\n\t \n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct igc_ring *tx_ring = adapter->tx_ring[i];\n\n\t\tset_bit(IGC_RING_FLAG_TX_HWTSTAMP, &tx_ring->flags);\n\t}\n\n}\n\n \nstatic int igc_ptp_set_timestamp_mode(struct igc_adapter *adapter,\n\t\t\t\t      struct hwtstamp_config *config)\n{\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tigc_ptp_disable_tx_timestamp(adapter);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tigc_ptp_enable_tx_timestamp(adapter);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tigc_ptp_disable_rx_timestamp(adapter);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\tcase HWTSTAMP_FILTER_ALL:\n\t\tigc_ptp_enable_rx_timestamp(adapter);\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void igc_ptp_tx_timeout(struct igc_adapter *adapter,\n\t\t\t       struct igc_tx_timestamp_request *tstamp)\n{\n\tdev_kfree_skb_any(tstamp->skb);\n\ttstamp->skb = NULL;\n\tadapter->tx_hwtstamp_timeouts++;\n\n\tnetdev_warn(adapter->netdev, \"Tx timestamp timeout\\n\");\n}\n\nvoid igc_ptp_tx_hang(struct igc_adapter *adapter)\n{\n\tstruct igc_tx_timestamp_request *tstamp;\n\tstruct igc_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tbool found = false;\n\tint i;\n\n\tspin_lock_irqsave(&adapter->ptp_tx_lock, flags);\n\n\tfor (i = 0; i < IGC_MAX_TX_TSTAMP_REGS; i++) {\n\t\ttstamp = &adapter->tx_tstamp[i];\n\n\t\tif (!tstamp->skb)\n\t\t\tcontinue;\n\n\t\tif (time_is_after_jiffies(tstamp->start + IGC_PTP_TX_TIMEOUT))\n\t\t\tcontinue;\n\n\t\tigc_ptp_tx_timeout(adapter, tstamp);\n\t\tfound = true;\n\t}\n\n\tif (found) {\n\t\t \n\t\trd32(IGC_TXSTMPH_0);\n\t}\n\n\tspin_unlock_irqrestore(&adapter->ptp_tx_lock, flags);\n}\n\nstatic void igc_ptp_tx_reg_to_stamp(struct igc_adapter *adapter,\n\t\t\t\t    struct igc_tx_timestamp_request *tstamp, u64 regval)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct sk_buff *skb;\n\tint adjust = 0;\n\n\tskb = tstamp->skb;\n\tif (!skb)\n\t\treturn;\n\n\tif (igc_ptp_systim_to_hwtstamp(adapter, &shhwtstamps, regval))\n\t\treturn;\n\n\tswitch (adapter->link_speed) {\n\tcase SPEED_10:\n\t\tadjust = IGC_I225_TX_LATENCY_10;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tadjust = IGC_I225_TX_LATENCY_100;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tadjust = IGC_I225_TX_LATENCY_1000;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tadjust = IGC_I225_TX_LATENCY_2500;\n\t\tbreak;\n\t}\n\n\tshhwtstamps.hwtstamp =\n\t\tktime_add_ns(shhwtstamps.hwtstamp, adjust);\n\n\ttstamp->skb = NULL;\n\n\tskb_tstamp_tx(skb, &shhwtstamps);\n\tdev_kfree_skb_any(skb);\n}\n\n \nstatic void igc_ptp_tx_hwtstamp(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu64 regval;\n\tu32 mask;\n\tint i;\n\n\tmask = rd32(IGC_TSYNCTXCTL) & IGC_TSYNCTXCTL_TXTT_ANY;\n\tif (mask & IGC_TSYNCTXCTL_TXTT_0) {\n\t\tregval = rd32(IGC_TXSTMPL);\n\t\tregval |= (u64)rd32(IGC_TXSTMPH) << 32;\n\t} else {\n\t\t \n\t\tu32 txstmpl_old, txstmpl_new;\n\n\t\ttxstmpl_old = rd32(IGC_TXSTMPL);\n\t\trd32(IGC_TXSTMPH);\n\t\ttxstmpl_new = rd32(IGC_TXSTMPL);\n\n\t\tif (txstmpl_old == txstmpl_new)\n\t\t\tgoto done;\n\n\t\tregval = txstmpl_new;\n\t\tregval |= (u64)rd32(IGC_TXSTMPH) << 32;\n\t}\n\n\tigc_ptp_tx_reg_to_stamp(adapter, &adapter->tx_tstamp[0], regval);\n\ndone:\n\t \n\tfor (i = 1; i < IGC_MAX_TX_TSTAMP_REGS; i++) {\n\t\tstruct igc_tx_timestamp_request *tstamp = &adapter->tx_tstamp[i];\n\n\t\tif (!(tstamp->mask & mask))\n\t\t\tcontinue;\n\n\t\tregval = rd32(tstamp->regl);\n\t\tregval |= (u64)rd32(tstamp->regh) << 32;\n\n\t\tigc_ptp_tx_reg_to_stamp(adapter, tstamp, regval);\n\t}\n}\n\n \nvoid igc_ptp_tx_tstamp_event(struct igc_adapter *adapter)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->ptp_tx_lock, flags);\n\n\tigc_ptp_tx_hwtstamp(adapter);\n\n\tspin_unlock_irqrestore(&adapter->ptp_tx_lock, flags);\n}\n\n \nint igc_ptp_set_ts_config(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = igc_ptp_set_timestamp_mode(adapter, &config);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmemcpy(&adapter->tstamp_config, &config,\n\t       sizeof(adapter->tstamp_config));\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nint igc_ptp_get_ts_config(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct igc_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config *config = &adapter->tstamp_config;\n\n\treturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nstatic bool igc_is_crosststamp_supported(struct igc_adapter *adapter)\n{\n\tif (!IS_ENABLED(CONFIG_X86_TSC))\n\t\treturn false;\n\n\t \n\tif (adapter->pdev->device == IGC_DEV_ID_I225_V)\n\t\treturn false;\n\n\treturn pcie_ptm_enabled(adapter->pdev);\n}\n\nstatic struct system_counterval_t igc_device_tstamp_to_system(u64 tstamp)\n{\n#if IS_ENABLED(CONFIG_X86_TSC) && !defined(CONFIG_UML)\n\treturn convert_art_ns_to_tsc(tstamp);\n#else\n\treturn (struct system_counterval_t) { };\n#endif\n}\n\nstatic void igc_ptm_log_error(struct igc_adapter *adapter, u32 ptm_stat)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tswitch (ptm_stat) {\n\tcase IGC_PTM_STAT_RET_ERR:\n\t\tnetdev_err(netdev, \"PTM Error: Root port timeout\\n\");\n\t\tbreak;\n\tcase IGC_PTM_STAT_BAD_PTM_RES:\n\t\tnetdev_err(netdev, \"PTM Error: Bad response, PTM Response Data expected\\n\");\n\t\tbreak;\n\tcase IGC_PTM_STAT_T4M1_OVFL:\n\t\tnetdev_err(netdev, \"PTM Error: T4 minus T1 overflow\\n\");\n\t\tbreak;\n\tcase IGC_PTM_STAT_ADJUST_1ST:\n\t\tnetdev_err(netdev, \"PTM Error: 1588 timer adjusted during first PTM cycle\\n\");\n\t\tbreak;\n\tcase IGC_PTM_STAT_ADJUST_CYC:\n\t\tnetdev_err(netdev, \"PTM Error: 1588 timer adjusted during non-first PTM cycle\\n\");\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"PTM Error: Unknown error (%#x)\\n\", ptm_stat);\n\t\tbreak;\n\t}\n}\n\nstatic int igc_phc_get_syncdevicetime(ktime_t *device,\n\t\t\t\t      struct system_counterval_t *system,\n\t\t\t\t      void *ctx)\n{\n\tu32 stat, t2_curr_h, t2_curr_l, ctrl;\n\tstruct igc_adapter *adapter = ctx;\n\tstruct igc_hw *hw = &adapter->hw;\n\tint err, count = 100;\n\tktime_t t1, t2_curr;\n\n\t \n\tktime_get_snapshot(&adapter->snapshot);\n\n\tdo {\n\t\t \n\n\t\t \n\t\tctrl = rd32(IGC_PTM_CTRL);\n\t\tctrl &= ~IGC_PTM_CTRL_TRIG;\n\t\twr32(IGC_PTM_CTRL, ctrl);\n\t\tctrl |= IGC_PTM_CTRL_TRIG;\n\t\twr32(IGC_PTM_CTRL, ctrl);\n\n\t\t \n\t\twr32(IGC_PTM_STAT, IGC_PTM_STAT_VALID);\n\n\t\terr = readx_poll_timeout(rd32, IGC_PTM_STAT, stat,\n\t\t\t\t\t stat, IGC_PTM_STAT_SLEEP,\n\t\t\t\t\t IGC_PTM_STAT_TIMEOUT);\n\t\tif (err < 0) {\n\t\t\tnetdev_err(adapter->netdev, \"Timeout reading IGC_PTM_STAT register\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tif ((stat & IGC_PTM_STAT_VALID) == IGC_PTM_STAT_VALID)\n\t\t\tbreak;\n\n\t\tif (stat & ~IGC_PTM_STAT_VALID) {\n\t\t\t \n\t\t\tigc_ptm_log_error(adapter, stat);\n\t\t\t \n\t\t\twr32(IGC_PTM_STAT, stat);\n\t\t\tcontinue;\n\t\t}\n\t} while (--count);\n\n\tif (!count) {\n\t\tnetdev_err(adapter->netdev, \"Exceeded number of tries for PTM cycle\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tt1 = ktime_set(rd32(IGC_PTM_T1_TIM0_H), rd32(IGC_PTM_T1_TIM0_L));\n\n\tt2_curr_l = rd32(IGC_PTM_CURR_T2_L);\n\tt2_curr_h = rd32(IGC_PTM_CURR_T2_H);\n\n\t \n\tt2_curr_h = swab32(t2_curr_h);\n\n\tt2_curr = ((s64)t2_curr_h << 32 | t2_curr_l);\n\n\t*device = t1;\n\t*system = igc_device_tstamp_to_system(t2_curr);\n\n\treturn 0;\n}\n\nstatic int igc_ptp_getcrosststamp(struct ptp_clock_info *ptp,\n\t\t\t\t  struct system_device_crosststamp *cts)\n{\n\tstruct igc_adapter *adapter = container_of(ptp, struct igc_adapter,\n\t\t\t\t\t\t   ptp_caps);\n\n\treturn get_device_system_crosststamp(igc_phc_get_syncdevicetime,\n\t\t\t\t\t     adapter, &adapter->snapshot, cts);\n}\n\n \nvoid igc_ptp_init(struct igc_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct igc_tx_timestamp_request *tstamp;\n\tstruct igc_hw *hw = &adapter->hw;\n\tint i;\n\n\ttstamp = &adapter->tx_tstamp[0];\n\ttstamp->mask = IGC_TSYNCTXCTL_TXTT_0;\n\ttstamp->regl = IGC_TXSTMPL_0;\n\ttstamp->regh = IGC_TXSTMPH_0;\n\ttstamp->flags = 0;\n\n\ttstamp = &adapter->tx_tstamp[1];\n\ttstamp->mask = IGC_TSYNCTXCTL_TXTT_1;\n\ttstamp->regl = IGC_TXSTMPL_1;\n\ttstamp->regh = IGC_TXSTMPH_1;\n\ttstamp->flags = IGC_TX_FLAGS_TSTAMP_1;\n\n\ttstamp = &adapter->tx_tstamp[2];\n\ttstamp->mask = IGC_TSYNCTXCTL_TXTT_2;\n\ttstamp->regl = IGC_TXSTMPL_2;\n\ttstamp->regh = IGC_TXSTMPH_2;\n\ttstamp->flags = IGC_TX_FLAGS_TSTAMP_2;\n\n\ttstamp = &adapter->tx_tstamp[3];\n\ttstamp->mask = IGC_TSYNCTXCTL_TXTT_3;\n\ttstamp->regl = IGC_TXSTMPL_3;\n\ttstamp->regh = IGC_TXSTMPH_3;\n\ttstamp->flags = IGC_TX_FLAGS_TSTAMP_3;\n\n\tswitch (hw->mac.type) {\n\tcase igc_i225:\n\t\tfor (i = 0; i < IGC_N_SDP; i++) {\n\t\t\tstruct ptp_pin_desc *ppd = &adapter->sdp_config[i];\n\n\t\t\tsnprintf(ppd->name, sizeof(ppd->name), \"SDP%d\", i);\n\t\t\tppd->index = i;\n\t\t\tppd->func = PTP_PF_NONE;\n\t\t}\n\t\tsnprintf(adapter->ptp_caps.name, 16, \"%pm\", netdev->dev_addr);\n\t\tadapter->ptp_caps.owner = THIS_MODULE;\n\t\tadapter->ptp_caps.max_adj = 62499999;\n\t\tadapter->ptp_caps.adjfine = igc_ptp_adjfine_i225;\n\t\tadapter->ptp_caps.adjtime = igc_ptp_adjtime_i225;\n\t\tadapter->ptp_caps.gettimex64 = igc_ptp_gettimex64_i225;\n\t\tadapter->ptp_caps.settime64 = igc_ptp_settime_i225;\n\t\tadapter->ptp_caps.enable = igc_ptp_feature_enable_i225;\n\t\tadapter->ptp_caps.pps = 1;\n\t\tadapter->ptp_caps.pin_config = adapter->sdp_config;\n\t\tadapter->ptp_caps.n_ext_ts = IGC_N_EXTTS;\n\t\tadapter->ptp_caps.n_per_out = IGC_N_PEROUT;\n\t\tadapter->ptp_caps.n_pins = IGC_N_SDP;\n\t\tadapter->ptp_caps.verify = igc_ptp_verify_pin;\n\n\t\tif (!igc_is_crosststamp_supported(adapter))\n\t\t\tbreak;\n\n\t\tadapter->ptp_caps.getcrosststamp = igc_ptp_getcrosststamp;\n\t\tbreak;\n\tdefault:\n\t\tadapter->ptp_clock = NULL;\n\t\treturn;\n\t}\n\n\tspin_lock_init(&adapter->ptp_tx_lock);\n\tspin_lock_init(&adapter->tmreg_lock);\n\n\tadapter->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\n\tadapter->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\n\n\tadapter->prev_ptp_time = ktime_to_timespec64(ktime_get_real());\n\tadapter->ptp_reset_start = ktime_get();\n\n\tadapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,\n\t\t\t\t\t\t&adapter->pdev->dev);\n\tif (IS_ERR(adapter->ptp_clock)) {\n\t\tadapter->ptp_clock = NULL;\n\t\tnetdev_err(netdev, \"ptp_clock_register failed\\n\");\n\t} else if (adapter->ptp_clock) {\n\t\tnetdev_info(netdev, \"PHC added\\n\");\n\t\tadapter->ptp_flags |= IGC_PTP_ENABLED;\n\t}\n}\n\nstatic void igc_ptp_time_save(struct igc_adapter *adapter)\n{\n\tigc_ptp_read(adapter, &adapter->prev_ptp_time);\n\tadapter->ptp_reset_start = ktime_get();\n}\n\nstatic void igc_ptp_time_restore(struct igc_adapter *adapter)\n{\n\tstruct timespec64 ts = adapter->prev_ptp_time;\n\tktime_t delta;\n\n\tdelta = ktime_sub(ktime_get(), adapter->ptp_reset_start);\n\n\ttimespec64_add_ns(&ts, ktime_to_ns(delta));\n\n\tigc_ptp_write_i225(adapter, &ts);\n}\n\nstatic void igc_ptm_stop(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 ctrl;\n\n\tctrl = rd32(IGC_PTM_CTRL);\n\tctrl &= ~IGC_PTM_CTRL_EN;\n\n\twr32(IGC_PTM_CTRL, ctrl);\n}\n\n \nvoid igc_ptp_suspend(struct igc_adapter *adapter)\n{\n\tif (!(adapter->ptp_flags & IGC_PTP_ENABLED))\n\t\treturn;\n\n\tigc_ptp_clear_tx_tstamp(adapter);\n\n\tif (pci_device_is_present(adapter->pdev)) {\n\t\tigc_ptp_time_save(adapter);\n\t\tigc_ptm_stop(adapter);\n\t}\n}\n\n \nvoid igc_ptp_stop(struct igc_adapter *adapter)\n{\n\tigc_ptp_suspend(adapter);\n\n\tif (adapter->ptp_clock) {\n\t\tptp_clock_unregister(adapter->ptp_clock);\n\t\tnetdev_info(adapter->netdev, \"PHC removed\\n\");\n\t\tadapter->ptp_flags &= ~IGC_PTP_ENABLED;\n\t}\n}\n\n \nvoid igc_ptp_reset(struct igc_adapter *adapter)\n{\n\tstruct igc_hw *hw = &adapter->hw;\n\tu32 cycle_ctrl, ctrl;\n\tunsigned long flags;\n\tu32 timadj;\n\n\t \n\tigc_ptp_set_timestamp_mode(adapter, &adapter->tstamp_config);\n\n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\n\tswitch (adapter->hw.mac.type) {\n\tcase igc_i225:\n\t\ttimadj = rd32(IGC_TIMADJ);\n\t\ttimadj |= IGC_TIMADJ_ADJUST_METH;\n\t\twr32(IGC_TIMADJ, timadj);\n\n\t\twr32(IGC_TSAUXC, 0x0);\n\t\twr32(IGC_TSSDP, 0x0);\n\t\twr32(IGC_TSIM,\n\t\t     IGC_TSICR_INTERRUPTS |\n\t\t     (adapter->pps_sys_wrap_on ? IGC_TSICR_SYS_WRAP : 0));\n\t\twr32(IGC_IMS, IGC_IMS_TS);\n\n\t\tif (!igc_is_crosststamp_supported(adapter))\n\t\t\tbreak;\n\n\t\twr32(IGC_PCIE_DIG_DELAY, IGC_PCIE_DIG_DELAY_DEFAULT);\n\t\twr32(IGC_PCIE_PHY_DELAY, IGC_PCIE_PHY_DELAY_DEFAULT);\n\n\t\tcycle_ctrl = IGC_PTM_CYCLE_CTRL_CYC_TIME(IGC_PTM_CYC_TIME_DEFAULT);\n\n\t\twr32(IGC_PTM_CYCLE_CTRL, cycle_ctrl);\n\n\t\tctrl = IGC_PTM_CTRL_EN |\n\t\t\tIGC_PTM_CTRL_START_NOW |\n\t\t\tIGC_PTM_CTRL_SHRT_CYC(IGC_PTM_SHORT_CYC_DEFAULT) |\n\t\t\tIGC_PTM_CTRL_PTM_TO(IGC_PTM_TIMEOUT_DEFAULT) |\n\t\t\tIGC_PTM_CTRL_TRIG;\n\n\t\twr32(IGC_PTM_CTRL, ctrl);\n\n\t\t \n\t\twr32(IGC_PTM_STAT, IGC_PTM_STAT_VALID);\n\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tif (hw->mac.type == igc_i225) {\n\t\tigc_ptp_time_restore(adapter);\n\t} else {\n\t\ttimecounter_init(&adapter->tc, &adapter->cc,\n\t\t\t\t ktime_to_ns(ktime_get_real()));\n\t}\nout:\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\twrfl();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}