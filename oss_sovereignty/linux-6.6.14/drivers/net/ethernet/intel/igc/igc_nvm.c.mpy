{
  "module_name": "igc_nvm.c",
  "hash_id": "b109bd0fd7526e279820fac5c4c4d7895660472f33690d97c2447dbd2fdf5488",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_nvm.c",
  "human_readable_source": "\n \n\n#include \"igc_mac.h\"\n#include \"igc_nvm.h\"\n\n \nstatic s32 igc_poll_eerd_eewr_done(struct igc_hw *hw, int ee_reg)\n{\n\ts32 ret_val = -IGC_ERR_NVM;\n\tu32 attempts = 100000;\n\tu32 i, reg = 0;\n\n\tfor (i = 0; i < attempts; i++) {\n\t\tif (ee_reg == IGC_NVM_POLL_READ)\n\t\t\treg = rd32(IGC_EERD);\n\t\telse\n\t\t\treg = rd32(IGC_EEWR);\n\n\t\tif (reg & IGC_NVM_RW_REG_DONE) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(5);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 igc_acquire_nvm(struct igc_hw *hw)\n{\n\ts32 timeout = IGC_NVM_GRANT_ATTEMPTS;\n\tu32 eecd = rd32(IGC_EECD);\n\ts32 ret_val = 0;\n\n\twr32(IGC_EECD, eecd | IGC_EECD_REQ);\n\teecd = rd32(IGC_EECD);\n\n\twhile (timeout) {\n\t\tif (eecd & IGC_EECD_GNT)\n\t\t\tbreak;\n\t\tudelay(5);\n\t\teecd = rd32(IGC_EECD);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\teecd &= ~IGC_EECD_REQ;\n\t\twr32(IGC_EECD, eecd);\n\t\thw_dbg(\"Could not acquire NVM grant\\n\");\n\t\tret_val = -IGC_ERR_NVM;\n\t}\n\n\treturn ret_val;\n}\n\n \nvoid igc_release_nvm(struct igc_hw *hw)\n{\n\tu32 eecd;\n\n\teecd = rd32(IGC_EECD);\n\teecd &= ~IGC_EECD_REQ;\n\twr32(IGC_EECD, eecd);\n}\n\n \ns32 igc_read_nvm_eerd(struct igc_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\tstruct igc_nvm_info *nvm = &hw->nvm;\n\tu32 i, eerd = 0;\n\ts32 ret_val = 0;\n\n\t \n\tif (offset >= nvm->word_size || (words > (nvm->word_size - offset)) ||\n\t    words == 0) {\n\t\thw_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\tret_val = -IGC_ERR_NVM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\teerd = ((offset + i) << IGC_NVM_RW_ADDR_SHIFT) +\n\t\t\tIGC_NVM_RW_REG_START;\n\n\t\twr32(IGC_EERD, eerd);\n\t\tret_val = igc_poll_eerd_eewr_done(hw, IGC_NVM_POLL_READ);\n\t\tif (ret_val)\n\t\t\tbreak;\n\n\t\tdata[i] = (rd32(IGC_EERD) >> IGC_NVM_RW_REG_DATA);\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igc_read_mac_addr(struct igc_hw *hw)\n{\n\tu32 rar_high;\n\tu32 rar_low;\n\tu16 i;\n\n\trar_high = rd32(IGC_RAH(0));\n\trar_low = rd32(IGC_RAL(0));\n\n\tfor (i = 0; i < IGC_RAL_MAC_ADDR_LEN; i++)\n\t\thw->mac.perm_addr[i] = (u8)(rar_low >> (i * 8));\n\n\tfor (i = 0; i < IGC_RAH_MAC_ADDR_LEN; i++)\n\t\thw->mac.perm_addr[i + 4] = (u8)(rar_high >> (i * 8));\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\thw->mac.addr[i] = hw->mac.perm_addr[i];\n\n\treturn 0;\n}\n\n \ns32 igc_validate_nvm_checksum(struct igc_hw *hw)\n{\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\ts32 ret_val = 0;\n\n\tfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {\n\t\tret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\n\tif (checksum != (u16)NVM_SUM) {\n\t\thw_dbg(\"NVM Checksum Invalid\\n\");\n\t\tret_val = -IGC_ERR_NVM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igc_update_nvm_checksum(struct igc_hw *hw)\n{\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\ts32  ret_val;\n\n\tfor (i = 0; i < NVM_CHECKSUM_REG; i++) {\n\t\tret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error while updating checksum.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\tchecksum = (u16)NVM_SUM - checksum;\n\tret_val = hw->nvm.ops.write(hw, NVM_CHECKSUM_REG, 1, &checksum);\n\tif (ret_val)\n\t\thw_dbg(\"NVM Write Error while updating checksum.\\n\");\n\nout:\n\treturn ret_val;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}