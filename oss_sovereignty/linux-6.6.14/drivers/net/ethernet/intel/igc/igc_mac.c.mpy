{
  "module_name": "igc_mac.c",
  "hash_id": "0cbf321a5546285434e196cb68466ac2783a9865b4ac451f9cbc481d37487b6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igc/igc_mac.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include \"igc_mac.h\"\n#include \"igc_hw.h\"\n\n \ns32 igc_disable_pcie_master(struct igc_hw *hw)\n{\n\ts32 timeout = MASTER_DISABLE_TIMEOUT;\n\ts32 ret_val = 0;\n\tu32 ctrl;\n\n\tctrl = rd32(IGC_CTRL);\n\tctrl |= IGC_CTRL_GIO_MASTER_DISABLE;\n\twr32(IGC_CTRL, ctrl);\n\n\twhile (timeout) {\n\t\tif (!(rd32(IGC_STATUS) &\n\t\t    IGC_STATUS_GIO_MASTER_ENABLE))\n\t\t\tbreak;\n\t\tusleep_range(2000, 3000);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\thw_dbg(\"Master requests are pending.\\n\");\n\t\tret_val = -IGC_ERR_MASTER_REQUESTS_PENDING;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nvoid igc_init_rx_addrs(struct igc_hw *hw, u16 rar_count)\n{\n\tu8 mac_addr[ETH_ALEN] = {0};\n\tu32 i;\n\n\t \n\thw_dbg(\"Programming MAC Address into RAR[0]\\n\");\n\n\thw->mac.ops.rar_set(hw, hw->mac.addr, 0);\n\n\t \n\thw_dbg(\"Clearing RAR[1-%u]\\n\", rar_count - 1);\n\tfor (i = 1; i < rar_count; i++)\n\t\thw->mac.ops.rar_set(hw, mac_addr, i);\n}\n\n \nstatic s32 igc_set_fc_watermarks(struct igc_hw *hw)\n{\n\tu32 fcrtl = 0, fcrth = 0;\n\n\t \n\tif (hw->fc.current_mode & igc_fc_tx_pause) {\n\t\t \n\t\tfcrtl = hw->fc.low_water;\n\t\tif (hw->fc.send_xon)\n\t\t\tfcrtl |= IGC_FCRTL_XONE;\n\n\t\tfcrth = hw->fc.high_water;\n\t}\n\twr32(IGC_FCRTL, fcrtl);\n\twr32(IGC_FCRTH, fcrth);\n\n\treturn 0;\n}\n\n \ns32 igc_setup_link(struct igc_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\t \n\tif (igc_check_reset_block(hw))\n\t\tgoto out;\n\n\t \n\tif (hw->fc.requested_mode == igc_fc_default)\n\t\thw->fc.requested_mode = igc_fc_full;\n\n\t \n\thw->fc.current_mode = hw->fc.requested_mode;\n\n\thw_dbg(\"After fix-ups FlowControl is now = %x\\n\", hw->fc.current_mode);\n\n\t \n\tret_val = hw->mac.ops.setup_physical_interface(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\thw_dbg(\"Initializing the Flow Control address, type and timer regs\\n\");\n\twr32(IGC_FCT, FLOW_CONTROL_TYPE);\n\twr32(IGC_FCAH, FLOW_CONTROL_ADDRESS_HIGH);\n\twr32(IGC_FCAL, FLOW_CONTROL_ADDRESS_LOW);\n\n\twr32(IGC_FCTTV, hw->fc.pause_time);\n\n\tret_val = igc_set_fc_watermarks(hw);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igc_force_mac_fc(struct igc_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu32 ctrl;\n\n\tctrl = rd32(IGC_CTRL);\n\n\t \n\thw_dbg(\"hw->fc.current_mode = %u\\n\", hw->fc.current_mode);\n\n\tswitch (hw->fc.current_mode) {\n\tcase igc_fc_none:\n\t\tctrl &= (~(IGC_CTRL_TFCE | IGC_CTRL_RFCE));\n\t\tbreak;\n\tcase igc_fc_rx_pause:\n\t\tctrl &= (~IGC_CTRL_TFCE);\n\t\tctrl |= IGC_CTRL_RFCE;\n\t\tbreak;\n\tcase igc_fc_tx_pause:\n\t\tctrl &= (~IGC_CTRL_RFCE);\n\t\tctrl |= IGC_CTRL_TFCE;\n\t\tbreak;\n\tcase igc_fc_full:\n\t\tctrl |= (IGC_CTRL_TFCE | IGC_CTRL_RFCE);\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(\"Flow control param set incorrectly\\n\");\n\t\tret_val = -IGC_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\twr32(IGC_CTRL, ctrl);\n\nout:\n\treturn ret_val;\n}\n\n \nvoid igc_clear_hw_cntrs_base(struct igc_hw *hw)\n{\n\trd32(IGC_CRCERRS);\n\trd32(IGC_MPC);\n\trd32(IGC_SCC);\n\trd32(IGC_ECOL);\n\trd32(IGC_MCC);\n\trd32(IGC_LATECOL);\n\trd32(IGC_COLC);\n\trd32(IGC_RERC);\n\trd32(IGC_DC);\n\trd32(IGC_RLEC);\n\trd32(IGC_XONRXC);\n\trd32(IGC_XONTXC);\n\trd32(IGC_XOFFRXC);\n\trd32(IGC_XOFFTXC);\n\trd32(IGC_FCRUC);\n\trd32(IGC_GPRC);\n\trd32(IGC_BPRC);\n\trd32(IGC_MPRC);\n\trd32(IGC_GPTC);\n\trd32(IGC_GORCL);\n\trd32(IGC_GORCH);\n\trd32(IGC_GOTCL);\n\trd32(IGC_GOTCH);\n\trd32(IGC_RNBC);\n\trd32(IGC_RUC);\n\trd32(IGC_RFC);\n\trd32(IGC_ROC);\n\trd32(IGC_RJC);\n\trd32(IGC_TORL);\n\trd32(IGC_TORH);\n\trd32(IGC_TOTL);\n\trd32(IGC_TOTH);\n\trd32(IGC_TPR);\n\trd32(IGC_TPT);\n\trd32(IGC_MPTC);\n\trd32(IGC_BPTC);\n\n\trd32(IGC_PRC64);\n\trd32(IGC_PRC127);\n\trd32(IGC_PRC255);\n\trd32(IGC_PRC511);\n\trd32(IGC_PRC1023);\n\trd32(IGC_PRC1522);\n\trd32(IGC_PTC64);\n\trd32(IGC_PTC127);\n\trd32(IGC_PTC255);\n\trd32(IGC_PTC511);\n\trd32(IGC_PTC1023);\n\trd32(IGC_PTC1522);\n\n\trd32(IGC_ALGNERRC);\n\trd32(IGC_RXERRC);\n\trd32(IGC_TNCRS);\n\trd32(IGC_HTDPMC);\n\trd32(IGC_TSCTC);\n\n\trd32(IGC_MGTPRC);\n\trd32(IGC_MGTPDC);\n\trd32(IGC_MGTPTC);\n\n\trd32(IGC_IAC);\n\n\trd32(IGC_RPTHC);\n\trd32(IGC_TLPIC);\n\trd32(IGC_RLPIC);\n\trd32(IGC_HGPTC);\n\trd32(IGC_RXDMTC);\n\trd32(IGC_HGORCL);\n\trd32(IGC_HGORCH);\n\trd32(IGC_HGOTCL);\n\trd32(IGC_HGOTCH);\n\trd32(IGC_LENERRS);\n}\n\n \nvoid igc_rar_set(struct igc_hw *hw, u8 *addr, u32 index)\n{\n\tu32 rar_low, rar_high;\n\n\t \n\trar_low = ((u32)addr[0] |\n\t\t   ((u32)addr[1] << 8) |\n\t\t   ((u32)addr[2] << 16) | ((u32)addr[3] << 24));\n\n\trar_high = ((u32)addr[4] | ((u32)addr[5] << 8));\n\n\t \n\tif (rar_low || rar_high)\n\t\trar_high |= IGC_RAH_AV;\n\n\t \n\twr32(IGC_RAL(index), rar_low);\n\twrfl();\n\twr32(IGC_RAH(index), rar_high);\n\twrfl();\n}\n\n \ns32 igc_check_for_copper_link(struct igc_hw *hw)\n{\n\tstruct igc_mac_info *mac = &hw->mac;\n\tbool link = false;\n\ts32 ret_val;\n\n\t \n\tif (!mac->get_link_status) {\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tret_val = igc_phy_has_link(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!link)\n\t\tgoto out;  \n\n\tmac->get_link_status = false;\n\n\t \n\tigc_check_downshift(hw);\n\n\t \n\tif (!mac->autoneg) {\n\t\tret_val = -IGC_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\t \n\tigc_config_collision_dist(hw);\n\n\t \n\tret_val = igc_config_fc_after_link_up(hw);\n\tif (ret_val)\n\t\thw_dbg(\"Error configuring flow control\\n\");\n\nout:\n\t \n\tret_val = igc_set_ltr_i225(hw, link);\n\n\treturn ret_val;\n}\n\n \nvoid igc_config_collision_dist(struct igc_hw *hw)\n{\n\tu32 tctl;\n\n\ttctl = rd32(IGC_TCTL);\n\n\ttctl &= ~IGC_TCTL_COLD;\n\ttctl |= IGC_COLLISION_DISTANCE << IGC_COLD_SHIFT;\n\n\twr32(IGC_TCTL, tctl);\n\twrfl();\n}\n\n \ns32 igc_config_fc_after_link_up(struct igc_hw *hw)\n{\n\tu16 mii_status_reg, mii_nway_adv_reg, mii_nway_lp_ability_reg;\n\tstruct igc_mac_info *mac = &hw->mac;\n\tu16 speed, duplex;\n\ts32 ret_val = 0;\n\n\t \n\tif (mac->autoneg_failed)\n\t\tret_val = igc_force_mac_fc(hw);\n\n\tif (ret_val) {\n\t\thw_dbg(\"Error forcing flow control settings\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (mac->autoneg) {\n\t\t \n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS,\n\t\t\t\t\t       &mii_status_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS,\n\t\t\t\t\t       &mii_status_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (!(mii_status_reg & MII_SR_AUTONEG_COMPLETE)) {\n\t\t\thw_dbg(\"Copper PHY and Auto Neg has not completed.\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_AUTONEG_ADV,\n\t\t\t\t\t       &mii_nway_adv_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_LP_ABILITY,\n\t\t\t\t\t       &mii_nway_lp_ability_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t\t \n\t\tif ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {\n\t\t\t \n\t\t\tif (hw->fc.requested_mode == igc_fc_full) {\n\t\t\t\thw->fc.current_mode = igc_fc_full;\n\t\t\t\thw_dbg(\"Flow Control = FULL.\\n\");\n\t\t\t} else {\n\t\t\t\thw->fc.current_mode = igc_fc_rx_pause;\n\t\t\t\thw_dbg(\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t\t}\n\t\t}\n\n\t\t \n\t\telse if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t\t (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\n\t\t\t (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\n\t\t\t (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\n\t\t\thw->fc.current_mode = igc_fc_tx_pause;\n\t\t\thw_dbg(\"Flow Control = TX PAUSE frames only.\\n\");\n\t\t}\n\t\t \n\t\telse if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t\t (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\n\t\t\t !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\n\t\t\t (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\n\t\t\thw->fc.current_mode = igc_fc_rx_pause;\n\t\t\thw_dbg(\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t}\n\t\t \n\t\telse if ((hw->fc.requested_mode == igc_fc_none) ||\n\t\t\t (hw->fc.requested_mode == igc_fc_tx_pause) ||\n\t\t\t (hw->fc.strict_ieee)) {\n\t\t\thw->fc.current_mode = igc_fc_none;\n\t\t\thw_dbg(\"Flow Control = NONE.\\n\");\n\t\t} else {\n\t\t\thw->fc.current_mode = igc_fc_rx_pause;\n\t\t\thw_dbg(\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t}\n\n\t\t \n\t\tret_val = hw->mac.ops.get_speed_and_duplex(hw, &speed, &duplex);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error getting link speed and duplex\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (duplex == HALF_DUPLEX)\n\t\t\thw->fc.current_mode = igc_fc_none;\n\n\t\t \n\t\tret_val = igc_force_mac_fc(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error forcing flow control settings\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igc_get_auto_rd_done(struct igc_hw *hw)\n{\n\ts32 ret_val = 0;\n\ts32 i = 0;\n\n\twhile (i < AUTO_READ_DONE_TIMEOUT) {\n\t\tif (rd32(IGC_EECD) & IGC_EECD_AUTO_RD)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\ti++;\n\t}\n\n\tif (i == AUTO_READ_DONE_TIMEOUT) {\n\t\thw_dbg(\"Auto read by HW from NVM has not completed.\\n\");\n\t\tret_val = -IGC_ERR_RESET;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igc_get_speed_and_duplex_copper(struct igc_hw *hw, u16 *speed,\n\t\t\t\t    u16 *duplex)\n{\n\tu32 status;\n\n\tstatus = rd32(IGC_STATUS);\n\tif (status & IGC_STATUS_SPEED_1000) {\n\t\t \n\t\tif (hw->mac.type == igc_i225 &&\n\t\t    (status & IGC_STATUS_SPEED_2500)) {\n\t\t\t*speed = SPEED_2500;\n\t\t\thw_dbg(\"2500 Mbs, \");\n\t\t} else {\n\t\t\t*speed = SPEED_1000;\n\t\t\thw_dbg(\"1000 Mbs, \");\n\t\t}\n\t} else if (status & IGC_STATUS_SPEED_100) {\n\t\t*speed = SPEED_100;\n\t\thw_dbg(\"100 Mbs, \");\n\t} else {\n\t\t*speed = SPEED_10;\n\t\thw_dbg(\"10 Mbs, \");\n\t}\n\n\tif (status & IGC_STATUS_FD) {\n\t\t*duplex = FULL_DUPLEX;\n\t\thw_dbg(\"Full Duplex\\n\");\n\t} else {\n\t\t*duplex = HALF_DUPLEX;\n\t\thw_dbg(\"Half Duplex\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nvoid igc_put_hw_semaphore(struct igc_hw *hw)\n{\n\tu32 swsm;\n\n\tswsm = rd32(IGC_SWSM);\n\n\tswsm &= ~(IGC_SWSM_SMBI | IGC_SWSM_SWESMBI);\n\n\twr32(IGC_SWSM, swsm);\n}\n\n \nbool igc_enable_mng_pass_thru(struct igc_hw *hw)\n{\n\tbool ret_val = false;\n\tu32 fwsm, factps;\n\tu32 manc;\n\n\tif (!hw->mac.asf_firmware_present)\n\t\tgoto out;\n\n\tmanc = rd32(IGC_MANC);\n\n\tif (!(manc & IGC_MANC_RCV_TCO_EN))\n\t\tgoto out;\n\n\tif (hw->mac.arc_subsystem_valid) {\n\t\tfwsm = rd32(IGC_FWSM);\n\t\tfactps = rd32(IGC_FACTPS);\n\n\t\tif (!(factps & IGC_FACTPS_MNGCG) &&\n\t\t    ((fwsm & IGC_FWSM_MODE_MASK) ==\n\t\t    (igc_mng_mode_pt << IGC_FWSM_MODE_SHIFT))) {\n\t\t\tret_val = true;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((manc & IGC_MANC_SMBUS_EN) &&\n\t\t    !(manc & IGC_MANC_ASF_EN)) {\n\t\t\tret_val = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic u32 igc_hash_mc_addr(struct igc_hw *hw, u8 *mc_addr)\n{\n\tu32 hash_value, hash_mask;\n\tu8 bit_shift = 0;\n\n\t \n\thash_mask = (hw->mac.mta_reg_count * 32) - 1;\n\n\t \n\twhile (hash_mask >> bit_shift != 0xFF)\n\t\tbit_shift++;\n\n\t \n\tswitch (hw->mac.mc_filter_type) {\n\tdefault:\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tbit_shift += 1;\n\t\tbreak;\n\tcase 2:\n\t\tbit_shift += 2;\n\t\tbreak;\n\tcase 3:\n\t\tbit_shift += 4;\n\t\tbreak;\n\t}\n\n\thash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\n\t\t\t\t  (((u16)mc_addr[5]) << bit_shift)));\n\n\treturn hash_value;\n}\n\n \nvoid igc_update_mc_addr_list(struct igc_hw *hw,\n\t\t\t     u8 *mc_addr_list, u32 mc_addr_count)\n{\n\tu32 hash_value, hash_bit, hash_reg;\n\tint i;\n\n\t \n\tmemset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));\n\n\t \n\tfor (i = 0; (u32)i < mc_addr_count; i++) {\n\t\thash_value = igc_hash_mc_addr(hw, mc_addr_list);\n\n\t\thash_reg = (hash_value >> 5) & (hw->mac.mta_reg_count - 1);\n\t\thash_bit = hash_value & 0x1F;\n\n\t\thw->mac.mta_shadow[hash_reg] |= BIT(hash_bit);\n\t\tmc_addr_list += ETH_ALEN;\n\t}\n\n\t \n\tfor (i = hw->mac.mta_reg_count - 1; i >= 0; i--)\n\t\tarray_wr32(IGC_MTA, i, hw->mac.mta_shadow[i]);\n\twrfl();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}