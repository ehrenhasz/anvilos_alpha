{
  "module_name": "ice_flow.c",
  "hash_id": "44a786b188c0a39799e89ff4c5ac1e63959689b15ec485f6732c9b4cd58619ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_flow.c",
  "human_readable_source": "\n \n\n#include \"ice_common.h\"\n#include \"ice_flow.h\"\n#include <net/gre.h>\n\n \nstruct ice_flow_field_info {\n\tenum ice_flow_seg_hdr hdr;\n\ts16 off;\t \n\tu16 size;\t \n\tu16 mask;\t \n};\n\n#define ICE_FLOW_FLD_INFO(_hdr, _offset_bytes, _size_bytes) { \\\n\t.hdr = _hdr, \\\n\t.off = (_offset_bytes) * BITS_PER_BYTE, \\\n\t.size = (_size_bytes) * BITS_PER_BYTE, \\\n\t.mask = 0, \\\n}\n\n#define ICE_FLOW_FLD_INFO_MSK(_hdr, _offset_bytes, _size_bytes, _mask) { \\\n\t.hdr = _hdr, \\\n\t.off = (_offset_bytes) * BITS_PER_BYTE, \\\n\t.size = (_size_bytes) * BITS_PER_BYTE, \\\n\t.mask = _mask, \\\n}\n\n \nstatic const\nstruct ice_flow_field_info ice_flds_info[ICE_FLOW_FIELD_IDX_MAX] = {\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ETH, 0, ETH_ALEN),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ETH, ETH_ALEN, ETH_ALEN),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_VLAN, 12, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_VLAN, 14, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ETH, 0, sizeof(__be16)),\n\t \n\t \n\tICE_FLOW_FLD_INFO_MSK(ICE_FLOW_SEG_HDR_IPV4, 0, 1, 0x00fc),\n\t \n\tICE_FLOW_FLD_INFO_MSK(ICE_FLOW_SEG_HDR_IPV6, 0, 1, 0x0ff0),\n\t \n\tICE_FLOW_FLD_INFO_MSK(ICE_FLOW_SEG_HDR_NONE, 8, 1, 0xff00),\n\t \n\tICE_FLOW_FLD_INFO_MSK(ICE_FLOW_SEG_HDR_NONE, 8, 1, 0x00ff),\n\t \n\tICE_FLOW_FLD_INFO_MSK(ICE_FLOW_SEG_HDR_NONE, 6, 1, 0x00ff),\n\t \n\tICE_FLOW_FLD_INFO_MSK(ICE_FLOW_SEG_HDR_NONE, 6, 1, 0xff00),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_IPV4, 12, sizeof(struct in_addr)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_IPV4, 16, sizeof(struct in_addr)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_IPV6, 8, sizeof(struct in6_addr)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_IPV6, 24, sizeof(struct in6_addr)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_TCP, 0, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_TCP, 2, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_UDP, 0, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_UDP, 2, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_SCTP, 0, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_SCTP, 2, sizeof(__be16)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_TCP, 13, 1),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ARP, 14, sizeof(struct in_addr)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ARP, 24, sizeof(struct in_addr)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ARP, 8, ETH_ALEN),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ARP, 18, ETH_ALEN),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ARP, 6, sizeof(__be16)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ICMP, 0, 1),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ICMP, 1, 1),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_GRE, 12,\n\t\t\t  sizeof_field(struct gre_full_hdr, key)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_GTPC_TEID, 12, sizeof(__be32)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_GTPU_IP, 12, sizeof(__be32)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_GTPU_EH, 12, sizeof(__be32)),\n\t \n\tICE_FLOW_FLD_INFO_MSK(ICE_FLOW_SEG_HDR_GTPU_EH, 22, sizeof(__be16),\n\t\t\t      0x3f00),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_GTPU_UP, 12, sizeof(__be32)),\n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_GTPU_DWN, 12, sizeof(__be32)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_PPPOE, 2, sizeof(__be16)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_PFCP_SESSION, 12, sizeof(__be64)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_L2TPV3, 0, sizeof(__be32)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_ESP, 0, sizeof(__be32)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_AH, 4, sizeof(__be32)),\n\t \n\t \n\tICE_FLOW_FLD_INFO(ICE_FLOW_SEG_HDR_NAT_T_ESP, 8, sizeof(__be32)),\n};\n\n \nstatic const u32 ice_ptypes_mac_ofos[] = {\n\t0xFDC00846, 0xBFBF7F7E, 0xF70001DF, 0xFEFDFDFB,\n\t0x0000077E, 0x00000000, 0x00000000, 0x00000000,\n\t0x00400000, 0x03FFF000, 0x7FFFFFE0, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_macvlan_il[] = {\n\t0x00000000, 0xBC000000, 0x000001DF, 0xF0000000,\n\t0x0000077E, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv4_ofos[] = {\n\t0x1DC00000, 0x04000800, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000155, 0x00000000, 0x00000000,\n\t0x00000000, 0x000FC000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv4_ofos_all[] = {\n\t0x1DC00000, 0x04000800, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000155, 0x00000000, 0x00000000,\n\t0x00000000, 0x000FC000, 0x83E0F800, 0x00000101,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv4_il[] = {\n\t0xE0000000, 0xB807700E, 0x80000003, 0xE01DC03B,\n\t0x0000000E, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x001FF800, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv6_ofos[] = {\n\t0x00000000, 0x00000000, 0x77000000, 0x10002000,\n\t0x00000000, 0x000002AA, 0x00000000, 0x00000000,\n\t0x00000000, 0x03F00000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv6_ofos_all[] = {\n\t0x00000000, 0x00000000, 0x77000000, 0x10002000,\n\t0x00000000, 0x000002AA, 0x00000000, 0x00000000,\n\t0x00080F00, 0x03F00000, 0x7C1F0000, 0x00000206,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv6_il[] = {\n\t0x00000000, 0x03B80770, 0x000001DC, 0x0EE00000,\n\t0x00000770, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x7FE00000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv4_ofos_no_l4[] = {\n\t0x10C00000, 0x04000800, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_arp_of[] = {\n\t0x00000800, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv4_il_no_l4[] = {\n\t0x60000000, 0x18043008, 0x80000002, 0x6010c021,\n\t0x00000008, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv6_ofos_no_l4[] = {\n\t0x00000000, 0x00000000, 0x43000000, 0x10002000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ipv6_il_no_l4[] = {\n\t0x00000000, 0x02180430, 0x0000010c, 0x086010c0,\n\t0x00000430, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_udp_il[] = {\n\t0x81000000, 0x20204040, 0x04000010, 0x80810102,\n\t0x00000040, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00410000, 0x90842000, 0x00000007,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_tcp_il[] = {\n\t0x04000000, 0x80810102, 0x10000040, 0x02040408,\n\t0x00000102, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00820000, 0x21084000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_sctp_il[] = {\n\t0x08000000, 0x01020204, 0x20000081, 0x04080810,\n\t0x00000204, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x01040000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_icmp_of[] = {\n\t0x10000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_icmp_il[] = {\n\t0x00000000, 0x02040408, 0x40000102, 0x08101020,\n\t0x00000408, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x42108000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_gre_of[] = {\n\t0x00000000, 0xBFBF7800, 0x000001DF, 0xFEFDE000,\n\t0x0000017E, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_mac_il[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_gtpc[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000180, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_gtpc_tid[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000060, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const struct ice_ptype_attributes ice_attr_gtpu_eh[] = {\n\t{ ICE_MAC_IPV4_GTPU_IPV4_FRAG,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_PAY,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_UDP_PAY, ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_TCP,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_ICMP,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_FRAG,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_PAY,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_UDP_PAY, ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_TCP,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_ICMP,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_FRAG,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_PAY,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_UDP_PAY, ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_TCP,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_ICMPV6,  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_FRAG,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_PAY,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_UDP_PAY, ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_TCP,\t  ICE_PTYPE_ATTR_GTP_PDU_EH },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_ICMPV6,  ICE_PTYPE_ATTR_GTP_PDU_EH },\n};\n\nstatic const struct ice_ptype_attributes ice_attr_gtpu_down[] = {\n\t{ ICE_MAC_IPV4_GTPU_IPV4_FRAG,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_PAY,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_UDP_PAY, ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_TCP,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_ICMP,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_FRAG,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_PAY,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_UDP_PAY, ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_TCP,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_ICMP,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_FRAG,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_PAY,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_UDP_PAY, ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_TCP,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_ICMPV6,  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_FRAG,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_PAY,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_UDP_PAY, ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_TCP,\t  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_ICMPV6,  ICE_PTYPE_ATTR_GTP_DOWNLINK },\n};\n\nstatic const struct ice_ptype_attributes ice_attr_gtpu_up[] = {\n\t{ ICE_MAC_IPV4_GTPU_IPV4_FRAG,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_PAY,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_UDP_PAY, ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_TCP,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV4_ICMP,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_FRAG,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_PAY,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_UDP_PAY, ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_TCP,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV4_ICMP,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_FRAG,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_PAY,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_UDP_PAY, ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_TCP,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV4_GTPU_IPV6_ICMPV6,  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_FRAG,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_PAY,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_UDP_PAY, ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_TCP,\t  ICE_PTYPE_ATTR_GTP_UPLINK },\n\t{ ICE_MAC_IPV6_GTPU_IPV6_ICMPV6,  ICE_PTYPE_ATTR_GTP_UPLINK },\n};\n\nstatic const u32 ice_ptypes_gtpu[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x7FFFFE00, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_pppoe[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x03ffe000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_pfcp_node[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x80000000, 0x00000002,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_pfcp_session[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000005,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_l2tpv3[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000300,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_esp[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000003, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_ah[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x0000000C, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstatic const u32 ice_ptypes_nat_t_esp[] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000030, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\nstatic const u32 ice_ptypes_mac_non_ip_ofos[] = {\n\t0x00000846, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00400000, 0x03FFF000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n};\n\n \nstruct ice_flow_prof_params {\n\tenum ice_block blk;\n\tu16 entry_length;  \n\tu8 es_cnt;\n\tstruct ice_flow_prof *prof;\n\n\t \n\tstruct ice_fv_word es[ICE_MAX_FV_WORDS];\n\t \n\tconst struct ice_ptype_attributes *attr;\n\tu16 attr_cnt;\n\n\tu16 mask[ICE_MAX_FV_WORDS];\n\tDECLARE_BITMAP(ptypes, ICE_FLOW_PTYPE_MAX);\n};\n\n#define ICE_FLOW_RSS_HDRS_INNER_MASK \\\n\t(ICE_FLOW_SEG_HDR_PPPOE | ICE_FLOW_SEG_HDR_GTPC | \\\n\tICE_FLOW_SEG_HDR_GTPC_TEID | ICE_FLOW_SEG_HDR_GTPU | \\\n\tICE_FLOW_SEG_HDR_PFCP_SESSION | ICE_FLOW_SEG_HDR_L2TPV3 | \\\n\tICE_FLOW_SEG_HDR_ESP | ICE_FLOW_SEG_HDR_AH | \\\n\tICE_FLOW_SEG_HDR_NAT_T_ESP)\n\n#define ICE_FLOW_SEG_HDRS_L3_MASK\t\\\n\t(ICE_FLOW_SEG_HDR_IPV4 | ICE_FLOW_SEG_HDR_IPV6 | ICE_FLOW_SEG_HDR_ARP)\n#define ICE_FLOW_SEG_HDRS_L4_MASK\t\\\n\t(ICE_FLOW_SEG_HDR_ICMP | ICE_FLOW_SEG_HDR_TCP | ICE_FLOW_SEG_HDR_UDP | \\\n\t ICE_FLOW_SEG_HDR_SCTP)\n \n#define ICE_FLOW_SEG_HDRS_L4_MASK_NO_OTHER\t\\\n\t(ICE_FLOW_SEG_HDR_TCP | ICE_FLOW_SEG_HDR_UDP | ICE_FLOW_SEG_HDR_SCTP)\n\n \nstatic int ice_flow_val_hdrs(struct ice_flow_seg_info *segs, u8 segs_cnt)\n{\n\tu8 i;\n\n\tfor (i = 0; i < segs_cnt; i++) {\n\t\t \n\t\tif (segs[i].hdrs & ICE_FLOW_SEG_HDRS_L3_MASK &&\n\t\t    !is_power_of_2(segs[i].hdrs & ICE_FLOW_SEG_HDRS_L3_MASK))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (segs[i].hdrs & ICE_FLOW_SEG_HDRS_L4_MASK &&\n\t\t    !is_power_of_2(segs[i].hdrs & ICE_FLOW_SEG_HDRS_L4_MASK))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n#define ICE_FLOW_PROT_HDR_SZ_MAC\t14\n#define ICE_FLOW_PROT_HDR_SZ_MAC_VLAN\t(ICE_FLOW_PROT_HDR_SZ_MAC + 2)\n#define ICE_FLOW_PROT_HDR_SZ_IPV4\t20\n#define ICE_FLOW_PROT_HDR_SZ_IPV6\t40\n#define ICE_FLOW_PROT_HDR_SZ_ARP\t28\n#define ICE_FLOW_PROT_HDR_SZ_ICMP\t8\n#define ICE_FLOW_PROT_HDR_SZ_TCP\t20\n#define ICE_FLOW_PROT_HDR_SZ_UDP\t8\n#define ICE_FLOW_PROT_HDR_SZ_SCTP\t12\n\n \nstatic u16 ice_flow_calc_seg_sz(struct ice_flow_prof_params *params, u8 seg)\n{\n\tu16 sz;\n\n\t \n\tsz = (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_VLAN) ?\n\t\tICE_FLOW_PROT_HDR_SZ_MAC_VLAN : ICE_FLOW_PROT_HDR_SZ_MAC;\n\n\t \n\tif (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_IPV4)\n\t\tsz += ICE_FLOW_PROT_HDR_SZ_IPV4;\n\telse if (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_IPV6)\n\t\tsz += ICE_FLOW_PROT_HDR_SZ_IPV6;\n\telse if (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_ARP)\n\t\tsz += ICE_FLOW_PROT_HDR_SZ_ARP;\n\telse if (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDRS_L4_MASK)\n\t\t \n\t\treturn 0;\n\n\t \n\tif (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_ICMP)\n\t\tsz += ICE_FLOW_PROT_HDR_SZ_ICMP;\n\telse if (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_TCP)\n\t\tsz += ICE_FLOW_PROT_HDR_SZ_TCP;\n\telse if (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_UDP)\n\t\tsz += ICE_FLOW_PROT_HDR_SZ_UDP;\n\telse if (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_SCTP)\n\t\tsz += ICE_FLOW_PROT_HDR_SZ_SCTP;\n\n\treturn sz;\n}\n\n \nstatic int ice_flow_proc_seg_hdrs(struct ice_flow_prof_params *params)\n{\n\tstruct ice_flow_prof *prof;\n\tu8 i;\n\n\tmemset(params->ptypes, 0xff, sizeof(params->ptypes));\n\n\tprof = params->prof;\n\n\tfor (i = 0; i < params->prof->segs_cnt; i++) {\n\t\tconst unsigned long *src;\n\t\tu32 hdrs;\n\n\t\thdrs = prof->segs[i].hdrs;\n\n\t\tif (hdrs & ICE_FLOW_SEG_HDR_ETH) {\n\t\t\tsrc = !i ? (const unsigned long *)ice_ptypes_mac_ofos :\n\t\t\t\t(const unsigned long *)ice_ptypes_mac_il;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t}\n\n\t\tif (i && hdrs & ICE_FLOW_SEG_HDR_VLAN) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_macvlan_il;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t}\n\n\t\tif (!i && hdrs & ICE_FLOW_SEG_HDR_ARP) {\n\t\t\tbitmap_and(params->ptypes, params->ptypes,\n\t\t\t\t   (const unsigned long *)ice_ptypes_arp_of,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t}\n\n\t\tif ((hdrs & ICE_FLOW_SEG_HDR_IPV4) &&\n\t\t    (hdrs & ICE_FLOW_SEG_HDR_IPV_OTHER)) {\n\t\t\tsrc = i ? (const unsigned long *)ice_ptypes_ipv4_il :\n\t\t\t\t(const unsigned long *)ice_ptypes_ipv4_ofos_all;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if ((hdrs & ICE_FLOW_SEG_HDR_IPV6) &&\n\t\t\t   (hdrs & ICE_FLOW_SEG_HDR_IPV_OTHER)) {\n\t\t\tsrc = i ? (const unsigned long *)ice_ptypes_ipv6_il :\n\t\t\t\t(const unsigned long *)ice_ptypes_ipv6_ofos_all;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if ((hdrs & ICE_FLOW_SEG_HDR_IPV4) &&\n\t\t\t   !(hdrs & ICE_FLOW_SEG_HDRS_L4_MASK_NO_OTHER)) {\n\t\t\tsrc = !i ? (const unsigned long *)ice_ptypes_ipv4_ofos_no_l4 :\n\t\t\t\t(const unsigned long *)ice_ptypes_ipv4_il_no_l4;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_IPV4) {\n\t\t\tsrc = !i ? (const unsigned long *)ice_ptypes_ipv4_ofos :\n\t\t\t\t(const unsigned long *)ice_ptypes_ipv4_il;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if ((hdrs & ICE_FLOW_SEG_HDR_IPV6) &&\n\t\t\t   !(hdrs & ICE_FLOW_SEG_HDRS_L4_MASK_NO_OTHER)) {\n\t\t\tsrc = !i ? (const unsigned long *)ice_ptypes_ipv6_ofos_no_l4 :\n\t\t\t\t(const unsigned long *)ice_ptypes_ipv6_il_no_l4;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_IPV6) {\n\t\t\tsrc = !i ? (const unsigned long *)ice_ptypes_ipv6_ofos :\n\t\t\t\t(const unsigned long *)ice_ptypes_ipv6_il;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t}\n\n\t\tif (hdrs & ICE_FLOW_SEG_HDR_ETH_NON_IP) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_mac_non_ip_ofos;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_PPPOE) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_pppoe;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_pppoe;\n\t\t\tbitmap_andnot(params->ptypes, params->ptypes, src,\n\t\t\t\t      ICE_FLOW_PTYPE_MAX);\n\t\t}\n\n\t\tif (hdrs & ICE_FLOW_SEG_HDR_UDP) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_udp_il;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_TCP) {\n\t\t\tbitmap_and(params->ptypes, params->ptypes,\n\t\t\t\t   (const unsigned long *)ice_ptypes_tcp_il,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_SCTP) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_sctp_il;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t}\n\n\t\tif (hdrs & ICE_FLOW_SEG_HDR_ICMP) {\n\t\t\tsrc = !i ? (const unsigned long *)ice_ptypes_icmp_of :\n\t\t\t\t(const unsigned long *)ice_ptypes_icmp_il;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_GRE) {\n\t\t\tif (!i) {\n\t\t\t\tsrc = (const unsigned long *)ice_ptypes_gre_of;\n\t\t\t\tbitmap_and(params->ptypes, params->ptypes,\n\t\t\t\t\t   src, ICE_FLOW_PTYPE_MAX);\n\t\t\t}\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_GTPC) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_gtpc;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_GTPC_TEID) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_gtpc_tid;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_GTPU_DWN) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_gtpu;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\n\t\t\t \n\t\t\tparams->attr = ice_attr_gtpu_down;\n\t\t\tparams->attr_cnt = ARRAY_SIZE(ice_attr_gtpu_down);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_GTPU_UP) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_gtpu;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\n\t\t\t \n\t\t\tparams->attr = ice_attr_gtpu_up;\n\t\t\tparams->attr_cnt = ARRAY_SIZE(ice_attr_gtpu_up);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_GTPU_EH) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_gtpu;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\n\t\t\t \n\t\t\tparams->attr = ice_attr_gtpu_eh;\n\t\t\tparams->attr_cnt = ARRAY_SIZE(ice_attr_gtpu_eh);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_GTPU_IP) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_gtpu;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_L2TPV3) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_l2tpv3;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_ESP) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_esp;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_AH) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_ah;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else if (hdrs & ICE_FLOW_SEG_HDR_NAT_T_ESP) {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_nat_t_esp;\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t}\n\n\t\tif (hdrs & ICE_FLOW_SEG_HDR_PFCP) {\n\t\t\tif (hdrs & ICE_FLOW_SEG_HDR_PFCP_NODE)\n\t\t\t\tsrc = (const unsigned long *)ice_ptypes_pfcp_node;\n\t\t\telse\n\t\t\t\tsrc = (const unsigned long *)ice_ptypes_pfcp_session;\n\n\t\t\tbitmap_and(params->ptypes, params->ptypes, src,\n\t\t\t\t   ICE_FLOW_PTYPE_MAX);\n\t\t} else {\n\t\t\tsrc = (const unsigned long *)ice_ptypes_pfcp_node;\n\t\t\tbitmap_andnot(params->ptypes, params->ptypes, src,\n\t\t\t\t      ICE_FLOW_PTYPE_MAX);\n\n\t\t\tsrc = (const unsigned long *)ice_ptypes_pfcp_session;\n\t\t\tbitmap_andnot(params->ptypes, params->ptypes, src,\n\t\t\t\t      ICE_FLOW_PTYPE_MAX);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_flow_xtract_fld(struct ice_hw *hw, struct ice_flow_prof_params *params,\n\t\t    u8 seg, enum ice_flow_field fld, u64 match)\n{\n\tenum ice_flow_field sib = ICE_FLOW_FIELD_IDX_MAX;\n\tenum ice_prot_id prot_id = ICE_PROT_ID_INVAL;\n\tu8 fv_words = hw->blk[params->blk].es.fvw;\n\tstruct ice_flow_fld_info *flds;\n\tu16 cnt, ese_bits, i;\n\tu16 sib_mask = 0;\n\tu16 mask;\n\tu16 off;\n\n\tflds = params->prof->segs[seg].fields;\n\n\tswitch (fld) {\n\tcase ICE_FLOW_FIELD_IDX_ETH_DA:\n\tcase ICE_FLOW_FIELD_IDX_ETH_SA:\n\tcase ICE_FLOW_FIELD_IDX_S_VLAN:\n\tcase ICE_FLOW_FIELD_IDX_C_VLAN:\n\t\tprot_id = seg == 0 ? ICE_PROT_MAC_OF_OR_S : ICE_PROT_MAC_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_ETH_TYPE:\n\t\tprot_id = seg == 0 ? ICE_PROT_ETYPE_OL : ICE_PROT_ETYPE_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_IPV4_DSCP:\n\t\tprot_id = seg == 0 ? ICE_PROT_IPV4_OF_OR_S : ICE_PROT_IPV4_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_IPV6_DSCP:\n\t\tprot_id = seg == 0 ? ICE_PROT_IPV6_OF_OR_S : ICE_PROT_IPV6_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_IPV4_TTL:\n\tcase ICE_FLOW_FIELD_IDX_IPV4_PROT:\n\t\tprot_id = seg == 0 ? ICE_PROT_IPV4_OF_OR_S : ICE_PROT_IPV4_IL;\n\n\t\t \n\t\tif (fld == ICE_FLOW_FIELD_IDX_IPV4_TTL)\n\t\t\tsib = ICE_FLOW_FIELD_IDX_IPV4_PROT;\n\t\telse if (fld == ICE_FLOW_FIELD_IDX_IPV4_PROT)\n\t\t\tsib = ICE_FLOW_FIELD_IDX_IPV4_TTL;\n\n\t\t \n\t\tif (match & BIT(sib))\n\t\t\tsib_mask = ice_flds_info[sib].mask;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_IPV6_TTL:\n\tcase ICE_FLOW_FIELD_IDX_IPV6_PROT:\n\t\tprot_id = seg == 0 ? ICE_PROT_IPV6_OF_OR_S : ICE_PROT_IPV6_IL;\n\n\t\t \n\t\tif (fld == ICE_FLOW_FIELD_IDX_IPV6_TTL)\n\t\t\tsib = ICE_FLOW_FIELD_IDX_IPV6_PROT;\n\t\telse if (fld == ICE_FLOW_FIELD_IDX_IPV6_PROT)\n\t\t\tsib = ICE_FLOW_FIELD_IDX_IPV6_TTL;\n\n\t\t \n\t\tif (match & BIT(sib))\n\t\t\tsib_mask = ice_flds_info[sib].mask;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_IPV4_SA:\n\tcase ICE_FLOW_FIELD_IDX_IPV4_DA:\n\t\tprot_id = seg == 0 ? ICE_PROT_IPV4_OF_OR_S : ICE_PROT_IPV4_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_IPV6_SA:\n\tcase ICE_FLOW_FIELD_IDX_IPV6_DA:\n\t\tprot_id = seg == 0 ? ICE_PROT_IPV6_OF_OR_S : ICE_PROT_IPV6_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_TCP_SRC_PORT:\n\tcase ICE_FLOW_FIELD_IDX_TCP_DST_PORT:\n\tcase ICE_FLOW_FIELD_IDX_TCP_FLAGS:\n\t\tprot_id = ICE_PROT_TCP_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_UDP_SRC_PORT:\n\tcase ICE_FLOW_FIELD_IDX_UDP_DST_PORT:\n\t\tprot_id = ICE_PROT_UDP_IL_OR_S;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_SCTP_SRC_PORT:\n\tcase ICE_FLOW_FIELD_IDX_SCTP_DST_PORT:\n\t\tprot_id = ICE_PROT_SCTP_IL;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_GTPC_TEID:\n\tcase ICE_FLOW_FIELD_IDX_GTPU_IP_TEID:\n\tcase ICE_FLOW_FIELD_IDX_GTPU_UP_TEID:\n\tcase ICE_FLOW_FIELD_IDX_GTPU_DWN_TEID:\n\tcase ICE_FLOW_FIELD_IDX_GTPU_EH_TEID:\n\tcase ICE_FLOW_FIELD_IDX_GTPU_EH_QFI:\n\t\t \n\t\tprot_id = ICE_PROT_UDP_OF;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_PPPOE_SESS_ID:\n\t\tprot_id = ICE_PROT_PPPOE;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_PFCP_SEID:\n\t\tprot_id = ICE_PROT_UDP_IL_OR_S;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_L2TPV3_SESS_ID:\n\t\tprot_id = ICE_PROT_L2TPV3;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_ESP_SPI:\n\t\tprot_id = ICE_PROT_ESP_F;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_AH_SPI:\n\t\tprot_id = ICE_PROT_ESP_2;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_NAT_T_ESP_SPI:\n\t\tprot_id = ICE_PROT_UDP_IL_OR_S;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_ARP_SIP:\n\tcase ICE_FLOW_FIELD_IDX_ARP_DIP:\n\tcase ICE_FLOW_FIELD_IDX_ARP_SHA:\n\tcase ICE_FLOW_FIELD_IDX_ARP_DHA:\n\tcase ICE_FLOW_FIELD_IDX_ARP_OP:\n\t\tprot_id = ICE_PROT_ARP_OF;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_ICMP_TYPE:\n\tcase ICE_FLOW_FIELD_IDX_ICMP_CODE:\n\t\t \n\t\tprot_id = (params->prof->segs[seg].hdrs & ICE_FLOW_SEG_HDR_IPV4) ?\n\t\t\t\tICE_PROT_ICMP_IL : ICE_PROT_ICMPV6_IL;\n\t\tsib = fld == ICE_FLOW_FIELD_IDX_ICMP_TYPE ?\n\t\t\tICE_FLOW_FIELD_IDX_ICMP_CODE :\n\t\t\tICE_FLOW_FIELD_IDX_ICMP_TYPE;\n\t\tbreak;\n\tcase ICE_FLOW_FIELD_IDX_GRE_KEYID:\n\t\tprot_id = ICE_PROT_GRE_OF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tese_bits = ICE_FLOW_FV_EXTRACT_SZ * BITS_PER_BYTE;\n\n\tflds[fld].xtrct.prot_id = prot_id;\n\tflds[fld].xtrct.off = (ice_flds_info[fld].off / ese_bits) *\n\t\tICE_FLOW_FV_EXTRACT_SZ;\n\tflds[fld].xtrct.disp = (u8)(ice_flds_info[fld].off % ese_bits);\n\tflds[fld].xtrct.idx = params->es_cnt;\n\tflds[fld].xtrct.mask = ice_flds_info[fld].mask;\n\n\t \n\tcnt = DIV_ROUND_UP(flds[fld].xtrct.disp + ice_flds_info[fld].size,\n\t\t\t   ese_bits);\n\n\t \n\toff = flds[fld].xtrct.off;\n\tmask = flds[fld].xtrct.mask;\n\tfor (i = 0; i < cnt; i++) {\n\t\t \n\t\tif (sib == ICE_FLOW_FIELD_IDX_MAX ||\n\t\t    flds[sib].xtrct.prot_id == ICE_PROT_ID_INVAL ||\n\t\t    flds[sib].xtrct.off != off) {\n\t\t\tu8 idx;\n\n\t\t\t \n\t\t\tif (params->es_cnt >= fv_words)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\t \n\t\t\tif (hw->blk[params->blk].es.reverse)\n\t\t\t\tidx = fv_words - params->es_cnt - 1;\n\t\t\telse\n\t\t\t\tidx = params->es_cnt;\n\n\t\t\tparams->es[idx].prot_id = prot_id;\n\t\t\tparams->es[idx].off = off;\n\t\t\tparams->mask[idx] = mask | sib_mask;\n\t\t\tparams->es_cnt++;\n\t\t}\n\n\t\toff += ICE_FLOW_FV_EXTRACT_SZ;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_flow_xtract_raws(struct ice_hw *hw, struct ice_flow_prof_params *params,\n\t\t     u8 seg)\n{\n\tu16 fv_words;\n\tu16 hdrs_sz;\n\tu8 i;\n\n\tif (!params->prof->segs[seg].raws_cnt)\n\t\treturn 0;\n\n\tif (params->prof->segs[seg].raws_cnt >\n\t    ARRAY_SIZE(params->prof->segs[seg].raws))\n\t\treturn -ENOSPC;\n\n\t \n\thdrs_sz = ice_flow_calc_seg_sz(params, seg);\n\tif (!hdrs_sz)\n\t\treturn -EINVAL;\n\n\tfv_words = hw->blk[params->blk].es.fvw;\n\n\tfor (i = 0; i < params->prof->segs[seg].raws_cnt; i++) {\n\t\tstruct ice_flow_seg_fld_raw *raw;\n\t\tu16 off, cnt, j;\n\n\t\traw = &params->prof->segs[seg].raws[i];\n\n\t\t \n\t\traw->info.xtrct.prot_id = ICE_PROT_MAC_OF_OR_S;\n\t\traw->info.xtrct.off = (raw->off / ICE_FLOW_FV_EXTRACT_SZ) *\n\t\t\tICE_FLOW_FV_EXTRACT_SZ;\n\t\traw->info.xtrct.disp = (raw->off % ICE_FLOW_FV_EXTRACT_SZ) *\n\t\t\tBITS_PER_BYTE;\n\t\traw->info.xtrct.idx = params->es_cnt;\n\n\t\t \n\t\tcnt = DIV_ROUND_UP(raw->info.xtrct.disp +\n\t\t\t\t   (raw->info.src.last * BITS_PER_BYTE),\n\t\t\t\t   (ICE_FLOW_FV_EXTRACT_SZ * BITS_PER_BYTE));\n\t\toff = raw->info.xtrct.off;\n\t\tfor (j = 0; j < cnt; j++) {\n\t\t\tu16 idx;\n\n\t\t\t \n\t\t\tif (params->es_cnt >= hw->blk[params->blk].es.count ||\n\t\t\t    params->es_cnt >= ICE_MAX_FV_WORDS)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\t \n\t\t\tif (hw->blk[params->blk].es.reverse)\n\t\t\t\tidx = fv_words - params->es_cnt - 1;\n\t\t\telse\n\t\t\t\tidx = params->es_cnt;\n\n\t\t\tparams->es[idx].prot_id = raw->info.xtrct.prot_id;\n\t\t\tparams->es[idx].off = off;\n\t\t\tparams->es_cnt++;\n\t\t\toff += ICE_FLOW_FV_EXTRACT_SZ;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_flow_create_xtrct_seq(struct ice_hw *hw,\n\t\t\t  struct ice_flow_prof_params *params)\n{\n\tstruct ice_flow_prof *prof = params->prof;\n\tint status = 0;\n\tu8 i;\n\n\tfor (i = 0; i < prof->segs_cnt; i++) {\n\t\tu64 match = params->prof->segs[i].match;\n\t\tenum ice_flow_field j;\n\n\t\tfor_each_set_bit(j, (unsigned long *)&match,\n\t\t\t\t ICE_FLOW_FIELD_IDX_MAX) {\n\t\t\tstatus = ice_flow_xtract_fld(hw, params, i, j, match);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tclear_bit(j, (unsigned long *)&match);\n\t\t}\n\n\t\t \n\t\tstatus = ice_flow_xtract_raws(hw, params, i);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_flow_proc_segs(struct ice_hw *hw, struct ice_flow_prof_params *params)\n{\n\tint status;\n\n\tstatus = ice_flow_proc_seg_hdrs(params);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ice_flow_create_xtrct_seq(hw, params);\n\tif (status)\n\t\treturn status;\n\n\tswitch (params->blk) {\n\tcase ICE_BLK_FD:\n\tcase ICE_BLK_RSS:\n\t\tstatus = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn status;\n}\n\n#define ICE_FLOW_FIND_PROF_CHK_FLDS\t0x00000001\n#define ICE_FLOW_FIND_PROF_CHK_VSI\t0x00000002\n#define ICE_FLOW_FIND_PROF_NOT_CHK_DIR\t0x00000004\n\n \nstatic struct ice_flow_prof *\nice_flow_find_prof_conds(struct ice_hw *hw, enum ice_block blk,\n\t\t\t enum ice_flow_dir dir, struct ice_flow_seg_info *segs,\n\t\t\t u8 segs_cnt, u16 vsi_handle, u32 conds)\n{\n\tstruct ice_flow_prof *p, *prof = NULL;\n\n\tmutex_lock(&hw->fl_profs_locks[blk]);\n\tlist_for_each_entry(p, &hw->fl_profs[blk], l_entry)\n\t\tif ((p->dir == dir || conds & ICE_FLOW_FIND_PROF_NOT_CHK_DIR) &&\n\t\t    segs_cnt && segs_cnt == p->segs_cnt) {\n\t\t\tu8 i;\n\n\t\t\t \n\t\t\tif ((conds & ICE_FLOW_FIND_PROF_CHK_VSI) &&\n\t\t\t    ice_is_vsi_valid(hw, vsi_handle) &&\n\t\t\t    !test_bit(vsi_handle, p->vsis))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfor (i = 0; i < segs_cnt; i++)\n\t\t\t\tif (segs[i].hdrs != p->segs[i].hdrs ||\n\t\t\t\t    ((conds & ICE_FLOW_FIND_PROF_CHK_FLDS) &&\n\t\t\t\t     segs[i].match != p->segs[i].match))\n\t\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (i == segs_cnt) {\n\t\t\t\tprof = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tmutex_unlock(&hw->fl_profs_locks[blk]);\n\n\treturn prof;\n}\n\n \nstatic struct ice_flow_prof *\nice_flow_find_prof_id(struct ice_hw *hw, enum ice_block blk, u64 prof_id)\n{\n\tstruct ice_flow_prof *p;\n\n\tlist_for_each_entry(p, &hw->fl_profs[blk], l_entry)\n\t\tif (p->id == prof_id)\n\t\t\treturn p;\n\n\treturn NULL;\n}\n\n \nstatic int\nice_flow_rem_entry_sync(struct ice_hw *hw, enum ice_block __always_unused blk,\n\t\t\tstruct ice_flow_entry *entry)\n{\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tlist_del(&entry->l_entry);\n\n\tdevm_kfree(ice_hw_to_dev(hw), entry->entry);\n\tdevm_kfree(ice_hw_to_dev(hw), entry);\n\n\treturn 0;\n}\n\n \nstatic int\nice_flow_add_prof_sync(struct ice_hw *hw, enum ice_block blk,\n\t\t       enum ice_flow_dir dir, u64 prof_id,\n\t\t       struct ice_flow_seg_info *segs, u8 segs_cnt,\n\t\t       struct ice_flow_prof **prof)\n{\n\tstruct ice_flow_prof_params *params;\n\tint status;\n\tu8 i;\n\n\tif (!prof)\n\t\treturn -EINVAL;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tparams->prof = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*params->prof),\n\t\t\t\t    GFP_KERNEL);\n\tif (!params->prof) {\n\t\tstatus = -ENOMEM;\n\t\tgoto free_params;\n\t}\n\n\t \n\tfor (i = 0; i < ICE_MAX_FV_WORDS; i++) {\n\t\tparams->es[i].prot_id = ICE_PROT_INVALID;\n\t\tparams->es[i].off = ICE_FV_OFFSET_INVAL;\n\t}\n\n\tparams->blk = blk;\n\tparams->prof->id = prof_id;\n\tparams->prof->dir = dir;\n\tparams->prof->segs_cnt = segs_cnt;\n\n\t \n\tfor (i = 0; i < segs_cnt; i++)\n\t\tmemcpy(&params->prof->segs[i], &segs[i], sizeof(*segs));\n\n\tstatus = ice_flow_proc_segs(hw, params);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_FLOW, \"Error processing a flow's packet segments\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = ice_add_prof(hw, blk, prof_id, (u8 *)params->ptypes,\n\t\t\t      params->attr, params->attr_cnt, params->es,\n\t\t\t      params->mask);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_FLOW, \"Error adding a HW flow profile\\n\");\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&params->prof->entries);\n\tmutex_init(&params->prof->entries_lock);\n\t*prof = params->prof;\n\nout:\n\tif (status)\n\t\tdevm_kfree(ice_hw_to_dev(hw), params->prof);\nfree_params:\n\tkfree(params);\n\n\treturn status;\n}\n\n \nstatic int\nice_flow_rem_prof_sync(struct ice_hw *hw, enum ice_block blk,\n\t\t       struct ice_flow_prof *prof)\n{\n\tint status;\n\n\t \n\tif (!list_empty(&prof->entries)) {\n\t\tstruct ice_flow_entry *e, *t;\n\n\t\tmutex_lock(&prof->entries_lock);\n\n\t\tlist_for_each_entry_safe(e, t, &prof->entries, l_entry) {\n\t\t\tstatus = ice_flow_rem_entry_sync(hw, blk, e);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&prof->entries_lock);\n\t}\n\n\t \n\tstatus = ice_rem_prof(hw, blk, prof->id);\n\tif (!status) {\n\t\tlist_del(&prof->l_entry);\n\t\tmutex_destroy(&prof->entries_lock);\n\t\tdevm_kfree(ice_hw_to_dev(hw), prof);\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_flow_assoc_prof(struct ice_hw *hw, enum ice_block blk,\n\t\t    struct ice_flow_prof *prof, u16 vsi_handle)\n{\n\tint status = 0;\n\n\tif (!test_bit(vsi_handle, prof->vsis)) {\n\t\tstatus = ice_add_prof_id_flow(hw, blk,\n\t\t\t\t\t      ice_get_hw_vsi_num(hw,\n\t\t\t\t\t\t\t\t vsi_handle),\n\t\t\t\t\t      prof->id);\n\t\tif (!status)\n\t\t\tset_bit(vsi_handle, prof->vsis);\n\t\telse\n\t\t\tice_debug(hw, ICE_DBG_FLOW, \"HW profile add failed, %d\\n\",\n\t\t\t\t  status);\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_flow_disassoc_prof(struct ice_hw *hw, enum ice_block blk,\n\t\t       struct ice_flow_prof *prof, u16 vsi_handle)\n{\n\tint status = 0;\n\n\tif (test_bit(vsi_handle, prof->vsis)) {\n\t\tstatus = ice_rem_prof_id_flow(hw, blk,\n\t\t\t\t\t      ice_get_hw_vsi_num(hw,\n\t\t\t\t\t\t\t\t vsi_handle),\n\t\t\t\t\t      prof->id);\n\t\tif (!status)\n\t\t\tclear_bit(vsi_handle, prof->vsis);\n\t\telse\n\t\t\tice_debug(hw, ICE_DBG_FLOW, \"HW profile remove failed, %d\\n\",\n\t\t\t\t  status);\n\t}\n\n\treturn status;\n}\n\n \nint\nice_flow_add_prof(struct ice_hw *hw, enum ice_block blk, enum ice_flow_dir dir,\n\t\t  u64 prof_id, struct ice_flow_seg_info *segs, u8 segs_cnt,\n\t\t  struct ice_flow_prof **prof)\n{\n\tint status;\n\n\tif (segs_cnt > ICE_FLOW_SEG_MAX)\n\t\treturn -ENOSPC;\n\n\tif (!segs_cnt)\n\t\treturn -EINVAL;\n\n\tif (!segs)\n\t\treturn -EINVAL;\n\n\tstatus = ice_flow_val_hdrs(segs, segs_cnt);\n\tif (status)\n\t\treturn status;\n\n\tmutex_lock(&hw->fl_profs_locks[blk]);\n\n\tstatus = ice_flow_add_prof_sync(hw, blk, dir, prof_id, segs, segs_cnt,\n\t\t\t\t\tprof);\n\tif (!status)\n\t\tlist_add(&(*prof)->l_entry, &hw->fl_profs[blk]);\n\n\tmutex_unlock(&hw->fl_profs_locks[blk]);\n\n\treturn status;\n}\n\n \nint ice_flow_rem_prof(struct ice_hw *hw, enum ice_block blk, u64 prof_id)\n{\n\tstruct ice_flow_prof *prof;\n\tint status;\n\n\tmutex_lock(&hw->fl_profs_locks[blk]);\n\n\tprof = ice_flow_find_prof_id(hw, blk, prof_id);\n\tif (!prof) {\n\t\tstatus = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = ice_flow_rem_prof_sync(hw, blk, prof);\n\nout:\n\tmutex_unlock(&hw->fl_profs_locks[blk]);\n\n\treturn status;\n}\n\n \nint\nice_flow_add_entry(struct ice_hw *hw, enum ice_block blk, u64 prof_id,\n\t\t   u64 entry_id, u16 vsi_handle, enum ice_flow_priority prio,\n\t\t   void *data, u64 *entry_h)\n{\n\tstruct ice_flow_entry *e = NULL;\n\tstruct ice_flow_prof *prof;\n\tint status;\n\n\t \n\tif (!entry_h || (!data && blk != ICE_BLK_RSS))\n\t\treturn -EINVAL;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hw->fl_profs_locks[blk]);\n\n\tprof = ice_flow_find_prof_id(hw, blk, prof_id);\n\tif (!prof) {\n\t\tstatus = -ENOENT;\n\t} else {\n\t\t \n\t\te = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*e), GFP_KERNEL);\n\t\tif (!e)\n\t\t\tstatus = -ENOMEM;\n\t\telse\n\t\t\tstatus = ice_flow_assoc_prof(hw, blk, prof, vsi_handle);\n\t}\n\n\tmutex_unlock(&hw->fl_profs_locks[blk]);\n\tif (status)\n\t\tgoto out;\n\n\te->id = entry_id;\n\te->vsi_handle = vsi_handle;\n\te->prof = prof;\n\te->priority = prio;\n\n\tswitch (blk) {\n\tcase ICE_BLK_FD:\n\tcase ICE_BLK_RSS:\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&prof->entries_lock);\n\tlist_add(&e->l_entry, &prof->entries);\n\tmutex_unlock(&prof->entries_lock);\n\n\t*entry_h = ICE_FLOW_ENTRY_HNDL(e);\n\nout:\n\tif (status && e) {\n\t\tdevm_kfree(ice_hw_to_dev(hw), e->entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), e);\n\t}\n\n\treturn status;\n}\n\n \nint ice_flow_rem_entry(struct ice_hw *hw, enum ice_block blk, u64 entry_h)\n{\n\tstruct ice_flow_entry *entry;\n\tstruct ice_flow_prof *prof;\n\tint status = 0;\n\n\tif (entry_h == ICE_FLOW_ENTRY_HANDLE_INVAL)\n\t\treturn -EINVAL;\n\n\tentry = ICE_FLOW_ENTRY_PTR(entry_h);\n\n\t \n\tprof = entry->prof;\n\n\tif (prof) {\n\t\tmutex_lock(&prof->entries_lock);\n\t\tstatus = ice_flow_rem_entry_sync(hw, blk, entry);\n\t\tmutex_unlock(&prof->entries_lock);\n\t}\n\n\treturn status;\n}\n\n \nstatic void\nice_flow_set_fld_ext(struct ice_flow_seg_info *seg, enum ice_flow_field fld,\n\t\t     enum ice_flow_fld_match_type field_type, u16 val_loc,\n\t\t     u16 mask_loc, u16 last_loc)\n{\n\tu64 bit = BIT_ULL(fld);\n\n\tseg->match |= bit;\n\tif (field_type == ICE_FLOW_FLD_TYPE_RANGE)\n\t\tseg->range |= bit;\n\n\tseg->fields[fld].type = field_type;\n\tseg->fields[fld].src.val = val_loc;\n\tseg->fields[fld].src.mask = mask_loc;\n\tseg->fields[fld].src.last = last_loc;\n\n\tICE_FLOW_SET_HDRS(seg, ice_flds_info[fld].hdr);\n}\n\n \nvoid\nice_flow_set_fld(struct ice_flow_seg_info *seg, enum ice_flow_field fld,\n\t\t u16 val_loc, u16 mask_loc, u16 last_loc, bool range)\n{\n\tenum ice_flow_fld_match_type t = range ?\n\t\tICE_FLOW_FLD_TYPE_RANGE : ICE_FLOW_FLD_TYPE_REG;\n\n\tice_flow_set_fld_ext(seg, fld, t, val_loc, mask_loc, last_loc);\n}\n\n \nvoid\nice_flow_add_fld_raw(struct ice_flow_seg_info *seg, u16 off, u8 len,\n\t\t     u16 val_loc, u16 mask_loc)\n{\n\tif (seg->raws_cnt < ICE_FLOW_SEG_RAW_FLD_MAX) {\n\t\tseg->raws[seg->raws_cnt].off = off;\n\t\tseg->raws[seg->raws_cnt].info.type = ICE_FLOW_FLD_TYPE_SIZE;\n\t\tseg->raws[seg->raws_cnt].info.src.val = val_loc;\n\t\tseg->raws[seg->raws_cnt].info.src.mask = mask_loc;\n\t\t \n\t\tseg->raws[seg->raws_cnt].info.src.last = len;\n\t}\n\n\t \n\tseg->raws_cnt++;\n}\n\n \nint ice_flow_rem_vsi_prof(struct ice_hw *hw, u16 vsi_handle, u64 prof_id)\n{\n\tstruct ice_flow_prof *prof;\n\tint status = 0;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\t \n\tprof = ice_flow_find_prof_id(hw, ICE_BLK_FD, prof_id);\n\tif (!prof) {\n\t\tice_debug(hw, ICE_DBG_PKG, \"Cannot find flow profile id=%llu\\n\",\n\t\t\t  prof_id);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (!list_empty(&prof->entries)) {\n\t\tstruct ice_flow_entry *e, *t;\n\n\t\tmutex_lock(&prof->entries_lock);\n\t\tlist_for_each_entry_safe(e, t, &prof->entries, l_entry) {\n\t\t\tif (e->vsi_handle != vsi_handle)\n\t\t\t\tcontinue;\n\n\t\t\tstatus = ice_flow_rem_entry_sync(hw, ICE_BLK_FD, e);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&prof->entries_lock);\n\t}\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ice_flow_disassoc_prof(hw, ICE_BLK_FD, prof, vsi_handle);\n\tif (status)\n\t\tice_debug(hw, ICE_DBG_PKG, \"ice_flow_disassoc_prof() failed with status=%d\\n\",\n\t\t\t  status);\n\treturn status;\n}\n\n#define ICE_FLOW_RSS_SEG_HDR_L2_MASKS \\\n\t(ICE_FLOW_SEG_HDR_ETH | ICE_FLOW_SEG_HDR_VLAN)\n\n#define ICE_FLOW_RSS_SEG_HDR_L3_MASKS \\\n\t(ICE_FLOW_SEG_HDR_IPV4 | ICE_FLOW_SEG_HDR_IPV6)\n\n#define ICE_FLOW_RSS_SEG_HDR_L4_MASKS \\\n\t(ICE_FLOW_SEG_HDR_TCP | ICE_FLOW_SEG_HDR_UDP | ICE_FLOW_SEG_HDR_SCTP)\n\n#define ICE_FLOW_RSS_SEG_HDR_VAL_MASKS \\\n\t(ICE_FLOW_RSS_SEG_HDR_L2_MASKS | \\\n\t ICE_FLOW_RSS_SEG_HDR_L3_MASKS | \\\n\t ICE_FLOW_RSS_SEG_HDR_L4_MASKS)\n\n \nstatic int\nice_flow_set_rss_seg_info(struct ice_flow_seg_info *segs, u64 hash_fields,\n\t\t\t  u32 flow_hdr)\n{\n\tu64 val;\n\tu8 i;\n\n\tfor_each_set_bit(i, (unsigned long *)&hash_fields,\n\t\t\t ICE_FLOW_FIELD_IDX_MAX)\n\t\tice_flow_set_fld(segs, (enum ice_flow_field)i,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\n\tICE_FLOW_SET_HDRS(segs, flow_hdr);\n\n\tif (segs->hdrs & ~ICE_FLOW_RSS_SEG_HDR_VAL_MASKS &\n\t    ~ICE_FLOW_RSS_HDRS_INNER_MASK & ~ICE_FLOW_SEG_HDR_IPV_OTHER)\n\t\treturn -EINVAL;\n\n\tval = (u64)(segs->hdrs & ICE_FLOW_RSS_SEG_HDR_L3_MASKS);\n\tif (val && !is_power_of_2(val))\n\t\treturn -EIO;\n\n\tval = (u64)(segs->hdrs & ICE_FLOW_RSS_SEG_HDR_L4_MASKS);\n\tif (val && !is_power_of_2(val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nvoid ice_rem_vsi_rss_list(struct ice_hw *hw, u16 vsi_handle)\n{\n\tstruct ice_rss_cfg *r, *tmp;\n\n\tif (list_empty(&hw->rss_list_head))\n\t\treturn;\n\n\tmutex_lock(&hw->rss_locks);\n\tlist_for_each_entry_safe(r, tmp, &hw->rss_list_head, l_entry)\n\t\tif (test_and_clear_bit(vsi_handle, r->vsis))\n\t\t\tif (bitmap_empty(r->vsis, ICE_MAX_VSI)) {\n\t\t\t\tlist_del(&r->l_entry);\n\t\t\t\tdevm_kfree(ice_hw_to_dev(hw), r);\n\t\t\t}\n\tmutex_unlock(&hw->rss_locks);\n}\n\n \nint ice_rem_vsi_rss_cfg(struct ice_hw *hw, u16 vsi_handle)\n{\n\tconst enum ice_block blk = ICE_BLK_RSS;\n\tstruct ice_flow_prof *p, *t;\n\tint status = 0;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\tif (list_empty(&hw->fl_profs[blk]))\n\t\treturn 0;\n\n\tmutex_lock(&hw->rss_locks);\n\tlist_for_each_entry_safe(p, t, &hw->fl_profs[blk], l_entry)\n\t\tif (test_bit(vsi_handle, p->vsis)) {\n\t\t\tstatus = ice_flow_disassoc_prof(hw, blk, p, vsi_handle);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\n\t\t\tif (bitmap_empty(p->vsis, ICE_MAX_VSI)) {\n\t\t\t\tstatus = ice_flow_rem_prof(hw, blk, p->id);\n\t\t\t\tif (status)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tmutex_unlock(&hw->rss_locks);\n\n\treturn status;\n}\n\n \nstatic void\nice_rem_rss_list(struct ice_hw *hw, u16 vsi_handle, struct ice_flow_prof *prof)\n{\n\tstruct ice_rss_cfg *r, *tmp;\n\n\t \n\tlist_for_each_entry_safe(r, tmp, &hw->rss_list_head, l_entry)\n\t\tif (r->hashed_flds == prof->segs[prof->segs_cnt - 1].match &&\n\t\t    r->packet_hdr == prof->segs[prof->segs_cnt - 1].hdrs) {\n\t\t\tclear_bit(vsi_handle, r->vsis);\n\t\t\tif (bitmap_empty(r->vsis, ICE_MAX_VSI)) {\n\t\t\t\tlist_del(&r->l_entry);\n\t\t\t\tdevm_kfree(ice_hw_to_dev(hw), r);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n}\n\n \nstatic int\nice_add_rss_list(struct ice_hw *hw, u16 vsi_handle, struct ice_flow_prof *prof)\n{\n\tstruct ice_rss_cfg *r, *rss_cfg;\n\n\tlist_for_each_entry(r, &hw->rss_list_head, l_entry)\n\t\tif (r->hashed_flds == prof->segs[prof->segs_cnt - 1].match &&\n\t\t    r->packet_hdr == prof->segs[prof->segs_cnt - 1].hdrs) {\n\t\t\tset_bit(vsi_handle, r->vsis);\n\t\t\treturn 0;\n\t\t}\n\n\trss_cfg = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*rss_cfg),\n\t\t\t       GFP_KERNEL);\n\tif (!rss_cfg)\n\t\treturn -ENOMEM;\n\n\trss_cfg->hashed_flds = prof->segs[prof->segs_cnt - 1].match;\n\trss_cfg->packet_hdr = prof->segs[prof->segs_cnt - 1].hdrs;\n\tset_bit(vsi_handle, rss_cfg->vsis);\n\n\tlist_add_tail(&rss_cfg->l_entry, &hw->rss_list_head);\n\n\treturn 0;\n}\n\n#define ICE_FLOW_PROF_HASH_S\t0\n#define ICE_FLOW_PROF_HASH_M\t(0xFFFFFFFFULL << ICE_FLOW_PROF_HASH_S)\n#define ICE_FLOW_PROF_HDR_S\t32\n#define ICE_FLOW_PROF_HDR_M\t(0x3FFFFFFFULL << ICE_FLOW_PROF_HDR_S)\n#define ICE_FLOW_PROF_ENCAP_S\t63\n#define ICE_FLOW_PROF_ENCAP_M\t(BIT_ULL(ICE_FLOW_PROF_ENCAP_S))\n\n#define ICE_RSS_OUTER_HEADERS\t1\n#define ICE_RSS_INNER_HEADERS\t2\n\n \n#define ICE_FLOW_GEN_PROFID(hash, hdr, segs_cnt) \\\n\t((u64)(((u64)(hash) & ICE_FLOW_PROF_HASH_M) | \\\n\t       (((u64)(hdr) << ICE_FLOW_PROF_HDR_S) & ICE_FLOW_PROF_HDR_M) | \\\n\t       ((u8)((segs_cnt) - 1) ? ICE_FLOW_PROF_ENCAP_M : 0)))\n\n \nstatic int\nice_add_rss_cfg_sync(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds,\n\t\t     u32 addl_hdrs, u8 segs_cnt)\n{\n\tconst enum ice_block blk = ICE_BLK_RSS;\n\tstruct ice_flow_prof *prof = NULL;\n\tstruct ice_flow_seg_info *segs;\n\tint status;\n\n\tif (!segs_cnt || segs_cnt > ICE_FLOW_SEG_MAX)\n\t\treturn -EINVAL;\n\n\tsegs = kcalloc(segs_cnt, sizeof(*segs), GFP_KERNEL);\n\tif (!segs)\n\t\treturn -ENOMEM;\n\n\t \n\tstatus = ice_flow_set_rss_seg_info(&segs[segs_cnt - 1], hashed_flds,\n\t\t\t\t\t   addl_hdrs);\n\tif (status)\n\t\tgoto exit;\n\n\t \n\tprof = ice_flow_find_prof_conds(hw, blk, ICE_FLOW_RX, segs, segs_cnt,\n\t\t\t\t\tvsi_handle,\n\t\t\t\t\tICE_FLOW_FIND_PROF_CHK_FLDS |\n\t\t\t\t\tICE_FLOW_FIND_PROF_CHK_VSI);\n\tif (prof)\n\t\tgoto exit;\n\n\t \n\tprof = ice_flow_find_prof_conds(hw, blk, ICE_FLOW_RX, segs, segs_cnt,\n\t\t\t\t\tvsi_handle, ICE_FLOW_FIND_PROF_CHK_VSI);\n\tif (prof) {\n\t\tstatus = ice_flow_disassoc_prof(hw, blk, prof, vsi_handle);\n\t\tif (!status)\n\t\t\tice_rem_rss_list(hw, vsi_handle, prof);\n\t\telse\n\t\t\tgoto exit;\n\n\t\t \n\t\tif (bitmap_empty(prof->vsis, ICE_MAX_VSI)) {\n\t\t\tstatus = ice_flow_rem_prof(hw, blk, prof->id);\n\t\t\tif (status)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tprof = ice_flow_find_prof_conds(hw, blk, ICE_FLOW_RX, segs, segs_cnt,\n\t\t\t\t\tvsi_handle,\n\t\t\t\t\tICE_FLOW_FIND_PROF_CHK_FLDS);\n\tif (prof) {\n\t\tstatus = ice_flow_assoc_prof(hw, blk, prof, vsi_handle);\n\t\tif (!status)\n\t\t\tstatus = ice_add_rss_list(hw, vsi_handle, prof);\n\t\tgoto exit;\n\t}\n\n\t \n\tstatus = ice_flow_add_prof(hw, blk, ICE_FLOW_RX,\n\t\t\t\t   ICE_FLOW_GEN_PROFID(hashed_flds,\n\t\t\t\t\t\t       segs[segs_cnt - 1].hdrs,\n\t\t\t\t\t\t       segs_cnt),\n\t\t\t\t   segs, segs_cnt, &prof);\n\tif (status)\n\t\tgoto exit;\n\n\tstatus = ice_flow_assoc_prof(hw, blk, prof, vsi_handle);\n\t \n\tif (status) {\n\t\tice_flow_rem_prof(hw, blk, prof->id);\n\t\tgoto exit;\n\t}\n\n\tstatus = ice_add_rss_list(hw, vsi_handle, prof);\n\nexit:\n\tkfree(segs);\n\treturn status;\n}\n\n \nint\nice_add_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds,\n\t\tu32 addl_hdrs)\n{\n\tint status;\n\n\tif (hashed_flds == ICE_HASH_INVALID ||\n\t    !ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hw->rss_locks);\n\tstatus = ice_add_rss_cfg_sync(hw, vsi_handle, hashed_flds, addl_hdrs,\n\t\t\t\t      ICE_RSS_OUTER_HEADERS);\n\tif (!status)\n\t\tstatus = ice_add_rss_cfg_sync(hw, vsi_handle, hashed_flds,\n\t\t\t\t\t      addl_hdrs, ICE_RSS_INNER_HEADERS);\n\tmutex_unlock(&hw->rss_locks);\n\n\treturn status;\n}\n\n \nstatic int\nice_rem_rss_cfg_sync(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds,\n\t\t     u32 addl_hdrs, u8 segs_cnt)\n{\n\tconst enum ice_block blk = ICE_BLK_RSS;\n\tstruct ice_flow_seg_info *segs;\n\tstruct ice_flow_prof *prof;\n\tint status;\n\n\tsegs = kcalloc(segs_cnt, sizeof(*segs), GFP_KERNEL);\n\tif (!segs)\n\t\treturn -ENOMEM;\n\n\t \n\tstatus = ice_flow_set_rss_seg_info(&segs[segs_cnt - 1], hashed_flds,\n\t\t\t\t\t   addl_hdrs);\n\tif (status)\n\t\tgoto out;\n\n\tprof = ice_flow_find_prof_conds(hw, blk, ICE_FLOW_RX, segs, segs_cnt,\n\t\t\t\t\tvsi_handle,\n\t\t\t\t\tICE_FLOW_FIND_PROF_CHK_FLDS);\n\tif (!prof) {\n\t\tstatus = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tstatus = ice_flow_disassoc_prof(hw, blk, prof, vsi_handle);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tice_rem_rss_list(hw, vsi_handle, prof);\n\n\tif (bitmap_empty(prof->vsis, ICE_MAX_VSI))\n\t\tstatus = ice_flow_rem_prof(hw, blk, prof->id);\n\nout:\n\tkfree(segs);\n\treturn status;\n}\n\n \nint __maybe_unused\nice_rem_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds,\n\t\tu32 addl_hdrs)\n{\n\tint status;\n\n\tif (hashed_flds == ICE_HASH_INVALID ||\n\t    !ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hw->rss_locks);\n\tstatus = ice_rem_rss_cfg_sync(hw, vsi_handle, hashed_flds, addl_hdrs,\n\t\t\t\t      ICE_RSS_OUTER_HEADERS);\n\tif (!status)\n\t\tstatus = ice_rem_rss_cfg_sync(hw, vsi_handle, hashed_flds,\n\t\t\t\t\t      addl_hdrs, ICE_RSS_INNER_HEADERS);\n\tmutex_unlock(&hw->rss_locks);\n\n\treturn status;\n}\n\n \n#define ICE_FLOW_AVF_RSS_IPV4_MASKS \\\n\t(BIT_ULL(ICE_AVF_FLOW_FIELD_IPV4_OTHER) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_FRAG_IPV4))\n#define ICE_FLOW_AVF_RSS_TCP_IPV4_MASKS \\\n\t(BIT_ULL(ICE_AVF_FLOW_FIELD_IPV4_TCP_SYN_NO_ACK) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_IPV4_TCP))\n#define ICE_FLOW_AVF_RSS_UDP_IPV4_MASKS \\\n\t(BIT_ULL(ICE_AVF_FLOW_FIELD_UNICAST_IPV4_UDP) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_MULTICAST_IPV4_UDP) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_IPV4_UDP))\n#define ICE_FLOW_AVF_RSS_ALL_IPV4_MASKS \\\n\t(ICE_FLOW_AVF_RSS_TCP_IPV4_MASKS | ICE_FLOW_AVF_RSS_UDP_IPV4_MASKS | \\\n\t ICE_FLOW_AVF_RSS_IPV4_MASKS | BIT_ULL(ICE_AVF_FLOW_FIELD_IPV4_SCTP))\n\n#define ICE_FLOW_AVF_RSS_IPV6_MASKS \\\n\t(BIT_ULL(ICE_AVF_FLOW_FIELD_IPV6_OTHER) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_FRAG_IPV6))\n#define ICE_FLOW_AVF_RSS_UDP_IPV6_MASKS \\\n\t(BIT_ULL(ICE_AVF_FLOW_FIELD_UNICAST_IPV6_UDP) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_MULTICAST_IPV6_UDP) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_IPV6_UDP))\n#define ICE_FLOW_AVF_RSS_TCP_IPV6_MASKS \\\n\t(BIT_ULL(ICE_AVF_FLOW_FIELD_IPV6_TCP_SYN_NO_ACK) | \\\n\t BIT_ULL(ICE_AVF_FLOW_FIELD_IPV6_TCP))\n#define ICE_FLOW_AVF_RSS_ALL_IPV6_MASKS \\\n\t(ICE_FLOW_AVF_RSS_TCP_IPV6_MASKS | ICE_FLOW_AVF_RSS_UDP_IPV6_MASKS | \\\n\t ICE_FLOW_AVF_RSS_IPV6_MASKS | BIT_ULL(ICE_AVF_FLOW_FIELD_IPV6_SCTP))\n\n \nint ice_add_avf_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 avf_hash)\n{\n\tint status = 0;\n\tu64 hash_flds;\n\n\tif (avf_hash == ICE_AVF_FLOW_FIELD_INVALID ||\n\t    !ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\t \n\tif (avf_hash & ~(ICE_FLOW_AVF_RSS_ALL_IPV4_MASKS |\n\t\t\t ICE_FLOW_AVF_RSS_ALL_IPV6_MASKS))\n\t\treturn -EIO;\n\n\thash_flds = avf_hash;\n\n\t \n\tif (hash_flds & ICE_FLOW_AVF_RSS_ALL_IPV4_MASKS)\n\t\thash_flds |= ICE_FLOW_AVF_RSS_IPV4_MASKS;\n\n\tif (hash_flds & ICE_FLOW_AVF_RSS_ALL_IPV6_MASKS)\n\t\thash_flds |= ICE_FLOW_AVF_RSS_IPV6_MASKS;\n\n\t \n\twhile (hash_flds) {\n\t\tu64 rss_hash = ICE_HASH_INVALID;\n\n\t\tif (hash_flds & ICE_FLOW_AVF_RSS_ALL_IPV4_MASKS) {\n\t\t\tif (hash_flds & ICE_FLOW_AVF_RSS_IPV4_MASKS) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV4;\n\t\t\t\thash_flds &= ~ICE_FLOW_AVF_RSS_IPV4_MASKS;\n\t\t\t} else if (hash_flds &\n\t\t\t\t   ICE_FLOW_AVF_RSS_TCP_IPV4_MASKS) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV4 |\n\t\t\t\t\tICE_FLOW_HASH_TCP_PORT;\n\t\t\t\thash_flds &= ~ICE_FLOW_AVF_RSS_TCP_IPV4_MASKS;\n\t\t\t} else if (hash_flds &\n\t\t\t\t   ICE_FLOW_AVF_RSS_UDP_IPV4_MASKS) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV4 |\n\t\t\t\t\tICE_FLOW_HASH_UDP_PORT;\n\t\t\t\thash_flds &= ~ICE_FLOW_AVF_RSS_UDP_IPV4_MASKS;\n\t\t\t} else if (hash_flds &\n\t\t\t\t   BIT_ULL(ICE_AVF_FLOW_FIELD_IPV4_SCTP)) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV4 |\n\t\t\t\t\tICE_FLOW_HASH_SCTP_PORT;\n\t\t\t\thash_flds &=\n\t\t\t\t\t~BIT_ULL(ICE_AVF_FLOW_FIELD_IPV4_SCTP);\n\t\t\t}\n\t\t} else if (hash_flds & ICE_FLOW_AVF_RSS_ALL_IPV6_MASKS) {\n\t\t\tif (hash_flds & ICE_FLOW_AVF_RSS_IPV6_MASKS) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV6;\n\t\t\t\thash_flds &= ~ICE_FLOW_AVF_RSS_IPV6_MASKS;\n\t\t\t} else if (hash_flds &\n\t\t\t\t   ICE_FLOW_AVF_RSS_TCP_IPV6_MASKS) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV6 |\n\t\t\t\t\tICE_FLOW_HASH_TCP_PORT;\n\t\t\t\thash_flds &= ~ICE_FLOW_AVF_RSS_TCP_IPV6_MASKS;\n\t\t\t} else if (hash_flds &\n\t\t\t\t   ICE_FLOW_AVF_RSS_UDP_IPV6_MASKS) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV6 |\n\t\t\t\t\tICE_FLOW_HASH_UDP_PORT;\n\t\t\t\thash_flds &= ~ICE_FLOW_AVF_RSS_UDP_IPV6_MASKS;\n\t\t\t} else if (hash_flds &\n\t\t\t\t   BIT_ULL(ICE_AVF_FLOW_FIELD_IPV6_SCTP)) {\n\t\t\t\trss_hash = ICE_FLOW_HASH_IPV6 |\n\t\t\t\t\tICE_FLOW_HASH_SCTP_PORT;\n\t\t\t\thash_flds &=\n\t\t\t\t\t~BIT_ULL(ICE_AVF_FLOW_FIELD_IPV6_SCTP);\n\t\t\t}\n\t\t}\n\n\t\tif (rss_hash == ICE_HASH_INVALID)\n\t\t\treturn -EIO;\n\n\t\tstatus = ice_add_rss_cfg(hw, vsi_handle, rss_hash,\n\t\t\t\t\t ICE_FLOW_SEG_HDR_NONE);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nint ice_replay_rss_cfg(struct ice_hw *hw, u16 vsi_handle)\n{\n\tstruct ice_rss_cfg *r;\n\tint status = 0;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hw->rss_locks);\n\tlist_for_each_entry(r, &hw->rss_list_head, l_entry) {\n\t\tif (test_bit(vsi_handle, r->vsis)) {\n\t\t\tstatus = ice_add_rss_cfg_sync(hw, vsi_handle,\n\t\t\t\t\t\t      r->hashed_flds,\n\t\t\t\t\t\t      r->packet_hdr,\n\t\t\t\t\t\t      ICE_RSS_OUTER_HEADERS);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\tstatus = ice_add_rss_cfg_sync(hw, vsi_handle,\n\t\t\t\t\t\t      r->hashed_flds,\n\t\t\t\t\t\t      r->packet_hdr,\n\t\t\t\t\t\t      ICE_RSS_INNER_HEADERS);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&hw->rss_locks);\n\n\treturn status;\n}\n\n \nu64 ice_get_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u32 hdrs)\n{\n\tu64 rss_hash = ICE_HASH_INVALID;\n\tstruct ice_rss_cfg *r;\n\n\t \n\tif (hdrs == ICE_FLOW_SEG_HDR_NONE || !ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn ICE_HASH_INVALID;\n\n\tmutex_lock(&hw->rss_locks);\n\tlist_for_each_entry(r, &hw->rss_list_head, l_entry)\n\t\tif (test_bit(vsi_handle, r->vsis) &&\n\t\t    r->packet_hdr == hdrs) {\n\t\t\trss_hash = r->hashed_flds;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&hw->rss_locks);\n\n\treturn rss_hash;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}