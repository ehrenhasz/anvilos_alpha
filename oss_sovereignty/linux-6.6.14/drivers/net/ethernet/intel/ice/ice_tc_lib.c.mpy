{
  "module_name": "ice_tc_lib.c",
  "hash_id": "a75e75898799e73ca057eb76c60898979db2a269713808e91f8306e80a3869b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_tc_lib.c",
  "human_readable_source": "\n \n\n#include \"ice.h\"\n#include \"ice_tc_lib.h\"\n#include \"ice_fltr.h\"\n#include \"ice_lib.h\"\n#include \"ice_protocol_type.h\"\n\n#define ICE_TC_METADATA_LKUP_IDX 0\n\n \nstatic int\nice_tc_count_lkups(u32 flags, struct ice_tc_flower_lyr_2_4_hdrs *headers,\n\t\t   struct ice_tc_flower_fltr *fltr)\n{\n\tint lkups_cnt = 1;  \n\n\t \n\n\tif (flags & ICE_TC_FLWR_FIELD_TENANT_ID)\n\t\tlkups_cnt++;\n\n\tif (flags & ICE_TC_FLWR_FIELD_ENC_DST_MAC)\n\t\tlkups_cnt++;\n\n\tif (flags & ICE_TC_FLWR_FIELD_ENC_OPTS)\n\t\tlkups_cnt++;\n\n\tif (flags & (ICE_TC_FLWR_FIELD_ENC_SRC_IPV4 |\n\t\t     ICE_TC_FLWR_FIELD_ENC_DEST_IPV4 |\n\t\t     ICE_TC_FLWR_FIELD_ENC_SRC_IPV6 |\n\t\t     ICE_TC_FLWR_FIELD_ENC_DEST_IPV6))\n\t\tlkups_cnt++;\n\n\tif (flags & (ICE_TC_FLWR_FIELD_ENC_IP_TOS |\n\t\t     ICE_TC_FLWR_FIELD_ENC_IP_TTL))\n\t\tlkups_cnt++;\n\n\tif (flags & ICE_TC_FLWR_FIELD_ENC_DEST_L4_PORT)\n\t\tlkups_cnt++;\n\n\tif (flags & ICE_TC_FLWR_FIELD_ETH_TYPE_ID)\n\t\tlkups_cnt++;\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_DST_MAC | ICE_TC_FLWR_FIELD_SRC_MAC))\n\t\tlkups_cnt++;\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_VLAN | ICE_TC_FLWR_FIELD_VLAN_PRIO))\n\t\tlkups_cnt++;\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_CVLAN | ICE_TC_FLWR_FIELD_CVLAN_PRIO))\n\t\tlkups_cnt++;\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_PPPOE_SESSID |\n\t\t     ICE_TC_FLWR_FIELD_PPP_PROTO))\n\t\tlkups_cnt++;\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_DEST_IPV4 | ICE_TC_FLWR_FIELD_SRC_IPV4 |\n\t\t     ICE_TC_FLWR_FIELD_DEST_IPV6 | ICE_TC_FLWR_FIELD_SRC_IPV6))\n\t\tlkups_cnt++;\n\n\tif (flags & (ICE_TC_FLWR_FIELD_IP_TOS | ICE_TC_FLWR_FIELD_IP_TTL))\n\t\tlkups_cnt++;\n\n\t \n\tif (flags & ICE_TC_FLWR_FIELD_L2TPV3_SESSID)\n\t\tlkups_cnt++;\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_DEST_L4_PORT |\n\t\t     ICE_TC_FLWR_FIELD_SRC_L4_PORT))\n\t\tlkups_cnt++;\n\n\treturn lkups_cnt;\n}\n\nstatic enum ice_protocol_type ice_proto_type_from_mac(bool inner)\n{\n\treturn inner ? ICE_MAC_IL : ICE_MAC_OFOS;\n}\n\nstatic enum ice_protocol_type ice_proto_type_from_etype(bool inner)\n{\n\treturn inner ? ICE_ETYPE_IL : ICE_ETYPE_OL;\n}\n\nstatic enum ice_protocol_type ice_proto_type_from_ipv4(bool inner)\n{\n\treturn inner ? ICE_IPV4_IL : ICE_IPV4_OFOS;\n}\n\nstatic enum ice_protocol_type ice_proto_type_from_ipv6(bool inner)\n{\n\treturn inner ? ICE_IPV6_IL : ICE_IPV6_OFOS;\n}\n\nstatic enum ice_protocol_type ice_proto_type_from_l4_port(u16 ip_proto)\n{\n\tswitch (ip_proto) {\n\tcase IPPROTO_TCP:\n\t\treturn ICE_TCP_IL;\n\tcase IPPROTO_UDP:\n\t\treturn ICE_UDP_ILOS;\n\t}\n\n\treturn 0;\n}\n\nstatic enum ice_protocol_type\nice_proto_type_from_tunnel(enum ice_tunnel_type type)\n{\n\tswitch (type) {\n\tcase TNL_VXLAN:\n\t\treturn ICE_VXLAN;\n\tcase TNL_GENEVE:\n\t\treturn ICE_GENEVE;\n\tcase TNL_GRETAP:\n\t\treturn ICE_NVGRE;\n\tcase TNL_GTPU:\n\t\t \n\t\treturn ICE_GTP;\n\tcase TNL_GTPC:\n\t\treturn ICE_GTP_NO_PAY;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum ice_sw_tunnel_type\nice_sw_type_from_tunnel(enum ice_tunnel_type type)\n{\n\tswitch (type) {\n\tcase TNL_VXLAN:\n\t\treturn ICE_SW_TUN_VXLAN;\n\tcase TNL_GENEVE:\n\t\treturn ICE_SW_TUN_GENEVE;\n\tcase TNL_GRETAP:\n\t\treturn ICE_SW_TUN_NVGRE;\n\tcase TNL_GTPU:\n\t\treturn ICE_SW_TUN_GTPU;\n\tcase TNL_GTPC:\n\t\treturn ICE_SW_TUN_GTPC;\n\tdefault:\n\t\treturn ICE_NON_TUN;\n\t}\n}\n\nstatic u16 ice_check_supported_vlan_tpid(u16 vlan_tpid)\n{\n\tswitch (vlan_tpid) {\n\tcase ETH_P_8021Q:\n\tcase ETH_P_8021AD:\n\tcase ETH_P_QINQ1:\n\t\treturn vlan_tpid;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nice_tc_fill_tunnel_outer(u32 flags, struct ice_tc_flower_fltr *fltr,\n\t\t\t struct ice_adv_lkup_elem *list, int i)\n{\n\tstruct ice_tc_flower_lyr_2_4_hdrs *hdr = &fltr->outer_headers;\n\n\tif (flags & ICE_TC_FLWR_FIELD_TENANT_ID) {\n\t\tu32 tenant_id;\n\n\t\tlist[i].type = ice_proto_type_from_tunnel(fltr->tunnel_type);\n\t\tswitch (fltr->tunnel_type) {\n\t\tcase TNL_VXLAN:\n\t\tcase TNL_GENEVE:\n\t\t\ttenant_id = be32_to_cpu(fltr->tenant_id) << 8;\n\t\t\tlist[i].h_u.tnl_hdr.vni = cpu_to_be32(tenant_id);\n\t\t\tmemcpy(&list[i].m_u.tnl_hdr.vni, \"\\xff\\xff\\xff\\x00\", 4);\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase TNL_GRETAP:\n\t\t\tlist[i].h_u.nvgre_hdr.tni_flow = fltr->tenant_id;\n\t\t\tmemcpy(&list[i].m_u.nvgre_hdr.tni_flow,\n\t\t\t       \"\\xff\\xff\\xff\\xff\", 4);\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase TNL_GTPC:\n\t\tcase TNL_GTPU:\n\t\t\tlist[i].h_u.gtp_hdr.teid = fltr->tenant_id;\n\t\t\tmemcpy(&list[i].m_u.gtp_hdr.teid,\n\t\t\t       \"\\xff\\xff\\xff\\xff\", 4);\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & ICE_TC_FLWR_FIELD_ENC_DST_MAC) {\n\t\tlist[i].type = ice_proto_type_from_mac(false);\n\t\tether_addr_copy(list[i].h_u.eth_hdr.dst_addr,\n\t\t\t\thdr->l2_key.dst_mac);\n\t\tether_addr_copy(list[i].m_u.eth_hdr.dst_addr,\n\t\t\t\thdr->l2_mask.dst_mac);\n\t\ti++;\n\t}\n\n\tif (flags & ICE_TC_FLWR_FIELD_ENC_OPTS &&\n\t    (fltr->tunnel_type == TNL_GTPU || fltr->tunnel_type == TNL_GTPC)) {\n\t\tlist[i].type = ice_proto_type_from_tunnel(fltr->tunnel_type);\n\n\t\tif (fltr->gtp_pdu_info_masks.pdu_type) {\n\t\t\tlist[i].h_u.gtp_hdr.pdu_type =\n\t\t\t\tfltr->gtp_pdu_info_keys.pdu_type << 4;\n\t\t\tmemcpy(&list[i].m_u.gtp_hdr.pdu_type, \"\\xf0\", 1);\n\t\t}\n\n\t\tif (fltr->gtp_pdu_info_masks.qfi) {\n\t\t\tlist[i].h_u.gtp_hdr.qfi = fltr->gtp_pdu_info_keys.qfi;\n\t\t\tmemcpy(&list[i].m_u.gtp_hdr.qfi, \"\\x3f\", 1);\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (flags & (ICE_TC_FLWR_FIELD_ENC_SRC_IPV4 |\n\t\t     ICE_TC_FLWR_FIELD_ENC_DEST_IPV4)) {\n\t\tlist[i].type = ice_proto_type_from_ipv4(false);\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_SRC_IPV4) {\n\t\t\tlist[i].h_u.ipv4_hdr.src_addr = hdr->l3_key.src_ipv4;\n\t\t\tlist[i].m_u.ipv4_hdr.src_addr = hdr->l3_mask.src_ipv4;\n\t\t}\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_DEST_IPV4) {\n\t\t\tlist[i].h_u.ipv4_hdr.dst_addr = hdr->l3_key.dst_ipv4;\n\t\t\tlist[i].m_u.ipv4_hdr.dst_addr = hdr->l3_mask.dst_ipv4;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (flags & (ICE_TC_FLWR_FIELD_ENC_SRC_IPV6 |\n\t\t     ICE_TC_FLWR_FIELD_ENC_DEST_IPV6)) {\n\t\tlist[i].type = ice_proto_type_from_ipv6(false);\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_SRC_IPV6) {\n\t\t\tmemcpy(&list[i].h_u.ipv6_hdr.src_addr,\n\t\t\t       &hdr->l3_key.src_ipv6_addr,\n\t\t\t       sizeof(hdr->l3_key.src_ipv6_addr));\n\t\t\tmemcpy(&list[i].m_u.ipv6_hdr.src_addr,\n\t\t\t       &hdr->l3_mask.src_ipv6_addr,\n\t\t\t       sizeof(hdr->l3_mask.src_ipv6_addr));\n\t\t}\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_DEST_IPV6) {\n\t\t\tmemcpy(&list[i].h_u.ipv6_hdr.dst_addr,\n\t\t\t       &hdr->l3_key.dst_ipv6_addr,\n\t\t\t       sizeof(hdr->l3_key.dst_ipv6_addr));\n\t\t\tmemcpy(&list[i].m_u.ipv6_hdr.dst_addr,\n\t\t\t       &hdr->l3_mask.dst_ipv6_addr,\n\t\t\t       sizeof(hdr->l3_mask.dst_ipv6_addr));\n\t\t}\n\t\ti++;\n\t}\n\n\tif (fltr->inner_headers.l2_key.n_proto == htons(ETH_P_IP) &&\n\t    (flags & (ICE_TC_FLWR_FIELD_ENC_IP_TOS |\n\t\t      ICE_TC_FLWR_FIELD_ENC_IP_TTL))) {\n\t\tlist[i].type = ice_proto_type_from_ipv4(false);\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_IP_TOS) {\n\t\t\tlist[i].h_u.ipv4_hdr.tos = hdr->l3_key.tos;\n\t\t\tlist[i].m_u.ipv4_hdr.tos = hdr->l3_mask.tos;\n\t\t}\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_IP_TTL) {\n\t\t\tlist[i].h_u.ipv4_hdr.time_to_live = hdr->l3_key.ttl;\n\t\t\tlist[i].m_u.ipv4_hdr.time_to_live = hdr->l3_mask.ttl;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (fltr->inner_headers.l2_key.n_proto == htons(ETH_P_IPV6) &&\n\t    (flags & (ICE_TC_FLWR_FIELD_ENC_IP_TOS |\n\t\t      ICE_TC_FLWR_FIELD_ENC_IP_TTL))) {\n\t\tstruct ice_ipv6_hdr *hdr_h, *hdr_m;\n\n\t\thdr_h = &list[i].h_u.ipv6_hdr;\n\t\thdr_m = &list[i].m_u.ipv6_hdr;\n\t\tlist[i].type = ice_proto_type_from_ipv6(false);\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_IP_TOS) {\n\t\t\tbe32p_replace_bits(&hdr_h->be_ver_tc_flow,\n\t\t\t\t\t   hdr->l3_key.tos,\n\t\t\t\t\t   ICE_IPV6_HDR_TC_MASK);\n\t\t\tbe32p_replace_bits(&hdr_m->be_ver_tc_flow,\n\t\t\t\t\t   hdr->l3_mask.tos,\n\t\t\t\t\t   ICE_IPV6_HDR_TC_MASK);\n\t\t}\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_ENC_IP_TTL) {\n\t\t\thdr_h->hop_limit = hdr->l3_key.ttl;\n\t\t\thdr_m->hop_limit = hdr->l3_mask.ttl;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif ((flags & ICE_TC_FLWR_FIELD_ENC_DEST_L4_PORT) &&\n\t    hdr->l3_key.ip_proto == IPPROTO_UDP) {\n\t\tlist[i].type = ICE_UDP_OF;\n\t\tlist[i].h_u.l4_hdr.dst_port = hdr->l4_key.dst_port;\n\t\tlist[i].m_u.l4_hdr.dst_port = hdr->l4_mask.dst_port;\n\t\ti++;\n\t}\n\n\t \n\tice_rule_add_tunnel_metadata(&list[ICE_TC_METADATA_LKUP_IDX]);\n\n\treturn i;\n}\n\n \nstatic int\nice_tc_fill_rules(struct ice_hw *hw, u32 flags,\n\t\t  struct ice_tc_flower_fltr *tc_fltr,\n\t\t  struct ice_adv_lkup_elem *list,\n\t\t  struct ice_adv_rule_info *rule_info,\n\t\t  u16 *l4_proto)\n{\n\tstruct ice_tc_flower_lyr_2_4_hdrs *headers = &tc_fltr->outer_headers;\n\tbool inner = false;\n\tu16 vlan_tpid = 0;\n\tint i = 1;  \n\n\trule_info->vlan_type = vlan_tpid;\n\n\t \n\tice_rule_add_direction_metadata(&list[ICE_TC_METADATA_LKUP_IDX]);\n\n\trule_info->tun_type = ice_sw_type_from_tunnel(tc_fltr->tunnel_type);\n\tif (tc_fltr->tunnel_type != TNL_LAST) {\n\t\ti = ice_tc_fill_tunnel_outer(flags, tc_fltr, list, i);\n\n\t\theaders = &tc_fltr->inner_headers;\n\t\tinner = true;\n\t}\n\n\tif (flags & ICE_TC_FLWR_FIELD_ETH_TYPE_ID) {\n\t\tlist[i].type = ice_proto_type_from_etype(inner);\n\t\tlist[i].h_u.ethertype.ethtype_id = headers->l2_key.n_proto;\n\t\tlist[i].m_u.ethertype.ethtype_id = headers->l2_mask.n_proto;\n\t\ti++;\n\t}\n\n\tif (flags & (ICE_TC_FLWR_FIELD_DST_MAC |\n\t\t     ICE_TC_FLWR_FIELD_SRC_MAC)) {\n\t\tstruct ice_tc_l2_hdr *l2_key, *l2_mask;\n\n\t\tl2_key = &headers->l2_key;\n\t\tl2_mask = &headers->l2_mask;\n\n\t\tlist[i].type = ice_proto_type_from_mac(inner);\n\t\tif (flags & ICE_TC_FLWR_FIELD_DST_MAC) {\n\t\t\tether_addr_copy(list[i].h_u.eth_hdr.dst_addr,\n\t\t\t\t\tl2_key->dst_mac);\n\t\t\tether_addr_copy(list[i].m_u.eth_hdr.dst_addr,\n\t\t\t\t\tl2_mask->dst_mac);\n\t\t}\n\t\tif (flags & ICE_TC_FLWR_FIELD_SRC_MAC) {\n\t\t\tether_addr_copy(list[i].h_u.eth_hdr.src_addr,\n\t\t\t\t\tl2_key->src_mac);\n\t\t\tether_addr_copy(list[i].m_u.eth_hdr.src_addr,\n\t\t\t\t\tl2_mask->src_mac);\n\t\t}\n\t\ti++;\n\t}\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_VLAN | ICE_TC_FLWR_FIELD_VLAN_PRIO)) {\n\t\tif (flags & ICE_TC_FLWR_FIELD_CVLAN)\n\t\t\tlist[i].type = ICE_VLAN_EX;\n\t\telse\n\t\t\tlist[i].type = ICE_VLAN_OFOS;\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_VLAN) {\n\t\t\tlist[i].h_u.vlan_hdr.vlan = headers->vlan_hdr.vlan_id;\n\t\t\tlist[i].m_u.vlan_hdr.vlan = cpu_to_be16(0x0FFF);\n\t\t}\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_VLAN_PRIO) {\n\t\t\tif (flags & ICE_TC_FLWR_FIELD_VLAN) {\n\t\t\t\tlist[i].m_u.vlan_hdr.vlan = cpu_to_be16(0xEFFF);\n\t\t\t} else {\n\t\t\t\tlist[i].m_u.vlan_hdr.vlan = cpu_to_be16(0xE000);\n\t\t\t\tlist[i].h_u.vlan_hdr.vlan = 0;\n\t\t\t}\n\t\t\tlist[i].h_u.vlan_hdr.vlan |=\n\t\t\t\theaders->vlan_hdr.vlan_prio;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (flags & ICE_TC_FLWR_FIELD_VLAN_TPID) {\n\t\tvlan_tpid = be16_to_cpu(headers->vlan_hdr.vlan_tpid);\n\t\trule_info->vlan_type =\n\t\t\t\tice_check_supported_vlan_tpid(vlan_tpid);\n\n\t\tice_rule_add_vlan_metadata(&list[ICE_TC_METADATA_LKUP_IDX]);\n\t}\n\n\tif (flags & (ICE_TC_FLWR_FIELD_CVLAN | ICE_TC_FLWR_FIELD_CVLAN_PRIO)) {\n\t\tlist[i].type = ICE_VLAN_IN;\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_CVLAN) {\n\t\t\tlist[i].h_u.vlan_hdr.vlan = headers->cvlan_hdr.vlan_id;\n\t\t\tlist[i].m_u.vlan_hdr.vlan = cpu_to_be16(0x0FFF);\n\t\t}\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_CVLAN_PRIO) {\n\t\t\tif (flags & ICE_TC_FLWR_FIELD_CVLAN) {\n\t\t\t\tlist[i].m_u.vlan_hdr.vlan = cpu_to_be16(0xEFFF);\n\t\t\t} else {\n\t\t\t\tlist[i].m_u.vlan_hdr.vlan = cpu_to_be16(0xE000);\n\t\t\t\tlist[i].h_u.vlan_hdr.vlan = 0;\n\t\t\t}\n\t\t\tlist[i].h_u.vlan_hdr.vlan |=\n\t\t\t\theaders->cvlan_hdr.vlan_prio;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (flags & (ICE_TC_FLWR_FIELD_PPPOE_SESSID |\n\t\t     ICE_TC_FLWR_FIELD_PPP_PROTO)) {\n\t\tstruct ice_pppoe_hdr *vals, *masks;\n\n\t\tvals = &list[i].h_u.pppoe_hdr;\n\t\tmasks = &list[i].m_u.pppoe_hdr;\n\n\t\tlist[i].type = ICE_PPPOE;\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_PPPOE_SESSID) {\n\t\t\tvals->session_id = headers->pppoe_hdr.session_id;\n\t\t\tmasks->session_id = cpu_to_be16(0xFFFF);\n\t\t}\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_PPP_PROTO) {\n\t\t\tvals->ppp_prot_id = headers->pppoe_hdr.ppp_proto;\n\t\t\tmasks->ppp_prot_id = cpu_to_be16(0xFFFF);\n\t\t}\n\n\t\ti++;\n\t}\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_DEST_IPV4 |\n\t\t     ICE_TC_FLWR_FIELD_SRC_IPV4)) {\n\t\tstruct ice_tc_l3_hdr *l3_key, *l3_mask;\n\n\t\tlist[i].type = ice_proto_type_from_ipv4(inner);\n\t\tl3_key = &headers->l3_key;\n\t\tl3_mask = &headers->l3_mask;\n\t\tif (flags & ICE_TC_FLWR_FIELD_DEST_IPV4) {\n\t\t\tlist[i].h_u.ipv4_hdr.dst_addr = l3_key->dst_ipv4;\n\t\t\tlist[i].m_u.ipv4_hdr.dst_addr = l3_mask->dst_ipv4;\n\t\t}\n\t\tif (flags & ICE_TC_FLWR_FIELD_SRC_IPV4) {\n\t\t\tlist[i].h_u.ipv4_hdr.src_addr = l3_key->src_ipv4;\n\t\t\tlist[i].m_u.ipv4_hdr.src_addr = l3_mask->src_ipv4;\n\t\t}\n\t\ti++;\n\t} else if (flags & (ICE_TC_FLWR_FIELD_DEST_IPV6 |\n\t\t\t    ICE_TC_FLWR_FIELD_SRC_IPV6)) {\n\t\tstruct ice_ipv6_hdr *ipv6_hdr, *ipv6_mask;\n\t\tstruct ice_tc_l3_hdr *l3_key, *l3_mask;\n\n\t\tlist[i].type = ice_proto_type_from_ipv6(inner);\n\t\tipv6_hdr = &list[i].h_u.ipv6_hdr;\n\t\tipv6_mask = &list[i].m_u.ipv6_hdr;\n\t\tl3_key = &headers->l3_key;\n\t\tl3_mask = &headers->l3_mask;\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_DEST_IPV6) {\n\t\t\tmemcpy(&ipv6_hdr->dst_addr, &l3_key->dst_ipv6_addr,\n\t\t\t       sizeof(l3_key->dst_ipv6_addr));\n\t\t\tmemcpy(&ipv6_mask->dst_addr, &l3_mask->dst_ipv6_addr,\n\t\t\t       sizeof(l3_mask->dst_ipv6_addr));\n\t\t}\n\t\tif (flags & ICE_TC_FLWR_FIELD_SRC_IPV6) {\n\t\t\tmemcpy(&ipv6_hdr->src_addr, &l3_key->src_ipv6_addr,\n\t\t\t       sizeof(l3_key->src_ipv6_addr));\n\t\t\tmemcpy(&ipv6_mask->src_addr, &l3_mask->src_ipv6_addr,\n\t\t\t       sizeof(l3_mask->src_ipv6_addr));\n\t\t}\n\t\ti++;\n\t}\n\n\tif (headers->l2_key.n_proto == htons(ETH_P_IP) &&\n\t    (flags & (ICE_TC_FLWR_FIELD_IP_TOS | ICE_TC_FLWR_FIELD_IP_TTL))) {\n\t\tlist[i].type = ice_proto_type_from_ipv4(inner);\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_IP_TOS) {\n\t\t\tlist[i].h_u.ipv4_hdr.tos = headers->l3_key.tos;\n\t\t\tlist[i].m_u.ipv4_hdr.tos = headers->l3_mask.tos;\n\t\t}\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_IP_TTL) {\n\t\t\tlist[i].h_u.ipv4_hdr.time_to_live =\n\t\t\t\theaders->l3_key.ttl;\n\t\t\tlist[i].m_u.ipv4_hdr.time_to_live =\n\t\t\t\theaders->l3_mask.ttl;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (headers->l2_key.n_proto == htons(ETH_P_IPV6) &&\n\t    (flags & (ICE_TC_FLWR_FIELD_IP_TOS | ICE_TC_FLWR_FIELD_IP_TTL))) {\n\t\tstruct ice_ipv6_hdr *hdr_h, *hdr_m;\n\n\t\thdr_h = &list[i].h_u.ipv6_hdr;\n\t\thdr_m = &list[i].m_u.ipv6_hdr;\n\t\tlist[i].type = ice_proto_type_from_ipv6(inner);\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_IP_TOS) {\n\t\t\tbe32p_replace_bits(&hdr_h->be_ver_tc_flow,\n\t\t\t\t\t   headers->l3_key.tos,\n\t\t\t\t\t   ICE_IPV6_HDR_TC_MASK);\n\t\t\tbe32p_replace_bits(&hdr_m->be_ver_tc_flow,\n\t\t\t\t\t   headers->l3_mask.tos,\n\t\t\t\t\t   ICE_IPV6_HDR_TC_MASK);\n\t\t}\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_IP_TTL) {\n\t\t\thdr_h->hop_limit = headers->l3_key.ttl;\n\t\t\thdr_m->hop_limit = headers->l3_mask.ttl;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (flags & ICE_TC_FLWR_FIELD_L2TPV3_SESSID) {\n\t\tlist[i].type = ICE_L2TPV3;\n\n\t\tlist[i].h_u.l2tpv3_sess_hdr.session_id =\n\t\t\theaders->l2tpv3_hdr.session_id;\n\t\tlist[i].m_u.l2tpv3_sess_hdr.session_id =\n\t\t\tcpu_to_be32(0xFFFFFFFF);\n\n\t\ti++;\n\t}\n\n\t \n\tif (flags & (ICE_TC_FLWR_FIELD_DEST_L4_PORT |\n\t\t     ICE_TC_FLWR_FIELD_SRC_L4_PORT)) {\n\t\tstruct ice_tc_l4_hdr *l4_key, *l4_mask;\n\n\t\tlist[i].type = ice_proto_type_from_l4_port(headers->l3_key.ip_proto);\n\t\tl4_key = &headers->l4_key;\n\t\tl4_mask = &headers->l4_mask;\n\n\t\tif (flags & ICE_TC_FLWR_FIELD_DEST_L4_PORT) {\n\t\t\tlist[i].h_u.l4_hdr.dst_port = l4_key->dst_port;\n\t\t\tlist[i].m_u.l4_hdr.dst_port = l4_mask->dst_port;\n\t\t}\n\t\tif (flags & ICE_TC_FLWR_FIELD_SRC_L4_PORT) {\n\t\t\tlist[i].h_u.l4_hdr.src_port = l4_key->src_port;\n\t\t\tlist[i].m_u.l4_hdr.src_port = l4_mask->src_port;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\n \nstatic int ice_tc_tun_get_type(struct net_device *tunnel_dev)\n{\n\tif (netif_is_vxlan(tunnel_dev))\n\t\treturn TNL_VXLAN;\n\tif (netif_is_geneve(tunnel_dev))\n\t\treturn TNL_GENEVE;\n\tif (netif_is_gretap(tunnel_dev) ||\n\t    netif_is_ip6gretap(tunnel_dev))\n\t\treturn TNL_GRETAP;\n\n\t \n\tif (netif_is_gtp(tunnel_dev))\n\t\treturn TNL_GTPU;\n\treturn TNL_LAST;\n}\n\nbool ice_is_tunnel_supported(struct net_device *dev)\n{\n\treturn ice_tc_tun_get_type(dev) != TNL_LAST;\n}\n\nstatic bool ice_tc_is_dev_uplink(struct net_device *dev)\n{\n\treturn netif_is_ice(dev) || ice_is_tunnel_supported(dev);\n}\n\nstatic int ice_tc_setup_redirect_action(struct net_device *filter_dev,\n\t\t\t\t\tstruct ice_tc_flower_fltr *fltr,\n\t\t\t\t\tstruct net_device *target_dev)\n{\n\tstruct ice_repr *repr;\n\n\tfltr->action.fltr_act = ICE_FWD_TO_VSI;\n\n\tif (ice_is_port_repr_netdev(filter_dev) &&\n\t    ice_is_port_repr_netdev(target_dev)) {\n\t\trepr = ice_netdev_to_repr(target_dev);\n\n\t\tfltr->dest_vsi = repr->src_vsi;\n\t\tfltr->direction = ICE_ESWITCH_FLTR_EGRESS;\n\t} else if (ice_is_port_repr_netdev(filter_dev) &&\n\t\t   ice_tc_is_dev_uplink(target_dev)) {\n\t\trepr = ice_netdev_to_repr(filter_dev);\n\n\t\tfltr->dest_vsi = repr->src_vsi->back->switchdev.uplink_vsi;\n\t\tfltr->direction = ICE_ESWITCH_FLTR_EGRESS;\n\t} else if (ice_tc_is_dev_uplink(filter_dev) &&\n\t\t   ice_is_port_repr_netdev(target_dev)) {\n\t\trepr = ice_netdev_to_repr(target_dev);\n\n\t\tfltr->dest_vsi = repr->src_vsi;\n\t\tfltr->direction = ICE_ESWITCH_FLTR_INGRESS;\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t   \"Unsupported netdevice in switchdev mode\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nice_tc_setup_drop_action(struct net_device *filter_dev,\n\t\t\t struct ice_tc_flower_fltr *fltr)\n{\n\tfltr->action.fltr_act = ICE_DROP_PACKET;\n\n\tif (ice_is_port_repr_netdev(filter_dev)) {\n\t\tfltr->direction = ICE_ESWITCH_FLTR_EGRESS;\n\t} else if (ice_tc_is_dev_uplink(filter_dev)) {\n\t\tfltr->direction = ICE_ESWITCH_FLTR_INGRESS;\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t   \"Unsupported netdevice in switchdev mode\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ice_eswitch_tc_parse_action(struct net_device *filter_dev,\n\t\t\t\t       struct ice_tc_flower_fltr *fltr,\n\t\t\t\t       struct flow_action_entry *act)\n{\n\tint err;\n\n\tswitch (act->id) {\n\tcase FLOW_ACTION_DROP:\n\t\terr = ice_tc_setup_drop_action(filter_dev, fltr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbreak;\n\n\tcase FLOW_ACTION_REDIRECT:\n\t\terr = ice_tc_setup_redirect_action(filter_dev, fltr, act->dev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbreak;\n\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Unsupported action in switchdev mode\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nice_eswitch_add_tc_fltr(struct ice_vsi *vsi, struct ice_tc_flower_fltr *fltr)\n{\n\tstruct ice_tc_flower_lyr_2_4_hdrs *headers = &fltr->outer_headers;\n\tstruct ice_adv_rule_info rule_info = { 0 };\n\tstruct ice_rule_query_data rule_added;\n\tstruct ice_hw *hw = &vsi->back->hw;\n\tstruct ice_adv_lkup_elem *list;\n\tu32 flags = fltr->flags;\n\tint lkups_cnt;\n\tint ret;\n\tint i;\n\n\tif (!flags || (flags & ICE_TC_FLWR_FIELD_ENC_SRC_L4_PORT)) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Unsupported encap field(s)\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlkups_cnt = ice_tc_count_lkups(flags, headers, fltr);\n\tlist = kcalloc(lkups_cnt, sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\ti = ice_tc_fill_rules(hw, flags, fltr, list, &rule_info, NULL);\n\tif (i != lkups_cnt) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trule_info.sw_act.fltr_act = fltr->action.fltr_act;\n\tif (fltr->action.fltr_act != ICE_DROP_PACKET)\n\t\trule_info.sw_act.vsi_handle = fltr->dest_vsi->idx;\n\t \n\trule_info.priority = 7;\n\trule_info.flags_info.act_valid = true;\n\n\tif (fltr->direction == ICE_ESWITCH_FLTR_INGRESS) {\n\t\t \n\t\trule_info.sw_act.flag |= ICE_FLTR_RX;\n\t\trule_info.sw_act.src = hw->pf_id;\n\t\trule_info.flags_info.act = ICE_SINGLE_ACT_LB_ENABLE;\n\t} else if (fltr->direction == ICE_ESWITCH_FLTR_EGRESS &&\n\t\t   fltr->dest_vsi == vsi->back->switchdev.uplink_vsi) {\n\t\t \n\t\trule_info.sw_act.flag |= ICE_FLTR_TX;\n\t\trule_info.sw_act.src = vsi->idx;\n\t\trule_info.flags_info.act = ICE_SINGLE_ACT_LAN_ENABLE;\n\t} else {\n\t\t \n\t\trule_info.sw_act.flag |= ICE_FLTR_TX;\n\t\trule_info.sw_act.src = vsi->idx;\n\t\trule_info.flags_info.act = ICE_SINGLE_ACT_LB_ENABLE;\n\t}\n\n\t \n\trule_info.fltr_rule_id = fltr->cookie;\n\n\tret = ice_add_adv_rule(hw, list, lkups_cnt, &rule_info, &rule_added);\n\tif (ret == -EEXIST) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Unable to add filter because it already exist\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t} else if (ret) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Unable to add filter due to error\");\n\t\tgoto exit;\n\t}\n\n\t \n\tfltr->rid = rule_added.rid;\n\tfltr->rule_id = rule_added.rule_id;\n\tfltr->dest_vsi_handle = rule_added.vsi_handle;\n\nexit:\n\tkfree(list);\n\treturn ret;\n}\n\n \nstruct ice_vsi *\nice_locate_vsi_using_queue(struct ice_vsi *vsi, int queue)\n{\n\tint num_tc, tc;\n\n\t \n\tif (!ice_is_adq_active(vsi->back))\n\t\treturn vsi;\n\n\t \n\tnum_tc = vsi->mqprio_qopt.qopt.num_tc;\n\n\tfor (tc = 0; tc < num_tc; tc++) {\n\t\tint qcount = vsi->mqprio_qopt.qopt.count[tc];\n\t\tint offset = vsi->mqprio_qopt.qopt.offset[tc];\n\n\t\tif (queue >= offset && queue < offset + qcount) {\n\t\t\t \n\t\t\tif (tc < ICE_CHNL_START_TC)\n\t\t\t\treturn vsi;\n\t\t\telse\n\t\t\t\treturn vsi->tc_map_vsi[tc];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct ice_rx_ring *\nice_locate_rx_ring_using_queue(struct ice_vsi *vsi,\n\t\t\t       struct ice_tc_flower_fltr *tc_fltr)\n{\n\tu16 queue = tc_fltr->action.fwd.q.queue;\n\n\treturn queue < vsi->num_rxq ? vsi->rx_rings[queue] : NULL;\n}\n\n \nstatic struct ice_vsi *\nice_tc_forward_action(struct ice_vsi *vsi, struct ice_tc_flower_fltr *tc_fltr)\n{\n\tstruct ice_rx_ring *ring = NULL;\n\tstruct ice_vsi *dest_vsi = NULL;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct device *dev;\n\tu32 tc_class;\n\tint q;\n\n\tdev = ice_pf_to_dev(pf);\n\n\t \n\tswitch (tc_fltr->action.fltr_act) {\n\tcase ICE_FWD_TO_VSI:\n\t\ttc_class = tc_fltr->action.fwd.tc.tc_class;\n\t\t \n\t\tif (tc_class < ICE_CHNL_START_TC) {\n\t\t\tNL_SET_ERR_MSG_MOD(tc_fltr->extack,\n\t\t\t\t\t   \"Unable to add filter because of unsupported destination\");\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\t\t \n\t\tdest_vsi = vsi->tc_map_vsi[tc_class];\n\t\tbreak;\n\tcase ICE_FWD_TO_Q:\n\t\t \n\t\tring = ice_locate_rx_ring_using_queue(vsi, tc_fltr);\n\t\tif (!ring) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Unable to locate Rx queue for action fwd_to_queue: %u\\n\",\n\t\t\t\ttc_fltr->action.fwd.q.queue);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\t \n\t\tq = tc_fltr->action.fwd.q.queue;\n\t\tdest_vsi = ice_locate_vsi_using_queue(vsi, q);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev,\n\t\t\t\"Unable to add filter because of unsupported action %u (supported actions: fwd to tc, fwd to queue)\\n\",\n\t\t\ttc_fltr->action.fltr_act);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tif (!dest_vsi) {\n\t\tdev_err(dev,\n\t\t\t\"Unable to add filter because specified destination VSI doesn't exist\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn dest_vsi;\n}\n\n \nstatic int\nice_add_tc_flower_adv_fltr(struct ice_vsi *vsi,\n\t\t\t   struct ice_tc_flower_fltr *tc_fltr)\n{\n\tstruct ice_tc_flower_lyr_2_4_hdrs *headers = &tc_fltr->outer_headers;\n\tstruct ice_adv_rule_info rule_info = {0};\n\tstruct ice_rule_query_data rule_added;\n\tstruct ice_adv_lkup_elem *list;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tu32 flags = tc_fltr->flags;\n\tstruct ice_vsi *dest_vsi;\n\tstruct device *dev;\n\tu16 lkups_cnt = 0;\n\tu16 l4_proto = 0;\n\tint ret = 0;\n\tu16 i = 0;\n\n\tdev = ice_pf_to_dev(pf);\n\tif (ice_is_safe_mode(pf)) {\n\t\tNL_SET_ERR_MSG_MOD(tc_fltr->extack, \"Unable to add filter because driver is in safe mode\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!flags || (flags & (ICE_TC_FLWR_FIELD_ENC_DEST_IPV4 |\n\t\t\t\tICE_TC_FLWR_FIELD_ENC_SRC_IPV4 |\n\t\t\t\tICE_TC_FLWR_FIELD_ENC_DEST_IPV6 |\n\t\t\t\tICE_TC_FLWR_FIELD_ENC_SRC_IPV6 |\n\t\t\t\tICE_TC_FLWR_FIELD_ENC_SRC_L4_PORT))) {\n\t\tNL_SET_ERR_MSG_MOD(tc_fltr->extack, \"Unsupported encap field(s)\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (ice_is_forward_action(tc_fltr->action.fltr_act)) {\n\t\tdest_vsi = ice_tc_forward_action(vsi, tc_fltr);\n\t\tif (IS_ERR(dest_vsi))\n\t\t\treturn PTR_ERR(dest_vsi);\n\t}\n\n\tlkups_cnt = ice_tc_count_lkups(flags, headers, tc_fltr);\n\tlist = kcalloc(lkups_cnt, sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\ti = ice_tc_fill_rules(hw, flags, tc_fltr, list, &rule_info, &l4_proto);\n\tif (i != lkups_cnt) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trule_info.sw_act.fltr_act = tc_fltr->action.fltr_act;\n\t \n\trule_info.fltr_rule_id = tc_fltr->cookie;\n\n\tswitch (tc_fltr->action.fltr_act) {\n\tcase ICE_FWD_TO_VSI:\n\t\trule_info.sw_act.vsi_handle = dest_vsi->idx;\n\t\trule_info.priority = ICE_SWITCH_FLTR_PRIO_VSI;\n\t\trule_info.sw_act.src = hw->pf_id;\n\t\tdev_dbg(dev, \"add switch rule for TC:%u vsi_idx:%u, lkups_cnt:%u\\n\",\n\t\t\ttc_fltr->action.fwd.tc.tc_class,\n\t\t\trule_info.sw_act.vsi_handle, lkups_cnt);\n\t\tbreak;\n\tcase ICE_FWD_TO_Q:\n\t\t \n\t\trule_info.sw_act.fwd_id.q_id = tc_fltr->action.fwd.q.hw_queue;\n\t\trule_info.sw_act.vsi_handle = dest_vsi->idx;\n\t\trule_info.priority = ICE_SWITCH_FLTR_PRIO_QUEUE;\n\t\trule_info.sw_act.src = hw->pf_id;\n\t\tdev_dbg(dev, \"add switch rule action to forward to queue:%u (HW queue %u), lkups_cnt:%u\\n\",\n\t\t\ttc_fltr->action.fwd.q.queue,\n\t\t\ttc_fltr->action.fwd.q.hw_queue, lkups_cnt);\n\t\tbreak;\n\tcase ICE_DROP_PACKET:\n\t\trule_info.sw_act.flag |= ICE_FLTR_RX;\n\t\trule_info.sw_act.src = hw->pf_id;\n\t\trule_info.priority = ICE_SWITCH_FLTR_PRIO_VSI;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto exit;\n\t}\n\n\tret = ice_add_adv_rule(hw, list, lkups_cnt, &rule_info, &rule_added);\n\tif (ret == -EEXIST) {\n\t\tNL_SET_ERR_MSG_MOD(tc_fltr->extack,\n\t\t\t\t   \"Unable to add filter because it already exist\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t} else if (ret) {\n\t\tNL_SET_ERR_MSG_MOD(tc_fltr->extack,\n\t\t\t\t   \"Unable to add filter due to error\");\n\t\tgoto exit;\n\t}\n\n\t \n\ttc_fltr->rid = rule_added.rid;\n\ttc_fltr->rule_id = rule_added.rule_id;\n\ttc_fltr->dest_vsi_handle = rule_added.vsi_handle;\n\tif (tc_fltr->action.fltr_act == ICE_FWD_TO_VSI ||\n\t    tc_fltr->action.fltr_act == ICE_FWD_TO_Q) {\n\t\ttc_fltr->dest_vsi = dest_vsi;\n\t\t \n\t\tdest_vsi->num_chnl_fltr++;\n\n\t\t \n\t\tif (vsi->type == ICE_VSI_PF &&\n\t\t    (flags & (ICE_TC_FLWR_FIELD_DST_MAC |\n\t\t\t      ICE_TC_FLWR_FIELD_ENC_DST_MAC)))\n\t\t\tpf->num_dmac_chnl_fltrs++;\n\t}\n\tswitch (tc_fltr->action.fltr_act) {\n\tcase ICE_FWD_TO_VSI:\n\t\tdev_dbg(dev, \"added switch rule (lkups_cnt %u, flags 0x%x), action is forward to TC %u, rid %u, rule_id %u, vsi_idx %u\\n\",\n\t\t\tlkups_cnt, flags,\n\t\t\ttc_fltr->action.fwd.tc.tc_class, rule_added.rid,\n\t\t\trule_added.rule_id, rule_added.vsi_handle);\n\t\tbreak;\n\tcase ICE_FWD_TO_Q:\n\t\tdev_dbg(dev, \"added switch rule (lkups_cnt %u, flags 0x%x), action is forward to queue: %u (HW queue %u)     , rid %u, rule_id %u\\n\",\n\t\t\tlkups_cnt, flags, tc_fltr->action.fwd.q.queue,\n\t\t\ttc_fltr->action.fwd.q.hw_queue, rule_added.rid,\n\t\t\trule_added.rule_id);\n\t\tbreak;\n\tcase ICE_DROP_PACKET:\n\t\tdev_dbg(dev, \"added switch rule (lkups_cnt %u, flags 0x%x), action is drop, rid %u, rule_id %u\\n\",\n\t\t\tlkups_cnt, flags, rule_added.rid, rule_added.rule_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nexit:\n\tkfree(list);\n\treturn ret;\n}\n\n \nstatic u16\nice_tc_set_pppoe(struct flow_match_pppoe *match,\n\t\t struct ice_tc_flower_fltr *fltr,\n\t\t struct ice_tc_flower_lyr_2_4_hdrs *headers)\n{\n\tif (match->mask->session_id) {\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_PPPOE_SESSID;\n\t\theaders->pppoe_hdr.session_id = match->key->session_id;\n\t}\n\n\tif (match->mask->ppp_proto) {\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_PPP_PROTO;\n\t\theaders->pppoe_hdr.ppp_proto = match->key->ppp_proto;\n\t}\n\n\treturn be16_to_cpu(match->key->type);\n}\n\n \nstatic int\nice_tc_set_ipv4(struct flow_match_ipv4_addrs *match,\n\t\tstruct ice_tc_flower_fltr *fltr,\n\t\tstruct ice_tc_flower_lyr_2_4_hdrs *headers, bool is_encap)\n{\n\tif (match->key->dst) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_DEST_IPV4;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_DEST_IPV4;\n\t\theaders->l3_key.dst_ipv4 = match->key->dst;\n\t\theaders->l3_mask.dst_ipv4 = match->mask->dst;\n\t}\n\tif (match->key->src) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_SRC_IPV4;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_SRC_IPV4;\n\t\theaders->l3_key.src_ipv4 = match->key->src;\n\t\theaders->l3_mask.src_ipv4 = match->mask->src;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nice_tc_set_ipv6(struct flow_match_ipv6_addrs *match,\n\t\tstruct ice_tc_flower_fltr *fltr,\n\t\tstruct ice_tc_flower_lyr_2_4_hdrs *headers, bool is_encap)\n{\n\tstruct ice_tc_l3_hdr *l3_key, *l3_mask;\n\n\t \n\tif (ipv6_addr_loopback(&match->key->dst) ||\n\t    ipv6_addr_loopback(&match->key->src)) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Bad IPv6, addr is LOOPBACK\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (ipv6_addr_any(&match->mask->dst) &&\n\t    ipv6_addr_any(&match->mask->src)) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Bad src/dest IPv6, addr is any\");\n\t\treturn -EINVAL;\n\t}\n\tif (!ipv6_addr_any(&match->mask->dst)) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_DEST_IPV6;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_DEST_IPV6;\n\t}\n\tif (!ipv6_addr_any(&match->mask->src)) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_SRC_IPV6;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_SRC_IPV6;\n\t}\n\n\tl3_key = &headers->l3_key;\n\tl3_mask = &headers->l3_mask;\n\n\tif (fltr->flags & (ICE_TC_FLWR_FIELD_ENC_SRC_IPV6 |\n\t\t\t   ICE_TC_FLWR_FIELD_SRC_IPV6)) {\n\t\tmemcpy(&l3_key->src_ipv6_addr, &match->key->src.s6_addr,\n\t\t       sizeof(match->key->src.s6_addr));\n\t\tmemcpy(&l3_mask->src_ipv6_addr, &match->mask->src.s6_addr,\n\t\t       sizeof(match->mask->src.s6_addr));\n\t}\n\tif (fltr->flags & (ICE_TC_FLWR_FIELD_ENC_DEST_IPV6 |\n\t\t\t   ICE_TC_FLWR_FIELD_DEST_IPV6)) {\n\t\tmemcpy(&l3_key->dst_ipv6_addr, &match->key->dst.s6_addr,\n\t\t       sizeof(match->key->dst.s6_addr));\n\t\tmemcpy(&l3_mask->dst_ipv6_addr, &match->mask->dst.s6_addr,\n\t\t       sizeof(match->mask->dst.s6_addr));\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nice_tc_set_tos_ttl(struct flow_match_ip *match,\n\t\t   struct ice_tc_flower_fltr *fltr,\n\t\t   struct ice_tc_flower_lyr_2_4_hdrs *headers,\n\t\t   bool is_encap)\n{\n\tif (match->mask->tos) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_IP_TOS;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_IP_TOS;\n\n\t\theaders->l3_key.tos = match->key->tos;\n\t\theaders->l3_mask.tos = match->mask->tos;\n\t}\n\n\tif (match->mask->ttl) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_IP_TTL;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_IP_TTL;\n\n\t\theaders->l3_key.ttl = match->key->ttl;\n\t\theaders->l3_mask.ttl = match->mask->ttl;\n\t}\n}\n\n \nstatic int\nice_tc_set_port(struct flow_match_ports match,\n\t\tstruct ice_tc_flower_fltr *fltr,\n\t\tstruct ice_tc_flower_lyr_2_4_hdrs *headers, bool is_encap)\n{\n\tif (match.key->dst) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_DEST_L4_PORT;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_DEST_L4_PORT;\n\n\t\theaders->l4_key.dst_port = match.key->dst;\n\t\theaders->l4_mask.dst_port = match.mask->dst;\n\t}\n\tif (match.key->src) {\n\t\tif (is_encap)\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_SRC_L4_PORT;\n\t\telse\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_SRC_L4_PORT;\n\n\t\theaders->l4_key.src_port = match.key->src;\n\t\theaders->l4_mask.src_port = match.mask->src;\n\t}\n\treturn 0;\n}\n\nstatic struct net_device *\nice_get_tunnel_device(struct net_device *dev, struct flow_rule *rule)\n{\n\tstruct flow_action_entry *act;\n\tint i;\n\n\tif (ice_is_tunnel_supported(dev))\n\t\treturn dev;\n\n\tflow_action_for_each(i, act, &rule->action) {\n\t\tif (act->id == FLOW_ACTION_REDIRECT &&\n\t\t    ice_is_tunnel_supported(act->dev))\n\t\t\treturn act->dev;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int\nice_parse_gtp_type(struct flow_match_ports match,\n\t\t   struct ice_tc_flower_fltr *fltr)\n{\n\tu16 dst_port;\n\n\tif (match.key->dst) {\n\t\tdst_port = be16_to_cpu(match.key->dst);\n\n\t\tswitch (dst_port) {\n\t\tcase 2152:\n\t\t\tbreak;\n\t\tcase 2123:\n\t\t\tfltr->tunnel_type = TNL_GTPC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Unsupported GTP port number\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nice_parse_tunnel_attr(struct net_device *dev, struct flow_rule *rule,\n\t\t      struct ice_tc_flower_fltr *fltr)\n{\n\tstruct ice_tc_flower_lyr_2_4_hdrs *headers = &fltr->outer_headers;\n\tstruct flow_match_control enc_control;\n\n\tfltr->tunnel_type = ice_tc_tun_get_type(dev);\n\theaders->l3_key.ip_proto = IPPROTO_UDP;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID)) {\n\t\tstruct flow_match_enc_keyid enc_keyid;\n\n\t\tflow_rule_match_enc_keyid(rule, &enc_keyid);\n\n\t\tif (!enc_keyid.mask->keyid ||\n\t\t    enc_keyid.mask->keyid != cpu_to_be32(ICE_TC_FLOWER_MASK_32))\n\t\t\treturn -EINVAL;\n\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_TENANT_ID;\n\t\tfltr->tenant_id = enc_keyid.key->keyid;\n\t}\n\n\tflow_rule_match_enc_control(rule, &enc_control);\n\n\tif (enc_control.key->addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_enc_ipv4_addrs(rule, &match);\n\t\tif (ice_tc_set_ipv4(&match, fltr, headers, true))\n\t\t\treturn -EINVAL;\n\t} else if (enc_control.key->addr_type ==\n\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\tstruct flow_match_ipv6_addrs match;\n\n\t\tflow_rule_match_enc_ipv6_addrs(rule, &match);\n\t\tif (ice_tc_set_ipv6(&match, fltr, headers, true))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IP)) {\n\t\tstruct flow_match_ip match;\n\n\t\tflow_rule_match_enc_ip(rule, &match);\n\t\tice_tc_set_tos_ttl(&match, fltr, headers, true);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_PORTS) &&\n\t    fltr->tunnel_type != TNL_VXLAN && fltr->tunnel_type != TNL_GENEVE) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_enc_ports(rule, &match);\n\n\t\tif (fltr->tunnel_type != TNL_GTPU) {\n\t\t\tif (ice_tc_set_port(match, fltr, headers, true))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (ice_parse_gtp_type(match, fltr))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_OPTS)) {\n\t\tstruct flow_match_enc_opts match;\n\n\t\tflow_rule_match_enc_opts(rule, &match);\n\n\t\tmemcpy(&fltr->gtp_pdu_info_keys, &match.key->data[0],\n\t\t       sizeof(struct gtp_pdu_session_info));\n\n\t\tmemcpy(&fltr->gtp_pdu_info_masks, &match.mask->data[0],\n\t\t       sizeof(struct gtp_pdu_session_info));\n\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_OPTS;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_parse_cls_flower(struct net_device *filter_dev, struct ice_vsi *vsi,\n\t\t     struct flow_cls_offload *f,\n\t\t     struct ice_tc_flower_fltr *fltr)\n{\n\tstruct ice_tc_flower_lyr_2_4_hdrs *headers = &fltr->outer_headers;\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tu16 n_proto_mask = 0, n_proto_key = 0, addr_type = 0;\n\tstruct flow_dissector *dissector;\n\tstruct net_device *tunnel_dev;\n\n\tdissector = rule->match.dissector;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CVLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_KEYID) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_OPTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PPPOE) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_L2TPV3))) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Unsupported key used\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ttunnel_dev = ice_get_tunnel_device(filter_dev, rule);\n\tif (tunnel_dev) {\n\t\tint err;\n\n\t\tfilter_dev = tunnel_dev;\n\n\t\terr = ice_parse_tunnel_attr(filter_dev, rule, fltr);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Failed to parse TC flower tunnel attributes\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\theaders = &fltr->inner_headers;\n\t} else if (dissector->used_keys &\n\t\t  (BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) |\n\t\t   BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) |\n\t\t   BIT_ULL(FLOW_DISSECTOR_KEY_ENC_KEYID) |\n\t\t   BIT_ULL(FLOW_DISSECTOR_KEY_ENC_PORTS))) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Tunnel key used, but device isn't a tunnel\");\n\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tfltr->tunnel_type = TNL_LAST;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\n\t\tn_proto_key = ntohs(match.key->n_proto);\n\t\tn_proto_mask = ntohs(match.mask->n_proto);\n\n\t\tif (n_proto_key == ETH_P_ALL || n_proto_key == 0 ||\n\t\t    fltr->tunnel_type == TNL_GTPU ||\n\t\t    fltr->tunnel_type == TNL_GTPC) {\n\t\t\tn_proto_key = 0;\n\t\t\tn_proto_mask = 0;\n\t\t} else {\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ETH_TYPE_ID;\n\t\t}\n\n\t\theaders->l2_key.n_proto = cpu_to_be16(n_proto_key);\n\t\theaders->l2_mask.n_proto = cpu_to_be16(n_proto_mask);\n\t\theaders->l3_key.ip_proto = match.key->ip_proto;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\n\t\tif (!is_zero_ether_addr(match.key->dst)) {\n\t\t\tether_addr_copy(headers->l2_key.dst_mac,\n\t\t\t\t\tmatch.key->dst);\n\t\t\tether_addr_copy(headers->l2_mask.dst_mac,\n\t\t\t\t\tmatch.mask->dst);\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_DST_MAC;\n\t\t}\n\n\t\tif (!is_zero_ether_addr(match.key->src)) {\n\t\t\tether_addr_copy(headers->l2_key.src_mac,\n\t\t\t\t\tmatch.key->src);\n\t\t\tether_addr_copy(headers->l2_mask.src_mac,\n\t\t\t\t\tmatch.mask->src);\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_SRC_MAC;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN) ||\n\t    is_vlan_dev(filter_dev)) {\n\t\tstruct flow_dissector_key_vlan mask;\n\t\tstruct flow_dissector_key_vlan key;\n\t\tstruct flow_match_vlan match;\n\n\t\tif (is_vlan_dev(filter_dev)) {\n\t\t\tmatch.key = &key;\n\t\t\tmatch.key->vlan_id = vlan_dev_vlan_id(filter_dev);\n\t\t\tmatch.key->vlan_priority = 0;\n\t\t\tmatch.mask = &mask;\n\t\t\tmemset(match.mask, 0xff, sizeof(*match.mask));\n\t\t\tmatch.mask->vlan_priority = 0;\n\t\t} else {\n\t\t\tflow_rule_match_vlan(rule, &match);\n\t\t}\n\n\t\tif (match.mask->vlan_id) {\n\t\t\tif (match.mask->vlan_id == VLAN_VID_MASK) {\n\t\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_VLAN;\n\t\t\t\theaders->vlan_hdr.vlan_id =\n\t\t\t\t\tcpu_to_be16(match.key->vlan_id &\n\t\t\t\t\t\t    VLAN_VID_MASK);\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Bad VLAN mask\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (match.mask->vlan_priority) {\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_VLAN_PRIO;\n\t\t\theaders->vlan_hdr.vlan_prio =\n\t\t\t\tbe16_encode_bits(match.key->vlan_priority,\n\t\t\t\t\t\t VLAN_PRIO_MASK);\n\t\t}\n\n\t\tif (match.mask->vlan_tpid) {\n\t\t\theaders->vlan_hdr.vlan_tpid = match.key->vlan_tpid;\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_VLAN_TPID;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tif (!ice_is_dvm_ena(&vsi->back->hw)) {\n\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Double VLAN mode is not enabled\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tflow_rule_match_cvlan(rule, &match);\n\n\t\tif (match.mask->vlan_id) {\n\t\t\tif (match.mask->vlan_id == VLAN_VID_MASK) {\n\t\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_CVLAN;\n\t\t\t\theaders->cvlan_hdr.vlan_id =\n\t\t\t\t\tcpu_to_be16(match.key->vlan_id &\n\t\t\t\t\t\t    VLAN_VID_MASK);\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t\t\t   \"Bad CVLAN mask\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (match.mask->vlan_priority) {\n\t\t\tfltr->flags |= ICE_TC_FLWR_FIELD_CVLAN_PRIO;\n\t\t\theaders->cvlan_hdr.vlan_prio =\n\t\t\t\tbe16_encode_bits(match.key->vlan_priority,\n\t\t\t\t\t\t VLAN_PRIO_MASK);\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PPPOE)) {\n\t\tstruct flow_match_pppoe match;\n\n\t\tflow_rule_match_pppoe(rule, &match);\n\t\tn_proto_key = ice_tc_set_pppoe(&match, fltr, headers);\n\n\t\t \n\t\theaders->l2_key.n_proto = cpu_to_be16(n_proto_key);\n\t\theaders->l2_mask.n_proto = cpu_to_be16(0xFFFF);\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ETH_TYPE_ID;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(rule, &match);\n\n\t\taddr_type = match.key->addr_type;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_ipv4_addrs(rule, &match);\n\t\tif (ice_tc_set_ipv4(&match, fltr, headers, false))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\tstruct flow_match_ipv6_addrs match;\n\n\t\tflow_rule_match_ipv6_addrs(rule, &match);\n\t\tif (ice_tc_set_ipv6(&match, fltr, headers, false))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {\n\t\tstruct flow_match_ip match;\n\n\t\tflow_rule_match_ip(rule, &match);\n\t\tice_tc_set_tos_ttl(&match, fltr, headers, false);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_L2TPV3)) {\n\t\tstruct flow_match_l2tpv3 match;\n\n\t\tflow_rule_match_l2tpv3(rule, &match);\n\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_L2TPV3_SESSID;\n\t\theaders->l2tpv3_hdr.session_id = match.key->session_id;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_ports(rule, &match);\n\t\tif (ice_tc_set_port(match, fltr, headers, false))\n\t\t\treturn -EINVAL;\n\t\tswitch (headers->l3_key.ip_proto) {\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_UDP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Only UDP and TCP transport are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nice_add_switch_fltr(struct ice_vsi *vsi, struct ice_tc_flower_fltr *fltr)\n{\n\tif (fltr->action.fltr_act == ICE_FWD_TO_QGRP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ice_is_eswitch_mode_switchdev(vsi->back))\n\t\treturn ice_eswitch_add_tc_fltr(vsi, fltr);\n\n\treturn ice_add_tc_flower_adv_fltr(vsi, fltr);\n}\n\n \nstatic int\nice_prep_adq_filter(struct ice_vsi *vsi, struct ice_tc_flower_fltr *fltr)\n{\n\tif ((fltr->flags & ICE_TC_FLWR_FIELD_TENANT_ID) &&\n\t    (fltr->flags & (ICE_TC_FLWR_FIELD_DST_MAC |\n\t\t\t   ICE_TC_FLWR_FIELD_SRC_MAC))) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t   \"Unable to add filter because filter using tunnel key and inner MAC is unsupported combination\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (fltr->tunnel_type != TNL_LAST &&\n\t    !(fltr->flags & ICE_TC_FLWR_FIELD_ENC_DST_MAC))\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_ENC_DST_MAC;\n\n\tif (fltr->tunnel_type == TNL_LAST &&\n\t    !(fltr->flags & ICE_TC_FLWR_FIELD_DST_MAC))\n\t\tfltr->flags |= ICE_TC_FLWR_FIELD_DST_MAC;\n\n\tif (fltr->flags & (ICE_TC_FLWR_FIELD_DST_MAC |\n\t\t\t   ICE_TC_FLWR_FIELD_ENC_DST_MAC)) {\n\t\tether_addr_copy(fltr->outer_headers.l2_key.dst_mac,\n\t\t\t\tvsi->netdev->dev_addr);\n\t\teth_broadcast_addr(fltr->outer_headers.l2_mask.dst_mac);\n\t}\n\n\t \n\tif (fltr->flags & ICE_TC_FLWR_FIELD_VLAN) {\n\t\tu16 vlan_id = be16_to_cpu(fltr->outer_headers.vlan_hdr.vlan_id);\n\n\t\tif (!ice_vlan_fltr_exist(&vsi->back->hw, vlan_id, vsi->idx)) {\n\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t\t   \"Unable to add filter because legacy VLAN filter for specified destination doesn't exist\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nice_handle_tclass_action(struct ice_vsi *vsi,\n\t\t\t struct flow_cls_offload *cls_flower,\n\t\t\t struct ice_tc_flower_fltr *fltr)\n{\n\tint tc = tc_classid_to_hwtc(vsi->netdev, cls_flower->classid);\n\n\t \n\tif (tc < ICE_CHNL_START_TC) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t   \"Unable to add filter because of unsupported destination\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!(vsi->all_enatc & BIT(tc))) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t   \"Unable to add filter because of non-existence destination\");\n\t\treturn -EINVAL;\n\t}\n\tfltr->action.fltr_act = ICE_FWD_TO_VSI;\n\tfltr->action.fwd.tc.tc_class = tc;\n\n\treturn ice_prep_adq_filter(vsi, fltr);\n}\n\nstatic int\nice_tc_forward_to_queue(struct ice_vsi *vsi, struct ice_tc_flower_fltr *fltr,\n\t\t\tstruct flow_action_entry *act)\n{\n\tstruct ice_vsi *ch_vsi = NULL;\n\tu16 queue = act->rx_queue;\n\n\tif (queue >= vsi->num_rxq) {\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack,\n\t\t\t\t   \"Unable to add filter because specified queue is invalid\");\n\t\treturn -EINVAL;\n\t}\n\tfltr->action.fltr_act = ICE_FWD_TO_Q;\n\tfltr->action.fwd.q.queue = queue;\n\t \n\tfltr->action.fwd.q.hw_queue = vsi->rxq_map[queue];\n\n\t \n\tch_vsi = ice_locate_vsi_using_queue(vsi, fltr->action.fwd.q.queue);\n\tif (!ch_vsi)\n\t\treturn -EINVAL;\n\tfltr->dest_vsi = ch_vsi;\n\tif (!ice_is_chnl_fltr(fltr))\n\t\treturn 0;\n\n\treturn ice_prep_adq_filter(vsi, fltr);\n}\n\nstatic int\nice_tc_parse_action(struct ice_vsi *vsi, struct ice_tc_flower_fltr *fltr,\n\t\t    struct flow_action_entry *act)\n{\n\tswitch (act->id) {\n\tcase FLOW_ACTION_RX_QUEUE_MAPPING:\n\t\t \n\t\treturn ice_tc_forward_to_queue(vsi, fltr, act);\n\tcase FLOW_ACTION_DROP:\n\t\tfltr->action.fltr_act = ICE_DROP_PACKET;\n\t\treturn 0;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Unsupported TC action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int ice_parse_tc_flower_actions(struct net_device *filter_dev,\n\t\t\t\t       struct ice_vsi *vsi,\n\t\t\t\t       struct flow_cls_offload *cls_flower,\n\t\t\t\t       struct ice_tc_flower_fltr *fltr)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls_flower);\n\tstruct flow_action *flow_action = &rule->action;\n\tstruct flow_action_entry *act;\n\tint i, err;\n\n\tif (cls_flower->classid)\n\t\treturn ice_handle_tclass_action(vsi, cls_flower, fltr);\n\n\tif (!flow_action_has_entries(flow_action))\n\t\treturn -EINVAL;\n\n\tflow_action_for_each(i, act, flow_action) {\n\t\tif (ice_is_eswitch_mode_switchdev(vsi->back))\n\t\t\terr = ice_eswitch_tc_parse_action(filter_dev, fltr, act);\n\t\telse\n\t\t\terr = ice_tc_parse_action(vsi, fltr, act);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcontinue;\n\t}\n\treturn 0;\n}\n\n \nstatic int ice_del_tc_fltr(struct ice_vsi *vsi, struct ice_tc_flower_fltr *fltr)\n{\n\tstruct ice_rule_query_data rule_rem;\n\tstruct ice_pf *pf = vsi->back;\n\tint err;\n\n\trule_rem.rid = fltr->rid;\n\trule_rem.rule_id = fltr->rule_id;\n\trule_rem.vsi_handle = fltr->dest_vsi_handle;\n\terr = ice_rem_adv_rule_by_id(&pf->hw, &rule_rem);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Filter does not exist\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tNL_SET_ERR_MSG_MOD(fltr->extack, \"Failed to delete TC flower filter\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (fltr->dest_vsi) {\n\t\tif (fltr->dest_vsi->type == ICE_VSI_CHNL) {\n\t\t\tfltr->dest_vsi->num_chnl_fltr--;\n\n\t\t\t \n\t\t\tif (vsi->type == ICE_VSI_PF &&\n\t\t\t    (fltr->flags & (ICE_TC_FLWR_FIELD_DST_MAC |\n\t\t\t\t\t    ICE_TC_FLWR_FIELD_ENC_DST_MAC)))\n\t\t\t\tpf->num_dmac_chnl_fltrs--;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nice_add_tc_fltr(struct net_device *netdev, struct ice_vsi *vsi,\n\t\tstruct flow_cls_offload *f,\n\t\tstruct ice_tc_flower_fltr **__fltr)\n{\n\tstruct ice_tc_flower_fltr *fltr;\n\tint err;\n\n\t \n\t*__fltr = NULL;\n\n\tfltr = kzalloc(sizeof(*fltr), GFP_KERNEL);\n\tif (!fltr)\n\t\treturn -ENOMEM;\n\n\tfltr->cookie = f->cookie;\n\tfltr->extack = f->common.extack;\n\tfltr->src_vsi = vsi;\n\tINIT_HLIST_NODE(&fltr->tc_flower_node);\n\n\terr = ice_parse_cls_flower(netdev, vsi, f, fltr);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = ice_parse_tc_flower_actions(netdev, vsi, f, fltr);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = ice_add_switch_fltr(vsi, fltr);\n\tif (err < 0)\n\t\tgoto err;\n\n\t \n\t*__fltr = fltr;\n\n\treturn 0;\nerr:\n\tkfree(fltr);\n\treturn err;\n}\n\n \nstatic struct ice_tc_flower_fltr *\nice_find_tc_flower_fltr(struct ice_pf *pf, unsigned long cookie)\n{\n\tstruct ice_tc_flower_fltr *fltr;\n\n\thlist_for_each_entry(fltr, &pf->tc_flower_fltr_list, tc_flower_node)\n\t\tif (cookie == fltr->cookie)\n\t\t\treturn fltr;\n\n\treturn NULL;\n}\n\n \nint\nice_add_cls_flower(struct net_device *netdev, struct ice_vsi *vsi,\n\t\t   struct flow_cls_offload *cls_flower)\n{\n\tstruct netlink_ext_ack *extack = cls_flower->common.extack;\n\tstruct net_device *vsi_netdev = vsi->netdev;\n\tstruct ice_tc_flower_fltr *fltr;\n\tstruct ice_pf *pf = vsi->back;\n\tint err;\n\n\tif (ice_is_reset_in_progress(pf->state))\n\t\treturn -EBUSY;\n\tif (test_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags))\n\t\treturn -EINVAL;\n\n\tif (ice_is_port_repr_netdev(netdev))\n\t\tvsi_netdev = netdev;\n\n\tif (!(vsi_netdev->features & NETIF_F_HW_TC) &&\n\t    !test_bit(ICE_FLAG_CLS_FLOWER, pf->flags)) {\n\t\t \n\t\tif (netdev == vsi_netdev)\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"can't apply TC flower filters, turn ON hw-tc-offload and try again\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfltr = ice_find_tc_flower_fltr(pf, cls_flower->cookie);\n\tif (fltr) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"filter cookie already exists, ignoring\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\terr = ice_add_tc_fltr(netdev, vsi, cls_flower, &fltr);\n\tif (err)\n\t\treturn err;\n\n\t \n\thlist_add_head(&fltr->tc_flower_node, &pf->tc_flower_fltr_list);\n\treturn 0;\n}\n\n \nint\nice_del_cls_flower(struct ice_vsi *vsi, struct flow_cls_offload *cls_flower)\n{\n\tstruct ice_tc_flower_fltr *fltr;\n\tstruct ice_pf *pf = vsi->back;\n\tint err;\n\n\t \n\tfltr = ice_find_tc_flower_fltr(pf, cls_flower->cookie);\n\tif (!fltr) {\n\t\tif (!test_bit(ICE_FLAG_TC_MQPRIO, pf->flags) &&\n\t\t    hlist_empty(&pf->tc_flower_fltr_list))\n\t\t\treturn 0;\n\n\t\tNL_SET_ERR_MSG_MOD(cls_flower->common.extack, \"failed to delete TC flower filter because unable to find it\");\n\t\treturn -EINVAL;\n\t}\n\n\tfltr->extack = cls_flower->common.extack;\n\t \n\terr = ice_del_tc_fltr(vsi, fltr);\n\tif (err)\n\t\treturn err;\n\n\t \n\thlist_del(&fltr->tc_flower_node);\n\n\t \n\tkfree(fltr);\n\n\treturn 0;\n}\n\n \nvoid ice_replay_tc_fltrs(struct ice_pf *pf)\n{\n\tstruct ice_tc_flower_fltr *fltr;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(fltr, node,\n\t\t\t\t  &pf->tc_flower_fltr_list,\n\t\t\t\t  tc_flower_node) {\n\t\tfltr->extack = NULL;\n\t\tice_add_switch_fltr(fltr->src_vsi, fltr);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}