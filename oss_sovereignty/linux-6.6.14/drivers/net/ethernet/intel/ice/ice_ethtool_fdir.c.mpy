{
  "module_name": "ice_ethtool_fdir.c",
  "hash_id": "448f7a92f304e77c2b0256db414da16204b7b862c32964d9cd948bcbba4fa768",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c",
  "human_readable_source": "\n \n\n \n\n#include \"ice.h\"\n#include \"ice_lib.h\"\n#include \"ice_fdir.h\"\n#include \"ice_flow.h\"\n\nstatic struct in6_addr full_ipv6_addr_mask = {\n\t.in6_u = {\n\t\t.u6_addr8 = {\n\t\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t}\n\t}\n};\n\nstatic struct in6_addr zero_ipv6_addr_mask = {\n\t.in6_u = {\n\t\t.u6_addr8 = {\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t}\n\t}\n};\n\n \n#define TNL_SEG_CNT(_TNL_) ((_TNL_) + 1)\n\n \nstatic int ice_fltr_to_ethtool_flow(enum ice_fltr_ptype flow)\n{\n\tswitch (flow) {\n\tcase ICE_FLTR_PTYPE_NONF_IPV4_TCP:\n\t\treturn TCP_V4_FLOW;\n\tcase ICE_FLTR_PTYPE_NONF_IPV4_UDP:\n\t\treturn UDP_V4_FLOW;\n\tcase ICE_FLTR_PTYPE_NONF_IPV4_SCTP:\n\t\treturn SCTP_V4_FLOW;\n\tcase ICE_FLTR_PTYPE_NONF_IPV4_OTHER:\n\t\treturn IPV4_USER_FLOW;\n\tcase ICE_FLTR_PTYPE_NONF_IPV6_TCP:\n\t\treturn TCP_V6_FLOW;\n\tcase ICE_FLTR_PTYPE_NONF_IPV6_UDP:\n\t\treturn UDP_V6_FLOW;\n\tcase ICE_FLTR_PTYPE_NONF_IPV6_SCTP:\n\t\treturn SCTP_V6_FLOW;\n\tcase ICE_FLTR_PTYPE_NONF_IPV6_OTHER:\n\t\treturn IPV6_USER_FLOW;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\n \nstatic enum ice_fltr_ptype ice_ethtool_flow_to_fltr(int eth)\n{\n\tswitch (eth) {\n\tcase TCP_V4_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV4_TCP;\n\tcase UDP_V4_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV4_UDP;\n\tcase SCTP_V4_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV4_SCTP;\n\tcase IPV4_USER_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV4_OTHER;\n\tcase TCP_V6_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV6_TCP;\n\tcase UDP_V6_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV6_UDP;\n\tcase SCTP_V6_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV6_SCTP;\n\tcase IPV6_USER_FLOW:\n\t\treturn ICE_FLTR_PTYPE_NONF_IPV6_OTHER;\n\tdefault:\n\t\treturn ICE_FLTR_PTYPE_NONF_NONE;\n\t}\n}\n\n \nstatic bool ice_is_mask_valid(u64 mask, u64 field)\n{\n\treturn (mask & field) == field;\n}\n\n \nint ice_get_ethtool_fdir_entry(struct ice_hw *hw, struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp;\n\tstruct ice_fdir_fltr *rule;\n\tint ret = 0;\n\tu16 idx;\n\n\tfsp = (struct ethtool_rx_flow_spec *)&cmd->fs;\n\n\tmutex_lock(&hw->fdir_fltr_lock);\n\n\trule = ice_fdir_find_fltr_by_idx(hw, fsp->location);\n\n\tif (!rule || fsp->location != rule->fltr_id) {\n\t\tret = -EINVAL;\n\t\tgoto release_lock;\n\t}\n\n\tfsp->flow_type = ice_fltr_to_ethtool_flow(rule->flow_type);\n\n\tmemset(&fsp->m_u, 0, sizeof(fsp->m_u));\n\tmemset(&fsp->m_ext, 0, sizeof(fsp->m_ext));\n\n\tswitch (fsp->flow_type) {\n\tcase IPV4_USER_FLOW:\n\t\tfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\n\t\tfsp->h_u.usr_ip4_spec.proto = 0;\n\t\tfsp->h_u.usr_ip4_spec.l4_4_bytes = rule->ip.v4.l4_header;\n\t\tfsp->h_u.usr_ip4_spec.tos = rule->ip.v4.tos;\n\t\tfsp->h_u.usr_ip4_spec.ip4src = rule->ip.v4.src_ip;\n\t\tfsp->h_u.usr_ip4_spec.ip4dst = rule->ip.v4.dst_ip;\n\t\tfsp->m_u.usr_ip4_spec.ip4src = rule->mask.v4.src_ip;\n\t\tfsp->m_u.usr_ip4_spec.ip4dst = rule->mask.v4.dst_ip;\n\t\tfsp->m_u.usr_ip4_spec.ip_ver = 0xFF;\n\t\tfsp->m_u.usr_ip4_spec.proto = 0;\n\t\tfsp->m_u.usr_ip4_spec.l4_4_bytes = rule->mask.v4.l4_header;\n\t\tfsp->m_u.usr_ip4_spec.tos = rule->mask.v4.tos;\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tfsp->h_u.tcp_ip4_spec.psrc = rule->ip.v4.src_port;\n\t\tfsp->h_u.tcp_ip4_spec.pdst = rule->ip.v4.dst_port;\n\t\tfsp->h_u.tcp_ip4_spec.ip4src = rule->ip.v4.src_ip;\n\t\tfsp->h_u.tcp_ip4_spec.ip4dst = rule->ip.v4.dst_ip;\n\t\tfsp->m_u.tcp_ip4_spec.psrc = rule->mask.v4.src_port;\n\t\tfsp->m_u.tcp_ip4_spec.pdst = rule->mask.v4.dst_port;\n\t\tfsp->m_u.tcp_ip4_spec.ip4src = rule->mask.v4.src_ip;\n\t\tfsp->m_u.tcp_ip4_spec.ip4dst = rule->mask.v4.dst_ip;\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tfsp->h_u.usr_ip6_spec.l4_4_bytes = rule->ip.v6.l4_header;\n\t\tfsp->h_u.usr_ip6_spec.tclass = rule->ip.v6.tc;\n\t\tfsp->h_u.usr_ip6_spec.l4_proto = rule->ip.v6.proto;\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6src, rule->ip.v6.src_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6dst, rule->ip.v6.dst_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(fsp->m_u.tcp_ip6_spec.ip6src, rule->mask.v6.src_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(fsp->m_u.tcp_ip6_spec.ip6dst, rule->mask.v6.dst_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tfsp->m_u.usr_ip6_spec.l4_4_bytes = rule->mask.v6.l4_header;\n\t\tfsp->m_u.usr_ip6_spec.tclass = rule->mask.v6.tc;\n\t\tfsp->m_u.usr_ip6_spec.l4_proto = rule->mask.v6.proto;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6src, rule->ip.v6.src_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6dst, rule->ip.v6.dst_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tfsp->h_u.tcp_ip6_spec.psrc = rule->ip.v6.src_port;\n\t\tfsp->h_u.tcp_ip6_spec.pdst = rule->ip.v6.dst_port;\n\t\tmemcpy(fsp->m_u.tcp_ip6_spec.ip6src,\n\t\t       rule->mask.v6.src_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(fsp->m_u.tcp_ip6_spec.ip6dst,\n\t\t       rule->mask.v6.dst_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tfsp->m_u.tcp_ip6_spec.psrc = rule->mask.v6.src_port;\n\t\tfsp->m_u.tcp_ip6_spec.pdst = rule->mask.v6.dst_port;\n\t\tfsp->h_u.tcp_ip6_spec.tclass = rule->ip.v6.tc;\n\t\tfsp->m_u.tcp_ip6_spec.tclass = rule->mask.v6.tc;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (rule->dest_ctl == ICE_FLTR_PRGM_DESC_DEST_DROP_PKT)\n\t\tfsp->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfsp->ring_cookie = rule->orig_q_index;\n\n\tidx = ice_ethtool_flow_to_fltr(fsp->flow_type);\n\tif (idx == ICE_FLTR_PTYPE_NONF_NONE) {\n\t\tdev_err(ice_hw_to_dev(hw), \"Missing input index for flow_type %d\\n\",\n\t\t\trule->flow_type);\n\t\tret = -EINVAL;\n\t}\n\nrelease_lock:\n\tmutex_unlock(&hw->fdir_fltr_lock);\n\treturn ret;\n}\n\n \nint\nice_get_fdir_fltr_ids(struct ice_hw *hw, struct ethtool_rxnfc *cmd,\n\t\t      u32 *rule_locs)\n{\n\tstruct ice_fdir_fltr *f_rule;\n\tunsigned int cnt = 0;\n\tint val = 0;\n\n\t \n\tcmd->data = ice_get_fdir_cnt_all(hw);\n\n\tmutex_lock(&hw->fdir_fltr_lock);\n\n\tlist_for_each_entry(f_rule, &hw->fdir_list_head, fltr_node) {\n\t\tif (cnt == cmd->rule_cnt) {\n\t\t\tval = -EMSGSIZE;\n\t\t\tgoto release_lock;\n\t\t}\n\t\trule_locs[cnt] = f_rule->fltr_id;\n\t\tcnt++;\n\t}\n\nrelease_lock:\n\tmutex_unlock(&hw->fdir_fltr_lock);\n\tif (!val)\n\t\tcmd->rule_cnt = cnt;\n\treturn val;\n}\n\n \nstatic void\nice_fdir_remap_entries(struct ice_fd_hw_prof *prof, int tun, int idx)\n{\n\tif (idx != prof->cnt && tun < ICE_FD_HW_SEG_MAX) {\n\t\tint i;\n\n\t\tfor (i = idx; i < (prof->cnt - 1); i++) {\n\t\t\tu64 old_entry_h;\n\n\t\t\told_entry_h = prof->entry_h[i + 1][tun];\n\t\t\tprof->entry_h[i][tun] = old_entry_h;\n\t\t\tprof->vsi_h[i] = prof->vsi_h[i + 1];\n\t\t}\n\n\t\tprof->entry_h[i][tun] = 0;\n\t\tprof->vsi_h[i] = 0;\n\t}\n}\n\n \nvoid ice_fdir_rem_adq_chnl(struct ice_hw *hw, u16 vsi_idx)\n{\n\tint status, flow;\n\n\tif (!hw->fdir_prof)\n\t\treturn;\n\n\tfor (flow = 0; flow < ICE_FLTR_PTYPE_MAX; flow++) {\n\t\tstruct ice_fd_hw_prof *prof = hw->fdir_prof[flow];\n\t\tint tun, i;\n\n\t\tif (!prof || !prof->cnt)\n\t\t\tcontinue;\n\n\t\tfor (tun = 0; tun < ICE_FD_HW_SEG_MAX; tun++) {\n\t\t\tu64 prof_id;\n\n\t\t\tprof_id = flow + tun * ICE_FLTR_PTYPE_MAX;\n\n\t\t\tfor (i = 0; i < prof->cnt; i++) {\n\t\t\t\tif (prof->vsi_h[i] != vsi_idx)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tprof->entry_h[i][tun] = 0;\n\t\t\t\tprof->vsi_h[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tice_fdir_remap_entries(prof, tun, i);\n\n\t\t\t \n\t\t\tstatus = ice_flow_rem_vsi_prof(hw, vsi_idx, prof_id);\n\t\t\tif (status) {\n\t\t\t\tdev_err(ice_hw_to_dev(hw), \"ice_flow_rem_vsi_prof() failed status=%d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t}\n\t\t}\n\t\tprof->cnt--;\n\t}\n}\n\n \nstatic struct ice_fd_hw_prof *\nice_fdir_get_hw_prof(struct ice_hw *hw, enum ice_block blk, int flow)\n{\n\tif (blk == ICE_BLK_FD && hw->fdir_prof)\n\t\treturn hw->fdir_prof[flow];\n\n\treturn NULL;\n}\n\n \nstatic void\nice_fdir_erase_flow_from_hw(struct ice_hw *hw, enum ice_block blk, int flow)\n{\n\tstruct ice_fd_hw_prof *prof = ice_fdir_get_hw_prof(hw, blk, flow);\n\tint tun;\n\n\tif (!prof)\n\t\treturn;\n\n\tfor (tun = 0; tun < ICE_FD_HW_SEG_MAX; tun++) {\n\t\tu64 prof_id;\n\t\tint j;\n\n\t\tprof_id = flow + tun * ICE_FLTR_PTYPE_MAX;\n\t\tfor (j = 0; j < prof->cnt; j++) {\n\t\t\tu16 vsi_num;\n\n\t\t\tif (!prof->entry_h[j][tun] || !prof->vsi_h[j])\n\t\t\t\tcontinue;\n\t\t\tvsi_num = ice_get_hw_vsi_num(hw, prof->vsi_h[j]);\n\t\t\tice_rem_prof_id_flow(hw, blk, vsi_num, prof_id);\n\t\t\tice_flow_rem_entry(hw, blk, prof->entry_h[j][tun]);\n\t\t\tprof->entry_h[j][tun] = 0;\n\t\t}\n\t\tice_flow_rem_prof(hw, blk, prof_id);\n\t}\n}\n\n \nstatic void\nice_fdir_rem_flow(struct ice_hw *hw, enum ice_block blk,\n\t\t  enum ice_fltr_ptype flow_type)\n{\n\tint flow = (int)flow_type & ~FLOW_EXT;\n\tstruct ice_fd_hw_prof *prof;\n\tint tun, i;\n\n\tprof = ice_fdir_get_hw_prof(hw, blk, flow);\n\tif (!prof)\n\t\treturn;\n\n\tice_fdir_erase_flow_from_hw(hw, blk, flow);\n\tfor (i = 0; i < prof->cnt; i++)\n\t\tprof->vsi_h[i] = 0;\n\tfor (tun = 0; tun < ICE_FD_HW_SEG_MAX; tun++) {\n\t\tif (!prof->fdir_seg[tun])\n\t\t\tcontinue;\n\t\tdevm_kfree(ice_hw_to_dev(hw), prof->fdir_seg[tun]);\n\t\tprof->fdir_seg[tun] = NULL;\n\t}\n\tprof->cnt = 0;\n}\n\n \nvoid ice_fdir_release_flows(struct ice_hw *hw)\n{\n\tint flow;\n\n\t \n\tfor (flow = 0; flow < ICE_FLTR_PTYPE_MAX; flow++)\n\t\tice_fdir_erase_flow_from_hw(hw, ICE_BLK_FD, flow);\n}\n\n \nvoid ice_fdir_replay_flows(struct ice_hw *hw)\n{\n\tint flow;\n\n\tfor (flow = 0; flow < ICE_FLTR_PTYPE_MAX; flow++) {\n\t\tint tun;\n\n\t\tif (!hw->fdir_prof[flow] || !hw->fdir_prof[flow]->cnt)\n\t\t\tcontinue;\n\t\tfor (tun = 0; tun < ICE_FD_HW_SEG_MAX; tun++) {\n\t\t\tstruct ice_flow_prof *hw_prof;\n\t\t\tstruct ice_fd_hw_prof *prof;\n\t\t\tu64 prof_id;\n\t\t\tint j;\n\n\t\t\tprof = hw->fdir_prof[flow];\n\t\t\tprof_id = flow + tun * ICE_FLTR_PTYPE_MAX;\n\t\t\tice_flow_add_prof(hw, ICE_BLK_FD, ICE_FLOW_RX, prof_id,\n\t\t\t\t\t  prof->fdir_seg[tun], TNL_SEG_CNT(tun),\n\t\t\t\t\t  &hw_prof);\n\t\t\tfor (j = 0; j < prof->cnt; j++) {\n\t\t\t\tenum ice_flow_priority prio;\n\t\t\t\tu64 entry_h = 0;\n\t\t\t\tint err;\n\n\t\t\t\tprio = ICE_FLOW_PRIO_NORMAL;\n\t\t\t\terr = ice_flow_add_entry(hw, ICE_BLK_FD,\n\t\t\t\t\t\t\t prof_id,\n\t\t\t\t\t\t\t prof->vsi_h[0],\n\t\t\t\t\t\t\t prof->vsi_h[j],\n\t\t\t\t\t\t\t prio, prof->fdir_seg,\n\t\t\t\t\t\t\t &entry_h);\n\t\t\t\tif (err) {\n\t\t\t\t\tdev_err(ice_hw_to_dev(hw), \"Could not replay Flow Director, flow type %d\\n\",\n\t\t\t\t\t\tflow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprof->entry_h[j][tun] = entry_h;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int\nice_parse_rx_flow_user_data(struct ethtool_rx_flow_spec *fsp,\n\t\t\t    struct ice_rx_flow_userdef *data)\n{\n\tu64 value, mask;\n\n\tmemset(data, 0, sizeof(*data));\n\tif (!(fsp->flow_type & FLOW_EXT))\n\t\treturn 0;\n\n\tvalue = be64_to_cpu(*((__force __be64 *)fsp->h_ext.data));\n\tmask = be64_to_cpu(*((__force __be64 *)fsp->m_ext.data));\n\tif (!mask)\n\t\treturn 0;\n\n#define ICE_USERDEF_FLEX_WORD_M\tGENMASK_ULL(15, 0)\n#define ICE_USERDEF_FLEX_OFFS_S\t16\n#define ICE_USERDEF_FLEX_OFFS_M\tGENMASK_ULL(31, ICE_USERDEF_FLEX_OFFS_S)\n#define ICE_USERDEF_FLEX_FLTR_M\tGENMASK_ULL(31, 0)\n\n\t \n#define ICE_USERDEF_FLEX_MAX_OFFS_VAL 0x1fe\n\n\tif (!ice_is_mask_valid(mask, ICE_USERDEF_FLEX_FLTR_M) ||\n\t    value > ICE_USERDEF_FLEX_FLTR_M)\n\t\treturn -EINVAL;\n\n\tdata->flex_word = value & ICE_USERDEF_FLEX_WORD_M;\n\tdata->flex_offset = (value & ICE_USERDEF_FLEX_OFFS_M) >>\n\t\t\t     ICE_USERDEF_FLEX_OFFS_S;\n\tif (data->flex_offset > ICE_USERDEF_FLEX_MAX_OFFS_VAL)\n\t\treturn -EINVAL;\n\n\tdata->flex_fltr = true;\n\n\treturn 0;\n}\n\n \nstatic int ice_fdir_num_avail_fltr(struct ice_hw *hw, struct ice_vsi *vsi)\n{\n\tu16 vsi_num = ice_get_hw_vsi_num(hw, vsi->idx);\n\tu16 num_guar;\n\tu16 num_be;\n\n\t \n\tnum_guar = vsi->num_gfltr;\n\n\t \n\tnum_guar -= (rd32(hw, VSIQF_FD_CNT(vsi_num)) &\n\t\t     VSIQF_FD_CNT_FD_GCNT_M) >> VSIQF_FD_CNT_FD_GCNT_S;\n\n\t \n\tnum_be = hw->func_caps.fd_fltr_best_effort;\n\n\t \n\tnum_be -= (rd32(hw, GLQF_FD_CNT) & GLQF_FD_CNT_FD_BCNT_M) >>\n\t\t   GLQF_FD_CNT_FD_BCNT_S;\n\n\treturn num_guar + num_be;\n}\n\n \nstatic int\nice_fdir_alloc_flow_prof(struct ice_hw *hw, enum ice_fltr_ptype flow)\n{\n\tif (!hw)\n\t\treturn -EINVAL;\n\n\tif (!hw->fdir_prof) {\n\t\thw->fdir_prof = devm_kcalloc(ice_hw_to_dev(hw),\n\t\t\t\t\t     ICE_FLTR_PTYPE_MAX,\n\t\t\t\t\t     sizeof(*hw->fdir_prof),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!hw->fdir_prof)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!hw->fdir_prof[flow]) {\n\t\thw->fdir_prof[flow] = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t\t\t\t   sizeof(**hw->fdir_prof),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!hw->fdir_prof[flow])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u16\nice_fdir_prof_vsi_idx(struct ice_fd_hw_prof *prof, int vsi_idx)\n{\n\tu16 idx = 0;\n\n\tfor (idx = 0; idx < prof->cnt; idx++)\n\t\tif (prof->vsi_h[idx] == vsi_idx)\n\t\t\treturn idx;\n\n\tif (idx == prof->cnt)\n\t\tprof->vsi_h[prof->cnt++] = vsi_idx;\n\treturn idx;\n}\n\n \nstatic int\nice_fdir_set_hw_fltr_rule(struct ice_pf *pf, struct ice_flow_seg_info *seg,\n\t\t\t  enum ice_fltr_ptype flow, enum ice_fd_hw_seg tun)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_vsi *main_vsi, *ctrl_vsi;\n\tstruct ice_flow_seg_info *old_seg;\n\tstruct ice_flow_prof *prof = NULL;\n\tstruct ice_fd_hw_prof *hw_prof;\n\tstruct ice_hw *hw = &pf->hw;\n\tu64 entry1_h = 0;\n\tu64 entry2_h = 0;\n\tbool del_last;\n\tu64 prof_id;\n\tint err;\n\tint idx;\n\n\tmain_vsi = ice_get_main_vsi(pf);\n\tif (!main_vsi)\n\t\treturn -EINVAL;\n\n\tctrl_vsi = ice_get_ctrl_vsi(pf);\n\tif (!ctrl_vsi)\n\t\treturn -EINVAL;\n\n\terr = ice_fdir_alloc_flow_prof(hw, flow);\n\tif (err)\n\t\treturn err;\n\n\thw_prof = hw->fdir_prof[flow];\n\told_seg = hw_prof->fdir_seg[tun];\n\tif (old_seg) {\n\t\t \n\t\tif (!memcmp(old_seg, seg, sizeof(*seg)))\n\t\t\treturn -EEXIST;\n\n\t\t \n\t\tif (hw->fdir_fltr_cnt[flow]) {\n\t\t\tdev_err(dev, \"Failed to add filter.  Flow director filters on each port must have the same input set.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ice_is_arfs_using_perfect_flow(hw, flow)) {\n\t\t\tdev_err(dev, \"aRFS using perfect flow type %d, cannot change input set\\n\",\n\t\t\t\tflow);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tice_fdir_rem_flow(hw, ICE_BLK_FD, flow);\n\t}\n\n\t \n\tprof_id = flow + tun * ICE_FLTR_PTYPE_MAX;\n\terr = ice_flow_add_prof(hw, ICE_BLK_FD, ICE_FLOW_RX, prof_id, seg,\n\t\t\t\tTNL_SEG_CNT(tun), &prof);\n\tif (err)\n\t\treturn err;\n\terr = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, main_vsi->idx,\n\t\t\t\t main_vsi->idx, ICE_FLOW_PRIO_NORMAL,\n\t\t\t\t seg, &entry1_h);\n\tif (err)\n\t\tgoto err_prof;\n\terr = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, main_vsi->idx,\n\t\t\t\t ctrl_vsi->idx, ICE_FLOW_PRIO_NORMAL,\n\t\t\t\t seg, &entry2_h);\n\tif (err)\n\t\tgoto err_entry;\n\n\thw_prof->fdir_seg[tun] = seg;\n\thw_prof->entry_h[0][tun] = entry1_h;\n\thw_prof->entry_h[1][tun] = entry2_h;\n\thw_prof->vsi_h[0] = main_vsi->idx;\n\thw_prof->vsi_h[1] = ctrl_vsi->idx;\n\tif (!hw_prof->cnt)\n\t\thw_prof->cnt = 2;\n\n\tfor (idx = 1; idx < ICE_CHNL_MAX_TC; idx++) {\n\t\tu16 vsi_idx;\n\t\tu16 vsi_h;\n\n\t\tif (!ice_is_adq_active(pf) || !main_vsi->tc_map_vsi[idx])\n\t\t\tcontinue;\n\n\t\tentry1_h = 0;\n\t\tvsi_h = main_vsi->tc_map_vsi[idx]->idx;\n\t\terr = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id,\n\t\t\t\t\t main_vsi->idx, vsi_h,\n\t\t\t\t\t ICE_FLOW_PRIO_NORMAL, seg,\n\t\t\t\t\t &entry1_h);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Could not add Channel VSI %d to flow group\\n\",\n\t\t\t\tidx);\n\t\t\tgoto err_unroll;\n\t\t}\n\n\t\tvsi_idx = ice_fdir_prof_vsi_idx(hw_prof,\n\t\t\t\t\t\tmain_vsi->tc_map_vsi[idx]->idx);\n\t\thw_prof->entry_h[vsi_idx][tun] = entry1_h;\n\t}\n\n\treturn 0;\n\nerr_unroll:\n\tentry1_h = 0;\n\thw_prof->fdir_seg[tun] = NULL;\n\n\t \n\tdel_last = true;\n\tfor (idx = 0; idx < ICE_FD_HW_SEG_MAX; idx++)\n\t\tif (hw_prof->fdir_seg[idx]) {\n\t\t\tdel_last = false;\n\t\t\tbreak;\n\t\t}\n\n\tfor (idx = 0; idx < hw_prof->cnt; idx++) {\n\t\tu16 vsi_num = ice_get_hw_vsi_num(hw, hw_prof->vsi_h[idx]);\n\n\t\tif (!hw_prof->entry_h[idx][tun])\n\t\t\tcontinue;\n\t\tice_rem_prof_id_flow(hw, ICE_BLK_FD, vsi_num, prof_id);\n\t\tice_flow_rem_entry(hw, ICE_BLK_FD, hw_prof->entry_h[idx][tun]);\n\t\thw_prof->entry_h[idx][tun] = 0;\n\t\tif (del_last)\n\t\t\thw_prof->vsi_h[idx] = 0;\n\t}\n\tif (del_last)\n\t\thw_prof->cnt = 0;\nerr_entry:\n\tice_rem_prof_id_flow(hw, ICE_BLK_FD,\n\t\t\t     ice_get_hw_vsi_num(hw, main_vsi->idx), prof_id);\n\tice_flow_rem_entry(hw, ICE_BLK_FD, entry1_h);\nerr_prof:\n\tice_flow_rem_prof(hw, ICE_BLK_FD, prof_id);\n\tdev_err(dev, \"Failed to add filter.  Flow director filters on each port must have the same input set.\\n\");\n\n\treturn err;\n}\n\n \nstatic int\nice_set_init_fdir_seg(struct ice_flow_seg_info *seg,\n\t\t      enum ice_flow_seg_hdr l3_proto,\n\t\t      enum ice_flow_seg_hdr l4_proto)\n{\n\tenum ice_flow_field src_addr, dst_addr, src_port, dst_port;\n\n\tif (!seg)\n\t\treturn -EINVAL;\n\n\tif (l3_proto == ICE_FLOW_SEG_HDR_IPV4) {\n\t\tsrc_addr = ICE_FLOW_FIELD_IDX_IPV4_SA;\n\t\tdst_addr = ICE_FLOW_FIELD_IDX_IPV4_DA;\n\t} else if (l3_proto == ICE_FLOW_SEG_HDR_IPV6) {\n\t\tsrc_addr = ICE_FLOW_FIELD_IDX_IPV6_SA;\n\t\tdst_addr = ICE_FLOW_FIELD_IDX_IPV6_DA;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (l4_proto == ICE_FLOW_SEG_HDR_TCP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_TCP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_TCP_DST_PORT;\n\t} else if (l4_proto == ICE_FLOW_SEG_HDR_UDP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_UDP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_UDP_DST_PORT;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tICE_FLOW_SET_HDRS(seg, l3_proto | l4_proto);\n\n\t \n\tice_flow_set_fld(seg, src_addr, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL, false);\n\n\t \n\tice_flow_set_fld(seg, dst_addr, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL, false);\n\n\t \n\tice_flow_set_fld(seg, src_port, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL, false);\n\n\t \n\tice_flow_set_fld(seg, dst_port, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL, false);\n\n\treturn 0;\n}\n\n \nstatic int\nice_create_init_fdir_rule(struct ice_pf *pf, enum ice_fltr_ptype flow)\n{\n\tstruct ice_flow_seg_info *seg, *tun_seg;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw *hw = &pf->hw;\n\tint ret;\n\n\t \n\tif (hw->fdir_prof && hw->fdir_prof[flow] &&\n\t    hw->fdir_prof[flow]->fdir_seg[0])\n\t\treturn -EINVAL;\n\n\tseg = devm_kzalloc(dev, sizeof(*seg), GFP_KERNEL);\n\tif (!seg)\n\t\treturn -ENOMEM;\n\n\ttun_seg = devm_kcalloc(dev, ICE_FD_HW_SEG_MAX, sizeof(*tun_seg),\n\t\t\t       GFP_KERNEL);\n\tif (!tun_seg) {\n\t\tdevm_kfree(dev, seg);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (flow == ICE_FLTR_PTYPE_NONF_IPV4_TCP)\n\t\tret = ice_set_init_fdir_seg(seg, ICE_FLOW_SEG_HDR_IPV4,\n\t\t\t\t\t    ICE_FLOW_SEG_HDR_TCP);\n\telse if (flow == ICE_FLTR_PTYPE_NONF_IPV4_UDP)\n\t\tret = ice_set_init_fdir_seg(seg, ICE_FLOW_SEG_HDR_IPV4,\n\t\t\t\t\t    ICE_FLOW_SEG_HDR_UDP);\n\telse if (flow == ICE_FLTR_PTYPE_NONF_IPV6_TCP)\n\t\tret = ice_set_init_fdir_seg(seg, ICE_FLOW_SEG_HDR_IPV6,\n\t\t\t\t\t    ICE_FLOW_SEG_HDR_TCP);\n\telse if (flow == ICE_FLTR_PTYPE_NONF_IPV6_UDP)\n\t\tret = ice_set_init_fdir_seg(seg, ICE_FLOW_SEG_HDR_IPV6,\n\t\t\t\t\t    ICE_FLOW_SEG_HDR_UDP);\n\telse\n\t\tret = -EINVAL;\n\tif (ret)\n\t\tgoto err_exit;\n\n\t \n\tret = ice_fdir_set_hw_fltr_rule(pf, seg, flow, ICE_FD_HW_SEG_NON_TUN);\n\tif (ret)\n\t\t \n\t\tgoto err_exit;\n\n\t \n\tmemcpy(&tun_seg[1], seg, sizeof(*seg));\n\tret = ice_fdir_set_hw_fltr_rule(pf, tun_seg, flow, ICE_FD_HW_SEG_TUN);\n\tif (ret)\n\t\t \n\t\tdevm_kfree(dev, tun_seg);\n\n\tset_bit(flow, hw->fdir_perfect_fltr);\n\treturn ret;\nerr_exit:\n\tdevm_kfree(dev, tun_seg);\n\tdevm_kfree(dev, seg);\n\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int\nice_set_fdir_ip4_seg(struct ice_flow_seg_info *seg,\n\t\t     struct ethtool_tcpip4_spec *tcp_ip4_spec,\n\t\t     enum ice_flow_seg_hdr l4_proto, bool *perfect_fltr)\n{\n\tenum ice_flow_field src_port, dst_port;\n\n\t \n\tif (!tcp_ip4_spec->psrc && !tcp_ip4_spec->ip4src &&\n\t    !tcp_ip4_spec->pdst && !tcp_ip4_spec->ip4dst)\n\t\treturn -EINVAL;\n\n\t \n\tif (tcp_ip4_spec->tos)\n\t\treturn -EOPNOTSUPP;\n\n\tif (l4_proto == ICE_FLOW_SEG_HDR_TCP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_TCP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_TCP_DST_PORT;\n\t} else if (l4_proto == ICE_FLOW_SEG_HDR_UDP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_UDP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_UDP_DST_PORT;\n\t} else if (l4_proto == ICE_FLOW_SEG_HDR_SCTP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_SCTP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_SCTP_DST_PORT;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*perfect_fltr = true;\n\tICE_FLOW_SET_HDRS(seg, ICE_FLOW_SEG_HDR_IPV4 | l4_proto);\n\n\t \n\tif (tcp_ip4_spec->ip4src == htonl(0xFFFFFFFF))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV4_SA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!tcp_ip4_spec->ip4src)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (tcp_ip4_spec->ip4dst == htonl(0xFFFFFFFF))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV4_DA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!tcp_ip4_spec->ip4dst)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (tcp_ip4_spec->psrc == htons(0xFFFF))\n\t\tice_flow_set_fld(seg, src_port, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t false);\n\telse if (!tcp_ip4_spec->psrc)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (tcp_ip4_spec->pdst == htons(0xFFFF))\n\t\tice_flow_set_fld(seg, dst_port, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t false);\n\telse if (!tcp_ip4_spec->pdst)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n \nstatic int\nice_set_fdir_ip4_usr_seg(struct ice_flow_seg_info *seg,\n\t\t\t struct ethtool_usrip4_spec *usr_ip4_spec,\n\t\t\t bool *perfect_fltr)\n{\n\t \n\tif (usr_ip4_spec->l4_4_bytes)\n\t\treturn -EINVAL;\n\tif (usr_ip4_spec->tos)\n\t\treturn -EINVAL;\n\tif (usr_ip4_spec->ip_ver)\n\t\treturn -EINVAL;\n\t \n\tif (usr_ip4_spec->proto)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (!usr_ip4_spec->ip4src && !usr_ip4_spec->ip4dst)\n\t\treturn -EINVAL;\n\n\t*perfect_fltr = true;\n\tICE_FLOW_SET_HDRS(seg, ICE_FLOW_SEG_HDR_IPV4);\n\n\t \n\tif (usr_ip4_spec->ip4src == htonl(0xFFFFFFFF))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV4_SA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!usr_ip4_spec->ip4src)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (usr_ip4_spec->ip4dst == htonl(0xFFFFFFFF))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV4_DA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!usr_ip4_spec->ip4dst)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n \nstatic int\nice_set_fdir_ip6_seg(struct ice_flow_seg_info *seg,\n\t\t     struct ethtool_tcpip6_spec *tcp_ip6_spec,\n\t\t     enum ice_flow_seg_hdr l4_proto, bool *perfect_fltr)\n{\n\tenum ice_flow_field src_port, dst_port;\n\n\t \n\tif (!memcmp(tcp_ip6_spec->ip6src, &zero_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)) &&\n\t    !memcmp(tcp_ip6_spec->ip6dst, &zero_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)) &&\n\t    !tcp_ip6_spec->psrc && !tcp_ip6_spec->pdst)\n\t\treturn -EINVAL;\n\n\t \n\tif (tcp_ip6_spec->tclass)\n\t\treturn -EOPNOTSUPP;\n\n\tif (l4_proto == ICE_FLOW_SEG_HDR_TCP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_TCP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_TCP_DST_PORT;\n\t} else if (l4_proto == ICE_FLOW_SEG_HDR_UDP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_UDP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_UDP_DST_PORT;\n\t} else if (l4_proto == ICE_FLOW_SEG_HDR_SCTP) {\n\t\tsrc_port = ICE_FLOW_FIELD_IDX_SCTP_SRC_PORT;\n\t\tdst_port = ICE_FLOW_FIELD_IDX_SCTP_DST_PORT;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t*perfect_fltr = true;\n\tICE_FLOW_SET_HDRS(seg, ICE_FLOW_SEG_HDR_IPV6 | l4_proto);\n\n\tif (!memcmp(tcp_ip6_spec->ip6src, &full_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV6_SA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!memcmp(tcp_ip6_spec->ip6src, &zero_ipv6_addr_mask,\n\t\t\t sizeof(struct in6_addr)))\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tif (!memcmp(tcp_ip6_spec->ip6dst, &full_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV6_DA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!memcmp(tcp_ip6_spec->ip6dst, &zero_ipv6_addr_mask,\n\t\t\t sizeof(struct in6_addr)))\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (tcp_ip6_spec->psrc == htons(0xFFFF))\n\t\tice_flow_set_fld(seg, src_port, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t false);\n\telse if (!tcp_ip6_spec->psrc)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (tcp_ip6_spec->pdst == htons(0xFFFF))\n\t\tice_flow_set_fld(seg, dst_port, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t false);\n\telse if (!tcp_ip6_spec->pdst)\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n \nstatic int\nice_set_fdir_ip6_usr_seg(struct ice_flow_seg_info *seg,\n\t\t\t struct ethtool_usrip6_spec *usr_ip6_spec,\n\t\t\t bool *perfect_fltr)\n{\n\t \n\tif (usr_ip6_spec->l4_4_bytes)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (usr_ip6_spec->tclass)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (usr_ip6_spec->l4_proto)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (!memcmp(usr_ip6_spec->ip6src, &zero_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)) &&\n\t    !memcmp(usr_ip6_spec->ip6dst, &zero_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)))\n\t\treturn -EINVAL;\n\n\t*perfect_fltr = true;\n\tICE_FLOW_SET_HDRS(seg, ICE_FLOW_SEG_HDR_IPV6);\n\n\tif (!memcmp(usr_ip6_spec->ip6src, &full_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV6_SA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!memcmp(usr_ip6_spec->ip6src, &zero_ipv6_addr_mask,\n\t\t\t sizeof(struct in6_addr)))\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tif (!memcmp(usr_ip6_spec->ip6dst, &full_ipv6_addr_mask,\n\t\t    sizeof(struct in6_addr)))\n\t\tice_flow_set_fld(seg, ICE_FLOW_FIELD_IDX_IPV6_DA,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t ICE_FLOW_FLD_OFF_INVAL, false);\n\telse if (!memcmp(usr_ip6_spec->ip6dst, &zero_ipv6_addr_mask,\n\t\t\t sizeof(struct in6_addr)))\n\t\t*perfect_fltr = false;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n \nstatic int\nice_cfg_fdir_xtrct_seq(struct ice_pf *pf, struct ethtool_rx_flow_spec *fsp,\n\t\t       struct ice_rx_flow_userdef *user)\n{\n\tstruct ice_flow_seg_info *seg, *tun_seg;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tenum ice_fltr_ptype fltr_idx;\n\tstruct ice_hw *hw = &pf->hw;\n\tbool perfect_filter;\n\tint ret;\n\n\tseg = devm_kzalloc(dev, sizeof(*seg), GFP_KERNEL);\n\tif (!seg)\n\t\treturn -ENOMEM;\n\n\ttun_seg = devm_kcalloc(dev, ICE_FD_HW_SEG_MAX, sizeof(*tun_seg),\n\t\t\t       GFP_KERNEL);\n\tif (!tun_seg) {\n\t\tdevm_kfree(dev, seg);\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (fsp->flow_type & ~FLOW_EXT) {\n\tcase TCP_V4_FLOW:\n\t\tret = ice_set_fdir_ip4_seg(seg, &fsp->m_u.tcp_ip4_spec,\n\t\t\t\t\t   ICE_FLOW_SEG_HDR_TCP,\n\t\t\t\t\t   &perfect_filter);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tret = ice_set_fdir_ip4_seg(seg, &fsp->m_u.tcp_ip4_spec,\n\t\t\t\t\t   ICE_FLOW_SEG_HDR_UDP,\n\t\t\t\t\t   &perfect_filter);\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\tret = ice_set_fdir_ip4_seg(seg, &fsp->m_u.tcp_ip4_spec,\n\t\t\t\t\t   ICE_FLOW_SEG_HDR_SCTP,\n\t\t\t\t\t   &perfect_filter);\n\t\tbreak;\n\tcase IPV4_USER_FLOW:\n\t\tret = ice_set_fdir_ip4_usr_seg(seg, &fsp->m_u.usr_ip4_spec,\n\t\t\t\t\t       &perfect_filter);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tret = ice_set_fdir_ip6_seg(seg, &fsp->m_u.tcp_ip6_spec,\n\t\t\t\t\t   ICE_FLOW_SEG_HDR_TCP,\n\t\t\t\t\t   &perfect_filter);\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tret = ice_set_fdir_ip6_seg(seg, &fsp->m_u.tcp_ip6_spec,\n\t\t\t\t\t   ICE_FLOW_SEG_HDR_UDP,\n\t\t\t\t\t   &perfect_filter);\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\tret = ice_set_fdir_ip6_seg(seg, &fsp->m_u.tcp_ip6_spec,\n\t\t\t\t\t   ICE_FLOW_SEG_HDR_SCTP,\n\t\t\t\t\t   &perfect_filter);\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tret = ice_set_fdir_ip6_usr_seg(seg, &fsp->m_u.usr_ip6_spec,\n\t\t\t\t\t       &perfect_filter);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tgoto err_exit;\n\n\t \n\tmemcpy(&tun_seg[1], seg, sizeof(*seg));\n\n\tif (user && user->flex_fltr) {\n\t\tperfect_filter = false;\n\t\tice_flow_add_fld_raw(seg, user->flex_offset,\n\t\t\t\t     ICE_FLTR_PRGM_FLEX_WORD_SIZE,\n\t\t\t\t     ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t     ICE_FLOW_FLD_OFF_INVAL);\n\t\tice_flow_add_fld_raw(&tun_seg[1], user->flex_offset,\n\t\t\t\t     ICE_FLTR_PRGM_FLEX_WORD_SIZE,\n\t\t\t\t     ICE_FLOW_FLD_OFF_INVAL,\n\t\t\t\t     ICE_FLOW_FLD_OFF_INVAL);\n\t}\n\n\tfltr_idx = ice_ethtool_flow_to_fltr(fsp->flow_type & ~FLOW_EXT);\n\n\tassign_bit(fltr_idx, hw->fdir_perfect_fltr, perfect_filter);\n\n\t \n\tret = ice_fdir_set_hw_fltr_rule(pf, seg, fltr_idx,\n\t\t\t\t\tICE_FD_HW_SEG_NON_TUN);\n\tif (ret == -EEXIST) {\n\t\t \n\t\tret = 0;\n\t\tgoto err_exit;\n\t} else if (ret) {\n\t\t \n\t\tgoto err_exit;\n\t}\n\n\t \n\tmemcpy(&tun_seg[1], seg, sizeof(*seg));\n\tret = ice_fdir_set_hw_fltr_rule(pf, tun_seg, fltr_idx,\n\t\t\t\t\tICE_FD_HW_SEG_TUN);\n\tif (ret == -EEXIST) {\n\t\t \n\t\tdevm_kfree(dev, tun_seg);\n\t\tret = 0;\n\t} else if (ret) {\n\t\t \n\t\tdevm_kfree(dev, tun_seg);\n\t}\n\n\treturn ret;\n\nerr_exit:\n\tdevm_kfree(dev, tun_seg);\n\tdevm_kfree(dev, seg);\n\n\treturn ret;\n}\n\n \nstatic void ice_update_per_q_fltr(struct ice_vsi *vsi, u32 q_index, bool inc)\n{\n\tstruct ice_rx_ring *rx_ring;\n\n\tif (!vsi->num_rxq || q_index >= vsi->num_rxq)\n\t\treturn;\n\n\trx_ring = vsi->rx_rings[q_index];\n\tif (!rx_ring || !rx_ring->ch)\n\t\treturn;\n\n\tif (inc)\n\t\tatomic_inc(&rx_ring->ch->num_sb_fltr);\n\telse\n\t\tatomic_dec_if_positive(&rx_ring->ch->num_sb_fltr);\n}\n\n \nint\nice_fdir_write_fltr(struct ice_pf *pf, struct ice_fdir_fltr *input, bool add,\n\t\t    bool is_tun)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_fltr_desc desc;\n\tstruct ice_vsi *ctrl_vsi;\n\tu8 *pkt, *frag_pkt;\n\tbool has_frag;\n\tint err;\n\n\tctrl_vsi = ice_get_ctrl_vsi(pf);\n\tif (!ctrl_vsi)\n\t\treturn -EINVAL;\n\n\tpkt = devm_kzalloc(dev, ICE_FDIR_MAX_RAW_PKT_SIZE, GFP_KERNEL);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\tfrag_pkt = devm_kzalloc(dev, ICE_FDIR_MAX_RAW_PKT_SIZE, GFP_KERNEL);\n\tif (!frag_pkt) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tice_fdir_get_prgm_desc(hw, input, &desc, add);\n\terr = ice_fdir_get_gen_prgm_pkt(hw, input, pkt, false, is_tun);\n\tif (err)\n\t\tgoto err_free_all;\n\terr = ice_prgm_fdir_fltr(ctrl_vsi, &desc, pkt);\n\tif (err)\n\t\tgoto err_free_all;\n\n\t \n\thas_frag = ice_fdir_has_frag(input->flow_type);\n\tif (has_frag) {\n\t\t \n\t\tice_fdir_get_prgm_desc(hw, input, &desc, add);\n\t\terr = ice_fdir_get_gen_prgm_pkt(hw, input, frag_pkt, true,\n\t\t\t\t\t\tis_tun);\n\t\tif (err)\n\t\t\tgoto err_frag;\n\t\terr = ice_prgm_fdir_fltr(ctrl_vsi, &desc, frag_pkt);\n\t\tif (err)\n\t\t\tgoto err_frag;\n\t} else {\n\t\tdevm_kfree(dev, frag_pkt);\n\t}\n\n\treturn 0;\n\nerr_free_all:\n\tdevm_kfree(dev, frag_pkt);\nerr_free:\n\tdevm_kfree(dev, pkt);\n\treturn err;\n\nerr_frag:\n\tdevm_kfree(dev, frag_pkt);\n\treturn err;\n}\n\n \nstatic int\nice_fdir_write_all_fltr(struct ice_pf *pf, struct ice_fdir_fltr *input,\n\t\t\tbool add)\n{\n\tu16 port_num;\n\tint tun;\n\n\tfor (tun = 0; tun < ICE_FD_HW_SEG_MAX; tun++) {\n\t\tbool is_tun = tun == ICE_FD_HW_SEG_TUN;\n\t\tint err;\n\n\t\tif (is_tun && !ice_get_open_tunnel_port(&pf->hw, &port_num, TNL_ALL))\n\t\t\tcontinue;\n\t\terr = ice_fdir_write_fltr(pf, input, add, is_tun);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nvoid ice_fdir_replay_fltrs(struct ice_pf *pf)\n{\n\tstruct ice_fdir_fltr *f_rule;\n\tstruct ice_hw *hw = &pf->hw;\n\n\tlist_for_each_entry(f_rule, &hw->fdir_list_head, fltr_node) {\n\t\tint err = ice_fdir_write_all_fltr(pf, f_rule, true);\n\n\t\tif (err)\n\t\t\tdev_dbg(ice_pf_to_dev(pf), \"Flow Director error %d, could not reprogram filter %d\\n\",\n\t\t\t\terr, f_rule->fltr_id);\n\t}\n}\n\n \nint ice_fdir_create_dflt_rules(struct ice_pf *pf)\n{\n\tint err;\n\n\t \n\terr = ice_create_init_fdir_rule(pf, ICE_FLTR_PTYPE_NONF_IPV4_TCP);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_create_init_fdir_rule(pf, ICE_FLTR_PTYPE_NONF_IPV4_UDP);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_create_init_fdir_rule(pf, ICE_FLTR_PTYPE_NONF_IPV6_TCP);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_create_init_fdir_rule(pf, ICE_FLTR_PTYPE_NONF_IPV6_UDP);\n\n\treturn err;\n}\n\n \nvoid ice_fdir_del_all_fltrs(struct ice_vsi *vsi)\n{\n\tstruct ice_fdir_fltr *f_rule, *tmp;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\n\tlist_for_each_entry_safe(f_rule, tmp, &hw->fdir_list_head, fltr_node) {\n\t\tice_fdir_write_all_fltr(pf, f_rule, false);\n\t\tice_fdir_update_cntrs(hw, f_rule->flow_type, false);\n\t\tlist_del(&f_rule->fltr_node);\n\t\tdevm_kfree(ice_pf_to_dev(pf), f_rule);\n\t}\n}\n\n \nvoid ice_vsi_manage_fdir(struct ice_vsi *vsi, bool ena)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tenum ice_fltr_ptype flow;\n\n\tif (ena) {\n\t\tset_bit(ICE_FLAG_FD_ENA, pf->flags);\n\t\tice_fdir_create_dflt_rules(pf);\n\t\treturn;\n\t}\n\n\tmutex_lock(&hw->fdir_fltr_lock);\n\tif (!test_and_clear_bit(ICE_FLAG_FD_ENA, pf->flags))\n\t\tgoto release_lock;\n\n\tice_fdir_del_all_fltrs(vsi);\n\n\tif (hw->fdir_prof)\n\t\tfor (flow = ICE_FLTR_PTYPE_NONF_NONE; flow < ICE_FLTR_PTYPE_MAX;\n\t\t     flow++)\n\t\t\tif (hw->fdir_prof[flow])\n\t\t\t\tice_fdir_rem_flow(hw, ICE_BLK_FD, flow);\n\nrelease_lock:\n\tmutex_unlock(&hw->fdir_fltr_lock);\n}\n\n \nstatic void\nice_fdir_do_rem_flow(struct ice_pf *pf, enum ice_fltr_ptype flow_type)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tbool need_perfect = false;\n\n\tif (flow_type == ICE_FLTR_PTYPE_NONF_IPV4_TCP ||\n\t    flow_type == ICE_FLTR_PTYPE_NONF_IPV4_UDP ||\n\t    flow_type == ICE_FLTR_PTYPE_NONF_IPV6_TCP ||\n\t    flow_type == ICE_FLTR_PTYPE_NONF_IPV6_UDP)\n\t\tneed_perfect = true;\n\n\tif (need_perfect && test_bit(flow_type, hw->fdir_perfect_fltr))\n\t\treturn;\n\n\tice_fdir_rem_flow(hw, ICE_BLK_FD, flow_type);\n\tif (need_perfect)\n\t\tice_create_init_fdir_rule(pf, flow_type);\n}\n\n \nstatic int\nice_fdir_update_list_entry(struct ice_pf *pf, struct ice_fdir_fltr *input,\n\t\t\t   int fltr_idx)\n{\n\tstruct ice_fdir_fltr *old_fltr;\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_vsi *vsi;\n\tint err = -ENOENT;\n\n\t \n\tif (ice_is_reset_in_progress(pf->state))\n\t\treturn -EBUSY;\n\n\tvsi = ice_get_main_vsi(pf);\n\tif (!vsi)\n\t\treturn -EINVAL;\n\n\told_fltr = ice_fdir_find_fltr_by_idx(hw, fltr_idx);\n\tif (old_fltr) {\n\t\terr = ice_fdir_write_all_fltr(pf, old_fltr, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tice_fdir_update_cntrs(hw, old_fltr->flow_type, false);\n\t\t \n\t\tice_update_per_q_fltr(vsi, old_fltr->orig_q_index, false);\n\t\tif (!input && !hw->fdir_fltr_cnt[old_fltr->flow_type])\n\t\t\t \n\t\t\tice_fdir_do_rem_flow(pf, old_fltr->flow_type);\n\t\tlist_del(&old_fltr->fltr_node);\n\t\tdevm_kfree(ice_hw_to_dev(hw), old_fltr);\n\t}\n\tif (!input)\n\t\treturn err;\n\tice_fdir_list_add_fltr(hw, input);\n\t \n\tice_update_per_q_fltr(vsi, input->orig_q_index, true);\n\tice_fdir_update_cntrs(hw, input->flow_type, true);\n\treturn 0;\n}\n\n \nint ice_del_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tint val;\n\n\tif (!test_bit(ICE_FLAG_FD_ENA, pf->flags))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (ice_is_reset_in_progress(pf->state)) {\n\t\tdev_err(ice_pf_to_dev(pf), \"Device is resetting - deleting Flow Director filters not supported during reset\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(ICE_FD_FLUSH_REQ, pf->state))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&hw->fdir_fltr_lock);\n\tval = ice_fdir_update_list_entry(pf, NULL, fsp->location);\n\tmutex_unlock(&hw->fdir_fltr_lock);\n\n\treturn val;\n}\n\n \nstatic void\nice_update_ring_dest_vsi(struct ice_vsi *vsi, u16 *dest_vsi, u32 *ring)\n{\n\tstruct ice_channel *ch;\n\n\tlist_for_each_entry(ch, &vsi->ch_list, list) {\n\t\tif (!ch->ch_vsi)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((*ring < ch->base_q) ||\n\t\t    (*ring >= (ch->base_q + ch->num_rxq)))\n\t\t\tcontinue;\n\n\t\t \n\t\t*dest_vsi = ch->ch_vsi->idx;\n\n\t\t \n\t\t*ring -= ch->base_q;\n\t}\n}\n\n \nstatic int\nice_set_fdir_input_set(struct ice_vsi *vsi, struct ethtool_rx_flow_spec *fsp,\n\t\t       struct ice_fdir_fltr *input)\n{\n\tu16 dest_vsi, q_index = 0;\n\tu16 orig_q_index = 0;\n\tstruct ice_pf *pf;\n\tstruct ice_hw *hw;\n\tint flow_type;\n\tu8 dest_ctl;\n\n\tif (!vsi || !fsp || !input)\n\t\treturn -EINVAL;\n\n\tpf = vsi->back;\n\thw = &pf->hw;\n\n\tdest_vsi = vsi->idx;\n\tif (fsp->ring_cookie == RX_CLS_FLOW_DISC) {\n\t\tdest_ctl = ICE_FLTR_PRGM_DESC_DEST_DROP_PKT;\n\t} else {\n\t\tu32 ring = ethtool_get_flow_spec_ring(fsp->ring_cookie);\n\t\tu8 vf = ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);\n\n\t\tif (vf) {\n\t\t\tdev_err(ice_pf_to_dev(pf), \"Failed to add filter. Flow director filters are not supported on VF queues.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ring >= vsi->num_rxq)\n\t\t\treturn -EINVAL;\n\n\t\torig_q_index = ring;\n\t\tice_update_ring_dest_vsi(vsi, &dest_vsi, &ring);\n\t\tdest_ctl = ICE_FLTR_PRGM_DESC_DEST_DIRECT_PKT_QINDEX;\n\t\tq_index = ring;\n\t}\n\n\tinput->fltr_id = fsp->location;\n\tinput->q_index = q_index;\n\tflow_type = fsp->flow_type & ~FLOW_EXT;\n\n\t \n\tinput->orig_q_index = orig_q_index;\n\tinput->dest_vsi = dest_vsi;\n\tinput->dest_ctl = dest_ctl;\n\tinput->fltr_status = ICE_FLTR_PRGM_DESC_FD_STATUS_FD_ID;\n\tinput->cnt_index = ICE_FD_SB_STAT_IDX(hw->fd_ctr_base);\n\tinput->flow_type = ice_ethtool_flow_to_fltr(flow_type);\n\n\tif (fsp->flow_type & FLOW_EXT) {\n\t\tmemcpy(input->ext_data.usr_def, fsp->h_ext.data,\n\t\t       sizeof(input->ext_data.usr_def));\n\t\tinput->ext_data.vlan_type = fsp->h_ext.vlan_etype;\n\t\tinput->ext_data.vlan_tag = fsp->h_ext.vlan_tci;\n\t\tmemcpy(input->ext_mask.usr_def, fsp->m_ext.data,\n\t\t       sizeof(input->ext_mask.usr_def));\n\t\tinput->ext_mask.vlan_type = fsp->m_ext.vlan_etype;\n\t\tinput->ext_mask.vlan_tag = fsp->m_ext.vlan_tci;\n\t}\n\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tinput->ip.v4.dst_port = fsp->h_u.tcp_ip4_spec.pdst;\n\t\tinput->ip.v4.src_port = fsp->h_u.tcp_ip4_spec.psrc;\n\t\tinput->ip.v4.dst_ip = fsp->h_u.tcp_ip4_spec.ip4dst;\n\t\tinput->ip.v4.src_ip = fsp->h_u.tcp_ip4_spec.ip4src;\n\t\tinput->mask.v4.dst_port = fsp->m_u.tcp_ip4_spec.pdst;\n\t\tinput->mask.v4.src_port = fsp->m_u.tcp_ip4_spec.psrc;\n\t\tinput->mask.v4.dst_ip = fsp->m_u.tcp_ip4_spec.ip4dst;\n\t\tinput->mask.v4.src_ip = fsp->m_u.tcp_ip4_spec.ip4src;\n\t\tbreak;\n\tcase IPV4_USER_FLOW:\n\t\tinput->ip.v4.dst_ip = fsp->h_u.usr_ip4_spec.ip4dst;\n\t\tinput->ip.v4.src_ip = fsp->h_u.usr_ip4_spec.ip4src;\n\t\tinput->ip.v4.l4_header = fsp->h_u.usr_ip4_spec.l4_4_bytes;\n\t\tinput->ip.v4.proto = fsp->h_u.usr_ip4_spec.proto;\n\t\tinput->ip.v4.ip_ver = fsp->h_u.usr_ip4_spec.ip_ver;\n\t\tinput->ip.v4.tos = fsp->h_u.usr_ip4_spec.tos;\n\t\tinput->mask.v4.dst_ip = fsp->m_u.usr_ip4_spec.ip4dst;\n\t\tinput->mask.v4.src_ip = fsp->m_u.usr_ip4_spec.ip4src;\n\t\tinput->mask.v4.l4_header = fsp->m_u.usr_ip4_spec.l4_4_bytes;\n\t\tinput->mask.v4.proto = fsp->m_u.usr_ip4_spec.proto;\n\t\tinput->mask.v4.ip_ver = fsp->m_u.usr_ip4_spec.ip_ver;\n\t\tinput->mask.v4.tos = fsp->m_u.usr_ip4_spec.tos;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tmemcpy(input->ip.v6.dst_ip, fsp->h_u.usr_ip6_spec.ip6dst,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(input->ip.v6.src_ip, fsp->h_u.usr_ip6_spec.ip6src,\n\t\t       sizeof(struct in6_addr));\n\t\tinput->ip.v6.dst_port = fsp->h_u.tcp_ip6_spec.pdst;\n\t\tinput->ip.v6.src_port = fsp->h_u.tcp_ip6_spec.psrc;\n\t\tinput->ip.v6.tc = fsp->h_u.tcp_ip6_spec.tclass;\n\t\tmemcpy(input->mask.v6.dst_ip, fsp->m_u.tcp_ip6_spec.ip6dst,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(input->mask.v6.src_ip, fsp->m_u.tcp_ip6_spec.ip6src,\n\t\t       sizeof(struct in6_addr));\n\t\tinput->mask.v6.dst_port = fsp->m_u.tcp_ip6_spec.pdst;\n\t\tinput->mask.v6.src_port = fsp->m_u.tcp_ip6_spec.psrc;\n\t\tinput->mask.v6.tc = fsp->m_u.tcp_ip6_spec.tclass;\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tmemcpy(input->ip.v6.dst_ip, fsp->h_u.usr_ip6_spec.ip6dst,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(input->ip.v6.src_ip, fsp->h_u.usr_ip6_spec.ip6src,\n\t\t       sizeof(struct in6_addr));\n\t\tinput->ip.v6.l4_header = fsp->h_u.usr_ip6_spec.l4_4_bytes;\n\t\tinput->ip.v6.tc = fsp->h_u.usr_ip6_spec.tclass;\n\n\t\t \n\t\tif (!fsp->m_u.usr_ip6_spec.l4_proto)\n\t\t\tinput->ip.v6.proto = IPPROTO_NONE;\n\t\telse\n\t\t\tinput->ip.v6.proto = fsp->h_u.usr_ip6_spec.l4_proto;\n\n\t\tmemcpy(input->mask.v6.dst_ip, fsp->m_u.usr_ip6_spec.ip6dst,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(input->mask.v6.src_ip, fsp->m_u.usr_ip6_spec.ip6src,\n\t\t       sizeof(struct in6_addr));\n\t\tinput->mask.v6.l4_header = fsp->m_u.usr_ip6_spec.l4_4_bytes;\n\t\tinput->mask.v6.tc = fsp->m_u.usr_ip6_spec.tclass;\n\t\tinput->mask.v6.proto = fsp->m_u.usr_ip6_spec.l4_proto;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint ice_add_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd)\n{\n\tstruct ice_rx_flow_userdef userdata;\n\tstruct ethtool_rx_flow_spec *fsp;\n\tstruct ice_fdir_fltr *input;\n\tstruct device *dev;\n\tstruct ice_pf *pf;\n\tstruct ice_hw *hw;\n\tint fltrs_needed;\n\tu16 tunnel_port;\n\tint ret;\n\n\tif (!vsi)\n\t\treturn -EINVAL;\n\n\tpf = vsi->back;\n\thw = &pf->hw;\n\tdev = ice_pf_to_dev(pf);\n\n\tif (!test_bit(ICE_FLAG_FD_ENA, pf->flags))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (ice_is_reset_in_progress(pf->state)) {\n\t\tdev_err(dev, \"Device is resetting - adding Flow Director filters not supported during reset\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfsp = (struct ethtool_rx_flow_spec *)&cmd->fs;\n\n\tif (ice_parse_rx_flow_user_data(fsp, &userdata))\n\t\treturn -EINVAL;\n\n\tif (fsp->flow_type & FLOW_MAC_EXT)\n\t\treturn -EINVAL;\n\n\tret = ice_cfg_fdir_xtrct_seq(pf, fsp, &userdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fsp->location >= ice_get_fdir_cnt_all(hw)) {\n\t\tdev_err(dev, \"Failed to add filter.  The maximum number of flow director filters has been reached.\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tfltrs_needed = ice_get_open_tunnel_port(hw, &tunnel_port, TNL_ALL) ? 2 : 1;\n\tif (!ice_fdir_find_fltr_by_idx(hw, fsp->location) &&\n\t    ice_fdir_num_avail_fltr(hw, pf->vsi[vsi->idx]) < fltrs_needed) {\n\t\tdev_err(dev, \"Failed to add filter.  The maximum number of flow director filters has been reached.\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tinput = devm_kzalloc(dev, sizeof(*input), GFP_KERNEL);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tret = ice_set_fdir_input_set(vsi, fsp, input);\n\tif (ret)\n\t\tgoto free_input;\n\n\tmutex_lock(&hw->fdir_fltr_lock);\n\tif (ice_fdir_is_dup_fltr(hw, input)) {\n\t\tret = -EINVAL;\n\t\tgoto release_lock;\n\t}\n\n\tif (userdata.flex_fltr) {\n\t\tinput->flex_fltr = true;\n\t\tinput->flex_word = cpu_to_be16(userdata.flex_word);\n\t\tinput->flex_offset = userdata.flex_offset;\n\t}\n\n\tinput->cnt_ena = ICE_FXD_FLTR_QW0_STAT_ENA_PKTS;\n\tinput->fdid_prio = ICE_FXD_FLTR_QW1_FDID_PRI_THREE;\n\tinput->comp_report = ICE_FXD_FLTR_QW0_COMP_REPORT_SW_FAIL;\n\n\t \n\tret = ice_fdir_update_list_entry(pf, input, fsp->location);\n\tif (ret)\n\t\tgoto release_lock;\n\n\tret = ice_fdir_write_all_fltr(pf, input, true);\n\tif (ret)\n\t\tgoto remove_sw_rule;\n\n\tgoto release_lock;\n\nremove_sw_rule:\n\tice_fdir_update_cntrs(hw, input->flow_type, false);\n\t \n\tice_update_per_q_fltr(vsi, input->orig_q_index, false);\n\tlist_del(&input->fltr_node);\nrelease_lock:\n\tmutex_unlock(&hw->fdir_fltr_lock);\nfree_input:\n\tif (ret)\n\t\tdevm_kfree(dev, input);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}