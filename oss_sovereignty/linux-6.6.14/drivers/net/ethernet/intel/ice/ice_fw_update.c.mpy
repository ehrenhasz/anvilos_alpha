{
  "module_name": "ice_fw_update.c",
  "hash_id": "c7aceb8bca14dce9b94b117ef1ec843fbe37fb3d019dffbf28666682ec54f1a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_fw_update.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n#include <linux/crc32.h>\n#include <linux/pldmfw.h>\n#include \"ice.h\"\n#include \"ice_fw_update.h\"\n\nstruct ice_fwu_priv {\n\tstruct pldmfw context;\n\n\tstruct ice_pf *pf;\n\tstruct netlink_ext_ack *extack;\n\n\t \n\tu8 activate_flags;\n\n\t \n\tu8 reset_level;\n\n\t \n\tu8 emp_reset_available;\n};\n\n \nstatic int\nice_send_package_data(struct pldmfw *context, const u8 *data, u16 length)\n{\n\tstruct ice_fwu_priv *priv = container_of(context, struct ice_fwu_priv, context);\n\tstruct netlink_ext_ack *extack = priv->extack;\n\tstruct device *dev = context->dev;\n\tstruct ice_pf *pf = priv->pf;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 *package_data;\n\tint status;\n\n\tdev_dbg(dev, \"Sending PLDM record package data to firmware\\n\");\n\n\tpackage_data = kmemdup(data, length, GFP_KERNEL);\n\tif (!package_data)\n\t\treturn -ENOMEM;\n\n\tstatus = ice_nvm_set_pkg_data(hw, false, package_data, length, NULL);\n\n\tkfree(package_data);\n\n\tif (status) {\n\t\tdev_err(dev, \"Failed to send record package data to firmware, err %d aq_err %s\\n\",\n\t\t\tstatus, ice_aq_str(hw->adminq.sq_last_status));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to record package data to firmware\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_check_component_response(struct ice_pf *pf, u16 id, u8 response, u8 code,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tconst char *component;\n\n\tswitch (id) {\n\tcase NVM_COMP_ID_OROM:\n\t\tcomponent = \"fw.undi\";\n\t\tbreak;\n\tcase NVM_COMP_ID_NVM:\n\t\tcomponent = \"fw.mgmt\";\n\t\tbreak;\n\tcase NVM_COMP_ID_NETLIST:\n\t\tcomponent = \"fw.netlist\";\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unexpected unknown component identifier 0x%02x\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s: firmware response 0x%x, code 0x%x\\n\",\n\t\tcomponent, response, code);\n\n\tswitch (response) {\n\tcase ICE_AQ_NVM_PASS_COMP_CAN_BE_UPDATED:\n\t\t \n\t\treturn 0;\n\tcase ICE_AQ_NVM_PASS_COMP_CAN_MAY_BE_UPDATEABLE:\n\t\tdev_warn(dev, \"firmware recommends not updating %s, as it may result in a downgrade. continuing anyways\\n\", component);\n\t\treturn 0;\n\tcase ICE_AQ_NVM_PASS_COMP_CAN_NOT_BE_UPDATED:\n\t\tdev_info(dev, \"firmware has rejected updating %s\\n\", component);\n\t\tbreak;\n\t}\n\n\tswitch (code) {\n\tcase ICE_AQ_NVM_PASS_COMP_STAMP_IDENTICAL_CODE:\n\t\tdev_err(dev, \"Component comparison stamp for %s is identical to the running image\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component comparison stamp is identical to running image\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_STAMP_LOWER:\n\t\tdev_err(dev, \"Component comparison stamp for %s is lower than the running image\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component comparison stamp is lower than running image\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_INVALID_STAMP_CODE:\n\t\tdev_err(dev, \"Component comparison stamp for %s is invalid\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component comparison stamp is invalid\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_CONFLICT_CODE:\n\t\tdev_err(dev, \"%s conflicts with a previous component table\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component table conflict occurred\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_PRE_REQ_NOT_MET_CODE:\n\t\tdev_err(dev, \"Pre-requisites for component %s have not been met\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component pre-requisites not met\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_NOT_SUPPORTED_CODE:\n\t\tdev_err(dev, \"%s is not a supported component\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component not supported\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_CANNOT_DOWNGRADE_CODE:\n\t\tdev_err(dev, \"Security restrictions prevent %s from being downgraded\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component cannot be downgraded\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_INCOMPLETE_IMAGE_CODE:\n\t\tdev_err(dev, \"Received an incomplete component image for %s\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Incomplete component image\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_VER_STR_IDENTICAL_CODE:\n\t\tdev_err(dev, \"Component version for %s is identical to the running image\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component version is identical to running image\");\n\t\tbreak;\n\tcase ICE_AQ_NVM_PASS_COMP_VER_STR_LOWER_CODE:\n\t\tdev_err(dev, \"Component version for %s is lower than the running image\\n\",\n\t\t\tcomponent);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Component version is lower than the running image\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unexpected response code 0x02%x for %s\\n\",\n\t\t\tcode, component);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Received unexpected response code from firmware\");\n\t\tbreak;\n\t}\n\n\treturn -ECANCELED;\n}\n\n \nstatic int\nice_send_component_table(struct pldmfw *context, struct pldmfw_component *component,\n\t\t\t u8 transfer_flag)\n{\n\tstruct ice_fwu_priv *priv = container_of(context, struct ice_fwu_priv, context);\n\tstruct netlink_ext_ack *extack = priv->extack;\n\tstruct ice_aqc_nvm_comp_tbl *comp_tbl;\n\tu8 comp_response, comp_response_code;\n\tstruct device *dev = context->dev;\n\tstruct ice_pf *pf = priv->pf;\n\tstruct ice_hw *hw = &pf->hw;\n\tsize_t length;\n\tint status;\n\n\tswitch (component->identifier) {\n\tcase NVM_COMP_ID_OROM:\n\tcase NVM_COMP_ID_NVM:\n\tcase NVM_COMP_ID_NETLIST:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unable to update due to a firmware component with unknown ID %u\\n\",\n\t\t\tcomponent->identifier);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unable to update due to unknown firmware component\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlength = struct_size(comp_tbl, cvs, component->version_len);\n\tcomp_tbl = kzalloc(length, GFP_KERNEL);\n\tif (!comp_tbl)\n\t\treturn -ENOMEM;\n\n\tcomp_tbl->comp_class = cpu_to_le16(component->classification);\n\tcomp_tbl->comp_id = cpu_to_le16(component->identifier);\n\tcomp_tbl->comp_class_idx = FWU_COMP_CLASS_IDX_NOT_USE;\n\tcomp_tbl->comp_cmp_stamp = cpu_to_le32(component->comparison_stamp);\n\tcomp_tbl->cvs_type = component->version_type;\n\tcomp_tbl->cvs_len = component->version_len;\n\tmemcpy(comp_tbl->cvs, component->version_string, component->version_len);\n\n\tdev_dbg(dev, \"Sending component table to firmware:\\n\");\n\n\tstatus = ice_nvm_pass_component_tbl(hw, (u8 *)comp_tbl, length,\n\t\t\t\t\t    transfer_flag, &comp_response,\n\t\t\t\t\t    &comp_response_code, NULL);\n\n\tkfree(comp_tbl);\n\n\tif (status) {\n\t\tdev_err(dev, \"Failed to transfer component table to firmware, err %d aq_err %s\\n\",\n\t\t\tstatus, ice_aq_str(hw->adminq.sq_last_status));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to transfer component table to firmware\");\n\t\treturn -EIO;\n\t}\n\n\treturn ice_check_component_response(pf, component->identifier, comp_response,\n\t\t\t\t\t    comp_response_code, extack);\n}\n\n \nstatic int\nice_write_one_nvm_block(struct ice_pf *pf, u16 module, u32 offset,\n\t\t\tu16 block_size, u8 *block, bool last_cmd,\n\t\t\tu8 *reset_level, struct netlink_ext_ack *extack)\n{\n\tu16 completion_module, completion_retval;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_aq_task task = {};\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_aq_desc *desc;\n\tu32 completion_offset;\n\tint err;\n\n\tdev_dbg(dev, \"Writing block of %u bytes for module 0x%02x at offset %u\\n\",\n\t\tblock_size, module, offset);\n\n\tice_aq_prep_for_event(pf, &task, ice_aqc_opc_nvm_write);\n\n\terr = ice_aq_update_nvm(hw, module, offset, block_size, block,\n\t\t\t\tlast_cmd, 0, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to flash module 0x%02x with block of size %u at offset %u, err %d aq_err %s\\n\",\n\t\t\tmodule, block_size, offset, err,\n\t\t\tice_aq_str(hw->adminq.sq_last_status));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to program flash module\");\n\t\treturn -EIO;\n\t}\n\n\t \n\terr = ice_aq_wait_for_event(pf, &task, 15 * HZ);\n\tif (err) {\n\t\tdev_err(dev, \"Timed out while trying to flash module 0x%02x with block of size %u at offset %u, err %d\\n\",\n\t\t\tmodule, block_size, offset, err);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Timed out waiting for firmware\");\n\t\treturn -EIO;\n\t}\n\n\tdesc = &task.event.desc;\n\tcompletion_module = le16_to_cpu(desc->params.nvm.module_typeid);\n\tcompletion_retval = le16_to_cpu(desc->retval);\n\n\tcompletion_offset = le16_to_cpu(desc->params.nvm.offset_low);\n\tcompletion_offset |= desc->params.nvm.offset_high << 16;\n\n\tif (completion_module != module) {\n\t\tdev_err(dev, \"Unexpected module_typeid in write completion: got 0x%x, expected 0x%x\\n\",\n\t\t\tcompletion_module, module);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unexpected firmware response\");\n\t\treturn -EIO;\n\t}\n\n\tif (completion_offset != offset) {\n\t\tdev_err(dev, \"Unexpected offset in write completion: got %u, expected %u\\n\",\n\t\t\tcompletion_offset, offset);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unexpected firmware response\");\n\t\treturn -EIO;\n\t}\n\n\tif (completion_retval) {\n\t\tdev_err(dev, \"Firmware failed to flash module 0x%02x with block of size %u at offset %u, err %s\\n\",\n\t\t\tmodule, block_size, offset,\n\t\t\tice_aq_str((enum ice_aq_err)completion_retval));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware failed to program flash module\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (reset_level && last_cmd && module == ICE_SR_1ST_NVM_BANK_PTR) {\n\t\tif (hw->dev_caps.common_cap.pcie_reset_avoidance) {\n\t\t\t*reset_level = desc->params.nvm.cmd_flags &\n\t\t\t\t       ICE_AQC_NVM_RESET_LVL_M;\n\t\t\tdev_dbg(dev, \"Firmware reported required reset level as %u\\n\",\n\t\t\t\t*reset_level);\n\t\t} else {\n\t\t\t*reset_level = ICE_AQC_NVM_POR_FLAG;\n\t\t\tdev_dbg(dev, \"Firmware doesn't support indicating required reset level. Assuming a power cycle is required\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_write_nvm_module(struct ice_pf *pf, u16 module, const char *component,\n\t\t     const u8 *image, u32 length, u8 *reset_level,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct devlink *devlink;\n\tu32 offset = 0;\n\tbool last_cmd;\n\tu8 *block;\n\tint err;\n\n\tdev_dbg(dev, \"Beginning write of flash component '%s', module 0x%02x\\n\", component, module);\n\n\tdevlink = priv_to_devlink(pf);\n\n\tdevlink_flash_update_status_notify(devlink, \"Flashing\",\n\t\t\t\t\t   component, 0, length);\n\n\tblock = kzalloc(ICE_AQ_MAX_BUF_LEN, GFP_KERNEL);\n\tif (!block)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tu32 block_size;\n\n\t\tblock_size = min_t(u32, ICE_AQ_MAX_BUF_LEN, length - offset);\n\t\tlast_cmd = !(offset + block_size < length);\n\n\t\t \n\t\tmemcpy(block, image + offset, block_size);\n\n\t\terr = ice_write_one_nvm_block(pf, module, offset, block_size,\n\t\t\t\t\t      block, last_cmd, reset_level,\n\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\toffset += block_size;\n\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing\",\n\t\t\t\t\t\t   component, offset, length);\n\t} while (!last_cmd);\n\n\tdev_dbg(dev, \"Completed write of flash component '%s', module 0x%02x\\n\", component, module);\n\n\tif (err)\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing failed\",\n\t\t\t\t\t\t   component, length, length);\n\telse\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing done\",\n\t\t\t\t\t\t   component, length, length);\n\n\tkfree(block);\n\treturn err;\n}\n\n \n#define ICE_FW_ERASE_TIMEOUT 300\n\n \nstatic int\nice_erase_nvm_module(struct ice_pf *pf, u16 module, const char *component,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tu16 completion_module, completion_retval;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_aq_task task = {};\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_aq_desc *desc;\n\tstruct devlink *devlink;\n\tint err;\n\n\tdev_dbg(dev, \"Beginning erase of flash component '%s', module 0x%02x\\n\", component, module);\n\n\tdevlink = priv_to_devlink(pf);\n\n\tdevlink_flash_update_timeout_notify(devlink, \"Erasing\", component, ICE_FW_ERASE_TIMEOUT);\n\n\tice_aq_prep_for_event(pf, &task, ice_aqc_opc_nvm_erase);\n\n\terr = ice_aq_erase_nvm(hw, module, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to erase %s (module 0x%02x), err %d aq_err %s\\n\",\n\t\t\tcomponent, module, err,\n\t\t\tice_aq_str(hw->adminq.sq_last_status));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to erase flash module\");\n\t\terr = -EIO;\n\t\tgoto out_notify_devlink;\n\t}\n\n\terr = ice_aq_wait_for_event(pf, &task, ICE_FW_ERASE_TIMEOUT * HZ);\n\tif (err) {\n\t\tdev_err(dev, \"Timed out waiting for firmware to respond with erase completion for %s (module 0x%02x), err %d\\n\",\n\t\t\tcomponent, module, err);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Timed out waiting for firmware\");\n\t\tgoto out_notify_devlink;\n\t}\n\n\tdesc = &task.event.desc;\n\tcompletion_module = le16_to_cpu(desc->params.nvm.module_typeid);\n\tcompletion_retval = le16_to_cpu(desc->retval);\n\n\tif (completion_module != module) {\n\t\tdev_err(dev, \"Unexpected module_typeid in erase completion for %s: got 0x%x, expected 0x%x\\n\",\n\t\t\tcomponent, completion_module, module);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unexpected firmware response\");\n\t\terr = -EIO;\n\t\tgoto out_notify_devlink;\n\t}\n\n\tif (completion_retval) {\n\t\tdev_err(dev, \"Firmware failed to erase %s (module 0x02%x), aq_err %s\\n\",\n\t\t\tcomponent, module,\n\t\t\tice_aq_str((enum ice_aq_err)completion_retval));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware failed to erase flash\");\n\t\terr = -EIO;\n\t\tgoto out_notify_devlink;\n\t}\n\n\tdev_dbg(dev, \"Completed erase of flash component '%s', module 0x%02x\\n\", component, module);\n\nout_notify_devlink:\n\tif (err)\n\t\tdevlink_flash_update_status_notify(devlink, \"Erasing failed\",\n\t\t\t\t\t\t   component, 0, 0);\n\telse\n\t\tdevlink_flash_update_status_notify(devlink, \"Erasing done\",\n\t\t\t\t\t\t   component, 0, 0);\n\n\treturn err;\n}\n\n \nstatic int\nice_switch_flash_banks(struct ice_pf *pf, u8 activate_flags,\n\t\t       u8 *emp_reset_available, struct netlink_ext_ack *extack)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_aq_task task = {};\n\tstruct ice_hw *hw = &pf->hw;\n\tu16 completion_retval;\n\tu8 response_flags;\n\tint err;\n\n\tice_aq_prep_for_event(pf, &task, ice_aqc_opc_nvm_write_activate);\n\n\terr = ice_nvm_write_activate(hw, activate_flags, &response_flags);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to switch active flash banks, err %d aq_err %s\\n\",\n\t\t\terr, ice_aq_str(hw->adminq.sq_last_status));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to switch active flash banks\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (emp_reset_available) {\n\t\tif (hw->dev_caps.common_cap.reset_restrict_support) {\n\t\t\t*emp_reset_available = response_flags & ICE_AQC_NVM_EMPR_ENA;\n\t\t\tdev_dbg(dev, \"Firmware indicated that EMP reset is %s\\n\",\n\t\t\t\t*emp_reset_available ?\n\t\t\t\t\"available\" : \"not available\");\n\t\t} else {\n\t\t\t*emp_reset_available = ICE_AQC_NVM_EMPR_ENA;\n\t\t\tdev_dbg(dev, \"Firmware does not support restricting EMP reset availability\\n\");\n\t\t}\n\t}\n\n\terr = ice_aq_wait_for_event(pf, &task, 30 * HZ);\n\tif (err) {\n\t\tdev_err(dev, \"Timed out waiting for firmware to switch active flash banks, err %d\\n\",\n\t\t\terr);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Timed out waiting for firmware\");\n\t\treturn err;\n\t}\n\n\tcompletion_retval = le16_to_cpu(task.event.desc.retval);\n\tif (completion_retval) {\n\t\tdev_err(dev, \"Firmware failed to switch active flash banks aq_err %s\\n\",\n\t\t\tice_aq_str((enum ice_aq_err)completion_retval));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware failed to switch active flash banks\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_flash_component(struct pldmfw *context, struct pldmfw_component *component)\n{\n\tstruct ice_fwu_priv *priv = container_of(context, struct ice_fwu_priv, context);\n\tstruct netlink_ext_ack *extack = priv->extack;\n\tstruct ice_pf *pf = priv->pf;\n\tconst char *name;\n\tu8 *reset_level;\n\tu16 module;\n\tu8 flag;\n\tint err;\n\n\tswitch (component->identifier) {\n\tcase NVM_COMP_ID_OROM:\n\t\tmodule = ICE_SR_1ST_OROM_BANK_PTR;\n\t\tflag = ICE_AQC_NVM_ACTIV_SEL_OROM;\n\t\treset_level = NULL;\n\t\tname = \"fw.undi\";\n\t\tbreak;\n\tcase NVM_COMP_ID_NVM:\n\t\tmodule = ICE_SR_1ST_NVM_BANK_PTR;\n\t\tflag = ICE_AQC_NVM_ACTIV_SEL_NVM;\n\t\treset_level = &priv->reset_level;\n\t\tname = \"fw.mgmt\";\n\t\tbreak;\n\tcase NVM_COMP_ID_NETLIST:\n\t\tmodule = ICE_SR_NETLIST_BANK_PTR;\n\t\tflag = ICE_AQC_NVM_ACTIV_SEL_NETLIST;\n\t\treset_level = NULL;\n\t\tname = \"fw.netlist\";\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN(1, \"Unexpected unknown component identifier 0x%02x\",\n\t\t     component->identifier);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->activate_flags |= flag;\n\n\terr = ice_erase_nvm_module(pf, module, name, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn ice_write_nvm_module(pf, module, name, component->component_data,\n\t\t\t\t    component->component_size, reset_level,\n\t\t\t\t    extack);\n}\n\n \nstatic int ice_finalize_update(struct pldmfw *context)\n{\n\tstruct ice_fwu_priv *priv = container_of(context, struct ice_fwu_priv, context);\n\tstruct netlink_ext_ack *extack = priv->extack;\n\tstruct ice_pf *pf = priv->pf;\n\tstruct devlink *devlink;\n\tint err;\n\n\t \n\terr = ice_switch_flash_banks(pf, priv->activate_flags,\n\t\t\t\t     &priv->emp_reset_available, extack);\n\tif (err)\n\t\treturn err;\n\n\tdevlink = priv_to_devlink(pf);\n\n\t \n\tif (priv->reset_level == ICE_AQC_NVM_EMPR_FLAG &&\n\t    !priv->emp_reset_available) {\n\t\tdev_dbg(ice_pf_to_dev(pf), \"Firmware indicated EMP reset as sufficient, but EMP reset is disabled\\n\");\n\t\tpriv->reset_level = ICE_AQC_NVM_PERST_FLAG;\n\t}\n\n\tswitch (priv->reset_level) {\n\tcase ICE_AQC_NVM_EMPR_FLAG:\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\t\t\t   \"Activate new firmware by devlink reload\",\n\t\t\t\t\t\t   NULL, 0, 0);\n\t\tbreak;\n\tcase ICE_AQC_NVM_PERST_FLAG:\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\t\t\t   \"Activate new firmware by rebooting the system\",\n\t\t\t\t\t\t   NULL, 0, 0);\n\t\tbreak;\n\tcase ICE_AQC_NVM_POR_FLAG:\n\tdefault:\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\t\t\t   \"Activate new firmware by power cycling the system\",\n\t\t\t\t\t\t   NULL, 0, 0);\n\t\tbreak;\n\t}\n\n\tpf->fw_emp_reset_disabled = !priv->emp_reset_available;\n\n\treturn 0;\n}\n\nstruct ice_pldm_pci_record_id {\n\tu32 vendor;\n\tu32 device;\n\tu32 subsystem_vendor;\n\tu32 subsystem_device;\n};\n\n \nstatic bool\nice_op_pci_match_record(struct pldmfw *context, struct pldmfw_record *record)\n{\n\tstruct pci_dev *pdev = to_pci_dev(context->dev);\n\tstruct ice_pldm_pci_record_id id = {\n\t\t.vendor = PCI_ANY_ID,\n\t\t.device = PCI_ANY_ID,\n\t\t.subsystem_vendor = PCI_ANY_ID,\n\t\t.subsystem_device = PCI_ANY_ID,\n\t};\n\tstruct pldmfw_desc_tlv *desc;\n\n\tlist_for_each_entry(desc, &record->descs, entry) {\n\t\tu16 value;\n\t\tint *ptr;\n\n\t\tswitch (desc->type) {\n\t\tcase PLDM_DESC_ID_PCI_VENDOR_ID:\n\t\t\tptr = &id.vendor;\n\t\t\tbreak;\n\t\tcase PLDM_DESC_ID_PCI_DEVICE_ID:\n\t\t\tptr = &id.device;\n\t\t\tbreak;\n\t\tcase PLDM_DESC_ID_PCI_SUBVENDOR_ID:\n\t\t\tptr = &id.subsystem_vendor;\n\t\t\tbreak;\n\t\tcase PLDM_DESC_ID_PCI_SUBDEV_ID:\n\t\t\tptr = &id.subsystem_device;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = get_unaligned_le16(desc->data);\n\t\t \n\t\tif (value)\n\t\t\t*ptr = value;\n\t\telse\n\t\t\t*ptr = PCI_ANY_ID;\n\t}\n\n\t \n\tif ((id.vendor == PCI_ANY_ID || id.vendor == pdev->vendor) &&\n\t    (id.device == PCI_ANY_ID || id.device == pdev->device ||\n\t    id.device == ICE_DEV_ID_E822_SI_DFLT) &&\n\t    (id.subsystem_vendor == PCI_ANY_ID ||\n\t    id.subsystem_vendor == pdev->subsystem_vendor) &&\n\t    (id.subsystem_device == PCI_ANY_ID ||\n\t    id.subsystem_device == pdev->subsystem_device))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct pldmfw_ops ice_fwu_ops_e810 = {\n\t.match_record = &pldmfw_op_pci_match_record,\n\t.send_package_data = &ice_send_package_data,\n\t.send_component_table = &ice_send_component_table,\n\t.flash_component = &ice_flash_component,\n\t.finalize_update = &ice_finalize_update,\n};\n\nstatic const struct pldmfw_ops ice_fwu_ops_e822 = {\n\t.match_record = &ice_op_pci_match_record,\n\t.send_package_data = &ice_send_package_data,\n\t.send_component_table = &ice_send_component_table,\n\t.flash_component = &ice_flash_component,\n\t.finalize_update = &ice_finalize_update,\n};\n\n \nint ice_get_pending_updates(struct ice_pf *pf, u8 *pending,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw_dev_caps *dev_caps;\n\tstruct ice_hw *hw = &pf->hw;\n\tint err;\n\n\tdev_caps = kzalloc(sizeof(*dev_caps), GFP_KERNEL);\n\tif (!dev_caps)\n\t\treturn -ENOMEM;\n\n\t \n\terr = ice_discover_dev_caps(hw, dev_caps);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unable to read device capabilities\");\n\t\tkfree(dev_caps);\n\t\treturn err;\n\t}\n\n\t*pending = 0;\n\n\tif (dev_caps->common_cap.nvm_update_pending_nvm) {\n\t\tdev_info(dev, \"The fw.mgmt flash component has a pending update\\n\");\n\t\t*pending |= ICE_AQC_NVM_ACTIV_SEL_NVM;\n\t}\n\n\tif (dev_caps->common_cap.nvm_update_pending_orom) {\n\t\tdev_info(dev, \"The fw.undi flash component has a pending update\\n\");\n\t\t*pending |= ICE_AQC_NVM_ACTIV_SEL_OROM;\n\t}\n\n\tif (dev_caps->common_cap.nvm_update_pending_netlist) {\n\t\tdev_info(dev, \"The fw.netlist flash component has a pending update\\n\");\n\t\t*pending |= ICE_AQC_NVM_ACTIV_SEL_NETLIST;\n\t}\n\n\tkfree(dev_caps);\n\n\treturn 0;\n}\n\n \nstatic int\nice_cancel_pending_update(struct ice_pf *pf, const char *component,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct devlink *devlink = priv_to_devlink(pf);\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 pending;\n\tint err;\n\n\terr = ice_get_pending_updates(pf, &pending, extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (component) {\n\t\tif (strcmp(component, \"fw.mgmt\") == 0)\n\t\t\tpending &= ICE_AQC_NVM_ACTIV_SEL_NVM;\n\t\telse if (strcmp(component, \"fw.undi\") == 0)\n\t\t\tpending &= ICE_AQC_NVM_ACTIV_SEL_OROM;\n\t\telse if (strcmp(component, \"fw.netlist\") == 0)\n\t\t\tpending &= ICE_AQC_NVM_ACTIV_SEL_NETLIST;\n\t\telse\n\t\t\tWARN(1, \"Unexpected flash component %s\", component);\n\t}\n\n\t \n\tif (!pending)\n\t\treturn 0;\n\n\t \n\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\t\t   \"Canceling previous pending update\",\n\t\t\t\t\t   component, 0, 0);\n\n\terr = ice_acquire_nvm(hw, ICE_RES_WRITE);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to acquire device flash lock, err %d aq_err %s\\n\",\n\t\t\terr, ice_aq_str(hw->adminq.sq_last_status));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to acquire device flash lock\");\n\t\treturn err;\n\t}\n\n\tpending |= ICE_AQC_NVM_REVERT_LAST_ACTIV;\n\terr = ice_switch_flash_banks(pf, pending, NULL, extack);\n\n\tice_release_nvm(hw);\n\n\t \n\tpf->fw_emp_reset_disabled = false;\n\n\treturn err;\n}\n\n \nint ice_devlink_flash_update(struct devlink *devlink,\n\t\t\t     struct devlink_flash_update_params *params,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ice_pf *pf = devlink_priv(devlink);\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_fwu_priv priv;\n\tu8 preservation;\n\tint err;\n\n\tif (!params->overwrite_mask) {\n\t\t \n\t\tpreservation = ICE_AQC_NVM_PRESERVE_ALL;\n\t} else if (params->overwrite_mask == DEVLINK_FLASH_OVERWRITE_SETTINGS) {\n\t\t \n\t\tpreservation = ICE_AQC_NVM_PRESERVE_SELECTED;\n\t} else if (params->overwrite_mask == (DEVLINK_FLASH_OVERWRITE_SETTINGS |\n\t\t\t\t\t      DEVLINK_FLASH_OVERWRITE_IDENTIFIERS)) {\n\t\t \n\t\tpreservation = ICE_AQC_NVM_NO_PRESERVATION;\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Requested overwrite mask is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!hw->dev_caps.common_cap.nvm_unified_update) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Current firmware does not support unified update\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&priv, 0, sizeof(priv));\n\n\t \n\tif (hw->mac_type == ICE_MAC_GENERIC)\n\t\tpriv.context.ops = &ice_fwu_ops_e822;\n\telse\n\t\tpriv.context.ops = &ice_fwu_ops_e810;\n\tpriv.context.dev = dev;\n\tpriv.extack = extack;\n\tpriv.pf = pf;\n\tpriv.activate_flags = preservation;\n\n\tdevlink_flash_update_status_notify(devlink, \"Preparing to flash\", NULL, 0, 0);\n\n\terr = ice_cancel_pending_update(pf, NULL, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_acquire_nvm(hw, ICE_RES_WRITE);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to acquire device flash lock, err %d aq_err %s\\n\",\n\t\t\terr, ice_aq_str(hw->adminq.sq_last_status));\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to acquire device flash lock\");\n\t\treturn err;\n\t}\n\n\terr = pldmfw_flash_image(&priv.context, params->fw);\n\tif (err == -ENOENT) {\n\t\tdev_err(dev, \"Firmware image has no record matching this device\\n\");\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware image has no record matching this device\");\n\t} else if (err) {\n\t\t \n\t\tdev_err(dev, \"Failed to flash PLDM image, err %d\", err);\n\t}\n\n\tice_release_nvm(hw);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}