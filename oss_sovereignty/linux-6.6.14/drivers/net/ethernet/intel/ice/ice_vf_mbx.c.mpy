{
  "module_name": "ice_vf_mbx.c",
  "hash_id": "09def53ecf9faee68ac91442468d0bf372759552a83c557dc062697523edc2b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_vf_mbx.c",
  "human_readable_source": "\n \n\n#include \"ice_common.h\"\n#include \"ice_vf_mbx.h\"\n\n \nint\nice_aq_send_msg_to_vf(struct ice_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval,\n\t\t      u8 *msg, u16 msglen, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_pf_vf_msg *cmd;\n\tstruct ice_aq_desc desc;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_mbx_opc_send_msg_to_vf);\n\n\tcmd = &desc.params.virt;\n\tcmd->id = cpu_to_le32(vfid);\n\n\tdesc.cookie_high = cpu_to_le32(v_opcode);\n\tdesc.cookie_low = cpu_to_le32(v_retval);\n\n\tif (msglen)\n\t\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\treturn ice_sq_send_cmd(hw, &hw->mailboxq, &desc, msg, msglen, cd);\n}\n\nstatic const u32 ice_legacy_aq_to_vc_speed[] = {\n\tVIRTCHNL_LINK_SPEED_100MB,\t \n\tVIRTCHNL_LINK_SPEED_100MB,\n\tVIRTCHNL_LINK_SPEED_1GB,\n\tVIRTCHNL_LINK_SPEED_1GB,\n\tVIRTCHNL_LINK_SPEED_1GB,\n\tVIRTCHNL_LINK_SPEED_10GB,\n\tVIRTCHNL_LINK_SPEED_20GB,\n\tVIRTCHNL_LINK_SPEED_25GB,\n\tVIRTCHNL_LINK_SPEED_40GB,\n\tVIRTCHNL_LINK_SPEED_40GB,\n\tVIRTCHNL_LINK_SPEED_40GB,\n};\n\n \nu32 ice_conv_link_speed_to_virtchnl(bool adv_link_support, u16 link_speed)\n{\n\t \n\tu32 index = fls(link_speed) - 1;\n\n\tif (adv_link_support)\n\t\treturn ice_get_link_speed(index);\n\telse if (index < ARRAY_SIZE(ice_legacy_aq_to_vc_speed))\n\t\t \n\t\treturn ice_legacy_aq_to_vc_speed[index];\n\n\treturn VIRTCHNL_LINK_SPEED_UNKNOWN;\n}\n\n \n#define ICE_RQ_DATA_MASK(rq_data) ((rq_data) & PF_MBX_ARQH_ARQH_M)\n \n#define ICE_IGNORE_MAX_MSG_CNT\t0xFFFF\n\n \nstatic void ice_mbx_reset_snapshot(struct ice_mbx_snapshot *snap)\n{\n\tstruct ice_mbx_vf_info *vf_info;\n\n\t \n\tmemset(&snap->mbx_buf, 0, sizeof(snap->mbx_buf));\n\tsnap->mbx_buf.state = ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT;\n\n\t \n\tlist_for_each_entry(vf_info, &snap->mbx_vf, list_entry)\n\t\tvf_info->msg_count = 0;\n}\n\n \nstatic void\nice_mbx_traverse(struct ice_hw *hw,\n\t\t enum ice_mbx_snapshot_state *new_state)\n{\n\tstruct ice_mbx_snap_buffer_data *snap_buf;\n\tu32 num_iterations;\n\n\tsnap_buf = &hw->mbx_snapshot.mbx_buf;\n\n\t \n\tnum_iterations = ICE_RQ_DATA_MASK(++snap_buf->num_iterations);\n\n\t \n\tif (num_iterations == snap_buf->head ||\n\t    (snap_buf->max_num_msgs_mbx < ICE_IGNORE_MAX_MSG_CNT &&\n\t     ++snap_buf->num_msg_proc >= snap_buf->max_num_msgs_mbx))\n\t\t*new_state = ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT;\n}\n\n \nstatic int\nice_mbx_detect_malvf(struct ice_hw *hw, struct ice_mbx_vf_info *vf_info,\n\t\t     enum ice_mbx_snapshot_state *new_state,\n\t\t     bool *is_malvf)\n{\n\t \n\tvf_info->msg_count++;\n\n\tif (vf_info->msg_count >= ICE_ASYNC_VF_MSG_THRESHOLD)\n\t\t*is_malvf = true;\n\n\t \n\tice_mbx_traverse(hw, new_state);\n\n\treturn 0;\n}\n\n \nint\nice_mbx_vf_state_handler(struct ice_hw *hw, struct ice_mbx_data *mbx_data,\n\t\t\t struct ice_mbx_vf_info *vf_info, bool *report_malvf)\n{\n\tstruct ice_mbx_snapshot *snap = &hw->mbx_snapshot;\n\tstruct ice_mbx_snap_buffer_data *snap_buf;\n\tstruct ice_ctl_q_info *cq = &hw->mailboxq;\n\tenum ice_mbx_snapshot_state new_state;\n\tbool is_malvf = false;\n\tint status = 0;\n\n\tif (!report_malvf || !mbx_data || !vf_info)\n\t\treturn -EINVAL;\n\n\t*report_malvf = false;\n\n\t \n\t  \n\tif (mbx_data->max_num_msgs_mbx <= ICE_ASYNC_VF_MSG_THRESHOLD)\n\t\treturn -EINVAL;\n\n\t \n\tif (mbx_data->async_watermark_val < ICE_ASYNC_VF_MSG_THRESHOLD ||\n\t    mbx_data->async_watermark_val > mbx_data->max_num_msgs_mbx)\n\t\treturn -EINVAL;\n\n\tnew_state = ICE_MAL_VF_DETECT_STATE_INVALID;\n\tsnap_buf = &snap->mbx_buf;\n\n\tswitch (snap_buf->state) {\n\tcase ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT:\n\t\t \n\t\tice_mbx_reset_snapshot(snap);\n\n\t\t \n\t\tsnap_buf->num_pending_arq = mbx_data->num_pending_arq;\n\t\tsnap_buf->num_msg_proc = mbx_data->num_msg_proc;\n\t\tsnap_buf->max_num_msgs_mbx = mbx_data->max_num_msgs_mbx;\n\n\t\t \n\t\tsnap_buf->head = ICE_RQ_DATA_MASK(cq->rq.next_to_clean +\n\t\t\t\t\t\t  mbx_data->num_pending_arq);\n\t\tsnap_buf->tail = ICE_RQ_DATA_MASK(cq->rq.next_to_clean - 1);\n\t\tsnap_buf->num_iterations = snap_buf->tail;\n\n\t\t \n\t\tif (snap_buf->num_pending_arq >=\n\t\t    mbx_data->async_watermark_val) {\n\t\t\tnew_state = ICE_MAL_VF_DETECT_STATE_DETECT;\n\t\t\tstatus = ice_mbx_detect_malvf(hw, vf_info, &new_state, &is_malvf);\n\t\t} else {\n\t\t\tnew_state = ICE_MAL_VF_DETECT_STATE_TRAVERSE;\n\t\t\tice_mbx_traverse(hw, &new_state);\n\t\t}\n\t\tbreak;\n\n\tcase ICE_MAL_VF_DETECT_STATE_TRAVERSE:\n\t\tnew_state = ICE_MAL_VF_DETECT_STATE_TRAVERSE;\n\t\tice_mbx_traverse(hw, &new_state);\n\t\tbreak;\n\n\tcase ICE_MAL_VF_DETECT_STATE_DETECT:\n\t\tnew_state = ICE_MAL_VF_DETECT_STATE_DETECT;\n\t\tstatus = ice_mbx_detect_malvf(hw, vf_info, &new_state, &is_malvf);\n\t\tbreak;\n\n\tdefault:\n\t\tnew_state = ICE_MAL_VF_DETECT_STATE_INVALID;\n\t\tstatus = -EIO;\n\t}\n\n\tsnap_buf->state = new_state;\n\n\t \n\tif (is_malvf && !vf_info->malicious) {\n\t\tvf_info->malicious = 1;\n\t\t*report_malvf = true;\n\t}\n\n\treturn status;\n}\n\n \nvoid ice_mbx_clear_malvf(struct ice_mbx_vf_info *vf_info)\n{\n\tvf_info->malicious = 0;\n\tvf_info->msg_count = 0;\n}\n\n \nvoid ice_mbx_init_vf_info(struct ice_hw *hw, struct ice_mbx_vf_info *vf_info)\n{\n\tstruct ice_mbx_snapshot *snap = &hw->mbx_snapshot;\n\n\tice_mbx_clear_malvf(vf_info);\n\tlist_add(&vf_info->list_entry, &snap->mbx_vf);\n}\n\n \nvoid ice_mbx_init_snapshot(struct ice_hw *hw)\n{\n\tstruct ice_mbx_snapshot *snap = &hw->mbx_snapshot;\n\n\tINIT_LIST_HEAD(&snap->mbx_vf);\n\tice_mbx_reset_snapshot(snap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}