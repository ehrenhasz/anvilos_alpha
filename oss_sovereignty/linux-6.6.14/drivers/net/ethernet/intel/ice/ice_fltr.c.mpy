{
  "module_name": "ice_fltr.c",
  "hash_id": "05986b89d9d1888a04af6e3c53e0d53a67de494cb8c93b984528bfc1e6237d78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_fltr.c",
  "human_readable_source": "\n \n\n#include \"ice.h\"\n#include \"ice_fltr.h\"\n\n \nvoid ice_fltr_free_list(struct device *dev, struct list_head *h)\n{\n\tstruct ice_fltr_list_entry *e, *tmp;\n\n\tlist_for_each_entry_safe(e, tmp, h, list_entry) {\n\t\tlist_del(&e->list_entry);\n\t\tdevm_kfree(dev, e);\n\t}\n}\n\n \nstatic int\nice_fltr_add_entry_to_list(struct device *dev, struct ice_fltr_info *info,\n\t\t\t   struct list_head *list)\n{\n\tstruct ice_fltr_list_entry *entry;\n\n\tentry = devm_kzalloc(dev, sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->fltr_info = *info;\n\n\tINIT_LIST_HEAD(&entry->list_entry);\n\tlist_add(&entry->list_entry, list);\n\n\treturn 0;\n}\n\n \nint\nice_fltr_set_vlan_vsi_promisc(struct ice_hw *hw, struct ice_vsi *vsi,\n\t\t\t      u8 promisc_mask)\n{\n\tstruct ice_pf *pf = hw->back;\n\tint result;\n\n\tresult = ice_set_vlan_vsi_promisc(hw, vsi->idx, promisc_mask, false);\n\tif (result && result != -EEXIST)\n\t\tdev_err(ice_pf_to_dev(pf),\n\t\t\t\"Error setting promisc mode on VSI %i (rc=%d)\\n\",\n\t\t\tvsi->vsi_num, result);\n\n\treturn result;\n}\n\n \nint\nice_fltr_clear_vlan_vsi_promisc(struct ice_hw *hw, struct ice_vsi *vsi,\n\t\t\t\tu8 promisc_mask)\n{\n\tstruct ice_pf *pf = hw->back;\n\tint result;\n\n\tresult = ice_set_vlan_vsi_promisc(hw, vsi->idx, promisc_mask, true);\n\tif (result && result != -EEXIST)\n\t\tdev_err(ice_pf_to_dev(pf),\n\t\t\t\"Error clearing promisc mode on VSI %i (rc=%d)\\n\",\n\t\t\tvsi->vsi_num, result);\n\n\treturn result;\n}\n\n \nint\nice_fltr_clear_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,\n\t\t\t   u16 vid)\n{\n\tstruct ice_pf *pf = hw->back;\n\tint result;\n\n\tresult = ice_clear_vsi_promisc(hw, vsi_handle, promisc_mask, vid);\n\tif (result && result != -EEXIST)\n\t\tdev_err(ice_pf_to_dev(pf),\n\t\t\t\"Error clearing promisc mode on VSI %i for VID %u (rc=%d)\\n\",\n\t\t\tice_get_hw_vsi_num(hw, vsi_handle), vid, result);\n\n\treturn result;\n}\n\n \nint\nice_fltr_set_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,\n\t\t\t u16 vid)\n{\n\tstruct ice_pf *pf = hw->back;\n\tint result;\n\n\tresult = ice_set_vsi_promisc(hw, vsi_handle, promisc_mask, vid);\n\tif (result && result != -EEXIST)\n\t\tdev_err(ice_pf_to_dev(pf),\n\t\t\t\"Error setting promisc mode on VSI %i for VID %u (rc=%d)\\n\",\n\t\t\tice_get_hw_vsi_num(hw, vsi_handle), vid, result);\n\n\treturn result;\n}\n\n \nint ice_fltr_add_mac_list(struct ice_vsi *vsi, struct list_head *list)\n{\n\treturn ice_add_mac(&vsi->back->hw, list);\n}\n\n \nint ice_fltr_remove_mac_list(struct ice_vsi *vsi, struct list_head *list)\n{\n\treturn ice_remove_mac(&vsi->back->hw, list);\n}\n\n \nstatic int ice_fltr_add_vlan_list(struct ice_vsi *vsi, struct list_head *list)\n{\n\treturn ice_add_vlan(&vsi->back->hw, list);\n}\n\n \nstatic int\nice_fltr_remove_vlan_list(struct ice_vsi *vsi, struct list_head *list)\n{\n\treturn ice_remove_vlan(&vsi->back->hw, list);\n}\n\n \nstatic int ice_fltr_add_eth_list(struct ice_vsi *vsi, struct list_head *list)\n{\n\treturn ice_add_eth_mac(&vsi->back->hw, list);\n}\n\n \nstatic int ice_fltr_remove_eth_list(struct ice_vsi *vsi, struct list_head *list)\n{\n\treturn ice_remove_eth_mac(&vsi->back->hw, list);\n}\n\n \nvoid ice_fltr_remove_all(struct ice_vsi *vsi)\n{\n\tice_remove_vsi_fltr(&vsi->back->hw, vsi->idx);\n\t \n\tif (vsi->netdev) {\n\t\t__dev_uc_unsync(vsi->netdev, NULL);\n\t\t__dev_mc_unsync(vsi->netdev, NULL);\n\t}\n}\n\n \nint\nice_fltr_add_mac_to_list(struct ice_vsi *vsi, struct list_head *list,\n\t\t\t const u8 *mac, enum ice_sw_fwd_act_type action)\n{\n\tstruct ice_fltr_info info = { 0 };\n\n\tinfo.flag = ICE_FLTR_TX;\n\tinfo.src_id = ICE_SRC_ID_VSI;\n\tinfo.lkup_type = ICE_SW_LKUP_MAC;\n\tinfo.fltr_act = action;\n\tinfo.vsi_handle = vsi->idx;\n\n\tether_addr_copy(info.l_data.mac.mac_addr, mac);\n\n\treturn ice_fltr_add_entry_to_list(ice_pf_to_dev(vsi->back), &info,\n\t\t\t\t\t  list);\n}\n\n \nstatic int\nice_fltr_add_vlan_to_list(struct ice_vsi *vsi, struct list_head *list,\n\t\t\t  struct ice_vlan *vlan)\n{\n\tstruct ice_fltr_info info = { 0 };\n\n\tinfo.flag = ICE_FLTR_TX;\n\tinfo.src_id = ICE_SRC_ID_VSI;\n\tinfo.lkup_type = ICE_SW_LKUP_VLAN;\n\tinfo.fltr_act = ICE_FWD_TO_VSI;\n\tinfo.vsi_handle = vsi->idx;\n\tinfo.l_data.vlan.vlan_id = vlan->vid;\n\tinfo.l_data.vlan.tpid = vlan->tpid;\n\tinfo.l_data.vlan.tpid_valid = true;\n\n\treturn ice_fltr_add_entry_to_list(ice_pf_to_dev(vsi->back), &info,\n\t\t\t\t\t  list);\n}\n\n \nstatic int\nice_fltr_add_eth_to_list(struct ice_vsi *vsi, struct list_head *list,\n\t\t\t u16 ethertype, u16 flag,\n\t\t\t enum ice_sw_fwd_act_type action)\n{\n\tstruct ice_fltr_info info = { 0 };\n\n\tinfo.flag = flag;\n\tinfo.lkup_type = ICE_SW_LKUP_ETHERTYPE;\n\tinfo.fltr_act = action;\n\tinfo.vsi_handle = vsi->idx;\n\tinfo.l_data.ethertype_mac.ethertype = ethertype;\n\n\tif (flag == ICE_FLTR_TX)\n\t\tinfo.src_id = ICE_SRC_ID_VSI;\n\telse\n\t\tinfo.src_id = ICE_SRC_ID_LPORT;\n\n\treturn ice_fltr_add_entry_to_list(ice_pf_to_dev(vsi->back), &info,\n\t\t\t\t\t  list);\n}\n\n \nstatic int\nice_fltr_prepare_mac(struct ice_vsi *vsi, const u8 *mac,\n\t\t     enum ice_sw_fwd_act_type action,\n\t\t     int (*mac_action)(struct ice_vsi *, struct list_head *))\n{\n\tLIST_HEAD(tmp_list);\n\tint result;\n\n\tif (ice_fltr_add_mac_to_list(vsi, &tmp_list, mac, action)) {\n\t\tice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);\n\t\treturn -ENOMEM;\n\t}\n\n\tresult = mac_action(vsi, &tmp_list);\n\tice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);\n\treturn result;\n}\n\n \nstatic int\nice_fltr_prepare_mac_and_broadcast(struct ice_vsi *vsi, const u8 *mac,\n\t\t\t\t   enum ice_sw_fwd_act_type action,\n\t\t\t\t   int(*mac_action)\n\t\t\t\t   (struct ice_vsi *, struct list_head *))\n{\n\tu8 broadcast[ETH_ALEN];\n\tLIST_HEAD(tmp_list);\n\tint result;\n\n\teth_broadcast_addr(broadcast);\n\tif (ice_fltr_add_mac_to_list(vsi, &tmp_list, mac, action) ||\n\t    ice_fltr_add_mac_to_list(vsi, &tmp_list, broadcast, action)) {\n\t\tice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);\n\t\treturn -ENOMEM;\n\t}\n\n\tresult = mac_action(vsi, &tmp_list);\n\tice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);\n\treturn result;\n}\n\n \nstatic int\nice_fltr_prepare_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan,\n\t\t      int (*vlan_action)(struct ice_vsi *, struct list_head *))\n{\n\tLIST_HEAD(tmp_list);\n\tint result;\n\n\tif (ice_fltr_add_vlan_to_list(vsi, &tmp_list, vlan))\n\t\treturn -ENOMEM;\n\n\tresult = vlan_action(vsi, &tmp_list);\n\tice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);\n\treturn result;\n}\n\n \nstatic int\nice_fltr_prepare_eth(struct ice_vsi *vsi, u16 ethertype, u16 flag,\n\t\t     enum ice_sw_fwd_act_type action,\n\t\t     int (*eth_action)(struct ice_vsi *, struct list_head *))\n{\n\tLIST_HEAD(tmp_list);\n\tint result;\n\n\tif (ice_fltr_add_eth_to_list(vsi, &tmp_list, ethertype, flag, action))\n\t\treturn -ENOMEM;\n\n\tresult = eth_action(vsi, &tmp_list);\n\tice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);\n\treturn result;\n}\n\n \nint ice_fltr_add_mac(struct ice_vsi *vsi, const u8 *mac,\n\t\t     enum ice_sw_fwd_act_type action)\n{\n\treturn ice_fltr_prepare_mac(vsi, mac, action, ice_fltr_add_mac_list);\n}\n\n \nint\nice_fltr_add_mac_and_broadcast(struct ice_vsi *vsi, const u8 *mac,\n\t\t\t       enum ice_sw_fwd_act_type action)\n{\n\treturn ice_fltr_prepare_mac_and_broadcast(vsi, mac, action,\n\t\t\t\t\t\t  ice_fltr_add_mac_list);\n}\n\n \nint ice_fltr_remove_mac(struct ice_vsi *vsi, const u8 *mac,\n\t\t\tenum ice_sw_fwd_act_type action)\n{\n\treturn ice_fltr_prepare_mac(vsi, mac, action, ice_fltr_remove_mac_list);\n}\n\n \nint ice_fltr_add_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan)\n{\n\treturn ice_fltr_prepare_vlan(vsi, vlan, ice_fltr_add_vlan_list);\n}\n\n \nint ice_fltr_remove_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan)\n{\n\treturn ice_fltr_prepare_vlan(vsi, vlan, ice_fltr_remove_vlan_list);\n}\n\n \nint ice_fltr_add_eth(struct ice_vsi *vsi, u16 ethertype, u16 flag,\n\t\t     enum ice_sw_fwd_act_type action)\n{\n\treturn ice_fltr_prepare_eth(vsi, ethertype, flag, action,\n\t\t\t\t    ice_fltr_add_eth_list);\n}\n\n \nint ice_fltr_remove_eth(struct ice_vsi *vsi, u16 ethertype, u16 flag,\n\t\t\tenum ice_sw_fwd_act_type action)\n{\n\treturn ice_fltr_prepare_eth(vsi, ethertype, flag, action,\n\t\t\t\t    ice_fltr_remove_eth_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}