{
  "module_name": "ice_switch.c",
  "hash_id": "b50a334f620e08be16c6c844bd6ed8874cf2a870e9eb4eca5a7a3458461abc43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_switch.c",
  "human_readable_source": "\n \n\n#include \"ice_lib.h\"\n#include \"ice_switch.h\"\n\n#define ICE_ETH_DA_OFFSET\t\t0\n#define ICE_ETH_ETHTYPE_OFFSET\t\t12\n#define ICE_ETH_VLAN_TCI_OFFSET\t\t14\n#define ICE_MAX_VLAN_ID\t\t\t0xFFF\n#define ICE_IPV6_ETHER_ID\t\t0x86DD\n\n \nstatic const u8 dummy_eth_header[DUMMY_ETH_HDR_LEN] = { 0x2, 0, 0, 0, 0, 0,\n\t\t\t\t\t\t\t0x2, 0, 0, 0, 0, 0,\n\t\t\t\t\t\t\t0x81, 0, 0, 0};\n\nenum {\n\tICE_PKT_OUTER_IPV6\t= BIT(0),\n\tICE_PKT_TUN_GTPC\t= BIT(1),\n\tICE_PKT_TUN_GTPU\t= BIT(2),\n\tICE_PKT_TUN_NVGRE\t= BIT(3),\n\tICE_PKT_TUN_UDP\t\t= BIT(4),\n\tICE_PKT_INNER_IPV6\t= BIT(5),\n\tICE_PKT_INNER_TCP\t= BIT(6),\n\tICE_PKT_INNER_UDP\t= BIT(7),\n\tICE_PKT_GTP_NOPAY\t= BIT(8),\n\tICE_PKT_KMALLOC\t\t= BIT(9),\n\tICE_PKT_PPPOE\t\t= BIT(10),\n\tICE_PKT_L2TPV3\t\t= BIT(11),\n};\n\nstruct ice_dummy_pkt_offsets {\n\tenum ice_protocol_type type;\n\tu16 offset;  \n};\n\nstruct ice_dummy_pkt_profile {\n\tconst struct ice_dummy_pkt_offsets *offsets;\n\tconst u8 *pkt;\n\tu32 match;\n\tu16 pkt_len;\n\tu16 offsets_len;\n};\n\n#define ICE_DECLARE_PKT_OFFSETS(type)\t\t\t\t\t\\\n\tstatic const struct ice_dummy_pkt_offsets\t\t\t\\\n\tice_dummy_##type##_packet_offsets[]\n\n#define ICE_DECLARE_PKT_TEMPLATE(type)\t\t\t\t\t\\\n\tstatic const u8 ice_dummy_##type##_packet[]\n\n#define ICE_PKT_PROFILE(type, m) {\t\t\t\t\t\\\n\t.match\t\t= (m),\t\t\t\t\t\t\\\n\t.pkt\t\t= ice_dummy_##type##_packet,\t\t\t\\\n\t.pkt_len\t= sizeof(ice_dummy_##type##_packet),\t\t\\\n\t.offsets\t= ice_dummy_##type##_packet_offsets,\t\t\\\n\t.offsets_len\t= sizeof(ice_dummy_##type##_packet_offsets),\t\\\n}\n\nICE_DECLARE_PKT_OFFSETS(vlan) = {\n\t{ ICE_VLAN_OFOS,        12 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(vlan) = {\n\t0x81, 0x00, 0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(qinq) = {\n\t{ ICE_VLAN_EX,          12 },\n\t{ ICE_VLAN_IN,          16 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(qinq) = {\n\t0x91, 0x00, 0x00, 0x00,  \n\t0x81, 0x00, 0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(gre_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_NVGRE,\t\t34 },\n\t{ ICE_MAC_IL,\t\t42 },\n\t{ ICE_ETYPE_IL,\t\t54 },\n\t{ ICE_IPV4_IL,\t\t56 },\n\t{ ICE_TCP_IL,\t\t76 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(gre_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x3E,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x2F, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x80, 0x00, 0x65, 0x58,\t \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x14,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x06, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x02, 0x20, 0x00,\n\t0x00, 0x00, 0x00, 0x00\n};\n\nICE_DECLARE_PKT_OFFSETS(gre_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_NVGRE,\t\t34 },\n\t{ ICE_MAC_IL,\t\t42 },\n\t{ ICE_ETYPE_IL,\t\t54 },\n\t{ ICE_IPV4_IL,\t\t56 },\n\t{ ICE_UDP_ILOS,\t\t76 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(gre_udp) = {\n\t0x00, 0x00, 0x00, 0x00,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x3E,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x2F, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x80, 0x00, 0x65, 0x58,\t \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x14,\t \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,\t \n\t0x00, 0x08, 0x00, 0x00,\n};\n\nICE_DECLARE_PKT_OFFSETS(udp_tun_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_VXLAN,\t\t42 },\n\t{ ICE_GENEVE,\t\t42 },\n\t{ ICE_VXLAN_GPE,\t42 },\n\t{ ICE_MAC_IL,\t\t50 },\n\t{ ICE_ETYPE_IL,\t\t62 },\n\t{ ICE_IPV4_IL,\t\t64 },\n\t{ ICE_TCP_IL,\t\t84 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(udp_tun_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,   \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x5a,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x40, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x12, 0xb5,  \n\t0x00, 0x46, 0x00, 0x00,\n\n\t0x00, 0x00, 0x65, 0x58,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x28,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x40, 0x06, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x02, 0x20, 0x00,\n\t0x00, 0x00, 0x00, 0x00\n};\n\nICE_DECLARE_PKT_OFFSETS(udp_tun_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_VXLAN,\t\t42 },\n\t{ ICE_GENEVE,\t\t42 },\n\t{ ICE_VXLAN_GPE,\t42 },\n\t{ ICE_MAC_IL,\t\t50 },\n\t{ ICE_ETYPE_IL,\t\t62 },\n\t{ ICE_IPV4_IL,\t\t64 },\n\t{ ICE_UDP_ILOS,\t\t84 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(udp_tun_udp) = {\n\t0x00, 0x00, 0x00, 0x00,   \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x4e,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x12, 0xb5,  \n\t0x00, 0x3a, 0x00, 0x00,\n\n\t0x00, 0x00, 0x65, 0x58,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x1c,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n};\n\nICE_DECLARE_PKT_OFFSETS(gre_ipv6_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_NVGRE,\t\t34 },\n\t{ ICE_MAC_IL,\t\t42 },\n\t{ ICE_ETYPE_IL,\t\t54 },\n\t{ ICE_IPV6_IL,\t\t56 },\n\t{ ICE_TCP_IL,\t\t96 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(gre_ipv6_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x66,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x2F, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x80, 0x00, 0x65, 0x58,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x86, 0xdd,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x06, 0x40,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x02, 0x20, 0x00,\n\t0x00, 0x00, 0x00, 0x00\n};\n\nICE_DECLARE_PKT_OFFSETS(gre_ipv6_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_NVGRE,\t\t34 },\n\t{ ICE_MAC_IL,\t\t42 },\n\t{ ICE_ETYPE_IL,\t\t54 },\n\t{ ICE_IPV6_IL,\t\t56 },\n\t{ ICE_UDP_ILOS,\t\t96 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(gre_ipv6_udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x5a,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x2F, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x80, 0x00, 0x65, 0x58,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x86, 0xdd,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x11, 0x40,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n};\n\nICE_DECLARE_PKT_OFFSETS(udp_tun_ipv6_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_VXLAN,\t\t42 },\n\t{ ICE_GENEVE,\t\t42 },\n\t{ ICE_VXLAN_GPE,\t42 },\n\t{ ICE_MAC_IL,\t\t50 },\n\t{ ICE_ETYPE_IL,\t\t62 },\n\t{ ICE_IPV6_IL,\t\t64 },\n\t{ ICE_TCP_IL,\t\t104 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(udp_tun_ipv6_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,   \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x6e,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x40, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x12, 0xb5,  \n\t0x00, 0x5a, 0x00, 0x00,\n\n\t0x00, 0x00, 0x65, 0x58,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x86, 0xdd,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x06, 0x40,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x02, 0x20, 0x00,\n\t0x00, 0x00, 0x00, 0x00\n};\n\nICE_DECLARE_PKT_OFFSETS(udp_tun_ipv6_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_VXLAN,\t\t42 },\n\t{ ICE_GENEVE,\t\t42 },\n\t{ ICE_VXLAN_GPE,\t42 },\n\t{ ICE_MAC_IL,\t\t50 },\n\t{ ICE_ETYPE_IL,\t\t62 },\n\t{ ICE_IPV6_IL,\t\t64 },\n\t{ ICE_UDP_ILOS,\t\t104 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(udp_tun_ipv6_udp) = {\n\t0x00, 0x00, 0x00, 0x00,   \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x62,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x12, 0xb5,  \n\t0x00, 0x4e, 0x00, 0x00,\n\n\t0x00, 0x00, 0x65, 0x58,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x86, 0xdd,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x11, 0x40,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n};\n\n \nICE_DECLARE_PKT_OFFSETS(udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_ILOS,\t\t34 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\n \nICE_DECLARE_PKT_TEMPLATE(udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x1c,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n\n\t0x00, 0x00,\t \n};\n\n \nICE_DECLARE_PKT_OFFSETS(tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_TCP_IL,\t\t34 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\n \nICE_DECLARE_PKT_TEMPLATE(tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x28,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x06, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,\t \n};\n\nICE_DECLARE_PKT_OFFSETS(tcp_ipv6) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_TCP_IL,\t\t54 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(tcp_ipv6) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x86, 0xDD,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x14, 0x06, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\n \nICE_DECLARE_PKT_OFFSETS(udp_ipv6) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_UDP_ILOS,\t\t54 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\n \nICE_DECLARE_PKT_TEMPLATE(udp_ipv6) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x86, 0xDD,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x10, 0x11, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x10, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\n \nICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv4_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_GTP,\t\t42 },\n\t{ ICE_IPV4_IL,\t\t62 },\n\t{ ICE_TCP_IL,\t\t82 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv4_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x08, 0x00,\n\n\t0x45, 0x00, 0x00, 0x58,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x44, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x34,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x45, 0x00, 0x00, 0x28,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x06, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\n \nICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv4_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_GTP,\t\t42 },\n\t{ ICE_IPV4_IL,\t\t62 },\n\t{ ICE_UDP_ILOS,\t\t82 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv4_udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x08, 0x00,\n\n\t0x45, 0x00, 0x00, 0x4c,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x38, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x28,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x45, 0x00, 0x00, 0x1c,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\n \nICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv6_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_GTP,\t\t42 },\n\t{ ICE_IPV6_IL,\t\t62 },\n\t{ ICE_TCP_IL,\t\t102 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv6_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x08, 0x00,\n\n\t0x45, 0x00, 0x00, 0x6c,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x58, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x48,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x14, 0x06, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv6_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_GTP,\t\t42 },\n\t{ ICE_IPV6_IL,\t\t62 },\n\t{ ICE_UDP_ILOS,\t\t102 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv6_udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x08, 0x00,\n\n\t0x45, 0x00, 0x00, 0x60,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x4c, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x3c,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x11, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv4_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t54 },\n\t{ ICE_GTP,\t\t62 },\n\t{ ICE_IPV4_IL,\t\t82 },\n\t{ ICE_TCP_IL,\t\t102 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv4_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x86, 0xdd,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x44, 0x11, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x44, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x34,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x45, 0x00, 0x00, 0x28,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x06, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv4_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t54 },\n\t{ ICE_GTP,\t\t62 },\n\t{ ICE_IPV4_IL,\t\t82 },\n\t{ ICE_UDP_ILOS,\t\t102 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv4_udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x86, 0xdd,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x38, 0x11, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x38, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x28,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x45, 0x00, 0x00, 0x1c,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv6_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t54 },\n\t{ ICE_GTP,\t\t62 },\n\t{ ICE_IPV6_IL,\t\t82 },\n\t{ ICE_TCP_IL,\t\t122 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv6_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x86, 0xdd,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x58, 0x11, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x58, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x48,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x14, 0x06, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv6_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t54 },\n\t{ ICE_GTP,\t\t62 },\n\t{ ICE_IPV6_IL,\t\t82 },\n\t{ ICE_UDP_ILOS,\t\t122 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv6_udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x86, 0xdd,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x4c, 0x11, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x08, 0x68,  \n\t0x00, 0x4c, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x3c,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x11, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n\n\t0x00, 0x00,  \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv4) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t34 },\n\t{ ICE_GTP_NO_PAY,\t42 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv4) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x08, 0x00,\n\n\t0x45, 0x00, 0x00, 0x44,  \n\t0x00, 0x00, 0x40, 0x00,\n\t0x40, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x68, 0x08, 0x68,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x34, 0xff, 0x00, 0x28,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x85,\n\n\t0x02, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x45, 0x00, 0x00, 0x14,  \n\t0x00, 0x00, 0x40, 0x00,\n\t0x40, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n};\n\nICE_DECLARE_PKT_OFFSETS(ipv6_gtp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_UDP_OF,\t\t54 },\n\t{ ICE_GTP_NO_PAY,\t62 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv6_gtp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x86, 0xdd,\n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x6c, 0x11, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x68, 0x08, 0x68,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x30, 0x00, 0x00, 0x28,  \n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,\n};\n\nICE_DECLARE_PKT_OFFSETS(pppoe_ipv4_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_PPPOE,\t\t14 },\n\t{ ICE_IPV4_OFOS,\t22 },\n\t{ ICE_TCP_IL,\t\t42 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(pppoe_ipv4_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x88, 0x64,\t\t \n\n\t0x11, 0x00, 0x00, 0x00,  \n\t0x00, 0x16,\n\n\t0x00, 0x21,\t\t \n\n\t0x45, 0x00, 0x00, 0x28,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x06, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,\t\t \n};\n\nICE_DECLARE_PKT_OFFSETS(pppoe_ipv4_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_PPPOE,\t\t14 },\n\t{ ICE_IPV4_OFOS,\t22 },\n\t{ ICE_UDP_ILOS,\t\t42 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(pppoe_ipv4_udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x88, 0x64,\t\t \n\n\t0x11, 0x00, 0x00, 0x00,  \n\t0x00, 0x16,\n\n\t0x00, 0x21,\t\t \n\n\t0x45, 0x00, 0x00, 0x1c,  \n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x11, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n\n\t0x00, 0x00,\t\t \n};\n\nICE_DECLARE_PKT_OFFSETS(pppoe_ipv6_tcp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_PPPOE,\t\t14 },\n\t{ ICE_IPV6_OFOS,\t22 },\n\t{ ICE_TCP_IL,\t\t62 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(pppoe_ipv6_tcp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x88, 0x64,\t\t \n\n\t0x11, 0x00, 0x00, 0x00,  \n\t0x00, 0x2a,\n\n\t0x00, 0x57,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x14, 0x06, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x50, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00,\t\t \n};\n\nICE_DECLARE_PKT_OFFSETS(pppoe_ipv6_udp) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_PPPOE,\t\t14 },\n\t{ ICE_IPV6_OFOS,\t22 },\n\t{ ICE_UDP_ILOS,\t\t62 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(pppoe_ipv6_udp) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x88, 0x64,\t\t \n\n\t0x11, 0x00, 0x00, 0x00,  \n\t0x00, 0x2a,\n\n\t0x00, 0x57,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x11, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x08, 0x00, 0x00,\n\n\t0x00, 0x00,\t\t \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv4_l2tpv3) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV4_OFOS,\t14 },\n\t{ ICE_L2TPV3,\t\t34 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv4_l2tpv3) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x08, 0x00,\t\t \n\n\t0x45, 0x00, 0x00, 0x20,  \n\t0x00, 0x00, 0x40, 0x00,\n\t0x40, 0x73, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\t\t \n};\n\nICE_DECLARE_PKT_OFFSETS(ipv6_l2tpv3) = {\n\t{ ICE_MAC_OFOS,\t\t0 },\n\t{ ICE_ETYPE_OL,\t\t12 },\n\t{ ICE_IPV6_OFOS,\t14 },\n\t{ ICE_L2TPV3,\t\t54 },\n\t{ ICE_PROTOCOL_LAST,\t0 },\n};\n\nICE_DECLARE_PKT_TEMPLATE(ipv6_l2tpv3) = {\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x86, 0xDD,\t\t \n\n\t0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x0c, 0x73, 0x40,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\t\t \n};\n\nstatic const struct ice_dummy_pkt_profile ice_dummy_pkt_profiles[] = {\n\tICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPU | ICE_PKT_OUTER_IPV6 |\n\t\t\t\t  ICE_PKT_GTP_NOPAY),\n\tICE_PKT_PROFILE(ipv6_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |\n\t\t\t\t\t    ICE_PKT_OUTER_IPV6 |\n\t\t\t\t\t    ICE_PKT_INNER_IPV6 |\n\t\t\t\t\t    ICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(ipv6_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |\n\t\t\t\t\t    ICE_PKT_OUTER_IPV6 |\n\t\t\t\t\t    ICE_PKT_INNER_IPV6),\n\tICE_PKT_PROFILE(ipv6_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |\n\t\t\t\t\t    ICE_PKT_OUTER_IPV6 |\n\t\t\t\t\t    ICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(ipv6_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU |\n\t\t\t\t\t    ICE_PKT_OUTER_IPV6),\n\tICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPU | ICE_PKT_GTP_NOPAY),\n\tICE_PKT_PROFILE(ipv4_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |\n\t\t\t\t\t    ICE_PKT_INNER_IPV6 |\n\t\t\t\t\t    ICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(ipv4_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |\n\t\t\t\t\t    ICE_PKT_INNER_IPV6),\n\tICE_PKT_PROFILE(ipv4_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |\n\t\t\t\t\t    ICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(ipv4_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU),\n\tICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPC | ICE_PKT_OUTER_IPV6),\n\tICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPC),\n\tICE_PKT_PROFILE(pppoe_ipv6_udp, ICE_PKT_PPPOE | ICE_PKT_OUTER_IPV6 |\n\t\t\t\t\tICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(pppoe_ipv6_tcp, ICE_PKT_PPPOE | ICE_PKT_OUTER_IPV6),\n\tICE_PKT_PROFILE(pppoe_ipv4_udp, ICE_PKT_PPPOE | ICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(pppoe_ipv4_tcp, ICE_PKT_PPPOE),\n\tICE_PKT_PROFILE(gre_ipv6_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6 |\n\t\t\t\t      ICE_PKT_INNER_TCP),\n\tICE_PKT_PROFILE(gre_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_TCP),\n\tICE_PKT_PROFILE(gre_ipv6_udp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6),\n\tICE_PKT_PROFILE(gre_udp, ICE_PKT_TUN_NVGRE),\n\tICE_PKT_PROFILE(udp_tun_ipv6_tcp, ICE_PKT_TUN_UDP |\n\t\t\t\t\t  ICE_PKT_INNER_IPV6 |\n\t\t\t\t\t  ICE_PKT_INNER_TCP),\n\tICE_PKT_PROFILE(ipv6_l2tpv3, ICE_PKT_L2TPV3 | ICE_PKT_OUTER_IPV6),\n\tICE_PKT_PROFILE(ipv4_l2tpv3, ICE_PKT_L2TPV3),\n\tICE_PKT_PROFILE(udp_tun_tcp, ICE_PKT_TUN_UDP | ICE_PKT_INNER_TCP),\n\tICE_PKT_PROFILE(udp_tun_ipv6_udp, ICE_PKT_TUN_UDP |\n\t\t\t\t\t  ICE_PKT_INNER_IPV6),\n\tICE_PKT_PROFILE(udp_tun_udp, ICE_PKT_TUN_UDP),\n\tICE_PKT_PROFILE(udp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(udp, ICE_PKT_INNER_UDP),\n\tICE_PKT_PROFILE(tcp_ipv6, ICE_PKT_OUTER_IPV6),\n\tICE_PKT_PROFILE(tcp, 0),\n};\n\n \nstatic DECLARE_BITMAP(recipe_to_profile[ICE_MAX_NUM_RECIPES],\n\t\t\t  ICE_MAX_NUM_PROFILES);\n\n \nstatic DECLARE_BITMAP(profile_to_recipe[ICE_MAX_NUM_PROFILES],\n\t\t\t  ICE_MAX_NUM_RECIPES);\n\n \nint ice_init_def_sw_recp(struct ice_hw *hw)\n{\n\tstruct ice_sw_recipe *recps;\n\tu8 i;\n\n\trecps = devm_kcalloc(ice_hw_to_dev(hw), ICE_MAX_NUM_RECIPES,\n\t\t\t     sizeof(*recps), GFP_KERNEL);\n\tif (!recps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ICE_MAX_NUM_RECIPES; i++) {\n\t\trecps[i].root_rid = i;\n\t\tINIT_LIST_HEAD(&recps[i].filt_rules);\n\t\tINIT_LIST_HEAD(&recps[i].filt_replay_rules);\n\t\tINIT_LIST_HEAD(&recps[i].rg_list);\n\t\tmutex_init(&recps[i].filt_rule_lock);\n\t}\n\n\thw->switch_info->recp_list = recps;\n\n\treturn 0;\n}\n\n \nstatic int\nice_aq_get_sw_cfg(struct ice_hw *hw, struct ice_aqc_get_sw_cfg_resp_elem *buf,\n\t\t  u16 buf_size, u16 *req_desc, u16 *num_elems,\n\t\t  struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_get_sw_cfg *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_get_sw_cfg);\n\tcmd = &desc.params.get_sw_conf;\n\tcmd->element = cpu_to_le16(*req_desc);\n\n\tstatus = ice_aq_send_cmd(hw, &desc, buf, buf_size, cd);\n\tif (!status) {\n\t\t*req_desc = le16_to_cpu(cmd->element);\n\t\t*num_elems = le16_to_cpu(cmd->num_elems);\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_aq_add_vsi(struct ice_hw *hw, struct ice_vsi_ctx *vsi_ctx,\n\t       struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_add_update_free_vsi_resp *res;\n\tstruct ice_aqc_add_get_update_free_vsi *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tcmd = &desc.params.vsi_cmd;\n\tres = &desc.params.add_update_free_vsi_res;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_add_vsi);\n\n\tif (!vsi_ctx->alloc_from_pool)\n\t\tcmd->vsi_num = cpu_to_le16(vsi_ctx->vsi_num |\n\t\t\t\t\t   ICE_AQ_VSI_IS_VALID);\n\tcmd->vf_id = vsi_ctx->vf_num;\n\n\tcmd->vsi_flags = cpu_to_le16(vsi_ctx->flags);\n\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\tstatus = ice_aq_send_cmd(hw, &desc, &vsi_ctx->info,\n\t\t\t\t sizeof(vsi_ctx->info), cd);\n\n\tif (!status) {\n\t\tvsi_ctx->vsi_num = le16_to_cpu(res->vsi_num) & ICE_AQ_VSI_NUM_M;\n\t\tvsi_ctx->vsis_allocd = le16_to_cpu(res->vsi_used);\n\t\tvsi_ctx->vsis_unallocated = le16_to_cpu(res->vsi_free);\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_aq_free_vsi(struct ice_hw *hw, struct ice_vsi_ctx *vsi_ctx,\n\t\tbool keep_vsi_alloc, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_add_update_free_vsi_resp *resp;\n\tstruct ice_aqc_add_get_update_free_vsi *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tcmd = &desc.params.vsi_cmd;\n\tresp = &desc.params.add_update_free_vsi_res;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_free_vsi);\n\n\tcmd->vsi_num = cpu_to_le16(vsi_ctx->vsi_num | ICE_AQ_VSI_IS_VALID);\n\tif (keep_vsi_alloc)\n\t\tcmd->cmd_flags = cpu_to_le16(ICE_AQ_VSI_KEEP_ALLOC);\n\n\tstatus = ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n\tif (!status) {\n\t\tvsi_ctx->vsis_allocd = le16_to_cpu(resp->vsi_used);\n\t\tvsi_ctx->vsis_unallocated = le16_to_cpu(resp->vsi_free);\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_aq_update_vsi(struct ice_hw *hw, struct ice_vsi_ctx *vsi_ctx,\n\t\t  struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_add_update_free_vsi_resp *resp;\n\tstruct ice_aqc_add_get_update_free_vsi *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tcmd = &desc.params.vsi_cmd;\n\tresp = &desc.params.add_update_free_vsi_res;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_update_vsi);\n\n\tcmd->vsi_num = cpu_to_le16(vsi_ctx->vsi_num | ICE_AQ_VSI_IS_VALID);\n\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\tstatus = ice_aq_send_cmd(hw, &desc, &vsi_ctx->info,\n\t\t\t\t sizeof(vsi_ctx->info), cd);\n\n\tif (!status) {\n\t\tvsi_ctx->vsis_allocd = le16_to_cpu(resp->vsi_used);\n\t\tvsi_ctx->vsis_unallocated = le16_to_cpu(resp->vsi_free);\n\t}\n\n\treturn status;\n}\n\n \nbool ice_is_vsi_valid(struct ice_hw *hw, u16 vsi_handle)\n{\n\treturn vsi_handle < ICE_MAX_VSI && hw->vsi_ctx[vsi_handle];\n}\n\n \nu16 ice_get_hw_vsi_num(struct ice_hw *hw, u16 vsi_handle)\n{\n\treturn hw->vsi_ctx[vsi_handle]->vsi_num;\n}\n\n \nstruct ice_vsi_ctx *ice_get_vsi_ctx(struct ice_hw *hw, u16 vsi_handle)\n{\n\treturn (vsi_handle >= ICE_MAX_VSI) ? NULL : hw->vsi_ctx[vsi_handle];\n}\n\n \nstatic void\nice_save_vsi_ctx(struct ice_hw *hw, u16 vsi_handle, struct ice_vsi_ctx *vsi)\n{\n\thw->vsi_ctx[vsi_handle] = vsi;\n}\n\n \nstatic void ice_clear_vsi_q_ctx(struct ice_hw *hw, u16 vsi_handle)\n{\n\tstruct ice_vsi_ctx *vsi = ice_get_vsi_ctx(hw, vsi_handle);\n\tu8 i;\n\n\tif (!vsi)\n\t\treturn;\n\tice_for_each_traffic_class(i) {\n\t\tdevm_kfree(ice_hw_to_dev(hw), vsi->lan_q_ctx[i]);\n\t\tvsi->lan_q_ctx[i] = NULL;\n\t\tdevm_kfree(ice_hw_to_dev(hw), vsi->rdma_q_ctx[i]);\n\t\tvsi->rdma_q_ctx[i] = NULL;\n\t}\n}\n\n \nstatic void ice_clear_vsi_ctx(struct ice_hw *hw, u16 vsi_handle)\n{\n\tstruct ice_vsi_ctx *vsi;\n\n\tvsi = ice_get_vsi_ctx(hw, vsi_handle);\n\tif (vsi) {\n\t\tice_clear_vsi_q_ctx(hw, vsi_handle);\n\t\tdevm_kfree(ice_hw_to_dev(hw), vsi);\n\t\thw->vsi_ctx[vsi_handle] = NULL;\n\t}\n}\n\n \nvoid ice_clear_all_vsi_ctx(struct ice_hw *hw)\n{\n\tu16 i;\n\n\tfor (i = 0; i < ICE_MAX_VSI; i++)\n\t\tice_clear_vsi_ctx(hw, i);\n}\n\n \nint\nice_add_vsi(struct ice_hw *hw, u16 vsi_handle, struct ice_vsi_ctx *vsi_ctx,\n\t    struct ice_sq_cd *cd)\n{\n\tstruct ice_vsi_ctx *tmp_vsi_ctx;\n\tint status;\n\n\tif (vsi_handle >= ICE_MAX_VSI)\n\t\treturn -EINVAL;\n\tstatus = ice_aq_add_vsi(hw, vsi_ctx, cd);\n\tif (status)\n\t\treturn status;\n\ttmp_vsi_ctx = ice_get_vsi_ctx(hw, vsi_handle);\n\tif (!tmp_vsi_ctx) {\n\t\t \n\t\ttmp_vsi_ctx = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t\t\t   sizeof(*tmp_vsi_ctx), GFP_KERNEL);\n\t\tif (!tmp_vsi_ctx) {\n\t\t\tice_aq_free_vsi(hw, vsi_ctx, false, cd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t*tmp_vsi_ctx = *vsi_ctx;\n\t\tice_save_vsi_ctx(hw, vsi_handle, tmp_vsi_ctx);\n\t} else {\n\t\t \n\t\ttmp_vsi_ctx->vsi_num = vsi_ctx->vsi_num;\n\t}\n\n\treturn 0;\n}\n\n \nint\nice_free_vsi(struct ice_hw *hw, u16 vsi_handle, struct ice_vsi_ctx *vsi_ctx,\n\t     bool keep_vsi_alloc, struct ice_sq_cd *cd)\n{\n\tint status;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\tvsi_ctx->vsi_num = ice_get_hw_vsi_num(hw, vsi_handle);\n\tstatus = ice_aq_free_vsi(hw, vsi_ctx, keep_vsi_alloc, cd);\n\tif (!status)\n\t\tice_clear_vsi_ctx(hw, vsi_handle);\n\treturn status;\n}\n\n \nint\nice_update_vsi(struct ice_hw *hw, u16 vsi_handle, struct ice_vsi_ctx *vsi_ctx,\n\t       struct ice_sq_cd *cd)\n{\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\tvsi_ctx->vsi_num = ice_get_hw_vsi_num(hw, vsi_handle);\n\treturn ice_aq_update_vsi(hw, vsi_ctx, cd);\n}\n\n \nint\nice_cfg_rdma_fltr(struct ice_hw *hw, u16 vsi_handle, bool enable)\n{\n\tstruct ice_vsi_ctx *ctx, *cached_ctx;\n\tint status;\n\n\tcached_ctx = ice_get_vsi_ctx(hw, vsi_handle);\n\tif (!cached_ctx)\n\t\treturn -ENOENT;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->info.q_opt_rss = cached_ctx->info.q_opt_rss;\n\tctx->info.q_opt_tc = cached_ctx->info.q_opt_tc;\n\tctx->info.q_opt_flags = cached_ctx->info.q_opt_flags;\n\n\tctx->info.valid_sections = cpu_to_le16(ICE_AQ_VSI_PROP_Q_OPT_VALID);\n\n\tif (enable)\n\t\tctx->info.q_opt_flags |= ICE_AQ_VSI_Q_OPT_PE_FLTR_EN;\n\telse\n\t\tctx->info.q_opt_flags &= ~ICE_AQ_VSI_Q_OPT_PE_FLTR_EN;\n\n\tstatus = ice_update_vsi(hw, vsi_handle, ctx, NULL);\n\tif (!status) {\n\t\tcached_ctx->info.q_opt_flags = ctx->info.q_opt_flags;\n\t\tcached_ctx->info.valid_sections |= ctx->info.valid_sections;\n\t}\n\n\tkfree(ctx);\n\treturn status;\n}\n\n \nstatic int\nice_aq_alloc_free_vsi_list(struct ice_hw *hw, u16 *vsi_list_id,\n\t\t\t   enum ice_sw_lkup_type lkup_type,\n\t\t\t   enum ice_adminq_opc opc)\n{\n\tstruct ice_aqc_alloc_free_res_elem *sw_buf;\n\tstruct ice_aqc_res_elem *vsi_ele;\n\tu16 buf_len;\n\tint status;\n\n\tbuf_len = struct_size(sw_buf, elem, 1);\n\tsw_buf = devm_kzalloc(ice_hw_to_dev(hw), buf_len, GFP_KERNEL);\n\tif (!sw_buf)\n\t\treturn -ENOMEM;\n\tsw_buf->num_elems = cpu_to_le16(1);\n\n\tif (lkup_type == ICE_SW_LKUP_MAC ||\n\t    lkup_type == ICE_SW_LKUP_MAC_VLAN ||\n\t    lkup_type == ICE_SW_LKUP_ETHERTYPE ||\n\t    lkup_type == ICE_SW_LKUP_ETHERTYPE_MAC ||\n\t    lkup_type == ICE_SW_LKUP_PROMISC ||\n\t    lkup_type == ICE_SW_LKUP_PROMISC_VLAN ||\n\t    lkup_type == ICE_SW_LKUP_DFLT) {\n\t\tsw_buf->res_type = cpu_to_le16(ICE_AQC_RES_TYPE_VSI_LIST_REP);\n\t} else if (lkup_type == ICE_SW_LKUP_VLAN) {\n\t\tif (opc == ice_aqc_opc_alloc_res)\n\t\t\tsw_buf->res_type =\n\t\t\t\tcpu_to_le16(ICE_AQC_RES_TYPE_VSI_LIST_PRUNE |\n\t\t\t\t\t    ICE_AQC_RES_TYPE_FLAG_SHARED);\n\t\telse\n\t\t\tsw_buf->res_type =\n\t\t\t\tcpu_to_le16(ICE_AQC_RES_TYPE_VSI_LIST_PRUNE);\n\t} else {\n\t\tstatus = -EINVAL;\n\t\tgoto ice_aq_alloc_free_vsi_list_exit;\n\t}\n\n\tif (opc == ice_aqc_opc_free_res)\n\t\tsw_buf->elem[0].e.sw_resp = cpu_to_le16(*vsi_list_id);\n\n\tstatus = ice_aq_alloc_free_res(hw, sw_buf, buf_len, opc);\n\tif (status)\n\t\tgoto ice_aq_alloc_free_vsi_list_exit;\n\n\tif (opc == ice_aqc_opc_alloc_res) {\n\t\tvsi_ele = &sw_buf->elem[0];\n\t\t*vsi_list_id = le16_to_cpu(vsi_ele->e.sw_resp);\n\t}\n\nice_aq_alloc_free_vsi_list_exit:\n\tdevm_kfree(ice_hw_to_dev(hw), sw_buf);\n\treturn status;\n}\n\n \nint\nice_aq_sw_rules(struct ice_hw *hw, void *rule_list, u16 rule_list_sz,\n\t\tu8 num_rules, enum ice_adminq_opc opc, struct ice_sq_cd *cd)\n{\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tif (opc != ice_aqc_opc_add_sw_rules &&\n\t    opc != ice_aqc_opc_update_sw_rules &&\n\t    opc != ice_aqc_opc_remove_sw_rules)\n\t\treturn -EINVAL;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, opc);\n\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\tdesc.params.sw_rules.num_rules_fltr_entry_index =\n\t\tcpu_to_le16(num_rules);\n\tstatus = ice_aq_send_cmd(hw, &desc, rule_list, rule_list_sz, cd);\n\tif (opc != ice_aqc_opc_add_sw_rules &&\n\t    hw->adminq.sq_last_status == ICE_AQ_RC_ENOENT)\n\t\tstatus = -ENOENT;\n\n\treturn status;\n}\n\n \nint\nice_aq_add_recipe(struct ice_hw *hw,\n\t\t  struct ice_aqc_recipe_data_elem *s_recipe_list,\n\t\t  u16 num_recipes, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_add_get_recipe *cmd;\n\tstruct ice_aq_desc desc;\n\tu16 buf_size;\n\n\tcmd = &desc.params.add_get_recipe;\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_add_recipe);\n\n\tcmd->num_sub_recipes = cpu_to_le16(num_recipes);\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\tbuf_size = num_recipes * sizeof(*s_recipe_list);\n\n\treturn ice_aq_send_cmd(hw, &desc, s_recipe_list, buf_size, cd);\n}\n\n \nint\nice_aq_get_recipe(struct ice_hw *hw,\n\t\t  struct ice_aqc_recipe_data_elem *s_recipe_list,\n\t\t  u16 *num_recipes, u16 recipe_root, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_add_get_recipe *cmd;\n\tstruct ice_aq_desc desc;\n\tu16 buf_size;\n\tint status;\n\n\tif (*num_recipes != ICE_MAX_NUM_RECIPES)\n\t\treturn -EINVAL;\n\n\tcmd = &desc.params.add_get_recipe;\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_get_recipe);\n\n\tcmd->return_index = cpu_to_le16(recipe_root);\n\tcmd->num_sub_recipes = 0;\n\n\tbuf_size = *num_recipes * sizeof(*s_recipe_list);\n\n\tstatus = ice_aq_send_cmd(hw, &desc, s_recipe_list, buf_size, cd);\n\t*num_recipes = le16_to_cpu(cmd->num_sub_recipes);\n\n\treturn status;\n}\n\n \nint\nice_update_recipe_lkup_idx(struct ice_hw *hw,\n\t\t\t   struct ice_update_recipe_lkup_idx_params *params)\n{\n\tstruct ice_aqc_recipe_data_elem *rcp_list;\n\tu16 num_recps = ICE_MAX_NUM_RECIPES;\n\tint status;\n\n\trcp_list = kcalloc(num_recps, sizeof(*rcp_list), GFP_KERNEL);\n\tif (!rcp_list)\n\t\treturn -ENOMEM;\n\n\t \n\trcp_list->recipe_indx = params->rid;\n\tstatus = ice_aq_get_recipe(hw, rcp_list, &num_recps, params->rid, NULL);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_SW, \"Failed to get recipe %d, status %d\\n\",\n\t\t\t  params->rid, status);\n\t\tgoto error_out;\n\t}\n\n\t \n\trcp_list->content.lkup_indx[params->lkup_idx] = params->fv_idx;\n\tif (params->mask_valid)\n\t\trcp_list->content.mask[params->lkup_idx] =\n\t\t\tcpu_to_le16(params->mask);\n\n\tif (params->ignore_valid)\n\t\trcp_list->content.lkup_indx[params->lkup_idx] |=\n\t\t\tICE_AQ_RECIPE_LKUP_IGNORE;\n\n\tstatus = ice_aq_add_recipe(hw, &rcp_list[0], 1, NULL);\n\tif (status)\n\t\tice_debug(hw, ICE_DBG_SW, \"Failed to update recipe %d lkup_idx %d fv_idx %d mask %d mask_valid %s, status %d\\n\",\n\t\t\t  params->rid, params->lkup_idx, params->fv_idx,\n\t\t\t  params->mask, params->mask_valid ? \"true\" : \"false\",\n\t\t\t  status);\n\nerror_out:\n\tkfree(rcp_list);\n\treturn status;\n}\n\n \nint\nice_aq_map_recipe_to_profile(struct ice_hw *hw, u32 profile_id, u8 *r_bitmap,\n\t\t\t     struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_recipe_to_profile *cmd;\n\tstruct ice_aq_desc desc;\n\n\tcmd = &desc.params.recipe_to_profile;\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_recipe_to_profile);\n\tcmd->profile_id = cpu_to_le16(profile_id);\n\t \n\tmemcpy(cmd->recipe_assoc, r_bitmap, sizeof(cmd->recipe_assoc));\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n}\n\n \nint\nice_aq_get_recipe_to_profile(struct ice_hw *hw, u32 profile_id, u8 *r_bitmap,\n\t\t\t     struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_recipe_to_profile *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tcmd = &desc.params.recipe_to_profile;\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_get_recipe_to_profile);\n\tcmd->profile_id = cpu_to_le16(profile_id);\n\n\tstatus = ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n\tif (!status)\n\t\tmemcpy(r_bitmap, cmd->recipe_assoc, sizeof(cmd->recipe_assoc));\n\n\treturn status;\n}\n\n \nint ice_alloc_recipe(struct ice_hw *hw, u16 *rid)\n{\n\tstruct ice_aqc_alloc_free_res_elem *sw_buf;\n\tu16 buf_len;\n\tint status;\n\n\tbuf_len = struct_size(sw_buf, elem, 1);\n\tsw_buf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!sw_buf)\n\t\treturn -ENOMEM;\n\n\tsw_buf->num_elems = cpu_to_le16(1);\n\tsw_buf->res_type = cpu_to_le16((ICE_AQC_RES_TYPE_RECIPE <<\n\t\t\t\t\tICE_AQC_RES_TYPE_S) |\n\t\t\t\t\tICE_AQC_RES_TYPE_FLAG_SHARED);\n\tstatus = ice_aq_alloc_free_res(hw, sw_buf, buf_len,\n\t\t\t\t       ice_aqc_opc_alloc_res);\n\tif (!status)\n\t\t*rid = le16_to_cpu(sw_buf->elem[0].e.sw_resp);\n\tkfree(sw_buf);\n\n\treturn status;\n}\n\n \nstatic void ice_get_recp_to_prof_map(struct ice_hw *hw)\n{\n\tDECLARE_BITMAP(r_bitmap, ICE_MAX_NUM_RECIPES);\n\tu16 i;\n\n\tfor (i = 0; i < hw->switch_info->max_used_prof_index + 1; i++) {\n\t\tu16 j;\n\n\t\tbitmap_zero(profile_to_recipe[i], ICE_MAX_NUM_RECIPES);\n\t\tbitmap_zero(r_bitmap, ICE_MAX_NUM_RECIPES);\n\t\tif (ice_aq_get_recipe_to_profile(hw, i, (u8 *)r_bitmap, NULL))\n\t\t\tcontinue;\n\t\tbitmap_copy(profile_to_recipe[i], r_bitmap,\n\t\t\t    ICE_MAX_NUM_RECIPES);\n\t\tfor_each_set_bit(j, r_bitmap, ICE_MAX_NUM_RECIPES)\n\t\t\tset_bit(i, recipe_to_profile[j]);\n\t}\n}\n\n \nstatic void\nice_collect_result_idx(struct ice_aqc_recipe_data_elem *buf,\n\t\t       struct ice_sw_recipe *recp)\n{\n\tif (buf->content.result_indx & ICE_AQ_RECIPE_RESULT_EN)\n\t\tset_bit(buf->content.result_indx & ~ICE_AQ_RECIPE_RESULT_EN,\n\t\t\trecp->res_idxs);\n}\n\n \nstatic int\nice_get_recp_frm_fw(struct ice_hw *hw, struct ice_sw_recipe *recps, u8 rid,\n\t\t    bool *refresh_required)\n{\n\tDECLARE_BITMAP(result_bm, ICE_MAX_FV_WORDS);\n\tstruct ice_aqc_recipe_data_elem *tmp;\n\tu16 num_recps = ICE_MAX_NUM_RECIPES;\n\tstruct ice_prot_lkup_ext *lkup_exts;\n\tu8 fv_word_idx = 0;\n\tu16 sub_recps;\n\tint status;\n\n\tbitmap_zero(result_bm, ICE_MAX_FV_WORDS);\n\n\t \n\ttmp = kcalloc(ICE_MAX_NUM_RECIPES, sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\ttmp[0].recipe_indx = rid;\n\tstatus = ice_aq_get_recipe(hw, tmp, &num_recps, rid, NULL);\n\t \n\tif (status)\n\t\tgoto err_unroll;\n\n\t \n\tif (*refresh_required) {\n\t\tice_get_recp_to_prof_map(hw);\n\t\t*refresh_required = false;\n\t}\n\n\t \n\tlkup_exts = &recps[rid].lkup_exts;\n\n\tfor (sub_recps = 0; sub_recps < num_recps; sub_recps++) {\n\t\tstruct ice_aqc_recipe_data_elem root_bufs = tmp[sub_recps];\n\t\tstruct ice_recp_grp_entry *rg_entry;\n\t\tu8 i, prof, idx, prot = 0;\n\t\tbool is_root;\n\t\tu16 off = 0;\n\n\t\trg_entry = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*rg_entry),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!rg_entry) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto err_unroll;\n\t\t}\n\n\t\tidx = root_bufs.recipe_indx;\n\t\tis_root = root_bufs.content.rid & ICE_AQ_RECIPE_ID_IS_ROOT;\n\n\t\t \n\t\tif (root_bufs.content.result_indx & ICE_AQ_RECIPE_RESULT_EN)\n\t\t\tset_bit(root_bufs.content.result_indx & ~ICE_AQ_RECIPE_RESULT_EN,\n\t\t\t\tresult_bm);\n\n\t\t \n\t\tprof = find_first_bit(recipe_to_profile[idx],\n\t\t\t\t      ICE_MAX_NUM_PROFILES);\n\t\tfor (i = 0; i < ICE_NUM_WORDS_RECIPE; i++) {\n\t\t\tu8 lkup_indx = root_bufs.content.lkup_indx[i + 1];\n\n\t\t\trg_entry->fv_idx[i] = lkup_indx;\n\t\t\trg_entry->fv_mask[i] =\n\t\t\t\tle16_to_cpu(root_bufs.content.mask[i + 1]);\n\n\t\t\t \n\t\t\tif (test_bit(rg_entry->fv_idx[i], hw->switch_info->prof_res_bm[prof]) ||\n\t\t\t    rg_entry->fv_idx[i] & ICE_AQ_RECIPE_LKUP_IGNORE ||\n\t\t\t    rg_entry->fv_idx[i] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tice_find_prot_off(hw, ICE_BLK_SW, prof,\n\t\t\t\t\t  rg_entry->fv_idx[i], &prot, &off);\n\t\t\tlkup_exts->fv_words[fv_word_idx].prot_id = prot;\n\t\t\tlkup_exts->fv_words[fv_word_idx].off = off;\n\t\t\tlkup_exts->field_mask[fv_word_idx] =\n\t\t\t\trg_entry->fv_mask[i];\n\t\t\tfv_word_idx++;\n\t\t}\n\t\t \n\t\tlist_add(&rg_entry->l_entry, &recps[rid].rg_list);\n\n\t\t \n\t\trecps[idx].is_root = !!is_root;\n\t\trecps[idx].priority = root_bufs.content.act_ctrl_fwd_priority;\n\t\trecps[idx].need_pass_l2 = root_bufs.content.act_ctrl &\n\t\t\t\t\t  ICE_AQ_RECIPE_ACT_NEED_PASS_L2;\n\t\trecps[idx].allow_pass_l2 = root_bufs.content.act_ctrl &\n\t\t\t\t\t   ICE_AQ_RECIPE_ACT_ALLOW_PASS_L2;\n\t\tbitmap_zero(recps[idx].res_idxs, ICE_MAX_FV_WORDS);\n\t\tif (root_bufs.content.result_indx & ICE_AQ_RECIPE_RESULT_EN) {\n\t\t\trecps[idx].chain_idx = root_bufs.content.result_indx &\n\t\t\t\t~ICE_AQ_RECIPE_RESULT_EN;\n\t\t\tset_bit(recps[idx].chain_idx, recps[idx].res_idxs);\n\t\t} else {\n\t\t\trecps[idx].chain_idx = ICE_INVAL_CHAIN_IND;\n\t\t}\n\n\t\tif (!is_root)\n\t\t\tcontinue;\n\n\t\t \n\t\tmemcpy(recps[idx].r_bitmap, root_bufs.recipe_bitmap,\n\t\t       sizeof(recps[idx].r_bitmap));\n\t\trecps[idx].root_rid = root_bufs.content.rid &\n\t\t\t~ICE_AQ_RECIPE_ID_IS_ROOT;\n\t\trecps[idx].priority = root_bufs.content.act_ctrl_fwd_priority;\n\t}\n\n\t \n\tlkup_exts->n_val_words = fv_word_idx;\n\trecps[rid].big_recp = (num_recps > 1);\n\trecps[rid].n_grp_count = (u8)num_recps;\n\trecps[rid].root_buf = devm_kmemdup(ice_hw_to_dev(hw), tmp,\n\t\t\t\t\t   recps[rid].n_grp_count * sizeof(*recps[rid].root_buf),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!recps[rid].root_buf) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unroll;\n\t}\n\n\t \n\tbitmap_copy(recps[rid].res_idxs, result_bm, ICE_MAX_FV_WORDS);\n\trecps[rid].recp_created = true;\n\nerr_unroll:\n\tkfree(tmp);\n\treturn status;\n}\n\n \nstatic void\nice_init_port_info(struct ice_port_info *pi, u16 vsi_port_num, u8 type,\n\t\t   u16 swid, u16 pf_vf_num, bool is_vf)\n{\n\tswitch (type) {\n\tcase ICE_AQC_GET_SW_CONF_RESP_PHYS_PORT:\n\t\tpi->lport = (u8)(vsi_port_num & ICE_LPORT_MASK);\n\t\tpi->sw_id = swid;\n\t\tpi->pf_vf_num = pf_vf_num;\n\t\tpi->is_vf = is_vf;\n\t\tbreak;\n\tdefault:\n\t\tice_debug(pi->hw, ICE_DBG_SW, \"incorrect VSI/port type received\\n\");\n\t\tbreak;\n\t}\n}\n\n \nint ice_get_initial_sw_cfg(struct ice_hw *hw)\n{\n\tstruct ice_aqc_get_sw_cfg_resp_elem *rbuf;\n\tu16 req_desc = 0;\n\tu16 num_elems;\n\tint status;\n\tu16 i;\n\n\trbuf = kzalloc(ICE_SW_CFG_MAX_BUF_LEN, GFP_KERNEL);\n\tif (!rbuf)\n\t\treturn -ENOMEM;\n\n\t \n\tdo {\n\t\tstruct ice_aqc_get_sw_cfg_resp_elem *ele;\n\n\t\tstatus = ice_aq_get_sw_cfg(hw, rbuf, ICE_SW_CFG_MAX_BUF_LEN,\n\t\t\t\t\t   &req_desc, &num_elems, NULL);\n\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tfor (i = 0, ele = rbuf; i < num_elems; i++, ele++) {\n\t\t\tu16 pf_vf_num, swid, vsi_port_num;\n\t\t\tbool is_vf = false;\n\t\t\tu8 res_type;\n\n\t\t\tvsi_port_num = le16_to_cpu(ele->vsi_port_num) &\n\t\t\t\tICE_AQC_GET_SW_CONF_RESP_VSI_PORT_NUM_M;\n\n\t\t\tpf_vf_num = le16_to_cpu(ele->pf_vf_num) &\n\t\t\t\tICE_AQC_GET_SW_CONF_RESP_FUNC_NUM_M;\n\n\t\t\tswid = le16_to_cpu(ele->swid);\n\n\t\t\tif (le16_to_cpu(ele->pf_vf_num) &\n\t\t\t    ICE_AQC_GET_SW_CONF_RESP_IS_VF)\n\t\t\t\tis_vf = true;\n\n\t\t\tres_type = (u8)(le16_to_cpu(ele->vsi_port_num) >>\n\t\t\t\t\tICE_AQC_GET_SW_CONF_RESP_TYPE_S);\n\n\t\t\tif (res_type == ICE_AQC_GET_SW_CONF_RESP_VSI) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tice_init_port_info(hw->port_info, vsi_port_num,\n\t\t\t\t\t   res_type, swid, pf_vf_num, is_vf);\n\t\t}\n\t} while (req_desc && !status);\n\n\tkfree(rbuf);\n\treturn status;\n}\n\n \nstatic void ice_fill_sw_info(struct ice_hw *hw, struct ice_fltr_info *fi)\n{\n\tfi->lb_en = false;\n\tfi->lan_en = false;\n\tif ((fi->flag & ICE_FLTR_TX) &&\n\t    (fi->fltr_act == ICE_FWD_TO_VSI ||\n\t     fi->fltr_act == ICE_FWD_TO_VSI_LIST ||\n\t     fi->fltr_act == ICE_FWD_TO_Q ||\n\t     fi->fltr_act == ICE_FWD_TO_QGRP)) {\n\t\t \n\t\tif (fi->lkup_type != ICE_SW_LKUP_VLAN)\n\t\t\tfi->lb_en = true;\n\n\t\t \n\t\tif (hw->evb_veb) {\n\t\t\tif (fi->lkup_type == ICE_SW_LKUP_ETHERTYPE ||\n\t\t\t    fi->lkup_type == ICE_SW_LKUP_PROMISC ||\n\t\t\t    fi->lkup_type == ICE_SW_LKUP_ETHERTYPE_MAC ||\n\t\t\t    fi->lkup_type == ICE_SW_LKUP_PROMISC_VLAN ||\n\t\t\t    fi->lkup_type == ICE_SW_LKUP_DFLT ||\n\t\t\t    fi->lkup_type == ICE_SW_LKUP_VLAN ||\n\t\t\t    (fi->lkup_type == ICE_SW_LKUP_MAC &&\n\t\t\t     !is_unicast_ether_addr(fi->l_data.mac.mac_addr)) ||\n\t\t\t    (fi->lkup_type == ICE_SW_LKUP_MAC_VLAN &&\n\t\t\t     !is_unicast_ether_addr(fi->l_data.mac.mac_addr)))\n\t\t\t\tfi->lan_en = true;\n\t\t} else {\n\t\t\tfi->lan_en = true;\n\t\t}\n\t}\n}\n\n \nvoid ice_fill_eth_hdr(u8 *eth_hdr)\n{\n\tmemcpy(eth_hdr, dummy_eth_header, DUMMY_ETH_HDR_LEN);\n}\n\n \nstatic void\nice_fill_sw_rule(struct ice_hw *hw, struct ice_fltr_info *f_info,\n\t\t struct ice_sw_rule_lkup_rx_tx *s_rule,\n\t\t enum ice_adminq_opc opc)\n{\n\tu16 vlan_id = ICE_MAX_VLAN_ID + 1;\n\tu16 vlan_tpid = ETH_P_8021Q;\n\tvoid *daddr = NULL;\n\tu16 eth_hdr_sz;\n\tu8 *eth_hdr;\n\tu32 act = 0;\n\t__be16 *off;\n\tu8 q_rgn;\n\n\tif (opc == ice_aqc_opc_remove_sw_rules) {\n\t\ts_rule->act = 0;\n\t\ts_rule->index = cpu_to_le16(f_info->fltr_rule_id);\n\t\ts_rule->hdr_len = 0;\n\t\treturn;\n\t}\n\n\teth_hdr_sz = sizeof(dummy_eth_header);\n\teth_hdr = s_rule->hdr_data;\n\n\t \n\tmemcpy(eth_hdr, dummy_eth_header, eth_hdr_sz);\n\tice_fill_sw_info(hw, f_info);\n\n\tswitch (f_info->fltr_act) {\n\tcase ICE_FWD_TO_VSI:\n\t\tact |= (f_info->fwd_id.hw_vsi_id << ICE_SINGLE_ACT_VSI_ID_S) &\n\t\t\tICE_SINGLE_ACT_VSI_ID_M;\n\t\tif (f_info->lkup_type != ICE_SW_LKUP_VLAN)\n\t\t\tact |= ICE_SINGLE_ACT_VSI_FORWARDING |\n\t\t\t\tICE_SINGLE_ACT_VALID_BIT;\n\t\tbreak;\n\tcase ICE_FWD_TO_VSI_LIST:\n\t\tact |= ICE_SINGLE_ACT_VSI_LIST;\n\t\tact |= (f_info->fwd_id.vsi_list_id <<\n\t\t\tICE_SINGLE_ACT_VSI_LIST_ID_S) &\n\t\t\tICE_SINGLE_ACT_VSI_LIST_ID_M;\n\t\tif (f_info->lkup_type != ICE_SW_LKUP_VLAN)\n\t\t\tact |= ICE_SINGLE_ACT_VSI_FORWARDING |\n\t\t\t\tICE_SINGLE_ACT_VALID_BIT;\n\t\tbreak;\n\tcase ICE_FWD_TO_Q:\n\t\tact |= ICE_SINGLE_ACT_TO_Q;\n\t\tact |= (f_info->fwd_id.q_id << ICE_SINGLE_ACT_Q_INDEX_S) &\n\t\t\tICE_SINGLE_ACT_Q_INDEX_M;\n\t\tbreak;\n\tcase ICE_DROP_PACKET:\n\t\tact |= ICE_SINGLE_ACT_VSI_FORWARDING | ICE_SINGLE_ACT_DROP |\n\t\t\tICE_SINGLE_ACT_VALID_BIT;\n\t\tbreak;\n\tcase ICE_FWD_TO_QGRP:\n\t\tq_rgn = f_info->qgrp_size > 0 ?\n\t\t\t(u8)ilog2(f_info->qgrp_size) : 0;\n\t\tact |= ICE_SINGLE_ACT_TO_Q;\n\t\tact |= (f_info->fwd_id.q_id << ICE_SINGLE_ACT_Q_INDEX_S) &\n\t\t\tICE_SINGLE_ACT_Q_INDEX_M;\n\t\tact |= (q_rgn << ICE_SINGLE_ACT_Q_REGION_S) &\n\t\t\tICE_SINGLE_ACT_Q_REGION_M;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (f_info->lb_en)\n\t\tact |= ICE_SINGLE_ACT_LB_ENABLE;\n\tif (f_info->lan_en)\n\t\tact |= ICE_SINGLE_ACT_LAN_ENABLE;\n\n\tswitch (f_info->lkup_type) {\n\tcase ICE_SW_LKUP_MAC:\n\t\tdaddr = f_info->l_data.mac.mac_addr;\n\t\tbreak;\n\tcase ICE_SW_LKUP_VLAN:\n\t\tvlan_id = f_info->l_data.vlan.vlan_id;\n\t\tif (f_info->l_data.vlan.tpid_valid)\n\t\t\tvlan_tpid = f_info->l_data.vlan.tpid;\n\t\tif (f_info->fltr_act == ICE_FWD_TO_VSI ||\n\t\t    f_info->fltr_act == ICE_FWD_TO_VSI_LIST) {\n\t\t\tact |= ICE_SINGLE_ACT_PRUNE;\n\t\t\tact |= ICE_SINGLE_ACT_EGRESS | ICE_SINGLE_ACT_INGRESS;\n\t\t}\n\t\tbreak;\n\tcase ICE_SW_LKUP_ETHERTYPE_MAC:\n\t\tdaddr = f_info->l_data.ethertype_mac.mac_addr;\n\t\tfallthrough;\n\tcase ICE_SW_LKUP_ETHERTYPE:\n\t\toff = (__force __be16 *)(eth_hdr + ICE_ETH_ETHTYPE_OFFSET);\n\t\t*off = cpu_to_be16(f_info->l_data.ethertype_mac.ethertype);\n\t\tbreak;\n\tcase ICE_SW_LKUP_MAC_VLAN:\n\t\tdaddr = f_info->l_data.mac_vlan.mac_addr;\n\t\tvlan_id = f_info->l_data.mac_vlan.vlan_id;\n\t\tbreak;\n\tcase ICE_SW_LKUP_PROMISC_VLAN:\n\t\tvlan_id = f_info->l_data.mac_vlan.vlan_id;\n\t\tfallthrough;\n\tcase ICE_SW_LKUP_PROMISC:\n\t\tdaddr = f_info->l_data.mac_vlan.mac_addr;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ts_rule->hdr.type = (f_info->flag & ICE_FLTR_RX) ?\n\t\tcpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_RX) :\n\t\tcpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_TX);\n\n\t \n\ts_rule->recipe_id = cpu_to_le16(f_info->lkup_type);\n\ts_rule->src = cpu_to_le16(f_info->src);\n\ts_rule->act = cpu_to_le32(act);\n\n\tif (daddr)\n\t\tether_addr_copy(eth_hdr + ICE_ETH_DA_OFFSET, daddr);\n\n\tif (!(vlan_id > ICE_MAX_VLAN_ID)) {\n\t\toff = (__force __be16 *)(eth_hdr + ICE_ETH_VLAN_TCI_OFFSET);\n\t\t*off = cpu_to_be16(vlan_id);\n\t\toff = (__force __be16 *)(eth_hdr + ICE_ETH_ETHTYPE_OFFSET);\n\t\t*off = cpu_to_be16(vlan_tpid);\n\t}\n\n\t \n\tif (opc != ice_aqc_opc_update_sw_rules)\n\t\ts_rule->hdr_len = cpu_to_le16(eth_hdr_sz);\n}\n\n \nstatic int\nice_add_marker_act(struct ice_hw *hw, struct ice_fltr_mgmt_list_entry *m_ent,\n\t\t   u16 sw_marker, u16 l_id)\n{\n\tstruct ice_sw_rule_lkup_rx_tx *rx_tx;\n\tstruct ice_sw_rule_lg_act *lg_act;\n\t \n\tconst u16 num_lg_acts = 3;\n\tu16 lg_act_size;\n\tu16 rules_size;\n\tint status;\n\tu32 act;\n\tu16 id;\n\n\tif (m_ent->fltr_info.lkup_type != ICE_SW_LKUP_MAC)\n\t\treturn -EINVAL;\n\n\t \n\tlg_act_size = (u16)ICE_SW_RULE_LG_ACT_SIZE(lg_act, num_lg_acts);\n\trules_size = lg_act_size + ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(rx_tx);\n\tlg_act = devm_kzalloc(ice_hw_to_dev(hw), rules_size, GFP_KERNEL);\n\tif (!lg_act)\n\t\treturn -ENOMEM;\n\n\trx_tx = (typeof(rx_tx))((u8 *)lg_act + lg_act_size);\n\n\t \n\tlg_act->hdr.type = cpu_to_le16(ICE_AQC_SW_RULES_T_LG_ACT);\n\tlg_act->index = cpu_to_le16(l_id);\n\tlg_act->size = cpu_to_le16(num_lg_acts);\n\n\t \n\tid = (m_ent->vsi_count > 1) ? m_ent->fltr_info.fwd_id.vsi_list_id :\n\t\tm_ent->fltr_info.fwd_id.hw_vsi_id;\n\n\tact = ICE_LG_ACT_VSI_FORWARDING | ICE_LG_ACT_VALID_BIT;\n\tact |= (id << ICE_LG_ACT_VSI_LIST_ID_S) & ICE_LG_ACT_VSI_LIST_ID_M;\n\tif (m_ent->vsi_count > 1)\n\t\tact |= ICE_LG_ACT_VSI_LIST;\n\tlg_act->act[0] = cpu_to_le32(act);\n\n\t \n\tact = ICE_LG_ACT_GENERIC;\n\n\tact |= (1 << ICE_LG_ACT_GENERIC_VALUE_S) & ICE_LG_ACT_GENERIC_VALUE_M;\n\tlg_act->act[1] = cpu_to_le32(act);\n\n\tact = (ICE_LG_ACT_GENERIC_OFF_RX_DESC_PROF_IDX <<\n\t       ICE_LG_ACT_GENERIC_OFFSET_S) & ICE_LG_ACT_GENERIC_OFFSET_M;\n\n\t \n\tact |= ICE_LG_ACT_GENERIC;\n\tact |= (sw_marker << ICE_LG_ACT_GENERIC_VALUE_S) &\n\t\tICE_LG_ACT_GENERIC_VALUE_M;\n\n\tlg_act->act[2] = cpu_to_le32(act);\n\n\t \n\tice_fill_sw_rule(hw, &m_ent->fltr_info, rx_tx,\n\t\t\t ice_aqc_opc_update_sw_rules);\n\n\t \n\trx_tx->act = cpu_to_le32(ICE_SINGLE_ACT_PTR |\n\t\t\t\t ((l_id << ICE_SINGLE_ACT_PTR_VAL_S) &\n\t\t\t\t  ICE_SINGLE_ACT_PTR_VAL_M));\n\n\t \n\trx_tx->index = cpu_to_le16(m_ent->fltr_info.fltr_rule_id);\n\n\tstatus = ice_aq_sw_rules(hw, lg_act, rules_size, 2,\n\t\t\t\t ice_aqc_opc_update_sw_rules, NULL);\n\tif (!status) {\n\t\tm_ent->lg_act_idx = l_id;\n\t\tm_ent->sw_marker_id = sw_marker;\n\t}\n\n\tdevm_kfree(ice_hw_to_dev(hw), lg_act);\n\treturn status;\n}\n\n \nstatic struct ice_vsi_list_map_info *\nice_create_vsi_list_map(struct ice_hw *hw, u16 *vsi_handle_arr, u16 num_vsi,\n\t\t\tu16 vsi_list_id)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_vsi_list_map_info *v_map;\n\tint i;\n\n\tv_map = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*v_map), GFP_KERNEL);\n\tif (!v_map)\n\t\treturn NULL;\n\n\tv_map->vsi_list_id = vsi_list_id;\n\tv_map->ref_cnt = 1;\n\tfor (i = 0; i < num_vsi; i++)\n\t\tset_bit(vsi_handle_arr[i], v_map->vsi_map);\n\n\tlist_add(&v_map->list_entry, &sw->vsi_list_map_head);\n\treturn v_map;\n}\n\n \nstatic int\nice_update_vsi_list_rule(struct ice_hw *hw, u16 *vsi_handle_arr, u16 num_vsi,\n\t\t\t u16 vsi_list_id, bool remove, enum ice_adminq_opc opc,\n\t\t\t enum ice_sw_lkup_type lkup_type)\n{\n\tstruct ice_sw_rule_vsi_list *s_rule;\n\tu16 s_rule_size;\n\tu16 rule_type;\n\tint status;\n\tint i;\n\n\tif (!num_vsi)\n\t\treturn -EINVAL;\n\n\tif (lkup_type == ICE_SW_LKUP_MAC ||\n\t    lkup_type == ICE_SW_LKUP_MAC_VLAN ||\n\t    lkup_type == ICE_SW_LKUP_ETHERTYPE ||\n\t    lkup_type == ICE_SW_LKUP_ETHERTYPE_MAC ||\n\t    lkup_type == ICE_SW_LKUP_PROMISC ||\n\t    lkup_type == ICE_SW_LKUP_PROMISC_VLAN ||\n\t    lkup_type == ICE_SW_LKUP_DFLT)\n\t\trule_type = remove ? ICE_AQC_SW_RULES_T_VSI_LIST_CLEAR :\n\t\t\tICE_AQC_SW_RULES_T_VSI_LIST_SET;\n\telse if (lkup_type == ICE_SW_LKUP_VLAN)\n\t\trule_type = remove ? ICE_AQC_SW_RULES_T_PRUNE_LIST_CLEAR :\n\t\t\tICE_AQC_SW_RULES_T_PRUNE_LIST_SET;\n\telse\n\t\treturn -EINVAL;\n\n\ts_rule_size = (u16)ICE_SW_RULE_VSI_LIST_SIZE(s_rule, num_vsi);\n\ts_rule = devm_kzalloc(ice_hw_to_dev(hw), s_rule_size, GFP_KERNEL);\n\tif (!s_rule)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < num_vsi; i++) {\n\t\tif (!ice_is_vsi_valid(hw, vsi_handle_arr[i])) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\ts_rule->vsi[i] =\n\t\t\tcpu_to_le16(ice_get_hw_vsi_num(hw, vsi_handle_arr[i]));\n\t}\n\n\ts_rule->hdr.type = cpu_to_le16(rule_type);\n\ts_rule->number_vsi = cpu_to_le16(num_vsi);\n\ts_rule->index = cpu_to_le16(vsi_list_id);\n\n\tstatus = ice_aq_sw_rules(hw, s_rule, s_rule_size, 1, opc, NULL);\n\nexit:\n\tdevm_kfree(ice_hw_to_dev(hw), s_rule);\n\treturn status;\n}\n\n \nstatic int\nice_create_vsi_list_rule(struct ice_hw *hw, u16 *vsi_handle_arr, u16 num_vsi,\n\t\t\t u16 *vsi_list_id, enum ice_sw_lkup_type lkup_type)\n{\n\tint status;\n\n\tstatus = ice_aq_alloc_free_vsi_list(hw, vsi_list_id, lkup_type,\n\t\t\t\t\t    ice_aqc_opc_alloc_res);\n\tif (status)\n\t\treturn status;\n\n\t \n\treturn ice_update_vsi_list_rule(hw, vsi_handle_arr, num_vsi,\n\t\t\t\t\t*vsi_list_id, false,\n\t\t\t\t\tice_aqc_opc_add_sw_rules, lkup_type);\n}\n\n \nstatic int\nice_create_pkt_fwd_rule(struct ice_hw *hw,\n\t\t\tstruct ice_fltr_list_entry *f_entry)\n{\n\tstruct ice_fltr_mgmt_list_entry *fm_entry;\n\tstruct ice_sw_rule_lkup_rx_tx *s_rule;\n\tenum ice_sw_lkup_type l_type;\n\tstruct ice_sw_recipe *recp;\n\tint status;\n\n\ts_rule = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t      ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(s_rule),\n\t\t\t      GFP_KERNEL);\n\tif (!s_rule)\n\t\treturn -ENOMEM;\n\tfm_entry = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*fm_entry),\n\t\t\t\tGFP_KERNEL);\n\tif (!fm_entry) {\n\t\tstatus = -ENOMEM;\n\t\tgoto ice_create_pkt_fwd_rule_exit;\n\t}\n\n\tfm_entry->fltr_info = f_entry->fltr_info;\n\n\t \n\tfm_entry->vsi_count = 1;\n\tfm_entry->lg_act_idx = ICE_INVAL_LG_ACT_INDEX;\n\tfm_entry->sw_marker_id = ICE_INVAL_SW_MARKER_ID;\n\tfm_entry->counter_index = ICE_INVAL_COUNTER_ID;\n\n\tice_fill_sw_rule(hw, &fm_entry->fltr_info, s_rule,\n\t\t\t ice_aqc_opc_add_sw_rules);\n\n\tstatus = ice_aq_sw_rules(hw, s_rule,\n\t\t\t\t ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(s_rule), 1,\n\t\t\t\t ice_aqc_opc_add_sw_rules, NULL);\n\tif (status) {\n\t\tdevm_kfree(ice_hw_to_dev(hw), fm_entry);\n\t\tgoto ice_create_pkt_fwd_rule_exit;\n\t}\n\n\tf_entry->fltr_info.fltr_rule_id = le16_to_cpu(s_rule->index);\n\tfm_entry->fltr_info.fltr_rule_id = le16_to_cpu(s_rule->index);\n\n\t \n\tl_type = fm_entry->fltr_info.lkup_type;\n\trecp = &hw->switch_info->recp_list[l_type];\n\tlist_add(&fm_entry->list_entry, &recp->filt_rules);\n\nice_create_pkt_fwd_rule_exit:\n\tdevm_kfree(ice_hw_to_dev(hw), s_rule);\n\treturn status;\n}\n\n \nstatic int\nice_update_pkt_fwd_rule(struct ice_hw *hw, struct ice_fltr_info *f_info)\n{\n\tstruct ice_sw_rule_lkup_rx_tx *s_rule;\n\tint status;\n\n\ts_rule = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t      ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(s_rule),\n\t\t\t      GFP_KERNEL);\n\tif (!s_rule)\n\t\treturn -ENOMEM;\n\n\tice_fill_sw_rule(hw, f_info, s_rule, ice_aqc_opc_update_sw_rules);\n\n\ts_rule->index = cpu_to_le16(f_info->fltr_rule_id);\n\n\t \n\tstatus = ice_aq_sw_rules(hw, s_rule,\n\t\t\t\t ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(s_rule), 1,\n\t\t\t\t ice_aqc_opc_update_sw_rules, NULL);\n\n\tdevm_kfree(ice_hw_to_dev(hw), s_rule);\n\treturn status;\n}\n\n \nint ice_update_sw_rule_bridge_mode(struct ice_hw *hw)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_mgmt_list_entry *fm_entry;\n\tstruct list_head *rule_head;\n\tstruct mutex *rule_lock;  \n\tint status = 0;\n\n\trule_lock = &sw->recp_list[ICE_SW_LKUP_MAC].filt_rule_lock;\n\trule_head = &sw->recp_list[ICE_SW_LKUP_MAC].filt_rules;\n\n\tmutex_lock(rule_lock);\n\tlist_for_each_entry(fm_entry, rule_head, list_entry) {\n\t\tstruct ice_fltr_info *fi = &fm_entry->fltr_info;\n\t\tu8 *addr = fi->l_data.mac.mac_addr;\n\n\t\t \n\t\tif ((fi->flag & ICE_FLTR_TX) && is_unicast_ether_addr(addr) &&\n\t\t    (fi->fltr_act == ICE_FWD_TO_VSI ||\n\t\t     fi->fltr_act == ICE_FWD_TO_VSI_LIST ||\n\t\t     fi->fltr_act == ICE_FWD_TO_Q ||\n\t\t     fi->fltr_act == ICE_FWD_TO_QGRP)) {\n\t\t\tstatus = ice_update_pkt_fwd_rule(hw, fi);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(rule_lock);\n\n\treturn status;\n}\n\n \nstatic int\nice_add_update_vsi_list(struct ice_hw *hw,\n\t\t\tstruct ice_fltr_mgmt_list_entry *m_entry,\n\t\t\tstruct ice_fltr_info *cur_fltr,\n\t\t\tstruct ice_fltr_info *new_fltr)\n{\n\tu16 vsi_list_id = 0;\n\tint status = 0;\n\n\tif ((cur_fltr->fltr_act == ICE_FWD_TO_Q ||\n\t     cur_fltr->fltr_act == ICE_FWD_TO_QGRP))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((new_fltr->fltr_act == ICE_FWD_TO_Q ||\n\t     new_fltr->fltr_act == ICE_FWD_TO_QGRP) &&\n\t    (cur_fltr->fltr_act == ICE_FWD_TO_VSI ||\n\t     cur_fltr->fltr_act == ICE_FWD_TO_VSI_LIST))\n\t\treturn -EOPNOTSUPP;\n\n\tif (m_entry->vsi_count < 2 && !m_entry->vsi_list_info) {\n\t\t \n\t\tstruct ice_fltr_info tmp_fltr;\n\t\tu16 vsi_handle_arr[2];\n\n\t\t \n\t\tif (cur_fltr->fwd_id.hw_vsi_id == new_fltr->fwd_id.hw_vsi_id)\n\t\t\treturn -EEXIST;\n\n\t\tvsi_handle_arr[0] = cur_fltr->vsi_handle;\n\t\tvsi_handle_arr[1] = new_fltr->vsi_handle;\n\t\tstatus = ice_create_vsi_list_rule(hw, &vsi_handle_arr[0], 2,\n\t\t\t\t\t\t  &vsi_list_id,\n\t\t\t\t\t\t  new_fltr->lkup_type);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\ttmp_fltr = *new_fltr;\n\t\ttmp_fltr.fltr_rule_id = cur_fltr->fltr_rule_id;\n\t\ttmp_fltr.fltr_act = ICE_FWD_TO_VSI_LIST;\n\t\ttmp_fltr.fwd_id.vsi_list_id = vsi_list_id;\n\t\t \n\t\tstatus = ice_update_pkt_fwd_rule(hw, &tmp_fltr);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tcur_fltr->fwd_id.vsi_list_id = vsi_list_id;\n\t\tcur_fltr->fltr_act = ICE_FWD_TO_VSI_LIST;\n\t\tm_entry->vsi_list_info =\n\t\t\tice_create_vsi_list_map(hw, &vsi_handle_arr[0], 2,\n\t\t\t\t\t\tvsi_list_id);\n\n\t\tif (!m_entry->vsi_list_info)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (m_entry->sw_marker_id != ICE_INVAL_SW_MARKER_ID)\n\t\t\tstatus =\n\t\t\t    ice_add_marker_act(hw, m_entry,\n\t\t\t\t\t       m_entry->sw_marker_id,\n\t\t\t\t\t       m_entry->lg_act_idx);\n\t} else {\n\t\tu16 vsi_handle = new_fltr->vsi_handle;\n\t\tenum ice_adminq_opc opcode;\n\n\t\tif (!m_entry->vsi_list_info)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (test_bit(vsi_handle, m_entry->vsi_list_info->vsi_map))\n\t\t\treturn 0;\n\n\t\t \n\t\tvsi_list_id = cur_fltr->fwd_id.vsi_list_id;\n\t\topcode = ice_aqc_opc_update_sw_rules;\n\n\t\tstatus = ice_update_vsi_list_rule(hw, &vsi_handle, 1,\n\t\t\t\t\t\t  vsi_list_id, false, opcode,\n\t\t\t\t\t\t  new_fltr->lkup_type);\n\t\t \n\t\tif (!status)\n\t\t\tset_bit(vsi_handle, m_entry->vsi_list_info->vsi_map);\n\t}\n\tif (!status)\n\t\tm_entry->vsi_count++;\n\treturn status;\n}\n\n \nstatic struct ice_fltr_mgmt_list_entry *\nice_find_rule_entry(struct ice_hw *hw, u8 recp_id, struct ice_fltr_info *f_info)\n{\n\tstruct ice_fltr_mgmt_list_entry *list_itr, *ret = NULL;\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct list_head *list_head;\n\n\tlist_head = &sw->recp_list[recp_id].filt_rules;\n\tlist_for_each_entry(list_itr, list_head, list_entry) {\n\t\tif (!memcmp(&f_info->l_data, &list_itr->fltr_info.l_data,\n\t\t\t    sizeof(f_info->l_data)) &&\n\t\t    f_info->flag == list_itr->fltr_info.flag) {\n\t\t\tret = list_itr;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstruct ice_vsi_list_map_info *\nice_find_vsi_list_entry(struct ice_hw *hw, u8 recp_id, u16 vsi_handle,\n\t\t\tu16 *vsi_list_id)\n{\n\tstruct ice_vsi_list_map_info *map_info = NULL;\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_mgmt_list_entry *list_itr;\n\tstruct list_head *list_head;\n\n\tlist_head = &sw->recp_list[recp_id].filt_rules;\n\tlist_for_each_entry(list_itr, list_head, list_entry) {\n\t\tif (list_itr->vsi_list_info) {\n\t\t\tmap_info = list_itr->vsi_list_info;\n\t\t\tif (test_bit(vsi_handle, map_info->vsi_map)) {\n\t\t\t\t*vsi_list_id = map_info->vsi_list_id;\n\t\t\t\treturn map_info;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int\nice_add_rule_internal(struct ice_hw *hw, u8 recp_id,\n\t\t      struct ice_fltr_list_entry *f_entry)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_info *new_fltr, *cur_fltr;\n\tstruct ice_fltr_mgmt_list_entry *m_entry;\n\tstruct mutex *rule_lock;  \n\tint status = 0;\n\n\tif (!ice_is_vsi_valid(hw, f_entry->fltr_info.vsi_handle))\n\t\treturn -EINVAL;\n\tf_entry->fltr_info.fwd_id.hw_vsi_id =\n\t\tice_get_hw_vsi_num(hw, f_entry->fltr_info.vsi_handle);\n\n\trule_lock = &sw->recp_list[recp_id].filt_rule_lock;\n\n\tmutex_lock(rule_lock);\n\tnew_fltr = &f_entry->fltr_info;\n\tif (new_fltr->flag & ICE_FLTR_RX)\n\t\tnew_fltr->src = hw->port_info->lport;\n\telse if (new_fltr->flag & ICE_FLTR_TX)\n\t\tnew_fltr->src = f_entry->fltr_info.fwd_id.hw_vsi_id;\n\n\tm_entry = ice_find_rule_entry(hw, recp_id, new_fltr);\n\tif (!m_entry) {\n\t\tmutex_unlock(rule_lock);\n\t\treturn ice_create_pkt_fwd_rule(hw, f_entry);\n\t}\n\n\tcur_fltr = &m_entry->fltr_info;\n\tstatus = ice_add_update_vsi_list(hw, m_entry, cur_fltr, new_fltr);\n\tmutex_unlock(rule_lock);\n\n\treturn status;\n}\n\n \nstatic int\nice_remove_vsi_list_rule(struct ice_hw *hw, u16 vsi_list_id,\n\t\t\t enum ice_sw_lkup_type lkup_type)\n{\n\tstruct ice_sw_rule_vsi_list *s_rule;\n\tu16 s_rule_size;\n\tint status;\n\n\ts_rule_size = (u16)ICE_SW_RULE_VSI_LIST_SIZE(s_rule, 0);\n\ts_rule = devm_kzalloc(ice_hw_to_dev(hw), s_rule_size, GFP_KERNEL);\n\tif (!s_rule)\n\t\treturn -ENOMEM;\n\n\ts_rule->hdr.type = cpu_to_le16(ICE_AQC_SW_RULES_T_VSI_LIST_CLEAR);\n\ts_rule->index = cpu_to_le16(vsi_list_id);\n\n\t \n\tstatus = ice_aq_alloc_free_vsi_list(hw, &vsi_list_id, lkup_type,\n\t\t\t\t\t    ice_aqc_opc_free_res);\n\n\tdevm_kfree(ice_hw_to_dev(hw), s_rule);\n\treturn status;\n}\n\n \nstatic int\nice_rem_update_vsi_list(struct ice_hw *hw, u16 vsi_handle,\n\t\t\tstruct ice_fltr_mgmt_list_entry *fm_list)\n{\n\tenum ice_sw_lkup_type lkup_type;\n\tu16 vsi_list_id;\n\tint status = 0;\n\n\tif (fm_list->fltr_info.fltr_act != ICE_FWD_TO_VSI_LIST ||\n\t    fm_list->vsi_count == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!test_bit(vsi_handle, fm_list->vsi_list_info->vsi_map))\n\t\treturn -ENOENT;\n\n\tlkup_type = fm_list->fltr_info.lkup_type;\n\tvsi_list_id = fm_list->fltr_info.fwd_id.vsi_list_id;\n\tstatus = ice_update_vsi_list_rule(hw, &vsi_handle, 1, vsi_list_id, true,\n\t\t\t\t\t  ice_aqc_opc_update_sw_rules,\n\t\t\t\t\t  lkup_type);\n\tif (status)\n\t\treturn status;\n\n\tfm_list->vsi_count--;\n\tclear_bit(vsi_handle, fm_list->vsi_list_info->vsi_map);\n\n\tif (fm_list->vsi_count == 1 && lkup_type != ICE_SW_LKUP_VLAN) {\n\t\tstruct ice_fltr_info tmp_fltr_info = fm_list->fltr_info;\n\t\tstruct ice_vsi_list_map_info *vsi_list_info =\n\t\t\tfm_list->vsi_list_info;\n\t\tu16 rem_vsi_handle;\n\n\t\trem_vsi_handle = find_first_bit(vsi_list_info->vsi_map,\n\t\t\t\t\t\tICE_MAX_VSI);\n\t\tif (!ice_is_vsi_valid(hw, rem_vsi_handle))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tstatus = ice_update_vsi_list_rule(hw, &rem_vsi_handle, 1,\n\t\t\t\t\t\t  vsi_list_id, true,\n\t\t\t\t\t\t  ice_aqc_opc_update_sw_rules,\n\t\t\t\t\t\t  lkup_type);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\ttmp_fltr_info.fltr_act = ICE_FWD_TO_VSI;\n\t\ttmp_fltr_info.fwd_id.hw_vsi_id =\n\t\t\tice_get_hw_vsi_num(hw, rem_vsi_handle);\n\t\ttmp_fltr_info.vsi_handle = rem_vsi_handle;\n\t\tstatus = ice_update_pkt_fwd_rule(hw, &tmp_fltr_info);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_SW, \"Failed to update pkt fwd rule to FWD_TO_VSI on HW VSI %d, error %d\\n\",\n\t\t\t\t  tmp_fltr_info.fwd_id.hw_vsi_id, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tfm_list->fltr_info = tmp_fltr_info;\n\t}\n\n\tif ((fm_list->vsi_count == 1 && lkup_type != ICE_SW_LKUP_VLAN) ||\n\t    (fm_list->vsi_count == 0 && lkup_type == ICE_SW_LKUP_VLAN)) {\n\t\tstruct ice_vsi_list_map_info *vsi_list_info =\n\t\t\tfm_list->vsi_list_info;\n\n\t\t \n\t\tstatus = ice_remove_vsi_list_rule(hw, vsi_list_id, lkup_type);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_SW, \"Failed to remove VSI list %d, error %d\\n\",\n\t\t\t\t  vsi_list_id, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tlist_del(&vsi_list_info->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), vsi_list_info);\n\t\tfm_list->vsi_list_info = NULL;\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_remove_rule_internal(struct ice_hw *hw, u8 recp_id,\n\t\t\t struct ice_fltr_list_entry *f_entry)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_mgmt_list_entry *list_elem;\n\tstruct mutex *rule_lock;  \n\tbool remove_rule = false;\n\tu16 vsi_handle;\n\tint status = 0;\n\n\tif (!ice_is_vsi_valid(hw, f_entry->fltr_info.vsi_handle))\n\t\treturn -EINVAL;\n\tf_entry->fltr_info.fwd_id.hw_vsi_id =\n\t\tice_get_hw_vsi_num(hw, f_entry->fltr_info.vsi_handle);\n\n\trule_lock = &sw->recp_list[recp_id].filt_rule_lock;\n\tmutex_lock(rule_lock);\n\tlist_elem = ice_find_rule_entry(hw, recp_id, &f_entry->fltr_info);\n\tif (!list_elem) {\n\t\tstatus = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\tif (list_elem->fltr_info.fltr_act != ICE_FWD_TO_VSI_LIST) {\n\t\tremove_rule = true;\n\t} else if (!list_elem->vsi_list_info) {\n\t\tstatus = -ENOENT;\n\t\tgoto exit;\n\t} else if (list_elem->vsi_list_info->ref_cnt > 1) {\n\t\t \n\t\tlist_elem->vsi_list_info->ref_cnt--;\n\t\tremove_rule = true;\n\t} else {\n\t\t \n\t\tvsi_handle = f_entry->fltr_info.vsi_handle;\n\t\tstatus = ice_rem_update_vsi_list(hw, vsi_handle, list_elem);\n\t\tif (status)\n\t\t\tgoto exit;\n\t\t \n\t\tif (list_elem->vsi_count == 0)\n\t\t\tremove_rule = true;\n\t}\n\n\tif (remove_rule) {\n\t\t \n\t\tstruct ice_sw_rule_lkup_rx_tx *s_rule;\n\n\t\ts_rule = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t\t      ICE_SW_RULE_RX_TX_NO_HDR_SIZE(s_rule),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_rule) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tice_fill_sw_rule(hw, &list_elem->fltr_info, s_rule,\n\t\t\t\t ice_aqc_opc_remove_sw_rules);\n\n\t\tstatus = ice_aq_sw_rules(hw, s_rule,\n\t\t\t\t\t ICE_SW_RULE_RX_TX_NO_HDR_SIZE(s_rule),\n\t\t\t\t\t 1, ice_aqc_opc_remove_sw_rules, NULL);\n\n\t\t \n\t\tdevm_kfree(ice_hw_to_dev(hw), s_rule);\n\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\tlist_del(&list_elem->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), list_elem);\n\t}\nexit:\n\tmutex_unlock(rule_lock);\n\treturn status;\n}\n\n \nbool ice_vlan_fltr_exist(struct ice_hw *hw, u16 vlan_id, u16 vsi_handle)\n{\n\tstruct ice_fltr_mgmt_list_entry *entry;\n\tstruct list_head *rule_head;\n\tstruct ice_switch_info *sw;\n\tstruct mutex *rule_lock;  \n\tu16 hw_vsi_id;\n\n\tif (vlan_id > ICE_MAX_VLAN_ID)\n\t\treturn false;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn false;\n\n\thw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);\n\tsw = hw->switch_info;\n\trule_head = &sw->recp_list[ICE_SW_LKUP_VLAN].filt_rules;\n\tif (!rule_head)\n\t\treturn false;\n\n\trule_lock = &sw->recp_list[ICE_SW_LKUP_VLAN].filt_rule_lock;\n\tmutex_lock(rule_lock);\n\tlist_for_each_entry(entry, rule_head, list_entry) {\n\t\tstruct ice_fltr_info *f_info = &entry->fltr_info;\n\t\tu16 entry_vlan_id = f_info->l_data.vlan.vlan_id;\n\t\tstruct ice_vsi_list_map_info *map_info;\n\n\t\tif (entry_vlan_id > ICE_MAX_VLAN_ID)\n\t\t\tcontinue;\n\n\t\tif (f_info->flag != ICE_FLTR_TX ||\n\t\t    f_info->src_id != ICE_SRC_ID_VSI ||\n\t\t    f_info->lkup_type != ICE_SW_LKUP_VLAN)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (f_info->fltr_act != ICE_FWD_TO_VSI &&\n\t\t    f_info->fltr_act != ICE_FWD_TO_VSI_LIST)\n\t\t\tcontinue;\n\n\t\tif (f_info->fltr_act == ICE_FWD_TO_VSI) {\n\t\t\tif (hw_vsi_id != f_info->fwd_id.hw_vsi_id)\n\t\t\t\tcontinue;\n\t\t} else if (f_info->fltr_act == ICE_FWD_TO_VSI_LIST) {\n\t\t\t \n\t\t\tif (entry->vsi_count == 1 &&\n\t\t\t    entry->vsi_list_info) {\n\t\t\t\tmap_info = entry->vsi_list_info;\n\t\t\t\tif (!test_bit(vsi_handle, map_info->vsi_map))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (vlan_id == entry_vlan_id) {\n\t\t\tmutex_unlock(rule_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tmutex_unlock(rule_lock);\n\n\treturn false;\n}\n\n \nint ice_add_mac(struct ice_hw *hw, struct list_head *m_list)\n{\n\tstruct ice_fltr_list_entry *m_list_itr;\n\tint status = 0;\n\n\tif (!m_list || !hw)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(m_list_itr, m_list, list_entry) {\n\t\tu8 *add = &m_list_itr->fltr_info.l_data.mac.mac_addr[0];\n\t\tu16 vsi_handle;\n\t\tu16 hw_vsi_id;\n\n\t\tm_list_itr->fltr_info.flag = ICE_FLTR_TX;\n\t\tvsi_handle = m_list_itr->fltr_info.vsi_handle;\n\t\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\t\treturn -EINVAL;\n\t\thw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);\n\t\tm_list_itr->fltr_info.fwd_id.hw_vsi_id = hw_vsi_id;\n\t\t \n\t\tif (m_list_itr->fltr_info.src_id != ICE_SRC_ID_VSI)\n\t\t\treturn -EINVAL;\n\t\tm_list_itr->fltr_info.src = hw_vsi_id;\n\t\tif (m_list_itr->fltr_info.lkup_type != ICE_SW_LKUP_MAC ||\n\t\t    is_zero_ether_addr(add))\n\t\t\treturn -EINVAL;\n\n\t\tm_list_itr->status = ice_add_rule_internal(hw, ICE_SW_LKUP_MAC,\n\t\t\t\t\t\t\t   m_list_itr);\n\t\tif (m_list_itr->status)\n\t\t\treturn m_list_itr->status;\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_add_vlan_internal(struct ice_hw *hw, struct ice_fltr_list_entry *f_entry)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_mgmt_list_entry *v_list_itr;\n\tstruct ice_fltr_info *new_fltr, *cur_fltr;\n\tenum ice_sw_lkup_type lkup_type;\n\tu16 vsi_list_id = 0, vsi_handle;\n\tstruct mutex *rule_lock;  \n\tint status = 0;\n\n\tif (!ice_is_vsi_valid(hw, f_entry->fltr_info.vsi_handle))\n\t\treturn -EINVAL;\n\n\tf_entry->fltr_info.fwd_id.hw_vsi_id =\n\t\tice_get_hw_vsi_num(hw, f_entry->fltr_info.vsi_handle);\n\tnew_fltr = &f_entry->fltr_info;\n\n\t \n\tif (new_fltr->l_data.vlan.vlan_id > ICE_MAX_VLAN_ID)\n\t\treturn -EINVAL;\n\n\tif (new_fltr->src_id != ICE_SRC_ID_VSI)\n\t\treturn -EINVAL;\n\n\tnew_fltr->src = new_fltr->fwd_id.hw_vsi_id;\n\tlkup_type = new_fltr->lkup_type;\n\tvsi_handle = new_fltr->vsi_handle;\n\trule_lock = &sw->recp_list[ICE_SW_LKUP_VLAN].filt_rule_lock;\n\tmutex_lock(rule_lock);\n\tv_list_itr = ice_find_rule_entry(hw, ICE_SW_LKUP_VLAN, new_fltr);\n\tif (!v_list_itr) {\n\t\tstruct ice_vsi_list_map_info *map_info = NULL;\n\n\t\tif (new_fltr->fltr_act == ICE_FWD_TO_VSI) {\n\t\t\t \n\t\t\tmap_info = ice_find_vsi_list_entry(hw, ICE_SW_LKUP_VLAN,\n\t\t\t\t\t\t\t   vsi_handle,\n\t\t\t\t\t\t\t   &vsi_list_id);\n\t\t\tif (!map_info) {\n\t\t\t\tstatus = ice_create_vsi_list_rule(hw,\n\t\t\t\t\t\t\t\t  &vsi_handle,\n\t\t\t\t\t\t\t\t  1,\n\t\t\t\t\t\t\t\t  &vsi_list_id,\n\t\t\t\t\t\t\t\t  lkup_type);\n\t\t\t\tif (status)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\t \n\t\t\tnew_fltr->fltr_act = ICE_FWD_TO_VSI_LIST;\n\t\t\tnew_fltr->fwd_id.vsi_list_id = vsi_list_id;\n\t\t}\n\n\t\tstatus = ice_create_pkt_fwd_rule(hw, f_entry);\n\t\tif (!status) {\n\t\t\tv_list_itr = ice_find_rule_entry(hw, ICE_SW_LKUP_VLAN,\n\t\t\t\t\t\t\t new_fltr);\n\t\t\tif (!v_list_itr) {\n\t\t\t\tstatus = -ENOENT;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\t \n\t\t\tif (map_info) {\n\t\t\t\tv_list_itr->vsi_list_info = map_info;\n\t\t\t\tmap_info->ref_cnt++;\n\t\t\t} else {\n\t\t\t\tv_list_itr->vsi_list_info =\n\t\t\t\t\tice_create_vsi_list_map(hw, &vsi_handle,\n\t\t\t\t\t\t\t\t1, vsi_list_id);\n\t\t\t}\n\t\t}\n\t} else if (v_list_itr->vsi_list_info->ref_cnt == 1) {\n\t\t \n\t\tcur_fltr = &v_list_itr->fltr_info;\n\t\tstatus = ice_add_update_vsi_list(hw, v_list_itr, cur_fltr,\n\t\t\t\t\t\t new_fltr);\n\t} else {\n\t\t \n\t\tstruct ice_fltr_info tmp_fltr;\n\t\tu16 vsi_handle_arr[2];\n\t\tu16 cur_handle;\n\n\t\t \n\t\tif (v_list_itr->vsi_count > 1 &&\n\t\t    v_list_itr->vsi_list_info->ref_cnt > 1) {\n\t\t\tice_debug(hw, ICE_DBG_SW, \"Invalid configuration: Optimization to reuse VSI list with more than one VSI is not being done yet\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcur_handle =\n\t\t\tfind_first_bit(v_list_itr->vsi_list_info->vsi_map,\n\t\t\t\t       ICE_MAX_VSI);\n\n\t\t \n\t\tif (cur_handle == vsi_handle) {\n\t\t\tstatus = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tvsi_handle_arr[0] = cur_handle;\n\t\tvsi_handle_arr[1] = vsi_handle;\n\t\tstatus = ice_create_vsi_list_rule(hw, &vsi_handle_arr[0], 2,\n\t\t\t\t\t\t  &vsi_list_id, lkup_type);\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\ttmp_fltr = v_list_itr->fltr_info;\n\t\ttmp_fltr.fltr_rule_id = v_list_itr->fltr_info.fltr_rule_id;\n\t\ttmp_fltr.fwd_id.vsi_list_id = vsi_list_id;\n\t\ttmp_fltr.fltr_act = ICE_FWD_TO_VSI_LIST;\n\t\t \n\t\tstatus = ice_update_pkt_fwd_rule(hw, &tmp_fltr);\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\t \n\t\tv_list_itr->vsi_list_info->ref_cnt--;\n\n\t\t \n\t\tv_list_itr->fltr_info.fwd_id.vsi_list_id = vsi_list_id;\n\t\tv_list_itr->vsi_list_info =\n\t\t\tice_create_vsi_list_map(hw, &vsi_handle_arr[0], 2,\n\t\t\t\t\t\tvsi_list_id);\n\t\tv_list_itr->vsi_count++;\n\t}\n\nexit:\n\tmutex_unlock(rule_lock);\n\treturn status;\n}\n\n \nint ice_add_vlan(struct ice_hw *hw, struct list_head *v_list)\n{\n\tstruct ice_fltr_list_entry *v_list_itr;\n\n\tif (!v_list || !hw)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(v_list_itr, v_list, list_entry) {\n\t\tif (v_list_itr->fltr_info.lkup_type != ICE_SW_LKUP_VLAN)\n\t\t\treturn -EINVAL;\n\t\tv_list_itr->fltr_info.flag = ICE_FLTR_TX;\n\t\tv_list_itr->status = ice_add_vlan_internal(hw, v_list_itr);\n\t\tif (v_list_itr->status)\n\t\t\treturn v_list_itr->status;\n\t}\n\treturn 0;\n}\n\n \nint ice_add_eth_mac(struct ice_hw *hw, struct list_head *em_list)\n{\n\tstruct ice_fltr_list_entry *em_list_itr;\n\n\tif (!em_list || !hw)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(em_list_itr, em_list, list_entry) {\n\t\tenum ice_sw_lkup_type l_type =\n\t\t\tem_list_itr->fltr_info.lkup_type;\n\n\t\tif (l_type != ICE_SW_LKUP_ETHERTYPE_MAC &&\n\t\t    l_type != ICE_SW_LKUP_ETHERTYPE)\n\t\t\treturn -EINVAL;\n\n\t\tem_list_itr->status = ice_add_rule_internal(hw, l_type,\n\t\t\t\t\t\t\t    em_list_itr);\n\t\tif (em_list_itr->status)\n\t\t\treturn em_list_itr->status;\n\t}\n\treturn 0;\n}\n\n \nint ice_remove_eth_mac(struct ice_hw *hw, struct list_head *em_list)\n{\n\tstruct ice_fltr_list_entry *em_list_itr, *tmp;\n\n\tif (!em_list || !hw)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry_safe(em_list_itr, tmp, em_list, list_entry) {\n\t\tenum ice_sw_lkup_type l_type =\n\t\t\tem_list_itr->fltr_info.lkup_type;\n\n\t\tif (l_type != ICE_SW_LKUP_ETHERTYPE_MAC &&\n\t\t    l_type != ICE_SW_LKUP_ETHERTYPE)\n\t\t\treturn -EINVAL;\n\n\t\tem_list_itr->status = ice_remove_rule_internal(hw, l_type,\n\t\t\t\t\t\t\t       em_list_itr);\n\t\tif (em_list_itr->status)\n\t\t\treturn em_list_itr->status;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nice_rem_sw_rule_info(struct ice_hw *hw, struct list_head *rule_head)\n{\n\tif (!list_empty(rule_head)) {\n\t\tstruct ice_fltr_mgmt_list_entry *entry;\n\t\tstruct ice_fltr_mgmt_list_entry *tmp;\n\n\t\tlist_for_each_entry_safe(entry, tmp, rule_head, list_entry) {\n\t\t\tlist_del(&entry->list_entry);\n\t\t\tdevm_kfree(ice_hw_to_dev(hw), entry);\n\t\t}\n\t}\n}\n\n \nstatic void\nice_rem_adv_rule_info(struct ice_hw *hw, struct list_head *rule_head)\n{\n\tstruct ice_adv_fltr_mgmt_list_entry *tmp_entry;\n\tstruct ice_adv_fltr_mgmt_list_entry *lst_itr;\n\n\tif (list_empty(rule_head))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lst_itr, tmp_entry, rule_head, list_entry) {\n\t\tlist_del(&lst_itr->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), lst_itr->lkups);\n\t\tdevm_kfree(ice_hw_to_dev(hw), lst_itr);\n\t}\n}\n\n \nint\nice_cfg_dflt_vsi(struct ice_port_info *pi, u16 vsi_handle, bool set,\n\t\t u8 direction)\n{\n\tstruct ice_fltr_list_entry f_list_entry;\n\tstruct ice_fltr_info f_info;\n\tstruct ice_hw *hw = pi->hw;\n\tu16 hw_vsi_id;\n\tint status;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\thw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);\n\n\tmemset(&f_info, 0, sizeof(f_info));\n\n\tf_info.lkup_type = ICE_SW_LKUP_DFLT;\n\tf_info.flag = direction;\n\tf_info.fltr_act = ICE_FWD_TO_VSI;\n\tf_info.fwd_id.hw_vsi_id = hw_vsi_id;\n\tf_info.vsi_handle = vsi_handle;\n\n\tif (f_info.flag & ICE_FLTR_RX) {\n\t\tf_info.src = hw->port_info->lport;\n\t\tf_info.src_id = ICE_SRC_ID_LPORT;\n\t} else if (f_info.flag & ICE_FLTR_TX) {\n\t\tf_info.src_id = ICE_SRC_ID_VSI;\n\t\tf_info.src = hw_vsi_id;\n\t}\n\tf_list_entry.fltr_info = f_info;\n\n\tif (set)\n\t\tstatus = ice_add_rule_internal(hw, ICE_SW_LKUP_DFLT,\n\t\t\t\t\t       &f_list_entry);\n\telse\n\t\tstatus = ice_remove_rule_internal(hw, ICE_SW_LKUP_DFLT,\n\t\t\t\t\t\t  &f_list_entry);\n\n\treturn status;\n}\n\n \nstatic bool\nice_vsi_uses_fltr(struct ice_fltr_mgmt_list_entry *fm_entry, u16 vsi_handle)\n{\n\treturn ((fm_entry->fltr_info.fltr_act == ICE_FWD_TO_VSI &&\n\t\t fm_entry->fltr_info.vsi_handle == vsi_handle) ||\n\t\t(fm_entry->fltr_info.fltr_act == ICE_FWD_TO_VSI_LIST &&\n\t\t fm_entry->vsi_list_info &&\n\t\t (test_bit(vsi_handle, fm_entry->vsi_list_info->vsi_map))));\n}\n\n \nbool\nice_check_if_dflt_vsi(struct ice_port_info *pi, u16 vsi_handle,\n\t\t      bool *rule_exists)\n{\n\tstruct ice_fltr_mgmt_list_entry *fm_entry;\n\tstruct ice_sw_recipe *recp_list;\n\tstruct list_head *rule_head;\n\tstruct mutex *rule_lock;  \n\tbool ret = false;\n\n\trecp_list = &pi->hw->switch_info->recp_list[ICE_SW_LKUP_DFLT];\n\trule_lock = &recp_list->filt_rule_lock;\n\trule_head = &recp_list->filt_rules;\n\n\tmutex_lock(rule_lock);\n\n\tif (rule_exists && !list_empty(rule_head))\n\t\t*rule_exists = true;\n\n\tlist_for_each_entry(fm_entry, rule_head, list_entry) {\n\t\tif (ice_vsi_uses_fltr(fm_entry, vsi_handle)) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(rule_lock);\n\n\treturn ret;\n}\n\n \nint ice_remove_mac(struct ice_hw *hw, struct list_head *m_list)\n{\n\tstruct ice_fltr_list_entry *list_itr, *tmp;\n\n\tif (!m_list)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry_safe(list_itr, tmp, m_list, list_entry) {\n\t\tenum ice_sw_lkup_type l_type = list_itr->fltr_info.lkup_type;\n\t\tu16 vsi_handle;\n\n\t\tif (l_type != ICE_SW_LKUP_MAC)\n\t\t\treturn -EINVAL;\n\n\t\tvsi_handle = list_itr->fltr_info.vsi_handle;\n\t\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\t\treturn -EINVAL;\n\n\t\tlist_itr->fltr_info.fwd_id.hw_vsi_id =\n\t\t\t\t\tice_get_hw_vsi_num(hw, vsi_handle);\n\n\t\tlist_itr->status = ice_remove_rule_internal(hw,\n\t\t\t\t\t\t\t    ICE_SW_LKUP_MAC,\n\t\t\t\t\t\t\t    list_itr);\n\t\tif (list_itr->status)\n\t\t\treturn list_itr->status;\n\t}\n\treturn 0;\n}\n\n \nint ice_remove_vlan(struct ice_hw *hw, struct list_head *v_list)\n{\n\tstruct ice_fltr_list_entry *v_list_itr, *tmp;\n\n\tif (!v_list || !hw)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry_safe(v_list_itr, tmp, v_list, list_entry) {\n\t\tenum ice_sw_lkup_type l_type = v_list_itr->fltr_info.lkup_type;\n\n\t\tif (l_type != ICE_SW_LKUP_VLAN)\n\t\t\treturn -EINVAL;\n\t\tv_list_itr->status = ice_remove_rule_internal(hw,\n\t\t\t\t\t\t\t      ICE_SW_LKUP_VLAN,\n\t\t\t\t\t\t\t      v_list_itr);\n\t\tif (v_list_itr->status)\n\t\t\treturn v_list_itr->status;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nice_add_entry_to_vsi_fltr_list(struct ice_hw *hw, u16 vsi_handle,\n\t\t\t       struct list_head *vsi_list_head,\n\t\t\t       struct ice_fltr_info *fi)\n{\n\tstruct ice_fltr_list_entry *tmp;\n\n\t \n\ttmp = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\ttmp->fltr_info = *fi;\n\n\t \n\ttmp->fltr_info.fltr_act = ICE_FWD_TO_VSI;\n\ttmp->fltr_info.vsi_handle = vsi_handle;\n\ttmp->fltr_info.fwd_id.hw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);\n\n\tlist_add(&tmp->list_entry, vsi_list_head);\n\n\treturn 0;\n}\n\n \nstatic int\nice_add_to_vsi_fltr_list(struct ice_hw *hw, u16 vsi_handle,\n\t\t\t struct list_head *lkup_list_head,\n\t\t\t struct list_head *vsi_list_head)\n{\n\tstruct ice_fltr_mgmt_list_entry *fm_entry;\n\tint status = 0;\n\n\t \n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(fm_entry, lkup_list_head, list_entry) {\n\t\tif (!ice_vsi_uses_fltr(fm_entry, vsi_handle))\n\t\t\tcontinue;\n\n\t\tstatus = ice_add_entry_to_vsi_fltr_list(hw, vsi_handle,\n\t\t\t\t\t\t\tvsi_list_head,\n\t\t\t\t\t\t\t&fm_entry->fltr_info);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn status;\n}\n\n \nstatic u8 ice_determine_promisc_mask(struct ice_fltr_info *fi)\n{\n\tu16 vid = fi->l_data.mac_vlan.vlan_id;\n\tu8 *macaddr = fi->l_data.mac.mac_addr;\n\tbool is_tx_fltr = false;\n\tu8 promisc_mask = 0;\n\n\tif (fi->flag == ICE_FLTR_TX)\n\t\tis_tx_fltr = true;\n\n\tif (is_broadcast_ether_addr(macaddr))\n\t\tpromisc_mask |= is_tx_fltr ?\n\t\t\tICE_PROMISC_BCAST_TX : ICE_PROMISC_BCAST_RX;\n\telse if (is_multicast_ether_addr(macaddr))\n\t\tpromisc_mask |= is_tx_fltr ?\n\t\t\tICE_PROMISC_MCAST_TX : ICE_PROMISC_MCAST_RX;\n\telse if (is_unicast_ether_addr(macaddr))\n\t\tpromisc_mask |= is_tx_fltr ?\n\t\t\tICE_PROMISC_UCAST_TX : ICE_PROMISC_UCAST_RX;\n\tif (vid)\n\t\tpromisc_mask |= is_tx_fltr ?\n\t\t\tICE_PROMISC_VLAN_TX : ICE_PROMISC_VLAN_RX;\n\n\treturn promisc_mask;\n}\n\n \nstatic int\nice_remove_promisc(struct ice_hw *hw, u8 recp_id, struct list_head *v_list)\n{\n\tstruct ice_fltr_list_entry *v_list_itr, *tmp;\n\n\tlist_for_each_entry_safe(v_list_itr, tmp, v_list, list_entry) {\n\t\tv_list_itr->status =\n\t\t\tice_remove_rule_internal(hw, recp_id, v_list_itr);\n\t\tif (v_list_itr->status)\n\t\t\treturn v_list_itr->status;\n\t}\n\treturn 0;\n}\n\n \nint\nice_clear_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,\n\t\t      u16 vid)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_list_entry *fm_entry, *tmp;\n\tstruct list_head remove_list_head;\n\tstruct ice_fltr_mgmt_list_entry *itr;\n\tstruct list_head *rule_head;\n\tstruct mutex *rule_lock;\t \n\tint status = 0;\n\tu8 recipe_id;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\n\tif (promisc_mask & (ICE_PROMISC_VLAN_RX | ICE_PROMISC_VLAN_TX))\n\t\trecipe_id = ICE_SW_LKUP_PROMISC_VLAN;\n\telse\n\t\trecipe_id = ICE_SW_LKUP_PROMISC;\n\n\trule_head = &sw->recp_list[recipe_id].filt_rules;\n\trule_lock = &sw->recp_list[recipe_id].filt_rule_lock;\n\n\tINIT_LIST_HEAD(&remove_list_head);\n\n\tmutex_lock(rule_lock);\n\tlist_for_each_entry(itr, rule_head, list_entry) {\n\t\tstruct ice_fltr_info *fltr_info;\n\t\tu8 fltr_promisc_mask = 0;\n\n\t\tif (!ice_vsi_uses_fltr(itr, vsi_handle))\n\t\t\tcontinue;\n\t\tfltr_info = &itr->fltr_info;\n\n\t\tif (recipe_id == ICE_SW_LKUP_PROMISC_VLAN &&\n\t\t    vid != fltr_info->l_data.mac_vlan.vlan_id)\n\t\t\tcontinue;\n\n\t\tfltr_promisc_mask |= ice_determine_promisc_mask(fltr_info);\n\n\t\t \n\t\tif (fltr_promisc_mask & ~promisc_mask)\n\t\t\tcontinue;\n\n\t\tstatus = ice_add_entry_to_vsi_fltr_list(hw, vsi_handle,\n\t\t\t\t\t\t\t&remove_list_head,\n\t\t\t\t\t\t\tfltr_info);\n\t\tif (status) {\n\t\t\tmutex_unlock(rule_lock);\n\t\t\tgoto free_fltr_list;\n\t\t}\n\t}\n\tmutex_unlock(rule_lock);\n\n\tstatus = ice_remove_promisc(hw, recipe_id, &remove_list_head);\n\nfree_fltr_list:\n\tlist_for_each_entry_safe(fm_entry, tmp, &remove_list_head, list_entry) {\n\t\tlist_del(&fm_entry->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), fm_entry);\n\t}\n\n\treturn status;\n}\n\n \nint\nice_set_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask, u16 vid)\n{\n\tenum { UCAST_FLTR = 1, MCAST_FLTR, BCAST_FLTR };\n\tstruct ice_fltr_list_entry f_list_entry;\n\tstruct ice_fltr_info new_fltr;\n\tbool is_tx_fltr;\n\tint status = 0;\n\tu16 hw_vsi_id;\n\tint pkt_type;\n\tu8 recipe_id;\n\n\tif (!ice_is_vsi_valid(hw, vsi_handle))\n\t\treturn -EINVAL;\n\thw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);\n\n\tmemset(&new_fltr, 0, sizeof(new_fltr));\n\n\tif (promisc_mask & (ICE_PROMISC_VLAN_RX | ICE_PROMISC_VLAN_TX)) {\n\t\tnew_fltr.lkup_type = ICE_SW_LKUP_PROMISC_VLAN;\n\t\tnew_fltr.l_data.mac_vlan.vlan_id = vid;\n\t\trecipe_id = ICE_SW_LKUP_PROMISC_VLAN;\n\t} else {\n\t\tnew_fltr.lkup_type = ICE_SW_LKUP_PROMISC;\n\t\trecipe_id = ICE_SW_LKUP_PROMISC;\n\t}\n\n\t \n\twhile (promisc_mask) {\n\t\tu8 *mac_addr;\n\n\t\tpkt_type = 0;\n\t\tis_tx_fltr = false;\n\n\t\tif (promisc_mask & ICE_PROMISC_UCAST_RX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_UCAST_RX;\n\t\t\tpkt_type = UCAST_FLTR;\n\t\t} else if (promisc_mask & ICE_PROMISC_UCAST_TX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_UCAST_TX;\n\t\t\tpkt_type = UCAST_FLTR;\n\t\t\tis_tx_fltr = true;\n\t\t} else if (promisc_mask & ICE_PROMISC_MCAST_RX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_MCAST_RX;\n\t\t\tpkt_type = MCAST_FLTR;\n\t\t} else if (promisc_mask & ICE_PROMISC_MCAST_TX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_MCAST_TX;\n\t\t\tpkt_type = MCAST_FLTR;\n\t\t\tis_tx_fltr = true;\n\t\t} else if (promisc_mask & ICE_PROMISC_BCAST_RX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_BCAST_RX;\n\t\t\tpkt_type = BCAST_FLTR;\n\t\t} else if (promisc_mask & ICE_PROMISC_BCAST_TX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_BCAST_TX;\n\t\t\tpkt_type = BCAST_FLTR;\n\t\t\tis_tx_fltr = true;\n\t\t}\n\n\t\t \n\t\tif (promisc_mask & ICE_PROMISC_VLAN_RX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_VLAN_RX;\n\t\t} else if (promisc_mask & ICE_PROMISC_VLAN_TX) {\n\t\t\tpromisc_mask &= ~ICE_PROMISC_VLAN_TX;\n\t\t\tis_tx_fltr = true;\n\t\t}\n\n\t\t \n\t\tmac_addr = new_fltr.l_data.mac.mac_addr;\n\t\tif (pkt_type == BCAST_FLTR) {\n\t\t\teth_broadcast_addr(mac_addr);\n\t\t} else if (pkt_type == MCAST_FLTR ||\n\t\t\t   pkt_type == UCAST_FLTR) {\n\t\t\t \n\t\t\tether_addr_copy(mac_addr, dummy_eth_header);\n\t\t\tif (pkt_type == MCAST_FLTR)\n\t\t\t\tmac_addr[0] |= 0x1;\t \n\t\t}\n\n\t\t \n\t\tnew_fltr.flag = 0;\n\t\tif (is_tx_fltr) {\n\t\t\tnew_fltr.flag |= ICE_FLTR_TX;\n\t\t\tnew_fltr.src = hw_vsi_id;\n\t\t} else {\n\t\t\tnew_fltr.flag |= ICE_FLTR_RX;\n\t\t\tnew_fltr.src = hw->port_info->lport;\n\t\t}\n\n\t\tnew_fltr.fltr_act = ICE_FWD_TO_VSI;\n\t\tnew_fltr.vsi_handle = vsi_handle;\n\t\tnew_fltr.fwd_id.hw_vsi_id = hw_vsi_id;\n\t\tf_list_entry.fltr_info = new_fltr;\n\n\t\tstatus = ice_add_rule_internal(hw, recipe_id, &f_list_entry);\n\t\tif (status)\n\t\t\tgoto set_promisc_exit;\n\t}\n\nset_promisc_exit:\n\treturn status;\n}\n\n \nint\nice_set_vlan_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,\n\t\t\t bool rm_vlan_promisc)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_list_entry *list_itr, *tmp;\n\tstruct list_head vsi_list_head;\n\tstruct list_head *vlan_head;\n\tstruct mutex *vlan_lock;  \n\tu16 vlan_id;\n\tint status;\n\n\tINIT_LIST_HEAD(&vsi_list_head);\n\tvlan_lock = &sw->recp_list[ICE_SW_LKUP_VLAN].filt_rule_lock;\n\tvlan_head = &sw->recp_list[ICE_SW_LKUP_VLAN].filt_rules;\n\tmutex_lock(vlan_lock);\n\tstatus = ice_add_to_vsi_fltr_list(hw, vsi_handle, vlan_head,\n\t\t\t\t\t  &vsi_list_head);\n\tmutex_unlock(vlan_lock);\n\tif (status)\n\t\tgoto free_fltr_list;\n\n\tlist_for_each_entry(list_itr, &vsi_list_head, list_entry) {\n\t\t \n\t\tif (ice_is_dvm_ena(hw) &&\n\t\t    list_itr->fltr_info.l_data.vlan.tpid == 0)\n\t\t\tcontinue;\n\n\t\tvlan_id = list_itr->fltr_info.l_data.vlan.vlan_id;\n\t\tif (rm_vlan_promisc)\n\t\t\tstatus = ice_clear_vsi_promisc(hw, vsi_handle,\n\t\t\t\t\t\t       promisc_mask, vlan_id);\n\t\telse\n\t\t\tstatus = ice_set_vsi_promisc(hw, vsi_handle,\n\t\t\t\t\t\t     promisc_mask, vlan_id);\n\t\tif (status && status != -EEXIST)\n\t\t\tbreak;\n\t}\n\nfree_fltr_list:\n\tlist_for_each_entry_safe(list_itr, tmp, &vsi_list_head, list_entry) {\n\t\tlist_del(&list_itr->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), list_itr);\n\t}\n\treturn status;\n}\n\n \nstatic void\nice_remove_vsi_lkup_fltr(struct ice_hw *hw, u16 vsi_handle,\n\t\t\t enum ice_sw_lkup_type lkup)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tstruct ice_fltr_list_entry *fm_entry;\n\tstruct list_head remove_list_head;\n\tstruct list_head *rule_head;\n\tstruct ice_fltr_list_entry *tmp;\n\tstruct mutex *rule_lock;\t \n\tint status;\n\n\tINIT_LIST_HEAD(&remove_list_head);\n\trule_lock = &sw->recp_list[lkup].filt_rule_lock;\n\trule_head = &sw->recp_list[lkup].filt_rules;\n\tmutex_lock(rule_lock);\n\tstatus = ice_add_to_vsi_fltr_list(hw, vsi_handle, rule_head,\n\t\t\t\t\t  &remove_list_head);\n\tmutex_unlock(rule_lock);\n\tif (status)\n\t\tgoto free_fltr_list;\n\n\tswitch (lkup) {\n\tcase ICE_SW_LKUP_MAC:\n\t\tice_remove_mac(hw, &remove_list_head);\n\t\tbreak;\n\tcase ICE_SW_LKUP_VLAN:\n\t\tice_remove_vlan(hw, &remove_list_head);\n\t\tbreak;\n\tcase ICE_SW_LKUP_PROMISC:\n\tcase ICE_SW_LKUP_PROMISC_VLAN:\n\t\tice_remove_promisc(hw, lkup, &remove_list_head);\n\t\tbreak;\n\tcase ICE_SW_LKUP_MAC_VLAN:\n\tcase ICE_SW_LKUP_ETHERTYPE:\n\tcase ICE_SW_LKUP_ETHERTYPE_MAC:\n\tcase ICE_SW_LKUP_DFLT:\n\tcase ICE_SW_LKUP_LAST:\n\tdefault:\n\t\tice_debug(hw, ICE_DBG_SW, \"Unsupported lookup type %d\\n\", lkup);\n\t\tbreak;\n\t}\n\nfree_fltr_list:\n\tlist_for_each_entry_safe(fm_entry, tmp, &remove_list_head, list_entry) {\n\t\tlist_del(&fm_entry->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), fm_entry);\n\t}\n}\n\n \nvoid ice_remove_vsi_fltr(struct ice_hw *hw, u16 vsi_handle)\n{\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_MAC);\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_MAC_VLAN);\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_PROMISC);\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_VLAN);\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_DFLT);\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_ETHERTYPE);\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_ETHERTYPE_MAC);\n\tice_remove_vsi_lkup_fltr(hw, vsi_handle, ICE_SW_LKUP_PROMISC_VLAN);\n}\n\n \nint\nice_alloc_res_cntr(struct ice_hw *hw, u8 type, u8 alloc_shared, u16 num_items,\n\t\t   u16 *counter_id)\n{\n\tstruct ice_aqc_alloc_free_res_elem *buf;\n\tu16 buf_len;\n\tint status;\n\n\t \n\tbuf_len = struct_size(buf, elem, 1);\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->num_elems = cpu_to_le16(num_items);\n\tbuf->res_type = cpu_to_le16(((type << ICE_AQC_RES_TYPE_S) &\n\t\t\t\t      ICE_AQC_RES_TYPE_M) | alloc_shared);\n\n\tstatus = ice_aq_alloc_free_res(hw, buf, buf_len, ice_aqc_opc_alloc_res);\n\tif (status)\n\t\tgoto exit;\n\n\t*counter_id = le16_to_cpu(buf->elem[0].e.sw_resp);\n\nexit:\n\tkfree(buf);\n\treturn status;\n}\n\n \nint\nice_free_res_cntr(struct ice_hw *hw, u8 type, u8 alloc_shared, u16 num_items,\n\t\t  u16 counter_id)\n{\n\tstruct ice_aqc_alloc_free_res_elem *buf;\n\tu16 buf_len;\n\tint status;\n\n\t \n\tbuf_len = struct_size(buf, elem, 1);\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->num_elems = cpu_to_le16(num_items);\n\tbuf->res_type = cpu_to_le16(((type << ICE_AQC_RES_TYPE_S) &\n\t\t\t\t      ICE_AQC_RES_TYPE_M) | alloc_shared);\n\tbuf->elem[0].e.sw_resp = cpu_to_le16(counter_id);\n\n\tstatus = ice_aq_alloc_free_res(hw, buf, buf_len, ice_aqc_opc_free_res);\n\tif (status)\n\t\tice_debug(hw, ICE_DBG_SW, \"counter resource could not be freed\\n\");\n\n\tkfree(buf);\n\treturn status;\n}\n\n#define ICE_PROTOCOL_ENTRY(id, ...) {\t\t\\\n\t.prot_type\t= id,\t\t\t\\\n\t.offs\t\t= {__VA_ARGS__},\t\\\n}\n\n \nint ice_share_res(struct ice_hw *hw, u16 type, u8 shared, u16 res_id)\n{\n\tstruct ice_aqc_alloc_free_res_elem *buf;\n\tu16 buf_len;\n\tint status;\n\n\tbuf_len = struct_size(buf, elem, 1);\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->num_elems = cpu_to_le16(1);\n\tif (shared)\n\t\tbuf->res_type = cpu_to_le16(((type << ICE_AQC_RES_TYPE_S) &\n\t\t\t\t\t     ICE_AQC_RES_TYPE_M) |\n\t\t\t\t\t    ICE_AQC_RES_TYPE_FLAG_SHARED);\n\telse\n\t\tbuf->res_type = cpu_to_le16(((type << ICE_AQC_RES_TYPE_S) &\n\t\t\t\t\t     ICE_AQC_RES_TYPE_M) &\n\t\t\t\t\t    ~ICE_AQC_RES_TYPE_FLAG_SHARED);\n\n\tbuf->elem[0].e.sw_resp = cpu_to_le16(res_id);\n\tstatus = ice_aq_alloc_free_res(hw, buf, buf_len,\n\t\t\t\t       ice_aqc_opc_share_res);\n\tif (status)\n\t\tice_debug(hw, ICE_DBG_SW, \"Could not set resource type %u id %u to %s\\n\",\n\t\t\t  type, res_id, shared ? \"SHARED\" : \"DEDICATED\");\n\n\tkfree(buf);\n\treturn status;\n}\n\n \nstatic const struct ice_prot_ext_tbl_entry ice_prot_ext[ICE_PROTOCOL_LAST] = {\n\tICE_PROTOCOL_ENTRY(ICE_MAC_OFOS, 0, 2, 4, 6, 8, 10, 12),\n\tICE_PROTOCOL_ENTRY(ICE_MAC_IL, 0, 2, 4, 6, 8, 10, 12),\n\tICE_PROTOCOL_ENTRY(ICE_ETYPE_OL, 0),\n\tICE_PROTOCOL_ENTRY(ICE_ETYPE_IL, 0),\n\tICE_PROTOCOL_ENTRY(ICE_VLAN_OFOS, 2, 0),\n\tICE_PROTOCOL_ENTRY(ICE_IPV4_OFOS, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18),\n\tICE_PROTOCOL_ENTRY(ICE_IPV4_IL,\t0, 2, 4, 6, 8, 10, 12, 14, 16, 18),\n\tICE_PROTOCOL_ENTRY(ICE_IPV6_OFOS, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,\n\t\t\t   20, 22, 24, 26, 28, 30, 32, 34, 36, 38),\n\tICE_PROTOCOL_ENTRY(ICE_IPV6_IL, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n\t\t\t   22, 24, 26, 28, 30, 32, 34, 36, 38),\n\tICE_PROTOCOL_ENTRY(ICE_TCP_IL, 0, 2),\n\tICE_PROTOCOL_ENTRY(ICE_UDP_OF, 0, 2),\n\tICE_PROTOCOL_ENTRY(ICE_UDP_ILOS, 0, 2),\n\tICE_PROTOCOL_ENTRY(ICE_VXLAN, 8, 10, 12, 14),\n\tICE_PROTOCOL_ENTRY(ICE_GENEVE, 8, 10, 12, 14),\n\tICE_PROTOCOL_ENTRY(ICE_NVGRE, 0, 2, 4, 6),\n\tICE_PROTOCOL_ENTRY(ICE_GTP, 8, 10, 12, 14, 16, 18, 20, 22),\n\tICE_PROTOCOL_ENTRY(ICE_GTP_NO_PAY, 8, 10, 12, 14),\n\tICE_PROTOCOL_ENTRY(ICE_PPPOE, 0, 2, 4, 6),\n\tICE_PROTOCOL_ENTRY(ICE_L2TPV3, 0, 2, 4, 6, 8, 10),\n\tICE_PROTOCOL_ENTRY(ICE_VLAN_EX, 2, 0),\n\tICE_PROTOCOL_ENTRY(ICE_VLAN_IN, 2, 0),\n\tICE_PROTOCOL_ENTRY(ICE_HW_METADATA,\n\t\t\t   ICE_SOURCE_PORT_MDID_OFFSET,\n\t\t\t   ICE_PTYPE_MDID_OFFSET,\n\t\t\t   ICE_PACKET_LENGTH_MDID_OFFSET,\n\t\t\t   ICE_SOURCE_VSI_MDID_OFFSET,\n\t\t\t   ICE_PKT_VLAN_MDID_OFFSET,\n\t\t\t   ICE_PKT_TUNNEL_MDID_OFFSET,\n\t\t\t   ICE_PKT_TCP_MDID_OFFSET,\n\t\t\t   ICE_PKT_ERROR_MDID_OFFSET),\n};\n\nstatic struct ice_protocol_entry ice_prot_id_tbl[ICE_PROTOCOL_LAST] = {\n\t{ ICE_MAC_OFOS,\t\tICE_MAC_OFOS_HW },\n\t{ ICE_MAC_IL,\t\tICE_MAC_IL_HW },\n\t{ ICE_ETYPE_OL,\t\tICE_ETYPE_OL_HW },\n\t{ ICE_ETYPE_IL,\t\tICE_ETYPE_IL_HW },\n\t{ ICE_VLAN_OFOS,\tICE_VLAN_OL_HW },\n\t{ ICE_IPV4_OFOS,\tICE_IPV4_OFOS_HW },\n\t{ ICE_IPV4_IL,\t\tICE_IPV4_IL_HW },\n\t{ ICE_IPV6_OFOS,\tICE_IPV6_OFOS_HW },\n\t{ ICE_IPV6_IL,\t\tICE_IPV6_IL_HW },\n\t{ ICE_TCP_IL,\t\tICE_TCP_IL_HW },\n\t{ ICE_UDP_OF,\t\tICE_UDP_OF_HW },\n\t{ ICE_UDP_ILOS,\t\tICE_UDP_ILOS_HW },\n\t{ ICE_VXLAN,\t\tICE_UDP_OF_HW },\n\t{ ICE_GENEVE,\t\tICE_UDP_OF_HW },\n\t{ ICE_NVGRE,\t\tICE_GRE_OF_HW },\n\t{ ICE_GTP,\t\tICE_UDP_OF_HW },\n\t{ ICE_GTP_NO_PAY,\tICE_UDP_ILOS_HW },\n\t{ ICE_PPPOE,\t\tICE_PPPOE_HW },\n\t{ ICE_L2TPV3,\t\tICE_L2TPV3_HW },\n\t{ ICE_VLAN_EX,          ICE_VLAN_OF_HW },\n\t{ ICE_VLAN_IN,          ICE_VLAN_OL_HW },\n\t{ ICE_HW_METADATA,      ICE_META_DATA_ID_HW },\n};\n\n \nstatic u16\nice_find_recp(struct ice_hw *hw, struct ice_prot_lkup_ext *lkup_exts,\n\t      const struct ice_adv_rule_info *rinfo)\n{\n\tbool refresh_required = true;\n\tstruct ice_sw_recipe *recp;\n\tu8 i;\n\n\t \n\trecp = hw->switch_info->recp_list;\n\tfor (i = 0; i < ICE_MAX_NUM_RECIPES; i++) {\n\t\t \n\t\tif (!recp[i].recp_created)\n\t\t\tif (ice_get_recp_frm_fw(hw,\n\t\t\t\t\t\thw->switch_info->recp_list, i,\n\t\t\t\t\t\t&refresh_required))\n\t\t\t\tcontinue;\n\n\t\t \n\t\tif (recp[i].root_buf && recp[i].root_buf->content.act_ctrl &\n\t\t    ICE_AQ_RECIPE_ACT_INV_ACT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (lkup_exts->n_val_words == recp[i].lkup_exts.n_val_words) {\n\t\t\tstruct ice_fv_word *ar = recp[i].lkup_exts.fv_words;\n\t\t\tstruct ice_fv_word *be = lkup_exts->fv_words;\n\t\t\tu16 *cr = recp[i].lkup_exts.field_mask;\n\t\t\tu16 *de = lkup_exts->field_mask;\n\t\t\tbool found = true;\n\t\t\tu8 pe, qr;\n\n\t\t\t \n\t\t\tfor (pe = 0; pe < lkup_exts->n_val_words; pe++) {\n\t\t\t\tfor (qr = 0; qr < recp[i].lkup_exts.n_val_words;\n\t\t\t\t     qr++) {\n\t\t\t\t\tif (ar[qr].off == be[pe].off &&\n\t\t\t\t\t    ar[qr].prot_id == be[pe].prot_id &&\n\t\t\t\t\t    cr[qr] == de[pe])\n\t\t\t\t\t\t \n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (qr >= recp[i].lkup_exts.n_val_words) {\n\t\t\t\t\tfound = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (found && recp[i].tun_type == rinfo->tun_type &&\n\t\t\t    recp[i].need_pass_l2 == rinfo->need_pass_l2 &&\n\t\t\t    recp[i].allow_pass_l2 == rinfo->allow_pass_l2)\n\t\t\t\treturn i;  \n\t\t}\n\t}\n\treturn ICE_MAX_NUM_RECIPES;\n}\n\n \nvoid ice_change_proto_id_to_dvm(void)\n{\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ice_prot_id_tbl); i++)\n\t\tif (ice_prot_id_tbl[i].type == ICE_VLAN_OFOS &&\n\t\t    ice_prot_id_tbl[i].protocol_id != ICE_VLAN_OF_HW)\n\t\t\tice_prot_id_tbl[i].protocol_id = ICE_VLAN_OF_HW;\n}\n\n \nstatic bool ice_prot_type_to_id(enum ice_protocol_type type, u8 *id)\n{\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ice_prot_id_tbl); i++)\n\t\tif (ice_prot_id_tbl[i].type == type) {\n\t\t\t*id = ice_prot_id_tbl[i].protocol_id;\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\n\n \nstatic u8\nice_fill_valid_words(struct ice_adv_lkup_elem *rule,\n\t\t     struct ice_prot_lkup_ext *lkup_exts)\n{\n\tu8 j, word, prot_id, ret_val;\n\n\tif (!ice_prot_type_to_id(rule->type, &prot_id))\n\t\treturn 0;\n\n\tword = lkup_exts->n_val_words;\n\n\tfor (j = 0; j < sizeof(rule->m_u) / sizeof(u16); j++)\n\t\tif (((u16 *)&rule->m_u)[j] &&\n\t\t    rule->type < ARRAY_SIZE(ice_prot_ext)) {\n\t\t\t \n\t\t\tif (word >= ICE_MAX_CHAIN_WORDS)\n\t\t\t\treturn 0;\n\t\t\tlkup_exts->fv_words[word].off =\n\t\t\t\tice_prot_ext[rule->type].offs[j];\n\t\t\tlkup_exts->fv_words[word].prot_id =\n\t\t\t\tice_prot_id_tbl[rule->type].protocol_id;\n\t\t\tlkup_exts->field_mask[word] =\n\t\t\t\tbe16_to_cpu(((__force __be16 *)&rule->m_u)[j]);\n\t\t\tword++;\n\t\t}\n\n\tret_val = word - lkup_exts->n_val_words;\n\tlkup_exts->n_val_words = word;\n\n\treturn ret_val;\n}\n\n \nstatic int\nice_create_first_fit_recp_def(struct ice_hw *hw,\n\t\t\t      struct ice_prot_lkup_ext *lkup_exts,\n\t\t\t      struct list_head *rg_list,\n\t\t\t      u8 *recp_cnt)\n{\n\tstruct ice_pref_recipe_group *grp = NULL;\n\tu8 j;\n\n\t*recp_cnt = 0;\n\n\t \n\tfor (j = 0; j < lkup_exts->n_val_words; j++)\n\t\tif (!test_bit(j, lkup_exts->done)) {\n\t\t\tif (!grp ||\n\t\t\t    grp->n_val_pairs == ICE_NUM_WORDS_RECIPE) {\n\t\t\t\tstruct ice_recp_grp_entry *entry;\n\n\t\t\t\tentry = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t\t\t\t     sizeof(*entry),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\t\tif (!entry)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tlist_add(&entry->l_entry, rg_list);\n\t\t\t\tgrp = &entry->r_group;\n\t\t\t\t(*recp_cnt)++;\n\t\t\t}\n\n\t\t\tgrp->pairs[grp->n_val_pairs].prot_id =\n\t\t\t\tlkup_exts->fv_words[j].prot_id;\n\t\t\tgrp->pairs[grp->n_val_pairs].off =\n\t\t\t\tlkup_exts->fv_words[j].off;\n\t\t\tgrp->mask[grp->n_val_pairs] = lkup_exts->field_mask[j];\n\t\t\tgrp->n_val_pairs++;\n\t\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_fill_fv_word_index(struct ice_hw *hw, struct list_head *fv_list,\n\t\t       struct list_head *rg_list)\n{\n\tstruct ice_sw_fv_list_entry *fv;\n\tstruct ice_recp_grp_entry *rg;\n\tstruct ice_fv_word *fv_ext;\n\n\tif (list_empty(fv_list))\n\t\treturn 0;\n\n\tfv = list_first_entry(fv_list, struct ice_sw_fv_list_entry,\n\t\t\t      list_entry);\n\tfv_ext = fv->fv_ptr->ew;\n\n\tlist_for_each_entry(rg, rg_list, l_entry) {\n\t\tu8 i;\n\n\t\tfor (i = 0; i < rg->r_group.n_val_pairs; i++) {\n\t\t\tstruct ice_fv_word *pr;\n\t\t\tbool found = false;\n\t\t\tu16 mask;\n\t\t\tu8 j;\n\n\t\t\tpr = &rg->r_group.pairs[i];\n\t\t\tmask = rg->r_group.mask[i];\n\n\t\t\tfor (j = 0; j < hw->blk[ICE_BLK_SW].es.fvw; j++)\n\t\t\t\tif (fv_ext[j].prot_id == pr->prot_id &&\n\t\t\t\t    fv_ext[j].off == pr->off) {\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\t \n\t\t\t\t\trg->fv_idx[i] = j;\n\t\t\t\t\trg->fv_mask[i] = mask;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t \n\t\t\tif (!found)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic u16\nice_find_free_recp_res_idx(struct ice_hw *hw, const unsigned long *profiles,\n\t\t\t   unsigned long *free_idx)\n{\n\tDECLARE_BITMAP(possible_idx, ICE_MAX_FV_WORDS);\n\tDECLARE_BITMAP(recipes, ICE_MAX_NUM_RECIPES);\n\tDECLARE_BITMAP(used_idx, ICE_MAX_FV_WORDS);\n\tu16 bit;\n\n\tbitmap_zero(recipes, ICE_MAX_NUM_RECIPES);\n\tbitmap_zero(used_idx, ICE_MAX_FV_WORDS);\n\n\tbitmap_fill(possible_idx, ICE_MAX_FV_WORDS);\n\n\t \n\tfor_each_set_bit(bit, profiles, ICE_MAX_NUM_PROFILES) {\n\t\tbitmap_or(recipes, recipes, profile_to_recipe[bit],\n\t\t\t  ICE_MAX_NUM_RECIPES);\n\t\tbitmap_and(possible_idx, possible_idx,\n\t\t\t   hw->switch_info->prof_res_bm[bit],\n\t\t\t   ICE_MAX_FV_WORDS);\n\t}\n\n\t \n\tfor_each_set_bit(bit, recipes, ICE_MAX_NUM_RECIPES)\n\t\tbitmap_or(used_idx, used_idx,\n\t\t\t  hw->switch_info->recp_list[bit].res_idxs,\n\t\t\t  ICE_MAX_FV_WORDS);\n\n\tbitmap_xor(free_idx, used_idx, possible_idx, ICE_MAX_FV_WORDS);\n\n\t \n\treturn (u16)bitmap_weight(free_idx, ICE_MAX_FV_WORDS);\n}\n\n \nstatic int\nice_add_sw_recipe(struct ice_hw *hw, struct ice_sw_recipe *rm,\n\t\t  unsigned long *profiles)\n{\n\tDECLARE_BITMAP(result_idx_bm, ICE_MAX_FV_WORDS);\n\tstruct ice_aqc_recipe_content *content;\n\tstruct ice_aqc_recipe_data_elem *tmp;\n\tstruct ice_aqc_recipe_data_elem *buf;\n\tstruct ice_recp_grp_entry *entry;\n\tu16 free_res_idx;\n\tu16 recipe_count;\n\tu8 chain_idx;\n\tu8 recps = 0;\n\tint status;\n\n\t \n\t  \n\tbitmap_zero(result_idx_bm, ICE_MAX_FV_WORDS);\n\tfree_res_idx = ice_find_free_recp_res_idx(hw, profiles, result_idx_bm);\n\n\tice_debug(hw, ICE_DBG_SW, \"Result idx slots: %d, need %d\\n\",\n\t\t  free_res_idx, rm->n_grp_count);\n\n\tif (rm->n_grp_count > 1) {\n\t\tif (rm->n_grp_count > free_res_idx)\n\t\t\treturn -ENOSPC;\n\n\t\trm->n_grp_count++;\n\t}\n\n\tif (rm->n_grp_count > ICE_MAX_CHAIN_RECIPE)\n\t\treturn -ENOSPC;\n\n\ttmp = kcalloc(ICE_MAX_NUM_RECIPES, sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tbuf = devm_kcalloc(ice_hw_to_dev(hw), rm->n_grp_count, sizeof(*buf),\n\t\t\t   GFP_KERNEL);\n\tif (!buf) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_mem;\n\t}\n\n\tbitmap_zero(rm->r_bitmap, ICE_MAX_NUM_RECIPES);\n\trecipe_count = ICE_MAX_NUM_RECIPES;\n\tstatus = ice_aq_get_recipe(hw, tmp, &recipe_count, ICE_SW_LKUP_MAC,\n\t\t\t\t   NULL);\n\tif (status || recipe_count == 0)\n\t\tgoto err_unroll;\n\n\t \n\tchain_idx = find_first_bit(result_idx_bm, ICE_MAX_FV_WORDS);\n\tlist_for_each_entry(entry, &rm->rg_list, l_entry) {\n\t\tu8 i;\n\n\t\tstatus = ice_alloc_recipe(hw, &entry->rid);\n\t\tif (status)\n\t\t\tgoto err_unroll;\n\n\t\tcontent = &buf[recps].content;\n\n\t\t \n\t\ttmp[0].content.result_indx = 0;\n\n\t\tbuf[recps] = tmp[0];\n\t\tbuf[recps].recipe_indx = (u8)entry->rid;\n\t\t \n\t\tcontent->rid = 0;\n\t\tmemset(&content->lkup_indx, 0,\n\t\t       sizeof(content->lkup_indx));\n\n\t\t \n\t\tcontent->lkup_indx[0] = ICE_AQ_SW_ID_LKUP_IDX;\n\t\tcontent->mask[0] = cpu_to_le16(ICE_AQ_SW_ID_LKUP_MASK);\n\t\t \n\t\tfor (i = 1; i <= ICE_NUM_WORDS_RECIPE; i++) {\n\t\t\tcontent->lkup_indx[i] = 0x80;\n\t\t\tcontent->mask[i] = 0;\n\t\t}\n\n\t\tfor (i = 0; i < entry->r_group.n_val_pairs; i++) {\n\t\t\tcontent->lkup_indx[i + 1] = entry->fv_idx[i];\n\t\t\tcontent->mask[i + 1] = cpu_to_le16(entry->fv_mask[i]);\n\t\t}\n\n\t\tif (rm->n_grp_count > 1) {\n\t\t\t \n\t\t\tif (chain_idx >= ICE_MAX_FV_WORDS) {\n\t\t\t\tice_debug(hw, ICE_DBG_SW, \"No chain index available\\n\");\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t\tgoto err_unroll;\n\t\t\t}\n\n\t\t\tentry->chain_idx = chain_idx;\n\t\t\tcontent->result_indx =\n\t\t\t\tICE_AQ_RECIPE_RESULT_EN |\n\t\t\t\t((chain_idx << ICE_AQ_RECIPE_RESULT_DATA_S) &\n\t\t\t\t ICE_AQ_RECIPE_RESULT_DATA_M);\n\t\t\tclear_bit(chain_idx, result_idx_bm);\n\t\t\tchain_idx = find_first_bit(result_idx_bm,\n\t\t\t\t\t\t   ICE_MAX_FV_WORDS);\n\t\t}\n\n\t\t \n\t\tbitmap_zero((unsigned long *)buf[recps].recipe_bitmap,\n\t\t\t    ICE_MAX_NUM_RECIPES);\n\t\tset_bit(buf[recps].recipe_indx,\n\t\t\t(unsigned long *)buf[recps].recipe_bitmap);\n\t\tcontent->act_ctrl_fwd_priority = rm->priority;\n\n\t\tif (rm->need_pass_l2)\n\t\t\tcontent->act_ctrl |= ICE_AQ_RECIPE_ACT_NEED_PASS_L2;\n\n\t\tif (rm->allow_pass_l2)\n\t\t\tcontent->act_ctrl |= ICE_AQ_RECIPE_ACT_ALLOW_PASS_L2;\n\t\trecps++;\n\t}\n\n\tif (rm->n_grp_count == 1) {\n\t\trm->root_rid = buf[0].recipe_indx;\n\t\tset_bit(buf[0].recipe_indx, rm->r_bitmap);\n\t\tbuf[0].content.rid = rm->root_rid | ICE_AQ_RECIPE_ID_IS_ROOT;\n\t\tif (sizeof(buf[0].recipe_bitmap) >= sizeof(rm->r_bitmap)) {\n\t\t\tmemcpy(buf[0].recipe_bitmap, rm->r_bitmap,\n\t\t\t       sizeof(buf[0].recipe_bitmap));\n\t\t} else {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto err_unroll;\n\t\t}\n\t\t \n\t\tbuf[0].content.act_ctrl_fwd_priority = rm->priority;\n\t} else {\n\t\tstruct ice_recp_grp_entry *last_chain_entry;\n\t\tu16 rid, i;\n\n\t\t \n\t\tstatus = ice_alloc_recipe(hw, &rid);\n\t\tif (status)\n\t\t\tgoto err_unroll;\n\n\t\tcontent = &buf[recps].content;\n\n\t\tbuf[recps].recipe_indx = (u8)rid;\n\t\tcontent->rid = (u8)rid;\n\t\tcontent->rid |= ICE_AQ_RECIPE_ID_IS_ROOT;\n\t\t \n\t\tlast_chain_entry = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t\t\t\tsizeof(*last_chain_entry),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!last_chain_entry) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto err_unroll;\n\t\t}\n\t\tlast_chain_entry->rid = rid;\n\t\tmemset(&content->lkup_indx, 0, sizeof(content->lkup_indx));\n\t\t \n\t\tcontent->lkup_indx[0] = ICE_AQ_SW_ID_LKUP_IDX;\n\t\tcontent->mask[0] = cpu_to_le16(ICE_AQ_SW_ID_LKUP_MASK);\n\t\tfor (i = 1; i <= ICE_NUM_WORDS_RECIPE; i++) {\n\t\t\tcontent->lkup_indx[i] = ICE_AQ_RECIPE_LKUP_IGNORE;\n\t\t\tcontent->mask[i] = 0;\n\t\t}\n\n\t\ti = 1;\n\t\t \n\t\tset_bit(rid, rm->r_bitmap);\n\t\t \n\t\tlast_chain_entry->chain_idx = ICE_INVAL_CHAIN_IND;\n\t\tlist_for_each_entry(entry, &rm->rg_list, l_entry) {\n\t\t\tlast_chain_entry->fv_idx[i] = entry->chain_idx;\n\t\t\tcontent->lkup_indx[i] = entry->chain_idx;\n\t\t\tcontent->mask[i++] = cpu_to_le16(0xFFFF);\n\t\t\tset_bit(entry->rid, rm->r_bitmap);\n\t\t}\n\t\tlist_add(&last_chain_entry->l_entry, &rm->rg_list);\n\t\tif (sizeof(buf[recps].recipe_bitmap) >=\n\t\t    sizeof(rm->r_bitmap)) {\n\t\t\tmemcpy(buf[recps].recipe_bitmap, rm->r_bitmap,\n\t\t\t       sizeof(buf[recps].recipe_bitmap));\n\t\t} else {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto err_unroll;\n\t\t}\n\t\tcontent->act_ctrl_fwd_priority = rm->priority;\n\n\t\trecps++;\n\t\trm->root_rid = (u8)rid;\n\t}\n\tstatus = ice_acquire_change_lock(hw, ICE_RES_WRITE);\n\tif (status)\n\t\tgoto err_unroll;\n\n\tstatus = ice_aq_add_recipe(hw, buf, rm->n_grp_count, NULL);\n\tice_release_change_lock(hw);\n\tif (status)\n\t\tgoto err_unroll;\n\n\t \n\tlist_for_each_entry(entry, &rm->rg_list, l_entry) {\n\t\tstruct ice_switch_info *sw = hw->switch_info;\n\t\tbool is_root, idx_found = false;\n\t\tstruct ice_sw_recipe *recp;\n\t\tu16 idx, buf_idx = 0;\n\n\t\t \n\t\tfor (idx = 0; idx < rm->n_grp_count; idx++)\n\t\t\tif (buf[idx].recipe_indx == entry->rid) {\n\t\t\t\tbuf_idx = idx;\n\t\t\t\tidx_found = true;\n\t\t\t}\n\n\t\tif (!idx_found) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto err_unroll;\n\t\t}\n\n\t\trecp = &sw->recp_list[entry->rid];\n\t\tis_root = (rm->root_rid == entry->rid);\n\t\trecp->is_root = is_root;\n\n\t\trecp->root_rid = entry->rid;\n\t\trecp->big_recp = (is_root && rm->n_grp_count > 1);\n\n\t\tmemcpy(&recp->ext_words, entry->r_group.pairs,\n\t\t       entry->r_group.n_val_pairs * sizeof(struct ice_fv_word));\n\n\t\tmemcpy(recp->r_bitmap, buf[buf_idx].recipe_bitmap,\n\t\t       sizeof(recp->r_bitmap));\n\n\t\t \n\t\tice_collect_result_idx(&buf[buf_idx], recp);\n\n\t\t \n\t\tif (!is_root)\n\t\t\tice_collect_result_idx(&buf[buf_idx],\n\t\t\t\t\t       &sw->recp_list[rm->root_rid]);\n\n\t\trecp->n_ext_words = entry->r_group.n_val_pairs;\n\t\trecp->chain_idx = entry->chain_idx;\n\t\trecp->priority = buf[buf_idx].content.act_ctrl_fwd_priority;\n\t\trecp->n_grp_count = rm->n_grp_count;\n\t\trecp->tun_type = rm->tun_type;\n\t\trecp->need_pass_l2 = rm->need_pass_l2;\n\t\trecp->allow_pass_l2 = rm->allow_pass_l2;\n\t\trecp->recp_created = true;\n\t}\n\trm->root_buf = buf;\n\tkfree(tmp);\n\treturn status;\n\nerr_unroll:\nerr_mem:\n\tkfree(tmp);\n\tdevm_kfree(ice_hw_to_dev(hw), buf);\n\treturn status;\n}\n\n \nstatic int\nice_create_recipe_group(struct ice_hw *hw, struct ice_sw_recipe *rm,\n\t\t\tstruct ice_prot_lkup_ext *lkup_exts)\n{\n\tu8 recp_count = 0;\n\tint status;\n\n\trm->n_grp_count = 0;\n\n\t \n\tstatus = ice_create_first_fit_recp_def(hw, lkup_exts,\n\t\t\t\t\t       &rm->rg_list, &recp_count);\n\tif (!status) {\n\t\trm->n_grp_count += recp_count;\n\t\trm->n_ext_words = lkup_exts->n_val_words;\n\t\tmemcpy(&rm->ext_words, lkup_exts->fv_words,\n\t\t       sizeof(rm->ext_words));\n\t\tmemcpy(rm->word_masks, lkup_exts->field_mask,\n\t\t       sizeof(rm->word_masks));\n\t}\n\n\treturn status;\n}\n\n \nstatic void\nice_get_compat_fv_bitmap(struct ice_hw *hw, struct ice_adv_rule_info *rinfo,\n\t\t\t unsigned long *bm)\n{\n\tenum ice_prof_type prof_type;\n\n\tbitmap_zero(bm, ICE_MAX_NUM_PROFILES);\n\n\tswitch (rinfo->tun_type) {\n\tcase ICE_NON_TUN:\n\t\tprof_type = ICE_PROF_NON_TUN;\n\t\tbreak;\n\tcase ICE_ALL_TUNNELS:\n\t\tprof_type = ICE_PROF_TUN_ALL;\n\t\tbreak;\n\tcase ICE_SW_TUN_GENEVE:\n\tcase ICE_SW_TUN_VXLAN:\n\t\tprof_type = ICE_PROF_TUN_UDP;\n\t\tbreak;\n\tcase ICE_SW_TUN_NVGRE:\n\t\tprof_type = ICE_PROF_TUN_GRE;\n\t\tbreak;\n\tcase ICE_SW_TUN_GTPU:\n\t\tprof_type = ICE_PROF_TUN_GTPU;\n\t\tbreak;\n\tcase ICE_SW_TUN_GTPC:\n\t\tprof_type = ICE_PROF_TUN_GTPC;\n\t\tbreak;\n\tcase ICE_SW_TUN_AND_NON_TUN:\n\tdefault:\n\t\tprof_type = ICE_PROF_ALL;\n\t\tbreak;\n\t}\n\n\tice_get_sw_fv_bitmap(hw, prof_type, bm);\n}\n\n \nstatic int\nice_add_adv_recipe(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups,\n\t\t   u16 lkups_cnt, struct ice_adv_rule_info *rinfo, u16 *rid)\n{\n\tDECLARE_BITMAP(fv_bitmap, ICE_MAX_NUM_PROFILES);\n\tDECLARE_BITMAP(profiles, ICE_MAX_NUM_PROFILES);\n\tstruct ice_prot_lkup_ext *lkup_exts;\n\tstruct ice_recp_grp_entry *r_entry;\n\tstruct ice_sw_fv_list_entry *fvit;\n\tstruct ice_recp_grp_entry *r_tmp;\n\tstruct ice_sw_fv_list_entry *tmp;\n\tstruct ice_sw_recipe *rm;\n\tint status = 0;\n\tu8 i;\n\n\tif (!lkups_cnt)\n\t\treturn -EINVAL;\n\n\tlkup_exts = kzalloc(sizeof(*lkup_exts), GFP_KERNEL);\n\tif (!lkup_exts)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < lkups_cnt; i++) {\n\t\tu16 count;\n\n\t\tif (lkups[i].type >= ICE_PROTOCOL_LAST) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto err_free_lkup_exts;\n\t\t}\n\n\t\tcount = ice_fill_valid_words(&lkups[i], lkup_exts);\n\t\tif (!count) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto err_free_lkup_exts;\n\t\t}\n\t}\n\n\trm = kzalloc(sizeof(*rm), GFP_KERNEL);\n\tif (!rm) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_free_lkup_exts;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&rm->fv_list);\n\tINIT_LIST_HEAD(&rm->rg_list);\n\n\t \n\tice_get_compat_fv_bitmap(hw, rinfo, fv_bitmap);\n\n\tstatus = ice_get_sw_fv_list(hw, lkup_exts, fv_bitmap, &rm->fv_list);\n\tif (status)\n\t\tgoto err_unroll;\n\n\t \n\tstatus = ice_create_recipe_group(hw, rm, lkup_exts);\n\tif (status)\n\t\tgoto err_unroll;\n\n\t \n\trm->priority = (u8)rinfo->priority;\n\n\trm->need_pass_l2 = rinfo->need_pass_l2;\n\trm->allow_pass_l2 = rinfo->allow_pass_l2;\n\n\t \n\tstatus = ice_fill_fv_word_index(hw, &rm->fv_list, &rm->rg_list);\n\tif (status)\n\t\tgoto err_unroll;\n\n\t \n\tbitmap_zero(profiles, ICE_MAX_NUM_PROFILES);\n\tlist_for_each_entry(fvit, &rm->fv_list, list_entry) {\n\t\tice_debug(hw, ICE_DBG_SW, \"profile: %d\\n\", fvit->profile_id);\n\t\tset_bit((u16)fvit->profile_id, profiles);\n\t}\n\n\t \n\t*rid = ice_find_recp(hw, lkup_exts, rinfo);\n\tif (*rid < ICE_MAX_NUM_RECIPES)\n\t\t \n\t\tgoto err_unroll;\n\n\trm->tun_type = rinfo->tun_type;\n\t \n\tstatus = ice_add_sw_recipe(hw, rm, profiles);\n\tif (status)\n\t\tgoto err_unroll;\n\n\t \n\tlist_for_each_entry(fvit, &rm->fv_list, list_entry) {\n\t\tDECLARE_BITMAP(r_bitmap, ICE_MAX_NUM_RECIPES);\n\t\tu16 j;\n\n\t\tstatus = ice_aq_get_recipe_to_profile(hw, fvit->profile_id,\n\t\t\t\t\t\t      (u8 *)r_bitmap, NULL);\n\t\tif (status)\n\t\t\tgoto err_unroll;\n\n\t\tbitmap_or(r_bitmap, r_bitmap, rm->r_bitmap,\n\t\t\t  ICE_MAX_NUM_RECIPES);\n\t\tstatus = ice_acquire_change_lock(hw, ICE_RES_WRITE);\n\t\tif (status)\n\t\t\tgoto err_unroll;\n\n\t\tstatus = ice_aq_map_recipe_to_profile(hw, fvit->profile_id,\n\t\t\t\t\t\t      (u8 *)r_bitmap,\n\t\t\t\t\t\t      NULL);\n\t\tice_release_change_lock(hw);\n\n\t\tif (status)\n\t\t\tgoto err_unroll;\n\n\t\t \n\t\tbitmap_copy(profile_to_recipe[fvit->profile_id], r_bitmap,\n\t\t\t    ICE_MAX_NUM_RECIPES);\n\n\t\t \n\t\tfor_each_set_bit(j, rm->r_bitmap, ICE_MAX_NUM_RECIPES)\n\t\t\tset_bit((u16)fvit->profile_id, recipe_to_profile[j]);\n\t}\n\n\t*rid = rm->root_rid;\n\tmemcpy(&hw->switch_info->recp_list[*rid].lkup_exts, lkup_exts,\n\t       sizeof(*lkup_exts));\nerr_unroll:\n\tlist_for_each_entry_safe(r_entry, r_tmp, &rm->rg_list, l_entry) {\n\t\tlist_del(&r_entry->l_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), r_entry);\n\t}\n\n\tlist_for_each_entry_safe(fvit, tmp, &rm->fv_list, list_entry) {\n\t\tlist_del(&fvit->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), fvit);\n\t}\n\n\tdevm_kfree(ice_hw_to_dev(hw), rm->root_buf);\n\tkfree(rm);\n\nerr_free_lkup_exts:\n\tkfree(lkup_exts);\n\n\treturn status;\n}\n\n \nstatic struct ice_dummy_pkt_profile *\nice_dummy_packet_add_vlan(const struct ice_dummy_pkt_profile *dummy_pkt,\n\t\t\t  u32 num_vlan)\n{\n\tstruct ice_dummy_pkt_profile *profile;\n\tstruct ice_dummy_pkt_offsets *offsets;\n\tu32 buf_len, off, etype_off, i;\n\tu8 *pkt;\n\n\tif (num_vlan < 1 || num_vlan > 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\toff = num_vlan * VLAN_HLEN;\n\n\tbuf_len = array_size(num_vlan, sizeof(ice_dummy_vlan_packet_offsets)) +\n\t\t  dummy_pkt->offsets_len;\n\toffsets = kzalloc(buf_len, GFP_KERNEL);\n\tif (!offsets)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\toffsets[0] = dummy_pkt->offsets[0];\n\tif (num_vlan == 2) {\n\t\toffsets[1] = ice_dummy_qinq_packet_offsets[0];\n\t\toffsets[2] = ice_dummy_qinq_packet_offsets[1];\n\t} else if (num_vlan == 1) {\n\t\toffsets[1] = ice_dummy_vlan_packet_offsets[0];\n\t}\n\n\tfor (i = 1; dummy_pkt->offsets[i].type != ICE_PROTOCOL_LAST; i++) {\n\t\toffsets[i + num_vlan].type = dummy_pkt->offsets[i].type;\n\t\toffsets[i + num_vlan].offset =\n\t\t\tdummy_pkt->offsets[i].offset + off;\n\t}\n\toffsets[i + num_vlan] = dummy_pkt->offsets[i];\n\n\tetype_off = dummy_pkt->offsets[1].offset;\n\n\tbuf_len = array_size(num_vlan, sizeof(ice_dummy_vlan_packet)) +\n\t\t  dummy_pkt->pkt_len;\n\tpkt = kzalloc(buf_len, GFP_KERNEL);\n\tif (!pkt) {\n\t\tkfree(offsets);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmemcpy(pkt, dummy_pkt->pkt, etype_off);\n\tmemcpy(pkt + etype_off,\n\t       num_vlan == 2 ? ice_dummy_qinq_packet : ice_dummy_vlan_packet,\n\t       off);\n\tmemcpy(pkt + etype_off + off, dummy_pkt->pkt + etype_off,\n\t       dummy_pkt->pkt_len - etype_off);\n\n\tprofile = kzalloc(sizeof(*profile), GFP_KERNEL);\n\tif (!profile) {\n\t\tkfree(offsets);\n\t\tkfree(pkt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tprofile->offsets = offsets;\n\tprofile->pkt = pkt;\n\tprofile->pkt_len = buf_len;\n\tprofile->match |= ICE_PKT_KMALLOC;\n\n\treturn profile;\n}\n\n \nstatic const struct ice_dummy_pkt_profile *\nice_find_dummy_packet(struct ice_adv_lkup_elem *lkups, u16 lkups_cnt,\n\t\t      enum ice_sw_tunnel_type tun_type)\n{\n\tconst struct ice_dummy_pkt_profile *ret = ice_dummy_pkt_profiles;\n\tu32 match = 0, vlan_count = 0;\n\tu16 i;\n\n\tswitch (tun_type) {\n\tcase ICE_SW_TUN_GTPC:\n\t\tmatch |= ICE_PKT_TUN_GTPC;\n\t\tbreak;\n\tcase ICE_SW_TUN_GTPU:\n\t\tmatch |= ICE_PKT_TUN_GTPU;\n\t\tbreak;\n\tcase ICE_SW_TUN_NVGRE:\n\t\tmatch |= ICE_PKT_TUN_NVGRE;\n\t\tbreak;\n\tcase ICE_SW_TUN_GENEVE:\n\tcase ICE_SW_TUN_VXLAN:\n\t\tmatch |= ICE_PKT_TUN_UDP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < lkups_cnt; i++) {\n\t\tif (lkups[i].type == ICE_UDP_ILOS)\n\t\t\tmatch |= ICE_PKT_INNER_UDP;\n\t\telse if (lkups[i].type == ICE_TCP_IL)\n\t\t\tmatch |= ICE_PKT_INNER_TCP;\n\t\telse if (lkups[i].type == ICE_IPV6_OFOS)\n\t\t\tmatch |= ICE_PKT_OUTER_IPV6;\n\t\telse if (lkups[i].type == ICE_VLAN_OFOS ||\n\t\t\t lkups[i].type == ICE_VLAN_EX)\n\t\t\tvlan_count++;\n\t\telse if (lkups[i].type == ICE_VLAN_IN)\n\t\t\tvlan_count++;\n\t\telse if (lkups[i].type == ICE_ETYPE_OL &&\n\t\t\t lkups[i].h_u.ethertype.ethtype_id ==\n\t\t\t\tcpu_to_be16(ICE_IPV6_ETHER_ID) &&\n\t\t\t lkups[i].m_u.ethertype.ethtype_id ==\n\t\t\t\tcpu_to_be16(0xFFFF))\n\t\t\tmatch |= ICE_PKT_OUTER_IPV6;\n\t\telse if (lkups[i].type == ICE_ETYPE_IL &&\n\t\t\t lkups[i].h_u.ethertype.ethtype_id ==\n\t\t\t\tcpu_to_be16(ICE_IPV6_ETHER_ID) &&\n\t\t\t lkups[i].m_u.ethertype.ethtype_id ==\n\t\t\t\tcpu_to_be16(0xFFFF))\n\t\t\tmatch |= ICE_PKT_INNER_IPV6;\n\t\telse if (lkups[i].type == ICE_IPV6_IL)\n\t\t\tmatch |= ICE_PKT_INNER_IPV6;\n\t\telse if (lkups[i].type == ICE_GTP_NO_PAY)\n\t\t\tmatch |= ICE_PKT_GTP_NOPAY;\n\t\telse if (lkups[i].type == ICE_PPPOE) {\n\t\t\tmatch |= ICE_PKT_PPPOE;\n\t\t\tif (lkups[i].h_u.pppoe_hdr.ppp_prot_id ==\n\t\t\t    htons(PPP_IPV6))\n\t\t\t\tmatch |= ICE_PKT_OUTER_IPV6;\n\t\t} else if (lkups[i].type == ICE_L2TPV3)\n\t\t\tmatch |= ICE_PKT_L2TPV3;\n\t}\n\n\twhile (ret->match && (match & ret->match) != ret->match)\n\t\tret++;\n\n\tif (vlan_count != 0)\n\t\tret = ice_dummy_packet_add_vlan(ret, vlan_count);\n\n\treturn ret;\n}\n\n \nstatic int\nice_fill_adv_dummy_packet(struct ice_adv_lkup_elem *lkups, u16 lkups_cnt,\n\t\t\t  struct ice_sw_rule_lkup_rx_tx *s_rule,\n\t\t\t  const struct ice_dummy_pkt_profile *profile)\n{\n\tu8 *pkt;\n\tu16 i;\n\n\t \n\tpkt = s_rule->hdr_data;\n\n\tmemcpy(pkt, profile->pkt, profile->pkt_len);\n\n\tfor (i = 0; i < lkups_cnt; i++) {\n\t\tconst struct ice_dummy_pkt_offsets *offsets = profile->offsets;\n\t\tenum ice_protocol_type type;\n\t\tu16 offset = 0, len = 0, j;\n\t\tbool found = false;\n\n\t\t \n\t\ttype = lkups[i].type;\n\t\t \n\t\tif (type == ICE_HW_METADATA)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; offsets[j].type != ICE_PROTOCOL_LAST; j++) {\n\t\t\tif (type == offsets[j].type) {\n\t\t\t\toffset = offsets[j].offset;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!found)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (lkups[i].type) {\n\t\tcase ICE_MAC_OFOS:\n\t\tcase ICE_MAC_IL:\n\t\t\tlen = sizeof(struct ice_ether_hdr);\n\t\t\tbreak;\n\t\tcase ICE_ETYPE_OL:\n\t\tcase ICE_ETYPE_IL:\n\t\t\tlen = sizeof(struct ice_ethtype_hdr);\n\t\t\tbreak;\n\t\tcase ICE_VLAN_OFOS:\n\t\tcase ICE_VLAN_EX:\n\t\tcase ICE_VLAN_IN:\n\t\t\tlen = sizeof(struct ice_vlan_hdr);\n\t\t\tbreak;\n\t\tcase ICE_IPV4_OFOS:\n\t\tcase ICE_IPV4_IL:\n\t\t\tlen = sizeof(struct ice_ipv4_hdr);\n\t\t\tbreak;\n\t\tcase ICE_IPV6_OFOS:\n\t\tcase ICE_IPV6_IL:\n\t\t\tlen = sizeof(struct ice_ipv6_hdr);\n\t\t\tbreak;\n\t\tcase ICE_TCP_IL:\n\t\tcase ICE_UDP_OF:\n\t\tcase ICE_UDP_ILOS:\n\t\t\tlen = sizeof(struct ice_l4_hdr);\n\t\t\tbreak;\n\t\tcase ICE_SCTP_IL:\n\t\t\tlen = sizeof(struct ice_sctp_hdr);\n\t\t\tbreak;\n\t\tcase ICE_NVGRE:\n\t\t\tlen = sizeof(struct ice_nvgre_hdr);\n\t\t\tbreak;\n\t\tcase ICE_VXLAN:\n\t\tcase ICE_GENEVE:\n\t\t\tlen = sizeof(struct ice_udp_tnl_hdr);\n\t\t\tbreak;\n\t\tcase ICE_GTP_NO_PAY:\n\t\tcase ICE_GTP:\n\t\t\tlen = sizeof(struct ice_udp_gtp_hdr);\n\t\t\tbreak;\n\t\tcase ICE_PPPOE:\n\t\t\tlen = sizeof(struct ice_pppoe_hdr);\n\t\t\tbreak;\n\t\tcase ICE_L2TPV3:\n\t\t\tlen = sizeof(struct ice_l2tpv3_sess_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (len % ICE_BYTES_PER_WORD)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tfor (j = 0; j < len / sizeof(u16); j++) {\n\t\t\tu16 *ptr = (u16 *)(pkt + offset);\n\t\t\tu16 mask = lkups[i].m_raw[j];\n\n\t\t\tif (!mask)\n\t\t\t\tcontinue;\n\n\t\t\tptr[j] = (ptr[j] & ~mask) | (lkups[i].h_raw[j] & mask);\n\t\t}\n\t}\n\n\ts_rule->hdr_len = cpu_to_le16(profile->pkt_len);\n\n\treturn 0;\n}\n\n \nstatic int\nice_fill_adv_packet_tun(struct ice_hw *hw, enum ice_sw_tunnel_type tun_type,\n\t\t\tu8 *pkt, const struct ice_dummy_pkt_offsets *offsets)\n{\n\tu16 open_port, i;\n\n\tswitch (tun_type) {\n\tcase ICE_SW_TUN_VXLAN:\n\t\tif (!ice_get_open_tunnel_port(hw, &open_port, TNL_VXLAN))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase ICE_SW_TUN_GENEVE:\n\t\tif (!ice_get_open_tunnel_port(hw, &open_port, TNL_GENEVE))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; offsets[i].type != ICE_PROTOCOL_LAST; i++) {\n\t\tif (offsets[i].type == ICE_UDP_OF) {\n\t\t\tstruct ice_l4_hdr *hdr;\n\t\t\tu16 offset;\n\n\t\t\toffset = offsets[i].offset;\n\t\t\thdr = (struct ice_l4_hdr *)&pkt[offset];\n\t\t\thdr->dst_port = cpu_to_be16(open_port);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\n \nstatic int\nice_fill_adv_packet_vlan(struct ice_hw *hw, u16 vlan_type, u8 *pkt,\n\t\t\t const struct ice_dummy_pkt_offsets *offsets)\n{\n\tu16 i;\n\n\t \n\tif (!vlan_type || !ice_is_dvm_ena(hw))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; offsets[i].type != ICE_PROTOCOL_LAST; i++) {\n\t\tif (offsets[i].type == ICE_VLAN_OFOS ||\n\t\t    offsets[i].type == ICE_VLAN_EX) {\n\t\t\tstruct ice_vlan_hdr *hdr;\n\t\t\tu16 offset;\n\n\t\t\toffset = offsets[i].offset;\n\t\t\thdr = (struct ice_vlan_hdr *)&pkt[offset];\n\t\t\thdr->type = cpu_to_be16(vlan_type);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic bool ice_rules_equal(const struct ice_adv_rule_info *first,\n\t\t\t    const struct ice_adv_rule_info *second)\n{\n\treturn first->sw_act.flag == second->sw_act.flag &&\n\t       first->tun_type == second->tun_type &&\n\t       first->vlan_type == second->vlan_type &&\n\t       first->src_vsi == second->src_vsi &&\n\t       first->need_pass_l2 == second->need_pass_l2 &&\n\t       first->allow_pass_l2 == second->allow_pass_l2;\n}\n\n \nstatic struct ice_adv_fltr_mgmt_list_entry *\nice_find_adv_rule_entry(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups,\n\t\t\tu16 lkups_cnt, u16 recp_id,\n\t\t\tstruct ice_adv_rule_info *rinfo)\n{\n\tstruct ice_adv_fltr_mgmt_list_entry *list_itr;\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tint i;\n\n\tlist_for_each_entry(list_itr, &sw->recp_list[recp_id].filt_rules,\n\t\t\t    list_entry) {\n\t\tbool lkups_matched = true;\n\n\t\tif (lkups_cnt != list_itr->lkups_cnt)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < list_itr->lkups_cnt; i++)\n\t\t\tif (memcmp(&list_itr->lkups[i], &lkups[i],\n\t\t\t\t   sizeof(*lkups))) {\n\t\t\t\tlkups_matched = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (ice_rules_equal(rinfo, &list_itr->rule_info) &&\n\t\t    lkups_matched)\n\t\t\treturn list_itr;\n\t}\n\treturn NULL;\n}\n\n \nstatic int\nice_adv_add_update_vsi_list(struct ice_hw *hw,\n\t\t\t    struct ice_adv_fltr_mgmt_list_entry *m_entry,\n\t\t\t    struct ice_adv_rule_info *cur_fltr,\n\t\t\t    struct ice_adv_rule_info *new_fltr)\n{\n\tu16 vsi_list_id = 0;\n\tint status;\n\n\tif (cur_fltr->sw_act.fltr_act == ICE_FWD_TO_Q ||\n\t    cur_fltr->sw_act.fltr_act == ICE_FWD_TO_QGRP ||\n\t    cur_fltr->sw_act.fltr_act == ICE_DROP_PACKET)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((new_fltr->sw_act.fltr_act == ICE_FWD_TO_Q ||\n\t     new_fltr->sw_act.fltr_act == ICE_FWD_TO_QGRP) &&\n\t    (cur_fltr->sw_act.fltr_act == ICE_FWD_TO_VSI ||\n\t     cur_fltr->sw_act.fltr_act == ICE_FWD_TO_VSI_LIST))\n\t\treturn -EOPNOTSUPP;\n\n\tif (m_entry->vsi_count < 2 && !m_entry->vsi_list_info) {\n\t\t  \n\t\tstruct ice_fltr_info tmp_fltr;\n\t\tu16 vsi_handle_arr[2];\n\n\t\t \n\t\tif (cur_fltr->sw_act.fwd_id.hw_vsi_id ==\n\t\t    new_fltr->sw_act.fwd_id.hw_vsi_id)\n\t\t\treturn -EEXIST;\n\n\t\tvsi_handle_arr[0] = cur_fltr->sw_act.vsi_handle;\n\t\tvsi_handle_arr[1] = new_fltr->sw_act.vsi_handle;\n\t\tstatus = ice_create_vsi_list_rule(hw, &vsi_handle_arr[0], 2,\n\t\t\t\t\t\t  &vsi_list_id,\n\t\t\t\t\t\t  ICE_SW_LKUP_LAST);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tmemset(&tmp_fltr, 0, sizeof(tmp_fltr));\n\t\ttmp_fltr.flag = m_entry->rule_info.sw_act.flag;\n\t\ttmp_fltr.fltr_rule_id = cur_fltr->fltr_rule_id;\n\t\ttmp_fltr.fltr_act = ICE_FWD_TO_VSI_LIST;\n\t\ttmp_fltr.fwd_id.vsi_list_id = vsi_list_id;\n\t\ttmp_fltr.lkup_type = ICE_SW_LKUP_LAST;\n\n\t\t \n\t\tstatus = ice_update_pkt_fwd_rule(hw, &tmp_fltr);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tcur_fltr->sw_act.fwd_id.vsi_list_id = vsi_list_id;\n\t\tcur_fltr->sw_act.fltr_act = ICE_FWD_TO_VSI_LIST;\n\t\tm_entry->vsi_list_info =\n\t\t\tice_create_vsi_list_map(hw, &vsi_handle_arr[0], 2,\n\t\t\t\t\t\tvsi_list_id);\n\t} else {\n\t\tu16 vsi_handle = new_fltr->sw_act.vsi_handle;\n\n\t\tif (!m_entry->vsi_list_info)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (test_bit(vsi_handle, m_entry->vsi_list_info->vsi_map))\n\t\t\treturn 0;\n\n\t\t \n\t\tvsi_list_id = cur_fltr->sw_act.fwd_id.vsi_list_id;\n\n\t\tstatus = ice_update_vsi_list_rule(hw, &vsi_handle, 1,\n\t\t\t\t\t\t  vsi_list_id, false,\n\t\t\t\t\t\t  ice_aqc_opc_update_sw_rules,\n\t\t\t\t\t\t  ICE_SW_LKUP_LAST);\n\t\t \n\t\tif (!status)\n\t\t\tset_bit(vsi_handle, m_entry->vsi_list_info->vsi_map);\n\t}\n\tif (!status)\n\t\tm_entry->vsi_count++;\n\treturn status;\n}\n\nvoid ice_rule_add_tunnel_metadata(struct ice_adv_lkup_elem *lkup)\n{\n\tlkup->type = ICE_HW_METADATA;\n\tlkup->m_u.metadata.flags[ICE_PKT_FLAGS_MDID21] |=\n\t\tcpu_to_be16(ICE_PKT_TUNNEL_MASK);\n}\n\nvoid ice_rule_add_direction_metadata(struct ice_adv_lkup_elem *lkup)\n{\n\tlkup->type = ICE_HW_METADATA;\n\tlkup->m_u.metadata.flags[ICE_PKT_FLAGS_MDID20] |=\n\t\tcpu_to_be16(ICE_PKT_FROM_NETWORK);\n}\n\nvoid ice_rule_add_vlan_metadata(struct ice_adv_lkup_elem *lkup)\n{\n\tlkup->type = ICE_HW_METADATA;\n\tlkup->m_u.metadata.flags[ICE_PKT_FLAGS_MDID20] |=\n\t\tcpu_to_be16(ICE_PKT_VLAN_MASK);\n}\n\nvoid ice_rule_add_src_vsi_metadata(struct ice_adv_lkup_elem *lkup)\n{\n\tlkup->type = ICE_HW_METADATA;\n\tlkup->m_u.metadata.source_vsi = cpu_to_be16(ICE_MDID_SOURCE_VSI_MASK);\n}\n\n \nint\nice_add_adv_rule(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups,\n\t\t u16 lkups_cnt, struct ice_adv_rule_info *rinfo,\n\t\t struct ice_rule_query_data *added_entry)\n{\n\tstruct ice_adv_fltr_mgmt_list_entry *m_entry, *adv_fltr = NULL;\n\tstruct ice_sw_rule_lkup_rx_tx *s_rule = NULL;\n\tconst struct ice_dummy_pkt_profile *profile;\n\tu16 rid = 0, i, rule_buf_sz, vsi_handle;\n\tstruct list_head *rule_head;\n\tstruct ice_switch_info *sw;\n\tu16 word_cnt;\n\tu32 act = 0;\n\tint status;\n\tu8 q_rgn;\n\n\t \n\tif (!hw->switch_info->prof_res_bm_init) {\n\t\thw->switch_info->prof_res_bm_init = 1;\n\t\tice_init_prof_result_bm(hw);\n\t}\n\n\tif (!lkups_cnt)\n\t\treturn -EINVAL;\n\n\t \n\tword_cnt = 0;\n\tfor (i = 0; i < lkups_cnt; i++) {\n\t\tu16 j;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(lkups->m_raw); j++)\n\t\t\tif (lkups[i].m_raw[j])\n\t\t\t\tword_cnt++;\n\t}\n\n\tif (!word_cnt)\n\t\treturn -EINVAL;\n\n\tif (word_cnt > ICE_MAX_CHAIN_WORDS)\n\t\treturn -ENOSPC;\n\n\t \n\tprofile = ice_find_dummy_packet(lkups, lkups_cnt, rinfo->tun_type);\n\tif (IS_ERR(profile))\n\t\treturn PTR_ERR(profile);\n\n\tif (!(rinfo->sw_act.fltr_act == ICE_FWD_TO_VSI ||\n\t      rinfo->sw_act.fltr_act == ICE_FWD_TO_Q ||\n\t      rinfo->sw_act.fltr_act == ICE_FWD_TO_QGRP ||\n\t      rinfo->sw_act.fltr_act == ICE_DROP_PACKET ||\n\t      rinfo->sw_act.fltr_act == ICE_NOP)) {\n\t\tstatus = -EIO;\n\t\tgoto free_pkt_profile;\n\t}\n\n\tvsi_handle = rinfo->sw_act.vsi_handle;\n\tif (!ice_is_vsi_valid(hw, vsi_handle)) {\n\t\tstatus =  -EINVAL;\n\t\tgoto free_pkt_profile;\n\t}\n\n\tif (rinfo->sw_act.fltr_act == ICE_FWD_TO_VSI ||\n\t    rinfo->sw_act.fltr_act == ICE_NOP)\n\t\trinfo->sw_act.fwd_id.hw_vsi_id =\n\t\t\tice_get_hw_vsi_num(hw, vsi_handle);\n\n\tif (rinfo->src_vsi)\n\t\trinfo->sw_act.src = ice_get_hw_vsi_num(hw, rinfo->src_vsi);\n\telse\n\t\trinfo->sw_act.src = ice_get_hw_vsi_num(hw, vsi_handle);\n\n\tstatus = ice_add_adv_recipe(hw, lkups, lkups_cnt, rinfo, &rid);\n\tif (status)\n\t\tgoto free_pkt_profile;\n\tm_entry = ice_find_adv_rule_entry(hw, lkups, lkups_cnt, rid, rinfo);\n\tif (m_entry) {\n\t\t \n\t\tstatus = ice_adv_add_update_vsi_list(hw, m_entry,\n\t\t\t\t\t\t     &m_entry->rule_info,\n\t\t\t\t\t\t     rinfo);\n\t\tif (added_entry) {\n\t\t\tadded_entry->rid = rid;\n\t\t\tadded_entry->rule_id = m_entry->rule_info.fltr_rule_id;\n\t\t\tadded_entry->vsi_handle = rinfo->sw_act.vsi_handle;\n\t\t}\n\t\tgoto free_pkt_profile;\n\t}\n\trule_buf_sz = ICE_SW_RULE_RX_TX_HDR_SIZE(s_rule, profile->pkt_len);\n\ts_rule = kzalloc(rule_buf_sz, GFP_KERNEL);\n\tif (!s_rule) {\n\t\tstatus = -ENOMEM;\n\t\tgoto free_pkt_profile;\n\t}\n\tif (!rinfo->flags_info.act_valid) {\n\t\tact |= ICE_SINGLE_ACT_LAN_ENABLE;\n\t\tact |= ICE_SINGLE_ACT_LB_ENABLE;\n\t} else {\n\t\tact |= rinfo->flags_info.act & (ICE_SINGLE_ACT_LAN_ENABLE |\n\t\t\t\t\t\tICE_SINGLE_ACT_LB_ENABLE);\n\t}\n\n\tswitch (rinfo->sw_act.fltr_act) {\n\tcase ICE_FWD_TO_VSI:\n\t\tact |= (rinfo->sw_act.fwd_id.hw_vsi_id <<\n\t\t\tICE_SINGLE_ACT_VSI_ID_S) & ICE_SINGLE_ACT_VSI_ID_M;\n\t\tact |= ICE_SINGLE_ACT_VSI_FORWARDING | ICE_SINGLE_ACT_VALID_BIT;\n\t\tbreak;\n\tcase ICE_FWD_TO_Q:\n\t\tact |= ICE_SINGLE_ACT_TO_Q;\n\t\tact |= (rinfo->sw_act.fwd_id.q_id << ICE_SINGLE_ACT_Q_INDEX_S) &\n\t\t       ICE_SINGLE_ACT_Q_INDEX_M;\n\t\tbreak;\n\tcase ICE_FWD_TO_QGRP:\n\t\tq_rgn = rinfo->sw_act.qgrp_size > 0 ?\n\t\t\t(u8)ilog2(rinfo->sw_act.qgrp_size) : 0;\n\t\tact |= ICE_SINGLE_ACT_TO_Q;\n\t\tact |= (rinfo->sw_act.fwd_id.q_id << ICE_SINGLE_ACT_Q_INDEX_S) &\n\t\t       ICE_SINGLE_ACT_Q_INDEX_M;\n\t\tact |= (q_rgn << ICE_SINGLE_ACT_Q_REGION_S) &\n\t\t       ICE_SINGLE_ACT_Q_REGION_M;\n\t\tbreak;\n\tcase ICE_DROP_PACKET:\n\t\tact |= ICE_SINGLE_ACT_VSI_FORWARDING | ICE_SINGLE_ACT_DROP |\n\t\t       ICE_SINGLE_ACT_VALID_BIT;\n\t\tbreak;\n\tcase ICE_NOP:\n\t\tact |= FIELD_PREP(ICE_SINGLE_ACT_VSI_ID_M,\n\t\t\t\t  rinfo->sw_act.fwd_id.hw_vsi_id);\n\t\tact &= ~ICE_SINGLE_ACT_VALID_BIT;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EIO;\n\t\tgoto err_ice_add_adv_rule;\n\t}\n\n\t \n\tif (rinfo->sw_act.flag & ICE_FLTR_TX) {\n\t\ts_rule->hdr.type = cpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_TX);\n\t\ts_rule->src = cpu_to_le16(rinfo->sw_act.src);\n\t} else {\n\t\ts_rule->hdr.type = cpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_RX);\n\t\ts_rule->src = cpu_to_le16(hw->port_info->lport);\n\t}\n\n\ts_rule->recipe_id = cpu_to_le16(rid);\n\ts_rule->act = cpu_to_le32(act);\n\n\tstatus = ice_fill_adv_dummy_packet(lkups, lkups_cnt, s_rule, profile);\n\tif (status)\n\t\tgoto err_ice_add_adv_rule;\n\n\tstatus = ice_fill_adv_packet_tun(hw, rinfo->tun_type, s_rule->hdr_data,\n\t\t\t\t\t profile->offsets);\n\tif (status)\n\t\tgoto err_ice_add_adv_rule;\n\n\tstatus = ice_fill_adv_packet_vlan(hw, rinfo->vlan_type,\n\t\t\t\t\t  s_rule->hdr_data,\n\t\t\t\t\t  profile->offsets);\n\tif (status)\n\t\tgoto err_ice_add_adv_rule;\n\n\tstatus = ice_aq_sw_rules(hw, (struct ice_aqc_sw_rules *)s_rule,\n\t\t\t\t rule_buf_sz, 1, ice_aqc_opc_add_sw_rules,\n\t\t\t\t NULL);\n\tif (status)\n\t\tgoto err_ice_add_adv_rule;\n\tadv_fltr = devm_kzalloc(ice_hw_to_dev(hw),\n\t\t\t\tsizeof(struct ice_adv_fltr_mgmt_list_entry),\n\t\t\t\tGFP_KERNEL);\n\tif (!adv_fltr) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ice_add_adv_rule;\n\t}\n\n\tadv_fltr->lkups = devm_kmemdup(ice_hw_to_dev(hw), lkups,\n\t\t\t\t       lkups_cnt * sizeof(*lkups), GFP_KERNEL);\n\tif (!adv_fltr->lkups) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ice_add_adv_rule;\n\t}\n\n\tadv_fltr->lkups_cnt = lkups_cnt;\n\tadv_fltr->rule_info = *rinfo;\n\tadv_fltr->rule_info.fltr_rule_id = le16_to_cpu(s_rule->index);\n\tsw = hw->switch_info;\n\tsw->recp_list[rid].adv_rule = true;\n\trule_head = &sw->recp_list[rid].filt_rules;\n\n\tif (rinfo->sw_act.fltr_act == ICE_FWD_TO_VSI)\n\t\tadv_fltr->vsi_count = 1;\n\n\t \n\tlist_add(&adv_fltr->list_entry, rule_head);\n\tif (added_entry) {\n\t\tadded_entry->rid = rid;\n\t\tadded_entry->rule_id = adv_fltr->rule_info.fltr_rule_id;\n\t\tadded_entry->vsi_handle = rinfo->sw_act.vsi_handle;\n\t}\nerr_ice_add_adv_rule:\n\tif (status && adv_fltr) {\n\t\tdevm_kfree(ice_hw_to_dev(hw), adv_fltr->lkups);\n\t\tdevm_kfree(ice_hw_to_dev(hw), adv_fltr);\n\t}\n\n\tkfree(s_rule);\n\nfree_pkt_profile:\n\tif (profile->match & ICE_PKT_KMALLOC) {\n\t\tkfree(profile->offsets);\n\t\tkfree(profile->pkt);\n\t\tkfree(profile);\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_replay_vsi_fltr(struct ice_hw *hw, u16 vsi_handle, u8 recp_id,\n\t\t    struct list_head *list_head)\n{\n\tstruct ice_fltr_mgmt_list_entry *itr;\n\tint status = 0;\n\tu16 hw_vsi_id;\n\n\tif (list_empty(list_head))\n\t\treturn status;\n\thw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);\n\n\tlist_for_each_entry(itr, list_head, list_entry) {\n\t\tstruct ice_fltr_list_entry f_entry;\n\n\t\tf_entry.fltr_info = itr->fltr_info;\n\t\tif (itr->vsi_count < 2 && recp_id != ICE_SW_LKUP_VLAN &&\n\t\t    itr->fltr_info.vsi_handle == vsi_handle) {\n\t\t\t \n\t\t\tif (f_entry.fltr_info.src_id == ICE_SRC_ID_VSI)\n\t\t\t\tf_entry.fltr_info.src = hw_vsi_id;\n\t\t\tstatus = ice_add_rule_internal(hw, recp_id, &f_entry);\n\t\t\tif (status)\n\t\t\t\tgoto end;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!itr->vsi_list_info ||\n\t\t    !test_bit(vsi_handle, itr->vsi_list_info->vsi_map))\n\t\t\tcontinue;\n\t\t \n\t\tclear_bit(vsi_handle, itr->vsi_list_info->vsi_map);\n\t\tf_entry.fltr_info.vsi_handle = vsi_handle;\n\t\tf_entry.fltr_info.fltr_act = ICE_FWD_TO_VSI;\n\t\t \n\t\tif (f_entry.fltr_info.src_id == ICE_SRC_ID_VSI)\n\t\t\tf_entry.fltr_info.src = hw_vsi_id;\n\t\tif (recp_id == ICE_SW_LKUP_VLAN)\n\t\t\tstatus = ice_add_vlan_internal(hw, &f_entry);\n\t\telse\n\t\t\tstatus = ice_add_rule_internal(hw, recp_id, &f_entry);\n\t\tif (status)\n\t\t\tgoto end;\n\t}\nend:\n\treturn status;\n}\n\n \nstatic int\nice_adv_rem_update_vsi_list(struct ice_hw *hw, u16 vsi_handle,\n\t\t\t    struct ice_adv_fltr_mgmt_list_entry *fm_list)\n{\n\tstruct ice_vsi_list_map_info *vsi_list_info;\n\tenum ice_sw_lkup_type lkup_type;\n\tu16 vsi_list_id;\n\tint status;\n\n\tif (fm_list->rule_info.sw_act.fltr_act != ICE_FWD_TO_VSI_LIST ||\n\t    fm_list->vsi_count == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!test_bit(vsi_handle, fm_list->vsi_list_info->vsi_map))\n\t\treturn -ENOENT;\n\n\tlkup_type = ICE_SW_LKUP_LAST;\n\tvsi_list_id = fm_list->rule_info.sw_act.fwd_id.vsi_list_id;\n\tstatus = ice_update_vsi_list_rule(hw, &vsi_handle, 1, vsi_list_id, true,\n\t\t\t\t\t  ice_aqc_opc_update_sw_rules,\n\t\t\t\t\t  lkup_type);\n\tif (status)\n\t\treturn status;\n\n\tfm_list->vsi_count--;\n\tclear_bit(vsi_handle, fm_list->vsi_list_info->vsi_map);\n\tvsi_list_info = fm_list->vsi_list_info;\n\tif (fm_list->vsi_count == 1) {\n\t\tstruct ice_fltr_info tmp_fltr;\n\t\tu16 rem_vsi_handle;\n\n\t\trem_vsi_handle = find_first_bit(vsi_list_info->vsi_map,\n\t\t\t\t\t\tICE_MAX_VSI);\n\t\tif (!ice_is_vsi_valid(hw, rem_vsi_handle))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tstatus = ice_update_vsi_list_rule(hw, &rem_vsi_handle, 1,\n\t\t\t\t\t\t  vsi_list_id, true,\n\t\t\t\t\t\t  ice_aqc_opc_update_sw_rules,\n\t\t\t\t\t\t  lkup_type);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tmemset(&tmp_fltr, 0, sizeof(tmp_fltr));\n\t\ttmp_fltr.flag = fm_list->rule_info.sw_act.flag;\n\t\ttmp_fltr.fltr_rule_id = fm_list->rule_info.fltr_rule_id;\n\t\tfm_list->rule_info.sw_act.fltr_act = ICE_FWD_TO_VSI;\n\t\ttmp_fltr.fltr_act = ICE_FWD_TO_VSI;\n\t\ttmp_fltr.fwd_id.hw_vsi_id =\n\t\t\tice_get_hw_vsi_num(hw, rem_vsi_handle);\n\t\tfm_list->rule_info.sw_act.fwd_id.hw_vsi_id =\n\t\t\tice_get_hw_vsi_num(hw, rem_vsi_handle);\n\t\tfm_list->rule_info.sw_act.vsi_handle = rem_vsi_handle;\n\n\t\t \n\t\tstatus = ice_update_pkt_fwd_rule(hw, &tmp_fltr);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_SW, \"Failed to update pkt fwd rule to FWD_TO_VSI on HW VSI %d, error %d\\n\",\n\t\t\t\t  tmp_fltr.fwd_id.hw_vsi_id, status);\n\t\t\treturn status;\n\t\t}\n\t\tfm_list->vsi_list_info->ref_cnt--;\n\n\t\t \n\t\tstatus = ice_remove_vsi_list_rule(hw, vsi_list_id, lkup_type);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_SW, \"Failed to remove VSI list %d, error %d\\n\",\n\t\t\t\t  vsi_list_id, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tlist_del(&vsi_list_info->list_entry);\n\t\tdevm_kfree(ice_hw_to_dev(hw), vsi_list_info);\n\t\tfm_list->vsi_list_info = NULL;\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_rem_adv_rule(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups,\n\t\t u16 lkups_cnt, struct ice_adv_rule_info *rinfo)\n{\n\tstruct ice_adv_fltr_mgmt_list_entry *list_elem;\n\tstruct ice_prot_lkup_ext lkup_exts;\n\tbool remove_rule = false;\n\tstruct mutex *rule_lock;  \n\tu16 i, rid, vsi_handle;\n\tint status = 0;\n\n\tmemset(&lkup_exts, 0, sizeof(lkup_exts));\n\tfor (i = 0; i < lkups_cnt; i++) {\n\t\tu16 count;\n\n\t\tif (lkups[i].type >= ICE_PROTOCOL_LAST)\n\t\t\treturn -EIO;\n\n\t\tcount = ice_fill_valid_words(&lkups[i], &lkup_exts);\n\t\tif (!count)\n\t\t\treturn -EIO;\n\t}\n\n\trid = ice_find_recp(hw, &lkup_exts, rinfo);\n\t \n\tif (rid == ICE_MAX_NUM_RECIPES)\n\t\treturn -EINVAL;\n\n\trule_lock = &hw->switch_info->recp_list[rid].filt_rule_lock;\n\tlist_elem = ice_find_adv_rule_entry(hw, lkups, lkups_cnt, rid, rinfo);\n\t \n\tif (!list_elem)\n\t\treturn 0;\n\tmutex_lock(rule_lock);\n\tif (list_elem->rule_info.sw_act.fltr_act != ICE_FWD_TO_VSI_LIST) {\n\t\tremove_rule = true;\n\t} else if (list_elem->vsi_count > 1) {\n\t\tremove_rule = false;\n\t\tvsi_handle = rinfo->sw_act.vsi_handle;\n\t\tstatus = ice_adv_rem_update_vsi_list(hw, vsi_handle, list_elem);\n\t} else {\n\t\tvsi_handle = rinfo->sw_act.vsi_handle;\n\t\tstatus = ice_adv_rem_update_vsi_list(hw, vsi_handle, list_elem);\n\t\tif (status) {\n\t\t\tmutex_unlock(rule_lock);\n\t\t\treturn status;\n\t\t}\n\t\tif (list_elem->vsi_count == 0)\n\t\t\tremove_rule = true;\n\t}\n\tmutex_unlock(rule_lock);\n\tif (remove_rule) {\n\t\tstruct ice_sw_rule_lkup_rx_tx *s_rule;\n\t\tu16 rule_buf_sz;\n\n\t\trule_buf_sz = ICE_SW_RULE_RX_TX_NO_HDR_SIZE(s_rule);\n\t\ts_rule = kzalloc(rule_buf_sz, GFP_KERNEL);\n\t\tif (!s_rule)\n\t\t\treturn -ENOMEM;\n\t\ts_rule->act = 0;\n\t\ts_rule->index = cpu_to_le16(list_elem->rule_info.fltr_rule_id);\n\t\ts_rule->hdr_len = 0;\n\t\tstatus = ice_aq_sw_rules(hw, (struct ice_aqc_sw_rules *)s_rule,\n\t\t\t\t\t rule_buf_sz, 1,\n\t\t\t\t\t ice_aqc_opc_remove_sw_rules, NULL);\n\t\tif (!status || status == -ENOENT) {\n\t\t\tstruct ice_switch_info *sw = hw->switch_info;\n\n\t\t\tmutex_lock(rule_lock);\n\t\t\tlist_del(&list_elem->list_entry);\n\t\t\tdevm_kfree(ice_hw_to_dev(hw), list_elem->lkups);\n\t\t\tdevm_kfree(ice_hw_to_dev(hw), list_elem);\n\t\t\tmutex_unlock(rule_lock);\n\t\t\tif (list_empty(&sw->recp_list[rid].filt_rules))\n\t\t\t\tsw->recp_list[rid].adv_rule = false;\n\t\t}\n\t\tkfree(s_rule);\n\t}\n\treturn status;\n}\n\n \nint\nice_rem_adv_rule_by_id(struct ice_hw *hw,\n\t\t       struct ice_rule_query_data *remove_entry)\n{\n\tstruct ice_adv_fltr_mgmt_list_entry *list_itr;\n\tstruct list_head *list_head;\n\tstruct ice_adv_rule_info rinfo;\n\tstruct ice_switch_info *sw;\n\n\tsw = hw->switch_info;\n\tif (!sw->recp_list[remove_entry->rid].recp_created)\n\t\treturn -EINVAL;\n\tlist_head = &sw->recp_list[remove_entry->rid].filt_rules;\n\tlist_for_each_entry(list_itr, list_head, list_entry) {\n\t\tif (list_itr->rule_info.fltr_rule_id ==\n\t\t    remove_entry->rule_id) {\n\t\t\trinfo = list_itr->rule_info;\n\t\t\trinfo.sw_act.vsi_handle = remove_entry->vsi_handle;\n\t\t\treturn ice_rem_adv_rule(hw, list_itr->lkups,\n\t\t\t\t\t\tlist_itr->lkups_cnt, &rinfo);\n\t\t}\n\t}\n\t \n\treturn -ENOENT;\n}\n\n \nstatic int\nice_replay_vsi_adv_rule(struct ice_hw *hw, u16 vsi_handle,\n\t\t\tstruct list_head *list_head)\n{\n\tstruct ice_rule_query_data added_entry = { 0 };\n\tstruct ice_adv_fltr_mgmt_list_entry *adv_fltr;\n\tint status = 0;\n\n\tif (list_empty(list_head))\n\t\treturn status;\n\tlist_for_each_entry(adv_fltr, list_head, list_entry) {\n\t\tstruct ice_adv_rule_info *rinfo = &adv_fltr->rule_info;\n\t\tu16 lk_cnt = adv_fltr->lkups_cnt;\n\n\t\tif (vsi_handle != rinfo->sw_act.vsi_handle)\n\t\t\tcontinue;\n\t\tstatus = ice_add_adv_rule(hw, adv_fltr->lkups, lk_cnt, rinfo,\n\t\t\t\t\t  &added_entry);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\treturn status;\n}\n\n \nint ice_replay_vsi_all_fltr(struct ice_hw *hw, u16 vsi_handle)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tint status;\n\tu8 i;\n\n\tfor (i = 0; i < ICE_MAX_NUM_RECIPES; i++) {\n\t\tstruct list_head *head;\n\n\t\thead = &sw->recp_list[i].filt_replay_rules;\n\t\tif (!sw->recp_list[i].adv_rule)\n\t\t\tstatus = ice_replay_vsi_fltr(hw, vsi_handle, i, head);\n\t\telse\n\t\t\tstatus = ice_replay_vsi_adv_rule(hw, vsi_handle, head);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn status;\n}\n\n \nvoid ice_rm_all_sw_replay_rule_info(struct ice_hw *hw)\n{\n\tstruct ice_switch_info *sw = hw->switch_info;\n\tu8 i;\n\n\tif (!sw)\n\t\treturn;\n\n\tfor (i = 0; i < ICE_MAX_NUM_RECIPES; i++) {\n\t\tif (!list_empty(&sw->recp_list[i].filt_replay_rules)) {\n\t\t\tstruct list_head *l_head;\n\n\t\t\tl_head = &sw->recp_list[i].filt_replay_rules;\n\t\t\tif (!sw->recp_list[i].adv_rule)\n\t\t\t\tice_rem_sw_rule_info(hw, l_head);\n\t\t\telse\n\t\t\t\tice_rem_adv_rule_info(hw, l_head);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}