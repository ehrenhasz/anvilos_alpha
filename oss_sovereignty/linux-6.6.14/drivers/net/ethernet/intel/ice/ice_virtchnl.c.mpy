{
  "module_name": "ice_virtchnl.c",
  "hash_id": "b059cc677bb5511ad9202207398badef7389890963b56b8069dc7cd6305a09cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_virtchnl.c",
  "human_readable_source": "\n \n\n#include \"ice_virtchnl.h\"\n#include \"ice_vf_lib_private.h\"\n#include \"ice.h\"\n#include \"ice_base.h\"\n#include \"ice_lib.h\"\n#include \"ice_fltr.h\"\n#include \"ice_virtchnl_allowlist.h\"\n#include \"ice_vf_vsi_vlan_ops.h\"\n#include \"ice_vlan.h\"\n#include \"ice_flex_pipe.h\"\n#include \"ice_dcb_lib.h\"\n\n#define FIELD_SELECTOR(proto_hdr_field) \\\n\t\tBIT((proto_hdr_field) & PROTO_HDR_FIELD_MASK)\n\nstruct ice_vc_hdr_match_type {\n\tu32 vc_hdr;\t \n\tu32 ice_hdr;\t \n};\n\nstatic const struct ice_vc_hdr_match_type ice_vc_hdr_list[] = {\n\t{VIRTCHNL_PROTO_HDR_NONE,\tICE_FLOW_SEG_HDR_NONE},\n\t{VIRTCHNL_PROTO_HDR_ETH,\tICE_FLOW_SEG_HDR_ETH},\n\t{VIRTCHNL_PROTO_HDR_S_VLAN,\tICE_FLOW_SEG_HDR_VLAN},\n\t{VIRTCHNL_PROTO_HDR_C_VLAN,\tICE_FLOW_SEG_HDR_VLAN},\n\t{VIRTCHNL_PROTO_HDR_IPV4,\tICE_FLOW_SEG_HDR_IPV4 |\n\t\t\t\t\tICE_FLOW_SEG_HDR_IPV_OTHER},\n\t{VIRTCHNL_PROTO_HDR_IPV6,\tICE_FLOW_SEG_HDR_IPV6 |\n\t\t\t\t\tICE_FLOW_SEG_HDR_IPV_OTHER},\n\t{VIRTCHNL_PROTO_HDR_TCP,\tICE_FLOW_SEG_HDR_TCP},\n\t{VIRTCHNL_PROTO_HDR_UDP,\tICE_FLOW_SEG_HDR_UDP},\n\t{VIRTCHNL_PROTO_HDR_SCTP,\tICE_FLOW_SEG_HDR_SCTP},\n\t{VIRTCHNL_PROTO_HDR_PPPOE,\tICE_FLOW_SEG_HDR_PPPOE},\n\t{VIRTCHNL_PROTO_HDR_GTPU_IP,\tICE_FLOW_SEG_HDR_GTPU_IP},\n\t{VIRTCHNL_PROTO_HDR_GTPU_EH,\tICE_FLOW_SEG_HDR_GTPU_EH},\n\t{VIRTCHNL_PROTO_HDR_GTPU_EH_PDU_DWN,\n\t\t\t\t\tICE_FLOW_SEG_HDR_GTPU_DWN},\n\t{VIRTCHNL_PROTO_HDR_GTPU_EH_PDU_UP,\n\t\t\t\t\tICE_FLOW_SEG_HDR_GTPU_UP},\n\t{VIRTCHNL_PROTO_HDR_L2TPV3,\tICE_FLOW_SEG_HDR_L2TPV3},\n\t{VIRTCHNL_PROTO_HDR_ESP,\tICE_FLOW_SEG_HDR_ESP},\n\t{VIRTCHNL_PROTO_HDR_AH,\t\tICE_FLOW_SEG_HDR_AH},\n\t{VIRTCHNL_PROTO_HDR_PFCP,\tICE_FLOW_SEG_HDR_PFCP_SESSION},\n};\n\nstruct ice_vc_hash_field_match_type {\n\tu32 vc_hdr;\t\t \n\tu32 vc_hash_field;\t \n\tu64 ice_hash_field;\t \n};\n\nstatic const struct\nice_vc_hash_field_match_type ice_vc_hash_field_list[] = {\n\t{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_SRC),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_ETH_SA)},\n\t{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_DST),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_ETH_DA)},\n\t{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_SRC) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_DST),\n\t\tICE_FLOW_HASH_ETH},\n\t{VIRTCHNL_PROTO_HDR_ETH,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_ETHERTYPE),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_ETH_TYPE)},\n\t{VIRTCHNL_PROTO_HDR_S_VLAN,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_S_VLAN_ID),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_S_VLAN)},\n\t{VIRTCHNL_PROTO_HDR_C_VLAN,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_C_VLAN_ID),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_C_VLAN)},\n\t{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_SA)},\n\t{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_DA)},\n\t{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST),\n\t\tICE_FLOW_HASH_IPV4},\n\t{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_SA) |\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},\n\t{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_DA) |\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},\n\t{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),\n\t\tICE_FLOW_HASH_IPV4 | BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},\n\t{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},\n\t{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_SA)},\n\t{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_DA)},\n\t{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST),\n\t\tICE_FLOW_HASH_IPV6},\n\t{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_SA) |\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},\n\t{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_DA) |\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},\n\t{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),\n\t\tICE_FLOW_HASH_IPV6 | BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},\n\t{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},\n\t{VIRTCHNL_PROTO_HDR_TCP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_SRC_PORT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_TCP_SRC_PORT)},\n\t{VIRTCHNL_PROTO_HDR_TCP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_DST_PORT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_TCP_DST_PORT)},\n\t{VIRTCHNL_PROTO_HDR_TCP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_SRC_PORT) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_DST_PORT),\n\t\tICE_FLOW_HASH_TCP_PORT},\n\t{VIRTCHNL_PROTO_HDR_UDP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_SRC_PORT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_UDP_SRC_PORT)},\n\t{VIRTCHNL_PROTO_HDR_UDP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_DST_PORT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_UDP_DST_PORT)},\n\t{VIRTCHNL_PROTO_HDR_UDP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_SRC_PORT) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_DST_PORT),\n\t\tICE_FLOW_HASH_UDP_PORT},\n\t{VIRTCHNL_PROTO_HDR_SCTP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_SRC_PORT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_SRC_PORT)},\n\t{VIRTCHNL_PROTO_HDR_SCTP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_DST_PORT),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_DST_PORT)},\n\t{VIRTCHNL_PROTO_HDR_SCTP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_SRC_PORT) |\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_DST_PORT),\n\t\tICE_FLOW_HASH_SCTP_PORT},\n\t{VIRTCHNL_PROTO_HDR_PPPOE,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_PPPOE_SESS_ID),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_PPPOE_SESS_ID)},\n\t{VIRTCHNL_PROTO_HDR_GTPU_IP,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_GTPU_IP_TEID),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_GTPU_IP_TEID)},\n\t{VIRTCHNL_PROTO_HDR_L2TPV3,\n\t\tFIELD_SELECTOR(VIRTCHNL_PROTO_HDR_L2TPV3_SESS_ID),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_L2TPV3_SESS_ID)},\n\t{VIRTCHNL_PROTO_HDR_ESP, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ESP_SPI),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_ESP_SPI)},\n\t{VIRTCHNL_PROTO_HDR_AH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_AH_SPI),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_AH_SPI)},\n\t{VIRTCHNL_PROTO_HDR_PFCP, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_PFCP_SEID),\n\t\tBIT_ULL(ICE_FLOW_FIELD_IDX_PFCP_SEID)},\n};\n\n \nstatic void\nice_vc_vf_broadcast(struct ice_pf *pf, enum virtchnl_ops v_opcode,\n\t\t    enum virtchnl_status_code v_retval, u8 *msg, u16 msglen)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tmutex_lock(&pf->vfs.table_lock);\n\tice_for_each_vf(pf, bkt, vf) {\n\t\t \n\t\tif (!test_bit(ICE_VF_STATE_INIT, vf->vf_states) &&\n\t\t    !test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states))\n\t\t\tcontinue;\n\n\t\t \n\t\tice_aq_send_msg_to_vf(hw, vf->vf_id, v_opcode, v_retval, msg,\n\t\t\t\t      msglen, NULL);\n\t}\n\tmutex_unlock(&pf->vfs.table_lock);\n}\n\n \nstatic void\nice_set_pfe_link(struct ice_vf *vf, struct virtchnl_pf_event *pfe,\n\t\t int ice_link_speed, bool link_up)\n{\n\tif (vf->driver_caps & VIRTCHNL_VF_CAP_ADV_LINK_SPEED) {\n\t\tpfe->event_data.link_event_adv.link_status = link_up;\n\t\t \n\t\tpfe->event_data.link_event_adv.link_speed =\n\t\t\tice_conv_link_speed_to_virtchnl(true, ice_link_speed);\n\t} else {\n\t\tpfe->event_data.link_event.link_status = link_up;\n\t\t \n\t\tpfe->event_data.link_event.link_speed =\n\t\t\t(enum virtchnl_link_speed)\n\t\t\tice_conv_link_speed_to_virtchnl(false, ice_link_speed);\n\t}\n}\n\n \nvoid ice_vc_notify_vf_link_state(struct ice_vf *vf)\n{\n\tstruct virtchnl_pf_event pfe = { 0 };\n\tstruct ice_hw *hw = &vf->pf->hw;\n\n\tpfe.event = VIRTCHNL_EVENT_LINK_CHANGE;\n\tpfe.severity = PF_EVENT_SEVERITY_INFO;\n\n\tif (ice_is_vf_link_up(vf))\n\t\tice_set_pfe_link(vf, &pfe,\n\t\t\t\t hw->port_info->phy.link_info.link_speed, true);\n\telse\n\t\tice_set_pfe_link(vf, &pfe, ICE_AQ_LINK_SPEED_UNKNOWN, false);\n\n\tice_aq_send_msg_to_vf(hw, vf->vf_id, VIRTCHNL_OP_EVENT,\n\t\t\t      VIRTCHNL_STATUS_SUCCESS, (u8 *)&pfe,\n\t\t\t      sizeof(pfe), NULL);\n}\n\n \nvoid ice_vc_notify_link_state(struct ice_pf *pf)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tmutex_lock(&pf->vfs.table_lock);\n\tice_for_each_vf(pf, bkt, vf)\n\t\tice_vc_notify_vf_link_state(vf);\n\tmutex_unlock(&pf->vfs.table_lock);\n}\n\n \nvoid ice_vc_notify_reset(struct ice_pf *pf)\n{\n\tstruct virtchnl_pf_event pfe;\n\n\tif (!ice_has_vfs(pf))\n\t\treturn;\n\n\tpfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;\n\tpfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;\n\tice_vc_vf_broadcast(pf, VIRTCHNL_OP_EVENT, VIRTCHNL_STATUS_SUCCESS,\n\t\t\t    (u8 *)&pfe, sizeof(struct virtchnl_pf_event));\n}\n\n \nint\nice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,\n\t\t      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen)\n{\n\tstruct device *dev;\n\tstruct ice_pf *pf;\n\tint aq_ret;\n\n\tpf = vf->pf;\n\tdev = ice_pf_to_dev(pf);\n\n\taq_ret = ice_aq_send_msg_to_vf(&pf->hw, vf->vf_id, v_opcode, v_retval,\n\t\t\t\t       msg, msglen, NULL);\n\tif (aq_ret && pf->hw.mailboxq.sq_last_status != ICE_AQ_RC_ENOSYS) {\n\t\tdev_info(dev, \"Unable to send the message to VF %d ret %d aq_err %s\\n\",\n\t\t\t vf->vf_id, aq_ret,\n\t\t\t ice_aq_str(pf->hw.mailboxq.sq_last_status));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_vc_get_ver_msg(struct ice_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_version_info info = {\n\t\tVIRTCHNL_VERSION_MAJOR, VIRTCHNL_VERSION_MINOR\n\t};\n\n\tvf->vf_ver = *(struct virtchnl_version_info *)msg;\n\t \n\tif (VF_IS_V10(&vf->vf_ver))\n\t\tinfo.minor = VIRTCHNL_VERSION_MINOR_NO_VF_CAPS;\n\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_VERSION,\n\t\t\t\t     VIRTCHNL_STATUS_SUCCESS, (u8 *)&info,\n\t\t\t\t     sizeof(struct virtchnl_version_info));\n}\n\n \nstatic u16 ice_vc_get_max_frame_size(struct ice_vf *vf)\n{\n\tstruct ice_port_info *pi = ice_vf_get_port_info(vf);\n\tu16 max_frame_size;\n\n\tmax_frame_size = pi->phy.link_info.max_frame_size;\n\n\tif (ice_vf_is_port_vlan_ena(vf))\n\t\tmax_frame_size -= VLAN_HLEN;\n\n\treturn max_frame_size;\n}\n\n \nstatic u32\nice_vc_get_vlan_caps(struct ice_hw *hw, struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t     u32 driver_caps)\n{\n\tif (ice_is_eswitch_mode_switchdev(vf->pf))\n\t\t \n\t\treturn 0;\n\n\tif (driver_caps & VIRTCHNL_VF_OFFLOAD_VLAN_V2) {\n\t\t \n\t\treturn VIRTCHNL_VF_OFFLOAD_VLAN_V2;\n\t} else if (driver_caps & VIRTCHNL_VF_OFFLOAD_VLAN) {\n\t\t \n\t\tif (ice_is_dvm_ena(hw) && ice_vf_is_port_vlan_ena(vf)) {\n\t\t\treturn VIRTCHNL_VF_OFFLOAD_VLAN;\n\t\t} else if (!ice_is_dvm_ena(hw) &&\n\t\t\t   !ice_vf_is_port_vlan_ena(vf)) {\n\t\t\t \n\t\t\tice_vf_vsi_cfg_svm_legacy_vlan_mode(vsi);\n\t\t\treturn VIRTCHNL_VF_OFFLOAD_VLAN;\n\t\t} else if (ice_is_dvm_ena(hw)) {\n\t\t\t \n\t\t\tice_vf_vsi_cfg_dvm_legacy_vlan_mode(vsi);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_vc_get_vf_res_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vf_resource *vfres = NULL;\n\tstruct ice_hw *hw = &vf->pf->hw;\n\tstruct ice_vsi *vsi;\n\tint len = 0;\n\tint ret;\n\n\tif (ice_check_vf_init(vf)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tlen = virtchnl_struct_size(vfres, vsi_res, 0);\n\n\tvfres = kzalloc(len, GFP_KERNEL);\n\tif (!vfres) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;\n\t\tlen = 0;\n\t\tgoto err;\n\t}\n\tif (VF_IS_V11(&vf->vf_ver))\n\t\tvf->driver_caps = *(u32 *)msg;\n\telse\n\t\tvf->driver_caps = VIRTCHNL_VF_OFFLOAD_L2 |\n\t\t\t\t  VIRTCHNL_VF_OFFLOAD_RSS_REG |\n\t\t\t\t  VIRTCHNL_VF_OFFLOAD_VLAN;\n\n\tvfres->vf_cap_flags = VIRTCHNL_VF_OFFLOAD_L2;\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tvfres->vf_cap_flags |= ice_vc_get_vlan_caps(hw, vf, vsi,\n\t\t\t\t\t\t    vf->driver_caps);\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PF) {\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_PF;\n\t} else {\n\t\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_AQ)\n\t\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_AQ;\n\t\telse\n\t\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_REG;\n\t}\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_FLEX_DESC)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RX_FLEX_DESC;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_FDIR_PF)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_FDIR_PF;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_POLLING)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RX_POLLING;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_WB_ON_ITR;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_REQ_QUEUES)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_REQ_QUEUES;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_CAP_ADV_LINK_SPEED)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_CAP_ADV_LINK_SPEED;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF;\n\n\tif (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_USO)\n\t\tvfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_USO;\n\n\tvfres->num_vsis = 1;\n\t \n\tvfres->num_queue_pairs = vsi->num_txq;\n\tvfres->max_vectors = vf->pf->vfs.num_msix_per;\n\tvfres->rss_key_size = ICE_VSIQF_HKEY_ARRAY_SIZE;\n\tvfres->rss_lut_size = ICE_LUT_VSI_SIZE;\n\tvfres->max_mtu = ice_vc_get_max_frame_size(vf);\n\n\tvfres->vsi_res[0].vsi_id = vf->lan_vsi_num;\n\tvfres->vsi_res[0].vsi_type = VIRTCHNL_VSI_SRIOV;\n\tvfres->vsi_res[0].num_queue_pairs = vsi->num_txq;\n\tether_addr_copy(vfres->vsi_res[0].default_mac_addr,\n\t\t\tvf->hw_lan_addr);\n\n\t \n\tvf->driver_caps = vfres->vf_cap_flags;\n\n\tice_vc_set_caps_allowlist(vf);\n\tice_vc_set_working_allowlist(vf);\n\n\tset_bit(ICE_VF_STATE_ACTIVE, vf->vf_states);\n\nerr:\n\t \n\tret = ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_VF_RESOURCES, v_ret,\n\t\t\t\t    (u8 *)vfres, len);\n\n\tkfree(vfres);\n\treturn ret;\n}\n\n \nstatic void ice_vc_reset_vf_msg(struct ice_vf *vf)\n{\n\tif (test_bit(ICE_VF_STATE_INIT, vf->vf_states))\n\t\tice_reset_vf(vf, 0);\n}\n\n \nbool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id)\n{\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_vsi *vsi;\n\n\tvsi = ice_find_vsi(pf, vsi_id);\n\n\treturn (vsi && (vsi->vf == vf));\n}\n\n \nstatic bool ice_vc_isvalid_q_id(struct ice_vf *vf, u16 vsi_id, u8 qid)\n{\n\tstruct ice_vsi *vsi = ice_find_vsi(vf->pf, vsi_id);\n\t \n\treturn (vsi && (qid < vsi->alloc_txq));\n}\n\n \nstatic bool ice_vc_isvalid_ring_len(u16 ring_len)\n{\n\treturn ring_len == 0 ||\n\t       (ring_len >= ICE_MIN_NUM_DESC &&\n\t\tring_len <= ICE_MAX_NUM_DESC &&\n\t\t!(ring_len % ICE_REQ_DESC_MULTIPLE));\n}\n\n \nbool\nice_vc_validate_pattern(struct ice_vf *vf, struct virtchnl_proto_hdrs *proto)\n{\n\tbool is_ipv4 = false;\n\tbool is_ipv6 = false;\n\tbool is_udp = false;\n\tu16 ptype = -1;\n\tint i = 0;\n\n\twhile (i < proto->count &&\n\t       proto->proto_hdr[i].type != VIRTCHNL_PROTO_HDR_NONE) {\n\t\tswitch (proto->proto_hdr[i].type) {\n\t\tcase VIRTCHNL_PROTO_HDR_ETH:\n\t\t\tptype = ICE_PTYPE_MAC_PAY;\n\t\t\tbreak;\n\t\tcase VIRTCHNL_PROTO_HDR_IPV4:\n\t\t\tptype = ICE_PTYPE_IPV4_PAY;\n\t\t\tis_ipv4 = true;\n\t\t\tbreak;\n\t\tcase VIRTCHNL_PROTO_HDR_IPV6:\n\t\t\tptype = ICE_PTYPE_IPV6_PAY;\n\t\t\tis_ipv6 = true;\n\t\t\tbreak;\n\t\tcase VIRTCHNL_PROTO_HDR_UDP:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = ICE_PTYPE_IPV4_UDP_PAY;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = ICE_PTYPE_IPV6_UDP_PAY;\n\t\t\tis_udp = true;\n\t\t\tbreak;\n\t\tcase VIRTCHNL_PROTO_HDR_TCP:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = ICE_PTYPE_IPV4_TCP_PAY;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = ICE_PTYPE_IPV6_TCP_PAY;\n\t\t\tbreak;\n\t\tcase VIRTCHNL_PROTO_HDR_SCTP:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = ICE_PTYPE_IPV4_SCTP_PAY;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = ICE_PTYPE_IPV6_SCTP_PAY;\n\t\t\tbreak;\n\t\tcase VIRTCHNL_PROTO_HDR_GTPU_IP:\n\t\tcase VIRTCHNL_PROTO_HDR_GTPU_EH:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = ICE_MAC_IPV4_GTPU;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = ICE_MAC_IPV6_GTPU;\n\t\t\tgoto out;\n\t\tcase VIRTCHNL_PROTO_HDR_L2TPV3:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = ICE_MAC_IPV4_L2TPV3;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = ICE_MAC_IPV6_L2TPV3;\n\t\t\tgoto out;\n\t\tcase VIRTCHNL_PROTO_HDR_ESP:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = is_udp ? ICE_MAC_IPV4_NAT_T_ESP :\n\t\t\t\t\t\tICE_MAC_IPV4_ESP;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = is_udp ? ICE_MAC_IPV6_NAT_T_ESP :\n\t\t\t\t\t\tICE_MAC_IPV6_ESP;\n\t\t\tgoto out;\n\t\tcase VIRTCHNL_PROTO_HDR_AH:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = ICE_MAC_IPV4_AH;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = ICE_MAC_IPV6_AH;\n\t\t\tgoto out;\n\t\tcase VIRTCHNL_PROTO_HDR_PFCP:\n\t\t\tif (is_ipv4)\n\t\t\t\tptype = ICE_MAC_IPV4_PFCP_SESSION;\n\t\t\telse if (is_ipv6)\n\t\t\t\tptype = ICE_MAC_IPV6_PFCP_SESSION;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\nout:\n\treturn ice_hw_ptype_ena(&vf->pf->hw, ptype);\n}\n\n \nstatic bool\nice_vc_parse_rss_cfg(struct ice_hw *hw, struct virtchnl_rss_cfg *rss_cfg,\n\t\t     u32 *addl_hdrs, u64 *hash_flds)\n{\n\tconst struct ice_vc_hash_field_match_type *hf_list;\n\tconst struct ice_vc_hdr_match_type *hdr_list;\n\tint i, hf_list_len, hdr_list_len;\n\n\thf_list = ice_vc_hash_field_list;\n\thf_list_len = ARRAY_SIZE(ice_vc_hash_field_list);\n\thdr_list = ice_vc_hdr_list;\n\thdr_list_len = ARRAY_SIZE(ice_vc_hdr_list);\n\n\tfor (i = 0; i < rss_cfg->proto_hdrs.count; i++) {\n\t\tstruct virtchnl_proto_hdr *proto_hdr =\n\t\t\t\t\t&rss_cfg->proto_hdrs.proto_hdr[i];\n\t\tbool hdr_found = false;\n\t\tint j;\n\n\t\t \n\t\tfor (j = 0; j < hdr_list_len; j++) {\n\t\t\tstruct ice_vc_hdr_match_type hdr_map = hdr_list[j];\n\n\t\t\tif (proto_hdr->type == hdr_map.vc_hdr) {\n\t\t\t\t*addl_hdrs |= hdr_map.ice_hdr;\n\t\t\t\thdr_found = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!hdr_found)\n\t\t\treturn false;\n\n\t\t \n\t\tfor (j = 0; j < hf_list_len; j++) {\n\t\t\tstruct ice_vc_hash_field_match_type hf_map = hf_list[j];\n\n\t\t\tif (proto_hdr->type == hf_map.vc_hdr &&\n\t\t\t    proto_hdr->field_selector == hf_map.vc_hash_field) {\n\t\t\t\t*hash_flds |= hf_map.ice_hash_field;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic bool ice_vf_adv_rss_offload_ena(u32 caps)\n{\n\treturn !!(caps & VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF);\n}\n\n \nstatic int ice_vc_handle_rss_cfg(struct ice_vf *vf, u8 *msg, bool add)\n{\n\tu32 v_opcode = add ? VIRTCHNL_OP_ADD_RSS_CFG : VIRTCHNL_OP_DEL_RSS_CFG;\n\tstruct virtchnl_rss_cfg *rss_cfg = (struct virtchnl_rss_cfg *)msg;\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct device *dev = ice_pf_to_dev(vf->pf);\n\tstruct ice_hw *hw = &vf->pf->hw;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {\n\t\tdev_dbg(dev, \"VF %d attempting to configure RSS, but RSS is not supported by the PF\\n\",\n\t\t\tvf->vf_id);\n\t\tv_ret = VIRTCHNL_STATUS_ERR_NOT_SUPPORTED;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vf_adv_rss_offload_ena(vf->driver_caps)) {\n\t\tdev_dbg(dev, \"VF %d attempting to configure RSS, but Advanced RSS offload is not supported\\n\",\n\t\t\tvf->vf_id);\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (rss_cfg->proto_hdrs.count > VIRTCHNL_MAX_NUM_PROTO_HDRS ||\n\t    rss_cfg->rss_algorithm < VIRTCHNL_RSS_ALG_TOEPLITZ_ASYMMETRIC ||\n\t    rss_cfg->rss_algorithm > VIRTCHNL_RSS_ALG_XOR_SYMMETRIC) {\n\t\tdev_dbg(dev, \"VF %d attempting to configure RSS, but RSS configuration is not valid\\n\",\n\t\t\tvf->vf_id);\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_validate_pattern(vf, &rss_cfg->proto_hdrs)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (rss_cfg->rss_algorithm == VIRTCHNL_RSS_ALG_R_ASYMMETRIC) {\n\t\tstruct ice_vsi_ctx *ctx;\n\t\tu8 lut_type, hash_type;\n\t\tint status;\n\n\t\tlut_type = ICE_AQ_VSI_Q_OPT_RSS_LUT_VSI;\n\t\thash_type = add ? ICE_AQ_VSI_Q_OPT_RSS_XOR :\n\t\t\t\tICE_AQ_VSI_Q_OPT_RSS_TPLZ;\n\n\t\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\t\tif (!ctx) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\tctx->info.q_opt_rss = ((lut_type <<\n\t\t\t\t\tICE_AQ_VSI_Q_OPT_RSS_LUT_S) &\n\t\t\t\t       ICE_AQ_VSI_Q_OPT_RSS_LUT_M) |\n\t\t\t\t       (hash_type &\n\t\t\t\t\tICE_AQ_VSI_Q_OPT_RSS_HASH_M);\n\n\t\t \n\t\tctx->info.q_opt_rss |= (vsi->info.q_opt_rss &\n\t\t\t\t\t  ICE_AQ_VSI_Q_OPT_RSS_GBL_LUT_M);\n\t\tctx->info.q_opt_tc = vsi->info.q_opt_tc;\n\t\tctx->info.q_opt_flags = vsi->info.q_opt_rss;\n\n\t\tctx->info.valid_sections =\n\t\t\t\tcpu_to_le16(ICE_AQ_VSI_PROP_Q_OPT_VALID);\n\n\t\tstatus = ice_update_vsi(hw, vsi->idx, ctx, NULL);\n\t\tif (status) {\n\t\t\tdev_err(dev, \"update VSI for RSS failed, err %d aq_err %s\\n\",\n\t\t\t\tstatus, ice_aq_str(hw->adminq.sq_last_status));\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t} else {\n\t\t\tvsi->info.q_opt_rss = ctx->info.q_opt_rss;\n\t\t}\n\n\t\tkfree(ctx);\n\t} else {\n\t\tu32 addl_hdrs = ICE_FLOW_SEG_HDR_NONE;\n\t\tu64 hash_flds = ICE_HASH_INVALID;\n\n\t\tif (!ice_vc_parse_rss_cfg(hw, rss_cfg, &addl_hdrs,\n\t\t\t\t\t  &hash_flds)) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\tif (add) {\n\t\t\tif (ice_add_rss_cfg(hw, vsi->idx, hash_flds,\n\t\t\t\t\t    addl_hdrs)) {\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tdev_err(dev, \"ice_add_rss_cfg failed for vsi = %d, v_ret = %d\\n\",\n\t\t\t\t\tvsi->vsi_num, v_ret);\n\t\t\t}\n\t\t} else {\n\t\t\tint status;\n\n\t\t\tstatus = ice_rem_rss_cfg(hw, vsi->idx, hash_flds,\n\t\t\t\t\t\t addl_hdrs);\n\t\t\t \n\t\t\tif (status && status != -ENOENT) {\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tdev_err(dev, \"ice_rem_rss_cfg failed for VF ID:%d, error:%d\\n\",\n\t\t\t\t\tvf->vf_id, status);\n\t\t\t}\n\t\t}\n\t}\n\nerror_param:\n\treturn ice_vc_send_msg_to_vf(vf, v_opcode, v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_config_rss_key(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_rss_key *vrk =\n\t\t(struct virtchnl_rss_key *)msg;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vrk->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (vrk->key_len != ICE_VSIQF_HKEY_ARRAY_SIZE) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (ice_set_rss_key(vsi, vrk->key))\n\t\tv_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;\nerror_param:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_KEY, v_ret,\n\t\t\t\t     NULL, 0);\n}\n\n \nstatic int ice_vc_config_rss_lut(struct ice_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vrl->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (vrl->lut_entries != ICE_LUT_VSI_SIZE) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (ice_set_rss_lut(vsi, vrl->lut, ICE_LUT_VSI_SIZE))\n\t\tv_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;\nerror_param:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_LUT, v_ret,\n\t\t\t\t     NULL, 0);\n}\n\n \nstatic int ice_vc_cfg_promiscuous_mode_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tbool rm_promisc, alluni = false, allmulti = false;\n\tstruct virtchnl_promisc_info *info =\n\t    (struct virtchnl_promisc_info *)msg;\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\tint mcast_err = 0, ucast_err = 0;\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_vsi *vsi;\n\tu8 mcast_m, ucast_m;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, info->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tdev = ice_pf_to_dev(pf);\n\tif (!ice_is_vf_trusted(vf)) {\n\t\tdev_err(dev, \"Unprivileged VF %d is attempting to configure promiscuous mode\\n\",\n\t\t\tvf->vf_id);\n\t\t \n\t\tgoto error_param;\n\t}\n\n\tif (info->flags & FLAG_VF_UNICAST_PROMISC)\n\t\talluni = true;\n\n\tif (info->flags & FLAG_VF_MULTICAST_PROMISC)\n\t\tallmulti = true;\n\n\trm_promisc = !allmulti && !alluni;\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(vsi);\n\tif (rm_promisc)\n\t\tret = vlan_ops->ena_rx_filtering(vsi);\n\telse\n\t\tret = vlan_ops->dis_rx_filtering(vsi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to configure VLAN pruning in promiscuous mode\\n\");\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tice_vf_get_promisc_masks(vf, vsi, &ucast_m, &mcast_m);\n\n\tif (!test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags)) {\n\t\tif (alluni) {\n\t\t\t \n\t\t\tret = ice_set_dflt_vsi(vsi);\n\t\t} else {\n\t\t\t \n\t\t\tif (ice_is_dflt_vsi_in_use(vsi->port_info))\n\t\t\t\tret = ice_clear_dflt_vsi(vsi);\n\t\t}\n\n\t\t \n\t\tif (allmulti)\n\t\t\tmcast_err = ice_vf_set_vsi_promisc(vf, vsi, mcast_m);\n\t\telse\n\t\t\tmcast_err = ice_vf_clear_vsi_promisc(vf, vsi, mcast_m);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Turning on/off promiscuous mode for VF %d failed, error: %d\\n\",\n\t\t\t\tvf->vf_id, ret);\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;\n\t\t\tgoto error_param;\n\t\t}\n\t} else {\n\t\tif (alluni)\n\t\t\tucast_err = ice_vf_set_vsi_promisc(vf, vsi, ucast_m);\n\t\telse\n\t\t\tucast_err = ice_vf_clear_vsi_promisc(vf, vsi, ucast_m);\n\n\t\tif (allmulti)\n\t\t\tmcast_err = ice_vf_set_vsi_promisc(vf, vsi, mcast_m);\n\t\telse\n\t\t\tmcast_err = ice_vf_clear_vsi_promisc(vf, vsi, mcast_m);\n\n\t\tif (ucast_err || mcast_err)\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t}\n\n\tif (!mcast_err) {\n\t\tif (allmulti &&\n\t\t    !test_and_set_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))\n\t\t\tdev_info(dev, \"VF %u successfully set multicast promiscuous mode\\n\",\n\t\t\t\t vf->vf_id);\n\t\telse if (!allmulti &&\n\t\t\t test_and_clear_bit(ICE_VF_STATE_MC_PROMISC,\n\t\t\t\t\t    vf->vf_states))\n\t\t\tdev_info(dev, \"VF %u successfully unset multicast promiscuous mode\\n\",\n\t\t\t\t vf->vf_id);\n\t} else {\n\t\tdev_err(dev, \"Error while modifying multicast promiscuous mode for VF %u, error: %d\\n\",\n\t\t\tvf->vf_id, mcast_err);\n\t}\n\n\tif (!ucast_err) {\n\t\tif (alluni &&\n\t\t    !test_and_set_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states))\n\t\t\tdev_info(dev, \"VF %u successfully set unicast promiscuous mode\\n\",\n\t\t\t\t vf->vf_id);\n\t\telse if (!alluni &&\n\t\t\t test_and_clear_bit(ICE_VF_STATE_UC_PROMISC,\n\t\t\t\t\t    vf->vf_states))\n\t\t\tdev_info(dev, \"VF %u successfully unset unicast promiscuous mode\\n\",\n\t\t\t\t vf->vf_id);\n\t} else {\n\t\tdev_err(dev, \"Error while modifying unicast promiscuous mode for VF %u, error: %d\\n\",\n\t\t\tvf->vf_id, ucast_err);\n\t}\n\nerror_param:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_get_stats_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_queue_select *vqs =\n\t\t(struct virtchnl_queue_select *)msg;\n\tstruct ice_eth_stats stats = { 0 };\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tice_update_eth_stats(vsi);\n\n\tstats = vsi->eth_stats;\n\nerror_param:\n\t \n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_STATS, v_ret,\n\t\t\t\t     (u8 *)&stats, sizeof(stats));\n}\n\n \nstatic bool ice_vc_validate_vqs_bitmaps(struct virtchnl_queue_select *vqs)\n{\n\tif ((!vqs->rx_queues && !vqs->tx_queues) ||\n\t    vqs->rx_queues >= BIT(ICE_MAX_RSS_QS_PER_VF) ||\n\t    vqs->tx_queues >= BIT(ICE_MAX_RSS_QS_PER_VF))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void ice_vf_ena_txq_interrupt(struct ice_vsi *vsi, u32 q_idx)\n{\n\tstruct ice_hw *hw = &vsi->back->hw;\n\tu32 pfq = vsi->txq_map[q_idx];\n\tu32 reg;\n\n\treg = rd32(hw, QINT_TQCTL(pfq));\n\n\t \n\tif (!(reg & QINT_TQCTL_MSIX_INDX_M))\n\t\treturn;\n\n\twr32(hw, QINT_TQCTL(pfq), reg | QINT_TQCTL_CAUSE_ENA_M);\n}\n\n \nstatic void ice_vf_ena_rxq_interrupt(struct ice_vsi *vsi, u32 q_idx)\n{\n\tstruct ice_hw *hw = &vsi->back->hw;\n\tu32 pfq = vsi->rxq_map[q_idx];\n\tu32 reg;\n\n\treg = rd32(hw, QINT_RQCTL(pfq));\n\n\t \n\tif (!(reg & QINT_RQCTL_MSIX_INDX_M))\n\t\treturn;\n\n\twr32(hw, QINT_RQCTL(pfq), reg | QINT_RQCTL_CAUSE_ENA_M);\n}\n\n \nstatic int ice_vc_ena_qs_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_queue_select *vqs =\n\t    (struct virtchnl_queue_select *)msg;\n\tstruct ice_vsi *vsi;\n\tunsigned long q_map;\n\tu16 vf_q_id;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_validate_vqs_bitmaps(vqs)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\t \n\tq_map = vqs->rx_queues;\n\tfor_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {\n\t\tif (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\t \n\t\tif (test_bit(vf_q_id, vf->rxq_ena))\n\t\t\tcontinue;\n\n\t\tif (ice_vsi_ctrl_one_rx_ring(vsi, true, vf_q_id, true)) {\n\t\t\tdev_err(ice_pf_to_dev(vsi->back), \"Failed to enable Rx ring %d on VSI %d\\n\",\n\t\t\t\tvf_q_id, vsi->vsi_num);\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\tice_vf_ena_rxq_interrupt(vsi, vf_q_id);\n\t\tset_bit(vf_q_id, vf->rxq_ena);\n\t}\n\n\tq_map = vqs->tx_queues;\n\tfor_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {\n\t\tif (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\t \n\t\tif (test_bit(vf_q_id, vf->txq_ena))\n\t\t\tcontinue;\n\n\t\tice_vf_ena_txq_interrupt(vsi, vf_q_id);\n\t\tset_bit(vf_q_id, vf->txq_ena);\n\t}\n\n\t \n\tif (v_ret == VIRTCHNL_STATUS_SUCCESS)\n\t\tset_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);\n\nerror_param:\n\t \n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_QUEUES, v_ret,\n\t\t\t\t     NULL, 0);\n}\n\n \nstatic int\nice_vf_vsi_dis_single_txq(struct ice_vf *vf, struct ice_vsi *vsi, u16 q_id)\n{\n\tstruct ice_txq_meta txq_meta = { 0 };\n\tstruct ice_tx_ring *ring;\n\tint err;\n\n\tif (!test_bit(q_id, vf->txq_ena))\n\t\tdev_dbg(ice_pf_to_dev(vsi->back), \"Queue %u on VSI %u is not enabled, but stopping it anyway\\n\",\n\t\t\tq_id, vsi->vsi_num);\n\n\tring = vsi->tx_rings[q_id];\n\tif (!ring)\n\t\treturn -EINVAL;\n\n\tice_fill_txq_meta(vsi, ring, &txq_meta);\n\n\terr = ice_vsi_stop_tx_ring(vsi, ICE_NO_RESET, vf->vf_id, ring, &txq_meta);\n\tif (err) {\n\t\tdev_err(ice_pf_to_dev(vsi->back), \"Failed to stop Tx ring %d on VSI %d\\n\",\n\t\t\tq_id, vsi->vsi_num);\n\t\treturn err;\n\t}\n\n\t \n\tclear_bit(q_id, vf->txq_ena);\n\n\treturn 0;\n}\n\n \nstatic int ice_vc_dis_qs_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_queue_select *vqs =\n\t    (struct virtchnl_queue_select *)msg;\n\tstruct ice_vsi *vsi;\n\tunsigned long q_map;\n\tu16 vf_q_id;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) &&\n\t    !test_bit(ICE_VF_STATE_QS_ENA, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_validate_vqs_bitmaps(vqs)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (vqs->tx_queues) {\n\t\tq_map = vqs->tx_queues;\n\n\t\tfor_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {\n\t\t\tif (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\tif (ice_vf_vsi_dis_single_txq(vf, vsi, vf_q_id)) {\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t}\n\t}\n\n\tq_map = vqs->rx_queues;\n\t \n\tif (q_map &&\n\t    bitmap_equal(&q_map, vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF)) {\n\t\tif (ice_vsi_stop_all_rx_rings(vsi)) {\n\t\t\tdev_err(ice_pf_to_dev(vsi->back), \"Failed to stop all Rx rings on VSI %d\\n\",\n\t\t\t\tvsi->vsi_num);\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\tbitmap_zero(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF);\n\t} else if (q_map) {\n\t\tfor_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {\n\t\t\tif (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!test_bit(vf_q_id, vf->rxq_ena))\n\t\t\t\tcontinue;\n\n\t\t\tif (ice_vsi_ctrl_one_rx_ring(vsi, false, vf_q_id,\n\t\t\t\t\t\t     true)) {\n\t\t\t\tdev_err(ice_pf_to_dev(vsi->back), \"Failed to stop Rx ring %d on VSI %d\\n\",\n\t\t\t\t\tvf_q_id, vsi->vsi_num);\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\t \n\t\t\tclear_bit(vf_q_id, vf->rxq_ena);\n\t\t}\n\t}\n\n\t \n\tif (v_ret == VIRTCHNL_STATUS_SUCCESS && ice_vf_has_no_qs_ena(vf))\n\t\tclear_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);\n\nerror_param:\n\t \n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_QUEUES, v_ret,\n\t\t\t\t     NULL, 0);\n}\n\n \nstatic int\nice_cfg_interrupt(struct ice_vf *vf, struct ice_vsi *vsi, u16 vector_id,\n\t\t  struct virtchnl_vector_map *map,\n\t\t  struct ice_q_vector *q_vector)\n{\n\tu16 vsi_q_id, vsi_q_id_idx;\n\tunsigned long qmap;\n\n\tq_vector->num_ring_rx = 0;\n\tq_vector->num_ring_tx = 0;\n\n\tqmap = map->rxq_map;\n\tfor_each_set_bit(vsi_q_id_idx, &qmap, ICE_MAX_RSS_QS_PER_VF) {\n\t\tvsi_q_id = vsi_q_id_idx;\n\n\t\tif (!ice_vc_isvalid_q_id(vf, vsi->vsi_num, vsi_q_id))\n\t\t\treturn VIRTCHNL_STATUS_ERR_PARAM;\n\n\t\tq_vector->num_ring_rx++;\n\t\tq_vector->rx.itr_idx = map->rxitr_idx;\n\t\tvsi->rx_rings[vsi_q_id]->q_vector = q_vector;\n\t\tice_cfg_rxq_interrupt(vsi, vsi_q_id, vector_id,\n\t\t\t\t      q_vector->rx.itr_idx);\n\t}\n\n\tqmap = map->txq_map;\n\tfor_each_set_bit(vsi_q_id_idx, &qmap, ICE_MAX_RSS_QS_PER_VF) {\n\t\tvsi_q_id = vsi_q_id_idx;\n\n\t\tif (!ice_vc_isvalid_q_id(vf, vsi->vsi_num, vsi_q_id))\n\t\t\treturn VIRTCHNL_STATUS_ERR_PARAM;\n\n\t\tq_vector->num_ring_tx++;\n\t\tq_vector->tx.itr_idx = map->txitr_idx;\n\t\tvsi->tx_rings[vsi_q_id]->q_vector = q_vector;\n\t\tice_cfg_txq_interrupt(vsi, vsi_q_id, vector_id,\n\t\t\t\t      q_vector->tx.itr_idx);\n\t}\n\n\treturn VIRTCHNL_STATUS_SUCCESS;\n}\n\n \nstatic int ice_vc_cfg_irq_map_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tu16 num_q_vectors_mapped, vsi_id, vector_id;\n\tstruct virtchnl_irq_map_info *irqmap_info;\n\tstruct virtchnl_vector_map *map;\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_vsi *vsi;\n\tint i;\n\n\tirqmap_info = (struct virtchnl_irq_map_info *)msg;\n\tnum_q_vectors_mapped = irqmap_info->num_vectors;\n\n\t \n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||\n\t    pf->vfs.num_msix_per < num_q_vectors_mapped ||\n\t    !num_q_vectors_mapped) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < num_q_vectors_mapped; i++) {\n\t\tstruct ice_q_vector *q_vector;\n\n\t\tmap = &irqmap_info->vecmap[i];\n\n\t\tvector_id = map->vector_id;\n\t\tvsi_id = map->vsi_id;\n\t\t \n\t\tif (!(vector_id < pf->vfs.num_msix_per) ||\n\t\t    !ice_vc_isvalid_vsi_id(vf, vsi_id) ||\n\t\t    (!vector_id && (map->rxq_map || map->txq_map))) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\t \n\t\tif (!vector_id)\n\t\t\tcontinue;\n\n\t\t \n\t\tq_vector = vsi->q_vectors[vector_id - ICE_NONQ_VECS_VF];\n\t\tif (!q_vector) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\n\t\t \n\t\tv_ret = (enum virtchnl_status_code)\n\t\t\tice_cfg_interrupt(vf, vsi, vector_id, map, q_vector);\n\t\tif (v_ret)\n\t\t\tgoto error_param;\n\t}\n\nerror_param:\n\t \n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_IRQ_MAP, v_ret,\n\t\t\t\t     NULL, 0);\n}\n\n \nstatic int ice_vc_cfg_qs_msg(struct ice_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vsi_queue_config_info *qci =\n\t    (struct virtchnl_vsi_queue_config_info *)msg;\n\tstruct virtchnl_queue_pair_info *qpi;\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_lag *lag;\n\tstruct ice_vsi *vsi;\n\tu8 act_prt, pri_prt;\n\tint i = -1, q_idx;\n\n\tlag = pf->lag;\n\tmutex_lock(&pf->lag_mutex);\n\tact_prt = ICE_LAG_INVALID_PORT;\n\tpri_prt = pf->hw.port_info->lport;\n\tif (lag && lag->bonded && lag->primary) {\n\t\tact_prt = lag->active_port;\n\t\tif (act_prt != pri_prt && act_prt != ICE_LAG_INVALID_PORT &&\n\t\t    lag->upper_netdev)\n\t\t\tice_lag_move_vf_nodes_cfg(lag, act_prt, pri_prt);\n\t\telse\n\t\t\tact_prt = ICE_LAG_INVALID_PORT;\n\t}\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states))\n\t\tgoto error_param;\n\n\tif (!ice_vc_isvalid_vsi_id(vf, qci->vsi_id))\n\t\tgoto error_param;\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi)\n\t\tgoto error_param;\n\n\tif (qci->num_queue_pairs > ICE_MAX_RSS_QS_PER_VF ||\n\t    qci->num_queue_pairs > min_t(u16, vsi->alloc_txq, vsi->alloc_rxq)) {\n\t\tdev_err(ice_pf_to_dev(pf), \"VF-%d requesting more than supported number of queues: %d\\n\",\n\t\t\tvf->vf_id, min_t(u16, vsi->alloc_txq, vsi->alloc_rxq));\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < qci->num_queue_pairs; i++) {\n\t\tqpi = &qci->qpair[i];\n\t\tif (qpi->txq.vsi_id != qci->vsi_id ||\n\t\t    qpi->rxq.vsi_id != qci->vsi_id ||\n\t\t    qpi->rxq.queue_id != qpi->txq.queue_id ||\n\t\t    qpi->txq.headwb_enabled ||\n\t\t    !ice_vc_isvalid_ring_len(qpi->txq.ring_len) ||\n\t\t    !ice_vc_isvalid_ring_len(qpi->rxq.ring_len) ||\n\t\t    !ice_vc_isvalid_q_id(vf, qci->vsi_id, qpi->txq.queue_id)) {\n\t\t\tgoto error_param;\n\t\t}\n\n\t\tq_idx = qpi->rxq.queue_id;\n\n\t\t \n\t\tif (q_idx >= vsi->alloc_txq || q_idx >= vsi->alloc_rxq) {\n\t\t\tgoto error_param;\n\t\t}\n\n\t\t \n\t\tif (qpi->txq.ring_len > 0) {\n\t\t\tvsi->tx_rings[i]->dma = qpi->txq.dma_ring_addr;\n\t\t\tvsi->tx_rings[i]->count = qpi->txq.ring_len;\n\n\t\t\t \n\t\t\tif (ice_vf_vsi_dis_single_txq(vf, vsi, q_idx))\n\t\t\t\tgoto error_param;\n\n\t\t\t \n\t\t\tif (ice_vsi_cfg_single_txq(vsi, vsi->tx_rings, q_idx)) {\n\t\t\t\tdev_warn(ice_pf_to_dev(pf), \"VF-%d failed to configure TX queue %d\\n\",\n\t\t\t\t\t vf->vf_id, i);\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (qpi->rxq.ring_len > 0) {\n\t\t\tu16 max_frame_size = ice_vc_get_max_frame_size(vf);\n\t\t\tu32 rxdid;\n\n\t\t\tvsi->rx_rings[i]->dma = qpi->rxq.dma_ring_addr;\n\t\t\tvsi->rx_rings[i]->count = qpi->rxq.ring_len;\n\n\t\t\tif (qpi->rxq.databuffer_size != 0 &&\n\t\t\t    (qpi->rxq.databuffer_size > ((16 * 1024) - 128) ||\n\t\t\t     qpi->rxq.databuffer_size < 1024))\n\t\t\t\tgoto error_param;\n\t\t\tvsi->rx_buf_len = qpi->rxq.databuffer_size;\n\t\t\tvsi->rx_rings[i]->rx_buf_len = vsi->rx_buf_len;\n\t\t\tif (qpi->rxq.max_pkt_size > max_frame_size ||\n\t\t\t    qpi->rxq.max_pkt_size < 64)\n\t\t\t\tgoto error_param;\n\n\t\t\tvsi->max_frame = qpi->rxq.max_pkt_size;\n\t\t\t \n\t\t\tif (ice_vf_is_port_vlan_ena(vf))\n\t\t\t\tvsi->max_frame += VLAN_HLEN;\n\n\t\t\tif (ice_vsi_cfg_single_rxq(vsi, q_idx)) {\n\t\t\t\tdev_warn(ice_pf_to_dev(pf), \"VF-%d failed to configure RX queue %d\\n\",\n\t\t\t\t\t vf->vf_id, i);\n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (vf->driver_caps &\n\t\t\t    VIRTCHNL_VF_OFFLOAD_RX_FLEX_DESC) {\n\t\t\t\trxdid = qpi->rxq.rxdid;\n\t\t\t\tif (!(BIT(rxdid) & pf->supported_rxdids))\n\t\t\t\t\tgoto error_param;\n\t\t\t} else {\n\t\t\t\trxdid = ICE_RXDID_LEGACY_1;\n\t\t\t}\n\n\t\t\tice_write_qrxflxp_cntxt(&vsi->back->hw,\n\t\t\t\t\t\tvsi->rxq_map[q_idx],\n\t\t\t\t\t\trxdid, 0x03, false);\n\t\t}\n\t}\n\n\tif (lag && lag->bonded && lag->primary &&\n\t    act_prt != ICE_LAG_INVALID_PORT)\n\t\tice_lag_move_vf_nodes_cfg(lag, pri_prt, act_prt);\n\tmutex_unlock(&pf->lag_mutex);\n\n\t \n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES,\n\t\t\t\t     VIRTCHNL_STATUS_SUCCESS, NULL, 0);\nerror_param:\n\t \n\tfor (; i >= 0; i--) {\n\t\tif (ice_vsi_ctrl_one_rx_ring(vsi, false, i, true))\n\t\t\tdev_err(ice_pf_to_dev(pf), \"VF-%d could not disable RX queue %d\\n\",\n\t\t\t\tvf->vf_id, i);\n\t\tif (ice_vf_vsi_dis_single_txq(vf, vsi, i))\n\t\t\tdev_err(ice_pf_to_dev(pf), \"VF-%d could not disable TX queue %d\\n\",\n\t\t\t\tvf->vf_id, i);\n\t}\n\n\tif (lag && lag->bonded && lag->primary &&\n\t    act_prt != ICE_LAG_INVALID_PORT)\n\t\tice_lag_move_vf_nodes_cfg(lag, pri_prt, act_prt);\n\tmutex_unlock(&pf->lag_mutex);\n\n\tice_lag_move_new_vf_nodes(vf);\n\n\t \n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES,\n\t\t\t\t     VIRTCHNL_STATUS_ERR_PARAM, NULL, 0);\n}\n\n \nstatic bool ice_can_vf_change_mac(struct ice_vf *vf)\n{\n\t \n\tif (vf->pf_set_mac && !ice_is_vf_trusted(vf))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic u8\nice_vc_ether_addr_type(struct virtchnl_ether_addr *vc_ether_addr)\n{\n\treturn (vc_ether_addr->type & VIRTCHNL_ETHER_ADDR_TYPE_MASK);\n}\n\n \nstatic bool\nice_is_vc_addr_legacy(struct virtchnl_ether_addr *vc_ether_addr)\n{\n\tu8 type = ice_vc_ether_addr_type(vc_ether_addr);\n\n\treturn (type == VIRTCHNL_ETHER_ADDR_LEGACY);\n}\n\n \nstatic bool\nice_is_vc_addr_primary(struct virtchnl_ether_addr __maybe_unused *vc_ether_addr)\n{\n\tu8 type = ice_vc_ether_addr_type(vc_ether_addr);\n\n\treturn (type == VIRTCHNL_ETHER_ADDR_PRIMARY);\n}\n\n \nstatic void\nice_vfhw_mac_add(struct ice_vf *vf, struct virtchnl_ether_addr *vc_ether_addr)\n{\n\tu8 *mac_addr = vc_ether_addr->addr;\n\n\tif (!is_valid_ether_addr(mac_addr))\n\t\treturn;\n\n\t \n\tif ((ice_is_vc_addr_legacy(vc_ether_addr) &&\n\t     is_zero_ether_addr(vf->hw_lan_addr)) ||\n\t    ice_is_vc_addr_primary(vc_ether_addr)) {\n\t\tether_addr_copy(vf->dev_lan_addr, mac_addr);\n\t\tether_addr_copy(vf->hw_lan_addr, mac_addr);\n\t}\n\n\t \n\tif (ice_is_vc_addr_legacy(vc_ether_addr)) {\n\t\tether_addr_copy(vf->legacy_last_added_umac.addr,\n\t\t\t\tmac_addr);\n\t\tvf->legacy_last_added_umac.time_modified = jiffies;\n\t}\n}\n\n \nstatic int\nice_vc_add_mac_addr(struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t    struct virtchnl_ether_addr *vc_ether_addr)\n{\n\tstruct device *dev = ice_pf_to_dev(vf->pf);\n\tu8 *mac_addr = vc_ether_addr->addr;\n\tint ret;\n\n\t \n\tif (ether_addr_equal(mac_addr, vf->dev_lan_addr))\n\t\treturn 0;\n\n\tif (is_unicast_ether_addr(mac_addr) && !ice_can_vf_change_mac(vf)) {\n\t\tdev_err(dev, \"VF attempting to override administratively set MAC address, bring down and up the VF interface to resume normal operation\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tret = ice_fltr_add_mac(vsi, mac_addr, ICE_FWD_TO_VSI);\n\tif (ret == -EEXIST) {\n\t\tdev_dbg(dev, \"MAC %pM already exists for VF %d\\n\", mac_addr,\n\t\t\tvf->vf_id);\n\t\t \n\t} else if (ret) {\n\t\tdev_err(dev, \"Failed to add MAC %pM for VF %d\\n, error %d\\n\",\n\t\t\tmac_addr, vf->vf_id, ret);\n\t\treturn ret;\n\t} else {\n\t\tvf->num_mac++;\n\t}\n\n\tice_vfhw_mac_add(vf, vc_ether_addr);\n\n\treturn ret;\n}\n\n \nstatic bool ice_is_legacy_umac_expired(struct ice_time_mac *last_added_umac)\n{\n#define ICE_LEGACY_VF_MAC_CHANGE_EXPIRE_TIME\tmsecs_to_jiffies(3000)\n\treturn time_is_before_jiffies(last_added_umac->time_modified +\n\t\t\t\t      ICE_LEGACY_VF_MAC_CHANGE_EXPIRE_TIME);\n}\n\n \nstatic void\nice_update_legacy_cached_mac(struct ice_vf *vf,\n\t\t\t     struct virtchnl_ether_addr *vc_ether_addr)\n{\n\tif (!ice_is_vc_addr_legacy(vc_ether_addr) ||\n\t    ice_is_legacy_umac_expired(&vf->legacy_last_added_umac))\n\t\treturn;\n\n\tether_addr_copy(vf->dev_lan_addr, vf->legacy_last_added_umac.addr);\n\tether_addr_copy(vf->hw_lan_addr, vf->legacy_last_added_umac.addr);\n}\n\n \nstatic void\nice_vfhw_mac_del(struct ice_vf *vf, struct virtchnl_ether_addr *vc_ether_addr)\n{\n\tu8 *mac_addr = vc_ether_addr->addr;\n\n\tif (!is_valid_ether_addr(mac_addr) ||\n\t    !ether_addr_equal(vf->dev_lan_addr, mac_addr))\n\t\treturn;\n\n\t \n\teth_zero_addr(vf->dev_lan_addr);\n\n\tice_update_legacy_cached_mac(vf, vc_ether_addr);\n}\n\n \nstatic int\nice_vc_del_mac_addr(struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t    struct virtchnl_ether_addr *vc_ether_addr)\n{\n\tstruct device *dev = ice_pf_to_dev(vf->pf);\n\tu8 *mac_addr = vc_ether_addr->addr;\n\tint status;\n\n\tif (!ice_can_vf_change_mac(vf) &&\n\t    ether_addr_equal(vf->dev_lan_addr, mac_addr))\n\t\treturn 0;\n\n\tstatus = ice_fltr_remove_mac(vsi, mac_addr, ICE_FWD_TO_VSI);\n\tif (status == -ENOENT) {\n\t\tdev_err(dev, \"MAC %pM does not exist for VF %d\\n\", mac_addr,\n\t\t\tvf->vf_id);\n\t\treturn -ENOENT;\n\t} else if (status) {\n\t\tdev_err(dev, \"Failed to delete MAC %pM for VF %d, error %d\\n\",\n\t\t\tmac_addr, vf->vf_id, status);\n\t\treturn -EIO;\n\t}\n\n\tice_vfhw_mac_del(vf, vc_ether_addr);\n\n\tvf->num_mac--;\n\n\treturn 0;\n}\n\n \nstatic int\nice_vc_handle_mac_addr_msg(struct ice_vf *vf, u8 *msg, bool set)\n{\n\tint (*ice_vc_cfg_mac)\n\t\t(struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t struct virtchnl_ether_addr *virtchnl_ether_addr);\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_ether_addr_list *al =\n\t    (struct virtchnl_ether_addr_list *)msg;\n\tstruct ice_pf *pf = vf->pf;\n\tenum virtchnl_ops vc_op;\n\tstruct ice_vsi *vsi;\n\tint i;\n\n\tif (set) {\n\t\tvc_op = VIRTCHNL_OP_ADD_ETH_ADDR;\n\t\tice_vc_cfg_mac = ice_vc_add_mac_addr;\n\t} else {\n\t\tvc_op = VIRTCHNL_OP_DEL_ETH_ADDR;\n\t\tice_vc_cfg_mac = ice_vc_del_mac_addr;\n\t}\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||\n\t    !ice_vc_isvalid_vsi_id(vf, al->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto handle_mac_exit;\n\t}\n\n\t \n\tif (set && !ice_is_vf_trusted(vf) &&\n\t    (vf->num_mac + al->num_elements) > ICE_MAX_MACADDR_PER_VF) {\n\t\tdev_err(ice_pf_to_dev(pf), \"Can't add more MAC addresses, because VF-%d is not trusted, switch the VF to trusted mode in order to add more functionalities\\n\",\n\t\t\tvf->vf_id);\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto handle_mac_exit;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto handle_mac_exit;\n\t}\n\n\tfor (i = 0; i < al->num_elements; i++) {\n\t\tu8 *mac_addr = al->list[i].addr;\n\t\tint result;\n\n\t\tif (is_broadcast_ether_addr(mac_addr) ||\n\t\t    is_zero_ether_addr(mac_addr))\n\t\t\tcontinue;\n\n\t\tresult = ice_vc_cfg_mac(vf, vsi, &al->list[i]);\n\t\tif (result == -EEXIST || result == -ENOENT) {\n\t\t\tcontinue;\n\t\t} else if (result) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;\n\t\t\tgoto handle_mac_exit;\n\t\t}\n\t}\n\nhandle_mac_exit:\n\t \n\treturn ice_vc_send_msg_to_vf(vf, vc_op, v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_add_mac_addr_msg(struct ice_vf *vf, u8 *msg)\n{\n\treturn ice_vc_handle_mac_addr_msg(vf, msg, true);\n}\n\n \nstatic int ice_vc_del_mac_addr_msg(struct ice_vf *vf, u8 *msg)\n{\n\treturn ice_vc_handle_mac_addr_msg(vf, msg, false);\n}\n\n \nstatic int ice_vc_request_qs_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vf_res_request *vfres =\n\t\t(struct virtchnl_vf_res_request *)msg;\n\tu16 req_queues = vfres->num_queue_pairs;\n\tstruct ice_pf *pf = vf->pf;\n\tu16 max_allowed_vf_queues;\n\tu16 tx_rx_queue_left;\n\tstruct device *dev;\n\tu16 cur_queues;\n\n\tdev = ice_pf_to_dev(pf);\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tcur_queues = vf->num_vf_qs;\n\ttx_rx_queue_left = min_t(u16, ice_get_avail_txq_count(pf),\n\t\t\t\t ice_get_avail_rxq_count(pf));\n\tmax_allowed_vf_queues = tx_rx_queue_left + cur_queues;\n\tif (!req_queues) {\n\t\tdev_err(dev, \"VF %d tried to request 0 queues. Ignoring.\\n\",\n\t\t\tvf->vf_id);\n\t} else if (req_queues > ICE_MAX_RSS_QS_PER_VF) {\n\t\tdev_err(dev, \"VF %d tried to request more than %d queues.\\n\",\n\t\t\tvf->vf_id, ICE_MAX_RSS_QS_PER_VF);\n\t\tvfres->num_queue_pairs = ICE_MAX_RSS_QS_PER_VF;\n\t} else if (req_queues > cur_queues &&\n\t\t   req_queues - cur_queues > tx_rx_queue_left) {\n\t\tdev_warn(dev, \"VF %d requested %u more queues, but only %u left.\\n\",\n\t\t\t vf->vf_id, req_queues - cur_queues, tx_rx_queue_left);\n\t\tvfres->num_queue_pairs = min_t(u16, max_allowed_vf_queues,\n\t\t\t\t\t       ICE_MAX_RSS_QS_PER_VF);\n\t} else {\n\t\t \n\t\tvf->num_req_qs = req_queues;\n\t\tice_reset_vf(vf, ICE_VF_RESET_NOTIFY);\n\t\tdev_info(dev, \"VF %d granted request of %u queues.\\n\",\n\t\t\t vf->vf_id, req_queues);\n\t\treturn 0;\n\t}\n\nerror_param:\n\t \n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_REQUEST_QUEUES,\n\t\t\t\t     v_ret, (u8 *)vfres, sizeof(*vfres));\n}\n\n \nstatic bool ice_vf_vlan_offload_ena(u32 caps)\n{\n\treturn !!(caps & VIRTCHNL_VF_OFFLOAD_VLAN);\n}\n\n \nstatic bool ice_is_vlan_promisc_allowed(struct ice_vf *vf)\n{\n\tif ((test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states) ||\n\t     test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states)) &&\n\t    test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, vf->pf->flags))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int ice_vf_ena_vlan_promisc(struct ice_vsi *vsi, struct ice_vlan *vlan)\n{\n\tu8 promisc_m = ICE_PROMISC_VLAN_TX | ICE_PROMISC_VLAN_RX;\n\tint status;\n\n\tstatus = ice_fltr_set_vsi_promisc(&vsi->back->hw, vsi->idx, promisc_m,\n\t\t\t\t\t  vlan->vid);\n\tif (status && status != -EEXIST)\n\t\treturn status;\n\n\treturn 0;\n}\n\n \nstatic int ice_vf_dis_vlan_promisc(struct ice_vsi *vsi, struct ice_vlan *vlan)\n{\n\tu8 promisc_m = ICE_PROMISC_VLAN_TX | ICE_PROMISC_VLAN_RX;\n\tint status;\n\n\tstatus = ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx, promisc_m,\n\t\t\t\t\t    vlan->vid);\n\tif (status && status != -ENOENT)\n\t\treturn status;\n\n\treturn 0;\n}\n\n \nstatic bool ice_vf_has_max_vlans(struct ice_vf *vf, struct ice_vsi *vsi)\n{\n\tif (ice_is_vf_trusted(vf))\n\t\treturn false;\n\n#define ICE_VF_ADDED_VLAN_ZERO_FLTRS\t1\n\treturn ((ice_vsi_num_non_zero_vlans(vsi) +\n\t\tICE_VF_ADDED_VLAN_ZERO_FLTRS) >= ICE_MAX_VLAN_PER_VF);\n}\n\n \nstatic int ice_vc_process_vlan_msg(struct ice_vf *vf, u8 *msg, bool add_v)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vlan_filter_list *vfl =\n\t    (struct virtchnl_vlan_filter_list *)msg;\n\tstruct ice_pf *pf = vf->pf;\n\tbool vlan_promisc = false;\n\tstruct ice_vsi *vsi;\n\tstruct device *dev;\n\tint status = 0;\n\tint i;\n\n\tdev = ice_pf_to_dev(pf);\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vf_vlan_offload_ena(vf->driver_caps)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vfl->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\tif (vfl->vlan_id[i] >= VLAN_N_VID) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tdev_err(dev, \"invalid VF VLAN id %d\\n\",\n\t\t\t\tvfl->vlan_id[i]);\n\t\t\tgoto error_param;\n\t\t}\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (add_v && ice_vf_has_max_vlans(vf, vsi)) {\n\t\tdev_info(dev, \"VF-%d is not trusted, switch the VF to trusted mode, in order to add more VLAN addresses\\n\",\n\t\t\t vf->vf_id);\n\t\t \n\t\tgoto error_param;\n\t}\n\n\t \n\tif (ice_vf_is_port_vlan_ena(vf) && !ice_is_dvm_ena(&pf->hw)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\t \n\tvlan_promisc = ice_is_vlan_promisc_allowed(vf) &&\n\t\t!ice_is_dvm_ena(&pf->hw) &&\n\t\t!ice_vf_is_port_vlan_ena(vf);\n\n\tif (add_v) {\n\t\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\t\tu16 vid = vfl->vlan_id[i];\n\t\t\tstruct ice_vlan vlan;\n\n\t\t\tif (ice_vf_has_max_vlans(vf, vsi)) {\n\t\t\t\tdev_info(dev, \"VF-%d is not trusted, switch the VF to trusted mode, in order to add more VLAN addresses\\n\",\n\t\t\t\t\t vf->vf_id);\n\t\t\t\t \n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!vid)\n\t\t\t\tcontinue;\n\n\t\t\tvlan = ICE_VLAN(ETH_P_8021Q, vid, 0);\n\t\t\tstatus = vsi->inner_vlan_ops.add_vlan(vsi, &vlan);\n\t\t\tif (status) {\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!vlan_promisc && vid && !ice_is_dvm_ena(&pf->hw)) {\n\t\t\t\tif (vf->spoofchk) {\n\t\t\t\t\tstatus = vsi->inner_vlan_ops.ena_tx_filtering(vsi);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\t\t\tdev_err(dev, \"Enable VLAN anti-spoofing on VLAN ID: %d failed error-%d\\n\",\n\t\t\t\t\t\t\tvid, status);\n\t\t\t\t\t\tgoto error_param;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vsi->inner_vlan_ops.ena_rx_filtering(vsi)) {\n\t\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\t\tdev_err(dev, \"Enable VLAN pruning on VLAN ID: %d failed error-%d\\n\",\n\t\t\t\t\t\tvid, status);\n\t\t\t\t\tgoto error_param;\n\t\t\t\t}\n\t\t\t} else if (vlan_promisc) {\n\t\t\t\tstatus = ice_vf_ena_vlan_promisc(vsi, &vlan);\n\t\t\t\tif (status) {\n\t\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\t\tdev_err(dev, \"Enable Unicast/multicast promiscuous mode on VLAN ID:%d failed error-%d\\n\",\n\t\t\t\t\t\tvid, status);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tint num_vf_vlan;\n\n\t\tnum_vf_vlan = vsi->num_vlan;\n\t\tfor (i = 0; i < vfl->num_elements && i < num_vf_vlan; i++) {\n\t\t\tu16 vid = vfl->vlan_id[i];\n\t\t\tstruct ice_vlan vlan;\n\n\t\t\t \n\t\t\tif (!vid)\n\t\t\t\tcontinue;\n\n\t\t\tvlan = ICE_VLAN(ETH_P_8021Q, vid, 0);\n\t\t\tstatus = vsi->inner_vlan_ops.del_vlan(vsi, &vlan);\n\t\t\tif (status) {\n\t\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!ice_vsi_has_non_zero_vlans(vsi)) {\n\t\t\t\tvsi->inner_vlan_ops.dis_tx_filtering(vsi);\n\t\t\t\tvsi->inner_vlan_ops.dis_rx_filtering(vsi);\n\t\t\t}\n\n\t\t\tif (vlan_promisc)\n\t\t\t\tice_vf_dis_vlan_promisc(vsi, &vlan);\n\t\t}\n\t}\n\nerror_param:\n\t \n\tif (add_v)\n\t\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_VLAN, v_ret,\n\t\t\t\t\t     NULL, 0);\n\telse\n\t\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DEL_VLAN, v_ret,\n\t\t\t\t\t     NULL, 0);\n}\n\n \nstatic int ice_vc_add_vlan_msg(struct ice_vf *vf, u8 *msg)\n{\n\treturn ice_vc_process_vlan_msg(vf, msg, true);\n}\n\n \nstatic int ice_vc_remove_vlan_msg(struct ice_vf *vf, u8 *msg)\n{\n\treturn ice_vc_process_vlan_msg(vf, msg, false);\n}\n\n \nstatic int ice_vc_ena_vlan_stripping(struct ice_vf *vf)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vf_vlan_offload_ena(vf->driver_caps)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (vsi->inner_vlan_ops.ena_stripping(vsi, ETH_P_8021Q))\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\nerror_param:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_dis_vlan_stripping(struct ice_vf *vf)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (!ice_vf_vlan_offload_ena(vf->driver_caps)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\n\tif (vsi->inner_vlan_ops.dis_stripping(vsi))\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\nerror_param:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_get_rss_hena(struct ice_vf *vf)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_rss_hena *vrh = NULL;\n\tint len = 0, ret;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tif (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {\n\t\tdev_err(ice_pf_to_dev(vf->pf), \"RSS not supported by PF\\n\");\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tlen = sizeof(struct virtchnl_rss_hena);\n\tvrh = kzalloc(len, GFP_KERNEL);\n\tif (!vrh) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;\n\t\tlen = 0;\n\t\tgoto err;\n\t}\n\n\tvrh->hena = ICE_DEFAULT_RSS_HENA;\nerr:\n\t \n\tret = ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_RSS_HENA_CAPS, v_ret,\n\t\t\t\t    (u8 *)vrh, len);\n\tkfree(vrh);\n\treturn ret;\n}\n\n \nstatic int ice_vc_set_rss_hena(struct ice_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_rss_hena *vrh = (struct virtchnl_rss_hena *)msg;\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_vsi *vsi;\n\tstruct device *dev;\n\tint status;\n\n\tdev = ice_pf_to_dev(pf);\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tif (!test_bit(ICE_FLAG_RSS_ENA, pf->flags)) {\n\t\tdev_err(dev, \"RSS not supported by PF\\n\");\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\t \n\tstatus = ice_rem_vsi_rss_cfg(&pf->hw, vsi->idx);\n\tif (status && !vrh->hena) {\n\t\t \n\t\tv_ret = ice_err_to_virt_err(status);\n\t\tgoto err;\n\t} else if (status) {\n\t\t \n\t\tdev_warn(dev, \"Failed to clear the RSS configuration for VF %u\\n\",\n\t\t\t vf->vf_id);\n\t}\n\n\tif (vrh->hena) {\n\t\tstatus = ice_add_avf_rss_cfg(&pf->hw, vsi->idx, vrh->hena);\n\t\tv_ret = ice_err_to_virt_err(status);\n\t}\n\n\t \nerr:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_SET_RSS_HENA, v_ret,\n\t\t\t\t     NULL, 0);\n}\n\n \nstatic int ice_vc_query_rxdid(struct ice_vf *vf)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_supported_rxdids *rxdid = NULL;\n\tstruct ice_hw *hw = &vf->pf->hw;\n\tstruct ice_pf *pf = vf->pf;\n\tint len = 0;\n\tint ret, i;\n\tu32 regval;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tif (!(vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_FLEX_DESC)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto err;\n\t}\n\n\tlen = sizeof(struct virtchnl_supported_rxdids);\n\trxdid = kzalloc(len, GFP_KERNEL);\n\tif (!rxdid) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;\n\t\tlen = 0;\n\t\tgoto err;\n\t}\n\n\t \n\trxdid->supported_rxdids |= BIT(ICE_RXDID_LEGACY_1);\n\n\tfor (i = ICE_RXDID_FLEX_NIC; i < ICE_FLEX_DESC_RXDID_MAX_NUM; i++) {\n\t\tregval = rd32(hw, GLFLXP_RXDID_FLAGS(i, 0));\n\t\tif ((regval >> GLFLXP_RXDID_FLAGS_FLEXIFLAG_4N_S)\n\t\t\t& GLFLXP_RXDID_FLAGS_FLEXIFLAG_4N_M)\n\t\t\trxdid->supported_rxdids |= BIT(i);\n\t}\n\n\tpf->supported_rxdids = rxdid->supported_rxdids;\n\nerr:\n\tret = ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_SUPPORTED_RXDIDS,\n\t\t\t\t    v_ret, (u8 *)rxdid, len);\n\tkfree(rxdid);\n\treturn ret;\n}\n\n \nstatic int ice_vf_init_vlan_stripping(struct ice_vf *vf)\n{\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\n\tif (!vsi)\n\t\treturn -EINVAL;\n\n\t \n\tif (ice_vf_is_port_vlan_ena(vf) && !ice_is_dvm_ena(&vsi->back->hw))\n\t\treturn 0;\n\n\tif (ice_vf_vlan_offload_ena(vf->driver_caps))\n\t\treturn vsi->inner_vlan_ops.ena_stripping(vsi, ETH_P_8021Q);\n\telse\n\t\treturn vsi->inner_vlan_ops.dis_stripping(vsi);\n}\n\nstatic u16 ice_vc_get_max_vlan_fltrs(struct ice_vf *vf)\n{\n\tif (vf->trusted)\n\t\treturn VLAN_N_VID;\n\telse\n\t\treturn ICE_MAX_VLAN_PER_VF;\n}\n\n \nstatic bool ice_vf_outer_vlan_not_allowed(struct ice_vf *vf)\n{\n\tif (ice_vf_is_port_vlan_ena(vf))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void\nice_vc_set_dvm_caps(struct ice_vf *vf, struct virtchnl_vlan_caps *caps)\n{\n\tstruct virtchnl_vlan_supported_caps *supported_caps;\n\n\tif (ice_vf_outer_vlan_not_allowed(vf)) {\n\t\t \n\t\tsupported_caps = &caps->filtering.filtering_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tsupported_caps = &caps->offloads.stripping_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tsupported_caps = &caps->offloads.insertion_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tcaps->offloads.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;\n\t\tcaps->offloads.ethertype_match =\n\t\t\tVIRTCHNL_ETHERTYPE_STRIPPING_MATCHES_INSERTION;\n\t} else {\n\t\tsupported_caps = &caps->filtering.filtering_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_88A8 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_9100 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_AND;\n\t\tcaps->filtering.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\t\t VIRTCHNL_VLAN_ETHERTYPE_88A8 |\n\t\t\t\t\t\t VIRTCHNL_VLAN_ETHERTYPE_9100;\n\n\t\tsupported_caps = &caps->offloads.stripping_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_88A8 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_9100 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_XOR |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG2_2;\n\n\t\tsupported_caps = &caps->offloads.insertion_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_88A8 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_9100 |\n\t\t\t\t\tVIRTCHNL_VLAN_ETHERTYPE_XOR |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG2;\n\n\t\tcaps->offloads.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;\n\n\t\tcaps->offloads.ethertype_match =\n\t\t\tVIRTCHNL_ETHERTYPE_STRIPPING_MATCHES_INSERTION;\n\t}\n\n\tcaps->filtering.max_filters = ice_vc_get_max_vlan_fltrs(vf);\n}\n\n \nstatic void\nice_vc_set_svm_caps(struct ice_vf *vf, struct virtchnl_vlan_caps *caps)\n{\n\tstruct virtchnl_vlan_supported_caps *supported_caps;\n\n\tif (ice_vf_is_port_vlan_ena(vf)) {\n\t\tsupported_caps = &caps->filtering.filtering_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tsupported_caps = &caps->offloads.stripping_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tsupported_caps = &caps->offloads.insertion_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tcaps->offloads.ethertype_init = VIRTCHNL_VLAN_UNSUPPORTED;\n\t\tcaps->offloads.ethertype_match = VIRTCHNL_VLAN_UNSUPPORTED;\n\t\tcaps->filtering.max_filters = 0;\n\t} else {\n\t\tsupported_caps = &caps->filtering.filtering_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\t\tcaps->filtering.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;\n\n\t\tsupported_caps = &caps->offloads.stripping_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tsupported_caps = &caps->offloads.insertion_support;\n\t\tsupported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |\n\t\t\t\t\tVIRTCHNL_VLAN_TOGGLE |\n\t\t\t\t\tVIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;\n\t\tsupported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\t\tcaps->offloads.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;\n\t\tcaps->offloads.ethertype_match =\n\t\t\tVIRTCHNL_ETHERTYPE_STRIPPING_MATCHES_INSERTION;\n\t\tcaps->filtering.max_filters = ice_vc_get_max_vlan_fltrs(vf);\n\t}\n}\n\n \nstatic int ice_vc_get_offload_vlan_v2_caps(struct ice_vf *vf)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vlan_caps *caps = NULL;\n\tint err, len = 0;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tcaps = kzalloc(sizeof(*caps), GFP_KERNEL);\n\tif (!caps) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;\n\t\tgoto out;\n\t}\n\tlen = sizeof(*caps);\n\n\tif (ice_is_dvm_ena(&vf->pf->hw))\n\t\tice_vc_set_dvm_caps(vf, caps);\n\telse\n\t\tice_vc_set_svm_caps(vf, caps);\n\n\t \n\tmemcpy(&vf->vlan_v2_caps, caps, sizeof(*caps));\n\nout:\n\terr = ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS,\n\t\t\t\t    v_ret, (u8 *)caps, len);\n\tkfree(caps);\n\treturn err;\n}\n\n \nstatic bool ice_vc_validate_vlan_tpid(u16 filtering_caps, u16 tpid)\n{\n\tenum virtchnl_vlan_support vlan_ethertype = VIRTCHNL_VLAN_UNSUPPORTED;\n\n\tswitch (tpid) {\n\tcase ETH_P_8021Q:\n\t\tvlan_ethertype = VIRTCHNL_VLAN_ETHERTYPE_8100;\n\t\tbreak;\n\tcase ETH_P_8021AD:\n\t\tvlan_ethertype = VIRTCHNL_VLAN_ETHERTYPE_88A8;\n\t\tbreak;\n\tcase ETH_P_QINQ1:\n\t\tvlan_ethertype = VIRTCHNL_VLAN_ETHERTYPE_9100;\n\t\tbreak;\n\t}\n\n\tif (!(filtering_caps & vlan_ethertype))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool ice_vc_is_valid_vlan(struct virtchnl_vlan *vc_vlan)\n{\n\tif (!vc_vlan->tci || !vc_vlan->tpid)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool\nice_vc_validate_vlan_filter_list(struct virtchnl_vlan_filtering_caps *vfc,\n\t\t\t\t struct virtchnl_vlan_filter_list_v2 *vfl)\n{\n\tu16 i;\n\n\tif (!vfl->num_elements)\n\t\treturn false;\n\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\tstruct virtchnl_vlan_supported_caps *filtering_support =\n\t\t\t&vfc->filtering_support;\n\t\tstruct virtchnl_vlan_filter *vlan_fltr = &vfl->filters[i];\n\t\tstruct virtchnl_vlan *outer = &vlan_fltr->outer;\n\t\tstruct virtchnl_vlan *inner = &vlan_fltr->inner;\n\n\t\tif ((ice_vc_is_valid_vlan(outer) &&\n\t\t     filtering_support->outer == VIRTCHNL_VLAN_UNSUPPORTED) ||\n\t\t    (ice_vc_is_valid_vlan(inner) &&\n\t\t     filtering_support->inner == VIRTCHNL_VLAN_UNSUPPORTED))\n\t\t\treturn false;\n\n\t\tif ((outer->tci_mask &&\n\t\t     !(filtering_support->outer & VIRTCHNL_VLAN_FILTER_MASK)) ||\n\t\t    (inner->tci_mask &&\n\t\t     !(filtering_support->inner & VIRTCHNL_VLAN_FILTER_MASK)))\n\t\t\treturn false;\n\n\t\tif (((outer->tci & VLAN_PRIO_MASK) &&\n\t\t     !(filtering_support->outer & VIRTCHNL_VLAN_PRIO)) ||\n\t\t    ((inner->tci & VLAN_PRIO_MASK) &&\n\t\t     !(filtering_support->inner & VIRTCHNL_VLAN_PRIO)))\n\t\t\treturn false;\n\n\t\tif ((ice_vc_is_valid_vlan(outer) &&\n\t\t     !ice_vc_validate_vlan_tpid(filtering_support->outer,\n\t\t\t\t\t\touter->tpid)) ||\n\t\t    (ice_vc_is_valid_vlan(inner) &&\n\t\t     !ice_vc_validate_vlan_tpid(filtering_support->inner,\n\t\t\t\t\t\tinner->tpid)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic struct ice_vlan ice_vc_to_vlan(struct virtchnl_vlan *vc_vlan)\n{\n\tstruct ice_vlan vlan = { 0 };\n\n\tvlan.prio = (vc_vlan->tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n\tvlan.vid = vc_vlan->tci & VLAN_VID_MASK;\n\tvlan.tpid = vc_vlan->tpid;\n\n\treturn vlan;\n}\n\n \nstatic int\nice_vc_vlan_action(struct ice_vsi *vsi,\n\t\t   int (*vlan_action)(struct ice_vsi *, struct ice_vlan *),\n\t\t   struct ice_vlan *vlan)\n{\n\tint err;\n\n\terr = vlan_action(vsi, vlan);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int\nice_vc_del_vlans(struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t struct virtchnl_vlan_filter_list_v2 *vfl)\n{\n\tbool vlan_promisc = ice_is_vlan_promisc_allowed(vf);\n\tint err;\n\tu16 i;\n\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\tstruct virtchnl_vlan_filter *vlan_fltr = &vfl->filters[i];\n\t\tstruct virtchnl_vlan *vc_vlan;\n\n\t\tvc_vlan = &vlan_fltr->outer;\n\t\tif (ice_vc_is_valid_vlan(vc_vlan)) {\n\t\t\tstruct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);\n\n\t\t\terr = ice_vc_vlan_action(vsi,\n\t\t\t\t\t\t vsi->outer_vlan_ops.del_vlan,\n\t\t\t\t\t\t &vlan);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (vlan_promisc)\n\t\t\t\tice_vf_dis_vlan_promisc(vsi, &vlan);\n\n\t\t\t \n\t\t\tif (!ice_vsi_has_non_zero_vlans(vsi) && ice_is_dvm_ena(&vsi->back->hw)) {\n\t\t\t\terr = vsi->outer_vlan_ops.dis_tx_filtering(vsi);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tvc_vlan = &vlan_fltr->inner;\n\t\tif (ice_vc_is_valid_vlan(vc_vlan)) {\n\t\t\tstruct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);\n\n\t\t\terr = ice_vc_vlan_action(vsi,\n\t\t\t\t\t\t vsi->inner_vlan_ops.del_vlan,\n\t\t\t\t\t\t &vlan);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tif (!ice_is_dvm_ena(&vsi->back->hw)) {\n\t\t\t\tif (vlan_promisc)\n\t\t\t\t\tice_vf_dis_vlan_promisc(vsi, &vlan);\n\n\t\t\t\t \n\t\t\t\tif (!ice_vsi_has_non_zero_vlans(vsi)) {\n\t\t\t\t\terr = vsi->inner_vlan_ops.dis_tx_filtering(vsi);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_vc_remove_vlan_v2_msg(struct ice_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vlan_filter_list_v2 *vfl =\n\t\t(struct virtchnl_vlan_filter_list_v2 *)msg;\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct ice_vsi *vsi;\n\n\tif (!ice_vc_validate_vlan_filter_list(&vf->vlan_v2_caps.filtering,\n\t\t\t\t\t      vfl)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vfl->vport_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (ice_vc_del_vlans(vf, vsi, vfl))\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\nout:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DEL_VLAN_V2, v_ret, NULL,\n\t\t\t\t     0);\n}\n\n \nstatic int\nice_vc_add_vlans(struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t struct virtchnl_vlan_filter_list_v2 *vfl)\n{\n\tbool vlan_promisc = ice_is_vlan_promisc_allowed(vf);\n\tint err;\n\tu16 i;\n\n\tfor (i = 0; i < vfl->num_elements; i++) {\n\t\tstruct virtchnl_vlan_filter *vlan_fltr = &vfl->filters[i];\n\t\tstruct virtchnl_vlan *vc_vlan;\n\n\t\tvc_vlan = &vlan_fltr->outer;\n\t\tif (ice_vc_is_valid_vlan(vc_vlan)) {\n\t\t\tstruct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);\n\n\t\t\terr = ice_vc_vlan_action(vsi,\n\t\t\t\t\t\t vsi->outer_vlan_ops.add_vlan,\n\t\t\t\t\t\t &vlan);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (vlan_promisc) {\n\t\t\t\terr = ice_vf_ena_vlan_promisc(vsi, &vlan);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (vf->spoofchk && vlan.vid && ice_is_dvm_ena(&vsi->back->hw)) {\n\t\t\t\terr = vsi->outer_vlan_ops.ena_tx_filtering(vsi);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tvc_vlan = &vlan_fltr->inner;\n\t\tif (ice_vc_is_valid_vlan(vc_vlan)) {\n\t\t\tstruct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);\n\n\t\t\terr = ice_vc_vlan_action(vsi,\n\t\t\t\t\t\t vsi->inner_vlan_ops.add_vlan,\n\t\t\t\t\t\t &vlan);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tif (!ice_is_dvm_ena(&vsi->back->hw)) {\n\t\t\t\tif (vlan_promisc) {\n\t\t\t\t\terr = ice_vf_ena_vlan_promisc(vsi, &vlan);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (vf->spoofchk && vlan.vid) {\n\t\t\t\t\terr = vsi->inner_vlan_ops.ena_tx_filtering(vsi);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool\nice_vc_validate_add_vlan_filter_list(struct ice_vsi *vsi,\n\t\t\t\t     struct virtchnl_vlan_filtering_caps *vfc,\n\t\t\t\t     struct virtchnl_vlan_filter_list_v2 *vfl)\n{\n\tu16 num_requested_filters = ice_vsi_num_non_zero_vlans(vsi) +\n\t\tvfl->num_elements;\n\n\tif (num_requested_filters > vfc->max_filters)\n\t\treturn false;\n\n\treturn ice_vc_validate_vlan_filter_list(vfc, vfl);\n}\n\n \nstatic int ice_vc_add_vlan_v2_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vlan_filter_list_v2 *vfl =\n\t\t(struct virtchnl_vlan_filter_list_v2 *)msg;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, vfl->vport_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (!ice_vc_validate_add_vlan_filter_list(vsi,\n\t\t\t\t\t\t  &vf->vlan_v2_caps.filtering,\n\t\t\t\t\t\t  vfl)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (ice_vc_add_vlans(vf, vsi, vfl))\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\nout:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_VLAN_V2, v_ret, NULL,\n\t\t\t\t     0);\n}\n\n \nstatic bool\nice_vc_valid_vlan_setting(u32 negotiated_settings, u32 ethertype_setting)\n{\n\tif (ethertype_setting && !(negotiated_settings & ethertype_setting))\n\t\treturn false;\n\n\t \n\tif (!(negotiated_settings & VIRTCHNL_VLAN_ETHERTYPE_AND) &&\n\t    hweight32(ethertype_setting) > 1)\n\t\treturn false;\n\n\t \n\tif (!(negotiated_settings & VIRTCHNL_VLAN_TOGGLE))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool\nice_vc_valid_vlan_setting_msg(struct virtchnl_vlan_supported_caps *caps,\n\t\t\t      struct virtchnl_vlan_setting *msg)\n{\n\tif ((!msg->outer_ethertype_setting &&\n\t     !msg->inner_ethertype_setting) ||\n\t    (!caps->outer && !caps->inner))\n\t\treturn false;\n\n\tif (msg->outer_ethertype_setting &&\n\t    !ice_vc_valid_vlan_setting(caps->outer,\n\t\t\t\t       msg->outer_ethertype_setting))\n\t\treturn false;\n\n\tif (msg->inner_ethertype_setting &&\n\t    !ice_vc_valid_vlan_setting(caps->inner,\n\t\t\t\t       msg->inner_ethertype_setting))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int ice_vc_get_tpid(u32 ethertype_setting, u16 *tpid)\n{\n\tswitch (ethertype_setting) {\n\tcase VIRTCHNL_VLAN_ETHERTYPE_8100:\n\t\t*tpid = ETH_P_8021Q;\n\t\tbreak;\n\tcase VIRTCHNL_VLAN_ETHERTYPE_88A8:\n\t\t*tpid = ETH_P_8021AD;\n\t\tbreak;\n\tcase VIRTCHNL_VLAN_ETHERTYPE_9100:\n\t\t*tpid = ETH_P_QINQ1;\n\t\tbreak;\n\tdefault:\n\t\t*tpid = 0;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_vc_ena_vlan_offload(struct ice_vsi *vsi,\n\t\t\tint (*ena_offload)(struct ice_vsi *vsi, u16 tpid),\n\t\t\tu32 ethertype_setting)\n{\n\tu16 tpid;\n\tint err;\n\n\terr = ice_vc_get_tpid(ethertype_setting, &tpid);\n\tif (err)\n\t\treturn err;\n\n\terr = ena_offload(vsi, tpid);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#define ICE_L2TSEL_QRX_CONTEXT_REG_IDX\t3\n#define ICE_L2TSEL_BIT_OFFSET\t\t23\nenum ice_l2tsel {\n\tICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND,\n\tICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG1,\n};\n\n \nstatic void ice_vsi_update_l2tsel(struct ice_vsi *vsi, enum ice_l2tsel l2tsel)\n{\n\tstruct ice_hw *hw = &vsi->back->hw;\n\tu32 l2tsel_bit;\n\tint i;\n\n\tif (l2tsel == ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND)\n\t\tl2tsel_bit = 0;\n\telse\n\t\tl2tsel_bit = BIT(ICE_L2TSEL_BIT_OFFSET);\n\n\tfor (i = 0; i < vsi->alloc_rxq; i++) {\n\t\tu16 pfq = vsi->rxq_map[i];\n\t\tu32 qrx_context_offset;\n\t\tu32 regval;\n\n\t\tqrx_context_offset =\n\t\t\tQRX_CONTEXT(ICE_L2TSEL_QRX_CONTEXT_REG_IDX, pfq);\n\n\t\tregval = rd32(hw, qrx_context_offset);\n\t\tregval &= ~BIT(ICE_L2TSEL_BIT_OFFSET);\n\t\tregval |= l2tsel_bit;\n\t\twr32(hw, qrx_context_offset, regval);\n\t}\n}\n\n \nstatic int ice_vc_ena_vlan_stripping_v2_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vlan_supported_caps *stripping_support;\n\tstruct virtchnl_vlan_setting *strip_msg =\n\t\t(struct virtchnl_vlan_setting *)msg;\n\tu32 ethertype_setting;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, strip_msg->vport_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tstripping_support = &vf->vlan_v2_caps.offloads.stripping_support;\n\tif (!ice_vc_valid_vlan_setting_msg(stripping_support, strip_msg)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tethertype_setting = strip_msg->outer_ethertype_setting;\n\tif (ethertype_setting) {\n\t\tif (ice_vc_ena_vlan_offload(vsi,\n\t\t\t\t\t    vsi->outer_vlan_ops.ena_stripping,\n\t\t\t\t\t    ethertype_setting)) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tenum ice_l2tsel l2tsel =\n\t\t\t\tICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND;\n\n\t\t\t \n\t\t\tice_vsi_update_l2tsel(vsi, l2tsel);\n\t\t}\n\t}\n\n\tethertype_setting = strip_msg->inner_ethertype_setting;\n\tif (ethertype_setting &&\n\t    ice_vc_ena_vlan_offload(vsi, vsi->inner_vlan_ops.ena_stripping,\n\t\t\t\t    ethertype_setting)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_dis_vlan_stripping_v2_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vlan_supported_caps *stripping_support;\n\tstruct virtchnl_vlan_setting *strip_msg =\n\t\t(struct virtchnl_vlan_setting *)msg;\n\tu32 ethertype_setting;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, strip_msg->vport_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tstripping_support = &vf->vlan_v2_caps.offloads.stripping_support;\n\tif (!ice_vc_valid_vlan_setting_msg(stripping_support, strip_msg)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tethertype_setting = strip_msg->outer_ethertype_setting;\n\tif (ethertype_setting) {\n\t\tif (vsi->outer_vlan_ops.dis_stripping(vsi)) {\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tenum ice_l2tsel l2tsel =\n\t\t\t\tICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG1;\n\n\t\t\t \n\t\t\tice_vsi_update_l2tsel(vsi, l2tsel);\n\t\t}\n\t}\n\n\tethertype_setting = strip_msg->inner_ethertype_setting;\n\tif (ethertype_setting && vsi->inner_vlan_ops.dis_stripping(vsi)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_ena_vlan_insertion_v2_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vlan_supported_caps *insertion_support;\n\tstruct virtchnl_vlan_setting *insertion_msg =\n\t\t(struct virtchnl_vlan_setting *)msg;\n\tu32 ethertype_setting;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, insertion_msg->vport_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tinsertion_support = &vf->vlan_v2_caps.offloads.insertion_support;\n\tif (!ice_vc_valid_vlan_setting_msg(insertion_support, insertion_msg)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tethertype_setting = insertion_msg->outer_ethertype_setting;\n\tif (ethertype_setting &&\n\t    ice_vc_ena_vlan_offload(vsi, vsi->outer_vlan_ops.ena_insertion,\n\t\t\t\t    ethertype_setting)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tethertype_setting = insertion_msg->inner_ethertype_setting;\n\tif (ethertype_setting &&\n\t    ice_vc_ena_vlan_offload(vsi, vsi->inner_vlan_ops.ena_insertion,\n\t\t\t\t    ethertype_setting)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\n \nstatic int ice_vc_dis_vlan_insertion_v2_msg(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_vlan_supported_caps *insertion_support;\n\tstruct virtchnl_vlan_setting *insertion_msg =\n\t\t(struct virtchnl_vlan_setting *)msg;\n\tu32 ethertype_setting;\n\tstruct ice_vsi *vsi;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tif (!ice_vc_isvalid_vsi_id(vf, insertion_msg->vport_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tinsertion_support = &vf->vlan_v2_caps.offloads.insertion_support;\n\tif (!ice_vc_valid_vlan_setting_msg(insertion_support, insertion_msg)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tethertype_setting = insertion_msg->outer_ethertype_setting;\n\tif (ethertype_setting && vsi->outer_vlan_ops.dis_insertion(vsi)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\tethertype_setting = insertion_msg->inner_ethertype_setting;\n\tif (ethertype_setting && vsi->inner_vlan_ops.dis_insertion(vsi)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\nstatic const struct ice_virtchnl_ops ice_virtchnl_dflt_ops = {\n\t.get_ver_msg = ice_vc_get_ver_msg,\n\t.get_vf_res_msg = ice_vc_get_vf_res_msg,\n\t.reset_vf = ice_vc_reset_vf_msg,\n\t.add_mac_addr_msg = ice_vc_add_mac_addr_msg,\n\t.del_mac_addr_msg = ice_vc_del_mac_addr_msg,\n\t.cfg_qs_msg = ice_vc_cfg_qs_msg,\n\t.ena_qs_msg = ice_vc_ena_qs_msg,\n\t.dis_qs_msg = ice_vc_dis_qs_msg,\n\t.request_qs_msg = ice_vc_request_qs_msg,\n\t.cfg_irq_map_msg = ice_vc_cfg_irq_map_msg,\n\t.config_rss_key = ice_vc_config_rss_key,\n\t.config_rss_lut = ice_vc_config_rss_lut,\n\t.get_stats_msg = ice_vc_get_stats_msg,\n\t.cfg_promiscuous_mode_msg = ice_vc_cfg_promiscuous_mode_msg,\n\t.add_vlan_msg = ice_vc_add_vlan_msg,\n\t.remove_vlan_msg = ice_vc_remove_vlan_msg,\n\t.query_rxdid = ice_vc_query_rxdid,\n\t.get_rss_hena = ice_vc_get_rss_hena,\n\t.set_rss_hena_msg = ice_vc_set_rss_hena,\n\t.ena_vlan_stripping = ice_vc_ena_vlan_stripping,\n\t.dis_vlan_stripping = ice_vc_dis_vlan_stripping,\n\t.handle_rss_cfg_msg = ice_vc_handle_rss_cfg,\n\t.add_fdir_fltr_msg = ice_vc_add_fdir_fltr,\n\t.del_fdir_fltr_msg = ice_vc_del_fdir_fltr,\n\t.get_offload_vlan_v2_caps = ice_vc_get_offload_vlan_v2_caps,\n\t.add_vlan_v2_msg = ice_vc_add_vlan_v2_msg,\n\t.remove_vlan_v2_msg = ice_vc_remove_vlan_v2_msg,\n\t.ena_vlan_stripping_v2_msg = ice_vc_ena_vlan_stripping_v2_msg,\n\t.dis_vlan_stripping_v2_msg = ice_vc_dis_vlan_stripping_v2_msg,\n\t.ena_vlan_insertion_v2_msg = ice_vc_ena_vlan_insertion_v2_msg,\n\t.dis_vlan_insertion_v2_msg = ice_vc_dis_vlan_insertion_v2_msg,\n};\n\n \nvoid ice_virtchnl_set_dflt_ops(struct ice_vf *vf)\n{\n\tvf->virtchnl_ops = &ice_virtchnl_dflt_ops;\n}\n\n \nstatic int ice_vc_repr_add_mac(struct ice_vf *vf, u8 *msg)\n{\n\tenum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;\n\tstruct virtchnl_ether_addr_list *al =\n\t    (struct virtchnl_ether_addr_list *)msg;\n\tstruct ice_vsi *vsi;\n\tstruct ice_pf *pf;\n\tint i;\n\n\tif (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||\n\t    !ice_vc_isvalid_vsi_id(vf, al->vsi_id)) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto handle_mac_exit;\n\t}\n\n\tpf = vf->pf;\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (!vsi) {\n\t\tv_ret = VIRTCHNL_STATUS_ERR_PARAM;\n\t\tgoto handle_mac_exit;\n\t}\n\n\tfor (i = 0; i < al->num_elements; i++) {\n\t\tu8 *mac_addr = al->list[i].addr;\n\n\t\tif (!is_unicast_ether_addr(mac_addr) ||\n\t\t    ether_addr_equal(mac_addr, vf->hw_lan_addr))\n\t\t\tcontinue;\n\n\t\tif (vf->pf_set_mac) {\n\t\t\tdev_err(ice_pf_to_dev(pf), \"VF attempting to override administratively set MAC address\\n\");\n\t\t\tv_ret = VIRTCHNL_STATUS_ERR_NOT_SUPPORTED;\n\t\t\tgoto handle_mac_exit;\n\t\t}\n\n\t\tice_vfhw_mac_add(vf, &al->list[i]);\n\t\tvf->num_mac++;\n\t\tbreak;\n\t}\n\nhandle_mac_exit:\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_ETH_ADDR,\n\t\t\t\t     v_ret, NULL, 0);\n}\n\n \nstatic int\nice_vc_repr_del_mac(struct ice_vf __always_unused *vf, u8 __always_unused *msg)\n{\n\tstruct virtchnl_ether_addr_list *al =\n\t\t(struct virtchnl_ether_addr_list *)msg;\n\n\tice_update_legacy_cached_mac(vf, &al->list[0]);\n\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DEL_ETH_ADDR,\n\t\t\t\t     VIRTCHNL_STATUS_SUCCESS, NULL, 0);\n}\n\nstatic int\nice_vc_repr_cfg_promiscuous_mode(struct ice_vf *vf, u8 __always_unused *msg)\n{\n\tdev_dbg(ice_pf_to_dev(vf->pf),\n\t\t\"Can't config promiscuous mode in switchdev mode for VF %d\\n\",\n\t\tvf->vf_id);\n\treturn ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,\n\t\t\t\t     VIRTCHNL_STATUS_ERR_NOT_SUPPORTED,\n\t\t\t\t     NULL, 0);\n}\n\nstatic const struct ice_virtchnl_ops ice_virtchnl_repr_ops = {\n\t.get_ver_msg = ice_vc_get_ver_msg,\n\t.get_vf_res_msg = ice_vc_get_vf_res_msg,\n\t.reset_vf = ice_vc_reset_vf_msg,\n\t.add_mac_addr_msg = ice_vc_repr_add_mac,\n\t.del_mac_addr_msg = ice_vc_repr_del_mac,\n\t.cfg_qs_msg = ice_vc_cfg_qs_msg,\n\t.ena_qs_msg = ice_vc_ena_qs_msg,\n\t.dis_qs_msg = ice_vc_dis_qs_msg,\n\t.request_qs_msg = ice_vc_request_qs_msg,\n\t.cfg_irq_map_msg = ice_vc_cfg_irq_map_msg,\n\t.config_rss_key = ice_vc_config_rss_key,\n\t.config_rss_lut = ice_vc_config_rss_lut,\n\t.get_stats_msg = ice_vc_get_stats_msg,\n\t.cfg_promiscuous_mode_msg = ice_vc_repr_cfg_promiscuous_mode,\n\t.add_vlan_msg = ice_vc_add_vlan_msg,\n\t.remove_vlan_msg = ice_vc_remove_vlan_msg,\n\t.query_rxdid = ice_vc_query_rxdid,\n\t.get_rss_hena = ice_vc_get_rss_hena,\n\t.set_rss_hena_msg = ice_vc_set_rss_hena,\n\t.ena_vlan_stripping = ice_vc_ena_vlan_stripping,\n\t.dis_vlan_stripping = ice_vc_dis_vlan_stripping,\n\t.handle_rss_cfg_msg = ice_vc_handle_rss_cfg,\n\t.add_fdir_fltr_msg = ice_vc_add_fdir_fltr,\n\t.del_fdir_fltr_msg = ice_vc_del_fdir_fltr,\n\t.get_offload_vlan_v2_caps = ice_vc_get_offload_vlan_v2_caps,\n\t.add_vlan_v2_msg = ice_vc_add_vlan_v2_msg,\n\t.remove_vlan_v2_msg = ice_vc_remove_vlan_v2_msg,\n\t.ena_vlan_stripping_v2_msg = ice_vc_ena_vlan_stripping_v2_msg,\n\t.dis_vlan_stripping_v2_msg = ice_vc_dis_vlan_stripping_v2_msg,\n\t.ena_vlan_insertion_v2_msg = ice_vc_ena_vlan_insertion_v2_msg,\n\t.dis_vlan_insertion_v2_msg = ice_vc_dis_vlan_insertion_v2_msg,\n};\n\n \nvoid ice_virtchnl_set_repr_ops(struct ice_vf *vf)\n{\n\tvf->virtchnl_ops = &ice_virtchnl_repr_ops;\n}\n\n \nstatic bool\nice_is_malicious_vf(struct ice_vf *vf, struct ice_mbx_data *mbxdata)\n{\n\tbool report_malvf = false;\n\tstruct device *dev;\n\tstruct ice_pf *pf;\n\tint status;\n\n\tpf = vf->pf;\n\tdev = ice_pf_to_dev(pf);\n\n\tif (test_bit(ICE_VF_STATE_DIS, vf->vf_states))\n\t\treturn vf->mbx_info.malicious;\n\n\t \n\tstatus = ice_mbx_vf_state_handler(&pf->hw, mbxdata, &vf->mbx_info,\n\t\t\t\t\t  &report_malvf);\n\tif (status)\n\t\tdev_warn_ratelimited(dev, \"Unable to check status of mailbox overflow for VF %u MAC %pM, status %d\\n\",\n\t\t\t\t     vf->vf_id, vf->dev_lan_addr, status);\n\n\tif (report_malvf) {\n\t\tstruct ice_vsi *pf_vsi = ice_get_main_vsi(pf);\n\t\tu8 zero_addr[ETH_ALEN] = {};\n\n\t\tdev_warn(dev, \"VF MAC %pM on PF MAC %pM is generating asynchronous messages and may be overflowing the PF message queue. Please see the Adapter User Guide for more information\\n\",\n\t\t\t vf->dev_lan_addr,\n\t\t\t pf_vsi ? pf_vsi->netdev->dev_addr : zero_addr);\n\t}\n\n\treturn vf->mbx_info.malicious;\n}\n\n \nvoid ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event,\n\t\t\t   struct ice_mbx_data *mbxdata)\n{\n\tu32 v_opcode = le32_to_cpu(event->desc.cookie_high);\n\ts16 vf_id = le16_to_cpu(event->desc.retval);\n\tconst struct ice_virtchnl_ops *ops;\n\tu16 msglen = event->msg_len;\n\tu8 *msg = event->msg_buf;\n\tstruct ice_vf *vf = NULL;\n\tstruct device *dev;\n\tint err = 0;\n\n\tdev = ice_pf_to_dev(pf);\n\n\tvf = ice_get_vf_by_id(pf, vf_id);\n\tif (!vf) {\n\t\tdev_err(dev, \"Unable to locate VF for message from VF ID %d, opcode %d, len %d\\n\",\n\t\t\tvf_id, v_opcode, msglen);\n\t\treturn;\n\t}\n\n\tmutex_lock(&vf->cfg_lock);\n\n\t \n\tif (ice_is_malicious_vf(vf, mbxdata))\n\t\tgoto finish;\n\n\t \n\tif (test_bit(ICE_VF_STATE_DIS, vf->vf_states)) {\n\t\terr = -EPERM;\n\t\tgoto error_handler;\n\t}\n\n\tops = vf->virtchnl_ops;\n\n\t \n\terr = virtchnl_vc_validate_vf_msg(&vf->vf_ver, v_opcode, msg, msglen);\n\tif (err) {\n\t\tif (err == VIRTCHNL_STATUS_ERR_PARAM)\n\t\t\terr = -EPERM;\n\t\telse\n\t\t\terr = -EINVAL;\n\t}\n\nerror_handler:\n\tif (err) {\n\t\tice_vc_send_msg_to_vf(vf, v_opcode, VIRTCHNL_STATUS_ERR_PARAM,\n\t\t\t\t      NULL, 0);\n\t\tdev_err(dev, \"Invalid message from VF %d, opcode %d, len %d, error %d\\n\",\n\t\t\tvf_id, v_opcode, msglen, err);\n\t\tgoto finish;\n\t}\n\n\tif (!ice_vc_is_opcode_allowed(vf, v_opcode)) {\n\t\tice_vc_send_msg_to_vf(vf, v_opcode,\n\t\t\t\t      VIRTCHNL_STATUS_ERR_NOT_SUPPORTED, NULL,\n\t\t\t\t      0);\n\t\tgoto finish;\n\t}\n\n\tswitch (v_opcode) {\n\tcase VIRTCHNL_OP_VERSION:\n\t\terr = ops->get_ver_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_VF_RESOURCES:\n\t\terr = ops->get_vf_res_msg(vf, msg);\n\t\tif (ice_vf_init_vlan_stripping(vf))\n\t\t\tdev_dbg(dev, \"Failed to initialize VLAN stripping for VF %d\\n\",\n\t\t\t\tvf->vf_id);\n\t\tice_vc_notify_vf_link_state(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_RESET_VF:\n\t\tops->reset_vf(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_ETH_ADDR:\n\t\terr = ops->add_mac_addr_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_ETH_ADDR:\n\t\terr = ops->del_mac_addr_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_VSI_QUEUES:\n\t\terr = ops->cfg_qs_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_QUEUES:\n\t\terr = ops->ena_qs_msg(vf, msg);\n\t\tice_vc_notify_vf_link_state(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_QUEUES:\n\t\terr = ops->dis_qs_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_REQUEST_QUEUES:\n\t\terr = ops->request_qs_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_IRQ_MAP:\n\t\terr = ops->cfg_irq_map_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_RSS_KEY:\n\t\terr = ops->config_rss_key(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_RSS_LUT:\n\t\terr = ops->config_rss_lut(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_STATS:\n\t\terr = ops->get_stats_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE:\n\t\terr = ops->cfg_promiscuous_mode_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_VLAN:\n\t\terr = ops->add_vlan_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_VLAN:\n\t\terr = ops->remove_vlan_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_SUPPORTED_RXDIDS:\n\t\terr = ops->query_rxdid(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_RSS_HENA_CAPS:\n\t\terr = ops->get_rss_hena(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_SET_RSS_HENA:\n\t\terr = ops->set_rss_hena_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_VLAN_STRIPPING:\n\t\terr = ops->ena_vlan_stripping(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_VLAN_STRIPPING:\n\t\terr = ops->dis_vlan_stripping(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_FDIR_FILTER:\n\t\terr = ops->add_fdir_fltr_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_FDIR_FILTER:\n\t\terr = ops->del_fdir_fltr_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_RSS_CFG:\n\t\terr = ops->handle_rss_cfg_msg(vf, msg, true);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_RSS_CFG:\n\t\terr = ops->handle_rss_cfg_msg(vf, msg, false);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS:\n\t\terr = ops->get_offload_vlan_v2_caps(vf);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_VLAN_V2:\n\t\terr = ops->add_vlan_v2_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_VLAN_V2:\n\t\terr = ops->remove_vlan_v2_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2:\n\t\terr = ops->ena_vlan_stripping_v2_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2:\n\t\terr = ops->dis_vlan_stripping_v2_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2:\n\t\terr = ops->ena_vlan_insertion_v2_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2:\n\t\terr = ops->dis_vlan_insertion_v2_msg(vf, msg);\n\t\tbreak;\n\tcase VIRTCHNL_OP_UNKNOWN:\n\tdefault:\n\t\tdev_err(dev, \"Unsupported opcode %d from VF %d\\n\", v_opcode,\n\t\t\tvf_id);\n\t\terr = ice_vc_send_msg_to_vf(vf, v_opcode,\n\t\t\t\t\t    VIRTCHNL_STATUS_ERR_NOT_SUPPORTED,\n\t\t\t\t\t    NULL, 0);\n\t\tbreak;\n\t}\n\tif (err) {\n\t\t \n\t\tdev_info(dev, \"PF failed to honor VF %d, opcode %d, error %d\\n\",\n\t\t\t vf_id, v_opcode, err);\n\t}\n\nfinish:\n\tmutex_unlock(&vf->cfg_lock);\n\tice_put_vf(vf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}