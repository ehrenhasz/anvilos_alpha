{
  "module_name": "ice_dcb_lib.h",
  "hash_id": "cb497732cd64ad6147abf24eadea292c2caffb32862f83f64d51229e5eadf631",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_dcb_lib.h",
  "human_readable_source": " \n \n\n#ifndef _ICE_DCB_LIB_H_\n#define _ICE_DCB_LIB_H_\n\n#include \"ice.h\"\n#include \"ice_base.h\"\n#include \"ice_lib.h\"\n\n#ifdef CONFIG_DCB\n#define ICE_TC_MAX_BW\t\t100  \n#define ICE_DCB_HW_CHG_RST\t0  \n#define ICE_DCB_NO_HW_CHG\t1  \n#define ICE_DCB_HW_CHG\t\t2  \n\nvoid ice_dcb_rebuild(struct ice_pf *pf);\nint ice_dcb_sw_dflt_cfg(struct ice_pf *pf, bool ets_willing, bool locked);\nu8 ice_dcb_get_num_tc(struct ice_dcbx_cfg *dcbcfg);\nvoid ice_vsi_set_dcb_tc_cfg(struct ice_vsi *vsi);\nbool ice_is_pfc_causing_hung_q(struct ice_pf *pf, unsigned int txqueue);\nu8 ice_dcb_get_tc(struct ice_vsi *vsi, int queue_index);\nint\nice_pf_dcb_cfg(struct ice_pf *pf, struct ice_dcbx_cfg *new_cfg, bool locked);\nint ice_dcb_bwchk(struct ice_pf *pf, struct ice_dcbx_cfg *dcbcfg);\nvoid ice_pf_dcb_recfg(struct ice_pf *pf, bool locked);\nvoid ice_vsi_cfg_dcb_rings(struct ice_vsi *vsi);\nint ice_init_pf_dcb(struct ice_pf *pf, bool locked);\nvoid ice_update_dcb_stats(struct ice_pf *pf);\nvoid\nice_tx_prepare_vlan_flags_dcb(struct ice_tx_ring *tx_ring,\n\t\t\t      struct ice_tx_buf *first);\nvoid\nice_dcb_process_lldp_set_mib_change(struct ice_pf *pf,\n\t\t\t\t    struct ice_rq_event_info *event);\n \nstatic inline bool ice_find_q_in_range(u16 low, u16 high, unsigned int tx_q)\n{\n\treturn (tx_q >= low) && (tx_q < high);\n}\n\nstatic inline void\nice_set_cgd_num(struct ice_tlan_ctx *tlan_ctx, u8 dcb_tc)\n{\n\ttlan_ctx->cgd_num = dcb_tc;\n}\n\nstatic inline bool ice_is_dcb_active(struct ice_pf *pf)\n{\n\treturn (test_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags) ||\n\t\ttest_bit(ICE_FLAG_DCB_ENA, pf->flags));\n}\n\nstatic inline u8 ice_get_pfc_mode(struct ice_pf *pf)\n{\n\treturn pf->hw.port_info->qos_cfg.local_dcbx_cfg.pfc_mode;\n}\n\n#else\nstatic inline void ice_dcb_rebuild(struct ice_pf *pf) { }\n\nstatic inline void ice_vsi_set_dcb_tc_cfg(struct ice_vsi *vsi)\n{\n\tvsi->tc_cfg.ena_tc = ICE_DFLT_TRAFFIC_CLASS;\n\tvsi->tc_cfg.numtc = 1;\n}\n\nstatic inline u8 ice_dcb_get_ena_tc(struct ice_dcbx_cfg __always_unused *dcbcfg)\n{\n\treturn ICE_DFLT_TRAFFIC_CLASS;\n}\n\nstatic inline u8 ice_dcb_get_num_tc(struct ice_dcbx_cfg __always_unused *dcbcfg)\n{\n\treturn 1;\n}\n\nstatic inline u8\nice_dcb_get_tc(struct ice_vsi __always_unused *vsi,\n\t       int __always_unused queue_index)\n{\n\treturn 0;\n}\n\nstatic inline int\nice_init_pf_dcb(struct ice_pf *pf, bool __always_unused locked)\n{\n\tdev_dbg(ice_pf_to_dev(pf), \"DCB not supported\\n\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int\nice_pf_dcb_cfg(struct ice_pf __always_unused *pf,\n\t       struct ice_dcbx_cfg __always_unused *new_cfg,\n\t       bool __always_unused locked)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int\nice_tx_prepare_vlan_flags_dcb(struct ice_tx_ring __always_unused *tx_ring,\n\t\t\t      struct ice_tx_buf __always_unused *first)\n{\n\treturn 0;\n}\n\nstatic inline bool ice_is_dcb_active(struct ice_pf __always_unused *pf)\n{\n\treturn false;\n}\n\nstatic inline bool\nice_is_pfc_causing_hung_q(struct ice_pf __always_unused *pf,\n\t\t\t  unsigned int __always_unused txqueue)\n{\n\treturn false;\n}\n\nstatic inline u8 ice_get_pfc_mode(struct ice_pf *pf)\n{\n\treturn 0;\n}\n\nstatic inline void ice_pf_dcb_recfg(struct ice_pf *pf, bool locked) { }\nstatic inline void ice_vsi_cfg_dcb_rings(struct ice_vsi *vsi) { }\nstatic inline void ice_update_dcb_stats(struct ice_pf *pf) { }\nstatic inline void\nice_dcb_process_lldp_set_mib_change(struct ice_pf *pf, struct ice_rq_event_info *event) { }\nstatic inline void ice_set_cgd_num(struct ice_tlan_ctx *tlan_ctx, u8 dcb_tc) { }\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}