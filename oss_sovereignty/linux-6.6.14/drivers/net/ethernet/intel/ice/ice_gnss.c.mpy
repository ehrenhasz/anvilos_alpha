{
  "module_name": "ice_gnss.c",
  "hash_id": "b47f2f38c7eb0912c1a7e548dd3b3d2cfa10965e30431e13eb7acc9a3d44529f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_gnss.c",
  "human_readable_source": "\n \n\n#include \"ice.h\"\n#include \"ice_lib.h\"\n\n \nstatic int\nice_gnss_do_write(struct ice_pf *pf, const unsigned char *buf, unsigned int size)\n{\n\tstruct ice_aqc_link_topo_addr link_topo;\n\tstruct ice_hw *hw = &pf->hw;\n\tunsigned int offset = 0;\n\tint err = 0;\n\n\tmemset(&link_topo, 0, sizeof(struct ice_aqc_link_topo_addr));\n\tlink_topo.topo_params.index = ICE_E810T_GNSS_I2C_BUS;\n\tlink_topo.topo_params.node_type_ctx |=\n\t\tFIELD_PREP(ICE_AQC_LINK_TOPO_NODE_CTX_M,\n\t\t\t   ICE_AQC_LINK_TOPO_NODE_CTX_OVERRIDE);\n\n\t \n\twhile (size - offset > ICE_GNSS_UBX_WRITE_BYTES + 1) {\n\t\terr = ice_aq_write_i2c(hw, link_topo, ICE_GNSS_UBX_I2C_BUS_ADDR,\n\t\t\t\t       cpu_to_le16(buf[offset]),\n\t\t\t\t       ICE_MAX_I2C_WRITE_BYTES,\n\t\t\t\t       &buf[offset + 1], NULL);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\toffset += ICE_GNSS_UBX_WRITE_BYTES;\n\t}\n\n\t \n\tif (size - offset == ICE_GNSS_UBX_WRITE_BYTES + 1) {\n\t\terr = ice_aq_write_i2c(hw, link_topo, ICE_GNSS_UBX_I2C_BUS_ADDR,\n\t\t\t\t       cpu_to_le16(buf[offset]),\n\t\t\t\t       ICE_MAX_I2C_WRITE_BYTES - 1,\n\t\t\t\t       &buf[offset + 1], NULL);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\toffset += ICE_GNSS_UBX_WRITE_BYTES - 1;\n\t}\n\n\t \n\terr = ice_aq_write_i2c(hw, link_topo, ICE_GNSS_UBX_I2C_BUS_ADDR,\n\t\t\t       cpu_to_le16(buf[offset]), size - offset - 1,\n\t\t\t       &buf[offset + 1], NULL);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn size;\n\nerr_out:\n\tdev_err(ice_pf_to_dev(pf), \"GNSS failed to write, offset=%u, size=%u, err=%d\\n\",\n\t\toffset, size, err);\n\n\treturn err;\n}\n\n \nstatic void ice_gnss_read(struct kthread_work *work)\n{\n\tstruct gnss_serial *gnss = container_of(work, struct gnss_serial,\n\t\t\t\t\t\tread_work.work);\n\tunsigned long delay = ICE_GNSS_POLL_DATA_DELAY_TIME;\n\tunsigned int i, bytes_read, data_len, count;\n\tstruct ice_aqc_link_topo_addr link_topo;\n\tstruct ice_pf *pf;\n\tstruct ice_hw *hw;\n\t__be16 data_len_b;\n\tchar *buf = NULL;\n\tu8 i2c_params;\n\tint err = 0;\n\n\tpf = gnss->back;\n\tif (!pf || !test_bit(ICE_FLAG_GNSS, pf->flags))\n\t\treturn;\n\n\thw = &pf->hw;\n\n\tmemset(&link_topo, 0, sizeof(struct ice_aqc_link_topo_addr));\n\tlink_topo.topo_params.index = ICE_E810T_GNSS_I2C_BUS;\n\tlink_topo.topo_params.node_type_ctx |=\n\t\tFIELD_PREP(ICE_AQC_LINK_TOPO_NODE_CTX_M,\n\t\t\t   ICE_AQC_LINK_TOPO_NODE_CTX_OVERRIDE);\n\n\ti2c_params = ICE_GNSS_UBX_DATA_LEN_WIDTH |\n\t\t     ICE_AQC_I2C_USE_REPEATED_START;\n\n\terr = ice_aq_read_i2c(hw, link_topo, ICE_GNSS_UBX_I2C_BUS_ADDR,\n\t\t\t      cpu_to_le16(ICE_GNSS_UBX_DATA_LEN_H),\n\t\t\t      i2c_params, (u8 *)&data_len_b, NULL);\n\tif (err)\n\t\tgoto requeue;\n\n\tdata_len = be16_to_cpu(data_len_b);\n\tif (data_len == 0 || data_len == U16_MAX)\n\t\tgoto requeue;\n\n\t \n\n\tdata_len = min_t(typeof(data_len), data_len, PAGE_SIZE);\n\n\tbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto requeue;\n\t}\n\n\t \n\tfor (i = 0; i < data_len; i += bytes_read) {\n\t\tunsigned int bytes_left = data_len - i;\n\n\t\tbytes_read = min_t(typeof(bytes_left), bytes_left,\n\t\t\t\t   ICE_MAX_I2C_DATA_SIZE);\n\n\t\terr = ice_aq_read_i2c(hw, link_topo, ICE_GNSS_UBX_I2C_BUS_ADDR,\n\t\t\t\t      cpu_to_le16(ICE_GNSS_UBX_EMPTY_DATA),\n\t\t\t\t      bytes_read, &buf[i], NULL);\n\t\tif (err)\n\t\t\tgoto free_buf;\n\t}\n\n\tcount = gnss_insert_raw(pf->gnss_dev, buf, i);\n\tif (count != i)\n\t\tdev_warn(ice_pf_to_dev(pf),\n\t\t\t \"gnss_insert_raw ret=%d size=%d\\n\",\n\t\t\t count, i);\n\tdelay = ICE_GNSS_TIMER_DELAY_TIME;\nfree_buf:\n\tfree_page((unsigned long)buf);\nrequeue:\n\tkthread_queue_delayed_work(gnss->kworker, &gnss->read_work, delay);\n\tif (err)\n\t\tdev_dbg(ice_pf_to_dev(pf), \"GNSS failed to read err=%d\\n\", err);\n}\n\n \nstatic struct gnss_serial *ice_gnss_struct_init(struct ice_pf *pf)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct kthread_worker *kworker;\n\tstruct gnss_serial *gnss;\n\n\tgnss = kzalloc(sizeof(*gnss), GFP_KERNEL);\n\tif (!gnss)\n\t\treturn NULL;\n\n\tgnss->back = pf;\n\tpf->gnss_serial = gnss;\n\n\tkthread_init_delayed_work(&gnss->read_work, ice_gnss_read);\n\tkworker = kthread_create_worker(0, \"ice-gnss-%s\", dev_name(dev));\n\tif (IS_ERR(kworker)) {\n\t\tkfree(gnss);\n\t\treturn NULL;\n\t}\n\n\tgnss->kworker = kworker;\n\n\treturn gnss;\n}\n\n \nstatic int ice_gnss_open(struct gnss_device *gdev)\n{\n\tstruct ice_pf *pf = gnss_get_drvdata(gdev);\n\tstruct gnss_serial *gnss;\n\n\tif (!pf)\n\t\treturn -EFAULT;\n\n\tif (!test_bit(ICE_FLAG_GNSS, pf->flags))\n\t\treturn -EFAULT;\n\n\tgnss = pf->gnss_serial;\n\tif (!gnss)\n\t\treturn -ENODEV;\n\n\tkthread_queue_delayed_work(gnss->kworker, &gnss->read_work, 0);\n\n\treturn 0;\n}\n\n \nstatic void ice_gnss_close(struct gnss_device *gdev)\n{\n\tstruct ice_pf *pf = gnss_get_drvdata(gdev);\n\tstruct gnss_serial *gnss;\n\n\tif (!pf)\n\t\treturn;\n\n\tgnss = pf->gnss_serial;\n\tif (!gnss)\n\t\treturn;\n\n\tkthread_cancel_delayed_work_sync(&gnss->read_work);\n}\n\n \nstatic int\nice_gnss_write(struct gnss_device *gdev, const unsigned char *buf,\n\t       size_t count)\n{\n\tstruct ice_pf *pf = gnss_get_drvdata(gdev);\n\tstruct gnss_serial *gnss;\n\n\t \n\tif (count <= 1 || count > ICE_GNSS_TTY_WRITE_BUF)\n\t\treturn -EINVAL;\n\n\tif (!pf)\n\t\treturn -EFAULT;\n\n\tif (!test_bit(ICE_FLAG_GNSS, pf->flags))\n\t\treturn -EFAULT;\n\n\tgnss = pf->gnss_serial;\n\tif (!gnss)\n\t\treturn -ENODEV;\n\n\treturn ice_gnss_do_write(pf, buf, count);\n}\n\nstatic const struct gnss_operations ice_gnss_ops = {\n\t.open = ice_gnss_open,\n\t.close = ice_gnss_close,\n\t.write_raw = ice_gnss_write,\n};\n\n \nstatic int ice_gnss_register(struct ice_pf *pf)\n{\n\tstruct gnss_device *gdev;\n\tint ret;\n\n\tgdev = gnss_allocate_device(ice_pf_to_dev(pf));\n\tif (!gdev) {\n\t\tdev_err(ice_pf_to_dev(pf),\n\t\t\t\"gnss_allocate_device returns NULL\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgdev->ops = &ice_gnss_ops;\n\tgdev->type = GNSS_TYPE_UBX;\n\tgnss_set_drvdata(gdev, pf);\n\tret = gnss_register_device(gdev);\n\tif (ret) {\n\t\tdev_err(ice_pf_to_dev(pf), \"gnss_register_device err=%d\\n\",\n\t\t\tret);\n\t\tgnss_put_device(gdev);\n\t} else {\n\t\tpf->gnss_dev = gdev;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void ice_gnss_deregister(struct ice_pf *pf)\n{\n\tif (pf->gnss_dev) {\n\t\tgnss_deregister_device(pf->gnss_dev);\n\t\tgnss_put_device(pf->gnss_dev);\n\t\tpf->gnss_dev = NULL;\n\t}\n}\n\n \nvoid ice_gnss_init(struct ice_pf *pf)\n{\n\tint ret;\n\n\tpf->gnss_serial = ice_gnss_struct_init(pf);\n\tif (!pf->gnss_serial)\n\t\treturn;\n\n\tret = ice_gnss_register(pf);\n\tif (!ret) {\n\t\tset_bit(ICE_FLAG_GNSS, pf->flags);\n\t\tdev_info(ice_pf_to_dev(pf), \"GNSS init successful\\n\");\n\t} else {\n\t\tice_gnss_exit(pf);\n\t\tdev_err(ice_pf_to_dev(pf), \"GNSS init failure\\n\");\n\t}\n}\n\n \nvoid ice_gnss_exit(struct ice_pf *pf)\n{\n\tice_gnss_deregister(pf);\n\tclear_bit(ICE_FLAG_GNSS, pf->flags);\n\n\tif (pf->gnss_serial) {\n\t\tstruct gnss_serial *gnss = pf->gnss_serial;\n\n\t\tkthread_cancel_delayed_work_sync(&gnss->read_work);\n\t\tkthread_destroy_worker(gnss->kworker);\n\t\tgnss->kworker = NULL;\n\n\t\tkfree(gnss);\n\t\tpf->gnss_serial = NULL;\n\t}\n}\n\n \nbool ice_gnss_is_gps_present(struct ice_hw *hw)\n{\n\tif (!hw->func_caps.ts_func_info.src_tmr_owned)\n\t\treturn false;\n\n#if IS_ENABLED(CONFIG_PTP_1588_CLOCK)\n\tif (ice_is_e810t(hw)) {\n\t\tint err;\n\t\tu8 data;\n\n\t\terr = ice_read_pca9575_reg_e810t(hw, ICE_PCA9575_P0_IN, &data);\n\t\tif (err || !!(data & ICE_E810T_P0_GNSS_PRSNT_N))\n\t\t\treturn false;\n\t} else {\n\t\treturn false;\n\t}\n#else\n\tif (!ice_is_e810t(hw))\n\t\treturn false;\n#endif  \n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}