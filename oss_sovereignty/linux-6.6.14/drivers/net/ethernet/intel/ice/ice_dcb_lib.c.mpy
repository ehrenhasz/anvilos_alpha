{
  "module_name": "ice_dcb_lib.c",
  "hash_id": "abd350e8d7f082e96410d341916653596c5f08fd4bf7baffa37c1692b4ffd9ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_dcb_lib.c",
  "human_readable_source": "\n \n\n#include \"ice_dcb_lib.h\"\n#include \"ice_dcb_nl.h\"\n#include \"ice_devlink.h\"\n\n \nstatic u8 ice_dcb_get_ena_tc(struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 i, num_tc, ena_tc = 1;\n\n\tnum_tc = ice_dcb_get_num_tc(dcbcfg);\n\n\tfor (i = 0; i < num_tc; i++)\n\t\tena_tc |= BIT(i);\n\n\treturn ena_tc;\n}\n\n \nbool ice_is_pfc_causing_hung_q(struct ice_pf *pf, unsigned int txqueue)\n{\n\tu8 num_tcs = 0, i, tc, up_mapped_tc, up_in_tc = 0;\n\tu64 ref_prio_xoff[ICE_MAX_UP];\n\tstruct ice_vsi *vsi;\n\tu32 up2tc;\n\n\tvsi = ice_get_main_vsi(pf);\n\tif (!vsi)\n\t\treturn false;\n\n\tice_for_each_traffic_class(i)\n\t\tif (vsi->tc_cfg.ena_tc & BIT(i))\n\t\t\tnum_tcs++;\n\n\t \n\tfor (tc = 0; tc < num_tcs - 1; tc++)\n\t\tif (ice_find_q_in_range(vsi->tc_cfg.tc_info[tc].qoffset,\n\t\t\t\t\tvsi->tc_cfg.tc_info[tc + 1].qoffset,\n\t\t\t\t\ttxqueue))\n\t\t\tbreak;\n\n\t \n\tup2tc = rd32(&pf->hw, PRTDCB_TUP2TC);\n\tfor (i = 0; i < ICE_MAX_UP; i++) {\n\t\tup_mapped_tc = (up2tc >> (i * 3)) & 0x7;\n\t\tif (up_mapped_tc == tc)\n\t\t\tup_in_tc |= BIT(i);\n\t}\n\n\t \n\tfor (i = 0; i < ICE_MAX_UP; i++)\n\t\tif (up_in_tc & BIT(i))\n\t\t\tref_prio_xoff[i] = pf->stats.priority_xoff_rx[i];\n\n\tice_update_dcb_stats(pf);\n\n\tfor (i = 0; i < ICE_MAX_UP; i++)\n\t\tif (up_in_tc & BIT(i))\n\t\t\tif (pf->stats.priority_xoff_rx[i] > ref_prio_xoff[i])\n\t\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic u8 ice_dcb_get_mode(struct ice_port_info *port_info, bool host)\n{\n\tu8 mode;\n\n\tif (host)\n\t\tmode = DCB_CAP_DCBX_HOST;\n\telse\n\t\tmode = DCB_CAP_DCBX_LLD_MANAGED;\n\n\tif (port_info->qos_cfg.local_dcbx_cfg.dcbx_mode & ICE_DCBX_MODE_CEE)\n\t\treturn mode | DCB_CAP_DCBX_VER_CEE;\n\telse\n\t\treturn mode | DCB_CAP_DCBX_VER_IEEE;\n}\n\n \nu8 ice_dcb_get_num_tc(struct ice_dcbx_cfg *dcbcfg)\n{\n\tbool tc_unused = false;\n\tu8 num_tc = 0;\n\tu8 ret = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < CEE_DCBX_MAX_PRIO; i++)\n\t\tnum_tc |= BIT(dcbcfg->etscfg.prio_table[i]);\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tif (num_tc & BIT(i)) {\n\t\t\tif (!tc_unused) {\n\t\t\t\tret++;\n\t\t\t} else {\n\t\t\t\tpr_err(\"Non-contiguous TCs - Disabling DCB\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\ttc_unused = true;\n\t\t}\n\t}\n\n\t \n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}\n\n \nstatic u8 ice_get_first_droptc(struct ice_vsi *vsi)\n{\n\tstruct ice_dcbx_cfg *cfg = &vsi->port_info->qos_cfg.local_dcbx_cfg;\n\tstruct device *dev = ice_pf_to_dev(vsi->back);\n\tu8 num_tc, ena_tc_map, pfc_ena_map;\n\tu8 i;\n\n\tnum_tc = ice_dcb_get_num_tc(cfg);\n\n\t \n\tena_tc_map = ice_dcb_get_ena_tc(cfg);\n\n\t \n\tpfc_ena_map = cfg->pfc.pfcena;\n\n\t \n\tfor (i = 0; i < num_tc; i++) {\n\t\tif ((ena_tc_map & BIT(i)) && (!(pfc_ena_map & BIT(i)))) {\n\t\t\tdev_dbg(dev, \"first drop tc = %d\\n\", i);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"first drop tc = 0\\n\");\n\treturn 0;\n}\n\n \nvoid ice_vsi_set_dcb_tc_cfg(struct ice_vsi *vsi)\n{\n\tstruct ice_dcbx_cfg *cfg = &vsi->port_info->qos_cfg.local_dcbx_cfg;\n\n\tswitch (vsi->type) {\n\tcase ICE_VSI_PF:\n\t\tvsi->tc_cfg.ena_tc = ice_dcb_get_ena_tc(cfg);\n\t\tvsi->tc_cfg.numtc = ice_dcb_get_num_tc(cfg);\n\t\tbreak;\n\tcase ICE_VSI_CHNL:\n\t\tvsi->tc_cfg.ena_tc = BIT(ice_get_first_droptc(vsi));\n\t\tvsi->tc_cfg.numtc = 1;\n\t\tbreak;\n\tcase ICE_VSI_CTRL:\n\tcase ICE_VSI_LB:\n\tdefault:\n\t\tvsi->tc_cfg.ena_tc = ICE_DFLT_TRAFFIC_CLASS;\n\t\tvsi->tc_cfg.numtc = 1;\n\t}\n}\n\n \nu8 ice_dcb_get_tc(struct ice_vsi *vsi, int queue_index)\n{\n\treturn vsi->tx_rings[queue_index]->dcb_tc;\n}\n\n \nvoid ice_vsi_cfg_dcb_rings(struct ice_vsi *vsi)\n{\n\tstruct ice_tx_ring *tx_ring;\n\tstruct ice_rx_ring *rx_ring;\n\tu16 qoffset, qcount;\n\tint i, n;\n\n\tif (!test_bit(ICE_FLAG_DCB_ENA, vsi->back->flags)) {\n\t\t \n\t\tice_for_each_txq(vsi, i) {\n\t\t\ttx_ring = vsi->tx_rings[i];\n\t\t\ttx_ring->dcb_tc = 0;\n\t\t}\n\t\tice_for_each_rxq(vsi, i) {\n\t\t\trx_ring = vsi->rx_rings[i];\n\t\t\trx_ring->dcb_tc = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tice_for_each_traffic_class(n) {\n\t\tif (!(vsi->tc_cfg.ena_tc & BIT(n)))\n\t\t\tbreak;\n\n\t\tqoffset = vsi->tc_cfg.tc_info[n].qoffset;\n\t\tqcount = vsi->tc_cfg.tc_info[n].qcount_tx;\n\t\tfor (i = qoffset; i < (qoffset + qcount); i++)\n\t\t\tvsi->tx_rings[i]->dcb_tc = n;\n\n\t\tqcount = vsi->tc_cfg.tc_info[n].qcount_rx;\n\t\tfor (i = qoffset; i < (qoffset + qcount); i++)\n\t\t\tvsi->rx_rings[i]->dcb_tc = n;\n\t}\n\t \n\tif (vsi->all_enatc) {\n\t\tu8 first_droptc = ice_get_first_droptc(vsi);\n\n\t\t \n\t\tice_for_each_chnl_tc(n) {\n\t\t\tif (!(vsi->all_enatc & BIT(n)))\n\t\t\t\tbreak;\n\n\t\t\tqoffset = vsi->mqprio_qopt.qopt.offset[n];\n\t\t\tqcount = vsi->mqprio_qopt.qopt.count[n];\n\t\t\tfor (i = qoffset; i < (qoffset + qcount); i++) {\n\t\t\t\tvsi->tx_rings[i]->dcb_tc = first_droptc;\n\t\t\t\tvsi->rx_rings[i]->dcb_tc = first_droptc;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void ice_dcb_ena_dis_vsi(struct ice_pf *pf, bool ena, bool locked)\n{\n\tint i;\n\n\tice_for_each_vsi(pf, i) {\n\t\tstruct ice_vsi *vsi = pf->vsi[i];\n\n\t\tif (!vsi)\n\t\t\tcontinue;\n\n\t\tswitch (vsi->type) {\n\t\tcase ICE_VSI_CHNL:\n\t\tcase ICE_VSI_SWITCHDEV_CTRL:\n\t\tcase ICE_VSI_PF:\n\t\t\tif (ena)\n\t\t\t\tice_ena_vsi(vsi, locked);\n\t\t\telse\n\t\t\t\tice_dis_vsi(vsi, locked);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n \nint ice_dcb_bwchk(struct ice_pf *pf, struct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_dcb_ets_cfg *etscfg = &dcbcfg->etscfg;\n\tu8 num_tc, total_bw = 0;\n\tint i;\n\n\t \n\tnum_tc = ice_dcb_get_num_tc(dcbcfg);\n\n\t \n\tif (num_tc == 1) {\n\t\tetscfg->tcbwtable[0] = ICE_TC_MAX_BW;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < num_tc; i++)\n\t\ttotal_bw += etscfg->tcbwtable[i];\n\n\tif (!total_bw) {\n\t\tetscfg->tcbwtable[0] = ICE_TC_MAX_BW;\n\t} else if (total_bw != ICE_TC_MAX_BW) {\n\t\tdev_err(ice_pf_to_dev(pf), \"Invalid config, total bandwidth must equal 100\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint ice_pf_dcb_cfg(struct ice_pf *pf, struct ice_dcbx_cfg *new_cfg, bool locked)\n{\n\tstruct ice_aqc_port_ets_elem buf = { 0 };\n\tstruct ice_dcbx_cfg *old_cfg, *curr_cfg;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tint ret = ICE_DCB_NO_HW_CHG;\n\tstruct iidc_event *event;\n\tstruct ice_vsi *pf_vsi;\n\n\tcurr_cfg = &pf->hw.port_info->qos_cfg.local_dcbx_cfg;\n\n\t \n\tif (!pf->hw.port_info->qos_cfg.is_sw_lldp)\n\t\tret = ICE_DCB_HW_CHG_RST;\n\n\t \n\tif (ice_dcb_get_num_tc(new_cfg) > 1) {\n\t\tdev_dbg(dev, \"DCB tagging enabled (num TC > 1)\\n\");\n\t\tif (pf->hw.port_info->is_custom_tx_enabled) {\n\t\t\tdev_err(dev, \"Custom Tx scheduler feature enabled, can't configure DCB\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tice_tear_down_devlink_rate_tree(pf);\n\n\t\tset_bit(ICE_FLAG_DCB_ENA, pf->flags);\n\t} else {\n\t\tdev_dbg(dev, \"DCB tagging disabled (num TC = 1)\\n\");\n\t\tclear_bit(ICE_FLAG_DCB_ENA, pf->flags);\n\t}\n\n\tif (!memcmp(new_cfg, curr_cfg, sizeof(*new_cfg))) {\n\t\tdev_dbg(dev, \"No change in DCB config required\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ice_dcb_bwchk(pf, new_cfg))\n\t\treturn -EINVAL;\n\n\t \n\told_cfg = kmemdup(curr_cfg, sizeof(*old_cfg), GFP_KERNEL);\n\tif (!old_cfg)\n\t\treturn -ENOMEM;\n\n\tdev_info(dev, \"Commit DCB Configuration to the hardware\\n\");\n\tpf_vsi = ice_get_main_vsi(pf);\n\tif (!pf_vsi) {\n\t\tdev_dbg(dev, \"PF VSI doesn't exist\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_cfg;\n\t}\n\n\t \n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tret = -ENOMEM;\n\t\tgoto free_cfg;\n\t}\n\n\tset_bit(IIDC_EVENT_BEFORE_TC_CHANGE, event->type);\n\tice_send_event_to_aux(pf, event);\n\tkfree(event);\n\n\t \n\tif (!locked)\n\t\trtnl_lock();\n\n\t \n\tice_dcb_ena_dis_vsi(pf, false, true);\n\n\tmemcpy(curr_cfg, new_cfg, sizeof(*curr_cfg));\n\tmemcpy(&curr_cfg->etsrec, &curr_cfg->etscfg, sizeof(curr_cfg->etsrec));\n\tmemcpy(&new_cfg->etsrec, &curr_cfg->etscfg, sizeof(curr_cfg->etsrec));\n\n\t \n\tif (pf->hw.port_info->qos_cfg.is_sw_lldp) {\n\t\tret = ice_set_dcb_cfg(pf->hw.port_info);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Set DCB Config failed\\n\");\n\t\t\t \n\t\t\tmemcpy(curr_cfg, old_cfg, sizeof(*curr_cfg));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ice_query_port_ets(pf->hw.port_info, &buf, sizeof(buf), NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Query Port ETS failed\\n\");\n\t\tgoto out;\n\t}\n\n\tice_pf_dcb_recfg(pf, false);\n\nout:\n\t \n\tice_dcb_ena_dis_vsi(pf, true, true);\n\tif (!locked)\n\t\trtnl_unlock();\nfree_cfg:\n\tkfree(old_cfg);\n\treturn ret;\n}\n\n \nstatic void ice_cfg_etsrec_defaults(struct ice_port_info *pi)\n{\n\tstruct ice_dcbx_cfg *dcbcfg = &pi->qos_cfg.local_dcbx_cfg;\n\tu8 i;\n\n\t \n\tif (dcbcfg->etsrec.maxtcs)\n\t\treturn;\n\n\t \n\tdcbcfg->etsrec.maxtcs = 1;\n\tfor (i = 0; i < ICE_MAX_TRAFFIC_CLASS; i++) {\n\t\tdcbcfg->etsrec.tcbwtable[i] = i ? 0 : 100;\n\t\tdcbcfg->etsrec.tsatable[i] = i ? ICE_IEEE_TSA_STRICT :\n\t\t\t\t\t\t ICE_IEEE_TSA_ETS;\n\t}\n}\n\n \nstatic bool\nice_dcb_need_recfg(struct ice_pf *pf, struct ice_dcbx_cfg *old_cfg,\n\t\t   struct ice_dcbx_cfg *new_cfg)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tbool need_reconfig = false;\n\n\t \n\tif (memcmp(&new_cfg->etscfg, &old_cfg->etscfg,\n\t\t   sizeof(new_cfg->etscfg))) {\n\t\t \n\t\tif (memcmp(&new_cfg->etscfg.prio_table,\n\t\t\t   &old_cfg->etscfg.prio_table,\n\t\t\t   sizeof(new_cfg->etscfg.prio_table))) {\n\t\t\tneed_reconfig = true;\n\t\t\tdev_dbg(dev, \"ETS UP2TC changed.\\n\");\n\t\t}\n\n\t\tif (memcmp(&new_cfg->etscfg.tcbwtable,\n\t\t\t   &old_cfg->etscfg.tcbwtable,\n\t\t\t   sizeof(new_cfg->etscfg.tcbwtable)))\n\t\t\tdev_dbg(dev, \"ETS TC BW Table changed.\\n\");\n\n\t\tif (memcmp(&new_cfg->etscfg.tsatable,\n\t\t\t   &old_cfg->etscfg.tsatable,\n\t\t\t   sizeof(new_cfg->etscfg.tsatable)))\n\t\t\tdev_dbg(dev, \"ETS TSA Table changed.\\n\");\n\t}\n\n\t \n\tif (memcmp(&new_cfg->pfc, &old_cfg->pfc, sizeof(new_cfg->pfc))) {\n\t\tneed_reconfig = true;\n\t\tdev_dbg(dev, \"PFC config change detected.\\n\");\n\t}\n\n\t \n\tif (memcmp(&new_cfg->app, &old_cfg->app, sizeof(new_cfg->app))) {\n\t\tneed_reconfig = true;\n\t\tdev_dbg(dev, \"APP Table change detected.\\n\");\n\t}\n\n\tdev_dbg(dev, \"dcb need_reconfig=%d\\n\", need_reconfig);\n\treturn need_reconfig;\n}\n\n \nvoid ice_dcb_rebuild(struct ice_pf *pf)\n{\n\tstruct ice_aqc_port_ets_elem buf = { 0 };\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_dcbx_cfg *err_cfg;\n\tint ret;\n\n\tret = ice_query_port_ets(pf->hw.port_info, &buf, sizeof(buf), NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Query Port ETS failed\\n\");\n\t\tgoto dcb_error;\n\t}\n\n\tmutex_lock(&pf->tc_mutex);\n\n\tif (!pf->hw.port_info->qos_cfg.is_sw_lldp)\n\t\tice_cfg_etsrec_defaults(pf->hw.port_info);\n\n\tret = ice_set_dcb_cfg(pf->hw.port_info);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set DCB config in rebuild\\n\");\n\t\tgoto dcb_error;\n\t}\n\n\tif (!pf->hw.port_info->qos_cfg.is_sw_lldp) {\n\t\tret = ice_cfg_lldp_mib_change(&pf->hw, true);\n\t\tif (ret && !pf->hw.port_info->qos_cfg.is_sw_lldp) {\n\t\t\tdev_err(dev, \"Failed to register for MIB changes\\n\");\n\t\t\tgoto dcb_error;\n\t\t}\n\t}\n\n\tdev_info(dev, \"DCB info restored\\n\");\n\tret = ice_query_port_ets(pf->hw.port_info, &buf, sizeof(buf), NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Query Port ETS failed\\n\");\n\t\tgoto dcb_error;\n\t}\n\n\tmutex_unlock(&pf->tc_mutex);\n\n\treturn;\n\ndcb_error:\n\tdev_err(dev, \"Disabling DCB until new settings occur\\n\");\n\terr_cfg = kzalloc(sizeof(*err_cfg), GFP_KERNEL);\n\tif (!err_cfg) {\n\t\tmutex_unlock(&pf->tc_mutex);\n\t\treturn;\n\t}\n\n\terr_cfg->etscfg.willing = true;\n\terr_cfg->etscfg.tcbwtable[0] = ICE_TC_MAX_BW;\n\terr_cfg->etscfg.tsatable[0] = ICE_IEEE_TSA_ETS;\n\tmemcpy(&err_cfg->etsrec, &err_cfg->etscfg, sizeof(err_cfg->etsrec));\n\t \n\t \n\tice_pf_dcb_cfg(pf, err_cfg, false);\n\tkfree(err_cfg);\n\n\tmutex_unlock(&pf->tc_mutex);\n}\n\n \nstatic int ice_dcb_init_cfg(struct ice_pf *pf, bool locked)\n{\n\tstruct ice_dcbx_cfg *newcfg;\n\tstruct ice_port_info *pi;\n\tint ret = 0;\n\n\tpi = pf->hw.port_info;\n\tnewcfg = kmemdup(&pi->qos_cfg.local_dcbx_cfg, sizeof(*newcfg),\n\t\t\t GFP_KERNEL);\n\tif (!newcfg)\n\t\treturn -ENOMEM;\n\n\tmemset(&pi->qos_cfg.local_dcbx_cfg, 0, sizeof(*newcfg));\n\n\tdev_info(ice_pf_to_dev(pf), \"Configuring initial DCB values\\n\");\n\tif (ice_pf_dcb_cfg(pf, newcfg, locked))\n\t\tret = -EINVAL;\n\n\tkfree(newcfg);\n\n\treturn ret;\n}\n\n \nint ice_dcb_sw_dflt_cfg(struct ice_pf *pf, bool ets_willing, bool locked)\n{\n\tstruct ice_aqc_port_ets_elem buf = { 0 };\n\tstruct ice_dcbx_cfg *dcbcfg;\n\tstruct ice_port_info *pi;\n\tstruct ice_hw *hw;\n\tint ret;\n\n\thw = &pf->hw;\n\tpi = hw->port_info;\n\tdcbcfg = kzalloc(sizeof(*dcbcfg), GFP_KERNEL);\n\tif (!dcbcfg)\n\t\treturn -ENOMEM;\n\n\tmemset(&pi->qos_cfg.local_dcbx_cfg, 0, sizeof(*dcbcfg));\n\n\tdcbcfg->etscfg.willing = ets_willing ? 1 : 0;\n\tdcbcfg->etscfg.maxtcs = hw->func_caps.common_cap.maxtc;\n\tdcbcfg->etscfg.tcbwtable[0] = 100;\n\tdcbcfg->etscfg.tsatable[0] = ICE_IEEE_TSA_ETS;\n\n\tmemcpy(&dcbcfg->etsrec, &dcbcfg->etscfg,\n\t       sizeof(dcbcfg->etsrec));\n\tdcbcfg->etsrec.willing = 0;\n\n\tdcbcfg->pfc.willing = 1;\n\tdcbcfg->pfc.pfccap = hw->func_caps.common_cap.maxtc;\n\n\tdcbcfg->numapps = 1;\n\tdcbcfg->app[0].selector = ICE_APP_SEL_ETHTYPE;\n\tdcbcfg->app[0].priority = 3;\n\tdcbcfg->app[0].prot_id = ETH_P_FCOE;\n\n\tret = ice_pf_dcb_cfg(pf, dcbcfg, locked);\n\tkfree(dcbcfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ice_query_port_ets(pi, &buf, sizeof(buf), NULL);\n}\n\n \nstatic bool ice_dcb_tc_contig(u8 *prio_table)\n{\n\tbool found_empty = false;\n\tu8 used_tc = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < CEE_DCBX_MAX_PRIO; i++)\n\t\tused_tc |= BIT(prio_table[i]);\n\n\tfor (i = 0; i < CEE_DCBX_MAX_PRIO; i++) {\n\t\tif (used_tc & BIT(i)) {\n\t\t\tif (found_empty)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tfound_empty = true;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic int ice_dcb_noncontig_cfg(struct ice_pf *pf)\n{\n\tstruct ice_dcbx_cfg *dcbcfg = &pf->hw.port_info->qos_cfg.local_dcbx_cfg;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tint ret;\n\n\t \n\tret = ice_dcb_sw_dflt_cfg(pf, false, true);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set local DCB config %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdcbcfg->etscfg.willing = 1;\n\tret = ice_set_dcb_cfg(pf->hw.port_info);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to set DCB to unwilling\\n\");\n\n\treturn ret;\n}\n\n \nvoid ice_pf_dcb_recfg(struct ice_pf *pf, bool locked)\n{\n\tstruct ice_dcbx_cfg *dcbcfg = &pf->hw.port_info->qos_cfg.local_dcbx_cfg;\n\tstruct iidc_event *event;\n\tu8 tc_map = 0;\n\tint v, ret;\n\n\t \n\tice_for_each_vsi(pf, v) {\n\t\tstruct ice_vsi *vsi = pf->vsi[v];\n\n\t\tif (!vsi)\n\t\t\tcontinue;\n\n\t\tif (vsi->type == ICE_VSI_PF) {\n\t\t\ttc_map = ice_dcb_get_ena_tc(dcbcfg);\n\n\t\t\t \n\t\t\tif (!ice_dcb_tc_contig(dcbcfg->etscfg.prio_table)) {\n\t\t\t\ttc_map = ICE_DFLT_TRAFFIC_CLASS;\n\t\t\t\tice_dcb_noncontig_cfg(pf);\n\t\t\t}\n\t\t} else if (vsi->type == ICE_VSI_CHNL) {\n\t\t\ttc_map = BIT(ice_get_first_droptc(vsi));\n\t\t} else {\n\t\t\ttc_map = ICE_DFLT_TRAFFIC_CLASS;\n\t\t}\n\n\t\tret = ice_vsi_cfg_tc(vsi, tc_map);\n\t\tif (ret) {\n\t\t\tdev_err(ice_pf_to_dev(pf), \"Failed to config TC for VSI index: %d\\n\",\n\t\t\t\tvsi->idx);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (vsi->type == ICE_VSI_CHNL ||\n\t\t    vsi->type == ICE_VSI_SWITCHDEV_CTRL)\n\t\t\tcontinue;\n\n\t\tice_vsi_map_rings_to_vectors(vsi);\n\t\tif (vsi->type == ICE_VSI_PF)\n\t\t\tice_dcbnl_set_all(vsi);\n\t}\n\tif (!locked) {\n\t\t \n\t\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\t\tif (!event)\n\t\t\treturn;\n\n\t\tset_bit(IIDC_EVENT_AFTER_TC_CHANGE, event->type);\n\t\tice_send_event_to_aux(pf, event);\n\t\tkfree(event);\n\t}\n}\n\n \nint ice_init_pf_dcb(struct ice_pf *pf, bool locked)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_port_info *port_info;\n\tstruct ice_hw *hw = &pf->hw;\n\tint err;\n\n\tport_info = hw->port_info;\n\n\terr = ice_init_dcb(hw, false);\n\tif (err && !port_info->qos_cfg.is_sw_lldp) {\n\t\tdev_err(dev, \"Error initializing DCB %d\\n\", err);\n\t\tgoto dcb_init_err;\n\t}\n\n\tdev_info(dev, \"DCB is enabled in the hardware, max number of TCs supported on this port are %d\\n\",\n\t\t pf->hw.func_caps.common_cap.maxtc);\n\tif (err) {\n\t\tstruct ice_vsi *pf_vsi;\n\n\t\t \n\t\tdev_info(dev, \"FW LLDP is disabled, DCBx/LLDP in SW mode.\\n\");\n\t\tclear_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags);\n\t\terr = ice_aq_set_pfc_mode(&pf->hw, ICE_AQC_PFC_VLAN_BASED_PFC,\n\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\tdev_info(dev, \"Failed to set VLAN PFC mode\\n\");\n\n\t\terr = ice_dcb_sw_dflt_cfg(pf, true, locked);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to set local DCB config %d\\n\",\n\t\t\t\terr);\n\t\t\terr = -EIO;\n\t\t\tgoto dcb_init_err;\n\t\t}\n\n\t\t \n\t\tpf_vsi = ice_get_main_vsi(pf);\n\t\tif (!pf_vsi) {\n\t\t\tdev_err(dev, \"Failed to set local DCB config\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto dcb_init_err;\n\t\t}\n\n\t\tice_cfg_sw_lldp(pf_vsi, false, true);\n\n\t\tpf->dcbx_cap = ice_dcb_get_mode(port_info, true);\n\t\treturn 0;\n\t}\n\n\tset_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags);\n\n\t \n\tpf->dcbx_cap = ice_dcb_get_mode(port_info, false);\n\n\terr = ice_dcb_init_cfg(pf, locked);\n\tif (err)\n\t\tgoto dcb_init_err;\n\n\treturn 0;\n\ndcb_init_err:\n\tdev_err(dev, \"DCB init failed\\n\");\n\treturn err;\n}\n\n \nvoid ice_update_dcb_stats(struct ice_pf *pf)\n{\n\tstruct ice_hw_port_stats *prev_ps, *cur_ps;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 port;\n\tint i;\n\n\tport = hw->port_info->lport;\n\tprev_ps = &pf->stats_prev;\n\tcur_ps = &pf->stats;\n\n\tif (ice_is_reset_in_progress(pf->state))\n\t\tpf->stat_prev_loaded = false;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tice_stat_update32(hw, GLPRT_PXOFFRXC(port, i),\n\t\t\t\t  pf->stat_prev_loaded,\n\t\t\t\t  &prev_ps->priority_xoff_rx[i],\n\t\t\t\t  &cur_ps->priority_xoff_rx[i]);\n\t\tice_stat_update32(hw, GLPRT_PXONRXC(port, i),\n\t\t\t\t  pf->stat_prev_loaded,\n\t\t\t\t  &prev_ps->priority_xon_rx[i],\n\t\t\t\t  &cur_ps->priority_xon_rx[i]);\n\t\tice_stat_update32(hw, GLPRT_PXONTXC(port, i),\n\t\t\t\t  pf->stat_prev_loaded,\n\t\t\t\t  &prev_ps->priority_xon_tx[i],\n\t\t\t\t  &cur_ps->priority_xon_tx[i]);\n\t\tice_stat_update32(hw, GLPRT_PXOFFTXC(port, i),\n\t\t\t\t  pf->stat_prev_loaded,\n\t\t\t\t  &prev_ps->priority_xoff_tx[i],\n\t\t\t\t  &cur_ps->priority_xoff_tx[i]);\n\t\tice_stat_update32(hw, GLPRT_RXON2OFFCNT(port, i),\n\t\t\t\t  pf->stat_prev_loaded,\n\t\t\t\t  &prev_ps->priority_xon_2_xoff[i],\n\t\t\t\t  &cur_ps->priority_xon_2_xoff[i]);\n\t}\n}\n\n \nvoid\nice_tx_prepare_vlan_flags_dcb(struct ice_tx_ring *tx_ring,\n\t\t\t      struct ice_tx_buf *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\n\tif (!test_bit(ICE_FLAG_DCB_ENA, tx_ring->vsi->back->flags))\n\t\treturn;\n\n\t \n\tif ((first->tx_flags & ICE_TX_FLAGS_HW_VLAN ||\n\t     first->tx_flags & ICE_TX_FLAGS_HW_OUTER_SINGLE_VLAN) ||\n\t    skb->priority != TC_PRIO_CONTROL) {\n\t\tfirst->vid &= ~VLAN_PRIO_MASK;\n\t\t \n\t\tfirst->vid |= (skb->priority << VLAN_PRIO_SHIFT) & VLAN_PRIO_MASK;\n\t\t \n\t\tif (tx_ring->flags & ICE_TX_FLAGS_RING_VLAN_L2TAG2)\n\t\t\tfirst->tx_flags |= ICE_TX_FLAGS_HW_OUTER_SINGLE_VLAN;\n\t\telse\n\t\t\tfirst->tx_flags |= ICE_TX_FLAGS_HW_VLAN;\n\t}\n}\n\n \nstatic bool ice_dcb_is_mib_change_pending(u8 state)\n{\n\treturn ICE_AQ_LLDP_MIB_CHANGE_PENDING ==\n\t\tFIELD_GET(ICE_AQ_LLDP_MIB_CHANGE_STATE_M, state);\n}\n\n \nvoid\nice_dcb_process_lldp_set_mib_change(struct ice_pf *pf,\n\t\t\t\t    struct ice_rq_event_info *event)\n{\n\tstruct ice_aqc_port_ets_elem buf = { 0 };\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_aqc_lldp_get_mib *mib;\n\tstruct ice_dcbx_cfg tmp_dcbx_cfg;\n\tbool pending_handled = true;\n\tbool need_reconfig = false;\n\tstruct ice_port_info *pi;\n\tu8 mib_type;\n\tint ret;\n\n\t \n\tif (!(test_bit(ICE_FLAG_DCB_CAPABLE, pf->flags)))\n\t\treturn;\n\n\tif (pf->dcbx_cap & DCB_CAP_DCBX_HOST) {\n\t\tdev_dbg(dev, \"MIB Change Event in HOST mode\\n\");\n\t\treturn;\n\t}\n\n\tpi = pf->hw.port_info;\n\tmib = (struct ice_aqc_lldp_get_mib *)&event->desc.params.raw;\n\n\t \n\tmib_type = FIELD_GET(ICE_AQ_LLDP_BRID_TYPE_M, mib->type);\n\tdev_dbg(dev, \"LLDP event MIB bridge type 0x%x\\n\", mib_type);\n\tif (mib_type != ICE_AQ_LLDP_BRID_TYPE_NEAREST_BRID)\n\t\treturn;\n\n\t \n\tif (ice_dcb_is_mib_change_pending(mib->state))\n\t\tpending_handled = false;\n\n\t \n\tmib_type = FIELD_GET(ICE_AQ_LLDP_MIB_TYPE_M, mib->type);\n\tdev_dbg(dev, \"LLDP event mib type %s\\n\", mib_type ? \"remote\" : \"local\");\n\tif (mib_type == ICE_AQ_LLDP_MIB_REMOTE) {\n\t\t \n\t\tif (!pending_handled) {\n\t\t\tice_get_dcb_cfg_from_mib_change(pi, event);\n\t\t} else {\n\t\t\tret =\n\t\t\t  ice_aq_get_dcb_cfg(pi->hw, ICE_AQ_LLDP_MIB_REMOTE,\n\t\t\t\t\t     ICE_AQ_LLDP_BRID_TYPE_NEAREST_BRID,\n\t\t\t\t\t     &pi->qos_cfg.remote_dcbx_cfg);\n\t\t\tif (ret)\n\t\t\t\tdev_dbg(dev, \"Failed to get remote DCB config\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&pf->tc_mutex);\n\n\t \n\ttmp_dcbx_cfg = pi->qos_cfg.local_dcbx_cfg;\n\n\t \n\tmemset(&pi->qos_cfg.local_dcbx_cfg, 0,\n\t       sizeof(pi->qos_cfg.local_dcbx_cfg));\n\n\t \n\tif (!pending_handled) {\n\t\tice_get_dcb_cfg_from_mib_change(pi, event);\n\t} else {\n\t\tret = ice_get_dcb_cfg(pi);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to get DCB config\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!memcmp(&tmp_dcbx_cfg, &pi->qos_cfg.local_dcbx_cfg,\n\t\t    sizeof(tmp_dcbx_cfg))) {\n\t\tdev_dbg(dev, \"No change detected in DCBX configuration.\\n\");\n\t\tgoto out;\n\t}\n\n\tpf->dcbx_cap = ice_dcb_get_mode(pi, false);\n\n\tneed_reconfig = ice_dcb_need_recfg(pf, &tmp_dcbx_cfg,\n\t\t\t\t\t   &pi->qos_cfg.local_dcbx_cfg);\n\tice_dcbnl_flush_apps(pf, &tmp_dcbx_cfg, &pi->qos_cfg.local_dcbx_cfg);\n\tif (!need_reconfig)\n\t\tgoto out;\n\n\t \n\tif (ice_dcb_get_num_tc(&pi->qos_cfg.local_dcbx_cfg) > 1) {\n\t\tdev_dbg(dev, \"DCB tagging enabled (num TC > 1)\\n\");\n\t\tset_bit(ICE_FLAG_DCB_ENA, pf->flags);\n\t} else {\n\t\tdev_dbg(dev, \"DCB tagging disabled (num TC = 1)\\n\");\n\t\tclear_bit(ICE_FLAG_DCB_ENA, pf->flags);\n\t}\n\n\t \n\tif (!pending_handled) {\n\t\tice_lldp_execute_pending_mib(&pf->hw);\n\t\tpending_handled = true;\n\t}\n\n\trtnl_lock();\n\t \n\tice_dcb_ena_dis_vsi(pf, false, true);\n\n\tret = ice_query_port_ets(pi, &buf, sizeof(buf), NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Query Port ETS failed\\n\");\n\t\tgoto unlock_rtnl;\n\t}\n\n\t \n\tice_pf_dcb_recfg(pf, false);\n\n\t \n\tice_dcb_ena_dis_vsi(pf, true, true);\nunlock_rtnl:\n\trtnl_unlock();\nout:\n\tmutex_unlock(&pf->tc_mutex);\n\n\t \n\tif (!pending_handled)\n\t\tice_lldp_execute_pending_mib(&pf->hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}