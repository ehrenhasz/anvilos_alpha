{
  "module_name": "ice_ethtool.c",
  "hash_id": "44d9f8a921e47e3b2163a8af1f454fa5bf2e4074f05628adb6d54ef9dfdf8c7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include \"ice.h\"\n#include \"ice_ethtool.h\"\n#include \"ice_flow.h\"\n#include \"ice_fltr.h\"\n#include \"ice_lib.h\"\n#include \"ice_dcb_lib.h\"\n#include <net/dcbnl.h>\n\nstruct ice_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define ICE_STAT(_type, _name, _stat) { \\\n\t.stat_string = _name, \\\n\t.sizeof_stat = sizeof_field(_type, _stat), \\\n\t.stat_offset = offsetof(_type, _stat) \\\n}\n\n#define ICE_VSI_STAT(_name, _stat) \\\n\t\tICE_STAT(struct ice_vsi, _name, _stat)\n#define ICE_PF_STAT(_name, _stat) \\\n\t\tICE_STAT(struct ice_pf, _name, _stat)\n\nstatic int ice_q_stats_len(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\n\treturn ((np->vsi->alloc_txq + np->vsi->alloc_rxq) *\n\t\t(sizeof(struct ice_q_stats) / sizeof(u64)));\n}\n\n#define ICE_PF_STATS_LEN\tARRAY_SIZE(ice_gstrings_pf_stats)\n#define ICE_VSI_STATS_LEN\tARRAY_SIZE(ice_gstrings_vsi_stats)\n\n#define ICE_PFC_STATS_LEN ( \\\n\t\t(sizeof_field(struct ice_pf, stats.priority_xoff_rx) + \\\n\t\t sizeof_field(struct ice_pf, stats.priority_xon_rx) + \\\n\t\t sizeof_field(struct ice_pf, stats.priority_xoff_tx) + \\\n\t\t sizeof_field(struct ice_pf, stats.priority_xon_tx)) \\\n\t\t / sizeof(u64))\n#define ICE_ALL_STATS_LEN(n)\t(ICE_PF_STATS_LEN + ICE_PFC_STATS_LEN + \\\n\t\t\t\t ICE_VSI_STATS_LEN + ice_q_stats_len(n))\n\nstatic const struct ice_stats ice_gstrings_vsi_stats[] = {\n\tICE_VSI_STAT(\"rx_unicast\", eth_stats.rx_unicast),\n\tICE_VSI_STAT(\"tx_unicast\", eth_stats.tx_unicast),\n\tICE_VSI_STAT(\"rx_multicast\", eth_stats.rx_multicast),\n\tICE_VSI_STAT(\"tx_multicast\", eth_stats.tx_multicast),\n\tICE_VSI_STAT(\"rx_broadcast\", eth_stats.rx_broadcast),\n\tICE_VSI_STAT(\"tx_broadcast\", eth_stats.tx_broadcast),\n\tICE_VSI_STAT(\"rx_bytes\", eth_stats.rx_bytes),\n\tICE_VSI_STAT(\"tx_bytes\", eth_stats.tx_bytes),\n\tICE_VSI_STAT(\"rx_dropped\", eth_stats.rx_discards),\n\tICE_VSI_STAT(\"rx_unknown_protocol\", eth_stats.rx_unknown_protocol),\n\tICE_VSI_STAT(\"rx_alloc_fail\", rx_buf_failed),\n\tICE_VSI_STAT(\"rx_pg_alloc_fail\", rx_page_failed),\n\tICE_VSI_STAT(\"tx_errors\", eth_stats.tx_errors),\n\tICE_VSI_STAT(\"tx_linearize\", tx_linearize),\n\tICE_VSI_STAT(\"tx_busy\", tx_busy),\n\tICE_VSI_STAT(\"tx_restart\", tx_restart),\n};\n\nenum ice_ethtool_test_id {\n\tICE_ETH_TEST_REG = 0,\n\tICE_ETH_TEST_EEPROM,\n\tICE_ETH_TEST_INTR,\n\tICE_ETH_TEST_LOOP,\n\tICE_ETH_TEST_LINK,\n};\n\nstatic const char ice_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register test  (offline)\",\n\t\"EEPROM test    (offline)\",\n\t\"Interrupt test (offline)\",\n\t\"Loopback test  (offline)\",\n\t\"Link test   (on/offline)\",\n};\n\n#define ICE_TEST_LEN (sizeof(ice_gstrings_test) / ETH_GSTRING_LEN)\n\n \nstatic const struct ice_stats ice_gstrings_pf_stats[] = {\n\tICE_PF_STAT(\"rx_bytes.nic\", stats.eth.rx_bytes),\n\tICE_PF_STAT(\"tx_bytes.nic\", stats.eth.tx_bytes),\n\tICE_PF_STAT(\"rx_unicast.nic\", stats.eth.rx_unicast),\n\tICE_PF_STAT(\"tx_unicast.nic\", stats.eth.tx_unicast),\n\tICE_PF_STAT(\"rx_multicast.nic\", stats.eth.rx_multicast),\n\tICE_PF_STAT(\"tx_multicast.nic\", stats.eth.tx_multicast),\n\tICE_PF_STAT(\"rx_broadcast.nic\", stats.eth.rx_broadcast),\n\tICE_PF_STAT(\"tx_broadcast.nic\", stats.eth.tx_broadcast),\n\tICE_PF_STAT(\"tx_errors.nic\", stats.eth.tx_errors),\n\tICE_PF_STAT(\"tx_timeout.nic\", tx_timeout_count),\n\tICE_PF_STAT(\"rx_size_64.nic\", stats.rx_size_64),\n\tICE_PF_STAT(\"tx_size_64.nic\", stats.tx_size_64),\n\tICE_PF_STAT(\"rx_size_127.nic\", stats.rx_size_127),\n\tICE_PF_STAT(\"tx_size_127.nic\", stats.tx_size_127),\n\tICE_PF_STAT(\"rx_size_255.nic\", stats.rx_size_255),\n\tICE_PF_STAT(\"tx_size_255.nic\", stats.tx_size_255),\n\tICE_PF_STAT(\"rx_size_511.nic\", stats.rx_size_511),\n\tICE_PF_STAT(\"tx_size_511.nic\", stats.tx_size_511),\n\tICE_PF_STAT(\"rx_size_1023.nic\", stats.rx_size_1023),\n\tICE_PF_STAT(\"tx_size_1023.nic\", stats.tx_size_1023),\n\tICE_PF_STAT(\"rx_size_1522.nic\", stats.rx_size_1522),\n\tICE_PF_STAT(\"tx_size_1522.nic\", stats.tx_size_1522),\n\tICE_PF_STAT(\"rx_size_big.nic\", stats.rx_size_big),\n\tICE_PF_STAT(\"tx_size_big.nic\", stats.tx_size_big),\n\tICE_PF_STAT(\"link_xon_rx.nic\", stats.link_xon_rx),\n\tICE_PF_STAT(\"link_xon_tx.nic\", stats.link_xon_tx),\n\tICE_PF_STAT(\"link_xoff_rx.nic\", stats.link_xoff_rx),\n\tICE_PF_STAT(\"link_xoff_tx.nic\", stats.link_xoff_tx),\n\tICE_PF_STAT(\"tx_dropped_link_down.nic\", stats.tx_dropped_link_down),\n\tICE_PF_STAT(\"rx_undersize.nic\", stats.rx_undersize),\n\tICE_PF_STAT(\"rx_fragments.nic\", stats.rx_fragments),\n\tICE_PF_STAT(\"rx_oversize.nic\", stats.rx_oversize),\n\tICE_PF_STAT(\"rx_jabber.nic\", stats.rx_jabber),\n\tICE_PF_STAT(\"rx_csum_bad.nic\", hw_csum_rx_error),\n\tICE_PF_STAT(\"rx_length_errors.nic\", stats.rx_len_errors),\n\tICE_PF_STAT(\"rx_dropped.nic\", stats.eth.rx_discards),\n\tICE_PF_STAT(\"rx_crc_errors.nic\", stats.crc_errors),\n\tICE_PF_STAT(\"illegal_bytes.nic\", stats.illegal_bytes),\n\tICE_PF_STAT(\"mac_local_faults.nic\", stats.mac_local_faults),\n\tICE_PF_STAT(\"mac_remote_faults.nic\", stats.mac_remote_faults),\n\tICE_PF_STAT(\"fdir_sb_match.nic\", stats.fd_sb_match),\n\tICE_PF_STAT(\"fdir_sb_status.nic\", stats.fd_sb_status),\n\tICE_PF_STAT(\"tx_hwtstamp_skipped\", ptp.tx_hwtstamp_skipped),\n\tICE_PF_STAT(\"tx_hwtstamp_timeouts\", ptp.tx_hwtstamp_timeouts),\n\tICE_PF_STAT(\"tx_hwtstamp_flushed\", ptp.tx_hwtstamp_flushed),\n\tICE_PF_STAT(\"tx_hwtstamp_discarded\", ptp.tx_hwtstamp_discarded),\n\tICE_PF_STAT(\"late_cached_phc_updates\", ptp.late_cached_phc_updates),\n};\n\nstatic const u32 ice_regs_dump_list[] = {\n\tPFGEN_STATE,\n\tPRTGEN_STATUS,\n\tQRX_CTRL(0),\n\tQINT_TQCTL(0),\n\tQINT_RQCTL(0),\n\tPFINT_OICR_ENA,\n\tQRX_ITR(0),\n#define GLDCB_TLPM_PCI_DM\t\t\t0x000A0180\n\tGLDCB_TLPM_PCI_DM,\n#define GLDCB_TLPM_TC2PFC\t\t\t0x000A0194\n\tGLDCB_TLPM_TC2PFC,\n#define TCDCB_TLPM_WAIT_DM(_i)\t\t\t(0x000A0080 + ((_i) * 4))\n\tTCDCB_TLPM_WAIT_DM(0),\n\tTCDCB_TLPM_WAIT_DM(1),\n\tTCDCB_TLPM_WAIT_DM(2),\n\tTCDCB_TLPM_WAIT_DM(3),\n\tTCDCB_TLPM_WAIT_DM(4),\n\tTCDCB_TLPM_WAIT_DM(5),\n\tTCDCB_TLPM_WAIT_DM(6),\n\tTCDCB_TLPM_WAIT_DM(7),\n\tTCDCB_TLPM_WAIT_DM(8),\n\tTCDCB_TLPM_WAIT_DM(9),\n\tTCDCB_TLPM_WAIT_DM(10),\n\tTCDCB_TLPM_WAIT_DM(11),\n\tTCDCB_TLPM_WAIT_DM(12),\n\tTCDCB_TLPM_WAIT_DM(13),\n\tTCDCB_TLPM_WAIT_DM(14),\n\tTCDCB_TLPM_WAIT_DM(15),\n\tTCDCB_TLPM_WAIT_DM(16),\n\tTCDCB_TLPM_WAIT_DM(17),\n\tTCDCB_TLPM_WAIT_DM(18),\n\tTCDCB_TLPM_WAIT_DM(19),\n\tTCDCB_TLPM_WAIT_DM(20),\n\tTCDCB_TLPM_WAIT_DM(21),\n\tTCDCB_TLPM_WAIT_DM(22),\n\tTCDCB_TLPM_WAIT_DM(23),\n\tTCDCB_TLPM_WAIT_DM(24),\n\tTCDCB_TLPM_WAIT_DM(25),\n\tTCDCB_TLPM_WAIT_DM(26),\n\tTCDCB_TLPM_WAIT_DM(27),\n\tTCDCB_TLPM_WAIT_DM(28),\n\tTCDCB_TLPM_WAIT_DM(29),\n\tTCDCB_TLPM_WAIT_DM(30),\n\tTCDCB_TLPM_WAIT_DM(31),\n#define GLPCI_WATMK_CLNT_PIPEMON\t\t0x000BFD90\n\tGLPCI_WATMK_CLNT_PIPEMON,\n#define GLPCI_CUR_CLNT_COMMON\t\t\t0x000BFD84\n\tGLPCI_CUR_CLNT_COMMON,\n#define GLPCI_CUR_CLNT_PIPEMON\t\t\t0x000BFD88\n\tGLPCI_CUR_CLNT_PIPEMON,\n#define GLPCI_PCIERR\t\t\t\t0x0009DEB0\n\tGLPCI_PCIERR,\n#define GLPSM_DEBUG_CTL_STATUS\t\t\t0x000B0600\n\tGLPSM_DEBUG_CTL_STATUS,\n#define GLPSM0_DEBUG_FIFO_OVERFLOW_DETECT\t0x000B0680\n\tGLPSM0_DEBUG_FIFO_OVERFLOW_DETECT,\n#define GLPSM0_DEBUG_FIFO_UNDERFLOW_DETECT\t0x000B0684\n\tGLPSM0_DEBUG_FIFO_UNDERFLOW_DETECT,\n#define GLPSM0_DEBUG_DT_OUT_OF_WINDOW\t\t0x000B0688\n\tGLPSM0_DEBUG_DT_OUT_OF_WINDOW,\n#define GLPSM0_DEBUG_INTF_HW_ERROR_DETECT\t0x000B069C\n\tGLPSM0_DEBUG_INTF_HW_ERROR_DETECT,\n#define GLPSM0_DEBUG_MISC_HW_ERROR_DETECT\t0x000B06A0\n\tGLPSM0_DEBUG_MISC_HW_ERROR_DETECT,\n#define GLPSM1_DEBUG_FIFO_OVERFLOW_DETECT\t0x000B0E80\n\tGLPSM1_DEBUG_FIFO_OVERFLOW_DETECT,\n#define GLPSM1_DEBUG_FIFO_UNDERFLOW_DETECT\t0x000B0E84\n\tGLPSM1_DEBUG_FIFO_UNDERFLOW_DETECT,\n#define GLPSM1_DEBUG_SRL_FIFO_OVERFLOW_DETECT\t0x000B0E88\n\tGLPSM1_DEBUG_SRL_FIFO_OVERFLOW_DETECT,\n#define GLPSM1_DEBUG_SRL_FIFO_UNDERFLOW_DETECT  0x000B0E8C\n\tGLPSM1_DEBUG_SRL_FIFO_UNDERFLOW_DETECT,\n#define GLPSM1_DEBUG_MISC_HW_ERROR_DETECT       0x000B0E90\n\tGLPSM1_DEBUG_MISC_HW_ERROR_DETECT,\n#define GLPSM2_DEBUG_FIFO_OVERFLOW_DETECT       0x000B1680\n\tGLPSM2_DEBUG_FIFO_OVERFLOW_DETECT,\n#define GLPSM2_DEBUG_FIFO_UNDERFLOW_DETECT      0x000B1684\n\tGLPSM2_DEBUG_FIFO_UNDERFLOW_DETECT,\n#define GLPSM2_DEBUG_MISC_HW_ERROR_DETECT       0x000B1688\n\tGLPSM2_DEBUG_MISC_HW_ERROR_DETECT,\n#define GLTDPU_TCLAN_COMP_BOB(_i)               (0x00049ADC + ((_i) * 4))\n\tGLTDPU_TCLAN_COMP_BOB(1),\n\tGLTDPU_TCLAN_COMP_BOB(2),\n\tGLTDPU_TCLAN_COMP_BOB(3),\n\tGLTDPU_TCLAN_COMP_BOB(4),\n\tGLTDPU_TCLAN_COMP_BOB(5),\n\tGLTDPU_TCLAN_COMP_BOB(6),\n\tGLTDPU_TCLAN_COMP_BOB(7),\n\tGLTDPU_TCLAN_COMP_BOB(8),\n#define GLTDPU_TCB_CMD_BOB(_i)                  (0x0004975C + ((_i) * 4))\n\tGLTDPU_TCB_CMD_BOB(1),\n\tGLTDPU_TCB_CMD_BOB(2),\n\tGLTDPU_TCB_CMD_BOB(3),\n\tGLTDPU_TCB_CMD_BOB(4),\n\tGLTDPU_TCB_CMD_BOB(5),\n\tGLTDPU_TCB_CMD_BOB(6),\n\tGLTDPU_TCB_CMD_BOB(7),\n\tGLTDPU_TCB_CMD_BOB(8),\n#define GLTDPU_PSM_UPDATE_BOB(_i)               (0x00049B5C + ((_i) * 4))\n\tGLTDPU_PSM_UPDATE_BOB(1),\n\tGLTDPU_PSM_UPDATE_BOB(2),\n\tGLTDPU_PSM_UPDATE_BOB(3),\n\tGLTDPU_PSM_UPDATE_BOB(4),\n\tGLTDPU_PSM_UPDATE_BOB(5),\n\tGLTDPU_PSM_UPDATE_BOB(6),\n\tGLTDPU_PSM_UPDATE_BOB(7),\n\tGLTDPU_PSM_UPDATE_BOB(8),\n#define GLTCB_CMD_IN_BOB(_i)                    (0x000AE288 + ((_i) * 4))\n\tGLTCB_CMD_IN_BOB(1),\n\tGLTCB_CMD_IN_BOB(2),\n\tGLTCB_CMD_IN_BOB(3),\n\tGLTCB_CMD_IN_BOB(4),\n\tGLTCB_CMD_IN_BOB(5),\n\tGLTCB_CMD_IN_BOB(6),\n\tGLTCB_CMD_IN_BOB(7),\n\tGLTCB_CMD_IN_BOB(8),\n#define GLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(_i)   (0x000FC148 + ((_i) * 4))\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(1),\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(2),\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(3),\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(4),\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(5),\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(6),\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(7),\n\tGLLAN_TCLAN_FETCH_CTL_FBK_BOB_CTL(8),\n#define GLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(_i) (0x000FC248 + ((_i) * 4))\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(1),\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(2),\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(3),\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(4),\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(5),\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(6),\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(7),\n\tGLLAN_TCLAN_FETCH_CTL_SCHED_BOB_CTL(8),\n#define GLLAN_TCLAN_CACHE_CTL_BOB_CTL(_i)       (0x000FC1C8 + ((_i) * 4))\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(1),\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(2),\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(3),\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(4),\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(5),\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(6),\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(7),\n\tGLLAN_TCLAN_CACHE_CTL_BOB_CTL(8),\n#define GLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(_i)  (0x000FC188 + ((_i) * 4))\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(1),\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(2),\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(3),\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(4),\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(5),\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(6),\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(7),\n\tGLLAN_TCLAN_FETCH_CTL_PROC_BOB_CTL(8),\n#define GLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(_i) (0x000FC288 + ((_i) * 4))\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(1),\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(2),\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(3),\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(4),\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(5),\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(6),\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(7),\n\tGLLAN_TCLAN_FETCH_CTL_PCIE_RD_BOB_CTL(8),\n#define PRTDCB_TCUPM_REG_CM(_i)\t\t\t(0x000BC360 + ((_i) * 4))\n\tPRTDCB_TCUPM_REG_CM(0),\n\tPRTDCB_TCUPM_REG_CM(1),\n\tPRTDCB_TCUPM_REG_CM(2),\n\tPRTDCB_TCUPM_REG_CM(3),\n#define PRTDCB_TCUPM_REG_DM(_i)\t\t\t(0x000BC3A0 + ((_i) * 4))\n\tPRTDCB_TCUPM_REG_DM(0),\n\tPRTDCB_TCUPM_REG_DM(1),\n\tPRTDCB_TCUPM_REG_DM(2),\n\tPRTDCB_TCUPM_REG_DM(3),\n#define PRTDCB_TLPM_REG_DM(_i)\t\t\t(0x000A0000 + ((_i) * 4))\n\tPRTDCB_TLPM_REG_DM(0),\n\tPRTDCB_TLPM_REG_DM(1),\n\tPRTDCB_TLPM_REG_DM(2),\n\tPRTDCB_TLPM_REG_DM(3),\n};\n\nstruct ice_priv_flag {\n\tchar name[ETH_GSTRING_LEN];\n\tu32 bitno;\t\t\t \n};\n\n#define ICE_PRIV_FLAG(_name, _bitno) { \\\n\t.name = _name, \\\n\t.bitno = _bitno, \\\n}\n\nstatic const struct ice_priv_flag ice_gstrings_priv_flags[] = {\n\tICE_PRIV_FLAG(\"link-down-on-close\", ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA),\n\tICE_PRIV_FLAG(\"fw-lldp-agent\", ICE_FLAG_FW_LLDP_AGENT),\n\tICE_PRIV_FLAG(\"vf-true-promisc-support\",\n\t\t      ICE_FLAG_VF_TRUE_PROMISC_ENA),\n\tICE_PRIV_FLAG(\"mdd-auto-reset-vf\", ICE_FLAG_MDD_AUTO_RESET_VF),\n\tICE_PRIV_FLAG(\"vf-vlan-pruning\", ICE_FLAG_VF_VLAN_PRUNING),\n\tICE_PRIV_FLAG(\"legacy-rx\", ICE_FLAG_LEGACY_RX),\n};\n\n#define ICE_PRIV_FLAG_ARRAY_SIZE\tARRAY_SIZE(ice_gstrings_priv_flags)\n\nstatic void\n__ice_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo,\n\t\t  struct ice_vsi *vsi)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_orom_info *orom;\n\tstruct ice_nvm_info *nvm;\n\n\tnvm = &hw->flash.nvm;\n\torom = &hw->flash.orom;\n\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME, sizeof(drvinfo->driver));\n\n\t \n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%x.%02x 0x%x %d.%d.%d\", nvm->major, nvm->minor,\n\t\t nvm->eetrack, orom->major, orom->build, orom->patch);\n\n\tstrscpy(drvinfo->bus_info, pci_name(pf->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void\nice_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\n\t__ice_get_drvinfo(netdev, drvinfo, np->vsi);\n\tdrvinfo->n_priv_flags = ICE_PRIV_FLAG_ARRAY_SIZE;\n}\n\nstatic int ice_get_regs_len(struct net_device __always_unused *netdev)\n{\n\treturn sizeof(ice_regs_dump_list);\n}\n\nstatic void\nice_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tu32 *regs_buf = (u32 *)p;\n\tunsigned int i;\n\n\tregs->version = 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(ice_regs_dump_list); ++i)\n\t\tregs_buf[i] = rd32(hw, ice_regs_dump_list[i]);\n}\n\nstatic u32 ice_get_msglevel(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\n#ifndef CONFIG_DYNAMIC_DEBUG\n\tif (pf->hw.debug_mask)\n\t\tnetdev_info(netdev, \"hw debug_mask: 0x%llX\\n\",\n\t\t\t    pf->hw.debug_mask);\n#endif  \n\n\treturn pf->msg_enable;\n}\n\nstatic void ice_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\n#ifndef CONFIG_DYNAMIC_DEBUG\n\tif (ICE_DBG_USER & data)\n\t\tpf->hw.debug_mask = data;\n\telse\n\t\tpf->msg_enable = data;\n#else\n\tpf->msg_enable = data;\n#endif  \n}\n\nstatic int ice_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\n\treturn (int)pf->hw.flash.flash_size;\n}\n\nstatic int\nice_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom,\n\t       u8 *bytes)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct device *dev;\n\tint ret;\n\tu8 *buf;\n\n\tdev = ice_pf_to_dev(pf);\n\n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\tnetdev_dbg(netdev, \"GEEPROM cmd 0x%08x, offset 0x%08x, len 0x%08x\\n\",\n\t\t   eeprom->cmd, eeprom->offset, eeprom->len);\n\n\tbuf = kzalloc(eeprom->len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = ice_acquire_nvm(hw, ICE_RES_READ);\n\tif (ret) {\n\t\tdev_err(dev, \"ice_acquire_nvm failed, err %d aq_err %s\\n\",\n\t\t\tret, ice_aq_str(hw->adminq.sq_last_status));\n\t\tgoto out;\n\t}\n\n\tret = ice_read_flat_nvm(hw, eeprom->offset, &eeprom->len, buf,\n\t\t\t\tfalse);\n\tif (ret) {\n\t\tdev_err(dev, \"ice_read_flat_nvm failed, err %d aq_err %s\\n\",\n\t\t\tret, ice_aq_str(hw->adminq.sq_last_status));\n\t\tgoto release;\n\t}\n\n\tmemcpy(bytes, buf, eeprom->len);\nrelease:\n\tice_release_nvm(hw);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic bool ice_active_vfs(struct ice_pf *pf)\n{\n\tbool active = false;\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\trcu_read_lock();\n\tice_for_each_vf_rcu(pf, bkt, vf) {\n\t\tif (test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {\n\t\t\tactive = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn active;\n}\n\n \nstatic u64 ice_link_test(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tbool link_up = false;\n\tint status;\n\n\tnetdev_info(netdev, \"link test\\n\");\n\tstatus = ice_get_link_status(np->vsi->port_info, &link_up);\n\tif (status) {\n\t\tnetdev_err(netdev, \"link query error, status = %d\\n\",\n\t\t\t   status);\n\t\treturn 1;\n\t}\n\n\tif (!link_up)\n\t\treturn 2;\n\n\treturn 0;\n}\n\n \nstatic u64 ice_eeprom_test(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\n\tnetdev_info(netdev, \"EEPROM test\\n\");\n\treturn !!(ice_nvm_validate_checksum(&pf->hw));\n}\n\n \nstatic int ice_reg_pattern_test(struct ice_hw *hw, u32 reg, u32 mask)\n{\n\tstruct ice_pf *pf = (struct ice_pf *)hw->back;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstatic const u32 patterns[] = {\n\t\t0x5A5A5A5A, 0xA5A5A5A5,\n\t\t0x00000000, 0xFFFFFFFF\n\t};\n\tu32 val, orig_val;\n\tunsigned int i;\n\n\torig_val = rd32(hw, reg);\n\tfor (i = 0; i < ARRAY_SIZE(patterns); ++i) {\n\t\tu32 pattern = patterns[i] & mask;\n\n\t\twr32(hw, reg, pattern);\n\t\tval = rd32(hw, reg);\n\t\tif (val == pattern)\n\t\t\tcontinue;\n\t\tdev_err(dev, \"%s: reg pattern test failed - reg 0x%08x pat 0x%08x val 0x%08x\\n\"\n\t\t\t, __func__, reg, pattern, val);\n\t\treturn 1;\n\t}\n\n\twr32(hw, reg, orig_val);\n\tval = rd32(hw, reg);\n\tif (val != orig_val) {\n\t\tdev_err(dev, \"%s: reg restore test failed - reg 0x%08x orig 0x%08x val 0x%08x\\n\"\n\t\t\t, __func__, reg, orig_val, val);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u64 ice_reg_test(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_hw *hw = np->vsi->port_info->hw;\n\tu32 int_elements = hw->func_caps.common_cap.num_msix_vectors ?\n\t\thw->func_caps.common_cap.num_msix_vectors - 1 : 1;\n\tstruct ice_diag_reg_test_info {\n\t\tu32 address;\n\t\tu32 mask;\n\t\tu32 elem_num;\n\t\tu32 elem_size;\n\t} ice_reg_list[] = {\n\t\t{GLINT_ITR(0, 0), 0x00000fff, int_elements,\n\t\t\tGLINT_ITR(0, 1) - GLINT_ITR(0, 0)},\n\t\t{GLINT_ITR(1, 0), 0x00000fff, int_elements,\n\t\t\tGLINT_ITR(1, 1) - GLINT_ITR(1, 0)},\n\t\t{GLINT_ITR(0, 0), 0x00000fff, int_elements,\n\t\t\tGLINT_ITR(2, 1) - GLINT_ITR(2, 0)},\n\t\t{GLINT_CTL, 0xffff0001, 1, 0}\n\t};\n\tunsigned int i;\n\n\tnetdev_dbg(netdev, \"Register test\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(ice_reg_list); ++i) {\n\t\tu32 j;\n\n\t\tfor (j = 0; j < ice_reg_list[i].elem_num; ++j) {\n\t\t\tu32 mask = ice_reg_list[i].mask;\n\t\t\tu32 reg = ice_reg_list[i].address +\n\t\t\t\t(j * ice_reg_list[i].elem_size);\n\n\t\t\t \n\t\t\tif (ice_reg_pattern_test(hw, reg, mask))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_lbtest_prepare_rings(struct ice_vsi *vsi)\n{\n\tint status;\n\n\tstatus = ice_vsi_setup_tx_rings(vsi);\n\tif (status)\n\t\tgoto err_setup_tx_ring;\n\n\tstatus = ice_vsi_setup_rx_rings(vsi);\n\tif (status)\n\t\tgoto err_setup_rx_ring;\n\n\tstatus = ice_vsi_cfg_lan(vsi);\n\tif (status)\n\t\tgoto err_setup_rx_ring;\n\n\tstatus = ice_vsi_start_all_rx_rings(vsi);\n\tif (status)\n\t\tgoto err_start_rx_ring;\n\n\treturn 0;\n\nerr_start_rx_ring:\n\tice_vsi_free_rx_rings(vsi);\nerr_setup_rx_ring:\n\tice_vsi_stop_lan_tx_rings(vsi, ICE_NO_RESET, 0);\nerr_setup_tx_ring:\n\tice_vsi_free_tx_rings(vsi);\n\n\treturn status;\n}\n\n \nstatic int ice_lbtest_disable_rings(struct ice_vsi *vsi)\n{\n\tint status;\n\n\tstatus = ice_vsi_stop_lan_tx_rings(vsi, ICE_NO_RESET, 0);\n\tif (status)\n\t\tnetdev_err(vsi->netdev, \"Failed to stop Tx rings, VSI %d error %d\\n\",\n\t\t\t   vsi->vsi_num, status);\n\n\tstatus = ice_vsi_stop_all_rx_rings(vsi);\n\tif (status)\n\t\tnetdev_err(vsi->netdev, \"Failed to stop Rx rings, VSI %d error %d\\n\",\n\t\t\t   vsi->vsi_num, status);\n\n\tice_vsi_free_tx_rings(vsi);\n\tice_vsi_free_rx_rings(vsi);\n\n\treturn status;\n}\n\n \nstatic int ice_lbtest_create_frame(struct ice_pf *pf, u8 **ret_data, u16 size)\n{\n\tu8 *data;\n\n\tif (!pf)\n\t\treturn -EINVAL;\n\n\tdata = devm_kzalloc(ice_pf_to_dev(pf), size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(data, 0xFF, size);\n\tdata[32] = 0xDE;\n\tdata[42] = 0xAD;\n\tdata[44] = 0xBE;\n\tdata[46] = 0xEF;\n\n\t*ret_data = data;\n\n\treturn 0;\n}\n\n \nstatic bool ice_lbtest_check_frame(u8 *frame)\n{\n\t \n\tif (frame[32] == 0xDE &&\n\t    frame[42] == 0xAD &&\n\t    frame[44] == 0xBE &&\n\t    frame[46] == 0xEF &&\n\t    frame[48] == 0xFF)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int ice_diag_send(struct ice_tx_ring *tx_ring, u8 *data, u16 size)\n{\n\tstruct ice_tx_desc *tx_desc;\n\tstruct ice_tx_buf *tx_buf;\n\tdma_addr_t dma;\n\tu64 td_cmd;\n\n\ttx_desc = ICE_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_buf = &tx_ring->tx_buf[tx_ring->next_to_use];\n\n\tdma = dma_map_single(tx_ring->dev, data, size, DMA_TO_DEVICE);\n\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\treturn -EINVAL;\n\n\ttx_desc->buf_addr = cpu_to_le64(dma);\n\n\t \n\ttd_cmd = (u64)(ICE_TX_DESC_CMD_EOP | ICE_TX_DESC_CMD_RS);\n\ttx_desc->cmd_type_offset_bsz =\n\t\tcpu_to_le64(ICE_TX_DESC_DTYPE_DATA |\n\t\t\t    (td_cmd << ICE_TXD_QW1_CMD_S) |\n\t\t\t    ((u64)0 << ICE_TXD_QW1_OFFSET_S) |\n\t\t\t    ((u64)size << ICE_TXD_QW1_TX_BUF_SZ_S) |\n\t\t\t    ((u64)0 << ICE_TXD_QW1_L2TAG1_S));\n\n\ttx_buf->next_to_watch = tx_desc;\n\n\t \n\twmb();\n\n\ttx_ring->next_to_use++;\n\tif (tx_ring->next_to_use >= tx_ring->count)\n\t\ttx_ring->next_to_use = 0;\n\n\twritel_relaxed(tx_ring->next_to_use, tx_ring->tail);\n\n\t \n\tusleep_range(1000, 2000);\n\tdma_unmap_single(tx_ring->dev, dma, size, DMA_TO_DEVICE);\n\n\treturn 0;\n}\n\n#define ICE_LB_FRAME_SIZE 64\n \nstatic int ice_lbtest_receive_frames(struct ice_rx_ring *rx_ring)\n{\n\tstruct ice_rx_buf *rx_buf;\n\tint valid_frames, i;\n\tu8 *received_buf;\n\n\tvalid_frames = 0;\n\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tunion ice_32b_rx_flex_desc *rx_desc;\n\n\t\trx_desc = ICE_RX_DESC(rx_ring, i);\n\n\t\tif (!(rx_desc->wb.status_error0 &\n\t\t    (cpu_to_le16(BIT(ICE_RX_FLEX_DESC_STATUS0_DD_S)) |\n\t\t     cpu_to_le16(BIT(ICE_RX_FLEX_DESC_STATUS0_EOF_S)))))\n\t\t\tcontinue;\n\n\t\trx_buf = &rx_ring->rx_buf[i];\n\t\treceived_buf = page_address(rx_buf->page) + rx_buf->page_offset;\n\n\t\tif (ice_lbtest_check_frame(received_buf))\n\t\t\tvalid_frames++;\n\t}\n\n\treturn valid_frames;\n}\n\n \nstatic u64 ice_loopback_test(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *orig_vsi = np->vsi, *test_vsi;\n\tstruct ice_pf *pf = orig_vsi->back;\n\tu8 broadcast[ETH_ALEN], ret = 0;\n\tint num_frames, valid_frames;\n\tstruct ice_tx_ring *tx_ring;\n\tstruct ice_rx_ring *rx_ring;\n\tstruct device *dev;\n\tu8 *tx_frame;\n\tint i;\n\n\tdev = ice_pf_to_dev(pf);\n\tnetdev_info(netdev, \"loopback test\\n\");\n\n\ttest_vsi = ice_lb_vsi_setup(pf, pf->hw.port_info);\n\tif (!test_vsi) {\n\t\tnetdev_err(netdev, \"Failed to create a VSI for the loopback test\\n\");\n\t\treturn 1;\n\t}\n\n\ttest_vsi->netdev = netdev;\n\ttx_ring = test_vsi->tx_rings[0];\n\trx_ring = test_vsi->rx_rings[0];\n\n\tif (ice_lbtest_prepare_rings(test_vsi)) {\n\t\tret = 2;\n\t\tgoto lbtest_vsi_close;\n\t}\n\n\tif (ice_alloc_rx_bufs(rx_ring, rx_ring->count)) {\n\t\tret = 3;\n\t\tgoto lbtest_rings_dis;\n\t}\n\n\t \n\tif (ice_aq_set_mac_loopback(&pf->hw, true, NULL)) {\n\t\tret = 4;\n\t\tgoto lbtest_mac_dis;\n\t}\n\n\t \n\teth_broadcast_addr(broadcast);\n\tif (ice_fltr_add_mac(test_vsi, broadcast, ICE_FWD_TO_VSI)) {\n\t\tret = 5;\n\t\tgoto lbtest_mac_dis;\n\t}\n\n\tif (ice_lbtest_create_frame(pf, &tx_frame, ICE_LB_FRAME_SIZE)) {\n\t\tret = 7;\n\t\tgoto remove_mac_filters;\n\t}\n\n\tnum_frames = min_t(int, tx_ring->count, 32);\n\tfor (i = 0; i < num_frames; i++) {\n\t\tif (ice_diag_send(tx_ring, tx_frame, ICE_LB_FRAME_SIZE)) {\n\t\t\tret = 8;\n\t\t\tgoto lbtest_free_frame;\n\t\t}\n\t}\n\n\tvalid_frames = ice_lbtest_receive_frames(rx_ring);\n\tif (!valid_frames)\n\t\tret = 9;\n\telse if (valid_frames != num_frames)\n\t\tret = 10;\n\nlbtest_free_frame:\n\tdevm_kfree(dev, tx_frame);\nremove_mac_filters:\n\tif (ice_fltr_remove_mac(test_vsi, broadcast, ICE_FWD_TO_VSI))\n\t\tnetdev_err(netdev, \"Could not remove MAC filter for the test VSI\\n\");\nlbtest_mac_dis:\n\t \n\tif (ice_aq_set_mac_loopback(&pf->hw, false, NULL))\n\t\tnetdev_err(netdev, \"Could not disable MAC loopback\\n\");\nlbtest_rings_dis:\n\tif (ice_lbtest_disable_rings(test_vsi))\n\t\tnetdev_err(netdev, \"Could not disable test rings\\n\");\nlbtest_vsi_close:\n\ttest_vsi->netdev = NULL;\n\tif (ice_vsi_release(test_vsi))\n\t\tnetdev_err(netdev, \"Failed to remove the test VSI\\n\");\n\n\treturn ret;\n}\n\n \nstatic u64 ice_intr_test(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\tu16 swic_old = pf->sw_int_count;\n\n\tnetdev_info(netdev, \"interrupt test\\n\");\n\n\twr32(&pf->hw, GLINT_DYN_CTL(pf->oicr_irq.index),\n\t     GLINT_DYN_CTL_SW_ITR_INDX_M |\n\t     GLINT_DYN_CTL_INTENA_MSK_M |\n\t     GLINT_DYN_CTL_SWINT_TRIG_M);\n\n\tusleep_range(1000, 2000);\n\treturn (swic_old == pf->sw_int_count);\n}\n\n \nstatic void\nice_self_test(struct net_device *netdev, struct ethtool_test *eth_test,\n\t      u64 *data)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tbool if_running = netif_running(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\tstruct device *dev;\n\n\tdev = ice_pf_to_dev(pf);\n\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\tnetdev_info(netdev, \"offline testing starting\\n\");\n\n\t\tset_bit(ICE_TESTING, pf->state);\n\n\t\tif (ice_active_vfs(pf)) {\n\t\t\tdev_warn(dev, \"Please take active VFs and Netqueues offline and restart the adapter before running NIC diagnostics\\n\");\n\t\t\tdata[ICE_ETH_TEST_REG] = 1;\n\t\t\tdata[ICE_ETH_TEST_EEPROM] = 1;\n\t\t\tdata[ICE_ETH_TEST_INTR] = 1;\n\t\t\tdata[ICE_ETH_TEST_LOOP] = 1;\n\t\t\tdata[ICE_ETH_TEST_LINK] = 1;\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\t\tclear_bit(ICE_TESTING, pf->state);\n\t\t\tgoto skip_ol_tests;\n\t\t}\n\t\t \n\t\tif (if_running)\n\t\t\t \n\t\t\tice_stop(netdev);\n\n\t\tdata[ICE_ETH_TEST_LINK] = ice_link_test(netdev);\n\t\tdata[ICE_ETH_TEST_EEPROM] = ice_eeprom_test(netdev);\n\t\tdata[ICE_ETH_TEST_INTR] = ice_intr_test(netdev);\n\t\tdata[ICE_ETH_TEST_LOOP] = ice_loopback_test(netdev);\n\t\tdata[ICE_ETH_TEST_REG] = ice_reg_test(netdev);\n\n\t\tif (data[ICE_ETH_TEST_LINK] ||\n\t\t    data[ICE_ETH_TEST_EEPROM] ||\n\t\t    data[ICE_ETH_TEST_LOOP] ||\n\t\t    data[ICE_ETH_TEST_INTR] ||\n\t\t    data[ICE_ETH_TEST_REG])\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tclear_bit(ICE_TESTING, pf->state);\n\n\t\tif (if_running) {\n\t\t\tint status = ice_open(netdev);\n\n\t\t\tif (status) {\n\t\t\t\tdev_err(dev, \"Could not open device %s, err %d\\n\",\n\t\t\t\t\tpf->int_name, status);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tnetdev_info(netdev, \"online testing starting\\n\");\n\n\t\tdata[ICE_ETH_TEST_LINK] = ice_link_test(netdev);\n\t\tif (data[ICE_ETH_TEST_LINK])\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tdata[ICE_ETH_TEST_REG] = 0;\n\t\tdata[ICE_ETH_TEST_EEPROM] = 0;\n\t\tdata[ICE_ETH_TEST_INTR] = 0;\n\t\tdata[ICE_ETH_TEST_LOOP] = 0;\n\t}\n\nskip_ol_tests:\n\tnetdev_info(netdev, \"testing finished\\n\");\n}\n\nstatic void\n__ice_get_strings(struct net_device *netdev, u32 stringset, u8 *data,\n\t\t  struct ice_vsi *vsi)\n{\n\tunsigned int i;\n\tu8 *p = data;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ICE_VSI_STATS_LEN; i++)\n\t\t\tethtool_sprintf(&p,\n\t\t\t\t\tice_gstrings_vsi_stats[i].stat_string);\n\n\t\tif (ice_is_port_repr_netdev(netdev))\n\t\t\treturn;\n\n\t\tice_for_each_alloc_txq(vsi, i) {\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_bytes\", i);\n\t\t}\n\n\t\tice_for_each_alloc_rxq(vsi, i) {\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_bytes\", i);\n\t\t}\n\n\t\tif (vsi->type != ICE_VSI_PF)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < ICE_PF_STATS_LEN; i++)\n\t\t\tethtool_sprintf(&p,\n\t\t\t\t\tice_gstrings_pf_stats[i].stat_string);\n\n\t\tfor (i = 0; i < ICE_MAX_USER_PRIORITY; i++) {\n\t\t\tethtool_sprintf(&p, \"tx_priority_%u_xon.nic\", i);\n\t\t\tethtool_sprintf(&p, \"tx_priority_%u_xoff.nic\", i);\n\t\t}\n\t\tfor (i = 0; i < ICE_MAX_USER_PRIORITY; i++) {\n\t\t\tethtool_sprintf(&p, \"rx_priority_%u_xon.nic\", i);\n\t\t\tethtool_sprintf(&p, \"rx_priority_%u_xoff.nic\", i);\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, ice_gstrings_test, ICE_TEST_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tfor (i = 0; i < ICE_PRIV_FLAG_ARRAY_SIZE; i++)\n\t\t\tethtool_sprintf(&p, ice_gstrings_priv_flags[i].name);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ice_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\n\t__ice_get_strings(netdev, stringset, data, np->vsi);\n}\n\nstatic int\nice_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tbool led_active;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tled_active = true;\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tled_active = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ice_aq_set_port_id_led(np->vsi->port_info, !led_active, NULL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int ice_set_fec_cfg(struct net_device *netdev, enum ice_fec_mode req_fec)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_aqc_set_phy_cfg_data config = { 0 };\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_port_info *pi;\n\n\tpi = vsi->port_info;\n\tif (!pi)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (vsi->type != ICE_VSI_PF) {\n\t\tnetdev_info(netdev, \"Changing FEC parameters only supported for PF VSI\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (pi->phy.curr_user_fec_req == req_fec)\n\t\treturn 0;\n\n\t \n\tmemcpy(&config, &pi->phy.curr_user_phy_cfg, sizeof(config));\n\n\tice_cfg_phy_fec(pi, &config, req_fec);\n\tconfig.caps |= ICE_AQ_PHY_ENA_AUTO_LINK_UPDT;\n\n\tif (ice_aq_set_phy_cfg(pi->hw, pi, &config, NULL))\n\t\treturn -EAGAIN;\n\n\t \n\tpi->phy.curr_user_fec_req = req_fec;\n\n\treturn 0;\n}\n\n \nstatic int\nice_set_fecparam(struct net_device *netdev, struct ethtool_fecparam *fecparam)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tenum ice_fec_mode fec;\n\n\tswitch (fecparam->fec) {\n\tcase ETHTOOL_FEC_AUTO:\n\t\tfec = ICE_FEC_AUTO;\n\t\tbreak;\n\tcase ETHTOOL_FEC_RS:\n\t\tfec = ICE_FEC_RS;\n\t\tbreak;\n\tcase ETHTOOL_FEC_BASER:\n\t\tfec = ICE_FEC_BASER;\n\t\tbreak;\n\tcase ETHTOOL_FEC_OFF:\n\tcase ETHTOOL_FEC_NONE:\n\t\tfec = ICE_FEC_NONE;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(ice_pf_to_dev(vsi->back), \"Unsupported FEC mode: %d\\n\",\n\t\t\t fecparam->fec);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ice_set_fec_cfg(netdev, fec);\n}\n\n \nstatic int\nice_get_fecparam(struct net_device *netdev, struct ethtool_fecparam *fecparam)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_aqc_get_phy_caps_data *caps;\n\tstruct ice_link_status *link_info;\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_port_info *pi;\n\tint err;\n\n\tpi = vsi->port_info;\n\n\tif (!pi)\n\t\treturn -EOPNOTSUPP;\n\tlink_info = &pi->phy.link_info;\n\n\t \n\tswitch (link_info->fec_info) {\n\tcase ICE_AQ_LINK_25G_KR_FEC_EN:\n\t\tfecparam->active_fec = ETHTOOL_FEC_BASER;\n\t\tbreak;\n\tcase ICE_AQ_LINK_25G_RS_528_FEC_EN:\n\tcase ICE_AQ_LINK_25G_RS_544_FEC_EN:\n\t\tfecparam->active_fec = ETHTOOL_FEC_RS;\n\t\tbreak;\n\tdefault:\n\t\tfecparam->active_fec = ETHTOOL_FEC_OFF;\n\t\tbreak;\n\t}\n\n\tcaps = kzalloc(sizeof(*caps), GFP_KERNEL);\n\tif (!caps)\n\t\treturn -ENOMEM;\n\n\terr = ice_aq_get_phy_caps(pi, false, ICE_AQC_REPORT_TOPO_CAP_MEDIA,\n\t\t\t\t  caps, NULL);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tif (caps->caps & ICE_AQC_PHY_EN_AUTO_FEC)\n\t\tfecparam->fec |= ETHTOOL_FEC_AUTO;\n\tif (caps->link_fec_options & ICE_AQC_PHY_FEC_10G_KR_40G_KR4_EN ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_10G_KR_40G_KR4_REQ ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_25G_KR_CLAUSE74_EN ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_25G_KR_REQ)\n\t\tfecparam->fec |= ETHTOOL_FEC_BASER;\n\tif (caps->link_fec_options & ICE_AQC_PHY_FEC_25G_RS_528_REQ ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_25G_RS_544_REQ ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_25G_RS_CLAUSE91_EN)\n\t\tfecparam->fec |= ETHTOOL_FEC_RS;\n\tif (caps->link_fec_options == 0)\n\t\tfecparam->fec |= ETHTOOL_FEC_OFF;\n\ndone:\n\tkfree(caps);\n\treturn err;\n}\n\n \nstatic int ice_nway_reset(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tint err;\n\n\t \n\tif (!test_bit(ICE_DOWN, vsi->back->state))\n\t\terr = ice_set_link(vsi, true);\n\telse\n\t\terr = ice_set_link(vsi, false);\n\n\treturn err;\n}\n\n \nstatic u32 ice_get_priv_flags(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tu32 i, ret_flags = 0;\n\n\tfor (i = 0; i < ICE_PRIV_FLAG_ARRAY_SIZE; i++) {\n\t\tconst struct ice_priv_flag *priv_flag;\n\n\t\tpriv_flag = &ice_gstrings_priv_flags[i];\n\n\t\tif (test_bit(priv_flag->bitno, pf->flags))\n\t\t\tret_flags |= BIT(i);\n\t}\n\n\treturn ret_flags;\n}\n\n \nstatic int ice_set_priv_flags(struct net_device *netdev, u32 flags)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tDECLARE_BITMAP(change_flags, ICE_PF_FLAGS_NBITS);\n\tDECLARE_BITMAP(orig_flags, ICE_PF_FLAGS_NBITS);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct device *dev;\n\tint ret = 0;\n\tu32 i;\n\n\tif (flags > BIT(ICE_PRIV_FLAG_ARRAY_SIZE))\n\t\treturn -EINVAL;\n\n\tdev = ice_pf_to_dev(pf);\n\tset_bit(ICE_FLAG_ETHTOOL_CTXT, pf->flags);\n\n\tbitmap_copy(orig_flags, pf->flags, ICE_PF_FLAGS_NBITS);\n\tfor (i = 0; i < ICE_PRIV_FLAG_ARRAY_SIZE; i++) {\n\t\tconst struct ice_priv_flag *priv_flag;\n\n\t\tpriv_flag = &ice_gstrings_priv_flags[i];\n\n\t\tif (flags & BIT(i))\n\t\t\tset_bit(priv_flag->bitno, pf->flags);\n\t\telse\n\t\t\tclear_bit(priv_flag->bitno, pf->flags);\n\t}\n\n\tbitmap_xor(change_flags, pf->flags, orig_flags, ICE_PF_FLAGS_NBITS);\n\n\t \n\tif (test_bit(ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA, change_flags) &&\n\t    test_bit(ICE_FLAG_TOTAL_PORT_SHUTDOWN_ENA, pf->flags)) {\n\t\tdev_err(dev, \"Setting link-down-on-close not supported on this port\\n\");\n\t\tset_bit(ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA, pf->flags);\n\t\tret = -EINVAL;\n\t\tgoto ethtool_exit;\n\t}\n\n\tif (test_bit(ICE_FLAG_FW_LLDP_AGENT, change_flags)) {\n\t\tif (!test_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags)) {\n\t\t\tint status;\n\n\t\t\t \n\t\t\tstatus = ice_cfg_lldp_mib_change(&pf->hw, false);\n\n\t\t\t \n\t\t\tif (status)\n\t\t\t\tdev_info(dev, \"Failed to unreg for LLDP events\\n\");\n\n\t\t\t \n\t\t\tstatus = ice_aq_stop_lldp(&pf->hw, true, true, NULL);\n\t\t\tif (status)\n\t\t\t\tdev_warn(dev, \"Fail to stop LLDP agent\\n\");\n\t\t\t \n\t\t\tstatus = ice_init_pf_dcb(pf, true);\n\t\t\tif (status)\n\t\t\t\tdev_warn(dev, \"Fail to init DCB\\n\");\n\n\t\t\tpf->dcbx_cap &= ~DCB_CAP_DCBX_LLD_MANAGED;\n\t\t\tpf->dcbx_cap |= DCB_CAP_DCBX_HOST;\n\t\t} else {\n\t\t\tbool dcbx_agent_status;\n\t\t\tint status;\n\n\t\t\tif (ice_get_pfc_mode(pf) == ICE_QOS_MODE_DSCP) {\n\t\t\t\tclear_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags);\n\t\t\t\tdev_err(dev, \"QoS in L3 DSCP mode, FW Agent not allowed to start\\n\");\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto ethtool_exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tice_cfg_sw_lldp(vsi, false, false);\n\n\t\t\t \n\t\t\tstatus = ice_aq_start_lldp(&pf->hw, true, NULL);\n\t\t\tif (status)\n\t\t\t\tdev_warn(dev, \"Fail to start LLDP Agent\\n\");\n\n\t\t\t \n\t\t\tstatus = ice_aq_start_stop_dcbx(&pf->hw, true,\n\t\t\t\t\t\t\t&dcbx_agent_status,\n\t\t\t\t\t\t\tNULL);\n\t\t\tif (status)\n\t\t\t\tdev_dbg(dev, \"Failed to start FW DCBX\\n\");\n\n\t\t\tdev_info(dev, \"FW DCBX agent is %s\\n\",\n\t\t\t\t dcbx_agent_status ? \"ACTIVE\" : \"DISABLED\");\n\n\t\t\t \n\t\t\tstatus = ice_init_pf_dcb(pf, true);\n\t\t\tif (status)\n\t\t\t\tdev_dbg(dev, \"Fail to init DCB\\n\");\n\n\t\t\t \n\t\t\tstatus = ice_cfg_lldp_mib_change(&pf->hw, true);\n\t\t\tif (status)\n\t\t\t\tdev_dbg(dev, \"Fail to enable MIB change events\\n\");\n\n\t\t\tpf->dcbx_cap &= ~DCB_CAP_DCBX_HOST;\n\t\t\tpf->dcbx_cap |= DCB_CAP_DCBX_LLD_MANAGED;\n\n\t\t\tice_nway_reset(netdev);\n\t\t}\n\t}\n\tif (test_bit(ICE_FLAG_LEGACY_RX, change_flags)) {\n\t\t \n\t\tice_down_up(vsi);\n\t}\n\t \n\tif (test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, change_flags) &&\n\t    ice_is_any_vf_in_unicast_promisc(pf)) {\n\t\tdev_err(dev, \"Changing vf-true-promisc-support flag while VF(s) are in promiscuous mode not supported\\n\");\n\t\t \n\t\tchange_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags);\n\t\tret = -EAGAIN;\n\t}\n\n\tif (test_bit(ICE_FLAG_VF_VLAN_PRUNING, change_flags) &&\n\t    ice_has_vfs(pf)) {\n\t\tdev_err(dev, \"vf-vlan-pruning: VLAN pruning cannot be changed while VFs are active.\\n\");\n\t\t \n\t\tchange_bit(ICE_FLAG_VF_VLAN_PRUNING, pf->flags);\n\t\tret = -EOPNOTSUPP;\n\t}\nethtool_exit:\n\tclear_bit(ICE_FLAG_ETHTOOL_CTXT, pf->flags);\n\treturn ret;\n}\n\nstatic int ice_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\t \n\t\treturn ICE_ALL_STATS_LEN(netdev);\n\tcase ETH_SS_TEST:\n\t\treturn ICE_TEST_LEN;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn ICE_PRIV_FLAG_ARRAY_SIZE;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void\n__ice_get_ethtool_stats(struct net_device *netdev,\n\t\t\tstruct ethtool_stats __always_unused *stats, u64 *data,\n\t\t\tstruct ice_vsi *vsi)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_tx_ring *tx_ring;\n\tstruct ice_rx_ring *rx_ring;\n\tunsigned int j;\n\tint i = 0;\n\tchar *p;\n\n\tice_update_pf_stats(pf);\n\tice_update_vsi_stats(vsi);\n\n\tfor (j = 0; j < ICE_VSI_STATS_LEN; j++) {\n\t\tp = (char *)vsi + ice_gstrings_vsi_stats[j].stat_offset;\n\t\tdata[i++] = (ice_gstrings_vsi_stats[j].sizeof_stat ==\n\t\t\t     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\n\tif (ice_is_port_repr_netdev(netdev))\n\t\treturn;\n\n\t \n\trcu_read_lock();\n\n\tice_for_each_alloc_txq(vsi, j) {\n\t\ttx_ring = READ_ONCE(vsi->tx_rings[j]);\n\t\tif (tx_ring && tx_ring->ring_stats) {\n\t\t\tdata[i++] = tx_ring->ring_stats->stats.pkts;\n\t\t\tdata[i++] = tx_ring->ring_stats->stats.bytes;\n\t\t} else {\n\t\t\tdata[i++] = 0;\n\t\t\tdata[i++] = 0;\n\t\t}\n\t}\n\n\tice_for_each_alloc_rxq(vsi, j) {\n\t\trx_ring = READ_ONCE(vsi->rx_rings[j]);\n\t\tif (rx_ring && rx_ring->ring_stats) {\n\t\t\tdata[i++] = rx_ring->ring_stats->stats.pkts;\n\t\t\tdata[i++] = rx_ring->ring_stats->stats.bytes;\n\t\t} else {\n\t\t\tdata[i++] = 0;\n\t\t\tdata[i++] = 0;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (vsi->type != ICE_VSI_PF)\n\t\treturn;\n\n\tfor (j = 0; j < ICE_PF_STATS_LEN; j++) {\n\t\tp = (char *)pf + ice_gstrings_pf_stats[j].stat_offset;\n\t\tdata[i++] = (ice_gstrings_pf_stats[j].sizeof_stat ==\n\t\t\t     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\n\tfor (j = 0; j < ICE_MAX_USER_PRIORITY; j++) {\n\t\tdata[i++] = pf->stats.priority_xon_tx[j];\n\t\tdata[i++] = pf->stats.priority_xoff_tx[j];\n\t}\n\n\tfor (j = 0; j < ICE_MAX_USER_PRIORITY; j++) {\n\t\tdata[i++] = pf->stats.priority_xon_rx[j];\n\t\tdata[i++] = pf->stats.priority_xoff_rx[j];\n\t}\n}\n\nstatic void\nice_get_ethtool_stats(struct net_device *netdev,\n\t\t      struct ethtool_stats __always_unused *stats, u64 *data)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\n\t__ice_get_ethtool_stats(netdev, stats, data, np->vsi);\n}\n\n#define ICE_PHY_TYPE_LOW_MASK_MIN_1G\t(ICE_PHY_TYPE_LOW_100BASE_TX | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100M_SGMII)\n\n#define ICE_PHY_TYPE_LOW_MASK_MIN_25G\t(ICE_PHY_TYPE_LOW_MASK_MIN_1G | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_1000BASE_T | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_1000BASE_SX | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_1000BASE_LX | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_1000BASE_KX | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_1G_SGMII | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_2500BASE_T | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_2500BASE_X | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_2500BASE_KX | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_5GBASE_T | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_5GBASE_KR | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_10GBASE_T | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_10G_SFI_DA | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_10GBASE_SR | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_10GBASE_LR | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_10GBASE_KR_CR1 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_10G_SFI_AOC_ACC | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_10G_SFI_C2C)\n\n#define ICE_PHY_TYPE_LOW_MASK_100G\t(ICE_PHY_TYPE_LOW_100GBASE_CR4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_SR4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_LR4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_KR4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100G_CAUI4_AOC_ACC | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100G_CAUI4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100G_AUI4_AOC_ACC | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100G_AUI4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_CR_PAM4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_KR_PAM4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_CP2 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_SR2 | \\\n\t\t\t\t\t ICE_PHY_TYPE_LOW_100GBASE_DR)\n\n#define ICE_PHY_TYPE_HIGH_MASK_100G\t(ICE_PHY_TYPE_HIGH_100GBASE_KR2_PAM4 | \\\n\t\t\t\t\t ICE_PHY_TYPE_HIGH_100G_CAUI2_AOC_ACC |\\\n\t\t\t\t\t ICE_PHY_TYPE_HIGH_100G_CAUI2 | \\\n\t\t\t\t\t ICE_PHY_TYPE_HIGH_100G_AUI2_AOC_ACC | \\\n\t\t\t\t\t ICE_PHY_TYPE_HIGH_100G_AUI2)\n\n \nstatic void\nice_mask_min_supported_speeds(struct ice_hw *hw,\n\t\t\t      u64 phy_types_high, u64 *phy_types_low)\n{\n\t \n\tif (*phy_types_low & ICE_PHY_TYPE_LOW_MASK_100G ||\n\t    phy_types_high & ICE_PHY_TYPE_HIGH_MASK_100G)\n\t\t*phy_types_low &= ~ICE_PHY_TYPE_LOW_MASK_MIN_25G;\n\telse if (!ice_is_100m_speed_supported(hw))\n\t\t*phy_types_low &= ~ICE_PHY_TYPE_LOW_MASK_MIN_1G;\n}\n\n \nstatic void\nice_linkmode_set_bit(const struct ice_phy_type_to_ethtool *phy_to_ethtool,\n\t\t     struct ethtool_link_ksettings *ks, u32 req_speeds,\n\t\t     u64 advert_phy_type, u32 phy_type)\n{\n\tlinkmode_set_bit(phy_to_ethtool->link_mode, ks->link_modes.supported);\n\n\tif (req_speeds & phy_to_ethtool->aq_link_speed ||\n\t    (!req_speeds && advert_phy_type & BIT(phy_type)))\n\t\tlinkmode_set_bit(phy_to_ethtool->link_mode,\n\t\t\t\t ks->link_modes.advertising);\n}\n\n \nstatic void\nice_phy_type_to_ethtool(struct net_device *netdev,\n\t\t\tstruct ethtool_link_ksettings *ks)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tu64 advert_phy_type_lo = 0;\n\tu64 advert_phy_type_hi = 0;\n\tu64 phy_types_high = 0;\n\tu64 phy_types_low = 0;\n\tu32 req_speeds;\n\tu32 i;\n\n\treq_speeds = vsi->port_info->phy.link_info.req_speeds;\n\n\t \n\tif (test_bit(ICE_FLAG_LINK_LENIENT_MODE_ENA, pf->flags)) {\n\t\tphy_types_low = le64_to_cpu(pf->nvm_phy_type_lo);\n\t\tphy_types_high = le64_to_cpu(pf->nvm_phy_type_hi);\n\n\t\tice_mask_min_supported_speeds(&pf->hw, phy_types_high,\n\t\t\t\t\t      &phy_types_low);\n\t\t \n\t\tif (ice_fw_supports_link_override(&pf->hw) &&\n\t\t    !ice_fw_supports_report_dflt_cfg(&pf->hw)) {\n\t\t\tstruct ice_link_default_override_tlv *ldo;\n\n\t\t\tldo = &pf->link_dflt_override;\n\t\t\t \n\t\t\tif (ldo->options & ICE_LINK_OVERRIDE_EN &&\n\t\t\t    (ldo->phy_type_low || ldo->phy_type_high)) {\n\t\t\t\tadvert_phy_type_lo =\n\t\t\t\t\tle64_to_cpu(pf->nvm_phy_type_lo) &\n\t\t\t\t\tldo->phy_type_low;\n\t\t\t\tadvert_phy_type_hi =\n\t\t\t\t\tle64_to_cpu(pf->nvm_phy_type_hi) &\n\t\t\t\t\tldo->phy_type_high;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tphy_types_low = vsi->port_info->phy.phy_type_low;\n\t\tphy_types_high = vsi->port_info->phy.phy_type_high;\n\t}\n\n\t \n\tif (!advert_phy_type_lo && !advert_phy_type_hi) {\n\t\tadvert_phy_type_lo = vsi->port_info->phy.phy_type_low;\n\t\tadvert_phy_type_hi = vsi->port_info->phy.phy_type_high;\n\t}\n\n\tlinkmode_zero(ks->link_modes.supported);\n\tlinkmode_zero(ks->link_modes.advertising);\n\n\tfor (i = 0; i < ARRAY_SIZE(phy_type_low_lkup); i++) {\n\t\tif (phy_types_low & BIT_ULL(i))\n\t\t\tice_linkmode_set_bit(&phy_type_low_lkup[i], ks,\n\t\t\t\t\t     req_speeds, advert_phy_type_lo,\n\t\t\t\t\t     i);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(phy_type_high_lkup); i++) {\n\t\tif (phy_types_high & BIT_ULL(i))\n\t\t\tice_linkmode_set_bit(&phy_type_high_lkup[i], ks,\n\t\t\t\t\t     req_speeds, advert_phy_type_hi,\n\t\t\t\t\t     i);\n\t}\n}\n\n#define TEST_SET_BITS_TIMEOUT\t50\n#define TEST_SET_BITS_SLEEP_MAX\t2000\n#define TEST_SET_BITS_SLEEP_MIN\t1000\n\n \nstatic void\nice_get_settings_link_up(struct ethtool_link_ksettings *ks,\n\t\t\t struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_port_info *pi = np->vsi->port_info;\n\tstruct ice_link_status *link_info;\n\tstruct ice_vsi *vsi = np->vsi;\n\n\tlink_info = &vsi->port_info->phy.link_info;\n\n\t \n\tice_phy_type_to_ethtool(netdev, ks);\n\n\tswitch (link_info->link_speed) {\n\tcase ICE_AQ_LINK_SPEED_100GB:\n\t\tks->base.speed = SPEED_100000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_50GB:\n\t\tks->base.speed = SPEED_50000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_40GB:\n\t\tks->base.speed = SPEED_40000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_25GB:\n\t\tks->base.speed = SPEED_25000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_20GB:\n\t\tks->base.speed = SPEED_20000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_10GB:\n\t\tks->base.speed = SPEED_10000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_5GB:\n\t\tks->base.speed = SPEED_5000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_2500MB:\n\t\tks->base.speed = SPEED_2500;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_1000MB:\n\t\tks->base.speed = SPEED_1000;\n\t\tbreak;\n\tcase ICE_AQ_LINK_SPEED_100MB:\n\t\tks->base.speed = SPEED_100;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(netdev, \"WARNING: Unrecognized link_speed (0x%x).\\n\",\n\t\t\t    link_info->link_speed);\n\t\tbreak;\n\t}\n\tks->base.duplex = DUPLEX_FULL;\n\n\tif (link_info->an_info & ICE_AQ_AN_COMPLETED)\n\t\tethtool_link_ksettings_add_link_mode(ks, lp_advertising,\n\t\t\t\t\t\t     Autoneg);\n\n\t \n\tswitch (pi->fc.current_mode) {\n\tcase ICE_FC_FULL:\n\t\tethtool_link_ksettings_add_link_mode(ks, lp_advertising, Pause);\n\t\tbreak;\n\tcase ICE_FC_TX_PAUSE:\n\t\tethtool_link_ksettings_add_link_mode(ks, lp_advertising, Pause);\n\t\tethtool_link_ksettings_add_link_mode(ks, lp_advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tcase ICE_FC_RX_PAUSE:\n\t\tethtool_link_ksettings_add_link_mode(ks, lp_advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tcase ICE_FC_PFC:\n\tdefault:\n\t\tethtool_link_ksettings_del_link_mode(ks, lp_advertising, Pause);\n\t\tethtool_link_ksettings_del_link_mode(ks, lp_advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nice_get_settings_link_down(struct ethtool_link_ksettings *ks,\n\t\t\t   struct net_device *netdev)\n{\n\t \n\tice_phy_type_to_ethtool(netdev, ks);\n\n\t \n\tks->base.speed = SPEED_UNKNOWN;\n\tks->base.duplex = DUPLEX_UNKNOWN;\n}\n\n \nstatic int\nice_get_link_ksettings(struct net_device *netdev,\n\t\t       struct ethtool_link_ksettings *ks)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_aqc_get_phy_caps_data *caps;\n\tstruct ice_link_status *hw_link_info;\n\tstruct ice_vsi *vsi = np->vsi;\n\tint err;\n\n\tethtool_link_ksettings_zero_link_mode(ks, supported);\n\tethtool_link_ksettings_zero_link_mode(ks, advertising);\n\tethtool_link_ksettings_zero_link_mode(ks, lp_advertising);\n\thw_link_info = &vsi->port_info->phy.link_info;\n\n\t \n\tif (hw_link_info->link_info & ICE_AQ_LINK_UP)\n\t\tice_get_settings_link_up(ks, netdev);\n\telse\n\t\tice_get_settings_link_down(ks, netdev);\n\n\t \n\tks->base.autoneg = (hw_link_info->an_info & ICE_AQ_AN_COMPLETED) ?\n\t\tAUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\t \n\tswitch (vsi->port_info->phy.media_type) {\n\tcase ICE_MEDIA_FIBER:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FIBRE);\n\t\tks->base.port = PORT_FIBRE;\n\t\tbreak;\n\tcase ICE_MEDIA_BASET:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, TP);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, TP);\n\t\tks->base.port = PORT_TP;\n\t\tbreak;\n\tcase ICE_MEDIA_BACKPLANE:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Backplane);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Backplane);\n\t\tks->base.port = PORT_NONE;\n\t\tbreak;\n\tcase ICE_MEDIA_DA:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FIBRE);\n\t\tks->base.port = PORT_DA;\n\t\tbreak;\n\tdefault:\n\t\tks->base.port = PORT_OTHER;\n\t\tbreak;\n\t}\n\n\t \n\tethtool_link_ksettings_add_link_mode(ks, supported, Pause);\n\n\tcaps = kzalloc(sizeof(*caps), GFP_KERNEL);\n\tif (!caps)\n\t\treturn -ENOMEM;\n\n\terr = ice_aq_get_phy_caps(vsi->port_info, false,\n\t\t\t\t  ICE_AQC_REPORT_ACTIVE_CFG, caps, NULL);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tif ((caps->caps & ICE_AQC_PHY_EN_TX_LINK_PAUSE) &&\n\t    (caps->caps & ICE_AQC_PHY_EN_RX_LINK_PAUSE)) {\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Pause);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t} else if (caps->caps & ICE_AQC_PHY_EN_TX_LINK_PAUSE) {\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t} else if (caps->caps & ICE_AQC_PHY_EN_RX_LINK_PAUSE) {\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Pause);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t} else {\n\t\tethtool_link_ksettings_del_link_mode(ks, advertising, Pause);\n\t\tethtool_link_ksettings_del_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t}\n\n\t \n\tethtool_link_ksettings_add_link_mode(ks, advertising, FEC_NONE);\n\n\tif (caps->link_fec_options & ICE_AQC_PHY_FEC_10G_KR_40G_KR4_REQ ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_25G_KR_REQ)\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     FEC_BASER);\n\tif (caps->link_fec_options & ICE_AQC_PHY_FEC_25G_RS_528_REQ ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_25G_RS_544_REQ)\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FEC_RS);\n\n\terr = ice_aq_get_phy_caps(vsi->port_info, false,\n\t\t\t\t  ICE_AQC_REPORT_TOPO_CAP_MEDIA, caps, NULL);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_NONE);\n\n\tif (caps->link_fec_options & ICE_AQC_PHY_FEC_10G_KR_40G_KR4_EN ||\n\t    caps->link_fec_options & ICE_AQC_PHY_FEC_25G_KR_CLAUSE74_EN)\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_BASER);\n\tif (caps->link_fec_options & ICE_AQC_PHY_FEC_25G_RS_CLAUSE91_EN)\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_RS);\n\n\t \n\tif (ice_is_phy_caps_an_enabled(caps)) {\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, Autoneg);\n\t}\n\ndone:\n\tkfree(caps);\n\treturn err;\n}\n\n \nstatic u16\nice_ksettings_find_adv_link_speed(const struct ethtool_link_ksettings *ks)\n{\n\tu16 adv_link_speed = 0;\n\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100baseT_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_100MB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseX_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseT_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseKX_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_1000MB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  2500baseT_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  2500baseX_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_2500MB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  5000baseT_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_5GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseT_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseKR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseSR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  10000baseLR_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_10GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  25000baseCR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  25000baseSR_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  25000baseKR_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_25GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseCR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseSR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseLR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  40000baseKR4_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_40GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  50000baseCR2_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  50000baseKR2_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  50000baseSR2_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_50GB;\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100000baseCR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100000baseSR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100000baseLR4_ER4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100000baseKR4_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100000baseCR2_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100000baseSR2_Full) ||\n\t    ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  100000baseKR2_Full))\n\t\tadv_link_speed |= ICE_AQ_LINK_SPEED_100GB;\n\n\treturn adv_link_speed;\n}\n\n \nstatic int\nice_setup_autoneg(struct ice_port_info *p, struct ethtool_link_ksettings *ks,\n\t\t  struct ice_aqc_set_phy_cfg_data *config,\n\t\t  u8 autoneg_enabled, u8 *autoneg_changed,\n\t\t  struct net_device *netdev)\n{\n\tint err = 0;\n\n\t*autoneg_changed = 0;\n\n\t \n\tif (autoneg_enabled == AUTONEG_ENABLE) {\n\t\t \n\t\tif (!(p->phy.link_info.an_info & ICE_AQ_AN_COMPLETED)) {\n\t\t\t \n\t\t\tif (!ethtool_link_ksettings_test_link_mode(ks,\n\t\t\t\t\t\t\t\t   supported,\n\t\t\t\t\t\t\t\t   Autoneg)) {\n\t\t\t\tnetdev_info(netdev, \"Autoneg not supported on this phy.\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tconfig->caps |= ICE_AQ_PHY_ENA_AUTO_LINK_UPDT;\n\t\t\t\t*autoneg_changed = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (p->phy.link_info.an_info & ICE_AQ_AN_COMPLETED) {\n\t\t\t \n\t\t\tif (ethtool_link_ksettings_test_link_mode(ks,\n\t\t\t\t\t\t\t\t  supported,\n\t\t\t\t\t\t\t\t  Autoneg)) {\n\t\t\t\tnetdev_info(netdev, \"Autoneg cannot be disabled on this phy\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tconfig->caps &= ~ICE_AQ_PHY_ENA_AUTO_LINK_UPDT;\n\t\t\t\t*autoneg_changed = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic void\nice_set_phy_type_from_speed(const struct ethtool_link_ksettings *ks,\n\t\t\t    u64 *phy_type_low, u64 *phy_type_high,\n\t\t\t    u16 adv_link_speed)\n{\n\t \n\tadv_link_speed &= ~ICE_AQ_LINK_SPEED_1000MB;\n\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseT_Full))\n\t\t*phy_type_low |= ICE_PHY_TYPE_LOW_1000BASE_T |\n\t\t\t\t ICE_PHY_TYPE_LOW_1G_SGMII;\n\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseKX_Full))\n\t\t*phy_type_low |= ICE_PHY_TYPE_LOW_1000BASE_KX;\n\n\tif (ethtool_link_ksettings_test_link_mode(ks, advertising,\n\t\t\t\t\t\t  1000baseX_Full))\n\t\t*phy_type_low |= ICE_PHY_TYPE_LOW_1000BASE_SX |\n\t\t\t\t ICE_PHY_TYPE_LOW_1000BASE_LX;\n\n\tice_update_phy_type(phy_type_low, phy_type_high, adv_link_speed);\n}\n\n \nstatic int\nice_set_link_ksettings(struct net_device *netdev,\n\t\t       const struct ethtool_link_ksettings *ks)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tu8 autoneg, timeout = TEST_SET_BITS_TIMEOUT;\n\tstruct ethtool_link_ksettings copy_ks = *ks;\n\tstruct ethtool_link_ksettings safe_ks = {};\n\tstruct ice_aqc_get_phy_caps_data *phy_caps;\n\tstruct ice_aqc_set_phy_cfg_data config;\n\tu16 adv_link_speed, curr_link_speed;\n\tstruct ice_pf *pf = np->vsi->back;\n\tstruct ice_port_info *pi;\n\tu8 autoneg_changed = 0;\n\tu64 phy_type_high = 0;\n\tu64 phy_type_low = 0;\n\tbool linkup;\n\tint err;\n\n\tpi = np->vsi->port_info;\n\n\tif (!pi)\n\t\treturn -EIO;\n\n\tif (pi->phy.media_type != ICE_MEDIA_BASET &&\n\t    pi->phy.media_type != ICE_MEDIA_FIBER &&\n\t    pi->phy.media_type != ICE_MEDIA_BACKPLANE &&\n\t    pi->phy.media_type != ICE_MEDIA_DA &&\n\t    pi->phy.link_info.link_info & ICE_AQ_LINK_UP)\n\t\treturn -EOPNOTSUPP;\n\n\tphy_caps = kzalloc(sizeof(*phy_caps), GFP_KERNEL);\n\tif (!phy_caps)\n\t\treturn -ENOMEM;\n\n\t \n\tif (ice_fw_supports_report_dflt_cfg(pi->hw))\n\t\terr = ice_aq_get_phy_caps(pi, false, ICE_AQC_REPORT_DFLT_CFG,\n\t\t\t\t\t  phy_caps, NULL);\n\telse\n\t\terr = ice_aq_get_phy_caps(pi, false, ICE_AQC_REPORT_TOPO_CAP_MEDIA,\n\t\t\t\t\t  phy_caps, NULL);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tautoneg = copy_ks.base.autoneg;\n\n\t \n\tice_phy_type_to_ethtool(netdev, &safe_ks);\n\n\t \n\tif (!bitmap_subset(copy_ks.link_modes.advertising,\n\t\t\t   safe_ks.link_modes.supported,\n\t\t\t   __ETHTOOL_LINK_MODE_MASK_NBITS)) {\n\t\tif (!test_bit(ICE_FLAG_LINK_LENIENT_MODE_ENA, pf->flags))\n\t\t\tnetdev_info(netdev, \"The selected speed is not supported by the current media. Please select a link speed that is supported by the current media.\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\t \n\tmemset(&safe_ks, 0, sizeof(safe_ks));\n\tsafe_ks.base.cmd = copy_ks.base.cmd;\n\tsafe_ks.base.link_mode_masks_nwords =\n\t\tcopy_ks.base.link_mode_masks_nwords;\n\tice_get_link_ksettings(netdev, &safe_ks);\n\n\t \n\tcopy_ks.base.autoneg = safe_ks.base.autoneg;\n\t \n\tcopy_ks.base.speed = safe_ks.base.speed;\n\n\t \n\tif (memcmp(&copy_ks.base, &safe_ks.base, sizeof(copy_ks.base))) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\twhile (test_and_set_bit(ICE_CFG_BUSY, pf->state)) {\n\t\ttimeout--;\n\t\tif (!timeout) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto done;\n\t\t}\n\t\tusleep_range(TEST_SET_BITS_SLEEP_MIN, TEST_SET_BITS_SLEEP_MAX);\n\t}\n\n\t \n\tconfig = pi->phy.curr_user_phy_cfg;\n\n\tconfig.caps |= ICE_AQ_PHY_ENA_AUTO_LINK_UPDT;\n\n\t \n\terr = ice_setup_autoneg(pi, &safe_ks, &config, autoneg, &autoneg_changed,\n\t\t\t\tnetdev);\n\n\tif (err)\n\t\tgoto done;\n\n\t \n\tpi->phy.get_link_info = true;\n\terr = ice_get_link_status(pi, &linkup);\n\tif (err)\n\t\tgoto done;\n\n\tcurr_link_speed = pi->phy.curr_user_speed_req;\n\tadv_link_speed = ice_ksettings_find_adv_link_speed(ks);\n\n\t \n\tif (!adv_link_speed)\n\t\tadv_link_speed = curr_link_speed;\n\n\t \n\tice_set_phy_type_from_speed(ks, &phy_type_low, &phy_type_high,\n\t\t\t\t    adv_link_speed);\n\n\tif (!autoneg_changed && adv_link_speed == curr_link_speed) {\n\t\tnetdev_info(netdev, \"Nothing changed, exiting without setting anything.\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tpi->phy.link_info.req_speeds = adv_link_speed;\n\n\t \n\tconfig.caps |= ICE_AQ_PHY_ENA_LINK;\n\n\t \n\tif (!(phy_type_low || phy_type_high)) {\n\t\tnetdev_info(netdev, \"The selected speed is not supported by the current media. Please select a link speed that is supported by the current media.\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\t \n\tconfig.phy_type_high = cpu_to_le64(phy_type_high) &\n\t\t\tphy_caps->phy_type_high;\n\tconfig.phy_type_low = cpu_to_le64(phy_type_low) &\n\t\t\tphy_caps->phy_type_low;\n\n\tif (!(config.phy_type_high || config.phy_type_low)) {\n\t\t \n\t\tif (test_bit(ICE_FLAG_LINK_LENIENT_MODE_ENA, pf->flags)) {\n\t\t\tconfig.phy_type_high = cpu_to_le64(phy_type_high) &\n\t\t\t\t\t       pf->nvm_phy_type_hi;\n\t\t\tconfig.phy_type_low = cpu_to_le64(phy_type_low) &\n\t\t\t\t\t      pf->nvm_phy_type_lo;\n\t\t} else {\n\t\t\tnetdev_info(netdev, \"The selected speed is not supported by the current media. Please select a link speed that is supported by the current media.\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (pi->phy.link_info.link_info & ICE_AQ_LINK_UP) {\n\t\t \n\t\tice_print_link_msg(np->vsi, false);\n\t\tnetif_carrier_off(netdev);\n\t\tnetif_tx_stop_all_queues(netdev);\n\t}\n\n\t \n\terr = ice_aq_set_phy_cfg(&pf->hw, pi, &config, NULL);\n\tif (err) {\n\t\tnetdev_info(netdev, \"Set phy config failed,\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tpi->phy.curr_user_speed_req = adv_link_speed;\ndone:\n\tkfree(phy_caps);\n\tclear_bit(ICE_CFG_BUSY, pf->state);\n\n\treturn err;\n}\n\n \nstatic u32 ice_parse_hdrs(struct ethtool_rxnfc *nfc)\n{\n\tu32 hdrs = ICE_FLOW_SEG_HDR_NONE;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\thdrs |= ICE_FLOW_SEG_HDR_TCP | ICE_FLOW_SEG_HDR_IPV4;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\thdrs |= ICE_FLOW_SEG_HDR_UDP | ICE_FLOW_SEG_HDR_IPV4;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\thdrs |= ICE_FLOW_SEG_HDR_SCTP | ICE_FLOW_SEG_HDR_IPV4;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\thdrs |= ICE_FLOW_SEG_HDR_TCP | ICE_FLOW_SEG_HDR_IPV6;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\thdrs |= ICE_FLOW_SEG_HDR_UDP | ICE_FLOW_SEG_HDR_IPV6;\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\thdrs |= ICE_FLOW_SEG_HDR_SCTP | ICE_FLOW_SEG_HDR_IPV6;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn hdrs;\n}\n\n#define ICE_FLOW_HASH_FLD_IPV4_SA\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_SA)\n#define ICE_FLOW_HASH_FLD_IPV6_SA\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_SA)\n#define ICE_FLOW_HASH_FLD_IPV4_DA\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_DA)\n#define ICE_FLOW_HASH_FLD_IPV6_DA\tBIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_DA)\n#define ICE_FLOW_HASH_FLD_TCP_SRC_PORT\tBIT_ULL(ICE_FLOW_FIELD_IDX_TCP_SRC_PORT)\n#define ICE_FLOW_HASH_FLD_TCP_DST_PORT\tBIT_ULL(ICE_FLOW_FIELD_IDX_TCP_DST_PORT)\n#define ICE_FLOW_HASH_FLD_UDP_SRC_PORT\tBIT_ULL(ICE_FLOW_FIELD_IDX_UDP_SRC_PORT)\n#define ICE_FLOW_HASH_FLD_UDP_DST_PORT\tBIT_ULL(ICE_FLOW_FIELD_IDX_UDP_DST_PORT)\n#define ICE_FLOW_HASH_FLD_SCTP_SRC_PORT\t\\\n\tBIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_SRC_PORT)\n#define ICE_FLOW_HASH_FLD_SCTP_DST_PORT\t\\\n\tBIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_DST_PORT)\n\n \nstatic u64 ice_parse_hash_flds(struct ethtool_rxnfc *nfc)\n{\n\tu64 hfld = ICE_HASH_INVALID;\n\n\tif (nfc->data & RXH_IP_SRC || nfc->data & RXH_IP_DST) {\n\t\tswitch (nfc->flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\t\tif (nfc->data & RXH_IP_SRC)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_IPV4_SA;\n\t\t\tif (nfc->data & RXH_IP_DST)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_IPV4_DA;\n\t\t\tbreak;\n\t\tcase TCP_V6_FLOW:\n\t\tcase UDP_V6_FLOW:\n\t\tcase SCTP_V6_FLOW:\n\t\t\tif (nfc->data & RXH_IP_SRC)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_IPV6_SA;\n\t\t\tif (nfc->data & RXH_IP_DST)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_IPV6_DA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nfc->data & RXH_L4_B_0_1 || nfc->data & RXH_L4_B_2_3) {\n\t\tswitch (nfc->flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\tcase TCP_V6_FLOW:\n\t\t\tif (nfc->data & RXH_L4_B_0_1)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_TCP_SRC_PORT;\n\t\t\tif (nfc->data & RXH_L4_B_2_3)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_TCP_DST_PORT;\n\t\t\tbreak;\n\t\tcase UDP_V4_FLOW:\n\t\tcase UDP_V6_FLOW:\n\t\t\tif (nfc->data & RXH_L4_B_0_1)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_UDP_SRC_PORT;\n\t\t\tif (nfc->data & RXH_L4_B_2_3)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_UDP_DST_PORT;\n\t\t\tbreak;\n\t\tcase SCTP_V4_FLOW:\n\t\tcase SCTP_V6_FLOW:\n\t\t\tif (nfc->data & RXH_L4_B_0_1)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_SCTP_SRC_PORT;\n\t\t\tif (nfc->data & RXH_L4_B_2_3)\n\t\t\t\thfld |= ICE_FLOW_HASH_FLD_SCTP_DST_PORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hfld;\n}\n\n \nstatic int\nice_set_rss_hash_opt(struct ice_vsi *vsi, struct ethtool_rxnfc *nfc)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct device *dev;\n\tu64 hashed_flds;\n\tint status;\n\tu32 hdrs;\n\n\tdev = ice_pf_to_dev(pf);\n\tif (ice_is_safe_mode(pf)) {\n\t\tdev_dbg(dev, \"Advanced RSS disabled. Package download failed, vsi num = %d\\n\",\n\t\t\tvsi->vsi_num);\n\t\treturn -EINVAL;\n\t}\n\n\thashed_flds = ice_parse_hash_flds(nfc);\n\tif (hashed_flds == ICE_HASH_INVALID) {\n\t\tdev_dbg(dev, \"Invalid hash fields, vsi num = %d\\n\",\n\t\t\tvsi->vsi_num);\n\t\treturn -EINVAL;\n\t}\n\n\thdrs = ice_parse_hdrs(nfc);\n\tif (hdrs == ICE_FLOW_SEG_HDR_NONE) {\n\t\tdev_dbg(dev, \"Header type is not valid, vsi num = %d\\n\",\n\t\t\tvsi->vsi_num);\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = ice_add_rss_cfg(&pf->hw, vsi->idx, hashed_flds, hdrs);\n\tif (status) {\n\t\tdev_dbg(dev, \"ice_add_rss_cfg failed, vsi num = %d, error = %d\\n\",\n\t\t\tvsi->vsi_num, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nice_get_rss_hash_opt(struct ice_vsi *vsi, struct ethtool_rxnfc *nfc)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct device *dev;\n\tu64 hash_flds;\n\tu32 hdrs;\n\n\tdev = ice_pf_to_dev(pf);\n\n\tnfc->data = 0;\n\tif (ice_is_safe_mode(pf)) {\n\t\tdev_dbg(dev, \"Advanced RSS disabled. Package download failed, vsi num = %d\\n\",\n\t\t\tvsi->vsi_num);\n\t\treturn;\n\t}\n\n\thdrs = ice_parse_hdrs(nfc);\n\tif (hdrs == ICE_FLOW_SEG_HDR_NONE) {\n\t\tdev_dbg(dev, \"Header type is not valid, vsi num = %d\\n\",\n\t\t\tvsi->vsi_num);\n\t\treturn;\n\t}\n\n\thash_flds = ice_get_rss_cfg(&pf->hw, vsi->idx, hdrs);\n\tif (hash_flds == ICE_HASH_INVALID) {\n\t\tdev_dbg(dev, \"No hash fields found for the given header type, vsi num = %d\\n\",\n\t\t\tvsi->vsi_num);\n\t\treturn;\n\t}\n\n\tif (hash_flds & ICE_FLOW_HASH_FLD_IPV4_SA ||\n\t    hash_flds & ICE_FLOW_HASH_FLD_IPV6_SA)\n\t\tnfc->data |= (u64)RXH_IP_SRC;\n\n\tif (hash_flds & ICE_FLOW_HASH_FLD_IPV4_DA ||\n\t    hash_flds & ICE_FLOW_HASH_FLD_IPV6_DA)\n\t\tnfc->data |= (u64)RXH_IP_DST;\n\n\tif (hash_flds & ICE_FLOW_HASH_FLD_TCP_SRC_PORT ||\n\t    hash_flds & ICE_FLOW_HASH_FLD_UDP_SRC_PORT ||\n\t    hash_flds & ICE_FLOW_HASH_FLD_SCTP_SRC_PORT)\n\t\tnfc->data |= (u64)RXH_L4_B_0_1;\n\n\tif (hash_flds & ICE_FLOW_HASH_FLD_TCP_DST_PORT ||\n\t    hash_flds & ICE_FLOW_HASH_FLD_UDP_DST_PORT ||\n\t    hash_flds & ICE_FLOW_HASH_FLD_SCTP_DST_PORT)\n\t\tnfc->data |= (u64)RXH_L4_B_2_3;\n}\n\n \nstatic int ice_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\treturn ice_add_fdir_ethtool(vsi, cmd);\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\treturn ice_del_fdir_ethtool(vsi, cmd);\n\tcase ETHTOOL_SRXFH:\n\t\treturn ice_set_rss_hash_opt(vsi, cmd);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int\nice_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd,\n\t      u32 __always_unused *rule_locs)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tint ret = -EOPNOTSUPP;\n\tstruct ice_hw *hw;\n\n\thw = &vsi->back->hw;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = vsi->rss_size;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = hw->fdir_active_fltr;\n\t\t \n\t\tcmd->data = ice_get_fdir_cnt_all(hw);\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = ice_get_ethtool_fdir_entry(hw, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tret = ice_get_fdir_fltr_ids(hw, cmd, (u32 *)rule_locs);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\tice_get_rss_hash_opt(vsi, cmd);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void\nice_get_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring,\n\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\n\tring->rx_max_pending = ICE_MAX_NUM_DESC;\n\tring->tx_max_pending = ICE_MAX_NUM_DESC;\n\tif (vsi->tx_rings && vsi->rx_rings) {\n\t\tring->rx_pending = vsi->rx_rings[0]->count;\n\t\tring->tx_pending = vsi->tx_rings[0]->count;\n\t} else {\n\t\tring->rx_pending = 0;\n\t\tring->tx_pending = 0;\n\t}\n\n\t \n\tring->rx_mini_max_pending = 0;\n\tring->rx_jumbo_max_pending = 0;\n\tring->rx_mini_pending = 0;\n\tring->rx_jumbo_pending = 0;\n}\n\nstatic int\nice_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring,\n\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_tx_ring *xdp_rings = NULL;\n\tstruct ice_tx_ring *tx_rings = NULL;\n\tstruct ice_rx_ring *rx_rings = NULL;\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tint i, timeout = 50, err = 0;\n\tu16 new_rx_cnt, new_tx_cnt;\n\n\tif (ring->tx_pending > ICE_MAX_NUM_DESC ||\n\t    ring->tx_pending < ICE_MIN_NUM_DESC ||\n\t    ring->rx_pending > ICE_MAX_NUM_DESC ||\n\t    ring->rx_pending < ICE_MIN_NUM_DESC) {\n\t\tnetdev_err(netdev, \"Descriptors requested (Tx: %d / Rx: %d) out of range [%d-%d] (increment %d)\\n\",\n\t\t\t   ring->tx_pending, ring->rx_pending,\n\t\t\t   ICE_MIN_NUM_DESC, ICE_MAX_NUM_DESC,\n\t\t\t   ICE_REQ_DESC_MULTIPLE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!vsi->tx_rings || !vsi->rx_rings)\n\t\treturn -EBUSY;\n\n\tnew_tx_cnt = ALIGN(ring->tx_pending, ICE_REQ_DESC_MULTIPLE);\n\tif (new_tx_cnt != ring->tx_pending)\n\t\tnetdev_info(netdev, \"Requested Tx descriptor count rounded up to %d\\n\",\n\t\t\t    new_tx_cnt);\n\tnew_rx_cnt = ALIGN(ring->rx_pending, ICE_REQ_DESC_MULTIPLE);\n\tif (new_rx_cnt != ring->rx_pending)\n\t\tnetdev_info(netdev, \"Requested Rx descriptor count rounded up to %d\\n\",\n\t\t\t    new_rx_cnt);\n\n\t \n\tif (new_tx_cnt == vsi->tx_rings[0]->count &&\n\t    new_rx_cnt == vsi->rx_rings[0]->count) {\n\t\tnetdev_dbg(netdev, \"Nothing to change, descriptor count is same as requested\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (ice_xsk_any_rx_ring_ena(vsi))\n\t\treturn -EBUSY;\n\n\twhile (test_and_set_bit(ICE_CFG_BUSY, pf->state)) {\n\t\ttimeout--;\n\t\tif (!timeout)\n\t\t\treturn -EBUSY;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\tif (!netif_running(vsi->netdev)) {\n\t\tice_for_each_alloc_txq(vsi, i)\n\t\t\tvsi->tx_rings[i]->count = new_tx_cnt;\n\t\tice_for_each_alloc_rxq(vsi, i)\n\t\t\tvsi->rx_rings[i]->count = new_rx_cnt;\n\t\tif (ice_is_xdp_ena_vsi(vsi))\n\t\t\tice_for_each_xdp_txq(vsi, i)\n\t\t\t\tvsi->xdp_rings[i]->count = new_tx_cnt;\n\t\tvsi->num_tx_desc = (u16)new_tx_cnt;\n\t\tvsi->num_rx_desc = (u16)new_rx_cnt;\n\t\tnetdev_dbg(netdev, \"Link is down, descriptor count change happens when link is brought up\\n\");\n\t\tgoto done;\n\t}\n\n\tif (new_tx_cnt == vsi->tx_rings[0]->count)\n\t\tgoto process_rx;\n\n\t \n\tnetdev_info(netdev, \"Changing Tx descriptor count from %d to %d\\n\",\n\t\t    vsi->tx_rings[0]->count, new_tx_cnt);\n\n\ttx_rings = kcalloc(vsi->num_txq, sizeof(*tx_rings), GFP_KERNEL);\n\tif (!tx_rings) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tice_for_each_txq(vsi, i) {\n\t\t \n\t\ttx_rings[i] = *vsi->tx_rings[i];\n\t\ttx_rings[i].count = new_tx_cnt;\n\t\ttx_rings[i].desc = NULL;\n\t\ttx_rings[i].tx_buf = NULL;\n\t\ttx_rings[i].tx_tstamps = &pf->ptp.port.tx;\n\t\terr = ice_setup_tx_ring(&tx_rings[i]);\n\t\tif (err) {\n\t\t\twhile (i--)\n\t\t\t\tice_clean_tx_ring(&tx_rings[i]);\n\t\t\tkfree(tx_rings);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!ice_is_xdp_ena_vsi(vsi))\n\t\tgoto process_rx;\n\n\t \n\tnetdev_info(netdev, \"Changing XDP descriptor count from %d to %d\\n\",\n\t\t    vsi->xdp_rings[0]->count, new_tx_cnt);\n\n\txdp_rings = kcalloc(vsi->num_xdp_txq, sizeof(*xdp_rings), GFP_KERNEL);\n\tif (!xdp_rings) {\n\t\terr = -ENOMEM;\n\t\tgoto free_tx;\n\t}\n\n\tice_for_each_xdp_txq(vsi, i) {\n\t\t \n\t\txdp_rings[i] = *vsi->xdp_rings[i];\n\t\txdp_rings[i].count = new_tx_cnt;\n\t\txdp_rings[i].desc = NULL;\n\t\txdp_rings[i].tx_buf = NULL;\n\t\terr = ice_setup_tx_ring(&xdp_rings[i]);\n\t\tif (err) {\n\t\t\twhile (i--)\n\t\t\t\tice_clean_tx_ring(&xdp_rings[i]);\n\t\t\tkfree(xdp_rings);\n\t\t\tgoto free_tx;\n\t\t}\n\t\tice_set_ring_xdp(&xdp_rings[i]);\n\t}\n\nprocess_rx:\n\tif (new_rx_cnt == vsi->rx_rings[0]->count)\n\t\tgoto process_link;\n\n\t \n\tnetdev_info(netdev, \"Changing Rx descriptor count from %d to %d\\n\",\n\t\t    vsi->rx_rings[0]->count, new_rx_cnt);\n\n\trx_rings = kcalloc(vsi->num_rxq, sizeof(*rx_rings), GFP_KERNEL);\n\tif (!rx_rings) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tice_for_each_rxq(vsi, i) {\n\t\t \n\t\trx_rings[i] = *vsi->rx_rings[i];\n\t\trx_rings[i].count = new_rx_cnt;\n\t\trx_rings[i].cached_phctime = pf->ptp.cached_phc_time;\n\t\trx_rings[i].desc = NULL;\n\t\trx_rings[i].rx_buf = NULL;\n\t\t \n\t\trx_rings[i].tail = vsi->back->hw.hw_addr + PRTGEN_STATUS;\n\n\t\terr = ice_setup_rx_ring(&rx_rings[i]);\n\t\tif (err)\n\t\t\tgoto rx_unwind;\n\n\t\t \n\t\terr = ice_alloc_rx_bufs(&rx_rings[i],\n\t\t\t\t\tICE_RX_DESC_UNUSED(&rx_rings[i]));\nrx_unwind:\n\t\tif (err) {\n\t\t\twhile (i) {\n\t\t\t\ti--;\n\t\t\t\tice_free_rx_ring(&rx_rings[i]);\n\t\t\t}\n\t\t\tkfree(rx_rings);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_tx;\n\t\t}\n\t}\n\nprocess_link:\n\t \n\tif (!test_and_set_bit(ICE_VSI_DOWN, vsi->state)) {\n\t\tice_down(vsi);\n\n\t\tif (tx_rings) {\n\t\t\tice_for_each_txq(vsi, i) {\n\t\t\t\tice_free_tx_ring(vsi->tx_rings[i]);\n\t\t\t\t*vsi->tx_rings[i] = tx_rings[i];\n\t\t\t}\n\t\t\tkfree(tx_rings);\n\t\t}\n\n\t\tif (rx_rings) {\n\t\t\tice_for_each_rxq(vsi, i) {\n\t\t\t\tice_free_rx_ring(vsi->rx_rings[i]);\n\t\t\t\t \n\t\t\t\trx_rings[i].tail = vsi->rx_rings[i]->tail;\n\t\t\t\t \n\t\t\t\trx_rings[i].next_to_use = 0;\n\t\t\t\trx_rings[i].next_to_clean = 0;\n\t\t\t\trx_rings[i].next_to_alloc = 0;\n\t\t\t\t*vsi->rx_rings[i] = rx_rings[i];\n\t\t\t}\n\t\t\tkfree(rx_rings);\n\t\t}\n\n\t\tif (xdp_rings) {\n\t\t\tice_for_each_xdp_txq(vsi, i) {\n\t\t\t\tice_free_tx_ring(vsi->xdp_rings[i]);\n\t\t\t\t*vsi->xdp_rings[i] = xdp_rings[i];\n\t\t\t}\n\t\t\tkfree(xdp_rings);\n\t\t}\n\n\t\tvsi->num_tx_desc = new_tx_cnt;\n\t\tvsi->num_rx_desc = new_rx_cnt;\n\t\tice_up(vsi);\n\t}\n\tgoto done;\n\nfree_tx:\n\t \n\tif (tx_rings) {\n\t\tice_for_each_txq(vsi, i)\n\t\t\tice_free_tx_ring(&tx_rings[i]);\n\t\tkfree(tx_rings);\n\t}\n\ndone:\n\tclear_bit(ICE_CFG_BUSY, pf->state);\n\treturn err;\n}\n\n \nstatic void\nice_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_port_info *pi = np->vsi->port_info;\n\tstruct ice_aqc_get_phy_caps_data *pcaps;\n\tstruct ice_dcbx_cfg *dcbx_cfg;\n\tint status;\n\n\t \n\tpause->rx_pause = 0;\n\tpause->tx_pause = 0;\n\n\tdcbx_cfg = &pi->qos_cfg.local_dcbx_cfg;\n\n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\tif (!pcaps)\n\t\treturn;\n\n\t \n\tstatus = ice_aq_get_phy_caps(pi, false, ICE_AQC_REPORT_ACTIVE_CFG, pcaps,\n\t\t\t\t     NULL);\n\tif (status)\n\t\tgoto out;\n\n\tpause->autoneg = ice_is_phy_caps_an_enabled(pcaps) ? AUTONEG_ENABLE :\n\t\t\t\t\t\t\t     AUTONEG_DISABLE;\n\n\tif (dcbx_cfg->pfc.pfcena)\n\t\t \n\t\tgoto out;\n\n\tif (pcaps->caps & ICE_AQC_PHY_EN_TX_LINK_PAUSE)\n\t\tpause->tx_pause = 1;\n\tif (pcaps->caps & ICE_AQC_PHY_EN_RX_LINK_PAUSE)\n\t\tpause->rx_pause = 1;\n\nout:\n\tkfree(pcaps);\n}\n\n \nstatic int\nice_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_aqc_get_phy_caps_data *pcaps;\n\tstruct ice_link_status *hw_link_info;\n\tstruct ice_pf *pf = np->vsi->back;\n\tstruct ice_dcbx_cfg *dcbx_cfg;\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_port_info *pi;\n\tu8 aq_failures;\n\tbool link_up;\n\tu32 is_an;\n\tint err;\n\n\tpi = vsi->port_info;\n\thw_link_info = &pi->phy.link_info;\n\tdcbx_cfg = &pi->qos_cfg.local_dcbx_cfg;\n\tlink_up = hw_link_info->link_info & ICE_AQ_LINK_UP;\n\n\t \n\tif (vsi->type != ICE_VSI_PF) {\n\t\tnetdev_info(netdev, \"Changing flow control parameters only supported for PF VSI\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\tif (!pcaps)\n\t\treturn -ENOMEM;\n\n\t \n\terr = ice_aq_get_phy_caps(pi, false, ICE_AQC_REPORT_ACTIVE_CFG, pcaps,\n\t\t\t\t  NULL);\n\tif (err) {\n\t\tkfree(pcaps);\n\t\treturn err;\n\t}\n\n\tis_an = ice_is_phy_caps_an_enabled(pcaps) ? AUTONEG_ENABLE :\n\t\t\t\t\t\t    AUTONEG_DISABLE;\n\n\tkfree(pcaps);\n\n\tif (pause->autoneg != is_an) {\n\t\tnetdev_info(netdev, \"To change autoneg please use: ethtool -s <dev> autoneg <on|off>\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!test_bit(ICE_DOWN, pf->state) &&\n\t    !(hw_link_info->an_info & ICE_AQ_AN_COMPLETED)) {\n\t\t \n\t\tnetdev_info(netdev, \"Autoneg did not complete so changing settings may not result in an actual change.\\n\");\n\t}\n\n\tif (dcbx_cfg->pfc.pfcena) {\n\t\tnetdev_info(netdev, \"Priority flow control enabled. Cannot set link flow control.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (pause->rx_pause && pause->tx_pause)\n\t\tpi->fc.req_mode = ICE_FC_FULL;\n\telse if (pause->rx_pause && !pause->tx_pause)\n\t\tpi->fc.req_mode = ICE_FC_RX_PAUSE;\n\telse if (!pause->rx_pause && pause->tx_pause)\n\t\tpi->fc.req_mode = ICE_FC_TX_PAUSE;\n\telse if (!pause->rx_pause && !pause->tx_pause)\n\t\tpi->fc.req_mode = ICE_FC_NONE;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\terr = ice_set_fc(pi, &aq_failures, link_up);\n\n\tif (aq_failures & ICE_SET_FC_AQ_FAIL_GET) {\n\t\tnetdev_info(netdev, \"Set fc failed on the get_phy_capabilities call with err %d aq_err %s\\n\",\n\t\t\t    err, ice_aq_str(hw->adminq.sq_last_status));\n\t\terr = -EAGAIN;\n\t} else if (aq_failures & ICE_SET_FC_AQ_FAIL_SET) {\n\t\tnetdev_info(netdev, \"Set fc failed on the set_phy_config call with err %d aq_err %s\\n\",\n\t\t\t    err, ice_aq_str(hw->adminq.sq_last_status));\n\t\terr = -EAGAIN;\n\t} else if (aq_failures & ICE_SET_FC_AQ_FAIL_UPDATE) {\n\t\tnetdev_info(netdev, \"Set fc failed on the get_link_info call with err %d aq_err %s\\n\",\n\t\t\t    err, ice_aq_str(hw->adminq.sq_last_status));\n\t\terr = -EAGAIN;\n\t}\n\n\treturn err;\n}\n\n \nstatic u32 ice_get_rxfh_key_size(struct net_device __always_unused *netdev)\n{\n\treturn ICE_VSIQF_HKEY_ARRAY_SIZE;\n}\n\n \nstatic u32 ice_get_rxfh_indir_size(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\n\treturn np->vsi->rss_table_size;\n}\n\nstatic int\nice_get_rxfh_context(struct net_device *netdev, u32 *indir,\n\t\t     u8 *key, u8 *hfunc, u32 rss_context)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tu16 qcount, offset;\n\tint err, num_tc, i;\n\tu8 *lut;\n\n\tif (!test_bit(ICE_FLAG_RSS_ENA, pf->flags)) {\n\t\tnetdev_warn(netdev, \"RSS is not supported on this VSI!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (rss_context && !ice_is_adq_active(pf)) {\n\t\tnetdev_err(netdev, \"RSS context cannot be non-zero when ADQ is not configured.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqcount = vsi->mqprio_qopt.qopt.count[rss_context];\n\toffset = vsi->mqprio_qopt.qopt.offset[rss_context];\n\n\tif (rss_context && ice_is_adq_active(pf)) {\n\t\tnum_tc = vsi->mqprio_qopt.qopt.num_tc;\n\t\tif (rss_context >= num_tc) {\n\t\t\tnetdev_err(netdev, \"RSS context:%d  > num_tc:%d\\n\",\n\t\t\t\t   rss_context, num_tc);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tvsi = vsi->tc_map_vsi[rss_context];\n\t}\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\tif (!indir)\n\t\treturn 0;\n\n\tlut = kzalloc(vsi->rss_table_size, GFP_KERNEL);\n\tif (!lut)\n\t\treturn -ENOMEM;\n\n\terr = ice_get_rss_key(vsi, key);\n\tif (err)\n\t\tgoto out;\n\n\terr = ice_get_rss_lut(vsi, lut, vsi->rss_table_size);\n\tif (err)\n\t\tgoto out;\n\n\tif (ice_is_adq_active(pf)) {\n\t\tfor (i = 0; i < vsi->rss_table_size; i++)\n\t\t\tindir[i] = offset + lut[i] % qcount;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < vsi->rss_table_size; i++)\n\t\tindir[i] = lut[i];\n\nout:\n\tkfree(lut);\n\treturn err;\n}\n\n \nstatic int\nice_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key, u8 *hfunc)\n{\n\treturn ice_get_rxfh_context(netdev, indir, key, hfunc, 0);\n}\n\n \nstatic int\nice_set_rxfh(struct net_device *netdev, const u32 *indir, const u8 *key,\n\t     const u8 hfunc)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct device *dev;\n\tint err;\n\n\tdev = ice_pf_to_dev(pf);\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!test_bit(ICE_FLAG_RSS_ENA, pf->flags)) {\n\t\t \n\t\tnetdev_warn(netdev, \"RSS is not configured on this VSI!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ice_is_adq_active(pf)) {\n\t\tnetdev_err(netdev, \"Cannot change RSS params with ADQ configured.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (key) {\n\t\tif (!vsi->rss_hkey_user) {\n\t\t\tvsi->rss_hkey_user =\n\t\t\t\tdevm_kzalloc(dev, ICE_VSIQF_HKEY_ARRAY_SIZE,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!vsi->rss_hkey_user)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(vsi->rss_hkey_user, key, ICE_VSIQF_HKEY_ARRAY_SIZE);\n\n\t\terr = ice_set_rss_key(vsi, vsi->rss_hkey_user);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!vsi->rss_lut_user) {\n\t\tvsi->rss_lut_user = devm_kzalloc(dev, vsi->rss_table_size,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!vsi->rss_lut_user)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (indir) {\n\t\tint i;\n\n\t\tfor (i = 0; i < vsi->rss_table_size; i++)\n\t\t\tvsi->rss_lut_user[i] = (u8)(indir[i]);\n\t} else {\n\t\tice_fill_rss_lut(vsi->rss_lut_user, vsi->rss_table_size,\n\t\t\t\t vsi->rss_size);\n\t}\n\n\terr = ice_set_rss_lut(vsi, vsi->rss_lut_user, vsi->rss_table_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nice_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(dev);\n\n\t \n\tif (!test_bit(ICE_FLAG_PTP, pf->flags))\n\t\treturn ethtool_op_get_ts_info(dev, info);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->phc_index = ice_get_ptp_clock_index(pf);\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) | BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\n \nstatic int ice_get_max_txq(struct ice_pf *pf)\n{\n\treturn min3(pf->num_lan_msix, (u16)num_online_cpus(),\n\t\t    (u16)pf->hw.func_caps.common_cap.num_txq);\n}\n\n \nstatic int ice_get_max_rxq(struct ice_pf *pf)\n{\n\treturn min3(pf->num_lan_msix, (u16)num_online_cpus(),\n\t\t    (u16)pf->hw.func_caps.common_cap.num_rxq);\n}\n\n \nstatic u32 ice_get_combined_cnt(struct ice_vsi *vsi)\n{\n\tu32 combined = 0;\n\tint q_idx;\n\n\tice_for_each_q_vector(vsi, q_idx) {\n\t\tstruct ice_q_vector *q_vector = vsi->q_vectors[q_idx];\n\n\t\tif (q_vector->rx.rx_ring && q_vector->tx.tx_ring)\n\t\t\tcombined++;\n\t}\n\n\treturn combined;\n}\n\n \nstatic void\nice_get_channels(struct net_device *dev, struct ethtool_channels *ch)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(dev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\n\t \n\tch->max_rx = ice_get_max_rxq(pf);\n\tch->max_tx = ice_get_max_txq(pf);\n\tch->max_combined = min_t(int, ch->max_rx, ch->max_tx);\n\n\t \n\tch->combined_count = ice_get_combined_cnt(vsi);\n\tch->rx_count = vsi->num_rxq - ch->combined_count;\n\tch->tx_count = vsi->num_txq - ch->combined_count;\n\n\t \n\tch->other_count = test_bit(ICE_FLAG_FD_ENA, pf->flags) ? 1 : 0;\n\tch->max_other = ch->other_count;\n}\n\n \nstatic int ice_get_valid_rss_size(struct ice_hw *hw, int new_size)\n{\n\tstruct ice_hw_common_caps *caps = &hw->func_caps.common_cap;\n\n\treturn min_t(int, new_size, BIT(caps->rss_table_entry_width));\n}\n\n \nstatic int ice_vsi_set_dflt_rss_lut(struct ice_vsi *vsi, int req_rss_size)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct device *dev;\n\tstruct ice_hw *hw;\n\tint err;\n\tu8 *lut;\n\n\tdev = ice_pf_to_dev(pf);\n\thw = &pf->hw;\n\n\tif (!req_rss_size)\n\t\treturn -EINVAL;\n\n\tlut = kzalloc(vsi->rss_table_size, GFP_KERNEL);\n\tif (!lut)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!test_bit(ICE_FLAG_RSS_ENA, pf->flags))\n\t\tvsi->rss_size = 1;\n\telse\n\t\tvsi->rss_size = ice_get_valid_rss_size(hw, req_rss_size);\n\n\t \n\tice_fill_rss_lut(lut, vsi->rss_table_size, vsi->rss_size);\n\terr = ice_set_rss_lut(vsi, lut, vsi->rss_table_size);\n\tif (err)\n\t\tdev_err(dev, \"Cannot set RSS lut, err %d aq_err %s\\n\", err,\n\t\t\tice_aq_str(hw->adminq.sq_last_status));\n\n\tkfree(lut);\n\treturn err;\n}\n\n \nstatic int ice_set_channels(struct net_device *dev, struct ethtool_channels *ch)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(dev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tint new_rx = 0, new_tx = 0;\n\tbool locked = false;\n\tu32 curr_combined;\n\tint ret = 0;\n\n\t \n\tif (ice_is_safe_mode(pf)) {\n\t\tnetdev_err(dev, \"Changing channel in Safe Mode is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\t \n\tif (ch->other_count != (test_bit(ICE_FLAG_FD_ENA, pf->flags) ? 1U : 0U))\n\t\treturn -EINVAL;\n\n\tif (ice_is_adq_active(pf)) {\n\t\tnetdev_err(dev, \"Cannot set channels with ADQ configured.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (test_bit(ICE_FLAG_FD_ENA, pf->flags) && pf->hw.fdir_active_fltr) {\n\t\tnetdev_err(dev, \"Cannot set channels when Flow Director filters are active\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcurr_combined = ice_get_combined_cnt(vsi);\n\n\t \n\tif (ch->rx_count == vsi->num_rxq - curr_combined)\n\t\tch->rx_count = 0;\n\tif (ch->tx_count == vsi->num_txq - curr_combined)\n\t\tch->tx_count = 0;\n\tif (ch->combined_count == curr_combined)\n\t\tch->combined_count = 0;\n\n\tif (!(ch->combined_count || (ch->rx_count && ch->tx_count))) {\n\t\tnetdev_err(dev, \"Please specify at least 1 Rx and 1 Tx channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnew_rx = ch->combined_count + ch->rx_count;\n\tnew_tx = ch->combined_count + ch->tx_count;\n\n\tif (new_rx < vsi->tc_cfg.numtc) {\n\t\tnetdev_err(dev, \"Cannot set less Rx channels, than Traffic Classes you have (%u)\\n\",\n\t\t\t   vsi->tc_cfg.numtc);\n\t\treturn -EINVAL;\n\t}\n\tif (new_tx < vsi->tc_cfg.numtc) {\n\t\tnetdev_err(dev, \"Cannot set less Tx channels, than Traffic Classes you have (%u)\\n\",\n\t\t\t   vsi->tc_cfg.numtc);\n\t\treturn -EINVAL;\n\t}\n\tif (new_rx > ice_get_max_rxq(pf)) {\n\t\tnetdev_err(dev, \"Maximum allowed Rx channels is %d\\n\",\n\t\t\t   ice_get_max_rxq(pf));\n\t\treturn -EINVAL;\n\t}\n\tif (new_tx > ice_get_max_txq(pf)) {\n\t\tnetdev_err(dev, \"Maximum allowed Tx channels is %d\\n\",\n\t\t\t   ice_get_max_txq(pf));\n\t\treturn -EINVAL;\n\t}\n\n\tif (pf->adev) {\n\t\tmutex_lock(&pf->adev_mutex);\n\t\tdevice_lock(&pf->adev->dev);\n\t\tlocked = true;\n\t\tif (pf->adev->dev.driver) {\n\t\t\tnetdev_err(dev, \"Cannot change channels when RDMA is active\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto adev_unlock;\n\t\t}\n\t}\n\n\tice_vsi_recfg_qs(vsi, new_rx, new_tx, locked);\n\n\tif (!netif_is_rxfh_configured(dev)) {\n\t\tret = ice_vsi_set_dflt_rss_lut(vsi, new_rx);\n\t\tgoto adev_unlock;\n\t}\n\n\t \n\tvsi->rss_size = ice_get_valid_rss_size(&pf->hw, new_rx);\n\nadev_unlock:\n\tif (locked) {\n\t\tdevice_unlock(&pf->adev->dev);\n\t\tmutex_unlock(&pf->adev_mutex);\n\t}\n\treturn ret;\n}\n\n \nstatic void ice_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_pf *pf = np->vsi->back;\n\n\tif (np->vsi->type != ICE_VSI_PF)\n\t\tnetdev_warn(netdev, \"Wake on LAN is not supported on this interface!\\n\");\n\n\t \n\tif (ice_is_wol_supported(&pf->hw)) {\n\t\twol->supported = WAKE_MAGIC;\n\t\twol->wolopts = pf->wol_ena ? WAKE_MAGIC : 0;\n\t} else {\n\t\twol->supported = 0;\n\t\twol->wolopts = 0;\n\t}\n}\n\n \nstatic int ice_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\n\tif (vsi->type != ICE_VSI_PF || !ice_is_wol_supported(&pf->hw))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (wol->wolopts && wol->wolopts != WAKE_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (pf->wol_ena != !!wol->wolopts) {\n\t\tpf->wol_ena = !!wol->wolopts;\n\t\tdevice_set_wakeup_enable(ice_pf_to_dev(pf), pf->wol_ena);\n\t\tnetdev_dbg(netdev, \"WoL magic packet %sabled\\n\",\n\t\t\t   pf->wol_ena ? \"en\" : \"dis\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_get_rc_coalesce(struct ethtool_coalesce *ec, struct ice_ring_container *rc)\n{\n\tif (!rc->rx_ring)\n\t\treturn -EINVAL;\n\n\tswitch (rc->type) {\n\tcase ICE_RX_CONTAINER:\n\t\tec->use_adaptive_rx_coalesce = ITR_IS_DYNAMIC(rc);\n\t\tec->rx_coalesce_usecs = rc->itr_setting;\n\t\tec->rx_coalesce_usecs_high = rc->rx_ring->q_vector->intrl;\n\t\tbreak;\n\tcase ICE_TX_CONTAINER:\n\t\tec->use_adaptive_tx_coalesce = ITR_IS_DYNAMIC(rc);\n\t\tec->tx_coalesce_usecs = rc->itr_setting;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(ice_pf_to_dev(rc->rx_ring->vsi->back), \"Invalid c_type %d\\n\", rc->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_get_q_coalesce(struct ice_vsi *vsi, struct ethtool_coalesce *ec, int q_num)\n{\n\tif (q_num < vsi->num_rxq && q_num < vsi->num_txq) {\n\t\tif (ice_get_rc_coalesce(ec,\n\t\t\t\t\t&vsi->rx_rings[q_num]->q_vector->rx))\n\t\t\treturn -EINVAL;\n\t\tif (ice_get_rc_coalesce(ec,\n\t\t\t\t\t&vsi->tx_rings[q_num]->q_vector->tx))\n\t\t\treturn -EINVAL;\n\t} else if (q_num < vsi->num_rxq) {\n\t\tif (ice_get_rc_coalesce(ec,\n\t\t\t\t\t&vsi->rx_rings[q_num]->q_vector->rx))\n\t\t\treturn -EINVAL;\n\t} else if (q_num < vsi->num_txq) {\n\t\tif (ice_get_rc_coalesce(ec,\n\t\t\t\t\t&vsi->tx_rings[q_num]->q_vector->tx))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\n__ice_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec,\n\t\t   int q_num)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\n\tif (q_num < 0)\n\t\tq_num = 0;\n\n\tif (ice_get_q_coalesce(vsi, ec, q_num))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ice_get_coalesce(struct net_device *netdev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn __ice_get_coalesce(netdev, ec, -1);\n}\n\nstatic int\nice_get_per_q_coalesce(struct net_device *netdev, u32 q_num,\n\t\t       struct ethtool_coalesce *ec)\n{\n\treturn __ice_get_coalesce(netdev, ec, q_num);\n}\n\n \nstatic int\nice_set_rc_coalesce(struct ethtool_coalesce *ec,\n\t\t    struct ice_ring_container *rc, struct ice_vsi *vsi)\n{\n\tconst char *c_type_str = (rc->type == ICE_RX_CONTAINER) ? \"rx\" : \"tx\";\n\tu32 use_adaptive_coalesce, coalesce_usecs;\n\tstruct ice_pf *pf = vsi->back;\n\tu16 itr_setting;\n\n\tif (!rc->rx_ring)\n\t\treturn -EINVAL;\n\n\tswitch (rc->type) {\n\tcase ICE_RX_CONTAINER:\n\t{\n\t\tstruct ice_q_vector *q_vector = rc->rx_ring->q_vector;\n\n\t\tif (ec->rx_coalesce_usecs_high > ICE_MAX_INTRL ||\n\t\t    (ec->rx_coalesce_usecs_high &&\n\t\t     ec->rx_coalesce_usecs_high < pf->hw.intrl_gran)) {\n\t\t\tnetdev_info(vsi->netdev, \"Invalid value, %s-usecs-high valid values are 0 (disabled), %d-%d\\n\",\n\t\t\t\t    c_type_str, pf->hw.intrl_gran,\n\t\t\t\t    ICE_MAX_INTRL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ec->rx_coalesce_usecs_high != q_vector->intrl &&\n\t\t    (ec->use_adaptive_rx_coalesce || ec->use_adaptive_tx_coalesce)) {\n\t\t\tnetdev_info(vsi->netdev, \"Invalid value, %s-usecs-high cannot be changed if adaptive-tx or adaptive-rx is enabled\\n\",\n\t\t\t\t    c_type_str);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ec->rx_coalesce_usecs_high != q_vector->intrl)\n\t\t\tq_vector->intrl = ec->rx_coalesce_usecs_high;\n\n\t\tuse_adaptive_coalesce = ec->use_adaptive_rx_coalesce;\n\t\tcoalesce_usecs = ec->rx_coalesce_usecs;\n\n\t\tbreak;\n\t}\n\tcase ICE_TX_CONTAINER:\n\t\tuse_adaptive_coalesce = ec->use_adaptive_tx_coalesce;\n\t\tcoalesce_usecs = ec->tx_coalesce_usecs;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(ice_pf_to_dev(pf), \"Invalid container type %d\\n\",\n\t\t\trc->type);\n\t\treturn -EINVAL;\n\t}\n\n\titr_setting = rc->itr_setting;\n\tif (coalesce_usecs != itr_setting && use_adaptive_coalesce) {\n\t\tnetdev_info(vsi->netdev, \"%s interrupt throttling cannot be changed if adaptive-%s is enabled\\n\",\n\t\t\t    c_type_str, c_type_str);\n\t\treturn -EINVAL;\n\t}\n\n\tif (coalesce_usecs > ICE_ITR_MAX) {\n\t\tnetdev_info(vsi->netdev, \"Invalid value, %s-usecs range is 0-%d\\n\",\n\t\t\t    c_type_str, ICE_ITR_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_adaptive_coalesce) {\n\t\trc->itr_mode = ITR_DYNAMIC;\n\t} else {\n\t\trc->itr_mode = ITR_STATIC;\n\t\t \n\t\trc->itr_setting = coalesce_usecs;\n\t\t \n\t\tice_write_itr(rc, coalesce_usecs);\n\t\t \n\t\tice_flush(&pf->hw);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_set_q_coalesce(struct ice_vsi *vsi, struct ethtool_coalesce *ec, int q_num)\n{\n\tif (q_num < vsi->num_rxq && q_num < vsi->num_txq) {\n\t\tif (ice_set_rc_coalesce(ec,\n\t\t\t\t\t&vsi->rx_rings[q_num]->q_vector->rx,\n\t\t\t\t\tvsi))\n\t\t\treturn -EINVAL;\n\n\t\tif (ice_set_rc_coalesce(ec,\n\t\t\t\t\t&vsi->tx_rings[q_num]->q_vector->tx,\n\t\t\t\t\tvsi))\n\t\t\treturn -EINVAL;\n\t} else if (q_num < vsi->num_rxq) {\n\t\tif (ice_set_rc_coalesce(ec,\n\t\t\t\t\t&vsi->rx_rings[q_num]->q_vector->rx,\n\t\t\t\t\tvsi))\n\t\t\treturn -EINVAL;\n\t} else if (q_num < vsi->num_txq) {\n\t\tif (ice_set_rc_coalesce(ec,\n\t\t\t\t\t&vsi->tx_rings[q_num]->q_vector->tx,\n\t\t\t\t\tvsi))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nice_print_if_odd_usecs(struct net_device *netdev, u16 itr_setting,\n\t\t       u32 use_adaptive_coalesce, u32 coalesce_usecs,\n\t\t       const char *c_type_str)\n{\n\tif (use_adaptive_coalesce)\n\t\treturn;\n\n\tif (itr_setting != coalesce_usecs && (coalesce_usecs % 2))\n\t\tnetdev_info(netdev, \"User set %s-usecs to %d, device only supports even values. Rounding down and attempting to set %s-usecs to %d\\n\",\n\t\t\t    c_type_str, coalesce_usecs, c_type_str,\n\t\t\t    ITR_REG_ALIGN(coalesce_usecs));\n}\n\n \nstatic int\n__ice_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec,\n\t\t   int q_num)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\n\tif (q_num < 0) {\n\t\tstruct ice_q_vector *q_vector = vsi->q_vectors[0];\n\t\tint v_idx;\n\n\t\tif (q_vector) {\n\t\t\tice_print_if_odd_usecs(netdev, q_vector->rx.itr_setting,\n\t\t\t\t\t       ec->use_adaptive_rx_coalesce,\n\t\t\t\t\t       ec->rx_coalesce_usecs, \"rx\");\n\n\t\t\tice_print_if_odd_usecs(netdev, q_vector->tx.itr_setting,\n\t\t\t\t\t       ec->use_adaptive_tx_coalesce,\n\t\t\t\t\t       ec->tx_coalesce_usecs, \"tx\");\n\t\t}\n\n\t\tice_for_each_q_vector(vsi, v_idx) {\n\t\t\t \n\t\t\tif (v_idx >= vsi->num_rxq && v_idx >= vsi->num_txq)\n\t\t\t\tgoto set_complete;\n\n\t\t\tif (ice_set_q_coalesce(vsi, ec, v_idx))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tice_set_q_vector_intrl(vsi->q_vectors[v_idx]);\n\t\t}\n\t\tgoto set_complete;\n\t}\n\n\tif (ice_set_q_coalesce(vsi, ec, q_num))\n\t\treturn -EINVAL;\n\n\tice_set_q_vector_intrl(vsi->q_vectors[q_num]);\n\nset_complete:\n\treturn 0;\n}\n\nstatic int ice_set_coalesce(struct net_device *netdev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn __ice_set_coalesce(netdev, ec, -1);\n}\n\nstatic int\nice_set_per_q_coalesce(struct net_device *netdev, u32 q_num,\n\t\t       struct ethtool_coalesce *ec)\n{\n\treturn __ice_set_coalesce(netdev, ec, q_num);\n}\n\nstatic void\nice_repr_get_drvinfo(struct net_device *netdev,\n\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstruct ice_repr *repr = ice_netdev_to_repr(netdev);\n\n\tif (ice_check_vf_ready_for_cfg(repr->vf))\n\t\treturn;\n\n\t__ice_get_drvinfo(netdev, drvinfo, repr->src_vsi);\n}\n\nstatic void\nice_repr_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tstruct ice_repr *repr = ice_netdev_to_repr(netdev);\n\n\t \n\tif (ice_check_vf_ready_for_cfg(repr->vf) ||\n\t    stringset != ETH_SS_STATS)\n\t\treturn;\n\n\t__ice_get_strings(netdev, stringset, data, repr->src_vsi);\n}\n\nstatic void\nice_repr_get_ethtool_stats(struct net_device *netdev,\n\t\t\t   struct ethtool_stats __always_unused *stats,\n\t\t\t   u64 *data)\n{\n\tstruct ice_repr *repr = ice_netdev_to_repr(netdev);\n\n\tif (ice_check_vf_ready_for_cfg(repr->vf))\n\t\treturn;\n\n\t__ice_get_ethtool_stats(netdev, stats, data, repr->src_vsi);\n}\n\nstatic int ice_repr_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ICE_VSI_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n#define ICE_I2C_EEPROM_DEV_ADDR\t\t0xA0\n#define ICE_I2C_EEPROM_DEV_ADDR2\t0xA2\n#define ICE_MODULE_TYPE_SFP\t\t0x03\n#define ICE_MODULE_TYPE_QSFP_PLUS\t0x0D\n#define ICE_MODULE_TYPE_QSFP28\t\t0x11\n#define ICE_MODULE_SFF_ADDR_MODE\t0x04\n#define ICE_MODULE_SFF_DIAG_CAPAB\t0x40\n#define ICE_MODULE_REVISION_ADDR\t0x01\n#define ICE_MODULE_SFF_8472_COMP\t0x5E\n#define ICE_MODULE_SFF_8472_SWAP\t0x5C\n#define ICE_MODULE_QSFP_MAX_LEN\t\t640\n\n \nstatic int\nice_get_module_info(struct net_device *netdev,\n\t\t    struct ethtool_modinfo *modinfo)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 sff8472_comp = 0;\n\tu8 sff8472_swap = 0;\n\tu8 sff8636_rev = 0;\n\tu8 value = 0;\n\tint status;\n\n\tstatus = ice_aq_sff_eeprom(hw, 0, ICE_I2C_EEPROM_DEV_ADDR, 0x00, 0x00,\n\t\t\t\t   0, &value, 1, 0, NULL);\n\tif (status)\n\t\treturn status;\n\n\tswitch (value) {\n\tcase ICE_MODULE_TYPE_SFP:\n\t\tstatus = ice_aq_sff_eeprom(hw, 0, ICE_I2C_EEPROM_DEV_ADDR,\n\t\t\t\t\t   ICE_MODULE_SFF_8472_COMP, 0x00, 0,\n\t\t\t\t\t   &sff8472_comp, 1, 0, NULL);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ice_aq_sff_eeprom(hw, 0, ICE_I2C_EEPROM_DEV_ADDR,\n\t\t\t\t\t   ICE_MODULE_SFF_8472_SWAP, 0x00, 0,\n\t\t\t\t\t   &sff8472_swap, 1, 0, NULL);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (sff8472_swap & ICE_MODULE_SFF_ADDR_MODE) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t} else if (sff8472_comp &&\n\t\t\t   (sff8472_swap & ICE_MODULE_SFF_DIAG_CAPAB)) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t}\n\t\tbreak;\n\tcase ICE_MODULE_TYPE_QSFP_PLUS:\n\tcase ICE_MODULE_TYPE_QSFP28:\n\t\tstatus = ice_aq_sff_eeprom(hw, 0, ICE_I2C_EEPROM_DEV_ADDR,\n\t\t\t\t\t   ICE_MODULE_REVISION_ADDR, 0x00, 0,\n\t\t\t\t\t   &sff8636_rev, 1, 0, NULL);\n\t\tif (status)\n\t\t\treturn status;\n\t\t \n\t\tif (sff8636_rev > 0x02) {\n\t\t\t \n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ICE_MODULE_QSFP_MAX_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ICE_MODULE_QSFP_MAX_LEN;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(netdev, \"SFF Module Type not recognized.\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nice_get_module_eeprom(struct net_device *netdev,\n\t\t      struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n#define SFF_READ_BLOCK_SIZE 8\n\tu8 value[SFF_READ_BLOCK_SIZE] = { 0 };\n\tu8 addr = ICE_I2C_EEPROM_DEV_ADDR;\n\tstruct ice_vsi *vsi = np->vsi;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_hw *hw = &pf->hw;\n\tbool is_sfp = false;\n\tunsigned int i, j;\n\tu16 offset = 0;\n\tu8 page = 0;\n\tint status;\n\n\tif (!ee || !ee->len || !data)\n\t\treturn -EINVAL;\n\n\tstatus = ice_aq_sff_eeprom(hw, 0, addr, offset, page, 0, value, 1, 0,\n\t\t\t\t   NULL);\n\tif (status)\n\t\treturn status;\n\n\tif (value[0] == ICE_MODULE_TYPE_SFP)\n\t\tis_sfp = true;\n\n\tmemset(data, 0, ee->len);\n\tfor (i = 0; i < ee->len; i += SFF_READ_BLOCK_SIZE) {\n\t\toffset = i + ee->offset;\n\t\tpage = 0;\n\n\t\t \n\t\tif (is_sfp) {\n\t\t\tif (offset >= ETH_MODULE_SFF_8079_LEN) {\n\t\t\t\toffset -= ETH_MODULE_SFF_8079_LEN;\n\t\t\t\taddr = ICE_I2C_EEPROM_DEV_ADDR2;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (offset >= ETH_MODULE_SFF_8436_LEN) {\n\t\t\t\t \n\t\t\t\toffset -= ETH_MODULE_SFF_8436_LEN / 2;\n\t\t\t\tpage++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (page == 0 || !(data[0x2] & 0x4)) {\n\t\t\tu32 copy_len;\n\n\t\t\t \n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tstatus = ice_aq_sff_eeprom(hw, 0, addr, offset, page,\n\t\t\t\t\t\t\t   !is_sfp, value,\n\t\t\t\t\t\t\t   SFF_READ_BLOCK_SIZE,\n\t\t\t\t\t\t\t   0, NULL);\n\t\t\t\tnetdev_dbg(netdev, \"SFF %02X %02X %02X %X = %02X%02X%02X%02X.%02X%02X%02X%02X (%X)\\n\",\n\t\t\t\t\t   addr, offset, page, is_sfp,\n\t\t\t\t\t   value[0], value[1], value[2], value[3],\n\t\t\t\t\t   value[4], value[5], value[6], value[7],\n\t\t\t\t\t   status);\n\t\t\t\tif (status) {\n\t\t\t\t\tusleep_range(1500, 2500);\n\t\t\t\t\tmemset(value, 0, SFF_READ_BLOCK_SIZE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tcopy_len = min_t(u32, SFF_READ_BLOCK_SIZE, ee->len - i);\n\t\t\tmemcpy(data + i, value, copy_len);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ice_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE |\n\t\t\t\t     ETHTOOL_COALESCE_RX_USECS_HIGH,\n\t.get_link_ksettings\t= ice_get_link_ksettings,\n\t.set_link_ksettings\t= ice_set_link_ksettings,\n\t.get_drvinfo\t\t= ice_get_drvinfo,\n\t.get_regs_len\t\t= ice_get_regs_len,\n\t.get_regs\t\t= ice_get_regs,\n\t.get_wol\t\t= ice_get_wol,\n\t.set_wol\t\t= ice_set_wol,\n\t.get_msglevel\t\t= ice_get_msglevel,\n\t.set_msglevel\t\t= ice_set_msglevel,\n\t.self_test\t\t= ice_self_test,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= ice_get_eeprom_len,\n\t.get_eeprom\t\t= ice_get_eeprom,\n\t.get_coalesce\t\t= ice_get_coalesce,\n\t.set_coalesce\t\t= ice_set_coalesce,\n\t.get_strings\t\t= ice_get_strings,\n\t.set_phys_id\t\t= ice_set_phys_id,\n\t.get_ethtool_stats      = ice_get_ethtool_stats,\n\t.get_priv_flags\t\t= ice_get_priv_flags,\n\t.set_priv_flags\t\t= ice_set_priv_flags,\n\t.get_sset_count\t\t= ice_get_sset_count,\n\t.get_rxnfc\t\t= ice_get_rxnfc,\n\t.set_rxnfc\t\t= ice_set_rxnfc,\n\t.get_ringparam\t\t= ice_get_ringparam,\n\t.set_ringparam\t\t= ice_set_ringparam,\n\t.nway_reset\t\t= ice_nway_reset,\n\t.get_pauseparam\t\t= ice_get_pauseparam,\n\t.set_pauseparam\t\t= ice_set_pauseparam,\n\t.get_rxfh_key_size\t= ice_get_rxfh_key_size,\n\t.get_rxfh_indir_size\t= ice_get_rxfh_indir_size,\n\t.get_rxfh_context\t= ice_get_rxfh_context,\n\t.get_rxfh\t\t= ice_get_rxfh,\n\t.set_rxfh\t\t= ice_set_rxfh,\n\t.get_channels\t\t= ice_get_channels,\n\t.set_channels\t\t= ice_set_channels,\n\t.get_ts_info\t\t= ice_get_ts_info,\n\t.get_per_queue_coalesce\t= ice_get_per_q_coalesce,\n\t.set_per_queue_coalesce\t= ice_set_per_q_coalesce,\n\t.get_fecparam\t\t= ice_get_fecparam,\n\t.set_fecparam\t\t= ice_set_fecparam,\n\t.get_module_info\t= ice_get_module_info,\n\t.get_module_eeprom\t= ice_get_module_eeprom,\n};\n\nstatic const struct ethtool_ops ice_ethtool_safe_mode_ops = {\n\t.get_link_ksettings\t= ice_get_link_ksettings,\n\t.set_link_ksettings\t= ice_set_link_ksettings,\n\t.get_drvinfo\t\t= ice_get_drvinfo,\n\t.get_regs_len\t\t= ice_get_regs_len,\n\t.get_regs\t\t= ice_get_regs,\n\t.get_wol\t\t= ice_get_wol,\n\t.set_wol\t\t= ice_set_wol,\n\t.get_msglevel\t\t= ice_get_msglevel,\n\t.set_msglevel\t\t= ice_set_msglevel,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= ice_get_eeprom_len,\n\t.get_eeprom\t\t= ice_get_eeprom,\n\t.get_strings\t\t= ice_get_strings,\n\t.get_ethtool_stats\t= ice_get_ethtool_stats,\n\t.get_sset_count\t\t= ice_get_sset_count,\n\t.get_ringparam\t\t= ice_get_ringparam,\n\t.set_ringparam\t\t= ice_set_ringparam,\n\t.nway_reset\t\t= ice_nway_reset,\n\t.get_channels\t\t= ice_get_channels,\n};\n\n \nvoid ice_set_ethtool_safe_mode_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ice_ethtool_safe_mode_ops;\n}\n\nstatic const struct ethtool_ops ice_ethtool_repr_ops = {\n\t.get_drvinfo\t\t= ice_repr_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= ice_repr_get_strings,\n\t.get_ethtool_stats      = ice_repr_get_ethtool_stats,\n\t.get_sset_count\t\t= ice_repr_get_sset_count,\n};\n\n \nvoid ice_set_ethtool_repr_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ice_ethtool_repr_ops;\n}\n\n \nvoid ice_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ice_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}