{
  "module_name": "ice_ptp.c",
  "hash_id": "42443b3af560c2a7a7b249487224520c680cd507c7518006d608e2d1b4da5935",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_ptp.c",
  "human_readable_source": "\n \n\n#include \"ice.h\"\n#include \"ice_lib.h\"\n#include \"ice_trace.h\"\n\n#define E810_OUT_PROP_DELAY_NS 1\n\n#define UNKNOWN_INCVAL_E822 0x100000000ULL\n\nstatic const struct ptp_pin_desc ice_pin_desc_e810t[] = {\n\t \n\t{ \"GNSS\",  GNSS, PTP_PF_EXTTS, 0, { 0, } },\n\t{ \"SMA1\",  SMA1, PTP_PF_NONE, 1, { 0, } },\n\t{ \"U.FL1\", UFL1, PTP_PF_NONE, 1, { 0, } },\n\t{ \"SMA2\",  SMA2, PTP_PF_NONE, 2, { 0, } },\n\t{ \"U.FL2\", UFL2, PTP_PF_NONE, 2, { 0, } },\n};\n\n \nstatic int\nice_get_sma_config_e810t(struct ice_hw *hw, struct ptp_pin_desc *ptp_pins)\n{\n\tu8 data, i;\n\tint status;\n\n\t \n\tstatus = ice_read_sma_ctrl_e810t(hw, &data);\n\tif (status)\n\t\treturn status;\n\n\t \n\tfor (i = 0; i < NUM_PTP_PINS_E810T; i++) {\n\t\tsnprintf(ptp_pins[i].name, sizeof(ptp_pins[i].name),\n\t\t\t \"%s\", ice_pin_desc_e810t[i].name);\n\t\tptp_pins[i].index = ice_pin_desc_e810t[i].index;\n\t\tptp_pins[i].func = ice_pin_desc_e810t[i].func;\n\t\tptp_pins[i].chan = ice_pin_desc_e810t[i].chan;\n\t}\n\n\t \n\tswitch (data & ICE_SMA1_MASK_E810T) {\n\tcase ICE_SMA1_MASK_E810T:\n\tdefault:\n\t\tptp_pins[SMA1].func = PTP_PF_NONE;\n\t\tptp_pins[UFL1].func = PTP_PF_NONE;\n\t\tbreak;\n\tcase ICE_SMA1_DIR_EN_E810T:\n\t\tptp_pins[SMA1].func = PTP_PF_PEROUT;\n\t\tptp_pins[UFL1].func = PTP_PF_NONE;\n\t\tbreak;\n\tcase ICE_SMA1_TX_EN_E810T:\n\t\tptp_pins[SMA1].func = PTP_PF_EXTTS;\n\t\tptp_pins[UFL1].func = PTP_PF_NONE;\n\t\tbreak;\n\tcase 0:\n\t\tptp_pins[SMA1].func = PTP_PF_EXTTS;\n\t\tptp_pins[UFL1].func = PTP_PF_PEROUT;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (data & ICE_SMA2_MASK_E810T) {\n\tcase ICE_SMA2_MASK_E810T:\n\tdefault:\n\t\tptp_pins[SMA2].func = PTP_PF_NONE;\n\t\tptp_pins[UFL2].func = PTP_PF_NONE;\n\t\tbreak;\n\tcase (ICE_SMA2_TX_EN_E810T | ICE_SMA2_UFL2_RX_DIS_E810T):\n\t\tptp_pins[SMA2].func = PTP_PF_EXTTS;\n\t\tptp_pins[UFL2].func = PTP_PF_NONE;\n\t\tbreak;\n\tcase (ICE_SMA2_DIR_EN_E810T | ICE_SMA2_UFL2_RX_DIS_E810T):\n\t\tptp_pins[SMA2].func = PTP_PF_PEROUT;\n\t\tptp_pins[UFL2].func = PTP_PF_NONE;\n\t\tbreak;\n\tcase (ICE_SMA2_DIR_EN_E810T | ICE_SMA2_TX_EN_E810T):\n\t\tptp_pins[SMA2].func = PTP_PF_NONE;\n\t\tptp_pins[UFL2].func = PTP_PF_EXTTS;\n\t\tbreak;\n\tcase ICE_SMA2_DIR_EN_E810T:\n\t\tptp_pins[SMA2].func = PTP_PF_PEROUT;\n\t\tptp_pins[UFL2].func = PTP_PF_EXTTS;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_ptp_set_sma_config_e810t(struct ice_hw *hw,\n\t\t\t     const struct ptp_pin_desc *ptp_pins)\n{\n\tint status;\n\tu8 data;\n\n\t \n\tif (ptp_pins[SMA1].func == PTP_PF_PEROUT &&\n\t    ptp_pins[UFL1].func == PTP_PF_PEROUT)\n\t\treturn -EINVAL;\n\n\t \n\tif (ptp_pins[SMA2].func == PTP_PF_EXTTS &&\n\t    ptp_pins[UFL2].func == PTP_PF_EXTTS)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = ice_read_sma_ctrl_e810t(hw, &data);\n\tif (status)\n\t\treturn status;\n\n\t \n\tdata &= ~ICE_SMA1_MASK_E810T;\n\tif (ptp_pins[SMA1].func == PTP_PF_NONE &&\n\t    ptp_pins[UFL1].func == PTP_PF_NONE) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA1 + U.FL1 disabled\");\n\t\tdata |= ICE_SMA1_MASK_E810T;\n\t} else if (ptp_pins[SMA1].func == PTP_PF_EXTTS &&\n\t\t   ptp_pins[UFL1].func == PTP_PF_NONE) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA1 RX\");\n\t\tdata |= ICE_SMA1_TX_EN_E810T;\n\t} else if (ptp_pins[SMA1].func == PTP_PF_NONE &&\n\t\t   ptp_pins[UFL1].func == PTP_PF_PEROUT) {\n\t\t \n\t\tdev_info(ice_hw_to_dev(hw), \"SMA1 RX + U.FL1 TX\");\n\t} else if (ptp_pins[SMA1].func == PTP_PF_EXTTS &&\n\t\t   ptp_pins[UFL1].func == PTP_PF_PEROUT) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA1 RX + U.FL1 TX\");\n\t} else if (ptp_pins[SMA1].func == PTP_PF_PEROUT &&\n\t\t   ptp_pins[UFL1].func == PTP_PF_NONE) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA1 TX\");\n\t\tdata |= ICE_SMA1_DIR_EN_E810T;\n\t}\n\n\tdata &= ~ICE_SMA2_MASK_E810T;\n\tif (ptp_pins[SMA2].func == PTP_PF_NONE &&\n\t    ptp_pins[UFL2].func == PTP_PF_NONE) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA2 + U.FL2 disabled\");\n\t\tdata |= ICE_SMA2_MASK_E810T;\n\t} else if (ptp_pins[SMA2].func == PTP_PF_EXTTS &&\n\t\t\tptp_pins[UFL2].func == PTP_PF_NONE) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA2 RX\");\n\t\tdata |= (ICE_SMA2_TX_EN_E810T |\n\t\t\t ICE_SMA2_UFL2_RX_DIS_E810T);\n\t} else if (ptp_pins[SMA2].func == PTP_PF_NONE &&\n\t\t   ptp_pins[UFL2].func == PTP_PF_EXTTS) {\n\t\tdev_info(ice_hw_to_dev(hw), \"UFL2 RX\");\n\t\tdata |= (ICE_SMA2_DIR_EN_E810T | ICE_SMA2_TX_EN_E810T);\n\t} else if (ptp_pins[SMA2].func == PTP_PF_PEROUT &&\n\t\t   ptp_pins[UFL2].func == PTP_PF_NONE) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA2 TX\");\n\t\tdata |= (ICE_SMA2_DIR_EN_E810T |\n\t\t\t ICE_SMA2_UFL2_RX_DIS_E810T);\n\t} else if (ptp_pins[SMA2].func == PTP_PF_PEROUT &&\n\t\t   ptp_pins[UFL2].func == PTP_PF_EXTTS) {\n\t\tdev_info(ice_hw_to_dev(hw), \"SMA2 TX + U.FL2 RX\");\n\t\tdata |= ICE_SMA2_DIR_EN_E810T;\n\t}\n\n\treturn ice_write_sma_ctrl_e810t(hw, data);\n}\n\n \nstatic int\nice_ptp_set_sma_e810t(struct ptp_clock_info *info, unsigned int pin,\n\t\t      enum ptp_pin_function func)\n{\n\tstruct ptp_pin_desc ptp_pins[NUM_PTP_PINS_E810T];\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\tstruct ice_hw *hw = &pf->hw;\n\tint err;\n\n\tif (pin < SMA1 || func > PTP_PF_PEROUT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = ice_get_sma_config_e810t(hw, ptp_pins);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pin == SMA1 && ptp_pins[UFL1].func == func)\n\t\tptp_pins[UFL1].func = PTP_PF_NONE;\n\tif (pin == UFL1 && ptp_pins[SMA1].func == func)\n\t\tptp_pins[SMA1].func = PTP_PF_NONE;\n\n\tif (pin == SMA2 && ptp_pins[UFL2].func == func)\n\t\tptp_pins[UFL2].func = PTP_PF_NONE;\n\tif (pin == UFL2 && ptp_pins[SMA2].func == func)\n\t\tptp_pins[SMA2].func = PTP_PF_NONE;\n\n\t \n\tptp_pins[pin].func = func;\n\n\treturn ice_ptp_set_sma_config_e810t(hw, ptp_pins);\n}\n\n \nstatic int\nice_verify_pin_e810t(struct ptp_clock_info *info, unsigned int pin,\n\t\t     enum ptp_pin_function func, unsigned int chan)\n{\n\t \n\tif (chan != ice_pin_desc_e810t[pin].chan)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\t\tbreak;\n\tcase PTP_PF_EXTTS:\n\t\tif (pin == UFL1)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\t\tif (pin == UFL2 || pin == GNSS)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ice_ptp_set_sma_e810t(info, pin, func);\n}\n\n \nstatic void ice_set_tx_tstamp(struct ice_pf *pf, bool on)\n{\n\tstruct ice_vsi *vsi;\n\tu32 val;\n\tu16 i;\n\n\tvsi = ice_get_main_vsi(pf);\n\tif (!vsi)\n\t\treturn;\n\n\t \n\tice_for_each_txq(vsi, i) {\n\t\tif (!vsi->tx_rings[i])\n\t\t\tcontinue;\n\t\tvsi->tx_rings[i]->ptp_tx = on;\n\t}\n\n\t \n\tval = rd32(&pf->hw, PFINT_OICR_ENA);\n\tif (on)\n\t\tval |= PFINT_OICR_TSYN_TX_M;\n\telse\n\t\tval &= ~PFINT_OICR_TSYN_TX_M;\n\twr32(&pf->hw, PFINT_OICR_ENA, val);\n\n\tpf->ptp.tstamp_config.tx_type = on ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\n}\n\n \nstatic void ice_set_rx_tstamp(struct ice_pf *pf, bool on)\n{\n\tstruct ice_vsi *vsi;\n\tu16 i;\n\n\tvsi = ice_get_main_vsi(pf);\n\tif (!vsi)\n\t\treturn;\n\n\t \n\tice_for_each_rxq(vsi, i) {\n\t\tif (!vsi->rx_rings[i])\n\t\t\tcontinue;\n\t\tvsi->rx_rings[i]->ptp_rx = on;\n\t}\n\n\tpf->ptp.tstamp_config.rx_filter = on ? HWTSTAMP_FILTER_ALL :\n\t\t\t\t\t       HWTSTAMP_FILTER_NONE;\n}\n\n \nvoid ice_ptp_cfg_timestamp(struct ice_pf *pf, bool ena)\n{\n\tice_set_tx_tstamp(pf, ena);\n\tice_set_rx_tstamp(pf, ena);\n}\n\n \nint ice_get_ptp_clock_index(struct ice_pf *pf)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tenum ice_aqc_driver_params param_idx;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 tmr_idx;\n\tu32 value;\n\tint err;\n\n\t \n\tif (pf->ptp.clock)\n\t\treturn ptp_clock_index(pf->ptp.clock);\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_assoc;\n\tif (!tmr_idx)\n\t\tparam_idx = ICE_AQC_DRIVER_PARAM_CLK_IDX_TMR0;\n\telse\n\t\tparam_idx = ICE_AQC_DRIVER_PARAM_CLK_IDX_TMR1;\n\n\terr = ice_aq_get_driver_param(hw, param_idx, &value, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to read PTP clock index parameter, err %d aq_err %s\\n\",\n\t\t\terr, ice_aq_str(hw->adminq.sq_last_status));\n\t\treturn -1;\n\t}\n\n\t \n\tif (!(value & PTP_SHARED_CLK_IDX_VALID))\n\t\treturn -1;\n\n\treturn value & ~PTP_SHARED_CLK_IDX_VALID;\n}\n\n \nstatic void ice_set_ptp_clock_index(struct ice_pf *pf)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tenum ice_aqc_driver_params param_idx;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 tmr_idx;\n\tu32 value;\n\tint err;\n\n\tif (!pf->ptp.clock)\n\t\treturn;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_assoc;\n\tif (!tmr_idx)\n\t\tparam_idx = ICE_AQC_DRIVER_PARAM_CLK_IDX_TMR0;\n\telse\n\t\tparam_idx = ICE_AQC_DRIVER_PARAM_CLK_IDX_TMR1;\n\n\tvalue = (u32)ptp_clock_index(pf->ptp.clock);\n\tif (value > INT_MAX) {\n\t\tdev_err(dev, \"PTP Clock index is too large to store\\n\");\n\t\treturn;\n\t}\n\tvalue |= PTP_SHARED_CLK_IDX_VALID;\n\n\terr = ice_aq_set_driver_param(hw, param_idx, value, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to set PTP clock index parameter, err %d aq_err %s\\n\",\n\t\t\terr, ice_aq_str(hw->adminq.sq_last_status));\n\t}\n}\n\n \nstatic void ice_clear_ptp_clock_index(struct ice_pf *pf)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tenum ice_aqc_driver_params param_idx;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 tmr_idx;\n\tint err;\n\n\t \n\tif (!hw->func_caps.ts_func_info.src_tmr_owned)\n\t\treturn;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_assoc;\n\tif (!tmr_idx)\n\t\tparam_idx = ICE_AQC_DRIVER_PARAM_CLK_IDX_TMR0;\n\telse\n\t\tparam_idx = ICE_AQC_DRIVER_PARAM_CLK_IDX_TMR1;\n\n\terr = ice_aq_set_driver_param(hw, param_idx, 0, NULL);\n\tif (err) {\n\t\tdev_dbg(dev, \"Failed to clear PTP clock index parameter, err %d aq_err %s\\n\",\n\t\t\terr, ice_aq_str(hw->adminq.sq_last_status));\n\t}\n}\n\n \nstatic u64\nice_ptp_read_src_clk_reg(struct ice_pf *pf, struct ptp_system_timestamp *sts)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tu32 hi, lo, lo2;\n\tu8 tmr_idx;\n\n\ttmr_idx = ice_get_ptp_src_clock_index(hw);\n\t \n\tptp_read_system_prets(sts);\n\n\tlo = rd32(hw, GLTSYN_TIME_L(tmr_idx));\n\n\t \n\tptp_read_system_postts(sts);\n\n\thi = rd32(hw, GLTSYN_TIME_H(tmr_idx));\n\tlo2 = rd32(hw, GLTSYN_TIME_L(tmr_idx));\n\n\tif (lo2 < lo) {\n\t\t \n\t\tptp_read_system_prets(sts);\n\t\tlo = rd32(hw, GLTSYN_TIME_L(tmr_idx));\n\t\tptp_read_system_postts(sts);\n\t\thi = rd32(hw, GLTSYN_TIME_H(tmr_idx));\n\t}\n\n\treturn ((u64)hi << 32) | lo;\n}\n\n \nstatic u64 ice_ptp_extend_32b_ts(u64 cached_phc_time, u32 in_tstamp)\n{\n\tu32 delta, phc_time_lo;\n\tu64 ns;\n\n\t \n\tphc_time_lo = (u32)cached_phc_time;\n\n\t \n\tdelta = (in_tstamp - phc_time_lo);\n\n\t \n\tif (delta > (U32_MAX / 2)) {\n\t\t \n\t\tdelta = (phc_time_lo - in_tstamp);\n\t\tns = cached_phc_time - delta;\n\t} else {\n\t\tns = cached_phc_time + delta;\n\t}\n\n\treturn ns;\n}\n\n \nstatic u64 ice_ptp_extend_40b_ts(struct ice_pf *pf, u64 in_tstamp)\n{\n\tconst u64 mask = GENMASK_ULL(31, 0);\n\tunsigned long discard_time;\n\n\t \n\tdiscard_time = pf->ptp.cached_phc_jiffies + msecs_to_jiffies(2000);\n\tif (time_is_before_jiffies(discard_time)) {\n\t\tpf->ptp.tx_hwtstamp_discarded++;\n\t\treturn 0;\n\t}\n\n\treturn ice_ptp_extend_32b_ts(pf->ptp.cached_phc_time,\n\t\t\t\t     (in_tstamp >> 8) & mask);\n}\n\n \nstatic bool\nice_ptp_is_tx_tracker_up(struct ice_ptp_tx *tx)\n{\n\tlockdep_assert_held(&tx->lock);\n\n\treturn tx->init && !tx->calibrating;\n}\n\n \nstatic void ice_ptp_process_tx_tstamp(struct ice_ptp_tx *tx)\n{\n\tstruct ice_ptp_port *ptp_port;\n\tstruct ice_pf *pf;\n\tstruct ice_hw *hw;\n\tu64 tstamp_ready;\n\tbool link_up;\n\tint err;\n\tu8 idx;\n\n\tif (!tx->init)\n\t\treturn;\n\n\tptp_port = container_of(tx, struct ice_ptp_port, tx);\n\tpf = ptp_port_to_pf(ptp_port);\n\thw = &pf->hw;\n\n\t \n\terr = ice_get_phy_tx_tstamp_ready(hw, tx->block, &tstamp_ready);\n\tif (err)\n\t\treturn;\n\n\t \n\tlink_up = ptp_port->link_up;\n\n\tfor_each_set_bit(idx, tx->in_use, tx->len) {\n\t\tstruct skb_shared_hwtstamps shhwtstamps = {};\n\t\tu8 phy_idx = idx + tx->offset;\n\t\tu64 raw_tstamp = 0, tstamp;\n\t\tbool drop_ts = !link_up;\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\tif (time_is_before_jiffies(tx->tstamps[idx].start + 2 * HZ)) {\n\t\t\tdrop_ts = true;\n\n\t\t\t \n\t\t\tpf->ptp.tx_hwtstamp_timeouts++;\n\t\t}\n\n\t\t \n\t\tif (!(tstamp_ready & BIT_ULL(phy_idx))) {\n\t\t\tif (drop_ts)\n\t\t\t\tgoto skip_ts_read;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tice_trace(tx_tstamp_fw_req, tx->tstamps[idx].skb, idx);\n\n\t\terr = ice_read_phy_tstamp(hw, tx->block, phy_idx, &raw_tstamp);\n\t\tif (err && !drop_ts)\n\t\t\tcontinue;\n\n\t\tice_trace(tx_tstamp_fw_done, tx->tstamps[idx].skb, idx);\n\n\t\t \n\t\tif (!drop_ts && tx->verify_cached &&\n\t\t    raw_tstamp == tx->tstamps[idx].cached_tstamp)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(raw_tstamp & ICE_PTP_TS_VALID))\n\t\t\tdrop_ts = true;\n\nskip_ts_read:\n\t\tspin_lock(&tx->lock);\n\t\tif (tx->verify_cached && raw_tstamp)\n\t\t\ttx->tstamps[idx].cached_tstamp = raw_tstamp;\n\t\tclear_bit(idx, tx->in_use);\n\t\tskb = tx->tstamps[idx].skb;\n\t\ttx->tstamps[idx].skb = NULL;\n\t\tif (test_and_clear_bit(idx, tx->stale))\n\t\t\tdrop_ts = true;\n\t\tspin_unlock(&tx->lock);\n\n\t\t \n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tif (drop_ts) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttstamp = ice_ptp_extend_40b_ts(pf, raw_tstamp);\n\t\tif (tstamp) {\n\t\t\tshhwtstamps.hwtstamp = ns_to_ktime(tstamp);\n\t\t\tice_trace(tx_tstamp_complete, skb, idx);\n\t\t}\n\n\t\tskb_tstamp_tx(skb, &shhwtstamps);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\n \nstatic enum ice_tx_tstamp_work ice_ptp_tx_tstamp(struct ice_ptp_tx *tx)\n{\n\tbool more_timestamps;\n\n\tif (!tx->init)\n\t\treturn ICE_TX_TSTAMP_WORK_DONE;\n\n\t \n\tice_ptp_process_tx_tstamp(tx);\n\n\t \n\tspin_lock(&tx->lock);\n\tmore_timestamps = tx->init && !bitmap_empty(tx->in_use, tx->len);\n\tspin_unlock(&tx->lock);\n\n\tif (more_timestamps)\n\t\treturn ICE_TX_TSTAMP_WORK_PENDING;\n\n\treturn ICE_TX_TSTAMP_WORK_DONE;\n}\n\n \nstatic int\nice_ptp_alloc_tx_tracker(struct ice_ptp_tx *tx)\n{\n\tunsigned long *in_use, *stale;\n\tstruct ice_tx_tstamp *tstamps;\n\n\ttstamps = kcalloc(tx->len, sizeof(*tstamps), GFP_KERNEL);\n\tin_use = bitmap_zalloc(tx->len, GFP_KERNEL);\n\tstale = bitmap_zalloc(tx->len, GFP_KERNEL);\n\n\tif (!tstamps || !in_use || !stale) {\n\t\tkfree(tstamps);\n\t\tbitmap_free(in_use);\n\t\tbitmap_free(stale);\n\n\t\treturn -ENOMEM;\n\t}\n\n\ttx->tstamps = tstamps;\n\ttx->in_use = in_use;\n\ttx->stale = stale;\n\ttx->init = 1;\n\n\tspin_lock_init(&tx->lock);\n\n\treturn 0;\n}\n\n \nstatic void\nice_ptp_flush_tx_tracker(struct ice_pf *pf, struct ice_ptp_tx *tx)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tu64 tstamp_ready;\n\tint err;\n\tu8 idx;\n\n\terr = ice_get_phy_tx_tstamp_ready(hw, tx->block, &tstamp_ready);\n\tif (err) {\n\t\tdev_dbg(ice_pf_to_dev(pf), \"Failed to get the Tx tstamp ready bitmap for block %u, err %d\\n\",\n\t\t\ttx->block, err);\n\n\t\t \n\t\ttstamp_ready = 0;\n\t}\n\n\tfor_each_set_bit(idx, tx->in_use, tx->len) {\n\t\tu8 phy_idx = idx + tx->offset;\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\tif (!hw->reset_ongoing && (tstamp_ready & BIT_ULL(phy_idx)))\n\t\t\tice_clear_phy_tstamp(hw, tx->block, phy_idx);\n\n\t\tspin_lock(&tx->lock);\n\t\tskb = tx->tstamps[idx].skb;\n\t\ttx->tstamps[idx].skb = NULL;\n\t\tclear_bit(idx, tx->in_use);\n\t\tclear_bit(idx, tx->stale);\n\t\tspin_unlock(&tx->lock);\n\n\t\t \n\t\tpf->ptp.tx_hwtstamp_flushed++;\n\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\n \nstatic void\nice_ptp_mark_tx_tracker_stale(struct ice_ptp_tx *tx)\n{\n\tspin_lock(&tx->lock);\n\tbitmap_or(tx->stale, tx->stale, tx->in_use, tx->len);\n\tspin_unlock(&tx->lock);\n}\n\n \nstatic void\nice_ptp_release_tx_tracker(struct ice_pf *pf, struct ice_ptp_tx *tx)\n{\n\tspin_lock(&tx->lock);\n\ttx->init = 0;\n\tspin_unlock(&tx->lock);\n\n\t \n\tsynchronize_irq(pf->oicr_irq.virq);\n\n\tice_ptp_flush_tx_tracker(pf, tx);\n\n\tkfree(tx->tstamps);\n\ttx->tstamps = NULL;\n\n\tbitmap_free(tx->in_use);\n\ttx->in_use = NULL;\n\n\tbitmap_free(tx->stale);\n\ttx->stale = NULL;\n\n\ttx->len = 0;\n}\n\n \nstatic int\nice_ptp_init_tx_e822(struct ice_pf *pf, struct ice_ptp_tx *tx, u8 port)\n{\n\ttx->block = port / ICE_PORTS_PER_QUAD;\n\ttx->offset = (port % ICE_PORTS_PER_QUAD) * INDEX_PER_PORT_E822;\n\ttx->len = INDEX_PER_PORT_E822;\n\ttx->verify_cached = 0;\n\n\treturn ice_ptp_alloc_tx_tracker(tx);\n}\n\n \nstatic int\nice_ptp_init_tx_e810(struct ice_pf *pf, struct ice_ptp_tx *tx)\n{\n\ttx->block = pf->hw.port_info->lport;\n\ttx->offset = 0;\n\ttx->len = INDEX_PER_PORT_E810;\n\t \n\ttx->verify_cached = 1;\n\n\treturn ice_ptp_alloc_tx_tracker(tx);\n}\n\n \nstatic int ice_ptp_update_cached_phctime(struct ice_pf *pf)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tunsigned long update_before;\n\tu64 systime;\n\tint i;\n\n\tupdate_before = pf->ptp.cached_phc_jiffies + msecs_to_jiffies(2000);\n\tif (pf->ptp.cached_phc_time &&\n\t    time_is_before_jiffies(update_before)) {\n\t\tunsigned long time_taken = jiffies - pf->ptp.cached_phc_jiffies;\n\n\t\tdev_warn(dev, \"%u msecs passed between update to cached PHC time\\n\",\n\t\t\t jiffies_to_msecs(time_taken));\n\t\tpf->ptp.late_cached_phc_updates++;\n\t}\n\n\t \n\tsystime = ice_ptp_read_src_clk_reg(pf, NULL);\n\n\t \n\tWRITE_ONCE(pf->ptp.cached_phc_time, systime);\n\tWRITE_ONCE(pf->ptp.cached_phc_jiffies, jiffies);\n\n\tif (test_and_set_bit(ICE_CFG_BUSY, pf->state))\n\t\treturn -EAGAIN;\n\n\tice_for_each_vsi(pf, i) {\n\t\tstruct ice_vsi *vsi = pf->vsi[i];\n\t\tint j;\n\n\t\tif (!vsi)\n\t\t\tcontinue;\n\n\t\tif (vsi->type != ICE_VSI_PF)\n\t\t\tcontinue;\n\n\t\tice_for_each_rxq(vsi, j) {\n\t\t\tif (!vsi->rx_rings[j])\n\t\t\t\tcontinue;\n\t\t\tWRITE_ONCE(vsi->rx_rings[j]->cached_phctime, systime);\n\t\t}\n\t}\n\tclear_bit(ICE_CFG_BUSY, pf->state);\n\n\treturn 0;\n}\n\n \nstatic void ice_ptp_reset_cached_phctime(struct ice_pf *pf)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tint err;\n\n\t \n\terr = ice_ptp_update_cached_phctime(pf);\n\tif (err) {\n\t\t \n\t\tdev_warn(dev, \"%s: ICE_CFG_BUSY, unable to immediately update cached PHC time\\n\",\n\t\t\t __func__);\n\n\t\t \n\t\tkthread_queue_delayed_work(pf->ptp.kworker, &pf->ptp.work,\n\t\t\t\t\t   msecs_to_jiffies(10));\n\t}\n\n\t \n\tice_ptp_mark_tx_tracker_stale(&pf->ptp.port.tx);\n}\n\n \nstatic void\nice_ptp_read_time(struct ice_pf *pf, struct timespec64 *ts,\n\t\t  struct ptp_system_timestamp *sts)\n{\n\tu64 time_ns = ice_ptp_read_src_clk_reg(pf, sts);\n\n\t*ts = ns_to_timespec64(time_ns);\n}\n\n \nstatic int ice_ptp_write_init(struct ice_pf *pf, struct timespec64 *ts)\n{\n\tu64 ns = timespec64_to_ns(ts);\n\tstruct ice_hw *hw = &pf->hw;\n\n\treturn ice_ptp_init_time(hw, ns);\n}\n\n \nstatic int ice_ptp_write_adj(struct ice_pf *pf, s32 adj)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\n\treturn ice_ptp_adj_clock(hw, adj);\n}\n\n \nstatic u64 ice_base_incval(struct ice_pf *pf)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tu64 incval;\n\n\tif (ice_is_e810(hw))\n\t\tincval = ICE_PTP_NOMINAL_INCVAL_E810;\n\telse if (ice_e822_time_ref(hw) < NUM_ICE_TIME_REF_FREQ)\n\t\tincval = ice_e822_nominal_incval(ice_e822_time_ref(hw));\n\telse\n\t\tincval = UNKNOWN_INCVAL_E822;\n\n\tdev_dbg(ice_pf_to_dev(pf), \"PTP: using base increment value of 0x%016llx\\n\",\n\t\tincval);\n\n\treturn incval;\n}\n\n \nstatic int ice_ptp_check_tx_fifo(struct ice_ptp_port *port)\n{\n\tint quad = port->port_num / ICE_PORTS_PER_QUAD;\n\tint offs = port->port_num % ICE_PORTS_PER_QUAD;\n\tstruct ice_pf *pf;\n\tstruct ice_hw *hw;\n\tu32 val, phy_sts;\n\tint err;\n\n\tpf = ptp_port_to_pf(port);\n\thw = &pf->hw;\n\n\tif (port->tx_fifo_busy_cnt == FIFO_OK)\n\t\treturn 0;\n\n\t \n\tif (offs == 0 || offs == 1)\n\t\terr = ice_read_quad_reg_e822(hw, quad, Q_REG_FIFO01_STATUS,\n\t\t\t\t\t     &val);\n\telse\n\t\terr = ice_read_quad_reg_e822(hw, quad, Q_REG_FIFO23_STATUS,\n\t\t\t\t\t     &val);\n\n\tif (err) {\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed to check port %d Tx FIFO, err %d\\n\",\n\t\t\tport->port_num, err);\n\t\treturn err;\n\t}\n\n\tif (offs & 0x1)\n\t\tphy_sts = (val & Q_REG_FIFO13_M) >> Q_REG_FIFO13_S;\n\telse\n\t\tphy_sts = (val & Q_REG_FIFO02_M) >> Q_REG_FIFO02_S;\n\n\tif (phy_sts & FIFO_EMPTY) {\n\t\tport->tx_fifo_busy_cnt = FIFO_OK;\n\t\treturn 0;\n\t}\n\n\tport->tx_fifo_busy_cnt++;\n\n\tdev_dbg(ice_pf_to_dev(pf), \"Try %d, port %d FIFO not empty\\n\",\n\t\tport->tx_fifo_busy_cnt, port->port_num);\n\n\tif (port->tx_fifo_busy_cnt == ICE_PTP_FIFO_NUM_CHECKS) {\n\t\tdev_dbg(ice_pf_to_dev(pf),\n\t\t\t\"Port %d Tx FIFO still not empty; resetting quad %d\\n\",\n\t\t\tport->port_num, quad);\n\t\tice_ptp_reset_ts_memory_quad_e822(hw, quad);\n\t\tport->tx_fifo_busy_cnt = FIFO_OK;\n\t\treturn 0;\n\t}\n\n\treturn -EAGAIN;\n}\n\n \nstatic void ice_ptp_wait_for_offsets(struct kthread_work *work)\n{\n\tstruct ice_ptp_port *port;\n\tstruct ice_pf *pf;\n\tstruct ice_hw *hw;\n\tint tx_err;\n\tint rx_err;\n\n\tport = container_of(work, struct ice_ptp_port, ov_work.work);\n\tpf = ptp_port_to_pf(port);\n\thw = &pf->hw;\n\n\tif (ice_is_reset_in_progress(pf->state)) {\n\t\t \n\t\tkthread_queue_delayed_work(pf->ptp.kworker,\n\t\t\t\t\t   &port->ov_work,\n\t\t\t\t\t   msecs_to_jiffies(100));\n\t\treturn;\n\t}\n\n\ttx_err = ice_ptp_check_tx_fifo(port);\n\tif (!tx_err)\n\t\ttx_err = ice_phy_cfg_tx_offset_e822(hw, port->port_num);\n\trx_err = ice_phy_cfg_rx_offset_e822(hw, port->port_num);\n\tif (tx_err || rx_err) {\n\t\t \n\t\tkthread_queue_delayed_work(pf->ptp.kworker,\n\t\t\t\t\t   &port->ov_work,\n\t\t\t\t\t   msecs_to_jiffies(100));\n\t\treturn;\n\t}\n}\n\n \nstatic int\nice_ptp_port_phy_stop(struct ice_ptp_port *ptp_port)\n{\n\tstruct ice_pf *pf = ptp_port_to_pf(ptp_port);\n\tu8 port = ptp_port->port_num;\n\tstruct ice_hw *hw = &pf->hw;\n\tint err;\n\n\tif (ice_is_e810(hw))\n\t\treturn 0;\n\n\tmutex_lock(&ptp_port->ps_lock);\n\n\tkthread_cancel_delayed_work_sync(&ptp_port->ov_work);\n\n\terr = ice_stop_phy_timer_e822(hw, port, true);\n\tif (err)\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed to set PHY port %d down, err %d\\n\",\n\t\t\tport, err);\n\n\tmutex_unlock(&ptp_port->ps_lock);\n\n\treturn err;\n}\n\n \nstatic int\nice_ptp_port_phy_restart(struct ice_ptp_port *ptp_port)\n{\n\tstruct ice_pf *pf = ptp_port_to_pf(ptp_port);\n\tu8 port = ptp_port->port_num;\n\tstruct ice_hw *hw = &pf->hw;\n\tint err;\n\n\tif (ice_is_e810(hw))\n\t\treturn 0;\n\n\tif (!ptp_port->link_up)\n\t\treturn ice_ptp_port_phy_stop(ptp_port);\n\n\tmutex_lock(&ptp_port->ps_lock);\n\n\tkthread_cancel_delayed_work_sync(&ptp_port->ov_work);\n\n\t \n\tspin_lock(&ptp_port->tx.lock);\n\tptp_port->tx.calibrating = true;\n\tspin_unlock(&ptp_port->tx.lock);\n\tptp_port->tx_fifo_busy_cnt = 0;\n\n\t \n\terr = ice_start_phy_timer_e822(hw, port);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t \n\tspin_lock(&ptp_port->tx.lock);\n\tptp_port->tx.calibrating = false;\n\tspin_unlock(&ptp_port->tx.lock);\n\n\tkthread_queue_delayed_work(pf->ptp.kworker, &ptp_port->ov_work, 0);\n\nout_unlock:\n\tif (err)\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed to set PHY port %d up, err %d\\n\",\n\t\t\tport, err);\n\n\tmutex_unlock(&ptp_port->ps_lock);\n\n\treturn err;\n}\n\n \nvoid ice_ptp_link_change(struct ice_pf *pf, u8 port, bool linkup)\n{\n\tstruct ice_ptp_port *ptp_port;\n\n\tif (!test_bit(ICE_FLAG_PTP, pf->flags))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(port >= ICE_NUM_EXTERNAL_PORTS))\n\t\treturn;\n\n\tptp_port = &pf->ptp.port;\n\tif (WARN_ON_ONCE(ptp_port->port_num != port))\n\t\treturn;\n\n\t \n\tptp_port->link_up = linkup;\n\n\t \n\tif (ice_is_e810(&pf->hw))\n\t\treturn;\n\n\tice_ptp_port_phy_restart(ptp_port);\n}\n\n \nstatic int ice_ptp_tx_ena_intr(struct ice_pf *pf, bool ena, u32 threshold)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tint err = 0;\n\tint quad;\n\tu32 val;\n\n\tice_ptp_reset_ts_memory(hw);\n\n\tfor (quad = 0; quad < ICE_MAX_QUAD; quad++) {\n\t\terr = ice_read_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG,\n\t\t\t\t\t     &val);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (ena) {\n\t\t\tval |= Q_REG_TX_MEM_GBL_CFG_INTR_ENA_M;\n\t\t\tval &= ~Q_REG_TX_MEM_GBL_CFG_INTR_THR_M;\n\t\t\tval |= ((threshold << Q_REG_TX_MEM_GBL_CFG_INTR_THR_S) &\n\t\t\t\tQ_REG_TX_MEM_GBL_CFG_INTR_THR_M);\n\t\t} else {\n\t\t\tval &= ~Q_REG_TX_MEM_GBL_CFG_INTR_ENA_M;\n\t\t}\n\n\t\terr = ice_write_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG,\n\t\t\t\t\t      val);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (err)\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed in intr ena, err %d\\n\",\n\t\t\terr);\n\treturn err;\n}\n\n \nstatic void ice_ptp_reset_phy_timestamping(struct ice_pf *pf)\n{\n\tice_ptp_port_phy_restart(&pf->ptp.port);\n}\n\n \nstatic int ice_ptp_adjfine(struct ptp_clock_info *info, long scaled_ppm)\n{\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\tstruct ice_hw *hw = &pf->hw;\n\tu64 incval;\n\tint err;\n\n\tincval = adjust_by_scaled_ppm(ice_base_incval(pf), scaled_ppm);\n\terr = ice_ptp_write_incval_locked(hw, incval);\n\tif (err) {\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed to set incval, err %d\\n\",\n\t\t\terr);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ice_ptp_extts_event(struct ice_pf *pf)\n{\n\tstruct ptp_clock_event event;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 chan, tmr_idx;\n\tu32 hi, lo;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\t \n\tfor (chan = 0; chan < GLTSYN_EVNT_H_IDX_MAX; chan++) {\n\t\t \n\t\tif (pf->ptp.ext_ts_irq & (1 << chan)) {\n\t\t\tlo = rd32(hw, GLTSYN_EVNT_L(chan, tmr_idx));\n\t\t\thi = rd32(hw, GLTSYN_EVNT_H(chan, tmr_idx));\n\t\t\tevent.timestamp = (((u64)hi) << 32) | lo;\n\t\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\t\tevent.index = chan;\n\n\t\t\t \n\t\t\tptp_clock_event(pf->ptp.clock, &event);\n\t\t\tpf->ptp.ext_ts_irq &= ~(1 << chan);\n\t\t}\n\t}\n}\n\n \nstatic int\nice_ptp_cfg_extts(struct ice_pf *pf, bool ena, unsigned int chan, u32 gpio_pin,\n\t\t  unsigned int extts_flags)\n{\n\tu32 func, aux_reg, gpio_reg, irq_reg;\n\tstruct ice_hw *hw = &pf->hw;\n\tu8 tmr_idx;\n\n\tif (chan > (unsigned int)pf->ptp.info.n_ext_ts)\n\t\treturn -EINVAL;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\n\tirq_reg = rd32(hw, PFINT_OICR_ENA);\n\n\tif (ena) {\n\t\t \n\t\tirq_reg |= PFINT_OICR_TSYN_EVNT_M;\n\t\taux_reg = GLTSYN_AUX_IN_0_INT_ENA_M;\n\n#define GLTSYN_AUX_IN_0_EVNTLVL_RISING_EDGE\tBIT(0)\n#define GLTSYN_AUX_IN_0_EVNTLVL_FALLING_EDGE\tBIT(1)\n\n\t\t \n\t\tif (extts_flags & PTP_FALLING_EDGE)\n\t\t\taux_reg |= GLTSYN_AUX_IN_0_EVNTLVL_FALLING_EDGE;\n\t\tif (extts_flags & PTP_RISING_EDGE)\n\t\t\taux_reg |= GLTSYN_AUX_IN_0_EVNTLVL_RISING_EDGE;\n\n\t\t \n\t\tfunc = 1 + chan + (tmr_idx * 3);\n\t\tgpio_reg = ((func << GLGEN_GPIO_CTL_PIN_FUNC_S) &\n\t\t\t    GLGEN_GPIO_CTL_PIN_FUNC_M);\n\t\tpf->ptp.ext_ts_chan |= (1 << chan);\n\t} else {\n\t\t \n\t\taux_reg = 0;\n\t\tgpio_reg = 0;\n\t\tpf->ptp.ext_ts_chan &= ~(1 << chan);\n\t\tif (!pf->ptp.ext_ts_chan)\n\t\t\tirq_reg &= ~PFINT_OICR_TSYN_EVNT_M;\n\t}\n\n\twr32(hw, PFINT_OICR_ENA, irq_reg);\n\twr32(hw, GLTSYN_AUX_IN(chan, tmr_idx), aux_reg);\n\twr32(hw, GLGEN_GPIO_CTL(gpio_pin), gpio_reg);\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_cfg_clkout(struct ice_pf *pf, unsigned int chan,\n\t\t\t      struct ice_perout_channel *config, bool store)\n{\n\tu64 current_time, period, start_time, phase;\n\tstruct ice_hw *hw = &pf->hw;\n\tu32 func, val, gpio_pin;\n\tu8 tmr_idx;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\n\t \n\twr32(hw, GLTSYN_AUX_OUT(chan, tmr_idx), 0);\n\n\t \n\tif (!config || !config->ena) {\n\t\twr32(hw, GLTSYN_CLKO(chan, tmr_idx), 0);\n\t\twr32(hw, GLTSYN_TGT_L(chan, tmr_idx), 0);\n\t\twr32(hw, GLTSYN_TGT_H(chan, tmr_idx), 0);\n\n\t\tval = GLGEN_GPIO_CTL_PIN_DIR_M;\n\t\tgpio_pin = pf->ptp.perout_channels[chan].gpio_pin;\n\t\twr32(hw, GLGEN_GPIO_CTL(gpio_pin), val);\n\n\t\t \n\t\tif (store)\n\t\t\tmemset(&pf->ptp.perout_channels[chan], 0,\n\t\t\t       sizeof(struct ice_perout_channel));\n\n\t\treturn 0;\n\t}\n\tperiod = config->period;\n\tstart_time = config->start_time;\n\tdiv64_u64_rem(start_time, period, &phase);\n\tgpio_pin = config->gpio_pin;\n\n\t \n\tif (period & 0x1) {\n\t\tdev_err(ice_pf_to_dev(pf), \"CLK Period must be an even value\\n\");\n\t\tgoto err;\n\t}\n\n\tperiod >>= 1;\n\n\t \n#define MIN_PULSE 3\n\tif (period <= MIN_PULSE || period > U32_MAX) {\n\t\tdev_err(ice_pf_to_dev(pf), \"CLK Period must be > %d && < 2^33\",\n\t\t\tMIN_PULSE * 2);\n\t\tgoto err;\n\t}\n\n\twr32(hw, GLTSYN_CLKO(chan, tmr_idx), lower_32_bits(period));\n\n\t \n\tcurrent_time = ice_ptp_read_src_clk_reg(pf, NULL);\n\n\t \n\tif (start_time < current_time)\n\t\tstart_time = div64_u64(current_time + NSEC_PER_SEC - 1,\n\t\t\t\t       NSEC_PER_SEC) * NSEC_PER_SEC + phase;\n\n\tif (ice_is_e810(hw))\n\t\tstart_time -= E810_OUT_PROP_DELAY_NS;\n\telse\n\t\tstart_time -= ice_e822_pps_delay(ice_e822_time_ref(hw));\n\n\t \n\twr32(hw, GLTSYN_TGT_L(chan, tmr_idx), lower_32_bits(start_time));\n\twr32(hw, GLTSYN_TGT_H(chan, tmr_idx), upper_32_bits(start_time));\n\n\t \n\tval = GLTSYN_AUX_OUT_0_OUT_ENA_M | GLTSYN_AUX_OUT_0_OUTMOD_M;\n\twr32(hw, GLTSYN_AUX_OUT(chan, tmr_idx), val);\n\n\t \n\tfunc = 8 + chan + (tmr_idx * 4);\n\tval = GLGEN_GPIO_CTL_PIN_DIR_M |\n\t      ((func << GLGEN_GPIO_CTL_PIN_FUNC_S) & GLGEN_GPIO_CTL_PIN_FUNC_M);\n\twr32(hw, GLGEN_GPIO_CTL(gpio_pin), val);\n\n\t \n\tif (store) {\n\t\tmemcpy(&pf->ptp.perout_channels[chan], config,\n\t\t       sizeof(struct ice_perout_channel));\n\t\tpf->ptp.perout_channels[chan].start_time = phase;\n\t}\n\n\treturn 0;\nerr:\n\tdev_err(ice_pf_to_dev(pf), \"PTP failed to cfg per_clk\\n\");\n\treturn -EFAULT;\n}\n\n \nstatic void ice_ptp_disable_all_clkout(struct ice_pf *pf)\n{\n\tuint i;\n\n\tfor (i = 0; i < pf->ptp.info.n_per_out; i++)\n\t\tif (pf->ptp.perout_channels[i].ena)\n\t\t\tice_ptp_cfg_clkout(pf, i, NULL, false);\n}\n\n \nstatic void ice_ptp_enable_all_clkout(struct ice_pf *pf)\n{\n\tuint i;\n\n\tfor (i = 0; i < pf->ptp.info.n_per_out; i++)\n\t\tif (pf->ptp.perout_channels[i].ena)\n\t\t\tice_ptp_cfg_clkout(pf, i, &pf->ptp.perout_channels[i],\n\t\t\t\t\t   false);\n}\n\n \nstatic int\nice_ptp_gpio_enable_e810(struct ptp_clock_info *info,\n\t\t\t struct ptp_clock_request *rq, int on)\n{\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\tstruct ice_perout_channel clk_cfg = {0};\n\tbool sma_pres = false;\n\tunsigned int chan;\n\tu32 gpio_pin;\n\tint err;\n\n\tif (ice_is_feature_supported(pf, ICE_F_SMA_CTRL))\n\t\tsma_pres = true;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\tchan = rq->perout.index;\n\t\tif (sma_pres) {\n\t\t\tif (chan == ice_pin_desc_e810t[SMA1].chan)\n\t\t\t\tclk_cfg.gpio_pin = GPIO_20;\n\t\t\telse if (chan == ice_pin_desc_e810t[SMA2].chan)\n\t\t\t\tclk_cfg.gpio_pin = GPIO_22;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t} else if (ice_is_e810t(&pf->hw)) {\n\t\t\tif (chan == 0)\n\t\t\t\tclk_cfg.gpio_pin = GPIO_20;\n\t\t\telse\n\t\t\t\tclk_cfg.gpio_pin = GPIO_22;\n\t\t} else if (chan == PPS_CLK_GEN_CHAN) {\n\t\t\tclk_cfg.gpio_pin = PPS_PIN_INDEX;\n\t\t} else {\n\t\t\tclk_cfg.gpio_pin = chan;\n\t\t}\n\n\t\tclk_cfg.period = ((rq->perout.period.sec * NSEC_PER_SEC) +\n\t\t\t\t   rq->perout.period.nsec);\n\t\tclk_cfg.start_time = ((rq->perout.start.sec * NSEC_PER_SEC) +\n\t\t\t\t       rq->perout.start.nsec);\n\t\tclk_cfg.ena = !!on;\n\n\t\terr = ice_ptp_cfg_clkout(pf, chan, &clk_cfg, true);\n\t\tbreak;\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tchan = rq->extts.index;\n\t\tif (sma_pres) {\n\t\t\tif (chan < ice_pin_desc_e810t[SMA2].chan)\n\t\t\t\tgpio_pin = GPIO_21;\n\t\t\telse\n\t\t\t\tgpio_pin = GPIO_23;\n\t\t} else if (ice_is_e810t(&pf->hw)) {\n\t\t\tif (chan == 0)\n\t\t\t\tgpio_pin = GPIO_21;\n\t\t\telse\n\t\t\t\tgpio_pin = GPIO_23;\n\t\t} else {\n\t\t\tgpio_pin = chan;\n\t\t}\n\n\t\terr = ice_ptp_cfg_extts(pf, !!on, chan, gpio_pin,\n\t\t\t\t\trq->extts.flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n \nstatic int ice_ptp_gpio_enable_e823(struct ptp_clock_info *info,\n\t\t\t\t    struct ptp_clock_request *rq, int on)\n{\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\tstruct ice_perout_channel clk_cfg = {0};\n\tint err;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PPS:\n\t\tclk_cfg.gpio_pin = PPS_PIN_INDEX;\n\t\tclk_cfg.period = NSEC_PER_SEC;\n\t\tclk_cfg.ena = !!on;\n\n\t\terr = ice_ptp_cfg_clkout(pf, PPS_CLK_GEN_CHAN, &clk_cfg, true);\n\t\tbreak;\n\tcase PTP_CLK_REQ_EXTTS:\n\t\terr = ice_ptp_cfg_extts(pf, !!on, rq->extts.index,\n\t\t\t\t\tTIME_SYNC_PIN_INDEX, rq->extts.flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n \nstatic int\nice_ptp_gettimex64(struct ptp_clock_info *info, struct timespec64 *ts,\n\t\t   struct ptp_system_timestamp *sts)\n{\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\tstruct ice_hw *hw = &pf->hw;\n\n\tif (!ice_ptp_lock(hw)) {\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed to get time\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tice_ptp_read_time(pf, ts, sts);\n\tice_ptp_unlock(hw);\n\n\treturn 0;\n}\n\n \nstatic int\nice_ptp_settime64(struct ptp_clock_info *info, const struct timespec64 *ts)\n{\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\tstruct timespec64 ts64 = *ts;\n\tstruct ice_hw *hw = &pf->hw;\n\tint err;\n\n\t \n\tif (pf->ptp.port.link_up)\n\t\tice_ptp_port_phy_stop(&pf->ptp.port);\n\n\tif (!ice_ptp_lock(hw)) {\n\t\terr = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\tice_ptp_disable_all_clkout(pf);\n\n\terr = ice_ptp_write_init(pf, &ts64);\n\tice_ptp_unlock(hw);\n\n\tif (!err)\n\t\tice_ptp_reset_cached_phctime(pf);\n\n\t \n\tice_ptp_enable_all_clkout(pf);\n\n\t \n\tif (pf->ptp.port.link_up)\n\t\tice_ptp_port_phy_restart(&pf->ptp.port);\nexit:\n\tif (err) {\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed to set time %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_adjtime_nonatomic(struct ptp_clock_info *info, s64 delta)\n{\n\tstruct timespec64 now, then;\n\tint ret;\n\n\tthen = ns_to_timespec64(delta);\n\tret = ice_ptp_gettimex64(info, &now, NULL);\n\tif (ret)\n\t\treturn ret;\n\tnow = timespec64_add(now, then);\n\n\treturn ice_ptp_settime64(info, (const struct timespec64 *)&now);\n}\n\n \nstatic int ice_ptp_adjtime(struct ptp_clock_info *info, s64 delta)\n{\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct device *dev;\n\tint err;\n\n\tdev = ice_pf_to_dev(pf);\n\n\t \n\tif (delta > S32_MAX || delta < S32_MIN) {\n\t\tdev_dbg(dev, \"delta = %lld, adjtime non-atomic\\n\", delta);\n\t\treturn ice_ptp_adjtime_nonatomic(info, delta);\n\t}\n\n\tif (!ice_ptp_lock(hw)) {\n\t\tdev_err(dev, \"PTP failed to acquire semaphore in adjtime\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tice_ptp_disable_all_clkout(pf);\n\n\terr = ice_ptp_write_adj(pf, delta);\n\n\t \n\tice_ptp_enable_all_clkout(pf);\n\n\tice_ptp_unlock(hw);\n\n\tif (err) {\n\t\tdev_err(dev, \"PTP failed to adjust time, err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tice_ptp_reset_cached_phctime(pf);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ICE_HWTS\n \nstatic int\nice_ptp_get_syncdevicetime(ktime_t *device,\n\t\t\t   struct system_counterval_t *system,\n\t\t\t   void *ctx)\n{\n\tstruct ice_pf *pf = (struct ice_pf *)ctx;\n\tstruct ice_hw *hw = &pf->hw;\n\tu32 hh_lock, hh_art_ctl;\n\tint i;\n\n\t \n\thh_lock = rd32(hw, PFHH_SEM + (PFTSYN_SEM_BYTES * hw->pf_id));\n\tif (hh_lock & PFHH_SEM_BUSY_M) {\n\t\tdev_err(ice_pf_to_dev(pf), \"PTP failed to get hh lock\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\thh_art_ctl = rd32(hw, GLHH_ART_CTL);\n\thh_art_ctl = hh_art_ctl | GLHH_ART_CTL_ACTIVE_M;\n\twr32(hw, GLHH_ART_CTL, hh_art_ctl);\n\n#define MAX_HH_LOCK_TRIES 100\n\n\tfor (i = 0; i < MAX_HH_LOCK_TRIES; i++) {\n\t\t \n\t\thh_art_ctl = rd32(hw, GLHH_ART_CTL);\n\t\tif (hh_art_ctl & GLHH_ART_CTL_ACTIVE_M) {\n\t\t\tudelay(1);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu32 hh_ts_lo, hh_ts_hi, tmr_idx;\n\t\t\tu64 hh_ts;\n\n\t\t\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_assoc;\n\t\t\t \n\t\t\thh_ts_lo = rd32(hw, GLHH_ART_TIME_L);\n\t\t\thh_ts_hi = rd32(hw, GLHH_ART_TIME_H);\n\t\t\thh_ts = ((u64)hh_ts_hi << 32) | hh_ts_lo;\n\t\t\t*system = convert_art_ns_to_tsc(hh_ts);\n\t\t\t \n\t\t\thh_ts_lo = rd32(hw, GLTSYN_HHTIME_L(tmr_idx));\n\t\t\thh_ts_hi = rd32(hw, GLTSYN_HHTIME_H(tmr_idx));\n\t\t\thh_ts = ((u64)hh_ts_hi << 32) | hh_ts_lo;\n\t\t\t*device = ns_to_ktime(hh_ts);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\thh_lock = rd32(hw, PFHH_SEM + (PFTSYN_SEM_BYTES * hw->pf_id));\n\thh_lock = hh_lock & ~PFHH_SEM_BUSY_M;\n\twr32(hw, PFHH_SEM + (PFTSYN_SEM_BYTES * hw->pf_id), hh_lock);\n\n\tif (i == MAX_HH_LOCK_TRIES)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int\nice_ptp_getcrosststamp_e822(struct ptp_clock_info *info,\n\t\t\t    struct system_device_crosststamp *cts)\n{\n\tstruct ice_pf *pf = ptp_info_to_pf(info);\n\n\treturn get_device_system_crosststamp(ice_ptp_get_syncdevicetime,\n\t\t\t\t\t     pf, NULL, cts);\n}\n#endif  \n\n \nint ice_ptp_get_ts_config(struct ice_pf *pf, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config *config;\n\n\tif (!test_bit(ICE_FLAG_PTP, pf->flags))\n\t\treturn -EIO;\n\n\tconfig = &pf->ptp.tstamp_config;\n\n\treturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nstatic int\nice_ptp_set_timestamp_mode(struct ice_pf *pf, struct hwtstamp_config *config)\n{\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tice_set_tx_tstamp(pf, false);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tice_set_tx_tstamp(pf, true);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tice_set_rx_tstamp(pf, false);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\tcase HWTSTAMP_FILTER_ALL:\n\t\tice_set_rx_tstamp(pf, true);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\n \nint ice_ptp_set_ts_config(struct ice_pf *pf, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (!test_bit(ICE_FLAG_PTP, pf->flags))\n\t\treturn -EAGAIN;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = ice_ptp_set_timestamp_mode(pf, &config);\n\tif (err)\n\t\treturn err;\n\n\t \n\tconfig = pf->ptp.tstamp_config;\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nvoid\nice_ptp_rx_hwtstamp(struct ice_rx_ring *rx_ring,\n\t\t    union ice_32b_rx_flex_desc *rx_desc, struct sk_buff *skb)\n{\n\tstruct skb_shared_hwtstamps *hwtstamps;\n\tu64 ts_ns, cached_time;\n\tu32 ts_high;\n\n\tif (!(rx_desc->wb.time_stamp_low & ICE_PTP_TS_VALID))\n\t\treturn;\n\n\tcached_time = READ_ONCE(rx_ring->cached_phctime);\n\n\t \n\tif (!cached_time)\n\t\treturn;\n\n\t \n\tts_high = le32_to_cpu(rx_desc->wb.flex_ts.ts_high);\n\tts_ns = ice_ptp_extend_32b_ts(cached_time, ts_high);\n\n\thwtstamps = skb_hwtstamps(skb);\n\tmemset(hwtstamps, 0, sizeof(*hwtstamps));\n\thwtstamps->hwtstamp = ns_to_ktime(ts_ns);\n}\n\n \nstatic void\nice_ptp_disable_sma_pins_e810t(struct ice_pf *pf, struct ptp_clock_info *info)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\n\tdev_warn(dev, \"Failed to configure E810-T SMA pin control\\n\");\n\n\tinfo->enable = NULL;\n\tinfo->verify = NULL;\n\tinfo->n_pins = 0;\n\tinfo->n_ext_ts = 0;\n\tinfo->n_per_out = 0;\n}\n\n \nstatic void\nice_ptp_setup_sma_pins_e810t(struct ice_pf *pf, struct ptp_clock_info *info)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tint err;\n\n\t \n\tinfo->pin_config = devm_kcalloc(dev, info->n_pins,\n\t\t\t\t\tsizeof(*info->pin_config), GFP_KERNEL);\n\tif (!info->pin_config) {\n\t\tice_ptp_disable_sma_pins_e810t(pf, info);\n\t\treturn;\n\t}\n\n\t \n\terr = ice_get_sma_config_e810t(&pf->hw, info->pin_config);\n\tif (err)\n\t\tice_ptp_disable_sma_pins_e810t(pf, info);\n}\n\n \nstatic void\nice_ptp_setup_pins_e810(struct ice_pf *pf, struct ptp_clock_info *info)\n{\n\tif (ice_is_feature_supported(pf, ICE_F_SMA_CTRL)) {\n\t\tinfo->n_ext_ts = N_EXT_TS_E810;\n\t\tinfo->n_per_out = N_PER_OUT_E810T;\n\t\tinfo->n_pins = NUM_PTP_PINS_E810T;\n\t\tinfo->verify = ice_verify_pin_e810t;\n\n\t\t \n\t\tice_ptp_setup_sma_pins_e810t(pf, info);\n\t} else if (ice_is_e810t(&pf->hw)) {\n\t\tinfo->n_ext_ts = N_EXT_TS_NO_SMA_E810T;\n\t\tinfo->n_per_out = N_PER_OUT_NO_SMA_E810T;\n\t} else {\n\t\tinfo->n_per_out = N_PER_OUT_E810;\n\t\tinfo->n_ext_ts = N_EXT_TS_E810;\n\t}\n}\n\n \nstatic void\nice_ptp_setup_pins_e823(struct ice_pf *pf, struct ptp_clock_info *info)\n{\n\tinfo->pps = 1;\n\tinfo->n_per_out = 0;\n\tinfo->n_ext_ts = 1;\n}\n\n \nstatic void\nice_ptp_set_funcs_e822(struct ice_pf *pf, struct ptp_clock_info *info)\n{\n#ifdef CONFIG_ICE_HWTS\n\tif (boot_cpu_has(X86_FEATURE_ART) &&\n\t    boot_cpu_has(X86_FEATURE_TSC_KNOWN_FREQ))\n\t\tinfo->getcrosststamp = ice_ptp_getcrosststamp_e822;\n#endif  \n}\n\n \nstatic void\nice_ptp_set_funcs_e810(struct ice_pf *pf, struct ptp_clock_info *info)\n{\n\tinfo->enable = ice_ptp_gpio_enable_e810;\n\tice_ptp_setup_pins_e810(pf, info);\n}\n\n \nstatic void\nice_ptp_set_funcs_e823(struct ice_pf *pf, struct ptp_clock_info *info)\n{\n\tinfo->enable = ice_ptp_gpio_enable_e823;\n\tice_ptp_setup_pins_e823(pf, info);\n}\n\n \nstatic void ice_ptp_set_caps(struct ice_pf *pf)\n{\n\tstruct ptp_clock_info *info = &pf->ptp.info;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\n\tsnprintf(info->name, sizeof(info->name) - 1, \"%s-%s-clk\",\n\t\t dev_driver_string(dev), dev_name(dev));\n\tinfo->owner = THIS_MODULE;\n\tinfo->max_adj = 100000000;\n\tinfo->adjtime = ice_ptp_adjtime;\n\tinfo->adjfine = ice_ptp_adjfine;\n\tinfo->gettimex64 = ice_ptp_gettimex64;\n\tinfo->settime64 = ice_ptp_settime64;\n\n\tif (ice_is_e810(&pf->hw))\n\t\tice_ptp_set_funcs_e810(pf, info);\n\telse if (ice_is_e823(&pf->hw))\n\t\tice_ptp_set_funcs_e823(pf, info);\n\telse\n\t\tice_ptp_set_funcs_e822(pf, info);\n}\n\n \nstatic long ice_ptp_create_clock(struct ice_pf *pf)\n{\n\tstruct ptp_clock_info *info;\n\tstruct ptp_clock *clock;\n\tstruct device *dev;\n\n\t \n\tif (pf->ptp.clock)\n\t\treturn 0;\n\n\tice_ptp_set_caps(pf);\n\n\tinfo = &pf->ptp.info;\n\tdev = ice_pf_to_dev(pf);\n\n\t \n\tclock = ptp_clock_register(info, dev);\n\tif (IS_ERR(clock))\n\t\treturn PTR_ERR(clock);\n\n\tpf->ptp.clock = clock;\n\n\treturn 0;\n}\n\n \ns8 ice_ptp_request_ts(struct ice_ptp_tx *tx, struct sk_buff *skb)\n{\n\tu8 idx;\n\n\tspin_lock(&tx->lock);\n\n\t \n\tif (!ice_ptp_is_tx_tracker_up(tx)) {\n\t\tspin_unlock(&tx->lock);\n\t\treturn -1;\n\t}\n\n\t \n\tidx = find_first_zero_bit(tx->in_use, tx->len);\n\tif (idx < tx->len) {\n\t\t \n\t\tset_bit(idx, tx->in_use);\n\t\tclear_bit(idx, tx->stale);\n\t\ttx->tstamps[idx].start = jiffies;\n\t\ttx->tstamps[idx].skb = skb_get(skb);\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tice_trace(tx_tstamp_request, skb, idx);\n\t}\n\n\tspin_unlock(&tx->lock);\n\n\t \n\tif (idx >= tx->len)\n\t\treturn -1;\n\telse\n\t\treturn idx + tx->offset;\n}\n\n \nenum ice_tx_tstamp_work ice_ptp_process_ts(struct ice_pf *pf)\n{\n\treturn ice_ptp_tx_tstamp(&pf->ptp.port.tx);\n}\n\nstatic void ice_ptp_periodic_work(struct kthread_work *work)\n{\n\tstruct ice_ptp *ptp = container_of(work, struct ice_ptp, work.work);\n\tstruct ice_pf *pf = container_of(ptp, struct ice_pf, ptp);\n\tint err;\n\n\tif (!test_bit(ICE_FLAG_PTP, pf->flags))\n\t\treturn;\n\n\terr = ice_ptp_update_cached_phctime(pf);\n\n\t \n\tkthread_queue_delayed_work(ptp->kworker, &ptp->work,\n\t\t\t\t   msecs_to_jiffies(err ? 10 : 500));\n}\n\n \nvoid ice_ptp_reset(struct ice_pf *pf)\n{\n\tstruct ice_ptp *ptp = &pf->ptp;\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct timespec64 ts;\n\tint err, itr = 1;\n\tu64 time_diff;\n\n\tif (test_bit(ICE_PFR_REQ, pf->state))\n\t\tgoto pfr;\n\n\tif (!hw->func_caps.ts_func_info.src_tmr_owned)\n\t\tgoto reset_ts;\n\n\terr = ice_ptp_init_phc(hw);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tif (!ice_ptp_lock(hw)) {\n\t\terr = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t \n\terr = ice_ptp_write_incval(hw, ice_base_incval(pf));\n\tif (err) {\n\t\tice_ptp_unlock(hw);\n\t\tgoto err;\n\t}\n\n\t \n\tif (ptp->cached_phc_time) {\n\t\ttime_diff = ktime_get_real_ns() - ptp->reset_time;\n\t\tts = ns_to_timespec64(ptp->cached_phc_time + time_diff);\n\t} else {\n\t\tts = ktime_to_timespec64(ktime_get_real());\n\t}\n\terr = ice_ptp_write_init(pf, &ts);\n\tif (err) {\n\t\tice_ptp_unlock(hw);\n\t\tgoto err;\n\t}\n\n\t \n\tice_ptp_unlock(hw);\n\n\tif (!ice_is_e810(hw)) {\n\t\t \n\t\terr = ice_ptp_tx_ena_intr(pf, true, itr);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\nreset_ts:\n\t \n\tice_ptp_reset_phy_timestamping(pf);\n\npfr:\n\t \n\tif (ice_is_e810(&pf->hw)) {\n\t\terr = ice_ptp_init_tx_e810(pf, &ptp->port.tx);\n\t} else {\n\t\tkthread_init_delayed_work(&ptp->port.ov_work,\n\t\t\t\t\t  ice_ptp_wait_for_offsets);\n\t\terr = ice_ptp_init_tx_e822(pf, &ptp->port.tx,\n\t\t\t\t\t   ptp->port.port_num);\n\t}\n\tif (err)\n\t\tgoto err;\n\n\tset_bit(ICE_FLAG_PTP, pf->flags);\n\n\t \n\tkthread_queue_delayed_work(ptp->kworker, &ptp->work, 0);\n\n\tdev_info(ice_pf_to_dev(pf), \"PTP reset successful\\n\");\n\treturn;\n\nerr:\n\tdev_err(ice_pf_to_dev(pf), \"PTP reset failed %d\\n\", err);\n}\n\n \nvoid ice_ptp_prepare_for_reset(struct ice_pf *pf)\n{\n\tstruct ice_ptp *ptp = &pf->ptp;\n\tu8 src_tmr;\n\n\tclear_bit(ICE_FLAG_PTP, pf->flags);\n\n\t \n\tice_ptp_cfg_timestamp(pf, false);\n\n\tkthread_cancel_delayed_work_sync(&ptp->work);\n\n\tif (test_bit(ICE_PFR_REQ, pf->state))\n\t\treturn;\n\n\tice_ptp_release_tx_tracker(pf, &pf->ptp.port.tx);\n\n\t \n\tice_ptp_disable_all_clkout(pf);\n\n\tsrc_tmr = ice_get_ptp_src_clock_index(&pf->hw);\n\n\t \n\twr32(&pf->hw, GLTSYN_ENA(src_tmr), (u32)~GLTSYN_ENA_TSYN_ENA_M);\n\n\t \n\tptp->reset_time = ktime_get_real_ns();\n}\n\n \nstatic int ice_ptp_init_owner(struct ice_pf *pf)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct timespec64 ts;\n\tint err, itr = 1;\n\n\terr = ice_ptp_init_phc(hw);\n\tif (err) {\n\t\tdev_err(ice_pf_to_dev(pf), \"Failed to initialize PHC, err %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tif (!ice_ptp_lock(hw)) {\n\t\terr = -EBUSY;\n\t\tgoto err_exit;\n\t}\n\n\t \n\terr = ice_ptp_write_incval(hw, ice_base_incval(pf));\n\tif (err) {\n\t\tice_ptp_unlock(hw);\n\t\tgoto err_exit;\n\t}\n\n\tts = ktime_to_timespec64(ktime_get_real());\n\t \n\terr = ice_ptp_write_init(pf, &ts);\n\tif (err) {\n\t\tice_ptp_unlock(hw);\n\t\tgoto err_exit;\n\t}\n\n\t \n\tice_ptp_unlock(hw);\n\n\tif (!ice_is_e810(hw)) {\n\t\t \n\t\terr = ice_ptp_tx_ena_intr(pf, true, itr);\n\t\tif (err)\n\t\t\tgoto err_exit;\n\t}\n\n\t \n\terr = ice_ptp_create_clock(pf);\n\tif (err)\n\t\tgoto err_clk;\n\n\t \n\tice_set_ptp_clock_index(pf);\n\n\treturn 0;\n\nerr_clk:\n\tpf->ptp.clock = NULL;\nerr_exit:\n\treturn err;\n}\n\n \nstatic int ice_ptp_init_work(struct ice_pf *pf, struct ice_ptp *ptp)\n{\n\tstruct kthread_worker *kworker;\n\n\t \n\tkthread_init_delayed_work(&ptp->work, ice_ptp_periodic_work);\n\n\t \n\tkworker = kthread_create_worker(0, \"ice-ptp-%s\",\n\t\t\t\t\tdev_name(ice_pf_to_dev(pf)));\n\tif (IS_ERR(kworker))\n\t\treturn PTR_ERR(kworker);\n\n\tptp->kworker = kworker;\n\n\t \n\tkthread_queue_delayed_work(ptp->kworker, &ptp->work, 0);\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_init_port(struct ice_pf *pf, struct ice_ptp_port *ptp_port)\n{\n\tmutex_init(&ptp_port->ps_lock);\n\n\tif (ice_is_e810(&pf->hw))\n\t\treturn ice_ptp_init_tx_e810(pf, &ptp_port->tx);\n\n\tkthread_init_delayed_work(&ptp_port->ov_work,\n\t\t\t\t  ice_ptp_wait_for_offsets);\n\treturn ice_ptp_init_tx_e822(pf, &ptp_port->tx, ptp_port->port_num);\n}\n\n \nvoid ice_ptp_init(struct ice_pf *pf)\n{\n\tstruct ice_ptp *ptp = &pf->ptp;\n\tstruct ice_hw *hw = &pf->hw;\n\tint err;\n\n\t \n\tif (hw->func_caps.ts_func_info.src_tmr_owned) {\n\t\terr = ice_ptp_init_owner(pf);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tptp->port.port_num = hw->pf_id;\n\terr = ice_ptp_init_port(pf, &ptp->port);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tice_ptp_reset_phy_timestamping(pf);\n\n\tset_bit(ICE_FLAG_PTP, pf->flags);\n\terr = ice_ptp_init_work(pf, ptp);\n\tif (err)\n\t\tgoto err;\n\n\tdev_info(ice_pf_to_dev(pf), \"PTP init successful\\n\");\n\treturn;\n\nerr:\n\t \n\tif (pf->ptp.clock) {\n\t\tptp_clock_unregister(ptp->clock);\n\t\tpf->ptp.clock = NULL;\n\t}\n\tclear_bit(ICE_FLAG_PTP, pf->flags);\n\tdev_err(ice_pf_to_dev(pf), \"PTP failed %d\\n\", err);\n}\n\n \nvoid ice_ptp_release(struct ice_pf *pf)\n{\n\tif (!test_bit(ICE_FLAG_PTP, pf->flags))\n\t\treturn;\n\n\t \n\tice_ptp_cfg_timestamp(pf, false);\n\n\tice_ptp_release_tx_tracker(pf, &pf->ptp.port.tx);\n\n\tclear_bit(ICE_FLAG_PTP, pf->flags);\n\n\tkthread_cancel_delayed_work_sync(&pf->ptp.work);\n\n\tice_ptp_port_phy_stop(&pf->ptp.port);\n\tmutex_destroy(&pf->ptp.port.ps_lock);\n\tif (pf->ptp.kworker) {\n\t\tkthread_destroy_worker(pf->ptp.kworker);\n\t\tpf->ptp.kworker = NULL;\n\t}\n\n\tif (!pf->ptp.clock)\n\t\treturn;\n\n\t \n\tice_ptp_disable_all_clkout(pf);\n\n\tice_clear_ptp_clock_index(pf);\n\tptp_clock_unregister(pf->ptp.clock);\n\tpf->ptp.clock = NULL;\n\n\tdev_info(ice_pf_to_dev(pf), \"Removed PTP clock\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}