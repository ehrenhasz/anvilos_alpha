{
  "module_name": "ice_dcb.c",
  "hash_id": "e36b04084c1142c04b9e404accf23750984c22192ade3363df9b6bf5bb827e02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_dcb.c",
  "human_readable_source": "\n \n\n#include \"ice_common.h\"\n#include \"ice_sched.h\"\n#include \"ice_dcb.h\"\n\n \nstatic int\nice_aq_get_lldp_mib(struct ice_hw *hw, u8 bridge_type, u8 mib_type, void *buf,\n\t\t    u16 buf_size, u16 *local_len, u16 *remote_len,\n\t\t    struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_lldp_get_mib *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tcmd = &desc.params.lldp_get_mib;\n\n\tif (buf_size == 0 || !buf)\n\t\treturn -EINVAL;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_lldp_get_mib);\n\n\tcmd->type = mib_type & ICE_AQ_LLDP_MIB_TYPE_M;\n\tcmd->type |= (bridge_type << ICE_AQ_LLDP_BRID_TYPE_S) &\n\t\tICE_AQ_LLDP_BRID_TYPE_M;\n\n\tdesc.datalen = cpu_to_le16(buf_size);\n\n\tstatus = ice_aq_send_cmd(hw, &desc, buf, buf_size, cd);\n\tif (!status) {\n\t\tif (local_len)\n\t\t\t*local_len = le16_to_cpu(cmd->local_len);\n\t\tif (remote_len)\n\t\t\t*remote_len = le16_to_cpu(cmd->remote_len);\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nice_aq_cfg_lldp_mib_change(struct ice_hw *hw, bool ena_update,\n\t\t\t   struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_lldp_set_mib_change *cmd;\n\tstruct ice_aq_desc desc;\n\n\tcmd = &desc.params.lldp_set_event;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_lldp_set_mib_change);\n\n\tif (!ena_update)\n\t\tcmd->command |= ICE_AQ_LLDP_MIB_UPDATE_DIS;\n\telse\n\t\tcmd->command |= FIELD_PREP(ICE_AQ_LLDP_MIB_PENDING_M,\n\t\t\t\t\t   ICE_AQ_LLDP_MIB_PENDING_ENABLE);\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n}\n\n \nint\nice_aq_stop_lldp(struct ice_hw *hw, bool shutdown_lldp_agent, bool persist,\n\t\t struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_lldp_stop *cmd;\n\tstruct ice_aq_desc desc;\n\n\tcmd = &desc.params.lldp_stop;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_lldp_stop);\n\n\tif (shutdown_lldp_agent)\n\t\tcmd->command |= ICE_AQ_LLDP_AGENT_SHUTDOWN;\n\n\tif (persist)\n\t\tcmd->command |= ICE_AQ_LLDP_AGENT_PERSIST_DIS;\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n}\n\n \nint ice_aq_start_lldp(struct ice_hw *hw, bool persist, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_lldp_start *cmd;\n\tstruct ice_aq_desc desc;\n\n\tcmd = &desc.params.lldp_start;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_lldp_start);\n\n\tcmd->command = ICE_AQ_LLDP_AGENT_START;\n\n\tif (persist)\n\t\tcmd->command |= ICE_AQ_LLDP_AGENT_PERSIST_ENA;\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n}\n\n \nstatic u8 ice_get_dcbx_status(struct ice_hw *hw)\n{\n\tu32 reg;\n\n\treg = rd32(hw, PRTDCB_GENS);\n\treturn (u8)((reg & PRTDCB_GENS_DCBX_STATUS_M) >>\n\t\t    PRTDCB_GENS_DCBX_STATUS_S);\n}\n\n \nstatic void\nice_parse_ieee_ets_common_tlv(u8 *buf, struct ice_dcb_ets_cfg *ets_cfg)\n{\n\tu8 offset = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tets_cfg->prio_table[i * 2] =\n\t\t\t((buf[offset] & ICE_IEEE_ETS_PRIO_1_M) >>\n\t\t\t ICE_IEEE_ETS_PRIO_1_S);\n\t\tets_cfg->prio_table[i * 2 + 1] =\n\t\t\t((buf[offset] & ICE_IEEE_ETS_PRIO_0_M) >>\n\t\t\t ICE_IEEE_ETS_PRIO_0_S);\n\t\toffset++;\n\t}\n\n\t \n\tice_for_each_traffic_class(i) {\n\t\tets_cfg->tcbwtable[i] = buf[offset];\n\t\tets_cfg->tsatable[i] = buf[ICE_MAX_TRAFFIC_CLASS + offset++];\n\t}\n}\n\n \nstatic void\nice_parse_ieee_etscfg_tlv(struct ice_lldp_org_tlv *tlv,\n\t\t\t  struct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_dcb_ets_cfg *etscfg;\n\tu8 *buf = tlv->tlvinfo;\n\n\t \n\tetscfg = &dcbcfg->etscfg;\n\tetscfg->willing = ((buf[0] & ICE_IEEE_ETS_WILLING_M) >>\n\t\t\t   ICE_IEEE_ETS_WILLING_S);\n\tetscfg->cbs = ((buf[0] & ICE_IEEE_ETS_CBS_M) >> ICE_IEEE_ETS_CBS_S);\n\tetscfg->maxtcs = ((buf[0] & ICE_IEEE_ETS_MAXTC_M) >>\n\t\t\t  ICE_IEEE_ETS_MAXTC_S);\n\n\t \n\tice_parse_ieee_ets_common_tlv(&buf[1], etscfg);\n}\n\n \nstatic void\nice_parse_ieee_etsrec_tlv(struct ice_lldp_org_tlv *tlv,\n\t\t\t  struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\n\t \n\tice_parse_ieee_ets_common_tlv(&buf[1], &dcbcfg->etsrec);\n}\n\n \nstatic void\nice_parse_ieee_pfccfg_tlv(struct ice_lldp_org_tlv *tlv,\n\t\t\t  struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\n\t \n\tdcbcfg->pfc.willing = ((buf[0] & ICE_IEEE_PFC_WILLING_M) >>\n\t\t\t       ICE_IEEE_PFC_WILLING_S);\n\tdcbcfg->pfc.mbc = ((buf[0] & ICE_IEEE_PFC_MBC_M) >> ICE_IEEE_PFC_MBC_S);\n\tdcbcfg->pfc.pfccap = ((buf[0] & ICE_IEEE_PFC_CAP_M) >>\n\t\t\t      ICE_IEEE_PFC_CAP_S);\n\tdcbcfg->pfc.pfcena = buf[1];\n}\n\n \nstatic void\nice_parse_ieee_app_tlv(struct ice_lldp_org_tlv *tlv,\n\t\t       struct ice_dcbx_cfg *dcbcfg)\n{\n\tu16 offset = 0;\n\tu16 typelen;\n\tint i = 0;\n\tu16 len;\n\tu8 *buf;\n\n\ttypelen = ntohs(tlv->typelen);\n\tlen = ((typelen & ICE_LLDP_TLV_LEN_M) >> ICE_LLDP_TLV_LEN_S);\n\tbuf = tlv->tlvinfo;\n\n\t \n\tlen -= (sizeof(tlv->ouisubtype) + 1);\n\n\t \n\toffset++;\n\n\t \n\twhile (offset < len) {\n\t\tdcbcfg->app[i].priority = ((buf[offset] &\n\t\t\t\t\t    ICE_IEEE_APP_PRIO_M) >>\n\t\t\t\t\t   ICE_IEEE_APP_PRIO_S);\n\t\tdcbcfg->app[i].selector = ((buf[offset] &\n\t\t\t\t\t    ICE_IEEE_APP_SEL_M) >>\n\t\t\t\t\t   ICE_IEEE_APP_SEL_S);\n\t\tdcbcfg->app[i].prot_id = (buf[offset + 1] << 0x8) |\n\t\t\tbuf[offset + 2];\n\t\t \n\t\toffset += 3;\n\t\ti++;\n\t\tif (i >= ICE_DCBX_MAX_APPS)\n\t\t\tbreak;\n\t}\n\n\tdcbcfg->numapps = i;\n}\n\n \nstatic void\nice_parse_ieee_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tu32 ouisubtype;\n\tu8 subtype;\n\n\touisubtype = ntohl(tlv->ouisubtype);\n\tsubtype = (u8)((ouisubtype & ICE_LLDP_TLV_SUBTYPE_M) >>\n\t\t       ICE_LLDP_TLV_SUBTYPE_S);\n\tswitch (subtype) {\n\tcase ICE_IEEE_SUBTYPE_ETS_CFG:\n\t\tice_parse_ieee_etscfg_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase ICE_IEEE_SUBTYPE_ETS_REC:\n\t\tice_parse_ieee_etsrec_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase ICE_IEEE_SUBTYPE_PFC_CFG:\n\t\tice_parse_ieee_pfccfg_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase ICE_IEEE_SUBTYPE_APP_PRI:\n\t\tice_parse_ieee_app_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nice_parse_cee_pgcfg_tlv(struct ice_cee_feat_tlv *tlv,\n\t\t\tstruct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_dcb_ets_cfg *etscfg;\n\tu8 *buf = tlv->tlvinfo;\n\tu16 offset = 0;\n\tint i;\n\n\tetscfg = &dcbcfg->etscfg;\n\n\tif (tlv->en_will_err & ICE_CEE_FEAT_TLV_WILLING_M)\n\t\tetscfg->willing = 1;\n\n\tetscfg->cbs = 0;\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tetscfg->prio_table[i * 2] =\n\t\t\t((buf[offset] & ICE_CEE_PGID_PRIO_1_M) >>\n\t\t\t ICE_CEE_PGID_PRIO_1_S);\n\t\tetscfg->prio_table[i * 2 + 1] =\n\t\t\t((buf[offset] & ICE_CEE_PGID_PRIO_0_M) >>\n\t\t\t ICE_CEE_PGID_PRIO_0_S);\n\t\toffset++;\n\t}\n\n\t \n\tice_for_each_traffic_class(i) {\n\t\tetscfg->tcbwtable[i] = buf[offset++];\n\n\t\tif (etscfg->prio_table[i] == ICE_CEE_PGID_STRICT)\n\t\t\tdcbcfg->etscfg.tsatable[i] = ICE_IEEE_TSA_STRICT;\n\t\telse\n\t\t\tdcbcfg->etscfg.tsatable[i] = ICE_IEEE_TSA_ETS;\n\t}\n\n\t \n\tetscfg->maxtcs = buf[offset];\n}\n\n \nstatic void\nice_parse_cee_pfccfg_tlv(struct ice_cee_feat_tlv *tlv,\n\t\t\t struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\n\tif (tlv->en_will_err & ICE_CEE_FEAT_TLV_WILLING_M)\n\t\tdcbcfg->pfc.willing = 1;\n\n\t \n\tdcbcfg->pfc.pfcena = buf[0];\n\tdcbcfg->pfc.pfccap = buf[1];\n}\n\n \nstatic void\nice_parse_cee_app_tlv(struct ice_cee_feat_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tu16 len, typelen, offset = 0;\n\tstruct ice_cee_app_prio *app;\n\tu8 i;\n\n\ttypelen = ntohs(tlv->hdr.typelen);\n\tlen = ((typelen & ICE_LLDP_TLV_LEN_M) >> ICE_LLDP_TLV_LEN_S);\n\n\tdcbcfg->numapps = len / sizeof(*app);\n\tif (!dcbcfg->numapps)\n\t\treturn;\n\tif (dcbcfg->numapps > ICE_DCBX_MAX_APPS)\n\t\tdcbcfg->numapps = ICE_DCBX_MAX_APPS;\n\n\tfor (i = 0; i < dcbcfg->numapps; i++) {\n\t\tu8 up, selector;\n\n\t\tapp = (struct ice_cee_app_prio *)(tlv->tlvinfo + offset);\n\t\tfor (up = 0; up < ICE_MAX_USER_PRIORITY; up++)\n\t\t\tif (app->prio_map & BIT(up))\n\t\t\t\tbreak;\n\n\t\tdcbcfg->app[i].priority = up;\n\n\t\t \n\t\tselector = (app->upper_oui_sel & ICE_CEE_APP_SELECTOR_M);\n\t\tswitch (selector) {\n\t\tcase ICE_CEE_APP_SEL_ETHTYPE:\n\t\t\tdcbcfg->app[i].selector = ICE_APP_SEL_ETHTYPE;\n\t\t\tbreak;\n\t\tcase ICE_CEE_APP_SEL_TCPIP:\n\t\t\tdcbcfg->app[i].selector = ICE_APP_SEL_TCPIP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdcbcfg->app[i].selector = selector;\n\t\t}\n\n\t\tdcbcfg->app[i].prot_id = ntohs(app->protocol);\n\t\t \n\t\toffset += sizeof(*app);\n\t}\n}\n\n \nstatic void\nice_parse_cee_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_cee_feat_tlv *sub_tlv;\n\tu8 subtype, feat_tlv_count = 0;\n\tu16 len, tlvlen, typelen;\n\tu32 ouisubtype;\n\n\touisubtype = ntohl(tlv->ouisubtype);\n\tsubtype = (u8)((ouisubtype & ICE_LLDP_TLV_SUBTYPE_M) >>\n\t\t       ICE_LLDP_TLV_SUBTYPE_S);\n\t \n\tif (subtype != ICE_CEE_DCBX_TYPE)\n\t\treturn;\n\n\ttypelen = ntohs(tlv->typelen);\n\ttlvlen = ((typelen & ICE_LLDP_TLV_LEN_M) >> ICE_LLDP_TLV_LEN_S);\n\tlen = sizeof(tlv->typelen) + sizeof(ouisubtype) +\n\t\tsizeof(struct ice_cee_ctrl_tlv);\n\t \n\tif (tlvlen <= len)\n\t\treturn;\n\n\tsub_tlv = (struct ice_cee_feat_tlv *)((char *)tlv + len);\n\twhile (feat_tlv_count < ICE_CEE_MAX_FEAT_TYPE) {\n\t\tu16 sublen;\n\n\t\ttypelen = ntohs(sub_tlv->hdr.typelen);\n\t\tsublen = ((typelen & ICE_LLDP_TLV_LEN_M) >> ICE_LLDP_TLV_LEN_S);\n\t\tsubtype = (u8)((typelen & ICE_LLDP_TLV_TYPE_M) >>\n\t\t\t       ICE_LLDP_TLV_TYPE_S);\n\t\tswitch (subtype) {\n\t\tcase ICE_CEE_SUBTYPE_PG_CFG:\n\t\t\tice_parse_cee_pgcfg_tlv(sub_tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase ICE_CEE_SUBTYPE_PFC_CFG:\n\t\t\tice_parse_cee_pfccfg_tlv(sub_tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase ICE_CEE_SUBTYPE_APP_PRI:\n\t\t\tice_parse_cee_app_tlv(sub_tlv, dcbcfg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t \n\t\t}\n\t\tfeat_tlv_count++;\n\t\t \n\t\tsub_tlv = (struct ice_cee_feat_tlv *)\n\t\t\t  ((char *)sub_tlv + sizeof(sub_tlv->hdr.typelen) +\n\t\t\t   sublen);\n\t}\n}\n\n \nstatic void\nice_parse_org_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tu32 ouisubtype;\n\tu32 oui;\n\n\touisubtype = ntohl(tlv->ouisubtype);\n\toui = ((ouisubtype & ICE_LLDP_TLV_OUI_M) >> ICE_LLDP_TLV_OUI_S);\n\tswitch (oui) {\n\tcase ICE_IEEE_8021QAZ_OUI:\n\t\tice_parse_ieee_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tcase ICE_CEE_DCBX_OUI:\n\t\tice_parse_cee_tlv(tlv, dcbcfg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;  \n\t}\n}\n\n \nstatic int ice_lldp_to_dcb_cfg(u8 *lldpmib, struct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_lldp_org_tlv *tlv;\n\tu16 offset = 0;\n\tint ret = 0;\n\tu16 typelen;\n\tu16 type;\n\tu16 len;\n\n\tif (!lldpmib || !dcbcfg)\n\t\treturn -EINVAL;\n\n\t \n\tlldpmib += ETH_HLEN;\n\ttlv = (struct ice_lldp_org_tlv *)lldpmib;\n\twhile (1) {\n\t\ttypelen = ntohs(tlv->typelen);\n\t\ttype = ((typelen & ICE_LLDP_TLV_TYPE_M) >> ICE_LLDP_TLV_TYPE_S);\n\t\tlen = ((typelen & ICE_LLDP_TLV_LEN_M) >> ICE_LLDP_TLV_LEN_S);\n\t\toffset += sizeof(typelen) + len;\n\n\t\t \n\t\tif (type == ICE_TLV_TYPE_END || offset > ICE_LLDPDU_SIZE)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase ICE_TLV_TYPE_ORG:\n\t\t\tice_parse_org_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttlv = (struct ice_lldp_org_tlv *)\n\t\t      ((char *)tlv + sizeof(tlv->typelen) + len);\n\t}\n\n\treturn ret;\n}\n\n \nint\nice_aq_get_dcb_cfg(struct ice_hw *hw, u8 mib_type, u8 bridgetype,\n\t\t   struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 *lldpmib;\n\tint ret;\n\n\t \n\tlldpmib = devm_kzalloc(ice_hw_to_dev(hw), ICE_LLDPDU_SIZE, GFP_KERNEL);\n\tif (!lldpmib)\n\t\treturn -ENOMEM;\n\n\tret = ice_aq_get_lldp_mib(hw, bridgetype, mib_type, (void *)lldpmib,\n\t\t\t\t  ICE_LLDPDU_SIZE, NULL, NULL, NULL);\n\n\tif (!ret)\n\t\t \n\t\tret = ice_lldp_to_dcb_cfg(lldpmib, dcbcfg);\n\n\tdevm_kfree(ice_hw_to_dev(hw), lldpmib);\n\n\treturn ret;\n}\n\n \nint\nice_aq_start_stop_dcbx(struct ice_hw *hw, bool start_dcbx_agent,\n\t\t       bool *dcbx_agent_status, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_lldp_stop_start_specific_agent *cmd;\n\tstruct ice_aq_desc desc;\n\tu16 opcode;\n\tint status;\n\n\tcmd = &desc.params.lldp_agent_ctrl;\n\n\topcode = ice_aqc_opc_lldp_stop_start_specific_agent;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, opcode);\n\n\tif (start_dcbx_agent)\n\t\tcmd->command = ICE_AQC_START_STOP_AGENT_START_DCBX;\n\n\tstatus = ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n\n\t*dcbx_agent_status = false;\n\n\tif (!status &&\n\t    cmd->command == ICE_AQC_START_STOP_AGENT_START_DCBX)\n\t\t*dcbx_agent_status = true;\n\n\treturn status;\n}\n\n \nstatic int\nice_aq_get_cee_dcb_cfg(struct ice_hw *hw,\n\t\t       struct ice_aqc_get_cee_dcb_cfg_resp *buff,\n\t\t       struct ice_sq_cd *cd)\n{\n\tstruct ice_aq_desc desc;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_get_cee_dcb_cfg);\n\n\treturn ice_aq_send_cmd(hw, &desc, (void *)buff, sizeof(*buff), cd);\n}\n\n \nint ice_aq_set_pfc_mode(struct ice_hw *hw, u8 pfc_mode, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_set_query_pfc_mode *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tif (pfc_mode > ICE_AQC_PFC_DSCP_BASED_PFC)\n\t\treturn -EINVAL;\n\n\tcmd = &desc.params.set_query_pfc_mode;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_set_pfc_mode);\n\n\tcmd->pfc_mode = pfc_mode;\n\n\tstatus = ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (cmd->pfc_mode != pfc_mode)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n \nstatic void\nice_cee_to_dcb_cfg(struct ice_aqc_get_cee_dcb_cfg_resp *cee_cfg,\n\t\t   struct ice_port_info *pi)\n{\n\tu32 status, tlv_status = le32_to_cpu(cee_cfg->tlv_status);\n\tu32 ice_aqc_cee_status_mask, ice_aqc_cee_status_shift, j;\n\tu8 i, err, sync, oper, app_index, ice_app_sel_type;\n\tu16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);\n\tu16 ice_aqc_cee_app_mask, ice_aqc_cee_app_shift;\n\tstruct ice_dcbx_cfg *cmp_dcbcfg, *dcbcfg;\n\tu16 ice_app_prot_id_type;\n\n\tdcbcfg = &pi->qos_cfg.local_dcbx_cfg;\n\tdcbcfg->dcbx_mode = ICE_DCBX_MODE_CEE;\n\tdcbcfg->tlv_status = tlv_status;\n\n\t \n\tdcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;\n\n\t \n\tfor (i = 0; i < ICE_MAX_TRAFFIC_CLASS / 2; i++) {\n\t\tdcbcfg->etscfg.prio_table[i * 2] =\n\t\t\t((cee_cfg->oper_prio_tc[i] & ICE_CEE_PGID_PRIO_0_M) >>\n\t\t\t ICE_CEE_PGID_PRIO_0_S);\n\t\tdcbcfg->etscfg.prio_table[i * 2 + 1] =\n\t\t\t((cee_cfg->oper_prio_tc[i] & ICE_CEE_PGID_PRIO_1_M) >>\n\t\t\t ICE_CEE_PGID_PRIO_1_S);\n\t}\n\n\tice_for_each_traffic_class(i) {\n\t\tdcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];\n\n\t\tif (dcbcfg->etscfg.prio_table[i] == ICE_CEE_PGID_STRICT) {\n\t\t\t \n\t\t\tdcbcfg->etscfg.prio_table[i] = cee_cfg->oper_num_tc - 1;\n\t\t\tdcbcfg->etscfg.tsatable[i] = ICE_IEEE_TSA_STRICT;\n\t\t} else {\n\t\t\tdcbcfg->etscfg.tsatable[i] = ICE_IEEE_TSA_ETS;\n\t\t}\n\t}\n\n\t \n\tdcbcfg->pfc.pfcena = cee_cfg->oper_pfc_en;\n\tdcbcfg->pfc.pfccap = ICE_MAX_TRAFFIC_CLASS;\n\n\t \n\tif (dcbcfg->app_mode == ICE_DCBX_APPS_NON_WILLING)\n\t\tcmp_dcbcfg = &pi->qos_cfg.desired_dcbx_cfg;\n\telse\n\t\tcmp_dcbcfg = &pi->qos_cfg.remote_dcbx_cfg;\n\n\tapp_index = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i == 0) {\n\t\t\t \n\t\t\tice_aqc_cee_status_mask = ICE_AQC_CEE_FCOE_STATUS_M;\n\t\t\tice_aqc_cee_status_shift = ICE_AQC_CEE_FCOE_STATUS_S;\n\t\t\tice_aqc_cee_app_mask = ICE_AQC_CEE_APP_FCOE_M;\n\t\t\tice_aqc_cee_app_shift = ICE_AQC_CEE_APP_FCOE_S;\n\t\t\tice_app_sel_type = ICE_APP_SEL_ETHTYPE;\n\t\t\tice_app_prot_id_type = ETH_P_FCOE;\n\t\t} else if (i == 1) {\n\t\t\t \n\t\t\tice_aqc_cee_status_mask = ICE_AQC_CEE_ISCSI_STATUS_M;\n\t\t\tice_aqc_cee_status_shift = ICE_AQC_CEE_ISCSI_STATUS_S;\n\t\t\tice_aqc_cee_app_mask = ICE_AQC_CEE_APP_ISCSI_M;\n\t\t\tice_aqc_cee_app_shift = ICE_AQC_CEE_APP_ISCSI_S;\n\t\t\tice_app_sel_type = ICE_APP_SEL_TCPIP;\n\t\t\tice_app_prot_id_type = ISCSI_LISTEN_PORT;\n\n\t\t\tfor (j = 0; j < cmp_dcbcfg->numapps; j++) {\n\t\t\t\tu16 prot_id = cmp_dcbcfg->app[j].prot_id;\n\t\t\t\tu8 sel = cmp_dcbcfg->app[j].selector;\n\n\t\t\t\tif  (sel == ICE_APP_SEL_TCPIP &&\n\t\t\t\t     (prot_id == ISCSI_LISTEN_PORT ||\n\t\t\t\t      prot_id == ICE_APP_PROT_ID_ISCSI_860)) {\n\t\t\t\t\tice_app_prot_id_type = prot_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tice_aqc_cee_status_mask = ICE_AQC_CEE_FIP_STATUS_M;\n\t\t\tice_aqc_cee_status_shift = ICE_AQC_CEE_FIP_STATUS_S;\n\t\t\tice_aqc_cee_app_mask = ICE_AQC_CEE_APP_FIP_M;\n\t\t\tice_aqc_cee_app_shift = ICE_AQC_CEE_APP_FIP_S;\n\t\t\tice_app_sel_type = ICE_APP_SEL_ETHTYPE;\n\t\t\tice_app_prot_id_type = ETH_P_FIP;\n\t\t}\n\n\t\tstatus = (tlv_status & ice_aqc_cee_status_mask) >>\n\t\t\t ice_aqc_cee_status_shift;\n\t\terr = (status & ICE_TLV_STATUS_ERR) ? 1 : 0;\n\t\tsync = (status & ICE_TLV_STATUS_SYNC) ? 1 : 0;\n\t\toper = (status & ICE_TLV_STATUS_OPER) ? 1 : 0;\n\t\t \n\t\tif (!err && sync && oper) {\n\t\t\tdcbcfg->app[app_index].priority =\n\t\t\t\t(app_prio & ice_aqc_cee_app_mask) >>\n\t\t\t\tice_aqc_cee_app_shift;\n\t\t\tdcbcfg->app[app_index].selector = ice_app_sel_type;\n\t\t\tdcbcfg->app[app_index].prot_id = ice_app_prot_id_type;\n\t\t\tapp_index++;\n\t\t}\n\t}\n\n\tdcbcfg->numapps = app_index;\n}\n\n \nstatic int ice_get_ieee_or_cee_dcb_cfg(struct ice_port_info *pi, u8 dcbx_mode)\n{\n\tstruct ice_dcbx_cfg *dcbx_cfg = NULL;\n\tint ret;\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\n\tif (dcbx_mode == ICE_DCBX_MODE_IEEE)\n\t\tdcbx_cfg = &pi->qos_cfg.local_dcbx_cfg;\n\telse if (dcbx_mode == ICE_DCBX_MODE_CEE)\n\t\tdcbx_cfg = &pi->qos_cfg.desired_dcbx_cfg;\n\n\t \n\tret = ice_aq_get_dcb_cfg(pi->hw, ICE_AQ_LLDP_MIB_LOCAL,\n\t\t\t\t ICE_AQ_LLDP_BRID_TYPE_NEAREST_BRID, dcbx_cfg);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tdcbx_cfg = &pi->qos_cfg.remote_dcbx_cfg;\n\tret = ice_aq_get_dcb_cfg(pi->hw, ICE_AQ_LLDP_MIB_REMOTE,\n\t\t\t\t ICE_AQ_LLDP_BRID_TYPE_NEAREST_BRID, dcbx_cfg);\n\t \n\tif (pi->hw->adminq.sq_last_status == ICE_AQ_RC_ENOENT)\n\t\tret = 0;\n\nout:\n\treturn ret;\n}\n\n \nint ice_get_dcb_cfg(struct ice_port_info *pi)\n{\n\tstruct ice_aqc_get_cee_dcb_cfg_resp cee_cfg;\n\tstruct ice_dcbx_cfg *dcbx_cfg;\n\tint ret;\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\n\tret = ice_aq_get_cee_dcb_cfg(pi->hw, &cee_cfg, NULL);\n\tif (!ret) {\n\t\t \n\t\tret = ice_get_ieee_or_cee_dcb_cfg(pi, ICE_DCBX_MODE_CEE);\n\t\tice_cee_to_dcb_cfg(&cee_cfg, pi);\n\t} else if (pi->hw->adminq.sq_last_status == ICE_AQ_RC_ENOENT) {\n\t\t \n\t\tdcbx_cfg = &pi->qos_cfg.local_dcbx_cfg;\n\t\tdcbx_cfg->dcbx_mode = ICE_DCBX_MODE_IEEE;\n\t\tret = ice_get_ieee_or_cee_dcb_cfg(pi, ICE_DCBX_MODE_IEEE);\n\t}\n\n\treturn ret;\n}\n\n \nvoid ice_get_dcb_cfg_from_mib_change(struct ice_port_info *pi,\n\t\t\t\t     struct ice_rq_event_info *event)\n{\n\tstruct ice_dcbx_cfg *dcbx_cfg = &pi->qos_cfg.local_dcbx_cfg;\n\tstruct ice_aqc_lldp_get_mib *mib;\n\tu8 change_type, dcbx_mode;\n\n\tmib = (struct ice_aqc_lldp_get_mib *)&event->desc.params.raw;\n\n\tchange_type = FIELD_GET(ICE_AQ_LLDP_MIB_TYPE_M,  mib->type);\n\tif (change_type == ICE_AQ_LLDP_MIB_REMOTE)\n\t\tdcbx_cfg = &pi->qos_cfg.remote_dcbx_cfg;\n\n\tdcbx_mode = FIELD_GET(ICE_AQ_LLDP_DCBX_M, mib->type);\n\n\tswitch (dcbx_mode) {\n\tcase ICE_AQ_LLDP_DCBX_IEEE:\n\t\tdcbx_cfg->dcbx_mode = ICE_DCBX_MODE_IEEE;\n\t\tice_lldp_to_dcb_cfg(event->msg_buf, dcbx_cfg);\n\t\tbreak;\n\n\tcase ICE_AQ_LLDP_DCBX_CEE:\n\t\tpi->qos_cfg.desired_dcbx_cfg = pi->qos_cfg.local_dcbx_cfg;\n\t\tice_cee_to_dcb_cfg((struct ice_aqc_get_cee_dcb_cfg_resp *)\n\t\t\t\t   event->msg_buf, pi);\n\t\tbreak;\n\t}\n}\n\n \nint ice_init_dcb(struct ice_hw *hw, bool enable_mib_change)\n{\n\tstruct ice_qos_cfg *qos_cfg = &hw->port_info->qos_cfg;\n\tint ret = 0;\n\n\tif (!hw->func_caps.common_cap.dcb)\n\t\treturn -EOPNOTSUPP;\n\n\tqos_cfg->is_sw_lldp = true;\n\n\t \n\tqos_cfg->dcbx_status = ice_get_dcbx_status(hw);\n\n\tif (qos_cfg->dcbx_status == ICE_DCBX_STATUS_DONE ||\n\t    qos_cfg->dcbx_status == ICE_DCBX_STATUS_IN_PROGRESS ||\n\t    qos_cfg->dcbx_status == ICE_DCBX_STATUS_NOT_STARTED) {\n\t\t \n\t\tret = ice_get_dcb_cfg(hw->port_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tqos_cfg->is_sw_lldp = false;\n\t} else if (qos_cfg->dcbx_status == ICE_DCBX_STATUS_DIS) {\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (enable_mib_change) {\n\t\tret = ice_aq_cfg_lldp_mib_change(hw, true, NULL);\n\t\tif (ret)\n\t\t\tqos_cfg->is_sw_lldp = true;\n\t}\n\n\treturn ret;\n}\n\n \nint ice_cfg_lldp_mib_change(struct ice_hw *hw, bool ena_mib)\n{\n\tstruct ice_qos_cfg *qos_cfg = &hw->port_info->qos_cfg;\n\tint ret;\n\n\tif (!hw->func_caps.common_cap.dcb)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tqos_cfg->dcbx_status = ice_get_dcbx_status(hw);\n\n\tif (qos_cfg->dcbx_status == ICE_DCBX_STATUS_DIS)\n\t\treturn -EBUSY;\n\n\tret = ice_aq_cfg_lldp_mib_change(hw, ena_mib, NULL);\n\tif (!ret)\n\t\tqos_cfg->is_sw_lldp = !ena_mib;\n\n\treturn ret;\n}\n\n \nstatic void\nice_add_ieee_ets_common_tlv(u8 *buf, struct ice_dcb_ets_cfg *ets_cfg)\n{\n\tu8 priority0, priority1;\n\tu8 offset = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < ICE_MAX_TRAFFIC_CLASS / 2; i++) {\n\t\tpriority0 = ets_cfg->prio_table[i * 2] & 0xF;\n\t\tpriority1 = ets_cfg->prio_table[i * 2 + 1] & 0xF;\n\t\tbuf[offset] = (priority0 << ICE_IEEE_ETS_PRIO_1_S) | priority1;\n\t\toffset++;\n\t}\n\n\t \n\tice_for_each_traffic_class(i) {\n\t\tbuf[offset] = ets_cfg->tcbwtable[i];\n\t\tbuf[ICE_MAX_TRAFFIC_CLASS + offset] = ets_cfg->tsatable[i];\n\t\toffset++;\n\t}\n}\n\n \nstatic void\nice_add_ieee_ets_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_dcb_ets_cfg *etscfg;\n\tu8 *buf = tlv->tlvinfo;\n\tu8 maxtcwilling = 0;\n\tu32 ouisubtype;\n\tu16 typelen;\n\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) |\n\t\t   ICE_IEEE_ETS_TLV_LEN);\n\ttlv->typelen = htons(typelen);\n\n\touisubtype = ((ICE_IEEE_8021QAZ_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t      ICE_IEEE_SUBTYPE_ETS_CFG);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\tetscfg = &dcbcfg->etscfg;\n\tif (etscfg->willing)\n\t\tmaxtcwilling = BIT(ICE_IEEE_ETS_WILLING_S);\n\tmaxtcwilling |= etscfg->maxtcs & ICE_IEEE_ETS_MAXTC_M;\n\tbuf[0] = maxtcwilling;\n\n\t \n\tice_add_ieee_ets_common_tlv(&buf[1], etscfg);\n}\n\n \nstatic void\nice_add_ieee_etsrec_tlv(struct ice_lldp_org_tlv *tlv,\n\t\t\tstruct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_dcb_ets_cfg *etsrec;\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\tu16 typelen;\n\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) |\n\t\t   ICE_IEEE_ETS_TLV_LEN);\n\ttlv->typelen = htons(typelen);\n\n\touisubtype = ((ICE_IEEE_8021QAZ_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t      ICE_IEEE_SUBTYPE_ETS_REC);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\tetsrec = &dcbcfg->etsrec;\n\n\t \n\t \n\tice_add_ieee_ets_common_tlv(&buf[1], etsrec);\n}\n\n \nstatic void\nice_add_ieee_pfc_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\tu16 typelen;\n\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) |\n\t\t   ICE_IEEE_PFC_TLV_LEN);\n\ttlv->typelen = htons(typelen);\n\n\touisubtype = ((ICE_IEEE_8021QAZ_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t      ICE_IEEE_SUBTYPE_PFC_CFG);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\tif (dcbcfg->pfc.willing)\n\t\tbuf[0] = BIT(ICE_IEEE_PFC_WILLING_S);\n\n\tif (dcbcfg->pfc.mbc)\n\t\tbuf[0] |= BIT(ICE_IEEE_PFC_MBC_S);\n\n\tbuf[0] |= dcbcfg->pfc.pfccap & 0xF;\n\tbuf[1] = dcbcfg->pfc.pfcena;\n}\n\n \nstatic void\nice_add_ieee_app_pri_tlv(struct ice_lldp_org_tlv *tlv,\n\t\t\t struct ice_dcbx_cfg *dcbcfg)\n{\n\tu16 typelen, len, offset = 0;\n\tu8 priority, selector, i = 0;\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\n\t \n\tif (dcbcfg->numapps == 0)\n\t\treturn;\n\touisubtype = ((ICE_IEEE_8021QAZ_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t      ICE_IEEE_SUBTYPE_APP_PRI);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\toffset++;\n\t \n\twhile (i < dcbcfg->numapps) {\n\t\tpriority = dcbcfg->app[i].priority & 0x7;\n\t\tselector = dcbcfg->app[i].selector & 0x7;\n\t\tbuf[offset] = (priority << ICE_IEEE_APP_PRIO_S) | selector;\n\t\tbuf[offset + 1] = (dcbcfg->app[i].prot_id >> 0x8) & 0xFF;\n\t\tbuf[offset + 2] = dcbcfg->app[i].prot_id & 0xFF;\n\t\t \n\t\toffset += 3;\n\t\ti++;\n\t\tif (i >= ICE_DCBX_MAX_APPS)\n\t\t\tbreak;\n\t}\n\t \n\tlen = sizeof(tlv->ouisubtype) + 1 + (i * 3);\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) | (len & 0x1FF));\n\ttlv->typelen = htons(typelen);\n}\n\n \nstatic void\nice_add_dscp_up_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\tu16 typelen;\n\tint i;\n\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) |\n\t\t   ICE_DSCP_UP_TLV_LEN);\n\ttlv->typelen = htons(typelen);\n\n\touisubtype = (u32)((ICE_DSCP_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t\t   ICE_DSCP_SUBTYPE_DSCP2UP);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\tfor (i = 0; i < ICE_DSCP_NUM_VAL; i++) {\n\t\t \n\t\tbuf[i] = dcbcfg->dscp_map[i];\n\t\t \n\t\tbuf[i + ICE_DSCP_IPV6_OFFSET] = dcbcfg->dscp_map[i];\n\t}\n\n\t \n\tbuf[i] = 0;\n\n\t \n\tbuf[i + ICE_DSCP_IPV6_OFFSET] = 0;\n}\n\n#define ICE_BYTES_PER_TC\t8\n \nstatic void\nice_add_dscp_enf_tlv(struct ice_lldp_org_tlv *tlv)\n{\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\tu16 typelen;\n\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) |\n\t\t   ICE_DSCP_ENF_TLV_LEN);\n\ttlv->typelen = htons(typelen);\n\n\touisubtype = (u32)((ICE_DSCP_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t\t   ICE_DSCP_SUBTYPE_ENFORCE);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\tmemset(buf, 0, 2 * (ICE_MAX_TRAFFIC_CLASS * ICE_BYTES_PER_TC));\n}\n\n \nstatic void\nice_add_dscp_tc_bw_tlv(struct ice_lldp_org_tlv *tlv,\n\t\t       struct ice_dcbx_cfg *dcbcfg)\n{\n\tstruct ice_dcb_ets_cfg *etscfg;\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\tu8 offset = 0;\n\tu16 typelen;\n\tint i;\n\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) |\n\t\t   ICE_DSCP_TC_BW_TLV_LEN);\n\ttlv->typelen = htons(typelen);\n\n\touisubtype = (u32)((ICE_DSCP_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t\t   ICE_DSCP_SUBTYPE_TCBW);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\t \n\tetscfg = &dcbcfg->etscfg;\n\tbuf[0] = etscfg->maxtcs & ICE_IEEE_ETS_MAXTC_M;\n\n\t \n\toffset = 5;\n\n\t \n\tfor (i = 0; i < ICE_MAX_TRAFFIC_CLASS; i++) {\n\t\tbuf[offset] = etscfg->tcbwtable[i];\n\t\tbuf[offset + ICE_MAX_TRAFFIC_CLASS] = etscfg->tsatable[i];\n\t\toffset++;\n\t}\n}\n\n \nstatic void\nice_add_dscp_pfc_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg)\n{\n\tu8 *buf = tlv->tlvinfo;\n\tu32 ouisubtype;\n\tu16 typelen;\n\n\ttypelen = ((ICE_TLV_TYPE_ORG << ICE_LLDP_TLV_TYPE_S) |\n\t\t   ICE_DSCP_PFC_TLV_LEN);\n\ttlv->typelen = htons(typelen);\n\n\touisubtype = (u32)((ICE_DSCP_OUI << ICE_LLDP_TLV_OUI_S) |\n\t\t\t   ICE_DSCP_SUBTYPE_PFC);\n\ttlv->ouisubtype = htonl(ouisubtype);\n\n\tbuf[0] = dcbcfg->pfc.pfccap & 0xF;\n\tbuf[1] = dcbcfg->pfc.pfcena;\n}\n\n \nstatic void\nice_add_dcb_tlv(struct ice_lldp_org_tlv *tlv, struct ice_dcbx_cfg *dcbcfg,\n\t\tu16 tlvid)\n{\n\tif (dcbcfg->pfc_mode == ICE_QOS_MODE_VLAN) {\n\t\tswitch (tlvid) {\n\t\tcase ICE_IEEE_TLV_ID_ETS_CFG:\n\t\t\tice_add_ieee_ets_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase ICE_IEEE_TLV_ID_ETS_REC:\n\t\t\tice_add_ieee_etsrec_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase ICE_IEEE_TLV_ID_PFC_CFG:\n\t\t\tice_add_ieee_pfc_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase ICE_IEEE_TLV_ID_APP_PRI:\n\t\t\tice_add_ieee_app_pri_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (tlvid) {\n\t\tcase ICE_TLV_ID_DSCP_UP:\n\t\t\tice_add_dscp_up_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase ICE_TLV_ID_DSCP_ENF:\n\t\t\tice_add_dscp_enf_tlv(tlv);\n\t\t\tbreak;\n\t\tcase ICE_TLV_ID_DSCP_TC_BW:\n\t\t\tice_add_dscp_tc_bw_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tcase ICE_TLV_ID_DSCP_TO_PFC:\n\t\t\tice_add_dscp_pfc_tlv(tlv, dcbcfg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void\nice_dcb_cfg_to_lldp(u8 *lldpmib, u16 *miblen, struct ice_dcbx_cfg *dcbcfg)\n{\n\tu16 len, offset = 0, tlvid = ICE_TLV_ID_START;\n\tstruct ice_lldp_org_tlv *tlv;\n\tu16 typelen;\n\n\ttlv = (struct ice_lldp_org_tlv *)lldpmib;\n\twhile (1) {\n\t\tice_add_dcb_tlv(tlv, dcbcfg, tlvid++);\n\t\ttypelen = ntohs(tlv->typelen);\n\t\tlen = (typelen & ICE_LLDP_TLV_LEN_M) >> ICE_LLDP_TLV_LEN_S;\n\t\tif (len)\n\t\t\toffset += len + 2;\n\t\t \n\t\tif (tlvid >= ICE_TLV_ID_END_OF_LLDPPDU ||\n\t\t    offset > ICE_LLDPDU_SIZE)\n\t\t\tbreak;\n\t\t \n\t\tif (len)\n\t\t\ttlv = (struct ice_lldp_org_tlv *)\n\t\t\t\t((char *)tlv + sizeof(tlv->typelen) + len);\n\t}\n\t*miblen = offset;\n}\n\n \nint ice_set_dcb_cfg(struct ice_port_info *pi)\n{\n\tu8 mib_type, *lldpmib = NULL;\n\tstruct ice_dcbx_cfg *dcbcfg;\n\tstruct ice_hw *hw;\n\tu16 miblen;\n\tint ret;\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\n\thw = pi->hw;\n\n\t \n\tdcbcfg = &pi->qos_cfg.local_dcbx_cfg;\n\t \n\tlldpmib = devm_kzalloc(ice_hw_to_dev(hw), ICE_LLDPDU_SIZE, GFP_KERNEL);\n\tif (!lldpmib)\n\t\treturn -ENOMEM;\n\n\tmib_type = SET_LOCAL_MIB_TYPE_LOCAL_MIB;\n\tif (dcbcfg->app_mode == ICE_DCBX_APPS_NON_WILLING)\n\t\tmib_type |= SET_LOCAL_MIB_TYPE_CEE_NON_WILLING;\n\n\tice_dcb_cfg_to_lldp(lldpmib, &miblen, dcbcfg);\n\tret = ice_aq_set_lldp_mib(hw, mib_type, (void *)lldpmib, miblen,\n\t\t\t\t  NULL);\n\n\tdevm_kfree(ice_hw_to_dev(hw), lldpmib);\n\n\treturn ret;\n}\n\n \nstatic int\nice_aq_query_port_ets(struct ice_port_info *pi,\n\t\t      struct ice_aqc_port_ets_elem *buf, u16 buf_size,\n\t\t      struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_query_port_ets *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\tcmd = &desc.params.port_ets;\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_query_port_ets);\n\tcmd->port_teid = pi->root->info.node_teid;\n\n\tstatus = ice_aq_send_cmd(pi->hw, &desc, buf, buf_size, cd);\n\treturn status;\n}\n\n \nstatic int\nice_update_port_tc_tree_cfg(struct ice_port_info *pi,\n\t\t\t    struct ice_aqc_port_ets_elem *buf)\n{\n\tstruct ice_sched_node *node, *tc_node;\n\tstruct ice_aqc_txsched_elem_data elem;\n\tu32 teid1, teid2;\n\tint status = 0;\n\tu8 i, j;\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\t \n\tfor (i = 0; i < pi->root->num_children; i++) {\n\t\tteid1 = le32_to_cpu(pi->root->children[i]->info.node_teid);\n\t\tice_for_each_traffic_class(j) {\n\t\t\tteid2 = le32_to_cpu(buf->tc_node_teid[j]);\n\t\t\tif (teid1 == teid2)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j < ICE_MAX_TRAFFIC_CLASS)\n\t\t\tcontinue;\n\t\t \n\t\tpi->root->children[i]->in_use = false;\n\t}\n\t \n\tice_for_each_traffic_class(j) {\n\t\tteid2 = le32_to_cpu(buf->tc_node_teid[j]);\n\t\tif (teid2 == ICE_INVAL_TEID)\n\t\t\tcontinue;\n\t\t \n\t\tfor (i = 0; i < pi->root->num_children; i++) {\n\t\t\ttc_node = pi->root->children[i];\n\t\t\tif (!tc_node)\n\t\t\t\tcontinue;\n\t\t\tteid1 = le32_to_cpu(tc_node->info.node_teid);\n\t\t\tif (teid1 == teid2) {\n\t\t\t\ttc_node->tc_num = j;\n\t\t\t\ttc_node->in_use = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i < pi->root->num_children)\n\t\t\tcontinue;\n\t\t \n\t\tstatus = ice_sched_query_elem(pi->hw, teid2, &elem);\n\t\tif (!status)\n\t\t\tstatus = ice_sched_add_node(pi, 1, &elem, NULL);\n\t\tif (status)\n\t\t\tbreak;\n\t\t \n\t\tnode = ice_sched_find_node_by_teid(pi->root, teid2);\n\t\tif (node)\n\t\t\tnode->tc_num = j;\n\t}\n\treturn status;\n}\n\n \nint\nice_query_port_ets(struct ice_port_info *pi,\n\t\t   struct ice_aqc_port_ets_elem *buf, u16 buf_size,\n\t\t   struct ice_sq_cd *cd)\n{\n\tint status;\n\n\tmutex_lock(&pi->sched_lock);\n\tstatus = ice_aq_query_port_ets(pi, buf, buf_size, cd);\n\tif (!status)\n\t\tstatus = ice_update_port_tc_tree_cfg(pi, buf);\n\tmutex_unlock(&pi->sched_lock);\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}