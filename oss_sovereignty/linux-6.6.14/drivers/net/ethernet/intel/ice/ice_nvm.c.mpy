{
  "module_name": "ice_nvm.c",
  "hash_id": "569cce93a27ecbec2d4986a2020260fbb4510ead5f2f4c8906c18d5ac7888425",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_nvm.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n\n#include \"ice_common.h\"\n\n \nstatic int\nice_aq_read_nvm(struct ice_hw *hw, u16 module_typeid, u32 offset, u16 length,\n\t\tvoid *data, bool last_command, bool read_shadow_ram,\n\t\tstruct ice_sq_cd *cd)\n{\n\tstruct ice_aq_desc desc;\n\tstruct ice_aqc_nvm *cmd;\n\n\tcmd = &desc.params.nvm;\n\n\tif (offset > ICE_AQC_NVM_MAX_OFFSET)\n\t\treturn -EINVAL;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_nvm_read);\n\n\tif (!read_shadow_ram && module_typeid == ICE_AQC_NVM_START_POINT)\n\t\tcmd->cmd_flags |= ICE_AQC_NVM_FLASH_ONLY;\n\n\t \n\tif (last_command)\n\t\tcmd->cmd_flags |= ICE_AQC_NVM_LAST_CMD;\n\tcmd->module_typeid = cpu_to_le16(module_typeid);\n\tcmd->offset_low = cpu_to_le16(offset & 0xFFFF);\n\tcmd->offset_high = (offset >> 16) & 0xFF;\n\tcmd->length = cpu_to_le16(length);\n\n\treturn ice_aq_send_cmd(hw, &desc, data, length, cd);\n}\n\n \nint\nice_read_flat_nvm(struct ice_hw *hw, u32 offset, u32 *length, u8 *data,\n\t\t  bool read_shadow_ram)\n{\n\tu32 inlen = *length;\n\tu32 bytes_read = 0;\n\tbool last_cmd;\n\tint status;\n\n\t*length = 0;\n\n\t \n\tif (read_shadow_ram && ((offset + inlen) > (hw->flash.sr_words * 2u))) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"NVM error: requested offset is beyond Shadow RAM limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tu32 read_size, sector_offset;\n\n\t\t \n\t\tsector_offset = offset % ICE_AQ_MAX_BUF_LEN;\n\t\tread_size = min_t(u32, ICE_AQ_MAX_BUF_LEN - sector_offset,\n\t\t\t\t  inlen - bytes_read);\n\n\t\tlast_cmd = !(bytes_read + read_size < inlen);\n\n\t\tstatus = ice_aq_read_nvm(hw, ICE_AQC_NVM_START_POINT,\n\t\t\t\t\t offset, read_size,\n\t\t\t\t\t data + bytes_read, last_cmd,\n\t\t\t\t\t read_shadow_ram, NULL);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tbytes_read += read_size;\n\t\toffset += read_size;\n\t} while (!last_cmd);\n\n\t*length = bytes_read;\n\treturn status;\n}\n\n \nint\nice_aq_update_nvm(struct ice_hw *hw, u16 module_typeid, u32 offset,\n\t\t  u16 length, void *data, bool last_command, u8 command_flags,\n\t\t  struct ice_sq_cd *cd)\n{\n\tstruct ice_aq_desc desc;\n\tstruct ice_aqc_nvm *cmd;\n\n\tcmd = &desc.params.nvm;\n\n\t \n\tif (offset & 0xFF000000)\n\t\treturn -EINVAL;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_nvm_write);\n\n\tcmd->cmd_flags |= command_flags;\n\n\t \n\tif (last_command)\n\t\tcmd->cmd_flags |= ICE_AQC_NVM_LAST_CMD;\n\tcmd->module_typeid = cpu_to_le16(module_typeid);\n\tcmd->offset_low = cpu_to_le16(offset & 0xFFFF);\n\tcmd->offset_high = (offset >> 16) & 0xFF;\n\tcmd->length = cpu_to_le16(length);\n\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\treturn ice_aq_send_cmd(hw, &desc, data, length, cd);\n}\n\n \nint ice_aq_erase_nvm(struct ice_hw *hw, u16 module_typeid, struct ice_sq_cd *cd)\n{\n\tstruct ice_aq_desc desc;\n\tstruct ice_aqc_nvm *cmd;\n\n\tcmd = &desc.params.nvm;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_nvm_erase);\n\n\tcmd->module_typeid = cpu_to_le16(module_typeid);\n\tcmd->length = cpu_to_le16(ICE_AQC_NVM_ERASE_LEN);\n\tcmd->offset_low = 0;\n\tcmd->offset_high = 0;\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, cd);\n}\n\n \nstatic int ice_read_sr_word_aq(struct ice_hw *hw, u16 offset, u16 *data)\n{\n\tu32 bytes = sizeof(u16);\n\t__le16 data_local;\n\tint status;\n\n\t \n\tstatus = ice_read_flat_nvm(hw, offset * sizeof(u16), &bytes,\n\t\t\t\t   (__force u8 *)&data_local, true);\n\tif (status)\n\t\treturn status;\n\n\t*data = le16_to_cpu(data_local);\n\treturn 0;\n}\n\n \nint ice_acquire_nvm(struct ice_hw *hw, enum ice_aq_res_access_type access)\n{\n\tif (hw->flash.blank_nvm_mode)\n\t\treturn 0;\n\n\treturn ice_acquire_res(hw, ICE_NVM_RES_ID, access, ICE_NVM_TIMEOUT);\n}\n\n \nvoid ice_release_nvm(struct ice_hw *hw)\n{\n\tif (hw->flash.blank_nvm_mode)\n\t\treturn;\n\n\tice_release_res(hw, ICE_NVM_RES_ID);\n}\n\n \nstatic u32 ice_get_flash_bank_offset(struct ice_hw *hw, enum ice_bank_select bank, u16 module)\n{\n\tstruct ice_bank_info *banks = &hw->flash.banks;\n\tenum ice_flash_bank active_bank;\n\tbool second_bank_active;\n\tu32 offset, size;\n\n\tswitch (module) {\n\tcase ICE_SR_1ST_NVM_BANK_PTR:\n\t\toffset = banks->nvm_ptr;\n\t\tsize = banks->nvm_size;\n\t\tactive_bank = banks->nvm_bank;\n\t\tbreak;\n\tcase ICE_SR_1ST_OROM_BANK_PTR:\n\t\toffset = banks->orom_ptr;\n\t\tsize = banks->orom_size;\n\t\tactive_bank = banks->orom_bank;\n\t\tbreak;\n\tcase ICE_SR_NETLIST_BANK_PTR:\n\t\toffset = banks->netlist_ptr;\n\t\tsize = banks->netlist_size;\n\t\tactive_bank = banks->netlist_bank;\n\t\tbreak;\n\tdefault:\n\t\tice_debug(hw, ICE_DBG_NVM, \"Unexpected value for flash module: 0x%04x\\n\", module);\n\t\treturn 0;\n\t}\n\n\tswitch (active_bank) {\n\tcase ICE_1ST_FLASH_BANK:\n\t\tsecond_bank_active = false;\n\t\tbreak;\n\tcase ICE_2ND_FLASH_BANK:\n\t\tsecond_bank_active = true;\n\t\tbreak;\n\tdefault:\n\t\tice_debug(hw, ICE_DBG_NVM, \"Unexpected value for active flash bank: %u\\n\",\n\t\t\t  active_bank);\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (bank) {\n\tcase ICE_ACTIVE_FLASH_BANK:\n\t\treturn offset + (second_bank_active ? size : 0);\n\tcase ICE_INACTIVE_FLASH_BANK:\n\t\treturn offset + (second_bank_active ? 0 : size);\n\t}\n\n\tice_debug(hw, ICE_DBG_NVM, \"Unexpected value for flash bank selection: %u\\n\", bank);\n\treturn 0;\n}\n\n \nstatic int\nice_read_flash_module(struct ice_hw *hw, enum ice_bank_select bank, u16 module,\n\t\t      u32 offset, u8 *data, u32 length)\n{\n\tint status;\n\tu32 start;\n\n\tstart = ice_get_flash_bank_offset(hw, bank, module);\n\tif (!start) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Unable to calculate flash bank offset for module 0x%04x\\n\",\n\t\t\t  module);\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = ice_acquire_nvm(hw, ICE_RES_READ);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ice_read_flat_nvm(hw, start + offset, &length, data, false);\n\n\tice_release_nvm(hw);\n\n\treturn status;\n}\n\n \nstatic int\nice_read_nvm_module(struct ice_hw *hw, enum ice_bank_select bank, u32 offset, u16 *data)\n{\n\t__le16 data_local;\n\tint status;\n\n\tstatus = ice_read_flash_module(hw, bank, ICE_SR_1ST_NVM_BANK_PTR, offset * sizeof(u16),\n\t\t\t\t       (__force u8 *)&data_local, sizeof(u16));\n\tif (!status)\n\t\t*data = le16_to_cpu(data_local);\n\n\treturn status;\n}\n\n \nstatic int\nice_read_nvm_sr_copy(struct ice_hw *hw, enum ice_bank_select bank, u32 offset, u16 *data)\n{\n\treturn ice_read_nvm_module(hw, bank, ICE_NVM_SR_COPY_WORD_OFFSET + offset, data);\n}\n\n \nstatic int\nice_read_netlist_module(struct ice_hw *hw, enum ice_bank_select bank, u32 offset, u16 *data)\n{\n\t__le16 data_local;\n\tint status;\n\n\tstatus = ice_read_flash_module(hw, bank, ICE_SR_NETLIST_BANK_PTR, offset * sizeof(u16),\n\t\t\t\t       (__force u8 *)&data_local, sizeof(u16));\n\tif (!status)\n\t\t*data = le16_to_cpu(data_local);\n\n\treturn status;\n}\n\n \nint ice_read_sr_word(struct ice_hw *hw, u16 offset, u16 *data)\n{\n\tint status;\n\n\tstatus = ice_acquire_nvm(hw, ICE_RES_READ);\n\tif (!status) {\n\t\tstatus = ice_read_sr_word_aq(hw, offset, data);\n\t\tice_release_nvm(hw);\n\t}\n\n\treturn status;\n}\n\n \nint\nice_get_pfa_module_tlv(struct ice_hw *hw, u16 *module_tlv, u16 *module_tlv_len,\n\t\t       u16 module_type)\n{\n\tu16 pfa_len, pfa_ptr;\n\tu16 next_tlv;\n\tint status;\n\n\tstatus = ice_read_sr_word(hw, ICE_SR_PFA_PTR, &pfa_ptr);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Preserved Field Array pointer.\\n\");\n\t\treturn status;\n\t}\n\tstatus = ice_read_sr_word(hw, pfa_ptr, &pfa_len);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read PFA length.\\n\");\n\t\treturn status;\n\t}\n\t \n\tnext_tlv = pfa_ptr + 1;\n\twhile (next_tlv < pfa_ptr + pfa_len) {\n\t\tu16 tlv_sub_module_type;\n\t\tu16 tlv_len;\n\n\t\t \n\t\tstatus = ice_read_sr_word(hw, next_tlv, &tlv_sub_module_type);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read TLV type.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tstatus = ice_read_sr_word(hw, next_tlv + 1, &tlv_len);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read TLV length.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (tlv_sub_module_type == module_type) {\n\t\t\tif (tlv_len) {\n\t\t\t\t*module_tlv = next_tlv;\n\t\t\t\t*module_tlv_len = tlv_len;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tnext_tlv = next_tlv + tlv_len + 2;\n\t}\n\t \n\treturn -ENOENT;\n}\n\n \nint ice_read_pba_string(struct ice_hw *hw, u8 *pba_num, u32 pba_num_size)\n{\n\tu16 pba_tlv, pba_tlv_len;\n\tu16 pba_word, pba_size;\n\tint status;\n\tu16 i;\n\n\tstatus = ice_get_pfa_module_tlv(hw, &pba_tlv, &pba_tlv_len,\n\t\t\t\t\tICE_SR_PBA_BLOCK_PTR);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read PBA Block TLV.\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tstatus = ice_read_sr_word(hw, (pba_tlv + 2), &pba_size);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read PBA Section size.\\n\");\n\t\treturn status;\n\t}\n\n\tif (pba_tlv_len < pba_size) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Invalid PBA Block TLV size.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpba_size--;\n\tif (pba_num_size < (((u32)pba_size * 2) + 1)) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Buffer too small for PBA data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < pba_size; i++) {\n\t\tstatus = ice_read_sr_word(hw, (pba_tlv + 2 + 1) + i, &pba_word);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read PBA Block word %d.\\n\", i);\n\t\t\treturn status;\n\t\t}\n\n\t\tpba_num[(i * 2)] = (pba_word >> 8) & 0xFF;\n\t\tpba_num[(i * 2) + 1] = pba_word & 0xFF;\n\t}\n\tpba_num[(pba_size * 2)] = '\\0';\n\n\treturn status;\n}\n\n \nstatic int\nice_get_nvm_ver_info(struct ice_hw *hw, enum ice_bank_select bank, struct ice_nvm_info *nvm)\n{\n\tu16 eetrack_lo, eetrack_hi, ver;\n\tint status;\n\n\tstatus = ice_read_nvm_sr_copy(hw, bank, ICE_SR_NVM_DEV_STARTER_VER, &ver);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read DEV starter version.\\n\");\n\t\treturn status;\n\t}\n\n\tnvm->major = (ver & ICE_NVM_VER_HI_MASK) >> ICE_NVM_VER_HI_SHIFT;\n\tnvm->minor = (ver & ICE_NVM_VER_LO_MASK) >> ICE_NVM_VER_LO_SHIFT;\n\n\tstatus = ice_read_nvm_sr_copy(hw, bank, ICE_SR_NVM_EETRACK_LO, &eetrack_lo);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read EETRACK lo.\\n\");\n\t\treturn status;\n\t}\n\tstatus = ice_read_nvm_sr_copy(hw, bank, ICE_SR_NVM_EETRACK_HI, &eetrack_hi);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read EETRACK hi.\\n\");\n\t\treturn status;\n\t}\n\n\tnvm->eetrack = (eetrack_hi << 16) | eetrack_lo;\n\n\treturn 0;\n}\n\n \nint ice_get_inactive_nvm_ver(struct ice_hw *hw, struct ice_nvm_info *nvm)\n{\n\treturn ice_get_nvm_ver_info(hw, ICE_INACTIVE_FLASH_BANK, nvm);\n}\n\n \nstatic int\nice_get_orom_civd_data(struct ice_hw *hw, enum ice_bank_select bank,\n\t\t       struct ice_orom_civd_info *civd)\n{\n\tu8 *orom_data;\n\tint status;\n\tu32 offset;\n\n\t \n\torom_data = vzalloc(hw->flash.banks.orom_size);\n\tif (!orom_data)\n\t\treturn -ENOMEM;\n\n\tstatus = ice_read_flash_module(hw, bank, ICE_SR_1ST_OROM_BANK_PTR, 0,\n\t\t\t\t       orom_data, hw->flash.banks.orom_size);\n\tif (status) {\n\t\tvfree(orom_data);\n\t\tice_debug(hw, ICE_DBG_NVM, \"Unable to read Option ROM data\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tfor (offset = 0; (offset + 512) <= hw->flash.banks.orom_size; offset += 512) {\n\t\tstruct ice_orom_civd_info *tmp;\n\t\tu8 sum = 0, i;\n\n\t\ttmp = (struct ice_orom_civd_info *)&orom_data[offset];\n\n\t\t \n\t\tif (memcmp(\"$CIV\", tmp->signature, sizeof(tmp->signature)) != 0)\n\t\t\tcontinue;\n\n\t\tice_debug(hw, ICE_DBG_NVM, \"Found CIVD section at offset %u\\n\",\n\t\t\t  offset);\n\n\t\t \n\t\tfor (i = 0; i < sizeof(*tmp); i++)\n\t\t\tsum += ((u8 *)tmp)[i];\n\n\t\tif (sum) {\n\t\t\tice_debug(hw, ICE_DBG_NVM, \"Found CIVD data with invalid checksum of %u\\n\",\n\t\t\t\t  sum);\n\t\t\tgoto err_invalid_checksum;\n\t\t}\n\n\t\t*civd = *tmp;\n\t\tvfree(orom_data);\n\t\treturn 0;\n\t}\n\n\tice_debug(hw, ICE_DBG_NVM, \"Unable to locate CIVD data within the Option ROM\\n\");\n\nerr_invalid_checksum:\n\tvfree(orom_data);\n\treturn -EIO;\n}\n\n \nstatic int\nice_get_orom_ver_info(struct ice_hw *hw, enum ice_bank_select bank, struct ice_orom_info *orom)\n{\n\tstruct ice_orom_civd_info civd;\n\tu32 combo_ver;\n\tint status;\n\n\tstatus = ice_get_orom_civd_data(hw, bank, &civd);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to locate valid Option ROM CIVD data\\n\");\n\t\treturn status;\n\t}\n\n\tcombo_ver = le32_to_cpu(civd.combo_ver);\n\n\torom->major = (u8)((combo_ver & ICE_OROM_VER_MASK) >> ICE_OROM_VER_SHIFT);\n\torom->patch = (u8)(combo_ver & ICE_OROM_VER_PATCH_MASK);\n\torom->build = (u16)((combo_ver & ICE_OROM_VER_BUILD_MASK) >> ICE_OROM_VER_BUILD_SHIFT);\n\n\treturn 0;\n}\n\n \nint ice_get_inactive_orom_ver(struct ice_hw *hw, struct ice_orom_info *orom)\n{\n\treturn ice_get_orom_ver_info(hw, ICE_INACTIVE_FLASH_BANK, orom);\n}\n\n \nstatic int\nice_get_netlist_info(struct ice_hw *hw, enum ice_bank_select bank,\n\t\t     struct ice_netlist_info *netlist)\n{\n\tu16 module_id, length, node_count, i;\n\tu16 *id_blk;\n\tint status;\n\n\tstatus = ice_read_netlist_module(hw, bank, ICE_NETLIST_TYPE_OFFSET, &module_id);\n\tif (status)\n\t\treturn status;\n\n\tif (module_id != ICE_NETLIST_LINK_TOPO_MOD_ID) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Expected netlist module_id ID of 0x%04x, but got 0x%04x\\n\",\n\t\t\t  ICE_NETLIST_LINK_TOPO_MOD_ID, module_id);\n\t\treturn -EIO;\n\t}\n\n\tstatus = ice_read_netlist_module(hw, bank, ICE_LINK_TOPO_MODULE_LEN, &length);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (length < ICE_NETLIST_ID_BLK_SIZE) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Netlist Link Topology module too small. Expected at least %u words, but got %u words.\\n\",\n\t\t\t  ICE_NETLIST_ID_BLK_SIZE, length);\n\t\treturn -EIO;\n\t}\n\n\tstatus = ice_read_netlist_module(hw, bank, ICE_LINK_TOPO_NODE_COUNT, &node_count);\n\tif (status)\n\t\treturn status;\n\tnode_count &= ICE_LINK_TOPO_NODE_COUNT_M;\n\n\tid_blk = kcalloc(ICE_NETLIST_ID_BLK_SIZE, sizeof(*id_blk), GFP_KERNEL);\n\tif (!id_blk)\n\t\treturn -ENOMEM;\n\n\t \n\tstatus = ice_read_flash_module(hw, bank, ICE_SR_NETLIST_BANK_PTR,\n\t\t\t\t       ICE_NETLIST_ID_BLK_OFFSET(node_count) * sizeof(u16),\n\t\t\t\t       (u8 *)id_blk, ICE_NETLIST_ID_BLK_SIZE * sizeof(u16));\n\tif (status)\n\t\tgoto exit_error;\n\n\tfor (i = 0; i < ICE_NETLIST_ID_BLK_SIZE; i++)\n\t\tid_blk[i] = le16_to_cpu(((__force __le16 *)id_blk)[i]);\n\n\tnetlist->major = id_blk[ICE_NETLIST_ID_BLK_MAJOR_VER_HIGH] << 16 |\n\t\t\t id_blk[ICE_NETLIST_ID_BLK_MAJOR_VER_LOW];\n\tnetlist->minor = id_blk[ICE_NETLIST_ID_BLK_MINOR_VER_HIGH] << 16 |\n\t\t\t id_blk[ICE_NETLIST_ID_BLK_MINOR_VER_LOW];\n\tnetlist->type = id_blk[ICE_NETLIST_ID_BLK_TYPE_HIGH] << 16 |\n\t\t\tid_blk[ICE_NETLIST_ID_BLK_TYPE_LOW];\n\tnetlist->rev = id_blk[ICE_NETLIST_ID_BLK_REV_HIGH] << 16 |\n\t\t       id_blk[ICE_NETLIST_ID_BLK_REV_LOW];\n\tnetlist->cust_ver = id_blk[ICE_NETLIST_ID_BLK_CUST_VER];\n\t \n\tnetlist->hash = id_blk[ICE_NETLIST_ID_BLK_SHA_HASH_WORD(15)] << 16 |\n\t\t\tid_blk[ICE_NETLIST_ID_BLK_SHA_HASH_WORD(14)];\n\nexit_error:\n\tkfree(id_blk);\n\n\treturn status;\n}\n\n \nint ice_get_inactive_netlist_ver(struct ice_hw *hw, struct ice_netlist_info *netlist)\n{\n\treturn ice_get_netlist_info(hw, ICE_INACTIVE_FLASH_BANK, netlist);\n}\n\n \nstatic int ice_discover_flash_size(struct ice_hw *hw)\n{\n\tu32 min_size = 0, max_size = ICE_AQC_NVM_MAX_OFFSET + 1;\n\tint status;\n\n\tstatus = ice_acquire_nvm(hw, ICE_RES_READ);\n\tif (status)\n\t\treturn status;\n\n\twhile ((max_size - min_size) > 1) {\n\t\tu32 offset = (max_size + min_size) / 2;\n\t\tu32 len = 1;\n\t\tu8 data;\n\n\t\tstatus = ice_read_flat_nvm(hw, offset, &len, &data, false);\n\t\tif (status == -EIO &&\n\t\t    hw->adminq.sq_last_status == ICE_AQ_RC_EINVAL) {\n\t\t\tice_debug(hw, ICE_DBG_NVM, \"%s: New upper bound of %u bytes\\n\",\n\t\t\t\t  __func__, offset);\n\t\t\tstatus = 0;\n\t\t\tmax_size = offset;\n\t\t} else if (!status) {\n\t\t\tice_debug(hw, ICE_DBG_NVM, \"%s: New lower bound of %u bytes\\n\",\n\t\t\t\t  __func__, offset);\n\t\t\tmin_size = offset;\n\t\t} else {\n\t\t\t \n\t\t\tgoto err_read_flat_nvm;\n\t\t}\n\t}\n\n\tice_debug(hw, ICE_DBG_NVM, \"Predicted flash size is %u bytes\\n\", max_size);\n\n\thw->flash.flash_size = max_size;\n\nerr_read_flat_nvm:\n\tice_release_nvm(hw);\n\n\treturn status;\n}\n\n \nstatic int ice_read_sr_pointer(struct ice_hw *hw, u16 offset, u32 *pointer)\n{\n\tint status;\n\tu16 value;\n\n\tstatus = ice_read_sr_word(hw, offset, &value);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (value & ICE_SR_NVM_PTR_4KB_UNITS)\n\t\t*pointer = (value & ~ICE_SR_NVM_PTR_4KB_UNITS) * 4 * 1024;\n\telse\n\t\t*pointer = value * 2;\n\n\treturn 0;\n}\n\n \nstatic int ice_read_sr_area_size(struct ice_hw *hw, u16 offset, u32 *size)\n{\n\tint status;\n\tu16 value;\n\n\tstatus = ice_read_sr_word(hw, offset, &value);\n\tif (status)\n\t\treturn status;\n\n\t \n\t*size = value * 4 * 1024;\n\n\treturn 0;\n}\n\n \nstatic int ice_determine_active_flash_banks(struct ice_hw *hw)\n{\n\tstruct ice_bank_info *banks = &hw->flash.banks;\n\tu16 ctrl_word;\n\tint status;\n\n\tstatus = ice_read_sr_word(hw, ICE_SR_NVM_CTRL_WORD, &ctrl_word);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read the Shadow RAM control word\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tif ((ctrl_word & ICE_SR_CTRL_WORD_1_M) >> ICE_SR_CTRL_WORD_1_S != ICE_SR_CTRL_WORD_VALID) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Shadow RAM control word is invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!(ctrl_word & ICE_SR_CTRL_WORD_NVM_BANK))\n\t\tbanks->nvm_bank = ICE_1ST_FLASH_BANK;\n\telse\n\t\tbanks->nvm_bank = ICE_2ND_FLASH_BANK;\n\n\tif (!(ctrl_word & ICE_SR_CTRL_WORD_OROM_BANK))\n\t\tbanks->orom_bank = ICE_1ST_FLASH_BANK;\n\telse\n\t\tbanks->orom_bank = ICE_2ND_FLASH_BANK;\n\n\tif (!(ctrl_word & ICE_SR_CTRL_WORD_NETLIST_BANK))\n\t\tbanks->netlist_bank = ICE_1ST_FLASH_BANK;\n\telse\n\t\tbanks->netlist_bank = ICE_2ND_FLASH_BANK;\n\n\tstatus = ice_read_sr_pointer(hw, ICE_SR_1ST_NVM_BANK_PTR, &banks->nvm_ptr);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read NVM bank pointer\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_read_sr_area_size(hw, ICE_SR_NVM_BANK_SIZE, &banks->nvm_size);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read NVM bank area size\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_read_sr_pointer(hw, ICE_SR_1ST_OROM_BANK_PTR, &banks->orom_ptr);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read OROM bank pointer\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_read_sr_area_size(hw, ICE_SR_OROM_BANK_SIZE, &banks->orom_size);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read OROM bank area size\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_read_sr_pointer(hw, ICE_SR_NETLIST_BANK_PTR, &banks->netlist_ptr);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read Netlist bank pointer\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_read_sr_area_size(hw, ICE_SR_NETLIST_BANK_SIZE, &banks->netlist_size);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to read Netlist bank area size\\n\");\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nint ice_init_nvm(struct ice_hw *hw)\n{\n\tstruct ice_flash_info *flash = &hw->flash;\n\tu32 fla, gens_stat;\n\tu8 sr_size;\n\tint status;\n\n\t \n\tgens_stat = rd32(hw, GLNVM_GENS);\n\tsr_size = (gens_stat & GLNVM_GENS_SR_SIZE_M) >> GLNVM_GENS_SR_SIZE_S;\n\n\t \n\tflash->sr_words = BIT(sr_size) * ICE_SR_WORDS_IN_1KB;\n\n\t \n\tfla = rd32(hw, GLNVM_FLA);\n\tif (fla & GLNVM_FLA_LOCKED_M) {  \n\t\tflash->blank_nvm_mode = false;\n\t} else {\n\t\t \n\t\tflash->blank_nvm_mode = true;\n\t\tice_debug(hw, ICE_DBG_NVM, \"NVM init error: unsupported blank mode.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tstatus = ice_discover_flash_size(hw);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"NVM init error: failed to discover flash size.\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_determine_active_flash_banks(hw);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to determine active flash banks.\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_get_nvm_ver_info(hw, ICE_ACTIVE_FLASH_BANK, &flash->nvm);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read NVM info.\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ice_get_orom_ver_info(hw, ICE_ACTIVE_FLASH_BANK, &flash->orom);\n\tif (status)\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read Option ROM info.\\n\");\n\n\t \n\tstatus = ice_get_netlist_info(hw, ICE_ACTIVE_FLASH_BANK, &flash->netlist);\n\tif (status)\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to read netlist info.\\n\");\n\n\treturn 0;\n}\n\n \nint ice_nvm_validate_checksum(struct ice_hw *hw)\n{\n\tstruct ice_aqc_nvm_checksum *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tstatus = ice_acquire_nvm(hw, ICE_RES_READ);\n\tif (status)\n\t\treturn status;\n\n\tcmd = &desc.params.nvm_checksum;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_nvm_checksum);\n\tcmd->flags = ICE_AQC_NVM_CHECKSUM_VERIFY;\n\n\tstatus = ice_aq_send_cmd(hw, &desc, NULL, 0, NULL);\n\tice_release_nvm(hw);\n\n\tif (!status)\n\t\tif (le16_to_cpu(cmd->checksum) != ICE_AQC_NVM_CHECKSUM_CORRECT)\n\t\t\tstatus = -EIO;\n\n\treturn status;\n}\n\n \nint ice_nvm_write_activate(struct ice_hw *hw, u16 cmd_flags, u8 *response_flags)\n{\n\tstruct ice_aqc_nvm *cmd;\n\tstruct ice_aq_desc desc;\n\tint err;\n\n\tcmd = &desc.params.nvm;\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_nvm_write_activate);\n\n\tcmd->cmd_flags = (u8)(cmd_flags & 0xFF);\n\tcmd->offset_high = (u8)((cmd_flags >> 8) & 0xFF);\n\n\terr = ice_aq_send_cmd(hw, &desc, NULL, 0, NULL);\n\tif (!err && response_flags)\n\t\t*response_flags = cmd->cmd_flags;\n\n\treturn err;\n}\n\n \nint ice_aq_nvm_update_empr(struct ice_hw *hw)\n{\n\tstruct ice_aq_desc desc;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_nvm_update_empr);\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, NULL);\n}\n\n \n\nint\nice_nvm_set_pkg_data(struct ice_hw *hw, bool del_pkg_data_flag, u8 *data,\n\t\t     u16 length, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_nvm_pkg_data *cmd;\n\tstruct ice_aq_desc desc;\n\n\tif (length != 0 && !data)\n\t\treturn -EINVAL;\n\n\tcmd = &desc.params.pkg_data;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_nvm_pkg_data);\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\tif (del_pkg_data_flag)\n\t\tcmd->cmd_flags |= ICE_AQC_NVM_PKG_DELETE;\n\n\treturn ice_aq_send_cmd(hw, &desc, data, length, cd);\n}\n\n \n\nint\nice_nvm_pass_component_tbl(struct ice_hw *hw, u8 *data, u16 length,\n\t\t\t   u8 transfer_flag, u8 *comp_response,\n\t\t\t   u8 *comp_response_code, struct ice_sq_cd *cd)\n{\n\tstruct ice_aqc_nvm_pass_comp_tbl *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\n\tif (!data || !comp_response || !comp_response_code)\n\t\treturn -EINVAL;\n\n\tcmd = &desc.params.pass_comp_tbl;\n\n\tice_fill_dflt_direct_cmd_desc(&desc,\n\t\t\t\t      ice_aqc_opc_nvm_pass_component_tbl);\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\tcmd->transfer_flag = transfer_flag;\n\tstatus = ice_aq_send_cmd(hw, &desc, data, length, cd);\n\n\tif (!status) {\n\t\t*comp_response = cmd->component_response;\n\t\t*comp_response_code = cmd->component_response_code;\n\t}\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}