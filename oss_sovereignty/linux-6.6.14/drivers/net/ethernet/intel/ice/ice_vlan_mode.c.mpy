{
  "module_name": "ice_vlan_mode.c",
  "hash_id": "3dbd15870a63bd91ec47c39bf35537527fd9a84389bdd72a213c3461d35b0bb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_vlan_mode.c",
  "human_readable_source": "\n \n\n#include \"ice_common.h\"\n\n \nstatic int\nice_pkg_get_supported_vlan_mode(struct ice_hw *hw, bool *dvm)\n{\n\tu16 meta_init_size = sizeof(struct ice_meta_init_section);\n\tstruct ice_meta_init_section *sect;\n\tstruct ice_buf_build *bld;\n\tint status;\n\n\t \n\t*dvm = false;\n\n\tbld = ice_pkg_buf_alloc_single_section(hw,\n\t\t\t\t\t       ICE_SID_RXPARSER_METADATA_INIT,\n\t\t\t\t\t       meta_init_size, (void **)&sect);\n\tif (!bld)\n\t\treturn -ENOMEM;\n\n\t \n\tsect->count = cpu_to_le16(1);\n\tsect->offset = cpu_to_le16(ICE_META_VLAN_MODE_ENTRY);\n\n\tstatus = ice_aq_upload_section(hw,\n\t\t\t\t       (struct ice_buf_hdr *)ice_pkg_buf(bld),\n\t\t\t\t       ICE_PKG_BUF_SIZE, NULL);\n\tif (!status) {\n\t\tDECLARE_BITMAP(entry, ICE_META_INIT_BITS);\n\t\tu32 arr[ICE_META_INIT_DW_CNT];\n\t\tu16 i;\n\n\t\t \n\t\tfor (i = 0; i < ICE_META_INIT_DW_CNT; i++)\n\t\t\tarr[i] = le32_to_cpu(sect->entry.bm[i]);\n\n\t\tbitmap_from_arr32(entry, arr, (u16)ICE_META_INIT_BITS);\n\n\t\t \n\t\t*dvm = test_bit(ICE_META_VLAN_MODE_BIT, entry);\n\t}\n\n\tice_pkg_buf_free(hw, bld);\n\n\treturn status;\n}\n\n \nstatic int\nice_aq_get_vlan_mode(struct ice_hw *hw,\n\t\t     struct ice_aqc_get_vlan_mode *get_params)\n{\n\tstruct ice_aq_desc desc;\n\n\tif (!get_params)\n\t\treturn -EINVAL;\n\n\tice_fill_dflt_direct_cmd_desc(&desc,\n\t\t\t\t      ice_aqc_opc_get_vlan_mode_parameters);\n\n\treturn ice_aq_send_cmd(hw, &desc, get_params, sizeof(*get_params),\n\t\t\t       NULL);\n}\n\n \nstatic bool ice_aq_is_dvm_ena(struct ice_hw *hw)\n{\n\tstruct ice_aqc_get_vlan_mode get_params = { 0 };\n\tint status;\n\n\tstatus = ice_aq_get_vlan_mode(hw, &get_params);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_AQ, \"Failed to get VLAN mode, status %d\\n\",\n\t\t\t  status);\n\t\treturn false;\n\t}\n\n\treturn (get_params.vlan_mode & ICE_AQ_VLAN_MODE_DVM_ENA);\n}\n\n \nbool ice_is_dvm_ena(struct ice_hw *hw)\n{\n\treturn hw->dvm_ena;\n}\n\n \nstatic void ice_cache_vlan_mode(struct ice_hw *hw)\n{\n\thw->dvm_ena = ice_aq_is_dvm_ena(hw) ? true : false;\n}\n\n \nstatic bool ice_pkg_supports_dvm(struct ice_hw *hw)\n{\n\tbool pkg_supports_dvm;\n\tint status;\n\n\tstatus = ice_pkg_get_supported_vlan_mode(hw, &pkg_supports_dvm);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_PKG, \"Failed to get supported VLAN mode, status %d\\n\",\n\t\t\t  status);\n\t\treturn false;\n\t}\n\n\treturn pkg_supports_dvm;\n}\n\n \nstatic bool ice_fw_supports_dvm(struct ice_hw *hw)\n{\n\tstruct ice_aqc_get_vlan_mode get_vlan_mode = { 0 };\n\tint status;\n\n\t \n\tstatus = ice_aq_get_vlan_mode(hw, &get_vlan_mode);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_NVM, \"Failed to get VLAN mode, status %d\\n\",\n\t\t\t  status);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool ice_is_dvm_supported(struct ice_hw *hw)\n{\n\tif (!ice_pkg_supports_dvm(hw)) {\n\t\tice_debug(hw, ICE_DBG_PKG, \"DDP doesn't support DVM\\n\");\n\t\treturn false;\n\t}\n\n\tif (!ice_fw_supports_dvm(hw)) {\n\t\tice_debug(hw, ICE_DBG_PKG, \"FW doesn't support DVM\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#define ICE_EXTERNAL_VLAN_ID_FV_IDX\t\t\t11\n#define ICE_SW_LKUP_VLAN_LOC_LKUP_IDX\t\t\t1\n#define ICE_SW_LKUP_VLAN_PKT_FLAGS_LKUP_IDX\t\t2\n#define ICE_SW_LKUP_PROMISC_VLAN_LOC_LKUP_IDX\t\t2\n#define ICE_PKT_FLAGS_0_TO_15_FV_IDX\t\t\t1\nstatic struct ice_update_recipe_lkup_idx_params ice_dvm_dflt_recipes[] = {\n\t{\n\t\t \n\t\t.rid = ICE_SW_LKUP_VLAN,\n\t\t.fv_idx = ICE_EXTERNAL_VLAN_ID_FV_IDX,\n\t\t.ignore_valid = true,\n\t\t.mask = 0,\n\t\t.mask_valid = false,  \n\t\t.lkup_idx = ICE_SW_LKUP_VLAN_LOC_LKUP_IDX,\n\t},\n\t{\n\t\t \n\t\t.rid = ICE_SW_LKUP_VLAN,\n\t\t.fv_idx = ICE_PKT_FLAGS_0_TO_15_FV_IDX,\n\t\t.ignore_valid = false,\n\t\t.mask = ICE_PKT_VLAN_MASK,\n\t\t.mask_valid = true,\n\t\t.lkup_idx = ICE_SW_LKUP_VLAN_PKT_FLAGS_LKUP_IDX,\n\t},\n\t{\n\t\t \n\t\t.rid = ICE_SW_LKUP_PROMISC_VLAN,\n\t\t.fv_idx = ICE_EXTERNAL_VLAN_ID_FV_IDX,\n\t\t.ignore_valid = true,\n\t\t.mask = 0,\n\t\t.mask_valid = false,   \n\t\t.lkup_idx = ICE_SW_LKUP_PROMISC_VLAN_LOC_LKUP_IDX,\n\t},\n};\n\n \nstatic int ice_dvm_update_dflt_recipes(struct ice_hw *hw)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ice_dvm_dflt_recipes); i++) {\n\t\tstruct ice_update_recipe_lkup_idx_params *params;\n\t\tint status;\n\n\t\tparams = &ice_dvm_dflt_recipes[i];\n\n\t\tstatus = ice_update_recipe_lkup_idx(hw, params);\n\t\tif (status) {\n\t\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to update RID %d lkup_idx %d fv_idx %d mask_valid %s mask 0x%04x\\n\",\n\t\t\t\t  params->rid, params->lkup_idx, params->fv_idx,\n\t\t\t\t  params->mask_valid ? \"true\" : \"false\",\n\t\t\t\t  params->mask);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_aq_set_vlan_mode(struct ice_hw *hw,\n\t\t     struct ice_aqc_set_vlan_mode *set_params)\n{\n\tu8 rdma_packet, mng_vlan_prot_id;\n\tstruct ice_aq_desc desc;\n\n\tif (!set_params)\n\t\treturn -EINVAL;\n\n\tif (set_params->l2tag_prio_tagging > ICE_AQ_VLAN_PRIO_TAG_MAX)\n\t\treturn -EINVAL;\n\n\trdma_packet = set_params->rdma_packet;\n\tif (rdma_packet != ICE_AQ_SVM_VLAN_RDMA_PKT_FLAG_SETTING &&\n\t    rdma_packet != ICE_AQ_DVM_VLAN_RDMA_PKT_FLAG_SETTING)\n\t\treturn -EINVAL;\n\n\tmng_vlan_prot_id = set_params->mng_vlan_prot_id;\n\tif (mng_vlan_prot_id != ICE_AQ_VLAN_MNG_PROTOCOL_ID_OUTER &&\n\t    mng_vlan_prot_id != ICE_AQ_VLAN_MNG_PROTOCOL_ID_INNER)\n\t\treturn -EINVAL;\n\n\tice_fill_dflt_direct_cmd_desc(&desc,\n\t\t\t\t      ice_aqc_opc_set_vlan_mode_parameters);\n\tdesc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);\n\n\treturn ice_aq_send_cmd(hw, &desc, set_params, sizeof(*set_params),\n\t\t\t       NULL);\n}\n\n \nstatic int ice_set_dvm(struct ice_hw *hw)\n{\n\tstruct ice_aqc_set_vlan_mode params = { 0 };\n\tint status;\n\n\tparams.l2tag_prio_tagging = ICE_AQ_VLAN_PRIO_TAG_OUTER_CTAG;\n\tparams.rdma_packet = ICE_AQ_DVM_VLAN_RDMA_PKT_FLAG_SETTING;\n\tparams.mng_vlan_prot_id = ICE_AQ_VLAN_MNG_PROTOCOL_ID_OUTER;\n\n\tstatus = ice_aq_set_vlan_mode(hw, &params);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to set double VLAN mode parameters, status %d\\n\",\n\t\t\t  status);\n\t\treturn status;\n\t}\n\n\tstatus = ice_dvm_update_dflt_recipes(hw);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to update default recipes for double VLAN mode, status %d\\n\",\n\t\t\t  status);\n\t\treturn status;\n\t}\n\n\tstatus = ice_aq_set_port_params(hw->port_info, true, NULL);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to set port in double VLAN mode, status %d\\n\",\n\t\t\t  status);\n\t\treturn status;\n\t}\n\n\tstatus = ice_set_dvm_boost_entries(hw);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to set boost TCAM entries for double VLAN mode, status %d\\n\",\n\t\t\t  status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_set_svm(struct ice_hw *hw)\n{\n\tstruct ice_aqc_set_vlan_mode *set_params;\n\tint status;\n\n\tstatus = ice_aq_set_port_params(hw->port_info, false, NULL);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to set port parameters for single VLAN mode\\n\");\n\t\treturn status;\n\t}\n\n\tset_params = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*set_params),\n\t\t\t\t  GFP_KERNEL);\n\tif (!set_params)\n\t\treturn -ENOMEM;\n\n\t \n\tset_params->l2tag_prio_tagging = ICE_AQ_VLAN_PRIO_TAG_INNER_CTAG;\n\tset_params->rdma_packet = ICE_AQ_SVM_VLAN_RDMA_PKT_FLAG_SETTING;\n\tset_params->mng_vlan_prot_id = ICE_AQ_VLAN_MNG_PROTOCOL_ID_INNER;\n\n\tstatus = ice_aq_set_vlan_mode(hw, set_params);\n\tif (status)\n\t\tice_debug(hw, ICE_DBG_INIT, \"Failed to configure port in single VLAN mode\\n\");\n\n\tdevm_kfree(ice_hw_to_dev(hw), set_params);\n\treturn status;\n}\n\n \nint ice_set_vlan_mode(struct ice_hw *hw)\n{\n\tif (!ice_is_dvm_supported(hw))\n\t\treturn 0;\n\n\tif (!ice_set_dvm(hw))\n\t\treturn 0;\n\n\treturn ice_set_svm(hw);\n}\n\n \nstatic void ice_print_dvm_not_supported(struct ice_hw *hw)\n{\n\tbool pkg_supports_dvm = ice_pkg_supports_dvm(hw);\n\tbool fw_supports_dvm = ice_fw_supports_dvm(hw);\n\n\tif (!fw_supports_dvm && !pkg_supports_dvm)\n\t\tdev_info(ice_hw_to_dev(hw), \"QinQ functionality cannot be enabled on this device. Update your DDP package and NVM to versions that support QinQ.\\n\");\n\telse if (!pkg_supports_dvm)\n\t\tdev_info(ice_hw_to_dev(hw), \"QinQ functionality cannot be enabled on this device. Update your DDP package to a version that supports QinQ.\\n\");\n\telse if (!fw_supports_dvm)\n\t\tdev_info(ice_hw_to_dev(hw), \"QinQ functionality cannot be enabled on this device. Update your NVM to a version that supports QinQ.\\n\");\n}\n\n \nvoid ice_post_pkg_dwnld_vlan_mode_cfg(struct ice_hw *hw)\n{\n\tice_cache_vlan_mode(hw);\n\n\tif (ice_is_dvm_ena(hw))\n\t\tice_change_proto_id_to_dvm();\n\telse\n\t\tice_print_dvm_not_supported(hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}