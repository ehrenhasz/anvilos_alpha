{
  "module_name": "ice_ptp.h",
  "hash_id": "766cad38f54bf61d2dfcd0611d6c1da2765ef335b2a199eadd881490271628f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_ptp.h",
  "human_readable_source": " \n \n\n#ifndef _ICE_PTP_H_\n#define _ICE_PTP_H_\n\n#include <linux/ptp_clock_kernel.h>\n#include <linux/kthread.h>\n\n#include \"ice_ptp_hw.h\"\n\nenum ice_ptp_pin_e810 {\n\tGPIO_20 = 0,\n\tGPIO_21,\n\tGPIO_22,\n\tGPIO_23,\n\tNUM_PTP_PIN_E810\n};\n\nenum ice_ptp_pin_e810t {\n\tGNSS = 0,\n\tSMA1,\n\tUFL1,\n\tSMA2,\n\tUFL2,\n\tNUM_PTP_PINS_E810T\n};\n\nstruct ice_perout_channel {\n\tbool ena;\n\tu32 gpio_pin;\n\tu64 period;\n\tu64 start_time;\n};\n\n \n\n \nstruct ice_tx_tstamp {\n\tstruct sk_buff *skb;\n\tunsigned long start;\n\tu64 cached_tstamp;\n};\n\n \nenum ice_tx_tstamp_work {\n\tICE_TX_TSTAMP_WORK_DONE = 0,\n\tICE_TX_TSTAMP_WORK_PENDING,\n};\n\n \nstruct ice_ptp_tx {\n\tspinlock_t lock;  \n\tstruct ice_tx_tstamp *tstamps;\n\tunsigned long *in_use;\n\tunsigned long *stale;\n\tu8 block;\n\tu8 offset;\n\tu8 len;\n\tu8 init : 1;\n\tu8 calibrating : 1;\n\tu8 verify_cached : 1;\n};\n\n \n#define INDEX_PER_QUAD\t\t\t64\n#define INDEX_PER_PORT_E822\t\t16\n#define INDEX_PER_PORT_E810\t\t64\n\n \nstruct ice_ptp_port {\n\tstruct ice_ptp_tx tx;\n\tstruct kthread_delayed_work ov_work;\n\tstruct mutex ps_lock;  \n\tbool link_up;\n\tu8 tx_fifo_busy_cnt;\n\tu8 port_num;\n};\n\n#define GLTSYN_TGT_H_IDX_MAX\t\t4\n\n \nstruct ice_ptp {\n\tstruct ice_ptp_port port;\n\tstruct kthread_delayed_work work;\n\tu64 cached_phc_time;\n\tunsigned long cached_phc_jiffies;\n\tu8 ext_ts_chan;\n\tu8 ext_ts_irq;\n\tstruct kthread_worker *kworker;\n\tstruct ice_perout_channel perout_channels[GLTSYN_TGT_H_IDX_MAX];\n\tstruct ptp_clock_info info;\n\tstruct ptp_clock *clock;\n\tstruct hwtstamp_config tstamp_config;\n\tu64 reset_time;\n\tu32 tx_hwtstamp_skipped;\n\tu32 tx_hwtstamp_timeouts;\n\tu32 tx_hwtstamp_flushed;\n\tu32 tx_hwtstamp_discarded;\n\tu32 late_cached_phc_updates;\n};\n\n#define __ptp_port_to_ptp(p) \\\n\tcontainer_of((p), struct ice_ptp, port)\n#define ptp_port_to_pf(p) \\\n\tcontainer_of(__ptp_port_to_ptp((p)), struct ice_pf, ptp)\n\n#define __ptp_info_to_ptp(i) \\\n\tcontainer_of((i), struct ice_ptp, info)\n#define ptp_info_to_pf(i) \\\n\tcontainer_of(__ptp_info_to_ptp((i)), struct ice_pf, ptp)\n\n#define PFTSYN_SEM_BYTES\t\t4\n#define PTP_SHARED_CLK_IDX_VALID\tBIT(31)\n#define TS_CMD_MASK\t\t\t0xF\n#define SYNC_EXEC_CMD\t\t\t0x3\n#define ICE_PTP_TS_VALID\t\tBIT(0)\n\n#define FIFO_EMPTY\t\t\tBIT(2)\n#define FIFO_OK\t\t\t\t0xFF\n#define ICE_PTP_FIFO_NUM_CHECKS\t\t5\n \n#define GLTSYN_AUX_OUT(_chan, _idx)\t(GLTSYN_AUX_OUT_0(_idx) + ((_chan) * 8))\n#define GLTSYN_AUX_IN(_chan, _idx)\t(GLTSYN_AUX_IN_0(_idx) + ((_chan) * 8))\n#define GLTSYN_CLKO(_chan, _idx)\t(GLTSYN_CLKO_0(_idx) + ((_chan) * 8))\n#define GLTSYN_TGT_L(_chan, _idx)\t(GLTSYN_TGT_L_0(_idx) + ((_chan) * 16))\n#define GLTSYN_TGT_H(_chan, _idx)\t(GLTSYN_TGT_H_0(_idx) + ((_chan) * 16))\n#define GLTSYN_EVNT_L(_chan, _idx)\t(GLTSYN_EVNT_L_0(_idx) + ((_chan) * 16))\n#define GLTSYN_EVNT_H(_chan, _idx)\t(GLTSYN_EVNT_H_0(_idx) + ((_chan) * 16))\n#define GLTSYN_EVNT_H_IDX_MAX\t\t3\n\n \n#define PPS_CLK_GEN_CHAN\t\t3\n#define PPS_CLK_SRC_CHAN\t\t2\n#define PPS_PIN_INDEX\t\t\t5\n#define TIME_SYNC_PIN_INDEX\t\t4\n#define N_EXT_TS_E810\t\t\t3\n#define N_PER_OUT_E810\t\t\t4\n#define N_PER_OUT_E810T\t\t\t3\n#define N_PER_OUT_NO_SMA_E810T\t\t2\n#define N_EXT_TS_NO_SMA_E810T\t\t2\n#define ETH_GLTSYN_ENA(_i)\t\t(0x03000348 + ((_i) * 4))\n\n#if IS_ENABLED(CONFIG_PTP_1588_CLOCK)\nstruct ice_pf;\nint ice_ptp_set_ts_config(struct ice_pf *pf, struct ifreq *ifr);\nint ice_ptp_get_ts_config(struct ice_pf *pf, struct ifreq *ifr);\nvoid ice_ptp_cfg_timestamp(struct ice_pf *pf, bool ena);\nint ice_get_ptp_clock_index(struct ice_pf *pf);\n\nvoid ice_ptp_extts_event(struct ice_pf *pf);\ns8 ice_ptp_request_ts(struct ice_ptp_tx *tx, struct sk_buff *skb);\nenum ice_tx_tstamp_work ice_ptp_process_ts(struct ice_pf *pf);\n\nvoid\nice_ptp_rx_hwtstamp(struct ice_rx_ring *rx_ring,\n\t\t    union ice_32b_rx_flex_desc *rx_desc, struct sk_buff *skb);\nvoid ice_ptp_reset(struct ice_pf *pf);\nvoid ice_ptp_prepare_for_reset(struct ice_pf *pf);\nvoid ice_ptp_init(struct ice_pf *pf);\nvoid ice_ptp_release(struct ice_pf *pf);\nvoid ice_ptp_link_change(struct ice_pf *pf, u8 port, bool linkup);\n#else  \nstatic inline int ice_ptp_set_ts_config(struct ice_pf *pf, struct ifreq *ifr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ice_ptp_get_ts_config(struct ice_pf *pf, struct ifreq *ifr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void ice_ptp_cfg_timestamp(struct ice_pf *pf, bool ena) { }\nstatic inline int ice_get_ptp_clock_index(struct ice_pf *pf)\n{\n\treturn -1;\n}\n\nstatic inline void ice_ptp_extts_event(struct ice_pf *pf) { }\nstatic inline s8\nice_ptp_request_ts(struct ice_ptp_tx *tx, struct sk_buff *skb)\n{\n\treturn -1;\n}\n\nstatic inline bool ice_ptp_process_ts(struct ice_pf *pf)\n{\n\treturn true;\n}\nstatic inline void\nice_ptp_rx_hwtstamp(struct ice_rx_ring *rx_ring,\n\t\t    union ice_32b_rx_flex_desc *rx_desc, struct sk_buff *skb) { }\nstatic inline void ice_ptp_reset(struct ice_pf *pf) { }\nstatic inline void ice_ptp_prepare_for_reset(struct ice_pf *pf) { }\nstatic inline void ice_ptp_init(struct ice_pf *pf) { }\nstatic inline void ice_ptp_release(struct ice_pf *pf) { }\nstatic inline void ice_ptp_link_change(struct ice_pf *pf, u8 port, bool linkup)\n{\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}