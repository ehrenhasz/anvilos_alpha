{
  "module_name": "ice_vf_lib.c",
  "hash_id": "b250df792d09f9a69e899a20634173119f090b2abe812d9090a82168fc5606d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_vf_lib.c",
  "human_readable_source": "\n \n\n#include \"ice_vf_lib_private.h\"\n#include \"ice.h\"\n#include \"ice_lib.h\"\n#include \"ice_fltr.h\"\n#include \"ice_virtchnl_allowlist.h\"\n\n \n\n \nstruct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)\n{\n\tstruct ice_vf *vf;\n\n\trcu_read_lock();\n\thash_for_each_possible_rcu(pf->vfs.table, vf, entry, vf_id) {\n\t\tif (vf->vf_id == vf_id) {\n\t\t\tstruct ice_vf *found;\n\n\t\t\tif (kref_get_unless_zero(&vf->refcnt))\n\t\t\t\tfound = vf;\n\t\t\telse\n\t\t\t\tfound = NULL;\n\n\t\t\trcu_read_unlock();\n\t\t\treturn found;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\n \nstatic void ice_release_vf(struct kref *ref)\n{\n\tstruct ice_vf *vf = container_of(ref, struct ice_vf, refcnt);\n\n\tvf->vf_ops->free(vf);\n}\n\n \nvoid ice_put_vf(struct ice_vf *vf)\n{\n\tkref_put(&vf->refcnt, ice_release_vf);\n}\n\n \nbool ice_has_vfs(struct ice_pf *pf)\n{\n\t \n\treturn !hash_empty(pf->vfs.table);\n}\n\n \nu16 ice_get_num_vfs(struct ice_pf *pf)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\tu16 num_vfs = 0;\n\n\trcu_read_lock();\n\tice_for_each_vf_rcu(pf, bkt, vf)\n\t\tnum_vfs++;\n\trcu_read_unlock();\n\n\treturn num_vfs;\n}\n\n \nstruct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf)\n{\n\tif (vf->lan_vsi_idx == ICE_NO_VSI)\n\t\treturn NULL;\n\n\treturn vf->pf->vsi[vf->lan_vsi_idx];\n}\n\n \nbool ice_is_vf_disabled(struct ice_vf *vf)\n{\n\tstruct ice_pf *pf = vf->pf;\n\n\treturn (test_bit(ICE_VF_DIS, pf->state) ||\n\t\ttest_bit(ICE_VF_STATE_DIS, vf->vf_states));\n}\n\n \nstatic void ice_wait_on_vf_reset(struct ice_vf *vf)\n{\n\tint i;\n\n\tfor (i = 0; i < ICE_MAX_VF_RESET_TRIES; i++) {\n\t\tif (test_bit(ICE_VF_STATE_INIT, vf->vf_states))\n\t\t\tbreak;\n\t\tmsleep(ICE_MAX_VF_RESET_SLEEP_MS);\n\t}\n}\n\n \nint ice_check_vf_ready_for_cfg(struct ice_vf *vf)\n{\n\tice_wait_on_vf_reset(vf);\n\n\tif (ice_is_vf_disabled(vf))\n\t\treturn -EINVAL;\n\n\tif (ice_check_vf_init(vf))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nstatic void ice_trigger_vf_reset(struct ice_vf *vf, bool is_vflr, bool is_pfr)\n{\n\t \n\tclear_bit(ICE_VF_STATE_ACTIVE, vf->vf_states);\n\n\t \n\tclear_bit(ICE_VF_STATE_INIT, vf->vf_states);\n\n\t \n\tif (!is_pfr)\n\t\tvf->vf_ops->clear_mbx_register(vf);\n\n\tvf->vf_ops->trigger_reset_register(vf, is_vflr);\n}\n\nstatic void ice_vf_clear_counters(struct ice_vf *vf)\n{\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\n\tif (vsi)\n\t\tvsi->num_vlan = 0;\n\n\tvf->num_mac = 0;\n\tmemset(&vf->mdd_tx_events, 0, sizeof(vf->mdd_tx_events));\n\tmemset(&vf->mdd_rx_events, 0, sizeof(vf->mdd_rx_events));\n}\n\n \nstatic void ice_vf_pre_vsi_rebuild(struct ice_vf *vf)\n{\n\t \n\tif (vf->vf_ops->irq_close)\n\t\tvf->vf_ops->irq_close(vf);\n\n\tice_vf_clear_counters(vf);\n\tvf->vf_ops->clear_reset_trigger(vf);\n}\n\n \nstatic int ice_vf_recreate_vsi(struct ice_vf *vf)\n{\n\tstruct ice_pf *pf = vf->pf;\n\tint err;\n\n\tice_vf_vsi_release(vf);\n\n\terr = vf->vf_ops->create_vsi(vf);\n\tif (err) {\n\t\tdev_err(ice_pf_to_dev(pf),\n\t\t\t\"Failed to recreate the VF%u's VSI, error %d\\n\",\n\t\t\tvf->vf_id, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_vf_rebuild_vsi(struct ice_vf *vf)\n{\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\tstruct ice_pf *pf = vf->pf;\n\n\tif (WARN_ON(!vsi))\n\t\treturn -EINVAL;\n\n\tif (ice_vsi_rebuild(vsi, ICE_VSI_FLAG_INIT)) {\n\t\tdev_err(ice_pf_to_dev(pf), \"failed to rebuild VF %d VSI\\n\",\n\t\t\tvf->vf_id);\n\t\treturn -EIO;\n\t}\n\t \n\tvsi->vsi_num = ice_get_hw_vsi_num(&pf->hw, vsi->idx);\n\tvf->lan_vsi_num = vsi->vsi_num;\n\n\treturn 0;\n}\n\n \nstatic int ice_vf_rebuild_host_vlan_cfg(struct ice_vf *vf, struct ice_vsi *vsi)\n{\n\tstruct ice_vsi_vlan_ops *vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);\n\tstruct device *dev = ice_pf_to_dev(vf->pf);\n\tint err;\n\n\tif (ice_vf_is_port_vlan_ena(vf)) {\n\t\terr = vlan_ops->set_port_vlan(vsi, &vf->port_vlan_info);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to configure port VLAN via VSI parameters for VF %u, error %d\\n\",\n\t\t\t\tvf->vf_id, err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = vlan_ops->add_vlan(vsi, &vf->port_vlan_info);\n\t} else {\n\t\terr = ice_vsi_add_vlan_zero(vsi);\n\t}\n\n\tif (err) {\n\t\tdev_err(dev, \"failed to add VLAN %u filter for VF %u during VF rebuild, error %d\\n\",\n\t\t\tice_vf_is_port_vlan_ena(vf) ?\n\t\t\tice_vf_get_port_vlan_id(vf) : 0, vf->vf_id, err);\n\t\treturn err;\n\t}\n\n\terr = vlan_ops->ena_rx_filtering(vsi);\n\tif (err)\n\t\tdev_warn(dev, \"failed to enable Rx VLAN filtering for VF %d VSI %d during VF rebuild, error %d\\n\",\n\t\t\t vf->vf_id, vsi->idx, err);\n\n\treturn 0;\n}\n\n \nstatic int ice_vf_rebuild_host_tx_rate_cfg(struct ice_vf *vf)\n{\n\tstruct device *dev = ice_pf_to_dev(vf->pf);\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\tint err;\n\n\tif (WARN_ON(!vsi))\n\t\treturn -EINVAL;\n\n\tif (vf->min_tx_rate) {\n\t\terr = ice_set_min_bw_limit(vsi, (u64)vf->min_tx_rate * 1000);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to set min Tx rate to %d Mbps for VF %u, error %d\\n\",\n\t\t\t\tvf->min_tx_rate, vf->vf_id, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (vf->max_tx_rate) {\n\t\terr = ice_set_max_bw_limit(vsi, (u64)vf->max_tx_rate * 1000);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to set max Tx rate to %d Mbps for VF %u, error %d\\n\",\n\t\t\t\tvf->max_tx_rate, vf->vf_id, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ice_vf_set_host_trust_cfg(struct ice_vf *vf)\n{\n\tassign_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps, vf->trusted);\n}\n\n \nstatic int ice_vf_rebuild_host_mac_cfg(struct ice_vf *vf)\n{\n\tstruct device *dev = ice_pf_to_dev(vf->pf);\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\tu8 broadcast[ETH_ALEN];\n\tint status;\n\n\tif (WARN_ON(!vsi))\n\t\treturn -EINVAL;\n\n\tif (ice_is_eswitch_mode_switchdev(vf->pf))\n\t\treturn 0;\n\n\teth_broadcast_addr(broadcast);\n\tstatus = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);\n\tif (status) {\n\t\tdev_err(dev, \"failed to add broadcast MAC filter for VF %u, error %d\\n\",\n\t\t\tvf->vf_id, status);\n\t\treturn status;\n\t}\n\n\tvf->num_mac++;\n\n\tif (is_valid_ether_addr(vf->hw_lan_addr)) {\n\t\tstatus = ice_fltr_add_mac(vsi, vf->hw_lan_addr,\n\t\t\t\t\t  ICE_FWD_TO_VSI);\n\t\tif (status) {\n\t\t\tdev_err(dev, \"failed to add default unicast MAC filter %pM for VF %u, error %d\\n\",\n\t\t\t\t&vf->hw_lan_addr[0], vf->vf_id,\n\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t\tvf->num_mac++;\n\n\t\tether_addr_copy(vf->dev_lan_addr, vf->hw_lan_addr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ice_vf_rebuild_aggregator_node_cfg(struct ice_vsi *vsi)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct device *dev;\n\tint status;\n\n\tif (!vsi->agg_node)\n\t\treturn;\n\n\tdev = ice_pf_to_dev(pf);\n\tif (vsi->agg_node->num_vsis == ICE_MAX_VSIS_IN_AGG_NODE) {\n\t\tdev_dbg(dev,\n\t\t\t\"agg_id %u already has reached max_num_vsis %u\\n\",\n\t\t\tvsi->agg_node->agg_id, vsi->agg_node->num_vsis);\n\t\treturn;\n\t}\n\n\tstatus = ice_move_vsi_to_agg(pf->hw.port_info, vsi->agg_node->agg_id,\n\t\t\t\t     vsi->idx, vsi->tc_cfg.ena_tc);\n\tif (status)\n\t\tdev_dbg(dev, \"unable to move VSI idx %u into aggregator %u node\",\n\t\t\tvsi->idx, vsi->agg_node->agg_id);\n\telse\n\t\tvsi->agg_node->num_vsis++;\n}\n\n \nstatic void ice_vf_rebuild_host_cfg(struct ice_vf *vf)\n{\n\tstruct device *dev = ice_pf_to_dev(vf->pf);\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\n\tif (WARN_ON(!vsi))\n\t\treturn;\n\n\tice_vf_set_host_trust_cfg(vf);\n\n\tif (ice_vf_rebuild_host_mac_cfg(vf))\n\t\tdev_err(dev, \"failed to rebuild default MAC configuration for VF %d\\n\",\n\t\t\tvf->vf_id);\n\n\tif (ice_vf_rebuild_host_vlan_cfg(vf, vsi))\n\t\tdev_err(dev, \"failed to rebuild VLAN configuration for VF %u\\n\",\n\t\t\tvf->vf_id);\n\n\tif (ice_vf_rebuild_host_tx_rate_cfg(vf))\n\t\tdev_err(dev, \"failed to rebuild Tx rate limiting configuration for VF %u\\n\",\n\t\t\tvf->vf_id);\n\n\tif (ice_vsi_apply_spoofchk(vsi, vf->spoofchk))\n\t\tdev_err(dev, \"failed to rebuild spoofchk configuration for VF %d\\n\",\n\t\t\tvf->vf_id);\n\n\t \n\tice_vf_rebuild_aggregator_node_cfg(vsi);\n}\n\n \nstatic void ice_set_vf_state_qs_dis(struct ice_vf *vf)\n{\n\t \n\tbitmap_zero(vf->txq_ena, ICE_MAX_RSS_QS_PER_VF);\n\tbitmap_zero(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF);\n\tclear_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);\n}\n\n \nstatic void ice_vf_set_initialized(struct ice_vf *vf)\n{\n\tice_set_vf_state_qs_dis(vf);\n\tclear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states);\n\tclear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states);\n\tclear_bit(ICE_VF_STATE_DIS, vf->vf_states);\n\tset_bit(ICE_VF_STATE_INIT, vf->vf_states);\n\tmemset(&vf->vlan_v2_caps, 0, sizeof(vf->vlan_v2_caps));\n}\n\n \nstatic void ice_vf_post_vsi_rebuild(struct ice_vf *vf)\n{\n\tice_vf_rebuild_host_cfg(vf);\n\tice_vf_set_initialized(vf);\n\n\tvf->vf_ops->post_vsi_rebuild(vf);\n}\n\n \nbool ice_is_any_vf_in_unicast_promisc(struct ice_pf *pf)\n{\n\tbool is_vf_promisc = false;\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\trcu_read_lock();\n\tice_for_each_vf_rcu(pf, bkt, vf) {\n\t\t \n\t\tif (test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states)) {\n\t\t\tis_vf_promisc = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn is_vf_promisc;\n}\n\n \nvoid\nice_vf_get_promisc_masks(struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t\t u8 *ucast_m, u8 *mcast_m)\n{\n\tif (ice_vf_is_port_vlan_ena(vf) ||\n\t    ice_vsi_has_non_zero_vlans(vsi)) {\n\t\t*mcast_m = ICE_MCAST_VLAN_PROMISC_BITS;\n\t\t*ucast_m = ICE_UCAST_VLAN_PROMISC_BITS;\n\t} else {\n\t\t*mcast_m = ICE_MCAST_PROMISC_BITS;\n\t\t*ucast_m = ICE_UCAST_PROMISC_BITS;\n\t}\n}\n\n \nstatic int\nice_vf_clear_all_promisc_modes(struct ice_vf *vf, struct ice_vsi *vsi)\n{\n\tstruct ice_pf *pf = vf->pf;\n\tu8 ucast_m, mcast_m;\n\tint ret = 0;\n\n\tice_vf_get_promisc_masks(vf, vsi, &ucast_m, &mcast_m);\n\tif (test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states)) {\n\t\tif (!test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags)) {\n\t\t\tif (ice_is_dflt_vsi_in_use(vsi->port_info))\n\t\t\t\tret = ice_clear_dflt_vsi(vsi);\n\t\t} else {\n\t\t\tret = ice_vf_clear_vsi_promisc(vf, vsi, ucast_m);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_err(ice_pf_to_dev(vf->pf), \"Disabling promiscuous mode failed\\n\");\n\t\t} else {\n\t\t\tclear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states);\n\t\t\tdev_info(ice_pf_to_dev(vf->pf), \"Disabling promiscuous mode succeeded\\n\");\n\t\t}\n\t}\n\n\tif (test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states)) {\n\t\tret = ice_vf_clear_vsi_promisc(vf, vsi, mcast_m);\n\t\tif (ret) {\n\t\t\tdev_err(ice_pf_to_dev(vf->pf), \"Disabling allmulticast mode failed\\n\");\n\t\t} else {\n\t\t\tclear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states);\n\t\t\tdev_info(ice_pf_to_dev(vf->pf), \"Disabling allmulticast mode succeeded\\n\");\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint\nice_vf_set_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)\n{\n\tstruct ice_hw *hw = &vsi->back->hw;\n\tint status;\n\n\tif (ice_vf_is_port_vlan_ena(vf))\n\t\tstatus = ice_fltr_set_vsi_promisc(hw, vsi->idx, promisc_m,\n\t\t\t\t\t\t  ice_vf_get_port_vlan_id(vf));\n\telse if (ice_vsi_has_non_zero_vlans(vsi))\n\t\tstatus = ice_fltr_set_vlan_vsi_promisc(hw, vsi, promisc_m);\n\telse\n\t\tstatus = ice_fltr_set_vsi_promisc(hw, vsi->idx, promisc_m, 0);\n\n\tif (status && status != -EEXIST) {\n\t\tdev_err(ice_pf_to_dev(vsi->back), \"enable Tx/Rx filter promiscuous mode on VF-%u failed, error: %d\\n\",\n\t\t\tvf->vf_id, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nint\nice_vf_clear_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)\n{\n\tstruct ice_hw *hw = &vsi->back->hw;\n\tint status;\n\n\tif (ice_vf_is_port_vlan_ena(vf))\n\t\tstatus = ice_fltr_clear_vsi_promisc(hw, vsi->idx, promisc_m,\n\t\t\t\t\t\t    ice_vf_get_port_vlan_id(vf));\n\telse if (ice_vsi_has_non_zero_vlans(vsi))\n\t\tstatus = ice_fltr_clear_vlan_vsi_promisc(hw, vsi, promisc_m);\n\telse\n\t\tstatus = ice_fltr_clear_vsi_promisc(hw, vsi->idx, promisc_m, 0);\n\n\tif (status && status != -ENOENT) {\n\t\tdev_err(ice_pf_to_dev(vsi->back), \"disable Tx/Rx filter promiscuous mode on VF-%u failed, error: %d\\n\",\n\t\t\tvf->vf_id, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ice_reset_all_vfs(struct ice_pf *pf)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\t \n\tif (!ice_has_vfs(pf))\n\t\treturn;\n\n\tmutex_lock(&pf->vfs.table_lock);\n\n\t \n\tice_for_each_vf(pf, bkt, vf)\n\t\tice_mbx_clear_malvf(&vf->mbx_info);\n\n\t \n\tif (test_and_set_bit(ICE_VF_DIS, pf->state)) {\n\t\tmutex_unlock(&pf->vfs.table_lock);\n\t\treturn;\n\t}\n\n\t \n\tice_for_each_vf(pf, bkt, vf)\n\t\tice_trigger_vf_reset(vf, true, true);\n\n\t \n\tice_for_each_vf(pf, bkt, vf) {\n\t\tif (!vf->vf_ops->poll_reset_status(vf)) {\n\t\t\t \n\t\t\tdev_warn(dev, \"VF %u reset check timeout\\n\", vf->vf_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tice_for_each_vf(pf, bkt, vf) {\n\t\tmutex_lock(&vf->cfg_lock);\n\n\t\tvf->driver_caps = 0;\n\t\tice_vc_set_default_allowlist(vf);\n\n\t\tice_vf_fdir_exit(vf);\n\t\tice_vf_fdir_init(vf);\n\t\t \n\t\tif (vf->ctrl_vsi_idx != ICE_NO_VSI)\n\t\t\tice_vf_ctrl_invalidate_vsi(vf);\n\n\t\tice_vf_pre_vsi_rebuild(vf);\n\t\tice_vf_rebuild_vsi(vf);\n\t\tice_vf_post_vsi_rebuild(vf);\n\n\t\tmutex_unlock(&vf->cfg_lock);\n\t}\n\n\tif (ice_is_eswitch_mode_switchdev(pf))\n\t\tif (ice_eswitch_rebuild(pf))\n\t\t\tdev_warn(dev, \"eswitch rebuild failed\\n\");\n\n\tice_flush(hw);\n\tclear_bit(ICE_VF_DIS, pf->state);\n\n\tmutex_unlock(&pf->vfs.table_lock);\n}\n\n \nstatic void ice_notify_vf_reset(struct ice_vf *vf)\n{\n\tstruct ice_hw *hw = &vf->pf->hw;\n\tstruct virtchnl_pf_event pfe;\n\n\t \n\tif ((!test_bit(ICE_VF_STATE_INIT, vf->vf_states) &&\n\t     !test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) ||\n\t    test_bit(ICE_VF_STATE_DIS, vf->vf_states))\n\t\treturn;\n\n\tpfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;\n\tpfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;\n\tice_aq_send_msg_to_vf(hw, vf->vf_id, VIRTCHNL_OP_EVENT,\n\t\t\t      VIRTCHNL_STATUS_SUCCESS, (u8 *)&pfe, sizeof(pfe),\n\t\t\t      NULL);\n}\n\n \nint ice_reset_vf(struct ice_vf *vf, u32 flags)\n{\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_lag *lag;\n\tstruct ice_vsi *vsi;\n\tu8 act_prt, pri_prt;\n\tstruct device *dev;\n\tint err = 0;\n\tbool rsd;\n\n\tdev = ice_pf_to_dev(pf);\n\tact_prt = ICE_LAG_INVALID_PORT;\n\tpri_prt = pf->hw.port_info->lport;\n\n\tif (flags & ICE_VF_RESET_NOTIFY)\n\t\tice_notify_vf_reset(vf);\n\n\tif (test_bit(ICE_VF_RESETS_DISABLED, pf->state)) {\n\t\tdev_dbg(dev, \"Trying to reset VF %d, but all VF resets are disabled\\n\",\n\t\t\tvf->vf_id);\n\t\treturn 0;\n\t}\n\n\tlag = pf->lag;\n\tmutex_lock(&pf->lag_mutex);\n\tif (lag && lag->bonded && lag->primary) {\n\t\tact_prt = lag->active_port;\n\t\tif (act_prt != pri_prt && act_prt != ICE_LAG_INVALID_PORT &&\n\t\t    lag->upper_netdev)\n\t\t\tice_lag_move_vf_nodes_cfg(lag, act_prt, pri_prt);\n\t\telse\n\t\t\tact_prt = ICE_LAG_INVALID_PORT;\n\t}\n\n\tif (flags & ICE_VF_RESET_LOCK)\n\t\tmutex_lock(&vf->cfg_lock);\n\telse\n\t\tlockdep_assert_held(&vf->cfg_lock);\n\n\tif (ice_is_vf_disabled(vf)) {\n\t\tvsi = ice_get_vf_vsi(vf);\n\t\tif (!vsi) {\n\t\t\tdev_dbg(dev, \"VF is already removed\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tice_vsi_stop_lan_tx_rings(vsi, ICE_NO_RESET, vf->vf_id);\n\n\t\tif (ice_vsi_is_rx_queue_active(vsi))\n\t\t\tice_vsi_stop_all_rx_rings(vsi);\n\n\t\tdev_dbg(dev, \"VF is already disabled, there is no need for resetting it, telling VM, all is fine %d\\n\",\n\t\t\tvf->vf_id);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tset_bit(ICE_VF_STATE_DIS, vf->vf_states);\n\tice_trigger_vf_reset(vf, flags & ICE_VF_RESET_VFLR, false);\n\n\tvsi = ice_get_vf_vsi(vf);\n\tif (WARN_ON(!vsi)) {\n\t\terr = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\tice_dis_vf_qs(vf);\n\n\t \n\tice_dis_vsi_txq(vsi->port_info, vsi->idx, 0, 0, NULL, NULL,\n\t\t\tNULL, vf->vf_ops->reset_type, vf->vf_id, NULL);\n\n\t \n\trsd = vf->vf_ops->poll_reset_status(vf);\n\n\t \n\tif (!rsd)\n\t\tdev_warn(dev, \"VF reset check timeout on VF %d\\n\", vf->vf_id);\n\n\tvf->driver_caps = 0;\n\tice_vc_set_default_allowlist(vf);\n\n\t \n\tice_vf_clear_all_promisc_modes(vf, vsi);\n\n\tice_vf_fdir_exit(vf);\n\tice_vf_fdir_init(vf);\n\t \n\tif (vf->ctrl_vsi_idx != ICE_NO_VSI)\n\t\tice_vf_ctrl_vsi_release(vf);\n\n\tice_vf_pre_vsi_rebuild(vf);\n\n\tif (ice_vf_recreate_vsi(vf)) {\n\t\tdev_err(dev, \"Failed to release and setup the VF%u's VSI\\n\",\n\t\t\tvf->vf_id);\n\t\terr = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tice_vf_post_vsi_rebuild(vf);\n\tvsi = ice_get_vf_vsi(vf);\n\tif (WARN_ON(!vsi)) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tice_eswitch_update_repr(vsi);\n\n\t \n\tice_mbx_clear_malvf(&vf->mbx_info);\n\nout_unlock:\n\tif (flags & ICE_VF_RESET_LOCK)\n\t\tmutex_unlock(&vf->cfg_lock);\n\n\tif (lag && lag->bonded && lag->primary &&\n\t    act_prt != ICE_LAG_INVALID_PORT)\n\t\tice_lag_move_vf_nodes_cfg(lag, pri_prt, act_prt);\n\tmutex_unlock(&pf->lag_mutex);\n\n\treturn err;\n}\n\n \nvoid ice_set_vf_state_dis(struct ice_vf *vf)\n{\n\tice_set_vf_state_qs_dis(vf);\n\tvf->vf_ops->clear_reset_state(vf);\n}\n\n \n\n \nvoid ice_initialize_vf_entry(struct ice_vf *vf)\n{\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_vfs *vfs;\n\n\tvfs = &pf->vfs;\n\n\t \n\tvf->spoofchk = true;\n\tvf->num_vf_qs = vfs->num_qps_per;\n\tice_vc_set_default_allowlist(vf);\n\tice_virtchnl_set_dflt_ops(vf);\n\n\t \n\tice_vf_ctrl_invalidate_vsi(vf);\n\tice_vf_fdir_init(vf);\n\n\t \n\tice_mbx_init_vf_info(&pf->hw, &vf->mbx_info);\n\n\tmutex_init(&vf->cfg_lock);\n}\n\n \nvoid ice_dis_vf_qs(struct ice_vf *vf)\n{\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\n\tif (WARN_ON(!vsi))\n\t\treturn;\n\n\tice_vsi_stop_lan_tx_rings(vsi, ICE_NO_RESET, vf->vf_id);\n\tice_vsi_stop_all_rx_rings(vsi);\n\tice_set_vf_state_qs_dis(vf);\n}\n\n \nenum virtchnl_status_code ice_err_to_virt_err(int err)\n{\n\tswitch (err) {\n\tcase 0:\n\t\treturn VIRTCHNL_STATUS_SUCCESS;\n\tcase -EINVAL:\n\tcase -ENODEV:\n\t\treturn VIRTCHNL_STATUS_ERR_PARAM;\n\tcase -ENOMEM:\n\t\treturn VIRTCHNL_STATUS_ERR_NO_MEMORY;\n\tcase -EALREADY:\n\tcase -EBUSY:\n\tcase -EIO:\n\tcase -ENOSPC:\n\t\treturn VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;\n\tdefault:\n\t\treturn VIRTCHNL_STATUS_ERR_NOT_SUPPORTED;\n\t}\n}\n\n \nint ice_check_vf_init(struct ice_vf *vf)\n{\n\tstruct ice_pf *pf = vf->pf;\n\n\tif (!test_bit(ICE_VF_STATE_INIT, vf->vf_states)) {\n\t\tdev_err(ice_pf_to_dev(pf), \"VF ID: %u in reset. Try again.\\n\",\n\t\t\tvf->vf_id);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\n \nstruct ice_port_info *ice_vf_get_port_info(struct ice_vf *vf)\n{\n\treturn vf->pf->hw.port_info;\n}\n\n \nstatic int ice_cfg_mac_antispoof(struct ice_vsi *vsi, bool enable)\n{\n\tstruct ice_vsi_ctx *ctx;\n\tint err;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->info.sec_flags = vsi->info.sec_flags;\n\tctx->info.valid_sections = cpu_to_le16(ICE_AQ_VSI_PROP_SECURITY_VALID);\n\n\tif (enable)\n\t\tctx->info.sec_flags |= ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF;\n\telse\n\t\tctx->info.sec_flags &= ~ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF;\n\n\terr = ice_update_vsi(&vsi->back->hw, vsi->idx, ctx, NULL);\n\tif (err)\n\t\tdev_err(ice_pf_to_dev(vsi->back), \"Failed to configure Tx MAC anti-spoof %s for VSI %d, error %d\\n\",\n\t\t\tenable ? \"ON\" : \"OFF\", vsi->vsi_num, err);\n\telse\n\t\tvsi->info.sec_flags = ctx->info.sec_flags;\n\n\tkfree(ctx);\n\n\treturn err;\n}\n\n \nstatic int ice_vsi_ena_spoofchk(struct ice_vsi *vsi)\n{\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\tint err = 0;\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(vsi);\n\n\t \n\tif (vsi->type != ICE_VSI_VF || ice_vsi_has_non_zero_vlans(vsi)) {\n\t\terr = vlan_ops->ena_tx_filtering(vsi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn ice_cfg_mac_antispoof(vsi, true);\n}\n\n \nstatic int ice_vsi_dis_spoofchk(struct ice_vsi *vsi)\n{\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\tint err;\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(vsi);\n\n\terr = vlan_ops->dis_tx_filtering(vsi);\n\tif (err)\n\t\treturn err;\n\n\treturn ice_cfg_mac_antispoof(vsi, false);\n}\n\n \nint ice_vsi_apply_spoofchk(struct ice_vsi *vsi, bool enable)\n{\n\tint err;\n\n\tif (enable)\n\t\terr = ice_vsi_ena_spoofchk(vsi);\n\telse\n\t\terr = ice_vsi_dis_spoofchk(vsi);\n\n\treturn err;\n}\n\n \nbool ice_is_vf_trusted(struct ice_vf *vf)\n{\n\treturn test_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);\n}\n\n \nbool ice_vf_has_no_qs_ena(struct ice_vf *vf)\n{\n\treturn (!bitmap_weight(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF) &&\n\t\t!bitmap_weight(vf->txq_ena, ICE_MAX_RSS_QS_PER_VF));\n}\n\n \nbool ice_is_vf_link_up(struct ice_vf *vf)\n{\n\tstruct ice_port_info *pi = ice_vf_get_port_info(vf);\n\n\tif (ice_check_vf_init(vf))\n\t\treturn false;\n\n\tif (ice_vf_has_no_qs_ena(vf))\n\t\treturn false;\n\telse if (vf->link_forced)\n\t\treturn vf->link_up;\n\telse\n\t\treturn pi->phy.link_info.link_info &\n\t\t\tICE_AQ_LINK_UP;\n}\n\n \nvoid ice_vf_ctrl_invalidate_vsi(struct ice_vf *vf)\n{\n\tvf->ctrl_vsi_idx = ICE_NO_VSI;\n}\n\n \nvoid ice_vf_ctrl_vsi_release(struct ice_vf *vf)\n{\n\tice_vsi_release(vf->pf->vsi[vf->ctrl_vsi_idx]);\n\tice_vf_ctrl_invalidate_vsi(vf);\n}\n\n \nstruct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf)\n{\n\tstruct ice_vsi_cfg_params params = {};\n\tstruct ice_pf *pf = vf->pf;\n\tstruct ice_vsi *vsi;\n\n\tparams.type = ICE_VSI_CTRL;\n\tparams.pi = ice_vf_get_port_info(vf);\n\tparams.vf = vf;\n\tparams.flags = ICE_VSI_FLAG_INIT;\n\n\tvsi = ice_vsi_setup(pf, &params);\n\tif (!vsi) {\n\t\tdev_err(ice_pf_to_dev(pf), \"Failed to create VF control VSI\\n\");\n\t\tice_vf_ctrl_invalidate_vsi(vf);\n\t}\n\n\treturn vsi;\n}\n\n \nint ice_vf_init_host_cfg(struct ice_vf *vf, struct ice_vsi *vsi)\n{\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\tstruct ice_pf *pf = vf->pf;\n\tu8 broadcast[ETH_ALEN];\n\tstruct device *dev;\n\tint err;\n\n\tdev = ice_pf_to_dev(pf);\n\n\terr = ice_vsi_add_vlan_zero(vsi);\n\tif (err) {\n\t\tdev_warn(dev, \"Failed to add VLAN 0 filter for VF %d\\n\",\n\t\t\t vf->vf_id);\n\t\treturn err;\n\t}\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(vsi);\n\terr = vlan_ops->ena_rx_filtering(vsi);\n\tif (err) {\n\t\tdev_warn(dev, \"Failed to enable Rx VLAN filtering for VF %d\\n\",\n\t\t\t vf->vf_id);\n\t\treturn err;\n\t}\n\n\teth_broadcast_addr(broadcast);\n\terr = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to add broadcast MAC filter for VF %d, status %d\\n\",\n\t\t\tvf->vf_id, err);\n\t\treturn err;\n\t}\n\n\tvf->num_mac = 1;\n\n\terr = ice_vsi_apply_spoofchk(vsi, vf->spoofchk);\n\tif (err) {\n\t\tdev_warn(dev, \"Failed to initialize spoofchk setting for VF %d\\n\",\n\t\t\t vf->vf_id);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ice_vf_invalidate_vsi(struct ice_vf *vf)\n{\n\tvf->lan_vsi_idx = ICE_NO_VSI;\n\tvf->lan_vsi_num = ICE_NO_VSI;\n}\n\n \nvoid ice_vf_vsi_release(struct ice_vf *vf)\n{\n\tstruct ice_vsi *vsi = ice_get_vf_vsi(vf);\n\n\tif (WARN_ON(!vsi))\n\t\treturn;\n\n\tice_vsi_release(vsi);\n\tice_vf_invalidate_vsi(vf);\n}\n\n \nstruct ice_vsi *ice_get_vf_ctrl_vsi(struct ice_pf *pf, struct ice_vsi *vsi)\n{\n\tstruct ice_vsi *ctrl_vsi = NULL;\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\trcu_read_lock();\n\tice_for_each_vf_rcu(pf, bkt, vf) {\n\t\tif (vf != vsi->vf && vf->ctrl_vsi_idx != ICE_NO_VSI) {\n\t\t\tctrl_vsi = pf->vsi[vf->ctrl_vsi_idx];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ctrl_vsi;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}