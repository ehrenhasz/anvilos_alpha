{
  "module_name": "ice_vf_lib.h",
  "hash_id": "4ec9ce7ab755819bac8852fe94a94570fbfcecf57ec4b938bae9d8ba9d442fdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_vf_lib.h",
  "human_readable_source": " \n \n\n#ifndef _ICE_VF_LIB_H_\n#define _ICE_VF_LIB_H_\n\n#include <linux/types.h>\n#include <linux/hashtable.h>\n#include <linux/bitmap.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <net/devlink.h>\n#include <linux/avf/virtchnl.h>\n#include \"ice_type.h\"\n#include \"ice_virtchnl_fdir.h\"\n#include \"ice_vsi_vlan_ops.h\"\n\n#define ICE_MAX_SRIOV_VFS\t\t256\n\n \n#define ICE_MAX_RSS_QS_PER_VF\t16\n\nstruct ice_pf;\nstruct ice_vf;\nstruct ice_virtchnl_ops;\n\n \nenum ice_virtchnl_cap {\n\tICE_VIRTCHNL_VF_CAP_PRIVILEGE = 0,\n};\n\n \nenum ice_vf_states {\n\tICE_VF_STATE_INIT = 0,\t\t \n\tICE_VF_STATE_ACTIVE,\t\t \n\tICE_VF_STATE_QS_ENA,\t\t \n\tICE_VF_STATE_DIS,\n\tICE_VF_STATE_MC_PROMISC,\n\tICE_VF_STATE_UC_PROMISC,\n\tICE_VF_STATES_NBITS\n};\n\nstruct ice_time_mac {\n\tunsigned long time_modified;\n\tu8 addr[ETH_ALEN];\n};\n\n \nstruct ice_mdd_vf_events {\n\tu16 count;\t\t\t \n\t \n\tu16 last_printed;\n};\n\n \nstruct ice_vf_ops {\n\tenum ice_disq_rst_src reset_type;\n\tvoid (*free)(struct ice_vf *vf);\n\tvoid (*clear_reset_state)(struct ice_vf *vf);\n\tvoid (*clear_mbx_register)(struct ice_vf *vf);\n\tvoid (*trigger_reset_register)(struct ice_vf *vf, bool is_vflr);\n\tbool (*poll_reset_status)(struct ice_vf *vf);\n\tvoid (*clear_reset_trigger)(struct ice_vf *vf);\n\tvoid (*irq_close)(struct ice_vf *vf);\n\tint (*create_vsi)(struct ice_vf *vf);\n\tvoid (*post_vsi_rebuild)(struct ice_vf *vf);\n};\n\n \nstruct ice_vfs {\n\tDECLARE_HASHTABLE(table, 8);\t \n\tstruct mutex table_lock;\t \n\tu16 num_supported;\t\t \n\tu16 num_qps_per;\t\t \n\tu16 num_msix_per;\t\t \n\tunsigned long last_printed_mdd_jiffies;\t \n};\n\n \nstruct ice_vf {\n\tstruct hlist_node entry;\n\tstruct rcu_head rcu;\n\tstruct kref refcnt;\n\tstruct ice_pf *pf;\n\n\t \n\tstruct mutex cfg_lock;\n\n\tu16 vf_id;\t\t\t \n\tu16 lan_vsi_idx;\t\t \n\tu16 ctrl_vsi_idx;\n\tstruct ice_vf_fdir fdir;\n\t \n\tint first_vector_idx;\n\tstruct ice_sw *vf_sw_id;\t \n\tstruct virtchnl_version_info vf_ver;\n\tu32 driver_caps;\t\t \n\tu8 dev_lan_addr[ETH_ALEN];\n\tu8 hw_lan_addr[ETH_ALEN];\n\tstruct ice_time_mac legacy_last_added_umac;\n\tDECLARE_BITMAP(txq_ena, ICE_MAX_RSS_QS_PER_VF);\n\tDECLARE_BITMAP(rxq_ena, ICE_MAX_RSS_QS_PER_VF);\n\tstruct ice_vlan port_vlan_info;\t \n\tstruct virtchnl_vlan_caps vlan_v2_caps;\n\tstruct ice_mbx_vf_info mbx_info;\n\tu8 pf_set_mac:1;\t\t \n\tu8 trusted:1;\n\tu8 spoofchk:1;\n\tu8 link_forced:1;\n\tu8 link_up:1;\t\t\t \n\t \n\tu16 lan_vsi_num;\t\t \n\tunsigned int min_tx_rate;\t \n\tunsigned int max_tx_rate;\t \n\tDECLARE_BITMAP(vf_states, ICE_VF_STATES_NBITS);\t \n\n\tunsigned long vf_caps;\t\t \n\tu8 num_req_qs;\t\t\t \n\tu16 num_mac;\n\tu16 num_vf_qs;\t\t\t \n\tstruct ice_mdd_vf_events mdd_rx_events;\n\tstruct ice_mdd_vf_events mdd_tx_events;\n\tDECLARE_BITMAP(opcodes_allowlist, VIRTCHNL_OP_MAX);\n\n\tstruct ice_repr *repr;\n\tconst struct ice_virtchnl_ops *virtchnl_ops;\n\tconst struct ice_vf_ops *vf_ops;\n\n\t \n\tstruct devlink_port devlink_port;\n};\n\n \nenum ice_vf_reset_flags {\n\tICE_VF_RESET_VFLR = BIT(0),  \n\tICE_VF_RESET_NOTIFY = BIT(1),  \n\tICE_VF_RESET_LOCK = BIT(2),  \n};\n\nstatic inline u16 ice_vf_get_port_vlan_id(struct ice_vf *vf)\n{\n\treturn vf->port_vlan_info.vid;\n}\n\nstatic inline u8 ice_vf_get_port_vlan_prio(struct ice_vf *vf)\n{\n\treturn vf->port_vlan_info.prio;\n}\n\nstatic inline bool ice_vf_is_port_vlan_ena(struct ice_vf *vf)\n{\n\treturn (ice_vf_get_port_vlan_id(vf) || ice_vf_get_port_vlan_prio(vf));\n}\n\nstatic inline u16 ice_vf_get_port_vlan_tpid(struct ice_vf *vf)\n{\n\treturn vf->port_vlan_info.tpid;\n}\n\n \n\n \n#define ice_for_each_vf(pf, bkt, vf) \\\n\thash_for_each((pf)->vfs.table, (bkt), (vf), entry)\n\n \n#define ice_for_each_vf_rcu(pf, bkt, vf) \\\n\thash_for_each_rcu((pf)->vfs.table, (bkt), (vf), entry)\n\n#ifdef CONFIG_PCI_IOV\nstruct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id);\nvoid ice_put_vf(struct ice_vf *vf);\nbool ice_has_vfs(struct ice_pf *pf);\nu16 ice_get_num_vfs(struct ice_pf *pf);\nstruct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf);\nbool ice_is_vf_disabled(struct ice_vf *vf);\nint ice_check_vf_ready_for_cfg(struct ice_vf *vf);\nvoid ice_set_vf_state_dis(struct ice_vf *vf);\nbool ice_is_any_vf_in_unicast_promisc(struct ice_pf *pf);\nvoid\nice_vf_get_promisc_masks(struct ice_vf *vf, struct ice_vsi *vsi,\n\t\t\t u8 *ucast_m, u8 *mcast_m);\nint\nice_vf_set_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m);\nint\nice_vf_clear_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m);\nint ice_reset_vf(struct ice_vf *vf, u32 flags);\nvoid ice_reset_all_vfs(struct ice_pf *pf);\nstruct ice_vsi *ice_get_vf_ctrl_vsi(struct ice_pf *pf, struct ice_vsi *vsi);\n#else  \nstatic inline struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)\n{\n\treturn NULL;\n}\n\nstatic inline void ice_put_vf(struct ice_vf *vf)\n{\n}\n\nstatic inline bool ice_has_vfs(struct ice_pf *pf)\n{\n\treturn false;\n}\n\nstatic inline u16 ice_get_num_vfs(struct ice_pf *pf)\n{\n\treturn 0;\n}\n\nstatic inline struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf)\n{\n\treturn NULL;\n}\n\nstatic inline bool ice_is_vf_disabled(struct ice_vf *vf)\n{\n\treturn true;\n}\n\nstatic inline int ice_check_vf_ready_for_cfg(struct ice_vf *vf)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void ice_set_vf_state_dis(struct ice_vf *vf)\n{\n}\n\nstatic inline bool ice_is_any_vf_in_unicast_promisc(struct ice_pf *pf)\n{\n\treturn false;\n}\n\nstatic inline int\nice_vf_set_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int\nice_vf_clear_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ice_reset_vf(struct ice_vf *vf, u32 flags)\n{\n\treturn 0;\n}\n\nstatic inline void ice_reset_all_vfs(struct ice_pf *pf)\n{\n}\n\nstatic inline struct ice_vsi *\nice_get_vf_ctrl_vsi(struct ice_pf *pf, struct ice_vsi *vsi)\n{\n\treturn NULL;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}