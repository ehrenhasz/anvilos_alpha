{
  "module_name": "ice_ptp_hw.c",
  "hash_id": "2e7c50cdb5bd79ffdd1bcecc560ebc5a654d8e8f525288321b9808f162d3f70b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_ptp_hw.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include \"ice_common.h\"\n#include \"ice_ptp_hw.h\"\n#include \"ice_ptp_consts.h\"\n#include \"ice_cgu_regs.h\"\n\n \n\n \nu8 ice_get_ptp_src_clock_index(struct ice_hw *hw)\n{\n\treturn hw->func_caps.ts_func_info.tmr_index_assoc;\n}\n\n \nstatic u64 ice_ptp_read_src_incval(struct ice_hw *hw)\n{\n\tu32 lo, hi;\n\tu8 tmr_idx;\n\n\ttmr_idx = ice_get_ptp_src_clock_index(hw);\n\n\tlo = rd32(hw, GLTSYN_INCVAL_L(tmr_idx));\n\thi = rd32(hw, GLTSYN_INCVAL_H(tmr_idx));\n\n\treturn ((u64)(hi & INCVAL_HIGH_M) << 32) | lo;\n}\n\n \nstatic void ice_ptp_src_cmd(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)\n{\n\tu32 cmd_val;\n\tu8 tmr_idx;\n\n\ttmr_idx = ice_get_ptp_src_clock_index(hw);\n\tcmd_val = tmr_idx << SEL_CPK_SRC;\n\n\tswitch (cmd) {\n\tcase INIT_TIME:\n\t\tcmd_val |= GLTSYN_CMD_INIT_TIME;\n\t\tbreak;\n\tcase INIT_INCVAL:\n\t\tcmd_val |= GLTSYN_CMD_INIT_INCVAL;\n\t\tbreak;\n\tcase ADJ_TIME:\n\t\tcmd_val |= GLTSYN_CMD_ADJ_TIME;\n\t\tbreak;\n\tcase ADJ_TIME_AT_TIME:\n\t\tcmd_val |= GLTSYN_CMD_ADJ_INIT_TIME;\n\t\tbreak;\n\tcase READ_TIME:\n\t\tcmd_val |= GLTSYN_CMD_READ_TIME;\n\t\tbreak;\n\tcase ICE_PTP_NOP:\n\t\tbreak;\n\t}\n\n\twr32(hw, GLTSYN_CMD, cmd_val);\n}\n\n \nstatic void ice_ptp_exec_tmr_cmd(struct ice_hw *hw)\n{\n\twr32(hw, GLTSYN_CMD_SYNC, SYNC_EXEC_CMD);\n\tice_flush(hw);\n}\n\n \n\n \nstatic void\nice_fill_phy_msg_e822(struct ice_sbq_msg_input *msg, u8 port, u16 offset)\n{\n\tint phy_port, phy, quadtype;\n\n\tphy_port = port % ICE_PORTS_PER_PHY;\n\tphy = port / ICE_PORTS_PER_PHY;\n\tquadtype = (port / ICE_PORTS_PER_QUAD) % ICE_NUM_QUAD_TYPE;\n\n\tif (quadtype == 0) {\n\t\tmsg->msg_addr_low = P_Q0_L(P_0_BASE + offset, phy_port);\n\t\tmsg->msg_addr_high = P_Q0_H(P_0_BASE + offset, phy_port);\n\t} else {\n\t\tmsg->msg_addr_low = P_Q1_L(P_4_BASE + offset, phy_port);\n\t\tmsg->msg_addr_high = P_Q1_H(P_4_BASE + offset, phy_port);\n\t}\n\n\tif (phy == 0)\n\t\tmsg->dest_dev = rmn_0;\n\telse if (phy == 1)\n\t\tmsg->dest_dev = rmn_1;\n\telse\n\t\tmsg->dest_dev = rmn_2;\n}\n\n \nstatic bool ice_is_64b_phy_reg_e822(u16 low_addr, u16 *high_addr)\n{\n\tswitch (low_addr) {\n\tcase P_REG_PAR_PCS_TX_OFFSET_L:\n\t\t*high_addr = P_REG_PAR_PCS_TX_OFFSET_U;\n\t\treturn true;\n\tcase P_REG_PAR_PCS_RX_OFFSET_L:\n\t\t*high_addr = P_REG_PAR_PCS_RX_OFFSET_U;\n\t\treturn true;\n\tcase P_REG_PAR_TX_TIME_L:\n\t\t*high_addr = P_REG_PAR_TX_TIME_U;\n\t\treturn true;\n\tcase P_REG_PAR_RX_TIME_L:\n\t\t*high_addr = P_REG_PAR_RX_TIME_U;\n\t\treturn true;\n\tcase P_REG_TOTAL_TX_OFFSET_L:\n\t\t*high_addr = P_REG_TOTAL_TX_OFFSET_U;\n\t\treturn true;\n\tcase P_REG_TOTAL_RX_OFFSET_L:\n\t\t*high_addr = P_REG_TOTAL_RX_OFFSET_U;\n\t\treturn true;\n\tcase P_REG_UIX66_10G_40G_L:\n\t\t*high_addr = P_REG_UIX66_10G_40G_U;\n\t\treturn true;\n\tcase P_REG_UIX66_25G_100G_L:\n\t\t*high_addr = P_REG_UIX66_25G_100G_U;\n\t\treturn true;\n\tcase P_REG_TX_CAPTURE_L:\n\t\t*high_addr = P_REG_TX_CAPTURE_U;\n\t\treturn true;\n\tcase P_REG_RX_CAPTURE_L:\n\t\t*high_addr = P_REG_RX_CAPTURE_U;\n\t\treturn true;\n\tcase P_REG_TX_TIMER_INC_PRE_L:\n\t\t*high_addr = P_REG_TX_TIMER_INC_PRE_U;\n\t\treturn true;\n\tcase P_REG_RX_TIMER_INC_PRE_L:\n\t\t*high_addr = P_REG_RX_TIMER_INC_PRE_U;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic bool ice_is_40b_phy_reg_e822(u16 low_addr, u16 *high_addr)\n{\n\tswitch (low_addr) {\n\tcase P_REG_TIMETUS_L:\n\t\t*high_addr = P_REG_TIMETUS_U;\n\t\treturn true;\n\tcase P_REG_PAR_RX_TUS_L:\n\t\t*high_addr = P_REG_PAR_RX_TUS_U;\n\t\treturn true;\n\tcase P_REG_PAR_TX_TUS_L:\n\t\t*high_addr = P_REG_PAR_TX_TUS_U;\n\t\treturn true;\n\tcase P_REG_PCS_RX_TUS_L:\n\t\t*high_addr = P_REG_PCS_RX_TUS_U;\n\t\treturn true;\n\tcase P_REG_PCS_TX_TUS_L:\n\t\t*high_addr = P_REG_PCS_TX_TUS_U;\n\t\treturn true;\n\tcase P_REG_DESK_PAR_RX_TUS_L:\n\t\t*high_addr = P_REG_DESK_PAR_RX_TUS_U;\n\t\treturn true;\n\tcase P_REG_DESK_PAR_TX_TUS_L:\n\t\t*high_addr = P_REG_DESK_PAR_TX_TUS_U;\n\t\treturn true;\n\tcase P_REG_DESK_PCS_RX_TUS_L:\n\t\t*high_addr = P_REG_DESK_PCS_RX_TUS_U;\n\t\treturn true;\n\tcase P_REG_DESK_PCS_TX_TUS_L:\n\t\t*high_addr = P_REG_DESK_PCS_TX_TUS_U;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int\nice_read_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 *val)\n{\n\tstruct ice_sbq_msg_input msg = {0};\n\tint err;\n\n\tice_fill_phy_msg_e822(&msg, port, offset);\n\tmsg.opcode = ice_sbq_msg_rd;\n\n\terr = ice_sbq_rw_reg(hw, &msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to send message to PHY, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t*val = msg.data;\n\n\treturn 0;\n}\n\n \nstatic int\nice_read_64b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 *val)\n{\n\tu32 low, high;\n\tu16 high_addr;\n\tint err;\n\n\t \n\tif (!ice_is_64b_phy_reg_e822(low_addr, &high_addr)) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Invalid 64b register addr 0x%08x\\n\",\n\t\t\t  low_addr);\n\t\treturn -EINVAL;\n\t}\n\n\terr = ice_read_phy_reg_e822(hw, port, low_addr, &low);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read from low register 0x%08x\\n, err %d\",\n\t\t\t  low_addr, err);\n\t\treturn err;\n\t}\n\n\terr = ice_read_phy_reg_e822(hw, port, high_addr, &high);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read from high register 0x%08x\\n, err %d\",\n\t\t\t  high_addr, err);\n\t\treturn err;\n\t}\n\n\t*val = (u64)high << 32 | low;\n\n\treturn 0;\n}\n\n \nstatic int\nice_write_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 val)\n{\n\tstruct ice_sbq_msg_input msg = {0};\n\tint err;\n\n\tice_fill_phy_msg_e822(&msg, port, offset);\n\tmsg.opcode = ice_sbq_msg_wr;\n\tmsg.data = val;\n\n\terr = ice_sbq_rw_reg(hw, &msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to send message to PHY, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_write_40b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 val)\n{\n\tu32 low, high;\n\tu16 high_addr;\n\tint err;\n\n\t \n\tif (!ice_is_40b_phy_reg_e822(low_addr, &high_addr)) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Invalid 40b register addr 0x%08x\\n\",\n\t\t\t  low_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tlow = (u32)(val & P_REG_40B_LOW_M);\n\thigh = (u32)(val >> P_REG_40B_HIGH_S);\n\n\terr = ice_write_phy_reg_e822(hw, port, low_addr, low);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write to low register 0x%08x\\n, err %d\",\n\t\t\t  low_addr, err);\n\t\treturn err;\n\t}\n\n\terr = ice_write_phy_reg_e822(hw, port, high_addr, high);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write to high register 0x%08x\\n, err %d\",\n\t\t\t  high_addr, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_write_64b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 val)\n{\n\tu32 low, high;\n\tu16 high_addr;\n\tint err;\n\n\t \n\tif (!ice_is_64b_phy_reg_e822(low_addr, &high_addr)) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Invalid 64b register addr 0x%08x\\n\",\n\t\t\t  low_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tlow = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\terr = ice_write_phy_reg_e822(hw, port, low_addr, low);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write to low register 0x%08x\\n, err %d\",\n\t\t\t  low_addr, err);\n\t\treturn err;\n\t}\n\n\terr = ice_write_phy_reg_e822(hw, port, high_addr, high);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write to high register 0x%08x\\n, err %d\",\n\t\t\t  high_addr, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nice_fill_quad_msg_e822(struct ice_sbq_msg_input *msg, u8 quad, u16 offset)\n{\n\tu32 addr;\n\n\tmsg->dest_dev = rmn_0;\n\n\tif ((quad % ICE_NUM_QUAD_TYPE) == 0)\n\t\taddr = Q_0_BASE + offset;\n\telse\n\t\taddr = Q_1_BASE + offset;\n\n\tmsg->msg_addr_low = lower_16_bits(addr);\n\tmsg->msg_addr_high = upper_16_bits(addr);\n}\n\n \nint\nice_read_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 *val)\n{\n\tstruct ice_sbq_msg_input msg = {0};\n\tint err;\n\n\tif (quad >= ICE_MAX_QUAD)\n\t\treturn -EINVAL;\n\n\tice_fill_quad_msg_e822(&msg, quad, offset);\n\tmsg.opcode = ice_sbq_msg_rd;\n\n\terr = ice_sbq_rw_reg(hw, &msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to send message to PHY, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t*val = msg.data;\n\n\treturn 0;\n}\n\n \nint\nice_write_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 val)\n{\n\tstruct ice_sbq_msg_input msg = {0};\n\tint err;\n\n\tif (quad >= ICE_MAX_QUAD)\n\t\treturn -EINVAL;\n\n\tice_fill_quad_msg_e822(&msg, quad, offset);\n\tmsg.opcode = ice_sbq_msg_wr;\n\tmsg.data = val;\n\n\terr = ice_sbq_rw_reg(hw, &msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to send message to PHY, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_read_phy_tstamp_e822(struct ice_hw *hw, u8 quad, u8 idx, u64 *tstamp)\n{\n\tu16 lo_addr, hi_addr;\n\tu32 lo, hi;\n\tint err;\n\n\tlo_addr = (u16)TS_L(Q_REG_TX_MEMORY_BANK_START, idx);\n\thi_addr = (u16)TS_H(Q_REG_TX_MEMORY_BANK_START, idx);\n\n\terr = ice_read_quad_reg_e822(hw, quad, lo_addr, &lo);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read low PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\terr = ice_read_quad_reg_e822(hw, quad, hi_addr, &hi);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read high PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t \n\t*tstamp = ((u64)hi) << TS_PHY_HIGH_S | ((u64)lo & TS_PHY_LOW_M);\n\n\treturn 0;\n}\n\n \nstatic int\nice_clear_phy_tstamp_e822(struct ice_hw *hw, u8 quad, u8 idx)\n{\n\tu16 lo_addr, hi_addr;\n\tint err;\n\n\tlo_addr = (u16)TS_L(Q_REG_TX_MEMORY_BANK_START, idx);\n\thi_addr = (u16)TS_H(Q_REG_TX_MEMORY_BANK_START, idx);\n\n\terr = ice_write_quad_reg_e822(hw, quad, lo_addr, 0);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to clear low PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\terr = ice_write_quad_reg_e822(hw, quad, hi_addr, 0);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to clear high PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ice_ptp_reset_ts_memory_quad_e822(struct ice_hw *hw, u8 quad)\n{\n\tice_write_quad_reg_e822(hw, quad, Q_REG_TS_CTRL, Q_REG_TS_CTRL_M);\n\tice_write_quad_reg_e822(hw, quad, Q_REG_TS_CTRL, ~(u32)Q_REG_TS_CTRL_M);\n}\n\n \nstatic void ice_ptp_reset_ts_memory_e822(struct ice_hw *hw)\n{\n\tunsigned int quad;\n\n\tfor (quad = 0; quad < ICE_MAX_QUAD; quad++)\n\t\tice_ptp_reset_ts_memory_quad_e822(hw, quad);\n}\n\n \nstatic int\nice_read_cgu_reg_e822(struct ice_hw *hw, u32 addr, u32 *val)\n{\n\tstruct ice_sbq_msg_input cgu_msg;\n\tint err;\n\n\tcgu_msg.opcode = ice_sbq_msg_rd;\n\tcgu_msg.dest_dev = cgu;\n\tcgu_msg.msg_addr_low = addr;\n\tcgu_msg.msg_addr_high = 0x0;\n\n\terr = ice_sbq_rw_reg(hw, &cgu_msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read CGU register 0x%04x, err %d\\n\",\n\t\t\t  addr, err);\n\t\treturn err;\n\t}\n\n\t*val = cgu_msg.data;\n\n\treturn err;\n}\n\n \nstatic int\nice_write_cgu_reg_e822(struct ice_hw *hw, u32 addr, u32 val)\n{\n\tstruct ice_sbq_msg_input cgu_msg;\n\tint err;\n\n\tcgu_msg.opcode = ice_sbq_msg_wr;\n\tcgu_msg.dest_dev = cgu;\n\tcgu_msg.msg_addr_low = addr;\n\tcgu_msg.msg_addr_high = 0x0;\n\tcgu_msg.data = val;\n\n\terr = ice_sbq_rw_reg(hw, &cgu_msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write CGU register 0x%04x, err %d\\n\",\n\t\t\t  addr, err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n \nstatic const char *ice_clk_freq_str(u8 clk_freq)\n{\n\tswitch ((enum ice_time_ref_freq)clk_freq) {\n\tcase ICE_TIME_REF_FREQ_25_000:\n\t\treturn \"25 MHz\";\n\tcase ICE_TIME_REF_FREQ_122_880:\n\t\treturn \"122.88 MHz\";\n\tcase ICE_TIME_REF_FREQ_125_000:\n\t\treturn \"125 MHz\";\n\tcase ICE_TIME_REF_FREQ_153_600:\n\t\treturn \"153.6 MHz\";\n\tcase ICE_TIME_REF_FREQ_156_250:\n\t\treturn \"156.25 MHz\";\n\tcase ICE_TIME_REF_FREQ_245_760:\n\t\treturn \"245.76 MHz\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n \nstatic const char *ice_clk_src_str(u8 clk_src)\n{\n\tswitch ((enum ice_clk_src)clk_src) {\n\tcase ICE_CLK_SRC_TCX0:\n\t\treturn \"TCX0\";\n\tcase ICE_CLK_SRC_TIME_REF:\n\t\treturn \"TIME_REF\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n \nstatic int\nice_cfg_cgu_pll_e822(struct ice_hw *hw, enum ice_time_ref_freq clk_freq,\n\t\t     enum ice_clk_src clk_src)\n{\n\tunion tspll_ro_bwm_lf bwm_lf;\n\tunion nac_cgu_dword19 dw19;\n\tunion nac_cgu_dword22 dw22;\n\tunion nac_cgu_dword24 dw24;\n\tunion nac_cgu_dword9 dw9;\n\tint err;\n\n\tif (clk_freq >= NUM_ICE_TIME_REF_FREQ) {\n\t\tdev_warn(ice_hw_to_dev(hw), \"Invalid TIME_REF frequency %u\\n\",\n\t\t\t clk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_src >= NUM_ICE_CLK_SRC) {\n\t\tdev_warn(ice_hw_to_dev(hw), \"Invalid clock source %u\\n\",\n\t\t\t clk_src);\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_src == ICE_CLK_SRC_TCX0 &&\n\t    clk_freq != ICE_TIME_REF_FREQ_25_000) {\n\t\tdev_warn(ice_hw_to_dev(hw),\n\t\t\t \"TCX0 only supports 25 MHz frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD9, &dw9.val);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD24, &dw24.val);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_read_cgu_reg_e822(hw, TSPLL_RO_BWM_LF, &bwm_lf.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tice_debug(hw, ICE_DBG_PTP, \"Current CGU configuration -- %s, clk_src %s, clk_freq %s, PLL %s\\n\",\n\t\t  dw24.field.ts_pll_enable ? \"enabled\" : \"disabled\",\n\t\t  ice_clk_src_str(dw24.field.time_ref_sel),\n\t\t  ice_clk_freq_str(dw9.field.time_ref_freq_sel),\n\t\t  bwm_lf.field.plllock_true_lock_cri ? \"locked\" : \"unlocked\");\n\n\t \n\tif (dw24.field.ts_pll_enable) {\n\t\tdw24.field.ts_pll_enable = 0;\n\n\t\terr = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tdw9.field.time_ref_freq_sel = clk_freq;\n\terr = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD9, dw9.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD19, &dw19.val);\n\tif (err)\n\t\treturn err;\n\n\tdw19.field.tspll_fbdiv_intgr = e822_cgu_params[clk_freq].feedback_div;\n\tdw19.field.tspll_ndivratio = 1;\n\n\terr = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD19, dw19.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD22, &dw22.val);\n\tif (err)\n\t\treturn err;\n\n\tdw22.field.time1588clk_div = e822_cgu_params[clk_freq].post_pll_div;\n\tdw22.field.time1588clk_sel_div2 = 0;\n\n\terr = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD22, dw22.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD24, &dw24.val);\n\tif (err)\n\t\treturn err;\n\n\tdw24.field.ref1588_ck_div = e822_cgu_params[clk_freq].refclk_pre_div;\n\tdw24.field.tspll_fbdiv_frac = e822_cgu_params[clk_freq].frac_n_div;\n\tdw24.field.time_ref_sel = clk_src;\n\n\terr = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdw24.field.ts_pll_enable = 1;\n\n\terr = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tusleep_range(1000, 5000);\n\n\terr = ice_read_cgu_reg_e822(hw, TSPLL_RO_BWM_LF, &bwm_lf.val);\n\tif (err)\n\t\treturn err;\n\n\tif (!bwm_lf.field.plllock_true_lock_cri) {\n\t\tdev_warn(ice_hw_to_dev(hw), \"CGU PLL failed to lock\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tice_debug(hw, ICE_DBG_PTP, \"New CGU configuration -- %s, clk_src %s, clk_freq %s, PLL %s\\n\",\n\t\t  dw24.field.ts_pll_enable ? \"enabled\" : \"disabled\",\n\t\t  ice_clk_src_str(dw24.field.time_ref_sel),\n\t\t  ice_clk_freq_str(dw9.field.time_ref_freq_sel),\n\t\t  bwm_lf.field.plllock_true_lock_cri ? \"locked\" : \"unlocked\");\n\n\treturn 0;\n}\n\n \nstatic int ice_init_cgu_e822(struct ice_hw *hw)\n{\n\tstruct ice_ts_func_info *ts_info = &hw->func_caps.ts_func_info;\n\tunion tspll_cntr_bist_settings cntr_bist;\n\tint err;\n\n\terr = ice_read_cgu_reg_e822(hw, TSPLL_CNTR_BIST_SETTINGS,\n\t\t\t\t    &cntr_bist.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcntr_bist.field.i_plllock_sel_0 = 0;\n\tcntr_bist.field.i_plllock_sel_1 = 0;\n\n\terr = ice_write_cgu_reg_e822(hw, TSPLL_CNTR_BIST_SETTINGS,\n\t\t\t\t     cntr_bist.val);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ice_cfg_cgu_pll_e822(hw, ts_info->time_ref,\n\t\t\t\t   (enum ice_clk_src)ts_info->clk_src);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_set_vernier_wl(struct ice_hw *hw)\n{\n\tu8 port;\n\n\tfor (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {\n\t\tint err;\n\n\t\terr = ice_write_phy_reg_e822(hw, port, P_REG_WL,\n\t\t\t\t\t     PTP_VERNIER_WL);\n\t\tif (err) {\n\t\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to set vernier window length for port %u, err %d\\n\",\n\t\t\t\t  port, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_init_phc_e822(struct ice_hw *hw)\n{\n\tint err;\n\tu32 regval;\n\n\t \n#define PF_SB_REM_DEV_CTL_SWITCH_READ BIT(1)\n#define PF_SB_REM_DEV_CTL_PHY0 BIT(2)\n\tregval = rd32(hw, PF_SB_REM_DEV_CTL);\n\tregval |= (PF_SB_REM_DEV_CTL_SWITCH_READ |\n\t\t   PF_SB_REM_DEV_CTL_PHY0);\n\twr32(hw, PF_SB_REM_DEV_CTL, regval);\n\n\t \n\terr = ice_init_cgu_e822(hw);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn ice_ptp_set_vernier_wl(hw);\n}\n\n \nstatic int\nice_ptp_prep_phy_time_e822(struct ice_hw *hw, u32 time)\n{\n\tu64 phy_time;\n\tu8 port;\n\tint err;\n\n\t \n\tphy_time = (u64)time << 32;\n\n\tfor (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {\n\t\t \n\t\terr = ice_write_64b_phy_reg_e822(hw, port,\n\t\t\t\t\t\t P_REG_TX_TIMER_INC_PRE_L,\n\t\t\t\t\t\t phy_time);\n\t\tif (err)\n\t\t\tgoto exit_err;\n\n\t\t \n\t\terr = ice_write_64b_phy_reg_e822(hw, port,\n\t\t\t\t\t\t P_REG_RX_TIMER_INC_PRE_L,\n\t\t\t\t\t\t phy_time);\n\t\tif (err)\n\t\t\tgoto exit_err;\n\t}\n\n\treturn 0;\n\nexit_err:\n\tice_debug(hw, ICE_DBG_PTP, \"Failed to write init time for port %u, err %d\\n\",\n\t\t  port, err);\n\n\treturn err;\n}\n\n \nstatic int\nice_ptp_prep_port_adj_e822(struct ice_hw *hw, u8 port, s64 time)\n{\n\tu32 l_time, u_time;\n\tint err;\n\n\tl_time = lower_32_bits(time);\n\tu_time = upper_32_bits(time);\n\n\t \n\terr = ice_write_phy_reg_e822(hw, port, P_REG_TX_TIMER_INC_PRE_L,\n\t\t\t\t     l_time);\n\tif (err)\n\t\tgoto exit_err;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_TX_TIMER_INC_PRE_U,\n\t\t\t\t     u_time);\n\tif (err)\n\t\tgoto exit_err;\n\n\t \n\terr = ice_write_phy_reg_e822(hw, port, P_REG_RX_TIMER_INC_PRE_L,\n\t\t\t\t     l_time);\n\tif (err)\n\t\tgoto exit_err;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_RX_TIMER_INC_PRE_U,\n\t\t\t\t     u_time);\n\tif (err)\n\t\tgoto exit_err;\n\n\treturn 0;\n\nexit_err:\n\tice_debug(hw, ICE_DBG_PTP, \"Failed to write time adjust for port %u, err %d\\n\",\n\t\t  port, err);\n\treturn err;\n}\n\n \nstatic int\nice_ptp_prep_phy_adj_e822(struct ice_hw *hw, s32 adj)\n{\n\ts64 cycles;\n\tu8 port;\n\n\t \n\tif (adj > 0)\n\t\tcycles = (s64)adj << 32;\n\telse\n\t\tcycles = -(((s64)-adj) << 32);\n\n\tfor (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {\n\t\tint err;\n\n\t\terr = ice_ptp_prep_port_adj_e822(hw, port, cycles);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_ptp_prep_phy_incval_e822(struct ice_hw *hw, u64 incval)\n{\n\tint err;\n\tu8 port;\n\n\tfor (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {\n\t\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_TIMETUS_L,\n\t\t\t\t\t\t incval);\n\t\tif (err)\n\t\t\tgoto exit_err;\n\t}\n\n\treturn 0;\n\nexit_err:\n\tice_debug(hw, ICE_DBG_PTP, \"Failed to write incval for port %u, err %d\\n\",\n\t\t  port, err);\n\n\treturn err;\n}\n\n \nstatic int\nice_ptp_read_port_capture(struct ice_hw *hw, u8 port, u64 *tx_ts, u64 *rx_ts)\n{\n\tint err;\n\n\t \n\terr = ice_read_64b_phy_reg_e822(hw, port, P_REG_TX_CAPTURE_L, tx_ts);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read REG_TX_CAPTURE, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tice_debug(hw, ICE_DBG_PTP, \"tx_init = 0x%016llx\\n\",\n\t\t  (unsigned long long)*tx_ts);\n\n\t \n\terr = ice_read_64b_phy_reg_e822(hw, port, P_REG_RX_CAPTURE_L, rx_ts);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read RX_CAPTURE, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tice_debug(hw, ICE_DBG_PTP, \"rx_init = 0x%016llx\\n\",\n\t\t  (unsigned long long)*rx_ts);\n\n\treturn 0;\n}\n\n \nstatic int\nice_ptp_write_port_cmd_e822(struct ice_hw *hw, u8 port, enum ice_ptp_tmr_cmd cmd)\n{\n\tu32 cmd_val, val;\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = ice_get_ptp_src_clock_index(hw);\n\tcmd_val = tmr_idx << SEL_PHY_SRC;\n\tswitch (cmd) {\n\tcase INIT_TIME:\n\t\tcmd_val |= PHY_CMD_INIT_TIME;\n\t\tbreak;\n\tcase INIT_INCVAL:\n\t\tcmd_val |= PHY_CMD_INIT_INCVAL;\n\t\tbreak;\n\tcase ADJ_TIME:\n\t\tcmd_val |= PHY_CMD_ADJ_TIME;\n\t\tbreak;\n\tcase READ_TIME:\n\t\tcmd_val |= PHY_CMD_READ_TIME;\n\t\tbreak;\n\tcase ADJ_TIME_AT_TIME:\n\t\tcmd_val |= PHY_CMD_ADJ_TIME_AT_TIME;\n\t\tbreak;\n\tcase ICE_PTP_NOP:\n\t\tbreak;\n\t}\n\n\t \n\t \n\terr = ice_read_phy_reg_e822(hw, port, P_REG_TX_TMR_CMD, &val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read TX_TMR_CMD, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t \n\tval &= ~TS_CMD_MASK;\n\tval |= cmd_val;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_TX_TMR_CMD, val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write back TX_TMR_CMD, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t \n\t \n\terr = ice_read_phy_reg_e822(hw, port, P_REG_RX_TMR_CMD, &val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read RX_TMR_CMD, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t \n\tval &= ~TS_CMD_MASK;\n\tval |= cmd_val;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_RX_TMR_CMD, val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write back RX_TMR_CMD, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_ptp_one_port_cmd(struct ice_hw *hw, u8 configured_port,\n\t\t     enum ice_ptp_tmr_cmd configured_cmd)\n{\n\tu8 port;\n\n\tfor (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {\n\t\tenum ice_ptp_tmr_cmd cmd;\n\t\tint err;\n\n\t\tif (port == configured_port)\n\t\t\tcmd = configured_cmd;\n\t\telse\n\t\t\tcmd = ICE_PTP_NOP;\n\n\t\terr = ice_ptp_write_port_cmd_e822(hw, port, cmd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_ptp_port_cmd_e822(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)\n{\n\tu8 port;\n\n\tfor (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {\n\t\tint err;\n\n\t\terr = ice_ptp_write_port_cmd_e822(hw, port, cmd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int\nice_phy_get_speed_and_fec_e822(struct ice_hw *hw, u8 port,\n\t\t\t       enum ice_ptp_link_spd *link_out,\n\t\t\t       enum ice_ptp_fec_mode *fec_out)\n{\n\tenum ice_ptp_link_spd link;\n\tenum ice_ptp_fec_mode fec;\n\tu32 serdes;\n\tint err;\n\n\terr = ice_read_phy_reg_e822(hw, port, P_REG_LINK_SPEED, &serdes);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read serdes info\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tfec = (enum ice_ptp_fec_mode)P_REG_LINK_SPEED_FEC_MODE(serdes);\n\n\tserdes &= P_REG_LINK_SPEED_SERDES_M;\n\n\t \n\tif (fec == ICE_PTP_FEC_MODE_RS_FEC) {\n\t\tswitch (serdes) {\n\t\tcase ICE_PTP_SERDES_25G:\n\t\t\tlink = ICE_PTP_LNK_SPD_25G_RS;\n\t\t\tbreak;\n\t\tcase ICE_PTP_SERDES_50G:\n\t\t\tlink = ICE_PTP_LNK_SPD_50G_RS;\n\t\t\tbreak;\n\t\tcase ICE_PTP_SERDES_100G:\n\t\t\tlink = ICE_PTP_LNK_SPD_100G_RS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tswitch (serdes) {\n\t\tcase ICE_PTP_SERDES_1G:\n\t\t\tlink = ICE_PTP_LNK_SPD_1G;\n\t\t\tbreak;\n\t\tcase ICE_PTP_SERDES_10G:\n\t\t\tlink = ICE_PTP_LNK_SPD_10G;\n\t\t\tbreak;\n\t\tcase ICE_PTP_SERDES_25G:\n\t\t\tlink = ICE_PTP_LNK_SPD_25G;\n\t\t\tbreak;\n\t\tcase ICE_PTP_SERDES_40G:\n\t\t\tlink = ICE_PTP_LNK_SPD_40G;\n\t\t\tbreak;\n\t\tcase ICE_PTP_SERDES_50G:\n\t\t\tlink = ICE_PTP_LNK_SPD_50G;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (link_out)\n\t\t*link_out = link;\n\tif (fec_out)\n\t\t*fec_out = fec;\n\n\treturn 0;\n}\n\n \nstatic void ice_phy_cfg_lane_e822(struct ice_hw *hw, u8 port)\n{\n\tenum ice_ptp_link_spd link_spd;\n\tint err;\n\tu32 val;\n\tu8 quad;\n\n\terr = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, NULL);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to get PHY link speed, err %d\\n\",\n\t\t\t  err);\n\t\treturn;\n\t}\n\n\tquad = port / ICE_PORTS_PER_QUAD;\n\n\terr = ice_read_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG, &val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read TX_MEM_GLB_CFG, err %d\\n\",\n\t\t\t  err);\n\t\treturn;\n\t}\n\n\tif (link_spd >= ICE_PTP_LNK_SPD_40G)\n\t\tval &= ~Q_REG_TX_MEM_GBL_CFG_LANE_TYPE_M;\n\telse\n\t\tval |= Q_REG_TX_MEM_GBL_CFG_LANE_TYPE_M;\n\n\terr = ice_write_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG, val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write back TX_MEM_GBL_CFG, err %d\\n\",\n\t\t\t  err);\n\t\treturn;\n\t}\n}\n\n \nstatic int ice_phy_cfg_uix_e822(struct ice_hw *hw, u8 port)\n{\n\tu64 cur_freq, clk_incval, tu_per_sec, uix;\n\tint err;\n\n\tcur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));\n\tclk_incval = ice_ptp_read_src_incval(hw);\n\n\t \n\ttu_per_sec = (cur_freq * clk_incval) >> 8;\n\n#define LINE_UI_10G_40G 640  \n#define LINE_UI_25G_100G 256  \n\n\t \n\tuix = div_u64(tu_per_sec * LINE_UI_10G_40G, 390625000);\n\n\terr = ice_write_64b_phy_reg_e822(hw, port, P_REG_UIX66_10G_40G_L,\n\t\t\t\t\t uix);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write UIX66_10G_40G, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t \n\tuix = div_u64(tu_per_sec * LINE_UI_25G_100G, 390625000);\n\n\terr = ice_write_64b_phy_reg_e822(hw, port, P_REG_UIX66_25G_100G_L,\n\t\t\t\t\t uix);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write UIX66_25G_100G, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_phy_cfg_parpcs_e822(struct ice_hw *hw, u8 port)\n{\n\tu64 cur_freq, clk_incval, tu_per_sec, phy_tus;\n\tenum ice_ptp_link_spd link_spd;\n\tenum ice_ptp_fec_mode fec_mode;\n\tint err;\n\n\terr = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);\n\tif (err)\n\t\treturn err;\n\n\tcur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));\n\tclk_incval = ice_ptp_read_src_incval(hw);\n\n\t \n\ttu_per_sec = cur_freq * clk_incval;\n\n\t \n\n\t \n\tif (e822_vernier[link_spd].tx_par_clk)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].tx_par_clk);\n\telse\n\t\tphy_tus = 0;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_PAR_TX_TUS_L,\n\t\t\t\t\t phy_tus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (e822_vernier[link_spd].rx_par_clk)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].rx_par_clk);\n\telse\n\t\tphy_tus = 0;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_PAR_RX_TUS_L,\n\t\t\t\t\t phy_tus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (e822_vernier[link_spd].tx_pcs_clk)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].tx_pcs_clk);\n\telse\n\t\tphy_tus = 0;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_PCS_TX_TUS_L,\n\t\t\t\t\t phy_tus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (e822_vernier[link_spd].rx_pcs_clk)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].rx_pcs_clk);\n\telse\n\t\tphy_tus = 0;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_PCS_RX_TUS_L,\n\t\t\t\t\t phy_tus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (e822_vernier[link_spd].tx_desk_rsgb_par)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].tx_desk_rsgb_par);\n\telse\n\t\tphy_tus = 0;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PAR_TX_TUS_L,\n\t\t\t\t\t phy_tus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (e822_vernier[link_spd].rx_desk_rsgb_par)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].rx_desk_rsgb_par);\n\telse\n\t\tphy_tus = 0;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PAR_RX_TUS_L,\n\t\t\t\t\t phy_tus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (e822_vernier[link_spd].tx_desk_rsgb_pcs)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].tx_desk_rsgb_pcs);\n\telse\n\t\tphy_tus = 0;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PCS_TX_TUS_L,\n\t\t\t\t\t phy_tus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (e822_vernier[link_spd].rx_desk_rsgb_pcs)\n\t\tphy_tus = div_u64(tu_per_sec,\n\t\t\t\t  e822_vernier[link_spd].rx_desk_rsgb_pcs);\n\telse\n\t\tphy_tus = 0;\n\n\treturn ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PCS_RX_TUS_L,\n\t\t\t\t\t  phy_tus);\n}\n\n \nstatic u64\nice_calc_fixed_tx_offset_e822(struct ice_hw *hw, enum ice_ptp_link_spd link_spd)\n{\n\tu64 cur_freq, clk_incval, tu_per_sec, fixed_offset;\n\n\tcur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));\n\tclk_incval = ice_ptp_read_src_incval(hw);\n\n\t \n\ttu_per_sec = cur_freq * clk_incval;\n\n\t \n\tfixed_offset = div_u64(tu_per_sec, 10000);\n\tfixed_offset *= e822_vernier[link_spd].tx_fixed_delay;\n\tfixed_offset = div_u64(fixed_offset, 10000000);\n\n\treturn fixed_offset;\n}\n\n \nint ice_phy_cfg_tx_offset_e822(struct ice_hw *hw, u8 port)\n{\n\tenum ice_ptp_link_spd link_spd;\n\tenum ice_ptp_fec_mode fec_mode;\n\tu64 total_offset, val;\n\tint err;\n\tu32 reg;\n\n\t \n\terr = ice_read_phy_reg_e822(hw, port, P_REG_TX_OR, &reg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read TX_OR for port %u, err %d\\n\",\n\t\t\t  port, err);\n\t\treturn err;\n\t}\n\n\tif (reg)\n\t\treturn 0;\n\n\terr = ice_read_phy_reg_e822(hw, port, P_REG_TX_OV_STATUS, &reg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read TX_OV_STATUS for port %u, err %d\\n\",\n\t\t\t  port, err);\n\t\treturn err;\n\t}\n\n\tif (!(reg & P_REG_TX_OV_STATUS_OV_M))\n\t\treturn -EBUSY;\n\n\terr = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);\n\tif (err)\n\t\treturn err;\n\n\ttotal_offset = ice_calc_fixed_tx_offset_e822(hw, link_spd);\n\n\t \n\tif (link_spd == ICE_PTP_LNK_SPD_1G ||\n\t    link_spd == ICE_PTP_LNK_SPD_10G ||\n\t    link_spd == ICE_PTP_LNK_SPD_25G ||\n\t    link_spd == ICE_PTP_LNK_SPD_25G_RS ||\n\t    link_spd == ICE_PTP_LNK_SPD_40G ||\n\t    link_spd == ICE_PTP_LNK_SPD_50G) {\n\t\terr = ice_read_64b_phy_reg_e822(hw, port,\n\t\t\t\t\t\tP_REG_PAR_PCS_TX_OFFSET_L,\n\t\t\t\t\t\t&val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttotal_offset += val;\n\t}\n\n\t \n\tif (link_spd == ICE_PTP_LNK_SPD_50G_RS ||\n\t    link_spd == ICE_PTP_LNK_SPD_100G_RS) {\n\t\terr = ice_read_64b_phy_reg_e822(hw, port,\n\t\t\t\t\t\tP_REG_PAR_TX_TIME_L,\n\t\t\t\t\t\t&val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttotal_offset += val;\n\t}\n\n\t \n\terr = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_TX_OFFSET_L,\n\t\t\t\t\t total_offset);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_TX_OR, 1);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(ice_hw_to_dev(hw), \"Port=%d Tx vernier offset calibration complete\\n\",\n\t\t port);\n\n\treturn 0;\n}\n\n \nstatic int\nice_phy_calc_pmd_adj_e822(struct ice_hw *hw, u8 port,\n\t\t\t  enum ice_ptp_link_spd link_spd,\n\t\t\t  enum ice_ptp_fec_mode fec_mode, u64 *pmd_adj)\n{\n\tu64 cur_freq, clk_incval, tu_per_sec, mult, adj;\n\tu8 pmd_align;\n\tu32 val;\n\tint err;\n\n\terr = ice_read_phy_reg_e822(hw, port, P_REG_PMD_ALIGNMENT, &val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read PMD alignment, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tpmd_align = (u8)val;\n\n\tcur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));\n\tclk_incval = ice_ptp_read_src_incval(hw);\n\n\t \n\ttu_per_sec = cur_freq * clk_incval;\n\n\t \n\tif (link_spd == ICE_PTP_LNK_SPD_1G) {\n\t\tif (pmd_align == 4)\n\t\t\tmult = 10;\n\t\telse\n\t\t\tmult = (pmd_align + 6) % 10;\n\t} else if (link_spd == ICE_PTP_LNK_SPD_10G ||\n\t\t   link_spd == ICE_PTP_LNK_SPD_25G ||\n\t\t   link_spd == ICE_PTP_LNK_SPD_40G ||\n\t\t   link_spd == ICE_PTP_LNK_SPD_50G) {\n\t\t \n\t\tif (pmd_align != 65 || fec_mode == ICE_PTP_FEC_MODE_CLAUSE74)\n\t\t\tmult = pmd_align;\n\t\telse\n\t\t\tmult = 0;\n\t} else if (link_spd == ICE_PTP_LNK_SPD_25G_RS ||\n\t\t   link_spd == ICE_PTP_LNK_SPD_50G_RS ||\n\t\t   link_spd == ICE_PTP_LNK_SPD_100G_RS) {\n\t\tif (pmd_align < 17)\n\t\t\tmult = pmd_align + 40;\n\t\telse\n\t\t\tmult = pmd_align;\n\t} else {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Unknown link speed %d, skipping PMD adjustment\\n\",\n\t\t\t  link_spd);\n\t\tmult = 0;\n\t}\n\n\t \n\tif (!mult) {\n\t\t*pmd_adj = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tadj = div_u64(tu_per_sec, 125);\n\tadj *= mult;\n\tadj = div_u64(adj, e822_vernier[link_spd].pmd_adj_divisor);\n\n\t \n\tif (link_spd == ICE_PTP_LNK_SPD_25G_RS) {\n\t\tu64 cycle_adj;\n\t\tu8 rx_cycle;\n\n\t\terr = ice_read_phy_reg_e822(hw, port, P_REG_RX_40_TO_160_CNT,\n\t\t\t\t\t    &val);\n\t\tif (err) {\n\t\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read 25G-RS Rx cycle count, err %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn err;\n\t\t}\n\n\t\trx_cycle = val & P_REG_RX_40_TO_160_CNT_RXCYC_M;\n\t\tif (rx_cycle) {\n\t\t\tmult = (4 - rx_cycle) * 40;\n\n\t\t\tcycle_adj = div_u64(tu_per_sec, 125);\n\t\t\tcycle_adj *= mult;\n\t\t\tcycle_adj = div_u64(cycle_adj, e822_vernier[link_spd].pmd_adj_divisor);\n\n\t\t\tadj += cycle_adj;\n\t\t}\n\t} else if (link_spd == ICE_PTP_LNK_SPD_50G_RS) {\n\t\tu64 cycle_adj;\n\t\tu8 rx_cycle;\n\n\t\terr = ice_read_phy_reg_e822(hw, port, P_REG_RX_80_TO_160_CNT,\n\t\t\t\t\t    &val);\n\t\tif (err) {\n\t\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read 50G-RS Rx cycle count, err %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn err;\n\t\t}\n\n\t\trx_cycle = val & P_REG_RX_80_TO_160_CNT_RXCYC_M;\n\t\tif (rx_cycle) {\n\t\t\tmult = rx_cycle * 40;\n\n\t\t\tcycle_adj = div_u64(tu_per_sec, 125);\n\t\t\tcycle_adj *= mult;\n\t\t\tcycle_adj = div_u64(cycle_adj, e822_vernier[link_spd].pmd_adj_divisor);\n\n\t\t\tadj += cycle_adj;\n\t\t}\n\t}\n\n\t \n\t*pmd_adj = adj;\n\n\treturn 0;\n}\n\n \nstatic u64\nice_calc_fixed_rx_offset_e822(struct ice_hw *hw, enum ice_ptp_link_spd link_spd)\n{\n\tu64 cur_freq, clk_incval, tu_per_sec, fixed_offset;\n\n\tcur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));\n\tclk_incval = ice_ptp_read_src_incval(hw);\n\n\t \n\ttu_per_sec = cur_freq * clk_incval;\n\n\t \n\tfixed_offset = div_u64(tu_per_sec, 10000);\n\tfixed_offset *= e822_vernier[link_spd].rx_fixed_delay;\n\tfixed_offset = div_u64(fixed_offset, 10000000);\n\n\treturn fixed_offset;\n}\n\n \nint ice_phy_cfg_rx_offset_e822(struct ice_hw *hw, u8 port)\n{\n\tenum ice_ptp_link_spd link_spd;\n\tenum ice_ptp_fec_mode fec_mode;\n\tu64 total_offset, pmd, val;\n\tint err;\n\tu32 reg;\n\n\t \n\terr = ice_read_phy_reg_e822(hw, port, P_REG_RX_OR, &reg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read RX_OR for port %u, err %d\\n\",\n\t\t\t  port, err);\n\t\treturn err;\n\t}\n\n\tif (reg)\n\t\treturn 0;\n\n\terr = ice_read_phy_reg_e822(hw, port, P_REG_RX_OV_STATUS, &reg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read RX_OV_STATUS for port %u, err %d\\n\",\n\t\t\t  port, err);\n\t\treturn err;\n\t}\n\n\tif (!(reg & P_REG_RX_OV_STATUS_OV_M))\n\t\treturn -EBUSY;\n\n\terr = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);\n\tif (err)\n\t\treturn err;\n\n\ttotal_offset = ice_calc_fixed_rx_offset_e822(hw, link_spd);\n\n\t \n\terr = ice_read_64b_phy_reg_e822(hw, port,\n\t\t\t\t\tP_REG_PAR_PCS_RX_OFFSET_L,\n\t\t\t\t\t&val);\n\tif (err)\n\t\treturn err;\n\n\ttotal_offset += val;\n\n\t \n\tif (link_spd == ICE_PTP_LNK_SPD_40G ||\n\t    link_spd == ICE_PTP_LNK_SPD_50G ||\n\t    link_spd == ICE_PTP_LNK_SPD_50G_RS ||\n\t    link_spd == ICE_PTP_LNK_SPD_100G_RS) {\n\t\terr = ice_read_64b_phy_reg_e822(hw, port,\n\t\t\t\t\t\tP_REG_PAR_RX_TIME_L,\n\t\t\t\t\t\t&val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttotal_offset += val;\n\t}\n\n\t \n\terr = ice_phy_calc_pmd_adj_e822(hw, port, link_spd, fec_mode, &pmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (fec_mode == ICE_PTP_FEC_MODE_RS_FEC)\n\t\ttotal_offset += pmd;\n\telse\n\t\ttotal_offset -= pmd;\n\n\t \n\terr = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_RX_OFFSET_L,\n\t\t\t\t\t total_offset);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_RX_OR, 1);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(ice_hw_to_dev(hw), \"Port=%d Rx vernier offset calibration complete\\n\",\n\t\t port);\n\n\treturn 0;\n}\n\n \nstatic int\nice_read_phy_and_phc_time_e822(struct ice_hw *hw, u8 port, u64 *phy_time,\n\t\t\t       u64 *phc_time)\n{\n\tu64 tx_time, rx_time;\n\tu32 zo, lo;\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = ice_get_ptp_src_clock_index(hw);\n\n\t \n\tice_ptp_src_cmd(hw, READ_TIME);\n\n\t \n\terr = ice_ptp_one_port_cmd(hw, port, READ_TIME);\n\tif (err)\n\t\treturn err;\n\n\t \n\tice_ptp_exec_tmr_cmd(hw);\n\n\t \n\tzo = rd32(hw, GLTSYN_SHTIME_0(tmr_idx));\n\tlo = rd32(hw, GLTSYN_SHTIME_L(tmr_idx));\n\t*phc_time = (u64)lo << 32 | zo;\n\n\t \n\terr = ice_ptp_read_port_capture(hw, port, &tx_time, &rx_time);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (tx_time != rx_time)\n\t\tdev_warn(ice_hw_to_dev(hw),\n\t\t\t \"PHY port %u Tx and Rx timers do not match, tx_time 0x%016llX, rx_time 0x%016llX\\n\",\n\t\t\t port, (unsigned long long)tx_time,\n\t\t\t (unsigned long long)rx_time);\n\n\t*phy_time = tx_time;\n\n\treturn 0;\n}\n\n \nstatic int ice_sync_phy_timer_e822(struct ice_hw *hw, u8 port)\n{\n\tu64 phc_time, phy_time, difference;\n\tint err;\n\n\tif (!ice_ptp_lock(hw)) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to acquire PTP semaphore\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\terr = ice_read_phy_and_phc_time_e822(hw, port, &phy_time, &phc_time);\n\tif (err)\n\t\tgoto err_unlock;\n\n\t \n\tdifference = phc_time - phy_time;\n\n\terr = ice_ptp_prep_port_adj_e822(hw, port, (s64)difference);\n\tif (err)\n\t\tgoto err_unlock;\n\n\terr = ice_ptp_one_port_cmd(hw, port, ADJ_TIME);\n\tif (err)\n\t\tgoto err_unlock;\n\n\t \n\tice_ptp_src_cmd(hw, ICE_PTP_NOP);\n\n\t \n\tice_ptp_exec_tmr_cmd(hw);\n\n\t \n\terr = ice_read_phy_and_phc_time_e822(hw, port, &phy_time, &phc_time);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tdev_info(ice_hw_to_dev(hw),\n\t\t \"Port %u PHY time synced to PHC: 0x%016llX, 0x%016llX\\n\",\n\t\t port, (unsigned long long)phy_time,\n\t\t (unsigned long long)phc_time);\n\n\tice_ptp_unlock(hw);\n\n\treturn 0;\n\nerr_unlock:\n\tice_ptp_unlock(hw);\n\treturn err;\n}\n\n \nint\nice_stop_phy_timer_e822(struct ice_hw *hw, u8 port, bool soft_reset)\n{\n\tint err;\n\tu32 val;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_TX_OR, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_RX_OR, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_read_phy_reg_e822(hw, port, P_REG_PS, &val);\n\tif (err)\n\t\treturn err;\n\n\tval &= ~P_REG_PS_START_M;\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\tif (err)\n\t\treturn err;\n\n\tval &= ~P_REG_PS_ENA_CLK_M;\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\tif (err)\n\t\treturn err;\n\n\tif (soft_reset) {\n\t\tval |= P_REG_PS_SFT_RESET_M;\n\t\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tice_debug(hw, ICE_DBG_PTP, \"Disabled clock on PHY port %u\\n\", port);\n\n\treturn 0;\n}\n\n \nint ice_start_phy_timer_e822(struct ice_hw *hw, u8 port)\n{\n\tu32 lo, hi, val;\n\tu64 incval;\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = ice_get_ptp_src_clock_index(hw);\n\n\terr = ice_stop_phy_timer_e822(hw, port, false);\n\tif (err)\n\t\treturn err;\n\n\tice_phy_cfg_lane_e822(hw, port);\n\n\terr = ice_phy_cfg_uix_e822(hw, port);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_phy_cfg_parpcs_e822(hw, port);\n\tif (err)\n\t\treturn err;\n\n\tlo = rd32(hw, GLTSYN_INCVAL_L(tmr_idx));\n\thi = rd32(hw, GLTSYN_INCVAL_H(tmr_idx));\n\tincval = (u64)hi << 32 | lo;\n\n\terr = ice_write_40b_phy_reg_e822(hw, port, P_REG_TIMETUS_L, incval);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_ptp_one_port_cmd(hw, port, INIT_INCVAL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tice_ptp_src_cmd(hw, ICE_PTP_NOP);\n\n\tice_ptp_exec_tmr_cmd(hw);\n\n\terr = ice_read_phy_reg_e822(hw, port, P_REG_PS, &val);\n\tif (err)\n\t\treturn err;\n\n\tval |= P_REG_PS_SFT_RESET_M;\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\tif (err)\n\t\treturn err;\n\n\tval |= P_REG_PS_START_M;\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\tif (err)\n\t\treturn err;\n\n\tval &= ~P_REG_PS_SFT_RESET_M;\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\tif (err)\n\t\treturn err;\n\n\terr = ice_ptp_one_port_cmd(hw, port, INIT_INCVAL);\n\tif (err)\n\t\treturn err;\n\n\tice_ptp_exec_tmr_cmd(hw);\n\n\tval |= P_REG_PS_ENA_CLK_M;\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\tif (err)\n\t\treturn err;\n\n\tval |= P_REG_PS_LOAD_OFFSET_M;\n\terr = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);\n\tif (err)\n\t\treturn err;\n\n\tice_ptp_exec_tmr_cmd(hw);\n\n\terr = ice_sync_phy_timer_e822(hw, port);\n\tif (err)\n\t\treturn err;\n\n\tice_debug(hw, ICE_DBG_PTP, \"Enabled clock on PHY port %u\\n\", port);\n\n\treturn 0;\n}\n\n \nstatic int\nice_get_phy_tx_tstamp_ready_e822(struct ice_hw *hw, u8 quad, u64 *tstamp_ready)\n{\n\tu32 hi, lo;\n\tint err;\n\n\terr = ice_read_quad_reg_e822(hw, quad, Q_REG_TX_MEMORY_STATUS_U, &hi);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read TX_MEMORY_STATUS_U for quad %u, err %d\\n\",\n\t\t\t  quad, err);\n\t\treturn err;\n\t}\n\n\terr = ice_read_quad_reg_e822(hw, quad, Q_REG_TX_MEMORY_STATUS_L, &lo);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read TX_MEMORY_STATUS_L for quad %u, err %d\\n\",\n\t\t\t  quad, err);\n\t\treturn err;\n\t}\n\n\t*tstamp_ready = (u64)hi << 32 | (u64)lo;\n\n\treturn 0;\n}\n\n \n\n \nstatic int ice_read_phy_reg_e810(struct ice_hw *hw, u32 addr, u32 *val)\n{\n\tstruct ice_sbq_msg_input msg = {0};\n\tint err;\n\n\tmsg.msg_addr_low = lower_16_bits(addr);\n\tmsg.msg_addr_high = upper_16_bits(addr);\n\tmsg.opcode = ice_sbq_msg_rd;\n\tmsg.dest_dev = rmn_0;\n\n\terr = ice_sbq_rw_reg(hw, &msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to send message to PHY, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t*val = msg.data;\n\n\treturn 0;\n}\n\n \nstatic int ice_write_phy_reg_e810(struct ice_hw *hw, u32 addr, u32 val)\n{\n\tstruct ice_sbq_msg_input msg = {0};\n\tint err;\n\n\tmsg.msg_addr_low = lower_16_bits(addr);\n\tmsg.msg_addr_high = upper_16_bits(addr);\n\tmsg.opcode = ice_sbq_msg_wr;\n\tmsg.dest_dev = rmn_0;\n\tmsg.data = val;\n\n\terr = ice_sbq_rw_reg(hw, &msg);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to send message to PHY, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_read_phy_tstamp_ll_e810(struct ice_hw *hw, u8 idx, u8 *hi, u32 *lo)\n{\n\tu32 val;\n\tu8 i;\n\n\t \n\tval = FIELD_PREP(TS_LL_READ_TS_IDX, idx) | TS_LL_READ_TS;\n\twr32(hw, PF_SB_ATQBAL, val);\n\n\t \n\tfor (i = TS_LL_READ_RETRIES; i > 0; i--) {\n\t\tval = rd32(hw, PF_SB_ATQBAL);\n\n\t\t \n\t\tif (!(FIELD_GET(TS_LL_READ_TS, val))) {\n\t\t\t \n\t\t\t*hi = FIELD_GET(TS_LL_READ_TS_HIGH, val);\n\n\t\t\t \n\t\t\t*lo = rd32(hw, PF_SB_ATQBAH) | TS_VALID;\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(10);\n\t}\n\n\t \n\tice_debug(hw, ICE_DBG_PTP, \"Failed to read PTP timestamp using low latency read\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int\nice_read_phy_tstamp_sbq_e810(struct ice_hw *hw, u8 lport, u8 idx, u8 *hi,\n\t\t\t     u32 *lo)\n{\n\tu32 hi_addr = TS_EXT(HIGH_TX_MEMORY_BANK_START, lport, idx);\n\tu32 lo_addr = TS_EXT(LOW_TX_MEMORY_BANK_START, lport, idx);\n\tu32 lo_val, hi_val;\n\tint err;\n\n\terr = ice_read_phy_reg_e810(hw, lo_addr, &lo_val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read low PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\terr = ice_read_phy_reg_e810(hw, hi_addr, &hi_val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read high PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\t*lo = lo_val;\n\t*hi = (u8)hi_val;\n\n\treturn 0;\n}\n\n \nstatic int\nice_read_phy_tstamp_e810(struct ice_hw *hw, u8 lport, u8 idx, u64 *tstamp)\n{\n\tu32 lo = 0;\n\tu8 hi = 0;\n\tint err;\n\n\tif (hw->dev_caps.ts_dev_info.ts_ll_read)\n\t\terr = ice_read_phy_tstamp_ll_e810(hw, idx, &hi, &lo);\n\telse\n\t\terr = ice_read_phy_tstamp_sbq_e810(hw, lport, idx, &hi, &lo);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\t*tstamp = ((u64)hi) << TS_HIGH_S | ((u64)lo & TS_LOW_M);\n\n\treturn 0;\n}\n\n \nstatic int ice_clear_phy_tstamp_e810(struct ice_hw *hw, u8 lport, u8 idx)\n{\n\tu32 lo_addr, hi_addr;\n\tint err;\n\n\tlo_addr = TS_EXT(LOW_TX_MEMORY_BANK_START, lport, idx);\n\thi_addr = TS_EXT(HIGH_TX_MEMORY_BANK_START, lport, idx);\n\n\terr = ice_write_phy_reg_e810(hw, lo_addr, 0);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to clear low PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\terr = ice_write_phy_reg_e810(hw, hi_addr, 0);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to clear high PTP timestamp register, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nint ice_ptp_init_phy_e810(struct ice_hw *hw)\n{\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_ENA(tmr_idx),\n\t\t\t\t     GLTSYN_ENA_TSYN_ENA_M);\n\tif (err)\n\t\tice_debug(hw, ICE_DBG_PTP, \"PTP failed in ena_phy_time_syn %d\\n\",\n\t\t\t  err);\n\n\treturn err;\n}\n\n \nstatic int ice_ptp_init_phc_e810(struct ice_hw *hw)\n{\n\t \n\twr32(hw, GLTSYN_SYNC_DLAY, 0);\n\n\t \n\treturn ice_ptp_init_phy_e810(hw);\n}\n\n \nstatic int ice_ptp_prep_phy_time_e810(struct ice_hw *hw, u32 time)\n{\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_SHTIME_0(tmr_idx), 0);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write SHTIME_0, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_SHTIME_L(tmr_idx), time);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write SHTIME_L, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_prep_phy_adj_e810(struct ice_hw *hw, s32 adj)\n{\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\n\t \n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_SHADJ_L(tmr_idx), 0);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write adj to PHY SHADJ_L, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_SHADJ_H(tmr_idx), adj);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write adj to PHY SHADJ_H, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_prep_phy_incval_e810(struct ice_hw *hw, u64 incval)\n{\n\tu32 high, low;\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\tlow = lower_32_bits(incval);\n\thigh = upper_32_bits(incval);\n\n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_SHADJ_L(tmr_idx), low);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write incval to PHY SHADJ_L, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_SHADJ_H(tmr_idx), high);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write incval PHY SHADJ_H, err %d\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_ptp_port_cmd_e810(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)\n{\n\tu32 cmd_val, val;\n\tint err;\n\n\tswitch (cmd) {\n\tcase INIT_TIME:\n\t\tcmd_val = GLTSYN_CMD_INIT_TIME;\n\t\tbreak;\n\tcase INIT_INCVAL:\n\t\tcmd_val = GLTSYN_CMD_INIT_INCVAL;\n\t\tbreak;\n\tcase ADJ_TIME:\n\t\tcmd_val = GLTSYN_CMD_ADJ_TIME;\n\t\tbreak;\n\tcase READ_TIME:\n\t\tcmd_val = GLTSYN_CMD_READ_TIME;\n\t\tbreak;\n\tcase ADJ_TIME_AT_TIME:\n\t\tcmd_val = GLTSYN_CMD_ADJ_INIT_TIME;\n\t\tbreak;\n\tcase ICE_PTP_NOP:\n\t\treturn 0;\n\t}\n\n\t \n\terr = ice_read_phy_reg_e810(hw, ETH_GLTSYN_CMD, &val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to read GLTSYN_CMD, err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tval &= ~TS_CMD_MASK_E810;\n\tval |= cmd_val;\n\n\terr = ice_write_phy_reg_e810(hw, ETH_GLTSYN_CMD, val);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to write back GLTSYN_CMD, err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nice_get_phy_tx_tstamp_ready_e810(struct ice_hw *hw, u8 port, u64 *tstamp_ready)\n{\n\t*tstamp_ready = 0xFFFFFFFFFFFFFFFF;\n\treturn 0;\n}\n\n \n\n \nstatic int\nice_get_pca9575_handle(struct ice_hw *hw, u16 *pca9575_handle)\n{\n\tstruct ice_aqc_get_link_topo *cmd;\n\tstruct ice_aq_desc desc;\n\tint status;\n\tu8 idx;\n\n\t \n\tif (hw->io_expander_handle) {\n\t\t*pca9575_handle = hw->io_expander_handle;\n\t\treturn 0;\n\t}\n\n\t \n\tcmd = &desc.params.get_link_topo;\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_get_link_topo);\n\n\t \n\tcmd->addr.topo_params.node_type_ctx =\n\t\t(ICE_AQC_LINK_TOPO_NODE_TYPE_M &\n\t\t ICE_AQC_LINK_TOPO_NODE_TYPE_GPIO_CTRL);\n\n#define SW_PCA9575_SFP_TOPO_IDX\t\t2\n#define SW_PCA9575_QSFP_TOPO_IDX\t1\n\n\t \n\tif (hw->device_id == ICE_DEV_ID_E810C_SFP)\n\t\tidx = SW_PCA9575_SFP_TOPO_IDX;\n\telse if (hw->device_id == ICE_DEV_ID_E810C_QSFP)\n\t\tidx = SW_PCA9575_QSFP_TOPO_IDX;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tcmd->addr.topo_params.index = idx;\n\n\tstatus = ice_aq_send_cmd(hw, &desc, NULL, 0, NULL);\n\tif (status)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (desc.params.get_link_topo.node_part_num !=\n\t\tICE_AQC_GET_LINK_TOPO_NODE_NR_PCA9575)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\thw->io_expander_handle =\n\t\tle16_to_cpu(desc.params.get_link_topo.addr.handle);\n\t*pca9575_handle = hw->io_expander_handle;\n\n\treturn 0;\n}\n\n \nint ice_read_sma_ctrl_e810t(struct ice_hw *hw, u8 *data)\n{\n\tint status;\n\tu16 handle;\n\tu8 i;\n\n\tstatus = ice_get_pca9575_handle(hw, &handle);\n\tif (status)\n\t\treturn status;\n\n\t*data = 0;\n\n\tfor (i = ICE_SMA_MIN_BIT_E810T; i <= ICE_SMA_MAX_BIT_E810T; i++) {\n\t\tbool pin;\n\n\t\tstatus = ice_aq_get_gpio(hw, handle, i + ICE_PCA9575_P1_OFFSET,\n\t\t\t\t\t &pin, NULL);\n\t\tif (status)\n\t\t\tbreak;\n\t\t*data |= (u8)(!pin) << i;\n\t}\n\n\treturn status;\n}\n\n \nint ice_write_sma_ctrl_e810t(struct ice_hw *hw, u8 data)\n{\n\tint status;\n\tu16 handle;\n\tu8 i;\n\n\tstatus = ice_get_pca9575_handle(hw, &handle);\n\tif (status)\n\t\treturn status;\n\n\tfor (i = ICE_SMA_MIN_BIT_E810T; i <= ICE_SMA_MAX_BIT_E810T; i++) {\n\t\tbool pin;\n\n\t\tpin = !(data & (1 << i));\n\t\tstatus = ice_aq_set_gpio(hw, handle, i + ICE_PCA9575_P1_OFFSET,\n\t\t\t\t\t pin, NULL);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nint ice_read_pca9575_reg_e810t(struct ice_hw *hw, u8 offset, u8 *data)\n{\n\tstruct ice_aqc_link_topo_addr link_topo;\n\t__le16 addr;\n\tu16 handle;\n\tint err;\n\n\tmemset(&link_topo, 0, sizeof(link_topo));\n\n\terr = ice_get_pca9575_handle(hw, &handle);\n\tif (err)\n\t\treturn err;\n\n\tlink_topo.handle = cpu_to_le16(handle);\n\tlink_topo.topo_params.node_type_ctx =\n\t\tFIELD_PREP(ICE_AQC_LINK_TOPO_NODE_CTX_M,\n\t\t\t   ICE_AQC_LINK_TOPO_NODE_CTX_PROVIDED);\n\n\taddr = cpu_to_le16((u16)offset);\n\n\treturn ice_aq_read_i2c(hw, link_topo, 0, addr, 1, data, NULL);\n}\n\n \n\n \nbool ice_ptp_lock(struct ice_hw *hw)\n{\n\tu32 hw_lock;\n\tint i;\n\n#define MAX_TRIES 15\n\n\tfor (i = 0; i < MAX_TRIES; i++) {\n\t\thw_lock = rd32(hw, PFTSYN_SEM + (PFTSYN_SEM_BYTES * hw->pf_id));\n\t\thw_lock = hw_lock & PFTSYN_SEM_BUSY_M;\n\t\tif (hw_lock) {\n\t\t\t \n\t\t\tusleep_range(5000, 6000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn !hw_lock;\n}\n\n \nvoid ice_ptp_unlock(struct ice_hw *hw)\n{\n\twr32(hw, PFTSYN_SEM + (PFTSYN_SEM_BYTES * hw->pf_id), 0);\n}\n\n \nstatic int ice_ptp_tmr_cmd(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)\n{\n\tint err;\n\n\t \n\tice_ptp_src_cmd(hw, cmd);\n\n\t \n\tif (ice_is_e810(hw))\n\t\terr = ice_ptp_port_cmd_e810(hw, cmd);\n\telse\n\t\terr = ice_ptp_port_cmd_e822(hw, cmd);\n\tif (err) {\n\t\tice_debug(hw, ICE_DBG_PTP, \"Failed to prepare PHY ports for timer command %u, err %d\\n\",\n\t\t\t  cmd, err);\n\t\treturn err;\n\t}\n\n\t \n\tice_ptp_exec_tmr_cmd(hw);\n\n\treturn 0;\n}\n\n \nint ice_ptp_init_time(struct ice_hw *hw, u64 time)\n{\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\n\t \n\twr32(hw, GLTSYN_SHTIME_L(tmr_idx), lower_32_bits(time));\n\twr32(hw, GLTSYN_SHTIME_H(tmr_idx), upper_32_bits(time));\n\twr32(hw, GLTSYN_SHTIME_0(tmr_idx), 0);\n\n\t \n\t \n\tif (ice_is_e810(hw))\n\t\terr = ice_ptp_prep_phy_time_e810(hw, time & 0xFFFFFFFF);\n\telse\n\t\terr = ice_ptp_prep_phy_time_e822(hw, time & 0xFFFFFFFF);\n\tif (err)\n\t\treturn err;\n\n\treturn ice_ptp_tmr_cmd(hw, INIT_TIME);\n}\n\n \nint ice_ptp_write_incval(struct ice_hw *hw, u64 incval)\n{\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\n\t \n\twr32(hw, GLTSYN_SHADJ_L(tmr_idx), lower_32_bits(incval));\n\twr32(hw, GLTSYN_SHADJ_H(tmr_idx), upper_32_bits(incval));\n\n\tif (ice_is_e810(hw))\n\t\terr = ice_ptp_prep_phy_incval_e810(hw, incval);\n\telse\n\t\terr = ice_ptp_prep_phy_incval_e822(hw, incval);\n\tif (err)\n\t\treturn err;\n\n\treturn ice_ptp_tmr_cmd(hw, INIT_INCVAL);\n}\n\n \nint ice_ptp_write_incval_locked(struct ice_hw *hw, u64 incval)\n{\n\tint err;\n\n\tif (!ice_ptp_lock(hw))\n\t\treturn -EBUSY;\n\n\terr = ice_ptp_write_incval(hw, incval);\n\n\tice_ptp_unlock(hw);\n\n\treturn err;\n}\n\n \nint ice_ptp_adj_clock(struct ice_hw *hw, s32 adj)\n{\n\tu8 tmr_idx;\n\tint err;\n\n\ttmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\n\t \n\twr32(hw, GLTSYN_SHADJ_L(tmr_idx), 0);\n\twr32(hw, GLTSYN_SHADJ_H(tmr_idx), adj);\n\n\tif (ice_is_e810(hw))\n\t\terr = ice_ptp_prep_phy_adj_e810(hw, adj);\n\telse\n\t\terr = ice_ptp_prep_phy_adj_e822(hw, adj);\n\tif (err)\n\t\treturn err;\n\n\treturn ice_ptp_tmr_cmd(hw, ADJ_TIME);\n}\n\n \nint ice_read_phy_tstamp(struct ice_hw *hw, u8 block, u8 idx, u64 *tstamp)\n{\n\tif (ice_is_e810(hw))\n\t\treturn ice_read_phy_tstamp_e810(hw, block, idx, tstamp);\n\telse\n\t\treturn ice_read_phy_tstamp_e822(hw, block, idx, tstamp);\n}\n\n \nint ice_clear_phy_tstamp(struct ice_hw *hw, u8 block, u8 idx)\n{\n\tif (ice_is_e810(hw))\n\t\treturn ice_clear_phy_tstamp_e810(hw, block, idx);\n\telse\n\t\treturn ice_clear_phy_tstamp_e822(hw, block, idx);\n}\n\n \nvoid ice_ptp_reset_ts_memory(struct ice_hw *hw)\n{\n\tif (ice_is_e810(hw))\n\t\treturn;\n\n\tice_ptp_reset_ts_memory_e822(hw);\n}\n\n \nint ice_ptp_init_phc(struct ice_hw *hw)\n{\n\tu8 src_idx = hw->func_caps.ts_func_info.tmr_index_owned;\n\n\t \n\twr32(hw, GLTSYN_ENA(src_idx), GLTSYN_ENA_TSYN_ENA_M);\n\n\t \n\t(void)rd32(hw, GLTSYN_STAT(src_idx));\n\n\tif (ice_is_e810(hw))\n\t\treturn ice_ptp_init_phc_e810(hw);\n\telse\n\t\treturn ice_ptp_init_phc_e822(hw);\n}\n\n \nint ice_get_phy_tx_tstamp_ready(struct ice_hw *hw, u8 block, u64 *tstamp_ready)\n{\n\tif (ice_is_e810(hw))\n\t\treturn ice_get_phy_tx_tstamp_ready_e810(hw, block,\n\t\t\t\t\t\t\ttstamp_ready);\n\telse\n\t\treturn ice_get_phy_tx_tstamp_ready_e822(hw, block,\n\t\t\t\t\t\t\ttstamp_ready);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}