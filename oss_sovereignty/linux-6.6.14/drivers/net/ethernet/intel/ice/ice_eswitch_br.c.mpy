{
  "module_name": "ice_eswitch_br.c",
  "hash_id": "d29354a0101580fbe0ff1e88b5b4ce86d228592243727be9ea044bb42c6ef4aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_eswitch_br.c",
  "human_readable_source": "\n \n\n#include \"ice.h\"\n#include \"ice_eswitch_br.h\"\n#include \"ice_repr.h\"\n#include \"ice_switch.h\"\n#include \"ice_vlan.h\"\n#include \"ice_vf_vsi_vlan_ops.h\"\n#include \"ice_trace.h\"\n\n#define ICE_ESW_BRIDGE_UPDATE_INTERVAL msecs_to_jiffies(1000)\n\nstatic const struct rhashtable_params ice_fdb_ht_params = {\n\t.key_offset = offsetof(struct ice_esw_br_fdb_entry, data),\n\t.key_len = sizeof(struct ice_esw_br_fdb_data),\n\t.head_offset = offsetof(struct ice_esw_br_fdb_entry, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic bool ice_eswitch_br_is_dev_valid(const struct net_device *dev)\n{\n\t \n\treturn ice_is_port_repr_netdev(dev) || netif_is_ice(dev) ||\n\t\tnetif_is_lag_master(dev);\n}\n\nstatic struct net_device *\nice_eswitch_br_get_uplink_from_lag(struct net_device *lag_dev)\n{\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(lag_dev, lower, iter) {\n\t\tif (netif_is_ice(lower))\n\t\t\treturn lower;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct ice_esw_br_port *\nice_eswitch_br_netdev_to_port(struct net_device *dev)\n{\n\tif (ice_is_port_repr_netdev(dev)) {\n\t\tstruct ice_repr *repr = ice_netdev_to_repr(dev);\n\n\t\treturn repr->br_port;\n\t} else if (netif_is_ice(dev) || netif_is_lag_master(dev)) {\n\t\tstruct net_device *ice_dev;\n\t\tstruct ice_pf *pf;\n\n\t\tif (netif_is_lag_master(dev))\n\t\t\tice_dev = ice_eswitch_br_get_uplink_from_lag(dev);\n\t\telse\n\t\t\tice_dev = dev;\n\n\t\tif (!ice_dev)\n\t\t\treturn NULL;\n\n\t\tpf = ice_netdev_to_pf(ice_dev);\n\n\t\treturn pf->br_port;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nice_eswitch_br_ingress_rule_setup(struct ice_adv_rule_info *rule_info,\n\t\t\t\t  u8 pf_id, u16 vf_vsi_idx)\n{\n\trule_info->sw_act.vsi_handle = vf_vsi_idx;\n\trule_info->sw_act.flag |= ICE_FLTR_RX;\n\trule_info->sw_act.src = pf_id;\n\trule_info->priority = 5;\n}\n\nstatic void\nice_eswitch_br_egress_rule_setup(struct ice_adv_rule_info *rule_info,\n\t\t\t\t u16 pf_vsi_idx)\n{\n\trule_info->sw_act.vsi_handle = pf_vsi_idx;\n\trule_info->sw_act.flag |= ICE_FLTR_TX;\n\trule_info->flags_info.act = ICE_SINGLE_ACT_LAN_ENABLE;\n\trule_info->flags_info.act_valid = true;\n\trule_info->priority = 5;\n}\n\nstatic int\nice_eswitch_br_rule_delete(struct ice_hw *hw, struct ice_rule_query_data *rule)\n{\n\tint err;\n\n\tif (!rule)\n\t\treturn -EINVAL;\n\n\terr = ice_rem_adv_rule_by_id(hw, rule);\n\tkfree(rule);\n\n\treturn err;\n}\n\nstatic u16\nice_eswitch_br_get_lkups_cnt(u16 vid)\n{\n\treturn ice_eswitch_br_is_vid_valid(vid) ? 2 : 1;\n}\n\nstatic void\nice_eswitch_br_add_vlan_lkup(struct ice_adv_lkup_elem *list, u16 vid)\n{\n\tif (ice_eswitch_br_is_vid_valid(vid)) {\n\t\tlist[1].type = ICE_VLAN_OFOS;\n\t\tlist[1].h_u.vlan_hdr.vlan = cpu_to_be16(vid & VLAN_VID_MASK);\n\t\tlist[1].m_u.vlan_hdr.vlan = cpu_to_be16(0xFFFF);\n\t}\n}\n\nstatic struct ice_rule_query_data *\nice_eswitch_br_fwd_rule_create(struct ice_hw *hw, int vsi_idx, int port_type,\n\t\t\t       const unsigned char *mac, u16 vid)\n{\n\tstruct ice_adv_rule_info rule_info = { 0 };\n\tstruct ice_rule_query_data *rule;\n\tstruct ice_adv_lkup_elem *list;\n\tu16 lkups_cnt;\n\tint err;\n\n\tlkups_cnt = ice_eswitch_br_get_lkups_cnt(vid);\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlist = kcalloc(lkups_cnt, sizeof(*list), GFP_ATOMIC);\n\tif (!list) {\n\t\terr = -ENOMEM;\n\t\tgoto err_list_alloc;\n\t}\n\n\tswitch (port_type) {\n\tcase ICE_ESWITCH_BR_UPLINK_PORT:\n\t\tice_eswitch_br_egress_rule_setup(&rule_info, vsi_idx);\n\t\tbreak;\n\tcase ICE_ESWITCH_BR_VF_REPR_PORT:\n\t\tice_eswitch_br_ingress_rule_setup(&rule_info, hw->pf_id,\n\t\t\t\t\t\t  vsi_idx);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto err_add_rule;\n\t}\n\n\tlist[0].type = ICE_MAC_OFOS;\n\tether_addr_copy(list[0].h_u.eth_hdr.dst_addr, mac);\n\teth_broadcast_addr(list[0].m_u.eth_hdr.dst_addr);\n\n\tice_eswitch_br_add_vlan_lkup(list, vid);\n\n\trule_info.need_pass_l2 = true;\n\n\trule_info.sw_act.fltr_act = ICE_FWD_TO_VSI;\n\n\terr = ice_add_adv_rule(hw, list, lkups_cnt, &rule_info, rule);\n\tif (err)\n\t\tgoto err_add_rule;\n\n\tkfree(list);\n\n\treturn rule;\n\nerr_add_rule:\n\tkfree(list);\nerr_list_alloc:\n\tkfree(rule);\n\n\treturn ERR_PTR(err);\n}\n\nstatic struct ice_rule_query_data *\nice_eswitch_br_guard_rule_create(struct ice_hw *hw, u16 vsi_idx,\n\t\t\t\t const unsigned char *mac, u16 vid)\n{\n\tstruct ice_adv_rule_info rule_info = { 0 };\n\tstruct ice_rule_query_data *rule;\n\tstruct ice_adv_lkup_elem *list;\n\tint err = -ENOMEM;\n\tu16 lkups_cnt;\n\n\tlkups_cnt = ice_eswitch_br_get_lkups_cnt(vid);\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\tgoto err_exit;\n\n\tlist = kcalloc(lkups_cnt, sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\tgoto err_list_alloc;\n\n\tlist[0].type = ICE_MAC_OFOS;\n\tether_addr_copy(list[0].h_u.eth_hdr.src_addr, mac);\n\teth_broadcast_addr(list[0].m_u.eth_hdr.src_addr);\n\n\tice_eswitch_br_add_vlan_lkup(list, vid);\n\n\trule_info.allow_pass_l2 = true;\n\trule_info.sw_act.vsi_handle = vsi_idx;\n\trule_info.sw_act.fltr_act = ICE_NOP;\n\trule_info.priority = 5;\n\n\terr = ice_add_adv_rule(hw, list, lkups_cnt, &rule_info, rule);\n\tif (err)\n\t\tgoto err_add_rule;\n\n\tkfree(list);\n\n\treturn rule;\n\nerr_add_rule:\n\tkfree(list);\nerr_list_alloc:\n\tkfree(rule);\nerr_exit:\n\treturn ERR_PTR(err);\n}\n\nstatic struct ice_esw_br_flow *\nice_eswitch_br_flow_create(struct device *dev, struct ice_hw *hw, int vsi_idx,\n\t\t\t   int port_type, const unsigned char *mac, u16 vid)\n{\n\tstruct ice_rule_query_data *fwd_rule, *guard_rule;\n\tstruct ice_esw_br_flow *flow;\n\tint err;\n\n\tflow = kzalloc(sizeof(*flow), GFP_KERNEL);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfwd_rule = ice_eswitch_br_fwd_rule_create(hw, vsi_idx, port_type, mac,\n\t\t\t\t\t\t  vid);\n\terr = PTR_ERR_OR_ZERO(fwd_rule);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to create eswitch bridge %sgress forward rule, err: %d\\n\",\n\t\t\tport_type == ICE_ESWITCH_BR_UPLINK_PORT ? \"e\" : \"in\",\n\t\t\terr);\n\t\tgoto err_fwd_rule;\n\t}\n\n\tguard_rule = ice_eswitch_br_guard_rule_create(hw, vsi_idx, mac, vid);\n\terr = PTR_ERR_OR_ZERO(guard_rule);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to create eswitch bridge %sgress guard rule, err: %d\\n\",\n\t\t\tport_type == ICE_ESWITCH_BR_UPLINK_PORT ? \"e\" : \"in\",\n\t\t\terr);\n\t\tgoto err_guard_rule;\n\t}\n\n\tflow->fwd_rule = fwd_rule;\n\tflow->guard_rule = guard_rule;\n\n\treturn flow;\n\nerr_guard_rule:\n\tice_eswitch_br_rule_delete(hw, fwd_rule);\nerr_fwd_rule:\n\tkfree(flow);\n\n\treturn ERR_PTR(err);\n}\n\nstatic struct ice_esw_br_fdb_entry *\nice_eswitch_br_fdb_find(struct ice_esw_br *bridge, const unsigned char *mac,\n\t\t\tu16 vid)\n{\n\tstruct ice_esw_br_fdb_data data = {\n\t\t.vid = vid,\n\t};\n\n\tether_addr_copy(data.addr, mac);\n\treturn rhashtable_lookup_fast(&bridge->fdb_ht, &data,\n\t\t\t\t      ice_fdb_ht_params);\n}\n\nstatic void\nice_eswitch_br_flow_delete(struct ice_pf *pf, struct ice_esw_br_flow *flow)\n{\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tint err;\n\n\terr = ice_eswitch_br_rule_delete(&pf->hw, flow->fwd_rule);\n\tif (err)\n\t\tdev_err(dev, \"Failed to delete FDB forward rule, err: %d\\n\",\n\t\t\terr);\n\n\terr = ice_eswitch_br_rule_delete(&pf->hw, flow->guard_rule);\n\tif (err)\n\t\tdev_err(dev, \"Failed to delete FDB guard rule, err: %d\\n\",\n\t\t\terr);\n\n\tkfree(flow);\n}\n\nstatic struct ice_esw_br_vlan *\nice_esw_br_port_vlan_lookup(struct ice_esw_br *bridge, u16 vsi_idx, u16 vid)\n{\n\tstruct ice_pf *pf = bridge->br_offloads->pf;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_esw_br_port *port;\n\tstruct ice_esw_br_vlan *vlan;\n\n\tport = xa_load(&bridge->ports, vsi_idx);\n\tif (!port) {\n\t\tdev_info(dev, \"Bridge port lookup failed (vsi=%u)\\n\", vsi_idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvlan = xa_load(&port->vlans, vid);\n\tif (!vlan) {\n\t\tdev_info(dev, \"Bridge port vlan metadata lookup failed (vsi=%u)\\n\",\n\t\t\t vsi_idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn vlan;\n}\n\nstatic void\nice_eswitch_br_fdb_entry_delete(struct ice_esw_br *bridge,\n\t\t\t\tstruct ice_esw_br_fdb_entry *fdb_entry)\n{\n\tstruct ice_pf *pf = bridge->br_offloads->pf;\n\n\trhashtable_remove_fast(&bridge->fdb_ht, &fdb_entry->ht_node,\n\t\t\t       ice_fdb_ht_params);\n\tlist_del(&fdb_entry->list);\n\n\tice_eswitch_br_flow_delete(pf, fdb_entry->flow);\n\n\tkfree(fdb_entry);\n}\n\nstatic void\nice_eswitch_br_fdb_offload_notify(struct net_device *dev,\n\t\t\t\t  const unsigned char *mac, u16 vid,\n\t\t\t\t  unsigned long val)\n{\n\tstruct switchdev_notifier_fdb_info fdb_info = {\n\t\t.addr = mac,\n\t\t.vid = vid,\n\t\t.offloaded = true,\n\t};\n\n\tcall_switchdev_notifiers(val, dev, &fdb_info.info, NULL);\n}\n\nstatic void\nice_eswitch_br_fdb_entry_notify_and_cleanup(struct ice_esw_br *bridge,\n\t\t\t\t\t    struct ice_esw_br_fdb_entry *entry)\n{\n\tif (!(entry->flags & ICE_ESWITCH_BR_FDB_ADDED_BY_USER))\n\t\tice_eswitch_br_fdb_offload_notify(entry->dev, entry->data.addr,\n\t\t\t\t\t\t  entry->data.vid,\n\t\t\t\t\t\t  SWITCHDEV_FDB_DEL_TO_BRIDGE);\n\tice_eswitch_br_fdb_entry_delete(bridge, entry);\n}\n\nstatic void\nice_eswitch_br_fdb_entry_find_and_delete(struct ice_esw_br *bridge,\n\t\t\t\t\t const unsigned char *mac, u16 vid)\n{\n\tstruct ice_pf *pf = bridge->br_offloads->pf;\n\tstruct ice_esw_br_fdb_entry *fdb_entry;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\n\tfdb_entry = ice_eswitch_br_fdb_find(bridge, mac, vid);\n\tif (!fdb_entry) {\n\t\tdev_err(dev, \"FDB entry with mac: %pM and vid: %u not found\\n\",\n\t\t\tmac, vid);\n\t\treturn;\n\t}\n\n\ttrace_ice_eswitch_br_fdb_entry_find_and_delete(fdb_entry);\n\tice_eswitch_br_fdb_entry_notify_and_cleanup(bridge, fdb_entry);\n}\n\nstatic void\nice_eswitch_br_fdb_entry_create(struct net_device *netdev,\n\t\t\t\tstruct ice_esw_br_port *br_port,\n\t\t\t\tbool added_by_user,\n\t\t\t\tconst unsigned char *mac, u16 vid)\n{\n\tstruct ice_esw_br *bridge = br_port->bridge;\n\tstruct ice_pf *pf = bridge->br_offloads->pf;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_esw_br_fdb_entry *fdb_entry;\n\tstruct ice_esw_br_flow *flow;\n\tstruct ice_esw_br_vlan *vlan;\n\tstruct ice_hw *hw = &pf->hw;\n\tunsigned long event;\n\tint err;\n\n\t \n\tif (!(bridge->flags & ICE_ESWITCH_BR_VLAN_FILTERING) && vid)\n\t\treturn;\n\n\tif ((bridge->flags & ICE_ESWITCH_BR_VLAN_FILTERING)) {\n\t\tvlan = ice_esw_br_port_vlan_lookup(bridge, br_port->vsi_idx,\n\t\t\t\t\t\t   vid);\n\t\tif (IS_ERR(vlan)) {\n\t\t\tdev_err(dev, \"Failed to find vlan lookup, err: %ld\\n\",\n\t\t\t\tPTR_ERR(vlan));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfdb_entry = ice_eswitch_br_fdb_find(bridge, mac, vid);\n\tif (fdb_entry)\n\t\tice_eswitch_br_fdb_entry_notify_and_cleanup(bridge, fdb_entry);\n\n\tfdb_entry = kzalloc(sizeof(*fdb_entry), GFP_KERNEL);\n\tif (!fdb_entry) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tflow = ice_eswitch_br_flow_create(dev, hw, br_port->vsi_idx,\n\t\t\t\t\t  br_port->type, mac, vid);\n\tif (IS_ERR(flow)) {\n\t\terr = PTR_ERR(flow);\n\t\tgoto err_add_flow;\n\t}\n\n\tether_addr_copy(fdb_entry->data.addr, mac);\n\tfdb_entry->data.vid = vid;\n\tfdb_entry->br_port = br_port;\n\tfdb_entry->flow = flow;\n\tfdb_entry->dev = netdev;\n\tfdb_entry->last_use = jiffies;\n\tevent = SWITCHDEV_FDB_ADD_TO_BRIDGE;\n\n\tif (added_by_user) {\n\t\tfdb_entry->flags |= ICE_ESWITCH_BR_FDB_ADDED_BY_USER;\n\t\tevent = SWITCHDEV_FDB_OFFLOADED;\n\t}\n\n\terr = rhashtable_insert_fast(&bridge->fdb_ht, &fdb_entry->ht_node,\n\t\t\t\t     ice_fdb_ht_params);\n\tif (err)\n\t\tgoto err_fdb_insert;\n\n\tlist_add(&fdb_entry->list, &bridge->fdb_list);\n\ttrace_ice_eswitch_br_fdb_entry_create(fdb_entry);\n\n\tice_eswitch_br_fdb_offload_notify(netdev, mac, vid, event);\n\n\treturn;\n\nerr_fdb_insert:\n\tice_eswitch_br_flow_delete(pf, flow);\nerr_add_flow:\n\tkfree(fdb_entry);\nerr_exit:\n\tdev_err(dev, \"Failed to create fdb entry, err: %d\\n\", err);\n}\n\nstatic void\nice_eswitch_br_fdb_work_dealloc(struct ice_esw_br_fdb_work *fdb_work)\n{\n\tkfree(fdb_work->fdb_info.addr);\n\tkfree(fdb_work);\n}\n\nstatic void\nice_eswitch_br_fdb_event_work(struct work_struct *work)\n{\n\tstruct ice_esw_br_fdb_work *fdb_work = ice_work_to_fdb_work(work);\n\tbool added_by_user = fdb_work->fdb_info.added_by_user;\n\tconst unsigned char *mac = fdb_work->fdb_info.addr;\n\tu16 vid = fdb_work->fdb_info.vid;\n\tstruct ice_esw_br_port *br_port;\n\n\trtnl_lock();\n\n\tbr_port = ice_eswitch_br_netdev_to_port(fdb_work->dev);\n\tif (!br_port)\n\t\tgoto err_exit;\n\n\tswitch (fdb_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tice_eswitch_br_fdb_entry_create(fdb_work->dev, br_port,\n\t\t\t\t\t\tadded_by_user, mac, vid);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tice_eswitch_br_fdb_entry_find_and_delete(br_port->bridge,\n\t\t\t\t\t\t\t mac, vid);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_exit;\n\t}\n\nerr_exit:\n\trtnl_unlock();\n\tdev_put(fdb_work->dev);\n\tice_eswitch_br_fdb_work_dealloc(fdb_work);\n}\n\nstatic struct ice_esw_br_fdb_work *\nice_eswitch_br_fdb_work_alloc(struct switchdev_notifier_fdb_info *fdb_info,\n\t\t\t      struct net_device *dev,\n\t\t\t      unsigned long event)\n{\n\tstruct ice_esw_br_fdb_work *work;\n\tunsigned char *mac;\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&work->work, ice_eswitch_br_fdb_event_work);\n\tmemcpy(&work->fdb_info, fdb_info, sizeof(work->fdb_info));\n\n\tmac = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\tif (!mac) {\n\t\tkfree(work);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tether_addr_copy(mac, fdb_info->addr);\n\twork->fdb_info.addr = mac;\n\twork->event = event;\n\twork->dev = dev;\n\n\treturn work;\n}\n\nstatic int\nice_eswitch_br_switchdev_event(struct notifier_block *nb,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct switchdev_notifier_info *info = ptr;\n\tstruct ice_esw_br_offloads *br_offloads;\n\tstruct ice_esw_br_fdb_work *work;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper;\n\n\tbr_offloads = ice_nb_to_br_offloads(nb, switchdev_nb);\n\textack = switchdev_notifier_info_to_extack(ptr);\n\n\tupper = netdev_master_upper_dev_get_rcu(dev);\n\tif (!upper)\n\t\treturn NOTIFY_DONE;\n\n\tif (!netif_is_bridge_master(upper))\n\t\treturn NOTIFY_DONE;\n\n\tif (!ice_eswitch_br_is_dev_valid(dev))\n\t\treturn NOTIFY_DONE;\n\n\tif (!ice_eswitch_br_netdev_to_port(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb_info = container_of(info, typeof(*fdb_info), info);\n\n\t\twork = ice_eswitch_br_fdb_work_alloc(fdb_info, dev, event);\n\t\tif (IS_ERR(work)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to init switchdev fdb work\");\n\t\t\treturn notifier_from_errno(PTR_ERR(work));\n\t\t}\n\t\tdev_hold(dev);\n\n\t\tqueue_work(br_offloads->wq, &work->work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic void ice_eswitch_br_fdb_flush(struct ice_esw_br *bridge)\n{\n\tstruct ice_esw_br_fdb_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list)\n\t\tice_eswitch_br_fdb_entry_notify_and_cleanup(bridge, entry);\n}\n\nstatic void\nice_eswitch_br_vlan_filtering_set(struct ice_esw_br *bridge, bool enable)\n{\n\tif (enable == !!(bridge->flags & ICE_ESWITCH_BR_VLAN_FILTERING))\n\t\treturn;\n\n\tice_eswitch_br_fdb_flush(bridge);\n\tif (enable)\n\t\tbridge->flags |= ICE_ESWITCH_BR_VLAN_FILTERING;\n\telse\n\t\tbridge->flags &= ~ICE_ESWITCH_BR_VLAN_FILTERING;\n}\n\nstatic void\nice_eswitch_br_clear_pvid(struct ice_esw_br_port *port)\n{\n\tstruct ice_vlan port_vlan = ICE_VLAN(ETH_P_8021Q, port->pvid, 0);\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(port->vsi);\n\n\tvlan_ops->del_vlan(port->vsi, &port_vlan);\n\tvlan_ops->clear_port_vlan(port->vsi);\n\n\tice_vf_vsi_disable_port_vlan(port->vsi);\n\n\tport->pvid = 0;\n}\n\nstatic void\nice_eswitch_br_vlan_cleanup(struct ice_esw_br_port *port,\n\t\t\t    struct ice_esw_br_vlan *vlan)\n{\n\tstruct ice_esw_br_fdb_entry *fdb_entry, *tmp;\n\tstruct ice_esw_br *bridge = port->bridge;\n\n\ttrace_ice_eswitch_br_vlan_cleanup(vlan);\n\n\tlist_for_each_entry_safe(fdb_entry, tmp, &bridge->fdb_list, list) {\n\t\tif (vlan->vid == fdb_entry->data.vid)\n\t\t\tice_eswitch_br_fdb_entry_delete(bridge, fdb_entry);\n\t}\n\n\txa_erase(&port->vlans, vlan->vid);\n\tif (port->pvid == vlan->vid)\n\t\tice_eswitch_br_clear_pvid(port);\n\tkfree(vlan);\n}\n\nstatic void ice_eswitch_br_port_vlans_flush(struct ice_esw_br_port *port)\n{\n\tstruct ice_esw_br_vlan *vlan;\n\tunsigned long index;\n\n\txa_for_each(&port->vlans, index, vlan)\n\t\tice_eswitch_br_vlan_cleanup(port, vlan);\n}\n\nstatic int\nice_eswitch_br_set_pvid(struct ice_esw_br_port *port,\n\t\t\tstruct ice_esw_br_vlan *vlan)\n{\n\tstruct ice_vlan port_vlan = ICE_VLAN(ETH_P_8021Q, vlan->vid, 0);\n\tstruct device *dev = ice_pf_to_dev(port->vsi->back);\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\tint err;\n\n\tif (port->pvid == vlan->vid || vlan->vid == 1)\n\t\treturn 0;\n\n\t \n\tif (port->type == ICE_ESWITCH_BR_UPLINK_PORT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (port->pvid) {\n\t\tdev_info(dev,\n\t\t\t \"Port VLAN (vsi=%u, vid=%u) already exists on the port, remove it before adding new one\\n\",\n\t\t\t port->vsi_idx, port->pvid);\n\t\treturn -EEXIST;\n\t}\n\n\tice_vf_vsi_enable_port_vlan(port->vsi);\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(port->vsi);\n\terr = vlan_ops->set_port_vlan(port->vsi, &port_vlan);\n\tif (err)\n\t\treturn err;\n\n\terr = vlan_ops->add_vlan(port->vsi, &port_vlan);\n\tif (err)\n\t\treturn err;\n\n\tice_eswitch_br_port_vlans_flush(port);\n\tport->pvid = vlan->vid;\n\n\treturn 0;\n}\n\nstatic struct ice_esw_br_vlan *\nice_eswitch_br_vlan_create(u16 vid, u16 flags, struct ice_esw_br_port *port)\n{\n\tstruct device *dev = ice_pf_to_dev(port->vsi->back);\n\tstruct ice_esw_br_vlan *vlan;\n\tint err;\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvlan->vid = vid;\n\tvlan->flags = flags;\n\tif ((flags & BRIDGE_VLAN_INFO_PVID) &&\n\t    (flags & BRIDGE_VLAN_INFO_UNTAGGED)) {\n\t\terr = ice_eswitch_br_set_pvid(port, vlan);\n\t\tif (err)\n\t\t\tgoto err_set_pvid;\n\t} else if ((flags & BRIDGE_VLAN_INFO_PVID) ||\n\t\t   (flags & BRIDGE_VLAN_INFO_UNTAGGED)) {\n\t\tdev_info(dev, \"VLAN push and pop are supported only simultaneously\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_set_pvid;\n\t}\n\n\terr = xa_insert(&port->vlans, vlan->vid, vlan, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_insert;\n\n\ttrace_ice_eswitch_br_vlan_create(vlan);\n\n\treturn vlan;\n\nerr_insert:\n\tif (port->pvid)\n\t\tice_eswitch_br_clear_pvid(port);\nerr_set_pvid:\n\tkfree(vlan);\n\treturn ERR_PTR(err);\n}\n\nstatic int\nice_eswitch_br_port_vlan_add(struct ice_esw_br *bridge, u16 vsi_idx, u16 vid,\n\t\t\t     u16 flags, struct netlink_ext_ack *extack)\n{\n\tstruct ice_esw_br_port *port;\n\tstruct ice_esw_br_vlan *vlan;\n\n\tport = xa_load(&bridge->ports, vsi_idx);\n\tif (!port)\n\t\treturn -EINVAL;\n\n\tif (port->pvid) {\n\t\tdev_info(ice_pf_to_dev(port->vsi->back),\n\t\t\t \"Port VLAN (vsi=%u, vid=%d) exists on the port, remove it to add trunk VLANs\\n\",\n\t\t\t port->vsi_idx, port->pvid);\n\t\treturn -EEXIST;\n\t}\n\n\tvlan = xa_load(&port->vlans, vid);\n\tif (vlan) {\n\t\tif (vlan->flags == flags)\n\t\t\treturn 0;\n\n\t\tice_eswitch_br_vlan_cleanup(port, vlan);\n\t}\n\n\tvlan = ice_eswitch_br_vlan_create(vid, flags, port);\n\tif (IS_ERR(vlan)) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Failed to create VLAN entry, vid: %u, vsi: %u\",\n\t\t\t\t       vid, vsi_idx);\n\t\treturn PTR_ERR(vlan);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nice_eswitch_br_port_vlan_del(struct ice_esw_br *bridge, u16 vsi_idx, u16 vid)\n{\n\tstruct ice_esw_br_port *port;\n\tstruct ice_esw_br_vlan *vlan;\n\n\tport = xa_load(&bridge->ports, vsi_idx);\n\tif (!port)\n\t\treturn;\n\n\tvlan = xa_load(&port->vlans, vid);\n\tif (!vlan)\n\t\treturn;\n\n\tice_eswitch_br_vlan_cleanup(port, vlan);\n}\n\nstatic int\nice_eswitch_br_port_obj_add(struct net_device *netdev, const void *ctx,\n\t\t\t    const struct switchdev_obj *obj,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ice_esw_br_port *br_port = ice_eswitch_br_netdev_to_port(netdev);\n\tstruct switchdev_obj_port_vlan *vlan;\n\tint err;\n\n\tif (!br_port)\n\t\treturn -EINVAL;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\t\terr = ice_eswitch_br_port_vlan_add(br_port->bridge,\n\t\t\t\t\t\t   br_port->vsi_idx, vlan->vid,\n\t\t\t\t\t\t   vlan->flags, extack);\n\t\treturn err;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nice_eswitch_br_port_obj_del(struct net_device *netdev, const void *ctx,\n\t\t\t    const struct switchdev_obj *obj)\n{\n\tstruct ice_esw_br_port *br_port = ice_eswitch_br_netdev_to_port(netdev);\n\tstruct switchdev_obj_port_vlan *vlan;\n\n\tif (!br_port)\n\t\treturn -EINVAL;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\t\tice_eswitch_br_port_vlan_del(br_port->bridge, br_port->vsi_idx,\n\t\t\t\t\t     vlan->vid);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nice_eswitch_br_port_obj_attr_set(struct net_device *netdev, const void *ctx,\n\t\t\t\t const struct switchdev_attr *attr,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ice_esw_br_port *br_port = ice_eswitch_br_netdev_to_port(netdev);\n\n\tif (!br_port)\n\t\treturn -EINVAL;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\tice_eswitch_br_vlan_filtering_set(br_port->bridge,\n\t\t\t\t\t\t  attr->u.vlan_filtering);\n\t\treturn 0;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\tbr_port->bridge->ageing_time =\n\t\t\tclock_t_to_jiffies(attr->u.ageing_time);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nice_eswitch_br_event_blocking(struct notifier_block *nb, unsigned long event,\n\t\t\t      void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = switchdev_handle_port_obj_add(dev, ptr,\n\t\t\t\t\t\t    ice_eswitch_br_is_dev_valid,\n\t\t\t\t\t\t    ice_eswitch_br_port_obj_add);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = switchdev_handle_port_obj_del(dev, ptr,\n\t\t\t\t\t\t    ice_eswitch_br_is_dev_valid,\n\t\t\t\t\t\t    ice_eswitch_br_port_obj_del);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     ice_eswitch_br_is_dev_valid,\n\t\t\t\t\t\t     ice_eswitch_br_port_obj_attr_set);\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\nstatic void\nice_eswitch_br_port_deinit(struct ice_esw_br *bridge,\n\t\t\t   struct ice_esw_br_port *br_port)\n{\n\tstruct ice_esw_br_fdb_entry *fdb_entry, *tmp;\n\tstruct ice_vsi *vsi = br_port->vsi;\n\n\tlist_for_each_entry_safe(fdb_entry, tmp, &bridge->fdb_list, list) {\n\t\tif (br_port == fdb_entry->br_port)\n\t\t\tice_eswitch_br_fdb_entry_delete(bridge, fdb_entry);\n\t}\n\n\tif (br_port->type == ICE_ESWITCH_BR_UPLINK_PORT && vsi->back)\n\t\tvsi->back->br_port = NULL;\n\telse if (vsi->vf && vsi->vf->repr)\n\t\tvsi->vf->repr->br_port = NULL;\n\n\txa_erase(&bridge->ports, br_port->vsi_idx);\n\tice_eswitch_br_port_vlans_flush(br_port);\n\tkfree(br_port);\n}\n\nstatic struct ice_esw_br_port *\nice_eswitch_br_port_init(struct ice_esw_br *bridge)\n{\n\tstruct ice_esw_br_port *br_port;\n\n\tbr_port = kzalloc(sizeof(*br_port), GFP_KERNEL);\n\tif (!br_port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\txa_init(&br_port->vlans);\n\n\tbr_port->bridge = bridge;\n\n\treturn br_port;\n}\n\nstatic int\nice_eswitch_br_vf_repr_port_init(struct ice_esw_br *bridge,\n\t\t\t\t struct ice_repr *repr)\n{\n\tstruct ice_esw_br_port *br_port;\n\tint err;\n\n\tbr_port = ice_eswitch_br_port_init(bridge);\n\tif (IS_ERR(br_port))\n\t\treturn PTR_ERR(br_port);\n\n\tbr_port->vsi = repr->src_vsi;\n\tbr_port->vsi_idx = br_port->vsi->idx;\n\tbr_port->type = ICE_ESWITCH_BR_VF_REPR_PORT;\n\trepr->br_port = br_port;\n\n\terr = xa_insert(&bridge->ports, br_port->vsi_idx, br_port, GFP_KERNEL);\n\tif (err) {\n\t\tice_eswitch_br_port_deinit(bridge, br_port);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nice_eswitch_br_uplink_port_init(struct ice_esw_br *bridge, struct ice_pf *pf)\n{\n\tstruct ice_vsi *vsi = pf->switchdev.uplink_vsi;\n\tstruct ice_esw_br_port *br_port;\n\tint err;\n\n\tbr_port = ice_eswitch_br_port_init(bridge);\n\tif (IS_ERR(br_port))\n\t\treturn PTR_ERR(br_port);\n\n\tbr_port->vsi = vsi;\n\tbr_port->vsi_idx = br_port->vsi->idx;\n\tbr_port->type = ICE_ESWITCH_BR_UPLINK_PORT;\n\tpf->br_port = br_port;\n\n\terr = xa_insert(&bridge->ports, br_port->vsi_idx, br_port, GFP_KERNEL);\n\tif (err) {\n\t\tice_eswitch_br_port_deinit(bridge, br_port);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nice_eswitch_br_ports_flush(struct ice_esw_br *bridge)\n{\n\tstruct ice_esw_br_port *port;\n\tunsigned long i;\n\n\txa_for_each(&bridge->ports, i, port)\n\t\tice_eswitch_br_port_deinit(bridge, port);\n}\n\nstatic void\nice_eswitch_br_deinit(struct ice_esw_br_offloads *br_offloads,\n\t\t      struct ice_esw_br *bridge)\n{\n\tif (!bridge)\n\t\treturn;\n\n\t \n\tice_eswitch_br_ports_flush(bridge);\n\tWARN_ON(!xa_empty(&bridge->ports));\n\txa_destroy(&bridge->ports);\n\trhashtable_destroy(&bridge->fdb_ht);\n\n\tbr_offloads->bridge = NULL;\n\tkfree(bridge);\n}\n\nstatic struct ice_esw_br *\nice_eswitch_br_init(struct ice_esw_br_offloads *br_offloads, int ifindex)\n{\n\tstruct ice_esw_br *bridge;\n\tint err;\n\n\tbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = rhashtable_init(&bridge->fdb_ht, &ice_fdb_ht_params);\n\tif (err) {\n\t\tkfree(bridge);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tINIT_LIST_HEAD(&bridge->fdb_list);\n\tbridge->br_offloads = br_offloads;\n\tbridge->ifindex = ifindex;\n\tbridge->ageing_time = clock_t_to_jiffies(BR_DEFAULT_AGEING_TIME);\n\txa_init(&bridge->ports);\n\tbr_offloads->bridge = bridge;\n\n\treturn bridge;\n}\n\nstatic struct ice_esw_br *\nice_eswitch_br_get(struct ice_esw_br_offloads *br_offloads, int ifindex,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ice_esw_br *bridge = br_offloads->bridge;\n\n\tif (bridge) {\n\t\tif (bridge->ifindex != ifindex) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only one bridge is supported per eswitch\");\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\t\treturn bridge;\n\t}\n\n\t \n\tbridge = ice_eswitch_br_init(br_offloads, ifindex);\n\tif (IS_ERR(bridge))\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to init the bridge\");\n\n\treturn bridge;\n}\n\nstatic void\nice_eswitch_br_verify_deinit(struct ice_esw_br_offloads *br_offloads,\n\t\t\t     struct ice_esw_br *bridge)\n{\n\t \n\tif (!bridge || !xa_empty(&bridge->ports))\n\t\treturn;\n\n\tice_eswitch_br_deinit(br_offloads, bridge);\n}\n\nstatic int\nice_eswitch_br_port_unlink(struct ice_esw_br_offloads *br_offloads,\n\t\t\t   struct net_device *dev, int ifindex,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ice_esw_br_port *br_port = ice_eswitch_br_netdev_to_port(dev);\n\tstruct ice_esw_br *bridge;\n\n\tif (!br_port) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port representor is not attached to any bridge\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (br_port->bridge->ifindex != ifindex) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port representor is attached to another bridge\");\n\t\treturn -EINVAL;\n\t}\n\n\tbridge = br_port->bridge;\n\n\ttrace_ice_eswitch_br_port_unlink(br_port);\n\tice_eswitch_br_port_deinit(br_port->bridge, br_port);\n\tice_eswitch_br_verify_deinit(br_offloads, bridge);\n\n\treturn 0;\n}\n\nstatic int\nice_eswitch_br_port_link(struct ice_esw_br_offloads *br_offloads,\n\t\t\t struct net_device *dev, int ifindex,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ice_esw_br *bridge;\n\tint err;\n\n\tif (ice_eswitch_br_netdev_to_port(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port is already attached to the bridge\");\n\t\treturn -EINVAL;\n\t}\n\n\tbridge = ice_eswitch_br_get(br_offloads, ifindex, extack);\n\tif (IS_ERR(bridge))\n\t\treturn PTR_ERR(bridge);\n\n\tif (ice_is_port_repr_netdev(dev)) {\n\t\tstruct ice_repr *repr = ice_netdev_to_repr(dev);\n\n\t\terr = ice_eswitch_br_vf_repr_port_init(bridge, repr);\n\t\ttrace_ice_eswitch_br_port_link(repr->br_port);\n\t} else {\n\t\tstruct net_device *ice_dev;\n\t\tstruct ice_pf *pf;\n\n\t\tif (netif_is_lag_master(dev))\n\t\t\tice_dev = ice_eswitch_br_get_uplink_from_lag(dev);\n\t\telse\n\t\t\tice_dev = dev;\n\n\t\tif (!ice_dev)\n\t\t\treturn 0;\n\n\t\tpf = ice_netdev_to_pf(ice_dev);\n\n\t\terr = ice_eswitch_br_uplink_port_init(bridge, pf);\n\t\ttrace_ice_eswitch_br_port_link(pf->br_port);\n\t}\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to init bridge port\");\n\t\tgoto err_port_init;\n\t}\n\n\treturn 0;\n\nerr_port_init:\n\tice_eswitch_br_verify_deinit(br_offloads, bridge);\n\treturn err;\n}\n\nstatic int\nice_eswitch_br_port_changeupper(struct notifier_block *nb, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct ice_esw_br_offloads *br_offloads;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper;\n\n\tbr_offloads = ice_nb_to_br_offloads(nb, netdev_nb);\n\n\tif (!ice_eswitch_br_is_dev_valid(dev))\n\t\treturn 0;\n\n\tupper = info->upper_dev;\n\tif (!netif_is_bridge_master(upper))\n\t\treturn 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (info->linking)\n\t\treturn ice_eswitch_br_port_link(br_offloads, dev,\n\t\t\t\t\t\tupper->ifindex, extack);\n\telse\n\t\treturn ice_eswitch_br_port_unlink(br_offloads, dev,\n\t\t\t\t\t\t  upper->ifindex, extack);\n}\n\nstatic int\nice_eswitch_br_port_event(struct notifier_block *nb,\n\t\t\t  unsigned long event, void *ptr)\n{\n\tint err = 0;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\terr = ice_eswitch_br_port_changeupper(nb, ptr);\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\nstatic void\nice_eswitch_br_offloads_dealloc(struct ice_pf *pf)\n{\n\tstruct ice_esw_br_offloads *br_offloads = pf->switchdev.br_offloads;\n\n\tASSERT_RTNL();\n\n\tif (!br_offloads)\n\t\treturn;\n\n\tice_eswitch_br_deinit(br_offloads, br_offloads->bridge);\n\n\tpf->switchdev.br_offloads = NULL;\n\tkfree(br_offloads);\n}\n\nstatic struct ice_esw_br_offloads *\nice_eswitch_br_offloads_alloc(struct ice_pf *pf)\n{\n\tstruct ice_esw_br_offloads *br_offloads;\n\n\tASSERT_RTNL();\n\n\tif (pf->switchdev.br_offloads)\n\t\treturn ERR_PTR(-EEXIST);\n\n\tbr_offloads = kzalloc(sizeof(*br_offloads), GFP_KERNEL);\n\tif (!br_offloads)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpf->switchdev.br_offloads = br_offloads;\n\tbr_offloads->pf = pf;\n\n\treturn br_offloads;\n}\n\nvoid\nice_eswitch_br_offloads_deinit(struct ice_pf *pf)\n{\n\tstruct ice_esw_br_offloads *br_offloads;\n\n\tbr_offloads = pf->switchdev.br_offloads;\n\tif (!br_offloads)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&br_offloads->update_work);\n\tunregister_netdevice_notifier(&br_offloads->netdev_nb);\n\tunregister_switchdev_blocking_notifier(&br_offloads->switchdev_blk);\n\tunregister_switchdev_notifier(&br_offloads->switchdev_nb);\n\tdestroy_workqueue(br_offloads->wq);\n\t \n\trtnl_lock();\n\tice_eswitch_br_offloads_dealloc(pf);\n\trtnl_unlock();\n}\n\nstatic void ice_eswitch_br_update(struct ice_esw_br_offloads *br_offloads)\n{\n\tstruct ice_esw_br *bridge = br_offloads->bridge;\n\tstruct ice_esw_br_fdb_entry *entry, *tmp;\n\n\tif (!bridge)\n\t\treturn;\n\n\trtnl_lock();\n\tlist_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list) {\n\t\tif (entry->flags & ICE_ESWITCH_BR_FDB_ADDED_BY_USER)\n\t\t\tcontinue;\n\n\t\tif (time_is_after_eq_jiffies(entry->last_use +\n\t\t\t\t\t     bridge->ageing_time))\n\t\t\tcontinue;\n\n\t\tice_eswitch_br_fdb_entry_notify_and_cleanup(bridge, entry);\n\t}\n\trtnl_unlock();\n}\n\nstatic void ice_eswitch_br_update_work(struct work_struct *work)\n{\n\tstruct ice_esw_br_offloads *br_offloads;\n\n\tbr_offloads = ice_work_to_br_offloads(work);\n\n\tice_eswitch_br_update(br_offloads);\n\n\tqueue_delayed_work(br_offloads->wq, &br_offloads->update_work,\n\t\t\t   ICE_ESW_BRIDGE_UPDATE_INTERVAL);\n}\n\nint\nice_eswitch_br_offloads_init(struct ice_pf *pf)\n{\n\tstruct ice_esw_br_offloads *br_offloads;\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tint err;\n\n\trtnl_lock();\n\tbr_offloads = ice_eswitch_br_offloads_alloc(pf);\n\trtnl_unlock();\n\tif (IS_ERR(br_offloads)) {\n\t\tdev_err(dev, \"Failed to init eswitch bridge\\n\");\n\t\treturn PTR_ERR(br_offloads);\n\t}\n\n\tbr_offloads->wq = alloc_ordered_workqueue(\"ice_bridge_wq\", 0);\n\tif (!br_offloads->wq) {\n\t\terr = -ENOMEM;\n\t\tdev_err(dev, \"Failed to allocate bridge workqueue\\n\");\n\t\tgoto err_alloc_wq;\n\t}\n\n\tbr_offloads->switchdev_nb.notifier_call =\n\t\tice_eswitch_br_switchdev_event;\n\terr = register_switchdev_notifier(&br_offloads->switchdev_nb);\n\tif (err) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to register switchdev notifier\\n\");\n\t\tgoto err_reg_switchdev_nb;\n\t}\n\n\tbr_offloads->switchdev_blk.notifier_call =\n\t\tice_eswitch_br_event_blocking;\n\terr = register_switchdev_blocking_notifier(&br_offloads->switchdev_blk);\n\tif (err) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to register bridge blocking switchdev notifier\\n\");\n\t\tgoto err_reg_switchdev_blk;\n\t}\n\n\tbr_offloads->netdev_nb.notifier_call = ice_eswitch_br_port_event;\n\terr = register_netdevice_notifier(&br_offloads->netdev_nb);\n\tif (err) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to register bridge port event notifier\\n\");\n\t\tgoto err_reg_netdev_nb;\n\t}\n\n\tINIT_DELAYED_WORK(&br_offloads->update_work,\n\t\t\t  ice_eswitch_br_update_work);\n\tqueue_delayed_work(br_offloads->wq, &br_offloads->update_work,\n\t\t\t   ICE_ESW_BRIDGE_UPDATE_INTERVAL);\n\n\treturn 0;\n\nerr_reg_netdev_nb:\n\tunregister_switchdev_blocking_notifier(&br_offloads->switchdev_blk);\nerr_reg_switchdev_blk:\n\tunregister_switchdev_notifier(&br_offloads->switchdev_nb);\nerr_reg_switchdev_nb:\n\tdestroy_workqueue(br_offloads->wq);\nerr_alloc_wq:\n\trtnl_lock();\n\tice_eswitch_br_offloads_dealloc(pf);\n\trtnl_unlock();\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}