{
  "module_name": "ice.h",
  "hash_id": "4f938a28b5435877288bd2cf36a56f9b0cb5480d88c906dcecbc0b114d0fff71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice.h",
  "human_readable_source": " \n \n\n#ifndef _ICE_H_\n#define _ICE_H_\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/netdevice.h>\n#include <linux/compiler.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/cpumask.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_vlan.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/interrupt.h>\n#include <linux/ethtool.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/bitmap.h>\n#include <linux/log2.h>\n#include <linux/ip.h>\n#include <linux/sctp.h>\n#include <linux/ipv6.h>\n#include <linux/pkt_sched.h>\n#include <linux/if_bridge.h>\n#include <linux/ctype.h>\n#include <linux/linkmode.h>\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/auxiliary_bus.h>\n#include <linux/avf/virtchnl.h>\n#include <linux/cpu_rmap.h>\n#include <linux/dim.h>\n#include <linux/gnss.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <net/tc_act/tc_mirred.h>\n#include <net/tc_act/tc_gact.h>\n#include <net/ip.h>\n#include <net/devlink.h>\n#include <net/ipv6.h>\n#include <net/xdp_sock.h>\n#include <net/xdp_sock_drv.h>\n#include <net/geneve.h>\n#include <net/gre.h>\n#include <net/udp_tunnel.h>\n#include <net/vxlan.h>\n#include <net/gtp.h>\n#include <linux/ppp_defs.h>\n#include \"ice_devids.h\"\n#include \"ice_type.h\"\n#include \"ice_txrx.h\"\n#include \"ice_dcb.h\"\n#include \"ice_switch.h\"\n#include \"ice_common.h\"\n#include \"ice_flow.h\"\n#include \"ice_sched.h\"\n#include \"ice_idc_int.h\"\n#include \"ice_sriov.h\"\n#include \"ice_vf_mbx.h\"\n#include \"ice_ptp.h\"\n#include \"ice_fdir.h\"\n#include \"ice_xsk.h\"\n#include \"ice_arfs.h\"\n#include \"ice_repr.h\"\n#include \"ice_eswitch.h\"\n#include \"ice_lag.h\"\n#include \"ice_vsi_vlan_ops.h\"\n#include \"ice_gnss.h\"\n#include \"ice_irq.h\"\n\n#define ICE_BAR0\t\t0\n#define ICE_REQ_DESC_MULTIPLE\t32\n#define ICE_MIN_NUM_DESC\t64\n#define ICE_MAX_NUM_DESC\t8160\n#define ICE_DFLT_MIN_RX_DESC\t512\n#define ICE_DFLT_NUM_TX_DESC\t256\n#define ICE_DFLT_NUM_RX_DESC\t2048\n\n#define ICE_DFLT_TRAFFIC_CLASS\tBIT(0)\n#define ICE_INT_NAME_STR_LEN\t(IFNAMSIZ + 16)\n#define ICE_AQ_LEN\t\t192\n#define ICE_MBXSQ_LEN\t\t64\n#define ICE_SBQ_LEN\t\t64\n#define ICE_MIN_LAN_TXRX_MSIX\t1\n#define ICE_MIN_LAN_OICR_MSIX\t1\n#define ICE_MIN_MSIX\t\t(ICE_MIN_LAN_TXRX_MSIX + ICE_MIN_LAN_OICR_MSIX)\n#define ICE_FDIR_MSIX\t\t2\n#define ICE_RDMA_NUM_AEQ_MSIX\t4\n#define ICE_MIN_RDMA_MSIX\t2\n#define ICE_ESWITCH_MSIX\t1\n#define ICE_NO_VSI\t\t0xffff\n#define ICE_VSI_MAP_CONTIG\t0\n#define ICE_VSI_MAP_SCATTER\t1\n#define ICE_MAX_SCATTER_TXQS\t16\n#define ICE_MAX_SCATTER_RXQS\t16\n#define ICE_Q_WAIT_RETRY_LIMIT\t10\n#define ICE_Q_WAIT_MAX_RETRY\t(5 * ICE_Q_WAIT_RETRY_LIMIT)\n#define ICE_MAX_LG_RSS_QS\t256\n#define ICE_INVAL_Q_INDEX\t0xffff\n\n#define ICE_MAX_RXQS_PER_TC\t\t256\t \n\n#define ICE_CHNL_START_TC\t\t1\n\n#define ICE_MAX_RESET_WAIT\t\t20\n\n#define ICE_VSIQF_HKEY_ARRAY_SIZE\t((VSIQF_HKEY_MAX_INDEX + 1) *\t4)\n\n#define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)\n\n#define ICE_MAX_MTU\t(ICE_AQ_SET_MAC_FRAME_SIZE_MAX - ICE_ETH_PKT_HDR_PAD)\n\n#define ICE_MAX_TSO_SIZE 131072\n\n#define ICE_UP_TABLE_TRANSLATE(val, i) \\\n\t\t(((val) << ICE_AQ_VSI_UP_TABLE_UP##i##_S) & \\\n\t\t  ICE_AQ_VSI_UP_TABLE_UP##i##_M)\n\n#define ICE_TX_DESC(R, i) (&(((struct ice_tx_desc *)((R)->desc))[i]))\n#define ICE_RX_DESC(R, i) (&(((union ice_32b_rx_flex_desc *)((R)->desc))[i]))\n#define ICE_TX_CTX_DESC(R, i) (&(((struct ice_tx_ctx_desc *)((R)->desc))[i]))\n#define ICE_TX_FDIRDESC(R, i) (&(((struct ice_fltr_desc *)((R)->desc))[i]))\n\n \n#define ICE_MIN_BW_LIMIT\t\t500\n \n#define ICE_BW_KBPS_DIVISOR\t\t125\n\n \n#define ICE_SWITCH_FLTR_PRIO_QUEUE\t7\n \n#define ICE_SWITCH_FLTR_PRIO_RSVD\t6\n#define ICE_SWITCH_FLTR_PRIO_VSI\t5\n#define ICE_SWITCH_FLTR_PRIO_QGRP\tICE_SWITCH_FLTR_PRIO_VSI\n\n \n#define ice_for_each_vsi(pf, i) \\\n\tfor ((i) = 0; (i) < (pf)->num_alloc_vsi; (i)++)\n\n \n#define ice_for_each_txq(vsi, i) \\\n\tfor ((i) = 0; (i) < (vsi)->num_txq; (i)++)\n\n#define ice_for_each_xdp_txq(vsi, i) \\\n\tfor ((i) = 0; (i) < (vsi)->num_xdp_txq; (i)++)\n\n#define ice_for_each_rxq(vsi, i) \\\n\tfor ((i) = 0; (i) < (vsi)->num_rxq; (i)++)\n\n \n#define ice_for_each_alloc_txq(vsi, i) \\\n\tfor ((i) = 0; (i) < (vsi)->alloc_txq; (i)++)\n\n#define ice_for_each_alloc_rxq(vsi, i) \\\n\tfor ((i) = 0; (i) < (vsi)->alloc_rxq; (i)++)\n\n#define ice_for_each_q_vector(vsi, i) \\\n\tfor ((i) = 0; (i) < (vsi)->num_q_vectors; (i)++)\n\n#define ice_for_each_chnl_tc(i)\t\\\n\tfor ((i) = ICE_CHNL_START_TC; (i) < ICE_CHNL_MAX_TC; (i)++)\n\n#define ICE_UCAST_PROMISC_BITS (ICE_PROMISC_UCAST_TX | ICE_PROMISC_UCAST_RX)\n\n#define ICE_UCAST_VLAN_PROMISC_BITS (ICE_PROMISC_UCAST_TX | \\\n\t\t\t\t     ICE_PROMISC_UCAST_RX | \\\n\t\t\t\t     ICE_PROMISC_VLAN_TX  | \\\n\t\t\t\t     ICE_PROMISC_VLAN_RX)\n\n#define ICE_MCAST_PROMISC_BITS (ICE_PROMISC_MCAST_TX | ICE_PROMISC_MCAST_RX)\n\n#define ICE_MCAST_VLAN_PROMISC_BITS (ICE_PROMISC_MCAST_TX | \\\n\t\t\t\t     ICE_PROMISC_MCAST_RX | \\\n\t\t\t\t     ICE_PROMISC_VLAN_TX  | \\\n\t\t\t\t     ICE_PROMISC_VLAN_RX)\n\n#define ice_pf_to_dev(pf) (&((pf)->pdev->dev))\n\nenum ice_feature {\n\tICE_F_DSCP,\n\tICE_F_PTP_EXTTS,\n\tICE_F_SMA_CTRL,\n\tICE_F_GNSS,\n\tICE_F_ROCE_LAG,\n\tICE_F_SRIOV_LAG,\n\tICE_F_MAX\n};\n\nDECLARE_STATIC_KEY_FALSE(ice_xdp_locking_key);\n\nstruct ice_channel {\n\tstruct list_head list;\n\tu8 type;\n\tu16 sw_id;\n\tu16 base_q;\n\tu16 num_rxq;\n\tu16 num_txq;\n\tu16 vsi_num;\n\tu8 ena_tc;\n\tstruct ice_aqc_vsi_props info;\n\tu64 max_tx_rate;\n\tu64 min_tx_rate;\n\tatomic_t num_sb_fltr;\n\tstruct ice_vsi *ch_vsi;\n};\n\nstruct ice_txq_meta {\n\tu32 q_teid;\t \n\tu16 q_id;\t \n\tu16 q_handle;\t \n\tu16 vsi_idx;\t \n\tu8 tc;\t\t \n};\n\nstruct ice_tc_info {\n\tu16 qoffset;\n\tu16 qcount_tx;\n\tu16 qcount_rx;\n\tu8 netdev_tc;\n};\n\nstruct ice_tc_cfg {\n\tu8 numtc;  \n\tu16 ena_tc;  \n\tstruct ice_tc_info tc_info[ICE_MAX_TRAFFIC_CLASS];\n};\n\nstruct ice_qs_cfg {\n\tstruct mutex *qs_mutex;   \n\tunsigned long *pf_map;\n\tunsigned long pf_map_size;\n\tunsigned int q_count;\n\tunsigned int scatter_count;\n\tu16 *vsi_map;\n\tu16 vsi_map_offset;\n\tu8 mapping_mode;\n};\n\nstruct ice_sw {\n\tstruct ice_pf *pf;\n\tu16 sw_id;\t\t \n\tu16 bridge_mode;\t \n};\n\nenum ice_pf_state {\n\tICE_TESTING,\n\tICE_DOWN,\n\tICE_NEEDS_RESTART,\n\tICE_PREPARED_FOR_RESET,\t \n\tICE_RESET_OICR_RECV,\t\t \n\tICE_PFR_REQ,\t\t \n\tICE_CORER_REQ,\t\t \n\tICE_GLOBR_REQ,\t\t \n\tICE_CORER_RECV,\t\t \n\tICE_GLOBR_RECV,\t\t \n\tICE_EMPR_RECV,\t\t \n\tICE_SUSPENDED,\t\t \n\tICE_RESET_FAILED,\t\t \n\t \n\tICE_STATE_NOMINAL_CHECK_BITS,\n\tICE_ADMINQ_EVENT_PENDING,\n\tICE_MAILBOXQ_EVENT_PENDING,\n\tICE_SIDEBANDQ_EVENT_PENDING,\n\tICE_MDD_EVENT_PENDING,\n\tICE_VFLR_EVENT_PENDING,\n\tICE_FLTR_OVERFLOW_PROMISC,\n\tICE_VF_DIS,\n\tICE_CFG_BUSY,\n\tICE_SERVICE_SCHED,\n\tICE_SERVICE_DIS,\n\tICE_FD_FLUSH_REQ,\n\tICE_OICR_INTR_DIS,\t\t \n\tICE_MDD_VF_PRINT_PENDING,\t \n\tICE_VF_RESETS_DISABLED,\t \n\tICE_LINK_DEFAULT_OVERRIDE_PENDING,\n\tICE_PHY_INIT_COMPLETE,\n\tICE_FD_VF_FLUSH_CTX,\t\t \n\tICE_AUX_ERR_PENDING,\n\tICE_STATE_NBITS\t\t \n};\n\nenum ice_vsi_state {\n\tICE_VSI_DOWN,\n\tICE_VSI_NEEDS_RESTART,\n\tICE_VSI_NETDEV_ALLOCD,\n\tICE_VSI_NETDEV_REGISTERED,\n\tICE_VSI_UMAC_FLTR_CHANGED,\n\tICE_VSI_MMAC_FLTR_CHANGED,\n\tICE_VSI_PROMISC_CHANGED,\n\tICE_VSI_STATE_NBITS\t\t \n};\n\nstruct ice_vsi_stats {\n\tstruct ice_ring_stats **tx_ring_stats;   \n\tstruct ice_ring_stats **rx_ring_stats;   \n};\n\n \nstruct ice_vsi {\n\tstruct net_device *netdev;\n\tstruct ice_sw *vsw;\t\t  \n\tstruct ice_pf *back;\t\t  \n\tstruct ice_port_info *port_info;  \n\tstruct ice_rx_ring **rx_rings;\t  \n\tstruct ice_tx_ring **tx_rings;\t  \n\tstruct ice_q_vector **q_vectors;  \n\n\tirqreturn_t (*irq_handler)(int irq, void *data);\n\n\tu64 tx_linearize;\n\tDECLARE_BITMAP(state, ICE_VSI_STATE_NBITS);\n\tunsigned int current_netdev_flags;\n\tu32 tx_restart;\n\tu32 tx_busy;\n\tu32 rx_buf_failed;\n\tu32 rx_page_failed;\n\tu16 num_q_vectors;\n\t \n\tbool irq_dyn_alloc;\n\n\tenum ice_vsi_type type;\n\tu16 vsi_num;\t\t\t \n\tu16 idx;\t\t\t \n\n\tstruct ice_vf *vf;\t\t \n\n\tu16 num_gfltr;\n\tu16 num_bfltr;\n\n\t \n\tu16 rss_table_size;\t \n\tu16 rss_size;\t\t \n\tu8 *rss_hkey_user;\t \n\tu8 *rss_lut_user;\t \n\tu8 rss_lut_type;\t \n\n\t \n#define ICE_MAX_ARFS_LIST\t1024\n#define ICE_ARFS_LST_MASK\t(ICE_MAX_ARFS_LIST - 1)\n\tstruct hlist_head *arfs_fltr_list;\n\tstruct ice_arfs_active_fltr_cntrs *arfs_fltr_cntrs;\n\tspinlock_t arfs_lock;\t \n\tatomic_t *arfs_last_fltr_id;\n\n\tu16 max_frame;\n\tu16 rx_buf_len;\n\n\tstruct ice_aqc_vsi_props info;\t  \n\tstruct ice_vsi_vlan_info vlan_info;\t \n\n\t \n\tstruct rtnl_link_stats64 net_stats;\n\tstruct rtnl_link_stats64 net_stats_prev;\n\tstruct ice_eth_stats eth_stats;\n\tstruct ice_eth_stats eth_stats_prev;\n\n\tstruct list_head tmp_sync_list;\t\t \n\tstruct list_head tmp_unsync_list;\t \n\n\tu8 irqs_ready:1;\n\tu8 current_isup:1;\t\t  \n\tu8 stat_offsets_loaded:1;\n\tstruct ice_vsi_vlan_ops inner_vlan_ops;\n\tstruct ice_vsi_vlan_ops outer_vlan_ops;\n\tu16 num_vlan;\n\n\t \n\tu8 tx_mapping_mode;\t\t  \n\tu8 rx_mapping_mode;\t\t  \n\tu16 *txq_map;\t\t\t  \n\tu16 *rxq_map;\t\t\t  \n\tu16 alloc_txq;\t\t\t  \n\tu16 num_txq;\t\t\t  \n\tu16 alloc_rxq;\t\t\t  \n\tu16 num_rxq;\t\t\t  \n\tu16 req_txq;\t\t\t  \n\tu16 req_rxq;\t\t\t  \n\tu16 num_rx_desc;\n\tu16 num_tx_desc;\n\tu16 qset_handle[ICE_MAX_TRAFFIC_CLASS];\n\tstruct ice_tc_cfg tc_cfg;\n\tstruct bpf_prog *xdp_prog;\n\tstruct ice_tx_ring **xdp_rings;\t  \n\tunsigned long *af_xdp_zc_qps;\t  \n\tu16 num_xdp_txq;\t\t  \n\tu8 xdp_mapping_mode;\t\t  \n\n\tstruct net_device **target_netdevs;\n\n\tstruct tc_mqprio_qopt_offload mqprio_qopt;  \n\n\t \n\tstruct ice_vsi *tc_map_vsi[ICE_CHNL_MAX_TC];\n\tu16 cnt_q_avail;\n\tu16 next_base_q;\t \n\tstruct list_head ch_list;\n\tu16 num_chnl_rxq;\n\tu16 num_chnl_txq;\n\tu16 ch_rss_size;\n\tu16 num_chnl_fltr;\n\t \n\tu16 orig_rss_size;\n\t \n\tu8 all_numtc;\n\tu16 all_enatc;\n\n\t \n\tu8 old_numtc;\n\tu16 old_ena_tc;\n\n\tstruct ice_channel *ch;\n\n\t \n\tstruct ice_agg_node *agg_node;\n} ____cacheline_internodealigned_in_smp;\n\n \nstruct ice_q_vector {\n\tstruct ice_vsi *vsi;\n\n\tu16 v_idx;\t\t\t \n\tu16 reg_idx;\n\tu8 num_ring_rx;\t\t\t \n\tu8 num_ring_tx;\t\t\t \n\tu8 wb_on_itr:1;\t\t\t \n\t \n\tu8 intrl;\n\n\tstruct napi_struct napi;\n\n\tstruct ice_ring_container rx;\n\tstruct ice_ring_container tx;\n\n\tcpumask_t affinity_mask;\n\tstruct irq_affinity_notify affinity_notify;\n\n\tstruct ice_channel *ch;\n\n\tchar name[ICE_INT_NAME_STR_LEN];\n\n\tu16 total_events;\t \n\tstruct msi_map irq;\n} ____cacheline_internodealigned_in_smp;\n\nenum ice_pf_flags {\n\tICE_FLAG_FLTR_SYNC,\n\tICE_FLAG_RDMA_ENA,\n\tICE_FLAG_RSS_ENA,\n\tICE_FLAG_SRIOV_ENA,\n\tICE_FLAG_SRIOV_CAPABLE,\n\tICE_FLAG_DCB_CAPABLE,\n\tICE_FLAG_DCB_ENA,\n\tICE_FLAG_FD_ENA,\n\tICE_FLAG_PTP_SUPPORTED,\t\t \n\tICE_FLAG_PTP,\t\t\t \n\tICE_FLAG_ADV_FEATURES,\n\tICE_FLAG_TC_MQPRIO,\t\t \n\tICE_FLAG_CLS_FLOWER,\n\tICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,\n\tICE_FLAG_TOTAL_PORT_SHUTDOWN_ENA,\n\tICE_FLAG_NO_MEDIA,\n\tICE_FLAG_FW_LLDP_AGENT,\n\tICE_FLAG_MOD_POWER_UNSUPPORTED,\n\tICE_FLAG_PHY_FW_LOAD_FAILED,\n\tICE_FLAG_ETHTOOL_CTXT,\t\t \n\tICE_FLAG_LEGACY_RX,\n\tICE_FLAG_VF_TRUE_PROMISC_ENA,\n\tICE_FLAG_MDD_AUTO_RESET_VF,\n\tICE_FLAG_VF_VLAN_PRUNING,\n\tICE_FLAG_LINK_LENIENT_MODE_ENA,\n\tICE_FLAG_PLUG_AUX_DEV,\n\tICE_FLAG_UNPLUG_AUX_DEV,\n\tICE_FLAG_MTU_CHANGED,\n\tICE_FLAG_GNSS,\t\t\t \n\tICE_PF_FLAGS_NBITS\t\t \n};\n\nenum ice_misc_thread_tasks {\n\tICE_MISC_THREAD_EXTTS_EVENT,\n\tICE_MISC_THREAD_TX_TSTAMP,\n\tICE_MISC_THREAD_NBITS\t\t \n};\n\nstruct ice_switchdev_info {\n\tstruct ice_vsi *control_vsi;\n\tstruct ice_vsi *uplink_vsi;\n\tstruct ice_esw_br_offloads *br_offloads;\n\tbool is_running;\n};\n\nstruct ice_agg_node {\n\tu32 agg_id;\n#define ICE_MAX_VSIS_IN_AGG_NODE\t64\n\tu32 num_vsis;\n\tu8 valid;\n};\n\nstruct ice_pf {\n\tstruct pci_dev *pdev;\n\n\tstruct devlink_region *nvm_region;\n\tstruct devlink_region *sram_region;\n\tstruct devlink_region *devcaps_region;\n\n\t \n\tstruct devlink_port devlink_port;\n\n\t \n\tstruct msix_entry *msix_entries;\n\tstruct ice_irq_tracker irq_tracker;\n\t \n\tu16 sriov_base_vector;\n\n\tu16 ctrl_vsi_idx;\t\t \n\n\tstruct ice_vsi **vsi;\t\t \n\tstruct ice_vsi_stats **vsi_stats;\n\tstruct ice_sw *first_sw;\t \n\tu16 eswitch_mode;\t\t \n\tstruct ice_vfs vfs;\n\tDECLARE_BITMAP(features, ICE_F_MAX);\n\tDECLARE_BITMAP(state, ICE_STATE_NBITS);\n\tDECLARE_BITMAP(flags, ICE_PF_FLAGS_NBITS);\n\tDECLARE_BITMAP(misc_thread, ICE_MISC_THREAD_NBITS);\n\tunsigned long *avail_txqs;\t \n\tunsigned long *avail_rxqs;\t \n\tunsigned long serv_tmr_period;\n\tunsigned long serv_tmr_prev;\n\tstruct timer_list serv_tmr;\n\tstruct work_struct serv_task;\n\tstruct mutex avail_q_mutex;\t \n\tstruct mutex sw_mutex;\t\t \n\tstruct mutex tc_mutex;\t\t \n\tstruct mutex adev_mutex;\t \n\tstruct mutex lag_mutex;\t\t \n\tu32 msg_enable;\n\tstruct ice_ptp ptp;\n\tstruct gnss_serial *gnss_serial;\n\tstruct gnss_device *gnss_dev;\n\tu16 num_rdma_msix;\t\t \n\tu16 rdma_base_vector;\n\n\t \n\tspinlock_t aq_wait_lock;\n\tstruct hlist_head aq_wait_list;\n\twait_queue_head_t aq_wait_queue;\n\tbool fw_emp_reset_disabled;\n\n\twait_queue_head_t reset_wait_queue;\n\n\tu32 hw_csum_rx_error;\n\tu32 oicr_err_reg;\n\tstruct msi_map oicr_irq;\t \n\tu16 max_pf_txqs;\t \n\tu16 max_pf_rxqs;\t \n\tu16 num_lan_msix;\t \n\tu16 num_lan_tx;\t\t \n\tu16 num_lan_rx;\t\t \n\tu16 next_vsi;\t\t \n\tu16 num_alloc_vsi;\n\tu16 corer_count;\t \n\tu16 globr_count;\t \n\tu16 empr_count;\t\t \n\tu16 pfr_count;\t\t \n\n\tu8 wol_ena : 1;\t\t \n\tu32 wakeup_reason;\t \n\tstruct ice_hw_port_stats stats;\n\tstruct ice_hw_port_stats stats_prev;\n\tstruct ice_hw hw;\n\tu8 stat_prev_loaded:1;  \n\tu8 rdma_mode;\n\tu16 dcbx_cap;\n\tu32 tx_timeout_count;\n\tunsigned long tx_timeout_last_recovery;\n\tu32 tx_timeout_recovery_level;\n\tchar int_name[ICE_INT_NAME_STR_LEN];\n\tstruct auxiliary_device *adev;\n\tint aux_idx;\n\tu32 sw_int_count;\n\t \n\tu16 num_dmac_chnl_fltrs;\n\tstruct hlist_head tc_flower_fltr_list;\n\n\tu64 supported_rxdids;\n\n\t__le64 nvm_phy_type_lo;  \n\t__le64 nvm_phy_type_hi;  \n\tstruct ice_link_default_override_tlv link_dflt_override;\n\tstruct ice_lag *lag;  \n\n\tstruct ice_switchdev_info switchdev;\n\tstruct ice_esw_br_port *br_port;\n\n#define ICE_INVALID_AGG_NODE_ID\t\t0\n#define ICE_PF_AGG_NODE_ID_START\t1\n#define ICE_MAX_PF_AGG_NODES\t\t32\n\tstruct ice_agg_node pf_agg_node[ICE_MAX_PF_AGG_NODES];\n#define ICE_VF_AGG_NODE_ID_START\t65\n#define ICE_MAX_VF_AGG_NODES\t\t32\n\tstruct ice_agg_node vf_agg_node[ICE_MAX_VF_AGG_NODES];\n};\n\nextern struct workqueue_struct *ice_lag_wq;\n\nstruct ice_netdev_priv {\n\tstruct ice_vsi *vsi;\n\tstruct ice_repr *repr;\n\t \n\tstruct list_head tc_indr_block_priv_list;\n};\n\n \nstatic inline bool ice_vector_ch_enabled(struct ice_q_vector *qv)\n{\n\treturn !!qv->ch;  \n}\n\n \nstatic inline void\nice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,\n\t\t    struct ice_q_vector *q_vector)\n{\n\tu32 vector = (vsi && q_vector) ? q_vector->reg_idx :\n\t\t\t\t((struct ice_pf *)hw->back)->oicr_irq.index;\n\tint itr = ICE_ITR_NONE;\n\tu32 val;\n\n\t \n\tval = GLINT_DYN_CTL_INTENA_M | GLINT_DYN_CTL_CLEARPBA_M |\n\t      (itr << GLINT_DYN_CTL_ITR_INDX_S);\n\tif (vsi)\n\t\tif (test_bit(ICE_VSI_DOWN, vsi->state))\n\t\t\treturn;\n\twr32(hw, GLINT_DYN_CTL(vector), val);\n}\n\n \nstatic inline struct ice_pf *ice_netdev_to_pf(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(netdev);\n\n\treturn np->vsi->back;\n}\n\nstatic inline bool ice_is_xdp_ena_vsi(struct ice_vsi *vsi)\n{\n\treturn !!READ_ONCE(vsi->xdp_prog);\n}\n\nstatic inline void ice_set_ring_xdp(struct ice_tx_ring *ring)\n{\n\tring->flags |= ICE_TX_FLAGS_RING_XDP;\n}\n\n \nstatic inline struct xsk_buff_pool *ice_xsk_pool(struct ice_rx_ring *ring)\n{\n\tstruct ice_vsi *vsi = ring->vsi;\n\tu16 qid = ring->q_index;\n\n\tif (!ice_is_xdp_ena_vsi(vsi) || !test_bit(qid, vsi->af_xdp_zc_qps))\n\t\treturn NULL;\n\n\treturn xsk_get_pool_from_qid(vsi->netdev, qid);\n}\n\n \nstatic inline void ice_tx_xsk_pool(struct ice_vsi *vsi, u16 qid)\n{\n\tstruct ice_tx_ring *ring;\n\n\tring = vsi->rx_rings[qid]->xdp_ring;\n\tif (!ring)\n\t\treturn;\n\n\tif (!ice_is_xdp_ena_vsi(vsi) || !test_bit(qid, vsi->af_xdp_zc_qps)) {\n\t\tring->xsk_pool = NULL;\n\t\treturn;\n\t}\n\n\tring->xsk_pool = xsk_get_pool_from_qid(vsi->netdev, qid);\n}\n\n \nstatic inline struct ice_vsi *ice_get_main_vsi(struct ice_pf *pf)\n{\n\tif (pf->vsi)\n\t\treturn pf->vsi[0];\n\n\treturn NULL;\n}\n\n \nstatic inline struct ice_vsi *ice_get_netdev_priv_vsi(struct ice_netdev_priv *np)\n{\n\t \n\tif (np->repr)\n\t\treturn np->repr->src_vsi;\n\telse\n\t\treturn np->vsi;\n}\n\n \nstatic inline struct ice_vsi *ice_get_ctrl_vsi(struct ice_pf *pf)\n{\n\t \n\tif (!pf->vsi || pf->ctrl_vsi_idx == ICE_NO_VSI)\n\t\treturn NULL;\n\n\treturn pf->vsi[pf->ctrl_vsi_idx];\n}\n\n \nstatic inline struct ice_vsi *ice_find_vsi(struct ice_pf *pf, u16 vsi_num)\n{\n\tint i;\n\n\tice_for_each_vsi(pf, i)\n\t\tif (pf->vsi[i] && pf->vsi[i]->vsi_num == vsi_num)\n\t\t\treturn  pf->vsi[i];\n\treturn NULL;\n}\n\n \nstatic inline bool ice_is_switchdev_running(struct ice_pf *pf)\n{\n\treturn pf->switchdev.is_running;\n}\n\n#define ICE_FD_STAT_CTR_BLOCK_COUNT\t256\n#define ICE_FD_STAT_PF_IDX(base_idx) \\\n\t\t\t((base_idx) * ICE_FD_STAT_CTR_BLOCK_COUNT)\n#define ICE_FD_SB_STAT_IDX(base_idx) ICE_FD_STAT_PF_IDX(base_idx)\n#define ICE_FD_STAT_CH\t\t\t1\n#define ICE_FD_CH_STAT_IDX(base_idx) \\\n\t\t\t(ICE_FD_STAT_PF_IDX(base_idx) + ICE_FD_STAT_CH)\n\n \nstatic inline bool ice_is_adq_active(struct ice_pf *pf)\n{\n\tstruct ice_vsi *vsi;\n\n\tvsi = ice_get_main_vsi(pf);\n\tif (!vsi)\n\t\treturn false;\n\n\t \n\tif (vsi->tc_cfg.numtc > ICE_CHNL_START_TC &&\n\t    test_bit(ICE_FLAG_TC_MQPRIO, pf->flags))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool netif_is_ice(const struct net_device *dev);\nint ice_vsi_setup_tx_rings(struct ice_vsi *vsi);\nint ice_vsi_setup_rx_rings(struct ice_vsi *vsi);\nint ice_vsi_open_ctrl(struct ice_vsi *vsi);\nint ice_vsi_open(struct ice_vsi *vsi);\nvoid ice_set_ethtool_ops(struct net_device *netdev);\nvoid ice_set_ethtool_repr_ops(struct net_device *netdev);\nvoid ice_set_ethtool_safe_mode_ops(struct net_device *netdev);\nu16 ice_get_avail_txq_count(struct ice_pf *pf);\nu16 ice_get_avail_rxq_count(struct ice_pf *pf);\nint ice_vsi_recfg_qs(struct ice_vsi *vsi, int new_rx, int new_tx, bool locked);\nvoid ice_update_vsi_stats(struct ice_vsi *vsi);\nvoid ice_update_pf_stats(struct ice_pf *pf);\nvoid\nice_fetch_u64_stats_per_ring(struct u64_stats_sync *syncp,\n\t\t\t     struct ice_q_stats stats, u64 *pkts, u64 *bytes);\nint ice_up(struct ice_vsi *vsi);\nint ice_down(struct ice_vsi *vsi);\nint ice_down_up(struct ice_vsi *vsi);\nint ice_vsi_cfg_lan(struct ice_vsi *vsi);\nstruct ice_vsi *ice_lb_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi);\nint ice_vsi_determine_xdp_res(struct ice_vsi *vsi);\nint ice_prepare_xdp_rings(struct ice_vsi *vsi, struct bpf_prog *prog);\nint ice_destroy_xdp_rings(struct ice_vsi *vsi);\nint\nice_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames,\n\t     u32 flags);\nint ice_set_rss_lut(struct ice_vsi *vsi, u8 *lut, u16 lut_size);\nint ice_get_rss_lut(struct ice_vsi *vsi, u8 *lut, u16 lut_size);\nint ice_set_rss_key(struct ice_vsi *vsi, u8 *seed);\nint ice_get_rss_key(struct ice_vsi *vsi, u8 *seed);\nvoid ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);\nint ice_schedule_reset(struct ice_pf *pf, enum ice_reset_req reset);\nvoid ice_print_link_msg(struct ice_vsi *vsi, bool isup);\nint ice_plug_aux_dev(struct ice_pf *pf);\nvoid ice_unplug_aux_dev(struct ice_pf *pf);\nint ice_init_rdma(struct ice_pf *pf);\nvoid ice_deinit_rdma(struct ice_pf *pf);\nconst char *ice_aq_str(enum ice_aq_err aq_err);\nbool ice_is_wol_supported(struct ice_hw *hw);\nvoid ice_fdir_del_all_fltrs(struct ice_vsi *vsi);\nint\nice_fdir_write_fltr(struct ice_pf *pf, struct ice_fdir_fltr *input, bool add,\n\t\t    bool is_tun);\nvoid ice_vsi_manage_fdir(struct ice_vsi *vsi, bool ena);\nint ice_add_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);\nint ice_del_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);\nint ice_get_ethtool_fdir_entry(struct ice_hw *hw, struct ethtool_rxnfc *cmd);\nint\nice_get_fdir_fltr_ids(struct ice_hw *hw, struct ethtool_rxnfc *cmd,\n\t\t      u32 *rule_locs);\nvoid ice_fdir_rem_adq_chnl(struct ice_hw *hw, u16 vsi_idx);\nvoid ice_fdir_release_flows(struct ice_hw *hw);\nvoid ice_fdir_replay_flows(struct ice_hw *hw);\nvoid ice_fdir_replay_fltrs(struct ice_pf *pf);\nint ice_fdir_create_dflt_rules(struct ice_pf *pf);\n\nenum ice_aq_task_state {\n\tICE_AQ_TASK_NOT_PREPARED,\n\tICE_AQ_TASK_WAITING,\n\tICE_AQ_TASK_COMPLETE,\n\tICE_AQ_TASK_CANCELED,\n};\n\nstruct ice_aq_task {\n\tstruct hlist_node entry;\n\tstruct ice_rq_event_info event;\n\tenum ice_aq_task_state state;\n\tu16 opcode;\n};\n\nvoid ice_aq_prep_for_event(struct ice_pf *pf, struct ice_aq_task *task,\n\t\t\t   u16 opcode);\nint ice_aq_wait_for_event(struct ice_pf *pf, struct ice_aq_task *task,\n\t\t\t  unsigned long timeout);\nint ice_open(struct net_device *netdev);\nint ice_open_internal(struct net_device *netdev);\nint ice_stop(struct net_device *netdev);\nvoid ice_service_task_schedule(struct ice_pf *pf);\nint ice_load(struct ice_pf *pf);\nvoid ice_unload(struct ice_pf *pf);\n\n \nstatic inline void ice_set_rdma_cap(struct ice_pf *pf)\n{\n\tif (pf->hw.func_caps.common_cap.rdma && pf->num_rdma_msix) {\n\t\tset_bit(ICE_FLAG_RDMA_ENA, pf->flags);\n\t\tset_bit(ICE_FLAG_PLUG_AUX_DEV, pf->flags);\n\t}\n}\n\n \nstatic inline void ice_clear_rdma_cap(struct ice_pf *pf)\n{\n\t \n\tclear_bit(ICE_FLAG_PLUG_AUX_DEV, pf->flags);\n\tset_bit(ICE_FLAG_UNPLUG_AUX_DEV, pf->flags);\n\tclear_bit(ICE_FLAG_RDMA_ENA, pf->flags);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}