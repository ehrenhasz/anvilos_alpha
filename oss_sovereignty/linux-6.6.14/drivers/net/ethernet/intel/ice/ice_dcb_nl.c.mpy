{
  "module_name": "ice_dcb_nl.c",
  "hash_id": "c12c7b73d2d7cd33bb6ccc109d42fdc015e755777ffbda3b0292330f6b4c9e09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_dcb_nl.c",
  "human_readable_source": "\n \n\n#include \"ice.h\"\n#include \"ice_dcb.h\"\n#include \"ice_dcb_lib.h\"\n#include \"ice_dcb_nl.h\"\n#include <net/dcbnl.h>\n\n \nstatic void ice_dcbnl_devreset(struct net_device *netdev)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\n\twhile (ice_is_reset_in_progress(pf->state))\n\t\tusleep_range(1000, 2000);\n\n\tdev_close(netdev);\n\tnetdev_state_change(netdev);\n\tdev_open(netdev, NULL);\n\tnetdev_state_change(netdev);\n}\n\n \nstatic int ice_dcbnl_getets(struct net_device *netdev, struct ieee_ets *ets)\n{\n\tstruct ice_dcbx_cfg *dcbxcfg;\n\tstruct ice_pf *pf;\n\n\tpf = ice_netdev_to_pf(netdev);\n\tdcbxcfg = &pf->hw.port_info->qos_cfg.local_dcbx_cfg;\n\n\tets->willing = dcbxcfg->etscfg.willing;\n\tets->ets_cap = dcbxcfg->etscfg.maxtcs;\n\tets->cbs = dcbxcfg->etscfg.cbs;\n\tmemcpy(ets->tc_tx_bw, dcbxcfg->etscfg.tcbwtable, sizeof(ets->tc_tx_bw));\n\tmemcpy(ets->tc_rx_bw, dcbxcfg->etscfg.tcbwtable, sizeof(ets->tc_rx_bw));\n\tmemcpy(ets->tc_tsa, dcbxcfg->etscfg.tsatable, sizeof(ets->tc_tsa));\n\tmemcpy(ets->prio_tc, dcbxcfg->etscfg.prio_table, sizeof(ets->prio_tc));\n\tmemcpy(ets->tc_reco_bw, dcbxcfg->etsrec.tcbwtable,\n\t       sizeof(ets->tc_reco_bw));\n\tmemcpy(ets->tc_reco_tsa, dcbxcfg->etsrec.tsatable,\n\t       sizeof(ets->tc_reco_tsa));\n\tmemcpy(ets->reco_prio_tc, dcbxcfg->etscfg.prio_table,\n\t       sizeof(ets->reco_prio_tc));\n\n\treturn 0;\n}\n\n \nstatic int ice_dcbnl_setets(struct net_device *netdev, struct ieee_ets *ets)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcbx_cfg *new_cfg;\n\tint bwcfg = 0, bwrec = 0;\n\tint err, i;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\n\tmutex_lock(&pf->tc_mutex);\n\n\tnew_cfg->etscfg.willing = ets->willing;\n\tnew_cfg->etscfg.cbs = ets->cbs;\n\tice_for_each_traffic_class(i) {\n\t\tnew_cfg->etscfg.tcbwtable[i] = ets->tc_tx_bw[i];\n\t\tbwcfg += ets->tc_tx_bw[i];\n\t\tnew_cfg->etscfg.tsatable[i] = ets->tc_tsa[i];\n\t\tif (new_cfg->pfc_mode == ICE_QOS_MODE_VLAN) {\n\t\t\t \n\t\t\tnew_cfg->etscfg.prio_table[i] = ets->prio_tc[i];\n\t\t\tnew_cfg->etsrec.prio_table[i] = ets->reco_prio_tc[i];\n\t\t}\n\t\tnew_cfg->etsrec.tcbwtable[i] = ets->tc_reco_bw[i];\n\t\tbwrec += ets->tc_reco_bw[i];\n\t\tnew_cfg->etsrec.tsatable[i] = ets->tc_reco_tsa[i];\n\t}\n\n\tif (ice_dcb_bwchk(pf, new_cfg)) {\n\t\terr = -EINVAL;\n\t\tgoto ets_out;\n\t}\n\n\tnew_cfg->etscfg.maxtcs = pf->hw.func_caps.common_cap.maxtc;\n\n\tif (!bwcfg)\n\t\tnew_cfg->etscfg.tcbwtable[0] = 100;\n\n\tif (!bwrec)\n\t\tnew_cfg->etsrec.tcbwtable[0] = 100;\n\n\terr = ice_pf_dcb_cfg(pf, new_cfg, true);\n\t \n\tif (err == ICE_DCB_HW_CHG_RST)\n\t\tice_dcbnl_devreset(netdev);\n\tif (err == ICE_DCB_NO_HW_CHG)\n\t\terr = ICE_DCB_HW_CHG_RST;\n\nets_out:\n\tmutex_unlock(&pf->tc_mutex);\n\treturn err;\n}\n\n \nstatic int\nice_dcbnl_getnumtcs(struct net_device *dev, int __always_unused tcid, u8 *num)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(dev);\n\n\tif (!test_bit(ICE_FLAG_DCB_CAPABLE, pf->flags))\n\t\treturn -EINVAL;\n\n\t*num = pf->hw.func_caps.common_cap.maxtc;\n\treturn 0;\n}\n\n \nstatic u8 ice_dcbnl_getdcbx(struct net_device *netdev)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\n\treturn pf->dcbx_cap;\n}\n\n \nstatic u8 ice_dcbnl_setdcbx(struct net_device *netdev, u8 mode)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_qos_cfg *qos_cfg;\n\n\t \n\tif (test_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags))\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\t \n\tif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    ((mode & DCB_CAP_DCBX_VER_IEEE) && (mode & DCB_CAP_DCBX_VER_CEE)) ||\n\t    !(mode & DCB_CAP_DCBX_HOST))\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\t \n\tif (mode == pf->dcbx_cap)\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn ICE_DCB_NO_HW_CHG;\n\t}\n\n\tqos_cfg = &pf->hw.port_info->qos_cfg;\n\n\t \n\tif (qos_cfg->local_dcbx_cfg.pfc_mode == ICE_QOS_MODE_DSCP)\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\tpf->dcbx_cap = mode;\n\n\tif (mode & DCB_CAP_DCBX_VER_CEE)\n\t\tqos_cfg->local_dcbx_cfg.dcbx_mode = ICE_DCBX_MODE_CEE;\n\telse\n\t\tqos_cfg->local_dcbx_cfg.dcbx_mode = ICE_DCBX_MODE_IEEE;\n\n\tdev_info(ice_pf_to_dev(pf), \"DCBx mode = 0x%x\\n\", mode);\n\treturn ICE_DCB_HW_CHG_RST;\n}\n\n \nstatic void ice_dcbnl_get_perm_hw_addr(struct net_device *netdev, u8 *perm_addr)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_port_info *pi = pf->hw.port_info;\n\tint i, j;\n\n\tmemset(perm_addr, 0xff, MAX_ADDR_LEN);\n\n\tfor (i = 0; i < netdev->addr_len; i++)\n\t\tperm_addr[i] = pi->mac.perm_addr[i];\n\n\tfor (j = 0; j < netdev->addr_len; j++, i++)\n\t\tperm_addr[i] = pi->mac.perm_addr[j];\n}\n\n \nstatic void ice_get_pfc_delay(struct ice_hw *hw, u16 *delay)\n{\n\tu32 val;\n\n\tval = rd32(hw, PRTDCB_GENC);\n\t*delay = (u16)((val & PRTDCB_GENC_PFCLDA_M) >> PRTDCB_GENC_PFCLDA_S);\n}\n\n \nstatic int ice_dcbnl_getpfc(struct net_device *netdev, struct ieee_pfc *pfc)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_port_info *pi = pf->hw.port_info;\n\tstruct ice_dcbx_cfg *dcbxcfg;\n\tint i;\n\n\tdcbxcfg = &pi->qos_cfg.local_dcbx_cfg;\n\tpfc->pfc_cap = dcbxcfg->pfc.pfccap;\n\tpfc->pfc_en = dcbxcfg->pfc.pfcena;\n\tpfc->mbc = dcbxcfg->pfc.mbc;\n\tice_get_pfc_delay(&pf->hw, &pfc->delay);\n\n\tice_for_each_traffic_class(i) {\n\t\tpfc->requests[i] = pf->stats.priority_xoff_tx[i];\n\t\tpfc->indications[i] = pf->stats.priority_xoff_rx[i];\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ice_dcbnl_setpfc(struct net_device *netdev, struct ieee_pfc *pfc)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcbx_cfg *new_cfg;\n\tint err;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&pf->tc_mutex);\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\n\tif (pfc->pfc_cap)\n\t\tnew_cfg->pfc.pfccap = pfc->pfc_cap;\n\telse\n\t\tnew_cfg->pfc.pfccap = pf->hw.func_caps.common_cap.maxtc;\n\n\tnew_cfg->pfc.pfcena = pfc->pfc_en;\n\n\terr = ice_pf_dcb_cfg(pf, new_cfg, true);\n\tif (err == ICE_DCB_HW_CHG_RST)\n\t\tice_dcbnl_devreset(netdev);\n\tif (err == ICE_DCB_NO_HW_CHG)\n\t\terr = ICE_DCB_HW_CHG_RST;\n\tmutex_unlock(&pf->tc_mutex);\n\treturn err;\n}\n\n \nstatic void\nice_dcbnl_get_pfc_cfg(struct net_device *netdev, int prio, u8 *setting)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_port_info *pi = pf->hw.port_info;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\tif (prio >= ICE_MAX_USER_PRIORITY)\n\t\treturn;\n\n\t*setting = (pi->qos_cfg.local_dcbx_cfg.pfc.pfcena >> prio) & 0x1;\n\tdev_dbg(ice_pf_to_dev(pf), \"Get PFC Config up=%d, setting=%d, pfcenable=0x%x\\n\",\n\t\tprio, *setting, pi->qos_cfg.local_dcbx_cfg.pfc.pfcena);\n}\n\n \nstatic void ice_dcbnl_set_pfc_cfg(struct net_device *netdev, int prio, u8 set)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcbx_cfg *new_cfg;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\tif (prio >= ICE_MAX_USER_PRIORITY)\n\t\treturn;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn;\n\t}\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\n\tnew_cfg->pfc.pfccap = pf->hw.func_caps.common_cap.maxtc;\n\tif (set)\n\t\tnew_cfg->pfc.pfcena |= BIT(prio);\n\telse\n\t\tnew_cfg->pfc.pfcena &= ~BIT(prio);\n\n\tdev_dbg(ice_pf_to_dev(pf), \"Set PFC config UP:%d set:%d pfcena:0x%x\\n\",\n\t\tprio, set, new_cfg->pfc.pfcena);\n}\n\n \nstatic u8 ice_dcbnl_getpfcstate(struct net_device *netdev)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_port_info *pi = pf->hw.port_info;\n\n\t \n\tif (pi->qos_cfg.local_dcbx_cfg.pfc.pfcena)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic u8 ice_dcbnl_getstate(struct net_device *netdev)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tu8 state = 0;\n\n\tstate = test_bit(ICE_FLAG_DCB_CAPABLE, pf->flags);\n\n\tdev_dbg(ice_pf_to_dev(pf), \"DCB enabled state = %d\\n\", state);\n\treturn state;\n}\n\n \nstatic u8 ice_dcbnl_setstate(struct net_device *netdev, u8 state)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn ICE_DCB_NO_HW_CHG;\n\t}\n\n\t \n\tif (!!state == test_bit(ICE_FLAG_DCB_ENA, pf->flags))\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\tif (state) {\n\t\tset_bit(ICE_FLAG_DCB_ENA, pf->flags);\n\t\tmemcpy(&pf->hw.port_info->qos_cfg.desired_dcbx_cfg,\n\t\t       &pf->hw.port_info->qos_cfg.local_dcbx_cfg,\n\t\t       sizeof(struct ice_dcbx_cfg));\n\t} else {\n\t\tclear_bit(ICE_FLAG_DCB_ENA, pf->flags);\n\t}\n\n\treturn ICE_DCB_HW_CHG;\n}\n\n \nstatic void\nice_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev, int prio,\n\t\t\t   u8 __always_unused *prio_type, u8 *pgid,\n\t\t\t   u8 __always_unused *bw_pct,\n\t\t\t   u8 __always_unused *up_map)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_port_info *pi = pf->hw.port_info;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\tif (prio >= ICE_MAX_USER_PRIORITY)\n\t\treturn;\n\n\t*pgid = pi->qos_cfg.local_dcbx_cfg.etscfg.prio_table[prio];\n\tdev_dbg(ice_pf_to_dev(pf), \"Get PG config prio=%d tc=%d\\n\", prio,\n\t\t*pgid);\n}\n\n \nstatic void\nice_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev, int tc,\n\t\t\t   u8 __always_unused prio_type,\n\t\t\t   u8 __always_unused bwg_id,\n\t\t\t   u8 __always_unused bw_pct, u8 up_map)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcbx_cfg *new_cfg;\n\tint i;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\tif (tc >= ICE_MAX_TRAFFIC_CLASS)\n\t\treturn;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn;\n\t}\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\n\t \n\n\tice_for_each_traffic_class(i) {\n\t\tif (up_map & BIT(i))\n\t\t\tnew_cfg->etscfg.prio_table[i] = tc;\n\t}\n\tnew_cfg->etscfg.tsatable[tc] = ICE_IEEE_TSA_ETS;\n}\n\n \nstatic void\nice_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev, int pgid, u8 *bw_pct)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_port_info *pi = pf->hw.port_info;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\tif (pgid >= ICE_MAX_TRAFFIC_CLASS)\n\t\treturn;\n\n\t*bw_pct = pi->qos_cfg.local_dcbx_cfg.etscfg.tcbwtable[pgid];\n\tdev_dbg(ice_pf_to_dev(pf), \"Get PG BW config tc=%d bw_pct=%d\\n\",\n\t\tpgid, *bw_pct);\n}\n\n \nstatic void\nice_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev, int pgid, u8 bw_pct)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcbx_cfg *new_cfg;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\tif (pgid >= ICE_MAX_TRAFFIC_CLASS)\n\t\treturn;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn;\n\t}\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\n\tnew_cfg->etscfg.tcbwtable[pgid] = bw_pct;\n}\n\n \nstatic void\nice_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev, int prio,\n\t\t\t   u8 __always_unused *prio_type, u8 *pgid,\n\t\t\t   u8 __always_unused *bw_pct,\n\t\t\t   u8 __always_unused *up_map)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_port_info *pi = pf->hw.port_info;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\tif (prio >= ICE_MAX_USER_PRIORITY)\n\t\treturn;\n\n\t*pgid = pi->qos_cfg.local_dcbx_cfg.etscfg.prio_table[prio];\n}\n\n \nstatic void\nice_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev,\n\t\t\t   int __always_unused prio,\n\t\t\t   u8 __always_unused prio_type,\n\t\t\t   u8 __always_unused pgid,\n\t\t\t   u8 __always_unused bw_pct,\n\t\t\t   u8 __always_unused up_map)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\n\tdev_dbg(ice_pf_to_dev(pf), \"Rx TC PG Config Not Supported.\\n\");\n}\n\n \nstatic void\nice_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev, int __always_unused pgid,\n\t\t\t    u8 *bw_pct)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn;\n\n\t*bw_pct = 0;\n}\n\n \nstatic void\nice_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev, int __always_unused pgid,\n\t\t\t    u8 __always_unused bw_pct)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\n\tdev_dbg(ice_pf_to_dev(pf), \"Rx BWG PG Config Not Supported.\\n\");\n}\n\n \nstatic u8 ice_dcbnl_get_cap(struct net_device *netdev, int capid, u8 *cap)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\n\tif (!(test_bit(ICE_FLAG_DCB_CAPABLE, pf->flags)))\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PG:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_UP2TC:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PG_TCS:\n\t\t*cap = 0x80;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 0x80;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_GSP:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_BCN:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = pf->dcbx_cap;\n\t\tbreak;\n\tdefault:\n\t\t*cap = false;\n\t\tbreak;\n\t}\n\n\tdev_dbg(ice_pf_to_dev(pf), \"DCBX Get Capability cap=%d capval=0x%x\\n\",\n\t\tcapid, *cap);\n\treturn 0;\n}\n\n \nstatic int ice_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct dcb_app app = {\n\t\t\t\t.selector = idtype,\n\t\t\t\t.protocol = id,\n\t\t\t     };\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn -EINVAL;\n\n\treturn dcb_getapp(netdev, &app);\n}\n\n \nstatic bool\nice_dcbnl_find_app(struct ice_dcbx_cfg *cfg,\n\t\t   struct ice_dcb_app_priority_table *app)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < cfg->numapps; i++) {\n\t\tif (app->selector == cfg->app[i].selector &&\n\t\t    app->prot_id == cfg->app[i].prot_id &&\n\t\t    app->priority == cfg->app[i].priority)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#define ICE_BYTES_PER_DSCP_VAL\t\t8\n\n \nstatic int ice_dcbnl_setapp(struct net_device *netdev, struct dcb_app *app)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcb_app_priority_table new_app;\n\tstruct ice_dcbx_cfg *old_cfg, *new_cfg;\n\tu8 max_tc;\n\tint ret;\n\n\t \n\tif (app->selector != IEEE_8021QAZ_APP_SEL_DSCP)\n\t\treturn -EINVAL;\n\n\t \n\tif (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) {\n\t\tnetdev_err(netdev, \"can't do DSCP QoS when FW DCB agent active\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tif (!ice_is_feature_supported(pf, ICE_F_DSCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (app->protocol >= ICE_DSCP_NUM_VAL) {\n\t\tnetdev_err(netdev, \"DSCP value 0x%04X out of range\\n\",\n\t\t\t   app->protocol);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax_tc = pf->hw.func_caps.common_cap.maxtc;\n\tif (app->priority >= max_tc) {\n\t\tnetdev_err(netdev, \"TC %d out of range, max TC %d\\n\",\n\t\t\t   app->priority, max_tc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&pf->tc_mutex);\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\told_cfg = &pf->hw.port_info->qos_cfg.local_dcbx_cfg;\n\n\tret = dcb_ieee_setapp(netdev, app);\n\tif (ret)\n\t\tgoto setapp_out;\n\n\tif (test_and_set_bit(app->protocol, new_cfg->dscp_mapped)) {\n\t\tnetdev_err(netdev, \"DSCP value 0x%04X already user mapped\\n\",\n\t\t\t   app->protocol);\n\t\tret = dcb_ieee_delapp(netdev, app);\n\t\tif (ret)\n\t\t\tnetdev_err(netdev, \"Failed to delete re-mapping TLV\\n\");\n\t\tret = -EINVAL;\n\t\tgoto setapp_out;\n\t}\n\n\tnew_app.selector = app->selector;\n\tnew_app.prot_id = app->protocol;\n\tnew_app.priority = app->priority;\n\n\t \n\tif (old_cfg->pfc_mode == ICE_QOS_MODE_VLAN) {\n\t\tint i, j;\n\n\t\t \n\t\tret = ice_aq_set_pfc_mode(&pf->hw, ICE_AQC_PFC_DSCP_BASED_PFC,\n\t\t\t\t\t  NULL);\n\t\tif (ret) {\n\t\t\tnetdev_err(netdev, \"Failed to set DSCP PFC mode %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto setapp_out;\n\t\t}\n\t\tnetdev_info(netdev, \"Switched QoS to L3 DSCP mode\\n\");\n\n\t\tnew_cfg->pfc_mode = ICE_QOS_MODE_DSCP;\n\n\t\t \n\t\tnew_cfg->etscfg.willing = 0;\n\t\tnew_cfg->pfc.pfccap = max_tc;\n\t\tnew_cfg->pfc.willing = 0;\n\n\t\tfor (i = 0; i < max_tc; i++)\n\t\t\tfor (j = 0; j < ICE_BYTES_PER_DSCP_VAL; j++) {\n\t\t\t\tint dscp, offset;\n\n\t\t\t\tdscp = (i * max_tc) + j;\n\t\t\t\toffset = max_tc * ICE_BYTES_PER_DSCP_VAL;\n\n\t\t\t\tnew_cfg->dscp_map[dscp] = i;\n\t\t\t\t \n\t\t\t\tif (max_tc < ICE_MAX_TRAFFIC_CLASS)\n\t\t\t\t\tnew_cfg->dscp_map[dscp + offset] = i;\n\t\t\t}\n\n\t\tnew_cfg->etscfg.tcbwtable[0] = 100;\n\t\tnew_cfg->etscfg.tsatable[0] = ICE_IEEE_TSA_ETS;\n\t\tnew_cfg->etscfg.prio_table[0] = 0;\n\n\t\tfor (i = 1; i < max_tc; i++) {\n\t\t\tnew_cfg->etscfg.tcbwtable[i] = 0;\n\t\t\tnew_cfg->etscfg.tsatable[i] = ICE_IEEE_TSA_ETS;\n\t\t\tnew_cfg->etscfg.prio_table[i] = i;\n\t\t}\n\t}  \n\n\t \n\tnew_cfg->dscp_map[app->protocol] = app->priority;\n\tnew_cfg->app[new_cfg->numapps++] = new_app;\n\n\tret = ice_pf_dcb_cfg(pf, new_cfg, true);\n\t \n\tif (ret == ICE_DCB_HW_CHG_RST)\n\t\tice_dcbnl_devreset(netdev);\n\telse\n\t\tret = ICE_DCB_NO_HW_CHG;\n\nsetapp_out:\n\tmutex_unlock(&pf->tc_mutex);\n\treturn ret;\n}\n\n \nstatic int ice_dcbnl_delapp(struct net_device *netdev, struct dcb_app *app)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcbx_cfg *old_cfg, *new_cfg;\n\tunsigned int i, j;\n\tint ret = 0;\n\n\tif (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) {\n\t\tnetdev_err(netdev, \"can't delete DSCP netlink app when FW DCB agent is active\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&pf->tc_mutex);\n\told_cfg = &pf->hw.port_info->qos_cfg.local_dcbx_cfg;\n\n\tret = dcb_ieee_delapp(netdev, app);\n\tif (ret)\n\t\tgoto delapp_out;\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\n\tfor (i = 0; i < new_cfg->numapps; i++) {\n\t\tif (app->selector == new_cfg->app[i].selector &&\n\t\t    app->protocol == new_cfg->app[i].prot_id &&\n\t\t    app->priority == new_cfg->app[i].priority) {\n\t\t\tnew_cfg->app[i].selector = 0;\n\t\t\tnew_cfg->app[i].prot_id = 0;\n\t\t\tnew_cfg->app[i].priority = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == new_cfg->numapps) {\n\t\tret = -EINVAL;\n\t\tgoto delapp_out;\n\t}\n\n\tnew_cfg->numapps--;\n\n\tfor (j = i; j < new_cfg->numapps; j++) {\n\t\tnew_cfg->app[j].selector = old_cfg->app[j + 1].selector;\n\t\tnew_cfg->app[j].prot_id = old_cfg->app[j + 1].prot_id;\n\t\tnew_cfg->app[j].priority = old_cfg->app[j + 1].priority;\n\t}\n\n\t \n\tif (app->selector != IEEE_8021QAZ_APP_SEL_DSCP ||\n\t    !ice_is_feature_supported(pf, ICE_F_DSCP)) {\n\t\tret = ICE_DCB_HW_CHG;\n\t\tgoto delapp_out;\n\t}\n\n\t \n\tclear_bit(app->protocol, new_cfg->dscp_mapped);\n\t \n\tnew_cfg->dscp_map[app->protocol] = app->protocol %\n\t\t\t\t\t   ICE_BYTES_PER_DSCP_VAL;\n\n\t \n\tif (bitmap_empty(new_cfg->dscp_mapped, ICE_DSCP_NUM_VAL) &&\n\t    new_cfg->pfc_mode == ICE_QOS_MODE_DSCP) {\n\t\tret = ice_aq_set_pfc_mode(&pf->hw,\n\t\t\t\t\t  ICE_AQC_PFC_VLAN_BASED_PFC,\n\t\t\t\t\t  NULL);\n\t\tif (ret) {\n\t\t\tnetdev_info(netdev, \"Failed to set VLAN PFC mode %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto delapp_out;\n\t\t}\n\t\tnetdev_info(netdev, \"Switched QoS to L2 VLAN mode\\n\");\n\n\t\tnew_cfg->pfc_mode = ICE_QOS_MODE_VLAN;\n\n\t\tret = ice_dcb_sw_dflt_cfg(pf, true, true);\n\t} else {\n\t\tret = ice_pf_dcb_cfg(pf, new_cfg, true);\n\t}\n\n\t \n\tif (ret == ICE_DCB_HW_CHG_RST)\n\t\tice_dcbnl_devreset(netdev);\n\n\t \n\tif (ret == ICE_DCB_NO_HW_CHG)\n\t\tret = ICE_DCB_HW_CHG;\n\ndelapp_out:\n\tmutex_unlock(&pf->tc_mutex);\n\treturn ret;\n}\n\n \nstatic u8 ice_dcbnl_cee_set_all(struct net_device *netdev)\n{\n\tstruct ice_pf *pf = ice_netdev_to_pf(netdev);\n\tstruct ice_dcbx_cfg *new_cfg;\n\tint err;\n\n\tif ((pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    !(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn ICE_DCB_NO_HW_CHG;\n\n\tif (pf->lag && pf->lag->bonded) {\n\t\tnetdev_err(netdev, \"DCB changes not allowed when in a bond\\n\");\n\t\treturn ICE_DCB_NO_HW_CHG;\n\t}\n\n\tnew_cfg = &pf->hw.port_info->qos_cfg.desired_dcbx_cfg;\n\n\tmutex_lock(&pf->tc_mutex);\n\n\terr = ice_pf_dcb_cfg(pf, new_cfg, true);\n\n\tmutex_unlock(&pf->tc_mutex);\n\treturn (err != ICE_DCB_HW_CHG_RST) ? ICE_DCB_NO_HW_CHG : err;\n}\n\nstatic const struct dcbnl_rtnl_ops dcbnl_ops = {\n\t \n\t.ieee_getets = ice_dcbnl_getets,\n\t.ieee_setets = ice_dcbnl_setets,\n\t.ieee_getpfc = ice_dcbnl_getpfc,\n\t.ieee_setpfc = ice_dcbnl_setpfc,\n\t.ieee_setapp = ice_dcbnl_setapp,\n\t.ieee_delapp = ice_dcbnl_delapp,\n\n\t \n\t.getstate = ice_dcbnl_getstate,\n\t.setstate = ice_dcbnl_setstate,\n\t.getpermhwaddr = ice_dcbnl_get_perm_hw_addr,\n\t.setpgtccfgtx = ice_dcbnl_set_pg_tc_cfg_tx,\n\t.setpgbwgcfgtx = ice_dcbnl_set_pg_bwg_cfg_tx,\n\t.setpgtccfgrx = ice_dcbnl_set_pg_tc_cfg_rx,\n\t.setpgbwgcfgrx = ice_dcbnl_set_pg_bwg_cfg_rx,\n\t.getpgtccfgtx = ice_dcbnl_get_pg_tc_cfg_tx,\n\t.getpgbwgcfgtx = ice_dcbnl_get_pg_bwg_cfg_tx,\n\t.getpgtccfgrx = ice_dcbnl_get_pg_tc_cfg_rx,\n\t.getpgbwgcfgrx = ice_dcbnl_get_pg_bwg_cfg_rx,\n\t.setpfccfg = ice_dcbnl_set_pfc_cfg,\n\t.getpfccfg = ice_dcbnl_get_pfc_cfg,\n\t.setall = ice_dcbnl_cee_set_all,\n\t.getcap = ice_dcbnl_get_cap,\n\t.getnumtcs = ice_dcbnl_getnumtcs,\n\t.getpfcstate = ice_dcbnl_getpfcstate,\n\t.getapp = ice_dcbnl_getapp,\n\n\t \n\t.getdcbx = ice_dcbnl_getdcbx,\n\t.setdcbx = ice_dcbnl_setdcbx,\n};\n\n \nvoid ice_dcbnl_set_all(struct ice_vsi *vsi)\n{\n\tstruct net_device *netdev = vsi->netdev;\n\tstruct ice_dcbx_cfg *dcbxcfg;\n\tstruct ice_port_info *pi;\n\tstruct dcb_app sapp;\n\tstruct ice_pf *pf;\n\tunsigned int i;\n\n\tif (!netdev)\n\t\treturn;\n\n\tpf = ice_netdev_to_pf(netdev);\n\tpi = pf->hw.port_info;\n\n\t \n\tif (pf->dcbx_cap & DCB_CAP_DCBX_HOST)\n\t\treturn;\n\n\t \n\tif (!test_bit(ICE_FLAG_DCB_ENA, pf->flags))\n\t\treturn;\n\n\tdcbxcfg = &pi->qos_cfg.local_dcbx_cfg;\n\n\tfor (i = 0; i < dcbxcfg->numapps; i++) {\n\t\tu8 prio, tc_map;\n\n\t\tprio = dcbxcfg->app[i].priority;\n\t\ttc_map = BIT(dcbxcfg->etscfg.prio_table[prio]);\n\n\t\t \n\t\tif (tc_map & vsi->tc_cfg.ena_tc) {\n\t\t\tsapp.selector = dcbxcfg->app[i].selector;\n\t\t\tsapp.protocol = dcbxcfg->app[i].prot_id;\n\t\t\tsapp.priority = prio;\n\t\t\tdcb_ieee_setapp(netdev, &sapp);\n\t\t}\n\t}\n\t \n\tdcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_SET, 0, 0);\n}\n\n \nstatic void\nice_dcbnl_vsi_del_app(struct ice_vsi *vsi,\n\t\t      struct ice_dcb_app_priority_table *app)\n{\n\tstruct dcb_app sapp;\n\tint err;\n\n\tsapp.selector = app->selector;\n\tsapp.protocol = app->prot_id;\n\tsapp.priority = app->priority;\n\terr = ice_dcbnl_delapp(vsi->netdev, &sapp);\n\tdev_dbg(ice_pf_to_dev(vsi->back), \"Deleting app for VSI idx=%d err=%d sel=%d proto=0x%x, prio=%d\\n\",\n\t\tvsi->idx, err, app->selector, app->prot_id, app->priority);\n}\n\n \nvoid\nice_dcbnl_flush_apps(struct ice_pf *pf, struct ice_dcbx_cfg *old_cfg,\n\t\t     struct ice_dcbx_cfg *new_cfg)\n{\n\tstruct ice_vsi *main_vsi = ice_get_main_vsi(pf);\n\tunsigned int i;\n\n\tif (!main_vsi)\n\t\treturn;\n\n\tfor (i = 0; i < old_cfg->numapps; i++) {\n\t\tstruct ice_dcb_app_priority_table app = old_cfg->app[i];\n\n\t\t \n\t\tif (!ice_dcbnl_find_app(new_cfg, &app))\n\t\t\tice_dcbnl_vsi_del_app(main_vsi, &app);\n\t}\n}\n\n \nvoid ice_dcbnl_setup(struct ice_vsi *vsi)\n{\n\tstruct net_device *netdev = vsi->netdev;\n\tstruct ice_pf *pf;\n\n\tpf = ice_netdev_to_pf(netdev);\n\tif (!test_bit(ICE_FLAG_DCB_CAPABLE, pf->flags))\n\t\treturn;\n\n\tnetdev->dcbnl_ops = &dcbnl_ops;\n\tice_dcbnl_set_all(vsi);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}