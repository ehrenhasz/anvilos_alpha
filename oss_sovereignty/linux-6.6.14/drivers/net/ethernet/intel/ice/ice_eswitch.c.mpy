{
  "module_name": "ice_eswitch.c",
  "hash_id": "1892a66709118c9ba6f2265a90b3d289e3e6ce3d9051d4c2af31265a2ad151fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ice/ice_eswitch.c",
  "human_readable_source": "\n \n\n#include \"ice.h\"\n#include \"ice_lib.h\"\n#include \"ice_eswitch.h\"\n#include \"ice_eswitch_br.h\"\n#include \"ice_fltr.h\"\n#include \"ice_repr.h\"\n#include \"ice_devlink.h\"\n#include \"ice_tc_lib.h\"\n\n \nstatic int\nice_eswitch_add_vf_sp_rule(struct ice_pf *pf, struct ice_vf *vf)\n{\n\tstruct ice_vsi *ctrl_vsi = pf->switchdev.control_vsi;\n\tstruct ice_adv_rule_info rule_info = { 0 };\n\tstruct ice_adv_lkup_elem *list;\n\tstruct ice_hw *hw = &pf->hw;\n\tconst u16 lkups_cnt = 1;\n\tint err;\n\n\tlist = kcalloc(lkups_cnt, sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tice_rule_add_src_vsi_metadata(list);\n\n\trule_info.sw_act.flag = ICE_FLTR_TX;\n\trule_info.sw_act.vsi_handle = ctrl_vsi->idx;\n\trule_info.sw_act.fltr_act = ICE_FWD_TO_Q;\n\trule_info.sw_act.fwd_id.q_id = hw->func_caps.common_cap.rxq_first_id +\n\t\t\t\t       ctrl_vsi->rxq_map[vf->vf_id];\n\trule_info.flags_info.act |= ICE_SINGLE_ACT_LB_ENABLE;\n\trule_info.flags_info.act_valid = true;\n\trule_info.tun_type = ICE_SW_TUN_AND_NON_TUN;\n\trule_info.src_vsi = vf->lan_vsi_idx;\n\n\terr = ice_add_adv_rule(hw, list, lkups_cnt, &rule_info,\n\t\t\t       &vf->repr->sp_rule);\n\tif (err)\n\t\tdev_err(ice_pf_to_dev(pf), \"Unable to add VF slow-path rule in switchdev mode for VF %d\",\n\t\t\tvf->vf_id);\n\n\tkfree(list);\n\treturn err;\n}\n\n \nstatic void ice_eswitch_del_vf_sp_rule(struct ice_vf *vf)\n{\n\tif (!vf->repr)\n\t\treturn;\n\n\tice_rem_adv_rule_by_id(&vf->pf->hw, &vf->repr->sp_rule);\n}\n\n \nstatic int ice_eswitch_setup_env(struct ice_pf *pf)\n{\n\tstruct ice_vsi *uplink_vsi = pf->switchdev.uplink_vsi;\n\tstruct net_device *uplink_netdev = uplink_vsi->netdev;\n\tstruct ice_vsi *ctrl_vsi = pf->switchdev.control_vsi;\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\tbool rule_added = false;\n\n\tice_remove_vsi_fltr(&pf->hw, uplink_vsi->idx);\n\n\tnetif_addr_lock_bh(uplink_netdev);\n\t__dev_uc_unsync(uplink_netdev, NULL);\n\t__dev_mc_unsync(uplink_netdev, NULL);\n\tnetif_addr_unlock_bh(uplink_netdev);\n\n\tif (ice_vsi_add_vlan_zero(uplink_vsi))\n\t\tgoto err_def_rx;\n\n\tif (!ice_is_dflt_vsi_in_use(uplink_vsi->port_info)) {\n\t\tif (ice_set_dflt_vsi(uplink_vsi))\n\t\t\tgoto err_def_rx;\n\t\trule_added = true;\n\t}\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(uplink_vsi);\n\tif (vlan_ops->dis_rx_filtering(uplink_vsi))\n\t\tgoto err_dis_rx;\n\n\tif (ice_vsi_update_security(uplink_vsi, ice_vsi_ctx_set_allow_override))\n\t\tgoto err_override_uplink;\n\n\tif (ice_vsi_update_security(ctrl_vsi, ice_vsi_ctx_set_allow_override))\n\t\tgoto err_override_control;\n\n\tif (ice_vsi_update_local_lb(uplink_vsi, true))\n\t\tgoto err_override_local_lb;\n\n\treturn 0;\n\nerr_override_local_lb:\n\tice_vsi_update_security(ctrl_vsi, ice_vsi_ctx_clear_allow_override);\nerr_override_control:\n\tice_vsi_update_security(uplink_vsi, ice_vsi_ctx_clear_allow_override);\nerr_override_uplink:\n\tvlan_ops->ena_rx_filtering(uplink_vsi);\nerr_dis_rx:\n\tif (rule_added)\n\t\tice_clear_dflt_vsi(uplink_vsi);\nerr_def_rx:\n\tice_fltr_add_mac_and_broadcast(uplink_vsi,\n\t\t\t\t       uplink_vsi->port_info->mac.perm_addr,\n\t\t\t\t       ICE_FWD_TO_VSI);\n\treturn -ENODEV;\n}\n\n \nstatic void ice_eswitch_remap_rings_to_vectors(struct ice_pf *pf)\n{\n\tstruct ice_vsi *vsi = pf->switchdev.control_vsi;\n\tint q_id;\n\n\tice_for_each_txq(vsi, q_id) {\n\t\tstruct ice_q_vector *q_vector;\n\t\tstruct ice_tx_ring *tx_ring;\n\t\tstruct ice_rx_ring *rx_ring;\n\t\tstruct ice_repr *repr;\n\t\tstruct ice_vf *vf;\n\n\t\tvf = ice_get_vf_by_id(pf, q_id);\n\t\tif (WARN_ON(!vf))\n\t\t\tcontinue;\n\n\t\trepr = vf->repr;\n\t\tq_vector = repr->q_vector;\n\t\ttx_ring = vsi->tx_rings[q_id];\n\t\trx_ring = vsi->rx_rings[q_id];\n\n\t\tq_vector->vsi = vsi;\n\t\tq_vector->reg_idx = vsi->q_vectors[0]->reg_idx;\n\n\t\tq_vector->num_ring_tx = 1;\n\t\tq_vector->tx.tx_ring = tx_ring;\n\t\ttx_ring->q_vector = q_vector;\n\t\ttx_ring->next = NULL;\n\t\ttx_ring->netdev = repr->netdev;\n\t\t \n\t\ttx_ring->q_index = 0;\n\n\t\tq_vector->num_ring_rx = 1;\n\t\tq_vector->rx.rx_ring = rx_ring;\n\t\trx_ring->q_vector = q_vector;\n\t\trx_ring->next = NULL;\n\t\trx_ring->netdev = repr->netdev;\n\n\t\tice_put_vf(vf);\n\t}\n}\n\n \nstatic void\nice_eswitch_release_reprs(struct ice_pf *pf, struct ice_vsi *ctrl_vsi)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tlockdep_assert_held(&pf->vfs.table_lock);\n\n\tice_for_each_vf(pf, bkt, vf) {\n\t\tstruct ice_vsi *vsi = vf->repr->src_vsi;\n\n\t\t \n\t\tif (!vf->repr->dst)\n\t\t\tcontinue;\n\n\t\tice_vsi_update_security(vsi, ice_vsi_ctx_set_antispoof);\n\t\tmetadata_dst_free(vf->repr->dst);\n\t\tvf->repr->dst = NULL;\n\t\tice_eswitch_del_vf_sp_rule(vf);\n\t\tice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr,\n\t\t\t\t\t       ICE_FWD_TO_VSI);\n\n\t\tnetif_napi_del(&vf->repr->q_vector->napi);\n\t}\n}\n\n \nstatic int ice_eswitch_setup_reprs(struct ice_pf *pf)\n{\n\tstruct ice_vsi *ctrl_vsi = pf->switchdev.control_vsi;\n\tint max_vsi_num = 0;\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tlockdep_assert_held(&pf->vfs.table_lock);\n\n\tice_for_each_vf(pf, bkt, vf) {\n\t\tstruct ice_vsi *vsi = vf->repr->src_vsi;\n\n\t\tice_remove_vsi_fltr(&pf->hw, vsi->idx);\n\t\tvf->repr->dst = metadata_dst_alloc(0, METADATA_HW_PORT_MUX,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!vf->repr->dst) {\n\t\t\tice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr,\n\t\t\t\t\t\t       ICE_FWD_TO_VSI);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (ice_eswitch_add_vf_sp_rule(pf, vf)) {\n\t\t\tice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr,\n\t\t\t\t\t\t       ICE_FWD_TO_VSI);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (ice_vsi_update_security(vsi, ice_vsi_ctx_clear_antispoof)) {\n\t\t\tice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr,\n\t\t\t\t\t\t       ICE_FWD_TO_VSI);\n\t\t\tice_eswitch_del_vf_sp_rule(vf);\n\t\t\tmetadata_dst_free(vf->repr->dst);\n\t\t\tvf->repr->dst = NULL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (ice_vsi_add_vlan_zero(vsi)) {\n\t\t\tice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr,\n\t\t\t\t\t\t       ICE_FWD_TO_VSI);\n\t\t\tice_eswitch_del_vf_sp_rule(vf);\n\t\t\tmetadata_dst_free(vf->repr->dst);\n\t\t\tvf->repr->dst = NULL;\n\t\t\tice_vsi_update_security(vsi, ice_vsi_ctx_set_antispoof);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (max_vsi_num < vsi->vsi_num)\n\t\t\tmax_vsi_num = vsi->vsi_num;\n\n\t\tnetif_napi_add(vf->repr->netdev, &vf->repr->q_vector->napi,\n\t\t\t       ice_napi_poll);\n\n\t\tnetif_keep_dst(vf->repr->netdev);\n\t}\n\n\tice_for_each_vf(pf, bkt, vf) {\n\t\tstruct ice_repr *repr = vf->repr;\n\t\tstruct ice_vsi *vsi = repr->src_vsi;\n\t\tstruct metadata_dst *dst;\n\n\t\tdst = repr->dst;\n\t\tdst->u.port_info.port_id = vsi->vsi_num;\n\t\tdst->u.port_info.lower_dev = repr->netdev;\n\t\tice_repr_set_traffic_vsi(repr, ctrl_vsi);\n\t}\n\n\treturn 0;\n\nerr:\n\tice_eswitch_release_reprs(pf, ctrl_vsi);\n\n\treturn -ENODEV;\n}\n\n \nvoid ice_eswitch_update_repr(struct ice_vsi *vsi)\n{\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_repr *repr;\n\tstruct ice_vf *vf;\n\tint ret;\n\n\tif (!ice_is_switchdev_running(pf))\n\t\treturn;\n\n\tvf = vsi->vf;\n\trepr = vf->repr;\n\trepr->src_vsi = vsi;\n\trepr->dst->u.port_info.port_id = vsi->vsi_num;\n\n\tif (repr->br_port)\n\t\trepr->br_port->vsi = vsi;\n\n\tret = ice_vsi_update_security(vsi, ice_vsi_ctx_clear_antispoof);\n\tif (ret) {\n\t\tice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr, ICE_FWD_TO_VSI);\n\t\tdev_err(ice_pf_to_dev(pf), \"Failed to update VF %d port representor\",\n\t\t\tvsi->vf->vf_id);\n\t}\n}\n\n \nnetdev_tx_t\nice_eswitch_port_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ice_netdev_priv *np;\n\tstruct ice_repr *repr;\n\tstruct ice_vsi *vsi;\n\n\tnp = netdev_priv(netdev);\n\tvsi = np->vsi;\n\n\tif (!vsi || !ice_is_switchdev_running(vsi->back))\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (ice_is_reset_in_progress(vsi->back->state) ||\n\t    test_bit(ICE_VF_DIS, vsi->back->state))\n\t\treturn NETDEV_TX_BUSY;\n\n\trepr = ice_netdev_to_repr(netdev);\n\tskb_dst_drop(skb);\n\tdst_hold((struct dst_entry *)repr->dst);\n\tskb_dst_set(skb, (struct dst_entry *)repr->dst);\n\tskb->queue_mapping = repr->vf->vf_id;\n\n\treturn ice_start_xmit(skb, netdev);\n}\n\n \nvoid\nice_eswitch_set_target_vsi(struct sk_buff *skb,\n\t\t\t   struct ice_tx_offload_params *off)\n{\n\tstruct metadata_dst *dst = skb_metadata_dst(skb);\n\tu64 cd_cmd, dst_vsi;\n\n\tif (!dst) {\n\t\tcd_cmd = ICE_TX_CTX_DESC_SWTCH_UPLINK << ICE_TXD_CTX_QW1_CMD_S;\n\t\toff->cd_qw1 |= (cd_cmd | ICE_TX_DESC_DTYPE_CTX);\n\t} else {\n\t\tcd_cmd = ICE_TX_CTX_DESC_SWTCH_VSI << ICE_TXD_CTX_QW1_CMD_S;\n\t\tdst_vsi = ((u64)dst->u.port_info.port_id <<\n\t\t\t   ICE_TXD_CTX_QW1_VSI_S) & ICE_TXD_CTX_QW1_VSI_M;\n\t\toff->cd_qw1 = cd_cmd | dst_vsi | ICE_TX_DESC_DTYPE_CTX;\n\t}\n}\n\n \nstatic void ice_eswitch_release_env(struct ice_pf *pf)\n{\n\tstruct ice_vsi *uplink_vsi = pf->switchdev.uplink_vsi;\n\tstruct ice_vsi *ctrl_vsi = pf->switchdev.control_vsi;\n\tstruct ice_vsi_vlan_ops *vlan_ops;\n\n\tvlan_ops = ice_get_compat_vsi_vlan_ops(uplink_vsi);\n\n\tice_vsi_update_local_lb(uplink_vsi, false);\n\tice_vsi_update_security(ctrl_vsi, ice_vsi_ctx_clear_allow_override);\n\tice_vsi_update_security(uplink_vsi, ice_vsi_ctx_clear_allow_override);\n\tvlan_ops->ena_rx_filtering(uplink_vsi);\n\tice_clear_dflt_vsi(uplink_vsi);\n\tice_fltr_add_mac_and_broadcast(uplink_vsi,\n\t\t\t\t       uplink_vsi->port_info->mac.perm_addr,\n\t\t\t\t       ICE_FWD_TO_VSI);\n}\n\n \nstatic struct ice_vsi *\nice_eswitch_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi)\n{\n\tstruct ice_vsi_cfg_params params = {};\n\n\tparams.type = ICE_VSI_SWITCHDEV_CTRL;\n\tparams.pi = pi;\n\tparams.flags = ICE_VSI_FLAG_INIT;\n\n\treturn ice_vsi_setup(pf, &params);\n}\n\n \nstatic void ice_eswitch_napi_del(struct ice_pf *pf)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tlockdep_assert_held(&pf->vfs.table_lock);\n\n\tice_for_each_vf(pf, bkt, vf)\n\t\tnetif_napi_del(&vf->repr->q_vector->napi);\n}\n\n \nstatic void ice_eswitch_napi_enable(struct ice_pf *pf)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tlockdep_assert_held(&pf->vfs.table_lock);\n\n\tice_for_each_vf(pf, bkt, vf)\n\t\tnapi_enable(&vf->repr->q_vector->napi);\n}\n\n \nstatic void ice_eswitch_napi_disable(struct ice_pf *pf)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tlockdep_assert_held(&pf->vfs.table_lock);\n\n\tice_for_each_vf(pf, bkt, vf)\n\t\tnapi_disable(&vf->repr->q_vector->napi);\n}\n\n \nstatic int ice_eswitch_enable_switchdev(struct ice_pf *pf)\n{\n\tstruct ice_vsi *ctrl_vsi, *uplink_vsi;\n\n\tuplink_vsi = ice_get_main_vsi(pf);\n\tif (!uplink_vsi)\n\t\treturn -ENODEV;\n\n\tif (netif_is_any_bridge_port(uplink_vsi->netdev)) {\n\t\tdev_err(ice_pf_to_dev(pf),\n\t\t\t\"Uplink port cannot be a bridge port\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpf->switchdev.control_vsi = ice_eswitch_vsi_setup(pf, pf->hw.port_info);\n\tif (!pf->switchdev.control_vsi)\n\t\treturn -ENODEV;\n\n\tctrl_vsi = pf->switchdev.control_vsi;\n\tpf->switchdev.uplink_vsi = uplink_vsi;\n\n\tif (ice_eswitch_setup_env(pf))\n\t\tgoto err_vsi;\n\n\tif (ice_repr_add_for_all_vfs(pf))\n\t\tgoto err_repr_add;\n\n\tif (ice_eswitch_setup_reprs(pf))\n\t\tgoto err_setup_reprs;\n\n\tice_eswitch_remap_rings_to_vectors(pf);\n\n\tif (ice_vsi_open(ctrl_vsi))\n\t\tgoto err_setup_reprs;\n\n\tif (ice_eswitch_br_offloads_init(pf))\n\t\tgoto err_br_offloads;\n\n\tice_eswitch_napi_enable(pf);\n\n\treturn 0;\n\nerr_br_offloads:\n\tice_vsi_close(ctrl_vsi);\nerr_setup_reprs:\n\tice_repr_rem_from_all_vfs(pf);\nerr_repr_add:\n\tice_eswitch_release_env(pf);\nerr_vsi:\n\tice_vsi_release(ctrl_vsi);\n\treturn -ENODEV;\n}\n\n \nstatic void ice_eswitch_disable_switchdev(struct ice_pf *pf)\n{\n\tstruct ice_vsi *ctrl_vsi = pf->switchdev.control_vsi;\n\n\tice_eswitch_napi_disable(pf);\n\tice_eswitch_br_offloads_deinit(pf);\n\tice_eswitch_release_env(pf);\n\tice_eswitch_release_reprs(pf, ctrl_vsi);\n\tice_vsi_release(ctrl_vsi);\n\tice_repr_rem_from_all_vfs(pf);\n}\n\n \nint\nice_eswitch_mode_set(struct devlink *devlink, u16 mode,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ice_pf *pf = devlink_priv(devlink);\n\n\tif (pf->eswitch_mode == mode)\n\t\treturn 0;\n\n\tif (ice_has_vfs(pf)) {\n\t\tdev_info(ice_pf_to_dev(pf), \"Changing eswitch mode is allowed only if there is no VFs created\");\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing eswitch mode is allowed only if there is no VFs created\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (mode) {\n\tcase DEVLINK_ESWITCH_MODE_LEGACY:\n\t\tdev_info(ice_pf_to_dev(pf), \"PF %d changed eswitch mode to legacy\",\n\t\t\t pf->hw.pf_id);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changed eswitch mode to legacy\");\n\t\tbreak;\n\tcase DEVLINK_ESWITCH_MODE_SWITCHDEV:\n\t{\n\t\tif (ice_is_adq_active(pf)) {\n\t\t\tdev_err(ice_pf_to_dev(pf), \"Couldn't change eswitch mode to switchdev - ADQ is active. Delete ADQ configs and try again, e.g. tc qdisc del dev $PF root\");\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Couldn't change eswitch mode to switchdev - ADQ is active. Delete ADQ configs and try again, e.g. tc qdisc del dev $PF root\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tdev_info(ice_pf_to_dev(pf), \"PF %d changed eswitch mode to switchdev\",\n\t\t\t pf->hw.pf_id);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changed eswitch mode to switchdev\");\n\t\tbreak;\n\t}\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown eswitch mode\");\n\t\treturn -EINVAL;\n\t}\n\n\tpf->eswitch_mode = mode;\n\treturn 0;\n}\n\n \nint ice_eswitch_mode_get(struct devlink *devlink, u16 *mode)\n{\n\tstruct ice_pf *pf = devlink_priv(devlink);\n\n\t*mode = pf->eswitch_mode;\n\treturn 0;\n}\n\n \nbool ice_is_eswitch_mode_switchdev(struct ice_pf *pf)\n{\n\treturn pf->eswitch_mode == DEVLINK_ESWITCH_MODE_SWITCHDEV;\n}\n\n \nvoid ice_eswitch_release(struct ice_pf *pf)\n{\n\tif (pf->eswitch_mode == DEVLINK_ESWITCH_MODE_LEGACY)\n\t\treturn;\n\n\tice_eswitch_disable_switchdev(pf);\n\tpf->switchdev.is_running = false;\n}\n\n \nint ice_eswitch_configure(struct ice_pf *pf)\n{\n\tint status;\n\n\tif (pf->eswitch_mode == DEVLINK_ESWITCH_MODE_LEGACY || pf->switchdev.is_running)\n\t\treturn 0;\n\n\tstatus = ice_eswitch_enable_switchdev(pf);\n\tif (status)\n\t\treturn status;\n\n\tpf->switchdev.is_running = true;\n\treturn 0;\n}\n\n \nstatic void ice_eswitch_start_all_tx_queues(struct ice_pf *pf)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tlockdep_assert_held(&pf->vfs.table_lock);\n\n\tif (test_bit(ICE_DOWN, pf->state))\n\t\treturn;\n\n\tice_for_each_vf(pf, bkt, vf) {\n\t\tif (vf->repr)\n\t\t\tice_repr_start_tx_queues(vf->repr);\n\t}\n}\n\n \nvoid ice_eswitch_stop_all_tx_queues(struct ice_pf *pf)\n{\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tlockdep_assert_held(&pf->vfs.table_lock);\n\n\tif (test_bit(ICE_DOWN, pf->state))\n\t\treturn;\n\n\tice_for_each_vf(pf, bkt, vf) {\n\t\tif (vf->repr)\n\t\t\tice_repr_stop_tx_queues(vf->repr);\n\t}\n}\n\n \nint ice_eswitch_rebuild(struct ice_pf *pf)\n{\n\tstruct ice_vsi *ctrl_vsi = pf->switchdev.control_vsi;\n\tint status;\n\n\tice_eswitch_napi_disable(pf);\n\tice_eswitch_napi_del(pf);\n\n\tstatus = ice_eswitch_setup_env(pf);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ice_eswitch_setup_reprs(pf);\n\tif (status)\n\t\treturn status;\n\n\tice_eswitch_remap_rings_to_vectors(pf);\n\n\tice_replay_tc_fltrs(pf);\n\n\tstatus = ice_vsi_open(ctrl_vsi);\n\tif (status)\n\t\treturn status;\n\n\tice_eswitch_napi_enable(pf);\n\tice_eswitch_start_all_tx_queues(pf);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}