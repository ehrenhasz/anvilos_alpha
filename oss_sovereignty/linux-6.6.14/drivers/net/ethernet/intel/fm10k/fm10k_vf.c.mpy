{
  "module_name": "fm10k_vf.c",
  "hash_id": "cfbb26d27811139069e69b624cdb9c0c3c61a83c02e5e016694e8b4f295ab62e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_vf.c",
  "human_readable_source": "\n \n\n#include \"fm10k_vf.h\"\n\n \nstatic s32 fm10k_stop_hw_vf(struct fm10k_hw *hw)\n{\n\tu8 *perm_addr = hw->mac.perm_addr;\n\tu32 bal = 0, bah = 0, tdlen;\n\ts32 err;\n\tu16 i;\n\n\t \n\terr = fm10k_stop_hw_generic(hw);\n\tif (err && err != FM10K_ERR_REQUESTS_PENDING)\n\t\treturn err;\n\n\t \n\tif (is_valid_ether_addr(perm_addr)) {\n\t\tbal = (((u32)perm_addr[3]) << 24) |\n\t\t      (((u32)perm_addr[4]) << 16) |\n\t\t      (((u32)perm_addr[5]) << 8);\n\t\tbah = (((u32)0xFF)\t   << 24) |\n\t\t      (((u32)perm_addr[0]) << 16) |\n\t\t      (((u32)perm_addr[1]) << 8) |\n\t\t       ((u32)perm_addr[2]);\n\t}\n\n\t \n\ttdlen = hw->mac.itr_scale << FM10K_TDLEN_ITR_SCALE_SHIFT;\n\n\t \n\tfor (i = 0; i < hw->mac.max_queues; i++) {\n\t\tfm10k_write_reg(hw, FM10K_TDBAL(i), bal);\n\t\tfm10k_write_reg(hw, FM10K_TDBAH(i), bah);\n\t\tfm10k_write_reg(hw, FM10K_RDBAL(i), bal);\n\t\tfm10k_write_reg(hw, FM10K_RDBAH(i), bah);\n\t\t \n\t\tfm10k_write_reg(hw, FM10K_TDLEN(i), tdlen);\n\t}\n\n\treturn err;\n}\n\n \nstatic s32 fm10k_reset_hw_vf(struct fm10k_hw *hw)\n{\n\ts32 err;\n\n\t \n\terr = fm10k_stop_hw_vf(hw);\n\tif (err == FM10K_ERR_REQUESTS_PENDING)\n\t\thw->mac.reset_while_pending++;\n\telse if (err)\n\t\treturn err;\n\n\t \n\tfm10k_write_reg(hw, FM10K_VFCTRL, FM10K_VFCTRL_RST);\n\n\t \n\tfm10k_write_flush(hw);\n\tudelay(FM10K_RESET_TIMEOUT);\n\n\t \n\tfm10k_write_reg(hw, FM10K_VFCTRL, 0);\n\tif (fm10k_read_reg(hw, FM10K_VFCTRL) & FM10K_VFCTRL_RST)\n\t\treturn FM10K_ERR_RESET_FAILED;\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_init_hw_vf(struct fm10k_hw *hw)\n{\n\tu32 tqdloc, tqdloc0 = ~fm10k_read_reg(hw, FM10K_TQDLOC(0));\n\ts32 err;\n\tu16 i;\n\n\t \n\tif (!~fm10k_read_reg(hw, FM10K_TXQCTL(0)) ||\n\t    !~fm10k_read_reg(hw, FM10K_RXQCTL(0))) {\n\t\terr = FM10K_ERR_NO_RESOURCES;\n\t\tgoto reset_max_queues;\n\t}\n\n\t \n\tfor (i = 1; tqdloc0 && (i < FM10K_MAX_QUEUES_POOL); i++) {\n\t\t \n\t\ttqdloc = ~fm10k_read_reg(hw, FM10K_TQDLOC(i));\n\t\tif (!tqdloc || (tqdloc == tqdloc0))\n\t\t\tbreak;\n\n\t\t \n\t\tif (!~fm10k_read_reg(hw, FM10K_TXQCTL(i)) ||\n\t\t    !~fm10k_read_reg(hw, FM10K_RXQCTL(i)))\n\t\t\tbreak;\n\t}\n\n\t \n\terr = fm10k_disable_queues_generic(hw, i);\n\tif (err)\n\t\tgoto reset_max_queues;\n\n\t \n\thw->mac.max_queues = i;\n\n\t \n\thw->mac.default_vid = (fm10k_read_reg(hw, FM10K_TXQCTL(0)) &\n\t\t\t       FM10K_TXQCTL_VID_MASK) >> FM10K_TXQCTL_VID_SHIFT;\n\t \n\thw->mac.itr_scale = (fm10k_read_reg(hw, FM10K_TDLEN(0)) &\n\t\t\t     FM10K_TDLEN_ITR_SCALE_MASK) >>\n\t\t\t    FM10K_TDLEN_ITR_SCALE_SHIFT;\n\n\treturn 0;\n\nreset_max_queues:\n\thw->mac.max_queues = 0;\n\n\treturn err;\n}\n\n \nconst struct fm10k_tlv_attr fm10k_mac_vlan_msg_attr[] = {\n\tFM10K_TLV_ATTR_U32(FM10K_MAC_VLAN_MSG_VLAN),\n\tFM10K_TLV_ATTR_BOOL(FM10K_MAC_VLAN_MSG_SET),\n\tFM10K_TLV_ATTR_MAC_ADDR(FM10K_MAC_VLAN_MSG_MAC),\n\tFM10K_TLV_ATTR_MAC_ADDR(FM10K_MAC_VLAN_MSG_DEFAULT_MAC),\n\tFM10K_TLV_ATTR_MAC_ADDR(FM10K_MAC_VLAN_MSG_MULTICAST),\n\tFM10K_TLV_ATTR_LAST\n};\n\n \nstatic s32 fm10k_update_vlan_vf(struct fm10k_hw *hw, u32 vid, u8 vsi, bool set)\n{\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 msg[4];\n\n\t \n\tif (vsi)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif ((vid << 16 | vid) >> 28)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (!set)\n\t\tvid |= FM10K_VLAN_CLEAR;\n\n\t \n\tfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MAC_VLAN);\n\tfm10k_tlv_attr_put_u32(msg, FM10K_MAC_VLAN_MSG_VLAN, vid);\n\n\t \n\treturn mbx->ops.enqueue_tx(hw, mbx, msg);\n}\n\n \ns32 fm10k_msg_mac_vlan_vf(struct fm10k_hw *hw, u32 **results,\n\t\t\t  struct fm10k_mbx_info __always_unused *mbx)\n{\n\tu8 perm_addr[ETH_ALEN];\n\tu16 vid;\n\ts32 err;\n\n\t \n\terr = fm10k_tlv_attr_get_mac_vlan(\n\t\t\t\t\tresults[FM10K_MAC_VLAN_MSG_DEFAULT_MAC],\n\t\t\t\t\tperm_addr, &vid);\n\tif (err)\n\t\treturn err;\n\n\tether_addr_copy(hw->mac.perm_addr, perm_addr);\n\thw->mac.default_vid = vid & (FM10K_VLAN_TABLE_VID_MAX - 1);\n\thw->mac.vlan_override = !!(vid & FM10K_VLAN_OVERRIDE);\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_read_mac_addr_vf(struct fm10k_hw *hw)\n{\n\tu8 perm_addr[ETH_ALEN];\n\tu32 base_addr;\n\n\tbase_addr = fm10k_read_reg(hw, FM10K_TDBAL(0));\n\n\t \n\tif (base_addr << 24)\n\t\treturn  FM10K_ERR_INVALID_MAC_ADDR;\n\n\tperm_addr[3] = (u8)(base_addr >> 24);\n\tperm_addr[4] = (u8)(base_addr >> 16);\n\tperm_addr[5] = (u8)(base_addr >> 8);\n\n\tbase_addr = fm10k_read_reg(hw, FM10K_TDBAH(0));\n\n\t \n\tif ((~base_addr) >> 24)\n\t\treturn  FM10K_ERR_INVALID_MAC_ADDR;\n\n\tperm_addr[0] = (u8)(base_addr >> 16);\n\tperm_addr[1] = (u8)(base_addr >> 8);\n\tperm_addr[2] = (u8)(base_addr);\n\n\tether_addr_copy(hw->mac.perm_addr, perm_addr);\n\tether_addr_copy(hw->mac.addr, perm_addr);\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_update_uc_addr_vf(struct fm10k_hw *hw,\n\t\t\t\t   u16 __always_unused glort,\n\t\t\t\t   const u8 *mac, u16 vid, bool add,\n\t\t\t\t   u8 __always_unused flags)\n{\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 msg[7];\n\n\t \n\tif (vid >= FM10K_VLAN_TABLE_VID_MAX)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (!is_valid_ether_addr(mac))\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (is_valid_ether_addr(hw->mac.perm_addr) &&\n\t    !ether_addr_equal(hw->mac.perm_addr, mac))\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (!add)\n\t\tvid |= FM10K_VLAN_CLEAR;\n\n\t \n\tfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MAC_VLAN);\n\tfm10k_tlv_attr_put_mac_vlan(msg, FM10K_MAC_VLAN_MSG_MAC, mac, vid);\n\n\t \n\treturn mbx->ops.enqueue_tx(hw, mbx, msg);\n}\n\n \nstatic s32 fm10k_update_mc_addr_vf(struct fm10k_hw *hw,\n\t\t\t\t   u16 __always_unused glort,\n\t\t\t\t   const u8 *mac, u16 vid, bool add)\n{\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 msg[7];\n\n\t \n\tif (vid >= FM10K_VLAN_TABLE_VID_MAX)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (!is_multicast_ether_addr(mac))\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (!add)\n\t\tvid |= FM10K_VLAN_CLEAR;\n\n\t \n\tfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MAC_VLAN);\n\tfm10k_tlv_attr_put_mac_vlan(msg, FM10K_MAC_VLAN_MSG_MULTICAST,\n\t\t\t\t    mac, vid);\n\n\t \n\treturn mbx->ops.enqueue_tx(hw, mbx, msg);\n}\n\n \nstatic void fm10k_update_int_moderator_vf(struct fm10k_hw *hw)\n{\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 msg[1];\n\n\t \n\tfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MSIX);\n\n\t \n\tmbx->ops.enqueue_tx(hw, mbx, msg);\n}\n\n \nconst struct fm10k_tlv_attr fm10k_lport_state_msg_attr[] = {\n\tFM10K_TLV_ATTR_BOOL(FM10K_LPORT_STATE_MSG_DISABLE),\n\tFM10K_TLV_ATTR_U8(FM10K_LPORT_STATE_MSG_XCAST_MODE),\n\tFM10K_TLV_ATTR_BOOL(FM10K_LPORT_STATE_MSG_READY),\n\tFM10K_TLV_ATTR_LAST\n};\n\n \ns32 fm10k_msg_lport_state_vf(struct fm10k_hw *hw, u32 **results,\n\t\t\t     struct fm10k_mbx_info __always_unused *mbx)\n{\n\thw->mac.dglort_map = !results[FM10K_LPORT_STATE_MSG_READY] ?\n\t\t\t     FM10K_DGLORTMAP_NONE : FM10K_DGLORTMAP_ZERO;\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_update_lport_state_vf(struct fm10k_hw *hw,\n\t\t\t\t       u16 __always_unused glort,\n\t\t\t\t       u16 __always_unused count, bool enable)\n{\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 msg[2];\n\n\t \n\thw->mac.dglort_map = FM10K_DGLORTMAP_NONE;\n\n\t \n\tfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_LPORT_STATE);\n\tif (!enable)\n\t\tfm10k_tlv_attr_put_bool(msg, FM10K_LPORT_STATE_MSG_DISABLE);\n\n\t \n\treturn mbx->ops.enqueue_tx(hw, mbx, msg);\n}\n\n \nstatic s32 fm10k_update_xcast_mode_vf(struct fm10k_hw *hw,\n\t\t\t\t      u16 __always_unused glort, u8 mode)\n{\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 msg[3];\n\n\tif (mode > FM10K_XCAST_MODE_NONE)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_LPORT_STATE);\n\tfm10k_tlv_attr_put_u8(msg, FM10K_LPORT_STATE_MSG_XCAST_MODE, mode);\n\n\t \n\treturn mbx->ops.enqueue_tx(hw, mbx, msg);\n}\n\n \nstatic void fm10k_update_hw_stats_vf(struct fm10k_hw *hw,\n\t\t\t\t     struct fm10k_hw_stats *stats)\n{\n\tfm10k_update_hw_stats_q(hw, stats->q, 0, hw->mac.max_queues);\n}\n\n \nstatic void fm10k_rebind_hw_stats_vf(struct fm10k_hw *hw,\n\t\t\t\t     struct fm10k_hw_stats *stats)\n{\n\t \n\tfm10k_unbind_hw_stats_q(stats->q, 0, hw->mac.max_queues);\n\n\t \n\tfm10k_update_hw_stats_vf(hw, stats);\n}\n\n \nstatic s32 fm10k_configure_dglort_map_vf(struct fm10k_hw __always_unused *hw,\n\t\t\t\t\t struct fm10k_dglort_cfg *dglort)\n{\n\t \n\tif (!dglort)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\n\treturn 0;\n}\n\nstatic const struct fm10k_msg_data fm10k_msg_data_vf[] = {\n\tFM10K_TLV_MSG_TEST_HANDLER(fm10k_tlv_msg_test),\n\tFM10K_VF_MSG_MAC_VLAN_HANDLER(fm10k_msg_mac_vlan_vf),\n\tFM10K_VF_MSG_LPORT_STATE_HANDLER(fm10k_msg_lport_state_vf),\n\tFM10K_TLV_MSG_ERROR_HANDLER(fm10k_tlv_msg_error),\n};\n\nstatic const struct fm10k_mac_ops mac_ops_vf = {\n\t.get_bus_info\t\t= fm10k_get_bus_info_generic,\n\t.reset_hw\t\t= fm10k_reset_hw_vf,\n\t.init_hw\t\t= fm10k_init_hw_vf,\n\t.start_hw\t\t= fm10k_start_hw_generic,\n\t.stop_hw\t\t= fm10k_stop_hw_vf,\n\t.update_vlan\t\t= fm10k_update_vlan_vf,\n\t.read_mac_addr\t\t= fm10k_read_mac_addr_vf,\n\t.update_uc_addr\t\t= fm10k_update_uc_addr_vf,\n\t.update_mc_addr\t\t= fm10k_update_mc_addr_vf,\n\t.update_xcast_mode\t= fm10k_update_xcast_mode_vf,\n\t.update_int_moderator\t= fm10k_update_int_moderator_vf,\n\t.update_lport_state\t= fm10k_update_lport_state_vf,\n\t.update_hw_stats\t= fm10k_update_hw_stats_vf,\n\t.rebind_hw_stats\t= fm10k_rebind_hw_stats_vf,\n\t.configure_dglort_map\t= fm10k_configure_dglort_map_vf,\n\t.get_host_state\t\t= fm10k_get_host_state_generic,\n};\n\nstatic s32 fm10k_get_invariants_vf(struct fm10k_hw *hw)\n{\n\tfm10k_get_invariants_generic(hw);\n\n\treturn fm10k_pfvf_mbx_init(hw, &hw->mbx, fm10k_msg_data_vf, 0);\n}\n\nconst struct fm10k_info fm10k_vf_info = {\n\t.mac\t\t= fm10k_mac_vf,\n\t.get_invariants\t= fm10k_get_invariants_vf,\n\t.mac_ops\t= &mac_ops_vf,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}