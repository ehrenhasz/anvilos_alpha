{
  "module_name": "fm10k_main.c",
  "hash_id": "0caec7a419b8781c18f8a25babce8dade00063bf35dd7ee845504ea9ce535d8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_main.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <linux/if_macvlan.h>\n#include <linux/prefetch.h>\n\n#include \"fm10k.h\"\n\n#define DRV_SUMMARY\t\"Intel(R) Ethernet Switch Host Interface Driver\"\nchar fm10k_driver_name[] = \"fm10k\";\nstatic const char fm10k_driver_string[] = DRV_SUMMARY;\nstatic const char fm10k_copyright[] =\n\t\"Copyright(c) 2013 - 2019 Intel Corporation.\";\n\nMODULE_AUTHOR(\"Intel Corporation, <linux.nics@intel.com>\");\nMODULE_DESCRIPTION(DRV_SUMMARY);\nMODULE_LICENSE(\"GPL v2\");\n\n \nstruct workqueue_struct *fm10k_workqueue;\n\n \nstatic int __init fm10k_init_module(void)\n{\n\tint ret;\n\n\tpr_info(\"%s\\n\", fm10k_driver_string);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t \n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\n\tfm10k_dbg_init();\n\n\tret = fm10k_register_pci_driver();\n\tif (ret) {\n\t\tfm10k_dbg_exit();\n\t\tdestroy_workqueue(fm10k_workqueue);\n\t}\n\n\treturn ret;\n}\nmodule_init(fm10k_init_module);\n\n \nstatic void __exit fm10k_exit_module(void)\n{\n\tfm10k_unregister_pci_driver();\n\n\tfm10k_dbg_exit();\n\n\t \n\tdestroy_workqueue(fm10k_workqueue);\n}\nmodule_exit(fm10k_exit_module);\n\nstatic bool fm10k_alloc_mapped_page(struct fm10k_ring *rx_ring,\n\t\t\t\t    struct fm10k_rx_buffer *bi)\n{\n\tstruct page *page = bi->page;\n\tdma_addr_t dma;\n\n\t \n\tif (likely(page))\n\t\treturn true;\n\n\t \n\tpage = dev_alloc_page();\n\tif (unlikely(!page)) {\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\t \n\tdma = dma_map_page(rx_ring->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t \n\tif (dma_mapping_error(rx_ring->dev, dma)) {\n\t\t__free_page(page);\n\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\tbi->dma = dma;\n\tbi->page = page;\n\tbi->page_offset = 0;\n\n\treturn true;\n}\n\n \nvoid fm10k_alloc_rx_buffers(struct fm10k_ring *rx_ring, u16 cleaned_count)\n{\n\tunion fm10k_rx_desc *rx_desc;\n\tstruct fm10k_rx_buffer *bi;\n\tu16 i = rx_ring->next_to_use;\n\n\t \n\tif (!cleaned_count)\n\t\treturn;\n\n\trx_desc = FM10K_RX_DESC(rx_ring, i);\n\tbi = &rx_ring->rx_buffer[i];\n\ti -= rx_ring->count;\n\n\tdo {\n\t\tif (!fm10k_alloc_mapped_page(rx_ring, bi))\n\t\t\tbreak;\n\n\t\t \n\t\trx_desc->q.pkt_addr = cpu_to_le64(bi->dma + bi->page_offset);\n\n\t\trx_desc++;\n\t\tbi++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\trx_desc = FM10K_RX_DESC(rx_ring, 0);\n\t\t\tbi = rx_ring->rx_buffer;\n\t\t\ti -= rx_ring->count;\n\t\t}\n\n\t\t \n\t\trx_desc->d.staterr = 0;\n\n\t\tcleaned_count--;\n\t} while (cleaned_count);\n\n\ti += rx_ring->count;\n\n\tif (rx_ring->next_to_use != i) {\n\t\t \n\t\trx_ring->next_to_use = i;\n\n\t\t \n\t\trx_ring->next_to_alloc = i;\n\n\t\t \n\t\twmb();\n\n\t\t \n\t\twritel(i, rx_ring->tail);\n\t}\n}\n\n \nstatic void fm10k_reuse_rx_page(struct fm10k_ring *rx_ring,\n\t\t\t\tstruct fm10k_rx_buffer *old_buff)\n{\n\tstruct fm10k_rx_buffer *new_buff;\n\tu16 nta = rx_ring->next_to_alloc;\n\n\tnew_buff = &rx_ring->rx_buffer[nta];\n\n\t \n\tnta++;\n\trx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;\n\n\t \n\t*new_buff = *old_buff;\n\n\t \n\tdma_sync_single_range_for_device(rx_ring->dev, old_buff->dma,\n\t\t\t\t\t old_buff->page_offset,\n\t\t\t\t\t FM10K_RX_BUFSZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n}\n\nstatic bool fm10k_can_reuse_rx_page(struct fm10k_rx_buffer *rx_buffer,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned int __maybe_unused truesize)\n{\n\t \n\tif (!dev_page_is_reusable(page))\n\t\treturn false;\n\n#if (PAGE_SIZE < 8192)\n\t \n\tif (unlikely(page_count(page) != 1))\n\t\treturn false;\n\n\t \n\trx_buffer->page_offset ^= FM10K_RX_BUFSZ;\n#else\n\t \n\trx_buffer->page_offset += truesize;\n\n\tif (rx_buffer->page_offset > (PAGE_SIZE - FM10K_RX_BUFSZ))\n\t\treturn false;\n#endif\n\n\t \n\tpage_ref_inc(page);\n\n\treturn true;\n}\n\n \nstatic bool fm10k_add_rx_frag(struct fm10k_rx_buffer *rx_buffer,\n\t\t\t      unsigned int size,\n\t\t\t      union fm10k_rx_desc *rx_desc,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct page *page = rx_buffer->page;\n\tunsigned char *va = page_address(page) + rx_buffer->page_offset;\n#if (PAGE_SIZE < 8192)\n\tunsigned int truesize = FM10K_RX_BUFSZ;\n#else\n\tunsigned int truesize = ALIGN(size, 512);\n#endif\n\tunsigned int pull_len;\n\n\tif (unlikely(skb_is_nonlinear(skb)))\n\t\tgoto add_tail_frag;\n\n\tif (likely(size <= FM10K_RX_HDR_LEN)) {\n\t\tmemcpy(__skb_put(skb, size), va, ALIGN(size, sizeof(long)));\n\n\t\t \n\t\tif (dev_page_is_reusable(page))\n\t\t\treturn true;\n\n\t\t \n\t\t__free_page(page);\n\t\treturn false;\n\t}\n\n\t \n\tpull_len = eth_get_headlen(skb->dev, va, FM10K_RX_HDR_LEN);\n\n\t \n\tmemcpy(__skb_put(skb, pull_len), va, ALIGN(pull_len, sizeof(long)));\n\n\t \n\tva += pull_len;\n\tsize -= pull_len;\n\nadd_tail_frag:\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\n\t\t\t(unsigned long)va & ~PAGE_MASK, size, truesize);\n\n\treturn fm10k_can_reuse_rx_page(rx_buffer, page, truesize);\n}\n\nstatic struct sk_buff *fm10k_fetch_rx_buffer(struct fm10k_ring *rx_ring,\n\t\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tunsigned int size = le16_to_cpu(rx_desc->w.length);\n\tstruct fm10k_rx_buffer *rx_buffer;\n\tstruct page *page;\n\n\trx_buffer = &rx_ring->rx_buffer[rx_ring->next_to_clean];\n\tpage = rx_buffer->page;\n\tprefetchw(page);\n\n\tif (likely(!skb)) {\n\t\tvoid *page_addr = page_address(page) +\n\t\t\t\t  rx_buffer->page_offset;\n\n\t\t \n\t\tnet_prefetch(page_addr);\n\n\t\t \n\t\tskb = napi_alloc_skb(&rx_ring->q_vector->napi,\n\t\t\t\t     FM10K_RX_HDR_LEN);\n\t\tif (unlikely(!skb)) {\n\t\t\trx_ring->rx_stats.alloc_failed++;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tprefetchw(skb->data);\n\t}\n\n\t \n\tdma_sync_single_range_for_cpu(rx_ring->dev,\n\t\t\t\t      rx_buffer->dma,\n\t\t\t\t      rx_buffer->page_offset,\n\t\t\t\t      size,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\t \n\tif (fm10k_add_rx_frag(rx_buffer, size, rx_desc, skb)) {\n\t\t \n\t\tfm10k_reuse_rx_page(rx_ring, rx_buffer);\n\t} else {\n\t\t \n\t\tdma_unmap_page(rx_ring->dev, rx_buffer->dma,\n\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t}\n\n\t \n\trx_buffer->page = NULL;\n\n\treturn skb;\n}\n\nstatic inline void fm10k_rx_checksum(struct fm10k_ring *ring,\n\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tskb_checksum_none_assert(skb);\n\n\t \n\tif (!(ring->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\t \n\tif (fm10k_test_staterr(rx_desc,\n\t\t\t       FM10K_RXD_STATUS_L4E |\n\t\t\t       FM10K_RXD_STATUS_L4E2 |\n\t\t\t       FM10K_RXD_STATUS_IPE |\n\t\t\t       FM10K_RXD_STATUS_IPE2)) {\n\t\tring->rx_stats.csum_err++;\n\t\treturn;\n\t}\n\n\t \n\tif (fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS2))\n\t\tskb->encapsulation = true;\n\telse if (!fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS))\n\t\treturn;\n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tring->rx_stats.csum_good++;\n}\n\n#define FM10K_RSS_L4_TYPES_MASK \\\n\t(BIT(FM10K_RSSTYPE_IPV4_TCP) | \\\n\t BIT(FM10K_RSSTYPE_IPV4_UDP) | \\\n\t BIT(FM10K_RSSTYPE_IPV6_TCP) | \\\n\t BIT(FM10K_RSSTYPE_IPV6_UDP))\n\nstatic inline void fm10k_rx_hash(struct fm10k_ring *ring,\n\t\t\t\t union fm10k_rx_desc *rx_desc,\n\t\t\t\t struct sk_buff *skb)\n{\n\tu16 rss_type;\n\n\tif (!(ring->netdev->features & NETIF_F_RXHASH))\n\t\treturn;\n\n\trss_type = le16_to_cpu(rx_desc->w.pkt_info) & FM10K_RXD_RSSTYPE_MASK;\n\tif (!rss_type)\n\t\treturn;\n\n\tskb_set_hash(skb, le32_to_cpu(rx_desc->d.rss),\n\t\t     (BIT(rss_type) & FM10K_RSS_L4_TYPES_MASK) ?\n\t\t     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);\n}\n\nstatic void fm10k_type_trans(struct fm10k_ring *rx_ring,\n\t\t\t     union fm10k_rx_desc __maybe_unused *rx_desc,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct net_device *dev = rx_ring->netdev;\n\tstruct fm10k_l2_accel *l2_accel = rcu_dereference_bh(rx_ring->l2_accel);\n\n\t \n\tif (l2_accel) {\n\t\tu16 idx = le16_to_cpu(FM10K_CB(skb)->fi.w.dglort) - 1;\n\n\t\tidx -= l2_accel->dglort;\n\t\tif (idx < l2_accel->size && l2_accel->macvlan[idx])\n\t\t\tdev = l2_accel->macvlan[idx];\n\t\telse\n\t\t\tl2_accel = NULL;\n\t}\n\n\t \n\tif (!l2_accel)\n\t\tskb_record_rx_queue(skb, rx_ring->queue_index);\n\telse\n\t\tmacvlan_count_rx(netdev_priv(dev), skb->len + ETH_HLEN, true,\n\t\t\t\t false);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n}\n\n \nstatic unsigned int fm10k_process_skb_fields(struct fm10k_ring *rx_ring,\n\t\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tunsigned int len = skb->len;\n\n\tfm10k_rx_hash(rx_ring, rx_desc, skb);\n\n\tfm10k_rx_checksum(rx_ring, rx_desc, skb);\n\n\tFM10K_CB(skb)->tstamp = rx_desc->q.timestamp;\n\n\tFM10K_CB(skb)->fi.w.vlan = rx_desc->w.vlan;\n\n\tFM10K_CB(skb)->fi.d.glort = rx_desc->d.glort;\n\n\tif (rx_desc->w.vlan) {\n\t\tu16 vid = le16_to_cpu(rx_desc->w.vlan);\n\n\t\tif ((vid & VLAN_VID_MASK) != rx_ring->vid)\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t\telse if (vid & VLAN_PRIO_MASK)\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       vid & VLAN_PRIO_MASK);\n\t}\n\n\tfm10k_type_trans(rx_ring, rx_desc, skb);\n\n\treturn len;\n}\n\n \nstatic bool fm10k_is_non_eop(struct fm10k_ring *rx_ring,\n\t\t\t     union fm10k_rx_desc *rx_desc)\n{\n\tu32 ntc = rx_ring->next_to_clean + 1;\n\n\t \n\tntc = (ntc < rx_ring->count) ? ntc : 0;\n\trx_ring->next_to_clean = ntc;\n\n\tprefetch(FM10K_RX_DESC(rx_ring, ntc));\n\n\tif (likely(fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_EOP)))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool fm10k_cleanup_headers(struct fm10k_ring *rx_ring,\n\t\t\t\t  union fm10k_rx_desc *rx_desc,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tif (unlikely((fm10k_test_staterr(rx_desc,\n\t\t\t\t\t FM10K_RXD_STATUS_RXE)))) {\n#define FM10K_TEST_RXD_BIT(rxd, bit) \\\n\t((rxd)->w.csum_err & cpu_to_le16(bit))\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_ERROR))\n\t\t\trx_ring->rx_stats.switch_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_NO_DESCRIPTOR))\n\t\t\trx_ring->rx_stats.drops++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_PP_ERROR))\n\t\t\trx_ring->rx_stats.pp_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_READY))\n\t\t\trx_ring->rx_stats.link_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_TOO_BIG))\n\t\t\trx_ring->rx_stats.length_errors++;\n\t\tdev_kfree_skb_any(skb);\n\t\trx_ring->rx_stats.errors++;\n\t\treturn true;\n\t}\n\n\t \n\tif (eth_skb_pad(skb))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void fm10k_receive_skb(struct fm10k_q_vector *q_vector,\n\t\t\t      struct sk_buff *skb)\n{\n\tnapi_gro_receive(&q_vector->napi, skb);\n}\n\nstatic int fm10k_clean_rx_irq(struct fm10k_q_vector *q_vector,\n\t\t\t      struct fm10k_ring *rx_ring,\n\t\t\t      int budget)\n{\n\tstruct sk_buff *skb = rx_ring->skb;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tu16 cleaned_count = fm10k_desc_unused(rx_ring);\n\n\twhile (likely(total_packets < budget)) {\n\t\tunion fm10k_rx_desc *rx_desc;\n\n\t\t \n\t\tif (cleaned_count >= FM10K_RX_BUFFER_WRITE) {\n\t\t\tfm10k_alloc_rx_buffers(rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\trx_desc = FM10K_RX_DESC(rx_ring, rx_ring->next_to_clean);\n\n\t\tif (!rx_desc->d.staterr)\n\t\t\tbreak;\n\n\t\t \n\t\tdma_rmb();\n\n\t\t \n\t\tskb = fm10k_fetch_rx_buffer(rx_ring, rx_desc, skb);\n\n\t\t \n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tcleaned_count++;\n\n\t\t \n\t\tif (fm10k_is_non_eop(rx_ring, rx_desc))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fm10k_cleanup_headers(rx_ring, rx_desc, skb)) {\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttotal_bytes += fm10k_process_skb_fields(rx_ring, rx_desc, skb);\n\n\t\tfm10k_receive_skb(q_vector, skb);\n\n\t\t \n\t\tskb = NULL;\n\n\t\t \n\t\ttotal_packets++;\n\t}\n\n\t \n\trx_ring->skb = skb;\n\n\tu64_stats_update_begin(&rx_ring->syncp);\n\trx_ring->stats.packets += total_packets;\n\trx_ring->stats.bytes += total_bytes;\n\tu64_stats_update_end(&rx_ring->syncp);\n\tq_vector->rx.total_packets += total_packets;\n\tq_vector->rx.total_bytes += total_bytes;\n\n\treturn total_packets;\n}\n\n#define VXLAN_HLEN (sizeof(struct udphdr) + 8)\nstatic struct ethhdr *fm10k_port_is_vxlan(struct sk_buff *skb)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(skb->dev);\n\n\tif (interface->vxlan_port != udp_hdr(skb)->dest)\n\t\treturn NULL;\n\n\t \n\treturn (struct ethhdr *)(skb_transport_header(skb) + VXLAN_HLEN);\n}\n\n#define FM10K_NVGRE_RESERVED0_FLAGS htons(0x9FFF)\n#define NVGRE_TNI htons(0x2000)\nstruct fm10k_nvgre_hdr {\n\t__be16 flags;\n\t__be16 proto;\n\t__be32 tni;\n};\n\nstatic struct ethhdr *fm10k_gre_is_nvgre(struct sk_buff *skb)\n{\n\tstruct fm10k_nvgre_hdr *nvgre_hdr;\n\tint hlen = ip_hdrlen(skb);\n\n\t \n\tif (vlan_get_protocol(skb) != htons(ETH_P_IP))\n\t\treturn NULL;\n\n\t \n\tnvgre_hdr = (struct fm10k_nvgre_hdr *)(skb_network_header(skb) + hlen);\n\n\t \n\tif (nvgre_hdr->flags & FM10K_NVGRE_RESERVED0_FLAGS)\n\t\treturn NULL;\n\n\t \n\tif (nvgre_hdr->flags & NVGRE_TNI)\n\t\treturn (struct ethhdr *)(nvgre_hdr + 1);\n\n\treturn (struct ethhdr *)(&nvgre_hdr->tni);\n}\n\n__be16 fm10k_tx_encap_offload(struct sk_buff *skb)\n{\n\tu8 l4_hdr = 0, inner_l4_hdr = 0, inner_l4_hlen;\n\tstruct ethhdr *eth_hdr;\n\n\tif (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||\n\t    skb->inner_protocol != htons(ETH_P_TEB))\n\t\treturn 0;\n\n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_UDP:\n\t\teth_hdr = fm10k_port_is_vxlan(skb);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\teth_hdr = fm10k_gre_is_nvgre(skb);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!eth_hdr)\n\t\treturn 0;\n\n\tswitch (eth_hdr->h_proto) {\n\tcase htons(ETH_P_IP):\n\t\tinner_l4_hdr = inner_ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tinner_l4_hdr = inner_ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (inner_l4_hdr) {\n\tcase IPPROTO_TCP:\n\t\tinner_l4_hlen = inner_tcp_hdrlen(skb);\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tinner_l4_hlen = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tif (skb_inner_transport_header(skb) + inner_l4_hlen -\n\t    skb_mac_header(skb) > FM10K_TUNNEL_HEADER_LENGTH)\n\t\treturn 0;\n\n\treturn eth_hdr->h_proto;\n}\n\nstatic int fm10k_tso(struct fm10k_ring *tx_ring,\n\t\t     struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunsigned char *th;\n\tu8 hdrlen;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\n\tif (!skb_is_gso(skb))\n\t\treturn 0;\n\n\t \n\tif (skb->encapsulation) {\n\t\tif (!fm10k_tx_encap_offload(skb))\n\t\t\tgoto err_vxlan;\n\t\tth = skb_inner_transport_header(skb);\n\t} else {\n\t\tth = skb_transport_header(skb);\n\t}\n\n\t \n\thdrlen = (th - skb->data) + (((struct tcphdr *)th)->doff << 2);\n\n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\n\t \n\tfirst->gso_segs = skb_shinfo(skb)->gso_segs;\n\tfirst->bytecount += (first->gso_segs - 1) * hdrlen;\n\n\t \n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = hdrlen;\n\ttx_desc->mss = cpu_to_le16(skb_shinfo(skb)->gso_size);\n\n\treturn 1;\n\nerr_vxlan:\n\ttx_ring->netdev->features &= ~NETIF_F_GSO_UDP_TUNNEL;\n\tif (net_ratelimit())\n\t\tnetdev_err(tx_ring->netdev,\n\t\t\t   \"TSO requested for unsupported tunnel, disabling offload\\n\");\n\treturn -1;\n}\n\nstatic void fm10k_tx_csum(struct fm10k_ring *tx_ring,\n\t\t\t  struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunion {\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t\tu8 *raw;\n\t} network_hdr;\n\tu8 *transport_hdr;\n\t__be16 frag_off;\n\t__be16 protocol;\n\tu8 l4_hdr = 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tgoto no_csum;\n\n\tif (skb->encapsulation) {\n\t\tprotocol = fm10k_tx_encap_offload(skb);\n\t\tif (!protocol) {\n\t\t\tif (skb_checksum_help(skb)) {\n\t\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t\t \"failed to offload encap csum!\\n\");\n\t\t\t\ttx_ring->tx_stats.csum_err++;\n\t\t\t}\n\t\t\tgoto no_csum;\n\t\t}\n\t\tnetwork_hdr.raw = skb_inner_network_header(skb);\n\t\ttransport_hdr = skb_inner_transport_header(skb);\n\t} else {\n\t\tprotocol = vlan_get_protocol(skb);\n\t\tnetwork_hdr.raw = skb_network_header(skb);\n\t\ttransport_hdr = skb_transport_header(skb);\n\t}\n\n\tswitch (protocol) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = network_hdr.ipv4->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = network_hdr.ipv6->nexthdr;\n\t\tif (likely((transport_hdr - network_hdr.raw) ==\n\t\t\t   sizeof(struct ipv6hdr)))\n\t\t\tbreak;\n\t\tipv6_skip_exthdr(skb, network_hdr.raw - skb->data +\n\t\t\t\t      sizeof(struct ipv6hdr),\n\t\t\t\t &l4_hdr, &frag_off);\n\t\tif (unlikely(frag_off))\n\t\t\tl4_hdr = NEXTHDR_FRAGMENT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tif (skb->encapsulation)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tif (unlikely(net_ratelimit())) {\n\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t \"partial checksum, version=%d l4 proto=%x\\n\",\n\t\t\t\t protocol, l4_hdr);\n\t\t}\n\t\tskb_checksum_help(skb);\n\t\ttx_ring->tx_stats.csum_err++;\n\t\tgoto no_csum;\n\t}\n\n\t \n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\ttx_ring->tx_stats.csum_good++;\n\nno_csum:\n\t \n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = 0;\n\ttx_desc->mss = 0;\n}\n\n#define FM10K_SET_FLAG(_input, _flag, _result) \\\n\t((_flag <= _result) ? \\\n\t ((u32)(_input & _flag) * (_result / _flag)) : \\\n\t ((u32)(_input & _flag) / (_flag / _result)))\n\nstatic u8 fm10k_tx_desc_flags(struct sk_buff *skb, u32 tx_flags)\n{\n\t \n\tu32 desc_flags = 0;\n\n\t \n\tdesc_flags |= FM10K_SET_FLAG(tx_flags, FM10K_TX_FLAGS_CSUM,\n\t\t\t\t     FM10K_TXD_FLAG_CSUM);\n\n\treturn desc_flags;\n}\n\nstatic bool fm10k_tx_desc_push(struct fm10k_ring *tx_ring,\n\t\t\t       struct fm10k_tx_desc *tx_desc, u16 i,\n\t\t\t       dma_addr_t dma, unsigned int size, u8 desc_flags)\n{\n\t \n\tif ((++i & (FM10K_TXD_WB_FIFO_SIZE - 1)) == 0)\n\t\tdesc_flags |= FM10K_TXD_FLAG_RS | FM10K_TXD_FLAG_INT;\n\n\t \n\ttx_desc->buffer_addr = cpu_to_le64(dma);\n\ttx_desc->flags = desc_flags;\n\ttx_desc->buflen = cpu_to_le16(size);\n\n\t \n\treturn i == tx_ring->count;\n}\n\nstatic int __fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\n{\n\tnetif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);\n\n\t \n\tsmp_mb();\n\n\t \n\tif (likely(fm10k_desc_unused(tx_ring) < size))\n\t\treturn -EBUSY;\n\n\t \n\tnetif_start_subqueue(tx_ring->netdev, tx_ring->queue_index);\n\t++tx_ring->tx_stats.restart_queue;\n\treturn 0;\n}\n\nstatic inline int fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\n{\n\tif (likely(fm10k_desc_unused(tx_ring) >= size))\n\t\treturn 0;\n\treturn __fm10k_maybe_stop_tx(tx_ring, size);\n}\n\nstatic void fm10k_tx_map(struct fm10k_ring *tx_ring,\n\t\t\t struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tskb_frag_t *frag;\n\tunsigned char *data;\n\tdma_addr_t dma;\n\tunsigned int data_len, size;\n\tu32 tx_flags = first->tx_flags;\n\tu16 i = tx_ring->next_to_use;\n\tu8 flags = fm10k_tx_desc_flags(skb, tx_flags);\n\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\n\t \n\tif (skb_vlan_tag_present(skb))\n\t\ttx_desc->vlan = cpu_to_le16(skb_vlan_tag_get(skb));\n\telse\n\t\ttx_desc->vlan = 0;\n\n\tsize = skb_headlen(skb);\n\tdata = skb->data;\n\n\tdma = dma_map_single(tx_ring->dev, data, size, DMA_TO_DEVICE);\n\n\tdata_len = skb->data_len;\n\ttx_buffer = first;\n\n\tfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\n\t\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\t\tgoto dma_error;\n\n\t\t \n\t\tdma_unmap_len_set(tx_buffer, len, size);\n\t\tdma_unmap_addr_set(tx_buffer, dma, dma);\n\n\t\twhile (unlikely(size > FM10K_MAX_DATA_PER_TXD)) {\n\t\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++, dma,\n\t\t\t\t\t       FM10K_MAX_DATA_PER_TXD, flags)) {\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tdma += FM10K_MAX_DATA_PER_TXD;\n\t\t\tsize -= FM10K_MAX_DATA_PER_TXD;\n\t\t}\n\n\t\tif (likely(!data_len))\n\t\t\tbreak;\n\n\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++,\n\t\t\t\t       dma, size, flags)) {\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\ti = 0;\n\t\t}\n\n\t\tsize = skb_frag_size(frag);\n\t\tdata_len -= size;\n\n\t\tdma = skb_frag_dma_map(tx_ring->dev, frag, 0, size,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t}\n\n\t \n\tflags |= FM10K_TXD_FLAG_LAST;\n\n\tif (fm10k_tx_desc_push(tx_ring, tx_desc, i++, dma, size, flags))\n\t\ti = 0;\n\n\t \n\tnetdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);\n\n\t \n\tskb_tx_timestamp(first->skb);\n\n\t \n\twmb();\n\n\t \n\tfirst->next_to_watch = tx_desc;\n\n\ttx_ring->next_to_use = i;\n\n\t \n\tfm10k_maybe_stop_tx(tx_ring, DESC_NEEDED);\n\n\t \n\tif (netif_xmit_stopped(txring_txq(tx_ring)) || !netdev_xmit_more()) {\n\t\twritel(i, tx_ring->tail);\n\t}\n\n\treturn;\ndma_error:\n\tdev_err(tx_ring->dev, \"TX DMA map failed\\n\");\n\n\t \n\tfor (;;) {\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t\tfm10k_unmap_and_free_tx_resource(tx_ring, tx_buffer);\n\t\tif (tx_buffer == first)\n\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\ti = tx_ring->count;\n\t\ti--;\n\t}\n\n\ttx_ring->next_to_use = i;\n}\n\nnetdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb,\n\t\t\t\t  struct fm10k_ring *tx_ring)\n{\n\tu16 count = TXD_USE_COUNT(skb_headlen(skb));\n\tstruct fm10k_tx_buffer *first;\n\tunsigned short f;\n\tu32 tx_flags = 0;\n\tint tso;\n\n\t \n\tfor (f = 0; f < skb_shinfo(skb)->nr_frags; f++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[f];\n\n\t\tcount += TXD_USE_COUNT(skb_frag_size(frag));\n\t}\n\n\tif (fm10k_maybe_stop_tx(tx_ring, count + 3)) {\n\t\ttx_ring->tx_stats.tx_busy++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tfirst = &tx_ring->tx_buffer[tx_ring->next_to_use];\n\tfirst->skb = skb;\n\tfirst->bytecount = max_t(unsigned int, skb->len, ETH_ZLEN);\n\tfirst->gso_segs = 1;\n\n\t \n\tfirst->tx_flags = tx_flags;\n\n\ttso = fm10k_tso(tx_ring, first);\n\tif (tso < 0)\n\t\tgoto out_drop;\n\telse if (!tso)\n\t\tfm10k_tx_csum(tx_ring, first);\n\n\tfm10k_tx_map(tx_ring, first);\n\n\treturn NETDEV_TX_OK;\n\nout_drop:\n\tdev_kfree_skb_any(first->skb);\n\tfirst->skb = NULL;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic u64 fm10k_get_tx_completed(struct fm10k_ring *ring)\n{\n\treturn ring->stats.packets;\n}\n\n \nu64 fm10k_get_tx_pending(struct fm10k_ring *ring, bool in_sw)\n{\n\tstruct fm10k_intfc *interface = ring->q_vector->interface;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu32 head, tail;\n\n\tif (likely(in_sw)) {\n\t\thead = ring->next_to_clean;\n\t\ttail = ring->next_to_use;\n\t} else {\n\t\thead = fm10k_read_reg(hw, FM10K_TDH(ring->reg_idx));\n\t\ttail = fm10k_read_reg(hw, FM10K_TDT(ring->reg_idx));\n\t}\n\n\treturn ((head <= tail) ? tail : tail + ring->count) - head;\n}\n\nbool fm10k_check_tx_hang(struct fm10k_ring *tx_ring)\n{\n\tu32 tx_done = fm10k_get_tx_completed(tx_ring);\n\tu32 tx_done_old = tx_ring->tx_stats.tx_done_old;\n\tu32 tx_pending = fm10k_get_tx_pending(tx_ring, true);\n\n\tclear_check_for_tx_hang(tx_ring);\n\n\t \n\tif (!tx_pending || (tx_done_old != tx_done)) {\n\t\t \n\t\ttx_ring->tx_stats.tx_done_old = tx_done;\n\t\t \n\t\tclear_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\n\n\t\treturn false;\n\t}\n\n\t \n\treturn test_and_set_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\n}\n\n \nvoid fm10k_tx_timeout_reset(struct fm10k_intfc *interface)\n{\n\t \n\tif (!test_bit(__FM10K_DOWN, interface->state)) {\n\t\tinterface->tx_timeout_count++;\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\t\tfm10k_service_event_schedule(interface);\n\t}\n}\n\n \nstatic bool fm10k_clean_tx_irq(struct fm10k_q_vector *q_vector,\n\t\t\t       struct fm10k_ring *tx_ring, int napi_budget)\n{\n\tstruct fm10k_intfc *interface = q_vector->interface;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tunsigned int budget = q_vector->tx.work_limit;\n\tunsigned int i = tx_ring->next_to_clean;\n\n\tif (test_bit(__FM10K_DOWN, interface->state))\n\t\treturn true;\n\n\ttx_buffer = &tx_ring->tx_buffer[i];\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\ti -= tx_ring->count;\n\n\tdo {\n\t\tstruct fm10k_tx_desc *eop_desc = tx_buffer->next_to_watch;\n\n\t\t \n\t\tif (!eop_desc)\n\t\t\tbreak;\n\n\t\t \n\t\tsmp_rmb();\n\n\t\t \n\t\tif (!(eop_desc->flags & FM10K_TXD_FLAG_DONE))\n\t\t\tbreak;\n\n\t\t \n\t\ttx_buffer->next_to_watch = NULL;\n\n\t\t \n\t\ttotal_bytes += tx_buffer->bytecount;\n\t\ttotal_packets += tx_buffer->gso_segs;\n\n\t\t \n\t\tnapi_consume_skb(tx_buffer->skb, napi_budget);\n\n\t\t \n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t \n\t\ttx_buffer->skb = NULL;\n\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\n\t\t \n\t\twhile (tx_desc != eop_desc) {\n\t\t\ttx_buffer++;\n\t\t\ttx_desc++;\n\t\t\ti++;\n\t\t\tif (unlikely(!i)) {\n\t\t\t\ti -= tx_ring->count;\n\t\t\t\ttx_buffer = tx_ring->tx_buffer;\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dma_unmap_len(tx_buffer, len)) {\n\t\t\t\tdma_unmap_page(tx_ring->dev,\n\t\t\t\t\t       dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t\t       dma_unmap_len(tx_buffer, len),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttx_buffer++;\n\t\ttx_desc++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\ti -= tx_ring->count;\n\t\t\ttx_buffer = tx_ring->tx_buffer;\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t}\n\n\t\t \n\t\tprefetch(tx_desc);\n\n\t\t \n\t\tbudget--;\n\t} while (likely(budget));\n\n\ti += tx_ring->count;\n\ttx_ring->next_to_clean = i;\n\tu64_stats_update_begin(&tx_ring->syncp);\n\ttx_ring->stats.bytes += total_bytes;\n\ttx_ring->stats.packets += total_packets;\n\tu64_stats_update_end(&tx_ring->syncp);\n\tq_vector->tx.total_bytes += total_bytes;\n\tq_vector->tx.total_packets += total_packets;\n\n\tif (check_for_tx_hang(tx_ring) && fm10k_check_tx_hang(tx_ring)) {\n\t\t \n\t\tstruct fm10k_hw *hw = &interface->hw;\n\n\t\tnetif_err(interface, drv, tx_ring->netdev,\n\t\t\t  \"Detected Tx Unit Hang\\n\"\n\t\t\t  \"  Tx Queue             <%d>\\n\"\n\t\t\t  \"  TDH, TDT             <%x>, <%x>\\n\"\n\t\t\t  \"  next_to_use          <%x>\\n\"\n\t\t\t  \"  next_to_clean        <%x>\\n\",\n\t\t\t  tx_ring->queue_index,\n\t\t\t  fm10k_read_reg(hw, FM10K_TDH(tx_ring->reg_idx)),\n\t\t\t  fm10k_read_reg(hw, FM10K_TDT(tx_ring->reg_idx)),\n\t\t\t  tx_ring->next_to_use, i);\n\n\t\tnetif_stop_subqueue(tx_ring->netdev,\n\t\t\t\t    tx_ring->queue_index);\n\n\t\tnetif_info(interface, probe, tx_ring->netdev,\n\t\t\t   \"tx hang %d detected on queue %d, resetting interface\\n\",\n\t\t\t   interface->tx_timeout_count + 1,\n\t\t\t   tx_ring->queue_index);\n\n\t\tfm10k_tx_timeout_reset(interface);\n\n\t\t \n\t\treturn true;\n\t}\n\n\t \n\tnetdev_tx_completed_queue(txring_txq(tx_ring),\n\t\t\t\t  total_packets, total_bytes);\n\n#define TX_WAKE_THRESHOLD min_t(u16, FM10K_MIN_TXD - 1, DESC_NEEDED * 2)\n\tif (unlikely(total_packets && netif_carrier_ok(tx_ring->netdev) &&\n\t\t     (fm10k_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD))) {\n\t\t \n\t\tsmp_mb();\n\t\tif (__netif_subqueue_stopped(tx_ring->netdev,\n\t\t\t\t\t     tx_ring->queue_index) &&\n\t\t    !test_bit(__FM10K_DOWN, interface->state)) {\n\t\t\tnetif_wake_subqueue(tx_ring->netdev,\n\t\t\t\t\t    tx_ring->queue_index);\n\t\t\t++tx_ring->tx_stats.restart_queue;\n\t\t}\n\t}\n\n\treturn !!budget;\n}\n\n \nstatic void fm10k_update_itr(struct fm10k_ring_container *ring_container)\n{\n\tunsigned int avg_wire_size, packets, itr_round;\n\n\t \n\tif (!ITR_IS_ADAPTIVE(ring_container->itr))\n\t\tgoto clear_counts;\n\n\tpackets = ring_container->total_packets;\n\tif (!packets)\n\t\tgoto clear_counts;\n\n\tavg_wire_size = ring_container->total_bytes / packets;\n\n\t \n\tif (avg_wire_size <= 360) {\n\t\t \n\t\tavg_wire_size *= 8;\n\t\tavg_wire_size += 376;\n\t} else if (avg_wire_size <= 1152) {\n\t\t \n\t\tavg_wire_size *= 3;\n\t\tavg_wire_size += 2176;\n\t} else if (avg_wire_size <= 1920) {\n\t\t \n\t\tavg_wire_size += 4480;\n\t} else {\n\t\t \n\t\tavg_wire_size = 6656;\n\t}\n\n\t \n\titr_round = READ_ONCE(ring_container->itr_scale) + 8;\n\tavg_wire_size += BIT(itr_round) - 1;\n\tavg_wire_size >>= itr_round;\n\n\t \n\tring_container->itr = avg_wire_size | FM10K_ITR_ADAPTIVE;\n\nclear_counts:\n\tring_container->total_bytes = 0;\n\tring_container->total_packets = 0;\n}\n\nstatic void fm10k_qv_enable(struct fm10k_q_vector *q_vector)\n{\n\t \n\tu32 itr = FM10K_ITR_ENABLE;\n\n\t \n\tfm10k_update_itr(&q_vector->tx);\n\n\t \n\tfm10k_update_itr(&q_vector->rx);\n\n\t \n\titr |= (q_vector->tx.itr & FM10K_ITR_MAX);\n\n\t \n\titr |= (q_vector->rx.itr & FM10K_ITR_MAX) << FM10K_ITR_INTERVAL1_SHIFT;\n\n\t \n\twritel(itr, q_vector->itr);\n}\n\nstatic int fm10k_poll(struct napi_struct *napi, int budget)\n{\n\tstruct fm10k_q_vector *q_vector =\n\t\t\t       container_of(napi, struct fm10k_q_vector, napi);\n\tstruct fm10k_ring *ring;\n\tint per_ring_budget, work_done = 0;\n\tbool clean_complete = true;\n\n\tfm10k_for_each_ring(ring, q_vector->tx) {\n\t\tif (!fm10k_clean_tx_irq(q_vector, ring, budget))\n\t\t\tclean_complete = false;\n\t}\n\n\t \n\tif (budget <= 0)\n\t\treturn budget;\n\n\t \n\tif (q_vector->rx.count > 1)\n\t\tper_ring_budget = max(budget / q_vector->rx.count, 1);\n\telse\n\t\tper_ring_budget = budget;\n\n\tfm10k_for_each_ring(ring, q_vector->rx) {\n\t\tint work = fm10k_clean_rx_irq(q_vector, ring, per_ring_budget);\n\n\t\twork_done += work;\n\t\tif (work >= per_ring_budget)\n\t\t\tclean_complete = false;\n\t}\n\n\t \n\tif (!clean_complete)\n\t\treturn budget;\n\n\t \n\tif (likely(napi_complete_done(napi, work_done)))\n\t\tfm10k_qv_enable(q_vector);\n\n\treturn min(work_done, budget - 1);\n}\n\n \nstatic bool fm10k_set_qos_queues(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tstruct fm10k_ring_feature *f;\n\tint rss_i, i;\n\tint pcs;\n\n\t \n\tpcs = netdev_get_num_tc(dev);\n\n\tif (pcs <= 1)\n\t\treturn false;\n\n\t \n\tf = &interface->ring_feature[RING_F_QOS];\n\tf->indices = pcs;\n\tf->mask = BIT(fls(pcs - 1)) - 1;\n\n\t \n\trss_i = interface->hw.mac.max_queues / pcs;\n\trss_i = BIT(fls(rss_i) - 1);\n\n\t \n\tf = &interface->ring_feature[RING_F_RSS];\n\trss_i = min_t(u16, rss_i, f->limit);\n\tf->indices = rss_i;\n\tf->mask = BIT(fls(rss_i - 1)) - 1;\n\n\t \n\tfor (i = 0; i < pcs; i++)\n\t\tnetdev_set_tc_queue(dev, i, rss_i, rss_i * i);\n\n\tinterface->num_rx_queues = rss_i * pcs;\n\tinterface->num_tx_queues = rss_i * pcs;\n\n\treturn true;\n}\n\n \nstatic bool fm10k_set_rss_queues(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_ring_feature *f;\n\tu16 rss_i;\n\n\tf = &interface->ring_feature[RING_F_RSS];\n\trss_i = min_t(u16, interface->hw.mac.max_queues, f->limit);\n\n\t \n\tf->indices = rss_i;\n\tf->mask = BIT(fls(rss_i - 1)) - 1;\n\n\tinterface->num_rx_queues = rss_i;\n\tinterface->num_tx_queues = rss_i;\n\n\treturn true;\n}\n\n \nstatic void fm10k_set_num_queues(struct fm10k_intfc *interface)\n{\n\t \n\tif (fm10k_set_qos_queues(interface))\n\t\treturn;\n\n\t \n\tfm10k_set_rss_queues(interface);\n}\n\n \nstatic void fm10k_reset_num_queues(struct fm10k_intfc *interface)\n{\n\tinterface->num_tx_queues = 0;\n\tinterface->num_rx_queues = 0;\n\tinterface->num_q_vectors = 0;\n}\n\n \nstatic int fm10k_alloc_q_vector(struct fm10k_intfc *interface,\n\t\t\t\tunsigned int v_count, unsigned int v_idx,\n\t\t\t\tunsigned int txr_count, unsigned int txr_idx,\n\t\t\t\tunsigned int rxr_count, unsigned int rxr_idx)\n{\n\tstruct fm10k_q_vector *q_vector;\n\tstruct fm10k_ring *ring;\n\tint ring_count;\n\n\tring_count = txr_count + rxr_count;\n\n\t \n\tq_vector = kzalloc(struct_size(q_vector, ring, ring_count), GFP_KERNEL);\n\tif (!q_vector)\n\t\treturn -ENOMEM;\n\n\t \n\tnetif_napi_add(interface->netdev, &q_vector->napi, fm10k_poll);\n\n\t \n\tinterface->q_vector[v_idx] = q_vector;\n\tq_vector->interface = interface;\n\tq_vector->v_idx = v_idx;\n\n\t \n\tring = q_vector->ring;\n\n\t \n\tq_vector->tx.ring = ring;\n\tq_vector->tx.work_limit = FM10K_DEFAULT_TX_WORK;\n\tq_vector->tx.itr = interface->tx_itr;\n\tq_vector->tx.itr_scale = interface->hw.mac.itr_scale;\n\tq_vector->tx.count = txr_count;\n\n\twhile (txr_count) {\n\t\t \n\t\tring->dev = &interface->pdev->dev;\n\t\tring->netdev = interface->netdev;\n\n\t\t \n\t\tring->q_vector = q_vector;\n\n\t\t \n\t\tring->count = interface->tx_ring_count;\n\t\tring->queue_index = txr_idx;\n\n\t\t \n\t\tinterface->tx_ring[txr_idx] = ring;\n\n\t\t \n\t\ttxr_count--;\n\t\ttxr_idx += v_count;\n\n\t\t \n\t\tring++;\n\t}\n\n\t \n\tq_vector->rx.ring = ring;\n\tq_vector->rx.itr = interface->rx_itr;\n\tq_vector->rx.itr_scale = interface->hw.mac.itr_scale;\n\tq_vector->rx.count = rxr_count;\n\n\twhile (rxr_count) {\n\t\t \n\t\tring->dev = &interface->pdev->dev;\n\t\tring->netdev = interface->netdev;\n\t\trcu_assign_pointer(ring->l2_accel, interface->l2_accel);\n\n\t\t \n\t\tring->q_vector = q_vector;\n\n\t\t \n\t\tring->count = interface->rx_ring_count;\n\t\tring->queue_index = rxr_idx;\n\n\t\t \n\t\tinterface->rx_ring[rxr_idx] = ring;\n\n\t\t \n\t\trxr_count--;\n\t\trxr_idx += v_count;\n\n\t\t \n\t\tring++;\n\t}\n\n\tfm10k_dbg_q_vector_init(q_vector);\n\n\treturn 0;\n}\n\n \nstatic void fm10k_free_q_vector(struct fm10k_intfc *interface, int v_idx)\n{\n\tstruct fm10k_q_vector *q_vector = interface->q_vector[v_idx];\n\tstruct fm10k_ring *ring;\n\n\tfm10k_dbg_q_vector_exit(q_vector);\n\n\tfm10k_for_each_ring(ring, q_vector->tx)\n\t\tinterface->tx_ring[ring->queue_index] = NULL;\n\n\tfm10k_for_each_ring(ring, q_vector->rx)\n\t\tinterface->rx_ring[ring->queue_index] = NULL;\n\n\tinterface->q_vector[v_idx] = NULL;\n\tnetif_napi_del(&q_vector->napi);\n\tkfree_rcu(q_vector, rcu);\n}\n\n \nstatic int fm10k_alloc_q_vectors(struct fm10k_intfc *interface)\n{\n\tunsigned int q_vectors = interface->num_q_vectors;\n\tunsigned int rxr_remaining = interface->num_rx_queues;\n\tunsigned int txr_remaining = interface->num_tx_queues;\n\tunsigned int rxr_idx = 0, txr_idx = 0, v_idx = 0;\n\tint err;\n\n\tif (q_vectors >= (rxr_remaining + txr_remaining)) {\n\t\tfor (; rxr_remaining; v_idx++) {\n\t\t\terr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\n\t\t\t\t\t\t   0, 0, 1, rxr_idx);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\t \n\t\t\trxr_remaining--;\n\t\t\trxr_idx++;\n\t\t}\n\t}\n\n\tfor (; v_idx < q_vectors; v_idx++) {\n\t\tint rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_idx);\n\t\tint tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_idx);\n\n\t\terr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\n\t\t\t\t\t   tqpv, txr_idx,\n\t\t\t\t\t   rqpv, rxr_idx);\n\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\t \n\t\trxr_remaining -= rqpv;\n\t\ttxr_remaining -= tqpv;\n\t\trxr_idx++;\n\t\ttxr_idx++;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tfm10k_reset_num_queues(interface);\n\n\twhile (v_idx--)\n\t\tfm10k_free_q_vector(interface, v_idx);\n\n\treturn -ENOMEM;\n}\n\n \nstatic void fm10k_free_q_vectors(struct fm10k_intfc *interface)\n{\n\tint v_idx = interface->num_q_vectors;\n\n\tfm10k_reset_num_queues(interface);\n\n\twhile (v_idx--)\n\t\tfm10k_free_q_vector(interface, v_idx);\n}\n\n \nstatic void fm10k_reset_msix_capability(struct fm10k_intfc *interface)\n{\n\tpci_disable_msix(interface->pdev);\n\tkfree(interface->msix_entries);\n\tinterface->msix_entries = NULL;\n}\n\n \nstatic int fm10k_init_msix_capability(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint v_budget, vector;\n\n\t \n\tv_budget = max(interface->num_rx_queues, interface->num_tx_queues);\n\tv_budget = min_t(u16, v_budget, num_online_cpus());\n\n\t \n\tv_budget += NON_Q_VECTORS;\n\n\t \n\tv_budget = min_t(int, v_budget, hw->mac.max_msix_vectors);\n\n\t \n\tinterface->msix_entries = kcalloc(v_budget, sizeof(struct msix_entry),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!interface->msix_entries)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (vector = 0; vector < v_budget; vector++)\n\t\tinterface->msix_entries[vector].entry = vector;\n\n\t \n\tv_budget = pci_enable_msix_range(interface->pdev,\n\t\t\t\t\t interface->msix_entries,\n\t\t\t\t\t MIN_MSIX_COUNT(hw),\n\t\t\t\t\t v_budget);\n\tif (v_budget < 0) {\n\t\tkfree(interface->msix_entries);\n\t\tinterface->msix_entries = NULL;\n\t\treturn v_budget;\n\t}\n\n\t \n\tinterface->num_q_vectors = v_budget - NON_Q_VECTORS;\n\n\treturn 0;\n}\n\n \nstatic bool fm10k_cache_ring_qos(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tint pc, offset, rss_i, i;\n\tu16 pc_stride = interface->ring_feature[RING_F_QOS].mask + 1;\n\tu8 num_pcs = netdev_get_num_tc(dev);\n\n\tif (num_pcs <= 1)\n\t\treturn false;\n\n\trss_i = interface->ring_feature[RING_F_RSS].indices;\n\n\tfor (pc = 0, offset = 0; pc < num_pcs; pc++, offset += rss_i) {\n\t\tint q_idx = pc;\n\n\t\tfor (i = 0; i < rss_i; i++) {\n\t\t\tinterface->tx_ring[offset + i]->reg_idx = q_idx;\n\t\t\tinterface->tx_ring[offset + i]->qos_pc = pc;\n\t\t\tinterface->rx_ring[offset + i]->reg_idx = q_idx;\n\t\t\tinterface->rx_ring[offset + i]->qos_pc = pc;\n\t\t\tq_idx += pc_stride;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic void fm10k_cache_ring_rss(struct fm10k_intfc *interface)\n{\n\tint i;\n\n\tfor (i = 0; i < interface->num_rx_queues; i++)\n\t\tinterface->rx_ring[i]->reg_idx = i;\n\n\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\tinterface->tx_ring[i]->reg_idx = i;\n}\n\n \nstatic void fm10k_assign_rings(struct fm10k_intfc *interface)\n{\n\tif (fm10k_cache_ring_qos(interface))\n\t\treturn;\n\n\tfm10k_cache_ring_rss(interface);\n}\n\nstatic void fm10k_init_reta(struct fm10k_intfc *interface)\n{\n\tu16 i, rss_i = interface->ring_feature[RING_F_RSS].indices;\n\tu32 reta;\n\n\t \n\tif (netif_is_rxfh_configured(interface->netdev)) {\n\t\tfor (i = FM10K_RETA_SIZE; i--;) {\n\t\t\treta = interface->reta[i];\n\t\t\tif ((((reta << 24) >> 24) < rss_i) &&\n\t\t\t    (((reta << 16) >> 24) < rss_i) &&\n\t\t\t    (((reta <<  8) >> 24) < rss_i) &&\n\t\t\t    (((reta)       >> 24) < rss_i))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdev_err(&interface->pdev->dev,\n\t\t\t\t\"RSS indirection table assigned flows out of queue bounds. Reconfiguring.\\n\");\n\t\t\tgoto repopulate_reta;\n\t\t}\n\n\t\t \n\t\treturn;\n\t}\n\nrepopulate_reta:\n\tfm10k_write_reta(interface, NULL);\n}\n\n \nint fm10k_init_queueing_scheme(struct fm10k_intfc *interface)\n{\n\tint err;\n\n\t \n\tfm10k_set_num_queues(interface);\n\n\t \n\terr = fm10k_init_msix_capability(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to initialize MSI-X capability\\n\");\n\t\tgoto err_init_msix;\n\t}\n\n\t \n\terr = fm10k_alloc_q_vectors(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to allocate queue vectors\\n\");\n\t\tgoto err_alloc_q_vectors;\n\t}\n\n\t \n\tfm10k_assign_rings(interface);\n\n\t \n\tfm10k_init_reta(interface);\n\n\treturn 0;\n\nerr_alloc_q_vectors:\n\tfm10k_reset_msix_capability(interface);\nerr_init_msix:\n\tfm10k_reset_num_queues(interface);\n\treturn err;\n}\n\n \nvoid fm10k_clear_queueing_scheme(struct fm10k_intfc *interface)\n{\n\tfm10k_free_q_vectors(interface);\n\tfm10k_reset_msix_capability(interface);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}