{
  "module_name": "fm10k_debugfs.c",
  "hash_id": "431dc29f8895f4e89dfea256a4c173fe1affbb6c29efdf2ac6e55fde275d220d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c",
  "human_readable_source": "\n \n\n#include \"fm10k.h\"\n\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\nstatic struct dentry *dbg_root;\n\n \n\nstatic void *fm10k_dbg_desc_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct fm10k_ring *ring = s->private;\n\n\treturn (*pos < ring->count) ? pos : NULL;\n}\n\nstatic void *fm10k_dbg_desc_seq_next(struct seq_file *s,\n\t\t\t\t     void __always_unused *v,\n\t\t\t\t     loff_t *pos)\n{\n\tstruct fm10k_ring *ring = s->private;\n\n\treturn (++(*pos) < ring->count) ? pos : NULL;\n}\n\nstatic void fm10k_dbg_desc_seq_stop(struct seq_file __always_unused *s,\n\t\t\t\t    void __always_unused *v)\n{\n\t \n}\n\nstatic void fm10k_dbg_desc_break(struct seq_file *s, int i)\n{\n\twhile (i--)\n\t\tseq_putc(s, '-');\n\n\tseq_putc(s, '\\n');\n}\n\nstatic int fm10k_dbg_tx_desc_seq_show(struct seq_file *s, void *v)\n{\n\tstruct fm10k_ring *ring = s->private;\n\tint i = *(loff_t *)v;\n\tstatic const char tx_desc_hdr[] =\n\t\t\"DES BUFFER_ADDRESS     LENGTH VLAN   MSS    HDRLEN FLAGS\\n\";\n\n\t \n\tif (!i) {\n\t\tseq_printf(s, tx_desc_hdr);\n\t\tfm10k_dbg_desc_break(s, sizeof(tx_desc_hdr) - 1);\n\t}\n\n\t \n\tif (!ring->desc) {\n\t\tseq_printf(s, \"%03X Descriptor ring not allocated.\\n\", i);\n\t} else {\n\t\tstruct fm10k_tx_desc *txd = FM10K_TX_DESC(ring, i);\n\n\t\tseq_printf(s, \"%03X %#018llx %#06x %#06x %#06x %#06x %#04x\\n\",\n\t\t\t   i, txd->buffer_addr, txd->buflen, txd->vlan,\n\t\t\t   txd->mss, txd->hdrlen, txd->flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int fm10k_dbg_rx_desc_seq_show(struct seq_file *s, void *v)\n{\n\tstruct fm10k_ring *ring = s->private;\n\tint i = *(loff_t *)v;\n\tstatic const char rx_desc_hdr[] =\n\t\"DES DATA       RSS        STATERR    LENGTH VLAN   DGLORT SGLORT TIMESTAMP\\n\";\n\n\t \n\tif (!i) {\n\t\tseq_printf(s, rx_desc_hdr);\n\t\tfm10k_dbg_desc_break(s, sizeof(rx_desc_hdr) - 1);\n\t}\n\n\t \n\tif (!ring->desc) {\n\t\tseq_printf(s, \"%03X Descriptor ring not allocated.\\n\", i);\n\t} else {\n\t\tunion fm10k_rx_desc *rxd = FM10K_RX_DESC(ring, i);\n\n\t\tseq_printf(s,\n\t\t\t   \"%03X %#010x %#010x %#010x %#06x %#06x %#06x %#06x %#018llx\\n\",\n\t\t\t   i, rxd->d.data, rxd->d.rss, rxd->d.staterr,\n\t\t\t   rxd->w.length, rxd->w.vlan, rxd->w.dglort,\n\t\t\t   rxd->w.sglort, rxd->q.timestamp);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations fm10k_dbg_tx_desc_seq_ops = {\n\t.start = fm10k_dbg_desc_seq_start,\n\t.next  = fm10k_dbg_desc_seq_next,\n\t.stop  = fm10k_dbg_desc_seq_stop,\n\t.show  = fm10k_dbg_tx_desc_seq_show,\n};\n\nstatic const struct seq_operations fm10k_dbg_rx_desc_seq_ops = {\n\t.start = fm10k_dbg_desc_seq_start,\n\t.next  = fm10k_dbg_desc_seq_next,\n\t.stop  = fm10k_dbg_desc_seq_stop,\n\t.show  = fm10k_dbg_rx_desc_seq_show,\n};\n\nstatic int fm10k_dbg_desc_open(struct inode *inode, struct file *filep)\n{\n\tstruct fm10k_ring *ring = inode->i_private;\n\tstruct fm10k_q_vector *q_vector = ring->q_vector;\n\tconst struct seq_operations *desc_seq_ops;\n\tint err;\n\n\tif (ring < q_vector->rx.ring)\n\t\tdesc_seq_ops = &fm10k_dbg_tx_desc_seq_ops;\n\telse\n\t\tdesc_seq_ops = &fm10k_dbg_rx_desc_seq_ops;\n\n\terr = seq_open(filep, desc_seq_ops);\n\tif (err)\n\t\treturn err;\n\n\t((struct seq_file *)filep->private_data)->private = ring;\n\n\treturn 0;\n}\n\nstatic const struct file_operations fm10k_dbg_desc_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = fm10k_dbg_desc_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n\n \nvoid fm10k_dbg_q_vector_init(struct fm10k_q_vector *q_vector)\n{\n\tstruct fm10k_intfc *interface = q_vector->interface;\n\tchar name[16];\n\tint i;\n\n\tif (!interface->dbg_intfc)\n\t\treturn;\n\n\t \n\tsnprintf(name, sizeof(name), \"q_vector.%03d\", q_vector->v_idx);\n\n\tq_vector->dbg_q_vector = debugfs_create_dir(name, interface->dbg_intfc);\n\n\t \n\tfor (i = 0; i < q_vector->tx.count; i++) {\n\t\tstruct fm10k_ring *ring = &q_vector->tx.ring[i];\n\n\t\tsnprintf(name, sizeof(name), \"tx_ring.%03d\", ring->queue_index);\n\n\t\tdebugfs_create_file(name, 0600,\n\t\t\t\t    q_vector->dbg_q_vector, ring,\n\t\t\t\t    &fm10k_dbg_desc_fops);\n\t}\n\n\t \n\tfor (i = 0; i < q_vector->rx.count; i++) {\n\t\tstruct fm10k_ring *ring = &q_vector->rx.ring[i];\n\n\t\tsnprintf(name, sizeof(name), \"rx_ring.%03d\", ring->queue_index);\n\n\t\tdebugfs_create_file(name, 0600,\n\t\t\t\t    q_vector->dbg_q_vector, ring,\n\t\t\t\t    &fm10k_dbg_desc_fops);\n\t}\n}\n\n \nvoid fm10k_dbg_q_vector_exit(struct fm10k_q_vector *q_vector)\n{\n\tstruct fm10k_intfc *interface = q_vector->interface;\n\n\tif (interface->dbg_intfc)\n\t\tdebugfs_remove_recursive(q_vector->dbg_q_vector);\n\tq_vector->dbg_q_vector = NULL;\n}\n\n \n\nvoid fm10k_dbg_intfc_init(struct fm10k_intfc *interface)\n{\n\tconst char *name = pci_name(interface->pdev);\n\n\tif (dbg_root)\n\t\tinterface->dbg_intfc = debugfs_create_dir(name, dbg_root);\n}\n\n \nvoid fm10k_dbg_intfc_exit(struct fm10k_intfc *interface)\n{\n\tif (dbg_root)\n\t\tdebugfs_remove_recursive(interface->dbg_intfc);\n\tinterface->dbg_intfc = NULL;\n}\n\n \nvoid fm10k_dbg_init(void)\n{\n\tdbg_root = debugfs_create_dir(fm10k_driver_name, NULL);\n}\n\n \nvoid fm10k_dbg_exit(void)\n{\n\tdebugfs_remove_recursive(dbg_root);\n\tdbg_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}