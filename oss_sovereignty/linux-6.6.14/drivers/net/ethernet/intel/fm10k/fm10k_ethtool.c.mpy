{
  "module_name": "fm10k_ethtool.c",
  "hash_id": "b4e03ff92b9961a81a0c62fcb76a6bbb529faf85fe0e39229303b2972a1694f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/vmalloc.h>\n\n#include \"fm10k.h\"\n\nstruct fm10k_stats {\n\t \n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define FM10K_STAT_FIELDS(_type, _name, _stat) { \\\n\t.stat_string = _name, \\\n\t.sizeof_stat = sizeof_field(_type, _stat), \\\n\t.stat_offset = offsetof(_type, _stat) \\\n}\n\n \n#define FM10K_NETDEV_STAT(_net_stat) \\\n\tFM10K_STAT_FIELDS(struct net_device_stats, __stringify(_net_stat), \\\n\t\t\t  _net_stat)\n\nstatic const struct fm10k_stats fm10k_gstrings_net_stats[] = {\n\tFM10K_NETDEV_STAT(tx_packets),\n\tFM10K_NETDEV_STAT(tx_bytes),\n\tFM10K_NETDEV_STAT(tx_errors),\n\tFM10K_NETDEV_STAT(rx_packets),\n\tFM10K_NETDEV_STAT(rx_bytes),\n\tFM10K_NETDEV_STAT(rx_errors),\n\tFM10K_NETDEV_STAT(rx_dropped),\n\n\t \n\tFM10K_NETDEV_STAT(rx_length_errors),\n\tFM10K_NETDEV_STAT(rx_crc_errors),\n\tFM10K_NETDEV_STAT(rx_fifo_errors),\n};\n\n#define FM10K_NETDEV_STATS_LEN\tARRAY_SIZE(fm10k_gstrings_net_stats)\n\n \n#define FM10K_STAT(_name, _stat) \\\n\tFM10K_STAT_FIELDS(struct fm10k_intfc, _name, _stat)\n\nstatic const struct fm10k_stats fm10k_gstrings_global_stats[] = {\n\tFM10K_STAT(\"tx_restart_queue\", restart_queue),\n\tFM10K_STAT(\"tx_busy\", tx_busy),\n\tFM10K_STAT(\"tx_csum_errors\", tx_csum_errors),\n\tFM10K_STAT(\"rx_alloc_failed\", alloc_failed),\n\tFM10K_STAT(\"rx_csum_errors\", rx_csum_errors),\n\n\tFM10K_STAT(\"tx_packets_nic\", tx_packets_nic),\n\tFM10K_STAT(\"tx_bytes_nic\", tx_bytes_nic),\n\tFM10K_STAT(\"rx_packets_nic\", rx_packets_nic),\n\tFM10K_STAT(\"rx_bytes_nic\", rx_bytes_nic),\n\tFM10K_STAT(\"rx_drops_nic\", rx_drops_nic),\n\tFM10K_STAT(\"rx_overrun_pf\", rx_overrun_pf),\n\tFM10K_STAT(\"rx_overrun_vf\", rx_overrun_vf),\n\n\tFM10K_STAT(\"swapi_status\", hw.swapi.status),\n\tFM10K_STAT(\"mac_rules_used\", hw.swapi.mac.used),\n\tFM10K_STAT(\"mac_rules_avail\", hw.swapi.mac.avail),\n\n\tFM10K_STAT(\"reset_while_pending\", hw.mac.reset_while_pending),\n\n\tFM10K_STAT(\"tx_hang_count\", tx_timeout_count),\n};\n\nstatic const struct fm10k_stats fm10k_gstrings_pf_stats[] = {\n\tFM10K_STAT(\"timeout\", stats.timeout.count),\n\tFM10K_STAT(\"ur\", stats.ur.count),\n\tFM10K_STAT(\"ca\", stats.ca.count),\n\tFM10K_STAT(\"um\", stats.um.count),\n\tFM10K_STAT(\"xec\", stats.xec.count),\n\tFM10K_STAT(\"vlan_drop\", stats.vlan_drop.count),\n\tFM10K_STAT(\"loopback_drop\", stats.loopback_drop.count),\n\tFM10K_STAT(\"nodesc_drop\", stats.nodesc_drop.count),\n};\n\n \n#define FM10K_MBX_STAT(_name, _stat) \\\n\tFM10K_STAT_FIELDS(struct fm10k_mbx_info, _name, _stat)\n\nstatic const struct fm10k_stats fm10k_gstrings_mbx_stats[] = {\n\tFM10K_MBX_STAT(\"mbx_tx_busy\", tx_busy),\n\tFM10K_MBX_STAT(\"mbx_tx_dropped\", tx_dropped),\n\tFM10K_MBX_STAT(\"mbx_tx_messages\", tx_messages),\n\tFM10K_MBX_STAT(\"mbx_tx_dwords\", tx_dwords),\n\tFM10K_MBX_STAT(\"mbx_tx_mbmem_pulled\", tx_mbmem_pulled),\n\tFM10K_MBX_STAT(\"mbx_rx_messages\", rx_messages),\n\tFM10K_MBX_STAT(\"mbx_rx_dwords\", rx_dwords),\n\tFM10K_MBX_STAT(\"mbx_rx_parse_err\", rx_parse_err),\n\tFM10K_MBX_STAT(\"mbx_rx_mbmem_pushed\", rx_mbmem_pushed),\n};\n\n \n#define FM10K_QUEUE_STAT(_name, _stat) \\\n\tFM10K_STAT_FIELDS(struct fm10k_ring, _name, _stat)\n\nstatic const struct fm10k_stats fm10k_gstrings_queue_stats[] = {\n\tFM10K_QUEUE_STAT(\"%s_queue_%u_packets\", stats.packets),\n\tFM10K_QUEUE_STAT(\"%s_queue_%u_bytes\", stats.bytes),\n};\n\n#define FM10K_GLOBAL_STATS_LEN ARRAY_SIZE(fm10k_gstrings_global_stats)\n#define FM10K_PF_STATS_LEN ARRAY_SIZE(fm10k_gstrings_pf_stats)\n#define FM10K_MBX_STATS_LEN ARRAY_SIZE(fm10k_gstrings_mbx_stats)\n#define FM10K_QUEUE_STATS_LEN ARRAY_SIZE(fm10k_gstrings_queue_stats)\n\n#define FM10K_STATIC_STATS_LEN (FM10K_GLOBAL_STATS_LEN + \\\n\t\t\t\tFM10K_NETDEV_STATS_LEN + \\\n\t\t\t\tFM10K_MBX_STATS_LEN)\n\nstatic const char fm10k_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Mailbox test (on/offline)\"\n};\n\n#define FM10K_TEST_LEN (sizeof(fm10k_gstrings_test) / ETH_GSTRING_LEN)\n\nenum fm10k_self_test_types {\n\tFM10K_TEST_MBX,\n\tFM10K_TEST_MAX = FM10K_TEST_LEN\n};\n\nenum {\n\tFM10K_PRV_FLAG_LEN,\n};\n\nstatic const char fm10k_prv_flags[FM10K_PRV_FLAG_LEN][ETH_GSTRING_LEN] = {\n};\n\nstatic void __fm10k_add_stat_strings(u8 **p, const struct fm10k_stats stats[],\n\t\t\t\t     const unsigned int size, ...)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tva_list args;\n\n\t\tva_start(args, size);\n\t\tvsnprintf(*p, ETH_GSTRING_LEN, stats[i].stat_string, args);\n\t\t*p += ETH_GSTRING_LEN;\n\t\tva_end(args);\n\t}\n}\n\n#define fm10k_add_stat_strings(p, stats, ...) \\\n\t__fm10k_add_stat_strings(p, stats, ARRAY_SIZE(stats), ## __VA_ARGS__)\n\nstatic void fm10k_get_stat_strings(struct net_device *dev, u8 *data)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tunsigned int i;\n\n\tfm10k_add_stat_strings(&data, fm10k_gstrings_net_stats);\n\n\tfm10k_add_stat_strings(&data, fm10k_gstrings_global_stats);\n\n\tfm10k_add_stat_strings(&data, fm10k_gstrings_mbx_stats);\n\n\tif (interface->hw.mac.type != fm10k_mac_vf)\n\t\tfm10k_add_stat_strings(&data, fm10k_gstrings_pf_stats);\n\n\tfor (i = 0; i < interface->hw.mac.max_queues; i++) {\n\t\tfm10k_add_stat_strings(&data, fm10k_gstrings_queue_stats,\n\t\t\t\t       \"tx\", i);\n\n\t\tfm10k_add_stat_strings(&data, fm10k_gstrings_queue_stats,\n\t\t\t\t       \"rx\", i);\n\t}\n}\n\nstatic void fm10k_get_strings(struct net_device *dev,\n\t\t\t      u32 stringset, u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, fm10k_gstrings_test,\n\t\t       FM10K_TEST_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfm10k_get_stat_strings(dev, data);\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(data, fm10k_prv_flags,\n\t\t       FM10K_PRV_FLAG_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic int fm10k_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint stats_len = FM10K_STATIC_STATS_LEN;\n\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn FM10K_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\tstats_len += hw->mac.max_queues * 2 * FM10K_QUEUE_STATS_LEN;\n\n\t\tif (hw->mac.type != fm10k_mac_vf)\n\t\t\tstats_len += FM10K_PF_STATS_LEN;\n\n\t\treturn stats_len;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn FM10K_PRV_FLAG_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void __fm10k_add_ethtool_stats(u64 **data, void *pointer,\n\t\t\t\t      const struct fm10k_stats stats[],\n\t\t\t\t      const unsigned int size)\n{\n\tunsigned int i;\n\n\tif (!pointer) {\n\t\t \n\t\tfor (i = 0; i < size; i++)\n\t\t\t*((*data)++) = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tchar *p = (char *)pointer + stats[i].stat_offset;\n\n\t\tswitch (stats[i].sizeof_stat) {\n\t\tcase sizeof(u64):\n\t\t\t*((*data)++) = *(u64 *)p;\n\t\t\tbreak;\n\t\tcase sizeof(u32):\n\t\t\t*((*data)++) = *(u32 *)p;\n\t\t\tbreak;\n\t\tcase sizeof(u16):\n\t\t\t*((*data)++) = *(u16 *)p;\n\t\t\tbreak;\n\t\tcase sizeof(u8):\n\t\t\t*((*data)++) = *(u8 *)p;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"unexpected stat size for %s\",\n\t\t\t\t  stats[i].stat_string);\n\t\t\t*((*data)++) = 0;\n\t\t}\n\t}\n}\n\n#define fm10k_add_ethtool_stats(data, pointer, stats) \\\n\t__fm10k_add_ethtool_stats(data, pointer, stats, ARRAY_SIZE(stats))\n\nstatic void fm10k_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats __always_unused *stats,\n\t\t\t\t    u64 *data)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct net_device_stats *net_stats = &netdev->stats;\n\tint i;\n\n\tfm10k_update_stats(interface);\n\n\tfm10k_add_ethtool_stats(&data, net_stats, fm10k_gstrings_net_stats);\n\n\tfm10k_add_ethtool_stats(&data, interface, fm10k_gstrings_global_stats);\n\n\tfm10k_add_ethtool_stats(&data, &interface->hw.mbx,\n\t\t\t\tfm10k_gstrings_mbx_stats);\n\n\tif (interface->hw.mac.type != fm10k_mac_vf) {\n\t\tfm10k_add_ethtool_stats(&data, interface,\n\t\t\t\t\tfm10k_gstrings_pf_stats);\n\t}\n\n\tfor (i = 0; i < interface->hw.mac.max_queues; i++) {\n\t\tstruct fm10k_ring *ring;\n\n\t\tring = interface->tx_ring[i];\n\t\tfm10k_add_ethtool_stats(&data, ring,\n\t\t\t\t\tfm10k_gstrings_queue_stats);\n\n\t\tring = interface->rx_ring[i];\n\t\tfm10k_add_ethtool_stats(&data, ring,\n\t\t\t\t\tfm10k_gstrings_queue_stats);\n\t}\n}\n\n \n#define FM10K_REGS_LEN_Q 29\n\nstatic void fm10k_get_reg_q(struct fm10k_hw *hw, u32 *buff, int i)\n{\n\tint idx = 0;\n\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RDBAL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RDBAH(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RDLEN(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TPH_RXCTRL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RDH(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RDT(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RXQCTL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RXDCTL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RXINT(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_SRRCTL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_QPRC(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_QPRDC(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_QBRC_L(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_QBRC_H(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TDBAL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TDBAH(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TDLEN(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TPH_TXCTRL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TDH(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TDT(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TXDCTL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TXQCTL(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TXINT(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_QPTC(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_QBTC_L(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_QBTC_H(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TQDLOC(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_TX_SGLORT(i));\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_PFVTCTL(i));\n\n\tBUG_ON(idx != FM10K_REGS_LEN_Q);\n}\n\n \n#define FM10K_REGS_LEN_VSI 43\n\nstatic void fm10k_get_reg_vsi(struct fm10k_hw *hw, u32 *buff, int i)\n{\n\tint idx = 0, j;\n\n\tbuff[idx++] = fm10k_read_reg(hw, FM10K_MRQC(i));\n\tfor (j = 0; j < 10; j++)\n\t\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RSSRK(i, j));\n\tfor (j = 0; j < 32; j++)\n\t\tbuff[idx++] = fm10k_read_reg(hw, FM10K_RETA(i, j));\n\n\tBUG_ON(idx != FM10K_REGS_LEN_VSI);\n}\n\nstatic void fm10k_get_regs(struct net_device *netdev,\n\t\t\t   struct ethtool_regs *regs, void *p)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu32 *buff = p;\n\tu16 i;\n\n\tregs->version = BIT(24) | (hw->revision_id << 16) | hw->device_id;\n\n\tswitch (hw->mac.type) {\n\tcase fm10k_mac_pf:\n\t\t \n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_CTRL);\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_CTRL_EXT);\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_GCR);\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_GCR_EXT);\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\t*(buff++) = fm10k_read_reg(hw, FM10K_DGLORTMAP(i));\n\t\t\t*(buff++) = fm10k_read_reg(hw, FM10K_DGLORTDEC(i));\n\t\t}\n\n\t\tfor (i = 0; i < 65; i++) {\n\t\t\tfm10k_get_reg_vsi(hw, buff, i);\n\t\t\tbuff += FM10K_REGS_LEN_VSI;\n\t\t}\n\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_DMA_CTRL);\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_DMA_CTRL2);\n\n\t\tfor (i = 0; i < FM10K_MAX_QUEUES_PF; i++) {\n\t\t\tfm10k_get_reg_q(hw, buff, i);\n\t\t\tbuff += FM10K_REGS_LEN_Q;\n\t\t}\n\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_TPH_CTRL);\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t*(buff++) = fm10k_read_reg(hw, FM10K_INT_MAP(i));\n\n\t\t \n\t\tfor (i = 0; i < 130; i++)\n\t\t\t*(buff++) = fm10k_read_reg(hw, FM10K_ITR(i));\n\n\t\tbreak;\n\tcase fm10k_mac_vf:\n\t\t \n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_VFCTRL);\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_VFINT_MAP);\n\t\t*(buff++) = fm10k_read_reg(hw, FM10K_VFSYSTIME);\n\n\t\t \n\t\tfor (i = 0; i < 8; i++)\n\t\t\t*(buff++) = fm10k_read_reg(hw, FM10K_VFITR(i));\n\n\t\tfm10k_get_reg_vsi(hw, buff, 0);\n\t\tbuff += FM10K_REGS_LEN_VSI;\n\n\t\tfor (i = 0; i < FM10K_MAX_QUEUES_POOL; i++) {\n\t\t\tif (i < hw->mac.max_queues)\n\t\t\t\tfm10k_get_reg_q(hw, buff, i);\n\t\t\telse\n\t\t\t\tmemset(buff, 0, sizeof(u32) * FM10K_REGS_LEN_Q);\n\t\t\tbuff += FM10K_REGS_LEN_Q;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \n#define FM10K_REGS_LEN_PF \\\n(162 + (65 * FM10K_REGS_LEN_VSI) + (FM10K_MAX_QUEUES_PF * FM10K_REGS_LEN_Q))\n#define FM10K_REGS_LEN_VF \\\n(11 + FM10K_REGS_LEN_VSI + (FM10K_MAX_QUEUES_POOL * FM10K_REGS_LEN_Q))\n\nstatic int fm10k_get_regs_len(struct net_device *netdev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\tswitch (hw->mac.type) {\n\tcase fm10k_mac_pf:\n\t\treturn FM10K_REGS_LEN_PF * sizeof(u32);\n\tcase fm10k_mac_vf:\n\t\treturn FM10K_REGS_LEN_VF * sizeof(u32);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void fm10k_get_drvinfo(struct net_device *dev,\n\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\n\tstrncpy(info->driver, fm10k_driver_name,\n\t\tsizeof(info->driver) - 1);\n\tstrncpy(info->bus_info, pci_name(interface->pdev),\n\t\tsizeof(info->bus_info) - 1);\n}\n\nstatic void fm10k_get_pauseparam(struct net_device *dev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\n\t \n\tpause->autoneg = 0;\n\tpause->tx_pause = 1;\n\n\tpause->rx_pause = interface->rx_pause ? 1 : 0;\n}\n\nstatic int fm10k_set_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\tif (pause->autoneg || !pause->tx_pause)\n\t\treturn -EINVAL;\n\n\t \n\tif (hw->mac.type == fm10k_mac_pf)\n\t\tinterface->rx_pause = pause->rx_pause ? ~0 : 0;\n\telse if (pause->rx_pause)\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\tfm10k_update_rx_drop_en(interface);\n\n\treturn 0;\n}\n\nstatic u32 fm10k_get_msglevel(struct net_device *netdev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\n\treturn interface->msg_enable;\n}\n\nstatic void fm10k_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\n\tinterface->msg_enable = data;\n}\n\nstatic void fm10k_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\n\tring->rx_max_pending = FM10K_MAX_RXD;\n\tring->tx_max_pending = FM10K_MAX_TXD;\n\tring->rx_mini_max_pending = 0;\n\tring->rx_jumbo_max_pending = 0;\n\tring->rx_pending = interface->rx_ring_count;\n\tring->tx_pending = interface->tx_ring_count;\n\tring->rx_mini_pending = 0;\n\tring->rx_jumbo_pending = 0;\n}\n\nstatic int fm10k_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_ring *temp_ring;\n\tint i, err = 0;\n\tu32 new_rx_count, new_tx_count;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tnew_tx_count = clamp_t(u32, ring->tx_pending,\n\t\t\t       FM10K_MIN_TXD, FM10K_MAX_TXD);\n\tnew_tx_count = ALIGN(new_tx_count, FM10K_REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tnew_rx_count = clamp_t(u32, ring->rx_pending,\n\t\t\t       FM10K_MIN_RXD, FM10K_MAX_RXD);\n\tnew_rx_count = ALIGN(new_rx_count, FM10K_REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\tif ((new_tx_count == interface->tx_ring_count) &&\n\t    (new_rx_count == interface->rx_ring_count)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\twhile (test_and_set_bit(__FM10K_RESETTING, interface->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(interface->netdev)) {\n\t\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\t\tinterface->tx_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < interface->num_rx_queues; i++)\n\t\t\tinterface->rx_ring[i]->count = new_rx_count;\n\t\tinterface->tx_ring_count = new_tx_count;\n\t\tinterface->rx_ring_count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\t \n\ti = max_t(int, interface->num_tx_queues, interface->num_rx_queues);\n\ttemp_ring = vmalloc(array_size(i, sizeof(struct fm10k_ring)));\n\n\tif (!temp_ring) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_reset;\n\t}\n\n\tfm10k_down(interface);\n\n\t \n\tif (new_tx_count != interface->tx_ring_count) {\n\t\tfor (i = 0; i < interface->num_tx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], interface->tx_ring[i],\n\t\t\t       sizeof(struct fm10k_ring));\n\n\t\t\ttemp_ring[i].count = new_tx_count;\n\t\t\terr = fm10k_setup_tx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tfm10k_free_tx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < interface->num_tx_queues; i++) {\n\t\t\tfm10k_free_tx_resources(interface->tx_ring[i]);\n\n\t\t\tmemcpy(interface->tx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct fm10k_ring));\n\t\t}\n\n\t\tinterface->tx_ring_count = new_tx_count;\n\t}\n\n\t \n\tif (new_rx_count != interface->rx_ring_count) {\n\t\tfor (i = 0; i < interface->num_rx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], interface->rx_ring[i],\n\t\t\t       sizeof(struct fm10k_ring));\n\n\t\t\ttemp_ring[i].count = new_rx_count;\n\t\t\terr = fm10k_setup_rx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tfm10k_free_rx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < interface->num_rx_queues; i++) {\n\t\t\tfm10k_free_rx_resources(interface->rx_ring[i]);\n\n\t\t\tmemcpy(interface->rx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct fm10k_ring));\n\t\t}\n\n\t\tinterface->rx_ring_count = new_rx_count;\n\t}\n\nerr_setup:\n\tfm10k_up(interface);\n\tvfree(temp_ring);\nclear_reset:\n\tclear_bit(__FM10K_RESETTING, interface->state);\n\treturn err;\n}\n\nstatic int fm10k_get_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\n\tec->use_adaptive_tx_coalesce = ITR_IS_ADAPTIVE(interface->tx_itr);\n\tec->tx_coalesce_usecs = interface->tx_itr & ~FM10K_ITR_ADAPTIVE;\n\n\tec->use_adaptive_rx_coalesce = ITR_IS_ADAPTIVE(interface->rx_itr);\n\tec->rx_coalesce_usecs = interface->rx_itr & ~FM10K_ITR_ADAPTIVE;\n\n\treturn 0;\n}\n\nstatic int fm10k_set_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tu16 tx_itr, rx_itr;\n\tint i;\n\n\t \n\tif ((ec->rx_coalesce_usecs > FM10K_ITR_MAX) ||\n\t    (ec->tx_coalesce_usecs > FM10K_ITR_MAX))\n\t\treturn -EINVAL;\n\n\t \n\ttx_itr = ec->tx_coalesce_usecs;\n\trx_itr = ec->rx_coalesce_usecs;\n\n\t \n\tif (ec->use_adaptive_tx_coalesce)\n\t\ttx_itr = FM10K_ITR_ADAPTIVE | FM10K_TX_ITR_DEFAULT;\n\n\tif (ec->use_adaptive_rx_coalesce)\n\t\trx_itr = FM10K_ITR_ADAPTIVE | FM10K_RX_ITR_DEFAULT;\n\n\t \n\tinterface->tx_itr = tx_itr;\n\tinterface->rx_itr = rx_itr;\n\n\t \n\tfor (i = 0; i < interface->num_q_vectors; i++) {\n\t\tstruct fm10k_q_vector *qv = interface->q_vector[i];\n\n\t\tqv->tx.itr = tx_itr;\n\t\tqv->rx.itr = rx_itr;\n\t}\n\n\treturn 0;\n}\n\nstatic int fm10k_get_rss_hash_opts(struct fm10k_intfc *interface,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tcmd->data = 0;\n\n\t \n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase UDP_V4_FLOW:\n\t\tif (test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\n\t\t\t     interface->flags))\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V4_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\n\t\t\t     interface->flags))\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fm10k_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t   u32 __always_unused *rule_locs)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = interface->num_rx_queues;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\tret = fm10k_get_rss_hash_opts(interface, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fm10k_set_rss_hash_opt(struct fm10k_intfc *interface,\n\t\t\t\t  struct ethtool_rxnfc *nfc)\n{\n\tint rss_ipv4_udp = test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\n\t\t\t\t    interface->flags);\n\tint rss_ipv6_udp = test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\n\t\t\t\t    interface->flags);\n\n\t \n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    !(nfc->data & RXH_L4_B_0_1) ||\n\t\t    !(nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tclear_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\n\t\t\t\t  interface->flags);\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tset_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\n\t\t\t\tinterface->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tclear_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\n\t\t\t\t  interface->flags);\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tset_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\n\t\t\t\tinterface->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    (nfc->data & RXH_L4_B_0_1) ||\n\t\t    (nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((rss_ipv4_udp != test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\n\t\t\t\t      interface->flags)) ||\n\t    (rss_ipv6_udp != test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\n\t\t\t\t      interface->flags))) {\n\t\tstruct fm10k_hw *hw = &interface->hw;\n\t\tbool warn = false;\n\t\tu32 mrqc;\n\n\t\t \n\t\tmrqc = FM10K_MRQC_IPV4 |\n\t\t       FM10K_MRQC_TCP_IPV4 |\n\t\t       FM10K_MRQC_IPV6 |\n\t\t       FM10K_MRQC_TCP_IPV6;\n\n\t\tif (test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\n\t\t\t     interface->flags)) {\n\t\t\tmrqc |= FM10K_MRQC_UDP_IPV4;\n\t\t\twarn = true;\n\t\t}\n\t\tif (test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\n\t\t\t     interface->flags)) {\n\t\t\tmrqc |= FM10K_MRQC_UDP_IPV6;\n\t\t\twarn = true;\n\t\t}\n\n\t\t \n\t\tif (warn)\n\t\t\tnetif_warn(interface, drv, interface->netdev,\n\t\t\t\t   \"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\\n\");\n\n\t\tfm10k_write_reg(hw, FM10K_MRQC(0), mrqc);\n\t}\n\n\treturn 0;\n}\n\nstatic int fm10k_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = fm10k_set_rss_hash_opt(interface, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fm10k_mbx_test(struct fm10k_intfc *interface, u64 *data)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 attr_flag, test_msg[6];\n\tunsigned long timeout;\n\tint err = -EINVAL;\n\n\t \n\tif (hw->mac.type != fm10k_mac_vf)\n\t\treturn 0;\n\n\t \n\tfor (attr_flag = BIT(FM10K_TEST_MSG_UNSET);\n\t     attr_flag < BIT(2 * FM10K_TEST_MSG_NESTED);\n\t     attr_flag += attr_flag) {\n\t\t \n\t\tfm10k_tlv_msg_test_create(test_msg, attr_flag);\n\n\t\tfm10k_mbx_lock(interface);\n\t\tmbx->test_result = FM10K_NOT_IMPLEMENTED;\n\t\terr = mbx->ops.enqueue_tx(hw, mbx, test_msg);\n\t\tfm10k_mbx_unlock(interface);\n\n\t\t \n\t\ttimeout = jiffies + HZ;\n\t\tdo {\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_out;\n\n\t\t\tusleep_range(500, 1000);\n\n\t\t\tfm10k_mbx_lock(interface);\n\t\t\tmbx->ops.process(hw, mbx);\n\t\t\tfm10k_mbx_unlock(interface);\n\n\t\t\terr = mbx->test_result;\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t} while (time_is_after_jiffies(timeout));\n\n\t\t \n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\nerr_out:\n\t*data = err < 0 ? (attr_flag) : (err > 0);\n\treturn err;\n}\n\nstatic void fm10k_self_test(struct net_device *dev,\n\t\t\t    struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\tmemset(data, 0, sizeof(*data) * FM10K_TEST_LEN);\n\n\tif (FM10K_REMOVED(hw->hw_addr)) {\n\t\tnetif_err(interface, drv, dev,\n\t\t\t  \"Interface removed - test blocked\\n\");\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\n\tif (fm10k_mbx_test(interface, &data[FM10K_TEST_MBX]))\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n}\n\nstatic u32 fm10k_get_priv_flags(struct net_device *netdev)\n{\n\treturn 0;\n}\n\nstatic int fm10k_set_priv_flags(struct net_device *netdev, u32 priv_flags)\n{\n\tif (priv_flags >= BIT(FM10K_PRV_FLAG_LEN))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic u32 fm10k_get_reta_size(struct net_device __always_unused *netdev)\n{\n\treturn FM10K_RETA_SIZE * FM10K_RETA_ENTRIES_PER_REG;\n}\n\nvoid fm10k_write_reta(struct fm10k_intfc *interface, const u32 *indir)\n{\n\tu16 rss_i = interface->ring_feature[RING_F_RSS].indices;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu32 table[4];\n\tint i, j;\n\n\t \n\tfor (i = 0; i < FM10K_RETA_SIZE; i++) {\n\t\tu32 reta, n;\n\n\t\t \n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif (indir)\n\t\t\t\tn = indir[4 * i + j];\n\t\t\telse\n\t\t\t\tn = ethtool_rxfh_indir_default(4 * i + j,\n\t\t\t\t\t\t\t       rss_i);\n\n\t\t\ttable[j] = n;\n\t\t}\n\n\t\treta = table[0] |\n\t\t\t(table[1] << 8) |\n\t\t\t(table[2] << 16) |\n\t\t\t(table[3] << 24);\n\n\t\tif (interface->reta[i] == reta)\n\t\t\tcontinue;\n\n\t\tinterface->reta[i] = reta;\n\t\tfm10k_write_reg(hw, FM10K_RETA(0, i), reta);\n\t}\n}\n\nstatic int fm10k_get_reta(struct net_device *netdev, u32 *indir)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tint i;\n\n\tif (!indir)\n\t\treturn 0;\n\n\tfor (i = 0; i < FM10K_RETA_SIZE; i++, indir += 4) {\n\t\tu32 reta = interface->reta[i];\n\n\t\tindir[0] = (reta << 24) >> 24;\n\t\tindir[1] = (reta << 16) >> 24;\n\t\tindir[2] = (reta <<  8) >> 24;\n\t\tindir[3] = (reta) >> 24;\n\t}\n\n\treturn 0;\n}\n\nstatic int fm10k_set_reta(struct net_device *netdev, const u32 *indir)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tint i;\n\tu16 rss_i;\n\n\tif (!indir)\n\t\treturn 0;\n\n\t \n\trss_i = interface->ring_feature[RING_F_RSS].indices;\n\tfor (i = fm10k_get_reta_size(netdev); i--;) {\n\t\tif (indir[i] < rss_i)\n\t\t\tcontinue;\n\t\treturn -EINVAL;\n\t}\n\n\tfm10k_write_reta(interface, indir);\n\n\treturn 0;\n}\n\nstatic u32 fm10k_get_rssrk_size(struct net_device __always_unused *netdev)\n{\n\treturn FM10K_RSSRK_SIZE * FM10K_RSSRK_ENTRIES_PER_REG;\n}\n\nstatic int fm10k_get_rssh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t  u8 *hfunc)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tint i, err;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\terr = fm10k_get_reta(netdev, indir);\n\tif (err || !key)\n\t\treturn err;\n\n\tfor (i = 0; i < FM10K_RSSRK_SIZE; i++, key += 4)\n\t\t*(__le32 *)key = cpu_to_le32(interface->rssrk[i]);\n\n\treturn 0;\n}\n\nstatic int fm10k_set_rssh(struct net_device *netdev, const u32 *indir,\n\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint i, err;\n\n\t \n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\terr = fm10k_set_reta(netdev, indir);\n\tif (err || !key)\n\t\treturn err;\n\n\tfor (i = 0; i < FM10K_RSSRK_SIZE; i++, key += 4) {\n\t\tu32 rssrk = le32_to_cpu(*(__le32 *)key);\n\n\t\tif (interface->rssrk[i] == rssrk)\n\t\t\tcontinue;\n\n\t\tinterface->rssrk[i] = rssrk;\n\t\tfm10k_write_reg(hw, FM10K_RSSRK(0, i), rssrk);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int fm10k_max_channels(struct net_device *dev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tunsigned int max_combined = interface->hw.mac.max_queues;\n\tu8 tcs = netdev_get_num_tc(dev);\n\n\t \n\tif (tcs > 1)\n\t\tmax_combined = BIT((fls(max_combined / tcs) - 1));\n\n\treturn max_combined;\n}\n\nstatic void fm10k_get_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *ch)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\n\t \n\tch->max_combined = fm10k_max_channels(dev);\n\n\t \n\tch->max_other = NON_Q_VECTORS;\n\tch->other_count = ch->max_other;\n\n\t \n\tch->combined_count = interface->ring_feature[RING_F_RSS].indices;\n}\n\nstatic int fm10k_set_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *ch)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tunsigned int count = ch->combined_count;\n\n\t \n\tif (!count || ch->rx_count || ch->tx_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (ch->other_count != NON_Q_VECTORS)\n\t\treturn -EINVAL;\n\n\t \n\tif (count > fm10k_max_channels(dev))\n\t\treturn -EINVAL;\n\n\tinterface->ring_feature[RING_F_RSS].limit = count;\n\n\t \n\treturn fm10k_setup_tc(dev, netdev_get_num_tc(dev));\n}\n\nstatic const struct ethtool_ops fm10k_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE,\n\t.get_strings\t\t= fm10k_get_strings,\n\t.get_sset_count\t\t= fm10k_get_sset_count,\n\t.get_ethtool_stats      = fm10k_get_ethtool_stats,\n\t.get_drvinfo\t\t= fm10k_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_pauseparam\t\t= fm10k_get_pauseparam,\n\t.set_pauseparam\t\t= fm10k_set_pauseparam,\n\t.get_msglevel\t\t= fm10k_get_msglevel,\n\t.set_msglevel\t\t= fm10k_set_msglevel,\n\t.get_ringparam\t\t= fm10k_get_ringparam,\n\t.set_ringparam\t\t= fm10k_set_ringparam,\n\t.get_coalesce\t\t= fm10k_get_coalesce,\n\t.set_coalesce\t\t= fm10k_set_coalesce,\n\t.get_rxnfc\t\t= fm10k_get_rxnfc,\n\t.set_rxnfc\t\t= fm10k_set_rxnfc,\n\t.get_regs               = fm10k_get_regs,\n\t.get_regs_len           = fm10k_get_regs_len,\n\t.self_test\t\t= fm10k_self_test,\n\t.get_priv_flags\t\t= fm10k_get_priv_flags,\n\t.set_priv_flags\t\t= fm10k_set_priv_flags,\n\t.get_rxfh_indir_size\t= fm10k_get_reta_size,\n\t.get_rxfh_key_size\t= fm10k_get_rssrk_size,\n\t.get_rxfh\t\t= fm10k_get_rssh,\n\t.set_rxfh\t\t= fm10k_set_rssh,\n\t.get_channels\t\t= fm10k_get_channels,\n\t.set_channels\t\t= fm10k_set_channels,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n};\n\nvoid fm10k_set_ethtool_ops(struct net_device *dev)\n{\n\tdev->ethtool_ops = &fm10k_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}