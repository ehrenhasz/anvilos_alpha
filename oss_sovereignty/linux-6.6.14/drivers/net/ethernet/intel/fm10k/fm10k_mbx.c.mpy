{
  "module_name": "fm10k_mbx.c",
  "hash_id": "1be41767019640480228b289d820bf50ecf9f62f258a4d3871a2b27bc3ca5f5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c",
  "human_readable_source": "\n \n\n#include \"fm10k_common.h\"\n\n \nstatic void fm10k_fifo_init(struct fm10k_mbx_fifo *fifo, u32 *buffer, u16 size)\n{\n\tfifo->buffer = buffer;\n\tfifo->size = size;\n\tfifo->head = 0;\n\tfifo->tail = 0;\n}\n\n \nstatic u16 fm10k_fifo_used(struct fm10k_mbx_fifo *fifo)\n{\n\treturn fifo->tail - fifo->head;\n}\n\n \nstatic u16 fm10k_fifo_unused(struct fm10k_mbx_fifo *fifo)\n{\n\treturn fifo->size + fifo->head - fifo->tail;\n}\n\n \nstatic bool fm10k_fifo_empty(struct fm10k_mbx_fifo *fifo)\n{\n\treturn fifo->head == fifo->tail;\n}\n\n \nstatic u16 fm10k_fifo_head_offset(struct fm10k_mbx_fifo *fifo, u16 offset)\n{\n\treturn (fifo->head + offset) & (fifo->size - 1);\n}\n\n \nstatic u16 fm10k_fifo_tail_offset(struct fm10k_mbx_fifo *fifo, u16 offset)\n{\n\treturn (fifo->tail + offset) & (fifo->size - 1);\n}\n\n \nstatic u16 fm10k_fifo_head_len(struct fm10k_mbx_fifo *fifo)\n{\n\tu32 *head = fifo->buffer + fm10k_fifo_head_offset(fifo, 0);\n\n\t \n\tif (fm10k_fifo_empty(fifo))\n\t\treturn 0;\n\n\t \n\treturn FM10K_TLV_DWORD_LEN(*head);\n}\n\n \nstatic u16 fm10k_fifo_head_drop(struct fm10k_mbx_fifo *fifo)\n{\n\tu16 len = fm10k_fifo_head_len(fifo);\n\n\t \n\tfifo->head += len;\n\n\treturn len;\n}\n\n \nstatic void fm10k_fifo_drop_all(struct fm10k_mbx_fifo *fifo)\n{\n\tfifo->head = fifo->tail;\n}\n\n \nstatic u16 fm10k_mbx_index_len(struct fm10k_mbx_info *mbx, u16 head, u16 tail)\n{\n\tu16 len = tail - head;\n\n\t \n\tif (len > tail)\n\t\tlen -= 2;\n\n\treturn len & ((mbx->mbmem_len << 1) - 1);\n}\n\n \nstatic u16 fm10k_mbx_tail_add(struct fm10k_mbx_info *mbx, u16 offset)\n{\n\tu16 tail = (mbx->tail + offset + 1) & ((mbx->mbmem_len << 1) - 1);\n\n\t \n\treturn (tail > mbx->tail) ? --tail : ++tail;\n}\n\n \nstatic u16 fm10k_mbx_tail_sub(struct fm10k_mbx_info *mbx, u16 offset)\n{\n\tu16 tail = (mbx->tail - offset - 1) & ((mbx->mbmem_len << 1) - 1);\n\n\t \n\treturn (tail < mbx->tail) ? ++tail : --tail;\n}\n\n \nstatic u16 fm10k_mbx_head_add(struct fm10k_mbx_info *mbx, u16 offset)\n{\n\tu16 head = (mbx->head + offset + 1) & ((mbx->mbmem_len << 1) - 1);\n\n\t \n\treturn (head > mbx->head) ? --head : ++head;\n}\n\n \nstatic u16 fm10k_mbx_head_sub(struct fm10k_mbx_info *mbx, u16 offset)\n{\n\tu16 head = (mbx->head - offset - 1) & ((mbx->mbmem_len << 1) - 1);\n\n\t \n\treturn (head < mbx->head) ? ++head : --head;\n}\n\n \nstatic u16 fm10k_mbx_pushed_tail_len(struct fm10k_mbx_info *mbx)\n{\n\tu32 *tail = mbx->rx.buffer + fm10k_fifo_tail_offset(&mbx->rx, 0);\n\n\t \n\tif (!mbx->pushed)\n\t\treturn 0;\n\n\treturn FM10K_TLV_DWORD_LEN(*tail);\n}\n\n \nstatic void fm10k_fifo_write_copy(struct fm10k_mbx_fifo *fifo,\n\t\t\t\t  const u32 *msg, u16 tail_offset, u16 len)\n{\n\tu16 end = fm10k_fifo_tail_offset(fifo, tail_offset);\n\tu32 *tail = fifo->buffer + end;\n\n\t \n\tend = fifo->size - end;\n\n\t \n\tif (end < len)\n\t\tmemcpy(fifo->buffer, msg + end, (len - end) << 2);\n\telse\n\t\tend = len;\n\n\t \n\tmemcpy(tail, msg, end << 2);\n}\n\n \nstatic s32 fm10k_fifo_enqueue(struct fm10k_mbx_fifo *fifo, const u32 *msg)\n{\n\tu16 len = FM10K_TLV_DWORD_LEN(*msg);\n\n\t \n\tif (len > fifo->size)\n\t\treturn FM10K_MBX_ERR_SIZE;\n\n\t \n\tif (len > fm10k_fifo_unused(fifo))\n\t\treturn FM10K_MBX_ERR_NO_SPACE;\n\n\t \n\tfm10k_fifo_write_copy(fifo, msg, 0, len);\n\n\t \n\twmb();\n\n\t \n\tfifo->tail += len;\n\n\treturn 0;\n}\n\n \nstatic u16 fm10k_mbx_validate_msg_size(struct fm10k_mbx_info *mbx, u16 len)\n{\n\tstruct fm10k_mbx_fifo *fifo = &mbx->rx;\n\tu16 total_len = 0, msg_len;\n\n\t \n\tlen += mbx->pushed;\n\n\t \n\tdo {\n\t\tu32 *msg;\n\n\t\tmsg = fifo->buffer + fm10k_fifo_tail_offset(fifo, total_len);\n\t\tmsg_len = FM10K_TLV_DWORD_LEN(*msg);\n\t\ttotal_len += msg_len;\n\t} while (total_len < len);\n\n\t \n\tif ((len < total_len) && (msg_len <= mbx->max_size))\n\t\treturn 0;\n\n\t \n\treturn (len < total_len) ? len : (len - total_len);\n}\n\n \nstatic void fm10k_mbx_write_copy(struct fm10k_hw *hw,\n\t\t\t\t struct fm10k_mbx_info *mbx)\n{\n\tstruct fm10k_mbx_fifo *fifo = &mbx->tx;\n\tu32 mbmem = mbx->mbmem_reg;\n\tu32 *head = fifo->buffer;\n\tu16 end, len, tail, mask;\n\n\tif (!mbx->tail_len)\n\t\treturn;\n\n\t \n\tmask = mbx->mbmem_len - 1;\n\tlen = mbx->tail_len;\n\ttail = fm10k_mbx_tail_sub(mbx, len);\n\tif (tail > mask)\n\t\ttail++;\n\n\t \n\tend = fm10k_fifo_head_offset(fifo, mbx->pulled);\n\thead += end;\n\n\t \n\trmb();\n\n\t \n\tfor (end = fifo->size - end; len; head = fifo->buffer) {\n\t\tdo {\n\t\t\t \n\t\t\ttail &= mask;\n\t\t\tif (!tail)\n\t\t\t\ttail++;\n\n\t\t\tmbx->tx_mbmem_pulled++;\n\n\t\t\t \n\t\t\tfm10k_write_reg(hw, mbmem + tail++, *(head++));\n\t\t} while (--len && --end);\n\t}\n}\n\n \nstatic void fm10k_mbx_pull_head(struct fm10k_hw *hw,\n\t\t\t\tstruct fm10k_mbx_info *mbx, u16 head)\n{\n\tu16 mbmem_len, len, ack = fm10k_mbx_index_len(mbx, head, mbx->tail);\n\tstruct fm10k_mbx_fifo *fifo = &mbx->tx;\n\n\t \n\tmbx->pulled += mbx->tail_len - ack;\n\n\t \n\tmbmem_len = mbx->mbmem_len - 1;\n\tlen = fm10k_fifo_used(fifo) - mbx->pulled;\n\tif (len > mbmem_len)\n\t\tlen = mbmem_len;\n\n\t \n\tmbx->tail = fm10k_mbx_tail_add(mbx, len - ack);\n\tmbx->tail_len = len;\n\n\t \n\tfor (len = fm10k_fifo_head_len(fifo);\n\t     len && (mbx->pulled >= len);\n\t     len = fm10k_fifo_head_len(fifo)) {\n\t\tmbx->pulled -= fm10k_fifo_head_drop(fifo);\n\t\tmbx->tx_messages++;\n\t\tmbx->tx_dwords += len;\n\t}\n\n\t \n\tfm10k_mbx_write_copy(hw, mbx);\n}\n\n \nstatic void fm10k_mbx_read_copy(struct fm10k_hw *hw,\n\t\t\t\tstruct fm10k_mbx_info *mbx)\n{\n\tstruct fm10k_mbx_fifo *fifo = &mbx->rx;\n\tu32 mbmem = mbx->mbmem_reg ^ mbx->mbmem_len;\n\tu32 *tail = fifo->buffer;\n\tu16 end, len, head;\n\n\t \n\tlen = mbx->head_len;\n\thead = fm10k_mbx_head_sub(mbx, len);\n\tif (head >= mbx->mbmem_len)\n\t\thead++;\n\n\t \n\tend = fm10k_fifo_tail_offset(fifo, mbx->pushed);\n\ttail += end;\n\n\t \n\tfor (end = fifo->size - end; len; tail = fifo->buffer) {\n\t\tdo {\n\t\t\t \n\t\t\thead &= mbx->mbmem_len - 1;\n\t\t\tif (!head)\n\t\t\t\thead++;\n\n\t\t\tmbx->rx_mbmem_pushed++;\n\n\t\t\t \n\t\t\t*(tail++) = fm10k_read_reg(hw, mbmem + head++);\n\t\t} while (--len && --end);\n\t}\n\n\t \n\twmb();\n}\n\n \nstatic s32 fm10k_mbx_push_tail(struct fm10k_hw *hw,\n\t\t\t       struct fm10k_mbx_info *mbx,\n\t\t\t       u16 tail)\n{\n\tstruct fm10k_mbx_fifo *fifo = &mbx->rx;\n\tu16 len, seq = fm10k_mbx_index_len(mbx, mbx->head, tail);\n\n\t \n\tlen = fm10k_fifo_unused(fifo) - mbx->pushed;\n\tif (len > seq)\n\t\tlen = seq;\n\n\t \n\tmbx->head = fm10k_mbx_head_add(mbx, len);\n\tmbx->head_len = len;\n\n\t \n\tif (!len)\n\t\treturn 0;\n\n\t \n\tfm10k_mbx_read_copy(hw, mbx);\n\n\t \n\tif (fm10k_mbx_validate_msg_size(mbx, len))\n\t\treturn FM10K_MBX_ERR_SIZE;\n\n\t \n\tmbx->pushed += len;\n\n\t \n\tfor (len = fm10k_mbx_pushed_tail_len(mbx);\n\t     len && (mbx->pushed >= len);\n\t     len = fm10k_mbx_pushed_tail_len(mbx)) {\n\t\tfifo->tail += len;\n\t\tmbx->pushed -= len;\n\t\tmbx->rx_messages++;\n\t\tmbx->rx_dwords += len;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const u16 fm10k_crc_16b_table[256] = {\n\t0x0000, 0x7956, 0xF2AC, 0x8BFA, 0xBC6D, 0xC53B, 0x4EC1, 0x3797,\n\t0x21EF, 0x58B9, 0xD343, 0xAA15, 0x9D82, 0xE4D4, 0x6F2E, 0x1678,\n\t0x43DE, 0x3A88, 0xB172, 0xC824, 0xFFB3, 0x86E5, 0x0D1F, 0x7449,\n\t0x6231, 0x1B67, 0x909D, 0xE9CB, 0xDE5C, 0xA70A, 0x2CF0, 0x55A6,\n\t0x87BC, 0xFEEA, 0x7510, 0x0C46, 0x3BD1, 0x4287, 0xC97D, 0xB02B,\n\t0xA653, 0xDF05, 0x54FF, 0x2DA9, 0x1A3E, 0x6368, 0xE892, 0x91C4,\n\t0xC462, 0xBD34, 0x36CE, 0x4F98, 0x780F, 0x0159, 0x8AA3, 0xF3F5,\n\t0xE58D, 0x9CDB, 0x1721, 0x6E77, 0x59E0, 0x20B6, 0xAB4C, 0xD21A,\n\t0x564D, 0x2F1B, 0xA4E1, 0xDDB7, 0xEA20, 0x9376, 0x188C, 0x61DA,\n\t0x77A2, 0x0EF4, 0x850E, 0xFC58, 0xCBCF, 0xB299, 0x3963, 0x4035,\n\t0x1593, 0x6CC5, 0xE73F, 0x9E69, 0xA9FE, 0xD0A8, 0x5B52, 0x2204,\n\t0x347C, 0x4D2A, 0xC6D0, 0xBF86, 0x8811, 0xF147, 0x7ABD, 0x03EB,\n\t0xD1F1, 0xA8A7, 0x235D, 0x5A0B, 0x6D9C, 0x14CA, 0x9F30, 0xE666,\n\t0xF01E, 0x8948, 0x02B2, 0x7BE4, 0x4C73, 0x3525, 0xBEDF, 0xC789,\n\t0x922F, 0xEB79, 0x6083, 0x19D5, 0x2E42, 0x5714, 0xDCEE, 0xA5B8,\n\t0xB3C0, 0xCA96, 0x416C, 0x383A, 0x0FAD, 0x76FB, 0xFD01, 0x8457,\n\t0xAC9A, 0xD5CC, 0x5E36, 0x2760, 0x10F7, 0x69A1, 0xE25B, 0x9B0D,\n\t0x8D75, 0xF423, 0x7FD9, 0x068F, 0x3118, 0x484E, 0xC3B4, 0xBAE2,\n\t0xEF44, 0x9612, 0x1DE8, 0x64BE, 0x5329, 0x2A7F, 0xA185, 0xD8D3,\n\t0xCEAB, 0xB7FD, 0x3C07, 0x4551, 0x72C6, 0x0B90, 0x806A, 0xF93C,\n\t0x2B26, 0x5270, 0xD98A, 0xA0DC, 0x974B, 0xEE1D, 0x65E7, 0x1CB1,\n\t0x0AC9, 0x739F, 0xF865, 0x8133, 0xB6A4, 0xCFF2, 0x4408, 0x3D5E,\n\t0x68F8, 0x11AE, 0x9A54, 0xE302, 0xD495, 0xADC3, 0x2639, 0x5F6F,\n\t0x4917, 0x3041, 0xBBBB, 0xC2ED, 0xF57A, 0x8C2C, 0x07D6, 0x7E80,\n\t0xFAD7, 0x8381, 0x087B, 0x712D, 0x46BA, 0x3FEC, 0xB416, 0xCD40,\n\t0xDB38, 0xA26E, 0x2994, 0x50C2, 0x6755, 0x1E03, 0x95F9, 0xECAF,\n\t0xB909, 0xC05F, 0x4BA5, 0x32F3, 0x0564, 0x7C32, 0xF7C8, 0x8E9E,\n\t0x98E6, 0xE1B0, 0x6A4A, 0x131C, 0x248B, 0x5DDD, 0xD627, 0xAF71,\n\t0x7D6B, 0x043D, 0x8FC7, 0xF691, 0xC106, 0xB850, 0x33AA, 0x4AFC,\n\t0x5C84, 0x25D2, 0xAE28, 0xD77E, 0xE0E9, 0x99BF, 0x1245, 0x6B13,\n\t0x3EB5, 0x47E3, 0xCC19, 0xB54F, 0x82D8, 0xFB8E, 0x7074, 0x0922,\n\t0x1F5A, 0x660C, 0xEDF6, 0x94A0, 0xA337, 0xDA61, 0x519B, 0x28CD };\n\n \nstatic u16 fm10k_crc_16b(const u32 *data, u16 seed, u16 len)\n{\n\tu32 result = seed;\n\n\twhile (len--) {\n\t\tresult ^= *(data++);\n\t\tresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\n\t\tresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\n\n\t\tif (!(len--))\n\t\t\tbreak;\n\n\t\tresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\n\t\tresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\n\t}\n\n\treturn (u16)result;\n}\n\n \nstatic u16 fm10k_fifo_crc(struct fm10k_mbx_fifo *fifo, u16 offset,\n\t\t\t  u16 len, u16 seed)\n{\n\tu32 *data = fifo->buffer + offset;\n\n\t \n\toffset = fifo->size - offset;\n\n\t \n\tif (offset < len) {\n\t\tseed = fm10k_crc_16b(data, seed, offset * 2);\n\t\tdata = fifo->buffer;\n\t\tlen -= offset;\n\t}\n\n\t \n\treturn fm10k_crc_16b(data, seed, len * 2);\n}\n\n \nstatic void fm10k_mbx_update_local_crc(struct fm10k_mbx_info *mbx, u16 head)\n{\n\tu16 len = mbx->tail_len - fm10k_mbx_index_len(mbx, head, mbx->tail);\n\n\t \n\thead = fm10k_fifo_head_offset(&mbx->tx, mbx->pulled);\n\n\t \n\tmbx->local = fm10k_fifo_crc(&mbx->tx, head, len, mbx->local);\n}\n\n \nstatic s32 fm10k_mbx_verify_remote_crc(struct fm10k_mbx_info *mbx)\n{\n\tstruct fm10k_mbx_fifo *fifo = &mbx->rx;\n\tu16 len = mbx->head_len;\n\tu16 offset = fm10k_fifo_tail_offset(fifo, mbx->pushed) - len;\n\tu16 crc;\n\n\t \n\tif (len)\n\t\tmbx->remote = fm10k_fifo_crc(fifo, offset, len, mbx->remote);\n\n\t \n\tcrc = fm10k_crc_16b(&mbx->mbx_hdr, mbx->remote, 1);\n\n\t \n\treturn crc ? FM10K_MBX_ERR_CRC : 0;\n}\n\n \nstatic bool fm10k_mbx_rx_ready(struct fm10k_mbx_info *mbx)\n{\n\tu16 msg_size = fm10k_fifo_head_len(&mbx->rx);\n\n\treturn msg_size && (fm10k_fifo_used(&mbx->rx) >= msg_size);\n}\n\n \nstatic bool fm10k_mbx_tx_ready(struct fm10k_mbx_info *mbx, u16 len)\n{\n\tu16 fifo_unused = fm10k_fifo_unused(&mbx->tx);\n\n\treturn (mbx->state == FM10K_STATE_OPEN) && (fifo_unused >= len);\n}\n\n \nstatic bool fm10k_mbx_tx_complete(struct fm10k_mbx_info *mbx)\n{\n\treturn fm10k_fifo_empty(&mbx->tx);\n}\n\n \nstatic u16 fm10k_mbx_dequeue_rx(struct fm10k_hw *hw,\n\t\t\t\tstruct fm10k_mbx_info *mbx)\n{\n\tstruct fm10k_mbx_fifo *fifo = &mbx->rx;\n\ts32 err;\n\tu16 cnt;\n\n\t \n\tfor (cnt = 0; !fm10k_fifo_empty(fifo); cnt++) {\n\t\terr = fm10k_tlv_msg_parse(hw, fifo->buffer + fifo->head,\n\t\t\t\t\t  mbx, mbx->msg_data);\n\t\tif (err < 0)\n\t\t\tmbx->rx_parse_err++;\n\n\t\tfm10k_fifo_head_drop(fifo);\n\t}\n\n\t \n\tmemmove(fifo->buffer, fifo->buffer + fifo->tail, mbx->pushed << 2);\n\n\t \n\tfifo->tail -= fifo->head;\n\tfifo->head = 0;\n\n\treturn cnt;\n}\n\n \nstatic s32 fm10k_mbx_enqueue_tx(struct fm10k_hw *hw,\n\t\t\t\tstruct fm10k_mbx_info *mbx, const u32 *msg)\n{\n\tu32 countdown = mbx->timeout;\n\ts32 err;\n\n\tswitch (mbx->state) {\n\tcase FM10K_STATE_CLOSED:\n\tcase FM10K_STATE_DISCONNECT:\n\t\treturn FM10K_MBX_ERR_NO_MBX;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\terr = fm10k_fifo_enqueue(&mbx->tx, msg);\n\n\t \n\twhile (err && countdown) {\n\t\tcountdown--;\n\t\tudelay(mbx->udelay);\n\t\tmbx->ops.process(hw, mbx);\n\t\terr = fm10k_fifo_enqueue(&mbx->tx, msg);\n\t}\n\n\t \n\tif (err) {\n\t\tmbx->timeout = 0;\n\t\tmbx->tx_busy++;\n\t}\n\n\t \n\tif (!mbx->tail_len)\n\t\tmbx->ops.process(hw, mbx);\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_mbx_read(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\n{\n\t \n\tif (mbx->mbx_hdr)\n\t\treturn FM10K_MBX_ERR_BUSY;\n\n\t \n\tif (fm10k_read_reg(hw, mbx->mbx_reg) & FM10K_MBX_REQ_INTERRUPT)\n\t\tmbx->mbx_lock = FM10K_MBX_ACK;\n\n\t \n\tfm10k_write_reg(hw, mbx->mbx_reg,\n\t\t\tFM10K_MBX_REQ_INTERRUPT | FM10K_MBX_ACK_INTERRUPT);\n\n\t \n\tmbx->mbx_hdr = fm10k_read_reg(hw, mbx->mbmem_reg ^ mbx->mbmem_len);\n\n\treturn 0;\n}\n\n \nstatic void fm10k_mbx_write(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\n{\n\tu32 mbmem = mbx->mbmem_reg;\n\n\t \n\tfm10k_write_reg(hw, mbmem, mbx->mbx_hdr);\n\n\t \n\tif (mbx->mbx_lock)\n\t\tfm10k_write_reg(hw, mbx->mbx_reg, mbx->mbx_lock);\n\n\t \n\tmbx->mbx_hdr = 0;\n\tmbx->mbx_lock = 0;\n}\n\n \nstatic void fm10k_mbx_create_connect_hdr(struct fm10k_mbx_info *mbx)\n{\n\tmbx->mbx_lock |= FM10K_MBX_REQ;\n\n\tmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_CONNECT, TYPE) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(mbx->rx.size - 1, CONNECT_SIZE);\n}\n\n \nstatic void fm10k_mbx_create_data_hdr(struct fm10k_mbx_info *mbx)\n{\n\tu32 hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_DATA, TYPE) |\n\t\t  FM10K_MSG_HDR_FIELD_SET(mbx->tail, TAIL) |\n\t\t  FM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD);\n\tstruct fm10k_mbx_fifo *fifo = &mbx->tx;\n\tu16 crc;\n\n\tif (mbx->tail_len)\n\t\tmbx->mbx_lock |= FM10K_MBX_REQ;\n\n\t \n\tcrc = fm10k_fifo_crc(fifo, fm10k_fifo_head_offset(fifo, mbx->pulled),\n\t\t\t     mbx->tail_len, mbx->local);\n\tcrc = fm10k_crc_16b(&hdr, crc, 1);\n\n\t \n\tmbx->mbx_hdr = hdr | FM10K_MSG_HDR_FIELD_SET(crc, CRC);\n}\n\n \nstatic void fm10k_mbx_create_disconnect_hdr(struct fm10k_mbx_info *mbx)\n{\n\tu32 hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_DISCONNECT, TYPE) |\n\t\t  FM10K_MSG_HDR_FIELD_SET(mbx->tail, TAIL) |\n\t\t  FM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD);\n\tu16 crc = fm10k_crc_16b(&hdr, mbx->local, 1);\n\n\tmbx->mbx_lock |= FM10K_MBX_ACK;\n\n\t \n\tmbx->mbx_hdr = hdr | FM10K_MSG_HDR_FIELD_SET(crc, CRC);\n}\n\n \nstatic void fm10k_mbx_create_fake_disconnect_hdr(struct fm10k_mbx_info *mbx)\n{\n\tu32 hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_DISCONNECT, TYPE) |\n\t\t  FM10K_MSG_HDR_FIELD_SET(mbx->head, TAIL) |\n\t\t  FM10K_MSG_HDR_FIELD_SET(mbx->tail, HEAD);\n\tu16 crc = fm10k_crc_16b(&hdr, mbx->local, 1);\n\n\tmbx->mbx_lock |= FM10K_MBX_ACK;\n\n\t \n\tmbx->mbx_hdr = hdr | FM10K_MSG_HDR_FIELD_SET(crc, CRC);\n}\n\n \nstatic void fm10k_mbx_create_error_msg(struct fm10k_mbx_info *mbx, s32 err)\n{\n\t \n\tswitch (err) {\n\tcase FM10K_MBX_ERR_TAIL:\n\tcase FM10K_MBX_ERR_HEAD:\n\tcase FM10K_MBX_ERR_TYPE:\n\tcase FM10K_MBX_ERR_SIZE:\n\tcase FM10K_MBX_ERR_RSVD0:\n\tcase FM10K_MBX_ERR_CRC:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tmbx->mbx_lock |= FM10K_MBX_REQ;\n\n\tmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_ERROR, TYPE) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(err, ERR_NO) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD);\n}\n\n \nstatic s32 fm10k_mbx_validate_msg_hdr(struct fm10k_mbx_info *mbx)\n{\n\tu16 type, rsvd0, head, tail, size;\n\tconst u32 *hdr = &mbx->mbx_hdr;\n\n\ttype = FM10K_MSG_HDR_FIELD_GET(*hdr, TYPE);\n\trsvd0 = FM10K_MSG_HDR_FIELD_GET(*hdr, RSVD0);\n\ttail = FM10K_MSG_HDR_FIELD_GET(*hdr, TAIL);\n\thead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\n\tsize = FM10K_MSG_HDR_FIELD_GET(*hdr, CONNECT_SIZE);\n\n\tif (rsvd0)\n\t\treturn FM10K_MBX_ERR_RSVD0;\n\n\tswitch (type) {\n\tcase FM10K_MSG_DISCONNECT:\n\t\t \n\t\tif (tail != mbx->head)\n\t\t\treturn FM10K_MBX_ERR_TAIL;\n\n\t\tfallthrough;\n\tcase FM10K_MSG_DATA:\n\t\t \n\t\tif (!head || (head == FM10K_MSG_HDR_MASK(HEAD)))\n\t\t\treturn FM10K_MBX_ERR_HEAD;\n\t\tif (fm10k_mbx_index_len(mbx, head, mbx->tail) > mbx->tail_len)\n\t\t\treturn FM10K_MBX_ERR_HEAD;\n\n\t\t \n\t\tif (!tail || (tail == FM10K_MSG_HDR_MASK(TAIL)))\n\t\t\treturn FM10K_MBX_ERR_TAIL;\n\t\tif (fm10k_mbx_index_len(mbx, mbx->head, tail) < mbx->mbmem_len)\n\t\t\tbreak;\n\n\t\treturn FM10K_MBX_ERR_TAIL;\n\tcase FM10K_MSG_CONNECT:\n\t\t \n\t\tif ((size < FM10K_VFMBX_MSG_MTU) || (size & (size + 1)))\n\t\t\treturn FM10K_MBX_ERR_SIZE;\n\n\t\tfallthrough;\n\tcase FM10K_MSG_ERROR:\n\t\tif (!head || (head == FM10K_MSG_HDR_MASK(HEAD)))\n\t\t\treturn FM10K_MBX_ERR_HEAD;\n\t\t \n\t\tif (tail)\n\t\t\treturn FM10K_MBX_ERR_TAIL;\n\n\t\tbreak;\n\tdefault:\n\t\treturn FM10K_MBX_ERR_TYPE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_mbx_create_reply(struct fm10k_hw *hw,\n\t\t\t\t  struct fm10k_mbx_info *mbx, u16 head)\n{\n\tswitch (mbx->state) {\n\tcase FM10K_STATE_OPEN:\n\tcase FM10K_STATE_DISCONNECT:\n\t\t \n\t\tfm10k_mbx_update_local_crc(mbx, head);\n\n\t\t \n\t\tfm10k_mbx_pull_head(hw, mbx, head);\n\n\t\t \n\t\tif (mbx->tail_len || (mbx->state == FM10K_STATE_OPEN))\n\t\t\tfm10k_mbx_create_data_hdr(mbx);\n\t\telse\n\t\t\tfm10k_mbx_create_disconnect_hdr(mbx);\n\t\tbreak;\n\tcase FM10K_STATE_CONNECT:\n\t\t \n\t\tfm10k_mbx_create_connect_hdr(mbx);\n\t\tbreak;\n\tcase FM10K_STATE_CLOSED:\n\t\t \n\t\tfm10k_mbx_create_disconnect_hdr(mbx);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fm10k_mbx_reset_work(struct fm10k_mbx_info *mbx)\n{\n\tu16 len, head, ack;\n\n\t \n\tmbx->max_size = mbx->rx.size - 1;\n\n\t \n\thead = FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, HEAD);\n\tack = fm10k_mbx_index_len(mbx, head, mbx->tail);\n\tmbx->pulled += mbx->tail_len - ack;\n\n\t \n\twhile (fm10k_fifo_head_len(&mbx->tx) && mbx->pulled) {\n\t\tlen = fm10k_fifo_head_drop(&mbx->tx);\n\t\tmbx->tx_dropped++;\n\t\tif (mbx->pulled >= len)\n\t\t\tmbx->pulled -= len;\n\t\telse\n\t\t\tmbx->pulled = 0;\n\t}\n\n\t \n\tmbx->pushed = 0;\n\tmbx->pulled = 0;\n\tmbx->tail_len = 0;\n\tmbx->head_len = 0;\n\tmbx->rx.tail = 0;\n\tmbx->rx.head = 0;\n}\n\n \nstatic void fm10k_mbx_update_max_size(struct fm10k_mbx_info *mbx, u16 size)\n{\n\tu16 len;\n\n\tmbx->max_size = size;\n\n\t \n\tfor (len = fm10k_fifo_head_len(&mbx->tx);\n\t     len > size;\n\t     len = fm10k_fifo_head_len(&mbx->tx)) {\n\t\tfm10k_fifo_head_drop(&mbx->tx);\n\t\tmbx->tx_dropped++;\n\t}\n}\n\n \nstatic void fm10k_mbx_connect_reset(struct fm10k_mbx_info *mbx)\n{\n\t \n\tfm10k_mbx_reset_work(mbx);\n\n\t \n\tmbx->local = FM10K_MBX_CRC_SEED;\n\tmbx->remote = FM10K_MBX_CRC_SEED;\n\n\t \n\tif (mbx->state == FM10K_STATE_OPEN)\n\t\tmbx->state = FM10K_STATE_CONNECT;\n\telse\n\t\tmbx->state = FM10K_STATE_CLOSED;\n}\n\n \nstatic s32 fm10k_mbx_process_connect(struct fm10k_hw *hw,\n\t\t\t\t     struct fm10k_mbx_info *mbx)\n{\n\tconst enum fm10k_mbx_state state = mbx->state;\n\tconst u32 *hdr = &mbx->mbx_hdr;\n\tu16 size, head;\n\n\t \n\tsize = FM10K_MSG_HDR_FIELD_GET(*hdr, CONNECT_SIZE);\n\thead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\n\n\tswitch (state) {\n\tcase FM10K_STATE_DISCONNECT:\n\tcase FM10K_STATE_OPEN:\n\t\t \n\t\tfm10k_mbx_connect_reset(mbx);\n\t\tbreak;\n\tcase FM10K_STATE_CONNECT:\n\t\t \n\t\tif (size > mbx->rx.size) {\n\t\t\tmbx->max_size = mbx->rx.size - 1;\n\t\t} else {\n\t\t\t \n\t\t\tmbx->state = FM10K_STATE_OPEN;\n\n\t\t\tfm10k_mbx_update_max_size(mbx, size);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tmbx->tail = head;\n\n\treturn fm10k_mbx_create_reply(hw, mbx, head);\n}\n\n \nstatic s32 fm10k_mbx_process_data(struct fm10k_hw *hw,\n\t\t\t\t  struct fm10k_mbx_info *mbx)\n{\n\tconst u32 *hdr = &mbx->mbx_hdr;\n\tu16 head, tail;\n\ts32 err;\n\n\t \n\thead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\n\ttail = FM10K_MSG_HDR_FIELD_GET(*hdr, TAIL);\n\n\t \n\tif (mbx->state == FM10K_STATE_CONNECT) {\n\t\tmbx->tail = head;\n\t\tmbx->state = FM10K_STATE_OPEN;\n\t}\n\n\t \n\terr = fm10k_mbx_push_tail(hw, mbx, tail);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = fm10k_mbx_verify_remote_crc(mbx);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfm10k_mbx_dequeue_rx(hw, mbx);\n\n\treturn fm10k_mbx_create_reply(hw, mbx, head);\n}\n\n \nstatic s32 fm10k_mbx_process_disconnect(struct fm10k_hw *hw,\n\t\t\t\t\tstruct fm10k_mbx_info *mbx)\n{\n\tconst enum fm10k_mbx_state state = mbx->state;\n\tconst u32 *hdr = &mbx->mbx_hdr;\n\tu16 head;\n\ts32 err;\n\n\t \n\thead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\n\n\t \n\tif (mbx->pushed)\n\t\treturn FM10K_MBX_ERR_TAIL;\n\n\t \n\tmbx->head_len = 0;\n\n\t \n\terr = fm10k_mbx_verify_remote_crc(mbx);\n\tif (err)\n\t\treturn err;\n\n\tswitch (state) {\n\tcase FM10K_STATE_DISCONNECT:\n\tcase FM10K_STATE_OPEN:\n\t\t \n\t\tif (!fm10k_mbx_tx_complete(mbx))\n\t\t\tbreak;\n\n\t\t \n\t\tif (head != mbx->tail)\n\t\t\treturn FM10K_MBX_ERR_HEAD;\n\n\t\t \n\t\tfm10k_mbx_connect_reset(mbx);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn fm10k_mbx_create_reply(hw, mbx, head);\n}\n\n \nstatic s32 fm10k_mbx_process_error(struct fm10k_hw *hw,\n\t\t\t\t   struct fm10k_mbx_info *mbx)\n{\n\tconst u32 *hdr = &mbx->mbx_hdr;\n\tu16 head;\n\n\t \n\thead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\n\n\tswitch (mbx->state) {\n\tcase FM10K_STATE_OPEN:\n\tcase FM10K_STATE_DISCONNECT:\n\t\t \n\t\tfm10k_mbx_reset_work(mbx);\n\n\t\t \n\t\tmbx->local = FM10K_MBX_CRC_SEED;\n\t\tmbx->remote = FM10K_MBX_CRC_SEED;\n\n\t\t \n\t\tmbx->tail = head;\n\n\t\t \n\t\tif (mbx->state == FM10K_STATE_OPEN) {\n\t\t\tmbx->state = FM10K_STATE_CONNECT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfm10k_mbx_create_connect_hdr(mbx);\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn fm10k_mbx_create_reply(hw, mbx, mbx->tail);\n}\n\n \nstatic s32 fm10k_mbx_process(struct fm10k_hw *hw,\n\t\t\t     struct fm10k_mbx_info *mbx)\n{\n\ts32 err;\n\n\t \n\tif (mbx->state == FM10K_STATE_CLOSED)\n\t\treturn 0;\n\n\t \n\terr = fm10k_mbx_read(hw, mbx);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = fm10k_mbx_validate_msg_hdr(mbx);\n\tif (err < 0)\n\t\tgoto msg_err;\n\n\tswitch (FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, TYPE)) {\n\tcase FM10K_MSG_CONNECT:\n\t\terr = fm10k_mbx_process_connect(hw, mbx);\n\t\tbreak;\n\tcase FM10K_MSG_DATA:\n\t\terr = fm10k_mbx_process_data(hw, mbx);\n\t\tbreak;\n\tcase FM10K_MSG_DISCONNECT:\n\t\terr = fm10k_mbx_process_disconnect(hw, mbx);\n\t\tbreak;\n\tcase FM10K_MSG_ERROR:\n\t\terr = fm10k_mbx_process_error(hw, mbx);\n\t\tbreak;\n\tdefault:\n\t\terr = FM10K_MBX_ERR_TYPE;\n\t\tbreak;\n\t}\n\nmsg_err:\n\t \n\tif (err < 0)\n\t\tfm10k_mbx_create_error_msg(mbx, err);\n\n\t \n\tfm10k_mbx_write(hw, mbx);\n\n\treturn err;\n}\n\n \nstatic void fm10k_mbx_disconnect(struct fm10k_hw *hw,\n\t\t\t\t struct fm10k_mbx_info *mbx)\n{\n\tint timeout = mbx->timeout ? FM10K_MBX_DISCONNECT_TIMEOUT : 0;\n\n\t \n\tmbx->state = FM10K_STATE_DISCONNECT;\n\n\t \n\tfm10k_write_reg(hw, mbx->mbx_reg, FM10K_MBX_REQ |\n\t\t\t\t\t  FM10K_MBX_INTERRUPT_DISABLE);\n\tdo {\n\t\tudelay(FM10K_MBX_POLL_DELAY);\n\t\tmbx->ops.process(hw, mbx);\n\t\ttimeout -= FM10K_MBX_POLL_DELAY;\n\t} while ((timeout > 0) && (mbx->state != FM10K_STATE_CLOSED));\n\n\t \n\tfm10k_mbx_connect_reset(mbx);\n\tfm10k_fifo_drop_all(&mbx->tx);\n\n\tfm10k_write_reg(hw, mbx->mbmem_reg, 0);\n}\n\n \nstatic s32 fm10k_mbx_connect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\n{\n\t \n\tif (!mbx->rx.buffer)\n\t\treturn FM10K_MBX_ERR_NO_SPACE;\n\n\t \n\tif (mbx->state != FM10K_STATE_CLOSED)\n\t\treturn FM10K_MBX_ERR_BUSY;\n\n\t \n\tmbx->timeout = FM10K_MBX_INIT_TIMEOUT;\n\n\t \n\tmbx->state = FM10K_STATE_CONNECT;\n\n\tfm10k_mbx_reset_work(mbx);\n\n\t \n\tfm10k_mbx_create_fake_disconnect_hdr(mbx);\n\tfm10k_write_reg(hw, mbx->mbmem_reg ^ mbx->mbmem_len, mbx->mbx_hdr);\n\n\t \n\tmbx->mbx_lock = FM10K_MBX_REQ_INTERRUPT | FM10K_MBX_ACK_INTERRUPT |\n\t\t\tFM10K_MBX_INTERRUPT_ENABLE;\n\n\t \n\tfm10k_mbx_create_connect_hdr(mbx);\n\tfm10k_mbx_write(hw, mbx);\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_mbx_validate_handlers(const struct fm10k_msg_data *msg_data)\n{\n\tconst struct fm10k_tlv_attr *attr;\n\tunsigned int id;\n\n\t \n\tif (!msg_data)\n\t\treturn 0;\n\n\twhile (msg_data->id != FM10K_TLV_ERROR) {\n\t\t \n\t\tif (!msg_data->func)\n\t\t\treturn FM10K_ERR_PARAM;\n\n\t\t \n\t\tattr = msg_data->attr;\n\t\tif (attr) {\n\t\t\twhile (attr->id != FM10K_TLV_ERROR) {\n\t\t\t\tid = attr->id;\n\t\t\t\tattr++;\n\t\t\t\t \n\t\t\t\tif (id >= attr->id)\n\t\t\t\t\treturn FM10K_ERR_PARAM;\n\t\t\t\t \n\t\t\t\tif (id >= FM10K_TLV_RESULTS_MAX)\n\t\t\t\t\treturn FM10K_ERR_PARAM;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (attr->id != FM10K_TLV_ERROR)\n\t\t\t\treturn FM10K_ERR_PARAM;\n\t\t}\n\n\t\tid = msg_data->id;\n\t\tmsg_data++;\n\t\t \n\t\tif (id >= msg_data->id)\n\t\t\treturn FM10K_ERR_PARAM;\n\t}\n\n\t \n\tif ((msg_data->id != FM10K_TLV_ERROR) || !msg_data->func)\n\t\treturn FM10K_ERR_PARAM;\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_mbx_register_handlers(struct fm10k_mbx_info *mbx,\n\t\t\t\t       const struct fm10k_msg_data *msg_data)\n{\n\t \n\tif (fm10k_mbx_validate_handlers(msg_data))\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tmbx->msg_data = msg_data;\n\n\treturn 0;\n}\n\n \ns32 fm10k_pfvf_mbx_init(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx,\n\t\t\tconst struct fm10k_msg_data *msg_data, u8 id)\n{\n\t \n\tswitch (hw->mac.type) {\n\tcase fm10k_mac_vf:\n\t\tmbx->mbx_reg = FM10K_VFMBX;\n\t\tmbx->mbmem_reg = FM10K_VFMBMEM(FM10K_VFMBMEM_VF_XOR);\n\t\tbreak;\n\tcase fm10k_mac_pf:\n\t\t \n\t\tif (id < 64) {\n\t\t\tmbx->mbx_reg = FM10K_MBX(id);\n\t\t\tmbx->mbmem_reg = FM10K_MBMEM_VF(id, 0);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn FM10K_MBX_ERR_NO_MBX;\n\t}\n\n\t \n\tmbx->state = FM10K_STATE_CLOSED;\n\n\t \n\tif (fm10k_mbx_validate_handlers(msg_data))\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tmbx->msg_data = msg_data;\n\n\t \n\tmbx->timeout = 0;\n\tmbx->udelay = FM10K_MBX_INIT_DELAY;\n\n\t \n\tmbx->tail = 1;\n\tmbx->head = 1;\n\n\t \n\tmbx->local = FM10K_MBX_CRC_SEED;\n\tmbx->remote = FM10K_MBX_CRC_SEED;\n\n\t \n\tmbx->max_size = FM10K_MBX_MSG_MAX_SIZE;\n\tmbx->mbmem_len = FM10K_VFMBMEM_VF_XOR;\n\n\t \n\tfm10k_fifo_init(&mbx->tx, mbx->buffer, FM10K_MBX_TX_BUFFER_SIZE);\n\tfm10k_fifo_init(&mbx->rx, &mbx->buffer[FM10K_MBX_TX_BUFFER_SIZE],\n\t\t\tFM10K_MBX_RX_BUFFER_SIZE);\n\n\t \n\tmbx->ops.connect = fm10k_mbx_connect;\n\tmbx->ops.disconnect = fm10k_mbx_disconnect;\n\tmbx->ops.rx_ready = fm10k_mbx_rx_ready;\n\tmbx->ops.tx_ready = fm10k_mbx_tx_ready;\n\tmbx->ops.tx_complete = fm10k_mbx_tx_complete;\n\tmbx->ops.enqueue_tx = fm10k_mbx_enqueue_tx;\n\tmbx->ops.process = fm10k_mbx_process;\n\tmbx->ops.register_handlers = fm10k_mbx_register_handlers;\n\n\treturn 0;\n}\n\n \nstatic void fm10k_sm_mbx_create_data_hdr(struct fm10k_mbx_info *mbx)\n{\n\tif (mbx->tail_len)\n\t\tmbx->mbx_lock |= FM10K_MBX_REQ;\n\n\tmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(mbx->tail, SM_TAIL) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(mbx->remote, SM_VER) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(mbx->head, SM_HEAD);\n}\n\n \nstatic void fm10k_sm_mbx_create_connect_hdr(struct fm10k_mbx_info *mbx, u8 err)\n{\n\tif (mbx->local)\n\t\tmbx->mbx_lock |= FM10K_MBX_REQ;\n\n\tmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(mbx->tail, SM_TAIL) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(mbx->remote, SM_VER) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(mbx->head, SM_HEAD) |\n\t\t       FM10K_MSG_HDR_FIELD_SET(err, SM_ERR);\n}\n\n \nstatic void fm10k_sm_mbx_connect_reset(struct fm10k_mbx_info *mbx)\n{\n\t \n\tfm10k_mbx_reset_work(mbx);\n\n\t \n\tmbx->local = FM10K_SM_MBX_VERSION;\n\tmbx->remote = 0;\n\n\t \n\tmbx->tail = 1;\n\tmbx->head = 1;\n\n\t \n\tmbx->state = FM10K_STATE_CONNECT;\n}\n\n \nstatic s32 fm10k_sm_mbx_connect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\n{\n\t \n\tif (!mbx->rx.buffer)\n\t\treturn FM10K_MBX_ERR_NO_SPACE;\n\n\t \n\tif (mbx->state != FM10K_STATE_CLOSED)\n\t\treturn FM10K_MBX_ERR_BUSY;\n\n\t \n\tmbx->timeout = FM10K_MBX_INIT_TIMEOUT;\n\n\t \n\tmbx->state = FM10K_STATE_CONNECT;\n\tmbx->max_size = FM10K_MBX_MSG_MAX_SIZE;\n\n\t \n\tfm10k_sm_mbx_connect_reset(mbx);\n\n\t \n\tmbx->mbx_lock = FM10K_MBX_REQ_INTERRUPT | FM10K_MBX_ACK_INTERRUPT |\n\t\t\tFM10K_MBX_INTERRUPT_ENABLE;\n\n\t \n\tfm10k_sm_mbx_create_connect_hdr(mbx, 0);\n\tfm10k_mbx_write(hw, mbx);\n\n\treturn 0;\n}\n\n \nstatic void fm10k_sm_mbx_disconnect(struct fm10k_hw *hw,\n\t\t\t\t    struct fm10k_mbx_info *mbx)\n{\n\tint timeout = mbx->timeout ? FM10K_MBX_DISCONNECT_TIMEOUT : 0;\n\n\t \n\tmbx->state = FM10K_STATE_DISCONNECT;\n\n\t \n\tfm10k_write_reg(hw, mbx->mbx_reg, FM10K_MBX_REQ |\n\t\t\t\t\t  FM10K_MBX_INTERRUPT_DISABLE);\n\tdo {\n\t\tudelay(FM10K_MBX_POLL_DELAY);\n\t\tmbx->ops.process(hw, mbx);\n\t\ttimeout -= FM10K_MBX_POLL_DELAY;\n\t} while ((timeout > 0) && (mbx->state != FM10K_STATE_CLOSED));\n\n\t \n\tmbx->state = FM10K_STATE_CLOSED;\n\tmbx->remote = 0;\n\tfm10k_mbx_reset_work(mbx);\n\tfm10k_fifo_drop_all(&mbx->tx);\n\n\tfm10k_write_reg(hw, mbx->mbmem_reg, 0);\n}\n\n \nstatic s32 fm10k_sm_mbx_validate_fifo_hdr(struct fm10k_mbx_info *mbx)\n{\n\tconst u32 *hdr = &mbx->mbx_hdr;\n\tu16 tail, head, ver;\n\n\ttail = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_TAIL);\n\tver = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_VER);\n\thead = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_HEAD);\n\n\tswitch (ver) {\n\tcase 0:\n\t\tbreak;\n\tcase FM10K_SM_MBX_VERSION:\n\t\tif (!head || head > FM10K_SM_MBX_FIFO_LEN)\n\t\t\treturn FM10K_MBX_ERR_HEAD;\n\t\tif (!tail || tail > FM10K_SM_MBX_FIFO_LEN)\n\t\t\treturn FM10K_MBX_ERR_TAIL;\n\t\tif (mbx->tail < head)\n\t\t\thead += mbx->mbmem_len - 1;\n\t\tif (tail < mbx->head)\n\t\t\ttail += mbx->mbmem_len - 1;\n\t\tif (fm10k_mbx_index_len(mbx, head, mbx->tail) > mbx->tail_len)\n\t\t\treturn FM10K_MBX_ERR_HEAD;\n\t\tif (fm10k_mbx_index_len(mbx, mbx->head, tail) < mbx->mbmem_len)\n\t\t\tbreak;\n\t\treturn FM10K_MBX_ERR_TAIL;\n\tdefault:\n\t\treturn FM10K_MBX_ERR_SRC;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fm10k_sm_mbx_process_error(struct fm10k_mbx_info *mbx)\n{\n\tconst enum fm10k_mbx_state state = mbx->state;\n\n\tswitch (state) {\n\tcase FM10K_STATE_DISCONNECT:\n\t\t \n\t\tmbx->remote = 0;\n\t\tbreak;\n\tcase FM10K_STATE_OPEN:\n\t\t \n\t\tfm10k_sm_mbx_connect_reset(mbx);\n\t\tbreak;\n\tcase FM10K_STATE_CONNECT:\n\t\t \n\t\tif (mbx->remote) {\n\t\t\twhile (mbx->local > 1)\n\t\t\t\tmbx->local--;\n\t\t\tmbx->remote = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfm10k_sm_mbx_create_connect_hdr(mbx, 0);\n}\n\n \nstatic void fm10k_sm_mbx_create_error_msg(struct fm10k_mbx_info *mbx, s32 err)\n{\n\t \n\tswitch (err) {\n\tcase FM10K_MBX_ERR_TAIL:\n\tcase FM10K_MBX_ERR_HEAD:\n\tcase FM10K_MBX_ERR_SRC:\n\tcase FM10K_MBX_ERR_SIZE:\n\tcase FM10K_MBX_ERR_RSVD0:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tfm10k_sm_mbx_process_error(mbx);\n\tfm10k_sm_mbx_create_connect_hdr(mbx, 1);\n}\n\n \nstatic s32 fm10k_sm_mbx_receive(struct fm10k_hw *hw,\n\t\t\t\tstruct fm10k_mbx_info *mbx,\n\t\t\t\tu16 tail)\n{\n\t \n\tu16 mbmem_len = mbx->mbmem_len - 1;\n\ts32 err;\n\n\t \n\tif (tail < mbx->head)\n\t\ttail += mbmem_len;\n\n\t \n\terr = fm10k_mbx_push_tail(hw, mbx, tail);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfm10k_mbx_dequeue_rx(hw, mbx);\n\n\t \n\tmbx->head = fm10k_mbx_head_sub(mbx, mbx->pushed);\n\tmbx->pushed = 0;\n\n\t \n\tif (mbx->head > mbmem_len)\n\t\tmbx->head -= mbmem_len;\n\n\treturn err;\n}\n\n \nstatic void fm10k_sm_mbx_transmit(struct fm10k_hw *hw,\n\t\t\t\t  struct fm10k_mbx_info *mbx, u16 head)\n{\n\tstruct fm10k_mbx_fifo *fifo = &mbx->tx;\n\t \n\tu16 mbmem_len = mbx->mbmem_len - 1;\n\tu16 tail_len, len = 0;\n\n\t \n\tif (mbx->tail < head)\n\t\thead += mbmem_len;\n\n\tfm10k_mbx_pull_head(hw, mbx, head);\n\n\t \n\tdo {\n\t\tu32 *msg;\n\n\t\tmsg = fifo->buffer + fm10k_fifo_head_offset(fifo, len);\n\t\ttail_len = len;\n\t\tlen += FM10K_TLV_DWORD_LEN(*msg);\n\t} while ((len <= mbx->tail_len) && (len < mbmem_len));\n\n\t \n\tif (mbx->tail_len > tail_len) {\n\t\tmbx->tail = fm10k_mbx_tail_sub(mbx, mbx->tail_len - tail_len);\n\t\tmbx->tail_len = tail_len;\n\t}\n\n\t \n\tif (mbx->tail > mbmem_len)\n\t\tmbx->tail -= mbmem_len;\n}\n\n \nstatic void fm10k_sm_mbx_create_reply(struct fm10k_hw *hw,\n\t\t\t\t      struct fm10k_mbx_info *mbx, u16 head)\n{\n\tswitch (mbx->state) {\n\tcase FM10K_STATE_OPEN:\n\tcase FM10K_STATE_DISCONNECT:\n\t\t \n\t\tfm10k_sm_mbx_transmit(hw, mbx, head);\n\n\t\t \n\t\tif (mbx->tail_len || (mbx->state == FM10K_STATE_OPEN)) {\n\t\t\tfm10k_sm_mbx_create_data_hdr(mbx);\n\t\t} else {\n\t\t\tmbx->remote = 0;\n\t\t\tfm10k_sm_mbx_create_connect_hdr(mbx, 0);\n\t\t}\n\t\tbreak;\n\tcase FM10K_STATE_CONNECT:\n\tcase FM10K_STATE_CLOSED:\n\t\tfm10k_sm_mbx_create_connect_hdr(mbx, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic s32 fm10k_sm_mbx_process_reset(struct fm10k_hw *hw,\n\t\t\t\t      struct fm10k_mbx_info *mbx)\n{\n\ts32 err = 0;\n\tconst enum fm10k_mbx_state state = mbx->state;\n\n\tswitch (state) {\n\tcase FM10K_STATE_DISCONNECT:\n\t\t \n\t\tmbx->state = FM10K_STATE_CLOSED;\n\t\tmbx->remote = 0;\n\t\tmbx->local = 0;\n\t\tbreak;\n\tcase FM10K_STATE_OPEN:\n\t\t \n\t\tfm10k_sm_mbx_connect_reset(mbx);\n\t\terr = FM10K_ERR_RESET_REQUESTED;\n\t\tbreak;\n\tcase FM10K_STATE_CONNECT:\n\t\t \n\t\tmbx->remote = mbx->local;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfm10k_sm_mbx_create_reply(hw, mbx, mbx->tail);\n\n\treturn err;\n}\n\n \nstatic s32 fm10k_sm_mbx_process_version_1(struct fm10k_hw *hw,\n\t\t\t\t\t  struct fm10k_mbx_info *mbx)\n{\n\tconst u32 *hdr = &mbx->mbx_hdr;\n\tu16 head, tail;\n\ts32 len;\n\n\t \n\ttail = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_TAIL);\n\thead = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_HEAD);\n\n\t \n\tif (mbx->state == FM10K_STATE_CONNECT) {\n\t\tif (!mbx->remote)\n\t\t\tgoto send_reply;\n\t\tif (mbx->remote != 1)\n\t\t\treturn FM10K_MBX_ERR_SRC;\n\n\t\tmbx->state = FM10K_STATE_OPEN;\n\t}\n\n\tdo {\n\t\t \n\t\tlen = fm10k_sm_mbx_receive(hw, mbx, tail);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\t \n\t} while (len);\n\nsend_reply:\n\tfm10k_sm_mbx_create_reply(hw, mbx, head);\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_sm_mbx_process(struct fm10k_hw *hw,\n\t\t\t\tstruct fm10k_mbx_info *mbx)\n{\n\ts32 err;\n\n\t \n\tif (mbx->state == FM10K_STATE_CLOSED)\n\t\treturn 0;\n\n\t \n\terr = fm10k_mbx_read(hw, mbx);\n\tif (err)\n\t\treturn err;\n\n\terr = fm10k_sm_mbx_validate_fifo_hdr(mbx);\n\tif (err < 0)\n\t\tgoto fifo_err;\n\n\tif (FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, SM_ERR)) {\n\t\tfm10k_sm_mbx_process_error(mbx);\n\t\tgoto fifo_err;\n\t}\n\n\tswitch (FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, SM_VER)) {\n\tcase 0:\n\t\terr = fm10k_sm_mbx_process_reset(hw, mbx);\n\t\tbreak;\n\tcase FM10K_SM_MBX_VERSION:\n\t\terr = fm10k_sm_mbx_process_version_1(hw, mbx);\n\t\tbreak;\n\t}\n\nfifo_err:\n\tif (err < 0)\n\t\tfm10k_sm_mbx_create_error_msg(mbx, err);\n\n\t \n\tfm10k_mbx_write(hw, mbx);\n\n\treturn err;\n}\n\n \ns32 fm10k_sm_mbx_init(struct fm10k_hw __always_unused *hw,\n\t\t      struct fm10k_mbx_info *mbx,\n\t\t      const struct fm10k_msg_data *msg_data)\n{\n\tmbx->mbx_reg = FM10K_GMBX;\n\tmbx->mbmem_reg = FM10K_MBMEM_PF(0);\n\n\t \n\tmbx->state = FM10K_STATE_CLOSED;\n\n\t \n\tif (fm10k_mbx_validate_handlers(msg_data))\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tmbx->msg_data = msg_data;\n\n\t \n\tmbx->timeout = 0;\n\tmbx->udelay = FM10K_MBX_INIT_DELAY;\n\n\t \n\tmbx->max_size = FM10K_MBX_MSG_MAX_SIZE;\n\tmbx->mbmem_len = FM10K_MBMEM_PF_XOR;\n\n\t \n\tfm10k_fifo_init(&mbx->tx, mbx->buffer, FM10K_MBX_TX_BUFFER_SIZE);\n\tfm10k_fifo_init(&mbx->rx, &mbx->buffer[FM10K_MBX_TX_BUFFER_SIZE],\n\t\t\tFM10K_MBX_RX_BUFFER_SIZE);\n\n\t \n\tmbx->ops.connect = fm10k_sm_mbx_connect;\n\tmbx->ops.disconnect = fm10k_sm_mbx_disconnect;\n\tmbx->ops.rx_ready = fm10k_mbx_rx_ready;\n\tmbx->ops.tx_ready = fm10k_mbx_tx_ready;\n\tmbx->ops.tx_complete = fm10k_mbx_tx_complete;\n\tmbx->ops.enqueue_tx = fm10k_mbx_enqueue_tx;\n\tmbx->ops.process = fm10k_sm_mbx_process;\n\tmbx->ops.register_handlers = fm10k_mbx_register_handlers;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}