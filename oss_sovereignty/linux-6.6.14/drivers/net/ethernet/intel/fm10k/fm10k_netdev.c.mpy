{
  "module_name": "fm10k_netdev.c",
  "hash_id": "cbbbf276c62844c4fa6182bda59636ac55bb62febc3bea7183d6b536c68d9798",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c",
  "human_readable_source": "\n \n\n#include \"fm10k.h\"\n#include <linux/vmalloc.h>\n#include <net/udp_tunnel.h>\n#include <linux/if_macvlan.h>\n\n \nint fm10k_setup_tx_resources(struct fm10k_ring *tx_ring)\n{\n\tstruct device *dev = tx_ring->dev;\n\tint size;\n\n\tsize = sizeof(struct fm10k_tx_buffer) * tx_ring->count;\n\n\ttx_ring->tx_buffer = vzalloc(size);\n\tif (!tx_ring->tx_buffer)\n\t\tgoto err;\n\n\tu64_stats_init(&tx_ring->syncp);\n\n\t \n\ttx_ring->size = tx_ring->count * sizeof(struct fm10k_tx_desc);\n\ttx_ring->size = ALIGN(tx_ring->size, 4096);\n\n\ttx_ring->desc = dma_alloc_coherent(dev, tx_ring->size,\n\t\t\t\t\t   &tx_ring->dma, GFP_KERNEL);\n\tif (!tx_ring->desc)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tvfree(tx_ring->tx_buffer);\n\ttx_ring->tx_buffer = NULL;\n\treturn -ENOMEM;\n}\n\n \nstatic int fm10k_setup_all_tx_resources(struct fm10k_intfc *interface)\n{\n\tint i, err;\n\n\tfor (i = 0; i < interface->num_tx_queues; i++) {\n\t\terr = fm10k_setup_tx_resources(interface->tx_ring[i]);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\tnetif_err(interface, probe, interface->netdev,\n\t\t\t  \"Allocation for Tx Queue %u failed\\n\", i);\n\t\tgoto err_setup_tx;\n\t}\n\n\treturn 0;\nerr_setup_tx:\n\t \n\twhile (i--)\n\t\tfm10k_free_tx_resources(interface->tx_ring[i]);\n\treturn err;\n}\n\n \nint fm10k_setup_rx_resources(struct fm10k_ring *rx_ring)\n{\n\tstruct device *dev = rx_ring->dev;\n\tint size;\n\n\tsize = sizeof(struct fm10k_rx_buffer) * rx_ring->count;\n\n\trx_ring->rx_buffer = vzalloc(size);\n\tif (!rx_ring->rx_buffer)\n\t\tgoto err;\n\n\tu64_stats_init(&rx_ring->syncp);\n\n\t \n\trx_ring->size = rx_ring->count * sizeof(union fm10k_rx_desc);\n\trx_ring->size = ALIGN(rx_ring->size, 4096);\n\n\trx_ring->desc = dma_alloc_coherent(dev, rx_ring->size,\n\t\t\t\t\t   &rx_ring->dma, GFP_KERNEL);\n\tif (!rx_ring->desc)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tvfree(rx_ring->rx_buffer);\n\trx_ring->rx_buffer = NULL;\n\treturn -ENOMEM;\n}\n\n \nstatic int fm10k_setup_all_rx_resources(struct fm10k_intfc *interface)\n{\n\tint i, err;\n\n\tfor (i = 0; i < interface->num_rx_queues; i++) {\n\t\terr = fm10k_setup_rx_resources(interface->rx_ring[i]);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\tnetif_err(interface, probe, interface->netdev,\n\t\t\t  \"Allocation for Rx Queue %u failed\\n\", i);\n\t\tgoto err_setup_rx;\n\t}\n\n\treturn 0;\nerr_setup_rx:\n\t \n\twhile (i--)\n\t\tfm10k_free_rx_resources(interface->rx_ring[i]);\n\treturn err;\n}\n\nvoid fm10k_unmap_and_free_tx_resource(struct fm10k_ring *ring,\n\t\t\t\t      struct fm10k_tx_buffer *tx_buffer)\n{\n\tif (tx_buffer->skb) {\n\t\tdev_kfree_skb_any(tx_buffer->skb);\n\t\tif (dma_unmap_len(tx_buffer, len))\n\t\t\tdma_unmap_single(ring->dev,\n\t\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t} else if (dma_unmap_len(tx_buffer, len)) {\n\t\tdma_unmap_page(ring->dev,\n\t\t\t       dma_unmap_addr(tx_buffer, dma),\n\t\t\t       dma_unmap_len(tx_buffer, len),\n\t\t\t       DMA_TO_DEVICE);\n\t}\n\ttx_buffer->next_to_watch = NULL;\n\ttx_buffer->skb = NULL;\n\tdma_unmap_len_set(tx_buffer, len, 0);\n\t \n}\n\n \nstatic void fm10k_clean_tx_ring(struct fm10k_ring *tx_ring)\n{\n\tunsigned long size;\n\tu16 i;\n\n\t \n\tif (!tx_ring->tx_buffer)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < tx_ring->count; i++) {\n\t\tstruct fm10k_tx_buffer *tx_buffer = &tx_ring->tx_buffer[i];\n\n\t\tfm10k_unmap_and_free_tx_resource(tx_ring, tx_buffer);\n\t}\n\n\t \n\tnetdev_tx_reset_queue(txring_txq(tx_ring));\n\n\tsize = sizeof(struct fm10k_tx_buffer) * tx_ring->count;\n\tmemset(tx_ring->tx_buffer, 0, size);\n\n\t \n\tmemset(tx_ring->desc, 0, tx_ring->size);\n}\n\n \nvoid fm10k_free_tx_resources(struct fm10k_ring *tx_ring)\n{\n\tfm10k_clean_tx_ring(tx_ring);\n\n\tvfree(tx_ring->tx_buffer);\n\ttx_ring->tx_buffer = NULL;\n\n\t \n\tif (!tx_ring->desc)\n\t\treturn;\n\n\tdma_free_coherent(tx_ring->dev, tx_ring->size,\n\t\t\t  tx_ring->desc, tx_ring->dma);\n\ttx_ring->desc = NULL;\n}\n\n \nvoid fm10k_clean_all_tx_rings(struct fm10k_intfc *interface)\n{\n\tint i;\n\n\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\tfm10k_clean_tx_ring(interface->tx_ring[i]);\n}\n\n \nstatic void fm10k_free_all_tx_resources(struct fm10k_intfc *interface)\n{\n\tint i = interface->num_tx_queues;\n\n\twhile (i--)\n\t\tfm10k_free_tx_resources(interface->tx_ring[i]);\n}\n\n \nstatic void fm10k_clean_rx_ring(struct fm10k_ring *rx_ring)\n{\n\tunsigned long size;\n\tu16 i;\n\n\tif (!rx_ring->rx_buffer)\n\t\treturn;\n\n\tdev_kfree_skb(rx_ring->skb);\n\trx_ring->skb = NULL;\n\n\t \n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tstruct fm10k_rx_buffer *buffer = &rx_ring->rx_buffer[i];\n\t\t \n\t\tif (!buffer->page)\n\t\t\tcontinue;\n\n\t\tdma_unmap_page(rx_ring->dev, buffer->dma,\n\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t__free_page(buffer->page);\n\n\t\tbuffer->page = NULL;\n\t}\n\n\tsize = sizeof(struct fm10k_rx_buffer) * rx_ring->count;\n\tmemset(rx_ring->rx_buffer, 0, size);\n\n\t \n\tmemset(rx_ring->desc, 0, rx_ring->size);\n\n\trx_ring->next_to_alloc = 0;\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n}\n\n \nvoid fm10k_free_rx_resources(struct fm10k_ring *rx_ring)\n{\n\tfm10k_clean_rx_ring(rx_ring);\n\n\tvfree(rx_ring->rx_buffer);\n\trx_ring->rx_buffer = NULL;\n\n\t \n\tif (!rx_ring->desc)\n\t\treturn;\n\n\tdma_free_coherent(rx_ring->dev, rx_ring->size,\n\t\t\t  rx_ring->desc, rx_ring->dma);\n\n\trx_ring->desc = NULL;\n}\n\n \nvoid fm10k_clean_all_rx_rings(struct fm10k_intfc *interface)\n{\n\tint i;\n\n\tfor (i = 0; i < interface->num_rx_queues; i++)\n\t\tfm10k_clean_rx_ring(interface->rx_ring[i]);\n}\n\n \nstatic void fm10k_free_all_rx_resources(struct fm10k_intfc *interface)\n{\n\tint i = interface->num_rx_queues;\n\n\twhile (i--)\n\t\tfm10k_free_rx_resources(interface->rx_ring[i]);\n}\n\n \nstatic void fm10k_request_glort_range(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu16 mask = (~hw->mac.dglort_map) >> FM10K_DGLORTMAP_MASK_SHIFT;\n\n\t \n\tinterface->glort = hw->mac.dglort_map & FM10K_DGLORTMAP_NONE;\n\tinterface->glort_count = 0;\n\n\t \n\tif (hw->mac.dglort_map == FM10K_DGLORTMAP_NONE)\n\t\treturn;\n\n\t \n\tif (mask <= hw->iov.total_vfs) {\n\t\tinterface->glort_count = 1;\n\t\tinterface->glort += mask;\n\t} else if (mask < 64) {\n\t\tinterface->glort_count = (mask + 1) / 2;\n\t\tinterface->glort += interface->glort_count;\n\t} else {\n\t\tinterface->glort_count = mask - 63;\n\t\tinterface->glort += 64;\n\t}\n}\n\n \nstatic void fm10k_restore_udp_port_info(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\t \n\tif (hw->mac.type != fm10k_mac_pf)\n\t\treturn;\n\n\t \n\tfm10k_write_reg(hw, FM10K_TUNNEL_CFG,\n\t\t\tntohs(interface->vxlan_port) |\n\t\t\t(ETH_P_TEB << FM10K_TUNNEL_CFG_NVGRE_SHIFT));\n\n\t \n\tfm10k_write_reg(hw, FM10K_TUNNEL_CFG_GENEVE,\n\t\t\tntohs(interface->geneve_port));\n}\n\n \nstatic int fm10k_udp_tunnel_sync(struct net_device *dev, unsigned int table)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct udp_tunnel_info ti;\n\n\tudp_tunnel_nic_get_port(dev, table, 0, &ti);\n\tif (!table)\n\t\tinterface->vxlan_port = ti.port;\n\telse\n\t\tinterface->geneve_port = ti.port;\n\n\tfm10k_restore_udp_port_info(interface);\n\treturn 0;\n}\n\nstatic const struct udp_tunnel_nic_info fm10k_udp_tunnels = {\n\t.sync_table\t= fm10k_udp_tunnel_sync,\n\t.tables\t\t= {\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN,  },\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_GENEVE, },\n\t},\n};\n\n \nint fm10k_open(struct net_device *netdev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tint err;\n\n\t \n\terr = fm10k_setup_all_tx_resources(interface);\n\tif (err)\n\t\tgoto err_setup_tx;\n\n\t \n\terr = fm10k_setup_all_rx_resources(interface);\n\tif (err)\n\t\tgoto err_setup_rx;\n\n\t \n\terr = fm10k_qv_request_irq(interface);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\t \n\tfm10k_request_glort_range(interface);\n\n\t \n\terr = netif_set_real_num_tx_queues(netdev,\n\t\t\t\t\t   interface->num_tx_queues);\n\tif (err)\n\t\tgoto err_set_queues;\n\n\terr = netif_set_real_num_rx_queues(netdev,\n\t\t\t\t\t   interface->num_rx_queues);\n\tif (err)\n\t\tgoto err_set_queues;\n\n\tfm10k_up(interface);\n\n\treturn 0;\n\nerr_set_queues:\n\tfm10k_qv_free_irq(interface);\nerr_req_irq:\n\tfm10k_free_all_rx_resources(interface);\nerr_setup_rx:\n\tfm10k_free_all_tx_resources(interface);\nerr_setup_tx:\n\treturn err;\n}\n\n \nint fm10k_close(struct net_device *netdev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\n\tfm10k_down(interface);\n\n\tfm10k_qv_free_irq(interface);\n\n\tfm10k_free_all_tx_resources(interface);\n\tfm10k_free_all_rx_resources(interface);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t fm10k_xmit_frame(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tint num_tx_queues = READ_ONCE(interface->num_tx_queues);\n\tunsigned int r_idx = skb->queue_mapping;\n\tint err;\n\n\tif (!num_tx_queues)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif ((skb->protocol == htons(ETH_P_8021Q)) &&\n\t    !skb_vlan_tag_present(skb)) {\n\t\t \n\t\tstruct vlan_hdr *vhdr;\n\t\t__be16 proto;\n\n\t\t \n\t\tskb = skb_share_check(skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NETDEV_TX_OK;\n\n\t\t \n\t\tif (unlikely(!pskb_may_pull(skb, VLAN_ETH_HLEN)))\n\t\t\treturn NETDEV_TX_OK;\n\n\t\t \n\t\terr = skb_cow_head(skb, 0);\n\t\tif (err) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\n\t\t \n\t\tvhdr = (struct vlan_hdr *)(skb->data + ETH_HLEN);\n\n\t\t \n\t\t__vlan_hwaccel_put_tag(skb,\n\t\t\t\t       htons(ETH_P_8021Q),\n\t\t\t\t       ntohs(vhdr->h_vlan_TCI));\n\t\tproto = vhdr->h_vlan_encapsulated_proto;\n\t\tskb->protocol = (ntohs(proto) >= 1536) ? proto :\n\t\t\t\t\t\t\t htons(ETH_P_802_2);\n\n\t\t \n\t\tmemmove(skb->data + VLAN_HLEN, skb->data, 12);\n\t\t__skb_pull(skb, VLAN_HLEN);\n\t\tskb_reset_mac_header(skb);\n\t}\n\n\t \n\tif (unlikely(skb->len < 17)) {\n\t\tint pad_len = 17 - skb->len;\n\n\t\tif (skb_pad(skb, pad_len))\n\t\t\treturn NETDEV_TX_OK;\n\t\t__skb_put(skb, pad_len);\n\t}\n\n\tif (r_idx >= num_tx_queues)\n\t\tr_idx %= num_tx_queues;\n\n\terr = fm10k_xmit_frame_ring(skb, interface->tx_ring[r_idx]);\n\n\treturn err;\n}\n\n \nstatic void fm10k_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_ring *tx_ring;\n\tbool real_tx_hang = false;\n\n\tif (txqueue >= interface->num_tx_queues) {\n\t\tWARN(1, \"invalid Tx queue index %d\", txqueue);\n\t\treturn;\n\t}\n\n\ttx_ring = interface->tx_ring[txqueue];\n\tif (check_for_tx_hang(tx_ring) && fm10k_check_tx_hang(tx_ring))\n\t\treal_tx_hang = true;\n\n#define TX_TIMEO_LIMIT 16000\n\tif (real_tx_hang) {\n\t\tfm10k_tx_timeout_reset(interface);\n\t} else {\n\t\tnetif_info(interface, drv, netdev,\n\t\t\t   \"Fake Tx hang detected with timeout of %d seconds\\n\",\n\t\t\t   netdev->watchdog_timeo / HZ);\n\n\t\t \n\t\tif (netdev->watchdog_timeo < TX_TIMEO_LIMIT)\n\t\t\tnetdev->watchdog_timeo *= 2;\n\t}\n}\n\n \nstatic bool fm10k_host_mbx_ready(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\treturn (hw->mac.type == fm10k_mac_vf || interface->host_ready);\n}\n\n \nint fm10k_queue_vlan_request(struct fm10k_intfc *interface,\n\t\t\t     u32 vid, u8 vsi, bool set)\n{\n\tstruct fm10k_macvlan_request *request;\n\tunsigned long flags;\n\n\t \n\trequest = kzalloc(sizeof(*request), GFP_ATOMIC);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->type = FM10K_VLAN_REQUEST;\n\trequest->vlan.vid = vid;\n\trequest->vlan.vsi = vsi;\n\trequest->set = set;\n\n\tspin_lock_irqsave(&interface->macvlan_lock, flags);\n\tlist_add_tail(&request->list, &interface->macvlan_requests);\n\tspin_unlock_irqrestore(&interface->macvlan_lock, flags);\n\n\tfm10k_macvlan_schedule(interface);\n\n\treturn 0;\n}\n\n \nint fm10k_queue_mac_request(struct fm10k_intfc *interface, u16 glort,\n\t\t\t    const unsigned char *addr, u16 vid, bool set)\n{\n\tstruct fm10k_macvlan_request *request;\n\tunsigned long flags;\n\n\t \n\trequest = kzalloc(sizeof(*request), GFP_ATOMIC);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (is_multicast_ether_addr(addr))\n\t\trequest->type = FM10K_MC_MAC_REQUEST;\n\telse\n\t\trequest->type = FM10K_UC_MAC_REQUEST;\n\n\tether_addr_copy(request->mac.addr, addr);\n\trequest->mac.glort = glort;\n\trequest->mac.vid = vid;\n\trequest->set = set;\n\n\tspin_lock_irqsave(&interface->macvlan_lock, flags);\n\tlist_add_tail(&request->list, &interface->macvlan_requests);\n\tspin_unlock_irqrestore(&interface->macvlan_lock, flags);\n\n\tfm10k_macvlan_schedule(interface);\n\n\treturn 0;\n}\n\n \nvoid fm10k_clear_macvlan_queue(struct fm10k_intfc *interface,\n\t\t\t       u16 glort, bool vlans)\n\n{\n\tstruct fm10k_macvlan_request *r, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&interface->macvlan_lock, flags);\n\n\t \n\tlist_for_each_entry_safe(r, tmp, &interface->macvlan_requests, list) {\n\t\tswitch (r->type) {\n\t\tcase FM10K_MC_MAC_REQUEST:\n\t\tcase FM10K_UC_MAC_REQUEST:\n\t\t\t \n\t\t\tif (r->mac.glort != glort)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase FM10K_VLAN_REQUEST:\n\t\t\tif (vlans) {\n\t\t\t\tlist_del(&r->list);\n\t\t\t\tkfree(r);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&interface->macvlan_lock, flags);\n}\n\nstatic int fm10k_uc_vlan_unsync(struct net_device *netdev,\n\t\t\t\tconst unsigned char *uc_addr)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tu16 glort = interface->glort;\n\tu16 vid = interface->vid;\n\tbool set = !!(vid / VLAN_N_VID);\n\tint err;\n\n\t \n\tvid &= VLAN_N_VID - 1;\n\n\terr = fm10k_queue_mac_request(interface, glort, uc_addr, vid, set);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn 1;\n}\n\nstatic int fm10k_mc_vlan_unsync(struct net_device *netdev,\n\t\t\t\tconst unsigned char *mc_addr)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tu16 glort = interface->glort;\n\tu16 vid = interface->vid;\n\tbool set = !!(vid / VLAN_N_VID);\n\tint err;\n\n\t \n\tvid &= VLAN_N_VID - 1;\n\n\terr = fm10k_queue_mac_request(interface, glort, mc_addr, vid, set);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn 1;\n}\n\nstatic int fm10k_update_vid(struct net_device *netdev, u16 vid, bool set)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_l2_accel *l2_accel = interface->l2_accel;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu16 glort;\n\ts32 err;\n\tint i;\n\n\t \n\tif (!vid)\n\t\treturn 0;\n\n\tif (vid >= VLAN_N_VID)\n\t\treturn -EINVAL;\n\n\t \n\tif (set && hw->mac.vlan_override)\n\t\treturn -EACCES;\n\n\t \n\tset_bit(vid, interface->active_vlans);\n\tif (!set)\n\t\tclear_bit(vid, interface->active_vlans);\n\n\t \n\tfor (i = 0; i < interface->num_rx_queues; i++) {\n\t\tstruct fm10k_ring *rx_ring = interface->rx_ring[i];\n\t\tu16 rx_vid = rx_ring->vid & (VLAN_N_VID - 1);\n\n\t\tif (test_bit(rx_vid, interface->active_vlans))\n\t\t\trx_ring->vid |= FM10K_VLAN_CLEAR;\n\t\telse\n\t\t\trx_ring->vid &= ~FM10K_VLAN_CLEAR;\n\t}\n\n\t \n\tif (hw->mac.vlan_override)\n\t\treturn 0;\n\n\t \n\tif (!set && vid == hw->mac.default_vid)\n\t\treturn 0;\n\n\t \n\tif (test_bit(__FM10K_DOWN, interface->state))\n\t\treturn 0;\n\n\tfm10k_mbx_lock(interface);\n\n\t \n\tif (!(netdev->flags & IFF_PROMISC)) {\n\t\terr = fm10k_queue_vlan_request(interface, vid, 0, set);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\t \n\terr = fm10k_queue_mac_request(interface, interface->glort,\n\t\t\t\t      hw->mac.addr, vid, set);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tif (l2_accel) {\n\t\tfor (i = 0; i < l2_accel->size; i++) {\n\t\t\tstruct net_device *sdev = l2_accel->macvlan[i];\n\n\t\t\tif (!sdev)\n\t\t\t\tcontinue;\n\n\t\t\tglort = l2_accel->dglort + 1 + i;\n\n\t\t\tfm10k_queue_mac_request(interface, glort,\n\t\t\t\t\t\tsdev->dev_addr,\n\t\t\t\t\t\tvid, set);\n\t\t}\n\t}\n\n\t \n\tinterface->vid = vid + (set ? VLAN_N_VID : 0);\n\n\t \n\t__dev_uc_unsync(netdev, fm10k_uc_vlan_unsync);\n\t__dev_mc_unsync(netdev, fm10k_mc_vlan_unsync);\n\nerr_out:\n\tfm10k_mbx_unlock(interface);\n\n\treturn err;\n}\n\nstatic int fm10k_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t __always_unused __be16 proto, u16 vid)\n{\n\t \n\treturn fm10k_update_vid(netdev, vid, true);\n}\n\nstatic int fm10k_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t  __always_unused __be16 proto, u16 vid)\n{\n\t \n\treturn fm10k_update_vid(netdev, vid, false);\n}\n\nstatic u16 fm10k_find_next_vlan(struct fm10k_intfc *interface, u16 vid)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu16 default_vid = hw->mac.default_vid;\n\tu16 vid_limit = vid < default_vid ? default_vid : VLAN_N_VID;\n\n\tvid = find_next_bit(interface->active_vlans, vid_limit, ++vid);\n\n\treturn vid;\n}\n\nstatic void fm10k_clear_unused_vlans(struct fm10k_intfc *interface)\n{\n\tu32 vid, prev_vid;\n\n\t \n\tfor (vid = 0, prev_vid = 0;\n\t     prev_vid < VLAN_N_VID;\n\t     prev_vid = vid + 1, vid = fm10k_find_next_vlan(interface, vid)) {\n\t\tif (prev_vid == vid)\n\t\t\tcontinue;\n\n\t\t \n\t\tprev_vid += (vid - prev_vid - 1) << FM10K_VLAN_LENGTH_SHIFT;\n\t\tfm10k_queue_vlan_request(interface, prev_vid, 0, false);\n\t}\n}\n\nstatic int __fm10k_uc_sync(struct net_device *dev,\n\t\t\t   const unsigned char *addr, bool sync)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tu16 vid, glort = interface->glort;\n\ts32 err;\n\n\tif (!is_valid_ether_addr(addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tfor (vid = fm10k_find_next_vlan(interface, 0);\n\t     vid < VLAN_N_VID;\n\t     vid = fm10k_find_next_vlan(interface, vid)) {\n\t\terr = fm10k_queue_mac_request(interface, glort,\n\t\t\t\t\t      addr, vid, sync);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int fm10k_uc_sync(struct net_device *dev,\n\t\t\t const unsigned char *addr)\n{\n\treturn __fm10k_uc_sync(dev, addr, true);\n}\n\nstatic int fm10k_uc_unsync(struct net_device *dev,\n\t\t\t   const unsigned char *addr)\n{\n\treturn __fm10k_uc_sync(dev, addr, false);\n}\n\nstatic int fm10k_set_mac(struct net_device *dev, void *p)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct sockaddr *addr = p;\n\ts32 err = 0;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (dev->flags & IFF_UP) {\n\t\t \n\t\tfm10k_mbx_lock(interface);\n\n\t\terr = fm10k_uc_sync(dev, addr->sa_data);\n\t\tif (!err)\n\t\t\tfm10k_uc_unsync(dev, hw->mac.addr);\n\n\t\tfm10k_mbx_unlock(interface);\n\t}\n\n\tif (!err) {\n\t\teth_hw_addr_set(dev, addr->sa_data);\n\t\tether_addr_copy(hw->mac.addr, addr->sa_data);\n\t\tdev->addr_assign_type &= ~NET_ADDR_RANDOM;\n\t}\n\n\t \n\treturn err ? -EAGAIN : 0;\n}\n\nstatic int __fm10k_mc_sync(struct net_device *dev,\n\t\t\t   const unsigned char *addr, bool sync)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tu16 vid, glort = interface->glort;\n\ts32 err;\n\n\tif (!is_multicast_ether_addr(addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tfor (vid = fm10k_find_next_vlan(interface, 0);\n\t     vid < VLAN_N_VID;\n\t     vid = fm10k_find_next_vlan(interface, vid)) {\n\t\terr = fm10k_queue_mac_request(interface, glort,\n\t\t\t\t\t      addr, vid, sync);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int fm10k_mc_sync(struct net_device *dev,\n\t\t\t const unsigned char *addr)\n{\n\treturn __fm10k_mc_sync(dev, addr, true);\n}\n\nstatic int fm10k_mc_unsync(struct net_device *dev,\n\t\t\t   const unsigned char *addr)\n{\n\treturn __fm10k_mc_sync(dev, addr, false);\n}\n\nstatic void fm10k_set_rx_mode(struct net_device *dev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint xcast_mode;\n\n\t \n\tif (!(dev->flags & IFF_UP))\n\t\treturn;\n\n\t \n\txcast_mode = (dev->flags & IFF_PROMISC) ? FM10K_XCAST_MODE_PROMISC :\n\t\t     (dev->flags & IFF_ALLMULTI) ? FM10K_XCAST_MODE_ALLMULTI :\n\t\t     (dev->flags & (IFF_BROADCAST | IFF_MULTICAST)) ?\n\t\t     FM10K_XCAST_MODE_MULTI : FM10K_XCAST_MODE_NONE;\n\n\tfm10k_mbx_lock(interface);\n\n\t \n\tif (interface->xcast_mode != xcast_mode) {\n\t\t \n\t\tif (xcast_mode == FM10K_XCAST_MODE_PROMISC)\n\t\t\tfm10k_queue_vlan_request(interface, FM10K_VLAN_ALL,\n\t\t\t\t\t\t 0, true);\n\n\t\t \n\t\tif (interface->xcast_mode == FM10K_XCAST_MODE_PROMISC)\n\t\t\tfm10k_clear_unused_vlans(interface);\n\n\t\t \n\t\tif (fm10k_host_mbx_ready(interface))\n\t\t\thw->mac.ops.update_xcast_mode(hw, interface->glort,\n\t\t\t\t\t\t      xcast_mode);\n\n\t\t \n\t\tinterface->xcast_mode = xcast_mode;\n\t}\n\n\t \n\t__dev_uc_sync(dev, fm10k_uc_sync, fm10k_uc_unsync);\n\t__dev_mc_sync(dev, fm10k_mc_sync, fm10k_mc_unsync);\n\n\tfm10k_mbx_unlock(interface);\n}\n\nvoid fm10k_restore_rx_state(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_l2_accel *l2_accel = interface->l2_accel;\n\tstruct net_device *netdev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint xcast_mode, i;\n\tu16 vid, glort;\n\n\t \n\tglort = interface->glort;\n\n\t \n\tif (netdev->flags & IFF_PROMISC)\n\t\txcast_mode = FM10K_XCAST_MODE_PROMISC;\n\telse if (netdev->flags & IFF_ALLMULTI)\n\t\txcast_mode = FM10K_XCAST_MODE_ALLMULTI;\n\telse if (netdev->flags & (IFF_BROADCAST | IFF_MULTICAST))\n\t\txcast_mode = FM10K_XCAST_MODE_MULTI;\n\telse\n\t\txcast_mode = FM10K_XCAST_MODE_NONE;\n\n\tfm10k_mbx_lock(interface);\n\n\t \n\tif (fm10k_host_mbx_ready(interface))\n\t\thw->mac.ops.update_lport_state(hw, glort,\n\t\t\t\t\t       interface->glort_count, true);\n\n\t \n\tfm10k_queue_vlan_request(interface, FM10K_VLAN_ALL, 0,\n\t\t\t\t xcast_mode == FM10K_XCAST_MODE_PROMISC);\n\n\t \n\tfor (vid = fm10k_find_next_vlan(interface, 0);\n\t     vid < VLAN_N_VID;\n\t     vid = fm10k_find_next_vlan(interface, vid)) {\n\t\tfm10k_queue_vlan_request(interface, vid, 0, true);\n\n\t\tfm10k_queue_mac_request(interface, glort,\n\t\t\t\t\thw->mac.addr, vid, true);\n\n\t\t \n\t\tif (l2_accel) {\n\t\t\tfor (i = 0; i < l2_accel->size; i++) {\n\t\t\t\tstruct net_device *sdev = l2_accel->macvlan[i];\n\n\t\t\t\tif (!sdev)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tglort = l2_accel->dglort + 1 + i;\n\n\t\t\t\tfm10k_queue_mac_request(interface, glort,\n\t\t\t\t\t\t\tsdev->dev_addr,\n\t\t\t\t\t\t\tvid, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (fm10k_host_mbx_ready(interface))\n\t\thw->mac.ops.update_xcast_mode(hw, glort, xcast_mode);\n\n\t \n\t__dev_uc_sync(netdev, fm10k_uc_sync, fm10k_uc_unsync);\n\t__dev_mc_sync(netdev, fm10k_mc_sync, fm10k_mc_unsync);\n\n\t \n\tif (l2_accel) {\n\t\tfor (i = 0; i < l2_accel->size; i++) {\n\t\t\tstruct net_device *sdev = l2_accel->macvlan[i];\n\n\t\t\tif (!sdev)\n\t\t\t\tcontinue;\n\n\t\t\tglort = l2_accel->dglort + 1 + i;\n\n\t\t\thw->mac.ops.update_xcast_mode(hw, glort,\n\t\t\t\t\t\t      FM10K_XCAST_MODE_NONE);\n\t\t\tfm10k_queue_mac_request(interface, glort,\n\t\t\t\t\t\tsdev->dev_addr,\n\t\t\t\t\t\thw->mac.default_vid, true);\n\t\t}\n\t}\n\n\tfm10k_mbx_unlock(interface);\n\n\t \n\tinterface->xcast_mode = xcast_mode;\n\n\t \n\tfm10k_restore_udp_port_info(interface);\n}\n\nvoid fm10k_reset_rx_state(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\t \n\twhile (test_bit(__FM10K_MACVLAN_SCHED, interface->state))\n\t\tusleep_range(1000, 2000);\n\n\t \n\tfm10k_clear_macvlan_queue(interface, interface->glort, true);\n\n\tfm10k_mbx_lock(interface);\n\n\t \n\tif (fm10k_host_mbx_ready(interface))\n\t\thw->mac.ops.update_lport_state(hw, interface->glort,\n\t\t\t\t\t       interface->glort_count, false);\n\n\tfm10k_mbx_unlock(interface);\n\n\t \n\tinterface->xcast_mode = FM10K_XCAST_MODE_NONE;\n\n\t \n\t__dev_uc_unsync(netdev, NULL);\n\t__dev_mc_unsync(netdev, NULL);\n}\n\n \nstatic void fm10k_get_stats64(struct net_device *netdev,\n\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_ring *ring;\n\tunsigned int start, i;\n\tu64 bytes, packets;\n\n\trcu_read_lock();\n\n\tfor (i = 0; i < interface->num_rx_queues; i++) {\n\t\tring = READ_ONCE(interface->rx_ring[i]);\n\n\t\tif (!ring)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\t\tpackets = ring->stats.packets;\n\t\t\tbytes   = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n\n\t\tstats->rx_packets += packets;\n\t\tstats->rx_bytes   += bytes;\n\t}\n\n\tfor (i = 0; i < interface->num_tx_queues; i++) {\n\t\tring = READ_ONCE(interface->tx_ring[i]);\n\n\t\tif (!ring)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\t\tpackets = ring->stats.packets;\n\t\t\tbytes   = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n\n\t\tstats->tx_packets += packets;\n\t\tstats->tx_bytes   += bytes;\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tstats->rx_missed_errors\t= netdev->stats.rx_missed_errors;\n}\n\nint fm10k_setup_tc(struct net_device *dev, u8 tc)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tint err;\n\n\t \n\tif (tc && (interface->hw.mac.type != fm10k_mac_pf))\n\t\treturn -EINVAL;\n\n\t \n\tif (tc > 8)\n\t\treturn -EINVAL;\n\n\t \n\tif (netif_running(dev))\n\t\tfm10k_close(dev);\n\n\tfm10k_mbx_free_irq(interface);\n\n\tfm10k_clear_queueing_scheme(interface);\n\n\t \n\tnetdev_reset_tc(dev);\n\tnetdev_set_num_tc(dev, tc);\n\n\terr = fm10k_init_queueing_scheme(interface);\n\tif (err)\n\t\tgoto err_queueing_scheme;\n\n\terr = fm10k_mbx_request_irq(interface);\n\tif (err)\n\t\tgoto err_mbx_irq;\n\n\terr = netif_running(dev) ? fm10k_open(dev) : 0;\n\tif (err)\n\t\tgoto err_open;\n\n\t \n\tset_bit(FM10K_FLAG_SWPRI_CONFIG, interface->flags);\n\n\treturn 0;\nerr_open:\n\tfm10k_mbx_free_irq(interface);\nerr_mbx_irq:\n\tfm10k_clear_queueing_scheme(interface);\nerr_queueing_scheme:\n\tnetif_device_detach(dev);\n\n\treturn err;\n}\n\nstatic int __fm10k_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t    void *type_data)\n{\n\tstruct tc_mqprio_qopt *mqprio = type_data;\n\n\tif (type != TC_SETUP_QDISC_MQPRIO)\n\t\treturn -EOPNOTSUPP;\n\n\tmqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;\n\n\treturn fm10k_setup_tc(dev, mqprio->num_tc);\n}\n\nstatic void fm10k_assign_l2_accel(struct fm10k_intfc *interface,\n\t\t\t\t  struct fm10k_l2_accel *l2_accel)\n{\n\tint i;\n\n\tfor (i = 0; i < interface->num_rx_queues; i++) {\n\t\tstruct fm10k_ring *ring = interface->rx_ring[i];\n\n\t\trcu_assign_pointer(ring->l2_accel, l2_accel);\n\t}\n\n\tinterface->l2_accel = l2_accel;\n}\n\nstatic void *fm10k_dfwd_add_station(struct net_device *dev,\n\t\t\t\t    struct net_device *sdev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_l2_accel *l2_accel = interface->l2_accel;\n\tstruct fm10k_l2_accel *old_l2_accel = NULL;\n\tstruct fm10k_dglort_cfg dglort = { 0 };\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint size, i;\n\tu16 vid, glort;\n\n\t \n\tif (!macvlan_supports_dest_filter(sdev))\n\t\treturn ERR_PTR(-EMEDIUMTYPE);\n\n\t \n\tif (!l2_accel) {\n\t\t \n\t\tif (interface->glort_count < 7)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tsize = offsetof(struct fm10k_l2_accel, macvlan[7]);\n\t\tl2_accel = kzalloc(size, GFP_KERNEL);\n\t\tif (!l2_accel)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tl2_accel->size = 7;\n\t\tl2_accel->dglort = interface->glort;\n\n\t\t \n\t\tfm10k_assign_l2_accel(interface, l2_accel);\n\t \n\t} else if ((l2_accel->count == FM10K_MAX_STATIONS) ||\n\t\t   (l2_accel->count == (interface->glort_count - 1))) {\n\t\treturn ERR_PTR(-EBUSY);\n\t \n\t} else if (l2_accel->count == l2_accel->size) {\n\t\told_l2_accel = l2_accel;\n\t\tsize = offsetof(struct fm10k_l2_accel,\n\t\t\t\tmacvlan[(l2_accel->size * 2) + 1]);\n\t\tl2_accel = kzalloc(size, GFP_KERNEL);\n\t\tif (!l2_accel)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmemcpy(l2_accel, old_l2_accel,\n\t\t       offsetof(struct fm10k_l2_accel,\n\t\t\t\tmacvlan[old_l2_accel->size]));\n\n\t\tl2_accel->size = (old_l2_accel->size * 2) + 1;\n\n\t\t \n\t\tfm10k_assign_l2_accel(interface, l2_accel);\n\t\tkfree_rcu(old_l2_accel, rcu);\n\t}\n\n\t \n\tfor (i = 0; i < l2_accel->size; i++) {\n\t\tif (!l2_accel->macvlan[i])\n\t\t\tbreak;\n\t}\n\n\t \n\tl2_accel->macvlan[i] = sdev;\n\tl2_accel->count++;\n\n\t \n\tdglort.idx = fm10k_dglort_pf_rss;\n\tdglort.inner_rss = 1;\n\tdglort.rss_l = fls(interface->ring_feature[RING_F_RSS].mask);\n\tdglort.pc_l = fls(interface->ring_feature[RING_F_QOS].mask);\n\tdglort.glort = interface->glort;\n\tdglort.shared_l = fls(l2_accel->size);\n\thw->mac.ops.configure_dglort_map(hw, &dglort);\n\n\t \n\tfm10k_mbx_lock(interface);\n\n\tglort = l2_accel->dglort + 1 + i;\n\n\tif (fm10k_host_mbx_ready(interface))\n\t\thw->mac.ops.update_xcast_mode(hw, glort,\n\t\t\t\t\t      FM10K_XCAST_MODE_NONE);\n\n\tfm10k_queue_mac_request(interface, glort, sdev->dev_addr,\n\t\t\t\thw->mac.default_vid, true);\n\n\tfor (vid = fm10k_find_next_vlan(interface, 0);\n\t     vid < VLAN_N_VID;\n\t     vid = fm10k_find_next_vlan(interface, vid))\n\t\tfm10k_queue_mac_request(interface, glort, sdev->dev_addr,\n\t\t\t\t\tvid, true);\n\n\tfm10k_mbx_unlock(interface);\n\n\treturn sdev;\n}\n\nstatic void fm10k_dfwd_del_station(struct net_device *dev, void *priv)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_l2_accel *l2_accel = READ_ONCE(interface->l2_accel);\n\tstruct fm10k_dglort_cfg dglort = { 0 };\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct net_device *sdev = priv;\n\tu16 vid, glort;\n\tint i;\n\n\tif (!l2_accel)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < l2_accel->size; i++) {\n\t\tif (l2_accel->macvlan[i] == sdev)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == l2_accel->size)\n\t\treturn;\n\n\t \n\tfm10k_mbx_lock(interface);\n\n\tglort = l2_accel->dglort + 1 + i;\n\n\tif (fm10k_host_mbx_ready(interface))\n\t\thw->mac.ops.update_xcast_mode(hw, glort,\n\t\t\t\t\t      FM10K_XCAST_MODE_NONE);\n\n\tfm10k_queue_mac_request(interface, glort, sdev->dev_addr,\n\t\t\t\thw->mac.default_vid, false);\n\n\tfor (vid = fm10k_find_next_vlan(interface, 0);\n\t     vid < VLAN_N_VID;\n\t     vid = fm10k_find_next_vlan(interface, vid))\n\t\tfm10k_queue_mac_request(interface, glort, sdev->dev_addr,\n\t\t\t\t\tvid, false);\n\n\tfm10k_mbx_unlock(interface);\n\n\t \n\tl2_accel->macvlan[i] = NULL;\n\tl2_accel->count--;\n\n\t \n\tdglort.idx = fm10k_dglort_pf_rss;\n\tdglort.inner_rss = 1;\n\tdglort.rss_l = fls(interface->ring_feature[RING_F_RSS].mask);\n\tdglort.pc_l = fls(interface->ring_feature[RING_F_QOS].mask);\n\tdglort.glort = interface->glort;\n\tdglort.shared_l = fls(l2_accel->size);\n\thw->mac.ops.configure_dglort_map(hw, &dglort);\n\n\t \n\tif (l2_accel->count == 0) {\n\t\tfm10k_assign_l2_accel(interface, NULL);\n\t\tkfree_rcu(l2_accel, rcu);\n\t}\n}\n\nstatic netdev_features_t fm10k_features_check(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tif (!skb->encapsulation || fm10k_tx_encap_offload(skb))\n\t\treturn features;\n\n\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n}\n\nstatic const struct net_device_ops fm10k_netdev_ops = {\n\t.ndo_open\t\t= fm10k_open,\n\t.ndo_stop\t\t= fm10k_close,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_start_xmit\t\t= fm10k_xmit_frame,\n\t.ndo_set_mac_address\t= fm10k_set_mac,\n\t.ndo_tx_timeout\t\t= fm10k_tx_timeout,\n\t.ndo_vlan_rx_add_vid\t= fm10k_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= fm10k_vlan_rx_kill_vid,\n\t.ndo_set_rx_mode\t= fm10k_set_rx_mode,\n\t.ndo_get_stats64\t= fm10k_get_stats64,\n\t.ndo_setup_tc\t\t= __fm10k_setup_tc,\n\t.ndo_set_vf_mac\t\t= fm10k_ndo_set_vf_mac,\n\t.ndo_set_vf_vlan\t= fm10k_ndo_set_vf_vlan,\n\t.ndo_set_vf_rate\t= fm10k_ndo_set_vf_bw,\n\t.ndo_get_vf_config\t= fm10k_ndo_get_vf_config,\n\t.ndo_get_vf_stats\t= fm10k_ndo_get_vf_stats,\n\t.ndo_dfwd_add_station\t= fm10k_dfwd_add_station,\n\t.ndo_dfwd_del_station\t= fm10k_dfwd_del_station,\n\t.ndo_features_check\t= fm10k_features_check,\n};\n\n#define DEFAULT_DEBUG_LEVEL_SHIFT 3\n\nstruct net_device *fm10k_alloc_netdev(const struct fm10k_info *info)\n{\n\tnetdev_features_t hw_features;\n\tstruct fm10k_intfc *interface;\n\tstruct net_device *dev;\n\n\tdev = alloc_etherdev_mq(sizeof(struct fm10k_intfc), MAX_QUEUES);\n\tif (!dev)\n\t\treturn NULL;\n\n\t \n\tdev->netdev_ops = &fm10k_netdev_ops;\n\tfm10k_set_ethtool_ops(dev);\n\n\t \n\tinterface = netdev_priv(dev);\n\tinterface->msg_enable = BIT(DEFAULT_DEBUG_LEVEL_SHIFT) - 1;\n\n\t \n\tdev->features |= NETIF_F_IP_CSUM |\n\t\t\t NETIF_F_IPV6_CSUM |\n\t\t\t NETIF_F_SG |\n\t\t\t NETIF_F_TSO |\n\t\t\t NETIF_F_TSO6 |\n\t\t\t NETIF_F_TSO_ECN |\n\t\t\t NETIF_F_RXHASH |\n\t\t\t NETIF_F_RXCSUM;\n\n\t \n\tif (info->mac == fm10k_mac_pf) {\n\t\tdev->hw_enc_features = NETIF_F_IP_CSUM |\n\t\t\t\t       NETIF_F_TSO |\n\t\t\t\t       NETIF_F_TSO6 |\n\t\t\t\t       NETIF_F_TSO_ECN |\n\t\t\t\t       NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t       NETIF_F_IPV6_CSUM |\n\t\t\t\t       NETIF_F_SG;\n\n\t\tdev->features |= NETIF_F_GSO_UDP_TUNNEL;\n\n\t\tdev->udp_tunnel_nic_info = &fm10k_udp_tunnels;\n\t}\n\n\t \n\thw_features = dev->features;\n\n\t \n\thw_features |= NETIF_F_HW_L2FW_DOFFLOAD;\n\n\t \n\tdev->vlan_features |= dev->features;\n\n\t \n\tdev->features |= NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tdev->hw_features |= hw_features;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = FM10K_MAX_JUMBO_FRAME_SIZE;\n\n\treturn dev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}