{
  "module_name": "fm10k_pci.c",
  "hash_id": "c18877e52237232d5f6cdf0d762b7332e8ca315019be199bf8cc7baa108b7936",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n\n#include \"fm10k.h\"\n\nstatic const struct fm10k_info *fm10k_info_tbl[] = {\n\t[fm10k_device_pf] = &fm10k_pf_info,\n\t[fm10k_device_vf] = &fm10k_vf_info,\n};\n\n \nstatic const struct pci_device_id fm10k_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, FM10K_DEV_ID_PF), fm10k_device_pf },\n\t{ PCI_VDEVICE(INTEL, FM10K_DEV_ID_SDI_FM10420_QDA2), fm10k_device_pf },\n\t{ PCI_VDEVICE(INTEL, FM10K_DEV_ID_SDI_FM10420_DA2), fm10k_device_pf },\n\t{ PCI_VDEVICE(INTEL, FM10K_DEV_ID_VF), fm10k_device_vf },\n\t \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, fm10k_pci_tbl);\n\nu16 fm10k_read_pci_cfg_word(struct fm10k_hw *hw, u32 reg)\n{\n\tstruct fm10k_intfc *interface = hw->back;\n\tu16 value = 0;\n\n\tif (FM10K_REMOVED(hw->hw_addr))\n\t\treturn ~value;\n\n\tpci_read_config_word(interface->pdev, reg, &value);\n\tif (value == 0xFFFF)\n\t\tfm10k_write_flush(hw);\n\n\treturn value;\n}\n\nu32 fm10k_read_reg(struct fm10k_hw *hw, int reg)\n{\n\tu32 __iomem *hw_addr = READ_ONCE(hw->hw_addr);\n\tu32 value = 0;\n\n\tif (FM10K_REMOVED(hw_addr))\n\t\treturn ~value;\n\n\tvalue = readl(&hw_addr[reg]);\n\tif (!(~value) && (!reg || !(~readl(hw_addr)))) {\n\t\tstruct fm10k_intfc *interface = hw->back;\n\t\tstruct net_device *netdev = interface->netdev;\n\n\t\thw->hw_addr = NULL;\n\t\tnetif_device_detach(netdev);\n\t\tnetdev_err(netdev, \"PCIe link lost, device now detached\\n\");\n\t}\n\n\treturn value;\n}\n\nstatic int fm10k_hw_ready(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\tfm10k_write_flush(hw);\n\n\treturn FM10K_REMOVED(hw->hw_addr) ? -ENODEV : 0;\n}\n\n \nvoid fm10k_macvlan_schedule(struct fm10k_intfc *interface)\n{\n\t \n\tif (!test_bit(__FM10K_MACVLAN_DISABLE, interface->state) &&\n\t    !test_and_set_bit(__FM10K_MACVLAN_SCHED, interface->state)) {\n\t\tclear_bit(__FM10K_MACVLAN_REQUEST, interface->state);\n\t\t \n\t\tqueue_delayed_work(fm10k_workqueue,\n\t\t\t\t   &interface->macvlan_task, 10);\n\t} else {\n\t\tset_bit(__FM10K_MACVLAN_REQUEST, interface->state);\n\t}\n}\n\n \nstatic void fm10k_stop_macvlan_task(struct fm10k_intfc *interface)\n{\n\t \n\tset_bit(__FM10K_MACVLAN_DISABLE, interface->state);\n\n\t \n\tcancel_delayed_work_sync(&interface->macvlan_task);\n\n\t \n\tclear_bit(__FM10K_MACVLAN_SCHED, interface->state);\n}\n\n \nstatic void fm10k_resume_macvlan_task(struct fm10k_intfc *interface)\n{\n\t \n\tclear_bit(__FM10K_MACVLAN_DISABLE, interface->state);\n\n\t \n\tif (test_bit(__FM10K_MACVLAN_REQUEST, interface->state))\n\t\tfm10k_macvlan_schedule(interface);\n}\n\nvoid fm10k_service_event_schedule(struct fm10k_intfc *interface)\n{\n\tif (!test_bit(__FM10K_SERVICE_DISABLE, interface->state) &&\n\t    !test_and_set_bit(__FM10K_SERVICE_SCHED, interface->state)) {\n\t\tclear_bit(__FM10K_SERVICE_REQUEST, interface->state);\n\t\tqueue_work(fm10k_workqueue, &interface->service_task);\n\t} else {\n\t\tset_bit(__FM10K_SERVICE_REQUEST, interface->state);\n\t}\n}\n\nstatic void fm10k_service_event_complete(struct fm10k_intfc *interface)\n{\n\tWARN_ON(!test_bit(__FM10K_SERVICE_SCHED, interface->state));\n\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(__FM10K_SERVICE_SCHED, interface->state);\n\n\t \n\tif (test_bit(__FM10K_SERVICE_REQUEST, interface->state))\n\t\tfm10k_service_event_schedule(interface);\n}\n\nstatic void fm10k_stop_service_event(struct fm10k_intfc *interface)\n{\n\tset_bit(__FM10K_SERVICE_DISABLE, interface->state);\n\tcancel_work_sync(&interface->service_task);\n\n\t \n\tclear_bit(__FM10K_SERVICE_SCHED, interface->state);\n}\n\nstatic void fm10k_start_service_event(struct fm10k_intfc *interface)\n{\n\tclear_bit(__FM10K_SERVICE_DISABLE, interface->state);\n\tfm10k_service_event_schedule(interface);\n}\n\n \nstatic void fm10k_service_timer(struct timer_list *t)\n{\n\tstruct fm10k_intfc *interface = from_timer(interface, t,\n\t\t\t\t\t\t   service_timer);\n\n\t \n\tmod_timer(&interface->service_timer, (HZ * 2) + jiffies);\n\n\tfm10k_service_event_schedule(interface);\n}\n\n \nstatic bool fm10k_prepare_for_reset(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\n\t \n\tnetif_trans_update(netdev);\n\n\t \n\tif (test_and_set_bit(__FM10K_RESETTING, interface->state))\n\t\treturn false;\n\n\t \n\tfm10k_stop_macvlan_task(interface);\n\n\trtnl_lock();\n\n\tfm10k_iov_suspend(interface->pdev);\n\n\tif (netif_running(netdev))\n\t\tfm10k_close(netdev);\n\n\tfm10k_mbx_free_irq(interface);\n\n\t \n\tfm10k_clear_queueing_scheme(interface);\n\n\t \n\tinterface->last_reset = jiffies + (10 * HZ);\n\n\trtnl_unlock();\n\n\treturn true;\n}\n\nstatic int fm10k_handle_reset(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint err;\n\n\tWARN_ON(!test_bit(__FM10K_RESETTING, interface->state));\n\n\trtnl_lock();\n\n\tpci_set_master(interface->pdev);\n\n\t \n\terr = hw->mac.ops.reset_hw(hw);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev, \"reset_hw failed: %d\\n\", err);\n\t\tgoto reinit_err;\n\t}\n\n\terr = hw->mac.ops.init_hw(hw);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev, \"init_hw failed: %d\\n\", err);\n\t\tgoto reinit_err;\n\t}\n\n\terr = fm10k_init_queueing_scheme(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"init_queueing_scheme failed: %d\\n\", err);\n\t\tgoto reinit_err;\n\t}\n\n\t \n\terr = fm10k_mbx_request_irq(interface);\n\tif (err)\n\t\tgoto err_mbx_irq;\n\n\terr = fm10k_hw_ready(interface);\n\tif (err)\n\t\tgoto err_open;\n\n\t \n\tif (hw->mac.type == fm10k_mac_vf) {\n\t\tif (is_valid_ether_addr(hw->mac.perm_addr)) {\n\t\t\tether_addr_copy(hw->mac.addr, hw->mac.perm_addr);\n\t\t\tether_addr_copy(netdev->perm_addr, hw->mac.perm_addr);\n\t\t\teth_hw_addr_set(netdev, hw->mac.perm_addr);\n\t\t\tnetdev->addr_assign_type &= ~NET_ADDR_RANDOM;\n\t\t}\n\n\t\tif (hw->mac.vlan_override)\n\t\t\tnetdev->features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\t\telse\n\t\t\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_RX;\n\t}\n\n\terr = netif_running(netdev) ? fm10k_open(netdev) : 0;\n\tif (err)\n\t\tgoto err_open;\n\n\tfm10k_iov_resume(interface->pdev);\n\n\trtnl_unlock();\n\n\tfm10k_resume_macvlan_task(interface);\n\n\tclear_bit(__FM10K_RESETTING, interface->state);\n\n\treturn err;\nerr_open:\n\tfm10k_mbx_free_irq(interface);\nerr_mbx_irq:\n\tfm10k_clear_queueing_scheme(interface);\nreinit_err:\n\tnetif_device_detach(netdev);\n\n\trtnl_unlock();\n\n\tclear_bit(__FM10K_RESETTING, interface->state);\n\n\treturn err;\n}\n\nstatic void fm10k_detach_subtask(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\tu32 __iomem *hw_addr;\n\tu32 value;\n\n\t \n\tif (netif_device_present(netdev) || interface->hw.hw_addr)\n\t\treturn;\n\n\t \n\tif (fm10k_prepare_for_reset(interface))\n\t\tset_bit(__FM10K_RESET_DETACHED, interface->state);\n\n\t \n\thw_addr = READ_ONCE(interface->uc_addr);\n\tvalue = readl(hw_addr);\n\tif (~value) {\n\t\tint err;\n\n\t\t \n\t\tif (!test_and_clear_bit(__FM10K_RESET_DETACHED,\n\t\t\t\t\tinterface->state))\n\t\t\treturn;\n\n\t\t \n\t\tinterface->hw.hw_addr = interface->uc_addr;\n\n\t\t \n\t\terr = fm10k_handle_reset(interface);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev, \"Unable to reset device: %d\\n\", err);\n\t\t\tinterface->hw.hw_addr = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tnetif_device_attach(netdev);\n\t\tnetdev_warn(netdev, \"PCIe link restored, device now attached\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void fm10k_reset_subtask(struct fm10k_intfc *interface)\n{\n\tint err;\n\n\tif (!test_and_clear_bit(FM10K_FLAG_RESET_REQUESTED,\n\t\t\t\tinterface->flags))\n\t\treturn;\n\n\t \n\tif (!fm10k_prepare_for_reset(interface))\n\t\treturn;\n\n\tnetdev_err(interface->netdev, \"Reset interface\\n\");\n\n\terr = fm10k_handle_reset(interface);\n\tif (err)\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"fm10k_handle_reset failed: %d\\n\", err);\n}\n\n \nstatic void fm10k_configure_swpri_map(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint i;\n\n\t \n\tclear_bit(FM10K_FLAG_SWPRI_CONFIG, interface->flags);\n\n\t \n\tif (hw->mac.type != fm10k_mac_pf)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < FM10K_SWPRI_MAX; i++)\n\t\tfm10k_write_reg(hw, FM10K_SWPRI_MAP(i),\n\t\t\t\tnetdev_get_prio_tc_map(netdev, i));\n}\n\n \nstatic void fm10k_watchdog_update_host_state(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\ts32 err;\n\n\tif (test_bit(__FM10K_LINK_DOWN, interface->state)) {\n\t\tinterface->host_ready = false;\n\t\tif (time_is_after_jiffies(interface->link_down_event))\n\t\t\treturn;\n\t\tclear_bit(__FM10K_LINK_DOWN, interface->state);\n\t}\n\n\tif (test_bit(FM10K_FLAG_SWPRI_CONFIG, interface->flags)) {\n\t\tif (rtnl_trylock()) {\n\t\t\tfm10k_configure_swpri_map(interface);\n\t\t\trtnl_unlock();\n\t\t}\n\t}\n\n\t \n\tfm10k_mbx_lock(interface);\n\n\terr = hw->mac.ops.get_host_state(hw, &interface->host_ready);\n\tif (err && time_is_before_jiffies(interface->last_reset))\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\n\t \n\tfm10k_mbx_unlock(interface);\n}\n\n \nstatic void fm10k_mbx_subtask(struct fm10k_intfc *interface)\n{\n\t \n\tif (test_bit(__FM10K_RESETTING, interface->state))\n\t\treturn;\n\n\t \n\tfm10k_watchdog_update_host_state(interface);\n\n\t \n\tfm10k_iov_mbx(interface);\n}\n\n \nstatic void fm10k_watchdog_host_is_ready(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\n\t \n\tif (netif_carrier_ok(netdev))\n\t\treturn;\n\n\tnetif_info(interface, drv, netdev, \"NIC Link is up\\n\");\n\n\tnetif_carrier_on(netdev);\n\tnetif_tx_wake_all_queues(netdev);\n}\n\n \nstatic void fm10k_watchdog_host_not_ready(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\n\t \n\tif (!netif_carrier_ok(netdev))\n\t\treturn;\n\n\tnetif_info(interface, drv, netdev, \"NIC Link is down\\n\");\n\n\tnetif_carrier_off(netdev);\n\tnetif_tx_stop_all_queues(netdev);\n}\n\n \nvoid fm10k_update_stats(struct fm10k_intfc *interface)\n{\n\tstruct net_device_stats *net_stats = &interface->netdev->stats;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu64 hw_csum_tx_good = 0, hw_csum_rx_good = 0, rx_length_errors = 0;\n\tu64 rx_switch_errors = 0, rx_drops = 0, rx_pp_errors = 0;\n\tu64 rx_link_errors = 0;\n\tu64 rx_errors = 0, rx_csum_errors = 0, tx_csum_errors = 0;\n\tu64 restart_queue = 0, tx_busy = 0, alloc_failed = 0;\n\tu64 rx_bytes_nic = 0, rx_pkts_nic = 0, rx_drops_nic = 0;\n\tu64 tx_bytes_nic = 0, tx_pkts_nic = 0;\n\tu64 bytes, pkts;\n\tint i;\n\n\t \n\tif (test_and_set_bit(__FM10K_UPDATING_STATS, interface->state))\n\t\treturn;\n\n\t \n\tinterface->next_stats_update = jiffies + HZ;\n\n\t \n\tfor (bytes = 0, pkts = 0, i = 0; i < interface->num_tx_queues; i++) {\n\t\tstruct fm10k_ring *tx_ring = READ_ONCE(interface->tx_ring[i]);\n\n\t\tif (!tx_ring)\n\t\t\tcontinue;\n\n\t\trestart_queue += tx_ring->tx_stats.restart_queue;\n\t\ttx_busy += tx_ring->tx_stats.tx_busy;\n\t\ttx_csum_errors += tx_ring->tx_stats.csum_err;\n\t\tbytes += tx_ring->stats.bytes;\n\t\tpkts += tx_ring->stats.packets;\n\t\thw_csum_tx_good += tx_ring->tx_stats.csum_good;\n\t}\n\n\tinterface->restart_queue = restart_queue;\n\tinterface->tx_busy = tx_busy;\n\tnet_stats->tx_bytes = bytes;\n\tnet_stats->tx_packets = pkts;\n\tinterface->tx_csum_errors = tx_csum_errors;\n\tinterface->hw_csum_tx_good = hw_csum_tx_good;\n\n\t \n\tfor (bytes = 0, pkts = 0, i = 0; i < interface->num_rx_queues; i++) {\n\t\tstruct fm10k_ring *rx_ring = READ_ONCE(interface->rx_ring[i]);\n\n\t\tif (!rx_ring)\n\t\t\tcontinue;\n\n\t\tbytes += rx_ring->stats.bytes;\n\t\tpkts += rx_ring->stats.packets;\n\t\talloc_failed += rx_ring->rx_stats.alloc_failed;\n\t\trx_csum_errors += rx_ring->rx_stats.csum_err;\n\t\trx_errors += rx_ring->rx_stats.errors;\n\t\thw_csum_rx_good += rx_ring->rx_stats.csum_good;\n\t\trx_switch_errors += rx_ring->rx_stats.switch_errors;\n\t\trx_drops += rx_ring->rx_stats.drops;\n\t\trx_pp_errors += rx_ring->rx_stats.pp_errors;\n\t\trx_link_errors += rx_ring->rx_stats.link_errors;\n\t\trx_length_errors += rx_ring->rx_stats.length_errors;\n\t}\n\n\tnet_stats->rx_bytes = bytes;\n\tnet_stats->rx_packets = pkts;\n\tinterface->alloc_failed = alloc_failed;\n\tinterface->rx_csum_errors = rx_csum_errors;\n\tinterface->hw_csum_rx_good = hw_csum_rx_good;\n\tinterface->rx_switch_errors = rx_switch_errors;\n\tinterface->rx_drops = rx_drops;\n\tinterface->rx_pp_errors = rx_pp_errors;\n\tinterface->rx_link_errors = rx_link_errors;\n\tinterface->rx_length_errors = rx_length_errors;\n\n\thw->mac.ops.update_hw_stats(hw, &interface->stats);\n\n\tfor (i = 0; i < hw->mac.max_queues; i++) {\n\t\tstruct fm10k_hw_stats_q *q = &interface->stats.q[i];\n\n\t\ttx_bytes_nic += q->tx_bytes.count;\n\t\ttx_pkts_nic += q->tx_packets.count;\n\t\trx_bytes_nic += q->rx_bytes.count;\n\t\trx_pkts_nic += q->rx_packets.count;\n\t\trx_drops_nic += q->rx_drops.count;\n\t}\n\n\tinterface->tx_bytes_nic = tx_bytes_nic;\n\tinterface->tx_packets_nic = tx_pkts_nic;\n\tinterface->rx_bytes_nic = rx_bytes_nic;\n\tinterface->rx_packets_nic = rx_pkts_nic;\n\tinterface->rx_drops_nic = rx_drops_nic;\n\n\t \n\tnet_stats->rx_errors = rx_errors;\n\tnet_stats->rx_dropped = interface->stats.nodesc_drop.count;\n\n\t \n\tfm10k_iov_update_stats(interface);\n\n\tclear_bit(__FM10K_UPDATING_STATS, interface->state);\n}\n\n \nstatic void fm10k_watchdog_flush_tx(struct fm10k_intfc *interface)\n{\n\tint some_tx_pending = 0;\n\tint i;\n\n\t \n\tif (netif_carrier_ok(interface->netdev))\n\t\treturn;\n\n\tfor (i = 0; i < interface->num_tx_queues; i++) {\n\t\tstruct fm10k_ring *tx_ring = interface->tx_ring[i];\n\n\t\tif (tx_ring->next_to_use != tx_ring->next_to_clean) {\n\t\t\tsome_tx_pending = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (some_tx_pending)\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n}\n\n \nstatic void fm10k_watchdog_subtask(struct fm10k_intfc *interface)\n{\n\t \n\tif (test_bit(__FM10K_DOWN, interface->state) ||\n\t    test_bit(__FM10K_RESETTING, interface->state))\n\t\treturn;\n\n\tif (interface->host_ready)\n\t\tfm10k_watchdog_host_is_ready(interface);\n\telse\n\t\tfm10k_watchdog_host_not_ready(interface);\n\n\t \n\tif (time_is_before_jiffies(interface->next_stats_update))\n\t\tfm10k_update_stats(interface);\n\n\t \n\tfm10k_watchdog_flush_tx(interface);\n}\n\n \nstatic void fm10k_check_hang_subtask(struct fm10k_intfc *interface)\n{\n\t \n\tif (test_bit(__FM10K_DOWN, interface->state) ||\n\t    test_bit(__FM10K_RESETTING, interface->state))\n\t\treturn;\n\n\t \n\tif (time_is_after_eq_jiffies(interface->next_tx_hang_check))\n\t\treturn;\n\tinterface->next_tx_hang_check = jiffies + (2 * HZ);\n\n\tif (netif_carrier_ok(interface->netdev)) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\t\tset_check_for_tx_hang(interface->tx_ring[i]);\n\n\t\t \n\t\tfor (i = 0; i < interface->num_q_vectors; i++) {\n\t\t\tstruct fm10k_q_vector *qv = interface->q_vector[i];\n\n\t\t\tif (!qv->tx.count && !qv->rx.count)\n\t\t\t\tcontinue;\n\t\t\twritel(FM10K_ITR_ENABLE | FM10K_ITR_PENDING2, qv->itr);\n\t\t}\n\t}\n}\n\n \nstatic void fm10k_service_task(struct work_struct *work)\n{\n\tstruct fm10k_intfc *interface;\n\n\tinterface = container_of(work, struct fm10k_intfc, service_task);\n\n\t \n\tfm10k_detach_subtask(interface);\n\n\t \n\tfm10k_mbx_subtask(interface);\n\tfm10k_reset_subtask(interface);\n\n\t \n\tfm10k_watchdog_subtask(interface);\n\tfm10k_check_hang_subtask(interface);\n\n\t \n\tfm10k_service_event_complete(interface);\n}\n\n \nstatic void fm10k_macvlan_task(struct work_struct *work)\n{\n\tstruct fm10k_macvlan_request *item;\n\tstruct fm10k_intfc *interface;\n\tstruct delayed_work *dwork;\n\tstruct list_head *requests;\n\tstruct fm10k_hw *hw;\n\tunsigned long flags;\n\n\tdwork = to_delayed_work(work);\n\tinterface = container_of(dwork, struct fm10k_intfc, macvlan_task);\n\thw = &interface->hw;\n\trequests = &interface->macvlan_requests;\n\n\tdo {\n\t\t \n\t\tspin_lock_irqsave(&interface->macvlan_lock, flags);\n\t\titem = list_first_entry_or_null(requests,\n\t\t\t\t\t\tstruct fm10k_macvlan_request,\n\t\t\t\t\t\tlist);\n\t\tif (item)\n\t\t\tlist_del_init(&item->list);\n\n\t\tspin_unlock_irqrestore(&interface->macvlan_lock, flags);\n\n\t\t \n\t\tif (!item)\n\t\t\tgoto done;\n\n\t\tfm10k_mbx_lock(interface);\n\n\t\t \n\t\tif (!hw->mbx.ops.tx_ready(&hw->mbx, FM10K_VFMBX_MSG_MTU + 5)) {\n\t\t\thw->mbx.ops.process(hw, &hw->mbx);\n\t\t\tset_bit(__FM10K_MACVLAN_REQUEST, interface->state);\n\t\t\tfm10k_mbx_unlock(interface);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&interface->macvlan_lock, flags);\n\t\t\tlist_add(&item->list, requests);\n\t\t\tspin_unlock_irqrestore(&interface->macvlan_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (item->type) {\n\t\tcase FM10K_MC_MAC_REQUEST:\n\t\t\thw->mac.ops.update_mc_addr(hw,\n\t\t\t\t\t\t   item->mac.glort,\n\t\t\t\t\t\t   item->mac.addr,\n\t\t\t\t\t\t   item->mac.vid,\n\t\t\t\t\t\t   item->set);\n\t\t\tbreak;\n\t\tcase FM10K_UC_MAC_REQUEST:\n\t\t\thw->mac.ops.update_uc_addr(hw,\n\t\t\t\t\t\t   item->mac.glort,\n\t\t\t\t\t\t   item->mac.addr,\n\t\t\t\t\t\t   item->mac.vid,\n\t\t\t\t\t\t   item->set,\n\t\t\t\t\t\t   0);\n\t\t\tbreak;\n\t\tcase FM10K_VLAN_REQUEST:\n\t\t\thw->mac.ops.update_vlan(hw,\n\t\t\t\t\t\titem->vlan.vid,\n\t\t\t\t\t\titem->vlan.vsi,\n\t\t\t\t\t\titem->set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tfm10k_mbx_unlock(interface);\n\n\t\t \n\t\tkfree(item);\n\t} while (true);\n\ndone:\n\tWARN_ON(!test_bit(__FM10K_MACVLAN_SCHED, interface->state));\n\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(__FM10K_MACVLAN_SCHED, interface->state);\n\n\t \n\tif (test_bit(__FM10K_MACVLAN_REQUEST, interface->state))\n\t\tfm10k_macvlan_schedule(interface);\n}\n\n \nstatic void fm10k_configure_tx_ring(struct fm10k_intfc *interface,\n\t\t\t\t    struct fm10k_ring *ring)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu64 tdba = ring->dma;\n\tu32 size = ring->count * sizeof(struct fm10k_tx_desc);\n\tu32 txint = FM10K_INT_MAP_DISABLE;\n\tu32 txdctl = BIT(FM10K_TXDCTL_MAX_TIME_SHIFT) | FM10K_TXDCTL_ENABLE;\n\tu8 reg_idx = ring->reg_idx;\n\n\t \n\tfm10k_write_reg(hw, FM10K_TXDCTL(reg_idx), 0);\n\tfm10k_write_flush(hw);\n\n\t \n\n\t \n\tfm10k_write_reg(hw, FM10K_TDBAL(reg_idx), tdba & DMA_BIT_MASK(32));\n\tfm10k_write_reg(hw, FM10K_TDBAH(reg_idx), tdba >> 32);\n\tfm10k_write_reg(hw, FM10K_TDLEN(reg_idx), size);\n\n\t \n\tfm10k_write_reg(hw, FM10K_TDH(reg_idx), 0);\n\tfm10k_write_reg(hw, FM10K_TDT(reg_idx), 0);\n\n\t \n\tring->tail = &interface->uc_addr[FM10K_TDT(reg_idx)];\n\n\t \n\tring->next_to_clean = 0;\n\tring->next_to_use = 0;\n\n\t \n\tif (ring->q_vector) {\n\t\ttxint = ring->q_vector->v_idx + NON_Q_VECTORS;\n\t\ttxint |= FM10K_INT_MAP_TIMER0;\n\t}\n\n\tfm10k_write_reg(hw, FM10K_TXINT(reg_idx), txint);\n\n\t \n\tfm10k_write_reg(hw, FM10K_PFVTCTL(reg_idx),\n\t\t\tFM10K_PFVTCTL_FTAG_DESC_ENABLE);\n\n\t \n\tif (!test_and_set_bit(__FM10K_TX_XPS_INIT_DONE, ring->state) &&\n\t    ring->q_vector)\n\t\tnetif_set_xps_queue(ring->netdev,\n\t\t\t\t    &ring->q_vector->affinity_mask,\n\t\t\t\t    ring->queue_index);\n\n\t \n\tfm10k_write_reg(hw, FM10K_TXDCTL(reg_idx), txdctl);\n}\n\n \nstatic void fm10k_enable_tx_ring(struct fm10k_intfc *interface,\n\t\t\t\t struct fm10k_ring *ring)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint wait_loop = 10;\n\tu32 txdctl;\n\tu8 reg_idx = ring->reg_idx;\n\n\t \n\tif (fm10k_read_reg(hw, FM10K_TXDCTL(reg_idx)) & FM10K_TXDCTL_ENABLE)\n\t\treturn;\n\n\t \n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\ttxdctl = fm10k_read_reg(hw, FM10K_TXDCTL(reg_idx));\n\t} while (!(txdctl & FM10K_TXDCTL_ENABLE) && --wait_loop);\n\tif (!wait_loop)\n\t\tnetif_err(interface, drv, interface->netdev,\n\t\t\t  \"Could not enable Tx Queue %d\\n\", reg_idx);\n}\n\n \nstatic void fm10k_configure_tx(struct fm10k_intfc *interface)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\tfm10k_configure_tx_ring(interface, interface->tx_ring[i]);\n\n\t \n\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\tfm10k_enable_tx_ring(interface, interface->tx_ring[i]);\n}\n\n \nstatic void fm10k_configure_rx_ring(struct fm10k_intfc *interface,\n\t\t\t\t    struct fm10k_ring *ring)\n{\n\tu64 rdba = ring->dma;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu32 size = ring->count * sizeof(union fm10k_rx_desc);\n\tu32 rxqctl, rxdctl = FM10K_RXDCTL_WRITE_BACK_MIN_DELAY;\n\tu32 srrctl = FM10K_SRRCTL_BUFFER_CHAINING_EN;\n\tu32 rxint = FM10K_INT_MAP_DISABLE;\n\tu8 rx_pause = interface->rx_pause;\n\tu8 reg_idx = ring->reg_idx;\n\n\t \n\trxqctl = fm10k_read_reg(hw, FM10K_RXQCTL(reg_idx));\n\trxqctl &= ~FM10K_RXQCTL_ENABLE;\n\tfm10k_write_reg(hw, FM10K_RXQCTL(reg_idx), rxqctl);\n\tfm10k_write_flush(hw);\n\n\t \n\n\t \n\tfm10k_write_reg(hw, FM10K_RDBAL(reg_idx), rdba & DMA_BIT_MASK(32));\n\tfm10k_write_reg(hw, FM10K_RDBAH(reg_idx), rdba >> 32);\n\tfm10k_write_reg(hw, FM10K_RDLEN(reg_idx), size);\n\n\t \n\tfm10k_write_reg(hw, FM10K_RDH(reg_idx), 0);\n\tfm10k_write_reg(hw, FM10K_RDT(reg_idx), 0);\n\n\t \n\tring->tail = &interface->uc_addr[FM10K_RDT(reg_idx)];\n\n\t \n\tring->next_to_clean = 0;\n\tring->next_to_use = 0;\n\tring->next_to_alloc = 0;\n\n\t \n\tsrrctl |= FM10K_RX_BUFSZ >> FM10K_SRRCTL_BSIZEPKT_SHIFT;\n\n\t \n\tsrrctl |= FM10K_SRRCTL_LOOPBACK_SUPPRESS;\n\tfm10k_write_reg(hw, FM10K_SRRCTL(reg_idx), srrctl);\n\n\t \n#ifdef CONFIG_DCB\n\tif (interface->pfc_en)\n\t\trx_pause = interface->pfc_en;\n#endif\n\tif (!(rx_pause & BIT(ring->qos_pc)))\n\t\trxdctl |= FM10K_RXDCTL_DROP_ON_EMPTY;\n\n\tfm10k_write_reg(hw, FM10K_RXDCTL(reg_idx), rxdctl);\n\n\t \n\tring->vid = hw->mac.default_vid;\n\n\t \n\tif (test_bit(hw->mac.default_vid, interface->active_vlans))\n\t\tring->vid |= FM10K_VLAN_CLEAR;\n\n\t \n\tif (ring->q_vector) {\n\t\trxint = ring->q_vector->v_idx + NON_Q_VECTORS;\n\t\trxint |= FM10K_INT_MAP_TIMER1;\n\t}\n\n\tfm10k_write_reg(hw, FM10K_RXINT(reg_idx), rxint);\n\n\t \n\trxqctl = fm10k_read_reg(hw, FM10K_RXQCTL(reg_idx));\n\trxqctl |= FM10K_RXQCTL_ENABLE;\n\tfm10k_write_reg(hw, FM10K_RXQCTL(reg_idx), rxqctl);\n\n\t \n\tfm10k_alloc_rx_buffers(ring, fm10k_desc_unused(ring));\n}\n\n \nvoid fm10k_update_rx_drop_en(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu8 rx_pause = interface->rx_pause;\n\tint i;\n\n#ifdef CONFIG_DCB\n\tif (interface->pfc_en)\n\t\trx_pause = interface->pfc_en;\n\n#endif\n\tfor (i = 0; i < interface->num_rx_queues; i++) {\n\t\tstruct fm10k_ring *ring = interface->rx_ring[i];\n\t\tu32 rxdctl = FM10K_RXDCTL_WRITE_BACK_MIN_DELAY;\n\t\tu8 reg_idx = ring->reg_idx;\n\n\t\tif (!(rx_pause & BIT(ring->qos_pc)))\n\t\t\trxdctl |= FM10K_RXDCTL_DROP_ON_EMPTY;\n\n\t\tfm10k_write_reg(hw, FM10K_RXDCTL(reg_idx), rxdctl);\n\t}\n}\n\n \nstatic void fm10k_configure_dglort(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_dglort_cfg dglort = { 0 };\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint i;\n\tu32 mrqc;\n\n\t \n\tfor (i = 0; i < FM10K_RSSRK_SIZE; i++)\n\t\tfm10k_write_reg(hw, FM10K_RSSRK(0, i), interface->rssrk[i]);\n\n\t \n\tfor (i = 0; i < FM10K_RETA_SIZE; i++)\n\t\tfm10k_write_reg(hw, FM10K_RETA(0, i), interface->reta[i]);\n\n\t \n\tmrqc = FM10K_MRQC_IPV4 |\n\t       FM10K_MRQC_TCP_IPV4 |\n\t       FM10K_MRQC_IPV6 |\n\t       FM10K_MRQC_TCP_IPV6;\n\n\tif (test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP, interface->flags))\n\t\tmrqc |= FM10K_MRQC_UDP_IPV4;\n\tif (test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP, interface->flags))\n\t\tmrqc |= FM10K_MRQC_UDP_IPV6;\n\n\tfm10k_write_reg(hw, FM10K_MRQC(0), mrqc);\n\n\t \n\tdglort.inner_rss = 1;\n\tdglort.rss_l = fls(interface->ring_feature[RING_F_RSS].mask);\n\tdglort.pc_l = fls(interface->ring_feature[RING_F_QOS].mask);\n\thw->mac.ops.configure_dglort_map(hw, &dglort);\n\n\t \n\tif (interface->glort_count > 64) {\n\t\tmemset(&dglort, 0, sizeof(dglort));\n\t\tdglort.inner_rss = 1;\n\t\tdglort.glort = interface->glort + 64;\n\t\tdglort.idx = fm10k_dglort_pf_queue;\n\t\tdglort.queue_l = fls(interface->num_rx_queues - 1);\n\t\thw->mac.ops.configure_dglort_map(hw, &dglort);\n\t}\n\n\t \n\tmemset(&dglort, 0, sizeof(dglort));\n\tdglort.inner_rss = 1;\n\tdglort.glort = interface->glort;\n\tdglort.rss_l = fls(interface->ring_feature[RING_F_RSS].mask);\n\tdglort.pc_l = fls(interface->ring_feature[RING_F_QOS].mask);\n\t \n\tdglort.idx = fm10k_dglort_pf_rss;\n\tif (interface->l2_accel)\n\t\tdglort.shared_l = fls(interface->l2_accel->size);\n\thw->mac.ops.configure_dglort_map(hw, &dglort);\n}\n\n \nstatic void fm10k_configure_rx(struct fm10k_intfc *interface)\n{\n\tint i;\n\n\t \n\tfm10k_configure_swpri_map(interface);\n\n\t \n\tfm10k_configure_dglort(interface);\n\n\t \n\tfor (i = 0; i < interface->num_rx_queues; i++)\n\t\tfm10k_configure_rx_ring(interface, interface->rx_ring[i]);\n\n\t \n}\n\nstatic void fm10k_napi_enable_all(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_q_vector *q_vector;\n\tint q_idx;\n\n\tfor (q_idx = 0; q_idx < interface->num_q_vectors; q_idx++) {\n\t\tq_vector = interface->q_vector[q_idx];\n\t\tnapi_enable(&q_vector->napi);\n\t}\n}\n\nstatic irqreturn_t fm10k_msix_clean_rings(int __always_unused irq, void *data)\n{\n\tstruct fm10k_q_vector *q_vector = data;\n\n\tif (q_vector->rx.count || q_vector->tx.count)\n\t\tnapi_schedule_irqoff(&q_vector->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t fm10k_msix_mbx_vf(int __always_unused irq, void *data)\n{\n\tstruct fm10k_intfc *interface = data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\n\t \n\tfm10k_write_reg(hw, FM10K_VFITR(FM10K_MBX_VECTOR),\n\t\t\t(FM10K_MBX_INT_DELAY >> hw->mac.itr_scale) |\n\t\t\tFM10K_ITR_ENABLE);\n\n\t \n\tif (fm10k_mbx_trylock(interface)) {\n\t\tmbx->ops.process(hw, mbx);\n\t\tfm10k_mbx_unlock(interface);\n\t}\n\n\thw->mac.get_host_state = true;\n\tfm10k_service_event_schedule(interface);\n\n\treturn IRQ_HANDLED;\n}\n\n#define FM10K_ERR_MSG(type) case (type): error = #type; break\nstatic void fm10k_handle_fault(struct fm10k_intfc *interface, int type,\n\t\t\t       struct fm10k_fault *fault)\n{\n\tstruct pci_dev *pdev = interface->pdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tchar *error;\n\n\tswitch (type) {\n\tcase FM10K_PCA_FAULT:\n\t\tswitch (fault->type) {\n\t\tdefault:\n\t\t\terror = \"Unknown PCA error\";\n\t\t\tbreak;\n\t\tFM10K_ERR_MSG(PCA_NO_FAULT);\n\t\tFM10K_ERR_MSG(PCA_UNMAPPED_ADDR);\n\t\tFM10K_ERR_MSG(PCA_BAD_QACCESS_PF);\n\t\tFM10K_ERR_MSG(PCA_BAD_QACCESS_VF);\n\t\tFM10K_ERR_MSG(PCA_MALICIOUS_REQ);\n\t\tFM10K_ERR_MSG(PCA_POISONED_TLP);\n\t\tFM10K_ERR_MSG(PCA_TLP_ABORT);\n\t\t}\n\t\tbreak;\n\tcase FM10K_THI_FAULT:\n\t\tswitch (fault->type) {\n\t\tdefault:\n\t\t\terror = \"Unknown THI error\";\n\t\t\tbreak;\n\t\tFM10K_ERR_MSG(THI_NO_FAULT);\n\t\tFM10K_ERR_MSG(THI_MAL_DIS_Q_FAULT);\n\t\t}\n\t\tbreak;\n\tcase FM10K_FUM_FAULT:\n\t\tswitch (fault->type) {\n\t\tdefault:\n\t\t\terror = \"Unknown FUM error\";\n\t\t\tbreak;\n\t\tFM10K_ERR_MSG(FUM_NO_FAULT);\n\t\tFM10K_ERR_MSG(FUM_UNMAPPED_ADDR);\n\t\tFM10K_ERR_MSG(FUM_BAD_VF_QACCESS);\n\t\tFM10K_ERR_MSG(FUM_ADD_DECODE_ERR);\n\t\tFM10K_ERR_MSG(FUM_RO_ERROR);\n\t\tFM10K_ERR_MSG(FUM_QPRC_CRC_ERROR);\n\t\tFM10K_ERR_MSG(FUM_CSR_TIMEOUT);\n\t\tFM10K_ERR_MSG(FUM_INVALID_TYPE);\n\t\tFM10K_ERR_MSG(FUM_INVALID_LENGTH);\n\t\tFM10K_ERR_MSG(FUM_INVALID_BE);\n\t\tFM10K_ERR_MSG(FUM_INVALID_ALIGN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = \"Undocumented fault\";\n\t\tbreak;\n\t}\n\n\tdev_warn(&pdev->dev,\n\t\t \"%s Address: 0x%llx SpecInfo: 0x%x Func: %02x.%0x\\n\",\n\t\t error, fault->address, fault->specinfo,\n\t\t PCI_SLOT(fault->func), PCI_FUNC(fault->func));\n\n\t \n\tif (fault->func && iov_data) {\n\t\tint vf = fault->func - 1;\n\t\tstruct fm10k_vf_info *vf_info = &iov_data->vf_info[vf];\n\n\t\thw->iov.ops.reset_lport(hw, vf_info);\n\t\thw->iov.ops.reset_resources(hw, vf_info);\n\n\t\t \n\t\thw->iov.ops.set_lport(hw, vf_info, vf,\n\t\t\t\t      FM10K_VF_FLAG_MULTI_CAPABLE);\n\n\t\t \n\t\tvf_info->mbx.ops.connect(hw, &vf_info->mbx);\n\t}\n}\n\nstatic void fm10k_report_fault(struct fm10k_intfc *interface, u32 eicr)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_fault fault = { 0 };\n\tint type, err;\n\n\tfor (eicr &= FM10K_EICR_FAULT_MASK, type = FM10K_PCA_FAULT;\n\t     eicr;\n\t     eicr >>= 1, type += FM10K_FAULT_SIZE) {\n\t\t \n\t\tif (!(eicr & 0x1))\n\t\t\tcontinue;\n\n\t\t \n\t\terr = hw->mac.ops.get_fault(hw, type, &fault);\n\t\tif (err) {\n\t\t\tdev_err(&interface->pdev->dev,\n\t\t\t\t\"error reading fault\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfm10k_handle_fault(interface, type, &fault);\n\t}\n}\n\nstatic void fm10k_reset_drop_on_empty(struct fm10k_intfc *interface, u32 eicr)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tconst u32 rxdctl = FM10K_RXDCTL_WRITE_BACK_MIN_DELAY;\n\tu32 maxholdq;\n\tint q;\n\n\tif (!(eicr & FM10K_EICR_MAXHOLDTIME))\n\t\treturn;\n\n\tmaxholdq = fm10k_read_reg(hw, FM10K_MAXHOLDQ(7));\n\tif (maxholdq)\n\t\tfm10k_write_reg(hw, FM10K_MAXHOLDQ(7), maxholdq);\n\tfor (q = 255;;) {\n\t\tif (maxholdq & BIT(31)) {\n\t\t\tif (q < FM10K_MAX_QUEUES_PF) {\n\t\t\t\tinterface->rx_overrun_pf++;\n\t\t\t\tfm10k_write_reg(hw, FM10K_RXDCTL(q), rxdctl);\n\t\t\t} else {\n\t\t\t\tinterface->rx_overrun_vf++;\n\t\t\t}\n\t\t}\n\n\t\tmaxholdq *= 2;\n\t\tif (!maxholdq)\n\t\t\tq &= ~(32 - 1);\n\n\t\tif (!q)\n\t\t\tbreak;\n\n\t\tif (q-- % 32)\n\t\t\tcontinue;\n\n\t\tmaxholdq = fm10k_read_reg(hw, FM10K_MAXHOLDQ(q / 32));\n\t\tif (maxholdq)\n\t\t\tfm10k_write_reg(hw, FM10K_MAXHOLDQ(q / 32), maxholdq);\n\t}\n}\n\nstatic irqreturn_t fm10k_msix_mbx_pf(int __always_unused irq, void *data)\n{\n\tstruct fm10k_intfc *interface = data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tu32 eicr;\n\n\t \n\teicr = fm10k_read_reg(hw, FM10K_EICR);\n\tfm10k_write_reg(hw, FM10K_EICR, eicr & (FM10K_EICR_MAILBOX |\n\t\t\t\t\t\tFM10K_EICR_SWITCHREADY |\n\t\t\t\t\t\tFM10K_EICR_SWITCHNOTREADY));\n\n\t \n\tfm10k_report_fault(interface, eicr);\n\n\t \n\tfm10k_reset_drop_on_empty(interface, eicr);\n\n\t \n\tif (fm10k_mbx_trylock(interface)) {\n\t\ts32 err = mbx->ops.process(hw, mbx);\n\n\t\tif (err == FM10K_ERR_RESET_REQUESTED)\n\t\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\n\t\t \n\t\tfm10k_iov_event(interface);\n\t\tfm10k_mbx_unlock(interface);\n\t}\n\n\t \n\tif (eicr & FM10K_EICR_SWITCHNOTREADY) {\n\t\t \n\t\tinterface->link_down_event = jiffies + (4 * HZ);\n\t\tset_bit(__FM10K_LINK_DOWN, interface->state);\n\n\t\t \n\t\thw->mac.dglort_map = FM10K_DGLORTMAP_NONE;\n\t}\n\n\t \n\thw->mac.get_host_state = true;\n\n\t \n\tfm10k_service_event_schedule(interface);\n\n\t \n\tfm10k_write_reg(hw, FM10K_ITR(FM10K_MBX_VECTOR),\n\t\t\t(FM10K_MBX_INT_DELAY >> hw->mac.itr_scale) |\n\t\t\tFM10K_ITR_ENABLE);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid fm10k_mbx_free_irq(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct msix_entry *entry;\n\tint itr_reg;\n\n\t \n\tif (!interface->msix_entries)\n\t\treturn;\n\n\tentry = &interface->msix_entries[FM10K_MBX_VECTOR];\n\n\t \n\thw->mbx.ops.disconnect(hw, &hw->mbx);\n\n\t \n\tif (hw->mac.type == fm10k_mac_pf) {\n\t\tfm10k_write_reg(hw, FM10K_EIMR,\n\t\t\t\tFM10K_EIMR_DISABLE(PCA_FAULT) |\n\t\t\t\tFM10K_EIMR_DISABLE(FUM_FAULT) |\n\t\t\t\tFM10K_EIMR_DISABLE(MAILBOX) |\n\t\t\t\tFM10K_EIMR_DISABLE(SWITCHREADY) |\n\t\t\t\tFM10K_EIMR_DISABLE(SWITCHNOTREADY) |\n\t\t\t\tFM10K_EIMR_DISABLE(SRAMERROR) |\n\t\t\t\tFM10K_EIMR_DISABLE(VFLR) |\n\t\t\t\tFM10K_EIMR_DISABLE(MAXHOLDTIME));\n\t\titr_reg = FM10K_ITR(FM10K_MBX_VECTOR);\n\t} else {\n\t\titr_reg = FM10K_VFITR(FM10K_MBX_VECTOR);\n\t}\n\n\tfm10k_write_reg(hw, itr_reg, FM10K_ITR_MASK_SET);\n\n\tfree_irq(entry->vector, interface);\n}\n\nstatic s32 fm10k_mbx_mac_addr(struct fm10k_hw *hw, u32 **results,\n\t\t\t      struct fm10k_mbx_info *mbx)\n{\n\tbool vlan_override = hw->mac.vlan_override;\n\tu16 default_vid = hw->mac.default_vid;\n\tstruct fm10k_intfc *interface;\n\ts32 err;\n\n\terr = fm10k_msg_mac_vlan_vf(hw, results, mbx);\n\tif (err)\n\t\treturn err;\n\n\tinterface = container_of(hw, struct fm10k_intfc, hw);\n\n\t \n\tif (is_valid_ether_addr(hw->mac.perm_addr) &&\n\t    !ether_addr_equal(hw->mac.perm_addr, hw->mac.addr))\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\n\t \n\tif ((vlan_override != hw->mac.vlan_override) ||\n\t    (default_vid != hw->mac.default_vid))\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\n\treturn 0;\n}\n\n \nstatic s32 fm10k_mbx_error(struct fm10k_hw *hw, u32 **results,\n\t\t\t   struct fm10k_mbx_info __always_unused *mbx)\n{\n\tstruct fm10k_intfc *interface;\n\tstruct pci_dev *pdev;\n\n\tinterface = container_of(hw, struct fm10k_intfc, hw);\n\tpdev = interface->pdev;\n\n\tdev_err(&pdev->dev, \"Unknown message ID %u\\n\",\n\t\t**results & FM10K_TLV_ID_MASK);\n\n\treturn 0;\n}\n\nstatic const struct fm10k_msg_data vf_mbx_data[] = {\n\tFM10K_TLV_MSG_TEST_HANDLER(fm10k_tlv_msg_test),\n\tFM10K_VF_MSG_MAC_VLAN_HANDLER(fm10k_mbx_mac_addr),\n\tFM10K_VF_MSG_LPORT_STATE_HANDLER(fm10k_msg_lport_state_vf),\n\tFM10K_TLV_MSG_ERROR_HANDLER(fm10k_mbx_error),\n};\n\nstatic int fm10k_mbx_request_irq_vf(struct fm10k_intfc *interface)\n{\n\tstruct msix_entry *entry = &interface->msix_entries[FM10K_MBX_VECTOR];\n\tstruct net_device *dev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint err;\n\n\t \n\tu32 itr = entry->entry | FM10K_INT_MAP_TIMER0;\n\n\t \n\terr = hw->mbx.ops.register_handlers(&hw->mbx, vf_mbx_data);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = request_irq(entry->vector, fm10k_msix_mbx_vf, 0,\n\t\t\t  dev->name, interface);\n\tif (err) {\n\t\tnetif_err(interface, probe, dev,\n\t\t\t  \"request_irq for msix_mbx failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tfm10k_write_reg(hw, FM10K_VFINT_MAP, itr);\n\n\t \n\tfm10k_write_reg(hw, FM10K_VFITR(entry->entry), FM10K_ITR_ENABLE);\n\n\treturn 0;\n}\n\nstatic s32 fm10k_lport_map(struct fm10k_hw *hw, u32 **results,\n\t\t\t   struct fm10k_mbx_info *mbx)\n{\n\tstruct fm10k_intfc *interface;\n\tu32 dglort_map = hw->mac.dglort_map;\n\ts32 err;\n\n\tinterface = container_of(hw, struct fm10k_intfc, hw);\n\n\terr = fm10k_msg_err_pf(hw, results, mbx);\n\tif (!err && hw->swapi.status) {\n\t\t \n\t\tinterface->link_down_event = jiffies + (2 * HZ);\n\t\tset_bit(__FM10K_LINK_DOWN, interface->state);\n\n\t\t \n\t\thw->mac.dglort_map = FM10K_DGLORTMAP_NONE;\n\n\t\tfm10k_service_event_schedule(interface);\n\n\t\t \n\t\tif (interface->lport_map_failed)\n\t\t\treturn 0;\n\n\t\tinterface->lport_map_failed = true;\n\n\t\tif (hw->swapi.status == FM10K_MSG_ERR_PEP_NOT_SCHEDULED)\n\t\t\tdev_warn(&interface->pdev->dev,\n\t\t\t\t \"cannot obtain link because the host interface is configured for a PCIe host interface bandwidth of zero\\n\");\n\t\tdev_warn(&interface->pdev->dev,\n\t\t\t \"request logical port map failed: %d\\n\",\n\t\t\t hw->swapi.status);\n\n\t\treturn 0;\n\t}\n\n\terr = fm10k_msg_lport_map_pf(hw, results, mbx);\n\tif (err)\n\t\treturn err;\n\n\tinterface->lport_map_failed = false;\n\n\t \n\tif (dglort_map != hw->mac.dglort_map)\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\n\treturn 0;\n}\n\nstatic s32 fm10k_update_pvid(struct fm10k_hw *hw, u32 **results,\n\t\t\t     struct fm10k_mbx_info __always_unused *mbx)\n{\n\tstruct fm10k_intfc *interface;\n\tu16 glort, pvid;\n\tu32 pvid_update;\n\ts32 err;\n\n\terr = fm10k_tlv_attr_get_u32(results[FM10K_PF_ATTR_ID_UPDATE_PVID],\n\t\t\t\t     &pvid_update);\n\tif (err)\n\t\treturn err;\n\n\t \n\tglort = FM10K_MSG_HDR_FIELD_GET(pvid_update, UPDATE_PVID_GLORT);\n\tpvid = FM10K_MSG_HDR_FIELD_GET(pvid_update, UPDATE_PVID_PVID);\n\n\t \n\tif (!fm10k_glort_valid_pf(hw, glort))\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (pvid >= FM10K_VLAN_TABLE_VID_MAX)\n\t\treturn FM10K_ERR_PARAM;\n\n\tinterface = container_of(hw, struct fm10k_intfc, hw);\n\n\t \n\terr = fm10k_iov_update_pvid(interface, glort, pvid);\n\tif (!err)\n\t\treturn 0;\n\n\t \n\tif (pvid != hw->mac.default_vid)\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\n\thw->mac.default_vid = pvid;\n\n\treturn 0;\n}\n\nstatic const struct fm10k_msg_data pf_mbx_data[] = {\n\tFM10K_PF_MSG_ERR_HANDLER(XCAST_MODES, fm10k_msg_err_pf),\n\tFM10K_PF_MSG_ERR_HANDLER(UPDATE_MAC_FWD_RULE, fm10k_msg_err_pf),\n\tFM10K_PF_MSG_LPORT_MAP_HANDLER(fm10k_lport_map),\n\tFM10K_PF_MSG_ERR_HANDLER(LPORT_CREATE, fm10k_msg_err_pf),\n\tFM10K_PF_MSG_ERR_HANDLER(LPORT_DELETE, fm10k_msg_err_pf),\n\tFM10K_PF_MSG_UPDATE_PVID_HANDLER(fm10k_update_pvid),\n\tFM10K_TLV_MSG_ERROR_HANDLER(fm10k_mbx_error),\n};\n\nstatic int fm10k_mbx_request_irq_pf(struct fm10k_intfc *interface)\n{\n\tstruct msix_entry *entry = &interface->msix_entries[FM10K_MBX_VECTOR];\n\tstruct net_device *dev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint err;\n\n\t \n\tu32 mbx_itr = entry->entry | FM10K_INT_MAP_TIMER0;\n\tu32 other_itr = entry->entry | FM10K_INT_MAP_IMMEDIATE;\n\n\t \n\terr = hw->mbx.ops.register_handlers(&hw->mbx, pf_mbx_data);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = request_irq(entry->vector, fm10k_msix_mbx_pf, 0,\n\t\t\t  dev->name, interface);\n\tif (err) {\n\t\tnetif_err(interface, probe, dev,\n\t\t\t  \"request_irq for msix_mbx failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_pcie_fault), other_itr);\n\tfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_switch_up_down), other_itr);\n\tfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_sram), other_itr);\n\tfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_max_hold_time), other_itr);\n\tfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_vflr), other_itr);\n\n\t \n\tfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_mailbox), mbx_itr);\n\n\t \n\tfm10k_write_reg(hw, FM10K_EIMR, FM10K_EIMR_ENABLE(PCA_FAULT) |\n\t\t\t\t\tFM10K_EIMR_ENABLE(FUM_FAULT) |\n\t\t\t\t\tFM10K_EIMR_ENABLE(MAILBOX) |\n\t\t\t\t\tFM10K_EIMR_ENABLE(SWITCHREADY) |\n\t\t\t\t\tFM10K_EIMR_ENABLE(SWITCHNOTREADY) |\n\t\t\t\t\tFM10K_EIMR_ENABLE(SRAMERROR) |\n\t\t\t\t\tFM10K_EIMR_ENABLE(VFLR) |\n\t\t\t\t\tFM10K_EIMR_ENABLE(MAXHOLDTIME));\n\n\t \n\tfm10k_write_reg(hw, FM10K_ITR(entry->entry), FM10K_ITR_ENABLE);\n\n\treturn 0;\n}\n\nint fm10k_mbx_request_irq(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint err;\n\n\t \n\tif (hw->mac.type == fm10k_mac_pf)\n\t\terr = fm10k_mbx_request_irq_pf(interface);\n\telse\n\t\terr = fm10k_mbx_request_irq_vf(interface);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hw->mbx.ops.connect(hw, &hw->mbx);\n\n\t \n\tif (err)\n\t\tfm10k_mbx_free_irq(interface);\n\n\treturn err;\n}\n\n \nvoid fm10k_qv_free_irq(struct fm10k_intfc *interface)\n{\n\tint vector = interface->num_q_vectors;\n\tstruct msix_entry *entry;\n\n\tentry = &interface->msix_entries[NON_Q_VECTORS + vector];\n\n\twhile (vector) {\n\t\tstruct fm10k_q_vector *q_vector;\n\n\t\tvector--;\n\t\tentry--;\n\t\tq_vector = interface->q_vector[vector];\n\n\t\tif (!q_vector->tx.count && !q_vector->rx.count)\n\t\t\tcontinue;\n\n\t\t \n\t\tirq_set_affinity_hint(entry->vector, NULL);\n\n\t\t \n\t\twritel(FM10K_ITR_MASK_SET, q_vector->itr);\n\n\t\tfree_irq(entry->vector, q_vector);\n\t}\n}\n\n \nint fm10k_qv_request_irq(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct msix_entry *entry;\n\tunsigned int ri = 0, ti = 0;\n\tint vector, err;\n\n\tentry = &interface->msix_entries[NON_Q_VECTORS];\n\n\tfor (vector = 0; vector < interface->num_q_vectors; vector++) {\n\t\tstruct fm10k_q_vector *q_vector = interface->q_vector[vector];\n\n\t\t \n\t\tif (q_vector->tx.count && q_vector->rx.count) {\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name),\n\t\t\t\t \"%s-TxRx-%u\", dev->name, ri++);\n\t\t\tti++;\n\t\t} else if (q_vector->rx.count) {\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name),\n\t\t\t\t \"%s-rx-%u\", dev->name, ri++);\n\t\t} else if (q_vector->tx.count) {\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name),\n\t\t\t\t \"%s-tx-%u\", dev->name, ti++);\n\t\t} else {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tq_vector->itr = (hw->mac.type == fm10k_mac_pf) ?\n\t\t\t\t&interface->uc_addr[FM10K_ITR(entry->entry)] :\n\t\t\t\t&interface->uc_addr[FM10K_VFITR(entry->entry)];\n\n\t\t \n\t\terr = request_irq(entry->vector, &fm10k_msix_clean_rings, 0,\n\t\t\t\t  q_vector->name, q_vector);\n\t\tif (err) {\n\t\t\tnetif_err(interface, probe, dev,\n\t\t\t\t  \"request_irq failed for MSIX interrupt Error: %d\\n\",\n\t\t\t\t  err);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tirq_set_affinity_hint(entry->vector, &q_vector->affinity_mask);\n\n\t\t \n\t\twritel(FM10K_ITR_ENABLE, q_vector->itr);\n\n\t\tentry++;\n\t}\n\n\treturn 0;\n\nerr_out:\n\t \n\twhile (vector) {\n\t\tstruct fm10k_q_vector *q_vector;\n\n\t\tentry--;\n\t\tvector--;\n\t\tq_vector = interface->q_vector[vector];\n\n\t\tif (!q_vector->tx.count && !q_vector->rx.count)\n\t\t\tcontinue;\n\n\t\t \n\t\tirq_set_affinity_hint(entry->vector, NULL);\n\n\t\t \n\t\twritel(FM10K_ITR_MASK_SET, q_vector->itr);\n\n\t\tfree_irq(entry->vector, q_vector);\n\t}\n\n\treturn err;\n}\n\nvoid fm10k_up(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\t \n\thw->mac.ops.start_hw(hw);\n\n\t \n\tfm10k_configure_tx(interface);\n\n\t \n\tfm10k_configure_rx(interface);\n\n\t \n\thw->mac.ops.update_int_moderator(hw);\n\n\t \n\tclear_bit(__FM10K_UPDATING_STATS, interface->state);\n\n\t \n\tclear_bit(__FM10K_DOWN, interface->state);\n\n\t \n\tfm10k_napi_enable_all(interface);\n\n\t \n\tfm10k_restore_rx_state(interface);\n\n\t \n\tnetif_tx_start_all_queues(interface->netdev);\n\n\t \n\thw->mac.get_host_state = true;\n\tmod_timer(&interface->service_timer, jiffies);\n}\n\nstatic void fm10k_napi_disable_all(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_q_vector *q_vector;\n\tint q_idx;\n\n\tfor (q_idx = 0; q_idx < interface->num_q_vectors; q_idx++) {\n\t\tq_vector = interface->q_vector[q_idx];\n\t\tnapi_disable(&q_vector->napi);\n\t}\n}\n\nvoid fm10k_down(struct fm10k_intfc *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint err, i = 0, count = 0;\n\n\t \n\tif (test_and_set_bit(__FM10K_DOWN, interface->state))\n\t\treturn;\n\n\t \n\tnetif_carrier_off(netdev);\n\n\t \n\tnetif_tx_stop_all_queues(netdev);\n\tnetif_tx_disable(netdev);\n\n\t \n\tfm10k_reset_rx_state(interface);\n\n\t \n\tfm10k_napi_disable_all(interface);\n\n\t \n\tfm10k_update_stats(interface);\n\n\t \n\twhile (test_and_set_bit(__FM10K_UPDATING_STATS, interface->state))\n\t\tusleep_range(1000, 2000);\n\n\t \n\tif (FM10K_REMOVED(hw->hw_addr))\n\t\tgoto skip_tx_dma_drain;\n\n\t \n\terr = hw->mac.ops.stop_hw(hw);\n\tif (err != FM10K_ERR_REQUESTS_PENDING)\n\t\tgoto skip_tx_dma_drain;\n\n#define TX_DMA_DRAIN_RETRIES 25\n\tfor (count = 0; count < TX_DMA_DRAIN_RETRIES; count++) {\n\t\tusleep_range(10000, 20000);\n\n\t\t \n\t\tfor (; i < interface->num_tx_queues; i++)\n\t\t\tif (fm10k_get_tx_pending(interface->tx_ring[i], false))\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (i == interface->num_tx_queues)\n\t\t\tbreak;\n\t}\n\n\tif (count >= TX_DMA_DRAIN_RETRIES)\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Tx queues failed to drain after %d tries. Tx DMA is probably hung.\\n\",\n\t\t\tcount);\nskip_tx_dma_drain:\n\t \n\terr = hw->mac.ops.stop_hw(hw);\n\tif (err == FM10K_ERR_REQUESTS_PENDING)\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"due to pending requests hw was not shut down gracefully\\n\");\n\telse if (err)\n\t\tdev_err(&interface->pdev->dev, \"stop_hw failed: %d\\n\", err);\n\n\t \n\tfm10k_clean_all_tx_rings(interface);\n\tfm10k_clean_all_rx_rings(interface);\n}\n\n \nstatic int fm10k_sw_init(struct fm10k_intfc *interface,\n\t\t\t const struct pci_device_id *ent)\n{\n\tconst struct fm10k_info *fi = fm10k_info_tbl[ent->driver_data];\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct pci_dev *pdev = interface->pdev;\n\tstruct net_device *netdev = interface->netdev;\n\tu32 rss_key[FM10K_RSSRK_SIZE];\n\tunsigned int rss;\n\tint err;\n\n\t \n\thw->back = interface;\n\thw->hw_addr = interface->uc_addr;\n\n\t \n\thw->vendor_id = pdev->vendor;\n\thw->device_id = pdev->device;\n\thw->revision_id = pdev->revision;\n\thw->subsystem_vendor_id = pdev->subsystem_vendor;\n\thw->subsystem_device_id = pdev->subsystem_device;\n\n\t \n\tmemcpy(&hw->mac.ops, fi->mac_ops, sizeof(hw->mac.ops));\n\thw->mac.type = fi->mac;\n\n\t \n\tif (fi->iov_ops)\n\t\tmemcpy(&hw->iov.ops, fi->iov_ops, sizeof(hw->iov.ops));\n\n\t \n\trss = min_t(int, FM10K_MAX_RSS_INDICES, num_online_cpus());\n\tinterface->ring_feature[RING_F_RSS].limit = rss;\n\tfi->get_invariants(hw);\n\n\t \n\tif (hw->mac.ops.get_bus_info)\n\t\thw->mac.ops.get_bus_info(hw);\n\n\t \n\tif (hw->mac.ops.set_dma_mask)\n\t\thw->mac.ops.set_dma_mask(hw, dma_get_mask(&pdev->dev));\n\n\t \n\tif (dma_get_mask(&pdev->dev) > DMA_BIT_MASK(32)) {\n\t\tnetdev->features |= NETIF_F_HIGHDMA;\n\t\tnetdev->vlan_features |= NETIF_F_HIGHDMA;\n\t}\n\n\t \n\terr = hw->mac.ops.reset_hw(hw);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"reset_hw failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = hw->mac.ops.init_hw(hw);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"init_hw failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\thw->mac.ops.update_hw_stats(hw, &interface->stats);\n\n\t \n\tpci_sriov_set_totalvfs(pdev, hw->iov.total_vfs);\n\n\t \n\teth_random_addr(hw->mac.addr);\n\n\t \n\terr = hw->mac.ops.read_mac_addr(hw);\n\tif (err) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Failed to obtain MAC address defaulting to random\\n\");\n\t\t \n\t\tnetdev->addr_assign_type |= NET_ADDR_RANDOM;\n\t}\n\n\teth_hw_addr_set(netdev, hw->mac.addr);\n\tether_addr_copy(netdev->perm_addr, hw->mac.addr);\n\n\tif (!is_valid_ether_addr(netdev->perm_addr)) {\n\t\tdev_err(&pdev->dev, \"Invalid MAC Address\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tfm10k_dcbnl_set_ops(netdev);\n\n\t \n\tinterface->tx_ring_count = FM10K_DEFAULT_TXD;\n\tinterface->rx_ring_count = FM10K_DEFAULT_RXD;\n\n\t \n\tinterface->tx_itr = FM10K_TX_ITR_DEFAULT;\n\tinterface->rx_itr = FM10K_ITR_ADAPTIVE | FM10K_RX_ITR_DEFAULT;\n\n\t \n\tINIT_LIST_HEAD(&interface->macvlan_requests);\n\n\tnetdev_rss_key_fill(rss_key, sizeof(rss_key));\n\tmemcpy(interface->rssrk, rss_key, sizeof(rss_key));\n\n\t \n\tspin_lock_init(&interface->mbx_lock);\n\tspin_lock_init(&interface->macvlan_lock);\n\n\t \n\tset_bit(__FM10K_DOWN, interface->state);\n\tset_bit(__FM10K_UPDATING_STATS, interface->state);\n\n\treturn 0;\n}\n\n \nstatic int fm10k_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct fm10k_intfc *interface;\n\tint err;\n\n\tif (pdev->error_state != pci_channel_io_normal) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"PCI device still in an error state. Unable to load...\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"PCI enable device failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(48));\n\tif (err)\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"DMA configuration failed: %d\\n\", err);\n\t\tgoto err_dma;\n\t}\n\n\terr = pci_request_mem_regions(pdev, fm10k_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"pci_request_selected_regions failed: %d\\n\", err);\n\t\tgoto err_pci_reg;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\n\tnetdev = fm10k_alloc_netdev(fm10k_info_tbl[ent->driver_data]);\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_netdev;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tinterface = netdev_priv(netdev);\n\tpci_set_drvdata(pdev, interface);\n\n\tinterface->netdev = netdev;\n\tinterface->pdev = pdev;\n\n\tinterface->uc_addr = ioremap(pci_resource_start(pdev, 0),\n\t\t\t\t     FM10K_UC_ADDR_SIZE);\n\tif (!interface->uc_addr) {\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\terr = fm10k_sw_init(interface, ent);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\t \n\tfm10k_dbg_intfc_init(interface);\n\n\terr = fm10k_init_queueing_scheme(interface);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\t \n\tset_bit(__FM10K_SERVICE_DISABLE, interface->state);\n\n\terr = fm10k_mbx_request_irq(interface);\n\tif (err)\n\t\tgoto err_mbx_interrupt;\n\n\t \n\terr = fm10k_hw_ready(interface);\n\tif (err)\n\t\tgoto err_register;\n\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\t \n\tnetif_carrier_off(netdev);\n\n\t \n\tnetif_tx_stop_all_queues(netdev);\n\n\t \n\ttimer_setup(&interface->service_timer, fm10k_service_timer, 0);\n\tINIT_WORK(&interface->service_task, fm10k_service_task);\n\n\t \n\tINIT_DELAYED_WORK(&interface->macvlan_task, fm10k_macvlan_task);\n\n\t \n\tmod_timer(&interface->service_timer, (HZ * 2) + jiffies);\n\n\t \n\tpcie_print_link_status(interface->pdev);\n\n\t \n\tdev_info(&pdev->dev, \"%pM\\n\", netdev->dev_addr);\n\n\t \n\tfm10k_iov_configure(pdev, 0);\n\n\t \n\tclear_bit(__FM10K_SERVICE_DISABLE, interface->state);\n\tfm10k_service_event_schedule(interface);\n\n\treturn 0;\n\nerr_register:\n\tfm10k_mbx_free_irq(interface);\nerr_mbx_interrupt:\n\tfm10k_clear_queueing_scheme(interface);\nerr_sw_init:\n\tif (interface->sw_addr)\n\t\tiounmap(interface->sw_addr);\n\tiounmap(interface->uc_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_netdev:\n\tpci_release_mem_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void fm10k_remove(struct pci_dev *pdev)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = interface->netdev;\n\n\tdel_timer_sync(&interface->service_timer);\n\n\tfm10k_stop_service_event(interface);\n\tfm10k_stop_macvlan_task(interface);\n\n\t \n\tfm10k_clear_macvlan_queue(interface, interface->glort, true);\n\n\t \n\tif (netdev->reg_state == NETREG_REGISTERED)\n\t\tunregister_netdev(netdev);\n\n\t \n\tfm10k_iov_disable(pdev);\n\n\t \n\tfm10k_mbx_free_irq(interface);\n\n\t \n\tfm10k_clear_queueing_scheme(interface);\n\n\t \n\tfm10k_dbg_intfc_exit(interface);\n\n\tif (interface->sw_addr)\n\t\tiounmap(interface->sw_addr);\n\tiounmap(interface->uc_addr);\n\n\tfree_netdev(netdev);\n\n\tpci_release_mem_regions(pdev);\n\n\tpci_disable_device(pdev);\n}\n\nstatic void fm10k_prepare_suspend(struct fm10k_intfc *interface)\n{\n\t \n\tfm10k_stop_service_event(interface);\n\n\tif (fm10k_prepare_for_reset(interface))\n\t\tset_bit(__FM10K_RESET_SUSPENDED, interface->state);\n}\n\nstatic int fm10k_handle_resume(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint err;\n\n\t \n\tif (!test_and_clear_bit(__FM10K_RESET_SUSPENDED, interface->state))\n\t\tdev_warn(&interface->pdev->dev,\n\t\t\t \"Device was shut down as part of suspend... Attempting to recover\\n\");\n\n\t \n\thw->mac.ops.rebind_hw_stats(hw, &interface->stats);\n\n\terr = fm10k_handle_reset(interface);\n\tif (err)\n\t\treturn err;\n\n\t \n\tinterface->host_ready = false;\n\tfm10k_watchdog_host_not_ready(interface);\n\n\t \n\tinterface->link_down_event = jiffies + (HZ);\n\tset_bit(__FM10K_LINK_DOWN, interface->state);\n\n\t \n\tfm10k_start_service_event(interface);\n\n\t \n\tfm10k_macvlan_schedule(interface);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused fm10k_resume(struct device *dev)\n{\n\tstruct fm10k_intfc *interface = dev_get_drvdata(dev);\n\tstruct net_device *netdev = interface->netdev;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint err;\n\n\t \n\thw->hw_addr = interface->uc_addr;\n\n\terr = fm10k_handle_resume(interface);\n\tif (err)\n\t\treturn err;\n\n\tnetif_device_attach(netdev);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused fm10k_suspend(struct device *dev)\n{\n\tstruct fm10k_intfc *interface = dev_get_drvdata(dev);\n\tstruct net_device *netdev = interface->netdev;\n\n\tnetif_device_detach(netdev);\n\n\tfm10k_prepare_suspend(interface);\n\n\treturn 0;\n}\n\n \nstatic pci_ers_result_t fm10k_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = interface->netdev;\n\n\tnetif_device_detach(netdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tfm10k_prepare_suspend(interface);\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t fm10k_io_slot_reset(struct pci_dev *pdev)\n{\n\tpci_ers_result_t result;\n\n\tif (pci_reenable_device(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset.\\n\");\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tpci_set_master(pdev);\n\t\tpci_restore_state(pdev);\n\n\t\t \n\t\tpci_save_state(pdev);\n\n\t\tpci_wake_from_d3(pdev, false);\n\n\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\treturn result;\n}\n\n \nstatic void fm10k_io_resume(struct pci_dev *pdev)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = interface->netdev;\n\tint err;\n\n\terr = fm10k_handle_resume(interface);\n\n\tif (err)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"%s failed: %d\\n\", __func__, err);\n\telse\n\t\tnetif_device_attach(netdev);\n}\n\n \nstatic void fm10k_io_reset_prepare(struct pci_dev *pdev)\n{\n\t \n\tif (pci_num_vf(pdev))\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"PCIe FLR may cause issues for any active VF devices\\n\");\n\tfm10k_prepare_suspend(pci_get_drvdata(pdev));\n}\n\n \nstatic void fm10k_io_reset_done(struct pci_dev *pdev)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\tint err = fm10k_handle_resume(interface);\n\n\tif (err) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"%s failed: %d\\n\", __func__, err);\n\t\tnetif_device_detach(interface->netdev);\n\t}\n}\n\nstatic const struct pci_error_handlers fm10k_err_handler = {\n\t.error_detected = fm10k_io_error_detected,\n\t.slot_reset = fm10k_io_slot_reset,\n\t.resume = fm10k_io_resume,\n\t.reset_prepare = fm10k_io_reset_prepare,\n\t.reset_done = fm10k_io_reset_done,\n};\n\nstatic SIMPLE_DEV_PM_OPS(fm10k_pm_ops, fm10k_suspend, fm10k_resume);\n\nstatic struct pci_driver fm10k_driver = {\n\t.name\t\t\t= fm10k_driver_name,\n\t.id_table\t\t= fm10k_pci_tbl,\n\t.probe\t\t\t= fm10k_probe,\n\t.remove\t\t\t= fm10k_remove,\n\t.driver = {\n\t\t.pm\t\t= &fm10k_pm_ops,\n\t},\n\t.sriov_configure\t= fm10k_iov_configure,\n\t.err_handler\t\t= &fm10k_err_handler\n};\n\n \nint fm10k_register_pci_driver(void)\n{\n\treturn pci_register_driver(&fm10k_driver);\n}\n\n \nvoid fm10k_unregister_pci_driver(void)\n{\n\tpci_unregister_driver(&fm10k_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}