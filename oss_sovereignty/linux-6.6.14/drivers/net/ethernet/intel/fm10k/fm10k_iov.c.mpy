{
  "module_name": "fm10k_iov.c",
  "hash_id": "61a17943ee11dc6d2cbed6dc8da9f7ae032e4c8950866772433698acd48b9a27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_iov.c",
  "human_readable_source": "\n \n\n#include \"fm10k.h\"\n#include \"fm10k_vf.h\"\n#include \"fm10k_pf.h\"\n\nstatic s32 fm10k_iov_msg_error(struct fm10k_hw *hw, u32 **results,\n\t\t\t       struct fm10k_mbx_info *mbx)\n{\n\tstruct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;\n\tstruct fm10k_intfc *interface = hw->back;\n\tstruct pci_dev *pdev = interface->pdev;\n\n\tdev_err(&pdev->dev, \"Unknown message ID %u on VF %d\\n\",\n\t\t**results & FM10K_TLV_ID_MASK, vf_info->vf_idx);\n\n\treturn fm10k_tlv_msg_error(hw, results, mbx);\n}\n\n \nstatic s32 fm10k_iov_msg_queue_mac_vlan(struct fm10k_hw *hw, u32 **results,\n\t\t\t\t\tstruct fm10k_mbx_info *mbx)\n{\n\tstruct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;\n\tstruct fm10k_intfc *interface = hw->back;\n\tu8 mac[ETH_ALEN];\n\tu32 *result;\n\tint err = 0;\n\tbool set;\n\tu16 vlan;\n\tu32 vid;\n\n\t \n\tif (!FM10K_VF_FLAG_ENABLED(vf_info))\n\t\terr = FM10K_ERR_PARAM;\n\n\tif (!err && !!results[FM10K_MAC_VLAN_MSG_VLAN]) {\n\t\tresult = results[FM10K_MAC_VLAN_MSG_VLAN];\n\n\t\t \n\t\terr = fm10k_tlv_attr_get_u32(result, &vid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tset = !(vid & FM10K_VLAN_CLEAR);\n\t\tvid &= ~FM10K_VLAN_CLEAR;\n\n\t\t \n\n\t\tif (vid >> 16) {\n\t\t\t \n\t\t\tif (vf_info->pf_vid)\n\t\t\t\treturn FM10K_ERR_PARAM;\n\t\t} else {\n\t\t\terr = fm10k_iov_select_vid(vf_info, (u16)vid);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tvid = err;\n\t\t}\n\n\t\t \n\t\terr = hw->mac.ops.update_vlan(hw, vid, vf_info->vsi, set);\n\t}\n\n\tif (!err && !!results[FM10K_MAC_VLAN_MSG_MAC]) {\n\t\tresult = results[FM10K_MAC_VLAN_MSG_MAC];\n\n\t\t \n\t\terr = fm10k_tlv_attr_get_mac_vlan(result, mac, &vlan);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (is_valid_ether_addr(vf_info->mac) &&\n\t\t    !ether_addr_equal(mac, vf_info->mac))\n\t\t\treturn FM10K_ERR_PARAM;\n\n\t\tset = !(vlan & FM10K_VLAN_CLEAR);\n\t\tvlan &= ~FM10K_VLAN_CLEAR;\n\n\t\terr = fm10k_iov_select_vid(vf_info, vlan);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tvlan = (u16)err;\n\n\t\t \n\t\terr = fm10k_queue_mac_request(interface, vf_info->glort,\n\t\t\t\t\t      mac, vlan, set);\n\t}\n\n\tif (!err && !!results[FM10K_MAC_VLAN_MSG_MULTICAST]) {\n\t\tresult = results[FM10K_MAC_VLAN_MSG_MULTICAST];\n\n\t\t \n\t\terr = fm10k_tlv_attr_get_mac_vlan(result, mac, &vlan);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (!(vf_info->vf_flags & FM10K_VF_FLAG_MULTI_ENABLED))\n\t\t\treturn FM10K_ERR_PARAM;\n\n\t\tset = !(vlan & FM10K_VLAN_CLEAR);\n\t\tvlan &= ~FM10K_VLAN_CLEAR;\n\n\t\terr = fm10k_iov_select_vid(vf_info, vlan);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tvlan = (u16)err;\n\n\t\t \n\t\terr = fm10k_queue_mac_request(interface, vf_info->glort,\n\t\t\t\t\t      mac, vlan, set);\n\t}\n\n\treturn err;\n}\n\nstatic const struct fm10k_msg_data iov_mbx_data[] = {\n\tFM10K_TLV_MSG_TEST_HANDLER(fm10k_tlv_msg_test),\n\tFM10K_VF_MSG_MSIX_HANDLER(fm10k_iov_msg_msix_pf),\n\tFM10K_VF_MSG_MAC_VLAN_HANDLER(fm10k_iov_msg_queue_mac_vlan),\n\tFM10K_VF_MSG_LPORT_STATE_HANDLER(fm10k_iov_msg_lport_state_pf),\n\tFM10K_TLV_MSG_ERROR_HANDLER(fm10k_iov_msg_error),\n};\n\ns32 fm10k_iov_event(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_iov_data *iov_data;\n\ts64 vflre;\n\tint i;\n\n\t \n\tif (!READ_ONCE(interface->iov_data))\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tiov_data = interface->iov_data;\n\n\t \n\tif (!iov_data)\n\t\tgoto read_unlock;\n\n\tif (!(fm10k_read_reg(hw, FM10K_EICR) & FM10K_EICR_VFLR))\n\t\tgoto read_unlock;\n\n\t \n\tvflre = fm10k_read_reg(hw, FM10K_PFVFLRE(1));\n\tvflre <<= 32;\n\tvflre |= fm10k_read_reg(hw, FM10K_PFVFLRE(0));\n\n\ti = iov_data->num_vfs;\n\n\tfor (vflre <<= 64 - i; vflre && i--; vflre += vflre) {\n\t\tstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\n\n\t\tif (vflre >= 0)\n\t\t\tcontinue;\n\n\t\thw->iov.ops.reset_resources(hw, vf_info);\n\t\tvf_info->mbx.ops.connect(hw, &vf_info->mbx);\n\t}\n\nread_unlock:\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\ns32 fm10k_iov_mbx(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_iov_data *iov_data;\n\tint i;\n\n\t \n\tif (!READ_ONCE(interface->iov_data))\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tiov_data = interface->iov_data;\n\n\t \n\tif (!iov_data)\n\t\tgoto read_unlock;\n\n\t \n\tfm10k_mbx_lock(interface);\n\n\t \nprocess_mbx:\n\tfor (i = iov_data->next_vf_mbx ? : iov_data->num_vfs; i--;) {\n\t\tstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\n\t\tstruct fm10k_mbx_info *mbx = &vf_info->mbx;\n\t\tu16 glort = vf_info->glort;\n\n\t\t \n\t\thw->mbx.ops.process(hw, &hw->mbx);\n\n\t\t \n\t\tif (vf_info->vf_flags && !fm10k_glort_valid_pf(hw, glort)) {\n\t\t\thw->iov.ops.reset_lport(hw, vf_info);\n\t\t\tfm10k_clear_macvlan_queue(interface, glort, false);\n\t\t}\n\n\t\t \n\t\tif (!mbx->timeout) {\n\t\t\thw->iov.ops.reset_resources(hw, vf_info);\n\t\t\tmbx->ops.connect(hw, mbx);\n\t\t}\n\n\t\t \n\t\tif (hw->mbx.state == FM10K_STATE_OPEN &&\n\t\t    !hw->mbx.ops.tx_ready(&hw->mbx, FM10K_VFMBX_MSG_MTU)) {\n\t\t\t \n\t\t\tinterface->hw_sm_mbx_full++;\n\n\t\t\t \n\t\t\tfm10k_service_event_schedule(interface);\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmbx->ops.process(hw, mbx);\n\t}\n\n\t \n\tif (i >= 0) {\n\t\tiov_data->next_vf_mbx = i + 1;\n\t} else if (iov_data->next_vf_mbx) {\n\t\tiov_data->next_vf_mbx = 0;\n\t\tgoto process_mbx;\n\t}\n\n\t \n\tfm10k_mbx_unlock(interface);\n\nread_unlock:\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nvoid fm10k_iov_suspend(struct pci_dev *pdev)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint num_vfs, i;\n\n\t \n\tnum_vfs = iov_data ? iov_data->num_vfs : 0;\n\n\t \n\tfm10k_write_reg(hw, FM10K_DGLORTMAP(fm10k_dglort_vf_rss),\n\t\t\tFM10K_DGLORTMAP_NONE);\n\n\t \n\tfor (i = 0; i < num_vfs; i++) {\n\t\tstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\n\n\t\thw->iov.ops.reset_resources(hw, vf_info);\n\t\thw->iov.ops.reset_lport(hw, vf_info);\n\t\tfm10k_clear_macvlan_queue(interface, vf_info->glort, false);\n\t}\n}\n\nstatic void fm10k_mask_aer_comp_abort(struct pci_dev *pdev)\n{\n\tu32 err_mask;\n\tint pos;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);\n\tif (!pos)\n\t\treturn;\n\n\t \n\tpci_read_config_dword(pdev, pos + PCI_ERR_UNCOR_MASK, &err_mask);\n\terr_mask |= PCI_ERR_UNC_COMP_ABORT;\n\tpci_write_config_dword(pdev, pos + PCI_ERR_UNCOR_MASK, err_mask);\n}\n\nint fm10k_iov_resume(struct pci_dev *pdev)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_dglort_cfg dglort = { 0 };\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint num_vfs, i;\n\n\t \n\tnum_vfs = iov_data ? iov_data->num_vfs : 0;\n\n\t \n\tif (!iov_data)\n\t\treturn -ENOMEM;\n\n\t \n\tfm10k_mask_aer_comp_abort(pdev);\n\n\t \n\thw->iov.ops.assign_resources(hw, num_vfs, num_vfs);\n\n\t \n\tdglort.glort = hw->mac.dglort_map & FM10K_DGLORTMAP_NONE;\n\tdglort.idx = fm10k_dglort_vf_rss;\n\tdglort.inner_rss = 1;\n\tdglort.rss_l = fls(fm10k_queues_per_pool(hw) - 1);\n\tdglort.queue_b = fm10k_vf_queue_index(hw, 0);\n\tdglort.vsi_l = fls(hw->iov.total_vfs - 1);\n\tdglort.vsi_b = 1;\n\n\thw->mac.ops.configure_dglort_map(hw, &dglort);\n\n\t \n\tfor (i = 0; i < num_vfs; i++) {\n\t\tstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\n\n\t\t \n\t\tif (i == (~hw->mac.dglort_map >> FM10K_DGLORTMAP_MASK_SHIFT))\n\t\t\tbreak;\n\n\t\t \n\t\thw->iov.ops.set_lport(hw, vf_info, i,\n\t\t\t\t      FM10K_VF_FLAG_MULTI_CAPABLE);\n\n\t\t \n\t\thw->iov.ops.assign_default_mac_vlan(hw, vf_info);\n\n\t\t \n\t\tvf_info->mbx.ops.connect(hw, &vf_info->mbx);\n\t}\n\n\treturn 0;\n}\n\ns32 fm10k_iov_update_pvid(struct fm10k_intfc *interface, u16 glort, u16 pvid)\n{\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_vf_info *vf_info;\n\tu16 vf_idx = (glort - hw->mac.dglort_map) & FM10K_DGLORTMAP_NONE;\n\n\t \n\tif (!iov_data)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tif (vf_idx >= iov_data->num_vfs)\n\t\treturn FM10K_ERR_PARAM;\n\n\t \n\tvf_info = &iov_data->vf_info[vf_idx];\n\tif (vf_info->sw_vid != pvid) {\n\t\tvf_info->sw_vid = pvid;\n\t\thw->iov.ops.assign_default_mac_vlan(hw, vf_info);\n\t}\n\n\treturn 0;\n}\n\nstatic void fm10k_iov_free_data(struct pci_dev *pdev)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\n\tif (!interface->iov_data)\n\t\treturn;\n\n\t \n\tfm10k_iov_suspend(pdev);\n\n\t \n\tkfree_rcu(interface->iov_data, rcu);\n\tinterface->iov_data = NULL;\n}\n\nstatic s32 fm10k_iov_alloc_data(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tsize_t size;\n\tint i;\n\n\t \n\tif (iov_data)\n\t\treturn -EBUSY;\n\n\t \n\tif (!hw->iov.ops.assign_resources)\n\t\treturn -ENODEV;\n\n\t \n\tif (!num_vfs)\n\t\treturn 0;\n\n\t \n\tsize = offsetof(struct fm10k_iov_data, vf_info[num_vfs]);\n\tiov_data = kzalloc(size, GFP_KERNEL);\n\tif (!iov_data)\n\t\treturn -ENOMEM;\n\n\t \n\tiov_data->num_vfs = num_vfs;\n\n\t \n\tfor (i = 0; i < num_vfs; i++) {\n\t\tstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\n\t\tint err;\n\n\t\t \n\t\tvf_info->vsi = i + 1;\n\t\tvf_info->vf_idx = i;\n\n\t\t \n\t\terr = fm10k_pfvf_mbx_init(hw, &vf_info->mbx, iov_mbx_data, i);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unable to initialize SR-IOV mailbox\\n\");\n\t\t\tkfree(iov_data);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tinterface->iov_data = iov_data;\n\n\t \n\tfm10k_iov_resume(pdev);\n\n\treturn 0;\n}\n\nvoid fm10k_iov_disable(struct pci_dev *pdev)\n{\n\tif (pci_num_vf(pdev) && pci_vfs_assigned(pdev))\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot disable SR-IOV while VFs are assigned\\n\");\n\telse\n\t\tpci_disable_sriov(pdev);\n\n\tfm10k_iov_free_data(pdev);\n}\n\nint fm10k_iov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tint current_vfs = pci_num_vf(pdev);\n\tint err = 0;\n\n\tif (current_vfs && pci_vfs_assigned(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot modify SR-IOV while VFs are assigned\\n\");\n\t\tnum_vfs = current_vfs;\n\t} else {\n\t\tpci_disable_sriov(pdev);\n\t\tfm10k_iov_free_data(pdev);\n\t}\n\n\t \n\terr = fm10k_iov_alloc_data(pdev, num_vfs);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (num_vfs && num_vfs != current_vfs) {\n\t\terr = pci_enable_sriov(pdev, num_vfs);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Enable PCI SR-IOV failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn num_vfs;\n}\n\n \nvoid fm10k_iov_update_stats(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint i;\n\n\tif (!iov_data)\n\t\treturn;\n\n\tfor (i = 0; i < iov_data->num_vfs; i++)\n\t\thw->iov.ops.update_stats(hw, iov_data->vf_info[i].stats, i);\n}\n\nstatic inline void fm10k_reset_vf_info(struct fm10k_intfc *interface,\n\t\t\t\t       struct fm10k_vf_info *vf_info)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\t \n\tfm10k_mbx_lock(interface);\n\n\t \n\thw->iov.ops.reset_lport(hw, vf_info);\n\n\tfm10k_clear_macvlan_queue(interface, vf_info->glort, false);\n\n\t \n\thw->iov.ops.assign_default_mac_vlan(hw, vf_info);\n\n\t \n\thw->iov.ops.set_lport(hw, vf_info, vf_info->vf_idx,\n\t\t\t      FM10K_VF_FLAG_MULTI_CAPABLE);\n\n\tfm10k_mbx_unlock(interface);\n}\n\nint fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_vf_info *vf_info;\n\n\t \n\tif (!iov_data || vf_idx >= iov_data->num_vfs)\n\t\treturn -EINVAL;\n\n\t \n\tif (!is_zero_ether_addr(mac) && !is_valid_ether_addr(mac))\n\t\treturn -EINVAL;\n\n\t \n\tvf_info = &iov_data->vf_info[vf_idx];\n\tether_addr_copy(vf_info->mac, mac);\n\n\tfm10k_reset_vf_info(interface, vf_info);\n\n\treturn 0;\n}\n\nint fm10k_ndo_set_vf_vlan(struct net_device *netdev, int vf_idx, u16 vid,\n\t\t\t  u8 qos, __be16 vlan_proto)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_vf_info *vf_info;\n\n\t \n\tif (!iov_data || vf_idx >= iov_data->num_vfs)\n\t\treturn -EINVAL;\n\n\t \n\tif (qos || (vid > (VLAN_VID_MASK - 1)))\n\t\treturn -EINVAL;\n\n\t \n\tif (vlan_proto != htons(ETH_P_8021Q))\n\t\treturn -EPROTONOSUPPORT;\n\n\tvf_info = &iov_data->vf_info[vf_idx];\n\n\t \n\tif (vf_info->pf_vid == vid)\n\t\treturn 0;\n\n\t \n\tvf_info->pf_vid = vid;\n\n\t \n\thw->mac.ops.update_vlan(hw, FM10K_VLAN_ALL, vf_info->vsi, false);\n\n\tfm10k_reset_vf_info(interface, vf_info);\n\n\treturn 0;\n}\n\nint fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx,\n\t\t\tint __always_unused min_rate, int max_rate)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\t \n\tif (!iov_data || vf_idx >= iov_data->num_vfs)\n\t\treturn -EINVAL;\n\n\t \n\tif (max_rate &&\n\t    (max_rate < FM10K_VF_TC_MIN || max_rate > FM10K_VF_TC_MAX))\n\t\treturn -EINVAL;\n\n\t \n\tiov_data->vf_info[vf_idx].rate = max_rate;\n\n\t \n\thw->iov.ops.configure_tc(hw, vf_idx, max_rate);\n\n\treturn 0;\n}\n\nint fm10k_ndo_get_vf_config(struct net_device *netdev,\n\t\t\t    int vf_idx, struct ifla_vf_info *ivi)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_vf_info *vf_info;\n\n\t \n\tif (!iov_data || vf_idx >= iov_data->num_vfs)\n\t\treturn -EINVAL;\n\n\tvf_info = &iov_data->vf_info[vf_idx];\n\n\tivi->vf = vf_idx;\n\tivi->max_tx_rate = vf_info->rate;\n\tivi->min_tx_rate = 0;\n\tether_addr_copy(ivi->mac, vf_info->mac);\n\tivi->vlan = vf_info->pf_vid;\n\tivi->qos = 0;\n\n\treturn 0;\n}\n\nint fm10k_ndo_get_vf_stats(struct net_device *netdev,\n\t\t\t   int vf_idx, struct ifla_vf_stats *stats)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(netdev);\n\tstruct fm10k_iov_data *iov_data = interface->iov_data;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tstruct fm10k_hw_stats_q *hw_stats;\n\tu32 idx, qpp;\n\n\t \n\tif (!iov_data || vf_idx >= iov_data->num_vfs)\n\t\treturn -EINVAL;\n\n\tqpp = fm10k_queues_per_pool(hw);\n\thw_stats = iov_data->vf_info[vf_idx].stats;\n\n\tfor (idx = 0; idx < qpp; idx++) {\n\t\tstats->rx_packets += hw_stats[idx].rx_packets.count;\n\t\tstats->tx_packets += hw_stats[idx].tx_packets.count;\n\t\tstats->rx_bytes += hw_stats[idx].rx_bytes.count;\n\t\tstats->tx_bytes += hw_stats[idx].tx_bytes.count;\n\t\tstats->rx_dropped += hw_stats[idx].rx_drops.count;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}