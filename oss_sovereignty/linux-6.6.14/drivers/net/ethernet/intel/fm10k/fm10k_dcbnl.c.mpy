{
  "module_name": "fm10k_dcbnl.c",
  "hash_id": "c7368ad24c6afcd571f1e4cbfce91b4756bab60bf4fd31ff296fda4961a22203",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c",
  "human_readable_source": "\n \n\n#include \"fm10k.h\"\n\n \nstatic int fm10k_dcbnl_ieee_getets(struct net_device *dev, struct ieee_ets *ets)\n{\n\tint i;\n\n\t \n\tets->ets_cap = IEEE_8021QAZ_MAX_TCS;\n\tets->cbs = 0;\n\n\t \n\tmemset(ets->tc_tx_bw, 0, sizeof(ets->tc_tx_bw));\n\tmemset(ets->tc_rx_bw, 0, sizeof(ets->tc_rx_bw));\n\tmemset(ets->tc_tsa, IEEE_8021QAZ_TSA_STRICT, sizeof(ets->tc_tsa));\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\tets->prio_tc[i] = netdev_get_prio_tc_map(dev, i);\n\n\treturn 0;\n}\n\n \nstatic int fm10k_dcbnl_ieee_setets(struct net_device *dev, struct ieee_ets *ets)\n{\n\tu8 num_tc = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tif (ets->tc_tx_bw[i] || ets->tc_rx_bw[i])\n\t\t\treturn -EINVAL;\n\t\tif (ets->tc_tsa[i] != IEEE_8021QAZ_TSA_STRICT)\n\t\t\treturn -EINVAL;\n\t\tif (ets->prio_tc[i] > num_tc)\n\t\t\tnum_tc = ets->prio_tc[i];\n\t}\n\n\t \n\tif (num_tc)\n\t\tnum_tc++;\n\n\tif (num_tc > IEEE_8021QAZ_MAX_TCS)\n\t\treturn -EINVAL;\n\n\t \n\tif (num_tc != netdev_get_num_tc(dev)) {\n\t\tint err = fm10k_setup_tc(dev, num_tc);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\tnetdev_set_prio_tc_map(dev, i, ets->prio_tc[i]);\n\n\treturn 0;\n}\n\n \nstatic int fm10k_dcbnl_ieee_getpfc(struct net_device *dev, struct ieee_pfc *pfc)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\n\t \n\tpfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\n\tpfc->pfc_en = interface->pfc_en;\n\n\treturn 0;\n}\n\n \nstatic int fm10k_dcbnl_ieee_setpfc(struct net_device *dev, struct ieee_pfc *pfc)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\n\t \n\tinterface->pfc_en = pfc->pfc_en;\n\n\t \n\tif (netif_running(dev))\n\t\tfm10k_update_rx_drop_en(interface);\n\n\treturn 0;\n}\n\n \nstatic u8 fm10k_dcbnl_getdcbx(struct net_device __always_unused *dev)\n{\n\treturn DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;\n}\n\n \nstatic u8 fm10k_dcbnl_setdcbx(struct net_device __always_unused *dev, u8 mode)\n{\n\treturn (mode != (DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE)) ? 1 : 0;\n}\n\nstatic const struct dcbnl_rtnl_ops fm10k_dcbnl_ops = {\n\t.ieee_getets\t= fm10k_dcbnl_ieee_getets,\n\t.ieee_setets\t= fm10k_dcbnl_ieee_setets,\n\t.ieee_getpfc\t= fm10k_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t= fm10k_dcbnl_ieee_setpfc,\n\n\t.getdcbx\t= fm10k_dcbnl_getdcbx,\n\t.setdcbx\t= fm10k_dcbnl_setdcbx,\n};\n\n \nvoid fm10k_dcbnl_set_ops(struct net_device *dev)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(dev);\n\tstruct fm10k_hw *hw = &interface->hw;\n\n\tif (hw->mac.type == fm10k_mac_pf)\n\t\tdev->dcbnl_ops = &fm10k_dcbnl_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}