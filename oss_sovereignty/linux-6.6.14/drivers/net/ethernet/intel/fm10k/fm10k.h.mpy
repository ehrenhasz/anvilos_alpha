{
  "module_name": "fm10k.h",
  "hash_id": "8386df55e44964a7208e3374bcf0719511cfb9385d301ead1e85046c570add22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k.h",
  "human_readable_source": " \n \n\n#ifndef _FM10K_H_\n#define _FM10K_H_\n\n#include <linux/types.h>\n#include <linux/etherdevice.h>\n#include <linux/cpumask.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n\n#include \"fm10k_pf.h\"\n#include \"fm10k_vf.h\"\n\n#define FM10K_MAX_JUMBO_FRAME_SIZE\t15342\t \n\n#define MAX_QUEUES\tFM10K_MAX_QUEUES_PF\n\n#define FM10K_MIN_RXD\t\t 128\n#define FM10K_MAX_RXD\t\t4096\n#define FM10K_DEFAULT_RXD\t 256\n\n#define FM10K_MIN_TXD\t\t 128\n#define FM10K_MAX_TXD\t\t4096\n#define FM10K_DEFAULT_TXD\t 256\n#define FM10K_DEFAULT_TX_WORK\t 256\n\n#define FM10K_RXBUFFER_256\t  256\n#define FM10K_RX_HDR_LEN\tFM10K_RXBUFFER_256\n#define FM10K_RXBUFFER_2048\t 2048\n#define FM10K_RX_BUFSZ\t\tFM10K_RXBUFFER_2048\n\n \n#define FM10K_RX_BUFFER_WRITE\t16\t \n\n#define FM10K_MAX_STATIONS\t63\nstruct fm10k_l2_accel {\n\tint size;\n\tu16 count;\n\tu16 dglort;\n\tstruct rcu_head rcu;\n\tstruct net_device *macvlan[];\n};\n\nenum fm10k_ring_state_t {\n\t__FM10K_TX_DETECT_HANG,\n\t__FM10K_HANG_CHECK_ARMED,\n\t__FM10K_TX_XPS_INIT_DONE,\n\t \n\t__FM10K_TX_STATE_SIZE__,\n};\n\n#define check_for_tx_hang(ring) \\\n\ttest_bit(__FM10K_TX_DETECT_HANG, (ring)->state)\n#define set_check_for_tx_hang(ring) \\\n\tset_bit(__FM10K_TX_DETECT_HANG, (ring)->state)\n#define clear_check_for_tx_hang(ring) \\\n\tclear_bit(__FM10K_TX_DETECT_HANG, (ring)->state)\n\nstruct fm10k_tx_buffer {\n\tstruct fm10k_tx_desc *next_to_watch;\n\tstruct sk_buff *skb;\n\tunsigned int bytecount;\n\tu16 gso_segs;\n\tu16 tx_flags;\n\tDEFINE_DMA_UNMAP_ADDR(dma);\n\tDEFINE_DMA_UNMAP_LEN(len);\n};\n\nstruct fm10k_rx_buffer {\n\tdma_addr_t dma;\n\tstruct page *page;\n\tu32 page_offset;\n};\n\nstruct fm10k_queue_stats {\n\tu64 packets;\n\tu64 bytes;\n};\n\nstruct fm10k_tx_queue_stats {\n\tu64 restart_queue;\n\tu64 csum_err;\n\tu64 tx_busy;\n\tu64 tx_done_old;\n\tu64 csum_good;\n};\n\nstruct fm10k_rx_queue_stats {\n\tu64 alloc_failed;\n\tu64 csum_err;\n\tu64 errors;\n\tu64 csum_good;\n\tu64 switch_errors;\n\tu64 drops;\n\tu64 pp_errors;\n\tu64 link_errors;\n\tu64 length_errors;\n};\n\nstruct fm10k_ring {\n\tstruct fm10k_q_vector *q_vector; \n\tstruct net_device *netdev;\t \n\tstruct device *dev;\t\t \n\tstruct fm10k_l2_accel __rcu *l2_accel;\t \n\tvoid *desc;\t\t\t \n\tunion {\n\t\tstruct fm10k_tx_buffer *tx_buffer;\n\t\tstruct fm10k_rx_buffer *rx_buffer;\n\t};\n\tu32 __iomem *tail;\n\tDECLARE_BITMAP(state, __FM10K_TX_STATE_SIZE__);\n\tdma_addr_t dma;\t\t\t \n\tunsigned int size;\t\t \n\n\tu8 queue_index;\t\t\t \n\tu8 reg_idx;\t\t\t \n\tu8 qos_pc;\t\t\t \n\tu16 vid;\t\t\t \n\tu16 count;\t\t\t \n\n\tu16 next_to_alloc;\n\tu16 next_to_use;\n\tu16 next_to_clean;\n\n\tstruct fm10k_queue_stats stats;\n\tstruct u64_stats_sync syncp;\n\tunion {\n\t\t \n\t\tstruct fm10k_tx_queue_stats tx_stats;\n\t\t \n\t\tstruct {\n\t\t\tstruct fm10k_rx_queue_stats rx_stats;\n\t\t\tstruct sk_buff *skb;\n\t\t};\n\t};\n} ____cacheline_internodealigned_in_smp;\n\nstruct fm10k_ring_container {\n\tstruct fm10k_ring *ring;\t \n\tunsigned int total_bytes;\t \n\tunsigned int total_packets;\t \n\tu16 work_limit;\t\t\t \n\tu16 itr;\t\t\t \n\tu8 itr_scale;\t\t\t \n\tu8 count;\t\t\t \n};\n\n#define FM10K_ITR_MAX\t\t0x0FFF\t \n#define FM10K_ITR_10K\t\t100\t \n#define FM10K_ITR_20K\t\t50\t \n#define FM10K_ITR_40K\t\t25\t \n#define FM10K_ITR_ADAPTIVE\t0x8000\t \n\n#define ITR_IS_ADAPTIVE(itr) (!!(itr & FM10K_ITR_ADAPTIVE))\n\n#define FM10K_TX_ITR_DEFAULT\tFM10K_ITR_40K\n#define FM10K_RX_ITR_DEFAULT\tFM10K_ITR_20K\n#define FM10K_ITR_ENABLE\t(FM10K_ITR_AUTOMASK | FM10K_ITR_MASK_CLEAR)\n\nstatic inline struct netdev_queue *txring_txq(const struct fm10k_ring *ring)\n{\n\treturn &ring->netdev->_tx[ring->queue_index];\n}\n\n \n#define fm10k_for_each_ring(pos, head) \\\n\tfor (pos = &(head).ring[(head).count]; (--pos) >= (head).ring;)\n\n#define MAX_Q_VECTORS 256\n#define MIN_Q_VECTORS\t1\nenum fm10k_non_q_vectors {\n\tFM10K_MBX_VECTOR,\n\tNON_Q_VECTORS\n};\n\n#define MIN_MSIX_COUNT(hw)\t(MIN_Q_VECTORS + NON_Q_VECTORS)\n\nstruct fm10k_q_vector {\n\tstruct fm10k_intfc *interface;\n\tu32 __iomem *itr;\t \n\tu16 v_idx;\t\t \n\tstruct fm10k_ring_container rx, tx;\n\n\tstruct napi_struct napi;\n\tcpumask_t affinity_mask;\n\tchar name[IFNAMSIZ + 9];\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dbg_q_vector;\n#endif  \n\tstruct rcu_head rcu;\t \n\n\t \n\tstruct fm10k_ring ring[] ____cacheline_internodealigned_in_smp;\n};\n\nenum fm10k_ring_f_enum {\n\tRING_F_RSS,\n\tRING_F_QOS,\n\tRING_F_ARRAY_SIZE   \n};\n\nstruct fm10k_ring_feature {\n\tu16 limit;\t \n\tu16 indices;\t \n\tu16 mask;\t \n\tu16 offset;\t \n};\n\nstruct fm10k_iov_data {\n\tunsigned int\t\tnum_vfs;\n\tunsigned int\t\tnext_vf_mbx;\n\tstruct rcu_head\t\trcu;\n\tstruct fm10k_vf_info\tvf_info[];\n};\n\nenum fm10k_macvlan_request_type {\n\tFM10K_UC_MAC_REQUEST,\n\tFM10K_MC_MAC_REQUEST,\n\tFM10K_VLAN_REQUEST\n};\n\nstruct fm10k_macvlan_request {\n\tenum fm10k_macvlan_request_type type;\n\tstruct list_head list;\n\tunion {\n\t\tstruct fm10k_mac_request {\n\t\t\tu8 addr[ETH_ALEN];\n\t\t\tu16 glort;\n\t\t\tu16 vid;\n\t\t} mac;\n\t\tstruct fm10k_vlan_request {\n\t\t\tu32 vid;\n\t\t\tu8 vsi;\n\t\t} vlan;\n\t};\n\tbool set;\n};\n\n \nextern struct workqueue_struct *fm10k_workqueue;\n\n \nenum fm10k_flags_t {\n\tFM10K_FLAG_RESET_REQUESTED,\n\tFM10K_FLAG_RSS_FIELD_IPV4_UDP,\n\tFM10K_FLAG_RSS_FIELD_IPV6_UDP,\n\tFM10K_FLAG_SWPRI_CONFIG,\n\t \n\t__FM10K_FLAGS_SIZE__\n};\n\nenum fm10k_state_t {\n\t__FM10K_RESETTING,\n\t__FM10K_RESET_DETACHED,\n\t__FM10K_RESET_SUSPENDED,\n\t__FM10K_DOWN,\n\t__FM10K_SERVICE_SCHED,\n\t__FM10K_SERVICE_REQUEST,\n\t__FM10K_SERVICE_DISABLE,\n\t__FM10K_MACVLAN_SCHED,\n\t__FM10K_MACVLAN_REQUEST,\n\t__FM10K_MACVLAN_DISABLE,\n\t__FM10K_LINK_DOWN,\n\t__FM10K_UPDATING_STATS,\n\t \n\t__FM10K_STATE_SIZE__,\n};\n\nstruct fm10k_intfc {\n\tunsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];\n\tstruct net_device *netdev;\n\tstruct fm10k_l2_accel *l2_accel;  \n\tstruct pci_dev *pdev;\n\tDECLARE_BITMAP(state, __FM10K_STATE_SIZE__);\n\n\t \n\tDECLARE_BITMAP(flags, __FM10K_FLAGS_SIZE__);\n\n\tint xcast_mode;\n\n\t \n\tint num_tx_queues;\n\tu16 tx_itr;\n\n\t \n\tint num_rx_queues;\n\tu16 rx_itr;\n\n\t \n\tstruct fm10k_ring *tx_ring[MAX_QUEUES] ____cacheline_aligned_in_smp;\n\n\tu64 restart_queue;\n\tu64 tx_busy;\n\tu64 tx_csum_errors;\n\tu64 alloc_failed;\n\tu64 rx_csum_errors;\n\n\tu64 tx_bytes_nic;\n\tu64 tx_packets_nic;\n\tu64 rx_bytes_nic;\n\tu64 rx_packets_nic;\n\tu64 rx_drops_nic;\n\tu64 rx_overrun_pf;\n\tu64 rx_overrun_vf;\n\n\t \n\tu64 hw_sm_mbx_full;\n\tu64 hw_csum_tx_good;\n\tu64 hw_csum_rx_good;\n\tu64 rx_switch_errors;\n\tu64 rx_drops;\n\tu64 rx_pp_errors;\n\tu64 rx_link_errors;\n\tu64 rx_length_errors;\n\n\tu32 tx_timeout_count;\n\n\t \n\tstruct fm10k_ring *rx_ring[MAX_QUEUES];\n\n\t \n\tstruct fm10k_q_vector *q_vector[MAX_Q_VECTORS];\n\tstruct msix_entry *msix_entries;\n\tint num_q_vectors;\t \n\tstruct fm10k_ring_feature ring_feature[RING_F_ARRAY_SIZE];\n\n\t \n\tstruct fm10k_iov_data *iov_data;\n\n\tstruct fm10k_hw_stats stats;\n\tstruct fm10k_hw hw;\n\t \n\tspinlock_t mbx_lock;\n\tu32 __iomem *uc_addr;\n\tu32 __iomem *sw_addr;\n\tu16 msg_enable;\n\tu16 tx_ring_count;\n\tu16 rx_ring_count;\n\tstruct timer_list service_timer;\n\tstruct work_struct service_task;\n\tunsigned long next_stats_update;\n\tunsigned long next_tx_hang_check;\n\tunsigned long last_reset;\n\tunsigned long link_down_event;\n\tbool host_ready;\n\tbool lport_map_failed;\n\n\tu32 reta[FM10K_RETA_SIZE];\n\tu32 rssrk[FM10K_RSSRK_SIZE];\n\n\t \n\t__be16 vxlan_port;\n\t__be16 geneve_port;\n\n\t \n\tstruct list_head macvlan_requests;\n\tstruct delayed_work macvlan_task;\n\t \n\tspinlock_t macvlan_lock;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dbg_intfc;\n#endif  \n\n#ifdef CONFIG_DCB\n\tu8 pfc_en;\n#endif\n\tu8 rx_pause;\n\n\t \n\tu16 glort;\n\tu16 glort_count;\n\n\t \n\tu16 vid;\n};\n\nstatic inline void fm10k_mbx_lock(struct fm10k_intfc *interface)\n{\n\tspin_lock(&interface->mbx_lock);\n}\n\nstatic inline void fm10k_mbx_unlock(struct fm10k_intfc *interface)\n{\n\tspin_unlock(&interface->mbx_lock);\n}\n\nstatic inline int fm10k_mbx_trylock(struct fm10k_intfc *interface)\n{\n\treturn spin_trylock(&interface->mbx_lock);\n}\n\n \nstatic inline __le32 fm10k_test_staterr(union fm10k_rx_desc *rx_desc,\n\t\t\t\t\tconst u32 stat_err_bits)\n{\n\treturn rx_desc->d.staterr & cpu_to_le32(stat_err_bits);\n}\n\n \nstatic inline u16 fm10k_desc_unused(struct fm10k_ring *ring)\n{\n\ts16 unused = ring->next_to_clean - ring->next_to_use - 1;\n\n\treturn likely(unused < 0) ? unused + ring->count : unused;\n}\n\n#define FM10K_TX_DESC(R, i)\t\\\n\t(&(((struct fm10k_tx_desc *)((R)->desc))[i]))\n#define FM10K_RX_DESC(R, i)\t\\\n\t (&(((union fm10k_rx_desc *)((R)->desc))[i]))\n\n#define FM10K_MAX_TXD_PWR\t14\n#define FM10K_MAX_DATA_PER_TXD\t(1u << FM10K_MAX_TXD_PWR)\n\n \n#define TXD_USE_COUNT(S)\tDIV_ROUND_UP((S), FM10K_MAX_DATA_PER_TXD)\n#define DESC_NEEDED\t(MAX_SKB_FRAGS + 4)\n\nenum fm10k_tx_flags {\n\t \n\tFM10K_TX_FLAGS_CSUM\t= 0x01,\n};\n\n \nunion fm10k_ftag_info {\n\t__le64 ftag;\n\tstruct {\n\t\t \n\t\t__le32 glort;\n\t\t \n\t\t__le32 vlan;\n\t} d;\n\tstruct {\n\t\t__le16 dglort;\n\t\t__le16 sglort;\n\t\t__le16 vlan;\n\t\t__le16 swpri_type_user;\n\t} w;\n};\n\nstruct fm10k_cb {\n\tunion {\n\t\t__le64 tstamp;\n\t\tunsigned long ts_tx_timeout;\n\t};\n\tunion fm10k_ftag_info fi;\n};\n\n#define FM10K_CB(skb) ((struct fm10k_cb *)(skb)->cb)\n\n \nextern char fm10k_driver_name[];\nint fm10k_init_queueing_scheme(struct fm10k_intfc *interface);\nvoid fm10k_clear_queueing_scheme(struct fm10k_intfc *interface);\n__be16 fm10k_tx_encap_offload(struct sk_buff *skb);\nnetdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb,\n\t\t\t\t  struct fm10k_ring *tx_ring);\nvoid fm10k_tx_timeout_reset(struct fm10k_intfc *interface);\nu64 fm10k_get_tx_pending(struct fm10k_ring *ring, bool in_sw);\nbool fm10k_check_tx_hang(struct fm10k_ring *tx_ring);\nvoid fm10k_alloc_rx_buffers(struct fm10k_ring *rx_ring, u16 cleaned_count);\n\n \nvoid fm10k_mbx_free_irq(struct fm10k_intfc *);\nint fm10k_mbx_request_irq(struct fm10k_intfc *);\nvoid fm10k_qv_free_irq(struct fm10k_intfc *interface);\nint fm10k_qv_request_irq(struct fm10k_intfc *interface);\nint fm10k_register_pci_driver(void);\nvoid fm10k_unregister_pci_driver(void);\nvoid fm10k_up(struct fm10k_intfc *interface);\nvoid fm10k_down(struct fm10k_intfc *interface);\nvoid fm10k_update_stats(struct fm10k_intfc *interface);\nvoid fm10k_service_event_schedule(struct fm10k_intfc *interface);\nvoid fm10k_macvlan_schedule(struct fm10k_intfc *interface);\nvoid fm10k_update_rx_drop_en(struct fm10k_intfc *interface);\n\n \nstruct net_device *fm10k_alloc_netdev(const struct fm10k_info *info);\nint fm10k_setup_rx_resources(struct fm10k_ring *);\nint fm10k_setup_tx_resources(struct fm10k_ring *);\nvoid fm10k_free_rx_resources(struct fm10k_ring *);\nvoid fm10k_free_tx_resources(struct fm10k_ring *);\nvoid fm10k_clean_all_rx_rings(struct fm10k_intfc *);\nvoid fm10k_clean_all_tx_rings(struct fm10k_intfc *);\nvoid fm10k_unmap_and_free_tx_resource(struct fm10k_ring *,\n\t\t\t\t      struct fm10k_tx_buffer *);\nvoid fm10k_restore_rx_state(struct fm10k_intfc *);\nvoid fm10k_reset_rx_state(struct fm10k_intfc *);\nint fm10k_setup_tc(struct net_device *dev, u8 tc);\nint fm10k_open(struct net_device *netdev);\nint fm10k_close(struct net_device *netdev);\nint fm10k_queue_vlan_request(struct fm10k_intfc *interface, u32 vid,\n\t\t\t     u8 vsi, bool set);\nint fm10k_queue_mac_request(struct fm10k_intfc *interface, u16 glort,\n\t\t\t    const unsigned char *addr, u16 vid, bool set);\nvoid fm10k_clear_macvlan_queue(struct fm10k_intfc *interface,\n\t\t\t       u16 glort, bool vlans);\n\n \nvoid fm10k_set_ethtool_ops(struct net_device *dev);\nvoid fm10k_write_reta(struct fm10k_intfc *interface, const u32 *indir);\n\n \ns32 fm10k_iov_event(struct fm10k_intfc *interface);\ns32 fm10k_iov_mbx(struct fm10k_intfc *interface);\nvoid fm10k_iov_suspend(struct pci_dev *pdev);\nint fm10k_iov_resume(struct pci_dev *pdev);\nvoid fm10k_iov_disable(struct pci_dev *pdev);\nint fm10k_iov_configure(struct pci_dev *pdev, int num_vfs);\nvoid fm10k_iov_update_stats(struct fm10k_intfc *interface);\ns32 fm10k_iov_update_pvid(struct fm10k_intfc *interface, u16 glort, u16 pvid);\nint fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac);\nint fm10k_ndo_set_vf_vlan(struct net_device *netdev,\n\t\t\t  int vf_idx, u16 vid, u8 qos, __be16 vlan_proto);\nint fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx,\n\t\t\tint __always_unused min_rate, int max_rate);\nint fm10k_ndo_get_vf_config(struct net_device *netdev,\n\t\t\t    int vf_idx, struct ifla_vf_info *ivi);\nint fm10k_ndo_get_vf_stats(struct net_device *netdev,\n\t\t\t   int vf_idx, struct ifla_vf_stats *stats);\n\n \n#ifdef CONFIG_DEBUG_FS\nvoid fm10k_dbg_q_vector_init(struct fm10k_q_vector *q_vector);\nvoid fm10k_dbg_q_vector_exit(struct fm10k_q_vector *q_vector);\nvoid fm10k_dbg_intfc_init(struct fm10k_intfc *interface);\nvoid fm10k_dbg_intfc_exit(struct fm10k_intfc *interface);\nvoid fm10k_dbg_init(void);\nvoid fm10k_dbg_exit(void);\n#else\nstatic inline void fm10k_dbg_q_vector_init(struct fm10k_q_vector *q_vector) {}\nstatic inline void fm10k_dbg_q_vector_exit(struct fm10k_q_vector *q_vector) {}\nstatic inline void fm10k_dbg_intfc_init(struct fm10k_intfc *interface) {}\nstatic inline void fm10k_dbg_intfc_exit(struct fm10k_intfc *interface) {}\nstatic inline void fm10k_dbg_init(void) {}\nstatic inline void fm10k_dbg_exit(void) {}\n#endif  \n\n \n#ifdef CONFIG_DCB\nvoid fm10k_dcbnl_set_ops(struct net_device *dev);\n#else\nstatic inline void fm10k_dcbnl_set_ops(struct net_device *dev) {}\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}