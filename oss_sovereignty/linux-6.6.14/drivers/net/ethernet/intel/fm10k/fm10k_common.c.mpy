{
  "module_name": "fm10k_common.c",
  "hash_id": "5506f27ddb40946d381a281fa68ab1f55cba3c66c82896ae41f30a093f21d31c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/fm10k/fm10k_common.c",
  "human_readable_source": "\n \n\n#include \"fm10k_common.h\"\n\n \ns32 fm10k_get_bus_info_generic(struct fm10k_hw *hw)\n{\n\tu16 link_cap, link_status, device_cap, device_control;\n\n\t \n\tlink_cap = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_LINK_CAP);\n\n\tswitch (link_cap & FM10K_PCIE_LINK_WIDTH) {\n\tcase FM10K_PCIE_LINK_WIDTH_1:\n\t\thw->bus_caps.width = fm10k_bus_width_pcie_x1;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_WIDTH_2:\n\t\thw->bus_caps.width = fm10k_bus_width_pcie_x2;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_WIDTH_4:\n\t\thw->bus_caps.width = fm10k_bus_width_pcie_x4;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_WIDTH_8:\n\t\thw->bus_caps.width = fm10k_bus_width_pcie_x8;\n\t\tbreak;\n\tdefault:\n\t\thw->bus_caps.width = fm10k_bus_width_unknown;\n\t\tbreak;\n\t}\n\n\tswitch (link_cap & FM10K_PCIE_LINK_SPEED) {\n\tcase FM10K_PCIE_LINK_SPEED_2500:\n\t\thw->bus_caps.speed = fm10k_bus_speed_2500;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_SPEED_5000:\n\t\thw->bus_caps.speed = fm10k_bus_speed_5000;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_SPEED_8000:\n\t\thw->bus_caps.speed = fm10k_bus_speed_8000;\n\t\tbreak;\n\tdefault:\n\t\thw->bus_caps.speed = fm10k_bus_speed_unknown;\n\t\tbreak;\n\t}\n\n\t \n\tdevice_cap = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_DEV_CAP);\n\n\tswitch (device_cap & FM10K_PCIE_DEV_CAP_PAYLOAD) {\n\tcase FM10K_PCIE_DEV_CAP_PAYLOAD_128:\n\t\thw->bus_caps.payload = fm10k_bus_payload_128;\n\t\tbreak;\n\tcase FM10K_PCIE_DEV_CAP_PAYLOAD_256:\n\t\thw->bus_caps.payload = fm10k_bus_payload_256;\n\t\tbreak;\n\tcase FM10K_PCIE_DEV_CAP_PAYLOAD_512:\n\t\thw->bus_caps.payload = fm10k_bus_payload_512;\n\t\tbreak;\n\tdefault:\n\t\thw->bus_caps.payload = fm10k_bus_payload_unknown;\n\t\tbreak;\n\t}\n\n\t \n\tlink_status = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_LINK_STATUS);\n\n\tswitch (link_status & FM10K_PCIE_LINK_WIDTH) {\n\tcase FM10K_PCIE_LINK_WIDTH_1:\n\t\thw->bus.width = fm10k_bus_width_pcie_x1;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_WIDTH_2:\n\t\thw->bus.width = fm10k_bus_width_pcie_x2;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_WIDTH_4:\n\t\thw->bus.width = fm10k_bus_width_pcie_x4;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_WIDTH_8:\n\t\thw->bus.width = fm10k_bus_width_pcie_x8;\n\t\tbreak;\n\tdefault:\n\t\thw->bus.width = fm10k_bus_width_unknown;\n\t\tbreak;\n\t}\n\n\tswitch (link_status & FM10K_PCIE_LINK_SPEED) {\n\tcase FM10K_PCIE_LINK_SPEED_2500:\n\t\thw->bus.speed = fm10k_bus_speed_2500;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_SPEED_5000:\n\t\thw->bus.speed = fm10k_bus_speed_5000;\n\t\tbreak;\n\tcase FM10K_PCIE_LINK_SPEED_8000:\n\t\thw->bus.speed = fm10k_bus_speed_8000;\n\t\tbreak;\n\tdefault:\n\t\thw->bus.speed = fm10k_bus_speed_unknown;\n\t\tbreak;\n\t}\n\n\t \n\tdevice_control = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_DEV_CTRL);\n\n\tswitch (device_control & FM10K_PCIE_DEV_CTRL_PAYLOAD) {\n\tcase FM10K_PCIE_DEV_CTRL_PAYLOAD_128:\n\t\thw->bus.payload = fm10k_bus_payload_128;\n\t\tbreak;\n\tcase FM10K_PCIE_DEV_CTRL_PAYLOAD_256:\n\t\thw->bus.payload = fm10k_bus_payload_256;\n\t\tbreak;\n\tcase FM10K_PCIE_DEV_CTRL_PAYLOAD_512:\n\t\thw->bus.payload = fm10k_bus_payload_512;\n\t\tbreak;\n\tdefault:\n\t\thw->bus.payload = fm10k_bus_payload_unknown;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u16 fm10k_get_pcie_msix_count_generic(struct fm10k_hw *hw)\n{\n\tu16 msix_count;\n\n\t \n\tmsix_count = fm10k_read_pci_cfg_word(hw, FM10K_PCI_MSIX_MSG_CTRL);\n\tmsix_count &= FM10K_PCI_MSIX_MSG_CTRL_TBL_SZ_MASK;\n\n\t \n\tmsix_count++;\n\n\tif (msix_count > FM10K_MAX_MSIX_VECTORS)\n\t\tmsix_count = FM10K_MAX_MSIX_VECTORS;\n\n\treturn msix_count;\n}\n\n \ns32 fm10k_get_invariants_generic(struct fm10k_hw *hw)\n{\n\tstruct fm10k_mac_info *mac = &hw->mac;\n\n\t \n\tmac->dglort_map = FM10K_DGLORTMAP_NONE;\n\n\t \n\tmac->max_msix_vectors = fm10k_get_pcie_msix_count_generic(hw);\n\n\treturn 0;\n}\n\n \ns32 fm10k_start_hw_generic(struct fm10k_hw *hw)\n{\n\t \n\thw->mac.tx_ready = true;\n\n\treturn 0;\n}\n\n \ns32 fm10k_disable_queues_generic(struct fm10k_hw *hw, u16 q_cnt)\n{\n\tu32 reg;\n\tu16 i, time;\n\n\t \n\thw->mac.tx_ready = false;\n\n\tif (FM10K_REMOVED(hw->hw_addr))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < q_cnt; i++) {\n\t\treg = fm10k_read_reg(hw, FM10K_TXDCTL(i));\n\t\tfm10k_write_reg(hw, FM10K_TXDCTL(i),\n\t\t\t\treg & ~FM10K_TXDCTL_ENABLE);\n\t\treg = fm10k_read_reg(hw, FM10K_RXQCTL(i));\n\t\tfm10k_write_reg(hw, FM10K_RXQCTL(i),\n\t\t\t\treg & ~FM10K_RXQCTL_ENABLE);\n\t}\n\n\tfm10k_write_flush(hw);\n\tudelay(1);\n\n\t \n\tfor (i = 0, time = FM10K_QUEUE_DISABLE_TIMEOUT; time;) {\n\t\t \n\t\tif (i == q_cnt)\n\t\t\treturn 0;\n\n\t\t \n\t\treg = fm10k_read_reg(hw, FM10K_TXDCTL(i));\n\t\tif (!~reg || !(reg & FM10K_TXDCTL_ENABLE)) {\n\t\t\treg = fm10k_read_reg(hw, FM10K_RXQCTL(i));\n\t\t\tif (!~reg || !(reg & FM10K_RXQCTL_ENABLE)) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttime--;\n\t\tif (time)\n\t\t\tudelay(1);\n\t}\n\n\treturn FM10K_ERR_REQUESTS_PENDING;\n}\n\n \ns32 fm10k_stop_hw_generic(struct fm10k_hw *hw)\n{\n\treturn fm10k_disable_queues_generic(hw, hw->mac.max_queues);\n}\n\n \nu32 fm10k_read_hw_stats_32b(struct fm10k_hw *hw, u32 addr,\n\t\t\t    struct fm10k_hw_stat *stat)\n{\n\tu32 delta = fm10k_read_reg(hw, addr) - stat->base_l;\n\n\tif (FM10K_REMOVED(hw->hw_addr))\n\t\tstat->base_h = 0;\n\n\treturn delta;\n}\n\n \nstatic u64 fm10k_read_hw_stats_48b(struct fm10k_hw *hw, u32 addr,\n\t\t\t\t   struct fm10k_hw_stat *stat)\n{\n\tu32 count_l;\n\tu32 count_h;\n\tu32 count_tmp;\n\tu64 delta;\n\n\tcount_h = fm10k_read_reg(hw, addr + 1);\n\n\t \n\tdo {\n\t\tcount_tmp = count_h;\n\t\tcount_l = fm10k_read_reg(hw, addr);\n\t\tcount_h = fm10k_read_reg(hw, addr + 1);\n\t} while (count_h != count_tmp);\n\n\tdelta = ((u64)(count_h - stat->base_h) << 32) + count_l;\n\tdelta -= stat->base_l;\n\n\treturn delta & FM10K_48_BIT_MASK;\n}\n\n \nstatic void fm10k_update_hw_base_48b(struct fm10k_hw_stat *stat, u64 delta)\n{\n\tif (!delta)\n\t\treturn;\n\n\t \n\tdelta += stat->base_l;\n\tstat->base_l = (u32)delta;\n\n\t \n\tstat->base_h += (u32)(delta >> 32);\n}\n\n \nstatic void fm10k_update_hw_stats_tx_q(struct fm10k_hw *hw,\n\t\t\t\t       struct fm10k_hw_stats_q *q,\n\t\t\t\t       u32 idx)\n{\n\tu32 id_tx, id_tx_prev, tx_packets;\n\tu64 tx_bytes = 0;\n\n\t \n\tid_tx = fm10k_read_reg(hw, FM10K_TXQCTL(idx));\n\n\t \n\tdo {\n\t\ttx_packets = fm10k_read_hw_stats_32b(hw, FM10K_QPTC(idx),\n\t\t\t\t\t\t     &q->tx_packets);\n\n\t\tif (tx_packets)\n\t\t\ttx_bytes = fm10k_read_hw_stats_48b(hw,\n\t\t\t\t\t\t\t   FM10K_QBTC_L(idx),\n\t\t\t\t\t\t\t   &q->tx_bytes);\n\n\t\t \n\t\tid_tx_prev = id_tx;\n\t\tid_tx = fm10k_read_reg(hw, FM10K_TXQCTL(idx));\n\t} while ((id_tx ^ id_tx_prev) & FM10K_TXQCTL_ID_MASK);\n\n\t \n\tid_tx &= FM10K_TXQCTL_ID_MASK;\n\tid_tx |= FM10K_STAT_VALID;\n\n\t \n\tif (q->tx_stats_idx == id_tx) {\n\t\tq->tx_packets.count += tx_packets;\n\t\tq->tx_bytes.count += tx_bytes;\n\t}\n\n\t \n\tfm10k_update_hw_base_32b(&q->tx_packets, tx_packets);\n\tfm10k_update_hw_base_48b(&q->tx_bytes, tx_bytes);\n\n\tq->tx_stats_idx = id_tx;\n}\n\n \nstatic void fm10k_update_hw_stats_rx_q(struct fm10k_hw *hw,\n\t\t\t\t       struct fm10k_hw_stats_q *q,\n\t\t\t\t       u32 idx)\n{\n\tu32 id_rx, id_rx_prev, rx_packets, rx_drops;\n\tu64 rx_bytes = 0;\n\n\t \n\tid_rx = fm10k_read_reg(hw, FM10K_RXQCTL(idx));\n\n\t \n\tdo {\n\t\trx_drops = fm10k_read_hw_stats_32b(hw, FM10K_QPRDC(idx),\n\t\t\t\t\t\t   &q->rx_drops);\n\n\t\trx_packets = fm10k_read_hw_stats_32b(hw, FM10K_QPRC(idx),\n\t\t\t\t\t\t     &q->rx_packets);\n\n\t\tif (rx_packets)\n\t\t\trx_bytes = fm10k_read_hw_stats_48b(hw,\n\t\t\t\t\t\t\t   FM10K_QBRC_L(idx),\n\t\t\t\t\t\t\t   &q->rx_bytes);\n\n\t\t \n\t\tid_rx_prev = id_rx;\n\t\tid_rx = fm10k_read_reg(hw, FM10K_RXQCTL(idx));\n\t} while ((id_rx ^ id_rx_prev) & FM10K_RXQCTL_ID_MASK);\n\n\t \n\tid_rx &= FM10K_RXQCTL_ID_MASK;\n\tid_rx |= FM10K_STAT_VALID;\n\n\t \n\tif (q->rx_stats_idx == id_rx) {\n\t\tq->rx_drops.count += rx_drops;\n\t\tq->rx_packets.count += rx_packets;\n\t\tq->rx_bytes.count += rx_bytes;\n\t}\n\n\t \n\tfm10k_update_hw_base_32b(&q->rx_drops, rx_drops);\n\tfm10k_update_hw_base_32b(&q->rx_packets, rx_packets);\n\tfm10k_update_hw_base_48b(&q->rx_bytes, rx_bytes);\n\n\tq->rx_stats_idx = id_rx;\n}\n\n \nvoid fm10k_update_hw_stats_q(struct fm10k_hw *hw, struct fm10k_hw_stats_q *q,\n\t\t\t     u32 idx, u32 count)\n{\n\tu32 i;\n\n\tfor (i = 0; i < count; i++, idx++, q++) {\n\t\tfm10k_update_hw_stats_tx_q(hw, q, idx);\n\t\tfm10k_update_hw_stats_rx_q(hw, q, idx);\n\t}\n}\n\n \nvoid fm10k_unbind_hw_stats_q(struct fm10k_hw_stats_q *q, u32 idx, u32 count)\n{\n\tu32 i;\n\n\tfor (i = 0; i < count; i++, idx++, q++) {\n\t\tq->rx_stats_idx = 0;\n\t\tq->tx_stats_idx = 0;\n\t}\n}\n\n \ns32 fm10k_get_host_state_generic(struct fm10k_hw *hw, bool *host_ready)\n{\n\tstruct fm10k_mbx_info *mbx = &hw->mbx;\n\tstruct fm10k_mac_info *mac = &hw->mac;\n\ts32 ret_val = 0;\n\tu32 txdctl = fm10k_read_reg(hw, FM10K_TXDCTL(0));\n\n\t \n\tmbx->ops.process(hw, mbx);\n\n\t \n\tif (!(~txdctl) || !(txdctl & FM10K_TXDCTL_ENABLE))\n\t\tmac->get_host_state = true;\n\n\t \n\tif (!mac->get_host_state || !(~txdctl))\n\t\tgoto out;\n\n\t \n\tif (mac->tx_ready && !(txdctl & FM10K_TXDCTL_ENABLE)) {\n\t\tret_val = FM10K_ERR_RESET_REQUESTED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!mbx->timeout) {\n\t\tret_val = FM10K_ERR_RESET_REQUESTED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (mbx->state != FM10K_STATE_OPEN)\n\t\tgoto out;\n\n\t \n\tif (mac->dglort_map == FM10K_DGLORTMAP_NONE) {\n\t\tif (mac->ops.request_lport_map)\n\t\t\tret_val = mac->ops.request_lport_map(hw);\n\n\t\tgoto out;\n\t}\n\n\t \n\tmac->get_host_state = false;\n\nout:\n\t*host_ready = !mac->get_host_state;\n\treturn ret_val;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}