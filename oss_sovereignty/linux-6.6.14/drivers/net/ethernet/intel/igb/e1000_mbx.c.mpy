{
  "module_name": "e1000_mbx.c",
  "hash_id": "e4007f4875a9d8551dee4c24f4dea39d505615875cb09d387498d827d05ccb3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/e1000_mbx.c",
  "human_readable_source": "\n \n\n#include \"e1000_mbx.h\"\n\n \ns32 igb_read_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id,\n\t\t bool unlock)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\t \n\tif (size > mbx->size)\n\t\tsize = mbx->size;\n\n\tif (mbx->ops.read)\n\t\tret_val = mbx->ops.read(hw, msg, size, mbx_id, unlock);\n\n\treturn ret_val;\n}\n\n \ns32 igb_write_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = 0;\n\n\tif (size > mbx->size)\n\t\tret_val = -E1000_ERR_MBX;\n\n\telse if (mbx->ops.write)\n\t\tret_val = mbx->ops.write(hw, msg, size, mbx_id);\n\n\treturn ret_val;\n}\n\n \ns32 igb_check_for_msg(struct e1000_hw *hw, u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (mbx->ops.check_for_msg)\n\t\tret_val = mbx->ops.check_for_msg(hw, mbx_id);\n\n\treturn ret_val;\n}\n\n \ns32 igb_check_for_ack(struct e1000_hw *hw, u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (mbx->ops.check_for_ack)\n\t\tret_val = mbx->ops.check_for_ack(hw, mbx_id);\n\n\treturn ret_val;\n}\n\n \ns32 igb_check_for_rst(struct e1000_hw *hw, u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (mbx->ops.check_for_rst)\n\t\tret_val = mbx->ops.check_for_rst(hw, mbx_id);\n\n\treturn ret_val;\n}\n\n \ns32 igb_unlock_mbx(struct e1000_hw *hw, u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (mbx->ops.unlock)\n\t\tret_val = mbx->ops.unlock(hw, mbx_id);\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_poll_for_msg(struct e1000_hw *hw, u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!countdown || !mbx->ops.check_for_msg)\n\t\tgoto out;\n\n\twhile (countdown && mbx->ops.check_for_msg(hw, mbx_id)) {\n\t\tcountdown--;\n\t\tif (!countdown)\n\t\t\tbreak;\n\t\tudelay(mbx->usec_delay);\n\t}\n\n\t \n\tif (!countdown)\n\t\tmbx->timeout = 0;\nout:\n\treturn countdown ? 0 : -E1000_ERR_MBX;\n}\n\n \nstatic s32 igb_poll_for_ack(struct e1000_hw *hw, u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!countdown || !mbx->ops.check_for_ack)\n\t\tgoto out;\n\n\twhile (countdown && mbx->ops.check_for_ack(hw, mbx_id)) {\n\t\tcountdown--;\n\t\tif (!countdown)\n\t\t\tbreak;\n\t\tudelay(mbx->usec_delay);\n\t}\n\n\t \n\tif (!countdown)\n\t\tmbx->timeout = 0;\nout:\n\treturn countdown ? 0 : -E1000_ERR_MBX;\n}\n\n \nstatic s32 igb_read_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size,\n\t\t\t       u16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (!mbx->ops.read)\n\t\tgoto out;\n\n\tret_val = igb_poll_for_msg(hw, mbx_id);\n\n\tif (!ret_val)\n\t\tret_val = mbx->ops.read(hw, msg, size, mbx_id, true);\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_write_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size,\n\t\t\t\tu16 mbx_id)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\t \n\tif (!mbx->ops.write || !mbx->timeout)\n\t\tgoto out;\n\n\t \n\tret_val = mbx->ops.write(hw, msg, size, mbx_id);\n\n\t \n\tif (!ret_val)\n\t\tret_val = igb_poll_for_ack(hw, mbx_id);\nout:\n\treturn ret_val;\n}\n\nstatic s32 igb_check_for_bit_pf(struct e1000_hw *hw, u32 mask)\n{\n\tu32 mbvficr = rd32(E1000_MBVFICR);\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (mbvficr & mask) {\n\t\tret_val = 0;\n\t\twr32(E1000_MBVFICR, mask);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_check_for_msg_pf(struct e1000_hw *hw, u16 vf_number)\n{\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (!igb_check_for_bit_pf(hw, E1000_MBVFICR_VFREQ_VF1 << vf_number)) {\n\t\tret_val = 0;\n\t\thw->mbx.stats.reqs++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_check_for_ack_pf(struct e1000_hw *hw, u16 vf_number)\n{\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (!igb_check_for_bit_pf(hw, E1000_MBVFICR_VFACK_VF1 << vf_number)) {\n\t\tret_val = 0;\n\t\thw->mbx.stats.acks++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_check_for_rst_pf(struct e1000_hw *hw, u16 vf_number)\n{\n\tu32 vflre = rd32(E1000_VFLRE);\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (vflre & BIT(vf_number)) {\n\t\tret_val = 0;\n\t\twr32(E1000_VFLRE, BIT(vf_number));\n\t\thw->mbx.stats.rsts++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_obtain_mbx_lock_pf(struct e1000_hw *hw, u16 vf_number)\n{\n\ts32 ret_val = -E1000_ERR_MBX;\n\tu32 p2v_mailbox;\n\tint count = 10;\n\n\tdo {\n\t\t \n\t\twr32(E1000_P2VMAILBOX(vf_number), E1000_P2VMAILBOX_PFU);\n\n\t\t \n\t\tp2v_mailbox = rd32(E1000_P2VMAILBOX(vf_number));\n\t\tif (p2v_mailbox & E1000_P2VMAILBOX_PFU) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1000);\n\t} while (count-- > 0);\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_release_mbx_lock_pf(struct e1000_hw *hw, u16 vf_number)\n{\n\tu32 p2v_mailbox;\n\n\t \n\tp2v_mailbox = rd32(E1000_P2VMAILBOX(vf_number));\n\tif (p2v_mailbox & E1000_P2VMAILBOX_PFU)\n\t\twr32(E1000_P2VMAILBOX(vf_number),\n\t\t     p2v_mailbox & ~E1000_P2VMAILBOX_PFU);\n\n\treturn 0;\n}\n\n \nstatic s32 igb_write_mbx_pf(struct e1000_hw *hw, u32 *msg, u16 size,\n\t\t\t    u16 vf_number)\n{\n\ts32 ret_val;\n\tu16 i;\n\n\t \n\tret_val = igb_obtain_mbx_lock_pf(hw, vf_number);\n\tif (ret_val)\n\t\tgoto out_no_write;\n\n\t \n\tigb_check_for_msg_pf(hw, vf_number);\n\tigb_check_for_ack_pf(hw, vf_number);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tarray_wr32(E1000_VMBMEM(vf_number), i, msg[i]);\n\n\t \n\twr32(E1000_P2VMAILBOX(vf_number), E1000_P2VMAILBOX_STS);\n\n\t \n\thw->mbx.stats.msgs_tx++;\n\nout_no_write:\n\treturn ret_val;\n\n}\n\n \nstatic s32 igb_read_mbx_pf(struct e1000_hw *hw, u32 *msg, u16 size,\n\t\t\t   u16 vf_number, bool unlock)\n{\n\ts32 ret_val;\n\tu16 i;\n\n\t \n\tret_val = igb_obtain_mbx_lock_pf(hw, vf_number);\n\tif (ret_val)\n\t\tgoto out_no_read;\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tmsg[i] = array_rd32(E1000_VMBMEM(vf_number), i);\n\n\t \n\tif (unlock)\n\t\twr32(E1000_P2VMAILBOX(vf_number), E1000_P2VMAILBOX_ACK);\n\telse\n\t\twr32(E1000_P2VMAILBOX(vf_number),\n\t\t     E1000_P2VMAILBOX_ACK | E1000_P2VMAILBOX_PFU);\n\n\t \n\thw->mbx.stats.msgs_rx++;\n\nout_no_read:\n\treturn ret_val;\n}\n\n \ns32 igb_init_mbx_params_pf(struct e1000_hw *hw)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\n\tmbx->timeout = 0;\n\tmbx->usec_delay = 0;\n\n\tmbx->size = E1000_VFMAILBOX_SIZE;\n\n\tmbx->ops.read = igb_read_mbx_pf;\n\tmbx->ops.write = igb_write_mbx_pf;\n\tmbx->ops.read_posted = igb_read_posted_mbx;\n\tmbx->ops.write_posted = igb_write_posted_mbx;\n\tmbx->ops.check_for_msg = igb_check_for_msg_pf;\n\tmbx->ops.check_for_ack = igb_check_for_ack_pf;\n\tmbx->ops.check_for_rst = igb_check_for_rst_pf;\n\tmbx->ops.unlock = igb_release_mbx_lock_pf;\n\n\tmbx->stats.msgs_tx = 0;\n\tmbx->stats.msgs_rx = 0;\n\tmbx->stats.reqs = 0;\n\tmbx->stats.acks = 0;\n\tmbx->stats.rsts = 0;\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}