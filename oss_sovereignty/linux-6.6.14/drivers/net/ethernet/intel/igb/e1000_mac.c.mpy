{
  "module_name": "e1000_mac.c",
  "hash_id": "7560903ffda0bb9520e8addf108020cc202ba6c993a23afa1a67d3b90e2aa878",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/e1000_mac.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n\n#include \"e1000_mac.h\"\n\n#include \"igb.h\"\n\nstatic s32 igb_set_default_fc(struct e1000_hw *hw);\nstatic void igb_set_fc_watermarks(struct e1000_hw *hw);\n\n \ns32 igb_get_bus_info_pcie(struct e1000_hw *hw)\n{\n\tstruct e1000_bus_info *bus = &hw->bus;\n\ts32 ret_val;\n\tu32 reg;\n\tu16 pcie_link_status;\n\n\tbus->type = e1000_bus_type_pci_express;\n\n\tret_val = igb_read_pcie_cap_reg(hw,\n\t\t\t\t\tPCI_EXP_LNKSTA,\n\t\t\t\t\t&pcie_link_status);\n\tif (ret_val) {\n\t\tbus->width = e1000_bus_width_unknown;\n\t\tbus->speed = e1000_bus_speed_unknown;\n\t} else {\n\t\tswitch (pcie_link_status & PCI_EXP_LNKSTA_CLS) {\n\t\tcase PCI_EXP_LNKSTA_CLS_2_5GB:\n\t\t\tbus->speed = e1000_bus_speed_2500;\n\t\t\tbreak;\n\t\tcase PCI_EXP_LNKSTA_CLS_5_0GB:\n\t\t\tbus->speed = e1000_bus_speed_5000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbus->speed = e1000_bus_speed_unknown;\n\t\t\tbreak;\n\t\t}\n\n\t\tbus->width = (enum e1000_bus_width)((pcie_link_status &\n\t\t\t\t\t\t     PCI_EXP_LNKSTA_NLW) >>\n\t\t\t\t\t\t     PCI_EXP_LNKSTA_NLW_SHIFT);\n\t}\n\n\treg = rd32(E1000_STATUS);\n\tbus->func = (reg & E1000_STATUS_FUNC_MASK) >> E1000_STATUS_FUNC_SHIFT;\n\n\treturn 0;\n}\n\n \nvoid igb_clear_vfta(struct e1000_hw *hw)\n{\n\tu32 offset;\n\n\tfor (offset = E1000_VLAN_FILTER_TBL_SIZE; offset--;)\n\t\thw->mac.ops.write_vfta(hw, offset, 0);\n}\n\n \nvoid igb_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\n\tarray_wr32(E1000_VFTA, offset, value);\n\twrfl();\n\n\tadapter->shadow_vfta[offset] = value;\n}\n\n \nvoid igb_init_rx_addrs(struct e1000_hw *hw, u16 rar_count)\n{\n\tu32 i;\n\tu8 mac_addr[ETH_ALEN] = {0};\n\n\t \n\thw_dbg(\"Programming MAC Address into RAR[0]\\n\");\n\n\thw->mac.ops.rar_set(hw, hw->mac.addr, 0);\n\n\t \n\thw_dbg(\"Clearing RAR[1-%u]\\n\", rar_count-1);\n\tfor (i = 1; i < rar_count; i++)\n\t\thw->mac.ops.rar_set(hw, mac_addr, i);\n}\n\n \nstatic s32 igb_find_vlvf_slot(struct e1000_hw *hw, u32 vlan, bool vlvf_bypass)\n{\n\ts32 regindex, first_empty_slot;\n\tu32 bits;\n\n\t \n\tif (vlan == 0)\n\t\treturn 0;\n\n\t \n\tfirst_empty_slot = vlvf_bypass ? -E1000_ERR_NO_SPACE : 0;\n\n\t \n\tfor (regindex = E1000_VLVF_ARRAY_SIZE; --regindex > 0;) {\n\t\tbits = rd32(E1000_VLVF(regindex)) & E1000_VLVF_VLANID_MASK;\n\t\tif (bits == vlan)\n\t\t\treturn regindex;\n\t\tif (!first_empty_slot && !bits)\n\t\t\tfirst_empty_slot = regindex;\n\t}\n\n\treturn first_empty_slot ? : -E1000_ERR_NO_SPACE;\n}\n\n \ns32 igb_vfta_set(struct e1000_hw *hw, u32 vlan, u32 vind,\n\t\t bool vlan_on, bool vlvf_bypass)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\tu32 regidx, vfta_delta, vfta, bits;\n\ts32 vlvf_index;\n\n\tif ((vlan > 4095) || (vind > 7))\n\t\treturn -E1000_ERR_PARAM;\n\n\t \n\n\t \n\tregidx = vlan / 32;\n\tvfta_delta = BIT(vlan % 32);\n\tvfta = adapter->shadow_vfta[regidx];\n\n\t \n\tvfta_delta &= vlan_on ? ~vfta : vfta;\n\tvfta ^= vfta_delta;\n\n\t \n\tif (!adapter->vfs_allocated_count)\n\t\tgoto vfta_update;\n\n\tvlvf_index = igb_find_vlvf_slot(hw, vlan, vlvf_bypass);\n\tif (vlvf_index < 0) {\n\t\tif (vlvf_bypass)\n\t\t\tgoto vfta_update;\n\t\treturn vlvf_index;\n\t}\n\n\tbits = rd32(E1000_VLVF(vlvf_index));\n\n\t \n\tbits |= BIT(E1000_VLVF_POOLSEL_SHIFT + vind);\n\tif (vlan_on)\n\t\tgoto vlvf_update;\n\n\t \n\tbits ^= BIT(E1000_VLVF_POOLSEL_SHIFT + vind);\n\n\tif (!(bits & E1000_VLVF_POOLSEL_MASK)) {\n\t\t \n\t\tif (vfta_delta)\n\t\t\thw->mac.ops.write_vfta(hw, regidx, vfta);\n\n\t\t \n\t\twr32(E1000_VLVF(vlvf_index), 0);\n\n\t\treturn 0;\n\t}\n\n\t \n\tvfta_delta = 0;\n\nvlvf_update:\n\t \n\twr32(E1000_VLVF(vlvf_index), bits | vlan | E1000_VLVF_VLANID_ENABLE);\n\nvfta_update:\n\t \n\tif (vfta_delta)\n\t\thw->mac.ops.write_vfta(hw, regidx, vfta);\n\n\treturn 0;\n}\n\n \ns32 igb_check_alt_mac_addr(struct e1000_hw *hw)\n{\n\tu32 i;\n\ts32 ret_val = 0;\n\tu16 offset, nvm_alt_mac_addr_offset, nvm_data;\n\tu8 alt_mac_addr[ETH_ALEN];\n\n\t \n\tif (hw->mac.type >= e1000_82580)\n\t\tgoto out;\n\n\tret_val = hw->nvm.ops.read(hw, NVM_ALT_MAC_ADDR_PTR, 1,\n\t\t\t\t &nvm_alt_mac_addr_offset);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((nvm_alt_mac_addr_offset == 0xFFFF) ||\n\t    (nvm_alt_mac_addr_offset == 0x0000))\n\t\t \n\t\tgoto out;\n\n\tif (hw->bus.func == E1000_FUNC_1)\n\t\tnvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN1;\n\tif (hw->bus.func == E1000_FUNC_2)\n\t\tnvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN2;\n\n\tif (hw->bus.func == E1000_FUNC_3)\n\t\tnvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN3;\n\tfor (i = 0; i < ETH_ALEN; i += 2) {\n\t\toffset = nvm_alt_mac_addr_offset + (i >> 1);\n\t\tret_val = hw->nvm.ops.read(hw, offset, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\talt_mac_addr[i] = (u8)(nvm_data & 0xFF);\n\t\talt_mac_addr[i + 1] = (u8)(nvm_data >> 8);\n\t}\n\n\t \n\tif (is_multicast_ether_addr(alt_mac_addr)) {\n\t\thw_dbg(\"Ignoring Alternate Mac Address with MC bit set\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\thw->mac.ops.rar_set(hw, alt_mac_addr, 0);\n\nout:\n\treturn ret_val;\n}\n\n \nvoid igb_rar_set(struct e1000_hw *hw, u8 *addr, u32 index)\n{\n\tu32 rar_low, rar_high;\n\n\t \n\trar_low = ((u32) addr[0] |\n\t\t   ((u32) addr[1] << 8) |\n\t\t    ((u32) addr[2] << 16) | ((u32) addr[3] << 24));\n\n\trar_high = ((u32) addr[4] | ((u32) addr[5] << 8));\n\n\t \n\tif (rar_low || rar_high)\n\t\trar_high |= E1000_RAH_AV;\n\n\t \n\twr32(E1000_RAL(index), rar_low);\n\twrfl();\n\twr32(E1000_RAH(index), rar_high);\n\twrfl();\n}\n\n \nvoid igb_mta_set(struct e1000_hw *hw, u32 hash_value)\n{\n\tu32 hash_bit, hash_reg, mta;\n\n\t \n\thash_reg = (hash_value >> 5) & (hw->mac.mta_reg_count - 1);\n\thash_bit = hash_value & 0x1F;\n\n\tmta = array_rd32(E1000_MTA, hash_reg);\n\n\tmta |= BIT(hash_bit);\n\n\tarray_wr32(E1000_MTA, hash_reg, mta);\n\twrfl();\n}\n\n \nstatic u32 igb_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)\n{\n\tu32 hash_value, hash_mask;\n\tu8 bit_shift = 1;\n\n\t \n\thash_mask = (hw->mac.mta_reg_count * 32) - 1;\n\n\t \n\twhile (hash_mask >> bit_shift != 0xFF && bit_shift < 4)\n\t\tbit_shift++;\n\n\t \n\tswitch (hw->mac.mc_filter_type) {\n\tdefault:\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tbit_shift += 1;\n\t\tbreak;\n\tcase 2:\n\t\tbit_shift += 2;\n\t\tbreak;\n\tcase 3:\n\t\tbit_shift += 4;\n\t\tbreak;\n\t}\n\n\thash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\n\t\t\t\t  (((u16) mc_addr[5]) << bit_shift)));\n\n\treturn hash_value;\n}\n\n \nstatic void igb_i21x_hw_doublecheck(struct e1000_hw *hw)\n{\n\tint failed_cnt = 3;\n\tbool is_failed;\n\tint i;\n\n\tdo {\n\t\tis_failed = false;\n\t\tfor (i = hw->mac.mta_reg_count - 1; i >= 0; i--) {\n\t\t\tif (array_rd32(E1000_MTA, i) != hw->mac.mta_shadow[i]) {\n\t\t\t\tis_failed = true;\n\t\t\t\tarray_wr32(E1000_MTA, i, hw->mac.mta_shadow[i]);\n\t\t\t\twrfl();\n\t\t\t}\n\t\t}\n\t\tif (is_failed && --failed_cnt <= 0) {\n\t\t\thw_dbg(\"Failed to update MTA_REGISTER, too many retries\");\n\t\t\tbreak;\n\t\t}\n\t} while (is_failed);\n}\n\n \nvoid igb_update_mc_addr_list(struct e1000_hw *hw,\n\t\t\t     u8 *mc_addr_list, u32 mc_addr_count)\n{\n\tu32 hash_value, hash_bit, hash_reg;\n\tint i;\n\n\t \n\tmemset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));\n\n\t \n\tfor (i = 0; (u32) i < mc_addr_count; i++) {\n\t\thash_value = igb_hash_mc_addr(hw, mc_addr_list);\n\n\t\thash_reg = (hash_value >> 5) & (hw->mac.mta_reg_count - 1);\n\t\thash_bit = hash_value & 0x1F;\n\n\t\thw->mac.mta_shadow[hash_reg] |= BIT(hash_bit);\n\t\tmc_addr_list += (ETH_ALEN);\n\t}\n\n\t \n\tfor (i = hw->mac.mta_reg_count - 1; i >= 0; i--)\n\t\tarray_wr32(E1000_MTA, i, hw->mac.mta_shadow[i]);\n\twrfl();\n\tif (hw->mac.type == e1000_i210 || hw->mac.type == e1000_i211)\n\t\tigb_i21x_hw_doublecheck(hw);\n}\n\n \nvoid igb_clear_hw_cntrs_base(struct e1000_hw *hw)\n{\n\trd32(E1000_CRCERRS);\n\trd32(E1000_SYMERRS);\n\trd32(E1000_MPC);\n\trd32(E1000_SCC);\n\trd32(E1000_ECOL);\n\trd32(E1000_MCC);\n\trd32(E1000_LATECOL);\n\trd32(E1000_COLC);\n\trd32(E1000_DC);\n\trd32(E1000_SEC);\n\trd32(E1000_RLEC);\n\trd32(E1000_XONRXC);\n\trd32(E1000_XONTXC);\n\trd32(E1000_XOFFRXC);\n\trd32(E1000_XOFFTXC);\n\trd32(E1000_FCRUC);\n\trd32(E1000_GPRC);\n\trd32(E1000_BPRC);\n\trd32(E1000_MPRC);\n\trd32(E1000_GPTC);\n\trd32(E1000_GORCL);\n\trd32(E1000_GORCH);\n\trd32(E1000_GOTCL);\n\trd32(E1000_GOTCH);\n\trd32(E1000_RNBC);\n\trd32(E1000_RUC);\n\trd32(E1000_RFC);\n\trd32(E1000_ROC);\n\trd32(E1000_RJC);\n\trd32(E1000_TORL);\n\trd32(E1000_TORH);\n\trd32(E1000_TOTL);\n\trd32(E1000_TOTH);\n\trd32(E1000_TPR);\n\trd32(E1000_TPT);\n\trd32(E1000_MPTC);\n\trd32(E1000_BPTC);\n}\n\n \ns32 igb_check_for_copper_link(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val;\n\tbool link;\n\n\t \n\tif (!mac->get_link_status) {\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tret_val = igb_phy_has_link(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!link)\n\t\tgoto out;  \n\n\tmac->get_link_status = false;\n\n\t \n\tigb_check_downshift(hw);\n\n\t \n\tif (!mac->autoneg) {\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\t \n\tigb_config_collision_dist(hw);\n\n\t \n\tret_val = igb_config_fc_after_link_up(hw);\n\tif (ret_val)\n\t\thw_dbg(\"Error configuring flow control\\n\");\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_setup_link(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\t \n\tif (igb_check_reset_block(hw))\n\t\tgoto out;\n\n\t \n\tif (hw->fc.requested_mode == e1000_fc_default) {\n\t\tret_val = igb_set_default_fc(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\t \n\thw->fc.current_mode = hw->fc.requested_mode;\n\n\thw_dbg(\"After fix-ups FlowControl is now = %x\\n\", hw->fc.current_mode);\n\n\t \n\tret_val = hw->mac.ops.setup_physical_interface(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\thw_dbg(\"Initializing the Flow Control address, type and timer regs\\n\");\n\twr32(E1000_FCT, FLOW_CONTROL_TYPE);\n\twr32(E1000_FCAH, FLOW_CONTROL_ADDRESS_HIGH);\n\twr32(E1000_FCAL, FLOW_CONTROL_ADDRESS_LOW);\n\n\twr32(E1000_FCTTV, hw->fc.pause_time);\n\n\tigb_set_fc_watermarks(hw);\n\nout:\n\n\treturn ret_val;\n}\n\n \nvoid igb_config_collision_dist(struct e1000_hw *hw)\n{\n\tu32 tctl;\n\n\ttctl = rd32(E1000_TCTL);\n\n\ttctl &= ~E1000_TCTL_COLD;\n\ttctl |= E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT;\n\n\twr32(E1000_TCTL, tctl);\n\twrfl();\n}\n\n \nstatic void igb_set_fc_watermarks(struct e1000_hw *hw)\n{\n\tu32 fcrtl = 0, fcrth = 0;\n\n\t \n\tif (hw->fc.current_mode & e1000_fc_tx_pause) {\n\t\t \n\t\tfcrtl = hw->fc.low_water;\n\t\tif (hw->fc.send_xon)\n\t\t\tfcrtl |= E1000_FCRTL_XONE;\n\n\t\tfcrth = hw->fc.high_water;\n\t}\n\twr32(E1000_FCRTL, fcrtl);\n\twr32(E1000_FCRTH, fcrth);\n}\n\n \nstatic s32 igb_set_default_fc(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 lan_offset;\n\tu16 nvm_data;\n\n\t \n\tif (hw->mac.type == e1000_i350)\n\t\tlan_offset = NVM_82580_LAN_FUNC_OFFSET(hw->bus.func);\n\telse\n\t\tlan_offset = 0;\n\n\tret_val = hw->nvm.ops.read(hw, NVM_INIT_CONTROL2_REG + lan_offset,\n\t\t\t\t   1, &nvm_data);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((nvm_data & NVM_WORD0F_PAUSE_MASK) == 0)\n\t\thw->fc.requested_mode = e1000_fc_none;\n\telse if ((nvm_data & NVM_WORD0F_PAUSE_MASK) == NVM_WORD0F_ASM_DIR)\n\t\thw->fc.requested_mode = e1000_fc_tx_pause;\n\telse\n\t\thw->fc.requested_mode = e1000_fc_full;\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_force_mac_fc(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val = 0;\n\n\tctrl = rd32(E1000_CTRL);\n\n\t \n\thw_dbg(\"hw->fc.current_mode = %u\\n\", hw->fc.current_mode);\n\n\tswitch (hw->fc.current_mode) {\n\tcase e1000_fc_none:\n\t\tctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));\n\t\tbreak;\n\tcase e1000_fc_rx_pause:\n\t\tctrl &= (~E1000_CTRL_TFCE);\n\t\tctrl |= E1000_CTRL_RFCE;\n\t\tbreak;\n\tcase e1000_fc_tx_pause:\n\t\tctrl &= (~E1000_CTRL_RFCE);\n\t\tctrl |= E1000_CTRL_TFCE;\n\t\tbreak;\n\tcase e1000_fc_full:\n\t\tctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(\"Flow control param set incorrectly\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\twr32(E1000_CTRL, ctrl);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_config_fc_after_link_up(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val = 0;\n\tu32 pcs_status_reg, pcs_adv_reg, pcs_lp_ability_reg, pcs_ctrl_reg;\n\tu16 mii_status_reg, mii_nway_adv_reg, mii_nway_lp_ability_reg;\n\tu16 speed, duplex;\n\n\t \n\tif (mac->autoneg_failed) {\n\t\tif (hw->phy.media_type == e1000_media_type_internal_serdes)\n\t\t\tret_val = igb_force_mac_fc(hw);\n\t} else {\n\t\tif (hw->phy.media_type == e1000_media_type_copper)\n\t\t\tret_val = igb_force_mac_fc(hw);\n\t}\n\n\tif (ret_val) {\n\t\thw_dbg(\"Error forcing flow control settings\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif ((hw->phy.media_type == e1000_media_type_copper) && mac->autoneg) {\n\t\t \n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS,\n\t\t\t\t\t\t   &mii_status_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS,\n\t\t\t\t\t\t   &mii_status_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (!(mii_status_reg & MII_SR_AUTONEG_COMPLETE)) {\n\t\t\thw_dbg(\"Copper PHY and Auto Neg has not completed.\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_AUTONEG_ADV,\n\t\t\t\t\t    &mii_nway_adv_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_LP_ABILITY,\n\t\t\t\t\t    &mii_nway_lp_ability_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tif ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {\n\t\t\t \n\t\t\tif (hw->fc.requested_mode == e1000_fc_full) {\n\t\t\t\thw->fc.current_mode = e1000_fc_full;\n\t\t\t\thw_dbg(\"Flow Control = FULL.\\n\");\n\t\t\t} else {\n\t\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\t\thw_dbg(\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t\t  (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\n\t\t\t  (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\n\t\t\t  (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\n\t\t\thw->fc.current_mode = e1000_fc_tx_pause;\n\t\t\thw_dbg(\"Flow Control = TX PAUSE frames only.\\n\");\n\t\t}\n\t\t \n\t\telse if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t\t (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\n\t\t\t !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\n\t\t\t (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\n\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\thw_dbg(\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t}\n\t\t \n\t\telse if ((hw->fc.requested_mode == e1000_fc_none) ||\n\t\t\t (hw->fc.requested_mode == e1000_fc_tx_pause) ||\n\t\t\t (hw->fc.strict_ieee)) {\n\t\t\thw->fc.current_mode = e1000_fc_none;\n\t\t\thw_dbg(\"Flow Control = NONE.\\n\");\n\t\t} else {\n\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\thw_dbg(\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t}\n\n\t\t \n\t\tret_val = hw->mac.ops.get_speed_and_duplex(hw, &speed, &duplex);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error getting link speed and duplex\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (duplex == HALF_DUPLEX)\n\t\t\thw->fc.current_mode = e1000_fc_none;\n\n\t\t \n\t\tret_val = igb_force_mac_fc(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error forcing flow control settings\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tif ((hw->phy.media_type == e1000_media_type_internal_serdes)\n\t\t&& mac->autoneg) {\n\t\t \n\t\tpcs_status_reg = rd32(E1000_PCS_LSTAT);\n\n\t\tif (!(pcs_status_reg & E1000_PCS_LSTS_AN_COMPLETE)) {\n\t\t\thw_dbg(\"PCS Auto Neg has not completed.\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\tpcs_adv_reg = rd32(E1000_PCS_ANADV);\n\t\tpcs_lp_ability_reg = rd32(E1000_PCS_LPAB);\n\n\t\t \n\t\tif ((pcs_adv_reg & E1000_TXCW_PAUSE) &&\n\t\t    (pcs_lp_ability_reg & E1000_TXCW_PAUSE)) {\n\t\t\t \n\t\t\tif (hw->fc.requested_mode == e1000_fc_full) {\n\t\t\t\thw->fc.current_mode = e1000_fc_full;\n\t\t\t\thw_dbg(\"Flow Control = FULL.\\n\");\n\t\t\t} else {\n\t\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\t\thw_dbg(\"Flow Control = Rx PAUSE frames only.\\n\");\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (!(pcs_adv_reg & E1000_TXCW_PAUSE) &&\n\t\t\t  (pcs_adv_reg & E1000_TXCW_ASM_DIR) &&\n\t\t\t  (pcs_lp_ability_reg & E1000_TXCW_PAUSE) &&\n\t\t\t  (pcs_lp_ability_reg & E1000_TXCW_ASM_DIR)) {\n\t\t\thw->fc.current_mode = e1000_fc_tx_pause;\n\t\t\thw_dbg(\"Flow Control = Tx PAUSE frames only.\\n\");\n\t\t}\n\t\t \n\t\telse if ((pcs_adv_reg & E1000_TXCW_PAUSE) &&\n\t\t\t (pcs_adv_reg & E1000_TXCW_ASM_DIR) &&\n\t\t\t !(pcs_lp_ability_reg & E1000_TXCW_PAUSE) &&\n\t\t\t (pcs_lp_ability_reg & E1000_TXCW_ASM_DIR)) {\n\t\t\thw->fc.current_mode = e1000_fc_rx_pause;\n\t\t\thw_dbg(\"Flow Control = Rx PAUSE frames only.\\n\");\n\t\t} else {\n\t\t\t \n\t\t\thw->fc.current_mode = e1000_fc_none;\n\t\t\thw_dbg(\"Flow Control = NONE.\\n\");\n\t\t}\n\n\t\t \n\t\tpcs_ctrl_reg = rd32(E1000_PCS_LCTL);\n\t\tpcs_ctrl_reg |= E1000_PCS_LCTL_FORCE_FCTRL;\n\t\twr32(E1000_PCS_LCTL, pcs_ctrl_reg);\n\n\t\tret_val = igb_force_mac_fc(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error forcing flow control settings\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_get_speed_and_duplex_copper(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t      u16 *duplex)\n{\n\tu32 status;\n\n\tstatus = rd32(E1000_STATUS);\n\tif (status & E1000_STATUS_SPEED_1000) {\n\t\t*speed = SPEED_1000;\n\t\thw_dbg(\"1000 Mbs, \");\n\t} else if (status & E1000_STATUS_SPEED_100) {\n\t\t*speed = SPEED_100;\n\t\thw_dbg(\"100 Mbs, \");\n\t} else {\n\t\t*speed = SPEED_10;\n\t\thw_dbg(\"10 Mbs, \");\n\t}\n\n\tif (status & E1000_STATUS_FD) {\n\t\t*duplex = FULL_DUPLEX;\n\t\thw_dbg(\"Full Duplex\\n\");\n\t} else {\n\t\t*duplex = HALF_DUPLEX;\n\t\thw_dbg(\"Half Duplex\\n\");\n\t}\n\n\treturn 0;\n}\n\n \ns32 igb_get_hw_semaphore(struct e1000_hw *hw)\n{\n\tu32 swsm;\n\ts32 ret_val = 0;\n\ts32 timeout = hw->nvm.word_size + 1;\n\ts32 i = 0;\n\n\t \n\twhile (i < timeout) {\n\t\tswsm = rd32(E1000_SWSM);\n\t\tif (!(swsm & E1000_SWSM_SMBI))\n\t\t\tbreak;\n\n\t\tudelay(50);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\thw_dbg(\"Driver can't access device - SMBI bit is set.\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tswsm = rd32(E1000_SWSM);\n\t\twr32(E1000_SWSM, swsm | E1000_SWSM_SWESMBI);\n\n\t\t \n\t\tif (rd32(E1000_SWSM) & E1000_SWSM_SWESMBI)\n\t\t\tbreak;\n\n\t\tudelay(50);\n\t}\n\n\tif (i == timeout) {\n\t\t \n\t\tigb_put_hw_semaphore(hw);\n\t\thw_dbg(\"Driver can't access the NVM\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nvoid igb_put_hw_semaphore(struct e1000_hw *hw)\n{\n\tu32 swsm;\n\n\tswsm = rd32(E1000_SWSM);\n\n\tswsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);\n\n\twr32(E1000_SWSM, swsm);\n}\n\n \ns32 igb_get_auto_rd_done(struct e1000_hw *hw)\n{\n\ts32 i = 0;\n\ts32 ret_val = 0;\n\n\n\twhile (i < AUTO_READ_DONE_TIMEOUT) {\n\t\tif (rd32(E1000_EECD) & E1000_EECD_AUTO_RD)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\ti++;\n\t}\n\n\tif (i == AUTO_READ_DONE_TIMEOUT) {\n\t\thw_dbg(\"Auto read by HW from NVM has not completed.\\n\");\n\t\tret_val = -E1000_ERR_RESET;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_valid_led_default(struct e1000_hw *hw, u16 *data)\n{\n\ts32 ret_val;\n\n\tret_val = hw->nvm.ops.read(hw, NVM_ID_LED_SETTINGS, 1, data);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (*data == ID_LED_RESERVED_0000 || *data == ID_LED_RESERVED_FFFF) {\n\t\tswitch (hw->phy.media_type) {\n\t\tcase e1000_media_type_internal_serdes:\n\t\t\t*data = ID_LED_DEFAULT_82575_SERDES;\n\t\t\tbreak;\n\t\tcase e1000_media_type_copper:\n\t\tdefault:\n\t\t\t*data = ID_LED_DEFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_id_led_init(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val;\n\tconst u32 ledctl_mask = 0x000000FF;\n\tconst u32 ledctl_on = E1000_LEDCTL_MODE_LED_ON;\n\tconst u32 ledctl_off = E1000_LEDCTL_MODE_LED_OFF;\n\tu16 data, i, temp;\n\tconst u16 led_mask = 0x0F;\n\n\t \n\tif ((hw->mac.type == e1000_i210) ||\n\t    (hw->mac.type == e1000_i211))\n\t\tret_val = igb_valid_led_default_i210(hw, &data);\n\telse\n\t\tret_val = igb_valid_led_default(hw, &data);\n\n\tif (ret_val)\n\t\tgoto out;\n\n\tmac->ledctl_default = rd32(E1000_LEDCTL);\n\tmac->ledctl_mode1 = mac->ledctl_default;\n\tmac->ledctl_mode2 = mac->ledctl_default;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttemp = (data >> (i << 2)) & led_mask;\n\t\tswitch (temp) {\n\t\tcase ID_LED_ON1_DEF2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\t\tmac->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode1 |= ledctl_on << (i << 3);\n\t\t\tbreak;\n\t\tcase ID_LED_OFF1_DEF2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\tmac->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode1 |= ledctl_off << (i << 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tswitch (temp) {\n\t\tcase ID_LED_DEF1_ON2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\t\tmac->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode2 |= ledctl_on << (i << 3);\n\t\t\tbreak;\n\t\tcase ID_LED_DEF1_OFF2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\tmac->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\n\t\t\tmac->ledctl_mode2 |= ledctl_off << (i << 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_cleanup_led(struct e1000_hw *hw)\n{\n\twr32(E1000_LEDCTL, hw->mac.ledctl_default);\n\treturn 0;\n}\n\n \ns32 igb_blink_led(struct e1000_hw *hw)\n{\n\tu32 ledctl_blink = 0;\n\tu32 i;\n\n\tif (hw->phy.media_type == e1000_media_type_fiber) {\n\t\t \n\t\tledctl_blink = E1000_LEDCTL_LED0_BLINK |\n\t\t     (E1000_LEDCTL_MODE_LED_ON << E1000_LEDCTL_LED0_MODE_SHIFT);\n\t} else {\n\t\t \n\t\tledctl_blink = hw->mac.ledctl_mode2;\n\t\tfor (i = 0; i < 32; i += 8) {\n\t\t\tu32 mode = (hw->mac.ledctl_mode2 >> i) &\n\t\t\t    E1000_LEDCTL_LED0_MODE_MASK;\n\t\t\tu32 led_default = hw->mac.ledctl_default >> i;\n\n\t\t\tif ((!(led_default & E1000_LEDCTL_LED0_IVRT) &&\n\t\t\t     (mode == E1000_LEDCTL_MODE_LED_ON)) ||\n\t\t\t    ((led_default & E1000_LEDCTL_LED0_IVRT) &&\n\t\t\t     (mode == E1000_LEDCTL_MODE_LED_OFF))) {\n\t\t\t\tledctl_blink &=\n\t\t\t\t    ~(E1000_LEDCTL_LED0_MODE_MASK << i);\n\t\t\t\tledctl_blink |= (E1000_LEDCTL_LED0_BLINK |\n\t\t\t\t\t\t E1000_LEDCTL_MODE_LED_ON) << i;\n\t\t\t}\n\t\t}\n\t}\n\n\twr32(E1000_LEDCTL, ledctl_blink);\n\n\treturn 0;\n}\n\n \ns32 igb_led_off(struct e1000_hw *hw)\n{\n\tswitch (hw->phy.media_type) {\n\tcase e1000_media_type_copper:\n\t\twr32(E1000_LEDCTL, hw->mac.ledctl_mode1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \ns32 igb_disable_pcie_master(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 timeout = MASTER_DISABLE_TIMEOUT;\n\ts32 ret_val = 0;\n\n\tif (hw->bus.type != e1000_bus_type_pci_express)\n\t\tgoto out;\n\n\tctrl = rd32(E1000_CTRL);\n\tctrl |= E1000_CTRL_GIO_MASTER_DISABLE;\n\twr32(E1000_CTRL, ctrl);\n\n\twhile (timeout) {\n\t\tif (!(rd32(E1000_STATUS) &\n\t\t      E1000_STATUS_GIO_MASTER_ENABLE))\n\t\t\tbreak;\n\t\tudelay(100);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\thw_dbg(\"Master requests are pending.\\n\");\n\t\tret_val = -E1000_ERR_MASTER_REQUESTS_PENDING;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_validate_mdi_setting(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\t \n\tif (hw->mac.type >= e1000_82580)\n\t\tgoto out;\n\n\tif (!hw->mac.autoneg && (hw->phy.mdix == 0 || hw->phy.mdix == 3)) {\n\t\thw_dbg(\"Invalid MDI setting detected\\n\");\n\t\thw->phy.mdix = 1;\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_write_8bit_ctrl_reg(struct e1000_hw *hw, u32 reg,\n\t\t\t      u32 offset, u8 data)\n{\n\tu32 i, regvalue = 0;\n\ts32 ret_val = 0;\n\n\t \n\tregvalue = ((u32)data) | (offset << E1000_GEN_CTL_ADDRESS_SHIFT);\n\twr32(reg, regvalue);\n\n\t \n\tfor (i = 0; i < E1000_GEN_POLL_TIMEOUT; i++) {\n\t\tudelay(5);\n\t\tregvalue = rd32(reg);\n\t\tif (regvalue & E1000_GEN_CTL_READY)\n\t\t\tbreak;\n\t}\n\tif (!(regvalue & E1000_GEN_CTL_READY)) {\n\t\thw_dbg(\"Reg %08x did not indicate ready\\n\", reg);\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nbool igb_enable_mng_pass_thru(struct e1000_hw *hw)\n{\n\tu32 manc;\n\tu32 fwsm, factps;\n\tbool ret_val = false;\n\n\tif (!hw->mac.asf_firmware_present)\n\t\tgoto out;\n\n\tmanc = rd32(E1000_MANC);\n\n\tif (!(manc & E1000_MANC_RCV_TCO_EN))\n\t\tgoto out;\n\n\tif (hw->mac.arc_subsystem_valid) {\n\t\tfwsm = rd32(E1000_FWSM);\n\t\tfactps = rd32(E1000_FACTPS);\n\n\t\tif (!(factps & E1000_FACTPS_MNGCG) &&\n\t\t    ((fwsm & E1000_FWSM_MODE_MASK) ==\n\t\t     (e1000_mng_mode_pt << E1000_FWSM_MODE_SHIFT))) {\n\t\t\tret_val = true;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((manc & E1000_MANC_SMBUS_EN) &&\n\t\t    !(manc & E1000_MANC_ASF_EN)) {\n\t\t\tret_val = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}