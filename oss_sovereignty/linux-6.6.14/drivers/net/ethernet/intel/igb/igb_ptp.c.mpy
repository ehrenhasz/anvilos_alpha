{
  "module_name": "igb_ptp.c",
  "hash_id": "ed6dcf57c2e3bab93f0f750ac3e5023d6da9a0f9c5064614926dbc0222172a3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/igb_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/ptp_classify.h>\n\n#include \"igb.h\"\n\n#define INCVALUE_MASK\t\t0x7fffffff\n#define ISGN\t\t\t0x80000000\n\n \n\n#define IGB_SYSTIM_OVERFLOW_PERIOD\t(HZ * 60 * 6)\n#define IGB_PTP_TX_TIMEOUT\t\t(HZ * 15)\n#define INCPERIOD_82576\t\t\tBIT(E1000_TIMINCA_16NS_SHIFT)\n#define INCVALUE_82576_MASK\t\tGENMASK(E1000_TIMINCA_16NS_SHIFT - 1, 0)\n#define INCVALUE_82576\t\t\t(16u << IGB_82576_TSYNC_SHIFT)\n#define IGB_NBITS_82580\t\t\t40\n#define IGB_82580_BASE_PERIOD\t\t0x800000000\n\nstatic void igb_ptp_tx_hwtstamp(struct igb_adapter *adapter);\nstatic void igb_ptp_sdp_init(struct igb_adapter *adapter);\n\n \nstatic u64 igb_ptp_read_82576(const struct cyclecounter *cc)\n{\n\tstruct igb_adapter *igb = container_of(cc, struct igb_adapter, cc);\n\tstruct e1000_hw *hw = &igb->hw;\n\tu64 val;\n\tu32 lo, hi;\n\n\tlo = rd32(E1000_SYSTIML);\n\thi = rd32(E1000_SYSTIMH);\n\n\tval = ((u64) hi) << 32;\n\tval |= lo;\n\n\treturn val;\n}\n\n \nstatic u64 igb_ptp_read_82580(const struct cyclecounter *cc)\n{\n\tstruct igb_adapter *igb = container_of(cc, struct igb_adapter, cc);\n\tstruct e1000_hw *hw = &igb->hw;\n\tu32 lo, hi;\n\tu64 val;\n\n\t \n\trd32(E1000_SYSTIMR);\n\tlo = rd32(E1000_SYSTIML);\n\thi = rd32(E1000_SYSTIMH);\n\n\tval = ((u64) hi) << 32;\n\tval |= lo;\n\n\treturn val;\n}\n\n \nstatic void igb_ptp_read_i210(struct igb_adapter *adapter,\n\t\t\t      struct timespec64 *ts)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 sec, nsec;\n\n\t \n\trd32(E1000_SYSTIMR);\n\tnsec = rd32(E1000_SYSTIML);\n\tsec = rd32(E1000_SYSTIMH);\n\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}\n\nstatic void igb_ptp_write_i210(struct igb_adapter *adapter,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\twr32(E1000_SYSTIML, ts->tv_nsec);\n\twr32(E1000_SYSTIMH, (u32)ts->tv_sec);\n}\n\n \nstatic void igb_ptp_systim_to_hwtstamp(struct igb_adapter *adapter,\n\t\t\t\t       struct skb_shared_hwtstamps *hwtstamps,\n\t\t\t\t       u64 systim)\n{\n\tunsigned long flags;\n\tu64 ns;\n\n\tmemset(hwtstamps, 0, sizeof(*hwtstamps));\n\n\tswitch (adapter->hw.mac.type) {\n\tcase e1000_82576:\n\tcase e1000_82580:\n\tcase e1000_i354:\n\tcase e1000_i350:\n\t\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\t\tns = timecounter_cyc2time(&adapter->tc, systim);\n\t\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\t\thwtstamps->hwtstamp = ns_to_ktime(ns);\n\t\tbreak;\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\t \n\t\thwtstamps->hwtstamp = ktime_set(systim >> 32,\n\t\t\t\t\t\tsystim & 0xFFFFFFFF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int igb_ptp_adjfine_82576(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct e1000_hw *hw = &igb->hw;\n\tu64 incvalue;\n\n\tincvalue = adjust_by_scaled_ppm(INCVALUE_82576, scaled_ppm);\n\n\twr32(E1000_TIMINCA, INCPERIOD_82576 | (incvalue & INCVALUE_82576_MASK));\n\n\treturn 0;\n}\n\nstatic int igb_ptp_adjfine_82580(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct e1000_hw *hw = &igb->hw;\n\tbool neg_adj;\n\tu64 rate;\n\tu32 inca;\n\n\tneg_adj = diff_by_scaled_ppm(IGB_82580_BASE_PERIOD, scaled_ppm, &rate);\n\n\tinca = rate & INCVALUE_MASK;\n\tif (neg_adj)\n\t\tinca |= ISGN;\n\n\twr32(E1000_TIMINCA, inca);\n\n\treturn 0;\n}\n\nstatic int igb_ptp_adjtime_82576(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\ttimecounter_adjtime(&igb->tc, delta);\n\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int igb_ptp_adjtime_i210(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tunsigned long flags;\n\tstruct timespec64 now, then = ns_to_timespec64(delta);\n\n\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\n\tigb_ptp_read_i210(igb, &now);\n\tnow = timespec64_add(now, then);\n\tigb_ptp_write_i210(igb, (const struct timespec64 *)&now);\n\n\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int igb_ptp_gettimex_82576(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct e1000_hw *hw = &igb->hw;\n\tunsigned long flags;\n\tu32 lo, hi;\n\tu64 ns;\n\n\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\n\tptp_read_system_prets(sts);\n\tlo = rd32(E1000_SYSTIML);\n\tptp_read_system_postts(sts);\n\thi = rd32(E1000_SYSTIMH);\n\n\tns = timecounter_cyc2time(&igb->tc, ((u64)hi << 32) | lo);\n\n\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int igb_ptp_gettimex_82580(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct e1000_hw *hw = &igb->hw;\n\tunsigned long flags;\n\tu32 lo, hi;\n\tu64 ns;\n\n\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\n\tptp_read_system_prets(sts);\n\trd32(E1000_SYSTIMR);\n\tptp_read_system_postts(sts);\n\tlo = rd32(E1000_SYSTIML);\n\thi = rd32(E1000_SYSTIMH);\n\n\tns = timecounter_cyc2time(&igb->tc, ((u64)hi << 32) | lo);\n\n\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int igb_ptp_gettimex_i210(struct ptp_clock_info *ptp,\n\t\t\t\t struct timespec64 *ts,\n\t\t\t\t struct ptp_system_timestamp *sts)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tstruct e1000_hw *hw = &igb->hw;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\n\tptp_read_system_prets(sts);\n\trd32(E1000_SYSTIMR);\n\tptp_read_system_postts(sts);\n\tts->tv_nsec = rd32(E1000_SYSTIML);\n\tts->tv_sec = rd32(E1000_SYSTIMH);\n\n\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int igb_ptp_settime_82576(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tunsigned long flags;\n\tu64 ns;\n\n\tns = timespec64_to_ns(ts);\n\n\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\n\ttimecounter_init(&igb->tc, &igb->cc, ns);\n\n\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int igb_ptp_settime_i210(struct ptp_clock_info *ptp,\n\t\t\t\tconst struct timespec64 *ts)\n{\n\tstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\n\t\t\t\t\t       ptp_caps);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\n\tigb_ptp_write_i210(igb, ts);\n\n\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic void igb_pin_direction(int pin, int input, u32 *ctrl, u32 *ctrl_ext)\n{\n\tu32 *ptr = pin < 2 ? ctrl : ctrl_ext;\n\tstatic const u32 mask[IGB_N_SDP] = {\n\t\tE1000_CTRL_SDP0_DIR,\n\t\tE1000_CTRL_SDP1_DIR,\n\t\tE1000_CTRL_EXT_SDP2_DIR,\n\t\tE1000_CTRL_EXT_SDP3_DIR,\n\t};\n\n\tif (input)\n\t\t*ptr &= ~mask[pin];\n\telse\n\t\t*ptr |= mask[pin];\n}\n\nstatic void igb_pin_extts(struct igb_adapter *igb, int chan, int pin)\n{\n\tstatic const u32 aux0_sel_sdp[IGB_N_SDP] = {\n\t\tAUX0_SEL_SDP0, AUX0_SEL_SDP1, AUX0_SEL_SDP2, AUX0_SEL_SDP3,\n\t};\n\tstatic const u32 aux1_sel_sdp[IGB_N_SDP] = {\n\t\tAUX1_SEL_SDP0, AUX1_SEL_SDP1, AUX1_SEL_SDP2, AUX1_SEL_SDP3,\n\t};\n\tstatic const u32 ts_sdp_en[IGB_N_SDP] = {\n\t\tTS_SDP0_EN, TS_SDP1_EN, TS_SDP2_EN, TS_SDP3_EN,\n\t};\n\tstruct e1000_hw *hw = &igb->hw;\n\tu32 ctrl, ctrl_ext, tssdp = 0;\n\n\tctrl = rd32(E1000_CTRL);\n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\ttssdp = rd32(E1000_TSSDP);\n\n\tigb_pin_direction(pin, 1, &ctrl, &ctrl_ext);\n\n\t \n\ttssdp &= ~ts_sdp_en[pin];\n\n\tif (chan == 1) {\n\t\ttssdp &= ~AUX1_SEL_SDP3;\n\t\ttssdp |= aux1_sel_sdp[pin] | AUX1_TS_SDP_EN;\n\t} else {\n\t\ttssdp &= ~AUX0_SEL_SDP3;\n\t\ttssdp |= aux0_sel_sdp[pin] | AUX0_TS_SDP_EN;\n\t}\n\n\twr32(E1000_TSSDP, tssdp);\n\twr32(E1000_CTRL, ctrl);\n\twr32(E1000_CTRL_EXT, ctrl_ext);\n}\n\nstatic void igb_pin_perout(struct igb_adapter *igb, int chan, int pin, int freq)\n{\n\tstatic const u32 aux0_sel_sdp[IGB_N_SDP] = {\n\t\tAUX0_SEL_SDP0, AUX0_SEL_SDP1, AUX0_SEL_SDP2, AUX0_SEL_SDP3,\n\t};\n\tstatic const u32 aux1_sel_sdp[IGB_N_SDP] = {\n\t\tAUX1_SEL_SDP0, AUX1_SEL_SDP1, AUX1_SEL_SDP2, AUX1_SEL_SDP3,\n\t};\n\tstatic const u32 ts_sdp_en[IGB_N_SDP] = {\n\t\tTS_SDP0_EN, TS_SDP1_EN, TS_SDP2_EN, TS_SDP3_EN,\n\t};\n\tstatic const u32 ts_sdp_sel_tt0[IGB_N_SDP] = {\n\t\tTS_SDP0_SEL_TT0, TS_SDP1_SEL_TT0,\n\t\tTS_SDP2_SEL_TT0, TS_SDP3_SEL_TT0,\n\t};\n\tstatic const u32 ts_sdp_sel_tt1[IGB_N_SDP] = {\n\t\tTS_SDP0_SEL_TT1, TS_SDP1_SEL_TT1,\n\t\tTS_SDP2_SEL_TT1, TS_SDP3_SEL_TT1,\n\t};\n\tstatic const u32 ts_sdp_sel_fc0[IGB_N_SDP] = {\n\t\tTS_SDP0_SEL_FC0, TS_SDP1_SEL_FC0,\n\t\tTS_SDP2_SEL_FC0, TS_SDP3_SEL_FC0,\n\t};\n\tstatic const u32 ts_sdp_sel_fc1[IGB_N_SDP] = {\n\t\tTS_SDP0_SEL_FC1, TS_SDP1_SEL_FC1,\n\t\tTS_SDP2_SEL_FC1, TS_SDP3_SEL_FC1,\n\t};\n\tstatic const u32 ts_sdp_sel_clr[IGB_N_SDP] = {\n\t\tTS_SDP0_SEL_FC1, TS_SDP1_SEL_FC1,\n\t\tTS_SDP2_SEL_FC1, TS_SDP3_SEL_FC1,\n\t};\n\tstruct e1000_hw *hw = &igb->hw;\n\tu32 ctrl, ctrl_ext, tssdp = 0;\n\n\tctrl = rd32(E1000_CTRL);\n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\ttssdp = rd32(E1000_TSSDP);\n\n\tigb_pin_direction(pin, 0, &ctrl, &ctrl_ext);\n\n\t \n\tif ((tssdp & AUX0_SEL_SDP3) == aux0_sel_sdp[pin])\n\t\ttssdp &= ~AUX0_TS_SDP_EN;\n\n\tif ((tssdp & AUX1_SEL_SDP3) == aux1_sel_sdp[pin])\n\t\ttssdp &= ~AUX1_TS_SDP_EN;\n\n\ttssdp &= ~ts_sdp_sel_clr[pin];\n\tif (freq) {\n\t\tif (chan == 1)\n\t\t\ttssdp |= ts_sdp_sel_fc1[pin];\n\t\telse\n\t\t\ttssdp |= ts_sdp_sel_fc0[pin];\n\t} else {\n\t\tif (chan == 1)\n\t\t\ttssdp |= ts_sdp_sel_tt1[pin];\n\t\telse\n\t\t\ttssdp |= ts_sdp_sel_tt0[pin];\n\t}\n\ttssdp |= ts_sdp_en[pin];\n\n\twr32(E1000_TSSDP, tssdp);\n\twr32(E1000_CTRL, ctrl);\n\twr32(E1000_CTRL_EXT, ctrl_ext);\n}\n\nstatic int igb_ptp_feature_enable_82580(struct ptp_clock_info *ptp,\n\t\t\t\t\tstruct ptp_clock_request *rq, int on)\n{\n\tstruct igb_adapter *igb =\n\t\tcontainer_of(ptp, struct igb_adapter, ptp_caps);\n\tu32 tsauxc, tsim, tsauxc_mask, tsim_mask, trgttiml, trgttimh, systiml,\n\t\tsystimh, level_mask, level, rem;\n\tstruct e1000_hw *hw = &igb->hw;\n\tstruct timespec64 ts, start;\n\tunsigned long flags;\n\tu64 systim, now;\n\tint pin = -1;\n\ts64 ns;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\t \n\t\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\t\tPTP_STRICT_FLAGS))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (on) {\n\t\t\tpin = ptp_find_pin(igb->ptp_clock, PTP_PF_EXTTS,\n\t\t\t\t\t   rq->extts.index);\n\t\t\tif (pin < 0)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (rq->extts.index == 1) {\n\t\t\ttsauxc_mask = TSAUXC_EN_TS1;\n\t\t\ttsim_mask = TSINTR_AUTT1;\n\t\t} else {\n\t\t\ttsauxc_mask = TSAUXC_EN_TS0;\n\t\t\ttsim_mask = TSINTR_AUTT0;\n\t\t}\n\t\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\t\ttsauxc = rd32(E1000_TSAUXC);\n\t\ttsim = rd32(E1000_TSIM);\n\t\tif (on) {\n\t\t\tigb_pin_extts(igb, rq->extts.index, pin);\n\t\t\ttsauxc |= tsauxc_mask;\n\t\t\ttsim |= tsim_mask;\n\t\t} else {\n\t\t\ttsauxc &= ~tsauxc_mask;\n\t\t\ttsim &= ~tsim_mask;\n\t\t}\n\t\twr32(E1000_TSAUXC, tsauxc);\n\t\twr32(E1000_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\t\treturn 0;\n\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t \n\t\tif (rq->perout.flags)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (on) {\n\t\t\tpin = ptp_find_pin(igb->ptp_clock, PTP_PF_PEROUT,\n\t\t\t\t\t   rq->perout.index);\n\t\t\tif (pin < 0)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tts.tv_sec = rq->perout.period.sec;\n\t\tts.tv_nsec = rq->perout.period.nsec;\n\t\tns = timespec64_to_ns(&ts);\n\t\tns = ns >> 1;\n\t\tif (on && ns < 8LL)\n\t\t\treturn -EINVAL;\n\t\tts = ns_to_timespec64(ns);\n\t\tif (rq->perout.index == 1) {\n\t\t\ttsauxc_mask = TSAUXC_EN_TT1;\n\t\t\ttsim_mask = TSINTR_TT1;\n\t\t\ttrgttiml = E1000_TRGTTIML1;\n\t\t\ttrgttimh = E1000_TRGTTIMH1;\n\t\t} else {\n\t\t\ttsauxc_mask = TSAUXC_EN_TT0;\n\t\t\ttsim_mask = TSINTR_TT0;\n\t\t\ttrgttiml = E1000_TRGTTIML0;\n\t\t\ttrgttimh = E1000_TRGTTIMH0;\n\t\t}\n\t\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\t\ttsauxc = rd32(E1000_TSAUXC);\n\t\ttsim = rd32(E1000_TSIM);\n\t\tif (rq->perout.index == 1) {\n\t\t\ttsauxc &= ~(TSAUXC_EN_TT1 | TSAUXC_EN_CLK1 | TSAUXC_ST1);\n\t\t\ttsim &= ~TSINTR_TT1;\n\t\t} else {\n\t\t\ttsauxc &= ~(TSAUXC_EN_TT0 | TSAUXC_EN_CLK0 | TSAUXC_ST0);\n\t\t\ttsim &= ~TSINTR_TT0;\n\t\t}\n\t\tif (on) {\n\t\t\tint i = rq->perout.index;\n\n\t\t\t \n\t\t\trd32(E1000_SYSTIMR);\n\t\t\tsystiml = rd32(E1000_SYSTIML);\n\t\t\tsystimh = rd32(E1000_SYSTIMH);\n\t\t\tsystim = (((u64)(systimh & 0xFF)) << 32) | ((u64)systiml);\n\t\t\tnow = timecounter_cyc2time(&igb->tc, systim);\n\n\t\t\tif (pin < 2) {\n\t\t\t\tlevel_mask = (i == 1) ? 0x80000 : 0x40000;\n\t\t\t\tlevel = (rd32(E1000_CTRL) & level_mask) ? 1 : 0;\n\t\t\t} else {\n\t\t\t\tlevel_mask = (i == 1) ? 0x80 : 0x40;\n\t\t\t\tlevel = (rd32(E1000_CTRL_EXT) & level_mask) ? 1 : 0;\n\t\t\t}\n\n\t\t\tdiv_u64_rem(now, ns, &rem);\n\t\t\tsystim = systim + (ns - rem);\n\n\t\t\t \n\t\t\tdiv_u64_rem(now, ns << 1, &rem);\n\t\t\tif (rem < ns) {\n\t\t\t\t \n\t\t\t\tif (level == 0) {\n\t\t\t\t\t \n\t\t\t\t\tsystim += ns;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (level == 1) {\n\t\t\t\t\t \n\t\t\t\t\tsystim += ns;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstart = ns_to_timespec64(systim + (ns - rem));\n\t\t\tigb_pin_perout(igb, i, pin, 0);\n\t\t\tigb->perout[i].start.tv_sec = start.tv_sec;\n\t\t\tigb->perout[i].start.tv_nsec = start.tv_nsec;\n\t\t\tigb->perout[i].period.tv_sec = ts.tv_sec;\n\t\t\tigb->perout[i].period.tv_nsec = ts.tv_nsec;\n\n\t\t\twr32(trgttiml, (u32)systim);\n\t\t\twr32(trgttimh, ((u32)(systim >> 32)) & 0xFF);\n\t\t\ttsauxc |= tsauxc_mask;\n\t\t\ttsim |= tsim_mask;\n\t\t}\n\t\twr32(E1000_TSAUXC, tsauxc);\n\t\twr32(E1000_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\t\treturn 0;\n\n\tcase PTP_CLK_REQ_PPS:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int igb_ptp_feature_enable_i210(struct ptp_clock_info *ptp,\n\t\t\t\t       struct ptp_clock_request *rq, int on)\n{\n\tstruct igb_adapter *igb =\n\t\tcontainer_of(ptp, struct igb_adapter, ptp_caps);\n\tstruct e1000_hw *hw = &igb->hw;\n\tu32 tsauxc, tsim, tsauxc_mask, tsim_mask, trgttiml, trgttimh, freqout;\n\tunsigned long flags;\n\tstruct timespec64 ts;\n\tint use_freq = 0, pin = -1;\n\ts64 ns;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\t \n\t\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\t\tPTP_STRICT_FLAGS))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif ((rq->extts.flags & PTP_STRICT_FLAGS) &&\n\t\t    (rq->extts.flags & PTP_ENABLE_FEATURE) &&\n\t\t    (rq->extts.flags & PTP_EXTTS_EDGES) != PTP_EXTTS_EDGES)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (on) {\n\t\t\tpin = ptp_find_pin(igb->ptp_clock, PTP_PF_EXTTS,\n\t\t\t\t\t   rq->extts.index);\n\t\t\tif (pin < 0)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (rq->extts.index == 1) {\n\t\t\ttsauxc_mask = TSAUXC_EN_TS1;\n\t\t\ttsim_mask = TSINTR_AUTT1;\n\t\t} else {\n\t\t\ttsauxc_mask = TSAUXC_EN_TS0;\n\t\t\ttsim_mask = TSINTR_AUTT0;\n\t\t}\n\t\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\t\ttsauxc = rd32(E1000_TSAUXC);\n\t\ttsim = rd32(E1000_TSIM);\n\t\tif (on) {\n\t\t\tigb_pin_extts(igb, rq->extts.index, pin);\n\t\t\ttsauxc |= tsauxc_mask;\n\t\t\ttsim |= tsim_mask;\n\t\t} else {\n\t\t\ttsauxc &= ~tsauxc_mask;\n\t\t\ttsim &= ~tsim_mask;\n\t\t}\n\t\twr32(E1000_TSAUXC, tsauxc);\n\t\twr32(E1000_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\t\treturn 0;\n\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t \n\t\tif (rq->perout.flags)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (on) {\n\t\t\tpin = ptp_find_pin(igb->ptp_clock, PTP_PF_PEROUT,\n\t\t\t\t\t   rq->perout.index);\n\t\t\tif (pin < 0)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tts.tv_sec = rq->perout.period.sec;\n\t\tts.tv_nsec = rq->perout.period.nsec;\n\t\tns = timespec64_to_ns(&ts);\n\t\tns = ns >> 1;\n\t\tif (on && ((ns <= 70000000LL) || (ns == 125000000LL) ||\n\t\t\t   (ns == 250000000LL) || (ns == 500000000LL))) {\n\t\t\tif (ns < 8LL)\n\t\t\t\treturn -EINVAL;\n\t\t\tuse_freq = 1;\n\t\t}\n\t\tts = ns_to_timespec64(ns);\n\t\tif (rq->perout.index == 1) {\n\t\t\tif (use_freq) {\n\t\t\t\ttsauxc_mask = TSAUXC_EN_CLK1 | TSAUXC_ST1;\n\t\t\t\ttsim_mask = 0;\n\t\t\t} else {\n\t\t\t\ttsauxc_mask = TSAUXC_EN_TT1;\n\t\t\t\ttsim_mask = TSINTR_TT1;\n\t\t\t}\n\t\t\ttrgttiml = E1000_TRGTTIML1;\n\t\t\ttrgttimh = E1000_TRGTTIMH1;\n\t\t\tfreqout = E1000_FREQOUT1;\n\t\t} else {\n\t\t\tif (use_freq) {\n\t\t\t\ttsauxc_mask = TSAUXC_EN_CLK0 | TSAUXC_ST0;\n\t\t\t\ttsim_mask = 0;\n\t\t\t} else {\n\t\t\t\ttsauxc_mask = TSAUXC_EN_TT0;\n\t\t\t\ttsim_mask = TSINTR_TT0;\n\t\t\t}\n\t\t\ttrgttiml = E1000_TRGTTIML0;\n\t\t\ttrgttimh = E1000_TRGTTIMH0;\n\t\t\tfreqout = E1000_FREQOUT0;\n\t\t}\n\t\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\t\ttsauxc = rd32(E1000_TSAUXC);\n\t\ttsim = rd32(E1000_TSIM);\n\t\tif (rq->perout.index == 1) {\n\t\t\ttsauxc &= ~(TSAUXC_EN_TT1 | TSAUXC_EN_CLK1 | TSAUXC_ST1);\n\t\t\ttsim &= ~TSINTR_TT1;\n\t\t} else {\n\t\t\ttsauxc &= ~(TSAUXC_EN_TT0 | TSAUXC_EN_CLK0 | TSAUXC_ST0);\n\t\t\ttsim &= ~TSINTR_TT0;\n\t\t}\n\t\tif (on) {\n\t\t\tint i = rq->perout.index;\n\t\t\tigb_pin_perout(igb, i, pin, use_freq);\n\t\t\tigb->perout[i].start.tv_sec = rq->perout.start.sec;\n\t\t\tigb->perout[i].start.tv_nsec = rq->perout.start.nsec;\n\t\t\tigb->perout[i].period.tv_sec = ts.tv_sec;\n\t\t\tigb->perout[i].period.tv_nsec = ts.tv_nsec;\n\t\t\twr32(trgttimh, rq->perout.start.sec);\n\t\t\twr32(trgttiml, rq->perout.start.nsec);\n\t\t\tif (use_freq)\n\t\t\t\twr32(freqout, ns);\n\t\t\ttsauxc |= tsauxc_mask;\n\t\t\ttsim |= tsim_mask;\n\t\t}\n\t\twr32(E1000_TSAUXC, tsauxc);\n\t\twr32(E1000_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\t\treturn 0;\n\n\tcase PTP_CLK_REQ_PPS:\n\t\tspin_lock_irqsave(&igb->tmreg_lock, flags);\n\t\ttsim = rd32(E1000_TSIM);\n\t\tif (on)\n\t\t\ttsim |= TSINTR_SYS_WRAP;\n\t\telse\n\t\t\ttsim &= ~TSINTR_SYS_WRAP;\n\t\tigb->pps_sys_wrap_on = !!on;\n\t\twr32(E1000_TSIM, tsim);\n\t\tspin_unlock_irqrestore(&igb->tmreg_lock, flags);\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int igb_ptp_feature_enable(struct ptp_clock_info *ptp,\n\t\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int igb_ptp_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t      enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic void igb_ptp_tx_work(struct work_struct *work)\n{\n\tstruct igb_adapter *adapter = container_of(work, struct igb_adapter,\n\t\t\t\t\t\t   ptp_tx_work);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tsynctxctl;\n\n\tif (!adapter->ptp_tx_skb)\n\t\treturn;\n\n\tif (time_is_before_jiffies(adapter->ptp_tx_start +\n\t\t\t\t   IGB_PTP_TX_TIMEOUT)) {\n\t\tdev_kfree_skb_any(adapter->ptp_tx_skb);\n\t\tadapter->ptp_tx_skb = NULL;\n\t\tclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\n\t\tadapter->tx_hwtstamp_timeouts++;\n\t\t \n\t\trd32(E1000_TXSTMPH);\n\t\tdev_warn(&adapter->pdev->dev, \"clearing Tx timestamp hang\\n\");\n\t\treturn;\n\t}\n\n\ttsynctxctl = rd32(E1000_TSYNCTXCTL);\n\tif (tsynctxctl & E1000_TSYNCTXCTL_VALID)\n\t\tigb_ptp_tx_hwtstamp(adapter);\n\telse\n\t\t \n\t\tschedule_work(&adapter->ptp_tx_work);\n}\n\nstatic void igb_ptp_overflow_check(struct work_struct *work)\n{\n\tstruct igb_adapter *igb =\n\t\tcontainer_of(work, struct igb_adapter, ptp_overflow_work.work);\n\tstruct timespec64 ts;\n\tu64 ns;\n\n\t \n\tns = timecounter_read(&igb->tc);\n\n\tts = ns_to_timespec64(ns);\n\tpr_debug(\"igb overflow check at %lld.%09lu\\n\",\n\t\t (long long) ts.tv_sec, ts.tv_nsec);\n\n\tschedule_delayed_work(&igb->ptp_overflow_work,\n\t\t\t      IGB_SYSTIM_OVERFLOW_PERIOD);\n}\n\n \nvoid igb_ptp_rx_hang(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tsyncrxctl = rd32(E1000_TSYNCRXCTL);\n\tunsigned long rx_event;\n\n\t \n\tif (hw->mac.type != e1000_82576)\n\t\treturn;\n\n\t \n\tif (!(tsyncrxctl & E1000_TSYNCRXCTL_VALID)) {\n\t\tadapter->last_rx_ptp_check = jiffies;\n\t\treturn;\n\t}\n\n\t \n\trx_event = adapter->last_rx_ptp_check;\n\tif (time_after(adapter->last_rx_timestamp, rx_event))\n\t\trx_event = adapter->last_rx_timestamp;\n\n\t \n\tif (time_is_before_jiffies(rx_event + 5 * HZ)) {\n\t\trd32(E1000_RXSTMPH);\n\t\tadapter->last_rx_ptp_check = jiffies;\n\t\tadapter->rx_hwtstamp_cleared++;\n\t\tdev_warn(&adapter->pdev->dev, \"clearing Rx timestamp hang\\n\");\n\t}\n}\n\n \nvoid igb_ptp_tx_hang(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool timeout = time_is_before_jiffies(adapter->ptp_tx_start +\n\t\t\t\t\t      IGB_PTP_TX_TIMEOUT);\n\n\tif (!adapter->ptp_tx_skb)\n\t\treturn;\n\n\tif (!test_bit(__IGB_PTP_TX_IN_PROGRESS, &adapter->state))\n\t\treturn;\n\n\t \n\tif (timeout) {\n\t\tcancel_work_sync(&adapter->ptp_tx_work);\n\t\tdev_kfree_skb_any(adapter->ptp_tx_skb);\n\t\tadapter->ptp_tx_skb = NULL;\n\t\tclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\n\t\tadapter->tx_hwtstamp_timeouts++;\n\t\t \n\t\trd32(E1000_TXSTMPH);\n\t\tdev_warn(&adapter->pdev->dev, \"clearing Tx timestamp hang\\n\");\n\t}\n}\n\n \nstatic void igb_ptp_tx_hwtstamp(struct igb_adapter *adapter)\n{\n\tstruct sk_buff *skb = adapter->ptp_tx_skb;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tu64 regval;\n\tint adjust = 0;\n\n\tregval = rd32(E1000_TXSTMPL);\n\tregval |= (u64)rd32(E1000_TXSTMPH) << 32;\n\n\tigb_ptp_systim_to_hwtstamp(adapter, &shhwtstamps, regval);\n\t \n\tif (adapter->hw.mac.type == e1000_i210) {\n\t\tswitch (adapter->link_speed) {\n\t\tcase SPEED_10:\n\t\t\tadjust = IGB_I210_TX_LATENCY_10;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tadjust = IGB_I210_TX_LATENCY_100;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tadjust = IGB_I210_TX_LATENCY_1000;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tshhwtstamps.hwtstamp =\n\t\tktime_add_ns(shhwtstamps.hwtstamp, adjust);\n\n\t \n\tadapter->ptp_tx_skb = NULL;\n\tclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\n\n\t \n\tskb_tstamp_tx(skb, &shhwtstamps);\n\tdev_kfree_skb_any(skb);\n}\n\n \nint igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector, void *va,\n\t\t\tktime_t *timestamp)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tstruct skb_shared_hwtstamps ts;\n\t__le64 *regval = (__le64 *)va;\n\tint adjust = 0;\n\n\tif (!(adapter->ptp_flags & IGB_PTP_ENABLED))\n\t\treturn 0;\n\n\t \n\n\t \n\tif (regval[0])\n\t\treturn 0;\n\n\tigb_ptp_systim_to_hwtstamp(adapter, &ts, le64_to_cpu(regval[1]));\n\n\t \n\tif (adapter->hw.mac.type == e1000_i210) {\n\t\tswitch (adapter->link_speed) {\n\t\tcase SPEED_10:\n\t\t\tadjust = IGB_I210_RX_LATENCY_10;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tadjust = IGB_I210_RX_LATENCY_100;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tadjust = IGB_I210_RX_LATENCY_1000;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*timestamp = ktime_sub_ns(ts.hwtstamp, adjust);\n\n\treturn IGB_TS_HDR_LEN;\n}\n\n \nvoid igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector, struct sk_buff *skb)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint adjust = 0;\n\tu64 regval;\n\n\tif (!(adapter->ptp_flags & IGB_PTP_ENABLED))\n\t\treturn;\n\n\t \n\tif (!(rd32(E1000_TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID))\n\t\treturn;\n\n\tregval = rd32(E1000_RXSTMPL);\n\tregval |= (u64)rd32(E1000_RXSTMPH) << 32;\n\n\tigb_ptp_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), regval);\n\n\t \n\tif (adapter->hw.mac.type == e1000_i210) {\n\t\tswitch (adapter->link_speed) {\n\t\tcase SPEED_10:\n\t\t\tadjust = IGB_I210_RX_LATENCY_10;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tadjust = IGB_I210_RX_LATENCY_100;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tadjust = IGB_I210_RX_LATENCY_1000;\n\t\t\tbreak;\n\t\t}\n\t}\n\tskb_hwtstamps(skb)->hwtstamp =\n\t\tktime_sub_ns(skb_hwtstamps(skb)->hwtstamp, adjust);\n\n\t \n\tadapter->last_rx_timestamp = jiffies;\n}\n\n \nint igb_ptp_get_ts_config(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config *config = &adapter->tstamp_config;\n\n\treturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nstatic int igb_ptp_set_timestamp_mode(struct igb_adapter *adapter,\n\t\t\t\t      struct hwtstamp_config *config)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tsync_tx_ctl = E1000_TSYNCTXCTL_ENABLED;\n\tu32 tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\n\tu32 tsync_rx_cfg = 0;\n\tbool is_l4 = false;\n\tbool is_l2 = false;\n\tu32 regval;\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\ttsync_tx_ctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ttsync_rx_ctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\n\t\ttsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\n\t\ttsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_EVENT_V2;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\tcase HWTSTAMP_FILTER_ALL:\n\t\t \n\t\tif (hw->mac.type != e1000_82576) {\n\t\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\n\t\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\treturn -ERANGE;\n\t}\n\n\tif (hw->mac.type == e1000_82575) {\n\t\tif (tsync_rx_ctl | tsync_tx_ctl)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((hw->mac.type >= e1000_82580) && tsync_rx_ctl) {\n\t\ttsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\n\t\tif ((hw->mac.type == e1000_i210) ||\n\t\t    (hw->mac.type == e1000_i211)) {\n\t\t\tregval = rd32(E1000_RXPBS);\n\t\t\tregval |= E1000_RXPBS_CFG_TS_EN;\n\t\t\twr32(E1000_RXPBS, regval);\n\t\t}\n\t}\n\n\t \n\tregval = rd32(E1000_TSYNCTXCTL);\n\tregval &= ~E1000_TSYNCTXCTL_ENABLED;\n\tregval |= tsync_tx_ctl;\n\twr32(E1000_TSYNCTXCTL, regval);\n\n\t \n\tregval = rd32(E1000_TSYNCRXCTL);\n\tregval &= ~(E1000_TSYNCRXCTL_ENABLED | E1000_TSYNCRXCTL_TYPE_MASK);\n\tregval |= tsync_rx_ctl;\n\twr32(E1000_TSYNCRXCTL, regval);\n\n\t \n\twr32(E1000_TSYNCRXCFG, tsync_rx_cfg);\n\n\t \n\tif (is_l2)\n\t\twr32(E1000_ETQF(IGB_ETQF_FILTER_1588),\n\t\t     (E1000_ETQF_FILTER_ENABLE |  \n\t\t      E1000_ETQF_1588 |  \n\t\t      ETH_P_1588));      \n\telse\n\t\twr32(E1000_ETQF(IGB_ETQF_FILTER_1588), 0);\n\n\t \n\tif (is_l4) {\n\t\tu32 ftqf = (IPPROTO_UDP  \n\t\t\t| E1000_FTQF_VF_BP  \n\t\t\t| E1000_FTQF_1588_TIME_STAMP  \n\t\t\t| E1000_FTQF_MASK);  \n\t\tftqf &= ~E1000_FTQF_MASK_PROTO_BP;  \n\n\t\twr32(E1000_IMIR(3), (__force unsigned int)htons(PTP_EV_PORT));\n\t\twr32(E1000_IMIREXT(3),\n\t\t     (E1000_IMIREXT_SIZE_BP | E1000_IMIREXT_CTRL_BP));\n\t\tif (hw->mac.type == e1000_82576) {\n\t\t\t \n\t\t\twr32(E1000_SPQF(3), (__force unsigned int)htons(PTP_EV_PORT));\n\t\t\tftqf &= ~E1000_FTQF_MASK_SOURCE_PORT_BP;\n\t\t}\n\t\twr32(E1000_FTQF(3), ftqf);\n\t} else {\n\t\twr32(E1000_FTQF(3), E1000_FTQF_MASK);\n\t}\n\twrfl();\n\n\t \n\tregval = rd32(E1000_TXSTMPL);\n\tregval = rd32(E1000_TXSTMPH);\n\tregval = rd32(E1000_RXSTMPL);\n\tregval = rd32(E1000_RXSTMPH);\n\n\treturn 0;\n}\n\n \nint igb_ptp_set_ts_config(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = igb_ptp_set_timestamp_mode(adapter, &config);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmemcpy(&adapter->tstamp_config, &config,\n\t       sizeof(adapter->tstamp_config));\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nvoid igb_ptp_init(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82576:\n\t\tsnprintf(adapter->ptp_caps.name, 16, \"%pm\", netdev->dev_addr);\n\t\tadapter->ptp_caps.owner = THIS_MODULE;\n\t\tadapter->ptp_caps.max_adj = 999999881;\n\t\tadapter->ptp_caps.n_ext_ts = 0;\n\t\tadapter->ptp_caps.pps = 0;\n\t\tadapter->ptp_caps.adjfine = igb_ptp_adjfine_82576;\n\t\tadapter->ptp_caps.adjtime = igb_ptp_adjtime_82576;\n\t\tadapter->ptp_caps.gettimex64 = igb_ptp_gettimex_82576;\n\t\tadapter->ptp_caps.settime64 = igb_ptp_settime_82576;\n\t\tadapter->ptp_caps.enable = igb_ptp_feature_enable;\n\t\tadapter->cc.read = igb_ptp_read_82576;\n\t\tadapter->cc.mask = CYCLECOUNTER_MASK(64);\n\t\tadapter->cc.mult = 1;\n\t\tadapter->cc.shift = IGB_82576_TSYNC_SHIFT;\n\t\tadapter->ptp_flags |= IGB_PTP_OVERFLOW_CHECK;\n\t\tbreak;\n\tcase e1000_82580:\n\tcase e1000_i354:\n\tcase e1000_i350:\n\t\tigb_ptp_sdp_init(adapter);\n\t\tsnprintf(adapter->ptp_caps.name, 16, \"%pm\", netdev->dev_addr);\n\t\tadapter->ptp_caps.owner = THIS_MODULE;\n\t\tadapter->ptp_caps.max_adj = 62499999;\n\t\tadapter->ptp_caps.n_ext_ts = IGB_N_EXTTS;\n\t\tadapter->ptp_caps.n_per_out = IGB_N_PEROUT;\n\t\tadapter->ptp_caps.n_pins = IGB_N_SDP;\n\t\tadapter->ptp_caps.pps = 0;\n\t\tadapter->ptp_caps.pin_config = adapter->sdp_config;\n\t\tadapter->ptp_caps.adjfine = igb_ptp_adjfine_82580;\n\t\tadapter->ptp_caps.adjtime = igb_ptp_adjtime_82576;\n\t\tadapter->ptp_caps.gettimex64 = igb_ptp_gettimex_82580;\n\t\tadapter->ptp_caps.settime64 = igb_ptp_settime_82576;\n\t\tadapter->ptp_caps.enable = igb_ptp_feature_enable_82580;\n\t\tadapter->ptp_caps.verify = igb_ptp_verify_pin;\n\t\tadapter->cc.read = igb_ptp_read_82580;\n\t\tadapter->cc.mask = CYCLECOUNTER_MASK(IGB_NBITS_82580);\n\t\tadapter->cc.mult = 1;\n\t\tadapter->cc.shift = 0;\n\t\tadapter->ptp_flags |= IGB_PTP_OVERFLOW_CHECK;\n\t\tbreak;\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tigb_ptp_sdp_init(adapter);\n\t\tsnprintf(adapter->ptp_caps.name, 16, \"%pm\", netdev->dev_addr);\n\t\tadapter->ptp_caps.owner = THIS_MODULE;\n\t\tadapter->ptp_caps.max_adj = 62499999;\n\t\tadapter->ptp_caps.n_ext_ts = IGB_N_EXTTS;\n\t\tadapter->ptp_caps.n_per_out = IGB_N_PEROUT;\n\t\tadapter->ptp_caps.n_pins = IGB_N_SDP;\n\t\tadapter->ptp_caps.pps = 1;\n\t\tadapter->ptp_caps.pin_config = adapter->sdp_config;\n\t\tadapter->ptp_caps.adjfine = igb_ptp_adjfine_82580;\n\t\tadapter->ptp_caps.adjtime = igb_ptp_adjtime_i210;\n\t\tadapter->ptp_caps.gettimex64 = igb_ptp_gettimex_i210;\n\t\tadapter->ptp_caps.settime64 = igb_ptp_settime_i210;\n\t\tadapter->ptp_caps.enable = igb_ptp_feature_enable_i210;\n\t\tadapter->ptp_caps.verify = igb_ptp_verify_pin;\n\t\tbreak;\n\tdefault:\n\t\tadapter->ptp_clock = NULL;\n\t\treturn;\n\t}\n\n\tadapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,\n\t\t\t\t\t\t&adapter->pdev->dev);\n\tif (IS_ERR(adapter->ptp_clock)) {\n\t\tadapter->ptp_clock = NULL;\n\t\tdev_err(&adapter->pdev->dev, \"ptp_clock_register failed\\n\");\n\t} else if (adapter->ptp_clock) {\n\t\tdev_info(&adapter->pdev->dev, \"added PHC on %s\\n\",\n\t\t\t adapter->netdev->name);\n\t\tadapter->ptp_flags |= IGB_PTP_ENABLED;\n\n\t\tspin_lock_init(&adapter->tmreg_lock);\n\t\tINIT_WORK(&adapter->ptp_tx_work, igb_ptp_tx_work);\n\n\t\tif (adapter->ptp_flags & IGB_PTP_OVERFLOW_CHECK)\n\t\t\tINIT_DELAYED_WORK(&adapter->ptp_overflow_work,\n\t\t\t\t\t  igb_ptp_overflow_check);\n\n\t\tadapter->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\n\t\tadapter->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\n\n\t\tigb_ptp_reset(adapter);\n\t}\n}\n\n \nvoid igb_ptp_sdp_init(struct igb_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < IGB_N_SDP; i++) {\n\t\tstruct ptp_pin_desc *ppd = &adapter->sdp_config[i];\n\n\t\tsnprintf(ppd->name, sizeof(ppd->name), \"SDP%d\", i);\n\t\tppd->index = i;\n\t\tppd->func = PTP_PF_NONE;\n\t}\n}\n\n \nvoid igb_ptp_suspend(struct igb_adapter *adapter)\n{\n\tif (!(adapter->ptp_flags & IGB_PTP_ENABLED))\n\t\treturn;\n\n\tif (adapter->ptp_flags & IGB_PTP_OVERFLOW_CHECK)\n\t\tcancel_delayed_work_sync(&adapter->ptp_overflow_work);\n\n\tcancel_work_sync(&adapter->ptp_tx_work);\n\tif (adapter->ptp_tx_skb) {\n\t\tdev_kfree_skb_any(adapter->ptp_tx_skb);\n\t\tadapter->ptp_tx_skb = NULL;\n\t\tclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\n\t}\n}\n\n \nvoid igb_ptp_stop(struct igb_adapter *adapter)\n{\n\tigb_ptp_suspend(adapter);\n\n\tif (adapter->ptp_clock) {\n\t\tptp_clock_unregister(adapter->ptp_clock);\n\t\tdev_info(&adapter->pdev->dev, \"removed PHC on %s\\n\",\n\t\t\t adapter->netdev->name);\n\t\tadapter->ptp_flags &= ~IGB_PTP_ENABLED;\n\t}\n}\n\n \nvoid igb_ptp_reset(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\n\t \n\tigb_ptp_set_timestamp_mode(adapter, &adapter->tstamp_config);\n\n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\n\tswitch (adapter->hw.mac.type) {\n\tcase e1000_82576:\n\t\t \n\t\twr32(E1000_TIMINCA, INCPERIOD_82576 | INCVALUE_82576);\n\t\tbreak;\n\tcase e1000_82580:\n\tcase e1000_i354:\n\tcase e1000_i350:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\twr32(E1000_TSAUXC, 0x0);\n\t\twr32(E1000_TSSDP, 0x0);\n\t\twr32(E1000_TSIM,\n\t\t     TSYNC_INTERRUPTS |\n\t\t     (adapter->pps_sys_wrap_on ? TSINTR_SYS_WRAP : 0));\n\t\twr32(E1000_IMS, E1000_IMS_TS);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tif ((hw->mac.type == e1000_i210) || (hw->mac.type == e1000_i211)) {\n\t\tstruct timespec64 ts = ktime_to_timespec64(ktime_get_real());\n\n\t\tigb_ptp_write_i210(adapter, &ts);\n\t} else {\n\t\ttimecounter_init(&adapter->tc, &adapter->cc,\n\t\t\t\t ktime_to_ns(ktime_get_real()));\n\t}\nout:\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\twrfl();\n\n\tif (adapter->ptp_flags & IGB_PTP_OVERFLOW_CHECK)\n\t\tschedule_delayed_work(&adapter->ptp_overflow_work,\n\t\t\t\t      IGB_SYSTIM_OVERFLOW_PERIOD);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}