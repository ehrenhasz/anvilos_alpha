{
  "module_name": "e1000_nvm.c",
  "hash_id": "66e98c49906d9ccad33b99f1278395df3a91d5e148ade9b05c9b6567e863c863",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/e1000_nvm.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/delay.h>\n\n#include \"e1000_mac.h\"\n#include \"e1000_nvm.h\"\n\n \nstatic void igb_raise_eec_clk(struct e1000_hw *hw, u32 *eecd)\n{\n\t*eecd = *eecd | E1000_EECD_SK;\n\twr32(E1000_EECD, *eecd);\n\twrfl();\n\tudelay(hw->nvm.delay_usec);\n}\n\n \nstatic void igb_lower_eec_clk(struct e1000_hw *hw, u32 *eecd)\n{\n\t*eecd = *eecd & ~E1000_EECD_SK;\n\twr32(E1000_EECD, *eecd);\n\twrfl();\n\tudelay(hw->nvm.delay_usec);\n}\n\n \nstatic void igb_shift_out_eec_bits(struct e1000_hw *hw, u16 data, u16 count)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = rd32(E1000_EECD);\n\tu32 mask;\n\n\tmask = 1u << (count - 1);\n\tif (nvm->type == e1000_nvm_eeprom_spi)\n\t\teecd |= E1000_EECD_DO;\n\n\tdo {\n\t\teecd &= ~E1000_EECD_DI;\n\n\t\tif (data & mask)\n\t\t\teecd |= E1000_EECD_DI;\n\n\t\twr32(E1000_EECD, eecd);\n\t\twrfl();\n\n\t\tudelay(nvm->delay_usec);\n\n\t\tigb_raise_eec_clk(hw, &eecd);\n\t\tigb_lower_eec_clk(hw, &eecd);\n\n\t\tmask >>= 1;\n\t} while (mask);\n\n\teecd &= ~E1000_EECD_DI;\n\twr32(E1000_EECD, eecd);\n}\n\n \nstatic u16 igb_shift_in_eec_bits(struct e1000_hw *hw, u16 count)\n{\n\tu32 eecd;\n\tu32 i;\n\tu16 data;\n\n\teecd = rd32(E1000_EECD);\n\n\teecd &= ~(E1000_EECD_DO | E1000_EECD_DI);\n\tdata = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdata <<= 1;\n\t\tigb_raise_eec_clk(hw, &eecd);\n\n\t\teecd = rd32(E1000_EECD);\n\n\t\teecd &= ~E1000_EECD_DI;\n\t\tif (eecd & E1000_EECD_DO)\n\t\t\tdata |= 1;\n\n\t\tigb_lower_eec_clk(hw, &eecd);\n\t}\n\n\treturn data;\n}\n\n \nstatic s32 igb_poll_eerd_eewr_done(struct e1000_hw *hw, int ee_reg)\n{\n\tu32 attempts = 100000;\n\tu32 i, reg = 0;\n\ts32 ret_val = -E1000_ERR_NVM;\n\n\tfor (i = 0; i < attempts; i++) {\n\t\tif (ee_reg == E1000_NVM_POLL_READ)\n\t\t\treg = rd32(E1000_EERD);\n\t\telse\n\t\t\treg = rd32(E1000_EEWR);\n\n\t\tif (reg & E1000_NVM_RW_REG_DONE) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(5);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 igb_acquire_nvm(struct e1000_hw *hw)\n{\n\tu32 eecd = rd32(E1000_EECD);\n\ts32 timeout = E1000_NVM_GRANT_ATTEMPTS;\n\ts32 ret_val = 0;\n\n\n\twr32(E1000_EECD, eecd | E1000_EECD_REQ);\n\teecd = rd32(E1000_EECD);\n\n\twhile (timeout) {\n\t\tif (eecd & E1000_EECD_GNT)\n\t\t\tbreak;\n\t\tudelay(5);\n\t\teecd = rd32(E1000_EECD);\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\teecd &= ~E1000_EECD_REQ;\n\t\twr32(E1000_EECD, eecd);\n\t\thw_dbg(\"Could not acquire NVM grant\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic void igb_standby_nvm(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = rd32(E1000_EECD);\n\n\tif (nvm->type == e1000_nvm_eeprom_spi) {\n\t\t \n\t\teecd |= E1000_EECD_CS;\n\t\twr32(E1000_EECD, eecd);\n\t\twrfl();\n\t\tudelay(nvm->delay_usec);\n\t\teecd &= ~E1000_EECD_CS;\n\t\twr32(E1000_EECD, eecd);\n\t\twrfl();\n\t\tudelay(nvm->delay_usec);\n\t}\n}\n\n \nstatic void e1000_stop_nvm(struct e1000_hw *hw)\n{\n\tu32 eecd;\n\n\teecd = rd32(E1000_EECD);\n\tif (hw->nvm.type == e1000_nvm_eeprom_spi) {\n\t\t \n\t\teecd |= E1000_EECD_CS;\n\t\tigb_lower_eec_clk(hw, &eecd);\n\t}\n}\n\n \nvoid igb_release_nvm(struct e1000_hw *hw)\n{\n\tu32 eecd;\n\n\te1000_stop_nvm(hw);\n\n\teecd = rd32(E1000_EECD);\n\teecd &= ~E1000_EECD_REQ;\n\twr32(E1000_EECD, eecd);\n}\n\n \nstatic s32 igb_ready_nvm_eeprom(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = rd32(E1000_EECD);\n\ts32 ret_val = 0;\n\tu16 timeout = 0;\n\tu8 spi_stat_reg;\n\n\n\tif (nvm->type == e1000_nvm_eeprom_spi) {\n\t\t \n\t\teecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\n\t\twr32(E1000_EECD, eecd);\n\t\twrfl();\n\t\tudelay(1);\n\t\ttimeout = NVM_MAX_RETRY_SPI;\n\n\t\t \n\t\twhile (timeout) {\n\t\t\tigb_shift_out_eec_bits(hw, NVM_RDSR_OPCODE_SPI,\n\t\t\t\t\t       hw->nvm.opcode_bits);\n\t\t\tspi_stat_reg = (u8)igb_shift_in_eec_bits(hw, 8);\n\t\t\tif (!(spi_stat_reg & NVM_STATUS_RDY_SPI))\n\t\t\t\tbreak;\n\n\t\t\tudelay(5);\n\t\t\tigb_standby_nvm(hw);\n\t\t\ttimeout--;\n\t\t}\n\n\t\tif (!timeout) {\n\t\t\thw_dbg(\"SPI NVM Status error\\n\");\n\t\t\tret_val = -E1000_ERR_NVM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_read_nvm_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 i = 0;\n\ts32 ret_val;\n\tu16 word_in;\n\tu8 read_opcode = NVM_READ_OPCODE_SPI;\n\n\t \n\tif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\n\t    (words == 0)) {\n\t\thw_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\n\tret_val = nvm->ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_ready_nvm_eeprom(hw);\n\tif (ret_val)\n\t\tgoto release;\n\n\tigb_standby_nvm(hw);\n\n\tif ((nvm->address_bits == 8) && (offset >= 128))\n\t\tread_opcode |= NVM_A8_OPCODE_SPI;\n\n\t \n\tigb_shift_out_eec_bits(hw, read_opcode, nvm->opcode_bits);\n\tigb_shift_out_eec_bits(hw, (u16)(offset*2), nvm->address_bits);\n\n\t \n\tfor (i = 0; i < words; i++) {\n\t\tword_in = igb_shift_in_eec_bits(hw, 16);\n\t\tdata[i] = (word_in >> 8) | (word_in << 8);\n\t}\n\nrelease:\n\tnvm->ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_read_nvm_eerd(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 i, eerd = 0;\n\ts32 ret_val = 0;\n\n\t \n\tif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\n\t    (words == 0)) {\n\t\thw_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\teerd = ((offset+i) << E1000_NVM_RW_ADDR_SHIFT) +\n\t\t\tE1000_NVM_RW_REG_START;\n\n\t\twr32(E1000_EERD, eerd);\n\t\tret_val = igb_poll_eerd_eewr_done(hw, E1000_NVM_POLL_READ);\n\t\tif (ret_val)\n\t\t\tbreak;\n\n\t\tdata[i] = (rd32(E1000_EERD) >>\n\t\t\tE1000_NVM_RW_REG_DATA);\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_write_nvm_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\ts32 ret_val = -E1000_ERR_NVM;\n\tu16 widx = 0;\n\n\t \n\tif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\n\t    (words == 0)) {\n\t\thw_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\treturn ret_val;\n\t}\n\n\twhile (widx < words) {\n\t\tu8 write_opcode = NVM_WRITE_OPCODE_SPI;\n\n\t\tret_val = nvm->ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = igb_ready_nvm_eeprom(hw);\n\t\tif (ret_val) {\n\t\t\tnvm->ops.release(hw);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tigb_standby_nvm(hw);\n\n\t\t \n\t\tigb_shift_out_eec_bits(hw, NVM_WREN_OPCODE_SPI,\n\t\t\t\t\t nvm->opcode_bits);\n\n\t\tigb_standby_nvm(hw);\n\n\t\t \n\t\tif ((nvm->address_bits == 8) && (offset >= 128))\n\t\t\twrite_opcode |= NVM_A8_OPCODE_SPI;\n\n\t\t \n\t\tigb_shift_out_eec_bits(hw, write_opcode, nvm->opcode_bits);\n\t\tigb_shift_out_eec_bits(hw, (u16)((offset + widx) * 2),\n\t\t\t\t\t nvm->address_bits);\n\n\t\t \n\t\twhile (widx < words) {\n\t\t\tu16 word_out = data[widx];\n\n\t\t\tword_out = (word_out >> 8) | (word_out << 8);\n\t\t\tigb_shift_out_eec_bits(hw, word_out, 16);\n\t\t\twidx++;\n\n\t\t\tif ((((offset + widx) * 2) % nvm->page_size) == 0) {\n\t\t\t\tigb_standby_nvm(hw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t\tnvm->ops.release(hw);\n\t}\n\n\treturn ret_val;\n}\n\n \ns32 igb_read_part_string(struct e1000_hw *hw, u8 *part_num, u32 part_num_size)\n{\n\ts32 ret_val;\n\tu16 nvm_data;\n\tu16 pointer;\n\tu16 offset;\n\tu16 length;\n\n\tif (part_num == NULL) {\n\t\thw_dbg(\"PBA string buffer was null\\n\");\n\t\tret_val = E1000_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tret_val = hw->nvm.ops.read(hw, NVM_PBA_OFFSET_0, 1, &nvm_data);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tret_val = hw->nvm.ops.read(hw, NVM_PBA_OFFSET_1, 1, &pointer);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (nvm_data != NVM_PBA_PTR_GUARD) {\n\t\thw_dbg(\"NVM PBA number is not stored as string\\n\");\n\n\t\t \n\t\tif (part_num_size < 11) {\n\t\t\thw_dbg(\"PBA string buffer too small\\n\");\n\t\t\treturn E1000_ERR_NO_SPACE;\n\t\t}\n\n\t\t \n\t\tpart_num[0] = (nvm_data >> 12) & 0xF;\n\t\tpart_num[1] = (nvm_data >> 8) & 0xF;\n\t\tpart_num[2] = (nvm_data >> 4) & 0xF;\n\t\tpart_num[3] = nvm_data & 0xF;\n\t\tpart_num[4] = (pointer >> 12) & 0xF;\n\t\tpart_num[5] = (pointer >> 8) & 0xF;\n\t\tpart_num[6] = '-';\n\t\tpart_num[7] = 0;\n\t\tpart_num[8] = (pointer >> 4) & 0xF;\n\t\tpart_num[9] = pointer & 0xF;\n\n\t\t \n\t\tpart_num[10] = '\\0';\n\n\t\t \n\t\tfor (offset = 0; offset < 10; offset++) {\n\t\t\tif (part_num[offset] < 0xA)\n\t\t\t\tpart_num[offset] += '0';\n\t\t\telse if (part_num[offset] < 0x10)\n\t\t\t\tpart_num[offset] += 'A' - 0xA;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tret_val = hw->nvm.ops.read(hw, pointer, 1, &length);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (length == 0xFFFF || length == 0) {\n\t\thw_dbg(\"NVM PBA number section invalid length\\n\");\n\t\tret_val = E1000_ERR_NVM_PBA_SECTION;\n\t\tgoto out;\n\t}\n\t \n\tif (part_num_size < (((u32)length * 2) - 1)) {\n\t\thw_dbg(\"PBA string buffer too small\\n\");\n\t\tret_val = E1000_ERR_NO_SPACE;\n\t\tgoto out;\n\t}\n\n\t \n\tpointer++;\n\tlength--;\n\n\tfor (offset = 0; offset < length; offset++) {\n\t\tret_val = hw->nvm.ops.read(hw, pointer + offset, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tpart_num[offset * 2] = (u8)(nvm_data >> 8);\n\t\tpart_num[(offset * 2) + 1] = (u8)(nvm_data & 0xFF);\n\t}\n\tpart_num[offset * 2] = '\\0';\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_read_mac_addr(struct e1000_hw *hw)\n{\n\tu32 rar_high;\n\tu32 rar_low;\n\tu16 i;\n\n\trar_high = rd32(E1000_RAH(0));\n\trar_low = rd32(E1000_RAL(0));\n\n\tfor (i = 0; i < E1000_RAL_MAC_ADDR_LEN; i++)\n\t\thw->mac.perm_addr[i] = (u8)(rar_low >> (i*8));\n\n\tfor (i = 0; i < E1000_RAH_MAC_ADDR_LEN; i++)\n\t\thw->mac.perm_addr[i+4] = (u8)(rar_high >> (i*8));\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\thw->mac.addr[i] = hw->mac.perm_addr[i];\n\n\treturn 0;\n}\n\n \ns32 igb_validate_nvm_checksum(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\n\tfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {\n\t\tret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\n\tif (checksum != (u16) NVM_SUM) {\n\t\thw_dbg(\"NVM Checksum Invalid\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_update_nvm_checksum(struct e1000_hw *hw)\n{\n\ts32  ret_val;\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\n\tfor (i = 0; i < NVM_CHECKSUM_REG; i++) {\n\t\tret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error while updating checksum.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\tchecksum = (u16) NVM_SUM - checksum;\n\tret_val = hw->nvm.ops.write(hw, NVM_CHECKSUM_REG, 1, &checksum);\n\tif (ret_val)\n\t\thw_dbg(\"NVM Write Error while updating checksum.\\n\");\n\nout:\n\treturn ret_val;\n}\n\n \nvoid igb_get_fw_version(struct e1000_hw *hw, struct e1000_fw_version *fw_vers)\n{\n\tu16 eeprom_verh, eeprom_verl, etrack_test, fw_version;\n\tu8 q, hval, rem, result;\n\tu16 comb_verh, comb_verl, comb_offset;\n\n\tmemset(fw_vers, 0, sizeof(struct e1000_fw_version));\n\n\t \n\thw->nvm.ops.read(hw, NVM_ETRACK_HIWORD, 1, &etrack_test);\n\tswitch (hw->mac.type) {\n\tcase e1000_i211:\n\t\tigb_read_invm_version(hw, fw_vers);\n\t\treturn;\n\tcase e1000_82575:\n\tcase e1000_82576:\n\tcase e1000_82580:\n\t\t \n\t\tif ((etrack_test &  NVM_MAJOR_MASK) != NVM_ETRACK_VALID) {\n\t\t\thw->nvm.ops.read(hw, NVM_VERSION, 1, &fw_version);\n\t\t\tfw_vers->eep_major = (fw_version & NVM_MAJOR_MASK)\n\t\t\t\t\t      >> NVM_MAJOR_SHIFT;\n\t\t\tfw_vers->eep_minor = (fw_version & NVM_MINOR_MASK)\n\t\t\t\t\t      >> NVM_MINOR_SHIFT;\n\t\t\tfw_vers->eep_build = (fw_version & NVM_IMAGE_ID_MASK);\n\t\t\tgoto etrack_id;\n\t\t}\n\t\tbreak;\n\tcase e1000_i210:\n\t\tif (!(igb_get_flash_presence_i210(hw))) {\n\t\t\tigb_read_invm_version(hw, fw_vers);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase e1000_i350:\n\t\t \n\t\thw->nvm.ops.read(hw, NVM_COMB_VER_PTR, 1, &comb_offset);\n\t\tif ((comb_offset != 0x0) &&\n\t\t    (comb_offset != NVM_VER_INVALID)) {\n\n\t\t\thw->nvm.ops.read(hw, (NVM_COMB_VER_OFF + comb_offset\n\t\t\t\t\t + 1), 1, &comb_verh);\n\t\t\thw->nvm.ops.read(hw, (NVM_COMB_VER_OFF + comb_offset),\n\t\t\t\t\t 1, &comb_verl);\n\n\t\t\t \n\t\t\tif ((comb_verh && comb_verl) &&\n\t\t\t    ((comb_verh != NVM_VER_INVALID) &&\n\t\t\t     (comb_verl != NVM_VER_INVALID))) {\n\n\t\t\t\tfw_vers->or_valid = true;\n\t\t\t\tfw_vers->or_major =\n\t\t\t\t\tcomb_verl >> NVM_COMB_VER_SHFT;\n\t\t\t\tfw_vers->or_build =\n\t\t\t\t\t(comb_verl << NVM_COMB_VER_SHFT)\n\t\t\t\t\t| (comb_verh >> NVM_COMB_VER_SHFT);\n\t\t\t\tfw_vers->or_patch =\n\t\t\t\t\tcomb_verh & NVM_COMB_VER_MASK;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\thw->nvm.ops.read(hw, NVM_VERSION, 1, &fw_version);\n\tfw_vers->eep_major = (fw_version & NVM_MAJOR_MASK)\n\t\t\t      >> NVM_MAJOR_SHIFT;\n\n\t \n\tif ((fw_version & NVM_NEW_DEC_MASK) == 0x0) {\n\t\teeprom_verl = (fw_version & NVM_COMB_VER_MASK);\n\t} else {\n\t\teeprom_verl = (fw_version & NVM_MINOR_MASK)\n\t\t\t\t>> NVM_MINOR_SHIFT;\n\t}\n\t \n\tq = eeprom_verl / NVM_HEX_CONV;\n\thval = q * NVM_HEX_TENS;\n\trem = eeprom_verl % NVM_HEX_CONV;\n\tresult = hval + rem;\n\tfw_vers->eep_minor = result;\n\netrack_id:\n\tif ((etrack_test &  NVM_MAJOR_MASK) == NVM_ETRACK_VALID) {\n\t\thw->nvm.ops.read(hw, NVM_ETRACK_WORD, 1, &eeprom_verl);\n\t\thw->nvm.ops.read(hw, (NVM_ETRACK_WORD + 1), 1, &eeprom_verh);\n\t\tfw_vers->etrack_id = (eeprom_verh << NVM_ETRACK_SHIFT)\n\t\t\t| eeprom_verl;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}