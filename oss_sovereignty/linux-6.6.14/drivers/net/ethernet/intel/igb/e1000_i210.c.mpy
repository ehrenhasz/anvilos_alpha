{
  "module_name": "e1000_i210.c",
  "hash_id": "380daffdf9cf6d73000c2f2a8cee3e4abf7bf9136dde3077c6bad6e57552e850",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/e1000_i210.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/if_ether.h>\n\n#include \"e1000_hw.h\"\n#include \"e1000_i210.h\"\n\nstatic s32 igb_update_flash_i210(struct e1000_hw *hw);\n\n \nstatic s32 igb_get_hw_semaphore_i210(struct e1000_hw *hw)\n{\n\tu32 swsm;\n\ts32 timeout = hw->nvm.word_size + 1;\n\ts32 i = 0;\n\n\t \n\twhile (i < timeout) {\n\t\tswsm = rd32(E1000_SWSM);\n\t\tif (!(swsm & E1000_SWSM_SMBI))\n\t\t\tbreak;\n\n\t\tudelay(50);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\t \n\t\tif (hw->dev_spec._82575.clear_semaphore_once) {\n\t\t\thw->dev_spec._82575.clear_semaphore_once = false;\n\t\t\tigb_put_hw_semaphore(hw);\n\t\t\tfor (i = 0; i < timeout; i++) {\n\t\t\t\tswsm = rd32(E1000_SWSM);\n\t\t\t\tif (!(swsm & E1000_SWSM_SMBI))\n\t\t\t\t\tbreak;\n\n\t\t\t\tudelay(50);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i == timeout) {\n\t\t\thw_dbg(\"Driver can't access device - SMBI bit is set.\\n\");\n\t\t\treturn -E1000_ERR_NVM;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tswsm = rd32(E1000_SWSM);\n\t\twr32(E1000_SWSM, swsm | E1000_SWSM_SWESMBI);\n\n\t\t \n\t\tif (rd32(E1000_SWSM) & E1000_SWSM_SWESMBI)\n\t\t\tbreak;\n\n\t\tudelay(50);\n\t}\n\n\tif (i == timeout) {\n\t\t \n\t\tigb_put_hw_semaphore(hw);\n\t\thw_dbg(\"Driver can't access the NVM\\n\");\n\t\treturn -E1000_ERR_NVM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 igb_acquire_nvm_i210(struct e1000_hw *hw)\n{\n\treturn igb_acquire_swfw_sync_i210(hw, E1000_SWFW_EEP_SM);\n}\n\n \nstatic void igb_release_nvm_i210(struct e1000_hw *hw)\n{\n\tigb_release_swfw_sync_i210(hw, E1000_SWFW_EEP_SM);\n}\n\n \ns32 igb_acquire_swfw_sync_i210(struct e1000_hw *hw, u16 mask)\n{\n\tu32 swfw_sync;\n\tu32 swmask = mask;\n\tu32 fwmask = mask << 16;\n\ts32 ret_val = 0;\n\ts32 i = 0, timeout = 200;  \n\n\twhile (i < timeout) {\n\t\tif (igb_get_hw_semaphore_i210(hw)) {\n\t\t\tret_val = -E1000_ERR_SWFW_SYNC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswfw_sync = rd32(E1000_SW_FW_SYNC);\n\t\tif (!(swfw_sync & (fwmask | swmask)))\n\t\t\tbreak;\n\n\t\t \n\t\tigb_put_hw_semaphore(hw);\n\t\tmdelay(5);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\thw_dbg(\"Driver can't access resource, SW_FW_SYNC timeout.\\n\");\n\t\tret_val = -E1000_ERR_SWFW_SYNC;\n\t\tgoto out;\n\t}\n\n\tswfw_sync |= swmask;\n\twr32(E1000_SW_FW_SYNC, swfw_sync);\n\n\tigb_put_hw_semaphore(hw);\nout:\n\treturn ret_val;\n}\n\n \nvoid igb_release_swfw_sync_i210(struct e1000_hw *hw, u16 mask)\n{\n\tu32 swfw_sync;\n\n\twhile (igb_get_hw_semaphore_i210(hw))\n\t\t;  \n\n\tswfw_sync = rd32(E1000_SW_FW_SYNC);\n\tswfw_sync &= ~mask;\n\twr32(E1000_SW_FW_SYNC, swfw_sync);\n\n\tigb_put_hw_semaphore(hw);\n}\n\n \nstatic s32 igb_read_nvm_srrd_i210(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t  u16 *data)\n{\n\ts32 status = 0;\n\tu16 i, count;\n\n\t \n\tfor (i = 0; i < words; i += E1000_EERD_EEWR_MAX_COUNT) {\n\t\tcount = (words - i) / E1000_EERD_EEWR_MAX_COUNT > 0 ?\n\t\t\tE1000_EERD_EEWR_MAX_COUNT : (words - i);\n\t\tif (!(hw->nvm.ops.acquire(hw))) {\n\t\t\tstatus = igb_read_nvm_eerd(hw, offset, count,\n\t\t\t\t\t\t     data + i);\n\t\t\thw->nvm.ops.release(hw);\n\t\t} else {\n\t\t\tstatus = E1000_ERR_SWFW_SYNC;\n\t\t}\n\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 igb_write_nvm_srwr(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\tu16 *data)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 i, k, eewr = 0;\n\tu32 attempts = 100000;\n\ts32 ret_val = 0;\n\n\t \n\tif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\n\t    (words == 0)) {\n\t\thw_dbg(\"nvm parameter(s) out of bounds\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\teewr = ((offset+i) << E1000_NVM_RW_ADDR_SHIFT) |\n\t\t\t(data[i] << E1000_NVM_RW_REG_DATA) |\n\t\t\tE1000_NVM_RW_REG_START;\n\n\t\twr32(E1000_SRWR, eewr);\n\n\t\tfor (k = 0; k < attempts; k++) {\n\t\t\tif (E1000_NVM_RW_REG_DONE &\n\t\t\t    rd32(E1000_SRWR)) {\n\t\t\t\tret_val = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(5);\n\t}\n\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Shadow RAM write EEWR timed out\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_write_nvm_srwr_i210(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t   u16 *data)\n{\n\ts32 status = 0;\n\tu16 i, count;\n\n\t \n\tfor (i = 0; i < words; i += E1000_EERD_EEWR_MAX_COUNT) {\n\t\tcount = (words - i) / E1000_EERD_EEWR_MAX_COUNT > 0 ?\n\t\t\tE1000_EERD_EEWR_MAX_COUNT : (words - i);\n\t\tif (!(hw->nvm.ops.acquire(hw))) {\n\t\t\tstatus = igb_write_nvm_srwr(hw, offset, count,\n\t\t\t\t\t\t      data + i);\n\t\t\thw->nvm.ops.release(hw);\n\t\t} else {\n\t\t\tstatus = E1000_ERR_SWFW_SYNC;\n\t\t}\n\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 igb_read_invm_word_i210(struct e1000_hw *hw, u8 address, u16 *data)\n{\n\ts32 status = -E1000_ERR_INVM_VALUE_NOT_FOUND;\n\tu32 invm_dword;\n\tu16 i;\n\tu8 record_type, word_address;\n\n\tfor (i = 0; i < E1000_INVM_SIZE; i++) {\n\t\tinvm_dword = rd32(E1000_INVM_DATA_REG(i));\n\t\t \n\t\trecord_type = INVM_DWORD_TO_RECORD_TYPE(invm_dword);\n\t\tif (record_type == E1000_INVM_UNINITIALIZED_STRUCTURE)\n\t\t\tbreak;\n\t\tif (record_type == E1000_INVM_CSR_AUTOLOAD_STRUCTURE)\n\t\t\ti += E1000_INVM_CSR_AUTOLOAD_DATA_SIZE_IN_DWORDS;\n\t\tif (record_type == E1000_INVM_RSA_KEY_SHA256_STRUCTURE)\n\t\t\ti += E1000_INVM_RSA_KEY_SHA256_DATA_SIZE_IN_DWORDS;\n\t\tif (record_type == E1000_INVM_WORD_AUTOLOAD_STRUCTURE) {\n\t\t\tword_address = INVM_DWORD_TO_WORD_ADDRESS(invm_dword);\n\t\t\tif (word_address == address) {\n\t\t\t\t*data = INVM_DWORD_TO_WORD_DATA(invm_dword);\n\t\t\t\thw_dbg(\"Read INVM Word 0x%02x = %x\\n\",\n\t\t\t\t\t  address, *data);\n\t\t\t\tstatus = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (status)\n\t\thw_dbg(\"Requested word 0x%02x not found in OTP\\n\", address);\n\treturn status;\n}\n\n \nstatic s32 igb_read_invm_i210(struct e1000_hw *hw, u16 offset,\n\t\t\t\tu16 __always_unused words, u16 *data)\n{\n\ts32 ret_val = 0;\n\n\t \n\tswitch (offset) {\n\tcase NVM_MAC_ADDR:\n\t\tret_val = igb_read_invm_word_i210(hw, (u8)offset, &data[0]);\n\t\tret_val |= igb_read_invm_word_i210(hw, (u8)offset+1,\n\t\t\t\t\t\t     &data[1]);\n\t\tret_val |= igb_read_invm_word_i210(hw, (u8)offset+2,\n\t\t\t\t\t\t     &data[2]);\n\t\tif (ret_val)\n\t\t\thw_dbg(\"MAC Addr not found in iNVM\\n\");\n\t\tbreak;\n\tcase NVM_INIT_CTRL_2:\n\t\tret_val = igb_read_invm_word_i210(hw, (u8)offset, data);\n\t\tif (ret_val) {\n\t\t\t*data = NVM_INIT_CTRL_2_DEFAULT_I211;\n\t\t\tret_val = 0;\n\t\t}\n\t\tbreak;\n\tcase NVM_INIT_CTRL_4:\n\t\tret_val = igb_read_invm_word_i210(hw, (u8)offset, data);\n\t\tif (ret_val) {\n\t\t\t*data = NVM_INIT_CTRL_4_DEFAULT_I211;\n\t\t\tret_val = 0;\n\t\t}\n\t\tbreak;\n\tcase NVM_LED_1_CFG:\n\t\tret_val = igb_read_invm_word_i210(hw, (u8)offset, data);\n\t\tif (ret_val) {\n\t\t\t*data = NVM_LED_1_CFG_DEFAULT_I211;\n\t\t\tret_val = 0;\n\t\t}\n\t\tbreak;\n\tcase NVM_LED_0_2_CFG:\n\t\tret_val = igb_read_invm_word_i210(hw, (u8)offset, data);\n\t\tif (ret_val) {\n\t\t\t*data = NVM_LED_0_2_CFG_DEFAULT_I211;\n\t\t\tret_val = 0;\n\t\t}\n\t\tbreak;\n\tcase NVM_ID_LED_SETTINGS:\n\t\tret_val = igb_read_invm_word_i210(hw, (u8)offset, data);\n\t\tif (ret_val) {\n\t\t\t*data = ID_LED_RESERVED_FFFF;\n\t\t\tret_val = 0;\n\t\t}\n\t\tbreak;\n\tcase NVM_SUB_DEV_ID:\n\t\t*data = hw->subsystem_device_id;\n\t\tbreak;\n\tcase NVM_SUB_VEN_ID:\n\t\t*data = hw->subsystem_vendor_id;\n\t\tbreak;\n\tcase NVM_DEV_ID:\n\t\t*data = hw->device_id;\n\t\tbreak;\n\tcase NVM_VEN_ID:\n\t\t*data = hw->vendor_id;\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(\"NVM word 0x%02x is not mapped.\\n\", offset);\n\t\t*data = NVM_RESERVED_WORD;\n\t\tbreak;\n\t}\n\treturn ret_val;\n}\n\n \ns32 igb_read_invm_version(struct e1000_hw *hw,\n\t\t\t  struct e1000_fw_version *invm_ver) {\n\tu32 *record = NULL;\n\tu32 *next_record = NULL;\n\tu32 i = 0;\n\tu32 invm_dword = 0;\n\tu32 invm_blocks = E1000_INVM_SIZE - (E1000_INVM_ULT_BYTES_SIZE /\n\t\t\t\t\t     E1000_INVM_RECORD_SIZE_IN_BYTES);\n\tu32 buffer[E1000_INVM_SIZE];\n\ts32 status = -E1000_ERR_INVM_VALUE_NOT_FOUND;\n\tu16 version = 0;\n\n\t \n\tfor (i = 0; i < E1000_INVM_SIZE; i++) {\n\t\tinvm_dword = rd32(E1000_INVM_DATA_REG(i));\n\t\tbuffer[i] = invm_dword;\n\t}\n\n\t \n\tfor (i = 1; i < invm_blocks; i++) {\n\t\trecord = &buffer[invm_blocks - i];\n\t\tnext_record = &buffer[invm_blocks - i + 1];\n\n\t\t \n\t\tif ((i == 1) && ((*record & E1000_INVM_VER_FIELD_ONE) == 0)) {\n\t\t\tversion = 0;\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\telse if ((i == 1) &&\n\t\t\t ((*record & E1000_INVM_VER_FIELD_TWO) == 0)) {\n\t\t\tversion = (*record & E1000_INVM_VER_FIELD_ONE) >> 3;\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\telse if ((((*record & E1000_INVM_VER_FIELD_ONE) == 0) &&\n\t\t\t ((*record & 0x3) == 0)) || (((*record & 0x3) != 0) &&\n\t\t\t (i != 1))) {\n\t\t\tversion = (*next_record & E1000_INVM_VER_FIELD_TWO)\n\t\t\t\t  >> 13;\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\telse if (((*record & E1000_INVM_VER_FIELD_TWO) == 0) &&\n\t\t\t ((*record & 0x3) == 0)) {\n\t\t\tversion = (*record & E1000_INVM_VER_FIELD_ONE) >> 3;\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!status) {\n\t\tinvm_ver->invm_major = (version & E1000_INVM_MAJOR_MASK)\n\t\t\t\t\t>> E1000_INVM_MAJOR_SHIFT;\n\t\tinvm_ver->invm_minor = version & E1000_INVM_MINOR_MASK;\n\t}\n\t \n\tfor (i = 1; i < invm_blocks; i++) {\n\t\trecord = &buffer[invm_blocks - i];\n\t\tnext_record = &buffer[invm_blocks - i + 1];\n\n\t\t \n\t\tif ((i == 1) && ((*record & E1000_INVM_IMGTYPE_FIELD) == 0)) {\n\t\t\tinvm_ver->invm_img_type = 0;\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\telse if ((((*record & 0x3) == 0) &&\n\t\t\t ((*record & E1000_INVM_IMGTYPE_FIELD) == 0)) ||\n\t\t\t ((((*record & 0x3) != 0) && (i != 1)))) {\n\t\t\tinvm_ver->invm_img_type =\n\t\t\t\t(*next_record & E1000_INVM_IMGTYPE_FIELD) >> 23;\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn status;\n}\n\n \nstatic s32 igb_validate_nvm_checksum_i210(struct e1000_hw *hw)\n{\n\ts32 status = 0;\n\ts32 (*read_op_ptr)(struct e1000_hw *, u16, u16, u16 *);\n\n\tif (!(hw->nvm.ops.acquire(hw))) {\n\n\t\t \n\t\tread_op_ptr = hw->nvm.ops.read;\n\t\thw->nvm.ops.read = igb_read_nvm_eerd;\n\n\t\tstatus = igb_validate_nvm_checksum(hw);\n\n\t\t \n\t\thw->nvm.ops.read = read_op_ptr;\n\n\t\thw->nvm.ops.release(hw);\n\t} else {\n\t\tstatus = E1000_ERR_SWFW_SYNC;\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 igb_update_nvm_checksum_i210(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\n\t \n\tret_val = igb_read_nvm_eerd(hw, 0, 1, &nvm_data);\n\tif (ret_val) {\n\t\thw_dbg(\"EEPROM read failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!(hw->nvm.ops.acquire(hw))) {\n\t\t \n\n\t\tfor (i = 0; i < NVM_CHECKSUM_REG; i++) {\n\t\t\tret_val = igb_read_nvm_eerd(hw, i, 1, &nvm_data);\n\t\t\tif (ret_val) {\n\t\t\t\thw->nvm.ops.release(hw);\n\t\t\t\thw_dbg(\"NVM Read Error while updating checksum.\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tchecksum += nvm_data;\n\t\t}\n\t\tchecksum = (u16) NVM_SUM - checksum;\n\t\tret_val = igb_write_nvm_srwr(hw, NVM_CHECKSUM_REG, 1,\n\t\t\t\t\t\t&checksum);\n\t\tif (ret_val) {\n\t\t\thw->nvm.ops.release(hw);\n\t\t\thw_dbg(\"NVM Write Error while updating checksum.\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\thw->nvm.ops.release(hw);\n\n\t\tret_val = igb_update_flash_i210(hw);\n\t} else {\n\t\tret_val = -E1000_ERR_SWFW_SYNC;\n\t}\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_pool_flash_update_done_i210(struct e1000_hw *hw)\n{\n\ts32 ret_val = -E1000_ERR_NVM;\n\tu32 i, reg;\n\n\tfor (i = 0; i < E1000_FLUDONE_ATTEMPTS; i++) {\n\t\treg = rd32(E1000_EECD);\n\t\tif (reg & E1000_EECD_FLUDONE_I210) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(5);\n\t}\n\n\treturn ret_val;\n}\n\n \nbool igb_get_flash_presence_i210(struct e1000_hw *hw)\n{\n\tu32 eec = 0;\n\tbool ret_val = false;\n\n\teec = rd32(E1000_EECD);\n\tif (eec & E1000_EECD_FLASH_DETECTED_I210)\n\t\tret_val = true;\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_update_flash_i210(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu32 flup;\n\n\tret_val = igb_pool_flash_update_done_i210(hw);\n\tif (ret_val == -E1000_ERR_NVM) {\n\t\thw_dbg(\"Flash update time out\\n\");\n\t\tgoto out;\n\t}\n\n\tflup = rd32(E1000_EECD) | E1000_EECD_FLUPD_I210;\n\twr32(E1000_EECD, flup);\n\n\tret_val = igb_pool_flash_update_done_i210(hw);\n\tif (ret_val)\n\t\thw_dbg(\"Flash update time out\\n\");\n\telse\n\t\thw_dbg(\"Flash update complete\\n\");\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_valid_led_default_i210(struct e1000_hw *hw, u16 *data)\n{\n\ts32 ret_val;\n\n\tret_val = hw->nvm.ops.read(hw, NVM_ID_LED_SETTINGS, 1, data);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (*data == ID_LED_RESERVED_0000 || *data == ID_LED_RESERVED_FFFF) {\n\t\tswitch (hw->phy.media_type) {\n\t\tcase e1000_media_type_internal_serdes:\n\t\t\t*data = ID_LED_DEFAULT_I210_SERDES;\n\t\t\tbreak;\n\t\tcase e1000_media_type_copper:\n\t\tdefault:\n\t\t\t*data = ID_LED_DEFAULT_I210;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 __igb_access_xmdio_reg(struct e1000_hw *hw, u16 address,\n\t\t\t\t  u8 dev_addr, u16 *data, bool read)\n{\n\ts32 ret_val = 0;\n\n\tret_val = hw->phy.ops.write_reg(hw, E1000_MMDAC, dev_addr);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = hw->phy.ops.write_reg(hw, E1000_MMDAAD, address);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = hw->phy.ops.write_reg(hw, E1000_MMDAC, E1000_MMDAC_FUNC_DATA |\n\t\t\t\t\t\t\t dev_addr);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (read)\n\t\tret_val = hw->phy.ops.read_reg(hw, E1000_MMDAAD, data);\n\telse\n\t\tret_val = hw->phy.ops.write_reg(hw, E1000_MMDAAD, *data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = hw->phy.ops.write_reg(hw, E1000_MMDAC, 0);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn ret_val;\n}\n\n \ns32 igb_read_xmdio_reg(struct e1000_hw *hw, u16 addr, u8 dev_addr, u16 *data)\n{\n\treturn __igb_access_xmdio_reg(hw, addr, dev_addr, data, true);\n}\n\n \ns32 igb_write_xmdio_reg(struct e1000_hw *hw, u16 addr, u8 dev_addr, u16 data)\n{\n\treturn __igb_access_xmdio_reg(hw, addr, dev_addr, &data, false);\n}\n\n \ns32 igb_init_nvm_params_i210(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\n\tnvm->ops.acquire = igb_acquire_nvm_i210;\n\tnvm->ops.release = igb_release_nvm_i210;\n\tnvm->ops.valid_led_default = igb_valid_led_default_i210;\n\n\t \n\tif (igb_get_flash_presence_i210(hw)) {\n\t\thw->nvm.type = e1000_nvm_flash_hw;\n\t\tnvm->ops.read    = igb_read_nvm_srrd_i210;\n\t\tnvm->ops.write   = igb_write_nvm_srwr_i210;\n\t\tnvm->ops.validate = igb_validate_nvm_checksum_i210;\n\t\tnvm->ops.update   = igb_update_nvm_checksum_i210;\n\t} else {\n\t\thw->nvm.type = e1000_nvm_invm;\n\t\tnvm->ops.read     = igb_read_invm_i210;\n\t\tnvm->ops.write    = NULL;\n\t\tnvm->ops.validate = NULL;\n\t\tnvm->ops.update   = NULL;\n\t}\n\treturn 0;\n}\n\n \ns32 igb_pll_workaround_i210(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu32 wuc, mdicnfg, ctrl, ctrl_ext, reg_val;\n\tu16 nvm_word, phy_word, pci_word, tmp_nvm;\n\tint i;\n\n\t \n\twuc = rd32(E1000_WUC);\n\tmdicnfg = rd32(E1000_MDICNFG);\n\treg_val = mdicnfg & ~E1000_MDICNFG_EXT_MDIO;\n\twr32(E1000_MDICNFG, reg_val);\n\n\t \n\tret_val = igb_read_invm_word_i210(hw, E1000_INVM_AUTOLOAD,\n\t\t\t\t\t  &nvm_word);\n\tif (ret_val)\n\t\tnvm_word = E1000_INVM_DEFAULT_AL;\n\ttmp_nvm = nvm_word | E1000_INVM_PLL_WO_VAL;\n\tigb_write_phy_reg_82580(hw, I347AT4_PAGE_SELECT, E1000_PHY_PLL_FREQ_PAGE);\n\tphy_word = E1000_PHY_PLL_UNCONF;\n\tfor (i = 0; i < E1000_MAX_PLL_TRIES; i++) {\n\t\t \n\t\tigb_read_phy_reg_82580(hw, E1000_PHY_PLL_FREQ_REG, &phy_word);\n\t\tif ((phy_word & E1000_PHY_PLL_UNCONF)\n\t\t    != E1000_PHY_PLL_UNCONF) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\t}\n\t\t \n\t\tctrl = rd32(E1000_CTRL);\n\t\twr32(E1000_CTRL, ctrl|E1000_CTRL_PHY_RST);\n\n\t\tctrl_ext = rd32(E1000_CTRL_EXT);\n\t\tctrl_ext |= (E1000_CTRL_EXT_PHYPDEN | E1000_CTRL_EXT_SDLPE);\n\t\twr32(E1000_CTRL_EXT, ctrl_ext);\n\n\t\twr32(E1000_WUC, 0);\n\t\treg_val = (E1000_INVM_AUTOLOAD << 4) | (tmp_nvm << 16);\n\t\twr32(E1000_EEARBC_I210, reg_val);\n\n\t\tigb_read_pci_cfg(hw, E1000_PCI_PMCSR, &pci_word);\n\t\tpci_word |= E1000_PCI_PMCSR_D3;\n\t\tigb_write_pci_cfg(hw, E1000_PCI_PMCSR, &pci_word);\n\t\tusleep_range(1000, 2000);\n\t\tpci_word &= ~E1000_PCI_PMCSR_D3;\n\t\tigb_write_pci_cfg(hw, E1000_PCI_PMCSR, &pci_word);\n\t\treg_val = (E1000_INVM_AUTOLOAD << 4) | (nvm_word << 16);\n\t\twr32(E1000_EEARBC_I210, reg_val);\n\n\t\t \n\t\twr32(E1000_WUC, wuc);\n\t}\n\tigb_write_phy_reg_82580(hw, I347AT4_PAGE_SELECT, 0);\n\t \n\twr32(E1000_MDICNFG, mdicnfg);\n\treturn ret_val;\n}\n\n \ns32 igb_get_cfg_done_i210(struct e1000_hw *hw)\n{\n\ts32 timeout = PHY_CFG_TIMEOUT;\n\tu32 mask = E1000_NVM_CFG_DONE_PORT_0;\n\n\twhile (timeout) {\n\t\tif (rd32(E1000_EEMNGCTL_I210) & mask)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\ttimeout--;\n\t}\n\tif (!timeout)\n\t\thw_dbg(\"MNG configuration cycle has not completed.\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}