{
  "module_name": "igb_ethtool.c",
  "hash_id": "444436cdb2978e0e98bc6981b9ec96bb4f1b381f6a94d9b27b1a19eae506ebec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/igb_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/vmalloc.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/if_ether.h>\n#include <linux/ethtool.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/highmem.h>\n#include <linux/mdio.h>\n\n#include \"igb.h\"\n\nstruct igb_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define IGB_STAT(_name, _stat) { \\\n\t.stat_string = _name, \\\n\t.sizeof_stat = sizeof_field(struct igb_adapter, _stat), \\\n\t.stat_offset = offsetof(struct igb_adapter, _stat) \\\n}\nstatic const struct igb_stats igb_gstrings_stats[] = {\n\tIGB_STAT(\"rx_packets\", stats.gprc),\n\tIGB_STAT(\"tx_packets\", stats.gptc),\n\tIGB_STAT(\"rx_bytes\", stats.gorc),\n\tIGB_STAT(\"tx_bytes\", stats.gotc),\n\tIGB_STAT(\"rx_broadcast\", stats.bprc),\n\tIGB_STAT(\"tx_broadcast\", stats.bptc),\n\tIGB_STAT(\"rx_multicast\", stats.mprc),\n\tIGB_STAT(\"tx_multicast\", stats.mptc),\n\tIGB_STAT(\"multicast\", stats.mprc),\n\tIGB_STAT(\"collisions\", stats.colc),\n\tIGB_STAT(\"rx_crc_errors\", stats.crcerrs),\n\tIGB_STAT(\"rx_no_buffer_count\", stats.rnbc),\n\tIGB_STAT(\"rx_missed_errors\", stats.mpc),\n\tIGB_STAT(\"tx_aborted_errors\", stats.ecol),\n\tIGB_STAT(\"tx_carrier_errors\", stats.tncrs),\n\tIGB_STAT(\"tx_window_errors\", stats.latecol),\n\tIGB_STAT(\"tx_abort_late_coll\", stats.latecol),\n\tIGB_STAT(\"tx_deferred_ok\", stats.dc),\n\tIGB_STAT(\"tx_single_coll_ok\", stats.scc),\n\tIGB_STAT(\"tx_multi_coll_ok\", stats.mcc),\n\tIGB_STAT(\"tx_timeout_count\", tx_timeout_count),\n\tIGB_STAT(\"rx_long_length_errors\", stats.roc),\n\tIGB_STAT(\"rx_short_length_errors\", stats.ruc),\n\tIGB_STAT(\"rx_align_errors\", stats.algnerrc),\n\tIGB_STAT(\"tx_tcp_seg_good\", stats.tsctc),\n\tIGB_STAT(\"tx_tcp_seg_failed\", stats.tsctfc),\n\tIGB_STAT(\"rx_flow_control_xon\", stats.xonrxc),\n\tIGB_STAT(\"rx_flow_control_xoff\", stats.xoffrxc),\n\tIGB_STAT(\"tx_flow_control_xon\", stats.xontxc),\n\tIGB_STAT(\"tx_flow_control_xoff\", stats.xofftxc),\n\tIGB_STAT(\"rx_long_byte_count\", stats.gorc),\n\tIGB_STAT(\"tx_dma_out_of_sync\", stats.doosync),\n\tIGB_STAT(\"tx_smbus\", stats.mgptc),\n\tIGB_STAT(\"rx_smbus\", stats.mgprc),\n\tIGB_STAT(\"dropped_smbus\", stats.mgpdc),\n\tIGB_STAT(\"os2bmc_rx_by_bmc\", stats.o2bgptc),\n\tIGB_STAT(\"os2bmc_tx_by_bmc\", stats.b2ospc),\n\tIGB_STAT(\"os2bmc_tx_by_host\", stats.o2bspc),\n\tIGB_STAT(\"os2bmc_rx_by_host\", stats.b2ogprc),\n\tIGB_STAT(\"tx_hwtstamp_timeouts\", tx_hwtstamp_timeouts),\n\tIGB_STAT(\"tx_hwtstamp_skipped\", tx_hwtstamp_skipped),\n\tIGB_STAT(\"rx_hwtstamp_cleared\", rx_hwtstamp_cleared),\n};\n\n#define IGB_NETDEV_STAT(_net_stat) { \\\n\t.stat_string = __stringify(_net_stat), \\\n\t.sizeof_stat = sizeof_field(struct rtnl_link_stats64, _net_stat), \\\n\t.stat_offset = offsetof(struct rtnl_link_stats64, _net_stat) \\\n}\nstatic const struct igb_stats igb_gstrings_net_stats[] = {\n\tIGB_NETDEV_STAT(rx_errors),\n\tIGB_NETDEV_STAT(tx_errors),\n\tIGB_NETDEV_STAT(tx_dropped),\n\tIGB_NETDEV_STAT(rx_length_errors),\n\tIGB_NETDEV_STAT(rx_over_errors),\n\tIGB_NETDEV_STAT(rx_frame_errors),\n\tIGB_NETDEV_STAT(rx_fifo_errors),\n\tIGB_NETDEV_STAT(tx_fifo_errors),\n\tIGB_NETDEV_STAT(tx_heartbeat_errors)\n};\n\n#define IGB_GLOBAL_STATS_LEN\t\\\n\t(sizeof(igb_gstrings_stats) / sizeof(struct igb_stats))\n#define IGB_NETDEV_STATS_LEN\t\\\n\t(sizeof(igb_gstrings_net_stats) / sizeof(struct igb_stats))\n#define IGB_RX_QUEUE_STATS_LEN \\\n\t(sizeof(struct igb_rx_queue_stats) / sizeof(u64))\n\n#define IGB_TX_QUEUE_STATS_LEN 3  \n\n#define IGB_QUEUE_STATS_LEN \\\n\t((((struct igb_adapter *)netdev_priv(netdev))->num_rx_queues * \\\n\t  IGB_RX_QUEUE_STATS_LEN) + \\\n\t (((struct igb_adapter *)netdev_priv(netdev))->num_tx_queues * \\\n\t  IGB_TX_QUEUE_STATS_LEN))\n#define IGB_STATS_LEN \\\n\t(IGB_GLOBAL_STATS_LEN + IGB_NETDEV_STATS_LEN + IGB_QUEUE_STATS_LEN)\n\nenum igb_diagnostics_results {\n\tTEST_REG = 0,\n\tTEST_EEP,\n\tTEST_IRQ,\n\tTEST_LOOP,\n\tTEST_LINK\n};\n\nstatic const char igb_gstrings_test[][ETH_GSTRING_LEN] = {\n\t[TEST_REG]  = \"Register test  (offline)\",\n\t[TEST_EEP]  = \"Eeprom test    (offline)\",\n\t[TEST_IRQ]  = \"Interrupt test (offline)\",\n\t[TEST_LOOP] = \"Loopback test  (offline)\",\n\t[TEST_LINK] = \"Link test   (on/offline)\"\n};\n#define IGB_TEST_LEN (sizeof(igb_gstrings_test) / ETH_GSTRING_LEN)\n\nstatic const char igb_priv_flags_strings[][ETH_GSTRING_LEN] = {\n#define IGB_PRIV_FLAGS_LEGACY_RX\tBIT(0)\n\t\"legacy-rx\",\n};\n\n#define IGB_PRIV_FLAGS_STR_LEN ARRAY_SIZE(igb_priv_flags_strings)\n\nstatic int igb_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\n\tstruct e1000_sfp_flags *eth_flags = &dev_spec->eth_flags;\n\tu32 status;\n\tu32 speed;\n\tu32 supported, advertising;\n\n\tstatus = pm_runtime_suspended(&adapter->pdev->dev) ?\n\t\t 0 : rd32(E1000_STATUS);\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\n\t\tsupported = (SUPPORTED_10baseT_Half |\n\t\t\t     SUPPORTED_10baseT_Full |\n\t\t\t     SUPPORTED_100baseT_Half |\n\t\t\t     SUPPORTED_100baseT_Full |\n\t\t\t     SUPPORTED_1000baseT_Full|\n\t\t\t     SUPPORTED_Autoneg |\n\t\t\t     SUPPORTED_TP |\n\t\t\t     SUPPORTED_Pause);\n\t\tadvertising = ADVERTISED_TP;\n\n\t\tif (hw->mac.autoneg == 1) {\n\t\t\tadvertising |= ADVERTISED_Autoneg;\n\t\t\t \n\t\t\tadvertising |= hw->phy.autoneg_advertised;\n\t\t}\n\n\t\tcmd->base.port = PORT_TP;\n\t\tcmd->base.phy_address = hw->phy.addr;\n\t} else {\n\t\tsupported = (SUPPORTED_FIBRE |\n\t\t\t     SUPPORTED_1000baseKX_Full |\n\t\t\t     SUPPORTED_Autoneg |\n\t\t\t     SUPPORTED_Pause);\n\t\tadvertising = (ADVERTISED_FIBRE |\n\t\t\t       ADVERTISED_1000baseKX_Full);\n\t\tif (hw->mac.type == e1000_i354) {\n\t\t\tif ((hw->device_id ==\n\t\t\t     E1000_DEV_ID_I354_BACKPLANE_2_5GBPS) &&\n\t\t\t    !(status & E1000_STATUS_2P5_SKU_OVER)) {\n\t\t\t\tsupported |= SUPPORTED_2500baseX_Full;\n\t\t\t\tsupported &= ~SUPPORTED_1000baseKX_Full;\n\t\t\t\tadvertising |= ADVERTISED_2500baseX_Full;\n\t\t\t\tadvertising &= ~ADVERTISED_1000baseKX_Full;\n\t\t\t}\n\t\t}\n\t\tif (eth_flags->e100_base_fx || eth_flags->e100_base_lx) {\n\t\t\tsupported |= SUPPORTED_100baseT_Full;\n\t\t\tadvertising |= ADVERTISED_100baseT_Full;\n\t\t}\n\t\tif (hw->mac.autoneg == 1)\n\t\t\tadvertising |= ADVERTISED_Autoneg;\n\n\t\tcmd->base.port = PORT_FIBRE;\n\t}\n\tif (hw->mac.autoneg != 1)\n\t\tadvertising &= ~(ADVERTISED_Pause |\n\t\t\t\t ADVERTISED_Asym_Pause);\n\n\tswitch (hw->fc.requested_mode) {\n\tcase e1000_fc_full:\n\t\tadvertising |= ADVERTISED_Pause;\n\t\tbreak;\n\tcase e1000_fc_rx_pause:\n\t\tadvertising |= (ADVERTISED_Pause |\n\t\t\t\tADVERTISED_Asym_Pause);\n\t\tbreak;\n\tcase e1000_fc_tx_pause:\n\t\tadvertising |=  ADVERTISED_Asym_Pause;\n\t\tbreak;\n\tdefault:\n\t\tadvertising &= ~(ADVERTISED_Pause |\n\t\t\t\t ADVERTISED_Asym_Pause);\n\t}\n\tif (status & E1000_STATUS_LU) {\n\t\tif ((status & E1000_STATUS_2P5_SKU) &&\n\t\t    !(status & E1000_STATUS_2P5_SKU_OVER)) {\n\t\t\tspeed = SPEED_2500;\n\t\t} else if (status & E1000_STATUS_SPEED_1000) {\n\t\t\tspeed = SPEED_1000;\n\t\t} else if (status & E1000_STATUS_SPEED_100) {\n\t\t\tspeed = SPEED_100;\n\t\t} else {\n\t\t\tspeed = SPEED_10;\n\t\t}\n\t\tif ((status & E1000_STATUS_FD) ||\n\t\t    hw->phy.media_type != e1000_media_type_copper)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t} else {\n\t\tspeed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\tcmd->base.speed = speed;\n\tif ((hw->phy.media_type == e1000_media_type_fiber) ||\n\t    hw->mac.autoneg)\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\t \n\tif (hw->phy.media_type == e1000_media_type_copper)\n\t\tcmd->base.eth_tp_mdix = hw->phy.is_mdix ? ETH_TP_MDI_X :\n\t\t\t\t\t\t      ETH_TP_MDI;\n\telse\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\n\tif (hw->phy.mdix == AUTO_ALL_MODES)\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\n\telse\n\t\tcmd->base.eth_tp_mdix_ctrl = hw->phy.mdix;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int igb_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 advertising;\n\n\t \n\tif (igb_check_reset_block(hw)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Cannot change link characteristics when SoL/IDER is active.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\tif (hw->phy.media_type != e1000_media_type_copper)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif ((cmd->base.eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&\n\t\t    (cmd->base.autoneg != AUTONEG_ENABLE)) {\n\t\t\tdev_err(&adapter->pdev->dev, \"forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\thw->mac.autoneg = 1;\n\t\tif (hw->phy.media_type == e1000_media_type_fiber) {\n\t\t\thw->phy.autoneg_advertised = advertising |\n\t\t\t\t\t\t     ADVERTISED_FIBRE |\n\t\t\t\t\t\t     ADVERTISED_Autoneg;\n\t\t\tswitch (adapter->link_speed) {\n\t\t\tcase SPEED_2500:\n\t\t\t\thw->phy.autoneg_advertised =\n\t\t\t\t\tADVERTISED_2500baseX_Full;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_1000:\n\t\t\t\thw->phy.autoneg_advertised =\n\t\t\t\t\tADVERTISED_1000baseT_Full;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_100:\n\t\t\t\thw->phy.autoneg_advertised =\n\t\t\t\t\tADVERTISED_100baseT_Full;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\thw->phy.autoneg_advertised = advertising |\n\t\t\t\t\t\t     ADVERTISED_TP |\n\t\t\t\t\t\t     ADVERTISED_Autoneg;\n\t\t}\n\t\tadvertising = hw->phy.autoneg_advertised;\n\t\tif (adapter->fc_autoneg)\n\t\t\thw->fc.requested_mode = e1000_fc_default;\n\t} else {\n\t\tu32 speed = cmd->base.speed;\n\t\t \n\t\tif (igb_set_spd_dplx(adapter, speed, cmd->base.duplex)) {\n\t\t\tclear_bit(__IGB_RESETTING, &adapter->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\t \n\t\tif (cmd->base.eth_tp_mdix_ctrl == ETH_TP_MDI_AUTO)\n\t\t\thw->phy.mdix = AUTO_ALL_MODES;\n\t\telse\n\t\t\thw->phy.mdix = cmd->base.eth_tp_mdix_ctrl;\n\t}\n\n\t \n\tif (netif_running(adapter->netdev)) {\n\t\tigb_down(adapter);\n\t\tigb_up(adapter);\n\t} else\n\t\tigb_reset(adapter);\n\n\tclear_bit(__IGB_RESETTING, &adapter->state);\n\treturn 0;\n}\n\nstatic u32 igb_get_link(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\n\t \n\tif (!netif_carrier_ok(netdev))\n\t\tmac->get_link_status = 1;\n\n\treturn igb_has_link(adapter);\n}\n\nstatic void igb_get_pauseparam(struct net_device *netdev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tpause->autoneg =\n\t\t(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);\n\n\tif (hw->fc.current_mode == e1000_fc_rx_pause)\n\t\tpause->rx_pause = 1;\n\telse if (hw->fc.current_mode == e1000_fc_tx_pause)\n\t\tpause->tx_pause = 1;\n\telse if (hw->fc.current_mode == e1000_fc_full) {\n\t\tpause->rx_pause = 1;\n\t\tpause->tx_pause = 1;\n\t}\n}\n\nstatic int igb_set_pauseparam(struct net_device *netdev,\n\t\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint retval = 0;\n\tint i;\n\n\t \n\tif (hw->dev_spec._82575.eth_flags.e100_base_fx)\n\t\treturn -EINVAL;\n\n\tadapter->fc_autoneg = pause->autoneg;\n\n\twhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (adapter->fc_autoneg == AUTONEG_ENABLE) {\n\t\thw->fc.requested_mode = e1000_fc_default;\n\t\tif (netif_running(adapter->netdev)) {\n\t\t\tigb_down(adapter);\n\t\t\tigb_up(adapter);\n\t\t} else {\n\t\t\tigb_reset(adapter);\n\t\t}\n\t} else {\n\t\tif (pause->rx_pause && pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_full;\n\t\telse if (pause->rx_pause && !pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_rx_pause;\n\t\telse if (!pause->rx_pause && pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_tx_pause;\n\t\telse if (!pause->rx_pause && !pause->tx_pause)\n\t\t\thw->fc.requested_mode = e1000_fc_none;\n\n\t\thw->fc.current_mode = hw->fc.requested_mode;\n\n\t\tretval = ((hw->phy.media_type == e1000_media_type_copper) ?\n\t\t\t  igb_force_mac_fc(hw) : igb_setup_link(hw));\n\n\t\t \n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tstruct igb_ring *ring = adapter->rx_ring[i];\n\n\t\t\tigb_setup_srrctl(adapter, ring);\n\t\t}\n\t}\n\n\tclear_bit(__IGB_RESETTING, &adapter->state);\n\treturn retval;\n}\n\nstatic u32 igb_get_msglevel(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\treturn adapter->msg_enable;\n}\n\nstatic void igb_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tadapter->msg_enable = data;\n}\n\nstatic int igb_get_regs_len(struct net_device *netdev)\n{\n#define IGB_REGS_LEN 740\n\treturn IGB_REGS_LEN * sizeof(u32);\n}\n\nstatic void igb_get_regs(struct net_device *netdev,\n\t\t\t struct ethtool_regs *regs, void *p)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu8 i;\n\n\tmemset(p, 0, IGB_REGS_LEN * sizeof(u32));\n\n\tregs->version = (1u << 24) | (hw->revision_id << 16) | hw->device_id;\n\n\t \n\tregs_buff[0] = rd32(E1000_CTRL);\n\tregs_buff[1] = rd32(E1000_STATUS);\n\tregs_buff[2] = rd32(E1000_CTRL_EXT);\n\tregs_buff[3] = rd32(E1000_MDIC);\n\tregs_buff[4] = rd32(E1000_SCTL);\n\tregs_buff[5] = rd32(E1000_CONNSW);\n\tregs_buff[6] = rd32(E1000_VET);\n\tregs_buff[7] = rd32(E1000_LEDCTL);\n\tregs_buff[8] = rd32(E1000_PBA);\n\tregs_buff[9] = rd32(E1000_PBS);\n\tregs_buff[10] = rd32(E1000_FRTIMER);\n\tregs_buff[11] = rd32(E1000_TCPTIMER);\n\n\t \n\tregs_buff[12] = rd32(E1000_EECD);\n\n\t \n\t \n\tregs_buff[13] = rd32(E1000_EICS);\n\tregs_buff[14] = rd32(E1000_EICS);\n\tregs_buff[15] = rd32(E1000_EIMS);\n\tregs_buff[16] = rd32(E1000_EIMC);\n\tregs_buff[17] = rd32(E1000_EIAC);\n\tregs_buff[18] = rd32(E1000_EIAM);\n\t \n\tregs_buff[19] = rd32(E1000_ICS);\n\tregs_buff[20] = rd32(E1000_ICS);\n\tregs_buff[21] = rd32(E1000_IMS);\n\tregs_buff[22] = rd32(E1000_IMC);\n\tregs_buff[23] = rd32(E1000_IAC);\n\tregs_buff[24] = rd32(E1000_IAM);\n\tregs_buff[25] = rd32(E1000_IMIRVP);\n\n\t \n\tregs_buff[26] = rd32(E1000_FCAL);\n\tregs_buff[27] = rd32(E1000_FCAH);\n\tregs_buff[28] = rd32(E1000_FCTTV);\n\tregs_buff[29] = rd32(E1000_FCRTL);\n\tregs_buff[30] = rd32(E1000_FCRTH);\n\tregs_buff[31] = rd32(E1000_FCRTV);\n\n\t \n\tregs_buff[32] = rd32(E1000_RCTL);\n\tregs_buff[33] = rd32(E1000_RXCSUM);\n\tregs_buff[34] = rd32(E1000_RLPML);\n\tregs_buff[35] = rd32(E1000_RFCTL);\n\tregs_buff[36] = rd32(E1000_MRQC);\n\tregs_buff[37] = rd32(E1000_VT_CTL);\n\n\t \n\tregs_buff[38] = rd32(E1000_TCTL);\n\tregs_buff[39] = rd32(E1000_TCTL_EXT);\n\tregs_buff[40] = rd32(E1000_TIPG);\n\tregs_buff[41] = rd32(E1000_DTXCTL);\n\n\t \n\tregs_buff[42] = rd32(E1000_WUC);\n\tregs_buff[43] = rd32(E1000_WUFC);\n\tregs_buff[44] = rd32(E1000_WUS);\n\tregs_buff[45] = rd32(E1000_IPAV);\n\tregs_buff[46] = rd32(E1000_WUPL);\n\n\t \n\tregs_buff[47] = rd32(E1000_PCS_CFG0);\n\tregs_buff[48] = rd32(E1000_PCS_LCTL);\n\tregs_buff[49] = rd32(E1000_PCS_LSTAT);\n\tregs_buff[50] = rd32(E1000_PCS_ANADV);\n\tregs_buff[51] = rd32(E1000_PCS_LPAB);\n\tregs_buff[52] = rd32(E1000_PCS_NPTX);\n\tregs_buff[53] = rd32(E1000_PCS_LPABNP);\n\n\t \n\tregs_buff[54] = adapter->stats.crcerrs;\n\tregs_buff[55] = adapter->stats.algnerrc;\n\tregs_buff[56] = adapter->stats.symerrs;\n\tregs_buff[57] = adapter->stats.rxerrc;\n\tregs_buff[58] = adapter->stats.mpc;\n\tregs_buff[59] = adapter->stats.scc;\n\tregs_buff[60] = adapter->stats.ecol;\n\tregs_buff[61] = adapter->stats.mcc;\n\tregs_buff[62] = adapter->stats.latecol;\n\tregs_buff[63] = adapter->stats.colc;\n\tregs_buff[64] = adapter->stats.dc;\n\tregs_buff[65] = adapter->stats.tncrs;\n\tregs_buff[66] = adapter->stats.sec;\n\tregs_buff[67] = adapter->stats.htdpmc;\n\tregs_buff[68] = adapter->stats.rlec;\n\tregs_buff[69] = adapter->stats.xonrxc;\n\tregs_buff[70] = adapter->stats.xontxc;\n\tregs_buff[71] = adapter->stats.xoffrxc;\n\tregs_buff[72] = adapter->stats.xofftxc;\n\tregs_buff[73] = adapter->stats.fcruc;\n\tregs_buff[74] = adapter->stats.prc64;\n\tregs_buff[75] = adapter->stats.prc127;\n\tregs_buff[76] = adapter->stats.prc255;\n\tregs_buff[77] = adapter->stats.prc511;\n\tregs_buff[78] = adapter->stats.prc1023;\n\tregs_buff[79] = adapter->stats.prc1522;\n\tregs_buff[80] = adapter->stats.gprc;\n\tregs_buff[81] = adapter->stats.bprc;\n\tregs_buff[82] = adapter->stats.mprc;\n\tregs_buff[83] = adapter->stats.gptc;\n\tregs_buff[84] = adapter->stats.gorc;\n\tregs_buff[86] = adapter->stats.gotc;\n\tregs_buff[88] = adapter->stats.rnbc;\n\tregs_buff[89] = adapter->stats.ruc;\n\tregs_buff[90] = adapter->stats.rfc;\n\tregs_buff[91] = adapter->stats.roc;\n\tregs_buff[92] = adapter->stats.rjc;\n\tregs_buff[93] = adapter->stats.mgprc;\n\tregs_buff[94] = adapter->stats.mgpdc;\n\tregs_buff[95] = adapter->stats.mgptc;\n\tregs_buff[96] = adapter->stats.tor;\n\tregs_buff[98] = adapter->stats.tot;\n\tregs_buff[100] = adapter->stats.tpr;\n\tregs_buff[101] = adapter->stats.tpt;\n\tregs_buff[102] = adapter->stats.ptc64;\n\tregs_buff[103] = adapter->stats.ptc127;\n\tregs_buff[104] = adapter->stats.ptc255;\n\tregs_buff[105] = adapter->stats.ptc511;\n\tregs_buff[106] = adapter->stats.ptc1023;\n\tregs_buff[107] = adapter->stats.ptc1522;\n\tregs_buff[108] = adapter->stats.mptc;\n\tregs_buff[109] = adapter->stats.bptc;\n\tregs_buff[110] = adapter->stats.tsctc;\n\tregs_buff[111] = adapter->stats.iac;\n\tregs_buff[112] = adapter->stats.rpthc;\n\tregs_buff[113] = adapter->stats.hgptc;\n\tregs_buff[114] = adapter->stats.hgorc;\n\tregs_buff[116] = adapter->stats.hgotc;\n\tregs_buff[118] = adapter->stats.lenerrs;\n\tregs_buff[119] = adapter->stats.scvpc;\n\tregs_buff[120] = adapter->stats.hrmpc;\n\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[121 + i] = rd32(E1000_SRRCTL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[125 + i] = rd32(E1000_PSRTYPE(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[129 + i] = rd32(E1000_RDBAL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[133 + i] = rd32(E1000_RDBAH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[137 + i] = rd32(E1000_RDLEN(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[141 + i] = rd32(E1000_RDH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[145 + i] = rd32(E1000_RDT(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[149 + i] = rd32(E1000_RXDCTL(i));\n\n\tfor (i = 0; i < 10; i++)\n\t\tregs_buff[153 + i] = rd32(E1000_EITR(i));\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[163 + i] = rd32(E1000_IMIR(i));\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[171 + i] = rd32(E1000_IMIREXT(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[179 + i] = rd32(E1000_RAL(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[195 + i] = rd32(E1000_RAH(i));\n\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[211 + i] = rd32(E1000_TDBAL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[215 + i] = rd32(E1000_TDBAH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[219 + i] = rd32(E1000_TDLEN(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[223 + i] = rd32(E1000_TDH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[227 + i] = rd32(E1000_TDT(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[231 + i] = rd32(E1000_TXDCTL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[235 + i] = rd32(E1000_TDWBAL(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[239 + i] = rd32(E1000_TDWBAH(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[243 + i] = rd32(E1000_DCA_TXCTRL(i));\n\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[247 + i] = rd32(E1000_IP4AT_REG(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[251 + i] = rd32(E1000_IP6AT_REG(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[255 + i] = rd32(E1000_WUPM_REG(i));\n\tfor (i = 0; i < 128; i++)\n\t\tregs_buff[287 + i] = rd32(E1000_FFMT_REG(i));\n\tfor (i = 0; i < 128; i++)\n\t\tregs_buff[415 + i] = rd32(E1000_FFVT_REG(i));\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[543 + i] = rd32(E1000_FFLT_REG(i));\n\n\tregs_buff[547] = rd32(E1000_TDFH);\n\tregs_buff[548] = rd32(E1000_TDFT);\n\tregs_buff[549] = rd32(E1000_TDFHS);\n\tregs_buff[550] = rd32(E1000_TDFPC);\n\n\tif (hw->mac.type > e1000_82580) {\n\t\tregs_buff[551] = adapter->stats.o2bgptc;\n\t\tregs_buff[552] = adapter->stats.b2ospc;\n\t\tregs_buff[553] = adapter->stats.o2bspc;\n\t\tregs_buff[554] = adapter->stats.b2ogprc;\n\t}\n\n\tif (hw->mac.type == e1000_82576) {\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[555 + i] = rd32(E1000_SRRCTL(i + 4));\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tregs_buff[567 + i] = rd32(E1000_PSRTYPE(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[571 + i] = rd32(E1000_RDBAL(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[583 + i] = rd32(E1000_RDBAH(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[595 + i] = rd32(E1000_RDLEN(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[607 + i] = rd32(E1000_RDH(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[619 + i] = rd32(E1000_RDT(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[631 + i] = rd32(E1000_RXDCTL(i + 4));\n\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[643 + i] = rd32(E1000_TDBAL(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[655 + i] = rd32(E1000_TDBAH(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[667 + i] = rd32(E1000_TDLEN(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[679 + i] = rd32(E1000_TDH(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[691 + i] = rd32(E1000_TDT(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[703 + i] = rd32(E1000_TXDCTL(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[715 + i] = rd32(E1000_TDWBAL(i + 4));\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tregs_buff[727 + i] = rd32(E1000_TDWBAH(i + 4));\n\t}\n\n\tif (hw->mac.type == e1000_i210 || hw->mac.type == e1000_i211)\n\t\tregs_buff[739] = rd32(E1000_I210_RR2DCDELAY);\n}\n\nstatic int igb_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\treturn adapter->hw.nvm.word_size * 2;\n}\n\nstatic int igb_get_eeprom(struct net_device *netdev,\n\t\t\t  struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tint first_word, last_word;\n\tint ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tif (hw->nvm.type == e1000_nvm_eeprom_spi)\n\t\tret_val = hw->nvm.ops.read(hw, first_word,\n\t\t\t\t\t   last_word - first_word + 1,\n\t\t\t\t\t   eeprom_buff);\n\telse {\n\t\tfor (i = 0; i < last_word - first_word + 1; i++) {\n\t\t\tret_val = hw->nvm.ops.read(hw, first_word + i, 1,\n\t\t\t\t\t\t   &eeprom_buff[i]);\n\t\t\tif (ret_val)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1),\n\t\t\teeprom->len);\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n}\n\nstatic int igb_set_eeprom(struct net_device *netdev,\n\t\t\t  struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tvoid *ptr;\n\tint max_len, first_word, last_word, ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((hw->mac.type >= e1000_i210) &&\n\t    !igb_get_flash_presence_i210(hw)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\n\t\treturn -EFAULT;\n\n\tmax_len = hw->nvm.word_size * 2;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_buff = kmalloc(max_len, GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tptr = (void *)eeprom_buff;\n\n\tif (eeprom->offset & 1) {\n\t\t \n\t\tret_val = hw->nvm.ops.read(hw, first_word, 1,\n\t\t\t\t\t    &eeprom_buff[0]);\n\t\tptr++;\n\t}\n\tif (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {\n\t\t \n\t\tret_val = hw->nvm.ops.read(hw, last_word, 1,\n\t\t\t\t   &eeprom_buff[last_word - first_word]);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(ptr, bytes, eeprom->len);\n\n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tcpu_to_le16s(&eeprom_buff[i]);\n\n\tret_val = hw->nvm.ops.write(hw, first_word,\n\t\t\t\t    last_word - first_word + 1, eeprom_buff);\n\n\t \n\tif (ret_val == 0)\n\t\thw->nvm.ops.update(hw);\n\n\tigb_set_fw_version(adapter);\nout:\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic void igb_get_drvinfo(struct net_device *netdev,\n\t\t\t    struct ethtool_drvinfo *drvinfo)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver,  igb_driver_name, sizeof(drvinfo->driver));\n\n\t \n\tstrscpy(drvinfo->fw_version, adapter->fw_version,\n\t\tsizeof(drvinfo->fw_version));\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\n\tdrvinfo->n_priv_flags = IGB_PRIV_FLAGS_STR_LEN;\n}\n\nstatic void igb_get_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ring,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tring->rx_max_pending = IGB_MAX_RXD;\n\tring->tx_max_pending = IGB_MAX_TXD;\n\tring->rx_pending = adapter->rx_ring_count;\n\tring->tx_pending = adapter->tx_ring_count;\n}\n\nstatic int igb_set_ringparam(struct net_device *netdev,\n\t\t\t     struct ethtool_ringparam *ring,\n\t\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct igb_ring *temp_ring;\n\tint i, err = 0;\n\tu16 new_rx_count, new_tx_count;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tnew_rx_count = min_t(u32, ring->rx_pending, IGB_MAX_RXD);\n\tnew_rx_count = max_t(u16, new_rx_count, IGB_MIN_RXD);\n\tnew_rx_count = ALIGN(new_rx_count, REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\tnew_tx_count = min_t(u32, ring->tx_pending, IGB_MAX_TXD);\n\tnew_tx_count = max_t(u16, new_tx_count, IGB_MIN_TXD);\n\tnew_tx_count = ALIGN(new_tx_count, REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tif ((new_tx_count == adapter->tx_ring_count) &&\n\t    (new_rx_count == adapter->rx_ring_count)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\twhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(adapter->netdev)) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\tadapter->tx_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\tadapter->rx_ring[i]->count = new_rx_count;\n\t\tadapter->tx_ring_count = new_tx_count;\n\t\tadapter->rx_ring_count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\tif (adapter->num_tx_queues > adapter->num_rx_queues)\n\t\ttemp_ring = vmalloc(array_size(sizeof(struct igb_ring),\n\t\t\t\t\t       adapter->num_tx_queues));\n\telse\n\t\ttemp_ring = vmalloc(array_size(sizeof(struct igb_ring),\n\t\t\t\t\t       adapter->num_rx_queues));\n\n\tif (!temp_ring) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_reset;\n\t}\n\n\tigb_down(adapter);\n\n\t \n\tif (new_tx_count != adapter->tx_ring_count) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->tx_ring[i],\n\t\t\t       sizeof(struct igb_ring));\n\n\t\t\ttemp_ring[i].count = new_tx_count;\n\t\t\terr = igb_setup_tx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tigb_free_tx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tigb_free_tx_resources(adapter->tx_ring[i]);\n\n\t\t\tmemcpy(adapter->tx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct igb_ring));\n\t\t}\n\n\t\tadapter->tx_ring_count = new_tx_count;\n\t}\n\n\tif (new_rx_count != adapter->rx_ring_count) {\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->rx_ring[i],\n\t\t\t       sizeof(struct igb_ring));\n\n\t\t\ttemp_ring[i].count = new_rx_count;\n\t\t\terr = igb_setup_rx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tigb_free_rx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tigb_free_rx_resources(adapter->rx_ring[i]);\n\n\t\t\tmemcpy(adapter->rx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct igb_ring));\n\t\t}\n\n\t\tadapter->rx_ring_count = new_rx_count;\n\t}\nerr_setup:\n\tigb_up(adapter);\n\tvfree(temp_ring);\nclear_reset:\n\tclear_bit(__IGB_RESETTING, &adapter->state);\n\treturn err;\n}\n\n \nstruct igb_reg_test {\n\tu16 reg;\n\tu16 reg_offset;\n\tu16 array_len;\n\tu16 test_type;\n\tu32 mask;\n\tu32 write;\n};\n\n \n\n#define PATTERN_TEST\t1\n#define SET_READ_TEST\t2\n#define WRITE_NO_TEST\t3\n#define TABLE32_TEST\t4\n#define TABLE64_TEST_LO\t5\n#define TABLE64_TEST_HI\t6\n\n \nstatic struct igb_reg_test reg_test_i210[] = {\n\t{ E1000_FCAL,\t   0x100, 1,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_FCAH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_FCT,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_RDBAL(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(0),  0x100, 4,  PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t \n\t{ E1000_RDT(0),\t   0x100, 4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_FCRTH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFF0, 0x0000FFF0 },\n\t{ E1000_FCTTV,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_TIPG,\t   0x100, 1,  PATTERN_TEST, 0x3FFFFFFF, 0x3FFFFFFF },\n\t{ E1000_TDBAL(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(0),  0x100, 4,  PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ E1000_TDT(0),\t   0x100, 4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0x003FFFFB },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0xFFFFFFFF },\n\t{ E1000_TCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_LO,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_HI,\n\t\t\t\t\t\t0x900FFFFF, 0xFFFFFFFF },\n\t{ E1000_MTA,\t   0, 128, TABLE32_TEST,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ 0, 0, 0, 0, 0 }\n};\n\n \nstatic struct igb_reg_test reg_test_i350[] = {\n\t{ E1000_FCAL,\t   0x100, 1,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_FCAH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_FCT,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_VET,\t   0x100, 1,  PATTERN_TEST, 0xFFFF0000, 0xFFFF0000 },\n\t{ E1000_RDBAL(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(0),  0x100, 4,  PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ E1000_RDBAL(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(4),  0x40,  4,  PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t \n\t{ E1000_RDT(0),\t   0x100, 4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RDT(4),\t   0x40,  4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_FCRTH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFF0, 0x0000FFF0 },\n\t{ E1000_FCTTV,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_TIPG,\t   0x100, 1,  PATTERN_TEST, 0x3FFFFFFF, 0x3FFFFFFF },\n\t{ E1000_TDBAL(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(0),  0x100, 4,  PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ E1000_TDBAL(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(4),  0x40,  4,  PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ E1000_TDT(0),\t   0x100, 4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_TDT(4),\t   0x40,  4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0x003FFFFB },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0xFFFFFFFF },\n\t{ E1000_TCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_LO,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_HI,\n\t\t\t\t\t\t0xC3FFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA2,\t   0, 16, TABLE64_TEST_LO,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA2,\t   0, 16, TABLE64_TEST_HI,\n\t\t\t\t\t\t0xC3FFFFFF, 0xFFFFFFFF },\n\t{ E1000_MTA,\t   0, 128, TABLE32_TEST,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ 0, 0, 0, 0 }\n};\n\n \nstatic struct igb_reg_test reg_test_82580[] = {\n\t{ E1000_FCAL,\t   0x100, 1,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_FCAH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_FCT,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_VET,\t   0x100, 1,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDBAL(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(0),  0x100, 4,  PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t{ E1000_RDBAL(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(4),  0x40,  4,  PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t \n\t{ E1000_RDT(0),\t   0x100, 4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RDT(4),\t   0x40,  4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_FCRTH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFF0, 0x0000FFF0 },\n\t{ E1000_FCTTV,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_TIPG,\t   0x100, 1,  PATTERN_TEST, 0x3FFFFFFF, 0x3FFFFFFF },\n\t{ E1000_TDBAL(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(0),  0x100, 4,  PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t{ E1000_TDBAL(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(4),  0x40,  4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(4),  0x40,  4,  PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t{ E1000_TDT(0),\t   0x100, 4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_TDT(4),\t   0x40,  4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0x003FFFFB },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0xFFFFFFFF },\n\t{ E1000_TCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_LO,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_HI,\n\t\t\t\t\t\t0x83FFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA2,\t   0, 8, TABLE64_TEST_LO,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA2,\t   0, 8, TABLE64_TEST_HI,\n\t\t\t\t\t\t0x83FFFFFF, 0xFFFFFFFF },\n\t{ E1000_MTA,\t   0, 128, TABLE32_TEST,\n\t\t\t\t\t\t0xFFFFFFFF, 0xFFFFFFFF },\n\t{ 0, 0, 0, 0 }\n};\n\n \nstatic struct igb_reg_test reg_test_82576[] = {\n\t{ E1000_FCAL,\t   0x100, 1,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_FCAH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_FCT,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_VET,\t   0x100, 1,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDBAL(0),  0x100, 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(0),  0x100, 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(0),  0x100, 4, PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t{ E1000_RDBAL(4),  0x40, 12, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(4),  0x40, 12, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(4),  0x40, 12, PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t \n\t{ E1000_RXDCTL(0), 0x100, 4, WRITE_NO_TEST, 0,\n\t  E1000_RXDCTL_QUEUE_ENABLE },\n\t{ E1000_RXDCTL(4), 0x40, 12, WRITE_NO_TEST, 0,\n\t  E1000_RXDCTL_QUEUE_ENABLE },\n\t \n\t{ E1000_RDT(0),\t   0x100, 4,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RDT(4),\t   0x40, 12,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RXDCTL(0), 0x100, 4,  WRITE_NO_TEST, 0, 0 },\n\t{ E1000_RXDCTL(4), 0x40, 12,  WRITE_NO_TEST, 0, 0 },\n\t{ E1000_FCRTH,\t   0x100, 1,  PATTERN_TEST, 0x0000FFF0, 0x0000FFF0 },\n\t{ E1000_FCTTV,\t   0x100, 1,  PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_TIPG,\t   0x100, 1,  PATTERN_TEST, 0x3FFFFFFF, 0x3FFFFFFF },\n\t{ E1000_TDBAL(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(0),  0x100, 4,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(0),  0x100, 4,  PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t{ E1000_TDBAL(4),  0x40, 12,  PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(4),  0x40, 12,  PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(4),  0x40, 12,  PATTERN_TEST, 0x000FFFF0, 0x000FFFFF },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0x003FFFFB },\n\t{ E1000_RCTL,\t   0x100, 1,  SET_READ_TEST, 0x04CFB0FE, 0xFFFFFFFF },\n\t{ E1000_TCTL,\t   0x100, 1,  SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA,\t   0, 16, TABLE64_TEST_HI, 0x83FFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA2,\t   0, 8, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA2,\t   0, 8, TABLE64_TEST_HI, 0x83FFFFFF, 0xFFFFFFFF },\n\t{ E1000_MTA,\t   0, 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ 0, 0, 0, 0 }\n};\n\n \nstatic struct igb_reg_test reg_test_82575[] = {\n\t{ E1000_FCAL,      0x100, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_FCAH,      0x100, 1, PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_FCT,       0x100, 1, PATTERN_TEST, 0x0000FFFF, 0xFFFFFFFF },\n\t{ E1000_VET,       0x100, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDBAL(0),  0x100, 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_RDBAH(0),  0x100, 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RDLEN(0),  0x100, 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t \n\t{ E1000_RXDCTL(0), 0x100, 4, WRITE_NO_TEST, 0,\n\t  E1000_RXDCTL_QUEUE_ENABLE },\n\t \n\t{ E1000_RDT(0),    0x100, 4, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_RXDCTL(0), 0x100, 4, WRITE_NO_TEST, 0, 0 },\n\t{ E1000_FCRTH,     0x100, 1, PATTERN_TEST, 0x0000FFF0, 0x0000FFF0 },\n\t{ E1000_FCTTV,     0x100, 1, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ E1000_TIPG,      0x100, 1, PATTERN_TEST, 0x3FFFFFFF, 0x3FFFFFFF },\n\t{ E1000_TDBAL(0),  0x100, 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ E1000_TDBAH(0),  0x100, 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_TDLEN(0),  0x100, 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ E1000_RCTL,      0x100, 1, SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_RCTL,      0x100, 1, SET_READ_TEST, 0x04CFB3FE, 0x003FFFFB },\n\t{ E1000_RCTL,      0x100, 1, SET_READ_TEST, 0x04CFB3FE, 0xFFFFFFFF },\n\t{ E1000_TCTL,      0x100, 1, SET_READ_TEST, 0xFFFFFFFF, 0x00000000 },\n\t{ E1000_TXCW,      0x100, 1, PATTERN_TEST, 0xC000FFFF, 0x0000FFFF },\n\t{ E1000_RA,        0, 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ E1000_RA,        0, 16, TABLE64_TEST_HI, 0x800FFFFF, 0xFFFFFFFF },\n\t{ E1000_MTA,       0, 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ 0, 0, 0, 0 }\n};\n\nstatic bool reg_pattern_test(struct igb_adapter *adapter, u64 *data,\n\t\t\t     int reg, u32 mask, u32 write)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 pat, val;\n\tstatic const u32 _test[] = {\n\t\t0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};\n\tfor (pat = 0; pat < ARRAY_SIZE(_test); pat++) {\n\t\twr32(reg, (_test[pat] & write));\n\t\tval = rd32(reg) & mask;\n\t\tif (val != (_test[pat] & write & mask)) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"pattern test reg %04X failed: got 0x%08X expected 0x%08X\\n\",\n\t\t\t\treg, val, (_test[pat] & write & mask));\n\t\t\t*data = reg;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool reg_set_and_check(struct igb_adapter *adapter, u64 *data,\n\t\t\t      int reg, u32 mask, u32 write)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 val;\n\n\twr32(reg, write & mask);\n\tval = rd32(reg);\n\tif ((write & mask) != (val & mask)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"set/check reg %04X test failed: got 0x%08X expected 0x%08X\\n\",\n\t\t\treg, (val & mask), (write & mask));\n\t\t*data = reg;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#define REG_PATTERN_TEST(reg, mask, write) \\\n\tdo { \\\n\t\tif (reg_pattern_test(adapter, data, reg, mask, write)) \\\n\t\t\treturn 1; \\\n\t} while (0)\n\n#define REG_SET_AND_CHECK(reg, mask, write) \\\n\tdo { \\\n\t\tif (reg_set_and_check(adapter, data, reg, mask, write)) \\\n\t\t\treturn 1; \\\n\t} while (0)\n\nstatic int igb_reg_test(struct igb_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct igb_reg_test *test;\n\tu32 value, before, after;\n\tu32 i, toggle;\n\n\tswitch (adapter->hw.mac.type) {\n\tcase e1000_i350:\n\tcase e1000_i354:\n\t\ttest = reg_test_i350;\n\t\ttoggle = 0x7FEFF3FF;\n\t\tbreak;\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\ttest = reg_test_i210;\n\t\ttoggle = 0x7FEFF3FF;\n\t\tbreak;\n\tcase e1000_82580:\n\t\ttest = reg_test_82580;\n\t\ttoggle = 0x7FEFF3FF;\n\t\tbreak;\n\tcase e1000_82576:\n\t\ttest = reg_test_82576;\n\t\ttoggle = 0x7FFFF3FF;\n\t\tbreak;\n\tdefault:\n\t\ttest = reg_test_82575;\n\t\ttoggle = 0x7FFFF3FF;\n\t\tbreak;\n\t}\n\n\t \n\tbefore = rd32(E1000_STATUS);\n\tvalue = (rd32(E1000_STATUS) & toggle);\n\twr32(E1000_STATUS, toggle);\n\tafter = rd32(E1000_STATUS) & toggle;\n\tif (value != after) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"failed STATUS register test got: 0x%08X expected: 0x%08X\\n\",\n\t\t\tafter, value);\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\t \n\twr32(E1000_STATUS, before);\n\n\t \n\twhile (test->reg) {\n\t\tfor (i = 0; i < test->array_len; i++) {\n\t\t\tswitch (test->test_type) {\n\t\t\tcase PATTERN_TEST:\n\t\t\t\tREG_PATTERN_TEST(test->reg +\n\t\t\t\t\t\t(i * test->reg_offset),\n\t\t\t\t\t\ttest->mask,\n\t\t\t\t\t\ttest->write);\n\t\t\t\tbreak;\n\t\t\tcase SET_READ_TEST:\n\t\t\t\tREG_SET_AND_CHECK(test->reg +\n\t\t\t\t\t\t(i * test->reg_offset),\n\t\t\t\t\t\ttest->mask,\n\t\t\t\t\t\ttest->write);\n\t\t\t\tbreak;\n\t\t\tcase WRITE_NO_TEST:\n\t\t\t\twritel(test->write,\n\t\t\t\t    (adapter->hw.hw_addr + test->reg)\n\t\t\t\t\t+ (i * test->reg_offset));\n\t\t\t\tbreak;\n\t\t\tcase TABLE32_TEST:\n\t\t\t\tREG_PATTERN_TEST(test->reg + (i * 4),\n\t\t\t\t\t\ttest->mask,\n\t\t\t\t\t\ttest->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_LO:\n\t\t\t\tREG_PATTERN_TEST(test->reg + (i * 8),\n\t\t\t\t\t\ttest->mask,\n\t\t\t\t\t\ttest->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_HI:\n\t\t\t\tREG_PATTERN_TEST((test->reg + 4) + (i * 8),\n\t\t\t\t\t\ttest->mask,\n\t\t\t\t\t\ttest->write);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttest++;\n\t}\n\n\t*data = 0;\n\treturn 0;\n}\n\nstatic int igb_eeprom_test(struct igb_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t*data = 0;\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tif (igb_get_flash_presence_i210(hw)) {\n\t\t\tif (adapter->hw.nvm.ops.validate(&adapter->hw) < 0)\n\t\t\t\t*data = 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (adapter->hw.nvm.ops.validate(&adapter->hw) < 0)\n\t\t\t*data = 2;\n\t\tbreak;\n\t}\n\n\treturn *data;\n}\n\nstatic irqreturn_t igb_test_intr(int irq, void *data)\n{\n\tstruct igb_adapter *adapter = (struct igb_adapter *) data;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tadapter->test_icr |= rd32(E1000_ICR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int igb_intr_test(struct igb_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 mask, ics_mask, i = 0, shared_int = true;\n\tu32 irq = adapter->pdev->irq;\n\n\t*data = 0;\n\n\t \n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\tif (request_irq(adapter->msix_entries[0].vector,\n\t\t\t\tigb_test_intr, 0, netdev->name, adapter)) {\n\t\t\t*data = 1;\n\t\t\treturn -1;\n\t\t}\n\t\twr32(E1000_IVAR_MISC, E1000_IVAR_VALID << 8);\n\t\twr32(E1000_EIMS, BIT(0));\n\t} else if (adapter->flags & IGB_FLAG_HAS_MSI) {\n\t\tshared_int = false;\n\t\tif (request_irq(irq,\n\t\t\t\tigb_test_intr, 0, netdev->name, adapter)) {\n\t\t\t*data = 1;\n\t\t\treturn -1;\n\t\t}\n\t} else if (!request_irq(irq, igb_test_intr, IRQF_PROBE_SHARED,\n\t\t\t\tnetdev->name, adapter)) {\n\t\tshared_int = false;\n\t} else if (request_irq(irq, igb_test_intr, IRQF_SHARED,\n\t\t netdev->name, adapter)) {\n\t\t*data = 1;\n\t\treturn -1;\n\t}\n\tdev_info(&adapter->pdev->dev, \"testing %s interrupt\\n\",\n\t\t(shared_int ? \"shared\" : \"unshared\"));\n\n\t \n\twr32(E1000_IMC, ~0);\n\twrfl();\n\tusleep_range(10000, 11000);\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82575:\n\t\tics_mask = 0x37F47EDD;\n\t\tbreak;\n\tcase e1000_82576:\n\t\tics_mask = 0x77D4FBFD;\n\t\tbreak;\n\tcase e1000_82580:\n\t\tics_mask = 0x77DCFED5;\n\t\tbreak;\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tics_mask = 0x77DCFED5;\n\t\tbreak;\n\tdefault:\n\t\tics_mask = 0x7FFFFFFF;\n\t\tbreak;\n\t}\n\n\t \n\tfor (; i < 31; i++) {\n\t\t \n\t\tmask = BIT(i);\n\n\t\tif (!(mask & ics_mask))\n\t\t\tcontinue;\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\n\t\t\t \n\t\t\twr32(E1000_ICR, ~0);\n\n\t\t\twr32(E1000_IMC, mask);\n\t\t\twr32(E1000_ICS, mask);\n\t\t\twrfl();\n\t\t\tusleep_range(10000, 11000);\n\n\t\t\tif (adapter->test_icr & mask) {\n\t\t\t\t*data = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tadapter->test_icr = 0;\n\n\t\t \n\t\twr32(E1000_ICR, ~0);\n\n\t\twr32(E1000_IMS, mask);\n\t\twr32(E1000_ICS, mask);\n\t\twrfl();\n\t\tusleep_range(10000, 11000);\n\n\t\tif (!(adapter->test_icr & mask)) {\n\t\t\t*data = 4;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\n\t\t\t \n\t\t\twr32(E1000_ICR, ~0);\n\n\t\t\twr32(E1000_IMC, ~mask);\n\t\t\twr32(E1000_ICS, ~mask);\n\t\t\twrfl();\n\t\t\tusleep_range(10000, 11000);\n\n\t\t\tif (adapter->test_icr & mask) {\n\t\t\t\t*data = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twr32(E1000_IMC, ~0);\n\twrfl();\n\tusleep_range(10000, 11000);\n\n\t \n\tif (adapter->flags & IGB_FLAG_HAS_MSIX)\n\t\tfree_irq(adapter->msix_entries[0].vector, adapter);\n\telse\n\t\tfree_irq(irq, adapter);\n\n\treturn *data;\n}\n\nstatic void igb_free_desc_rings(struct igb_adapter *adapter)\n{\n\tigb_free_tx_resources(&adapter->test_tx_ring);\n\tigb_free_rx_resources(&adapter->test_rx_ring);\n}\n\nstatic int igb_setup_desc_rings(struct igb_adapter *adapter)\n{\n\tstruct igb_ring *tx_ring = &adapter->test_tx_ring;\n\tstruct igb_ring *rx_ring = &adapter->test_rx_ring;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint ret_val;\n\n\t \n\ttx_ring->count = IGB_DEFAULT_TXD;\n\ttx_ring->dev = &adapter->pdev->dev;\n\ttx_ring->netdev = adapter->netdev;\n\ttx_ring->reg_idx = adapter->vfs_allocated_count;\n\n\tif (igb_setup_tx_resources(tx_ring)) {\n\t\tret_val = 1;\n\t\tgoto err_nomem;\n\t}\n\n\tigb_setup_tctl(adapter);\n\tigb_configure_tx_ring(adapter, tx_ring);\n\n\t \n\trx_ring->count = IGB_DEFAULT_RXD;\n\trx_ring->dev = &adapter->pdev->dev;\n\trx_ring->netdev = adapter->netdev;\n\trx_ring->reg_idx = adapter->vfs_allocated_count;\n\n\tif (igb_setup_rx_resources(rx_ring)) {\n\t\tret_val = 3;\n\t\tgoto err_nomem;\n\t}\n\n\t \n\twr32(E1000_MRQC, adapter->vfs_allocated_count << 3);\n\n\t \n\tigb_setup_rctl(adapter);\n\tigb_configure_rx_ring(adapter, rx_ring);\n\n\tigb_alloc_rx_buffers(rx_ring, igb_desc_unused(rx_ring));\n\n\treturn 0;\n\nerr_nomem:\n\tigb_free_desc_rings(adapter);\n\treturn ret_val;\n}\n\nstatic void igb_phy_disable_receiver(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\tigb_write_phy_reg(hw, 29, 0x001F);\n\tigb_write_phy_reg(hw, 30, 0x8FFC);\n\tigb_write_phy_reg(hw, 29, 0x001A);\n\tigb_write_phy_reg(hw, 30, 0x8FF0);\n}\n\nstatic int igb_integrated_phy_loopback(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_reg = 0;\n\n\thw->mac.autoneg = false;\n\n\tif (hw->phy.type == e1000_phy_m88) {\n\t\tif (hw->phy.id != I210_I_PHY_ID) {\n\t\t\t \n\t\t\tigb_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, 0x0808);\n\t\t\t \n\t\t\tigb_write_phy_reg(hw, PHY_CONTROL, 0x9140);\n\t\t\t \n\t\t\tigb_write_phy_reg(hw, PHY_CONTROL, 0x8140);\n\t\t} else {\n\t\t\t \n\t\t\tigb_write_phy_reg(hw, I347AT4_PAGE_SELECT, 0);\n\t\t\tigb_write_phy_reg(hw, PHY_CONTROL, 0x4140);\n\t\t}\n\t} else if (hw->phy.type == e1000_phy_82580) {\n\t\t \n\t\tigb_write_phy_reg(hw, I82580_PHY_LBK_CTRL, 0x8041);\n\t}\n\n\t \n\tmsleep(50);\n\n\t \n\tigb_write_phy_reg(hw, PHY_CONTROL, 0x4140);\n\n\t \n\tctrl_reg = rd32(E1000_CTRL);\n\tctrl_reg &= ~E1000_CTRL_SPD_SEL;  \n\tctrl_reg |= (E1000_CTRL_FRCSPD |  \n\t\t     E1000_CTRL_FRCDPX |  \n\t\t     E1000_CTRL_SPD_1000 | \n\t\t     E1000_CTRL_FD |\t  \n\t\t     E1000_CTRL_SLU);\t  \n\n\tif (hw->phy.type == e1000_phy_m88)\n\t\tctrl_reg |= E1000_CTRL_ILOS;  \n\n\twr32(E1000_CTRL, ctrl_reg);\n\n\t \n\tif (hw->phy.type == e1000_phy_m88)\n\t\tigb_phy_disable_receiver(adapter);\n\n\tmsleep(500);\n\treturn 0;\n}\n\nstatic int igb_set_phy_loopback(struct igb_adapter *adapter)\n{\n\treturn igb_integrated_phy_loopback(adapter);\n}\n\nstatic int igb_setup_loopback_test(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 reg;\n\n\treg = rd32(E1000_CTRL_EXT);\n\n\t \n\tif (reg & E1000_CTRL_EXT_LINK_MODE_MASK) {\n\t\tif ((hw->device_id == E1000_DEV_ID_DH89XXCC_SGMII) ||\n\t\t(hw->device_id == E1000_DEV_ID_DH89XXCC_SERDES) ||\n\t\t(hw->device_id == E1000_DEV_ID_DH89XXCC_BACKPLANE) ||\n\t\t(hw->device_id == E1000_DEV_ID_DH89XXCC_SFP) ||\n\t\t(hw->device_id == E1000_DEV_ID_I354_SGMII) ||\n\t\t(hw->device_id == E1000_DEV_ID_I354_BACKPLANE_2_5GBPS)) {\n\t\t\t \n\t\t\treg = rd32(E1000_MPHY_ADDR_CTL);\n\t\t\treg = (reg & E1000_MPHY_ADDR_CTL_OFFSET_MASK) |\n\t\t\tE1000_MPHY_PCS_CLK_REG_OFFSET;\n\t\t\twr32(E1000_MPHY_ADDR_CTL, reg);\n\n\t\t\treg = rd32(E1000_MPHY_DATA);\n\t\t\treg |= E1000_MPHY_PCS_CLK_REG_DIGINELBEN;\n\t\t\twr32(E1000_MPHY_DATA, reg);\n\t\t}\n\n\t\treg = rd32(E1000_RCTL);\n\t\treg |= E1000_RCTL_LBM_TCVR;\n\t\twr32(E1000_RCTL, reg);\n\n\t\twr32(E1000_SCTL, E1000_ENABLE_SERDES_LOOPBACK);\n\n\t\treg = rd32(E1000_CTRL);\n\t\treg &= ~(E1000_CTRL_RFCE |\n\t\t\t E1000_CTRL_TFCE |\n\t\t\t E1000_CTRL_LRST);\n\t\treg |= E1000_CTRL_SLU |\n\t\t       E1000_CTRL_FD;\n\t\twr32(E1000_CTRL, reg);\n\n\t\t \n\t\treg = rd32(E1000_CONNSW);\n\t\treg &= ~E1000_CONNSW_ENRGSRC;\n\t\twr32(E1000_CONNSW, reg);\n\n\t\t \n\t\tif (hw->mac.type >= e1000_82580) {\n\t\t\treg = rd32(E1000_PCS_CFG0);\n\t\t\treg |= E1000_PCS_CFG_IGN_SD;\n\t\t\twr32(E1000_PCS_CFG0, reg);\n\t\t}\n\n\t\t \n\t\treg = rd32(E1000_PCS_LCTL);\n\t\treg &= ~E1000_PCS_LCTL_AN_ENABLE;      \n\t\treg |= E1000_PCS_LCTL_FLV_LINK_UP |    \n\t\t       E1000_PCS_LCTL_FSV_1000 |       \n\t\t       E1000_PCS_LCTL_FDV_FULL |       \n\t\t       E1000_PCS_LCTL_FSD |            \n\t\t       E1000_PCS_LCTL_FORCE_LINK;      \n\t\twr32(E1000_PCS_LCTL, reg);\n\n\t\treturn 0;\n\t}\n\n\treturn igb_set_phy_loopback(adapter);\n}\n\nstatic void igb_loopback_cleanup(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\tu16 phy_reg;\n\n\tif ((hw->device_id == E1000_DEV_ID_DH89XXCC_SGMII) ||\n\t(hw->device_id == E1000_DEV_ID_DH89XXCC_SERDES) ||\n\t(hw->device_id == E1000_DEV_ID_DH89XXCC_BACKPLANE) ||\n\t(hw->device_id == E1000_DEV_ID_DH89XXCC_SFP) ||\n\t(hw->device_id == E1000_DEV_ID_I354_SGMII)) {\n\t\tu32 reg;\n\n\t\t \n\t\treg = rd32(E1000_MPHY_ADDR_CTL);\n\t\treg = (reg & E1000_MPHY_ADDR_CTL_OFFSET_MASK) |\n\t\tE1000_MPHY_PCS_CLK_REG_OFFSET;\n\t\twr32(E1000_MPHY_ADDR_CTL, reg);\n\n\t\treg = rd32(E1000_MPHY_DATA);\n\t\treg &= ~E1000_MPHY_PCS_CLK_REG_DIGINELBEN;\n\t\twr32(E1000_MPHY_DATA, reg);\n\t}\n\n\trctl = rd32(E1000_RCTL);\n\trctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);\n\twr32(E1000_RCTL, rctl);\n\n\thw->mac.autoneg = true;\n\tigb_read_phy_reg(hw, PHY_CONTROL, &phy_reg);\n\tif (phy_reg & MII_CR_LOOPBACK) {\n\t\tphy_reg &= ~MII_CR_LOOPBACK;\n\t\tigb_write_phy_reg(hw, PHY_CONTROL, phy_reg);\n\t\tigb_phy_sw_reset(hw);\n\t}\n}\n\nstatic void igb_create_lbtest_frame(struct sk_buff *skb,\n\t\t\t\t    unsigned int frame_size)\n{\n\tmemset(skb->data, 0xFF, frame_size);\n\tframe_size /= 2;\n\tmemset(&skb->data[frame_size], 0xAA, frame_size - 1);\n\tskb->data[frame_size + 10] = 0xBE;\n\tskb->data[frame_size + 12] = 0xAF;\n}\n\nstatic int igb_check_lbtest_frame(struct igb_rx_buffer *rx_buffer,\n\t\t\t\t  unsigned int frame_size)\n{\n\tunsigned char *data;\n\tbool match = true;\n\n\tframe_size >>= 1;\n\n\tdata = kmap_local_page(rx_buffer->page);\n\n\tif (data[3] != 0xFF ||\n\t    data[frame_size + 10] != 0xBE ||\n\t    data[frame_size + 12] != 0xAF)\n\t\tmatch = false;\n\n\tkunmap_local(data);\n\n\treturn match;\n}\n\nstatic int igb_clean_test_rings(struct igb_ring *rx_ring,\n\t\t\t\tstruct igb_ring *tx_ring,\n\t\t\t\tunsigned int size)\n{\n\tunion e1000_adv_rx_desc *rx_desc;\n\tstruct igb_rx_buffer *rx_buffer_info;\n\tstruct igb_tx_buffer *tx_buffer_info;\n\tu16 rx_ntc, tx_ntc, count = 0;\n\n\t \n\trx_ntc = rx_ring->next_to_clean;\n\ttx_ntc = tx_ring->next_to_clean;\n\trx_desc = IGB_RX_DESC(rx_ring, rx_ntc);\n\n\twhile (rx_desc->wb.upper.length) {\n\t\t \n\t\trx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];\n\n\t\t \n\t\tdma_sync_single_for_cpu(rx_ring->dev,\n\t\t\t\t\trx_buffer_info->dma,\n\t\t\t\t\tsize,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t \n\t\tif (igb_check_lbtest_frame(rx_buffer_info, size))\n\t\t\tcount++;\n\n\t\t \n\t\tdma_sync_single_for_device(rx_ring->dev,\n\t\t\t\t\t   rx_buffer_info->dma,\n\t\t\t\t\t   size,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t \n\t\ttx_buffer_info = &tx_ring->tx_buffer_info[tx_ntc];\n\n\t\t \n\t\tdev_kfree_skb_any(tx_buffer_info->skb);\n\n\t\t \n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer_info, dma),\n\t\t\t\t dma_unmap_len(tx_buffer_info, len),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdma_unmap_len_set(tx_buffer_info, len, 0);\n\n\t\t \n\t\trx_ntc++;\n\t\tif (rx_ntc == rx_ring->count)\n\t\t\trx_ntc = 0;\n\t\ttx_ntc++;\n\t\tif (tx_ntc == tx_ring->count)\n\t\t\ttx_ntc = 0;\n\n\t\t \n\t\trx_desc = IGB_RX_DESC(rx_ring, rx_ntc);\n\t}\n\n\tnetdev_tx_reset_queue(txring_txq(tx_ring));\n\n\t \n\tigb_alloc_rx_buffers(rx_ring, count);\n\trx_ring->next_to_clean = rx_ntc;\n\ttx_ring->next_to_clean = tx_ntc;\n\n\treturn count;\n}\n\nstatic int igb_run_loopback_test(struct igb_adapter *adapter)\n{\n\tstruct igb_ring *tx_ring = &adapter->test_tx_ring;\n\tstruct igb_ring *rx_ring = &adapter->test_rx_ring;\n\tu16 i, j, lc, good_cnt;\n\tint ret_val = 0;\n\tunsigned int size = IGB_RX_HDR_LEN;\n\tnetdev_tx_t tx_ret_val;\n\tstruct sk_buff *skb;\n\n\t \n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn 11;\n\n\t \n\tigb_create_lbtest_frame(skb, size);\n\tskb_put(skb, size);\n\n\t \n\n\tif (rx_ring->count <= tx_ring->count)\n\t\tlc = ((tx_ring->count / 64) * 2) + 1;\n\telse\n\t\tlc = ((rx_ring->count / 64) * 2) + 1;\n\n\tfor (j = 0; j <= lc; j++) {  \n\t\t \n\t\tgood_cnt = 0;\n\n\t\t \n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tskb_get(skb);\n\t\t\ttx_ret_val = igb_xmit_frame_ring(skb, tx_ring);\n\t\t\tif (tx_ret_val == NETDEV_TX_OK)\n\t\t\t\tgood_cnt++;\n\t\t}\n\n\t\tif (good_cnt != 64) {\n\t\t\tret_val = 12;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmsleep(200);\n\n\t\tgood_cnt = igb_clean_test_rings(rx_ring, tx_ring, size);\n\t\tif (good_cnt != 64) {\n\t\t\tret_val = 13;\n\t\t\tbreak;\n\t\t}\n\t}  \n\n\t \n\tkfree_skb(skb);\n\n\treturn ret_val;\n}\n\nstatic int igb_loopback_test(struct igb_adapter *adapter, u64 *data)\n{\n\t \n\tif (igb_check_reset_block(&adapter->hw)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Cannot do PHY loopback test when SoL/IDER is active.\\n\");\n\t\t*data = 0;\n\t\tgoto out;\n\t}\n\n\tif (adapter->hw.mac.type == e1000_i354) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\"Loopback test not supported on i354.\\n\");\n\t\t*data = 0;\n\t\tgoto out;\n\t}\n\t*data = igb_setup_desc_rings(adapter);\n\tif (*data)\n\t\tgoto out;\n\t*data = igb_setup_loopback_test(adapter);\n\tif (*data)\n\t\tgoto err_loopback;\n\t*data = igb_run_loopback_test(adapter);\n\tigb_loopback_cleanup(adapter);\n\nerr_loopback:\n\tigb_free_desc_rings(adapter);\nout:\n\treturn *data;\n}\n\nstatic int igb_link_test(struct igb_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\t*data = 0;\n\tif (hw->phy.media_type == e1000_media_type_internal_serdes) {\n\t\tint i = 0;\n\n\t\thw->mac.serdes_has_link = false;\n\n\t\t \n\t\tdo {\n\t\t\thw->mac.ops.check_for_link(&adapter->hw);\n\t\t\tif (hw->mac.serdes_has_link)\n\t\t\t\treturn *data;\n\t\t\tmsleep(20);\n\t\t} while (i++ < 3750);\n\n\t\t*data = 1;\n\t} else {\n\t\thw->mac.ops.check_for_link(&adapter->hw);\n\t\tif (hw->mac.autoneg)\n\t\t\tmsleep(5000);\n\n\t\tif (!(rd32(E1000_STATUS) & E1000_STATUS_LU))\n\t\t\t*data = 1;\n\t}\n\treturn *data;\n}\n\nstatic void igb_diag_test(struct net_device *netdev,\n\t\t\t  struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tu16 autoneg_advertised;\n\tu8 forced_speed_duplex, autoneg;\n\tbool if_running = netif_running(netdev);\n\n\tset_bit(__IGB_TESTING, &adapter->state);\n\n\t \n\tif (adapter->hw.dev_spec._82575.mas_capable)\n\t\teth_test->flags &= ~ETH_TEST_FL_OFFLINE;\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\t \n\n\t\t \n\t\tautoneg_advertised = adapter->hw.phy.autoneg_advertised;\n\t\tforced_speed_duplex = adapter->hw.mac.forced_speed_duplex;\n\t\tautoneg = adapter->hw.mac.autoneg;\n\n\t\tdev_info(&adapter->pdev->dev, \"offline testing starting\\n\");\n\n\t\t \n\t\tigb_power_up_link(adapter);\n\n\t\t \n\t\tif (igb_link_test(adapter, &data[TEST_LINK]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (if_running)\n\t\t\t \n\t\t\tigb_close(netdev);\n\t\telse\n\t\t\tigb_reset(adapter);\n\n\t\tif (igb_reg_test(adapter, &data[TEST_REG]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tigb_reset(adapter);\n\t\tif (igb_eeprom_test(adapter, &data[TEST_EEP]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tigb_reset(adapter);\n\t\tif (igb_intr_test(adapter, &data[TEST_IRQ]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tigb_reset(adapter);\n\t\t \n\t\tigb_power_up_link(adapter);\n\t\tif (igb_loopback_test(adapter, &data[TEST_LOOP]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tadapter->hw.phy.autoneg_advertised = autoneg_advertised;\n\t\tadapter->hw.mac.forced_speed_duplex = forced_speed_duplex;\n\t\tadapter->hw.mac.autoneg = autoneg;\n\n\t\t \n\t\tadapter->hw.phy.autoneg_wait_to_complete = true;\n\t\tigb_reset(adapter);\n\t\tadapter->hw.phy.autoneg_wait_to_complete = false;\n\n\t\tclear_bit(__IGB_TESTING, &adapter->state);\n\t\tif (if_running)\n\t\t\tigb_open(netdev);\n\t} else {\n\t\tdev_info(&adapter->pdev->dev, \"online testing starting\\n\");\n\n\t\t \n\t\tif (if_running && igb_link_test(adapter, &data[TEST_LINK]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\telse\n\t\t\tdata[TEST_LINK] = 0;\n\n\t\t \n\t\tdata[TEST_REG] = 0;\n\t\tdata[TEST_EEP] = 0;\n\t\tdata[TEST_IRQ] = 0;\n\t\tdata[TEST_LOOP] = 0;\n\n\t\tclear_bit(__IGB_TESTING, &adapter->state);\n\t}\n\tmsleep_interruptible(4 * 1000);\n}\n\nstatic void igb_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\twol->wolopts = 0;\n\n\tif (!(adapter->flags & IGB_FLAG_WOL_SUPPORTED))\n\t\treturn;\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST |\n\t\t\t WAKE_BCAST | WAKE_MAGIC |\n\t\t\t WAKE_PHY;\n\n\t \n\tswitch (adapter->hw.device_id) {\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adapter->wol & E1000_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & E1000_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & E1000_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & E1000_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tif (adapter->wol & E1000_WUFC_LNKC)\n\t\twol->wolopts |= WAKE_PHY;\n}\n\nstatic int igb_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE | WAKE_FILTER))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(adapter->flags & IGB_FLAG_WOL_SUPPORTED))\n\t\treturn wol->wolopts ? -EOPNOTSUPP : 0;\n\n\t \n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_UCAST)\n\t\tadapter->wol |= E1000_WUFC_EX;\n\tif (wol->wolopts & WAKE_MCAST)\n\t\tadapter->wol |= E1000_WUFC_MC;\n\tif (wol->wolopts & WAKE_BCAST)\n\t\tadapter->wol |= E1000_WUFC_BC;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= E1000_WUFC_MAG;\n\tif (wol->wolopts & WAKE_PHY)\n\t\tadapter->wol |= E1000_WUFC_LNKC;\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\n \n#define IGB_LED_ON\t\t0\n\nstatic int igb_set_phys_id(struct net_device *netdev,\n\t\t\t   enum ethtool_phys_id_state state)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tigb_blink_led(hw);\n\t\treturn 2;\n\tcase ETHTOOL_ID_ON:\n\t\tigb_blink_led(hw);\n\t\tbreak;\n\tcase ETHTOOL_ID_OFF:\n\t\tigb_led_off(hw);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tigb_led_off(hw);\n\t\tclear_bit(IGB_LED_ON, &adapter->led_status);\n\t\tigb_cleanup_led(hw);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_set_coalesce(struct net_device *netdev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\n\tif ((ec->rx_coalesce_usecs > IGB_MAX_ITR_USECS) ||\n\t    ((ec->rx_coalesce_usecs > 3) &&\n\t     (ec->rx_coalesce_usecs < IGB_MIN_ITR_USECS)) ||\n\t    (ec->rx_coalesce_usecs == 2))\n\t\treturn -EINVAL;\n\n\tif ((ec->tx_coalesce_usecs > IGB_MAX_ITR_USECS) ||\n\t    ((ec->tx_coalesce_usecs > 3) &&\n\t     (ec->tx_coalesce_usecs < IGB_MIN_ITR_USECS)) ||\n\t    (ec->tx_coalesce_usecs == 2))\n\t\treturn -EINVAL;\n\n\tif ((adapter->flags & IGB_FLAG_QUEUE_PAIRS) && ec->tx_coalesce_usecs)\n\t\treturn -EINVAL;\n\n\t \n\tif (ec->rx_coalesce_usecs == 0) {\n\t\tif (adapter->flags & IGB_FLAG_DMAC)\n\t\t\tadapter->flags &= ~IGB_FLAG_DMAC;\n\t}\n\n\t \n\tif (ec->rx_coalesce_usecs && ec->rx_coalesce_usecs <= 3)\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs;\n\telse\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs << 2;\n\n\t \n\tif (adapter->flags & IGB_FLAG_QUEUE_PAIRS)\n\t\tadapter->tx_itr_setting = adapter->rx_itr_setting;\n\telse if (ec->tx_coalesce_usecs && ec->tx_coalesce_usecs <= 3)\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs;\n\telse\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs << 2;\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++) {\n\t\tstruct igb_q_vector *q_vector = adapter->q_vector[i];\n\t\tq_vector->tx.work_limit = adapter->tx_work_limit;\n\t\tif (q_vector->rx.ring)\n\t\t\tq_vector->itr_val = adapter->rx_itr_setting;\n\t\telse\n\t\t\tq_vector->itr_val = adapter->tx_itr_setting;\n\t\tif (q_vector->itr_val && q_vector->itr_val <= 3)\n\t\t\tq_vector->itr_val = IGB_START_ITR;\n\t\tq_vector->set_itr = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_get_coalesce(struct net_device *netdev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->rx_itr_setting <= 3)\n\t\tec->rx_coalesce_usecs = adapter->rx_itr_setting;\n\telse\n\t\tec->rx_coalesce_usecs = adapter->rx_itr_setting >> 2;\n\n\tif (!(adapter->flags & IGB_FLAG_QUEUE_PAIRS)) {\n\t\tif (adapter->tx_itr_setting <= 3)\n\t\t\tec->tx_coalesce_usecs = adapter->tx_itr_setting;\n\t\telse\n\t\t\tec->tx_coalesce_usecs = adapter->tx_itr_setting >> 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_nway_reset(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tif (netif_running(netdev))\n\t\tigb_reinit_locked(adapter);\n\treturn 0;\n}\n\nstatic int igb_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn IGB_STATS_LEN;\n\tcase ETH_SS_TEST:\n\t\treturn IGB_TEST_LEN;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn IGB_PRIV_FLAGS_STR_LEN;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic void igb_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct rtnl_link_stats64 *net_stats = &adapter->stats64;\n\tunsigned int start;\n\tstruct igb_ring *ring;\n\tint i, j;\n\tchar *p;\n\n\tspin_lock(&adapter->stats64_lock);\n\tigb_update_stats(adapter);\n\n\tfor (i = 0; i < IGB_GLOBAL_STATS_LEN; i++) {\n\t\tp = (char *)adapter + igb_gstrings_stats[i].stat_offset;\n\t\tdata[i] = (igb_gstrings_stats[i].sizeof_stat ==\n\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\tfor (j = 0; j < IGB_NETDEV_STATS_LEN; j++, i++) {\n\t\tp = (char *)net_stats + igb_gstrings_net_stats[j].stat_offset;\n\t\tdata[i] = (igb_gstrings_net_stats[j].sizeof_stat ==\n\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\tfor (j = 0; j < adapter->num_tx_queues; j++) {\n\t\tu64\trestart2;\n\n\t\tring = adapter->tx_ring[j];\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->tx_syncp);\n\t\t\tdata[i]   = ring->tx_stats.packets;\n\t\t\tdata[i+1] = ring->tx_stats.bytes;\n\t\t\tdata[i+2] = ring->tx_stats.restart_queue;\n\t\t} while (u64_stats_fetch_retry(&ring->tx_syncp, start));\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->tx_syncp2);\n\t\t\trestart2  = ring->tx_stats.restart_queue2;\n\t\t} while (u64_stats_fetch_retry(&ring->tx_syncp2, start));\n\t\tdata[i+2] += restart2;\n\n\t\ti += IGB_TX_QUEUE_STATS_LEN;\n\t}\n\tfor (j = 0; j < adapter->num_rx_queues; j++) {\n\t\tring = adapter->rx_ring[j];\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->rx_syncp);\n\t\t\tdata[i]   = ring->rx_stats.packets;\n\t\t\tdata[i+1] = ring->rx_stats.bytes;\n\t\t\tdata[i+2] = ring->rx_stats.drops;\n\t\t\tdata[i+3] = ring->rx_stats.csum_err;\n\t\t\tdata[i+4] = ring->rx_stats.alloc_failed;\n\t\t} while (u64_stats_fetch_retry(&ring->rx_syncp, start));\n\t\ti += IGB_RX_QUEUE_STATS_LEN;\n\t}\n\tspin_unlock(&adapter->stats64_lock);\n}\n\nstatic void igb_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, igb_gstrings_test, sizeof(igb_gstrings_test));\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < IGB_GLOBAL_STATS_LEN; i++)\n\t\t\tethtool_sprintf(&p,\n\t\t\t\t\tigb_gstrings_stats[i].stat_string);\n\t\tfor (i = 0; i < IGB_NETDEV_STATS_LEN; i++)\n\t\t\tethtool_sprintf(&p,\n\t\t\t\t\tigb_gstrings_net_stats[i].stat_string);\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_bytes\", i);\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_restart\", i);\n\t\t}\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_bytes\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_drops\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_csum_err\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_alloc_failed\", i);\n\t\t}\n\t\t \n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(data, igb_priv_flags_strings,\n\t\t       IGB_PRIV_FLAGS_STR_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic int igb_get_ts_info(struct net_device *dev,\n\t\t\t   struct ethtool_ts_info *info)\n{\n\tstruct igb_adapter *adapter = netdev_priv(dev);\n\n\tif (adapter->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(adapter->ptp_clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n\tswitch (adapter->hw.mac.type) {\n\tcase e1000_82575:\n\t\tinfo->so_timestamping =\n\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\t\treturn 0;\n\tcase e1000_82576:\n\tcase e1000_82580:\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tinfo->so_timestamping =\n\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\t\tinfo->tx_types =\n\t\t\tBIT(HWTSTAMP_TX_OFF) |\n\t\t\tBIT(HWTSTAMP_TX_ON);\n\n\t\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE);\n\n\t\t \n\t\tif (adapter->hw.mac.type >= e1000_82580)\n\t\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_ALL);\n\t\telse\n\t\t\tinfo->rx_filters |=\n\t\t\t\tBIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t\tBIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t\tBIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n#define ETHER_TYPE_FULL_MASK ((__force __be16)~0)\nstatic int igb_get_ethtool_nfc_entry(struct igb_adapter *adapter,\n\t\t\t\t     struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp = &cmd->fs;\n\tstruct igb_nfc_filter *rule = NULL;\n\n\t \n\tcmd->data = IGB_MAX_RXNFC_FILTERS;\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node) {\n\t\tif (fsp->location <= rule->sw_idx)\n\t\t\tbreak;\n\t}\n\n\tif (!rule || fsp->location != rule->sw_idx)\n\t\treturn -EINVAL;\n\n\tif (rule->filter.match_flags) {\n\t\tfsp->flow_type = ETHER_FLOW;\n\t\tfsp->ring_cookie = rule->action;\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_ETHER_TYPE) {\n\t\t\tfsp->h_u.ether_spec.h_proto = rule->filter.etype;\n\t\t\tfsp->m_u.ether_spec.h_proto = ETHER_TYPE_FULL_MASK;\n\t\t}\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_VLAN_TCI) {\n\t\t\tfsp->flow_type |= FLOW_EXT;\n\t\t\tfsp->h_ext.vlan_tci = rule->filter.vlan_tci;\n\t\t\tfsp->m_ext.vlan_tci = htons(VLAN_PRIO_MASK);\n\t\t}\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_DST_MAC_ADDR) {\n\t\t\tether_addr_copy(fsp->h_u.ether_spec.h_dest,\n\t\t\t\t\trule->filter.dst_addr);\n\t\t\t \n\t\t\teth_broadcast_addr(fsp->m_u.ether_spec.h_dest);\n\t\t}\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_SRC_MAC_ADDR) {\n\t\t\tether_addr_copy(fsp->h_u.ether_spec.h_source,\n\t\t\t\t\trule->filter.src_addr);\n\t\t\t \n\t\t\teth_broadcast_addr(fsp->m_u.ether_spec.h_source);\n\t\t}\n\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int igb_get_ethtool_nfc_all(struct igb_adapter *adapter,\n\t\t\t\t   struct ethtool_rxnfc *cmd,\n\t\t\t\t   u32 *rule_locs)\n{\n\tstruct igb_nfc_filter *rule;\n\tint cnt = 0;\n\n\t \n\tcmd->data = IGB_MAX_RXNFC_FILTERS;\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node) {\n\t\tif (cnt == cmd->rule_cnt)\n\t\t\treturn -EMSGSIZE;\n\t\trule_locs[cnt] = rule->sw_idx;\n\t\tcnt++;\n\t}\n\n\tcmd->rule_cnt = cnt;\n\n\treturn 0;\n}\n\nstatic int igb_get_rss_hash_opts(struct igb_adapter *adapter,\n\t\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tcmd->data = 0;\n\n\t \n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase UDP_V4_FLOW:\n\t\tif (adapter->flags & IGB_FLAG_RSS_FIELD_IPV4_UDP)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase UDP_V6_FLOW:\n\t\tif (adapter->flags & IGB_FLAG_RSS_FIELD_IPV6_UDP)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t u32 *rule_locs)\n{\n\tstruct igb_adapter *adapter = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = adapter->num_rx_queues;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = adapter->nfc_filter_count;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = igb_get_ethtool_nfc_entry(adapter, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tret = igb_get_ethtool_nfc_all(adapter, cmd, rule_locs);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\tret = igb_get_rss_hash_opts(adapter, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#define UDP_RSS_FLAGS (IGB_FLAG_RSS_FIELD_IPV4_UDP | \\\n\t\t       IGB_FLAG_RSS_FIELD_IPV6_UDP)\nstatic int igb_set_rss_hash_opt(struct igb_adapter *adapter,\n\t\t\t\tstruct ethtool_rxnfc *nfc)\n{\n\tu32 flags = adapter->flags;\n\n\t \n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    !(nfc->data & RXH_L4_B_0_1) ||\n\t\t    !(nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tflags &= ~IGB_FLAG_RSS_FIELD_IPV4_UDP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tflags |= IGB_FLAG_RSS_FIELD_IPV4_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tflags &= ~IGB_FLAG_RSS_FIELD_IPV6_UDP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tflags |= IGB_FLAG_RSS_FIELD_IPV6_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    (nfc->data & RXH_L4_B_0_1) ||\n\t\t    (nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (flags != adapter->flags) {\n\t\tstruct e1000_hw *hw = &adapter->hw;\n\t\tu32 mrqc = rd32(E1000_MRQC);\n\n\t\tif ((flags & UDP_RSS_FLAGS) &&\n\t\t    !(adapter->flags & UDP_RSS_FLAGS))\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\\n\");\n\n\t\tadapter->flags = flags;\n\n\t\t \n\t\tmrqc |= E1000_MRQC_RSS_FIELD_IPV4 |\n\t\t\tE1000_MRQC_RSS_FIELD_IPV4_TCP |\n\t\t\tE1000_MRQC_RSS_FIELD_IPV6 |\n\t\t\tE1000_MRQC_RSS_FIELD_IPV6_TCP;\n\n\t\tmrqc &= ~(E1000_MRQC_RSS_FIELD_IPV4_UDP |\n\t\t\t  E1000_MRQC_RSS_FIELD_IPV6_UDP);\n\n\t\tif (flags & IGB_FLAG_RSS_FIELD_IPV4_UDP)\n\t\t\tmrqc |= E1000_MRQC_RSS_FIELD_IPV4_UDP;\n\n\t\tif (flags & IGB_FLAG_RSS_FIELD_IPV6_UDP)\n\t\t\tmrqc |= E1000_MRQC_RSS_FIELD_IPV6_UDP;\n\n\t\twr32(E1000_MRQC, mrqc);\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_rxnfc_write_etype_filter(struct igb_adapter *adapter,\n\t\t\t\t\tstruct igb_nfc_filter *input)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu8 i;\n\tu32 etqf;\n\tu16 etype;\n\n\t \n\tfor (i = 0; i < MAX_ETYPE_FILTER; ++i) {\n\t\tif (!adapter->etype_bitmap[i])\n\t\t\tbreak;\n\t}\n\tif (i == MAX_ETYPE_FILTER) {\n\t\tdev_err(&adapter->pdev->dev, \"ethtool -N: etype filters are all used.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->etype_bitmap[i] = true;\n\n\tetqf = rd32(E1000_ETQF(i));\n\tetype = ntohs(input->filter.etype & ETHER_TYPE_FULL_MASK);\n\n\tetqf |= E1000_ETQF_FILTER_ENABLE;\n\tetqf &= ~E1000_ETQF_ETYPE_MASK;\n\tetqf |= (etype & E1000_ETQF_ETYPE_MASK);\n\n\tetqf &= ~E1000_ETQF_QUEUE_MASK;\n\tetqf |= ((input->action << E1000_ETQF_QUEUE_SHIFT)\n\t\t& E1000_ETQF_QUEUE_MASK);\n\tetqf |= E1000_ETQF_QUEUE_ENABLE;\n\n\twr32(E1000_ETQF(i), etqf);\n\n\tinput->etype_reg_index = i;\n\n\treturn 0;\n}\n\nstatic int igb_rxnfc_write_vlan_prio_filter(struct igb_adapter *adapter,\n\t\t\t\t\t    struct igb_nfc_filter *input)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu8 vlan_priority;\n\tu16 queue_index;\n\tu32 vlapqf;\n\n\tvlapqf = rd32(E1000_VLAPQF);\n\tvlan_priority = (ntohs(input->filter.vlan_tci) & VLAN_PRIO_MASK)\n\t\t\t\t>> VLAN_PRIO_SHIFT;\n\tqueue_index = (vlapqf >> (vlan_priority * 4)) & E1000_VLAPQF_QUEUE_MASK;\n\n\t \n\tif ((vlapqf & E1000_VLAPQF_P_VALID(vlan_priority)) &&\n\t    (queue_index != input->action)) {\n\t\tdev_err(&adapter->pdev->dev, \"ethtool rxnfc set vlan prio filter failed.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tvlapqf |= E1000_VLAPQF_P_VALID(vlan_priority);\n\tvlapqf |= E1000_VLAPQF_QUEUE_SEL(vlan_priority, input->action);\n\n\twr32(E1000_VLAPQF, vlapqf);\n\n\treturn 0;\n}\n\nint igb_add_filter(struct igb_adapter *adapter, struct igb_nfc_filter *input)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err = -EINVAL;\n\n\tif (hw->mac.type == e1000_i210 &&\n\t    !(input->filter.match_flags & ~IGB_FILTER_FLAG_SRC_MAC_ADDR)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"i210 doesn't support flow classification rules specifying only source addresses.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_ETHER_TYPE) {\n\t\terr = igb_rxnfc_write_etype_filter(adapter, input);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_DST_MAC_ADDR) {\n\t\terr = igb_add_mac_steering_filter(adapter,\n\t\t\t\t\t\t  input->filter.dst_addr,\n\t\t\t\t\t\t  input->action, 0);\n\t\terr = min_t(int, err, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_SRC_MAC_ADDR) {\n\t\terr = igb_add_mac_steering_filter(adapter,\n\t\t\t\t\t\t  input->filter.src_addr,\n\t\t\t\t\t\t  input->action,\n\t\t\t\t\t\t  IGB_MAC_STATE_SRC_ADDR);\n\t\terr = min_t(int, err, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_VLAN_TCI)\n\t\terr = igb_rxnfc_write_vlan_prio_filter(adapter, input);\n\n\treturn err;\n}\n\nstatic void igb_clear_etype_filter_regs(struct igb_adapter *adapter,\n\t\t\t\t\tu16 reg_index)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 etqf = rd32(E1000_ETQF(reg_index));\n\n\tetqf &= ~E1000_ETQF_QUEUE_ENABLE;\n\tetqf &= ~E1000_ETQF_QUEUE_MASK;\n\tetqf &= ~E1000_ETQF_FILTER_ENABLE;\n\n\twr32(E1000_ETQF(reg_index), etqf);\n\n\tadapter->etype_bitmap[reg_index] = false;\n}\n\nstatic void igb_clear_vlan_prio_filter(struct igb_adapter *adapter,\n\t\t\t\t       u16 vlan_tci)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu8 vlan_priority;\n\tu32 vlapqf;\n\n\tvlan_priority = (vlan_tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n\n\tvlapqf = rd32(E1000_VLAPQF);\n\tvlapqf &= ~E1000_VLAPQF_P_VALID(vlan_priority);\n\tvlapqf &= ~E1000_VLAPQF_QUEUE_SEL(vlan_priority,\n\t\t\t\t\t\tE1000_VLAPQF_QUEUE_MASK);\n\n\twr32(E1000_VLAPQF, vlapqf);\n}\n\nint igb_erase_filter(struct igb_adapter *adapter, struct igb_nfc_filter *input)\n{\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_ETHER_TYPE)\n\t\tigb_clear_etype_filter_regs(adapter,\n\t\t\t\t\t    input->etype_reg_index);\n\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_VLAN_TCI)\n\t\tigb_clear_vlan_prio_filter(adapter,\n\t\t\t\t\t   ntohs(input->filter.vlan_tci));\n\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_SRC_MAC_ADDR)\n\t\tigb_del_mac_steering_filter(adapter, input->filter.src_addr,\n\t\t\t\t\t    input->action,\n\t\t\t\t\t    IGB_MAC_STATE_SRC_ADDR);\n\n\tif (input->filter.match_flags & IGB_FILTER_FLAG_DST_MAC_ADDR)\n\t\tigb_del_mac_steering_filter(adapter, input->filter.dst_addr,\n\t\t\t\t\t    input->action, 0);\n\n\treturn 0;\n}\n\nstatic int igb_update_ethtool_nfc_entry(struct igb_adapter *adapter,\n\t\t\t\t\tstruct igb_nfc_filter *input,\n\t\t\t\t\tu16 sw_idx)\n{\n\tstruct igb_nfc_filter *rule, *parent;\n\tint err = -EINVAL;\n\n\tparent = NULL;\n\trule = NULL;\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node) {\n\t\t \n\t\tif (rule->sw_idx >= sw_idx)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\t \n\tif (rule && (rule->sw_idx == sw_idx)) {\n\t\tif (!input)\n\t\t\terr = igb_erase_filter(adapter, rule);\n\n\t\thlist_del(&rule->nfc_node);\n\t\tkfree(rule);\n\t\tadapter->nfc_filter_count--;\n\t}\n\n\t \n\tif (!input)\n\t\treturn err;\n\n\t \n\tINIT_HLIST_NODE(&input->nfc_node);\n\n\t \n\tif (parent)\n\t\thlist_add_behind(&input->nfc_node, &parent->nfc_node);\n\telse\n\t\thlist_add_head(&input->nfc_node, &adapter->nfc_filter_list);\n\n\t \n\tadapter->nfc_filter_count++;\n\n\treturn 0;\n}\n\nstatic int igb_add_ethtool_nfc_entry(struct igb_adapter *adapter,\n\t\t\t\t     struct ethtool_rxnfc *cmd)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct igb_nfc_filter *input, *rule;\n\tint err = 0;\n\n\tif (!(netdev->hw_features & NETIF_F_NTUPLE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((fsp->ring_cookie == RX_CLS_FLOW_DISC) ||\n\t    (fsp->ring_cookie >= adapter->num_rx_queues)) {\n\t\tdev_err(&adapter->pdev->dev, \"ethtool -N: The specified action is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fsp->location >= IGB_MAX_RXNFC_FILTERS) {\n\t\tdev_err(&adapter->pdev->dev, \"Location out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((fsp->flow_type & ~FLOW_EXT) != ETHER_FLOW)\n\t\treturn -EINVAL;\n\n\tinput = kzalloc(sizeof(*input), GFP_KERNEL);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tif (fsp->m_u.ether_spec.h_proto == ETHER_TYPE_FULL_MASK) {\n\t\tinput->filter.etype = fsp->h_u.ether_spec.h_proto;\n\t\tinput->filter.match_flags = IGB_FILTER_FLAG_ETHER_TYPE;\n\t}\n\n\t \n\tif (is_broadcast_ether_addr(fsp->m_u.ether_spec.h_source)) {\n\t\tinput->filter.match_flags |= IGB_FILTER_FLAG_SRC_MAC_ADDR;\n\t\tether_addr_copy(input->filter.src_addr,\n\t\t\t\tfsp->h_u.ether_spec.h_source);\n\t}\n\n\t \n\tif (is_broadcast_ether_addr(fsp->m_u.ether_spec.h_dest)) {\n\t\tinput->filter.match_flags |= IGB_FILTER_FLAG_DST_MAC_ADDR;\n\t\tether_addr_copy(input->filter.dst_addr,\n\t\t\t\tfsp->h_u.ether_spec.h_dest);\n\t}\n\n\tif ((fsp->flow_type & FLOW_EXT) && fsp->m_ext.vlan_tci) {\n\t\tif (fsp->m_ext.vlan_tci != htons(VLAN_PRIO_MASK)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tinput->filter.vlan_tci = fsp->h_ext.vlan_tci;\n\t\tinput->filter.match_flags |= IGB_FILTER_FLAG_VLAN_TCI;\n\t}\n\n\tinput->action = fsp->ring_cookie;\n\tinput->sw_idx = fsp->location;\n\n\tspin_lock(&adapter->nfc_lock);\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node) {\n\t\tif (!memcmp(&input->filter, &rule->filter,\n\t\t\t    sizeof(input->filter))) {\n\t\t\terr = -EEXIST;\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"ethtool: this filter is already set\\n\");\n\t\t\tgoto err_out_w_lock;\n\t\t}\n\t}\n\n\terr = igb_add_filter(adapter, input);\n\tif (err)\n\t\tgoto err_out_w_lock;\n\n\terr = igb_update_ethtool_nfc_entry(adapter, input, input->sw_idx);\n\tif (err)\n\t\tgoto err_out_input_filter;\n\n\tspin_unlock(&adapter->nfc_lock);\n\treturn 0;\n\nerr_out_input_filter:\n\tigb_erase_filter(adapter, input);\nerr_out_w_lock:\n\tspin_unlock(&adapter->nfc_lock);\nerr_out:\n\tkfree(input);\n\treturn err;\n}\n\nstatic int igb_del_ethtool_nfc_entry(struct igb_adapter *adapter,\n\t\t\t\t     struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tint err;\n\n\tspin_lock(&adapter->nfc_lock);\n\terr = igb_update_ethtool_nfc_entry(adapter, NULL, fsp->location);\n\tspin_unlock(&adapter->nfc_lock);\n\n\treturn err;\n}\n\nstatic int igb_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct igb_adapter *adapter = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = igb_set_rss_hash_opt(adapter, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = igb_add_ethtool_nfc_entry(adapter, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = igb_del_ethtool_nfc_entry(adapter, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int igb_get_eee(struct net_device *netdev, struct ethtool_eee *edata)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ret_val;\n\tu16 phy_data;\n\n\tif ((hw->mac.type < e1000_i350) ||\n\t    (hw->phy.media_type != e1000_media_type_copper))\n\t\treturn -EOPNOTSUPP;\n\n\tedata->supported = (SUPPORTED_1000baseT_Full |\n\t\t\t    SUPPORTED_100baseT_Full);\n\tif (!hw->dev_spec._82575.eee_disable)\n\t\tedata->advertised =\n\t\t\tmmd_eee_adv_to_ethtool_adv_t(adapter->eee_advert);\n\n\t \n\tif (hw->mac.type == e1000_i354) {\n\t\tigb_get_eee_status_i354(hw, (bool *)&edata->eee_active);\n\t} else {\n\t\tu32 eeer;\n\n\t\teeer = rd32(E1000_EEER);\n\n\t\t \n\t\tif (eeer & E1000_EEER_EEE_NEG)\n\t\t\tedata->eee_active = true;\n\n\t\tif (eeer & E1000_EEER_TX_LPI_EN)\n\t\t\tedata->tx_lpi_enabled = true;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_i350:\n\t\tret_val = igb_read_emi_reg(hw, E1000_EEE_LP_ADV_ADDR_I350,\n\t\t\t\t\t   &phy_data);\n\t\tif (ret_val)\n\t\t\treturn -ENODATA;\n\n\t\tedata->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(phy_data);\n\t\tbreak;\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tret_val = igb_read_xmdio_reg(hw, E1000_EEE_LP_ADV_ADDR_I210,\n\t\t\t\t\t     E1000_EEE_LP_ADV_DEV_I210,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\treturn -ENODATA;\n\n\t\tedata->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(phy_data);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tedata->eee_enabled = !hw->dev_spec._82575.eee_disable;\n\n\tif ((hw->mac.type == e1000_i354) &&\n\t    (edata->eee_enabled))\n\t\tedata->tx_lpi_enabled = true;\n\n\t \n\tif (adapter->link_duplex == HALF_DUPLEX) {\n\t\tedata->eee_enabled = false;\n\t\tedata->eee_active = false;\n\t\tedata->tx_lpi_enabled = false;\n\t\tedata->advertised &= ~edata->advertised;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_set_eee(struct net_device *netdev,\n\t\t       struct ethtool_eee *edata)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct ethtool_eee eee_curr;\n\tbool adv1g_eee = true, adv100m_eee = true;\n\ts32 ret_val;\n\n\tif ((hw->mac.type < e1000_i350) ||\n\t    (hw->phy.media_type != e1000_media_type_copper))\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&eee_curr, 0, sizeof(struct ethtool_eee));\n\n\tret_val = igb_get_eee(netdev, &eee_curr);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (eee_curr.eee_enabled) {\n\t\tif (eee_curr.tx_lpi_enabled != edata->tx_lpi_enabled) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Setting EEE tx-lpi is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (edata->tx_lpi_timer) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Setting EEE Tx LPI timer is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!edata->advertised || (edata->advertised &\n\t\t    ~(ADVERTISE_100_FULL | ADVERTISE_1000_FULL))) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"EEE Advertisement supports only 100Tx and/or 100T full duplex\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tadv100m_eee = !!(edata->advertised & ADVERTISE_100_FULL);\n\t\tadv1g_eee = !!(edata->advertised & ADVERTISE_1000_FULL);\n\n\t} else if (!edata->eee_enabled) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Setting EEE options are not supported with EEE disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->eee_advert = ethtool_adv_to_mmd_eee_adv_t(edata->advertised);\n\tif (hw->dev_spec._82575.eee_disable != !edata->eee_enabled) {\n\t\thw->dev_spec._82575.eee_disable = !edata->eee_enabled;\n\t\tadapter->flags |= IGB_FLAG_EEE;\n\n\t\t \n\t\tif (netif_running(netdev))\n\t\t\tigb_reinit_locked(adapter);\n\t\telse\n\t\t\tigb_reset(adapter);\n\t}\n\n\tif (hw->mac.type == e1000_i354)\n\t\tret_val = igb_set_eee_i354(hw, adv1g_eee, adv100m_eee);\n\telse\n\t\tret_val = igb_set_eee_i350(hw, adv1g_eee, adv100m_eee);\n\n\tif (ret_val) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Problem setting EEE advertisement options\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_get_module_info(struct net_device *netdev,\n\t\t\t       struct ethtool_modinfo *modinfo)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 status = 0;\n\tu16 sff8472_rev, addr_mode;\n\tbool page_swap = false;\n\n\tif ((hw->phy.media_type == e1000_media_type_copper) ||\n\t    (hw->phy.media_type == e1000_media_type_unknown))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tstatus = igb_read_phy_reg_i2c(hw, IGB_SFF_8472_COMP, &sff8472_rev);\n\tif (status)\n\t\treturn -EIO;\n\n\t \n\tstatus = igb_read_phy_reg_i2c(hw, IGB_SFF_8472_SWAP, &addr_mode);\n\tif (status)\n\t\treturn -EIO;\n\n\t \n\tif ((addr_mode & 0xFF) & IGB_SFF_ADDRESSING_MODE) {\n\t\thw_dbg(\"Address change required to access page 0xA2, but not supported. Please report the module type to the driver maintainers.\\n\");\n\t\tpage_swap = true;\n\t}\n\n\tif ((sff8472_rev & 0xFF) == IGB_SFF_8472_UNSUP || page_swap) {\n\t\t \n\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t} else {\n\t\t \n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_get_module_eeprom(struct net_device *netdev,\n\t\t\t\t struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 status = 0;\n\tu16 *dataword;\n\tu16 first_word, last_word;\n\tint i = 0;\n\n\tif (ee->len == 0)\n\t\treturn -EINVAL;\n\n\tfirst_word = ee->offset >> 1;\n\tlast_word = (ee->offset + ee->len - 1) >> 1;\n\n\tdataword = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t GFP_KERNEL);\n\tif (!dataword)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++) {\n\t\tstatus = igb_read_phy_reg_i2c(hw, (first_word + i) * 2,\n\t\t\t\t\t      &dataword[i]);\n\t\tif (status) {\n\t\t\t \n\t\t\tkfree(dataword);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbe16_to_cpus(&dataword[i]);\n\t}\n\n\tmemcpy(data, (u8 *)dataword + (ee->offset & 1), ee->len);\n\tkfree(dataword);\n\n\treturn 0;\n}\n\nstatic int igb_ethtool_begin(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tpm_runtime_get_sync(&adapter->pdev->dev);\n\treturn 0;\n}\n\nstatic void igb_ethtool_complete(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tpm_runtime_put(&adapter->pdev->dev);\n}\n\nstatic u32 igb_get_rxfh_indir_size(struct net_device *netdev)\n{\n\treturn IGB_RETA_SIZE;\n}\n\nstatic int igb_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\tu8 *hfunc)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (!indir)\n\t\treturn 0;\n\tfor (i = 0; i < IGB_RETA_SIZE; i++)\n\t\tindir[i] = adapter->rss_indir_tbl[i];\n\n\treturn 0;\n}\n\nvoid igb_write_rss_indir_tbl(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 reg = E1000_RETA(0);\n\tu32 shift = 0;\n\tint i = 0;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82575:\n\t\tshift = 6;\n\t\tbreak;\n\tcase e1000_82576:\n\t\t \n\t\tif (adapter->vfs_allocated_count)\n\t\t\tshift = 3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twhile (i < IGB_RETA_SIZE) {\n\t\tu32 val = 0;\n\t\tint j;\n\n\t\tfor (j = 3; j >= 0; j--) {\n\t\t\tval <<= 8;\n\t\t\tval |= adapter->rss_indir_tbl[i + j];\n\t\t}\n\n\t\twr32(reg, val << shift);\n\t\treg += 4;\n\t\ti += 4;\n\t}\n}\n\nstatic int igb_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\tconst u8 *key, const u8 hfunc)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint i;\n\tu32 num_queues;\n\n\t \n\tif (key ||\n\t    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\tif (!indir)\n\t\treturn 0;\n\n\tnum_queues = adapter->rss_queues;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82576:\n\t\t \n\t\tif (adapter->vfs_allocated_count)\n\t\t\tnum_queues = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < IGB_RETA_SIZE; i++)\n\t\tif (indir[i] >= num_queues)\n\t\t\treturn -EINVAL;\n\n\n\tfor (i = 0; i < IGB_RETA_SIZE; i++)\n\t\tadapter->rss_indir_tbl[i] = indir[i];\n\n\tigb_write_rss_indir_tbl(adapter);\n\n\treturn 0;\n}\n\nstatic unsigned int igb_max_channels(struct igb_adapter *adapter)\n{\n\treturn igb_get_max_rss_queues(adapter);\n}\n\nstatic void igb_get_channels(struct net_device *netdev,\n\t\t\t     struct ethtool_channels *ch)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tch->max_combined = igb_max_channels(adapter);\n\n\t \n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\tch->max_other = NON_Q_VECTORS;\n\t\tch->other_count = NON_Q_VECTORS;\n\t}\n\n\tch->combined_count = adapter->rss_queues;\n}\n\nstatic int igb_set_channels(struct net_device *netdev,\n\t\t\t    struct ethtool_channels *ch)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tunsigned int count = ch->combined_count;\n\tunsigned int max_combined = 0;\n\n\t \n\tif (!count || ch->rx_count || ch->tx_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (ch->other_count != NON_Q_VECTORS)\n\t\treturn -EINVAL;\n\n\t \n\tmax_combined = igb_max_channels(adapter);\n\tif (count > max_combined)\n\t\treturn -EINVAL;\n\n\tif (count != adapter->rss_queues) {\n\t\tadapter->rss_queues = count;\n\t\tigb_set_flag_queue_pairs(adapter, max_combined);\n\n\t\t \n\t\treturn igb_reinit_queues(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 igb_get_priv_flags(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tu32 priv_flags = 0;\n\n\tif (adapter->flags & IGB_FLAG_RX_LEGACY)\n\t\tpriv_flags |= IGB_PRIV_FLAGS_LEGACY_RX;\n\n\treturn priv_flags;\n}\n\nstatic int igb_set_priv_flags(struct net_device *netdev, u32 priv_flags)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tunsigned int flags = adapter->flags;\n\n\tflags &= ~IGB_FLAG_RX_LEGACY;\n\tif (priv_flags & IGB_PRIV_FLAGS_LEGACY_RX)\n\t\tflags |= IGB_FLAG_RX_LEGACY;\n\n\tif (flags != adapter->flags) {\n\t\tadapter->flags = flags;\n\n\t\t \n\t\tif (netif_running(netdev))\n\t\t\tigb_reinit_locked(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops igb_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS,\n\t.get_drvinfo\t\t= igb_get_drvinfo,\n\t.get_regs_len\t\t= igb_get_regs_len,\n\t.get_regs\t\t= igb_get_regs,\n\t.get_wol\t\t= igb_get_wol,\n\t.set_wol\t\t= igb_set_wol,\n\t.get_msglevel\t\t= igb_get_msglevel,\n\t.set_msglevel\t\t= igb_set_msglevel,\n\t.nway_reset\t\t= igb_nway_reset,\n\t.get_link\t\t= igb_get_link,\n\t.get_eeprom_len\t\t= igb_get_eeprom_len,\n\t.get_eeprom\t\t= igb_get_eeprom,\n\t.set_eeprom\t\t= igb_set_eeprom,\n\t.get_ringparam\t\t= igb_get_ringparam,\n\t.set_ringparam\t\t= igb_set_ringparam,\n\t.get_pauseparam\t\t= igb_get_pauseparam,\n\t.set_pauseparam\t\t= igb_set_pauseparam,\n\t.self_test\t\t= igb_diag_test,\n\t.get_strings\t\t= igb_get_strings,\n\t.set_phys_id\t\t= igb_set_phys_id,\n\t.get_sset_count\t\t= igb_get_sset_count,\n\t.get_ethtool_stats\t= igb_get_ethtool_stats,\n\t.get_coalesce\t\t= igb_get_coalesce,\n\t.set_coalesce\t\t= igb_set_coalesce,\n\t.get_ts_info\t\t= igb_get_ts_info,\n\t.get_rxnfc\t\t= igb_get_rxnfc,\n\t.set_rxnfc\t\t= igb_set_rxnfc,\n\t.get_eee\t\t= igb_get_eee,\n\t.set_eee\t\t= igb_set_eee,\n\t.get_module_info\t= igb_get_module_info,\n\t.get_module_eeprom\t= igb_get_module_eeprom,\n\t.get_rxfh_indir_size\t= igb_get_rxfh_indir_size,\n\t.get_rxfh\t\t= igb_get_rxfh,\n\t.set_rxfh\t\t= igb_set_rxfh,\n\t.get_channels\t\t= igb_get_channels,\n\t.set_channels\t\t= igb_set_channels,\n\t.get_priv_flags\t\t= igb_get_priv_flags,\n\t.set_priv_flags\t\t= igb_set_priv_flags,\n\t.begin\t\t\t= igb_ethtool_begin,\n\t.complete\t\t= igb_ethtool_complete,\n\t.get_link_ksettings\t= igb_get_link_ksettings,\n\t.set_link_ksettings\t= igb_set_link_ksettings,\n};\n\nvoid igb_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &igb_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}