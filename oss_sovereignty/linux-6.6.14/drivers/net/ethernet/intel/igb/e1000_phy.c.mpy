{
  "module_name": "e1000_phy.c",
  "hash_id": "885686a459496e9c68913274ff2b1e51b977e1cb7bd4b8c25a9d18610f9a3741",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/e1000_phy.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/delay.h>\n\n#include \"e1000_mac.h\"\n#include \"e1000_phy.h\"\n\nstatic s32  igb_phy_setup_autoneg(struct e1000_hw *hw);\nstatic void igb_phy_force_speed_duplex_setup(struct e1000_hw *hw,\n\t\t\t\t\t     u16 *phy_ctrl);\nstatic s32  igb_wait_autoneg(struct e1000_hw *hw);\nstatic s32  igb_set_master_slave_mode(struct e1000_hw *hw);\n\n \nstatic const u16 e1000_m88_cable_length_table[] = {\n\t0, 50, 80, 110, 140, 140, E1000_CABLE_LENGTH_UNDEFINED };\n\nstatic const u16 e1000_igp_2_cable_length_table[] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 8, 11, 13, 16, 18, 21,\n\t0, 0, 0, 3, 6, 10, 13, 16, 19, 23, 26, 29, 32, 35, 38, 41,\n\t6, 10, 14, 18, 22, 26, 30, 33, 37, 41, 44, 48, 51, 54, 58, 61,\n\t21, 26, 31, 35, 40, 44, 49, 53, 57, 61, 65, 68, 72, 75, 79, 82,\n\t40, 45, 51, 56, 61, 66, 70, 75, 79, 83, 87, 91, 94, 98, 101, 104,\n\t60, 66, 72, 77, 82, 87, 92, 96, 100, 104, 108, 111, 114, 117, 119, 121,\n\t83, 89, 95, 100, 105, 109, 113, 116, 119, 122, 124,\n\t104, 109, 114, 118, 121, 124};\n\n \ns32 igb_check_reset_block(struct e1000_hw *hw)\n{\n\tu32 manc;\n\n\tmanc = rd32(E1000_MANC);\n\n\treturn (manc & E1000_MANC_BLK_PHY_RST_ON_IDE) ? E1000_BLK_PHY_RESET : 0;\n}\n\n \ns32 igb_get_phy_id(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu16 phy_id;\n\n\t \n\tif ((hw->mac.type == e1000_i210) || (hw->mac.type == e1000_i211))\n\t\tphy->ops.write_reg(hw, I347AT4_PAGE_SELECT, 0);\n\n\tret_val = phy->ops.read_reg(hw, PHY_ID1, &phy_id);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->id = (u32)(phy_id << 16);\n\tudelay(20);\n\tret_val = phy->ops.read_reg(hw, PHY_ID2, &phy_id);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->id |= (u32)(phy_id & PHY_REVISION_MASK);\n\tphy->revision = (u32)(phy_id & ~PHY_REVISION_MASK);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_phy_reset_dsp(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\tif (!(hw->phy.ops.write_reg))\n\t\tgoto out;\n\n\tret_val = hw->phy.ops.write_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xC1);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = hw->phy.ops.write_reg(hw, M88E1000_PHY_GEN_CONTROL, 0);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_read_phy_reg_mdic(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 i, mdic = 0;\n\ts32 ret_val = 0;\n\n\tif (offset > MAX_PHY_REG_ADDRESS) {\n\t\thw_dbg(\"PHY Address %d is out of range\\n\", offset);\n\t\tret_val = -E1000_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\t \n\tmdic = ((offset << E1000_MDIC_REG_SHIFT) |\n\t\t(phy->addr << E1000_MDIC_PHY_SHIFT) |\n\t\t(E1000_MDIC_OP_READ));\n\n\twr32(E1000_MDIC, mdic);\n\n\t \n\tfor (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {\n\t\tudelay(50);\n\t\tmdic = rd32(E1000_MDIC);\n\t\tif (mdic & E1000_MDIC_READY)\n\t\t\tbreak;\n\t}\n\tif (!(mdic & E1000_MDIC_READY)) {\n\t\thw_dbg(\"MDI Read did not complete\\n\");\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\tif (mdic & E1000_MDIC_ERROR) {\n\t\thw_dbg(\"MDI Error\\n\");\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\t*data = (u16) mdic;\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_write_phy_reg_mdic(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 i, mdic = 0;\n\ts32 ret_val = 0;\n\n\tif (offset > MAX_PHY_REG_ADDRESS) {\n\t\thw_dbg(\"PHY Address %d is out of range\\n\", offset);\n\t\tret_val = -E1000_ERR_PARAM;\n\t\tgoto out;\n\t}\n\n\t \n\tmdic = (((u32)data) |\n\t\t(offset << E1000_MDIC_REG_SHIFT) |\n\t\t(phy->addr << E1000_MDIC_PHY_SHIFT) |\n\t\t(E1000_MDIC_OP_WRITE));\n\n\twr32(E1000_MDIC, mdic);\n\n\t \n\tfor (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {\n\t\tudelay(50);\n\t\tmdic = rd32(E1000_MDIC);\n\t\tif (mdic & E1000_MDIC_READY)\n\t\t\tbreak;\n\t}\n\tif (!(mdic & E1000_MDIC_READY)) {\n\t\thw_dbg(\"MDI Write did not complete\\n\");\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\tif (mdic & E1000_MDIC_ERROR) {\n\t\thw_dbg(\"MDI Error\\n\");\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_read_phy_reg_i2c(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 i, i2ccmd = 0;\n\n\t \n\ti2ccmd = ((offset << E1000_I2CCMD_REG_ADDR_SHIFT) |\n\t\t  (phy->addr << E1000_I2CCMD_PHY_ADDR_SHIFT) |\n\t\t  (E1000_I2CCMD_OPCODE_READ));\n\n\twr32(E1000_I2CCMD, i2ccmd);\n\n\t \n\tfor (i = 0; i < E1000_I2CCMD_PHY_TIMEOUT; i++) {\n\t\tudelay(50);\n\t\ti2ccmd = rd32(E1000_I2CCMD);\n\t\tif (i2ccmd & E1000_I2CCMD_READY)\n\t\t\tbreak;\n\t}\n\tif (!(i2ccmd & E1000_I2CCMD_READY)) {\n\t\thw_dbg(\"I2CCMD Read did not complete\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\tif (i2ccmd & E1000_I2CCMD_ERROR) {\n\t\thw_dbg(\"I2CCMD Error bit set\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\t \n\t*data = ((i2ccmd >> 8) & 0x00FF) | ((i2ccmd << 8) & 0xFF00);\n\n\treturn 0;\n}\n\n \ns32 igb_write_phy_reg_i2c(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu32 i, i2ccmd = 0;\n\tu16 phy_data_swapped;\n\n\t \n\tif ((hw->phy.addr == 0) || (hw->phy.addr > 7)) {\n\t\thw_dbg(\"PHY I2C Address %d is out of range.\\n\",\n\t\t\t  hw->phy.addr);\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\t \n\tphy_data_swapped = ((data >> 8) & 0x00FF) | ((data << 8) & 0xFF00);\n\n\t \n\ti2ccmd = ((offset << E1000_I2CCMD_REG_ADDR_SHIFT) |\n\t\t  (phy->addr << E1000_I2CCMD_PHY_ADDR_SHIFT) |\n\t\t  E1000_I2CCMD_OPCODE_WRITE |\n\t\t  phy_data_swapped);\n\n\twr32(E1000_I2CCMD, i2ccmd);\n\n\t \n\tfor (i = 0; i < E1000_I2CCMD_PHY_TIMEOUT; i++) {\n\t\tudelay(50);\n\t\ti2ccmd = rd32(E1000_I2CCMD);\n\t\tif (i2ccmd & E1000_I2CCMD_READY)\n\t\t\tbreak;\n\t}\n\tif (!(i2ccmd & E1000_I2CCMD_READY)) {\n\t\thw_dbg(\"I2CCMD Write did not complete\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\tif (i2ccmd & E1000_I2CCMD_ERROR) {\n\t\thw_dbg(\"I2CCMD Error bit set\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\treturn 0;\n}\n\n \ns32 igb_read_sfp_data_byte(struct e1000_hw *hw, u16 offset, u8 *data)\n{\n\tu32 i = 0;\n\tu32 i2ccmd = 0;\n\tu32 data_local = 0;\n\n\tif (offset > E1000_I2CCMD_SFP_DIAG_ADDR(255)) {\n\t\thw_dbg(\"I2CCMD command address exceeds upper limit\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\n\t \n\ti2ccmd = ((offset << E1000_I2CCMD_REG_ADDR_SHIFT) |\n\t\t  E1000_I2CCMD_OPCODE_READ);\n\n\twr32(E1000_I2CCMD, i2ccmd);\n\n\t \n\tfor (i = 0; i < E1000_I2CCMD_PHY_TIMEOUT; i++) {\n\t\tudelay(50);\n\t\tdata_local = rd32(E1000_I2CCMD);\n\t\tif (data_local & E1000_I2CCMD_READY)\n\t\t\tbreak;\n\t}\n\tif (!(data_local & E1000_I2CCMD_READY)) {\n\t\thw_dbg(\"I2CCMD Read did not complete\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\tif (data_local & E1000_I2CCMD_ERROR) {\n\t\thw_dbg(\"I2CCMD Error bit set\\n\");\n\t\treturn -E1000_ERR_PHY;\n\t}\n\t*data = (u8) data_local & 0xFF;\n\n\treturn 0;\n}\n\n \ns32 igb_read_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\ts32 ret_val = 0;\n\n\tif (!(hw->phy.ops.acquire))\n\t\tgoto out;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\tret_val = igb_write_phy_reg_mdic(hw,\n\t\t\t\t\t\t IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t (u16)offset);\n\t\tif (ret_val) {\n\t\t\thw->phy.ops.release(hw);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret_val = igb_read_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\tdata);\n\n\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_write_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\ts32 ret_val = 0;\n\n\tif (!(hw->phy.ops.acquire))\n\t\tgoto out;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\tret_val = igb_write_phy_reg_mdic(hw,\n\t\t\t\t\t\t IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t (u16)offset);\n\t\tif (ret_val) {\n\t\t\thw->phy.ops.release(hw);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret_val = igb_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t\t\t\t\t data);\n\n\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_copper_link_setup_82580(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (phy->reset_disable) {\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\tif (phy->type == e1000_phy_82580) {\n\t\tret_val = hw->phy.ops.reset(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error resetting the PHY.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret_val = phy->ops.read_reg(hw, I82580_CFG_REG, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_data |= I82580_CFG_ASSERT_CRS_ON_TX;\n\n\t \n\tphy_data |= I82580_CFG_ENABLE_DOWNSHIFT;\n\n\tret_val = phy->ops.write_reg(hw, I82580_CFG_REG, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.read_reg(hw, I82580_PHY_CTRL_2, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\tphy_data &= ~I82580_PHY_CTRL2_MDIX_CFG_MASK;\n\t \n\tswitch (hw->phy.mdix) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\tphy_data |= I82580_PHY_CTRL2_MANUAL_MDIX;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tphy_data |= I82580_PHY_CTRL2_AUTO_MDI_MDIX;\n\t\tbreak;\n\t}\n\tret_val = hw->phy.ops.write_reg(hw, I82580_PHY_CTRL_2, phy_data);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_copper_link_setup_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (phy->reset_disable) {\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\n\n\t \n\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\n\tswitch (phy->mdix) {\n\tcase 1:\n\t\tphy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;\n\t\tbreak;\n\tcase 2:\n\t\tphy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;\n\t\tbreak;\n\tcase 3:\n\t\tphy_data |= M88E1000_PSCR_AUTO_X_1000T;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tphy_data |= M88E1000_PSCR_AUTO_X_MODE;\n\t\tbreak;\n\t}\n\n\t \n\tphy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;\n\tif (phy->disable_polarity_correction == 1)\n\t\tphy_data |= M88E1000_PSCR_POLARITY_REVERSAL;\n\n\tret_val = phy->ops.write_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (phy->revision < E1000_REVISION_4) {\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\n\t\t\t\t\t    &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy_data |= M88E1000_EPSCR_TX_CLK_25;\n\n\t\tif ((phy->revision == E1000_REVISION_2) &&\n\t\t    (phy->id == M88E1111_I_PHY_ID)) {\n\t\t\t \n\t\t\tphy_data &= ~M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK;\n\t\t\tphy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;\n\t\t} else {\n\t\t\t \n\t\t\tphy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |\n\t\t\t\t      M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);\n\t\t\tphy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |\n\t\t\t\t     M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);\n\t\t}\n\t\tret_val = phy->ops.write_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\n\t\t\t\t\t     phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret_val = igb_phy_sw_reset(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error committing the PHY changes\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_copper_link_setup_m88_gen2(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (phy->reset_disable)\n\t\treturn 0;\n\n\t \n\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\n\tswitch (phy->mdix) {\n\tcase 1:\n\t\tphy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;\n\t\tbreak;\n\tcase 2:\n\t\tphy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tif (phy->id != M88E1112_E_PHY_ID) {\n\t\t\tphy_data |= M88E1000_PSCR_AUTO_X_1000T;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase 0:\n\tdefault:\n\t\tphy_data |= M88E1000_PSCR_AUTO_X_MODE;\n\t\tbreak;\n\t}\n\n\t \n\tphy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;\n\tif (phy->disable_polarity_correction == 1)\n\t\tphy_data |= M88E1000_PSCR_POLARITY_REVERSAL;\n\n\t \n\tif (phy->id == M88E1543_E_PHY_ID) {\n\t\tphy_data &= ~I347AT4_PSCR_DOWNSHIFT_ENABLE;\n\t\tret_val =\n\t\t    phy->ops.write_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = igb_phy_sw_reset(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error committing the PHY changes\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\tphy_data &= ~I347AT4_PSCR_DOWNSHIFT_MASK;\n\tphy_data |= I347AT4_PSCR_DOWNSHIFT_6X;\n\tphy_data |= I347AT4_PSCR_DOWNSHIFT_ENABLE;\n\n\tret_val = phy->ops.write_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = igb_phy_sw_reset(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error committing the PHY changes\\n\");\n\t\treturn ret_val;\n\t}\n\tret_val = igb_set_master_slave_mode(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn 0;\n}\n\n \ns32 igb_copper_link_setup_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tif (phy->reset_disable) {\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\tret_val = phy->ops.reset(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error resetting the PHY.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tmsleep(100);\n\n\t \n\tif (phy->type == e1000_phy_igp) {\n\t\t \n\t\tif (phy->ops.set_d3_lplu_state)\n\t\t\tret_val = phy->ops.set_d3_lplu_state(hw, false);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error Disabling LPLU D3\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret_val = phy->ops.set_d0_lplu_state(hw, false);\n\tif (ret_val) {\n\t\thw_dbg(\"Error Disabling LPLU D0\\n\");\n\t\tgoto out;\n\t}\n\t \n\tret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_CTRL, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tdata &= ~IGP01E1000_PSCR_AUTO_MDIX;\n\n\tswitch (phy->mdix) {\n\tcase 1:\n\t\tdata &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\t\tbreak;\n\tcase 2:\n\t\tdata |= IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tdata |= IGP01E1000_PSCR_AUTO_MDIX;\n\t\tbreak;\n\t}\n\tret_val = phy->ops.write_reg(hw, IGP01E1000_PHY_PORT_CTRL, data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tif (hw->mac.autoneg) {\n\t\t \n\t\tif (phy->autoneg_advertised == ADVERTISE_1000_FULL) {\n\t\t\t \n\t\t\tret_val = phy->ops.read_reg(hw,\n\t\t\t\t\t\t    IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t    &data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\t\t     IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t     data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tret_val = phy->ops.read_reg(hw, PHY_1000T_CTRL, &data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tdata &= ~CR_1000T_MS_ENABLE;\n\t\t\tret_val = phy->ops.write_reg(hw, PHY_1000T_CTRL, data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tret_val = phy->ops.read_reg(hw, PHY_1000T_CTRL, &data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tphy->original_ms_type = (data & CR_1000T_MS_ENABLE) ?\n\t\t\t((data & CR_1000T_MS_VALUE) ?\n\t\t\te1000_ms_force_master :\n\t\t\te1000_ms_force_slave) :\n\t\t\te1000_ms_auto;\n\n\t\tswitch (phy->ms_type) {\n\t\tcase e1000_ms_force_master:\n\t\t\tdata |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);\n\t\t\tbreak;\n\t\tcase e1000_ms_force_slave:\n\t\t\tdata |= CR_1000T_MS_ENABLE;\n\t\t\tdata &= ~(CR_1000T_MS_VALUE);\n\t\t\tbreak;\n\t\tcase e1000_ms_auto:\n\t\t\tdata &= ~CR_1000T_MS_ENABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tret_val = phy->ops.write_reg(hw, PHY_1000T_CTRL, data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_copper_link_autoneg(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_ctrl;\n\n\t \n\tphy->autoneg_advertised &= phy->autoneg_mask;\n\n\t \n\tif (phy->autoneg_advertised == 0)\n\t\tphy->autoneg_advertised = phy->autoneg_mask;\n\n\thw_dbg(\"Reconfiguring auto-neg advertisement params\\n\");\n\tret_val = igb_phy_setup_autoneg(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error Setting up Auto-Negotiation\\n\");\n\t\tgoto out;\n\t}\n\thw_dbg(\"Restarting Auto-Neg\\n\");\n\n\t \n\tret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_ctrl |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);\n\tret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tif (phy->autoneg_wait_to_complete) {\n\t\tret_val = igb_wait_autoneg(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error while waiting for autoneg to complete\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thw->mac.get_link_status = true;\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_phy_setup_autoneg(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 mii_autoneg_adv_reg;\n\tu16 mii_1000t_ctrl_reg = 0;\n\n\tphy->autoneg_advertised &= phy->autoneg_mask;\n\n\t \n\tret_val = phy->ops.read_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (phy->autoneg_mask & ADVERTISE_1000_FULL) {\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, PHY_1000T_CTRL,\n\t\t\t\t\t    &mii_1000t_ctrl_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\t \n\n\t \n\tmii_autoneg_adv_reg &= ~(NWAY_AR_100TX_FD_CAPS |\n\t\t\t\t NWAY_AR_100TX_HD_CAPS |\n\t\t\t\t NWAY_AR_10T_FD_CAPS   |\n\t\t\t\t NWAY_AR_10T_HD_CAPS);\n\tmii_1000t_ctrl_reg &= ~(CR_1000T_HD_CAPS | CR_1000T_FD_CAPS);\n\n\thw_dbg(\"autoneg_advertised %x\\n\", phy->autoneg_advertised);\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_10_HALF) {\n\t\thw_dbg(\"Advertise 10mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_10_FULL) {\n\t\thw_dbg(\"Advertise 10mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_100_HALF) {\n\t\thw_dbg(\"Advertise 100mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_100_FULL) {\n\t\thw_dbg(\"Advertise 100mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;\n\t}\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_1000_HALF)\n\t\thw_dbg(\"Advertise 1000mb Half duplex request denied!\\n\");\n\n\t \n\tif (phy->autoneg_advertised & ADVERTISE_1000_FULL) {\n\t\thw_dbg(\"Advertise 1000mb Full duplex\\n\");\n\t\tmii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;\n\t}\n\n\t \n\tswitch (hw->fc.current_mode) {\n\tcase e1000_fc_none:\n\t\t \n\t\tmii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tcase e1000_fc_rx_pause:\n\t\t \n\t\tmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tcase e1000_fc_tx_pause:\n\t\t \n\t\tmii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;\n\t\tmii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;\n\t\tbreak;\n\tcase e1000_fc_full:\n\t\t \n\t\tmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(\"Flow control param set incorrectly\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tret_val = phy->ops.write_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\tgoto out;\n\n\thw_dbg(\"Auto-Neg Advertising %x\\n\", mii_autoneg_adv_reg);\n\n\tif (phy->autoneg_mask & ADVERTISE_1000_FULL) {\n\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\t     PHY_1000T_CTRL,\n\t\t\t\t\t     mii_1000t_ctrl_reg);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_setup_copper_link(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tbool link;\n\n\tif (hw->mac.autoneg) {\n\t\t \n\t\tret_val = igb_copper_link_autoneg(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\thw_dbg(\"Forcing Speed and Duplex\\n\");\n\t\tret_val = hw->phy.ops.force_speed_duplex(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error Forcing Speed and Duplex\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret_val = igb_phy_has_link(hw, COPPER_LINK_UP_LIMIT, 10, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (link) {\n\t\thw_dbg(\"Valid link established!!!\\n\");\n\t\tigb_config_collision_dist(hw);\n\t\tret_val = igb_config_fc_after_link_up(hw);\n\t} else {\n\t\thw_dbg(\"Unable to establish link!!!\\n\");\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_phy_force_speed_duplex_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tigb_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\tret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;\n\tphy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\n\tret_val = phy->ops.write_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\thw_dbg(\"IGP PSCR: %X\\n\", phy_data);\n\n\tudelay(1);\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\thw_dbg(\"Waiting for forced speed/duplex link on IGP phy.\\n\");\n\n\t\tret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT, 10000, &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (!link)\n\t\t\thw_dbg(\"Link taking longer than expected.\\n\");\n\n\t\t \n\t\tret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT, 10000, &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_phy_force_speed_duplex_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\t \n\tif (phy->type != e1000_phy_i210) {\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_CTRL,\n\t\t\t\t\t    &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\t\tret_val = phy->ops.write_reg(hw, M88E1000_PHY_SPEC_CTRL,\n\t\t\t\t\t     phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\thw_dbg(\"M88E1000 PSCR: %X\\n\", phy_data);\n\t}\n\n\tret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tigb_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\tret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = igb_phy_sw_reset(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\thw_dbg(\"Waiting for forced speed/duplex link on M88 phy.\\n\");\n\n\t\tret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT, 100000, &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (!link) {\n\t\t\tbool reset_dsp = true;\n\n\t\t\tswitch (hw->phy.id) {\n\t\t\tcase I347AT4_E_PHY_ID:\n\t\t\tcase M88E1112_E_PHY_ID:\n\t\t\tcase M88E1543_E_PHY_ID:\n\t\t\tcase M88E1512_E_PHY_ID:\n\t\t\tcase I210_I_PHY_ID:\n\t\t\t\treset_dsp = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (hw->phy.type != e1000_phy_m88)\n\t\t\t\t\treset_dsp = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!reset_dsp) {\n\t\t\t\thw_dbg(\"Link taking longer than expected.\\n\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\t\tM88E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t0x001d);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tgoto out;\n\t\t\t\tret_val = igb_phy_reset_dsp(hw);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT,\n\t\t\t\t\t   100000, &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tif (hw->phy.type != e1000_phy_m88 ||\n\t    hw->phy.id == I347AT4_E_PHY_ID ||\n\t    hw->phy.id == M88E1112_E_PHY_ID ||\n\t    hw->phy.id == M88E1543_E_PHY_ID ||\n\t    hw->phy.id == M88E1512_E_PHY_ID ||\n\t    hw->phy.id == I210_I_PHY_ID)\n\t\tgoto out;\n\n\tret_val = phy->ops.read_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tphy_data |= M88E1000_EPSCR_TX_CLK_25;\n\tret_val = phy->ops.write_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\n\tret_val = phy->ops.write_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic void igb_phy_force_speed_duplex_setup(struct e1000_hw *hw,\n\t\t\t\t\t     u16 *phy_ctrl)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 ctrl;\n\n\t \n\thw->fc.current_mode = e1000_fc_none;\n\n\t \n\tctrl = rd32(E1000_CTRL);\n\tctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tctrl &= ~E1000_CTRL_SPD_SEL;\n\n\t \n\tctrl &= ~E1000_CTRL_ASDE;\n\n\t \n\t*phy_ctrl &= ~MII_CR_AUTO_NEG_EN;\n\n\t \n\tif (mac->forced_speed_duplex & E1000_ALL_HALF_DUPLEX) {\n\t\tctrl &= ~E1000_CTRL_FD;\n\t\t*phy_ctrl &= ~MII_CR_FULL_DUPLEX;\n\t\thw_dbg(\"Half Duplex\\n\");\n\t} else {\n\t\tctrl |= E1000_CTRL_FD;\n\t\t*phy_ctrl |= MII_CR_FULL_DUPLEX;\n\t\thw_dbg(\"Full Duplex\\n\");\n\t}\n\n\t \n\tif (mac->forced_speed_duplex & E1000_ALL_100_SPEED) {\n\t\tctrl |= E1000_CTRL_SPD_100;\n\t\t*phy_ctrl |= MII_CR_SPEED_100;\n\t\t*phy_ctrl &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);\n\t\thw_dbg(\"Forcing 100mb\\n\");\n\t} else {\n\t\tctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\n\t\t*phy_ctrl |= MII_CR_SPEED_10;\n\t\t*phy_ctrl &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);\n\t\thw_dbg(\"Forcing 10mb\\n\");\n\t}\n\n\tigb_config_collision_dist(hw);\n\n\twr32(E1000_CTRL, ctrl);\n}\n\n \ns32 igb_set_d3_lplu_state(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu16 data;\n\n\tif (!(hw->phy.ops.read_reg))\n\t\tgoto out;\n\n\tret_val = phy->ops.read_reg(hw, IGP02E1000_PHY_POWER_MGMT, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!active) {\n\t\tdata &= ~IGP02E1000_PM_D3_LPLU;\n\t\tret_val = phy->ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,\n\t\t\t\t\t     data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on) {\n\t\t\tret_val = phy->ops.read_reg(hw,\n\t\t\t\t\t\t    IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t    &data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tdata |= IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\t\t     IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t     data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t} else if (phy->smart_speed == e1000_smart_speed_off) {\n\t\t\tret_val = phy->ops.read_reg(hw,\n\t\t\t\t\t\t     IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t     &data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\t\t     IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t     data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if ((phy->autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_NOT_GIG) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_10_SPEED)) {\n\t\tdata |= IGP02E1000_PM_D3_LPLU;\n\t\tret_val = phy->ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,\n\t\t\t\t\t      data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t    &data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\tret_val = phy->ops.write_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t     data);\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_check_downshift(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, offset, mask;\n\n\tswitch (phy->type) {\n\tcase e1000_phy_i210:\n\tcase e1000_phy_m88:\n\tcase e1000_phy_gg82563:\n\t\toffset\t= M88E1000_PHY_SPEC_STATUS;\n\t\tmask\t= M88E1000_PSSR_DOWNSHIFT;\n\t\tbreak;\n\tcase e1000_phy_igp_2:\n\tcase e1000_phy_igp:\n\tcase e1000_phy_igp_3:\n\t\toffset\t= IGP01E1000_PHY_LINK_HEALTH;\n\t\tmask\t= IGP01E1000_PLHR_SS_DOWNGRADE;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tphy->speed_downgraded = false;\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\tret_val = phy->ops.read_reg(hw, offset, &phy_data);\n\n\tif (!ret_val)\n\t\tphy->speed_downgraded = (phy_data & mask) ? true : false;\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_check_polarity_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_STATUS, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = (data & M88E1000_PSSR_REV_POLARITY)\n\t\t\t\t      ? e1000_rev_polarity_reversed\n\t\t\t\t      : e1000_rev_polarity_normal;\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_check_polarity_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data, offset, mask;\n\n\t \n\tret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_STATUS, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif ((data & IGP01E1000_PSSR_SPEED_MASK) ==\n\t    IGP01E1000_PSSR_SPEED_1000MBPS) {\n\t\toffset\t= IGP01E1000_PHY_PCS_INIT_REG;\n\t\tmask\t= IGP01E1000_PHY_POLARITY_MASK;\n\t} else {\n\t\t \n\t\toffset\t= IGP01E1000_PHY_PORT_STATUS;\n\t\tmask\t= IGP01E1000_PSSR_POLARITY_REVERSED;\n\t}\n\n\tret_val = phy->ops.read_reg(hw, offset, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = (data & mask)\n\t\t\t\t      ? e1000_rev_polarity_reversed\n\t\t\t\t      : e1000_rev_polarity_normal;\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_wait_autoneg(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 i, phy_status;\n\n\t \n\tfor (i = PHY_AUTO_NEG_LIMIT; i > 0; i--) {\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & MII_SR_AUTONEG_COMPLETE)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\t \n\treturn ret_val;\n}\n\n \ns32 igb_phy_has_link(struct e1000_hw *hw, u32 iterations,\n\t\t     u32 usec_interval, bool *success)\n{\n\ts32 ret_val = 0;\n\tu16 i, phy_status;\n\n\tfor (i = 0; i < iterations; i++) {\n\t\t \n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val && usec_interval > 0) {\n\t\t\t \n\t\t\tif (usec_interval >= 1000)\n\t\t\t\tmdelay(usec_interval/1000);\n\t\t\telse\n\t\t\t\tudelay(usec_interval);\n\t\t}\n\t\tret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & MII_SR_LINK_STATUS)\n\t\t\tbreak;\n\t\tif (usec_interval >= 1000)\n\t\t\tmdelay(usec_interval/1000);\n\t\telse\n\t\t\tudelay(usec_interval);\n\t}\n\n\t*success = (i < iterations) ? true : false;\n\n\treturn ret_val;\n}\n\n \ns32 igb_get_cable_length_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, index;\n\n\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tindex = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>\n\t\tM88E1000_PSSR_CABLE_LENGTH_SHIFT;\n\tif (index >= ARRAY_SIZE(e1000_m88_cable_length_table) - 1) {\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\n\tphy->min_cable_length = e1000_m88_cable_length_table[index];\n\tphy->max_cable_length = e1000_m88_cable_length_table[index + 1];\n\n\tphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\n\nout:\n\treturn ret_val;\n}\n\ns32 igb_get_cable_length_m88_gen2(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, phy_data2, index, default_page, is_cm;\n\tint len_tot = 0;\n\tu16 len_min;\n\tu16 len_max;\n\n\tswitch (hw->phy.id) {\n\tcase M88E1543_E_PHY_ID:\n\tcase M88E1512_E_PHY_ID:\n\tcase I347AT4_E_PHY_ID:\n\tcase I210_I_PHY_ID:\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, I347AT4_PAGE_SELECT,\n\t\t\t\t\t    &default_page);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tret_val = phy->ops.write_reg(hw, I347AT4_PAGE_SELECT, 0x07);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, I347AT4_PCDC, &phy_data2);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tis_cm = !(phy_data2 & I347AT4_PCDC_CABLE_LENGTH_UNIT);\n\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, I347AT4_PCDL0, &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->pair_length[0] = phy_data / (is_cm ? 100 : 1);\n\t\tlen_tot = phy->pair_length[0];\n\t\tlen_min = phy->pair_length[0];\n\t\tlen_max = phy->pair_length[0];\n\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, I347AT4_PCDL1, &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->pair_length[1] = phy_data / (is_cm ? 100 : 1);\n\t\tlen_tot += phy->pair_length[1];\n\t\tlen_min = min(len_min, phy->pair_length[1]);\n\t\tlen_max = max(len_max, phy->pair_length[1]);\n\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, I347AT4_PCDL2, &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->pair_length[2] = phy_data / (is_cm ? 100 : 1);\n\t\tlen_tot += phy->pair_length[2];\n\t\tlen_min = min(len_min, phy->pair_length[2]);\n\t\tlen_max = max(len_max, phy->pair_length[2]);\n\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, I347AT4_PCDL3, &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->pair_length[3] = phy_data / (is_cm ? 100 : 1);\n\t\tlen_tot += phy->pair_length[3];\n\t\tlen_min = min(len_min, phy->pair_length[3]);\n\t\tlen_max = max(len_max, phy->pair_length[3]);\n\n\t\t \n\t\tphy->min_cable_length = len_min;\n\t\tphy->max_cable_length = len_max;\n\t\tphy->cable_length = len_tot / 4;\n\n\t\t \n\t\tret_val = phy->ops.write_reg(hw, I347AT4_PAGE_SELECT,\n\t\t\t\t\t     default_page);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase M88E1112_E_PHY_ID:\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, I347AT4_PAGE_SELECT,\n\t\t\t\t\t    &default_page);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tret_val = phy->ops.write_reg(hw, I347AT4_PAGE_SELECT, 0x05);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tret_val = phy->ops.read_reg(hw, M88E1112_VCT_DSP_DISTANCE,\n\t\t\t\t\t    &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tindex = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>\n\t\t\tM88E1000_PSSR_CABLE_LENGTH_SHIFT;\n\t\tif (index >= ARRAY_SIZE(e1000_m88_cable_length_table) - 1) {\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tphy->min_cable_length = e1000_m88_cable_length_table[index];\n\t\tphy->max_cable_length = e1000_m88_cable_length_table[index + 1];\n\n\t\tphy->cable_length = (phy->min_cable_length +\n\t\t\t\t     phy->max_cable_length) / 2;\n\n\t\t \n\t\tret_val = phy->ops.write_reg(hw, I347AT4_PAGE_SELECT,\n\t\t\t\t\t     default_page);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tbreak;\n\tdefault:\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_get_cable_length_igp_2(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu16 phy_data, i, agc_value = 0;\n\tu16 cur_agc_index, max_agc_index = 0;\n\tu16 min_agc_index = ARRAY_SIZE(e1000_igp_2_cable_length_table) - 1;\n\tstatic const u16 agc_reg_array[IGP02E1000_PHY_CHANNEL_NUM] = {\n\t\tIGP02E1000_PHY_AGC_A,\n\t\tIGP02E1000_PHY_AGC_B,\n\t\tIGP02E1000_PHY_AGC_C,\n\t\tIGP02E1000_PHY_AGC_D\n\t};\n\n\t \n\tfor (i = 0; i < IGP02E1000_PHY_CHANNEL_NUM; i++) {\n\t\tret_val = phy->ops.read_reg(hw, agc_reg_array[i], &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tcur_agc_index = (phy_data >> IGP02E1000_AGC_LENGTH_SHIFT) &\n\t\t\t\tIGP02E1000_AGC_LENGTH_MASK;\n\n\t\t \n\t\tif ((cur_agc_index >= ARRAY_SIZE(e1000_igp_2_cable_length_table)) ||\n\t\t    (cur_agc_index == 0)) {\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (e1000_igp_2_cable_length_table[min_agc_index] >\n\t\t    e1000_igp_2_cable_length_table[cur_agc_index])\n\t\t\tmin_agc_index = cur_agc_index;\n\t\tif (e1000_igp_2_cable_length_table[max_agc_index] <\n\t\t    e1000_igp_2_cable_length_table[cur_agc_index])\n\t\t\tmax_agc_index = cur_agc_index;\n\n\t\tagc_value += e1000_igp_2_cable_length_table[cur_agc_index];\n\t}\n\n\tagc_value -= (e1000_igp_2_cable_length_table[min_agc_index] +\n\t\t      e1000_igp_2_cable_length_table[max_agc_index]);\n\tagc_value /= (IGP02E1000_PHY_CHANNEL_NUM - 2);\n\n\t \n\tphy->min_cable_length = ((agc_value - IGP02E1000_AGC_RANGE) > 0) ?\n\t\t\t\t (agc_value - IGP02E1000_AGC_RANGE) : 0;\n\tphy->max_cable_length = agc_value + IGP02E1000_AGC_RANGE;\n\n\tphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_get_phy_info_m88(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32  ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tif (phy->media_type != e1000_media_type_copper) {\n\t\thw_dbg(\"Phy info is only valid for copper media\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tret_val = igb_phy_has_link(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!link) {\n\t\thw_dbg(\"Phy info is only valid if link is up\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->polarity_correction = (phy_data & M88E1000_PSCR_POLARITY_REVERSAL)\n\t\t\t\t   ? true : false;\n\n\tret_val = igb_check_polarity_m88(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.read_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->is_mdix = (phy_data & M88E1000_PSSR_MDIX) ? true : false;\n\n\tif ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {\n\t\tret_val = phy->ops.get_cable_length(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tret_val = phy->ops.read_reg(hw, PHY_1000T_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS)\n\t\t\t\t? e1000_1000t_rx_status_ok\n\t\t\t\t: e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS)\n\t\t\t\t ? e1000_1000t_rx_status_ok\n\t\t\t\t : e1000_1000t_rx_status_not_ok;\n\t} else {\n\t\t \n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_get_phy_info_igp(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = igb_phy_has_link(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!link) {\n\t\thw_dbg(\"Phy info is only valid if link is up\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tphy->polarity_correction = true;\n\n\tret_val = igb_check_polarity_igp(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_STATUS, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->is_mdix = (data & IGP01E1000_PSSR_MDIX) ? true : false;\n\n\tif ((data & IGP01E1000_PSSR_SPEED_MASK) ==\n\t    IGP01E1000_PSSR_SPEED_1000MBPS) {\n\t\tret_val = phy->ops.get_cable_length(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tret_val = phy->ops.read_reg(hw, PHY_1000T_STATUS, &data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->local_rx = (data & SR_1000T_LOCAL_RX_STATUS)\n\t\t\t\t? e1000_1000t_rx_status_ok\n\t\t\t\t: e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (data & SR_1000T_REMOTE_RX_STATUS)\n\t\t\t\t ? e1000_1000t_rx_status_ok\n\t\t\t\t : e1000_1000t_rx_status_not_ok;\n\t} else {\n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_phy_sw_reset(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 phy_ctrl;\n\n\tif (!(hw->phy.ops.read_reg))\n\t\tgoto out;\n\n\tret_val = hw->phy.ops.read_reg(hw, PHY_CONTROL, &phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_ctrl |= MII_CR_RESET;\n\tret_val = hw->phy.ops.write_reg(hw, PHY_CONTROL, phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\tudelay(1);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_phy_hw_reset(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32  ret_val;\n\tu32 ctrl;\n\n\tret_val = igb_check_reset_block(hw);\n\tif (ret_val) {\n\t\tret_val = 0;\n\t\tgoto out;\n\t}\n\n\tret_val = phy->ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tctrl = rd32(E1000_CTRL);\n\twr32(E1000_CTRL, ctrl | E1000_CTRL_PHY_RST);\n\twrfl();\n\n\tudelay(phy->reset_delay_us);\n\n\twr32(E1000_CTRL, ctrl);\n\twrfl();\n\n\tudelay(150);\n\n\tphy->ops.release(hw);\n\n\tret_val = phy->ops.get_cfg_done(hw);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_phy_init_script_igp3(struct e1000_hw *hw)\n{\n\thw_dbg(\"Running IGP 3 PHY init script\\n\");\n\n\t \n\t \n\thw->phy.ops.write_reg(hw, 0x2F5B, 0x9018);\n\t \n\thw->phy.ops.write_reg(hw, 0x2F52, 0x0000);\n\t \n\thw->phy.ops.write_reg(hw, 0x2FB1, 0x8B24);\n\t \n\thw->phy.ops.write_reg(hw, 0x2FB2, 0xF8F0);\n\t \n\thw->phy.ops.write_reg(hw, 0x2010, 0x10B0);\n\t \n\thw->phy.ops.write_reg(hw, 0x2011, 0x0000);\n\t \n\thw->phy.ops.write_reg(hw, 0x20DD, 0x249A);\n\t \n\thw->phy.ops.write_reg(hw, 0x20DE, 0x00D3);\n\t \n\thw->phy.ops.write_reg(hw, 0x28B4, 0x04CE);\n\t \n\thw->phy.ops.write_reg(hw, 0x2F70, 0x29E4);\n\t \n\thw->phy.ops.write_reg(hw, 0x0000, 0x0140);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F30, 0x1606);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F31, 0xB814);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F35, 0x002A);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F3E, 0x0067);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F54, 0x0065);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F55, 0x002A);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F56, 0x002A);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F72, 0x3FB0);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F76, 0xC0FF);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F77, 0x1DEC);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F78, 0xF9EF);\n\t \n\thw->phy.ops.write_reg(hw, 0x1F79, 0x0210);\n\t \n\thw->phy.ops.write_reg(hw, 0x1895, 0x0003);\n\t \n\thw->phy.ops.write_reg(hw, 0x1796, 0x0008);\n\t \n\thw->phy.ops.write_reg(hw, 0x1798, 0xD008);\n\t \n\thw->phy.ops.write_reg(hw, 0x1898, 0xD918);\n\t \n\thw->phy.ops.write_reg(hw, 0x187A, 0x0800);\n\t \n\thw->phy.ops.write_reg(hw, 0x0019, 0x008D);\n\t \n\thw->phy.ops.write_reg(hw, 0x001B, 0x2080);\n\t \n\thw->phy.ops.write_reg(hw, 0x0014, 0x0045);\n\t \n\thw->phy.ops.write_reg(hw, 0x0000, 0x1340);\n\n\treturn 0;\n}\n\n \ns32 igb_initialize_M88E1512_phy(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0x00FF);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0x214B);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x2144);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0x0C28);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x2146);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0xB233);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x214D);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0xCC0C);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x2159);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0x00FB);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_3, 0x000D);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0x12);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_MODE, 0x8001);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_phy_sw_reset(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error committing the PHY changes\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tusleep_range(1000, 2000);\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_initialize_M88E1543_phy(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0x00FF);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0x214B);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x2144);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0x0C28);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x2146);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0xB233);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x214D);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_2, 0xDC0C);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_1, 0x2159);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0x00FB);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_CFG_REG_3, 0x0C0D);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0x12);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1512_MODE, 0x8001);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0x1);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_FIBER_CTRL, 0x9140);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_phy_sw_reset(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error committing the PHY changes\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tusleep_range(1000, 2000);\nout:\n\treturn ret_val;\n}\n\n \nvoid igb_power_up_phy_copper(struct e1000_hw *hw)\n{\n\tu16 mii_reg = 0;\n\n\t \n\thw->phy.ops.read_reg(hw, PHY_CONTROL, &mii_reg);\n\tmii_reg &= ~MII_CR_POWER_DOWN;\n\thw->phy.ops.write_reg(hw, PHY_CONTROL, mii_reg);\n}\n\n \nvoid igb_power_down_phy_copper(struct e1000_hw *hw)\n{\n\tu16 mii_reg = 0;\n\n\t \n\thw->phy.ops.read_reg(hw, PHY_CONTROL, &mii_reg);\n\tmii_reg |= MII_CR_POWER_DOWN;\n\thw->phy.ops.write_reg(hw, PHY_CONTROL, mii_reg);\n\tusleep_range(1000, 2000);\n}\n\n \nstatic s32 igb_check_polarity_82580(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\n\tret_val = phy->ops.read_reg(hw, I82580_PHY_STATUS_2, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = (data & I82580_PHY_STATUS2_REV_POLARITY)\n\t\t\t\t      ? e1000_rev_polarity_reversed\n\t\t\t\t      : e1000_rev_polarity_normal;\n\n\treturn ret_val;\n}\n\n \ns32 igb_phy_force_speed_duplex_82580(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tigb_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\tret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = phy->ops.read_reg(hw, I82580_PHY_CTRL_2, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_data &= ~I82580_PHY_CTRL2_MDIX_CFG_MASK;\n\n\tret_val = phy->ops.write_reg(hw, I82580_PHY_CTRL_2, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\thw_dbg(\"I82580_PHY_CTRL_2: %X\\n\", phy_data);\n\n\tudelay(1);\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\thw_dbg(\"Waiting for forced speed/duplex link on 82580 phy\\n\");\n\n\t\tret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT, 100000, &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (!link)\n\t\t\thw_dbg(\"Link taking longer than expected.\\n\");\n\n\t\t \n\t\tret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT, 100000, &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_get_phy_info_82580(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = igb_phy_has_link(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!link) {\n\t\thw_dbg(\"Phy info is only valid if link is up\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tphy->polarity_correction = true;\n\n\tret_val = igb_check_polarity_82580(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = phy->ops.read_reg(hw, I82580_PHY_STATUS_2, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->is_mdix = (data & I82580_PHY_STATUS2_MDIX) ? true : false;\n\n\tif ((data & I82580_PHY_STATUS2_SPEED_MASK) ==\n\t    I82580_PHY_STATUS2_SPEED_1000MBPS) {\n\t\tret_val = hw->phy.ops.get_cable_length(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tret_val = phy->ops.read_reg(hw, PHY_1000T_STATUS, &data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->local_rx = (data & SR_1000T_LOCAL_RX_STATUS)\n\t\t\t\t? e1000_1000t_rx_status_ok\n\t\t\t\t: e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (data & SR_1000T_REMOTE_RX_STATUS)\n\t\t\t\t ? e1000_1000t_rx_status_ok\n\t\t\t\t : e1000_1000t_rx_status_not_ok;\n\t} else {\n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_get_cable_length_82580(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, length;\n\n\tret_val = phy->ops.read_reg(hw, I82580_PHY_DIAG_STATUS, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tlength = (phy_data & I82580_DSTATUS_CABLE_LENGTH) >>\n\t\t I82580_DSTATUS_CABLE_LENGTH_SHIFT;\n\n\tif (length == E1000_CABLE_LENGTH_UNDEFINED)\n\t\tret_val = -E1000_ERR_PHY;\n\n\tphy->cable_length = length;\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_set_master_slave_mode(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\t \n\tret_val = hw->phy.ops.read_reg(hw, PHY_1000T_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\thw->phy.original_ms_type = (phy_data & CR_1000T_MS_ENABLE) ?\n\t\t\t\t   ((phy_data & CR_1000T_MS_VALUE) ?\n\t\t\t\t    e1000_ms_force_master :\n\t\t\t\t    e1000_ms_force_slave) : e1000_ms_auto;\n\n\tswitch (hw->phy.ms_type) {\n\tcase e1000_ms_force_master:\n\t\tphy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);\n\t\tbreak;\n\tcase e1000_ms_force_slave:\n\t\tphy_data |= CR_1000T_MS_ENABLE;\n\t\tphy_data &= ~(CR_1000T_MS_VALUE);\n\t\tbreak;\n\tcase e1000_ms_auto:\n\t\tphy_data &= ~CR_1000T_MS_ENABLE;\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn hw->phy.ops.write_reg(hw, PHY_1000T_CTRL, phy_data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}