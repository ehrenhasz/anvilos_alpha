{
  "module_name": "igb.h",
  "hash_id": "19b550070386853e0dd0700a16e6268c06fa7da8dc786c14e3aa3ac7c3aeb1f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/igb.h",
  "human_readable_source": " \n \n\n \n\n#ifndef _IGB_H_\n#define _IGB_H_\n\n#include \"e1000_mac.h\"\n#include \"e1000_82575.h\"\n\n#include <linux/timecounter.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/bitops.h>\n#include <linux/if_vlan.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/pci.h>\n#include <linux/mdio.h>\n\n#include <net/xdp.h>\n\nstruct igb_adapter;\n\n#define E1000_PCS_CFG_IGN_SD\t1\n\n \n#define IGB_START_ITR\t\t648  \n#define IGB_4K_ITR\t\t980\n#define IGB_20K_ITR\t\t196\n#define IGB_70K_ITR\t\t56\n\n \n#define IGB_DEFAULT_TXD\t\t256\n#define IGB_DEFAULT_TX_WORK\t128\n#define IGB_MIN_TXD\t\t64\n#define IGB_MAX_TXD\t\t4096\n\n#define IGB_DEFAULT_RXD\t\t256\n#define IGB_MIN_RXD\t\t64\n#define IGB_MAX_RXD\t\t4096\n\n#define IGB_DEFAULT_ITR\t\t3  \n#define IGB_MAX_ITR_USECS\t10000\n#define IGB_MIN_ITR_USECS\t10\n#define NON_Q_VECTORS\t\t1\n#define MAX_Q_VECTORS\t\t8\n#define MAX_MSIX_ENTRIES\t10\n\n \n#define IGB_MAX_RX_QUEUES\t8\n#define IGB_MAX_RX_QUEUES_82575\t4\n#define IGB_MAX_RX_QUEUES_I211\t2\n#define IGB_MAX_TX_QUEUES\t8\n#define IGB_MAX_VF_MC_ENTRIES\t30\n#define IGB_MAX_VF_FUNCTIONS\t8\n#define IGB_MAX_VFTA_ENTRIES\t128\n#define IGB_82576_VF_DEV_ID\t0x10CA\n#define IGB_I350_VF_DEV_ID\t0x1520\n\n \n#define IGB_MAJOR_MASK\t\t0xF000\n#define IGB_MINOR_MASK\t\t0x0FF0\n#define IGB_BUILD_MASK\t\t0x000F\n#define IGB_COMB_VER_MASK\t0x00FF\n#define IGB_MAJOR_SHIFT\t\t12\n#define IGB_MINOR_SHIFT\t\t4\n#define IGB_COMB_VER_SHFT\t8\n#define IGB_NVM_VER_INVALID\t0xFFFF\n#define IGB_ETRACK_SHIFT\t16\n#define NVM_ETRACK_WORD\t\t0x0042\n#define NVM_COMB_VER_OFF\t0x0083\n#define NVM_COMB_VER_PTR\t0x003d\n\n \n#define IGB_I210_TX_LATENCY_10\t\t9542\n#define IGB_I210_TX_LATENCY_100\t\t1024\n#define IGB_I210_TX_LATENCY_1000\t178\n#define IGB_I210_RX_LATENCY_10\t\t20662\n#define IGB_I210_RX_LATENCY_100\t\t2213\n#define IGB_I210_RX_LATENCY_1000\t448\n\n \n#define IGB_XDP_PASS\t\t0\n#define IGB_XDP_CONSUMED\tBIT(0)\n#define IGB_XDP_TX\t\tBIT(1)\n#define IGB_XDP_REDIR\t\tBIT(2)\n\nstruct vf_data_storage {\n\tunsigned char vf_mac_addresses[ETH_ALEN];\n\tu16 vf_mc_hashes[IGB_MAX_VF_MC_ENTRIES];\n\tu16 num_vf_mc_hashes;\n\tu32 flags;\n\tunsigned long last_nack;\n\tu16 pf_vlan;  \n\tu16 pf_qos;\n\tu16 tx_rate;\n\tbool spoofchk_enabled;\n\tbool trusted;\n};\n\n \n#define IGB_PF_MAC_FILTERS_RESERVED\t3\n\nstruct vf_mac_filter {\n\tstruct list_head l;\n\tint vf;\n\tbool free;\n\tu8 vf_mac[ETH_ALEN];\n};\n\n#define IGB_VF_FLAG_CTS            0x00000001  \n#define IGB_VF_FLAG_UNI_PROMISC    0x00000002  \n#define IGB_VF_FLAG_MULTI_PROMISC  0x00000004  \n#define IGB_VF_FLAG_PF_SET_MAC     0x00000008  \n\n \n#define IGB_RX_PTHRESH\t((hw->mac.type == e1000_i354) ? 12 : 8)\n#define IGB_RX_HTHRESH\t8\n#define IGB_TX_PTHRESH\t((hw->mac.type == e1000_i354) ? 20 : 8)\n#define IGB_TX_HTHRESH\t1\n#define IGB_RX_WTHRESH\t((hw->mac.type == e1000_82576 && \\\n\t\t\t  (adapter->flags & IGB_FLAG_HAS_MSIX)) ? 1 : 4)\n#define IGB_TX_WTHRESH\t((hw->mac.type == e1000_82576 && \\\n\t\t\t  (adapter->flags & IGB_FLAG_HAS_MSIX)) ? 1 : 16)\n\n \n#define MAXIMUM_ETHERNET_VLAN_SIZE 1522\n\n#define IGB_ETH_PKT_HDR_PAD\t(ETH_HLEN + ETH_FCS_LEN + (VLAN_HLEN * 2))\n\n \n#define IGB_RXBUFFER_256\t256\n#define IGB_RXBUFFER_1536\t1536\n#define IGB_RXBUFFER_2048\t2048\n#define IGB_RXBUFFER_3072\t3072\n#define IGB_RX_HDR_LEN\t\tIGB_RXBUFFER_256\n#define IGB_TS_HDR_LEN\t\t16\n\n \n#if (PAGE_SIZE < 8192)\n#define IGB_MAX_FRAME_BUILD_SKB (IGB_RXBUFFER_1536 - NET_IP_ALIGN)\n#define IGB_2K_TOO_SMALL_WITH_PADDING \\\n((NET_SKB_PAD + IGB_TS_HDR_LEN + IGB_RXBUFFER_1536) > SKB_WITH_OVERHEAD(IGB_RXBUFFER_2048))\n\nstatic inline int igb_compute_pad(int rx_buf_len)\n{\n\tint page_size, pad_size;\n\n\tpage_size = ALIGN(rx_buf_len, PAGE_SIZE / 2);\n\tpad_size = SKB_WITH_OVERHEAD(page_size) - rx_buf_len;\n\n\treturn pad_size;\n}\n\nstatic inline int igb_skb_pad(void)\n{\n\tint rx_buf_len;\n\n\t \n\tif (IGB_2K_TOO_SMALL_WITH_PADDING)\n\t\trx_buf_len = IGB_RXBUFFER_3072 + SKB_DATA_ALIGN(NET_IP_ALIGN);\n\telse\n\t\trx_buf_len = IGB_RXBUFFER_1536;\n\n\t \n\trx_buf_len -= NET_IP_ALIGN;\n\n\treturn igb_compute_pad(rx_buf_len);\n}\n\n#define IGB_SKB_PAD\tigb_skb_pad()\n#else\n#define IGB_SKB_PAD\t(NET_SKB_PAD + NET_IP_ALIGN)\n#endif\n\n \n#define IGB_RX_BUFFER_WRITE\t16  \n\n#define IGB_RX_DMA_ATTR \\\n\t(DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING)\n\n#define AUTO_ALL_MODES\t\t0\n#define IGB_EEPROM_APME\t\t0x0400\n\n#ifndef IGB_MASTER_SLAVE\n \n#define IGB_MASTER_SLAVE\te1000_ms_hw_default\n#endif\n\n#define IGB_MNG_VLAN_NONE\t-1\n\nenum igb_tx_flags {\n\t \n\tIGB_TX_FLAGS_VLAN\t= 0x01,\n\tIGB_TX_FLAGS_TSO\t= 0x02,\n\tIGB_TX_FLAGS_TSTAMP\t= 0x04,\n\n\t \n\tIGB_TX_FLAGS_IPV4\t= 0x10,\n\tIGB_TX_FLAGS_CSUM\t= 0x20,\n};\n\n \n#define IGB_TX_FLAGS_VLAN_MASK\t0xffff0000\n#define IGB_TX_FLAGS_VLAN_SHIFT\t16\n\n \n#define IGB_MAX_TXD_PWR\t15\n#define IGB_MAX_DATA_PER_TXD\t(1u << IGB_MAX_TXD_PWR)\n\n \n#define TXD_USE_COUNT(S) DIV_ROUND_UP((S), IGB_MAX_DATA_PER_TXD)\n#define DESC_NEEDED (MAX_SKB_FRAGS + 4)\n\n \n#define IGB_SFF_8472_SWAP\t\t0x5C\n#define IGB_SFF_8472_COMP\t\t0x5E\n\n \n#define IGB_SFF_ADDRESSING_MODE\t\t0x4\n#define IGB_SFF_8472_UNSUP\t\t0x00\n\n \nenum igb_tx_buf_type {\n\tIGB_TYPE_SKB = 0,\n\tIGB_TYPE_XDP,\n};\n\n \nstruct igb_tx_buffer {\n\tunion e1000_adv_tx_desc *next_to_watch;\n\tunsigned long time_stamp;\n\tenum igb_tx_buf_type type;\n\tunion {\n\t\tstruct sk_buff *skb;\n\t\tstruct xdp_frame *xdpf;\n\t};\n\tunsigned int bytecount;\n\tu16 gso_segs;\n\t__be16 protocol;\n\n\tDEFINE_DMA_UNMAP_ADDR(dma);\n\tDEFINE_DMA_UNMAP_LEN(len);\n\tu32 tx_flags;\n};\n\nstruct igb_rx_buffer {\n\tdma_addr_t dma;\n\tstruct page *page;\n#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)\n\t__u32 page_offset;\n#else\n\t__u16 page_offset;\n#endif\n\t__u16 pagecnt_bias;\n};\n\nstruct igb_tx_queue_stats {\n\tu64 packets;\n\tu64 bytes;\n\tu64 restart_queue;\n\tu64 restart_queue2;\n};\n\nstruct igb_rx_queue_stats {\n\tu64 packets;\n\tu64 bytes;\n\tu64 drops;\n\tu64 csum_err;\n\tu64 alloc_failed;\n};\n\nstruct igb_ring_container {\n\tstruct igb_ring *ring;\t\t \n\tunsigned int total_bytes;\t \n\tunsigned int total_packets;\t \n\tu16 work_limit;\t\t\t \n\tu8 count;\t\t\t \n\tu8 itr;\t\t\t\t \n};\n\nstruct igb_ring {\n\tstruct igb_q_vector *q_vector;\t \n\tstruct net_device *netdev;\t \n\tstruct bpf_prog *xdp_prog;\n\tstruct device *dev;\t\t \n\tunion {\t\t\t\t \n\t\tstruct igb_tx_buffer *tx_buffer_info;\n\t\tstruct igb_rx_buffer *rx_buffer_info;\n\t};\n\tvoid *desc;\t\t\t \n\tunsigned long flags;\t\t \n\tvoid __iomem *tail;\t\t \n\tdma_addr_t dma;\t\t\t \n\tunsigned int  size;\t\t \n\n\tu16 count;\t\t\t \n\tu8 queue_index;\t\t\t \n\tu8 reg_idx;\t\t\t \n\tbool launchtime_enable;\t\t \n\tbool cbs_enable;\t\t \n\ts32 idleslope;\t\t\t \n\ts32 sendslope;\t\t\t \n\ts32 hicredit;\t\t\t \n\ts32 locredit;\t\t\t \n\n\t \n\tu16 next_to_clean;\n\tu16 next_to_use;\n\tu16 next_to_alloc;\n\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tstruct igb_tx_queue_stats tx_stats;\n\t\t\tstruct u64_stats_sync tx_syncp;\n\t\t\tstruct u64_stats_sync tx_syncp2;\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\tstruct sk_buff *skb;\n\t\t\tstruct igb_rx_queue_stats rx_stats;\n\t\t\tstruct u64_stats_sync rx_syncp;\n\t\t};\n\t};\n\tstruct xdp_rxq_info xdp_rxq;\n} ____cacheline_internodealigned_in_smp;\n\nstruct igb_q_vector {\n\tstruct igb_adapter *adapter;\t \n\tint cpu;\t\t\t \n\tu32 eims_value;\t\t\t \n\n\tu16 itr_val;\n\tu8 set_itr;\n\tvoid __iomem *itr_register;\n\n\tstruct igb_ring_container rx, tx;\n\n\tstruct napi_struct napi;\n\tstruct rcu_head rcu;\t \n\tchar name[IFNAMSIZ + 9];\n\n\t \n\tstruct igb_ring ring[] ____cacheline_internodealigned_in_smp;\n};\n\nenum e1000_ring_flags_t {\n\tIGB_RING_FLAG_RX_3K_BUFFER,\n\tIGB_RING_FLAG_RX_BUILD_SKB_ENABLED,\n\tIGB_RING_FLAG_RX_SCTP_CSUM,\n\tIGB_RING_FLAG_RX_LB_VLAN_BSWAP,\n\tIGB_RING_FLAG_TX_CTX_IDX,\n\tIGB_RING_FLAG_TX_DETECT_HANG\n};\n\n#define ring_uses_large_buffer(ring) \\\n\ttest_bit(IGB_RING_FLAG_RX_3K_BUFFER, &(ring)->flags)\n#define set_ring_uses_large_buffer(ring) \\\n\tset_bit(IGB_RING_FLAG_RX_3K_BUFFER, &(ring)->flags)\n#define clear_ring_uses_large_buffer(ring) \\\n\tclear_bit(IGB_RING_FLAG_RX_3K_BUFFER, &(ring)->flags)\n\n#define ring_uses_build_skb(ring) \\\n\ttest_bit(IGB_RING_FLAG_RX_BUILD_SKB_ENABLED, &(ring)->flags)\n#define set_ring_build_skb_enabled(ring) \\\n\tset_bit(IGB_RING_FLAG_RX_BUILD_SKB_ENABLED, &(ring)->flags)\n#define clear_ring_build_skb_enabled(ring) \\\n\tclear_bit(IGB_RING_FLAG_RX_BUILD_SKB_ENABLED, &(ring)->flags)\n\nstatic inline unsigned int igb_rx_bufsz(struct igb_ring *ring)\n{\n#if (PAGE_SIZE < 8192)\n\tif (ring_uses_large_buffer(ring))\n\t\treturn IGB_RXBUFFER_3072;\n\n\tif (ring_uses_build_skb(ring))\n\t\treturn IGB_MAX_FRAME_BUILD_SKB;\n#endif\n\treturn IGB_RXBUFFER_2048;\n}\n\nstatic inline unsigned int igb_rx_pg_order(struct igb_ring *ring)\n{\n#if (PAGE_SIZE < 8192)\n\tif (ring_uses_large_buffer(ring))\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n#define igb_rx_pg_size(_ring) (PAGE_SIZE << igb_rx_pg_order(_ring))\n\n#define IGB_TXD_DCMD (E1000_ADVTXD_DCMD_EOP | E1000_ADVTXD_DCMD_RS)\n\n#define IGB_RX_DESC(R, i)\t\\\n\t(&(((union e1000_adv_rx_desc *)((R)->desc))[i]))\n#define IGB_TX_DESC(R, i)\t\\\n\t(&(((union e1000_adv_tx_desc *)((R)->desc))[i]))\n#define IGB_TX_CTXTDESC(R, i)\t\\\n\t(&(((struct e1000_adv_tx_context_desc *)((R)->desc))[i]))\n\n \nstatic inline __le32 igb_test_staterr(union e1000_adv_rx_desc *rx_desc,\n\t\t\t\t      const u32 stat_err_bits)\n{\n\treturn rx_desc->wb.upper.status_error & cpu_to_le32(stat_err_bits);\n}\n\n \nstatic inline int igb_desc_unused(struct igb_ring *ring)\n{\n\tif (ring->next_to_clean > ring->next_to_use)\n\t\treturn ring->next_to_clean - ring->next_to_use - 1;\n\n\treturn ring->count + ring->next_to_clean - ring->next_to_use - 1;\n}\n\n#ifdef CONFIG_IGB_HWMON\n\n#define IGB_HWMON_TYPE_LOC\t0\n#define IGB_HWMON_TYPE_TEMP\t1\n#define IGB_HWMON_TYPE_CAUTION\t2\n#define IGB_HWMON_TYPE_MAX\t3\n\nstruct hwmon_attr {\n\tstruct device_attribute dev_attr;\n\tstruct e1000_hw *hw;\n\tstruct e1000_thermal_diode_data *sensor;\n\tchar name[12];\n\t};\n\nstruct hwmon_buff {\n\tstruct attribute_group group;\n\tconst struct attribute_group *groups[2];\n\tstruct attribute *attrs[E1000_MAX_SENSORS * 4 + 1];\n\tstruct hwmon_attr hwmon_list[E1000_MAX_SENSORS * 4];\n\tunsigned int n_hwmon;\n\t};\n#endif\n\n \n#define MAX_ETYPE_FILTER\t(4 - 1)\n \n#define IGB_ETQF_FILTER_1588\t3\n\n#define IGB_N_EXTTS\t2\n#define IGB_N_PEROUT\t2\n#define IGB_N_SDP\t4\n#define IGB_RETA_SIZE\t128\n\nenum igb_filter_match_flags {\n\tIGB_FILTER_FLAG_ETHER_TYPE = 0x1,\n\tIGB_FILTER_FLAG_VLAN_TCI   = 0x2,\n\tIGB_FILTER_FLAG_SRC_MAC_ADDR   = 0x4,\n\tIGB_FILTER_FLAG_DST_MAC_ADDR   = 0x8,\n};\n\n#define IGB_MAX_RXNFC_FILTERS 16\n\n \nstruct igb_nfc_input {\n\t \n\tu8 match_flags;\n\t__be16 etype;\n\t__be16 vlan_tci;\n\tu8 src_addr[ETH_ALEN];\n\tu8 dst_addr[ETH_ALEN];\n};\n\nstruct igb_nfc_filter {\n\tstruct hlist_node nfc_node;\n\tstruct igb_nfc_input filter;\n\tunsigned long cookie;\n\tu16 etype_reg_index;\n\tu16 sw_idx;\n\tu16 action;\n};\n\nstruct igb_mac_addr {\n\tu8 addr[ETH_ALEN];\n\tu8 queue;\n\tu8 state;  \n};\n\n#define IGB_MAC_STATE_DEFAULT\t0x1\n#define IGB_MAC_STATE_IN_USE\t0x2\n#define IGB_MAC_STATE_SRC_ADDR\t0x4\n#define IGB_MAC_STATE_QUEUE_STEERING 0x8\n\n \nstruct igb_adapter {\n\tunsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];\n\n\tstruct net_device *netdev;\n\tstruct bpf_prog *xdp_prog;\n\n\tunsigned long state;\n\tunsigned int flags;\n\n\tunsigned int num_q_vectors;\n\tstruct msix_entry msix_entries[MAX_MSIX_ENTRIES];\n\n\t \n\tu32 rx_itr_setting;\n\tu32 tx_itr_setting;\n\tu16 tx_itr;\n\tu16 rx_itr;\n\n\t \n\tu16 tx_work_limit;\n\tu32 tx_timeout_count;\n\tint num_tx_queues;\n\tstruct igb_ring *tx_ring[16];\n\n\t \n\tint num_rx_queues;\n\tstruct igb_ring *rx_ring[16];\n\n\tu32 max_frame_size;\n\tu32 min_frame_size;\n\n\tstruct timer_list watchdog_timer;\n\tstruct timer_list phy_info_timer;\n\n\tu16 mng_vlan_id;\n\tu32 bd_number;\n\tu32 wol;\n\tu32 en_mng_pt;\n\tu16 link_speed;\n\tu16 link_duplex;\n\n\tu8 __iomem *io_addr;  \n\n\tstruct work_struct reset_task;\n\tstruct work_struct watchdog_task;\n\tbool fc_autoneg;\n\tu8  tx_timeout_factor;\n\tstruct timer_list blink_timer;\n\tunsigned long led_status;\n\n\t \n\tstruct pci_dev *pdev;\n\n\tspinlock_t stats64_lock;\n\tstruct rtnl_link_stats64 stats64;\n\n\t \n\tstruct e1000_hw hw;\n\tstruct e1000_hw_stats stats;\n\tstruct e1000_phy_info phy_info;\n\n\tu32 test_icr;\n\tstruct igb_ring test_tx_ring;\n\tstruct igb_ring test_rx_ring;\n\n\tint msg_enable;\n\n\tstruct igb_q_vector *q_vector[MAX_Q_VECTORS];\n\tu32 eims_enable_mask;\n\tu32 eims_other;\n\n\t \n\tu16 tx_ring_count;\n\tu16 rx_ring_count;\n\tunsigned int vfs_allocated_count;\n\tstruct vf_data_storage *vf_data;\n\tint vf_rate_link_speed;\n\tu32 rss_queues;\n\tu32 wvbr;\n\tu32 *shadow_vfta;\n\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_caps;\n\tstruct delayed_work ptp_overflow_work;\n\tstruct work_struct ptp_tx_work;\n\tstruct sk_buff *ptp_tx_skb;\n\tstruct hwtstamp_config tstamp_config;\n\tunsigned long ptp_tx_start;\n\tunsigned long last_rx_ptp_check;\n\tunsigned long last_rx_timestamp;\n\tunsigned int ptp_flags;\n\tspinlock_t tmreg_lock;\n\tstruct cyclecounter cc;\n\tstruct timecounter tc;\n\tu32 tx_hwtstamp_timeouts;\n\tu32 tx_hwtstamp_skipped;\n\tu32 rx_hwtstamp_cleared;\n\tbool pps_sys_wrap_on;\n\n\tstruct ptp_pin_desc sdp_config[IGB_N_SDP];\n\tstruct {\n\t\tstruct timespec64 start;\n\t\tstruct timespec64 period;\n\t} perout[IGB_N_PEROUT];\n\n\tchar fw_version[32];\n#ifdef CONFIG_IGB_HWMON\n\tstruct hwmon_buff *igb_hwmon_buff;\n\tbool ets;\n#endif\n\tstruct i2c_algo_bit_data i2c_algo;\n\tstruct i2c_adapter i2c_adap;\n\tstruct i2c_client *i2c_client;\n\tu32 rss_indir_tbl_init;\n\tu8 rss_indir_tbl[IGB_RETA_SIZE];\n\n\tunsigned long link_check_timeout;\n\tint copper_tries;\n\tstruct e1000_info ei;\n\tu16 eee_advert;\n\n\t \n\tstruct hlist_head nfc_filter_list;\n\tstruct hlist_head cls_flower_list;\n\tunsigned int nfc_filter_count;\n\t \n\tspinlock_t nfc_lock;\n\tbool etype_bitmap[MAX_ETYPE_FILTER];\n\n\tstruct igb_mac_addr *mac_table;\n\tstruct vf_mac_filter vf_macs;\n\tstruct vf_mac_filter *vf_mac_list;\n\t \n\tspinlock_t vfs_lock;\n};\n\n \n#define IGB_PTP_ENABLED\t\tBIT(0)\n#define IGB_PTP_OVERFLOW_CHECK\tBIT(1)\n\n#define IGB_FLAG_HAS_MSI\t\tBIT(0)\n#define IGB_FLAG_DCA_ENABLED\t\tBIT(1)\n#define IGB_FLAG_QUAD_PORT_A\t\tBIT(2)\n#define IGB_FLAG_QUEUE_PAIRS\t\tBIT(3)\n#define IGB_FLAG_DMAC\t\t\tBIT(4)\n#define IGB_FLAG_RSS_FIELD_IPV4_UDP\tBIT(6)\n#define IGB_FLAG_RSS_FIELD_IPV6_UDP\tBIT(7)\n#define IGB_FLAG_WOL_SUPPORTED\t\tBIT(8)\n#define IGB_FLAG_NEED_LINK_UPDATE\tBIT(9)\n#define IGB_FLAG_MEDIA_RESET\t\tBIT(10)\n#define IGB_FLAG_MAS_CAPABLE\t\tBIT(11)\n#define IGB_FLAG_MAS_ENABLE\t\tBIT(12)\n#define IGB_FLAG_HAS_MSIX\t\tBIT(13)\n#define IGB_FLAG_EEE\t\t\tBIT(14)\n#define IGB_FLAG_VLAN_PROMISC\t\tBIT(15)\n#define IGB_FLAG_RX_LEGACY\t\tBIT(16)\n#define IGB_FLAG_FQTSS\t\t\tBIT(17)\n\n \n#define IGB_MAS_ENABLE_0\t\t0X0001\n#define IGB_MAS_ENABLE_1\t\t0X0002\n#define IGB_MAS_ENABLE_2\t\t0X0004\n#define IGB_MAS_ENABLE_3\t\t0X0008\n\n \n#define IGB_MIN_TXPBSIZE\t20408\n#define IGB_TX_BUF_4096\t\t4096\n#define IGB_DMCTLX_DCFLUSH_DIS\t0x80000000   \n\n#define IGB_82576_TSYNC_SHIFT\t19\nenum e1000_state_t {\n\t__IGB_TESTING,\n\t__IGB_RESETTING,\n\t__IGB_DOWN,\n\t__IGB_PTP_TX_IN_PROGRESS,\n};\n\nenum igb_boards {\n\tboard_82575,\n};\n\nextern char igb_driver_name[];\n\nint igb_xmit_xdp_ring(struct igb_adapter *adapter,\n\t\t      struct igb_ring *ring,\n\t\t      struct xdp_frame *xdpf);\nint igb_open(struct net_device *netdev);\nint igb_close(struct net_device *netdev);\nint igb_up(struct igb_adapter *);\nvoid igb_down(struct igb_adapter *);\nvoid igb_reinit_locked(struct igb_adapter *);\nvoid igb_reset(struct igb_adapter *);\nint igb_reinit_queues(struct igb_adapter *);\nvoid igb_write_rss_indir_tbl(struct igb_adapter *);\nint igb_set_spd_dplx(struct igb_adapter *, u32, u8);\nint igb_setup_tx_resources(struct igb_ring *);\nint igb_setup_rx_resources(struct igb_ring *);\nvoid igb_free_tx_resources(struct igb_ring *);\nvoid igb_free_rx_resources(struct igb_ring *);\nvoid igb_configure_tx_ring(struct igb_adapter *, struct igb_ring *);\nvoid igb_configure_rx_ring(struct igb_adapter *, struct igb_ring *);\nvoid igb_setup_tctl(struct igb_adapter *);\nvoid igb_setup_rctl(struct igb_adapter *);\nvoid igb_setup_srrctl(struct igb_adapter *, struct igb_ring *);\nnetdev_tx_t igb_xmit_frame_ring(struct sk_buff *, struct igb_ring *);\nvoid igb_alloc_rx_buffers(struct igb_ring *, u16);\nvoid igb_update_stats(struct igb_adapter *);\nbool igb_has_link(struct igb_adapter *adapter);\nvoid igb_set_ethtool_ops(struct net_device *);\nvoid igb_power_up_link(struct igb_adapter *);\nvoid igb_set_fw_version(struct igb_adapter *);\nvoid igb_ptp_init(struct igb_adapter *adapter);\nvoid igb_ptp_stop(struct igb_adapter *adapter);\nvoid igb_ptp_reset(struct igb_adapter *adapter);\nvoid igb_ptp_suspend(struct igb_adapter *adapter);\nvoid igb_ptp_rx_hang(struct igb_adapter *adapter);\nvoid igb_ptp_tx_hang(struct igb_adapter *adapter);\nvoid igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector, struct sk_buff *skb);\nint igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector, void *va,\n\t\t\tktime_t *timestamp);\nint igb_ptp_set_ts_config(struct net_device *netdev, struct ifreq *ifr);\nint igb_ptp_get_ts_config(struct net_device *netdev, struct ifreq *ifr);\nvoid igb_set_flag_queue_pairs(struct igb_adapter *, const u32);\nunsigned int igb_get_max_rss_queues(struct igb_adapter *);\n#ifdef CONFIG_IGB_HWMON\nvoid igb_sysfs_exit(struct igb_adapter *adapter);\nint igb_sysfs_init(struct igb_adapter *adapter);\n#endif\nstatic inline s32 igb_reset_phy(struct e1000_hw *hw)\n{\n\tif (hw->phy.ops.reset)\n\t\treturn hw->phy.ops.reset(hw);\n\n\treturn 0;\n}\n\nstatic inline s32 igb_read_phy_reg(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\tif (hw->phy.ops.read_reg)\n\t\treturn hw->phy.ops.read_reg(hw, offset, data);\n\n\treturn 0;\n}\n\nstatic inline s32 igb_write_phy_reg(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\tif (hw->phy.ops.write_reg)\n\t\treturn hw->phy.ops.write_reg(hw, offset, data);\n\n\treturn 0;\n}\n\nstatic inline s32 igb_get_phy_info(struct e1000_hw *hw)\n{\n\tif (hw->phy.ops.get_phy_info)\n\t\treturn hw->phy.ops.get_phy_info(hw);\n\n\treturn 0;\n}\n\nstatic inline struct netdev_queue *txring_txq(const struct igb_ring *tx_ring)\n{\n\treturn netdev_get_tx_queue(tx_ring->netdev, tx_ring->queue_index);\n}\n\nint igb_add_filter(struct igb_adapter *adapter,\n\t\t   struct igb_nfc_filter *input);\nint igb_erase_filter(struct igb_adapter *adapter,\n\t\t     struct igb_nfc_filter *input);\n\nint igb_add_mac_steering_filter(struct igb_adapter *adapter,\n\t\t\t\tconst u8 *addr, u8 queue, u8 flags);\nint igb_del_mac_steering_filter(struct igb_adapter *adapter,\n\t\t\t\tconst u8 *addr, u8 queue, u8 flags);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}