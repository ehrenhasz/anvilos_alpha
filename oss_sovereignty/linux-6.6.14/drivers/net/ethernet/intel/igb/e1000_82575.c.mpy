{
  "module_name": "e1000_82575.c",
  "hash_id": "e64a2fe1a872b11b065bc5ffa12453aedc167e5a6fd2978014a9ef0440cccac3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igb/e1000_82575.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/if_ether.h>\n#include <linux/i2c.h>\n\n#include \"e1000_mac.h\"\n#include \"e1000_82575.h\"\n#include \"e1000_i210.h\"\n#include \"igb.h\"\n\nstatic s32  igb_get_invariants_82575(struct e1000_hw *);\nstatic s32  igb_acquire_phy_82575(struct e1000_hw *);\nstatic void igb_release_phy_82575(struct e1000_hw *);\nstatic s32  igb_acquire_nvm_82575(struct e1000_hw *);\nstatic void igb_release_nvm_82575(struct e1000_hw *);\nstatic s32  igb_check_for_link_82575(struct e1000_hw *);\nstatic s32  igb_get_cfg_done_82575(struct e1000_hw *);\nstatic s32  igb_init_hw_82575(struct e1000_hw *);\nstatic s32  igb_phy_hw_reset_sgmii_82575(struct e1000_hw *);\nstatic s32  igb_read_phy_reg_sgmii_82575(struct e1000_hw *, u32, u16 *);\nstatic s32  igb_reset_hw_82575(struct e1000_hw *);\nstatic s32  igb_reset_hw_82580(struct e1000_hw *);\nstatic s32  igb_set_d0_lplu_state_82575(struct e1000_hw *, bool);\nstatic s32  igb_set_d0_lplu_state_82580(struct e1000_hw *, bool);\nstatic s32  igb_set_d3_lplu_state_82580(struct e1000_hw *, bool);\nstatic s32  igb_setup_copper_link_82575(struct e1000_hw *);\nstatic s32  igb_setup_serdes_link_82575(struct e1000_hw *);\nstatic s32  igb_write_phy_reg_sgmii_82575(struct e1000_hw *, u32, u16);\nstatic void igb_clear_hw_cntrs_82575(struct e1000_hw *);\nstatic s32  igb_acquire_swfw_sync_82575(struct e1000_hw *, u16);\nstatic s32  igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *, u16 *,\n\t\t\t\t\t\t u16 *);\nstatic s32  igb_get_phy_id_82575(struct e1000_hw *);\nstatic void igb_release_swfw_sync_82575(struct e1000_hw *, u16);\nstatic bool igb_sgmii_active_82575(struct e1000_hw *);\nstatic s32  igb_reset_init_script_82575(struct e1000_hw *);\nstatic s32  igb_read_mac_addr_82575(struct e1000_hw *);\nstatic s32  igb_set_pcie_completion_timeout(struct e1000_hw *hw);\nstatic s32  igb_reset_mdicnfg_82580(struct e1000_hw *hw);\nstatic s32  igb_validate_nvm_checksum_82580(struct e1000_hw *hw);\nstatic s32  igb_update_nvm_checksum_82580(struct e1000_hw *hw);\nstatic s32 igb_validate_nvm_checksum_i350(struct e1000_hw *hw);\nstatic s32 igb_update_nvm_checksum_i350(struct e1000_hw *hw);\nstatic const u16 e1000_82580_rxpbs_table[] = {\n\t36, 72, 144, 1, 2, 4, 8, 16, 35, 70, 140 };\n\n \n\n \nstatic void igb_write_vfta_i350(struct e1000_hw *hw, u32 offset, u32 value)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\tint i;\n\n\tfor (i = 10; i--;)\n\t\tarray_wr32(E1000_VFTA, offset, value);\n\n\twrfl();\n\tadapter->shadow_vfta[offset] = value;\n}\n\n \nstatic bool igb_sgmii_uses_mdio_82575(struct e1000_hw *hw)\n{\n\tu32 reg = 0;\n\tbool ext_mdio = false;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82575:\n\tcase e1000_82576:\n\t\treg = rd32(E1000_MDIC);\n\t\text_mdio = !!(reg & E1000_MDIC_DEST);\n\t\tbreak;\n\tcase e1000_82580:\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\treg = rd32(E1000_MDICNFG);\n\t\text_mdio = !!(reg & E1000_MDICNFG_EXT_MDIO);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ext_mdio;\n}\n\n \nstatic s32 igb_check_for_link_media_swap(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tu8 port = 0;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 0);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = phy->ops.read_reg(hw, E1000_M88E1112_STATUS, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (data & E1000_M88E1112_STATUS_LINK)\n\t\tport = E1000_MEDIA_PORT_COPPER;\n\n\t \n\tret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 1);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = phy->ops.read_reg(hw, E1000_M88E1112_STATUS, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\n\tif (data & E1000_M88E1112_STATUS_LINK)\n\t\tport = E1000_MEDIA_PORT_OTHER;\n\n\t \n\tif (port && (hw->dev_spec._82575.media_port != port)) {\n\t\thw->dev_spec._82575.media_port = port;\n\t\thw->dev_spec._82575.media_changed = true;\n\t}\n\n\tif (port == E1000_MEDIA_PORT_COPPER) {\n\t\t \n\t\tret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 0);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tigb_check_for_link_82575(hw);\n\t} else {\n\t\tigb_check_for_link_82575(hw);\n\t\t \n\t\tret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 0);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 igb_init_phy_params_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu32 ctrl_ext;\n\n\tif (hw->phy.media_type != e1000_media_type_copper) {\n\t\tphy->type = e1000_phy_none;\n\t\tgoto out;\n\t}\n\n\tphy->autoneg_mask\t= AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\tphy->reset_delay_us\t= 100;\n\n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\n\tif (igb_sgmii_active_82575(hw)) {\n\t\tphy->ops.reset = igb_phy_hw_reset_sgmii_82575;\n\t\tctrl_ext |= E1000_CTRL_I2C_ENA;\n\t} else {\n\t\tphy->ops.reset = igb_phy_hw_reset;\n\t\tctrl_ext &= ~E1000_CTRL_I2C_ENA;\n\t}\n\n\twr32(E1000_CTRL_EXT, ctrl_ext);\n\tigb_reset_mdicnfg_82580(hw);\n\n\tif (igb_sgmii_active_82575(hw) && !igb_sgmii_uses_mdio_82575(hw)) {\n\t\tphy->ops.read_reg = igb_read_phy_reg_sgmii_82575;\n\t\tphy->ops.write_reg = igb_write_phy_reg_sgmii_82575;\n\t} else {\n\t\tswitch (hw->mac.type) {\n\t\tcase e1000_82580:\n\t\tcase e1000_i350:\n\t\tcase e1000_i354:\n\t\tcase e1000_i210:\n\t\tcase e1000_i211:\n\t\t\tphy->ops.read_reg = igb_read_phy_reg_82580;\n\t\t\tphy->ops.write_reg = igb_write_phy_reg_82580;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphy->ops.read_reg = igb_read_phy_reg_igp;\n\t\t\tphy->ops.write_reg = igb_write_phy_reg_igp;\n\t\t}\n\t}\n\n\t \n\thw->bus.func = (rd32(E1000_STATUS) & E1000_STATUS_FUNC_MASK) >>\n\t\t\tE1000_STATUS_FUNC_SHIFT;\n\n\t \n\tret_val = igb_get_phy_id_82575(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tswitch (phy->id) {\n\tcase M88E1543_E_PHY_ID:\n\tcase M88E1512_E_PHY_ID:\n\tcase I347AT4_E_PHY_ID:\n\tcase M88E1112_E_PHY_ID:\n\tcase M88E1111_I_PHY_ID:\n\t\tphy->type\t\t= e1000_phy_m88;\n\t\tphy->ops.check_polarity\t= igb_check_polarity_m88;\n\t\tphy->ops.get_phy_info\t= igb_get_phy_info_m88;\n\t\tif (phy->id != M88E1111_I_PHY_ID)\n\t\t\tphy->ops.get_cable_length =\n\t\t\t\t\t igb_get_cable_length_m88_gen2;\n\t\telse\n\t\t\tphy->ops.get_cable_length = igb_get_cable_length_m88;\n\t\tphy->ops.force_speed_duplex = igb_phy_force_speed_duplex_m88;\n\t\t \n\t\tif (phy->id == M88E1112_E_PHY_ID) {\n\t\t\tu16 data;\n\n\t\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\t\t     E1000_M88E1112_PAGE_ADDR,\n\t\t\t\t\t\t     2);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tret_val = phy->ops.read_reg(hw,\n\t\t\t\t\t\t    E1000_M88E1112_MAC_CTRL_1,\n\t\t\t\t\t\t    &data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tdata = (data & E1000_M88E1112_MAC_CTRL_1_MODE_MASK) >>\n\t\t\t       E1000_M88E1112_MAC_CTRL_1_MODE_SHIFT;\n\t\t\tif (data == E1000_M88E1112_AUTO_COPPER_SGMII ||\n\t\t\t    data == E1000_M88E1112_AUTO_COPPER_BASEX)\n\t\t\t\thw->mac.ops.check_for_link =\n\t\t\t\t\t\tigb_check_for_link_media_swap;\n\t\t}\n\t\tif (phy->id == M88E1512_E_PHY_ID) {\n\t\t\tret_val = igb_initialize_M88E1512_phy(hw);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (phy->id == M88E1543_E_PHY_ID) {\n\t\t\tret_val = igb_initialize_M88E1543_phy(hw);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase IGP03E1000_E_PHY_ID:\n\t\tphy->type = e1000_phy_igp_3;\n\t\tphy->ops.get_phy_info = igb_get_phy_info_igp;\n\t\tphy->ops.get_cable_length = igb_get_cable_length_igp_2;\n\t\tphy->ops.force_speed_duplex = igb_phy_force_speed_duplex_igp;\n\t\tphy->ops.set_d0_lplu_state = igb_set_d0_lplu_state_82575;\n\t\tphy->ops.set_d3_lplu_state = igb_set_d3_lplu_state;\n\t\tbreak;\n\tcase I82580_I_PHY_ID:\n\tcase I350_I_PHY_ID:\n\t\tphy->type = e1000_phy_82580;\n\t\tphy->ops.force_speed_duplex =\n\t\t\t\t\t igb_phy_force_speed_duplex_82580;\n\t\tphy->ops.get_cable_length = igb_get_cable_length_82580;\n\t\tphy->ops.get_phy_info = igb_get_phy_info_82580;\n\t\tphy->ops.set_d0_lplu_state = igb_set_d0_lplu_state_82580;\n\t\tphy->ops.set_d3_lplu_state = igb_set_d3_lplu_state_82580;\n\t\tbreak;\n\tcase I210_I_PHY_ID:\n\t\tphy->type\t\t= e1000_phy_i210;\n\t\tphy->ops.check_polarity\t= igb_check_polarity_m88;\n\t\tphy->ops.get_cfg_done\t= igb_get_cfg_done_i210;\n\t\tphy->ops.get_phy_info\t= igb_get_phy_info_m88;\n\t\tphy->ops.get_cable_length = igb_get_cable_length_m88_gen2;\n\t\tphy->ops.set_d0_lplu_state = igb_set_d0_lplu_state_82580;\n\t\tphy->ops.set_d3_lplu_state = igb_set_d3_lplu_state_82580;\n\t\tphy->ops.force_speed_duplex = igb_phy_force_speed_duplex_m88;\n\t\tbreak;\n\tcase BCM54616_E_PHY_ID:\n\t\tphy->type = e1000_phy_bcm54616;\n\t\tbreak;\n\tdefault:\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_init_nvm_params_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = rd32(E1000_EECD);\n\tu16 size;\n\n\tsize = (u16)((eecd & E1000_EECD_SIZE_EX_MASK) >>\n\t\t     E1000_EECD_SIZE_EX_SHIFT);\n\n\t \n\tsize += NVM_WORD_SIZE_BASE_SHIFT;\n\n\t \n\tif (size > 15)\n\t\tsize = 15;\n\n\tnvm->word_size = BIT(size);\n\tnvm->opcode_bits = 8;\n\tnvm->delay_usec = 1;\n\n\tswitch (nvm->override) {\n\tcase e1000_nvm_override_spi_large:\n\t\tnvm->page_size = 32;\n\t\tnvm->address_bits = 16;\n\t\tbreak;\n\tcase e1000_nvm_override_spi_small:\n\t\tnvm->page_size = 8;\n\t\tnvm->address_bits = 8;\n\t\tbreak;\n\tdefault:\n\t\tnvm->page_size = eecd & E1000_EECD_ADDR_BITS ? 32 : 8;\n\t\tnvm->address_bits = eecd & E1000_EECD_ADDR_BITS ?\n\t\t\t\t    16 : 8;\n\t\tbreak;\n\t}\n\tif (nvm->word_size == BIT(15))\n\t\tnvm->page_size = 128;\n\n\tnvm->type = e1000_nvm_eeprom_spi;\n\n\t \n\tnvm->ops.acquire = igb_acquire_nvm_82575;\n\tnvm->ops.release = igb_release_nvm_82575;\n\tnvm->ops.write = igb_write_nvm_spi;\n\tnvm->ops.validate = igb_validate_nvm_checksum;\n\tnvm->ops.update = igb_update_nvm_checksum;\n\tif (nvm->word_size < BIT(15))\n\t\tnvm->ops.read = igb_read_nvm_eerd;\n\telse\n\t\tnvm->ops.read = igb_read_nvm_spi;\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82580:\n\t\tnvm->ops.validate = igb_validate_nvm_checksum_82580;\n\t\tnvm->ops.update = igb_update_nvm_checksum_82580;\n\t\tbreak;\n\tcase e1000_i354:\n\tcase e1000_i350:\n\t\tnvm->ops.validate = igb_validate_nvm_checksum_i350;\n\t\tnvm->ops.update = igb_update_nvm_checksum_i350;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 igb_init_mac_params_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\n\n\t \n\tmac->mta_reg_count = 128;\n\t \n\tmac->uta_reg_count = (hw->mac.type == e1000_82575) ? 0 : 128;\n\t \n\tswitch (mac->type) {\n\tcase e1000_82576:\n\t\tmac->rar_entry_count = E1000_RAR_ENTRIES_82576;\n\t\tbreak;\n\tcase e1000_82580:\n\t\tmac->rar_entry_count = E1000_RAR_ENTRIES_82580;\n\t\tbreak;\n\tcase e1000_i350:\n\tcase e1000_i354:\n\t\tmac->rar_entry_count = E1000_RAR_ENTRIES_I350;\n\t\tbreak;\n\tdefault:\n\t\tmac->rar_entry_count = E1000_RAR_ENTRIES_82575;\n\t\tbreak;\n\t}\n\t \n\tif (mac->type >= e1000_82580)\n\t\tmac->ops.reset_hw = igb_reset_hw_82580;\n\telse\n\t\tmac->ops.reset_hw = igb_reset_hw_82575;\n\n\tif (mac->type >= e1000_i210) {\n\t\tmac->ops.acquire_swfw_sync = igb_acquire_swfw_sync_i210;\n\t\tmac->ops.release_swfw_sync = igb_release_swfw_sync_i210;\n\n\t} else {\n\t\tmac->ops.acquire_swfw_sync = igb_acquire_swfw_sync_82575;\n\t\tmac->ops.release_swfw_sync = igb_release_swfw_sync_82575;\n\t}\n\n\tif ((hw->mac.type == e1000_i350) || (hw->mac.type == e1000_i354))\n\t\tmac->ops.write_vfta = igb_write_vfta_i350;\n\telse\n\t\tmac->ops.write_vfta = igb_write_vfta;\n\n\t \n\tmac->asf_firmware_present = true;\n\t \n\tmac->arc_subsystem_valid =\n\t\t(rd32(E1000_FWSM) & E1000_FWSM_MODE_MASK)\n\t\t\t? true : false;\n\t \n\tif (mac->type >= e1000_i350)\n\t\tdev_spec->eee_disable = false;\n\telse\n\t\tdev_spec->eee_disable = true;\n\t \n\tif (mac->type >= e1000_i210)\n\t\tdev_spec->clear_semaphore_once = true;\n\t \n\tmac->ops.setup_physical_interface =\n\t\t(hw->phy.media_type == e1000_media_type_copper)\n\t\t\t? igb_setup_copper_link_82575\n\t\t\t: igb_setup_serdes_link_82575;\n\n\tif (mac->type == e1000_82580 || mac->type == e1000_i350) {\n\t\tswitch (hw->device_id) {\n\t\t \n\t\tcase E1000_DEV_ID_DH89XXCC_SGMII:\n\t\tcase E1000_DEV_ID_DH89XXCC_SERDES:\n\t\tcase E1000_DEV_ID_DH89XXCC_BACKPLANE:\n\t\tcase E1000_DEV_ID_DH89XXCC_SFP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thw->dev_spec._82575.mas_capable = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic s32 igb_set_sfp_media_type_82575(struct e1000_hw *hw)\n{\n\ts32 ret_val = E1000_ERR_CONFIG;\n\tu32 ctrl_ext = 0;\n\tstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\n\tstruct e1000_sfp_flags *eth_flags = &dev_spec->eth_flags;\n\tu8 tranceiver_type = 0;\n\ts32 timeout = 3;\n\n\t \n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\tctrl_ext &= ~E1000_CTRL_EXT_SDP3_DATA;\n\twr32(E1000_CTRL_EXT, ctrl_ext | E1000_CTRL_I2C_ENA);\n\n\twrfl();\n\n\t \n\twhile (timeout) {\n\t\tret_val = igb_read_sfp_data_byte(hw,\n\t\t\tE1000_I2CCMD_SFP_DATA_ADDR(E1000_SFF_IDENTIFIER_OFFSET),\n\t\t\t&tranceiver_type);\n\t\tif (ret_val == 0)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t\ttimeout--;\n\t}\n\tif (ret_val != 0)\n\t\tgoto out;\n\n\tret_val = igb_read_sfp_data_byte(hw,\n\t\t\tE1000_I2CCMD_SFP_DATA_ADDR(E1000_SFF_ETH_FLAGS_OFFSET),\n\t\t\t(u8 *)eth_flags);\n\tif (ret_val != 0)\n\t\tgoto out;\n\n\t \n\tif ((tranceiver_type == E1000_SFF_IDENTIFIER_SFP) ||\n\t    (tranceiver_type == E1000_SFF_IDENTIFIER_SFF)) {\n\t\tdev_spec->module_plugged = true;\n\t\tif (eth_flags->e1000_base_lx || eth_flags->e1000_base_sx) {\n\t\t\thw->phy.media_type = e1000_media_type_internal_serdes;\n\t\t} else if (eth_flags->e100_base_fx || eth_flags->e100_base_lx) {\n\t\t\tdev_spec->sgmii_active = true;\n\t\t\thw->phy.media_type = e1000_media_type_internal_serdes;\n\t\t} else if (eth_flags->e1000_base_t) {\n\t\t\tdev_spec->sgmii_active = true;\n\t\t\thw->phy.media_type = e1000_media_type_copper;\n\t\t} else {\n\t\t\thw->phy.media_type = e1000_media_type_unknown;\n\t\t\thw_dbg(\"PHY module has not been recognized\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\thw->phy.media_type = e1000_media_type_unknown;\n\t}\n\tret_val = 0;\nout:\n\t \n\twr32(E1000_CTRL_EXT, ctrl_ext);\n\treturn ret_val;\n}\n\nstatic s32 igb_get_invariants_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\n\ts32 ret_val;\n\tu32 ctrl_ext = 0;\n\tu32 link_mode = 0;\n\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82575EB_COPPER:\n\tcase E1000_DEV_ID_82575EB_FIBER_SERDES:\n\tcase E1000_DEV_ID_82575GB_QUAD_COPPER:\n\t\tmac->type = e1000_82575;\n\t\tbreak;\n\tcase E1000_DEV_ID_82576:\n\tcase E1000_DEV_ID_82576_NS:\n\tcase E1000_DEV_ID_82576_NS_SERDES:\n\tcase E1000_DEV_ID_82576_FIBER:\n\tcase E1000_DEV_ID_82576_SERDES:\n\tcase E1000_DEV_ID_82576_QUAD_COPPER:\n\tcase E1000_DEV_ID_82576_QUAD_COPPER_ET2:\n\tcase E1000_DEV_ID_82576_SERDES_QUAD:\n\t\tmac->type = e1000_82576;\n\t\tbreak;\n\tcase E1000_DEV_ID_82580_COPPER:\n\tcase E1000_DEV_ID_82580_FIBER:\n\tcase E1000_DEV_ID_82580_QUAD_FIBER:\n\tcase E1000_DEV_ID_82580_SERDES:\n\tcase E1000_DEV_ID_82580_SGMII:\n\tcase E1000_DEV_ID_82580_COPPER_DUAL:\n\tcase E1000_DEV_ID_DH89XXCC_SGMII:\n\tcase E1000_DEV_ID_DH89XXCC_SERDES:\n\tcase E1000_DEV_ID_DH89XXCC_BACKPLANE:\n\tcase E1000_DEV_ID_DH89XXCC_SFP:\n\t\tmac->type = e1000_82580;\n\t\tbreak;\n\tcase E1000_DEV_ID_I350_COPPER:\n\tcase E1000_DEV_ID_I350_FIBER:\n\tcase E1000_DEV_ID_I350_SERDES:\n\tcase E1000_DEV_ID_I350_SGMII:\n\t\tmac->type = e1000_i350;\n\t\tbreak;\n\tcase E1000_DEV_ID_I210_COPPER:\n\tcase E1000_DEV_ID_I210_FIBER:\n\tcase E1000_DEV_ID_I210_SERDES:\n\tcase E1000_DEV_ID_I210_SGMII:\n\tcase E1000_DEV_ID_I210_COPPER_FLASHLESS:\n\tcase E1000_DEV_ID_I210_SERDES_FLASHLESS:\n\t\tmac->type = e1000_i210;\n\t\tbreak;\n\tcase E1000_DEV_ID_I211_COPPER:\n\t\tmac->type = e1000_i211;\n\t\tbreak;\n\tcase E1000_DEV_ID_I354_BACKPLANE_1GBPS:\n\tcase E1000_DEV_ID_I354_SGMII:\n\tcase E1000_DEV_ID_I354_BACKPLANE_2_5GBPS:\n\t\tmac->type = e1000_i354;\n\t\tbreak;\n\tdefault:\n\t\treturn -E1000_ERR_MAC_INIT;\n\t}\n\n\t \n\t \n\thw->phy.media_type = e1000_media_type_copper;\n\tdev_spec->sgmii_active = false;\n\tdev_spec->module_plugged = false;\n\n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\n\tlink_mode = ctrl_ext & E1000_CTRL_EXT_LINK_MODE_MASK;\n\tswitch (link_mode) {\n\tcase E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:\n\t\thw->phy.media_type = e1000_media_type_internal_serdes;\n\t\tbreak;\n\tcase E1000_CTRL_EXT_LINK_MODE_SGMII:\n\t\t \n\t\tif (igb_sgmii_uses_mdio_82575(hw)) {\n\t\t\thw->phy.media_type = e1000_media_type_copper;\n\t\t\tdev_spec->sgmii_active = true;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;  \n\tcase E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES:\n\t\t \n\t\tret_val = igb_set_sfp_media_type_82575(hw);\n\t\tif ((ret_val != 0) ||\n\t\t    (hw->phy.media_type == e1000_media_type_unknown)) {\n\t\t\t \n\t\t\thw->phy.media_type = e1000_media_type_internal_serdes;\n\n\t\t\tif (link_mode == E1000_CTRL_EXT_LINK_MODE_SGMII) {\n\t\t\t\thw->phy.media_type = e1000_media_type_copper;\n\t\t\t\tdev_spec->sgmii_active = true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tctrl_ext &= ~E1000_CTRL_EXT_LINK_MODE_MASK;\n\n\t\tif (dev_spec->sgmii_active)\n\t\t\tctrl_ext |= E1000_CTRL_EXT_LINK_MODE_SGMII;\n\t\telse\n\t\t\tctrl_ext |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;\n\n\t\twr32(E1000_CTRL_EXT, ctrl_ext);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret_val = igb_init_mac_params_82575(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tret_val = igb_init_nvm_params_82575(hw);\n\tswitch (hw->mac.type) {\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tret_val = igb_init_nvm_params_i210(hw);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret_val)\n\t\tgoto out;\n\n\t \n\tswitch (mac->type) {\n\tcase e1000_82576:\n\tcase e1000_i350:\n\t\tigb_init_mbx_params_pf(hw);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret_val = igb_init_phy_params_82575(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_acquire_phy_82575(struct e1000_hw *hw)\n{\n\tu16 mask = E1000_SWFW_PHY0_SM;\n\n\tif (hw->bus.func == E1000_FUNC_1)\n\t\tmask = E1000_SWFW_PHY1_SM;\n\telse if (hw->bus.func == E1000_FUNC_2)\n\t\tmask = E1000_SWFW_PHY2_SM;\n\telse if (hw->bus.func == E1000_FUNC_3)\n\t\tmask = E1000_SWFW_PHY3_SM;\n\n\treturn hw->mac.ops.acquire_swfw_sync(hw, mask);\n}\n\n \nstatic void igb_release_phy_82575(struct e1000_hw *hw)\n{\n\tu16 mask = E1000_SWFW_PHY0_SM;\n\n\tif (hw->bus.func == E1000_FUNC_1)\n\t\tmask = E1000_SWFW_PHY1_SM;\n\telse if (hw->bus.func == E1000_FUNC_2)\n\t\tmask = E1000_SWFW_PHY2_SM;\n\telse if (hw->bus.func == E1000_FUNC_3)\n\t\tmask = E1000_SWFW_PHY3_SM;\n\n\thw->mac.ops.release_swfw_sync(hw, mask);\n}\n\n \nstatic s32 igb_read_phy_reg_sgmii_82575(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t  u16 *data)\n{\n\ts32 ret_val = -E1000_ERR_PARAM;\n\n\tif (offset > E1000_MAX_SGMII_PHY_REG_ADDR) {\n\t\thw_dbg(\"PHY Address %u is out of range\\n\", offset);\n\t\tgoto out;\n\t}\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_read_phy_reg_i2c(hw, offset, data);\n\n\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_write_phy_reg_sgmii_82575(struct e1000_hw *hw, u32 offset,\n\t\t\t\t\t   u16 data)\n{\n\ts32 ret_val = -E1000_ERR_PARAM;\n\n\n\tif (offset > E1000_MAX_SGMII_PHY_REG_ADDR) {\n\t\thw_dbg(\"PHY Address %d is out of range\\n\", offset);\n\t\tgoto out;\n\t}\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_write_phy_reg_i2c(hw, offset, data);\n\n\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_get_phy_id_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32  ret_val = 0;\n\tu16 phy_id;\n\tu32 ctrl_ext;\n\tu32 mdic;\n\n\t \n\tif (hw->mac.type == e1000_i354)\n\t\tigb_get_phy_id(hw);\n\n\t \n\tif (!(igb_sgmii_active_82575(hw))) {\n\t\tphy->addr = 1;\n\t\tret_val = igb_get_phy_id(hw);\n\t\tgoto out;\n\t}\n\n\tif (igb_sgmii_uses_mdio_82575(hw)) {\n\t\tswitch (hw->mac.type) {\n\t\tcase e1000_82575:\n\t\tcase e1000_82576:\n\t\t\tmdic = rd32(E1000_MDIC);\n\t\t\tmdic &= E1000_MDIC_PHY_MASK;\n\t\t\tphy->addr = mdic >> E1000_MDIC_PHY_SHIFT;\n\t\t\tbreak;\n\t\tcase e1000_82580:\n\t\tcase e1000_i350:\n\t\tcase e1000_i354:\n\t\tcase e1000_i210:\n\t\tcase e1000_i211:\n\t\t\tmdic = rd32(E1000_MDICNFG);\n\t\t\tmdic &= E1000_MDICNFG_PHY_MASK;\n\t\t\tphy->addr = mdic >> E1000_MDICNFG_PHY_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\t\tgoto out;\n\t\t}\n\t\tret_val = igb_get_phy_id(hw);\n\t\tgoto out;\n\t}\n\n\t \n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\twr32(E1000_CTRL_EXT, ctrl_ext & ~E1000_CTRL_EXT_SDP3_DATA);\n\twrfl();\n\tmsleep(300);\n\n\t \n\tfor (phy->addr = 1; phy->addr < 8; phy->addr++) {\n\t\tret_val = igb_read_phy_reg_sgmii_82575(hw, PHY_ID1, &phy_id);\n\t\tif (ret_val == 0) {\n\t\t\thw_dbg(\"Vendor ID 0x%08X read at address %u\\n\",\n\t\t\t       phy_id, phy->addr);\n\t\t\t \n\t\t\tif (phy_id == M88_VENDOR)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\thw_dbg(\"PHY address %u was unreadable\\n\", phy->addr);\n\t\t}\n\t}\n\n\t \n\tif (phy->addr == 8) {\n\t\tphy->addr = 0;\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t} else {\n\t\tret_val = igb_get_phy_id(hw);\n\t}\n\n\t \n\twr32(E1000_CTRL_EXT, ctrl_ext);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_phy_hw_reset_sgmii_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\n\t \n\n\thw_dbg(\"Soft resetting SGMII attached PHY...\\n\");\n\n\t \n\tret_val = hw->phy.ops.write_reg(hw, 0x1B, 0x8084);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_phy_sw_reset(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (phy->id == M88E1512_E_PHY_ID)\n\t\tret_val = igb_initialize_M88E1512_phy(hw);\n\tif (phy->id == M88E1543_E_PHY_ID)\n\t\tret_val = igb_initialize_M88E1543_phy(hw);\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_set_d0_lplu_state_82575(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = phy->ops.read_reg(hw, IGP02E1000_PHY_POWER_MGMT, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (active) {\n\t\tdata |= IGP02E1000_PM_D0_LPLU;\n\t\tret_val = phy->ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,\n\t\t\t\t\t\t data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t&data);\n\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\tret_val = phy->ops.write_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\t data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t} else {\n\t\tdata &= ~IGP02E1000_PM_D0_LPLU;\n\t\tret_val = phy->ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,\n\t\t\t\t\t\t data);\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on) {\n\t\t\tret_val = phy->ops.read_reg(hw,\n\t\t\t\t\tIGP01E1000_PHY_PORT_CONFIG, &data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tdata |= IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\tIGP01E1000_PHY_PORT_CONFIG, data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t} else if (phy->smart_speed == e1000_smart_speed_off) {\n\t\t\tret_val = phy->ops.read_reg(hw,\n\t\t\t\t\tIGP01E1000_PHY_PORT_CONFIG, &data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\n\t\t\tdata &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val = phy->ops.write_reg(hw,\n\t\t\t\t\tIGP01E1000_PHY_PORT_CONFIG, data);\n\t\t\tif (ret_val)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_set_d0_lplu_state_82580(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu16 data;\n\n\tdata = rd32(E1000_82580_PHY_POWER_MGMT);\n\n\tif (active) {\n\t\tdata |= E1000_82580_PM_D0_LPLU;\n\n\t\t \n\t\tdata &= ~E1000_82580_PM_SPD;\n\t} else {\n\t\tdata &= ~E1000_82580_PM_D0_LPLU;\n\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on)\n\t\t\tdata |= E1000_82580_PM_SPD;\n\t\telse if (phy->smart_speed == e1000_smart_speed_off)\n\t\t\tdata &= ~E1000_82580_PM_SPD; }\n\n\twr32(E1000_82580_PHY_POWER_MGMT, data);\n\treturn 0;\n}\n\n \nstatic s32 igb_set_d3_lplu_state_82580(struct e1000_hw *hw, bool active)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tu16 data;\n\n\tdata = rd32(E1000_82580_PHY_POWER_MGMT);\n\n\tif (!active) {\n\t\tdata &= ~E1000_82580_PM_D3_LPLU;\n\t\t \n\t\tif (phy->smart_speed == e1000_smart_speed_on)\n\t\t\tdata |= E1000_82580_PM_SPD;\n\t\telse if (phy->smart_speed == e1000_smart_speed_off)\n\t\t\tdata &= ~E1000_82580_PM_SPD;\n\t} else if ((phy->autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_NOT_GIG) ||\n\t\t   (phy->autoneg_advertised == E1000_ALL_10_SPEED)) {\n\t\tdata |= E1000_82580_PM_D3_LPLU;\n\t\t \n\t\tdata &= ~E1000_82580_PM_SPD;\n\t}\n\n\twr32(E1000_82580_PHY_POWER_MGMT, data);\n\treturn 0;\n}\n\n \nstatic s32 igb_acquire_nvm_82575(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tret_val = hw->mac.ops.acquire_swfw_sync(hw, E1000_SWFW_EEP_SM);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_acquire_nvm(hw);\n\n\tif (ret_val)\n\t\thw->mac.ops.release_swfw_sync(hw, E1000_SWFW_EEP_SM);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic void igb_release_nvm_82575(struct e1000_hw *hw)\n{\n\tigb_release_nvm(hw);\n\thw->mac.ops.release_swfw_sync(hw, E1000_SWFW_EEP_SM);\n}\n\n \nstatic s32 igb_acquire_swfw_sync_82575(struct e1000_hw *hw, u16 mask)\n{\n\tu32 swfw_sync;\n\tu32 swmask = mask;\n\tu32 fwmask = mask << 16;\n\ts32 ret_val = 0;\n\ts32 i = 0, timeout = 200;\n\n\twhile (i < timeout) {\n\t\tif (igb_get_hw_semaphore(hw)) {\n\t\t\tret_val = -E1000_ERR_SWFW_SYNC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswfw_sync = rd32(E1000_SW_FW_SYNC);\n\t\tif (!(swfw_sync & (fwmask | swmask)))\n\t\t\tbreak;\n\n\t\t \n\t\tigb_put_hw_semaphore(hw);\n\t\tmdelay(5);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\thw_dbg(\"Driver can't access resource, SW_FW_SYNC timeout.\\n\");\n\t\tret_val = -E1000_ERR_SWFW_SYNC;\n\t\tgoto out;\n\t}\n\n\tswfw_sync |= swmask;\n\twr32(E1000_SW_FW_SYNC, swfw_sync);\n\n\tigb_put_hw_semaphore(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic void igb_release_swfw_sync_82575(struct e1000_hw *hw, u16 mask)\n{\n\tu32 swfw_sync;\n\n\twhile (igb_get_hw_semaphore(hw) != 0)\n\t\t;  \n\n\tswfw_sync = rd32(E1000_SW_FW_SYNC);\n\tswfw_sync &= ~mask;\n\twr32(E1000_SW_FW_SYNC, swfw_sync);\n\n\tigb_put_hw_semaphore(hw);\n}\n\n \nstatic s32 igb_get_cfg_done_82575(struct e1000_hw *hw)\n{\n\ts32 timeout = PHY_CFG_TIMEOUT;\n\tu32 mask = E1000_NVM_CFG_DONE_PORT_0;\n\n\tif (hw->bus.func == 1)\n\t\tmask = E1000_NVM_CFG_DONE_PORT_1;\n\telse if (hw->bus.func == E1000_FUNC_2)\n\t\tmask = E1000_NVM_CFG_DONE_PORT_2;\n\telse if (hw->bus.func == E1000_FUNC_3)\n\t\tmask = E1000_NVM_CFG_DONE_PORT_3;\n\n\twhile (timeout) {\n\t\tif (rd32(E1000_EEMNGCTL) & mask)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\ttimeout--;\n\t}\n\tif (!timeout)\n\t\thw_dbg(\"MNG configuration cycle has not completed.\\n\");\n\n\t \n\tif (((rd32(E1000_EECD) & E1000_EECD_PRES) == 0) &&\n\t    (hw->phy.type == e1000_phy_igp_3))\n\t\tigb_phy_init_script_igp3(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 igb_get_link_up_info_82575(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t\tu16 *duplex)\n{\n\ts32 ret_val;\n\n\tif (hw->phy.media_type != e1000_media_type_copper)\n\t\tret_val = igb_get_pcs_speed_and_duplex_82575(hw, speed,\n\t\t\t\t\t\t\t       duplex);\n\telse\n\t\tret_val = igb_get_speed_and_duplex_copper(hw, speed,\n\t\t\t\t\t\t\t\t    duplex);\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_check_for_link_82575(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 speed, duplex;\n\n\tif (hw->phy.media_type != e1000_media_type_copper) {\n\t\tret_val = igb_get_pcs_speed_and_duplex_82575(hw, &speed,\n\t\t\t\t\t\t\t     &duplex);\n\t\t \n\t\thw->mac.get_link_status = !hw->mac.serdes_has_link;\n\n\t\t \n\t\tret_val = igb_config_fc_after_link_up(hw);\n\t\tif (ret_val)\n\t\t\thw_dbg(\"Error configuring flow control\\n\");\n\t} else {\n\t\tret_val = igb_check_for_copper_link(hw);\n\t}\n\n\treturn ret_val;\n}\n\n \nvoid igb_power_up_serdes_link_82575(struct e1000_hw *hw)\n{\n\tu32 reg;\n\n\n\tif ((hw->phy.media_type != e1000_media_type_internal_serdes) &&\n\t    !igb_sgmii_active_82575(hw))\n\t\treturn;\n\n\t \n\treg = rd32(E1000_PCS_CFG0);\n\treg |= E1000_PCS_CFG_PCS_EN;\n\twr32(E1000_PCS_CFG0, reg);\n\n\t \n\treg = rd32(E1000_CTRL_EXT);\n\treg &= ~E1000_CTRL_EXT_SDP3_DATA;\n\twr32(E1000_CTRL_EXT, reg);\n\n\t \n\twrfl();\n\tusleep_range(1000, 2000);\n}\n\n \nstatic s32 igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t\t\tu16 *duplex)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 pcs, status;\n\n\t \n\tmac->serdes_has_link = false;\n\t*speed = 0;\n\t*duplex = 0;\n\n\t \n\tpcs = rd32(E1000_PCS_LSTAT);\n\n\t \n\tif ((pcs & E1000_PCS_LSTS_LINK_OK) && (pcs & E1000_PCS_LSTS_SYNK_OK)) {\n\t\tmac->serdes_has_link = true;\n\n\t\t \n\t\tif (pcs & E1000_PCS_LSTS_SPEED_1000)\n\t\t\t*speed = SPEED_1000;\n\t\telse if (pcs & E1000_PCS_LSTS_SPEED_100)\n\t\t\t*speed = SPEED_100;\n\t\telse\n\t\t\t*speed = SPEED_10;\n\n\t\t \n\t\tif (pcs & E1000_PCS_LSTS_DUPLEX_FULL)\n\t\t\t*duplex = FULL_DUPLEX;\n\t\telse\n\t\t\t*duplex = HALF_DUPLEX;\n\n\t \n\t\tif (mac->type == e1000_i354) {\n\t\t\tstatus = rd32(E1000_STATUS);\n\t\t\tif ((status & E1000_STATUS_2P5_SKU) &&\n\t\t\t    !(status & E1000_STATUS_2P5_SKU_OVER)) {\n\t\t\t\t*speed = SPEED_2500;\n\t\t\t\t*duplex = FULL_DUPLEX;\n\t\t\t\thw_dbg(\"2500 Mbs, \");\n\t\t\t\thw_dbg(\"Full Duplex\\n\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n \nvoid igb_shutdown_serdes_link_82575(struct e1000_hw *hw)\n{\n\tu32 reg;\n\n\tif (hw->phy.media_type != e1000_media_type_internal_serdes &&\n\t    igb_sgmii_active_82575(hw))\n\t\treturn;\n\n\tif (!igb_enable_mng_pass_thru(hw)) {\n\t\t \n\t\treg = rd32(E1000_PCS_CFG0);\n\t\treg &= ~E1000_PCS_CFG_PCS_EN;\n\t\twr32(E1000_PCS_CFG0, reg);\n\n\t\t \n\t\treg = rd32(E1000_CTRL_EXT);\n\t\treg |= E1000_CTRL_EXT_SDP3_DATA;\n\t\twr32(E1000_CTRL_EXT, reg);\n\n\t\t \n\t\twrfl();\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\n \nstatic s32 igb_reset_hw_82575(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\n\t \n\tret_val = igb_disable_pcie_master(hw);\n\tif (ret_val)\n\t\thw_dbg(\"PCI-E Master disable polling has failed.\\n\");\n\n\t \n\tret_val = igb_set_pcie_completion_timeout(hw);\n\tif (ret_val)\n\t\thw_dbg(\"PCI-E Set completion timeout has failed.\\n\");\n\n\thw_dbg(\"Masking off all interrupts\\n\");\n\twr32(E1000_IMC, 0xffffffff);\n\n\twr32(E1000_RCTL, 0);\n\twr32(E1000_TCTL, E1000_TCTL_PSP);\n\twrfl();\n\n\tusleep_range(10000, 20000);\n\n\tctrl = rd32(E1000_CTRL);\n\n\thw_dbg(\"Issuing a global reset to MAC\\n\");\n\twr32(E1000_CTRL, ctrl | E1000_CTRL_RST);\n\n\tret_val = igb_get_auto_rd_done(hw);\n\tif (ret_val) {\n\t\t \n\t\thw_dbg(\"Auto Read Done did not complete\\n\");\n\t}\n\n\t \n\tif ((rd32(E1000_EECD) & E1000_EECD_PRES) == 0)\n\t\tigb_reset_init_script_82575(hw);\n\n\t \n\twr32(E1000_IMC, 0xffffffff);\n\trd32(E1000_ICR);\n\n\t \n\tret_val = igb_check_alt_mac_addr(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_init_hw_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val;\n\tu16 i, rar_count = mac->rar_entry_count;\n\n\tif ((hw->mac.type >= e1000_i210) &&\n\t    !(igb_get_flash_presence_i210(hw))) {\n\t\tret_val = igb_pll_workaround_i210(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tret_val = igb_id_led_init(hw);\n\tif (ret_val) {\n\t\thw_dbg(\"Error initializing identification LED\\n\");\n\t\t \n\t}\n\n\t \n\thw_dbg(\"Initializing the IEEE VLAN\\n\");\n\tigb_clear_vfta(hw);\n\n\t \n\tigb_init_rx_addrs(hw, rar_count);\n\n\t \n\thw_dbg(\"Zeroing the MTA\\n\");\n\tfor (i = 0; i < mac->mta_reg_count; i++)\n\t\tarray_wr32(E1000_MTA, i, 0);\n\n\t \n\thw_dbg(\"Zeroing the UTA\\n\");\n\tfor (i = 0; i < mac->uta_reg_count; i++)\n\t\tarray_wr32(E1000_UTA, i, 0);\n\n\t \n\tret_val = igb_setup_link(hw);\n\n\t \n\tigb_clear_hw_cntrs_82575(hw);\n\treturn ret_val;\n}\n\n \nstatic s32 igb_setup_copper_link_82575(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32  ret_val;\n\tu32 phpm_reg;\n\n\tctrl = rd32(E1000_CTRL);\n\tctrl |= E1000_CTRL_SLU;\n\tctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\twr32(E1000_CTRL, ctrl);\n\n\t \n\tswitch (hw->mac.type) {\n\tcase e1000_82580:\n\tcase e1000_i350:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tphpm_reg = rd32(E1000_82580_PHY_POWER_MGMT);\n\t\tphpm_reg &= ~E1000_82580_PM_GO_LINKD;\n\t\twr32(E1000_82580_PHY_POWER_MGMT, phpm_reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret_val = igb_setup_serdes_link_82575(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (igb_sgmii_active_82575(hw) && !hw->phy.reset_disable) {\n\t\t \n\t\tmsleep(300);\n\n\t\tret_val = hw->phy.ops.reset(hw);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"Error resetting the PHY.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tswitch (hw->phy.type) {\n\tcase e1000_phy_i210:\n\tcase e1000_phy_m88:\n\t\tswitch (hw->phy.id) {\n\t\tcase I347AT4_E_PHY_ID:\n\t\tcase M88E1112_E_PHY_ID:\n\t\tcase M88E1543_E_PHY_ID:\n\t\tcase M88E1512_E_PHY_ID:\n\t\tcase I210_I_PHY_ID:\n\t\t\tret_val = igb_copper_link_setup_m88_gen2(hw);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = igb_copper_link_setup_m88(hw);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase e1000_phy_igp_3:\n\t\tret_val = igb_copper_link_setup_igp(hw);\n\t\tbreak;\n\tcase e1000_phy_82580:\n\t\tret_val = igb_copper_link_setup_82580(hw);\n\t\tbreak;\n\tcase e1000_phy_bcm54616:\n\t\tret_val = 0;\n\t\tbreak;\n\tdefault:\n\t\tret_val = -E1000_ERR_PHY;\n\t\tbreak;\n\t}\n\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_setup_copper_link(hw);\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_setup_serdes_link_82575(struct e1000_hw *hw)\n{\n\tu32 ctrl_ext, ctrl_reg, reg, anadv_reg;\n\tbool pcs_autoneg;\n\ts32 ret_val = 0;\n\tu16 data;\n\n\tif ((hw->phy.media_type != e1000_media_type_internal_serdes) &&\n\t    !igb_sgmii_active_82575(hw))\n\t\treturn ret_val;\n\n\n\t \n\twr32(E1000_SCTL, E1000_SCTL_DISABLE_SERDES_LOOPBACK);\n\n\t \n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\tctrl_ext &= ~E1000_CTRL_EXT_SDP3_DATA;\n\tctrl_ext |= E1000_CTRL_I2C_ENA;\n\twr32(E1000_CTRL_EXT, ctrl_ext);\n\n\tctrl_reg = rd32(E1000_CTRL);\n\tctrl_reg |= E1000_CTRL_SLU;\n\n\tif (hw->mac.type == e1000_82575 || hw->mac.type == e1000_82576) {\n\t\t \n\t\tctrl_reg |= E1000_CTRL_SWDPIN0 | E1000_CTRL_SWDPIN1;\n\n\t\t \n\t\treg = rd32(E1000_CONNSW);\n\t\treg |= E1000_CONNSW_ENRGSRC;\n\t\twr32(E1000_CONNSW, reg);\n\t}\n\n\treg = rd32(E1000_PCS_LCTL);\n\n\t \n\tpcs_autoneg = hw->mac.autoneg;\n\n\tswitch (ctrl_ext & E1000_CTRL_EXT_LINK_MODE_MASK) {\n\tcase E1000_CTRL_EXT_LINK_MODE_SGMII:\n\t\t \n\t\tpcs_autoneg = true;\n\t\t \n\t\treg &= ~(E1000_PCS_LCTL_AN_TIMEOUT);\n\t\tbreak;\n\tcase E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:\n\t\t \n\t\tpcs_autoneg = false;\n\t\tfallthrough;\n\tdefault:\n\t\tif (hw->mac.type == e1000_82575 ||\n\t\t    hw->mac.type == e1000_82576) {\n\t\t\tret_val = hw->nvm.ops.read(hw, NVM_COMPAT, 1, &data);\n\t\t\tif (ret_val) {\n\t\t\t\thw_dbg(KERN_DEBUG \"NVM Read Error\\n\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\n\t\t\tif (data & E1000_EEPROM_PCS_AUTONEG_DISABLE_BIT)\n\t\t\t\tpcs_autoneg = false;\n\t\t}\n\n\t\t \n\t\tctrl_reg |= E1000_CTRL_SPD_1000 | E1000_CTRL_FRCSPD |\n\t\t\t\tE1000_CTRL_FD | E1000_CTRL_FRCDPX;\n\n\t\t \n\t\treg |= E1000_PCS_LCTL_FSV_1000 | E1000_PCS_LCTL_FDV_FULL;\n\t\tbreak;\n\t}\n\n\twr32(E1000_CTRL, ctrl_reg);\n\n\t \n\treg &= ~(E1000_PCS_LCTL_AN_ENABLE | E1000_PCS_LCTL_FLV_LINK_UP |\n\t\tE1000_PCS_LCTL_FSD | E1000_PCS_LCTL_FORCE_LINK);\n\n\tif (pcs_autoneg) {\n\t\t \n\t\treg |= E1000_PCS_LCTL_AN_ENABLE |  \n\t\t       E1000_PCS_LCTL_AN_RESTART;  \n\n\t\t \n\t\treg &= ~E1000_PCS_LCTL_FORCE_FCTRL;\n\n\t\t \n\t\tanadv_reg = rd32(E1000_PCS_ANADV);\n\t\tanadv_reg &= ~(E1000_TXCW_ASM_DIR | E1000_TXCW_PAUSE);\n\t\tswitch (hw->fc.requested_mode) {\n\t\tcase e1000_fc_full:\n\t\tcase e1000_fc_rx_pause:\n\t\t\tanadv_reg |= E1000_TXCW_ASM_DIR;\n\t\t\tanadv_reg |= E1000_TXCW_PAUSE;\n\t\t\tbreak;\n\t\tcase e1000_fc_tx_pause:\n\t\t\tanadv_reg |= E1000_TXCW_ASM_DIR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\twr32(E1000_PCS_ANADV, anadv_reg);\n\n\t\thw_dbg(\"Configuring Autoneg:PCS_LCTL=0x%08X\\n\", reg);\n\t} else {\n\t\t \n\t\treg |= E1000_PCS_LCTL_FSD;         \n\n\t\t \n\t\treg |= E1000_PCS_LCTL_FORCE_FCTRL;\n\n\t\thw_dbg(\"Configuring Forced Link:PCS_LCTL=0x%08X\\n\", reg);\n\t}\n\n\twr32(E1000_PCS_LCTL, reg);\n\n\tif (!pcs_autoneg && !igb_sgmii_active_82575(hw))\n\t\tigb_force_mac_fc(hw);\n\n\treturn ret_val;\n}\n\n \nstatic bool igb_sgmii_active_82575(struct e1000_hw *hw)\n{\n\tstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\n\treturn dev_spec->sgmii_active;\n}\n\n \nstatic s32 igb_reset_init_script_82575(struct e1000_hw *hw)\n{\n\tif (hw->mac.type == e1000_82575) {\n\t\thw_dbg(\"Running reset init script for 82575\\n\");\n\t\t \n\t\tigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x00, 0x0C);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x01, 0x78);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x1B, 0x23);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x23, 0x15);\n\n\t\t \n\t\tigb_write_8bit_ctrl_reg(hw, E1000_CCMCTL, 0x14, 0x00);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_CCMCTL, 0x10, 0x00);\n\n\t\t \n\t\tigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x00, 0xEC);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x61, 0xDF);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x34, 0x05);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x2F, 0x81);\n\n\t\t \n\t\tigb_write_8bit_ctrl_reg(hw, E1000_SCCTL, 0x02, 0x47);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_SCCTL, 0x14, 0x00);\n\t\tigb_write_8bit_ctrl_reg(hw, E1000_SCCTL, 0x10, 0x00);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 igb_read_mac_addr_82575(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\t \n\tret_val = igb_check_alt_mac_addr(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_read_mac_addr(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nvoid igb_power_down_phy_copper_82575(struct e1000_hw *hw)\n{\n\t \n\tif (!(igb_enable_mng_pass_thru(hw) || igb_check_reset_block(hw)))\n\t\tigb_power_down_phy_copper(hw);\n}\n\n \nstatic void igb_clear_hw_cntrs_82575(struct e1000_hw *hw)\n{\n\tigb_clear_hw_cntrs_base(hw);\n\n\trd32(E1000_PRC64);\n\trd32(E1000_PRC127);\n\trd32(E1000_PRC255);\n\trd32(E1000_PRC511);\n\trd32(E1000_PRC1023);\n\trd32(E1000_PRC1522);\n\trd32(E1000_PTC64);\n\trd32(E1000_PTC127);\n\trd32(E1000_PTC255);\n\trd32(E1000_PTC511);\n\trd32(E1000_PTC1023);\n\trd32(E1000_PTC1522);\n\n\trd32(E1000_ALGNERRC);\n\trd32(E1000_RXERRC);\n\trd32(E1000_TNCRS);\n\trd32(E1000_CEXTERR);\n\trd32(E1000_TSCTC);\n\trd32(E1000_TSCTFC);\n\n\trd32(E1000_MGTPRC);\n\trd32(E1000_MGTPDC);\n\trd32(E1000_MGTPTC);\n\n\trd32(E1000_IAC);\n\trd32(E1000_ICRXOC);\n\n\trd32(E1000_ICRXPTC);\n\trd32(E1000_ICRXATC);\n\trd32(E1000_ICTXPTC);\n\trd32(E1000_ICTXATC);\n\trd32(E1000_ICTXQEC);\n\trd32(E1000_ICTXQMTC);\n\trd32(E1000_ICRXDMTC);\n\n\trd32(E1000_CBTMPC);\n\trd32(E1000_HTDPMC);\n\trd32(E1000_CBRMPC);\n\trd32(E1000_RPTHC);\n\trd32(E1000_HGPTC);\n\trd32(E1000_HTCBDPC);\n\trd32(E1000_HGORCL);\n\trd32(E1000_HGORCH);\n\trd32(E1000_HGOTCL);\n\trd32(E1000_HGOTCH);\n\trd32(E1000_LENERRS);\n\n\t \n\tif (hw->phy.media_type == e1000_media_type_internal_serdes ||\n\t    igb_sgmii_active_82575(hw))\n\t\trd32(E1000_SCVPC);\n}\n\n \nvoid igb_rx_fifo_flush_82575(struct e1000_hw *hw)\n{\n\tu32 rctl, rlpml, rxdctl[4], rfctl, temp_rctl, rx_enabled;\n\tint i, ms_wait;\n\n\t \n\trfctl = rd32(E1000_RFCTL);\n\trfctl |= E1000_RFCTL_IPV6_EX_DIS;\n\twr32(E1000_RFCTL, rfctl);\n\n\tif (hw->mac.type != e1000_82575 ||\n\t    !(rd32(E1000_MANC) & E1000_MANC_RCV_TCO_EN))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\trxdctl[i] = rd32(E1000_RXDCTL(i));\n\t\twr32(E1000_RXDCTL(i),\n\t\t     rxdctl[i] & ~E1000_RXDCTL_QUEUE_ENABLE);\n\t}\n\t \n\tfor (ms_wait = 0; ms_wait < 10; ms_wait++) {\n\t\tusleep_range(1000, 2000);\n\t\trx_enabled = 0;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\trx_enabled |= rd32(E1000_RXDCTL(i));\n\t\tif (!(rx_enabled & E1000_RXDCTL_QUEUE_ENABLE))\n\t\t\tbreak;\n\t}\n\n\tif (ms_wait == 10)\n\t\thw_dbg(\"Queue disable timed out after 10ms\\n\");\n\n\t \n\twr32(E1000_RFCTL, rfctl & ~E1000_RFCTL_LEF);\n\n\trlpml = rd32(E1000_RLPML);\n\twr32(E1000_RLPML, 0);\n\n\trctl = rd32(E1000_RCTL);\n\ttemp_rctl = rctl & ~(E1000_RCTL_EN | E1000_RCTL_SBP);\n\ttemp_rctl |= E1000_RCTL_LPE;\n\n\twr32(E1000_RCTL, temp_rctl);\n\twr32(E1000_RCTL, temp_rctl | E1000_RCTL_EN);\n\twrfl();\n\tusleep_range(2000, 3000);\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\twr32(E1000_RXDCTL(i), rxdctl[i]);\n\twr32(E1000_RCTL, rctl);\n\twrfl();\n\n\twr32(E1000_RLPML, rlpml);\n\twr32(E1000_RFCTL, rfctl);\n\n\t \n\trd32(E1000_ROC);\n\trd32(E1000_RNBC);\n\trd32(E1000_MPC);\n}\n\n \nstatic s32 igb_set_pcie_completion_timeout(struct e1000_hw *hw)\n{\n\tu32 gcr = rd32(E1000_GCR);\n\ts32 ret_val = 0;\n\tu16 pcie_devctl2;\n\n\t \n\tif (gcr & E1000_GCR_CMPL_TMOUT_MASK)\n\t\tgoto out;\n\n\t \n\tif (!(gcr & E1000_GCR_CAP_VER2)) {\n\t\tgcr |= E1000_GCR_CMPL_TMOUT_10ms;\n\t\tgoto out;\n\t}\n\n\t \n\tret_val = igb_read_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,\n\t\t\t\t\t&pcie_devctl2);\n\tif (ret_val)\n\t\tgoto out;\n\n\tpcie_devctl2 |= PCIE_DEVICE_CONTROL2_16ms;\n\n\tret_val = igb_write_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,\n\t\t\t\t\t &pcie_devctl2);\nout:\n\t \n\tgcr &= ~E1000_GCR_CMPL_TMOUT_RESEND;\n\n\twr32(E1000_GCR, gcr);\n\treturn ret_val;\n}\n\n \nvoid igb_vmdq_set_anti_spoofing_pf(struct e1000_hw *hw, bool enable, int pf)\n{\n\tu32 reg_val, reg_offset;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82576:\n\t\treg_offset = E1000_DTXSWC;\n\t\tbreak;\n\tcase e1000_i350:\n\tcase e1000_i354:\n\t\treg_offset = E1000_TXSWC;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\treg_val = rd32(reg_offset);\n\tif (enable) {\n\t\treg_val |= (E1000_DTXSWC_MAC_SPOOF_MASK |\n\t\t\t     E1000_DTXSWC_VLAN_SPOOF_MASK);\n\t\t \n\t\treg_val ^= (BIT(pf) | BIT(pf + MAX_NUM_VFS));\n\t} else {\n\t\treg_val &= ~(E1000_DTXSWC_MAC_SPOOF_MASK |\n\t\t\t     E1000_DTXSWC_VLAN_SPOOF_MASK);\n\t}\n\twr32(reg_offset, reg_val);\n}\n\n \nvoid igb_vmdq_set_loopback_pf(struct e1000_hw *hw, bool enable)\n{\n\tu32 dtxswc;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82576:\n\t\tdtxswc = rd32(E1000_DTXSWC);\n\t\tif (enable)\n\t\t\tdtxswc |= E1000_DTXSWC_VMDQ_LOOPBACK_EN;\n\t\telse\n\t\t\tdtxswc &= ~E1000_DTXSWC_VMDQ_LOOPBACK_EN;\n\t\twr32(E1000_DTXSWC, dtxswc);\n\t\tbreak;\n\tcase e1000_i354:\n\tcase e1000_i350:\n\t\tdtxswc = rd32(E1000_TXSWC);\n\t\tif (enable)\n\t\t\tdtxswc |= E1000_DTXSWC_VMDQ_LOOPBACK_EN;\n\t\telse\n\t\t\tdtxswc &= ~E1000_DTXSWC_VMDQ_LOOPBACK_EN;\n\t\twr32(E1000_TXSWC, dtxswc);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n}\n\n \nvoid igb_vmdq_set_replication_pf(struct e1000_hw *hw, bool enable)\n{\n\tu32 vt_ctl = rd32(E1000_VT_CTL);\n\n\tif (enable)\n\t\tvt_ctl |= E1000_VT_CTL_VM_REPL_EN;\n\telse\n\t\tvt_ctl &= ~E1000_VT_CTL_VM_REPL_EN;\n\n\twr32(E1000_VT_CTL, vt_ctl);\n}\n\n \ns32 igb_read_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\ts32 ret_val;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_read_phy_reg_mdic(hw, offset, data);\n\n\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_write_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\ts32 ret_val;\n\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = igb_write_phy_reg_mdic(hw, offset, data);\n\n\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_reset_mdicnfg_82580(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu32 mdicnfg;\n\tu16 nvm_data = 0;\n\n\tif (hw->mac.type != e1000_82580)\n\t\tgoto out;\n\tif (!igb_sgmii_active_82575(hw))\n\t\tgoto out;\n\n\tret_val = hw->nvm.ops.read(hw, NVM_INIT_CONTROL3_PORT_A +\n\t\t\t\t   NVM_82580_LAN_FUNC_OFFSET(hw->bus.func), 1,\n\t\t\t\t   &nvm_data);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tmdicnfg = rd32(E1000_MDICNFG);\n\tif (nvm_data & NVM_WORD24_EXT_MDIO)\n\t\tmdicnfg |= E1000_MDICNFG_EXT_MDIO;\n\tif (nvm_data & NVM_WORD24_COM_MDIO)\n\t\tmdicnfg |= E1000_MDICNFG_COM_MDIO;\n\twr32(E1000_MDICNFG, mdicnfg);\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_reset_hw_82580(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\t \n\tu16 swmbsw_mask = E1000_SW_SYNCH_MB;\n\tu32 ctrl;\n\tbool global_device_reset = hw->dev_spec._82575.global_device_reset;\n\n\thw->dev_spec._82575.global_device_reset = false;\n\n\t \n\tif (hw->mac.type == e1000_82580)\n\t\tglobal_device_reset = false;\n\n\t \n\tctrl = rd32(E1000_CTRL);\n\n\t \n\tret_val = igb_disable_pcie_master(hw);\n\tif (ret_val)\n\t\thw_dbg(\"PCI-E Master disable polling has failed.\\n\");\n\n\thw_dbg(\"Masking off all interrupts\\n\");\n\twr32(E1000_IMC, 0xffffffff);\n\twr32(E1000_RCTL, 0);\n\twr32(E1000_TCTL, E1000_TCTL_PSP);\n\twrfl();\n\n\tusleep_range(10000, 11000);\n\n\t \n\tif (global_device_reset &&\n\t\thw->mac.ops.acquire_swfw_sync(hw, swmbsw_mask))\n\t\t\tglobal_device_reset = false;\n\n\tif (global_device_reset &&\n\t\t!(rd32(E1000_STATUS) & E1000_STAT_DEV_RST_SET))\n\t\tctrl |= E1000_CTRL_DEV_RST;\n\telse\n\t\tctrl |= E1000_CTRL_RST;\n\n\twr32(E1000_CTRL, ctrl);\n\twrfl();\n\n\t \n\tif (global_device_reset)\n\t\tusleep_range(5000, 6000);\n\n\tret_val = igb_get_auto_rd_done(hw);\n\tif (ret_val) {\n\t\t \n\t\thw_dbg(\"Auto Read Done did not complete\\n\");\n\t}\n\n\t \n\twr32(E1000_STATUS, E1000_STAT_DEV_RST_SET);\n\n\t \n\twr32(E1000_IMC, 0xffffffff);\n\trd32(E1000_ICR);\n\n\tret_val = igb_reset_mdicnfg_82580(hw);\n\tif (ret_val)\n\t\thw_dbg(\"Could not reset MDICNFG based on EEPROM\\n\");\n\n\t \n\tret_val = igb_check_alt_mac_addr(hw);\n\n\t \n\tif (global_device_reset)\n\t\thw->mac.ops.release_swfw_sync(hw, swmbsw_mask);\n\n\treturn ret_val;\n}\n\n \nu16 igb_rxpbs_adjust_82580(u32 data)\n{\n\tu16 ret_val = 0;\n\n\tif (data < ARRAY_SIZE(e1000_82580_rxpbs_table))\n\t\tret_val = e1000_82580_rxpbs_table[data];\n\n\treturn ret_val;\n}\n\n \nstatic s32 igb_validate_nvm_checksum_with_offset(struct e1000_hw *hw,\n\t\t\t\t\t\t u16 offset)\n{\n\ts32 ret_val = 0;\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\n\tfor (i = offset; i < ((NVM_CHECKSUM_REG + offset) + 1); i++) {\n\t\tret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\n\tif (checksum != (u16) NVM_SUM) {\n\t\thw_dbg(\"NVM Checksum Invalid\\n\");\n\t\tret_val = -E1000_ERR_NVM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_update_nvm_checksum_with_offset(struct e1000_hw *hw, u16 offset)\n{\n\ts32 ret_val;\n\tu16 checksum = 0;\n\tu16 i, nvm_data;\n\n\tfor (i = offset; i < (NVM_CHECKSUM_REG + offset); i++) {\n\t\tret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Read Error while updating checksum.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tchecksum += nvm_data;\n\t}\n\tchecksum = (u16) NVM_SUM - checksum;\n\tret_val = hw->nvm.ops.write(hw, (NVM_CHECKSUM_REG + offset), 1,\n\t\t\t\t&checksum);\n\tif (ret_val)\n\t\thw_dbg(\"NVM Write Error while updating checksum.\\n\");\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_validate_nvm_checksum_82580(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 eeprom_regions_count = 1;\n\tu16 j, nvm_data;\n\tu16 nvm_offset;\n\n\tret_val = hw->nvm.ops.read(hw, NVM_COMPATIBILITY_REG_3, 1, &nvm_data);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (nvm_data & NVM_COMPATIBILITY_BIT_MASK) {\n\t\t \n\t\teeprom_regions_count = 4;\n\t}\n\n\tfor (j = 0; j < eeprom_regions_count; j++) {\n\t\tnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\n\t\tret_val = igb_validate_nvm_checksum_with_offset(hw,\n\t\t\t\t\t\t\t\tnvm_offset);\n\t\tif (ret_val != 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_update_nvm_checksum_82580(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 j, nvm_data;\n\tu16 nvm_offset;\n\n\tret_val = hw->nvm.ops.read(hw, NVM_COMPATIBILITY_REG_3, 1, &nvm_data);\n\tif (ret_val) {\n\t\thw_dbg(\"NVM Read Error while updating checksum compatibility bit.\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((nvm_data & NVM_COMPATIBILITY_BIT_MASK) == 0) {\n\t\t \n\t\tnvm_data = nvm_data | NVM_COMPATIBILITY_BIT_MASK;\n\t\tret_val = hw->nvm.ops.write(hw, NVM_COMPATIBILITY_REG_3, 1,\n\t\t\t\t\t&nvm_data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(\"NVM Write Error while updating checksum compatibility bit.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (j = 0; j < 4; j++) {\n\t\tnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\n\t\tret_val = igb_update_nvm_checksum_with_offset(hw, nvm_offset);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_validate_nvm_checksum_i350(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 j;\n\tu16 nvm_offset;\n\n\tfor (j = 0; j < 4; j++) {\n\t\tnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\n\t\tret_val = igb_validate_nvm_checksum_with_offset(hw,\n\t\t\t\t\t\t\t\tnvm_offset);\n\t\tif (ret_val != 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 igb_update_nvm_checksum_i350(struct e1000_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu16 j;\n\tu16 nvm_offset;\n\n\tfor (j = 0; j < 4; j++) {\n\t\tnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\n\t\tret_val = igb_update_nvm_checksum_with_offset(hw, nvm_offset);\n\t\tif (ret_val != 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 __igb_access_emi_reg(struct e1000_hw *hw, u16 address,\n\t\t\t\t  u16 *data, bool read)\n{\n\ts32 ret_val = 0;\n\n\tret_val = hw->phy.ops.write_reg(hw, E1000_EMIADD, address);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (read)\n\t\tret_val = hw->phy.ops.read_reg(hw, E1000_EMIDATA, data);\n\telse\n\t\tret_val = hw->phy.ops.write_reg(hw, E1000_EMIDATA, *data);\n\n\treturn ret_val;\n}\n\n \ns32 igb_read_emi_reg(struct e1000_hw *hw, u16 addr, u16 *data)\n{\n\treturn __igb_access_emi_reg(hw, addr, data, true);\n}\n\n \ns32 igb_set_eee_i350(struct e1000_hw *hw, bool adv1G, bool adv100M)\n{\n\tu32 ipcnfg, eeer;\n\n\tif ((hw->mac.type < e1000_i350) ||\n\t    (hw->phy.media_type != e1000_media_type_copper))\n\t\tgoto out;\n\tipcnfg = rd32(E1000_IPCNFG);\n\teeer = rd32(E1000_EEER);\n\n\t \n\tif (!(hw->dev_spec._82575.eee_disable)) {\n\t\tu32 eee_su = rd32(E1000_EEE_SU);\n\n\t\tif (adv100M)\n\t\t\tipcnfg |= E1000_IPCNFG_EEE_100M_AN;\n\t\telse\n\t\t\tipcnfg &= ~E1000_IPCNFG_EEE_100M_AN;\n\n\t\tif (adv1G)\n\t\t\tipcnfg |= E1000_IPCNFG_EEE_1G_AN;\n\t\telse\n\t\t\tipcnfg &= ~E1000_IPCNFG_EEE_1G_AN;\n\n\t\teeer |= (E1000_EEER_TX_LPI_EN | E1000_EEER_RX_LPI_EN |\n\t\t\tE1000_EEER_LPI_FC);\n\n\t\t \n\t\tif (eee_su & E1000_EEE_SU_LPI_CLK_STP)\n\t\t\thw_dbg(\"LPI Clock Stop Bit should not be set!\\n\");\n\n\t} else {\n\t\tipcnfg &= ~(E1000_IPCNFG_EEE_1G_AN |\n\t\t\tE1000_IPCNFG_EEE_100M_AN);\n\t\teeer &= ~(E1000_EEER_TX_LPI_EN |\n\t\t\tE1000_EEER_RX_LPI_EN |\n\t\t\tE1000_EEER_LPI_FC);\n\t}\n\twr32(E1000_IPCNFG, ipcnfg);\n\twr32(E1000_EEER, eeer);\n\trd32(E1000_IPCNFG);\n\trd32(E1000_EEER);\nout:\n\n\treturn 0;\n}\n\n \ns32 igb_set_eee_i354(struct e1000_hw *hw, bool adv1G, bool adv100M)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu16 phy_data;\n\n\tif ((hw->phy.media_type != e1000_media_type_copper) ||\n\t    ((phy->id != M88E1543_E_PHY_ID) &&\n\t     (phy->id != M88E1512_E_PHY_ID)))\n\t\tgoto out;\n\n\tif (!hw->dev_spec._82575.eee_disable) {\n\t\t \n\t\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 18);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tret_val = phy->ops.read_reg(hw, E1000_M88E1543_EEE_CTRL_1,\n\t\t\t\t\t    &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy_data |= E1000_M88E1543_EEE_CTRL_1_MS;\n\t\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_EEE_CTRL_1,\n\t\t\t\t\t     phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\t \n\t\tret_val = igb_read_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\n\t\t\t\t\t     E1000_EEE_ADV_DEV_I354,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (adv100M)\n\t\t\tphy_data |= E1000_EEE_ADV_100_SUPPORTED;\n\t\telse\n\t\t\tphy_data &= ~E1000_EEE_ADV_100_SUPPORTED;\n\n\t\tif (adv1G)\n\t\t\tphy_data |= E1000_EEE_ADV_1000_SUPPORTED;\n\t\telse\n\t\t\tphy_data &= ~E1000_EEE_ADV_1000_SUPPORTED;\n\n\t\tret_val = igb_write_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\n\t\t\t\t\t\tE1000_EEE_ADV_DEV_I354,\n\t\t\t\t\t\tphy_data);\n\t} else {\n\t\t \n\t\tret_val = igb_read_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\n\t\t\t\t\t     E1000_EEE_ADV_DEV_I354,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy_data &= ~(E1000_EEE_ADV_100_SUPPORTED |\n\t\t\t      E1000_EEE_ADV_1000_SUPPORTED);\n\t\tret_val = igb_write_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\n\t\t\t\t\t      E1000_EEE_ADV_DEV_I354,\n\t\t\t\t\t      phy_data);\n\t}\n\nout:\n\treturn ret_val;\n}\n\n \ns32 igb_get_eee_status_i354(struct e1000_hw *hw, bool *status)\n{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = 0;\n\tu16 phy_data;\n\n\t \n\tif ((hw->phy.media_type != e1000_media_type_copper) ||\n\t    ((phy->id != M88E1543_E_PHY_ID) &&\n\t     (phy->id != M88E1512_E_PHY_ID)))\n\t\tgoto out;\n\n\tret_val = igb_read_xmdio_reg(hw, E1000_PCS_STATUS_ADDR_I354,\n\t\t\t\t     E1000_PCS_STATUS_DEV_I354,\n\t\t\t\t     &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t*status = phy_data & (E1000_PCS_STATUS_TX_LPI_RCVD |\n\t\t\t      E1000_PCS_STATUS_RX_LPI_RCVD) ? true : false;\n\nout:\n\treturn ret_val;\n}\n\n#ifdef CONFIG_IGB_HWMON\nstatic const u8 e1000_emc_temp_data[4] = {\n\tE1000_EMC_INTERNAL_DATA,\n\tE1000_EMC_DIODE1_DATA,\n\tE1000_EMC_DIODE2_DATA,\n\tE1000_EMC_DIODE3_DATA\n};\nstatic const u8 e1000_emc_therm_limit[4] = {\n\tE1000_EMC_INTERNAL_THERM_LIMIT,\n\tE1000_EMC_DIODE1_THERM_LIMIT,\n\tE1000_EMC_DIODE2_THERM_LIMIT,\n\tE1000_EMC_DIODE3_THERM_LIMIT\n};\n\n \nstatic s32 igb_get_thermal_sensor_data_generic(struct e1000_hw *hw)\n{\n\tu16 ets_offset;\n\tu16 ets_cfg;\n\tu16 ets_sensor;\n\tu8  num_sensors;\n\tu8  sensor_index;\n\tu8  sensor_location;\n\tu8  i;\n\tstruct e1000_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\n\n\tif ((hw->mac.type != e1000_i350) || (hw->bus.func != 0))\n\t\treturn E1000_NOT_IMPLEMENTED;\n\n\tdata->sensor[0].temp = (rd32(E1000_THMJT) & 0xFF);\n\n\t \n\thw->nvm.ops.read(hw, NVM_ETS_CFG, 1, &ets_offset);\n\tif ((ets_offset == 0x0000) || (ets_offset == 0xFFFF))\n\t\treturn 0;\n\n\thw->nvm.ops.read(hw, ets_offset, 1, &ets_cfg);\n\tif (((ets_cfg & NVM_ETS_TYPE_MASK) >> NVM_ETS_TYPE_SHIFT)\n\t    != NVM_ETS_TYPE_EMC)\n\t\treturn E1000_NOT_IMPLEMENTED;\n\n\tnum_sensors = (ets_cfg & NVM_ETS_NUM_SENSORS_MASK);\n\tif (num_sensors > E1000_MAX_SENSORS)\n\t\tnum_sensors = E1000_MAX_SENSORS;\n\n\tfor (i = 1; i < num_sensors; i++) {\n\t\thw->nvm.ops.read(hw, (ets_offset + i), 1, &ets_sensor);\n\t\tsensor_index = ((ets_sensor & NVM_ETS_DATA_INDEX_MASK) >>\n\t\t\t\tNVM_ETS_DATA_INDEX_SHIFT);\n\t\tsensor_location = ((ets_sensor & NVM_ETS_DATA_LOC_MASK) >>\n\t\t\t\t   NVM_ETS_DATA_LOC_SHIFT);\n\n\t\tif (sensor_location != 0)\n\t\t\thw->phy.ops.read_i2c_byte(hw,\n\t\t\t\t\te1000_emc_temp_data[sensor_index],\n\t\t\t\t\tE1000_I2C_THERMAL_SENSOR_ADDR,\n\t\t\t\t\t&data->sensor[i].temp);\n\t}\n\treturn 0;\n}\n\n \nstatic s32 igb_init_thermal_sensor_thresh_generic(struct e1000_hw *hw)\n{\n\tu16 ets_offset;\n\tu16 ets_cfg;\n\tu16 ets_sensor;\n\tu8  low_thresh_delta;\n\tu8  num_sensors;\n\tu8  sensor_index;\n\tu8  sensor_location;\n\tu8  therm_limit;\n\tu8  i;\n\tstruct e1000_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\n\n\tif ((hw->mac.type != e1000_i350) || (hw->bus.func != 0))\n\t\treturn E1000_NOT_IMPLEMENTED;\n\n\tmemset(data, 0, sizeof(struct e1000_thermal_sensor_data));\n\n\tdata->sensor[0].location = 0x1;\n\tdata->sensor[0].caution_thresh =\n\t\t(rd32(E1000_THHIGHTC) & 0xFF);\n\tdata->sensor[0].max_op_thresh =\n\t\t(rd32(E1000_THLOWTC) & 0xFF);\n\n\t \n\thw->nvm.ops.read(hw, NVM_ETS_CFG, 1, &ets_offset);\n\tif ((ets_offset == 0x0000) || (ets_offset == 0xFFFF))\n\t\treturn 0;\n\n\thw->nvm.ops.read(hw, ets_offset, 1, &ets_cfg);\n\tif (((ets_cfg & NVM_ETS_TYPE_MASK) >> NVM_ETS_TYPE_SHIFT)\n\t    != NVM_ETS_TYPE_EMC)\n\t\treturn E1000_NOT_IMPLEMENTED;\n\n\tlow_thresh_delta = ((ets_cfg & NVM_ETS_LTHRES_DELTA_MASK) >>\n\t\t\t    NVM_ETS_LTHRES_DELTA_SHIFT);\n\tnum_sensors = (ets_cfg & NVM_ETS_NUM_SENSORS_MASK);\n\n\tfor (i = 1; i <= num_sensors; i++) {\n\t\thw->nvm.ops.read(hw, (ets_offset + i), 1, &ets_sensor);\n\t\tsensor_index = ((ets_sensor & NVM_ETS_DATA_INDEX_MASK) >>\n\t\t\t\tNVM_ETS_DATA_INDEX_SHIFT);\n\t\tsensor_location = ((ets_sensor & NVM_ETS_DATA_LOC_MASK) >>\n\t\t\t\t   NVM_ETS_DATA_LOC_SHIFT);\n\t\ttherm_limit = ets_sensor & NVM_ETS_DATA_HTHRESH_MASK;\n\n\t\thw->phy.ops.write_i2c_byte(hw,\n\t\t\te1000_emc_therm_limit[sensor_index],\n\t\t\tE1000_I2C_THERMAL_SENSOR_ADDR,\n\t\t\ttherm_limit);\n\n\t\tif ((i < E1000_MAX_SENSORS) && (sensor_location != 0)) {\n\t\t\tdata->sensor[i].location = sensor_location;\n\t\t\tdata->sensor[i].caution_thresh = therm_limit;\n\t\t\tdata->sensor[i].max_op_thresh = therm_limit -\n\t\t\t\t\t\t\tlow_thresh_delta;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif\nstatic struct e1000_mac_operations e1000_mac_ops_82575 = {\n\t.init_hw              = igb_init_hw_82575,\n\t.check_for_link       = igb_check_for_link_82575,\n\t.rar_set              = igb_rar_set,\n\t.read_mac_addr        = igb_read_mac_addr_82575,\n\t.get_speed_and_duplex = igb_get_link_up_info_82575,\n#ifdef CONFIG_IGB_HWMON\n\t.get_thermal_sensor_data = igb_get_thermal_sensor_data_generic,\n\t.init_thermal_sensor_thresh = igb_init_thermal_sensor_thresh_generic,\n#endif\n};\n\nstatic const struct e1000_phy_operations e1000_phy_ops_82575 = {\n\t.acquire              = igb_acquire_phy_82575,\n\t.get_cfg_done         = igb_get_cfg_done_82575,\n\t.release              = igb_release_phy_82575,\n\t.write_i2c_byte       = igb_write_i2c_byte,\n\t.read_i2c_byte        = igb_read_i2c_byte,\n};\n\nstatic struct e1000_nvm_operations e1000_nvm_ops_82575 = {\n\t.acquire              = igb_acquire_nvm_82575,\n\t.read                 = igb_read_nvm_eerd,\n\t.release              = igb_release_nvm_82575,\n\t.write                = igb_write_nvm_spi,\n};\n\nconst struct e1000_info e1000_82575_info = {\n\t.get_invariants = igb_get_invariants_82575,\n\t.mac_ops = &e1000_mac_ops_82575,\n\t.phy_ops = &e1000_phy_ops_82575,\n\t.nvm_ops = &e1000_nvm_ops_82575,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}