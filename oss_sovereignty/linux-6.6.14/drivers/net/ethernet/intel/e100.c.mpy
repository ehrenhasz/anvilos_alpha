{
  "module_name": "e100.c",
  "hash_id": "8495947d80750e566a1a2d8ee1a5562a43b9f68e11f12f401a54bfa7d8492d4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e100.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hardirq.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/if_vlan.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/string.h>\n#include <linux/firmware.h>\n#include <linux/rtnetlink.h>\n#include <asm/unaligned.h>\n\n\n#define DRV_NAME\t\t\"e100\"\n#define DRV_DESCRIPTION\t\t\"Intel(R) PRO/100 Network Driver\"\n#define DRV_COPYRIGHT\t\t\"Copyright(c) 1999-2006 Intel Corporation\"\n\n#define E100_WATCHDOG_PERIOD\t(2 * HZ)\n#define E100_NAPI_WEIGHT\t16\n\n#define FIRMWARE_D101M\t\t\"e100/d101m_ucode.bin\"\n#define FIRMWARE_D101S\t\t\"e100/d101s_ucode.bin\"\n#define FIRMWARE_D102E\t\t\"e100/d102e_ucode.bin\"\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(FIRMWARE_D101M);\nMODULE_FIRMWARE(FIRMWARE_D101S);\nMODULE_FIRMWARE(FIRMWARE_D102E);\n\nstatic int debug = 3;\nstatic int eeprom_bad_csum_allow = 0;\nstatic int use_io = 0;\nmodule_param(debug, int, 0);\nmodule_param(eeprom_bad_csum_allow, int, 0);\nmodule_param(use_io, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\nMODULE_PARM_DESC(eeprom_bad_csum_allow, \"Allow bad eeprom checksums\");\nMODULE_PARM_DESC(use_io, \"Force use of i/o access mode\");\n\n#define INTEL_8255X_ETHERNET_DEVICE(device_id, ich) {\\\n\tPCI_VENDOR_ID_INTEL, device_id, PCI_ANY_ID, PCI_ANY_ID, \\\n\tPCI_CLASS_NETWORK_ETHERNET << 8, 0xFFFF00, ich }\nstatic const struct pci_device_id e100_id_table[] = {\n\tINTEL_8255X_ETHERNET_DEVICE(0x1029, 0),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1030, 0),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1031, 3),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1032, 3),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1033, 3),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1034, 3),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1038, 3),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1039, 4),\n\tINTEL_8255X_ETHERNET_DEVICE(0x103A, 4),\n\tINTEL_8255X_ETHERNET_DEVICE(0x103B, 4),\n\tINTEL_8255X_ETHERNET_DEVICE(0x103C, 4),\n\tINTEL_8255X_ETHERNET_DEVICE(0x103D, 4),\n\tINTEL_8255X_ETHERNET_DEVICE(0x103E, 4),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1050, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1051, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1052, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1053, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1054, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1055, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1056, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1057, 5),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1059, 0),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1064, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1065, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1066, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1067, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1068, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1069, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x106A, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x106B, 6),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1091, 7),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1092, 7),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1093, 7),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1094, 7),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1095, 7),\n\tINTEL_8255X_ETHERNET_DEVICE(0x10fe, 7),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1209, 0),\n\tINTEL_8255X_ETHERNET_DEVICE(0x1229, 0),\n\tINTEL_8255X_ETHERNET_DEVICE(0x2449, 2),\n\tINTEL_8255X_ETHERNET_DEVICE(0x2459, 2),\n\tINTEL_8255X_ETHERNET_DEVICE(0x245D, 2),\n\tINTEL_8255X_ETHERNET_DEVICE(0x27DC, 7),\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, e100_id_table);\n\nenum mac {\n\tmac_82557_D100_A  = 0,\n\tmac_82557_D100_B  = 1,\n\tmac_82557_D100_C  = 2,\n\tmac_82558_D101_A4 = 4,\n\tmac_82558_D101_B0 = 5,\n\tmac_82559_D101M   = 8,\n\tmac_82559_D101S   = 9,\n\tmac_82550_D102    = 12,\n\tmac_82550_D102_C  = 13,\n\tmac_82551_E       = 14,\n\tmac_82551_F       = 15,\n\tmac_82551_10      = 16,\n\tmac_unknown       = 0xFF,\n};\n\nenum phy {\n\tphy_100a     = 0x000003E0,\n\tphy_100c     = 0x035002A8,\n\tphy_82555_tx = 0x015002A8,\n\tphy_nsc_tx   = 0x5C002000,\n\tphy_82562_et = 0x033002A8,\n\tphy_82562_em = 0x032002A8,\n\tphy_82562_ek = 0x031002A8,\n\tphy_82562_eh = 0x017002A8,\n\tphy_82552_v  = 0xd061004d,\n\tphy_unknown  = 0xFFFFFFFF,\n};\n\n \nstruct csr {\n\tstruct {\n\t\tu8 status;\n\t\tu8 stat_ack;\n\t\tu8 cmd_lo;\n\t\tu8 cmd_hi;\n\t\tu32 gen_ptr;\n\t} scb;\n\tu32 port;\n\tu16 flash_ctrl;\n\tu8 eeprom_ctrl_lo;\n\tu8 eeprom_ctrl_hi;\n\tu32 mdi_ctrl;\n\tu32 rx_dma_count;\n};\n\nenum scb_status {\n\trus_no_res       = 0x08,\n\trus_ready        = 0x10,\n\trus_mask         = 0x3C,\n};\n\nenum ru_state  {\n\tRU_SUSPENDED = 0,\n\tRU_RUNNING\t = 1,\n\tRU_UNINITIALIZED = -1,\n};\n\nenum scb_stat_ack {\n\tstat_ack_not_ours    = 0x00,\n\tstat_ack_sw_gen      = 0x04,\n\tstat_ack_rnr         = 0x10,\n\tstat_ack_cu_idle     = 0x20,\n\tstat_ack_frame_rx    = 0x40,\n\tstat_ack_cu_cmd_done = 0x80,\n\tstat_ack_not_present = 0xFF,\n\tstat_ack_rx = (stat_ack_sw_gen | stat_ack_rnr | stat_ack_frame_rx),\n\tstat_ack_tx = (stat_ack_cu_idle | stat_ack_cu_cmd_done),\n};\n\nenum scb_cmd_hi {\n\tirq_mask_none = 0x00,\n\tirq_mask_all  = 0x01,\n\tirq_sw_gen    = 0x02,\n};\n\nenum scb_cmd_lo {\n\tcuc_nop        = 0x00,\n\truc_start      = 0x01,\n\truc_load_base  = 0x06,\n\tcuc_start      = 0x10,\n\tcuc_resume     = 0x20,\n\tcuc_dump_addr  = 0x40,\n\tcuc_dump_stats = 0x50,\n\tcuc_load_base  = 0x60,\n\tcuc_dump_reset = 0x70,\n};\n\nenum cuc_dump {\n\tcuc_dump_complete       = 0x0000A005,\n\tcuc_dump_reset_complete = 0x0000A007,\n};\n\nenum port {\n\tsoftware_reset  = 0x0000,\n\tselftest        = 0x0001,\n\tselective_reset = 0x0002,\n};\n\nenum eeprom_ctrl_lo {\n\teesk = 0x01,\n\teecs = 0x02,\n\teedi = 0x04,\n\teedo = 0x08,\n};\n\nenum mdi_ctrl {\n\tmdi_write = 0x04000000,\n\tmdi_read  = 0x08000000,\n\tmdi_ready = 0x10000000,\n};\n\nenum eeprom_op {\n\top_write = 0x05,\n\top_read  = 0x06,\n\top_ewds  = 0x10,\n\top_ewen  = 0x13,\n};\n\nenum eeprom_offsets {\n\teeprom_cnfg_mdix  = 0x03,\n\teeprom_phy_iface  = 0x06,\n\teeprom_id         = 0x0A,\n\teeprom_config_asf = 0x0D,\n\teeprom_smbus_addr = 0x90,\n};\n\nenum eeprom_cnfg_mdix {\n\teeprom_mdix_enabled = 0x0080,\n};\n\nenum eeprom_phy_iface {\n\tNoSuchPhy = 0,\n\tI82553AB,\n\tI82553C,\n\tI82503,\n\tDP83840,\n\tS80C240,\n\tS80C24,\n\tI82555,\n\tDP83840A = 10,\n};\n\nenum eeprom_id {\n\teeprom_id_wol = 0x0020,\n};\n\nenum eeprom_config_asf {\n\teeprom_asf = 0x8000,\n\teeprom_gcl = 0x4000,\n};\n\nenum cb_status {\n\tcb_complete = 0x8000,\n\tcb_ok       = 0x2000,\n};\n\n \nenum cb_command {\n\tcb_nop    = 0x0000,\n\tcb_iaaddr = 0x0001,\n\tcb_config = 0x0002,\n\tcb_multi  = 0x0003,\n\tcb_tx     = 0x0004,\n\tcb_ucode  = 0x0005,\n\tcb_dump   = 0x0006,\n\tcb_tx_sf  = 0x0008,\n\tcb_tx_nc  = 0x0010,\n\tcb_cid    = 0x1f00,\n\tcb_i      = 0x2000,\n\tcb_s      = 0x4000,\n\tcb_el     = 0x8000,\n};\n\nstruct rfd {\n\t__le16 status;\n\t__le16 command;\n\t__le32 link;\n\t__le32 rbd;\n\t__le16 actual_size;\n\t__le16 size;\n};\n\nstruct rx {\n\tstruct rx *next, *prev;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n};\n\n#if defined(__BIG_ENDIAN_BITFIELD)\n#define X(a,b)\tb,a\n#else\n#define X(a,b)\ta,b\n#endif\nstruct config {\n \tu8 X(byte_count:6, pad0:2);\n \tu8 X(X(rx_fifo_limit:4, tx_fifo_limit:3), pad1:1);\n \tu8 adaptive_ifs;\n \tu8 X(X(X(X(mwi_enable:1, type_enable:1), read_align_enable:1),\n\t   term_write_cache_line:1), pad3:4);\n \tu8 X(rx_dma_max_count:7, pad4:1);\n \tu8 X(tx_dma_max_count:7, dma_max_count_enable:1);\n \tu8 X(X(X(X(X(X(X(late_scb_update:1, direct_rx_dma:1),\n\t   tno_intr:1), cna_intr:1), standard_tcb:1), standard_stat_counter:1),\n\t   rx_save_overruns : 1), rx_save_bad_frames : 1);\n \tu8 X(X(X(X(X(rx_discard_short_frames:1, tx_underrun_retry:2),\n\t   pad7:2), rx_extended_rfd:1), tx_two_frames_in_fifo:1),\n\t   tx_dynamic_tbd:1);\n \tu8 X(X(mii_mode:1, pad8:6), csma_disabled:1);\n \tu8 X(X(X(X(X(rx_tcpudp_checksum:1, pad9:3), vlan_arp_tco:1),\n\t   link_status_wake:1), arp_wake:1), mcmatch_wake:1);\n \tu8 X(X(X(pad10:3, no_source_addr_insertion:1), preamble_length:2),\n\t   loopback:2);\n \tu8 X(linear_priority:3, pad11:5);\n \tu8 X(X(linear_priority_mode:1, pad12:3), ifs:4);\n \tu8 ip_addr_lo;\n \tu8 ip_addr_hi;\n \tu8 X(X(X(X(X(X(X(promiscuous_mode:1, broadcast_disabled:1),\n\t   wait_after_win:1), pad15_1:1), ignore_ul_bit:1), crc_16_bit:1),\n\t   pad15_2:1), crs_or_cdt:1);\n \tu8 fc_delay_lo;\n \tu8 fc_delay_hi;\n \tu8 X(X(X(X(X(rx_stripping:1, tx_padding:1), rx_crc_transfer:1),\n\t   rx_long_ok:1), fc_priority_threshold:3), pad18:1);\n \tu8 X(X(X(X(X(X(X(addr_wake:1, magic_packet_disable:1),\n\t   fc_disable:1), fc_restop:1), fc_restart:1), fc_reject:1),\n\t   full_duplex_force:1), full_duplex_pin:1);\n \tu8 X(X(X(pad20_1:5, fc_priority_location:1), multi_ia:1), pad20_2:1);\n \tu8 X(X(pad21_1:3, multicast_all:1), pad21_2:4);\n \tu8 X(X(rx_d102_mode:1, rx_vlan_drop:1), pad22:6);\n\tu8 pad_d102[9];\n};\n\n#define E100_MAX_MULTICAST_ADDRS\t64\nstruct multi {\n\t__le16 count;\n\tu8 addr[E100_MAX_MULTICAST_ADDRS * ETH_ALEN + 2 ];\n};\n\n \n#define UCODE_SIZE\t\t\t134\nstruct cb {\n\t__le16 status;\n\t__le16 command;\n\t__le32 link;\n\tunion {\n\t\tu8 iaaddr[ETH_ALEN];\n\t\t__le32 ucode[UCODE_SIZE];\n\t\tstruct config config;\n\t\tstruct multi multi;\n\t\tstruct {\n\t\t\tu32 tbd_array;\n\t\t\tu16 tcb_byte_count;\n\t\t\tu8 threshold;\n\t\t\tu8 tbd_count;\n\t\t\tstruct {\n\t\t\t\t__le32 buf_addr;\n\t\t\t\t__le16 size;\n\t\t\t\tu16 eol;\n\t\t\t} tbd;\n\t\t} tcb;\n\t\t__le32 dump_buffer_addr;\n\t} u;\n\tstruct cb *next, *prev;\n\tdma_addr_t dma_addr;\n\tstruct sk_buff *skb;\n};\n\nenum loopback {\n\tlb_none = 0, lb_mac = 1, lb_phy = 3,\n};\n\nstruct stats {\n\t__le32 tx_good_frames, tx_max_collisions, tx_late_collisions,\n\t\ttx_underruns, tx_lost_crs, tx_deferred, tx_single_collisions,\n\t\ttx_multiple_collisions, tx_total_collisions;\n\t__le32 rx_good_frames, rx_crc_errors, rx_alignment_errors,\n\t\trx_resource_errors, rx_overrun_errors, rx_cdt_errors,\n\t\trx_short_frame_errors;\n\t__le32 fc_xmt_pause, fc_rcv_pause, fc_rcv_unsupported;\n\t__le16 xmt_tco_frames, rcv_tco_frames;\n\t__le32 complete;\n};\n\nstruct mem {\n\tstruct {\n\t\tu32 signature;\n\t\tu32 result;\n\t} selftest;\n\tstruct stats stats;\n\tu8 dump_buf[596];\n};\n\nstruct param_range {\n\tu32 min;\n\tu32 max;\n\tu32 count;\n};\n\nstruct params {\n\tstruct param_range rfds;\n\tstruct param_range cbs;\n};\n\nstruct nic {\n\t \n\tu32 msg_enable\t\t\t\t____cacheline_aligned;\n\tstruct net_device *netdev;\n\tstruct pci_dev *pdev;\n\tu16 (*mdio_ctrl)(struct nic *nic, u32 addr, u32 dir, u32 reg, u16 data);\n\n\tstruct rx *rxs\t\t\t\t____cacheline_aligned;\n\tstruct rx *rx_to_use;\n\tstruct rx *rx_to_clean;\n\tstruct rfd blank_rfd;\n\tenum ru_state ru_running;\n\n\tspinlock_t cb_lock\t\t\t____cacheline_aligned;\n\tspinlock_t cmd_lock;\n\tstruct csr __iomem *csr;\n\tenum scb_cmd_lo cuc_cmd;\n\tunsigned int cbs_avail;\n\tstruct napi_struct napi;\n\tstruct cb *cbs;\n\tstruct cb *cb_to_use;\n\tstruct cb *cb_to_send;\n\tstruct cb *cb_to_clean;\n\t__le16 tx_command;\n\t \n\n\tenum {\n\t\tich                = (1 << 0),\n\t\tpromiscuous        = (1 << 1),\n\t\tmulticast_all      = (1 << 2),\n\t\twol_magic          = (1 << 3),\n\t\tich_10h_workaround = (1 << 4),\n\t} flags\t\t\t\t\t____cacheline_aligned;\n\n\tenum mac mac;\n\tenum phy phy;\n\tstruct params params;\n\tstruct timer_list watchdog;\n\tstruct mii_if_info mii;\n\tstruct work_struct tx_timeout_task;\n\tenum loopback loopback;\n\n\tstruct mem *mem;\n\tdma_addr_t dma_addr;\n\n\tstruct dma_pool *cbs_pool;\n\tdma_addr_t cbs_dma_addr;\n\tu8 adaptive_ifs;\n\tu8 tx_threshold;\n\tu32 tx_frames;\n\tu32 tx_collisions;\n\tu32 tx_deferred;\n\tu32 tx_single_collisions;\n\tu32 tx_multiple_collisions;\n\tu32 tx_fc_pause;\n\tu32 tx_tco_frames;\n\n\tu32 rx_fc_pause;\n\tu32 rx_fc_unsupported;\n\tu32 rx_tco_frames;\n\tu32 rx_short_frame_errors;\n\tu32 rx_over_length_errors;\n\n\tu16 eeprom_wc;\n\t__le16 eeprom[256];\n\tspinlock_t mdio_lock;\n\tconst struct firmware *fw;\n};\n\nstatic inline void e100_write_flush(struct nic *nic)\n{\n\t \n\t(void)ioread8(&nic->csr->scb.status);\n}\n\nstatic void e100_enable_irq(struct nic *nic)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&nic->cmd_lock, flags);\n\tiowrite8(irq_mask_none, &nic->csr->scb.cmd_hi);\n\te100_write_flush(nic);\n\tspin_unlock_irqrestore(&nic->cmd_lock, flags);\n}\n\nstatic void e100_disable_irq(struct nic *nic)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&nic->cmd_lock, flags);\n\tiowrite8(irq_mask_all, &nic->csr->scb.cmd_hi);\n\te100_write_flush(nic);\n\tspin_unlock_irqrestore(&nic->cmd_lock, flags);\n}\n\nstatic void e100_hw_reset(struct nic *nic)\n{\n\t \n\tiowrite32(selective_reset, &nic->csr->port);\n\te100_write_flush(nic); udelay(20);\n\n\t \n\tiowrite32(software_reset, &nic->csr->port);\n\te100_write_flush(nic); udelay(20);\n\n\t \n\te100_disable_irq(nic);\n}\n\nstatic int e100_self_test(struct nic *nic)\n{\n\tu32 dma_addr = nic->dma_addr + offsetof(struct mem, selftest);\n\n\t \n\n\tnic->mem->selftest.signature = 0;\n\tnic->mem->selftest.result = 0xFFFFFFFF;\n\n\tiowrite32(selftest | dma_addr, &nic->csr->port);\n\te100_write_flush(nic);\n\t \n\tmsleep(10);\n\n\t \n\te100_disable_irq(nic);\n\n\t \n\tif (nic->mem->selftest.result != 0) {\n\t\tnetif_err(nic, hw, nic->netdev,\n\t\t\t  \"Self-test failed: result=0x%08X\\n\",\n\t\t\t  nic->mem->selftest.result);\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (nic->mem->selftest.signature == 0) {\n\t\tnetif_err(nic, hw, nic->netdev, \"Self-test failed: timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void e100_eeprom_write(struct nic *nic, u16 addr_len, u16 addr, __le16 data)\n{\n\tu32 cmd_addr_data[3];\n\tu8 ctrl;\n\tint i, j;\n\n\t \n\tcmd_addr_data[0] = op_ewen << (addr_len - 2);\n\tcmd_addr_data[1] = (((op_write << addr_len) | addr) << 16) |\n\t\tle16_to_cpu(data);\n\tcmd_addr_data[2] = op_ewds << (addr_len - 2);\n\n\t \n\tfor (j = 0; j < 3; j++) {\n\n\t\t \n\t\tiowrite8(eecs | eesk, &nic->csr->eeprom_ctrl_lo);\n\t\te100_write_flush(nic); udelay(4);\n\n\t\tfor (i = 31; i >= 0; i--) {\n\t\t\tctrl = (cmd_addr_data[j] & (1 << i)) ?\n\t\t\t\teecs | eedi : eecs;\n\t\t\tiowrite8(ctrl, &nic->csr->eeprom_ctrl_lo);\n\t\t\te100_write_flush(nic); udelay(4);\n\n\t\t\tiowrite8(ctrl | eesk, &nic->csr->eeprom_ctrl_lo);\n\t\t\te100_write_flush(nic); udelay(4);\n\t\t}\n\t\t \n\t\tmsleep(10);\n\n\t\t \n\t\tiowrite8(0, &nic->csr->eeprom_ctrl_lo);\n\t\te100_write_flush(nic); udelay(4);\n\t}\n};\n\n \nstatic __le16 e100_eeprom_read(struct nic *nic, u16 *addr_len, u16 addr)\n{\n\tu32 cmd_addr_data;\n\tu16 data = 0;\n\tu8 ctrl;\n\tint i;\n\n\tcmd_addr_data = ((op_read << *addr_len) | addr) << 16;\n\n\t \n\tiowrite8(eecs | eesk, &nic->csr->eeprom_ctrl_lo);\n\te100_write_flush(nic); udelay(4);\n\n\t \n\tfor (i = 31; i >= 0; i--) {\n\t\tctrl = (cmd_addr_data & (1 << i)) ? eecs | eedi : eecs;\n\t\tiowrite8(ctrl, &nic->csr->eeprom_ctrl_lo);\n\t\te100_write_flush(nic); udelay(4);\n\n\t\tiowrite8(ctrl | eesk, &nic->csr->eeprom_ctrl_lo);\n\t\te100_write_flush(nic); udelay(4);\n\n\t\t \n\t\tctrl = ioread8(&nic->csr->eeprom_ctrl_lo);\n\t\tif (!(ctrl & eedo) && i > 16) {\n\t\t\t*addr_len -= (i - 16);\n\t\t\ti = 17;\n\t\t}\n\n\t\tdata = (data << 1) | (ctrl & eedo ? 1 : 0);\n\t}\n\n\t \n\tiowrite8(0, &nic->csr->eeprom_ctrl_lo);\n\te100_write_flush(nic); udelay(4);\n\n\treturn cpu_to_le16(data);\n};\n\n \nstatic int e100_eeprom_load(struct nic *nic)\n{\n\tu16 addr, addr_len = 8, checksum = 0;\n\n\t \n\te100_eeprom_read(nic, &addr_len, 0);\n\tnic->eeprom_wc = 1 << addr_len;\n\n\tfor (addr = 0; addr < nic->eeprom_wc; addr++) {\n\t\tnic->eeprom[addr] = e100_eeprom_read(nic, &addr_len, addr);\n\t\tif (addr < nic->eeprom_wc - 1)\n\t\t\tchecksum += le16_to_cpu(nic->eeprom[addr]);\n\t}\n\n\t \n\tif (cpu_to_le16(0xBABA - checksum) != nic->eeprom[nic->eeprom_wc - 1]) {\n\t\tnetif_err(nic, probe, nic->netdev, \"EEPROM corrupted\\n\");\n\t\tif (!eeprom_bad_csum_allow)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int e100_eeprom_save(struct nic *nic, u16 start, u16 count)\n{\n\tu16 addr, addr_len = 8, checksum = 0;\n\n\t \n\te100_eeprom_read(nic, &addr_len, 0);\n\tnic->eeprom_wc = 1 << addr_len;\n\n\tif (start + count >= nic->eeprom_wc)\n\t\treturn -EINVAL;\n\n\tfor (addr = start; addr < start + count; addr++)\n\t\te100_eeprom_write(nic, addr_len, addr, nic->eeprom[addr]);\n\n\t \n\tfor (addr = 0; addr < nic->eeprom_wc - 1; addr++)\n\t\tchecksum += le16_to_cpu(nic->eeprom[addr]);\n\tnic->eeprom[nic->eeprom_wc - 1] = cpu_to_le16(0xBABA - checksum);\n\te100_eeprom_write(nic, addr_len, nic->eeprom_wc - 1,\n\t\tnic->eeprom[nic->eeprom_wc - 1]);\n\n\treturn 0;\n}\n\n#define E100_WAIT_SCB_TIMEOUT 20000  \n#define E100_WAIT_SCB_FAST 20        \nstatic int e100_exec_cmd(struct nic *nic, u8 cmd, dma_addr_t dma_addr)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\tint err = 0;\n\n\tspin_lock_irqsave(&nic->cmd_lock, flags);\n\n\t \n\tfor (i = 0; i < E100_WAIT_SCB_TIMEOUT; i++) {\n\t\tif (likely(!ioread8(&nic->csr->scb.cmd_lo)))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t\tif (unlikely(i > E100_WAIT_SCB_FAST))\n\t\t\tudelay(5);\n\t}\n\tif (unlikely(i == E100_WAIT_SCB_TIMEOUT)) {\n\t\terr = -EAGAIN;\n\t\tgoto err_unlock;\n\t}\n\n\tif (unlikely(cmd != cuc_resume))\n\t\tiowrite32(dma_addr, &nic->csr->scb.gen_ptr);\n\tiowrite8(cmd, &nic->csr->scb.cmd_lo);\n\nerr_unlock:\n\tspin_unlock_irqrestore(&nic->cmd_lock, flags);\n\n\treturn err;\n}\n\nstatic int e100_exec_cb(struct nic *nic, struct sk_buff *skb,\n\tint (*cb_prepare)(struct nic *, struct cb *, struct sk_buff *))\n{\n\tstruct cb *cb;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&nic->cb_lock, flags);\n\n\tif (unlikely(!nic->cbs_avail)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tcb = nic->cb_to_use;\n\tnic->cb_to_use = cb->next;\n\tnic->cbs_avail--;\n\tcb->skb = skb;\n\n\terr = cb_prepare(nic, cb, skb);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tif (unlikely(!nic->cbs_avail))\n\t\terr = -ENOSPC;\n\n\n\t \n\tcb->command |= cpu_to_le16(cb_s);\n\tdma_wmb();\n\tcb->prev->command &= cpu_to_le16(~cb_s);\n\n\twhile (nic->cb_to_send != nic->cb_to_use) {\n\t\tif (unlikely(e100_exec_cmd(nic, nic->cuc_cmd,\n\t\t\tnic->cb_to_send->dma_addr))) {\n\t\t\t \n\t\t\tif (err == -ENOSPC) {\n\t\t\t\t\n\t\t\t\tschedule_work(&nic->tx_timeout_task);\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnic->cuc_cmd = cuc_resume;\n\t\t\tnic->cb_to_send = nic->cb_to_send->next;\n\t\t}\n\t}\n\nerr_unlock:\n\tspin_unlock_irqrestore(&nic->cb_lock, flags);\n\n\treturn err;\n}\n\nstatic int mdio_read(struct net_device *netdev, int addr, int reg)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\treturn nic->mdio_ctrl(nic, addr, mdi_read, reg, 0);\n}\n\nstatic void mdio_write(struct net_device *netdev, int addr, int reg, int data)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tnic->mdio_ctrl(nic, addr, mdi_write, reg, data);\n}\n\n \nstatic u16 mdio_ctrl_hw(struct nic *nic, u32 addr, u32 dir, u32 reg, u16 data)\n{\n\tu32 data_out = 0;\n\tunsigned int i;\n\tunsigned long flags;\n\n\n\t \n\tspin_lock_irqsave(&nic->mdio_lock, flags);\n\tfor (i = 100; i; --i) {\n\t\tif (ioread32(&nic->csr->mdi_ctrl) & mdi_ready)\n\t\t\tbreak;\n\t\tudelay(20);\n\t}\n\tif (unlikely(!i)) {\n\t\tnetdev_err(nic->netdev, \"e100.mdio_ctrl won't go Ready\\n\");\n\t\tspin_unlock_irqrestore(&nic->mdio_lock, flags);\n\t\treturn 0;\t\t \n\t}\n\tiowrite32((reg << 16) | (addr << 21) | dir | data, &nic->csr->mdi_ctrl);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tudelay(20);\n\t\tif ((data_out = ioread32(&nic->csr->mdi_ctrl)) & mdi_ready)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&nic->mdio_lock, flags);\n\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\n\t\t     \"%s:addr=%d, reg=%d, data_in=0x%04X, data_out=0x%04X\\n\",\n\t\t     dir == mdi_read ? \"READ\" : \"WRITE\",\n\t\t     addr, reg, data, data_out);\n\treturn (u16)data_out;\n}\n\n \nstatic u16 mdio_ctrl_phy_82552_v(struct nic *nic,\n\t\t\t\t u32 addr,\n\t\t\t\t u32 dir,\n\t\t\t\t u32 reg,\n\t\t\t\t u16 data)\n{\n\tif ((reg == MII_BMCR) && (dir == mdi_write)) {\n\t\tif (data & (BMCR_ANRESTART | BMCR_ANENABLE)) {\n\t\t\tu16 advert = mdio_read(nic->netdev, nic->mii.phy_id,\n\t\t\t\t\t\t\tMII_ADVERTISE);\n\n\t\t\t \n\t\t\tif (advert & ADVERTISE_100FULL)\n\t\t\t\tdata |= BMCR_SPEED100 | BMCR_FULLDPLX;\n\t\t\telse if (advert & ADVERTISE_100HALF)\n\t\t\t\tdata |= BMCR_SPEED100;\n\t\t}\n\t}\n\treturn mdio_ctrl_hw(nic, addr, dir, reg, data);\n}\n\n \nstatic u16 mdio_ctrl_phy_mii_emulated(struct nic *nic,\n\t\t\t\t      u32 addr,\n\t\t\t\t      u32 dir,\n\t\t\t\t      u32 reg,\n\t\t\t\t      u16 data)\n{\n\t \n\n\tif (dir == mdi_read) {\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\t\t \n\t\t\treturn  BMCR_ANENABLE |\n\t\t\t\tBMCR_FULLDPLX;\n\t\tcase MII_BMSR:\n\t\t\treturn\tBMSR_LSTATUS   |\n\t\t\t\tBMSR_ANEGCAPABLE |\n\t\t\t\tBMSR_10FULL;\n\t\tcase MII_ADVERTISE:\n\t\t\t \n\t\t\treturn\tADVERTISE_10HALF |\n\t\t\t\tADVERTISE_10FULL;\n\t\tdefault:\n\t\t\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\n\t\t\t\t     \"%s:addr=%d, reg=%d, data=0x%04X: unimplemented emulation!\\n\",\n\t\t\t\t     dir == mdi_read ? \"READ\" : \"WRITE\",\n\t\t\t\t     addr, reg, data);\n\t\t\treturn 0xFFFF;\n\t\t}\n\t} else {\n\t\tswitch (reg) {\n\t\tdefault:\n\t\t\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\n\t\t\t\t     \"%s:addr=%d, reg=%d, data=0x%04X: unimplemented emulation!\\n\",\n\t\t\t\t     dir == mdi_read ? \"READ\" : \"WRITE\",\n\t\t\t\t     addr, reg, data);\n\t\t\treturn 0xFFFF;\n\t\t}\n\t}\n}\nstatic inline int e100_phy_supports_mii(struct nic *nic)\n{\n\t \n\treturn (nic->mdio_ctrl != mdio_ctrl_phy_mii_emulated);\n}\n\nstatic void e100_get_defaults(struct nic *nic)\n{\n\tstruct param_range rfds = { .min = 16, .max = 256, .count = 256 };\n\tstruct param_range cbs  = { .min = 64, .max = 256, .count = 128 };\n\n\t \n\tnic->mac = (nic->flags & ich) ? mac_82559_D101M : nic->pdev->revision;\n\tif (nic->mac == mac_unknown)\n\t\tnic->mac = mac_82557_D100_A;\n\n\tnic->params.rfds = rfds;\n\tnic->params.cbs = cbs;\n\n\t \n\tnic->tx_threshold = 0xE0;\n\n\t \n\tnic->tx_command = cpu_to_le16(cb_tx | cb_tx_sf |\n\t\t((nic->mac >= mac_82558_D101_A4) ? cb_cid : cb_i));\n\n\t \n\tnic->blank_rfd.command = 0;\n\tnic->blank_rfd.rbd = cpu_to_le32(0xFFFFFFFF);\n\tnic->blank_rfd.size = cpu_to_le16(VLAN_ETH_FRAME_LEN + ETH_FCS_LEN);\n\n\t \n\tnic->mii.phy_id_mask = 0x1F;\n\tnic->mii.reg_num_mask = 0x1F;\n\tnic->mii.dev = nic->netdev;\n\tnic->mii.mdio_read = mdio_read;\n\tnic->mii.mdio_write = mdio_write;\n}\n\nstatic int e100_configure(struct nic *nic, struct cb *cb, struct sk_buff *skb)\n{\n\tstruct config *config = &cb->u.config;\n\tu8 *c = (u8 *)config;\n\tstruct net_device *netdev = nic->netdev;\n\n\tcb->command = cpu_to_le16(cb_config);\n\n\tmemset(config, 0, sizeof(struct config));\n\n\tconfig->byte_count = 0x16;\t\t \n\tconfig->rx_fifo_limit = 0x8;\t\t \n\tconfig->direct_rx_dma = 0x1;\t\t \n\tconfig->standard_tcb = 0x1;\t\t \n\tconfig->standard_stat_counter = 0x1;\t \n\tconfig->rx_discard_short_frames = 0x1;\t \n\tconfig->tx_underrun_retry = 0x3;\t \n\tif (e100_phy_supports_mii(nic))\n\t\tconfig->mii_mode = 1;            \n\tconfig->pad10 = 0x6;\n\tconfig->no_source_addr_insertion = 0x1;\t \n\tconfig->preamble_length = 0x2;\t\t \n\tconfig->ifs = 0x6;\t\t\t \n\tconfig->ip_addr_hi = 0xF2;\t\t \n\tconfig->pad15_1 = 0x1;\n\tconfig->pad15_2 = 0x1;\n\tconfig->crs_or_cdt = 0x0;\t\t \n\tconfig->fc_delay_hi = 0x40;\t\t \n\tconfig->tx_padding = 0x1;\t\t \n\tconfig->fc_priority_threshold = 0x7;\t \n\tconfig->pad18 = 0x1;\n\tconfig->full_duplex_pin = 0x1;\t\t \n\tconfig->pad20_1 = 0x1F;\n\tconfig->fc_priority_location = 0x1;\t \n\tconfig->pad21_1 = 0x5;\n\n\tconfig->adaptive_ifs = nic->adaptive_ifs;\n\tconfig->loopback = nic->loopback;\n\n\tif (nic->mii.force_media && nic->mii.full_duplex)\n\t\tconfig->full_duplex_force = 0x1;\t \n\n\tif (nic->flags & promiscuous || nic->loopback) {\n\t\tconfig->rx_save_bad_frames = 0x1;\t \n\t\tconfig->rx_discard_short_frames = 0x0;\t \n\t\tconfig->promiscuous_mode = 0x1;\t\t \n\t}\n\n\tif (unlikely(netdev->features & NETIF_F_RXFCS))\n\t\tconfig->rx_crc_transfer = 0x1;\t \n\n\tif (nic->flags & multicast_all)\n\t\tconfig->multicast_all = 0x1;\t\t \n\n\t \n\tif (netif_running(nic->netdev) || !(nic->flags & wol_magic))\n\t\tconfig->magic_packet_disable = 0x1;\t \n\n\tif (nic->mac >= mac_82558_D101_A4) {\n\t\tconfig->fc_disable = 0x1;\t \n\t\tconfig->mwi_enable = 0x1;\t \n\t\tconfig->standard_tcb = 0x0;\t \n\t\tconfig->rx_long_ok = 0x1;\t \n\t\tif (nic->mac >= mac_82559_D101M) {\n\t\t\tconfig->tno_intr = 0x1;\t\t \n\t\t\t \n\t\t\tif (nic->mac >= mac_82551_10) {\n\t\t\t\tconfig->byte_count = 0x20;  \n\t\t\t\tconfig->rx_d102_mode = 0x1;  \n\t\t\t}\n\t\t} else {\n\t\t\tconfig->standard_stat_counter = 0x0;\n\t\t}\n\t}\n\n\tif (netdev->features & NETIF_F_RXALL) {\n\t\tconfig->rx_save_overruns = 0x1;  \n\t\tconfig->rx_save_bad_frames = 0x1;        \n\t\tconfig->rx_discard_short_frames = 0x0;   \n\t}\n\n\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev, \"[00-07]=%8ph\\n\",\n\t\t     c + 0);\n\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev, \"[08-15]=%8ph\\n\",\n\t\t     c + 8);\n\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev, \"[16-23]=%8ph\\n\",\n\t\t     c + 16);\n\treturn 0;\n}\n\n \n\n \n#define BUNDLESMALL 1\n#define BUNDLEMAX (u16)6\n#define INTDELAY (u16)1536  \n\n \nstatic const struct firmware *e100_request_firmware(struct nic *nic)\n{\n\tconst char *fw_name;\n\tconst struct firmware *fw = nic->fw;\n\tu8 timer, bundle, min_size;\n\tint err = 0;\n\tbool required = false;\n\n\t \n\tif (nic->flags & ich)\n\t\treturn NULL;\n\n\t \n\tif (nic->mac == mac_82559_D101M) {\n\t\tfw_name = FIRMWARE_D101M;\n\t} else if (nic->mac == mac_82559_D101S) {\n\t\tfw_name = FIRMWARE_D101S;\n\t} else if (nic->mac == mac_82551_F || nic->mac == mac_82551_10) {\n\t\tfw_name = FIRMWARE_D102E;\n\t\trequired = true;\n\t} else {  \n\t\treturn NULL;\n\t}\n\n\t \n\tif (!fw)\n\t\terr = request_firmware(&fw, fw_name, &nic->pdev->dev);\n\n\tif (err) {\n\t\tif (required) {\n\t\t\tnetif_err(nic, probe, nic->netdev,\n\t\t\t\t  \"Failed to load firmware \\\"%s\\\": %d\\n\",\n\t\t\t\t  fw_name, err);\n\t\t\treturn ERR_PTR(err);\n\t\t} else {\n\t\t\tnetif_info(nic, probe, nic->netdev,\n\t\t\t\t   \"CPUSaver disabled. Needs \\\"%s\\\": %d\\n\",\n\t\t\t\t   fw_name, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\tif (fw->size != UCODE_SIZE * 4 + 3) {\n\t\tnetif_err(nic, probe, nic->netdev,\n\t\t\t  \"Firmware \\\"%s\\\" has wrong size %zu\\n\",\n\t\t\t  fw_name, fw->size);\n\t\trelease_firmware(fw);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\ttimer = fw->data[UCODE_SIZE * 4];\n\tbundle = fw->data[UCODE_SIZE * 4 + 1];\n\tmin_size = fw->data[UCODE_SIZE * 4 + 2];\n\n\tif (timer >= UCODE_SIZE || bundle >= UCODE_SIZE ||\n\t    min_size >= UCODE_SIZE) {\n\t\tnetif_err(nic, probe, nic->netdev,\n\t\t\t  \"\\\"%s\\\" has bogus offset values (0x%x,0x%x,0x%x)\\n\",\n\t\t\t  fw_name, timer, bundle, min_size);\n\t\trelease_firmware(fw);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tnic->fw = fw;\n\treturn fw;\n}\n\nstatic int e100_setup_ucode(struct nic *nic, struct cb *cb,\n\t\t\t     struct sk_buff *skb)\n{\n\tconst struct firmware *fw = (void *)skb;\n\tu8 timer, bundle, min_size;\n\n\t \n\tcb->skb = NULL;\n\n\t \n\tmemcpy(cb->u.ucode, fw->data, UCODE_SIZE * 4);\n\n\t \n\ttimer = fw->data[UCODE_SIZE * 4];\n\tbundle = fw->data[UCODE_SIZE * 4 + 1];\n\tmin_size = fw->data[UCODE_SIZE * 4 + 2];\n\n\t \n\tcb->u.ucode[timer] &= cpu_to_le32(0xFFFF0000);\n\tcb->u.ucode[timer] |= cpu_to_le32(INTDELAY);\n\tcb->u.ucode[bundle] &= cpu_to_le32(0xFFFF0000);\n\tcb->u.ucode[bundle] |= cpu_to_le32(BUNDLEMAX);\n\tcb->u.ucode[min_size] &= cpu_to_le32(0xFFFF0000);\n\tcb->u.ucode[min_size] |= cpu_to_le32((BUNDLESMALL) ? 0xFFFF : 0xFF80);\n\n\tcb->command = cpu_to_le16(cb_ucode | cb_el);\n\treturn 0;\n}\n\nstatic inline int e100_load_ucode_wait(struct nic *nic)\n{\n\tconst struct firmware *fw;\n\tint err = 0, counter = 50;\n\tstruct cb *cb = nic->cb_to_clean;\n\n\tfw = e100_request_firmware(nic);\n\t \n\tif (IS_ERR_OR_NULL(fw))\n\t\treturn PTR_ERR_OR_ZERO(fw);\n\n\tif ((err = e100_exec_cb(nic, (void *)fw, e100_setup_ucode)))\n\t\tnetif_err(nic, probe, nic->netdev,\n\t\t\t  \"ucode cmd failed with error %d\\n\", err);\n\n\t \n\tnic->cuc_cmd = cuc_start;\n\n\t \n\te100_write_flush(nic);\n\tudelay(10);\n\n\t \n\twhile (!(cb->status & cpu_to_le16(cb_complete))) {\n\t\tmsleep(10);\n\t\tif (!--counter) break;\n\t}\n\n\t \n\tiowrite8(~0, &nic->csr->scb.stat_ack);\n\n\t \n\tif (!counter || !(cb->status & cpu_to_le16(cb_ok))) {\n\t\tnetif_err(nic, probe, nic->netdev, \"ucode load failed\\n\");\n\t\terr = -EPERM;\n\t}\n\n\treturn err;\n}\n\nstatic int e100_setup_iaaddr(struct nic *nic, struct cb *cb,\n\tstruct sk_buff *skb)\n{\n\tcb->command = cpu_to_le16(cb_iaaddr);\n\tmemcpy(cb->u.iaaddr, nic->netdev->dev_addr, ETH_ALEN);\n\treturn 0;\n}\n\nstatic int e100_dump(struct nic *nic, struct cb *cb, struct sk_buff *skb)\n{\n\tcb->command = cpu_to_le16(cb_dump);\n\tcb->u.dump_buffer_addr = cpu_to_le32(nic->dma_addr +\n\t\toffsetof(struct mem, dump_buf));\n\treturn 0;\n}\n\nstatic int e100_phy_check_without_mii(struct nic *nic)\n{\n\tu8 phy_type;\n\tint without_mii;\n\n\tphy_type = (le16_to_cpu(nic->eeprom[eeprom_phy_iface]) >> 8) & 0x0f;\n\n\tswitch (phy_type) {\n\tcase NoSuchPhy:  \n\tcase I82503:  \n\tcase S80C24:  \n\t\t \n\t\tnetif_info(nic, probe, nic->netdev,\n\t\t\t   \"found MII-less i82503 or 80c24 or other PHY\\n\");\n\n\t\tnic->mdio_ctrl = mdio_ctrl_phy_mii_emulated;\n\t\tnic->mii.phy_id = 0;  \n\n\t\t \n\n\t\twithout_mii = 1;\n\t\tbreak;\n\tdefault:\n\t\twithout_mii = 0;\n\t\tbreak;\n\t}\n\treturn without_mii;\n}\n\n#define NCONFIG_AUTO_SWITCH\t0x0080\n#define MII_NSC_CONG\t\tMII_RESV1\n#define NSC_CONG_ENABLE\t\t0x0100\n#define NSC_CONG_TXREADY\t0x0400\nstatic int e100_phy_init(struct nic *nic)\n{\n\tstruct net_device *netdev = nic->netdev;\n\tu32 addr;\n\tu16 bmcr, stat, id_lo, id_hi, cong;\n\n\t \n\tfor (addr = 0; addr < 32; addr++) {\n\t\tnic->mii.phy_id = (addr == 0) ? 1 : (addr == 1) ? 0 : addr;\n\t\tbmcr = mdio_read(netdev, nic->mii.phy_id, MII_BMCR);\n\t\tstat = mdio_read(netdev, nic->mii.phy_id, MII_BMSR);\n\t\tstat = mdio_read(netdev, nic->mii.phy_id, MII_BMSR);\n\t\tif (!((bmcr == 0xFFFF) || ((stat == 0) && (bmcr == 0))))\n\t\t\tbreak;\n\t}\n\tif (addr == 32) {\n\t\t \n\t\tif (e100_phy_check_without_mii(nic))\n\t\t\treturn 0;  \n\t\telse {\n\t\t\t \n\t\t\tnetif_err(nic, hw, nic->netdev,\n\t\t\t\t  \"Failed to locate any known PHY, aborting\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t} else\n\t\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\n\t\t\t     \"phy_addr = %d\\n\", nic->mii.phy_id);\n\n\t \n\tid_lo = mdio_read(netdev, nic->mii.phy_id, MII_PHYSID1);\n\tid_hi = mdio_read(netdev, nic->mii.phy_id, MII_PHYSID2);\n\tnic->phy = (u32)id_hi << 16 | (u32)id_lo;\n\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\n\t\t     \"phy ID = 0x%08X\\n\", nic->phy);\n\n\t \n\tfor (addr = 0; addr < 32; addr++) {\n\t\tif (addr != nic->mii.phy_id) {\n\t\t\tmdio_write(netdev, addr, MII_BMCR, BMCR_ISOLATE);\n\t\t} else if (nic->phy != phy_82552_v) {\n\t\t\tbmcr = mdio_read(netdev, addr, MII_BMCR);\n\t\t\tmdio_write(netdev, addr, MII_BMCR,\n\t\t\t\tbmcr & ~BMCR_ISOLATE);\n\t\t}\n\t}\n\t \n\tif (nic->phy == phy_82552_v)\n\t\tmdio_write(netdev, nic->mii.phy_id, MII_BMCR,\n\t\t\tbmcr & ~BMCR_ISOLATE);\n\n\t \n#define NCS_PHY_MODEL_MASK\t0xFFF0FFFF\n\tif ((nic->phy & NCS_PHY_MODEL_MASK) == phy_nsc_tx) {\n\t\t \n\t\tcong = mdio_read(netdev, nic->mii.phy_id, MII_NSC_CONG);\n\t\tcong |= NSC_CONG_TXREADY;\n\t\tcong &= ~NSC_CONG_ENABLE;\n\t\tmdio_write(netdev, nic->mii.phy_id, MII_NSC_CONG, cong);\n\t}\n\n\tif (nic->phy == phy_82552_v) {\n\t\tu16 advert = mdio_read(netdev, nic->mii.phy_id, MII_ADVERTISE);\n\n\t\t \n\t\tnic->mdio_ctrl = mdio_ctrl_phy_82552_v;\n\n\t\t \n\t\tadvert |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\tmdio_write(netdev, nic->mii.phy_id, MII_ADVERTISE, advert);\n\n\t\t \n\t\tbmcr = mdio_read(netdev, nic->mii.phy_id, MII_BMCR);\n\t\tbmcr |= BMCR_RESET;\n\t\tmdio_write(netdev, nic->mii.phy_id, MII_BMCR, bmcr);\n\t} else if ((nic->mac >= mac_82550_D102) || ((nic->flags & ich) &&\n\t   (mdio_read(netdev, nic->mii.phy_id, MII_TPISTATUS) & 0x8000) &&\n\t   (le16_to_cpu(nic->eeprom[eeprom_cnfg_mdix]) & eeprom_mdix_enabled))) {\n\t\t \n\t\tmdio_write(netdev, nic->mii.phy_id, MII_NCONFIG,\n\t\t\t\tnic->mii.force_media ? 0 : NCONFIG_AUTO_SWITCH);\n\t}\n\n\treturn 0;\n}\n\nstatic int e100_hw_init(struct nic *nic)\n{\n\tint err = 0;\n\n\te100_hw_reset(nic);\n\n\tnetif_err(nic, hw, nic->netdev, \"e100_hw_init\\n\");\n\tif ((err = e100_self_test(nic)))\n\t\treturn err;\n\n\tif ((err = e100_phy_init(nic)))\n\t\treturn err;\n\tif ((err = e100_exec_cmd(nic, cuc_load_base, 0)))\n\t\treturn err;\n\tif ((err = e100_exec_cmd(nic, ruc_load_base, 0)))\n\t\treturn err;\n\tif ((err = e100_load_ucode_wait(nic)))\n\t\treturn err;\n\tif ((err = e100_exec_cb(nic, NULL, e100_configure)))\n\t\treturn err;\n\tif ((err = e100_exec_cb(nic, NULL, e100_setup_iaaddr)))\n\t\treturn err;\n\tif ((err = e100_exec_cmd(nic, cuc_dump_addr,\n\t\tnic->dma_addr + offsetof(struct mem, stats))))\n\t\treturn err;\n\tif ((err = e100_exec_cmd(nic, cuc_dump_reset, 0)))\n\t\treturn err;\n\n\te100_disable_irq(nic);\n\n\treturn 0;\n}\n\nstatic int e100_multi(struct nic *nic, struct cb *cb, struct sk_buff *skb)\n{\n\tstruct net_device *netdev = nic->netdev;\n\tstruct netdev_hw_addr *ha;\n\tu16 i, count = min(netdev_mc_count(netdev), E100_MAX_MULTICAST_ADDRS);\n\n\tcb->command = cpu_to_le16(cb_multi);\n\tcb->u.multi.count = cpu_to_le16(count * ETH_ALEN);\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\tif (i == count)\n\t\t\tbreak;\n\t\tmemcpy(&cb->u.multi.addr[i++ * ETH_ALEN], &ha->addr,\n\t\t\tETH_ALEN);\n\t}\n\treturn 0;\n}\n\nstatic void e100_set_multicast_list(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\n\t\t     \"mc_count=%d, flags=0x%04X\\n\",\n\t\t     netdev_mc_count(netdev), netdev->flags);\n\n\tif (netdev->flags & IFF_PROMISC)\n\t\tnic->flags |= promiscuous;\n\telse\n\t\tnic->flags &= ~promiscuous;\n\n\tif (netdev->flags & IFF_ALLMULTI ||\n\t\tnetdev_mc_count(netdev) > E100_MAX_MULTICAST_ADDRS)\n\t\tnic->flags |= multicast_all;\n\telse\n\t\tnic->flags &= ~multicast_all;\n\n\te100_exec_cb(nic, NULL, e100_configure);\n\te100_exec_cb(nic, NULL, e100_multi);\n}\n\nstatic void e100_update_stats(struct nic *nic)\n{\n\tstruct net_device *dev = nic->netdev;\n\tstruct net_device_stats *ns = &dev->stats;\n\tstruct stats *s = &nic->mem->stats;\n\t__le32 *complete = (nic->mac < mac_82558_D101_A4) ? &s->fc_xmt_pause :\n\t\t(nic->mac < mac_82559_D101M) ? (__le32 *)&s->xmt_tco_frames :\n\t\t&s->complete;\n\n\t \n\n\tif (*complete == cpu_to_le32(cuc_dump_reset_complete)) {\n\t\t*complete = 0;\n\t\tnic->tx_frames = le32_to_cpu(s->tx_good_frames);\n\t\tnic->tx_collisions = le32_to_cpu(s->tx_total_collisions);\n\t\tns->tx_aborted_errors += le32_to_cpu(s->tx_max_collisions);\n\t\tns->tx_window_errors += le32_to_cpu(s->tx_late_collisions);\n\t\tns->tx_carrier_errors += le32_to_cpu(s->tx_lost_crs);\n\t\tns->tx_fifo_errors += le32_to_cpu(s->tx_underruns);\n\t\tns->collisions += nic->tx_collisions;\n\t\tns->tx_errors += le32_to_cpu(s->tx_max_collisions) +\n\t\t\tle32_to_cpu(s->tx_lost_crs);\n\t\tnic->rx_short_frame_errors +=\n\t\t\tle32_to_cpu(s->rx_short_frame_errors);\n\t\tns->rx_length_errors = nic->rx_short_frame_errors +\n\t\t\tnic->rx_over_length_errors;\n\t\tns->rx_crc_errors += le32_to_cpu(s->rx_crc_errors);\n\t\tns->rx_frame_errors += le32_to_cpu(s->rx_alignment_errors);\n\t\tns->rx_over_errors += le32_to_cpu(s->rx_overrun_errors);\n\t\tns->rx_fifo_errors += le32_to_cpu(s->rx_overrun_errors);\n\t\tns->rx_missed_errors += le32_to_cpu(s->rx_resource_errors);\n\t\tns->rx_errors += le32_to_cpu(s->rx_crc_errors) +\n\t\t\tle32_to_cpu(s->rx_alignment_errors) +\n\t\t\tle32_to_cpu(s->rx_short_frame_errors) +\n\t\t\tle32_to_cpu(s->rx_cdt_errors);\n\t\tnic->tx_deferred += le32_to_cpu(s->tx_deferred);\n\t\tnic->tx_single_collisions +=\n\t\t\tle32_to_cpu(s->tx_single_collisions);\n\t\tnic->tx_multiple_collisions +=\n\t\t\tle32_to_cpu(s->tx_multiple_collisions);\n\t\tif (nic->mac >= mac_82558_D101_A4) {\n\t\t\tnic->tx_fc_pause += le32_to_cpu(s->fc_xmt_pause);\n\t\t\tnic->rx_fc_pause += le32_to_cpu(s->fc_rcv_pause);\n\t\t\tnic->rx_fc_unsupported +=\n\t\t\t\tle32_to_cpu(s->fc_rcv_unsupported);\n\t\t\tif (nic->mac >= mac_82559_D101M) {\n\t\t\t\tnic->tx_tco_frames +=\n\t\t\t\t\tle16_to_cpu(s->xmt_tco_frames);\n\t\t\t\tnic->rx_tco_frames +=\n\t\t\t\t\tle16_to_cpu(s->rcv_tco_frames);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (e100_exec_cmd(nic, cuc_dump_reset, 0))\n\t\tnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\n\t\t\t     \"exec cuc_dump_reset failed\\n\");\n}\n\nstatic void e100_adjust_adaptive_ifs(struct nic *nic, int speed, int duplex)\n{\n\t \n\n\tif (duplex == DUPLEX_HALF) {\n\t\tu32 prev = nic->adaptive_ifs;\n\t\tu32 min_frames = (speed == SPEED_100) ? 1000 : 100;\n\n\t\tif ((nic->tx_frames / 32 < nic->tx_collisions) &&\n\t\t   (nic->tx_frames > min_frames)) {\n\t\t\tif (nic->adaptive_ifs < 60)\n\t\t\t\tnic->adaptive_ifs += 5;\n\t\t} else if (nic->tx_frames < min_frames) {\n\t\t\tif (nic->adaptive_ifs >= 5)\n\t\t\t\tnic->adaptive_ifs -= 5;\n\t\t}\n\t\tif (nic->adaptive_ifs != prev)\n\t\t\te100_exec_cb(nic, NULL, e100_configure);\n\t}\n}\n\nstatic void e100_watchdog(struct timer_list *t)\n{\n\tstruct nic *nic = from_timer(nic, t, watchdog);\n\tstruct ethtool_cmd cmd = { .cmd = ETHTOOL_GSET };\n\tu32 speed;\n\n\tnetif_printk(nic, timer, KERN_DEBUG, nic->netdev,\n\t\t     \"right now = %ld\\n\", jiffies);\n\n\t \n\n\tmii_ethtool_gset(&nic->mii, &cmd);\n\tspeed = ethtool_cmd_speed(&cmd);\n\n\tif (mii_link_ok(&nic->mii) && !netif_carrier_ok(nic->netdev)) {\n\t\tnetdev_info(nic->netdev, \"NIC Link is Up %u Mbps %s Duplex\\n\",\n\t\t\t    speed == SPEED_100 ? 100 : 10,\n\t\t\t    cmd.duplex == DUPLEX_FULL ? \"Full\" : \"Half\");\n\t} else if (!mii_link_ok(&nic->mii) && netif_carrier_ok(nic->netdev)) {\n\t\tnetdev_info(nic->netdev, \"NIC Link is Down\\n\");\n\t}\n\n\tmii_check_link(&nic->mii);\n\n\t \n\tspin_lock_irq(&nic->cmd_lock);\n\tiowrite8(ioread8(&nic->csr->scb.cmd_hi) | irq_sw_gen,&nic->csr->scb.cmd_hi);\n\te100_write_flush(nic);\n\tspin_unlock_irq(&nic->cmd_lock);\n\n\te100_update_stats(nic);\n\te100_adjust_adaptive_ifs(nic, speed, cmd.duplex);\n\n\tif (nic->mac <= mac_82557_D100_C)\n\t\t \n\t\te100_set_multicast_list(nic->netdev);\n\n\tif (nic->flags & ich && speed == SPEED_10 && cmd.duplex == DUPLEX_HALF)\n\t\t \n\t\tnic->flags |= ich_10h_workaround;\n\telse\n\t\tnic->flags &= ~ich_10h_workaround;\n\n\tmod_timer(&nic->watchdog,\n\t\t  round_jiffies(jiffies + E100_WATCHDOG_PERIOD));\n}\n\nstatic int e100_xmit_prepare(struct nic *nic, struct cb *cb,\n\tstruct sk_buff *skb)\n{\n\tdma_addr_t dma_addr;\n\tcb->command = nic->tx_command;\n\n\tdma_addr = dma_map_single(&nic->pdev->dev, skb->data, skb->len,\n\t\t\t\t  DMA_TO_DEVICE);\n\t \n\tif (dma_mapping_error(&nic->pdev->dev, dma_addr))\n\t\treturn -ENOMEM;\n\n\t \n\tif (unlikely(skb->no_fcs))\n\t\tcb->command |= cpu_to_le16(cb_tx_nc);\n\telse\n\t\tcb->command &= ~cpu_to_le16(cb_tx_nc);\n\n\t \n\tif ((nic->cbs_avail & ~15) == nic->cbs_avail)\n\t\tcb->command |= cpu_to_le16(cb_i);\n\tcb->u.tcb.tbd_array = cb->dma_addr + offsetof(struct cb, u.tcb.tbd);\n\tcb->u.tcb.tcb_byte_count = 0;\n\tcb->u.tcb.threshold = nic->tx_threshold;\n\tcb->u.tcb.tbd_count = 1;\n\tcb->u.tcb.tbd.buf_addr = cpu_to_le32(dma_addr);\n\tcb->u.tcb.tbd.size = cpu_to_le16(skb->len);\n\tskb_tx_timestamp(skb);\n\treturn 0;\n}\n\nstatic netdev_tx_t e100_xmit_frame(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tint err;\n\n\tif (nic->flags & ich_10h_workaround) {\n\t\t \n\t\tif (e100_exec_cmd(nic, cuc_nop, 0))\n\t\t\tnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\n\t\t\t\t     \"exec cuc_nop failed\\n\");\n\t\tudelay(1);\n\t}\n\n\terr = e100_exec_cb(nic, skb, e100_xmit_prepare);\n\n\tswitch (err) {\n\tcase -ENOSPC:\n\t\t \n\t\tnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\n\t\t\t     \"No space for CB\\n\");\n\t\tnetif_stop_queue(netdev);\n\t\tbreak;\n\tcase -ENOMEM:\n\t\t \n\t\tnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\n\t\t\t     \"Out of Tx resources, returning skb\\n\");\n\t\tnetif_stop_queue(netdev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int e100_tx_clean(struct nic *nic)\n{\n\tstruct net_device *dev = nic->netdev;\n\tstruct cb *cb;\n\tint tx_cleaned = 0;\n\n\tspin_lock(&nic->cb_lock);\n\n\t \n\tfor (cb = nic->cb_to_clean;\n\t    cb->status & cpu_to_le16(cb_complete);\n\t    cb = nic->cb_to_clean = cb->next) {\n\t\tdma_rmb();  \n\t\tnetif_printk(nic, tx_done, KERN_DEBUG, nic->netdev,\n\t\t\t     \"cb[%d]->status = 0x%04X\\n\",\n\t\t\t     (int)(((void*)cb - (void*)nic->cbs)/sizeof(struct cb)),\n\t\t\t     cb->status);\n\n\t\tif (likely(cb->skb != NULL)) {\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += cb->skb->len;\n\n\t\t\tdma_unmap_single(&nic->pdev->dev,\n\t\t\t\t\t le32_to_cpu(cb->u.tcb.tbd.buf_addr),\n\t\t\t\t\t le16_to_cpu(cb->u.tcb.tbd.size),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(cb->skb);\n\t\t\tcb->skb = NULL;\n\t\t\ttx_cleaned = 1;\n\t\t}\n\t\tcb->status = 0;\n\t\tnic->cbs_avail++;\n\t}\n\n\tspin_unlock(&nic->cb_lock);\n\n\t \n\tif (unlikely(tx_cleaned && netif_queue_stopped(nic->netdev)))\n\t\tnetif_wake_queue(nic->netdev);\n\n\treturn tx_cleaned;\n}\n\nstatic void e100_clean_cbs(struct nic *nic)\n{\n\tif (nic->cbs) {\n\t\twhile (nic->cbs_avail != nic->params.cbs.count) {\n\t\t\tstruct cb *cb = nic->cb_to_clean;\n\t\t\tif (cb->skb) {\n\t\t\t\tdma_unmap_single(&nic->pdev->dev,\n\t\t\t\t\t\t le32_to_cpu(cb->u.tcb.tbd.buf_addr),\n\t\t\t\t\t\t le16_to_cpu(cb->u.tcb.tbd.size),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb(cb->skb);\n\t\t\t}\n\t\t\tnic->cb_to_clean = nic->cb_to_clean->next;\n\t\t\tnic->cbs_avail++;\n\t\t}\n\t\tdma_pool_free(nic->cbs_pool, nic->cbs, nic->cbs_dma_addr);\n\t\tnic->cbs = NULL;\n\t\tnic->cbs_avail = 0;\n\t}\n\tnic->cuc_cmd = cuc_start;\n\tnic->cb_to_use = nic->cb_to_send = nic->cb_to_clean =\n\t\tnic->cbs;\n}\n\nstatic int e100_alloc_cbs(struct nic *nic)\n{\n\tstruct cb *cb;\n\tunsigned int i, count = nic->params.cbs.count;\n\n\tnic->cuc_cmd = cuc_start;\n\tnic->cb_to_use = nic->cb_to_send = nic->cb_to_clean = NULL;\n\tnic->cbs_avail = 0;\n\n\tnic->cbs = dma_pool_zalloc(nic->cbs_pool, GFP_KERNEL,\n\t\t\t\t   &nic->cbs_dma_addr);\n\tif (!nic->cbs)\n\t\treturn -ENOMEM;\n\n\tfor (cb = nic->cbs, i = 0; i < count; cb++, i++) {\n\t\tcb->next = (i + 1 < count) ? cb + 1 : nic->cbs;\n\t\tcb->prev = (i == 0) ? nic->cbs + count - 1 : cb - 1;\n\n\t\tcb->dma_addr = nic->cbs_dma_addr + i * sizeof(struct cb);\n\t\tcb->link = cpu_to_le32(nic->cbs_dma_addr +\n\t\t\t((i+1) % count) * sizeof(struct cb));\n\t}\n\n\tnic->cb_to_use = nic->cb_to_send = nic->cb_to_clean = nic->cbs;\n\tnic->cbs_avail = count;\n\n\treturn 0;\n}\n\nstatic inline void e100_start_receiver(struct nic *nic, struct rx *rx)\n{\n\tif (!nic->rxs) return;\n\tif (RU_SUSPENDED != nic->ru_running) return;\n\n\t \n\tif (!rx) rx = nic->rxs;\n\n\t \n\tif (rx->skb) {\n\t\te100_exec_cmd(nic, ruc_start, rx->dma_addr);\n\t\tnic->ru_running = RU_RUNNING;\n\t}\n}\n\n#define RFD_BUF_LEN (sizeof(struct rfd) + VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)\nstatic int e100_rx_alloc_skb(struct nic *nic, struct rx *rx)\n{\n\tif (!(rx->skb = netdev_alloc_skb_ip_align(nic->netdev, RFD_BUF_LEN)))\n\t\treturn -ENOMEM;\n\n\t \n\tskb_copy_to_linear_data(rx->skb, &nic->blank_rfd, sizeof(struct rfd));\n\trx->dma_addr = dma_map_single(&nic->pdev->dev, rx->skb->data,\n\t\t\t\t      RFD_BUF_LEN, DMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(&nic->pdev->dev, rx->dma_addr)) {\n\t\tdev_kfree_skb_any(rx->skb);\n\t\trx->skb = NULL;\n\t\trx->dma_addr = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (rx->prev->skb) {\n\t\tstruct rfd *prev_rfd = (struct rfd *)rx->prev->skb->data;\n\t\tput_unaligned_le32(rx->dma_addr, &prev_rfd->link);\n\t\tdma_sync_single_for_device(&nic->pdev->dev,\n\t\t\t\t\t   rx->prev->dma_addr,\n\t\t\t\t\t   sizeof(struct rfd),\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t}\n\n\treturn 0;\n}\n\nstatic int e100_rx_indicate(struct nic *nic, struct rx *rx,\n\tunsigned int *work_done, unsigned int work_to_do)\n{\n\tstruct net_device *dev = nic->netdev;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct rfd *rfd = (struct rfd *)skb->data;\n\tu16 rfd_status, actual_size;\n\tu16 fcs_pad = 0;\n\n\tif (unlikely(work_done && *work_done >= work_to_do))\n\t\treturn -EAGAIN;\n\n\t \n\tdma_sync_single_for_cpu(&nic->pdev->dev, rx->dma_addr,\n\t\t\t\tsizeof(struct rfd), DMA_BIDIRECTIONAL);\n\trfd_status = le16_to_cpu(rfd->status);\n\n\tnetif_printk(nic, rx_status, KERN_DEBUG, nic->netdev,\n\t\t     \"status=0x%04X\\n\", rfd_status);\n\tdma_rmb();  \n\n\t \n\tif (unlikely(!(rfd_status & cb_complete))) {\n\t\t \n\t\tif ((le16_to_cpu(rfd->command) & cb_el) &&\n\t\t    (RU_RUNNING == nic->ru_running))\n\n\t\t\tif (ioread8(&nic->csr->scb.status) & rus_no_res)\n\t\t\t\tnic->ru_running = RU_SUSPENDED;\n\t\tdma_sync_single_for_device(&nic->pdev->dev, rx->dma_addr,\n\t\t\t\t\t   sizeof(struct rfd),\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\tif (unlikely(dev->features & NETIF_F_RXFCS))\n\t\tfcs_pad = 4;\n\tactual_size = le16_to_cpu(rfd->actual_size) & 0x3FFF;\n\tif (unlikely(actual_size > RFD_BUF_LEN - sizeof(struct rfd)))\n\t\tactual_size = RFD_BUF_LEN - sizeof(struct rfd);\n\n\t \n\tdma_unmap_single(&nic->pdev->dev, rx->dma_addr, RFD_BUF_LEN,\n\t\t\t DMA_BIDIRECTIONAL);\n\n\t \n\tif ((le16_to_cpu(rfd->command) & cb_el) &&\n\t    (RU_RUNNING == nic->ru_running)) {\n\n\t    if (ioread8(&nic->csr->scb.status) & rus_no_res)\n\t\tnic->ru_running = RU_SUSPENDED;\n\t}\n\n\t \n\tskb_reserve(skb, sizeof(struct rfd));\n\tskb_put(skb, actual_size);\n\tskb->protocol = eth_type_trans(skb, nic->netdev);\n\n\t \n\tif (unlikely(dev->features & NETIF_F_RXALL)) {\n\t\tif (actual_size > ETH_DATA_LEN + VLAN_ETH_HLEN + fcs_pad)\n\t\t\t \n\t\t\tnic->rx_over_length_errors++;\n\t\tgoto process_skb;\n\t}\n\n\tif (unlikely(!(rfd_status & cb_ok))) {\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t} else if (actual_size > ETH_DATA_LEN + VLAN_ETH_HLEN + fcs_pad) {\n\t\t \n\t\tnic->rx_over_length_errors++;\n\t\tdev_kfree_skb_any(skb);\n\t} else {\nprocess_skb:\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += (actual_size - fcs_pad);\n\t\tnetif_receive_skb(skb);\n\t\tif (work_done)\n\t\t\t(*work_done)++;\n\t}\n\n\trx->skb = NULL;\n\n\treturn 0;\n}\n\nstatic void e100_rx_clean(struct nic *nic, unsigned int *work_done,\n\tunsigned int work_to_do)\n{\n\tstruct rx *rx;\n\tint restart_required = 0, err = 0;\n\tstruct rx *old_before_last_rx, *new_before_last_rx;\n\tstruct rfd *old_before_last_rfd, *new_before_last_rfd;\n\n\t \n\tfor (rx = nic->rx_to_clean; rx->skb; rx = nic->rx_to_clean = rx->next) {\n\t\terr = e100_rx_indicate(nic, rx, work_done, work_to_do);\n\t\t \n\t\tif (-EAGAIN == err || -ENODATA == err)\n\t\t\tbreak;\n\t}\n\n\n\t \n\tif (-EAGAIN != err && RU_SUSPENDED == nic->ru_running)\n\t\trestart_required = 1;\n\n\told_before_last_rx = nic->rx_to_use->prev->prev;\n\told_before_last_rfd = (struct rfd *)old_before_last_rx->skb->data;\n\n\t \n\tfor (rx = nic->rx_to_use; !rx->skb; rx = nic->rx_to_use = rx->next) {\n\t\tif (unlikely(e100_rx_alloc_skb(nic, rx)))\n\t\t\tbreak;  \n\t}\n\n\tnew_before_last_rx = nic->rx_to_use->prev->prev;\n\tif (new_before_last_rx != old_before_last_rx) {\n\t\t \n\t\tnew_before_last_rfd =\n\t\t\t(struct rfd *)new_before_last_rx->skb->data;\n\t\tnew_before_last_rfd->size = 0;\n\t\tnew_before_last_rfd->command |= cpu_to_le16(cb_el);\n\t\tdma_sync_single_for_device(&nic->pdev->dev,\n\t\t\t\t\t   new_before_last_rx->dma_addr,\n\t\t\t\t\t   sizeof(struct rfd),\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\t\t \n\t\told_before_last_rfd->command &= ~cpu_to_le16(cb_el);\n\t\tdma_sync_single_for_device(&nic->pdev->dev,\n\t\t\t\t\t   old_before_last_rx->dma_addr,\n\t\t\t\t\t   sizeof(struct rfd),\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t\told_before_last_rfd->size = cpu_to_le16(VLAN_ETH_FRAME_LEN\n\t\t\t\t\t\t\t+ ETH_FCS_LEN);\n\t\tdma_sync_single_for_device(&nic->pdev->dev,\n\t\t\t\t\t   old_before_last_rx->dma_addr,\n\t\t\t\t\t   sizeof(struct rfd),\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t}\n\n\tif (restart_required) {\n\t\t\n\t\tiowrite8(stat_ack_rnr, &nic->csr->scb.stat_ack);\n\t\te100_start_receiver(nic, nic->rx_to_clean);\n\t\tif (work_done)\n\t\t\t(*work_done)++;\n\t}\n}\n\nstatic void e100_rx_clean_list(struct nic *nic)\n{\n\tstruct rx *rx;\n\tunsigned int i, count = nic->params.rfds.count;\n\n\tnic->ru_running = RU_UNINITIALIZED;\n\n\tif (nic->rxs) {\n\t\tfor (rx = nic->rxs, i = 0; i < count; rx++, i++) {\n\t\t\tif (rx->skb) {\n\t\t\t\tdma_unmap_single(&nic->pdev->dev,\n\t\t\t\t\t\t rx->dma_addr, RFD_BUF_LEN,\n\t\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\t\t\tdev_kfree_skb(rx->skb);\n\t\t\t}\n\t\t}\n\t\tkfree(nic->rxs);\n\t\tnic->rxs = NULL;\n\t}\n\n\tnic->rx_to_use = nic->rx_to_clean = NULL;\n}\n\nstatic int e100_rx_alloc_list(struct nic *nic)\n{\n\tstruct rx *rx;\n\tunsigned int i, count = nic->params.rfds.count;\n\tstruct rfd *before_last;\n\n\tnic->rx_to_use = nic->rx_to_clean = NULL;\n\tnic->ru_running = RU_UNINITIALIZED;\n\n\tif (!(nic->rxs = kcalloc(count, sizeof(struct rx), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tfor (rx = nic->rxs, i = 0; i < count; rx++, i++) {\n\t\trx->next = (i + 1 < count) ? rx + 1 : nic->rxs;\n\t\trx->prev = (i == 0) ? nic->rxs + count - 1 : rx - 1;\n\t\tif (e100_rx_alloc_skb(nic, rx)) {\n\t\t\te100_rx_clean_list(nic);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t \n\trx = nic->rxs->prev->prev;\n\tbefore_last = (struct rfd *)rx->skb->data;\n\tbefore_last->command |= cpu_to_le16(cb_el);\n\tbefore_last->size = 0;\n\tdma_sync_single_for_device(&nic->pdev->dev, rx->dma_addr,\n\t\t\t\t   sizeof(struct rfd), DMA_BIDIRECTIONAL);\n\n\tnic->rx_to_use = nic->rx_to_clean = nic->rxs;\n\tnic->ru_running = RU_SUSPENDED;\n\n\treturn 0;\n}\n\nstatic irqreturn_t e100_intr(int irq, void *dev_id)\n{\n\tstruct net_device *netdev = dev_id;\n\tstruct nic *nic = netdev_priv(netdev);\n\tu8 stat_ack = ioread8(&nic->csr->scb.stat_ack);\n\n\tnetif_printk(nic, intr, KERN_DEBUG, nic->netdev,\n\t\t     \"stat_ack = 0x%02X\\n\", stat_ack);\n\n\tif (stat_ack == stat_ack_not_ours ||\t \n\t   stat_ack == stat_ack_not_present)\t \n\t\treturn IRQ_NONE;\n\n\t \n\tiowrite8(stat_ack, &nic->csr->scb.stat_ack);\n\n\t \n\tif (stat_ack & stat_ack_rnr)\n\t\tnic->ru_running = RU_SUSPENDED;\n\n\tif (likely(napi_schedule_prep(&nic->napi))) {\n\t\te100_disable_irq(nic);\n\t\t__napi_schedule(&nic->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int e100_poll(struct napi_struct *napi, int budget)\n{\n\tstruct nic *nic = container_of(napi, struct nic, napi);\n\tunsigned int work_done = 0;\n\n\te100_rx_clean(nic, &work_done, budget);\n\te100_tx_clean(nic);\n\n\t \n\tif (work_done == budget)\n\t\treturn budget;\n\n\t \n\tif (likely(napi_complete_done(napi, work_done)))\n\t\te100_enable_irq(nic);\n\n\treturn work_done;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void e100_netpoll(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\te100_disable_irq(nic);\n\te100_intr(nic->pdev->irq, netdev);\n\te100_tx_clean(nic);\n\te100_enable_irq(nic);\n}\n#endif\n\nstatic int e100_set_mac_address(struct net_device *netdev, void *p)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\te100_exec_cb(nic, NULL, e100_setup_iaaddr);\n\n\treturn 0;\n}\n\nstatic int e100_asf(struct nic *nic)\n{\n\t \n\treturn (nic->pdev->device >= 0x1050) && (nic->pdev->device <= 0x1057) &&\n\t   (le16_to_cpu(nic->eeprom[eeprom_config_asf]) & eeprom_asf) &&\n\t   !(le16_to_cpu(nic->eeprom[eeprom_config_asf]) & eeprom_gcl) &&\n\t   ((le16_to_cpu(nic->eeprom[eeprom_smbus_addr]) & 0xFF) != 0xFE);\n}\n\nstatic int e100_up(struct nic *nic)\n{\n\tint err;\n\n\tif ((err = e100_rx_alloc_list(nic)))\n\t\treturn err;\n\tif ((err = e100_alloc_cbs(nic)))\n\t\tgoto err_rx_clean_list;\n\tif ((err = e100_hw_init(nic)))\n\t\tgoto err_clean_cbs;\n\te100_set_multicast_list(nic->netdev);\n\te100_start_receiver(nic, NULL);\n\tmod_timer(&nic->watchdog, jiffies);\n\tif ((err = request_irq(nic->pdev->irq, e100_intr, IRQF_SHARED,\n\t\tnic->netdev->name, nic->netdev)))\n\t\tgoto err_no_irq;\n\tnetif_wake_queue(nic->netdev);\n\tnapi_enable(&nic->napi);\n\t \n\te100_enable_irq(nic);\n\treturn 0;\n\nerr_no_irq:\n\tdel_timer_sync(&nic->watchdog);\nerr_clean_cbs:\n\te100_clean_cbs(nic);\nerr_rx_clean_list:\n\te100_rx_clean_list(nic);\n\treturn err;\n}\n\nstatic void e100_down(struct nic *nic)\n{\n\t \n\tnapi_disable(&nic->napi);\n\tnetif_stop_queue(nic->netdev);\n\te100_hw_reset(nic);\n\tfree_irq(nic->pdev->irq, nic->netdev);\n\tdel_timer_sync(&nic->watchdog);\n\tnetif_carrier_off(nic->netdev);\n\te100_clean_cbs(nic);\n\te100_rx_clean_list(nic);\n}\n\nstatic void e100_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\t \n\tschedule_work(&nic->tx_timeout_task);\n}\n\nstatic void e100_tx_timeout_task(struct work_struct *work)\n{\n\tstruct nic *nic = container_of(work, struct nic, tx_timeout_task);\n\tstruct net_device *netdev = nic->netdev;\n\n\tnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\n\t\t     \"scb.status=0x%02X\\n\", ioread8(&nic->csr->scb.status));\n\n\trtnl_lock();\n\tif (netif_running(netdev)) {\n\t\te100_down(netdev_priv(netdev));\n\t\te100_up(netdev_priv(netdev));\n\t}\n\trtnl_unlock();\n}\n\nstatic int e100_loopback_test(struct nic *nic, enum loopback loopback_mode)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\n\t \n\n\tif ((err = e100_rx_alloc_list(nic)))\n\t\treturn err;\n\tif ((err = e100_alloc_cbs(nic)))\n\t\tgoto err_clean_rx;\n\n\t \n\tif (nic->flags & ich && loopback_mode == lb_phy)\n\t\tloopback_mode = lb_mac;\n\n\tnic->loopback = loopback_mode;\n\tif ((err = e100_hw_init(nic)))\n\t\tgoto err_loopback_none;\n\n\tif (loopback_mode == lb_phy)\n\t\tmdio_write(nic->netdev, nic->mii.phy_id, MII_BMCR,\n\t\t\tBMCR_LOOPBACK);\n\n\te100_start_receiver(nic, NULL);\n\n\tif (!(skb = netdev_alloc_skb(nic->netdev, ETH_DATA_LEN))) {\n\t\terr = -ENOMEM;\n\t\tgoto err_loopback_none;\n\t}\n\tskb_put(skb, ETH_DATA_LEN);\n\tmemset(skb->data, 0xFF, ETH_DATA_LEN);\n\te100_xmit_frame(skb, nic->netdev);\n\n\tmsleep(10);\n\n\tdma_sync_single_for_cpu(&nic->pdev->dev, nic->rx_to_clean->dma_addr,\n\t\t\t\tRFD_BUF_LEN, DMA_BIDIRECTIONAL);\n\n\tif (memcmp(nic->rx_to_clean->skb->data + sizeof(struct rfd),\n\t   skb->data, ETH_DATA_LEN))\n\t\terr = -EAGAIN;\n\nerr_loopback_none:\n\tmdio_write(nic->netdev, nic->mii.phy_id, MII_BMCR, 0);\n\tnic->loopback = lb_none;\n\te100_clean_cbs(nic);\n\te100_hw_reset(nic);\nerr_clean_rx:\n\te100_rx_clean_list(nic);\n\treturn err;\n}\n\n#define MII_LED_CONTROL\t0x1B\n#define E100_82552_LED_OVERRIDE 0x19\n#define E100_82552_LED_ON       0x000F  \n#define E100_82552_LED_OFF      0x000A  \n\nstatic int e100_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tmii_ethtool_get_link_ksettings(&nic->mii, cmd);\n\n\treturn 0;\n}\n\nstatic int e100_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tint err;\n\n\tmdio_write(netdev, nic->mii.phy_id, MII_BMCR, BMCR_RESET);\n\terr = mii_ethtool_set_link_ksettings(&nic->mii, cmd);\n\te100_exec_cb(nic, NULL, e100_configure);\n\n\treturn err;\n}\n\nstatic void e100_get_drvinfo(struct net_device *netdev,\n\tstruct ethtool_drvinfo *info)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(nic->pdev),\n\t\tsizeof(info->bus_info));\n}\n\n#define E100_PHY_REGS 0x1D\nstatic int e100_get_regs_len(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\t \n\treturn (1 + E100_PHY_REGS) * sizeof(u32) + sizeof(nic->mem->dump_buf);\n}\n\nstatic void e100_get_regs(struct net_device *netdev,\n\tstruct ethtool_regs *regs, void *p)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tu32 *buff = p;\n\tint i;\n\n\tregs->version = (1 << 24) | nic->pdev->revision;\n\tbuff[0] = ioread8(&nic->csr->scb.cmd_hi) << 24 |\n\t\tioread8(&nic->csr->scb.cmd_lo) << 16 |\n\t\tioread16(&nic->csr->scb.status);\n\tfor (i = 0; i < E100_PHY_REGS; i++)\n\t\t \n\t\tbuff[1 + i] = mdio_read(netdev, nic->mii.phy_id,\n\t\t\t\t\tE100_PHY_REGS - 1 - i);\n\tmemset(nic->mem->dump_buf, 0, sizeof(nic->mem->dump_buf));\n\te100_exec_cb(nic, NULL, e100_dump);\n\tmsleep(10);\n\tmemcpy(&buff[1 + E100_PHY_REGS], nic->mem->dump_buf,\n\t       sizeof(nic->mem->dump_buf));\n}\n\nstatic void e100_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\twol->supported = (nic->mac >= mac_82558_D101_A4) ?  WAKE_MAGIC : 0;\n\twol->wolopts = (nic->flags & wol_magic) ? WAKE_MAGIC : 0;\n}\n\nstatic int e100_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tif ((wol->wolopts && wol->wolopts != WAKE_MAGIC) ||\n\t    !device_can_wakeup(&nic->pdev->dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (wol->wolopts)\n\t\tnic->flags |= wol_magic;\n\telse\n\t\tnic->flags &= ~wol_magic;\n\n\tdevice_set_wakeup_enable(&nic->pdev->dev, wol->wolopts);\n\n\te100_exec_cb(nic, NULL, e100_configure);\n\n\treturn 0;\n}\n\nstatic u32 e100_get_msglevel(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\treturn nic->msg_enable;\n}\n\nstatic void e100_set_msglevel(struct net_device *netdev, u32 value)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tnic->msg_enable = value;\n}\n\nstatic int e100_nway_reset(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\treturn mii_nway_restart(&nic->mii);\n}\n\nstatic u32 e100_get_link(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\treturn mii_link_ok(&nic->mii);\n}\n\nstatic int e100_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\treturn nic->eeprom_wc << 1;\n}\n\n#define E100_EEPROM_MAGIC\t0x1234\nstatic int e100_get_eeprom(struct net_device *netdev,\n\tstruct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\teeprom->magic = E100_EEPROM_MAGIC;\n\tmemcpy(bytes, &((u8 *)nic->eeprom)[eeprom->offset], eeprom->len);\n\n\treturn 0;\n}\n\nstatic int e100_set_eeprom(struct net_device *netdev,\n\tstruct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tif (eeprom->magic != E100_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\tmemcpy(&((u8 *)nic->eeprom)[eeprom->offset], bytes, eeprom->len);\n\n\treturn e100_eeprom_save(nic, eeprom->offset >> 1,\n\t\t(eeprom->len >> 1) + 1);\n}\n\nstatic void e100_get_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tstruct param_range *rfds = &nic->params.rfds;\n\tstruct param_range *cbs = &nic->params.cbs;\n\n\tring->rx_max_pending = rfds->max;\n\tring->tx_max_pending = cbs->max;\n\tring->rx_pending = rfds->count;\n\tring->tx_pending = cbs->count;\n}\n\nstatic int e100_set_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ring,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tstruct param_range *rfds = &nic->params.rfds;\n\tstruct param_range *cbs = &nic->params.cbs;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tif (netif_running(netdev))\n\t\te100_down(nic);\n\trfds->count = max(ring->rx_pending, rfds->min);\n\trfds->count = min(rfds->count, rfds->max);\n\tcbs->count = max(ring->tx_pending, cbs->min);\n\tcbs->count = min(cbs->count, cbs->max);\n\tnetif_info(nic, drv, nic->netdev, \"Ring Param settings: rx: %d, tx %d\\n\",\n\t\t   rfds->count, cbs->count);\n\tif (netif_running(netdev))\n\t\te100_up(nic);\n\n\treturn 0;\n}\n\nstatic const char e100_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Link test     (on/offline)\",\n\t\"Eeprom test   (on/offline)\",\n\t\"Self test        (offline)\",\n\t\"Mac loopback     (offline)\",\n\t\"Phy loopback     (offline)\",\n};\n#define E100_TEST_LEN\tARRAY_SIZE(e100_gstrings_test)\n\nstatic void e100_diag_test(struct net_device *netdev,\n\tstruct ethtool_test *test, u64 *data)\n{\n\tstruct ethtool_cmd cmd;\n\tstruct nic *nic = netdev_priv(netdev);\n\tint i;\n\n\tmemset(data, 0, E100_TEST_LEN * sizeof(u64));\n\tdata[0] = !mii_link_ok(&nic->mii);\n\tdata[1] = e100_eeprom_load(nic);\n\tif (test->flags & ETH_TEST_FL_OFFLINE) {\n\n\t\t \n\t\tmii_ethtool_gset(&nic->mii, &cmd);\n\n\t\tif (netif_running(netdev))\n\t\t\te100_down(nic);\n\t\tdata[2] = e100_self_test(nic);\n\t\tdata[3] = e100_loopback_test(nic, lb_mac);\n\t\tdata[4] = e100_loopback_test(nic, lb_phy);\n\n\t\t \n\t\tmii_ethtool_sset(&nic->mii, &cmd);\n\n\t\tif (netif_running(netdev))\n\t\t\te100_up(nic);\n\t}\n\tfor (i = 0; i < E100_TEST_LEN; i++)\n\t\ttest->flags |= data[i] ? ETH_TEST_FL_FAILED : 0;\n\n\tmsleep_interruptible(4 * 1000);\n}\n\nstatic int e100_set_phys_id(struct net_device *netdev,\n\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tenum led_state {\n\t\tled_on     = 0x01,\n\t\tled_off    = 0x04,\n\t\tled_on_559 = 0x05,\n\t\tled_on_557 = 0x07,\n\t};\n\tu16 led_reg = (nic->phy == phy_82552_v) ? E100_82552_LED_OVERRIDE :\n\t\tMII_LED_CONTROL;\n\tu16 leds = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 2;\n\n\tcase ETHTOOL_ID_ON:\n\t\tleds = (nic->phy == phy_82552_v) ? E100_82552_LED_ON :\n\t\t       (nic->mac < mac_82559_D101M) ? led_on_557 : led_on_559;\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tleds = (nic->phy == phy_82552_v) ? E100_82552_LED_OFF : led_off;\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tbreak;\n\t}\n\n\tmdio_write(netdev, nic->mii.phy_id, led_reg, leds);\n\treturn 0;\n}\n\nstatic const char e100_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"rx_packets\", \"tx_packets\", \"rx_bytes\", \"tx_bytes\", \"rx_errors\",\n\t\"tx_errors\", \"rx_dropped\", \"tx_dropped\", \"multicast\", \"collisions\",\n\t\"rx_length_errors\", \"rx_over_errors\", \"rx_crc_errors\",\n\t\"rx_frame_errors\", \"rx_fifo_errors\", \"rx_missed_errors\",\n\t\"tx_aborted_errors\", \"tx_carrier_errors\", \"tx_fifo_errors\",\n\t\"tx_heartbeat_errors\", \"tx_window_errors\",\n\t \n\t\"tx_deferred\", \"tx_single_collisions\", \"tx_multi_collisions\",\n\t\"tx_flow_control_pause\", \"rx_flow_control_pause\",\n\t\"rx_flow_control_unsupported\", \"tx_tco_packets\", \"rx_tco_packets\",\n\t\"rx_short_frame_errors\", \"rx_over_length_errors\",\n};\n#define E100_NET_STATS_LEN\t21\n#define E100_STATS_LEN\tARRAY_SIZE(e100_gstrings_stats)\n\nstatic int e100_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn E100_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn E100_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void e100_get_ethtool_stats(struct net_device *netdev,\n\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tint i;\n\n\tfor (i = 0; i < E100_NET_STATS_LEN; i++)\n\t\tdata[i] = ((unsigned long *)&netdev->stats)[i];\n\n\tdata[i++] = nic->tx_deferred;\n\tdata[i++] = nic->tx_single_collisions;\n\tdata[i++] = nic->tx_multiple_collisions;\n\tdata[i++] = nic->tx_fc_pause;\n\tdata[i++] = nic->rx_fc_pause;\n\tdata[i++] = nic->rx_fc_unsupported;\n\tdata[i++] = nic->tx_tco_frames;\n\tdata[i++] = nic->rx_tco_frames;\n\tdata[i++] = nic->rx_short_frame_errors;\n\tdata[i++] = nic->rx_over_length_errors;\n}\n\nstatic void e100_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, e100_gstrings_test, sizeof(e100_gstrings_test));\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, e100_gstrings_stats, sizeof(e100_gstrings_stats));\n\t\tbreak;\n\t}\n}\n\nstatic const struct ethtool_ops e100_ethtool_ops = {\n\t.get_drvinfo\t\t= e100_get_drvinfo,\n\t.get_regs_len\t\t= e100_get_regs_len,\n\t.get_regs\t\t= e100_get_regs,\n\t.get_wol\t\t= e100_get_wol,\n\t.set_wol\t\t= e100_set_wol,\n\t.get_msglevel\t\t= e100_get_msglevel,\n\t.set_msglevel\t\t= e100_set_msglevel,\n\t.nway_reset\t\t= e100_nway_reset,\n\t.get_link\t\t= e100_get_link,\n\t.get_eeprom_len\t\t= e100_get_eeprom_len,\n\t.get_eeprom\t\t= e100_get_eeprom,\n\t.set_eeprom\t\t= e100_set_eeprom,\n\t.get_ringparam\t\t= e100_get_ringparam,\n\t.set_ringparam\t\t= e100_set_ringparam,\n\t.self_test\t\t= e100_diag_test,\n\t.get_strings\t\t= e100_get_strings,\n\t.set_phys_id\t\t= e100_set_phys_id,\n\t.get_ethtool_stats\t= e100_get_ethtool_stats,\n\t.get_sset_count\t\t= e100_get_sset_count,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings\t= e100_get_link_ksettings,\n\t.set_link_ksettings\t= e100_set_link_ksettings,\n};\n\nstatic int e100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\n\treturn generic_mii_ioctl(&nic->mii, if_mii(ifr), cmd, NULL);\n}\n\nstatic int e100_alloc(struct nic *nic)\n{\n\tnic->mem = dma_alloc_coherent(&nic->pdev->dev, sizeof(struct mem),\n\t\t\t\t      &nic->dma_addr, GFP_KERNEL);\n\treturn nic->mem ? 0 : -ENOMEM;\n}\n\nstatic void e100_free(struct nic *nic)\n{\n\tif (nic->mem) {\n\t\tdma_free_coherent(&nic->pdev->dev, sizeof(struct mem),\n\t\t\t\t  nic->mem, nic->dma_addr);\n\t\tnic->mem = NULL;\n\t}\n}\n\nstatic int e100_open(struct net_device *netdev)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tint err = 0;\n\n\tnetif_carrier_off(netdev);\n\tif ((err = e100_up(nic)))\n\t\tnetif_err(nic, ifup, nic->netdev, \"Cannot open interface, aborting\\n\");\n\treturn err;\n}\n\nstatic int e100_close(struct net_device *netdev)\n{\n\te100_down(netdev_priv(netdev));\n\treturn 0;\n}\n\nstatic int e100_set_features(struct net_device *netdev,\n\t\t\t     netdev_features_t features)\n{\n\tstruct nic *nic = netdev_priv(netdev);\n\tnetdev_features_t changed = features ^ netdev->features;\n\n\tif (!(changed & (NETIF_F_RXFCS | NETIF_F_RXALL)))\n\t\treturn 0;\n\n\tnetdev->features = features;\n\te100_exec_cb(nic, NULL, e100_configure);\n\treturn 1;\n}\n\nstatic const struct net_device_ops e100_netdev_ops = {\n\t.ndo_open\t\t= e100_open,\n\t.ndo_stop\t\t= e100_close,\n\t.ndo_start_xmit\t\t= e100_xmit_frame,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= e100_set_multicast_list,\n\t.ndo_set_mac_address\t= e100_set_mac_address,\n\t.ndo_eth_ioctl\t\t= e100_do_ioctl,\n\t.ndo_tx_timeout\t\t= e100_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= e100_netpoll,\n#endif\n\t.ndo_set_features\t= e100_set_features,\n};\n\nstatic int e100_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct nic *nic;\n\tint err;\n\n\tif (!(netdev = alloc_etherdev(sizeof(struct nic))))\n\t\treturn -ENOMEM;\n\n\tnetdev->hw_features |= NETIF_F_RXFCS;\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\tnetdev->hw_features |= NETIF_F_RXALL;\n\n\tnetdev->netdev_ops = &e100_netdev_ops;\n\tnetdev->ethtool_ops = &e100_ethtool_ops;\n\tnetdev->watchdog_timeo = E100_WATCHDOG_PERIOD;\n\tstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\n\n\tnic = netdev_priv(netdev);\n\tnetif_napi_add_weight(netdev, &nic->napi, e100_poll, E100_NAPI_WEIGHT);\n\tnic->netdev = netdev;\n\tnic->pdev = pdev;\n\tnic->msg_enable = (1 << debug) - 1;\n\tnic->mdio_ctrl = mdio_ctrl_hw;\n\tpci_set_drvdata(pdev, netdev);\n\n\tif ((err = pci_enable_device(pdev))) {\n\t\tnetif_err(nic, probe, nic->netdev, \"Cannot enable PCI device, aborting\\n\");\n\t\tgoto err_out_free_dev;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tnetif_err(nic, probe, nic->netdev, \"Cannot find proper PCI device base address, aborting\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\tif ((err = pci_request_regions(pdev, DRV_NAME))) {\n\t\tnetif_err(nic, probe, nic->netdev, \"Cannot obtain PCI resources, aborting\\n\");\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\tif ((err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)))) {\n\t\tnetif_err(nic, probe, nic->netdev, \"No usable DMA configuration, aborting\\n\");\n\t\tgoto err_out_free_res;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tif (use_io)\n\t\tnetif_info(nic, probe, nic->netdev, \"using i/o access mode\\n\");\n\n\tnic->csr = pci_iomap(pdev, (use_io ? 1 : 0), sizeof(struct csr));\n\tif (!nic->csr) {\n\t\tnetif_err(nic, probe, nic->netdev, \"Cannot map device registers, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_res;\n\t}\n\n\tif (ent->driver_data)\n\t\tnic->flags |= ich;\n\telse\n\t\tnic->flags &= ~ich;\n\n\te100_get_defaults(nic);\n\n\t \n\tif (nic->mac < mac_82558_D101_A4)\n\t\tnetdev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t \n\tspin_lock_init(&nic->cb_lock);\n\tspin_lock_init(&nic->cmd_lock);\n\tspin_lock_init(&nic->mdio_lock);\n\n\t \n\te100_hw_reset(nic);\n\n\tpci_set_master(pdev);\n\n\ttimer_setup(&nic->watchdog, e100_watchdog, 0);\n\n\tINIT_WORK(&nic->tx_timeout_task, e100_tx_timeout_task);\n\n\tif ((err = e100_alloc(nic))) {\n\t\tnetif_err(nic, probe, nic->netdev, \"Cannot alloc driver memory, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\tif ((err = e100_eeprom_load(nic)))\n\t\tgoto err_out_free;\n\n\te100_phy_init(nic);\n\n\teth_hw_addr_set(netdev, (u8 *)nic->eeprom);\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\tif (!eeprom_bad_csum_allow) {\n\t\t\tnetif_err(nic, probe, nic->netdev, \"Invalid MAC address from EEPROM, aborting\\n\");\n\t\t\terr = -EAGAIN;\n\t\t\tgoto err_out_free;\n\t\t} else {\n\t\t\tnetif_err(nic, probe, nic->netdev, \"Invalid MAC address from EEPROM, you MUST configure one.\\n\");\n\t\t}\n\t}\n\n\t \n\tif ((nic->mac >= mac_82558_D101_A4) &&\n\t   (le16_to_cpu(nic->eeprom[eeprom_id]) & eeprom_id_wol)) {\n\t\tnic->flags |= wol_magic;\n\t\tdevice_set_wakeup_enable(&pdev->dev, true);\n\t}\n\n\t \n\tpci_pme_active(pdev, false);\n\n\tstrcpy(netdev->name, \"eth%d\");\n\tif ((err = register_netdev(netdev))) {\n\t\tnetif_err(nic, probe, nic->netdev, \"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_free;\n\t}\n\tnic->cbs_pool = dma_pool_create(netdev->name,\n\t\t\t   &nic->pdev->dev,\n\t\t\t   nic->params.cbs.max * sizeof(struct cb),\n\t\t\t   sizeof(u32),\n\t\t\t   0);\n\tif (!nic->cbs_pool) {\n\t\tnetif_err(nic, probe, nic->netdev, \"Cannot create DMA pool, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_pool;\n\t}\n\tnetif_info(nic, probe, nic->netdev,\n\t\t   \"addr 0x%llx, irq %d, MAC addr %pM\\n\",\n\t\t   (unsigned long long)pci_resource_start(pdev, use_io ? 1 : 0),\n\t\t   pdev->irq, netdev->dev_addr);\n\n\treturn 0;\n\nerr_out_pool:\n\tunregister_netdev(netdev);\nerr_out_free:\n\te100_free(nic);\nerr_out_iounmap:\n\tpci_iounmap(pdev, nic->csr);\nerr_out_free_res:\n\tpci_release_regions(pdev);\nerr_out_disable_pdev:\n\tpci_disable_device(pdev);\nerr_out_free_dev:\n\tfree_netdev(netdev);\n\treturn err;\n}\n\nstatic void e100_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\n\tif (netdev) {\n\t\tstruct nic *nic = netdev_priv(netdev);\n\t\tunregister_netdev(netdev);\n\t\te100_free(nic);\n\t\tpci_iounmap(pdev, nic->csr);\n\t\tdma_pool_destroy(nic->cbs_pool);\n\t\tfree_netdev(netdev);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\n#define E100_82552_SMARTSPEED   0x14    \n#define E100_82552_REV_ANEG     0x0200  \n#define E100_82552_ANEG_NOW     0x0400  \nstatic void __e100_shutdown(struct pci_dev *pdev, bool *enable_wake)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev))\n\t\te100_down(nic);\n\n\tif ((nic->flags & wol_magic) | e100_asf(nic)) {\n\t\t \n\t\tif (nic->phy == phy_82552_v) {\n\t\t\tu16 smartspeed = mdio_read(netdev, nic->mii.phy_id,\n\t\t\t                           E100_82552_SMARTSPEED);\n\n\t\t\tmdio_write(netdev, nic->mii.phy_id,\n\t\t\t           E100_82552_SMARTSPEED, smartspeed |\n\t\t\t           E100_82552_REV_ANEG | E100_82552_ANEG_NOW);\n\t\t}\n\t\t*enable_wake = true;\n\t} else {\n\t\t*enable_wake = false;\n\t}\n\n\tpci_disable_device(pdev);\n}\n\nstatic int __e100_power_off(struct pci_dev *pdev, bool wake)\n{\n\tif (wake)\n\t\treturn pci_prepare_to_sleep(pdev);\n\n\tpci_wake_from_d3(pdev, false);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused e100_suspend(struct device *dev_d)\n{\n\tbool wake;\n\n\t__e100_shutdown(to_pci_dev(dev_d), &wake);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused e100_resume(struct device *dev_d)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev_d);\n\tstruct nic *nic = netdev_priv(netdev);\n\tint err;\n\n\terr = pci_enable_device(to_pci_dev(dev_d));\n\tif (err) {\n\t\tnetdev_err(netdev, \"Resume cannot enable PCI device, aborting\\n\");\n\t\treturn err;\n\t}\n\tpci_set_master(to_pci_dev(dev_d));\n\n\t \n\tif (nic->phy == phy_82552_v) {\n\t\tu16 smartspeed = mdio_read(netdev, nic->mii.phy_id,\n\t\t                           E100_82552_SMARTSPEED);\n\n\t\tmdio_write(netdev, nic->mii.phy_id,\n\t\t           E100_82552_SMARTSPEED,\n\t\t           smartspeed & ~(E100_82552_REV_ANEG));\n\t}\n\n\tif (netif_running(netdev))\n\t\te100_up(nic);\n\n\tnetif_device_attach(netdev);\n\n\treturn 0;\n}\n\nstatic void e100_shutdown(struct pci_dev *pdev)\n{\n\tbool wake;\n\t__e100_shutdown(pdev, &wake);\n\tif (system_state == SYSTEM_POWER_OFF)\n\t\t__e100_power_off(pdev, wake);\n}\n\n \n \nstatic pci_ers_result_t e100_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tnetif_device_detach(netdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (netif_running(netdev))\n\t\te100_down(nic);\n\tpci_disable_device(pdev);\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t e100_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct nic *nic = netdev_priv(netdev);\n\n\tif (pci_enable_device(pdev)) {\n\t\tpr_err(\"Cannot re-enable PCI device after reset\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\tpci_set_master(pdev);\n\n\t \n\tif (0 != PCI_FUNC(pdev->devfn))\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\te100_hw_reset(nic);\n\te100_phy_init(nic);\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n \nstatic void e100_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct nic *nic = netdev_priv(netdev);\n\n\t \n\tpci_enable_wake(pdev, PCI_D0, 0);\n\n\tnetif_device_attach(netdev);\n\tif (netif_running(netdev)) {\n\t\te100_open(netdev);\n\t\tmod_timer(&nic->watchdog, jiffies);\n\t}\n}\n\nstatic const struct pci_error_handlers e100_err_handler = {\n\t.error_detected = e100_io_error_detected,\n\t.slot_reset = e100_io_slot_reset,\n\t.resume = e100_io_resume,\n};\n\nstatic SIMPLE_DEV_PM_OPS(e100_pm_ops, e100_suspend, e100_resume);\n\nstatic struct pci_driver e100_driver = {\n\t.name =         DRV_NAME,\n\t.id_table =     e100_id_table,\n\t.probe =        e100_probe,\n\t.remove =       e100_remove,\n\n\t \n\t.driver.pm =\t&e100_pm_ops,\n\n\t.shutdown =     e100_shutdown,\n\t.err_handler = &e100_err_handler,\n};\n\nstatic int __init e100_init_module(void)\n{\n\tif (((1 << debug) - 1) & NETIF_MSG_DRV) {\n\t\tpr_info(\"%s\\n\", DRV_DESCRIPTION);\n\t\tpr_info(\"%s\\n\", DRV_COPYRIGHT);\n\t}\n\treturn pci_register_driver(&e100_driver);\n}\n\nstatic void __exit e100_cleanup_module(void)\n{\n\tpci_unregister_driver(&e100_driver);\n}\n\nmodule_init(e100_init_module);\nmodule_exit(e100_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}