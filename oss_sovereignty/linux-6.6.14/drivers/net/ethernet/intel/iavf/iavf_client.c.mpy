{
  "module_name": "iavf_client.c",
  "hash_id": "af3a1aed1ad529dbc9305d5fec4fc1930636408d27252d9aea42219920bc13b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/iavf/iavf_client.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/errno.h>\n\n#include \"iavf.h\"\n#include \"iavf_prototype.h\"\n#include \"iavf_client.h\"\n\nstatic\nconst char iavf_client_interface_version_str[] = IAVF_CLIENT_VERSION_STR;\nstatic struct iavf_client *vf_registered_client;\nstatic LIST_HEAD(iavf_devices);\nstatic DEFINE_MUTEX(iavf_device_mutex);\n\nstatic u32 iavf_client_virtchnl_send(struct iavf_info *ldev,\n\t\t\t\t     struct iavf_client *client,\n\t\t\t\t     u8 *msg, u16 len);\n\nstatic int iavf_client_setup_qvlist(struct iavf_info *ldev,\n\t\t\t\t    struct iavf_client *client,\n\t\t\t\t    struct iavf_qvlist_info *qvlist_info);\n\nstatic struct iavf_ops iavf_lan_ops = {\n\t.virtchnl_send = iavf_client_virtchnl_send,\n\t.setup_qvlist = iavf_client_setup_qvlist,\n};\n\n \nstatic\nvoid iavf_client_get_params(struct iavf_vsi *vsi, struct iavf_params *params)\n{\n\tint i;\n\n\tmemset(params, 0, sizeof(struct iavf_params));\n\tparams->mtu = vsi->netdev->mtu;\n\tparams->link_up = vsi->back->link_up;\n\n\tfor (i = 0; i < IAVF_MAX_USER_PRIORITY; i++) {\n\t\tparams->qos.prio_qos[i].tc = 0;\n\t\tparams->qos.prio_qos[i].qs_handle = vsi->qs_handle;\n\t}\n}\n\n \nvoid iavf_notify_client_message(struct iavf_vsi *vsi, u8 *msg, u16 len)\n{\n\tstruct iavf_client_instance *cinst;\n\n\tif (!vsi)\n\t\treturn;\n\n\tcinst = vsi->back->cinst;\n\tif (!cinst || !cinst->client || !cinst->client->ops ||\n\t    !cinst->client->ops->virtchnl_receive) {\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Cannot locate client instance virtchnl_receive function\\n\");\n\t\treturn;\n\t}\n\tcinst->client->ops->virtchnl_receive(&cinst->lan_info,  cinst->client,\n\t\t\t\t\t     msg, len);\n}\n\n \nvoid iavf_notify_client_l2_params(struct iavf_vsi *vsi)\n{\n\tstruct iavf_client_instance *cinst;\n\tstruct iavf_params params;\n\n\tif (!vsi)\n\t\treturn;\n\n\tcinst = vsi->back->cinst;\n\n\tif (!cinst || !cinst->client || !cinst->client->ops ||\n\t    !cinst->client->ops->l2_param_change) {\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Cannot locate client instance l2_param_change function\\n\");\n\t\treturn;\n\t}\n\tiavf_client_get_params(vsi, &params);\n\tcinst->lan_info.params = params;\n\tcinst->client->ops->l2_param_change(&cinst->lan_info, cinst->client,\n\t\t\t\t\t    &params);\n}\n\n \nvoid iavf_notify_client_open(struct iavf_vsi *vsi)\n{\n\tstruct iavf_adapter *adapter = vsi->back;\n\tstruct iavf_client_instance *cinst = adapter->cinst;\n\tint ret;\n\n\tif (!cinst || !cinst->client || !cinst->client->ops ||\n\t    !cinst->client->ops->open) {\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Cannot locate client instance open function\\n\");\n\t\treturn;\n\t}\n\tif (!(test_bit(__IAVF_CLIENT_INSTANCE_OPENED, &cinst->state))) {\n\t\tret = cinst->client->ops->open(&cinst->lan_info, cinst->client);\n\t\tif (!ret)\n\t\t\tset_bit(__IAVF_CLIENT_INSTANCE_OPENED, &cinst->state);\n\t}\n}\n\n \nstatic int iavf_client_release_qvlist(struct iavf_info *ldev)\n{\n\tstruct iavf_adapter *adapter = ldev->vf;\n\tenum iavf_status err;\n\n\tif (adapter->aq_required)\n\t\treturn -EAGAIN;\n\n\terr = iavf_aq_send_msg_to_pf(&adapter->hw,\n\t\t\t\t     VIRTCHNL_OP_RELEASE_RDMA_IRQ_MAP,\n\t\t\t\t     IAVF_SUCCESS, NULL, 0, NULL);\n\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Unable to send RDMA vector release message to PF, error %d, aq status %d\\n\",\n\t\t\terr, adapter->hw.aq.asq_last_status);\n\n\treturn err;\n}\n\n \nvoid iavf_notify_client_close(struct iavf_vsi *vsi, bool reset)\n{\n\tstruct iavf_adapter *adapter = vsi->back;\n\tstruct iavf_client_instance *cinst = adapter->cinst;\n\n\tif (!cinst || !cinst->client || !cinst->client->ops ||\n\t    !cinst->client->ops->close) {\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Cannot locate client instance close function\\n\");\n\t\treturn;\n\t}\n\tcinst->client->ops->close(&cinst->lan_info, cinst->client, reset);\n\tiavf_client_release_qvlist(&cinst->lan_info);\n\tclear_bit(__IAVF_CLIENT_INSTANCE_OPENED, &cinst->state);\n}\n\n \nstatic struct iavf_client_instance *\niavf_client_add_instance(struct iavf_adapter *adapter)\n{\n\tstruct iavf_client_instance *cinst = NULL;\n\tstruct iavf_vsi *vsi = &adapter->vsi;\n\tstruct netdev_hw_addr *mac = NULL;\n\tstruct iavf_params params;\n\n\tif (!vf_registered_client)\n\t\tgoto out;\n\n\tif (adapter->cinst) {\n\t\tcinst = adapter->cinst;\n\t\tgoto out;\n\t}\n\n\tcinst = kzalloc(sizeof(*cinst), GFP_KERNEL);\n\tif (!cinst)\n\t\tgoto out;\n\n\tcinst->lan_info.vf = (void *)adapter;\n\tcinst->lan_info.netdev = vsi->netdev;\n\tcinst->lan_info.pcidev = adapter->pdev;\n\tcinst->lan_info.fid = 0;\n\tcinst->lan_info.ftype = IAVF_CLIENT_FTYPE_VF;\n\tcinst->lan_info.hw_addr = adapter->hw.hw_addr;\n\tcinst->lan_info.ops = &iavf_lan_ops;\n\tcinst->lan_info.version.major = IAVF_CLIENT_VERSION_MAJOR;\n\tcinst->lan_info.version.minor = IAVF_CLIENT_VERSION_MINOR;\n\tcinst->lan_info.version.build = IAVF_CLIENT_VERSION_BUILD;\n\tiavf_client_get_params(vsi, &params);\n\tcinst->lan_info.params = params;\n\tset_bit(__IAVF_CLIENT_INSTANCE_NONE, &cinst->state);\n\n\tcinst->lan_info.msix_count = adapter->num_rdma_msix;\n\tcinst->lan_info.msix_entries =\n\t\t\t&adapter->msix_entries[adapter->rdma_base_vector];\n\n\tmac = list_first_entry(&cinst->lan_info.netdev->dev_addrs.list,\n\t\t\t       struct netdev_hw_addr, list);\n\tif (mac)\n\t\tether_addr_copy(cinst->lan_info.lanmac, mac->addr);\n\telse\n\t\tdev_err(&adapter->pdev->dev, \"MAC address list is empty!\\n\");\n\n\tcinst->client = vf_registered_client;\n\tadapter->cinst = cinst;\nout:\n\treturn cinst;\n}\n\n \nstatic\nvoid iavf_client_del_instance(struct iavf_adapter *adapter)\n{\n\tkfree(adapter->cinst);\n\tadapter->cinst = NULL;\n}\n\n \nvoid iavf_client_subtask(struct iavf_adapter *adapter)\n{\n\tstruct iavf_client *client = vf_registered_client;\n\tstruct iavf_client_instance *cinst;\n\tint ret = 0;\n\n\tif (adapter->state < __IAVF_DOWN)\n\t\treturn;\n\n\t \n\tif (!client)\n\t\treturn;\n\n\t \n\tcinst = iavf_client_add_instance(adapter);\n\tif (!cinst)\n\t\treturn;\n\n\tdev_info(&adapter->pdev->dev, \"Added instance of Client %s\\n\",\n\t\t client->name);\n\n\tif (!test_bit(__IAVF_CLIENT_INSTANCE_OPENED, &cinst->state)) {\n\t\t \n\n\t\tif (client->ops && client->ops->open)\n\t\t\tret = client->ops->open(&cinst->lan_info, client);\n\t\tif (!ret)\n\t\t\tset_bit(__IAVF_CLIENT_INSTANCE_OPENED,\n\t\t\t\t&cinst->state);\n\t\telse\n\t\t\t \n\t\t\tiavf_client_del_instance(adapter);\n\t}\n}\n\n \nint iavf_lan_add_device(struct iavf_adapter *adapter)\n{\n\tstruct iavf_device *ldev;\n\tint ret = 0;\n\n\tmutex_lock(&iavf_device_mutex);\n\tlist_for_each_entry(ldev, &iavf_devices, list) {\n\t\tif (ldev->vf == adapter) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tldev = kzalloc(sizeof(*ldev), GFP_KERNEL);\n\tif (!ldev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tldev->vf = adapter;\n\tINIT_LIST_HEAD(&ldev->list);\n\tlist_add(&ldev->list, &iavf_devices);\n\tdev_info(&adapter->pdev->dev, \"Added LAN device bus=0x%02x dev=0x%02x func=0x%02x\\n\",\n\t\t adapter->hw.bus.bus_id, adapter->hw.bus.device,\n\t\t adapter->hw.bus.func);\n\n\t \n\tadapter->flags |= IAVF_FLAG_SERVICE_CLIENT_REQUESTED;\n\nout:\n\tmutex_unlock(&iavf_device_mutex);\n\treturn ret;\n}\n\n \nint iavf_lan_del_device(struct iavf_adapter *adapter)\n{\n\tstruct iavf_device *ldev, *tmp;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&iavf_device_mutex);\n\tlist_for_each_entry_safe(ldev, tmp, &iavf_devices, list) {\n\t\tif (ldev->vf == adapter) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Deleted LAN device bus=0x%02x dev=0x%02x func=0x%02x\\n\",\n\t\t\t\t adapter->hw.bus.bus_id, adapter->hw.bus.device,\n\t\t\t\t adapter->hw.bus.func);\n\t\t\tlist_del(&ldev->list);\n\t\t\tkfree(ldev);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&iavf_device_mutex);\n\treturn ret;\n}\n\n \nstatic void iavf_client_release(struct iavf_client *client)\n{\n\tstruct iavf_client_instance *cinst;\n\tstruct iavf_device *ldev;\n\tstruct iavf_adapter *adapter;\n\n\tmutex_lock(&iavf_device_mutex);\n\tlist_for_each_entry(ldev, &iavf_devices, list) {\n\t\tadapter = ldev->vf;\n\t\tcinst = adapter->cinst;\n\t\tif (!cinst)\n\t\t\tcontinue;\n\t\tif (test_bit(__IAVF_CLIENT_INSTANCE_OPENED, &cinst->state)) {\n\t\t\tif (client->ops && client->ops->close)\n\t\t\t\tclient->ops->close(&cinst->lan_info, client,\n\t\t\t\t\t\t   false);\n\t\t\tiavf_client_release_qvlist(&cinst->lan_info);\n\t\t\tclear_bit(__IAVF_CLIENT_INSTANCE_OPENED, &cinst->state);\n\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t \"Client %s instance closed\\n\", client->name);\n\t\t}\n\t\t \n\t\tiavf_client_del_instance(adapter);\n\t\tdev_info(&adapter->pdev->dev, \"Deleted client instance of Client %s\\n\",\n\t\t\t client->name);\n\t}\n\tmutex_unlock(&iavf_device_mutex);\n}\n\n \nstatic void iavf_client_prepare(struct iavf_client *client)\n{\n\tstruct iavf_device *ldev;\n\tstruct iavf_adapter *adapter;\n\n\tmutex_lock(&iavf_device_mutex);\n\tlist_for_each_entry(ldev, &iavf_devices, list) {\n\t\tadapter = ldev->vf;\n\t\t \n\t\tadapter->flags |= IAVF_FLAG_SERVICE_CLIENT_REQUESTED;\n\t}\n\tmutex_unlock(&iavf_device_mutex);\n}\n\n \nstatic u32 iavf_client_virtchnl_send(struct iavf_info *ldev,\n\t\t\t\t     struct iavf_client *client,\n\t\t\t\t     u8 *msg, u16 len)\n{\n\tstruct iavf_adapter *adapter = ldev->vf;\n\tenum iavf_status err;\n\n\tif (adapter->aq_required)\n\t\treturn -EAGAIN;\n\n\terr = iavf_aq_send_msg_to_pf(&adapter->hw, VIRTCHNL_OP_RDMA,\n\t\t\t\t     IAVF_SUCCESS, msg, len, NULL);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev, \"Unable to send RDMA message to PF, error %d, aq status %d\\n\",\n\t\t\terr, adapter->hw.aq.asq_last_status);\n\n\treturn err;\n}\n\n \nstatic int iavf_client_setup_qvlist(struct iavf_info *ldev,\n\t\t\t\t    struct iavf_client *client,\n\t\t\t\t    struct iavf_qvlist_info *qvlist_info)\n{\n\tstruct virtchnl_rdma_qvlist_info *v_qvlist_info;\n\tstruct iavf_adapter *adapter = ldev->vf;\n\tstruct iavf_qv_info *qv_info;\n\tenum iavf_status err;\n\tu32 v_idx, i;\n\tsize_t msg_size;\n\n\tif (adapter->aq_required)\n\t\treturn -EAGAIN;\n\n\t \n\tfor (i = 0; i < qvlist_info->num_vectors; i++) {\n\t\tqv_info = &qvlist_info->qv_info[i];\n\t\tif (!qv_info)\n\t\t\tcontinue;\n\t\tv_idx = qv_info->v_idx;\n\t\tif ((v_idx >=\n\t\t    (adapter->rdma_base_vector + adapter->num_rdma_msix)) ||\n\t\t    (v_idx < adapter->rdma_base_vector))\n\t\t\treturn -EINVAL;\n\t}\n\n\tv_qvlist_info = (struct virtchnl_rdma_qvlist_info *)qvlist_info;\n\tmsg_size = virtchnl_struct_size(v_qvlist_info, qv_info,\n\t\t\t\t\tv_qvlist_info->num_vectors);\n\n\tadapter->client_pending |= BIT(VIRTCHNL_OP_CONFIG_RDMA_IRQ_MAP);\n\terr = iavf_aq_send_msg_to_pf(&adapter->hw,\n\t\t\t\tVIRTCHNL_OP_CONFIG_RDMA_IRQ_MAP, IAVF_SUCCESS,\n\t\t\t\t(u8 *)v_qvlist_info, msg_size, NULL);\n\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Unable to send RDMA vector config message to PF, error %d, aq status %d\\n\",\n\t\t\terr, adapter->hw.aq.asq_last_status);\n\t\tgoto out;\n\t}\n\n\terr = -EBUSY;\n\tfor (i = 0; i < 5; i++) {\n\t\tmsleep(100);\n\t\tif (!(adapter->client_pending &\n\t\t      BIT(VIRTCHNL_OP_CONFIG_RDMA_IRQ_MAP))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\n \nint iavf_register_client(struct iavf_client *client)\n{\n\tint ret = 0;\n\n\tif (!client) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (strlen(client->name) == 0) {\n\t\tpr_info(\"iavf: Failed to register client with no name\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (vf_registered_client) {\n\t\tpr_info(\"iavf: Client %s has already been registered!\\n\",\n\t\t\tclient->name);\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif ((client->version.major != IAVF_CLIENT_VERSION_MAJOR) ||\n\t    (client->version.minor != IAVF_CLIENT_VERSION_MINOR)) {\n\t\tpr_info(\"iavf: Failed to register client %s due to mismatched client interface version\\n\",\n\t\t\tclient->name);\n\t\tpr_info(\"Client is using version: %02d.%02d.%02d while LAN driver supports %s\\n\",\n\t\t\tclient->version.major, client->version.minor,\n\t\t\tclient->version.build,\n\t\t\tiavf_client_interface_version_str);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tvf_registered_client = client;\n\n\tiavf_client_prepare(client);\n\n\tpr_info(\"iavf: Registered client %s with return code %d\\n\",\n\t\tclient->name, ret);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(iavf_register_client);\n\n \nint iavf_unregister_client(struct iavf_client *client)\n{\n\tint ret = 0;\n\n\t \n\tiavf_client_release(client);\n\n\tif (vf_registered_client != client) {\n\t\tpr_info(\"iavf: Client %s has not been registered\\n\",\n\t\t\tclient->name);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tvf_registered_client = NULL;\n\tpr_info(\"iavf: Unregistered client %s\\n\", client->name);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(iavf_unregister_client);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}