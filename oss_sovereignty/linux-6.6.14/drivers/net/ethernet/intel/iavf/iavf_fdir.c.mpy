{
  "module_name": "iavf_fdir.c",
  "hash_id": "b227d7b122fb114ca500f023545071efe573ebd74cd72cca7a90e643a1fa8b48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/iavf/iavf_fdir.c",
  "human_readable_source": "\n \n\n \n\n#include \"iavf.h\"\n\n#define GTPU_PORT\t2152\n#define NAT_T_ESP_PORT\t4500\n#define PFCP_PORT\t8805\n\nstatic const struct in6_addr ipv6_addr_full_mask = {\n\t.in6_u = {\n\t\t.u6_addr8 = {\n\t\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t}\n\t}\n};\n\nstatic const struct in6_addr ipv6_addr_zero_mask = {\n\t.in6_u = {\n\t\t.u6_addr8 = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t}\n\t}\n};\n\n \nint iavf_validate_fdir_fltr_masks(struct iavf_adapter *adapter,\n\t\t\t\t  struct iavf_fdir_fltr *fltr)\n{\n\tif (fltr->eth_mask.etype && fltr->eth_mask.etype != htons(U16_MAX))\n\t\tgoto partial_mask;\n\n\tif (fltr->ip_ver == 4) {\n\t\tif (fltr->ip_mask.v4_addrs.src_ip &&\n\t\t    fltr->ip_mask.v4_addrs.src_ip != htonl(U32_MAX))\n\t\t\tgoto partial_mask;\n\n\t\tif (fltr->ip_mask.v4_addrs.dst_ip &&\n\t\t    fltr->ip_mask.v4_addrs.dst_ip != htonl(U32_MAX))\n\t\t\tgoto partial_mask;\n\n\t\tif (fltr->ip_mask.tos && fltr->ip_mask.tos != U8_MAX)\n\t\t\tgoto partial_mask;\n\t} else if (fltr->ip_ver == 6) {\n\t\tif (memcmp(&fltr->ip_mask.v6_addrs.src_ip, &ipv6_addr_zero_mask,\n\t\t\t   sizeof(struct in6_addr)) &&\n\t\t    memcmp(&fltr->ip_mask.v6_addrs.src_ip, &ipv6_addr_full_mask,\n\t\t\t   sizeof(struct in6_addr)))\n\t\t\tgoto partial_mask;\n\n\t\tif (memcmp(&fltr->ip_mask.v6_addrs.dst_ip, &ipv6_addr_zero_mask,\n\t\t\t   sizeof(struct in6_addr)) &&\n\t\t    memcmp(&fltr->ip_mask.v6_addrs.dst_ip, &ipv6_addr_full_mask,\n\t\t\t   sizeof(struct in6_addr)))\n\t\t\tgoto partial_mask;\n\n\t\tif (fltr->ip_mask.tclass && fltr->ip_mask.tclass != U8_MAX)\n\t\t\tgoto partial_mask;\n\t}\n\n\tif (fltr->ip_mask.proto && fltr->ip_mask.proto != U8_MAX)\n\t\tgoto partial_mask;\n\n\tif (fltr->ip_mask.src_port && fltr->ip_mask.src_port != htons(U16_MAX))\n\t\tgoto partial_mask;\n\n\tif (fltr->ip_mask.dst_port && fltr->ip_mask.dst_port != htons(U16_MAX))\n\t\tgoto partial_mask;\n\n\tif (fltr->ip_mask.spi && fltr->ip_mask.spi != htonl(U32_MAX))\n\t\tgoto partial_mask;\n\n\tif (fltr->ip_mask.l4_header &&\n\t    fltr->ip_mask.l4_header != htonl(U32_MAX))\n\t\tgoto partial_mask;\n\n\treturn 0;\n\npartial_mask:\n\tdev_err(&adapter->pdev->dev, \"Failed to add Flow Director filter, partial masks are not supported\\n\");\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic u16 iavf_pkt_udp_no_pay_len(struct iavf_fdir_fltr *fltr)\n{\n\treturn sizeof(struct ethhdr) +\n\t       (fltr->ip_ver == 4 ? sizeof(struct iphdr) : sizeof(struct ipv6hdr)) +\n\t       sizeof(struct udphdr);\n}\n\n \nstatic int\niavf_fill_fdir_gtpu_hdr(struct iavf_fdir_fltr *fltr,\n\t\t\tstruct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *uhdr = &proto_hdrs->proto_hdr[proto_hdrs->count - 1];\n\tstruct virtchnl_proto_hdr *ghdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct virtchnl_proto_hdr *ehdr = NULL;  \n\tu16 adj_offs, hdr_offs;\n\tint i;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(ghdr, GTPU_IP);\n\n\tadj_offs = iavf_pkt_udp_no_pay_len(fltr);\n\n\tfor (i = 0; i < fltr->flex_cnt; i++) {\n#define IAVF_GTPU_HDR_TEID_OFFS0\t4\n#define IAVF_GTPU_HDR_TEID_OFFS1\t6\n#define IAVF_GTPU_HDR_N_PDU_AND_NEXT_EXTHDR_OFFS\t10\n#define IAVF_GTPU_HDR_NEXT_EXTHDR_TYPE_MASK\t\t0x00FF  \n \n#define IAVF_GTPU_PSC_EXTHDR_TYPE\t\t\t0x85\n#define IAVF_GTPU_HDR_PSC_PDU_TYPE_AND_QFI_OFFS\t\t13\n#define IAVF_GTPU_HDR_PSC_PDU_QFI_MASK\t\t\t0x3F  \n#define IAVF_GTPU_EH_QFI_IDX\t\t\t\t1\n\n\t\tif (fltr->flex_words[i].offset < adj_offs)\n\t\t\treturn -EINVAL;\n\n\t\thdr_offs = fltr->flex_words[i].offset - adj_offs;\n\n\t\tswitch (hdr_offs) {\n\t\tcase IAVF_GTPU_HDR_TEID_OFFS0:\n\t\tcase IAVF_GTPU_HDR_TEID_OFFS1: {\n\t\t\t__be16 *pay_word = (__be16 *)ghdr->buffer;\n\n\t\t\tpay_word[hdr_offs >> 1] = htons(fltr->flex_words[i].word);\n\t\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(ghdr, GTPU_IP, TEID);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IAVF_GTPU_HDR_N_PDU_AND_NEXT_EXTHDR_OFFS:\n\t\t\tif ((fltr->flex_words[i].word &\n\t\t\t     IAVF_GTPU_HDR_NEXT_EXTHDR_TYPE_MASK) !=\n\t\t\t\t\t\tIAVF_GTPU_PSC_EXTHDR_TYPE)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tif (!ehdr)\n\t\t\t\tehdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\t\t\tVIRTCHNL_SET_PROTO_HDR_TYPE(ehdr, GTPU_EH);\n\t\t\tbreak;\n\t\tcase IAVF_GTPU_HDR_PSC_PDU_TYPE_AND_QFI_OFFS:\n\t\t\tif (!ehdr)\n\t\t\t\treturn -EINVAL;\n\t\t\tehdr->buffer[IAVF_GTPU_EH_QFI_IDX] =\n\t\t\t\t\tfltr->flex_words[i].word &\n\t\t\t\t\t\tIAVF_GTPU_HDR_PSC_PDU_QFI_MASK;\n\t\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(ehdr, GTPU_EH, QFI);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tuhdr->field_selector = 0;  \n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_pfcp_hdr(struct iavf_fdir_fltr *fltr,\n\t\t\tstruct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *uhdr = &proto_hdrs->proto_hdr[proto_hdrs->count - 1];\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tu16 adj_offs, hdr_offs;\n\tint i;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, PFCP);\n\n\tadj_offs = iavf_pkt_udp_no_pay_len(fltr);\n\n\tfor (i = 0; i < fltr->flex_cnt; i++) {\n#define IAVF_PFCP_HDR_SFIELD_AND_MSG_TYPE_OFFS\t0\n\t\tif (fltr->flex_words[i].offset < adj_offs)\n\t\t\treturn -EINVAL;\n\n\t\thdr_offs = fltr->flex_words[i].offset - adj_offs;\n\n\t\tswitch (hdr_offs) {\n\t\tcase IAVF_PFCP_HDR_SFIELD_AND_MSG_TYPE_OFFS:\n\t\t\thdr->buffer[0] = (fltr->flex_words[i].word >> 8) & 0xff;\n\t\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, PFCP, S_FIELD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tuhdr->field_selector = 0;  \n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_nat_t_esp_hdr(struct iavf_fdir_fltr *fltr,\n\t\t\t     struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *uhdr = &proto_hdrs->proto_hdr[proto_hdrs->count - 1];\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tu16 adj_offs, hdr_offs;\n\tu32 spi = 0;\n\tint i;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, ESP);\n\n\tadj_offs = iavf_pkt_udp_no_pay_len(fltr);\n\n\tfor (i = 0; i < fltr->flex_cnt; i++) {\n#define IAVF_NAT_T_ESP_SPI_OFFS0\t0\n#define IAVF_NAT_T_ESP_SPI_OFFS1\t2\n\t\tif (fltr->flex_words[i].offset < adj_offs)\n\t\t\treturn -EINVAL;\n\n\t\thdr_offs = fltr->flex_words[i].offset - adj_offs;\n\n\t\tswitch (hdr_offs) {\n\t\tcase IAVF_NAT_T_ESP_SPI_OFFS0:\n\t\t\tspi |= fltr->flex_words[i].word << 16;\n\t\t\tbreak;\n\t\tcase IAVF_NAT_T_ESP_SPI_OFFS1:\n\t\t\tspi |= fltr->flex_words[i].word;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!spi)\n\t\treturn -EOPNOTSUPP;  \n\n\t*(__be32 *)hdr->buffer = htonl(spi);\n\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, ESP, SPI);\n\n\tuhdr->field_selector = 0;  \n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_udp_flex_pay_hdr(struct iavf_fdir_fltr *fltr,\n\t\t\t\tstruct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tint err;\n\n\tswitch (ntohs(fltr->ip_data.dst_port)) {\n\tcase GTPU_PORT:\n\t\terr = iavf_fill_fdir_gtpu_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase NAT_T_ESP_PORT:\n\t\terr = iavf_fill_fdir_nat_t_esp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase PFCP_PORT:\n\t\terr = iavf_fill_fdir_pfcp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int\niavf_fill_fdir_ip4_hdr(struct iavf_fdir_fltr *fltr,\n\t\t       struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct iphdr *iph = (struct iphdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, IPV4);\n\n\tif (fltr->ip_mask.tos == U8_MAX) {\n\t\tiph->tos = fltr->ip_data.tos;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV4, DSCP);\n\t}\n\n\tif (fltr->ip_mask.proto == U8_MAX) {\n\t\tiph->protocol = fltr->ip_data.proto;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV4, PROT);\n\t}\n\n\tif (fltr->ip_mask.v4_addrs.src_ip == htonl(U32_MAX)) {\n\t\tiph->saddr = fltr->ip_data.v4_addrs.src_ip;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV4, SRC);\n\t}\n\n\tif (fltr->ip_mask.v4_addrs.dst_ip == htonl(U32_MAX)) {\n\t\tiph->daddr = fltr->ip_data.v4_addrs.dst_ip;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV4, DST);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_ip6_hdr(struct iavf_fdir_fltr *fltr,\n\t\t       struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct ipv6hdr *iph = (struct ipv6hdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, IPV6);\n\n\tif (fltr->ip_mask.tclass == U8_MAX) {\n\t\tiph->priority = (fltr->ip_data.tclass >> 4) & 0xF;\n\t\tiph->flow_lbl[0] = (fltr->ip_data.tclass << 4) & 0xF0;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV6, TC);\n\t}\n\n\tif (fltr->ip_mask.proto == U8_MAX) {\n\t\tiph->nexthdr = fltr->ip_data.proto;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV6, PROT);\n\t}\n\n\tif (!memcmp(&fltr->ip_mask.v6_addrs.src_ip, &ipv6_addr_full_mask,\n\t\t    sizeof(struct in6_addr))) {\n\t\tmemcpy(&iph->saddr, &fltr->ip_data.v6_addrs.src_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV6, SRC);\n\t}\n\n\tif (!memcmp(&fltr->ip_mask.v6_addrs.dst_ip, &ipv6_addr_full_mask,\n\t\t    sizeof(struct in6_addr))) {\n\t\tmemcpy(&iph->daddr, &fltr->ip_data.v6_addrs.dst_ip,\n\t\t       sizeof(struct in6_addr));\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, IPV6, DST);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_tcp_hdr(struct iavf_fdir_fltr *fltr,\n\t\t       struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct tcphdr *tcph = (struct tcphdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, TCP);\n\n\tif (fltr->ip_mask.src_port == htons(U16_MAX)) {\n\t\ttcph->source = fltr->ip_data.src_port;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, TCP, SRC_PORT);\n\t}\n\n\tif (fltr->ip_mask.dst_port == htons(U16_MAX)) {\n\t\ttcph->dest = fltr->ip_data.dst_port;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, TCP, DST_PORT);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_udp_hdr(struct iavf_fdir_fltr *fltr,\n\t\t       struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct udphdr *udph = (struct udphdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, UDP);\n\n\tif (fltr->ip_mask.src_port == htons(U16_MAX)) {\n\t\tudph->source = fltr->ip_data.src_port;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, UDP, SRC_PORT);\n\t}\n\n\tif (fltr->ip_mask.dst_port == htons(U16_MAX)) {\n\t\tudph->dest = fltr->ip_data.dst_port;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, UDP, DST_PORT);\n\t}\n\n\tif (!fltr->flex_cnt)\n\t\treturn 0;\n\n\treturn iavf_fill_fdir_udp_flex_pay_hdr(fltr, proto_hdrs);\n}\n\n \nstatic int\niavf_fill_fdir_sctp_hdr(struct iavf_fdir_fltr *fltr,\n\t\t\tstruct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct sctphdr *sctph = (struct sctphdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, SCTP);\n\n\tif (fltr->ip_mask.src_port == htons(U16_MAX)) {\n\t\tsctph->source = fltr->ip_data.src_port;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, SCTP, SRC_PORT);\n\t}\n\n\tif (fltr->ip_mask.dst_port == htons(U16_MAX)) {\n\t\tsctph->dest = fltr->ip_data.dst_port;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, SCTP, DST_PORT);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_ah_hdr(struct iavf_fdir_fltr *fltr,\n\t\t      struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct ip_auth_hdr *ah = (struct ip_auth_hdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, AH);\n\n\tif (fltr->ip_mask.spi == htonl(U32_MAX)) {\n\t\tah->spi = fltr->ip_data.spi;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, AH, SPI);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_esp_hdr(struct iavf_fdir_fltr *fltr,\n\t\t       struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct ip_esp_hdr *esph = (struct ip_esp_hdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, ESP);\n\n\tif (fltr->ip_mask.spi == htonl(U32_MAX)) {\n\t\tesph->spi = fltr->ip_data.spi;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, ESP, SPI);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_l4_hdr(struct iavf_fdir_fltr *fltr,\n\t\t      struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr;\n\t__be32 *l4_4_data;\n\n\tif (!fltr->ip_mask.proto)  \n\t\treturn 0;\n\n\thdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tl4_4_data = (__be32 *)hdr->buffer;\n\n\t \n\tif (fltr->ip_data.proto == 115 && fltr->ip_mask.l4_header == htonl(U32_MAX)) {\n\t\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, L2TPV3);\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, L2TPV3, SESS_ID);\n\n\t\t*l4_4_data = fltr->ip_data.l4_header;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_fill_fdir_eth_hdr(struct iavf_fdir_fltr *fltr,\n\t\t       struct virtchnl_proto_hdrs *proto_hdrs)\n{\n\tstruct virtchnl_proto_hdr *hdr = &proto_hdrs->proto_hdr[proto_hdrs->count++];\n\tstruct ethhdr *ehdr = (struct ethhdr *)hdr->buffer;\n\n\tVIRTCHNL_SET_PROTO_HDR_TYPE(hdr, ETH);\n\n\tif (fltr->eth_mask.etype == htons(U16_MAX)) {\n\t\tif (fltr->eth_data.etype == htons(ETH_P_IP) ||\n\t\t    fltr->eth_data.etype == htons(ETH_P_IPV6))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tehdr->h_proto = fltr->eth_data.etype;\n\t\tVIRTCHNL_ADD_PROTO_HDR_FIELD_BIT(hdr, ETH, ETHERTYPE);\n\t}\n\n\treturn 0;\n}\n\n \nint iavf_fill_fdir_add_msg(struct iavf_adapter *adapter, struct iavf_fdir_fltr *fltr)\n{\n\tstruct virtchnl_fdir_add *vc_msg = &fltr->vc_add_msg;\n\tstruct virtchnl_proto_hdrs *proto_hdrs;\n\tint err;\n\n\tproto_hdrs = &vc_msg->rule_cfg.proto_hdrs;\n\n\terr = iavf_fill_fdir_eth_hdr(fltr, proto_hdrs);  \n\tif (err)\n\t\treturn err;\n\n\tswitch (fltr->flow_type) {\n\tcase IAVF_FDIR_FLOW_IPV4_TCP:\n\t\terr = iavf_fill_fdir_ip4_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_tcp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV4_UDP:\n\t\terr = iavf_fill_fdir_ip4_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_udp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV4_SCTP:\n\t\terr = iavf_fill_fdir_ip4_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_sctp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV4_AH:\n\t\terr = iavf_fill_fdir_ip4_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_ah_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV4_ESP:\n\t\terr = iavf_fill_fdir_ip4_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_esp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV4_OTHER:\n\t\terr = iavf_fill_fdir_ip4_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_l4_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_TCP:\n\t\terr = iavf_fill_fdir_ip6_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_tcp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_UDP:\n\t\terr = iavf_fill_fdir_ip6_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_udp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_SCTP:\n\t\terr = iavf_fill_fdir_ip6_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_sctp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_AH:\n\t\terr = iavf_fill_fdir_ip6_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_ah_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_ESP:\n\t\terr = iavf_fill_fdir_ip6_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_esp_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_OTHER:\n\t\terr = iavf_fill_fdir_ip6_hdr(fltr, proto_hdrs) |\n\t\t      iavf_fill_fdir_l4_hdr(fltr, proto_hdrs);\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_NON_IP_L2:\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tvc_msg->vsi_id = adapter->vsi.id;\n\tvc_msg->rule_cfg.action_set.count = 1;\n\tvc_msg->rule_cfg.action_set.actions[0].type = fltr->action;\n\tvc_msg->rule_cfg.action_set.actions[0].act_conf.queue.index = fltr->q_index;\n\n\treturn 0;\n}\n\n \nstatic const char *iavf_fdir_flow_proto_name(enum iavf_fdir_flow_type flow_type)\n{\n\tswitch (flow_type) {\n\tcase IAVF_FDIR_FLOW_IPV4_TCP:\n\tcase IAVF_FDIR_FLOW_IPV6_TCP:\n\t\treturn \"TCP\";\n\tcase IAVF_FDIR_FLOW_IPV4_UDP:\n\tcase IAVF_FDIR_FLOW_IPV6_UDP:\n\t\treturn \"UDP\";\n\tcase IAVF_FDIR_FLOW_IPV4_SCTP:\n\tcase IAVF_FDIR_FLOW_IPV6_SCTP:\n\t\treturn \"SCTP\";\n\tcase IAVF_FDIR_FLOW_IPV4_AH:\n\tcase IAVF_FDIR_FLOW_IPV6_AH:\n\t\treturn \"AH\";\n\tcase IAVF_FDIR_FLOW_IPV4_ESP:\n\tcase IAVF_FDIR_FLOW_IPV6_ESP:\n\t\treturn \"ESP\";\n\tcase IAVF_FDIR_FLOW_IPV4_OTHER:\n\tcase IAVF_FDIR_FLOW_IPV6_OTHER:\n\t\treturn \"Other\";\n\tcase IAVF_FDIR_FLOW_NON_IP_L2:\n\t\treturn \"Ethernet\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nvoid iavf_print_fdir_fltr(struct iavf_adapter *adapter, struct iavf_fdir_fltr *fltr)\n{\n\tconst char *proto = iavf_fdir_flow_proto_name(fltr->flow_type);\n\n\tif (!proto)\n\t\treturn;\n\n\tswitch (fltr->flow_type) {\n\tcase IAVF_FDIR_FLOW_IPV4_TCP:\n\tcase IAVF_FDIR_FLOW_IPV4_UDP:\n\tcase IAVF_FDIR_FLOW_IPV4_SCTP:\n\t\tdev_info(&adapter->pdev->dev, \"Rule ID: %u dst_ip: %pI4 src_ip %pI4 %s: dst_port %hu src_port %hu\\n\",\n\t\t\t fltr->loc,\n\t\t\t &fltr->ip_data.v4_addrs.dst_ip,\n\t\t\t &fltr->ip_data.v4_addrs.src_ip,\n\t\t\t proto,\n\t\t\t ntohs(fltr->ip_data.dst_port),\n\t\t\t ntohs(fltr->ip_data.src_port));\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV4_AH:\n\tcase IAVF_FDIR_FLOW_IPV4_ESP:\n\t\tdev_info(&adapter->pdev->dev, \"Rule ID: %u dst_ip: %pI4 src_ip %pI4 %s: SPI %u\\n\",\n\t\t\t fltr->loc,\n\t\t\t &fltr->ip_data.v4_addrs.dst_ip,\n\t\t\t &fltr->ip_data.v4_addrs.src_ip,\n\t\t\t proto,\n\t\t\t ntohl(fltr->ip_data.spi));\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV4_OTHER:\n\t\tdev_info(&adapter->pdev->dev, \"Rule ID: %u dst_ip: %pI4 src_ip %pI4 proto: %u L4_bytes: 0x%x\\n\",\n\t\t\t fltr->loc,\n\t\t\t &fltr->ip_data.v4_addrs.dst_ip,\n\t\t\t &fltr->ip_data.v4_addrs.src_ip,\n\t\t\t fltr->ip_data.proto,\n\t\t\t ntohl(fltr->ip_data.l4_header));\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_TCP:\n\tcase IAVF_FDIR_FLOW_IPV6_UDP:\n\tcase IAVF_FDIR_FLOW_IPV6_SCTP:\n\t\tdev_info(&adapter->pdev->dev, \"Rule ID: %u dst_ip: %pI6 src_ip %pI6 %s: dst_port %hu src_port %hu\\n\",\n\t\t\t fltr->loc,\n\t\t\t &fltr->ip_data.v6_addrs.dst_ip,\n\t\t\t &fltr->ip_data.v6_addrs.src_ip,\n\t\t\t proto,\n\t\t\t ntohs(fltr->ip_data.dst_port),\n\t\t\t ntohs(fltr->ip_data.src_port));\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_AH:\n\tcase IAVF_FDIR_FLOW_IPV6_ESP:\n\t\tdev_info(&adapter->pdev->dev, \"Rule ID: %u dst_ip: %pI6 src_ip %pI6 %s: SPI %u\\n\",\n\t\t\t fltr->loc,\n\t\t\t &fltr->ip_data.v6_addrs.dst_ip,\n\t\t\t &fltr->ip_data.v6_addrs.src_ip,\n\t\t\t proto,\n\t\t\t ntohl(fltr->ip_data.spi));\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_IPV6_OTHER:\n\t\tdev_info(&adapter->pdev->dev, \"Rule ID: %u dst_ip: %pI6 src_ip %pI6 proto: %u L4_bytes: 0x%x\\n\",\n\t\t\t fltr->loc,\n\t\t\t &fltr->ip_data.v6_addrs.dst_ip,\n\t\t\t &fltr->ip_data.v6_addrs.src_ip,\n\t\t\t fltr->ip_data.proto,\n\t\t\t ntohl(fltr->ip_data.l4_header));\n\t\tbreak;\n\tcase IAVF_FDIR_FLOW_NON_IP_L2:\n\t\tdev_info(&adapter->pdev->dev, \"Rule ID: %u eth_type: 0x%x\\n\",\n\t\t\t fltr->loc,\n\t\t\t ntohs(fltr->eth_data.etype));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nbool iavf_fdir_is_dup_fltr(struct iavf_adapter *adapter, struct iavf_fdir_fltr *fltr)\n{\n\tstruct iavf_fdir_fltr *tmp;\n\tbool ret = false;\n\n\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\tlist_for_each_entry(tmp, &adapter->fdir_list_head, list) {\n\t\tif (tmp->flow_type != fltr->flow_type)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(&tmp->eth_data, &fltr->eth_data,\n\t\t\t    sizeof(fltr->eth_data)) &&\n\t\t    !memcmp(&tmp->ip_data, &fltr->ip_data,\n\t\t\t    sizeof(fltr->ip_data)) &&\n\t\t    !memcmp(&tmp->ext_data, &fltr->ext_data,\n\t\t\t    sizeof(fltr->ext_data))) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\n\treturn ret;\n}\n\n \nstruct iavf_fdir_fltr *iavf_find_fdir_fltr_by_loc(struct iavf_adapter *adapter, u32 loc)\n{\n\tstruct iavf_fdir_fltr *rule;\n\n\tlist_for_each_entry(rule, &adapter->fdir_list_head, list)\n\t\tif (rule->loc == loc)\n\t\t\treturn rule;\n\n\treturn NULL;\n}\n\n \nvoid iavf_fdir_list_add_fltr(struct iavf_adapter *adapter, struct iavf_fdir_fltr *fltr)\n{\n\tstruct iavf_fdir_fltr *rule, *parent = NULL;\n\n\tlist_for_each_entry(rule, &adapter->fdir_list_head, list) {\n\t\tif (rule->loc >= fltr->loc)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\tif (parent)\n\t\tlist_add(&fltr->list, &parent->list);\n\telse\n\t\tlist_add(&fltr->list, &adapter->fdir_list_head);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}