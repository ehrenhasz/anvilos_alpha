{
  "module_name": "iavf_adminq.c",
  "hash_id": "1d4d40747fd768587ce28817a3a25ab34207151f62c60b6e818bc56481a34b18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/iavf/iavf_adminq.c",
  "human_readable_source": "\n \n\n#include \"iavf_status.h\"\n#include \"iavf_type.h\"\n#include \"iavf_register.h\"\n#include \"iavf_adminq.h\"\n#include \"iavf_prototype.h\"\n\n \nstatic void iavf_adminq_init_regs(struct iavf_hw *hw)\n{\n\t \n\thw->aq.asq.tail = IAVF_VF_ATQT1;\n\thw->aq.asq.head = IAVF_VF_ATQH1;\n\thw->aq.asq.len  = IAVF_VF_ATQLEN1;\n\thw->aq.asq.bal  = IAVF_VF_ATQBAL1;\n\thw->aq.asq.bah  = IAVF_VF_ATQBAH1;\n\thw->aq.arq.tail = IAVF_VF_ARQT1;\n\thw->aq.arq.head = IAVF_VF_ARQH1;\n\thw->aq.arq.len  = IAVF_VF_ARQLEN1;\n\thw->aq.arq.bal  = IAVF_VF_ARQBAL1;\n\thw->aq.arq.bah  = IAVF_VF_ARQBAH1;\n}\n\n \nstatic enum iavf_status iavf_alloc_adminq_asq_ring(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code;\n\n\tret_code = iavf_allocate_dma_mem(hw, &hw->aq.asq.desc_buf,\n\t\t\t\t\t iavf_mem_atq_ring,\n\t\t\t\t\t (hw->aq.num_asq_entries *\n\t\t\t\t\t sizeof(struct iavf_aq_desc)),\n\t\t\t\t\t IAVF_ADMINQ_DESC_ALIGNMENT);\n\tif (ret_code)\n\t\treturn ret_code;\n\n\tret_code = iavf_allocate_virt_mem(hw, &hw->aq.asq.cmd_buf,\n\t\t\t\t\t  (hw->aq.num_asq_entries *\n\t\t\t\t\t  sizeof(struct iavf_asq_cmd_details)));\n\tif (ret_code) {\n\t\tiavf_free_dma_mem(hw, &hw->aq.asq.desc_buf);\n\t\treturn ret_code;\n\t}\n\n\treturn ret_code;\n}\n\n \nstatic enum iavf_status iavf_alloc_adminq_arq_ring(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code;\n\n\tret_code = iavf_allocate_dma_mem(hw, &hw->aq.arq.desc_buf,\n\t\t\t\t\t iavf_mem_arq_ring,\n\t\t\t\t\t (hw->aq.num_arq_entries *\n\t\t\t\t\t sizeof(struct iavf_aq_desc)),\n\t\t\t\t\t IAVF_ADMINQ_DESC_ALIGNMENT);\n\n\treturn ret_code;\n}\n\n \nstatic void iavf_free_adminq_asq(struct iavf_hw *hw)\n{\n\tiavf_free_dma_mem(hw, &hw->aq.asq.desc_buf);\n}\n\n \nstatic void iavf_free_adminq_arq(struct iavf_hw *hw)\n{\n\tiavf_free_dma_mem(hw, &hw->aq.arq.desc_buf);\n}\n\n \nstatic enum iavf_status iavf_alloc_arq_bufs(struct iavf_hw *hw)\n{\n\tstruct iavf_aq_desc *desc;\n\tstruct iavf_dma_mem *bi;\n\tenum iavf_status ret_code;\n\tint i;\n\n\t \n\n\t \n\tret_code = iavf_allocate_virt_mem(hw, &hw->aq.arq.dma_head,\n\t\t\t\t\t  (hw->aq.num_arq_entries *\n\t\t\t\t\t   sizeof(struct iavf_dma_mem)));\n\tif (ret_code)\n\t\tgoto alloc_arq_bufs;\n\thw->aq.arq.r.arq_bi = (struct iavf_dma_mem *)hw->aq.arq.dma_head.va;\n\n\t \n\tfor (i = 0; i < hw->aq.num_arq_entries; i++) {\n\t\tbi = &hw->aq.arq.r.arq_bi[i];\n\t\tret_code = iavf_allocate_dma_mem(hw, bi,\n\t\t\t\t\t\t iavf_mem_arq_buf,\n\t\t\t\t\t\t hw->aq.arq_buf_size,\n\t\t\t\t\t\t IAVF_ADMINQ_DESC_ALIGNMENT);\n\t\tif (ret_code)\n\t\t\tgoto unwind_alloc_arq_bufs;\n\n\t\t \n\t\tdesc = IAVF_ADMINQ_DESC(hw->aq.arq, i);\n\n\t\tdesc->flags = cpu_to_le16(IAVF_AQ_FLAG_BUF);\n\t\tif (hw->aq.arq_buf_size > IAVF_AQ_LARGE_BUF)\n\t\t\tdesc->flags |= cpu_to_le16(IAVF_AQ_FLAG_LB);\n\t\tdesc->opcode = 0;\n\t\t \n\t\tdesc->datalen = cpu_to_le16((u16)bi->size);\n\t\tdesc->retval = 0;\n\t\tdesc->cookie_high = 0;\n\t\tdesc->cookie_low = 0;\n\t\tdesc->params.external.addr_high =\n\t\t\tcpu_to_le32(upper_32_bits(bi->pa));\n\t\tdesc->params.external.addr_low =\n\t\t\tcpu_to_le32(lower_32_bits(bi->pa));\n\t\tdesc->params.external.param0 = 0;\n\t\tdesc->params.external.param1 = 0;\n\t}\n\nalloc_arq_bufs:\n\treturn ret_code;\n\nunwind_alloc_arq_bufs:\n\t \n\ti--;\n\tfor (; i >= 0; i--)\n\t\tiavf_free_dma_mem(hw, &hw->aq.arq.r.arq_bi[i]);\n\tiavf_free_virt_mem(hw, &hw->aq.arq.dma_head);\n\n\treturn ret_code;\n}\n\n \nstatic enum iavf_status iavf_alloc_asq_bufs(struct iavf_hw *hw)\n{\n\tstruct iavf_dma_mem *bi;\n\tenum iavf_status ret_code;\n\tint i;\n\n\t \n\tret_code = iavf_allocate_virt_mem(hw, &hw->aq.asq.dma_head,\n\t\t\t\t\t  (hw->aq.num_asq_entries *\n\t\t\t\t\t   sizeof(struct iavf_dma_mem)));\n\tif (ret_code)\n\t\tgoto alloc_asq_bufs;\n\thw->aq.asq.r.asq_bi = (struct iavf_dma_mem *)hw->aq.asq.dma_head.va;\n\n\t \n\tfor (i = 0; i < hw->aq.num_asq_entries; i++) {\n\t\tbi = &hw->aq.asq.r.asq_bi[i];\n\t\tret_code = iavf_allocate_dma_mem(hw, bi,\n\t\t\t\t\t\t iavf_mem_asq_buf,\n\t\t\t\t\t\t hw->aq.asq_buf_size,\n\t\t\t\t\t\t IAVF_ADMINQ_DESC_ALIGNMENT);\n\t\tif (ret_code)\n\t\t\tgoto unwind_alloc_asq_bufs;\n\t}\nalloc_asq_bufs:\n\treturn ret_code;\n\nunwind_alloc_asq_bufs:\n\t \n\ti--;\n\tfor (; i >= 0; i--)\n\t\tiavf_free_dma_mem(hw, &hw->aq.asq.r.asq_bi[i]);\n\tiavf_free_virt_mem(hw, &hw->aq.asq.dma_head);\n\n\treturn ret_code;\n}\n\n \nstatic void iavf_free_arq_bufs(struct iavf_hw *hw)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < hw->aq.num_arq_entries; i++)\n\t\tiavf_free_dma_mem(hw, &hw->aq.arq.r.arq_bi[i]);\n\n\t \n\tiavf_free_dma_mem(hw, &hw->aq.arq.desc_buf);\n\n\t \n\tiavf_free_virt_mem(hw, &hw->aq.arq.dma_head);\n}\n\n \nstatic void iavf_free_asq_bufs(struct iavf_hw *hw)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < hw->aq.num_asq_entries; i++)\n\t\tif (hw->aq.asq.r.asq_bi[i].pa)\n\t\t\tiavf_free_dma_mem(hw, &hw->aq.asq.r.asq_bi[i]);\n\n\t \n\tiavf_free_virt_mem(hw, &hw->aq.asq.cmd_buf);\n\n\t \n\tiavf_free_dma_mem(hw, &hw->aq.asq.desc_buf);\n\n\t \n\tiavf_free_virt_mem(hw, &hw->aq.asq.dma_head);\n}\n\n \nstatic enum iavf_status iavf_config_asq_regs(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code = 0;\n\tu32 reg = 0;\n\n\t \n\twr32(hw, hw->aq.asq.head, 0);\n\twr32(hw, hw->aq.asq.tail, 0);\n\n\t \n\twr32(hw, hw->aq.asq.len, (hw->aq.num_asq_entries |\n\t\t\t\t  IAVF_VF_ATQLEN1_ATQENABLE_MASK));\n\twr32(hw, hw->aq.asq.bal, lower_32_bits(hw->aq.asq.desc_buf.pa));\n\twr32(hw, hw->aq.asq.bah, upper_32_bits(hw->aq.asq.desc_buf.pa));\n\n\t \n\treg = rd32(hw, hw->aq.asq.bal);\n\tif (reg != lower_32_bits(hw->aq.asq.desc_buf.pa))\n\t\tret_code = IAVF_ERR_ADMIN_QUEUE_ERROR;\n\n\treturn ret_code;\n}\n\n \nstatic enum iavf_status iavf_config_arq_regs(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code = 0;\n\tu32 reg = 0;\n\n\t \n\twr32(hw, hw->aq.arq.head, 0);\n\twr32(hw, hw->aq.arq.tail, 0);\n\n\t \n\twr32(hw, hw->aq.arq.len, (hw->aq.num_arq_entries |\n\t\t\t\t  IAVF_VF_ARQLEN1_ARQENABLE_MASK));\n\twr32(hw, hw->aq.arq.bal, lower_32_bits(hw->aq.arq.desc_buf.pa));\n\twr32(hw, hw->aq.arq.bah, upper_32_bits(hw->aq.arq.desc_buf.pa));\n\n\t \n\twr32(hw, hw->aq.arq.tail, hw->aq.num_arq_entries - 1);\n\n\t \n\treg = rd32(hw, hw->aq.arq.bal);\n\tif (reg != lower_32_bits(hw->aq.arq.desc_buf.pa))\n\t\tret_code = IAVF_ERR_ADMIN_QUEUE_ERROR;\n\n\treturn ret_code;\n}\n\n \nstatic enum iavf_status iavf_init_asq(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code = 0;\n\tint i;\n\n\tif (hw->aq.asq.count > 0) {\n\t\t \n\t\tret_code = IAVF_ERR_NOT_READY;\n\t\tgoto init_adminq_exit;\n\t}\n\n\t \n\tif ((hw->aq.num_asq_entries == 0) ||\n\t    (hw->aq.asq_buf_size == 0)) {\n\t\tret_code = IAVF_ERR_CONFIG;\n\t\tgoto init_adminq_exit;\n\t}\n\n\thw->aq.asq.next_to_use = 0;\n\thw->aq.asq.next_to_clean = 0;\n\n\t \n\tret_code = iavf_alloc_adminq_asq_ring(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_exit;\n\n\t \n\tret_code = iavf_alloc_asq_bufs(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_rings;\n\n\t \n\tret_code = iavf_config_asq_regs(hw);\n\tif (ret_code)\n\t\tgoto init_free_asq_bufs;\n\n\t \n\thw->aq.asq.count = hw->aq.num_asq_entries;\n\tgoto init_adminq_exit;\n\ninit_free_asq_bufs:\n\tfor (i = 0; i < hw->aq.num_asq_entries; i++)\n\t\tiavf_free_dma_mem(hw, &hw->aq.asq.r.asq_bi[i]);\n\tiavf_free_virt_mem(hw, &hw->aq.asq.dma_head);\n\ninit_adminq_free_rings:\n\tiavf_free_adminq_asq(hw);\n\ninit_adminq_exit:\n\treturn ret_code;\n}\n\n \nstatic enum iavf_status iavf_init_arq(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code = 0;\n\tint i;\n\n\tif (hw->aq.arq.count > 0) {\n\t\t \n\t\tret_code = IAVF_ERR_NOT_READY;\n\t\tgoto init_adminq_exit;\n\t}\n\n\t \n\tif ((hw->aq.num_arq_entries == 0) ||\n\t    (hw->aq.arq_buf_size == 0)) {\n\t\tret_code = IAVF_ERR_CONFIG;\n\t\tgoto init_adminq_exit;\n\t}\n\n\thw->aq.arq.next_to_use = 0;\n\thw->aq.arq.next_to_clean = 0;\n\n\t \n\tret_code = iavf_alloc_adminq_arq_ring(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_exit;\n\n\t \n\tret_code = iavf_alloc_arq_bufs(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_rings;\n\n\t \n\tret_code = iavf_config_arq_regs(hw);\n\tif (ret_code)\n\t\tgoto init_free_arq_bufs;\n\n\t \n\thw->aq.arq.count = hw->aq.num_arq_entries;\n\tgoto init_adminq_exit;\n\ninit_free_arq_bufs:\n\tfor (i = 0; i < hw->aq.num_arq_entries; i++)\n\t\tiavf_free_dma_mem(hw, &hw->aq.arq.r.arq_bi[i]);\n\tiavf_free_virt_mem(hw, &hw->aq.arq.dma_head);\ninit_adminq_free_rings:\n\tiavf_free_adminq_arq(hw);\n\ninit_adminq_exit:\n\treturn ret_code;\n}\n\n \nstatic enum iavf_status iavf_shutdown_asq(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code = 0;\n\n\tmutex_lock(&hw->aq.asq_mutex);\n\n\tif (hw->aq.asq.count == 0) {\n\t\tret_code = IAVF_ERR_NOT_READY;\n\t\tgoto shutdown_asq_out;\n\t}\n\n\t \n\twr32(hw, hw->aq.asq.head, 0);\n\twr32(hw, hw->aq.asq.tail, 0);\n\twr32(hw, hw->aq.asq.len, 0);\n\twr32(hw, hw->aq.asq.bal, 0);\n\twr32(hw, hw->aq.asq.bah, 0);\n\n\thw->aq.asq.count = 0;  \n\n\t \n\tiavf_free_asq_bufs(hw);\n\nshutdown_asq_out:\n\tmutex_unlock(&hw->aq.asq_mutex);\n\treturn ret_code;\n}\n\n \nstatic enum iavf_status iavf_shutdown_arq(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code = 0;\n\n\tmutex_lock(&hw->aq.arq_mutex);\n\n\tif (hw->aq.arq.count == 0) {\n\t\tret_code = IAVF_ERR_NOT_READY;\n\t\tgoto shutdown_arq_out;\n\t}\n\n\t \n\twr32(hw, hw->aq.arq.head, 0);\n\twr32(hw, hw->aq.arq.tail, 0);\n\twr32(hw, hw->aq.arq.len, 0);\n\twr32(hw, hw->aq.arq.bal, 0);\n\twr32(hw, hw->aq.arq.bah, 0);\n\n\thw->aq.arq.count = 0;  \n\n\t \n\tiavf_free_arq_bufs(hw);\n\nshutdown_arq_out:\n\tmutex_unlock(&hw->aq.arq_mutex);\n\treturn ret_code;\n}\n\n \nenum iavf_status iavf_init_adminq(struct iavf_hw *hw)\n{\n\tenum iavf_status ret_code;\n\n\t \n\tif ((hw->aq.num_arq_entries == 0) ||\n\t    (hw->aq.num_asq_entries == 0) ||\n\t    (hw->aq.arq_buf_size == 0) ||\n\t    (hw->aq.asq_buf_size == 0)) {\n\t\tret_code = IAVF_ERR_CONFIG;\n\t\tgoto init_adminq_exit;\n\t}\n\n\t \n\tiavf_adminq_init_regs(hw);\n\n\t \n\thw->aq.asq_cmd_timeout = IAVF_ASQ_CMD_TIMEOUT;\n\n\t \n\tret_code = iavf_init_asq(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_destroy_locks;\n\n\t \n\tret_code = iavf_init_arq(hw);\n\tif (ret_code)\n\t\tgoto init_adminq_free_asq;\n\n\t \n\tgoto init_adminq_exit;\n\ninit_adminq_free_asq:\n\tiavf_shutdown_asq(hw);\ninit_adminq_destroy_locks:\n\ninit_adminq_exit:\n\treturn ret_code;\n}\n\n \nenum iavf_status iavf_shutdown_adminq(struct iavf_hw *hw)\n{\n\tif (iavf_check_asq_alive(hw))\n\t\tiavf_aq_queue_shutdown(hw, true);\n\n\tiavf_shutdown_asq(hw);\n\tiavf_shutdown_arq(hw);\n\n\treturn 0;\n}\n\n \nstatic u16 iavf_clean_asq(struct iavf_hw *hw)\n{\n\tstruct iavf_adminq_ring *asq = &hw->aq.asq;\n\tstruct iavf_asq_cmd_details *details;\n\tu16 ntc = asq->next_to_clean;\n\tstruct iavf_aq_desc desc_cb;\n\tstruct iavf_aq_desc *desc;\n\n\tdesc = IAVF_ADMINQ_DESC(*asq, ntc);\n\tdetails = IAVF_ADMINQ_DETAILS(*asq, ntc);\n\twhile (rd32(hw, hw->aq.asq.head) != ntc) {\n\t\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"ntc %d head %d.\\n\", ntc, rd32(hw, hw->aq.asq.head));\n\n\t\tif (details->callback) {\n\t\t\tIAVF_ADMINQ_CALLBACK cb_func =\n\t\t\t\t\t(IAVF_ADMINQ_CALLBACK)details->callback;\n\t\t\tdesc_cb = *desc;\n\t\t\tcb_func(hw, &desc_cb);\n\t\t}\n\t\tmemset((void *)desc, 0, sizeof(struct iavf_aq_desc));\n\t\tmemset((void *)details, 0,\n\t\t       sizeof(struct iavf_asq_cmd_details));\n\t\tntc++;\n\t\tif (ntc == asq->count)\n\t\t\tntc = 0;\n\t\tdesc = IAVF_ADMINQ_DESC(*asq, ntc);\n\t\tdetails = IAVF_ADMINQ_DETAILS(*asq, ntc);\n\t}\n\n\tasq->next_to_clean = ntc;\n\n\treturn IAVF_DESC_UNUSED(asq);\n}\n\n \nbool iavf_asq_done(struct iavf_hw *hw)\n{\n\t \n\treturn rd32(hw, hw->aq.asq.head) == hw->aq.asq.next_to_use;\n}\n\n \nenum iavf_status iavf_asq_send_command(struct iavf_hw *hw,\n\t\t\t\t       struct iavf_aq_desc *desc,\n\t\t\t\t       void *buff,  \n\t\t\t\t       u16  buff_size,\n\t\t\t\t       struct iavf_asq_cmd_details *cmd_details)\n{\n\tstruct iavf_dma_mem *dma_buff = NULL;\n\tstruct iavf_asq_cmd_details *details;\n\tstruct iavf_aq_desc *desc_on_ring;\n\tbool cmd_completed = false;\n\tenum iavf_status status = 0;\n\tu16  retval = 0;\n\tu32  val = 0;\n\n\tmutex_lock(&hw->aq.asq_mutex);\n\n\tif (hw->aq.asq.count == 0) {\n\t\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Admin queue not initialized.\\n\");\n\t\tstatus = IAVF_ERR_QUEUE_EMPTY;\n\t\tgoto asq_send_command_error;\n\t}\n\n\thw->aq.asq_last_status = IAVF_AQ_RC_OK;\n\n\tval = rd32(hw, hw->aq.asq.head);\n\tif (val >= hw->aq.num_asq_entries) {\n\t\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: head overrun at %d\\n\", val);\n\t\tstatus = IAVF_ERR_QUEUE_EMPTY;\n\t\tgoto asq_send_command_error;\n\t}\n\n\tdetails = IAVF_ADMINQ_DETAILS(hw->aq.asq, hw->aq.asq.next_to_use);\n\tif (cmd_details) {\n\t\t*details = *cmd_details;\n\n\t\t \n\t\tif (details->cookie) {\n\t\t\tdesc->cookie_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(details->cookie));\n\t\t\tdesc->cookie_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(details->cookie));\n\t\t}\n\t} else {\n\t\tmemset(details, 0, sizeof(struct iavf_asq_cmd_details));\n\t}\n\n\t \n\tdesc->flags &= ~cpu_to_le16(details->flags_dis);\n\tdesc->flags |= cpu_to_le16(details->flags_ena);\n\n\tif (buff_size > hw->aq.asq_buf_size) {\n\t\tiavf_debug(hw,\n\t\t\t   IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Invalid buffer size: %d.\\n\",\n\t\t\t   buff_size);\n\t\tstatus = IAVF_ERR_INVALID_SIZE;\n\t\tgoto asq_send_command_error;\n\t}\n\n\tif (details->postpone && !details->async) {\n\t\tiavf_debug(hw,\n\t\t\t   IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Async flag not set along with postpone flag\");\n\t\tstatus = IAVF_ERR_PARAM;\n\t\tgoto asq_send_command_error;\n\t}\n\n\t \n\t \n\tif (iavf_clean_asq(hw) == 0) {\n\t\tiavf_debug(hw,\n\t\t\t   IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQTX: Error queue is full.\\n\");\n\t\tstatus = IAVF_ERR_ADMIN_QUEUE_FULL;\n\t\tgoto asq_send_command_error;\n\t}\n\n\t \n\tdesc_on_ring = IAVF_ADMINQ_DESC(hw->aq.asq, hw->aq.asq.next_to_use);\n\n\t \n\t*desc_on_ring = *desc;\n\n\t \n\tif (buff) {\n\t\tdma_buff = &hw->aq.asq.r.asq_bi[hw->aq.asq.next_to_use];\n\t\t \n\t\tmemcpy(dma_buff->va, buff, buff_size);\n\t\tdesc_on_ring->datalen = cpu_to_le16(buff_size);\n\n\t\t \n\t\tdesc_on_ring->params.external.addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(dma_buff->pa));\n\t\tdesc_on_ring->params.external.addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_buff->pa));\n\t}\n\n\t \n\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE, \"AQTX: desc and buffer:\\n\");\n\tiavf_debug_aq(hw, IAVF_DEBUG_AQ_COMMAND, (void *)desc_on_ring,\n\t\t      buff, buff_size);\n\t(hw->aq.asq.next_to_use)++;\n\tif (hw->aq.asq.next_to_use == hw->aq.asq.count)\n\t\thw->aq.asq.next_to_use = 0;\n\tif (!details->postpone)\n\t\twr32(hw, hw->aq.asq.tail, hw->aq.asq.next_to_use);\n\n\t \n\tif (!details->async && !details->postpone) {\n\t\tu32 total_delay = 0;\n\n\t\tdo {\n\t\t\t \n\t\t\tif (iavf_asq_done(hw))\n\t\t\t\tbreak;\n\t\t\tudelay(50);\n\t\t\ttotal_delay += 50;\n\t\t} while (total_delay < hw->aq.asq_cmd_timeout);\n\t}\n\n\t \n\tif (iavf_asq_done(hw)) {\n\t\t*desc = *desc_on_ring;\n\t\tif (buff)\n\t\t\tmemcpy(buff, dma_buff->va, buff_size);\n\t\tretval = le16_to_cpu(desc->retval);\n\t\tif (retval != 0) {\n\t\t\tiavf_debug(hw,\n\t\t\t\t   IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t\t   \"AQTX: Command completed with error 0x%X.\\n\",\n\t\t\t\t   retval);\n\n\t\t\t \n\t\t\tretval &= 0xff;\n\t\t}\n\t\tcmd_completed = true;\n\t\tif ((enum iavf_admin_queue_err)retval == IAVF_AQ_RC_OK)\n\t\t\tstatus = 0;\n\t\telse if ((enum iavf_admin_queue_err)retval == IAVF_AQ_RC_EBUSY)\n\t\t\tstatus = IAVF_ERR_NOT_READY;\n\t\telse\n\t\t\tstatus = IAVF_ERR_ADMIN_QUEUE_ERROR;\n\t\thw->aq.asq_last_status = (enum iavf_admin_queue_err)retval;\n\t}\n\n\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,\n\t\t   \"AQTX: desc and buffer writeback:\\n\");\n\tiavf_debug_aq(hw, IAVF_DEBUG_AQ_COMMAND, (void *)desc, buff, buff_size);\n\n\t \n\tif (details->wb_desc)\n\t\t*details->wb_desc = *desc_on_ring;\n\n\t \n\tif ((!cmd_completed) &&\n\t    (!details->async && !details->postpone)) {\n\t\tif (rd32(hw, hw->aq.asq.len) & IAVF_VF_ATQLEN1_ATQCRIT_MASK) {\n\t\t\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t\t   \"AQTX: AQ Critical error.\\n\");\n\t\t\tstatus = IAVF_ERR_ADMIN_QUEUE_CRITICAL_ERROR;\n\t\t} else {\n\t\t\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t\t   \"AQTX: Writeback timeout.\\n\");\n\t\t\tstatus = IAVF_ERR_ADMIN_QUEUE_TIMEOUT;\n\t\t}\n\t}\n\nasq_send_command_error:\n\tmutex_unlock(&hw->aq.asq_mutex);\n\treturn status;\n}\n\n \nvoid iavf_fill_default_direct_cmd_desc(struct iavf_aq_desc *desc, u16 opcode)\n{\n\t \n\tmemset((void *)desc, 0, sizeof(struct iavf_aq_desc));\n\tdesc->opcode = cpu_to_le16(opcode);\n\tdesc->flags = cpu_to_le16(IAVF_AQ_FLAG_SI);\n}\n\n \nenum iavf_status iavf_clean_arq_element(struct iavf_hw *hw,\n\t\t\t\t\tstruct iavf_arq_event_info *e,\n\t\t\t\t\tu16 *pending)\n{\n\tu16 ntc = hw->aq.arq.next_to_clean;\n\tstruct iavf_aq_desc *desc;\n\tenum iavf_status ret_code = 0;\n\tstruct iavf_dma_mem *bi;\n\tu16 desc_idx;\n\tu16 datalen;\n\tu16 flags;\n\tu16 ntu;\n\n\t \n\tmemset(&e->desc, 0, sizeof(e->desc));\n\n\t \n\tmutex_lock(&hw->aq.arq_mutex);\n\n\tif (hw->aq.arq.count == 0) {\n\t\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQRX: Admin queue not initialized.\\n\");\n\t\tret_code = IAVF_ERR_QUEUE_EMPTY;\n\t\tgoto clean_arq_element_err;\n\t}\n\n\t \n\tntu = rd32(hw, hw->aq.arq.head) & IAVF_VF_ARQH1_ARQH_MASK;\n\tif (ntu == ntc) {\n\t\t \n\t\tret_code = IAVF_ERR_ADMIN_QUEUE_NO_WORK;\n\t\tgoto clean_arq_element_out;\n\t}\n\n\t \n\tdesc = IAVF_ADMINQ_DESC(hw->aq.arq, ntc);\n\tdesc_idx = ntc;\n\n\thw->aq.arq_last_status =\n\t\t(enum iavf_admin_queue_err)le16_to_cpu(desc->retval);\n\tflags = le16_to_cpu(desc->flags);\n\tif (flags & IAVF_AQ_FLAG_ERR) {\n\t\tret_code = IAVF_ERR_ADMIN_QUEUE_ERROR;\n\t\tiavf_debug(hw,\n\t\t\t   IAVF_DEBUG_AQ_MESSAGE,\n\t\t\t   \"AQRX: Event received with error 0x%X.\\n\",\n\t\t\t   hw->aq.arq_last_status);\n\t}\n\n\te->desc = *desc;\n\tdatalen = le16_to_cpu(desc->datalen);\n\te->msg_len = min(datalen, e->buf_len);\n\tif (e->msg_buf && (e->msg_len != 0))\n\t\tmemcpy(e->msg_buf, hw->aq.arq.r.arq_bi[desc_idx].va,\n\t\t       e->msg_len);\n\n\tiavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE, \"AQRX: desc and buffer:\\n\");\n\tiavf_debug_aq(hw, IAVF_DEBUG_AQ_COMMAND, (void *)desc, e->msg_buf,\n\t\t      hw->aq.arq_buf_size);\n\n\t \n\tbi = &hw->aq.arq.r.arq_bi[ntc];\n\tmemset((void *)desc, 0, sizeof(struct iavf_aq_desc));\n\n\tdesc->flags = cpu_to_le16(IAVF_AQ_FLAG_BUF);\n\tif (hw->aq.arq_buf_size > IAVF_AQ_LARGE_BUF)\n\t\tdesc->flags |= cpu_to_le16(IAVF_AQ_FLAG_LB);\n\tdesc->datalen = cpu_to_le16((u16)bi->size);\n\tdesc->params.external.addr_high = cpu_to_le32(upper_32_bits(bi->pa));\n\tdesc->params.external.addr_low = cpu_to_le32(lower_32_bits(bi->pa));\n\n\t \n\twr32(hw, hw->aq.arq.tail, ntc);\n\t \n\tntc++;\n\tif (ntc == hw->aq.num_arq_entries)\n\t\tntc = 0;\n\thw->aq.arq.next_to_clean = ntc;\n\thw->aq.arq.next_to_use = ntu;\n\nclean_arq_element_out:\n\t \n\tif (pending)\n\t\t*pending = (ntc > ntu ? hw->aq.arq.count : 0) + (ntu - ntc);\n\nclean_arq_element_err:\n\tmutex_unlock(&hw->aq.arq_mutex);\n\n\treturn ret_code;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}