{
  "module_name": "iavf_virtchnl.c",
  "hash_id": "9fb28a185ab3fcaf06696f8bb1325b526c41d5ac2df39c94abc541f0f61cfa91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/iavf/iavf_virtchnl.c",
  "human_readable_source": "\n \n\n#include \"iavf.h\"\n#include \"iavf_prototype.h\"\n#include \"iavf_client.h\"\n\n \nstatic int iavf_send_pf_msg(struct iavf_adapter *adapter,\n\t\t\t    enum virtchnl_ops op, u8 *msg, u16 len)\n{\n\tstruct iavf_hw *hw = &adapter->hw;\n\tenum iavf_status status;\n\n\tif (adapter->flags & IAVF_FLAG_PF_COMMS_FAILED)\n\t\treturn 0;  \n\n\tstatus = iavf_aq_send_msg_to_pf(hw, op, 0, msg, len, NULL);\n\tif (status)\n\t\tdev_dbg(&adapter->pdev->dev, \"Unable to send opcode %d to PF, status %s, aq_err %s\\n\",\n\t\t\top, iavf_stat_str(hw, status),\n\t\t\tiavf_aq_str(hw, hw->aq.asq_last_status));\n\treturn iavf_status_to_errno(status);\n}\n\n \nint iavf_send_api_ver(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_version_info vvi;\n\n\tvvi.major = VIRTCHNL_VERSION_MAJOR;\n\tvvi.minor = VIRTCHNL_VERSION_MINOR;\n\n\treturn iavf_send_pf_msg(adapter, VIRTCHNL_OP_VERSION, (u8 *)&vvi,\n\t\t\t\tsizeof(vvi));\n}\n\n \nstatic int\niavf_poll_virtchnl_msg(struct iavf_hw *hw, struct iavf_arq_event_info *event,\n\t\t       enum virtchnl_ops op_to_poll)\n{\n\tenum virtchnl_ops received_op;\n\tenum iavf_status status;\n\tu32 v_retval;\n\n\twhile (1) {\n\t\t \n\t\tstatus = iavf_clean_arq_element(hw, event, NULL);\n\t\tif (status != IAVF_SUCCESS)\n\t\t\treturn iavf_status_to_errno(status);\n\t\treceived_op =\n\t\t    (enum virtchnl_ops)le32_to_cpu(event->desc.cookie_high);\n\t\tif (op_to_poll == received_op)\n\t\t\tbreak;\n\t}\n\n\tv_retval = le32_to_cpu(event->desc.cookie_low);\n\treturn virtchnl_status_to_errno((enum virtchnl_status_code)v_retval);\n}\n\n \nint iavf_verify_api_ver(struct iavf_adapter *adapter)\n{\n\tstruct iavf_arq_event_info event;\n\tint err;\n\n\tevent.buf_len = IAVF_MAX_AQ_BUF_SIZE;\n\tevent.msg_buf = kzalloc(IAVF_MAX_AQ_BUF_SIZE, GFP_KERNEL);\n\tif (!event.msg_buf)\n\t\treturn -ENOMEM;\n\n\terr = iavf_poll_virtchnl_msg(&adapter->hw, &event, VIRTCHNL_OP_VERSION);\n\tif (!err) {\n\t\tstruct virtchnl_version_info *pf_vvi =\n\t\t\t(struct virtchnl_version_info *)event.msg_buf;\n\t\tadapter->pf_version = *pf_vvi;\n\n\t\tif (pf_vvi->major > VIRTCHNL_VERSION_MAJOR ||\n\t\t    (pf_vvi->major == VIRTCHNL_VERSION_MAJOR &&\n\t\t     pf_vvi->minor > VIRTCHNL_VERSION_MINOR))\n\t\t\terr = -EIO;\n\t}\n\n\tkfree(event.msg_buf);\n\n\treturn err;\n}\n\n \nint iavf_send_vf_config_msg(struct iavf_adapter *adapter)\n{\n\tu32 caps;\n\n\tcaps = VIRTCHNL_VF_OFFLOAD_L2 |\n\t       VIRTCHNL_VF_OFFLOAD_RSS_PF |\n\t       VIRTCHNL_VF_OFFLOAD_RSS_AQ |\n\t       VIRTCHNL_VF_OFFLOAD_RSS_REG |\n\t       VIRTCHNL_VF_OFFLOAD_VLAN |\n\t       VIRTCHNL_VF_OFFLOAD_WB_ON_ITR |\n\t       VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2 |\n\t       VIRTCHNL_VF_OFFLOAD_ENCAP |\n\t       VIRTCHNL_VF_OFFLOAD_VLAN_V2 |\n\t       VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM |\n\t       VIRTCHNL_VF_OFFLOAD_REQ_QUEUES |\n\t       VIRTCHNL_VF_OFFLOAD_ADQ |\n\t       VIRTCHNL_VF_OFFLOAD_USO |\n\t       VIRTCHNL_VF_OFFLOAD_FDIR_PF |\n\t       VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF |\n\t       VIRTCHNL_VF_CAP_ADV_LINK_SPEED;\n\n\tadapter->current_op = VIRTCHNL_OP_GET_VF_RESOURCES;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_GET_CONFIG;\n\tif (PF_IS_V11(adapter))\n\t\treturn iavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_VF_RESOURCES,\n\t\t\t\t\t(u8 *)&caps, sizeof(caps));\n\telse\n\t\treturn iavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_VF_RESOURCES,\n\t\t\t\t\tNULL, 0);\n}\n\nint iavf_send_vf_offload_vlan_v2_msg(struct iavf_adapter *adapter)\n{\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_GET_OFFLOAD_VLAN_V2_CAPS;\n\n\tif (!VLAN_V2_ALLOWED(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tadapter->current_op = VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS;\n\n\treturn iavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS,\n\t\t\t\tNULL, 0);\n}\n\n \nstatic void iavf_validate_num_queues(struct iavf_adapter *adapter)\n{\n\tif (adapter->vf_res->num_queue_pairs > IAVF_MAX_REQ_QUEUES) {\n\t\tstruct virtchnl_vsi_resource *vsi_res;\n\t\tint i;\n\n\t\tdev_info(&adapter->pdev->dev, \"Received %d queues, but can only have a max of %d\\n\",\n\t\t\t adapter->vf_res->num_queue_pairs,\n\t\t\t IAVF_MAX_REQ_QUEUES);\n\t\tdev_info(&adapter->pdev->dev, \"Fixing by reducing queues to %d\\n\",\n\t\t\t IAVF_MAX_REQ_QUEUES);\n\t\tadapter->vf_res->num_queue_pairs = IAVF_MAX_REQ_QUEUES;\n\t\tfor (i = 0; i < adapter->vf_res->num_vsis; i++) {\n\t\t\tvsi_res = &adapter->vf_res->vsi_res[i];\n\t\t\tvsi_res->num_queue_pairs = IAVF_MAX_REQ_QUEUES;\n\t\t}\n\t}\n}\n\n \nint iavf_get_vf_config(struct iavf_adapter *adapter)\n{\n\tstruct iavf_hw *hw = &adapter->hw;\n\tstruct iavf_arq_event_info event;\n\tu16 len;\n\tint err;\n\n\tlen = IAVF_VIRTCHNL_VF_RESOURCE_SIZE;\n\tevent.buf_len = len;\n\tevent.msg_buf = kzalloc(len, GFP_KERNEL);\n\tif (!event.msg_buf)\n\t\treturn -ENOMEM;\n\n\terr = iavf_poll_virtchnl_msg(hw, &event, VIRTCHNL_OP_GET_VF_RESOURCES);\n\tmemcpy(adapter->vf_res, event.msg_buf, min(event.msg_len, len));\n\n\t \n\tif (!err)\n\t\tiavf_validate_num_queues(adapter);\n\tiavf_vf_parse_hw_config(hw, adapter->vf_res);\n\n\tkfree(event.msg_buf);\n\n\treturn err;\n}\n\nint iavf_get_vf_vlan_v2_caps(struct iavf_adapter *adapter)\n{\n\tstruct iavf_arq_event_info event;\n\tint err;\n\tu16 len;\n\n\tlen = sizeof(struct virtchnl_vlan_caps);\n\tevent.buf_len = len;\n\tevent.msg_buf = kzalloc(len, GFP_KERNEL);\n\tif (!event.msg_buf)\n\t\treturn -ENOMEM;\n\n\terr = iavf_poll_virtchnl_msg(&adapter->hw, &event,\n\t\t\t\t     VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS);\n\tif (!err)\n\t\tmemcpy(&adapter->vlan_v2_caps, event.msg_buf,\n\t\t       min(event.msg_len, len));\n\n\tkfree(event.msg_buf);\n\n\treturn err;\n}\n\n \nvoid iavf_configure_queues(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_vsi_queue_config_info *vqci;\n\tint i, max_frame = adapter->vf_res->max_mtu;\n\tint pairs = adapter->num_active_queues;\n\tstruct virtchnl_queue_pair_info *vqpi;\n\tsize_t len;\n\n\tif (max_frame > IAVF_MAX_RXBUFFER || !max_frame)\n\t\tmax_frame = IAVF_MAX_RXBUFFER;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot configure queues, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_CONFIG_VSI_QUEUES;\n\tlen = virtchnl_struct_size(vqci, qpair, pairs);\n\tvqci = kzalloc(len, GFP_KERNEL);\n\tif (!vqci)\n\t\treturn;\n\n\t \n\tif (!(adapter->flags & IAVF_FLAG_LEGACY_RX) &&\n\t    (adapter->netdev->mtu <= ETH_DATA_LEN))\n\t\tmax_frame = IAVF_RXBUFFER_1536 - NET_IP_ALIGN;\n\n\tvqci->vsi_id = adapter->vsi_res->vsi_id;\n\tvqci->num_queue_pairs = pairs;\n\tvqpi = vqci->qpair;\n\t \n\tfor (i = 0; i < pairs; i++) {\n\t\tvqpi->txq.vsi_id = vqci->vsi_id;\n\t\tvqpi->txq.queue_id = i;\n\t\tvqpi->txq.ring_len = adapter->tx_rings[i].count;\n\t\tvqpi->txq.dma_ring_addr = adapter->tx_rings[i].dma;\n\t\tvqpi->rxq.vsi_id = vqci->vsi_id;\n\t\tvqpi->rxq.queue_id = i;\n\t\tvqpi->rxq.ring_len = adapter->rx_rings[i].count;\n\t\tvqpi->rxq.dma_ring_addr = adapter->rx_rings[i].dma;\n\t\tvqpi->rxq.max_pkt_size = max_frame;\n\t\tvqpi->rxq.databuffer_size =\n\t\t\tALIGN(adapter->rx_rings[i].rx_buf_len,\n\t\t\t      BIT_ULL(IAVF_RXQ_CTX_DBUFF_SHIFT));\n\t\tvqpi++;\n\t}\n\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_CONFIGURE_QUEUES;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_CONFIG_VSI_QUEUES,\n\t\t\t (u8 *)vqci, len);\n\tkfree(vqci);\n}\n\n \nvoid iavf_enable_queues(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_queue_select vqs;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot enable queues, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_ENABLE_QUEUES;\n\tvqs.vsi_id = adapter->vsi_res->vsi_id;\n\tvqs.tx_queues = BIT(adapter->num_active_queues) - 1;\n\tvqs.rx_queues = vqs.tx_queues;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_ENABLE_QUEUES;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ENABLE_QUEUES,\n\t\t\t (u8 *)&vqs, sizeof(vqs));\n}\n\n \nvoid iavf_disable_queues(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_queue_select vqs;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot disable queues, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_DISABLE_QUEUES;\n\tvqs.vsi_id = adapter->vsi_res->vsi_id;\n\tvqs.tx_queues = BIT(adapter->num_active_queues) - 1;\n\tvqs.rx_queues = vqs.tx_queues;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_DISABLE_QUEUES;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DISABLE_QUEUES,\n\t\t\t (u8 *)&vqs, sizeof(vqs));\n}\n\n \nvoid iavf_map_queues(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_irq_map_info *vimi;\n\tstruct virtchnl_vector_map *vecmap;\n\tstruct iavf_q_vector *q_vector;\n\tint v_idx, q_vectors;\n\tsize_t len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot map queues to vectors, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_CONFIG_IRQ_MAP;\n\n\tq_vectors = adapter->num_msix_vectors - NONQ_VECS;\n\n\tlen = virtchnl_struct_size(vimi, vecmap, adapter->num_msix_vectors);\n\tvimi = kzalloc(len, GFP_KERNEL);\n\tif (!vimi)\n\t\treturn;\n\n\tvimi->num_vectors = adapter->num_msix_vectors;\n\t \n\tfor (v_idx = 0; v_idx < q_vectors; v_idx++) {\n\t\tq_vector = &adapter->q_vectors[v_idx];\n\t\tvecmap = &vimi->vecmap[v_idx];\n\n\t\tvecmap->vsi_id = adapter->vsi_res->vsi_id;\n\t\tvecmap->vector_id = v_idx + NONQ_VECS;\n\t\tvecmap->txq_map = q_vector->ring_mask;\n\t\tvecmap->rxq_map = q_vector->ring_mask;\n\t\tvecmap->rxitr_idx = IAVF_RX_ITR;\n\t\tvecmap->txitr_idx = IAVF_TX_ITR;\n\t}\n\t \n\tvecmap = &vimi->vecmap[v_idx];\n\tvecmap->vsi_id = adapter->vsi_res->vsi_id;\n\tvecmap->vector_id = 0;\n\tvecmap->txq_map = 0;\n\tvecmap->rxq_map = 0;\n\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_MAP_VECTORS;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_CONFIG_IRQ_MAP,\n\t\t\t (u8 *)vimi, len);\n\tkfree(vimi);\n}\n\n \nstatic void\niavf_set_mac_addr_type(struct virtchnl_ether_addr *virtchnl_ether_addr,\n\t\t       const struct iavf_mac_filter *filter)\n{\n\tvirtchnl_ether_addr->type = filter->is_primary ?\n\t\tVIRTCHNL_ETHER_ADDR_PRIMARY :\n\t\tVIRTCHNL_ETHER_ADDR_EXTRA;\n}\n\n \nvoid iavf_add_ether_addrs(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_ether_addr_list *veal;\n\tstruct iavf_mac_filter *f;\n\tint i = 0, count = 0;\n\tbool more = false;\n\tsize_t len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot add filters, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\n\tlist_for_each_entry(f, &adapter->mac_filter_list, list) {\n\t\tif (f->add)\n\t\t\tcount++;\n\t}\n\tif (!count) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_MAC_FILTER;\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_ADD_ETH_ADDR;\n\n\tlen = virtchnl_struct_size(veal, list, count);\n\tif (len > IAVF_MAX_AQ_BUF_SIZE) {\n\t\tdev_warn(&adapter->pdev->dev, \"Too many add MAC changes in one request\\n\");\n\t\twhile (len > IAVF_MAX_AQ_BUF_SIZE)\n\t\t\tlen = virtchnl_struct_size(veal, list, --count);\n\t\tmore = true;\n\t}\n\n\tveal = kzalloc(len, GFP_ATOMIC);\n\tif (!veal) {\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\treturn;\n\t}\n\n\tveal->vsi_id = adapter->vsi_res->vsi_id;\n\tveal->num_elements = count;\n\tlist_for_each_entry(f, &adapter->mac_filter_list, list) {\n\t\tif (f->add) {\n\t\t\tether_addr_copy(veal->list[i].addr, f->macaddr);\n\t\t\tiavf_set_mac_addr_type(&veal->list[i], f);\n\t\t\ti++;\n\t\t\tf->add = false;\n\t\t\tif (i == count)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!more)\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_MAC_FILTER;\n\n\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_ETH_ADDR, (u8 *)veal, len);\n\tkfree(veal);\n}\n\n \nvoid iavf_del_ether_addrs(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_ether_addr_list *veal;\n\tstruct iavf_mac_filter *f, *ftmp;\n\tint i = 0, count = 0;\n\tbool more = false;\n\tsize_t len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot remove filters, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\n\tlist_for_each_entry(f, &adapter->mac_filter_list, list) {\n\t\tif (f->remove)\n\t\t\tcount++;\n\t}\n\tif (!count) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_MAC_FILTER;\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_DEL_ETH_ADDR;\n\n\tlen = virtchnl_struct_size(veal, list, count);\n\tif (len > IAVF_MAX_AQ_BUF_SIZE) {\n\t\tdev_warn(&adapter->pdev->dev, \"Too many delete MAC changes in one request\\n\");\n\t\twhile (len > IAVF_MAX_AQ_BUF_SIZE)\n\t\t\tlen = virtchnl_struct_size(veal, list, --count);\n\t\tmore = true;\n\t}\n\tveal = kzalloc(len, GFP_ATOMIC);\n\tif (!veal) {\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\treturn;\n\t}\n\n\tveal->vsi_id = adapter->vsi_res->vsi_id;\n\tveal->num_elements = count;\n\tlist_for_each_entry_safe(f, ftmp, &adapter->mac_filter_list, list) {\n\t\tif (f->remove) {\n\t\t\tether_addr_copy(veal->list[i].addr, f->macaddr);\n\t\t\tiavf_set_mac_addr_type(&veal->list[i], f);\n\t\t\ti++;\n\t\t\tlist_del(&f->list);\n\t\t\tkfree(f);\n\t\t\tif (i == count)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!more)\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_MAC_FILTER;\n\n\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_ETH_ADDR, (u8 *)veal, len);\n\tkfree(veal);\n}\n\n \nstatic void iavf_mac_add_ok(struct iavf_adapter *adapter)\n{\n\tstruct iavf_mac_filter *f, *ftmp;\n\n\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\tlist_for_each_entry_safe(f, ftmp, &adapter->mac_filter_list, list) {\n\t\tf->is_new_mac = false;\n\t\tif (!f->add && !f->add_handled)\n\t\t\tf->add_handled = true;\n\t}\n\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n}\n\n \nstatic void iavf_mac_add_reject(struct iavf_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct iavf_mac_filter *f, *ftmp;\n\n\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\tlist_for_each_entry_safe(f, ftmp, &adapter->mac_filter_list, list) {\n\t\tif (f->remove && ether_addr_equal(f->macaddr, netdev->dev_addr))\n\t\t\tf->remove = false;\n\n\t\tif (!f->add && !f->add_handled)\n\t\t\tf->add_handled = true;\n\n\t\tif (f->is_new_mac) {\n\t\t\tlist_del(&f->list);\n\t\t\tkfree(f);\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n}\n\n \nstatic void iavf_vlan_add_reject(struct iavf_adapter *adapter)\n{\n\tstruct iavf_vlan_filter *f, *ftmp;\n\n\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\tlist_for_each_entry_safe(f, ftmp, &adapter->vlan_filter_list, list) {\n\t\tif (f->state == IAVF_VLAN_IS_NEW) {\n\t\t\tlist_del(&f->list);\n\t\t\tkfree(f);\n\t\t\tadapter->num_vlan_filters--;\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n}\n\n \nvoid iavf_add_vlans(struct iavf_adapter *adapter)\n{\n\tint len, i = 0, count = 0;\n\tstruct iavf_vlan_filter *f;\n\tbool more = false;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot add VLANs, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\n\tlist_for_each_entry(f, &adapter->vlan_filter_list, list) {\n\t\tif (f->state == IAVF_VLAN_ADD)\n\t\t\tcount++;\n\t}\n\tif (!count || !VLAN_FILTERING_ALLOWED(adapter)) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_VLAN_FILTER;\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\treturn;\n\t}\n\n\tif (VLAN_ALLOWED(adapter)) {\n\t\tstruct virtchnl_vlan_filter_list *vvfl;\n\n\t\tadapter->current_op = VIRTCHNL_OP_ADD_VLAN;\n\n\t\tlen = virtchnl_struct_size(vvfl, vlan_id, count);\n\t\tif (len > IAVF_MAX_AQ_BUF_SIZE) {\n\t\t\tdev_warn(&adapter->pdev->dev, \"Too many add VLAN changes in one request\\n\");\n\t\t\twhile (len > IAVF_MAX_AQ_BUF_SIZE)\n\t\t\t\tlen = virtchnl_struct_size(vvfl, vlan_id,\n\t\t\t\t\t\t\t   --count);\n\t\t\tmore = true;\n\t\t}\n\t\tvvfl = kzalloc(len, GFP_ATOMIC);\n\t\tif (!vvfl) {\n\t\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tvvfl->vsi_id = adapter->vsi_res->vsi_id;\n\t\tvvfl->num_elements = count;\n\t\tlist_for_each_entry(f, &adapter->vlan_filter_list, list) {\n\t\t\tif (f->state == IAVF_VLAN_ADD) {\n\t\t\t\tvvfl->vlan_id[i] = f->vlan.vid;\n\t\t\t\ti++;\n\t\t\t\tf->state = IAVF_VLAN_IS_NEW;\n\t\t\t\tif (i == count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!more)\n\t\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_VLAN_FILTER;\n\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_VLAN, (u8 *)vvfl, len);\n\t\tkfree(vvfl);\n\t} else {\n\t\tu16 max_vlans = adapter->vlan_v2_caps.filtering.max_filters;\n\t\tu16 current_vlans = iavf_get_num_vlans_added(adapter);\n\t\tstruct virtchnl_vlan_filter_list_v2 *vvfl_v2;\n\n\t\tadapter->current_op = VIRTCHNL_OP_ADD_VLAN_V2;\n\n\t\tif ((count + current_vlans) > max_vlans &&\n\t\t    current_vlans < max_vlans) {\n\t\t\tcount = max_vlans - iavf_get_num_vlans_added(adapter);\n\t\t\tmore = true;\n\t\t}\n\n\t\tlen = virtchnl_struct_size(vvfl_v2, filters, count);\n\t\tif (len > IAVF_MAX_AQ_BUF_SIZE) {\n\t\t\tdev_warn(&adapter->pdev->dev, \"Too many add VLAN changes in one request\\n\");\n\t\t\twhile (len > IAVF_MAX_AQ_BUF_SIZE)\n\t\t\t\tlen = virtchnl_struct_size(vvfl_v2, filters,\n\t\t\t\t\t\t\t   --count);\n\t\t\tmore = true;\n\t\t}\n\n\t\tvvfl_v2 = kzalloc(len, GFP_ATOMIC);\n\t\tif (!vvfl_v2) {\n\t\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tvvfl_v2->vport_id = adapter->vsi_res->vsi_id;\n\t\tvvfl_v2->num_elements = count;\n\t\tlist_for_each_entry(f, &adapter->vlan_filter_list, list) {\n\t\t\tif (f->state == IAVF_VLAN_ADD) {\n\t\t\t\tstruct virtchnl_vlan_supported_caps *filtering_support =\n\t\t\t\t\t&adapter->vlan_v2_caps.filtering.filtering_support;\n\t\t\t\tstruct virtchnl_vlan *vlan;\n\n\t\t\t\tif (i == count)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (filtering_support->outer)\n\t\t\t\t\tvlan = &vvfl_v2->filters[i].outer;\n\t\t\t\telse\n\t\t\t\t\tvlan = &vvfl_v2->filters[i].inner;\n\n\t\t\t\tvlan->tci = f->vlan.vid;\n\t\t\t\tvlan->tpid = f->vlan.tpid;\n\n\t\t\t\ti++;\n\t\t\t\tf->state = IAVF_VLAN_IS_NEW;\n\t\t\t}\n\t\t}\n\n\t\tif (!more)\n\t\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_VLAN_FILTER;\n\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_VLAN_V2,\n\t\t\t\t (u8 *)vvfl_v2, len);\n\t\tkfree(vvfl_v2);\n\t}\n}\n\n \nvoid iavf_del_vlans(struct iavf_adapter *adapter)\n{\n\tstruct iavf_vlan_filter *f, *ftmp;\n\tint len, i = 0, count = 0;\n\tbool more = false;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot remove VLANs, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\n\tlist_for_each_entry_safe(f, ftmp, &adapter->vlan_filter_list, list) {\n\t\t \n\t\tif (f->state == IAVF_VLAN_REMOVE &&\n\t\t    !VLAN_FILTERING_ALLOWED(adapter)) {\n\t\t\tlist_del(&f->list);\n\t\t\tkfree(f);\n\t\t\tadapter->num_vlan_filters--;\n\t\t} else if (f->state == IAVF_VLAN_DISABLE &&\n\t\t    !VLAN_FILTERING_ALLOWED(adapter)) {\n\t\t\tf->state = IAVF_VLAN_INACTIVE;\n\t\t} else if (f->state == IAVF_VLAN_REMOVE ||\n\t\t\t   f->state == IAVF_VLAN_DISABLE) {\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!count || !VLAN_FILTERING_ALLOWED(adapter)) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_VLAN_FILTER;\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\treturn;\n\t}\n\n\tif (VLAN_ALLOWED(adapter)) {\n\t\tstruct virtchnl_vlan_filter_list *vvfl;\n\n\t\tadapter->current_op = VIRTCHNL_OP_DEL_VLAN;\n\n\t\tlen = virtchnl_struct_size(vvfl, vlan_id, count);\n\t\tif (len > IAVF_MAX_AQ_BUF_SIZE) {\n\t\t\tdev_warn(&adapter->pdev->dev, \"Too many delete VLAN changes in one request\\n\");\n\t\t\twhile (len > IAVF_MAX_AQ_BUF_SIZE)\n\t\t\t\tlen = virtchnl_struct_size(vvfl, vlan_id,\n\t\t\t\t\t\t\t   --count);\n\t\t\tmore = true;\n\t\t}\n\t\tvvfl = kzalloc(len, GFP_ATOMIC);\n\t\tif (!vvfl) {\n\t\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tvvfl->vsi_id = adapter->vsi_res->vsi_id;\n\t\tvvfl->num_elements = count;\n\t\tlist_for_each_entry_safe(f, ftmp, &adapter->vlan_filter_list, list) {\n\t\t\tif (f->state == IAVF_VLAN_DISABLE) {\n\t\t\t\tvvfl->vlan_id[i] = f->vlan.vid;\n\t\t\t\tf->state = IAVF_VLAN_INACTIVE;\n\t\t\t\ti++;\n\t\t\t\tif (i == count)\n\t\t\t\t\tbreak;\n\t\t\t} else if (f->state == IAVF_VLAN_REMOVE) {\n\t\t\t\tvvfl->vlan_id[i] = f->vlan.vid;\n\t\t\t\tlist_del(&f->list);\n\t\t\t\tkfree(f);\n\t\t\t\tadapter->num_vlan_filters--;\n\t\t\t\ti++;\n\t\t\t\tif (i == count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more)\n\t\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_VLAN_FILTER;\n\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_VLAN, (u8 *)vvfl, len);\n\t\tkfree(vvfl);\n\t} else {\n\t\tstruct virtchnl_vlan_filter_list_v2 *vvfl_v2;\n\n\t\tadapter->current_op = VIRTCHNL_OP_DEL_VLAN_V2;\n\n\t\tlen = virtchnl_struct_size(vvfl_v2, filters, count);\n\t\tif (len > IAVF_MAX_AQ_BUF_SIZE) {\n\t\t\tdev_warn(&adapter->pdev->dev, \"Too many add VLAN changes in one request\\n\");\n\t\t\twhile (len > IAVF_MAX_AQ_BUF_SIZE)\n\t\t\t\tlen = virtchnl_struct_size(vvfl_v2, filters,\n\t\t\t\t\t\t\t   --count);\n\t\t\tmore = true;\n\t\t}\n\n\t\tvvfl_v2 = kzalloc(len, GFP_ATOMIC);\n\t\tif (!vvfl_v2) {\n\t\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tvvfl_v2->vport_id = adapter->vsi_res->vsi_id;\n\t\tvvfl_v2->num_elements = count;\n\t\tlist_for_each_entry_safe(f, ftmp, &adapter->vlan_filter_list, list) {\n\t\t\tif (f->state == IAVF_VLAN_DISABLE ||\n\t\t\t    f->state == IAVF_VLAN_REMOVE) {\n\t\t\t\tstruct virtchnl_vlan_supported_caps *filtering_support =\n\t\t\t\t\t&adapter->vlan_v2_caps.filtering.filtering_support;\n\t\t\t\tstruct virtchnl_vlan *vlan;\n\n\t\t\t\t \n\t\t\t\tif (filtering_support->outer)\n\t\t\t\t\tvlan = &vvfl_v2->filters[i].outer;\n\t\t\t\telse\n\t\t\t\t\tvlan = &vvfl_v2->filters[i].inner;\n\n\t\t\t\tvlan->tci = f->vlan.vid;\n\t\t\t\tvlan->tpid = f->vlan.tpid;\n\n\t\t\t\tif (f->state == IAVF_VLAN_DISABLE) {\n\t\t\t\t\tf->state = IAVF_VLAN_INACTIVE;\n\t\t\t\t} else {\n\t\t\t\t\tlist_del(&f->list);\n\t\t\t\t\tkfree(f);\n\t\t\t\t\tadapter->num_vlan_filters--;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (i == count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more)\n\t\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_VLAN_FILTER;\n\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_VLAN_V2,\n\t\t\t\t (u8 *)vvfl_v2, len);\n\t\tkfree(vvfl_v2);\n\t}\n}\n\n \nvoid iavf_set_promiscuous(struct iavf_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct virtchnl_promisc_info vpi;\n\tunsigned int flags;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot set promiscuous mode, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_bh(&adapter->current_netdev_promisc_flags_lock);\n\n\t \n\tif (!iavf_promiscuous_mode_changed(adapter)) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_CONFIGURE_PROMISC_MODE;\n\t\tdev_dbg(&adapter->pdev->dev, \"No change in promiscuous mode\\n\");\n\t\t \n\t\tspin_unlock_bh(&adapter->current_netdev_promisc_flags_lock);\n\t\treturn;\n\t}\n\n\t \n\tif (!(netdev->flags & IFF_PROMISC) &&\n\t    netdev->flags & IFF_ALLMULTI) {\n\t\t \n\t\tflags = FLAG_VF_MULTICAST_PROMISC;\n\t\tadapter->current_netdev_promisc_flags |= IFF_ALLMULTI;\n\t\tadapter->current_netdev_promisc_flags &= ~IFF_PROMISC;\n\t\tdev_info(&adapter->pdev->dev, \"Entering multicast promiscuous mode\\n\");\n\t} else if (!(netdev->flags & IFF_PROMISC) &&\n\t\t   !(netdev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\tflags = 0;\n\t\tadapter->current_netdev_promisc_flags &=\n\t\t\t~(IFF_PROMISC | IFF_ALLMULTI);\n\t\tdev_info(&adapter->pdev->dev, \"Leaving promiscuous mode\\n\");\n\t} else {\n\t\t \n\t\tflags = FLAG_VF_UNICAST_PROMISC | FLAG_VF_MULTICAST_PROMISC;\n\t\tadapter->current_netdev_promisc_flags |= IFF_PROMISC;\n\t\tif (netdev->flags & IFF_ALLMULTI)\n\t\t\tadapter->current_netdev_promisc_flags |= IFF_ALLMULTI;\n\t\telse\n\t\t\tadapter->current_netdev_promisc_flags &= ~IFF_ALLMULTI;\n\n\t\tdev_info(&adapter->pdev->dev, \"Entering promiscuous mode\\n\");\n\t}\n\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_CONFIGURE_PROMISC_MODE;\n\n\t \n\tspin_unlock_bh(&adapter->current_netdev_promisc_flags_lock);\n\n\tadapter->current_op = VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE;\n\tvpi.vsi_id = adapter->vsi_res->vsi_id;\n\tvpi.flags = flags;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,\n\t\t\t (u8 *)&vpi, sizeof(vpi));\n}\n\n \nvoid iavf_request_stats(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_queue_select vqs;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\treturn;\n\t}\n\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_REQUEST_STATS;\n\tadapter->current_op = VIRTCHNL_OP_GET_STATS;\n\tvqs.vsi_id = adapter->vsi_res->vsi_id;\n\t \n\tif (iavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_STATS, (u8 *)&vqs,\n\t\t\t     sizeof(vqs)))\n\t\t \n\t\tadapter->current_op = VIRTCHNL_OP_UNKNOWN;\n}\n\n \nvoid iavf_get_hena(struct iavf_adapter *adapter)\n{\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot get RSS hash capabilities, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_GET_RSS_HENA_CAPS;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_GET_HENA;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_RSS_HENA_CAPS, NULL, 0);\n}\n\n \nvoid iavf_set_hena(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_rss_hena vrh;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot set RSS hash enable, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tvrh.hena = adapter->hena;\n\tadapter->current_op = VIRTCHNL_OP_SET_RSS_HENA;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_SET_HENA;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_SET_RSS_HENA, (u8 *)&vrh,\n\t\t\t sizeof(vrh));\n}\n\n \nvoid iavf_set_rss_key(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_rss_key *vrk;\n\tint len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot set RSS key, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tlen = virtchnl_struct_size(vrk, key, adapter->rss_key_size);\n\tvrk = kzalloc(len, GFP_KERNEL);\n\tif (!vrk)\n\t\treturn;\n\tvrk->vsi_id = adapter->vsi.id;\n\tvrk->key_len = adapter->rss_key_size;\n\tmemcpy(vrk->key, adapter->rss_key, adapter->rss_key_size);\n\n\tadapter->current_op = VIRTCHNL_OP_CONFIG_RSS_KEY;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_SET_RSS_KEY;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_CONFIG_RSS_KEY, (u8 *)vrk, len);\n\tkfree(vrk);\n}\n\n \nvoid iavf_set_rss_lut(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_rss_lut *vrl;\n\tint len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot set RSS LUT, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tlen = virtchnl_struct_size(vrl, lut, adapter->rss_lut_size);\n\tvrl = kzalloc(len, GFP_KERNEL);\n\tif (!vrl)\n\t\treturn;\n\tvrl->vsi_id = adapter->vsi.id;\n\tvrl->lut_entries = adapter->rss_lut_size;\n\tmemcpy(vrl->lut, adapter->rss_lut, adapter->rss_lut_size);\n\tadapter->current_op = VIRTCHNL_OP_CONFIG_RSS_LUT;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_SET_RSS_LUT;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_CONFIG_RSS_LUT, (u8 *)vrl, len);\n\tkfree(vrl);\n}\n\n \nvoid iavf_enable_vlan_stripping(struct iavf_adapter *adapter)\n{\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot enable stripping, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_ENABLE_VLAN_STRIPPING;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_ENABLE_VLAN_STRIPPING;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING, NULL, 0);\n}\n\n \nvoid iavf_disable_vlan_stripping(struct iavf_adapter *adapter)\n{\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot disable stripping, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_DISABLE_VLAN_STRIPPING;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_DISABLE_VLAN_STRIPPING;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING, NULL, 0);\n}\n\n \nstatic u32 iavf_tpid_to_vc_ethertype(u16 tpid)\n{\n\tswitch (tpid) {\n\tcase ETH_P_8021Q:\n\t\treturn VIRTCHNL_VLAN_ETHERTYPE_8100;\n\tcase ETH_P_8021AD:\n\t\treturn VIRTCHNL_VLAN_ETHERTYPE_88A8;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\niavf_set_vc_offload_ethertype(struct iavf_adapter *adapter,\n\t\t\t      struct virtchnl_vlan_setting *msg, u16 tpid,\n\t\t\t      enum virtchnl_ops offload_op)\n{\n\tstruct virtchnl_vlan_supported_caps *offload_support;\n\tu16 vc_ethertype = iavf_tpid_to_vc_ethertype(tpid);\n\n\t \n\tswitch (offload_op) {\n\tcase VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2:\n\tcase VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2:\n\t\toffload_support =\n\t\t\t&adapter->vlan_v2_caps.offloads.stripping_support;\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2:\n\tcase VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2:\n\t\toffload_support =\n\t\t\t&adapter->vlan_v2_caps.offloads.insertion_support;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->pdev->dev, \"Invalid opcode %d for setting virtchnl ethertype to enable/disable VLAN offloads\\n\",\n\t\t\toffload_op);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (offload_support->outer & vc_ethertype &&\n\t    offload_support->outer & VIRTCHNL_VLAN_TOGGLE) {\n\t\tmsg->outer_ethertype_setting = vc_ethertype;\n\t} else if (offload_support->inner & vc_ethertype &&\n\t\t   offload_support->inner & VIRTCHNL_VLAN_TOGGLE) {\n\t\tmsg->inner_ethertype_setting = vc_ethertype;\n\t} else {\n\t\tdev_dbg(&adapter->pdev->dev, \"opcode %d unsupported for VLAN TPID 0x%04x\\n\",\n\t\t\toffload_op, tpid);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\niavf_clear_offload_v2_aq_required(struct iavf_adapter *adapter, u16 tpid,\n\t\t\t\t  enum virtchnl_ops offload_op)\n{\n\tswitch (offload_op) {\n\tcase VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2:\n\t\tif (tpid == ETH_P_8021Q)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_ENABLE_CTAG_VLAN_STRIPPING;\n\t\telse if (tpid == ETH_P_8021AD)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_ENABLE_STAG_VLAN_STRIPPING;\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2:\n\t\tif (tpid == ETH_P_8021Q)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_DISABLE_CTAG_VLAN_STRIPPING;\n\t\telse if (tpid == ETH_P_8021AD)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_DISABLE_STAG_VLAN_STRIPPING;\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2:\n\t\tif (tpid == ETH_P_8021Q)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_ENABLE_CTAG_VLAN_INSERTION;\n\t\telse if (tpid == ETH_P_8021AD)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_ENABLE_STAG_VLAN_INSERTION;\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2:\n\t\tif (tpid == ETH_P_8021Q)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_DISABLE_CTAG_VLAN_INSERTION;\n\t\telse if (tpid == ETH_P_8021AD)\n\t\t\tadapter->aq_required &=\n\t\t\t\t~IAVF_FLAG_AQ_DISABLE_STAG_VLAN_INSERTION;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->pdev->dev, \"Unsupported opcode %d specified for clearing aq_required bits for VIRTCHNL_VF_OFFLOAD_VLAN_V2 offload request\\n\",\n\t\t\toffload_op);\n\t}\n}\n\n \nstatic void\niavf_send_vlan_offload_v2(struct iavf_adapter *adapter, u16 tpid,\n\t\t\t  enum virtchnl_ops offload_op)\n{\n\tstruct virtchnl_vlan_setting *msg;\n\tint len = sizeof(*msg);\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot send %d, command %d pending\\n\",\n\t\t\toffload_op, adapter->current_op);\n\t\treturn;\n\t}\n\n\tadapter->current_op = offload_op;\n\n\tmsg = kzalloc(len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tmsg->vport_id = adapter->vsi_res->vsi_id;\n\n\t \n\tiavf_clear_offload_v2_aq_required(adapter, tpid, offload_op);\n\n\t \n\tif (!iavf_set_vc_offload_ethertype(adapter, msg, tpid, offload_op))\n\t\tiavf_send_pf_msg(adapter, offload_op, (u8 *)msg, len);\n\telse\n\t\tadapter->current_op = VIRTCHNL_OP_UNKNOWN;\n\n\tkfree(msg);\n}\n\n \nvoid iavf_enable_vlan_stripping_v2(struct iavf_adapter *adapter, u16 tpid)\n{\n\tiavf_send_vlan_offload_v2(adapter, tpid,\n\t\t\t\t  VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2);\n}\n\n \nvoid iavf_disable_vlan_stripping_v2(struct iavf_adapter *adapter, u16 tpid)\n{\n\tiavf_send_vlan_offload_v2(adapter, tpid,\n\t\t\t\t  VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2);\n}\n\n \nvoid iavf_enable_vlan_insertion_v2(struct iavf_adapter *adapter, u16 tpid)\n{\n\tiavf_send_vlan_offload_v2(adapter, tpid,\n\t\t\t\t  VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2);\n}\n\n \nvoid iavf_disable_vlan_insertion_v2(struct iavf_adapter *adapter, u16 tpid)\n{\n\tiavf_send_vlan_offload_v2(adapter, tpid,\n\t\t\t\t  VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2);\n}\n\n#define IAVF_MAX_SPEED_STRLEN\t13\n\n \nstatic void iavf_print_link_message(struct iavf_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint link_speed_mbps;\n\tchar *speed;\n\n\tif (!adapter->link_up) {\n\t\tnetdev_info(netdev, \"NIC Link is Down\\n\");\n\t\treturn;\n\t}\n\n\tspeed = kzalloc(IAVF_MAX_SPEED_STRLEN, GFP_KERNEL);\n\tif (!speed)\n\t\treturn;\n\n\tif (ADV_LINK_SUPPORT(adapter)) {\n\t\tlink_speed_mbps = adapter->link_speed_mbps;\n\t\tgoto print_link_msg;\n\t}\n\n\tswitch (adapter->link_speed) {\n\tcase VIRTCHNL_LINK_SPEED_40GB:\n\t\tlink_speed_mbps = SPEED_40000;\n\t\tbreak;\n\tcase VIRTCHNL_LINK_SPEED_25GB:\n\t\tlink_speed_mbps = SPEED_25000;\n\t\tbreak;\n\tcase VIRTCHNL_LINK_SPEED_20GB:\n\t\tlink_speed_mbps = SPEED_20000;\n\t\tbreak;\n\tcase VIRTCHNL_LINK_SPEED_10GB:\n\t\tlink_speed_mbps = SPEED_10000;\n\t\tbreak;\n\tcase VIRTCHNL_LINK_SPEED_5GB:\n\t\tlink_speed_mbps = SPEED_5000;\n\t\tbreak;\n\tcase VIRTCHNL_LINK_SPEED_2_5GB:\n\t\tlink_speed_mbps = SPEED_2500;\n\t\tbreak;\n\tcase VIRTCHNL_LINK_SPEED_1GB:\n\t\tlink_speed_mbps = SPEED_1000;\n\t\tbreak;\n\tcase VIRTCHNL_LINK_SPEED_100MB:\n\t\tlink_speed_mbps = SPEED_100;\n\t\tbreak;\n\tdefault:\n\t\tlink_speed_mbps = SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\nprint_link_msg:\n\tif (link_speed_mbps > SPEED_1000) {\n\t\tif (link_speed_mbps == SPEED_2500)\n\t\t\tsnprintf(speed, IAVF_MAX_SPEED_STRLEN, \"2.5 Gbps\");\n\t\telse\n\t\t\t \n\t\t\tsnprintf(speed, IAVF_MAX_SPEED_STRLEN, \"%d %s\",\n\t\t\t\t link_speed_mbps / 1000, \"Gbps\");\n\t} else if (link_speed_mbps == SPEED_UNKNOWN) {\n\t\tsnprintf(speed, IAVF_MAX_SPEED_STRLEN, \"%s\", \"Unknown Mbps\");\n\t} else {\n\t\tsnprintf(speed, IAVF_MAX_SPEED_STRLEN, \"%d %s\",\n\t\t\t link_speed_mbps, \"Mbps\");\n\t}\n\n\tnetdev_info(netdev, \"NIC Link is Up Speed is %s Full Duplex\\n\", speed);\n\tkfree(speed);\n}\n\n \nstatic bool\niavf_get_vpe_link_status(struct iavf_adapter *adapter,\n\t\t\t struct virtchnl_pf_event *vpe)\n{\n\tif (ADV_LINK_SUPPORT(adapter))\n\t\treturn vpe->event_data.link_event_adv.link_status;\n\telse\n\t\treturn vpe->event_data.link_event.link_status;\n}\n\n \nstatic void\niavf_set_adapter_link_speed_from_vpe(struct iavf_adapter *adapter,\n\t\t\t\t     struct virtchnl_pf_event *vpe)\n{\n\tif (ADV_LINK_SUPPORT(adapter))\n\t\tadapter->link_speed_mbps =\n\t\t\tvpe->event_data.link_event_adv.link_speed;\n\telse\n\t\tadapter->link_speed = vpe->event_data.link_event.link_speed;\n}\n\n \nvoid iavf_enable_channels(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_tc_info *vti = NULL;\n\tsize_t len;\n\tint i;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot configure mqprio, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tlen = virtchnl_struct_size(vti, list, adapter->num_tc);\n\tvti = kzalloc(len, GFP_KERNEL);\n\tif (!vti)\n\t\treturn;\n\tvti->num_tc = adapter->num_tc;\n\tfor (i = 0; i < vti->num_tc; i++) {\n\t\tvti->list[i].count = adapter->ch_config.ch_info[i].count;\n\t\tvti->list[i].offset = adapter->ch_config.ch_info[i].offset;\n\t\tvti->list[i].pad = 0;\n\t\tvti->list[i].max_tx_rate =\n\t\t\t\tadapter->ch_config.ch_info[i].max_tx_rate;\n\t}\n\n\tadapter->ch_config.state = __IAVF_TC_RUNNING;\n\tadapter->flags |= IAVF_FLAG_REINIT_ITR_NEEDED;\n\tadapter->current_op = VIRTCHNL_OP_ENABLE_CHANNELS;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_ENABLE_CHANNELS;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ENABLE_CHANNELS, (u8 *)vti, len);\n\tkfree(vti);\n}\n\n \nvoid iavf_disable_channels(struct iavf_adapter *adapter)\n{\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot configure mqprio, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tadapter->ch_config.state = __IAVF_TC_INVALID;\n\tadapter->flags |= IAVF_FLAG_REINIT_ITR_NEEDED;\n\tadapter->current_op = VIRTCHNL_OP_DISABLE_CHANNELS;\n\tadapter->aq_required &= ~IAVF_FLAG_AQ_DISABLE_CHANNELS;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DISABLE_CHANNELS, NULL, 0);\n}\n\n \nstatic void iavf_print_cloud_filter(struct iavf_adapter *adapter,\n\t\t\t\t    struct virtchnl_filter *f)\n{\n\tswitch (f->flow_type) {\n\tcase VIRTCHNL_TCP_V4_FLOW:\n\t\tdev_info(&adapter->pdev->dev, \"dst_mac: %pM src_mac: %pM vlan_id: %hu dst_ip: %pI4 src_ip %pI4 dst_port %hu src_port %hu\\n\",\n\t\t\t &f->data.tcp_spec.dst_mac,\n\t\t\t &f->data.tcp_spec.src_mac,\n\t\t\t ntohs(f->data.tcp_spec.vlan_id),\n\t\t\t &f->data.tcp_spec.dst_ip[0],\n\t\t\t &f->data.tcp_spec.src_ip[0],\n\t\t\t ntohs(f->data.tcp_spec.dst_port),\n\t\t\t ntohs(f->data.tcp_spec.src_port));\n\t\tbreak;\n\tcase VIRTCHNL_TCP_V6_FLOW:\n\t\tdev_info(&adapter->pdev->dev, \"dst_mac: %pM src_mac: %pM vlan_id: %hu dst_ip: %pI6 src_ip %pI6 dst_port %hu src_port %hu\\n\",\n\t\t\t &f->data.tcp_spec.dst_mac,\n\t\t\t &f->data.tcp_spec.src_mac,\n\t\t\t ntohs(f->data.tcp_spec.vlan_id),\n\t\t\t &f->data.tcp_spec.dst_ip,\n\t\t\t &f->data.tcp_spec.src_ip,\n\t\t\t ntohs(f->data.tcp_spec.dst_port),\n\t\t\t ntohs(f->data.tcp_spec.src_port));\n\t\tbreak;\n\t}\n}\n\n \nvoid iavf_add_cloud_filter(struct iavf_adapter *adapter)\n{\n\tstruct iavf_cloud_filter *cf;\n\tstruct virtchnl_filter *f;\n\tint len = 0, count = 0;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot add cloud filter, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tlist_for_each_entry(cf, &adapter->cloud_filter_list, list) {\n\t\tif (cf->add) {\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!count) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_CLOUD_FILTER;\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_ADD_CLOUD_FILTER;\n\n\tlen = sizeof(struct virtchnl_filter);\n\tf = kzalloc(len, GFP_KERNEL);\n\tif (!f)\n\t\treturn;\n\n\tlist_for_each_entry(cf, &adapter->cloud_filter_list, list) {\n\t\tif (cf->add) {\n\t\t\tmemcpy(f, &cf->f, sizeof(struct virtchnl_filter));\n\t\t\tcf->add = false;\n\t\t\tcf->state = __IAVF_CF_ADD_PENDING;\n\t\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_CLOUD_FILTER,\n\t\t\t\t\t (u8 *)f, len);\n\t\t}\n\t}\n\tkfree(f);\n}\n\n \nvoid iavf_del_cloud_filter(struct iavf_adapter *adapter)\n{\n\tstruct iavf_cloud_filter *cf, *cftmp;\n\tstruct virtchnl_filter *f;\n\tint len = 0, count = 0;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot remove cloud filter, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\tlist_for_each_entry(cf, &adapter->cloud_filter_list, list) {\n\t\tif (cf->del) {\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!count) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_CLOUD_FILTER;\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_DEL_CLOUD_FILTER;\n\n\tlen = sizeof(struct virtchnl_filter);\n\tf = kzalloc(len, GFP_KERNEL);\n\tif (!f)\n\t\treturn;\n\n\tlist_for_each_entry_safe(cf, cftmp, &adapter->cloud_filter_list, list) {\n\t\tif (cf->del) {\n\t\t\tmemcpy(f, &cf->f, sizeof(struct virtchnl_filter));\n\t\t\tcf->del = false;\n\t\t\tcf->state = __IAVF_CF_DEL_PENDING;\n\t\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_CLOUD_FILTER,\n\t\t\t\t\t (u8 *)f, len);\n\t\t}\n\t}\n\tkfree(f);\n}\n\n \nvoid iavf_add_fdir_filter(struct iavf_adapter *adapter)\n{\n\tstruct iavf_fdir_fltr *fdir;\n\tstruct virtchnl_fdir_add *f;\n\tbool process_fltr = false;\n\tint len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot add Flow Director filter, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tlen = sizeof(struct virtchnl_fdir_add);\n\tf = kzalloc(len, GFP_KERNEL);\n\tif (!f)\n\t\treturn;\n\n\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\tlist_for_each_entry(fdir, &adapter->fdir_list_head, list) {\n\t\tif (fdir->state == IAVF_FDIR_FLTR_ADD_REQUEST) {\n\t\t\tprocess_fltr = true;\n\t\t\tfdir->state = IAVF_FDIR_FLTR_ADD_PENDING;\n\t\t\tmemcpy(f, &fdir->vc_add_msg, len);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\n\tif (!process_fltr) {\n\t\t \n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_FDIR_FILTER;\n\t\tkfree(f);\n\t\treturn;\n\t}\n\tadapter->current_op = VIRTCHNL_OP_ADD_FDIR_FILTER;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_FDIR_FILTER, (u8 *)f, len);\n\tkfree(f);\n}\n\n \nvoid iavf_del_fdir_filter(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_fdir_del f = {};\n\tstruct iavf_fdir_fltr *fdir;\n\tbool process_fltr = false;\n\tint len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot remove Flow Director filter, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tlen = sizeof(struct virtchnl_fdir_del);\n\n\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\tlist_for_each_entry(fdir, &adapter->fdir_list_head, list) {\n\t\tif (fdir->state == IAVF_FDIR_FLTR_DEL_REQUEST) {\n\t\t\tprocess_fltr = true;\n\t\t\tf.vsi_id = fdir->vc_add_msg.vsi_id;\n\t\t\tf.flow_id = fdir->flow_id;\n\t\t\tfdir->state = IAVF_FDIR_FLTR_DEL_PENDING;\n\t\t\tbreak;\n\t\t} else if (fdir->state == IAVF_FDIR_FLTR_DIS_REQUEST) {\n\t\t\tprocess_fltr = true;\n\t\t\tf.vsi_id = fdir->vc_add_msg.vsi_id;\n\t\t\tf.flow_id = fdir->flow_id;\n\t\t\tfdir->state = IAVF_FDIR_FLTR_DIS_PENDING;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\n\tif (!process_fltr) {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_FDIR_FILTER;\n\t\treturn;\n\t}\n\n\tadapter->current_op = VIRTCHNL_OP_DEL_FDIR_FILTER;\n\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_FDIR_FILTER, (u8 *)&f, len);\n}\n\n \nvoid iavf_add_adv_rss_cfg(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_rss_cfg *rss_cfg;\n\tstruct iavf_adv_rss *rss;\n\tbool process_rss = false;\n\tint len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot add RSS configuration, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tlen = sizeof(struct virtchnl_rss_cfg);\n\trss_cfg = kzalloc(len, GFP_KERNEL);\n\tif (!rss_cfg)\n\t\treturn;\n\n\tspin_lock_bh(&adapter->adv_rss_lock);\n\tlist_for_each_entry(rss, &adapter->adv_rss_list_head, list) {\n\t\tif (rss->state == IAVF_ADV_RSS_ADD_REQUEST) {\n\t\t\tprocess_rss = true;\n\t\t\trss->state = IAVF_ADV_RSS_ADD_PENDING;\n\t\t\tmemcpy(rss_cfg, &rss->cfg_msg, len);\n\t\t\tiavf_print_adv_rss_cfg(adapter, rss,\n\t\t\t\t\t       \"Input set change for\",\n\t\t\t\t\t       \"is pending\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->adv_rss_lock);\n\n\tif (process_rss) {\n\t\tadapter->current_op = VIRTCHNL_OP_ADD_RSS_CFG;\n\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_RSS_CFG,\n\t\t\t\t (u8 *)rss_cfg, len);\n\t} else {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_ADD_ADV_RSS_CFG;\n\t}\n\n\tkfree(rss_cfg);\n}\n\n \nvoid iavf_del_adv_rss_cfg(struct iavf_adapter *adapter)\n{\n\tstruct virtchnl_rss_cfg *rss_cfg;\n\tstruct iavf_adv_rss *rss;\n\tbool process_rss = false;\n\tint len;\n\n\tif (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {\n\t\t \n\t\tdev_err(&adapter->pdev->dev, \"Cannot remove RSS configuration, command %d pending\\n\",\n\t\t\tadapter->current_op);\n\t\treturn;\n\t}\n\n\tlen = sizeof(struct virtchnl_rss_cfg);\n\trss_cfg = kzalloc(len, GFP_KERNEL);\n\tif (!rss_cfg)\n\t\treturn;\n\n\tspin_lock_bh(&adapter->adv_rss_lock);\n\tlist_for_each_entry(rss, &adapter->adv_rss_list_head, list) {\n\t\tif (rss->state == IAVF_ADV_RSS_DEL_REQUEST) {\n\t\t\tprocess_rss = true;\n\t\t\trss->state = IAVF_ADV_RSS_DEL_PENDING;\n\t\t\tmemcpy(rss_cfg, &rss->cfg_msg, len);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->adv_rss_lock);\n\n\tif (process_rss) {\n\t\tadapter->current_op = VIRTCHNL_OP_DEL_RSS_CFG;\n\t\tiavf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_RSS_CFG,\n\t\t\t\t (u8 *)rss_cfg, len);\n\t} else {\n\t\tadapter->aq_required &= ~IAVF_FLAG_AQ_DEL_ADV_RSS_CFG;\n\t}\n\n\tkfree(rss_cfg);\n}\n\n \nint iavf_request_reset(struct iavf_adapter *adapter)\n{\n\tint err;\n\t \n\terr = iavf_send_pf_msg(adapter, VIRTCHNL_OP_RESET_VF, NULL, 0);\n\tadapter->current_op = VIRTCHNL_OP_UNKNOWN;\n\treturn err;\n}\n\n \nstatic void iavf_netdev_features_vlan_strip_set(struct net_device *netdev,\n\t\t\t\t\t\tconst bool enable)\n{\n\tif (enable)\n\t\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_RX;\n\telse\n\t\tnetdev->features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n}\n\n \nstatic void iavf_activate_fdir_filters(struct iavf_adapter *adapter)\n{\n\tstruct iavf_fdir_fltr *f, *ftmp;\n\tbool add_filters = false;\n\n\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\tlist_for_each_entry_safe(f, ftmp, &adapter->fdir_list_head, list) {\n\t\tif (f->state == IAVF_FDIR_FLTR_ADD_REQUEST ||\n\t\t    f->state == IAVF_FDIR_FLTR_ADD_PENDING ||\n\t\t    f->state == IAVF_FDIR_FLTR_ACTIVE) {\n\t\t\t \n\t\t\tf->state = IAVF_FDIR_FLTR_ADD_REQUEST;\n\t\t\tadd_filters = true;\n\t\t} else if (f->state == IAVF_FDIR_FLTR_DIS_REQUEST ||\n\t\t\t   f->state == IAVF_FDIR_FLTR_DIS_PENDING) {\n\t\t\t \n\t\t\tf->state = IAVF_FDIR_FLTR_INACTIVE;\n\t\t} else if (f->state == IAVF_FDIR_FLTR_DEL_REQUEST ||\n\t\t\t   f->state == IAVF_FDIR_FLTR_DEL_PENDING) {\n\t\t\t \n\t\t\tlist_del(&f->list);\n\t\t\tkfree(f);\n\t\t\tadapter->fdir_active_fltr--;\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\n\tif (add_filters)\n\t\tadapter->aq_required |= IAVF_FLAG_AQ_ADD_FDIR_FILTER;\n}\n\n \nvoid iavf_virtchnl_completion(struct iavf_adapter *adapter,\n\t\t\t      enum virtchnl_ops v_opcode,\n\t\t\t      enum iavf_status v_retval, u8 *msg, u16 msglen)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (v_opcode == VIRTCHNL_OP_EVENT) {\n\t\tstruct virtchnl_pf_event *vpe =\n\t\t\t(struct virtchnl_pf_event *)msg;\n\t\tbool link_up = iavf_get_vpe_link_status(adapter, vpe);\n\n\t\tswitch (vpe->event) {\n\t\tcase VIRTCHNL_EVENT_LINK_CHANGE:\n\t\t\tiavf_set_adapter_link_speed_from_vpe(adapter, vpe);\n\n\t\t\t \n\t\t\tif (adapter->link_up == link_up)\n\t\t\t\tbreak;\n\n\t\t\tif (link_up) {\n\t\t\t\t \n\t\t\t\tif (adapter->state != __IAVF_RUNNING)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (adapter->flags &\n\t\t\t\t    IAVF_FLAG_QUEUES_DISABLED)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tadapter->link_up = link_up;\n\t\t\tif (link_up) {\n\t\t\t\tnetif_tx_start_all_queues(netdev);\n\t\t\t\tnetif_carrier_on(netdev);\n\t\t\t} else {\n\t\t\t\tnetif_tx_stop_all_queues(netdev);\n\t\t\t\tnetif_carrier_off(netdev);\n\t\t\t}\n\t\t\tiavf_print_link_message(adapter);\n\t\t\tbreak;\n\t\tcase VIRTCHNL_EVENT_RESET_IMPENDING:\n\t\t\tdev_info(&adapter->pdev->dev, \"Reset indication received from the PF\\n\");\n\t\t\tif (!(adapter->flags & IAVF_FLAG_RESET_PENDING)) {\n\t\t\t\tdev_info(&adapter->pdev->dev, \"Scheduling reset task\\n\");\n\t\t\t\tiavf_schedule_reset(adapter, IAVF_FLAG_RESET_PENDING);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&adapter->pdev->dev, \"Unknown event %d from PF\\n\",\n\t\t\t\tvpe->event);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (v_retval) {\n\t\tswitch (v_opcode) {\n\t\tcase VIRTCHNL_OP_ADD_VLAN:\n\t\t\tdev_err(&adapter->pdev->dev, \"Failed to add VLAN filter, error %s\\n\",\n\t\t\t\tiavf_stat_str(&adapter->hw, v_retval));\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_ADD_ETH_ADDR:\n\t\t\tdev_err(&adapter->pdev->dev, \"Failed to add MAC filter, error %s\\n\",\n\t\t\t\tiavf_stat_str(&adapter->hw, v_retval));\n\t\t\tiavf_mac_add_reject(adapter);\n\t\t\t \n\t\t\tether_addr_copy(adapter->hw.mac.addr, netdev->dev_addr);\n\t\t\twake_up(&adapter->vc_waitqueue);\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_DEL_VLAN:\n\t\t\tdev_err(&adapter->pdev->dev, \"Failed to delete VLAN filter, error %s\\n\",\n\t\t\t\tiavf_stat_str(&adapter->hw, v_retval));\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_DEL_ETH_ADDR:\n\t\t\tdev_err(&adapter->pdev->dev, \"Failed to delete MAC filter, error %s\\n\",\n\t\t\t\tiavf_stat_str(&adapter->hw, v_retval));\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_ENABLE_CHANNELS:\n\t\t\tdev_err(&adapter->pdev->dev, \"Failed to configure queue channels, error %s\\n\",\n\t\t\t\tiavf_stat_str(&adapter->hw, v_retval));\n\t\t\tadapter->flags &= ~IAVF_FLAG_REINIT_ITR_NEEDED;\n\t\t\tadapter->ch_config.state = __IAVF_TC_INVALID;\n\t\t\tnetdev_reset_tc(netdev);\n\t\t\tnetif_tx_start_all_queues(netdev);\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_DISABLE_CHANNELS:\n\t\t\tdev_err(&adapter->pdev->dev, \"Failed to disable queue channels, error %s\\n\",\n\t\t\t\tiavf_stat_str(&adapter->hw, v_retval));\n\t\t\tadapter->flags &= ~IAVF_FLAG_REINIT_ITR_NEEDED;\n\t\t\tadapter->ch_config.state = __IAVF_TC_RUNNING;\n\t\t\tnetif_tx_start_all_queues(netdev);\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_ADD_CLOUD_FILTER: {\n\t\t\tstruct iavf_cloud_filter *cf, *cftmp;\n\n\t\t\tlist_for_each_entry_safe(cf, cftmp,\n\t\t\t\t\t\t &adapter->cloud_filter_list,\n\t\t\t\t\t\t list) {\n\t\t\t\tif (cf->state == __IAVF_CF_ADD_PENDING) {\n\t\t\t\t\tcf->state = __IAVF_CF_INVALID;\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Failed to add cloud filter, error %s\\n\",\n\t\t\t\t\t\t iavf_stat_str(&adapter->hw,\n\t\t\t\t\t\t\t       v_retval));\n\t\t\t\t\tiavf_print_cloud_filter(adapter,\n\t\t\t\t\t\t\t\t&cf->f);\n\t\t\t\t\tlist_del(&cf->list);\n\t\t\t\t\tkfree(cf);\n\t\t\t\t\tadapter->num_cloud_filters--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_DEL_CLOUD_FILTER: {\n\t\t\tstruct iavf_cloud_filter *cf;\n\n\t\t\tlist_for_each_entry(cf, &adapter->cloud_filter_list,\n\t\t\t\t\t    list) {\n\t\t\t\tif (cf->state == __IAVF_CF_DEL_PENDING) {\n\t\t\t\t\tcf->state = __IAVF_CF_ACTIVE;\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Failed to del cloud filter, error %s\\n\",\n\t\t\t\t\t\t iavf_stat_str(&adapter->hw,\n\t\t\t\t\t\t\t       v_retval));\n\t\t\t\t\tiavf_print_cloud_filter(adapter,\n\t\t\t\t\t\t\t\t&cf->f);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_ADD_FDIR_FILTER: {\n\t\t\tstruct iavf_fdir_fltr *fdir, *fdir_tmp;\n\n\t\t\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\t\t\tlist_for_each_entry_safe(fdir, fdir_tmp,\n\t\t\t\t\t\t &adapter->fdir_list_head,\n\t\t\t\t\t\t list) {\n\t\t\t\tif (fdir->state == IAVF_FDIR_FLTR_ADD_PENDING) {\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Failed to add Flow Director filter, error %s\\n\",\n\t\t\t\t\t\t iavf_stat_str(&adapter->hw,\n\t\t\t\t\t\t\t       v_retval));\n\t\t\t\t\tiavf_print_fdir_fltr(adapter, fdir);\n\t\t\t\t\tif (msglen)\n\t\t\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\t\t\"%s\\n\", msg);\n\t\t\t\t\tlist_del(&fdir->list);\n\t\t\t\t\tkfree(fdir);\n\t\t\t\t\tadapter->fdir_active_fltr--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_DEL_FDIR_FILTER: {\n\t\t\tstruct iavf_fdir_fltr *fdir;\n\n\t\t\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\t\t\tlist_for_each_entry(fdir, &adapter->fdir_list_head,\n\t\t\t\t\t    list) {\n\t\t\t\tif (fdir->state == IAVF_FDIR_FLTR_DEL_PENDING ||\n\t\t\t\t    fdir->state == IAVF_FDIR_FLTR_DIS_PENDING) {\n\t\t\t\t\tfdir->state = IAVF_FDIR_FLTR_ACTIVE;\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Failed to del Flow Director filter, error %s\\n\",\n\t\t\t\t\t\t iavf_stat_str(&adapter->hw,\n\t\t\t\t\t\t\t       v_retval));\n\t\t\t\t\tiavf_print_fdir_fltr(adapter, fdir);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_ADD_RSS_CFG: {\n\t\t\tstruct iavf_adv_rss *rss, *rss_tmp;\n\n\t\t\tspin_lock_bh(&adapter->adv_rss_lock);\n\t\t\tlist_for_each_entry_safe(rss, rss_tmp,\n\t\t\t\t\t\t &adapter->adv_rss_list_head,\n\t\t\t\t\t\t list) {\n\t\t\t\tif (rss->state == IAVF_ADV_RSS_ADD_PENDING) {\n\t\t\t\t\tiavf_print_adv_rss_cfg(adapter, rss,\n\t\t\t\t\t\t\t       \"Failed to change the input set for\",\n\t\t\t\t\t\t\t       NULL);\n\t\t\t\t\tlist_del(&rss->list);\n\t\t\t\t\tkfree(rss);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&adapter->adv_rss_lock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_DEL_RSS_CFG: {\n\t\t\tstruct iavf_adv_rss *rss;\n\n\t\t\tspin_lock_bh(&adapter->adv_rss_lock);\n\t\t\tlist_for_each_entry(rss, &adapter->adv_rss_list_head,\n\t\t\t\t\t    list) {\n\t\t\t\tif (rss->state == IAVF_ADV_RSS_DEL_PENDING) {\n\t\t\t\t\trss->state = IAVF_ADV_RSS_ACTIVE;\n\t\t\t\t\tdev_err(&adapter->pdev->dev, \"Failed to delete RSS configuration, error %s\\n\",\n\t\t\t\t\t\tiavf_stat_str(&adapter->hw,\n\t\t\t\t\t\t\t      v_retval));\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&adapter->adv_rss_lock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_ENABLE_VLAN_STRIPPING:\n\t\t\tdev_warn(&adapter->pdev->dev, \"Changing VLAN Stripping is not allowed when Port VLAN is configured\\n\");\n\t\t\t \n\t\t\tiavf_netdev_features_vlan_strip_set(netdev, false);\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_DISABLE_VLAN_STRIPPING:\n\t\t\tdev_warn(&adapter->pdev->dev, \"Changing VLAN Stripping is not allowed when Port VLAN is configured\\n\");\n\t\t\t \n\t\t\tiavf_netdev_features_vlan_strip_set(netdev, true);\n\t\t\tbreak;\n\t\tcase VIRTCHNL_OP_ADD_VLAN_V2:\n\t\t\tiavf_vlan_add_reject(adapter);\n\t\t\tdev_warn(&adapter->pdev->dev, \"Failed to add VLAN filter, error %s\\n\",\n\t\t\t\t iavf_stat_str(&adapter->hw, v_retval));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&adapter->pdev->dev, \"PF returned error %d (%s) to our request %d\\n\",\n\t\t\t\tv_retval, iavf_stat_str(&adapter->hw, v_retval),\n\t\t\t\tv_opcode);\n\t\t}\n\t}\n\tswitch (v_opcode) {\n\tcase VIRTCHNL_OP_ADD_ETH_ADDR:\n\t\tif (!v_retval)\n\t\t\tiavf_mac_add_ok(adapter);\n\t\tif (!ether_addr_equal(netdev->dev_addr, adapter->hw.mac.addr))\n\t\t\tif (!ether_addr_equal(netdev->dev_addr,\n\t\t\t\t\t      adapter->hw.mac.addr)) {\n\t\t\t\tnetif_addr_lock_bh(netdev);\n\t\t\t\teth_hw_addr_set(netdev, adapter->hw.mac.addr);\n\t\t\t\tnetif_addr_unlock_bh(netdev);\n\t\t\t}\n\t\twake_up(&adapter->vc_waitqueue);\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_STATS: {\n\t\tstruct iavf_eth_stats *stats =\n\t\t\t(struct iavf_eth_stats *)msg;\n\t\tnetdev->stats.rx_packets = stats->rx_unicast +\n\t\t\t\t\t   stats->rx_multicast +\n\t\t\t\t\t   stats->rx_broadcast;\n\t\tnetdev->stats.tx_packets = stats->tx_unicast +\n\t\t\t\t\t   stats->tx_multicast +\n\t\t\t\t\t   stats->tx_broadcast;\n\t\tnetdev->stats.rx_bytes = stats->rx_bytes;\n\t\tnetdev->stats.tx_bytes = stats->tx_bytes;\n\t\tnetdev->stats.tx_errors = stats->tx_errors;\n\t\tnetdev->stats.rx_dropped = stats->rx_discards;\n\t\tnetdev->stats.tx_dropped = stats->tx_discards;\n\t\tadapter->current_stats = *stats;\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_VF_RESOURCES: {\n\t\tu16 len = IAVF_VIRTCHNL_VF_RESOURCE_SIZE;\n\n\t\tmemcpy(adapter->vf_res, msg, min(msglen, len));\n\t\tiavf_validate_num_queues(adapter);\n\t\tiavf_vf_parse_hw_config(&adapter->hw, adapter->vf_res);\n\t\tif (is_zero_ether_addr(adapter->hw.mac.addr)) {\n\t\t\t \n\t\t\tether_addr_copy(adapter->hw.mac.addr, netdev->dev_addr);\n\t\t} else {\n\t\t\tnetif_addr_lock_bh(netdev);\n\t\t\t \n\t\t\tether_addr_copy(netdev->perm_addr,\n\t\t\t\t\tadapter->hw.mac.addr);\n\t\t\tnetif_addr_unlock_bh(netdev);\n\t\t}\n\t\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\t\tiavf_add_filter(adapter, adapter->hw.mac.addr);\n\n\t\tif (VLAN_ALLOWED(adapter)) {\n\t\t\tif (!list_empty(&adapter->vlan_filter_list)) {\n\t\t\t\tstruct iavf_vlan_filter *vlf;\n\n\t\t\t\t \n\t\t\t\tlist_for_each_entry(vlf,\n\t\t\t\t\t\t    &adapter->vlan_filter_list,\n\t\t\t\t\t\t    list)\n\t\t\t\t\tvlf->state = IAVF_VLAN_ADD;\n\n\t\t\t\tadapter->aq_required |=\n\t\t\t\t\tIAVF_FLAG_AQ_ADD_VLAN_FILTER;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\t\tiavf_activate_fdir_filters(adapter);\n\n\t\tiavf_parse_vf_resource_msg(adapter);\n\n\t\t \n\t\tif (VLAN_V2_ALLOWED(adapter))\n\t\t\tbreak;\n\t\t \n\t\t}\n\t\tfallthrough;\n\tcase VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS: {\n\t\tstruct iavf_mac_filter *f;\n\t\tbool was_mac_changed;\n\t\tu64 aq_required = 0;\n\n\t\tif (v_opcode == VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS)\n\t\t\tmemcpy(&adapter->vlan_v2_caps, msg,\n\t\t\t       min_t(u16, msglen,\n\t\t\t\t     sizeof(adapter->vlan_v2_caps)));\n\n\t\tiavf_process_config(adapter);\n\t\tadapter->flags |= IAVF_FLAG_SETUP_NETDEV_FEATURES;\n\t\tiavf_schedule_finish_config(adapter);\n\n\t\tiavf_set_queue_vlan_tag_loc(adapter);\n\n\t\twas_mac_changed = !ether_addr_equal(netdev->dev_addr,\n\t\t\t\t\t\t    adapter->hw.mac.addr);\n\n\t\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\n\t\t \n\t\tlist_for_each_entry(f, &adapter->mac_filter_list, list) {\n\t\t\tif (was_mac_changed &&\n\t\t\t    ether_addr_equal(netdev->dev_addr, f->macaddr))\n\t\t\t\tether_addr_copy(f->macaddr,\n\t\t\t\t\t\tadapter->hw.mac.addr);\n\n\t\t\tf->is_new_mac = true;\n\t\t\tf->add = true;\n\t\t\tf->add_handled = false;\n\t\t\tf->remove = false;\n\t\t}\n\n\t\t \n\t\tif (VLAN_FILTERING_ALLOWED(adapter)) {\n\t\t\tstruct iavf_vlan_filter *vlf;\n\n\t\t\tif (!list_empty(&adapter->vlan_filter_list)) {\n\t\t\t\tlist_for_each_entry(vlf,\n\t\t\t\t\t\t    &adapter->vlan_filter_list,\n\t\t\t\t\t\t    list)\n\t\t\t\t\tvlf->state = IAVF_VLAN_ADD;\n\n\t\t\t\taq_required |= IAVF_FLAG_AQ_ADD_VLAN_FILTER;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\n\t\tnetif_addr_lock_bh(netdev);\n\t\teth_hw_addr_set(netdev, adapter->hw.mac.addr);\n\t\tnetif_addr_unlock_bh(netdev);\n\n\t\tadapter->aq_required |= IAVF_FLAG_AQ_ADD_MAC_FILTER |\n\t\t\taq_required;\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_QUEUES:\n\t\t \n\t\tiavf_irq_enable(adapter, true);\n\t\twake_up(&adapter->reset_waitqueue);\n\t\tadapter->flags &= ~IAVF_FLAG_QUEUES_DISABLED;\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_QUEUES:\n\t\tiavf_free_all_tx_resources(adapter);\n\t\tiavf_free_all_rx_resources(adapter);\n\t\tif (adapter->state == __IAVF_DOWN_PENDING) {\n\t\t\tiavf_change_state(adapter, __IAVF_DOWN);\n\t\t\twake_up(&adapter->down_waitqueue);\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_VERSION:\n\tcase VIRTCHNL_OP_CONFIG_IRQ_MAP:\n\t\t \n\t\tif (v_opcode != adapter->current_op)\n\t\t\treturn;\n\t\tbreak;\n\tcase VIRTCHNL_OP_RDMA:\n\t\t \n\t\tif (msglen && CLIENT_ENABLED(adapter))\n\t\t\tiavf_notify_client_message(&adapter->vsi, msg, msglen);\n\t\tbreak;\n\n\tcase VIRTCHNL_OP_CONFIG_RDMA_IRQ_MAP:\n\t\tadapter->client_pending &=\n\t\t\t\t~(BIT(VIRTCHNL_OP_CONFIG_RDMA_IRQ_MAP));\n\t\tbreak;\n\tcase VIRTCHNL_OP_GET_RSS_HENA_CAPS: {\n\t\tstruct virtchnl_rss_hena *vrh = (struct virtchnl_rss_hena *)msg;\n\n\t\tif (msglen == sizeof(*vrh))\n\t\t\tadapter->hena = vrh->hena;\n\t\telse\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t \"Invalid message %d from PF\\n\", v_opcode);\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_REQUEST_QUEUES: {\n\t\tstruct virtchnl_vf_res_request *vfres =\n\t\t\t(struct virtchnl_vf_res_request *)msg;\n\n\t\tif (vfres->num_queue_pairs != adapter->num_req_queues) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Requested %d queues, PF can support %d\\n\",\n\t\t\t\t adapter->num_req_queues,\n\t\t\t\t vfres->num_queue_pairs);\n\t\t\tadapter->num_req_queues = 0;\n\t\t\tadapter->flags &= ~IAVF_FLAG_REINIT_ITR_NEEDED;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_CLOUD_FILTER: {\n\t\tstruct iavf_cloud_filter *cf;\n\n\t\tlist_for_each_entry(cf, &adapter->cloud_filter_list, list) {\n\t\t\tif (cf->state == __IAVF_CF_ADD_PENDING)\n\t\t\t\tcf->state = __IAVF_CF_ACTIVE;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_CLOUD_FILTER: {\n\t\tstruct iavf_cloud_filter *cf, *cftmp;\n\n\t\tlist_for_each_entry_safe(cf, cftmp, &adapter->cloud_filter_list,\n\t\t\t\t\t list) {\n\t\t\tif (cf->state == __IAVF_CF_DEL_PENDING) {\n\t\t\t\tcf->state = __IAVF_CF_INVALID;\n\t\t\t\tlist_del(&cf->list);\n\t\t\t\tkfree(cf);\n\t\t\t\tadapter->num_cloud_filters--;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_FDIR_FILTER: {\n\t\tstruct virtchnl_fdir_add *add_fltr = (struct virtchnl_fdir_add *)msg;\n\t\tstruct iavf_fdir_fltr *fdir, *fdir_tmp;\n\n\t\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\t\tlist_for_each_entry_safe(fdir, fdir_tmp,\n\t\t\t\t\t &adapter->fdir_list_head,\n\t\t\t\t\t list) {\n\t\t\tif (fdir->state == IAVF_FDIR_FLTR_ADD_PENDING) {\n\t\t\t\tif (add_fltr->status == VIRTCHNL_FDIR_SUCCESS) {\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Flow Director filter with location %u is added\\n\",\n\t\t\t\t\t\t fdir->loc);\n\t\t\t\t\tfdir->state = IAVF_FDIR_FLTR_ACTIVE;\n\t\t\t\t\tfdir->flow_id = add_fltr->flow_id;\n\t\t\t\t} else {\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Failed to add Flow Director filter with status: %d\\n\",\n\t\t\t\t\t\t add_fltr->status);\n\t\t\t\t\tiavf_print_fdir_fltr(adapter, fdir);\n\t\t\t\t\tlist_del(&fdir->list);\n\t\t\t\t\tkfree(fdir);\n\t\t\t\t\tadapter->fdir_active_fltr--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_FDIR_FILTER: {\n\t\tstruct virtchnl_fdir_del *del_fltr = (struct virtchnl_fdir_del *)msg;\n\t\tstruct iavf_fdir_fltr *fdir, *fdir_tmp;\n\n\t\tspin_lock_bh(&adapter->fdir_fltr_lock);\n\t\tlist_for_each_entry_safe(fdir, fdir_tmp, &adapter->fdir_list_head,\n\t\t\t\t\t list) {\n\t\t\tif (fdir->state == IAVF_FDIR_FLTR_DEL_PENDING) {\n\t\t\t\tif (del_fltr->status == VIRTCHNL_FDIR_SUCCESS ||\n\t\t\t\t    del_fltr->status ==\n\t\t\t\t    VIRTCHNL_FDIR_FAILURE_RULE_NONEXIST) {\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Flow Director filter with location %u is deleted\\n\",\n\t\t\t\t\t\t fdir->loc);\n\t\t\t\t\tlist_del(&fdir->list);\n\t\t\t\t\tkfree(fdir);\n\t\t\t\t\tadapter->fdir_active_fltr--;\n\t\t\t\t} else {\n\t\t\t\t\tfdir->state = IAVF_FDIR_FLTR_ACTIVE;\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Failed to delete Flow Director filter with status: %d\\n\",\n\t\t\t\t\t\t del_fltr->status);\n\t\t\t\t\tiavf_print_fdir_fltr(adapter, fdir);\n\t\t\t\t}\n\t\t\t} else if (fdir->state == IAVF_FDIR_FLTR_DIS_PENDING) {\n\t\t\t\tif (del_fltr->status == VIRTCHNL_FDIR_SUCCESS ||\n\t\t\t\t    del_fltr->status ==\n\t\t\t\t    VIRTCHNL_FDIR_FAILURE_RULE_NONEXIST) {\n\t\t\t\t\tfdir->state = IAVF_FDIR_FLTR_INACTIVE;\n\t\t\t\t} else {\n\t\t\t\t\tfdir->state = IAVF_FDIR_FLTR_ACTIVE;\n\t\t\t\t\tdev_info(&adapter->pdev->dev, \"Failed to disable Flow Director filter with status: %d\\n\",\n\t\t\t\t\t\t del_fltr->status);\n\t\t\t\t\tiavf_print_fdir_fltr(adapter, fdir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&adapter->fdir_fltr_lock);\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_RSS_CFG: {\n\t\tstruct iavf_adv_rss *rss;\n\n\t\tspin_lock_bh(&adapter->adv_rss_lock);\n\t\tlist_for_each_entry(rss, &adapter->adv_rss_list_head, list) {\n\t\t\tif (rss->state == IAVF_ADV_RSS_ADD_PENDING) {\n\t\t\t\tiavf_print_adv_rss_cfg(adapter, rss,\n\t\t\t\t\t\t       \"Input set change for\",\n\t\t\t\t\t\t       \"successful\");\n\t\t\t\trss->state = IAVF_ADV_RSS_ACTIVE;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&adapter->adv_rss_lock);\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_DEL_RSS_CFG: {\n\t\tstruct iavf_adv_rss *rss, *rss_tmp;\n\n\t\tspin_lock_bh(&adapter->adv_rss_lock);\n\t\tlist_for_each_entry_safe(rss, rss_tmp,\n\t\t\t\t\t &adapter->adv_rss_list_head, list) {\n\t\t\tif (rss->state == IAVF_ADV_RSS_DEL_PENDING) {\n\t\t\t\tlist_del(&rss->list);\n\t\t\t\tkfree(rss);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&adapter->adv_rss_lock);\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_ADD_VLAN_V2: {\n\t\tstruct iavf_vlan_filter *f;\n\n\t\tspin_lock_bh(&adapter->mac_vlan_list_lock);\n\t\tlist_for_each_entry(f, &adapter->vlan_filter_list, list) {\n\t\t\tif (f->state == IAVF_VLAN_IS_NEW)\n\t\t\t\tf->state = IAVF_VLAN_ACTIVE;\n\t\t}\n\t\tspin_unlock_bh(&adapter->mac_vlan_list_lock);\n\t\t}\n\t\tbreak;\n\tcase VIRTCHNL_OP_ENABLE_VLAN_STRIPPING:\n\t\t \n\t\tif (!v_retval)\n\t\t\tiavf_netdev_features_vlan_strip_set(netdev, true);\n\t\tbreak;\n\tcase VIRTCHNL_OP_DISABLE_VLAN_STRIPPING:\n\t\t \n\t\tif (!v_retval)\n\t\t\tiavf_netdev_features_vlan_strip_set(netdev, false);\n\t\tbreak;\n\tdefault:\n\t\tif (adapter->current_op && (v_opcode != adapter->current_op))\n\t\t\tdev_warn(&adapter->pdev->dev, \"Expected response %d from PF, received %d\\n\",\n\t\t\t\t adapter->current_op, v_opcode);\n\t\tbreak;\n\t}  \n\tadapter->current_op = VIRTCHNL_OP_UNKNOWN;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}