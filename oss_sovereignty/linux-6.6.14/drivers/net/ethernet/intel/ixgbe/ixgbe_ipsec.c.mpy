{
  "module_name": "ixgbe_ipsec.c",
  "hash_id": "baf5993e3c0e634c26edaf1db95f9a3da564396ba5518ef5aa0f9dce20f2413f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c",
  "human_readable_source": "\n \n\n#include \"ixgbe.h\"\n#include <net/xfrm.h>\n#include <crypto/aead.h>\n#include <linux/if_bridge.h>\n\n#define IXGBE_IPSEC_KEY_BITS  160\nstatic const char aes_gcm_name[] = \"rfc4106(gcm(aes))\";\n\nstatic void ixgbe_ipsec_del_sa(struct xfrm_state *xs);\n\n \nstatic void ixgbe_ipsec_set_tx_sa(struct ixgbe_hw *hw, u16 idx,\n\t\t\t\t  u32 key[], u32 salt)\n{\n\tu32 reg;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_IPSTXKEY(i),\n\t\t\t\t(__force u32)cpu_to_be32(key[3 - i]));\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSTXSALT, (__force u32)cpu_to_be32(salt));\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treg = IXGBE_READ_REG(hw, IXGBE_IPSTXIDX);\n\treg &= IXGBE_RXTXIDX_IPS_EN;\n\treg |= idx << IXGBE_RXTXIDX_IDX_SHIFT | IXGBE_RXTXIDX_WRITE;\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSTXIDX, reg);\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic void ixgbe_ipsec_set_rx_item(struct ixgbe_hw *hw, u16 idx,\n\t\t\t\t    enum ixgbe_ipsec_tbl_sel tbl)\n{\n\tu32 reg;\n\n\treg = IXGBE_READ_REG(hw, IXGBE_IPSRXIDX);\n\treg &= IXGBE_RXTXIDX_IPS_EN;\n\treg |= tbl << IXGBE_RXIDX_TBL_SHIFT |\n\t       idx << IXGBE_RXTXIDX_IDX_SHIFT |\n\t       IXGBE_RXTXIDX_WRITE;\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXIDX, reg);\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic void ixgbe_ipsec_set_rx_sa(struct ixgbe_hw *hw, u16 idx, __be32 spi,\n\t\t\t\t  u32 key[], u32 salt, u32 mode, u32 ip_idx)\n{\n\tint i;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXSPI,\n\t\t\t(__force u32)cpu_to_le32((__force u32)spi));\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXIPIDX, ip_idx);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tixgbe_ipsec_set_rx_item(hw, idx, ips_rx_spi_tbl);\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXKEY(i),\n\t\t\t\t(__force u32)cpu_to_be32(key[3 - i]));\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXSALT, (__force u32)cpu_to_be32(salt));\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXMOD, mode);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tixgbe_ipsec_set_rx_item(hw, idx, ips_rx_key_tbl);\n}\n\n \nstatic void ixgbe_ipsec_set_rx_ip(struct ixgbe_hw *hw, u16 idx, __be32 addr[])\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXIPADDR(i),\n\t\t\t\t(__force u32)cpu_to_le32((__force u32)addr[i]));\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tixgbe_ipsec_set_rx_item(hw, idx, ips_rx_ip_tbl);\n}\n\n \nstatic void ixgbe_ipsec_clear_hw_tables(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 buf[4] = {0, 0, 0, 0};\n\tu16 idx;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXIDX, 0);\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSTXIDX, 0);\n\n\t \n\tfor (idx = 0; idx < IXGBE_IPSEC_MAX_RX_IP_COUNT; idx++) {\n\t\tixgbe_ipsec_set_tx_sa(hw, idx, buf, 0);\n\t\tixgbe_ipsec_set_rx_sa(hw, idx, 0, buf, 0, 0, 0);\n\t\tixgbe_ipsec_set_rx_ip(hw, idx, (__be32 *)buf);\n\t}\n\tfor (; idx < IXGBE_IPSEC_MAX_SA_COUNT; idx++) {\n\t\tixgbe_ipsec_set_tx_sa(hw, idx, buf, 0);\n\t\tixgbe_ipsec_set_rx_sa(hw, idx, 0, buf, 0, 0, 0);\n\t}\n}\n\n \nstatic void ixgbe_ipsec_stop_data(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tbool link = adapter->link_up;\n\tu32 t_rdy, r_rdy;\n\tu32 limit;\n\tu32 reg;\n\n\t \n\treg = IXGBE_READ_REG(hw, IXGBE_SECTXCTRL);\n\treg |= IXGBE_SECTXCTRL_TX_DIS;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXCTRL, reg);\n\n\treg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);\n\treg |= IXGBE_SECRXCTRL_RX_DIS;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, reg);\n\n\t \n\tt_rdy = IXGBE_READ_REG(hw, IXGBE_SECTXSTAT) &\n\t\tIXGBE_SECTXSTAT_SECTX_RDY;\n\tr_rdy = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT) &\n\t\tIXGBE_SECRXSTAT_SECRX_RDY;\n\tif (t_rdy && r_rdy)\n\t\treturn;\n\n\t \n\tif (!link) {\n\t\treg = IXGBE_READ_REG(hw, IXGBE_MACC);\n\t\treg |= IXGBE_MACC_FLU;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MACC, reg);\n\n\t\treg = IXGBE_READ_REG(hw, IXGBE_HLREG0);\n\t\treg |= IXGBE_HLREG0_LPBK;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_HLREG0, reg);\n\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t\tmdelay(3);\n\t}\n\n\t \n\tlimit = 20;\n\tdo {\n\t\tmdelay(10);\n\t\tt_rdy = IXGBE_READ_REG(hw, IXGBE_SECTXSTAT) &\n\t\t\tIXGBE_SECTXSTAT_SECTX_RDY;\n\t\tr_rdy = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT) &\n\t\t\tIXGBE_SECRXSTAT_SECRX_RDY;\n\t} while (!(t_rdy && r_rdy) && limit--);\n\n\t \n\tif (!link) {\n\t\treg = IXGBE_READ_REG(hw, IXGBE_MACC);\n\t\treg &= ~IXGBE_MACC_FLU;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MACC, reg);\n\n\t\treg = IXGBE_READ_REG(hw, IXGBE_HLREG0);\n\t\treg &= ~IXGBE_HLREG0_LPBK;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_HLREG0, reg);\n\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n}\n\n \nstatic void ixgbe_ipsec_stop_engine(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 reg;\n\n\tixgbe_ipsec_stop_data(adapter);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_IPSTXIDX, 0);\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXIDX, 0);\n\n\t \n\treg = IXGBE_READ_REG(hw, IXGBE_SECTXCTRL);\n\treg |= IXGBE_SECTXCTRL_SECTX_DIS;\n\treg &= ~IXGBE_SECTXCTRL_STORE_FORWARD;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXCTRL, reg);\n\n\treg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);\n\treg |= IXGBE_SECRXCTRL_SECRX_DIS;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, reg);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXBUFFAF, 0x250);\n\n\t \n\treg = IXGBE_READ_REG(hw, IXGBE_SECTXMINIFG);\n\treg = (reg & 0xfffffff0) | 0x1;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXMINIFG, reg);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXCTRL, IXGBE_SECTXCTRL_SECTX_DIS);\n\tIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, IXGBE_SECRXCTRL_SECRX_DIS);\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic void ixgbe_ipsec_start_engine(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 reg;\n\n\tixgbe_ipsec_stop_data(adapter);\n\n\t \n\treg = IXGBE_READ_REG(hw, IXGBE_SECTXMINIFG);\n\treg = (reg & 0xfffffff0) | 0x3;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXMINIFG, reg);\n\n\t \n\treg = IXGBE_READ_REG(hw, IXGBE_SECTXBUFFAF);\n\treg = (reg & 0xfffffc00) | 0x15;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXBUFFAF, reg);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, 0);\n\tIXGBE_WRITE_REG(hw, IXGBE_SECTXCTRL, IXGBE_SECTXCTRL_STORE_FORWARD);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_IPSTXIDX, IXGBE_RXTXIDX_IPS_EN);\n\tIXGBE_WRITE_REG(hw, IXGBE_IPSRXIDX, IXGBE_RXTXIDX_IPS_EN);\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nvoid ixgbe_ipsec_restore(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint i;\n\n\tif (!(adapter->flags2 & IXGBE_FLAG2_IPSEC_ENABLED))\n\t\treturn;\n\n\t \n\tixgbe_ipsec_stop_engine(adapter);\n\tixgbe_ipsec_clear_hw_tables(adapter);\n\tixgbe_ipsec_start_engine(adapter);\n\n\t \n\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT; i++) {\n\t\tstruct rx_sa *r = &ipsec->rx_tbl[i];\n\t\tstruct tx_sa *t = &ipsec->tx_tbl[i];\n\n\t\tif (r->used) {\n\t\t\tif (r->mode & IXGBE_RXTXMOD_VF)\n\t\t\t\tixgbe_ipsec_del_sa(r->xs);\n\t\t\telse\n\t\t\t\tixgbe_ipsec_set_rx_sa(hw, i, r->xs->id.spi,\n\t\t\t\t\t\t      r->key, r->salt,\n\t\t\t\t\t\t      r->mode, r->iptbl_ind);\n\t\t}\n\n\t\tif (t->used) {\n\t\t\tif (t->mode & IXGBE_RXTXMOD_VF)\n\t\t\t\tixgbe_ipsec_del_sa(t->xs);\n\t\t\telse\n\t\t\t\tixgbe_ipsec_set_tx_sa(hw, i, t->key, t->salt);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < IXGBE_IPSEC_MAX_RX_IP_COUNT; i++) {\n\t\tstruct rx_ip_sa *ipsa = &ipsec->ip_tbl[i];\n\n\t\tif (ipsa->used)\n\t\t\tixgbe_ipsec_set_rx_ip(hw, i, ipsa->ipaddr);\n\t}\n}\n\n \nstatic int ixgbe_ipsec_find_empty_idx(struct ixgbe_ipsec *ipsec, bool rxtable)\n{\n\tu32 i;\n\n\tif (rxtable) {\n\t\tif (ipsec->num_rx_sa == IXGBE_IPSEC_MAX_SA_COUNT)\n\t\t\treturn -ENOSPC;\n\n\t\t \n\t\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT; i++) {\n\t\t\tif (!ipsec->rx_tbl[i].used)\n\t\t\t\treturn i;\n\t\t}\n\t} else {\n\t\tif (ipsec->num_tx_sa == IXGBE_IPSEC_MAX_SA_COUNT)\n\t\t\treturn -ENOSPC;\n\n\t\t \n\t\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT; i++) {\n\t\t\tif (!ipsec->tx_tbl[i].used)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -ENOSPC;\n}\n\n \nstatic struct xfrm_state *ixgbe_ipsec_find_rx_state(struct ixgbe_ipsec *ipsec,\n\t\t\t\t\t\t    __be32 *daddr, u8 proto,\n\t\t\t\t\t\t    __be32 spi, bool ip4)\n{\n\tstruct rx_sa *rsa;\n\tstruct xfrm_state *ret = NULL;\n\n\trcu_read_lock();\n\thash_for_each_possible_rcu(ipsec->rx_sa_list, rsa, hlist,\n\t\t\t\t   (__force u32)spi) {\n\t\tif (rsa->mode & IXGBE_RXTXMOD_VF)\n\t\t\tcontinue;\n\t\tif (spi == rsa->xs->id.spi &&\n\t\t    ((ip4 && *daddr == rsa->xs->id.daddr.a4) ||\n\t\t      (!ip4 && !memcmp(daddr, &rsa->xs->id.daddr.a6,\n\t\t\t\t       sizeof(rsa->xs->id.daddr.a6)))) &&\n\t\t    proto == rsa->xs->id.proto) {\n\t\t\tret = rsa->xs;\n\t\t\txfrm_state_hold(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int ixgbe_ipsec_parse_proto_keys(struct xfrm_state *xs,\n\t\t\t\t\tu32 *mykey, u32 *mysalt)\n{\n\tstruct net_device *dev = xs->xso.real_dev;\n\tunsigned char *key_data;\n\tchar *alg_name = NULL;\n\tint key_len;\n\n\tif (!xs->aead) {\n\t\tnetdev_err(dev, \"Unsupported IPsec algorithm\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->aead->alg_icv_len != IXGBE_IPSEC_AUTH_BITS) {\n\t\tnetdev_err(dev, \"IPsec offload requires %d bit authentication\\n\",\n\t\t\t   IXGBE_IPSEC_AUTH_BITS);\n\t\treturn -EINVAL;\n\t}\n\n\tkey_data = &xs->aead->alg_key[0];\n\tkey_len = xs->aead->alg_key_len;\n\talg_name = xs->aead->alg_name;\n\n\tif (strcmp(alg_name, aes_gcm_name)) {\n\t\tnetdev_err(dev, \"Unsupported IPsec algorithm - please use %s\\n\",\n\t\t\t   aes_gcm_name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (key_len == IXGBE_IPSEC_KEY_BITS) {\n\t\t*mysalt = ((u32 *)key_data)[4];\n\t} else if (key_len != (IXGBE_IPSEC_KEY_BITS - (sizeof(*mysalt) * 8))) {\n\t\tnetdev_err(dev, \"IPsec hw offload only supports keys up to 128 bits with a 32 bit salt\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\tnetdev_info(dev, \"IPsec hw offload parameters missing 32 bit salt value\\n\");\n\t\t*mysalt = 0;\n\t}\n\tmemcpy(mykey, key_data, 16);\n\n\treturn 0;\n}\n\n \nstatic int ixgbe_ipsec_check_mgmt_ip(struct xfrm_state *xs)\n{\n\tstruct net_device *dev = xs->xso.real_dev;\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 mfval, manc, reg;\n\tint num_filters = 4;\n\tbool manc_ipv4;\n\tu32 bmcipval;\n\tint i, j;\n\n#define MANC_EN_IPV4_FILTER      BIT(24)\n#define MFVAL_IPV4_FILTER_SHIFT  16\n#define MFVAL_IPV6_FILTER_SHIFT  24\n#define MIPAF_ARR(_m, _n)        (IXGBE_MIPAF + ((_m) * 0x10) + ((_n) * 4))\n\n#define IXGBE_BMCIP(_n)          (0x5050 + ((_n) * 4))\n#define IXGBE_BMCIPVAL           0x5060\n#define BMCIP_V4                 0x2\n#define BMCIP_V6                 0x3\n#define BMCIP_MASK               0x3\n\n\tmanc = IXGBE_READ_REG(hw, IXGBE_MANC);\n\tmanc_ipv4 = !!(manc & MANC_EN_IPV4_FILTER);\n\tmfval = IXGBE_READ_REG(hw, IXGBE_MFVAL);\n\tbmcipval = IXGBE_READ_REG(hw, IXGBE_BMCIPVAL);\n\n\tif (xs->props.family == AF_INET) {\n\t\t \n\t\tif (manc_ipv4) {\n\t\t\t \n\t\t\tfor (i = 0; i < num_filters; i++) {\n\t\t\t\tif (!(mfval & BIT(MFVAL_IPV4_FILTER_SHIFT + i)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\treg = IXGBE_READ_REG(hw, MIPAF_ARR(3, i));\n\t\t\t\tif (reg == (__force u32)xs->id.daddr.a4)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif ((bmcipval & BMCIP_MASK) == BMCIP_V4) {\n\t\t\treg = IXGBE_READ_REG(hw, IXGBE_BMCIP(3));\n\t\t\tif (reg == (__force u32)xs->id.daddr.a4)\n\t\t\t\treturn 1;\n\t\t}\n\n\t} else {\n\t\t \n\t\tif (manc_ipv4)\n\t\t\tnum_filters = 3;\n\n\t\tfor (i = 0; i < num_filters; i++) {\n\t\t\tif (!(mfval & BIT(MFVAL_IPV6_FILTER_SHIFT + i)))\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\treg = IXGBE_READ_REG(hw, MIPAF_ARR(i, j));\n\t\t\t\tif (reg != (__force u32)xs->id.daddr.a6[j])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == 4)    \n\t\t\t\treturn 1;\n\t\t}\n\n\t\tif ((bmcipval & BMCIP_MASK) == BMCIP_V6) {\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\treg = IXGBE_READ_REG(hw, IXGBE_BMCIP(j));\n\t\t\t\tif (reg != (__force u32)xs->id.daddr.a6[j])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == 4)    \n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ixgbe_ipsec_add_sa(struct xfrm_state *xs,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = xs->xso.real_dev;\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint checked, match, first;\n\tu16 sa_idx;\n\tint ret;\n\tint i;\n\n\tif (xs->id.proto != IPPROTO_ESP && xs->id.proto != IPPROTO_AH) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported protocol for ipsec offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->props.mode != XFRM_MODE_TRANSPORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported mode for ipsec offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ixgbe_ipsec_check_mgmt_ip(xs)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"IPsec IP addr clash with mgmt filters\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->xso.type != XFRM_DEV_OFFLOAD_CRYPTO) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported ipsec offload type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->xso.dir == XFRM_DEV_OFFLOAD_IN) {\n\t\tstruct rx_sa rsa;\n\n\t\tif (xs->calg) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Compression offload not supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = ixgbe_ipsec_find_empty_idx(ipsec, true);\n\t\tif (ret < 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No space for SA in Rx table!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsa_idx = (u16)ret;\n\n\t\tmemset(&rsa, 0, sizeof(rsa));\n\t\trsa.used = true;\n\t\trsa.xs = xs;\n\n\t\tif (rsa.xs->id.proto & IPPROTO_ESP)\n\t\t\trsa.decrypt = xs->ealg || xs->aead;\n\n\t\t \n\t\tret = ixgbe_ipsec_parse_proto_keys(xs, rsa.key, &rsa.salt);\n\t\tif (ret) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get key data for Rx SA table\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (xs->props.family == AF_INET6)\n\t\t\tmemcpy(rsa.ipaddr, &xs->id.daddr.a6, 16);\n\t\telse\n\t\t\tmemcpy(&rsa.ipaddr[3], &xs->id.daddr.a4, 4);\n\n\t\t \n\n\t\t \n\t\tchecked = 0;\n\t\tmatch = -1;\n\t\tfirst = -1;\n\t\tfor (i = 0;\n\t\t     i < IXGBE_IPSEC_MAX_RX_IP_COUNT &&\n\t\t     (checked < ipsec->num_rx_sa || first < 0);\n\t\t     i++) {\n\t\t\tif (ipsec->ip_tbl[i].used) {\n\t\t\t\tif (!memcmp(ipsec->ip_tbl[i].ipaddr,\n\t\t\t\t\t    rsa.ipaddr, sizeof(rsa.ipaddr))) {\n\t\t\t\t\tmatch = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchecked++;\n\t\t\t} else if (first < 0) {\n\t\t\t\tfirst = i;   \n\t\t\t}\n\t\t}\n\n\t\tif (ipsec->num_rx_sa == 0)\n\t\t\tfirst = 0;\n\n\t\tif (match >= 0) {\n\t\t\t \n\t\t\trsa.iptbl_ind = match;\n\t\t\tipsec->ip_tbl[match].ref_cnt++;\n\n\t\t} else if (first >= 0) {\n\t\t\t \n\t\t\trsa.iptbl_ind = first;\n\n\t\t\tmemcpy(ipsec->ip_tbl[first].ipaddr,\n\t\t\t       rsa.ipaddr, sizeof(rsa.ipaddr));\n\t\t\tipsec->ip_tbl[first].ref_cnt = 1;\n\t\t\tipsec->ip_tbl[first].used = true;\n\n\t\t\tixgbe_ipsec_set_rx_ip(hw, rsa.iptbl_ind, rsa.ipaddr);\n\n\t\t} else {\n\t\t\t \n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No space for SA in Rx IP SA table\");\n\t\t\tmemset(&rsa, 0, sizeof(rsa));\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\trsa.mode = IXGBE_RXMOD_VALID;\n\t\tif (rsa.xs->id.proto & IPPROTO_ESP)\n\t\t\trsa.mode |= IXGBE_RXMOD_PROTO_ESP;\n\t\tif (rsa.decrypt)\n\t\t\trsa.mode |= IXGBE_RXMOD_DECRYPT;\n\t\tif (rsa.xs->props.family == AF_INET6)\n\t\t\trsa.mode |= IXGBE_RXMOD_IPV6;\n\n\t\t \n\t\tmemcpy(&ipsec->rx_tbl[sa_idx], &rsa, sizeof(rsa));\n\n\t\tixgbe_ipsec_set_rx_sa(hw, sa_idx, rsa.xs->id.spi, rsa.key,\n\t\t\t\t      rsa.salt, rsa.mode, rsa.iptbl_ind);\n\t\txs->xso.offload_handle = sa_idx + IXGBE_IPSEC_BASE_RX_INDEX;\n\n\t\tipsec->num_rx_sa++;\n\n\t\t \n\t\thash_add_rcu(ipsec->rx_sa_list, &ipsec->rx_tbl[sa_idx].hlist,\n\t\t\t     (__force u32)rsa.xs->id.spi);\n\t} else {\n\t\tstruct tx_sa tsa;\n\n\t\tif (adapter->num_vfs &&\n\t\t    adapter->bridge_mode != BRIDGE_MODE_VEPA)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tret = ixgbe_ipsec_find_empty_idx(ipsec, false);\n\t\tif (ret < 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No space for SA in Tx table\");\n\t\t\treturn ret;\n\t\t}\n\t\tsa_idx = (u16)ret;\n\n\t\tmemset(&tsa, 0, sizeof(tsa));\n\t\ttsa.used = true;\n\t\ttsa.xs = xs;\n\n\t\tif (xs->id.proto & IPPROTO_ESP)\n\t\t\ttsa.encrypt = xs->ealg || xs->aead;\n\n\t\tret = ixgbe_ipsec_parse_proto_keys(xs, tsa.key, &tsa.salt);\n\t\tif (ret) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get key data for Tx SA table\");\n\t\t\tmemset(&tsa, 0, sizeof(tsa));\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tmemcpy(&ipsec->tx_tbl[sa_idx], &tsa, sizeof(tsa));\n\n\t\tixgbe_ipsec_set_tx_sa(hw, sa_idx, tsa.key, tsa.salt);\n\n\t\txs->xso.offload_handle = sa_idx + IXGBE_IPSEC_BASE_TX_INDEX;\n\n\t\tipsec->num_tx_sa++;\n\t}\n\n\t \n\tif (!(adapter->flags2 & IXGBE_FLAG2_IPSEC_ENABLED)) {\n\t\tixgbe_ipsec_start_engine(adapter);\n\t\tadapter->flags2 |= IXGBE_FLAG2_IPSEC_ENABLED;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ixgbe_ipsec_del_sa(struct xfrm_state *xs)\n{\n\tstruct net_device *dev = xs->xso.real_dev;\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 zerobuf[4] = {0, 0, 0, 0};\n\tu16 sa_idx;\n\n\tif (xs->xso.dir == XFRM_DEV_OFFLOAD_IN) {\n\t\tstruct rx_sa *rsa;\n\t\tu8 ipi;\n\n\t\tsa_idx = xs->xso.offload_handle - IXGBE_IPSEC_BASE_RX_INDEX;\n\t\trsa = &ipsec->rx_tbl[sa_idx];\n\n\t\tif (!rsa->used) {\n\t\t\tnetdev_err(dev, \"Invalid Rx SA selected sa_idx=%d offload_handle=%lu\\n\",\n\t\t\t\t   sa_idx, xs->xso.offload_handle);\n\t\t\treturn;\n\t\t}\n\n\t\tixgbe_ipsec_set_rx_sa(hw, sa_idx, 0, zerobuf, 0, 0, 0);\n\t\thash_del_rcu(&rsa->hlist);\n\n\t\t \n\t\tipi = rsa->iptbl_ind;\n\t\tif (ipsec->ip_tbl[ipi].ref_cnt > 0) {\n\t\t\tipsec->ip_tbl[ipi].ref_cnt--;\n\n\t\t\tif (!ipsec->ip_tbl[ipi].ref_cnt) {\n\t\t\t\tmemset(&ipsec->ip_tbl[ipi], 0,\n\t\t\t\t       sizeof(struct rx_ip_sa));\n\t\t\t\tixgbe_ipsec_set_rx_ip(hw, ipi,\n\t\t\t\t\t\t      (__force __be32 *)zerobuf);\n\t\t\t}\n\t\t}\n\n\t\tmemset(rsa, 0, sizeof(struct rx_sa));\n\t\tipsec->num_rx_sa--;\n\t} else {\n\t\tsa_idx = xs->xso.offload_handle - IXGBE_IPSEC_BASE_TX_INDEX;\n\n\t\tif (!ipsec->tx_tbl[sa_idx].used) {\n\t\t\tnetdev_err(dev, \"Invalid Tx SA selected sa_idx=%d offload_handle=%lu\\n\",\n\t\t\t\t   sa_idx, xs->xso.offload_handle);\n\t\t\treturn;\n\t\t}\n\n\t\tixgbe_ipsec_set_tx_sa(hw, sa_idx, zerobuf, 0);\n\t\tmemset(&ipsec->tx_tbl[sa_idx], 0, sizeof(struct tx_sa));\n\t\tipsec->num_tx_sa--;\n\t}\n\n\t \n\tif (ipsec->num_rx_sa == 0 && ipsec->num_tx_sa == 0) {\n\t\tadapter->flags2 &= ~IXGBE_FLAG2_IPSEC_ENABLED;\n\t\tixgbe_ipsec_stop_engine(adapter);\n\t}\n}\n\n \nstatic bool ixgbe_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *xs)\n{\n\tif (xs->props.family == AF_INET) {\n\t\t \n\t\tif (ip_hdr(skb)->ihl != 5)\n\t\t\treturn false;\n\t} else {\n\t\t \n\t\tif (ipv6_ext_hdr(ipv6_hdr(skb)->nexthdr))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const struct xfrmdev_ops ixgbe_xfrmdev_ops = {\n\t.xdo_dev_state_add = ixgbe_ipsec_add_sa,\n\t.xdo_dev_state_delete = ixgbe_ipsec_del_sa,\n\t.xdo_dev_offload_ok = ixgbe_ipsec_offload_ok,\n};\n\n \nvoid ixgbe_ipsec_vf_clear(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tint i;\n\n\tif (!ipsec)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT && ipsec->num_rx_sa; i++) {\n\t\tif (!ipsec->rx_tbl[i].used)\n\t\t\tcontinue;\n\t\tif (ipsec->rx_tbl[i].mode & IXGBE_RXTXMOD_VF &&\n\t\t    ipsec->rx_tbl[i].vf == vf)\n\t\t\tixgbe_ipsec_del_sa(ipsec->rx_tbl[i].xs);\n\t}\n\n\t \n\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT && ipsec->num_tx_sa; i++) {\n\t\tif (!ipsec->tx_tbl[i].used)\n\t\t\tcontinue;\n\t\tif (ipsec->tx_tbl[i].mode & IXGBE_RXTXMOD_VF &&\n\t\t    ipsec->tx_tbl[i].vf == vf)\n\t\t\tixgbe_ipsec_del_sa(ipsec->tx_tbl[i].xs);\n\t}\n}\n\n \nint ixgbe_ipsec_vf_add_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)\n{\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tstruct xfrm_algo_desc *algo;\n\tstruct sa_mbx_msg *sam;\n\tstruct xfrm_state *xs;\n\tsize_t aead_len;\n\tu16 sa_idx;\n\tu32 pfsa;\n\tint err;\n\n\tsam = (struct sa_mbx_msg *)(&msgbuf[1]);\n\tif (!adapter->vfinfo[vf].trusted ||\n\t    !(adapter->flags2 & IXGBE_FLAG2_VF_IPSEC_ENABLED)) {\n\t\te_warn(drv, \"VF %d attempted to add an IPsec SA\\n\", vf);\n\t\terr = -EACCES;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (sam->dir != XFRM_DEV_OFFLOAD_IN) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\txs = kzalloc(sizeof(*xs), GFP_KERNEL);\n\tif (unlikely(!xs)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\txs->xso.dir = sam->dir;\n\txs->id.spi = sam->spi;\n\txs->id.proto = sam->proto;\n\txs->props.family = sam->family;\n\tif (xs->props.family == AF_INET6)\n\t\tmemcpy(&xs->id.daddr.a6, sam->addr, sizeof(xs->id.daddr.a6));\n\telse\n\t\tmemcpy(&xs->id.daddr.a4, sam->addr, sizeof(xs->id.daddr.a4));\n\txs->xso.dev = adapter->netdev;\n\n\talgo = xfrm_aead_get_byname(aes_gcm_name, IXGBE_IPSEC_AUTH_BITS, 1);\n\tif (unlikely(!algo)) {\n\t\terr = -ENOENT;\n\t\tgoto err_xs;\n\t}\n\n\taead_len = sizeof(*xs->aead) + IXGBE_IPSEC_KEY_BITS / 8;\n\txs->aead = kzalloc(aead_len, GFP_KERNEL);\n\tif (unlikely(!xs->aead)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_xs;\n\t}\n\n\txs->props.ealgo = algo->desc.sadb_alg_id;\n\txs->geniv = algo->uinfo.aead.geniv;\n\txs->aead->alg_icv_len = IXGBE_IPSEC_AUTH_BITS;\n\txs->aead->alg_key_len = IXGBE_IPSEC_KEY_BITS;\n\tmemcpy(xs->aead->alg_key, sam->key, sizeof(sam->key));\n\tmemcpy(xs->aead->alg_name, aes_gcm_name, sizeof(aes_gcm_name));\n\n\t \n\terr = ixgbe_ipsec_add_sa(xs, NULL);\n\tif (err)\n\t\tgoto err_aead;\n\n\tpfsa = xs->xso.offload_handle;\n\tif (pfsa < IXGBE_IPSEC_BASE_TX_INDEX) {\n\t\tsa_idx = pfsa - IXGBE_IPSEC_BASE_RX_INDEX;\n\t\tipsec->rx_tbl[sa_idx].vf = vf;\n\t\tipsec->rx_tbl[sa_idx].mode |= IXGBE_RXTXMOD_VF;\n\t} else {\n\t\tsa_idx = pfsa - IXGBE_IPSEC_BASE_TX_INDEX;\n\t\tipsec->tx_tbl[sa_idx].vf = vf;\n\t\tipsec->tx_tbl[sa_idx].mode |= IXGBE_RXTXMOD_VF;\n\t}\n\n\tmsgbuf[1] = xs->xso.offload_handle;\n\n\treturn 0;\n\nerr_aead:\n\tkfree_sensitive(xs->aead);\nerr_xs:\n\tkfree_sensitive(xs);\nerr_out:\n\tmsgbuf[1] = err;\n\treturn err;\n}\n\n \nint ixgbe_ipsec_vf_del_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)\n{\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tstruct xfrm_state *xs;\n\tu32 pfsa = msgbuf[1];\n\tu16 sa_idx;\n\n\tif (!adapter->vfinfo[vf].trusted) {\n\t\te_err(drv, \"vf %d attempted to delete an SA\\n\", vf);\n\t\treturn -EPERM;\n\t}\n\n\tif (pfsa < IXGBE_IPSEC_BASE_TX_INDEX) {\n\t\tstruct rx_sa *rsa;\n\n\t\tsa_idx = pfsa - IXGBE_IPSEC_BASE_RX_INDEX;\n\t\tif (sa_idx >= IXGBE_IPSEC_MAX_SA_COUNT) {\n\t\t\te_err(drv, \"vf %d SA index %d out of range\\n\",\n\t\t\t      vf, sa_idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trsa = &ipsec->rx_tbl[sa_idx];\n\n\t\tif (!rsa->used)\n\t\t\treturn 0;\n\n\t\tif (!(rsa->mode & IXGBE_RXTXMOD_VF) ||\n\t\t    rsa->vf != vf) {\n\t\t\te_err(drv, \"vf %d bad Rx SA index %d\\n\", vf, sa_idx);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\txs = ipsec->rx_tbl[sa_idx].xs;\n\t} else {\n\t\tstruct tx_sa *tsa;\n\n\t\tsa_idx = pfsa - IXGBE_IPSEC_BASE_TX_INDEX;\n\t\tif (sa_idx >= IXGBE_IPSEC_MAX_SA_COUNT) {\n\t\t\te_err(drv, \"vf %d SA index %d out of range\\n\",\n\t\t\t      vf, sa_idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttsa = &ipsec->tx_tbl[sa_idx];\n\n\t\tif (!tsa->used)\n\t\t\treturn 0;\n\n\t\tif (!(tsa->mode & IXGBE_RXTXMOD_VF) ||\n\t\t    tsa->vf != vf) {\n\t\t\te_err(drv, \"vf %d bad Tx SA index %d\\n\", vf, sa_idx);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\txs = ipsec->tx_tbl[sa_idx].xs;\n\t}\n\n\tixgbe_ipsec_del_sa(xs);\n\n\t \n\tkfree_sensitive(xs);\n\n\treturn 0;\n}\n\n \nint ixgbe_ipsec_tx(struct ixgbe_ring *tx_ring,\n\t\t   struct ixgbe_tx_buffer *first,\n\t\t   struct ixgbe_ipsec_tx_data *itd)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(tx_ring->netdev);\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tstruct xfrm_state *xs;\n\tstruct sec_path *sp;\n\tstruct tx_sa *tsa;\n\n\tsp = skb_sec_path(first->skb);\n\tif (unlikely(!sp->len)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: no xfrm state len = %d\\n\",\n\t\t\t   __func__, sp->len);\n\t\treturn 0;\n\t}\n\n\txs = xfrm_input_state(first->skb);\n\tif (unlikely(!xs)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: no xfrm_input_state() xs = %p\\n\",\n\t\t\t   __func__, xs);\n\t\treturn 0;\n\t}\n\n\titd->sa_idx = xs->xso.offload_handle - IXGBE_IPSEC_BASE_TX_INDEX;\n\tif (unlikely(itd->sa_idx >= IXGBE_IPSEC_MAX_SA_COUNT)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: bad sa_idx=%d handle=%lu\\n\",\n\t\t\t   __func__, itd->sa_idx, xs->xso.offload_handle);\n\t\treturn 0;\n\t}\n\n\ttsa = &ipsec->tx_tbl[itd->sa_idx];\n\tif (unlikely(!tsa->used)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: unused sa_idx=%d\\n\",\n\t\t\t   __func__, itd->sa_idx);\n\t\treturn 0;\n\t}\n\n\tfirst->tx_flags |= IXGBE_TX_FLAGS_IPSEC | IXGBE_TX_FLAGS_CC;\n\n\tif (xs->id.proto == IPPROTO_ESP) {\n\n\t\titd->flags |= IXGBE_ADVTXD_TUCMD_IPSEC_TYPE_ESP |\n\t\t\t      IXGBE_ADVTXD_TUCMD_L4T_TCP;\n\t\tif (first->protocol == htons(ETH_P_IP))\n\t\t\titd->flags |= IXGBE_ADVTXD_TUCMD_IPV4;\n\n\t\t \n\t\tif (!skb_is_gso(first->skb)) {\n\t\t\t \n\t\t\tconst int authlen = IXGBE_IPSEC_AUTH_BITS / 8;\n\t\t\tstruct sk_buff *skb = first->skb;\n\t\t\tu8 padlen;\n\t\t\tint ret;\n\n\t\t\tret = skb_copy_bits(skb, skb->len - (authlen + 2),\n\t\t\t\t\t    &padlen, 1);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn 0;\n\t\t\titd->trailer_len = authlen + 2 + padlen;\n\t\t}\n\t}\n\tif (tsa->encrypt)\n\t\titd->flags |= IXGBE_ADVTXD_TUCMD_IPSEC_ENCRYPT_EN;\n\n\treturn 1;\n}\n\n \nvoid ixgbe_ipsec_rx(struct ixgbe_ring *rx_ring,\n\t\t    union ixgbe_adv_rx_desc *rx_desc,\n\t\t    struct sk_buff *skb)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(rx_ring->netdev);\n\t__le16 pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;\n\t__le16 ipsec_pkt_types = cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPSEC_AH |\n\t\t\t\t\t     IXGBE_RXDADV_PKTTYPE_IPSEC_ESP);\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\tstruct xfrm_offload *xo = NULL;\n\tstruct xfrm_state *xs = NULL;\n\tstruct ipv6hdr *ip6 = NULL;\n\tstruct iphdr *ip4 = NULL;\n\tstruct sec_path *sp;\n\tvoid *daddr;\n\t__be32 spi;\n\tu8 *c_hdr;\n\tu8 proto;\n\n\t \n\tif (pkt_info & cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPV4)) {\n\t\tip4 = (struct iphdr *)(skb->data + ETH_HLEN);\n\t\tdaddr = &ip4->daddr;\n\t\tc_hdr = (u8 *)ip4 + ip4->ihl * 4;\n\t} else if (pkt_info & cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPV6)) {\n\t\tip6 = (struct ipv6hdr *)(skb->data + ETH_HLEN);\n\t\tdaddr = &ip6->daddr;\n\t\tc_hdr = (u8 *)ip6 + sizeof(struct ipv6hdr);\n\t} else {\n\t\treturn;\n\t}\n\n\tswitch (pkt_info & ipsec_pkt_types) {\n\tcase cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPSEC_AH):\n\t\tspi = ((struct ip_auth_hdr *)c_hdr)->spi;\n\t\tproto = IPPROTO_AH;\n\t\tbreak;\n\tcase cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPSEC_ESP):\n\t\tspi = ((struct ip_esp_hdr *)c_hdr)->spi;\n\t\tproto = IPPROTO_ESP;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\txs = ixgbe_ipsec_find_rx_state(ipsec, daddr, proto, spi, !!ip4);\n\tif (unlikely(!xs))\n\t\treturn;\n\n\tsp = secpath_set(skb);\n\tif (unlikely(!sp))\n\t\treturn;\n\n\tsp->xvec[sp->len++] = xs;\n\tsp->olen++;\n\txo = xfrm_offload(skb);\n\txo->flags = CRYPTO_DONE;\n\txo->status = CRYPTO_SUCCESS;\n\n\tadapter->rx_ipsec++;\n}\n\n \nvoid ixgbe_init_ipsec_offload(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct ixgbe_ipsec *ipsec;\n\tu32 t_dis, r_dis;\n\tsize_t size;\n\n\tif (hw->mac.type == ixgbe_mac_82598EB)\n\t\treturn;\n\n\t \n\tt_dis = IXGBE_READ_REG(hw, IXGBE_SECTXSTAT) &\n\t\tIXGBE_SECTXSTAT_SECTX_OFF_DIS;\n\tr_dis = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT) &\n\t\tIXGBE_SECRXSTAT_SECRX_OFF_DIS;\n\tif (t_dis || r_dis)\n\t\treturn;\n\n\tipsec = kzalloc(sizeof(*ipsec), GFP_KERNEL);\n\tif (!ipsec)\n\t\tgoto err1;\n\thash_init(ipsec->rx_sa_list);\n\n\tsize = sizeof(struct rx_sa) * IXGBE_IPSEC_MAX_SA_COUNT;\n\tipsec->rx_tbl = kzalloc(size, GFP_KERNEL);\n\tif (!ipsec->rx_tbl)\n\t\tgoto err2;\n\n\tsize = sizeof(struct tx_sa) * IXGBE_IPSEC_MAX_SA_COUNT;\n\tipsec->tx_tbl = kzalloc(size, GFP_KERNEL);\n\tif (!ipsec->tx_tbl)\n\t\tgoto err2;\n\n\tsize = sizeof(struct rx_ip_sa) * IXGBE_IPSEC_MAX_RX_IP_COUNT;\n\tipsec->ip_tbl = kzalloc(size, GFP_KERNEL);\n\tif (!ipsec->ip_tbl)\n\t\tgoto err2;\n\n\tipsec->num_rx_sa = 0;\n\tipsec->num_tx_sa = 0;\n\n\tadapter->ipsec = ipsec;\n\tixgbe_ipsec_stop_engine(adapter);\n\tixgbe_ipsec_clear_hw_tables(adapter);\n\n\tadapter->netdev->xfrmdev_ops = &ixgbe_xfrmdev_ops;\n\n\treturn;\n\nerr2:\n\tkfree(ipsec->ip_tbl);\n\tkfree(ipsec->rx_tbl);\n\tkfree(ipsec->tx_tbl);\n\tkfree(ipsec);\nerr1:\n\tnetdev_err(adapter->netdev, \"Unable to allocate memory for SA tables\");\n}\n\n \nvoid ixgbe_stop_ipsec_offload(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_ipsec *ipsec = adapter->ipsec;\n\n\tadapter->ipsec = NULL;\n\tif (ipsec) {\n\t\tkfree(ipsec->ip_tbl);\n\t\tkfree(ipsec->rx_tbl);\n\t\tkfree(ipsec->tx_tbl);\n\t\tkfree(ipsec);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}