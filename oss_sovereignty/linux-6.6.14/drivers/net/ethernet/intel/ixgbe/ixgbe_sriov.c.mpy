{
  "module_name": "ixgbe_sriov.c",
  "hash_id": "89874dbf02af0076a61860543ecaa75bf0cd0ff3d652cd37bdd0a7b9552402d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/ipv6.h>\n#include <linux/if_bridge.h>\n#ifdef NETIF_F_HW_VLAN_CTAG_TX\n#include <linux/if_vlan.h>\n#endif\n\n#include \"ixgbe.h\"\n#include \"ixgbe_type.h\"\n#include \"ixgbe_sriov.h\"\n\n#ifdef CONFIG_PCI_IOV\nstatic inline void ixgbe_alloc_vf_macvlans(struct ixgbe_adapter *adapter,\n\t\t\t\t\t   unsigned int num_vfs)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct vf_macvlans *mv_list;\n\tint num_vf_macvlans, i;\n\n\t \n\tINIT_LIST_HEAD(&adapter->vf_mvs.l);\n\n\tnum_vf_macvlans = hw->mac.num_rar_entries -\n\t\t\t  (IXGBE_MAX_PF_MACVLANS + 1 + num_vfs);\n\tif (!num_vf_macvlans)\n\t\treturn;\n\n\tmv_list = kcalloc(num_vf_macvlans, sizeof(struct vf_macvlans),\n\t\t\t  GFP_KERNEL);\n\tif (mv_list) {\n\t\tfor (i = 0; i < num_vf_macvlans; i++) {\n\t\t\tmv_list[i].vf = -1;\n\t\t\tmv_list[i].free = true;\n\t\t\tlist_add(&mv_list[i].l, &adapter->vf_mvs.l);\n\t\t}\n\t\tadapter->mv_list = mv_list;\n\t}\n}\n\nstatic int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter,\n\t\t\t\tunsigned int num_vfs)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint i;\n\n\tif (adapter->xdp_prog) {\n\t\te_warn(probe, \"SRIOV is not supported with XDP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tadapter->flags |= IXGBE_FLAG_SRIOV_ENABLED |\n\t\t\t  IXGBE_FLAG_VMDQ_ENABLED;\n\n\t \n\tadapter->vfinfo = kcalloc(num_vfs, sizeof(struct vf_data_storage),\n\t\t\t\t  GFP_KERNEL);\n\tif (!adapter->vfinfo)\n\t\treturn -ENOMEM;\n\n\tadapter->num_vfs = num_vfs;\n\n\tixgbe_alloc_vf_macvlans(adapter, num_vfs);\n\tadapter->ring_feature[RING_F_VMDQ].offset = num_vfs;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);\n\tadapter->bridge_mode = BRIDGE_MODE_VEB;\n\n\t \n\tif ((adapter->hw.mac.type == ixgbe_mac_82599EB) && (num_vfs < 16)) {\n\t\tadapter->dcb_cfg.num_tcs.pg_tcs = MAX_TRAFFIC_CLASS;\n\t\tadapter->dcb_cfg.num_tcs.pfc_tcs = MAX_TRAFFIC_CLASS;\n\t} else if (num_vfs < 32) {\n\t\tadapter->dcb_cfg.num_tcs.pg_tcs = 4;\n\t\tadapter->dcb_cfg.num_tcs.pfc_tcs = 4;\n\t} else {\n\t\tadapter->dcb_cfg.num_tcs.pg_tcs = 1;\n\t\tadapter->dcb_cfg.num_tcs.pfc_tcs = 1;\n\t}\n\n\t \n\tadapter->flags2 &= ~(IXGBE_FLAG2_RSC_CAPABLE |\n\t\t\t     IXGBE_FLAG2_RSC_ENABLED);\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\t \n\t\tadapter->vfinfo[i].spoofchk_enabled = true;\n\t\tadapter->vfinfo[i].link_enable = true;\n\n\t\t \n\t\tadapter->vfinfo[i].rss_query_enabled = false;\n\n\t\t \n\t\tadapter->vfinfo[i].trusted = false;\n\n\t\t \n\t\tadapter->vfinfo[i].xcast_mode = IXGBEVF_XCAST_MODE_NONE;\n\t}\n\n\te_info(probe, \"SR-IOV enabled with %d VFs\\n\", num_vfs);\n\treturn 0;\n}\n\n \nstatic void ixgbe_get_vfs(struct ixgbe_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu16 vendor = pdev->vendor;\n\tstruct pci_dev *vfdev;\n\tint vf = 0;\n\tu16 vf_id;\n\tint pos;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\tif (!pos)\n\t\treturn;\n\tpci_read_config_word(pdev, pos + PCI_SRIOV_VF_DID, &vf_id);\n\n\tvfdev = pci_get_device(vendor, vf_id, NULL);\n\tfor (; vfdev; vfdev = pci_get_device(vendor, vf_id, vfdev)) {\n\t\tif (!vfdev->is_virtfn)\n\t\t\tcontinue;\n\t\tif (vfdev->physfn != pdev)\n\t\t\tcontinue;\n\t\tif (vf >= adapter->num_vfs)\n\t\t\tcontinue;\n\t\tpci_dev_get(vfdev);\n\t\tadapter->vfinfo[vf].vfdev = vfdev;\n\t\t++vf;\n\t}\n}\n\n \nvoid ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int max_vfs)\n{\n\tint pre_existing_vfs = 0;\n\tunsigned int num_vfs;\n\n\tpre_existing_vfs = pci_num_vf(adapter->pdev);\n\tif (!pre_existing_vfs && !max_vfs)\n\t\treturn;\n\n\t \n\tif (pre_existing_vfs) {\n\t\tnum_vfs = pre_existing_vfs;\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Virtual Functions already enabled for this device - Please reload all VF drivers to avoid spoofed packet errors\\n\");\n\t} else {\n\t\tint err;\n\t\t \n\t\tnum_vfs = min_t(unsigned int, max_vfs, IXGBE_MAX_VFS_DRV_LIMIT);\n\n\t\terr = pci_enable_sriov(adapter->pdev, num_vfs);\n\t\tif (err) {\n\t\t\te_err(probe, \"Failed to enable PCI sriov: %d\\n\", err);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!__ixgbe_enable_sriov(adapter, num_vfs)) {\n\t\tixgbe_get_vfs(adapter);\n\t\treturn;\n\t}\n\n\t \n\te_err(probe, \"Unable to allocate memory for VF Data Storage - \"\n\t      \"SRIOV disabled\\n\");\n\tixgbe_disable_sriov(adapter);\n}\n\n#endif  \nint ixgbe_disable_sriov(struct ixgbe_adapter *adapter)\n{\n\tunsigned int num_vfs = adapter->num_vfs, vf;\n\tunsigned long flags;\n\tint rss;\n\n\tspin_lock_irqsave(&adapter->vfs_lock, flags);\n\t \n\tadapter->num_vfs = 0;\n\tspin_unlock_irqrestore(&adapter->vfs_lock, flags);\n\n\t \n\tfor (vf = 0; vf < num_vfs; ++vf) {\n\t\tstruct pci_dev *vfdev = adapter->vfinfo[vf].vfdev;\n\n\t\tif (!vfdev)\n\t\t\tcontinue;\n\t\tadapter->vfinfo[vf].vfdev = NULL;\n\t\tpci_dev_put(vfdev);\n\t}\n\n\t \n\tkfree(adapter->vfinfo);\n\tadapter->vfinfo = NULL;\n\n\t \n\tkfree(adapter->mv_list);\n\tadapter->mv_list = NULL;\n\n\t \n\tif (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))\n\t\treturn 0;\n\n#ifdef CONFIG_PCI_IOV\n\t \n\tif (pci_vfs_assigned(adapter->pdev)) {\n\t\te_dev_warn(\"Unloading driver while VFs are assigned - VFs will not be deallocated\\n\");\n\t\treturn -EPERM;\n\t}\n\t \n\tpci_disable_sriov(adapter->pdev);\n#endif\n\n\t \n\tif (bitmap_weight(adapter->fwd_bitmask, adapter->num_rx_pools) == 1) {\n\t\tadapter->flags &= ~IXGBE_FLAG_VMDQ_ENABLED;\n\t\tadapter->flags &= ~IXGBE_FLAG_SRIOV_ENABLED;\n\t\trss = min_t(int, ixgbe_max_rss_indices(adapter),\n\t\t\t    num_online_cpus());\n\t} else {\n\t\trss = min_t(int, IXGBE_MAX_L2A_QUEUES, num_online_cpus());\n\t}\n\n\tadapter->ring_feature[RING_F_VMDQ].offset = 0;\n\tadapter->ring_feature[RING_F_RSS].limit = rss;\n\n\t \n\tmsleep(100);\n\treturn 0;\n}\n\nstatic int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct ixgbe_adapter *adapter = pci_get_drvdata(dev);\n\tint pre_existing_vfs = pci_num_vf(dev);\n\tint err = 0, num_rx_pools, i, limit;\n\tu8 num_tc;\n\n\tif (pre_existing_vfs && pre_existing_vfs != num_vfs)\n\t\terr = ixgbe_disable_sriov(adapter);\n\telse if (pre_existing_vfs && pre_existing_vfs == num_vfs)\n\t\treturn num_vfs;\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tnum_tc = adapter->hw_tcs;\n\tnum_rx_pools = bitmap_weight(adapter->fwd_bitmask,\n\t\t\t\t     adapter->num_rx_pools);\n\tlimit = (num_tc > 4) ? IXGBE_MAX_VFS_8TC :\n\t\t(num_tc > 1) ? IXGBE_MAX_VFS_4TC : IXGBE_MAX_VFS_1TC;\n\n\tif (num_vfs > (limit - num_rx_pools)) {\n\t\te_dev_err(\"Currently configured with %d TCs, and %d offloaded macvlans. Creating more than %d VFs is not allowed\\n\",\n\t\t\t  num_tc, num_rx_pools - 1, limit - num_rx_pools);\n\t\treturn -EPERM;\n\t}\n\n\terr = __ixgbe_enable_sriov(adapter, num_vfs);\n\tif (err)\n\t\treturn  err;\n\n\tfor (i = 0; i < num_vfs; i++)\n\t\tixgbe_vf_configuration(dev, (i | 0x10000000));\n\n\t \n\tixgbe_sriov_reinit(adapter);\n\n\terr = pci_enable_sriov(dev, num_vfs);\n\tif (err) {\n\t\te_dev_warn(\"Failed to enable PCI sriov: %d\\n\", err);\n\t\treturn err;\n\t}\n\tixgbe_get_vfs(adapter);\n\n\treturn num_vfs;\n#else\n\treturn 0;\n#endif\n}\n\nstatic int ixgbe_pci_sriov_disable(struct pci_dev *dev)\n{\n\tstruct ixgbe_adapter *adapter = pci_get_drvdata(dev);\n\tint err;\n#ifdef CONFIG_PCI_IOV\n\tu32 current_flags = adapter->flags;\n\tint prev_num_vf = pci_num_vf(dev);\n#endif\n\n\terr = ixgbe_disable_sriov(adapter);\n\n\t \n#ifdef CONFIG_PCI_IOV\n\tif (!err && (current_flags != adapter->flags ||\n\t\t     prev_num_vf != pci_num_vf(dev)))\n\t\tixgbe_sriov_reinit(adapter);\n#endif\n\n\treturn err;\n}\n\nint ixgbe_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\n{\n\tif (num_vfs == 0)\n\t\treturn ixgbe_pci_sriov_disable(dev);\n\telse\n\t\treturn ixgbe_pci_sriov_enable(dev, num_vfs);\n}\n\nstatic int ixgbe_set_vf_multicasts(struct ixgbe_adapter *adapter,\n\t\t\t\t   u32 *msgbuf, u32 vf)\n{\n\tint entries = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK)\n\t\t       >> IXGBE_VT_MSGINFO_SHIFT;\n\tu16 *hash_list = (u16 *)&msgbuf[1];\n\tstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint i;\n\tu32 vector_bit;\n\tu32 vector_reg;\n\tu32 mta_reg;\n\tu32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));\n\n\t \n\tentries = min(entries, IXGBE_MAX_VF_MC_ENTRIES);\n\n\t \n\tvfinfo->num_vf_mc_hashes = entries;\n\n\t \n\tfor (i = 0; i < entries; i++) {\n\t\tvfinfo->vf_mc_hashes[i] = hash_list[i];\n\t}\n\n\tfor (i = 0; i < vfinfo->num_vf_mc_hashes; i++) {\n\t\tvector_reg = (vfinfo->vf_mc_hashes[i] >> 5) & 0x7F;\n\t\tvector_bit = vfinfo->vf_mc_hashes[i] & 0x1F;\n\t\tmta_reg = IXGBE_READ_REG(hw, IXGBE_MTA(vector_reg));\n\t\tmta_reg |= BIT(vector_bit);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MTA(vector_reg), mta_reg);\n\t}\n\tvmolr |= IXGBE_VMOLR_ROMPE;\n\tIXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PCI_IOV\nvoid ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct vf_data_storage *vfinfo;\n\tint i, j;\n\tu32 vector_bit;\n\tu32 vector_reg;\n\tu32 mta_reg;\n\n\tfor (i = 0; i < adapter->num_vfs; i++) {\n\t\tu32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(i));\n\t\tvfinfo = &adapter->vfinfo[i];\n\t\tfor (j = 0; j < vfinfo->num_vf_mc_hashes; j++) {\n\t\t\thw->addr_ctrl.mta_in_use++;\n\t\t\tvector_reg = (vfinfo->vf_mc_hashes[j] >> 5) & 0x7F;\n\t\t\tvector_bit = vfinfo->vf_mc_hashes[j] & 0x1F;\n\t\t\tmta_reg = IXGBE_READ_REG(hw, IXGBE_MTA(vector_reg));\n\t\t\tmta_reg |= BIT(vector_bit);\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_MTA(vector_reg), mta_reg);\n\t\t}\n\n\t\tif (vfinfo->num_vf_mc_hashes)\n\t\t\tvmolr |= IXGBE_VMOLR_ROMPE;\n\t\telse\n\t\t\tvmolr &= ~IXGBE_VMOLR_ROMPE;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VMOLR(i), vmolr);\n\t}\n\n\t \n\tixgbe_full_sync_mac_table(adapter);\n}\n#endif\n\nstatic int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid,\n\t\t\t     u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint err;\n\n\t \n\tif (add && test_bit(vid, adapter->active_vlans)) {\n\t\terr = hw->mac.ops.set_vfta(hw, vid, VMDQ_P(0), true, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = hw->mac.ops.set_vfta(hw, vid, vf, !!add, false);\n\n\tif (add && !err)\n\t\treturn err;\n\n\t \n\tif (test_bit(vid, adapter->active_vlans) ||\n\t    (adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))\n\t\tixgbe_update_pf_promisc_vlvf(adapter, vid);\n\n\treturn err;\n}\n\nstatic int ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 max_frame, u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 max_frs;\n\n\tif (max_frame < ETH_MIN_MTU || max_frame > IXGBE_MAX_JUMBO_FRAME_SIZE) {\n\t\te_err(drv, \"VF max_frame %d out of range\\n\", max_frame);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (adapter->hw.mac.type == ixgbe_mac_82599EB) {\n\t\tstruct net_device *dev = adapter->netdev;\n\t\tint pf_max_frame = dev->mtu + ETH_HLEN;\n\t\tu32 reg_offset, vf_shift, vfre;\n\t\ts32 err = 0;\n\n#ifdef CONFIG_FCOE\n\t\tif (dev->features & NETIF_F_FCOE_MTU)\n\t\t\tpf_max_frame = max_t(int, pf_max_frame,\n\t\t\t\t\t     IXGBE_FCOE_JUMBO_FRAME_SIZE);\n\n#endif  \n\t\tswitch (adapter->vfinfo[vf].vf_api) {\n\t\tcase ixgbe_mbox_api_11:\n\t\tcase ixgbe_mbox_api_12:\n\t\tcase ixgbe_mbox_api_13:\n\t\tcase ixgbe_mbox_api_14:\n\t\t\t \n\t\t\tif (pf_max_frame > ETH_FRAME_LEN)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t \n\t\t\tif ((pf_max_frame > ETH_FRAME_LEN) ||\n\t\t\t    (max_frame > (ETH_FRAME_LEN + ETH_FCS_LEN)))\n\t\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tvf_shift = vf % 32;\n\t\treg_offset = vf / 32;\n\n\t\t \n\t\tvfre = IXGBE_READ_REG(hw, IXGBE_VFRE(reg_offset));\n\t\tif (err)\n\t\t\tvfre &= ~BIT(vf_shift);\n\t\telse\n\t\t\tvfre |= BIT(vf_shift);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), vfre);\n\n\t\tif (err) {\n\t\t\te_err(drv, \"VF max_frame %d out of range\\n\", max_frame);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tmax_frs = IXGBE_READ_REG(hw, IXGBE_MAXFRS);\n\tmax_frs &= IXGBE_MHADD_MFS_MASK;\n\tmax_frs >>= IXGBE_MHADD_MFS_SHIFT;\n\n\tif (max_frs < max_frame) {\n\t\tmax_frs = max_frame << IXGBE_MHADD_MFS_SHIFT;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MAXFRS, max_frs);\n\t}\n\n\te_info(hw, \"VF requests change max MTU to %d\\n\", max_frame);\n\n\treturn 0;\n}\n\nstatic void ixgbe_set_vmolr(struct ixgbe_hw *hw, u32 vf, bool aupe)\n{\n\tu32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));\n\tvmolr |= IXGBE_VMOLR_BAM;\n\tif (aupe)\n\t\tvmolr |= IXGBE_VMOLR_AUPE;\n\telse\n\t\tvmolr &= ~IXGBE_VMOLR_AUPE;\n\tIXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);\n}\n\nstatic void ixgbe_clear_vmvir(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_VMVIR(vf), 0);\n}\n\nstatic void ixgbe_clear_vf_vlans(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 vlvfb_mask, pool_mask, i;\n\n\t \n\tpool_mask = ~BIT(VMDQ_P(0) % 32);\n\tvlvfb_mask = BIT(vf % 32);\n\n\t \n\tfor (i = IXGBE_VLVF_ENTRIES; i--;) {\n\t\tu32 bits[2], vlvfb, vid, vfta, vlvf;\n\t\tu32 word = i * 2 + vf / 32;\n\t\tu32 mask;\n\n\t\tvlvfb = IXGBE_READ_REG(hw, IXGBE_VLVFB(word));\n\n\t\t \n\t\tif (!(vlvfb & vlvfb_mask))\n\t\t\tcontinue;\n\n\t\t \n\t\tvlvfb ^= vlvfb_mask;\n\n\t\t \n\t\tbits[word % 2] = vlvfb;\n\t\tbits[~word % 2] = IXGBE_READ_REG(hw, IXGBE_VLVFB(word ^ 1));\n\n\t\t \n\t\tif (bits[(VMDQ_P(0) / 32) ^ 1] ||\n\t\t    (bits[VMDQ_P(0) / 32] & pool_mask))\n\t\t\tgoto update_vlvfb;\n\n\t\t \n\t\tif (bits[0] || bits[1])\n\t\t\tgoto update_vlvf;\n\n\t\t \n\t\tvlvf = IXGBE_READ_REG(hw, IXGBE_VLVF(i));\n\t\tif (!vlvf)\n\t\t\tgoto update_vlvfb;\n\n\t\tvid = vlvf & VLAN_VID_MASK;\n\t\tmask = BIT(vid % 32);\n\n\t\t \n\t\tvfta = IXGBE_READ_REG(hw, IXGBE_VFTA(vid / 32));\n\t\tif (vfta & mask)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTA(vid / 32), vfta ^ mask);\nupdate_vlvf:\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_VLVF(i), 0);\n\n\t\tif (!(adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))\n\t\t\tvlvfb = 0;\nupdate_vlvfb:\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_VLVFB(word), vlvfb);\n\t}\n}\n\nstatic int ixgbe_set_vf_macvlan(struct ixgbe_adapter *adapter,\n\t\t\t\tint vf, int index, unsigned char *mac_addr)\n{\n\tstruct vf_macvlans *entry;\n\tstruct list_head *pos;\n\tint retval = 0;\n\n\tif (index <= 1) {\n\t\tlist_for_each(pos, &adapter->vf_mvs.l) {\n\t\t\tentry = list_entry(pos, struct vf_macvlans, l);\n\t\t\tif (entry->vf == vf) {\n\t\t\t\tentry->vf = -1;\n\t\t\t\tentry->free = true;\n\t\t\t\tentry->is_macvlan = false;\n\t\t\t\tixgbe_del_mac_filter(adapter,\n\t\t\t\t\t\t     entry->vf_macvlan, vf);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!index)\n\t\treturn 0;\n\n\tentry = NULL;\n\n\tlist_for_each(pos, &adapter->vf_mvs.l) {\n\t\tentry = list_entry(pos, struct vf_macvlans, l);\n\t\tif (entry->free)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!entry || !entry->free)\n\t\treturn -ENOSPC;\n\n\tretval = ixgbe_add_mac_filter(adapter, mac_addr, vf);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tentry->free = false;\n\tentry->is_macvlan = true;\n\tentry->vf = vf;\n\tmemcpy(entry->vf_macvlan, mac_addr, ETH_ALEN);\n\n\treturn 0;\n}\n\nstatic inline void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\n\tstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\n\tu32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);\n\tu8 num_tcs = adapter->hw_tcs;\n\tu32 reg_val;\n\tu32 queue;\n\n\t \n\tixgbe_clear_vf_vlans(adapter, vf);\n\n\t \n\tixgbe_set_vf_vlan(adapter, true, vfinfo->pf_vlan, vf);\n\n\t \n\tixgbe_set_vmolr(hw, vf, !vfinfo->pf_vlan);\n\n\t \n\tif (!vfinfo->pf_vlan && !vfinfo->pf_qos && !num_tcs) {\n\t\tixgbe_clear_vmvir(adapter, vf);\n\t} else {\n\t\tif (vfinfo->pf_qos || !num_tcs)\n\t\t\tixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\n\t\t\t\t\tvfinfo->pf_qos, vf);\n\t\telse\n\t\t\tixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\n\t\t\t\t\tadapter->default_up, vf);\n\n\t\tif (vfinfo->spoofchk_enabled) {\n\t\t\thw->mac.ops.set_vlan_anti_spoofing(hw, true, vf);\n\t\t\thw->mac.ops.set_mac_anti_spoofing(hw, true, vf);\n\t\t}\n\t}\n\n\t \n\tadapter->vfinfo[vf].num_vf_mc_hashes = 0;\n\n\t \n\tixgbe_ipsec_vf_clear(adapter, vf);\n\n\t \n\tixgbe_set_rx_mode(adapter->netdev);\n\n\tixgbe_del_mac_filter(adapter, adapter->vfinfo[vf].vf_mac_addresses, vf);\n\tixgbe_set_vf_macvlan(adapter, vf, 0, NULL);\n\n\t \n\tadapter->vfinfo[vf].vf_api = ixgbe_mbox_api_10;\n\n\t \n\tfor (queue = 0; queue < q_per_pool; queue++) {\n\t\tunsigned int reg_idx = (vf * q_per_pool) + queue;\n\n\t\treg_val = IXGBE_READ_REG(hw, IXGBE_PVFTXDCTL(reg_idx));\n\n\t\t \n\t\tif (reg_val) {\n\t\t\treg_val |= IXGBE_TXDCTL_ENABLE;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(reg_idx), reg_val);\n\t\t\treg_val &= ~IXGBE_TXDCTL_ENABLE;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(reg_idx), reg_val);\n\t\t}\n\t}\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\nstatic void ixgbe_vf_clear_mbx(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 word;\n\n\t \n\tfor (word = 0; word < IXGBE_VFMAILBOX_SIZE; word++)\n\t\tIXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf), word, 0);\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\nstatic int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter,\n\t\t\t    int vf, unsigned char *mac_addr)\n{\n\ts32 retval;\n\n\tixgbe_del_mac_filter(adapter, adapter->vfinfo[vf].vf_mac_addresses, vf);\n\tretval = ixgbe_add_mac_filter(adapter, mac_addr, vf);\n\tif (retval >= 0)\n\t\tmemcpy(adapter->vfinfo[vf].vf_mac_addresses, mac_addr,\n\t\t       ETH_ALEN);\n\telse\n\t\teth_zero_addr(adapter->vfinfo[vf].vf_mac_addresses);\n\n\treturn retval;\n}\n\nint ixgbe_vf_configuration(struct pci_dev *pdev, unsigned int event_mask)\n{\n\tstruct ixgbe_adapter *adapter = pci_get_drvdata(pdev);\n\tunsigned int vfn = (event_mask & 0x3f);\n\n\tbool enable = ((event_mask & 0x10000000U) != 0);\n\n\tif (enable)\n\t\teth_zero_addr(adapter->vfinfo[vfn].vf_mac_addresses);\n\n\treturn 0;\n}\n\nstatic inline void ixgbe_write_qde(struct ixgbe_adapter *adapter, u32 vf,\n\t\t\t\t   u32 qde)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\n\tu32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);\n\tint i;\n\n\tfor (i = vf * q_per_pool; i < ((vf + 1) * q_per_pool); i++) {\n\t\tu32 reg;\n\n\t\t \n\t\tIXGBE_WRITE_FLUSH(hw);\n\n\t\t \n\t\treg = IXGBE_QDE_WRITE | qde;\n\t\treg |= i <<  IXGBE_QDE_IDX_SHIFT;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_QDE, reg);\n\t}\n}\n\n \nstatic void ixgbe_set_vf_rx_tx(struct ixgbe_adapter *adapter, int vf)\n{\n\tu32 reg_cur_tx, reg_cur_rx, reg_req_tx, reg_req_rx;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 reg_offset, vf_shift;\n\n\tvf_shift = vf % 32;\n\treg_offset = vf / 32;\n\n\treg_cur_tx = IXGBE_READ_REG(hw, IXGBE_VFTE(reg_offset));\n\treg_cur_rx = IXGBE_READ_REG(hw, IXGBE_VFRE(reg_offset));\n\n\tif (adapter->vfinfo[vf].link_enable) {\n\t\treg_req_tx = reg_cur_tx | 1 << vf_shift;\n\t\treg_req_rx = reg_cur_rx | 1 << vf_shift;\n\t} else {\n\t\treg_req_tx = reg_cur_tx & ~(1 << vf_shift);\n\t\treg_req_rx = reg_cur_rx & ~(1 << vf_shift);\n\t}\n\n\t \n\tif (adapter->hw.mac.type == ixgbe_mac_82599EB) {\n\t\tstruct net_device *dev = adapter->netdev;\n\t\tint pf_max_frame = dev->mtu + ETH_HLEN;\n\n#if IS_ENABLED(CONFIG_FCOE)\n\t\tif (dev->features & NETIF_F_FCOE_MTU)\n\t\t\tpf_max_frame = max_t(int, pf_max_frame,\n\t\t\t\t\t     IXGBE_FCOE_JUMBO_FRAME_SIZE);\n#endif  \n\n\t\tif (pf_max_frame > ETH_FRAME_LEN)\n\t\t\treg_req_rx = reg_cur_rx & ~(1 << vf_shift);\n\t}\n\n\t \n\tif (reg_cur_tx != reg_req_tx)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTE(reg_offset), reg_req_tx);\n\tif (reg_cur_rx != reg_req_rx)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), reg_req_rx);\n}\n\nstatic int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tunsigned char *vf_mac = adapter->vfinfo[vf].vf_mac_addresses;\n\tu32 reg, reg_offset, vf_shift;\n\tu32 msgbuf[4] = {0, 0, 0, 0};\n\tu8 *addr = (u8 *)(&msgbuf[1]);\n\tu32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);\n\tint i;\n\n\te_info(probe, \"VF Reset msg received from vf %d\\n\", vf);\n\n\t \n\tixgbe_vf_reset_event(adapter, vf);\n\n\tixgbe_vf_clear_mbx(adapter, vf);\n\n\t \n\tif (!is_zero_ether_addr(vf_mac))\n\t\tixgbe_set_vf_mac(adapter, vf, vf_mac);\n\n\tvf_shift = vf % 32;\n\treg_offset = vf / 32;\n\n\t \n\treg = IXGBE_QDE_ENABLE;\n\tif (adapter->vfinfo[vf].pf_vlan)\n\t\treg |= IXGBE_QDE_HIDE_VLAN;\n\n\tixgbe_write_qde(adapter, vf, reg);\n\n\tixgbe_set_vf_rx_tx(adapter, vf);\n\n\t \n\tadapter->vfinfo[vf].clear_to_send = true;\n\n\t \n\treg = IXGBE_READ_REG(hw, IXGBE_VMECM(reg_offset));\n\treg |= BIT(vf_shift);\n\tIXGBE_WRITE_REG(hw, IXGBE_VMECM(reg_offset), reg);\n\n\t \n\tfor (i = 0; i < q_per_pool; i++) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_PVFTDWBAHn(q_per_pool, vf, i), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_PVFTDWBALn(q_per_pool, vf, i), 0);\n\t}\n\n\t \n\tmsgbuf[0] = IXGBE_VF_RESET;\n\tif (!is_zero_ether_addr(vf_mac) && adapter->vfinfo[vf].pf_set_mac) {\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_ACK;\n\t\tmemcpy(addr, vf_mac, ETH_ALEN);\n\t} else {\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\n\t}\n\n\t \n\tmsgbuf[3] = hw->mac.mc_filter_type;\n\tixgbe_write_mbx(hw, msgbuf, IXGBE_VF_PERMADDR_MSG_LEN, vf);\n\n\treturn 0;\n}\n\nstatic int ixgbe_set_vf_mac_addr(struct ixgbe_adapter *adapter,\n\t\t\t\t u32 *msgbuf, u32 vf)\n{\n\tu8 *new_mac = ((u8 *)(&msgbuf[1]));\n\n\tif (!is_valid_ether_addr(new_mac)) {\n\t\te_warn(drv, \"VF %d attempted to set invalid mac\\n\", vf);\n\t\treturn -1;\n\t}\n\n\tif (adapter->vfinfo[vf].pf_set_mac && !adapter->vfinfo[vf].trusted &&\n\t    !ether_addr_equal(adapter->vfinfo[vf].vf_mac_addresses, new_mac)) {\n\t\te_warn(drv,\n\t\t       \"VF %d attempted to override administratively set MAC address\\n\"\n\t\t       \"Reload the VF driver to resume operations\\n\",\n\t\t       vf);\n\t\treturn -1;\n\t}\n\n\treturn ixgbe_set_vf_mac(adapter, vf, new_mac) < 0;\n}\n\nstatic int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter,\n\t\t\t\t u32 *msgbuf, u32 vf)\n{\n\tu32 add = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK) >> IXGBE_VT_MSGINFO_SHIFT;\n\tu32 vid = (msgbuf[1] & IXGBE_VLVF_VLANID_MASK);\n\tu8 tcs = adapter->hw_tcs;\n\n\tif (adapter->vfinfo[vf].pf_vlan || tcs) {\n\t\te_warn(drv,\n\t\t       \"VF %d attempted to override administratively set VLAN configuration\\n\"\n\t\t       \"Reload the VF driver to resume operations\\n\",\n\t\t       vf);\n\t\treturn -1;\n\t}\n\n\t \n\tif (!vid && !add)\n\t\treturn 0;\n\n\treturn ixgbe_set_vf_vlan(adapter, add, vid, vf);\n}\n\nstatic int ixgbe_set_vf_macvlan_msg(struct ixgbe_adapter *adapter,\n\t\t\t\t    u32 *msgbuf, u32 vf)\n{\n\tu8 *new_mac = ((u8 *)(&msgbuf[1]));\n\tint index = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK) >>\n\t\t    IXGBE_VT_MSGINFO_SHIFT;\n\tint err;\n\n\tif (adapter->vfinfo[vf].pf_set_mac && !adapter->vfinfo[vf].trusted &&\n\t    index > 0) {\n\t\te_warn(drv,\n\t\t       \"VF %d requested MACVLAN filter but is administratively denied\\n\",\n\t\t       vf);\n\t\treturn -1;\n\t}\n\n\t \n\tif (index) {\n\t\tif (!is_valid_ether_addr(new_mac)) {\n\t\t\te_warn(drv, \"VF %d attempted to set invalid mac\\n\", vf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (adapter->vfinfo[vf].spoofchk_enabled) {\n\t\t\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\t\t\thw->mac.ops.set_mac_anti_spoofing(hw, false, vf);\n\t\t\thw->mac.ops.set_vlan_anti_spoofing(hw, false, vf);\n\t\t}\n\t}\n\n\terr = ixgbe_set_vf_macvlan(adapter, vf, index, new_mac);\n\tif (err == -ENOSPC)\n\t\te_warn(drv,\n\t\t       \"VF %d has requested a MACVLAN filter but there is no space for it\\n\",\n\t\t       vf);\n\n\treturn err < 0;\n}\n\nstatic int ixgbe_negotiate_vf_api(struct ixgbe_adapter *adapter,\n\t\t\t\t  u32 *msgbuf, u32 vf)\n{\n\tint api = msgbuf[1];\n\n\tswitch (api) {\n\tcase ixgbe_mbox_api_10:\n\tcase ixgbe_mbox_api_11:\n\tcase ixgbe_mbox_api_12:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_14:\n\t\tadapter->vfinfo[vf].vf_api = api;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\te_info(drv, \"VF %d requested invalid api version %u\\n\", vf, api);\n\n\treturn -1;\n}\n\nstatic int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter,\n\t\t\t       u32 *msgbuf, u32 vf)\n{\n\tstruct net_device *dev = adapter->netdev;\n\tstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\n\tunsigned int default_tc = 0;\n\tu8 num_tcs = adapter->hw_tcs;\n\n\t \n\tswitch (adapter->vfinfo[vf].vf_api) {\n\tcase ixgbe_mbox_api_20:\n\tcase ixgbe_mbox_api_11:\n\tcase ixgbe_mbox_api_12:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_14:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tmsgbuf[IXGBE_VF_TX_QUEUES] = __ALIGN_MASK(1, ~vmdq->mask);\n\tmsgbuf[IXGBE_VF_RX_QUEUES] = __ALIGN_MASK(1, ~vmdq->mask);\n\n\t \n\tif (num_tcs > 1)\n\t\tdefault_tc = netdev_get_prio_tc_map(dev, adapter->default_up);\n\n\t \n\tif (num_tcs)\n\t\tmsgbuf[IXGBE_VF_TRANS_VLAN] = num_tcs;\n\telse if (adapter->vfinfo[vf].pf_vlan || adapter->vfinfo[vf].pf_qos)\n\t\tmsgbuf[IXGBE_VF_TRANS_VLAN] = 1;\n\telse\n\t\tmsgbuf[IXGBE_VF_TRANS_VLAN] = 0;\n\n\t \n\tmsgbuf[IXGBE_VF_DEF_QUEUE] = default_tc;\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_vf_reta(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)\n{\n\tu32 i, j;\n\tu32 *out_buf = &msgbuf[1];\n\tconst u8 *reta = adapter->rss_indir_tbl;\n\tu32 reta_size = ixgbe_rss_indir_tbl_entries(adapter);\n\n\t \n\tif (!adapter->vfinfo[vf].rss_query_enabled)\n\t\treturn -EPERM;\n\n\t \n\tswitch (adapter->vfinfo[vf].vf_api) {\n\tcase ixgbe_mbox_api_14:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_12:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tfor (i = 0; i < reta_size / 16; i++) {\n\t\tout_buf[i] = 0;\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tout_buf[i] |= (u32)(reta[16 * i + j] & 0x3) << (2 * j);\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_vf_rss_key(struct ixgbe_adapter *adapter,\n\t\t\t\tu32 *msgbuf, u32 vf)\n{\n\tu32 *rss_key = &msgbuf[1];\n\n\t \n\tif (!adapter->vfinfo[vf].rss_query_enabled)\n\t\treturn -EPERM;\n\n\t \n\tswitch (adapter->vfinfo[vf].vf_api) {\n\tcase ixgbe_mbox_api_14:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_12:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemcpy(rss_key, adapter->rss_key, IXGBE_RSS_KEY_SIZE);\n\n\treturn 0;\n}\n\nstatic int ixgbe_update_vf_xcast_mode(struct ixgbe_adapter *adapter,\n\t\t\t\t      u32 *msgbuf, u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint xcast_mode = msgbuf[1];\n\tu32 vmolr, fctrl, disable, enable;\n\n\t \n\tswitch (adapter->vfinfo[vf].vf_api) {\n\tcase ixgbe_mbox_api_12:\n\t\t \n\t\tif (xcast_mode == IXGBEVF_XCAST_MODE_PROMISC)\n\t\t\treturn -EOPNOTSUPP;\n\t\tfallthrough;\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_14:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (xcast_mode > IXGBEVF_XCAST_MODE_MULTI &&\n\t    !adapter->vfinfo[vf].trusted) {\n\t\txcast_mode = IXGBEVF_XCAST_MODE_MULTI;\n\t}\n\n\tif (adapter->vfinfo[vf].xcast_mode == xcast_mode)\n\t\tgoto out;\n\n\tswitch (xcast_mode) {\n\tcase IXGBEVF_XCAST_MODE_NONE:\n\t\tdisable = IXGBE_VMOLR_ROMPE |\n\t\t\t  IXGBE_VMOLR_MPE | IXGBE_VMOLR_UPE | IXGBE_VMOLR_VPE;\n\t\tenable = IXGBE_VMOLR_BAM;\n\t\tbreak;\n\tcase IXGBEVF_XCAST_MODE_MULTI:\n\t\tdisable = IXGBE_VMOLR_MPE | IXGBE_VMOLR_UPE | IXGBE_VMOLR_VPE;\n\t\tenable = IXGBE_VMOLR_BAM | IXGBE_VMOLR_ROMPE;\n\t\tbreak;\n\tcase IXGBEVF_XCAST_MODE_ALLMULTI:\n\t\tdisable = IXGBE_VMOLR_UPE | IXGBE_VMOLR_VPE;\n\t\tenable = IXGBE_VMOLR_BAM | IXGBE_VMOLR_ROMPE | IXGBE_VMOLR_MPE;\n\t\tbreak;\n\tcase IXGBEVF_XCAST_MODE_PROMISC:\n\t\tif (hw->mac.type <= ixgbe_mac_82599EB)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tfctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);\n\t\tif (!(fctrl & IXGBE_FCTRL_UPE)) {\n\t\t\t \n\t\t\te_warn(drv,\n\t\t\t       \"Enabling VF promisc requires PF in promisc\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tdisable = IXGBE_VMOLR_VPE;\n\t\tenable = IXGBE_VMOLR_BAM | IXGBE_VMOLR_ROMPE |\n\t\t\t IXGBE_VMOLR_MPE | IXGBE_VMOLR_UPE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tvmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));\n\tvmolr &= ~disable;\n\tvmolr |= enable;\n\tIXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);\n\n\tadapter->vfinfo[vf].xcast_mode = xcast_mode;\n\nout:\n\tmsgbuf[1] = xcast_mode;\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_vf_link_state(struct ixgbe_adapter *adapter,\n\t\t\t\t   u32 *msgbuf, u32 vf)\n{\n\tu32 *link_state = &msgbuf[1];\n\n\t \n\tswitch (adapter->vfinfo[vf].vf_api) {\n\tcase ixgbe_mbox_api_12:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_14:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*link_state = adapter->vfinfo[vf].link_enable;\n\n\treturn 0;\n}\n\nstatic int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tu32 mbx_size = IXGBE_VFMAILBOX_SIZE;\n\tu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\ts32 retval;\n\n\tretval = ixgbe_read_mbx(hw, msgbuf, mbx_size, vf);\n\n\tif (retval) {\n\t\tpr_err(\"Error receiving message from VF\\n\");\n\t\treturn retval;\n\t}\n\n\t \n\tif (msgbuf[0] & (IXGBE_VT_MSGTYPE_ACK | IXGBE_VT_MSGTYPE_NACK))\n\t\treturn 0;\n\n\t \n\tIXGBE_WRITE_FLUSH(hw);\n\n\tif (msgbuf[0] == IXGBE_VF_RESET)\n\t\treturn ixgbe_vf_reset_msg(adapter, vf);\n\n\t \n\tif (!adapter->vfinfo[vf].clear_to_send) {\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\n\t\tixgbe_write_mbx(hw, msgbuf, 1, vf);\n\t\treturn 0;\n\t}\n\n\tswitch ((msgbuf[0] & 0xFFFF)) {\n\tcase IXGBE_VF_SET_MAC_ADDR:\n\t\tretval = ixgbe_set_vf_mac_addr(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_MULTICAST:\n\t\tretval = ixgbe_set_vf_multicasts(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_VLAN:\n\t\tretval = ixgbe_set_vf_vlan_msg(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_LPE:\n\t\tretval = ixgbe_set_vf_lpe(adapter, msgbuf[1], vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_MACVLAN:\n\t\tretval = ixgbe_set_vf_macvlan_msg(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_API_NEGOTIATE:\n\t\tretval = ixgbe_negotiate_vf_api(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_GET_QUEUES:\n\t\tretval = ixgbe_get_vf_queues(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_GET_RETA:\n\t\tretval = ixgbe_get_vf_reta(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_GET_RSS_KEY:\n\t\tretval = ixgbe_get_vf_rss_key(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_UPDATE_XCAST_MODE:\n\t\tretval = ixgbe_update_vf_xcast_mode(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_GET_LINK_STATE:\n\t\tretval = ixgbe_get_vf_link_state(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_IPSEC_ADD:\n\t\tretval = ixgbe_ipsec_vf_add_sa(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_IPSEC_DEL:\n\t\tretval = ixgbe_ipsec_vf_del_sa(adapter, msgbuf, vf);\n\t\tbreak;\n\tdefault:\n\t\te_err(drv, \"Unhandled Msg %8.8x\\n\", msgbuf[0]);\n\t\tretval = IXGBE_ERR_MBX;\n\t\tbreak;\n\t}\n\n\t \n\tif (retval)\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\n\telse\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_ACK;\n\n\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_CTS;\n\n\tixgbe_write_mbx(hw, msgbuf, mbx_size, vf);\n\n\treturn retval;\n}\n\nstatic void ixgbe_rcv_ack_from_vf(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 msg = IXGBE_VT_MSGTYPE_NACK;\n\n\t \n\tif (!adapter->vfinfo[vf].clear_to_send)\n\t\tixgbe_write_mbx(hw, &msg, 1, vf);\n}\n\nvoid ixgbe_msg_task(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tu32 vf;\n\n\tspin_lock_irqsave(&adapter->vfs_lock, flags);\n\tfor (vf = 0; vf < adapter->num_vfs; vf++) {\n\t\t \n\t\tif (!ixgbe_check_for_rst(hw, vf))\n\t\t\tixgbe_vf_reset_event(adapter, vf);\n\n\t\t \n\t\tif (!ixgbe_check_for_msg(hw, vf))\n\t\t\tixgbe_rcv_msg_from_vf(adapter, vf);\n\n\t\t \n\t\tif (!ixgbe_check_for_ack(hw, vf))\n\t\t\tixgbe_rcv_ack_from_vf(adapter, vf);\n\t}\n\tspin_unlock_irqrestore(&adapter->vfs_lock, flags);\n}\n\nstatic inline void ixgbe_ping_vf(struct ixgbe_adapter *adapter, int vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 ping;\n\n\tping = IXGBE_PF_CONTROL_MSG;\n\tif (adapter->vfinfo[vf].clear_to_send)\n\t\tping |= IXGBE_VT_MSGTYPE_CTS;\n\tixgbe_write_mbx(hw, &ping, 1, vf);\n}\n\nvoid ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 ping;\n\tint i;\n\n\tfor (i = 0 ; i < adapter->num_vfs; i++) {\n\t\tping = IXGBE_PF_CONTROL_MSG;\n\t\tif (adapter->vfinfo[i].clear_to_send)\n\t\t\tping |= IXGBE_VT_MSGTYPE_CTS;\n\t\tixgbe_write_mbx(hw, &ping, 1, i);\n\t}\n}\n\n \nvoid ixgbe_set_all_vfs(struct ixgbe_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0 ; i < adapter->num_vfs; i++)\n\t\tixgbe_set_vf_link_state(adapter, i,\n\t\t\t\t\tadapter->vfinfo[i].link_state);\n}\n\nint ixgbe_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\ts32 retval;\n\n\tif (vf >= adapter->num_vfs)\n\t\treturn -EINVAL;\n\n\tif (is_valid_ether_addr(mac)) {\n\t\tdev_info(&adapter->pdev->dev, \"setting MAC %pM on VF %d\\n\",\n\t\t\t mac, vf);\n\t\tdev_info(&adapter->pdev->dev, \"Reload the VF driver to make this change effective.\");\n\n\t\tretval = ixgbe_set_vf_mac(adapter, vf, mac);\n\t\tif (retval >= 0) {\n\t\t\tadapter->vfinfo[vf].pf_set_mac = true;\n\n\t\t\tif (test_bit(__IXGBE_DOWN, &adapter->state)) {\n\t\t\t\tdev_warn(&adapter->pdev->dev, \"The VF MAC address has been set, but the PF device is not up.\\n\");\n\t\t\t\tdev_warn(&adapter->pdev->dev, \"Bring the PF device up before attempting to use the VF device.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(&adapter->pdev->dev, \"The VF MAC address was NOT set due to invalid or duplicate MAC address.\\n\");\n\t\t}\n\t} else if (is_zero_ether_addr(mac)) {\n\t\tunsigned char *vf_mac_addr =\n\t\t\t\t\t   adapter->vfinfo[vf].vf_mac_addresses;\n\n\t\t \n\t\tif (is_zero_ether_addr(vf_mac_addr))\n\t\t\treturn 0;\n\n\t\tdev_info(&adapter->pdev->dev, \"removing MAC on VF %d\\n\", vf);\n\n\t\tretval = ixgbe_del_mac_filter(adapter, vf_mac_addr, vf);\n\t\tif (retval >= 0) {\n\t\t\tadapter->vfinfo[vf].pf_set_mac = false;\n\t\t\tmemcpy(vf_mac_addr, mac, ETH_ALEN);\n\t\t} else {\n\t\t\tdev_warn(&adapter->pdev->dev, \"Could NOT remove the VF MAC address.\\n\");\n\t\t}\n\t} else {\n\t\tretval = -EINVAL;\n\t}\n\n\treturn retval;\n}\n\nstatic int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter, int vf,\n\t\t\t\t  u16 vlan, u8 qos)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint err;\n\n\terr = ixgbe_set_vf_vlan(adapter, true, vlan, vf);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tixgbe_set_vf_vlan(adapter, false, 0, vf);\n\n\tixgbe_set_vmvir(adapter, vlan, qos, vf);\n\tixgbe_set_vmolr(hw, vf, false);\n\n\t \n\tif (hw->mac.type >= ixgbe_mac_X550)\n\t\tixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE |\n\t\t\t\tIXGBE_QDE_HIDE_VLAN);\n\n\tadapter->vfinfo[vf].pf_vlan = vlan;\n\tadapter->vfinfo[vf].pf_qos = qos;\n\tdev_info(&adapter->pdev->dev,\n\t\t \"Setting VLAN %d, QOS 0x%x on VF %d\\n\", vlan, qos, vf);\n\tif (test_bit(__IXGBE_DOWN, &adapter->state)) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"The VF VLAN has been set, but the PF device is not up.\\n\");\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Bring the PF device up before attempting to use the VF device.\\n\");\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int ixgbe_disable_port_vlan(struct ixgbe_adapter *adapter, int vf)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint err;\n\n\terr = ixgbe_set_vf_vlan(adapter, false,\n\t\t\t\tadapter->vfinfo[vf].pf_vlan, vf);\n\t \n\tixgbe_set_vf_vlan(adapter, true, 0, vf);\n\tixgbe_clear_vmvir(adapter, vf);\n\tixgbe_set_vmolr(hw, vf, true);\n\n\t \n\tif (hw->mac.type >= ixgbe_mac_X550)\n\t\tixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE);\n\n\tadapter->vfinfo[vf].pf_vlan = 0;\n\tadapter->vfinfo[vf].pf_qos = 0;\n\n\treturn err;\n}\n\nint ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan,\n\t\t\t  u8 qos, __be16 vlan_proto)\n{\n\tint err = 0;\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif ((vf >= adapter->num_vfs) || (vlan > 4095) || (qos > 7))\n\t\treturn -EINVAL;\n\tif (vlan_proto != htons(ETH_P_8021Q))\n\t\treturn -EPROTONOSUPPORT;\n\tif (vlan || qos) {\n\t\t \n\t\tif (adapter->vfinfo[vf].pf_vlan)\n\t\t\terr = ixgbe_disable_port_vlan(adapter, vf);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ixgbe_enable_port_vlan(adapter, vf, vlan, qos);\n\t} else {\n\t\terr = ixgbe_disable_port_vlan(adapter, vf);\n\t}\n\nout:\n\treturn err;\n}\n\nint ixgbe_link_mbps(struct ixgbe_adapter *adapter)\n{\n\tswitch (adapter->link_speed) {\n\tcase IXGBE_LINK_SPEED_100_FULL:\n\t\treturn 100;\n\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\treturn 1000;\n\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\t\treturn 10000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ixgbe_set_vf_rate_limit(struct ixgbe_adapter *adapter, int vf)\n{\n\tstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 bcnrc_val = 0;\n\tu16 queue, queues_per_pool;\n\tu16 tx_rate = adapter->vfinfo[vf].tx_rate;\n\n\tif (tx_rate) {\n\t\t \n\t\tbcnrc_val = adapter->vf_rate_link_speed;\n\n\t\t \n\t\tbcnrc_val <<= IXGBE_RTTBCNRC_RF_INT_SHIFT;\n\t\tbcnrc_val /= tx_rate;\n\n\t\t \n\t\tbcnrc_val &= IXGBE_RTTBCNRC_RF_INT_MASK |\n\t\t\t     IXGBE_RTTBCNRC_RF_DEC_MASK;\n\n\t\t \n\t\tbcnrc_val |= IXGBE_RTTBCNRC_RS_ENA;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_82599EB:\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRM, 0x4);\n\t\tbreak;\n\tcase ixgbe_mac_X540:\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRM, 0x14);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tqueues_per_pool = __ALIGN_MASK(1, ~vmdq->mask);\n\n\t \n\tfor (queue = 0; queue < queues_per_pool; queue++) {\n\t\tunsigned int reg_idx = (vf * queues_per_pool) + queue;\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RTTDQSEL, reg_idx);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRC, bcnrc_val);\n\t}\n}\n\nvoid ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter)\n{\n\tint i;\n\n\t \n\tif (!adapter->vf_rate_link_speed)\n\t\treturn;\n\n\tif (ixgbe_link_mbps(adapter) != adapter->vf_rate_link_speed) {\n\t\tadapter->vf_rate_link_speed = 0;\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Link speed has been changed. VF Transmit rate is disabled\\n\");\n\t}\n\n\tfor (i = 0; i < adapter->num_vfs; i++) {\n\t\tif (!adapter->vf_rate_link_speed)\n\t\t\tadapter->vfinfo[i].tx_rate = 0;\n\n\t\tixgbe_set_vf_rate_limit(adapter, i);\n\t}\n}\n\nint ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate,\n\t\t\tint max_tx_rate)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tint link_speed;\n\n\t \n\tif (vf >= adapter->num_vfs)\n\t\treturn -EINVAL;\n\n\t \n\tif (!adapter->link_up)\n\t\treturn -EINVAL;\n\n\t \n\tlink_speed = ixgbe_link_mbps(adapter);\n\tif (link_speed != 10000)\n\t\treturn -EINVAL;\n\n\tif (min_tx_rate)\n\t\treturn -EINVAL;\n\n\t \n\tif (max_tx_rate && ((max_tx_rate <= 10) || (max_tx_rate > link_speed)))\n\t\treturn -EINVAL;\n\n\t \n\tadapter->vf_rate_link_speed = link_speed;\n\tadapter->vfinfo[vf].tx_rate = max_tx_rate;\n\n\t \n\tixgbe_set_vf_rate_limit(adapter, vf);\n\n\treturn 0;\n}\n\nint ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\tif (vf >= adapter->num_vfs)\n\t\treturn -EINVAL;\n\n\tadapter->vfinfo[vf].spoofchk_enabled = setting;\n\n\t \n\thw->mac.ops.set_mac_anti_spoofing(hw, setting, vf);\n\n\t \n\thw->mac.ops.set_vlan_anti_spoofing(hw, setting, vf);\n\n\t \n\tif (hw->mac.ops.set_ethertype_anti_spoofing) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_LLDP),\n\t\t\t\t(IXGBE_ETQF_FILTER_EN    |\n\t\t\t\t IXGBE_ETQF_TX_ANTISPOOF |\n\t\t\t\t ETH_P_LLDP));\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FC),\n\t\t\t\t(IXGBE_ETQF_FILTER_EN |\n\t\t\t\t IXGBE_ETQF_TX_ANTISPOOF |\n\t\t\t\t ETH_P_PAUSE));\n\n\t\thw->mac.ops.set_ethertype_anti_spoofing(hw, setting, vf);\n\t}\n\n\treturn 0;\n}\n\n \nvoid ixgbe_set_vf_link_state(struct ixgbe_adapter *adapter, int vf, int state)\n{\n\tadapter->vfinfo[vf].link_state = state;\n\n\tswitch (state) {\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\t\tif (test_bit(__IXGBE_DOWN, &adapter->state))\n\t\t\tadapter->vfinfo[vf].link_enable = false;\n\t\telse\n\t\t\tadapter->vfinfo[vf].link_enable = true;\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\tadapter->vfinfo[vf].link_enable = true;\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tadapter->vfinfo[vf].link_enable = false;\n\t\tbreak;\n\t}\n\n\tixgbe_set_vf_rx_tx(adapter, vf);\n\n\t \n\tadapter->vfinfo[vf].clear_to_send = false;\n\tixgbe_ping_vf(adapter, vf);\n}\n\n \nint ixgbe_ndo_set_vf_link_state(struct net_device *netdev, int vf, int state)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tint ret = 0;\n\n\tif (vf < 0 || vf >= adapter->num_vfs) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"NDO set VF link - invalid VF identifier %d\\n\", vf);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state) {\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"NDO set VF %d link state %d - not supported\\n\",\n\t\t\tvf, state);\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"NDO set VF %d link state disable\\n\", vf);\n\t\tixgbe_set_vf_link_state(adapter, vf, state);\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"NDO set VF %d link state auto\\n\", vf);\n\t\tixgbe_set_vf_link_state(adapter, vf, state);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"NDO set VF %d - invalid link state %d\\n\", vf, state);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nint ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf,\n\t\t\t\t  bool setting)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (adapter->hw.mac.type < ixgbe_mac_82599EB ||\n\t    adapter->hw.mac.type >= ixgbe_mac_X550)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf >= adapter->num_vfs)\n\t\treturn -EINVAL;\n\n\tadapter->vfinfo[vf].rss_query_enabled = setting;\n\n\treturn 0;\n}\n\nint ixgbe_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (vf >= adapter->num_vfs)\n\t\treturn -EINVAL;\n\n\t \n\tif (adapter->vfinfo[vf].trusted == setting)\n\t\treturn 0;\n\n\tadapter->vfinfo[vf].trusted = setting;\n\n\t \n\tadapter->vfinfo[vf].clear_to_send = false;\n\tixgbe_ping_vf(adapter, vf);\n\n\te_info(drv, \"VF %u is %strusted\\n\", vf, setting ? \"\" : \"not \");\n\n\treturn 0;\n}\n\nint ixgbe_ndo_get_vf_config(struct net_device *netdev,\n\t\t\t    int vf, struct ifla_vf_info *ivi)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tif (vf >= adapter->num_vfs)\n\t\treturn -EINVAL;\n\tivi->vf = vf;\n\tmemcpy(&ivi->mac, adapter->vfinfo[vf].vf_mac_addresses, ETH_ALEN);\n\tivi->max_tx_rate = adapter->vfinfo[vf].tx_rate;\n\tivi->min_tx_rate = 0;\n\tivi->vlan = adapter->vfinfo[vf].pf_vlan;\n\tivi->qos = adapter->vfinfo[vf].pf_qos;\n\tivi->spoofchk = adapter->vfinfo[vf].spoofchk_enabled;\n\tivi->rss_query_en = adapter->vfinfo[vf].rss_query_enabled;\n\tivi->trusted = adapter->vfinfo[vf].trusted;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}