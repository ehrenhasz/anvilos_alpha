{
  "module_name": "ixgbe_x550.c",
  "hash_id": "7ca9c4eb4864624ea9e5df3c1d1fd2bedda066c90ed6ff2499616c28cf5d5fea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c",
  "human_readable_source": "\n \n\n#include \"ixgbe_x540.h\"\n#include \"ixgbe_type.h\"\n#include \"ixgbe_common.h\"\n#include \"ixgbe_phy.h\"\n\nstatic s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *, ixgbe_link_speed);\nstatic s32 ixgbe_setup_fc_x550em(struct ixgbe_hw *);\nstatic void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *);\nstatic void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *);\nstatic s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *);\n\nstatic s32 ixgbe_get_invariants_X550_x(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\tstruct ixgbe_link_info *link = &hw->link;\n\n\t \n\tixgbe_get_invariants_X540(hw);\n\n\tif (mac->ops.get_media_type(hw) != ixgbe_media_type_copper)\n\t\tphy->ops.set_phy_power = NULL;\n\n\tlink->addr = IXGBE_CS4227;\n\n\treturn 0;\n}\n\nstatic s32 ixgbe_get_invariants_X550_x_fw(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\n\t \n\tixgbe_get_invariants_X540(hw);\n\n\tphy->ops.set_phy_power = NULL;\n\n\treturn 0;\n}\n\nstatic s32 ixgbe_get_invariants_X550_a(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\n\t \n\tixgbe_get_invariants_X540(hw);\n\n\tif (mac->ops.get_media_type(hw) != ixgbe_media_type_copper)\n\t\tphy->ops.set_phy_power = NULL;\n\n\treturn 0;\n}\n\nstatic s32 ixgbe_get_invariants_X550_a_fw(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\n\t \n\tixgbe_get_invariants_X540(hw);\n\n\tphy->ops.set_phy_power = NULL;\n\n\treturn 0;\n}\n\n \nstatic void ixgbe_setup_mux_ctl(struct ixgbe_hw *hw)\n{\n\tu32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\n\tif (hw->bus.lan_id) {\n\t\tesdp &= ~(IXGBE_ESDP_SDP1_NATIVE | IXGBE_ESDP_SDP1);\n\t\tesdp |= IXGBE_ESDP_SDP1_DIR;\n\t}\n\tesdp &= ~(IXGBE_ESDP_SDP0_NATIVE | IXGBE_ESDP_SDP0_DIR);\n\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic s32 ixgbe_read_cs4227(struct ixgbe_hw *hw, u16 reg, u16 *value)\n{\n\treturn hw->link.ops.read_link_unlocked(hw, hw->link.addr, reg, value);\n}\n\n \nstatic s32 ixgbe_write_cs4227(struct ixgbe_hw *hw, u16 reg, u16 value)\n{\n\treturn hw->link.ops.write_link_unlocked(hw, hw->link.addr, reg, value);\n}\n\n \nstatic s32 ixgbe_read_pe(struct ixgbe_hw *hw, u8 reg, u8 *value)\n{\n\ts32 status;\n\n\tstatus = ixgbe_read_i2c_byte_generic_unlocked(hw, reg, IXGBE_PE, value);\n\tif (status)\n\t\thw_err(hw, \"port expander access failed with %d\\n\", status);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_pe(struct ixgbe_hw *hw, u8 reg, u8 value)\n{\n\ts32 status;\n\n\tstatus = ixgbe_write_i2c_byte_generic_unlocked(hw, reg, IXGBE_PE,\n\t\t\t\t\t\t       value);\n\tif (status)\n\t\thw_err(hw, \"port expander access failed with %d\\n\", status);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_reset_cs4227(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu32 retry;\n\tu16 value;\n\tu8 reg;\n\n\t \n\tstatus = ixgbe_read_pe(hw, IXGBE_PE_OUTPUT, &reg);\n\tif (status)\n\t\treturn status;\n\treg |= IXGBE_PE_BIT1;\n\tstatus = ixgbe_write_pe(hw, IXGBE_PE_OUTPUT, reg);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ixgbe_read_pe(hw, IXGBE_PE_CONFIG, &reg);\n\tif (status)\n\t\treturn status;\n\treg &= ~IXGBE_PE_BIT1;\n\tstatus = ixgbe_write_pe(hw, IXGBE_PE_CONFIG, reg);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ixgbe_read_pe(hw, IXGBE_PE_OUTPUT, &reg);\n\tif (status)\n\t\treturn status;\n\treg &= ~IXGBE_PE_BIT1;\n\tstatus = ixgbe_write_pe(hw, IXGBE_PE_OUTPUT, reg);\n\tif (status)\n\t\treturn status;\n\n\tusleep_range(IXGBE_CS4227_RESET_HOLD, IXGBE_CS4227_RESET_HOLD + 100);\n\n\tstatus = ixgbe_read_pe(hw, IXGBE_PE_OUTPUT, &reg);\n\tif (status)\n\t\treturn status;\n\treg |= IXGBE_PE_BIT1;\n\tstatus = ixgbe_write_pe(hw, IXGBE_PE_OUTPUT, reg);\n\tif (status)\n\t\treturn status;\n\n\t \n\tmsleep(IXGBE_CS4227_RESET_DELAY);\n\tfor (retry = 0; retry < IXGBE_CS4227_RETRIES; retry++) {\n\t\tstatus = ixgbe_read_cs4227(hw, IXGBE_CS4227_EFUSE_STATUS,\n\t\t\t\t\t   &value);\n\t\tif (!status && value == IXGBE_CS4227_EEPROM_LOAD_OK)\n\t\t\tbreak;\n\t\tmsleep(IXGBE_CS4227_CHECK_DELAY);\n\t}\n\tif (retry == IXGBE_CS4227_RETRIES) {\n\t\thw_err(hw, \"CS4227 reset did not complete\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\tstatus = ixgbe_read_cs4227(hw, IXGBE_CS4227_EEPROM_STATUS, &value);\n\tif (status || !(value & IXGBE_CS4227_EEPROM_LOAD_OK)) {\n\t\thw_err(hw, \"CS4227 EEPROM did not load successfully\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ixgbe_check_cs4227(struct ixgbe_hw *hw)\n{\n\tu32 swfw_mask = hw->phy.phy_semaphore_mask;\n\ts32 status;\n\tu16 value;\n\tu8 retry;\n\n\tfor (retry = 0; retry < IXGBE_CS4227_RETRIES; retry++) {\n\t\tstatus = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);\n\t\tif (status) {\n\t\t\thw_err(hw, \"semaphore failed with %d\\n\", status);\n\t\t\tmsleep(IXGBE_CS4227_CHECK_DELAY);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstatus = ixgbe_read_cs4227(hw, IXGBE_CS4227_SCRATCH, &value);\n\t\tif (!status && value == IXGBE_CS4227_RESET_COMPLETE)\n\t\t\tgoto out;\n\n\t\tif (status || value != IXGBE_CS4227_RESET_PENDING)\n\t\t\tbreak;\n\n\t\t \n\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\tmsleep(IXGBE_CS4227_CHECK_DELAY);\n\t}\n\t \n\tif (retry == IXGBE_CS4227_RETRIES) {\n\t\tstatus = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);\n\t\tif (status) {\n\t\t\thw_err(hw, \"semaphore failed with %d\\n\", status);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tstatus = ixgbe_reset_cs4227(hw);\n\tif (status) {\n\t\thw_err(hw, \"CS4227 reset failed: %d\", status);\n\t\tgoto out;\n\t}\n\n\t \n\tixgbe_write_cs4227(hw, IXGBE_CS4227_SCRATCH,\n\t\t\t   IXGBE_CS4227_RESET_PENDING);\n\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\tusleep_range(10000, 12000);\n\tstatus = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);\n\tif (status) {\n\t\thw_err(hw, \"semaphore failed with %d\", status);\n\t\treturn;\n\t}\n\n\t \n\tstatus = ixgbe_write_cs4227(hw, IXGBE_CS4227_SCRATCH,\n\t\t\t\t    IXGBE_CS4227_RESET_COMPLETE);\n\nout:\n\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\tmsleep(hw->eeprom.semaphore_delay);\n}\n\n \nstatic s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw)\n{\n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_X550EM_A_SFP:\n\t\tif (hw->bus.lan_id)\n\t\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;\n\t\telse\n\t\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;\n\t\treturn ixgbe_identify_module_generic(hw);\n\tcase IXGBE_DEV_ID_X550EM_X_SFP:\n\t\t \n\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;\n\t\tixgbe_setup_mux_ctl(hw);\n\t\tixgbe_check_cs4227(hw);\n\t\tfallthrough;\n\tcase IXGBE_DEV_ID_X550EM_A_SFP_N:\n\t\treturn ixgbe_identify_module_generic(hw);\n\tcase IXGBE_DEV_ID_X550EM_X_KX4:\n\t\thw->phy.type = ixgbe_phy_x550em_kx4;\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_X_XFI:\n\t\thw->phy.type = ixgbe_phy_x550em_xfi;\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_X_KR:\n\tcase IXGBE_DEV_ID_X550EM_A_KR:\n\tcase IXGBE_DEV_ID_X550EM_A_KR_L:\n\t\thw->phy.type = ixgbe_phy_x550em_kr;\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_A_10G_T:\n\t\tif (hw->bus.lan_id)\n\t\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;\n\t\telse\n\t\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;\n\t\tfallthrough;\n\tcase IXGBE_DEV_ID_X550EM_X_10G_T:\n\t\treturn ixgbe_identify_phy_generic(hw);\n\tcase IXGBE_DEV_ID_X550EM_X_1G_T:\n\t\thw->phy.type = ixgbe_phy_ext_1g_t;\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T_L:\n\t\thw->phy.type = ixgbe_phy_fw;\n\t\thw->phy.ops.read_reg = NULL;\n\t\thw->phy.ops.write_reg = NULL;\n\t\tif (hw->bus.lan_id)\n\t\t\thw->phy.phy_semaphore_mask |= IXGBE_GSSR_PHY1_SM;\n\t\telse\n\t\t\thw->phy.phy_semaphore_mask |= IXGBE_GSSR_PHY0_SM;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic s32 ixgbe_read_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t     u32 device_type, u16 *phy_data)\n{\n\treturn IXGBE_NOT_IMPLEMENTED;\n}\n\nstatic s32 ixgbe_write_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t      u32 device_type, u16 phy_data)\n{\n\treturn IXGBE_NOT_IMPLEMENTED;\n}\n\n \nstatic s32 ixgbe_read_i2c_combined_generic(struct ixgbe_hw *hw, u8 addr,\n\t\t\t\t\t   u16 reg, u16 *val)\n{\n\treturn ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, true);\n}\n\n \nstatic s32\nixgbe_read_i2c_combined_generic_unlocked(struct ixgbe_hw *hw, u8 addr,\n\t\t\t\t\t u16 reg, u16 *val)\n{\n\treturn ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, false);\n}\n\n \nstatic s32 ixgbe_write_i2c_combined_generic(struct ixgbe_hw *hw,\n\t\t\t\t\t    u8 addr, u16 reg, u16 val)\n{\n\treturn ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, true);\n}\n\n \nstatic s32\nixgbe_write_i2c_combined_generic_unlocked(struct ixgbe_hw *hw,\n\t\t\t\t\t  u8 addr, u16 reg, u16 val)\n{\n\treturn ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, false);\n}\n\n \ns32 ixgbe_fw_phy_activity(struct ixgbe_hw *hw, u16 activity,\n\t\t\t  u32 (*data)[FW_PHY_ACT_DATA_COUNT])\n{\n\tunion {\n\t\tstruct ixgbe_hic_phy_activity_req cmd;\n\t\tstruct ixgbe_hic_phy_activity_resp rsp;\n\t} hic;\n\tu16 retries = FW_PHY_ACT_RETRIES;\n\ts32 rc;\n\tu32 i;\n\n\tdo {\n\t\tmemset(&hic, 0, sizeof(hic));\n\t\thic.cmd.hdr.cmd = FW_PHY_ACT_REQ_CMD;\n\t\thic.cmd.hdr.buf_len = FW_PHY_ACT_REQ_LEN;\n\t\thic.cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;\n\t\thic.cmd.port_number = hw->bus.lan_id;\n\t\thic.cmd.activity_id = cpu_to_le16(activity);\n\t\tfor (i = 0; i < ARRAY_SIZE(hic.cmd.data); ++i)\n\t\t\thic.cmd.data[i] = cpu_to_be32((*data)[i]);\n\n\t\trc = ixgbe_host_interface_command(hw, &hic.cmd, sizeof(hic.cmd),\n\t\t\t\t\t\t  IXGBE_HI_COMMAND_TIMEOUT,\n\t\t\t\t\t\t  true);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (hic.rsp.hdr.cmd_or_resp.ret_status ==\n\t\t    FW_CEM_RESP_STATUS_SUCCESS) {\n\t\t\tfor (i = 0; i < FW_PHY_ACT_DATA_COUNT; ++i)\n\t\t\t\t(*data)[i] = be32_to_cpu(hic.rsp.data[i]);\n\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(20, 30);\n\t\t--retries;\n\t} while (retries > 0);\n\n\treturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\n}\n\nstatic const struct {\n\tu16 fw_speed;\n\tixgbe_link_speed phy_speed;\n} ixgbe_fw_map[] = {\n\t{ FW_PHY_ACT_LINK_SPEED_10, IXGBE_LINK_SPEED_10_FULL },\n\t{ FW_PHY_ACT_LINK_SPEED_100, IXGBE_LINK_SPEED_100_FULL },\n\t{ FW_PHY_ACT_LINK_SPEED_1G, IXGBE_LINK_SPEED_1GB_FULL },\n\t{ FW_PHY_ACT_LINK_SPEED_2_5G, IXGBE_LINK_SPEED_2_5GB_FULL },\n\t{ FW_PHY_ACT_LINK_SPEED_5G, IXGBE_LINK_SPEED_5GB_FULL },\n\t{ FW_PHY_ACT_LINK_SPEED_10G, IXGBE_LINK_SPEED_10GB_FULL },\n};\n\n \nstatic s32 ixgbe_get_phy_id_fw(struct ixgbe_hw *hw)\n{\n\tu32 info[FW_PHY_ACT_DATA_COUNT] = { 0 };\n\tu16 phy_speeds;\n\tu16 phy_id_lo;\n\ts32 rc;\n\tu16 i;\n\n\tif (hw->phy.id)\n\t\treturn 0;\n\n\trc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_PHY_INFO, &info);\n\tif (rc)\n\t\treturn rc;\n\n\thw->phy.speeds_supported = 0;\n\tphy_speeds = info[0] & FW_PHY_INFO_SPEED_MASK;\n\tfor (i = 0; i < ARRAY_SIZE(ixgbe_fw_map); ++i) {\n\t\tif (phy_speeds & ixgbe_fw_map[i].fw_speed)\n\t\t\thw->phy.speeds_supported |= ixgbe_fw_map[i].phy_speed;\n\t}\n\n\thw->phy.id = info[0] & FW_PHY_INFO_ID_HI_MASK;\n\tphy_id_lo = info[1] & FW_PHY_INFO_ID_LO_MASK;\n\thw->phy.id |= phy_id_lo & IXGBE_PHY_REVISION_MASK;\n\thw->phy.revision = phy_id_lo & ~IXGBE_PHY_REVISION_MASK;\n\tif (!hw->phy.id || hw->phy.id == IXGBE_PHY_REVISION_MASK)\n\t\treturn IXGBE_ERR_PHY_ADDR_INVALID;\n\n\thw->phy.autoneg_advertised = hw->phy.speeds_supported;\n\thw->phy.eee_speeds_supported = IXGBE_LINK_SPEED_100_FULL |\n\t\t\t\t       IXGBE_LINK_SPEED_1GB_FULL;\n\thw->phy.eee_speeds_advertised = hw->phy.eee_speeds_supported;\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_identify_phy_fw(struct ixgbe_hw *hw)\n{\n\tif (hw->bus.lan_id)\n\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;\n\telse\n\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;\n\n\thw->phy.type = ixgbe_phy_fw;\n\thw->phy.ops.read_reg = NULL;\n\thw->phy.ops.write_reg = NULL;\n\treturn ixgbe_get_phy_id_fw(hw);\n}\n\n \nstatic s32 ixgbe_shutdown_fw_phy(struct ixgbe_hw *hw)\n{\n\tu32 setup[FW_PHY_ACT_DATA_COUNT] = { 0 };\n\n\tsetup[0] = FW_PHY_ACT_FORCE_LINK_DOWN_OFF;\n\treturn ixgbe_fw_phy_activity(hw, FW_PHY_ACT_FORCE_LINK_DOWN, &setup);\n}\n\n \nstatic s32 ixgbe_setup_fw_link(struct ixgbe_hw *hw)\n{\n\tu32 setup[FW_PHY_ACT_DATA_COUNT] = { 0 };\n\ts32 rc;\n\tu16 i;\n\n\tif (hw->phy.reset_disable || ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\tif (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {\n\t\thw_err(hw, \"rx_pause not valid in strict IEEE mode\\n\");\n\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\t}\n\n\tswitch (hw->fc.requested_mode) {\n\tcase ixgbe_fc_full:\n\t\tsetup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_RXTX <<\n\t\t\t    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;\n\t\tbreak;\n\tcase ixgbe_fc_rx_pause:\n\t\tsetup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_RX <<\n\t\t\t    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;\n\t\tbreak;\n\tcase ixgbe_fc_tx_pause:\n\t\tsetup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_TX <<\n\t\t\t    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ixgbe_fw_map); ++i) {\n\t\tif (hw->phy.autoneg_advertised & ixgbe_fw_map[i].phy_speed)\n\t\t\tsetup[0] |= ixgbe_fw_map[i].fw_speed;\n\t}\n\tsetup[0] |= FW_PHY_ACT_SETUP_LINK_HP | FW_PHY_ACT_SETUP_LINK_AN;\n\n\tif (hw->phy.eee_speeds_advertised)\n\t\tsetup[0] |= FW_PHY_ACT_SETUP_LINK_EEE;\n\n\trc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_SETUP_LINK, &setup);\n\tif (rc)\n\t\treturn rc;\n\tif (setup[0] == FW_PHY_ACT_SETUP_LINK_RSP_DOWN)\n\t\treturn IXGBE_ERR_OVERTEMP;\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_fc_autoneg_fw(struct ixgbe_hw *hw)\n{\n\tif (hw->fc.requested_mode == ixgbe_fc_default)\n\t\thw->fc.requested_mode = ixgbe_fc_full;\n\n\treturn ixgbe_setup_fw_link(hw);\n}\n\n \nstatic s32 ixgbe_init_eeprom_params_X550(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eec;\n\tu16 eeprom_size;\n\n\tif (eeprom->type == ixgbe_eeprom_uninitialized) {\n\t\teeprom->semaphore_delay = 10;\n\t\teeprom->type = ixgbe_flash;\n\n\t\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\t\teeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>\n\t\t\t\t    IXGBE_EEC_SIZE_SHIFT);\n\t\teeprom->word_size = BIT(eeprom_size +\n\t\t\t\t\tIXGBE_EEPROM_WORD_SIZE_SHIFT);\n\n\t\thw_dbg(hw, \"Eeprom params: type = %d, size = %d\\n\",\n\t\t       eeprom->type, eeprom->word_size);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_iosf_wait(struct ixgbe_hw *hw, u32 *ctrl)\n{\n\tu32 i, command;\n\n\t \n\tfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\n\t\tcommand = IXGBE_READ_REG(hw, IXGBE_SB_IOSF_INDIRECT_CTRL);\n\t\tif (!(command & IXGBE_SB_IOSF_CTRL_BUSY))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (ctrl)\n\t\t*ctrl = command;\n\tif (i == IXGBE_MDIO_COMMAND_TIMEOUT) {\n\t\thw_dbg(hw, \"IOSF wait timed out\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t       u32 device_type, u32 *data)\n{\n\tu32 gssr = IXGBE_GSSR_PHY1_SM | IXGBE_GSSR_PHY0_SM;\n\tu32 command, error;\n\ts32 ret;\n\n\tret = hw->mac.ops.acquire_swfw_sync(hw, gssr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ixgbe_iosf_wait(hw, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tcommand = ((reg_addr << IXGBE_SB_IOSF_CTRL_ADDR_SHIFT) |\n\t\t   (device_type << IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT));\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_SB_IOSF_INDIRECT_CTRL, command);\n\n\tret = ixgbe_iosf_wait(hw, &command);\n\n\tif ((command & IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK) != 0) {\n\t\terror = (command & IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK) >>\n\t\t\t IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT;\n\t\thw_dbg(hw, \"Failed to read, error %x\\n\", error);\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\tif (!ret)\n\t\t*data = IXGBE_READ_REG(hw, IXGBE_SB_IOSF_INDIRECT_DATA);\n\nout:\n\thw->mac.ops.release_swfw_sync(hw, gssr);\n\treturn ret;\n}\n\n \nstatic s32 ixgbe_get_phy_token(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_hic_phy_token_req token_cmd;\n\ts32 status;\n\n\ttoken_cmd.hdr.cmd = FW_PHY_TOKEN_REQ_CMD;\n\ttoken_cmd.hdr.buf_len = FW_PHY_TOKEN_REQ_LEN;\n\ttoken_cmd.hdr.cmd_or_resp.cmd_resv = 0;\n\ttoken_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;\n\ttoken_cmd.port_number = hw->bus.lan_id;\n\ttoken_cmd.command_type = FW_PHY_TOKEN_REQ;\n\ttoken_cmd.pad = 0;\n\tstatus = ixgbe_host_interface_command(hw, &token_cmd, sizeof(token_cmd),\n\t\t\t\t\t      IXGBE_HI_COMMAND_TIMEOUT,\n\t\t\t\t\t      true);\n\tif (status)\n\t\treturn status;\n\tif (token_cmd.hdr.cmd_or_resp.ret_status == FW_PHY_TOKEN_OK)\n\t\treturn 0;\n\tif (token_cmd.hdr.cmd_or_resp.ret_status != FW_PHY_TOKEN_RETRY)\n\t\treturn IXGBE_ERR_FW_RESP_INVALID;\n\n\treturn IXGBE_ERR_TOKEN_RETRY;\n}\n\n \nstatic s32 ixgbe_put_phy_token(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_hic_phy_token_req token_cmd;\n\ts32 status;\n\n\ttoken_cmd.hdr.cmd = FW_PHY_TOKEN_REQ_CMD;\n\ttoken_cmd.hdr.buf_len = FW_PHY_TOKEN_REQ_LEN;\n\ttoken_cmd.hdr.cmd_or_resp.cmd_resv = 0;\n\ttoken_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;\n\ttoken_cmd.port_number = hw->bus.lan_id;\n\ttoken_cmd.command_type = FW_PHY_TOKEN_REL;\n\ttoken_cmd.pad = 0;\n\tstatus = ixgbe_host_interface_command(hw, &token_cmd, sizeof(token_cmd),\n\t\t\t\t\t      IXGBE_HI_COMMAND_TIMEOUT,\n\t\t\t\t\t      true);\n\tif (status)\n\t\treturn status;\n\tif (token_cmd.hdr.cmd_or_resp.ret_status == FW_PHY_TOKEN_OK)\n\t\treturn 0;\n\treturn IXGBE_ERR_FW_RESP_INVALID;\n}\n\n \nstatic s32 ixgbe_write_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t\t __always_unused u32 device_type,\n\t\t\t\t\t u32 data)\n{\n\tstruct ixgbe_hic_internal_phy_req write_cmd;\n\n\tmemset(&write_cmd, 0, sizeof(write_cmd));\n\twrite_cmd.hdr.cmd = FW_INT_PHY_REQ_CMD;\n\twrite_cmd.hdr.buf_len = FW_INT_PHY_REQ_LEN;\n\twrite_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;\n\twrite_cmd.port_number = hw->bus.lan_id;\n\twrite_cmd.command_type = FW_INT_PHY_REQ_WRITE;\n\twrite_cmd.address = cpu_to_be16(reg_addr);\n\twrite_cmd.write_data = cpu_to_be32(data);\n\n\treturn ixgbe_host_interface_command(hw, &write_cmd, sizeof(write_cmd),\n\t\t\t\t\t    IXGBE_HI_COMMAND_TIMEOUT, false);\n}\n\n \nstatic s32 ixgbe_read_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t\t__always_unused u32 device_type,\n\t\t\t\t\tu32 *data)\n{\n\tunion {\n\t\tstruct ixgbe_hic_internal_phy_req cmd;\n\t\tstruct ixgbe_hic_internal_phy_resp rsp;\n\t} hic;\n\ts32 status;\n\n\tmemset(&hic, 0, sizeof(hic));\n\thic.cmd.hdr.cmd = FW_INT_PHY_REQ_CMD;\n\thic.cmd.hdr.buf_len = FW_INT_PHY_REQ_LEN;\n\thic.cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;\n\thic.cmd.port_number = hw->bus.lan_id;\n\thic.cmd.command_type = FW_INT_PHY_REQ_READ;\n\thic.cmd.address = cpu_to_be16(reg_addr);\n\n\tstatus = ixgbe_host_interface_command(hw, &hic.cmd, sizeof(hic.cmd),\n\t\t\t\t\t      IXGBE_HI_COMMAND_TIMEOUT, true);\n\n\t \n\t*data = be32_to_cpu(hic.rsp.read_data);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw,\n\t\t\t\t\t    u16 offset, u16 words, u16 *data)\n{\n\tconst u32 mask = IXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_EEP_SM;\n\tstruct ixgbe_hic_read_shadow_ram buffer;\n\tu32 current_word = 0;\n\tu16 words_to_read;\n\ts32 status;\n\tu32 i;\n\n\t \n\tstatus = hw->mac.ops.acquire_swfw_sync(hw, mask);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read buffer - semaphore failed\\n\");\n\t\treturn status;\n\t}\n\n\twhile (words) {\n\t\tif (words > FW_MAX_READ_BUFFER_SIZE / 2)\n\t\t\twords_to_read = FW_MAX_READ_BUFFER_SIZE / 2;\n\t\telse\n\t\t\twords_to_read = words;\n\n\t\tbuffer.hdr.req.cmd = FW_READ_SHADOW_RAM_CMD;\n\t\tbuffer.hdr.req.buf_lenh = 0;\n\t\tbuffer.hdr.req.buf_lenl = FW_READ_SHADOW_RAM_LEN;\n\t\tbuffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;\n\n\t\t \n\t\tbuffer.address = (__force u32)cpu_to_be32((offset +\n\t\t\t\t\t\t\t   current_word) * 2);\n\t\tbuffer.length = (__force u16)cpu_to_be16(words_to_read * 2);\n\t\tbuffer.pad2 = 0;\n\t\tbuffer.pad3 = 0;\n\n\t\tstatus = ixgbe_hic_unlocked(hw, (u32 *)&buffer, sizeof(buffer),\n\t\t\t\t\t    IXGBE_HI_COMMAND_TIMEOUT);\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Host interface command failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < words_to_read; i++) {\n\t\t\tu32 reg = IXGBE_FLEX_MNG + (FW_NVM_DATA_OFFSET << 2) +\n\t\t\t\t  2 * i;\n\t\t\tu32 value = IXGBE_READ_REG(hw, reg);\n\n\t\t\tdata[current_word] = (u16)(value & 0xffff);\n\t\t\tcurrent_word++;\n\t\t\ti++;\n\t\t\tif (i < words_to_read) {\n\t\t\t\tvalue >>= 16;\n\t\t\t\tdata[current_word] = (u16)(value & 0xffff);\n\t\t\t\tcurrent_word++;\n\t\t\t}\n\t\t}\n\t\twords -= words_to_read;\n\t}\n\nout:\n\thw->mac.ops.release_swfw_sync(hw, mask);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_checksum_ptr_x550(struct ixgbe_hw *hw, u16 ptr,\n\t\t\t\t   u16 size, u16 *csum, u16 *buffer,\n\t\t\t\t   u32 buffer_size)\n{\n\tu16 buf[256];\n\ts32 status;\n\tu16 length, bufsz, i, start;\n\tu16 *local_buffer;\n\n\tbufsz = ARRAY_SIZE(buf);\n\n\t \n\tif (!buffer) {\n\t\tstatus = ixgbe_read_ee_hostif_buffer_X550(hw, ptr, bufsz, buf);\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Failed to read EEPROM image\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tlocal_buffer = buf;\n\t} else {\n\t\tif (buffer_size < ptr)\n\t\t\treturn  IXGBE_ERR_PARAM;\n\t\tlocal_buffer = &buffer[ptr];\n\t}\n\n\tif (size) {\n\t\tstart = 0;\n\t\tlength = size;\n\t} else {\n\t\tstart = 1;\n\t\tlength = local_buffer[0];\n\n\t\t \n\t\tif (length == 0xFFFF || length == 0 ||\n\t\t    (ptr + length) >= hw->eeprom.word_size)\n\t\t\treturn 0;\n\t}\n\n\tif (buffer && ((u32)start + (u32)length > buffer_size))\n\t\treturn IXGBE_ERR_PARAM;\n\n\tfor (i = start; length; i++, length--) {\n\t\tif (i == bufsz && !buffer) {\n\t\t\tptr += bufsz;\n\t\t\ti = 0;\n\t\t\tif (length < bufsz)\n\t\t\t\tbufsz = length;\n\n\t\t\t \n\t\t\tstatus = ixgbe_read_ee_hostif_buffer_X550(hw, ptr,\n\t\t\t\t\t\t\t\t  bufsz, buf);\n\t\t\tif (status) {\n\t\t\t\thw_dbg(hw, \"Failed to read EEPROM image\\n\");\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t\t*csum += local_buffer[i];\n\t}\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_calc_checksum_X550(struct ixgbe_hw *hw, u16 *buffer,\n\t\t\t\t    u32 buffer_size)\n{\n\tu16 eeprom_ptrs[IXGBE_EEPROM_LAST_WORD + 1];\n\tu16 *local_buffer;\n\ts32 status;\n\tu16 checksum = 0;\n\tu16 pointer, i, size;\n\n\thw->eeprom.ops.init_params(hw);\n\n\tif (!buffer) {\n\t\t \n\t\tstatus = ixgbe_read_ee_hostif_buffer_X550(hw, 0,\n\t\t\t\t\t\tIXGBE_EEPROM_LAST_WORD + 1,\n\t\t\t\t\t\teeprom_ptrs);\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Failed to read EEPROM image\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tlocal_buffer = eeprom_ptrs;\n\t} else {\n\t\tif (buffer_size < IXGBE_EEPROM_LAST_WORD)\n\t\t\treturn IXGBE_ERR_PARAM;\n\t\tlocal_buffer = buffer;\n\t}\n\n\t \n\tfor (i = 0; i <= IXGBE_EEPROM_LAST_WORD; i++)\n\t\tif (i != IXGBE_EEPROM_CHECKSUM)\n\t\t\tchecksum += local_buffer[i];\n\n\t \n\tfor (i = IXGBE_PCIE_ANALOG_PTR_X550; i < IXGBE_FW_PTR; i++) {\n\t\tif (i == IXGBE_PHY_PTR || i == IXGBE_OPTION_ROM_PTR)\n\t\t\tcontinue;\n\n\t\tpointer = local_buffer[i];\n\n\t\t \n\t\tif (pointer == 0xFFFF || pointer == 0 ||\n\t\t    pointer >= hw->eeprom.word_size)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IXGBE_PCIE_GENERAL_PTR:\n\t\t\tsize = IXGBE_IXGBE_PCIE_GENERAL_SIZE;\n\t\t\tbreak;\n\t\tcase IXGBE_PCIE_CONFIG0_PTR:\n\t\tcase IXGBE_PCIE_CONFIG1_PTR:\n\t\t\tsize = IXGBE_PCIE_CONFIG_SIZE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = ixgbe_checksum_ptr_x550(hw, pointer, size, &checksum,\n\t\t\t\t\t\t buffer, buffer_size);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tchecksum = (u16)IXGBE_EEPROM_SUM - checksum;\n\n\treturn (s32)checksum;\n}\n\n \nstatic s32 ixgbe_calc_eeprom_checksum_X550(struct ixgbe_hw *hw)\n{\n\treturn ixgbe_calc_checksum_X550(hw, NULL, 0);\n}\n\n \nstatic s32 ixgbe_read_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset, u16 *data)\n{\n\tconst u32 mask = IXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_EEP_SM;\n\tstruct ixgbe_hic_read_shadow_ram buffer;\n\ts32 status;\n\n\tbuffer.hdr.req.cmd = FW_READ_SHADOW_RAM_CMD;\n\tbuffer.hdr.req.buf_lenh = 0;\n\tbuffer.hdr.req.buf_lenl = FW_READ_SHADOW_RAM_LEN;\n\tbuffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;\n\n\t \n\tbuffer.address = (__force u32)cpu_to_be32(offset * 2);\n\t \n\tbuffer.length = (__force u16)cpu_to_be16(sizeof(u16));\n\n\tstatus = hw->mac.ops.acquire_swfw_sync(hw, mask);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ixgbe_hic_unlocked(hw, (u32 *)&buffer, sizeof(buffer),\n\t\t\t\t    IXGBE_HI_COMMAND_TIMEOUT);\n\tif (!status) {\n\t\t*data = (u16)IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG,\n\t\t\t\t\t\t  FW_NVM_DATA_OFFSET);\n\t}\n\n\thw->mac.ops.release_swfw_sync(hw, mask);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_validate_eeprom_checksum_X550(struct ixgbe_hw *hw,\n\t\t\t\t\t       u16 *checksum_val)\n{\n\ts32 status;\n\tu16 checksum;\n\tu16 read_checksum = 0;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, 0, &checksum);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = hw->eeprom.ops.calc_checksum(hw);\n\tif (status < 0)\n\t\treturn status;\n\n\tchecksum = (u16)(status & 0xffff);\n\n\tstatus = ixgbe_read_ee_hostif_X550(hw, IXGBE_EEPROM_CHECKSUM,\n\t\t\t\t\t   &read_checksum);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (read_checksum != checksum) {\n\t\tstatus = IXGBE_ERR_EEPROM_CHECKSUM;\n\t\thw_dbg(hw, \"Invalid EEPROM checksum\");\n\t}\n\n\t \n\tif (checksum_val)\n\t\t*checksum_val = checksum;\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_ee_hostif_data_X550(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t   u16 data)\n{\n\ts32 status;\n\tstruct ixgbe_hic_write_shadow_ram buffer;\n\n\tbuffer.hdr.req.cmd = FW_WRITE_SHADOW_RAM_CMD;\n\tbuffer.hdr.req.buf_lenh = 0;\n\tbuffer.hdr.req.buf_lenl = FW_WRITE_SHADOW_RAM_LEN;\n\tbuffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;\n\n\t \n\tbuffer.length = cpu_to_be16(sizeof(u16));\n\tbuffer.data = data;\n\tbuffer.address = cpu_to_be32(offset * 2);\n\n\tstatus = ixgbe_host_interface_command(hw, &buffer, sizeof(buffer),\n\t\t\t\t\t      IXGBE_HI_COMMAND_TIMEOUT, false);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset, u16 data)\n{\n\ts32 status = 0;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) == 0) {\n\t\tstatus = ixgbe_write_ee_hostif_data_X550(hw, offset, data);\n\t\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\t} else {\n\t\thw_dbg(hw, \"write ee hostif failed to get semaphore\");\n\t\tstatus = IXGBE_ERR_SWFW_SYNC;\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_update_flash_X550(struct ixgbe_hw *hw)\n{\n\ts32 status = 0;\n\tunion ixgbe_hic_hdr2 buffer;\n\n\tbuffer.req.cmd = FW_SHADOW_RAM_DUMP_CMD;\n\tbuffer.req.buf_lenh = 0;\n\tbuffer.req.buf_lenl = FW_SHADOW_RAM_DUMP_LEN;\n\tbuffer.req.checksum = FW_DEFAULT_CHECKSUM;\n\n\tstatus = ixgbe_host_interface_command(hw, &buffer, sizeof(buffer),\n\t\t\t\t\t      IXGBE_HI_COMMAND_TIMEOUT, false);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_get_bus_info_X550em(struct ixgbe_hw *hw)\n{\n\thw->bus.type  = ixgbe_bus_type_internal;\n\thw->bus.width = ixgbe_bus_width_unknown;\n\thw->bus.speed = ixgbe_bus_speed_unknown;\n\n\thw->mac.ops.set_lan_id(hw);\n\n\treturn 0;\n}\n\n \nstatic bool ixgbe_fw_recovery_mode_X550(struct ixgbe_hw *hw)\n{\n\tu32 fwsm;\n\n\tfwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));\n\treturn !!(fwsm & IXGBE_FWSM_FW_NVM_RECOVERY_MODE);\n}\n\n \nstatic void ixgbe_disable_rx_x550(struct ixgbe_hw *hw)\n{\n\tu32 rxctrl, pfdtxgswc;\n\ts32 status;\n\tstruct ixgbe_hic_disable_rxen fw_cmd;\n\n\trxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\n\tif (rxctrl & IXGBE_RXCTRL_RXEN) {\n\t\tpfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);\n\t\tif (pfdtxgswc & IXGBE_PFDTXGSWC_VT_LBEN) {\n\t\t\tpfdtxgswc &= ~IXGBE_PFDTXGSWC_VT_LBEN;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);\n\t\t\thw->mac.set_lben = true;\n\t\t} else {\n\t\t\thw->mac.set_lben = false;\n\t\t}\n\n\t\tfw_cmd.hdr.cmd = FW_DISABLE_RXEN_CMD;\n\t\tfw_cmd.hdr.buf_len = FW_DISABLE_RXEN_LEN;\n\t\tfw_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;\n\t\tfw_cmd.port_number = hw->bus.lan_id;\n\n\t\tstatus = ixgbe_host_interface_command(hw, &fw_cmd,\n\t\t\t\t\tsizeof(struct ixgbe_hic_disable_rxen),\n\t\t\t\t\tIXGBE_HI_COMMAND_TIMEOUT, true);\n\n\t\t \n\t\tif (status) {\n\t\t\trxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\n\t\t\tif (rxctrl & IXGBE_RXCTRL_RXEN) {\n\t\t\t\trxctrl &= ~IXGBE_RXCTRL_RXEN;\n\t\t\t\tIXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic s32 ixgbe_update_eeprom_checksum_X550(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu16 checksum = 0;\n\n\t \n\tstatus = ixgbe_read_ee_hostif_X550(hw, 0, &checksum);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ixgbe_calc_eeprom_checksum_X550(hw);\n\tif (status < 0)\n\t\treturn status;\n\n\tchecksum = (u16)(status & 0xffff);\n\n\tstatus = ixgbe_write_ee_hostif_X550(hw, IXGBE_EEPROM_CHECKSUM,\n\t\t\t\t\t    checksum);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ixgbe_update_flash_X550(hw);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_ee_hostif_buffer_X550(struct ixgbe_hw *hw,\n\t\t\t\t\t     u16 offset, u16 words,\n\t\t\t\t\t     u16 *data)\n{\n\ts32 status = 0;\n\tu32 i = 0;\n\n\t \n\tstatus = hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM write buffer - semaphore failed\\n\");\n\t\treturn status;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\tstatus = ixgbe_write_ee_hostif_data_X550(hw, offset + i,\n\t\t\t\t\t\t\t data[i]);\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Eeprom buffered write failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t\tu32 device_type, u32 data)\n{\n\tu32 gssr = IXGBE_GSSR_PHY1_SM | IXGBE_GSSR_PHY0_SM;\n\tu32 command, error;\n\ts32 ret;\n\n\tret = hw->mac.ops.acquire_swfw_sync(hw, gssr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ixgbe_iosf_wait(hw, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tcommand = ((reg_addr << IXGBE_SB_IOSF_CTRL_ADDR_SHIFT) |\n\t\t   (device_type << IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT));\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_SB_IOSF_INDIRECT_CTRL, command);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_SB_IOSF_INDIRECT_DATA, data);\n\n\tret = ixgbe_iosf_wait(hw, &command);\n\n\tif ((command & IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK) != 0) {\n\t\terror = (command & IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK) >>\n\t\t\t IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT;\n\t\thw_dbg(hw, \"Failed to write, error %x\\n\", error);\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\nout:\n\thw->mac.ops.release_swfw_sync(hw, gssr);\n\treturn ret;\n}\n\n \nstatic s32 ixgbe_setup_ixfi_x550em_x(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu32 reg_val;\n\n\t \n\tstatus = ixgbe_read_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\tif (status)\n\t\treturn status;\n\n\treg_val |= IXGBE_KRM_RX_TRN_LINKUP_CTRL_CONV_WO_PROTOCOL;\n\tstatus = ixgbe_write_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ixgbe_read_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_DSP_TXFFE_STATE_4(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\tif (status)\n\t\treturn status;\n\n\treg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_C0_EN;\n\treg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN;\n\treg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN;\n\tstatus = ixgbe_write_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_DSP_TXFFE_STATE_4(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ixgbe_read_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_DSP_TXFFE_STATE_5(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\tif (status)\n\t\treturn status;\n\n\treg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_C0_EN;\n\treg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN;\n\treg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN;\n\tstatus = ixgbe_write_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_DSP_TXFFE_STATE_5(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ixgbe_read_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_TX_COEFF_CTRL_1(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\tif (status)\n\t\treturn status;\n\n\treg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_OVRRD_EN;\n\treg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CZERO_EN;\n\treg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CPLUS1_OVRRD_EN;\n\treg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CMINUS1_OVRRD_EN;\n\tstatus = ixgbe_write_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_TX_COEFF_CTRL_1(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_restart_an_internal_phy_x550em(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu32 link_ctrl;\n\n\t \n\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &link_ctrl);\n\n\tif (status) {\n\t\thw_dbg(hw, \"Auto-negotiation did not complete\\n\");\n\t\treturn status;\n\t}\n\n\tlink_ctrl |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART;\n\tstatus = hw->mac.ops.write_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, link_ctrl);\n\n\tif (hw->mac.type == ixgbe_mac_x550em_a) {\n\t\tu32 flx_mask_st20;\n\n\t\t \n\t\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &flx_mask_st20);\n\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Auto-negotiation did not complete\\n\");\n\t\t\treturn status;\n\t\t}\n\n\t\tflx_mask_st20 |= IXGBE_KRM_PMD_FLX_MASK_ST20_FW_AN_RESTART;\n\t\tstatus = hw->mac.ops.write_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, flx_mask_st20);\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_setup_ixfi_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\ts32 status;\n\tu32 reg_val;\n\n\t \n\tif (mac->type != ixgbe_mac_X550EM_x)\n\t\treturn IXGBE_ERR_LINK_SETUP;\n\n\t \n\tstatus = ixgbe_read_iosf_sb_reg_x550(hw,\n\t\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\tif (status)\n\t\treturn status;\n\n\treg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;\n\treg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK;\n\n\t \n\tswitch (*speed) {\n\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\t\treg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G;\n\t\tbreak;\n\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\treg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn IXGBE_ERR_LINK_SETUP;\n\t}\n\n\tstatus = ixgbe_write_iosf_sb_reg_x550(hw,\n\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (hw->mac.type == ixgbe_mac_X550EM_x) {\n\t\tstatus = ixgbe_setup_ixfi_x550em_x(hw);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tstatus = ixgbe_restart_an_internal_phy_x550em(hw);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_supported_sfp_modules_X550em(struct ixgbe_hw *hw, bool *linear)\n{\n\tswitch (hw->phy.sfp_type) {\n\tcase ixgbe_sfp_type_not_present:\n\t\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n\tcase ixgbe_sfp_type_da_cu_core0:\n\tcase ixgbe_sfp_type_da_cu_core1:\n\t\t*linear = true;\n\t\tbreak;\n\tcase ixgbe_sfp_type_srlr_core0:\n\tcase ixgbe_sfp_type_srlr_core1:\n\tcase ixgbe_sfp_type_da_act_lmt_core0:\n\tcase ixgbe_sfp_type_da_act_lmt_core1:\n\tcase ixgbe_sfp_type_1g_sx_core0:\n\tcase ixgbe_sfp_type_1g_sx_core1:\n\tcase ixgbe_sfp_type_1g_lx_core0:\n\tcase ixgbe_sfp_type_1g_lx_core1:\n\t\t*linear = false;\n\t\tbreak;\n\tcase ixgbe_sfp_type_unknown:\n\tcase ixgbe_sfp_type_1g_cu_core0:\n\tcase ixgbe_sfp_type_1g_cu_core1:\n\tdefault:\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32\nixgbe_setup_mac_link_sfp_x550em(struct ixgbe_hw *hw,\n\t\t\t\tixgbe_link_speed speed,\n\t\t\t\t__always_unused bool autoneg_wait_to_complete)\n{\n\ts32 status;\n\tu16 reg_slice, reg_val;\n\tbool setup_linear = false;\n\n\t \n\tstatus = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);\n\n\t \n\tif (status == IXGBE_ERR_SFP_NOT_PRESENT)\n\t\treturn 0;\n\n\tif (status)\n\t\treturn status;\n\n\t \n\tixgbe_setup_kr_speed_x550em(hw, speed);\n\n\t \n\treg_slice = IXGBE_CS4227_LINE_SPARE24_LSB + (hw->bus.lan_id << 12);\n\tif (setup_linear)\n\t\treg_val = (IXGBE_CS4227_EDC_MODE_CX1 << 1) | 0x1;\n\telse\n\t\treg_val = (IXGBE_CS4227_EDC_MODE_SR << 1) | 0x1;\n\n\tstatus = hw->link.ops.write_link(hw, hw->link.addr, reg_slice,\n\t\t\t\t\t reg_val);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_setup_sfi_x550a(struct ixgbe_hw *hw, ixgbe_link_speed *speed)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\ts32 status;\n\tu32 reg_val;\n\n\t \n\tstatus = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\tif (status)\n\t\treturn status;\n\n\treg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN;\n\treg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN;\n\treg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN;\n\treg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK;\n\n\t \n\tswitch (*speed) {\n\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\t\treg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_10G;\n\t\tbreak;\n\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\treg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_1G;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn IXGBE_ERR_LINK_SETUP;\n\t}\n\n\t(void)mac->ops.write_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\n\t \n\t(void)mac->ops.read_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_FLX_TMRS_CTRL_ST31(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\treg_val |= 0x0400;\n\n\t(void)mac->ops.write_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_FLX_TMRS_CTRL_ST31(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\n\t \n\t(void)mac->ops.read_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\treg_val |= 0x20002240;\n\n\t(void)mac->ops.write_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\n\t \n\t(void)mac->ops.read_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_PCS_KX_AN(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\treg_val |= 0x1;\n\n\t(void)mac->ops.write_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_PCS_KX_AN(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\n\t \n\t(void)mac->ops.read_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_AN_CNTL_4(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\treg_val |= 0x20000000;\n\n\t(void)mac->ops.write_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_AN_CNTL_4(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\n\t \n\t(void)mac->ops.read_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\treg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART;\n\n\t(void)mac->ops.write_iosf_sb_reg(hw,\n\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\n\t \n\tstatus = ixgbe_restart_an_internal_phy_x550em(hw);\n\n\treturn status;\n}\n\n \nstatic s32\nixgbe_setup_mac_link_sfp_n(struct ixgbe_hw *hw, ixgbe_link_speed speed,\n\t\t\t   __always_unused bool autoneg_wait_to_complete)\n{\n\tbool setup_linear = false;\n\tu32 reg_phy_int;\n\ts32 ret_val;\n\n\t \n\tret_val = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);\n\n\t \n\tif (ret_val == IXGBE_ERR_SFP_NOT_PRESENT)\n\t\treturn 0;\n\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_phy_int);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treg_phy_int &= IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_DA;\n\tif (!setup_linear)\n\t\treg_phy_int |= IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_SR;\n\n\tret_val = hw->mac.ops.write_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_phy_int);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\treturn ixgbe_setup_sfi_x550a(hw, &speed);\n}\n\n \nstatic s32\nixgbe_setup_mac_link_sfp_x550a(struct ixgbe_hw *hw, ixgbe_link_speed speed,\n\t\t\t       __always_unused bool autoneg_wait_to_complete)\n{\n\tu32 reg_slice, slice_offset;\n\tbool setup_linear = false;\n\tu16 reg_phy_ext;\n\ts32 ret_val;\n\n\t \n\tret_val = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);\n\n\t \n\tif (ret_val == IXGBE_ERR_SFP_NOT_PRESENT)\n\t\treturn 0;\n\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tixgbe_setup_kr_speed_x550em(hw, speed);\n\n\tif (hw->phy.mdio.prtad == MDIO_PRTAD_NONE)\n\t\treturn IXGBE_ERR_PHY_ADDR_INVALID;\n\n\t \n\tret_val = hw->phy.ops.read_reg(hw, IXGBE_CS4227_EFUSE_PDF_SKU,\n\t\t\t\t       IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (reg_phy_ext == IXGBE_CS4223_SKU_ID)\n\t\tslice_offset = (hw->bus.lan_id +\n\t\t\t\t(hw->bus.instance_id << 1)) << 12;\n\telse\n\t\tslice_offset = hw->bus.lan_id << 12;\n\n\t \n\treg_slice = IXGBE_CS4227_LINE_SPARE24_LSB + slice_offset;\n\n\tret_val = hw->phy.ops.read_reg(hw, reg_slice,\n\t\t\t\t       IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treg_phy_ext &= ~((IXGBE_CS4227_EDC_MODE_CX1 << 1) |\n\t\t\t (IXGBE_CS4227_EDC_MODE_SR << 1));\n\n\tif (setup_linear)\n\t\treg_phy_ext |= (IXGBE_CS4227_EDC_MODE_CX1 << 1) | 1;\n\telse\n\t\treg_phy_ext |= (IXGBE_CS4227_EDC_MODE_SR << 1) | 1;\n\n\tret_val = hw->phy.ops.write_reg(hw, reg_slice,\n\t\t\t\t\tIXGBE_MDIO_ZERO_DEV_TYPE, reg_phy_ext);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\treturn hw->phy.ops.read_reg(hw, reg_slice,\n\t\t\t\t    IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);\n}\n\n \nstatic s32 ixgbe_setup_mac_link_t_X550em(struct ixgbe_hw *hw,\n\t\t\t\t\t ixgbe_link_speed speed,\n\t\t\t\t\t bool autoneg_wait)\n{\n\ts32 status;\n\tixgbe_link_speed force_speed;\n\n\t \n\tif (speed & IXGBE_LINK_SPEED_10GB_FULL)\n\t\tforce_speed = IXGBE_LINK_SPEED_10GB_FULL;\n\telse\n\t\tforce_speed = IXGBE_LINK_SPEED_1GB_FULL;\n\n\t \n\tif (hw->mac.type == ixgbe_mac_X550EM_x &&\n\t    !(hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE)) {\n\t\tstatus = ixgbe_setup_ixfi_x550em(hw, &force_speed);\n\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait);\n}\n\n \nstatic s32 ixgbe_check_link_t_X550em(struct ixgbe_hw *hw,\n\t\t\t\t     ixgbe_link_speed *speed,\n\t\t\t\t     bool *link_up,\n\t\t\t\t     bool link_up_wait_to_complete)\n{\n\tu32 status;\n\tu16 i, autoneg_status;\n\n\tif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)\n\t\treturn IXGBE_ERR_CONFIG;\n\n\tstatus = ixgbe_check_mac_link_generic(hw, speed, link_up,\n\t\t\t\t\t      link_up_wait_to_complete);\n\n\t \n\tif (status || !(*link_up))\n\t\treturn status;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tstatus = hw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN,\n\t\t\t\t\t      &autoneg_status);\n\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tif (!(autoneg_status & IXGBE_MDIO_AUTO_NEG_LINK_STATUS))\n\t\t*link_up = false;\n\n\treturn 0;\n}\n\n \nstatic s32\nixgbe_setup_sgmii(struct ixgbe_hw *hw, __always_unused ixgbe_link_speed speed,\n\t\t  __always_unused bool autoneg_wait_to_complete)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tu32 lval, sval, flx_val;\n\ts32 rc;\n\n\trc = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\t       IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t       IXGBE_SB_IOSF_TARGET_KR_PHY, &lval);\n\tif (rc)\n\t\treturn rc;\n\n\tlval &= ~IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;\n\tlval &= ~IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK;\n\tlval |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_SGMII_EN;\n\tlval |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_CLAUSE_37_EN;\n\tlval |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G;\n\trc = mac->ops.write_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, lval);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\t       IXGBE_KRM_SGMII_CTRL(hw->bus.lan_id),\n\t\t\t\t       IXGBE_SB_IOSF_TARGET_KR_PHY, &sval);\n\tif (rc)\n\t\treturn rc;\n\n\tsval |= IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_10_D;\n\tsval |= IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_100_D;\n\trc = mac->ops.write_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_SGMII_CTRL(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, sval);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &flx_val);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &flx_val);\n\tif (rc)\n\t\treturn rc;\n\n\tflx_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK;\n\tflx_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_1G;\n\tflx_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN;\n\tflx_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN;\n\tflx_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN;\n\n\trc = mac->ops.write_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, flx_val);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ixgbe_restart_an_internal_phy_x550em(hw);\n\treturn rc;\n}\n\n \nstatic s32 ixgbe_setup_sgmii_fw(struct ixgbe_hw *hw, ixgbe_link_speed speed,\n\t\t\t\tbool autoneg_wait)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tu32 lval, sval, flx_val;\n\ts32 rc;\n\n\trc = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\t       IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t       IXGBE_SB_IOSF_TARGET_KR_PHY, &lval);\n\tif (rc)\n\t\treturn rc;\n\n\tlval &= ~IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;\n\tlval &= ~IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK;\n\tlval |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_SGMII_EN;\n\tlval |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_CLAUSE_37_EN;\n\tlval &= ~IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G;\n\trc = mac->ops.write_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, lval);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\t       IXGBE_KRM_SGMII_CTRL(hw->bus.lan_id),\n\t\t\t\t       IXGBE_SB_IOSF_TARGET_KR_PHY, &sval);\n\tif (rc)\n\t\treturn rc;\n\n\tsval &= ~IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_10_D;\n\tsval &= ~IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_100_D;\n\trc = mac->ops.write_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_SGMII_CTRL(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, sval);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mac->ops.write_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, lval);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mac->ops.read_iosf_sb_reg(hw,\n\t\t\t\t    IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\t    IXGBE_SB_IOSF_TARGET_KR_PHY, &flx_val);\n\tif (rc)\n\t\treturn rc;\n\n\tflx_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK;\n\tflx_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_AN;\n\tflx_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN;\n\tflx_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN;\n\tflx_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN;\n\n\trc = mac->ops.write_iosf_sb_reg(hw,\n\t\t\t\t    IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\t    IXGBE_SB_IOSF_TARGET_KR_PHY, flx_val);\n\tif (rc)\n\t\treturn rc;\n\n\tixgbe_restart_an_internal_phy_x550em(hw);\n\n\treturn hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait);\n}\n\n \nstatic void ixgbe_fc_autoneg_sgmii_x550em_a(struct ixgbe_hw *hw)\n{\n\ts32 status = IXGBE_ERR_FC_NOT_NEGOTIATED;\n\tu32 info[FW_PHY_ACT_DATA_COUNT] = { 0 };\n\tixgbe_link_speed speed;\n\tbool link_up;\n\n\t \n\tif (hw->fc.disable_fc_autoneg)\n\t\tgoto out;\n\n\thw->mac.ops.check_link(hw, &speed, &link_up, false);\n\tif (!link_up)\n\t\tgoto out;\n\n\t \n\tstatus = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_LINK_INFO, &info);\n\tif (status || !(info[0] & FW_PHY_ACT_GET_LINK_INFO_AN_COMPLETE)) {\n\t\tstatus = IXGBE_ERR_FC_NOT_NEGOTIATED;\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = ixgbe_negotiate_fc(hw, info[0], info[0],\n\t\t\t\t    FW_PHY_ACT_GET_LINK_INFO_FC_RX,\n\t\t\t\t    FW_PHY_ACT_GET_LINK_INFO_FC_TX,\n\t\t\t\t    FW_PHY_ACT_GET_LINK_INFO_LP_FC_RX,\n\t\t\t\t    FW_PHY_ACT_GET_LINK_INFO_LP_FC_TX);\n\nout:\n\tif (!status) {\n\t\thw->fc.fc_was_autonegged = true;\n\t} else {\n\t\thw->fc.fc_was_autonegged = false;\n\t\thw->fc.current_mode = hw->fc.requested_mode;\n\t}\n}\n\n \nstatic void ixgbe_init_mac_link_ops_X550em_a(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\n\tswitch (mac->ops.get_media_type(hw)) {\n\tcase ixgbe_media_type_fiber:\n\t\tmac->ops.setup_fc = NULL;\n\t\tmac->ops.fc_autoneg = ixgbe_fc_autoneg_fiber_x550em_a;\n\t\tbreak;\n\tcase ixgbe_media_type_copper:\n\t\tif (hw->device_id != IXGBE_DEV_ID_X550EM_A_1G_T &&\n\t\t    hw->device_id != IXGBE_DEV_ID_X550EM_A_1G_T_L) {\n\t\t\tmac->ops.setup_link = ixgbe_setup_mac_link_t_X550em;\n\t\t\tbreak;\n\t\t}\n\t\tmac->ops.fc_autoneg = ixgbe_fc_autoneg_sgmii_x550em_a;\n\t\tmac->ops.setup_fc = ixgbe_fc_autoneg_fw;\n\t\tmac->ops.setup_link = ixgbe_setup_sgmii_fw;\n\t\tmac->ops.check_link = ixgbe_check_mac_link_generic;\n\t\tbreak;\n\tcase ixgbe_media_type_backplane:\n\t\tmac->ops.fc_autoneg = ixgbe_fc_autoneg_backplane_x550em_a;\n\t\tmac->ops.setup_fc = ixgbe_setup_fc_backplane_x550em_a;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void ixgbe_init_mac_link_ops_X550em(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\n\tmac->ops.setup_fc = ixgbe_setup_fc_x550em;\n\n\tswitch (mac->ops.get_media_type(hw)) {\n\tcase ixgbe_media_type_fiber:\n\t\t \n\t\tmac->ops.disable_tx_laser = NULL;\n\t\tmac->ops.enable_tx_laser = NULL;\n\t\tmac->ops.flap_tx_laser = NULL;\n\t\tmac->ops.setup_link = ixgbe_setup_mac_link_multispeed_fiber;\n\t\tswitch (hw->device_id) {\n\t\tcase IXGBE_DEV_ID_X550EM_A_SFP_N:\n\t\t\tmac->ops.setup_mac_link = ixgbe_setup_mac_link_sfp_n;\n\t\t\tbreak;\n\t\tcase IXGBE_DEV_ID_X550EM_A_SFP:\n\t\t\tmac->ops.setup_mac_link =\n\t\t\t\t\t\tixgbe_setup_mac_link_sfp_x550a;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmac->ops.setup_mac_link =\n\t\t\t\t\t\tixgbe_setup_mac_link_sfp_x550em;\n\t\t\tbreak;\n\t\t}\n\t\tmac->ops.set_rate_select_speed =\n\t\t\t\t\tixgbe_set_soft_rate_select_speed;\n\t\tbreak;\n\tcase ixgbe_media_type_copper:\n\t\tif (hw->device_id == IXGBE_DEV_ID_X550EM_X_1G_T)\n\t\t\tbreak;\n\t\tmac->ops.setup_link = ixgbe_setup_mac_link_t_X550em;\n\t\tmac->ops.setup_fc = ixgbe_setup_fc_generic;\n\t\tmac->ops.check_link = ixgbe_check_link_t_X550em;\n\t\tbreak;\n\tcase ixgbe_media_type_backplane:\n\t\tif (hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII ||\n\t\t    hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII_L)\n\t\t\tmac->ops.setup_link = ixgbe_setup_sgmii;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (hw->mac.type == ixgbe_mac_x550em_a)\n\t\tixgbe_init_mac_link_ops_X550em_a(hw);\n}\n\n \nstatic s32 ixgbe_setup_sfp_modules_X550em(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tbool linear;\n\n\t \n\tstatus = ixgbe_supported_sfp_modules_X550em(hw, &linear);\n\tif (status)\n\t\treturn status;\n\n\tixgbe_init_mac_link_ops_X550em(hw);\n\thw->phy.ops.reset = NULL;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw,\n\t\t\t\t\t      ixgbe_link_speed *speed,\n\t\t\t\t\t      bool *autoneg)\n{\n\tif (hw->phy.type == ixgbe_phy_fw) {\n\t\t*autoneg = true;\n\t\t*speed = hw->phy.speeds_supported;\n\t\treturn 0;\n\t}\n\n\t \n\tif (hw->phy.media_type == ixgbe_media_type_fiber) {\n\t\t \n\t\t*autoneg = false;\n\n\t\tif (hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||\n\t\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1 ||\n\t\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\n\t\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1) {\n\t\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (hw->phy.multispeed_fiber)\n\t\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL |\n\t\t\t\t IXGBE_LINK_SPEED_1GB_FULL;\n\t\telse\n\t\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t} else {\n\t\tswitch (hw->phy.type) {\n\t\tcase ixgbe_phy_x550em_kx4:\n\t\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL |\n\t\t\t\t IXGBE_LINK_SPEED_2_5GB_FULL |\n\t\t\t\t IXGBE_LINK_SPEED_10GB_FULL;\n\t\t\tbreak;\n\t\tcase ixgbe_phy_x550em_xfi:\n\t\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL |\n\t\t\t\t IXGBE_LINK_SPEED_10GB_FULL;\n\t\t\tbreak;\n\t\tcase ixgbe_phy_ext_1g_t:\n\t\tcase ixgbe_phy_sgmii:\n\t\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t\tbreak;\n\t\tcase ixgbe_phy_x550em_kr:\n\t\t\tif (hw->mac.type == ixgbe_mac_x550em_a) {\n\t\t\t\t \n\t\t\t\tif (hw->phy.nw_mng_if_sel &\n\t\t\t\t    IXGBE_NW_MNG_IF_SEL_PHY_SPEED_2_5G) {\n\t\t\t\t\t*speed = IXGBE_LINK_SPEED_2_5GB_FULL;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (hw->device_id ==\n\t\t\t\t\t   IXGBE_DEV_ID_X550EM_A_KR_L) {\n\t\t\t\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL |\n\t\t\t\t IXGBE_LINK_SPEED_1GB_FULL;\n\t\t\tbreak;\n\t\t}\n\t\t*autoneg = true;\n\t}\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)\n{\n\tu32 status;\n\tu16 reg;\n\n\t*lsc = false;\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG,\n\t\t\t\t      MDIO_MMD_VEND1,\n\t\t\t\t      &reg);\n\n\tif (status || !(reg & IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN))\n\t\treturn status;\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_FLAG,\n\t\t\t\t      MDIO_MMD_VEND1,\n\t\t\t\t      &reg);\n\n\tif (status || !(reg & (IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN |\n\t\t\t\tIXGBE_MDIO_GLOBAL_ALARM_1_INT)))\n\t\treturn status;\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_ALARM_1,\n\t\t\t\t      MDIO_MMD_VEND1,\n\t\t\t\t      &reg);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (reg & IXGBE_MDIO_GLOBAL_ALM_1_HI_TMP_FAIL) {\n\t\t \n\t\tixgbe_set_copper_phy_power(hw, false);\n\t\treturn IXGBE_ERR_OVERTEMP;\n\t}\n\tif (reg & IXGBE_MDIO_GLOBAL_ALM_1_DEV_FAULT) {\n\t\t \n\t\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_FAULT_MSG,\n\t\t\t\t\t  MDIO_MMD_VEND1,\n\t\t\t\t\t  &reg);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\t \n\t\tif (reg == IXGBE_MDIO_GLOBAL_FAULT_MSG_HI_TMP) {\n\t\t\t \n\t\t\tixgbe_set_copper_phy_power(hw, false);\n\t\t\treturn IXGBE_ERR_OVERTEMP;\n\t\t}\n\t}\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG,\n\t\t\t\t      MDIO_MMD_AN, &reg);\n\n\tif (status || !(reg & IXGBE_MDIO_GLOBAL_STD_ALM2_INT))\n\t\treturn status;\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM2,\n\t\t\t\t      MDIO_MMD_AN, &reg);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (reg & IXGBE_MDIO_AUTO_NEG_VEN_LSC)\n\t\t*lsc = true;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_enable_lasi_ext_t_x550em(struct ixgbe_hw *hw)\n{\n\tu32 status;\n\tu16 reg;\n\tbool lsc;\n\n\t \n\tstatus = ixgbe_get_lasi_ext_t_x550em(hw, &lsc);\n\n\t \n\n\t \n\tif (hw->mac.type != ixgbe_mac_x550em_a) {\n\t\tstatus = hw->phy.ops.read_reg(hw,\n\t\t\t\t\t    IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,\n\t\t\t\t\t    MDIO_MMD_AN, &reg);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\treg |= IXGBE_MDIO_PMA_TX_VEN_LASI_INT_EN;\n\n\t\tstatus = hw->phy.ops.write_reg(hw,\n\t\t\t\t\t    IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,\n\t\t\t\t\t    MDIO_MMD_AN, reg);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_MASK,\n\t\t\t\t      MDIO_MMD_VEND1,\n\t\t\t\t      &reg);\n\tif (status)\n\t\treturn status;\n\n\treg |= (IXGBE_MDIO_GLOBAL_INT_HI_TEMP_EN |\n\t\tIXGBE_MDIO_GLOBAL_INT_DEV_FAULT_EN);\n\n\tstatus = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_MASK,\n\t\t\t\t       MDIO_MMD_VEND1,\n\t\t\t\t       reg);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK,\n\t\t\t\t      MDIO_MMD_VEND1,\n\t\t\t\t      &reg);\n\tif (status)\n\t\treturn status;\n\n\treg |= (IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN |\n\t\tIXGBE_MDIO_GLOBAL_ALARM_1_INT);\n\n\tstatus = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK,\n\t\t\t\t       MDIO_MMD_VEND1,\n\t\t\t\t       reg);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK,\n\t\t\t\t      MDIO_MMD_VEND1,\n\t\t\t\t      &reg);\n\tif (status)\n\t\treturn status;\n\n\treg |= IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN;\n\n\tstatus = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK,\n\t\t\t\t       MDIO_MMD_VEND1,\n\t\t\t\t       reg);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\tbool lsc;\n\tu32 status;\n\n\tstatus = ixgbe_get_lasi_ext_t_x550em(hw, &lsc);\n\tif (status)\n\t\treturn status;\n\n\tif (lsc && phy->ops.setup_internal_link)\n\t\treturn phy->ops.setup_internal_link(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw,\n\t\t\t\t       ixgbe_link_speed speed)\n{\n\ts32 status;\n\tu32 reg_val;\n\n\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\tif (status)\n\t\treturn status;\n\n\treg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;\n\treg_val &= ~(IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR |\n\t\t     IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX);\n\n\t \n\tif (speed & IXGBE_LINK_SPEED_10GB_FULL)\n\t\treg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR;\n\n\t \n\tif (speed & IXGBE_LINK_SPEED_1GB_FULL)\n\t\treg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX;\n\n\tstatus = hw->mac.ops.write_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\n\tif (hw->mac.type == ixgbe_mac_x550em_a) {\n\t\t \n\t\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);\n\n\t\tif (status)\n\t\t\treturn status;\n\n\t\treg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK;\n\t\treg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_AN;\n\t\treg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN;\n\t\treg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN;\n\t\treg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN;\n\n\t\tstatus = hw->mac.ops.write_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);\n\t}\n\n\treturn ixgbe_restart_an_internal_phy_x550em(hw);\n}\n\n \nstatic s32 ixgbe_setup_kr_x550em(struct ixgbe_hw *hw)\n{\n\t \n\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_2_5GB_FULL)\n\t\treturn 0;\n\n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\treturn ixgbe_setup_kr_speed_x550em(hw, hw->phy.autoneg_advertised);\n}\n\n \nstatic s32 ixgbe_ext_phy_t_x550em_get_link(struct ixgbe_hw *hw, bool *link_up)\n{\n\tu32 ret;\n\tu16 autoneg_status;\n\n\t*link_up = false;\n\n\t \n\tret = hw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN,\n\t\t\t\t   &autoneg_status);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN,\n\t\t\t\t   &autoneg_status);\n\tif (ret)\n\t\treturn ret;\n\n\t*link_up = !!(autoneg_status & IXGBE_MDIO_AUTO_NEG_LINK_STATUS);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_setup_internal_phy_t_x550em(struct ixgbe_hw *hw)\n{\n\tixgbe_link_speed force_speed;\n\tbool link_up;\n\tu32 status;\n\tu16 speed;\n\n\tif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)\n\t\treturn IXGBE_ERR_CONFIG;\n\n\tif (!(hw->mac.type == ixgbe_mac_X550EM_x &&\n\t      !(hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE))) {\n\t\tspeed = IXGBE_LINK_SPEED_10GB_FULL |\n\t\t\tIXGBE_LINK_SPEED_1GB_FULL;\n\t\treturn ixgbe_setup_kr_speed_x550em(hw, speed);\n\t}\n\n\t \n\tstatus = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);\n\tif (status)\n\t\treturn status;\n\n\tif (!link_up)\n\t\treturn 0;\n\n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_STAT,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      &speed);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);\n\tif (status)\n\t\treturn status;\n\n\tif (!link_up)\n\t\treturn 0;\n\n\t \n\tspeed &= IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_MASK;\n\n\tswitch (speed) {\n\tcase IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_FULL:\n\t\tforce_speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t\tbreak;\n\tcase IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_FULL:\n\t\tforce_speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\t}\n\n\treturn ixgbe_setup_ixfi_x550em(hw, &force_speed);\n}\n\n \nstatic s32 ixgbe_reset_phy_t_X550em(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\n\tstatus = ixgbe_reset_phy_generic(hw);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\treturn ixgbe_enable_lasi_ext_t_x550em(hw);\n}\n\n \nstatic s32 ixgbe_led_on_t_x550em(struct ixgbe_hw *hw, u32 led_idx)\n{\n\tu16 phy_data;\n\n\tif (led_idx >= IXGBE_X557_MAX_LED_INDEX)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\thw->phy.ops.read_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,\n\t\t\t     MDIO_MMD_VEND1, &phy_data);\n\tphy_data |= IXGBE_X557_LED_MANUAL_SET_MASK;\n\thw->phy.ops.write_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,\n\t\t\t      MDIO_MMD_VEND1, phy_data);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_led_off_t_x550em(struct ixgbe_hw *hw, u32 led_idx)\n{\n\tu16 phy_data;\n\n\tif (led_idx >= IXGBE_X557_MAX_LED_INDEX)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\thw->phy.ops.read_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,\n\t\t\t     MDIO_MMD_VEND1, &phy_data);\n\tphy_data &= ~IXGBE_X557_LED_MANUAL_SET_MASK;\n\thw->phy.ops.write_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,\n\t\t\t      MDIO_MMD_VEND1, phy_data);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_set_fw_drv_ver_x550(struct ixgbe_hw *hw, u8 maj, u8 min,\n\t\t\t\t     u8 build, u8 sub, u16 len,\n\t\t\t\t     const char *driver_ver)\n{\n\tstruct ixgbe_hic_drv_info2 fw_cmd;\n\ts32 ret_val;\n\tint i;\n\n\tif (!len || !driver_ver || (len > sizeof(fw_cmd.driver_string)))\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\n\tfw_cmd.hdr.cmd = FW_CEM_CMD_DRIVER_INFO;\n\tfw_cmd.hdr.buf_len = FW_CEM_CMD_DRIVER_INFO_LEN + len;\n\tfw_cmd.hdr.cmd_or_resp.cmd_resv = FW_CEM_CMD_RESERVED;\n\tfw_cmd.port_num = (u8)hw->bus.func;\n\tfw_cmd.ver_maj = maj;\n\tfw_cmd.ver_min = min;\n\tfw_cmd.ver_build = build;\n\tfw_cmd.ver_sub = sub;\n\tfw_cmd.hdr.checksum = 0;\n\tmemcpy(fw_cmd.driver_string, driver_ver, len);\n\tfw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&fw_cmd,\n\t\t\t      (FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));\n\n\tfor (i = 0; i <= FW_CEM_MAX_RETRIES; i++) {\n\t\tret_val = ixgbe_host_interface_command(hw, (u32 *)&fw_cmd,\n\t\t\t\t\t\t       sizeof(fw_cmd),\n\t\t\t\t\t\t       IXGBE_HI_COMMAND_TIMEOUT,\n\t\t\t\t\t\t       true);\n\t\tif (ret_val)\n\t\t\tcontinue;\n\n\t\tif (fw_cmd.hdr.cmd_or_resp.ret_status !=\n\t\t    FW_CEM_RESP_STATUS_SUCCESS)\n\t\t\treturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\n\t\treturn 0;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbe_get_lcd_t_x550em(struct ixgbe_hw *hw,\n\t\t\t\t  ixgbe_link_speed *lcd_speed)\n{\n\tu16 an_lp_status;\n\ts32 status;\n\tu16 word = hw->eeprom.ctrl_word_3;\n\n\t*lcd_speed = IXGBE_LINK_SPEED_UNKNOWN;\n\n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_AUTO_NEG_LP_STATUS,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      &an_lp_status);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (an_lp_status & IXGBE_AUTO_NEG_LP_1000BASE_CAP) {\n\t\t*lcd_speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\treturn status;\n\t}\n\n\t \n\tif ((hw->bus.lan_id && (word & NVM_INIT_CTRL_3_D10GMP_PORT1)) ||\n\t    (word & NVM_INIT_CTRL_3_D10GMP_PORT0))\n\t\treturn status;\n\n\t \n\t*lcd_speed = IXGBE_LINK_SPEED_10GB_FULL;\n\treturn status;\n}\n\n \nstatic s32 ixgbe_setup_fc_x550em(struct ixgbe_hw *hw)\n{\n\tbool pause, asm_dir;\n\tu32 reg_val;\n\ts32 rc = 0;\n\n\t \n\tif (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {\n\t\thw_err(hw, \"ixgbe_fc_rx_pause not valid in strict IEEE mode\\n\");\n\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\t}\n\n\t \n\tif (hw->fc.requested_mode == ixgbe_fc_default)\n\t\thw->fc.requested_mode = ixgbe_fc_full;\n\n\t \n\tswitch (hw->fc.requested_mode) {\n\tcase ixgbe_fc_none:\n\t\tpause = false;\n\t\tasm_dir = false;\n\t\tbreak;\n\tcase ixgbe_fc_tx_pause:\n\t\tpause = false;\n\t\tasm_dir = true;\n\t\tbreak;\n\tcase ixgbe_fc_rx_pause:\n\t\t \n\t\tfallthrough;\n\tcase ixgbe_fc_full:\n\t\tpause = true;\n\t\tasm_dir = true;\n\t\tbreak;\n\tdefault:\n\t\thw_err(hw, \"Flow control param set incorrectly\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_X550EM_X_KR:\n\tcase IXGBE_DEV_ID_X550EM_A_KR:\n\tcase IXGBE_DEV_ID_X550EM_A_KR_L:\n\t\trc = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\t\t    IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),\n\t\t\t\t\t    IXGBE_SB_IOSF_TARGET_KR_PHY,\n\t\t\t\t\t    &reg_val);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\treg_val &= ~(IXGBE_KRM_AN_CNTL_1_SYM_PAUSE |\n\t\t\t     IXGBE_KRM_AN_CNTL_1_ASM_PAUSE);\n\t\tif (pause)\n\t\t\treg_val |= IXGBE_KRM_AN_CNTL_1_SYM_PAUSE;\n\t\tif (asm_dir)\n\t\t\treg_val |= IXGBE_KRM_AN_CNTL_1_ASM_PAUSE;\n\t\trc = hw->mac.ops.write_iosf_sb_reg(hw,\n\t\t\t\t\t    IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),\n\t\t\t\t\t    IXGBE_SB_IOSF_TARGET_KR_PHY,\n\t\t\t\t\t    reg_val);\n\n\t\t \n\t\thw->fc.disable_fc_autoneg = true;\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_X_XFI:\n\t\thw->fc.disable_fc_autoneg = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \nstatic void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *hw)\n{\n\tu32 link_s1, lp_an_page_low, an_cntl_1;\n\ts32 status = IXGBE_ERR_FC_NOT_NEGOTIATED;\n\tixgbe_link_speed speed;\n\tbool link_up;\n\n\t \n\tif (hw->fc.disable_fc_autoneg) {\n\t\thw_err(hw, \"Flow control autoneg is disabled\");\n\t\tgoto out;\n\t}\n\n\thw->mac.ops.check_link(hw, &speed, &link_up, false);\n\tif (!link_up) {\n\t\thw_err(hw, \"The link is down\");\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_LINK_S1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &link_s1);\n\n\tif (status || (link_s1 & IXGBE_KRM_LINK_S1_MAC_AN_COMPLETE) == 0) {\n\t\thw_dbg(hw, \"Auto-Negotiation did not complete\\n\");\n\t\tstatus = IXGBE_ERR_FC_NOT_NEGOTIATED;\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &an_cntl_1);\n\n\tif (status) {\n\t\thw_dbg(hw, \"Auto-Negotiation did not complete\\n\");\n\t\tgoto out;\n\t}\n\n\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\tIXGBE_KRM_LP_BASE_PAGE_HIGH(hw->bus.lan_id),\n\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &lp_an_page_low);\n\n\tif (status) {\n\t\thw_dbg(hw, \"Auto-Negotiation did not complete\\n\");\n\t\tgoto out;\n\t}\n\n\tstatus = ixgbe_negotiate_fc(hw, an_cntl_1, lp_an_page_low,\n\t\t\t\t    IXGBE_KRM_AN_CNTL_1_SYM_PAUSE,\n\t\t\t\t    IXGBE_KRM_AN_CNTL_1_ASM_PAUSE,\n\t\t\t\t    IXGBE_KRM_LP_BASE_PAGE_HIGH_SYM_PAUSE,\n\t\t\t\t    IXGBE_KRM_LP_BASE_PAGE_HIGH_ASM_PAUSE);\n\nout:\n\tif (!status) {\n\t\thw->fc.fc_was_autonegged = true;\n\t} else {\n\t\thw->fc.fc_was_autonegged = false;\n\t\thw->fc.current_mode = hw->fc.requested_mode;\n\t}\n}\n\n \nstatic void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *hw)\n{\n\thw->fc.fc_was_autonegged = false;\n\thw->fc.current_mode = hw->fc.requested_mode;\n}\n\n \nstatic s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw)\n{\n\tu16 an_10g_cntl_reg, autoneg_reg, speed;\n\ts32 status;\n\tixgbe_link_speed lcd_speed;\n\tu32 save_autoneg;\n\tbool link_up;\n\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\tstatus = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);\n\tif (status)\n\t\treturn status;\n\n\tstatus = hw->eeprom.ops.read(hw, NVM_INIT_CTRL_3,\n\t\t\t\t     &hw->eeprom.ctrl_word_3);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (!link_up || !(hw->eeprom.ctrl_word_3 & NVM_INIT_CTRL_3_LPLU) ||\n\t    !(hw->wol_enabled || ixgbe_mng_present(hw)))\n\t\treturn ixgbe_set_copper_phy_power(hw, false);\n\n\t \n\tstatus = ixgbe_get_lcd_t_x550em(hw, &lcd_speed);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (lcd_speed == IXGBE_LINK_SPEED_UNKNOWN)\n\t\treturn ixgbe_set_copper_phy_power(hw, false);\n\n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_STAT,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      &speed);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);\n\tif (status)\n\t\treturn ixgbe_set_copper_phy_power(hw, false);\n\n\t \n\tspeed &= IXGBE_MDIO_AUTO_NEG_VEN_STAT_SPEED_MASK;\n\n\t \n\tif (((speed == IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB) &&\n\t     (lcd_speed == IXGBE_LINK_SPEED_1GB_FULL)) ||\n\t    ((speed == IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB) &&\n\t     (lcd_speed == IXGBE_LINK_SPEED_10GB_FULL)))\n\t\treturn status;\n\n\t \n\tstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      &autoneg_reg);\n\tif (status)\n\t\treturn status;\n\n\tstatus = hw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      &an_10g_cntl_reg);\n\tif (status)\n\t\treturn status;\n\n\tstatus = hw->phy.ops.read_reg(hw,\n\t\t\t\t      IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      &autoneg_reg);\n\tif (status)\n\t\treturn status;\n\n\tsave_autoneg = hw->phy.autoneg_advertised;\n\n\t \n\tstatus = hw->mac.ops.setup_link(hw, lcd_speed, false);\n\n\t \n\thw->phy.autoneg_advertised = save_autoneg;\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_reset_phy_fw(struct ixgbe_hw *hw)\n{\n\tu32 store[FW_PHY_ACT_DATA_COUNT] = { 0 };\n\ts32 rc;\n\n\tif (hw->phy.reset_disable || ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\trc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_PHY_SW_RESET, &store);\n\tif (rc)\n\t\treturn rc;\n\tmemset(store, 0, sizeof(store));\n\n\trc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_INIT_PHY, &store);\n\tif (rc)\n\t\treturn rc;\n\n\treturn ixgbe_setup_fw_link(hw);\n}\n\n \nstatic s32 ixgbe_check_overtemp_fw(struct ixgbe_hw *hw)\n{\n\tu32 store[FW_PHY_ACT_DATA_COUNT] = { 0 };\n\ts32 rc;\n\n\trc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_LINK_INFO, &store);\n\tif (rc)\n\t\treturn rc;\n\n\tif (store[0] & FW_PHY_ACT_GET_LINK_INFO_TEMP) {\n\t\tixgbe_shutdown_fw_phy(hw);\n\t\treturn IXGBE_ERR_OVERTEMP;\n\t}\n\treturn 0;\n}\n\n \nstatic void ixgbe_read_mng_if_sel_x550em(struct ixgbe_hw *hw)\n{\n\t \n\thw->phy.nw_mng_if_sel = IXGBE_READ_REG(hw, IXGBE_NW_MNG_IF_SEL);\n\n\t \n\tif (hw->mac.type == ixgbe_mac_x550em_a &&\n\t    hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_MDIO_ACT) {\n\t\thw->phy.mdio.prtad = (hw->phy.nw_mng_if_sel &\n\t\t\t\t      IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD) >>\n\t\t\t\t     IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT;\n\t}\n}\n\n \nstatic s32 ixgbe_init_phy_ops_X550em(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\n\thw->mac.ops.set_lan_id(hw);\n\n\tixgbe_read_mng_if_sel_x550em(hw);\n\n\tif (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) {\n\t\tphy->phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;\n\t\tixgbe_setup_mux_ctl(hw);\n\t}\n\n\t \n\tret_val = phy->ops.identify(hw);\n\tif (ret_val == IXGBE_ERR_SFP_NOT_SUPPORTED ||\n\t    ret_val == IXGBE_ERR_PHY_ADDR_INVALID)\n\t\treturn ret_val;\n\n\t \n\tixgbe_init_mac_link_ops_X550em(hw);\n\tif (phy->sfp_type != ixgbe_sfp_type_unknown)\n\t\tphy->ops.reset = NULL;\n\n\t \n\tswitch (hw->phy.type) {\n\tcase ixgbe_phy_x550em_kx4:\n\t\tphy->ops.setup_link = NULL;\n\t\tphy->ops.read_reg = ixgbe_read_phy_reg_x550em;\n\t\tphy->ops.write_reg = ixgbe_write_phy_reg_x550em;\n\t\tbreak;\n\tcase ixgbe_phy_x550em_kr:\n\t\tphy->ops.setup_link = ixgbe_setup_kr_x550em;\n\t\tphy->ops.read_reg = ixgbe_read_phy_reg_x550em;\n\t\tphy->ops.write_reg = ixgbe_write_phy_reg_x550em;\n\t\tbreak;\n\tcase ixgbe_phy_x550em_xfi:\n\t\t \n\t\tphy->ops.setup_link = NULL;\n\t\tphy->ops.read_reg = ixgbe_read_phy_reg_x550em;\n\t\tphy->ops.write_reg = ixgbe_write_phy_reg_x550em;\n\t\tbreak;\n\tcase ixgbe_phy_x550em_ext_t:\n\t\t \n\t\tphy->nw_mng_if_sel = IXGBE_READ_REG(hw, IXGBE_NW_MNG_IF_SEL);\n\n\t\t \n\t\tphy->ops.setup_internal_link =\n\t\t\t\t\t      ixgbe_setup_internal_phy_t_x550em;\n\n\t\t \n\t\tif (hw->mac.type == ixgbe_mac_X550EM_x &&\n\t\t    !(IXGBE_READ_REG(hw, IXGBE_FUSES0_GROUP(0)) &\n\t\t      IXGBE_FUSES0_REV_MASK))\n\t\t\tphy->ops.enter_lplu = ixgbe_enter_lplu_t_x550em;\n\n\t\tphy->ops.handle_lasi = ixgbe_handle_lasi_ext_t_x550em;\n\t\tphy->ops.reset = ixgbe_reset_phy_t_X550em;\n\t\tbreak;\n\tcase ixgbe_phy_sgmii:\n\t\tphy->ops.setup_link = NULL;\n\t\tbreak;\n\tcase ixgbe_phy_fw:\n\t\tphy->ops.setup_link = ixgbe_setup_fw_link;\n\t\tphy->ops.reset = ixgbe_reset_phy_fw;\n\t\tbreak;\n\tcase ixgbe_phy_ext_1g_t:\n\t\tphy->ops.setup_link = NULL;\n\t\tphy->ops.read_reg = NULL;\n\t\tphy->ops.write_reg = NULL;\n\t\tphy->ops.reset = NULL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic enum ixgbe_media_type ixgbe_get_media_type_X550em(struct ixgbe_hw *hw)\n{\n\tenum ixgbe_media_type media_type;\n\n\t \n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_X550EM_A_SGMII:\n\tcase IXGBE_DEV_ID_X550EM_A_SGMII_L:\n\t\thw->phy.type = ixgbe_phy_sgmii;\n\t\tfallthrough;\n\tcase IXGBE_DEV_ID_X550EM_X_KR:\n\tcase IXGBE_DEV_ID_X550EM_X_KX4:\n\tcase IXGBE_DEV_ID_X550EM_X_XFI:\n\tcase IXGBE_DEV_ID_X550EM_A_KR:\n\tcase IXGBE_DEV_ID_X550EM_A_KR_L:\n\t\tmedia_type = ixgbe_media_type_backplane;\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_X_SFP:\n\tcase IXGBE_DEV_ID_X550EM_A_SFP:\n\tcase IXGBE_DEV_ID_X550EM_A_SFP_N:\n\t\tmedia_type = ixgbe_media_type_fiber;\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_X_1G_T:\n\tcase IXGBE_DEV_ID_X550EM_X_10G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_10G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T_L:\n\t\tmedia_type = ixgbe_media_type_copper;\n\t\tbreak;\n\tdefault:\n\t\tmedia_type = ixgbe_media_type_unknown;\n\t\tbreak;\n\t}\n\treturn media_type;\n}\n\n \nstatic s32 ixgbe_init_ext_t_x550em(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu16 reg;\n\n\tstatus = hw->phy.ops.read_reg(hw,\n\t\t\t\t      IXGBE_MDIO_TX_VENDOR_ALARMS_3,\n\t\t\t\t      MDIO_MMD_PMAPMD,\n\t\t\t\t      &reg);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (reg & IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK) {\n\t\tstatus = hw->phy.ops.read_reg(hw,\n\t\t\t\t\tIXGBE_MDIO_GLOBAL_RES_PR_10,\n\t\t\t\t\tMDIO_MMD_VEND1,\n\t\t\t\t\t&reg);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\treg &= ~IXGBE_MDIO_POWER_UP_STALL;\n\n\t\tstatus = hw->phy.ops.write_reg(hw,\n\t\t\t\t\tIXGBE_MDIO_GLOBAL_RES_PR_10,\n\t\t\t\t\tMDIO_MMD_VEND1,\n\t\t\t\t\treg);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\n \nstatic void ixgbe_set_mdio_speed(struct ixgbe_hw *hw)\n{\n\tu32 hlreg0;\n\n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_X550EM_X_10G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_SGMII:\n\tcase IXGBE_DEV_ID_X550EM_A_SGMII_L:\n\tcase IXGBE_DEV_ID_X550EM_A_10G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_SFP:\n\t\t \n\t\thlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);\n\t\thlreg0 &= ~IXGBE_HLREG0_MDCSPD;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);\n\t\tbreak;\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T_L:\n\t\t \n\t\thlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);\n\t\thlreg0 |= IXGBE_HLREG0_MDCSPD;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic s32 ixgbe_reset_hw_X550em(struct ixgbe_hw *hw)\n{\n\tixgbe_link_speed link_speed;\n\ts32 status;\n\tu32 ctrl = 0;\n\tu32 i;\n\tbool link_up = false;\n\tu32 swfw_mask = hw->phy.phy_semaphore_mask;\n\n\t \n\tstatus = hw->mac.ops.stop_adapter(hw);\n\tif (status)\n\t\treturn status;\n\n\t \n\tixgbe_clear_tx_pending(hw);\n\n\t \n\tixgbe_set_mdio_speed(hw);\n\n\t \n\tstatus = hw->phy.ops.init(hw);\n\tif (status == IXGBE_ERR_SFP_NOT_SUPPORTED ||\n\t    status == IXGBE_ERR_PHY_ADDR_INVALID)\n\t\treturn status;\n\n\t \n\tif (hw->phy.type == ixgbe_phy_x550em_ext_t) {\n\t\tstatus = ixgbe_init_ext_t_x550em(hw);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tif (hw->phy.sfp_setup_needed) {\n\t\tstatus = hw->mac.ops.setup_sfp(hw);\n\t\thw->phy.sfp_setup_needed = false;\n\t}\n\n\tif (status == IXGBE_ERR_SFP_NOT_SUPPORTED)\n\t\treturn status;\n\n\t \n\tif (!hw->phy.reset_disable && hw->phy.ops.reset)\n\t\thw->phy.ops.reset(hw);\n\nmac_reset_top:\n\t \n\tctrl = IXGBE_CTRL_LNK_RST;\n\n\tif (!hw->force_full_reset) {\n\t\thw->mac.ops.check_link(hw, &link_speed, &link_up, false);\n\t\tif (link_up)\n\t\t\tctrl = IXGBE_CTRL_RST;\n\t}\n\n\tstatus = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);\n\tif (status) {\n\t\thw_dbg(hw, \"semaphore failed with %d\", status);\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\t}\n\n\tctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);\n\tIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\n\tIXGBE_WRITE_FLUSH(hw);\n\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\tusleep_range(1000, 1200);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\n\t\tif (!(ctrl & IXGBE_CTRL_RST_MASK))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (ctrl & IXGBE_CTRL_RST_MASK) {\n\t\tstatus = IXGBE_ERR_RESET_FAILED;\n\t\thw_dbg(hw, \"Reset polling failed to complete.\\n\");\n\t}\n\n\tmsleep(50);\n\n\t \n\tif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\n\t\thw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\n\t\tgoto mac_reset_top;\n\t}\n\n\t \n\thw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\n\n\t \n\thw->mac.num_rar_entries = 128;\n\thw->mac.ops.init_rx_addrs(hw);\n\n\tixgbe_set_mdio_speed(hw);\n\n\tif (hw->device_id == IXGBE_DEV_ID_X550EM_X_SFP)\n\t\tixgbe_setup_mux_ctl(hw);\n\n\treturn status;\n}\n\n \nstatic void ixgbe_set_ethertype_anti_spoofing_X550(struct ixgbe_hw *hw,\n\t\t\t\t\t\t   bool enable, int vf)\n{\n\tint vf_target_reg = vf >> 3;\n\tint vf_target_shift = vf % 8 + IXGBE_SPOOF_ETHERTYPEAS_SHIFT;\n\tu32 pfvfspoof;\n\n\tpfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));\n\tif (enable)\n\t\tpfvfspoof |= BIT(vf_target_shift);\n\telse\n\t\tpfvfspoof &= ~BIT(vf_target_shift);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);\n}\n\n \nstatic void ixgbe_set_source_address_pruning_X550(struct ixgbe_hw *hw,\n\t\t\t\t\t\t  bool enable,\n\t\t\t\t\t\t  unsigned int pool)\n{\n\tu64 pfflp;\n\n\t \n\tif (pool > 63)\n\t\treturn;\n\n\tpfflp = (u64)IXGBE_READ_REG(hw, IXGBE_PFFLPL);\n\tpfflp |= (u64)IXGBE_READ_REG(hw, IXGBE_PFFLPH) << 32;\n\n\tif (enable)\n\t\tpfflp |= (1ULL << pool);\n\telse\n\t\tpfflp &= ~(1ULL << pool);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_PFFLPL, (u32)pfflp);\n\tIXGBE_WRITE_REG(hw, IXGBE_PFFLPH, (u32)(pfflp >> 32));\n}\n\n \nstatic s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw)\n{\n\ts32 status = 0;\n\tu32 an_cntl = 0;\n\n\t \n\tif (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {\n\t\thw_err(hw, \"ixgbe_fc_rx_pause not valid in strict IEEE mode\\n\");\n\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\t}\n\n\tif (hw->fc.requested_mode == ixgbe_fc_default)\n\t\thw->fc.requested_mode = ixgbe_fc_full;\n\n\t \n\tstatus = hw->mac.ops.read_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, &an_cntl);\n\n\tif (status) {\n\t\thw_dbg(hw, \"Auto-Negotiation did not complete\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tswitch (hw->fc.requested_mode) {\n\tcase ixgbe_fc_none:\n\t\t \n\t\tan_cntl &= ~(IXGBE_KRM_AN_CNTL_1_SYM_PAUSE |\n\t\t\t     IXGBE_KRM_AN_CNTL_1_ASM_PAUSE);\n\t\tbreak;\n\tcase ixgbe_fc_tx_pause:\n\t\t \n\t\tan_cntl |= IXGBE_KRM_AN_CNTL_1_ASM_PAUSE;\n\t\tan_cntl &= ~IXGBE_KRM_AN_CNTL_1_SYM_PAUSE;\n\t\tbreak;\n\tcase ixgbe_fc_rx_pause:\n\t\t \n\tcase ixgbe_fc_full:\n\t\t \n\t\tan_cntl |= IXGBE_KRM_AN_CNTL_1_SYM_PAUSE |\n\t\t\t   IXGBE_KRM_AN_CNTL_1_ASM_PAUSE;\n\t\tbreak;\n\tdefault:\n\t\thw_err(hw, \"Flow control param set incorrectly\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\tstatus = hw->mac.ops.write_iosf_sb_reg(hw,\n\t\t\t\t\tIXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),\n\t\t\t\t\tIXGBE_SB_IOSF_TARGET_KR_PHY, an_cntl);\n\n\t \n\tstatus = ixgbe_restart_an_internal_phy_x550em(hw);\n\n\treturn status;\n}\n\n \nstatic void ixgbe_set_mux(struct ixgbe_hw *hw, u8 state)\n{\n\tu32 esdp;\n\n\tif (!hw->bus.lan_id)\n\t\treturn;\n\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\tif (state)\n\t\tesdp |= IXGBE_ESDP_SDP1;\n\telse\n\t\tesdp &= ~IXGBE_ESDP_SDP1;\n\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic s32 ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)\n{\n\ts32 status;\n\n\tstatus = ixgbe_acquire_swfw_sync_X540(hw, mask);\n\tif (status)\n\t\treturn status;\n\n\tif (mask & IXGBE_GSSR_I2C_MASK)\n\t\tixgbe_set_mux(hw, 1);\n\n\treturn 0;\n}\n\n \nstatic void ixgbe_release_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)\n{\n\tif (mask & IXGBE_GSSR_I2C_MASK)\n\t\tixgbe_set_mux(hw, 0);\n\n\tixgbe_release_swfw_sync_X540(hw, mask);\n}\n\n \nstatic s32 ixgbe_acquire_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;\n\tint retries = FW_PHY_TOKEN_RETRIES;\n\ts32 status;\n\n\twhile (--retries) {\n\t\tstatus = 0;\n\t\tif (hmask)\n\t\t\tstatus = ixgbe_acquire_swfw_sync_X540(hw, hmask);\n\t\tif (status)\n\t\t\treturn status;\n\t\tif (!(mask & IXGBE_GSSR_TOKEN_SM))\n\t\t\treturn 0;\n\n\t\tstatus = ixgbe_get_phy_token(hw);\n\t\tif (!status)\n\t\t\treturn 0;\n\t\tif (hmask)\n\t\t\tixgbe_release_swfw_sync_X540(hw, hmask);\n\t\tif (status != IXGBE_ERR_TOKEN_RETRY)\n\t\t\treturn status;\n\t\tmsleep(FW_PHY_TOKEN_DELAY);\n\t}\n\n\treturn status;\n}\n\n \nstatic void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;\n\n\tif (mask & IXGBE_GSSR_TOKEN_SM)\n\t\tixgbe_put_phy_token(hw);\n\n\tif (hmask)\n\t\tixgbe_release_swfw_sync_X540(hw, hmask);\n}\n\n \nstatic s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t    u32 device_type, u16 *phy_data)\n{\n\tu32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;\n\ts32 status;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, mask))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = hw->phy.ops.read_reg_mdi(hw, reg_addr, device_type, phy_data);\n\n\thw->mac.ops.release_swfw_sync(hw, mask);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\t     u32 device_type, u16 phy_data)\n{\n\tu32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;\n\ts32 status;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, mask))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type, phy_data);\n\thw->mac.ops.release_swfw_sync(hw, mask);\n\n\treturn status;\n}\n\n#define X550_COMMON_MAC \\\n\t.init_hw\t\t\t= &ixgbe_init_hw_generic, \\\n\t.start_hw\t\t\t= &ixgbe_start_hw_X540, \\\n\t.clear_hw_cntrs\t\t\t= &ixgbe_clear_hw_cntrs_generic, \\\n\t.enable_rx_dma\t\t\t= &ixgbe_enable_rx_dma_generic, \\\n\t.get_mac_addr\t\t\t= &ixgbe_get_mac_addr_generic, \\\n\t.get_device_caps\t\t= &ixgbe_get_device_caps_generic, \\\n\t.stop_adapter\t\t\t= &ixgbe_stop_adapter_generic, \\\n\t.set_lan_id\t\t\t= &ixgbe_set_lan_id_multi_port_pcie, \\\n\t.read_analog_reg8\t\t= NULL, \\\n\t.write_analog_reg8\t\t= NULL, \\\n\t.set_rxpba\t\t\t= &ixgbe_set_rxpba_generic, \\\n\t.check_link\t\t\t= &ixgbe_check_mac_link_generic, \\\n\t.blink_led_start\t\t= &ixgbe_blink_led_start_X540, \\\n\t.blink_led_stop\t\t\t= &ixgbe_blink_led_stop_X540, \\\n\t.set_rar\t\t\t= &ixgbe_set_rar_generic, \\\n\t.clear_rar\t\t\t= &ixgbe_clear_rar_generic, \\\n\t.set_vmdq\t\t\t= &ixgbe_set_vmdq_generic, \\\n\t.set_vmdq_san_mac\t\t= &ixgbe_set_vmdq_san_mac_generic, \\\n\t.clear_vmdq\t\t\t= &ixgbe_clear_vmdq_generic, \\\n\t.init_rx_addrs\t\t\t= &ixgbe_init_rx_addrs_generic, \\\n\t.update_mc_addr_list\t\t= &ixgbe_update_mc_addr_list_generic, \\\n\t.enable_mc\t\t\t= &ixgbe_enable_mc_generic, \\\n\t.disable_mc\t\t\t= &ixgbe_disable_mc_generic, \\\n\t.clear_vfta\t\t\t= &ixgbe_clear_vfta_generic, \\\n\t.set_vfta\t\t\t= &ixgbe_set_vfta_generic, \\\n\t.fc_enable\t\t\t= &ixgbe_fc_enable_generic, \\\n\t.set_fw_drv_ver\t\t\t= &ixgbe_set_fw_drv_ver_x550, \\\n\t.init_uta_tables\t\t= &ixgbe_init_uta_tables_generic, \\\n\t.set_mac_anti_spoofing\t\t= &ixgbe_set_mac_anti_spoofing, \\\n\t.set_vlan_anti_spoofing\t\t= &ixgbe_set_vlan_anti_spoofing, \\\n\t.set_source_address_pruning\t= \\\n\t\t\t\t&ixgbe_set_source_address_pruning_X550, \\\n\t.set_ethertype_anti_spoofing\t= \\\n\t\t\t\t&ixgbe_set_ethertype_anti_spoofing_X550, \\\n\t.disable_rx_buff\t\t= &ixgbe_disable_rx_buff_generic, \\\n\t.enable_rx_buff\t\t\t= &ixgbe_enable_rx_buff_generic, \\\n\t.get_thermal_sensor_data\t= NULL, \\\n\t.init_thermal_sensor_thresh\t= NULL, \\\n\t.fw_recovery_mode\t\t= &ixgbe_fw_recovery_mode_X550, \\\n\t.enable_rx\t\t\t= &ixgbe_enable_rx_generic, \\\n\t.disable_rx\t\t\t= &ixgbe_disable_rx_x550, \\\n\nstatic const struct ixgbe_mac_operations mac_ops_X550 = {\n\tX550_COMMON_MAC\n\t.led_on\t\t\t= ixgbe_led_on_generic,\n\t.led_off\t\t= ixgbe_led_off_generic,\n\t.init_led_link_act\t= ixgbe_init_led_link_act_generic,\n\t.reset_hw\t\t= &ixgbe_reset_hw_X540,\n\t.get_media_type\t\t= &ixgbe_get_media_type_X540,\n\t.get_san_mac_addr\t= &ixgbe_get_san_mac_addr_generic,\n\t.get_wwn_prefix\t\t= &ixgbe_get_wwn_prefix_generic,\n\t.setup_link\t\t= &ixgbe_setup_mac_link_X540,\n\t.get_link_capabilities\t= &ixgbe_get_copper_link_capabilities_generic,\n\t.get_bus_info\t\t= &ixgbe_get_bus_info_generic,\n\t.setup_sfp\t\t= NULL,\n\t.acquire_swfw_sync\t= &ixgbe_acquire_swfw_sync_X540,\n\t.release_swfw_sync\t= &ixgbe_release_swfw_sync_X540,\n\t.init_swfw_sync\t\t= &ixgbe_init_swfw_sync_X540,\n\t.prot_autoc_read\t= prot_autoc_read_generic,\n\t.prot_autoc_write\t= prot_autoc_write_generic,\n\t.setup_fc\t\t= ixgbe_setup_fc_generic,\n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n};\n\nstatic const struct ixgbe_mac_operations mac_ops_X550EM_x = {\n\tX550_COMMON_MAC\n\t.led_on\t\t\t= ixgbe_led_on_t_x550em,\n\t.led_off\t\t= ixgbe_led_off_t_x550em,\n\t.init_led_link_act\t= ixgbe_init_led_link_act_generic,\n\t.reset_hw\t\t= &ixgbe_reset_hw_X550em,\n\t.get_media_type\t\t= &ixgbe_get_media_type_X550em,\n\t.get_san_mac_addr\t= NULL,\n\t.get_wwn_prefix\t\t= NULL,\n\t.setup_link\t\t= &ixgbe_setup_mac_link_X540,\n\t.get_link_capabilities\t= &ixgbe_get_link_capabilities_X550em,\n\t.get_bus_info\t\t= &ixgbe_get_bus_info_X550em,\n\t.setup_sfp\t\t= ixgbe_setup_sfp_modules_X550em,\n\t.acquire_swfw_sync\t= &ixgbe_acquire_swfw_sync_X550em,\n\t.release_swfw_sync\t= &ixgbe_release_swfw_sync_X550em,\n\t.init_swfw_sync\t\t= &ixgbe_init_swfw_sync_X540,\n\t.setup_fc\t\t= NULL,  \n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n\t.read_iosf_sb_reg\t= ixgbe_read_iosf_sb_reg_x550,\n\t.write_iosf_sb_reg\t= ixgbe_write_iosf_sb_reg_x550,\n};\n\nstatic const struct ixgbe_mac_operations mac_ops_X550EM_x_fw = {\n\tX550_COMMON_MAC\n\t.led_on\t\t\t= NULL,\n\t.led_off\t\t= NULL,\n\t.init_led_link_act\t= NULL,\n\t.reset_hw\t\t= &ixgbe_reset_hw_X550em,\n\t.get_media_type\t\t= &ixgbe_get_media_type_X550em,\n\t.get_san_mac_addr\t= NULL,\n\t.get_wwn_prefix\t\t= NULL,\n\t.setup_link\t\t= &ixgbe_setup_mac_link_X540,\n\t.get_link_capabilities\t= &ixgbe_get_link_capabilities_X550em,\n\t.get_bus_info\t\t= &ixgbe_get_bus_info_X550em,\n\t.setup_sfp\t\t= ixgbe_setup_sfp_modules_X550em,\n\t.acquire_swfw_sync\t= &ixgbe_acquire_swfw_sync_X550em,\n\t.release_swfw_sync\t= &ixgbe_release_swfw_sync_X550em,\n\t.init_swfw_sync\t\t= &ixgbe_init_swfw_sync_X540,\n\t.setup_fc\t\t= NULL,\n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n\t.read_iosf_sb_reg\t= ixgbe_read_iosf_sb_reg_x550,\n\t.write_iosf_sb_reg\t= ixgbe_write_iosf_sb_reg_x550,\n};\n\nstatic const struct ixgbe_mac_operations mac_ops_x550em_a = {\n\tX550_COMMON_MAC\n\t.led_on\t\t\t= ixgbe_led_on_t_x550em,\n\t.led_off\t\t= ixgbe_led_off_t_x550em,\n\t.init_led_link_act\t= ixgbe_init_led_link_act_generic,\n\t.reset_hw\t\t= ixgbe_reset_hw_X550em,\n\t.get_media_type\t\t= ixgbe_get_media_type_X550em,\n\t.get_san_mac_addr\t= NULL,\n\t.get_wwn_prefix\t\t= NULL,\n\t.setup_link\t\t= &ixgbe_setup_mac_link_X540,\n\t.get_link_capabilities\t= ixgbe_get_link_capabilities_X550em,\n\t.get_bus_info\t\t= ixgbe_get_bus_info_X550em,\n\t.setup_sfp\t\t= ixgbe_setup_sfp_modules_X550em,\n\t.acquire_swfw_sync\t= ixgbe_acquire_swfw_sync_x550em_a,\n\t.release_swfw_sync\t= ixgbe_release_swfw_sync_x550em_a,\n\t.setup_fc\t\t= ixgbe_setup_fc_x550em,\n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n\t.read_iosf_sb_reg\t= ixgbe_read_iosf_sb_reg_x550a,\n\t.write_iosf_sb_reg\t= ixgbe_write_iosf_sb_reg_x550a,\n};\n\nstatic const struct ixgbe_mac_operations mac_ops_x550em_a_fw = {\n\tX550_COMMON_MAC\n\t.led_on\t\t\t= ixgbe_led_on_generic,\n\t.led_off\t\t= ixgbe_led_off_generic,\n\t.init_led_link_act\t= ixgbe_init_led_link_act_generic,\n\t.reset_hw\t\t= ixgbe_reset_hw_X550em,\n\t.get_media_type\t\t= ixgbe_get_media_type_X550em,\n\t.get_san_mac_addr\t= NULL,\n\t.get_wwn_prefix\t\t= NULL,\n\t.setup_link\t\t= NULL,  \n\t.get_link_capabilities\t= ixgbe_get_link_capabilities_X550em,\n\t.get_bus_info\t\t= ixgbe_get_bus_info_X550em,\n\t.setup_sfp\t\t= ixgbe_setup_sfp_modules_X550em,\n\t.acquire_swfw_sync\t= ixgbe_acquire_swfw_sync_x550em_a,\n\t.release_swfw_sync\t= ixgbe_release_swfw_sync_x550em_a,\n\t.setup_fc\t\t= ixgbe_setup_fc_x550em,\n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n\t.read_iosf_sb_reg\t= ixgbe_read_iosf_sb_reg_x550a,\n\t.write_iosf_sb_reg\t= ixgbe_write_iosf_sb_reg_x550a,\n};\n\n#define X550_COMMON_EEP \\\n\t.read\t\t\t= &ixgbe_read_ee_hostif_X550, \\\n\t.read_buffer\t\t= &ixgbe_read_ee_hostif_buffer_X550, \\\n\t.write\t\t\t= &ixgbe_write_ee_hostif_X550, \\\n\t.write_buffer\t\t= &ixgbe_write_ee_hostif_buffer_X550, \\\n\t.validate_checksum\t= &ixgbe_validate_eeprom_checksum_X550, \\\n\t.update_checksum\t= &ixgbe_update_eeprom_checksum_X550, \\\n\t.calc_checksum\t\t= &ixgbe_calc_eeprom_checksum_X550, \\\n\nstatic const struct ixgbe_eeprom_operations eeprom_ops_X550 = {\n\tX550_COMMON_EEP\n\t.init_params\t\t= &ixgbe_init_eeprom_params_X550,\n};\n\nstatic const struct ixgbe_eeprom_operations eeprom_ops_X550EM_x = {\n\tX550_COMMON_EEP\n\t.init_params\t\t= &ixgbe_init_eeprom_params_X540,\n};\n\n#define X550_COMMON_PHY\t\\\n\t.identify_sfp\t\t= &ixgbe_identify_module_generic, \\\n\t.reset\t\t\t= NULL, \\\n\t.setup_link_speed\t= &ixgbe_setup_phy_link_speed_generic, \\\n\t.read_i2c_byte\t\t= &ixgbe_read_i2c_byte_generic, \\\n\t.write_i2c_byte\t\t= &ixgbe_write_i2c_byte_generic, \\\n\t.read_i2c_sff8472\t= &ixgbe_read_i2c_sff8472_generic, \\\n\t.read_i2c_eeprom\t= &ixgbe_read_i2c_eeprom_generic, \\\n\t.write_i2c_eeprom\t= &ixgbe_write_i2c_eeprom_generic, \\\n\t.setup_link\t\t= &ixgbe_setup_phy_link_generic, \\\n\t.set_phy_power\t\t= NULL,\n\nstatic const struct ixgbe_phy_operations phy_ops_X550 = {\n\tX550_COMMON_PHY\n\t.check_overtemp\t\t= &ixgbe_tn_check_overtemp,\n\t.init\t\t\t= NULL,\n\t.identify\t\t= &ixgbe_identify_phy_generic,\n\t.read_reg\t\t= &ixgbe_read_phy_reg_generic,\n\t.write_reg\t\t= &ixgbe_write_phy_reg_generic,\n};\n\nstatic const struct ixgbe_phy_operations phy_ops_X550EM_x = {\n\tX550_COMMON_PHY\n\t.check_overtemp\t\t= &ixgbe_tn_check_overtemp,\n\t.init\t\t\t= &ixgbe_init_phy_ops_X550em,\n\t.identify\t\t= &ixgbe_identify_phy_x550em,\n\t.read_reg\t\t= &ixgbe_read_phy_reg_generic,\n\t.write_reg\t\t= &ixgbe_write_phy_reg_generic,\n};\n\nstatic const struct ixgbe_phy_operations phy_ops_x550em_x_fw = {\n\tX550_COMMON_PHY\n\t.check_overtemp\t\t= NULL,\n\t.init\t\t\t= ixgbe_init_phy_ops_X550em,\n\t.identify\t\t= ixgbe_identify_phy_x550em,\n\t.read_reg\t\t= NULL,\n\t.write_reg\t\t= NULL,\n\t.read_reg_mdi\t\t= NULL,\n\t.write_reg_mdi\t\t= NULL,\n};\n\nstatic const struct ixgbe_phy_operations phy_ops_x550em_a = {\n\tX550_COMMON_PHY\n\t.check_overtemp\t\t= &ixgbe_tn_check_overtemp,\n\t.init\t\t\t= &ixgbe_init_phy_ops_X550em,\n\t.identify\t\t= &ixgbe_identify_phy_x550em,\n\t.read_reg\t\t= &ixgbe_read_phy_reg_x550a,\n\t.write_reg\t\t= &ixgbe_write_phy_reg_x550a,\n\t.read_reg_mdi\t\t= &ixgbe_read_phy_reg_mdi,\n\t.write_reg_mdi\t\t= &ixgbe_write_phy_reg_mdi,\n};\n\nstatic const struct ixgbe_phy_operations phy_ops_x550em_a_fw = {\n\tX550_COMMON_PHY\n\t.check_overtemp\t\t= ixgbe_check_overtemp_fw,\n\t.init\t\t\t= ixgbe_init_phy_ops_X550em,\n\t.identify\t\t= ixgbe_identify_phy_fw,\n\t.read_reg\t\t= NULL,\n\t.write_reg\t\t= NULL,\n\t.read_reg_mdi\t\t= NULL,\n\t.write_reg_mdi\t\t= NULL,\n};\n\nstatic const struct ixgbe_link_operations link_ops_x550em_x = {\n\t.read_link\t\t= &ixgbe_read_i2c_combined_generic,\n\t.read_link_unlocked\t= &ixgbe_read_i2c_combined_generic_unlocked,\n\t.write_link\t\t= &ixgbe_write_i2c_combined_generic,\n\t.write_link_unlocked\t= &ixgbe_write_i2c_combined_generic_unlocked,\n};\n\nstatic const u32 ixgbe_mvals_X550[IXGBE_MVALS_IDX_LIMIT] = {\n\tIXGBE_MVALS_INIT(X550)\n};\n\nstatic const u32 ixgbe_mvals_X550EM_x[IXGBE_MVALS_IDX_LIMIT] = {\n\tIXGBE_MVALS_INIT(X550EM_x)\n};\n\nstatic const u32 ixgbe_mvals_x550em_a[IXGBE_MVALS_IDX_LIMIT] = {\n\tIXGBE_MVALS_INIT(X550EM_a)\n};\n\nconst struct ixgbe_info ixgbe_X550_info = {\n\t.mac\t\t\t= ixgbe_mac_X550,\n\t.get_invariants\t\t= &ixgbe_get_invariants_X540,\n\t.mac_ops\t\t= &mac_ops_X550,\n\t.eeprom_ops\t\t= &eeprom_ops_X550,\n\t.phy_ops\t\t= &phy_ops_X550,\n\t.mbx_ops\t\t= &mbx_ops_generic,\n\t.mvals\t\t\t= ixgbe_mvals_X550,\n};\n\nconst struct ixgbe_info ixgbe_X550EM_x_info = {\n\t.mac\t\t\t= ixgbe_mac_X550EM_x,\n\t.get_invariants\t\t= &ixgbe_get_invariants_X550_x,\n\t.mac_ops\t\t= &mac_ops_X550EM_x,\n\t.eeprom_ops\t\t= &eeprom_ops_X550EM_x,\n\t.phy_ops\t\t= &phy_ops_X550EM_x,\n\t.mbx_ops\t\t= &mbx_ops_generic,\n\t.mvals\t\t\t= ixgbe_mvals_X550EM_x,\n\t.link_ops\t\t= &link_ops_x550em_x,\n};\n\nconst struct ixgbe_info ixgbe_x550em_x_fw_info = {\n\t.mac\t\t\t= ixgbe_mac_X550EM_x,\n\t.get_invariants\t\t= ixgbe_get_invariants_X550_x_fw,\n\t.mac_ops\t\t= &mac_ops_X550EM_x_fw,\n\t.eeprom_ops\t\t= &eeprom_ops_X550EM_x,\n\t.phy_ops\t\t= &phy_ops_x550em_x_fw,\n\t.mbx_ops\t\t= &mbx_ops_generic,\n\t.mvals\t\t\t= ixgbe_mvals_X550EM_x,\n};\n\nconst struct ixgbe_info ixgbe_x550em_a_info = {\n\t.mac\t\t\t= ixgbe_mac_x550em_a,\n\t.get_invariants\t\t= &ixgbe_get_invariants_X550_a,\n\t.mac_ops\t\t= &mac_ops_x550em_a,\n\t.eeprom_ops\t\t= &eeprom_ops_X550EM_x,\n\t.phy_ops\t\t= &phy_ops_x550em_a,\n\t.mbx_ops\t\t= &mbx_ops_generic,\n\t.mvals\t\t\t= ixgbe_mvals_x550em_a,\n};\n\nconst struct ixgbe_info ixgbe_x550em_a_fw_info = {\n\t.mac\t\t\t= ixgbe_mac_x550em_a,\n\t.get_invariants\t\t= ixgbe_get_invariants_X550_a_fw,\n\t.mac_ops\t\t= &mac_ops_x550em_a_fw,\n\t.eeprom_ops\t\t= &eeprom_ops_X550EM_x,\n\t.phy_ops\t\t= &phy_ops_x550em_a_fw,\n\t.mbx_ops\t\t= &mbx_ops_generic,\n\t.mvals\t\t\t= ixgbe_mvals_x550em_a,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}