{
  "module_name": "ixgbe_82599.c",
  "hash_id": "118485a8c2212e79f0b3e5291171f1359b5cccd85f0a64f8073e3b3f872ce03d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n\n#include \"ixgbe.h\"\n#include \"ixgbe_phy.h\"\n#include \"ixgbe_mbx.h\"\n\n#define IXGBE_82599_MAX_TX_QUEUES 128\n#define IXGBE_82599_MAX_RX_QUEUES 128\n#define IXGBE_82599_RAR_ENTRIES   128\n#define IXGBE_82599_MC_TBL_SIZE   128\n#define IXGBE_82599_VFT_TBL_SIZE  128\n#define IXGBE_82599_RX_PB_SIZE\t  512\n\nstatic void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);\nstatic void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);\nstatic void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);\nstatic void\nixgbe_set_hard_rate_select_speed(struct ixgbe_hw *, ixgbe_link_speed);\nstatic s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,\n\t\t\t\t\t   ixgbe_link_speed speed,\n\t\t\t\t\t   bool autoneg_wait_to_complete);\nstatic void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw);\nstatic s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,\n\t\t\t\t      bool autoneg_wait_to_complete);\nstatic s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,\n\t\t\t       ixgbe_link_speed speed,\n\t\t\t       bool autoneg_wait_to_complete);\nstatic s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,\n\t\t\t\t\t ixgbe_link_speed speed,\n\t\t\t\t\t bool autoneg_wait_to_complete);\nstatic s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw);\nstatic s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t     u8 dev_addr, u8 *data);\nstatic s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t      u8 dev_addr, u8 data);\nstatic s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw);\nstatic bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw);\n\nbool ixgbe_mng_enabled(struct ixgbe_hw *hw)\n{\n\tu32 fwsm, manc, factps;\n\n\tfwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));\n\tif ((fwsm & IXGBE_FWSM_MODE_MASK) != IXGBE_FWSM_FW_MODE_PT)\n\t\treturn false;\n\n\tmanc = IXGBE_READ_REG(hw, IXGBE_MANC);\n\tif (!(manc & IXGBE_MANC_RCV_TCO_EN))\n\t\treturn false;\n\n\tfactps = IXGBE_READ_REG(hw, IXGBE_FACTPS(hw));\n\tif (factps & IXGBE_FACTPS_MNGCG)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\n\t \n\tif ((mac->ops.get_media_type(hw) == ixgbe_media_type_fiber) &&\n\t    !ixgbe_mng_enabled(hw)) {\n\t\tmac->ops.disable_tx_laser =\n\t\t\t\t       &ixgbe_disable_tx_laser_multispeed_fiber;\n\t\tmac->ops.enable_tx_laser =\n\t\t\t\t\t&ixgbe_enable_tx_laser_multispeed_fiber;\n\t\tmac->ops.flap_tx_laser = &ixgbe_flap_tx_laser_multispeed_fiber;\n\t} else {\n\t\tmac->ops.disable_tx_laser = NULL;\n\t\tmac->ops.enable_tx_laser = NULL;\n\t\tmac->ops.flap_tx_laser = NULL;\n\t}\n\n\tif (hw->phy.multispeed_fiber) {\n\t\t \n\t\tmac->ops.setup_link = &ixgbe_setup_mac_link_multispeed_fiber;\n\t\tmac->ops.setup_mac_link = ixgbe_setup_mac_link_82599;\n\t\tmac->ops.set_rate_select_speed =\n\t\t\t\t\t       ixgbe_set_hard_rate_select_speed;\n\t} else {\n\t\tif ((mac->ops.get_media_type(hw) ==\n\t\t     ixgbe_media_type_backplane) &&\n\t\t    (hw->phy.smart_speed == ixgbe_smart_speed_auto ||\n\t\t     hw->phy.smart_speed == ixgbe_smart_speed_on) &&\n\t\t     !ixgbe_verify_lesm_fw_enabled_82599(hw))\n\t\t\tmac->ops.setup_link = &ixgbe_setup_mac_link_smartspeed;\n\t\telse\n\t\t\tmac->ops.setup_link = &ixgbe_setup_mac_link_82599;\n\t}\n}\n\nstatic s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)\n{\n\ts32 ret_val;\n\tu16 list_offset, data_offset, data_value;\n\n\tif (hw->phy.sfp_type != ixgbe_sfp_type_unknown) {\n\t\tixgbe_init_mac_link_ops_82599(hw);\n\n\t\thw->phy.ops.reset = NULL;\n\n\t\tret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,\n\t\t\t\t\t\t\t      &data_offset);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tret_val = hw->mac.ops.acquire_swfw_sync(hw,\n\t\t\t\t\t\t\tIXGBE_GSSR_MAC_CSR_SM);\n\t\tif (ret_val)\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\t\tif (hw->eeprom.ops.read(hw, ++data_offset, &data_value))\n\t\t\tgoto setup_sfp_err;\n\t\twhile (data_value != 0xffff) {\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_CORECTL, data_value);\n\t\t\tIXGBE_WRITE_FLUSH(hw);\n\t\t\tif (hw->eeprom.ops.read(hw, ++data_offset, &data_value))\n\t\t\t\tgoto setup_sfp_err;\n\t\t}\n\n\t\t \n\t\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\n\t\t \n\t\tusleep_range(hw->eeprom.semaphore_delay * 1000,\n\t\t\t     hw->eeprom.semaphore_delay * 2000);\n\n\t\t \n\t\tret_val = hw->mac.ops.prot_autoc_write(hw,\n\t\t\thw->mac.orig_autoc | IXGBE_AUTOC_LMS_10G_SERIAL,\n\t\t\tfalse);\n\n\t\tif (ret_val) {\n\t\t\thw_dbg(hw, \" sfp module setup not complete\\n\");\n\t\t\treturn IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;\n\t\t}\n\t}\n\n\treturn 0;\n\nsetup_sfp_err:\n\t \n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\n\t \n\tusleep_range(hw->eeprom.semaphore_delay * 1000,\n\t\t     hw->eeprom.semaphore_delay * 2000);\n\thw_err(hw, \"eeprom read at offset %d failed\\n\", data_offset);\n\treturn IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;\n}\n\n \nstatic s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked,\n\t\t\t\t u32 *reg_val)\n{\n\ts32 ret_val;\n\n\t*locked = false;\n\t \n\tif (ixgbe_verify_lesm_fw_enabled_82599(hw)) {\n\t\tret_val = hw->mac.ops.acquire_swfw_sync(hw,\n\t\t\t\t\tIXGBE_GSSR_MAC_CSR_SM);\n\t\tif (ret_val)\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\t\t*locked = true;\n\t}\n\n\t*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\treturn 0;\n}\n\n \nstatic s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)\n{\n\ts32 ret_val = 0;\n\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\tgoto out;\n\n\t \n\tif (!locked && ixgbe_verify_lesm_fw_enabled_82599(hw)) {\n\t\tret_val = hw->mac.ops.acquire_swfw_sync(hw,\n\t\t\t\t\tIXGBE_GSSR_MAC_CSR_SM);\n\t\tif (ret_val)\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\t\tlocked = true;\n\t}\n\n\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);\n\tret_val = ixgbe_reset_pipeline_82599(hw);\n\nout:\n\t \n\tif (locked)\n\t\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\n\n\treturn ret_val;\n}\n\nstatic s32 ixgbe_get_invariants_82599(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\n\tixgbe_init_mac_link_ops_82599(hw);\n\n\tmac->mcft_size = IXGBE_82599_MC_TBL_SIZE;\n\tmac->vft_size = IXGBE_82599_VFT_TBL_SIZE;\n\tmac->num_rar_entries = IXGBE_82599_RAR_ENTRIES;\n\tmac->rx_pb_size = IXGBE_82599_RX_PB_SIZE;\n\tmac->max_rx_queues = IXGBE_82599_MAX_RX_QUEUES;\n\tmac->max_tx_queues = IXGBE_82599_MAX_TX_QUEUES;\n\tmac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu32 esdp;\n\n\tif (hw->device_id == IXGBE_DEV_ID_82599_QSFP_SF_QP) {\n\t\t \n\t\thw->phy.qsfp_shared_i2c_bus = true;\n\n\t\t \n\t\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\t\tesdp |= IXGBE_ESDP_SDP0_DIR;\n\t\tesdp &= ~IXGBE_ESDP_SDP1_DIR;\n\t\tesdp &= ~IXGBE_ESDP_SDP0;\n\t\tesdp &= ~IXGBE_ESDP_SDP0_NATIVE;\n\t\tesdp &= ~IXGBE_ESDP_SDP1_NATIVE;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\n\t\tphy->ops.read_i2c_byte = &ixgbe_read_i2c_byte_82599;\n\t\tphy->ops.write_i2c_byte = &ixgbe_write_i2c_byte_82599;\n\t}\n\n\t \n\tret_val = phy->ops.identify(hw);\n\n\t \n\tixgbe_init_mac_link_ops_82599(hw);\n\n\t \n\tif (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {\n\t\tmac->ops.setup_link = &ixgbe_setup_copper_link_82599;\n\t\tmac->ops.get_link_capabilities =\n\t\t\t&ixgbe_get_copper_link_capabilities_generic;\n\t}\n\n\t \n\tswitch (hw->phy.type) {\n\tcase ixgbe_phy_tn:\n\t\tphy->ops.check_link = &ixgbe_check_phy_link_tnx;\n\t\tphy->ops.setup_link = &ixgbe_setup_phy_link_tnx;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,\n\t\t\t\t\t     ixgbe_link_speed *speed,\n\t\t\t\t\t     bool *autoneg)\n{\n\tu32 autoc = 0;\n\n\t \n\tif (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||\n\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||\n\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\n\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||\n\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||\n\t    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1) {\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = true;\n\t\treturn 0;\n\t}\n\n\t \n\tif (hw->mac.orig_link_settings_stored)\n\t\tautoc = hw->mac.orig_autoc;\n\telse\n\t\tautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\n\tswitch (autoc & IXGBE_AUTOC_LMS_MASK) {\n\tcase IXGBE_AUTOC_LMS_1G_LINK_NO_AN:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = false;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_10G_LINK_NO_AN:\n\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t\t*autoneg = false;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_1G_AN:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = true;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_10G_SERIAL:\n\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t\t*autoneg = false;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_KX4_KX_KR:\n\tcase IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN:\n\t\t*speed = IXGBE_LINK_SPEED_UNKNOWN;\n\t\tif (autoc & IXGBE_AUTOC_KR_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_10GB_FULL;\n\t\tif (autoc & IXGBE_AUTOC_KX4_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_10GB_FULL;\n\t\tif (autoc & IXGBE_AUTOC_KX_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = true;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII:\n\t\t*speed = IXGBE_LINK_SPEED_100_FULL;\n\t\tif (autoc & IXGBE_AUTOC_KR_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_10GB_FULL;\n\t\tif (autoc & IXGBE_AUTOC_KX4_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_10GB_FULL;\n\t\tif (autoc & IXGBE_AUTOC_KX_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = true;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_SGMII_1G_100M:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL | IXGBE_LINK_SPEED_100_FULL;\n\t\t*autoneg = false;\n\t\tbreak;\n\n\tdefault:\n\t\treturn IXGBE_ERR_LINK_SETUP;\n\t}\n\n\tif (hw->phy.multispeed_fiber) {\n\t\t*speed |= IXGBE_LINK_SPEED_10GB_FULL |\n\t\t\t  IXGBE_LINK_SPEED_1GB_FULL;\n\n\t\t \n\t\tif (hw->phy.media_type == ixgbe_media_type_fiber_qsfp)\n\t\t\t*autoneg = false;\n\t\telse\n\t\t\t*autoneg = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)\n{\n\t \n\tswitch (hw->phy.type) {\n\tcase ixgbe_phy_cu_unknown:\n\tcase ixgbe_phy_tn:\n\t\treturn ixgbe_media_type_copper;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_82599_KX4:\n\tcase IXGBE_DEV_ID_82599_KX4_MEZZ:\n\tcase IXGBE_DEV_ID_82599_COMBO_BACKPLANE:\n\tcase IXGBE_DEV_ID_82599_KR:\n\tcase IXGBE_DEV_ID_82599_BACKPLANE_FCOE:\n\tcase IXGBE_DEV_ID_82599_XAUI_LOM:\n\t\t \n\t\treturn ixgbe_media_type_backplane;\n\n\tcase IXGBE_DEV_ID_82599_SFP:\n\tcase IXGBE_DEV_ID_82599_SFP_FCOE:\n\tcase IXGBE_DEV_ID_82599_SFP_EM:\n\tcase IXGBE_DEV_ID_82599_SFP_SF2:\n\tcase IXGBE_DEV_ID_82599_SFP_SF_QP:\n\tcase IXGBE_DEV_ID_82599EN_SFP:\n\t\treturn ixgbe_media_type_fiber;\n\n\tcase IXGBE_DEV_ID_82599_CX4:\n\t\treturn ixgbe_media_type_cx4;\n\n\tcase IXGBE_DEV_ID_82599_T3_LOM:\n\t\treturn ixgbe_media_type_copper;\n\n\tcase IXGBE_DEV_ID_82599_LS:\n\t\treturn ixgbe_media_type_fiber_lco;\n\n\tcase IXGBE_DEV_ID_82599_QSFP_SF_QP:\n\t\treturn ixgbe_media_type_fiber_qsfp;\n\n\tdefault:\n\t\treturn ixgbe_media_type_unknown;\n\t}\n}\n\n \nstatic void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)\n{\n\tu32 autoc2_reg;\n\tu16 ee_ctrl_2 = 0;\n\n\thw->eeprom.ops.read(hw, IXGBE_EEPROM_CTRL_2, &ee_ctrl_2);\n\n\tif (!ixgbe_mng_present(hw) && !hw->wol_enabled &&\n\t    ee_ctrl_2 & IXGBE_EEPROM_CCD_BIT) {\n\t\tautoc2_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\n\t\tautoc2_reg |= IXGBE_AUTOC2_LINK_DISABLE_ON_D3_MASK;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2_reg);\n\t}\n}\n\n \nstatic s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,\n\t\t\t       bool autoneg_wait_to_complete)\n{\n\tu32 autoc_reg;\n\tu32 links_reg;\n\tu32 i;\n\ts32 status = 0;\n\tbool got_lock = false;\n\n\tif (ixgbe_verify_lesm_fw_enabled_82599(hw)) {\n\t\tstatus = hw->mac.ops.acquire_swfw_sync(hw,\n\t\t\t\t\t\tIXGBE_GSSR_MAC_CSR_SM);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tgot_lock = true;\n\t}\n\n\t \n\tixgbe_reset_pipeline_82599(hw);\n\n\tif (got_lock)\n\t\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\n\n\t \n\tif (autoneg_wait_to_complete) {\n\t\tautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\t\tif ((autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\n\t\t     IXGBE_AUTOC_LMS_KX4_KX_KR ||\n\t\t    (autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\n\t\t     IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||\n\t\t    (autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\n\t\t     IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {\n\t\t\tlinks_reg = 0;  \n\t\t\tfor (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {\n\t\t\t\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\t\t\t\tif (links_reg & IXGBE_LINKS_KX_AN_COMP)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(100);\n\t\t\t}\n\t\t\tif (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {\n\t\t\t\tstatus = IXGBE_ERR_AUTONEG_NOT_COMPLETE;\n\t\t\t\thw_dbg(hw, \"Autoneg did not complete.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmsleep(50);\n\n\treturn status;\n}\n\n \nstatic void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)\n{\n\tu32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn;\n\n\t \n\tesdp_reg |= IXGBE_ESDP_SDP3;\n\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(100);\n}\n\n \nstatic void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)\n{\n\tu32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\n\t \n\tesdp_reg &= ~IXGBE_ESDP_SDP3;\n\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\tmsleep(100);\n}\n\n \nstatic void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)\n{\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn;\n\n\tif (hw->mac.autotry_restart) {\n\t\tixgbe_disable_tx_laser_multispeed_fiber(hw);\n\t\tixgbe_enable_tx_laser_multispeed_fiber(hw);\n\t\thw->mac.autotry_restart = false;\n\t}\n}\n\n \nstatic void\nixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed)\n{\n\tu32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\n\tswitch (speed) {\n\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\t\tesdp_reg |= (IXGBE_ESDP_SDP5_DIR | IXGBE_ESDP_SDP5);\n\t\tbreak;\n\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\tesdp_reg &= ~IXGBE_ESDP_SDP5;\n\t\tesdp_reg |= IXGBE_ESDP_SDP5_DIR;\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \"Invalid fixed module speed\\n\");\n\t\treturn;\n\t}\n\n\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,\n\t\t\t\t     ixgbe_link_speed speed,\n\t\t\t\t     bool autoneg_wait_to_complete)\n{\n\ts32 status = 0;\n\tixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;\n\ts32 i, j;\n\tbool link_up = false;\n\tu32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\n\t  \n\thw->phy.autoneg_advertised = 0;\n\n\tif (speed & IXGBE_LINK_SPEED_10GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_1GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_100_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_100_FULL;\n\n\t \n\n\t \n\thw->phy.smart_speed_active = false;\n\tfor (j = 0; j < IXGBE_SMARTSPEED_MAX_RETRIES; j++) {\n\t\tstatus = ixgbe_setup_mac_link_82599(hw, speed,\n\t\t\t\t\t\t    autoneg_wait_to_complete);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tmdelay(100);\n\n\t\t\t \n\t\t\tstatus = hw->mac.ops.check_link(hw, &link_speed,\n\t\t\t\t\t\t\t&link_up, false);\n\t\t\tif (status != 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (link_up)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (((autoc_reg & IXGBE_AUTOC_KR_SUPP) == 0) ||\n\t    ((autoc_reg & IXGBE_AUTOC_KX4_KX_SUPP_MASK) == 0))\n\t\tgoto out;\n\n\t \n\thw->phy.smart_speed_active = true;\n\tstatus = ixgbe_setup_mac_link_82599(hw, speed,\n\t\t\t\t\t    autoneg_wait_to_complete);\n\tif (status != 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tmdelay(100);\n\n\t\t \n\t\tstatus = hw->mac.ops.check_link(hw, &link_speed,\n\t\t\t\t\t\t&link_up, false);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\n\t\tif (link_up)\n\t\t\tgoto out;\n\t}\n\n\t \n\thw->phy.smart_speed_active = false;\n\tstatus = ixgbe_setup_mac_link_82599(hw, speed,\n\t\t\t\t\t    autoneg_wait_to_complete);\n\nout:\n\tif (link_up && (link_speed == IXGBE_LINK_SPEED_1GB_FULL))\n\t\thw_dbg(hw, \"Smartspeed has downgraded the link speed from the maximum advertised\\n\");\n\treturn status;\n}\n\n \nstatic s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,\n\t\t\t\t      ixgbe_link_speed speed,\n\t\t\t\t      bool autoneg_wait_to_complete)\n{\n\tbool autoneg = false;\n\ts32 status;\n\tu32 pma_pmd_1g, link_mode, links_reg, i;\n\tu32 autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\n\tu32 pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;\n\tixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;\n\n\t \n\tu32 current_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\t \n\tu32 orig_autoc = 0;\n\t \n\tu32 autoc = current_autoc;\n\n\t \n\tstatus = hw->mac.ops.get_link_capabilities(hw, &link_capabilities,\n\t\t\t\t\t\t   &autoneg);\n\tif (status)\n\t\treturn status;\n\n\tspeed &= link_capabilities;\n\n\tif (speed == IXGBE_LINK_SPEED_UNKNOWN)\n\t\treturn IXGBE_ERR_LINK_SETUP;\n\n\t \n\tif (hw->mac.orig_link_settings_stored)\n\t\torig_autoc = hw->mac.orig_autoc;\n\telse\n\t\torig_autoc = autoc;\n\n\tlink_mode = autoc & IXGBE_AUTOC_LMS_MASK;\n\tpma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;\n\n\tif (link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR ||\n\t    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||\n\t    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {\n\t\t \n\t\tautoc &= ~(IXGBE_AUTOC_KX4_KX_SUPP_MASK | IXGBE_AUTOC_KR_SUPP);\n\t\tif (speed & IXGBE_LINK_SPEED_10GB_FULL) {\n\t\t\tif (orig_autoc & IXGBE_AUTOC_KX4_SUPP)\n\t\t\t\tautoc |= IXGBE_AUTOC_KX4_SUPP;\n\t\t\tif ((orig_autoc & IXGBE_AUTOC_KR_SUPP) &&\n\t\t\t    (hw->phy.smart_speed_active == false))\n\t\t\t\tautoc |= IXGBE_AUTOC_KR_SUPP;\n\t\t}\n\t\tif (speed & IXGBE_LINK_SPEED_1GB_FULL)\n\t\t\tautoc |= IXGBE_AUTOC_KX_SUPP;\n\t} else if ((pma_pmd_1g == IXGBE_AUTOC_1G_SFI) &&\n\t\t   (link_mode == IXGBE_AUTOC_LMS_1G_LINK_NO_AN ||\n\t\t    link_mode == IXGBE_AUTOC_LMS_1G_AN)) {\n\t\t \n\t\tif ((speed == IXGBE_LINK_SPEED_10GB_FULL) &&\n\t\t    (pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI)) {\n\t\t\tautoc &= ~IXGBE_AUTOC_LMS_MASK;\n\t\t\tautoc |= IXGBE_AUTOC_LMS_10G_SERIAL;\n\t\t}\n\t} else if ((pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI) &&\n\t\t   (link_mode == IXGBE_AUTOC_LMS_10G_SERIAL)) {\n\t\t \n\t\tif ((speed == IXGBE_LINK_SPEED_1GB_FULL) &&\n\t\t    (pma_pmd_1g == IXGBE_AUTOC_1G_SFI)) {\n\t\t\tautoc &= ~IXGBE_AUTOC_LMS_MASK;\n\t\t\tif (autoneg)\n\t\t\t\tautoc |= IXGBE_AUTOC_LMS_1G_AN;\n\t\t\telse\n\t\t\t\tautoc |= IXGBE_AUTOC_LMS_1G_LINK_NO_AN;\n\t\t}\n\t}\n\n\tif (autoc != current_autoc) {\n\t\t \n\t\tstatus = hw->mac.ops.prot_autoc_write(hw, autoc, false);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\t \n\t\tif (autoneg_wait_to_complete) {\n\t\t\tif (link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR ||\n\t\t\t    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||\n\t\t\t    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {\n\t\t\t\tlinks_reg = 0;  \n\t\t\t\tfor (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {\n\t\t\t\t\tlinks_reg =\n\t\t\t\t\t       IXGBE_READ_REG(hw, IXGBE_LINKS);\n\t\t\t\t\tif (links_reg & IXGBE_LINKS_KX_AN_COMP)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmsleep(100);\n\t\t\t\t}\n\t\t\t\tif (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t\tIXGBE_ERR_AUTONEG_NOT_COMPLETE;\n\t\t\t\t\thw_dbg(hw, \"Autoneg did not complete.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmsleep(50);\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,\n\t\t\t\t\t ixgbe_link_speed speed,\n\t\t\t\t\t bool autoneg_wait_to_complete)\n{\n\ts32 status;\n\n\t \n\tstatus = hw->phy.ops.setup_link_speed(hw, speed,\n\t\t\t\t\t      autoneg_wait_to_complete);\n\t \n\tixgbe_start_mac_link_82599(hw, autoneg_wait_to_complete);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)\n{\n\tixgbe_link_speed link_speed;\n\ts32 status;\n\tu32 ctrl, i, autoc, autoc2;\n\tu32 curr_lms;\n\tbool link_up = false;\n\n\t \n\tstatus = hw->mac.ops.stop_adapter(hw);\n\tif (status)\n\t\treturn status;\n\n\t \n\tixgbe_clear_tx_pending(hw);\n\n\t \n\n\t \n\tstatus = hw->phy.ops.init(hw);\n\n\tif (status == IXGBE_ERR_SFP_NOT_SUPPORTED)\n\t\treturn status;\n\n\t \n\tif (hw->phy.sfp_setup_needed) {\n\t\tstatus = hw->mac.ops.setup_sfp(hw);\n\t\thw->phy.sfp_setup_needed = false;\n\t}\n\n\tif (status == IXGBE_ERR_SFP_NOT_SUPPORTED)\n\t\treturn status;\n\n\t \n\tif (hw->phy.reset_disable == false && hw->phy.ops.reset != NULL)\n\t\thw->phy.ops.reset(hw);\n\n\t \n\tcurr_lms = IXGBE_READ_REG(hw, IXGBE_AUTOC) & IXGBE_AUTOC_LMS_MASK;\n\nmac_reset_top:\n\t \n\tctrl = IXGBE_CTRL_LNK_RST;\n\tif (!hw->force_full_reset) {\n\t\thw->mac.ops.check_link(hw, &link_speed, &link_up, false);\n\t\tif (link_up)\n\t\t\tctrl = IXGBE_CTRL_RST;\n\t}\n\n\tctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);\n\tIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\n\tIXGBE_WRITE_FLUSH(hw);\n\tusleep_range(1000, 1200);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\n\t\tif (!(ctrl & IXGBE_CTRL_RST_MASK))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (ctrl & IXGBE_CTRL_RST_MASK) {\n\t\tstatus = IXGBE_ERR_RESET_FAILED;\n\t\thw_dbg(hw, \"Reset polling failed to complete.\\n\");\n\t}\n\n\tmsleep(50);\n\n\t \n\tif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\n\t\thw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\n\t\tgoto mac_reset_top;\n\t}\n\n\t \n\tautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tautoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\n\n\t \n\tif (autoc2 & IXGBE_AUTOC2_LINK_DISABLE_MASK) {\n\t\tautoc2 &= ~IXGBE_AUTOC2_LINK_DISABLE_MASK;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n\n\tif (hw->mac.orig_link_settings_stored == false) {\n\t\thw->mac.orig_autoc = autoc;\n\t\thw->mac.orig_autoc2 = autoc2;\n\t\thw->mac.orig_link_settings_stored = true;\n\t} else {\n\n\t\t \n\t\tif ((hw->phy.multispeed_fiber && ixgbe_mng_enabled(hw)) ||\n\t\t    hw->wol_enabled)\n\t\t\thw->mac.orig_autoc =\n\t\t\t\t(hw->mac.orig_autoc & ~IXGBE_AUTOC_LMS_MASK) |\n\t\t\t\tcurr_lms;\n\n\t\tif (autoc != hw->mac.orig_autoc) {\n\t\t\tstatus = hw->mac.ops.prot_autoc_write(hw,\n\t\t\t\t\t\t\thw->mac.orig_autoc,\n\t\t\t\t\t\t\tfalse);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\n\t\tif ((autoc2 & IXGBE_AUTOC2_UPPER_MASK) !=\n\t\t    (hw->mac.orig_autoc2 & IXGBE_AUTOC2_UPPER_MASK)) {\n\t\t\tautoc2 &= ~IXGBE_AUTOC2_UPPER_MASK;\n\t\t\tautoc2 |= (hw->mac.orig_autoc2 &\n\t\t\t\t   IXGBE_AUTOC2_UPPER_MASK);\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2);\n\t\t}\n\t}\n\n\t \n\thw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\n\n\t \n\thw->mac.num_rar_entries = IXGBE_82599_RAR_ENTRIES;\n\thw->mac.ops.init_rx_addrs(hw);\n\n\t \n\thw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);\n\n\t \n\tif (is_valid_ether_addr(hw->mac.san_addr)) {\n\t\t \n\t\thw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;\n\n\t\thw->mac.ops.set_rar(hw, hw->mac.san_mac_rar_index,\n\t\t\t\t    hw->mac.san_addr, 0, IXGBE_RAH_AV);\n\n\t\t \n\t\thw->mac.ops.clear_vmdq(hw, hw->mac.san_mac_rar_index,\n\t\t\t\t       IXGBE_CLEAR_VMDQ_ALL);\n\n\t\t \n\t\thw->mac.num_rar_entries--;\n\t}\n\n\t \n\thw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,\n\t\t\t\t       &hw->mac.wwpn_prefix);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_fdir_check_cmd_complete(struct ixgbe_hw *hw, u32 *fdircmd)\n{\n\tint i;\n\n\tfor (i = 0; i < IXGBE_FDIRCMD_CMD_POLL; i++) {\n\t\t*fdircmd = IXGBE_READ_REG(hw, IXGBE_FDIRCMD);\n\t\tif (!(*fdircmd & IXGBE_FDIRCMD_CMD_MASK))\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\n\treturn IXGBE_ERR_FDIR_CMD_INCOMPLETE;\n}\n\n \ns32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)\n{\n\tint i;\n\tu32 fdirctrl = IXGBE_READ_REG(hw, IXGBE_FDIRCTRL);\n\tu32 fdircmd;\n\ts32 err;\n\n\tfdirctrl &= ~IXGBE_FDIRCTRL_INIT_DONE;\n\n\t \n\terr = ixgbe_fdir_check_cmd_complete(hw, &fdircmd);\n\tif (err) {\n\t\thw_dbg(hw, \"Flow Director previous command did not complete, aborting table re-initialization.\\n\");\n\t\treturn err;\n\t}\n\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRFREE, 0);\n\tIXGBE_WRITE_FLUSH(hw);\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,\n\t\t\t(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) |\n\t\t\t IXGBE_FDIRCMD_CLEARHT));\n\tIXGBE_WRITE_FLUSH(hw);\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,\n\t\t\t(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) &\n\t\t\t ~IXGBE_FDIRCMD_CLEARHT));\n\tIXGBE_WRITE_FLUSH(hw);\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, 0x00);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRCTRL, fdirctrl);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tfor (i = 0; i < IXGBE_FDIR_INIT_DONE_POLL; i++) {\n\t\tif (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &\n\t\t\t\t   IXGBE_FDIRCTRL_INIT_DONE)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (i >= IXGBE_FDIR_INIT_DONE_POLL) {\n\t\thw_dbg(hw, \"Flow Director Signature poll time exceeded!\\n\");\n\t\treturn IXGBE_ERR_FDIR_REINIT_FAILED;\n\t}\n\n\t \n\tIXGBE_READ_REG(hw, IXGBE_FDIRUSTAT);\n\tIXGBE_READ_REG(hw, IXGBE_FDIRFSTAT);\n\tIXGBE_READ_REG(hw, IXGBE_FDIRMATCH);\n\tIXGBE_READ_REG(hw, IXGBE_FDIRMISS);\n\tIXGBE_READ_REG(hw, IXGBE_FDIRLEN);\n\n\treturn 0;\n}\n\n \nstatic void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)\n{\n\tint i;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRHKEY, IXGBE_ATR_BUCKET_HASH_KEY);\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRSKEY, IXGBE_ATR_SIGNATURE_HASH_KEY);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRCTRL, fdirctrl);\n\tIXGBE_WRITE_FLUSH(hw);\n\tfor (i = 0; i < IXGBE_FDIR_INIT_DONE_POLL; i++) {\n\t\tif (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &\n\t\t\t\t   IXGBE_FDIRCTRL_INIT_DONE)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (i >= IXGBE_FDIR_INIT_DONE_POLL)\n\t\thw_dbg(hw, \"Flow Director poll time exceeded!\\n\");\n}\n\n \ns32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl)\n{\n\t \n\tfdirctrl |= (0x6 << IXGBE_FDIRCTRL_FLEX_SHIFT) |\n\t\t    (0xA << IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT) |\n\t\t    (4 << IXGBE_FDIRCTRL_FULL_THRESH_SHIFT);\n\n\t \n\tixgbe_fdir_enable_82599(hw, fdirctrl);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl)\n{\n\t \n\tfdirctrl |= IXGBE_FDIRCTRL_PERFECT_MATCH |\n\t\t    (IXGBE_FDIR_DROP_QUEUE << IXGBE_FDIRCTRL_DROP_Q_SHIFT) |\n\t\t    (0x6 << IXGBE_FDIRCTRL_FLEX_SHIFT) |\n\t\t    (0xA << IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT) |\n\t\t    (4 << IXGBE_FDIRCTRL_FULL_THRESH_SHIFT);\n\n\t \n\tixgbe_fdir_enable_82599(hw, fdirctrl);\n\n\treturn 0;\n}\n\n \n#define IXGBE_ATR_COMMON_HASH_KEY \\\n\t\t(IXGBE_ATR_BUCKET_HASH_KEY & IXGBE_ATR_SIGNATURE_HASH_KEY)\n#define IXGBE_COMPUTE_SIG_HASH_ITERATION(_n) \\\ndo { \\\n\tu32 n = (_n); \\\n\tif (IXGBE_ATR_COMMON_HASH_KEY & BIT(n)) \\\n\t\tcommon_hash ^= lo_hash_dword >> n; \\\n\telse if (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n)) \\\n\t\tbucket_hash ^= lo_hash_dword >> n; \\\n\telse if (IXGBE_ATR_SIGNATURE_HASH_KEY & BIT(n)) \\\n\t\tsig_hash ^= lo_hash_dword << (16 - n); \\\n\tif (IXGBE_ATR_COMMON_HASH_KEY & BIT(n + 16)) \\\n\t\tcommon_hash ^= hi_hash_dword >> n; \\\n\telse if (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n + 16)) \\\n\t\tbucket_hash ^= hi_hash_dword >> n; \\\n\telse if (IXGBE_ATR_SIGNATURE_HASH_KEY & BIT(n + 16)) \\\n\t\tsig_hash ^= hi_hash_dword << (16 - n); \\\n} while (0)\n\n \nstatic u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,\n\t\t\t\t\t    union ixgbe_atr_hash_dword common)\n{\n\tu32 hi_hash_dword, lo_hash_dword, flow_vm_vlan;\n\tu32 sig_hash = 0, bucket_hash = 0, common_hash = 0;\n\n\t \n\tflow_vm_vlan = ntohl(input.dword);\n\n\t \n\thi_hash_dword = ntohl(common.dword);\n\n\t \n\tlo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);\n\n\t \n\thi_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan >> 16);\n\n\t \n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(0);\n\n\t \n\tlo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);\n\n\t \n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(1);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(2);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(3);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(4);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(5);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(6);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(7);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(8);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(9);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(10);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(11);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(12);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(13);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(14);\n\tIXGBE_COMPUTE_SIG_HASH_ITERATION(15);\n\n\t \n\tbucket_hash ^= common_hash;\n\tbucket_hash &= IXGBE_ATR_HASH_MASK;\n\n\tsig_hash ^= common_hash << 16;\n\tsig_hash &= IXGBE_ATR_HASH_MASK << 16;\n\n\t \n\treturn sig_hash ^ bucket_hash;\n}\n\n \ns32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,\n\t\t\t\t\t  union ixgbe_atr_hash_dword input,\n\t\t\t\t\t  union ixgbe_atr_hash_dword common,\n\t\t\t\t\t  u8 queue)\n{\n\tu64 fdirhashcmd;\n\tu8 flow_type;\n\tbool tunnel;\n\tu32 fdircmd;\n\n\t \n\ttunnel = !!(input.formatted.flow_type & IXGBE_ATR_L4TYPE_TUNNEL_MASK);\n\tflow_type = input.formatted.flow_type &\n\t\t    (IXGBE_ATR_L4TYPE_TUNNEL_MASK - 1);\n\tswitch (flow_type) {\n\tcase IXGBE_ATR_FLOW_TYPE_TCPV4:\n\tcase IXGBE_ATR_FLOW_TYPE_UDPV4:\n\tcase IXGBE_ATR_FLOW_TYPE_SCTPV4:\n\tcase IXGBE_ATR_FLOW_TYPE_TCPV6:\n\tcase IXGBE_ATR_FLOW_TYPE_UDPV6:\n\tcase IXGBE_ATR_FLOW_TYPE_SCTPV6:\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \" Error on flow type input\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\t \n\tfdircmd = IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |\n\t\t  IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;\n\tfdircmd |= (u32)flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;\n\tfdircmd |= (u32)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;\n\tif (tunnel)\n\t\tfdircmd |= IXGBE_FDIRCMD_TUNNEL_FILTER;\n\n\t \n\tfdirhashcmd = (u64)fdircmd << 32;\n\tfdirhashcmd |= ixgbe_atr_compute_sig_hash_82599(input, common);\n\tIXGBE_WRITE_REG64(hw, IXGBE_FDIRHASH, fdirhashcmd);\n\n\thw_dbg(hw, \"Tx Queue=%x hash=%x\\n\", queue, (u32)fdirhashcmd);\n\n\treturn 0;\n}\n\n#define IXGBE_COMPUTE_BKT_HASH_ITERATION(_n) \\\ndo { \\\n\tu32 n = (_n); \\\n\tif (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n)) \\\n\t\tbucket_hash ^= lo_hash_dword >> n; \\\n\tif (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n + 16)) \\\n\t\tbucket_hash ^= hi_hash_dword >> n; \\\n} while (0)\n\n \nvoid ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,\n\t\t\t\t\t  union ixgbe_atr_input *input_mask)\n{\n\n\tu32 hi_hash_dword, lo_hash_dword, flow_vm_vlan;\n\tu32 bucket_hash = 0;\n\t__be32 hi_dword = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i <= 10; i++)\n\t\tinput->dword_stream[i] &= input_mask->dword_stream[i];\n\n\t \n\tflow_vm_vlan = ntohl(input->dword_stream[0]);\n\n\t \n\tfor (i = 1; i <= 10; i++)\n\t\thi_dword ^= input->dword_stream[i];\n\thi_hash_dword = ntohl(hi_dword);\n\n\t \n\tlo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);\n\n\t \n\thi_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan >> 16);\n\n\t \n\tIXGBE_COMPUTE_BKT_HASH_ITERATION(0);\n\n\t \n\tlo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);\n\n\t \n\tfor (i = 1; i <= 15; i++)\n\t\tIXGBE_COMPUTE_BKT_HASH_ITERATION(i);\n\n\t \n\tinput->formatted.bkt_hash = (__force __be16)(bucket_hash & 0x1FFF);\n}\n\n \nstatic u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask)\n{\n\tu32 mask = ntohs(input_mask->formatted.dst_port);\n\n\tmask <<= IXGBE_FDIRTCPM_DPORTM_SHIFT;\n\tmask |= ntohs(input_mask->formatted.src_port);\n\tmask = ((mask & 0x55555555) << 1) | ((mask & 0xAAAAAAAA) >> 1);\n\tmask = ((mask & 0x33333333) << 2) | ((mask & 0xCCCCCCCC) >> 2);\n\tmask = ((mask & 0x0F0F0F0F) << 4) | ((mask & 0xF0F0F0F0) >> 4);\n\treturn ((mask & 0x00FF00FF) << 8) | ((mask & 0xFF00FF00) >> 8);\n}\n\n \n#define IXGBE_STORE_AS_BE32(_value) \\\n\t(((u32)(_value) >> 24) | (((u32)(_value) & 0x00FF0000) >> 8) | \\\n\t (((u32)(_value) & 0x0000FF00) << 8) | ((u32)(_value) << 24))\n\n#define IXGBE_WRITE_REG_BE32(a, reg, value) \\\n\tIXGBE_WRITE_REG((a), (reg), IXGBE_STORE_AS_BE32(ntohl(value)))\n\n#define IXGBE_STORE_AS_BE16(_value) __swab16(ntohs((_value)))\n\ns32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,\n\t\t\t\t    union ixgbe_atr_input *input_mask)\n{\n\t \n\tu32 fdirm = IXGBE_FDIRM_DIPv6;\n\tu32 fdirtcpm;\n\n\t \n\n\t \n\tif (input_mask->formatted.bkt_hash)\n\t\thw_dbg(hw, \" bucket hash should always be 0 in mask\\n\");\n\n\t \n\tswitch (input_mask->formatted.vm_pool & 0x7F) {\n\tcase 0x0:\n\t\tfdirm |= IXGBE_FDIRM_POOL;\n\t\tbreak;\n\tcase 0x7F:\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \" Error on vm pool mask\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\tswitch (input_mask->formatted.flow_type & IXGBE_ATR_L4TYPE_MASK) {\n\tcase 0x0:\n\t\tfdirm |= IXGBE_FDIRM_L4P;\n\t\tif (input_mask->formatted.dst_port ||\n\t\t    input_mask->formatted.src_port) {\n\t\t\thw_dbg(hw, \" Error on src/dst port mask\\n\");\n\t\t\treturn IXGBE_ERR_CONFIG;\n\t\t}\n\t\tbreak;\n\tcase IXGBE_ATR_L4TYPE_MASK:\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \" Error on flow type mask\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\tswitch (ntohs(input_mask->formatted.vlan_id) & 0xEFFF) {\n\tcase 0x0000:\n\t\t \n\t\tfdirm |= IXGBE_FDIRM_VLANID;\n\t\tfallthrough;\n\tcase 0x0FFF:\n\t\t \n\t\tfdirm |= IXGBE_FDIRM_VLANP;\n\t\tbreak;\n\tcase 0xE000:\n\t\t \n\t\tfdirm |= IXGBE_FDIRM_VLANID;\n\t\tfallthrough;\n\tcase 0xEFFF:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \" Error on VLAN mask\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\tswitch ((__force u16)input_mask->formatted.flex_bytes & 0xFFFF) {\n\tcase 0x0000:\n\t\t \n\t\tfdirm |= IXGBE_FDIRM_FLEX;\n\t\tfallthrough;\n\tcase 0xFFFF:\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \" Error on flexible byte mask\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRM, fdirm);\n\n\t \n\tfdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRTCPM, ~fdirtcpm);\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRUDPM, ~fdirtcpm);\n\n\t \n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FDIRSCTPM, ~fdirtcpm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIP4M,\n\t\t\t     ~input_mask->formatted.src_ip[0]);\n\tIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRDIP4M,\n\t\t\t     ~input_mask->formatted.dst_ip[0]);\n\n\treturn 0;\n}\n\ns32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,\n\t\t\t\t\t  union ixgbe_atr_input *input,\n\t\t\t\t\t  u16 soft_id, u8 queue)\n{\n\tu32 fdirport, fdirvlan, fdirhash, fdircmd;\n\ts32 err;\n\n\t \n\tIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(0),\n\t\t\t     input->formatted.src_ip[0]);\n\tIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(1),\n\t\t\t     input->formatted.src_ip[1]);\n\tIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(2),\n\t\t\t     input->formatted.src_ip[2]);\n\n\t \n\tIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPSA, input->formatted.src_ip[0]);\n\n\t \n\tIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPDA, input->formatted.dst_ip[0]);\n\n\t \n\tfdirport = be16_to_cpu(input->formatted.dst_port);\n\tfdirport <<= IXGBE_FDIRPORT_DESTINATION_SHIFT;\n\tfdirport |= be16_to_cpu(input->formatted.src_port);\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRPORT, fdirport);\n\n\t \n\tfdirvlan = IXGBE_STORE_AS_BE16(input->formatted.flex_bytes);\n\tfdirvlan <<= IXGBE_FDIRVLAN_FLEX_SHIFT;\n\tfdirvlan |= ntohs(input->formatted.vlan_id);\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRVLAN, fdirvlan);\n\n\t \n\tfdirhash = (__force u32)input->formatted.bkt_hash;\n\tfdirhash |= soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT;\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);\n\n\t \n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tfdircmd = IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |\n\t\t  IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;\n\tif (queue == IXGBE_FDIR_DROP_QUEUE)\n\t\tfdircmd |= IXGBE_FDIRCMD_DROP;\n\tfdircmd |= input->formatted.flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;\n\tfdircmd |= (u32)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;\n\tfdircmd |= (u32)input->formatted.vm_pool << IXGBE_FDIRCMD_VT_POOL_SHIFT;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD, fdircmd);\n\terr = ixgbe_fdir_check_cmd_complete(hw, &fdircmd);\n\tif (err) {\n\t\thw_dbg(hw, \"Flow Director command did not complete!\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\ns32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,\n\t\t\t\t\t  union ixgbe_atr_input *input,\n\t\t\t\t\t  u16 soft_id)\n{\n\tu32 fdirhash;\n\tu32 fdircmd;\n\ts32 err;\n\n\t \n\tfdirhash = (__force u32)input->formatted.bkt_hash;\n\tfdirhash |= soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT;\n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);\n\n\t \n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD, IXGBE_FDIRCMD_CMD_QUERY_REM_FILT);\n\n\terr = ixgbe_fdir_check_cmd_complete(hw, &fdircmd);\n\tif (err) {\n\t\thw_dbg(hw, \"Flow Director command did not complete!\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (fdircmd & IXGBE_FDIRCMD_FILTER_VALID) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,\n\t\t\t\tIXGBE_FDIRCMD_CMD_REMOVE_FLOW);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val)\n{\n\tu32  core_ctl;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_CORECTL, IXGBE_CORECTL_WRITE_CMD |\n\t\t\t(reg << 8));\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(10);\n\tcore_ctl = IXGBE_READ_REG(hw, IXGBE_CORECTL);\n\t*val = (u8)core_ctl;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val)\n{\n\tu32  core_ctl;\n\n\tcore_ctl = (reg << 8) | val;\n\tIXGBE_WRITE_REG(hw, IXGBE_CORECTL, core_ctl);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(10);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\tret_val = ixgbe_start_hw_generic(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = ixgbe_start_hw_gen2(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\thw->mac.autotry_restart = true;\n\n\treturn ixgbe_verify_fw_version_82599(hw);\n}\n\n \nstatic s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\n\t \n\tstatus = ixgbe_identify_phy_generic(hw);\n\tif (status) {\n\t\t \n\t\tif (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_copper)\n\t\t\treturn status;\n\t\tstatus = ixgbe_identify_module_generic(hw);\n\t}\n\n\t \n\tif (hw->phy.type == ixgbe_phy_unknown) {\n\t\thw->phy.type = ixgbe_phy_none;\n\t\tstatus = 0;\n\t}\n\n\t \n\tif (hw->phy.type == ixgbe_phy_sfp_unsupported)\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval)\n{\n\t \n\thw->mac.ops.disable_rx_buff(hw);\n\n\tif (regval & IXGBE_RXCTRL_RXEN)\n\t\thw->mac.ops.enable_rx(hw);\n\telse\n\t\thw->mac.ops.disable_rx(hw);\n\n\thw->mac.ops.enable_rx_buff(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw)\n{\n\ts32 status = IXGBE_ERR_EEPROM_VERSION;\n\tu16 fw_offset, fw_ptp_cfg_offset;\n\tu16 offset;\n\tu16 fw_version = 0;\n\n\t \n\tif (hw->phy.media_type != ixgbe_media_type_fiber)\n\t\treturn 0;\n\n\t \n\toffset = IXGBE_FW_PTR;\n\tif (hw->eeprom.ops.read(hw, offset, &fw_offset))\n\t\tgoto fw_version_err;\n\n\tif (fw_offset == 0 || fw_offset == 0xFFFF)\n\t\treturn IXGBE_ERR_EEPROM_VERSION;\n\n\t \n\toffset = fw_offset + IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR;\n\tif (hw->eeprom.ops.read(hw, offset, &fw_ptp_cfg_offset))\n\t\tgoto fw_version_err;\n\n\tif (fw_ptp_cfg_offset == 0 || fw_ptp_cfg_offset == 0xFFFF)\n\t\treturn IXGBE_ERR_EEPROM_VERSION;\n\n\t \n\toffset = fw_ptp_cfg_offset + IXGBE_FW_PATCH_VERSION_4;\n\tif (hw->eeprom.ops.read(hw, offset, &fw_version))\n\t\tgoto fw_version_err;\n\n\tif (fw_version > 0x5)\n\t\tstatus = 0;\n\n\treturn status;\n\nfw_version_err:\n\thw_err(hw, \"eeprom read at offset %d failed\\n\", offset);\n\treturn IXGBE_ERR_EEPROM_VERSION;\n}\n\n \nstatic bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)\n{\n\tu16 fw_offset, fw_lesm_param_offset, fw_lesm_state;\n\ts32 status;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, IXGBE_FW_PTR, &fw_offset);\n\n\tif (status || fw_offset == 0 || fw_offset == 0xFFFF)\n\t\treturn false;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, (fw_offset +\n\t\t\t\t     IXGBE_FW_LESM_PARAMETERS_PTR),\n\t\t\t\t     &fw_lesm_param_offset);\n\n\tif (status ||\n\t    fw_lesm_param_offset == 0 || fw_lesm_param_offset == 0xFFFF)\n\t\treturn false;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, (fw_lesm_param_offset +\n\t\t\t\t     IXGBE_FW_LESM_STATE_1),\n\t\t\t\t     &fw_lesm_state);\n\n\tif (!status && (fw_lesm_state & IXGBE_FW_LESM_STATE_ENABLED))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t  u16 words, u16 *data)\n{\n\tstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\n\n\t \n\tif (eeprom->type == ixgbe_eeprom_spi &&\n\t    offset + (words - 1) <= IXGBE_EERD_MAX_ADDR)\n\t\treturn ixgbe_read_eerd_buffer_generic(hw, offset, words, data);\n\n\treturn ixgbe_read_eeprom_buffer_bit_bang_generic(hw, offset, words,\n\t\t\t\t\t\t\t data);\n}\n\n \nstatic s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,\n\t\t\t\t   u16 offset, u16 *data)\n{\n\tstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\n\n\t \n\tif (eeprom->type == ixgbe_eeprom_spi && offset <= IXGBE_EERD_MAX_ADDR)\n\t\treturn ixgbe_read_eerd_generic(hw, offset, data);\n\n\treturn ixgbe_read_eeprom_bit_bang_generic(hw, offset, data);\n}\n\n \nstatic s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)\n{\n\ts32 ret_val;\n\tu32 anlp1_reg = 0;\n\tu32 i, autoc_reg, autoc2_reg;\n\n\t \n\tautoc2_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\n\tif (autoc2_reg & IXGBE_AUTOC2_LINK_DISABLE_MASK) {\n\t\tautoc2_reg &= ~IXGBE_AUTOC2_LINK_DISABLE_MASK;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2_reg);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n\n\tautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tautoc_reg |= IXGBE_AUTOC_AN_RESTART;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC,\n\t\t\tautoc_reg ^ (0x4 << IXGBE_AUTOC_LMS_SHIFT));\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tusleep_range(4000, 8000);\n\t\tanlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);\n\t\tif (anlp1_reg & IXGBE_ANLP1_AN_STATE_MASK)\n\t\t\tbreak;\n\t}\n\n\tif (!(anlp1_reg & IXGBE_ANLP1_AN_STATE_MASK)) {\n\t\thw_dbg(hw, \"auto negotiation not completed\\n\");\n\t\tret_val = IXGBE_ERR_RESET_FAILED;\n\t\tgoto reset_pipeline_out;\n\t}\n\n\tret_val = 0;\n\nreset_pipeline_out:\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t     u8 dev_addr, u8 *data)\n{\n\tu32 esdp;\n\ts32 status;\n\ts32 timeout = 200;\n\n\tif (hw->phy.qsfp_shared_i2c_bus == true) {\n\t\t \n\t\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\t\tesdp |= IXGBE_ESDP_SDP0;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\n\t\twhile (timeout) {\n\t\t\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\t\t\tif (esdp & IXGBE_ESDP_SDP1)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(5000, 10000);\n\t\t\ttimeout--;\n\t\t}\n\n\t\tif (!timeout) {\n\t\t\thw_dbg(hw, \"Driver can't access resource, acquiring I2C bus timeout.\\n\");\n\t\t\tstatus = IXGBE_ERR_I2C;\n\t\t\tgoto release_i2c_access;\n\t\t}\n\t}\n\n\tstatus = ixgbe_read_i2c_byte_generic(hw, byte_offset, dev_addr, data);\n\nrelease_i2c_access:\n\tif (hw->phy.qsfp_shared_i2c_bus == true) {\n\t\t \n\t\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\t\tesdp &= ~IXGBE_ESDP_SDP0;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t      u8 dev_addr, u8 data)\n{\n\tu32 esdp;\n\ts32 status;\n\ts32 timeout = 200;\n\n\tif (hw->phy.qsfp_shared_i2c_bus == true) {\n\t\t \n\t\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\t\tesdp |= IXGBE_ESDP_SDP0;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\n\t\twhile (timeout) {\n\t\t\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\t\t\tif (esdp & IXGBE_ESDP_SDP1)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(5000, 10000);\n\t\t\ttimeout--;\n\t\t}\n\n\t\tif (!timeout) {\n\t\t\thw_dbg(hw, \"Driver can't access resource, acquiring I2C bus timeout.\\n\");\n\t\t\tstatus = IXGBE_ERR_I2C;\n\t\t\tgoto release_i2c_access;\n\t\t}\n\t}\n\n\tstatus = ixgbe_write_i2c_byte_generic(hw, byte_offset, dev_addr, data);\n\nrelease_i2c_access:\n\tif (hw->phy.qsfp_shared_i2c_bus == true) {\n\t\t \n\t\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\t\tesdp &= ~IXGBE_ESDP_SDP0;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n\n\treturn status;\n}\n\nstatic const struct ixgbe_mac_operations mac_ops_82599 = {\n\t.init_hw                = &ixgbe_init_hw_generic,\n\t.reset_hw               = &ixgbe_reset_hw_82599,\n\t.start_hw               = &ixgbe_start_hw_82599,\n\t.clear_hw_cntrs         = &ixgbe_clear_hw_cntrs_generic,\n\t.get_media_type         = &ixgbe_get_media_type_82599,\n\t.enable_rx_dma          = &ixgbe_enable_rx_dma_82599,\n\t.disable_rx_buff\t= &ixgbe_disable_rx_buff_generic,\n\t.enable_rx_buff\t\t= &ixgbe_enable_rx_buff_generic,\n\t.get_mac_addr           = &ixgbe_get_mac_addr_generic,\n\t.get_san_mac_addr       = &ixgbe_get_san_mac_addr_generic,\n\t.get_device_caps        = &ixgbe_get_device_caps_generic,\n\t.get_wwn_prefix         = &ixgbe_get_wwn_prefix_generic,\n\t.stop_adapter           = &ixgbe_stop_adapter_generic,\n\t.get_bus_info           = &ixgbe_get_bus_info_generic,\n\t.set_lan_id             = &ixgbe_set_lan_id_multi_port_pcie,\n\t.read_analog_reg8       = &ixgbe_read_analog_reg8_82599,\n\t.write_analog_reg8      = &ixgbe_write_analog_reg8_82599,\n\t.stop_link_on_d3\t= &ixgbe_stop_mac_link_on_d3_82599,\n\t.setup_link             = &ixgbe_setup_mac_link_82599,\n\t.set_rxpba\t\t= &ixgbe_set_rxpba_generic,\n\t.check_link             = &ixgbe_check_mac_link_generic,\n\t.get_link_capabilities  = &ixgbe_get_link_capabilities_82599,\n\t.led_on                 = &ixgbe_led_on_generic,\n\t.led_off                = &ixgbe_led_off_generic,\n\t.init_led_link_act\t= ixgbe_init_led_link_act_generic,\n\t.blink_led_start        = &ixgbe_blink_led_start_generic,\n\t.blink_led_stop         = &ixgbe_blink_led_stop_generic,\n\t.set_rar                = &ixgbe_set_rar_generic,\n\t.clear_rar              = &ixgbe_clear_rar_generic,\n\t.set_vmdq               = &ixgbe_set_vmdq_generic,\n\t.set_vmdq_san_mac\t= &ixgbe_set_vmdq_san_mac_generic,\n\t.clear_vmdq             = &ixgbe_clear_vmdq_generic,\n\t.init_rx_addrs          = &ixgbe_init_rx_addrs_generic,\n\t.update_mc_addr_list    = &ixgbe_update_mc_addr_list_generic,\n\t.enable_mc              = &ixgbe_enable_mc_generic,\n\t.disable_mc             = &ixgbe_disable_mc_generic,\n\t.clear_vfta             = &ixgbe_clear_vfta_generic,\n\t.set_vfta               = &ixgbe_set_vfta_generic,\n\t.fc_enable              = &ixgbe_fc_enable_generic,\n\t.setup_fc\t\t= ixgbe_setup_fc_generic,\n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n\t.set_fw_drv_ver         = &ixgbe_set_fw_drv_ver_generic,\n\t.init_uta_tables        = &ixgbe_init_uta_tables_generic,\n\t.setup_sfp              = &ixgbe_setup_sfp_modules_82599,\n\t.set_mac_anti_spoofing  = &ixgbe_set_mac_anti_spoofing,\n\t.set_vlan_anti_spoofing = &ixgbe_set_vlan_anti_spoofing,\n\t.acquire_swfw_sync      = &ixgbe_acquire_swfw_sync,\n\t.release_swfw_sync      = &ixgbe_release_swfw_sync,\n\t.init_swfw_sync\t\t= NULL,\n\t.get_thermal_sensor_data = &ixgbe_get_thermal_sensor_data_generic,\n\t.init_thermal_sensor_thresh = &ixgbe_init_thermal_sensor_thresh_generic,\n\t.prot_autoc_read\t= &prot_autoc_read_82599,\n\t.prot_autoc_write\t= &prot_autoc_write_82599,\n\t.enable_rx\t\t= &ixgbe_enable_rx_generic,\n\t.disable_rx\t\t= &ixgbe_disable_rx_generic,\n};\n\nstatic const struct ixgbe_eeprom_operations eeprom_ops_82599 = {\n\t.init_params\t\t= &ixgbe_init_eeprom_params_generic,\n\t.read\t\t\t= &ixgbe_read_eeprom_82599,\n\t.read_buffer\t\t= &ixgbe_read_eeprom_buffer_82599,\n\t.write\t\t\t= &ixgbe_write_eeprom_generic,\n\t.write_buffer\t\t= &ixgbe_write_eeprom_buffer_bit_bang_generic,\n\t.calc_checksum\t\t= &ixgbe_calc_eeprom_checksum_generic,\n\t.validate_checksum\t= &ixgbe_validate_eeprom_checksum_generic,\n\t.update_checksum\t= &ixgbe_update_eeprom_checksum_generic,\n};\n\nstatic const struct ixgbe_phy_operations phy_ops_82599 = {\n\t.identify\t\t= &ixgbe_identify_phy_82599,\n\t.identify_sfp\t\t= &ixgbe_identify_module_generic,\n\t.init\t\t\t= &ixgbe_init_phy_ops_82599,\n\t.reset\t\t\t= &ixgbe_reset_phy_generic,\n\t.read_reg\t\t= &ixgbe_read_phy_reg_generic,\n\t.write_reg\t\t= &ixgbe_write_phy_reg_generic,\n\t.setup_link\t\t= &ixgbe_setup_phy_link_generic,\n\t.setup_link_speed\t= &ixgbe_setup_phy_link_speed_generic,\n\t.read_i2c_byte\t\t= &ixgbe_read_i2c_byte_generic,\n\t.write_i2c_byte\t\t= &ixgbe_write_i2c_byte_generic,\n\t.read_i2c_sff8472\t= &ixgbe_read_i2c_sff8472_generic,\n\t.read_i2c_eeprom\t= &ixgbe_read_i2c_eeprom_generic,\n\t.write_i2c_eeprom\t= &ixgbe_write_i2c_eeprom_generic,\n\t.check_overtemp\t\t= &ixgbe_tn_check_overtemp,\n};\n\nconst struct ixgbe_info ixgbe_82599_info = {\n\t.mac                    = ixgbe_mac_82599EB,\n\t.get_invariants         = &ixgbe_get_invariants_82599,\n\t.mac_ops                = &mac_ops_82599,\n\t.eeprom_ops             = &eeprom_ops_82599,\n\t.phy_ops                = &phy_ops_82599,\n\t.mbx_ops                = &mbx_ops_generic,\n\t.mvals\t\t\t= ixgbe_mvals_8259X,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}