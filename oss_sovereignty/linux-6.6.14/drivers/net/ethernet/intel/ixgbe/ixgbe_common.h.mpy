{
  "module_name": "ixgbe_common.h",
  "hash_id": "195b7d75fffb75b6bb98c26c404351f57eb2902eb1e78df2cd0b3ece371524c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h",
  "human_readable_source": " \n \n\n#ifndef _IXGBE_COMMON_H_\n#define _IXGBE_COMMON_H_\n\n#include \"ixgbe_type.h\"\n#include \"ixgbe.h\"\n\nu16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw);\ns32 ixgbe_init_hw_generic(struct ixgbe_hw *hw);\ns32 ixgbe_start_hw_generic(struct ixgbe_hw *hw);\ns32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw);\ns32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw);\ns32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,\n\t\t\t\t  u32 pba_num_size);\ns32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr);\nenum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status);\nenum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status);\ns32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw);\nvoid ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw);\ns32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw);\n\ns32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index);\ns32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index);\ns32 ixgbe_init_led_link_act_generic(struct ixgbe_hw *hw);\n\ns32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw);\ns32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data);\ns32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t       u16 words, u16 *data);\ns32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data);\ns32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t   u16 words, u16 *data);\ns32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data);\ns32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t    u16 words, u16 *data);\ns32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t       u16 *data);\ns32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t      u16 words, u16 *data);\ns32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw);\ns32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,\n\t\t\t\t\t   u16 *checksum_val);\ns32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw);\n\ns32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,\n\t\t\t  u32 enable_addr);\ns32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index);\ns32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw);\ns32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw,\n\t\t\t\t      struct net_device *netdev);\ns32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw);\ns32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw);\ns32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw);\ns32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw);\ns32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval);\ns32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw);\ns32 ixgbe_setup_fc_generic(struct ixgbe_hw *);\nbool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw);\nvoid ixgbe_fc_autoneg(struct ixgbe_hw *hw);\n\ns32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask);\nvoid ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask);\ns32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr);\ns32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);\ns32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq);\ns32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);\ns32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw);\ns32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan,\n\t\t\t   u32 vind, bool vlan_on, bool vlvf_bypass);\ns32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw);\ns32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw,\n\t\t\t\t ixgbe_link_speed *speed,\n\t\t\t\t bool *link_up, bool link_up_wait_to_complete);\ns32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,\n\t\t\t\t u16 *wwpn_prefix);\n\ns32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *, u32 *reg_val);\ns32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked);\n\ns32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index);\ns32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index);\nvoid ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf);\nvoid ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf);\ns32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps);\ns32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,\n\t\t\t\t u8 build, u8 ver, u16 len, const char *str);\nu8 ixgbe_calculate_checksum(u8 *buffer, u32 length);\ns32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *, u32 length,\n\t\t\t\t u32 timeout, bool return_data);\ns32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 len, u32 timeout);\ns32 ixgbe_fw_phy_activity(struct ixgbe_hw *hw, u16 activity,\n\t\t\t  u32 (*data)[FW_PHY_ACT_DATA_COUNT]);\nvoid ixgbe_clear_tx_pending(struct ixgbe_hw *hw);\nbool ixgbe_mng_present(struct ixgbe_hw *hw);\nbool ixgbe_mng_enabled(struct ixgbe_hw *hw);\n\nvoid ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb,\n\t\t\t     u32 headroom, int strategy);\n\nextern const u32 ixgbe_mvals_8259X[IXGBE_MVALS_IDX_LIMIT];\n\n#define IXGBE_I2C_THERMAL_SENSOR_ADDR\t0xF8\n#define IXGBE_EMC_INTERNAL_DATA\t\t0x00\n#define IXGBE_EMC_INTERNAL_THERM_LIMIT\t0x20\n#define IXGBE_EMC_DIODE1_DATA\t\t0x01\n#define IXGBE_EMC_DIODE1_THERM_LIMIT\t0x19\n#define IXGBE_EMC_DIODE2_DATA\t\t0x23\n#define IXGBE_EMC_DIODE2_THERM_LIMIT\t0x1A\n#define IXGBE_EMC_DIODE3_DATA\t\t0x2A\n#define IXGBE_EMC_DIODE3_THERM_LIMIT\t0x30\n\ns32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw);\ns32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw);\nvoid ixgbe_get_etk_id(struct ixgbe_hw *hw,\n\t\t      struct ixgbe_nvm_version *nvm_ver);\nvoid ixgbe_get_oem_prod_version(struct ixgbe_hw *hw,\n\t\t\t\tstruct ixgbe_nvm_version *nvm_ver);\nvoid ixgbe_get_orom_version(struct ixgbe_hw *hw,\n\t\t\t    struct ixgbe_nvm_version *nvm_ver);\nvoid ixgbe_disable_rx_generic(struct ixgbe_hw *hw);\nvoid ixgbe_enable_rx_generic(struct ixgbe_hw *hw);\ns32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,\n\t\t\t\t\t  ixgbe_link_speed speed,\n\t\t\t\t\t  bool autoneg_wait_to_complete);\nvoid ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,\n\t\t\t\t      ixgbe_link_speed speed);\n\n#define IXGBE_FAILED_READ_RETRIES 5\n#define IXGBE_FAILED_READ_REG 0xffffffffU\n#define IXGBE_FAILED_READ_CFG_DWORD 0xffffffffU\n#define IXGBE_FAILED_READ_CFG_WORD 0xffffU\n\nu16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg);\nvoid ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value);\n\nstatic inline bool ixgbe_removed(void __iomem *addr)\n{\n\treturn unlikely(!addr);\n}\n\nstatic inline void ixgbe_write_reg(struct ixgbe_hw *hw, u32 reg, u32 value)\n{\n\tu8 __iomem *reg_addr = READ_ONCE(hw->hw_addr);\n\n\tif (ixgbe_removed(reg_addr))\n\t\treturn;\n\twritel(value, reg_addr + reg);\n}\n#define IXGBE_WRITE_REG(a, reg, value) ixgbe_write_reg((a), (reg), (value))\n\n#ifndef writeq\n#define writeq writeq\nstatic inline void writeq(u64 val, void __iomem *addr)\n{\n\twritel((u32)val, addr);\n\twritel((u32)(val >> 32), addr + 4);\n}\n#endif\n\nstatic inline void ixgbe_write_reg64(struct ixgbe_hw *hw, u32 reg, u64 value)\n{\n\tu8 __iomem *reg_addr = READ_ONCE(hw->hw_addr);\n\n\tif (ixgbe_removed(reg_addr))\n\t\treturn;\n\twriteq(value, reg_addr + reg);\n}\n#define IXGBE_WRITE_REG64(a, reg, value) ixgbe_write_reg64((a), (reg), (value))\n\nu32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg);\n#define IXGBE_READ_REG(a, reg) ixgbe_read_reg((a), (reg))\n\n#define IXGBE_WRITE_REG_ARRAY(a, reg, offset, value) \\\n\t\tixgbe_write_reg((a), (reg) + ((offset) << 2), (value))\n\n#define IXGBE_READ_REG_ARRAY(a, reg, offset) \\\n\t\tixgbe_read_reg((a), (reg) + ((offset) << 2))\n\n#define IXGBE_WRITE_FLUSH(a) ixgbe_read_reg((a), IXGBE_STATUS)\n\n#define ixgbe_hw_to_netdev(hw) (((struct ixgbe_adapter *)(hw)->back)->netdev)\n\n#define hw_dbg(hw, format, arg...) \\\n\tnetdev_dbg(ixgbe_hw_to_netdev(hw), format, ## arg)\n#define hw_err(hw, format, arg...) \\\n\tnetdev_err(ixgbe_hw_to_netdev(hw), format, ## arg)\n#define e_dev_info(format, arg...) \\\n\tdev_info(&adapter->pdev->dev, format, ## arg)\n#define e_dev_warn(format, arg...) \\\n\tdev_warn(&adapter->pdev->dev, format, ## arg)\n#define e_dev_err(format, arg...) \\\n\tdev_err(&adapter->pdev->dev, format, ## arg)\n#define e_dev_notice(format, arg...) \\\n\tdev_notice(&adapter->pdev->dev, format, ## arg)\n#define e_info(msglvl, format, arg...) \\\n\tnetif_info(adapter, msglvl, adapter->netdev, format, ## arg)\n#define e_err(msglvl, format, arg...) \\\n\tnetif_err(adapter, msglvl, adapter->netdev, format, ## arg)\n#define e_warn(msglvl, format, arg...) \\\n\tnetif_warn(adapter, msglvl, adapter->netdev, format, ## arg)\n#define e_crit(msglvl, format, arg...) \\\n\tnetif_crit(adapter, msglvl, adapter->netdev, format, ## arg)\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}