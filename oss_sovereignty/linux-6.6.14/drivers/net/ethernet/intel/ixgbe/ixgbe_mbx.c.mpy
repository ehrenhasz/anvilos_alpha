{
  "module_name": "ixgbe_mbx.c",
  "hash_id": "48036c3212bb557e1faedcff5cf2c97c2447cdb5c9683689d1d5ed7517753eea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include \"ixgbe.h\"\n#include \"ixgbe_mbx.h\"\n\n \ns32 ixgbe_read_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\n\t \n\tif (size > mbx->size)\n\t\tsize = mbx->size;\n\n\tif (!mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\treturn mbx->ops->read(hw, msg, size, mbx_id);\n}\n\n \ns32 ixgbe_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\n\tif (size > mbx->size)\n\t\treturn IXGBE_ERR_MBX;\n\n\tif (!mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\treturn mbx->ops->write(hw, msg, size, mbx_id);\n}\n\n \ns32 ixgbe_check_for_msg(struct ixgbe_hw *hw, u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\n\tif (!mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\treturn mbx->ops->check_for_msg(hw, mbx_id);\n}\n\n \ns32 ixgbe_check_for_ack(struct ixgbe_hw *hw, u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\n\tif (!mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\treturn mbx->ops->check_for_ack(hw, mbx_id);\n}\n\n \ns32 ixgbe_check_for_rst(struct ixgbe_hw *hw, u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\n\tif (!mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\treturn mbx->ops->check_for_rst(hw, mbx_id);\n}\n\n \nstatic s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw, u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!countdown || !mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\twhile (mbx->ops->check_for_msg(hw, mbx_id)) {\n\t\tcountdown--;\n\t\tif (!countdown)\n\t\t\treturn IXGBE_ERR_MBX;\n\t\tudelay(mbx->usec_delay);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw, u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!countdown || !mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\twhile (mbx->ops->check_for_ack(hw, mbx_id)) {\n\t\tcountdown--;\n\t\tif (!countdown)\n\t\t\treturn IXGBE_ERR_MBX;\n\t\tudelay(mbx->usec_delay);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size,\n\t\t\t\t u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val;\n\n\tif (!mbx->ops)\n\t\treturn IXGBE_ERR_MBX;\n\n\tret_val = ixgbe_poll_for_msg(hw, mbx_id);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\treturn mbx->ops->read(hw, msg, size, mbx_id);\n}\n\n \nstatic s32 ixgbe_write_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size,\n\t\t\t   u16 mbx_id)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val;\n\n\t \n\tif (!mbx->ops || !mbx->timeout)\n\t\treturn IXGBE_ERR_MBX;\n\n\t \n\tret_val = mbx->ops->write(hw, msg, size, mbx_id);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\treturn ixgbe_poll_for_ack(hw, mbx_id);\n}\n\nstatic s32 ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, u32 mask, s32 index)\n{\n\tu32 mbvficr = IXGBE_READ_REG(hw, IXGBE_MBVFICR(index));\n\n\tif (mbvficr & mask) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MBVFICR(index), mask);\n\t\treturn 0;\n\t}\n\n\treturn IXGBE_ERR_MBX;\n}\n\n \nstatic s32 ixgbe_check_for_msg_pf(struct ixgbe_hw *hw, u16 vf_number)\n{\n\ts32 index = IXGBE_MBVFICR_INDEX(vf_number);\n\tu32 vf_bit = vf_number % 16;\n\n\tif (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFREQ_VF1 << vf_bit,\n\t\t\t\t    index)) {\n\t\thw->mbx.stats.reqs++;\n\t\treturn 0;\n\t}\n\n\treturn IXGBE_ERR_MBX;\n}\n\n \nstatic s32 ixgbe_check_for_ack_pf(struct ixgbe_hw *hw, u16 vf_number)\n{\n\ts32 index = IXGBE_MBVFICR_INDEX(vf_number);\n\tu32 vf_bit = vf_number % 16;\n\n\tif (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFACK_VF1 << vf_bit,\n\t\t\t\t    index)) {\n\t\thw->mbx.stats.acks++;\n\t\treturn 0;\n\t}\n\n\treturn IXGBE_ERR_MBX;\n}\n\n \nstatic s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, u16 vf_number)\n{\n\tu32 reg_offset = (vf_number < 32) ? 0 : 1;\n\tu32 vf_shift = vf_number % 32;\n\tu32 vflre = 0;\n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_82599EB:\n\t\tvflre = IXGBE_READ_REG(hw, IXGBE_VFLRE(reg_offset));\n\t\tbreak;\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\tvflre = IXGBE_READ_REG(hw, IXGBE_VFLREC(reg_offset));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (vflre & BIT(vf_shift)) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFLREC(reg_offset), BIT(vf_shift));\n\t\thw->mbx.stats.rsts++;\n\t\treturn 0;\n\t}\n\n\treturn IXGBE_ERR_MBX;\n}\n\n \nstatic s32 ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw, u16 vf_number)\n{\n\tu32 p2v_mailbox;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_PFU);\n\n\t \n\tp2v_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_number));\n\tif (p2v_mailbox & IXGBE_PFMAILBOX_PFU)\n\t\treturn 0;\n\n\treturn IXGBE_ERR_MBX;\n}\n\n \nstatic s32 ixgbe_write_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,\n\t\t\t      u16 vf_number)\n{\n\ts32 ret_val;\n\tu16 i;\n\n\t \n\tret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tixgbe_check_for_msg_pf(hw, vf_number);\n\tixgbe_check_for_ack_pf(hw, vf_number);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tIXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i, msg[i]);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_STS);\n\n\t \n\thw->mbx.stats.msgs_tx++;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,\n\t\t\t     u16 vf_number)\n{\n\ts32 ret_val;\n\tu16 i;\n\n\t \n\tret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tmsg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_ACK);\n\n\t \n\thw->mbx.stats.msgs_rx++;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PCI_IOV\n \nvoid ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\n\tif (hw->mac.type != ixgbe_mac_82599EB &&\n\t    hw->mac.type != ixgbe_mac_X550 &&\n\t    hw->mac.type != ixgbe_mac_X550EM_x &&\n\t    hw->mac.type != ixgbe_mac_x550em_a &&\n\t    hw->mac.type != ixgbe_mac_X540)\n\t\treturn;\n\n\tmbx->timeout = 0;\n\tmbx->usec_delay = 0;\n\n\tmbx->stats.msgs_tx = 0;\n\tmbx->stats.msgs_rx = 0;\n\tmbx->stats.reqs = 0;\n\tmbx->stats.acks = 0;\n\tmbx->stats.rsts = 0;\n\n\tmbx->size = IXGBE_VFMAILBOX_SIZE;\n}\n#endif  \n\nconst struct ixgbe_mbx_operations mbx_ops_generic = {\n\t.read                   = ixgbe_read_mbx_pf,\n\t.write                  = ixgbe_write_mbx_pf,\n\t.read_posted            = ixgbe_read_posted_mbx,\n\t.write_posted           = ixgbe_write_posted_mbx,\n\t.check_for_msg          = ixgbe_check_for_msg_pf,\n\t.check_for_ack          = ixgbe_check_for_ack_pf,\n\t.check_for_rst          = ixgbe_check_for_rst_pf,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}