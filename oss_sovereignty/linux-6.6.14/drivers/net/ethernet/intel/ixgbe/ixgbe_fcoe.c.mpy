{
  "module_name": "ixgbe_fcoe.c",
  "hash_id": "abab0016f2f1bfc49a12d547179f4933dd6af0ec2d44d18c4f4d84c9b2a3a8e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c",
  "human_readable_source": "\n \n\n#include \"ixgbe.h\"\n#include <linux/if_ether.h>\n#include <linux/gfp.h>\n#include <linux/if_vlan.h>\n#include <generated/utsrelease.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/fc/fc_fs.h>\n#include <scsi/fc/fc_fcoe.h>\n#include <scsi/libfc.h>\n#include <scsi/libfcoe.h>\n\n \nstatic inline void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp)\n{\n\tddp->len = 0;\n\tddp->err = 1;\n\tddp->udl = NULL;\n\tddp->udp = 0UL;\n\tddp->sgl = NULL;\n\tddp->sgc = 0;\n}\n\n \nint ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid)\n{\n\tint len;\n\tstruct ixgbe_fcoe *fcoe;\n\tstruct ixgbe_adapter *adapter;\n\tstruct ixgbe_fcoe_ddp *ddp;\n\tstruct ixgbe_hw *hw;\n\tu32 fcbuff;\n\n\tif (!netdev)\n\t\treturn 0;\n\n\tif (xid >= netdev->fcoe_ddp_xid)\n\t\treturn 0;\n\n\tadapter = netdev_priv(netdev);\n\tfcoe = &adapter->fcoe;\n\tddp = &fcoe->ddp[xid];\n\tif (!ddp->udl)\n\t\treturn 0;\n\n\thw = &adapter->hw;\n\tlen = ddp->len;\n\t \n\tif (!ddp->err)\n\t\tgoto skip_ddpinv;\n\n\tif (hw->mac.type == ixgbe_mac_X550) {\n\t\t \n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDFC(0, xid), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDFC(3, xid),\n\t\t\t\t(xid | IXGBE_FCFLTRW_WE));\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDDC(2, xid), 0);\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDDC(3, xid),\n\t\t\t\t(xid | IXGBE_FCDMARW_WE));\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDDC(3, xid),\n\t\t\t\t(xid | IXGBE_FCDMARW_RE));\n\t\tfcbuff = IXGBE_READ_REG(hw, IXGBE_FCDDC(2, xid));\n\t} else {\n\t\t \n\t\tspin_lock_bh(&fcoe->lock);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCFLT, 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCFLTRW,\n\t\t\t\t(xid | IXGBE_FCFLTRW_WE));\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCBUFF, 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDMARW,\n\t\t\t\t(xid | IXGBE_FCDMARW_WE));\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDMARW,\n\t\t\t\t(xid | IXGBE_FCDMARW_RE));\n\t\tfcbuff = IXGBE_READ_REG(hw, IXGBE_FCBUFF);\n\t\tspin_unlock_bh(&fcoe->lock);\n\t\t}\n\n\tif (fcbuff & IXGBE_FCBUFF_VALID)\n\t\tusleep_range(100, 150);\n\nskip_ddpinv:\n\tif (ddp->sgl)\n\t\tdma_unmap_sg(&adapter->pdev->dev, ddp->sgl, ddp->sgc,\n\t\t\t     DMA_FROM_DEVICE);\n\tif (ddp->pool) {\n\t\tdma_pool_free(ddp->pool, ddp->udl, ddp->udp);\n\t\tddp->pool = NULL;\n\t}\n\n\tixgbe_fcoe_clear_ddp(ddp);\n\n\treturn len;\n}\n\n \nstatic int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,\n\t\t\t\tstruct scatterlist *sgl, unsigned int sgc,\n\t\t\t\tint target_mode)\n{\n\tstruct ixgbe_adapter *adapter;\n\tstruct ixgbe_hw *hw;\n\tstruct ixgbe_fcoe *fcoe;\n\tstruct ixgbe_fcoe_ddp *ddp;\n\tstruct ixgbe_fcoe_ddp_pool *ddp_pool;\n\tstruct scatterlist *sg;\n\tunsigned int i, j, dmacount;\n\tunsigned int len;\n\tstatic const unsigned int bufflen = IXGBE_FCBUFF_MIN;\n\tunsigned int firstoff = 0;\n\tunsigned int lastsize;\n\tunsigned int thisoff = 0;\n\tunsigned int thislen = 0;\n\tu32 fcbuff, fcdmarw, fcfltrw, fcrxctl;\n\tdma_addr_t addr = 0;\n\n\tif (!netdev || !sgl)\n\t\treturn 0;\n\n\tadapter = netdev_priv(netdev);\n\tif (xid >= netdev->fcoe_ddp_xid) {\n\t\te_warn(drv, \"xid=0x%x out-of-range\\n\", xid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (test_bit(__IXGBE_DOWN, &adapter->state) ||\n\t    test_bit(__IXGBE_RESETTING, &adapter->state))\n\t\treturn 0;\n\n\tfcoe = &adapter->fcoe;\n\tddp = &fcoe->ddp[xid];\n\tif (ddp->sgl) {\n\t\te_err(drv, \"xid 0x%x w/ non-null sgl=%p nents=%d\\n\",\n\t\t      xid, ddp->sgl, ddp->sgc);\n\t\treturn 0;\n\t}\n\tixgbe_fcoe_clear_ddp(ddp);\n\n\n\tif (!fcoe->ddp_pool) {\n\t\te_warn(drv, \"No ddp_pool resources allocated\\n\");\n\t\treturn 0;\n\t}\n\n\tddp_pool = per_cpu_ptr(fcoe->ddp_pool, get_cpu());\n\tif (!ddp_pool->pool) {\n\t\te_warn(drv, \"xid=0x%x no ddp pool for fcoe\\n\", xid);\n\t\tgoto out_noddp;\n\t}\n\n\t \n\tdmacount = dma_map_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);\n\tif (dmacount == 0) {\n\t\te_err(drv, \"xid 0x%x DMA map error\\n\", xid);\n\t\tgoto out_noddp;\n\t}\n\n\t \n\tddp->udl = dma_pool_alloc(ddp_pool->pool, GFP_ATOMIC, &ddp->udp);\n\tif (!ddp->udl) {\n\t\te_err(drv, \"failed allocated ddp context\\n\");\n\t\tgoto out_noddp_unmap;\n\t}\n\tddp->pool = ddp_pool->pool;\n\tddp->sgl = sgl;\n\tddp->sgc = sgc;\n\n\tj = 0;\n\tfor_each_sg(sgl, sg, dmacount, i) {\n\t\taddr = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\t\twhile (len) {\n\t\t\t \n\t\t\tif (j >= IXGBE_BUFFCNT_MAX) {\n\t\t\t\tddp_pool->noddp++;\n\t\t\t\tgoto out_noddp_free;\n\t\t\t}\n\n\t\t\t \n\t\t\tthisoff = addr & ((dma_addr_t)bufflen - 1);\n\t\t\tthislen = min((bufflen - thisoff), len);\n\t\t\t \n\t\t\tif ((j != 0) && (thisoff))\n\t\t\t\tgoto out_noddp_free;\n\t\t\t \n\t\t\tif (((i != (dmacount - 1)) || (thislen != len))\n\t\t\t    && ((thislen + thisoff) != bufflen))\n\t\t\t\tgoto out_noddp_free;\n\n\t\t\tddp->udl[j] = (u64)(addr - thisoff);\n\t\t\t \n\t\t\tif (j == 0)\n\t\t\t\tfirstoff = thisoff;\n\t\t\tlen -= thislen;\n\t\t\taddr += thislen;\n\t\t\tj++;\n\t\t}\n\t}\n\t \n\tlastsize = thisoff + thislen;\n\n\t \n\tif (lastsize == bufflen) {\n\t\tif (j >= IXGBE_BUFFCNT_MAX) {\n\t\t\tddp_pool->noddp_ext_buff++;\n\t\t\tgoto out_noddp_free;\n\t\t}\n\n\t\tddp->udl[j] = (u64)(fcoe->extra_ddp_buffer_dma);\n\t\tj++;\n\t\tlastsize = 1;\n\t}\n\tput_cpu();\n\n\tfcbuff = (IXGBE_FCBUFF_4KB << IXGBE_FCBUFF_BUFFSIZE_SHIFT);\n\tfcbuff |= ((j & 0xff) << IXGBE_FCBUFF_BUFFCNT_SHIFT);\n\tfcbuff |= (firstoff << IXGBE_FCBUFF_OFFSET_SHIFT);\n\t \n\tif (target_mode)\n\t\tfcbuff |= (IXGBE_FCBUFF_WRCONTX);\n\tfcbuff |= (IXGBE_FCBUFF_VALID);\n\n\tfcdmarw = xid;\n\tfcdmarw |= IXGBE_FCDMARW_WE;\n\tfcdmarw |= (lastsize << IXGBE_FCDMARW_LASTSIZE_SHIFT);\n\n\tfcfltrw = xid;\n\tfcfltrw |= IXGBE_FCFLTRW_WE;\n\n\t \n\thw = &adapter->hw;\n\n\t \n\tif (target_mode && !test_bit(__IXGBE_FCOE_TARGET, &fcoe->mode)) {\n\t\tset_bit(__IXGBE_FCOE_TARGET, &fcoe->mode);\n\t\tfcrxctl = IXGBE_READ_REG(hw, IXGBE_FCRXCTRL);\n\t\tfcrxctl |= IXGBE_FCRXCTRL_LASTSEQH;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRXCTRL, fcrxctl);\n\t}\n\n\tif (hw->mac.type == ixgbe_mac_X550) {\n\t\t \n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDDC(0, xid),\n\t\t\t\tddp->udp & DMA_BIT_MASK(32));\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDDC(1, xid), (u64)ddp->udp >> 32);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDDC(2, xid), fcbuff);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDDC(3, xid), fcdmarw);\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDFC(0, xid), IXGBE_FCFLT_VALID);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDFC(1, xid), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDFC(3, xid), fcfltrw);\n\t} else {\n\t\t \n\t\tspin_lock_bh(&fcoe->lock);\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCPTRL, ddp->udp & DMA_BIT_MASK(32));\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCPTRH, (u64)ddp->udp >> 32);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCBUFF, fcbuff);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCDMARW, fcdmarw);\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCPARAM, 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCFLT, IXGBE_FCFLT_VALID);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCFLTRW, fcfltrw);\n\n\t\tspin_unlock_bh(&fcoe->lock);\n\t}\n\n\treturn 1;\n\nout_noddp_free:\n\tdma_pool_free(ddp->pool, ddp->udl, ddp->udp);\n\tixgbe_fcoe_clear_ddp(ddp);\n\nout_noddp_unmap:\n\tdma_unmap_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);\nout_noddp:\n\tput_cpu();\n\treturn 0;\n}\n\n \nint ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid,\n\t\t       struct scatterlist *sgl, unsigned int sgc)\n{\n\treturn ixgbe_fcoe_ddp_setup(netdev, xid, sgl, sgc, 0);\n}\n\n \nint ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid,\n\t\t\t    struct scatterlist *sgl, unsigned int sgc)\n{\n\treturn ixgbe_fcoe_ddp_setup(netdev, xid, sgl, sgc, 1);\n}\n\n \nint ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,\n\t\t   union ixgbe_adv_rx_desc *rx_desc,\n\t\t   struct sk_buff *skb)\n{\n\tint rc = -EINVAL;\n\tstruct ixgbe_fcoe *fcoe;\n\tstruct ixgbe_fcoe_ddp *ddp;\n\tstruct fc_frame_header *fh;\n\tstruct fcoe_crc_eof *crc;\n\t__le32 fcerr = ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_FCERR);\n\t__le32 ddp_err;\n\tint ddp_max;\n\tu32 fctl;\n\tu16 xid;\n\n\tif (fcerr == cpu_to_le32(IXGBE_FCERR_BADCRC))\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\telse\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (eth_hdr(skb)->h_proto == htons(ETH_P_8021Q))\n\t\tfh = (struct fc_frame_header *)(skb->data +\n\t\t\tsizeof(struct vlan_hdr) + sizeof(struct fcoe_hdr));\n\telse\n\t\tfh = (struct fc_frame_header *)(skb->data +\n\t\t\tsizeof(struct fcoe_hdr));\n\n\tfctl = ntoh24(fh->fh_f_ctl);\n\tif (fctl & FC_FC_EX_CTX)\n\t\txid =  be16_to_cpu(fh->fh_ox_id);\n\telse\n\t\txid =  be16_to_cpu(fh->fh_rx_id);\n\n\tddp_max = IXGBE_FCOE_DDP_MAX;\n\t \n\tif (adapter->hw.mac.type == ixgbe_mac_X550)\n\t\tddp_max = IXGBE_FCOE_DDP_MAX_X550;\n\tif (xid >= ddp_max)\n\t\treturn -EINVAL;\n\n\tfcoe = &adapter->fcoe;\n\tddp = &fcoe->ddp[xid];\n\tif (!ddp->udl)\n\t\treturn -EINVAL;\n\n\tddp_err = ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_FCEOFE |\n\t\t\t\t\t      IXGBE_RXDADV_ERR_FCERR);\n\tif (ddp_err)\n\t\treturn -EINVAL;\n\n\tswitch (ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_STAT_FCSTAT)) {\n\t \n\tcase cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_DDP):\n\t\t \n\t\tddp->len = le32_to_cpu(rx_desc->wb.lower.hi_dword.rss);\n\t\trc = 0;\n\t\tbreak;\n\t \n\tcase cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_FCPRSP):\n\t\tdma_unmap_sg(&adapter->pdev->dev, ddp->sgl,\n\t\t\t     ddp->sgc, DMA_FROM_DEVICE);\n\t\tddp->err = (__force u32)ddp_err;\n\t\tddp->sgl = NULL;\n\t\tddp->sgc = 0;\n\t\tfallthrough;\n\t \n\tcase cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_NODDP):\n\t\t \n\t\tddp->len = le32_to_cpu(rx_desc->wb.lower.hi_dword.rss);\n\t\tif (ddp->len)\n\t\t\trc = ddp->len;\n\t\tbreak;\n\t \n\tcase cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_NOMTCH):\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif ((fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA) &&\n\t    (fctl & FC_FC_END_SEQ)) {\n\t\tskb_linearize(skb);\n\t\tcrc = skb_put(skb, sizeof(*crc));\n\t\tcrc->fcoe_eof = FC_EOF_T;\n\t}\n\n\treturn rc;\n}\n\n \nint ixgbe_fso(struct ixgbe_ring *tx_ring,\n\t      struct ixgbe_tx_buffer *first,\n\t      u8 *hdr_len)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fc_frame_header *fh;\n\tu32 vlan_macip_lens;\n\tu32 fcoe_sof_eof = 0;\n\tu32 mss_l4len_idx;\n\tu32 type_tucmd = IXGBE_ADVTXT_TUCMD_FCOE;\n\tu8 sof, eof;\n\n\tif (skb_is_gso(skb) && (skb_shinfo(skb)->gso_type != SKB_GSO_FCOE)) {\n\t\tdev_err(tx_ring->dev, \"Wrong gso type %d:expecting SKB_GSO_FCOE\\n\",\n\t\t\tskb_shinfo(skb)->gso_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tskb_set_network_header(skb, skb->mac_len);\n\tskb_set_transport_header(skb, skb->mac_len +\n\t\t\t\t sizeof(struct fcoe_hdr));\n\n\t \n\tsof = ((struct fcoe_hdr *)skb_network_header(skb))->fcoe_sof;\n\tswitch (sof) {\n\tcase FC_SOF_I2:\n\t\tfcoe_sof_eof = IXGBE_ADVTXD_FCOEF_ORIS;\n\t\tbreak;\n\tcase FC_SOF_I3:\n\t\tfcoe_sof_eof = IXGBE_ADVTXD_FCOEF_SOF |\n\t\t\t       IXGBE_ADVTXD_FCOEF_ORIS;\n\t\tbreak;\n\tcase FC_SOF_N2:\n\t\tbreak;\n\tcase FC_SOF_N3:\n\t\tfcoe_sof_eof = IXGBE_ADVTXD_FCOEF_SOF;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(tx_ring->dev, \"unknown sof = 0x%x\\n\", sof);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tskb_copy_bits(skb, skb->len - 4, &eof, 1);\n\t \n\tswitch (eof) {\n\tcase FC_EOF_N:\n\t\tfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_N;\n\t\tbreak;\n\tcase FC_EOF_T:\n\t\t \n\t\tif (skb_is_gso(skb))\n\t\t\tfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_N |\n\t\t\t\t\tIXGBE_ADVTXD_FCOEF_ORIE;\n\t\telse\n\t\t\tfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_T;\n\t\tbreak;\n\tcase FC_EOF_NI:\n\t\tfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_NI;\n\t\tbreak;\n\tcase FC_EOF_A:\n\t\tfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_A;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(tx_ring->dev, \"unknown eof = 0x%x\\n\", eof);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfh = (struct fc_frame_header *)skb_transport_header(skb);\n\tif (fh->fh_f_ctl[2] & FC_FC_REL_OFF)\n\t\tfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_PARINC;\n\n\t \n\t*hdr_len = sizeof(struct fcoe_crc_eof);\n\n\t \n\tif (skb_is_gso(skb)) {\n\t\t*hdr_len += skb_transport_offset(skb) +\n\t\t\t    sizeof(struct fc_frame_header);\n\t\t \n\t\tfirst->gso_segs = DIV_ROUND_UP(skb->len - *hdr_len,\n\t\t\t\t\t       skb_shinfo(skb)->gso_size);\n\t\tfirst->bytecount += (first->gso_segs - 1) * *hdr_len;\n\t\tfirst->tx_flags |= IXGBE_TX_FLAGS_TSO;\n\t\t \n\t\ttype_tucmd |= IXGBE_ADVTXD_TUCMD_L4T_RSV;\n\t}\n\n\t \n\tfirst->tx_flags |= IXGBE_TX_FLAGS_FCOE | IXGBE_TX_FLAGS_CC;\n\n\t \n\tmss_l4len_idx = skb_shinfo(skb)->gso_size << IXGBE_ADVTXD_MSS_SHIFT;\n\n\t \n\tvlan_macip_lens = skb_transport_offset(skb) +\n\t\t\t  sizeof(struct fc_frame_header);\n\tvlan_macip_lens |= (skb_transport_offset(skb) - 4)\n\t\t\t   << IXGBE_ADVTXD_MACLEN_SHIFT;\n\tvlan_macip_lens |= first->tx_flags & IXGBE_TX_FLAGS_VLAN_MASK;\n\n\t \n\tixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, fcoe_sof_eof,\n\t\t\t  type_tucmd, mss_l4len_idx);\n\n\treturn 0;\n}\n\nstatic void ixgbe_fcoe_dma_pool_free(struct ixgbe_fcoe *fcoe, unsigned int cpu)\n{\n\tstruct ixgbe_fcoe_ddp_pool *ddp_pool;\n\n\tddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);\n\tdma_pool_destroy(ddp_pool->pool);\n\tddp_pool->pool = NULL;\n}\n\nstatic int ixgbe_fcoe_dma_pool_alloc(struct ixgbe_fcoe *fcoe,\n\t\t\t\t     struct device *dev,\n\t\t\t\t     unsigned int cpu)\n{\n\tstruct ixgbe_fcoe_ddp_pool *ddp_pool;\n\tstruct dma_pool *pool;\n\tchar pool_name[32];\n\n\tsnprintf(pool_name, 32, \"ixgbe_fcoe_ddp_%u\", cpu);\n\n\tpool = dma_pool_create(pool_name, dev, IXGBE_FCPTR_MAX,\n\t\t\t       IXGBE_FCPTR_ALIGN, PAGE_SIZE);\n\tif (!pool)\n\t\treturn -ENOMEM;\n\n\tddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);\n\tddp_pool->pool = pool;\n\tddp_pool->noddp = 0;\n\tddp_pool->noddp_ext_buff = 0;\n\n\treturn 0;\n}\n\n \nvoid ixgbe_configure_fcoe(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_ring_feature *fcoe = &adapter->ring_feature[RING_F_FCOE];\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint i, fcoe_q, fcoe_i, fcoe_q_h = 0;\n\tint fcreta_size;\n\tu32 etqf;\n\n\t \n\tif (!(adapter->netdev->features & NETIF_F_FCOE_CRC))\n\t\treturn;\n\n\t \n\tetqf = ETH_P_FCOE | IXGBE_ETQF_FCOE | IXGBE_ETQF_FILTER_EN;\n\tif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\n\t\tetqf |= IXGBE_ETQF_POOL_ENABLE;\n\t\tetqf |= VMDQ_P(0) << IXGBE_ETQF_POOL_SHIFT;\n\t}\n\tIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FCOE), etqf);\n\tIXGBE_WRITE_REG(hw, IXGBE_ETQS(IXGBE_ETQF_FILTER_FCOE), 0);\n\n\t \n\tif (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))\n\t\treturn;\n\n\t \n\tfcreta_size = IXGBE_FCRETA_SIZE;\n\tif (adapter->hw.mac.type == ixgbe_mac_X550)\n\t\tfcreta_size = IXGBE_FCRETA_SIZE_X550;\n\n\tfor (i = 0; i < fcreta_size; i++) {\n\t\tif (adapter->hw.mac.type == ixgbe_mac_X550) {\n\t\t\tint fcoe_i_h = fcoe->offset + ((i + fcreta_size) %\n\t\t\t\t\t\t\tfcoe->indices);\n\t\t\tfcoe_q_h = adapter->rx_ring[fcoe_i_h]->reg_idx;\n\t\t\tfcoe_q_h = (fcoe_q_h << IXGBE_FCRETA_ENTRY_HIGH_SHIFT) &\n\t\t\t\t   IXGBE_FCRETA_ENTRY_HIGH_MASK;\n\t\t}\n\n\t\tfcoe_i = fcoe->offset + (i % fcoe->indices);\n\t\tfcoe_i &= IXGBE_FCRETA_ENTRY_MASK;\n\t\tfcoe_q = adapter->rx_ring[fcoe_i]->reg_idx;\n\t\tfcoe_q |= fcoe_q_h;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRETA(i), fcoe_q);\n\t}\n\tIXGBE_WRITE_REG(hw, IXGBE_FCRECTL, IXGBE_FCRECTL_ENA);\n\n\t \n\tetqf = ETH_P_FIP | IXGBE_ETQF_FILTER_EN;\n\tif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\n\t\tetqf |= IXGBE_ETQF_POOL_ENABLE;\n\t\tetqf |= VMDQ_P(0) << IXGBE_ETQF_POOL_SHIFT;\n\t}\n\tIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FIP), etqf);\n\n\t \n\tfcoe_q = adapter->rx_ring[fcoe->offset]->reg_idx;\n\tIXGBE_WRITE_REG(hw, IXGBE_ETQS(IXGBE_ETQF_FILTER_FIP),\n\t\t\tIXGBE_ETQS_QUEUE_EN |\n\t\t\t(fcoe_q << IXGBE_ETQS_RX_QUEUE_SHIFT));\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FCRXCTRL,\n\t\t\tIXGBE_FCRXCTRL_FCCRCBO |\n\t\t\t(FC_FCOE_VER << IXGBE_FCRXCTRL_FCOEVER_SHIFT));\n}\n\n \nvoid ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\n\tint cpu, i, ddp_max;\n\n\t \n\tif (!fcoe->ddp_pool)\n\t\treturn;\n\n\tddp_max = IXGBE_FCOE_DDP_MAX;\n\t \n\tif (adapter->hw.mac.type == ixgbe_mac_X550)\n\t\tddp_max = IXGBE_FCOE_DDP_MAX_X550;\n\n\tfor (i = 0; i < ddp_max; i++)\n\t\tixgbe_fcoe_ddp_put(adapter->netdev, i);\n\n\tfor_each_possible_cpu(cpu)\n\t\tixgbe_fcoe_dma_pool_free(fcoe, cpu);\n\n\tdma_unmap_single(&adapter->pdev->dev,\n\t\t\t fcoe->extra_ddp_buffer_dma,\n\t\t\t IXGBE_FCBUFF_MIN,\n\t\t\t DMA_FROM_DEVICE);\n\tkfree(fcoe->extra_ddp_buffer);\n\n\tfcoe->extra_ddp_buffer = NULL;\n\tfcoe->extra_ddp_buffer_dma = 0;\n}\n\n \nint ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\n\tstruct device *dev = &adapter->pdev->dev;\n\tvoid *buffer;\n\tdma_addr_t dma;\n\tunsigned int cpu;\n\n\t \n\tif (!fcoe->ddp_pool)\n\t\treturn 0;\n\n\t \n\tbuffer = kmalloc(IXGBE_FCBUFF_MIN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdma = dma_map_single(dev, buffer, IXGBE_FCBUFF_MIN, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, dma)) {\n\t\te_err(drv, \"failed to map extra DDP buffer\\n\");\n\t\tkfree(buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tfcoe->extra_ddp_buffer = buffer;\n\tfcoe->extra_ddp_buffer_dma = dma;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tint err = ixgbe_fcoe_dma_pool_alloc(fcoe, dev, cpu);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\te_err(drv, \"failed to alloc DDP pool on cpu:%d\\n\", cpu);\n\t\tixgbe_free_fcoe_ddp_resources(adapter);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\n\n\tif (!(adapter->flags & IXGBE_FLAG_FCOE_CAPABLE))\n\t\treturn -EINVAL;\n\n\tfcoe->ddp_pool = alloc_percpu(struct ixgbe_fcoe_ddp_pool);\n\n\tif (!fcoe->ddp_pool) {\n\t\te_err(drv, \"failed to allocate percpu DDP resources\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadapter->netdev->fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX - 1;\n\t \n\tif (adapter->hw.mac.type == ixgbe_mac_X550)\n\t\tadapter->netdev->fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX_X550 - 1;\n\n\treturn 0;\n}\n\nstatic void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\n\n\tadapter->netdev->fcoe_ddp_xid = 0;\n\n\tif (!fcoe->ddp_pool)\n\t\treturn;\n\n\tfree_percpu(fcoe->ddp_pool);\n\tfcoe->ddp_pool = NULL;\n}\n\n \nint ixgbe_fcoe_enable(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\n\n\tatomic_inc(&fcoe->refcnt);\n\n\tif (!(adapter->flags & IXGBE_FLAG_FCOE_CAPABLE))\n\t\treturn -EINVAL;\n\n\tif (adapter->flags & IXGBE_FLAG_FCOE_ENABLED)\n\t\treturn -EINVAL;\n\n\te_info(drv, \"Enabling FCoE offload features.\\n\");\n\n\tif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)\n\t\te_warn(probe, \"Enabling FCoE on PF will disable legacy VFs\\n\");\n\n\tif (netif_running(netdev))\n\t\tnetdev->netdev_ops->ndo_stop(netdev);\n\n\t \n\tixgbe_fcoe_ddp_enable(adapter);\n\n\t \n\tadapter->flags |= IXGBE_FLAG_FCOE_ENABLED;\n\tnetdev->features |= NETIF_F_FCOE_MTU;\n\tnetdev_features_change(netdev);\n\n\t \n\tixgbe_clear_interrupt_scheme(adapter);\n\tixgbe_init_interrupt_scheme(adapter);\n\n\tif (netif_running(netdev))\n\t\tnetdev->netdev_ops->ndo_open(netdev);\n\n\treturn 0;\n}\n\n \nint ixgbe_fcoe_disable(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (!atomic_dec_and_test(&adapter->fcoe.refcnt))\n\t\treturn -EINVAL;\n\n\tif (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))\n\t\treturn -EINVAL;\n\n\te_info(drv, \"Disabling FCoE offload features.\\n\");\n\tif (netif_running(netdev))\n\t\tnetdev->netdev_ops->ndo_stop(netdev);\n\n\t \n\tixgbe_fcoe_ddp_disable(adapter);\n\n\t \n\tadapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;\n\tnetdev->features &= ~NETIF_F_FCOE_MTU;\n\n\tnetdev_features_change(netdev);\n\n\t \n\tixgbe_clear_interrupt_scheme(adapter);\n\tixgbe_init_interrupt_scheme(adapter);\n\n\tif (netif_running(netdev))\n\t\tnetdev->netdev_ops->ndo_open(netdev);\n\n\treturn 0;\n}\n\n \nint ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)\n{\n\tu16 prefix = 0xffff;\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_mac_info *mac = &adapter->hw.mac;\n\n\tswitch (type) {\n\tcase NETDEV_FCOE_WWNN:\n\t\tprefix = mac->wwnn_prefix;\n\t\tbreak;\n\tcase NETDEV_FCOE_WWPN:\n\t\tprefix = mac->wwpn_prefix;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((prefix != 0xffff) &&\n\t    is_valid_ether_addr(mac->san_addr)) {\n\t\t*wwn = ((u64) prefix << 48) |\n\t\t       ((u64) mac->san_addr[0] << 40) |\n\t\t       ((u64) mac->san_addr[1] << 32) |\n\t\t       ((u64) mac->san_addr[2] << 24) |\n\t\t       ((u64) mac->san_addr[3] << 16) |\n\t\t       ((u64) mac->san_addr[4] << 8)  |\n\t\t       ((u64) mac->san_addr[5]);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nint ixgbe_fcoe_get_hbainfo(struct net_device *netdev,\n\t\t\t   struct netdev_fcoe_hbainfo *info)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu64 dsn;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\n\t \n\tif (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))\n\t\treturn -EINVAL;\n\n\t \n\tsnprintf(info->manufacturer, sizeof(info->manufacturer),\n\t\t \"Intel Corporation\");\n\n\t \n\n\t \n\tdsn = pci_get_dsn(adapter->pdev);\n\tif (dsn)\n\t\tsnprintf(info->serial_number, sizeof(info->serial_number),\n\t\t\t \"%016llX\", dsn);\n\telse\n\t\tsnprintf(info->serial_number, sizeof(info->serial_number),\n\t\t\t \"Unknown\");\n\n\t \n\tsnprintf(info->hardware_version,\n\t\t sizeof(info->hardware_version),\n\t\t \"Rev %d\", hw->revision_id);\n\t \n\tsnprintf(info->driver_version,\n\t\t sizeof(info->driver_version),\n\t\t \"%s v%s\",\n\t\t ixgbe_driver_name,\n\t\t UTS_RELEASE);\n\t \n\tstrscpy(info->firmware_version, adapter->eeprom_id,\n\t\tsizeof(info->firmware_version));\n\n\t \n\tif (hw->mac.type == ixgbe_mac_82599EB) {\n\t\tsnprintf(info->model,\n\t\t\t sizeof(info->model),\n\t\t\t \"Intel 82599\");\n\t} else if (hw->mac.type == ixgbe_mac_X550) {\n\t\tsnprintf(info->model,\n\t\t\t sizeof(info->model),\n\t\t\t \"Intel X550\");\n\t} else {\n\t\tsnprintf(info->model,\n\t\t\t sizeof(info->model),\n\t\t\t \"Intel X540\");\n\t}\n\n\t \n\tsnprintf(info->model_description,\n\t\t sizeof(info->model_description),\n\t\t \"%s\",\n\t\t ixgbe_default_device_descr);\n\n\treturn 0;\n}\n\n \nu8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter)\n{\n#ifdef CONFIG_IXGBE_DCB\n\treturn netdev_get_prio_tc_map(adapter->netdev, adapter->fcoe.up);\n#else\n\treturn 0;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}