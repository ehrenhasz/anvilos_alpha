{
  "module_name": "ixgbe_x540.c",
  "hash_id": "0fc6128c35b1bb7c18a0067a0a3d38e1f6514ed5e554e5c863a1fb6bd382a2ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n\n#include \"ixgbe.h\"\n#include \"ixgbe_phy.h\"\n#include \"ixgbe_x540.h\"\n\n#define IXGBE_X540_MAX_TX_QUEUES\t128\n#define IXGBE_X540_MAX_RX_QUEUES\t128\n#define IXGBE_X540_RAR_ENTRIES\t\t128\n#define IXGBE_X540_MC_TBL_SIZE\t\t128\n#define IXGBE_X540_VFT_TBL_SIZE\t\t128\n#define IXGBE_X540_RX_PB_SIZE\t\t384\n\nstatic s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw);\nstatic s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw);\nstatic s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw);\nstatic void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw);\n\nenum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw)\n{\n\treturn ixgbe_media_type_copper;\n}\n\ns32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\n\t \n\tphy->ops.set_phy_power = ixgbe_set_copper_phy_power;\n\n\tmac->mcft_size = IXGBE_X540_MC_TBL_SIZE;\n\tmac->vft_size = IXGBE_X540_VFT_TBL_SIZE;\n\tmac->num_rar_entries = IXGBE_X540_RAR_ENTRIES;\n\tmac->rx_pb_size = IXGBE_X540_RX_PB_SIZE;\n\tmac->max_rx_queues = IXGBE_X540_MAX_RX_QUEUES;\n\tmac->max_tx_queues = IXGBE_X540_MAX_TX_QUEUES;\n\tmac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed,\n\t\t\t      bool autoneg_wait_to_complete)\n{\n\treturn hw->phy.ops.setup_link_speed(hw, speed,\n\t\t\t\t\t    autoneg_wait_to_complete);\n}\n\n \ns32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu32 ctrl, i;\n\tu32 swfw_mask = hw->phy.phy_semaphore_mask;\n\n\t \n\tstatus = hw->mac.ops.stop_adapter(hw);\n\tif (status)\n\t\treturn status;\n\n\t \n\tixgbe_clear_tx_pending(hw);\n\nmac_reset_top:\n\tstatus = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);\n\tif (status) {\n\t\thw_dbg(hw, \"semaphore failed with %d\", status);\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\t}\n\n\tctrl = IXGBE_CTRL_RST;\n\tctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);\n\tIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\n\tIXGBE_WRITE_FLUSH(hw);\n\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\tusleep_range(1000, 1200);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\n\t\tif (!(ctrl & IXGBE_CTRL_RST_MASK))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (ctrl & IXGBE_CTRL_RST_MASK) {\n\t\tstatus = IXGBE_ERR_RESET_FAILED;\n\t\thw_dbg(hw, \"Reset polling failed to complete.\\n\");\n\t}\n\tmsleep(100);\n\n\t \n\tif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\n\t\thw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\n\t\tgoto mac_reset_top;\n\t}\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(0), 384 << IXGBE_RXPBSIZE_SHIFT);\n\n\t \n\thw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\n\n\t \n\thw->mac.num_rar_entries = IXGBE_X540_MAX_TX_QUEUES;\n\thw->mac.ops.init_rx_addrs(hw);\n\n\t \n\thw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);\n\n\t \n\tif (is_valid_ether_addr(hw->mac.san_addr)) {\n\t\t \n\t\thw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;\n\n\t\thw->mac.ops.set_rar(hw, hw->mac.san_mac_rar_index,\n\t\t\t\t    hw->mac.san_addr, 0, IXGBE_RAH_AV);\n\n\t\t \n\t\thw->mac.ops.clear_vmdq(hw, hw->mac.san_mac_rar_index,\n\t\t\t\t       IXGBE_CLEAR_VMDQ_ALL);\n\n\t\t \n\t\thw->mac.num_rar_entries--;\n\t}\n\n\t \n\thw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,\n\t\t\t\t   &hw->mac.wwpn_prefix);\n\n\treturn status;\n}\n\n \ns32 ixgbe_start_hw_X540(struct ixgbe_hw *hw)\n{\n\ts32 ret_val;\n\n\tret_val = ixgbe_start_hw_generic(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn ixgbe_start_hw_gen2(hw);\n}\n\n \ns32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eec;\n\tu16 eeprom_size;\n\n\tif (eeprom->type == ixgbe_eeprom_uninitialized) {\n\t\teeprom->semaphore_delay = 10;\n\t\teeprom->type = ixgbe_flash;\n\n\t\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\t\teeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>\n\t\t\t\t    IXGBE_EEC_SIZE_SHIFT);\n\t\teeprom->word_size = BIT(eeprom_size +\n\t\t\t\t\tIXGBE_EEPROM_WORD_SIZE_SHIFT);\n\n\t\thw_dbg(hw, \"Eeprom params: type = %d, size = %d\\n\",\n\t\t       eeprom->type, eeprom->word_size);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data)\n{\n\ts32 status;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = ixgbe_read_eerd_generic(hw, offset, data);\n\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw,\n\t\t\t\t       u16 offset, u16 words, u16 *data)\n{\n\ts32 status;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = ixgbe_read_eerd_buffer_generic(hw, offset, words, data);\n\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data)\n{\n\ts32 status;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = ixgbe_write_eewr_generic(hw, offset, data);\n\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw,\n\t\t\t\t\tu16 offset, u16 words, u16 *data)\n{\n\ts32 status;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = ixgbe_write_eewr_buffer_generic(hw, offset, words, data);\n\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)\n{\n\tu16 i;\n\tu16 j;\n\tu16 checksum = 0;\n\tu16 length = 0;\n\tu16 pointer = 0;\n\tu16 word = 0;\n\tu16 checksum_last_word = IXGBE_EEPROM_CHECKSUM;\n\tu16 ptr_start = IXGBE_PCIE_ANALOG_PTR;\n\n\t \n\n\t \n\tfor (i = 0; i < checksum_last_word; i++) {\n\t\tif (ixgbe_read_eerd_generic(hw, i, &word)) {\n\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\treturn IXGBE_ERR_EEPROM;\n\t\t}\n\t\tchecksum += word;\n\t}\n\n\t \n\tfor (i = ptr_start; i < IXGBE_FW_PTR; i++) {\n\t\tif (i == IXGBE_PHY_PTR || i == IXGBE_OPTION_ROM_PTR)\n\t\t\tcontinue;\n\n\t\tif (ixgbe_read_eerd_generic(hw, i, &pointer)) {\n\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (pointer == 0xFFFF || pointer == 0 ||\n\t\t    pointer >= hw->eeprom.word_size)\n\t\t\tcontinue;\n\n\t\tif (ixgbe_read_eerd_generic(hw, pointer, &length)) {\n\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\treturn IXGBE_ERR_EEPROM;\n\t\t}\n\n\t\t \n\t\tif (length == 0xFFFF || length == 0 ||\n\t\t    (pointer + length) >= hw->eeprom.word_size)\n\t\t\tcontinue;\n\n\t\tfor (j = pointer + 1; j <= pointer + length; j++) {\n\t\t\tif (ixgbe_read_eerd_generic(hw, j, &word)) {\n\t\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\t\treturn IXGBE_ERR_EEPROM;\n\t\t\t}\n\t\t\tchecksum += word;\n\t\t}\n\t}\n\n\tchecksum = (u16)IXGBE_EEPROM_SUM - checksum;\n\n\treturn (s32)checksum;\n}\n\n \nstatic s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,\n\t\t\t\t\t       u16 *checksum_val)\n{\n\ts32 status;\n\tu16 checksum;\n\tu16 read_checksum = 0;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, 0, &checksum);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = hw->eeprom.ops.calc_checksum(hw);\n\tif (status < 0)\n\t\tgoto out;\n\n\tchecksum = (u16)(status & 0xffff);\n\n\t \n\tstatus = ixgbe_read_eerd_generic(hw, IXGBE_EEPROM_CHECKSUM,\n\t\t\t\t\t &read_checksum);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tif (read_checksum != checksum) {\n\t\thw_dbg(hw, \"Invalid EEPROM checksum\");\n\t\tstatus = IXGBE_ERR_EEPROM_CHECKSUM;\n\t}\n\n\t \n\tif (checksum_val)\n\t\t*checksum_val = checksum;\n\nout:\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu16 checksum;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, 0, &checksum);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\n\t\treturn  IXGBE_ERR_SWFW_SYNC;\n\n\tstatus = hw->eeprom.ops.calc_checksum(hw);\n\tif (status < 0)\n\t\tgoto out;\n\n\tchecksum = (u16)(status & 0xffff);\n\n\t \n\tstatus = ixgbe_write_eewr_generic(hw, IXGBE_EEPROM_CHECKSUM, checksum);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = ixgbe_update_flash_X540(hw);\n\nout:\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)\n{\n\tu32 flup;\n\ts32 status;\n\n\tstatus = ixgbe_poll_flash_update_done_X540(hw);\n\tif (status == IXGBE_ERR_EEPROM) {\n\t\thw_dbg(hw, \"Flash update time out\\n\");\n\t\treturn status;\n\t}\n\n\tflup = IXGBE_READ_REG(hw, IXGBE_EEC(hw)) | IXGBE_EEC_FLUP;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), flup);\n\n\tstatus = ixgbe_poll_flash_update_done_X540(hw);\n\tif (status == 0)\n\t\thw_dbg(hw, \"Flash update complete\\n\");\n\telse\n\t\thw_dbg(hw, \"Flash update time out\\n\");\n\n\tif (hw->revision_id == 0) {\n\t\tflup = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\n\t\tif (flup & IXGBE_EEC_SEC1VAL) {\n\t\t\tflup |= IXGBE_EEC_FLUP;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), flup);\n\t\t}\n\n\t\tstatus = ixgbe_poll_flash_update_done_X540(hw);\n\t\tif (status == 0)\n\t\t\thw_dbg(hw, \"Flash update complete\\n\");\n\t\telse\n\t\t\thw_dbg(hw, \"Flash update time out\\n\");\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)\n{\n\tu32 i;\n\tu32 reg;\n\n\tfor (i = 0; i < IXGBE_FLUDONE_ATTEMPTS; i++) {\n\t\treg = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\t\tif (reg & IXGBE_EEC_FLUDONE)\n\t\t\treturn 0;\n\t\tudelay(5);\n\t}\n\treturn IXGBE_ERR_EEPROM;\n}\n\n \ns32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 swmask = mask & IXGBE_GSSR_NVM_PHY_MASK;\n\tu32 swi2c_mask = mask & IXGBE_GSSR_I2C_MASK;\n\tu32 fwmask = swmask << 5;\n\tu32 timeout = 200;\n\tu32 hwmask = 0;\n\tu32 swfw_sync;\n\tu32 i;\n\n\tif (swmask & IXGBE_GSSR_EEP_SM)\n\t\thwmask = IXGBE_GSSR_FLASH_SM;\n\n\t \n\tif (mask & IXGBE_GSSR_SW_MNG_SM)\n\t\tswmask |= IXGBE_GSSR_SW_MNG_SM;\n\n\tswmask |= swi2c_mask;\n\tfwmask |= swi2c_mask << 2;\n\tfor (i = 0; i < timeout; i++) {\n\t\t \n\t\tif (ixgbe_get_swfw_sync_semaphore(hw))\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\t\tswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\n\t\tif (!(swfw_sync & (fwmask | swmask | hwmask))) {\n\t\t\tswfw_sync |= swmask;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);\n\t\t\tixgbe_release_swfw_sync_semaphore(hw);\n\t\t\tusleep_range(5000, 6000);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tixgbe_release_swfw_sync_semaphore(hw);\n\t\tusleep_range(5000, 10000);\n\t}\n\n\t \n\tif (ixgbe_get_swfw_sync_semaphore(hw))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\tswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\n\tif (swfw_sync & (fwmask | hwmask)) {\n\t\tswfw_sync |= swmask;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);\n\t\tixgbe_release_swfw_sync_semaphore(hw);\n\t\tusleep_range(5000, 6000);\n\t\treturn 0;\n\t}\n\t \n\tif (swfw_sync & swmask) {\n\t\tu32 rmask = IXGBE_GSSR_EEP_SM | IXGBE_GSSR_PHY0_SM |\n\t\t\t    IXGBE_GSSR_PHY1_SM | IXGBE_GSSR_MAC_CSR_SM |\n\t\t\t    IXGBE_GSSR_SW_MNG_SM;\n\n\t\tif (swi2c_mask)\n\t\t\trmask |= IXGBE_GSSR_I2C_MASK;\n\t\tixgbe_release_swfw_sync_X540(hw, rmask);\n\t\tixgbe_release_swfw_sync_semaphore(hw);\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\t}\n\tixgbe_release_swfw_sync_semaphore(hw);\n\n\treturn IXGBE_ERR_SWFW_SYNC;\n}\n\n \nvoid ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 swmask = mask & (IXGBE_GSSR_NVM_PHY_MASK | IXGBE_GSSR_SW_MNG_SM);\n\tu32 swfw_sync;\n\n\tif (mask & IXGBE_GSSR_I2C_MASK)\n\t\tswmask |= mask & IXGBE_GSSR_I2C_MASK;\n\tixgbe_get_swfw_sync_semaphore(hw);\n\n\tswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\n\tswfw_sync &= ~swmask;\n\tIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);\n\n\tixgbe_release_swfw_sync_semaphore(hw);\n\tusleep_range(5000, 6000);\n}\n\n \nstatic s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)\n{\n\tu32 timeout = 2000;\n\tu32 i;\n\tu32 swsm;\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\t \n\t\tswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\n\t\tif (!(swsm & IXGBE_SWSM_SMBI))\n\t\t\tbreak;\n\t\tusleep_range(50, 100);\n\t}\n\n\tif (i == timeout) {\n\t\thw_dbg(hw,\n\t\t       \"Software semaphore SMBI between device drivers not granted.\\n\");\n\t\treturn IXGBE_ERR_EEPROM;\n\t}\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tswsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\n\t\tif (!(swsm & IXGBE_SWFW_REGSMP))\n\t\t\treturn 0;\n\n\t\tusleep_range(50, 100);\n\t}\n\n\t \n\thw_dbg(hw, \"REGSMP Software NVM semaphore not granted\\n\");\n\tixgbe_release_swfw_sync_semaphore(hw);\n\treturn IXGBE_ERR_EEPROM;\n}\n\n \nstatic void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)\n{\n\t u32 swsm;\n\n\t \n\n\tswsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\n\tswsm &= ~IXGBE_SWFW_REGSMP;\n\tIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swsm);\n\n\tswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\n\tswsm &= ~IXGBE_SWSM_SMBI;\n\tIXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nvoid ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw)\n{\n\tu32 rmask;\n\n\t \n\tixgbe_get_swfw_sync_semaphore(hw);\n\tixgbe_release_swfw_sync_semaphore(hw);\n\n\t \n\trmask = IXGBE_GSSR_EEP_SM | IXGBE_GSSR_PHY0_SM |\n\t\tIXGBE_GSSR_PHY1_SM | IXGBE_GSSR_MAC_CSR_SM |\n\t\tIXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_I2C_MASK;\n\n\tixgbe_acquire_swfw_sync_X540(hw, rmask);\n\tixgbe_release_swfw_sync_X540(hw, rmask);\n}\n\n \ns32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)\n{\n\tu32 macc_reg;\n\tu32 ledctl_reg;\n\tixgbe_link_speed speed;\n\tbool link_up;\n\n\tif (index > 3)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\thw->mac.ops.check_link(hw, &speed, &link_up, false);\n\tif (!link_up) {\n\t\tmacc_reg = IXGBE_READ_REG(hw, IXGBE_MACC);\n\t\tmacc_reg |= IXGBE_MACC_FLU | IXGBE_MACC_FSV_10G | IXGBE_MACC_FS;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);\n\t}\n\t \n\tledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\tledctl_reg &= ~IXGBE_LED_MODE_MASK(index);\n\tledctl_reg |= IXGBE_LED_BLINK(index);\n\tIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ledctl_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)\n{\n\tu32 macc_reg;\n\tu32 ledctl_reg;\n\n\tif (index > 3)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\tledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\tledctl_reg &= ~IXGBE_LED_MODE_MASK(index);\n\tledctl_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);\n\tledctl_reg &= ~IXGBE_LED_BLINK(index);\n\tIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ledctl_reg);\n\n\t \n\tmacc_reg = IXGBE_READ_REG(hw, IXGBE_MACC);\n\tmacc_reg &= ~(IXGBE_MACC_FLU | IXGBE_MACC_FSV_10G | IXGBE_MACC_FS);\n\tIXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\nstatic const struct ixgbe_mac_operations mac_ops_X540 = {\n\t.init_hw                = &ixgbe_init_hw_generic,\n\t.reset_hw               = &ixgbe_reset_hw_X540,\n\t.start_hw               = &ixgbe_start_hw_X540,\n\t.clear_hw_cntrs         = &ixgbe_clear_hw_cntrs_generic,\n\t.get_media_type         = &ixgbe_get_media_type_X540,\n\t.enable_rx_dma          = &ixgbe_enable_rx_dma_generic,\n\t.get_mac_addr           = &ixgbe_get_mac_addr_generic,\n\t.get_san_mac_addr       = &ixgbe_get_san_mac_addr_generic,\n\t.get_device_caps        = &ixgbe_get_device_caps_generic,\n\t.get_wwn_prefix         = &ixgbe_get_wwn_prefix_generic,\n\t.stop_adapter           = &ixgbe_stop_adapter_generic,\n\t.get_bus_info           = &ixgbe_get_bus_info_generic,\n\t.set_lan_id             = &ixgbe_set_lan_id_multi_port_pcie,\n\t.read_analog_reg8       = NULL,\n\t.write_analog_reg8      = NULL,\n\t.setup_link             = &ixgbe_setup_mac_link_X540,\n\t.set_rxpba\t\t= &ixgbe_set_rxpba_generic,\n\t.check_link             = &ixgbe_check_mac_link_generic,\n\t.get_link_capabilities  = &ixgbe_get_copper_link_capabilities_generic,\n\t.led_on                 = &ixgbe_led_on_generic,\n\t.led_off                = &ixgbe_led_off_generic,\n\t.init_led_link_act\t= ixgbe_init_led_link_act_generic,\n\t.blink_led_start        = &ixgbe_blink_led_start_X540,\n\t.blink_led_stop         = &ixgbe_blink_led_stop_X540,\n\t.set_rar                = &ixgbe_set_rar_generic,\n\t.clear_rar              = &ixgbe_clear_rar_generic,\n\t.set_vmdq               = &ixgbe_set_vmdq_generic,\n\t.set_vmdq_san_mac\t= &ixgbe_set_vmdq_san_mac_generic,\n\t.clear_vmdq             = &ixgbe_clear_vmdq_generic,\n\t.init_rx_addrs          = &ixgbe_init_rx_addrs_generic,\n\t.update_mc_addr_list    = &ixgbe_update_mc_addr_list_generic,\n\t.enable_mc              = &ixgbe_enable_mc_generic,\n\t.disable_mc             = &ixgbe_disable_mc_generic,\n\t.clear_vfta             = &ixgbe_clear_vfta_generic,\n\t.set_vfta               = &ixgbe_set_vfta_generic,\n\t.fc_enable              = &ixgbe_fc_enable_generic,\n\t.setup_fc\t\t= ixgbe_setup_fc_generic,\n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n\t.set_fw_drv_ver         = &ixgbe_set_fw_drv_ver_generic,\n\t.init_uta_tables        = &ixgbe_init_uta_tables_generic,\n\t.setup_sfp              = NULL,\n\t.set_mac_anti_spoofing  = &ixgbe_set_mac_anti_spoofing,\n\t.set_vlan_anti_spoofing = &ixgbe_set_vlan_anti_spoofing,\n\t.acquire_swfw_sync      = &ixgbe_acquire_swfw_sync_X540,\n\t.release_swfw_sync      = &ixgbe_release_swfw_sync_X540,\n\t.init_swfw_sync\t\t= &ixgbe_init_swfw_sync_X540,\n\t.disable_rx_buff\t= &ixgbe_disable_rx_buff_generic,\n\t.enable_rx_buff\t\t= &ixgbe_enable_rx_buff_generic,\n\t.get_thermal_sensor_data = NULL,\n\t.init_thermal_sensor_thresh = NULL,\n\t.prot_autoc_read\t= &prot_autoc_read_generic,\n\t.prot_autoc_write\t= &prot_autoc_write_generic,\n\t.enable_rx\t\t= &ixgbe_enable_rx_generic,\n\t.disable_rx\t\t= &ixgbe_disable_rx_generic,\n};\n\nstatic const struct ixgbe_eeprom_operations eeprom_ops_X540 = {\n\t.init_params            = &ixgbe_init_eeprom_params_X540,\n\t.read                   = &ixgbe_read_eerd_X540,\n\t.read_buffer\t\t= &ixgbe_read_eerd_buffer_X540,\n\t.write                  = &ixgbe_write_eewr_X540,\n\t.write_buffer\t\t= &ixgbe_write_eewr_buffer_X540,\n\t.calc_checksum\t\t= &ixgbe_calc_eeprom_checksum_X540,\n\t.validate_checksum      = &ixgbe_validate_eeprom_checksum_X540,\n\t.update_checksum        = &ixgbe_update_eeprom_checksum_X540,\n};\n\nstatic const struct ixgbe_phy_operations phy_ops_X540 = {\n\t.identify               = &ixgbe_identify_phy_generic,\n\t.identify_sfp           = &ixgbe_identify_sfp_module_generic,\n\t.init\t\t\t= NULL,\n\t.reset                  = NULL,\n\t.read_reg               = &ixgbe_read_phy_reg_generic,\n\t.write_reg              = &ixgbe_write_phy_reg_generic,\n\t.setup_link             = &ixgbe_setup_phy_link_generic,\n\t.setup_link_speed       = &ixgbe_setup_phy_link_speed_generic,\n\t.read_i2c_byte          = &ixgbe_read_i2c_byte_generic,\n\t.write_i2c_byte         = &ixgbe_write_i2c_byte_generic,\n\t.read_i2c_sff8472\t= &ixgbe_read_i2c_sff8472_generic,\n\t.read_i2c_eeprom        = &ixgbe_read_i2c_eeprom_generic,\n\t.write_i2c_eeprom       = &ixgbe_write_i2c_eeprom_generic,\n\t.check_overtemp         = &ixgbe_tn_check_overtemp,\n\t.set_phy_power          = &ixgbe_set_copper_phy_power,\n};\n\nstatic const u32 ixgbe_mvals_X540[IXGBE_MVALS_IDX_LIMIT] = {\n\tIXGBE_MVALS_INIT(X540)\n};\n\nconst struct ixgbe_info ixgbe_X540_info = {\n\t.mac                    = ixgbe_mac_X540,\n\t.get_invariants         = &ixgbe_get_invariants_X540,\n\t.mac_ops                = &mac_ops_X540,\n\t.eeprom_ops             = &eeprom_ops_X540,\n\t.phy_ops                = &phy_ops_X540,\n\t.mbx_ops                = &mbx_ops_generic,\n\t.mvals\t\t\t= ixgbe_mvals_X540,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}