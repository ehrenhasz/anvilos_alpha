{
  "module_name": "ixgbe_82598.c",
  "hash_id": "80838a41b6bfff75d5bbffd90d276cf0b4bbec04679f8093f5f7108c069484f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n\n#include \"ixgbe.h\"\n#include \"ixgbe_phy.h\"\n\n#define IXGBE_82598_MAX_TX_QUEUES 32\n#define IXGBE_82598_MAX_RX_QUEUES 64\n#define IXGBE_82598_RAR_ENTRIES   16\n#define IXGBE_82598_MC_TBL_SIZE  128\n#define IXGBE_82598_VFT_TBL_SIZE 128\n#define IXGBE_82598_RX_PB_SIZE\t 512\n\nstatic s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,\n\t\t\t\t\t ixgbe_link_speed speed,\n\t\t\t\t\t bool autoneg_wait_to_complete);\nstatic s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t       u8 *eeprom_data);\n\n \nstatic void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)\n{\n\tu32 gcr = IXGBE_READ_REG(hw, IXGBE_GCR);\n\tu16 pcie_devctl2;\n\n\tif (ixgbe_removed(hw->hw_addr))\n\t\treturn;\n\n\t \n\tif (gcr & IXGBE_GCR_CMPL_TMOUT_MASK)\n\t\tgoto out;\n\n\t \n\tif (!(gcr & IXGBE_GCR_CAP_VER2)) {\n\t\tgcr |= IXGBE_GCR_CMPL_TMOUT_10ms;\n\t\tgoto out;\n\t}\n\n\t \n\tpcie_devctl2 = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_CONTROL2);\n\tpcie_devctl2 |= IXGBE_PCI_DEVICE_CONTROL2_16ms;\n\tixgbe_write_pci_cfg_word(hw, IXGBE_PCI_DEVICE_CONTROL2, pcie_devctl2);\nout:\n\t \n\tgcr &= ~IXGBE_GCR_CMPL_TMOUT_RESEND;\n\tIXGBE_WRITE_REG(hw, IXGBE_GCR, gcr);\n}\n\nstatic s32 ixgbe_get_invariants_82598(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\n\t \n\tixgbe_identify_phy_generic(hw);\n\n\tmac->mcft_size = IXGBE_82598_MC_TBL_SIZE;\n\tmac->vft_size = IXGBE_82598_VFT_TBL_SIZE;\n\tmac->num_rar_entries = IXGBE_82598_RAR_ENTRIES;\n\tmac->rx_pb_size = IXGBE_82598_RX_PB_SIZE;\n\tmac->max_rx_queues = IXGBE_82598_MAX_RX_QUEUES;\n\tmac->max_tx_queues = IXGBE_82598_MAX_TX_QUEUES;\n\tmac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tstruct ixgbe_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 list_offset, data_offset;\n\n\t \n\tphy->ops.identify(hw);\n\n\t \n\tif (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {\n\t\tmac->ops.setup_link = &ixgbe_setup_copper_link_82598;\n\t\tmac->ops.get_link_capabilities =\n\t\t\t&ixgbe_get_copper_link_capabilities_generic;\n\t}\n\n\tswitch (hw->phy.type) {\n\tcase ixgbe_phy_tn:\n\t\tphy->ops.setup_link = &ixgbe_setup_phy_link_tnx;\n\t\tphy->ops.check_link = &ixgbe_check_phy_link_tnx;\n\t\tbreak;\n\tcase ixgbe_phy_nl:\n\t\tphy->ops.reset = &ixgbe_reset_phy_nl;\n\n\t\t \n\t\tret_val = phy->ops.identify_sfp(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tif (hw->phy.sfp_type == ixgbe_sfp_type_unknown)\n\t\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\n\t\t \n\t\tret_val = ixgbe_get_sfp_init_sequence_offsets(hw,\n\t\t\t\t\t\t\t    &list_offset,\n\t\t\t\t\t\t\t    &data_offset);\n\t\tif (ret_val)\n\t\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw)\n{\n\ts32 ret_val;\n\n\tret_val = ixgbe_start_hw_generic(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tixgbe_set_pcie_completion_timeout(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,\n\t\t\t\t\t     ixgbe_link_speed *speed,\n\t\t\t\t\t     bool *autoneg)\n{\n\tu32 autoc = 0;\n\n\t \n\tif (hw->mac.orig_link_settings_stored)\n\t\tautoc = hw->mac.orig_autoc;\n\telse\n\t\tautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\n\tswitch (autoc & IXGBE_AUTOC_LMS_MASK) {\n\tcase IXGBE_AUTOC_LMS_1G_LINK_NO_AN:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = false;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_10G_LINK_NO_AN:\n\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t\t*autoneg = false;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_1G_AN:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = true;\n\t\tbreak;\n\n\tcase IXGBE_AUTOC_LMS_KX4_AN:\n\tcase IXGBE_AUTOC_LMS_KX4_AN_1G_AN:\n\t\t*speed = IXGBE_LINK_SPEED_UNKNOWN;\n\t\tif (autoc & IXGBE_AUTOC_KX4_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_10GB_FULL;\n\t\tif (autoc & IXGBE_AUTOC_KX_SUPP)\n\t\t\t*speed |= IXGBE_LINK_SPEED_1GB_FULL;\n\t\t*autoneg = true;\n\t\tbreak;\n\n\tdefault:\n\t\treturn IXGBE_ERR_LINK_SETUP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)\n{\n\t \n\tswitch (hw->phy.type) {\n\tcase ixgbe_phy_cu_unknown:\n\tcase ixgbe_phy_tn:\n\t\treturn ixgbe_media_type_copper;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_82598:\n\tcase IXGBE_DEV_ID_82598_BX:\n\t\t \n\t\treturn ixgbe_media_type_backplane;\n\n\tcase IXGBE_DEV_ID_82598AF_DUAL_PORT:\n\tcase IXGBE_DEV_ID_82598AF_SINGLE_PORT:\n\tcase IXGBE_DEV_ID_82598_DA_DUAL_PORT:\n\tcase IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:\n\tcase IXGBE_DEV_ID_82598EB_XF_LR:\n\tcase IXGBE_DEV_ID_82598EB_SFP_LOM:\n\t\treturn ixgbe_media_type_fiber;\n\n\tcase IXGBE_DEV_ID_82598EB_CX4:\n\tcase IXGBE_DEV_ID_82598_CX4_DUAL_PORT:\n\t\treturn ixgbe_media_type_cx4;\n\n\tcase IXGBE_DEV_ID_82598AT:\n\tcase IXGBE_DEV_ID_82598AT2:\n\t\treturn ixgbe_media_type_copper;\n\n\tdefault:\n\t\treturn ixgbe_media_type_unknown;\n\t}\n}\n\n \nstatic s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)\n{\n\tu32 fctrl_reg;\n\tu32 rmcs_reg;\n\tu32 reg;\n\tu32 fcrtl, fcrth;\n\tu32 link_speed = 0;\n\tint i;\n\tbool link_up;\n\n\t \n\tif (!hw->fc.pause_time)\n\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\n\t \n\tfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\n\t\tif ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&\n\t\t    hw->fc.high_water[i]) {\n\t\t\tif (!hw->fc.low_water[i] ||\n\t\t\t    hw->fc.low_water[i] >= hw->fc.high_water[i]) {\n\t\t\t\thw_dbg(hw, \"Invalid water mark configuration\\n\");\n\t\t\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\thw->mac.ops.check_link(hw, &link_speed, &link_up, false);\n\tif (link_up && link_speed == IXGBE_LINK_SPEED_1GB_FULL) {\n\t\tswitch (hw->fc.requested_mode) {\n\t\tcase ixgbe_fc_full:\n\t\t\thw->fc.requested_mode = ixgbe_fc_tx_pause;\n\t\t\tbreak;\n\t\tcase ixgbe_fc_rx_pause:\n\t\t\thw->fc.requested_mode = ixgbe_fc_none;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\thw->mac.ops.fc_autoneg(hw);\n\n\t \n\tfctrl_reg = IXGBE_READ_REG(hw, IXGBE_FCTRL);\n\tfctrl_reg &= ~(IXGBE_FCTRL_RFCE | IXGBE_FCTRL_RPFCE);\n\n\trmcs_reg = IXGBE_READ_REG(hw, IXGBE_RMCS);\n\trmcs_reg &= ~(IXGBE_RMCS_TFCE_PRIORITY | IXGBE_RMCS_TFCE_802_3X);\n\n\t \n\tswitch (hw->fc.current_mode) {\n\tcase ixgbe_fc_none:\n\t\t \n\t\tbreak;\n\tcase ixgbe_fc_rx_pause:\n\t\t \n\t\tfctrl_reg |= IXGBE_FCTRL_RFCE;\n\t\tbreak;\n\tcase ixgbe_fc_tx_pause:\n\t\t \n\t\trmcs_reg |= IXGBE_RMCS_TFCE_802_3X;\n\t\tbreak;\n\tcase ixgbe_fc_full:\n\t\t \n\t\tfctrl_reg |= IXGBE_FCTRL_RFCE;\n\t\trmcs_reg |= IXGBE_RMCS_TFCE_802_3X;\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \"Flow control param set incorrectly\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\t \n\tfctrl_reg |= IXGBE_FCTRL_DPF;\n\tIXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl_reg);\n\tIXGBE_WRITE_REG(hw, IXGBE_RMCS, rmcs_reg);\n\n\t \n\tfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\n\t\tif ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&\n\t\t    hw->fc.high_water[i]) {\n\t\t\tfcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;\n\t\t\tfcrth = (hw->fc.high_water[i] << 10) | IXGBE_FCRTH_FCEN;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRTL(i), fcrtl);\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRTH(i), fcrth);\n\t\t} else {\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRTL(i), 0);\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRTH(i), 0);\n\t\t}\n\n\t}\n\n\t \n\treg = hw->fc.pause_time * 0x00010001;\n\tfor (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,\n\t\t\t\t      bool autoneg_wait_to_complete)\n{\n\tu32 autoc_reg;\n\tu32 links_reg;\n\tu32 i;\n\ts32 status = 0;\n\n\t \n\tautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tautoc_reg |= IXGBE_AUTOC_AN_RESTART;\n\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);\n\n\t \n\tif (autoneg_wait_to_complete) {\n\t\tif ((autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\n\t\t     IXGBE_AUTOC_LMS_KX4_AN ||\n\t\t    (autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\n\t\t     IXGBE_AUTOC_LMS_KX4_AN_1G_AN) {\n\t\t\tlinks_reg = 0;  \n\t\t\tfor (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {\n\t\t\t\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\t\t\t\tif (links_reg & IXGBE_LINKS_KX_AN_COMP)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(100);\n\t\t\t}\n\t\t\tif (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {\n\t\t\t\tstatus = IXGBE_ERR_AUTONEG_NOT_COMPLETE;\n\t\t\t\thw_dbg(hw, \"Autonegotiation did not complete.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmsleep(50);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw)\n{\n\tu32 timeout;\n\tu16 an_reg;\n\n\tif (hw->device_id != IXGBE_DEV_ID_82598AT2)\n\t\treturn 0;\n\n\tfor (timeout = 0;\n\t     timeout < IXGBE_VALIDATE_LINK_READY_TIMEOUT; timeout++) {\n\t\thw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN, &an_reg);\n\n\t\tif ((an_reg & MDIO_AN_STAT1_COMPLETE) &&\n\t\t    (an_reg & MDIO_STAT1_LSTATUS))\n\t\t\tbreak;\n\n\t\tmsleep(100);\n\t}\n\n\tif (timeout == IXGBE_VALIDATE_LINK_READY_TIMEOUT) {\n\t\thw_dbg(hw, \"Link was indicated but link is down\\n\");\n\t\treturn IXGBE_ERR_LINK_SETUP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,\n\t\t\t\t      ixgbe_link_speed *speed, bool *link_up,\n\t\t\t\t      bool link_up_wait_to_complete)\n{\n\tu32 links_reg;\n\tu32 i;\n\tu16 link_reg, adapt_comp_reg;\n\n\t \n\tif (hw->phy.type == ixgbe_phy_nl) {\n\t\thw->phy.ops.read_reg(hw, 0xC79F, MDIO_MMD_PMAPMD, &link_reg);\n\t\thw->phy.ops.read_reg(hw, 0xC79F, MDIO_MMD_PMAPMD, &link_reg);\n\t\thw->phy.ops.read_reg(hw, 0xC00C, MDIO_MMD_PMAPMD,\n\t\t\t\t     &adapt_comp_reg);\n\t\tif (link_up_wait_to_complete) {\n\t\t\tfor (i = 0; i < IXGBE_LINK_UP_TIME; i++) {\n\t\t\t\tif ((link_reg & 1) &&\n\t\t\t\t    ((adapt_comp_reg & 1) == 0)) {\n\t\t\t\t\t*link_up = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t*link_up = false;\n\t\t\t\t}\n\t\t\t\tmsleep(100);\n\t\t\t\thw->phy.ops.read_reg(hw, 0xC79F,\n\t\t\t\t\t\t     MDIO_MMD_PMAPMD,\n\t\t\t\t\t\t     &link_reg);\n\t\t\t\thw->phy.ops.read_reg(hw, 0xC00C,\n\t\t\t\t\t\t     MDIO_MMD_PMAPMD,\n\t\t\t\t\t\t     &adapt_comp_reg);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((link_reg & 1) && ((adapt_comp_reg & 1) == 0))\n\t\t\t\t*link_up = true;\n\t\t\telse\n\t\t\t\t*link_up = false;\n\t\t}\n\n\t\tif (!*link_up)\n\t\t\treturn 0;\n\t}\n\n\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\tif (link_up_wait_to_complete) {\n\t\tfor (i = 0; i < IXGBE_LINK_UP_TIME; i++) {\n\t\t\tif (links_reg & IXGBE_LINKS_UP) {\n\t\t\t\t*link_up = true;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t*link_up = false;\n\t\t\t}\n\t\t\tmsleep(100);\n\t\t\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\t\t}\n\t} else {\n\t\tif (links_reg & IXGBE_LINKS_UP)\n\t\t\t*link_up = true;\n\t\telse\n\t\t\t*link_up = false;\n\t}\n\n\tif (links_reg & IXGBE_LINKS_SPEED)\n\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\telse\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\n\tif ((hw->device_id == IXGBE_DEV_ID_82598AT2) && *link_up &&\n\t    (ixgbe_validate_link_ready(hw) != 0))\n\t\t*link_up = false;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,\n\t\t\t\t      ixgbe_link_speed speed,\n\t\t\t\t      bool autoneg_wait_to_complete)\n{\n\tbool\t\t autoneg\t   = false;\n\tixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;\n\tu32              curr_autoc        = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tu32              autoc             = curr_autoc;\n\tu32              link_mode         = autoc & IXGBE_AUTOC_LMS_MASK;\n\n\t \n\tixgbe_get_link_capabilities_82598(hw, &link_capabilities, &autoneg);\n\tspeed &= link_capabilities;\n\n\tif (speed == IXGBE_LINK_SPEED_UNKNOWN)\n\t\treturn IXGBE_ERR_LINK_SETUP;\n\n\t \n\telse if (link_mode == IXGBE_AUTOC_LMS_KX4_AN ||\n\t\t link_mode == IXGBE_AUTOC_LMS_KX4_AN_1G_AN) {\n\t\tautoc &= ~IXGBE_AUTOC_KX4_KX_SUPP_MASK;\n\t\tif (speed & IXGBE_LINK_SPEED_10GB_FULL)\n\t\t\tautoc |= IXGBE_AUTOC_KX4_SUPP;\n\t\tif (speed & IXGBE_LINK_SPEED_1GB_FULL)\n\t\t\tautoc |= IXGBE_AUTOC_KX_SUPP;\n\t\tif (autoc != curr_autoc)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);\n\t}\n\n\t \n\treturn ixgbe_start_mac_link_82598(hw, autoneg_wait_to_complete);\n}\n\n\n \nstatic s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,\n\t\t\t\t\t       ixgbe_link_speed speed,\n\t\t\t\t\t       bool autoneg_wait_to_complete)\n{\n\ts32 status;\n\n\t \n\tstatus = hw->phy.ops.setup_link_speed(hw, speed,\n\t\t\t\t\t      autoneg_wait_to_complete);\n\t \n\tixgbe_start_mac_link_82598(hw, autoneg_wait_to_complete);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\ts32 phy_status = 0;\n\tu32 ctrl;\n\tu32 gheccr;\n\tu32 i;\n\tu32 autoc;\n\tu8  analog_val;\n\n\t \n\tstatus = hw->mac.ops.stop_adapter(hw);\n\tif (status)\n\t\treturn status;\n\n\t \n\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &analog_val);\n\tif (analog_val & IXGBE_ATLAS_PDN_TX_REG_EN) {\n\t\t \n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK,\n\t\t\t\t\t     &analog_val);\n\t\tanalog_val &= ~IXGBE_ATLAS_PDN_TX_REG_EN;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK,\n\t\t\t\t\t      analog_val);\n\n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G,\n\t\t\t\t\t     &analog_val);\n\t\tanalog_val &= ~IXGBE_ATLAS_PDN_TX_10G_QL_ALL;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G,\n\t\t\t\t\t      analog_val);\n\n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G,\n\t\t\t\t\t     &analog_val);\n\t\tanalog_val &= ~IXGBE_ATLAS_PDN_TX_1G_QL_ALL;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G,\n\t\t\t\t\t      analog_val);\n\n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN,\n\t\t\t\t\t     &analog_val);\n\t\tanalog_val &= ~IXGBE_ATLAS_PDN_TX_AN_QL_ALL;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN,\n\t\t\t\t\t      analog_val);\n\t}\n\n\t \n\tif (hw->phy.reset_disable == false) {\n\t\t \n\n\t\t \n\t\tphy_status = hw->phy.ops.init(hw);\n\t\tif (phy_status == IXGBE_ERR_SFP_NOT_SUPPORTED)\n\t\t\treturn phy_status;\n\t\tif (phy_status == IXGBE_ERR_SFP_NOT_PRESENT)\n\t\t\tgoto mac_reset_top;\n\n\t\thw->phy.ops.reset(hw);\n\t}\n\nmac_reset_top:\n\t \n\tctrl = IXGBE_READ_REG(hw, IXGBE_CTRL) | IXGBE_CTRL_RST;\n\tIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\n\tIXGBE_WRITE_FLUSH(hw);\n\tusleep_range(1000, 1200);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\n\t\tif (!(ctrl & IXGBE_CTRL_RST))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (ctrl & IXGBE_CTRL_RST) {\n\t\tstatus = IXGBE_ERR_RESET_FAILED;\n\t\thw_dbg(hw, \"Reset polling failed to complete.\\n\");\n\t}\n\n\tmsleep(50);\n\n\t \n\tif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\n\t\thw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\n\t\tgoto mac_reset_top;\n\t}\n\n\tgheccr = IXGBE_READ_REG(hw, IXGBE_GHECCR);\n\tgheccr &= ~(BIT(21) | BIT(18) | BIT(9) | BIT(6));\n\tIXGBE_WRITE_REG(hw, IXGBE_GHECCR, gheccr);\n\n\t \n\tautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tif (hw->mac.orig_link_settings_stored == false) {\n\t\thw->mac.orig_autoc = autoc;\n\t\thw->mac.orig_link_settings_stored = true;\n\t} else if (autoc != hw->mac.orig_autoc) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC, hw->mac.orig_autoc);\n\t}\n\n\t \n\thw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\n\n\t \n\thw->mac.ops.init_rx_addrs(hw);\n\n\tif (phy_status)\n\t\tstatus = phy_status;\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\n{\n\tu32 rar_high;\n\tu32 rar_entries = hw->mac.num_rar_entries;\n\n\t \n\tif (rar >= rar_entries) {\n\t\thw_dbg(hw, \"RAR index %d is out of range.\\n\", rar);\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\trar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));\n\trar_high &= ~IXGBE_RAH_VIND_MASK;\n\trar_high |= ((vmdq << IXGBE_RAH_VIND_SHIFT) & IXGBE_RAH_VIND_MASK);\n\tIXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\n{\n\tu32 rar_high;\n\tu32 rar_entries = hw->mac.num_rar_entries;\n\n\n\t \n\tif (rar >= rar_entries) {\n\t\thw_dbg(hw, \"RAR index %d is out of range.\\n\", rar);\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\trar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));\n\tif (rar_high & IXGBE_RAH_VIND_MASK) {\n\t\trar_high &= ~IXGBE_RAH_VIND_MASK;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind,\n\t\t\t\tbool vlan_on, bool vlvf_bypass)\n{\n\tu32 regindex;\n\tu32 bitindex;\n\tu32 bits;\n\tu32 vftabyte;\n\n\tif (vlan > 4095)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\tregindex = (vlan >> 5) & 0x7F;    \n\n\t \n\tvftabyte =  ((vlan >> 3) & 0x03);  \n\tbitindex = (vlan & 0x7) << 2;     \n\n\t \n\tbits = IXGBE_READ_REG(hw, IXGBE_VFTAVIND(vftabyte, regindex));\n\tbits &= (~(0x0F << bitindex));\n\tbits |= (vind << bitindex);\n\tIXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vftabyte, regindex), bits);\n\n\t \n\tbitindex = vlan & 0x1F;    \n\n\tbits = IXGBE_READ_REG(hw, IXGBE_VFTA(regindex));\n\tif (vlan_on)\n\t\t \n\t\tbits |= BIT(bitindex);\n\telse\n\t\t \n\t\tbits &= ~BIT(bitindex);\n\tIXGBE_WRITE_REG(hw, IXGBE_VFTA(regindex), bits);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)\n{\n\tu32 offset;\n\tu32 vlanbyte;\n\n\tfor (offset = 0; offset < hw->mac.vft_size; offset++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);\n\n\tfor (vlanbyte = 0; vlanbyte < 4; vlanbyte++)\n\t\tfor (offset = 0; offset < hw->mac.vft_size; offset++)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vlanbyte, offset),\n\t\t\t\t\t0);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val)\n{\n\tu32  atlas_ctl;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_ATLASCTL,\n\t\t\tIXGBE_ATLASCTL_WRITE_CMD | (reg << 8));\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(10);\n\tatlas_ctl = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);\n\t*val = (u8)atlas_ctl;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val)\n{\n\tu32  atlas_ctl;\n\n\tatlas_ctl = (reg << 8) | val;\n\tIXGBE_WRITE_REG(hw, IXGBE_ATLASCTL, atlas_ctl);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(10);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, u8 dev_addr,\n\t\t\t\t    u8 byte_offset, u8 *eeprom_data)\n{\n\ts32 status = 0;\n\tu16 sfp_addr = 0;\n\tu16 sfp_data = 0;\n\tu16 sfp_stat = 0;\n\tu16 gssr;\n\tu32 i;\n\n\tif (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1)\n\t\tgssr = IXGBE_GSSR_PHY1_SM;\n\telse\n\t\tgssr = IXGBE_GSSR_PHY0_SM;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, gssr) != 0)\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tif (hw->phy.type == ixgbe_phy_nl) {\n\t\t \n\t\tsfp_addr = (dev_addr << 8) + byte_offset;\n\t\tsfp_addr = (sfp_addr | IXGBE_I2C_EEPROM_READ_MASK);\n\t\thw->phy.ops.write_reg_mdi(hw,\n\t\t\t\t\t  IXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR,\n\t\t\t\t\t  MDIO_MMD_PMAPMD,\n\t\t\t\t\t  sfp_addr);\n\n\t\t \n\t\tfor (i = 0; i < 100; i++) {\n\t\t\thw->phy.ops.read_reg_mdi(hw,\n\t\t\t\t\t\tIXGBE_MDIO_PMA_PMD_SDA_SCL_STAT,\n\t\t\t\t\t\tMDIO_MMD_PMAPMD,\n\t\t\t\t\t\t&sfp_stat);\n\t\t\tsfp_stat = sfp_stat & IXGBE_I2C_EEPROM_STATUS_MASK;\n\t\t\tif (sfp_stat != IXGBE_I2C_EEPROM_STATUS_IN_PROGRESS)\n\t\t\t\tbreak;\n\t\t\tusleep_range(10000, 20000);\n\t\t}\n\n\t\tif (sfp_stat != IXGBE_I2C_EEPROM_STATUS_PASS) {\n\t\t\thw_dbg(hw, \"EEPROM read did not pass.\\n\");\n\t\t\tstatus = IXGBE_ERR_SFP_NOT_PRESENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\thw->phy.ops.read_reg_mdi(hw, IXGBE_MDIO_PMA_PMD_SDA_SCL_DATA,\n\t\t\t\t\tMDIO_MMD_PMAPMD, &sfp_data);\n\n\t\t*eeprom_data = (u8)(sfp_data >> 8);\n\t} else {\n\t\tstatus = IXGBE_ERR_PHY;\n\t}\n\nout:\n\thw->mac.ops.release_swfw_sync(hw, gssr);\n\treturn status;\n}\n\n \nstatic s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t       u8 *eeprom_data)\n{\n\treturn ixgbe_read_i2c_phy_82598(hw, IXGBE_I2C_EEPROM_DEV_ADDR,\n\t\t\t\t\tbyte_offset, eeprom_data);\n}\n\n \nstatic s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t       u8 *sff8472_data)\n{\n\treturn ixgbe_read_i2c_phy_82598(hw, IXGBE_I2C_EEPROM_DEV_ADDR2,\n\t\t\t\t\tbyte_offset, sff8472_data);\n}\n\n \nstatic void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_bus_info *bus = &hw->bus;\n\tu16 pci_gen = 0;\n\tu16 pci_ctrl2 = 0;\n\n\tixgbe_set_lan_id_multi_port_pcie(hw);\n\n\t \n\thw->eeprom.ops.read(hw, IXGBE_PCIE_GENERAL_PTR, &pci_gen);\n\tif ((pci_gen != 0) && (pci_gen != 0xFFFF)) {\n\n\t\thw->eeprom.ops.read(hw, pci_gen + IXGBE_PCIE_CTRL2, &pci_ctrl2);\n\n\t\t \n\t\tif ((pci_ctrl2 & IXGBE_PCIE_CTRL2_LAN_DISABLE) &&\n\t\t    !(pci_ctrl2 & IXGBE_PCIE_CTRL2_DISABLE_SELECT) &&\n\t\t    !(pci_ctrl2 & IXGBE_PCIE_CTRL2_DUMMY_ENABLE)) {\n\n\t\t\tbus->func = 0;\n\t\t}\n\t}\n}\n\n \nstatic void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,\n\t\t\t\t  u32 headroom, int strategy)\n{\n\tu32 rxpktsize = IXGBE_RXPBSIZE_64KB;\n\tu8  i = 0;\n\n\tif (!num_pb)\n\t\treturn;\n\n\t \n\tswitch (strategy) {\n\tcase PBA_STRATEGY_WEIGHTED:\n\t\t \n\t\trxpktsize = IXGBE_RXPBSIZE_80KB;\n\t\tfor (; i < 4; i++)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\n\t\t \n\t\trxpktsize = IXGBE_RXPBSIZE_48KB;\n\t\tfallthrough;\n\tcase PBA_STRATEGY_EQUAL:\n\tdefault:\n\t\t \n\t\tfor (; i < IXGBE_MAX_PACKET_BUFFERS; i++)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), IXGBE_TXPBSIZE_40KB);\n}\n\nstatic const struct ixgbe_mac_operations mac_ops_82598 = {\n\t.init_hw\t\t= &ixgbe_init_hw_generic,\n\t.reset_hw\t\t= &ixgbe_reset_hw_82598,\n\t.start_hw\t\t= &ixgbe_start_hw_82598,\n\t.clear_hw_cntrs\t\t= &ixgbe_clear_hw_cntrs_generic,\n\t.get_media_type\t\t= &ixgbe_get_media_type_82598,\n\t.enable_rx_dma          = &ixgbe_enable_rx_dma_generic,\n\t.get_mac_addr\t\t= &ixgbe_get_mac_addr_generic,\n\t.stop_adapter\t\t= &ixgbe_stop_adapter_generic,\n\t.get_bus_info           = &ixgbe_get_bus_info_generic,\n\t.set_lan_id             = &ixgbe_set_lan_id_multi_port_pcie_82598,\n\t.read_analog_reg8\t= &ixgbe_read_analog_reg8_82598,\n\t.write_analog_reg8\t= &ixgbe_write_analog_reg8_82598,\n\t.setup_link\t\t= &ixgbe_setup_mac_link_82598,\n\t.set_rxpba\t\t= &ixgbe_set_rxpba_82598,\n\t.check_link\t\t= &ixgbe_check_mac_link_82598,\n\t.get_link_capabilities\t= &ixgbe_get_link_capabilities_82598,\n\t.led_on\t\t\t= &ixgbe_led_on_generic,\n\t.led_off\t\t= &ixgbe_led_off_generic,\n\t.init_led_link_act\t= ixgbe_init_led_link_act_generic,\n\t.blink_led_start\t= &ixgbe_blink_led_start_generic,\n\t.blink_led_stop\t\t= &ixgbe_blink_led_stop_generic,\n\t.set_rar\t\t= &ixgbe_set_rar_generic,\n\t.clear_rar\t\t= &ixgbe_clear_rar_generic,\n\t.set_vmdq\t\t= &ixgbe_set_vmdq_82598,\n\t.clear_vmdq\t\t= &ixgbe_clear_vmdq_82598,\n\t.init_rx_addrs\t\t= &ixgbe_init_rx_addrs_generic,\n\t.update_mc_addr_list\t= &ixgbe_update_mc_addr_list_generic,\n\t.enable_mc\t\t= &ixgbe_enable_mc_generic,\n\t.disable_mc\t\t= &ixgbe_disable_mc_generic,\n\t.clear_vfta\t\t= &ixgbe_clear_vfta_82598,\n\t.set_vfta\t\t= &ixgbe_set_vfta_82598,\n\t.fc_enable\t\t= &ixgbe_fc_enable_82598,\n\t.setup_fc\t\t= ixgbe_setup_fc_generic,\n\t.fc_autoneg\t\t= ixgbe_fc_autoneg,\n\t.set_fw_drv_ver         = NULL,\n\t.acquire_swfw_sync      = &ixgbe_acquire_swfw_sync,\n\t.release_swfw_sync      = &ixgbe_release_swfw_sync,\n\t.init_swfw_sync\t\t= NULL,\n\t.get_thermal_sensor_data = NULL,\n\t.init_thermal_sensor_thresh = NULL,\n\t.prot_autoc_read\t= &prot_autoc_read_generic,\n\t.prot_autoc_write\t= &prot_autoc_write_generic,\n\t.enable_rx\t\t= &ixgbe_enable_rx_generic,\n\t.disable_rx\t\t= &ixgbe_disable_rx_generic,\n};\n\nstatic const struct ixgbe_eeprom_operations eeprom_ops_82598 = {\n\t.init_params\t\t= &ixgbe_init_eeprom_params_generic,\n\t.read\t\t\t= &ixgbe_read_eerd_generic,\n\t.write\t\t\t= &ixgbe_write_eeprom_generic,\n\t.write_buffer\t\t= &ixgbe_write_eeprom_buffer_bit_bang_generic,\n\t.read_buffer\t\t= &ixgbe_read_eerd_buffer_generic,\n\t.calc_checksum          = &ixgbe_calc_eeprom_checksum_generic,\n\t.validate_checksum\t= &ixgbe_validate_eeprom_checksum_generic,\n\t.update_checksum\t= &ixgbe_update_eeprom_checksum_generic,\n};\n\nstatic const struct ixgbe_phy_operations phy_ops_82598 = {\n\t.identify\t\t= &ixgbe_identify_phy_generic,\n\t.identify_sfp\t\t= &ixgbe_identify_module_generic,\n\t.init\t\t\t= &ixgbe_init_phy_ops_82598,\n\t.reset\t\t\t= &ixgbe_reset_phy_generic,\n\t.read_reg\t\t= &ixgbe_read_phy_reg_generic,\n\t.write_reg\t\t= &ixgbe_write_phy_reg_generic,\n\t.read_reg_mdi\t\t= &ixgbe_read_phy_reg_mdi,\n\t.write_reg_mdi\t\t= &ixgbe_write_phy_reg_mdi,\n\t.setup_link\t\t= &ixgbe_setup_phy_link_generic,\n\t.setup_link_speed\t= &ixgbe_setup_phy_link_speed_generic,\n\t.read_i2c_sff8472\t= &ixgbe_read_i2c_sff8472_82598,\n\t.read_i2c_eeprom\t= &ixgbe_read_i2c_eeprom_82598,\n\t.check_overtemp\t\t= &ixgbe_tn_check_overtemp,\n};\n\nconst struct ixgbe_info ixgbe_82598_info = {\n\t.mac\t\t\t= ixgbe_mac_82598EB,\n\t.get_invariants\t\t= &ixgbe_get_invariants_82598,\n\t.mac_ops\t\t= &mac_ops_82598,\n\t.eeprom_ops\t\t= &eeprom_ops_82598,\n\t.phy_ops\t\t= &phy_ops_82598,\n\t.mvals\t\t\t= ixgbe_mvals_8259X,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}