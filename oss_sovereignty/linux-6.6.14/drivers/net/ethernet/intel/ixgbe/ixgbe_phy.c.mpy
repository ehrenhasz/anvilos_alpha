{
  "module_name": "ixgbe_phy.c",
  "hash_id": "68f43aaa8f77183eb2f0c2f8ea4b015d85ca3a01ad4743e417f178236db80185",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/sched.h>\n\n#include \"ixgbe.h\"\n#include \"ixgbe_phy.h\"\n\nstatic void ixgbe_i2c_start(struct ixgbe_hw *hw);\nstatic void ixgbe_i2c_stop(struct ixgbe_hw *hw);\nstatic s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data);\nstatic s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data);\nstatic s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw);\nstatic s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data);\nstatic s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data);\nstatic void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);\nstatic void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);\nstatic s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data);\nstatic bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl);\nstatic void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw);\nstatic enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id);\nstatic s32 ixgbe_get_phy_id(struct ixgbe_hw *hw);\nstatic s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw);\n\n \nstatic s32 ixgbe_out_i2c_byte_ack(struct ixgbe_hw *hw, u8 byte)\n{\n\ts32 status;\n\n\tstatus = ixgbe_clock_out_i2c_byte(hw, byte);\n\tif (status)\n\t\treturn status;\n\treturn ixgbe_get_i2c_ack(hw);\n}\n\n \nstatic s32 ixgbe_in_i2c_byte_ack(struct ixgbe_hw *hw, u8 *byte)\n{\n\ts32 status;\n\n\tstatus = ixgbe_clock_in_i2c_byte(hw, byte);\n\tif (status)\n\t\treturn status;\n\t \n\treturn ixgbe_clock_out_i2c_bit(hw, false);\n}\n\n \nstatic u8 ixgbe_ones_comp_byte_add(u8 add1, u8 add2)\n{\n\tu16 sum = add1 + add2;\n\n\tsum = (sum & 0xFF) + (sum >> 8);\n\treturn sum & 0xFF;\n}\n\n \ns32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,\n\t\t\t\t\tu16 reg, u16 *val, bool lock)\n{\n\tu32 swfw_mask = hw->phy.phy_semaphore_mask;\n\tint max_retry = 3;\n\tint retry = 0;\n\tu8 csum_byte;\n\tu8 high_bits;\n\tu8 low_bits;\n\tu8 reg_high;\n\tu8 csum;\n\n\treg_high = ((reg >> 7) & 0xFE) | 1;      \n\tcsum = ixgbe_ones_comp_byte_add(reg_high, reg & 0xFF);\n\tcsum = ~csum;\n\tdo {\n\t\tif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\t\tixgbe_i2c_start(hw);\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, addr))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, reg_high))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, reg & 0xFF))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, csum))\n\t\t\tgoto fail;\n\t\t \n\t\tixgbe_i2c_start(hw);\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, addr | 1))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_in_i2c_byte_ack(hw, &high_bits))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_in_i2c_byte_ack(hw, &low_bits))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_clock_in_i2c_byte(hw, &csum_byte))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_clock_out_i2c_bit(hw, false))\n\t\t\tgoto fail;\n\t\tixgbe_i2c_stop(hw);\n\t\tif (lock)\n\t\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\t*val = (high_bits << 8) | low_bits;\n\t\treturn 0;\n\nfail:\n\t\tixgbe_i2c_bus_clear(hw);\n\t\tif (lock)\n\t\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\tretry++;\n\t\tif (retry < max_retry)\n\t\t\thw_dbg(hw, \"I2C byte read combined error - Retry.\\n\");\n\t\telse\n\t\t\thw_dbg(hw, \"I2C byte read combined error.\\n\");\n\t} while (retry < max_retry);\n\n\treturn IXGBE_ERR_I2C;\n}\n\n \ns32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,\n\t\t\t\t\t u16 reg, u16 val, bool lock)\n{\n\tu32 swfw_mask = hw->phy.phy_semaphore_mask;\n\tint max_retry = 1;\n\tint retry = 0;\n\tu8 reg_high;\n\tu8 csum;\n\n\treg_high = (reg >> 7) & 0xFE;    \n\tcsum = ixgbe_ones_comp_byte_add(reg_high, reg & 0xFF);\n\tcsum = ixgbe_ones_comp_byte_add(csum, val >> 8);\n\tcsum = ixgbe_ones_comp_byte_add(csum, val & 0xFF);\n\tcsum = ~csum;\n\tdo {\n\t\tif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\t\tixgbe_i2c_start(hw);\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, addr))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, reg_high))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, reg & 0xFF))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, val >> 8))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, val & 0xFF))\n\t\t\tgoto fail;\n\t\t \n\t\tif (ixgbe_out_i2c_byte_ack(hw, csum))\n\t\t\tgoto fail;\n\t\tixgbe_i2c_stop(hw);\n\t\tif (lock)\n\t\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\treturn 0;\n\nfail:\n\t\tixgbe_i2c_bus_clear(hw);\n\t\tif (lock)\n\t\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\tretry++;\n\t\tif (retry < max_retry)\n\t\t\thw_dbg(hw, \"I2C byte write combined error - Retry.\\n\");\n\t\telse\n\t\t\thw_dbg(hw, \"I2C byte write combined error.\\n\");\n\t} while (retry < max_retry);\n\n\treturn IXGBE_ERR_I2C;\n}\n\n \nstatic bool ixgbe_probe_phy(struct ixgbe_hw *hw, u16 phy_addr)\n{\n\tu16 ext_ability = 0;\n\n\thw->phy.mdio.prtad = phy_addr;\n\tif (mdio45_probe(&hw->phy.mdio, phy_addr) != 0)\n\t\treturn false;\n\n\tif (ixgbe_get_phy_id(hw))\n\t\treturn false;\n\n\thw->phy.type = ixgbe_get_phy_type_from_id(hw->phy.id);\n\n\tif (hw->phy.type == ixgbe_phy_unknown) {\n\t\thw->phy.ops.read_reg(hw,\n\t\t\t\t     MDIO_PMA_EXTABLE,\n\t\t\t\t     MDIO_MMD_PMAPMD,\n\t\t\t\t     &ext_ability);\n\t\tif (ext_ability &\n\t\t    (MDIO_PMA_EXTABLE_10GBT |\n\t\t     MDIO_PMA_EXTABLE_1000BT))\n\t\t\thw->phy.type = ixgbe_phy_cu_unknown;\n\t\telse\n\t\t\thw->phy.type = ixgbe_phy_generic;\n\t}\n\n\treturn true;\n}\n\n \ns32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)\n{\n\tu32 phy_addr;\n\tu32 status = IXGBE_ERR_PHY_ADDR_INVALID;\n\n\tif (!hw->phy.phy_semaphore_mask) {\n\t\tif (hw->bus.lan_id)\n\t\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;\n\t\telse\n\t\t\thw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;\n\t}\n\n\tif (hw->phy.type != ixgbe_phy_unknown)\n\t\treturn 0;\n\n\tif (hw->phy.nw_mng_if_sel) {\n\t\tphy_addr = (hw->phy.nw_mng_if_sel &\n\t\t\t    IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD) >>\n\t\t\t   IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT;\n\t\tif (ixgbe_probe_phy(hw, phy_addr))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn IXGBE_ERR_PHY_ADDR_INVALID;\n\t}\n\n\tfor (phy_addr = 0; phy_addr < IXGBE_MAX_PHY_ADDR; phy_addr++) {\n\t\tif (ixgbe_probe_phy(hw, phy_addr)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (status)\n\t\thw->phy.mdio.prtad = MDIO_PRTAD_NONE;\n\n\treturn status;\n}\n\n \nbool ixgbe_check_reset_blocked(struct ixgbe_hw *hw)\n{\n\tu32 mmngc;\n\n\t \n\tif (hw->mac.type == ixgbe_mac_82598EB)\n\t\treturn false;\n\n\tmmngc = IXGBE_READ_REG(hw, IXGBE_MMNGC);\n\tif (mmngc & IXGBE_MMNGC_MNG_VETO) {\n\t\thw_dbg(hw, \"MNG_VETO bit detected.\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic s32 ixgbe_get_phy_id(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu16 phy_id_high = 0;\n\tu16 phy_id_low = 0;\n\n\tstatus = hw->phy.ops.read_reg(hw, MDIO_DEVID1, MDIO_MMD_PMAPMD,\n\t\t\t\t      &phy_id_high);\n\n\tif (!status) {\n\t\thw->phy.id = (u32)(phy_id_high << 16);\n\t\tstatus = hw->phy.ops.read_reg(hw, MDIO_DEVID2, MDIO_MMD_PMAPMD,\n\t\t\t\t\t      &phy_id_low);\n\t\thw->phy.id |= (u32)(phy_id_low & IXGBE_PHY_REVISION_MASK);\n\t\thw->phy.revision = (u32)(phy_id_low & ~IXGBE_PHY_REVISION_MASK);\n\t}\n\treturn status;\n}\n\n \nstatic enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id)\n{\n\tenum ixgbe_phy_type phy_type;\n\n\tswitch (phy_id) {\n\tcase TN1010_PHY_ID:\n\t\tphy_type = ixgbe_phy_tn;\n\t\tbreak;\n\tcase X550_PHY_ID2:\n\tcase X550_PHY_ID3:\n\tcase X540_PHY_ID:\n\t\tphy_type = ixgbe_phy_aq;\n\t\tbreak;\n\tcase QT2022_PHY_ID:\n\t\tphy_type = ixgbe_phy_qt;\n\t\tbreak;\n\tcase ATH_PHY_ID:\n\t\tphy_type = ixgbe_phy_nl;\n\t\tbreak;\n\tcase X557_PHY_ID:\n\tcase X557_PHY_ID2:\n\t\tphy_type = ixgbe_phy_x550em_ext_t;\n\t\tbreak;\n\tcase BCM54616S_E_PHY_ID:\n\t\tphy_type = ixgbe_phy_ext_1g_t;\n\t\tbreak;\n\tdefault:\n\t\tphy_type = ixgbe_phy_unknown;\n\t\tbreak;\n\t}\n\n\treturn phy_type;\n}\n\n \ns32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)\n{\n\tu32 i;\n\tu16 ctrl = 0;\n\ts32 status = 0;\n\n\tif (hw->phy.type == ixgbe_phy_unknown)\n\t\tstatus = ixgbe_identify_phy_generic(hw);\n\n\tif (status != 0 || hw->phy.type == ixgbe_phy_none)\n\t\treturn status;\n\n\t \n\tif (!hw->phy.reset_if_overtemp &&\n\t    (IXGBE_ERR_OVERTEMP == hw->phy.ops.check_overtemp(hw)))\n\t\treturn 0;\n\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\t \n\thw->phy.ops.write_reg(hw, MDIO_CTRL1,\n\t\t\t      MDIO_MMD_PHYXS,\n\t\t\t      MDIO_CTRL1_RESET);\n\n\t \n\tfor (i = 0; i < 30; i++) {\n\t\tmsleep(100);\n\t\tif (hw->phy.type == ixgbe_phy_x550em_ext_t) {\n\t\t\tstatus = hw->phy.ops.read_reg(hw,\n\t\t\t\t\t\t  IXGBE_MDIO_TX_VENDOR_ALARMS_3,\n\t\t\t\t\t\t  MDIO_MMD_PMAPMD, &ctrl);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\n\t\t\tif (ctrl & IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK) {\n\t\t\t\tudelay(2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = hw->phy.ops.read_reg(hw, MDIO_CTRL1,\n\t\t\t\t\t\t      MDIO_MMD_PHYXS, &ctrl);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\n\t\t\tif (!(ctrl & MDIO_CTRL1_RESET)) {\n\t\t\t\tudelay(2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctrl & MDIO_CTRL1_RESET) {\n\t\thw_dbg(hw, \"PHY reset polling failed to complete.\\n\");\n\t\treturn IXGBE_ERR_RESET_FAILED;\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,\n\t\t       u16 *phy_data)\n{\n\tu32 i, data, command;\n\n\t \n\tcommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |\n\t\t   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\n\t\t   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\n\t\t   (IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND));\n\n\tIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\n\n\t \n\tfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\n\t\tudelay(10);\n\n\t\tcommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\n\t\tif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\n\t\t\t\tbreak;\n\t}\n\n\n\tif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\n\t\thw_dbg(hw, \"PHY address command did not complete.\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\t \n\tcommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |\n\t\t   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\n\t\t   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\n\t\t   (IXGBE_MSCA_READ | IXGBE_MSCA_MDI_COMMAND));\n\n\tIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\n\n\t \n\tfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\n\t\tudelay(10);\n\n\t\tcommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\n\t\tif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\n\t\t\tbreak;\n\t}\n\n\tif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\n\t\thw_dbg(hw, \"PHY read command didn't complete\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\t \n\tdata = IXGBE_READ_REG(hw, IXGBE_MSRWD);\n\tdata >>= IXGBE_MSRWD_READ_DATA_SHIFT;\n\t*phy_data = (u16)(data);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t       u32 device_type, u16 *phy_data)\n{\n\ts32 status;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, gssr) == 0) {\n\t\tstatus = ixgbe_read_phy_reg_mdi(hw, reg_addr, device_type,\n\t\t\t\t\t\tphy_data);\n\t\thw->mac.ops.release_swfw_sync(hw, gssr);\n\t} else {\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\t}\n\n\treturn status;\n}\n\n \ns32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\tu32 device_type, u16 phy_data)\n{\n\tu32 i, command;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_MSRWD, (u32)phy_data);\n\n\t \n\tcommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |\n\t\t   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\n\t\t   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\n\t\t   (IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND));\n\n\tIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\n\n\t \n\tfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\n\t\tudelay(10);\n\n\t\tcommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\n\t\tif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\n\t\t\tbreak;\n\t}\n\n\tif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\n\t\thw_dbg(hw, \"PHY address cmd didn't complete\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\t \n\tcommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |\n\t\t   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\n\t\t   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\n\t\t   (IXGBE_MSCA_WRITE | IXGBE_MSCA_MDI_COMMAND));\n\n\tIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\n\n\t \n\tfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\n\t\tudelay(10);\n\n\t\tcommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\n\t\tif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\n\t\t\tbreak;\n\t}\n\n\tif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\n\t\thw_dbg(hw, \"PHY write cmd didn't complete\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,\n\t\t\t\tu32 device_type, u16 phy_data)\n{\n\ts32 status;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, gssr) == 0) {\n\t\tstatus = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type,\n\t\t\t\t\t\t phy_data);\n\t\thw->mac.ops.release_swfw_sync(hw, gssr);\n\t} else {\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\t}\n\n\treturn status;\n}\n\n#define IXGBE_HW_READ_REG(addr) IXGBE_READ_REG(hw, addr)\n\n \nstatic s32 ixgbe_msca_cmd(struct ixgbe_hw *hw, u32 cmd)\n{\n\tIXGBE_WRITE_REG(hw, IXGBE_MSCA, cmd);\n\n\treturn readx_poll_timeout(IXGBE_HW_READ_REG, IXGBE_MSCA, cmd,\n\t\t\t\t  !(cmd & IXGBE_MSCA_MDI_COMMAND), 10,\n\t\t\t\t  10 * IXGBE_MDIO_COMMAND_TIMEOUT);\n}\n\n \nstatic s32 ixgbe_mii_bus_read_generic_c22(struct ixgbe_hw *hw, int addr,\n\t\t\t\t\t  int regnum, u32 gssr)\n{\n\tu32 hwaddr, cmd;\n\ts32 data;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, gssr))\n\t\treturn -EBUSY;\n\n\thwaddr = addr << IXGBE_MSCA_PHY_ADDR_SHIFT;\n\thwaddr |= (regnum & GENMASK(5, 0)) << IXGBE_MSCA_DEV_TYPE_SHIFT;\n\tcmd = hwaddr | IXGBE_MSCA_OLD_PROTOCOL |\n\t\tIXGBE_MSCA_READ_AUTOINC | IXGBE_MSCA_MDI_COMMAND;\n\n\tdata = ixgbe_msca_cmd(hw, cmd);\n\tif (data < 0)\n\t\tgoto mii_bus_read_done;\n\n\tdata = IXGBE_READ_REG(hw, IXGBE_MSRWD);\n\tdata = (data >> IXGBE_MSRWD_READ_DATA_SHIFT) & GENMASK(16, 0);\n\nmii_bus_read_done:\n\thw->mac.ops.release_swfw_sync(hw, gssr);\n\treturn data;\n}\n\n \nstatic s32 ixgbe_mii_bus_read_generic_c45(struct ixgbe_hw *hw, int addr,\n\t\t\t\t\t  int devad, int regnum, u32 gssr)\n{\n\tu32 hwaddr, cmd;\n\ts32 data;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, gssr))\n\t\treturn -EBUSY;\n\n\thwaddr = addr << IXGBE_MSCA_PHY_ADDR_SHIFT;\n\thwaddr |= devad << 16 | regnum;\n\tcmd = hwaddr | IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND;\n\n\tdata = ixgbe_msca_cmd(hw, cmd);\n\tif (data < 0)\n\t\tgoto mii_bus_read_done;\n\n\tcmd = hwaddr | IXGBE_MSCA_READ | IXGBE_MSCA_MDI_COMMAND;\n\tdata = ixgbe_msca_cmd(hw, cmd);\n\tif (data < 0)\n\t\tgoto mii_bus_read_done;\n\n\tdata = IXGBE_READ_REG(hw, IXGBE_MSRWD);\n\tdata = (data >> IXGBE_MSRWD_READ_DATA_SHIFT) & GENMASK(16, 0);\n\nmii_bus_read_done:\n\thw->mac.ops.release_swfw_sync(hw, gssr);\n\treturn data;\n}\n\n \nstatic s32 ixgbe_mii_bus_write_generic_c22(struct ixgbe_hw *hw, int addr,\n\t\t\t\t\t   int regnum, u16 val, u32 gssr)\n{\n\tu32 hwaddr, cmd;\n\ts32 err;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, gssr))\n\t\treturn -EBUSY;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_MSRWD, (u32)val);\n\n\thwaddr = addr << IXGBE_MSCA_PHY_ADDR_SHIFT;\n\thwaddr |= (regnum & GENMASK(5, 0)) << IXGBE_MSCA_DEV_TYPE_SHIFT;\n\tcmd = hwaddr | IXGBE_MSCA_OLD_PROTOCOL | IXGBE_MSCA_WRITE |\n\t\tIXGBE_MSCA_MDI_COMMAND;\n\n\terr = ixgbe_msca_cmd(hw, cmd);\n\n\thw->mac.ops.release_swfw_sync(hw, gssr);\n\treturn err;\n}\n\n \nstatic s32 ixgbe_mii_bus_write_generic_c45(struct ixgbe_hw *hw, int addr,\n\t\t\t\t\t   int devad, int regnum, u16 val,\n\t\t\t\t\t   u32 gssr)\n{\n\tu32 hwaddr, cmd;\n\ts32 err;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, gssr))\n\t\treturn -EBUSY;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_MSRWD, (u32)val);\n\n\thwaddr = addr << IXGBE_MSCA_PHY_ADDR_SHIFT;\n\thwaddr |= devad << 16 | regnum;\n\tcmd = hwaddr | IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND;\n\n\terr = ixgbe_msca_cmd(hw, cmd);\n\tif (err < 0)\n\t\tgoto mii_bus_write_done;\n\n\tcmd = hwaddr | IXGBE_MSCA_WRITE | IXGBE_MSCA_MDI_COMMAND;\n\terr = ixgbe_msca_cmd(hw, cmd);\n\nmii_bus_write_done:\n\thw->mac.ops.release_swfw_sync(hw, gssr);\n\treturn err;\n}\n\n \nstatic s32 ixgbe_mii_bus_read_c22(struct mii_bus *bus, int addr, int regnum)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\treturn ixgbe_mii_bus_read_generic_c22(hw, addr, regnum, gssr);\n}\n\n \nstatic s32 ixgbe_mii_bus_read_c45(struct mii_bus *bus, int devad, int addr,\n\t\t\t\t  int regnum)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\treturn ixgbe_mii_bus_read_generic_c45(hw, addr, devad, regnum, gssr);\n}\n\n \nstatic s32 ixgbe_mii_bus_write_c22(struct mii_bus *bus, int addr, int regnum,\n\t\t\t\t   u16 val)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\treturn ixgbe_mii_bus_write_generic_c22(hw, addr, regnum, val, gssr);\n}\n\n \nstatic s32 ixgbe_mii_bus_write_c45(struct mii_bus *bus, int addr, int devad,\n\t\t\t\t   int regnum, u16 val)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\treturn ixgbe_mii_bus_write_generic_c45(hw, addr, devad, regnum, val,\n\t\t\t\t\t       gssr);\n}\n\n \nstatic s32 ixgbe_x550em_a_mii_bus_read_c22(struct mii_bus *bus, int addr,\n\t\t\t\t\t   int regnum)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\tgssr |= IXGBE_GSSR_TOKEN_SM | IXGBE_GSSR_PHY0_SM;\n\treturn ixgbe_mii_bus_read_generic_c22(hw, addr, regnum, gssr);\n}\n\n \nstatic s32 ixgbe_x550em_a_mii_bus_read_c45(struct mii_bus *bus, int addr,\n\t\t\t\t\t   int devad, int regnum)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\tgssr |= IXGBE_GSSR_TOKEN_SM | IXGBE_GSSR_PHY0_SM;\n\treturn ixgbe_mii_bus_read_generic_c45(hw, addr, devad, regnum, gssr);\n}\n\n \nstatic s32 ixgbe_x550em_a_mii_bus_write_c22(struct mii_bus *bus, int addr,\n\t\t\t\t\t    int regnum, u16 val)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\tgssr |= IXGBE_GSSR_TOKEN_SM | IXGBE_GSSR_PHY0_SM;\n\treturn ixgbe_mii_bus_write_generic_c22(hw, addr, regnum, val, gssr);\n}\n\n \nstatic s32 ixgbe_x550em_a_mii_bus_write_c45(struct mii_bus *bus, int addr,\n\t\t\t\t\t    int devad, int regnum, u16 val)\n{\n\tstruct ixgbe_adapter *adapter = bus->priv;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 gssr = hw->phy.phy_semaphore_mask;\n\n\tgssr |= IXGBE_GSSR_TOKEN_SM | IXGBE_GSSR_PHY0_SM;\n\treturn ixgbe_mii_bus_write_generic_c45(hw, addr, devad, regnum, val,\n\t\t\t\t\t       gssr);\n}\n\n \nstatic struct pci_dev *ixgbe_get_first_secondary_devfn(unsigned int devfn)\n{\n\tstruct pci_dev *rp_pdev;\n\tint bus;\n\n\trp_pdev = pci_get_domain_bus_and_slot(0, 0, devfn);\n\tif (rp_pdev && rp_pdev->subordinate) {\n\t\tbus = rp_pdev->subordinate->number;\n\t\tpci_dev_put(rp_pdev);\n\t\treturn pci_get_domain_bus_and_slot(0, bus, 0);\n\t}\n\n\tpci_dev_put(rp_pdev);\n\treturn NULL;\n}\n\n \nstatic bool ixgbe_x550em_a_has_mii(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_adapter *adapter = hw->back;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pci_dev *func0_pdev;\n\tbool has_mii = false;\n\n\t \n\tfunc0_pdev = ixgbe_get_first_secondary_devfn(PCI_DEVFN(0x16, 0));\n\tif (func0_pdev) {\n\t\tif (func0_pdev == pdev)\n\t\t\thas_mii = true;\n\t\tgoto out;\n\t}\n\tfunc0_pdev = ixgbe_get_first_secondary_devfn(PCI_DEVFN(0x17, 0));\n\tif (func0_pdev == pdev)\n\t\thas_mii = true;\n\nout:\n\tpci_dev_put(func0_pdev);\n\treturn has_mii;\n}\n\n \ns32 ixgbe_mii_bus_init(struct ixgbe_hw *hw)\n{\n\ts32 (*write_c22)(struct mii_bus *bus, int addr, int regnum, u16 val);\n\ts32 (*read_c22)(struct mii_bus *bus, int addr, int regnum);\n\ts32 (*write_c45)(struct mii_bus *bus, int addr, int devad, int regnum,\n\t\t\t u16 val);\n\ts32 (*read_c45)(struct mii_bus *bus, int addr, int devad, int regnum);\n\tstruct ixgbe_adapter *adapter = hw->back;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct device *dev = &adapter->netdev->dev;\n\tstruct mii_bus *bus;\n\n\tswitch (hw->device_id) {\n\t \n\tcase IXGBE_DEV_ID_X550EM_A_KR:\n\tcase IXGBE_DEV_ID_X550EM_A_KR_L:\n\tcase IXGBE_DEV_ID_X550EM_A_SFP_N:\n\tcase IXGBE_DEV_ID_X550EM_A_SGMII:\n\tcase IXGBE_DEV_ID_X550EM_A_SGMII_L:\n\tcase IXGBE_DEV_ID_X550EM_A_10G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_SFP:\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T:\n\tcase IXGBE_DEV_ID_X550EM_A_1G_T_L:\n\t\tif (!ixgbe_x550em_a_has_mii(hw))\n\t\t\treturn 0;\n\t\tread_c22 = ixgbe_x550em_a_mii_bus_read_c22;\n\t\twrite_c22 = ixgbe_x550em_a_mii_bus_write_c22;\n\t\tread_c45 = ixgbe_x550em_a_mii_bus_read_c45;\n\t\twrite_c45 = ixgbe_x550em_a_mii_bus_write_c45;\n\t\tbreak;\n\tdefault:\n\t\tread_c22 = ixgbe_mii_bus_read_c22;\n\t\twrite_c22 = ixgbe_mii_bus_write_c22;\n\t\tread_c45 = ixgbe_mii_bus_read_c45;\n\t\twrite_c45 = ixgbe_mii_bus_write_c45;\n\t\tbreak;\n\t}\n\n\tbus = devm_mdiobus_alloc(dev);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->read = read_c22;\n\tbus->write = write_c22;\n\tbus->read_c45 = read_c45;\n\tbus->write_c45 = write_c45;\n\n\t \n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-mdio-%s\", ixgbe_driver_name,\n\t\t pci_name(pdev));\n\n\tbus->name = \"ixgbe-mdio\";\n\tbus->priv = adapter;\n\tbus->parent = dev;\n\tbus->phy_mask = GENMASK(31, 0);\n\n\t \n\thw->phy.mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22;\n\n\tadapter->mii_bus = bus;\n\treturn mdiobus_register(bus);\n}\n\n \ns32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw)\n{\n\ts32 status = 0;\n\tu16 autoneg_reg = IXGBE_MII_AUTONEG_REG;\n\tbool autoneg = false;\n\tixgbe_link_speed speed;\n\n\tixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);\n\n\t \n\thw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL, MDIO_MMD_AN, &autoneg_reg);\n\n\tautoneg_reg &= ~MDIO_AN_10GBT_CTRL_ADV10G;\n\tif ((hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL) &&\n\t    (speed & IXGBE_LINK_SPEED_10GB_FULL))\n\t\tautoneg_reg |= MDIO_AN_10GBT_CTRL_ADV10G;\n\n\thw->phy.ops.write_reg(hw, MDIO_AN_10GBT_CTRL, MDIO_MMD_AN, autoneg_reg);\n\n\thw->phy.ops.read_reg(hw, IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,\n\t\t\t     MDIO_MMD_AN, &autoneg_reg);\n\n\tif (hw->mac.type == ixgbe_mac_X550) {\n\t\t \n\t\tautoneg_reg &= ~IXGBE_MII_5GBASE_T_ADVERTISE;\n\t\tif ((hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_5GB_FULL) &&\n\t\t    (speed & IXGBE_LINK_SPEED_5GB_FULL))\n\t\t\tautoneg_reg |= IXGBE_MII_5GBASE_T_ADVERTISE;\n\n\t\t \n\t\tautoneg_reg &= ~IXGBE_MII_2_5GBASE_T_ADVERTISE;\n\t\tif ((hw->phy.autoneg_advertised &\n\t\t     IXGBE_LINK_SPEED_2_5GB_FULL) &&\n\t\t    (speed & IXGBE_LINK_SPEED_2_5GB_FULL))\n\t\t\tautoneg_reg |= IXGBE_MII_2_5GBASE_T_ADVERTISE;\n\t}\n\n\t \n\tautoneg_reg &= ~IXGBE_MII_1GBASE_T_ADVERTISE;\n\tif ((hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_1GB_FULL) &&\n\t    (speed & IXGBE_LINK_SPEED_1GB_FULL))\n\t\tautoneg_reg |= IXGBE_MII_1GBASE_T_ADVERTISE;\n\n\thw->phy.ops.write_reg(hw, IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,\n\t\t\t      MDIO_MMD_AN, autoneg_reg);\n\n\t \n\thw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE, MDIO_MMD_AN, &autoneg_reg);\n\n\tautoneg_reg &= ~(ADVERTISE_100FULL | ADVERTISE_100HALF);\n\tif ((hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL) &&\n\t    (speed & IXGBE_LINK_SPEED_100_FULL))\n\t\tautoneg_reg |= ADVERTISE_100FULL;\n\n\thw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE, MDIO_MMD_AN, autoneg_reg);\n\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\t \n\thw->phy.ops.read_reg(hw, MDIO_CTRL1,\n\t\t\t     MDIO_MMD_AN, &autoneg_reg);\n\n\tautoneg_reg |= MDIO_AN_CTRL1_RESTART;\n\n\thw->phy.ops.write_reg(hw, MDIO_CTRL1,\n\t\t\t      MDIO_MMD_AN, autoneg_reg);\n\n\treturn status;\n}\n\n \ns32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,\n\t\t\t\t       ixgbe_link_speed speed,\n\t\t\t\t       bool autoneg_wait_to_complete)\n{\n\t \n\thw->phy.autoneg_advertised = 0;\n\n\tif (speed & IXGBE_LINK_SPEED_10GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_5GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_5GB_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_2_5GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_2_5GB_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_1GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_100_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_100_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_10_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10_FULL;\n\n\t \n\tif (hw->phy.ops.setup_link)\n\t\thw->phy.ops.setup_link(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_get_copper_speeds_supported(struct ixgbe_hw *hw)\n{\n\tu16 speed_ability;\n\ts32 status;\n\n\tstatus = hw->phy.ops.read_reg(hw, MDIO_SPEED, MDIO_MMD_PMAPMD,\n\t\t\t\t      &speed_ability);\n\tif (status)\n\t\treturn status;\n\n\tif (speed_ability & MDIO_SPEED_10G)\n\t\thw->phy.speeds_supported |= IXGBE_LINK_SPEED_10GB_FULL;\n\tif (speed_ability & MDIO_PMA_SPEED_1000)\n\t\thw->phy.speeds_supported |= IXGBE_LINK_SPEED_1GB_FULL;\n\tif (speed_ability & MDIO_PMA_SPEED_100)\n\t\thw->phy.speeds_supported |= IXGBE_LINK_SPEED_100_FULL;\n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_X550:\n\t\thw->phy.speeds_supported |= IXGBE_LINK_SPEED_2_5GB_FULL;\n\t\thw->phy.speeds_supported |= IXGBE_LINK_SPEED_5GB_FULL;\n\t\tbreak;\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\thw->phy.speeds_supported &= ~IXGBE_LINK_SPEED_100_FULL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,\n\t\t\t\t\t       ixgbe_link_speed *speed,\n\t\t\t\t\t       bool *autoneg)\n{\n\ts32 status = 0;\n\n\t*autoneg = true;\n\tif (!hw->phy.speeds_supported)\n\t\tstatus = ixgbe_get_copper_speeds_supported(hw);\n\n\t*speed = hw->phy.speeds_supported;\n\treturn status;\n}\n\n \ns32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed,\n\t\t\t     bool *link_up)\n{\n\ts32 status;\n\tu32 time_out;\n\tu32 max_time_out = 10;\n\tu16 phy_link = 0;\n\tu16 phy_speed = 0;\n\tu16 phy_data = 0;\n\n\t \n\t*link_up = false;\n\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\n\t \n\tfor (time_out = 0; time_out < max_time_out; time_out++) {\n\t\tudelay(10);\n\t\tstatus = hw->phy.ops.read_reg(hw,\n\t\t\t\t\t      MDIO_STAT1,\n\t\t\t\t\t      MDIO_MMD_VEND1,\n\t\t\t\t\t      &phy_data);\n\t\tphy_link = phy_data &\n\t\t\t    IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS;\n\t\tphy_speed = phy_data &\n\t\t\t    IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS;\n\t\tif (phy_link == IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS) {\n\t\t\t*link_up = true;\n\t\t\tif (phy_speed ==\n\t\t\t    IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS)\n\t\t\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \ns32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)\n{\n\tu16 autoneg_reg = IXGBE_MII_AUTONEG_REG;\n\tbool autoneg = false;\n\tixgbe_link_speed speed;\n\n\tixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);\n\n\tif (speed & IXGBE_LINK_SPEED_10GB_FULL) {\n\t\t \n\t\thw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL,\n\t\t\t\t     MDIO_MMD_AN,\n\t\t\t\t     &autoneg_reg);\n\n\t\tautoneg_reg &= ~MDIO_AN_10GBT_CTRL_ADV10G;\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL)\n\t\t\tautoneg_reg |= MDIO_AN_10GBT_CTRL_ADV10G;\n\n\t\thw->phy.ops.write_reg(hw, MDIO_AN_10GBT_CTRL,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      autoneg_reg);\n\t}\n\n\tif (speed & IXGBE_LINK_SPEED_1GB_FULL) {\n\t\t \n\t\thw->phy.ops.read_reg(hw, IXGBE_MII_AUTONEG_XNP_TX_REG,\n\t\t\t\t     MDIO_MMD_AN,\n\t\t\t\t     &autoneg_reg);\n\n\t\tautoneg_reg &= ~IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX;\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_1GB_FULL)\n\t\t\tautoneg_reg |= IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX;\n\n\t\thw->phy.ops.write_reg(hw, IXGBE_MII_AUTONEG_XNP_TX_REG,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      autoneg_reg);\n\t}\n\n\tif (speed & IXGBE_LINK_SPEED_100_FULL) {\n\t\t \n\t\thw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,\n\t\t\t\t     MDIO_MMD_AN,\n\t\t\t\t     &autoneg_reg);\n\n\t\tautoneg_reg &= ~(ADVERTISE_100FULL |\n\t\t\t\t ADVERTISE_100HALF);\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL)\n\t\t\tautoneg_reg |= ADVERTISE_100FULL;\n\n\t\thw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE,\n\t\t\t\t      MDIO_MMD_AN,\n\t\t\t\t      autoneg_reg);\n\t}\n\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\t \n\thw->phy.ops.read_reg(hw, MDIO_CTRL1,\n\t\t\t     MDIO_MMD_AN, &autoneg_reg);\n\n\tautoneg_reg |= MDIO_AN_CTRL1_RESTART;\n\n\thw->phy.ops.write_reg(hw, MDIO_CTRL1,\n\t\t\t      MDIO_MMD_AN, autoneg_reg);\n\treturn 0;\n}\n\n \ns32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)\n{\n\tu16 phy_offset, control, eword, edata, block_crc;\n\tbool end_data = false;\n\tu16 list_offset, data_offset;\n\tu16 phy_data = 0;\n\ts32 ret_val;\n\tu32 i;\n\n\t \n\tif (ixgbe_check_reset_blocked(hw))\n\t\treturn 0;\n\n\thw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS, &phy_data);\n\n\t \n\thw->phy.ops.write_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS,\n\t\t\t      (phy_data | MDIO_CTRL1_RESET));\n\n\tfor (i = 0; i < 100; i++) {\n\t\thw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS,\n\t\t\t\t     &phy_data);\n\t\tif ((phy_data & MDIO_CTRL1_RESET) == 0)\n\t\t\tbreak;\n\t\tusleep_range(10000, 20000);\n\t}\n\n\tif ((phy_data & MDIO_CTRL1_RESET) != 0) {\n\t\thw_dbg(hw, \"PHY reset did not complete.\\n\");\n\t\treturn IXGBE_ERR_PHY;\n\t}\n\n\t \n\tret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,\n\t\t\t\t\t\t      &data_offset);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = hw->eeprom.ops.read(hw, data_offset, &block_crc);\n\tdata_offset++;\n\twhile (!end_data) {\n\t\t \n\t\tret_val = hw->eeprom.ops.read(hw, data_offset, &eword);\n\t\tif (ret_val)\n\t\t\tgoto err_eeprom;\n\t\tcontrol = (eword & IXGBE_CONTROL_MASK_NL) >>\n\t\t\t   IXGBE_CONTROL_SHIFT_NL;\n\t\tedata = eword & IXGBE_DATA_MASK_NL;\n\t\tswitch (control) {\n\t\tcase IXGBE_DELAY_NL:\n\t\t\tdata_offset++;\n\t\t\thw_dbg(hw, \"DELAY: %d MS\\n\", edata);\n\t\t\tusleep_range(edata * 1000, edata * 2000);\n\t\t\tbreak;\n\t\tcase IXGBE_DATA_NL:\n\t\t\thw_dbg(hw, \"DATA:\\n\");\n\t\t\tdata_offset++;\n\t\t\tret_val = hw->eeprom.ops.read(hw, data_offset++,\n\t\t\t\t\t\t      &phy_offset);\n\t\t\tif (ret_val)\n\t\t\t\tgoto err_eeprom;\n\t\t\tfor (i = 0; i < edata; i++) {\n\t\t\t\tret_val = hw->eeprom.ops.read(hw, data_offset,\n\t\t\t\t\t\t\t      &eword);\n\t\t\t\tif (ret_val)\n\t\t\t\t\tgoto err_eeprom;\n\t\t\t\thw->phy.ops.write_reg(hw, phy_offset,\n\t\t\t\t\t\t      MDIO_MMD_PMAPMD, eword);\n\t\t\t\thw_dbg(hw, \"Wrote %4.4x to %4.4x\\n\", eword,\n\t\t\t\t       phy_offset);\n\t\t\t\tdata_offset++;\n\t\t\t\tphy_offset++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IXGBE_CONTROL_NL:\n\t\t\tdata_offset++;\n\t\t\thw_dbg(hw, \"CONTROL:\\n\");\n\t\t\tif (edata == IXGBE_CONTROL_EOL_NL) {\n\t\t\t\thw_dbg(hw, \"EOL\\n\");\n\t\t\t\tend_data = true;\n\t\t\t} else if (edata == IXGBE_CONTROL_SOL_NL) {\n\t\t\t\thw_dbg(hw, \"SOL\\n\");\n\t\t\t} else {\n\t\t\t\thw_dbg(hw, \"Bad control value\\n\");\n\t\t\t\treturn IXGBE_ERR_PHY;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thw_dbg(hw, \"Bad control type\\n\");\n\t\t\treturn IXGBE_ERR_PHY;\n\t\t}\n\t}\n\n\treturn ret_val;\n\nerr_eeprom:\n\thw_err(hw, \"eeprom read at offset %d failed\\n\", data_offset);\n\treturn IXGBE_ERR_PHY;\n}\n\n \ns32 ixgbe_identify_module_generic(struct ixgbe_hw *hw)\n{\n\tswitch (hw->mac.ops.get_media_type(hw)) {\n\tcase ixgbe_media_type_fiber:\n\t\treturn ixgbe_identify_sfp_module_generic(hw);\n\tcase ixgbe_media_type_fiber_qsfp:\n\t\treturn ixgbe_identify_qsfp_module_generic(hw);\n\tdefault:\n\t\thw->phy.sfp_type = ixgbe_sfp_type_not_present;\n\t\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n\t}\n\n\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n}\n\n \ns32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_adapter *adapter = hw->back;\n\ts32 status;\n\tu32 vendor_oui = 0;\n\tenum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;\n\tu8 identifier = 0;\n\tu8 comp_codes_1g = 0;\n\tu8 comp_codes_10g = 0;\n\tu8 oui_bytes[3] = {0, 0, 0};\n\tu8 cable_tech = 0;\n\tu8 cable_spec = 0;\n\tu16 enforce_sfp = 0;\n\n\tif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber) {\n\t\thw->phy.sfp_type = ixgbe_sfp_type_not_present;\n\t\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n\t}\n\n\t \n\thw->mac.ops.set_lan_id(hw);\n\n\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t     IXGBE_SFF_IDENTIFIER,\n\t\t\t\t\t     &identifier);\n\n\tif (status)\n\t\tgoto err_read_i2c_eeprom;\n\n\tif (identifier != IXGBE_SFF_IDENTIFIER_SFP) {\n\t\thw->phy.type = ixgbe_phy_sfp_unsupported;\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t}\n\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t     IXGBE_SFF_1GBE_COMP_CODES,\n\t\t\t\t\t     &comp_codes_1g);\n\n\tif (status)\n\t\tgoto err_read_i2c_eeprom;\n\n\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t     IXGBE_SFF_10GBE_COMP_CODES,\n\t\t\t\t\t     &comp_codes_10g);\n\n\tif (status)\n\t\tgoto err_read_i2c_eeprom;\n\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t     IXGBE_SFF_CABLE_TECHNOLOGY,\n\t\t\t\t\t     &cable_tech);\n\n\tif (status)\n\t\tgoto err_read_i2c_eeprom;\n\n\t  \n\tif (hw->mac.type == ixgbe_mac_82598EB) {\n\t\tif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_da_cu;\n\t\telse if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_sr;\n\t\telse if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_lr;\n\t\telse\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_unknown;\n\t} else {\n\t\tif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {\n\t\t\tif (hw->bus.lan_id == 0)\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\t     ixgbe_sfp_type_da_cu_core0;\n\t\t\telse\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\t     ixgbe_sfp_type_da_cu_core1;\n\t\t} else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE) {\n\t\t\thw->phy.ops.read_i2c_eeprom(\n\t\t\t\t\thw, IXGBE_SFF_CABLE_SPEC_COMP,\n\t\t\t\t\t&cable_spec);\n\t\t\tif (cable_spec &\n\t\t\t    IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING) {\n\t\t\t\tif (hw->bus.lan_id == 0)\n\t\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_da_act_lmt_core0;\n\t\t\t\telse\n\t\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_da_act_lmt_core1;\n\t\t\t} else {\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\t\tixgbe_sfp_type_unknown;\n\t\t\t}\n\t\t} else if (comp_codes_10g &\n\t\t\t   (IXGBE_SFF_10GBASESR_CAPABLE |\n\t\t\t    IXGBE_SFF_10GBASELR_CAPABLE)) {\n\t\t\tif (hw->bus.lan_id == 0)\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\t      ixgbe_sfp_type_srlr_core0;\n\t\t\telse\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\t      ixgbe_sfp_type_srlr_core1;\n\t\t} else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE) {\n\t\t\tif (hw->bus.lan_id == 0)\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_1g_cu_core0;\n\t\t\telse\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_1g_cu_core1;\n\t\t} else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) {\n\t\t\tif (hw->bus.lan_id == 0)\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_1g_sx_core0;\n\t\t\telse\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_1g_sx_core1;\n\t\t} else if (comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) {\n\t\t\tif (hw->bus.lan_id == 0)\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_1g_lx_core0;\n\t\t\telse\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\tixgbe_sfp_type_1g_lx_core1;\n\t\t} else {\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_unknown;\n\t\t}\n\t}\n\n\tif (hw->phy.sfp_type != stored_sfp_type)\n\t\thw->phy.sfp_setup_needed = true;\n\n\t \n\thw->phy.multispeed_fiber = false;\n\tif (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&\n\t     (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||\n\t    ((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&\n\t     (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))\n\t\thw->phy.multispeed_fiber = true;\n\n\t \n\tif (hw->phy.type != ixgbe_phy_nl) {\n\t\thw->phy.id = identifier;\n\t\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t    IXGBE_SFF_VENDOR_OUI_BYTE0,\n\t\t\t\t\t    &oui_bytes[0]);\n\n\t\tif (status != 0)\n\t\t\tgoto err_read_i2c_eeprom;\n\n\t\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t    IXGBE_SFF_VENDOR_OUI_BYTE1,\n\t\t\t\t\t    &oui_bytes[1]);\n\n\t\tif (status != 0)\n\t\t\tgoto err_read_i2c_eeprom;\n\n\t\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t    IXGBE_SFF_VENDOR_OUI_BYTE2,\n\t\t\t\t\t    &oui_bytes[2]);\n\n\t\tif (status != 0)\n\t\t\tgoto err_read_i2c_eeprom;\n\n\t\tvendor_oui =\n\t\t  ((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |\n\t\t   (oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |\n\t\t   (oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));\n\n\t\tswitch (vendor_oui) {\n\t\tcase IXGBE_SFF_VENDOR_OUI_TYCO:\n\t\t\tif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)\n\t\t\t\thw->phy.type =\n\t\t\t\t\t    ixgbe_phy_sfp_passive_tyco;\n\t\t\tbreak;\n\t\tcase IXGBE_SFF_VENDOR_OUI_FTL:\n\t\t\tif (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)\n\t\t\t\thw->phy.type = ixgbe_phy_sfp_ftl_active;\n\t\t\telse\n\t\t\t\thw->phy.type = ixgbe_phy_sfp_ftl;\n\t\t\tbreak;\n\t\tcase IXGBE_SFF_VENDOR_OUI_AVAGO:\n\t\t\thw->phy.type = ixgbe_phy_sfp_avago;\n\t\t\tbreak;\n\t\tcase IXGBE_SFF_VENDOR_OUI_INTEL:\n\t\t\thw->phy.type = ixgbe_phy_sfp_intel;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)\n\t\t\t\thw->phy.type =\n\t\t\t\t\t ixgbe_phy_sfp_passive_unknown;\n\t\t\telse if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)\n\t\t\t\thw->phy.type =\n\t\t\t\t\tixgbe_phy_sfp_active_unknown;\n\t\t\telse\n\t\t\t\thw->phy.type = ixgbe_phy_sfp_unknown;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (cable_tech & (IXGBE_SFF_DA_PASSIVE_CABLE |\n\t    IXGBE_SFF_DA_ACTIVE_CABLE))\n\t\treturn 0;\n\n\t \n\tif (comp_codes_10g == 0 &&\n\t    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {\n\t\thw->phy.type = ixgbe_phy_sfp_unsupported;\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t}\n\n\t \n\tif (hw->mac.type == ixgbe_mac_82598EB)\n\t\treturn 0;\n\n\thw->mac.ops.get_device_caps(hw, &enforce_sfp);\n\tif (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP) &&\n\t    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||\n\t      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {\n\t\t \n\t\tif (hw->phy.type == ixgbe_phy_sfp_intel)\n\t\t\treturn 0;\n\t\tif (hw->allow_unsupported_sfp) {\n\t\t\te_warn(drv, \"WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics.  Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter.  Intel Corporation is not responsible for any harm caused by using untested modules.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\thw_dbg(hw, \"SFP+ module not supported\\n\");\n\t\thw->phy.type = ixgbe_phy_sfp_unsupported;\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t}\n\treturn 0;\n\nerr_read_i2c_eeprom:\n\thw->phy.sfp_type = ixgbe_sfp_type_not_present;\n\tif (hw->phy.type != ixgbe_phy_nl) {\n\t\thw->phy.id = 0;\n\t\thw->phy.type = ixgbe_phy_unknown;\n\t}\n\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n}\n\n \nstatic s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_adapter *adapter = hw->back;\n\ts32 status;\n\tu32 vendor_oui = 0;\n\tenum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;\n\tu8 identifier = 0;\n\tu8 comp_codes_1g = 0;\n\tu8 comp_codes_10g = 0;\n\tu8 oui_bytes[3] = {0, 0, 0};\n\tu16 enforce_sfp = 0;\n\tu8 connector = 0;\n\tu8 cable_length = 0;\n\tu8 device_tech = 0;\n\tbool active_cable = false;\n\n\tif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber_qsfp) {\n\t\thw->phy.sfp_type = ixgbe_sfp_type_not_present;\n\t\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n\t}\n\n\t \n\thw->mac.ops.set_lan_id(hw);\n\n\tstatus = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_IDENTIFIER,\n\t\t\t\t\t     &identifier);\n\n\tif (status != 0)\n\t\tgoto err_read_i2c_eeprom;\n\n\tif (identifier != IXGBE_SFF_IDENTIFIER_QSFP_PLUS) {\n\t\thw->phy.type = ixgbe_phy_sfp_unsupported;\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t}\n\n\thw->phy.id = identifier;\n\n\tstatus = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_QSFP_10GBE_COMP,\n\t\t\t\t\t     &comp_codes_10g);\n\n\tif (status != 0)\n\t\tgoto err_read_i2c_eeprom;\n\n\tstatus = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_QSFP_1GBE_COMP,\n\t\t\t\t\t     &comp_codes_1g);\n\n\tif (status != 0)\n\t\tgoto err_read_i2c_eeprom;\n\n\tif (comp_codes_10g & IXGBE_SFF_QSFP_DA_PASSIVE_CABLE) {\n\t\thw->phy.type = ixgbe_phy_qsfp_passive_unknown;\n\t\tif (hw->bus.lan_id == 0)\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_da_cu_core0;\n\t\telse\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_da_cu_core1;\n\t} else if (comp_codes_10g & (IXGBE_SFF_10GBASESR_CAPABLE |\n\t\t\t\t     IXGBE_SFF_10GBASELR_CAPABLE)) {\n\t\tif (hw->bus.lan_id == 0)\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_srlr_core0;\n\t\telse\n\t\t\thw->phy.sfp_type = ixgbe_sfp_type_srlr_core1;\n\t} else {\n\t\tif (comp_codes_10g & IXGBE_SFF_QSFP_DA_ACTIVE_CABLE)\n\t\t\tactive_cable = true;\n\n\t\tif (!active_cable) {\n\t\t\t \n\t\t\thw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\tIXGBE_SFF_QSFP_CONNECTOR,\n\t\t\t\t\t&connector);\n\n\t\t\thw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\tIXGBE_SFF_QSFP_CABLE_LENGTH,\n\t\t\t\t\t&cable_length);\n\n\t\t\thw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\tIXGBE_SFF_QSFP_DEVICE_TECH,\n\t\t\t\t\t&device_tech);\n\n\t\t\tif ((connector ==\n\t\t\t\t     IXGBE_SFF_QSFP_CONNECTOR_NOT_SEPARABLE) &&\n\t\t\t    (cable_length > 0) &&\n\t\t\t    ((device_tech >> 4) ==\n\t\t\t\t     IXGBE_SFF_QSFP_TRANSMITER_850NM_VCSEL))\n\t\t\t\tactive_cable = true;\n\t\t}\n\n\t\tif (active_cable) {\n\t\t\thw->phy.type = ixgbe_phy_qsfp_active_unknown;\n\t\t\tif (hw->bus.lan_id == 0)\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\t\tixgbe_sfp_type_da_act_lmt_core0;\n\t\t\telse\n\t\t\t\thw->phy.sfp_type =\n\t\t\t\t\t\tixgbe_sfp_type_da_act_lmt_core1;\n\t\t} else {\n\t\t\t \n\t\t\thw->phy.type = ixgbe_phy_sfp_unsupported;\n\t\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\tif (hw->phy.sfp_type != stored_sfp_type)\n\t\thw->phy.sfp_setup_needed = true;\n\n\t \n\thw->phy.multispeed_fiber = false;\n\tif (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&\n\t     (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||\n\t    ((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&\n\t     (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))\n\t\thw->phy.multispeed_fiber = true;\n\n\t \n\tif (comp_codes_10g & (IXGBE_SFF_10GBASESR_CAPABLE |\n\t\t\t      IXGBE_SFF_10GBASELR_CAPABLE)) {\n\t\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\tIXGBE_SFF_QSFP_VENDOR_OUI_BYTE0,\n\t\t\t\t\t&oui_bytes[0]);\n\n\t\tif (status != 0)\n\t\t\tgoto err_read_i2c_eeprom;\n\n\t\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\tIXGBE_SFF_QSFP_VENDOR_OUI_BYTE1,\n\t\t\t\t\t&oui_bytes[1]);\n\n\t\tif (status != 0)\n\t\t\tgoto err_read_i2c_eeprom;\n\n\t\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\tIXGBE_SFF_QSFP_VENDOR_OUI_BYTE2,\n\t\t\t\t\t&oui_bytes[2]);\n\n\t\tif (status != 0)\n\t\t\tgoto err_read_i2c_eeprom;\n\n\t\tvendor_oui =\n\t\t\t((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |\n\t\t\t (oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |\n\t\t\t (oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));\n\n\t\tif (vendor_oui == IXGBE_SFF_VENDOR_OUI_INTEL)\n\t\t\thw->phy.type = ixgbe_phy_qsfp_intel;\n\t\telse\n\t\t\thw->phy.type = ixgbe_phy_qsfp_unknown;\n\n\t\thw->mac.ops.get_device_caps(hw, &enforce_sfp);\n\t\tif (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP)) {\n\t\t\t \n\t\t\tif (hw->phy.type == ixgbe_phy_qsfp_intel)\n\t\t\t\treturn 0;\n\t\t\tif (hw->allow_unsupported_sfp) {\n\t\t\t\te_warn(drv, \"WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\thw_dbg(hw, \"QSFP module not supported\\n\");\n\t\t\thw->phy.type = ixgbe_phy_sfp_unsupported;\n\t\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 0;\n\nerr_read_i2c_eeprom:\n\thw->phy.sfp_type = ixgbe_sfp_type_not_present;\n\thw->phy.id = 0;\n\thw->phy.type = ixgbe_phy_unknown;\n\n\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n}\n\n \ns32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,\n\t\t\t\t\tu16 *list_offset,\n\t\t\t\t\tu16 *data_offset)\n{\n\tu16 sfp_id;\n\tu16 sfp_type = hw->phy.sfp_type;\n\n\tif (hw->phy.sfp_type == ixgbe_sfp_type_unknown)\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\n\tif (hw->phy.sfp_type == ixgbe_sfp_type_not_present)\n\t\treturn IXGBE_ERR_SFP_NOT_PRESENT;\n\n\tif ((hw->device_id == IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM) &&\n\t    (hw->phy.sfp_type == ixgbe_sfp_type_da_cu))\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\n\t \n\tif (sfp_type == ixgbe_sfp_type_da_act_lmt_core0 ||\n\t    sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\n\t    sfp_type == ixgbe_sfp_type_1g_cu_core0 ||\n\t    sfp_type == ixgbe_sfp_type_1g_sx_core0)\n\t\tsfp_type = ixgbe_sfp_type_srlr_core0;\n\telse if (sfp_type == ixgbe_sfp_type_da_act_lmt_core1 ||\n\t\t sfp_type == ixgbe_sfp_type_1g_lx_core1 ||\n\t\t sfp_type == ixgbe_sfp_type_1g_cu_core1 ||\n\t\t sfp_type == ixgbe_sfp_type_1g_sx_core1)\n\t\tsfp_type = ixgbe_sfp_type_srlr_core1;\n\n\t \n\tif (hw->eeprom.ops.read(hw, IXGBE_PHY_INIT_OFFSET_NL, list_offset)) {\n\t\thw_err(hw, \"eeprom read at %d failed\\n\",\n\t\t       IXGBE_PHY_INIT_OFFSET_NL);\n\t\treturn IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT;\n\t}\n\n\tif ((!*list_offset) || (*list_offset == 0xFFFF))\n\t\treturn IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT;\n\n\t \n\t(*list_offset)++;\n\n\t \n\tif (hw->eeprom.ops.read(hw, *list_offset, &sfp_id))\n\t\tgoto err_phy;\n\n\twhile (sfp_id != IXGBE_PHY_INIT_END_NL) {\n\t\tif (sfp_id == sfp_type) {\n\t\t\t(*list_offset)++;\n\t\t\tif (hw->eeprom.ops.read(hw, *list_offset, data_offset))\n\t\t\t\tgoto err_phy;\n\t\t\tif ((!*data_offset) || (*data_offset == 0xFFFF)) {\n\t\t\t\thw_dbg(hw, \"SFP+ module not supported\\n\");\n\t\t\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t(*list_offset) += 2;\n\t\t\tif (hw->eeprom.ops.read(hw, *list_offset, &sfp_id))\n\t\t\t\tgoto err_phy;\n\t\t}\n\t}\n\n\tif (sfp_id == IXGBE_PHY_INIT_END_NL) {\n\t\thw_dbg(hw, \"No matching SFP+ module found\\n\");\n\t\treturn IXGBE_ERR_SFP_NOT_SUPPORTED;\n\t}\n\n\treturn 0;\n\nerr_phy:\n\thw_err(hw, \"eeprom read at offset %d failed\\n\", *list_offset);\n\treturn IXGBE_ERR_PHY;\n}\n\n \ns32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t  u8 *eeprom_data)\n{\n\treturn hw->phy.ops.read_i2c_byte(hw, byte_offset,\n\t\t\t\t\t IXGBE_I2C_EEPROM_DEV_ADDR,\n\t\t\t\t\t eeprom_data);\n}\n\n \ns32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t   u8 *sff8472_data)\n{\n\treturn hw->phy.ops.read_i2c_byte(hw, byte_offset,\n\t\t\t\t\t IXGBE_I2C_EEPROM_DEV_ADDR2,\n\t\t\t\t\t sff8472_data);\n}\n\n \ns32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t   u8 eeprom_data)\n{\n\treturn hw->phy.ops.write_i2c_byte(hw, byte_offset,\n\t\t\t\t\t  IXGBE_I2C_EEPROM_DEV_ADDR,\n\t\t\t\t\t  eeprom_data);\n}\n\n \nstatic bool ixgbe_is_sfp_probe(struct ixgbe_hw *hw, u8 offset, u8 addr)\n{\n\tif (addr == IXGBE_I2C_EEPROM_DEV_ADDR &&\n\t    offset == IXGBE_SFF_IDENTIFIER &&\n\t    hw->phy.sfp_type == ixgbe_sfp_type_not_present)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic s32 ixgbe_read_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t\t   u8 dev_addr, u8 *data, bool lock)\n{\n\ts32 status;\n\tu32 max_retry = 10;\n\tu32 retry = 0;\n\tu32 swfw_mask = hw->phy.phy_semaphore_mask;\n\tbool nack = true;\n\n\tif (hw->mac.type >= ixgbe_mac_X550)\n\t\tmax_retry = 3;\n\tif (ixgbe_is_sfp_probe(hw, byte_offset, dev_addr))\n\t\tmax_retry = IXGBE_SFP_DETECT_RETRIES;\n\n\t*data = 0;\n\n\tdo {\n\t\tif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\t\tixgbe_i2c_start(hw);\n\n\t\t \n\t\tstatus = ixgbe_clock_out_i2c_byte(hw, dev_addr);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_get_i2c_ack(hw);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_clock_out_i2c_byte(hw, byte_offset);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_get_i2c_ack(hw);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tixgbe_i2c_start(hw);\n\n\t\t \n\t\tstatus = ixgbe_clock_out_i2c_byte(hw, (dev_addr | 0x1));\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_get_i2c_ack(hw);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_clock_in_i2c_byte(hw, data);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_clock_out_i2c_bit(hw, nack);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tixgbe_i2c_stop(hw);\n\t\tif (lock)\n\t\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\treturn 0;\n\nfail:\n\t\tixgbe_i2c_bus_clear(hw);\n\t\tif (lock) {\n\t\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\t\tmsleep(100);\n\t\t}\n\t\tretry++;\n\t\tif (retry < max_retry)\n\t\t\thw_dbg(hw, \"I2C byte read error - Retrying.\\n\");\n\t\telse\n\t\t\thw_dbg(hw, \"I2C byte read error.\\n\");\n\n\t} while (retry < max_retry);\n\n\treturn status;\n}\n\n \ns32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\tu8 dev_addr, u8 *data)\n{\n\treturn ixgbe_read_i2c_byte_generic_int(hw, byte_offset, dev_addr,\n\t\t\t\t\t       data, true);\n}\n\n \ns32 ixgbe_read_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t\t u8 dev_addr, u8 *data)\n{\n\treturn ixgbe_read_i2c_byte_generic_int(hw, byte_offset, dev_addr,\n\t\t\t\t\t       data, false);\n}\n\n \nstatic s32 ixgbe_write_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t\t    u8 dev_addr, u8 data, bool lock)\n{\n\ts32 status;\n\tu32 max_retry = 1;\n\tu32 retry = 0;\n\tu32 swfw_mask = hw->phy.phy_semaphore_mask;\n\n\tif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\tdo {\n\t\tixgbe_i2c_start(hw);\n\n\t\tstatus = ixgbe_clock_out_i2c_byte(hw, dev_addr);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_get_i2c_ack(hw);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_clock_out_i2c_byte(hw, byte_offset);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_get_i2c_ack(hw);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_clock_out_i2c_byte(hw, data);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tstatus = ixgbe_get_i2c_ack(hw);\n\t\tif (status != 0)\n\t\t\tgoto fail;\n\n\t\tixgbe_i2c_stop(hw);\n\t\tif (lock)\n\t\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\t\treturn 0;\n\nfail:\n\t\tixgbe_i2c_bus_clear(hw);\n\t\tretry++;\n\t\tif (retry < max_retry)\n\t\t\thw_dbg(hw, \"I2C byte write error - Retrying.\\n\");\n\t\telse\n\t\t\thw_dbg(hw, \"I2C byte write error.\\n\");\n\t} while (retry < max_retry);\n\n\tif (lock)\n\t\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\n\treturn status;\n}\n\n \ns32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t u8 dev_addr, u8 data)\n{\n\treturn ixgbe_write_i2c_byte_generic_int(hw, byte_offset, dev_addr,\n\t\t\t\t\t\tdata, true);\n}\n\n \ns32 ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,\n\t\t\t\t\t  u8 dev_addr, u8 data)\n{\n\treturn ixgbe_write_i2c_byte_generic_int(hw, byte_offset, dev_addr,\n\t\t\t\t\t\tdata, false);\n}\n\n \nstatic void ixgbe_i2c_start(struct ixgbe_hw *hw)\n{\n\tu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\n\ti2cctl |= IXGBE_I2C_BB_EN(hw);\n\n\t \n\tixgbe_set_i2c_data(hw, &i2cctl, 1);\n\tixgbe_raise_i2c_clk(hw, &i2cctl);\n\n\t \n\tudelay(IXGBE_I2C_T_SU_STA);\n\n\tixgbe_set_i2c_data(hw, &i2cctl, 0);\n\n\t \n\tudelay(IXGBE_I2C_T_HD_STA);\n\n\tixgbe_lower_i2c_clk(hw, &i2cctl);\n\n\t \n\tudelay(IXGBE_I2C_T_LOW);\n\n}\n\n \nstatic void ixgbe_i2c_stop(struct ixgbe_hw *hw)\n{\n\tu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\tu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\n\tu32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN(hw);\n\tu32 bb_en_bit = IXGBE_I2C_BB_EN(hw);\n\n\t \n\tixgbe_set_i2c_data(hw, &i2cctl, 0);\n\tixgbe_raise_i2c_clk(hw, &i2cctl);\n\n\t \n\tudelay(IXGBE_I2C_T_SU_STO);\n\n\tixgbe_set_i2c_data(hw, &i2cctl, 1);\n\n\t \n\tudelay(IXGBE_I2C_T_BUF);\n\n\tif (bb_en_bit || data_oe_bit || clk_oe_bit) {\n\t\ti2cctl &= ~bb_en_bit;\n\t\ti2cctl |= data_oe_bit | clk_oe_bit;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n}\n\n \nstatic s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data)\n{\n\ts32 i;\n\tbool bit = false;\n\n\t*data = 0;\n\tfor (i = 7; i >= 0; i--) {\n\t\tixgbe_clock_in_i2c_bit(hw, &bit);\n\t\t*data |= bit << i;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data)\n{\n\ts32 status;\n\ts32 i;\n\tu32 i2cctl;\n\tbool bit = false;\n\n\tfor (i = 7; i >= 0; i--) {\n\t\tbit = (data >> i) & 0x1;\n\t\tstatus = ixgbe_clock_out_i2c_bit(hw, bit);\n\n\t\tif (status != 0)\n\t\t\tbreak;\n\t}\n\n\t \n\ti2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\ti2cctl |= IXGBE_I2C_DATA_OUT(hw);\n\ti2cctl |= IXGBE_I2C_DATA_OE_N_EN(hw);\n\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw)\n{\n\tu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\n\ts32 status = 0;\n\tu32 i = 0;\n\tu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\tu32 timeout = 10;\n\tbool ack = true;\n\n\tif (data_oe_bit) {\n\t\ti2cctl |= IXGBE_I2C_DATA_OUT(hw);\n\t\ti2cctl |= data_oe_bit;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n\tixgbe_raise_i2c_clk(hw, &i2cctl);\n\n\t \n\tudelay(IXGBE_I2C_T_HIGH);\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\ti2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\t\tack = ixgbe_get_i2c_data(hw, &i2cctl);\n\n\t\tudelay(1);\n\t\tif (ack == 0)\n\t\t\tbreak;\n\t}\n\n\tif (ack == 1) {\n\t\thw_dbg(hw, \"I2C ack was not received.\\n\");\n\t\tstatus = IXGBE_ERR_I2C;\n\t}\n\n\tixgbe_lower_i2c_clk(hw, &i2cctl);\n\n\t \n\tudelay(IXGBE_I2C_T_LOW);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data)\n{\n\tu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\tu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\n\n\tif (data_oe_bit) {\n\t\ti2cctl |= IXGBE_I2C_DATA_OUT(hw);\n\t\ti2cctl |= data_oe_bit;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n\tixgbe_raise_i2c_clk(hw, &i2cctl);\n\n\t \n\tudelay(IXGBE_I2C_T_HIGH);\n\n\ti2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\t*data = ixgbe_get_i2c_data(hw, &i2cctl);\n\n\tixgbe_lower_i2c_clk(hw, &i2cctl);\n\n\t \n\tudelay(IXGBE_I2C_T_LOW);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data)\n{\n\ts32 status;\n\tu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\n\tstatus = ixgbe_set_i2c_data(hw, &i2cctl, data);\n\tif (status == 0) {\n\t\tixgbe_raise_i2c_clk(hw, &i2cctl);\n\n\t\t \n\t\tudelay(IXGBE_I2C_T_HIGH);\n\n\t\tixgbe_lower_i2c_clk(hw, &i2cctl);\n\n\t\t \n\t\tudelay(IXGBE_I2C_T_LOW);\n\t} else {\n\t\thw_dbg(hw, \"I2C data was not set to %X\\n\", data);\n\t\treturn IXGBE_ERR_I2C;\n\t}\n\n\treturn 0;\n}\n \nstatic void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)\n{\n\tu32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN(hw);\n\tu32 i = 0;\n\tu32 timeout = IXGBE_I2C_CLOCK_STRETCHING_TIMEOUT;\n\tu32 i2cctl_r = 0;\n\n\tif (clk_oe_bit) {\n\t\t*i2cctl |= clk_oe_bit;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\n\t}\n\n\tfor (i = 0; i < timeout; i++) {\n\t\t*i2cctl |= IXGBE_I2C_CLK_OUT(hw);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t\t \n\t\tudelay(IXGBE_I2C_T_RISE);\n\n\t\ti2cctl_r = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\t\tif (i2cctl_r & IXGBE_I2C_CLK_IN(hw))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)\n{\n\n\t*i2cctl &= ~IXGBE_I2C_CLK_OUT(hw);\n\t*i2cctl &= ~IXGBE_I2C_CLK_OE_N_EN(hw);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tudelay(IXGBE_I2C_T_FALL);\n}\n\n \nstatic s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data)\n{\n\tu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\n\n\tif (data)\n\t\t*i2cctl |= IXGBE_I2C_DATA_OUT(hw);\n\telse\n\t\t*i2cctl &= ~IXGBE_I2C_DATA_OUT(hw);\n\t*i2cctl &= ~data_oe_bit;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tudelay(IXGBE_I2C_T_RISE + IXGBE_I2C_T_FALL + IXGBE_I2C_T_SU_DATA);\n\n\tif (!data)\t \n\t\treturn 0;\n\tif (data_oe_bit) {\n\t\t*i2cctl |= data_oe_bit;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t}\n\n\t \n\t*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\tif (data != ixgbe_get_i2c_data(hw, i2cctl)) {\n\t\thw_dbg(hw, \"Error - I2C data was not set to %X.\\n\", data);\n\t\treturn IXGBE_ERR_I2C;\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl)\n{\n\tu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\n\n\tif (data_oe_bit) {\n\t\t*i2cctl |= data_oe_bit;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\t\tudelay(IXGBE_I2C_T_FALL);\n\t}\n\n\tif (*i2cctl & IXGBE_I2C_DATA_IN(hw))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)\n{\n\tu32 i2cctl;\n\tu32 i;\n\n\tixgbe_i2c_start(hw);\n\ti2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\n\n\tixgbe_set_i2c_data(hw, &i2cctl, 1);\n\n\tfor (i = 0; i < 9; i++) {\n\t\tixgbe_raise_i2c_clk(hw, &i2cctl);\n\n\t\t \n\t\tudelay(IXGBE_I2C_T_HIGH);\n\n\t\tixgbe_lower_i2c_clk(hw, &i2cctl);\n\n\t\t \n\t\tudelay(IXGBE_I2C_T_LOW);\n\t}\n\n\tixgbe_i2c_start(hw);\n\n\t \n\tixgbe_i2c_stop(hw);\n}\n\n \ns32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw)\n{\n\tu16 phy_data = 0;\n\n\tif (hw->device_id != IXGBE_DEV_ID_82599_T3_LOM)\n\t\treturn 0;\n\n\t \n\thw->phy.ops.read_reg(hw, IXGBE_TN_LASI_STATUS_REG,\n\t\t\t     MDIO_MMD_PMAPMD, &phy_data);\n\n\tif (!(phy_data & IXGBE_TN_LASI_STATUS_TEMP_ALARM))\n\t\treturn 0;\n\n\treturn IXGBE_ERR_OVERTEMP;\n}\n\n \ns32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on)\n{\n\tu32 status;\n\tu16 reg;\n\n\t \n\tif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)\n\t\treturn 0;\n\n\tif (!on && ixgbe_mng_present(hw))\n\t\treturn 0;\n\n\tstatus = hw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_VEND1, &reg);\n\tif (status)\n\t\treturn status;\n\n\tif (on) {\n\t\treg &= ~IXGBE_MDIO_PHY_SET_LOW_POWER_MODE;\n\t} else {\n\t\tif (ixgbe_check_reset_blocked(hw))\n\t\t\treturn 0;\n\t\treg |= IXGBE_MDIO_PHY_SET_LOW_POWER_MODE;\n\t}\n\n\tstatus = hw->phy.ops.write_reg(hw, MDIO_CTRL1, MDIO_MMD_VEND1, reg);\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}