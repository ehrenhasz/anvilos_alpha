{
  "module_name": "ixgbe_ptp.c",
  "hash_id": "5508813b51f1686b142e553df01e03814c39c786fa43f3fa3e23886ff7f07162",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c",
  "human_readable_source": "\n \n\n#include \"ixgbe.h\"\n#include <linux/ptp_classify.h>\n#include <linux/clocksource.h>\n\n \n#define IXGBE_INCVAL_10GB 0x66666666\n#define IXGBE_INCVAL_1GB  0x40000000\n#define IXGBE_INCVAL_100  0x50000000\n\n#define IXGBE_INCVAL_SHIFT_10GB  28\n#define IXGBE_INCVAL_SHIFT_1GB   24\n#define IXGBE_INCVAL_SHIFT_100   21\n\n#define IXGBE_INCVAL_SHIFT_82599 7\n#define IXGBE_INCPER_SHIFT_82599 24\n\n#define IXGBE_OVERFLOW_PERIOD    (HZ * 30)\n#define IXGBE_PTP_TX_TIMEOUT     (HZ)\n\n \n#define NS_PER_SEC      1000000000ULL\n#define NS_PER_HALF_SEC  500000000ULL\n\n \n#define IXGBE_X550_BASE_PERIOD 0xC80000000ULL\n#define INCVALUE_MASK\t0x7FFFFFFF\n#define ISGN\t\t0x80000000\n\n \nstatic void ixgbe_ptp_setup_sdp_X540(struct ixgbe_adapter *adapter)\n{\n\tstruct cyclecounter *cc = &adapter->hw_cc;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 esdp, tsauxc, clktiml, clktimh, trgttiml, trgttimh, rem;\n\tu64 ns = 0, clock_edge = 0, clock_period;\n\tunsigned long flags;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, 0x0);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tif (!(adapter->flags2 & IXGBE_FLAG2_PTP_PPS_ENABLED))\n\t\treturn;\n\n\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\n\t \n\tesdp |= IXGBE_ESDP_SDP0_DIR |\n\t\tIXGBE_ESDP_SDP0_NATIVE;\n\n\t \n\ttsauxc = (IXGBE_TSAUXC_EN_CLK |\n\t\t  IXGBE_TSAUXC_SYNCLK |\n\t\t  IXGBE_TSAUXC_SDP0_INT);\n\n\t \n\tclock_period = div_u64((NS_PER_HALF_SEC << cc->shift), cc->mult);\n\tclktiml = (u32)(clock_period);\n\tclktimh = (u32)(clock_period >> 32);\n\n\t \n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\tns = timecounter_read(&adapter->hw_tc);\n\tclock_edge = adapter->hw_tc.cycle_last;\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\t \n\tdiv_u64_rem(ns, NS_PER_SEC, &rem);\n\n\t \n\trem = (NS_PER_SEC - rem);\n\n\t \n\tclock_edge += div_u64(((u64)rem << cc->shift), cc->mult);\n\ttrgttiml = (u32)clock_edge;\n\ttrgttimh = (u32)(clock_edge >> 32);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_CLKTIML, clktiml);\n\tIXGBE_WRITE_REG(hw, IXGBE_CLKTIMH, clktimh);\n\tIXGBE_WRITE_REG(hw, IXGBE_TRGTTIML0, trgttiml);\n\tIXGBE_WRITE_REG(hw, IXGBE_TRGTTIMH0, trgttimh);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\tIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, tsauxc);\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic void ixgbe_ptp_setup_sdp_X550(struct ixgbe_adapter *adapter)\n{\n\tu32 esdp, tsauxc, freqout, trgttiml, trgttimh, rem, tssdp;\n\tstruct cyclecounter *cc = &adapter->hw_cc;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu64 ns = 0, clock_edge = 0;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, 0x0);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tif (!(adapter->flags2 & IXGBE_FLAG2_PTP_PPS_ENABLED))\n\t\treturn;\n\n\tesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\n\t \n\tesdp |= IXGBE_ESDP_SDP0_DIR |\n\t\tIXGBE_ESDP_SDP0_NATIVE;\n\n\t \n#define IXGBE_TSAUXC_DIS_TS_CLEAR 0x40000000\n\ttsauxc = (IXGBE_TSAUXC_EN_CLK | IXGBE_TSAUXC_ST0 |\n\t\t  IXGBE_TSAUXC_EN_TT0 | IXGBE_TSAUXC_SDP0_INT |\n\t\t  IXGBE_TSAUXC_DIS_TS_CLEAR);\n\n\ttssdp = (IXGBE_TSSDP_TS_SDP0_EN |\n\t\t IXGBE_TSSDP_TS_SDP0_CLK0);\n\n\t \n\tfreqout = div_u64(NS_PER_HALF_SEC << cc->shift,  cc->mult);\n\n\t \n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\tns = timecounter_read(&adapter->hw_tc);\n\tclock_edge = adapter->hw_tc.cycle_last;\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\t \n\tdiv_u64_rem(ns, NS_PER_SEC, &rem);\n\n\t \n\trem = (NS_PER_SEC - rem);\n\n\t \n\tclock_edge += div_u64(((u64)rem << cc->shift), cc->mult);\n\n\t \n\tts = ns_to_timespec64(clock_edge);\n\ttrgttiml = (u32)ts.tv_nsec;\n\ttrgttimh = (u32)ts.tv_sec;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_FREQOUT0, freqout);\n\tIXGBE_WRITE_REG(hw, IXGBE_TRGTTIML0, trgttiml);\n\tIXGBE_WRITE_REG(hw, IXGBE_TRGTTIMH0, trgttimh);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\n\tIXGBE_WRITE_REG(hw, IXGBE_TSSDP, tssdp);\n\tIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, tsauxc);\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic u64 ixgbe_ptp_read_X550(const struct cyclecounter *cc)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\tcontainer_of(cc, struct ixgbe_adapter, hw_cc);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct timespec64 ts;\n\n\t \n\tIXGBE_READ_REG(hw, IXGBE_SYSTIMR);\n\tts.tv_nsec = IXGBE_READ_REG(hw, IXGBE_SYSTIML);\n\tts.tv_sec = IXGBE_READ_REG(hw, IXGBE_SYSTIMH);\n\n\treturn (u64)timespec64_to_ns(&ts);\n}\n\n \nstatic u64 ixgbe_ptp_read_82599(const struct cyclecounter *cc)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\tcontainer_of(cc, struct ixgbe_adapter, hw_cc);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu64 stamp = 0;\n\n\tstamp |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIML);\n\tstamp |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIMH) << 32;\n\n\treturn stamp;\n}\n\n \nstatic void ixgbe_ptp_convert_to_hwtstamp(struct ixgbe_adapter *adapter,\n\t\t\t\t\t  struct skb_shared_hwtstamps *hwtstamp,\n\t\t\t\t\t  u64 timestamp)\n{\n\tunsigned long flags;\n\tstruct timespec64 systime;\n\tu64 ns;\n\n\tmemset(hwtstamp, 0, sizeof(*hwtstamp));\n\n\tswitch (adapter->hw.mac.type) {\n\t \n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\t \n\t\tsystime.tv_sec = timestamp >> 32;\n\t\tsystime.tv_nsec = timestamp & 0xFFFFFFFF;\n\n\t\ttimestamp = timespec64_to_ns(&systime);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\tns = timecounter_cyc2time(&adapter->hw_tc, timestamp);\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\thwtstamp->hwtstamp = ns_to_ktime(ns);\n}\n\n \nstatic int ixgbe_ptp_adjfine_82599(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\tcontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu64 incval;\n\n\tsmp_mb();\n\tincval = READ_ONCE(adapter->base_incval);\n\tincval = adjust_by_scaled_ppm(incval, scaled_ppm);\n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_X540:\n\t\tif (incval > 0xFFFFFFFFULL)\n\t\t\te_dev_warn(\"PTP scaled_ppm adjusted SYSTIME rate overflowed!\\n\");\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, (u32)incval);\n\t\tbreak;\n\tcase ixgbe_mac_82599EB:\n\t\tif (incval > 0x00FFFFFFULL)\n\t\t\te_dev_warn(\"PTP scaled_ppm adjusted SYSTIME rate overflowed!\\n\");\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TIMINCA,\n\t\t\t\tBIT(IXGBE_INCPER_SHIFT_82599) |\n\t\t\t\t((u32)incval & 0x00FFFFFFUL));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ixgbe_ptp_adjfine_X550(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\t\tcontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tbool neg_adj;\n\tu64 rate;\n\tu32 inca;\n\n\tneg_adj = diff_by_scaled_ppm(IXGBE_X550_BASE_PERIOD, scaled_ppm, &rate);\n\n\t \n\tif (rate >= INCVALUE_MASK)\n\t\te_dev_warn(\"PTP scaled_ppm adjusted SYSTIME rate overflowed!\\n\");\n\n\tinca = rate & INCVALUE_MASK;\n\tif (neg_adj)\n\t\tinca |= ISGN;\n\n\tIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, inca);\n\n\treturn 0;\n}\n\n \nstatic int ixgbe_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\tcontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\ttimecounter_adjtime(&adapter->hw_tc, delta);\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\tif (adapter->ptp_setup_sdp)\n\t\tadapter->ptp_setup_sdp(adapter);\n\n\treturn 0;\n}\n\n \nstatic int ixgbe_ptp_gettimex(struct ptp_clock_info *ptp,\n\t\t\t      struct timespec64 *ts,\n\t\t\t      struct ptp_system_timestamp *sts)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\tcontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tu64 ns, stamp;\n\n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\t \n\t\tptp_read_system_prets(sts);\n\t\tIXGBE_READ_REG(hw, IXGBE_SYSTIMR);\n\t\tptp_read_system_postts(sts);\n\t\tts->tv_nsec = IXGBE_READ_REG(hw, IXGBE_SYSTIML);\n\t\tts->tv_sec = IXGBE_READ_REG(hw, IXGBE_SYSTIMH);\n\t\tstamp = timespec64_to_ns(ts);\n\t\tbreak;\n\tdefault:\n\t\tptp_read_system_prets(sts);\n\t\tstamp = IXGBE_READ_REG(hw, IXGBE_SYSTIML);\n\t\tptp_read_system_postts(sts);\n\t\tstamp |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIMH) << 32;\n\t\tbreak;\n\t}\n\n\tns = timecounter_cyc2time(&adapter->hw_tc, stamp);\n\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\n \nstatic int ixgbe_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t     const struct timespec64 *ts)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\tcontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\n\tunsigned long flags;\n\tu64 ns = timespec64_to_ns(ts);\n\n\t \n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\ttimecounter_init(&adapter->hw_tc, &adapter->hw_cc, ns);\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\tif (adapter->ptp_setup_sdp)\n\t\tadapter->ptp_setup_sdp(adapter);\n\treturn 0;\n}\n\n \nstatic int ixgbe_ptp_feature_enable(struct ptp_clock_info *ptp,\n\t\t\t\t    struct ptp_clock_request *rq, int on)\n{\n\tstruct ixgbe_adapter *adapter =\n\t\tcontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\n\n\t \n\tif (rq->type != PTP_CLK_REQ_PPS || !adapter->ptp_setup_sdp)\n\t\treturn -ENOTSUPP;\n\n\tif (on)\n\t\tadapter->flags2 |= IXGBE_FLAG2_PTP_PPS_ENABLED;\n\telse\n\t\tadapter->flags2 &= ~IXGBE_FLAG2_PTP_PPS_ENABLED;\n\n\tadapter->ptp_setup_sdp(adapter);\n\treturn 0;\n}\n\n \nvoid ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct ptp_clock_event event;\n\n\tevent.type = PTP_CLOCK_PPS;\n\n\t \n\tif (!adapter->ptp_clock)\n\t\treturn;\n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_X540:\n\t\tptp_clock_event(adapter->ptp_clock, &event);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter)\n{\n\tbool timeout = time_is_before_jiffies(adapter->last_overflow_check +\n\t\t\t\t\t     IXGBE_OVERFLOW_PERIOD);\n\tunsigned long flags;\n\n\tif (timeout) {\n\t\t \n\t\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\t\ttimecounter_read(&adapter->hw_tc);\n\t\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\t\tadapter->last_overflow_check = jiffies;\n\t}\n}\n\n \nvoid ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 tsyncrxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\n\tstruct ixgbe_ring *rx_ring;\n\tunsigned long rx_event;\n\tint n;\n\n\t \n\tif (!(tsyncrxctl & IXGBE_TSYNCRXCTL_VALID)) {\n\t\tadapter->last_rx_ptp_check = jiffies;\n\t\treturn;\n\t}\n\n\t \n\trx_event = adapter->last_rx_ptp_check;\n\tfor (n = 0; n < adapter->num_rx_queues; n++) {\n\t\trx_ring = adapter->rx_ring[n];\n\t\tif (time_after(rx_ring->last_rx_timestamp, rx_event))\n\t\t\trx_event = rx_ring->last_rx_timestamp;\n\t}\n\n\t \n\tif (time_is_before_jiffies(rx_event + 5 * HZ)) {\n\t\tIXGBE_READ_REG(hw, IXGBE_RXSTMPH);\n\t\tadapter->last_rx_ptp_check = jiffies;\n\n\t\tadapter->rx_hwtstamp_cleared++;\n\t\te_warn(drv, \"clearing RX Timestamp hang\\n\");\n\t}\n}\n\n \nstatic void ixgbe_ptp_clear_tx_timestamp(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\tIXGBE_READ_REG(hw, IXGBE_TXSTMPH);\n\tif (adapter->ptp_tx_skb) {\n\t\tdev_kfree_skb_any(adapter->ptp_tx_skb);\n\t\tadapter->ptp_tx_skb = NULL;\n\t}\n\tclear_bit_unlock(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state);\n}\n\n \nvoid ixgbe_ptp_tx_hang(struct ixgbe_adapter *adapter)\n{\n\tbool timeout = time_is_before_jiffies(adapter->ptp_tx_start +\n\t\t\t\t\t      IXGBE_PTP_TX_TIMEOUT);\n\n\tif (!adapter->ptp_tx_skb)\n\t\treturn;\n\n\tif (!test_bit(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state))\n\t\treturn;\n\n\t \n\tif (timeout) {\n\t\tcancel_work_sync(&adapter->ptp_tx_work);\n\t\tixgbe_ptp_clear_tx_timestamp(adapter);\n\t\tadapter->tx_hwtstamp_timeouts++;\n\t\te_warn(drv, \"clearing Tx timestamp hang\\n\");\n\t}\n}\n\n \nstatic void ixgbe_ptp_tx_hwtstamp(struct ixgbe_adapter *adapter)\n{\n\tstruct sk_buff *skb = adapter->ptp_tx_skb;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tu64 regval = 0;\n\n\tregval |= (u64)IXGBE_READ_REG(hw, IXGBE_TXSTMPL);\n\tregval |= (u64)IXGBE_READ_REG(hw, IXGBE_TXSTMPH) << 32;\n\tixgbe_ptp_convert_to_hwtstamp(adapter, &shhwtstamps, regval);\n\n\t \n\tadapter->ptp_tx_skb = NULL;\n\tclear_bit_unlock(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state);\n\n\t \n\tskb_tstamp_tx(skb, &shhwtstamps);\n\tdev_kfree_skb_any(skb);\n}\n\n \nstatic void ixgbe_ptp_tx_hwtstamp_work(struct work_struct *work)\n{\n\tstruct ixgbe_adapter *adapter = container_of(work, struct ixgbe_adapter,\n\t\t\t\t\t\t     ptp_tx_work);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tbool timeout = time_is_before_jiffies(adapter->ptp_tx_start +\n\t\t\t\t\t      IXGBE_PTP_TX_TIMEOUT);\n\tu32 tsynctxctl;\n\n\t \n\tif (!adapter->ptp_tx_skb) {\n\t\tixgbe_ptp_clear_tx_timestamp(adapter);\n\t\treturn;\n\t}\n\n\t \n\ttsynctxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCTXCTL);\n\tif (tsynctxctl & IXGBE_TSYNCTXCTL_VALID) {\n\t\tixgbe_ptp_tx_hwtstamp(adapter);\n\t\treturn;\n\t}\n\n\tif (timeout) {\n\t\tixgbe_ptp_clear_tx_timestamp(adapter);\n\t\tadapter->tx_hwtstamp_timeouts++;\n\t\te_warn(drv, \"clearing Tx Timestamp hang\\n\");\n\t} else {\n\t\t \n\t\tschedule_work(&adapter->ptp_tx_work);\n\t}\n}\n\n \nvoid ixgbe_ptp_rx_pktstamp(struct ixgbe_q_vector *q_vector,\n\t\t\t   struct sk_buff *skb)\n{\n\t__le64 regval;\n\n\t \n\tskb_copy_bits(skb, skb->len - IXGBE_TS_HDR_LEN, &regval,\n\t\t      IXGBE_TS_HDR_LEN);\n\t__pskb_trim(skb, skb->len - IXGBE_TS_HDR_LEN);\n\n\t \n\tixgbe_ptp_convert_to_hwtstamp(q_vector->adapter, skb_hwtstamps(skb),\n\t\t\t\t      le64_to_cpu(regval));\n}\n\n \nvoid ixgbe_ptp_rx_rgtstamp(struct ixgbe_q_vector *q_vector,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct ixgbe_adapter *adapter;\n\tstruct ixgbe_hw *hw;\n\tu64 regval = 0;\n\tu32 tsyncrxctl;\n\n\t \n\tif (!q_vector || !q_vector->adapter)\n\t\treturn;\n\n\tadapter = q_vector->adapter;\n\thw = &adapter->hw;\n\n\t \n\n\ttsyncrxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\n\tif (!(tsyncrxctl & IXGBE_TSYNCRXCTL_VALID))\n\t\treturn;\n\n\tregval |= (u64)IXGBE_READ_REG(hw, IXGBE_RXSTMPL);\n\tregval |= (u64)IXGBE_READ_REG(hw, IXGBE_RXSTMPH) << 32;\n\n\tixgbe_ptp_convert_to_hwtstamp(adapter, skb_hwtstamps(skb), regval);\n}\n\n \nint ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config *config = &adapter->tstamp_config;\n\n\treturn copy_to_user(ifr->ifr_data, config,\n\t\t\t    sizeof(*config)) ? -EFAULT : 0;\n}\n\n \nstatic int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter,\n\t\t\t\t struct hwtstamp_config *config)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 tsync_tx_ctl = IXGBE_TSYNCTXCTL_ENABLED;\n\tu32 tsync_rx_ctl = IXGBE_TSYNCRXCTL_ENABLED;\n\tu32 tsync_rx_mtrl = PTP_EV_PORT << 16;\n\tu32 aflags = adapter->flags;\n\tbool is_l2 = false;\n\tu32 regval;\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\ttsync_tx_ctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ttsync_rx_ctl = 0;\n\t\ttsync_rx_mtrl = 0;\n\t\taflags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\n\t\t\t    IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\ttsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_L4_V1;\n\t\ttsync_rx_mtrl |= IXGBE_RXMTRL_V1_SYNC_MSG;\n\t\taflags |= (IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\n\t\t\t   IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\ttsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_L4_V1;\n\t\ttsync_rx_mtrl |= IXGBE_RXMTRL_V1_DELAY_REQ_MSG;\n\t\taflags |= (IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\n\t\t\t   IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\ttsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_EVENT_V2;\n\t\tis_l2 = true;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\taflags |= (IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\n\t\t\t   IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\tcase HWTSTAMP_FILTER_ALL:\n\t\t \n\t\tif (hw->mac.type >= ixgbe_mac_X550) {\n\t\t\ttsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_ALL;\n\t\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\t\taflags |= IXGBE_FLAG_RX_HWTSTAMP_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tconfig->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\treturn -ERANGE;\n\t}\n\n\tif (hw->mac.type == ixgbe_mac_82598EB) {\n\t\tadapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\n\t\t\t\t    IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\n\t\tif (tsync_rx_ctl | tsync_tx_ctl)\n\t\t\treturn -ERANGE;\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\t \n\t\tif (config->rx_filter == HWTSTAMP_FILTER_NONE)\n\t\t\tbreak;\n\n\t\ttsync_rx_ctl = IXGBE_TSYNCRXCTL_ENABLED |\n\t\t\t       IXGBE_TSYNCRXCTL_TYPE_ALL |\n\t\t\t       IXGBE_TSYNCRXCTL_TSIP_UT_EN;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\taflags |= IXGBE_FLAG_RX_HWTSTAMP_ENABLED;\n\t\taflags &= ~IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER;\n\t\tis_l2 = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (is_l2)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_1588),\n\t\t\t\t(IXGBE_ETQF_FILTER_EN |  \n\t\t\t\t IXGBE_ETQF_1588 |  \n\t\t\t\t ETH_P_1588));      \n\telse\n\t\tIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_1588), 0);\n\n\t \n\tregval = IXGBE_READ_REG(hw, IXGBE_TSYNCTXCTL);\n\tregval &= ~IXGBE_TSYNCTXCTL_ENABLED;\n\tregval |= tsync_tx_ctl;\n\tIXGBE_WRITE_REG(hw, IXGBE_TSYNCTXCTL, regval);\n\n\t \n\tregval = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\n\tregval &= ~(IXGBE_TSYNCRXCTL_ENABLED | IXGBE_TSYNCRXCTL_TYPE_MASK);\n\tregval |= tsync_rx_ctl;\n\tIXGBE_WRITE_REG(hw, IXGBE_TSYNCRXCTL, regval);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_RXMTRL, tsync_rx_mtrl);\n\n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tadapter->flags = aflags;\n\n\t \n\tixgbe_ptp_clear_tx_timestamp(adapter);\n\tIXGBE_READ_REG(hw, IXGBE_RXSTMPH);\n\n\treturn 0;\n}\n\n \nint ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = ixgbe_ptp_set_timestamp_mode(adapter, &config);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmemcpy(&adapter->tstamp_config, &config,\n\t       sizeof(adapter->tstamp_config));\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\nstatic void ixgbe_ptp_link_speed_adjust(struct ixgbe_adapter *adapter,\n\t\t\t\t\tu32 *shift, u32 *incval)\n{\n\t \n\tswitch (adapter->link_speed) {\n\tcase IXGBE_LINK_SPEED_100_FULL:\n\t\t*shift = IXGBE_INCVAL_SHIFT_100;\n\t\t*incval = IXGBE_INCVAL_100;\n\t\tbreak;\n\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\t*shift = IXGBE_INCVAL_SHIFT_1GB;\n\t\t*incval = IXGBE_INCVAL_1GB;\n\t\tbreak;\n\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\tdefault:\n\t\t*shift = IXGBE_INCVAL_SHIFT_10GB;\n\t\t*incval = IXGBE_INCVAL_10GB;\n\t\tbreak;\n\t}\n}\n\n \nvoid ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct cyclecounter cc;\n\tunsigned long flags;\n\tu32 incval = 0;\n\tu32 fuse0 = 0;\n\n\t \n\tcc.mask = CLOCKSOURCE_MASK(64);\n\tcc.mult = 1;\n\tcc.shift = 0;\n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_X550EM_x:\n\t\t \n\t\tfuse0 = IXGBE_READ_REG(hw, IXGBE_FUSES0_GROUP(0));\n\t\tif (!(fuse0 & IXGBE_FUSES0_300MHZ)) {\n\t\t\tcc.mult = 3;\n\t\t\tcc.shift = 2;\n\t\t}\n\t\tfallthrough;\n\tcase ixgbe_mac_x550em_a:\n\tcase ixgbe_mac_X550:\n\t\tcc.read = ixgbe_ptp_read_X550;\n\t\tbreak;\n\tcase ixgbe_mac_X540:\n\t\tcc.read = ixgbe_ptp_read_82599;\n\n\t\tixgbe_ptp_link_speed_adjust(adapter, &cc.shift, &incval);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, incval);\n\t\tbreak;\n\tcase ixgbe_mac_82599EB:\n\t\tcc.read = ixgbe_ptp_read_82599;\n\n\t\tixgbe_ptp_link_speed_adjust(adapter, &cc.shift, &incval);\n\t\tincval >>= IXGBE_INCVAL_SHIFT_82599;\n\t\tcc.shift -= IXGBE_INCVAL_SHIFT_82599;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TIMINCA,\n\t\t\t\tBIT(IXGBE_INCPER_SHIFT_82599) | incval);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tWRITE_ONCE(adapter->base_incval, incval);\n\tsmp_mb();\n\n\t \n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\tmemcpy(&adapter->hw_cc, &cc, sizeof(adapter->hw_cc));\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n}\n\n \nstatic void ixgbe_ptp_init_systime(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 tsauxc;\n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\tcase ixgbe_mac_X550:\n\t\ttsauxc = IXGBE_READ_REG(hw, IXGBE_TSAUXC);\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_SYSTIMR, 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_SYSTIML, 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_SYSTIMH, 0);\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_TSIM, IXGBE_TSIM_TXTS);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_EIMS, IXGBE_EIMS_TIMESYNC);\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_TSAUXC,\n\t\t\t\ttsauxc & ~IXGBE_TSAUXC_DISABLE_SYSTIME);\n\t\tbreak;\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_82599EB:\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_SYSTIML, 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_SYSTIMH, 0);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nvoid ixgbe_ptp_reset(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\n\t \n\tixgbe_ptp_set_timestamp_mode(adapter, &adapter->tstamp_config);\n\n\t \n\tif (hw->mac.type == ixgbe_mac_82598EB)\n\t\treturn;\n\n\tixgbe_ptp_start_cyclecounter(adapter);\n\n\tixgbe_ptp_init_systime(adapter);\n\n\tspin_lock_irqsave(&adapter->tmreg_lock, flags);\n\ttimecounter_init(&adapter->hw_tc, &adapter->hw_cc,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\tspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\n\n\tadapter->last_overflow_check = jiffies;\n\n\t \n\tif (adapter->ptp_setup_sdp)\n\t\tadapter->ptp_setup_sdp(adapter);\n}\n\n \nstatic long ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tlong err;\n\n\t \n\tif (!IS_ERR_OR_NULL(adapter->ptp_clock))\n\t\treturn 0;\n\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_X540:\n\t\tsnprintf(adapter->ptp_caps.name,\n\t\t\t sizeof(adapter->ptp_caps.name),\n\t\t\t \"%s\", netdev->name);\n\t\tadapter->ptp_caps.owner = THIS_MODULE;\n\t\tadapter->ptp_caps.max_adj = 250000000;\n\t\tadapter->ptp_caps.n_alarm = 0;\n\t\tadapter->ptp_caps.n_ext_ts = 0;\n\t\tadapter->ptp_caps.n_per_out = 0;\n\t\tadapter->ptp_caps.pps = 1;\n\t\tadapter->ptp_caps.adjfine = ixgbe_ptp_adjfine_82599;\n\t\tadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\n\t\tadapter->ptp_caps.gettimex64 = ixgbe_ptp_gettimex;\n\t\tadapter->ptp_caps.settime64 = ixgbe_ptp_settime;\n\t\tadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\n\t\tadapter->ptp_setup_sdp = ixgbe_ptp_setup_sdp_X540;\n\t\tbreak;\n\tcase ixgbe_mac_82599EB:\n\t\tsnprintf(adapter->ptp_caps.name,\n\t\t\t sizeof(adapter->ptp_caps.name),\n\t\t\t \"%s\", netdev->name);\n\t\tadapter->ptp_caps.owner = THIS_MODULE;\n\t\tadapter->ptp_caps.max_adj = 250000000;\n\t\tadapter->ptp_caps.n_alarm = 0;\n\t\tadapter->ptp_caps.n_ext_ts = 0;\n\t\tadapter->ptp_caps.n_per_out = 0;\n\t\tadapter->ptp_caps.pps = 0;\n\t\tadapter->ptp_caps.adjfine = ixgbe_ptp_adjfine_82599;\n\t\tadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\n\t\tadapter->ptp_caps.gettimex64 = ixgbe_ptp_gettimex;\n\t\tadapter->ptp_caps.settime64 = ixgbe_ptp_settime;\n\t\tadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\n\t\tbreak;\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\tsnprintf(adapter->ptp_caps.name, 16, \"%s\", netdev->name);\n\t\tadapter->ptp_caps.owner = THIS_MODULE;\n\t\tadapter->ptp_caps.max_adj = 30000000;\n\t\tadapter->ptp_caps.n_alarm = 0;\n\t\tadapter->ptp_caps.n_ext_ts = 0;\n\t\tadapter->ptp_caps.n_per_out = 0;\n\t\tadapter->ptp_caps.pps = 1;\n\t\tadapter->ptp_caps.adjfine = ixgbe_ptp_adjfine_X550;\n\t\tadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\n\t\tadapter->ptp_caps.gettimex64 = ixgbe_ptp_gettimex;\n\t\tadapter->ptp_caps.settime64 = ixgbe_ptp_settime;\n\t\tadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\n\t\tadapter->ptp_setup_sdp = ixgbe_ptp_setup_sdp_X550;\n\t\tbreak;\n\tdefault:\n\t\tadapter->ptp_clock = NULL;\n\t\tadapter->ptp_setup_sdp = NULL;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tadapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,\n\t\t\t\t\t\t&adapter->pdev->dev);\n\tif (IS_ERR(adapter->ptp_clock)) {\n\t\terr = PTR_ERR(adapter->ptp_clock);\n\t\tadapter->ptp_clock = NULL;\n\t\te_dev_err(\"ptp_clock_register failed\\n\");\n\t\treturn err;\n\t} else if (adapter->ptp_clock)\n\t\te_dev_info(\"registered PHC device on %s\\n\", netdev->name);\n\n\t \n\tadapter->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\n\tadapter->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\n\n\treturn 0;\n}\n\n \nvoid ixgbe_ptp_init(struct ixgbe_adapter *adapter)\n{\n\t \n\tspin_lock_init(&adapter->tmreg_lock);\n\n\t \n\tif (ixgbe_ptp_create_clock(adapter))\n\t\treturn;\n\n\t \n\tINIT_WORK(&adapter->ptp_tx_work, ixgbe_ptp_tx_hwtstamp_work);\n\n\t \n\tixgbe_ptp_reset(adapter);\n\n\t \n\tset_bit(__IXGBE_PTP_RUNNING, &adapter->state);\n\n\treturn;\n}\n\n \nvoid ixgbe_ptp_suspend(struct ixgbe_adapter *adapter)\n{\n\t \n\tif (!test_and_clear_bit(__IXGBE_PTP_RUNNING, &adapter->state))\n\t\treturn;\n\n\tadapter->flags2 &= ~IXGBE_FLAG2_PTP_PPS_ENABLED;\n\tif (adapter->ptp_setup_sdp)\n\t\tadapter->ptp_setup_sdp(adapter);\n\n\t \n\tcancel_work_sync(&adapter->ptp_tx_work);\n\tixgbe_ptp_clear_tx_timestamp(adapter);\n}\n\n \nvoid ixgbe_ptp_stop(struct ixgbe_adapter *adapter)\n{\n\t \n\tixgbe_ptp_suspend(adapter);\n\n\t \n\tif (adapter->ptp_clock) {\n\t\tptp_clock_unregister(adapter->ptp_clock);\n\t\tadapter->ptp_clock = NULL;\n\t\te_dev_info(\"removed PHC on %s\\n\",\n\t\t\t   adapter->netdev->name);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}