{
  "module_name": "ixgbe_ethtool.c",
  "hash_id": "2f07b7d2673a63d142618ebf96bd63267efc53212f0088e049c58c5349da9067",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/uaccess.h>\n\n#include \"ixgbe.h\"\n#include \"ixgbe_phy.h\"\n\n\nenum {NETDEV_STATS, IXGBE_STATS};\n\nstruct ixgbe_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint type;\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define IXGBE_STAT(m)\t\tIXGBE_STATS, \\\n\t\t\t\tsizeof(((struct ixgbe_adapter *)0)->m), \\\n\t\t\t\toffsetof(struct ixgbe_adapter, m)\n#define IXGBE_NETDEV_STAT(m)\tNETDEV_STATS, \\\n\t\t\t\tsizeof(((struct rtnl_link_stats64 *)0)->m), \\\n\t\t\t\toffsetof(struct rtnl_link_stats64, m)\n\nstatic const struct ixgbe_stats ixgbe_gstrings_stats[] = {\n\t{\"rx_packets\", IXGBE_NETDEV_STAT(rx_packets)},\n\t{\"tx_packets\", IXGBE_NETDEV_STAT(tx_packets)},\n\t{\"rx_bytes\", IXGBE_NETDEV_STAT(rx_bytes)},\n\t{\"tx_bytes\", IXGBE_NETDEV_STAT(tx_bytes)},\n\t{\"rx_pkts_nic\", IXGBE_STAT(stats.gprc)},\n\t{\"tx_pkts_nic\", IXGBE_STAT(stats.gptc)},\n\t{\"rx_bytes_nic\", IXGBE_STAT(stats.gorc)},\n\t{\"tx_bytes_nic\", IXGBE_STAT(stats.gotc)},\n\t{\"lsc_int\", IXGBE_STAT(lsc_int)},\n\t{\"tx_busy\", IXGBE_STAT(tx_busy)},\n\t{\"non_eop_descs\", IXGBE_STAT(non_eop_descs)},\n\t{\"rx_errors\", IXGBE_NETDEV_STAT(rx_errors)},\n\t{\"tx_errors\", IXGBE_NETDEV_STAT(tx_errors)},\n\t{\"rx_dropped\", IXGBE_NETDEV_STAT(rx_dropped)},\n\t{\"tx_dropped\", IXGBE_NETDEV_STAT(tx_dropped)},\n\t{\"multicast\", IXGBE_NETDEV_STAT(multicast)},\n\t{\"broadcast\", IXGBE_STAT(stats.bprc)},\n\t{\"rx_no_buffer_count\", IXGBE_STAT(stats.rnbc[0]) },\n\t{\"collisions\", IXGBE_NETDEV_STAT(collisions)},\n\t{\"rx_over_errors\", IXGBE_NETDEV_STAT(rx_over_errors)},\n\t{\"rx_crc_errors\", IXGBE_NETDEV_STAT(rx_crc_errors)},\n\t{\"rx_frame_errors\", IXGBE_NETDEV_STAT(rx_frame_errors)},\n\t{\"hw_rsc_aggregated\", IXGBE_STAT(rsc_total_count)},\n\t{\"hw_rsc_flushed\", IXGBE_STAT(rsc_total_flush)},\n\t{\"fdir_match\", IXGBE_STAT(stats.fdirmatch)},\n\t{\"fdir_miss\", IXGBE_STAT(stats.fdirmiss)},\n\t{\"fdir_overflow\", IXGBE_STAT(fdir_overflow)},\n\t{\"rx_fifo_errors\", IXGBE_NETDEV_STAT(rx_fifo_errors)},\n\t{\"rx_missed_errors\", IXGBE_NETDEV_STAT(rx_missed_errors)},\n\t{\"tx_aborted_errors\", IXGBE_NETDEV_STAT(tx_aborted_errors)},\n\t{\"tx_carrier_errors\", IXGBE_NETDEV_STAT(tx_carrier_errors)},\n\t{\"tx_fifo_errors\", IXGBE_NETDEV_STAT(tx_fifo_errors)},\n\t{\"tx_heartbeat_errors\", IXGBE_NETDEV_STAT(tx_heartbeat_errors)},\n\t{\"tx_timeout_count\", IXGBE_STAT(tx_timeout_count)},\n\t{\"tx_restart_queue\", IXGBE_STAT(restart_queue)},\n\t{\"rx_length_errors\", IXGBE_STAT(stats.rlec)},\n\t{\"rx_long_length_errors\", IXGBE_STAT(stats.roc)},\n\t{\"rx_short_length_errors\", IXGBE_STAT(stats.ruc)},\n\t{\"tx_flow_control_xon\", IXGBE_STAT(stats.lxontxc)},\n\t{\"rx_flow_control_xon\", IXGBE_STAT(stats.lxonrxc)},\n\t{\"tx_flow_control_xoff\", IXGBE_STAT(stats.lxofftxc)},\n\t{\"rx_flow_control_xoff\", IXGBE_STAT(stats.lxoffrxc)},\n\t{\"rx_csum_offload_errors\", IXGBE_STAT(hw_csum_rx_error)},\n\t{\"alloc_rx_page\", IXGBE_STAT(alloc_rx_page)},\n\t{\"alloc_rx_page_failed\", IXGBE_STAT(alloc_rx_page_failed)},\n\t{\"alloc_rx_buff_failed\", IXGBE_STAT(alloc_rx_buff_failed)},\n\t{\"rx_no_dma_resources\", IXGBE_STAT(hw_rx_no_dma_resources)},\n\t{\"os2bmc_rx_by_bmc\", IXGBE_STAT(stats.o2bgptc)},\n\t{\"os2bmc_tx_by_bmc\", IXGBE_STAT(stats.b2ospc)},\n\t{\"os2bmc_tx_by_host\", IXGBE_STAT(stats.o2bspc)},\n\t{\"os2bmc_rx_by_host\", IXGBE_STAT(stats.b2ogprc)},\n\t{\"tx_hwtstamp_timeouts\", IXGBE_STAT(tx_hwtstamp_timeouts)},\n\t{\"tx_hwtstamp_skipped\", IXGBE_STAT(tx_hwtstamp_skipped)},\n\t{\"rx_hwtstamp_cleared\", IXGBE_STAT(rx_hwtstamp_cleared)},\n\t{\"tx_ipsec\", IXGBE_STAT(tx_ipsec)},\n\t{\"rx_ipsec\", IXGBE_STAT(rx_ipsec)},\n#ifdef IXGBE_FCOE\n\t{\"fcoe_bad_fccrc\", IXGBE_STAT(stats.fccrc)},\n\t{\"rx_fcoe_dropped\", IXGBE_STAT(stats.fcoerpdc)},\n\t{\"rx_fcoe_packets\", IXGBE_STAT(stats.fcoeprc)},\n\t{\"rx_fcoe_dwords\", IXGBE_STAT(stats.fcoedwrc)},\n\t{\"fcoe_noddp\", IXGBE_STAT(stats.fcoe_noddp)},\n\t{\"fcoe_noddp_ext_buff\", IXGBE_STAT(stats.fcoe_noddp_ext_buff)},\n\t{\"tx_fcoe_packets\", IXGBE_STAT(stats.fcoeptc)},\n\t{\"tx_fcoe_dwords\", IXGBE_STAT(stats.fcoedwtc)},\n#endif  \n};\n\n \n#define IXGBE_NUM_RX_QUEUES netdev->num_tx_queues\n\n#define IXGBE_QUEUE_STATS_LEN ( \\\n\t(netdev->num_tx_queues + IXGBE_NUM_RX_QUEUES) * \\\n\t(sizeof(struct ixgbe_queue_stats) / sizeof(u64)))\n#define IXGBE_GLOBAL_STATS_LEN ARRAY_SIZE(ixgbe_gstrings_stats)\n#define IXGBE_PB_STATS_LEN ( \\\n\t\t\t(sizeof(((struct ixgbe_adapter *)0)->stats.pxonrxc) + \\\n\t\t\t sizeof(((struct ixgbe_adapter *)0)->stats.pxontxc) + \\\n\t\t\t sizeof(((struct ixgbe_adapter *)0)->stats.pxoffrxc) + \\\n\t\t\t sizeof(((struct ixgbe_adapter *)0)->stats.pxofftxc)) \\\n\t\t\t/ sizeof(u64))\n#define IXGBE_STATS_LEN (IXGBE_GLOBAL_STATS_LEN + \\\n\t\t\t IXGBE_PB_STATS_LEN + \\\n\t\t\t IXGBE_QUEUE_STATS_LEN)\n\nstatic const char ixgbe_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register test  (offline)\", \"Eeprom test    (offline)\",\n\t\"Interrupt test (offline)\", \"Loopback test  (offline)\",\n\t\"Link test   (on/offline)\"\n};\n#define IXGBE_TEST_LEN sizeof(ixgbe_gstrings_test) / ETH_GSTRING_LEN\n\nstatic const char ixgbe_priv_flags_strings[][ETH_GSTRING_LEN] = {\n#define IXGBE_PRIV_FLAGS_LEGACY_RX\tBIT(0)\n\t\"legacy-rx\",\n#define IXGBE_PRIV_FLAGS_VF_IPSEC_EN\tBIT(1)\n\t\"vf-ipsec\",\n#define IXGBE_PRIV_FLAGS_AUTO_DISABLE_VF\tBIT(2)\n\t\"mdd-disable-vf\",\n};\n\n#define IXGBE_PRIV_FLAGS_STR_LEN ARRAY_SIZE(ixgbe_priv_flags_strings)\n\n#define ixgbe_isbackplane(type) ((type) == ixgbe_media_type_backplane)\n\nstatic void ixgbe_set_supported_10gtypes(struct ixgbe_hw *hw,\n\t\t\t\t\t struct ethtool_link_ksettings *cmd)\n{\n\tif (!ixgbe_isbackplane(hw->phy.media_type)) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\treturn;\n\t}\n\n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_82598:\n\tcase IXGBE_DEV_ID_82599_KX4:\n\tcase IXGBE_DEV_ID_82599_KX4_MEZZ:\n\tcase IXGBE_DEV_ID_X550EM_X_KX4:\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, supported, 10000baseKX4_Full);\n\t\tbreak;\n\tcase IXGBE_DEV_ID_82598_BX:\n\tcase IXGBE_DEV_ID_82599_KR:\n\tcase IXGBE_DEV_ID_X550EM_X_KR:\n\tcase IXGBE_DEV_ID_X550EM_X_XFI:\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, supported, 10000baseKR_Full);\n\t\tbreak;\n\tdefault:\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, supported, 10000baseKX4_Full);\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, supported, 10000baseKR_Full);\n\t\tbreak;\n\t}\n}\n\nstatic void ixgbe_set_advertising_10gtypes(struct ixgbe_hw *hw,\n\t\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tif (!ixgbe_isbackplane(hw->phy.media_type)) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\treturn;\n\t}\n\n\tswitch (hw->device_id) {\n\tcase IXGBE_DEV_ID_82598:\n\tcase IXGBE_DEV_ID_82599_KX4:\n\tcase IXGBE_DEV_ID_82599_KX4_MEZZ:\n\tcase IXGBE_DEV_ID_X550EM_X_KX4:\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, advertising, 10000baseKX4_Full);\n\t\tbreak;\n\tcase IXGBE_DEV_ID_82598_BX:\n\tcase IXGBE_DEV_ID_82599_KR:\n\tcase IXGBE_DEV_ID_X550EM_X_KR:\n\tcase IXGBE_DEV_ID_X550EM_X_XFI:\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, advertising, 10000baseKR_Full);\n\t\tbreak;\n\tdefault:\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, advertising, 10000baseKX4_Full);\n\t\tethtool_link_ksettings_add_link_mode\n\t\t\t(cmd, advertising, 10000baseKR_Full);\n\t\tbreak;\n\t}\n}\n\nstatic int ixgbe_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tixgbe_link_speed supported_link;\n\tbool autoneg = false;\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\n\thw->mac.ops.get_link_capabilities(hw, &supported_link, &autoneg);\n\n\t \n\tif (supported_link & IXGBE_LINK_SPEED_10GB_FULL) {\n\t\tixgbe_set_supported_10gtypes(hw, cmd);\n\t\tixgbe_set_advertising_10gtypes(hw, cmd);\n\t}\n\tif (supported_link & IXGBE_LINK_SPEED_5GB_FULL)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     5000baseT_Full);\n\n\tif (supported_link & IXGBE_LINK_SPEED_2_5GB_FULL)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     2500baseT_Full);\n\n\tif (supported_link & IXGBE_LINK_SPEED_1GB_FULL) {\n\t\tif (ixgbe_isbackplane(hw->phy.media_type)) {\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     1000baseKX_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     1000baseKX_Full);\n\t\t} else {\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\t}\n\t}\n\tif (supported_link & IXGBE_LINK_SPEED_100_FULL) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     100baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     100baseT_Full);\n\t}\n\tif (supported_link & IXGBE_LINK_SPEED_10_FULL) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     10baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     10baseT_Full);\n\t}\n\n\t \n\tif (hw->phy.autoneg_advertised) {\n\t\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10_FULL)\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     10baseT_Full);\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL)\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL)\n\t\t\tixgbe_set_advertising_10gtypes(hw, cmd);\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_1GB_FULL) {\n\t\t\tif (ethtool_link_ksettings_test_link_mode\n\t\t\t\t(cmd, supported, 1000baseKX_Full))\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(cmd, advertising, 1000baseKX_Full);\n\t\t\telse\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(cmd, advertising, 1000baseT_Full);\n\t\t}\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_5GB_FULL)\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     5000baseT_Full);\n\t\tif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_2_5GB_FULL)\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     2500baseT_Full);\n\t} else {\n\t\tif (hw->phy.multispeed_fiber && !autoneg) {\n\t\t\tif (supported_link & IXGBE_LINK_SPEED_10GB_FULL)\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(cmd, advertising, 10000baseT_Full);\n\t\t}\n\t}\n\n\tif (autoneg) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Autoneg);\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t} else\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\t \n\tswitch (adapter->hw.phy.type) {\n\tcase ixgbe_phy_tn:\n\tcase ixgbe_phy_aq:\n\tcase ixgbe_phy_x550em_ext_t:\n\tcase ixgbe_phy_fw:\n\tcase ixgbe_phy_cu_unknown:\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, TP);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, TP);\n\t\tcmd->base.port = PORT_TP;\n\t\tbreak;\n\tcase ixgbe_phy_qt:\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);\n\t\tcmd->base.port = PORT_FIBRE;\n\t\tbreak;\n\tcase ixgbe_phy_nl:\n\tcase ixgbe_phy_sfp_passive_tyco:\n\tcase ixgbe_phy_sfp_passive_unknown:\n\tcase ixgbe_phy_sfp_ftl:\n\tcase ixgbe_phy_sfp_avago:\n\tcase ixgbe_phy_sfp_intel:\n\tcase ixgbe_phy_sfp_unknown:\n\tcase ixgbe_phy_qsfp_passive_unknown:\n\tcase ixgbe_phy_qsfp_active_unknown:\n\tcase ixgbe_phy_qsfp_intel:\n\tcase ixgbe_phy_qsfp_unknown:\n\t\t \n\t\tswitch (adapter->hw.phy.sfp_type) {\n\t\tcase ixgbe_sfp_type_da_cu:\n\t\tcase ixgbe_sfp_type_da_cu_core0:\n\t\tcase ixgbe_sfp_type_da_cu_core1:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tcmd->base.port = PORT_DA;\n\t\t\tbreak;\n\t\tcase ixgbe_sfp_type_sr:\n\t\tcase ixgbe_sfp_type_lr:\n\t\tcase ixgbe_sfp_type_srlr_core0:\n\t\tcase ixgbe_sfp_type_srlr_core1:\n\t\tcase ixgbe_sfp_type_1g_sx_core0:\n\t\tcase ixgbe_sfp_type_1g_sx_core1:\n\t\tcase ixgbe_sfp_type_1g_lx_core0:\n\t\tcase ixgbe_sfp_type_1g_lx_core1:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tcmd->base.port = PORT_FIBRE;\n\t\t\tbreak;\n\t\tcase ixgbe_sfp_type_not_present:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tcmd->base.port = PORT_NONE;\n\t\t\tbreak;\n\t\tcase ixgbe_sfp_type_1g_cu_core0:\n\t\tcase ixgbe_sfp_type_1g_cu_core1:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     TP);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     TP);\n\t\t\tcmd->base.port = PORT_TP;\n\t\t\tbreak;\n\t\tcase ixgbe_sfp_type_unknown:\n\t\tdefault:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     FIBRE);\n\t\t\tcmd->base.port = PORT_OTHER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ixgbe_phy_xaui:\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     FIBRE);\n\t\tcmd->base.port = PORT_NONE;\n\t\tbreak;\n\tcase ixgbe_phy_unknown:\n\tcase ixgbe_phy_generic:\n\tcase ixgbe_phy_sfp_unsupported:\n\tdefault:\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     FIBRE);\n\t\tcmd->base.port = PORT_OTHER;\n\t\tbreak;\n\t}\n\n\t \n\tethtool_link_ksettings_add_link_mode(cmd, supported, Pause);\n\n\tswitch (hw->fc.requested_mode) {\n\tcase ixgbe_fc_full:\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Pause);\n\t\tbreak;\n\tcase ixgbe_fc_rx_pause:\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Pause);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tcase ixgbe_fc_tx_pause:\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t\tbreak;\n\tdefault:\n\t\tethtool_link_ksettings_del_link_mode(cmd, advertising, Pause);\n\t\tethtool_link_ksettings_del_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\t}\n\n\tif (netif_carrier_ok(netdev)) {\n\t\tswitch (adapter->link_speed) {\n\t\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\t\t\tcmd->base.speed = SPEED_10000;\n\t\t\tbreak;\n\t\tcase IXGBE_LINK_SPEED_5GB_FULL:\n\t\t\tcmd->base.speed = SPEED_5000;\n\t\t\tbreak;\n\t\tcase IXGBE_LINK_SPEED_2_5GB_FULL:\n\t\t\tcmd->base.speed = SPEED_2500;\n\t\t\tbreak;\n\t\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\t\tcmd->base.speed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase IXGBE_LINK_SPEED_100_FULL:\n\t\t\tcmd->base.speed = SPEED_100;\n\t\t\tbreak;\n\t\tcase IXGBE_LINK_SPEED_10_FULL:\n\t\t\tcmd->base.speed = SPEED_10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 advertised, old;\n\ts32 err = 0;\n\n\tif ((hw->phy.media_type == ixgbe_media_type_copper) ||\n\t    (hw->phy.multispeed_fiber)) {\n\t\t \n\t\tif (!linkmode_subset(cmd->link_modes.advertising,\n\t\t\t\t     cmd->link_modes.supported))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!cmd->base.autoneg && hw->phy.multispeed_fiber) {\n\t\t\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t\t  10000baseT_Full) &&\n\t\t\t    ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t\t  1000baseT_Full))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\told = hw->phy.autoneg_advertised;\n\t\tadvertised = 0;\n\t\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t  10000baseT_Full))\n\t\t\tadvertised |= IXGBE_LINK_SPEED_10GB_FULL;\n\t\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t  5000baseT_Full))\n\t\t\tadvertised |= IXGBE_LINK_SPEED_5GB_FULL;\n\t\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t  2500baseT_Full))\n\t\t\tadvertised |= IXGBE_LINK_SPEED_2_5GB_FULL;\n\t\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t  1000baseT_Full))\n\t\t\tadvertised |= IXGBE_LINK_SPEED_1GB_FULL;\n\n\t\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t  100baseT_Full))\n\t\t\tadvertised |= IXGBE_LINK_SPEED_100_FULL;\n\n\t\tif (ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t  10baseT_Full))\n\t\t\tadvertised |= IXGBE_LINK_SPEED_10_FULL;\n\n\t\tif (old == advertised)\n\t\t\treturn err;\n\t\t \n\t\twhile (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))\n\t\t\tusleep_range(1000, 2000);\n\n\t\thw->mac.autotry_restart = true;\n\t\terr = hw->mac.ops.setup_link(hw, advertised, true);\n\t\tif (err) {\n\t\t\te_info(probe, \"setup link failed with code %d\\n\", err);\n\t\t\thw->mac.ops.setup_link(hw, old, true);\n\t\t}\n\t\tclear_bit(__IXGBE_IN_SFP_INIT, &adapter->state);\n\t} else {\n\t\t \n\t\tu32 speed = cmd->base.speed;\n\n\t\tif ((cmd->base.autoneg == AUTONEG_ENABLE) ||\n\t\t    (!ethtool_link_ksettings_test_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t    10000baseT_Full)) ||\n\t\t    (speed + cmd->base.duplex != SPEED_10000 + DUPLEX_FULL))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void ixgbe_get_pause_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_pause_stats *stats)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw_stats *hwstats = &adapter->stats;\n\n\tstats->tx_pause_frames = hwstats->lxontxc + hwstats->lxofftxc;\n\tstats->rx_pause_frames = hwstats->lxonrxc + hwstats->lxoffrxc;\n}\n\nstatic void ixgbe_get_pauseparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\tif (ixgbe_device_supports_autoneg_fc(hw) &&\n\t    !hw->fc.disable_fc_autoneg)\n\t\tpause->autoneg = 1;\n\telse\n\t\tpause->autoneg = 0;\n\n\tif (hw->fc.current_mode == ixgbe_fc_rx_pause) {\n\t\tpause->rx_pause = 1;\n\t} else if (hw->fc.current_mode == ixgbe_fc_tx_pause) {\n\t\tpause->tx_pause = 1;\n\t} else if (hw->fc.current_mode == ixgbe_fc_full) {\n\t\tpause->rx_pause = 1;\n\t\tpause->tx_pause = 1;\n\t}\n}\n\nstatic int ixgbe_set_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct ixgbe_fc_info fc = hw->fc;\n\n\t \n\tif ((hw->mac.type == ixgbe_mac_82598EB) &&\n\t    (adapter->flags & IXGBE_FLAG_DCB_ENABLED))\n\t\treturn -EINVAL;\n\n\t \n\tif ((pause->autoneg == AUTONEG_ENABLE) &&\n\t    !ixgbe_device_supports_autoneg_fc(hw))\n\t\treturn -EINVAL;\n\n\tfc.disable_fc_autoneg = (pause->autoneg != AUTONEG_ENABLE);\n\n\tif ((pause->rx_pause && pause->tx_pause) || pause->autoneg)\n\t\tfc.requested_mode = ixgbe_fc_full;\n\telse if (pause->rx_pause && !pause->tx_pause)\n\t\tfc.requested_mode = ixgbe_fc_rx_pause;\n\telse if (!pause->rx_pause && pause->tx_pause)\n\t\tfc.requested_mode = ixgbe_fc_tx_pause;\n\telse\n\t\tfc.requested_mode = ixgbe_fc_none;\n\n\t \n\tif (memcmp(&fc, &hw->fc, sizeof(struct ixgbe_fc_info))) {\n\t\thw->fc = fc;\n\t\tif (netif_running(netdev))\n\t\t\tixgbe_reinit_locked(adapter);\n\t\telse\n\t\t\tixgbe_reset(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 ixgbe_get_msglevel(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\treturn adapter->msg_enable;\n}\n\nstatic void ixgbe_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tadapter->msg_enable = data;\n}\n\nstatic int ixgbe_get_regs_len(struct net_device *netdev)\n{\n#define IXGBE_REGS_LEN  1145\n\treturn IXGBE_REGS_LEN * sizeof(u32);\n}\n\n#define IXGBE_GET_STAT(_A_, _R_) _A_->stats._R_\n\nstatic void ixgbe_get_regs(struct net_device *netdev,\n\t\t\t   struct ethtool_regs *regs, void *p)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu8 i;\n\n\tmemset(p, 0, IXGBE_REGS_LEN * sizeof(u32));\n\n\tregs->version = hw->mac.type << 24 | hw->revision_id << 16 |\n\t\t\thw->device_id;\n\n\t \n\tregs_buff[0] = IXGBE_READ_REG(hw, IXGBE_CTRL);\n\tregs_buff[1] = IXGBE_READ_REG(hw, IXGBE_STATUS);\n\tregs_buff[2] = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);\n\tregs_buff[3] = IXGBE_READ_REG(hw, IXGBE_ESDP);\n\tregs_buff[4] = IXGBE_READ_REG(hw, IXGBE_EODSDP);\n\tregs_buff[5] = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\tregs_buff[6] = IXGBE_READ_REG(hw, IXGBE_FRTIMER);\n\tregs_buff[7] = IXGBE_READ_REG(hw, IXGBE_TCPTIMER);\n\n\t \n\tregs_buff[8] = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\tregs_buff[9] = IXGBE_READ_REG(hw, IXGBE_EERD);\n\tregs_buff[10] = IXGBE_READ_REG(hw, IXGBE_FLA(hw));\n\tregs_buff[11] = IXGBE_READ_REG(hw, IXGBE_EEMNGCTL);\n\tregs_buff[12] = IXGBE_READ_REG(hw, IXGBE_EEMNGDATA);\n\tregs_buff[13] = IXGBE_READ_REG(hw, IXGBE_FLMNGCTL);\n\tregs_buff[14] = IXGBE_READ_REG(hw, IXGBE_FLMNGDATA);\n\tregs_buff[15] = IXGBE_READ_REG(hw, IXGBE_FLMNGCNT);\n\tregs_buff[16] = IXGBE_READ_REG(hw, IXGBE_FLOP);\n\tregs_buff[17] = IXGBE_READ_REG(hw, IXGBE_GRC(hw));\n\n\t \n\t \n\tregs_buff[18] = IXGBE_READ_REG(hw, IXGBE_EICS);\n\tregs_buff[19] = IXGBE_READ_REG(hw, IXGBE_EICS);\n\tregs_buff[20] = IXGBE_READ_REG(hw, IXGBE_EIMS);\n\tregs_buff[21] = IXGBE_READ_REG(hw, IXGBE_EIMC);\n\tregs_buff[22] = IXGBE_READ_REG(hw, IXGBE_EIAC);\n\tregs_buff[23] = IXGBE_READ_REG(hw, IXGBE_EIAM);\n\tregs_buff[24] = IXGBE_READ_REG(hw, IXGBE_EITR(0));\n\tregs_buff[25] = IXGBE_READ_REG(hw, IXGBE_IVAR(0));\n\tregs_buff[26] = IXGBE_READ_REG(hw, IXGBE_MSIXT);\n\tregs_buff[27] = IXGBE_READ_REG(hw, IXGBE_MSIXPBA);\n\tregs_buff[28] = IXGBE_READ_REG(hw, IXGBE_PBACL(0));\n\tregs_buff[29] = IXGBE_READ_REG(hw, IXGBE_GPIE);\n\n\t \n\tregs_buff[30] = IXGBE_READ_REG(hw, IXGBE_PFCTOP);\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[31 + i] = IXGBE_READ_REG(hw, IXGBE_FCTTV(i));\n\tfor (i = 0; i < 8; i++) {\n\t\tswitch (hw->mac.type) {\n\t\tcase ixgbe_mac_82598EB:\n\t\t\tregs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL(i));\n\t\t\tregs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH(i));\n\t\t\tbreak;\n\t\tcase ixgbe_mac_82599EB:\n\t\tcase ixgbe_mac_X540:\n\t\tcase ixgbe_mac_X550:\n\t\tcase ixgbe_mac_X550EM_x:\n\t\tcase ixgbe_mac_x550em_a:\n\t\t\tregs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL_82599(i));\n\t\t\tregs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH_82599(i));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tregs_buff[51] = IXGBE_READ_REG(hw, IXGBE_FCRTV);\n\tregs_buff[52] = IXGBE_READ_REG(hw, IXGBE_TFCS);\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\tregs_buff[53 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAL(i));\n\tfor (i = 0; i < 64; i++)\n\t\tregs_buff[117 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAH(i));\n\tfor (i = 0; i < 64; i++)\n\t\tregs_buff[181 + i] = IXGBE_READ_REG(hw, IXGBE_RDLEN(i));\n\tfor (i = 0; i < 64; i++)\n\t\tregs_buff[245 + i] = IXGBE_READ_REG(hw, IXGBE_RDH(i));\n\tfor (i = 0; i < 64; i++)\n\t\tregs_buff[309 + i] = IXGBE_READ_REG(hw, IXGBE_RDT(i));\n\tfor (i = 0; i < 64; i++)\n\t\tregs_buff[373 + i] = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[437 + i] = IXGBE_READ_REG(hw, IXGBE_SRRCTL(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[453 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));\n\tregs_buff[469] = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[470 + i] = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i));\n\tregs_buff[478] = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\n\tregs_buff[479] = IXGBE_READ_REG(hw, IXGBE_DROPEN);\n\n\t \n\tregs_buff[480] = IXGBE_READ_REG(hw, IXGBE_RXCSUM);\n\tregs_buff[481] = IXGBE_READ_REG(hw, IXGBE_RFCTL);\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[482 + i] = IXGBE_READ_REG(hw, IXGBE_RAL(i));\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[498 + i] = IXGBE_READ_REG(hw, IXGBE_RAH(i));\n\tregs_buff[514] = IXGBE_READ_REG(hw, IXGBE_PSRTYPE(0));\n\tregs_buff[515] = IXGBE_READ_REG(hw, IXGBE_FCTRL);\n\tregs_buff[516] = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);\n\tregs_buff[517] = IXGBE_READ_REG(hw, IXGBE_MCSTCTRL);\n\tregs_buff[518] = IXGBE_READ_REG(hw, IXGBE_MRQC);\n\tregs_buff[519] = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[520 + i] = IXGBE_READ_REG(hw, IXGBE_IMIR(i));\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[528 + i] = IXGBE_READ_REG(hw, IXGBE_IMIREXT(i));\n\tregs_buff[536] = IXGBE_READ_REG(hw, IXGBE_IMIRVP);\n\n\t \n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[537 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAL(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[569 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAH(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[601 + i] = IXGBE_READ_REG(hw, IXGBE_TDLEN(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[633 + i] = IXGBE_READ_REG(hw, IXGBE_TDH(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[665 + i] = IXGBE_READ_REG(hw, IXGBE_TDT(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[697 + i] = IXGBE_READ_REG(hw, IXGBE_TXDCTL(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[729 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAL(i));\n\tfor (i = 0; i < 32; i++)\n\t\tregs_buff[761 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAH(i));\n\tregs_buff[793] = IXGBE_READ_REG(hw, IXGBE_DTXCTL);\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[794 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));\n\tregs_buff[810] = IXGBE_READ_REG(hw, IXGBE_TIPG);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[811 + i] = IXGBE_READ_REG(hw, IXGBE_TXPBSIZE(i));\n\tregs_buff[819] = IXGBE_READ_REG(hw, IXGBE_MNGTXMAP);\n\n\t \n\tregs_buff[820] = IXGBE_READ_REG(hw, IXGBE_WUC);\n\tregs_buff[821] = IXGBE_READ_REG(hw, IXGBE_WUFC);\n\tregs_buff[822] = IXGBE_READ_REG(hw, IXGBE_WUS);\n\tregs_buff[823] = IXGBE_READ_REG(hw, IXGBE_IPAV);\n\tregs_buff[824] = IXGBE_READ_REG(hw, IXGBE_IP4AT);\n\tregs_buff[825] = IXGBE_READ_REG(hw, IXGBE_IP6AT);\n\tregs_buff[826] = IXGBE_READ_REG(hw, IXGBE_WUPL);\n\tregs_buff[827] = IXGBE_READ_REG(hw, IXGBE_WUPM);\n\tregs_buff[828] = IXGBE_READ_REG(hw, IXGBE_FHFT(0));\n\n\t \n\tregs_buff[829] = IXGBE_READ_REG(hw, IXGBE_RMCS);    \n\tregs_buff[831] = IXGBE_READ_REG(hw, IXGBE_PDPMCS);  \n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_82598EB:\n\t\tregs_buff[830] = IXGBE_READ_REG(hw, IXGBE_DPMCS);\n\t\tregs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RUPPBMR);\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[833 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_RT2CR(i));\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[841 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_RT2SR(i));\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[849 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_TDTQ2TCCR(i));\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[857 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_TDTQ2TCSR(i));\n\t\tbreak;\n\tcase ixgbe_mac_82599EB:\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\tregs_buff[830] = IXGBE_READ_REG(hw, IXGBE_RTTDCS);\n\t\tregs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RTRPCS);\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[833 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_RTRPT4C(i));\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[841 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_RTRPT4S(i));\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[849 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_RTTDT2C(i));\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregs_buff[857 + i] =\n\t\t\t\tIXGBE_READ_REG(hw, IXGBE_RTTDT2S(i));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[865 + i] =\n\t\tIXGBE_READ_REG(hw, IXGBE_TDPT2TCCR(i));  \n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[873 + i] =\n\t\tIXGBE_READ_REG(hw, IXGBE_TDPT2TCSR(i));  \n\n\t \n\tregs_buff[881] = IXGBE_GET_STAT(adapter, crcerrs);\n\tregs_buff[882] = IXGBE_GET_STAT(adapter, illerrc);\n\tregs_buff[883] = IXGBE_GET_STAT(adapter, errbc);\n\tregs_buff[884] = IXGBE_GET_STAT(adapter, mspdc);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[885 + i] = IXGBE_GET_STAT(adapter, mpc[i]);\n\tregs_buff[893] = IXGBE_GET_STAT(adapter, mlfc);\n\tregs_buff[894] = IXGBE_GET_STAT(adapter, mrfc);\n\tregs_buff[895] = IXGBE_GET_STAT(adapter, rlec);\n\tregs_buff[896] = IXGBE_GET_STAT(adapter, lxontxc);\n\tregs_buff[897] = IXGBE_GET_STAT(adapter, lxonrxc);\n\tregs_buff[898] = IXGBE_GET_STAT(adapter, lxofftxc);\n\tregs_buff[899] = IXGBE_GET_STAT(adapter, lxoffrxc);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[900 + i] = IXGBE_GET_STAT(adapter, pxontxc[i]);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[908 + i] = IXGBE_GET_STAT(adapter, pxonrxc[i]);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[916 + i] = IXGBE_GET_STAT(adapter, pxofftxc[i]);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[924 + i] = IXGBE_GET_STAT(adapter, pxoffrxc[i]);\n\tregs_buff[932] = IXGBE_GET_STAT(adapter, prc64);\n\tregs_buff[933] = IXGBE_GET_STAT(adapter, prc127);\n\tregs_buff[934] = IXGBE_GET_STAT(adapter, prc255);\n\tregs_buff[935] = IXGBE_GET_STAT(adapter, prc511);\n\tregs_buff[936] = IXGBE_GET_STAT(adapter, prc1023);\n\tregs_buff[937] = IXGBE_GET_STAT(adapter, prc1522);\n\tregs_buff[938] = IXGBE_GET_STAT(adapter, gprc);\n\tregs_buff[939] = IXGBE_GET_STAT(adapter, bprc);\n\tregs_buff[940] = IXGBE_GET_STAT(adapter, mprc);\n\tregs_buff[941] = IXGBE_GET_STAT(adapter, gptc);\n\tregs_buff[942] = (u32)IXGBE_GET_STAT(adapter, gorc);\n\tregs_buff[943] = (u32)(IXGBE_GET_STAT(adapter, gorc) >> 32);\n\tregs_buff[944] = (u32)IXGBE_GET_STAT(adapter, gotc);\n\tregs_buff[945] = (u32)(IXGBE_GET_STAT(adapter, gotc) >> 32);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[946 + i] = IXGBE_GET_STAT(adapter, rnbc[i]);\n\tregs_buff[954] = IXGBE_GET_STAT(adapter, ruc);\n\tregs_buff[955] = IXGBE_GET_STAT(adapter, rfc);\n\tregs_buff[956] = IXGBE_GET_STAT(adapter, roc);\n\tregs_buff[957] = IXGBE_GET_STAT(adapter, rjc);\n\tregs_buff[958] = IXGBE_GET_STAT(adapter, mngprc);\n\tregs_buff[959] = IXGBE_GET_STAT(adapter, mngpdc);\n\tregs_buff[960] = IXGBE_GET_STAT(adapter, mngptc);\n\tregs_buff[961] = (u32)IXGBE_GET_STAT(adapter, tor);\n\tregs_buff[962] = (u32)(IXGBE_GET_STAT(adapter, tor) >> 32);\n\tregs_buff[963] = IXGBE_GET_STAT(adapter, tpr);\n\tregs_buff[964] = IXGBE_GET_STAT(adapter, tpt);\n\tregs_buff[965] = IXGBE_GET_STAT(adapter, ptc64);\n\tregs_buff[966] = IXGBE_GET_STAT(adapter, ptc127);\n\tregs_buff[967] = IXGBE_GET_STAT(adapter, ptc255);\n\tregs_buff[968] = IXGBE_GET_STAT(adapter, ptc511);\n\tregs_buff[969] = IXGBE_GET_STAT(adapter, ptc1023);\n\tregs_buff[970] = IXGBE_GET_STAT(adapter, ptc1522);\n\tregs_buff[971] = IXGBE_GET_STAT(adapter, mptc);\n\tregs_buff[972] = IXGBE_GET_STAT(adapter, bptc);\n\tregs_buff[973] = IXGBE_GET_STAT(adapter, xec);\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[974 + i] = IXGBE_GET_STAT(adapter, qprc[i]);\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[990 + i] = IXGBE_GET_STAT(adapter, qptc[i]);\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[1006 + i] = IXGBE_GET_STAT(adapter, qbrc[i]);\n\tfor (i = 0; i < 16; i++)\n\t\tregs_buff[1022 + i] = IXGBE_GET_STAT(adapter, qbtc[i]);\n\n\t \n\tregs_buff[1038] = IXGBE_READ_REG(hw, IXGBE_PCS1GCFIG);\n\tregs_buff[1039] = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);\n\tregs_buff[1040] = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);\n\tregs_buff[1041] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG0);\n\tregs_buff[1042] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG1);\n\tregs_buff[1043] = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);\n\tregs_buff[1044] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);\n\tregs_buff[1045] = IXGBE_READ_REG(hw, IXGBE_PCS1GANNP);\n\tregs_buff[1046] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLPNP);\n\tregs_buff[1047] = IXGBE_READ_REG(hw, IXGBE_HLREG0);\n\tregs_buff[1048] = IXGBE_READ_REG(hw, IXGBE_HLREG1);\n\tregs_buff[1049] = IXGBE_READ_REG(hw, IXGBE_PAP);\n\tregs_buff[1050] = IXGBE_READ_REG(hw, IXGBE_MACA);\n\tregs_buff[1051] = IXGBE_READ_REG(hw, IXGBE_APAE);\n\tregs_buff[1052] = IXGBE_READ_REG(hw, IXGBE_ARD);\n\tregs_buff[1053] = IXGBE_READ_REG(hw, IXGBE_AIS);\n\tregs_buff[1054] = IXGBE_READ_REG(hw, IXGBE_MSCA);\n\tregs_buff[1055] = IXGBE_READ_REG(hw, IXGBE_MSRWD);\n\tregs_buff[1056] = IXGBE_READ_REG(hw, IXGBE_MLADD);\n\tregs_buff[1057] = IXGBE_READ_REG(hw, IXGBE_MHADD);\n\tregs_buff[1058] = IXGBE_READ_REG(hw, IXGBE_TREG);\n\tregs_buff[1059] = IXGBE_READ_REG(hw, IXGBE_PCSS1);\n\tregs_buff[1060] = IXGBE_READ_REG(hw, IXGBE_PCSS2);\n\tregs_buff[1061] = IXGBE_READ_REG(hw, IXGBE_XPCSS);\n\tregs_buff[1062] = IXGBE_READ_REG(hw, IXGBE_SERDESC);\n\tregs_buff[1063] = IXGBE_READ_REG(hw, IXGBE_MACS);\n\tregs_buff[1064] = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tregs_buff[1065] = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\tregs_buff[1066] = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\n\tregs_buff[1067] = IXGBE_READ_REG(hw, IXGBE_AUTOC3);\n\tregs_buff[1068] = IXGBE_READ_REG(hw, IXGBE_ANLP1);\n\tregs_buff[1069] = IXGBE_READ_REG(hw, IXGBE_ANLP2);\n\tregs_buff[1070] = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);\n\n\t \n\tregs_buff[1071] = IXGBE_READ_REG(hw, IXGBE_RDSTATCTL);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[1072 + i] = IXGBE_READ_REG(hw, IXGBE_RDSTAT(i));\n\tregs_buff[1080] = IXGBE_READ_REG(hw, IXGBE_RDHMPN);\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[1081 + i] = IXGBE_READ_REG(hw, IXGBE_RIC_DW(i));\n\tregs_buff[1085] = IXGBE_READ_REG(hw, IXGBE_RDPROBE);\n\tregs_buff[1086] = IXGBE_READ_REG(hw, IXGBE_TDSTATCTL);\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[1087 + i] = IXGBE_READ_REG(hw, IXGBE_TDSTAT(i));\n\tregs_buff[1095] = IXGBE_READ_REG(hw, IXGBE_TDHMPN);\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[1096 + i] = IXGBE_READ_REG(hw, IXGBE_TIC_DW(i));\n\tregs_buff[1100] = IXGBE_READ_REG(hw, IXGBE_TDPROBE);\n\tregs_buff[1101] = IXGBE_READ_REG(hw, IXGBE_TXBUFCTRL);\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[1102 + i] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA(i));\n\tregs_buff[1106] = IXGBE_READ_REG(hw, IXGBE_RXBUFCTRL);\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[1107 + i] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA(i));\n\tfor (i = 0; i < 8; i++)\n\t\tregs_buff[1111 + i] = IXGBE_READ_REG(hw, IXGBE_PCIE_DIAG(i));\n\tregs_buff[1119] = IXGBE_READ_REG(hw, IXGBE_RFVAL);\n\tregs_buff[1120] = IXGBE_READ_REG(hw, IXGBE_MDFTC1);\n\tregs_buff[1121] = IXGBE_READ_REG(hw, IXGBE_MDFTC2);\n\tregs_buff[1122] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO1);\n\tregs_buff[1123] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO2);\n\tregs_buff[1124] = IXGBE_READ_REG(hw, IXGBE_MDFTS);\n\tregs_buff[1125] = IXGBE_READ_REG(hw, IXGBE_PCIEECCCTL);\n\tregs_buff[1126] = IXGBE_READ_REG(hw, IXGBE_PBTXECC);\n\tregs_buff[1127] = IXGBE_READ_REG(hw, IXGBE_PBRXECC);\n\n\t \n\tregs_buff[1128] = IXGBE_READ_REG(hw, IXGBE_MFLCN);\n\n\t \n\tregs_buff[1129] = IXGBE_READ_REG(hw, IXGBE_RTRUP2TC);\n\tregs_buff[1130] = IXGBE_READ_REG(hw, IXGBE_RTTUP2TC);\n\tfor (i = 0; i < 4; i++)\n\t\tregs_buff[1131 + i] = IXGBE_READ_REG(hw, IXGBE_TXLLQ(i));\n\tregs_buff[1135] = IXGBE_READ_REG(hw, IXGBE_RTTBCNRM);\n\t\t\t\t\t \n\tregs_buff[1136] = IXGBE_READ_REG(hw, IXGBE_RTTBCNRD);\n\t\t\t\t\t \n\n\t \n\tregs_buff[1137] = IXGBE_READ_REG(hw, IXGBE_RTTQCNCR);\n\tregs_buff[1138] = IXGBE_READ_REG(hw, IXGBE_RTTQCNTG);\n\n\t \n\tregs_buff[1139] = IXGBE_READ_REG(hw, IXGBE_SECTXCTRL);\n\tregs_buff[1140] = IXGBE_READ_REG(hw, IXGBE_SECTXSTAT);\n\tregs_buff[1141] = IXGBE_READ_REG(hw, IXGBE_SECTXBUFFAF);\n\tregs_buff[1142] = IXGBE_READ_REG(hw, IXGBE_SECTXMINIFG);\n\tregs_buff[1143] = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);\n\tregs_buff[1144] = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT);\n}\n\nstatic int ixgbe_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\treturn adapter->hw.eeprom.word_size * 2;\n}\n\nstatic int ixgbe_get_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tint first_word, last_word, eeprom_len;\n\tint ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_len = last_word - first_word + 1;\n\n\teeprom_buff = kmalloc_array(eeprom_len, sizeof(u16), GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tret_val = hw->eeprom.ops.read_buffer(hw, first_word, eeprom_len,\n\t\t\t\t\t     eeprom_buff);\n\n\t \n\tfor (i = 0; i < eeprom_len; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n}\n\nstatic int ixgbe_set_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tvoid *ptr;\n\tint max_len, first_word, last_word, ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\tif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\n\t\treturn -EINVAL;\n\n\tmax_len = hw->eeprom.word_size * 2;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_buff = kmalloc(max_len, GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tptr = eeprom_buff;\n\n\tif (eeprom->offset & 1) {\n\t\t \n\t\tret_val = hw->eeprom.ops.read(hw, first_word, &eeprom_buff[0]);\n\t\tif (ret_val)\n\t\t\tgoto err;\n\n\t\tptr++;\n\t}\n\tif ((eeprom->offset + eeprom->len) & 1) {\n\t\t \n\t\tret_val = hw->eeprom.ops.read(hw, last_word,\n\t\t\t\t\t  &eeprom_buff[last_word - first_word]);\n\t\tif (ret_val)\n\t\t\tgoto err;\n\t}\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(ptr, bytes, eeprom->len);\n\n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tcpu_to_le16s(&eeprom_buff[i]);\n\n\tret_val = hw->eeprom.ops.write_buffer(hw, first_word,\n\t\t\t\t\t      last_word - first_word + 1,\n\t\t\t\t\t      eeprom_buff);\n\n\t \n\tif (ret_val == 0)\n\t\thw->eeprom.ops.update_checksum(hw);\n\nerr:\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic void ixgbe_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver, ixgbe_driver_name, sizeof(drvinfo->driver));\n\n\tstrscpy(drvinfo->fw_version, adapter->eeprom_id,\n\t\tsizeof(drvinfo->fw_version));\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\n\tdrvinfo->n_priv_flags = IXGBE_PRIV_FLAGS_STR_LEN;\n}\n\nstatic u32 ixgbe_get_max_rxd(struct ixgbe_adapter *adapter)\n{\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_82598EB:\n\t\treturn IXGBE_MAX_RXD_82598;\n\tcase ixgbe_mac_82599EB:\n\t\treturn IXGBE_MAX_RXD_82599;\n\tcase ixgbe_mac_X540:\n\t\treturn IXGBE_MAX_RXD_X540;\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\treturn IXGBE_MAX_RXD_X550;\n\tdefault:\n\t\treturn IXGBE_MAX_RXD_82598;\n\t}\n}\n\nstatic u32 ixgbe_get_max_txd(struct ixgbe_adapter *adapter)\n{\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_82598EB:\n\t\treturn IXGBE_MAX_TXD_82598;\n\tcase ixgbe_mac_82599EB:\n\t\treturn IXGBE_MAX_TXD_82599;\n\tcase ixgbe_mac_X540:\n\t\treturn IXGBE_MAX_TXD_X540;\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\treturn IXGBE_MAX_TXD_X550;\n\tdefault:\n\t\treturn IXGBE_MAX_TXD_82598;\n\t}\n}\n\nstatic void ixgbe_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_ring *tx_ring = adapter->tx_ring[0];\n\tstruct ixgbe_ring *rx_ring = adapter->rx_ring[0];\n\n\tring->rx_max_pending = ixgbe_get_max_rxd(adapter);\n\tring->tx_max_pending = ixgbe_get_max_txd(adapter);\n\tring->rx_pending = rx_ring->count;\n\tring->tx_pending = tx_ring->count;\n}\n\nstatic int ixgbe_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_ring *temp_ring;\n\tint i, j, err = 0;\n\tu32 new_rx_count, new_tx_count;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tnew_tx_count = clamp_t(u32, ring->tx_pending,\n\t\t\t       IXGBE_MIN_TXD, ixgbe_get_max_txd(adapter));\n\tnew_tx_count = ALIGN(new_tx_count, IXGBE_REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tnew_rx_count = clamp_t(u32, ring->rx_pending,\n\t\t\t       IXGBE_MIN_RXD, ixgbe_get_max_rxd(adapter));\n\tnew_rx_count = ALIGN(new_rx_count, IXGBE_REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\tif ((new_tx_count == adapter->tx_ring_count) &&\n\t    (new_rx_count == adapter->rx_ring_count)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\twhile (test_and_set_bit(__IXGBE_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(adapter->netdev)) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\tadapter->tx_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < adapter->num_xdp_queues; i++)\n\t\t\tadapter->xdp_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\tadapter->rx_ring[i]->count = new_rx_count;\n\t\tadapter->tx_ring_count = new_tx_count;\n\t\tadapter->xdp_ring_count = new_tx_count;\n\t\tadapter->rx_ring_count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\t \n\ti = max_t(int, adapter->num_tx_queues + adapter->num_xdp_queues,\n\t\t  adapter->num_rx_queues);\n\ttemp_ring = vmalloc(array_size(i, sizeof(struct ixgbe_ring)));\n\n\tif (!temp_ring) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_reset;\n\t}\n\n\tixgbe_down(adapter);\n\n\t \n\tif (new_tx_count != adapter->tx_ring_count) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->tx_ring[i],\n\t\t\t       sizeof(struct ixgbe_ring));\n\n\t\t\ttemp_ring[i].count = new_tx_count;\n\t\t\terr = ixgbe_setup_tx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tixgbe_free_tx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < adapter->num_xdp_queues; j++, i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->xdp_ring[j],\n\t\t\t       sizeof(struct ixgbe_ring));\n\n\t\t\ttemp_ring[i].count = new_tx_count;\n\t\t\terr = ixgbe_setup_tx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tixgbe_free_tx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tixgbe_free_tx_resources(adapter->tx_ring[i]);\n\n\t\t\tmemcpy(adapter->tx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct ixgbe_ring));\n\t\t}\n\t\tfor (j = 0; j < adapter->num_xdp_queues; j++, i++) {\n\t\t\tixgbe_free_tx_resources(adapter->xdp_ring[j]);\n\n\t\t\tmemcpy(adapter->xdp_ring[j], &temp_ring[i],\n\t\t\t       sizeof(struct ixgbe_ring));\n\t\t}\n\n\t\tadapter->tx_ring_count = new_tx_count;\n\t}\n\n\t \n\tif (new_rx_count != adapter->rx_ring_count) {\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->rx_ring[i],\n\t\t\t       sizeof(struct ixgbe_ring));\n\n\t\t\t \n\t\t\tmemset(&temp_ring[i].xdp_rxq, 0,\n\t\t\t       sizeof(temp_ring[i].xdp_rxq));\n\n\t\t\ttemp_ring[i].count = new_rx_count;\n\t\t\terr = ixgbe_setup_rx_resources(adapter, &temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tixgbe_free_rx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tixgbe_free_rx_resources(adapter->rx_ring[i]);\n\n\t\t\tmemcpy(adapter->rx_ring[i], &temp_ring[i],\n\t\t\t       sizeof(struct ixgbe_ring));\n\t\t}\n\n\t\tadapter->rx_ring_count = new_rx_count;\n\t}\n\nerr_setup:\n\tixgbe_up(adapter);\n\tvfree(temp_ring);\nclear_reset:\n\tclear_bit(__IXGBE_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic int ixgbe_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn IXGBE_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn IXGBE_STATS_LEN;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn IXGBE_PRIV_FLAGS_STR_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void ixgbe_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *net_stats;\n\tunsigned int start;\n\tstruct ixgbe_ring *ring;\n\tint i, j;\n\tchar *p = NULL;\n\n\tixgbe_update_stats(adapter);\n\tnet_stats = dev_get_stats(netdev, &temp);\n\tfor (i = 0; i < IXGBE_GLOBAL_STATS_LEN; i++) {\n\t\tswitch (ixgbe_gstrings_stats[i].type) {\n\t\tcase NETDEV_STATS:\n\t\t\tp = (char *) net_stats +\n\t\t\t\t\tixgbe_gstrings_stats[i].stat_offset;\n\t\t\tbreak;\n\t\tcase IXGBE_STATS:\n\t\t\tp = (char *) adapter +\n\t\t\t\t\tixgbe_gstrings_stats[i].stat_offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata[i] = (ixgbe_gstrings_stats[i].sizeof_stat ==\n\t\t\t   sizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\tfor (j = 0; j < netdev->num_tx_queues; j++) {\n\t\tring = adapter->tx_ring[j];\n\t\tif (!ring) {\n\t\t\tdata[i] = 0;\n\t\t\tdata[i+1] = 0;\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\t\tdata[i]   = ring->stats.packets;\n\t\t\tdata[i+1] = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n\t\ti += 2;\n\t}\n\tfor (j = 0; j < IXGBE_NUM_RX_QUEUES; j++) {\n\t\tring = adapter->rx_ring[j];\n\t\tif (!ring) {\n\t\t\tdata[i] = 0;\n\t\t\tdata[i+1] = 0;\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\t\tdata[i]   = ring->stats.packets;\n\t\t\tdata[i+1] = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n\t\ti += 2;\n\t}\n\n\tfor (j = 0; j < IXGBE_MAX_PACKET_BUFFERS; j++) {\n\t\tdata[i++] = adapter->stats.pxontxc[j];\n\t\tdata[i++] = adapter->stats.pxofftxc[j];\n\t}\n\tfor (j = 0; j < IXGBE_MAX_PACKET_BUFFERS; j++) {\n\t\tdata[i++] = adapter->stats.pxonrxc[j];\n\t\tdata[i++] = adapter->stats.pxoffrxc[j];\n\t}\n}\n\nstatic void ixgbe_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t      u8 *data)\n{\n\tunsigned int i;\n\tu8 *p = data;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tfor (i = 0; i < IXGBE_TEST_LEN; i++)\n\t\t\tethtool_sprintf(&p, ixgbe_gstrings_test[i]);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < IXGBE_GLOBAL_STATS_LEN; i++)\n\t\t\tethtool_sprintf(&p,\n\t\t\t\t\tixgbe_gstrings_stats[i].stat_string);\n\t\tfor (i = 0; i < netdev->num_tx_queues; i++) {\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"tx_queue_%u_bytes\", i);\n\t\t}\n\t\tfor (i = 0; i < IXGBE_NUM_RX_QUEUES; i++) {\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_packets\", i);\n\t\t\tethtool_sprintf(&p, \"rx_queue_%u_bytes\", i);\n\t\t}\n\t\tfor (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++) {\n\t\t\tethtool_sprintf(&p, \"tx_pb_%u_pxon\", i);\n\t\t\tethtool_sprintf(&p, \"tx_pb_%u_pxoff\", i);\n\t\t}\n\t\tfor (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++) {\n\t\t\tethtool_sprintf(&p, \"rx_pb_%u_pxon\", i);\n\t\t\tethtool_sprintf(&p, \"rx_pb_%u_pxoff\", i);\n\t\t}\n\t\t \n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(data, ixgbe_priv_flags_strings,\n\t\t       IXGBE_PRIV_FLAGS_STR_LEN * ETH_GSTRING_LEN);\n\t}\n}\n\nstatic int ixgbe_link_test(struct ixgbe_adapter *adapter, u64 *data)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tbool link_up;\n\tu32 link_speed = 0;\n\n\tif (ixgbe_removed(hw->hw_addr)) {\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\t*data = 0;\n\n\thw->mac.ops.check_link(hw, &link_speed, &link_up, true);\n\tif (link_up)\n\t\treturn *data;\n\telse\n\t\t*data = 1;\n\treturn *data;\n}\n\n \nstruct ixgbe_reg_test {\n\tu16 reg;\n\tu8  array_len;\n\tu8  test_type;\n\tu32 mask;\n\tu32 write;\n};\n\n \n\n#define PATTERN_TEST\t1\n#define SET_READ_TEST\t2\n#define WRITE_NO_TEST\t3\n#define TABLE32_TEST\t4\n#define TABLE64_TEST_LO\t5\n#define TABLE64_TEST_HI\t6\n\n \nstatic const struct ixgbe_reg_test reg_test_82599[] = {\n\t{ IXGBE_FCRTL_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },\n\t{ IXGBE_FCRTH_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },\n\t{ IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_VLNCTRL, 1, PATTERN_TEST, 0x00000000, 0x00000000 },\n\t{ IXGBE_RDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFF80 },\n\t{ IXGBE_RDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_RDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, IXGBE_RXDCTL_ENABLE },\n\t{ IXGBE_RDT(0), 4, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, 0 },\n\t{ IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },\n\t{ IXGBE_FCTTV(0), 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_TDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ IXGBE_TDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_TDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFF80 },\n\t{ IXGBE_RXCTRL, 1, SET_READ_TEST, 0x00000001, 0x00000001 },\n\t{ IXGBE_RAL(0), 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_RAL(0), 16, TABLE64_TEST_HI, 0x8001FFFF, 0x800CFFFF },\n\t{ IXGBE_MTA(0), 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ .reg = 0 }\n};\n\n \nstatic const struct ixgbe_reg_test reg_test_82598[] = {\n\t{ IXGBE_FCRTL(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },\n\t{ IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },\n\t{ IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_VLNCTRL, 1, PATTERN_TEST, 0x00000000, 0x00000000 },\n\t{ IXGBE_RDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ IXGBE_RDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_RDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t \n\t{ IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, IXGBE_RXDCTL_ENABLE },\n\t \n\t{ IXGBE_RDT(0), 4, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, 0 },\n\t{ IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },\n\t{ IXGBE_FCTTV(0), 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_TIPG, 1, PATTERN_TEST, 0x000000FF, 0x000000FF },\n\t{ IXGBE_TDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ IXGBE_TDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_TDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ IXGBE_RXCTRL, 1, SET_READ_TEST, 0x00000003, 0x00000003 },\n\t{ IXGBE_DTXCTL, 1, SET_READ_TEST, 0x00000005, 0x00000005 },\n\t{ IXGBE_RAL(0), 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_RAL(0), 16, TABLE64_TEST_HI, 0x800CFFFF, 0x800CFFFF },\n\t{ IXGBE_MTA(0), 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ .reg = 0 }\n};\n\nstatic bool reg_pattern_test(struct ixgbe_adapter *adapter, u64 *data, int reg,\n\t\t\t     u32 mask, u32 write)\n{\n\tu32 pat, val, before;\n\tstatic const u32 test_pattern[] = {\n\t\t0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};\n\n\tif (ixgbe_removed(adapter->hw.hw_addr)) {\n\t\t*data = 1;\n\t\treturn true;\n\t}\n\tfor (pat = 0; pat < ARRAY_SIZE(test_pattern); pat++) {\n\t\tbefore = ixgbe_read_reg(&adapter->hw, reg);\n\t\tixgbe_write_reg(&adapter->hw, reg, test_pattern[pat] & write);\n\t\tval = ixgbe_read_reg(&adapter->hw, reg);\n\t\tif (val != (test_pattern[pat] & write & mask)) {\n\t\t\te_err(drv, \"pattern test reg %04X failed: got 0x%08X expected 0x%08X\\n\",\n\t\t\t      reg, val, (test_pattern[pat] & write & mask));\n\t\t\t*data = reg;\n\t\t\tixgbe_write_reg(&adapter->hw, reg, before);\n\t\t\treturn true;\n\t\t}\n\t\tixgbe_write_reg(&adapter->hw, reg, before);\n\t}\n\treturn false;\n}\n\nstatic bool reg_set_and_check(struct ixgbe_adapter *adapter, u64 *data, int reg,\n\t\t\t      u32 mask, u32 write)\n{\n\tu32 val, before;\n\n\tif (ixgbe_removed(adapter->hw.hw_addr)) {\n\t\t*data = 1;\n\t\treturn true;\n\t}\n\tbefore = ixgbe_read_reg(&adapter->hw, reg);\n\tixgbe_write_reg(&adapter->hw, reg, write & mask);\n\tval = ixgbe_read_reg(&adapter->hw, reg);\n\tif ((write & mask) != (val & mask)) {\n\t\te_err(drv, \"set/check reg %04X test failed: got 0x%08X expected 0x%08X\\n\",\n\t\t      reg, (val & mask), (write & mask));\n\t\t*data = reg;\n\t\tixgbe_write_reg(&adapter->hw, reg, before);\n\t\treturn true;\n\t}\n\tixgbe_write_reg(&adapter->hw, reg, before);\n\treturn false;\n}\n\nstatic int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)\n{\n\tconst struct ixgbe_reg_test *test;\n\tu32 value, before, after;\n\tu32 i, toggle;\n\n\tif (ixgbe_removed(adapter->hw.hw_addr)) {\n\t\te_err(drv, \"Adapter removed - register test blocked\\n\");\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_82598EB:\n\t\ttoggle = 0x7FFFF3FF;\n\t\ttest = reg_test_82598;\n\t\tbreak;\n\tcase ixgbe_mac_82599EB:\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\ttoggle = 0x7FFFF30F;\n\t\ttest = reg_test_82599;\n\t\tbreak;\n\tdefault:\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tbefore = ixgbe_read_reg(&adapter->hw, IXGBE_STATUS);\n\tvalue = (ixgbe_read_reg(&adapter->hw, IXGBE_STATUS) & toggle);\n\tixgbe_write_reg(&adapter->hw, IXGBE_STATUS, toggle);\n\tafter = ixgbe_read_reg(&adapter->hw, IXGBE_STATUS) & toggle;\n\tif (value != after) {\n\t\te_err(drv, \"failed STATUS register test got: 0x%08X expected: 0x%08X\\n\",\n\t\t      after, value);\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\t \n\tixgbe_write_reg(&adapter->hw, IXGBE_STATUS, before);\n\n\t \n\twhile (test->reg) {\n\t\tfor (i = 0; i < test->array_len; i++) {\n\t\t\tbool b = false;\n\n\t\t\tswitch (test->test_type) {\n\t\t\tcase PATTERN_TEST:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 0x40),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase SET_READ_TEST:\n\t\t\t\tb = reg_set_and_check(adapter, data,\n\t\t\t\t\t\t      test->reg + (i * 0x40),\n\t\t\t\t\t\t      test->mask,\n\t\t\t\t\t\t      test->write);\n\t\t\t\tbreak;\n\t\t\tcase WRITE_NO_TEST:\n\t\t\t\tixgbe_write_reg(&adapter->hw,\n\t\t\t\t\t\ttest->reg + (i * 0x40),\n\t\t\t\t\t\ttest->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE32_TEST:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 4),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_LO:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 8),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_HI:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     (test->reg + 4) + (i * 8),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b)\n\t\t\t\treturn 1;\n\t\t}\n\t\ttest++;\n\t}\n\n\t*data = 0;\n\treturn 0;\n}\n\nstatic int ixgbe_eeprom_test(struct ixgbe_adapter *adapter, u64 *data)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tif (hw->eeprom.ops.validate_checksum(hw, NULL))\n\t\t*data = 1;\n\telse\n\t\t*data = 0;\n\treturn *data;\n}\n\nstatic irqreturn_t ixgbe_test_intr(int irq, void *data)\n{\n\tstruct net_device *netdev = (struct net_device *) data;\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->test_icr |= IXGBE_READ_REG(&adapter->hw, IXGBE_EICR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ixgbe_intr_test(struct ixgbe_adapter *adapter, u64 *data)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 mask, i = 0, shared_int = true;\n\tu32 irq = adapter->pdev->irq;\n\n\t*data = 0;\n\n\t \n\tif (adapter->msix_entries) {\n\t\t \n\t\treturn 0;\n\t} else if (adapter->flags & IXGBE_FLAG_MSI_ENABLED) {\n\t\tshared_int = false;\n\t\tif (request_irq(irq, ixgbe_test_intr, 0, netdev->name,\n\t\t\t\tnetdev)) {\n\t\t\t*data = 1;\n\t\t\treturn -1;\n\t\t}\n\t} else if (!request_irq(irq, ixgbe_test_intr, IRQF_PROBE_SHARED,\n\t\t\t\tnetdev->name, netdev)) {\n\t\tshared_int = false;\n\t} else if (request_irq(irq, ixgbe_test_intr, IRQF_SHARED,\n\t\t\t       netdev->name, netdev)) {\n\t\t*data = 1;\n\t\treturn -1;\n\t}\n\te_info(hw, \"testing %s interrupt\\n\", shared_int ?\n\t       \"shared\" : \"unshared\");\n\n\t \n\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC, 0xFFFFFFFF);\n\tIXGBE_WRITE_FLUSH(&adapter->hw);\n\tusleep_range(10000, 20000);\n\n\t \n\tfor (; i < 10; i++) {\n\t\t \n\t\tmask = BIT(i);\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\t\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC,\n\t\t\t\t\t~mask & 0x00007FFF);\n\t\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EICS,\n\t\t\t\t\t~mask & 0x00007FFF);\n\t\t\tIXGBE_WRITE_FLUSH(&adapter->hw);\n\t\t\tusleep_range(10000, 20000);\n\n\t\t\tif (adapter->test_icr & mask) {\n\t\t\t\t*data = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tadapter->test_icr = 0;\n\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMS, mask);\n\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EICS, mask);\n\t\tIXGBE_WRITE_FLUSH(&adapter->hw);\n\t\tusleep_range(10000, 20000);\n\n\t\tif (!(adapter->test_icr & mask)) {\n\t\t\t*data = 4;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\t\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC,\n\t\t\t\t\t~mask & 0x00007FFF);\n\t\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EICS,\n\t\t\t\t\t~mask & 0x00007FFF);\n\t\t\tIXGBE_WRITE_FLUSH(&adapter->hw);\n\t\t\tusleep_range(10000, 20000);\n\n\t\t\tif (adapter->test_icr) {\n\t\t\t\t*data = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC, 0xFFFFFFFF);\n\tIXGBE_WRITE_FLUSH(&adapter->hw);\n\tusleep_range(10000, 20000);\n\n\t \n\tfree_irq(irq, netdev);\n\n\treturn *data;\n}\n\nstatic void ixgbe_free_desc_rings(struct ixgbe_adapter *adapter)\n{\n\t \n\n\t \n\tixgbe_disable_rx(adapter);\n\n\t \n\tixgbe_disable_tx(adapter);\n\n\tixgbe_reset(adapter);\n\n\tixgbe_free_tx_resources(&adapter->test_tx_ring);\n\tixgbe_free_rx_resources(&adapter->test_rx_ring);\n}\n\nstatic int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_ring *tx_ring = &adapter->test_tx_ring;\n\tstruct ixgbe_ring *rx_ring = &adapter->test_rx_ring;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 rctl, reg_data;\n\tint ret_val;\n\tint err;\n\n\t \n\ttx_ring->count = IXGBE_DEFAULT_TXD;\n\ttx_ring->queue_index = 0;\n\ttx_ring->dev = &adapter->pdev->dev;\n\ttx_ring->netdev = adapter->netdev;\n\ttx_ring->reg_idx = adapter->tx_ring[0]->reg_idx;\n\n\terr = ixgbe_setup_tx_resources(tx_ring);\n\tif (err)\n\t\treturn 1;\n\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_82599EB:\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\treg_data = IXGBE_READ_REG(&adapter->hw, IXGBE_DMATXCTL);\n\t\treg_data |= IXGBE_DMATXCTL_TE;\n\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_DMATXCTL, reg_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tixgbe_configure_tx_ring(adapter, tx_ring);\n\n\t \n\trx_ring->count = IXGBE_DEFAULT_RXD;\n\trx_ring->queue_index = 0;\n\trx_ring->dev = &adapter->pdev->dev;\n\trx_ring->netdev = adapter->netdev;\n\trx_ring->reg_idx = adapter->rx_ring[0]->reg_idx;\n\n\terr = ixgbe_setup_rx_resources(adapter, rx_ring);\n\tif (err) {\n\t\tret_val = 4;\n\t\tgoto err_nomem;\n\t}\n\n\thw->mac.ops.disable_rx(hw);\n\n\tixgbe_configure_rx_ring(adapter, rx_ring);\n\n\trctl = IXGBE_READ_REG(&adapter->hw, IXGBE_RXCTRL);\n\trctl |= IXGBE_RXCTRL_DMBYPS;\n\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_RXCTRL, rctl);\n\n\thw->mac.ops.enable_rx(hw);\n\n\treturn 0;\n\nerr_nomem:\n\tixgbe_free_desc_rings(adapter);\n\treturn ret_val;\n}\n\nstatic int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 reg_data;\n\n\n\t \n\treg_data = IXGBE_READ_REG(hw, IXGBE_HLREG0);\n\treg_data |= IXGBE_HLREG0_LPBK;\n\tIXGBE_WRITE_REG(hw, IXGBE_HLREG0, reg_data);\n\n\treg_data = IXGBE_READ_REG(hw, IXGBE_FCTRL);\n\treg_data |= IXGBE_FCTRL_BAM | IXGBE_FCTRL_SBP | IXGBE_FCTRL_MPE;\n\tIXGBE_WRITE_REG(hw, IXGBE_FCTRL, reg_data);\n\n\t \n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\treg_data = IXGBE_READ_REG(hw, IXGBE_MACC);\n\t\treg_data |= IXGBE_MACC_FLU;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MACC, reg_data);\n\t\tbreak;\n\tdefault:\n\t\tif (hw->mac.orig_autoc) {\n\t\t\treg_data = hw->mac.orig_autoc | IXGBE_AUTOC_FLU;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_data);\n\t\t} else {\n\t\t\treturn 10;\n\t\t}\n\t}\n\tIXGBE_WRITE_FLUSH(hw);\n\tusleep_range(10000, 20000);\n\n\t \n\tif (hw->mac.type == ixgbe_mac_82598EB) {\n\t\tu8 atlas;\n\n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &atlas);\n\t\tatlas |= IXGBE_ATLAS_PDN_TX_REG_EN;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, atlas);\n\n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, &atlas);\n\t\tatlas |= IXGBE_ATLAS_PDN_TX_10G_QL_ALL;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, atlas);\n\n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, &atlas);\n\t\tatlas |= IXGBE_ATLAS_PDN_TX_1G_QL_ALL;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, atlas);\n\n\t\thw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, &atlas);\n\t\tatlas |= IXGBE_ATLAS_PDN_TX_AN_QL_ALL;\n\t\thw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, atlas);\n\t}\n\n\treturn 0;\n}\n\nstatic void ixgbe_loopback_cleanup(struct ixgbe_adapter *adapter)\n{\n\tu32 reg_data;\n\n\treg_data = IXGBE_READ_REG(&adapter->hw, IXGBE_HLREG0);\n\treg_data &= ~IXGBE_HLREG0_LPBK;\n\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_HLREG0, reg_data);\n}\n\nstatic void ixgbe_create_lbtest_frame(struct sk_buff *skb,\n\t\t\t\t      unsigned int frame_size)\n{\n\tmemset(skb->data, 0xFF, frame_size);\n\tframe_size >>= 1;\n\tmemset(&skb->data[frame_size], 0xAA, frame_size / 2 - 1);\n\tskb->data[frame_size + 10] = 0xBE;\n\tskb->data[frame_size + 12] = 0xAF;\n}\n\nstatic bool ixgbe_check_lbtest_frame(struct ixgbe_rx_buffer *rx_buffer,\n\t\t\t\t     unsigned int frame_size)\n{\n\tunsigned char *data;\n\n\tframe_size >>= 1;\n\n\tdata = page_address(rx_buffer->page) + rx_buffer->page_offset;\n\n\treturn data[3] == 0xFF && data[frame_size + 10] == 0xBE &&\n\t\tdata[frame_size + 12] == 0xAF;\n}\n\nstatic u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring,\n\t\t\t\t  struct ixgbe_ring *tx_ring,\n\t\t\t\t  unsigned int size)\n{\n\tunion ixgbe_adv_rx_desc *rx_desc;\n\tu16 rx_ntc, tx_ntc, count = 0;\n\n\t \n\trx_ntc = rx_ring->next_to_clean;\n\ttx_ntc = tx_ring->next_to_clean;\n\trx_desc = IXGBE_RX_DESC(rx_ring, rx_ntc);\n\n\twhile (tx_ntc != tx_ring->next_to_use) {\n\t\tunion ixgbe_adv_tx_desc *tx_desc;\n\t\tstruct ixgbe_tx_buffer *tx_buffer;\n\n\t\ttx_desc = IXGBE_TX_DESC(tx_ring, tx_ntc);\n\n\t\t \n\t\tif (!(tx_desc->wb.status & cpu_to_le32(IXGBE_TXD_STAT_DD)))\n\t\t\treturn count;\n\n\t\t \n\t\ttx_buffer = &tx_ring->tx_buffer_info[tx_ntc];\n\n\t\t \n\t\tdev_kfree_skb_any(tx_buffer->skb);\n\n\t\t \n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\n\t\t \n\t\ttx_ntc++;\n\t\tif (tx_ntc == tx_ring->count)\n\t\t\ttx_ntc = 0;\n\t}\n\n\twhile (rx_desc->wb.upper.length) {\n\t\tstruct ixgbe_rx_buffer *rx_buffer;\n\n\t\t \n\t\trx_buffer = &rx_ring->rx_buffer_info[rx_ntc];\n\n\t\t \n\t\tdma_sync_single_for_cpu(rx_ring->dev,\n\t\t\t\t\trx_buffer->dma,\n\t\t\t\t\tixgbe_rx_bufsz(rx_ring),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t \n\t\tif (ixgbe_check_lbtest_frame(rx_buffer, size))\n\t\t\tcount++;\n\t\telse\n\t\t\tbreak;\n\n\t\t \n\t\tdma_sync_single_for_device(rx_ring->dev,\n\t\t\t\t\t   rx_buffer->dma,\n\t\t\t\t\t   ixgbe_rx_bufsz(rx_ring),\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t \n\t\trx_ntc++;\n\t\tif (rx_ntc == rx_ring->count)\n\t\t\trx_ntc = 0;\n\n\t\t \n\t\trx_desc = IXGBE_RX_DESC(rx_ring, rx_ntc);\n\t}\n\n\tnetdev_tx_reset_queue(txring_txq(tx_ring));\n\n\t \n\tixgbe_alloc_rx_buffers(rx_ring, count);\n\trx_ring->next_to_clean = rx_ntc;\n\ttx_ring->next_to_clean = tx_ntc;\n\n\treturn count;\n}\n\nstatic int ixgbe_run_loopback_test(struct ixgbe_adapter *adapter)\n{\n\tstruct ixgbe_ring *tx_ring = &adapter->test_tx_ring;\n\tstruct ixgbe_ring *rx_ring = &adapter->test_rx_ring;\n\tint i, j, lc, good_cnt, ret_val = 0;\n\tunsigned int size = 1024;\n\tnetdev_tx_t tx_ret_val;\n\tstruct sk_buff *skb;\n\tu32 flags_orig = adapter->flags;\n\n\t \n\tadapter->flags &= ~IXGBE_FLAG_DCB_ENABLED;\n\n\t \n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn 11;\n\n\t \n\tixgbe_create_lbtest_frame(skb, size);\n\tskb_put(skb, size);\n\n\t \n\n\tif (rx_ring->count <= tx_ring->count)\n\t\tlc = ((tx_ring->count / 64) * 2) + 1;\n\telse\n\t\tlc = ((rx_ring->count / 64) * 2) + 1;\n\n\tfor (j = 0; j <= lc; j++) {\n\t\t \n\t\tgood_cnt = 0;\n\n\t\t \n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tskb_get(skb);\n\t\t\ttx_ret_val = ixgbe_xmit_frame_ring(skb,\n\t\t\t\t\t\t\t   adapter,\n\t\t\t\t\t\t\t   tx_ring);\n\t\t\tif (tx_ret_val == NETDEV_TX_OK)\n\t\t\t\tgood_cnt++;\n\t\t}\n\n\t\tif (good_cnt != 64) {\n\t\t\tret_val = 12;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmsleep(200);\n\n\t\tgood_cnt = ixgbe_clean_test_rings(rx_ring, tx_ring, size);\n\t\tif (good_cnt != 64) {\n\t\t\tret_val = 13;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tkfree_skb(skb);\n\tadapter->flags = flags_orig;\n\n\treturn ret_val;\n}\n\nstatic int ixgbe_loopback_test(struct ixgbe_adapter *adapter, u64 *data)\n{\n\t*data = ixgbe_setup_desc_rings(adapter);\n\tif (*data)\n\t\tgoto out;\n\t*data = ixgbe_setup_loopback_test(adapter);\n\tif (*data)\n\t\tgoto err_loopback;\n\t*data = ixgbe_run_loopback_test(adapter);\n\tixgbe_loopback_cleanup(adapter);\n\nerr_loopback:\n\tixgbe_free_desc_rings(adapter);\nout:\n\treturn *data;\n}\n\nstatic void ixgbe_diag_test(struct net_device *netdev,\n\t\t\t    struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tbool if_running = netif_running(netdev);\n\n\tif (ixgbe_removed(adapter->hw.hw_addr)) {\n\t\te_err(hw, \"Adapter removed - test blocked\\n\");\n\t\tdata[0] = 1;\n\t\tdata[1] = 1;\n\t\tdata[2] = 1;\n\t\tdata[3] = 1;\n\t\tdata[4] = 1;\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\tset_bit(__IXGBE_TESTING, &adapter->state);\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\t\tif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < adapter->num_vfs; i++) {\n\t\t\t\tif (adapter->vfinfo[i].clear_to_send) {\n\t\t\t\t\tnetdev_warn(netdev, \"offline diagnostic is not supported when VFs are present\\n\");\n\t\t\t\t\tdata[0] = 1;\n\t\t\t\t\tdata[1] = 1;\n\t\t\t\t\tdata[2] = 1;\n\t\t\t\t\tdata[3] = 1;\n\t\t\t\t\tdata[4] = 1;\n\t\t\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\t\t\t\tclear_bit(__IXGBE_TESTING,\n\t\t\t\t\t\t  &adapter->state);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\te_info(hw, \"offline testing starting\\n\");\n\n\t\t \n\t\tif (ixgbe_link_test(adapter, &data[4]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (if_running)\n\t\t\t \n\t\t\tixgbe_close(netdev);\n\t\telse\n\t\t\tixgbe_reset(adapter);\n\n\t\te_info(hw, \"register testing starting\\n\");\n\t\tif (ixgbe_reg_test(adapter, &data[0]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tixgbe_reset(adapter);\n\t\te_info(hw, \"eeprom testing starting\\n\");\n\t\tif (ixgbe_eeprom_test(adapter, &data[1]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tixgbe_reset(adapter);\n\t\te_info(hw, \"interrupt testing starting\\n\");\n\t\tif (ixgbe_intr_test(adapter, &data[2]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tif (adapter->flags & (IXGBE_FLAG_SRIOV_ENABLED |\n\t\t\t\t      IXGBE_FLAG_VMDQ_ENABLED)) {\n\t\t\te_info(hw, \"Skip MAC loopback diagnostic in VT mode\\n\");\n\t\t\tdata[3] = 0;\n\t\t\tgoto skip_loopback;\n\t\t}\n\n\t\tixgbe_reset(adapter);\n\t\te_info(hw, \"loopback testing starting\\n\");\n\t\tif (ixgbe_loopback_test(adapter, &data[3]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\nskip_loopback:\n\t\tixgbe_reset(adapter);\n\n\t\t \n\t\tclear_bit(__IXGBE_TESTING, &adapter->state);\n\t\tif (if_running)\n\t\t\tixgbe_open(netdev);\n\t\telse if (hw->mac.ops.disable_tx_laser)\n\t\t\thw->mac.ops.disable_tx_laser(hw);\n\t} else {\n\t\te_info(hw, \"online testing starting\\n\");\n\n\t\t \n\t\tif (ixgbe_link_test(adapter, &data[4]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tdata[0] = 0;\n\t\tdata[1] = 0;\n\t\tdata[2] = 0;\n\t\tdata[3] = 0;\n\n\t\tclear_bit(__IXGBE_TESTING, &adapter->state);\n\t}\n}\n\nstatic int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint retval = 0;\n\n\t \n\tif (!ixgbe_wol_supported(adapter, hw->device_id,\n\t\t\t\t hw->subsystem_device_id)) {\n\t\tretval = 1;\n\t\twol->supported = 0;\n\t}\n\n\treturn retval;\n}\n\nstatic void ixgbe_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST |\n\t\t\t WAKE_BCAST | WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\tif (ixgbe_wol_exclusion(adapter, wol) ||\n\t    !device_can_wakeup(&adapter->pdev->dev))\n\t\treturn;\n\n\tif (adapter->wol & IXGBE_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & IXGBE_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & IXGBE_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & IXGBE_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\nstatic int ixgbe_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE |\n\t\t\t    WAKE_FILTER))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ixgbe_wol_exclusion(adapter, wol))\n\t\treturn wol->wolopts ? -EOPNOTSUPP : 0;\n\n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_UCAST)\n\t\tadapter->wol |= IXGBE_WUFC_EX;\n\tif (wol->wolopts & WAKE_MCAST)\n\t\tadapter->wol |= IXGBE_WUFC_MC;\n\tif (wol->wolopts & WAKE_BCAST)\n\t\tadapter->wol |= IXGBE_WUFC_BC;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= IXGBE_WUFC_MAG;\n\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\nstatic int ixgbe_nway_reset(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\tixgbe_reinit_locked(adapter);\n\n\treturn 0;\n}\n\nstatic int ixgbe_set_phys_id(struct net_device *netdev,\n\t\t\t     enum ethtool_phys_id_state state)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\tif (!hw->mac.ops.led_on || !hw->mac.ops.led_off)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tadapter->led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\t\treturn 2;\n\n\tcase ETHTOOL_ID_ON:\n\t\thw->mac.ops.led_on(hw, hw->mac.led_link_act);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\thw->mac.ops.led_off(hw, hw->mac.led_link_act);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\t \n\t\tIXGBE_WRITE_REG(&adapter->hw, IXGBE_LEDCTL, adapter->led_reg);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (adapter->rx_itr_setting <= 1)\n\t\tec->rx_coalesce_usecs = adapter->rx_itr_setting;\n\telse\n\t\tec->rx_coalesce_usecs = adapter->rx_itr_setting >> 2;\n\n\t \n\tif (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count)\n\t\treturn 0;\n\n\t \n\tif (adapter->tx_itr_setting <= 1)\n\t\tec->tx_coalesce_usecs = adapter->tx_itr_setting;\n\telse\n\t\tec->tx_coalesce_usecs = adapter->tx_itr_setting >> 2;\n\n\treturn 0;\n}\n\n \nstatic bool ixgbe_update_rsc(struct ixgbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\t \n\tif (!(adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE) ||\n\t    !(netdev->features & NETIF_F_LRO))\n\t\treturn false;\n\n\t \n\tif (adapter->rx_itr_setting == 1 ||\n\t    adapter->rx_itr_setting > IXGBE_MIN_RSC_ITR) {\n\t\tif (!(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)) {\n\t\t\tadapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;\n\t\t\te_info(probe, \"rx-usecs value high enough to re-enable RSC\\n\");\n\t\t\treturn true;\n\t\t}\n\t \n\t} else if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {\n\t\tadapter->flags2 &= ~IXGBE_FLAG2_RSC_ENABLED;\n\t\te_info(probe, \"rx-usecs set too low, disabling RSC\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int ixgbe_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_q_vector *q_vector;\n\tint i;\n\tu16 tx_itr_param, rx_itr_param, tx_itr_prev;\n\tbool need_reset = false;\n\n\tif (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count) {\n\t\t \n\t\tif (ec->tx_coalesce_usecs)\n\t\t\treturn -EINVAL;\n\t\ttx_itr_prev = adapter->rx_itr_setting;\n\t} else {\n\t\ttx_itr_prev = adapter->tx_itr_setting;\n\t}\n\n\tif ((ec->rx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)) ||\n\t    (ec->tx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)))\n\t\treturn -EINVAL;\n\n\tif (ec->rx_coalesce_usecs > 1)\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs << 2;\n\telse\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs;\n\n\tif (adapter->rx_itr_setting == 1)\n\t\trx_itr_param = IXGBE_20K_ITR;\n\telse\n\t\trx_itr_param = adapter->rx_itr_setting;\n\n\tif (ec->tx_coalesce_usecs > 1)\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs << 2;\n\telse\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs;\n\n\tif (adapter->tx_itr_setting == 1)\n\t\ttx_itr_param = IXGBE_12K_ITR;\n\telse\n\t\ttx_itr_param = adapter->tx_itr_setting;\n\n\t \n\tif (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count)\n\t\tadapter->tx_itr_setting = adapter->rx_itr_setting;\n\n\t \n\tif ((adapter->tx_itr_setting != 1) &&\n\t    (adapter->tx_itr_setting < IXGBE_100K_ITR)) {\n\t\tif ((tx_itr_prev == 1) ||\n\t\t    (tx_itr_prev >= IXGBE_100K_ITR))\n\t\t\tneed_reset = true;\n\t} else {\n\t\tif ((tx_itr_prev != 1) &&\n\t\t    (tx_itr_prev < IXGBE_100K_ITR))\n\t\t\tneed_reset = true;\n\t}\n\n\t \n\tneed_reset |= ixgbe_update_rsc(adapter);\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++) {\n\t\tq_vector = adapter->q_vector[i];\n\t\tif (q_vector->tx.count && !q_vector->rx.count)\n\t\t\t \n\t\t\tq_vector->itr = tx_itr_param;\n\t\telse\n\t\t\t \n\t\t\tq_vector->itr = rx_itr_param;\n\t\tixgbe_write_eitr(q_vector);\n\t}\n\n\t \n\tif (need_reset)\n\t\tixgbe_do_reset(netdev);\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\n\t\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tunion ixgbe_atr_input *mask = &adapter->fdir_mask;\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct hlist_node *node2;\n\tstruct ixgbe_fdir_filter *rule = NULL;\n\n\t \n\tcmd->data = (1024 << adapter->fdir_pballoc) - 2;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &adapter->fdir_filter_list, fdir_node) {\n\t\tif (fsp->location <= rule->sw_idx)\n\t\t\tbreak;\n\t}\n\n\tif (!rule || fsp->location != rule->sw_idx)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tswitch (rule->filter.formatted.flow_type) {\n\tcase IXGBE_ATR_FLOW_TYPE_TCPV4:\n\t\tfsp->flow_type = TCP_V4_FLOW;\n\t\tbreak;\n\tcase IXGBE_ATR_FLOW_TYPE_UDPV4:\n\t\tfsp->flow_type = UDP_V4_FLOW;\n\t\tbreak;\n\tcase IXGBE_ATR_FLOW_TYPE_SCTPV4:\n\t\tfsp->flow_type = SCTP_V4_FLOW;\n\t\tbreak;\n\tcase IXGBE_ATR_FLOW_TYPE_IPV4:\n\t\tfsp->flow_type = IP_USER_FLOW;\n\t\tfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\n\t\tfsp->h_u.usr_ip4_spec.proto = 0;\n\t\tfsp->m_u.usr_ip4_spec.proto = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;\n\tfsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;\n\tfsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;\n\tfsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;\n\tfsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];\n\tfsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];\n\tfsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];\n\tfsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];\n\tfsp->h_ext.vlan_tci = rule->filter.formatted.vlan_id;\n\tfsp->m_ext.vlan_tci = mask->formatted.vlan_id;\n\tfsp->h_ext.vlan_etype = rule->filter.formatted.flex_bytes;\n\tfsp->m_ext.vlan_etype = mask->formatted.flex_bytes;\n\tfsp->h_ext.data[1] = htonl(rule->filter.formatted.vm_pool);\n\tfsp->m_ext.data[1] = htonl(mask->formatted.vm_pool);\n\tfsp->flow_type |= FLOW_EXT;\n\n\t \n\tif (rule->action == IXGBE_FDIR_DROP_QUEUE)\n\t\tfsp->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfsp->ring_cookie = rule->action;\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_ethtool_fdir_all(struct ixgbe_adapter *adapter,\n\t\t\t\t      struct ethtool_rxnfc *cmd,\n\t\t\t\t      u32 *rule_locs)\n{\n\tstruct hlist_node *node2;\n\tstruct ixgbe_fdir_filter *rule;\n\tint cnt = 0;\n\n\t \n\tcmd->data = (1024 << adapter->fdir_pballoc) - 2;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &adapter->fdir_filter_list, fdir_node) {\n\t\tif (cnt == cmd->rule_cnt)\n\t\t\treturn -EMSGSIZE;\n\t\trule_locs[cnt] = rule->sw_idx;\n\t\tcnt++;\n\t}\n\n\tcmd->rule_cnt = cnt;\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tcmd->data = 0;\n\n\t \n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase UDP_V4_FLOW:\n\t\tif (adapter->flags2 & IXGBE_FLAG2_RSS_FIELD_IPV4_UDP)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase UDP_V6_FLOW:\n\t\tif (adapter->flags2 & IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_rss_indir_tbl_max(struct ixgbe_adapter *adapter)\n{\n\tif (adapter->hw.mac.type < ixgbe_mac_X550)\n\t\treturn 16;\n\telse\n\t\treturn 64;\n}\n\nstatic int ixgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t   u32 *rule_locs)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = min_t(int, adapter->num_rx_queues,\n\t\t\t\t  ixgbe_rss_indir_tbl_max(adapter));\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = adapter->fdir_filter_count;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = ixgbe_get_ethtool_fdir_entry(adapter, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tret = ixgbe_get_ethtool_fdir_all(adapter, cmd, rule_locs);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\tret = ixgbe_get_rss_hash_opts(adapter, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\n\t\t\t\t    struct ixgbe_fdir_filter *input,\n\t\t\t\t    u16 sw_idx)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct hlist_node *node2;\n\tstruct ixgbe_fdir_filter *rule, *parent;\n\tint err = -EINVAL;\n\n\tparent = NULL;\n\trule = NULL;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &adapter->fdir_filter_list, fdir_node) {\n\t\t \n\t\tif (rule->sw_idx >= sw_idx)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\t \n\tif (rule && (rule->sw_idx == sw_idx)) {\n\t\tif (!input || (rule->filter.formatted.bkt_hash !=\n\t\t\t       input->filter.formatted.bkt_hash)) {\n\t\t\terr = ixgbe_fdir_erase_perfect_filter_82599(hw,\n\t\t\t\t\t\t\t\t&rule->filter,\n\t\t\t\t\t\t\t\tsw_idx);\n\t\t}\n\n\t\thlist_del(&rule->fdir_node);\n\t\tkfree(rule);\n\t\tadapter->fdir_filter_count--;\n\t}\n\n\t \n\tif (!input)\n\t\treturn err;\n\n\t \n\tINIT_HLIST_NODE(&input->fdir_node);\n\n\t \n\tif (parent)\n\t\thlist_add_behind(&input->fdir_node, &parent->fdir_node);\n\telse\n\t\thlist_add_head(&input->fdir_node,\n\t\t\t       &adapter->fdir_filter_list);\n\n\t \n\tadapter->fdir_filter_count++;\n\n\treturn 0;\n}\n\nstatic int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t       u8 *flow_type)\n{\n\tswitch (fsp->flow_type & ~FLOW_EXT) {\n\tcase TCP_V4_FLOW:\n\t\t*flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\t*flow_type = IXGBE_ATR_FLOW_TYPE_UDPV4;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\t*flow_type = IXGBE_ATR_FLOW_TYPE_SCTPV4;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tswitch (fsp->h_u.usr_ip4_spec.proto) {\n\t\tcase IPPROTO_TCP:\n\t\t\t*flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\t\t*flow_type = IXGBE_ATR_FLOW_TYPE_UDPV4;\n\t\t\tbreak;\n\t\tcase IPPROTO_SCTP:\n\t\t\t*flow_type = IXGBE_ATR_FLOW_TYPE_SCTPV4;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (!fsp->m_u.usr_ip4_spec.proto) {\n\t\t\t\t*flow_type = IXGBE_ATR_FLOW_TYPE_IPV4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\n\t\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct ixgbe_fdir_filter *input;\n\tunion ixgbe_atr_input mask;\n\tu8 queue;\n\tint err;\n\n\tif (!(adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (fsp->ring_cookie == RX_CLS_FLOW_DISC) {\n\t\tqueue = IXGBE_FDIR_DROP_QUEUE;\n\t} else {\n\t\tu32 ring = ethtool_get_flow_spec_ring(fsp->ring_cookie);\n\t\tu8 vf = ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);\n\n\t\tif (!vf && (ring >= adapter->num_rx_queues))\n\t\t\treturn -EINVAL;\n\t\telse if (vf &&\n\t\t\t ((vf > adapter->num_vfs) ||\n\t\t\t   ring >= adapter->num_rx_queues_per_pool))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!vf)\n\t\t\tqueue = adapter->rx_ring[ring]->reg_idx;\n\t\telse\n\t\t\tqueue = ((vf - 1) *\n\t\t\t\tadapter->num_rx_queues_per_pool) + ring;\n\t}\n\n\t \n\tif (fsp->location >= ((1024 << adapter->fdir_pballoc) - 2)) {\n\t\te_err(drv, \"Location out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinput = kzalloc(sizeof(*input), GFP_ATOMIC);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tmemset(&mask, 0, sizeof(union ixgbe_atr_input));\n\n\t \n\tinput->sw_idx = fsp->location;\n\n\t \n\tif (!ixgbe_flowspec_to_flow_type(fsp,\n\t\t\t\t\t &input->filter.formatted.flow_type)) {\n\t\te_err(drv, \"Unrecognized flow type\\n\");\n\t\tgoto err_out;\n\t}\n\n\tmask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |\n\t\t\t\t   IXGBE_ATR_L4TYPE_MASK;\n\n\tif (input->filter.formatted.flow_type == IXGBE_ATR_FLOW_TYPE_IPV4)\n\t\tmask.formatted.flow_type &= IXGBE_ATR_L4TYPE_IPV6_MASK;\n\n\t \n\tinput->filter.formatted.src_ip[0] = fsp->h_u.tcp_ip4_spec.ip4src;\n\tmask.formatted.src_ip[0] = fsp->m_u.tcp_ip4_spec.ip4src;\n\tinput->filter.formatted.dst_ip[0] = fsp->h_u.tcp_ip4_spec.ip4dst;\n\tmask.formatted.dst_ip[0] = fsp->m_u.tcp_ip4_spec.ip4dst;\n\tinput->filter.formatted.src_port = fsp->h_u.tcp_ip4_spec.psrc;\n\tmask.formatted.src_port = fsp->m_u.tcp_ip4_spec.psrc;\n\tinput->filter.formatted.dst_port = fsp->h_u.tcp_ip4_spec.pdst;\n\tmask.formatted.dst_port = fsp->m_u.tcp_ip4_spec.pdst;\n\n\tif (fsp->flow_type & FLOW_EXT) {\n\t\tinput->filter.formatted.vm_pool =\n\t\t\t\t(unsigned char)ntohl(fsp->h_ext.data[1]);\n\t\tmask.formatted.vm_pool =\n\t\t\t\t(unsigned char)ntohl(fsp->m_ext.data[1]);\n\t\tinput->filter.formatted.vlan_id = fsp->h_ext.vlan_tci;\n\t\tmask.formatted.vlan_id = fsp->m_ext.vlan_tci;\n\t\tinput->filter.formatted.flex_bytes =\n\t\t\t\t\t\tfsp->h_ext.vlan_etype;\n\t\tmask.formatted.flex_bytes = fsp->m_ext.vlan_etype;\n\t}\n\n\t \n\tif (fsp->ring_cookie == RX_CLS_FLOW_DISC)\n\t\tinput->action = IXGBE_FDIR_DROP_QUEUE;\n\telse\n\t\tinput->action = fsp->ring_cookie;\n\n\tspin_lock(&adapter->fdir_perfect_lock);\n\n\tif (hlist_empty(&adapter->fdir_filter_list)) {\n\t\t \n\t\tmemcpy(&adapter->fdir_mask, &mask, sizeof(mask));\n\t\terr = ixgbe_fdir_set_input_mask_82599(hw, &mask);\n\t\tif (err) {\n\t\t\te_err(drv, \"Error writing mask\\n\");\n\t\t\tgoto err_out_w_lock;\n\t\t}\n\t} else if (memcmp(&adapter->fdir_mask, &mask, sizeof(mask))) {\n\t\te_err(drv, \"Only one mask supported per port\\n\");\n\t\tgoto err_out_w_lock;\n\t}\n\n\t \n\tixgbe_atr_compute_perfect_hash_82599(&input->filter, &mask);\n\n\t \n\terr = ixgbe_fdir_write_perfect_filter_82599(hw,\n\t\t\t\t&input->filter, input->sw_idx, queue);\n\tif (err)\n\t\tgoto err_out_w_lock;\n\n\tixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);\n\n\tspin_unlock(&adapter->fdir_perfect_lock);\n\n\treturn err;\nerr_out_w_lock:\n\tspin_unlock(&adapter->fdir_perfect_lock);\nerr_out:\n\tkfree(input);\n\treturn -EINVAL;\n}\n\nstatic int ixgbe_del_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\n\t\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tint err;\n\n\tspin_lock(&adapter->fdir_perfect_lock);\n\terr = ixgbe_update_ethtool_fdir_entry(adapter, NULL, fsp->location);\n\tspin_unlock(&adapter->fdir_perfect_lock);\n\n\treturn err;\n}\n\n#define UDP_RSS_FLAGS (IXGBE_FLAG2_RSS_FIELD_IPV4_UDP | \\\n\t\t       IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)\nstatic int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter,\n\t\t\t\t  struct ethtool_rxnfc *nfc)\n{\n\tu32 flags2 = adapter->flags2;\n\n\t \n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    !(nfc->data & RXH_L4_B_0_1) ||\n\t\t    !(nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tflags2 &= ~IXGBE_FLAG2_RSS_FIELD_IPV4_UDP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tflags2 |= IXGBE_FLAG2_RSS_FIELD_IPV4_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\tflags2 &= ~IXGBE_FLAG2_RSS_FIELD_IPV6_UDP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\tflags2 |= IXGBE_FLAG2_RSS_FIELD_IPV6_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    (nfc->data & RXH_L4_B_0_1) ||\n\t\t    (nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (flags2 != adapter->flags2) {\n\t\tstruct ixgbe_hw *hw = &adapter->hw;\n\t\tu32 mrqc;\n\t\tunsigned int pf_pool = adapter->num_vfs;\n\n\t\tif ((hw->mac.type >= ixgbe_mac_X550) &&\n\t\t    (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))\n\t\t\tmrqc = IXGBE_READ_REG(hw, IXGBE_PFVFMRQC(pf_pool));\n\t\telse\n\t\t\tmrqc = IXGBE_READ_REG(hw, IXGBE_MRQC);\n\n\t\tif ((flags2 & UDP_RSS_FLAGS) &&\n\t\t    !(adapter->flags2 & UDP_RSS_FLAGS))\n\t\t\te_warn(drv, \"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\\n\");\n\n\t\tadapter->flags2 = flags2;\n\n\t\t \n\t\tmrqc |= IXGBE_MRQC_RSS_FIELD_IPV4\n\t\t      | IXGBE_MRQC_RSS_FIELD_IPV4_TCP\n\t\t      | IXGBE_MRQC_RSS_FIELD_IPV6\n\t\t      | IXGBE_MRQC_RSS_FIELD_IPV6_TCP;\n\n\t\tmrqc &= ~(IXGBE_MRQC_RSS_FIELD_IPV4_UDP |\n\t\t\t  IXGBE_MRQC_RSS_FIELD_IPV6_UDP);\n\n\t\tif (flags2 & IXGBE_FLAG2_RSS_FIELD_IPV4_UDP)\n\t\t\tmrqc |= IXGBE_MRQC_RSS_FIELD_IPV4_UDP;\n\n\t\tif (flags2 & IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)\n\t\t\tmrqc |= IXGBE_MRQC_RSS_FIELD_IPV6_UDP;\n\n\t\tif ((hw->mac.type >= ixgbe_mac_X550) &&\n\t\t    (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_PFVFMRQC(pf_pool), mrqc);\n\t\telse\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_MRQC, mrqc);\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = ixgbe_add_ethtool_fdir_entry(adapter, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = ixgbe_del_ethtool_fdir_entry(adapter, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXFH:\n\t\tret = ixgbe_set_rss_hash_opt(adapter, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 ixgbe_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn IXGBE_RSS_KEY_SIZE;\n}\n\nstatic u32 ixgbe_rss_indir_size(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\treturn ixgbe_rss_indir_tbl_entries(adapter);\n}\n\nstatic void ixgbe_get_reta(struct ixgbe_adapter *adapter, u32 *indir)\n{\n\tint i, reta_size = ixgbe_rss_indir_tbl_entries(adapter);\n\tu16 rss_m = adapter->ring_feature[RING_F_RSS].mask;\n\n\tif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)\n\t\trss_m = adapter->ring_feature[RING_F_RSS].indices - 1;\n\n\tfor (i = 0; i < reta_size; i++)\n\t\tindir[i] = adapter->rss_indir_tbl[i] & rss_m;\n}\n\nstatic int ixgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t  u8 *hfunc)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\tif (indir)\n\t\tixgbe_get_reta(adapter, indir);\n\n\tif (key)\n\t\tmemcpy(key, adapter->rss_key, ixgbe_get_rxfh_key_size(netdev));\n\n\treturn 0;\n}\n\nstatic int ixgbe_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\tu32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (indir) {\n\t\tint max_queues = min_t(int, adapter->num_rx_queues,\n\t\t\t\t       ixgbe_rss_indir_tbl_max(adapter));\n\n\t\t \n\t\tif ((adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) &&\n\t\t    (max_queues < 2))\n\t\t\tmax_queues = 2;\n\n\t\t \n\t\tfor (i = 0; i < reta_entries; i++)\n\t\t\tif (indir[i] >= max_queues)\n\t\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < reta_entries; i++)\n\t\t\tadapter->rss_indir_tbl[i] = indir[i];\n\n\t\tixgbe_store_reta(adapter);\n\t}\n\n\t \n\tif (key) {\n\t\tmemcpy(adapter->rss_key, key, ixgbe_get_rxfh_key_size(netdev));\n\t\tixgbe_store_key(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_ts_info(struct net_device *dev,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\n\t \n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE);\n\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_ALL);\n\t\tbreak;\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_82599EB:\n\t\tinfo->rx_filters |=\n\t\t\tBIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\tBIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\tBIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\t\tbreak;\n\tdefault:\n\t\treturn ethtool_op_get_ts_info(dev, info);\n\t}\n\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tif (adapter->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(adapter->ptp_clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n\tinfo->tx_types =\n\t\tBIT(HWTSTAMP_TX_OFF) |\n\t\tBIT(HWTSTAMP_TX_ON);\n\n\treturn 0;\n}\n\nstatic unsigned int ixgbe_max_channels(struct ixgbe_adapter *adapter)\n{\n\tunsigned int max_combined;\n\tu8 tcs = adapter->hw_tcs;\n\n\tif (!(adapter->flags & IXGBE_FLAG_MSIX_ENABLED)) {\n\t\t \n\t\tmax_combined = 1;\n\t} else if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\n\t\t \n\t\tmax_combined = adapter->ring_feature[RING_F_RSS].mask + 1;\n\t} else if (tcs > 1) {\n\t\t \n\t\tif (adapter->hw.mac.type == ixgbe_mac_82598EB) {\n\t\t\t \n\t\t\tmax_combined = 4;\n\t\t} else if (tcs > 4) {\n\t\t\t \n\t\t\tmax_combined = 8;\n\t\t} else {\n\t\t\t \n\t\t\tmax_combined = 16;\n\t\t}\n\t} else if (adapter->atr_sample_rate) {\n\t\t \n\t\tmax_combined = IXGBE_MAX_FDIR_INDICES;\n\t} else {\n\t\t \n\t\tmax_combined = ixgbe_max_rss_indices(adapter);\n\t}\n\n\treturn min_t(int, max_combined, num_online_cpus());\n}\n\nstatic void ixgbe_get_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *ch)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\n\t \n\tch->max_combined = ixgbe_max_channels(adapter);\n\n\t \n\tif (adapter->flags & IXGBE_FLAG_MSIX_ENABLED) {\n\t\tch->max_other = NON_Q_VECTORS;\n\t\tch->other_count = NON_Q_VECTORS;\n\t}\n\n\t \n\tch->combined_count = adapter->ring_feature[RING_F_RSS].indices;\n\n\t \n\tif (ch->combined_count == 1)\n\t\treturn;\n\n\t \n\tif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)\n\t\treturn;\n\n\t \n\tif (adapter->hw_tcs > 1)\n\t\treturn;\n\n\t \n\tif (!adapter->atr_sample_rate)\n\t\treturn;\n\n\t \n\tch->combined_count = adapter->ring_feature[RING_F_FDIR].indices;\n}\n\nstatic int ixgbe_set_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *ch)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tunsigned int count = ch->combined_count;\n\tu8 max_rss_indices = ixgbe_max_rss_indices(adapter);\n\n\t \n\tif (!count || ch->rx_count || ch->tx_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (ch->other_count != NON_Q_VECTORS)\n\t\treturn -EINVAL;\n\n\t \n\tif (count > ixgbe_max_channels(adapter))\n\t\treturn -EINVAL;\n\n\t \n\tadapter->ring_feature[RING_F_FDIR].limit = count;\n\n\t \n\tif (count > max_rss_indices)\n\t\tcount = max_rss_indices;\n\tadapter->ring_feature[RING_F_RSS].limit = count;\n\n#ifdef IXGBE_FCOE\n\t \n\tif (count > IXGBE_FCRETA_SIZE)\n\t\tcount = IXGBE_FCRETA_SIZE;\n\tadapter->ring_feature[RING_F_FCOE].limit = count;\n\n#endif\n\t \n\treturn ixgbe_setup_tc(dev, adapter->hw_tcs);\n}\n\nstatic int ixgbe_get_module_info(struct net_device *dev,\n\t\t\t\t       struct ethtool_modinfo *modinfo)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\ts32 status;\n\tu8 sff8472_rev, addr_mode;\n\tbool page_swap = false;\n\n\tif (hw->phy.type == ixgbe_phy_fw)\n\t\treturn -ENXIO;\n\n\t \n\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t     IXGBE_SFF_SFF_8472_COMP,\n\t\t\t\t\t     &sff8472_rev);\n\tif (status)\n\t\treturn -EIO;\n\n\t \n\tstatus = hw->phy.ops.read_i2c_eeprom(hw,\n\t\t\t\t\t     IXGBE_SFF_SFF_8472_SWAP,\n\t\t\t\t\t     &addr_mode);\n\tif (status)\n\t\treturn -EIO;\n\n\tif (addr_mode & IXGBE_SFF_ADDRESSING_MODE) {\n\t\te_err(drv, \"Address change required to access page 0xA2, but not supported. Please report the module type to the driver maintainers.\\n\");\n\t\tpage_swap = true;\n\t}\n\n\tif (sff8472_rev == IXGBE_SFF_SFF_8472_UNSUP || page_swap ||\n\t    !(addr_mode & IXGBE_SFF_DDM_IMPLEMENTED)) {\n\t\t \n\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t} else {\n\t\t \n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_module_eeprom(struct net_device *dev,\n\t\t\t\t\t struct ethtool_eeprom *ee,\n\t\t\t\t\t u8 *data)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\ts32 status = IXGBE_ERR_PHY_ADDR_INVALID;\n\tu8 databyte = 0xFF;\n\tint i = 0;\n\n\tif (ee->len == 0)\n\t\treturn -EINVAL;\n\n\tif (hw->phy.type == ixgbe_phy_fw)\n\t\treturn -ENXIO;\n\n\tfor (i = ee->offset; i < ee->offset + ee->len; i++) {\n\t\t \n\t\tif (test_bit(__IXGBE_IN_SFP_INIT, &adapter->state))\n\t\t\treturn -EBUSY;\n\n\t\tif (i < ETH_MODULE_SFF_8079_LEN)\n\t\t\tstatus = hw->phy.ops.read_i2c_eeprom(hw, i, &databyte);\n\t\telse\n\t\t\tstatus = hw->phy.ops.read_i2c_sff8472(hw, i, &databyte);\n\n\t\tif (status)\n\t\t\treturn -EIO;\n\n\t\tdata[i - ee->offset] = databyte;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct {\n\tixgbe_link_speed mac_speed;\n\tu32 supported;\n} ixgbe_ls_map[] = {\n\t{ IXGBE_LINK_SPEED_10_FULL, SUPPORTED_10baseT_Full },\n\t{ IXGBE_LINK_SPEED_100_FULL, SUPPORTED_100baseT_Full },\n\t{ IXGBE_LINK_SPEED_1GB_FULL, SUPPORTED_1000baseT_Full },\n\t{ IXGBE_LINK_SPEED_2_5GB_FULL, SUPPORTED_2500baseX_Full },\n\t{ IXGBE_LINK_SPEED_10GB_FULL, SUPPORTED_10000baseT_Full },\n};\n\nstatic const struct {\n\tu32 lp_advertised;\n\tu32 mac_speed;\n} ixgbe_lp_map[] = {\n\t{ FW_PHY_ACT_UD_2_100M_TX_EEE, SUPPORTED_100baseT_Full },\n\t{ FW_PHY_ACT_UD_2_1G_T_EEE, SUPPORTED_1000baseT_Full },\n\t{ FW_PHY_ACT_UD_2_10G_T_EEE, SUPPORTED_10000baseT_Full },\n\t{ FW_PHY_ACT_UD_2_1G_KX_EEE, SUPPORTED_1000baseKX_Full },\n\t{ FW_PHY_ACT_UD_2_10G_KX4_EEE, SUPPORTED_10000baseKX4_Full },\n\t{ FW_PHY_ACT_UD_2_10G_KR_EEE, SUPPORTED_10000baseKR_Full},\n};\n\nstatic int\nixgbe_get_eee_fw(struct ixgbe_adapter *adapter, struct ethtool_eee *edata)\n{\n\tu32 info[FW_PHY_ACT_DATA_COUNT] = { 0 };\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\ts32 rc;\n\tu16 i;\n\n\trc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_UD_2, &info);\n\tif (rc)\n\t\treturn rc;\n\n\tedata->lp_advertised = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ixgbe_lp_map); ++i) {\n\t\tif (info[0] & ixgbe_lp_map[i].lp_advertised)\n\t\t\tedata->lp_advertised |= ixgbe_lp_map[i].mac_speed;\n\t}\n\n\tedata->supported = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ixgbe_ls_map); ++i) {\n\t\tif (hw->phy.eee_speeds_supported & ixgbe_ls_map[i].mac_speed)\n\t\t\tedata->supported |= ixgbe_ls_map[i].supported;\n\t}\n\n\tedata->advertised = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ixgbe_ls_map); ++i) {\n\t\tif (hw->phy.eee_speeds_advertised & ixgbe_ls_map[i].mac_speed)\n\t\t\tedata->advertised |= ixgbe_ls_map[i].supported;\n\t}\n\n\tedata->eee_enabled = !!edata->advertised;\n\tedata->tx_lpi_enabled = edata->eee_enabled;\n\tif (edata->advertised & edata->lp_advertised)\n\t\tedata->eee_active = true;\n\n\treturn 0;\n}\n\nstatic int ixgbe_get_eee(struct net_device *netdev, struct ethtool_eee *edata)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\tif (!(adapter->flags2 & IXGBE_FLAG2_EEE_CAPABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (hw->phy.eee_speeds_supported && hw->phy.type == ixgbe_phy_fw)\n\t\treturn ixgbe_get_eee_fw(adapter, edata);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ixgbe_set_eee(struct net_device *netdev, struct ethtool_eee *edata)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct ethtool_eee eee_data;\n\ts32 ret_val;\n\n\tif (!(adapter->flags2 & IXGBE_FLAG2_EEE_CAPABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&eee_data, 0, sizeof(struct ethtool_eee));\n\n\tret_val = ixgbe_get_eee(netdev, &eee_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (eee_data.eee_enabled && !edata->eee_enabled) {\n\t\tif (eee_data.tx_lpi_enabled != edata->tx_lpi_enabled) {\n\t\t\te_err(drv, \"Setting EEE tx-lpi is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (eee_data.tx_lpi_timer != edata->tx_lpi_timer) {\n\t\t\te_err(drv,\n\t\t\t      \"Setting EEE Tx LPI timer is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (eee_data.advertised != edata->advertised) {\n\t\t\te_err(drv,\n\t\t\t      \"Setting EEE advertised speeds is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (eee_data.eee_enabled != edata->eee_enabled) {\n\t\tif (edata->eee_enabled) {\n\t\t\tadapter->flags2 |= IXGBE_FLAG2_EEE_ENABLED;\n\t\t\thw->phy.eee_speeds_advertised =\n\t\t\t\t\t\t   hw->phy.eee_speeds_supported;\n\t\t} else {\n\t\t\tadapter->flags2 &= ~IXGBE_FLAG2_EEE_ENABLED;\n\t\t\thw->phy.eee_speeds_advertised = 0;\n\t\t}\n\n\t\t \n\t\tif (netif_running(netdev))\n\t\t\tixgbe_reinit_locked(adapter);\n\t\telse\n\t\t\tixgbe_reset(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 ixgbe_get_priv_flags(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tu32 priv_flags = 0;\n\n\tif (adapter->flags2 & IXGBE_FLAG2_RX_LEGACY)\n\t\tpriv_flags |= IXGBE_PRIV_FLAGS_LEGACY_RX;\n\n\tif (adapter->flags2 & IXGBE_FLAG2_VF_IPSEC_ENABLED)\n\t\tpriv_flags |= IXGBE_PRIV_FLAGS_VF_IPSEC_EN;\n\n\tif (adapter->flags2 & IXGBE_FLAG2_AUTO_DISABLE_VF)\n\t\tpriv_flags |= IXGBE_PRIV_FLAGS_AUTO_DISABLE_VF;\n\n\treturn priv_flags;\n}\n\nstatic int ixgbe_set_priv_flags(struct net_device *netdev, u32 priv_flags)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tunsigned int flags2 = adapter->flags2;\n\tunsigned int i;\n\n\tflags2 &= ~IXGBE_FLAG2_RX_LEGACY;\n\tif (priv_flags & IXGBE_PRIV_FLAGS_LEGACY_RX)\n\t\tflags2 |= IXGBE_FLAG2_RX_LEGACY;\n\n\tflags2 &= ~IXGBE_FLAG2_VF_IPSEC_ENABLED;\n\tif (priv_flags & IXGBE_PRIV_FLAGS_VF_IPSEC_EN)\n\t\tflags2 |= IXGBE_FLAG2_VF_IPSEC_ENABLED;\n\n\tflags2 &= ~IXGBE_FLAG2_AUTO_DISABLE_VF;\n\tif (priv_flags & IXGBE_PRIV_FLAGS_AUTO_DISABLE_VF) {\n\t\tif (adapter->hw.mac.type == ixgbe_mac_82599EB) {\n\t\t\t \n\t\t\tfor (i = 0; i < adapter->num_vfs; i++)\n\t\t\t\tadapter->vfinfo[i].primary_abort_count = 0;\n\n\t\t\tflags2 |= IXGBE_FLAG2_AUTO_DISABLE_VF;\n\t\t} else {\n\t\t\te_info(probe,\n\t\t\t       \"Cannot set private flags: Operation not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (flags2 != adapter->flags2) {\n\t\tadapter->flags2 = flags2;\n\n\t\t \n\t\tif (netif_running(netdev))\n\t\t\tixgbe_reinit_locked(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ixgbe_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS,\n\t.get_drvinfo            = ixgbe_get_drvinfo,\n\t.get_regs_len           = ixgbe_get_regs_len,\n\t.get_regs               = ixgbe_get_regs,\n\t.get_wol                = ixgbe_get_wol,\n\t.set_wol                = ixgbe_set_wol,\n\t.nway_reset             = ixgbe_nway_reset,\n\t.get_link               = ethtool_op_get_link,\n\t.get_eeprom_len         = ixgbe_get_eeprom_len,\n\t.get_eeprom             = ixgbe_get_eeprom,\n\t.set_eeprom             = ixgbe_set_eeprom,\n\t.get_ringparam          = ixgbe_get_ringparam,\n\t.set_ringparam          = ixgbe_set_ringparam,\n\t.get_pause_stats\t= ixgbe_get_pause_stats,\n\t.get_pauseparam         = ixgbe_get_pauseparam,\n\t.set_pauseparam         = ixgbe_set_pauseparam,\n\t.get_msglevel           = ixgbe_get_msglevel,\n\t.set_msglevel           = ixgbe_set_msglevel,\n\t.self_test              = ixgbe_diag_test,\n\t.get_strings            = ixgbe_get_strings,\n\t.set_phys_id            = ixgbe_set_phys_id,\n\t.get_sset_count         = ixgbe_get_sset_count,\n\t.get_ethtool_stats      = ixgbe_get_ethtool_stats,\n\t.get_coalesce           = ixgbe_get_coalesce,\n\t.set_coalesce           = ixgbe_set_coalesce,\n\t.get_rxnfc\t\t= ixgbe_get_rxnfc,\n\t.set_rxnfc\t\t= ixgbe_set_rxnfc,\n\t.get_rxfh_indir_size\t= ixgbe_rss_indir_size,\n\t.get_rxfh_key_size\t= ixgbe_get_rxfh_key_size,\n\t.get_rxfh\t\t= ixgbe_get_rxfh,\n\t.set_rxfh\t\t= ixgbe_set_rxfh,\n\t.get_eee\t\t= ixgbe_get_eee,\n\t.set_eee\t\t= ixgbe_set_eee,\n\t.get_channels\t\t= ixgbe_get_channels,\n\t.set_channels\t\t= ixgbe_set_channels,\n\t.get_priv_flags\t\t= ixgbe_get_priv_flags,\n\t.set_priv_flags\t\t= ixgbe_set_priv_flags,\n\t.get_ts_info\t\t= ixgbe_get_ts_info,\n\t.get_module_info\t= ixgbe_get_module_info,\n\t.get_module_eeprom\t= ixgbe_get_module_eeprom,\n\t.get_link_ksettings     = ixgbe_get_link_ksettings,\n\t.set_link_ksettings     = ixgbe_set_link_ksettings,\n};\n\nvoid ixgbe_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ixgbe_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}