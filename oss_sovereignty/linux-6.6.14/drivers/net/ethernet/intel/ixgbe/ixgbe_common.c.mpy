{
  "module_name": "ixgbe_common.c",
  "hash_id": "19d199ab3ff3d371ed2025c76f356a485f5ff6d6dd86f1735618b92f58b85cd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/netdevice.h>\n\n#include \"ixgbe.h\"\n#include \"ixgbe_common.h\"\n#include \"ixgbe_phy.h\"\n\nstatic s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw);\nstatic s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);\nstatic void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);\nstatic s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw);\nstatic void ixgbe_standby_eeprom(struct ixgbe_hw *hw);\nstatic void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,\n\t\t\t\t\tu16 count);\nstatic u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count);\nstatic void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);\nstatic void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);\nstatic void ixgbe_release_eeprom(struct ixgbe_hw *hw);\n\nstatic s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr);\nstatic s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg);\nstatic s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t     u16 words, u16 *data);\nstatic s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t     u16 words, u16 *data);\nstatic s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,\n\t\t\t\t\t\t u16 offset);\nstatic s32 ixgbe_disable_pcie_primary(struct ixgbe_hw *hw);\n\n \nconst u32 ixgbe_mvals_8259X[IXGBE_MVALS_IDX_LIMIT] = {\n\tIXGBE_MVALS_INIT(8259X)\n};\n\n \nbool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)\n{\n\tbool supported = false;\n\tixgbe_link_speed speed;\n\tbool link_up;\n\n\tswitch (hw->phy.media_type) {\n\tcase ixgbe_media_type_fiber:\n\t\t \n\t\tswitch (hw->device_id) {\n\t\tcase IXGBE_DEV_ID_X550EM_A_SFP:\n\t\tcase IXGBE_DEV_ID_X550EM_A_SFP_N:\n\t\t\tsupported = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thw->mac.ops.check_link(hw, &speed, &link_up, false);\n\t\t\t \n\t\t\tif (link_up)\n\t\t\t\tsupported = speed == IXGBE_LINK_SPEED_1GB_FULL;\n\t\t\telse\n\t\t\t\tsupported = true;\n\t\t}\n\n\t\tbreak;\n\tcase ixgbe_media_type_backplane:\n\t\tif (hw->device_id == IXGBE_DEV_ID_X550EM_X_XFI)\n\t\t\tsupported = false;\n\t\telse\n\t\t\tsupported = true;\n\t\tbreak;\n\tcase ixgbe_media_type_copper:\n\t\t \n\t\tswitch (hw->device_id) {\n\t\tcase IXGBE_DEV_ID_82599_T3_LOM:\n\t\tcase IXGBE_DEV_ID_X540T:\n\t\tcase IXGBE_DEV_ID_X540T1:\n\t\tcase IXGBE_DEV_ID_X550T:\n\t\tcase IXGBE_DEV_ID_X550T1:\n\t\tcase IXGBE_DEV_ID_X550EM_X_10G_T:\n\t\tcase IXGBE_DEV_ID_X550EM_A_10G_T:\n\t\tcase IXGBE_DEV_ID_X550EM_A_1G_T:\n\t\tcase IXGBE_DEV_ID_X550EM_A_1G_T_L:\n\t\t\tsupported = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!supported)\n\t\thw_dbg(hw, \"Device %x does not support flow control autoneg\\n\",\n\t\t       hw->device_id);\n\n\treturn supported;\n}\n\n \ns32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw)\n{\n\ts32 ret_val = 0;\n\tu32 reg = 0, reg_bp = 0;\n\tu16 reg_cu = 0;\n\tbool locked = false;\n\n\t \n\tif (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {\n\t\thw_dbg(hw, \"ixgbe_fc_rx_pause not valid in strict IEEE mode\\n\");\n\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\t}\n\n\t \n\tif (hw->fc.requested_mode == ixgbe_fc_default)\n\t\thw->fc.requested_mode = ixgbe_fc_full;\n\n\t \n\tswitch (hw->phy.media_type) {\n\tcase ixgbe_media_type_backplane:\n\t\t \n\t\tret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &reg_bp);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tfallthrough;  \n\tcase ixgbe_media_type_fiber:\n\t\treg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);\n\n\t\tbreak;\n\tcase ixgbe_media_type_copper:\n\t\thw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,\n\t\t\t\t\tMDIO_MMD_AN, &reg_cu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw->fc.requested_mode) {\n\tcase ixgbe_fc_none:\n\t\t \n\t\treg &= ~(IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);\n\t\tif (hw->phy.media_type == ixgbe_media_type_backplane)\n\t\t\treg_bp &= ~(IXGBE_AUTOC_SYM_PAUSE |\n\t\t\t\t    IXGBE_AUTOC_ASM_PAUSE);\n\t\telse if (hw->phy.media_type == ixgbe_media_type_copper)\n\t\t\treg_cu &= ~(IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE);\n\t\tbreak;\n\tcase ixgbe_fc_tx_pause:\n\t\t \n\t\treg |= IXGBE_PCS1GANA_ASM_PAUSE;\n\t\treg &= ~IXGBE_PCS1GANA_SYM_PAUSE;\n\t\tif (hw->phy.media_type == ixgbe_media_type_backplane) {\n\t\t\treg_bp |= IXGBE_AUTOC_ASM_PAUSE;\n\t\t\treg_bp &= ~IXGBE_AUTOC_SYM_PAUSE;\n\t\t} else if (hw->phy.media_type == ixgbe_media_type_copper) {\n\t\t\treg_cu |= IXGBE_TAF_ASM_PAUSE;\n\t\t\treg_cu &= ~IXGBE_TAF_SYM_PAUSE;\n\t\t}\n\t\tbreak;\n\tcase ixgbe_fc_rx_pause:\n\t\t \n\tcase ixgbe_fc_full:\n\t\t \n\t\treg |= IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE;\n\t\tif (hw->phy.media_type == ixgbe_media_type_backplane)\n\t\t\treg_bp |= IXGBE_AUTOC_SYM_PAUSE |\n\t\t\t\t  IXGBE_AUTOC_ASM_PAUSE;\n\t\telse if (hw->phy.media_type == ixgbe_media_type_copper)\n\t\t\treg_cu |= IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE;\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \"Flow control param set incorrectly\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\tif (hw->mac.type != ixgbe_mac_X540) {\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_PCS1GANA, reg);\n\t\treg = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);\n\n\t\t \n\t\tif (hw->fc.strict_ieee)\n\t\t\treg &= ~IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN;\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_PCS1GLCTL, reg);\n\t\thw_dbg(hw, \"Set up FC; PCS1GLCTL = 0x%08X\\n\", reg);\n\t}\n\n\t \n\tif (hw->phy.media_type == ixgbe_media_type_backplane) {\n\t\t \n\t\tret_val = hw->mac.ops.prot_autoc_write(hw, reg_bp, locked);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t} else if ((hw->phy.media_type == ixgbe_media_type_copper) &&\n\t\t   ixgbe_device_supports_autoneg_fc(hw)) {\n\t\thw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE,\n\t\t\t\t      MDIO_MMD_AN, reg_cu);\n\t}\n\n\thw_dbg(hw, \"Set up FC; IXGBE_AUTOC = 0x%08X\\n\", reg);\n\treturn ret_val;\n}\n\n \ns32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)\n{\n\ts32 ret_val;\n\tu32 ctrl_ext;\n\tu16 device_caps;\n\n\t \n\thw->phy.media_type = hw->mac.ops.get_media_type(hw);\n\n\t \n\thw->phy.ops.identify(hw);\n\n\t \n\thw->mac.ops.clear_vfta(hw);\n\n\t \n\thw->mac.ops.clear_hw_cntrs(hw);\n\n\t \n\tctrl_ext = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);\n\tctrl_ext |= IXGBE_CTRL_EXT_NS_DIS;\n\tIXGBE_WRITE_REG(hw, IXGBE_CTRL_EXT, ctrl_ext);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tif (hw->mac.ops.setup_fc) {\n\t\tret_val = hw->mac.ops.setup_fc(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_82599EB:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\thw->mac.ops.get_device_caps(hw, &device_caps);\n\t\tif (device_caps & IXGBE_DEVICE_CAPS_NO_CROSSTALK_WR)\n\t\t\thw->need_crosstalk_fix = false;\n\t\telse\n\t\t\thw->need_crosstalk_fix = true;\n\t\tbreak;\n\tdefault:\n\t\thw->need_crosstalk_fix = false;\n\t\tbreak;\n\t}\n\n\t \n\thw->adapter_stopped = false;\n\n\treturn 0;\n}\n\n \ns32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw)\n{\n\tu32 i;\n\n\t \n\tfor (i = 0; i < hw->mac.max_tx_queues; i++) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RTTDQSEL, i);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRC, 0);\n\t}\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_init_hw_generic(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\n\t \n\tstatus = hw->mac.ops.reset_hw(hw);\n\n\tif (status == 0) {\n\t\t \n\t\tstatus = hw->mac.ops.start_hw(hw);\n\t}\n\n\t \n\tif (hw->mac.ops.init_led_link_act)\n\t\thw->mac.ops.init_led_link_act(hw);\n\n\treturn status;\n}\n\n \ns32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)\n{\n\tu16 i = 0;\n\n\tIXGBE_READ_REG(hw, IXGBE_CRCERRS);\n\tIXGBE_READ_REG(hw, IXGBE_ILLERRC);\n\tIXGBE_READ_REG(hw, IXGBE_ERRBC);\n\tIXGBE_READ_REG(hw, IXGBE_MSPDC);\n\tfor (i = 0; i < 8; i++)\n\t\tIXGBE_READ_REG(hw, IXGBE_MPC(i));\n\n\tIXGBE_READ_REG(hw, IXGBE_MLFC);\n\tIXGBE_READ_REG(hw, IXGBE_MRFC);\n\tIXGBE_READ_REG(hw, IXGBE_RLEC);\n\tIXGBE_READ_REG(hw, IXGBE_LXONTXC);\n\tIXGBE_READ_REG(hw, IXGBE_LXOFFTXC);\n\tif (hw->mac.type >= ixgbe_mac_82599EB) {\n\t\tIXGBE_READ_REG(hw, IXGBE_LXONRXCNT);\n\t\tIXGBE_READ_REG(hw, IXGBE_LXOFFRXCNT);\n\t} else {\n\t\tIXGBE_READ_REG(hw, IXGBE_LXONRXC);\n\t\tIXGBE_READ_REG(hw, IXGBE_LXOFFRXC);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tIXGBE_READ_REG(hw, IXGBE_PXONTXC(i));\n\t\tIXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));\n\t\tif (hw->mac.type >= ixgbe_mac_82599EB) {\n\t\t\tIXGBE_READ_REG(hw, IXGBE_PXONRXCNT(i));\n\t\t\tIXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(i));\n\t\t} else {\n\t\t\tIXGBE_READ_REG(hw, IXGBE_PXONRXC(i));\n\t\t\tIXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));\n\t\t}\n\t}\n\tif (hw->mac.type >= ixgbe_mac_82599EB)\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tIXGBE_READ_REG(hw, IXGBE_PXON2OFFCNT(i));\n\tIXGBE_READ_REG(hw, IXGBE_PRC64);\n\tIXGBE_READ_REG(hw, IXGBE_PRC127);\n\tIXGBE_READ_REG(hw, IXGBE_PRC255);\n\tIXGBE_READ_REG(hw, IXGBE_PRC511);\n\tIXGBE_READ_REG(hw, IXGBE_PRC1023);\n\tIXGBE_READ_REG(hw, IXGBE_PRC1522);\n\tIXGBE_READ_REG(hw, IXGBE_GPRC);\n\tIXGBE_READ_REG(hw, IXGBE_BPRC);\n\tIXGBE_READ_REG(hw, IXGBE_MPRC);\n\tIXGBE_READ_REG(hw, IXGBE_GPTC);\n\tIXGBE_READ_REG(hw, IXGBE_GORCL);\n\tIXGBE_READ_REG(hw, IXGBE_GORCH);\n\tIXGBE_READ_REG(hw, IXGBE_GOTCL);\n\tIXGBE_READ_REG(hw, IXGBE_GOTCH);\n\tif (hw->mac.type == ixgbe_mac_82598EB)\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tIXGBE_READ_REG(hw, IXGBE_RNBC(i));\n\tIXGBE_READ_REG(hw, IXGBE_RUC);\n\tIXGBE_READ_REG(hw, IXGBE_RFC);\n\tIXGBE_READ_REG(hw, IXGBE_ROC);\n\tIXGBE_READ_REG(hw, IXGBE_RJC);\n\tIXGBE_READ_REG(hw, IXGBE_MNGPRC);\n\tIXGBE_READ_REG(hw, IXGBE_MNGPDC);\n\tIXGBE_READ_REG(hw, IXGBE_MNGPTC);\n\tIXGBE_READ_REG(hw, IXGBE_TORL);\n\tIXGBE_READ_REG(hw, IXGBE_TORH);\n\tIXGBE_READ_REG(hw, IXGBE_TPR);\n\tIXGBE_READ_REG(hw, IXGBE_TPT);\n\tIXGBE_READ_REG(hw, IXGBE_PTC64);\n\tIXGBE_READ_REG(hw, IXGBE_PTC127);\n\tIXGBE_READ_REG(hw, IXGBE_PTC255);\n\tIXGBE_READ_REG(hw, IXGBE_PTC511);\n\tIXGBE_READ_REG(hw, IXGBE_PTC1023);\n\tIXGBE_READ_REG(hw, IXGBE_PTC1522);\n\tIXGBE_READ_REG(hw, IXGBE_MPTC);\n\tIXGBE_READ_REG(hw, IXGBE_BPTC);\n\tfor (i = 0; i < 16; i++) {\n\t\tIXGBE_READ_REG(hw, IXGBE_QPRC(i));\n\t\tIXGBE_READ_REG(hw, IXGBE_QPTC(i));\n\t\tif (hw->mac.type >= ixgbe_mac_82599EB) {\n\t\t\tIXGBE_READ_REG(hw, IXGBE_QBRC_L(i));\n\t\t\tIXGBE_READ_REG(hw, IXGBE_QBRC_H(i));\n\t\t\tIXGBE_READ_REG(hw, IXGBE_QBTC_L(i));\n\t\t\tIXGBE_READ_REG(hw, IXGBE_QBTC_H(i));\n\t\t\tIXGBE_READ_REG(hw, IXGBE_QPRDC(i));\n\t\t} else {\n\t\t\tIXGBE_READ_REG(hw, IXGBE_QBRC(i));\n\t\t\tIXGBE_READ_REG(hw, IXGBE_QBTC(i));\n\t\t}\n\t}\n\n\tif (hw->mac.type == ixgbe_mac_X550 || hw->mac.type == ixgbe_mac_X540) {\n\t\tif (hw->phy.id == 0)\n\t\t\thw->phy.ops.identify(hw);\n\t\thw->phy.ops.read_reg(hw, IXGBE_PCRC8ECL, MDIO_MMD_PCS, &i);\n\t\thw->phy.ops.read_reg(hw, IXGBE_PCRC8ECH, MDIO_MMD_PCS, &i);\n\t\thw->phy.ops.read_reg(hw, IXGBE_LDPCECL, MDIO_MMD_PCS, &i);\n\t\thw->phy.ops.read_reg(hw, IXGBE_LDPCECH, MDIO_MMD_PCS, &i);\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,\n\t\t\t\t  u32 pba_num_size)\n{\n\ts32 ret_val;\n\tu16 data;\n\tu16 pba_ptr;\n\tu16 offset;\n\tu16 length;\n\n\tif (pba_num == NULL) {\n\t\thw_dbg(hw, \"PBA string buffer was null\\n\");\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\tret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM0_PTR, &data);\n\tif (ret_val) {\n\t\thw_dbg(hw, \"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM1_PTR, &pba_ptr);\n\tif (ret_val) {\n\t\thw_dbg(hw, \"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tif (data != IXGBE_PBANUM_PTR_GUARD) {\n\t\thw_dbg(hw, \"NVM PBA number is not stored as string\\n\");\n\n\t\t \n\t\tif (pba_num_size < 11) {\n\t\t\thw_dbg(hw, \"PBA string buffer too small\\n\");\n\t\t\treturn IXGBE_ERR_NO_SPACE;\n\t\t}\n\n\t\t \n\t\tpba_num[0] = (data >> 12) & 0xF;\n\t\tpba_num[1] = (data >> 8) & 0xF;\n\t\tpba_num[2] = (data >> 4) & 0xF;\n\t\tpba_num[3] = data & 0xF;\n\t\tpba_num[4] = (pba_ptr >> 12) & 0xF;\n\t\tpba_num[5] = (pba_ptr >> 8) & 0xF;\n\t\tpba_num[6] = '-';\n\t\tpba_num[7] = 0;\n\t\tpba_num[8] = (pba_ptr >> 4) & 0xF;\n\t\tpba_num[9] = pba_ptr & 0xF;\n\n\t\t \n\t\tpba_num[10] = '\\0';\n\n\t\t \n\t\tfor (offset = 0; offset < 10; offset++) {\n\t\t\tif (pba_num[offset] < 0xA)\n\t\t\t\tpba_num[offset] += '0';\n\t\t\telse if (pba_num[offset] < 0x10)\n\t\t\t\tpba_num[offset] += 'A' - 0xA;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret_val = hw->eeprom.ops.read(hw, pba_ptr, &length);\n\tif (ret_val) {\n\t\thw_dbg(hw, \"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tif (length == 0xFFFF || length == 0) {\n\t\thw_dbg(hw, \"NVM PBA number section invalid length\\n\");\n\t\treturn IXGBE_ERR_PBA_SECTION;\n\t}\n\n\t \n\tif (pba_num_size  < (((u32)length * 2) - 1)) {\n\t\thw_dbg(hw, \"PBA string buffer too small\\n\");\n\t\treturn IXGBE_ERR_NO_SPACE;\n\t}\n\n\t \n\tpba_ptr++;\n\tlength--;\n\n\tfor (offset = 0; offset < length; offset++) {\n\t\tret_val = hw->eeprom.ops.read(hw, pba_ptr + offset, &data);\n\t\tif (ret_val) {\n\t\t\thw_dbg(hw, \"NVM Read Error\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tpba_num[offset * 2] = (u8)(data >> 8);\n\t\tpba_num[(offset * 2) + 1] = (u8)(data & 0xFF);\n\t}\n\tpba_num[offset * 2] = '\\0';\n\n\treturn 0;\n}\n\n \ns32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)\n{\n\tu32 rar_high;\n\tu32 rar_low;\n\tu16 i;\n\n\trar_high = IXGBE_READ_REG(hw, IXGBE_RAH(0));\n\trar_low = IXGBE_READ_REG(hw, IXGBE_RAL(0));\n\n\tfor (i = 0; i < 4; i++)\n\t\tmac_addr[i] = (u8)(rar_low >> (i*8));\n\n\tfor (i = 0; i < 2; i++)\n\t\tmac_addr[i+4] = (u8)(rar_high >> (i*8));\n\n\treturn 0;\n}\n\nenum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status)\n{\n\tswitch (link_status & IXGBE_PCI_LINK_WIDTH) {\n\tcase IXGBE_PCI_LINK_WIDTH_1:\n\t\treturn ixgbe_bus_width_pcie_x1;\n\tcase IXGBE_PCI_LINK_WIDTH_2:\n\t\treturn ixgbe_bus_width_pcie_x2;\n\tcase IXGBE_PCI_LINK_WIDTH_4:\n\t\treturn ixgbe_bus_width_pcie_x4;\n\tcase IXGBE_PCI_LINK_WIDTH_8:\n\t\treturn ixgbe_bus_width_pcie_x8;\n\tdefault:\n\t\treturn ixgbe_bus_width_unknown;\n\t}\n}\n\nenum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status)\n{\n\tswitch (link_status & IXGBE_PCI_LINK_SPEED) {\n\tcase IXGBE_PCI_LINK_SPEED_2500:\n\t\treturn ixgbe_bus_speed_2500;\n\tcase IXGBE_PCI_LINK_SPEED_5000:\n\t\treturn ixgbe_bus_speed_5000;\n\tcase IXGBE_PCI_LINK_SPEED_8000:\n\t\treturn ixgbe_bus_speed_8000;\n\tdefault:\n\t\treturn ixgbe_bus_speed_unknown;\n\t}\n}\n\n \ns32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)\n{\n\tu16 link_status;\n\n\thw->bus.type = ixgbe_bus_type_pci_express;\n\n\t \n\tlink_status = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_LINK_STATUS);\n\n\thw->bus.width = ixgbe_convert_bus_width(link_status);\n\thw->bus.speed = ixgbe_convert_bus_speed(link_status);\n\n\thw->mac.ops.set_lan_id(hw);\n\n\treturn 0;\n}\n\n \nvoid ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_bus_info *bus = &hw->bus;\n\tu16 ee_ctrl_4;\n\tu32 reg;\n\n\treg = IXGBE_READ_REG(hw, IXGBE_STATUS);\n\tbus->func = (reg & IXGBE_STATUS_LAN_ID) >> IXGBE_STATUS_LAN_ID_SHIFT;\n\tbus->lan_id = bus->func;\n\n\t \n\treg = IXGBE_READ_REG(hw, IXGBE_FACTPS(hw));\n\tif (reg & IXGBE_FACTPS_LFS)\n\t\tbus->func ^= 0x1;\n\n\t \n\tif (hw->device_id == IXGBE_DEV_ID_X550EM_A_SFP) {\n\t\thw->eeprom.ops.read(hw, IXGBE_EEPROM_CTRL_4, &ee_ctrl_4);\n\t\tbus->instance_id = (ee_ctrl_4 & IXGBE_EE_CTRL_4_INST_ID) >>\n\t\t\t\t   IXGBE_EE_CTRL_4_INST_ID_SHIFT;\n\t}\n}\n\n \ns32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)\n{\n\tu32 reg_val;\n\tu16 i;\n\n\t \n\thw->adapter_stopped = true;\n\n\t \n\thw->mac.ops.disable_rx(hw);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_IRQ_CLEAR_MASK);\n\n\t \n\tIXGBE_READ_REG(hw, IXGBE_EICR);\n\n\t \n\tfor (i = 0; i < hw->mac.max_tx_queues; i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TXDCTL(i), IXGBE_TXDCTL_SWFLSH);\n\n\t \n\tfor (i = 0; i < hw->mac.max_rx_queues; i++) {\n\t\treg_val = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));\n\t\treg_val &= ~IXGBE_RXDCTL_ENABLE;\n\t\treg_val |= IXGBE_RXDCTL_SWFLSH;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RXDCTL(i), reg_val);\n\t}\n\n\t \n\tIXGBE_WRITE_FLUSH(hw);\n\tusleep_range(1000, 2000);\n\n\t \n\treturn ixgbe_disable_pcie_primary(hw);\n}\n\n \ns32 ixgbe_init_led_link_act_generic(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tu32 led_reg, led_mode;\n\tu16 i;\n\n\tled_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tled_mode = led_reg >> IXGBE_LED_MODE_SHIFT(i);\n\n\t\tif ((led_mode & IXGBE_LED_MODE_MASK_BASE) ==\n\t\t    IXGBE_LED_LINK_ACTIVE) {\n\t\t\tmac->led_link_act = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_x550em_a:\n\t\tmac->led_link_act = 0;\n\t\tbreak;\n\tcase ixgbe_mac_X550EM_x:\n\t\tmac->led_link_act = 1;\n\t\tbreak;\n\tdefault:\n\t\tmac->led_link_act = 2;\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index)\n{\n\tu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\n\tif (index > 3)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\tled_reg &= ~IXGBE_LED_MODE_MASK(index);\n\tled_reg |= IXGBE_LED_ON << IXGBE_LED_MODE_SHIFT(index);\n\tIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index)\n{\n\tu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\n\tif (index > 3)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\tled_reg &= ~IXGBE_LED_MODE_MASK(index);\n\tled_reg |= IXGBE_LED_OFF << IXGBE_LED_MODE_SHIFT(index);\n\tIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eec;\n\tu16 eeprom_size;\n\n\tif (eeprom->type == ixgbe_eeprom_uninitialized) {\n\t\teeprom->type = ixgbe_eeprom_none;\n\t\t \n\t\teeprom->semaphore_delay = 10;\n\t\t \n\t\teeprom->word_page_size = 0;\n\n\t\t \n\t\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\t\tif (eec & IXGBE_EEC_PRES) {\n\t\t\teeprom->type = ixgbe_eeprom_spi;\n\n\t\t\t \n\t\t\teeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>\n\t\t\t\t\t    IXGBE_EEC_SIZE_SHIFT);\n\t\t\teeprom->word_size = BIT(eeprom_size +\n\t\t\t\t\t\t IXGBE_EEPROM_WORD_SIZE_SHIFT);\n\t\t}\n\n\t\tif (eec & IXGBE_EEC_ADDR_SIZE)\n\t\t\teeprom->address_bits = 16;\n\t\telse\n\t\t\teeprom->address_bits = 8;\n\t\thw_dbg(hw, \"Eeprom params: type = %d, size = %d, address bits: %d\\n\",\n\t\t       eeprom->type, eeprom->word_size, eeprom->address_bits);\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t       u16 words, u16 *data)\n{\n\ts32 status;\n\tu16 i, count;\n\n\thw->eeprom.ops.init_params(hw);\n\n\tif (words == 0)\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\n\tif (offset + words > hw->eeprom.word_size)\n\t\treturn IXGBE_ERR_EEPROM;\n\n\t \n\tif ((hw->eeprom.word_page_size == 0) &&\n\t    (words > IXGBE_EEPROM_PAGE_SIZE_MAX))\n\t\tixgbe_detect_eeprom_page_size_generic(hw, offset);\n\n\t \n\tfor (i = 0; i < words; i += IXGBE_EEPROM_RD_BUFFER_MAX_COUNT) {\n\t\tcount = (words - i) / IXGBE_EEPROM_RD_BUFFER_MAX_COUNT > 0 ?\n\t\t\t IXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);\n\t\tstatus = ixgbe_write_eeprom_buffer_bit_bang(hw, offset + i,\n\t\t\t\t\t\t\t    count, &data[i]);\n\n\t\tif (status != 0)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t      u16 words, u16 *data)\n{\n\ts32 status;\n\tu16 word;\n\tu16 page_size;\n\tu16 i;\n\tu8 write_opcode = IXGBE_EEPROM_WRITE_OPCODE_SPI;\n\n\t \n\tstatus = ixgbe_acquire_eeprom(hw);\n\tif (status)\n\t\treturn status;\n\n\tif (ixgbe_ready_eeprom(hw) != 0) {\n\t\tixgbe_release_eeprom(hw);\n\t\treturn IXGBE_ERR_EEPROM;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\tixgbe_standby_eeprom(hw);\n\n\t\t \n\t\tixgbe_shift_out_eeprom_bits(hw,\n\t\t\t\t\t    IXGBE_EEPROM_WREN_OPCODE_SPI,\n\t\t\t\t\t    IXGBE_EEPROM_OPCODE_BITS);\n\n\t\tixgbe_standby_eeprom(hw);\n\n\t\t \n\t\tif ((hw->eeprom.address_bits == 8) &&\n\t\t    ((offset + i) >= 128))\n\t\t\twrite_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;\n\n\t\t \n\t\tixgbe_shift_out_eeprom_bits(hw, write_opcode,\n\t\t\t\t\t    IXGBE_EEPROM_OPCODE_BITS);\n\t\tixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),\n\t\t\t\t\t    hw->eeprom.address_bits);\n\n\t\tpage_size = hw->eeprom.word_page_size;\n\n\t\t \n\t\tdo {\n\t\t\tword = data[i];\n\t\t\tword = (word >> 8) | (word << 8);\n\t\t\tixgbe_shift_out_eeprom_bits(hw, word, 16);\n\n\t\t\tif (page_size == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (((offset + i) & (page_size - 1)) ==\n\t\t\t    (page_size - 1))\n\t\t\t\tbreak;\n\t\t} while (++i < words);\n\n\t\tixgbe_standby_eeprom(hw);\n\t\tusleep_range(10000, 20000);\n\t}\n\t \n\tixgbe_release_eeprom(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data)\n{\n\thw->eeprom.ops.init_params(hw);\n\n\tif (offset >= hw->eeprom.word_size)\n\t\treturn IXGBE_ERR_EEPROM;\n\n\treturn ixgbe_write_eeprom_buffer_bit_bang(hw, offset, 1, &data);\n}\n\n \ns32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t      u16 words, u16 *data)\n{\n\ts32 status;\n\tu16 i, count;\n\n\thw->eeprom.ops.init_params(hw);\n\n\tif (words == 0)\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\n\tif (offset + words > hw->eeprom.word_size)\n\t\treturn IXGBE_ERR_EEPROM;\n\n\t \n\tfor (i = 0; i < words; i += IXGBE_EEPROM_RD_BUFFER_MAX_COUNT) {\n\t\tcount = (words - i) / IXGBE_EEPROM_RD_BUFFER_MAX_COUNT > 0 ?\n\t\t\t IXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);\n\n\t\tstatus = ixgbe_read_eeprom_buffer_bit_bang(hw, offset + i,\n\t\t\t\t\t\t\t   count, &data[i]);\n\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t\t     u16 words, u16 *data)\n{\n\ts32 status;\n\tu16 word_in;\n\tu8 read_opcode = IXGBE_EEPROM_READ_OPCODE_SPI;\n\tu16 i;\n\n\t \n\tstatus = ixgbe_acquire_eeprom(hw);\n\tif (status)\n\t\treturn status;\n\n\tif (ixgbe_ready_eeprom(hw) != 0) {\n\t\tixgbe_release_eeprom(hw);\n\t\treturn IXGBE_ERR_EEPROM;\n\t}\n\n\tfor (i = 0; i < words; i++) {\n\t\tixgbe_standby_eeprom(hw);\n\t\t \n\t\tif ((hw->eeprom.address_bits == 8) &&\n\t\t    ((offset + i) >= 128))\n\t\t\tread_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;\n\n\t\t \n\t\tixgbe_shift_out_eeprom_bits(hw, read_opcode,\n\t\t\t\t\t    IXGBE_EEPROM_OPCODE_BITS);\n\t\tixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),\n\t\t\t\t\t    hw->eeprom.address_bits);\n\n\t\t \n\t\tword_in = ixgbe_shift_in_eeprom_bits(hw, 16);\n\t\tdata[i] = (word_in >> 8) | (word_in << 8);\n\t}\n\n\t \n\tixgbe_release_eeprom(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t       u16 *data)\n{\n\thw->eeprom.ops.init_params(hw);\n\n\tif (offset >= hw->eeprom.word_size)\n\t\treturn IXGBE_ERR_EEPROM;\n\n\treturn ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);\n}\n\n \ns32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t   u16 words, u16 *data)\n{\n\tu32 eerd;\n\ts32 status;\n\tu32 i;\n\n\thw->eeprom.ops.init_params(hw);\n\n\tif (words == 0)\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\n\tif (offset >= hw->eeprom.word_size)\n\t\treturn IXGBE_ERR_EEPROM;\n\n\tfor (i = 0; i < words; i++) {\n\t\teerd = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |\n\t\t       IXGBE_EEPROM_RW_REG_START;\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_EERD, eerd);\n\t\tstatus = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_READ);\n\n\t\tif (status == 0) {\n\t\t\tdata[i] = (IXGBE_READ_REG(hw, IXGBE_EERD) >>\n\t\t\t\t   IXGBE_EEPROM_RW_REG_DATA);\n\t\t} else {\n\t\t\thw_dbg(hw, \"Eeprom read timed out\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,\n\t\t\t\t\t\t u16 offset)\n{\n\tu16 data[IXGBE_EEPROM_PAGE_SIZE_MAX];\n\ts32 status;\n\tu16 i;\n\n\tfor (i = 0; i < IXGBE_EEPROM_PAGE_SIZE_MAX; i++)\n\t\tdata[i] = i;\n\n\thw->eeprom.word_page_size = IXGBE_EEPROM_PAGE_SIZE_MAX;\n\tstatus = ixgbe_write_eeprom_buffer_bit_bang(hw, offset,\n\t\t\t\t\t     IXGBE_EEPROM_PAGE_SIZE_MAX, data);\n\thw->eeprom.word_page_size = 0;\n\tif (status)\n\t\treturn status;\n\n\tstatus = ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);\n\tif (status)\n\t\treturn status;\n\n\t \n\thw->eeprom.word_page_size = IXGBE_EEPROM_PAGE_SIZE_MAX - data[0];\n\n\thw_dbg(hw, \"Detected EEPROM page size = %d words.\\n\",\n\t       hw->eeprom.word_page_size);\n\treturn 0;\n}\n\n \ns32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)\n{\n\treturn ixgbe_read_eerd_buffer_generic(hw, offset, 1, data);\n}\n\n \ns32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset,\n\t\t\t\t    u16 words, u16 *data)\n{\n\tu32 eewr;\n\ts32 status;\n\tu16 i;\n\n\thw->eeprom.ops.init_params(hw);\n\n\tif (words == 0)\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\n\tif (offset >= hw->eeprom.word_size)\n\t\treturn IXGBE_ERR_EEPROM;\n\n\tfor (i = 0; i < words; i++) {\n\t\teewr = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |\n\t\t       (data[i] << IXGBE_EEPROM_RW_REG_DATA) |\n\t\t       IXGBE_EEPROM_RW_REG_START;\n\n\t\tstatus = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Eeprom write EEWR timed out\\n\");\n\t\t\treturn status;\n\t\t}\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_EEWR, eewr);\n\n\t\tstatus = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);\n\t\tif (status) {\n\t\t\thw_dbg(hw, \"Eeprom write EEWR timed out\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data)\n{\n\treturn ixgbe_write_eewr_buffer_generic(hw, offset, 1, &data);\n}\n\n \nstatic s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg)\n{\n\tu32 i;\n\tu32 reg;\n\n\tfor (i = 0; i < IXGBE_EERD_EEWR_ATTEMPTS; i++) {\n\t\tif (ee_reg == IXGBE_NVM_POLL_READ)\n\t\t\treg = IXGBE_READ_REG(hw, IXGBE_EERD);\n\t\telse\n\t\t\treg = IXGBE_READ_REG(hw, IXGBE_EEWR);\n\n\t\tif (reg & IXGBE_EEPROM_RW_REG_DONE) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(5);\n\t}\n\treturn IXGBE_ERR_EEPROM;\n}\n\n \nstatic s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw)\n{\n\tu32 eec;\n\tu32 i;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) != 0)\n\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\n\t \n\teec |= IXGBE_EEC_REQ;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\n\tfor (i = 0; i < IXGBE_EEPROM_GRANT_ATTEMPTS; i++) {\n\t\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\t\tif (eec & IXGBE_EEC_GNT)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\t \n\tif (!(eec & IXGBE_EEC_GNT)) {\n\t\teec &= ~IXGBE_EEC_REQ;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\t\thw_dbg(hw, \"Could not acquire EEPROM grant\\n\");\n\n\t\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\t\treturn IXGBE_ERR_EEPROM;\n\t}\n\n\t \n\t \n\teec &= ~(IXGBE_EEC_CS | IXGBE_EEC_SK);\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(1);\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)\n{\n\tu32 timeout = 2000;\n\tu32 i;\n\tu32 swsm;\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\t \n\t\tswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\n\t\tif (!(swsm & IXGBE_SWSM_SMBI))\n\t\t\tbreak;\n\t\tusleep_range(50, 100);\n\t}\n\n\tif (i == timeout) {\n\t\thw_dbg(hw, \"Driver can't access the Eeprom - SMBI Semaphore not granted.\\n\");\n\t\t \n\t\tixgbe_release_eeprom_semaphore(hw);\n\n\t\tusleep_range(50, 100);\n\t\t \n\t\tswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\n\t\tif (swsm & IXGBE_SWSM_SMBI) {\n\t\t\thw_dbg(hw, \"Software semaphore SMBI between device drivers not granted.\\n\");\n\t\t\treturn IXGBE_ERR_EEPROM;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\n\n\t\t \n\t\tswsm |= IXGBE_SWSM_SWESMBI;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);\n\n\t\t \n\t\tswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\n\t\tif (swsm & IXGBE_SWSM_SWESMBI)\n\t\t\tbreak;\n\n\t\tusleep_range(50, 100);\n\t}\n\n\t \n\tif (i >= timeout) {\n\t\thw_dbg(hw, \"SWESMBI Software EEPROM semaphore not granted.\\n\");\n\t\tixgbe_release_eeprom_semaphore(hw);\n\t\treturn IXGBE_ERR_EEPROM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)\n{\n\tu32 swsm;\n\n\tswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\n\n\t \n\tswsm &= ~(IXGBE_SWSM_SWESMBI | IXGBE_SWSM_SMBI);\n\tIXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)\n{\n\tu16 i;\n\tu8 spi_stat_reg;\n\n\t \n\tfor (i = 0; i < IXGBE_EEPROM_MAX_RETRY_SPI; i += 5) {\n\t\tixgbe_shift_out_eeprom_bits(hw, IXGBE_EEPROM_RDSR_OPCODE_SPI,\n\t\t\t\t\t    IXGBE_EEPROM_OPCODE_BITS);\n\t\tspi_stat_reg = (u8)ixgbe_shift_in_eeprom_bits(hw, 8);\n\t\tif (!(spi_stat_reg & IXGBE_EEPROM_STATUS_RDY_SPI))\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t\tixgbe_standby_eeprom(hw);\n\t}\n\n\t \n\tif (i >= IXGBE_EEPROM_MAX_RETRY_SPI) {\n\t\thw_dbg(hw, \"SPI EEPROM Status error\\n\");\n\t\treturn IXGBE_ERR_EEPROM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ixgbe_standby_eeprom(struct ixgbe_hw *hw)\n{\n\tu32 eec;\n\n\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\n\t \n\teec |= IXGBE_EEC_CS;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(1);\n\teec &= ~IXGBE_EEC_CS;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(1);\n}\n\n \nstatic void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,\n\t\t\t\t\tu16 count)\n{\n\tu32 eec;\n\tu32 mask;\n\tu32 i;\n\n\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\n\t \n\tmask = BIT(count - 1);\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (data & mask)\n\t\t\teec |= IXGBE_EEC_DI;\n\t\telse\n\t\t\teec &= ~IXGBE_EEC_DI;\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\t\tIXGBE_WRITE_FLUSH(hw);\n\n\t\tudelay(1);\n\n\t\tixgbe_raise_eeprom_clk(hw, &eec);\n\t\tixgbe_lower_eeprom_clk(hw, &eec);\n\n\t\t \n\t\tmask = mask >> 1;\n\t}\n\n\t \n\teec &= ~IXGBE_EEC_DI;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\tIXGBE_WRITE_FLUSH(hw);\n}\n\n \nstatic u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)\n{\n\tu32 eec;\n\tu32 i;\n\tu16 data = 0;\n\n\t \n\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\n\teec &= ~(IXGBE_EEC_DO | IXGBE_EEC_DI);\n\n\tfor (i = 0; i < count; i++) {\n\t\tdata = data << 1;\n\t\tixgbe_raise_eeprom_clk(hw, &eec);\n\n\t\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\n\t\teec &= ~(IXGBE_EEC_DI);\n\t\tif (eec & IXGBE_EEC_DO)\n\t\t\tdata |= 1;\n\n\t\tixgbe_lower_eeprom_clk(hw, &eec);\n\t}\n\n\treturn data;\n}\n\n \nstatic void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)\n{\n\t \n\t*eec = *eec | IXGBE_EEC_SK;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), *eec);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(1);\n}\n\n \nstatic void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)\n{\n\t \n\t*eec = *eec & ~IXGBE_EEC_SK;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), *eec);\n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(1);\n}\n\n \nstatic void ixgbe_release_eeprom(struct ixgbe_hw *hw)\n{\n\tu32 eec;\n\n\teec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\n\n\teec |= IXGBE_EEC_CS;   \n\teec &= ~IXGBE_EEC_SK;  \n\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tudelay(1);\n\n\t \n\teec &= ~IXGBE_EEC_REQ;\n\tIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\n\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\n\n\t \n\tusleep_range(hw->eeprom.semaphore_delay * 1000,\n\t\t     hw->eeprom.semaphore_delay * 2000);\n}\n\n \ns32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)\n{\n\tu16 i;\n\tu16 j;\n\tu16 checksum = 0;\n\tu16 length = 0;\n\tu16 pointer = 0;\n\tu16 word = 0;\n\n\t \n\tfor (i = 0; i < IXGBE_EEPROM_CHECKSUM; i++) {\n\t\tif (hw->eeprom.ops.read(hw, i, &word)) {\n\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tchecksum += word;\n\t}\n\n\t \n\tfor (i = IXGBE_PCIE_ANALOG_PTR; i < IXGBE_FW_PTR; i++) {\n\t\tif (hw->eeprom.ops.read(hw, i, &pointer)) {\n\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\treturn IXGBE_ERR_EEPROM;\n\t\t}\n\n\t\t \n\t\tif (pointer == 0xFFFF || pointer == 0)\n\t\t\tcontinue;\n\n\t\tif (hw->eeprom.ops.read(hw, pointer, &length)) {\n\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\treturn IXGBE_ERR_EEPROM;\n\t\t}\n\n\t\tif (length == 0xFFFF || length == 0)\n\t\t\tcontinue;\n\n\t\tfor (j = pointer + 1; j <= pointer + length; j++) {\n\t\t\tif (hw->eeprom.ops.read(hw, j, &word)) {\n\t\t\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\t\t\treturn IXGBE_ERR_EEPROM;\n\t\t\t}\n\t\t\tchecksum += word;\n\t\t}\n\t}\n\n\tchecksum = (u16)IXGBE_EEPROM_SUM - checksum;\n\n\treturn (s32)checksum;\n}\n\n \ns32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,\n\t\t\t\t\t   u16 *checksum_val)\n{\n\ts32 status;\n\tu16 checksum;\n\tu16 read_checksum = 0;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, 0, &checksum);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = hw->eeprom.ops.calc_checksum(hw);\n\tif (status < 0)\n\t\treturn status;\n\n\tchecksum = (u16)(status & 0xffff);\n\n\tstatus = hw->eeprom.ops.read(hw, IXGBE_EEPROM_CHECKSUM, &read_checksum);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tif (read_checksum != checksum)\n\t\tstatus = IXGBE_ERR_EEPROM_CHECKSUM;\n\n\t \n\tif (checksum_val)\n\t\t*checksum_val = checksum;\n\n\treturn status;\n}\n\n \ns32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu16 checksum;\n\n\t \n\tstatus = hw->eeprom.ops.read(hw, 0, &checksum);\n\tif (status) {\n\t\thw_dbg(hw, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = hw->eeprom.ops.calc_checksum(hw);\n\tif (status < 0)\n\t\treturn status;\n\n\tchecksum = (u16)(status & 0xffff);\n\n\tstatus = hw->eeprom.ops.write(hw, IXGBE_EEPROM_CHECKSUM, checksum);\n\n\treturn status;\n}\n\n \ns32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,\n\t\t\t  u32 enable_addr)\n{\n\tu32 rar_low, rar_high;\n\tu32 rar_entries = hw->mac.num_rar_entries;\n\n\t \n\tif (index >= rar_entries) {\n\t\thw_dbg(hw, \"RAR index %d is out of range.\\n\", index);\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\t \n\thw->mac.ops.set_vmdq(hw, index, vmdq);\n\n\t \n\trar_low = ((u32)addr[0] |\n\t\t   ((u32)addr[1] << 8) |\n\t\t   ((u32)addr[2] << 16) |\n\t\t   ((u32)addr[3] << 24));\n\t \n\trar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));\n\trar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);\n\trar_high |= ((u32)addr[4] | ((u32)addr[5] << 8));\n\n\tif (enable_addr != 0)\n\t\trar_high |= IXGBE_RAH_AV;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_RAL(index), rar_low);\n\tIXGBE_WRITE_FLUSH(hw);\n\tIXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index)\n{\n\tu32 rar_high;\n\tu32 rar_entries = hw->mac.num_rar_entries;\n\n\t \n\tif (index >= rar_entries) {\n\t\thw_dbg(hw, \"RAR index %d is out of range.\\n\", index);\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\t \n\trar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));\n\trar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);\n\tIXGBE_WRITE_FLUSH(hw);\n\tIXGBE_WRITE_REG(hw, IXGBE_RAL(index), 0);\n\n\t \n\thw->mac.ops.clear_vmdq(hw, index, IXGBE_CLEAR_VMDQ_ALL);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)\n{\n\tu32 i;\n\tu32 rar_entries = hw->mac.num_rar_entries;\n\n\t \n\tif (!is_valid_ether_addr(hw->mac.addr)) {\n\t\t \n\t\thw->mac.ops.get_mac_addr(hw, hw->mac.addr);\n\n\t\thw_dbg(hw, \" Keeping Current RAR0 Addr =%pM\\n\", hw->mac.addr);\n\t} else {\n\t\t \n\t\thw_dbg(hw, \"Overriding MAC Address in RAR[0]\\n\");\n\t\thw_dbg(hw, \" New MAC Addr =%pM\\n\", hw->mac.addr);\n\n\t\thw->mac.ops.set_rar(hw, 0, hw->mac.addr, 0, IXGBE_RAH_AV);\n\t}\n\n\t \n\thw->mac.ops.clear_vmdq(hw, 0, IXGBE_CLEAR_VMDQ_ALL);\n\n\thw->addr_ctrl.overflow_promisc = 0;\n\n\thw->addr_ctrl.rar_used_count = 1;\n\n\t \n\thw_dbg(hw, \"Clearing RAR[1-%d]\\n\", rar_entries - 1);\n\tfor (i = 1; i < rar_entries; i++) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RAL(i), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RAH(i), 0);\n\t}\n\n\t \n\thw->addr_ctrl.mta_in_use = 0;\n\tIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, hw->mac.mc_filter_type);\n\n\thw_dbg(hw, \" Clearing MTA\\n\");\n\tfor (i = 0; i < hw->mac.mcft_size; i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MTA(i), 0);\n\n\tif (hw->mac.ops.init_uta_tables)\n\t\thw->mac.ops.init_uta_tables(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)\n{\n\tu32 vector = 0;\n\n\tswitch (hw->mac.mc_filter_type) {\n\tcase 0:    \n\t\tvector = ((mc_addr[4] >> 4) | (((u16)mc_addr[5]) << 4));\n\t\tbreak;\n\tcase 1:    \n\t\tvector = ((mc_addr[4] >> 3) | (((u16)mc_addr[5]) << 5));\n\t\tbreak;\n\tcase 2:    \n\t\tvector = ((mc_addr[4] >> 2) | (((u16)mc_addr[5]) << 6));\n\t\tbreak;\n\tcase 3:    \n\t\tvector = ((mc_addr[4]) | (((u16)mc_addr[5]) << 8));\n\t\tbreak;\n\tdefault:   \n\t\thw_dbg(hw, \"MC filter type param set incorrectly\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tvector &= 0xFFF;\n\treturn vector;\n}\n\n \nstatic void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)\n{\n\tu32 vector;\n\tu32 vector_bit;\n\tu32 vector_reg;\n\n\thw->addr_ctrl.mta_in_use++;\n\n\tvector = ixgbe_mta_vector(hw, mc_addr);\n\thw_dbg(hw, \" bit-vector = 0x%03X\\n\", vector);\n\n\t \n\tvector_reg = (vector >> 5) & 0x7F;\n\tvector_bit = vector & 0x1F;\n\thw->mac.mta_shadow[vector_reg] |= BIT(vector_bit);\n}\n\n \ns32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct netdev_hw_addr *ha;\n\tu32 i;\n\n\t \n\thw->addr_ctrl.num_mc_addrs = netdev_mc_count(netdev);\n\thw->addr_ctrl.mta_in_use = 0;\n\n\t \n\thw_dbg(hw, \" Clearing MTA\\n\");\n\tmemset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));\n\n\t \n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\thw_dbg(hw, \" Adding the multicast addresses:\\n\");\n\t\tixgbe_set_mta(hw, ha->addr);\n\t}\n\n\t \n\tfor (i = 0; i < hw->mac.mcft_size; i++)\n\t\tIXGBE_WRITE_REG_ARRAY(hw, IXGBE_MTA(0), i,\n\t\t\t\t      hw->mac.mta_shadow[i]);\n\n\tif (hw->addr_ctrl.mta_in_use > 0)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL,\n\t\t\t\tIXGBE_MCSTCTRL_MFE | hw->mac.mc_filter_type);\n\n\thw_dbg(hw, \"ixgbe_update_mc_addr_list_generic Complete\\n\");\n\treturn 0;\n}\n\n \ns32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_addr_filter_info *a = &hw->addr_ctrl;\n\n\tif (a->mta_in_use > 0)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, IXGBE_MCSTCTRL_MFE |\n\t\t\t\thw->mac.mc_filter_type);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_addr_filter_info *a = &hw->addr_ctrl;\n\n\tif (a->mta_in_use > 0)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, hw->mac.mc_filter_type);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)\n{\n\tu32 mflcn_reg, fccfg_reg;\n\tu32 reg;\n\tu32 fcrtl, fcrth;\n\tint i;\n\n\t \n\tif (!hw->fc.pause_time)\n\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\n\t \n\tfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\n\t\tif ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&\n\t\t    hw->fc.high_water[i]) {\n\t\t\tif (!hw->fc.low_water[i] ||\n\t\t\t    hw->fc.low_water[i] >= hw->fc.high_water[i]) {\n\t\t\t\thw_dbg(hw, \"Invalid water mark configuration\\n\");\n\t\t\t\treturn IXGBE_ERR_INVALID_LINK_SETTINGS;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\thw->mac.ops.fc_autoneg(hw);\n\n\t \n\tmflcn_reg = IXGBE_READ_REG(hw, IXGBE_MFLCN);\n\tmflcn_reg &= ~(IXGBE_MFLCN_RPFCE_MASK | IXGBE_MFLCN_RFCE);\n\n\tfccfg_reg = IXGBE_READ_REG(hw, IXGBE_FCCFG);\n\tfccfg_reg &= ~(IXGBE_FCCFG_TFCE_802_3X | IXGBE_FCCFG_TFCE_PRIORITY);\n\n\t \n\tswitch (hw->fc.current_mode) {\n\tcase ixgbe_fc_none:\n\t\t \n\t\tbreak;\n\tcase ixgbe_fc_rx_pause:\n\t\t \n\t\tmflcn_reg |= IXGBE_MFLCN_RFCE;\n\t\tbreak;\n\tcase ixgbe_fc_tx_pause:\n\t\t \n\t\tfccfg_reg |= IXGBE_FCCFG_TFCE_802_3X;\n\t\tbreak;\n\tcase ixgbe_fc_full:\n\t\t \n\t\tmflcn_reg |= IXGBE_MFLCN_RFCE;\n\t\tfccfg_reg |= IXGBE_FCCFG_TFCE_802_3X;\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \"Flow control param set incorrectly\\n\");\n\t\treturn IXGBE_ERR_CONFIG;\n\t}\n\n\t \n\tmflcn_reg |= IXGBE_MFLCN_DPF;\n\tIXGBE_WRITE_REG(hw, IXGBE_MFLCN, mflcn_reg);\n\tIXGBE_WRITE_REG(hw, IXGBE_FCCFG, fccfg_reg);\n\n\t \n\tfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\n\t\tif ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&\n\t\t    hw->fc.high_water[i]) {\n\t\t\tfcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), fcrtl);\n\t\t\tfcrth = (hw->fc.high_water[i] << 10) | IXGBE_FCRTH_FCEN;\n\t\t} else {\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), 0);\n\t\t\t \n\t\t\tfcrth = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i)) - 24576;\n\t\t}\n\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(i), fcrth);\n\t}\n\n\t \n\treg = hw->fc.pause_time * 0x00010001U;\n\tfor (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);\n\n\tIXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg,\n\t\t       u32 adv_sym, u32 adv_asm, u32 lp_sym, u32 lp_asm)\n{\n\tif ((!(adv_reg)) ||  (!(lp_reg)))\n\t\treturn IXGBE_ERR_FC_NOT_NEGOTIATED;\n\n\tif ((adv_reg & adv_sym) && (lp_reg & lp_sym)) {\n\t\t \n\t\tif (hw->fc.requested_mode == ixgbe_fc_full) {\n\t\t\thw->fc.current_mode = ixgbe_fc_full;\n\t\t\thw_dbg(hw, \"Flow Control = FULL.\\n\");\n\t\t} else {\n\t\t\thw->fc.current_mode = ixgbe_fc_rx_pause;\n\t\t\thw_dbg(hw, \"Flow Control=RX PAUSE frames only\\n\");\n\t\t}\n\t} else if (!(adv_reg & adv_sym) && (adv_reg & adv_asm) &&\n\t\t   (lp_reg & lp_sym) && (lp_reg & lp_asm)) {\n\t\thw->fc.current_mode = ixgbe_fc_tx_pause;\n\t\thw_dbg(hw, \"Flow Control = TX PAUSE frames only.\\n\");\n\t} else if ((adv_reg & adv_sym) && (adv_reg & adv_asm) &&\n\t\t   !(lp_reg & lp_sym) && (lp_reg & lp_asm)) {\n\t\thw->fc.current_mode = ixgbe_fc_rx_pause;\n\t\thw_dbg(hw, \"Flow Control = RX PAUSE frames only.\\n\");\n\t} else {\n\t\thw->fc.current_mode = ixgbe_fc_none;\n\t\thw_dbg(hw, \"Flow Control = NONE.\\n\");\n\t}\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)\n{\n\tu32 pcs_anadv_reg, pcs_lpab_reg, linkstat;\n\ts32 ret_val;\n\n\t \n\n\tlinkstat = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);\n\tif ((!!(linkstat & IXGBE_PCS1GLSTA_AN_COMPLETE) == 0) ||\n\t    (!!(linkstat & IXGBE_PCS1GLSTA_AN_TIMED_OUT) == 1))\n\t\treturn IXGBE_ERR_FC_NOT_NEGOTIATED;\n\n\tpcs_anadv_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);\n\tpcs_lpab_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);\n\n\tret_val =  ixgbe_negotiate_fc(hw, pcs_anadv_reg,\n\t\t\t       pcs_lpab_reg, IXGBE_PCS1GANA_SYM_PAUSE,\n\t\t\t       IXGBE_PCS1GANA_ASM_PAUSE,\n\t\t\t       IXGBE_PCS1GANA_SYM_PAUSE,\n\t\t\t       IXGBE_PCS1GANA_ASM_PAUSE);\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)\n{\n\tu32 links2, anlp1_reg, autoc_reg, links;\n\ts32 ret_val;\n\n\t \n\tlinks = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\tif ((links & IXGBE_LINKS_KX_AN_COMP) == 0)\n\t\treturn IXGBE_ERR_FC_NOT_NEGOTIATED;\n\n\tif (hw->mac.type == ixgbe_mac_82599EB) {\n\t\tlinks2 = IXGBE_READ_REG(hw, IXGBE_LINKS2);\n\t\tif ((links2 & IXGBE_LINKS2_AN_SUPPORTED) == 0)\n\t\t\treturn IXGBE_ERR_FC_NOT_NEGOTIATED;\n\t}\n\t \n\tautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tanlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);\n\n\tret_val = ixgbe_negotiate_fc(hw, autoc_reg,\n\t\tanlp1_reg, IXGBE_AUTOC_SYM_PAUSE, IXGBE_AUTOC_ASM_PAUSE,\n\t\tIXGBE_ANLP1_SYM_PAUSE, IXGBE_ANLP1_ASM_PAUSE);\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)\n{\n\tu16 technology_ability_reg = 0;\n\tu16 lp_technology_ability_reg = 0;\n\n\thw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,\n\t\t\t     MDIO_MMD_AN,\n\t\t\t     &technology_ability_reg);\n\thw->phy.ops.read_reg(hw, MDIO_AN_LPA,\n\t\t\t     MDIO_MMD_AN,\n\t\t\t     &lp_technology_ability_reg);\n\n\treturn ixgbe_negotiate_fc(hw, (u32)technology_ability_reg,\n\t\t\t\t  (u32)lp_technology_ability_reg,\n\t\t\t\t  IXGBE_TAF_SYM_PAUSE, IXGBE_TAF_ASM_PAUSE,\n\t\t\t\t  IXGBE_TAF_SYM_PAUSE, IXGBE_TAF_ASM_PAUSE);\n}\n\n \nvoid ixgbe_fc_autoneg(struct ixgbe_hw *hw)\n{\n\ts32 ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;\n\tixgbe_link_speed speed;\n\tbool link_up;\n\n\t \n\tif (hw->fc.disable_fc_autoneg)\n\t\tgoto out;\n\n\thw->mac.ops.check_link(hw, &speed, &link_up, false);\n\tif (!link_up)\n\t\tgoto out;\n\n\tswitch (hw->phy.media_type) {\n\t \n\tcase ixgbe_media_type_fiber:\n\t\tif (speed == IXGBE_LINK_SPEED_1GB_FULL)\n\t\t\tret_val = ixgbe_fc_autoneg_fiber(hw);\n\t\tbreak;\n\n\t \n\tcase ixgbe_media_type_backplane:\n\t\tret_val = ixgbe_fc_autoneg_backplane(hw);\n\t\tbreak;\n\n\t \n\tcase ixgbe_media_type_copper:\n\t\tif (ixgbe_device_supports_autoneg_fc(hw))\n\t\t\tret_val = ixgbe_fc_autoneg_copper(hw);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tif (ret_val == 0) {\n\t\thw->fc.fc_was_autonegged = true;\n\t} else {\n\t\thw->fc.fc_was_autonegged = false;\n\t\thw->fc.current_mode = hw->fc.requested_mode;\n\t}\n}\n\n \nstatic u32 ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw)\n{\n\ts16 devctl2;\n\tu32 pollcnt;\n\n\tdevctl2 = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_CONTROL2);\n\tdevctl2 &= IXGBE_PCIDEVCTRL2_TIMEO_MASK;\n\n\tswitch (devctl2) {\n\tcase IXGBE_PCIDEVCTRL2_65_130ms:\n\t\t pollcnt = 1300;          \n\t\tbreak;\n\tcase IXGBE_PCIDEVCTRL2_260_520ms:\n\t\tpollcnt = 5200;          \n\t\tbreak;\n\tcase IXGBE_PCIDEVCTRL2_1_2s:\n\t\tpollcnt = 20000;         \n\t\tbreak;\n\tcase IXGBE_PCIDEVCTRL2_4_8s:\n\t\tpollcnt = 80000;         \n\t\tbreak;\n\tcase IXGBE_PCIDEVCTRL2_17_34s:\n\t\tpollcnt = 34000;         \n\t\tbreak;\n\tcase IXGBE_PCIDEVCTRL2_50_100us:         \n\tcase IXGBE_PCIDEVCTRL2_1_2ms:            \n\tcase IXGBE_PCIDEVCTRL2_16_32ms:          \n\tcase IXGBE_PCIDEVCTRL2_16_32ms_def:      \n\tdefault:\n\t\tpollcnt = 800;           \n\t\tbreak;\n\t}\n\n\t \n\treturn (pollcnt * 11) / 10;\n}\n\n \nstatic s32 ixgbe_disable_pcie_primary(struct ixgbe_hw *hw)\n{\n\tu32 i, poll;\n\tu16 value;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_CTRL, IXGBE_CTRL_GIO_DIS);\n\n\t \n\tfor (i = 0; i < IXGBE_PCI_PRIMARY_DISABLE_TIMEOUT; i++) {\n\t\tif (IXGBE_READ_REG(hw, IXGBE_CTRL) & IXGBE_CTRL_GIO_DIS)\n\t\t\tbreak;\n\t\tusleep_range(100, 120);\n\t}\n\tif (i >= IXGBE_PCI_PRIMARY_DISABLE_TIMEOUT) {\n\t\thw_dbg(hw, \"GIO disable did not set - requesting resets\\n\");\n\t\tgoto gio_disable_fail;\n\t}\n\n\t \n\tif (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO) ||\n\t    ixgbe_removed(hw->hw_addr))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < IXGBE_PCI_PRIMARY_DISABLE_TIMEOUT; i++) {\n\t\tudelay(100);\n\t\tif (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO))\n\t\t\treturn 0;\n\t}\n\n\t \n\thw_dbg(hw, \"GIO Primary Disable bit didn't clear - requesting resets\\n\");\ngio_disable_fail:\n\thw->mac.flags |= IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\n\n\tif (hw->mac.type >= ixgbe_mac_X550)\n\t\treturn 0;\n\n\t \n\tpoll = ixgbe_pcie_timeout_poll(hw);\n\tfor (i = 0; i < poll; i++) {\n\t\tudelay(100);\n\t\tvalue = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);\n\t\tif (ixgbe_removed(hw->hw_addr))\n\t\t\treturn 0;\n\t\tif (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))\n\t\t\treturn 0;\n\t}\n\n\thw_dbg(hw, \"PCIe transaction pending bit also did not clear.\\n\");\n\treturn IXGBE_ERR_PRIMARY_REQUESTS_PENDING;\n}\n\n \ns32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 gssr = 0;\n\tu32 swmask = mask;\n\tu32 fwmask = mask << 5;\n\tu32 timeout = 200;\n\tu32 i;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\t \n\t\tif (ixgbe_get_eeprom_semaphore(hw))\n\t\t\treturn IXGBE_ERR_SWFW_SYNC;\n\n\t\tgssr = IXGBE_READ_REG(hw, IXGBE_GSSR);\n\t\tif (!(gssr & (fwmask | swmask))) {\n\t\t\tgssr |= swmask;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);\n\t\t\tixgbe_release_eeprom_semaphore(hw);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tixgbe_release_eeprom_semaphore(hw);\n\t\t\tusleep_range(5000, 10000);\n\t\t}\n\t}\n\n\t \n\tif (gssr & (fwmask | swmask))\n\t\tixgbe_release_swfw_sync(hw, gssr & (fwmask | swmask));\n\n\tusleep_range(5000, 10000);\n\treturn IXGBE_ERR_SWFW_SYNC;\n}\n\n \nvoid ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 gssr;\n\tu32 swmask = mask;\n\n\tixgbe_get_eeprom_semaphore(hw);\n\n\tgssr = IXGBE_READ_REG(hw, IXGBE_GSSR);\n\tgssr &= ~swmask;\n\tIXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);\n\n\tixgbe_release_eeprom_semaphore(hw);\n}\n\n \ns32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *locked, u32 *reg_val)\n{\n\t*locked = false;\n\t*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\treturn 0;\n}\n\n \ns32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked)\n{\n\tIXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_val);\n\treturn 0;\n}\n\n \ns32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw)\n{\n#define IXGBE_MAX_SECRX_POLL 40\n\tint i;\n\tint secrxreg;\n\n\tsecrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);\n\tsecrxreg |= IXGBE_SECRXCTRL_RX_DIS;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);\n\tfor (i = 0; i < IXGBE_MAX_SECRX_POLL; i++) {\n\t\tsecrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT);\n\t\tif (secrxreg & IXGBE_SECRXSTAT_SECRX_RDY)\n\t\t\tbreak;\n\t\telse\n\t\t\t \n\t\t\tudelay(1000);\n\t}\n\n\t \n\tif (i >= IXGBE_MAX_SECRX_POLL)\n\t\thw_dbg(hw, \"Rx unit being enabled before security path fully disabled. Continuing with init.\\n\");\n\n\treturn 0;\n\n}\n\n \ns32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw)\n{\n\tu32 secrxreg;\n\n\tsecrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);\n\tsecrxreg &= ~IXGBE_SECRXCTRL_RX_DIS;\n\tIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval)\n{\n\tif (regval & IXGBE_RXCTRL_RXEN)\n\t\thw->mac.ops.enable_rx(hw);\n\telse\n\t\thw->mac.ops.disable_rx(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)\n{\n\tixgbe_link_speed speed = 0;\n\tbool link_up = false;\n\tu32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\n\tu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\tbool locked = false;\n\ts32 ret_val;\n\n\tif (index > 3)\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\thw->mac.ops.check_link(hw, &speed, &link_up, false);\n\n\tif (!link_up) {\n\t\tret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tautoc_reg |= IXGBE_AUTOC_AN_RESTART;\n\t\tautoc_reg |= IXGBE_AUTOC_FLU;\n\n\t\tret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tIXGBE_WRITE_FLUSH(hw);\n\n\t\tusleep_range(10000, 20000);\n\t}\n\n\tled_reg &= ~IXGBE_LED_MODE_MASK(index);\n\tled_reg |= IXGBE_LED_BLINK(index);\n\tIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index)\n{\n\tu32 autoc_reg = 0;\n\tu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\n\tbool locked = false;\n\ts32 ret_val;\n\n\tif (index > 3)\n\t\treturn IXGBE_ERR_PARAM;\n\n\tret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tautoc_reg &= ~IXGBE_AUTOC_FLU;\n\tautoc_reg |= IXGBE_AUTOC_AN_RESTART;\n\n\tret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tled_reg &= ~IXGBE_LED_MODE_MASK(index);\n\tled_reg &= ~IXGBE_LED_BLINK(index);\n\tled_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);\n\tIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,\n\t\t\t\t\tu16 *san_mac_offset)\n{\n\ts32 ret_val;\n\n\t \n\tret_val = hw->eeprom.ops.read(hw, IXGBE_SAN_MAC_ADDR_PTR,\n\t\t\t\t      san_mac_offset);\n\tif (ret_val)\n\t\thw_err(hw, \"eeprom read at offset %d failed\\n\",\n\t\t       IXGBE_SAN_MAC_ADDR_PTR);\n\n\treturn ret_val;\n}\n\n \ns32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)\n{\n\tu16 san_mac_data, san_mac_offset;\n\tu8 i;\n\ts32 ret_val;\n\n\t \n\tret_val = ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);\n\tif (ret_val || san_mac_offset == 0 || san_mac_offset == 0xFFFF)\n\n\t\tgoto san_mac_addr_clr;\n\n\t \n\thw->mac.ops.set_lan_id(hw);\n\t \n\t(hw->bus.func) ? (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT1_OFFSET) :\n\t\t\t (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT0_OFFSET);\n\tfor (i = 0; i < 3; i++) {\n\t\tret_val = hw->eeprom.ops.read(hw, san_mac_offset,\n\t\t\t\t\t      &san_mac_data);\n\t\tif (ret_val) {\n\t\t\thw_err(hw, \"eeprom read at offset %d failed\\n\",\n\t\t\t       san_mac_offset);\n\t\t\tgoto san_mac_addr_clr;\n\t\t}\n\t\tsan_mac_addr[i * 2] = (u8)(san_mac_data);\n\t\tsan_mac_addr[i * 2 + 1] = (u8)(san_mac_data >> 8);\n\t\tsan_mac_offset++;\n\t}\n\treturn 0;\n\nsan_mac_addr_clr:\n\t \n\tfor (i = 0; i < 6; i++)\n\t\tsan_mac_addr[i] = 0xFF;\n\treturn ret_val;\n}\n\n \nu16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)\n{\n\tu16 msix_count;\n\tu16 max_msix_count;\n\tu16 pcie_offset;\n\n\tswitch (hw->mac.type) {\n\tcase ixgbe_mac_82598EB:\n\t\tpcie_offset = IXGBE_PCIE_MSIX_82598_CAPS;\n\t\tmax_msix_count = IXGBE_MAX_MSIX_VECTORS_82598;\n\t\tbreak;\n\tcase ixgbe_mac_82599EB:\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_X550:\n\tcase ixgbe_mac_X550EM_x:\n\tcase ixgbe_mac_x550em_a:\n\t\tpcie_offset = IXGBE_PCIE_MSIX_82599_CAPS;\n\t\tmax_msix_count = IXGBE_MAX_MSIX_VECTORS_82599;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\tmsix_count = ixgbe_read_pci_cfg_word(hw, pcie_offset);\n\tif (ixgbe_removed(hw->hw_addr))\n\t\tmsix_count = 0;\n\tmsix_count &= IXGBE_PCIE_MSIX_TBL_SZ_MASK;\n\n\t \n\tmsix_count++;\n\n\tif (msix_count > max_msix_count)\n\t\tmsix_count = max_msix_count;\n\n\treturn msix_count;\n}\n\n \ns32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\n{\n\tu32 mpsar_lo, mpsar_hi;\n\tu32 rar_entries = hw->mac.num_rar_entries;\n\n\t \n\tif (rar >= rar_entries) {\n\t\thw_dbg(hw, \"RAR index %d is out of range.\\n\", rar);\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\tmpsar_lo = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));\n\tmpsar_hi = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));\n\n\tif (ixgbe_removed(hw->hw_addr))\n\t\treturn 0;\n\n\tif (!mpsar_lo && !mpsar_hi)\n\t\treturn 0;\n\n\tif (vmdq == IXGBE_CLEAR_VMDQ_ALL) {\n\t\tif (mpsar_lo) {\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);\n\t\t\tmpsar_lo = 0;\n\t\t}\n\t\tif (mpsar_hi) {\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);\n\t\t\tmpsar_hi = 0;\n\t\t}\n\t} else if (vmdq < 32) {\n\t\tmpsar_lo &= ~BIT(vmdq);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar_lo);\n\t} else {\n\t\tmpsar_hi &= ~BIT(vmdq - 32);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar_hi);\n\t}\n\n\t \n\tif (mpsar_lo == 0 && mpsar_hi == 0 &&\n\t    rar != 0 && rar != hw->mac.san_mac_rar_index)\n\t\thw->mac.ops.clear_rar(hw, rar);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\n{\n\tu32 mpsar;\n\tu32 rar_entries = hw->mac.num_rar_entries;\n\n\t \n\tif (rar >= rar_entries) {\n\t\thw_dbg(hw, \"RAR index %d is out of range.\\n\", rar);\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\tif (vmdq < 32) {\n\t\tmpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));\n\t\tmpsar |= BIT(vmdq);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar);\n\t} else {\n\t\tmpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));\n\t\tmpsar |= BIT(vmdq - 32);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar);\n\t}\n\treturn 0;\n}\n\n \ns32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq)\n{\n\tu32 rar = hw->mac.san_mac_rar_index;\n\n\tif (vmdq < 32) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), BIT(vmdq));\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);\n\t} else {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), BIT(vmdq - 32));\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw)\n{\n\tint i;\n\n\tfor (i = 0; i < 128; i++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_UTA(i), 0);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan, bool vlvf_bypass)\n{\n\ts32 regindex, first_empty_slot;\n\tu32 bits;\n\n\t \n\tif (vlan == 0)\n\t\treturn 0;\n\n\t \n\tfirst_empty_slot = vlvf_bypass ? IXGBE_ERR_NO_SPACE : 0;\n\n\t \n\tvlan |= IXGBE_VLVF_VIEN;\n\n\t \n\tfor (regindex = IXGBE_VLVF_ENTRIES; --regindex;) {\n\t\tbits = IXGBE_READ_REG(hw, IXGBE_VLVF(regindex));\n\t\tif (bits == vlan)\n\t\t\treturn regindex;\n\t\tif (!first_empty_slot && !bits)\n\t\t\tfirst_empty_slot = regindex;\n\t}\n\n\t \n\tif (!first_empty_slot)\n\t\thw_dbg(hw, \"No space in VLVF.\\n\");\n\n\treturn first_empty_slot ? : IXGBE_ERR_NO_SPACE;\n}\n\n \ns32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,\n\t\t\t   bool vlan_on, bool vlvf_bypass)\n{\n\tu32 regidx, vfta_delta, vfta, bits;\n\ts32 vlvf_index;\n\n\tif ((vlan > 4095) || (vind > 63))\n\t\treturn IXGBE_ERR_PARAM;\n\n\t \n\n\t \n\tregidx = vlan / 32;\n\tvfta_delta = BIT(vlan % 32);\n\tvfta = IXGBE_READ_REG(hw, IXGBE_VFTA(regidx));\n\n\t \n\tvfta_delta &= vlan_on ? ~vfta : vfta;\n\tvfta ^= vfta_delta;\n\n\t \n\tif (!(IXGBE_READ_REG(hw, IXGBE_VT_CTL) & IXGBE_VT_CTL_VT_ENABLE))\n\t\tgoto vfta_update;\n\n\tvlvf_index = ixgbe_find_vlvf_slot(hw, vlan, vlvf_bypass);\n\tif (vlvf_index < 0) {\n\t\tif (vlvf_bypass)\n\t\t\tgoto vfta_update;\n\t\treturn vlvf_index;\n\t}\n\n\tbits = IXGBE_READ_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32));\n\n\t \n\tbits |= BIT(vind % 32);\n\tif (vlan_on)\n\t\tgoto vlvf_update;\n\n\t \n\tbits ^= BIT(vind % 32);\n\n\tif (!bits &&\n\t    !IXGBE_READ_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + 1 - vind / 32))) {\n\t\t \n\t\tif (vfta_delta)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTA(regidx), vfta);\n\n\t\t \n\t\tIXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32), 0);\n\n\t\treturn 0;\n\t}\n\n\t \n\tvfta_delta = 0;\n\nvlvf_update:\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32), bits);\n\tIXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), IXGBE_VLVF_VIEN | vlan);\n\nvfta_update:\n\t \n\tif (vfta_delta)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTA(regidx), vfta);\n\n\treturn 0;\n}\n\n \ns32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)\n{\n\tu32 offset;\n\n\tfor (offset = 0; offset < hw->mac.vft_size; offset++)\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);\n\n\tfor (offset = 0; offset < IXGBE_VLVF_ENTRIES; offset++) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VLVF(offset), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VLVFB(offset * 2), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VLVFB(offset * 2 + 1), 0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool ixgbe_need_crosstalk_fix(struct ixgbe_hw *hw)\n{\n\t \n\tif (!hw->need_crosstalk_fix)\n\t\treturn false;\n\n\t \n\tswitch (hw->mac.ops.get_media_type(hw)) {\n\tcase ixgbe_media_type_fiber:\n\tcase ixgbe_media_type_fiber_qsfp:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \ns32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,\n\t\t\t\t bool *link_up, bool link_up_wait_to_complete)\n{\n\tbool crosstalk_fix_active = ixgbe_need_crosstalk_fix(hw);\n\tu32 links_reg, links_orig;\n\tu32 i;\n\n\t \n\tif (crosstalk_fix_active) {\n\t\tu32 sfp_cage_full;\n\n\t\tswitch (hw->mac.type) {\n\t\tcase ixgbe_mac_82599EB:\n\t\t\tsfp_cage_full = IXGBE_READ_REG(hw, IXGBE_ESDP) &\n\t\t\t\t\tIXGBE_ESDP_SDP2;\n\t\t\tbreak;\n\t\tcase ixgbe_mac_X550EM_x:\n\t\tcase ixgbe_mac_x550em_a:\n\t\t\tsfp_cage_full = IXGBE_READ_REG(hw, IXGBE_ESDP) &\n\t\t\t\t\tIXGBE_ESDP_SDP0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsfp_cage_full = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!sfp_cage_full) {\n\t\t\t*link_up = false;\n\t\t\t*speed = IXGBE_LINK_SPEED_UNKNOWN;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tlinks_orig = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\n\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\n\tif (links_orig != links_reg) {\n\t\thw_dbg(hw, \"LINKS changed from %08X to %08X\\n\",\n\t\t       links_orig, links_reg);\n\t}\n\n\tif (link_up_wait_to_complete) {\n\t\tfor (i = 0; i < IXGBE_LINK_UP_TIME; i++) {\n\t\t\tif (links_reg & IXGBE_LINKS_UP) {\n\t\t\t\t*link_up = true;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t*link_up = false;\n\t\t\t}\n\t\t\tmsleep(100);\n\t\t\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\t\t}\n\t} else {\n\t\tif (links_reg & IXGBE_LINKS_UP) {\n\t\t\tif (crosstalk_fix_active) {\n\t\t\t\t \n\t\t\t\tmdelay(5);\n\t\t\t\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\n\t\t\t\tif (!(links_reg & IXGBE_LINKS_UP)) {\n\t\t\t\t\t*link_up = false;\n\t\t\t\t\t*speed = IXGBE_LINK_SPEED_UNKNOWN;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*link_up = true;\n\t\t} else {\n\t\t\t*link_up = false;\n\t\t}\n\t}\n\n\tswitch (links_reg & IXGBE_LINKS_SPEED_82599) {\n\tcase IXGBE_LINKS_SPEED_10G_82599:\n\t\tif ((hw->mac.type >= ixgbe_mac_X550) &&\n\t\t    (links_reg & IXGBE_LINKS_SPEED_NON_STD))\n\t\t\t*speed = IXGBE_LINK_SPEED_2_5GB_FULL;\n\t\telse\n\t\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t\tbreak;\n\tcase IXGBE_LINKS_SPEED_1G_82599:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\tbreak;\n\tcase IXGBE_LINKS_SPEED_100_82599:\n\t\tif ((hw->mac.type >= ixgbe_mac_X550) &&\n\t\t    (links_reg & IXGBE_LINKS_SPEED_NON_STD))\n\t\t\t*speed = IXGBE_LINK_SPEED_5GB_FULL;\n\t\telse\n\t\t\t*speed = IXGBE_LINK_SPEED_100_FULL;\n\t\tbreak;\n\tcase IXGBE_LINKS_SPEED_10_X550EM_A:\n\t\t*speed = IXGBE_LINK_SPEED_UNKNOWN;\n\t\tif (hw->device_id == IXGBE_DEV_ID_X550EM_A_1G_T ||\n\t\t    hw->device_id == IXGBE_DEV_ID_X550EM_A_1G_T_L) {\n\t\t\t*speed = IXGBE_LINK_SPEED_10_FULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*speed = IXGBE_LINK_SPEED_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,\n\t\t\t\t\tu16 *wwpn_prefix)\n{\n\tu16 offset, caps;\n\tu16 alt_san_mac_blk_offset;\n\n\t \n\t*wwnn_prefix = 0xFFFF;\n\t*wwpn_prefix = 0xFFFF;\n\n\t \n\toffset = IXGBE_ALT_SAN_MAC_ADDR_BLK_PTR;\n\tif (hw->eeprom.ops.read(hw, offset, &alt_san_mac_blk_offset))\n\t\tgoto wwn_prefix_err;\n\n\tif ((alt_san_mac_blk_offset == 0) ||\n\t    (alt_san_mac_blk_offset == 0xFFFF))\n\t\treturn 0;\n\n\t \n\toffset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET;\n\tif (hw->eeprom.ops.read(hw, offset, &caps))\n\t\tgoto wwn_prefix_err;\n\tif (!(caps & IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN))\n\t\treturn 0;\n\n\t \n\toffset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET;\n\tif (hw->eeprom.ops.read(hw, offset, wwnn_prefix))\n\t\thw_err(hw, \"eeprom read at offset %d failed\\n\", offset);\n\n\toffset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET;\n\tif (hw->eeprom.ops.read(hw, offset, wwpn_prefix))\n\t\tgoto wwn_prefix_err;\n\n\treturn 0;\n\nwwn_prefix_err:\n\thw_err(hw, \"eeprom read at offset %d failed\\n\", offset);\n\treturn 0;\n}\n\n \nvoid ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)\n{\n\tint vf_target_reg = vf >> 3;\n\tint vf_target_shift = vf % 8;\n\tu32 pfvfspoof;\n\n\tif (hw->mac.type == ixgbe_mac_82598EB)\n\t\treturn;\n\n\tpfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));\n\tif (enable)\n\t\tpfvfspoof |= BIT(vf_target_shift);\n\telse\n\t\tpfvfspoof &= ~BIT(vf_target_shift);\n\tIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);\n}\n\n \nvoid ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)\n{\n\tint vf_target_reg = vf >> 3;\n\tint vf_target_shift = vf % 8 + IXGBE_SPOOF_VLANAS_SHIFT;\n\tu32 pfvfspoof;\n\n\tif (hw->mac.type == ixgbe_mac_82598EB)\n\t\treturn;\n\n\tpfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));\n\tif (enable)\n\t\tpfvfspoof |= BIT(vf_target_shift);\n\telse\n\t\tpfvfspoof &= ~BIT(vf_target_shift);\n\tIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);\n}\n\n \ns32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps)\n{\n\thw->eeprom.ops.read(hw, IXGBE_DEVICE_CAPS, device_caps);\n\n\treturn 0;\n}\n\n \nvoid ixgbe_set_rxpba_generic(struct ixgbe_hw *hw,\n\t\t\t     int num_pb,\n\t\t\t     u32 headroom,\n\t\t\t     int strategy)\n{\n\tu32 pbsize = hw->mac.rx_pb_size;\n\tint i = 0;\n\tu32 rxpktsize, txpktsize, txpbthresh;\n\n\t \n\tpbsize -= headroom;\n\n\tif (!num_pb)\n\t\tnum_pb = 1;\n\n\t \n\tswitch (strategy) {\n\tcase (PBA_STRATEGY_WEIGHTED):\n\t\t \n\t\trxpktsize = ((pbsize * 5 * 2) / (num_pb * 8));\n\t\tpbsize -= rxpktsize * (num_pb / 2);\n\t\trxpktsize <<= IXGBE_RXPBSIZE_SHIFT;\n\t\tfor (; i < (num_pb / 2); i++)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\n\t\tfallthrough;  \n\tcase (PBA_STRATEGY_EQUAL):\n\t\t \n\t\trxpktsize = (pbsize / (num_pb - i)) << IXGBE_RXPBSIZE_SHIFT;\n\t\tfor (; i < num_pb; i++)\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\ttxpktsize = IXGBE_TXPBSIZE_MAX / num_pb;\n\ttxpbthresh = (txpktsize / 1024) - IXGBE_TXPKT_SIZE_MAX;\n\tfor (i = 0; i < num_pb; i++) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), txpktsize);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), txpbthresh);\n\t}\n\n\t \n\tfor (; i < IXGBE_MAX_PB; i++) {\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), 0);\n\t\tIXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), 0);\n\t}\n}\n\n \nu8 ixgbe_calculate_checksum(u8 *buffer, u32 length)\n{\n\tu32 i;\n\tu8 sum = 0;\n\n\tif (!buffer)\n\t\treturn 0;\n\n\tfor (i = 0; i < length; i++)\n\t\tsum += buffer[i];\n\n\treturn (u8) (0 - sum);\n}\n\n \ns32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 length,\n\t\t       u32 timeout)\n{\n\tu32 hicr, i, fwsts;\n\tu16 dword_len;\n\n\tif (!length || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {\n\t\thw_dbg(hw, \"Buffer length failure buffersize-%d.\\n\", length);\n\t\treturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\n\t}\n\n\t \n\tfwsts = IXGBE_READ_REG(hw, IXGBE_FWSTS);\n\tIXGBE_WRITE_REG(hw, IXGBE_FWSTS, fwsts | IXGBE_FWSTS_FWRI);\n\n\t \n\thicr = IXGBE_READ_REG(hw, IXGBE_HICR);\n\tif (!(hicr & IXGBE_HICR_EN)) {\n\t\thw_dbg(hw, \"IXGBE_HOST_EN bit disabled.\\n\");\n\t\treturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\n\t}\n\n\t \n\tif (length % sizeof(u32)) {\n\t\thw_dbg(hw, \"Buffer length failure, not aligned to dword\");\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\tdword_len = length >> 2;\n\n\t \n\tfor (i = 0; i < dword_len; i++)\n\t\tIXGBE_WRITE_REG_ARRAY(hw, IXGBE_FLEX_MNG,\n\t\t\t\t      i, (__force u32)cpu_to_le32(buffer[i]));\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_HICR, hicr | IXGBE_HICR_C);\n\n\tfor (i = 0; i < timeout; i++) {\n\t\thicr = IXGBE_READ_REG(hw, IXGBE_HICR);\n\t\tif (!(hicr & IXGBE_HICR_C))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\tif ((timeout && i == timeout) ||\n\t    !(IXGBE_READ_REG(hw, IXGBE_HICR) & IXGBE_HICR_SV))\n\t\treturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\n\n\treturn 0;\n}\n\n \ns32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *buffer,\n\t\t\t\t u32 length, u32 timeout,\n\t\t\t\t bool return_data)\n{\n\tu32 hdr_size = sizeof(struct ixgbe_hic_hdr);\n\tstruct ixgbe_hic_hdr *hdr = buffer;\n\tu32 *u32arr = buffer;\n\tu16 buf_len, dword_len;\n\ts32 status;\n\tu32 bi;\n\n\tif (!length || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {\n\t\thw_dbg(hw, \"Buffer length failure buffersize-%d.\\n\", length);\n\t\treturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\n\t}\n\t \n\tstatus = hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_SW_MNG_SM);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ixgbe_hic_unlocked(hw, buffer, length, timeout);\n\tif (status)\n\t\tgoto rel_out;\n\n\tif (!return_data)\n\t\tgoto rel_out;\n\n\t \n\tdword_len = hdr_size >> 2;\n\n\t \n\tfor (bi = 0; bi < dword_len; bi++) {\n\t\tu32arr[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);\n\t\tle32_to_cpus(&u32arr[bi]);\n\t}\n\n\t \n\tbuf_len = hdr->buf_len;\n\tif (!buf_len)\n\t\tgoto rel_out;\n\n\tif (length < round_up(buf_len, 4) + hdr_size) {\n\t\thw_dbg(hw, \"Buffer not large enough for reply message.\\n\");\n\t\tstatus = IXGBE_ERR_HOST_INTERFACE_COMMAND;\n\t\tgoto rel_out;\n\t}\n\n\t \n\tdword_len = (buf_len + 3) >> 2;\n\n\t \n\tfor (; bi <= dword_len; bi++) {\n\t\tu32arr[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);\n\t\tle32_to_cpus(&u32arr[bi]);\n\t}\n\nrel_out:\n\thw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_SW_MNG_SM);\n\n\treturn status;\n}\n\n \ns32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,\n\t\t\t\t u8 build, u8 sub, __always_unused u16 len,\n\t\t\t\t __always_unused const char *driver_ver)\n{\n\tstruct ixgbe_hic_drv_info fw_cmd;\n\tint i;\n\ts32 ret_val;\n\n\tfw_cmd.hdr.cmd = FW_CEM_CMD_DRIVER_INFO;\n\tfw_cmd.hdr.buf_len = FW_CEM_CMD_DRIVER_INFO_LEN;\n\tfw_cmd.hdr.cmd_or_resp.cmd_resv = FW_CEM_CMD_RESERVED;\n\tfw_cmd.port_num = hw->bus.func;\n\tfw_cmd.ver_maj = maj;\n\tfw_cmd.ver_min = min;\n\tfw_cmd.ver_build = build;\n\tfw_cmd.ver_sub = sub;\n\tfw_cmd.hdr.checksum = 0;\n\tfw_cmd.pad = 0;\n\tfw_cmd.pad2 = 0;\n\tfw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&fw_cmd,\n\t\t\t\t(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));\n\n\tfor (i = 0; i <= FW_CEM_MAX_RETRIES; i++) {\n\t\tret_val = ixgbe_host_interface_command(hw, &fw_cmd,\n\t\t\t\t\t\t       sizeof(fw_cmd),\n\t\t\t\t\t\t       IXGBE_HI_COMMAND_TIMEOUT,\n\t\t\t\t\t\t       true);\n\t\tif (ret_val != 0)\n\t\t\tcontinue;\n\n\t\tif (fw_cmd.hdr.cmd_or_resp.ret_status ==\n\t\t    FW_CEM_RESP_STATUS_SUCCESS)\n\t\t\tret_val = 0;\n\t\telse\n\t\t\tret_val = IXGBE_ERR_HOST_INTERFACE_COMMAND;\n\n\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\n \nvoid ixgbe_clear_tx_pending(struct ixgbe_hw *hw)\n{\n\tu32 gcr_ext, hlreg0, i, poll;\n\tu16 value;\n\n\t \n\tif (!(hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED))\n\t\treturn;\n\n\t \n\thlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);\n\tIXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0 | IXGBE_HLREG0_LPBK);\n\n\t \n\tIXGBE_WRITE_FLUSH(hw);\n\tusleep_range(3000, 6000);\n\n\t \n\tpoll = ixgbe_pcie_timeout_poll(hw);\n\tfor (i = 0; i < poll; i++) {\n\t\tusleep_range(100, 200);\n\t\tvalue = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);\n\t\tif (ixgbe_removed(hw->hw_addr))\n\t\t\tbreak;\n\t\tif (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))\n\t\t\tbreak;\n\t}\n\n\t \n\tgcr_ext = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);\n\tIXGBE_WRITE_REG(hw, IXGBE_GCR_EXT,\n\t\t\tgcr_ext | IXGBE_GCR_EXT_BUFFERS_CLEAR);\n\n\t \n\tIXGBE_WRITE_FLUSH(hw);\n\tudelay(20);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr_ext);\n\tIXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);\n}\n\nstatic const u8 ixgbe_emc_temp_data[4] = {\n\tIXGBE_EMC_INTERNAL_DATA,\n\tIXGBE_EMC_DIODE1_DATA,\n\tIXGBE_EMC_DIODE2_DATA,\n\tIXGBE_EMC_DIODE3_DATA\n};\nstatic const u8 ixgbe_emc_therm_limit[4] = {\n\tIXGBE_EMC_INTERNAL_THERM_LIMIT,\n\tIXGBE_EMC_DIODE1_THERM_LIMIT,\n\tIXGBE_EMC_DIODE2_THERM_LIMIT,\n\tIXGBE_EMC_DIODE3_THERM_LIMIT\n};\n\n \nstatic s32 ixgbe_get_ets_data(struct ixgbe_hw *hw, u16 *ets_cfg,\n\t\t\t      u16 *ets_offset)\n{\n\ts32 status;\n\n\tstatus = hw->eeprom.ops.read(hw, IXGBE_ETS_CFG, ets_offset);\n\tif (status)\n\t\treturn status;\n\n\tif ((*ets_offset == 0x0000) || (*ets_offset == 0xFFFF))\n\t\treturn IXGBE_NOT_IMPLEMENTED;\n\n\tstatus = hw->eeprom.ops.read(hw, *ets_offset, ets_cfg);\n\tif (status)\n\t\treturn status;\n\n\tif ((*ets_cfg & IXGBE_ETS_TYPE_MASK) != IXGBE_ETS_TYPE_EMC_SHIFTED)\n\t\treturn IXGBE_NOT_IMPLEMENTED;\n\n\treturn 0;\n}\n\n \ns32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu16 ets_offset;\n\tu16 ets_cfg;\n\tu16 ets_sensor;\n\tu8  num_sensors;\n\tu8  i;\n\tstruct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\n\n\t \n\tif ((IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1))\n\t\treturn IXGBE_NOT_IMPLEMENTED;\n\n\tstatus = ixgbe_get_ets_data(hw, &ets_cfg, &ets_offset);\n\tif (status)\n\t\treturn status;\n\n\tnum_sensors = (ets_cfg & IXGBE_ETS_NUM_SENSORS_MASK);\n\tif (num_sensors > IXGBE_MAX_SENSORS)\n\t\tnum_sensors = IXGBE_MAX_SENSORS;\n\n\tfor (i = 0; i < num_sensors; i++) {\n\t\tu8  sensor_index;\n\t\tu8  sensor_location;\n\n\t\tstatus = hw->eeprom.ops.read(hw, (ets_offset + 1 + i),\n\t\t\t\t\t     &ets_sensor);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tsensor_index = ((ets_sensor & IXGBE_ETS_DATA_INDEX_MASK) >>\n\t\t\t\tIXGBE_ETS_DATA_INDEX_SHIFT);\n\t\tsensor_location = ((ets_sensor & IXGBE_ETS_DATA_LOC_MASK) >>\n\t\t\t\t   IXGBE_ETS_DATA_LOC_SHIFT);\n\n\t\tif (sensor_location != 0) {\n\t\t\tstatus = hw->phy.ops.read_i2c_byte(hw,\n\t\t\t\t\tixgbe_emc_temp_data[sensor_index],\n\t\t\t\t\tIXGBE_I2C_THERMAL_SENSOR_ADDR,\n\t\t\t\t\t&data->sensor[i].temp);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \ns32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw)\n{\n\ts32 status;\n\tu16 ets_offset;\n\tu16 ets_cfg;\n\tu16 ets_sensor;\n\tu8  low_thresh_delta;\n\tu8  num_sensors;\n\tu8  therm_limit;\n\tu8  i;\n\tstruct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\n\n\tmemset(data, 0, sizeof(struct ixgbe_thermal_sensor_data));\n\n\t \n\tif ((IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1))\n\t\treturn IXGBE_NOT_IMPLEMENTED;\n\n\tstatus = ixgbe_get_ets_data(hw, &ets_cfg, &ets_offset);\n\tif (status)\n\t\treturn status;\n\n\tlow_thresh_delta = ((ets_cfg & IXGBE_ETS_LTHRES_DELTA_MASK) >>\n\t\t\t     IXGBE_ETS_LTHRES_DELTA_SHIFT);\n\tnum_sensors = (ets_cfg & IXGBE_ETS_NUM_SENSORS_MASK);\n\tif (num_sensors > IXGBE_MAX_SENSORS)\n\t\tnum_sensors = IXGBE_MAX_SENSORS;\n\n\tfor (i = 0; i < num_sensors; i++) {\n\t\tu8  sensor_index;\n\t\tu8  sensor_location;\n\n\t\tif (hw->eeprom.ops.read(hw, ets_offset + 1 + i, &ets_sensor)) {\n\t\t\thw_err(hw, \"eeprom read at offset %d failed\\n\",\n\t\t\t       ets_offset + 1 + i);\n\t\t\tcontinue;\n\t\t}\n\t\tsensor_index = ((ets_sensor & IXGBE_ETS_DATA_INDEX_MASK) >>\n\t\t\t\tIXGBE_ETS_DATA_INDEX_SHIFT);\n\t\tsensor_location = ((ets_sensor & IXGBE_ETS_DATA_LOC_MASK) >>\n\t\t\t\t   IXGBE_ETS_DATA_LOC_SHIFT);\n\t\ttherm_limit = ets_sensor & IXGBE_ETS_DATA_HTHRESH_MASK;\n\n\t\thw->phy.ops.write_i2c_byte(hw,\n\t\t\tixgbe_emc_therm_limit[sensor_index],\n\t\t\tIXGBE_I2C_THERMAL_SENSOR_ADDR, therm_limit);\n\n\t\tif (sensor_location == 0)\n\t\t\tcontinue;\n\n\t\tdata->sensor[i].location = sensor_location;\n\t\tdata->sensor[i].caution_thresh = therm_limit;\n\t\tdata->sensor[i].max_op_thresh = therm_limit - low_thresh_delta;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ixgbe_get_orom_version(struct ixgbe_hw *hw,\n\t\t\t    struct ixgbe_nvm_version *nvm_ver)\n{\n\tu16 offset, eeprom_cfg_blkh, eeprom_cfg_blkl;\n\n\tnvm_ver->or_valid = false;\n\t \n\thw->eeprom.ops.read(hw, NVM_OROM_OFFSET, &offset);\n\n\t \n\tif (offset == 0x0 || offset == NVM_INVALID_PTR)\n\t\treturn;\n\n\thw->eeprom.ops.read(hw, offset + NVM_OROM_BLK_HI, &eeprom_cfg_blkh);\n\thw->eeprom.ops.read(hw, offset + NVM_OROM_BLK_LOW, &eeprom_cfg_blkl);\n\n\t \n\tif ((eeprom_cfg_blkl | eeprom_cfg_blkh) == 0x0 ||\n\t    eeprom_cfg_blkl == NVM_VER_INVALID ||\n\t    eeprom_cfg_blkh == NVM_VER_INVALID)\n\t\treturn;\n\n\tnvm_ver->or_valid = true;\n\tnvm_ver->or_major = eeprom_cfg_blkl >> NVM_OROM_SHIFT;\n\tnvm_ver->or_build = (eeprom_cfg_blkl << NVM_OROM_SHIFT) |\n\t\t\t    (eeprom_cfg_blkh >> NVM_OROM_SHIFT);\n\tnvm_ver->or_patch = eeprom_cfg_blkh & NVM_OROM_PATCH_MASK;\n}\n\n \nvoid ixgbe_get_oem_prod_version(struct ixgbe_hw *hw,\n\t\t\t\tstruct ixgbe_nvm_version *nvm_ver)\n{\n\tu16 rel_num, prod_ver, mod_len, cap, offset;\n\n\tnvm_ver->oem_valid = false;\n\thw->eeprom.ops.read(hw, NVM_OEM_PROD_VER_PTR, &offset);\n\n\t \n\tif (offset == 0x0 || offset == NVM_INVALID_PTR)\n\t\treturn;\n\n\t \n\thw->eeprom.ops.read(hw, offset, &mod_len);\n\thw->eeprom.ops.read(hw, offset + NVM_OEM_PROD_VER_CAP_OFF, &cap);\n\n\t \n\tif (mod_len != NVM_OEM_PROD_VER_MOD_LEN ||\n\t    (cap & NVM_OEM_PROD_VER_CAP_MASK) != 0x0)\n\t\treturn;\n\n\thw->eeprom.ops.read(hw, offset + NVM_OEM_PROD_VER_OFF_L, &prod_ver);\n\thw->eeprom.ops.read(hw, offset + NVM_OEM_PROD_VER_OFF_H, &rel_num);\n\n\t \n\tif ((rel_num | prod_ver) == 0x0 ||\n\t    rel_num == NVM_VER_INVALID || prod_ver == NVM_VER_INVALID)\n\t\treturn;\n\n\tnvm_ver->oem_major = prod_ver >> NVM_VER_SHIFT;\n\tnvm_ver->oem_minor = prod_ver & NVM_VER_MASK;\n\tnvm_ver->oem_release = rel_num;\n\tnvm_ver->oem_valid = true;\n}\n\n \nvoid ixgbe_get_etk_id(struct ixgbe_hw *hw,\n\t\t      struct ixgbe_nvm_version *nvm_ver)\n{\n\tu16 etk_id_l, etk_id_h;\n\n\tif (hw->eeprom.ops.read(hw, NVM_ETK_OFF_LOW, &etk_id_l))\n\t\tetk_id_l = NVM_VER_INVALID;\n\tif (hw->eeprom.ops.read(hw, NVM_ETK_OFF_HI, &etk_id_h))\n\t\tetk_id_h = NVM_VER_INVALID;\n\n\t \n\tif ((etk_id_h & NVM_ETK_VALID) == 0) {\n\t\tnvm_ver->etk_id = etk_id_h;\n\t\tnvm_ver->etk_id |= (etk_id_l << NVM_ETK_SHIFT);\n\t} else {\n\t\tnvm_ver->etk_id = etk_id_l;\n\t\tnvm_ver->etk_id |= (etk_id_h << NVM_ETK_SHIFT);\n\t}\n}\n\nvoid ixgbe_disable_rx_generic(struct ixgbe_hw *hw)\n{\n\tu32 rxctrl;\n\n\trxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\n\tif (rxctrl & IXGBE_RXCTRL_RXEN) {\n\t\tif (hw->mac.type != ixgbe_mac_82598EB) {\n\t\t\tu32 pfdtxgswc;\n\n\t\t\tpfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);\n\t\t\tif (pfdtxgswc & IXGBE_PFDTXGSWC_VT_LBEN) {\n\t\t\t\tpfdtxgswc &= ~IXGBE_PFDTXGSWC_VT_LBEN;\n\t\t\t\tIXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);\n\t\t\t\thw->mac.set_lben = true;\n\t\t\t} else {\n\t\t\t\thw->mac.set_lben = false;\n\t\t\t}\n\t\t}\n\t\trxctrl &= ~IXGBE_RXCTRL_RXEN;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl);\n\t}\n}\n\nvoid ixgbe_enable_rx_generic(struct ixgbe_hw *hw)\n{\n\tu32 rxctrl;\n\n\trxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\n\tIXGBE_WRITE_REG(hw, IXGBE_RXCTRL, (rxctrl | IXGBE_RXCTRL_RXEN));\n\n\tif (hw->mac.type != ixgbe_mac_82598EB) {\n\t\tif (hw->mac.set_lben) {\n\t\t\tu32 pfdtxgswc;\n\n\t\t\tpfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);\n\t\t\tpfdtxgswc |= IXGBE_PFDTXGSWC_VT_LBEN;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);\n\t\t\thw->mac.set_lben = false;\n\t\t}\n\t}\n}\n\n \nbool ixgbe_mng_present(struct ixgbe_hw *hw)\n{\n\tu32 fwsm;\n\n\tif (hw->mac.type < ixgbe_mac_82599EB)\n\t\treturn false;\n\n\tfwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));\n\n\treturn !!(fwsm & IXGBE_FWSM_FW_MODE_PT);\n}\n\n \ns32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,\n\t\t\t\t\t  ixgbe_link_speed speed,\n\t\t\t\t\t  bool autoneg_wait_to_complete)\n{\n\tixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;\n\tixgbe_link_speed highest_link_speed = IXGBE_LINK_SPEED_UNKNOWN;\n\ts32 status = 0;\n\tu32 speedcnt = 0;\n\tu32 i = 0;\n\tbool autoneg, link_up = false;\n\n\t \n\tstatus = hw->mac.ops.get_link_capabilities(hw, &link_speed, &autoneg);\n\tif (status)\n\t\treturn status;\n\n\tspeed &= link_speed;\n\n\t \n\tif (speed & IXGBE_LINK_SPEED_10GB_FULL) {\n\t\tspeedcnt++;\n\t\thighest_link_speed = IXGBE_LINK_SPEED_10GB_FULL;\n\n\t\t \n\t\tswitch (hw->phy.media_type) {\n\t\tcase ixgbe_media_type_fiber:\n\t\t\thw->mac.ops.set_rate_select_speed(hw,\n\t\t\t\t\t\t    IXGBE_LINK_SPEED_10GB_FULL);\n\t\t\tbreak;\n\t\tcase ixgbe_media_type_fiber_qsfp:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\thw_dbg(hw, \"Unexpected media type\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmsleep(40);\n\n\t\tstatus = hw->mac.ops.setup_mac_link(hw,\n\t\t\t\t\t\t    IXGBE_LINK_SPEED_10GB_FULL,\n\t\t\t\t\t\t    autoneg_wait_to_complete);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\t \n\t\tif (hw->mac.ops.flap_tx_laser)\n\t\t\thw->mac.ops.flap_tx_laser(hw);\n\n\t\t \n\t\tfor (i = 0; i < 5; i++) {\n\t\t\t \n\t\t\tmsleep(100);\n\n\t\t\t \n\t\t\tstatus = hw->mac.ops.check_link(hw, &link_speed,\n\t\t\t\t\t\t\t&link_up, false);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\n\t\t\tif (link_up)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (speed & IXGBE_LINK_SPEED_1GB_FULL) {\n\t\tspeedcnt++;\n\t\tif (highest_link_speed == IXGBE_LINK_SPEED_UNKNOWN)\n\t\t\thighest_link_speed = IXGBE_LINK_SPEED_1GB_FULL;\n\n\t\t \n\t\tswitch (hw->phy.media_type) {\n\t\tcase ixgbe_media_type_fiber:\n\t\t\thw->mac.ops.set_rate_select_speed(hw,\n\t\t\t\t\t\t     IXGBE_LINK_SPEED_1GB_FULL);\n\t\t\tbreak;\n\t\tcase ixgbe_media_type_fiber_qsfp:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\thw_dbg(hw, \"Unexpected media type\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmsleep(40);\n\n\t\tstatus = hw->mac.ops.setup_mac_link(hw,\n\t\t\t\t\t\t    IXGBE_LINK_SPEED_1GB_FULL,\n\t\t\t\t\t\t    autoneg_wait_to_complete);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\t \n\t\tif (hw->mac.ops.flap_tx_laser)\n\t\t\thw->mac.ops.flap_tx_laser(hw);\n\n\t\t \n\t\tmsleep(100);\n\n\t\t \n\t\tstatus = hw->mac.ops.check_link(hw, &link_speed, &link_up,\n\t\t\t\t\t\tfalse);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (link_up)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (speedcnt > 1)\n\t\tstatus = ixgbe_setup_mac_link_multispeed_fiber(hw,\n\t\t\t\t\t\t      highest_link_speed,\n\t\t\t\t\t\t      autoneg_wait_to_complete);\n\nout:\n\t \n\thw->phy.autoneg_advertised = 0;\n\n\tif (speed & IXGBE_LINK_SPEED_10GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;\n\n\tif (speed & IXGBE_LINK_SPEED_1GB_FULL)\n\t\thw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;\n\n\treturn status;\n}\n\n \nvoid ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,\n\t\t\t\t      ixgbe_link_speed speed)\n{\n\ts32 status;\n\tu8 rs, eeprom_data;\n\n\tswitch (speed) {\n\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\t\t \n\t\trs = IXGBE_SFF_SOFT_RS_SELECT_10G;\n\t\tbreak;\n\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\trs = IXGBE_SFF_SOFT_RS_SELECT_1G;\n\t\tbreak;\n\tdefault:\n\t\thw_dbg(hw, \"Invalid fixed module speed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tstatus = hw->phy.ops.read_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,\n\t\t\t\t\t   IXGBE_I2C_EEPROM_DEV_ADDR2,\n\t\t\t\t\t   &eeprom_data);\n\tif (status) {\n\t\thw_dbg(hw, \"Failed to read Rx Rate Select RS0\\n\");\n\t\treturn;\n\t}\n\n\teeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) | rs;\n\n\tstatus = hw->phy.ops.write_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,\n\t\t\t\t\t    IXGBE_I2C_EEPROM_DEV_ADDR2,\n\t\t\t\t\t    eeprom_data);\n\tif (status) {\n\t\thw_dbg(hw, \"Failed to write Rx Rate Select RS0\\n\");\n\t\treturn;\n\t}\n\n\t \n\tstatus = hw->phy.ops.read_i2c_byte(hw, IXGBE_SFF_SFF_8472_ESCB,\n\t\t\t\t\t   IXGBE_I2C_EEPROM_DEV_ADDR2,\n\t\t\t\t\t   &eeprom_data);\n\tif (status) {\n\t\thw_dbg(hw, \"Failed to read Rx Rate Select RS1\\n\");\n\t\treturn;\n\t}\n\n\teeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) | rs;\n\n\tstatus = hw->phy.ops.write_i2c_byte(hw, IXGBE_SFF_SFF_8472_ESCB,\n\t\t\t\t\t    IXGBE_I2C_EEPROM_DEV_ADDR2,\n\t\t\t\t\t    eeprom_data);\n\tif (status) {\n\t\thw_dbg(hw, \"Failed to write Rx Rate Select RS1\\n\");\n\t\treturn;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}