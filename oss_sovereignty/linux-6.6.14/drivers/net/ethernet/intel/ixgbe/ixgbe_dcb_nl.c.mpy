{
  "module_name": "ixgbe_dcb_nl.c",
  "hash_id": "9a3ec161b5f360eb6280b19f3ae2b709ad7bf2bfc0889bf4a57d54e9cf4bdcd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c",
  "human_readable_source": "\n \n\n#include \"ixgbe.h\"\n#include <linux/dcbnl.h>\n#include \"ixgbe_dcb_82598.h\"\n#include \"ixgbe_dcb_82599.h\"\n#include \"ixgbe_sriov.h\"\n\n \n#define BIT_PFC\t\t0x02\n#define BIT_PG_RX\t0x04\n#define BIT_PG_TX\t0x08\n#define BIT_APP_UPCHG\t0x10\n\n \n#define DCB_HW_CHG_RST  0   \n#define DCB_NO_HW_CHG   1   \n#define DCB_HW_CHG      2   \n\nstatic int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)\n{\n\tstruct ixgbe_dcb_config *scfg = &adapter->temp_dcb_cfg;\n\tstruct ixgbe_dcb_config *dcfg = &adapter->dcb_cfg;\n\tstruct tc_configuration *src = NULL;\n\tstruct tc_configuration *dst = NULL;\n\tint i, j;\n\tint tx = DCB_TX_CONFIG;\n\tint rx = DCB_RX_CONFIG;\n\tint changes = 0;\n#ifdef IXGBE_FCOE\n\tstruct dcb_app app = {\n\t\t\t      .selector = DCB_APP_IDTYPE_ETHTYPE,\n\t\t\t      .protocol = ETH_P_FCOE,\n\t\t\t     };\n\tu8 up = dcb_getapp(adapter->netdev, &app);\n\n\tif (up && !(up & BIT(adapter->fcoe.up)))\n\t\tchanges |= BIT_APP_UPCHG;\n#endif\n\n\tfor (i = DCB_PG_ATTR_TC_0; i < tc_max + DCB_PG_ATTR_TC_0; i++) {\n\t\tsrc = &scfg->tc_config[i - DCB_PG_ATTR_TC_0];\n\t\tdst = &dcfg->tc_config[i - DCB_PG_ATTR_TC_0];\n\n\t\tif (dst->path[tx].prio_type != src->path[tx].prio_type) {\n\t\t\tdst->path[tx].prio_type = src->path[tx].prio_type;\n\t\t\tchanges |= BIT_PG_TX;\n\t\t}\n\n\t\tif (dst->path[tx].bwg_id != src->path[tx].bwg_id) {\n\t\t\tdst->path[tx].bwg_id = src->path[tx].bwg_id;\n\t\t\tchanges |= BIT_PG_TX;\n\t\t}\n\n\t\tif (dst->path[tx].bwg_percent != src->path[tx].bwg_percent) {\n\t\t\tdst->path[tx].bwg_percent = src->path[tx].bwg_percent;\n\t\t\tchanges |= BIT_PG_TX;\n\t\t}\n\n\t\tif (dst->path[tx].up_to_tc_bitmap !=\n\t\t\t\tsrc->path[tx].up_to_tc_bitmap) {\n\t\t\tdst->path[tx].up_to_tc_bitmap =\n\t\t\t\tsrc->path[tx].up_to_tc_bitmap;\n\t\t\tchanges |= (BIT_PG_TX | BIT_PFC | BIT_APP_UPCHG);\n\t\t}\n\n\t\tif (dst->path[rx].prio_type != src->path[rx].prio_type) {\n\t\t\tdst->path[rx].prio_type = src->path[rx].prio_type;\n\t\t\tchanges |= BIT_PG_RX;\n\t\t}\n\n\t\tif (dst->path[rx].bwg_id != src->path[rx].bwg_id) {\n\t\t\tdst->path[rx].bwg_id = src->path[rx].bwg_id;\n\t\t\tchanges |= BIT_PG_RX;\n\t\t}\n\n\t\tif (dst->path[rx].bwg_percent != src->path[rx].bwg_percent) {\n\t\t\tdst->path[rx].bwg_percent = src->path[rx].bwg_percent;\n\t\t\tchanges |= BIT_PG_RX;\n\t\t}\n\n\t\tif (dst->path[rx].up_to_tc_bitmap !=\n\t\t\t\tsrc->path[rx].up_to_tc_bitmap) {\n\t\t\tdst->path[rx].up_to_tc_bitmap =\n\t\t\t\tsrc->path[rx].up_to_tc_bitmap;\n\t\t\tchanges |= (BIT_PG_RX | BIT_PFC | BIT_APP_UPCHG);\n\t\t}\n\t}\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i < DCB_PG_ATTR_BW_ID_MAX; i++) {\n\t\tj = i - DCB_PG_ATTR_BW_ID_0;\n\t\tif (dcfg->bw_percentage[tx][j] != scfg->bw_percentage[tx][j]) {\n\t\t\tdcfg->bw_percentage[tx][j] = scfg->bw_percentage[tx][j];\n\t\t\tchanges |= BIT_PG_TX;\n\t\t}\n\t\tif (dcfg->bw_percentage[rx][j] != scfg->bw_percentage[rx][j]) {\n\t\t\tdcfg->bw_percentage[rx][j] = scfg->bw_percentage[rx][j];\n\t\t\tchanges |= BIT_PG_RX;\n\t\t}\n\t}\n\n\tfor (i = DCB_PFC_UP_ATTR_0; i < DCB_PFC_UP_ATTR_MAX; i++) {\n\t\tj = i - DCB_PFC_UP_ATTR_0;\n\t\tif (dcfg->tc_config[j].dcb_pfc != scfg->tc_config[j].dcb_pfc) {\n\t\t\tdcfg->tc_config[j].dcb_pfc = scfg->tc_config[j].dcb_pfc;\n\t\t\tchanges |= BIT_PFC;\n\t\t}\n\t}\n\n\tif (dcfg->pfc_mode_enable != scfg->pfc_mode_enable) {\n\t\tdcfg->pfc_mode_enable = scfg->pfc_mode_enable;\n\t\tchanges |= BIT_PFC;\n\t}\n\n\treturn changes;\n}\n\nstatic u8 ixgbe_dcbnl_get_state(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\treturn !!(adapter->flags & IXGBE_FLAG_DCB_ENABLED);\n}\n\nstatic u8 ixgbe_dcbnl_set_state(struct net_device *netdev, u8 state)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn 1;\n\n\t \n\tif (!state == !(adapter->flags & IXGBE_FLAG_DCB_ENABLED))\n\t\treturn 0;\n\n\treturn !!ixgbe_setup_tc(netdev,\n\t\t\t\tstate ? adapter->dcb_cfg.num_tcs.pg_tcs : 0);\n}\n\nstatic void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev,\n\t\t\t\t\t u8 *perm_addr)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tint i, j;\n\n\tmemset(perm_addr, 0xff, MAX_ADDR_LEN);\n\n\tfor (i = 0; i < netdev->addr_len; i++)\n\t\tperm_addr[i] = adapter->hw.mac.perm_addr[i];\n\n\tswitch (adapter->hw.mac.type) {\n\tcase ixgbe_mac_82599EB:\n\tcase ixgbe_mac_X540:\n\tcase ixgbe_mac_X550:\n\t\tfor (j = 0; j < netdev->addr_len; j++, i++)\n\t\t\tperm_addr[i] = adapter->hw.mac.san_addr[j];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ixgbe_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev, int tc,\n\t\t\t\t\t u8 prio, u8 bwg_id, u8 bw_pct,\n\t\t\t\t\t u8 up_map)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (prio != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[0].prio_type = prio;\n\tif (bwg_id != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_id = bwg_id;\n\tif (bw_pct != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_percent =\n\t\t\tbw_pct;\n\tif (up_map != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap =\n\t\t\tup_map;\n}\n\nstatic void ixgbe_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev, int bwg_id,\n\t\t\t\t\t  u8 bw_pct)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->temp_dcb_cfg.bw_percentage[0][bwg_id] = bw_pct;\n}\n\nstatic void ixgbe_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev, int tc,\n\t\t\t\t\t u8 prio, u8 bwg_id, u8 bw_pct,\n\t\t\t\t\t u8 up_map)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (prio != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[1].prio_type = prio;\n\tif (bwg_id != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_id = bwg_id;\n\tif (bw_pct != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_percent =\n\t\t\tbw_pct;\n\tif (up_map != DCB_ATTR_VALUE_UNDEFINED)\n\t\tadapter->temp_dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap =\n\t\t\tup_map;\n}\n\nstatic void ixgbe_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id,\n\t\t\t\t\t  u8 bw_pct)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->temp_dcb_cfg.bw_percentage[1][bwg_id] = bw_pct;\n}\n\nstatic void ixgbe_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev, int tc,\n\t\t\t\t\t u8 *prio, u8 *bwg_id, u8 *bw_pct,\n\t\t\t\t\t u8 *up_map)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t*prio = adapter->dcb_cfg.tc_config[tc].path[0].prio_type;\n\t*bwg_id = adapter->dcb_cfg.tc_config[tc].path[0].bwg_id;\n\t*bw_pct = adapter->dcb_cfg.tc_config[tc].path[0].bwg_percent;\n\t*up_map = adapter->dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap;\n}\n\nstatic void ixgbe_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev, int bwg_id,\n\t\t\t\t\t  u8 *bw_pct)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t*bw_pct = adapter->dcb_cfg.bw_percentage[0][bwg_id];\n}\n\nstatic void ixgbe_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev, int tc,\n\t\t\t\t\t u8 *prio, u8 *bwg_id, u8 *bw_pct,\n\t\t\t\t\t u8 *up_map)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t*prio = adapter->dcb_cfg.tc_config[tc].path[1].prio_type;\n\t*bwg_id = adapter->dcb_cfg.tc_config[tc].path[1].bwg_id;\n\t*bw_pct = adapter->dcb_cfg.tc_config[tc].path[1].bwg_percent;\n\t*up_map = adapter->dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap;\n}\n\nstatic void ixgbe_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id,\n\t\t\t\t\t  u8 *bw_pct)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t*bw_pct = adapter->dcb_cfg.bw_percentage[1][bwg_id];\n}\n\nstatic void ixgbe_dcbnl_set_pfc_cfg(struct net_device *netdev, int priority,\n\t\t\t\t    u8 setting)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->temp_dcb_cfg.tc_config[priority].dcb_pfc = setting;\n\tif (adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc !=\n\t    adapter->dcb_cfg.tc_config[priority].dcb_pfc)\n\t\tadapter->temp_dcb_cfg.pfc_mode_enable = true;\n}\n\nstatic void ixgbe_dcbnl_get_pfc_cfg(struct net_device *netdev, int priority,\n\t\t\t\t    u8 *setting)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\t*setting = adapter->dcb_cfg.tc_config[priority].dcb_pfc;\n}\n\nstatic void ixgbe_dcbnl_devreset(struct net_device *dev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\n\twhile (test_and_set_bit(__IXGBE_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (netif_running(dev))\n\t\tdev->netdev_ops->ndo_stop(dev);\n\n\tixgbe_clear_interrupt_scheme(adapter);\n\tixgbe_init_interrupt_scheme(adapter);\n\n\tif (netif_running(dev))\n\t\tdev->netdev_ops->ndo_open(dev);\n\n\tclear_bit(__IXGBE_RESETTING, &adapter->state);\n}\n\nstatic u8 ixgbe_dcbnl_set_all(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_dcb_config *dcb_cfg = &adapter->dcb_cfg;\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tint ret = DCB_NO_HW_CHG;\n\tint i;\n\n\t \n\tif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn DCB_NO_HW_CHG;\n\n\tadapter->dcb_set_bitmap |= ixgbe_copy_dcb_cfg(adapter,\n\t\t\t\t\t\t      MAX_TRAFFIC_CLASS);\n\tif (!adapter->dcb_set_bitmap)\n\t\treturn DCB_NO_HW_CHG;\n\n\tif (adapter->dcb_set_bitmap & (BIT_PG_TX|BIT_PG_RX)) {\n\t\tu16 refill[MAX_TRAFFIC_CLASS], max[MAX_TRAFFIC_CLASS];\n\t\tu8 bwg_id[MAX_TRAFFIC_CLASS], prio_type[MAX_TRAFFIC_CLASS];\n\t\t \n\t\tu8 prio_tc[MAX_USER_PRIORITY];\n\t\tint max_frame = adapter->netdev->mtu + ETH_HLEN + ETH_FCS_LEN;\n\n#ifdef IXGBE_FCOE\n\t\tif (adapter->netdev->features & NETIF_F_FCOE_MTU)\n\t\t\tmax_frame = max(max_frame, IXGBE_FCOE_JUMBO_FRAME_SIZE);\n#endif\n\n\t\tixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame,\n\t\t\t\t\t       DCB_TX_CONFIG);\n\t\tixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame,\n\t\t\t\t\t       DCB_RX_CONFIG);\n\n\t\tixgbe_dcb_unpack_refill(dcb_cfg, DCB_TX_CONFIG, refill);\n\t\tixgbe_dcb_unpack_max(dcb_cfg, max);\n\t\tixgbe_dcb_unpack_bwgid(dcb_cfg, DCB_TX_CONFIG, bwg_id);\n\t\tixgbe_dcb_unpack_prio(dcb_cfg, DCB_TX_CONFIG, prio_type);\n\t\tixgbe_dcb_unpack_map(dcb_cfg, DCB_TX_CONFIG, prio_tc);\n\n\t\tixgbe_dcb_hw_ets_config(hw, refill, max, bwg_id,\n\t\t\t\t\tprio_type, prio_tc);\n\n\t\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\t\tnetdev_set_prio_tc_map(netdev, i, prio_tc[i]);\n\n\t\tret = DCB_HW_CHG_RST;\n\t}\n\n\tif (adapter->dcb_set_bitmap & BIT_PFC) {\n\t\tif (dcb_cfg->pfc_mode_enable) {\n\t\t\tu8 pfc_en;\n\t\t\tu8 prio_tc[MAX_USER_PRIORITY];\n\n\t\t\tixgbe_dcb_unpack_map(dcb_cfg, DCB_TX_CONFIG, prio_tc);\n\t\t\tixgbe_dcb_unpack_pfc(dcb_cfg, &pfc_en);\n\t\t\tixgbe_dcb_hw_pfc_config(hw, pfc_en, prio_tc);\n\t\t} else {\n\t\t\thw->mac.ops.fc_enable(hw);\n\t\t}\n\n\t\tixgbe_set_rx_drop_en(adapter);\n\n\t\tret = DCB_HW_CHG;\n\t}\n\n#ifdef IXGBE_FCOE\n\t \n\tif (adapter->dcb_set_bitmap & BIT_APP_UPCHG) {\n\t\tstruct dcb_app app = {\n\t\t\t\t      .selector = DCB_APP_IDTYPE_ETHTYPE,\n\t\t\t\t      .protocol = ETH_P_FCOE,\n\t\t\t\t     };\n\t\tu8 up = dcb_getapp(netdev, &app);\n\n\t\tadapter->fcoe.up = ffs(up) - 1;\n\t\tixgbe_dcbnl_devreset(netdev);\n\t\tret = DCB_HW_CHG_RST;\n\t}\n#endif\n\n\tadapter->dcb_set_bitmap = 0x00;\n\treturn ret;\n}\n\nstatic u8 ixgbe_dcbnl_getcap(struct net_device *netdev, int capid, u8 *cap)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PG:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_UP2TC:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PG_TCS:\n\t\t*cap = 0x80;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 0x80;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_GSP:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_BCN:\n\t\t*cap = false;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = adapter->dcbx_cap;\n\t\tbreak;\n\tdefault:\n\t\t*cap = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->flags & IXGBE_FLAG_DCB_ENABLED) {\n\t\tswitch (tcid) {\n\t\tcase DCB_NUMTCS_ATTR_PG:\n\t\t\t*num = adapter->dcb_cfg.num_tcs.pg_tcs;\n\t\t\tbreak;\n\t\tcase DCB_NUMTCS_ATTR_PFC:\n\t\t\t*num = adapter->dcb_cfg.num_tcs.pfc_tcs;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)\n{\n\treturn -EINVAL;\n}\n\nstatic u8 ixgbe_dcbnl_getpfcstate(struct net_device *netdev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->dcb_cfg.pfc_mode_enable;\n}\n\nstatic void ixgbe_dcbnl_setpfcstate(struct net_device *netdev, u8 state)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->temp_dcb_cfg.pfc_mode_enable = state;\n}\n\n \nstatic int ixgbe_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(netdev);\n\tstruct dcb_app app = {\n\t\t\t\t.selector = idtype,\n\t\t\t\t.protocol = id,\n\t\t\t     };\n\n\tif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn -EINVAL;\n\n\treturn dcb_getapp(netdev, &app);\n}\n\nstatic int ixgbe_dcbnl_ieee_getets(struct net_device *dev,\n\t\t\t\t   struct ieee_ets *ets)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ieee_ets *my_ets = adapter->ixgbe_ieee_ets;\n\n\tets->ets_cap = adapter->dcb_cfg.num_tcs.pg_tcs;\n\n\t \n\tif (!my_ets)\n\t\treturn 0;\n\n\tets->cbs = my_ets->cbs;\n\tmemcpy(ets->tc_tx_bw, my_ets->tc_tx_bw, sizeof(ets->tc_tx_bw));\n\tmemcpy(ets->tc_rx_bw, my_ets->tc_rx_bw, sizeof(ets->tc_rx_bw));\n\tmemcpy(ets->tc_tsa, my_ets->tc_tsa, sizeof(ets->tc_tsa));\n\tmemcpy(ets->prio_tc, my_ets->prio_tc, sizeof(ets->prio_tc));\n\treturn 0;\n}\n\nstatic int ixgbe_dcbnl_ieee_setets(struct net_device *dev,\n\t\t\t\t   struct ieee_ets *ets)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tint max_frame = dev->mtu + ETH_HLEN + ETH_FCS_LEN;\n\tint i, err;\n\t__u8 max_tc = 0;\n\t__u8 map_chg = 0;\n\n\tif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tif (!adapter->ixgbe_ieee_ets) {\n\t\tadapter->ixgbe_ieee_ets = kmalloc(sizeof(struct ieee_ets),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!adapter->ixgbe_ieee_ets)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\t\tadapter->ixgbe_ieee_ets->prio_tc[i] =\n\t\t\t\tIEEE_8021QAZ_MAX_TCS;\n\t\t \n\t\tixgbe_dcb_read_rtrup2tc(&adapter->hw,\n\t\t\t\t\tadapter->ixgbe_ieee_ets->prio_tc);\n\t}\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tif (ets->prio_tc[i] > max_tc)\n\t\t\tmax_tc = ets->prio_tc[i];\n\t\tif (ets->prio_tc[i] != adapter->ixgbe_ieee_ets->prio_tc[i])\n\t\t\tmap_chg = 1;\n\t}\n\n\tmemcpy(adapter->ixgbe_ieee_ets, ets, sizeof(*adapter->ixgbe_ieee_ets));\n\n\tif (max_tc)\n\t\tmax_tc++;\n\n\tif (max_tc > adapter->dcb_cfg.num_tcs.pg_tcs)\n\t\treturn -EINVAL;\n\n\tif (max_tc != adapter->hw_tcs) {\n\t\terr = ixgbe_setup_tc(dev, max_tc);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (map_chg) {\n\t\tixgbe_dcbnl_devreset(dev);\n\t}\n\n\treturn ixgbe_dcb_hw_ets(&adapter->hw, ets, max_frame);\n}\n\nstatic int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev,\n\t\t\t\t   struct ieee_pfc *pfc)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ieee_pfc *my_pfc = adapter->ixgbe_ieee_pfc;\n\tint i;\n\n\tpfc->pfc_cap = adapter->dcb_cfg.num_tcs.pfc_tcs;\n\n\t \n\tif (!my_pfc)\n\t\treturn 0;\n\n\tpfc->pfc_en = my_pfc->pfc_en;\n\tpfc->mbc = my_pfc->mbc;\n\tpfc->delay = my_pfc->delay;\n\n\tfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\n\t\tpfc->requests[i] = adapter->stats.pxoffrxc[i];\n\t\tpfc->indications[i] = adapter->stats.pxofftxc[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_dcbnl_ieee_setpfc(struct net_device *dev,\n\t\t\t\t   struct ieee_pfc *pfc)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu8 *prio_tc;\n\tint err;\n\n\tif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tif (!adapter->ixgbe_ieee_pfc) {\n\t\tadapter->ixgbe_ieee_pfc = kmalloc(sizeof(struct ieee_pfc),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!adapter->ixgbe_ieee_pfc)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tprio_tc = adapter->ixgbe_ieee_ets->prio_tc;\n\tmemcpy(adapter->ixgbe_ieee_pfc, pfc, sizeof(*adapter->ixgbe_ieee_pfc));\n\n\t \n\tif (pfc->pfc_en)\n\t\terr = ixgbe_dcb_hw_pfc_config(hw, pfc->pfc_en, prio_tc);\n\telse\n\t\terr = hw->mac.ops.fc_enable(hw);\n\n\tixgbe_set_rx_drop_en(adapter);\n\n\treturn err;\n}\n\nstatic int ixgbe_dcbnl_ieee_setapp(struct net_device *dev,\n\t\t\t\t   struct dcb_app *app)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tint err;\n\n\tif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\terr = dcb_ieee_setapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n#ifdef IXGBE_FCOE\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\n\t    app->protocol == ETH_P_FCOE) {\n\t\tu8 app_mask = dcb_ieee_getapp_mask(dev, app);\n\n\t\tif (app_mask & BIT(adapter->fcoe.up))\n\t\t\treturn 0;\n\n\t\tadapter->fcoe.up = app->priority;\n\t\tixgbe_dcbnl_devreset(dev);\n\t}\n#endif\n\n\t \n\tif (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\n\t    app->protocol == 0) {\n\t\tint vf;\n\n\t\tadapter->default_up = app->priority;\n\n\t\tfor (vf = 0; vf < adapter->num_vfs; vf++) {\n\t\t\tstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\n\n\t\t\tif (!vfinfo->pf_qos)\n\t\t\t\tixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\n\t\t\t\t\t\tapp->priority, vf);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbe_dcbnl_ieee_delapp(struct net_device *dev,\n\t\t\t\t   struct dcb_app *app)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tint err;\n\n\tif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\terr = dcb_ieee_delapp(dev, app);\n\n#ifdef IXGBE_FCOE\n\tif (!err && app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\n\t    app->protocol == ETH_P_FCOE) {\n\t\tu8 app_mask = dcb_ieee_getapp_mask(dev, app);\n\n\t\tif (app_mask & BIT(adapter->fcoe.up))\n\t\t\treturn 0;\n\n\t\tadapter->fcoe.up = app_mask ?\n\t\t\t\t   ffs(app_mask) - 1 : IXGBE_FCOE_DEFTC;\n\t\tixgbe_dcbnl_devreset(dev);\n\t}\n#endif\n\t \n\tif (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\n\t    app->protocol == 0 && adapter->default_up == app->priority) {\n\t\tint vf;\n\t\tlong unsigned int app_mask = dcb_ieee_getapp_mask(dev, app);\n\t\tint qos = app_mask ? find_first_bit(&app_mask, 8) : 0;\n\n\t\tadapter->default_up = qos;\n\n\t\tfor (vf = 0; vf < adapter->num_vfs; vf++) {\n\t\t\tstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\n\n\t\t\tif (!vfinfo->pf_qos)\n\t\t\t\tixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\n\t\t\t\t\t\tqos, vf);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic u8 ixgbe_dcbnl_getdcbx(struct net_device *dev)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\treturn adapter->dcbx_cap;\n}\n\nstatic u8 ixgbe_dcbnl_setdcbx(struct net_device *dev, u8 mode)\n{\n\tstruct ixgbe_adapter *adapter = netdev_priv(dev);\n\tstruct ieee_ets ets = {0};\n\tstruct ieee_pfc pfc = {0};\n\tint err = 0;\n\n\t \n\tif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    ((mode & DCB_CAP_DCBX_VER_IEEE) && (mode & DCB_CAP_DCBX_VER_CEE)) ||\n\t    !(mode & DCB_CAP_DCBX_HOST))\n\t\treturn 1;\n\n\tif (mode == adapter->dcbx_cap)\n\t\treturn 0;\n\n\tadapter->dcbx_cap = mode;\n\n\t \n\tets.ets_cap = 8;\n\tpfc.pfc_cap = 8;\n\n\tif (mode & DCB_CAP_DCBX_VER_IEEE) {\n\t\tixgbe_dcbnl_ieee_setets(dev, &ets);\n\t\tixgbe_dcbnl_ieee_setpfc(dev, &pfc);\n\t} else if (mode & DCB_CAP_DCBX_VER_CEE) {\n\t\tu8 mask = BIT_PFC | BIT_PG_TX | BIT_PG_RX | BIT_APP_UPCHG;\n\n\t\tadapter->dcb_set_bitmap |= mask;\n\t\tixgbe_dcbnl_set_all(dev);\n\t} else {\n\t\t \n\t\tixgbe_dcbnl_ieee_setets(dev, &ets);\n\t\tixgbe_dcbnl_ieee_setpfc(dev, &pfc);\n\t\terr = ixgbe_setup_tc(dev, 0);\n\t}\n\n\treturn err ? 1 : 0;\n}\n\nconst struct dcbnl_rtnl_ops ixgbe_dcbnl_ops = {\n\t.ieee_getets\t= ixgbe_dcbnl_ieee_getets,\n\t.ieee_setets\t= ixgbe_dcbnl_ieee_setets,\n\t.ieee_getpfc\t= ixgbe_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t= ixgbe_dcbnl_ieee_setpfc,\n\t.ieee_setapp\t= ixgbe_dcbnl_ieee_setapp,\n\t.ieee_delapp\t= ixgbe_dcbnl_ieee_delapp,\n\t.getstate\t= ixgbe_dcbnl_get_state,\n\t.setstate\t= ixgbe_dcbnl_set_state,\n\t.getpermhwaddr\t= ixgbe_dcbnl_get_perm_hw_addr,\n\t.setpgtccfgtx\t= ixgbe_dcbnl_set_pg_tc_cfg_tx,\n\t.setpgbwgcfgtx\t= ixgbe_dcbnl_set_pg_bwg_cfg_tx,\n\t.setpgtccfgrx\t= ixgbe_dcbnl_set_pg_tc_cfg_rx,\n\t.setpgbwgcfgrx\t= ixgbe_dcbnl_set_pg_bwg_cfg_rx,\n\t.getpgtccfgtx\t= ixgbe_dcbnl_get_pg_tc_cfg_tx,\n\t.getpgbwgcfgtx\t= ixgbe_dcbnl_get_pg_bwg_cfg_tx,\n\t.getpgtccfgrx\t= ixgbe_dcbnl_get_pg_tc_cfg_rx,\n\t.getpgbwgcfgrx\t= ixgbe_dcbnl_get_pg_bwg_cfg_rx,\n\t.setpfccfg\t= ixgbe_dcbnl_set_pfc_cfg,\n\t.getpfccfg\t= ixgbe_dcbnl_get_pfc_cfg,\n\t.setall\t\t= ixgbe_dcbnl_set_all,\n\t.getcap\t\t= ixgbe_dcbnl_getcap,\n\t.getnumtcs\t= ixgbe_dcbnl_getnumtcs,\n\t.setnumtcs\t= ixgbe_dcbnl_setnumtcs,\n\t.getpfcstate\t= ixgbe_dcbnl_getpfcstate,\n\t.setpfcstate\t= ixgbe_dcbnl_setpfcstate,\n\t.getapp\t\t= ixgbe_dcbnl_getapp,\n\t.getdcbx\t= ixgbe_dcbnl_getdcbx,\n\t.setdcbx\t= ixgbe_dcbnl_setdcbx,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}