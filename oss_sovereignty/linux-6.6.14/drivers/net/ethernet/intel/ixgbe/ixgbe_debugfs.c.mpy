{
  "module_name": "ixgbe_debugfs.c",
  "hash_id": "e4da6302bc22ec7b3e1f476d9dd799b39ea26add099ccb254c806a9c448f9c33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\n#include \"ixgbe.h\"\n\nstatic struct dentry *ixgbe_dbg_root;\n\nstatic char ixgbe_dbg_reg_ops_buf[256] = \"\";\n\nstatic ssize_t ixgbe_dbg_common_ops_read(struct file *filp, char __user *buffer,\n\t\t\t\t\t size_t count, loff_t *ppos,\n\t\t\t\t\t char *dbg_buf)\n{\n\tstruct ixgbe_adapter *adapter = filp->private_data;\n\tchar *buf;\n\tint len;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tbuf = kasprintf(GFP_KERNEL, \"%s: %s\\n\",\n\t\t\tadapter->netdev->name, dbg_buf);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (count < strlen(buf)) {\n\t\tkfree(buf);\n\t\treturn -ENOSPC;\n\t}\n\n\tlen = simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));\n\n\tkfree(buf);\n\treturn len;\n}\n\n \nstatic ssize_t ixgbe_dbg_reg_ops_read(struct file *filp, char __user *buffer,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\treturn ixgbe_dbg_common_ops_read(filp, buffer, count, ppos,\n\t\t\t\t\t ixgbe_dbg_reg_ops_buf);\n}\n\n \nstatic ssize_t ixgbe_dbg_reg_ops_write(struct file *filp,\n\t\t\t\t     const char __user *buffer,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ixgbe_adapter *adapter = filp->private_data;\n\tint len;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\tif (count >= sizeof(ixgbe_dbg_reg_ops_buf))\n\t\treturn -ENOSPC;\n\n\tlen = simple_write_to_buffer(ixgbe_dbg_reg_ops_buf,\n\t\t\t\t     sizeof(ixgbe_dbg_reg_ops_buf)-1,\n\t\t\t\t     ppos,\n\t\t\t\t     buffer,\n\t\t\t\t     count);\n\tif (len < 0)\n\t\treturn len;\n\n\tixgbe_dbg_reg_ops_buf[len] = '\\0';\n\n\tif (strncmp(ixgbe_dbg_reg_ops_buf, \"write\", 5) == 0) {\n\t\tu32 reg, value;\n\t\tint cnt;\n\t\tcnt = sscanf(&ixgbe_dbg_reg_ops_buf[5], \"%x %x\", &reg, &value);\n\t\tif (cnt == 2) {\n\t\t\tIXGBE_WRITE_REG(&adapter->hw, reg, value);\n\t\t\tvalue = IXGBE_READ_REG(&adapter->hw, reg);\n\t\t\te_dev_info(\"write: 0x%08x = 0x%08x\\n\", reg, value);\n\t\t} else {\n\t\t\te_dev_info(\"write <reg> <value>\\n\");\n\t\t}\n\t} else if (strncmp(ixgbe_dbg_reg_ops_buf, \"read\", 4) == 0) {\n\t\tu32 reg, value;\n\t\tint cnt;\n\t\tcnt = sscanf(&ixgbe_dbg_reg_ops_buf[4], \"%x\", &reg);\n\t\tif (cnt == 1) {\n\t\t\tvalue = IXGBE_READ_REG(&adapter->hw, reg);\n\t\t\te_dev_info(\"read 0x%08x = 0x%08x\\n\", reg, value);\n\t\t} else {\n\t\t\te_dev_info(\"read <reg>\\n\");\n\t\t}\n\t} else {\n\t\te_dev_info(\"Unknown command %s\\n\", ixgbe_dbg_reg_ops_buf);\n\t\te_dev_info(\"Available commands:\\n\");\n\t\te_dev_info(\"   read <reg>\\n\");\n\t\te_dev_info(\"   write <reg> <value>\\n\");\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations ixgbe_dbg_reg_ops_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read =  ixgbe_dbg_reg_ops_read,\n\t.write = ixgbe_dbg_reg_ops_write,\n};\n\nstatic char ixgbe_dbg_netdev_ops_buf[256] = \"\";\n\n \nstatic ssize_t ixgbe_dbg_netdev_ops_read(struct file *filp, char __user *buffer,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn ixgbe_dbg_common_ops_read(filp, buffer, count, ppos,\n\t\t\t\t\t ixgbe_dbg_netdev_ops_buf);\n}\n\n \nstatic ssize_t ixgbe_dbg_netdev_ops_write(struct file *filp,\n\t\t\t\t\t  const char __user *buffer,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ixgbe_adapter *adapter = filp->private_data;\n\tint len;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\tif (count >= sizeof(ixgbe_dbg_netdev_ops_buf))\n\t\treturn -ENOSPC;\n\n\tlen = simple_write_to_buffer(ixgbe_dbg_netdev_ops_buf,\n\t\t\t\t     sizeof(ixgbe_dbg_netdev_ops_buf)-1,\n\t\t\t\t     ppos,\n\t\t\t\t     buffer,\n\t\t\t\t     count);\n\tif (len < 0)\n\t\treturn len;\n\n\tixgbe_dbg_netdev_ops_buf[len] = '\\0';\n\n\tif (strncmp(ixgbe_dbg_netdev_ops_buf, \"tx_timeout\", 10) == 0) {\n\t\t \n\t\tadapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev,\n\t\t\t\t\t\t\t    UINT_MAX);\n\t\te_dev_info(\"tx_timeout called\\n\");\n\t} else {\n\t\te_dev_info(\"Unknown command: %s\\n\", ixgbe_dbg_netdev_ops_buf);\n\t\te_dev_info(\"Available commands:\\n\");\n\t\te_dev_info(\"    tx_timeout\\n\");\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations ixgbe_dbg_netdev_ops_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = ixgbe_dbg_netdev_ops_read,\n\t.write = ixgbe_dbg_netdev_ops_write,\n};\n\n \nvoid ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter)\n{\n\tconst char *name = pci_name(adapter->pdev);\n\n\tadapter->ixgbe_dbg_adapter = debugfs_create_dir(name, ixgbe_dbg_root);\n\tdebugfs_create_file(\"reg_ops\", 0600, adapter->ixgbe_dbg_adapter,\n\t\t\t    adapter, &ixgbe_dbg_reg_ops_fops);\n\tdebugfs_create_file(\"netdev_ops\", 0600, adapter->ixgbe_dbg_adapter,\n\t\t\t    adapter, &ixgbe_dbg_netdev_ops_fops);\n}\n\n \nvoid ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter)\n{\n\tdebugfs_remove_recursive(adapter->ixgbe_dbg_adapter);\n\tadapter->ixgbe_dbg_adapter = NULL;\n}\n\n \nvoid ixgbe_dbg_init(void)\n{\n\tixgbe_dbg_root = debugfs_create_dir(ixgbe_driver_name, NULL);\n}\n\n \nvoid ixgbe_dbg_exit(void)\n{\n\tdebugfs_remove_recursive(ixgbe_dbg_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}