{
  "module_name": "e1000_hw.c",
  "hash_id": "05c2f172af1d30546078db12c05771c092b92c537083608d5838bc837de40c35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000/e1000_hw.c",
  "human_readable_source": "\n \n\n \n\n#include \"e1000.h\"\n\nstatic s32 e1000_check_downshift(struct e1000_hw *hw);\nstatic s32 e1000_check_polarity(struct e1000_hw *hw,\n\t\t\t\te1000_rev_polarity *polarity);\nstatic void e1000_clear_hw_cntrs(struct e1000_hw *hw);\nstatic void e1000_clear_vfta(struct e1000_hw *hw);\nstatic s32 e1000_config_dsp_after_link_change(struct e1000_hw *hw,\n\t\t\t\t\t      bool link_up);\nstatic s32 e1000_config_fc_after_link_up(struct e1000_hw *hw);\nstatic s32 e1000_detect_gig_phy(struct e1000_hw *hw);\nstatic s32 e1000_get_auto_rd_done(struct e1000_hw *hw);\nstatic s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length,\n\t\t\t\t  u16 *max_length);\nstatic s32 e1000_get_phy_cfg_done(struct e1000_hw *hw);\nstatic s32 e1000_id_led_init(struct e1000_hw *hw);\nstatic void e1000_init_rx_addrs(struct e1000_hw *hw);\nstatic s32 e1000_phy_igp_get_info(struct e1000_hw *hw,\n\t\t\t\t  struct e1000_phy_info *phy_info);\nstatic s32 e1000_phy_m88_get_info(struct e1000_hw *hw,\n\t\t\t\t  struct e1000_phy_info *phy_info);\nstatic s32 e1000_set_d3_lplu_state(struct e1000_hw *hw, bool active);\nstatic s32 e1000_wait_autoneg(struct e1000_hw *hw);\nstatic void e1000_write_reg_io(struct e1000_hw *hw, u32 offset, u32 value);\nstatic s32 e1000_set_phy_type(struct e1000_hw *hw);\nstatic void e1000_phy_init_script(struct e1000_hw *hw);\nstatic s32 e1000_setup_copper_link(struct e1000_hw *hw);\nstatic s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw);\nstatic s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw);\nstatic s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw);\nstatic s32 e1000_config_mac_to_phy(struct e1000_hw *hw);\nstatic void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl);\nstatic void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl);\nstatic void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count);\nstatic u16 e1000_shift_in_mdi_bits(struct e1000_hw *hw);\nstatic s32 e1000_phy_reset_dsp(struct e1000_hw *hw);\nstatic s32 e1000_write_eeprom_spi(struct e1000_hw *hw, u16 offset,\n\t\t\t\t  u16 words, u16 *data);\nstatic s32 e1000_write_eeprom_microwire(struct e1000_hw *hw, u16 offset,\n\t\t\t\t\tu16 words, u16 *data);\nstatic s32 e1000_spi_eeprom_ready(struct e1000_hw *hw);\nstatic void e1000_raise_ee_clk(struct e1000_hw *hw, u32 *eecd);\nstatic void e1000_lower_ee_clk(struct e1000_hw *hw, u32 *eecd);\nstatic void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count);\nstatic s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,\n\t\t\t\t  u16 phy_data);\nstatic s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,\n\t\t\t\t u16 *phy_data);\nstatic u16 e1000_shift_in_ee_bits(struct e1000_hw *hw, u16 count);\nstatic s32 e1000_acquire_eeprom(struct e1000_hw *hw);\nstatic void e1000_release_eeprom(struct e1000_hw *hw);\nstatic void e1000_standby_eeprom(struct e1000_hw *hw);\nstatic s32 e1000_set_vco_speed(struct e1000_hw *hw);\nstatic s32 e1000_polarity_reversal_workaround(struct e1000_hw *hw);\nstatic s32 e1000_set_phy_mode(struct e1000_hw *hw);\nstatic s32 e1000_do_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\tu16 *data);\nstatic s32 e1000_do_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t u16 *data);\n\n \nstatic const\nu16 e1000_igp_cable_length_table[IGP01E1000_AGC_LENGTH_TABLE_SIZE] = {\n\t5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t5, 10, 10, 10, 10, 10, 10, 10, 20, 20, 20, 20, 20, 25, 25, 25,\n\t25, 25, 25, 25, 30, 30, 30, 30, 40, 40, 40, 40, 40, 40, 40, 40,\n\t40, 50, 50, 50, 50, 50, 50, 50, 60, 60, 60, 60, 60, 60, 60, 60,\n\t60, 70, 70, 70, 70, 70, 70, 80, 80, 80, 80, 80, 80, 90, 90, 90,\n\t90, 90, 90, 90, 90, 90, 100, 100, 100, 100, 100, 100, 100, 100, 100,\n\t    100,\n\t100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,\n\t    110, 110,\n\t110, 110, 110, 110, 110, 110, 120, 120, 120, 120, 120, 120, 120, 120,\n\t    120, 120\n};\n\nstatic DEFINE_MUTEX(e1000_eeprom_lock);\nstatic DEFINE_SPINLOCK(e1000_phy_lock);\n\n \nstatic s32 e1000_set_phy_type(struct e1000_hw *hw)\n{\n\tif (hw->mac_type == e1000_undefined)\n\t\treturn -E1000_ERR_PHY_TYPE;\n\n\tswitch (hw->phy_id) {\n\tcase M88E1000_E_PHY_ID:\n\tcase M88E1000_I_PHY_ID:\n\tcase M88E1011_I_PHY_ID:\n\tcase M88E1111_I_PHY_ID:\n\tcase M88E1118_E_PHY_ID:\n\t\thw->phy_type = e1000_phy_m88;\n\t\tbreak;\n\tcase IGP01E1000_I_PHY_ID:\n\t\tif (hw->mac_type == e1000_82541 ||\n\t\t    hw->mac_type == e1000_82541_rev_2 ||\n\t\t    hw->mac_type == e1000_82547 ||\n\t\t    hw->mac_type == e1000_82547_rev_2)\n\t\t\thw->phy_type = e1000_phy_igp;\n\t\tbreak;\n\tcase RTL8211B_PHY_ID:\n\t\thw->phy_type = e1000_phy_8211;\n\t\tbreak;\n\tcase RTL8201N_PHY_ID:\n\t\thw->phy_type = e1000_phy_8201;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\thw->phy_type = e1000_phy_undefined;\n\t\treturn -E1000_ERR_PHY_TYPE;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic void e1000_phy_init_script(struct e1000_hw *hw)\n{\n\tu16 phy_saved_data;\n\n\tif (hw->phy_init_script) {\n\t\tmsleep(20);\n\n\t\t \n\t\te1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);\n\n\t\t \n\t\te1000_write_phy_reg(hw, 0x2F5B, 0x0003);\n\t\tmsleep(20);\n\n\t\te1000_write_phy_reg(hw, 0x0000, 0x0140);\n\t\tmsleep(5);\n\n\t\tswitch (hw->mac_type) {\n\t\tcase e1000_82541:\n\t\tcase e1000_82547:\n\t\t\te1000_write_phy_reg(hw, 0x1F95, 0x0001);\n\t\t\te1000_write_phy_reg(hw, 0x1F71, 0xBD21);\n\t\t\te1000_write_phy_reg(hw, 0x1F79, 0x0018);\n\t\t\te1000_write_phy_reg(hw, 0x1F30, 0x1600);\n\t\t\te1000_write_phy_reg(hw, 0x1F31, 0x0014);\n\t\t\te1000_write_phy_reg(hw, 0x1F32, 0x161C);\n\t\t\te1000_write_phy_reg(hw, 0x1F94, 0x0003);\n\t\t\te1000_write_phy_reg(hw, 0x1F96, 0x003F);\n\t\t\te1000_write_phy_reg(hw, 0x2010, 0x0008);\n\t\t\tbreak;\n\n\t\tcase e1000_82541_rev_2:\n\t\tcase e1000_82547_rev_2:\n\t\t\te1000_write_phy_reg(hw, 0x1F73, 0x0099);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\te1000_write_phy_reg(hw, 0x0000, 0x3300);\n\t\tmsleep(20);\n\n\t\t \n\t\te1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);\n\n\t\tif (hw->mac_type == e1000_82547) {\n\t\t\tu16 fused, fine, coarse;\n\n\t\t\t \n\t\t\te1000_read_phy_reg(hw,\n\t\t\t\t\t   IGP01E1000_ANALOG_SPARE_FUSE_STATUS,\n\t\t\t\t\t   &fused);\n\n\t\t\tif (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {\n\t\t\t\te1000_read_phy_reg(hw,\n\t\t\t\t\t\t   IGP01E1000_ANALOG_FUSE_STATUS,\n\t\t\t\t\t\t   &fused);\n\n\t\t\t\tfine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;\n\t\t\t\tcoarse =\n\t\t\t\t    fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;\n\n\t\t\t\tif (coarse >\n\t\t\t\t    IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {\n\t\t\t\t\tcoarse -=\n\t\t\t\t\t    IGP01E1000_ANALOG_FUSE_COARSE_10;\n\t\t\t\t\tfine -= IGP01E1000_ANALOG_FUSE_FINE_1;\n\t\t\t\t} else if (coarse ==\n\t\t\t\t\t   IGP01E1000_ANALOG_FUSE_COARSE_THRESH)\n\t\t\t\t\tfine -= IGP01E1000_ANALOG_FUSE_FINE_10;\n\n\t\t\t\tfused =\n\t\t\t\t    (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |\n\t\t\t\t    (fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |\n\t\t\t\t    (coarse &\n\t\t\t\t     IGP01E1000_ANALOG_FUSE_COARSE_MASK);\n\n\t\t\t\te1000_write_phy_reg(hw,\n\t\t\t\t\t\t    IGP01E1000_ANALOG_FUSE_CONTROL,\n\t\t\t\t\t\t    fused);\n\t\t\t\te1000_write_phy_reg(hw,\n\t\t\t\t\t\t    IGP01E1000_ANALOG_FUSE_BYPASS,\n\t\t\t\t\t\t    IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \ns32 e1000_set_mac_type(struct e1000_hw *hw)\n{\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82542:\n\t\tswitch (hw->revision_id) {\n\t\tcase E1000_82542_2_0_REV_ID:\n\t\t\thw->mac_type = e1000_82542_rev2_0;\n\t\t\tbreak;\n\t\tcase E1000_82542_2_1_REV_ID:\n\t\t\thw->mac_type = e1000_82542_rev2_1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -E1000_ERR_MAC_TYPE;\n\t\t}\n\t\tbreak;\n\tcase E1000_DEV_ID_82543GC_FIBER:\n\tcase E1000_DEV_ID_82543GC_COPPER:\n\t\thw->mac_type = e1000_82543;\n\t\tbreak;\n\tcase E1000_DEV_ID_82544EI_COPPER:\n\tcase E1000_DEV_ID_82544EI_FIBER:\n\tcase E1000_DEV_ID_82544GC_COPPER:\n\tcase E1000_DEV_ID_82544GC_LOM:\n\t\thw->mac_type = e1000_82544;\n\t\tbreak;\n\tcase E1000_DEV_ID_82540EM:\n\tcase E1000_DEV_ID_82540EM_LOM:\n\tcase E1000_DEV_ID_82540EP:\n\tcase E1000_DEV_ID_82540EP_LOM:\n\tcase E1000_DEV_ID_82540EP_LP:\n\t\thw->mac_type = e1000_82540;\n\t\tbreak;\n\tcase E1000_DEV_ID_82545EM_COPPER:\n\tcase E1000_DEV_ID_82545EM_FIBER:\n\t\thw->mac_type = e1000_82545;\n\t\tbreak;\n\tcase E1000_DEV_ID_82545GM_COPPER:\n\tcase E1000_DEV_ID_82545GM_FIBER:\n\tcase E1000_DEV_ID_82545GM_SERDES:\n\t\thw->mac_type = e1000_82545_rev_3;\n\t\tbreak;\n\tcase E1000_DEV_ID_82546EB_COPPER:\n\tcase E1000_DEV_ID_82546EB_FIBER:\n\tcase E1000_DEV_ID_82546EB_QUAD_COPPER:\n\t\thw->mac_type = e1000_82546;\n\t\tbreak;\n\tcase E1000_DEV_ID_82546GB_COPPER:\n\tcase E1000_DEV_ID_82546GB_FIBER:\n\tcase E1000_DEV_ID_82546GB_SERDES:\n\tcase E1000_DEV_ID_82546GB_PCIE:\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER:\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\thw->mac_type = e1000_82546_rev_3;\n\t\tbreak;\n\tcase E1000_DEV_ID_82541EI:\n\tcase E1000_DEV_ID_82541EI_MOBILE:\n\tcase E1000_DEV_ID_82541ER_LOM:\n\t\thw->mac_type = e1000_82541;\n\t\tbreak;\n\tcase E1000_DEV_ID_82541ER:\n\tcase E1000_DEV_ID_82541GI:\n\tcase E1000_DEV_ID_82541GI_LF:\n\tcase E1000_DEV_ID_82541GI_MOBILE:\n\t\thw->mac_type = e1000_82541_rev_2;\n\t\tbreak;\n\tcase E1000_DEV_ID_82547EI:\n\tcase E1000_DEV_ID_82547EI_MOBILE:\n\t\thw->mac_type = e1000_82547;\n\t\tbreak;\n\tcase E1000_DEV_ID_82547GI:\n\t\thw->mac_type = e1000_82547_rev_2;\n\t\tbreak;\n\tcase E1000_DEV_ID_INTEL_CE4100_GBE:\n\t\thw->mac_type = e1000_ce4100;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -E1000_ERR_MAC_TYPE;\n\t}\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82541:\n\tcase e1000_82547:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547_rev_2:\n\t\thw->asf_firmware_present = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (hw->mac_type == e1000_82543)\n\t\thw->bad_tx_carr_stats_fd = true;\n\n\tif (hw->mac_type > e1000_82544)\n\t\thw->has_smbus = true;\n\n\treturn E1000_SUCCESS;\n}\n\n \nvoid e1000_set_media_type(struct e1000_hw *hw)\n{\n\tu32 status;\n\n\tif (hw->mac_type != e1000_82543) {\n\t\t \n\t\thw->tbi_compatibility_en = false;\n\t}\n\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82545GM_SERDES:\n\tcase E1000_DEV_ID_82546GB_SERDES:\n\t\thw->media_type = e1000_media_type_internal_serdes;\n\t\tbreak;\n\tdefault:\n\t\tswitch (hw->mac_type) {\n\t\tcase e1000_82542_rev2_0:\n\t\tcase e1000_82542_rev2_1:\n\t\t\thw->media_type = e1000_media_type_fiber;\n\t\t\tbreak;\n\t\tcase e1000_ce4100:\n\t\t\thw->media_type = e1000_media_type_copper;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = er32(STATUS);\n\t\t\tif (status & E1000_STATUS_TBIMODE) {\n\t\t\t\thw->media_type = e1000_media_type_fiber;\n\t\t\t\t \n\t\t\t\thw->tbi_compatibility_en = false;\n\t\t\t} else {\n\t\t\t\thw->media_type = e1000_media_type_copper;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \ns32 e1000_reset_hw(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\tu32 ctrl_ext;\n\tu32 manc;\n\tu32 led_ctrl;\n\ts32 ret_val;\n\n\t \n\tif (hw->mac_type == e1000_82542_rev2_0) {\n\t\te_dbg(\"Disabling MWI on 82542 rev 2.0\\n\");\n\t\te1000_pci_clear_mwi(hw);\n\t}\n\n\t \n\te_dbg(\"Masking off all interrupts\\n\");\n\tew32(IMC, 0xffffffff);\n\n\t \n\tew32(RCTL, 0);\n\tew32(TCTL, E1000_TCTL_PSP);\n\tE1000_WRITE_FLUSH();\n\n\t \n\thw->tbi_compatibility_on = false;\n\n\t \n\tmsleep(10);\n\n\tctrl = er32(CTRL);\n\n\t \n\tif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\n\t\tew32(CTRL, (ctrl | E1000_CTRL_PHY_RST));\n\t\tE1000_WRITE_FLUSH();\n\t\tmsleep(5);\n\t}\n\n\t \n\te_dbg(\"Issuing a global reset to MAC\\n\");\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82544:\n\tcase e1000_82540:\n\tcase e1000_82545:\n\tcase e1000_82546:\n\tcase e1000_82541:\n\tcase e1000_82541_rev_2:\n\t\t \n\t\tE1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));\n\t\tbreak;\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546_rev_3:\n\t\t \n\t\tew32(CTRL_DUP, (ctrl | E1000_CTRL_RST));\n\t\tbreak;\n\tcase e1000_ce4100:\n\tdefault:\n\t\tew32(CTRL, (ctrl | E1000_CTRL_RST));\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\tcase e1000_82544:\n\t\t \n\t\tudelay(10);\n\t\tctrl_ext = er32(CTRL_EXT);\n\t\tctrl_ext |= E1000_CTRL_EXT_EE_RST;\n\t\tew32(CTRL_EXT, ctrl_ext);\n\t\tE1000_WRITE_FLUSH();\n\t\t \n\t\tmsleep(2);\n\t\tbreak;\n\tcase e1000_82541:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547:\n\tcase e1000_82547_rev_2:\n\t\t \n\t\tmsleep(20);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret_val = e1000_get_auto_rd_done(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\t}\n\n\t \n\tif (hw->mac_type >= e1000_82540) {\n\t\tmanc = er32(MANC);\n\t\tmanc &= ~(E1000_MANC_ARP_EN);\n\t\tew32(MANC, manc);\n\t}\n\n\tif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\n\t\te1000_phy_init_script(hw);\n\n\t\t \n\t\tled_ctrl = er32(LEDCTL);\n\t\tled_ctrl &= IGP_ACTIVITY_LED_MASK;\n\t\tled_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);\n\t\tew32(LEDCTL, led_ctrl);\n\t}\n\n\t \n\te_dbg(\"Masking off all interrupts\\n\");\n\tew32(IMC, 0xffffffff);\n\n\t \n\ter32(ICR);\n\n\t \n\tif (hw->mac_type == e1000_82542_rev2_0) {\n\t\tif (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)\n\t\t\te1000_pci_set_mwi(hw);\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_init_hw(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\tu32 i;\n\ts32 ret_val;\n\tu32 mta_size;\n\tu32 ctrl_ext;\n\n\t \n\tret_val = e1000_id_led_init(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Initializing Identification LED\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\te1000_set_media_type(hw);\n\n\t \n\te_dbg(\"Initializing the IEEE VLAN\\n\");\n\tif (hw->mac_type < e1000_82545_rev_3)\n\t\tew32(VET, 0);\n\te1000_clear_vfta(hw);\n\n\t \n\tif (hw->mac_type == e1000_82542_rev2_0) {\n\t\te_dbg(\"Disabling MWI on 82542 rev 2.0\\n\");\n\t\te1000_pci_clear_mwi(hw);\n\t\tew32(RCTL, E1000_RCTL_RST);\n\t\tE1000_WRITE_FLUSH();\n\t\tmsleep(5);\n\t}\n\n\t \n\te1000_init_rx_addrs(hw);\n\n\t \n\tif (hw->mac_type == e1000_82542_rev2_0) {\n\t\tew32(RCTL, 0);\n\t\tE1000_WRITE_FLUSH();\n\t\tmsleep(1);\n\t\tif (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)\n\t\t\te1000_pci_set_mwi(hw);\n\t}\n\n\t \n\te_dbg(\"Zeroing the MTA\\n\");\n\tmta_size = E1000_MC_TBL_SIZE;\n\tfor (i = 0; i < mta_size; i++) {\n\t\tE1000_WRITE_REG_ARRAY(hw, MTA, i, 0);\n\t\t \n\t\tE1000_WRITE_FLUSH();\n\t}\n\n\t \n\tif (hw->dma_fairness && hw->mac_type <= e1000_82543) {\n\t\tctrl = er32(CTRL);\n\t\tew32(CTRL, ctrl | E1000_CTRL_PRIOR);\n\t}\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546_rev_3:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (hw->bus_type == e1000_bus_type_pcix &&\n\t\t    e1000_pcix_get_mmrbc(hw) > 2048)\n\t\t\te1000_pcix_set_mmrbc(hw, 2048);\n\t\tbreak;\n\t}\n\n\t \n\tret_val = e1000_setup_link(hw);\n\n\t \n\tif (hw->mac_type > e1000_82544) {\n\t\tctrl = er32(TXDCTL);\n\t\tctrl =\n\t\t    (ctrl & ~E1000_TXDCTL_WTHRESH) |\n\t\t    E1000_TXDCTL_FULL_TX_DESC_WB;\n\t\tew32(TXDCTL, ctrl);\n\t}\n\n\t \n\te1000_clear_hw_cntrs(hw);\n\n\tif (hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER ||\n\t    hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3) {\n\t\tctrl_ext = er32(CTRL_EXT);\n\t\t \n\t\tctrl_ext |= E1000_CTRL_EXT_RO_DIS;\n\t\tew32(CTRL_EXT, ctrl_ext);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw)\n{\n\tu16 eeprom_data;\n\ts32 ret_val;\n\n\tif (hw->media_type != e1000_media_type_internal_serdes)\n\t\treturn E1000_SUCCESS;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546_rev_3:\n\t\tbreak;\n\tdefault:\n\t\treturn E1000_SUCCESS;\n\t}\n\n\tret_val = e1000_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,\n\t\t\t\t    &eeprom_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (eeprom_data != EEPROM_RESERVED_WORD) {\n\t\t \n\t\teeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL, eeprom_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_setup_link(struct e1000_hw *hw)\n{\n\tu32 ctrl_ext;\n\ts32 ret_val;\n\tu16 eeprom_data;\n\n\t \n\tif (hw->fc == E1000_FC_DEFAULT) {\n\t\tret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,\n\t\t\t\t\t    1, &eeprom_data);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"EEPROM Read Error\\n\");\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\t\tif ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)\n\t\t\thw->fc = E1000_FC_NONE;\n\t\telse if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==\n\t\t\t EEPROM_WORD0F_ASM_DIR)\n\t\t\thw->fc = E1000_FC_TX_PAUSE;\n\t\telse\n\t\t\thw->fc = E1000_FC_FULL;\n\t}\n\n\t \n\tif (hw->mac_type == e1000_82542_rev2_0)\n\t\thw->fc &= (~E1000_FC_TX_PAUSE);\n\n\tif ((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))\n\t\thw->fc &= (~E1000_FC_RX_PAUSE);\n\n\thw->original_fc = hw->fc;\n\n\te_dbg(\"After fix-ups FlowControl is now = %x\\n\", hw->fc);\n\n\t \n\tif (hw->mac_type == e1000_82543) {\n\t\tret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,\n\t\t\t\t\t    1, &eeprom_data);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"EEPROM Read Error\\n\");\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\t\tctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) <<\n\t\t\t    SWDPIO__EXT_SHIFT);\n\t\tew32(CTRL_EXT, ctrl_ext);\n\t}\n\n\t \n\tret_val = (hw->media_type == e1000_media_type_copper) ?\n\t    e1000_setup_copper_link(hw) : e1000_setup_fiber_serdes_link(hw);\n\n\t \n\te_dbg(\"Initializing the Flow Control address, type and timer regs\\n\");\n\n\tew32(FCT, FLOW_CONTROL_TYPE);\n\tew32(FCAH, FLOW_CONTROL_ADDRESS_HIGH);\n\tew32(FCAL, FLOW_CONTROL_ADDRESS_LOW);\n\n\tew32(FCTTV, hw->fc_pause_time);\n\n\t \n\tif (!(hw->fc & E1000_FC_TX_PAUSE)) {\n\t\tew32(FCRTL, 0);\n\t\tew32(FCRTH, 0);\n\t} else {\n\t\t \n\t\tif (hw->fc_send_xon) {\n\t\t\tew32(FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));\n\t\t\tew32(FCRTH, hw->fc_high_water);\n\t\t} else {\n\t\t\tew32(FCRTL, hw->fc_low_water);\n\t\t\tew32(FCRTH, hw->fc_high_water);\n\t\t}\n\t}\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\tu32 status;\n\tu32 txcw = 0;\n\tu32 i;\n\tu32 signal = 0;\n\ts32 ret_val;\n\n\t \n\tctrl = er32(CTRL);\n\tif (hw->media_type == e1000_media_type_fiber)\n\t\tsignal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;\n\n\tret_val = e1000_adjust_serdes_amplitude(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tctrl &= ~(E1000_CTRL_LRST);\n\n\t \n\tret_val = e1000_set_vco_speed(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te1000_config_collision_dist(hw);\n\n\t \n\tswitch (hw->fc) {\n\tcase E1000_FC_NONE:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD);\n\t\tbreak;\n\tcase E1000_FC_RX_PAUSE:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);\n\t\tbreak;\n\tcase E1000_FC_TX_PAUSE:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);\n\t\tbreak;\n\tcase E1000_FC_FULL:\n\t\t \n\t\ttxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Flow control param set incorrectly\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\t \n\te_dbg(\"Auto-negotiation enabled\\n\");\n\n\tew32(TXCW, txcw);\n\tew32(CTRL, ctrl);\n\tE1000_WRITE_FLUSH();\n\n\thw->txcw = txcw;\n\tmsleep(1);\n\n\t \n\tif (hw->media_type == e1000_media_type_internal_serdes ||\n\t    (er32(CTRL) & E1000_CTRL_SWDPIN1) == signal) {\n\t\te_dbg(\"Looking for Link\\n\");\n\t\tfor (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {\n\t\t\tmsleep(10);\n\t\t\tstatus = er32(STATUS);\n\t\t\tif (status & E1000_STATUS_LU)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == (LINK_UP_TIMEOUT / 10)) {\n\t\t\te_dbg(\"Never got a valid link from auto-neg!!!\\n\");\n\t\t\thw->autoneg_failed = 1;\n\t\t\t \n\t\t\tret_val = e1000_check_for_link(hw);\n\t\t\tif (ret_val) {\n\t\t\t\te_dbg(\"Error while checking for link\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t\thw->autoneg_failed = 0;\n\t\t} else {\n\t\t\thw->autoneg_failed = 0;\n\t\t\te_dbg(\"Valid Link Found\\n\");\n\t\t}\n\t} else {\n\t\te_dbg(\"No Signal Detected\\n\");\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_copper_link_rtl_setup(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\t \n\tret_val = e1000_phy_reset(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Resetting the PHY\\n\");\n\t\treturn ret_val;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\nstatic s32 gbe_dhg_phy_setup(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu32 ctrl_aux;\n\n\tswitch (hw->phy_type) {\n\tcase e1000_phy_8211:\n\t\tret_val = e1000_copper_link_rtl_setup(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"e1000_copper_link_rtl_setup failed!\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tbreak;\n\tcase e1000_phy_8201:\n\t\t \n\t\tctrl_aux = er32(CTL_AUX);\n\t\tctrl_aux |= E1000_CTL_AUX_RMII;\n\t\tew32(CTL_AUX, ctrl_aux);\n\t\tE1000_WRITE_FLUSH();\n\n\t\t \n\t\tctrl_aux = er32(CTL_AUX);\n\t\tctrl_aux |= 0x4;\n\t\tctrl_aux &= ~0x2;\n\t\tew32(CTL_AUX, ctrl_aux);\n\t\tE1000_WRITE_FLUSH();\n\t\tret_val = e1000_copper_link_rtl_setup(hw);\n\n\t\tif (ret_val) {\n\t\t\te_dbg(\"e1000_copper_link_rtl_setup failed!\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Error Resetting the PHY\\n\");\n\t\treturn E1000_ERR_PHY_TYPE;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_copper_link_preconfig(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tctrl = er32(CTRL);\n\t \n\tif (hw->mac_type > e1000_82543) {\n\t\tctrl |= E1000_CTRL_SLU;\n\t\tctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\t\tew32(CTRL, ctrl);\n\t} else {\n\t\tctrl |=\n\t\t    (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);\n\t\tew32(CTRL, ctrl);\n\t\tret_val = e1000_phy_hw_reset(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tret_val = e1000_detect_gig_phy(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error, did not detect valid phy.\\n\");\n\t\treturn ret_val;\n\t}\n\te_dbg(\"Phy ID = %x\\n\", hw->phy_id);\n\n\t \n\tret_val = e1000_set_phy_mode(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif ((hw->mac_type == e1000_82545_rev_3) ||\n\t    (hw->mac_type == e1000_82546_rev_3)) {\n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\t\tphy_data |= 0x00000008;\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\t}\n\n\tif (hw->mac_type <= e1000_82543 ||\n\t    hw->mac_type == e1000_82541 || hw->mac_type == e1000_82547 ||\n\t    hw->mac_type == e1000_82541_rev_2 ||\n\t    hw->mac_type == e1000_82547_rev_2)\n\t\thw->phy_reset_disable = false;\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_copper_link_igp_setup(struct e1000_hw *hw)\n{\n\tu32 led_ctrl;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (hw->phy_reset_disable)\n\t\treturn E1000_SUCCESS;\n\n\tret_val = e1000_phy_reset(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Resetting the PHY\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tmsleep(15);\n\t \n\tled_ctrl = er32(LEDCTL);\n\tled_ctrl &= IGP_ACTIVITY_LED_MASK;\n\tled_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);\n\tew32(LEDCTL, led_ctrl);\n\n\t \n\tif (hw->phy_type == e1000_phy_igp) {\n\t\t \n\t\tret_val = e1000_set_d3_lplu_state(hw, false);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error Disabling LPLU D3\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\n\t\thw->dsp_config_state = e1000_dsp_config_disabled;\n\t\t \n\t\tphy_data &=\n\t\t    ~(IGP01E1000_PSCR_AUTO_MDIX |\n\t\t      IGP01E1000_PSCR_FORCE_MDI_MDIX);\n\t\thw->mdix = 1;\n\n\t} else {\n\t\thw->dsp_config_state = e1000_dsp_config_enabled;\n\t\tphy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;\n\n\t\tswitch (hw->mdix) {\n\t\tcase 1:\n\t\t\tphy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tphy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\tphy_data |= IGP01E1000_PSCR_AUTO_MDIX;\n\t\t\tbreak;\n\t\t}\n\t}\n\tret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (hw->autoneg) {\n\t\te1000_ms_type phy_ms_setting = hw->master_slave;\n\n\t\tif (hw->ffe_config_state == e1000_ffe_config_active)\n\t\t\thw->ffe_config_state = e1000_ffe_config_enabled;\n\n\t\tif (hw->dsp_config_state == e1000_dsp_config_activated)\n\t\t\thw->dsp_config_state = e1000_dsp_config_enabled;\n\n\t\t \n\t\tif (hw->autoneg_advertised == ADVERTISE_1000_FULL) {\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t       &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tphy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\tphy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tphy_data &= ~CR_1000T_MS_ENABLE;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\n\t\tret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\thw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?\n\t\t    ((phy_data & CR_1000T_MS_VALUE) ?\n\t\t     e1000_ms_force_master :\n\t\t     e1000_ms_force_slave) : e1000_ms_auto;\n\n\t\tswitch (phy_ms_setting) {\n\t\tcase e1000_ms_force_master:\n\t\t\tphy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);\n\t\t\tbreak;\n\t\tcase e1000_ms_force_slave:\n\t\t\tphy_data |= CR_1000T_MS_ENABLE;\n\t\t\tphy_data &= ~(CR_1000T_MS_VALUE);\n\t\t\tbreak;\n\t\tcase e1000_ms_auto:\n\t\t\tphy_data &= ~CR_1000T_MS_ENABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_copper_link_mgp_setup(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (hw->phy_reset_disable)\n\t\treturn E1000_SUCCESS;\n\n\t \n\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\n\n\t \n\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\n\tswitch (hw->mdix) {\n\tcase 1:\n\t\tphy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;\n\t\tbreak;\n\tcase 2:\n\t\tphy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;\n\t\tbreak;\n\tcase 3:\n\t\tphy_data |= M88E1000_PSCR_AUTO_X_1000T;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tphy_data |= M88E1000_PSCR_AUTO_X_MODE;\n\t\tbreak;\n\t}\n\n\t \n\tphy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;\n\tif (hw->disable_polarity_correction == 1)\n\t\tphy_data |= M88E1000_PSCR_POLARITY_REVERSAL;\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (hw->phy_revision < M88E1011_I_REV_4) {\n\t\t \n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\n\t\t\t\t       &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_data |= M88E1000_EPSCR_TX_CLK_25;\n\n\t\tif ((hw->phy_revision == E1000_REVISION_2) &&\n\t\t    (hw->phy_id == M88E1111_I_PHY_ID)) {\n\t\t\t \n\t\t\tphy_data &= ~(M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK);\n\t\t\tphy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;\n\t\t\tret_val = e1000_write_phy_reg(hw,\n\t\t\t\t\t\t      M88E1000_EXT_PHY_SPEC_CTRL,\n\t\t\t\t\t\t      phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t} else {\n\t\t\t \n\t\t\tphy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |\n\t\t\t\t      M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);\n\t\t\tphy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |\n\t\t\t\t     M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);\n\t\t\tret_val = e1000_write_phy_reg(hw,\n\t\t\t\t\t\t      M88E1000_EXT_PHY_SPEC_CTRL,\n\t\t\t\t\t\t      phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tret_val = e1000_phy_reset(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Resetting the PHY\\n\");\n\t\treturn ret_val;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_copper_link_autoneg(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\t \n\thw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\n\t \n\tif (hw->autoneg_advertised == 0)\n\t\thw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;\n\n\t \n\tif (hw->phy_type == e1000_phy_8201)\n\t\thw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;\n\n\te_dbg(\"Reconfiguring auto-neg advertisement params\\n\");\n\tret_val = e1000_phy_setup_autoneg(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Setting up Auto-Negotiation\\n\");\n\t\treturn ret_val;\n\t}\n\te_dbg(\"Restarting Auto-Neg\\n\");\n\n\t \n\tret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);\n\tret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (hw->wait_autoneg_complete) {\n\t\tret_val = e1000_wait_autoneg(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg\n\t\t\t    (\"Error while waiting for autoneg to complete\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\thw->get_link_status = true;\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_copper_link_postconfig(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tif ((hw->mac_type >= e1000_82544) && (hw->mac_type != e1000_ce4100)) {\n\t\te1000_config_collision_dist(hw);\n\t} else {\n\t\tret_val = e1000_config_mac_to_phy(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error configuring MAC to PHY settings\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\tret_val = e1000_config_fc_after_link_up(hw);\n\tif (ret_val) {\n\t\te_dbg(\"Error Configuring Flow Control\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tif (hw->phy_type == e1000_phy_igp) {\n\t\tret_val = e1000_config_dsp_after_link_change(hw, true);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error Configuring DSP after link up\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_setup_copper_link(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 i;\n\tu16 phy_data;\n\n\t \n\tret_val = e1000_copper_link_preconfig(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (hw->phy_type == e1000_phy_igp) {\n\t\tret_val = e1000_copper_link_igp_setup(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else if (hw->phy_type == e1000_phy_m88) {\n\t\tret_val = e1000_copper_link_mgp_setup(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else {\n\t\tret_val = gbe_dhg_phy_setup(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"gbe_dhg_phy_setup failed!\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\tif (hw->autoneg) {\n\t\t \n\t\tret_val = e1000_copper_link_autoneg(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t} else {\n\t\t \n\t\te_dbg(\"Forcing speed and duplex\\n\");\n\t\tret_val = e1000_phy_force_speed_duplex(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error Forcing Speed and Duplex\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (phy_data & MII_SR_LINK_STATUS) {\n\t\t\t \n\t\t\tret_val = e1000_copper_link_postconfig(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\te_dbg(\"Valid link established!!!\\n\");\n\t\t\treturn E1000_SUCCESS;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\te_dbg(\"Unable to establish link!!!\\n\");\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_phy_setup_autoneg(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 mii_autoneg_adv_reg;\n\tu16 mii_1000t_ctrl_reg;\n\n\t \n\tret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\telse if (hw->phy_type == e1000_phy_8201)\n\t\tmii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;\n\n\t \n\n\t \n\tmii_autoneg_adv_reg &= ~REG4_SPEED_MASK;\n\tmii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;\n\n\te_dbg(\"autoneg_advertised %x\\n\", hw->autoneg_advertised);\n\n\t \n\tif (hw->autoneg_advertised & ADVERTISE_10_HALF) {\n\t\te_dbg(\"Advertise 10mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;\n\t}\n\n\t \n\tif (hw->autoneg_advertised & ADVERTISE_10_FULL) {\n\t\te_dbg(\"Advertise 10mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;\n\t}\n\n\t \n\tif (hw->autoneg_advertised & ADVERTISE_100_HALF) {\n\t\te_dbg(\"Advertise 100mb Half duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;\n\t}\n\n\t \n\tif (hw->autoneg_advertised & ADVERTISE_100_FULL) {\n\t\te_dbg(\"Advertise 100mb Full duplex\\n\");\n\t\tmii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;\n\t}\n\n\t \n\tif (hw->autoneg_advertised & ADVERTISE_1000_HALF) {\n\t\te_dbg\n\t\t    (\"Advertise 1000mb Half duplex requested, request denied!\\n\");\n\t}\n\n\t \n\tif (hw->autoneg_advertised & ADVERTISE_1000_FULL) {\n\t\te_dbg(\"Advertise 1000mb Full duplex\\n\");\n\t\tmii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;\n\t}\n\n\t \n\tswitch (hw->fc) {\n\tcase E1000_FC_NONE:\t \n\t\t \n\t\tmii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tcase E1000_FC_RX_PAUSE:\t \n\t\t \n\t\t \n\t\tmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tcase E1000_FC_TX_PAUSE:\t \n\t\t \n\t\tmii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;\n\t\tmii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;\n\t\tbreak;\n\tcase E1000_FC_FULL:\t \n\t\t \n\t\tmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Flow control param set incorrectly\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\te_dbg(\"Auto-Neg Advertising %x\\n\", mii_autoneg_adv_reg);\n\n\tif (hw->phy_type == e1000_phy_8201) {\n\t\tmii_1000t_ctrl_reg = 0;\n\t} else {\n\t\tret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,\n\t\t\t\t\t      mii_1000t_ctrl_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\tu16 mii_ctrl_reg;\n\tu16 mii_status_reg;\n\tu16 phy_data;\n\tu16 i;\n\n\t \n\thw->fc = E1000_FC_NONE;\n\n\te_dbg(\"hw->fc = %d\\n\", hw->fc);\n\n\t \n\tctrl = er32(CTRL);\n\n\t \n\tctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tctrl &= ~(DEVICE_SPEED_MASK);\n\n\t \n\tctrl &= ~E1000_CTRL_ASDE;\n\n\t \n\tret_val = e1000_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\n\tmii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;\n\n\t \n\tif (hw->forced_speed_duplex == e1000_100_full ||\n\t    hw->forced_speed_duplex == e1000_10_full) {\n\t\t \n\t\tctrl |= E1000_CTRL_FD;\n\t\tmii_ctrl_reg |= MII_CR_FULL_DUPLEX;\n\t\te_dbg(\"Full Duplex\\n\");\n\t} else {\n\t\t \n\t\tctrl &= ~E1000_CTRL_FD;\n\t\tmii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;\n\t\te_dbg(\"Half Duplex\\n\");\n\t}\n\n\t \n\tif (hw->forced_speed_duplex == e1000_100_full ||\n\t    hw->forced_speed_duplex == e1000_100_half) {\n\t\t \n\t\tctrl |= E1000_CTRL_SPD_100;\n\t\tmii_ctrl_reg |= MII_CR_SPEED_100;\n\t\tmii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);\n\t\te_dbg(\"Forcing 100mb \");\n\t} else {\n\t\t \n\t\tctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\n\t\tmii_ctrl_reg |= MII_CR_SPEED_10;\n\t\tmii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);\n\t\te_dbg(\"Forcing 10mb \");\n\t}\n\n\te1000_config_collision_dist(hw);\n\n\t \n\tew32(CTRL, ctrl);\n\n\tif (hw->phy_type == e1000_phy_m88) {\n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\te_dbg(\"M88E1000 PSCR: %x\\n\", phy_data);\n\n\t\t \n\t\tmii_ctrl_reg |= MII_CR_RESET;\n\n\t\t \n\t} else {\n\t\t \n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;\n\t\tphy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t \n\tret_val = e1000_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tudelay(1);\n\n\t \n\tif (hw->wait_autoneg_complete) {\n\t\t \n\t\te_dbg(\"Waiting for forced speed/duplex link.\\n\");\n\t\tmii_status_reg = 0;\n\n\t\t \n\t\tfor (i = PHY_FORCE_TIME; i > 0; i--) {\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tif (mii_status_reg & MII_SR_LINK_STATUS)\n\t\t\t\tbreak;\n\t\t\tmsleep(100);\n\t\t}\n\t\tif ((i == 0) && (hw->phy_type == e1000_phy_m88)) {\n\t\t\t \n\t\t\tret_val = e1000_phy_reset_dsp(hw);\n\t\t\tif (ret_val) {\n\t\t\t\te_dbg(\"Error Resetting PHY DSP\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\t\t \n\t\tfor (i = PHY_FORCE_TIME; i > 0; i--) {\n\t\t\tif (mii_status_reg & MII_SR_LINK_STATUS)\n\t\t\t\tbreak;\n\t\t\tmsleep(100);\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\tif (hw->phy_type == e1000_phy_m88) {\n\t\t \n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\n\t\t\t\t       &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_data |= M88E1000_EPSCR_TX_CLK_25;\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\n\t\t\t\t\tphy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif ((hw->mac_type == e1000_82544 ||\n\t\t     hw->mac_type == e1000_82543) &&\n\t\t    (!hw->autoneg) &&\n\t\t    (hw->forced_speed_duplex == e1000_10_full ||\n\t\t     hw->forced_speed_duplex == e1000_10_half)) {\n\t\t\tret_val = e1000_polarity_reversal_workaround(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nvoid e1000_config_collision_dist(struct e1000_hw *hw)\n{\n\tu32 tctl, coll_dist;\n\n\tif (hw->mac_type < e1000_82543)\n\t\tcoll_dist = E1000_COLLISION_DISTANCE_82542;\n\telse\n\t\tcoll_dist = E1000_COLLISION_DISTANCE;\n\n\ttctl = er32(TCTL);\n\n\ttctl &= ~E1000_TCTL_COLD;\n\ttctl |= coll_dist << E1000_COLD_SHIFT;\n\n\tew32(TCTL, tctl);\n\tE1000_WRITE_FLUSH();\n}\n\n \nstatic s32 e1000_config_mac_to_phy(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\t \n\tif ((hw->mac_type >= e1000_82544) && (hw->mac_type != e1000_ce4100))\n\t\treturn E1000_SUCCESS;\n\n\t \n\tctrl = er32(CTRL);\n\tctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);\n\n\tswitch (hw->phy_type) {\n\tcase e1000_phy_8201:\n\t\tret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (phy_data & RTL_PHY_CTRL_FD)\n\t\t\tctrl |= E1000_CTRL_FD;\n\t\telse\n\t\t\tctrl &= ~E1000_CTRL_FD;\n\n\t\tif (phy_data & RTL_PHY_CTRL_SPD_100)\n\t\t\tctrl |= E1000_CTRL_SPD_100;\n\t\telse\n\t\t\tctrl |= E1000_CTRL_SPD_10;\n\n\t\te1000_config_collision_dist(hw);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (phy_data & M88E1000_PSSR_DPLX)\n\t\t\tctrl |= E1000_CTRL_FD;\n\t\telse\n\t\t\tctrl &= ~E1000_CTRL_FD;\n\n\t\te1000_config_collision_dist(hw);\n\n\t\t \n\t\tif ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)\n\t\t\tctrl |= E1000_CTRL_SPD_1000;\n\t\telse if ((phy_data & M88E1000_PSSR_SPEED) ==\n\t\t\t M88E1000_PSSR_100MBS)\n\t\t\tctrl |= E1000_CTRL_SPD_100;\n\t}\n\n\t \n\tew32(CTRL, ctrl);\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_force_mac_fc(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\n\t \n\tctrl = er32(CTRL);\n\n\t \n\n\tswitch (hw->fc) {\n\tcase E1000_FC_NONE:\n\t\tctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));\n\t\tbreak;\n\tcase E1000_FC_RX_PAUSE:\n\t\tctrl &= (~E1000_CTRL_TFCE);\n\t\tctrl |= E1000_CTRL_RFCE;\n\t\tbreak;\n\tcase E1000_FC_TX_PAUSE:\n\t\tctrl &= (~E1000_CTRL_RFCE);\n\t\tctrl |= E1000_CTRL_TFCE;\n\t\tbreak;\n\tcase E1000_FC_FULL:\n\t\tctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Flow control param set incorrectly\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\t \n\tif (hw->mac_type == e1000_82542_rev2_0)\n\t\tctrl &= (~E1000_CTRL_TFCE);\n\n\tew32(CTRL, ctrl);\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_config_fc_after_link_up(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 mii_status_reg;\n\tu16 mii_nway_adv_reg;\n\tu16 mii_nway_lp_ability_reg;\n\tu16 speed;\n\tu16 duplex;\n\n\t \n\tif (((hw->media_type == e1000_media_type_fiber) &&\n\t     (hw->autoneg_failed)) ||\n\t    ((hw->media_type == e1000_media_type_internal_serdes) &&\n\t     (hw->autoneg_failed)) ||\n\t    ((hw->media_type == e1000_media_type_copper) &&\n\t     (!hw->autoneg))) {\n\t\tret_val = e1000_force_mac_fc(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error forcing flow control settings\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tif ((hw->media_type == e1000_media_type_copper) && hw->autoneg) {\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (mii_status_reg & MII_SR_AUTONEG_COMPLETE) {\n\t\t\t \n\t\t\tret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,\n\t\t\t\t\t\t     &mii_nway_adv_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,\n\t\t\t\t\t\t     &mii_nway_lp_ability_reg);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\t \n\t\t\t \n\t\t\tif ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t\t    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {\n\t\t\t\t \n\t\t\t\tif (hw->original_fc == E1000_FC_FULL) {\n\t\t\t\t\thw->fc = E1000_FC_FULL;\n\t\t\t\t\te_dbg(\"Flow Control = FULL.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\thw->fc = E1000_FC_RX_PAUSE;\n\t\t\t\t\te_dbg\n\t\t\t\t\t    (\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\telse if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t\t\t (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\n\t\t\t\t (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\n\t\t\t\t (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\n\t\t\t\thw->fc = E1000_FC_TX_PAUSE;\n\t\t\t\te_dbg\n\t\t\t\t    (\"Flow Control = TX PAUSE frames only.\\n\");\n\t\t\t}\n\t\t\t \n\t\t\telse if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\n\t\t\t\t (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\n\t\t\t\t !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\n\t\t\t\t (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\n\t\t\t\thw->fc = E1000_FC_RX_PAUSE;\n\t\t\t\te_dbg\n\t\t\t\t    (\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t\t}\n\t\t\t \n\t\t\telse if ((hw->original_fc == E1000_FC_NONE ||\n\t\t\t\t  hw->original_fc == E1000_FC_TX_PAUSE) ||\n\t\t\t\t hw->fc_strict_ieee) {\n\t\t\t\thw->fc = E1000_FC_NONE;\n\t\t\t\te_dbg(\"Flow Control = NONE.\\n\");\n\t\t\t} else {\n\t\t\t\thw->fc = E1000_FC_RX_PAUSE;\n\t\t\t\te_dbg\n\t\t\t\t    (\"Flow Control = RX PAUSE frames only.\\n\");\n\t\t\t}\n\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_get_speed_and_duplex(hw, &speed, &duplex);\n\t\t\tif (ret_val) {\n\t\t\t\te_dbg\n\t\t\t\t    (\"Error getting link speed and duplex\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\n\t\t\tif (duplex == HALF_DUPLEX)\n\t\t\t\thw->fc = E1000_FC_NONE;\n\n\t\t\t \n\t\t\tret_val = e1000_force_mac_fc(hw);\n\t\t\tif (ret_val) {\n\t\t\t\te_dbg\n\t\t\t\t    (\"Error forcing flow control settings\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t} else {\n\t\t\te_dbg\n\t\t\t    (\"Copper PHY and Auto Neg has not completed.\\n\");\n\t\t}\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_check_for_serdes_link_generic(struct e1000_hw *hw)\n{\n\tu32 rxcw;\n\tu32 ctrl;\n\tu32 status;\n\ts32 ret_val = E1000_SUCCESS;\n\n\tctrl = er32(CTRL);\n\tstatus = er32(STATUS);\n\trxcw = er32(RXCW);\n\n\t \n\t \n\tif ((!(status & E1000_STATUS_LU)) && (!(rxcw & E1000_RXCW_C))) {\n\t\tif (hw->autoneg_failed == 0) {\n\t\t\thw->autoneg_failed = 1;\n\t\t\tgoto out;\n\t\t}\n\t\te_dbg(\"NOT RXing /C/, disable AutoNeg and force link.\\n\");\n\n\t\t \n\t\tew32(TXCW, (hw->txcw & ~E1000_TXCW_ANE));\n\n\t\t \n\t\tctrl = er32(CTRL);\n\t\tctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);\n\t\tew32(CTRL, ctrl);\n\n\t\t \n\t\tret_val = e1000_config_fc_after_link_up(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error configuring flow control\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else if ((ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {\n\t\t \n\t\te_dbg(\"RXing /C/, enable AutoNeg and stop forcing link.\\n\");\n\t\tew32(TXCW, hw->txcw);\n\t\tew32(CTRL, (ctrl & ~E1000_CTRL_SLU));\n\n\t\thw->serdes_has_link = true;\n\t} else if (!(E1000_TXCW_ANE & er32(TXCW))) {\n\t\t \n\t\t \n\t\tudelay(10);\n\t\trxcw = er32(RXCW);\n\t\tif (rxcw & E1000_RXCW_SYNCH) {\n\t\t\tif (!(rxcw & E1000_RXCW_IV)) {\n\t\t\t\thw->serdes_has_link = true;\n\t\t\t\te_dbg(\"SERDES: Link up - forced.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\thw->serdes_has_link = false;\n\t\t\te_dbg(\"SERDES: Link down - force failed.\\n\");\n\t\t}\n\t}\n\n\tif (E1000_TXCW_ANE & er32(TXCW)) {\n\t\tstatus = er32(STATUS);\n\t\tif (status & E1000_STATUS_LU) {\n\t\t\t \n\t\t\tudelay(10);\n\t\t\trxcw = er32(RXCW);\n\t\t\tif (rxcw & E1000_RXCW_SYNCH) {\n\t\t\t\tif (!(rxcw & E1000_RXCW_IV)) {\n\t\t\t\t\thw->serdes_has_link = true;\n\t\t\t\t\te_dbg(\"SERDES: Link up - autoneg \"\n\t\t\t\t\t\t \"completed successfully.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\thw->serdes_has_link = false;\n\t\t\t\t\te_dbg(\"SERDES: Link down - invalid\"\n\t\t\t\t\t\t \"codewords detected in autoneg.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thw->serdes_has_link = false;\n\t\t\t\te_dbg(\"SERDES: Link down - no sync.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\thw->serdes_has_link = false;\n\t\t\te_dbg(\"SERDES: Link down - autoneg failed\\n\");\n\t\t}\n\t}\n\n      out:\n\treturn ret_val;\n}\n\n \ns32 e1000_check_for_link(struct e1000_hw *hw)\n{\n\tu32 status;\n\tu32 rctl;\n\tu32 icr;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\ter32(CTRL);\n\tstatus = er32(STATUS);\n\n\t \n\tif ((hw->media_type == e1000_media_type_fiber) ||\n\t    (hw->media_type == e1000_media_type_internal_serdes)) {\n\t\ter32(RXCW);\n\n\t\tif (hw->media_type == e1000_media_type_fiber) {\n\t\t\tif (status & E1000_STATUS_LU)\n\t\t\t\thw->get_link_status = false;\n\t\t}\n\t}\n\n\t \n\tif ((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (phy_data & MII_SR_LINK_STATUS) {\n\t\t\thw->get_link_status = false;\n\t\t\t \n\t\t\te1000_check_downshift(hw);\n\n\t\t\t \n\n\t\t\tif ((hw->mac_type == e1000_82544 ||\n\t\t\t     hw->mac_type == e1000_82543) &&\n\t\t\t    (!hw->autoneg) &&\n\t\t\t    (hw->forced_speed_duplex == e1000_10_full ||\n\t\t\t     hw->forced_speed_duplex == e1000_10_half)) {\n\t\t\t\tew32(IMC, 0xffffffff);\n\t\t\t\tret_val =\n\t\t\t\t    e1000_polarity_reversal_workaround(hw);\n\t\t\t\ticr = er32(ICR);\n\t\t\t\tew32(ICS, (icr & ~E1000_ICS_LSC));\n\t\t\t\tew32(IMS, IMS_ENABLE_MASK);\n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\t\t\te1000_config_dsp_after_link_change(hw, false);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (!hw->autoneg)\n\t\t\treturn -E1000_ERR_CONFIG;\n\n\t\t \n\t\te1000_config_dsp_after_link_change(hw, true);\n\n\t\t \n\t\tif ((hw->mac_type >= e1000_82544) &&\n\t\t    (hw->mac_type != e1000_ce4100))\n\t\t\te1000_config_collision_dist(hw);\n\t\telse {\n\t\t\tret_val = e1000_config_mac_to_phy(hw);\n\t\t\tif (ret_val) {\n\t\t\t\te_dbg\n\t\t\t\t    (\"Error configuring MAC to PHY settings\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret_val = e1000_config_fc_after_link_up(hw);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error configuring flow control\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\tif (hw->tbi_compatibility_en) {\n\t\t\tu16 speed, duplex;\n\n\t\t\tret_val =\n\t\t\t    e1000_get_speed_and_duplex(hw, &speed, &duplex);\n\n\t\t\tif (ret_val) {\n\t\t\t\te_dbg\n\t\t\t\t    (\"Error getting link speed and duplex\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t\tif (speed != SPEED_1000) {\n\t\t\t\t \n\t\t\t\tif (hw->tbi_compatibility_on) {\n\t\t\t\t\t \n\t\t\t\t\trctl = er32(RCTL);\n\t\t\t\t\trctl &= ~E1000_RCTL_SBP;\n\t\t\t\t\tew32(RCTL, rctl);\n\t\t\t\t\thw->tbi_compatibility_on = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!hw->tbi_compatibility_on) {\n\t\t\t\t\thw->tbi_compatibility_on = true;\n\t\t\t\t\trctl = er32(RCTL);\n\t\t\t\t\trctl |= E1000_RCTL_SBP;\n\t\t\t\t\tew32(RCTL, rctl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((hw->media_type == e1000_media_type_fiber) ||\n\t    (hw->media_type == e1000_media_type_internal_serdes))\n\t\te1000_check_for_serdes_link_generic(hw);\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_get_speed_and_duplex(struct e1000_hw *hw, u16 *speed, u16 *duplex)\n{\n\tu32 status;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (hw->mac_type >= e1000_82543) {\n\t\tstatus = er32(STATUS);\n\t\tif (status & E1000_STATUS_SPEED_1000) {\n\t\t\t*speed = SPEED_1000;\n\t\t\te_dbg(\"1000 Mbs, \");\n\t\t} else if (status & E1000_STATUS_SPEED_100) {\n\t\t\t*speed = SPEED_100;\n\t\t\te_dbg(\"100 Mbs, \");\n\t\t} else {\n\t\t\t*speed = SPEED_10;\n\t\t\te_dbg(\"10 Mbs, \");\n\t\t}\n\n\t\tif (status & E1000_STATUS_FD) {\n\t\t\t*duplex = FULL_DUPLEX;\n\t\t\te_dbg(\"Full Duplex\\n\");\n\t\t} else {\n\t\t\t*duplex = HALF_DUPLEX;\n\t\t\te_dbg(\" Half Duplex\\n\");\n\t\t}\n\t} else {\n\t\te_dbg(\"1000 Mbs, Full Duplex\\n\");\n\t\t*speed = SPEED_1000;\n\t\t*duplex = FULL_DUPLEX;\n\t}\n\n\t \n\tif (hw->phy_type == e1000_phy_igp && hw->speed_downgraded) {\n\t\tret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (!(phy_data & NWAY_ER_LP_NWAY_CAPS))\n\t\t\t*duplex = HALF_DUPLEX;\n\t\telse {\n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tif ((*speed == SPEED_100 &&\n\t\t\t     !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||\n\t\t\t    (*speed == SPEED_10 &&\n\t\t\t     !(phy_data & NWAY_LPAR_10T_FD_CAPS)))\n\t\t\t\t*duplex = HALF_DUPLEX;\n\t\t}\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_wait_autoneg(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 i;\n\tu16 phy_data;\n\n\te_dbg(\"Waiting for Auto-Neg to complete.\\n\");\n\n\t \n\tfor (i = PHY_AUTO_NEG_TIME; i > 0; i--) {\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tif (phy_data & MII_SR_AUTONEG_COMPLETE)\n\t\t\treturn E1000_SUCCESS;\n\n\t\tmsleep(100);\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nstatic void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)\n{\n\t \n\tew32(CTRL, (*ctrl | E1000_CTRL_MDC));\n\tE1000_WRITE_FLUSH();\n\tudelay(10);\n}\n\n \nstatic void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)\n{\n\t \n\tew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));\n\tE1000_WRITE_FLUSH();\n\tudelay(10);\n}\n\n \nstatic void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count)\n{\n\tu32 ctrl;\n\tu32 mask;\n\n\t \n\tmask = 0x01;\n\tmask <<= (count - 1);\n\n\tctrl = er32(CTRL);\n\n\t \n\tctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);\n\n\twhile (mask) {\n\t\t \n\t\tif (data & mask)\n\t\t\tctrl |= E1000_CTRL_MDIO;\n\t\telse\n\t\t\tctrl &= ~E1000_CTRL_MDIO;\n\n\t\tew32(CTRL, ctrl);\n\t\tE1000_WRITE_FLUSH();\n\n\t\tudelay(10);\n\n\t\te1000_raise_mdi_clk(hw, &ctrl);\n\t\te1000_lower_mdi_clk(hw, &ctrl);\n\n\t\tmask = mask >> 1;\n\t}\n}\n\n \nstatic u16 e1000_shift_in_mdi_bits(struct e1000_hw *hw)\n{\n\tu32 ctrl;\n\tu16 data = 0;\n\tu8 i;\n\n\t \n\tctrl = er32(CTRL);\n\n\t \n\tctrl &= ~E1000_CTRL_MDIO_DIR;\n\tctrl &= ~E1000_CTRL_MDIO;\n\n\tew32(CTRL, ctrl);\n\tE1000_WRITE_FLUSH();\n\n\t \n\te1000_raise_mdi_clk(hw, &ctrl);\n\te1000_lower_mdi_clk(hw, &ctrl);\n\n\tfor (data = 0, i = 0; i < 16; i++) {\n\t\tdata = data << 1;\n\t\te1000_raise_mdi_clk(hw, &ctrl);\n\t\tctrl = er32(CTRL);\n\t\t \n\t\tif (ctrl & E1000_CTRL_MDIO)\n\t\t\tdata |= 1;\n\t\te1000_lower_mdi_clk(hw, &ctrl);\n\t}\n\n\te1000_raise_mdi_clk(hw, &ctrl);\n\te1000_lower_mdi_clk(hw, &ctrl);\n\n\treturn data;\n}\n\n \ns32 e1000_read_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)\n{\n\tu32 ret_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&e1000_phy_lock, flags);\n\n\tif ((hw->phy_type == e1000_phy_igp) &&\n\t    (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {\n\t\tret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t (u16) reg_addr);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tret_val = e1000_read_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,\n\t\t\t\t\tphy_data);\nout:\n\tspin_unlock_irqrestore(&e1000_phy_lock, flags);\n\n\treturn ret_val;\n}\n\nstatic s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,\n\t\t\t\t u16 *phy_data)\n{\n\tu32 i;\n\tu32 mdic = 0;\n\tconst u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;\n\n\tif (reg_addr > MAX_PHY_REG_ADDRESS) {\n\t\te_dbg(\"PHY Address %d is out of range\\n\", reg_addr);\n\t\treturn -E1000_ERR_PARAM;\n\t}\n\n\tif (hw->mac_type > e1000_82543) {\n\t\t \n\t\tif (hw->mac_type == e1000_ce4100) {\n\t\t\tmdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |\n\t\t\t\t(phy_addr << E1000_MDIC_PHY_SHIFT) |\n\t\t\t\t(INTEL_CE_GBE_MDIC_OP_READ) |\n\t\t\t\t(INTEL_CE_GBE_MDIC_GO));\n\n\t\t\twritel(mdic, E1000_MDIO_CMD);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 64; i++) {\n\t\t\t\tudelay(50);\n\t\t\t\tmdic = readl(E1000_MDIO_CMD);\n\t\t\t\tif (!(mdic & INTEL_CE_GBE_MDIC_GO))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mdic & INTEL_CE_GBE_MDIC_GO) {\n\t\t\t\te_dbg(\"MDI Read did not complete\\n\");\n\t\t\t\treturn -E1000_ERR_PHY;\n\t\t\t}\n\n\t\t\tmdic = readl(E1000_MDIO_STS);\n\t\t\tif (mdic & INTEL_CE_GBE_MDIC_READ_ERROR) {\n\t\t\t\te_dbg(\"MDI Read Error\\n\");\n\t\t\t\treturn -E1000_ERR_PHY;\n\t\t\t}\n\t\t\t*phy_data = (u16)mdic;\n\t\t} else {\n\t\t\tmdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |\n\t\t\t\t(phy_addr << E1000_MDIC_PHY_SHIFT) |\n\t\t\t\t(E1000_MDIC_OP_READ));\n\n\t\t\tew32(MDIC, mdic);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 64; i++) {\n\t\t\t\tudelay(50);\n\t\t\t\tmdic = er32(MDIC);\n\t\t\t\tif (mdic & E1000_MDIC_READY)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(mdic & E1000_MDIC_READY)) {\n\t\t\t\te_dbg(\"MDI Read did not complete\\n\");\n\t\t\t\treturn -E1000_ERR_PHY;\n\t\t\t}\n\t\t\tif (mdic & E1000_MDIC_ERROR) {\n\t\t\t\te_dbg(\"MDI Error\\n\");\n\t\t\t\treturn -E1000_ERR_PHY;\n\t\t\t}\n\t\t\t*phy_data = (u16)mdic;\n\t\t}\n\t} else {\n\t\t \n\t\te1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);\n\n\t\t \n\t\tmdic = ((reg_addr) | (phy_addr << 5) |\n\t\t\t(PHY_OP_READ << 10) | (PHY_SOF << 12));\n\n\t\te1000_shift_out_mdi_bits(hw, mdic, 14);\n\n\t\t \n\t\t*phy_data = e1000_shift_in_mdi_bits(hw);\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_write_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)\n{\n\tu32 ret_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&e1000_phy_lock, flags);\n\n\tif ((hw->phy_type == e1000_phy_igp) &&\n\t    (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {\n\t\tret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t (u16)reg_addr);\n\t\tif (ret_val) {\n\t\t\tspin_unlock_irqrestore(&e1000_phy_lock, flags);\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\tret_val = e1000_write_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,\n\t\t\t\t\t phy_data);\n\tspin_unlock_irqrestore(&e1000_phy_lock, flags);\n\n\treturn ret_val;\n}\n\nstatic s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,\n\t\t\t\t  u16 phy_data)\n{\n\tu32 i;\n\tu32 mdic = 0;\n\tconst u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;\n\n\tif (reg_addr > MAX_PHY_REG_ADDRESS) {\n\t\te_dbg(\"PHY Address %d is out of range\\n\", reg_addr);\n\t\treturn -E1000_ERR_PARAM;\n\t}\n\n\tif (hw->mac_type > e1000_82543) {\n\t\t \n\t\tif (hw->mac_type == e1000_ce4100) {\n\t\t\tmdic = (((u32)phy_data) |\n\t\t\t\t(reg_addr << E1000_MDIC_REG_SHIFT) |\n\t\t\t\t(phy_addr << E1000_MDIC_PHY_SHIFT) |\n\t\t\t\t(INTEL_CE_GBE_MDIC_OP_WRITE) |\n\t\t\t\t(INTEL_CE_GBE_MDIC_GO));\n\n\t\t\twritel(mdic, E1000_MDIO_CMD);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 640; i++) {\n\t\t\t\tudelay(5);\n\t\t\t\tmdic = readl(E1000_MDIO_CMD);\n\t\t\t\tif (!(mdic & INTEL_CE_GBE_MDIC_GO))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mdic & INTEL_CE_GBE_MDIC_GO) {\n\t\t\t\te_dbg(\"MDI Write did not complete\\n\");\n\t\t\t\treturn -E1000_ERR_PHY;\n\t\t\t}\n\t\t} else {\n\t\t\tmdic = (((u32)phy_data) |\n\t\t\t\t(reg_addr << E1000_MDIC_REG_SHIFT) |\n\t\t\t\t(phy_addr << E1000_MDIC_PHY_SHIFT) |\n\t\t\t\t(E1000_MDIC_OP_WRITE));\n\n\t\t\tew32(MDIC, mdic);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 641; i++) {\n\t\t\t\tudelay(5);\n\t\t\t\tmdic = er32(MDIC);\n\t\t\t\tif (mdic & E1000_MDIC_READY)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(mdic & E1000_MDIC_READY)) {\n\t\t\t\te_dbg(\"MDI Write did not complete\\n\");\n\t\t\t\treturn -E1000_ERR_PHY;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\te1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);\n\n\t\t \n\t\tmdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |\n\t\t\t(PHY_OP_WRITE << 12) | (PHY_SOF << 14));\n\t\tmdic <<= 16;\n\t\tmdic |= (u32)phy_data;\n\n\t\te1000_shift_out_mdi_bits(hw, mdic, 32);\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_phy_hw_reset(struct e1000_hw *hw)\n{\n\tu32 ctrl, ctrl_ext;\n\tu32 led_ctrl;\n\n\te_dbg(\"Resetting Phy...\\n\");\n\n\tif (hw->mac_type > e1000_82543) {\n\t\t \n\t\tctrl = er32(CTRL);\n\t\tew32(CTRL, ctrl | E1000_CTRL_PHY_RST);\n\t\tE1000_WRITE_FLUSH();\n\n\t\tmsleep(10);\n\n\t\tew32(CTRL, ctrl);\n\t\tE1000_WRITE_FLUSH();\n\n\t} else {\n\t\t \n\t\tctrl_ext = er32(CTRL_EXT);\n\t\tctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;\n\t\tctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;\n\t\tew32(CTRL_EXT, ctrl_ext);\n\t\tE1000_WRITE_FLUSH();\n\t\tmsleep(10);\n\t\tctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;\n\t\tew32(CTRL_EXT, ctrl_ext);\n\t\tE1000_WRITE_FLUSH();\n\t}\n\tudelay(150);\n\n\tif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\n\t\t \n\t\tled_ctrl = er32(LEDCTL);\n\t\tled_ctrl &= IGP_ACTIVITY_LED_MASK;\n\t\tled_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);\n\t\tew32(LEDCTL, led_ctrl);\n\t}\n\n\t \n\treturn e1000_get_phy_cfg_done(hw);\n}\n\n \ns32 e1000_phy_reset(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tswitch (hw->phy_type) {\n\tcase e1000_phy_igp:\n\t\tret_val = e1000_phy_hw_reset(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tbreak;\n\tdefault:\n\t\tret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_data |= MII_CR_RESET;\n\t\tret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tudelay(1);\n\t\tbreak;\n\t}\n\n\tif (hw->phy_type == e1000_phy_igp)\n\t\te1000_phy_init_script(hw);\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_detect_gig_phy(struct e1000_hw *hw)\n{\n\ts32 phy_init_status, ret_val;\n\tu16 phy_id_high, phy_id_low;\n\tbool match = false;\n\n\tif (hw->phy_id != 0)\n\t\treturn E1000_SUCCESS;\n\n\t \n\tret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\thw->phy_id = (u32)(phy_id_high << 16);\n\tudelay(20);\n\tret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\thw->phy_id |= (u32)(phy_id_low & PHY_REVISION_MASK);\n\thw->phy_revision = (u32)phy_id_low & ~PHY_REVISION_MASK;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82543:\n\t\tif (hw->phy_id == M88E1000_E_PHY_ID)\n\t\t\tmatch = true;\n\t\tbreak;\n\tcase e1000_82544:\n\t\tif (hw->phy_id == M88E1000_I_PHY_ID)\n\t\t\tmatch = true;\n\t\tbreak;\n\tcase e1000_82540:\n\tcase e1000_82545:\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546:\n\tcase e1000_82546_rev_3:\n\t\tif (hw->phy_id == M88E1011_I_PHY_ID)\n\t\t\tmatch = true;\n\t\tbreak;\n\tcase e1000_ce4100:\n\t\tif ((hw->phy_id == RTL8211B_PHY_ID) ||\n\t\t    (hw->phy_id == RTL8201N_PHY_ID) ||\n\t\t    (hw->phy_id == M88E1118_E_PHY_ID))\n\t\t\tmatch = true;\n\t\tbreak;\n\tcase e1000_82541:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547:\n\tcase e1000_82547_rev_2:\n\t\tif (hw->phy_id == IGP01E1000_I_PHY_ID)\n\t\t\tmatch = true;\n\t\tbreak;\n\tdefault:\n\t\te_dbg(\"Invalid MAC type %d\\n\", hw->mac_type);\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\tphy_init_status = e1000_set_phy_type(hw);\n\n\tif ((match) && (phy_init_status == E1000_SUCCESS)) {\n\t\te_dbg(\"PHY ID 0x%X detected\\n\", hw->phy_id);\n\t\treturn E1000_SUCCESS;\n\t}\n\te_dbg(\"Invalid PHY ID 0x%X\\n\", hw->phy_id);\n\treturn -E1000_ERR_PHY;\n}\n\n \nstatic s32 e1000_phy_reset_dsp(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\n\tdo {\n\t\tret_val = e1000_write_phy_reg(hw, 29, 0x001d);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tret_val = e1000_write_phy_reg(hw, 30, 0x00c1);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tret_val = e1000_write_phy_reg(hw, 30, 0x0000);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tret_val = E1000_SUCCESS;\n\t} while (0);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_phy_igp_get_info(struct e1000_hw *hw,\n\t\t\t\t  struct e1000_phy_info *phy_info)\n{\n\ts32 ret_val;\n\tu16 phy_data, min_length, max_length, average;\n\te1000_rev_polarity polarity;\n\n\t \n\tphy_info->downshift = (e1000_downshift) hw->speed_downgraded;\n\n\t \n\tphy_info->extended_10bt_distance = e1000_10bt_ext_dist_enable_normal;\n\n\t \n\tphy_info->polarity_correction = e1000_polarity_reversal_enabled;\n\n\t \n\tret_val = e1000_check_polarity(hw, &polarity);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_info->cable_polarity = polarity;\n\n\tret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_info->mdix_mode =\n\t    (e1000_auto_x_mode) ((phy_data & IGP01E1000_PSSR_MDIX) >>\n\t\t\t\t IGP01E1000_PSSR_MDIX_SHIFT);\n\n\tif ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==\n\t    IGP01E1000_PSSR_SPEED_1000MBPS) {\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>\n\t\t\t\t      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?\n\t\t    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\t\tphy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>\n\t\t\t\t       SR_1000T_REMOTE_RX_STATUS_SHIFT) ?\n\t\t    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\n\t\t \n\t\tret_val = e1000_get_cable_length(hw, &min_length, &max_length);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\taverage = (max_length + min_length) / 2;\n\n\t\tif (average <= e1000_igp_cable_length_50)\n\t\t\tphy_info->cable_length = e1000_cable_length_50;\n\t\telse if (average <= e1000_igp_cable_length_80)\n\t\t\tphy_info->cable_length = e1000_cable_length_50_80;\n\t\telse if (average <= e1000_igp_cable_length_110)\n\t\t\tphy_info->cable_length = e1000_cable_length_80_110;\n\t\telse if (average <= e1000_igp_cable_length_140)\n\t\t\tphy_info->cable_length = e1000_cable_length_110_140;\n\t\telse\n\t\t\tphy_info->cable_length = e1000_cable_length_140;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_phy_m88_get_info(struct e1000_hw *hw,\n\t\t\t\t  struct e1000_phy_info *phy_info)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\te1000_rev_polarity polarity;\n\n\t \n\tphy_info->downshift = (e1000_downshift) hw->speed_downgraded;\n\n\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_info->extended_10bt_distance =\n\t    ((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>\n\t     M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT) ?\n\t    e1000_10bt_ext_dist_enable_lower :\n\t    e1000_10bt_ext_dist_enable_normal;\n\n\tphy_info->polarity_correction =\n\t    ((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>\n\t     M88E1000_PSCR_POLARITY_REVERSAL_SHIFT) ?\n\t    e1000_polarity_reversal_disabled : e1000_polarity_reversal_enabled;\n\n\t \n\tret_val = e1000_check_polarity(hw, &polarity);\n\tif (ret_val)\n\t\treturn ret_val;\n\tphy_info->cable_polarity = polarity;\n\n\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_info->mdix_mode =\n\t    (e1000_auto_x_mode) ((phy_data & M88E1000_PSSR_MDIX) >>\n\t\t\t\t M88E1000_PSSR_MDIX_SHIFT);\n\n\tif ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {\n\t\t \n\t\tphy_info->cable_length =\n\t\t    (e1000_cable_length) ((phy_data &\n\t\t\t\t\t   M88E1000_PSSR_CABLE_LENGTH) >>\n\t\t\t\t\t  M88E1000_PSSR_CABLE_LENGTH_SHIFT);\n\n\t\tret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>\n\t\t\t\t      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?\n\t\t    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\t\tphy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>\n\t\t\t\t       SR_1000T_REMOTE_RX_STATUS_SHIFT) ?\n\t\t    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tphy_info->cable_length = e1000_cable_length_undefined;\n\tphy_info->extended_10bt_distance = e1000_10bt_ext_dist_enable_undefined;\n\tphy_info->cable_polarity = e1000_rev_polarity_undefined;\n\tphy_info->downshift = e1000_downshift_undefined;\n\tphy_info->polarity_correction = e1000_polarity_reversal_undefined;\n\tphy_info->mdix_mode = e1000_auto_x_mode_undefined;\n\tphy_info->local_rx = e1000_1000t_rx_status_undefined;\n\tphy_info->remote_rx = e1000_1000t_rx_status_undefined;\n\n\tif (hw->media_type != e1000_media_type_copper) {\n\t\te_dbg(\"PHY info is only valid for copper media\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif ((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {\n\t\te_dbg(\"PHY info is only valid if link is up\\n\");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tif (hw->phy_type == e1000_phy_igp)\n\t\treturn e1000_phy_igp_get_info(hw, phy_info);\n\telse if ((hw->phy_type == e1000_phy_8211) ||\n\t\t (hw->phy_type == e1000_phy_8201))\n\t\treturn E1000_SUCCESS;\n\telse\n\t\treturn e1000_phy_m88_get_info(hw, phy_info);\n}\n\ns32 e1000_validate_mdi_setting(struct e1000_hw *hw)\n{\n\tif (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {\n\t\te_dbg(\"Invalid MDI setting detected\\n\");\n\t\thw->mdix = 1;\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_init_eeprom_params(struct e1000_hw *hw)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eecd = er32(EECD);\n\ts32 ret_val = E1000_SUCCESS;\n\tu16 eeprom_size;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\tcase e1000_82544:\n\t\teeprom->type = e1000_eeprom_microwire;\n\t\teeprom->word_size = 64;\n\t\teeprom->opcode_bits = 3;\n\t\teeprom->address_bits = 6;\n\t\teeprom->delay_usec = 50;\n\t\tbreak;\n\tcase e1000_82540:\n\tcase e1000_82545:\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546:\n\tcase e1000_82546_rev_3:\n\t\teeprom->type = e1000_eeprom_microwire;\n\t\teeprom->opcode_bits = 3;\n\t\teeprom->delay_usec = 50;\n\t\tif (eecd & E1000_EECD_SIZE) {\n\t\t\teeprom->word_size = 256;\n\t\t\teeprom->address_bits = 8;\n\t\t} else {\n\t\t\teeprom->word_size = 64;\n\t\t\teeprom->address_bits = 6;\n\t\t}\n\t\tbreak;\n\tcase e1000_82541:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547:\n\tcase e1000_82547_rev_2:\n\t\tif (eecd & E1000_EECD_TYPE) {\n\t\t\teeprom->type = e1000_eeprom_spi;\n\t\t\teeprom->opcode_bits = 8;\n\t\t\teeprom->delay_usec = 1;\n\t\t\tif (eecd & E1000_EECD_ADDR_BITS) {\n\t\t\t\teeprom->page_size = 32;\n\t\t\t\teeprom->address_bits = 16;\n\t\t\t} else {\n\t\t\t\teeprom->page_size = 8;\n\t\t\t\teeprom->address_bits = 8;\n\t\t\t}\n\t\t} else {\n\t\t\teeprom->type = e1000_eeprom_microwire;\n\t\t\teeprom->opcode_bits = 3;\n\t\t\teeprom->delay_usec = 50;\n\t\t\tif (eecd & E1000_EECD_ADDR_BITS) {\n\t\t\t\teeprom->word_size = 256;\n\t\t\t\teeprom->address_bits = 8;\n\t\t\t} else {\n\t\t\t\teeprom->word_size = 64;\n\t\t\t\teeprom->address_bits = 6;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (eeprom->type == e1000_eeprom_spi) {\n\t\t \n\t\t \n\t\teeprom->word_size = 64;\n\t\tret_val = e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\teeprom_size =\n\t\t    (eeprom_size & EEPROM_SIZE_MASK) >> EEPROM_SIZE_SHIFT;\n\t\t \n\t\tif (eeprom_size)\n\t\t\teeprom_size++;\n\n\t\teeprom->word_size = 1 << (eeprom_size + EEPROM_WORD_SIZE_SHIFT);\n\t}\n\treturn ret_val;\n}\n\n \nstatic void e1000_raise_ee_clk(struct e1000_hw *hw, u32 *eecd)\n{\n\t \n\t*eecd = *eecd | E1000_EECD_SK;\n\tew32(EECD, *eecd);\n\tE1000_WRITE_FLUSH();\n\tudelay(hw->eeprom.delay_usec);\n}\n\n \nstatic void e1000_lower_ee_clk(struct e1000_hw *hw, u32 *eecd)\n{\n\t \n\t*eecd = *eecd & ~E1000_EECD_SK;\n\tew32(EECD, *eecd);\n\tE1000_WRITE_FLUSH();\n\tudelay(hw->eeprom.delay_usec);\n}\n\n \nstatic void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eecd;\n\tu32 mask;\n\n\t \n\tmask = 0x01 << (count - 1);\n\teecd = er32(EECD);\n\tif (eeprom->type == e1000_eeprom_microwire)\n\t\teecd &= ~E1000_EECD_DO;\n\telse if (eeprom->type == e1000_eeprom_spi)\n\t\teecd |= E1000_EECD_DO;\n\n\tdo {\n\t\t \n\t\teecd &= ~E1000_EECD_DI;\n\n\t\tif (data & mask)\n\t\t\teecd |= E1000_EECD_DI;\n\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\n\t\tudelay(eeprom->delay_usec);\n\n\t\te1000_raise_ee_clk(hw, &eecd);\n\t\te1000_lower_ee_clk(hw, &eecd);\n\n\t\tmask = mask >> 1;\n\n\t} while (mask);\n\n\t \n\teecd &= ~E1000_EECD_DI;\n\tew32(EECD, eecd);\n}\n\n \nstatic u16 e1000_shift_in_ee_bits(struct e1000_hw *hw, u16 count)\n{\n\tu32 eecd;\n\tu32 i;\n\tu16 data;\n\n\t \n\n\teecd = er32(EECD);\n\n\teecd &= ~(E1000_EECD_DO | E1000_EECD_DI);\n\tdata = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdata = data << 1;\n\t\te1000_raise_ee_clk(hw, &eecd);\n\n\t\teecd = er32(EECD);\n\n\t\teecd &= ~(E1000_EECD_DI);\n\t\tif (eecd & E1000_EECD_DO)\n\t\t\tdata |= 1;\n\n\t\te1000_lower_ee_clk(hw, &eecd);\n\t}\n\n\treturn data;\n}\n\n \nstatic s32 e1000_acquire_eeprom(struct e1000_hw *hw)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eecd, i = 0;\n\n\teecd = er32(EECD);\n\n\t \n\tif (hw->mac_type > e1000_82544) {\n\t\teecd |= E1000_EECD_REQ;\n\t\tew32(EECD, eecd);\n\t\teecd = er32(EECD);\n\t\twhile ((!(eecd & E1000_EECD_GNT)) &&\n\t\t       (i < E1000_EEPROM_GRANT_ATTEMPTS)) {\n\t\t\ti++;\n\t\t\tudelay(5);\n\t\t\teecd = er32(EECD);\n\t\t}\n\t\tif (!(eecd & E1000_EECD_GNT)) {\n\t\t\teecd &= ~E1000_EECD_REQ;\n\t\t\tew32(EECD, eecd);\n\t\t\te_dbg(\"Could not acquire EEPROM grant\\n\");\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\t}\n\n\t \n\n\tif (eeprom->type == e1000_eeprom_microwire) {\n\t\t \n\t\teecd &= ~(E1000_EECD_DI | E1000_EECD_SK);\n\t\tew32(EECD, eecd);\n\n\t\t \n\t\teecd |= E1000_EECD_CS;\n\t\tew32(EECD, eecd);\n\t} else if (eeprom->type == e1000_eeprom_spi) {\n\t\t \n\t\teecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(1);\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic void e1000_standby_eeprom(struct e1000_hw *hw)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eecd;\n\n\teecd = er32(EECD);\n\n\tif (eeprom->type == e1000_eeprom_microwire) {\n\t\teecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(eeprom->delay_usec);\n\n\t\t \n\t\teecd |= E1000_EECD_SK;\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(eeprom->delay_usec);\n\n\t\t \n\t\teecd |= E1000_EECD_CS;\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(eeprom->delay_usec);\n\n\t\t \n\t\teecd &= ~E1000_EECD_SK;\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(eeprom->delay_usec);\n\t} else if (eeprom->type == e1000_eeprom_spi) {\n\t\t \n\t\teecd |= E1000_EECD_CS;\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(eeprom->delay_usec);\n\t\teecd &= ~E1000_EECD_CS;\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(eeprom->delay_usec);\n\t}\n}\n\n \nstatic void e1000_release_eeprom(struct e1000_hw *hw)\n{\n\tu32 eecd;\n\n\teecd = er32(EECD);\n\n\tif (hw->eeprom.type == e1000_eeprom_spi) {\n\t\teecd |= E1000_EECD_CS;\t \n\t\teecd &= ~E1000_EECD_SK;\t \n\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\n\t\tudelay(hw->eeprom.delay_usec);\n\t} else if (hw->eeprom.type == e1000_eeprom_microwire) {\n\t\t \n\n\t\t \n\t\teecd &= ~(E1000_EECD_CS | E1000_EECD_DI);\n\n\t\tew32(EECD, eecd);\n\n\t\t \n\t\teecd |= E1000_EECD_SK;\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(hw->eeprom.delay_usec);\n\n\t\t \n\t\teecd &= ~E1000_EECD_SK;\n\t\tew32(EECD, eecd);\n\t\tE1000_WRITE_FLUSH();\n\t\tudelay(hw->eeprom.delay_usec);\n\t}\n\n\t \n\tif (hw->mac_type > e1000_82544) {\n\t\teecd &= ~E1000_EECD_REQ;\n\t\tew32(EECD, eecd);\n\t}\n}\n\n \nstatic s32 e1000_spi_eeprom_ready(struct e1000_hw *hw)\n{\n\tu16 retry_count = 0;\n\tu8 spi_stat_reg;\n\n\t \n\tretry_count = 0;\n\tdo {\n\t\te1000_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,\n\t\t\t\t\thw->eeprom.opcode_bits);\n\t\tspi_stat_reg = (u8)e1000_shift_in_ee_bits(hw, 8);\n\t\tif (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t\tretry_count += 5;\n\n\t\te1000_standby_eeprom(hw);\n\t} while (retry_count < EEPROM_MAX_RETRY_SPI);\n\n\t \n\tif (retry_count >= EEPROM_MAX_RETRY_SPI) {\n\t\te_dbg(\"SPI EEPROM Status error\\n\");\n\t\treturn -E1000_ERR_EEPROM;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\ts32 ret;\n\n\tmutex_lock(&e1000_eeprom_lock);\n\tret = e1000_do_read_eeprom(hw, offset, words, data);\n\tmutex_unlock(&e1000_eeprom_lock);\n\treturn ret;\n}\n\nstatic s32 e1000_do_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\tu16 *data)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\tu32 i = 0;\n\n\tif (hw->mac_type == e1000_ce4100) {\n\t\tGBE_CONFIG_FLASH_READ(GBE_CONFIG_BASE_VIRT, offset, words,\n\t\t\t\t      data);\n\t\treturn E1000_SUCCESS;\n\t}\n\n\t \n\tif ((offset >= eeprom->word_size) ||\n\t    (words > eeprom->word_size - offset) ||\n\t    (words == 0)) {\n\t\te_dbg(\"\\\"words\\\" parameter out of bounds. Words = %d,\"\n\t\t      \"size = %d\\n\", offset, eeprom->word_size);\n\t\treturn -E1000_ERR_EEPROM;\n\t}\n\n\t \n\t \n\tif (e1000_acquire_eeprom(hw) != E1000_SUCCESS)\n\t\treturn -E1000_ERR_EEPROM;\n\n\t \n\tif (eeprom->type == e1000_eeprom_spi) {\n\t\tu16 word_in;\n\t\tu8 read_opcode = EEPROM_READ_OPCODE_SPI;\n\n\t\tif (e1000_spi_eeprom_ready(hw)) {\n\t\t\te1000_release_eeprom(hw);\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\n\t\te1000_standby_eeprom(hw);\n\n\t\t \n\t\tif ((eeprom->address_bits == 8) && (offset >= 128))\n\t\t\tread_opcode |= EEPROM_A8_OPCODE_SPI;\n\n\t\t \n\t\te1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);\n\t\te1000_shift_out_ee_bits(hw, (u16)(offset * 2),\n\t\t\t\t\teeprom->address_bits);\n\n\t\t \n\t\tfor (i = 0; i < words; i++) {\n\t\t\tword_in = e1000_shift_in_ee_bits(hw, 16);\n\t\t\tdata[i] = (word_in >> 8) | (word_in << 8);\n\t\t}\n\t} else if (eeprom->type == e1000_eeprom_microwire) {\n\t\tfor (i = 0; i < words; i++) {\n\t\t\t \n\t\t\te1000_shift_out_ee_bits(hw,\n\t\t\t\t\t\tEEPROM_READ_OPCODE_MICROWIRE,\n\t\t\t\t\t\teeprom->opcode_bits);\n\t\t\te1000_shift_out_ee_bits(hw, (u16)(offset + i),\n\t\t\t\t\t\teeprom->address_bits);\n\n\t\t\t \n\t\t\tdata[i] = e1000_shift_in_ee_bits(hw, 16);\n\t\t\te1000_standby_eeprom(hw);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\t \n\te1000_release_eeprom(hw);\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)\n{\n\tu16 checksum = 0;\n\tu16 i, eeprom_data;\n\n\tfor (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {\n\t\tif (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {\n\t\t\te_dbg(\"EEPROM Read Error\\n\");\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\t\tchecksum += eeprom_data;\n\t}\n\n#ifdef CONFIG_PARISC\n\t \n\tif ((hw->subsystem_vendor_id == 0x103C) && (eeprom_data == 0x16d6))\n\t\treturn E1000_SUCCESS;\n\n#endif\n\tif (checksum == (u16)EEPROM_SUM)\n\t\treturn E1000_SUCCESS;\n\telse {\n\t\te_dbg(\"EEPROM Checksum Invalid\\n\");\n\t\treturn -E1000_ERR_EEPROM;\n\t}\n}\n\n \ns32 e1000_update_eeprom_checksum(struct e1000_hw *hw)\n{\n\tu16 checksum = 0;\n\tu16 i, eeprom_data;\n\n\tfor (i = 0; i < EEPROM_CHECKSUM_REG; i++) {\n\t\tif (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {\n\t\t\te_dbg(\"EEPROM Read Error\\n\");\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\t\tchecksum += eeprom_data;\n\t}\n\tchecksum = (u16)EEPROM_SUM - checksum;\n\tif (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {\n\t\te_dbg(\"EEPROM Write Error\\n\");\n\t\treturn -E1000_ERR_EEPROM;\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\n{\n\ts32 ret;\n\n\tmutex_lock(&e1000_eeprom_lock);\n\tret = e1000_do_write_eeprom(hw, offset, words, data);\n\tmutex_unlock(&e1000_eeprom_lock);\n\treturn ret;\n}\n\nstatic s32 e1000_do_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t u16 *data)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\ts32 status = 0;\n\n\tif (hw->mac_type == e1000_ce4100) {\n\t\tGBE_CONFIG_FLASH_WRITE(GBE_CONFIG_BASE_VIRT, offset, words,\n\t\t\t\t       data);\n\t\treturn E1000_SUCCESS;\n\t}\n\n\t \n\tif ((offset >= eeprom->word_size) ||\n\t    (words > eeprom->word_size - offset) ||\n\t    (words == 0)) {\n\t\te_dbg(\"\\\"words\\\" parameter out of bounds\\n\");\n\t\treturn -E1000_ERR_EEPROM;\n\t}\n\n\t \n\tif (e1000_acquire_eeprom(hw) != E1000_SUCCESS)\n\t\treturn -E1000_ERR_EEPROM;\n\n\tif (eeprom->type == e1000_eeprom_microwire) {\n\t\tstatus = e1000_write_eeprom_microwire(hw, offset, words, data);\n\t} else {\n\t\tstatus = e1000_write_eeprom_spi(hw, offset, words, data);\n\t\tmsleep(10);\n\t}\n\n\t \n\te1000_release_eeprom(hw);\n\n\treturn status;\n}\n\n \nstatic s32 e1000_write_eeprom_spi(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t  u16 *data)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\tu16 widx = 0;\n\n\twhile (widx < words) {\n\t\tu8 write_opcode = EEPROM_WRITE_OPCODE_SPI;\n\n\t\tif (e1000_spi_eeprom_ready(hw))\n\t\t\treturn -E1000_ERR_EEPROM;\n\n\t\te1000_standby_eeprom(hw);\n\t\tcond_resched();\n\n\t\t \n\t\te1000_shift_out_ee_bits(hw, EEPROM_WREN_OPCODE_SPI,\n\t\t\t\t\teeprom->opcode_bits);\n\n\t\te1000_standby_eeprom(hw);\n\n\t\t \n\t\tif ((eeprom->address_bits == 8) && (offset >= 128))\n\t\t\twrite_opcode |= EEPROM_A8_OPCODE_SPI;\n\n\t\t \n\t\te1000_shift_out_ee_bits(hw, write_opcode, eeprom->opcode_bits);\n\n\t\te1000_shift_out_ee_bits(hw, (u16)((offset + widx) * 2),\n\t\t\t\t\teeprom->address_bits);\n\n\t\t \n\n\t\t \n\t\twhile (widx < words) {\n\t\t\tu16 word_out = data[widx];\n\n\t\t\tword_out = (word_out >> 8) | (word_out << 8);\n\t\t\te1000_shift_out_ee_bits(hw, word_out, 16);\n\t\t\twidx++;\n\n\t\t\t \n\t\t\tif ((((offset + widx) * 2) % eeprom->page_size) == 0) {\n\t\t\t\te1000_standby_eeprom(hw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_write_eeprom_microwire(struct e1000_hw *hw, u16 offset,\n\t\t\t\t\tu16 words, u16 *data)\n{\n\tstruct e1000_eeprom_info *eeprom = &hw->eeprom;\n\tu32 eecd;\n\tu16 words_written = 0;\n\tu16 i = 0;\n\n\t \n\te1000_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,\n\t\t\t\t(u16)(eeprom->opcode_bits + 2));\n\n\te1000_shift_out_ee_bits(hw, 0, (u16)(eeprom->address_bits - 2));\n\n\t \n\te1000_standby_eeprom(hw);\n\n\twhile (words_written < words) {\n\t\t \n\t\te1000_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,\n\t\t\t\t\teeprom->opcode_bits);\n\n\t\te1000_shift_out_ee_bits(hw, (u16)(offset + words_written),\n\t\t\t\t\teeprom->address_bits);\n\n\t\t \n\t\te1000_shift_out_ee_bits(hw, data[words_written], 16);\n\n\t\t \n\t\te1000_standby_eeprom(hw);\n\n\t\t \n\t\tfor (i = 0; i < 200; i++) {\n\t\t\teecd = er32(EECD);\n\t\t\tif (eecd & E1000_EECD_DO)\n\t\t\t\tbreak;\n\t\t\tudelay(50);\n\t\t}\n\t\tif (i == 200) {\n\t\t\te_dbg(\"EEPROM Write did not complete\\n\");\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\n\t\t \n\t\te1000_standby_eeprom(hw);\n\t\tcond_resched();\n\n\t\twords_written++;\n\t}\n\n\t \n\te1000_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,\n\t\t\t\t(u16)(eeprom->opcode_bits + 2));\n\n\te1000_shift_out_ee_bits(hw, 0, (u16)(eeprom->address_bits - 2));\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_read_mac_addr(struct e1000_hw *hw)\n{\n\tu16 offset;\n\tu16 eeprom_data, i;\n\n\tfor (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {\n\t\toffset = i >> 1;\n\t\tif (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {\n\t\t\te_dbg(\"EEPROM Read Error\\n\");\n\t\t\treturn -E1000_ERR_EEPROM;\n\t\t}\n\t\thw->perm_mac_addr[i] = (u8)(eeprom_data & 0x00FF);\n\t\thw->perm_mac_addr[i + 1] = (u8)(eeprom_data >> 8);\n\t}\n\n\tswitch (hw->mac_type) {\n\tdefault:\n\t\tbreak;\n\tcase e1000_82546:\n\tcase e1000_82546_rev_3:\n\t\tif (er32(STATUS) & E1000_STATUS_FUNC_1)\n\t\t\thw->perm_mac_addr[5] ^= 0x01;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < NODE_ADDRESS_SIZE; i++)\n\t\thw->mac_addr[i] = hw->perm_mac_addr[i];\n\treturn E1000_SUCCESS;\n}\n\n \nstatic void e1000_init_rx_addrs(struct e1000_hw *hw)\n{\n\tu32 i;\n\tu32 rar_num;\n\n\t \n\te_dbg(\"Programming MAC Address into RAR[0]\\n\");\n\n\te1000_rar_set(hw, hw->mac_addr, 0);\n\n\trar_num = E1000_RAR_ENTRIES;\n\n\t \n\te_dbg(\"Clearing RAR[1-14]\\n\");\n\tfor (i = 1; i < rar_num; i++) {\n\t\tE1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);\n\t\tE1000_WRITE_FLUSH();\n\t\tE1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);\n\t\tE1000_WRITE_FLUSH();\n\t}\n}\n\n \nu32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)\n{\n\tu32 hash_value = 0;\n\n\t \n\tswitch (hw->mc_filter_type) {\n\t\t \n\tcase 0:\n\t\t \n\t\thash_value = ((mc_addr[4] >> 4) | (((u16)mc_addr[5]) << 4));\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\thash_value = ((mc_addr[4] >> 3) | (((u16)mc_addr[5]) << 5));\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\thash_value = ((mc_addr[4] >> 2) | (((u16)mc_addr[5]) << 6));\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\thash_value = ((mc_addr[4]) | (((u16)mc_addr[5]) << 8));\n\t\tbreak;\n\t}\n\n\thash_value &= 0xFFF;\n\treturn hash_value;\n}\n\n \nvoid e1000_rar_set(struct e1000_hw *hw, u8 *addr, u32 index)\n{\n\tu32 rar_low, rar_high;\n\n\t \n\trar_low = ((u32)addr[0] | ((u32)addr[1] << 8) |\n\t\t   ((u32)addr[2] << 16) | ((u32)addr[3] << 24));\n\trar_high = ((u32)addr[4] | ((u32)addr[5] << 8));\n\n\t \n\tswitch (hw->mac_type) {\n\tdefault:\n\t\t \n\t\trar_high |= E1000_RAH_AV;\n\t\tbreak;\n\t}\n\n\tE1000_WRITE_REG_ARRAY(hw, RA, (index << 1), rar_low);\n\tE1000_WRITE_FLUSH();\n\tE1000_WRITE_REG_ARRAY(hw, RA, ((index << 1) + 1), rar_high);\n\tE1000_WRITE_FLUSH();\n}\n\n \nvoid e1000_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)\n{\n\tu32 temp;\n\n\tif ((hw->mac_type == e1000_82544) && ((offset & 0x1) == 1)) {\n\t\ttemp = E1000_READ_REG_ARRAY(hw, VFTA, (offset - 1));\n\t\tE1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);\n\t\tE1000_WRITE_FLUSH();\n\t\tE1000_WRITE_REG_ARRAY(hw, VFTA, (offset - 1), temp);\n\t\tE1000_WRITE_FLUSH();\n\t} else {\n\t\tE1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);\n\t\tE1000_WRITE_FLUSH();\n\t}\n}\n\n \nstatic void e1000_clear_vfta(struct e1000_hw *hw)\n{\n\tu32 offset;\n\n\tfor (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {\n\t\tE1000_WRITE_REG_ARRAY(hw, VFTA, offset, 0);\n\t\tE1000_WRITE_FLUSH();\n\t}\n}\n\nstatic s32 e1000_id_led_init(struct e1000_hw *hw)\n{\n\tu32 ledctl;\n\tconst u32 ledctl_mask = 0x000000FF;\n\tconst u32 ledctl_on = E1000_LEDCTL_MODE_LED_ON;\n\tconst u32 ledctl_off = E1000_LEDCTL_MODE_LED_OFF;\n\tu16 eeprom_data, i, temp;\n\tconst u16 led_mask = 0x0F;\n\n\tif (hw->mac_type < e1000_82540) {\n\t\t \n\t\treturn E1000_SUCCESS;\n\t}\n\n\tledctl = er32(LEDCTL);\n\thw->ledctl_default = ledctl;\n\thw->ledctl_mode1 = hw->ledctl_default;\n\thw->ledctl_mode2 = hw->ledctl_default;\n\n\tif (e1000_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {\n\t\te_dbg(\"EEPROM Read Error\\n\");\n\t\treturn -E1000_ERR_EEPROM;\n\t}\n\n\tif ((eeprom_data == ID_LED_RESERVED_0000) ||\n\t    (eeprom_data == ID_LED_RESERVED_FFFF)) {\n\t\teeprom_data = ID_LED_DEFAULT;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttemp = (eeprom_data >> (i << 2)) & led_mask;\n\t\tswitch (temp) {\n\t\tcase ID_LED_ON1_DEF2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\t\thw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\n\t\t\thw->ledctl_mode1 |= ledctl_on << (i << 3);\n\t\t\tbreak;\n\t\tcase ID_LED_OFF1_DEF2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\thw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\n\t\t\thw->ledctl_mode1 |= ledctl_off << (i << 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tswitch (temp) {\n\t\tcase ID_LED_DEF1_ON2:\n\t\tcase ID_LED_ON1_ON2:\n\t\tcase ID_LED_OFF1_ON2:\n\t\t\thw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\n\t\t\thw->ledctl_mode2 |= ledctl_on << (i << 3);\n\t\t\tbreak;\n\t\tcase ID_LED_DEF1_OFF2:\n\t\tcase ID_LED_ON1_OFF2:\n\t\tcase ID_LED_OFF1_OFF2:\n\t\t\thw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\n\t\t\thw->ledctl_mode2 |= ledctl_off << (i << 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_setup_led(struct e1000_hw *hw)\n{\n\tu32 ledctl;\n\ts32 ret_val = E1000_SUCCESS;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\tcase e1000_82544:\n\t\t \n\t\tbreak;\n\tcase e1000_82541:\n\tcase e1000_82547:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547_rev_2:\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO,\n\t\t\t\t\t     &hw->phy_spd_default);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\n\t\t\t\t\t      (u16)(hw->phy_spd_default &\n\t\t\t\t\t\t     ~IGP01E1000_GMII_SPD));\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tfallthrough;\n\tdefault:\n\t\tif (hw->media_type == e1000_media_type_fiber) {\n\t\t\tledctl = er32(LEDCTL);\n\t\t\t \n\t\t\thw->ledctl_default = ledctl;\n\t\t\t \n\t\t\tledctl &= ~(E1000_LEDCTL_LED0_IVRT |\n\t\t\t\t    E1000_LEDCTL_LED0_BLINK |\n\t\t\t\t    E1000_LEDCTL_LED0_MODE_MASK);\n\t\t\tledctl |= (E1000_LEDCTL_MODE_LED_OFF <<\n\t\t\t\t   E1000_LEDCTL_LED0_MODE_SHIFT);\n\t\t\tew32(LEDCTL, ledctl);\n\t\t} else if (hw->media_type == e1000_media_type_copper)\n\t\t\tew32(LEDCTL, hw->ledctl_mode1);\n\t\tbreak;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_cleanup_led(struct e1000_hw *hw)\n{\n\ts32 ret_val = E1000_SUCCESS;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\tcase e1000_82544:\n\t\t \n\t\tbreak;\n\tcase e1000_82541:\n\tcase e1000_82547:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547_rev_2:\n\t\t \n\t\tret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\n\t\t\t\t\t      hw->phy_spd_default);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tew32(LEDCTL, hw->ledctl_default);\n\t\tbreak;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_led_on(struct e1000_hw *hw)\n{\n\tu32 ctrl = er32(CTRL);\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\t\t \n\t\tctrl |= E1000_CTRL_SWDPIN0;\n\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\tbreak;\n\tcase e1000_82544:\n\t\tif (hw->media_type == e1000_media_type_fiber) {\n\t\t\t \n\t\t\tctrl |= E1000_CTRL_SWDPIN0;\n\t\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\t} else {\n\t\t\t \n\t\t\tctrl &= ~E1000_CTRL_SWDPIN0;\n\t\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (hw->media_type == e1000_media_type_fiber) {\n\t\t\t \n\t\t\tctrl &= ~E1000_CTRL_SWDPIN0;\n\t\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\t} else if (hw->media_type == e1000_media_type_copper) {\n\t\t\tew32(LEDCTL, hw->ledctl_mode2);\n\t\t\treturn E1000_SUCCESS;\n\t\t}\n\t\tbreak;\n\t}\n\n\tew32(CTRL, ctrl);\n\n\treturn E1000_SUCCESS;\n}\n\n \ns32 e1000_led_off(struct e1000_hw *hw)\n{\n\tu32 ctrl = er32(CTRL);\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\t\t \n\t\tctrl &= ~E1000_CTRL_SWDPIN0;\n\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\tbreak;\n\tcase e1000_82544:\n\t\tif (hw->media_type == e1000_media_type_fiber) {\n\t\t\t \n\t\t\tctrl &= ~E1000_CTRL_SWDPIN0;\n\t\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\t} else {\n\t\t\t \n\t\t\tctrl |= E1000_CTRL_SWDPIN0;\n\t\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (hw->media_type == e1000_media_type_fiber) {\n\t\t\t \n\t\t\tctrl |= E1000_CTRL_SWDPIN0;\n\t\t\tctrl |= E1000_CTRL_SWDPIO0;\n\t\t} else if (hw->media_type == e1000_media_type_copper) {\n\t\t\tew32(LEDCTL, hw->ledctl_mode1);\n\t\t\treturn E1000_SUCCESS;\n\t\t}\n\t\tbreak;\n\t}\n\n\tew32(CTRL, ctrl);\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic void e1000_clear_hw_cntrs(struct e1000_hw *hw)\n{\n\ter32(CRCERRS);\n\ter32(SYMERRS);\n\ter32(MPC);\n\ter32(SCC);\n\ter32(ECOL);\n\ter32(MCC);\n\ter32(LATECOL);\n\ter32(COLC);\n\ter32(DC);\n\ter32(SEC);\n\ter32(RLEC);\n\ter32(XONRXC);\n\ter32(XONTXC);\n\ter32(XOFFRXC);\n\ter32(XOFFTXC);\n\ter32(FCRUC);\n\n\ter32(PRC64);\n\ter32(PRC127);\n\ter32(PRC255);\n\ter32(PRC511);\n\ter32(PRC1023);\n\ter32(PRC1522);\n\n\ter32(GPRC);\n\ter32(BPRC);\n\ter32(MPRC);\n\ter32(GPTC);\n\ter32(GORCL);\n\ter32(GORCH);\n\ter32(GOTCL);\n\ter32(GOTCH);\n\ter32(RNBC);\n\ter32(RUC);\n\ter32(RFC);\n\ter32(ROC);\n\ter32(RJC);\n\ter32(TORL);\n\ter32(TORH);\n\ter32(TOTL);\n\ter32(TOTH);\n\ter32(TPR);\n\ter32(TPT);\n\n\ter32(PTC64);\n\ter32(PTC127);\n\ter32(PTC255);\n\ter32(PTC511);\n\ter32(PTC1023);\n\ter32(PTC1522);\n\n\ter32(MPTC);\n\ter32(BPTC);\n\n\tif (hw->mac_type < e1000_82543)\n\t\treturn;\n\n\ter32(ALGNERRC);\n\ter32(RXERRC);\n\ter32(TNCRS);\n\ter32(CEXTERR);\n\ter32(TSCTC);\n\ter32(TSCTFC);\n\n\tif (hw->mac_type <= e1000_82544)\n\t\treturn;\n\n\ter32(MGTPRC);\n\ter32(MGTPDC);\n\ter32(MGTPTC);\n}\n\n \nvoid e1000_reset_adaptive(struct e1000_hw *hw)\n{\n\tif (hw->adaptive_ifs) {\n\t\tif (!hw->ifs_params_forced) {\n\t\t\thw->current_ifs_val = 0;\n\t\t\thw->ifs_min_val = IFS_MIN;\n\t\t\thw->ifs_max_val = IFS_MAX;\n\t\t\thw->ifs_step_size = IFS_STEP;\n\t\t\thw->ifs_ratio = IFS_RATIO;\n\t\t}\n\t\thw->in_ifs_mode = false;\n\t\tew32(AIT, 0);\n\t} else {\n\t\te_dbg(\"Not in Adaptive IFS mode!\\n\");\n\t}\n}\n\n \nvoid e1000_update_adaptive(struct e1000_hw *hw)\n{\n\tif (hw->adaptive_ifs) {\n\t\tif ((hw->collision_delta * hw->ifs_ratio) > hw->tx_packet_delta) {\n\t\t\tif (hw->tx_packet_delta > MIN_NUM_XMITS) {\n\t\t\t\thw->in_ifs_mode = true;\n\t\t\t\tif (hw->current_ifs_val < hw->ifs_max_val) {\n\t\t\t\t\tif (hw->current_ifs_val == 0)\n\t\t\t\t\t\thw->current_ifs_val =\n\t\t\t\t\t\t    hw->ifs_min_val;\n\t\t\t\t\telse\n\t\t\t\t\t\thw->current_ifs_val +=\n\t\t\t\t\t\t    hw->ifs_step_size;\n\t\t\t\t\tew32(AIT, hw->current_ifs_val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (hw->in_ifs_mode &&\n\t\t\t    (hw->tx_packet_delta <= MIN_NUM_XMITS)) {\n\t\t\t\thw->current_ifs_val = 0;\n\t\t\t\thw->in_ifs_mode = false;\n\t\t\t\tew32(AIT, 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\te_dbg(\"Not in Adaptive IFS mode!\\n\");\n\t}\n}\n\n \nvoid e1000_get_bus_info(struct e1000_hw *hw)\n{\n\tu32 status;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\t\thw->bus_type = e1000_bus_type_pci;\n\t\thw->bus_speed = e1000_bus_speed_unknown;\n\t\thw->bus_width = e1000_bus_width_unknown;\n\t\tbreak;\n\tdefault:\n\t\tstatus = er32(STATUS);\n\t\thw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?\n\t\t    e1000_bus_type_pcix : e1000_bus_type_pci;\n\n\t\tif (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {\n\t\t\thw->bus_speed = (hw->bus_type == e1000_bus_type_pci) ?\n\t\t\t    e1000_bus_speed_66 : e1000_bus_speed_120;\n\t\t} else if (hw->bus_type == e1000_bus_type_pci) {\n\t\t\thw->bus_speed = (status & E1000_STATUS_PCI66) ?\n\t\t\t    e1000_bus_speed_66 : e1000_bus_speed_33;\n\t\t} else {\n\t\t\tswitch (status & E1000_STATUS_PCIX_SPEED) {\n\t\t\tcase E1000_STATUS_PCIX_SPEED_66:\n\t\t\t\thw->bus_speed = e1000_bus_speed_66;\n\t\t\t\tbreak;\n\t\t\tcase E1000_STATUS_PCIX_SPEED_100:\n\t\t\t\thw->bus_speed = e1000_bus_speed_100;\n\t\t\t\tbreak;\n\t\t\tcase E1000_STATUS_PCIX_SPEED_133:\n\t\t\t\thw->bus_speed = e1000_bus_speed_133;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\thw->bus_speed = e1000_bus_speed_reserved;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\thw->bus_width = (status & E1000_STATUS_BUS64) ?\n\t\t    e1000_bus_width_64 : e1000_bus_width_32;\n\t\tbreak;\n\t}\n}\n\n \nstatic void e1000_write_reg_io(struct e1000_hw *hw, u32 offset, u32 value)\n{\n\tunsigned long io_addr = hw->io_base;\n\tunsigned long io_data = hw->io_base + 4;\n\n\te1000_io_write(hw, io_addr, offset);\n\te1000_io_write(hw, io_data, value);\n}\n\n \nstatic s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length,\n\t\t\t\t  u16 *max_length)\n{\n\ts32 ret_val;\n\tu16 agc_value = 0;\n\tu16 i, phy_data;\n\tu16 cable_length;\n\n\t*min_length = *max_length = 0;\n\n\t \n\tif (hw->phy_type == e1000_phy_m88) {\n\t\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tcable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>\n\t\t    M88E1000_PSSR_CABLE_LENGTH_SHIFT;\n\n\t\t \n\t\tswitch (cable_length) {\n\t\tcase e1000_cable_length_50:\n\t\t\t*min_length = 0;\n\t\t\t*max_length = e1000_igp_cable_length_50;\n\t\t\tbreak;\n\t\tcase e1000_cable_length_50_80:\n\t\t\t*min_length = e1000_igp_cable_length_50;\n\t\t\t*max_length = e1000_igp_cable_length_80;\n\t\t\tbreak;\n\t\tcase e1000_cable_length_80_110:\n\t\t\t*min_length = e1000_igp_cable_length_80;\n\t\t\t*max_length = e1000_igp_cable_length_110;\n\t\t\tbreak;\n\t\tcase e1000_cable_length_110_140:\n\t\t\t*min_length = e1000_igp_cable_length_110;\n\t\t\t*max_length = e1000_igp_cable_length_140;\n\t\t\tbreak;\n\t\tcase e1000_cable_length_140:\n\t\t\t*min_length = e1000_igp_cable_length_140;\n\t\t\t*max_length = e1000_igp_cable_length_170;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -E1000_ERR_PHY;\n\t\t}\n\t} else if (hw->phy_type == e1000_phy_igp) {\t \n\t\tu16 cur_agc_value;\n\t\tu16 min_agc_value = IGP01E1000_AGC_LENGTH_TABLE_SIZE;\n\t\tstatic const u16 agc_reg_array[IGP01E1000_PHY_CHANNEL_NUM] = {\n\t\t       IGP01E1000_PHY_AGC_A,\n\t\t       IGP01E1000_PHY_AGC_B,\n\t\t       IGP01E1000_PHY_AGC_C,\n\t\t       IGP01E1000_PHY_AGC_D\n\t\t};\n\t\t \n\t\tfor (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {\n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, agc_reg_array[i], &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tcur_agc_value = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;\n\n\t\t\t \n\t\t\tif ((cur_agc_value >=\n\t\t\t     IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1) ||\n\t\t\t    (cur_agc_value == 0))\n\t\t\t\treturn -E1000_ERR_PHY;\n\n\t\t\tagc_value += cur_agc_value;\n\n\t\t\t \n\t\t\tif (min_agc_value > cur_agc_value)\n\t\t\t\tmin_agc_value = cur_agc_value;\n\t\t}\n\n\t\t \n\t\tif (agc_value <\n\t\t    IGP01E1000_PHY_CHANNEL_NUM * e1000_igp_cable_length_50) {\n\t\t\tagc_value -= min_agc_value;\n\n\t\t\t \n\t\t\tagc_value /= (IGP01E1000_PHY_CHANNEL_NUM - 1);\n\t\t} else {\n\t\t\t \n\t\t\tagc_value /= IGP01E1000_PHY_CHANNEL_NUM;\n\t\t}\n\n\t\t \n\t\t*min_length = ((e1000_igp_cable_length_table[agc_value] -\n\t\t\t\tIGP01E1000_AGC_RANGE) > 0) ?\n\t\t    (e1000_igp_cable_length_table[agc_value] -\n\t\t     IGP01E1000_AGC_RANGE) : 0;\n\t\t*max_length = e1000_igp_cable_length_table[agc_value] +\n\t\t    IGP01E1000_AGC_RANGE;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_check_polarity(struct e1000_hw *hw,\n\t\t\t\te1000_rev_polarity *polarity)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (hw->phy_type == e1000_phy_m88) {\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\t*polarity = ((phy_data & M88E1000_PSSR_REV_POLARITY) >>\n\t\t\t     M88E1000_PSSR_REV_POLARITY_SHIFT) ?\n\t\t    e1000_rev_polarity_reversed : e1000_rev_polarity_normal;\n\n\t} else if (hw->phy_type == e1000_phy_igp) {\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tif ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==\n\t\t    IGP01E1000_PSSR_SPEED_1000MBPS) {\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,\n\t\t\t\t\t       &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\t \n\t\t\t*polarity = (phy_data & IGP01E1000_PHY_POLARITY_MASK) ?\n\t\t\t    e1000_rev_polarity_reversed :\n\t\t\t    e1000_rev_polarity_normal;\n\t\t} else {\n\t\t\t \n\t\t\t*polarity =\n\t\t\t    (phy_data & IGP01E1000_PSSR_POLARITY_REVERSED) ?\n\t\t\t    e1000_rev_polarity_reversed :\n\t\t\t    e1000_rev_polarity_normal;\n\t\t}\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_check_downshift(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (hw->phy_type == e1000_phy_igp) {\n\t\tret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\thw->speed_downgraded =\n\t\t    (phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;\n\t} else if (hw->phy_type == e1000_phy_m88) {\n\t\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\n\t\t\t\t\t     &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\thw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>\n\t\t    M88E1000_PSSR_DOWNSHIFT_SHIFT;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\nstatic const u16 dsp_reg_array[IGP01E1000_PHY_CHANNEL_NUM] = {\n\tIGP01E1000_PHY_AGC_PARAM_A,\n\tIGP01E1000_PHY_AGC_PARAM_B,\n\tIGP01E1000_PHY_AGC_PARAM_C,\n\tIGP01E1000_PHY_AGC_PARAM_D\n};\n\nstatic s32 e1000_1000Mb_check_cable_length(struct e1000_hw *hw)\n{\n\tu16 min_length, max_length;\n\tu16 phy_data, i;\n\ts32 ret_val;\n\n\tret_val = e1000_get_cable_length(hw, &min_length, &max_length);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (hw->dsp_config_state != e1000_dsp_config_enabled)\n\t\treturn 0;\n\n\tif (min_length >= e1000_igp_cable_length_50) {\n\t\tfor (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {\n\t\t\tret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],\n\t\t\t\t\t\t     &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tphy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;\n\n\t\t\tret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],\n\t\t\t\t\t\t      phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t\thw->dsp_config_state = e1000_dsp_config_activated;\n\t} else {\n\t\tu16 ffe_idle_err_timeout = FFE_IDLE_ERR_COUNT_TIMEOUT_20;\n\t\tu32 idle_errs = 0;\n\n\t\t \n\t\tret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tfor (i = 0; i < ffe_idle_err_timeout; i++) {\n\t\t\tudelay(1000);\n\t\t\tret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS,\n\t\t\t\t\t\t     &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tidle_errs += (phy_data & SR_1000T_IDLE_ERROR_CNT);\n\t\t\tif (idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {\n\t\t\t\thw->ffe_config_state = e1000_ffe_config_active;\n\n\t\t\t\tret_val = e1000_write_phy_reg(hw,\n\t\t\t\t\t\t\t      IGP01E1000_PHY_DSP_FFE,\n\t\t\t\t\t\t\t      IGP01E1000_PHY_DSP_FFE_CM_CP);\n\t\t\t\tif (ret_val)\n\t\t\t\t\treturn ret_val;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (idle_errs)\n\t\t\t\tffe_idle_err_timeout =\n\t\t\t\t\t    FFE_IDLE_ERR_COUNT_TIMEOUT_100;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic s32 e1000_config_dsp_after_link_change(struct e1000_hw *hw, bool link_up)\n{\n\ts32 ret_val;\n\tu16 phy_data, phy_saved_data, speed, duplex, i;\n\n\tif (hw->phy_type != e1000_phy_igp)\n\t\treturn E1000_SUCCESS;\n\n\tif (link_up) {\n\t\tret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex);\n\t\tif (ret_val) {\n\t\t\te_dbg(\"Error getting link speed and duplex\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tif (speed == SPEED_1000) {\n\t\t\tret_val = e1000_1000Mb_check_cable_length(hw);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t} else {\n\t\tif (hw->dsp_config_state == e1000_dsp_config_activated) {\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);\n\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\t \n\t\t\tret_val = e1000_write_phy_reg(hw, 0x2F5B, 0x0003);\n\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tmsleep(20);\n\n\t\t\tret_val = e1000_write_phy_reg(hw, 0x0000,\n\t\t\t\t\t\t      IGP01E1000_IEEE_FORCE_GIGA);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tfor (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {\n\t\t\t\tret_val =\n\t\t\t\t    e1000_read_phy_reg(hw, dsp_reg_array[i],\n\t\t\t\t\t\t       &phy_data);\n\t\t\t\tif (ret_val)\n\t\t\t\t\treturn ret_val;\n\n\t\t\t\tphy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;\n\t\t\t\tphy_data |= IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;\n\n\t\t\t\tret_val =\n\t\t\t\t    e1000_write_phy_reg(hw, dsp_reg_array[i],\n\t\t\t\t\t\t\tphy_data);\n\t\t\t\tif (ret_val)\n\t\t\t\t\treturn ret_val;\n\t\t\t}\n\n\t\t\tret_val = e1000_write_phy_reg(hw, 0x0000,\n\t\t\t\t\t\t      IGP01E1000_IEEE_RESTART_AUTONEG);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tmsleep(20);\n\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);\n\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\thw->dsp_config_state = e1000_dsp_config_enabled;\n\t\t}\n\n\t\tif (hw->ffe_config_state == e1000_ffe_config_active) {\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);\n\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\t \n\t\t\tret_val = e1000_write_phy_reg(hw, 0x2F5B, 0x0003);\n\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tmsleep(20);\n\n\t\t\tret_val = e1000_write_phy_reg(hw, 0x0000,\n\t\t\t\t\t\t      IGP01E1000_IEEE_FORCE_GIGA);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,\n\t\t\t\t\t\tIGP01E1000_PHY_DSP_FFE_DEFAULT);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tret_val = e1000_write_phy_reg(hw, 0x0000,\n\t\t\t\t\t\t      IGP01E1000_IEEE_RESTART_AUTONEG);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tmsleep(20);\n\n\t\t\t \n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);\n\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\thw->ffe_config_state = e1000_ffe_config_enabled;\n\t\t}\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_set_phy_mode(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 eeprom_data;\n\n\tif ((hw->mac_type == e1000_82545_rev_3) &&\n\t    (hw->media_type == e1000_media_type_copper)) {\n\t\tret_val =\n\t\t    e1000_read_eeprom(hw, EEPROM_PHY_CLASS_WORD, 1,\n\t\t\t\t      &eeprom_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif ((eeprom_data != EEPROM_RESERVED_WORD) &&\n\t\t    (eeprom_data & EEPROM_PHY_CLASS_A)) {\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t\t0x000B);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,\n\t\t\t\t\t\t0x8104);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\thw->phy_reset_disable = false;\n\t\t}\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_set_d3_lplu_state(struct e1000_hw *hw, bool active)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tif (hw->phy_type != e1000_phy_igp)\n\t\treturn E1000_SUCCESS;\n\n\t \n\tif (hw->mac_type == e1000_82541_rev_2 ||\n\t    hw->mac_type == e1000_82547_rev_2) {\n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tif (!active) {\n\t\tif (hw->mac_type == e1000_82541_rev_2 ||\n\t\t    hw->mac_type == e1000_82547_rev_2) {\n\t\t\tphy_data &= ~IGP01E1000_GMII_FLEX_SPD;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\n\t\t\t\t\t\tphy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\tif (hw->smart_speed == e1000_smart_speed_on) {\n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t       &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tphy_data |= IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\tphy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t} else if (hw->smart_speed == e1000_smart_speed_off) {\n\t\t\tret_val =\n\t\t\t    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t       &phy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\n\t\t\tphy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\t\tphy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\t} else if ((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT) ||\n\t\t   (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL) ||\n\t\t   (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {\n\t\tif (hw->mac_type == e1000_82541_rev_2 ||\n\t\t    hw->mac_type == e1000_82547_rev_2) {\n\t\t\tphy_data |= IGP01E1000_GMII_FLEX_SPD;\n\t\t\tret_val =\n\t\t\t    e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\n\t\t\t\t\t\tphy_data);\n\t\t\tif (ret_val)\n\t\t\t\treturn ret_val;\n\t\t}\n\n\t\t \n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t       &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tphy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\n\t\t\t\t\tphy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_set_vco_speed(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 default_page = 0;\n\tu16 phy_data;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546_rev_3:\n\t\tbreak;\n\tdefault:\n\t\treturn E1000_SUCCESS;\n\t}\n\n\t \n\n\tret_val =\n\t    e1000_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, &default_page);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data &= ~M88E1000_PHY_VCO_REG_BIT8;\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tphy_data |= M88E1000_PHY_VCO_REG_BIT11;\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val =\n\t    e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, default_page);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\treturn E1000_SUCCESS;\n}\n\n \nu32 e1000_enable_mng_pass_thru(struct e1000_hw *hw)\n{\n\tu32 manc;\n\n\tif (hw->asf_firmware_present) {\n\t\tmanc = er32(MANC);\n\n\t\tif (!(manc & E1000_MANC_RCV_TCO_EN) ||\n\t\t    !(manc & E1000_MANC_EN_MAC_ADDR_FILTER))\n\t\t\treturn false;\n\t\tif ((manc & E1000_MANC_SMBUS_EN) && !(manc & E1000_MANC_ASF_EN))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic s32 e1000_polarity_reversal_workaround(struct e1000_hw *hw)\n{\n\ts32 ret_val;\n\tu16 mii_status_reg;\n\tu16 i;\n\n\t \n\n\t \n\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFFF);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tfor (i = PHY_FORCE_TIME; i > 0; i--) {\n\t\t \n\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif ((mii_status_reg & ~MII_SR_LINK_STATUS) == 0)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\t \n\tmsleep(1000);\n\n\t \n\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);\n\tif (ret_val)\n\t\treturn ret_val;\n\tmsleep(50);\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFF0);\n\tif (ret_val)\n\t\treturn ret_val;\n\tmsleep(50);\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFF00);\n\tif (ret_val)\n\t\treturn ret_val;\n\tmsleep(50);\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x0000);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tfor (i = PHY_FORCE_TIME; i > 0; i--) {\n\t\t \n\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (mii_status_reg & MII_SR_LINK_STATUS)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_get_auto_rd_done(struct e1000_hw *hw)\n{\n\tmsleep(5);\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_get_phy_cfg_done(struct e1000_hw *hw)\n{\n\tmsleep(10);\n\treturn E1000_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}