{
  "module_name": "e1000_ethtool.c",
  "hash_id": "8450a80f0fe62aa35c2b86b95485a600a84fd509d4e805a6eca73deaf435a9ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000/e1000_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include \"e1000.h\"\n#include <linux/jiffies.h>\n#include <linux/uaccess.h>\n\nenum {NETDEV_STATS, E1000_STATS};\n\nstruct e1000_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint type;\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define E1000_STAT(m)\t\tE1000_STATS, \\\n\t\t\t\tsizeof(((struct e1000_adapter *)0)->m), \\\n\t\t\t\toffsetof(struct e1000_adapter, m)\n#define E1000_NETDEV_STAT(m)\tNETDEV_STATS, \\\n\t\t\t\tsizeof(((struct net_device *)0)->m), \\\n\t\t\t\toffsetof(struct net_device, m)\n\nstatic const struct e1000_stats e1000_gstrings_stats[] = {\n\t{ \"rx_packets\", E1000_STAT(stats.gprc) },\n\t{ \"tx_packets\", E1000_STAT(stats.gptc) },\n\t{ \"rx_bytes\", E1000_STAT(stats.gorcl) },\n\t{ \"tx_bytes\", E1000_STAT(stats.gotcl) },\n\t{ \"rx_broadcast\", E1000_STAT(stats.bprc) },\n\t{ \"tx_broadcast\", E1000_STAT(stats.bptc) },\n\t{ \"rx_multicast\", E1000_STAT(stats.mprc) },\n\t{ \"tx_multicast\", E1000_STAT(stats.mptc) },\n\t{ \"rx_errors\", E1000_STAT(stats.rxerrc) },\n\t{ \"tx_errors\", E1000_STAT(stats.txerrc) },\n\t{ \"tx_dropped\", E1000_NETDEV_STAT(stats.tx_dropped) },\n\t{ \"multicast\", E1000_STAT(stats.mprc) },\n\t{ \"collisions\", E1000_STAT(stats.colc) },\n\t{ \"rx_length_errors\", E1000_STAT(stats.rlerrc) },\n\t{ \"rx_over_errors\", E1000_NETDEV_STAT(stats.rx_over_errors) },\n\t{ \"rx_crc_errors\", E1000_STAT(stats.crcerrs) },\n\t{ \"rx_frame_errors\", E1000_NETDEV_STAT(stats.rx_frame_errors) },\n\t{ \"rx_no_buffer_count\", E1000_STAT(stats.rnbc) },\n\t{ \"rx_missed_errors\", E1000_STAT(stats.mpc) },\n\t{ \"tx_aborted_errors\", E1000_STAT(stats.ecol) },\n\t{ \"tx_carrier_errors\", E1000_STAT(stats.tncrs) },\n\t{ \"tx_fifo_errors\", E1000_NETDEV_STAT(stats.tx_fifo_errors) },\n\t{ \"tx_heartbeat_errors\", E1000_NETDEV_STAT(stats.tx_heartbeat_errors) },\n\t{ \"tx_window_errors\", E1000_STAT(stats.latecol) },\n\t{ \"tx_abort_late_coll\", E1000_STAT(stats.latecol) },\n\t{ \"tx_deferred_ok\", E1000_STAT(stats.dc) },\n\t{ \"tx_single_coll_ok\", E1000_STAT(stats.scc) },\n\t{ \"tx_multi_coll_ok\", E1000_STAT(stats.mcc) },\n\t{ \"tx_timeout_count\", E1000_STAT(tx_timeout_count) },\n\t{ \"tx_restart_queue\", E1000_STAT(restart_queue) },\n\t{ \"rx_long_length_errors\", E1000_STAT(stats.roc) },\n\t{ \"rx_short_length_errors\", E1000_STAT(stats.ruc) },\n\t{ \"rx_align_errors\", E1000_STAT(stats.algnerrc) },\n\t{ \"tx_tcp_seg_good\", E1000_STAT(stats.tsctc) },\n\t{ \"tx_tcp_seg_failed\", E1000_STAT(stats.tsctfc) },\n\t{ \"rx_flow_control_xon\", E1000_STAT(stats.xonrxc) },\n\t{ \"rx_flow_control_xoff\", E1000_STAT(stats.xoffrxc) },\n\t{ \"tx_flow_control_xon\", E1000_STAT(stats.xontxc) },\n\t{ \"tx_flow_control_xoff\", E1000_STAT(stats.xofftxc) },\n\t{ \"rx_long_byte_count\", E1000_STAT(stats.gorcl) },\n\t{ \"rx_csum_offload_good\", E1000_STAT(hw_csum_good) },\n\t{ \"rx_csum_offload_errors\", E1000_STAT(hw_csum_err) },\n\t{ \"alloc_rx_buff_failed\", E1000_STAT(alloc_rx_buff_failed) },\n\t{ \"tx_smbus\", E1000_STAT(stats.mgptc) },\n\t{ \"rx_smbus\", E1000_STAT(stats.mgprc) },\n\t{ \"dropped_smbus\", E1000_STAT(stats.mgpdc) },\n};\n\n#define E1000_QUEUE_STATS_LEN 0\n#define E1000_GLOBAL_STATS_LEN ARRAY_SIZE(e1000_gstrings_stats)\n#define E1000_STATS_LEN (E1000_GLOBAL_STATS_LEN + E1000_QUEUE_STATS_LEN)\nstatic const char e1000_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register test  (offline)\", \"Eeprom test    (offline)\",\n\t\"Interrupt test (offline)\", \"Loopback test  (offline)\",\n\t\"Link test   (on/offline)\"\n};\n\n#define E1000_TEST_LEN\tARRAY_SIZE(e1000_gstrings_test)\n\nstatic int e1000_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 supported, advertising;\n\n\tif (hw->media_type == e1000_media_type_copper) {\n\t\tsupported = (SUPPORTED_10baseT_Half |\n\t\t\t     SUPPORTED_10baseT_Full |\n\t\t\t     SUPPORTED_100baseT_Half |\n\t\t\t     SUPPORTED_100baseT_Full |\n\t\t\t     SUPPORTED_1000baseT_Full|\n\t\t\t     SUPPORTED_Autoneg |\n\t\t\t     SUPPORTED_TP);\n\t\tadvertising = ADVERTISED_TP;\n\n\t\tif (hw->autoneg == 1) {\n\t\t\tadvertising |= ADVERTISED_Autoneg;\n\t\t\t \n\t\t\tadvertising |= hw->autoneg_advertised;\n\t\t}\n\n\t\tcmd->base.port = PORT_TP;\n\t\tcmd->base.phy_address = hw->phy_addr;\n\t} else {\n\t\tsupported   = (SUPPORTED_1000baseT_Full |\n\t\t\t       SUPPORTED_FIBRE |\n\t\t\t       SUPPORTED_Autoneg);\n\n\t\tadvertising = (ADVERTISED_1000baseT_Full |\n\t\t\t       ADVERTISED_FIBRE |\n\t\t\t       ADVERTISED_Autoneg);\n\n\t\tcmd->base.port = PORT_FIBRE;\n\t}\n\n\tif (er32(STATUS) & E1000_STATUS_LU) {\n\t\te1000_get_speed_and_duplex(hw, &adapter->link_speed,\n\t\t\t\t\t   &adapter->link_duplex);\n\t\tcmd->base.speed = adapter->link_speed;\n\n\t\t \n\t\tif (adapter->link_duplex == FULL_DUPLEX)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.autoneg = ((hw->media_type == e1000_media_type_fiber) ||\n\t\t\t hw->autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\t \n\tif ((hw->media_type == e1000_media_type_copper) &&\n\t    netif_carrier_ok(netdev))\n\t\tcmd->base.eth_tp_mdix = (!!adapter->phy_info.mdix_mode ?\n\t\t\t\t     ETH_TP_MDI_X : ETH_TP_MDI);\n\telse\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\n\tif (hw->mdix == AUTO_ALL_MODES)\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\n\telse\n\t\tcmd->base.eth_tp_mdix_ctrl = hw->mdix;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int e1000_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\tif (hw->media_type != e1000_media_type_copper)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif ((cmd->base.eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&\n\t\t    (cmd->base.autoneg != AUTONEG_ENABLE)) {\n\t\t\te_err(drv, \"forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\thw->autoneg = 1;\n\t\tif (hw->media_type == e1000_media_type_fiber)\n\t\t\thw->autoneg_advertised = ADVERTISED_1000baseT_Full |\n\t\t\t\t\t\t ADVERTISED_FIBRE |\n\t\t\t\t\t\t ADVERTISED_Autoneg;\n\t\telse\n\t\t\thw->autoneg_advertised = advertising |\n\t\t\t\t\t\t ADVERTISED_TP |\n\t\t\t\t\t\t ADVERTISED_Autoneg;\n\t} else {\n\t\tu32 speed = cmd->base.speed;\n\t\t \n\t\tif (e1000_set_spd_dplx(adapter, speed, cmd->base.duplex)) {\n\t\t\tclear_bit(__E1000_RESETTING, &adapter->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (cmd->base.eth_tp_mdix_ctrl) {\n\t\tif (cmd->base.eth_tp_mdix_ctrl == ETH_TP_MDI_AUTO)\n\t\t\thw->mdix = AUTO_ALL_MODES;\n\t\telse\n\t\t\thw->mdix = cmd->base.eth_tp_mdix_ctrl;\n\t}\n\n\t \n\n\tif (netif_running(adapter->netdev)) {\n\t\te1000_down(adapter);\n\t\te1000_up(adapter);\n\t} else {\n\t\te1000_reset(adapter);\n\t}\n\tclear_bit(__E1000_RESETTING, &adapter->flags);\n\treturn 0;\n}\n\nstatic u32 e1000_get_link(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (!netif_carrier_ok(netdev))\n\t\tadapter->hw.get_link_status = 1;\n\n\treturn e1000_has_link(adapter);\n}\n\nstatic void e1000_get_pauseparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tpause->autoneg =\n\t\t(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);\n\n\tif (hw->fc == E1000_FC_RX_PAUSE) {\n\t\tpause->rx_pause = 1;\n\t} else if (hw->fc == E1000_FC_TX_PAUSE) {\n\t\tpause->tx_pause = 1;\n\t} else if (hw->fc == E1000_FC_FULL) {\n\t\tpause->rx_pause = 1;\n\t\tpause->tx_pause = 1;\n\t}\n}\n\nstatic int e1000_set_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint retval = 0;\n\n\tadapter->fc_autoneg = pause->autoneg;\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\n\tif (pause->rx_pause && pause->tx_pause)\n\t\thw->fc = E1000_FC_FULL;\n\telse if (pause->rx_pause && !pause->tx_pause)\n\t\thw->fc = E1000_FC_RX_PAUSE;\n\telse if (!pause->rx_pause && pause->tx_pause)\n\t\thw->fc = E1000_FC_TX_PAUSE;\n\telse if (!pause->rx_pause && !pause->tx_pause)\n\t\thw->fc = E1000_FC_NONE;\n\n\thw->original_fc = hw->fc;\n\n\tif (adapter->fc_autoneg == AUTONEG_ENABLE) {\n\t\tif (netif_running(adapter->netdev)) {\n\t\t\te1000_down(adapter);\n\t\t\te1000_up(adapter);\n\t\t} else {\n\t\t\te1000_reset(adapter);\n\t\t}\n\t} else\n\t\tretval = ((hw->media_type == e1000_media_type_fiber) ?\n\t\t\t  e1000_setup_link(hw) : e1000_force_mac_fc(hw));\n\n\tclear_bit(__E1000_RESETTING, &adapter->flags);\n\treturn retval;\n}\n\nstatic u32 e1000_get_msglevel(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->msg_enable;\n}\n\nstatic void e1000_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->msg_enable = data;\n}\n\nstatic int e1000_get_regs_len(struct net_device *netdev)\n{\n#define E1000_REGS_LEN 32\n\treturn E1000_REGS_LEN * sizeof(u32);\n}\n\nstatic void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs,\n\t\t\t   void *p)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu16 phy_data;\n\n\tmemset(p, 0, E1000_REGS_LEN * sizeof(u32));\n\n\tregs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;\n\n\tregs_buff[0]  = er32(CTRL);\n\tregs_buff[1]  = er32(STATUS);\n\n\tregs_buff[2]  = er32(RCTL);\n\tregs_buff[3]  = er32(RDLEN);\n\tregs_buff[4]  = er32(RDH);\n\tregs_buff[5]  = er32(RDT);\n\tregs_buff[6]  = er32(RDTR);\n\n\tregs_buff[7]  = er32(TCTL);\n\tregs_buff[8]  = er32(TDLEN);\n\tregs_buff[9]  = er32(TDH);\n\tregs_buff[10] = er32(TDT);\n\tregs_buff[11] = er32(TIDV);\n\n\tregs_buff[12] = hw->phy_type;   \n\tif (hw->phy_type == e1000_phy_igp) {\n\t\te1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t    IGP01E1000_PHY_AGC_A);\n\t\te1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_A &\n\t\t\t\t   IGP01E1000_PHY_PAGE_SELECT, &phy_data);\n\t\tregs_buff[13] = (u32)phy_data;  \n\t\te1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t    IGP01E1000_PHY_AGC_B);\n\t\te1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_B &\n\t\t\t\t   IGP01E1000_PHY_PAGE_SELECT, &phy_data);\n\t\tregs_buff[14] = (u32)phy_data;  \n\t\te1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t    IGP01E1000_PHY_AGC_C);\n\t\te1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_C &\n\t\t\t\t   IGP01E1000_PHY_PAGE_SELECT, &phy_data);\n\t\tregs_buff[15] = (u32)phy_data;  \n\t\te1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t    IGP01E1000_PHY_AGC_D);\n\t\te1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_D &\n\t\t\t\t   IGP01E1000_PHY_PAGE_SELECT, &phy_data);\n\t\tregs_buff[16] = (u32)phy_data;  \n\t\tregs_buff[17] = 0;  \n\t\te1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);\n\t\te1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS &\n\t\t\t\t   IGP01E1000_PHY_PAGE_SELECT, &phy_data);\n\t\tregs_buff[18] = (u32)phy_data;  \n\t\te1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t    IGP01E1000_PHY_PCS_INIT_REG);\n\t\te1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG &\n\t\t\t\t   IGP01E1000_PHY_PAGE_SELECT, &phy_data);\n\t\tregs_buff[19] = (u32)phy_data;  \n\t\tregs_buff[20] = 0;  \n\t\tregs_buff[22] = 0;  \n\t\tregs_buff[23] = regs_buff[18];  \n\t\te1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);\n\t} else {\n\t\te1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\t\tregs_buff[13] = (u32)phy_data;  \n\t\tregs_buff[14] = 0;   \n\t\tregs_buff[15] = 0;   \n\t\tregs_buff[16] = 0;   \n\t\te1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\t\tregs_buff[17] = (u32)phy_data;  \n\t\tregs_buff[18] = regs_buff[13];  \n\t\tregs_buff[19] = 0;   \n\t\tregs_buff[20] = regs_buff[17];  \n\t\t \n\t\tregs_buff[22] = adapter->phy_stats.receive_errors;\n\t\tregs_buff[23] = regs_buff[13];  \n\t}\n\tregs_buff[21] = adapter->phy_stats.idle_errors;   \n\te1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\n\tregs_buff[24] = (u32)phy_data;   \n\tregs_buff[25] = regs_buff[24];   \n\tif (hw->mac_type >= e1000_82540 &&\n\t    hw->media_type == e1000_media_type_copper) {\n\t\tregs_buff[26] = er32(MANC);\n\t}\n}\n\nstatic int e1000_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\treturn hw->eeprom.word_size * 2;\n}\n\nstatic int e1000_get_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tint first_word, last_word;\n\tint ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tif (hw->eeprom.type == e1000_eeprom_spi)\n\t\tret_val = e1000_read_eeprom(hw, first_word,\n\t\t\t\t\t    last_word - first_word + 1,\n\t\t\t\t\t    eeprom_buff);\n\telse {\n\t\tfor (i = 0; i < last_word - first_word + 1; i++) {\n\t\t\tret_val = e1000_read_eeprom(hw, first_word + i, 1,\n\t\t\t\t\t\t    &eeprom_buff[i]);\n\t\t\tif (ret_val)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1),\n\t       eeprom->len);\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n}\n\nstatic int e1000_set_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 *eeprom_buff;\n\tvoid *ptr;\n\tint max_len, first_word, last_word, ret_val = 0;\n\tu16 i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\n\t\treturn -EFAULT;\n\n\tmax_len = hw->eeprom.word_size * 2;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_buff = kmalloc(max_len, GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tptr = (void *)eeprom_buff;\n\n\tif (eeprom->offset & 1) {\n\t\t \n\t\tret_val = e1000_read_eeprom(hw, first_word, 1,\n\t\t\t\t\t    &eeprom_buff[0]);\n\t\tptr++;\n\t}\n\tif (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {\n\t\t \n\t\tret_val = e1000_read_eeprom(hw, last_word, 1,\n\t\t\t\t\t    &eeprom_buff[last_word - first_word]);\n\t}\n\n\t \n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tle16_to_cpus(&eeprom_buff[i]);\n\n\tmemcpy(ptr, bytes, eeprom->len);\n\n\tfor (i = 0; i < last_word - first_word + 1; i++)\n\t\tcpu_to_le16s(&eeprom_buff[i]);\n\n\tret_val = e1000_write_eeprom(hw, first_word,\n\t\t\t\t     last_word - first_word + 1, eeprom_buff);\n\n\t \n\tif ((ret_val == 0) && (first_word <= EEPROM_CHECKSUM_REG))\n\t\te1000_update_eeprom_checksum(hw);\n\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic void e1000_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver,  e1000_driver_name,\n\t\tsizeof(drvinfo->driver));\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void e1000_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\te1000_mac_type mac_type = hw->mac_type;\n\tstruct e1000_tx_ring *txdr = adapter->tx_ring;\n\tstruct e1000_rx_ring *rxdr = adapter->rx_ring;\n\n\tring->rx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_RXD :\n\t\tE1000_MAX_82544_RXD;\n\tring->tx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_TXD :\n\t\tE1000_MAX_82544_TXD;\n\tring->rx_pending = rxdr->count;\n\tring->tx_pending = txdr->count;\n}\n\nstatic int e1000_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\te1000_mac_type mac_type = hw->mac_type;\n\tstruct e1000_tx_ring *txdr, *tx_old;\n\tstruct e1000_rx_ring *rxdr, *rx_old;\n\tint i, err;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\n\tif (netif_running(adapter->netdev))\n\t\te1000_down(adapter);\n\n\ttx_old = adapter->tx_ring;\n\trx_old = adapter->rx_ring;\n\n\terr = -ENOMEM;\n\ttxdr = kcalloc(adapter->num_tx_queues, sizeof(struct e1000_tx_ring),\n\t\t       GFP_KERNEL);\n\tif (!txdr)\n\t\tgoto err_alloc_tx;\n\n\trxdr = kcalloc(adapter->num_rx_queues, sizeof(struct e1000_rx_ring),\n\t\t       GFP_KERNEL);\n\tif (!rxdr)\n\t\tgoto err_alloc_rx;\n\n\tadapter->tx_ring = txdr;\n\tadapter->rx_ring = rxdr;\n\n\trxdr->count = max(ring->rx_pending, (u32)E1000_MIN_RXD);\n\trxdr->count = min(rxdr->count, (u32)(mac_type < e1000_82544 ?\n\t\t\t  E1000_MAX_RXD : E1000_MAX_82544_RXD));\n\trxdr->count = ALIGN(rxdr->count, REQ_RX_DESCRIPTOR_MULTIPLE);\n\ttxdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);\n\ttxdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?\n\t\t\t  E1000_MAX_TXD : E1000_MAX_82544_TXD));\n\ttxdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\ttxdr[i].count = txdr->count;\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\trxdr[i].count = rxdr->count;\n\n\terr = 0;\n\tif (netif_running(adapter->netdev)) {\n\t\t \n\t\terr = e1000_setup_all_rx_resources(adapter);\n\t\tif (err)\n\t\t\tgoto err_setup_rx;\n\t\terr = e1000_setup_all_tx_resources(adapter);\n\t\tif (err)\n\t\t\tgoto err_setup_tx;\n\n\t\t \n\n\t\tadapter->rx_ring = rx_old;\n\t\tadapter->tx_ring = tx_old;\n\t\te1000_free_all_rx_resources(adapter);\n\t\te1000_free_all_tx_resources(adapter);\n\t\tadapter->rx_ring = rxdr;\n\t\tadapter->tx_ring = txdr;\n\t\terr = e1000_up(adapter);\n\t}\n\tkfree(tx_old);\n\tkfree(rx_old);\n\n\tclear_bit(__E1000_RESETTING, &adapter->flags);\n\treturn err;\n\nerr_setup_tx:\n\te1000_free_all_rx_resources(adapter);\nerr_setup_rx:\n\tadapter->rx_ring = rx_old;\n\tadapter->tx_ring = tx_old;\n\tkfree(rxdr);\nerr_alloc_rx:\n\tkfree(txdr);\nerr_alloc_tx:\n\tif (netif_running(adapter->netdev))\n\t\te1000_up(adapter);\n\tclear_bit(__E1000_RESETTING, &adapter->flags);\n\treturn err;\n}\n\nstatic bool reg_pattern_test(struct e1000_adapter *adapter, u64 *data, int reg,\n\t\t\t     u32 mask, u32 write)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstatic const u32 test[] = {\n\t\t0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF\n\t};\n\tu8 __iomem *address = hw->hw_addr + reg;\n\tu32 read;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test); i++) {\n\t\twritel(write & test[i], address);\n\t\tread = readl(address);\n\t\tif (read != (write & test[i] & mask)) {\n\t\t\te_err(drv, \"pattern test reg %04X failed: \"\n\t\t\t      \"got 0x%08X expected 0x%08X\\n\",\n\t\t\t      reg, read, (write & test[i] & mask));\n\t\t\t*data = reg;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data, int reg,\n\t\t\t      u32 mask, u32 write)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu8 __iomem *address = hw->hw_addr + reg;\n\tu32 read;\n\n\twritel(write & mask, address);\n\tread = readl(address);\n\tif ((read & mask) != (write & mask)) {\n\t\te_err(drv, \"set/check reg %04X test failed: \"\n\t\t      \"got 0x%08X expected 0x%08X\\n\",\n\t\t      reg, (read & mask), (write & mask));\n\t\t*data = reg;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#define REG_PATTERN_TEST(reg, mask, write)\t\t\t     \\\n\tdo {\t\t\t\t\t\t\t     \\\n\t\tif (reg_pattern_test(adapter, data,\t\t     \\\n\t\t\t     (hw->mac_type >= e1000_82543)   \\\n\t\t\t     ? E1000_##reg : E1000_82542_##reg,\t     \\\n\t\t\t     mask, write))\t\t\t     \\\n\t\t\treturn 1;\t\t\t\t     \\\n\t} while (0)\n\n#define REG_SET_AND_CHECK(reg, mask, write)\t\t\t     \\\n\tdo {\t\t\t\t\t\t\t     \\\n\t\tif (reg_set_and_check(adapter, data,\t\t     \\\n\t\t\t      (hw->mac_type >= e1000_82543)  \\\n\t\t\t      ? E1000_##reg : E1000_82542_##reg,     \\\n\t\t\t      mask, write))\t\t\t     \\\n\t\t\treturn 1;\t\t\t\t     \\\n\t} while (0)\n\nstatic int e1000_reg_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tu32 value, before, after;\n\tu32 i, toggle;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\n\t \n\ttoggle = 0xFFFFF833;\n\n\tbefore = er32(STATUS);\n\tvalue = (er32(STATUS) & toggle);\n\tew32(STATUS, toggle);\n\tafter = er32(STATUS) & toggle;\n\tif (value != after) {\n\t\te_err(drv, \"failed STATUS register test got: \"\n\t\t      \"0x%08X expected: 0x%08X\\n\", after, value);\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\t \n\tew32(STATUS, before);\n\n\tREG_PATTERN_TEST(FCAL, 0xFFFFFFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(FCAH, 0x0000FFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(FCT, 0x0000FFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(VET, 0x0000FFFF, 0xFFFFFFFF);\n\n\tREG_PATTERN_TEST(RDTR, 0x0000FFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(RDBAH, 0xFFFFFFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(RDLEN, 0x000FFF80, 0x000FFFFF);\n\tREG_PATTERN_TEST(RDH, 0x0000FFFF, 0x0000FFFF);\n\tREG_PATTERN_TEST(RDT, 0x0000FFFF, 0x0000FFFF);\n\tREG_PATTERN_TEST(FCRTH, 0x0000FFF8, 0x0000FFF8);\n\tREG_PATTERN_TEST(FCTTV, 0x0000FFFF, 0x0000FFFF);\n\tREG_PATTERN_TEST(TIPG, 0x3FFFFFFF, 0x3FFFFFFF);\n\tREG_PATTERN_TEST(TDBAH, 0xFFFFFFFF, 0xFFFFFFFF);\n\tREG_PATTERN_TEST(TDLEN, 0x000FFF80, 0x000FFFFF);\n\n\tREG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x00000000);\n\n\tbefore = 0x06DFB3FE;\n\tREG_SET_AND_CHECK(RCTL, before, 0x003FFFFB);\n\tREG_SET_AND_CHECK(TCTL, 0xFFFFFFFF, 0x00000000);\n\n\tif (hw->mac_type >= e1000_82543) {\n\t\tREG_SET_AND_CHECK(RCTL, before, 0xFFFFFFFF);\n\t\tREG_PATTERN_TEST(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);\n\t\tREG_PATTERN_TEST(TXCW, 0xC000FFFF, 0x0000FFFF);\n\t\tREG_PATTERN_TEST(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);\n\t\tREG_PATTERN_TEST(TIDV, 0x0000FFFF, 0x0000FFFF);\n\t\tvalue = E1000_RAR_ENTRIES;\n\t\tfor (i = 0; i < value; i++) {\n\t\t\tREG_PATTERN_TEST(RA + (((i << 1) + 1) << 2),\n\t\t\t\t\t 0x8003FFFF, 0xFFFFFFFF);\n\t\t}\n\t} else {\n\t\tREG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x01FFFFFF);\n\t\tREG_PATTERN_TEST(RDBAL, 0xFFFFF000, 0xFFFFFFFF);\n\t\tREG_PATTERN_TEST(TXCW, 0x0000FFFF, 0x0000FFFF);\n\t\tREG_PATTERN_TEST(TDBAL, 0xFFFFF000, 0xFFFFFFFF);\n\t}\n\n\tvalue = E1000_MC_TBL_SIZE;\n\tfor (i = 0; i < value; i++)\n\t\tREG_PATTERN_TEST(MTA + (i << 2), 0xFFFFFFFF, 0xFFFFFFFF);\n\n\t*data = 0;\n\treturn 0;\n}\n\nstatic int e1000_eeprom_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 temp;\n\tu16 checksum = 0;\n\tu16 i;\n\n\t*data = 0;\n\t \n\tfor (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {\n\t\tif ((e1000_read_eeprom(hw, i, 1, &temp)) < 0) {\n\t\t\t*data = 1;\n\t\t\tbreak;\n\t\t}\n\t\tchecksum += temp;\n\t}\n\n\t \n\tif ((checksum != (u16)EEPROM_SUM) && !(*data))\n\t\t*data = 2;\n\n\treturn *data;\n}\n\nstatic irqreturn_t e1000_test_intr(int irq, void *data)\n{\n\tstruct net_device *netdev = (struct net_device *)data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tadapter->test_icr |= er32(ICR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 mask, i = 0;\n\tbool shared_int = true;\n\tu32 irq = adapter->pdev->irq;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t*data = 0;\n\n\t \n\tif (!request_irq(irq, e1000_test_intr, IRQF_PROBE_SHARED, netdev->name,\n\t\t\t netdev))\n\t\tshared_int = false;\n\telse if (request_irq(irq, e1000_test_intr, IRQF_SHARED,\n\t\t\t     netdev->name, netdev)) {\n\t\t*data = 1;\n\t\treturn -1;\n\t}\n\te_info(hw, \"testing %s interrupt\\n\", (shared_int ?\n\t       \"shared\" : \"unshared\"));\n\n\t \n\tew32(IMC, 0xFFFFFFFF);\n\tE1000_WRITE_FLUSH();\n\tmsleep(10);\n\n\t \n\tfor (; i < 10; i++) {\n\t\t \n\t\tmask = 1 << i;\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\t\t\tew32(IMC, mask);\n\t\t\tew32(ICS, mask);\n\t\t\tE1000_WRITE_FLUSH();\n\t\t\tmsleep(10);\n\n\t\t\tif (adapter->test_icr & mask) {\n\t\t\t\t*data = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tadapter->test_icr = 0;\n\t\tew32(IMS, mask);\n\t\tew32(ICS, mask);\n\t\tE1000_WRITE_FLUSH();\n\t\tmsleep(10);\n\n\t\tif (!(adapter->test_icr & mask)) {\n\t\t\t*data = 4;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!shared_int) {\n\t\t\t \n\t\t\tadapter->test_icr = 0;\n\t\t\tew32(IMC, ~mask & 0x00007FFF);\n\t\t\tew32(ICS, ~mask & 0x00007FFF);\n\t\t\tE1000_WRITE_FLUSH();\n\t\t\tmsleep(10);\n\n\t\t\tif (adapter->test_icr) {\n\t\t\t\t*data = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tew32(IMC, 0xFFFFFFFF);\n\tE1000_WRITE_FLUSH();\n\tmsleep(10);\n\n\t \n\tfree_irq(irq, netdev);\n\n\treturn *data;\n}\n\nstatic void e1000_free_desc_rings(struct e1000_adapter *adapter)\n{\n\tstruct e1000_tx_ring *txdr = &adapter->test_tx_ring;\n\tstruct e1000_rx_ring *rxdr = &adapter->test_rx_ring;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i;\n\n\tif (txdr->desc && txdr->buffer_info) {\n\t\tfor (i = 0; i < txdr->count; i++) {\n\t\t\tif (txdr->buffer_info[i].dma)\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t\t txdr->buffer_info[i].dma,\n\t\t\t\t\t\t txdr->buffer_info[i].length,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(txdr->buffer_info[i].skb);\n\t\t}\n\t}\n\n\tif (rxdr->desc && rxdr->buffer_info) {\n\t\tfor (i = 0; i < rxdr->count; i++) {\n\t\t\tif (rxdr->buffer_info[i].dma)\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t\t rxdr->buffer_info[i].dma,\n\t\t\t\t\t\t E1000_RXBUFFER_2048,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tkfree(rxdr->buffer_info[i].rxbuf.data);\n\t\t}\n\t}\n\n\tif (txdr->desc) {\n\t\tdma_free_coherent(&pdev->dev, txdr->size, txdr->desc,\n\t\t\t\t  txdr->dma);\n\t\ttxdr->desc = NULL;\n\t}\n\tif (rxdr->desc) {\n\t\tdma_free_coherent(&pdev->dev, rxdr->size, rxdr->desc,\n\t\t\t\t  rxdr->dma);\n\t\trxdr->desc = NULL;\n\t}\n\n\tkfree(txdr->buffer_info);\n\ttxdr->buffer_info = NULL;\n\tkfree(rxdr->buffer_info);\n\trxdr->buffer_info = NULL;\n}\n\nstatic int e1000_setup_desc_rings(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_tx_ring *txdr = &adapter->test_tx_ring;\n\tstruct e1000_rx_ring *rxdr = &adapter->test_rx_ring;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 rctl;\n\tint i, ret_val;\n\n\t \n\n\tif (!txdr->count)\n\t\ttxdr->count = E1000_DEFAULT_TXD;\n\n\ttxdr->buffer_info = kcalloc(txdr->count, sizeof(struct e1000_tx_buffer),\n\t\t\t\t    GFP_KERNEL);\n\tif (!txdr->buffer_info) {\n\t\tret_val = 1;\n\t\tgoto err_nomem;\n\t}\n\n\ttxdr->size = txdr->count * sizeof(struct e1000_tx_desc);\n\ttxdr->size = ALIGN(txdr->size, 4096);\n\ttxdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!txdr->desc) {\n\t\tret_val = 2;\n\t\tgoto err_nomem;\n\t}\n\ttxdr->next_to_use = txdr->next_to_clean = 0;\n\n\tew32(TDBAL, ((u64)txdr->dma & 0x00000000FFFFFFFF));\n\tew32(TDBAH, ((u64)txdr->dma >> 32));\n\tew32(TDLEN, txdr->count * sizeof(struct e1000_tx_desc));\n\tew32(TDH, 0);\n\tew32(TDT, 0);\n\tew32(TCTL, E1000_TCTL_PSP | E1000_TCTL_EN |\n\t     E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT |\n\t     E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);\n\n\tfor (i = 0; i < txdr->count; i++) {\n\t\tstruct e1000_tx_desc *tx_desc = E1000_TX_DESC(*txdr, i);\n\t\tstruct sk_buff *skb;\n\t\tunsigned int size = 1024;\n\n\t\tskb = alloc_skb(size, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret_val = 3;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\tskb_put(skb, size);\n\t\ttxdr->buffer_info[i].skb = skb;\n\t\ttxdr->buffer_info[i].length = skb->len;\n\t\ttxdr->buffer_info[i].dma =\n\t\t\tdma_map_single(&pdev->dev, skb->data, skb->len,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, txdr->buffer_info[i].dma)) {\n\t\t\tret_val = 4;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\ttx_desc->buffer_addr = cpu_to_le64(txdr->buffer_info[i].dma);\n\t\ttx_desc->lower.data = cpu_to_le32(skb->len);\n\t\ttx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP |\n\t\t\t\t\t\t   E1000_TXD_CMD_IFCS |\n\t\t\t\t\t\t   E1000_TXD_CMD_RPS);\n\t\ttx_desc->upper.data = 0;\n\t}\n\n\t \n\n\tif (!rxdr->count)\n\t\trxdr->count = E1000_DEFAULT_RXD;\n\n\trxdr->buffer_info = kcalloc(rxdr->count, sizeof(struct e1000_rx_buffer),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rxdr->buffer_info) {\n\t\tret_val = 5;\n\t\tgoto err_nomem;\n\t}\n\n\trxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);\n\trxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!rxdr->desc) {\n\t\tret_val = 6;\n\t\tgoto err_nomem;\n\t}\n\trxdr->next_to_use = rxdr->next_to_clean = 0;\n\n\trctl = er32(RCTL);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\tew32(RDBAL, ((u64)rxdr->dma & 0xFFFFFFFF));\n\tew32(RDBAH, ((u64)rxdr->dma >> 32));\n\tew32(RDLEN, rxdr->size);\n\tew32(RDH, 0);\n\tew32(RDT, 0);\n\trctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |\n\t\tE1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |\n\t\t(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);\n\tew32(RCTL, rctl);\n\n\tfor (i = 0; i < rxdr->count; i++) {\n\t\tstruct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rxdr, i);\n\t\tu8 *buf;\n\n\t\tbuf = kzalloc(E1000_RXBUFFER_2048 + NET_SKB_PAD + NET_IP_ALIGN,\n\t\t\t      GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret_val = 7;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\trxdr->buffer_info[i].rxbuf.data = buf;\n\n\t\trxdr->buffer_info[i].dma =\n\t\t\tdma_map_single(&pdev->dev,\n\t\t\t\t       buf + NET_SKB_PAD + NET_IP_ALIGN,\n\t\t\t\t       E1000_RXBUFFER_2048, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, rxdr->buffer_info[i].dma)) {\n\t\t\tret_val = 8;\n\t\t\tgoto err_nomem;\n\t\t}\n\t\trx_desc->buffer_addr = cpu_to_le64(rxdr->buffer_info[i].dma);\n\t}\n\n\treturn 0;\n\nerr_nomem:\n\te1000_free_desc_rings(adapter);\n\treturn ret_val;\n}\n\nstatic void e1000_phy_disable_receiver(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\te1000_write_phy_reg(hw, 29, 0x001F);\n\te1000_write_phy_reg(hw, 30, 0x8FFC);\n\te1000_write_phy_reg(hw, 29, 0x001A);\n\te1000_write_phy_reg(hw, 30, 0x8FF0);\n}\n\nstatic void e1000_phy_reset_clk_and_crs(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 phy_reg;\n\n\t \n\te1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);\n\tphy_reg |= M88E1000_EPSCR_TX_CLK_25;\n\te1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_reg);\n\n\t \n\te1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);\n\tphy_reg |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\n\te1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);\n}\n\nstatic int e1000_nonintegrated_phy_loopback(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_reg;\n\tu16 phy_reg;\n\n\t \n\n\tctrl_reg = er32(CTRL);\n\tctrl_reg |= (E1000_CTRL_ILOS |\t\t \n\t\t     E1000_CTRL_FRCSPD |\t \n\t\t     E1000_CTRL_FRCDPX |\t \n\t\t     E1000_CTRL_SPD_1000 |\t \n\t\t     E1000_CTRL_FD);\t\t \n\n\tew32(CTRL, ctrl_reg);\n\n\t \n\te1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);\n\n\t \n\tphy_reg &= ~M88E1000_PSCR_AUTO_X_MODE;\n\te1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);\n\n\t \n\te1000_phy_reset(hw);\n\n\t \n\te1000_phy_reset_clk_and_crs(adapter);\n\n\te1000_write_phy_reg(hw, PHY_CTRL, 0x8100);\n\n\t \n\tudelay(500);\n\n\t \n\te1000_phy_reset_clk_and_crs(adapter);\n\n\t \n\te1000_phy_disable_receiver(adapter);\n\n\t \n\te1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\n\tphy_reg |= MII_CR_LOOPBACK;\n\te1000_write_phy_reg(hw, PHY_CTRL, phy_reg);\n\n\t \n\te1000_phy_reset_clk_and_crs(adapter);\n\n\t \n\te1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\n\tif (phy_reg != 0x4100)\n\t\treturn 9;\n\n\te1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);\n\tif (phy_reg != 0x0070)\n\t\treturn 10;\n\n\te1000_read_phy_reg(hw, 29, &phy_reg);\n\tif (phy_reg != 0x001A)\n\t\treturn 11;\n\n\treturn 0;\n}\n\nstatic int e1000_integrated_phy_loopback(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_reg = 0;\n\tu32 stat_reg = 0;\n\n\thw->autoneg = false;\n\n\tif (hw->phy_type == e1000_phy_m88) {\n\t\t \n\t\te1000_write_phy_reg(hw,\n\t\t\t\t    M88E1000_PHY_SPEC_CTRL, 0x0808);\n\t\t \n\t\te1000_write_phy_reg(hw, PHY_CTRL, 0x9140);\n\t\t \n\t\te1000_write_phy_reg(hw, PHY_CTRL, 0x8140);\n\t}\n\n\tctrl_reg = er32(CTRL);\n\n\t \n\te1000_write_phy_reg(hw, PHY_CTRL, 0x4140);\n\n\t \n\tctrl_reg = er32(CTRL);\n\tctrl_reg &= ~E1000_CTRL_SPD_SEL;  \n\tctrl_reg |= (E1000_CTRL_FRCSPD |  \n\t\t\tE1000_CTRL_FRCDPX |  \n\t\t\tE1000_CTRL_SPD_1000 | \n\t\t\tE1000_CTRL_FD);  \n\n\tif (hw->media_type == e1000_media_type_copper &&\n\t    hw->phy_type == e1000_phy_m88)\n\t\tctrl_reg |= E1000_CTRL_ILOS;  \n\telse {\n\t\t \n\t\tstat_reg = er32(STATUS);\n\t\tif ((stat_reg & E1000_STATUS_FD) == 0)\n\t\t\tctrl_reg |= (E1000_CTRL_ILOS | E1000_CTRL_SLU);\n\t}\n\n\tew32(CTRL, ctrl_reg);\n\n\t \n\tif (hw->phy_type == e1000_phy_m88)\n\t\te1000_phy_disable_receiver(adapter);\n\n\tudelay(500);\n\n\treturn 0;\n}\n\nstatic int e1000_set_phy_loopback(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 phy_reg = 0;\n\tu16 count = 0;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82543:\n\t\tif (hw->media_type == e1000_media_type_copper) {\n\t\t\t \n\t\t\twhile (e1000_nonintegrated_phy_loopback(adapter) &&\n\t\t\t       count++ < 10);\n\t\t\tif (count < 11)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase e1000_82544:\n\tcase e1000_82540:\n\tcase e1000_82545:\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546:\n\tcase e1000_82546_rev_3:\n\tcase e1000_82541:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547:\n\tcase e1000_82547_rev_2:\n\t\treturn e1000_integrated_phy_loopback(adapter);\n\tdefault:\n\t\t \n\t\te1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\n\t\tphy_reg |= MII_CR_LOOPBACK;\n\t\te1000_write_phy_reg(hw, PHY_CTRL, phy_reg);\n\t\treturn 0;\n\t}\n\n\treturn 8;\n}\n\nstatic int e1000_setup_loopback_test(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (hw->media_type == e1000_media_type_fiber ||\n\t    hw->media_type == e1000_media_type_internal_serdes) {\n\t\tswitch (hw->mac_type) {\n\t\tcase e1000_82545:\n\t\tcase e1000_82546:\n\t\tcase e1000_82545_rev_3:\n\t\tcase e1000_82546_rev_3:\n\t\t\treturn e1000_set_phy_loopback(adapter);\n\t\tdefault:\n\t\t\trctl = er32(RCTL);\n\t\t\trctl |= E1000_RCTL_LBM_TCVR;\n\t\t\tew32(RCTL, rctl);\n\t\t\treturn 0;\n\t\t}\n\t} else if (hw->media_type == e1000_media_type_copper) {\n\t\treturn e1000_set_phy_loopback(adapter);\n\t}\n\n\treturn 7;\n}\n\nstatic void e1000_loopback_cleanup(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\tu16 phy_reg;\n\n\trctl = er32(RCTL);\n\trctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);\n\tew32(RCTL, rctl);\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82545:\n\tcase e1000_82546:\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546_rev_3:\n\tdefault:\n\t\thw->autoneg = true;\n\t\te1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\n\t\tif (phy_reg & MII_CR_LOOPBACK) {\n\t\t\tphy_reg &= ~MII_CR_LOOPBACK;\n\t\t\te1000_write_phy_reg(hw, PHY_CTRL, phy_reg);\n\t\t\te1000_phy_reset(hw);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void e1000_create_lbtest_frame(struct sk_buff *skb,\n\t\t\t\t      unsigned int frame_size)\n{\n\tmemset(skb->data, 0xFF, frame_size);\n\tframe_size &= ~1;\n\tmemset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);\n\tskb->data[frame_size / 2 + 10] = 0xBE;\n\tskb->data[frame_size / 2 + 12] = 0xAF;\n}\n\nstatic int e1000_check_lbtest_frame(const unsigned char *data,\n\t\t\t\t    unsigned int frame_size)\n{\n\tframe_size &= ~1;\n\tif (*(data + 3) == 0xFF) {\n\t\tif ((*(data + frame_size / 2 + 10) == 0xBE) &&\n\t\t    (*(data + frame_size / 2 + 12) == 0xAF)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 13;\n}\n\nstatic int e1000_run_loopback_test(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_tx_ring *txdr = &adapter->test_tx_ring;\n\tstruct e1000_rx_ring *rxdr = &adapter->test_rx_ring;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i, j, k, l, lc, good_cnt, ret_val = 0;\n\tunsigned long time;\n\n\tew32(RDT, rxdr->count - 1);\n\n\t \n\n\tif (rxdr->count <= txdr->count)\n\t\tlc = ((txdr->count / 64) * 2) + 1;\n\telse\n\t\tlc = ((rxdr->count / 64) * 2) + 1;\n\n\tk = l = 0;\n\tfor (j = 0; j <= lc; j++) {  \n\t\tfor (i = 0; i < 64; i++) {  \n\t\t\te1000_create_lbtest_frame(txdr->buffer_info[i].skb,\n\t\t\t\t\t\t  1024);\n\t\t\tdma_sync_single_for_device(&pdev->dev,\n\t\t\t\t\t\t   txdr->buffer_info[k].dma,\n\t\t\t\t\t\t   txdr->buffer_info[k].length,\n\t\t\t\t\t\t   DMA_TO_DEVICE);\n\t\t\tif (unlikely(++k == txdr->count))\n\t\t\t\tk = 0;\n\t\t}\n\t\tew32(TDT, k);\n\t\tE1000_WRITE_FLUSH();\n\t\tmsleep(200);\n\t\ttime = jiffies;  \n\t\tgood_cnt = 0;\n\t\tdo {  \n\t\t\tdma_sync_single_for_cpu(&pdev->dev,\n\t\t\t\t\t\trxdr->buffer_info[l].dma,\n\t\t\t\t\t\tE1000_RXBUFFER_2048,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\tret_val = e1000_check_lbtest_frame(\n\t\t\t\t\trxdr->buffer_info[l].rxbuf.data +\n\t\t\t\t\tNET_SKB_PAD + NET_IP_ALIGN,\n\t\t\t\t\t1024);\n\t\t\tif (!ret_val)\n\t\t\t\tgood_cnt++;\n\t\t\tif (unlikely(++l == rxdr->count))\n\t\t\t\tl = 0;\n\t\t\t \n\t\t} while (good_cnt < 64 && time_after(time + 20, jiffies));\n\n\t\tif (good_cnt != 64) {\n\t\t\tret_val = 13;  \n\t\t\tbreak;\n\t\t}\n\t\tif (time_after_eq(jiffies, time + 2)) {\n\t\t\tret_val = 14;  \n\t\t\tbreak;\n\t\t}\n\t}  \n\treturn ret_val;\n}\n\nstatic int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)\n{\n\t*data = e1000_setup_desc_rings(adapter);\n\tif (*data)\n\t\tgoto out;\n\t*data = e1000_setup_loopback_test(adapter);\n\tif (*data)\n\t\tgoto err_loopback;\n\t*data = e1000_run_loopback_test(adapter);\n\te1000_loopback_cleanup(adapter);\n\nerr_loopback:\n\te1000_free_desc_rings(adapter);\nout:\n\treturn *data;\n}\n\nstatic int e1000_link_test(struct e1000_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\t*data = 0;\n\tif (hw->media_type == e1000_media_type_internal_serdes) {\n\t\tint i = 0;\n\n\t\thw->serdes_has_link = false;\n\n\t\t \n\t\tdo {\n\t\t\te1000_check_for_link(hw);\n\t\t\tif (hw->serdes_has_link)\n\t\t\t\treturn *data;\n\t\t\tmsleep(20);\n\t\t} while (i++ < 3750);\n\n\t\t*data = 1;\n\t} else {\n\t\te1000_check_for_link(hw);\n\t\tif (hw->autoneg)   \n\t\t\tmsleep(4000);\n\n\t\tif (!(er32(STATUS) & E1000_STATUS_LU))\n\t\t\t*data = 1;\n\t}\n\treturn *data;\n}\n\nstatic int e1000_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn E1000_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn E1000_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void e1000_diag_test(struct net_device *netdev,\n\t\t\t    struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool if_running = netif_running(netdev);\n\n\tset_bit(__E1000_TESTING, &adapter->flags);\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\t \n\n\t\t \n\t\tu16 autoneg_advertised = hw->autoneg_advertised;\n\t\tu8 forced_speed_duplex = hw->forced_speed_duplex;\n\t\tu8 autoneg = hw->autoneg;\n\n\t\te_info(hw, \"offline testing starting\\n\");\n\n\t\t \n\t\tif (e1000_link_test(adapter, &data[4]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (if_running)\n\t\t\t \n\t\t\te1000_close(netdev);\n\t\telse\n\t\t\te1000_reset(adapter);\n\n\t\tif (e1000_reg_test(adapter, &data[0]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\te1000_reset(adapter);\n\t\tif (e1000_eeprom_test(adapter, &data[1]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\te1000_reset(adapter);\n\t\tif (e1000_intr_test(adapter, &data[2]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\te1000_reset(adapter);\n\t\t \n\t\te1000_power_up_phy(adapter);\n\t\tif (e1000_loopback_test(adapter, &data[3]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\thw->autoneg_advertised = autoneg_advertised;\n\t\thw->forced_speed_duplex = forced_speed_duplex;\n\t\thw->autoneg = autoneg;\n\n\t\te1000_reset(adapter);\n\t\tclear_bit(__E1000_TESTING, &adapter->flags);\n\t\tif (if_running)\n\t\t\te1000_open(netdev);\n\t} else {\n\t\te_info(hw, \"online testing starting\\n\");\n\t\t \n\t\tif (e1000_link_test(adapter, &data[4]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tdata[0] = 0;\n\t\tdata[1] = 0;\n\t\tdata[2] = 0;\n\t\tdata[3] = 0;\n\n\t\tclear_bit(__E1000_TESTING, &adapter->flags);\n\t}\n\tmsleep_interruptible(4 * 1000);\n}\n\nstatic int e1000_wol_exclusion(struct e1000_adapter *adapter,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint retval = 1;  \n\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82542:\n\tcase E1000_DEV_ID_82543GC_FIBER:\n\tcase E1000_DEV_ID_82543GC_COPPER:\n\tcase E1000_DEV_ID_82544EI_FIBER:\n\tcase E1000_DEV_ID_82546EB_QUAD_COPPER:\n\tcase E1000_DEV_ID_82545EM_FIBER:\n\tcase E1000_DEV_ID_82545EM_COPPER:\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER:\n\tcase E1000_DEV_ID_82546GB_PCIE:\n\t\t \n\t\twol->supported = 0;\n\t\tbreak;\n\tcase E1000_DEV_ID_82546EB_FIBER:\n\tcase E1000_DEV_ID_82546GB_FIBER:\n\t\t \n\t\tif (er32(STATUS) & E1000_STATUS_FUNC_1) {\n\t\t\twol->supported = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = 0;\n\t\tbreak;\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\t \n\t\tif (!adapter->quad_port_a) {\n\t\t\twol->supported = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (er32(STATUS) & E1000_STATUS_FUNC_1 &&\n\t\t    !adapter->eeprom_wol) {\n\t\t\twol->supported = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tretval = 0;\n\t}\n\n\treturn retval;\n}\n\nstatic void e1000_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST | WAKE_BCAST | WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\t \n\tif (e1000_wol_exclusion(adapter, wol) ||\n\t    !device_can_wakeup(&adapter->pdev->dev))\n\t\treturn;\n\n\t \n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\t \n\t\twol->supported &= ~WAKE_UCAST;\n\n\t\tif (adapter->wol & E1000_WUFC_EX)\n\t\t\te_err(drv, \"Interface does not support directed \"\n\t\t\t      \"(unicast) frame wake-up packets\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adapter->wol & E1000_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & E1000_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & E1000_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & E1000_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\nstatic int e1000_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (e1000_wol_exclusion(adapter, wol) ||\n\t    !device_can_wakeup(&adapter->pdev->dev))\n\t\treturn wol->wolopts ? -EOPNOTSUPP : 0;\n\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\tif (wol->wolopts & WAKE_UCAST) {\n\t\t\te_err(drv, \"Interface does not support directed \"\n\t\t\t      \"(unicast) frame wake-up packets\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_UCAST)\n\t\tadapter->wol |= E1000_WUFC_EX;\n\tif (wol->wolopts & WAKE_MCAST)\n\t\tadapter->wol |= E1000_WUFC_MC;\n\tif (wol->wolopts & WAKE_BCAST)\n\t\tadapter->wol |= E1000_WUFC_BC;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= E1000_WUFC_MAG;\n\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\nstatic int e1000_set_phys_id(struct net_device *netdev,\n\t\t\t     enum ethtool_phys_id_state state)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\te1000_setup_led(hw);\n\t\treturn 2;\n\n\tcase ETHTOOL_ID_ON:\n\t\te1000_led_on(hw);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\te1000_led_off(hw);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\te1000_cleanup_led(hw);\n\t}\n\n\treturn 0;\n}\n\nstatic int e1000_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->hw.mac_type < e1000_82545)\n\t\treturn -EOPNOTSUPP;\n\n\tif (adapter->itr_setting <= 4)\n\t\tec->rx_coalesce_usecs = adapter->itr_setting;\n\telse\n\t\tec->rx_coalesce_usecs = 1000000 / adapter->itr_setting;\n\n\treturn 0;\n}\n\nstatic int e1000_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (hw->mac_type < e1000_82545)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ec->rx_coalesce_usecs > E1000_MAX_ITR_USECS) ||\n\t    ((ec->rx_coalesce_usecs > 4) &&\n\t     (ec->rx_coalesce_usecs < E1000_MIN_ITR_USECS)) ||\n\t    (ec->rx_coalesce_usecs == 2))\n\t\treturn -EINVAL;\n\n\tif (ec->rx_coalesce_usecs == 4) {\n\t\tadapter->itr = adapter->itr_setting = 4;\n\t} else if (ec->rx_coalesce_usecs <= 3) {\n\t\tadapter->itr = 20000;\n\t\tadapter->itr_setting = ec->rx_coalesce_usecs;\n\t} else {\n\t\tadapter->itr = (1000000 / ec->rx_coalesce_usecs);\n\t\tadapter->itr_setting = adapter->itr & ~3;\n\t}\n\n\tif (adapter->itr_setting != 0)\n\t\tew32(ITR, 1000000000 / (adapter->itr * 256));\n\telse\n\t\tew32(ITR, 0);\n\n\treturn 0;\n}\n\nstatic int e1000_nway_reset(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\te1000_reinit_locked(adapter);\n\treturn 0;\n}\n\nstatic void e1000_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\tconst struct e1000_stats *stat = e1000_gstrings_stats;\n\n\te1000_update_stats(adapter);\n\tfor (i = 0; i < E1000_GLOBAL_STATS_LEN; i++, stat++) {\n\t\tchar *p;\n\n\t\tswitch (stat->type) {\n\t\tcase NETDEV_STATS:\n\t\t\tp = (char *)netdev + stat->stat_offset;\n\t\t\tbreak;\n\t\tcase E1000_STATS:\n\t\t\tp = (char *)adapter + stat->stat_offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_WARN_ONCE(netdev, \"Invalid E1000 stat type: %u index %d\\n\",\n\t\t\t\t\t stat->type, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stat->sizeof_stat == sizeof(u64))\n\t\t\tdata[i] = *(u64 *)p;\n\t\telse\n\t\t\tdata[i] = *(u32 *)p;\n\t}\n \n}\n\nstatic void e1000_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t      u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {\n\t\t\tmemcpy(p, e1000_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic const struct ethtool_ops e1000_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo\t\t= e1000_get_drvinfo,\n\t.get_regs_len\t\t= e1000_get_regs_len,\n\t.get_regs\t\t= e1000_get_regs,\n\t.get_wol\t\t= e1000_get_wol,\n\t.set_wol\t\t= e1000_set_wol,\n\t.get_msglevel\t\t= e1000_get_msglevel,\n\t.set_msglevel\t\t= e1000_set_msglevel,\n\t.nway_reset\t\t= e1000_nway_reset,\n\t.get_link\t\t= e1000_get_link,\n\t.get_eeprom_len\t\t= e1000_get_eeprom_len,\n\t.get_eeprom\t\t= e1000_get_eeprom,\n\t.set_eeprom\t\t= e1000_set_eeprom,\n\t.get_ringparam\t\t= e1000_get_ringparam,\n\t.set_ringparam\t\t= e1000_set_ringparam,\n\t.get_pauseparam\t\t= e1000_get_pauseparam,\n\t.set_pauseparam\t\t= e1000_set_pauseparam,\n\t.self_test\t\t= e1000_diag_test,\n\t.get_strings\t\t= e1000_get_strings,\n\t.set_phys_id\t\t= e1000_set_phys_id,\n\t.get_ethtool_stats\t= e1000_get_ethtool_stats,\n\t.get_sset_count\t\t= e1000_get_sset_count,\n\t.get_coalesce\t\t= e1000_get_coalesce,\n\t.set_coalesce\t\t= e1000_set_coalesce,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings\t= e1000_get_link_ksettings,\n\t.set_link_ksettings\t= e1000_set_link_ksettings,\n};\n\nvoid e1000_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &e1000_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}