{
  "module_name": "e1000_main.c",
  "hash_id": "3385ba999d793c572e522047b1ccb2af37e844f6327434fd7a1f8cc67b3b7cb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000/e1000_main.c",
  "human_readable_source": "\n \n\n#include \"e1000.h\"\n#include <net/ip6_checksum.h>\n#include <linux/io.h>\n#include <linux/prefetch.h>\n#include <linux/bitops.h>\n#include <linux/if_vlan.h>\n\nchar e1000_driver_name[] = \"e1000\";\nstatic char e1000_driver_string[] = \"Intel(R) PRO/1000 Network Driver\";\nstatic const char e1000_copyright[] = \"Copyright (c) 1999-2006 Intel Corporation.\";\n\n \nstatic const struct pci_device_id e1000_pci_tbl[] = {\n\tINTEL_E1000_ETHERNET_DEVICE(0x1000),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1001),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1004),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1008),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1009),\n\tINTEL_E1000_ETHERNET_DEVICE(0x100C),\n\tINTEL_E1000_ETHERNET_DEVICE(0x100D),\n\tINTEL_E1000_ETHERNET_DEVICE(0x100E),\n\tINTEL_E1000_ETHERNET_DEVICE(0x100F),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1010),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1011),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1012),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1013),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1014),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1015),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1016),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1017),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1018),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1019),\n\tINTEL_E1000_ETHERNET_DEVICE(0x101A),\n\tINTEL_E1000_ETHERNET_DEVICE(0x101D),\n\tINTEL_E1000_ETHERNET_DEVICE(0x101E),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1026),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1027),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1028),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1075),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1076),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1077),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1078),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1079),\n\tINTEL_E1000_ETHERNET_DEVICE(0x107A),\n\tINTEL_E1000_ETHERNET_DEVICE(0x107B),\n\tINTEL_E1000_ETHERNET_DEVICE(0x107C),\n\tINTEL_E1000_ETHERNET_DEVICE(0x108A),\n\tINTEL_E1000_ETHERNET_DEVICE(0x1099),\n\tINTEL_E1000_ETHERNET_DEVICE(0x10B5),\n\tINTEL_E1000_ETHERNET_DEVICE(0x2E6E),\n\t \n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, e1000_pci_tbl);\n\nint e1000_up(struct e1000_adapter *adapter);\nvoid e1000_down(struct e1000_adapter *adapter);\nvoid e1000_reinit_locked(struct e1000_adapter *adapter);\nvoid e1000_reset(struct e1000_adapter *adapter);\nint e1000_setup_all_tx_resources(struct e1000_adapter *adapter);\nint e1000_setup_all_rx_resources(struct e1000_adapter *adapter);\nvoid e1000_free_all_tx_resources(struct e1000_adapter *adapter);\nvoid e1000_free_all_rx_resources(struct e1000_adapter *adapter);\nstatic int e1000_setup_tx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_tx_ring *txdr);\nstatic int e1000_setup_rx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_rx_ring *rxdr);\nstatic void e1000_free_tx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_tx_ring *tx_ring);\nstatic void e1000_free_rx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_rx_ring *rx_ring);\nvoid e1000_update_stats(struct e1000_adapter *adapter);\n\nstatic int e1000_init_module(void);\nstatic void e1000_exit_module(void);\nstatic int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic void e1000_remove(struct pci_dev *pdev);\nstatic int e1000_alloc_queues(struct e1000_adapter *adapter);\nstatic int e1000_sw_init(struct e1000_adapter *adapter);\nint e1000_open(struct net_device *netdev);\nint e1000_close(struct net_device *netdev);\nstatic void e1000_configure_tx(struct e1000_adapter *adapter);\nstatic void e1000_configure_rx(struct e1000_adapter *adapter);\nstatic void e1000_setup_rctl(struct e1000_adapter *adapter);\nstatic void e1000_clean_all_tx_rings(struct e1000_adapter *adapter);\nstatic void e1000_clean_all_rx_rings(struct e1000_adapter *adapter);\nstatic void e1000_clean_tx_ring(struct e1000_adapter *adapter,\n\t\t\t\tstruct e1000_tx_ring *tx_ring);\nstatic void e1000_clean_rx_ring(struct e1000_adapter *adapter,\n\t\t\t\tstruct e1000_rx_ring *rx_ring);\nstatic void e1000_set_rx_mode(struct net_device *netdev);\nstatic void e1000_update_phy_info_task(struct work_struct *work);\nstatic void e1000_watchdog(struct work_struct *work);\nstatic void e1000_82547_tx_fifo_stall_task(struct work_struct *work);\nstatic netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev);\nstatic int e1000_change_mtu(struct net_device *netdev, int new_mtu);\nstatic int e1000_set_mac(struct net_device *netdev, void *p);\nstatic irqreturn_t e1000_intr(int irq, void *data);\nstatic bool e1000_clean_tx_irq(struct e1000_adapter *adapter,\n\t\t\t       struct e1000_tx_ring *tx_ring);\nstatic int e1000_clean(struct napi_struct *napi, int budget);\nstatic bool e1000_clean_rx_irq(struct e1000_adapter *adapter,\n\t\t\t       struct e1000_rx_ring *rx_ring,\n\t\t\t       int *work_done, int work_to_do);\nstatic bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,\n\t\t\t\t     struct e1000_rx_ring *rx_ring,\n\t\t\t\t     int *work_done, int work_to_do);\nstatic void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,\n\t\t\t\t\t struct e1000_rx_ring *rx_ring,\n\t\t\t\t\t int cleaned_count)\n{\n}\nstatic void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,\n\t\t\t\t   struct e1000_rx_ring *rx_ring,\n\t\t\t\t   int cleaned_count);\nstatic void e1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter,\n\t\t\t\t\t struct e1000_rx_ring *rx_ring,\n\t\t\t\t\t int cleaned_count);\nstatic int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);\nstatic int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,\n\t\t\t   int cmd);\nstatic void e1000_enter_82542_rst(struct e1000_adapter *adapter);\nstatic void e1000_leave_82542_rst(struct e1000_adapter *adapter);\nstatic void e1000_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void e1000_reset_task(struct work_struct *work);\nstatic void e1000_smartspeed(struct e1000_adapter *adapter);\nstatic int e1000_82547_fifo_workaround(struct e1000_adapter *adapter,\n\t\t\t\t       struct sk_buff *skb);\n\nstatic bool e1000_vlan_used(struct e1000_adapter *adapter);\nstatic void e1000_vlan_mode(struct net_device *netdev,\n\t\t\t    netdev_features_t features);\nstatic void e1000_vlan_filter_on_off(struct e1000_adapter *adapter,\n\t\t\t\t     bool filter_on);\nstatic int e1000_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t __be16 proto, u16 vid);\nstatic int e1000_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t  __be16 proto, u16 vid);\nstatic void e1000_restore_vlan(struct e1000_adapter *adapter);\n\nstatic int __maybe_unused e1000_suspend(struct device *dev);\nstatic int __maybe_unused e1000_resume(struct device *dev);\nstatic void e1000_shutdown(struct pci_dev *pdev);\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void e1000_netpoll (struct net_device *netdev);\n#endif\n\n#define COPYBREAK_DEFAULT 256\nstatic unsigned int copybreak __read_mostly = COPYBREAK_DEFAULT;\nmodule_param(copybreak, uint, 0644);\nMODULE_PARM_DESC(copybreak,\n\t\"Maximum size of packet that is copied to a new buffer on receive\");\n\nstatic pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state);\nstatic pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev);\nstatic void e1000_io_resume(struct pci_dev *pdev);\n\nstatic const struct pci_error_handlers e1000_err_handler = {\n\t.error_detected = e1000_io_error_detected,\n\t.slot_reset = e1000_io_slot_reset,\n\t.resume = e1000_io_resume,\n};\n\nstatic SIMPLE_DEV_PM_OPS(e1000_pm_ops, e1000_suspend, e1000_resume);\n\nstatic struct pci_driver e1000_driver = {\n\t.name     = e1000_driver_name,\n\t.id_table = e1000_pci_tbl,\n\t.probe    = e1000_probe,\n\t.remove   = e1000_remove,\n\t.driver = {\n\t\t.pm = &e1000_pm_ops,\n\t},\n\t.shutdown = e1000_shutdown,\n\t.err_handler = &e1000_err_handler\n};\n\nMODULE_AUTHOR(\"Intel Corporation, <linux.nics@intel.com>\");\nMODULE_DESCRIPTION(\"Intel(R) PRO/1000 Network Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\n \nstruct net_device *e1000_get_hw_dev(struct e1000_hw *hw)\n{\n\tstruct e1000_adapter *adapter = hw->back;\n\treturn adapter->netdev;\n}\n\n \nstatic int __init e1000_init_module(void)\n{\n\tint ret;\n\tpr_info(\"%s\\n\", e1000_driver_string);\n\n\tpr_info(\"%s\\n\", e1000_copyright);\n\n\tret = pci_register_driver(&e1000_driver);\n\tif (copybreak != COPYBREAK_DEFAULT) {\n\t\tif (copybreak == 0)\n\t\t\tpr_info(\"copybreak disabled\\n\");\n\t\telse\n\t\t\tpr_info(\"copybreak enabled for \"\n\t\t\t\t   \"packets <= %u bytes\\n\", copybreak);\n\t}\n\treturn ret;\n}\n\nmodule_init(e1000_init_module);\n\n \nstatic void __exit e1000_exit_module(void)\n{\n\tpci_unregister_driver(&e1000_driver);\n}\n\nmodule_exit(e1000_exit_module);\n\nstatic int e1000_request_irq(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tirq_handler_t handler = e1000_intr;\n\tint irq_flags = IRQF_SHARED;\n\tint err;\n\n\terr = request_irq(adapter->pdev->irq, handler, irq_flags, netdev->name,\n\t\t\t  netdev);\n\tif (err) {\n\t\te_err(probe, \"Unable to allocate interrupt Error: %d\\n\", err);\n\t}\n\n\treturn err;\n}\n\nstatic void e1000_free_irq(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tfree_irq(adapter->pdev->irq, netdev);\n}\n\n \nstatic void e1000_irq_disable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tew32(IMC, ~0);\n\tE1000_WRITE_FLUSH();\n\tsynchronize_irq(adapter->pdev->irq);\n}\n\n \nstatic void e1000_irq_enable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tew32(IMS, IMS_ENABLE_MASK);\n\tE1000_WRITE_FLUSH();\n}\n\nstatic void e1000_update_mng_vlan(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu16 vid = hw->mng_cookie.vlan_id;\n\tu16 old_vid = adapter->mng_vlan_id;\n\n\tif (!e1000_vlan_used(adapter))\n\t\treturn;\n\n\tif (!test_bit(vid, adapter->active_vlans)) {\n\t\tif (hw->mng_cookie.status &\n\t\t    E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) {\n\t\t\te1000_vlan_rx_add_vid(netdev, htons(ETH_P_8021Q), vid);\n\t\t\tadapter->mng_vlan_id = vid;\n\t\t} else {\n\t\t\tadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\n\t\t}\n\t\tif ((old_vid != (u16)E1000_MNG_VLAN_NONE) &&\n\t\t    (vid != old_vid) &&\n\t\t    !test_bit(old_vid, adapter->active_vlans))\n\t\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\n\t\t\t\t\t       old_vid);\n\t} else {\n\t\tadapter->mng_vlan_id = vid;\n\t}\n}\n\nstatic void e1000_init_manageability(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (adapter->en_mng_pt) {\n\t\tu32 manc = er32(MANC);\n\n\t\t \n\t\tmanc &= ~(E1000_MANC_ARP_EN);\n\n\t\tew32(MANC, manc);\n\t}\n}\n\nstatic void e1000_release_manageability(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (adapter->en_mng_pt) {\n\t\tu32 manc = er32(MANC);\n\n\t\t \n\t\tmanc |= E1000_MANC_ARP_EN;\n\n\t\tew32(MANC, manc);\n\t}\n}\n\n \nstatic void e1000_configure(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint i;\n\n\te1000_set_rx_mode(netdev);\n\n\te1000_restore_vlan(adapter);\n\te1000_init_manageability(adapter);\n\n\te1000_configure_tx(adapter);\n\te1000_setup_rctl(adapter);\n\te1000_configure_rx(adapter);\n\t \n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct e1000_rx_ring *ring = &adapter->rx_ring[i];\n\t\tadapter->alloc_rx_buf(adapter, ring,\n\t\t\t\t      E1000_DESC_UNUSED(ring));\n\t}\n}\n\nint e1000_up(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\te1000_configure(adapter);\n\n\tclear_bit(__E1000_DOWN, &adapter->flags);\n\n\tnapi_enable(&adapter->napi);\n\n\te1000_irq_enable(adapter);\n\n\tnetif_wake_queue(adapter->netdev);\n\n\t \n\tew32(ICS, E1000_ICS_LSC);\n\treturn 0;\n}\n\n \nvoid e1000_power_up_phy(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 mii_reg = 0;\n\n\t \n\tif (hw->media_type == e1000_media_type_copper) {\n\t\t \n\t\te1000_read_phy_reg(hw, PHY_CTRL, &mii_reg);\n\t\tmii_reg &= ~MII_CR_POWER_DOWN;\n\t\te1000_write_phy_reg(hw, PHY_CTRL, mii_reg);\n\t}\n}\n\nstatic void e1000_power_down_phy(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t \n\tif (!adapter->wol && hw->mac_type >= e1000_82540 &&\n\t   hw->media_type == e1000_media_type_copper) {\n\t\tu16 mii_reg = 0;\n\n\t\tswitch (hw->mac_type) {\n\t\tcase e1000_82540:\n\t\tcase e1000_82545:\n\t\tcase e1000_82545_rev_3:\n\t\tcase e1000_82546:\n\t\tcase e1000_ce4100:\n\t\tcase e1000_82546_rev_3:\n\t\tcase e1000_82541:\n\t\tcase e1000_82541_rev_2:\n\t\tcase e1000_82547:\n\t\tcase e1000_82547_rev_2:\n\t\t\tif (er32(MANC) & E1000_MANC_SMBUS_EN)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\te1000_read_phy_reg(hw, PHY_CTRL, &mii_reg);\n\t\tmii_reg |= MII_CR_POWER_DOWN;\n\t\te1000_write_phy_reg(hw, PHY_CTRL, mii_reg);\n\t\tmsleep(1);\n\t}\nout:\n\treturn;\n}\n\nstatic void e1000_down_and_stop(struct e1000_adapter *adapter)\n{\n\tset_bit(__E1000_DOWN, &adapter->flags);\n\n\tcancel_delayed_work_sync(&adapter->watchdog_task);\n\n\t \n\n\tcancel_delayed_work_sync(&adapter->phy_info_task);\n\tcancel_delayed_work_sync(&adapter->fifo_stall_task);\n\n\t \n\tif (!test_bit(__E1000_RESETTING, &adapter->flags))\n\t\tcancel_work_sync(&adapter->reset_task);\n}\n\nvoid e1000_down(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 rctl, tctl;\n\n\t \n\trctl = er32(RCTL);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t \n\n\tnetif_tx_disable(netdev);\n\n\t \n\ttctl = er32(TCTL);\n\ttctl &= ~E1000_TCTL_EN;\n\tew32(TCTL, tctl);\n\t \n\tE1000_WRITE_FLUSH();\n\tmsleep(10);\n\n\t \n\tnetif_carrier_off(netdev);\n\n\tnapi_disable(&adapter->napi);\n\n\te1000_irq_disable(adapter);\n\n\t \n\te1000_down_and_stop(adapter);\n\n\tadapter->link_speed = 0;\n\tadapter->link_duplex = 0;\n\n\te1000_reset(adapter);\n\te1000_clean_all_tx_rings(adapter);\n\te1000_clean_all_rx_rings(adapter);\n}\n\nvoid e1000_reinit_locked(struct e1000_adapter *adapter)\n{\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\n\t \n\tif (!test_bit(__E1000_DOWN, &adapter->flags)) {\n\t\te1000_down(adapter);\n\t\te1000_up(adapter);\n\t}\n\n\tclear_bit(__E1000_RESETTING, &adapter->flags);\n}\n\nvoid e1000_reset(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 pba = 0, tx_space, min_tx_space, min_rx_space;\n\tbool legacy_pba_adjust = false;\n\tu16 hwm;\n\n\t \n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\tcase e1000_82544:\n\tcase e1000_82540:\n\tcase e1000_82541:\n\tcase e1000_82541_rev_2:\n\t\tlegacy_pba_adjust = true;\n\t\tpba = E1000_PBA_48K;\n\t\tbreak;\n\tcase e1000_82545:\n\tcase e1000_82545_rev_3:\n\tcase e1000_82546:\n\tcase e1000_ce4100:\n\tcase e1000_82546_rev_3:\n\t\tpba = E1000_PBA_48K;\n\t\tbreak;\n\tcase e1000_82547:\n\tcase e1000_82547_rev_2:\n\t\tlegacy_pba_adjust = true;\n\t\tpba = E1000_PBA_30K;\n\t\tbreak;\n\tcase e1000_undefined:\n\tcase e1000_num_macs:\n\t\tbreak;\n\t}\n\n\tif (legacy_pba_adjust) {\n\t\tif (hw->max_frame_size > E1000_RXBUFFER_8192)\n\t\t\tpba -= 8;  \n\n\t\tif (hw->mac_type == e1000_82547) {\n\t\t\tadapter->tx_fifo_head = 0;\n\t\t\tadapter->tx_head_addr = pba << E1000_TX_HEAD_ADDR_SHIFT;\n\t\t\tadapter->tx_fifo_size =\n\t\t\t\t(E1000_PBA_40K - pba) << E1000_PBA_BYTES_SHIFT;\n\t\t\tatomic_set(&adapter->tx_fifo_stall, 0);\n\t\t}\n\t} else if (hw->max_frame_size >  ETH_FRAME_LEN + ETH_FCS_LEN) {\n\t\t \n\t\tew32(PBA, pba);\n\n\t\t \n\t\tpba = er32(PBA);\n\t\t \n\t\ttx_space = pba >> 16;\n\t\t \n\t\tpba &= 0xffff;\n\t\t \n\t\tmin_tx_space = (hw->max_frame_size +\n\t\t\t\tsizeof(struct e1000_tx_desc) -\n\t\t\t\tETH_FCS_LEN) * 2;\n\t\tmin_tx_space = ALIGN(min_tx_space, 1024);\n\t\tmin_tx_space >>= 10;\n\t\t \n\t\tmin_rx_space = hw->max_frame_size;\n\t\tmin_rx_space = ALIGN(min_rx_space, 1024);\n\t\tmin_rx_space >>= 10;\n\n\t\t \n\t\tif (tx_space < min_tx_space &&\n\t\t    ((min_tx_space - tx_space) < pba)) {\n\t\t\tpba = pba - (min_tx_space - tx_space);\n\n\t\t\t \n\t\t\tswitch (hw->mac_type) {\n\t\t\tcase e1000_82545 ... e1000_82546_rev_3:\n\t\t\t\tpba &= ~(E1000_PBA_8K - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pba < min_rx_space)\n\t\t\t\tpba = min_rx_space;\n\t\t}\n\t}\n\n\tew32(PBA, pba);\n\n\t \n\thwm = min(((pba << 10) * 9 / 10),\n\t\t  ((pba << 10) - hw->max_frame_size));\n\n\thw->fc_high_water = hwm & 0xFFF8;\t \n\thw->fc_low_water = hw->fc_high_water - 8;\n\thw->fc_pause_time = E1000_FC_PAUSE_TIME;\n\thw->fc_send_xon = 1;\n\thw->fc = hw->original_fc;\n\n\t \n\te1000_reset_hw(hw);\n\tif (hw->mac_type >= e1000_82544)\n\t\tew32(WUC, 0);\n\n\tif (e1000_init_hw(hw))\n\t\te_dev_err(\"Hardware Error\\n\");\n\te1000_update_mng_vlan(adapter);\n\n\t \n\tif (hw->mac_type >= e1000_82544 &&\n\t    hw->autoneg == 1 &&\n\t    hw->autoneg_advertised == ADVERTISE_1000_FULL) {\n\t\tu32 ctrl = er32(CTRL);\n\t\t \n\t\tctrl &= ~E1000_CTRL_SWDPIN3;\n\t\tew32(CTRL, ctrl);\n\t}\n\n\t \n\tew32(VET, ETHERNET_IEEE_VLAN_TYPE);\n\n\te1000_reset_adaptive(hw);\n\te1000_phy_get_info(hw, &adapter->phy_info);\n\n\te1000_release_manageability(adapter);\n}\n\n \nstatic void e1000_dump_eeprom(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ethtool_eeprom eeprom;\n\tconst struct ethtool_ops *ops = netdev->ethtool_ops;\n\tu8 *data;\n\tint i;\n\tu16 csum_old, csum_new = 0;\n\n\teeprom.len = ops->get_eeprom_len(netdev);\n\teeprom.offset = 0;\n\n\tdata = kmalloc(eeprom.len, GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tops->get_eeprom(netdev, &eeprom, data);\n\n\tcsum_old = (data[EEPROM_CHECKSUM_REG * 2]) +\n\t\t   (data[EEPROM_CHECKSUM_REG * 2 + 1] << 8);\n\tfor (i = 0; i < EEPROM_CHECKSUM_REG * 2; i += 2)\n\t\tcsum_new += data[i] + (data[i + 1] << 8);\n\tcsum_new = EEPROM_SUM - csum_new;\n\n\tpr_err(\"/*********************/\\n\");\n\tpr_err(\"Current EEPROM Checksum : 0x%04x\\n\", csum_old);\n\tpr_err(\"Calculated              : 0x%04x\\n\", csum_new);\n\n\tpr_err(\"Offset    Values\\n\");\n\tpr_err(\"========  ======\\n\");\n\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 16, 1, data, 128, 0);\n\n\tpr_err(\"Include this output when contacting your support provider.\\n\");\n\tpr_err(\"This is not a software error! Something bad happened to\\n\");\n\tpr_err(\"your hardware or EEPROM image. Ignoring this problem could\\n\");\n\tpr_err(\"result in further problems, possibly loss of data,\\n\");\n\tpr_err(\"corruption or system hangs!\\n\");\n\tpr_err(\"The MAC Address will be reset to 00:00:00:00:00:00,\\n\");\n\tpr_err(\"which is invalid and requires you to set the proper MAC\\n\");\n\tpr_err(\"address manually before continuing to enable this network\\n\");\n\tpr_err(\"device. Please inspect the EEPROM dump and report the\\n\");\n\tpr_err(\"issue to your hardware vendor or Intel Customer Support.\\n\");\n\tpr_err(\"/*********************/\\n\");\n\n\tkfree(data);\n}\n\n \nstatic int e1000_is_need_ioport(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase E1000_DEV_ID_82540EM:\n\tcase E1000_DEV_ID_82540EM_LOM:\n\tcase E1000_DEV_ID_82540EP:\n\tcase E1000_DEV_ID_82540EP_LOM:\n\tcase E1000_DEV_ID_82540EP_LP:\n\tcase E1000_DEV_ID_82541EI:\n\tcase E1000_DEV_ID_82541EI_MOBILE:\n\tcase E1000_DEV_ID_82541ER:\n\tcase E1000_DEV_ID_82541ER_LOM:\n\tcase E1000_DEV_ID_82541GI:\n\tcase E1000_DEV_ID_82541GI_LF:\n\tcase E1000_DEV_ID_82541GI_MOBILE:\n\tcase E1000_DEV_ID_82544EI_COPPER:\n\tcase E1000_DEV_ID_82544EI_FIBER:\n\tcase E1000_DEV_ID_82544GC_COPPER:\n\tcase E1000_DEV_ID_82544GC_LOM:\n\tcase E1000_DEV_ID_82545EM_COPPER:\n\tcase E1000_DEV_ID_82545EM_FIBER:\n\tcase E1000_DEV_ID_82546EB_COPPER:\n\tcase E1000_DEV_ID_82546EB_FIBER:\n\tcase E1000_DEV_ID_82546EB_QUAD_COPPER:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic netdev_features_t e1000_fix_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int e1000_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tnetdev_features_t changed = features ^ netdev->features;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\te1000_vlan_mode(netdev, features);\n\n\tif (!(changed & (NETIF_F_RXCSUM | NETIF_F_RXALL)))\n\t\treturn 0;\n\n\tnetdev->features = features;\n\tadapter->rx_csum = !!(features & NETIF_F_RXCSUM);\n\n\tif (netif_running(netdev))\n\t\te1000_reinit_locked(adapter);\n\telse\n\t\te1000_reset(adapter);\n\n\treturn 1;\n}\n\nstatic const struct net_device_ops e1000_netdev_ops = {\n\t.ndo_open\t\t= e1000_open,\n\t.ndo_stop\t\t= e1000_close,\n\t.ndo_start_xmit\t\t= e1000_xmit_frame,\n\t.ndo_set_rx_mode\t= e1000_set_rx_mode,\n\t.ndo_set_mac_address\t= e1000_set_mac,\n\t.ndo_tx_timeout\t\t= e1000_tx_timeout,\n\t.ndo_change_mtu\t\t= e1000_change_mtu,\n\t.ndo_eth_ioctl\t\t= e1000_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_vlan_rx_add_vid\t= e1000_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= e1000_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= e1000_netpoll,\n#endif\n\t.ndo_fix_features\t= e1000_fix_features,\n\t.ndo_set_features\t= e1000_set_features,\n};\n\n \nstatic int e1000_init_hw_struct(struct e1000_adapter *adapter,\n\t\t\t\tstruct e1000_hw *hw)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\t \n\thw->vendor_id = pdev->vendor;\n\thw->device_id = pdev->device;\n\thw->subsystem_vendor_id = pdev->subsystem_vendor;\n\thw->subsystem_id = pdev->subsystem_device;\n\thw->revision_id = pdev->revision;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);\n\n\thw->max_frame_size = adapter->netdev->mtu +\n\t\t\t     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;\n\thw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;\n\n\t \n\tif (e1000_set_mac_type(hw)) {\n\t\te_err(probe, \"Unknown MAC Type\\n\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (hw->mac_type) {\n\tdefault:\n\t\tbreak;\n\tcase e1000_82541:\n\tcase e1000_82547:\n\tcase e1000_82541_rev_2:\n\tcase e1000_82547_rev_2:\n\t\thw->phy_init_script = 1;\n\t\tbreak;\n\t}\n\n\te1000_set_media_type(hw);\n\te1000_get_bus_info(hw);\n\n\thw->wait_autoneg_complete = false;\n\thw->tbi_compatibility_en = true;\n\thw->adaptive_ifs = true;\n\n\t \n\n\tif (hw->media_type == e1000_media_type_copper) {\n\t\thw->mdix = AUTO_ALL_MODES;\n\t\thw->disable_polarity_correction = false;\n\t\thw->master_slave = E1000_MASTER_SLAVE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct e1000_adapter *adapter = NULL;\n\tstruct e1000_hw *hw;\n\n\tstatic int cards_found;\n\tstatic int global_quad_port_a;  \n\tint i, err, pci_using_dac;\n\tu16 eeprom_data = 0;\n\tu16 tmp = 0;\n\tu16 eeprom_apme_mask = E1000_EEPROM_APME;\n\tint bars, need_ioport;\n\tbool disable_dev = false;\n\n\t \n\tneed_ioport = e1000_is_need_ioport(pdev);\n\tif (need_ioport) {\n\t\tbars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);\n\t\terr = pci_enable_device(pdev);\n\t} else {\n\t\tbars = pci_select_bars(pdev, IORESOURCE_MEM);\n\t\terr = pci_enable_device_mem(pdev);\n\t}\n\tif (err)\n\t\treturn err;\n\n\terr = pci_request_selected_regions(pdev, bars, e1000_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\tpci_set_master(pdev);\n\terr = pci_save_state(pdev);\n\tif (err)\n\t\tgoto err_alloc_etherdev;\n\n\terr = -ENOMEM;\n\tnetdev = alloc_etherdev(sizeof(struct e1000_adapter));\n\tif (!netdev)\n\t\tgoto err_alloc_etherdev;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\tadapter->bars = bars;\n\tadapter->need_ioport = need_ioport;\n\n\thw = &adapter->hw;\n\thw->back = adapter;\n\n\terr = -EIO;\n\thw->hw_addr = pci_ioremap_bar(pdev, BAR_0);\n\tif (!hw->hw_addr)\n\t\tgoto err_ioremap;\n\n\tif (adapter->need_ioport) {\n\t\tfor (i = BAR_1; i < PCI_STD_NUM_BARS; i++) {\n\t\t\tif (pci_resource_len(pdev, i) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (pci_resource_flags(pdev, i) & IORESOURCE_IO) {\n\t\t\t\thw->io_base = pci_resource_start(pdev, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\terr = e1000_init_hw_struct(adapter, hw);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\t \n\tpci_using_dac = 0;\n\tif ((hw->bus_type == e1000_bus_type_pcix) &&\n\t    !dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tpci_using_dac = 1;\n\t} else {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tpr_err(\"No usable DMA config, aborting\\n\");\n\t\t\tgoto err_dma;\n\t\t}\n\t}\n\n\tnetdev->netdev_ops = &e1000_netdev_ops;\n\te1000_set_ethtool_ops(netdev);\n\tnetdev->watchdog_timeo = 5 * HZ;\n\tnetif_napi_add(netdev, &adapter->napi, e1000_clean);\n\n\tstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\n\n\tadapter->bd_number = cards_found;\n\n\t \n\n\terr = e1000_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\terr = -EIO;\n\tif (hw->mac_type == e1000_ce4100) {\n\t\thw->ce4100_gbe_mdio_base_virt =\n\t\t\t\t\tioremap(pci_resource_start(pdev, BAR_1),\n\t\t\t\t\t\tpci_resource_len(pdev, BAR_1));\n\n\t\tif (!hw->ce4100_gbe_mdio_base_virt)\n\t\t\tgoto err_mdio_ioremap;\n\t}\n\n\tif (hw->mac_type >= e1000_82543) {\n\t\tnetdev->hw_features = NETIF_F_SG |\n\t\t\t\t   NETIF_F_HW_CSUM |\n\t\t\t\t   NETIF_F_HW_VLAN_CTAG_RX;\n\t\tnetdev->features = NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_CTAG_FILTER;\n\t}\n\n\tif ((hw->mac_type >= e1000_82544) &&\n\t   (hw->mac_type != e1000_82547))\n\t\tnetdev->hw_features |= NETIF_F_TSO;\n\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\n\tnetdev->features |= netdev->hw_features;\n\tnetdev->hw_features |= (NETIF_F_RXCSUM |\n\t\t\t\tNETIF_F_RXALL |\n\t\t\t\tNETIF_F_RXFCS);\n\n\tif (pci_using_dac) {\n\t\tnetdev->features |= NETIF_F_HIGHDMA;\n\t\tnetdev->vlan_features |= NETIF_F_HIGHDMA;\n\t}\n\n\tnetdev->vlan_features |= (NETIF_F_TSO |\n\t\t\t\t  NETIF_F_HW_CSUM |\n\t\t\t\t  NETIF_F_SG);\n\n\t \n\tif (hw->device_id != E1000_DEV_ID_82545EM_COPPER ||\n\t    hw->subsystem_vendor_id != PCI_VENDOR_ID_VMWARE)\n\t\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t \n\tnetdev->min_mtu = ETH_ZLEN - ETH_HLEN;\n\tnetdev->max_mtu = MAX_JUMBO_FRAME_SIZE - (ETH_HLEN + ETH_FCS_LEN);\n\n\tadapter->en_mng_pt = e1000_enable_mng_pass_thru(hw);\n\n\t \n\tif (e1000_init_eeprom_params(hw)) {\n\t\te_err(probe, \"EEPROM initialization failed\\n\");\n\t\tgoto err_eeprom;\n\t}\n\n\t \n\n\te1000_reset_hw(hw);\n\n\t \n\tif (e1000_validate_eeprom_checksum(hw) < 0) {\n\t\te_err(probe, \"The EEPROM Checksum Is Not Valid\\n\");\n\t\te1000_dump_eeprom(adapter);\n\t\t \n\t\tmemset(hw->mac_addr, 0, netdev->addr_len);\n\t} else {\n\t\t \n\t\tif (e1000_read_mac_addr(hw))\n\t\t\te_err(probe, \"EEPROM Read Error\\n\");\n\t}\n\t \n\teth_hw_addr_set(netdev, hw->mac_addr);\n\n\tif (!is_valid_ether_addr(netdev->dev_addr))\n\t\te_err(probe, \"Invalid MAC Address\\n\");\n\n\n\tINIT_DELAYED_WORK(&adapter->watchdog_task, e1000_watchdog);\n\tINIT_DELAYED_WORK(&adapter->fifo_stall_task,\n\t\t\t  e1000_82547_tx_fifo_stall_task);\n\tINIT_DELAYED_WORK(&adapter->phy_info_task, e1000_update_phy_info_task);\n\tINIT_WORK(&adapter->reset_task, e1000_reset_task);\n\n\te1000_check_options(adapter);\n\n\t \n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\tcase e1000_82543:\n\t\tbreak;\n\tcase e1000_82544:\n\t\te1000_read_eeprom(hw,\n\t\t\tEEPROM_INIT_CONTROL2_REG, 1, &eeprom_data);\n\t\teeprom_apme_mask = E1000_EEPROM_82544_APM;\n\t\tbreak;\n\tcase e1000_82546:\n\tcase e1000_82546_rev_3:\n\t\tif (er32(STATUS) & E1000_STATUS_FUNC_1) {\n\t\t\te1000_read_eeprom(hw,\n\t\t\t\tEEPROM_INIT_CONTROL3_PORT_B, 1, &eeprom_data);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\te1000_read_eeprom(hw,\n\t\t\tEEPROM_INIT_CONTROL3_PORT_A, 1, &eeprom_data);\n\t\tbreak;\n\t}\n\tif (eeprom_data & eeprom_apme_mask)\n\t\tadapter->eeprom_wol |= E1000_WUFC_MAG;\n\n\t \n\tswitch (pdev->device) {\n\tcase E1000_DEV_ID_82546GB_PCIE:\n\t\tadapter->eeprom_wol = 0;\n\t\tbreak;\n\tcase E1000_DEV_ID_82546EB_FIBER:\n\tcase E1000_DEV_ID_82546GB_FIBER:\n\t\t \n\t\tif (er32(STATUS) & E1000_STATUS_FUNC_1)\n\t\t\tadapter->eeprom_wol = 0;\n\t\tbreak;\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\t \n\t\tif (global_quad_port_a != 0)\n\t\t\tadapter->eeprom_wol = 0;\n\t\telse\n\t\t\tadapter->quad_port_a = true;\n\t\t \n\t\tif (++global_quad_port_a == 4)\n\t\t\tglobal_quad_port_a = 0;\n\t\tbreak;\n\t}\n\n\t \n\tadapter->wol = adapter->eeprom_wol;\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\t \n\tif (hw->mac_type == e1000_ce4100) {\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\thw->phy_addr = i;\n\t\t\te1000_read_phy_reg(hw, PHY_ID2, &tmp);\n\n\t\t\tif (tmp != 0 && tmp != 0xFF)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= 32)\n\t\t\tgoto err_eeprom;\n\t}\n\n\t \n\te1000_reset(adapter);\n\n\tstrcpy(netdev->name, \"eth%d\");\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\te1000_vlan_filter_on_off(adapter, false);\n\n\t \n\te_info(probe, \"(PCI%s:%dMHz:%d-bit) %pM\\n\",\n\t       ((hw->bus_type == e1000_bus_type_pcix) ? \"-X\" : \"\"),\n\t       ((hw->bus_speed == e1000_bus_speed_133) ? 133 :\n\t\t(hw->bus_speed == e1000_bus_speed_120) ? 120 :\n\t\t(hw->bus_speed == e1000_bus_speed_100) ? 100 :\n\t\t(hw->bus_speed == e1000_bus_speed_66) ? 66 : 33),\n\t       ((hw->bus_width == e1000_bus_width_64) ? 64 : 32),\n\t       netdev->dev_addr);\n\n\t \n\tnetif_carrier_off(netdev);\n\n\te_info(probe, \"Intel(R) PRO/1000 Network Connection\\n\");\n\n\tcards_found++;\n\treturn 0;\n\nerr_register:\nerr_eeprom:\n\te1000_phy_hw_reset(hw);\n\n\tif (hw->flash_address)\n\t\tiounmap(hw->flash_address);\n\tkfree(adapter->tx_ring);\n\tkfree(adapter->rx_ring);\nerr_dma:\nerr_sw_init:\nerr_mdio_ioremap:\n\tiounmap(hw->ce4100_gbe_mdio_base_virt);\n\tiounmap(hw->hw_addr);\nerr_ioremap:\n\tdisable_dev = !test_and_set_bit(__E1000_DISABLED, &adapter->flags);\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tpci_release_selected_regions(pdev, bars);\nerr_pci_reg:\n\tif (!adapter || disable_dev)\n\t\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void e1000_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool disable_dev;\n\n\te1000_down_and_stop(adapter);\n\te1000_release_manageability(adapter);\n\n\tunregister_netdev(netdev);\n\n\te1000_phy_hw_reset(hw);\n\n\tkfree(adapter->tx_ring);\n\tkfree(adapter->rx_ring);\n\n\tif (hw->mac_type == e1000_ce4100)\n\t\tiounmap(hw->ce4100_gbe_mdio_base_virt);\n\tiounmap(hw->hw_addr);\n\tif (hw->flash_address)\n\t\tiounmap(hw->flash_address);\n\tpci_release_selected_regions(pdev, adapter->bars);\n\n\tdisable_dev = !test_and_set_bit(__E1000_DISABLED, &adapter->flags);\n\tfree_netdev(netdev);\n\n\tif (disable_dev)\n\t\tpci_disable_device(pdev);\n}\n\n \nstatic int e1000_sw_init(struct e1000_adapter *adapter)\n{\n\tadapter->rx_buffer_len = MAXIMUM_ETHERNET_VLAN_SIZE;\n\n\tadapter->num_tx_queues = 1;\n\tadapter->num_rx_queues = 1;\n\n\tif (e1000_alloc_queues(adapter)) {\n\t\te_err(probe, \"Unable to allocate memory for queues\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\te1000_irq_disable(adapter);\n\n\tspin_lock_init(&adapter->stats_lock);\n\n\tset_bit(__E1000_DOWN, &adapter->flags);\n\n\treturn 0;\n}\n\n \nstatic int e1000_alloc_queues(struct e1000_adapter *adapter)\n{\n\tadapter->tx_ring = kcalloc(adapter->num_tx_queues,\n\t\t\t\t   sizeof(struct e1000_tx_ring), GFP_KERNEL);\n\tif (!adapter->tx_ring)\n\t\treturn -ENOMEM;\n\n\tadapter->rx_ring = kcalloc(adapter->num_rx_queues,\n\t\t\t\t   sizeof(struct e1000_rx_ring), GFP_KERNEL);\n\tif (!adapter->rx_ring) {\n\t\tkfree(adapter->tx_ring);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn E1000_SUCCESS;\n}\n\n \nint e1000_open(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err;\n\n\t \n\tif (test_bit(__E1000_TESTING, &adapter->flags))\n\t\treturn -EBUSY;\n\n\tnetif_carrier_off(netdev);\n\n\t \n\terr = e1000_setup_all_tx_resources(adapter);\n\tif (err)\n\t\tgoto err_setup_tx;\n\n\t \n\terr = e1000_setup_all_rx_resources(adapter);\n\tif (err)\n\t\tgoto err_setup_rx;\n\n\te1000_power_up_phy(adapter);\n\n\tadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\n\tif ((hw->mng_cookie.status &\n\t\t\t  E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT)) {\n\t\te1000_update_mng_vlan(adapter);\n\t}\n\n\t \n\te1000_configure(adapter);\n\n\terr = e1000_request_irq(adapter);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\t \n\tclear_bit(__E1000_DOWN, &adapter->flags);\n\n\tnapi_enable(&adapter->napi);\n\n\te1000_irq_enable(adapter);\n\n\tnetif_start_queue(netdev);\n\n\t \n\tew32(ICS, E1000_ICS_LSC);\n\n\treturn E1000_SUCCESS;\n\nerr_req_irq:\n\te1000_power_down_phy(adapter);\n\te1000_free_all_rx_resources(adapter);\nerr_setup_rx:\n\te1000_free_all_tx_resources(adapter);\nerr_setup_tx:\n\te1000_reset(adapter);\n\n\treturn err;\n}\n\n \nint e1000_close(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint count = E1000_CHECK_RESET_COUNT;\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags) && count--)\n\t\tusleep_range(10000, 20000);\n\n\tWARN_ON(count < 0);\n\n\t \n\tset_bit(__E1000_DOWN, &adapter->flags);\n\tclear_bit(__E1000_RESETTING, &adapter->flags);\n\n\te1000_down(adapter);\n\te1000_power_down_phy(adapter);\n\te1000_free_irq(adapter);\n\n\te1000_free_all_tx_resources(adapter);\n\te1000_free_all_rx_resources(adapter);\n\n\t \n\tif ((hw->mng_cookie.status &\n\t     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&\n\t    !test_bit(adapter->mng_vlan_id, adapter->active_vlans)) {\n\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\n\t\t\t\t       adapter->mng_vlan_id);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool e1000_check_64k_bound(struct e1000_adapter *adapter, void *start,\n\t\t\t\t  unsigned long len)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned long begin = (unsigned long)start;\n\tunsigned long end = begin + len;\n\n\t \n\tif (hw->mac_type == e1000_82545 ||\n\t    hw->mac_type == e1000_ce4100 ||\n\t    hw->mac_type == e1000_82546) {\n\t\treturn ((begin ^ (end - 1)) >> 16) == 0;\n\t}\n\n\treturn true;\n}\n\n \nstatic int e1000_setup_tx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_tx_ring *txdr)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint size;\n\n\tsize = sizeof(struct e1000_tx_buffer) * txdr->count;\n\ttxdr->buffer_info = vzalloc(size);\n\tif (!txdr->buffer_info)\n\t\treturn -ENOMEM;\n\n\t \n\n\ttxdr->size = txdr->count * sizeof(struct e1000_tx_desc);\n\ttxdr->size = ALIGN(txdr->size, 4096);\n\n\ttxdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!txdr->desc) {\nsetup_tx_desc_die:\n\t\tvfree(txdr->buffer_info);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {\n\t\tvoid *olddesc = txdr->desc;\n\t\tdma_addr_t olddma = txdr->dma;\n\t\te_err(tx_err, \"txdr align check failed: %u bytes at %p\\n\",\n\t\t      txdr->size, txdr->desc);\n\t\t \n\t\ttxdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size,\n\t\t\t\t\t\t&txdr->dma, GFP_KERNEL);\n\t\t \n\t\tif (!txdr->desc) {\n\t\t\tdma_free_coherent(&pdev->dev, txdr->size, olddesc,\n\t\t\t\t\t  olddma);\n\t\t\tgoto setup_tx_desc_die;\n\t\t}\n\n\t\tif (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {\n\t\t\t \n\t\t\tdma_free_coherent(&pdev->dev, txdr->size, txdr->desc,\n\t\t\t\t\t  txdr->dma);\n\t\t\tdma_free_coherent(&pdev->dev, txdr->size, olddesc,\n\t\t\t\t\t  olddma);\n\t\t\te_err(probe, \"Unable to allocate aligned memory \"\n\t\t\t      \"for the transmit descriptor ring\\n\");\n\t\t\tvfree(txdr->buffer_info);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\t \n\t\t\tdma_free_coherent(&pdev->dev, txdr->size, olddesc,\n\t\t\t\t\t  olddma);\n\t\t}\n\t}\n\tmemset(txdr->desc, 0, txdr->size);\n\n\ttxdr->next_to_use = 0;\n\ttxdr->next_to_clean = 0;\n\n\treturn 0;\n}\n\n \nint e1000_setup_all_tx_resources(struct e1000_adapter *adapter)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\terr = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);\n\t\tif (err) {\n\t\t\te_err(probe, \"Allocation for Tx Queue %u failed\\n\", i);\n\t\t\tfor (i-- ; i >= 0; i--)\n\t\t\t\te1000_free_tx_resources(adapter,\n\t\t\t\t\t\t\t&adapter->tx_ring[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic void e1000_configure_tx(struct e1000_adapter *adapter)\n{\n\tu64 tdba;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tdlen, tctl, tipg;\n\tu32 ipgr1, ipgr2;\n\n\t \n\n\tswitch (adapter->num_tx_queues) {\n\tcase 1:\n\tdefault:\n\t\ttdba = adapter->tx_ring[0].dma;\n\t\ttdlen = adapter->tx_ring[0].count *\n\t\t\tsizeof(struct e1000_tx_desc);\n\t\tew32(TDLEN, tdlen);\n\t\tew32(TDBAH, (tdba >> 32));\n\t\tew32(TDBAL, (tdba & 0x00000000ffffffffULL));\n\t\tew32(TDT, 0);\n\t\tew32(TDH, 0);\n\t\tadapter->tx_ring[0].tdh = ((hw->mac_type >= e1000_82543) ?\n\t\t\t\t\t   E1000_TDH : E1000_82542_TDH);\n\t\tadapter->tx_ring[0].tdt = ((hw->mac_type >= e1000_82543) ?\n\t\t\t\t\t   E1000_TDT : E1000_82542_TDT);\n\t\tbreak;\n\t}\n\n\t \n\tif ((hw->media_type == e1000_media_type_fiber ||\n\t     hw->media_type == e1000_media_type_internal_serdes))\n\t\ttipg = DEFAULT_82543_TIPG_IPGT_FIBER;\n\telse\n\t\ttipg = DEFAULT_82543_TIPG_IPGT_COPPER;\n\n\tswitch (hw->mac_type) {\n\tcase e1000_82542_rev2_0:\n\tcase e1000_82542_rev2_1:\n\t\ttipg = DEFAULT_82542_TIPG_IPGT;\n\t\tipgr1 = DEFAULT_82542_TIPG_IPGR1;\n\t\tipgr2 = DEFAULT_82542_TIPG_IPGR2;\n\t\tbreak;\n\tdefault:\n\t\tipgr1 = DEFAULT_82543_TIPG_IPGR1;\n\t\tipgr2 = DEFAULT_82543_TIPG_IPGR2;\n\t\tbreak;\n\t}\n\ttipg |= ipgr1 << E1000_TIPG_IPGR1_SHIFT;\n\ttipg |= ipgr2 << E1000_TIPG_IPGR2_SHIFT;\n\tew32(TIPG, tipg);\n\n\t \n\n\tew32(TIDV, adapter->tx_int_delay);\n\tif (hw->mac_type >= e1000_82540)\n\t\tew32(TADV, adapter->tx_abs_int_delay);\n\n\t \n\n\ttctl = er32(TCTL);\n\ttctl &= ~E1000_TCTL_CT;\n\ttctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |\n\t\t(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);\n\n\te1000_config_collision_dist(hw);\n\n\t \n\tadapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;\n\n\t \n\tif (adapter->tx_int_delay)\n\t\tadapter->txd_cmd |= E1000_TXD_CMD_IDE;\n\n\tif (hw->mac_type < e1000_82543)\n\t\tadapter->txd_cmd |= E1000_TXD_CMD_RPS;\n\telse\n\t\tadapter->txd_cmd |= E1000_TXD_CMD_RS;\n\n\t \n\tif (hw->mac_type == e1000_82544 &&\n\t    hw->bus_type == e1000_bus_type_pcix)\n\t\tadapter->pcix_82544 = true;\n\n\tew32(TCTL, tctl);\n\n}\n\n \nstatic int e1000_setup_rx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_rx_ring *rxdr)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint size, desc_len;\n\n\tsize = sizeof(struct e1000_rx_buffer) * rxdr->count;\n\trxdr->buffer_info = vzalloc(size);\n\tif (!rxdr->buffer_info)\n\t\treturn -ENOMEM;\n\n\tdesc_len = sizeof(struct e1000_rx_desc);\n\n\t \n\n\trxdr->size = rxdr->count * desc_len;\n\trxdr->size = ALIGN(rxdr->size, 4096);\n\n\trxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!rxdr->desc) {\nsetup_rx_desc_die:\n\t\tvfree(rxdr->buffer_info);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {\n\t\tvoid *olddesc = rxdr->desc;\n\t\tdma_addr_t olddma = rxdr->dma;\n\t\te_err(rx_err, \"rxdr align check failed: %u bytes at %p\\n\",\n\t\t      rxdr->size, rxdr->desc);\n\t\t \n\t\trxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size,\n\t\t\t\t\t\t&rxdr->dma, GFP_KERNEL);\n\t\t \n\t\tif (!rxdr->desc) {\n\t\t\tdma_free_coherent(&pdev->dev, rxdr->size, olddesc,\n\t\t\t\t\t  olddma);\n\t\t\tgoto setup_rx_desc_die;\n\t\t}\n\n\t\tif (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {\n\t\t\t \n\t\t\tdma_free_coherent(&pdev->dev, rxdr->size, rxdr->desc,\n\t\t\t\t\t  rxdr->dma);\n\t\t\tdma_free_coherent(&pdev->dev, rxdr->size, olddesc,\n\t\t\t\t\t  olddma);\n\t\t\te_err(probe, \"Unable to allocate aligned memory for \"\n\t\t\t      \"the Rx descriptor ring\\n\");\n\t\t\tgoto setup_rx_desc_die;\n\t\t} else {\n\t\t\t \n\t\t\tdma_free_coherent(&pdev->dev, rxdr->size, olddesc,\n\t\t\t\t\t  olddma);\n\t\t}\n\t}\n\tmemset(rxdr->desc, 0, rxdr->size);\n\n\trxdr->next_to_clean = 0;\n\trxdr->next_to_use = 0;\n\trxdr->rx_skb_top = NULL;\n\n\treturn 0;\n}\n\n \nint e1000_setup_all_rx_resources(struct e1000_adapter *adapter)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\terr = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);\n\t\tif (err) {\n\t\t\te_err(probe, \"Allocation for Rx Queue %u failed\\n\", i);\n\t\t\tfor (i-- ; i >= 0; i--)\n\t\t\t\te1000_free_rx_resources(adapter,\n\t\t\t\t\t\t\t&adapter->rx_ring[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic void e1000_setup_rctl(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\trctl = er32(RCTL);\n\n\trctl &= ~(3 << E1000_RCTL_MO_SHIFT);\n\n\trctl |= E1000_RCTL_BAM | E1000_RCTL_LBM_NO |\n\t\tE1000_RCTL_RDMTS_HALF |\n\t\t(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);\n\n\tif (hw->tbi_compatibility_on == 1)\n\t\trctl |= E1000_RCTL_SBP;\n\telse\n\t\trctl &= ~E1000_RCTL_SBP;\n\n\tif (adapter->netdev->mtu <= ETH_DATA_LEN)\n\t\trctl &= ~E1000_RCTL_LPE;\n\telse\n\t\trctl |= E1000_RCTL_LPE;\n\n\t \n\trctl &= ~E1000_RCTL_SZ_4096;\n\trctl |= E1000_RCTL_BSEX;\n\tswitch (adapter->rx_buffer_len) {\n\tcase E1000_RXBUFFER_2048:\n\tdefault:\n\t\trctl |= E1000_RCTL_SZ_2048;\n\t\trctl &= ~E1000_RCTL_BSEX;\n\t\tbreak;\n\tcase E1000_RXBUFFER_4096:\n\t\trctl |= E1000_RCTL_SZ_4096;\n\t\tbreak;\n\tcase E1000_RXBUFFER_8192:\n\t\trctl |= E1000_RCTL_SZ_8192;\n\t\tbreak;\n\tcase E1000_RXBUFFER_16384:\n\t\trctl |= E1000_RCTL_SZ_16384;\n\t\tbreak;\n\t}\n\n\t \n\tif (adapter->netdev->features & NETIF_F_RXALL) {\n\t\t \n\t\trctl |= (E1000_RCTL_SBP |  \n\t\t\t E1000_RCTL_BAM |  \n\t\t\t E1000_RCTL_PMCF);  \n\n\t\trctl &= ~(E1000_RCTL_VFE |  \n\t\t\t  E1000_RCTL_DPF |  \n\t\t\t  E1000_RCTL_CFIEN);  \n\t\t \n\t}\n\n\tew32(RCTL, rctl);\n}\n\n \nstatic void e1000_configure_rx(struct e1000_adapter *adapter)\n{\n\tu64 rdba;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rdlen, rctl, rxcsum;\n\n\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\trdlen = adapter->rx_ring[0].count *\n\t\t\tsizeof(struct e1000_rx_desc);\n\t\tadapter->clean_rx = e1000_clean_jumbo_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;\n\t} else {\n\t\trdlen = adapter->rx_ring[0].count *\n\t\t\tsizeof(struct e1000_rx_desc);\n\t\tadapter->clean_rx = e1000_clean_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_rx_buffers;\n\t}\n\n\t \n\trctl = er32(RCTL);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\n\t \n\tew32(RDTR, adapter->rx_int_delay);\n\n\tif (hw->mac_type >= e1000_82540) {\n\t\tew32(RADV, adapter->rx_abs_int_delay);\n\t\tif (adapter->itr_setting != 0)\n\t\t\tew32(ITR, 1000000000 / (adapter->itr * 256));\n\t}\n\n\t \n\tswitch (adapter->num_rx_queues) {\n\tcase 1:\n\tdefault:\n\t\trdba = adapter->rx_ring[0].dma;\n\t\tew32(RDLEN, rdlen);\n\t\tew32(RDBAH, (rdba >> 32));\n\t\tew32(RDBAL, (rdba & 0x00000000ffffffffULL));\n\t\tew32(RDT, 0);\n\t\tew32(RDH, 0);\n\t\tadapter->rx_ring[0].rdh = ((hw->mac_type >= e1000_82543) ?\n\t\t\t\t\t   E1000_RDH : E1000_82542_RDH);\n\t\tadapter->rx_ring[0].rdt = ((hw->mac_type >= e1000_82543) ?\n\t\t\t\t\t   E1000_RDT : E1000_82542_RDT);\n\t\tbreak;\n\t}\n\n\t \n\tif (hw->mac_type >= e1000_82543) {\n\t\trxcsum = er32(RXCSUM);\n\t\tif (adapter->rx_csum)\n\t\t\trxcsum |= E1000_RXCSUM_TUOFL;\n\t\telse\n\t\t\t \n\t\t\trxcsum &= ~E1000_RXCSUM_TUOFL;\n\t\tew32(RXCSUM, rxcsum);\n\t}\n\n\t \n\tew32(RCTL, rctl | E1000_RCTL_EN);\n}\n\n \nstatic void e1000_free_tx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_tx_ring *tx_ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\te1000_clean_tx_ring(adapter, tx_ring);\n\n\tvfree(tx_ring->buffer_info);\n\ttx_ring->buffer_info = NULL;\n\n\tdma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,\n\t\t\t  tx_ring->dma);\n\n\ttx_ring->desc = NULL;\n}\n\n \nvoid e1000_free_all_tx_resources(struct e1000_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\te1000_free_tx_resources(adapter, &adapter->tx_ring[i]);\n}\n\nstatic void\ne1000_unmap_and_free_tx_resource(struct e1000_adapter *adapter,\n\t\t\t\t struct e1000_tx_buffer *buffer_info,\n\t\t\t\t int budget)\n{\n\tif (buffer_info->dma) {\n\t\tif (buffer_info->mapped_as_page)\n\t\t\tdma_unmap_page(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t       buffer_info->length, DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t\t buffer_info->length,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\tbuffer_info->dma = 0;\n\t}\n\tif (buffer_info->skb) {\n\t\tnapi_consume_skb(buffer_info->skb, budget);\n\t\tbuffer_info->skb = NULL;\n\t}\n\tbuffer_info->time_stamp = 0;\n\t \n}\n\n \nstatic void e1000_clean_tx_ring(struct e1000_adapter *adapter,\n\t\t\t\tstruct e1000_tx_ring *tx_ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_tx_buffer *buffer_info;\n\tunsigned long size;\n\tunsigned int i;\n\n\t \n\n\tfor (i = 0; i < tx_ring->count; i++) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\te1000_unmap_and_free_tx_resource(adapter, buffer_info, 0);\n\t}\n\n\tnetdev_reset_queue(adapter->netdev);\n\tsize = sizeof(struct e1000_tx_buffer) * tx_ring->count;\n\tmemset(tx_ring->buffer_info, 0, size);\n\n\t \n\n\tmemset(tx_ring->desc, 0, tx_ring->size);\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\ttx_ring->last_tx_tso = false;\n\n\twritel(0, hw->hw_addr + tx_ring->tdh);\n\twritel(0, hw->hw_addr + tx_ring->tdt);\n}\n\n \nstatic void e1000_clean_all_tx_rings(struct e1000_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\te1000_clean_tx_ring(adapter, &adapter->tx_ring[i]);\n}\n\n \nstatic void e1000_free_rx_resources(struct e1000_adapter *adapter,\n\t\t\t\t    struct e1000_rx_ring *rx_ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\te1000_clean_rx_ring(adapter, rx_ring);\n\n\tvfree(rx_ring->buffer_info);\n\trx_ring->buffer_info = NULL;\n\n\tdma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,\n\t\t\t  rx_ring->dma);\n\n\trx_ring->desc = NULL;\n}\n\n \nvoid e1000_free_all_rx_resources(struct e1000_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\te1000_free_rx_resources(adapter, &adapter->rx_ring[i]);\n}\n\n#define E1000_HEADROOM (NET_SKB_PAD + NET_IP_ALIGN)\nstatic unsigned int e1000_frag_len(const struct e1000_adapter *a)\n{\n\treturn SKB_DATA_ALIGN(a->rx_buffer_len + E1000_HEADROOM) +\n\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n}\n\nstatic void *e1000_alloc_frag(const struct e1000_adapter *a)\n{\n\tunsigned int len = e1000_frag_len(a);\n\tu8 *data = netdev_alloc_frag(len);\n\n\tif (likely(data))\n\t\tdata += E1000_HEADROOM;\n\treturn data;\n}\n\n \nstatic void e1000_clean_rx_ring(struct e1000_adapter *adapter,\n\t\t\t\tstruct e1000_rx_ring *rx_ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_rx_buffer *buffer_info;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunsigned long size;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tif (adapter->clean_rx == e1000_clean_rx_irq) {\n\t\t\tif (buffer_info->dma)\n\t\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t\t adapter->rx_buffer_len,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tif (buffer_info->rxbuf.data) {\n\t\t\t\tskb_free_frag(buffer_info->rxbuf.data);\n\t\t\t\tbuffer_info->rxbuf.data = NULL;\n\t\t\t}\n\t\t} else if (adapter->clean_rx == e1000_clean_jumbo_rx_irq) {\n\t\t\tif (buffer_info->dma)\n\t\t\t\tdma_unmap_page(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t       adapter->rx_buffer_len,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tif (buffer_info->rxbuf.page) {\n\t\t\t\tput_page(buffer_info->rxbuf.page);\n\t\t\t\tbuffer_info->rxbuf.page = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbuffer_info->dma = 0;\n\t}\n\n\t \n\tnapi_free_frags(&adapter->napi);\n\trx_ring->rx_skb_top = NULL;\n\n\tsize = sizeof(struct e1000_rx_buffer) * rx_ring->count;\n\tmemset(rx_ring->buffer_info, 0, size);\n\n\t \n\tmemset(rx_ring->desc, 0, rx_ring->size);\n\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\n\twritel(0, hw->hw_addr + rx_ring->rdh);\n\twritel(0, hw->hw_addr + rx_ring->rdt);\n}\n\n \nstatic void e1000_clean_all_rx_rings(struct e1000_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\te1000_clean_rx_ring(adapter, &adapter->rx_ring[i]);\n}\n\n \nstatic void e1000_enter_82542_rst(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 rctl;\n\n\te1000_pci_clear_mwi(hw);\n\n\trctl = er32(RCTL);\n\trctl |= E1000_RCTL_RST;\n\tew32(RCTL, rctl);\n\tE1000_WRITE_FLUSH();\n\tmdelay(5);\n\n\tif (netif_running(netdev))\n\t\te1000_clean_all_rx_rings(adapter);\n}\n\nstatic void e1000_leave_82542_rst(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 rctl;\n\n\trctl = er32(RCTL);\n\trctl &= ~E1000_RCTL_RST;\n\tew32(RCTL, rctl);\n\tE1000_WRITE_FLUSH();\n\tmdelay(5);\n\n\tif (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)\n\t\te1000_pci_set_mwi(hw);\n\n\tif (netif_running(netdev)) {\n\t\t \n\t\tstruct e1000_rx_ring *ring = &adapter->rx_ring[0];\n\t\te1000_configure_rx(adapter);\n\t\tadapter->alloc_rx_buf(adapter, ring, E1000_DESC_UNUSED(ring));\n\t}\n}\n\n \nstatic int e1000_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\n\tif (hw->mac_type == e1000_82542_rev2_0)\n\t\te1000_enter_82542_rst(adapter);\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tmemcpy(hw->mac_addr, addr->sa_data, netdev->addr_len);\n\n\te1000_rar_set(hw, hw->mac_addr, 0);\n\n\tif (hw->mac_type == e1000_82542_rev2_0)\n\t\te1000_leave_82542_rst(adapter);\n\n\treturn 0;\n}\n\n \nstatic void e1000_set_rx_mode(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tbool use_uc = false;\n\tu32 rctl;\n\tu32 hash_value;\n\tint i, rar_entries = E1000_RAR_ENTRIES;\n\tint mta_reg_count = E1000_NUM_MTA_REGISTERS;\n\tu32 *mcarray = kcalloc(mta_reg_count, sizeof(u32), GFP_ATOMIC);\n\n\tif (!mcarray)\n\t\treturn;\n\n\t \n\n\trctl = er32(RCTL);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);\n\t\trctl &= ~E1000_RCTL_VFE;\n\t} else {\n\t\tif (netdev->flags & IFF_ALLMULTI)\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\telse\n\t\t\trctl &= ~E1000_RCTL_MPE;\n\t\t \n\t\tif (e1000_vlan_used(adapter))\n\t\t\trctl |= E1000_RCTL_VFE;\n\t}\n\n\tif (netdev_uc_count(netdev) > rar_entries - 1) {\n\t\trctl |= E1000_RCTL_UPE;\n\t} else if (!(netdev->flags & IFF_PROMISC)) {\n\t\trctl &= ~E1000_RCTL_UPE;\n\t\tuse_uc = true;\n\t}\n\n\tew32(RCTL, rctl);\n\n\t \n\n\tif (hw->mac_type == e1000_82542_rev2_0)\n\t\te1000_enter_82542_rst(adapter);\n\n\t \n\ti = 1;\n\tif (use_uc)\n\t\tnetdev_for_each_uc_addr(ha, netdev) {\n\t\t\tif (i == rar_entries)\n\t\t\t\tbreak;\n\t\t\te1000_rar_set(hw, ha->addr, i++);\n\t\t}\n\n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\tif (i == rar_entries) {\n\t\t\t \n\t\t\tu32 hash_reg, hash_bit, mta;\n\t\t\thash_value = e1000_hash_mc_addr(hw, ha->addr);\n\t\t\thash_reg = (hash_value >> 5) & 0x7F;\n\t\t\thash_bit = hash_value & 0x1F;\n\t\t\tmta = (1 << hash_bit);\n\t\t\tmcarray[hash_reg] |= mta;\n\t\t} else {\n\t\t\te1000_rar_set(hw, ha->addr, i++);\n\t\t}\n\t}\n\n\tfor (; i < rar_entries; i++) {\n\t\tE1000_WRITE_REG_ARRAY(hw, RA, i << 1, 0);\n\t\tE1000_WRITE_FLUSH();\n\t\tE1000_WRITE_REG_ARRAY(hw, RA, (i << 1) + 1, 0);\n\t\tE1000_WRITE_FLUSH();\n\t}\n\n\t \n\tfor (i = mta_reg_count - 1; i >= 0 ; i--) {\n\t\t \n\t\tE1000_WRITE_REG_ARRAY(hw, MTA, i, mcarray[i]);\n\t}\n\tE1000_WRITE_FLUSH();\n\n\tif (hw->mac_type == e1000_82542_rev2_0)\n\t\te1000_leave_82542_rst(adapter);\n\n\tkfree(mcarray);\n}\n\n \nstatic void e1000_update_phy_info_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     phy_info_task.work);\n\n\te1000_phy_get_info(&adapter->hw, &adapter->phy_info);\n}\n\n \nstatic void e1000_82547_tx_fifo_stall_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     fifo_stall_task.work);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 tctl;\n\n\tif (atomic_read(&adapter->tx_fifo_stall)) {\n\t\tif ((er32(TDT) == er32(TDH)) &&\n\t\t   (er32(TDFT) == er32(TDFH)) &&\n\t\t   (er32(TDFTS) == er32(TDFHS))) {\n\t\t\ttctl = er32(TCTL);\n\t\t\tew32(TCTL, tctl & ~E1000_TCTL_EN);\n\t\t\tew32(TDFT, adapter->tx_head_addr);\n\t\t\tew32(TDFH, adapter->tx_head_addr);\n\t\t\tew32(TDFTS, adapter->tx_head_addr);\n\t\t\tew32(TDFHS, adapter->tx_head_addr);\n\t\t\tew32(TCTL, tctl);\n\t\t\tE1000_WRITE_FLUSH();\n\n\t\t\tadapter->tx_fifo_head = 0;\n\t\t\tatomic_set(&adapter->tx_fifo_stall, 0);\n\t\t\tnetif_wake_queue(netdev);\n\t\t} else if (!test_bit(__E1000_DOWN, &adapter->flags)) {\n\t\t\tschedule_delayed_work(&adapter->fifo_stall_task, 1);\n\t\t}\n\t}\n}\n\nbool e1000_has_link(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool link_active = false;\n\n\t \n\tswitch (hw->media_type) {\n\tcase e1000_media_type_copper:\n\t\tif (hw->mac_type == e1000_ce4100)\n\t\t\thw->get_link_status = 1;\n\t\tif (hw->get_link_status) {\n\t\t\te1000_check_for_link(hw);\n\t\t\tlink_active = !hw->get_link_status;\n\t\t} else {\n\t\t\tlink_active = true;\n\t\t}\n\t\tbreak;\n\tcase e1000_media_type_fiber:\n\t\te1000_check_for_link(hw);\n\t\tlink_active = !!(er32(STATUS) & E1000_STATUS_LU);\n\t\tbreak;\n\tcase e1000_media_type_internal_serdes:\n\t\te1000_check_for_link(hw);\n\t\tlink_active = hw->serdes_has_link;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn link_active;\n}\n\n \nstatic void e1000_watchdog(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     watchdog_task.work);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_tx_ring *txdr = adapter->tx_ring;\n\tu32 link, tctl;\n\n\tlink = e1000_has_link(adapter);\n\tif ((netif_carrier_ok(netdev)) && link)\n\t\tgoto link_up;\n\n\tif (link) {\n\t\tif (!netif_carrier_ok(netdev)) {\n\t\t\tu32 ctrl;\n\t\t\t \n\t\t\te1000_get_speed_and_duplex(hw,\n\t\t\t\t\t\t   &adapter->link_speed,\n\t\t\t\t\t\t   &adapter->link_duplex);\n\n\t\t\tctrl = er32(CTRL);\n\t\t\tpr_info(\"%s NIC Link is Up %d Mbps %s, \"\n\t\t\t\t\"Flow Control: %s\\n\",\n\t\t\t\tnetdev->name,\n\t\t\t\tadapter->link_speed,\n\t\t\t\tadapter->link_duplex == FULL_DUPLEX ?\n\t\t\t\t\"Full Duplex\" : \"Half Duplex\",\n\t\t\t\t((ctrl & E1000_CTRL_TFCE) && (ctrl &\n\t\t\t\tE1000_CTRL_RFCE)) ? \"RX/TX\" : ((ctrl &\n\t\t\t\tE1000_CTRL_RFCE) ? \"RX\" : ((ctrl &\n\t\t\t\tE1000_CTRL_TFCE) ? \"TX\" : \"None\")));\n\n\t\t\t \n\t\t\tadapter->tx_timeout_factor = 1;\n\t\t\tswitch (adapter->link_speed) {\n\t\t\tcase SPEED_10:\n\t\t\t\tadapter->tx_timeout_factor = 16;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_100:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\ttctl = er32(TCTL);\n\t\t\ttctl |= E1000_TCTL_EN;\n\t\t\tew32(TCTL, tctl);\n\n\t\t\tnetif_carrier_on(netdev);\n\t\t\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\t\t\tschedule_delayed_work(&adapter->phy_info_task,\n\t\t\t\t\t\t      2 * HZ);\n\t\t\tadapter->smartspeed = 0;\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tadapter->link_speed = 0;\n\t\t\tadapter->link_duplex = 0;\n\t\t\tpr_info(\"%s NIC Link is Down\\n\",\n\t\t\t\tnetdev->name);\n\t\t\tnetif_carrier_off(netdev);\n\n\t\t\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\t\t\tschedule_delayed_work(&adapter->phy_info_task,\n\t\t\t\t\t\t      2 * HZ);\n\t\t}\n\n\t\te1000_smartspeed(adapter);\n\t}\n\nlink_up:\n\te1000_update_stats(adapter);\n\n\thw->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;\n\tadapter->tpt_old = adapter->stats.tpt;\n\thw->collision_delta = adapter->stats.colc - adapter->colc_old;\n\tadapter->colc_old = adapter->stats.colc;\n\n\tadapter->gorcl = adapter->stats.gorcl - adapter->gorcl_old;\n\tadapter->gorcl_old = adapter->stats.gorcl;\n\tadapter->gotcl = adapter->stats.gotcl - adapter->gotcl_old;\n\tadapter->gotcl_old = adapter->stats.gotcl;\n\n\te1000_update_adaptive(hw);\n\n\tif (!netif_carrier_ok(netdev)) {\n\t\tif (E1000_DESC_UNUSED(txdr) + 1 < txdr->count) {\n\t\t\t \n\t\t\tadapter->tx_timeout_count++;\n\t\t\tschedule_work(&adapter->reset_task);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (hw->mac_type >= e1000_82540 && adapter->itr_setting == 4) {\n\t\t \n\t\tu32 goc = (adapter->gotcl + adapter->gorcl) / 10000;\n\t\tu32 dif = (adapter->gotcl > adapter->gorcl ?\n\t\t\t    adapter->gotcl - adapter->gorcl :\n\t\t\t    adapter->gorcl - adapter->gotcl) / 10000;\n\t\tu32 itr = goc > 0 ? (dif * 6000 / goc + 2000) : 8000;\n\n\t\tew32(ITR, 1000000000 / (itr * 256));\n\t}\n\n\t \n\tew32(ICS, E1000_ICS_RXDMT0);\n\n\t \n\tadapter->detect_tx_hung = true;\n\n\t \n\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\tschedule_delayed_work(&adapter->watchdog_task, 2 * HZ);\n}\n\nenum latency_range {\n\tlowest_latency = 0,\n\tlow_latency = 1,\n\tbulk_latency = 2,\n\tlatency_invalid = 255\n};\n\n \nstatic unsigned int e1000_update_itr(struct e1000_adapter *adapter,\n\t\t\t\t     u16 itr_setting, int packets, int bytes)\n{\n\tunsigned int retval = itr_setting;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (unlikely(hw->mac_type < e1000_82540))\n\t\tgoto update_itr_done;\n\n\tif (packets == 0)\n\t\tgoto update_itr_done;\n\n\tswitch (itr_setting) {\n\tcase lowest_latency:\n\t\t \n\t\tif (bytes/packets > 8000)\n\t\t\tretval = bulk_latency;\n\t\telse if ((packets < 5) && (bytes > 512))\n\t\t\tretval = low_latency;\n\t\tbreak;\n\tcase low_latency:   \n\t\tif (bytes > 10000) {\n\t\t\t \n\t\t\tif (bytes/packets > 8000)\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets < 10) || ((bytes/packets) > 1200))\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets > 35))\n\t\t\t\tretval = lowest_latency;\n\t\t} else if (bytes/packets > 2000)\n\t\t\tretval = bulk_latency;\n\t\telse if (packets <= 2 && bytes < 512)\n\t\t\tretval = lowest_latency;\n\t\tbreak;\n\tcase bulk_latency:  \n\t\tif (bytes > 25000) {\n\t\t\tif (packets > 35)\n\t\t\t\tretval = low_latency;\n\t\t} else if (bytes < 6000) {\n\t\t\tretval = low_latency;\n\t\t}\n\t\tbreak;\n\t}\n\nupdate_itr_done:\n\treturn retval;\n}\n\nstatic void e1000_set_itr(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 current_itr;\n\tu32 new_itr = adapter->itr;\n\n\tif (unlikely(hw->mac_type < e1000_82540))\n\t\treturn;\n\n\t \n\tif (unlikely(adapter->link_speed != SPEED_1000)) {\n\t\tnew_itr = 4000;\n\t\tgoto set_itr_now;\n\t}\n\n\tadapter->tx_itr = e1000_update_itr(adapter, adapter->tx_itr,\n\t\t\t\t\t   adapter->total_tx_packets,\n\t\t\t\t\t   adapter->total_tx_bytes);\n\t \n\tif (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)\n\t\tadapter->tx_itr = low_latency;\n\n\tadapter->rx_itr = e1000_update_itr(adapter, adapter->rx_itr,\n\t\t\t\t\t   adapter->total_rx_packets,\n\t\t\t\t\t   adapter->total_rx_bytes);\n\t \n\tif (adapter->itr_setting == 3 && adapter->rx_itr == lowest_latency)\n\t\tadapter->rx_itr = low_latency;\n\n\tcurrent_itr = max(adapter->rx_itr, adapter->tx_itr);\n\n\tswitch (current_itr) {\n\t \n\tcase lowest_latency:\n\t\tnew_itr = 70000;\n\t\tbreak;\n\tcase low_latency:\n\t\tnew_itr = 20000;  \n\t\tbreak;\n\tcase bulk_latency:\n\t\tnew_itr = 4000;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nset_itr_now:\n\tif (new_itr != adapter->itr) {\n\t\t \n\t\tnew_itr = new_itr > adapter->itr ?\n\t\t\t  min(adapter->itr + (new_itr >> 2), new_itr) :\n\t\t\t  new_itr;\n\t\tadapter->itr = new_itr;\n\t\tew32(ITR, 1000000000 / (new_itr * 256));\n\t}\n}\n\n#define E1000_TX_FLAGS_CSUM\t\t0x00000001\n#define E1000_TX_FLAGS_VLAN\t\t0x00000002\n#define E1000_TX_FLAGS_TSO\t\t0x00000004\n#define E1000_TX_FLAGS_IPV4\t\t0x00000008\n#define E1000_TX_FLAGS_NO_FCS\t\t0x00000010\n#define E1000_TX_FLAGS_VLAN_MASK\t0xffff0000\n#define E1000_TX_FLAGS_VLAN_SHIFT\t16\n\nstatic int e1000_tso(struct e1000_adapter *adapter,\n\t\t     struct e1000_tx_ring *tx_ring, struct sk_buff *skb,\n\t\t     __be16 protocol)\n{\n\tstruct e1000_context_desc *context_desc;\n\tstruct e1000_tx_buffer *buffer_info;\n\tunsigned int i;\n\tu32 cmd_length = 0;\n\tu16 ipcse = 0, tucse, mss;\n\tu8 ipcss, ipcso, tucss, tucso, hdr_len;\n\n\tif (skb_is_gso(skb)) {\n\t\tint err;\n\n\t\terr = skb_cow_head(skb, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\thdr_len = skb_tcp_all_headers(skb);\n\t\tmss = skb_shinfo(skb)->gso_size;\n\t\tif (protocol == htons(ETH_P_IP)) {\n\t\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\t\tiph->tot_len = 0;\n\t\t\tiph->check = 0;\n\t\t\ttcp_hdr(skb)->check = ~csum_tcpudp_magic(iph->saddr,\n\t\t\t\t\t\t\t\t iph->daddr, 0,\n\t\t\t\t\t\t\t\t IPPROTO_TCP,\n\t\t\t\t\t\t\t\t 0);\n\t\t\tcmd_length = E1000_TXD_CMD_IP;\n\t\t\tipcse = skb_transport_offset(skb) - 1;\n\t\t} else if (skb_is_gso_v6(skb)) {\n\t\t\ttcp_v6_gso_csum_prep(skb);\n\t\t\tipcse = 0;\n\t\t}\n\t\tipcss = skb_network_offset(skb);\n\t\tipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;\n\t\ttucss = skb_transport_offset(skb);\n\t\ttucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;\n\t\ttucse = 0;\n\n\t\tcmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |\n\t\t\t       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));\n\n\t\ti = tx_ring->next_to_use;\n\t\tcontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\n\t\tcontext_desc->lower_setup.ip_fields.ipcss  = ipcss;\n\t\tcontext_desc->lower_setup.ip_fields.ipcso  = ipcso;\n\t\tcontext_desc->lower_setup.ip_fields.ipcse  = cpu_to_le16(ipcse);\n\t\tcontext_desc->upper_setup.tcp_fields.tucss = tucss;\n\t\tcontext_desc->upper_setup.tcp_fields.tucso = tucso;\n\t\tcontext_desc->upper_setup.tcp_fields.tucse = cpu_to_le16(tucse);\n\t\tcontext_desc->tcp_seg_setup.fields.mss     = cpu_to_le16(mss);\n\t\tcontext_desc->tcp_seg_setup.fields.hdr_len = hdr_len;\n\t\tcontext_desc->cmd_and_length = cpu_to_le32(cmd_length);\n\n\t\tbuffer_info->time_stamp = jiffies;\n\t\tbuffer_info->next_to_watch = i;\n\n\t\tif (++i == tx_ring->count)\n\t\t\ti = 0;\n\n\t\ttx_ring->next_to_use = i;\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool e1000_tx_csum(struct e1000_adapter *adapter,\n\t\t\t  struct e1000_tx_ring *tx_ring, struct sk_buff *skb,\n\t\t\t  __be16 protocol)\n{\n\tstruct e1000_context_desc *context_desc;\n\tstruct e1000_tx_buffer *buffer_info;\n\tunsigned int i;\n\tu8 css;\n\tu32 cmd_len = E1000_TXD_CMD_DEXT;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn false;\n\n\tswitch (protocol) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tif (ip_hdr(skb)->protocol == IPPROTO_TCP)\n\t\t\tcmd_len |= E1000_TXD_CMD_TCP;\n\t\tbreak;\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\t \n\t\tif (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)\n\t\t\tcmd_len |= E1000_TXD_CMD_TCP;\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely(net_ratelimit()))\n\t\t\te_warn(drv, \"checksum_partial proto=%x!\\n\",\n\t\t\t       skb->protocol);\n\t\tbreak;\n\t}\n\n\tcss = skb_checksum_start_offset(skb);\n\n\ti = tx_ring->next_to_use;\n\tbuffer_info = &tx_ring->buffer_info[i];\n\tcontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\n\n\tcontext_desc->lower_setup.ip_config = 0;\n\tcontext_desc->upper_setup.tcp_fields.tucss = css;\n\tcontext_desc->upper_setup.tcp_fields.tucso =\n\t\tcss + skb->csum_offset;\n\tcontext_desc->upper_setup.tcp_fields.tucse = 0;\n\tcontext_desc->tcp_seg_setup.data = 0;\n\tcontext_desc->cmd_and_length = cpu_to_le32(cmd_len);\n\n\tbuffer_info->time_stamp = jiffies;\n\tbuffer_info->next_to_watch = i;\n\n\tif (unlikely(++i == tx_ring->count))\n\t\ti = 0;\n\n\ttx_ring->next_to_use = i;\n\n\treturn true;\n}\n\n#define E1000_MAX_TXD_PWR\t12\n#define E1000_MAX_DATA_PER_TXD\t(1<<E1000_MAX_TXD_PWR)\n\nstatic int e1000_tx_map(struct e1000_adapter *adapter,\n\t\t\tstruct e1000_tx_ring *tx_ring,\n\t\t\tstruct sk_buff *skb, unsigned int first,\n\t\t\tunsigned int max_per_txd, unsigned int nr_frags,\n\t\t\tunsigned int mss)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_tx_buffer *buffer_info;\n\tunsigned int len = skb_headlen(skb);\n\tunsigned int offset = 0, size, count = 0, i;\n\tunsigned int f, bytecount, segs;\n\n\ti = tx_ring->next_to_use;\n\n\twhile (len) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tsize = min(len, max_per_txd);\n\t\t \n\t\tif (!skb->data_len && tx_ring->last_tx_tso &&\n\t\t    !skb_is_gso(skb)) {\n\t\t\ttx_ring->last_tx_tso = false;\n\t\t\tsize -= 4;\n\t\t}\n\n\t\t \n\t\tif (unlikely(mss && !nr_frags && size == len && size > 8))\n\t\t\tsize -= 4;\n\t\t \n\t\tif (unlikely((hw->bus_type == e1000_bus_type_pcix) &&\n\t\t\t     (size > 2015) && count == 0))\n\t\t\tsize = 2015;\n\n\t\t \n\t\tif (unlikely(adapter->pcix_82544 &&\n\t\t   !((unsigned long)(skb->data + offset + size - 1) & 4) &&\n\t\t   size > 4))\n\t\t\tsize -= 4;\n\n\t\tbuffer_info->length = size;\n\t\t \n\t\tbuffer_info->time_stamp = jiffies;\n\t\tbuffer_info->mapped_as_page = false;\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev,\n\t\t\t\t\t\t  skb->data + offset,\n\t\t\t\t\t\t  size, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma))\n\t\t\tgoto dma_error;\n\t\tbuffer_info->next_to_watch = i;\n\n\t\tlen -= size;\n\t\toffset += size;\n\t\tcount++;\n\t\tif (len) {\n\t\t\ti++;\n\t\t\tif (unlikely(i == tx_ring->count))\n\t\t\t\ti = 0;\n\t\t}\n\t}\n\n\tfor (f = 0; f < nr_frags; f++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[f];\n\n\t\tlen = skb_frag_size(frag);\n\t\toffset = 0;\n\n\t\twhile (len) {\n\t\t\tunsigned long bufend;\n\t\t\ti++;\n\t\t\tif (unlikely(i == tx_ring->count))\n\t\t\t\ti = 0;\n\n\t\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\t\tsize = min(len, max_per_txd);\n\t\t\t \n\t\t\tif (unlikely(mss && f == (nr_frags-1) &&\n\t\t\t    size == len && size > 8))\n\t\t\t\tsize -= 4;\n\t\t\t \n\t\t\tbufend = (unsigned long)\n\t\t\t\tpage_to_phys(skb_frag_page(frag));\n\t\t\tbufend += offset + size - 1;\n\t\t\tif (unlikely(adapter->pcix_82544 &&\n\t\t\t\t     !(bufend & 4) &&\n\t\t\t\t     size > 4))\n\t\t\t\tsize -= 4;\n\n\t\t\tbuffer_info->length = size;\n\t\t\tbuffer_info->time_stamp = jiffies;\n\t\t\tbuffer_info->mapped_as_page = true;\n\t\t\tbuffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,\n\t\t\t\t\t\toffset, size, DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma))\n\t\t\t\tgoto dma_error;\n\t\t\tbuffer_info->next_to_watch = i;\n\n\t\t\tlen -= size;\n\t\t\toffset += size;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tsegs = skb_shinfo(skb)->gso_segs ?: 1;\n\t \n\tbytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;\n\n\ttx_ring->buffer_info[i].skb = skb;\n\ttx_ring->buffer_info[i].segs = segs;\n\ttx_ring->buffer_info[i].bytecount = bytecount;\n\ttx_ring->buffer_info[first].next_to_watch = i;\n\n\treturn count;\n\ndma_error:\n\tdev_err(&pdev->dev, \"TX DMA map failed\\n\");\n\tbuffer_info->dma = 0;\n\tif (count)\n\t\tcount--;\n\n\twhile (count--) {\n\t\tif (i == 0)\n\t\t\ti += tx_ring->count;\n\t\ti--;\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\te1000_unmap_and_free_tx_resource(adapter, buffer_info, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void e1000_tx_queue(struct e1000_adapter *adapter,\n\t\t\t   struct e1000_tx_ring *tx_ring, int tx_flags,\n\t\t\t   int count)\n{\n\tstruct e1000_tx_desc *tx_desc = NULL;\n\tstruct e1000_tx_buffer *buffer_info;\n\tu32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;\n\tunsigned int i;\n\n\tif (likely(tx_flags & E1000_TX_FLAGS_TSO)) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |\n\t\t\t     E1000_TXD_CMD_TSE;\n\t\ttxd_upper |= E1000_TXD_POPTS_TXSM << 8;\n\n\t\tif (likely(tx_flags & E1000_TX_FLAGS_IPV4))\n\t\t\ttxd_upper |= E1000_TXD_POPTS_IXSM << 8;\n\t}\n\n\tif (likely(tx_flags & E1000_TX_FLAGS_CSUM)) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;\n\t\ttxd_upper |= E1000_TXD_POPTS_TXSM << 8;\n\t}\n\n\tif (unlikely(tx_flags & E1000_TX_FLAGS_VLAN)) {\n\t\ttxd_lower |= E1000_TXD_CMD_VLE;\n\t\ttxd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);\n\t}\n\n\tif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\n\t\ttxd_lower &= ~(E1000_TXD_CMD_IFCS);\n\n\ti = tx_ring->next_to_use;\n\n\twhile (count--) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\ttx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\n\t\ttx_desc->lower.data =\n\t\t\tcpu_to_le32(txd_lower | buffer_info->length);\n\t\ttx_desc->upper.data = cpu_to_le32(txd_upper);\n\t\tif (unlikely(++i == tx_ring->count))\n\t\t\ti = 0;\n\t}\n\n\ttx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);\n\n\t \n\tif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\n\t\ttx_desc->lower.data &= ~(cpu_to_le32(E1000_TXD_CMD_IFCS));\n\n\t \n\tdma_wmb();\n\n\ttx_ring->next_to_use = i;\n}\n\n \n\n#define E1000_FIFO_HDR\t\t\t0x10\n#define E1000_82547_PAD_LEN\t\t0x3E0\n\nstatic int e1000_82547_fifo_workaround(struct e1000_adapter *adapter,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tu32 fifo_space = adapter->tx_fifo_size - adapter->tx_fifo_head;\n\tu32 skb_fifo_len = skb->len + E1000_FIFO_HDR;\n\n\tskb_fifo_len = ALIGN(skb_fifo_len, E1000_FIFO_HDR);\n\n\tif (adapter->link_duplex != HALF_DUPLEX)\n\t\tgoto no_fifo_stall_required;\n\n\tif (atomic_read(&adapter->tx_fifo_stall))\n\t\treturn 1;\n\n\tif (skb_fifo_len >= (E1000_82547_PAD_LEN + fifo_space)) {\n\t\tatomic_set(&adapter->tx_fifo_stall, 1);\n\t\treturn 1;\n\t}\n\nno_fifo_stall_required:\n\tadapter->tx_fifo_head += skb_fifo_len;\n\tif (adapter->tx_fifo_head >= adapter->tx_fifo_size)\n\t\tadapter->tx_fifo_head -= adapter->tx_fifo_size;\n\treturn 0;\n}\n\nstatic int __e1000_maybe_stop_tx(struct net_device *netdev, int size)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_tx_ring *tx_ring = adapter->tx_ring;\n\n\tnetif_stop_queue(netdev);\n\t \n\tsmp_mb();\n\n\t \n\tif (likely(E1000_DESC_UNUSED(tx_ring) < size))\n\t\treturn -EBUSY;\n\n\t \n\tnetif_start_queue(netdev);\n\t++adapter->restart_queue;\n\treturn 0;\n}\n\nstatic int e1000_maybe_stop_tx(struct net_device *netdev,\n\t\t\t       struct e1000_tx_ring *tx_ring, int size)\n{\n\tif (likely(E1000_DESC_UNUSED(tx_ring) >= size))\n\t\treturn 0;\n\treturn __e1000_maybe_stop_tx(netdev, size);\n}\n\n#define TXD_USE_COUNT(S, X) (((S) + ((1 << (X)) - 1)) >> (X))\nstatic netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_tx_ring *tx_ring;\n\tunsigned int first, max_per_txd = E1000_MAX_DATA_PER_TXD;\n\tunsigned int max_txd_pwr = E1000_MAX_TXD_PWR;\n\tunsigned int tx_flags = 0;\n\tunsigned int len = skb_headlen(skb);\n\tunsigned int nr_frags;\n\tunsigned int mss;\n\tint count = 0;\n\tint tso;\n\tunsigned int f;\n\t__be16 protocol = vlan_get_protocol(skb);\n\n\t \n\ttx_ring = adapter->tx_ring;\n\n\t \n\tif (eth_skb_pad(skb))\n\t\treturn NETDEV_TX_OK;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\t \n\tif (mss) {\n\t\tu8 hdr_len;\n\t\tmax_per_txd = min(mss << 2, max_per_txd);\n\t\tmax_txd_pwr = fls(max_per_txd) - 1;\n\n\t\thdr_len = skb_tcp_all_headers(skb);\n\t\tif (skb->data_len && hdr_len == len) {\n\t\t\tswitch (hw->mac_type) {\n\t\t\tcase e1000_82544: {\n\t\t\t\tunsigned int pull_size;\n\n\t\t\t\t \n\t\t\t\tif ((unsigned long)(skb_tail_pointer(skb) - 1)\n\t\t\t\t    & 4)\n\t\t\t\t\tbreak;\n\t\t\t\tpull_size = min((unsigned int)4, skb->data_len);\n\t\t\t\tif (!__pskb_pull_tail(skb, pull_size)) {\n\t\t\t\t\te_err(drv, \"__pskb_pull_tail \"\n\t\t\t\t\t      \"failed.\\n\");\n\t\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t}\n\t\t\t\tlen = skb_headlen(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((mss) || (skb->ip_summed == CHECKSUM_PARTIAL))\n\t\tcount++;\n\tcount++;\n\n\t \n\tif (!skb->data_len && tx_ring->last_tx_tso && !skb_is_gso(skb))\n\t\tcount++;\n\n\tcount += TXD_USE_COUNT(len, max_txd_pwr);\n\n\tif (adapter->pcix_82544)\n\t\tcount++;\n\n\t \n\tif (unlikely((hw->bus_type == e1000_bus_type_pcix) &&\n\t\t\t(len > 2015)))\n\t\tcount++;\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tfor (f = 0; f < nr_frags; f++)\n\t\tcount += TXD_USE_COUNT(skb_frag_size(&skb_shinfo(skb)->frags[f]),\n\t\t\t\t       max_txd_pwr);\n\tif (adapter->pcix_82544)\n\t\tcount += nr_frags;\n\n\t \n\tif (unlikely(e1000_maybe_stop_tx(netdev, tx_ring, count + 2)))\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (unlikely((hw->mac_type == e1000_82547) &&\n\t\t     (e1000_82547_fifo_workaround(adapter, skb)))) {\n\t\tnetif_stop_queue(netdev);\n\t\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\t\tschedule_delayed_work(&adapter->fifo_stall_task, 1);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\ttx_flags |= E1000_TX_FLAGS_VLAN;\n\t\ttx_flags |= (skb_vlan_tag_get(skb) <<\n\t\t\t     E1000_TX_FLAGS_VLAN_SHIFT);\n\t}\n\n\tfirst = tx_ring->next_to_use;\n\n\ttso = e1000_tso(adapter, tx_ring, skb, protocol);\n\tif (tso < 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (likely(tso)) {\n\t\tif (likely(hw->mac_type != e1000_82544))\n\t\t\ttx_ring->last_tx_tso = true;\n\t\ttx_flags |= E1000_TX_FLAGS_TSO;\n\t} else if (likely(e1000_tx_csum(adapter, tx_ring, skb, protocol)))\n\t\ttx_flags |= E1000_TX_FLAGS_CSUM;\n\n\tif (protocol == htons(ETH_P_IP))\n\t\ttx_flags |= E1000_TX_FLAGS_IPV4;\n\n\tif (unlikely(skb->no_fcs))\n\t\ttx_flags |= E1000_TX_FLAGS_NO_FCS;\n\n\tcount = e1000_tx_map(adapter, tx_ring, skb, first, max_per_txd,\n\t\t\t     nr_frags, mss);\n\n\tif (count) {\n\t\t \n\t\tint desc_needed = MAX_SKB_FRAGS + 7;\n\n\t\tnetdev_sent_queue(netdev, skb->len);\n\t\tskb_tx_timestamp(skb);\n\n\t\te1000_tx_queue(adapter, tx_ring, tx_flags, count);\n\n\t\t \n\t\tif (adapter->pcix_82544)\n\t\t\tdesc_needed += MAX_SKB_FRAGS + 1;\n\n\t\t \n\t\te1000_maybe_stop_tx(netdev, tx_ring, desc_needed);\n\n\t\tif (!netdev_xmit_more() ||\n\t\t    netif_xmit_stopped(netdev_get_tx_queue(netdev, 0))) {\n\t\t\twritel(tx_ring->next_to_use, hw->hw_addr + tx_ring->tdt);\n\t\t}\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t\ttx_ring->buffer_info[first].time_stamp = 0;\n\t\ttx_ring->next_to_use = first;\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n#define NUM_REGS 38  \nstatic void e1000_regdump(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 regs[NUM_REGS];\n\tu32 *regs_buff = regs;\n\tint i = 0;\n\n\tstatic const char * const reg_name[] = {\n\t\t\"CTRL\",  \"STATUS\",\n\t\t\"RCTL\", \"RDLEN\", \"RDH\", \"RDT\", \"RDTR\",\n\t\t\"TCTL\", \"TDBAL\", \"TDBAH\", \"TDLEN\", \"TDH\", \"TDT\",\n\t\t\"TIDV\", \"TXDCTL\", \"TADV\", \"TARC0\",\n\t\t\"TDBAL1\", \"TDBAH1\", \"TDLEN1\", \"TDH1\", \"TDT1\",\n\t\t\"TXDCTL1\", \"TARC1\",\n\t\t\"CTRL_EXT\", \"ERT\", \"RDBAL\", \"RDBAH\",\n\t\t\"TDFH\", \"TDFT\", \"TDFHS\", \"TDFTS\", \"TDFPC\",\n\t\t\"RDFH\", \"RDFT\", \"RDFHS\", \"RDFTS\", \"RDFPC\"\n\t};\n\n\tregs_buff[0]  = er32(CTRL);\n\tregs_buff[1]  = er32(STATUS);\n\n\tregs_buff[2]  = er32(RCTL);\n\tregs_buff[3]  = er32(RDLEN);\n\tregs_buff[4]  = er32(RDH);\n\tregs_buff[5]  = er32(RDT);\n\tregs_buff[6]  = er32(RDTR);\n\n\tregs_buff[7]  = er32(TCTL);\n\tregs_buff[8]  = er32(TDBAL);\n\tregs_buff[9]  = er32(TDBAH);\n\tregs_buff[10] = er32(TDLEN);\n\tregs_buff[11] = er32(TDH);\n\tregs_buff[12] = er32(TDT);\n\tregs_buff[13] = er32(TIDV);\n\tregs_buff[14] = er32(TXDCTL);\n\tregs_buff[15] = er32(TADV);\n\tregs_buff[16] = er32(TARC0);\n\n\tregs_buff[17] = er32(TDBAL1);\n\tregs_buff[18] = er32(TDBAH1);\n\tregs_buff[19] = er32(TDLEN1);\n\tregs_buff[20] = er32(TDH1);\n\tregs_buff[21] = er32(TDT1);\n\tregs_buff[22] = er32(TXDCTL1);\n\tregs_buff[23] = er32(TARC1);\n\tregs_buff[24] = er32(CTRL_EXT);\n\tregs_buff[25] = er32(ERT);\n\tregs_buff[26] = er32(RDBAL0);\n\tregs_buff[27] = er32(RDBAH0);\n\tregs_buff[28] = er32(TDFH);\n\tregs_buff[29] = er32(TDFT);\n\tregs_buff[30] = er32(TDFHS);\n\tregs_buff[31] = er32(TDFTS);\n\tregs_buff[32] = er32(TDFPC);\n\tregs_buff[33] = er32(RDFH);\n\tregs_buff[34] = er32(RDFT);\n\tregs_buff[35] = er32(RDFHS);\n\tregs_buff[36] = er32(RDFTS);\n\tregs_buff[37] = er32(RDFPC);\n\n\tpr_info(\"Register dump\\n\");\n\tfor (i = 0; i < NUM_REGS; i++)\n\t\tpr_info(\"%-15s  %08x\\n\", reg_name[i], regs_buff[i]);\n}\n\n \nstatic void e1000_dump(struct e1000_adapter *adapter)\n{\n\t \n\tstruct e1000_tx_ring *tx_ring = adapter->tx_ring;\n\tstruct e1000_rx_ring *rx_ring = adapter->rx_ring;\n\tint i;\n\n\tif (!netif_msg_hw(adapter))\n\t\treturn;\n\n\t \n\te1000_regdump(adapter);\n\n\t \n\tpr_info(\"TX Desc ring0 dump\\n\");\n\n\t \n\tpr_info(\"Tc[desc]     [Ce CoCsIpceCoS] [MssHlRSCm0Plen] [bi->dma       ] leng  ntw timestmp         bi->skb\\n\");\n\tpr_info(\"Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi->dma       ] leng  ntw timestmp         bi->skb\\n\");\n\n\tif (!netif_msg_tx_done(adapter))\n\t\tgoto rx_ring_summary;\n\n\tfor (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {\n\t\tstruct e1000_tx_desc *tx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\tstruct e1000_tx_buffer *buffer_info = &tx_ring->buffer_info[i];\n\t\tstruct my_u { __le64 a; __le64 b; };\n\t\tstruct my_u *u = (struct my_u *)tx_desc;\n\t\tconst char *type;\n\n\t\tif (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)\n\t\t\ttype = \"NTC/U\";\n\t\telse if (i == tx_ring->next_to_use)\n\t\t\ttype = \"NTU\";\n\t\telse if (i == tx_ring->next_to_clean)\n\t\t\ttype = \"NTC\";\n\t\telse\n\t\t\ttype = \"\";\n\n\t\tpr_info(\"T%c[0x%03X]    %016llX %016llX %016llX %04X  %3X %016llX %p %s\\n\",\n\t\t\t((le64_to_cpu(u->b) & (1<<20)) ? 'd' : 'c'), i,\n\t\t\tle64_to_cpu(u->a), le64_to_cpu(u->b),\n\t\t\t(u64)buffer_info->dma, buffer_info->length,\n\t\t\tbuffer_info->next_to_watch,\n\t\t\t(u64)buffer_info->time_stamp, buffer_info->skb, type);\n\t}\n\nrx_ring_summary:\n\t \n\tpr_info(\"\\nRX Desc ring dump\\n\");\n\n\t \n\tpr_info(\"R[desc]      [address 63:0  ] [vl er S cks ln] [bi->dma       ] [bi->skb]\\n\");\n\n\tif (!netif_msg_rx_status(adapter))\n\t\tgoto exit;\n\n\tfor (i = 0; rx_ring->desc && (i < rx_ring->count); i++) {\n\t\tstruct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rx_ring, i);\n\t\tstruct e1000_rx_buffer *buffer_info = &rx_ring->buffer_info[i];\n\t\tstruct my_u { __le64 a; __le64 b; };\n\t\tstruct my_u *u = (struct my_u *)rx_desc;\n\t\tconst char *type;\n\n\t\tif (i == rx_ring->next_to_use)\n\t\t\ttype = \"NTU\";\n\t\telse if (i == rx_ring->next_to_clean)\n\t\t\ttype = \"NTC\";\n\t\telse\n\t\t\ttype = \"\";\n\n\t\tpr_info(\"R[0x%03X]     %016llX %016llX %016llX %p %s\\n\",\n\t\t\ti, le64_to_cpu(u->a), le64_to_cpu(u->b),\n\t\t\t(u64)buffer_info->dma, buffer_info->rxbuf.data, type);\n\t}  \n\n\t \n\t \n\tpr_info(\"Rx descriptor cache in 64bit format\\n\");\n\tfor (i = 0x6000; i <= 0x63FF ; i += 0x10) {\n\t\tpr_info(\"R%04X: %08X|%08X %08X|%08X\\n\",\n\t\t\ti,\n\t\t\treadl(adapter->hw.hw_addr + i+4),\n\t\t\treadl(adapter->hw.hw_addr + i),\n\t\t\treadl(adapter->hw.hw_addr + i+12),\n\t\t\treadl(adapter->hw.hw_addr + i+8));\n\t}\n\t \n\tpr_info(\"Tx descriptor cache in 64bit format\\n\");\n\tfor (i = 0x7000; i <= 0x73FF ; i += 0x10) {\n\t\tpr_info(\"T%04X: %08X|%08X %08X|%08X\\n\",\n\t\t\ti,\n\t\t\treadl(adapter->hw.hw_addr + i+4),\n\t\t\treadl(adapter->hw.hw_addr + i),\n\t\t\treadl(adapter->hw.hw_addr + i+12),\n\t\t\treadl(adapter->hw.hw_addr + i+8));\n\t}\nexit:\n\treturn;\n}\n\n \nstatic void e1000_tx_timeout(struct net_device *netdev, unsigned int __always_unused txqueue)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tadapter->tx_timeout_count++;\n\tschedule_work(&adapter->reset_task);\n}\n\nstatic void e1000_reset_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter =\n\t\tcontainer_of(work, struct e1000_adapter, reset_task);\n\n\te_err(drv, \"Reset adapter\\n\");\n\te1000_reinit_locked(adapter);\n}\n\n \nstatic int e1000_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;\n\n\t \n\tswitch (hw->mac_type) {\n\tcase e1000_undefined ... e1000_82542_rev2_1:\n\t\tif (max_frame > (ETH_FRAME_LEN + ETH_FCS_LEN)) {\n\t\t\te_err(probe, \"Jumbo Frames not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\t \n\thw->max_frame_size = max_frame;\n\tif (netif_running(netdev)) {\n\t\t \n\t\tadapter->alloc_rx_buf = e1000_alloc_dummy_rx_buffers;\n\t\te1000_down(adapter);\n\t}\n\n\t \n\n\tif (max_frame <= E1000_RXBUFFER_2048)\n\t\tadapter->rx_buffer_len = E1000_RXBUFFER_2048;\n\telse\n#if (PAGE_SIZE >= E1000_RXBUFFER_16384)\n\t\tadapter->rx_buffer_len = E1000_RXBUFFER_16384;\n#elif (PAGE_SIZE >= E1000_RXBUFFER_4096)\n\t\tadapter->rx_buffer_len = PAGE_SIZE;\n#endif\n\n\t \n\tif (!hw->tbi_compatibility_on &&\n\t    ((max_frame == (ETH_FRAME_LEN + ETH_FCS_LEN)) ||\n\t     (max_frame == MAXIMUM_ETHERNET_VLAN_SIZE)))\n\t\tadapter->rx_buffer_len = MAXIMUM_ETHERNET_VLAN_SIZE;\n\n\tnetdev_dbg(netdev, \"changing MTU from %d to %d\\n\",\n\t\t   netdev->mtu, new_mtu);\n\tnetdev->mtu = new_mtu;\n\n\tif (netif_running(netdev))\n\t\te1000_up(adapter);\n\telse\n\t\te1000_reset(adapter);\n\n\tclear_bit(__E1000_RESETTING, &adapter->flags);\n\n\treturn 0;\n}\n\n \nvoid e1000_update_stats(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunsigned long flags;\n\tu16 phy_tmp;\n\n#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF\n\n\t \n\tif (adapter->link_speed == 0)\n\t\treturn;\n\tif (pci_channel_offline(pdev))\n\t\treturn;\n\n\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\n\t \n\n\tadapter->stats.crcerrs += er32(CRCERRS);\n\tadapter->stats.gprc += er32(GPRC);\n\tadapter->stats.gorcl += er32(GORCL);\n\tadapter->stats.gorch += er32(GORCH);\n\tadapter->stats.bprc += er32(BPRC);\n\tadapter->stats.mprc += er32(MPRC);\n\tadapter->stats.roc += er32(ROC);\n\n\tadapter->stats.prc64 += er32(PRC64);\n\tadapter->stats.prc127 += er32(PRC127);\n\tadapter->stats.prc255 += er32(PRC255);\n\tadapter->stats.prc511 += er32(PRC511);\n\tadapter->stats.prc1023 += er32(PRC1023);\n\tadapter->stats.prc1522 += er32(PRC1522);\n\n\tadapter->stats.symerrs += er32(SYMERRS);\n\tadapter->stats.mpc += er32(MPC);\n\tadapter->stats.scc += er32(SCC);\n\tadapter->stats.ecol += er32(ECOL);\n\tadapter->stats.mcc += er32(MCC);\n\tadapter->stats.latecol += er32(LATECOL);\n\tadapter->stats.dc += er32(DC);\n\tadapter->stats.sec += er32(SEC);\n\tadapter->stats.rlec += er32(RLEC);\n\tadapter->stats.xonrxc += er32(XONRXC);\n\tadapter->stats.xontxc += er32(XONTXC);\n\tadapter->stats.xoffrxc += er32(XOFFRXC);\n\tadapter->stats.xofftxc += er32(XOFFTXC);\n\tadapter->stats.fcruc += er32(FCRUC);\n\tadapter->stats.gptc += er32(GPTC);\n\tadapter->stats.gotcl += er32(GOTCL);\n\tadapter->stats.gotch += er32(GOTCH);\n\tadapter->stats.rnbc += er32(RNBC);\n\tadapter->stats.ruc += er32(RUC);\n\tadapter->stats.rfc += er32(RFC);\n\tadapter->stats.rjc += er32(RJC);\n\tadapter->stats.torl += er32(TORL);\n\tadapter->stats.torh += er32(TORH);\n\tadapter->stats.totl += er32(TOTL);\n\tadapter->stats.toth += er32(TOTH);\n\tadapter->stats.tpr += er32(TPR);\n\n\tadapter->stats.ptc64 += er32(PTC64);\n\tadapter->stats.ptc127 += er32(PTC127);\n\tadapter->stats.ptc255 += er32(PTC255);\n\tadapter->stats.ptc511 += er32(PTC511);\n\tadapter->stats.ptc1023 += er32(PTC1023);\n\tadapter->stats.ptc1522 += er32(PTC1522);\n\n\tadapter->stats.mptc += er32(MPTC);\n\tadapter->stats.bptc += er32(BPTC);\n\n\t \n\n\thw->tx_packet_delta = er32(TPT);\n\tadapter->stats.tpt += hw->tx_packet_delta;\n\thw->collision_delta = er32(COLC);\n\tadapter->stats.colc += hw->collision_delta;\n\n\tif (hw->mac_type >= e1000_82543) {\n\t\tadapter->stats.algnerrc += er32(ALGNERRC);\n\t\tadapter->stats.rxerrc += er32(RXERRC);\n\t\tadapter->stats.tncrs += er32(TNCRS);\n\t\tadapter->stats.cexterr += er32(CEXTERR);\n\t\tadapter->stats.tsctc += er32(TSCTC);\n\t\tadapter->stats.tsctfc += er32(TSCTFC);\n\t}\n\n\t \n\tnetdev->stats.multicast = adapter->stats.mprc;\n\tnetdev->stats.collisions = adapter->stats.colc;\n\n\t \n\n\t \n\tnetdev->stats.rx_errors = adapter->stats.rxerrc +\n\t\tadapter->stats.crcerrs + adapter->stats.algnerrc +\n\t\tadapter->stats.ruc + adapter->stats.roc +\n\t\tadapter->stats.cexterr;\n\tadapter->stats.rlerrc = adapter->stats.ruc + adapter->stats.roc;\n\tnetdev->stats.rx_length_errors = adapter->stats.rlerrc;\n\tnetdev->stats.rx_crc_errors = adapter->stats.crcerrs;\n\tnetdev->stats.rx_frame_errors = adapter->stats.algnerrc;\n\tnetdev->stats.rx_missed_errors = adapter->stats.mpc;\n\n\t \n\tadapter->stats.txerrc = adapter->stats.ecol + adapter->stats.latecol;\n\tnetdev->stats.tx_errors = adapter->stats.txerrc;\n\tnetdev->stats.tx_aborted_errors = adapter->stats.ecol;\n\tnetdev->stats.tx_window_errors = adapter->stats.latecol;\n\tnetdev->stats.tx_carrier_errors = adapter->stats.tncrs;\n\tif (hw->bad_tx_carr_stats_fd &&\n\t    adapter->link_duplex == FULL_DUPLEX) {\n\t\tnetdev->stats.tx_carrier_errors = 0;\n\t\tadapter->stats.tncrs = 0;\n\t}\n\n\t \n\n\t \n\tif (hw->media_type == e1000_media_type_copper) {\n\t\tif ((adapter->link_speed == SPEED_1000) &&\n\t\t   (!e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_tmp))) {\n\t\t\tphy_tmp &= PHY_IDLE_ERROR_COUNT_MASK;\n\t\t\tadapter->phy_stats.idle_errors += phy_tmp;\n\t\t}\n\n\t\tif ((hw->mac_type <= e1000_82546) &&\n\t\t   (hw->phy_type == e1000_phy_m88) &&\n\t\t   !e1000_read_phy_reg(hw, M88E1000_RX_ERR_CNTR, &phy_tmp))\n\t\t\tadapter->phy_stats.receive_errors += phy_tmp;\n\t}\n\n\t \n\tif (hw->has_smbus) {\n\t\tadapter->stats.mgptc += er32(MGTPTC);\n\t\tadapter->stats.mgprc += er32(MGTPRC);\n\t\tadapter->stats.mgpdc += er32(MGTPDC);\n\t}\n\n\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n}\n\n \nstatic irqreturn_t e1000_intr(int irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = er32(ICR);\n\n\tif (unlikely((!icr)))\n\t\treturn IRQ_NONE;   \n\n\t \n\tif (unlikely(test_bit(__E1000_DOWN, &adapter->flags)))\n\t\treturn IRQ_HANDLED;\n\n\tif (unlikely(icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC))) {\n\t\thw->get_link_status = 1;\n\t\t \n\t\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\t\tschedule_delayed_work(&adapter->watchdog_task, 1);\n\t}\n\n\t \n\tew32(IMC, ~0);\n\tE1000_WRITE_FLUSH();\n\n\tif (likely(napi_schedule_prep(&adapter->napi))) {\n\t\tadapter->total_tx_bytes = 0;\n\t\tadapter->total_tx_packets = 0;\n\t\tadapter->total_rx_bytes = 0;\n\t\tadapter->total_rx_packets = 0;\n\t\t__napi_schedule(&adapter->napi);\n\t} else {\n\t\t \n\t\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\t\te1000_irq_enable(adapter);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int e1000_clean(struct napi_struct *napi, int budget)\n{\n\tstruct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,\n\t\t\t\t\t\t     napi);\n\tint tx_clean_complete = 0, work_done = 0;\n\n\ttx_clean_complete = e1000_clean_tx_irq(adapter, &adapter->tx_ring[0]);\n\n\tadapter->clean_rx(adapter, &adapter->rx_ring[0], &work_done, budget);\n\n\tif (!tx_clean_complete || work_done == budget)\n\t\treturn budget;\n\n\t \n\tif (likely(napi_complete_done(napi, work_done))) {\n\t\tif (likely(adapter->itr_setting & 3))\n\t\t\te1000_set_itr(adapter);\n\t\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\t\te1000_irq_enable(adapter);\n\t}\n\n\treturn work_done;\n}\n\n \nstatic bool e1000_clean_tx_irq(struct e1000_adapter *adapter,\n\t\t\t       struct e1000_tx_ring *tx_ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_tx_desc *tx_desc, *eop_desc;\n\tstruct e1000_tx_buffer *buffer_info;\n\tunsigned int i, eop;\n\tunsigned int count = 0;\n\tunsigned int total_tx_bytes = 0, total_tx_packets = 0;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\n\ti = tx_ring->next_to_clean;\n\teop = tx_ring->buffer_info[i].next_to_watch;\n\teop_desc = E1000_TX_DESC(*tx_ring, eop);\n\n\twhile ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&\n\t       (count < tx_ring->count)) {\n\t\tbool cleaned = false;\n\t\tdma_rmb();\t \n\t\tfor ( ; !cleaned; count++) {\n\t\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\t\tcleaned = (i == eop);\n\n\t\t\tif (cleaned) {\n\t\t\t\ttotal_tx_packets += buffer_info->segs;\n\t\t\t\ttotal_tx_bytes += buffer_info->bytecount;\n\t\t\t\tif (buffer_info->skb) {\n\t\t\t\t\tbytes_compl += buffer_info->skb->len;\n\t\t\t\t\tpkts_compl++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\te1000_unmap_and_free_tx_resource(adapter, buffer_info,\n\t\t\t\t\t\t\t 64);\n\t\t\ttx_desc->upper.data = 0;\n\n\t\t\tif (unlikely(++i == tx_ring->count))\n\t\t\t\ti = 0;\n\t\t}\n\n\t\teop = tx_ring->buffer_info[i].next_to_watch;\n\t\teop_desc = E1000_TX_DESC(*tx_ring, eop);\n\t}\n\n\t \n\tsmp_store_release(&tx_ring->next_to_clean, i);\n\n\tnetdev_completed_queue(netdev, pkts_compl, bytes_compl);\n\n#define TX_WAKE_THRESHOLD 32\n\tif (unlikely(count && netif_carrier_ok(netdev) &&\n\t\t     E1000_DESC_UNUSED(tx_ring) >= TX_WAKE_THRESHOLD)) {\n\t\t \n\t\tsmp_mb();\n\n\t\tif (netif_queue_stopped(netdev) &&\n\t\t    !(test_bit(__E1000_DOWN, &adapter->flags))) {\n\t\t\tnetif_wake_queue(netdev);\n\t\t\t++adapter->restart_queue;\n\t\t}\n\t}\n\n\tif (adapter->detect_tx_hung) {\n\t\t \n\t\tadapter->detect_tx_hung = false;\n\t\tif (tx_ring->buffer_info[eop].time_stamp &&\n\t\t    time_after(jiffies, tx_ring->buffer_info[eop].time_stamp +\n\t\t\t       (adapter->tx_timeout_factor * HZ)) &&\n\t\t    !(er32(STATUS) & E1000_STATUS_TXOFF)) {\n\n\t\t\t \n\t\t\te_err(drv, \"Detected Tx Unit Hang\\n\"\n\t\t\t      \"  Tx Queue             <%lu>\\n\"\n\t\t\t      \"  TDH                  <%x>\\n\"\n\t\t\t      \"  TDT                  <%x>\\n\"\n\t\t\t      \"  next_to_use          <%x>\\n\"\n\t\t\t      \"  next_to_clean        <%x>\\n\"\n\t\t\t      \"buffer_info[next_to_clean]\\n\"\n\t\t\t      \"  time_stamp           <%lx>\\n\"\n\t\t\t      \"  next_to_watch        <%x>\\n\"\n\t\t\t      \"  jiffies              <%lx>\\n\"\n\t\t\t      \"  next_to_watch.status <%x>\\n\",\n\t\t\t\t(unsigned long)(tx_ring - adapter->tx_ring),\n\t\t\t\treadl(hw->hw_addr + tx_ring->tdh),\n\t\t\t\treadl(hw->hw_addr + tx_ring->tdt),\n\t\t\t\ttx_ring->next_to_use,\n\t\t\t\ttx_ring->next_to_clean,\n\t\t\t\ttx_ring->buffer_info[eop].time_stamp,\n\t\t\t\teop,\n\t\t\t\tjiffies,\n\t\t\t\teop_desc->upper.fields.status);\n\t\t\te1000_dump(adapter);\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\tadapter->total_tx_bytes += total_tx_bytes;\n\tadapter->total_tx_packets += total_tx_packets;\n\tnetdev->stats.tx_bytes += total_tx_bytes;\n\tnetdev->stats.tx_packets += total_tx_packets;\n\treturn count < tx_ring->count;\n}\n\n \nstatic void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err,\n\t\t\t      u32 csum, struct sk_buff *skb)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 status = (u16)status_err;\n\tu8 errors = (u8)(status_err >> 24);\n\n\tskb_checksum_none_assert(skb);\n\n\t \n\tif (unlikely(hw->mac_type < e1000_82543))\n\t\treturn;\n\t \n\tif (unlikely(status & E1000_RXD_STAT_IXSM))\n\t\treturn;\n\t \n\tif (unlikely(errors & E1000_RXD_ERR_TCPE)) {\n\t\t \n\t\tadapter->hw_csum_err++;\n\t\treturn;\n\t}\n\t \n\tif (!(status & E1000_RXD_STAT_TCPCS))\n\t\treturn;\n\n\t \n\tif (likely(status & E1000_RXD_STAT_TCPCS)) {\n\t\t \n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\tadapter->hw_csum_good++;\n}\n\n \nstatic void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,\n\t\t\t       u16 length)\n{\n\tbi->rxbuf.page = NULL;\n\tskb->len += length;\n\tskb->data_len += length;\n\tskb->truesize += PAGE_SIZE;\n}\n\n \nstatic void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,\n\t\t\t      __le16 vlan, struct sk_buff *skb)\n{\n\tskb->protocol = eth_type_trans(skb, adapter->netdev);\n\n\tif (status & E1000_RXD_STAT_VP) {\n\t\tu16 vid = le16_to_cpu(vlan) & E1000_RXD_SPC_VLAN_MASK;\n\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t}\n\tnapi_gro_receive(&adapter->napi, skb);\n}\n\n \nstatic void e1000_tbi_adjust_stats(struct e1000_hw *hw,\n\t\t\t\t   struct e1000_hw_stats *stats,\n\t\t\t\t   u32 frame_len, const u8 *mac_addr)\n{\n\tu64 carry_bit;\n\n\t \n\tframe_len--;\n\t \n\t \n\tstats->crcerrs--;\n\t \n\tstats->gprc++;\n\n\t \n\tcarry_bit = 0x80000000 & stats->gorcl;\n\tstats->gorcl += frame_len;\n\t \n\tif (carry_bit && ((stats->gorcl & 0x80000000) == 0))\n\t\tstats->gorch++;\n\t \n\tif (is_broadcast_ether_addr(mac_addr))\n\t\tstats->bprc++;\n\telse if (is_multicast_ether_addr(mac_addr))\n\t\tstats->mprc++;\n\n\tif (frame_len == hw->max_frame_size) {\n\t\t \n\t\tif (stats->roc > 0)\n\t\t\tstats->roc--;\n\t}\n\n\t \n\tif (frame_len == 64) {\n\t\tstats->prc64++;\n\t\tstats->prc127--;\n\t} else if (frame_len == 127) {\n\t\tstats->prc127++;\n\t\tstats->prc255--;\n\t} else if (frame_len == 255) {\n\t\tstats->prc255++;\n\t\tstats->prc511--;\n\t} else if (frame_len == 511) {\n\t\tstats->prc511++;\n\t\tstats->prc1023--;\n\t} else if (frame_len == 1023) {\n\t\tstats->prc1023++;\n\t\tstats->prc1522--;\n\t} else if (frame_len == 1522) {\n\t\tstats->prc1522++;\n\t}\n}\n\nstatic bool e1000_tbi_should_accept(struct e1000_adapter *adapter,\n\t\t\t\t    u8 status, u8 errors,\n\t\t\t\t    u32 length, const u8 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu8 last_byte = *(data + length - 1);\n\n\tif (TBI_ACCEPT(hw, status, errors, length, last_byte)) {\n\t\tunsigned long irq_flags;\n\n\t\tspin_lock_irqsave(&adapter->stats_lock, irq_flags);\n\t\te1000_tbi_adjust_stats(hw, &adapter->stats, length, data);\n\t\tspin_unlock_irqrestore(&adapter->stats_lock, irq_flags);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct sk_buff *e1000_alloc_rx_skb(struct e1000_adapter *adapter,\n\t\t\t\t\t  unsigned int bufsz)\n{\n\tstruct sk_buff *skb = napi_alloc_skb(&adapter->napi, bufsz);\n\n\tif (unlikely(!skb))\n\t\tadapter->alloc_rx_buff_failed++;\n\treturn skb;\n}\n\n \nstatic bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,\n\t\t\t\t     struct e1000_rx_ring *rx_ring,\n\t\t\t\t     int *work_done, int work_to_do)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_rx_desc *rx_desc, *next_rxd;\n\tstruct e1000_rx_buffer *buffer_info, *next_buffer;\n\tu32 length;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC(*rx_ring, i);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (rx_desc->status & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\t\tu8 status;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tdma_rmb();  \n\n\t\tstatus = rx_desc->status;\n\n\t\tif (++i == rx_ring->count)\n\t\t\ti = 0;\n\n\t\tnext_rxd = E1000_RX_DESC(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tdma_unmap_page(&pdev->dev, buffer_info->dma,\n\t\t\t       adapter->rx_buffer_len, DMA_FROM_DEVICE);\n\t\tbuffer_info->dma = 0;\n\n\t\tlength = le16_to_cpu(rx_desc->length);\n\n\t\t \n\t\tif (unlikely((status & E1000_RXD_STAT_EOP) &&\n\t\t    (rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK))) {\n\t\t\tu8 *mapped = page_address(buffer_info->rxbuf.page);\n\n\t\t\tif (e1000_tbi_should_accept(adapter, status,\n\t\t\t\t\t\t    rx_desc->errors,\n\t\t\t\t\t\t    length, mapped)) {\n\t\t\t\tlength--;\n\t\t\t} else if (netdev->features & NETIF_F_RXALL) {\n\t\t\t\tgoto process_skb;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdev_kfree_skb(rx_ring->rx_skb_top);\n\t\t\t\trx_ring->rx_skb_top = NULL;\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t}\n\n#define rxtop rx_ring->rx_skb_top\nprocess_skb:\n\t\tif (!(status & E1000_RXD_STAT_EOP)) {\n\t\t\t \n\t\t\tif (!rxtop) {\n\t\t\t\t \n\t\t\t\trxtop = napi_get_frags(&adapter->napi);\n\t\t\t\tif (!rxtop)\n\t\t\t\t\tbreak;\n\n\t\t\t\tskb_fill_page_desc(rxtop, 0,\n\t\t\t\t\t\t   buffer_info->rxbuf.page,\n\t\t\t\t\t\t   0, length);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tskb_fill_page_desc(rxtop,\n\t\t\t\t    skb_shinfo(rxtop)->nr_frags,\n\t\t\t\t    buffer_info->rxbuf.page, 0, length);\n\t\t\t}\n\t\t\te1000_consume_page(buffer_info, rxtop, length);\n\t\t\tgoto next_desc;\n\t\t} else {\n\t\t\tif (rxtop) {\n\t\t\t\t \n\t\t\t\tskb_fill_page_desc(rxtop,\n\t\t\t\t    skb_shinfo(rxtop)->nr_frags,\n\t\t\t\t    buffer_info->rxbuf.page, 0, length);\n\t\t\t\tskb = rxtop;\n\t\t\t\trxtop = NULL;\n\t\t\t\te1000_consume_page(buffer_info, skb, length);\n\t\t\t} else {\n\t\t\t\tstruct page *p;\n\t\t\t\t \n\t\t\t\tp = buffer_info->rxbuf.page;\n\t\t\t\tif (length <= copybreak) {\n\t\t\t\t\tif (likely(!(netdev->features & NETIF_F_RXFCS)))\n\t\t\t\t\t\tlength -= 4;\n\t\t\t\t\tskb = e1000_alloc_rx_skb(adapter,\n\t\t\t\t\t\t\t\t length);\n\t\t\t\t\tif (!skb)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tmemcpy(skb_tail_pointer(skb),\n\t\t\t\t\t       page_address(p), length);\n\n\t\t\t\t\t \n\t\t\t\t\tskb_put(skb, length);\n\t\t\t\t\te1000_rx_checksum(adapter,\n\t\t\t\t\t\t\t  status | rx_desc->errors << 24,\n\t\t\t\t\t\t\t  le16_to_cpu(rx_desc->csum), skb);\n\n\t\t\t\t\ttotal_rx_bytes += skb->len;\n\t\t\t\t\ttotal_rx_packets++;\n\n\t\t\t\t\te1000_receive_skb(adapter, status,\n\t\t\t\t\t\t\t  rx_desc->special, skb);\n\t\t\t\t\tgoto next_desc;\n\t\t\t\t} else {\n\t\t\t\t\tskb = napi_get_frags(&adapter->napi);\n\t\t\t\t\tif (!skb) {\n\t\t\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tskb_fill_page_desc(skb, 0, p, 0,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t\te1000_consume_page(buffer_info, skb,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\te1000_rx_checksum(adapter,\n\t\t\t\t  (u32)(status) |\n\t\t\t\t  ((u32)(rx_desc->errors) << 24),\n\t\t\t\t  le16_to_cpu(rx_desc->csum), skb);\n\n\t\ttotal_rx_bytes += (skb->len - 4);  \n\t\tif (likely(!(netdev->features & NETIF_F_RXFCS)))\n\t\t\tpskb_trim(skb, skb->len - 4);\n\t\ttotal_rx_packets++;\n\n\t\tif (status & E1000_RXD_STAT_VP) {\n\t\t\t__le16 vlan = rx_desc->special;\n\t\t\tu16 vid = le16_to_cpu(vlan) & E1000_RXD_SPC_VLAN_MASK;\n\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t\t}\n\n\t\tnapi_gro_frags(&adapter->napi);\n\nnext_desc:\n\t\trx_desc->status = 0;\n\n\t\t \n\t\tif (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {\n\t\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t \n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = E1000_DESC_UNUSED(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\n\tadapter->total_rx_packets += total_rx_packets;\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tnetdev->stats.rx_bytes += total_rx_bytes;\n\tnetdev->stats.rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\n \nstatic struct sk_buff *e1000_copybreak(struct e1000_adapter *adapter,\n\t\t\t\t       struct e1000_rx_buffer *buffer_info,\n\t\t\t\t       u32 length, const void *data)\n{\n\tstruct sk_buff *skb;\n\n\tif (length > copybreak)\n\t\treturn NULL;\n\n\tskb = e1000_alloc_rx_skb(adapter, length);\n\tif (!skb)\n\t\treturn NULL;\n\n\tdma_sync_single_for_cpu(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\tlength, DMA_FROM_DEVICE);\n\n\tskb_put_data(skb, data, length);\n\n\treturn skb;\n}\n\n \nstatic bool e1000_clean_rx_irq(struct e1000_adapter *adapter,\n\t\t\t       struct e1000_rx_ring *rx_ring,\n\t\t\t       int *work_done, int work_to_do)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_rx_desc *rx_desc, *next_rxd;\n\tstruct e1000_rx_buffer *buffer_info, *next_buffer;\n\tu32 length;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC(*rx_ring, i);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (rx_desc->status & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\t\tu8 *data;\n\t\tu8 status;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tdma_rmb();  \n\n\t\tstatus = rx_desc->status;\n\t\tlength = le16_to_cpu(rx_desc->length);\n\n\t\tdata = buffer_info->rxbuf.data;\n\t\tprefetch(data);\n\t\tskb = e1000_copybreak(adapter, buffer_info, length, data);\n\t\tif (!skb) {\n\t\t\tunsigned int frag_len = e1000_frag_len(adapter);\n\n\t\t\tskb = napi_build_skb(data - E1000_HEADROOM, frag_len);\n\t\t\tif (!skb) {\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tskb_reserve(skb, E1000_HEADROOM);\n\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t adapter->rx_buffer_len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tbuffer_info->dma = 0;\n\t\t\tbuffer_info->rxbuf.data = NULL;\n\t\t}\n\n\t\tif (++i == rx_ring->count)\n\t\t\ti = 0;\n\n\t\tnext_rxd = E1000_RX_DESC(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\n\t\t \n\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP)))\n\t\t\tadapter->discarding = true;\n\n\t\tif (adapter->discarding) {\n\t\t\t \n\t\t\tnetdev_dbg(netdev, \"Receive packet consumed multiple buffers\\n\");\n\t\t\tdev_kfree_skb(skb);\n\t\t\tif (status & E1000_RXD_STAT_EOP)\n\t\t\t\tadapter->discarding = false;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tif (unlikely(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK)) {\n\t\t\tif (e1000_tbi_should_accept(adapter, status,\n\t\t\t\t\t\t    rx_desc->errors,\n\t\t\t\t\t\t    length, data)) {\n\t\t\t\tlength--;\n\t\t\t} else if (netdev->features & NETIF_F_RXALL) {\n\t\t\t\tgoto process_skb;\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t}\n\nprocess_skb:\n\t\ttotal_rx_bytes += (length - 4);  \n\t\ttotal_rx_packets++;\n\n\t\tif (likely(!(netdev->features & NETIF_F_RXFCS)))\n\t\t\t \n\t\t\tlength -= 4;\n\n\t\tif (buffer_info->rxbuf.data == NULL)\n\t\t\tskb_put(skb, length);\n\t\telse  \n\t\t\tskb_trim(skb, length);\n\n\t\t \n\t\te1000_rx_checksum(adapter,\n\t\t\t\t  (u32)(status) |\n\t\t\t\t  ((u32)(rx_desc->errors) << 24),\n\t\t\t\t  le16_to_cpu(rx_desc->csum), skb);\n\n\t\te1000_receive_skb(adapter, status, rx_desc->special, skb);\n\nnext_desc:\n\t\trx_desc->status = 0;\n\n\t\t \n\t\tif (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {\n\t\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t \n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = E1000_DESC_UNUSED(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\n\tadapter->total_rx_packets += total_rx_packets;\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tnetdev->stats.rx_bytes += total_rx_bytes;\n\tnetdev->stats.rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\n \nstatic void\ne1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter,\n\t\t\t     struct e1000_rx_ring *rx_ring, int cleaned_count)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_rx_desc *rx_desc;\n\tstruct e1000_rx_buffer *buffer_info;\n\tunsigned int i;\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\t \n\t\tif (!buffer_info->rxbuf.page) {\n\t\t\tbuffer_info->rxbuf.page = alloc_page(GFP_ATOMIC);\n\t\t\tif (unlikely(!buffer_info->rxbuf.page)) {\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!buffer_info->dma) {\n\t\t\tbuffer_info->dma = dma_map_page(&pdev->dev,\n\t\t\t\t\t\t\tbuffer_info->rxbuf.page, 0,\n\t\t\t\t\t\t\tadapter->rx_buffer_len,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\t\tput_page(buffer_info->rxbuf.page);\n\t\t\t\tbuffer_info->rxbuf.page = NULL;\n\t\t\t\tbuffer_info->dma = 0;\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trx_desc = E1000_RX_DESC(*rx_ring, i);\n\t\trx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(++i == rx_ring->count))\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\n\tif (likely(rx_ring->next_to_use != i)) {\n\t\trx_ring->next_to_use = i;\n\t\tif (unlikely(i-- == 0))\n\t\t\ti = (rx_ring->count - 1);\n\n\t\t \n\t\tdma_wmb();\n\t\twritel(i, adapter->hw.hw_addr + rx_ring->rdt);\n\t}\n}\n\n \nstatic void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,\n\t\t\t\t   struct e1000_rx_ring *rx_ring,\n\t\t\t\t   int cleaned_count)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_rx_desc *rx_desc;\n\tstruct e1000_rx_buffer *buffer_info;\n\tunsigned int i;\n\tunsigned int bufsz = adapter->rx_buffer_len;\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\tvoid *data;\n\n\t\tif (buffer_info->rxbuf.data)\n\t\t\tgoto skip;\n\n\t\tdata = e1000_alloc_frag(adapter);\n\t\tif (!data) {\n\t\t\t \n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!e1000_check_64k_bound(adapter, data, bufsz)) {\n\t\t\tvoid *olddata = data;\n\t\t\te_err(rx_err, \"skb align check failed: %u bytes at \"\n\t\t\t      \"%p\\n\", bufsz, data);\n\t\t\t \n\t\t\tdata = e1000_alloc_frag(adapter);\n\t\t\t \n\t\t\tif (!data) {\n\t\t\t\tskb_free_frag(olddata);\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!e1000_check_64k_bound(adapter, data, bufsz)) {\n\t\t\t\t \n\t\t\t\tskb_free_frag(data);\n\t\t\t\tskb_free_frag(olddata);\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tskb_free_frag(olddata);\n\t\t}\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev,\n\t\t\t\t\t\t  data,\n\t\t\t\t\t\t  adapter->rx_buffer_len,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\tskb_free_frag(data);\n\t\t\tbuffer_info->dma = 0;\n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (!e1000_check_64k_bound(adapter,\n\t\t\t\t\t(void *)(unsigned long)buffer_info->dma,\n\t\t\t\t\tadapter->rx_buffer_len)) {\n\t\t\te_err(rx_err, \"dma align check failed: %u bytes at \"\n\t\t\t      \"%p\\n\", adapter->rx_buffer_len,\n\t\t\t      (void *)(unsigned long)buffer_info->dma);\n\n\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t adapter->rx_buffer_len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\tskb_free_frag(data);\n\t\t\tbuffer_info->rxbuf.data = NULL;\n\t\t\tbuffer_info->dma = 0;\n\n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer_info->rxbuf.data = data;\n skip:\n\t\trx_desc = E1000_RX_DESC(*rx_ring, i);\n\t\trx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(++i == rx_ring->count))\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\n\tif (likely(rx_ring->next_to_use != i)) {\n\t\trx_ring->next_to_use = i;\n\t\tif (unlikely(i-- == 0))\n\t\t\ti = (rx_ring->count - 1);\n\n\t\t \n\t\tdma_wmb();\n\t\twritel(i, hw->hw_addr + rx_ring->rdt);\n\t}\n}\n\n \nstatic void e1000_smartspeed(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 phy_status;\n\tu16 phy_ctrl;\n\n\tif ((hw->phy_type != e1000_phy_igp) || !hw->autoneg ||\n\t   !(hw->autoneg_advertised & ADVERTISE_1000_FULL))\n\t\treturn;\n\n\tif (adapter->smartspeed == 0) {\n\t\t \n\t\te1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_status);\n\t\tif (!(phy_status & SR_1000T_MS_CONFIG_FAULT))\n\t\t\treturn;\n\t\te1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_status);\n\t\tif (!(phy_status & SR_1000T_MS_CONFIG_FAULT))\n\t\t\treturn;\n\t\te1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);\n\t\tif (phy_ctrl & CR_1000T_MS_ENABLE) {\n\t\t\tphy_ctrl &= ~CR_1000T_MS_ENABLE;\n\t\t\te1000_write_phy_reg(hw, PHY_1000T_CTRL,\n\t\t\t\t\t    phy_ctrl);\n\t\t\tadapter->smartspeed++;\n\t\t\tif (!e1000_phy_setup_autoneg(hw) &&\n\t\t\t   !e1000_read_phy_reg(hw, PHY_CTRL,\n\t\t\t\t\t       &phy_ctrl)) {\n\t\t\t\tphy_ctrl |= (MII_CR_AUTO_NEG_EN |\n\t\t\t\t\t     MII_CR_RESTART_AUTO_NEG);\n\t\t\t\te1000_write_phy_reg(hw, PHY_CTRL,\n\t\t\t\t\t\t    phy_ctrl);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t} else if (adapter->smartspeed == E1000_SMARTSPEED_DOWNSHIFT) {\n\t\t \n\t\te1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);\n\t\tphy_ctrl |= CR_1000T_MS_ENABLE;\n\t\te1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_ctrl);\n\t\tif (!e1000_phy_setup_autoneg(hw) &&\n\t\t   !e1000_read_phy_reg(hw, PHY_CTRL, &phy_ctrl)) {\n\t\t\tphy_ctrl |= (MII_CR_AUTO_NEG_EN |\n\t\t\t\t     MII_CR_RESTART_AUTO_NEG);\n\t\t\te1000_write_phy_reg(hw, PHY_CTRL, phy_ctrl);\n\t\t}\n\t}\n\t \n\tif (adapter->smartspeed++ == E1000_SMARTSPEED_MAX)\n\t\tadapter->smartspeed = 0;\n}\n\n \nstatic int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn e1000_mii_ioctl(netdev, ifr, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,\n\t\t\t   int cmd)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\tint retval;\n\tu16 mii_reg;\n\tunsigned long flags;\n\n\tif (hw->media_type != e1000_media_type_copper)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = hw->phy_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\t\tif (e1000_read_phy_reg(hw, data->reg_num & 0x1F,\n\t\t\t\t   &data->val_out)) {\n\t\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\t\treturn -EIO;\n\t\t}\n\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (data->reg_num & ~(0x1F))\n\t\t\treturn -EFAULT;\n\t\tmii_reg = data->val_in;\n\t\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\t\tif (e1000_write_phy_reg(hw, data->reg_num,\n\t\t\t\t\tmii_reg)) {\n\t\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\t\treturn -EIO;\n\t\t}\n\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\tif (hw->media_type == e1000_media_type_copper) {\n\t\t\tswitch (data->reg_num) {\n\t\t\tcase PHY_CTRL:\n\t\t\t\tif (mii_reg & MII_CR_POWER_DOWN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (mii_reg & MII_CR_AUTO_NEG_EN) {\n\t\t\t\t\thw->autoneg = 1;\n\t\t\t\t\thw->autoneg_advertised = 0x2F;\n\t\t\t\t} else {\n\t\t\t\t\tu32 speed;\n\t\t\t\t\tif (mii_reg & 0x40)\n\t\t\t\t\t\tspeed = SPEED_1000;\n\t\t\t\t\telse if (mii_reg & 0x2000)\n\t\t\t\t\t\tspeed = SPEED_100;\n\t\t\t\t\telse\n\t\t\t\t\t\tspeed = SPEED_10;\n\t\t\t\t\tretval = e1000_set_spd_dplx(\n\t\t\t\t\t\tadapter, speed,\n\t\t\t\t\t\t((mii_reg & 0x100)\n\t\t\t\t\t\t ? DUPLEX_FULL :\n\t\t\t\t\t\t DUPLEX_HALF));\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\treturn retval;\n\t\t\t\t}\n\t\t\t\tif (netif_running(adapter->netdev))\n\t\t\t\t\te1000_reinit_locked(adapter);\n\t\t\t\telse\n\t\t\t\t\te1000_reset(adapter);\n\t\t\t\tbreak;\n\t\t\tcase M88E1000_PHY_SPEC_CTRL:\n\t\t\tcase M88E1000_EXT_PHY_SPEC_CTRL:\n\t\t\t\tif (e1000_phy_reset(hw))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (data->reg_num) {\n\t\t\tcase PHY_CTRL:\n\t\t\t\tif (mii_reg & MII_CR_POWER_DOWN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (netif_running(adapter->netdev))\n\t\t\t\t\te1000_reinit_locked(adapter);\n\t\t\t\telse\n\t\t\t\t\te1000_reset(adapter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn E1000_SUCCESS;\n}\n\nvoid e1000_pci_set_mwi(struct e1000_hw *hw)\n{\n\tstruct e1000_adapter *adapter = hw->back;\n\tint ret_val = pci_set_mwi(adapter->pdev);\n\n\tif (ret_val)\n\t\te_err(probe, \"Error in setting MWI\\n\");\n}\n\nvoid e1000_pci_clear_mwi(struct e1000_hw *hw)\n{\n\tstruct e1000_adapter *adapter = hw->back;\n\n\tpci_clear_mwi(adapter->pdev);\n}\n\nint e1000_pcix_get_mmrbc(struct e1000_hw *hw)\n{\n\tstruct e1000_adapter *adapter = hw->back;\n\treturn pcix_get_mmrbc(adapter->pdev);\n}\n\nvoid e1000_pcix_set_mmrbc(struct e1000_hw *hw, int mmrbc)\n{\n\tstruct e1000_adapter *adapter = hw->back;\n\tpcix_set_mmrbc(adapter->pdev, mmrbc);\n}\n\nvoid e1000_io_write(struct e1000_hw *hw, unsigned long port, u32 value)\n{\n\toutl(value, port);\n}\n\nstatic bool e1000_vlan_used(struct e1000_adapter *adapter)\n{\n\tu16 vid;\n\n\tfor_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void __e1000_vlan_mode(struct e1000_adapter *adapter,\n\t\t\t      netdev_features_t features)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl;\n\n\tctrl = er32(CTRL);\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\t \n\t\tctrl |= E1000_CTRL_VME;\n\t} else {\n\t\t \n\t\tctrl &= ~E1000_CTRL_VME;\n\t}\n\tew32(CTRL, ctrl);\n}\nstatic void e1000_vlan_filter_on_off(struct e1000_adapter *adapter,\n\t\t\t\t     bool filter_on)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\te1000_irq_disable(adapter);\n\n\t__e1000_vlan_mode(adapter, adapter->netdev->features);\n\tif (filter_on) {\n\t\t \n\t\trctl = er32(RCTL);\n\t\trctl &= ~E1000_RCTL_CFIEN;\n\t\tif (!(adapter->netdev->flags & IFF_PROMISC))\n\t\t\trctl |= E1000_RCTL_VFE;\n\t\tew32(RCTL, rctl);\n\t\te1000_update_mng_vlan(adapter);\n\t} else {\n\t\t \n\t\trctl = er32(RCTL);\n\t\trctl &= ~E1000_RCTL_VFE;\n\t\tew32(RCTL, rctl);\n\t}\n\n\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\te1000_irq_enable(adapter);\n}\n\nstatic void e1000_vlan_mode(struct net_device *netdev,\n\t\t\t    netdev_features_t features)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\te1000_irq_disable(adapter);\n\n\t__e1000_vlan_mode(adapter, features);\n\n\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\te1000_irq_enable(adapter);\n}\n\nstatic int e1000_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t __be16 proto, u16 vid)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vfta, index;\n\n\tif ((hw->mng_cookie.status &\n\t     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&\n\t    (vid == adapter->mng_vlan_id))\n\t\treturn 0;\n\n\tif (!e1000_vlan_used(adapter))\n\t\te1000_vlan_filter_on_off(adapter, true);\n\n\t \n\tindex = (vid >> 5) & 0x7F;\n\tvfta = E1000_READ_REG_ARRAY(hw, VFTA, index);\n\tvfta |= (1 << (vid & 0x1F));\n\te1000_write_vfta(hw, index, vfta);\n\n\tset_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\nstatic int e1000_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t  __be16 proto, u16 vid)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vfta, index;\n\n\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\te1000_irq_disable(adapter);\n\tif (!test_bit(__E1000_DOWN, &adapter->flags))\n\t\te1000_irq_enable(adapter);\n\n\t \n\tindex = (vid >> 5) & 0x7F;\n\tvfta = E1000_READ_REG_ARRAY(hw, VFTA, index);\n\tvfta &= ~(1 << (vid & 0x1F));\n\te1000_write_vfta(hw, index, vfta);\n\n\tclear_bit(vid, adapter->active_vlans);\n\n\tif (!e1000_vlan_used(adapter))\n\t\te1000_vlan_filter_on_off(adapter, false);\n\n\treturn 0;\n}\n\nstatic void e1000_restore_vlan(struct e1000_adapter *adapter)\n{\n\tu16 vid;\n\n\tif (!e1000_vlan_used(adapter))\n\t\treturn;\n\n\te1000_vlan_filter_on_off(adapter, true);\n\tfor_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)\n\t\te1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);\n}\n\nint e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\thw->autoneg = 0;\n\n\t \n\tif ((spd & 1) || (dplx & ~1))\n\t\tgoto err_inval;\n\n\t \n\tif ((hw->media_type == e1000_media_type_fiber) &&\n\t    spd != SPEED_1000 &&\n\t    dplx != DUPLEX_FULL)\n\t\tgoto err_inval;\n\n\tswitch (spd + dplx) {\n\tcase SPEED_10 + DUPLEX_HALF:\n\t\thw->forced_speed_duplex = e1000_10_half;\n\t\tbreak;\n\tcase SPEED_10 + DUPLEX_FULL:\n\t\thw->forced_speed_duplex = e1000_10_full;\n\t\tbreak;\n\tcase SPEED_100 + DUPLEX_HALF:\n\t\thw->forced_speed_duplex = e1000_100_half;\n\t\tbreak;\n\tcase SPEED_100 + DUPLEX_FULL:\n\t\thw->forced_speed_duplex = e1000_100_full;\n\t\tbreak;\n\tcase SPEED_1000 + DUPLEX_FULL:\n\t\thw->autoneg = 1;\n\t\thw->autoneg_advertised = ADVERTISE_1000_FULL;\n\t\tbreak;\n\tcase SPEED_1000 + DUPLEX_HALF:  \n\tdefault:\n\t\tgoto err_inval;\n\t}\n\n\t \n\thw->mdix = AUTO_ALL_MODES;\n\n\treturn 0;\n\nerr_inval:\n\te_err(probe, \"Unsupported Speed/Duplex configuration\\n\");\n\treturn -EINVAL;\n}\n\nstatic int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl, ctrl_ext, rctl, status;\n\tu32 wufc = adapter->wol;\n\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev)) {\n\t\tint count = E1000_CHECK_RESET_COUNT;\n\n\t\twhile (test_bit(__E1000_RESETTING, &adapter->flags) && count--)\n\t\t\tusleep_range(10000, 20000);\n\n\t\tWARN_ON(test_bit(__E1000_RESETTING, &adapter->flags));\n\t\te1000_down(adapter);\n\t}\n\n\tstatus = er32(STATUS);\n\tif (status & E1000_STATUS_LU)\n\t\twufc &= ~E1000_WUFC_LNKC;\n\n\tif (wufc) {\n\t\te1000_setup_rctl(adapter);\n\t\te1000_set_rx_mode(netdev);\n\n\t\trctl = er32(RCTL);\n\n\t\t \n\t\tif (wufc & E1000_WUFC_MC)\n\t\t\trctl |= E1000_RCTL_MPE;\n\n\t\t \n\t\tew32(RCTL, rctl | E1000_RCTL_EN);\n\n\t\tif (hw->mac_type >= e1000_82540) {\n\t\t\tctrl = er32(CTRL);\n\t\t\t \n\t\t\t#define E1000_CTRL_ADVD3WUC 0x00100000\n\t\t\t \n\t\t\t#define E1000_CTRL_EN_PHY_PWR_MGMT 0x00200000\n\t\t\tctrl |= E1000_CTRL_ADVD3WUC |\n\t\t\t\tE1000_CTRL_EN_PHY_PWR_MGMT;\n\t\t\tew32(CTRL, ctrl);\n\t\t}\n\n\t\tif (hw->media_type == e1000_media_type_fiber ||\n\t\t    hw->media_type == e1000_media_type_internal_serdes) {\n\t\t\t \n\t\t\tctrl_ext = er32(CTRL_EXT);\n\t\t\tctrl_ext |= E1000_CTRL_EXT_SDP7_DATA;\n\t\t\tew32(CTRL_EXT, ctrl_ext);\n\t\t}\n\n\t\tew32(WUC, E1000_WUC_PME_EN);\n\t\tew32(WUFC, wufc);\n\t} else {\n\t\tew32(WUC, 0);\n\t\tew32(WUFC, 0);\n\t}\n\n\te1000_release_manageability(adapter);\n\n\t*enable_wake = !!wufc;\n\n\t \n\tif (adapter->en_mng_pt)\n\t\t*enable_wake = true;\n\n\tif (netif_running(netdev))\n\t\te1000_free_irq(adapter);\n\n\tif (!test_and_set_bit(__E1000_DISABLED, &adapter->flags))\n\t\tpci_disable_device(pdev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused e1000_suspend(struct device *dev)\n{\n\tint retval;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tbool wake;\n\n\tretval = __e1000_shutdown(pdev, &wake);\n\tdevice_set_wakeup_enable(dev, wake);\n\n\treturn retval;\n}\n\nstatic int __maybe_unused e1000_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 err;\n\n\tif (adapter->need_ioport)\n\t\terr = pci_enable_device(pdev);\n\telse\n\t\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\tpr_err(\"Cannot enable PCI device from suspend\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(__E1000_DISABLED, &adapter->flags);\n\tpci_set_master(pdev);\n\n\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\tif (netif_running(netdev)) {\n\t\terr = e1000_request_irq(adapter);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\te1000_power_up_phy(adapter);\n\te1000_reset(adapter);\n\tew32(WUS, ~0);\n\n\te1000_init_manageability(adapter);\n\n\tif (netif_running(netdev))\n\t\te1000_up(adapter);\n\n\tnetif_device_attach(netdev);\n\n\treturn 0;\n}\n\nstatic void e1000_shutdown(struct pci_dev *pdev)\n{\n\tbool wake;\n\n\t__e1000_shutdown(pdev, &wake);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, wake);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void e1000_netpoll(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (disable_hardirq(adapter->pdev->irq))\n\t\te1000_intr(adapter->pdev->irq, netdev);\n\tenable_irq(adapter->pdev->irq);\n}\n#endif\n\n \nstatic pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tnetif_device_detach(netdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (netif_running(netdev))\n\t\te1000_down(adapter);\n\n\tif (!test_and_set_bit(__E1000_DISABLED, &adapter->flags))\n\t\tpci_disable_device(pdev);\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err;\n\n\tif (adapter->need_ioport)\n\t\terr = pci_enable_device(pdev);\n\telse\n\t\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\tpr_err(\"Cannot re-enable PCI device after reset.\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(__E1000_DISABLED, &adapter->flags);\n\tpci_set_master(pdev);\n\n\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\te1000_reset(adapter);\n\tew32(WUS, ~0);\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n \nstatic void e1000_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\te1000_init_manageability(adapter);\n\n\tif (netif_running(netdev)) {\n\t\tif (e1000_up(adapter)) {\n\t\t\tpr_info(\"can't bring device back up after reset\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tnetif_device_attach(netdev);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}