{
  "module_name": "e1000_param.c",
  "hash_id": "3d1772146f38a636c1fde46064dc34849a3fdc7d06accf09f4e815e8f0d7e6b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/e1000/e1000_param.c",
  "human_readable_source": "\n \n\n#include \"e1000.h\"\n\n \n\n#define E1000_MAX_NIC 32\n\n#define OPTION_UNSET   -1\n#define OPTION_DISABLED 0\n#define OPTION_ENABLED  1\n\n \n\n#define E1000_PARAM_INIT { [0 ... E1000_MAX_NIC] = OPTION_UNSET }\n#define E1000_PARAM(X, desc) \\\n\tstatic int X[E1000_MAX_NIC+1] = E1000_PARAM_INIT; \\\n\tstatic unsigned int num_##X; \\\n\tmodule_param_array_named(X, X, int, &num_##X, 0); \\\n\tMODULE_PARM_DESC(X, desc);\n\n \nE1000_PARAM(TxDescriptors, \"Number of transmit descriptors\");\n\n \nE1000_PARAM(RxDescriptors, \"Number of receive descriptors\");\n\n \nE1000_PARAM(Speed, \"Speed setting\");\n\n \nE1000_PARAM(Duplex, \"Duplex setting\");\n\n \nE1000_PARAM(AutoNeg, \"Advertised auto-negotiation setting\");\n#define AUTONEG_ADV_DEFAULT  0x2F\n\n \nE1000_PARAM(FlowControl, \"Flow Control setting\");\n\n \nE1000_PARAM(XsumRX, \"Disable or enable Receive Checksum offload\");\n\n \nE1000_PARAM(TxIntDelay, \"Transmit Interrupt Delay\");\n#define DEFAULT_TIDV                   8\n#define MAX_TXDELAY               0xFFFF\n#define MIN_TXDELAY                    0\n\n \nE1000_PARAM(TxAbsIntDelay, \"Transmit Absolute Interrupt Delay\");\n#define DEFAULT_TADV                  32\n#define MAX_TXABSDELAY            0xFFFF\n#define MIN_TXABSDELAY                 0\n\n \nE1000_PARAM(RxIntDelay, \"Receive Interrupt Delay\");\n#define DEFAULT_RDTR                   0\n#define MAX_RXDELAY               0xFFFF\n#define MIN_RXDELAY                    0\n\n \nE1000_PARAM(RxAbsIntDelay, \"Receive Absolute Interrupt Delay\");\n#define DEFAULT_RADV                   8\n#define MAX_RXABSDELAY            0xFFFF\n#define MIN_RXABSDELAY                 0\n\n \nE1000_PARAM(InterruptThrottleRate, \"Interrupt Throttling Rate\");\n#define DEFAULT_ITR                    3\n#define MAX_ITR                   100000\n#define MIN_ITR                      100\n\n \nE1000_PARAM(SmartPowerDownEnable, \"Enable PHY smart power down\");\n\nstruct e1000_option {\n\tenum { enable_option, range_option, list_option } type;\n\tconst char *name;\n\tconst char *err;\n\tint def;\n\tunion {\n\t\tstruct {  \n\t\t\tint min;\n\t\t\tint max;\n\t\t} r;\n\t\tstruct {  \n\t\t\tint nr;\n\t\t\tconst struct e1000_opt_list { int i; char *str; } *p;\n\t\t} l;\n\t} arg;\n};\n\nstatic int e1000_validate_option(unsigned int *value,\n\t\t\t\t const struct e1000_option *opt,\n\t\t\t\t struct e1000_adapter *adapter)\n{\n\tif (*value == OPTION_UNSET) {\n\t\t*value = opt->def;\n\t\treturn 0;\n\t}\n\n\tswitch (opt->type) {\n\tcase enable_option:\n\t\tswitch (*value) {\n\t\tcase OPTION_ENABLED:\n\t\t\te_dev_info(\"%s Enabled\\n\", opt->name);\n\t\t\treturn 0;\n\t\tcase OPTION_DISABLED:\n\t\t\te_dev_info(\"%s Disabled\\n\", opt->name);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase range_option:\n\t\tif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\n\t\t\te_dev_info(\"%s set to %i\\n\", opt->name, *value);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase list_option: {\n\t\tint i;\n\t\tconst struct e1000_opt_list *ent;\n\n\t\tfor (i = 0; i < opt->arg.l.nr; i++) {\n\t\t\tent = &opt->arg.l.p[i];\n\t\t\tif (*value == ent->i) {\n\t\t\t\tif (ent->str[0] != '\\0')\n\t\t\t\t\te_dev_info(\"%s\\n\", ent->str);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\te_dev_info(\"Invalid %s value specified (%i) %s\\n\",\n\t       opt->name, *value, opt->err);\n\t*value = opt->def;\n\treturn -1;\n}\n\nstatic void e1000_check_fiber_options(struct e1000_adapter *adapter);\nstatic void e1000_check_copper_options(struct e1000_adapter *adapter);\n\n \nvoid e1000_check_options(struct e1000_adapter *adapter)\n{\n\tstruct e1000_option opt;\n\tint bd = adapter->bd_number;\n\n\tif (bd >= E1000_MAX_NIC) {\n\t\te_dev_warn(\"Warning: no configuration for board #%i \"\n\t\t\t   \"using defaults for all values\\n\", bd);\n\t}\n\n\t{  \n\t\tstruct e1000_tx_ring *tx_ring = adapter->tx_ring;\n\t\tint i;\n\t\te1000_mac_type mac_type = adapter->hw.mac_type;\n\n\t\topt = (struct e1000_option) {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Transmit Descriptors\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(E1000_DEFAULT_TXD),\n\t\t\t.def  = E1000_DEFAULT_TXD,\n\t\t\t.arg  = { .r = {\n\t\t\t\t.min = E1000_MIN_TXD,\n\t\t\t\t.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD\n\t\t\t\t}}\n\t\t};\n\n\t\tif (num_TxDescriptors > bd) {\n\t\t\ttx_ring->count = TxDescriptors[bd];\n\t\t\te1000_validate_option(&tx_ring->count, &opt, adapter);\n\t\t\ttx_ring->count = ALIGN(tx_ring->count,\n\t\t\t\t\t\tREQ_TX_DESCRIPTOR_MULTIPLE);\n\t\t} else {\n\t\t\ttx_ring->count = opt.def;\n\t\t}\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\ttx_ring[i].count = tx_ring->count;\n\t}\n\t{  \n\t\tstruct e1000_rx_ring *rx_ring = adapter->rx_ring;\n\t\tint i;\n\t\te1000_mac_type mac_type = adapter->hw.mac_type;\n\n\t\topt = (struct e1000_option) {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Receive Descriptors\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(E1000_DEFAULT_RXD),\n\t\t\t.def  = E1000_DEFAULT_RXD,\n\t\t\t.arg  = { .r = {\n\t\t\t\t.min = E1000_MIN_RXD,\n\t\t\t\t.max = mac_type < e1000_82544 ? E1000_MAX_RXD :\n\t\t\t\t       E1000_MAX_82544_RXD\n\t\t\t}}\n\t\t};\n\n\t\tif (num_RxDescriptors > bd) {\n\t\t\trx_ring->count = RxDescriptors[bd];\n\t\t\te1000_validate_option(&rx_ring->count, &opt, adapter);\n\t\t\trx_ring->count = ALIGN(rx_ring->count,\n\t\t\t\t\t\tREQ_RX_DESCRIPTOR_MULTIPLE);\n\t\t} else {\n\t\t\trx_ring->count = opt.def;\n\t\t}\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\trx_ring[i].count = rx_ring->count;\n\t}\n\t{  \n\t\topt = (struct e1000_option) {\n\t\t\t.type = enable_option,\n\t\t\t.name = \"Checksum Offload\",\n\t\t\t.err  = \"defaulting to Enabled\",\n\t\t\t.def  = OPTION_ENABLED\n\t\t};\n\n\t\tif (num_XsumRX > bd) {\n\t\t\tunsigned int rx_csum = XsumRX[bd];\n\t\t\te1000_validate_option(&rx_csum, &opt, adapter);\n\t\t\tadapter->rx_csum = rx_csum;\n\t\t} else {\n\t\t\tadapter->rx_csum = opt.def;\n\t\t}\n\t}\n\t{  \n\n\t\tstatic const struct e1000_opt_list fc_list[] = {\n\t\t       { E1000_FC_NONE, \"Flow Control Disabled\" },\n\t\t       { E1000_FC_RX_PAUSE, \"Flow Control Receive Only\" },\n\t\t       { E1000_FC_TX_PAUSE, \"Flow Control Transmit Only\" },\n\t\t       { E1000_FC_FULL, \"Flow Control Enabled\" },\n\t\t       { E1000_FC_DEFAULT, \"Flow Control Hardware Default\" }\n\t\t};\n\n\t\topt = (struct e1000_option) {\n\t\t\t.type = list_option,\n\t\t\t.name = \"Flow Control\",\n\t\t\t.err  = \"reading default settings from EEPROM\",\n\t\t\t.def  = E1000_FC_DEFAULT,\n\t\t\t.arg  = { .l = { .nr = ARRAY_SIZE(fc_list),\n\t\t\t\t\t .p = fc_list }}\n\t\t};\n\n\t\tif (num_FlowControl > bd) {\n\t\t\tunsigned int fc = FlowControl[bd];\n\t\t\te1000_validate_option(&fc, &opt, adapter);\n\t\t\tadapter->hw.fc = adapter->hw.original_fc = fc;\n\t\t} else {\n\t\t\tadapter->hw.fc = adapter->hw.original_fc = opt.def;\n\t\t}\n\t}\n\t{  \n\t\topt = (struct e1000_option) {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Transmit Interrupt Delay\",\n\t\t\t.err  = \"using default of \" __MODULE_STRING(DEFAULT_TIDV),\n\t\t\t.def  = DEFAULT_TIDV,\n\t\t\t.arg  = { .r = { .min = MIN_TXDELAY,\n\t\t\t\t\t .max = MAX_TXDELAY }}\n\t\t};\n\n\t\tif (num_TxIntDelay > bd) {\n\t\t\tadapter->tx_int_delay = TxIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->tx_int_delay, &opt,\n\t\t\t                      adapter);\n\t\t} else {\n\t\t\tadapter->tx_int_delay = opt.def;\n\t\t}\n\t}\n\t{  \n\t\topt = (struct e1000_option) {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Transmit Absolute Interrupt Delay\",\n\t\t\t.err  = \"using default of \" __MODULE_STRING(DEFAULT_TADV),\n\t\t\t.def  = DEFAULT_TADV,\n\t\t\t.arg  = { .r = { .min = MIN_TXABSDELAY,\n\t\t\t\t\t .max = MAX_TXABSDELAY }}\n\t\t};\n\n\t\tif (num_TxAbsIntDelay > bd) {\n\t\t\tadapter->tx_abs_int_delay = TxAbsIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->tx_abs_int_delay, &opt,\n\t\t\t\t\t      adapter);\n\t\t} else {\n\t\t\tadapter->tx_abs_int_delay = opt.def;\n\t\t}\n\t}\n\t{  \n\t\topt = (struct e1000_option) {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Receive Interrupt Delay\",\n\t\t\t.err  = \"using default of \" __MODULE_STRING(DEFAULT_RDTR),\n\t\t\t.def  = DEFAULT_RDTR,\n\t\t\t.arg  = { .r = { .min = MIN_RXDELAY,\n\t\t\t\t\t .max = MAX_RXDELAY }}\n\t\t};\n\n\t\tif (num_RxIntDelay > bd) {\n\t\t\tadapter->rx_int_delay = RxIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->rx_int_delay, &opt,\n\t\t\t\t\t      adapter);\n\t\t} else {\n\t\t\tadapter->rx_int_delay = opt.def;\n\t\t}\n\t}\n\t{  \n\t\topt = (struct e1000_option) {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Receive Absolute Interrupt Delay\",\n\t\t\t.err  = \"using default of \" __MODULE_STRING(DEFAULT_RADV),\n\t\t\t.def  = DEFAULT_RADV,\n\t\t\t.arg  = { .r = { .min = MIN_RXABSDELAY,\n\t\t\t\t\t .max = MAX_RXABSDELAY }}\n\t\t};\n\n\t\tif (num_RxAbsIntDelay > bd) {\n\t\t\tadapter->rx_abs_int_delay = RxAbsIntDelay[bd];\n\t\t\te1000_validate_option(&adapter->rx_abs_int_delay, &opt,\n\t\t\t\t\t      adapter);\n\t\t} else {\n\t\t\tadapter->rx_abs_int_delay = opt.def;\n\t\t}\n\t}\n\t{  \n\t\topt = (struct e1000_option) {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Interrupt Throttling Rate (ints/sec)\",\n\t\t\t.err  = \"using default of \" __MODULE_STRING(DEFAULT_ITR),\n\t\t\t.def  = DEFAULT_ITR,\n\t\t\t.arg  = { .r = { .min = MIN_ITR,\n\t\t\t\t\t .max = MAX_ITR }}\n\t\t};\n\n\t\tif (num_InterruptThrottleRate > bd) {\n\t\t\tadapter->itr = InterruptThrottleRate[bd];\n\t\t\tswitch (adapter->itr) {\n\t\t\tcase 0:\n\t\t\t\te_dev_info(\"%s turned off\\n\", opt.name);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\te_dev_info(\"%s set to dynamic mode\\n\",\n\t\t\t\t\t   opt.name);\n\t\t\t\tadapter->itr_setting = adapter->itr;\n\t\t\t\tadapter->itr = 20000;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\te_dev_info(\"%s set to dynamic conservative \"\n\t\t\t\t\t   \"mode\\n\", opt.name);\n\t\t\t\tadapter->itr_setting = adapter->itr;\n\t\t\t\tadapter->itr = 20000;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\te_dev_info(\"%s set to simplified \"\n\t\t\t\t\t   \"(2000-8000) ints mode\\n\", opt.name);\n\t\t\t\tadapter->itr_setting = adapter->itr;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te1000_validate_option(&adapter->itr, &opt,\n\t\t\t\t\t\t      adapter);\n\t\t\t\t \n\t\t\t\tadapter->itr_setting = adapter->itr & ~3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tadapter->itr_setting = opt.def;\n\t\t\tadapter->itr = 20000;\n\t\t}\n\t}\n\t{  \n\t\topt = (struct e1000_option) {\n\t\t\t.type = enable_option,\n\t\t\t.name = \"PHY Smart Power Down\",\n\t\t\t.err  = \"defaulting to Disabled\",\n\t\t\t.def  = OPTION_DISABLED\n\t\t};\n\n\t\tif (num_SmartPowerDownEnable > bd) {\n\t\t\tunsigned int spd = SmartPowerDownEnable[bd];\n\t\t\te1000_validate_option(&spd, &opt, adapter);\n\t\t\tadapter->smart_power_down = spd;\n\t\t} else {\n\t\t\tadapter->smart_power_down = opt.def;\n\t\t}\n\t}\n\n\tswitch (adapter->hw.media_type) {\n\tcase e1000_media_type_fiber:\n\tcase e1000_media_type_internal_serdes:\n\t\te1000_check_fiber_options(adapter);\n\t\tbreak;\n\tcase e1000_media_type_copper:\n\t\te1000_check_copper_options(adapter);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \nstatic void e1000_check_fiber_options(struct e1000_adapter *adapter)\n{\n\tint bd = adapter->bd_number;\n\tif (num_Speed > bd) {\n\t\te_dev_info(\"Speed not valid for fiber adapters, parameter \"\n\t\t\t   \"ignored\\n\");\n\t}\n\n\tif (num_Duplex > bd) {\n\t\te_dev_info(\"Duplex not valid for fiber adapters, parameter \"\n\t\t\t   \"ignored\\n\");\n\t}\n\n\tif ((num_AutoNeg > bd) && (AutoNeg[bd] != 0x20)) {\n\t\te_dev_info(\"AutoNeg other than 1000/Full is not valid for fiber\"\n\t\t\t   \"adapters, parameter ignored\\n\");\n\t}\n}\n\n \nstatic void e1000_check_copper_options(struct e1000_adapter *adapter)\n{\n\tstruct e1000_option opt;\n\tunsigned int speed, dplx, an;\n\tint bd = adapter->bd_number;\n\n\t{  \n\t\tstatic const struct e1000_opt_list speed_list[] = {\n\t\t\t{          0, \"\" },\n\t\t\t{   SPEED_10, \"\" },\n\t\t\t{  SPEED_100, \"\" },\n\t\t\t{ SPEED_1000, \"\" }};\n\n\t\topt = (struct e1000_option) {\n\t\t\t.type = list_option,\n\t\t\t.name = \"Speed\",\n\t\t\t.err  = \"parameter ignored\",\n\t\t\t.def  = 0,\n\t\t\t.arg  = { .l = { .nr = ARRAY_SIZE(speed_list),\n\t\t\t\t\t .p = speed_list }}\n\t\t};\n\n\t\tif (num_Speed > bd) {\n\t\t\tspeed = Speed[bd];\n\t\t\te1000_validate_option(&speed, &opt, adapter);\n\t\t} else {\n\t\t\tspeed = opt.def;\n\t\t}\n\t}\n\t{  \n\t\tstatic const struct e1000_opt_list dplx_list[] = {\n\t\t\t{           0, \"\" },\n\t\t\t{ HALF_DUPLEX, \"\" },\n\t\t\t{ FULL_DUPLEX, \"\" }};\n\n\t\topt = (struct e1000_option) {\n\t\t\t.type = list_option,\n\t\t\t.name = \"Duplex\",\n\t\t\t.err  = \"parameter ignored\",\n\t\t\t.def  = 0,\n\t\t\t.arg  = { .l = { .nr = ARRAY_SIZE(dplx_list),\n\t\t\t\t\t .p = dplx_list }}\n\t\t};\n\n\t\tif (num_Duplex > bd) {\n\t\t\tdplx = Duplex[bd];\n\t\t\te1000_validate_option(&dplx, &opt, adapter);\n\t\t} else {\n\t\t\tdplx = opt.def;\n\t\t}\n\t}\n\n\tif ((num_AutoNeg > bd) && (speed != 0 || dplx != 0)) {\n\t\te_dev_info(\"AutoNeg specified along with Speed or Duplex, \"\n\t\t\t   \"parameter ignored\\n\");\n\t\tadapter->hw.autoneg_advertised = AUTONEG_ADV_DEFAULT;\n\t} else {  \n\t\tstatic const struct e1000_opt_list an_list[] =\n\t\t\t#define AA \"AutoNeg advertising \"\n\t\t\t{{ 0x01, AA \"10/HD\" },\n\t\t\t { 0x02, AA \"10/FD\" },\n\t\t\t { 0x03, AA \"10/FD, 10/HD\" },\n\t\t\t { 0x04, AA \"100/HD\" },\n\t\t\t { 0x05, AA \"100/HD, 10/HD\" },\n\t\t\t { 0x06, AA \"100/HD, 10/FD\" },\n\t\t\t { 0x07, AA \"100/HD, 10/FD, 10/HD\" },\n\t\t\t { 0x08, AA \"100/FD\" },\n\t\t\t { 0x09, AA \"100/FD, 10/HD\" },\n\t\t\t { 0x0a, AA \"100/FD, 10/FD\" },\n\t\t\t { 0x0b, AA \"100/FD, 10/FD, 10/HD\" },\n\t\t\t { 0x0c, AA \"100/FD, 100/HD\" },\n\t\t\t { 0x0d, AA \"100/FD, 100/HD, 10/HD\" },\n\t\t\t { 0x0e, AA \"100/FD, 100/HD, 10/FD\" },\n\t\t\t { 0x0f, AA \"100/FD, 100/HD, 10/FD, 10/HD\" },\n\t\t\t { 0x20, AA \"1000/FD\" },\n\t\t\t { 0x21, AA \"1000/FD, 10/HD\" },\n\t\t\t { 0x22, AA \"1000/FD, 10/FD\" },\n\t\t\t { 0x23, AA \"1000/FD, 10/FD, 10/HD\" },\n\t\t\t { 0x24, AA \"1000/FD, 100/HD\" },\n\t\t\t { 0x25, AA \"1000/FD, 100/HD, 10/HD\" },\n\t\t\t { 0x26, AA \"1000/FD, 100/HD, 10/FD\" },\n\t\t\t { 0x27, AA \"1000/FD, 100/HD, 10/FD, 10/HD\" },\n\t\t\t { 0x28, AA \"1000/FD, 100/FD\" },\n\t\t\t { 0x29, AA \"1000/FD, 100/FD, 10/HD\" },\n\t\t\t { 0x2a, AA \"1000/FD, 100/FD, 10/FD\" },\n\t\t\t { 0x2b, AA \"1000/FD, 100/FD, 10/FD, 10/HD\" },\n\t\t\t { 0x2c, AA \"1000/FD, 100/FD, 100/HD\" },\n\t\t\t { 0x2d, AA \"1000/FD, 100/FD, 100/HD, 10/HD\" },\n\t\t\t { 0x2e, AA \"1000/FD, 100/FD, 100/HD, 10/FD\" },\n\t\t\t { 0x2f, AA \"1000/FD, 100/FD, 100/HD, 10/FD, 10/HD\" }};\n\n\t\topt = (struct e1000_option) {\n\t\t\t.type = list_option,\n\t\t\t.name = \"AutoNeg\",\n\t\t\t.err  = \"parameter ignored\",\n\t\t\t.def  = AUTONEG_ADV_DEFAULT,\n\t\t\t.arg  = { .l = { .nr = ARRAY_SIZE(an_list),\n\t\t\t\t\t .p = an_list }}\n\t\t};\n\n\t\tif (num_AutoNeg > bd) {\n\t\t\tan = AutoNeg[bd];\n\t\t\te1000_validate_option(&an, &opt, adapter);\n\t\t} else {\n\t\t\tan = opt.def;\n\t\t}\n\t\tadapter->hw.autoneg_advertised = an;\n\t}\n\n\tswitch (speed + dplx) {\n\tcase 0:\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 1;\n\t\tif ((num_Speed > bd) && (speed != 0 || dplx != 0))\n\t\t\te_dev_info(\"Speed and duplex autonegotiation \"\n\t\t\t\t   \"enabled\\n\");\n\t\tbreak;\n\tcase HALF_DUPLEX:\n\t\te_dev_info(\"Half Duplex specified without Speed\\n\");\n\t\te_dev_info(\"Using Autonegotiation at Half Duplex only\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 1;\n\t\tadapter->hw.autoneg_advertised = ADVERTISE_10_HALF |\n\t\t\t\t\t\t ADVERTISE_100_HALF;\n\t\tbreak;\n\tcase FULL_DUPLEX:\n\t\te_dev_info(\"Full Duplex specified without Speed\\n\");\n\t\te_dev_info(\"Using Autonegotiation at Full Duplex only\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 1;\n\t\tadapter->hw.autoneg_advertised = ADVERTISE_10_FULL |\n\t\t\t\t\t\t ADVERTISE_100_FULL |\n\t\t\t\t\t\t ADVERTISE_1000_FULL;\n\t\tbreak;\n\tcase SPEED_10:\n\t\te_dev_info(\"10 Mbps Speed specified without Duplex\\n\");\n\t\te_dev_info(\"Using Autonegotiation at 10 Mbps only\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 1;\n\t\tadapter->hw.autoneg_advertised = ADVERTISE_10_HALF |\n\t\t\t\t\t\t ADVERTISE_10_FULL;\n\t\tbreak;\n\tcase SPEED_10 + HALF_DUPLEX:\n\t\te_dev_info(\"Forcing to 10 Mbps Half Duplex\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 0;\n\t\tadapter->hw.forced_speed_duplex = e1000_10_half;\n\t\tadapter->hw.autoneg_advertised = 0;\n\t\tbreak;\n\tcase SPEED_10 + FULL_DUPLEX:\n\t\te_dev_info(\"Forcing to 10 Mbps Full Duplex\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 0;\n\t\tadapter->hw.forced_speed_duplex = e1000_10_full;\n\t\tadapter->hw.autoneg_advertised = 0;\n\t\tbreak;\n\tcase SPEED_100:\n\t\te_dev_info(\"100 Mbps Speed specified without Duplex\\n\");\n\t\te_dev_info(\"Using Autonegotiation at 100 Mbps only\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 1;\n\t\tadapter->hw.autoneg_advertised = ADVERTISE_100_HALF |\n\t\t\t\t\t\t ADVERTISE_100_FULL;\n\t\tbreak;\n\tcase SPEED_100 + HALF_DUPLEX:\n\t\te_dev_info(\"Forcing to 100 Mbps Half Duplex\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 0;\n\t\tadapter->hw.forced_speed_duplex = e1000_100_half;\n\t\tadapter->hw.autoneg_advertised = 0;\n\t\tbreak;\n\tcase SPEED_100 + FULL_DUPLEX:\n\t\te_dev_info(\"Forcing to 100 Mbps Full Duplex\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 0;\n\t\tadapter->hw.forced_speed_duplex = e1000_100_full;\n\t\tadapter->hw.autoneg_advertised = 0;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\te_dev_info(\"1000 Mbps Speed specified without Duplex\\n\");\n\t\tgoto full_duplex_only;\n\tcase SPEED_1000 + HALF_DUPLEX:\n\t\te_dev_info(\"Half Duplex is not supported at 1000 Mbps\\n\");\n\t\tfallthrough;\n\tcase SPEED_1000 + FULL_DUPLEX:\nfull_duplex_only:\n\t\te_dev_info(\"Using Autonegotiation at 1000 Mbps Full Duplex \"\n\t\t\t   \"only\\n\");\n\t\tadapter->hw.autoneg = adapter->fc_autoneg = 1;\n\t\tadapter->hw.autoneg_advertised = ADVERTISE_1000_FULL;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\tif (e1000_validate_mdi_setting(&(adapter->hw)) < 0) {\n\t\te_dev_info(\"Speed, AutoNeg and MDI-X specs are incompatible. \"\n\t\t\t   \"Setting MDI-X to a compatible value.\\n\");\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}