{
  "module_name": "vf.c",
  "hash_id": "f11d73c7dd8df3adc7770b72414901d5a5bfa640cfb5e13488c8628b82278ec9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbevf/vf.c",
  "human_readable_source": "\n \n\n#include \"vf.h\"\n#include \"ixgbevf.h\"\n\n \n#define IXGBE_HV_RESET_OFFSET           0x201\n\nstatic inline s32 ixgbevf_write_msg_read_ack(struct ixgbe_hw *hw, u32 *msg,\n\t\t\t\t\t     u32 *retmsg, u16 size)\n{\n\ts32 retval = ixgbevf_write_mbx(hw, msg, size);\n\n\tif (retval)\n\t\treturn retval;\n\n\treturn ixgbevf_poll_mbx(hw, retmsg, size);\n}\n\n \nstatic s32 ixgbevf_start_hw_vf(struct ixgbe_hw *hw)\n{\n\t \n\thw->adapter_stopped = false;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_init_hw_vf(struct ixgbe_hw *hw)\n{\n\ts32 status = hw->mac.ops.start_hw(hw);\n\n\thw->mac.ops.get_mac_addr(hw, hw->mac.addr);\n\n\treturn status;\n}\n\n \nstatic s32 ixgbevf_reset_hw_vf(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\tu32 timeout = IXGBE_VF_INIT_TIMEOUT;\n\tu32 msgbuf[IXGBE_VF_PERMADDR_MSG_LEN];\n\tu8 *addr = (u8 *)(&msgbuf[1]);\n\ts32 ret_val;\n\n\t \n\thw->mac.ops.stop_adapter(hw);\n\n\t \n\thw->api_version = ixgbe_mbox_api_10;\n\thw->mbx.ops.init_params(hw);\n\tmemcpy(&hw->mbx.ops, &ixgbevf_mbx_ops_legacy,\n\t       sizeof(struct ixgbe_mbx_operations));\n\n\tIXGBE_WRITE_REG(hw, IXGBE_VFCTRL, IXGBE_CTRL_RST);\n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\twhile (!mbx->ops.check_for_rst(hw) && timeout) {\n\t\ttimeout--;\n\t\tudelay(5);\n\t}\n\n\tif (!timeout)\n\t\treturn IXGBE_ERR_RESET_FAILED;\n\n\t \n\tmbx->timeout = IXGBE_VF_MBX_INIT_TIMEOUT;\n\n\tmsgbuf[0] = IXGBE_VF_RESET;\n\tixgbevf_write_mbx(hw, msgbuf, 1);\n\n\tmdelay(10);\n\n\t \n\tret_val = ixgbevf_poll_mbx(hw, msgbuf, IXGBE_VF_PERMADDR_MSG_LEN);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tif (msgbuf[0] != (IXGBE_VF_RESET | IXGBE_VT_MSGTYPE_SUCCESS) &&\n\t    msgbuf[0] != (IXGBE_VF_RESET | IXGBE_VT_MSGTYPE_FAILURE))\n\t\treturn IXGBE_ERR_INVALID_MAC_ADDR;\n\n\tif (msgbuf[0] == (IXGBE_VF_RESET | IXGBE_VT_MSGTYPE_SUCCESS))\n\t\tether_addr_copy(hw->mac.perm_addr, addr);\n\n\thw->mac.mc_filter_type = msgbuf[IXGBE_VF_MC_TYPE_WORD];\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_hv_reset_hw_vf(struct ixgbe_hw *hw)\n{\n#if IS_ENABLED(CONFIG_PCI_MMCONFIG)\n\tstruct ixgbevf_adapter *adapter = hw->back;\n\tint i;\n\n\tfor (i = 0; i < 6; i++)\n\t\tpci_read_config_byte(adapter->pdev,\n\t\t\t\t     (i + IXGBE_HV_RESET_OFFSET),\n\t\t\t\t     &hw->mac.perm_addr[i]);\n\treturn 0;\n#else\n\tpr_err(\"PCI_MMCONFIG needs to be enabled for Hyper-V\\n\");\n\treturn -EOPNOTSUPP;\n#endif\n}\n\n \nstatic s32 ixgbevf_stop_hw_vf(struct ixgbe_hw *hw)\n{\n\tu32 number_of_queues;\n\tu32 reg_val;\n\tu16 i;\n\n\t \n\thw->adapter_stopped = true;\n\n\t \n\tnumber_of_queues = hw->mac.max_rx_queues;\n\tfor (i = 0; i < number_of_queues; i++) {\n\t\treg_val = IXGBE_READ_REG(hw, IXGBE_VFRXDCTL(i));\n\t\tif (reg_val & IXGBE_RXDCTL_ENABLE) {\n\t\t\treg_val &= ~IXGBE_RXDCTL_ENABLE;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_VFRXDCTL(i), reg_val);\n\t\t}\n\t}\n\n\tIXGBE_WRITE_FLUSH(hw);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_VTEIMC, IXGBE_VF_IRQ_CLEAR_MASK);\n\n\t \n\tIXGBE_READ_REG(hw, IXGBE_VTEICR);\n\n\t \n\tnumber_of_queues = hw->mac.max_tx_queues;\n\tfor (i = 0; i < number_of_queues; i++) {\n\t\treg_val = IXGBE_READ_REG(hw, IXGBE_VFTXDCTL(i));\n\t\tif (reg_val & IXGBE_TXDCTL_ENABLE) {\n\t\t\treg_val &= ~IXGBE_TXDCTL_ENABLE;\n\t\t\tIXGBE_WRITE_REG(hw, IXGBE_VFTXDCTL(i), reg_val);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)\n{\n\tu32 vector = 0;\n\n\tswitch (hw->mac.mc_filter_type) {\n\tcase 0:    \n\t\tvector = ((mc_addr[4] >> 4) | (((u16)mc_addr[5]) << 4));\n\t\tbreak;\n\tcase 1:    \n\t\tvector = ((mc_addr[4] >> 3) | (((u16)mc_addr[5]) << 5));\n\t\tbreak;\n\tcase 2:    \n\t\tvector = ((mc_addr[4] >> 2) | (((u16)mc_addr[5]) << 6));\n\t\tbreak;\n\tcase 3:    \n\t\tvector = ((mc_addr[4]) | (((u16)mc_addr[5]) << 8));\n\t\tbreak;\n\tdefault:   \n\t\tbreak;\n\t}\n\n\t \n\tvector &= 0xFFF;\n\treturn vector;\n}\n\n \nstatic s32 ixgbevf_get_mac_addr_vf(struct ixgbe_hw *hw, u8 *mac_addr)\n{\n\tether_addr_copy(mac_addr, hw->mac.perm_addr);\n\n\treturn 0;\n}\n\nstatic s32 ixgbevf_set_uc_addr_vf(struct ixgbe_hw *hw, u32 index, u8 *addr)\n{\n\tu32 msgbuf[3], msgbuf_chk;\n\tu8 *msg_addr = (u8 *)(&msgbuf[1]);\n\ts32 ret_val;\n\n\tmemset(msgbuf, 0, sizeof(msgbuf));\n\t \n\tmsgbuf[0] |= index << IXGBE_VT_MSGINFO_SHIFT;\n\tmsgbuf[0] |= IXGBE_VF_SET_MACVLAN;\n\tmsgbuf_chk = msgbuf[0];\n\n\tif (addr)\n\t\tether_addr_copy(msg_addr, addr);\n\n\tret_val = ixgbevf_write_msg_read_ack(hw, msgbuf, msgbuf,\n\t\t\t\t\t     ARRAY_SIZE(msgbuf));\n\tif (!ret_val) {\n\t\tmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\n\t\tif (msgbuf[0] == (msgbuf_chk | IXGBE_VT_MSGTYPE_FAILURE))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn ret_val;\n}\n\nstatic s32 ixgbevf_hv_set_uc_addr_vf(struct ixgbe_hw *hw, u32 index, u8 *addr)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nint ixgbevf_get_reta_locked(struct ixgbe_hw *hw, u32 *reta, int num_rx_queues)\n{\n\tint err, i, j;\n\tu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\n\tu32 *hw_reta = &msgbuf[1];\n\tu32 mask = 0;\n\n\t \n\tint dwords = IXGBEVF_82599_RETA_SIZE / 16;\n\n\t \n\tswitch (hw->api_version) {\n\tcase ixgbe_mbox_api_15:\n\tcase ixgbe_mbox_api_14:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_12:\n\t\tif (hw->mac.type < ixgbe_mac_X550_vf)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmsgbuf[0] = IXGBE_VF_GET_RETA;\n\n\terr = ixgbevf_write_mbx(hw, msgbuf, 1);\n\n\tif (err)\n\t\treturn err;\n\n\terr = ixgbevf_poll_mbx(hw, msgbuf, dwords + 1);\n\n\tif (err)\n\t\treturn err;\n\n\tmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\n\t \n\tif (msgbuf[0] == (IXGBE_VF_GET_RETA | IXGBE_VT_MSGTYPE_FAILURE))\n\t\treturn -EPERM;\n\n\t \n\tif (msgbuf[0] != (IXGBE_VF_GET_RETA | IXGBE_VT_MSGTYPE_SUCCESS))\n\t\treturn IXGBE_ERR_MBX;\n\n\t \n\tif (num_rx_queues > 1)\n\t\tmask = 0x1;\n\n\tfor (i = 0; i < dwords; i++)\n\t\tfor (j = 0; j < 16; j++)\n\t\t\treta[i * 16 + j] = (hw_reta[i] >> (2 * j)) & mask;\n\n\treturn 0;\n}\n\n \nint ixgbevf_get_rss_key_locked(struct ixgbe_hw *hw, u8 *rss_key)\n{\n\tint err;\n\tu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\n\n\t \n\tswitch (hw->api_version) {\n\tcase ixgbe_mbox_api_15:\n\tcase ixgbe_mbox_api_14:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_12:\n\t\tif (hw->mac.type < ixgbe_mac_X550_vf)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmsgbuf[0] = IXGBE_VF_GET_RSS_KEY;\n\terr = ixgbevf_write_mbx(hw, msgbuf, 1);\n\n\tif (err)\n\t\treturn err;\n\n\terr = ixgbevf_poll_mbx(hw, msgbuf, 11);\n\n\tif (err)\n\t\treturn err;\n\n\tmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\n\t \n\tif (msgbuf[0] == (IXGBE_VF_GET_RSS_KEY | IXGBE_VT_MSGTYPE_FAILURE))\n\t\treturn -EPERM;\n\n\t \n\tif (msgbuf[0] != (IXGBE_VF_GET_RSS_KEY | IXGBE_VT_MSGTYPE_SUCCESS))\n\t\treturn IXGBE_ERR_MBX;\n\n\tmemcpy(rss_key, msgbuf + 1, IXGBEVF_RSS_HASH_KEY_SIZE);\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_set_rar_vf(struct ixgbe_hw *hw, u32 index, u8 *addr,\n\t\t\t      u32 vmdq)\n{\n\tu32 msgbuf[3];\n\tu8 *msg_addr = (u8 *)(&msgbuf[1]);\n\ts32 ret_val;\n\n\tmemset(msgbuf, 0, sizeof(msgbuf));\n\tmsgbuf[0] = IXGBE_VF_SET_MAC_ADDR;\n\tether_addr_copy(msg_addr, addr);\n\n\tret_val = ixgbevf_write_msg_read_ack(hw, msgbuf, msgbuf,\n\t\t\t\t\t     ARRAY_SIZE(msgbuf));\n\tmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\n\t \n\tif (!ret_val &&\n\t    (msgbuf[0] == (IXGBE_VF_SET_MAC_ADDR | IXGBE_VT_MSGTYPE_FAILURE))) {\n\t\tixgbevf_get_mac_addr_vf(hw, hw->mac.addr);\n\t\treturn IXGBE_ERR_MBX;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_hv_set_rar_vf(struct ixgbe_hw *hw, u32 index, u8 *addr,\n\t\t\t\t u32 vmdq)\n{\n\tif (ether_addr_equal(addr, hw->mac.perm_addr))\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic s32 ixgbevf_update_mc_addr_list_vf(struct ixgbe_hw *hw,\n\t\t\t\t\t  struct net_device *netdev)\n{\n\tstruct netdev_hw_addr *ha;\n\tu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\n\tu16 *vector_list = (u16 *)&msgbuf[1];\n\tu32 cnt, i;\n\n\t \n\n\tcnt = netdev_mc_count(netdev);\n\tif (cnt > 30)\n\t\tcnt = 30;\n\tmsgbuf[0] = IXGBE_VF_SET_MULTICAST;\n\tmsgbuf[0] |= cnt << IXGBE_VT_MSGINFO_SHIFT;\n\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\tif (i == cnt)\n\t\t\tbreak;\n\t\tif (is_link_local_ether_addr(ha->addr))\n\t\t\tcontinue;\n\n\t\tvector_list[i++] = ixgbevf_mta_vector(hw, ha->addr);\n\t}\n\n\treturn ixgbevf_write_msg_read_ack(hw, msgbuf, msgbuf,\n\t\t\tIXGBE_VFMAILBOX_SIZE);\n}\n\n \nstatic s32 ixgbevf_hv_update_mc_addr_list_vf(struct ixgbe_hw *hw,\n\t\t\t\t\t     struct net_device *netdev)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic s32 ixgbevf_update_xcast_mode(struct ixgbe_hw *hw, int xcast_mode)\n{\n\tu32 msgbuf[2];\n\ts32 err;\n\n\tswitch (hw->api_version) {\n\tcase ixgbe_mbox_api_12:\n\t\t \n\t\tif (xcast_mode == IXGBEVF_XCAST_MODE_PROMISC)\n\t\t\treturn -EOPNOTSUPP;\n\t\tfallthrough;\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_14:\n\tcase ixgbe_mbox_api_15:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmsgbuf[0] = IXGBE_VF_UPDATE_XCAST_MODE;\n\tmsgbuf[1] = xcast_mode;\n\n\terr = ixgbevf_write_msg_read_ack(hw, msgbuf, msgbuf,\n\t\t\t\t\t ARRAY_SIZE(msgbuf));\n\tif (err)\n\t\treturn err;\n\n\tmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\tif (msgbuf[0] == (IXGBE_VF_UPDATE_XCAST_MODE | IXGBE_VT_MSGTYPE_FAILURE))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_hv_update_xcast_mode(struct ixgbe_hw *hw, int xcast_mode)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic s32 ixgbevf_get_link_state_vf(struct ixgbe_hw *hw, bool *link_state)\n{\n\tu32 msgbuf[2];\n\ts32 ret_val;\n\ts32 err;\n\n\tmsgbuf[0] = IXGBE_VF_GET_LINK_STATE;\n\tmsgbuf[1] = 0x0;\n\n\terr = ixgbevf_write_msg_read_ack(hw, msgbuf, msgbuf, 2);\n\n\tif (err || (msgbuf[0] & IXGBE_VT_MSGTYPE_FAILURE)) {\n\t\tret_val = IXGBE_ERR_MBX;\n\t} else {\n\t\tret_val = 0;\n\t\t*link_state = msgbuf[1];\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_hv_get_link_state_vf(struct ixgbe_hw *hw, bool *link_state)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic s32 ixgbevf_set_vfta_vf(struct ixgbe_hw *hw, u32 vlan, u32 vind,\n\t\t\t       bool vlan_on)\n{\n\tu32 msgbuf[2];\n\ts32 err;\n\n\tmsgbuf[0] = IXGBE_VF_SET_VLAN;\n\tmsgbuf[1] = vlan;\n\t \n\tmsgbuf[0] |= vlan_on << IXGBE_VT_MSGINFO_SHIFT;\n\n\terr = ixgbevf_write_msg_read_ack(hw, msgbuf, msgbuf,\n\t\t\t\t\t ARRAY_SIZE(msgbuf));\n\tif (err)\n\t\tgoto mbx_err;\n\n\t \n\tmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\tmsgbuf[0] &= ~(0xFF << IXGBE_VT_MSGINFO_SHIFT);\n\n\tif (msgbuf[0] != (IXGBE_VF_SET_VLAN | IXGBE_VT_MSGTYPE_SUCCESS))\n\t\terr = IXGBE_ERR_INVALID_ARGUMENT;\n\nmbx_err:\n\treturn err;\n}\n\n \nstatic s32 ixgbevf_hv_set_vfta_vf(struct ixgbe_hw *hw, u32 vlan, u32 vind,\n\t\t\t\t  bool vlan_on)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic s32 ixgbevf_setup_mac_link_vf(struct ixgbe_hw *hw,\n\t\t\t\t     ixgbe_link_speed speed, bool autoneg,\n\t\t\t\t     bool autoneg_wait_to_complete)\n{\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_check_mac_link_vf(struct ixgbe_hw *hw,\n\t\t\t\t     ixgbe_link_speed *speed,\n\t\t\t\t     bool *link_up,\n\t\t\t\t     bool autoneg_wait_to_complete)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\ts32 ret_val = 0;\n\tu32 links_reg;\n\tu32 in_msg = 0;\n\n\t \n\tif (!mbx->ops.check_for_rst(hw) || !mbx->timeout)\n\t\tmac->get_link_status = true;\n\n\tif (!mac->get_link_status)\n\t\tgoto out;\n\n\t \n\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_VFLINKS);\n\tif (!(links_reg & IXGBE_LINKS_UP))\n\t\tgoto out;\n\n\t \n\tif (mac->type == ixgbe_mac_82599_vf) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tudelay(100);\n\t\t\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_VFLINKS);\n\n\t\t\tif (!(links_reg & IXGBE_LINKS_UP))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (links_reg & IXGBE_LINKS_SPEED_82599) {\n\tcase IXGBE_LINKS_SPEED_10G_82599:\n\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t\tbreak;\n\tcase IXGBE_LINKS_SPEED_1G_82599:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\tbreak;\n\tcase IXGBE_LINKS_SPEED_100_82599:\n\t\t*speed = IXGBE_LINK_SPEED_100_FULL;\n\t\tbreak;\n\t}\n\n\t \n\tif (mbx->ops.read(hw, &in_msg, 1)) {\n\t\tif (hw->api_version >= ixgbe_mbox_api_15)\n\t\t\tmac->get_link_status = false;\n\t\tgoto out;\n\t}\n\n\tif (!(in_msg & IXGBE_VT_MSGTYPE_CTS)) {\n\t\t \n\t\tif (in_msg & IXGBE_VT_MSGTYPE_FAILURE)\n\t\t\tret_val = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!mbx->timeout) {\n\t\tret_val = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tmac->get_link_status = false;\n\nout:\n\t*link_up = !mac->get_link_status;\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_hv_check_mac_link_vf(struct ixgbe_hw *hw,\n\t\t\t\t\tixgbe_link_speed *speed,\n\t\t\t\t\tbool *link_up,\n\t\t\t\t\tbool autoneg_wait_to_complete)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\tstruct ixgbe_mac_info *mac = &hw->mac;\n\tu32 links_reg;\n\n\t \n\tif (!mbx->ops.check_for_rst(hw) || !mbx->timeout)\n\t\tmac->get_link_status = true;\n\n\tif (!mac->get_link_status)\n\t\tgoto out;\n\n\t \n\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_VFLINKS);\n\tif (!(links_reg & IXGBE_LINKS_UP))\n\t\tgoto out;\n\n\t \n\tif (mac->type == ixgbe_mac_82599_vf) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tudelay(100);\n\t\t\tlinks_reg = IXGBE_READ_REG(hw, IXGBE_VFLINKS);\n\n\t\t\tif (!(links_reg & IXGBE_LINKS_UP))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (links_reg & IXGBE_LINKS_SPEED_82599) {\n\tcase IXGBE_LINKS_SPEED_10G_82599:\n\t\t*speed = IXGBE_LINK_SPEED_10GB_FULL;\n\t\tbreak;\n\tcase IXGBE_LINKS_SPEED_1G_82599:\n\t\t*speed = IXGBE_LINK_SPEED_1GB_FULL;\n\t\tbreak;\n\tcase IXGBE_LINKS_SPEED_100_82599:\n\t\t*speed = IXGBE_LINK_SPEED_100_FULL;\n\t\tbreak;\n\t}\n\n\t \n\tmac->get_link_status = false;\n\nout:\n\t*link_up = !mac->get_link_status;\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_set_rlpml_vf(struct ixgbe_hw *hw, u16 max_size)\n{\n\tu32 msgbuf[2];\n\ts32 ret_val;\n\n\tmsgbuf[0] = IXGBE_VF_SET_LPE;\n\tmsgbuf[1] = max_size;\n\n\tret_val = ixgbevf_write_msg_read_ack(hw, msgbuf, msgbuf,\n\t\t\t\t\t     ARRAY_SIZE(msgbuf));\n\tif (ret_val)\n\t\treturn ret_val;\n\tif ((msgbuf[0] & IXGBE_VF_SET_LPE) &&\n\t    (msgbuf[0] & IXGBE_VT_MSGTYPE_FAILURE))\n\t\treturn IXGBE_ERR_MBX;\n\n\treturn 0;\n}\n\n \nstatic s32 ixgbevf_hv_set_rlpml_vf(struct ixgbe_hw *hw, u16 max_size)\n{\n\tu32 reg;\n\n\t \n\treg =  IXGBE_READ_REG(hw, IXGBE_VFRXDCTL(0));\n\t \n\treg |= ((max_size + 4) | IXGBE_RXDCTL_RLPML_EN);\n\tIXGBE_WRITE_REG(hw, IXGBE_VFRXDCTL(0), reg);\n\n\treturn 0;\n}\n\n \nstatic int ixgbevf_negotiate_api_version_vf(struct ixgbe_hw *hw, int api)\n{\n\tint err;\n\tu32 msg[3];\n\n\t \n\tmsg[0] = IXGBE_VF_API_NEGOTIATE;\n\tmsg[1] = api;\n\tmsg[2] = 0;\n\n\terr = ixgbevf_write_msg_read_ack(hw, msg, msg, ARRAY_SIZE(msg));\n\tif (!err) {\n\t\tmsg[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\n\t\t \n\t\tif (msg[0] == (IXGBE_VF_API_NEGOTIATE |\n\t\t\t      IXGBE_VT_MSGTYPE_SUCCESS)) {\n\t\t\thw->api_version = api;\n\t\t\treturn 0;\n\t\t}\n\n\t\terr = IXGBE_ERR_INVALID_ARGUMENT;\n\t}\n\n\treturn err;\n}\n\n \nstatic int ixgbevf_hv_negotiate_api_version_vf(struct ixgbe_hw *hw, int api)\n{\n\t \n\tif (api != ixgbe_mbox_api_10)\n\t\treturn IXGBE_ERR_INVALID_ARGUMENT;\n\n\treturn 0;\n}\n\nint ixgbevf_get_queues(struct ixgbe_hw *hw, unsigned int *num_tcs,\n\t\t       unsigned int *default_tc)\n{\n\tint err;\n\tu32 msg[5];\n\n\t \n\tswitch (hw->api_version) {\n\tcase ixgbe_mbox_api_11:\n\tcase ixgbe_mbox_api_12:\n\tcase ixgbe_mbox_api_13:\n\tcase ixgbe_mbox_api_14:\n\tcase ixgbe_mbox_api_15:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tmsg[0] = IXGBE_VF_GET_QUEUE;\n\tmsg[1] = msg[2] = msg[3] = msg[4] = 0;\n\n\terr = ixgbevf_write_msg_read_ack(hw, msg, msg, ARRAY_SIZE(msg));\n\tif (!err) {\n\t\tmsg[0] &= ~IXGBE_VT_MSGTYPE_CTS;\n\n\t\t \n\t\tif (msg[0] != (IXGBE_VF_GET_QUEUE | IXGBE_VT_MSGTYPE_SUCCESS))\n\t\t\treturn IXGBE_ERR_MBX;\n\n\t\t \n\t\thw->mac.max_tx_queues = msg[IXGBE_VF_TX_QUEUES];\n\t\tif (hw->mac.max_tx_queues == 0 ||\n\t\t    hw->mac.max_tx_queues > IXGBE_VF_MAX_TX_QUEUES)\n\t\t\thw->mac.max_tx_queues = IXGBE_VF_MAX_TX_QUEUES;\n\n\t\thw->mac.max_rx_queues = msg[IXGBE_VF_RX_QUEUES];\n\t\tif (hw->mac.max_rx_queues == 0 ||\n\t\t    hw->mac.max_rx_queues > IXGBE_VF_MAX_RX_QUEUES)\n\t\t\thw->mac.max_rx_queues = IXGBE_VF_MAX_RX_QUEUES;\n\n\t\t*num_tcs = msg[IXGBE_VF_TRANS_VLAN];\n\t\t \n\t\tif (*num_tcs > hw->mac.max_rx_queues)\n\t\t\t*num_tcs = 1;\n\n\t\t*default_tc = msg[IXGBE_VF_DEF_QUEUE];\n\t\t \n\t\tif (*default_tc >= hw->mac.max_tx_queues)\n\t\t\t*default_tc = 0;\n\t}\n\n\treturn err;\n}\n\nstatic const struct ixgbe_mac_operations ixgbevf_mac_ops = {\n\t.init_hw\t\t= ixgbevf_init_hw_vf,\n\t.reset_hw\t\t= ixgbevf_reset_hw_vf,\n\t.start_hw\t\t= ixgbevf_start_hw_vf,\n\t.get_mac_addr\t\t= ixgbevf_get_mac_addr_vf,\n\t.stop_adapter\t\t= ixgbevf_stop_hw_vf,\n\t.setup_link\t\t= ixgbevf_setup_mac_link_vf,\n\t.check_link\t\t= ixgbevf_check_mac_link_vf,\n\t.negotiate_api_version\t= ixgbevf_negotiate_api_version_vf,\n\t.set_rar\t\t= ixgbevf_set_rar_vf,\n\t.update_mc_addr_list\t= ixgbevf_update_mc_addr_list_vf,\n\t.update_xcast_mode\t= ixgbevf_update_xcast_mode,\n\t.get_link_state\t\t= ixgbevf_get_link_state_vf,\n\t.set_uc_addr\t\t= ixgbevf_set_uc_addr_vf,\n\t.set_vfta\t\t= ixgbevf_set_vfta_vf,\n\t.set_rlpml\t\t= ixgbevf_set_rlpml_vf,\n};\n\nstatic const struct ixgbe_mac_operations ixgbevf_hv_mac_ops = {\n\t.init_hw\t\t= ixgbevf_init_hw_vf,\n\t.reset_hw\t\t= ixgbevf_hv_reset_hw_vf,\n\t.start_hw\t\t= ixgbevf_start_hw_vf,\n\t.get_mac_addr\t\t= ixgbevf_get_mac_addr_vf,\n\t.stop_adapter\t\t= ixgbevf_stop_hw_vf,\n\t.setup_link\t\t= ixgbevf_setup_mac_link_vf,\n\t.check_link\t\t= ixgbevf_hv_check_mac_link_vf,\n\t.negotiate_api_version\t= ixgbevf_hv_negotiate_api_version_vf,\n\t.set_rar\t\t= ixgbevf_hv_set_rar_vf,\n\t.update_mc_addr_list\t= ixgbevf_hv_update_mc_addr_list_vf,\n\t.update_xcast_mode\t= ixgbevf_hv_update_xcast_mode,\n\t.get_link_state\t\t= ixgbevf_hv_get_link_state_vf,\n\t.set_uc_addr\t\t= ixgbevf_hv_set_uc_addr_vf,\n\t.set_vfta\t\t= ixgbevf_hv_set_vfta_vf,\n\t.set_rlpml\t\t= ixgbevf_hv_set_rlpml_vf,\n};\n\nconst struct ixgbevf_info ixgbevf_82599_vf_info = {\n\t.mac = ixgbe_mac_82599_vf,\n\t.mac_ops = &ixgbevf_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_82599_vf_hv_info = {\n\t.mac = ixgbe_mac_82599_vf,\n\t.mac_ops = &ixgbevf_hv_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_X540_vf_info = {\n\t.mac = ixgbe_mac_X540_vf,\n\t.mac_ops = &ixgbevf_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_X540_vf_hv_info = {\n\t.mac = ixgbe_mac_X540_vf,\n\t.mac_ops = &ixgbevf_hv_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_X550_vf_info = {\n\t.mac = ixgbe_mac_X550_vf,\n\t.mac_ops = &ixgbevf_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_X550_vf_hv_info = {\n\t.mac = ixgbe_mac_X550_vf,\n\t.mac_ops = &ixgbevf_hv_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_X550EM_x_vf_info = {\n\t.mac = ixgbe_mac_X550EM_x_vf,\n\t.mac_ops = &ixgbevf_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_X550EM_x_vf_hv_info = {\n\t.mac = ixgbe_mac_X550EM_x_vf,\n\t.mac_ops = &ixgbevf_hv_mac_ops,\n};\n\nconst struct ixgbevf_info ixgbevf_x550em_a_vf_info = {\n\t.mac = ixgbe_mac_x550em_a_vf,\n\t.mac_ops = &ixgbevf_mac_ops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}