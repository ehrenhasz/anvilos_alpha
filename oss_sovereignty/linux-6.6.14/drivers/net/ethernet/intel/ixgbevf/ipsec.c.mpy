{
  "module_name": "ipsec.c",
  "hash_id": "336bbd56b863a9b6c639c71a28595bcf7913772f63674fc739f250bbf0ba0551",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbevf/ipsec.c",
  "human_readable_source": "\n \n\n#include \"ixgbevf.h\"\n#include <net/xfrm.h>\n#include <crypto/aead.h>\n\n#define IXGBE_IPSEC_KEY_BITS  160\nstatic const char aes_gcm_name[] = \"rfc4106(gcm(aes))\";\n\n \nstatic int ixgbevf_ipsec_set_pf_sa(struct ixgbevf_adapter *adapter,\n\t\t\t\t   struct xfrm_state *xs)\n{\n\tu32 msgbuf[IXGBE_VFMAILBOX_SIZE] = { 0 };\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct sa_mbx_msg *sam;\n\tint ret;\n\n\t \n\tsam = (struct sa_mbx_msg *)(&msgbuf[1]);\n\tsam->dir = xs->xso.dir;\n\tsam->spi = xs->id.spi;\n\tsam->proto = xs->id.proto;\n\tsam->family = xs->props.family;\n\n\tif (xs->props.family == AF_INET6)\n\t\tmemcpy(sam->addr, &xs->id.daddr.a6, sizeof(xs->id.daddr.a6));\n\telse\n\t\tmemcpy(sam->addr, &xs->id.daddr.a4, sizeof(xs->id.daddr.a4));\n\tmemcpy(sam->key, xs->aead->alg_key, sizeof(sam->key));\n\n\tmsgbuf[0] = IXGBE_VF_IPSEC_ADD;\n\n\tspin_lock_bh(&adapter->mbx_lock);\n\n\tret = ixgbevf_write_mbx(hw, msgbuf, IXGBE_VFMAILBOX_SIZE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ixgbevf_poll_mbx(hw, msgbuf, 2);\n\tif (ret)\n\t\tgoto out;\n\n\tret = (int)msgbuf[1];\n\tif (msgbuf[0] & IXGBE_VT_MSGTYPE_FAILURE && ret >= 0)\n\t\tret = -1;\n\nout:\n\tspin_unlock_bh(&adapter->mbx_lock);\n\n\treturn ret;\n}\n\n \nstatic int ixgbevf_ipsec_del_pf_sa(struct ixgbevf_adapter *adapter, int pfsa)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 msgbuf[2];\n\tint err;\n\n\tmemset(msgbuf, 0, sizeof(msgbuf));\n\tmsgbuf[0] = IXGBE_VF_IPSEC_DEL;\n\tmsgbuf[1] = (u32)pfsa;\n\n\tspin_lock_bh(&adapter->mbx_lock);\n\n\terr = ixgbevf_write_mbx(hw, msgbuf, 2);\n\tif (err)\n\t\tgoto out;\n\n\terr = ixgbevf_poll_mbx(hw, msgbuf, 2);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tspin_unlock_bh(&adapter->mbx_lock);\n\treturn err;\n}\n\n \nvoid ixgbevf_ipsec_restore(struct ixgbevf_adapter *adapter)\n{\n\tstruct ixgbevf_ipsec *ipsec = adapter->ipsec;\n\tstruct net_device *netdev = adapter->netdev;\n\tint i;\n\n\tif (!(adapter->netdev->features & NETIF_F_HW_ESP))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT; i++) {\n\t\tstruct rx_sa *r = &ipsec->rx_tbl[i];\n\t\tstruct tx_sa *t = &ipsec->tx_tbl[i];\n\t\tint ret;\n\n\t\tif (r->used) {\n\t\t\tret = ixgbevf_ipsec_set_pf_sa(adapter, r->xs);\n\t\t\tif (ret < 0)\n\t\t\t\tnetdev_err(netdev, \"reload rx_tbl[%d] failed = %d\\n\",\n\t\t\t\t\t   i, ret);\n\t\t}\n\n\t\tif (t->used) {\n\t\t\tret = ixgbevf_ipsec_set_pf_sa(adapter, t->xs);\n\t\t\tif (ret < 0)\n\t\t\t\tnetdev_err(netdev, \"reload tx_tbl[%d] failed = %d\\n\",\n\t\t\t\t\t   i, ret);\n\t\t}\n\t}\n}\n\n \nstatic\nint ixgbevf_ipsec_find_empty_idx(struct ixgbevf_ipsec *ipsec, bool rxtable)\n{\n\tu32 i;\n\n\tif (rxtable) {\n\t\tif (ipsec->num_rx_sa == IXGBE_IPSEC_MAX_SA_COUNT)\n\t\t\treturn -ENOSPC;\n\n\t\t \n\t\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT; i++) {\n\t\t\tif (!ipsec->rx_tbl[i].used)\n\t\t\t\treturn i;\n\t\t}\n\t} else {\n\t\tif (ipsec->num_tx_sa == IXGBE_IPSEC_MAX_SA_COUNT)\n\t\t\treturn -ENOSPC;\n\n\t\t \n\t\tfor (i = 0; i < IXGBE_IPSEC_MAX_SA_COUNT; i++) {\n\t\t\tif (!ipsec->tx_tbl[i].used)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -ENOSPC;\n}\n\n \nstatic\nstruct xfrm_state *ixgbevf_ipsec_find_rx_state(struct ixgbevf_ipsec *ipsec,\n\t\t\t\t\t       __be32 *daddr, u8 proto,\n\t\t\t\t\t       __be32 spi, bool ip4)\n{\n\tstruct xfrm_state *ret = NULL;\n\tstruct rx_sa *rsa;\n\n\trcu_read_lock();\n\thash_for_each_possible_rcu(ipsec->rx_sa_list, rsa, hlist,\n\t\t\t\t   (__force u32)spi) {\n\t\tif (spi == rsa->xs->id.spi &&\n\t\t    ((ip4 && *daddr == rsa->xs->id.daddr.a4) ||\n\t\t      (!ip4 && !memcmp(daddr, &rsa->xs->id.daddr.a6,\n\t\t\t\t       sizeof(rsa->xs->id.daddr.a6)))) &&\n\t\t    proto == rsa->xs->id.proto) {\n\t\t\tret = rsa->xs;\n\t\t\txfrm_state_hold(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int ixgbevf_ipsec_parse_proto_keys(struct xfrm_state *xs,\n\t\t\t\t\t  u32 *mykey, u32 *mysalt)\n{\n\tstruct net_device *dev = xs->xso.real_dev;\n\tunsigned char *key_data;\n\tchar *alg_name = NULL;\n\tint key_len;\n\n\tif (!xs->aead) {\n\t\tnetdev_err(dev, \"Unsupported IPsec algorithm\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->aead->alg_icv_len != IXGBE_IPSEC_AUTH_BITS) {\n\t\tnetdev_err(dev, \"IPsec offload requires %d bit authentication\\n\",\n\t\t\t   IXGBE_IPSEC_AUTH_BITS);\n\t\treturn -EINVAL;\n\t}\n\n\tkey_data = &xs->aead->alg_key[0];\n\tkey_len = xs->aead->alg_key_len;\n\talg_name = xs->aead->alg_name;\n\n\tif (strcmp(alg_name, aes_gcm_name)) {\n\t\tnetdev_err(dev, \"Unsupported IPsec algorithm - please use %s\\n\",\n\t\t\t   aes_gcm_name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (key_len > IXGBE_IPSEC_KEY_BITS) {\n\t\t*mysalt = ((u32 *)key_data)[4];\n\t} else if (key_len == IXGBE_IPSEC_KEY_BITS) {\n\t\t*mysalt = 0;\n\t} else {\n\t\tnetdev_err(dev, \"IPsec hw offload only supports keys up to 128 bits with a 32 bit salt\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(mykey, key_data, 16);\n\n\treturn 0;\n}\n\n \nstatic int ixgbevf_ipsec_add_sa(struct xfrm_state *xs,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = xs->xso.real_dev;\n\tstruct ixgbevf_adapter *adapter;\n\tstruct ixgbevf_ipsec *ipsec;\n\tu16 sa_idx;\n\tint ret;\n\n\tadapter = netdev_priv(dev);\n\tipsec = adapter->ipsec;\n\n\tif (xs->id.proto != IPPROTO_ESP && xs->id.proto != IPPROTO_AH) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported protocol for IPsec offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->props.mode != XFRM_MODE_TRANSPORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported mode for ipsec offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->xso.type != XFRM_DEV_OFFLOAD_CRYPTO) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported ipsec offload type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->xso.dir == XFRM_DEV_OFFLOAD_IN) {\n\t\tstruct rx_sa rsa;\n\n\t\tif (xs->calg) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Compression offload not supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = ixgbevf_ipsec_find_empty_idx(ipsec, true);\n\t\tif (ret < 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No space for SA in Rx table!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsa_idx = (u16)ret;\n\n\t\tmemset(&rsa, 0, sizeof(rsa));\n\t\trsa.used = true;\n\t\trsa.xs = xs;\n\n\t\tif (rsa.xs->id.proto & IPPROTO_ESP)\n\t\t\trsa.decrypt = xs->ealg || xs->aead;\n\n\t\t \n\t\tret = ixgbevf_ipsec_parse_proto_keys(xs, rsa.key, &rsa.salt);\n\t\tif (ret) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get key data for Rx SA table\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (xs->props.family == AF_INET6)\n\t\t\tmemcpy(rsa.ipaddr, &xs->id.daddr.a6, 16);\n\t\telse\n\t\t\tmemcpy(&rsa.ipaddr[3], &xs->id.daddr.a4, 4);\n\n\t\trsa.mode = IXGBE_RXMOD_VALID;\n\t\tif (rsa.xs->id.proto & IPPROTO_ESP)\n\t\t\trsa.mode |= IXGBE_RXMOD_PROTO_ESP;\n\t\tif (rsa.decrypt)\n\t\t\trsa.mode |= IXGBE_RXMOD_DECRYPT;\n\t\tif (rsa.xs->props.family == AF_INET6)\n\t\t\trsa.mode |= IXGBE_RXMOD_IPV6;\n\n\t\tret = ixgbevf_ipsec_set_pf_sa(adapter, xs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trsa.pfsa = ret;\n\n\t\t \n\t\tmemcpy(&ipsec->rx_tbl[sa_idx], &rsa, sizeof(rsa));\n\n\t\txs->xso.offload_handle = sa_idx + IXGBE_IPSEC_BASE_RX_INDEX;\n\n\t\tipsec->num_rx_sa++;\n\n\t\t \n\t\thash_add_rcu(ipsec->rx_sa_list, &ipsec->rx_tbl[sa_idx].hlist,\n\t\t\t     (__force u32)rsa.xs->id.spi);\n\t} else {\n\t\tstruct tx_sa tsa;\n\n\t\t \n\t\tret = ixgbevf_ipsec_find_empty_idx(ipsec, false);\n\t\tif (ret < 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No space for SA in Tx table\");\n\t\t\treturn ret;\n\t\t}\n\t\tsa_idx = (u16)ret;\n\n\t\tmemset(&tsa, 0, sizeof(tsa));\n\t\ttsa.used = true;\n\t\ttsa.xs = xs;\n\n\t\tif (xs->id.proto & IPPROTO_ESP)\n\t\t\ttsa.encrypt = xs->ealg || xs->aead;\n\n\t\tret = ixgbevf_ipsec_parse_proto_keys(xs, tsa.key, &tsa.salt);\n\t\tif (ret) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get key data for Tx SA table\");\n\t\t\tmemset(&tsa, 0, sizeof(tsa));\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ixgbevf_ipsec_set_pf_sa(adapter, xs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttsa.pfsa = ret;\n\n\t\t \n\t\tmemcpy(&ipsec->tx_tbl[sa_idx], &tsa, sizeof(tsa));\n\n\t\txs->xso.offload_handle = sa_idx + IXGBE_IPSEC_BASE_TX_INDEX;\n\n\t\tipsec->num_tx_sa++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ixgbevf_ipsec_del_sa(struct xfrm_state *xs)\n{\n\tstruct net_device *dev = xs->xso.real_dev;\n\tstruct ixgbevf_adapter *adapter;\n\tstruct ixgbevf_ipsec *ipsec;\n\tu16 sa_idx;\n\n\tadapter = netdev_priv(dev);\n\tipsec = adapter->ipsec;\n\n\tif (xs->xso.dir == XFRM_DEV_OFFLOAD_IN) {\n\t\tsa_idx = xs->xso.offload_handle - IXGBE_IPSEC_BASE_RX_INDEX;\n\n\t\tif (!ipsec->rx_tbl[sa_idx].used) {\n\t\t\tnetdev_err(dev, \"Invalid Rx SA selected sa_idx=%d offload_handle=%lu\\n\",\n\t\t\t\t   sa_idx, xs->xso.offload_handle);\n\t\t\treturn;\n\t\t}\n\n\t\tixgbevf_ipsec_del_pf_sa(adapter, ipsec->rx_tbl[sa_idx].pfsa);\n\t\thash_del_rcu(&ipsec->rx_tbl[sa_idx].hlist);\n\t\tmemset(&ipsec->rx_tbl[sa_idx], 0, sizeof(struct rx_sa));\n\t\tipsec->num_rx_sa--;\n\t} else {\n\t\tsa_idx = xs->xso.offload_handle - IXGBE_IPSEC_BASE_TX_INDEX;\n\n\t\tif (!ipsec->tx_tbl[sa_idx].used) {\n\t\t\tnetdev_err(dev, \"Invalid Tx SA selected sa_idx=%d offload_handle=%lu\\n\",\n\t\t\t\t   sa_idx, xs->xso.offload_handle);\n\t\t\treturn;\n\t\t}\n\n\t\tixgbevf_ipsec_del_pf_sa(adapter, ipsec->tx_tbl[sa_idx].pfsa);\n\t\tmemset(&ipsec->tx_tbl[sa_idx], 0, sizeof(struct tx_sa));\n\t\tipsec->num_tx_sa--;\n\t}\n}\n\n \nstatic bool ixgbevf_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *xs)\n{\n\tif (xs->props.family == AF_INET) {\n\t\t \n\t\tif (ip_hdr(skb)->ihl != 5)\n\t\t\treturn false;\n\t} else {\n\t\t \n\t\tif (ipv6_ext_hdr(ipv6_hdr(skb)->nexthdr))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const struct xfrmdev_ops ixgbevf_xfrmdev_ops = {\n\t.xdo_dev_state_add = ixgbevf_ipsec_add_sa,\n\t.xdo_dev_state_delete = ixgbevf_ipsec_del_sa,\n\t.xdo_dev_offload_ok = ixgbevf_ipsec_offload_ok,\n};\n\n \nint ixgbevf_ipsec_tx(struct ixgbevf_ring *tx_ring,\n\t\t     struct ixgbevf_tx_buffer *first,\n\t\t     struct ixgbevf_ipsec_tx_data *itd)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(tx_ring->netdev);\n\tstruct ixgbevf_ipsec *ipsec = adapter->ipsec;\n\tstruct xfrm_state *xs;\n\tstruct sec_path *sp;\n\tstruct tx_sa *tsa;\n\tu16 sa_idx;\n\n\tsp = skb_sec_path(first->skb);\n\tif (unlikely(!sp->len)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: no xfrm state len = %d\\n\",\n\t\t\t   __func__, sp->len);\n\t\treturn 0;\n\t}\n\n\txs = xfrm_input_state(first->skb);\n\tif (unlikely(!xs)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: no xfrm_input_state() xs = %p\\n\",\n\t\t\t   __func__, xs);\n\t\treturn 0;\n\t}\n\n\tsa_idx = xs->xso.offload_handle - IXGBE_IPSEC_BASE_TX_INDEX;\n\tif (unlikely(sa_idx >= IXGBE_IPSEC_MAX_SA_COUNT)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: bad sa_idx=%d handle=%lu\\n\",\n\t\t\t   __func__, sa_idx, xs->xso.offload_handle);\n\t\treturn 0;\n\t}\n\n\ttsa = &ipsec->tx_tbl[sa_idx];\n\tif (unlikely(!tsa->used)) {\n\t\tnetdev_err(tx_ring->netdev, \"%s: unused sa_idx=%d\\n\",\n\t\t\t   __func__, sa_idx);\n\t\treturn 0;\n\t}\n\n\titd->pfsa = tsa->pfsa - IXGBE_IPSEC_BASE_TX_INDEX;\n\n\tfirst->tx_flags |= IXGBE_TX_FLAGS_IPSEC | IXGBE_TX_FLAGS_CSUM;\n\n\tif (xs->id.proto == IPPROTO_ESP) {\n\t\titd->flags |= IXGBE_ADVTXD_TUCMD_IPSEC_TYPE_ESP |\n\t\t\t      IXGBE_ADVTXD_TUCMD_L4T_TCP;\n\t\tif (first->protocol == htons(ETH_P_IP))\n\t\t\titd->flags |= IXGBE_ADVTXD_TUCMD_IPV4;\n\n\t\t \n\t\tif (!skb_is_gso(first->skb)) {\n\t\t\t \n\t\t\tconst int authlen = IXGBE_IPSEC_AUTH_BITS / 8;\n\t\t\tstruct sk_buff *skb = first->skb;\n\t\t\tu8 padlen;\n\t\t\tint ret;\n\n\t\t\tret = skb_copy_bits(skb, skb->len - (authlen + 2),\n\t\t\t\t\t    &padlen, 1);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn 0;\n\t\t\titd->trailer_len = authlen + 2 + padlen;\n\t\t}\n\t}\n\tif (tsa->encrypt)\n\t\titd->flags |= IXGBE_ADVTXD_TUCMD_IPSEC_ENCRYPT_EN;\n\n\treturn 1;\n}\n\n \nvoid ixgbevf_ipsec_rx(struct ixgbevf_ring *rx_ring,\n\t\t      union ixgbe_adv_rx_desc *rx_desc,\n\t\t      struct sk_buff *skb)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(rx_ring->netdev);\n\t__le16 pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;\n\t__le16 ipsec_pkt_types = cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPSEC_AH |\n\t\t\t\t\t     IXGBE_RXDADV_PKTTYPE_IPSEC_ESP);\n\tstruct ixgbevf_ipsec *ipsec = adapter->ipsec;\n\tstruct xfrm_offload *xo = NULL;\n\tstruct xfrm_state *xs = NULL;\n\tstruct ipv6hdr *ip6 = NULL;\n\tstruct iphdr *ip4 = NULL;\n\tstruct sec_path *sp;\n\tvoid *daddr;\n\t__be32 spi;\n\tu8 *c_hdr;\n\tu8 proto;\n\n\t \n\tif (pkt_info & cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPV4)) {\n\t\tip4 = (struct iphdr *)(skb->data + ETH_HLEN);\n\t\tdaddr = &ip4->daddr;\n\t\tc_hdr = (u8 *)ip4 + ip4->ihl * 4;\n\t} else if (pkt_info & cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPV6)) {\n\t\tip6 = (struct ipv6hdr *)(skb->data + ETH_HLEN);\n\t\tdaddr = &ip6->daddr;\n\t\tc_hdr = (u8 *)ip6 + sizeof(struct ipv6hdr);\n\t} else {\n\t\treturn;\n\t}\n\n\tswitch (pkt_info & ipsec_pkt_types) {\n\tcase cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPSEC_AH):\n\t\tspi = ((struct ip_auth_hdr *)c_hdr)->spi;\n\t\tproto = IPPROTO_AH;\n\t\tbreak;\n\tcase cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPSEC_ESP):\n\t\tspi = ((struct ip_esp_hdr *)c_hdr)->spi;\n\t\tproto = IPPROTO_ESP;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\txs = ixgbevf_ipsec_find_rx_state(ipsec, daddr, proto, spi, !!ip4);\n\tif (unlikely(!xs))\n\t\treturn;\n\n\tsp = secpath_set(skb);\n\tif (unlikely(!sp))\n\t\treturn;\n\n\tsp->xvec[sp->len++] = xs;\n\tsp->olen++;\n\txo = xfrm_offload(skb);\n\txo->flags = CRYPTO_DONE;\n\txo->status = CRYPTO_SUCCESS;\n\n\tadapter->rx_ipsec++;\n}\n\n \nvoid ixgbevf_init_ipsec_offload(struct ixgbevf_adapter *adapter)\n{\n\tstruct ixgbevf_ipsec *ipsec;\n\tsize_t size;\n\n\tswitch (adapter->hw.api_version) {\n\tcase ixgbe_mbox_api_14:\n\tcase ixgbe_mbox_api_15:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tipsec = kzalloc(sizeof(*ipsec), GFP_KERNEL);\n\tif (!ipsec)\n\t\tgoto err1;\n\thash_init(ipsec->rx_sa_list);\n\n\tsize = sizeof(struct rx_sa) * IXGBE_IPSEC_MAX_SA_COUNT;\n\tipsec->rx_tbl = kzalloc(size, GFP_KERNEL);\n\tif (!ipsec->rx_tbl)\n\t\tgoto err2;\n\n\tsize = sizeof(struct tx_sa) * IXGBE_IPSEC_MAX_SA_COUNT;\n\tipsec->tx_tbl = kzalloc(size, GFP_KERNEL);\n\tif (!ipsec->tx_tbl)\n\t\tgoto err2;\n\n\tipsec->num_rx_sa = 0;\n\tipsec->num_tx_sa = 0;\n\n\tadapter->ipsec = ipsec;\n\n\tadapter->netdev->xfrmdev_ops = &ixgbevf_xfrmdev_ops;\n\n#define IXGBEVF_ESP_FEATURES\t(NETIF_F_HW_ESP | \\\n\t\t\t\t NETIF_F_HW_ESP_TX_CSUM | \\\n\t\t\t\t NETIF_F_GSO_ESP)\n\n\tadapter->netdev->features |= IXGBEVF_ESP_FEATURES;\n\tadapter->netdev->hw_enc_features |= IXGBEVF_ESP_FEATURES;\n\n\treturn;\n\nerr2:\n\tkfree(ipsec->rx_tbl);\n\tkfree(ipsec->tx_tbl);\n\tkfree(ipsec);\nerr1:\n\tnetdev_err(adapter->netdev, \"Unable to allocate memory for SA tables\");\n}\n\n \nvoid ixgbevf_stop_ipsec_offload(struct ixgbevf_adapter *adapter)\n{\n\tstruct ixgbevf_ipsec *ipsec = adapter->ipsec;\n\n\tadapter->ipsec = NULL;\n\tif (ipsec) {\n\t\tkfree(ipsec->rx_tbl);\n\t\tkfree(ipsec->tx_tbl);\n\t\tkfree(ipsec);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}