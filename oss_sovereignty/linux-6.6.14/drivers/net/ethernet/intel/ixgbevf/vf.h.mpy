{
  "module_name": "vf.h",
  "hash_id": "ea2756fdc5eb7066c0d43f6b183d6eeb203abfbb4f50df7d8cc67ae1a807d60b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbevf/vf.h",
  "human_readable_source": " \n \n\n#ifndef __IXGBE_VF_H__\n#define __IXGBE_VF_H__\n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n\n#include \"defines.h\"\n#include \"regs.h\"\n#include \"mbx.h\"\n\nstruct ixgbe_hw;\n\nstruct ixgbe_mac_operations {\n\ts32 (*init_hw)(struct ixgbe_hw *);\n\ts32 (*reset_hw)(struct ixgbe_hw *);\n\ts32 (*start_hw)(struct ixgbe_hw *);\n\ts32 (*clear_hw_cntrs)(struct ixgbe_hw *);\n\tenum ixgbe_media_type (*get_media_type)(struct ixgbe_hw *);\n\ts32 (*get_mac_addr)(struct ixgbe_hw *, u8 *);\n\ts32 (*stop_adapter)(struct ixgbe_hw *);\n\ts32 (*get_bus_info)(struct ixgbe_hw *);\n\ts32 (*negotiate_api_version)(struct ixgbe_hw *hw, int api);\n\n\t \n\ts32 (*setup_link)(struct ixgbe_hw *, ixgbe_link_speed, bool, bool);\n\ts32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool);\n\ts32 (*get_link_capabilities)(struct ixgbe_hw *, ixgbe_link_speed *,\n\t\t\t\t     bool *);\n\n\t \n\ts32 (*set_rar)(struct ixgbe_hw *, u32, u8 *, u32);\n\ts32 (*set_uc_addr)(struct ixgbe_hw *, u32, u8 *);\n\ts32 (*init_rx_addrs)(struct ixgbe_hw *);\n\ts32 (*update_mc_addr_list)(struct ixgbe_hw *, struct net_device *);\n\ts32 (*update_xcast_mode)(struct ixgbe_hw *, int);\n\ts32 (*get_link_state)(struct ixgbe_hw *hw, bool *link_state);\n\ts32 (*enable_mc)(struct ixgbe_hw *);\n\ts32 (*disable_mc)(struct ixgbe_hw *);\n\ts32 (*clear_vfta)(struct ixgbe_hw *);\n\ts32 (*set_vfta)(struct ixgbe_hw *, u32, u32, bool);\n\ts32 (*set_rlpml)(struct ixgbe_hw *, u16);\n};\n\nenum ixgbe_mac_type {\n\tixgbe_mac_unknown = 0,\n\tixgbe_mac_82599_vf,\n\tixgbe_mac_X540_vf,\n\tixgbe_mac_X550_vf,\n\tixgbe_mac_X550EM_x_vf,\n\tixgbe_mac_x550em_a_vf,\n\tixgbe_num_macs\n};\n\nstruct ixgbe_mac_info {\n\tstruct ixgbe_mac_operations ops;\n\tu8 addr[6];\n\tu8 perm_addr[6];\n\n\tenum ixgbe_mac_type type;\n\n\ts32  mc_filter_type;\n\n\tbool get_link_status;\n\tu32  max_tx_queues;\n\tu32  max_rx_queues;\n\tu32  max_msix_vectors;\n};\n\nstruct ixgbe_mbx_operations {\n\ts32 (*init_params)(struct ixgbe_hw *hw);\n\tvoid (*release)(struct ixgbe_hw *hw);\n\ts32 (*read)(struct ixgbe_hw *, u32 *, u16);\n\ts32 (*write)(struct ixgbe_hw *, u32 *, u16);\n\ts32 (*check_for_msg)(struct ixgbe_hw *);\n\ts32 (*check_for_ack)(struct ixgbe_hw *);\n\ts32 (*check_for_rst)(struct ixgbe_hw *);\n};\n\nstruct ixgbe_mbx_stats {\n\tu32 msgs_tx;\n\tu32 msgs_rx;\n\n\tu32 acks;\n\tu32 reqs;\n\tu32 rsts;\n};\n\nstruct ixgbe_mbx_info {\n\tstruct ixgbe_mbx_operations ops;\n\tstruct ixgbe_mbx_stats stats;\n\tu32 timeout;\n\tu32 udelay;\n\tu32 vf_mailbox;\n\tu16 size;\n};\n\nstruct ixgbe_hw {\n\tvoid *back;\n\n\tu8 __iomem *hw_addr;\n\n\tstruct ixgbe_mac_info mac;\n\tstruct ixgbe_mbx_info mbx;\n\n\tu16 device_id;\n\tu16 subsystem_vendor_id;\n\tu16 subsystem_device_id;\n\tu16 vendor_id;\n\n\tu8  revision_id;\n\tbool adapter_stopped;\n\n\tint api_version;\n};\n\nstruct ixgbevf_hw_stats {\n\tu64 base_vfgprc;\n\tu64 base_vfgptc;\n\tu64 base_vfgorc;\n\tu64 base_vfgotc;\n\tu64 base_vfmprc;\n\n\tu64 last_vfgprc;\n\tu64 last_vfgptc;\n\tu64 last_vfgorc;\n\tu64 last_vfgotc;\n\tu64 last_vfmprc;\n\n\tu64 vfgprc;\n\tu64 vfgptc;\n\tu64 vfgorc;\n\tu64 vfgotc;\n\tu64 vfmprc;\n\n\tu64 saved_reset_vfgprc;\n\tu64 saved_reset_vfgptc;\n\tu64 saved_reset_vfgorc;\n\tu64 saved_reset_vfgotc;\n\tu64 saved_reset_vfmprc;\n};\n\nstruct ixgbevf_info {\n\tenum ixgbe_mac_type mac;\n\tconst struct ixgbe_mac_operations *mac_ops;\n};\n\n#define IXGBE_FAILED_READ_REG 0xffffffffU\n\n#define IXGBE_REMOVED(a) unlikely(!(a))\n\nstatic inline void ixgbe_write_reg(struct ixgbe_hw *hw, u32 reg, u32 value)\n{\n\tu8 __iomem *reg_addr = READ_ONCE(hw->hw_addr);\n\n\tif (IXGBE_REMOVED(reg_addr))\n\t\treturn;\n\twritel(value, reg_addr + reg);\n}\n\n#define IXGBE_WRITE_REG(h, r, v) ixgbe_write_reg(h, r, v)\n\nu32 ixgbevf_read_reg(struct ixgbe_hw *hw, u32 reg);\n#define IXGBE_READ_REG(h, r) ixgbevf_read_reg(h, r)\n\nstatic inline void ixgbe_write_reg_array(struct ixgbe_hw *hw, u32 reg,\n\t\t\t\t\t u32 offset, u32 value)\n{\n\tixgbe_write_reg(hw, reg + (offset << 2), value);\n}\n\n#define IXGBE_WRITE_REG_ARRAY(h, r, o, v) ixgbe_write_reg_array(h, r, o, v)\n\nstatic inline u32 ixgbe_read_reg_array(struct ixgbe_hw *hw, u32 reg,\n\t\t\t\t       u32 offset)\n{\n\treturn ixgbevf_read_reg(hw, reg + (offset << 2));\n}\n\n#define IXGBE_READ_REG_ARRAY(h, r, o) ixgbe_read_reg_array(h, r, o)\n\nint ixgbevf_get_queues(struct ixgbe_hw *hw, unsigned int *num_tcs,\n\t\t       unsigned int *default_tc);\nint ixgbevf_get_reta_locked(struct ixgbe_hw *hw, u32 *reta, int num_rx_queues);\nint ixgbevf_get_rss_key_locked(struct ixgbe_hw *hw, u8 *rss_key);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}