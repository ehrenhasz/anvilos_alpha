{
  "module_name": "mbx.c",
  "hash_id": "00f2f48a5793ab773a7a810f09252e53b4114263c176ee2dd3263517645c846d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbevf/mbx.c",
  "human_readable_source": "\n \n\n#include \"mbx.h\"\n#include \"ixgbevf.h\"\n\n \nstatic s32 ixgbevf_poll_for_msg(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!countdown || !mbx->ops.check_for_msg)\n\t\treturn IXGBE_ERR_CONFIG;\n\n\twhile (countdown && mbx->ops.check_for_msg(hw)) {\n\t\tcountdown--;\n\t\tudelay(mbx->udelay);\n\t}\n\n\treturn countdown ? 0 : IXGBE_ERR_TIMEOUT;\n}\n\n \nstatic s32 ixgbevf_poll_for_ack(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!countdown || !mbx->ops.check_for_ack)\n\t\treturn IXGBE_ERR_CONFIG;\n\n\twhile (countdown && mbx->ops.check_for_ack(hw)) {\n\t\tcountdown--;\n\t\tudelay(mbx->udelay);\n\t}\n\n\treturn countdown ? 0 : IXGBE_ERR_TIMEOUT;\n}\n\n \nstatic u32 ixgbevf_read_mailbox_vf(struct ixgbe_hw *hw)\n{\n\tu32 vf_mailbox = IXGBE_READ_REG(hw, IXGBE_VFMAILBOX);\n\n\tvf_mailbox |= hw->mbx.vf_mailbox;\n\thw->mbx.vf_mailbox |= vf_mailbox & IXGBE_VFMAILBOX_R2C_BITS;\n\n\treturn vf_mailbox;\n}\n\n \nstatic void ixgbevf_clear_msg_vf(struct ixgbe_hw *hw)\n{\n\tu32 vf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\n\tif (vf_mailbox & IXGBE_VFMAILBOX_PFSTS) {\n\t\thw->mbx.stats.reqs++;\n\t\thw->mbx.vf_mailbox &= ~IXGBE_VFMAILBOX_PFSTS;\n\t}\n}\n\n \nstatic void ixgbevf_clear_ack_vf(struct ixgbe_hw *hw)\n{\n\tu32 vf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\n\tif (vf_mailbox & IXGBE_VFMAILBOX_PFACK) {\n\t\thw->mbx.stats.acks++;\n\t\thw->mbx.vf_mailbox &= ~IXGBE_VFMAILBOX_PFACK;\n\t}\n}\n\n \nstatic void ixgbevf_clear_rst_vf(struct ixgbe_hw *hw)\n{\n\tu32 vf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\n\tif (vf_mailbox & (IXGBE_VFMAILBOX_RSTI | IXGBE_VFMAILBOX_RSTD)) {\n\t\thw->mbx.stats.rsts++;\n\t\thw->mbx.vf_mailbox &= ~(IXGBE_VFMAILBOX_RSTI |\n\t\t\t\t\tIXGBE_VFMAILBOX_RSTD);\n\t}\n}\n\n \nstatic s32 ixgbevf_check_for_bit_vf(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 vf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\ts32 ret_val = IXGBE_ERR_MBX;\n\n\tif (vf_mailbox & mask)\n\t\tret_val = 0;\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_check_for_msg_vf(struct ixgbe_hw *hw)\n{\n\ts32 ret_val = IXGBE_ERR_MBX;\n\n\tif (!ixgbevf_check_for_bit_vf(hw, IXGBE_VFMAILBOX_PFSTS)) {\n\t\tret_val = 0;\n\t\thw->mbx.stats.reqs++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_check_for_ack_vf(struct ixgbe_hw *hw)\n{\n\ts32 ret_val = IXGBE_ERR_MBX;\n\n\tif (!ixgbevf_check_for_bit_vf(hw, IXGBE_VFMAILBOX_PFACK)) {\n\t\tret_val = 0;\n\t\tixgbevf_clear_ack_vf(hw);\n\t\thw->mbx.stats.acks++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_check_for_rst_vf(struct ixgbe_hw *hw)\n{\n\ts32 ret_val = IXGBE_ERR_MBX;\n\n\tif (!ixgbevf_check_for_bit_vf(hw, (IXGBE_VFMAILBOX_RSTD |\n\t\t\t\t\t   IXGBE_VFMAILBOX_RSTI))) {\n\t\tret_val = 0;\n\t\tixgbevf_clear_rst_vf(hw);\n\t\thw->mbx.stats.rsts++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_obtain_mbx_lock_vf(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = IXGBE_ERR_CONFIG;\n\tint countdown = mbx->timeout;\n\tu32 vf_mailbox;\n\n\tif (!mbx->timeout)\n\t\treturn ret_val;\n\n\twhile (countdown--) {\n\t\t \n\t\tvf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\t\tvf_mailbox |= IXGBE_VFMAILBOX_VFU;\n\t\tIXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);\n\n\t\t \n\t\tif (ixgbevf_read_mailbox_vf(hw) & IXGBE_VFMAILBOX_VFU) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tudelay(mbx->udelay);\n\t}\n\n\tif (ret_val)\n\t\tret_val = IXGBE_ERR_TIMEOUT;\n\n\treturn ret_val;\n}\n\n \nstatic void ixgbevf_release_mbx_lock_vf(struct ixgbe_hw *hw)\n{\n\tu32 vf_mailbox;\n\n\t \n\tvf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\tvf_mailbox &= ~IXGBE_VFMAILBOX_VFU;\n\tIXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);\n}\n\n \nstatic void ixgbevf_release_mbx_lock_vf_legacy(struct ixgbe_hw *__always_unused hw)\n{\n}\n\n \nstatic s32 ixgbevf_write_mbx_vf(struct ixgbe_hw *hw, u32 *msg, u16 size)\n{\n\tu32 vf_mailbox;\n\ts32 ret_val;\n\tu16 i;\n\n\t \n\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);\n\tif (ret_val)\n\t\tgoto out_no_write;\n\n\t \n\tixgbevf_clear_msg_vf(hw);\n\tixgbevf_clear_ack_vf(hw);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tIXGBE_WRITE_REG_ARRAY(hw, IXGBE_VFMBMEM, i, msg[i]);\n\n\t \n\thw->mbx.stats.msgs_tx++;\n\n\t \n\tvf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\tvf_mailbox |= IXGBE_VFMAILBOX_REQ;\n\tIXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);\n\n\t \n\tret_val = ixgbevf_poll_for_ack(hw);\n\nout_no_write:\n\thw->mbx.ops.release(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_write_mbx_vf_legacy(struct ixgbe_hw *hw, u32 *msg, u16 size)\n{\n\ts32 ret_val;\n\tu16 i;\n\n\t \n\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);\n\tif (ret_val)\n\t\tgoto out_no_write;\n\n\t \n\tixgbevf_check_for_msg_vf(hw);\n\tixgbevf_clear_msg_vf(hw);\n\tixgbevf_check_for_ack_vf(hw);\n\tixgbevf_clear_ack_vf(hw);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tIXGBE_WRITE_REG_ARRAY(hw, IXGBE_VFMBMEM, i, msg[i]);\n\n\t \n\thw->mbx.stats.msgs_tx++;\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, IXGBE_VFMAILBOX_REQ);\n\nout_no_write:\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_read_mbx_vf(struct ixgbe_hw *hw, u32 *msg, u16 size)\n{\n\tu32 vf_mailbox;\n\ts32 ret_val;\n\tu16 i;\n\n\t \n\tret_val = ixgbevf_check_for_msg_vf(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tixgbevf_clear_msg_vf(hw);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tmsg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_VFMBMEM, i);\n\n\t \n\tvf_mailbox = ixgbevf_read_mailbox_vf(hw);\n\tvf_mailbox |= IXGBE_VFMAILBOX_ACK;\n\tIXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);\n\n\t \n\thw->mbx.stats.msgs_rx++;\n\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_read_mbx_vf_legacy(struct ixgbe_hw *hw, u32 *msg, u16 size)\n{\n\ts32 ret_val = 0;\n\tu16 i;\n\n\t \n\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);\n\tif (ret_val)\n\t\tgoto out_no_read;\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tmsg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_VFMBMEM, i);\n\n\t \n\tIXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, IXGBE_VFMAILBOX_ACK);\n\n\t \n\thw->mbx.stats.msgs_rx++;\n\nout_no_read:\n\treturn ret_val;\n}\n\n \nstatic s32 ixgbevf_init_mbx_params_vf(struct ixgbe_hw *hw)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\n\t \n\tmbx->timeout = IXGBE_VF_MBX_INIT_TIMEOUT;\n\tmbx->udelay = IXGBE_VF_MBX_INIT_DELAY;\n\n\tmbx->size = IXGBE_VFMAILBOX_SIZE;\n\n\tmbx->stats.msgs_tx = 0;\n\tmbx->stats.msgs_rx = 0;\n\tmbx->stats.reqs = 0;\n\tmbx->stats.acks = 0;\n\tmbx->stats.rsts = 0;\n\n\treturn 0;\n}\n\n \ns32 ixgbevf_poll_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = IXGBE_ERR_CONFIG;\n\n\tif (!mbx->ops.read || !mbx->ops.check_for_msg || !mbx->timeout)\n\t\treturn ret_val;\n\n\t \n\tif (size > mbx->size)\n\t\tsize = mbx->size;\n\n\tret_val = ixgbevf_poll_for_msg(hw);\n\t \n\tif (!ret_val)\n\t\tret_val = mbx->ops.read(hw, msg, size);\n\n\treturn ret_val;\n}\n\n \ns32 ixgbevf_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size)\n{\n\tstruct ixgbe_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = IXGBE_ERR_CONFIG;\n\n\t \n\tif (!mbx->ops.write || !mbx->ops.check_for_ack || !mbx->ops.release ||\n\t    !mbx->timeout)\n\t\treturn ret_val;\n\n\tif (size > mbx->size)\n\t\tret_val = IXGBE_ERR_PARAM;\n\telse\n\t\tret_val = mbx->ops.write(hw, msg, size);\n\n\treturn ret_val;\n}\n\nconst struct ixgbe_mbx_operations ixgbevf_mbx_ops = {\n\t.init_params\t= ixgbevf_init_mbx_params_vf,\n\t.release\t= ixgbevf_release_mbx_lock_vf,\n\t.read\t\t= ixgbevf_read_mbx_vf,\n\t.write\t\t= ixgbevf_write_mbx_vf,\n\t.check_for_msg\t= ixgbevf_check_for_msg_vf,\n\t.check_for_ack\t= ixgbevf_check_for_ack_vf,\n\t.check_for_rst\t= ixgbevf_check_for_rst_vf,\n};\n\nconst struct ixgbe_mbx_operations ixgbevf_mbx_ops_legacy = {\n\t.init_params\t= ixgbevf_init_mbx_params_vf,\n\t.release\t= ixgbevf_release_mbx_lock_vf_legacy,\n\t.read\t\t= ixgbevf_read_mbx_vf_legacy,\n\t.write\t\t= ixgbevf_write_mbx_vf_legacy,\n\t.check_for_msg\t= ixgbevf_check_for_msg_vf,\n\t.check_for_ack\t= ixgbevf_check_for_ack_vf,\n\t.check_for_rst\t= ixgbevf_check_for_rst_vf,\n};\n\n \nconst struct ixgbe_mbx_operations ixgbevf_hv_mbx_ops = {\n\t.init_params\t= ixgbevf_init_mbx_params_vf,\n\t.check_for_rst\t= ixgbevf_check_for_rst_vf,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}