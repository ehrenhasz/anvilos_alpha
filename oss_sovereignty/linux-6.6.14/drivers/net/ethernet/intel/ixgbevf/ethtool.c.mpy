{
  "module_name": "ethtool.c",
  "hash_id": "74d46af6353d2df077983a14727c77788ffddf48b295e8cd06208b1646d39390",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/ixgbevf/ethtool.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/vmalloc.h>\n#include <linux/if_vlan.h>\n#include <linux/uaccess.h>\n\n#include \"ixgbevf.h\"\n\nenum {NETDEV_STATS, IXGBEVF_STATS};\n\nstruct ixgbe_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint type;\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define IXGBEVF_STAT(_name, _stat) { \\\n\t.stat_string = _name, \\\n\t.type = IXGBEVF_STATS, \\\n\t.sizeof_stat = sizeof_field(struct ixgbevf_adapter, _stat), \\\n\t.stat_offset = offsetof(struct ixgbevf_adapter, _stat) \\\n}\n\n#define IXGBEVF_NETDEV_STAT(_net_stat) { \\\n\t.stat_string = #_net_stat, \\\n\t.type = NETDEV_STATS, \\\n\t.sizeof_stat = sizeof_field(struct net_device_stats, _net_stat), \\\n\t.stat_offset = offsetof(struct net_device_stats, _net_stat) \\\n}\n\nstatic struct ixgbe_stats ixgbevf_gstrings_stats[] = {\n\tIXGBEVF_NETDEV_STAT(rx_packets),\n\tIXGBEVF_NETDEV_STAT(tx_packets),\n\tIXGBEVF_NETDEV_STAT(rx_bytes),\n\tIXGBEVF_NETDEV_STAT(tx_bytes),\n\tIXGBEVF_STAT(\"tx_busy\", tx_busy),\n\tIXGBEVF_STAT(\"tx_restart_queue\", restart_queue),\n\tIXGBEVF_STAT(\"tx_timeout_count\", tx_timeout_count),\n\tIXGBEVF_NETDEV_STAT(multicast),\n\tIXGBEVF_STAT(\"rx_csum_offload_errors\", hw_csum_rx_error),\n\tIXGBEVF_STAT(\"alloc_rx_page\", alloc_rx_page),\n\tIXGBEVF_STAT(\"alloc_rx_page_failed\", alloc_rx_page_failed),\n\tIXGBEVF_STAT(\"alloc_rx_buff_failed\", alloc_rx_buff_failed),\n\tIXGBEVF_STAT(\"tx_ipsec\", tx_ipsec),\n\tIXGBEVF_STAT(\"rx_ipsec\", rx_ipsec),\n};\n\n#define IXGBEVF_QUEUE_STATS_LEN ( \\\n\t(((struct ixgbevf_adapter *)netdev_priv(netdev))->num_tx_queues + \\\n\t ((struct ixgbevf_adapter *)netdev_priv(netdev))->num_xdp_queues + \\\n\t ((struct ixgbevf_adapter *)netdev_priv(netdev))->num_rx_queues) * \\\n\t (sizeof(struct ixgbevf_stats) / sizeof(u64)))\n#define IXGBEVF_GLOBAL_STATS_LEN ARRAY_SIZE(ixgbevf_gstrings_stats)\n\n#define IXGBEVF_STATS_LEN (IXGBEVF_GLOBAL_STATS_LEN + IXGBEVF_QUEUE_STATS_LEN)\nstatic const char ixgbe_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register test  (offline)\",\n\t\"Link test   (on/offline)\"\n};\n\n#define IXGBEVF_TEST_LEN (sizeof(ixgbe_gstrings_test) / ETH_GSTRING_LEN)\n\nstatic const char ixgbevf_priv_flags_strings[][ETH_GSTRING_LEN] = {\n#define IXGBEVF_PRIV_FLAGS_LEGACY_RX\tBIT(0)\n\t\"legacy-rx\",\n};\n\n#define IXGBEVF_PRIV_FLAGS_STR_LEN ARRAY_SIZE(ixgbevf_priv_flags_strings)\n\nstatic int ixgbevf_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10000baseT_Full);\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\tcmd->base.port = -1;\n\n\tif (adapter->link_up) {\n\t\t__u32 speed = SPEED_10000;\n\n\t\tswitch (adapter->link_speed) {\n\t\tcase IXGBE_LINK_SPEED_10GB_FULL:\n\t\t\tspeed = SPEED_10000;\n\t\t\tbreak;\n\t\tcase IXGBE_LINK_SPEED_1GB_FULL:\n\t\t\tspeed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase IXGBE_LINK_SPEED_100_FULL:\n\t\t\tspeed = SPEED_100;\n\t\t\tbreak;\n\t\t}\n\n\t\tcmd->base.speed = speed;\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 ixgbevf_get_msglevel(struct net_device *netdev)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->msg_enable;\n}\n\nstatic void ixgbevf_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->msg_enable = data;\n}\n\nstatic int ixgbevf_get_regs_len(struct net_device *netdev)\n{\n#define IXGBE_REGS_LEN 45\n\treturn IXGBE_REGS_LEN * sizeof(u32);\n}\n\nstatic void ixgbevf_get_regs(struct net_device *netdev,\n\t\t\t     struct ethtool_regs *regs,\n\t\t\t     void *p)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu32 regs_len = ixgbevf_get_regs_len(netdev);\n\tu8 i;\n\n\tmemset(p, 0, regs_len);\n\n\t \n\tregs->version = (1u << 24) | (hw->revision_id << 16) | hw->device_id;\n\n\t \n\tregs_buff[0] = IXGBE_READ_REG(hw, IXGBE_VFCTRL);\n\tregs_buff[1] = IXGBE_READ_REG(hw, IXGBE_VFSTATUS);\n\tregs_buff[2] = IXGBE_READ_REG(hw, IXGBE_VFLINKS);\n\tregs_buff[3] = IXGBE_READ_REG(hw, IXGBE_VFRXMEMWRAP);\n\tregs_buff[4] = IXGBE_READ_REG(hw, IXGBE_VFFRTIMER);\n\n\t \n\t \n\tregs_buff[5] = IXGBE_READ_REG(hw, IXGBE_VTEICS);\n\tregs_buff[6] = IXGBE_READ_REG(hw, IXGBE_VTEICS);\n\tregs_buff[7] = IXGBE_READ_REG(hw, IXGBE_VTEIMS);\n\tregs_buff[8] = IXGBE_READ_REG(hw, IXGBE_VTEIMC);\n\tregs_buff[9] = IXGBE_READ_REG(hw, IXGBE_VTEIAC);\n\tregs_buff[10] = IXGBE_READ_REG(hw, IXGBE_VTEIAM);\n\tregs_buff[11] = IXGBE_READ_REG(hw, IXGBE_VTEITR(0));\n\tregs_buff[12] = IXGBE_READ_REG(hw, IXGBE_VTIVAR(0));\n\tregs_buff[13] = IXGBE_READ_REG(hw, IXGBE_VTIVAR_MISC);\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[14 + i] = IXGBE_READ_REG(hw, IXGBE_VFRDBAL(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[16 + i] = IXGBE_READ_REG(hw, IXGBE_VFRDBAH(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[18 + i] = IXGBE_READ_REG(hw, IXGBE_VFRDLEN(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[20 + i] = IXGBE_READ_REG(hw, IXGBE_VFRDH(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[22 + i] = IXGBE_READ_REG(hw, IXGBE_VFRDT(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[24 + i] = IXGBE_READ_REG(hw, IXGBE_VFRXDCTL(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[26 + i] = IXGBE_READ_REG(hw, IXGBE_VFSRRCTL(i));\n\n\t \n\tregs_buff[28] = IXGBE_READ_REG(hw, IXGBE_VFPSRTYPE);\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[29 + i] = IXGBE_READ_REG(hw, IXGBE_VFTDBAL(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[31 + i] = IXGBE_READ_REG(hw, IXGBE_VFTDBAH(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[33 + i] = IXGBE_READ_REG(hw, IXGBE_VFTDLEN(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_VFTDH(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[37 + i] = IXGBE_READ_REG(hw, IXGBE_VFTDT(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[39 + i] = IXGBE_READ_REG(hw, IXGBE_VFTXDCTL(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[41 + i] = IXGBE_READ_REG(hw, IXGBE_VFTDWBAL(i));\n\tfor (i = 0; i < 2; i++)\n\t\tregs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_VFTDWBAH(i));\n}\n\nstatic void ixgbevf_get_drvinfo(struct net_device *netdev,\n\t\t\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver, ixgbevf_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\n\tdrvinfo->n_priv_flags = IXGBEVF_PRIV_FLAGS_STR_LEN;\n}\n\nstatic void ixgbevf_get_ringparam(struct net_device *netdev,\n\t\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\tring->rx_max_pending = IXGBEVF_MAX_RXD;\n\tring->tx_max_pending = IXGBEVF_MAX_TXD;\n\tring->rx_pending = adapter->rx_ring_count;\n\tring->tx_pending = adapter->tx_ring_count;\n}\n\nstatic int ixgbevf_set_ringparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_ringparam *ring,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbevf_ring *tx_ring = NULL, *rx_ring = NULL;\n\tu32 new_rx_count, new_tx_count;\n\tint i, j, err = 0;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tnew_tx_count = max_t(u32, ring->tx_pending, IXGBEVF_MIN_TXD);\n\tnew_tx_count = min_t(u32, new_tx_count, IXGBEVF_MAX_TXD);\n\tnew_tx_count = ALIGN(new_tx_count, IXGBE_REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tnew_rx_count = max_t(u32, ring->rx_pending, IXGBEVF_MIN_RXD);\n\tnew_rx_count = min_t(u32, new_rx_count, IXGBEVF_MAX_RXD);\n\tnew_rx_count = ALIGN(new_rx_count, IXGBE_REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\t \n\tif ((new_tx_count == adapter->tx_ring_count) &&\n\t    (new_rx_count == adapter->rx_ring_count))\n\t\treturn 0;\n\n\twhile (test_and_set_bit(__IXGBEVF_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(adapter->netdev)) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\tadapter->tx_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < adapter->num_xdp_queues; i++)\n\t\t\tadapter->xdp_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\tadapter->rx_ring[i]->count = new_rx_count;\n\t\tadapter->tx_ring_count = new_tx_count;\n\t\tadapter->xdp_ring_count = new_tx_count;\n\t\tadapter->rx_ring_count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\tif (new_tx_count != adapter->tx_ring_count) {\n\t\ttx_ring = vmalloc(array_size(sizeof(*tx_ring),\n\t\t\t\t\t     adapter->num_tx_queues +\n\t\t\t\t\t\tadapter->num_xdp_queues));\n\t\tif (!tx_ring) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto clear_reset;\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\t \n\t\t\ttx_ring[i] = *adapter->tx_ring[i];\n\t\t\ttx_ring[i].count = new_tx_count;\n\t\t\terr = ixgbevf_setup_tx_resources(&tx_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tixgbevf_free_tx_resources(&tx_ring[i]);\n\t\t\t\t}\n\n\t\t\t\tvfree(tx_ring);\n\t\t\t\ttx_ring = NULL;\n\n\t\t\t\tgoto clear_reset;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < adapter->num_xdp_queues; i++, j++) {\n\t\t\t \n\t\t\ttx_ring[i] = *adapter->xdp_ring[j];\n\t\t\ttx_ring[i].count = new_tx_count;\n\t\t\terr = ixgbevf_setup_tx_resources(&tx_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tixgbevf_free_tx_resources(&tx_ring[i]);\n\t\t\t\t}\n\n\t\t\t\tvfree(tx_ring);\n\t\t\t\ttx_ring = NULL;\n\n\t\t\t\tgoto clear_reset;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (new_rx_count != adapter->rx_ring_count) {\n\t\trx_ring = vmalloc(array_size(sizeof(*rx_ring),\n\t\t\t\t\t     adapter->num_rx_queues));\n\t\tif (!rx_ring) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto clear_reset;\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\t \n\t\t\trx_ring[i] = *adapter->rx_ring[i];\n\n\t\t\t \n\t\t\tmemset(&rx_ring[i].xdp_rxq, 0,\n\t\t\t       sizeof(rx_ring[i].xdp_rxq));\n\n\t\t\trx_ring[i].count = new_rx_count;\n\t\t\terr = ixgbevf_setup_rx_resources(adapter, &rx_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tixgbevf_free_rx_resources(&rx_ring[i]);\n\t\t\t\t}\n\n\t\t\t\tvfree(rx_ring);\n\t\t\t\trx_ring = NULL;\n\n\t\t\t\tgoto clear_reset;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tixgbevf_down(adapter);\n\n\t \n\tif (tx_ring) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tixgbevf_free_tx_resources(adapter->tx_ring[i]);\n\t\t\t*adapter->tx_ring[i] = tx_ring[i];\n\t\t}\n\t\tadapter->tx_ring_count = new_tx_count;\n\n\t\tfor (j = 0; j < adapter->num_xdp_queues; i++, j++) {\n\t\t\tixgbevf_free_tx_resources(adapter->xdp_ring[j]);\n\t\t\t*adapter->xdp_ring[j] = tx_ring[i];\n\t\t}\n\t\tadapter->xdp_ring_count = new_tx_count;\n\n\t\tvfree(tx_ring);\n\t\ttx_ring = NULL;\n\t}\n\n\t \n\tif (rx_ring) {\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tixgbevf_free_rx_resources(adapter->rx_ring[i]);\n\t\t\t*adapter->rx_ring[i] = rx_ring[i];\n\t\t}\n\t\tadapter->rx_ring_count = new_rx_count;\n\n\t\tvfree(rx_ring);\n\t\trx_ring = NULL;\n\t}\n\n\t \n\tixgbevf_up(adapter);\n\nclear_reset:\n\t \n\tif (tx_ring) {\n\t\tfor (i = 0;\n\t\t     i < adapter->num_tx_queues + adapter->num_xdp_queues; i++)\n\t\t\tixgbevf_free_tx_resources(&tx_ring[i]);\n\t\tvfree(tx_ring);\n\t}\n\n\tclear_bit(__IXGBEVF_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic int ixgbevf_get_sset_count(struct net_device *netdev, int stringset)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\treturn IXGBEVF_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn IXGBEVF_STATS_LEN;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn IXGBEVF_PRIV_FLAGS_STR_LEN;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void ixgbevf_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *net_stats;\n\tunsigned int start;\n\tstruct ixgbevf_ring *ring;\n\tint i, j;\n\tchar *p;\n\n\tixgbevf_update_stats(adapter);\n\tnet_stats = dev_get_stats(netdev, &temp);\n\tfor (i = 0; i < IXGBEVF_GLOBAL_STATS_LEN; i++) {\n\t\tswitch (ixgbevf_gstrings_stats[i].type) {\n\t\tcase NETDEV_STATS:\n\t\t\tp = (char *)net_stats +\n\t\t\t\t\tixgbevf_gstrings_stats[i].stat_offset;\n\t\t\tbreak;\n\t\tcase IXGBEVF_STATS:\n\t\t\tp = (char *)adapter +\n\t\t\t\t\tixgbevf_gstrings_stats[i].stat_offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata[i] = (ixgbevf_gstrings_stats[i].sizeof_stat ==\n\t\t\t   sizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\n\t \n\tfor (j = 0; j < adapter->num_tx_queues; j++) {\n\t\tring = adapter->tx_ring[j];\n\t\tif (!ring) {\n\t\t\tdata[i++] = 0;\n\t\t\tdata[i++] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\t\tdata[i]   = ring->stats.packets;\n\t\t\tdata[i + 1] = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n\t\ti += 2;\n\t}\n\n\t \n\tfor (j = 0; j < adapter->num_xdp_queues; j++) {\n\t\tring = adapter->xdp_ring[j];\n\t\tif (!ring) {\n\t\t\tdata[i++] = 0;\n\t\t\tdata[i++] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\t\tdata[i] = ring->stats.packets;\n\t\t\tdata[i + 1] = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n\t\ti += 2;\n\t}\n\n\t \n\tfor (j = 0; j < adapter->num_rx_queues; j++) {\n\t\tring = adapter->rx_ring[j];\n\t\tif (!ring) {\n\t\t\tdata[i++] = 0;\n\t\t\tdata[i++] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\t\tdata[i]   = ring->stats.packets;\n\t\t\tdata[i + 1] = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n\t\ti += 2;\n\t}\n}\n\nstatic void ixgbevf_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t\tu8 *data)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tchar *p = (char *)data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, *ixgbe_gstrings_test,\n\t\t       IXGBEVF_TEST_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < IXGBEVF_GLOBAL_STATS_LEN; i++) {\n\t\t\tmemcpy(p, ixgbevf_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tsprintf(p, \"tx_queue_%u_packets\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"tx_queue_%u_bytes\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < adapter->num_xdp_queues; i++) {\n\t\t\tsprintf(p, \"xdp_queue_%u_packets\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"xdp_queue_%u_bytes\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tsprintf(p, \"rx_queue_%u_packets\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"rx_queue_%u_bytes\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(data, ixgbevf_priv_flags_strings,\n\t\t       IXGBEVF_PRIV_FLAGS_STR_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic int ixgbevf_link_test(struct ixgbevf_adapter *adapter, u64 *data)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tbool link_up;\n\tu32 link_speed = 0;\n\t*data = 0;\n\n\thw->mac.ops.check_link(hw, &link_speed, &link_up, true);\n\tif (!link_up)\n\t\t*data = 1;\n\n\treturn *data;\n}\n\n \nstruct ixgbevf_reg_test {\n\tu16 reg;\n\tu8  array_len;\n\tu8  test_type;\n\tu32 mask;\n\tu32 write;\n};\n\n \n\n#define PATTERN_TEST\t1\n#define SET_READ_TEST\t2\n#define WRITE_NO_TEST\t3\n#define TABLE32_TEST\t4\n#define TABLE64_TEST_LO\t5\n#define TABLE64_TEST_HI\t6\n\n \nstatic const struct ixgbevf_reg_test reg_test_vf[] = {\n\t{ IXGBE_VFRDBAL(0), 2, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFF80 },\n\t{ IXGBE_VFRDBAH(0), 2, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_VFRDLEN(0), 2, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },\n\t{ IXGBE_VFRXDCTL(0), 2, WRITE_NO_TEST, 0, IXGBE_RXDCTL_ENABLE },\n\t{ IXGBE_VFRDT(0), 2, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },\n\t{ IXGBE_VFRXDCTL(0), 2, WRITE_NO_TEST, 0, 0 },\n\t{ IXGBE_VFTDBAL(0), 2, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },\n\t{ IXGBE_VFTDBAH(0), 2, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },\n\t{ IXGBE_VFTDLEN(0), 2, PATTERN_TEST, 0x000FFF80, 0x000FFF80 },\n\t{ .reg = 0 }\n};\n\nstatic const u32 register_test_patterns[] = {\n\t0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF\n};\n\nstatic bool reg_pattern_test(struct ixgbevf_adapter *adapter, u64 *data,\n\t\t\t     int reg, u32 mask, u32 write)\n{\n\tu32 pat, val, before;\n\n\tif (IXGBE_REMOVED(adapter->hw.hw_addr)) {\n\t\t*data = 1;\n\t\treturn true;\n\t}\n\tfor (pat = 0; pat < ARRAY_SIZE(register_test_patterns); pat++) {\n\t\tbefore = ixgbevf_read_reg(&adapter->hw, reg);\n\t\tixgbe_write_reg(&adapter->hw, reg,\n\t\t\t\tregister_test_patterns[pat] & write);\n\t\tval = ixgbevf_read_reg(&adapter->hw, reg);\n\t\tif (val != (register_test_patterns[pat] & write & mask)) {\n\t\t\thw_dbg(&adapter->hw,\n\t\t\t       \"pattern test reg %04X failed: got 0x%08X expected 0x%08X\\n\",\n\t\t\t       reg, val,\n\t\t\t       register_test_patterns[pat] & write & mask);\n\t\t\t*data = reg;\n\t\t\tixgbe_write_reg(&adapter->hw, reg, before);\n\t\t\treturn true;\n\t\t}\n\t\tixgbe_write_reg(&adapter->hw, reg, before);\n\t}\n\treturn false;\n}\n\nstatic bool reg_set_and_check(struct ixgbevf_adapter *adapter, u64 *data,\n\t\t\t      int reg, u32 mask, u32 write)\n{\n\tu32 val, before;\n\n\tif (IXGBE_REMOVED(adapter->hw.hw_addr)) {\n\t\t*data = 1;\n\t\treturn true;\n\t}\n\tbefore = ixgbevf_read_reg(&adapter->hw, reg);\n\tixgbe_write_reg(&adapter->hw, reg, write & mask);\n\tval = ixgbevf_read_reg(&adapter->hw, reg);\n\tif ((write & mask) != (val & mask)) {\n\t\tpr_err(\"set/check reg %04X test failed: got 0x%08X expected 0x%08X\\n\",\n\t\t       reg, (val & mask), write & mask);\n\t\t*data = reg;\n\t\tixgbe_write_reg(&adapter->hw, reg, before);\n\t\treturn true;\n\t}\n\tixgbe_write_reg(&adapter->hw, reg, before);\n\treturn false;\n}\n\nstatic int ixgbevf_reg_test(struct ixgbevf_adapter *adapter, u64 *data)\n{\n\tconst struct ixgbevf_reg_test *test;\n\tu32 i;\n\n\tif (IXGBE_REMOVED(adapter->hw.hw_addr)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Adapter removed - register test blocked\\n\");\n\t\t*data = 1;\n\t\treturn 1;\n\t}\n\ttest = reg_test_vf;\n\n\t \n\twhile (test->reg) {\n\t\tfor (i = 0; i < test->array_len; i++) {\n\t\t\tbool b = false;\n\n\t\t\tswitch (test->test_type) {\n\t\t\tcase PATTERN_TEST:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 0x40),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase SET_READ_TEST:\n\t\t\t\tb = reg_set_and_check(adapter, data,\n\t\t\t\t\t\t      test->reg + (i * 0x40),\n\t\t\t\t\t\t      test->mask,\n\t\t\t\t\t\t      test->write);\n\t\t\t\tbreak;\n\t\t\tcase WRITE_NO_TEST:\n\t\t\t\tixgbe_write_reg(&adapter->hw,\n\t\t\t\t\t\ttest->reg + (i * 0x40),\n\t\t\t\t\t\ttest->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE32_TEST:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 4),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_LO:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + (i * 8),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\tcase TABLE64_TEST_HI:\n\t\t\t\tb = reg_pattern_test(adapter, data,\n\t\t\t\t\t\t     test->reg + 4 + (i * 8),\n\t\t\t\t\t\t     test->mask,\n\t\t\t\t\t\t     test->write);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b)\n\t\t\t\treturn 1;\n\t\t}\n\t\ttest++;\n\t}\n\n\t*data = 0;\n\treturn *data;\n}\n\nstatic void ixgbevf_diag_test(struct net_device *netdev,\n\t\t\t      struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tbool if_running = netif_running(netdev);\n\n\tif (IXGBE_REMOVED(adapter->hw.hw_addr)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Adapter removed - test blocked\\n\");\n\t\tdata[0] = 1;\n\t\tdata[1] = 1;\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\tset_bit(__IXGBEVF_TESTING, &adapter->state);\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\t \n\n\t\thw_dbg(&adapter->hw, \"offline testing starting\\n\");\n\n\t\t \n\t\tif (ixgbevf_link_test(adapter, &data[1]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (if_running)\n\t\t\t \n\t\t\tixgbevf_close(netdev);\n\t\telse\n\t\t\tixgbevf_reset(adapter);\n\n\t\thw_dbg(&adapter->hw, \"register testing starting\\n\");\n\t\tif (ixgbevf_reg_test(adapter, &data[0]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tixgbevf_reset(adapter);\n\n\t\tclear_bit(__IXGBEVF_TESTING, &adapter->state);\n\t\tif (if_running)\n\t\t\tixgbevf_open(netdev);\n\t} else {\n\t\thw_dbg(&adapter->hw, \"online testing starting\\n\");\n\t\t \n\t\tif (ixgbevf_link_test(adapter, &data[1]))\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t \n\t\tdata[0] = 0;\n\n\t\tclear_bit(__IXGBEVF_TESTING, &adapter->state);\n\t}\n\tmsleep_interruptible(4 * 1000);\n}\n\nstatic int ixgbevf_nway_reset(struct net_device *netdev)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\tixgbevf_reinit_locked(adapter);\n\n\treturn 0;\n}\n\nstatic int ixgbevf_get_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *ec,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (adapter->rx_itr_setting <= 1)\n\t\tec->rx_coalesce_usecs = adapter->rx_itr_setting;\n\telse\n\t\tec->rx_coalesce_usecs = adapter->rx_itr_setting >> 2;\n\n\t \n\tif (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count)\n\t\treturn 0;\n\n\t \n\tif (adapter->tx_itr_setting <= 1)\n\t\tec->tx_coalesce_usecs = adapter->tx_itr_setting;\n\telse\n\t\tec->tx_coalesce_usecs = adapter->tx_itr_setting >> 2;\n\n\treturn 0;\n}\n\nstatic int ixgbevf_set_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *ec,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tstruct ixgbevf_q_vector *q_vector;\n\tint num_vectors, i;\n\tu16 tx_itr_param, rx_itr_param;\n\n\t \n\tif (adapter->q_vector[0]->tx.count &&\n\t    adapter->q_vector[0]->rx.count && ec->tx_coalesce_usecs)\n\t\treturn -EINVAL;\n\n\tif ((ec->rx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)) ||\n\t    (ec->tx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)))\n\t\treturn -EINVAL;\n\n\tif (ec->rx_coalesce_usecs > 1)\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs << 2;\n\telse\n\t\tadapter->rx_itr_setting = ec->rx_coalesce_usecs;\n\n\tif (adapter->rx_itr_setting == 1)\n\t\trx_itr_param = IXGBE_20K_ITR;\n\telse\n\t\trx_itr_param = adapter->rx_itr_setting;\n\n\tif (ec->tx_coalesce_usecs > 1)\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs << 2;\n\telse\n\t\tadapter->tx_itr_setting = ec->tx_coalesce_usecs;\n\n\tif (adapter->tx_itr_setting == 1)\n\t\ttx_itr_param = IXGBE_12K_ITR;\n\telse\n\t\ttx_itr_param = adapter->tx_itr_setting;\n\n\tnum_vectors = adapter->num_msix_vectors - NON_Q_VECTORS;\n\n\tfor (i = 0; i < num_vectors; i++) {\n\t\tq_vector = adapter->q_vector[i];\n\t\tif (q_vector->tx.count && !q_vector->rx.count)\n\t\t\t \n\t\t\tq_vector->itr = tx_itr_param;\n\t\telse\n\t\t\t \n\t\t\tq_vector->itr = rx_itr_param;\n\t\tixgbevf_write_eitr(q_vector);\n\t}\n\n\treturn 0;\n}\n\nstatic int ixgbevf_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\n\t\t\t     u32 *rules __always_unused)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(dev);\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = adapter->num_rx_queues;\n\t\treturn 0;\n\tdefault:\n\t\thw_dbg(&adapter->hw, \"Command parameters not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32 ixgbevf_get_rxfh_indir_size(struct net_device *netdev)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->hw.mac.type >= ixgbe_mac_X550_vf)\n\t\treturn IXGBEVF_X550_VFRETA_SIZE;\n\n\treturn IXGBEVF_82599_RETA_SIZE;\n}\n\nstatic u32 ixgbevf_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn IXGBEVF_RSS_HASH_KEY_SIZE;\n}\n\nstatic int ixgbevf_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t    u8 *hfunc)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tint err = 0;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\tif (adapter->hw.mac.type >= ixgbe_mac_X550_vf) {\n\t\tif (key)\n\t\t\tmemcpy(key, adapter->rss_key,\n\t\t\t       ixgbevf_get_rxfh_key_size(netdev));\n\n\t\tif (indir) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < IXGBEVF_X550_VFRETA_SIZE; i++)\n\t\t\t\tindir[i] = adapter->rss_indir_tbl[i];\n\t\t}\n\t} else {\n\t\t \n\t\tif (!indir && !key)\n\t\t\treturn 0;\n\n\t\tspin_lock_bh(&adapter->mbx_lock);\n\t\tif (indir)\n\t\t\terr = ixgbevf_get_reta_locked(&adapter->hw, indir,\n\t\t\t\t\t\t      adapter->num_rx_queues);\n\n\t\tif (!err && key)\n\t\t\terr = ixgbevf_get_rss_key_locked(&adapter->hw, key);\n\n\t\tspin_unlock_bh(&adapter->mbx_lock);\n\t}\n\n\treturn err;\n}\n\nstatic u32 ixgbevf_get_priv_flags(struct net_device *netdev)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tu32 priv_flags = 0;\n\n\tif (adapter->flags & IXGBEVF_FLAGS_LEGACY_RX)\n\t\tpriv_flags |= IXGBEVF_PRIV_FLAGS_LEGACY_RX;\n\n\treturn priv_flags;\n}\n\nstatic int ixgbevf_set_priv_flags(struct net_device *netdev, u32 priv_flags)\n{\n\tstruct ixgbevf_adapter *adapter = netdev_priv(netdev);\n\tunsigned int flags = adapter->flags;\n\n\tflags &= ~IXGBEVF_FLAGS_LEGACY_RX;\n\tif (priv_flags & IXGBEVF_PRIV_FLAGS_LEGACY_RX)\n\t\tflags |= IXGBEVF_FLAGS_LEGACY_RX;\n\n\tif (flags != adapter->flags) {\n\t\tadapter->flags = flags;\n\n\t\t \n\t\tif (netif_running(netdev))\n\t\t\tixgbevf_reinit_locked(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ixgbevf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS,\n\t.get_drvinfo\t\t= ixgbevf_get_drvinfo,\n\t.get_regs_len\t\t= ixgbevf_get_regs_len,\n\t.get_regs\t\t= ixgbevf_get_regs,\n\t.nway_reset\t\t= ixgbevf_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ringparam\t\t= ixgbevf_get_ringparam,\n\t.set_ringparam\t\t= ixgbevf_set_ringparam,\n\t.get_msglevel\t\t= ixgbevf_get_msglevel,\n\t.set_msglevel\t\t= ixgbevf_set_msglevel,\n\t.self_test\t\t= ixgbevf_diag_test,\n\t.get_sset_count\t\t= ixgbevf_get_sset_count,\n\t.get_strings\t\t= ixgbevf_get_strings,\n\t.get_ethtool_stats\t= ixgbevf_get_ethtool_stats,\n\t.get_coalesce\t\t= ixgbevf_get_coalesce,\n\t.set_coalesce\t\t= ixgbevf_set_coalesce,\n\t.get_rxnfc\t\t= ixgbevf_get_rxnfc,\n\t.get_rxfh_indir_size\t= ixgbevf_get_rxfh_indir_size,\n\t.get_rxfh_key_size\t= ixgbevf_get_rxfh_key_size,\n\t.get_rxfh\t\t= ixgbevf_get_rxfh,\n\t.get_link_ksettings\t= ixgbevf_get_link_ksettings,\n\t.get_priv_flags\t\t= ixgbevf_get_priv_flags,\n\t.set_priv_flags\t\t= ixgbevf_set_priv_flags,\n};\n\nvoid ixgbevf_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ixgbevf_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}