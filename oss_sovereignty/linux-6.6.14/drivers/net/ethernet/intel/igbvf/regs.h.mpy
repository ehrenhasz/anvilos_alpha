{
  "module_name": "regs.h",
  "hash_id": "34d76f65dec91be474bda4f6f3775f870836d81cc2347ec69ceb9a3c5a0e2958",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igbvf/regs.h",
  "human_readable_source": " \n \n\n#ifndef _E1000_REGS_H_\n#define _E1000_REGS_H_\n\n#define E1000_CTRL\t0x00000  \n#define E1000_STATUS\t0x00008  \n#define E1000_ITR\t0x000C4  \n#define E1000_EICR\t0x01580  \n#define E1000_EITR(_n)\t(0x01680 + (0x4 * (_n)))\n#define E1000_EICS\t0x01520  \n#define E1000_EIMS\t0x01524  \n#define E1000_EIMC\t0x01528  \n#define E1000_EIAC\t0x0152C  \n#define E1000_EIAM\t0x01530  \n#define E1000_IVAR0\t0x01700  \n#define E1000_IVAR_MISC\t0x01740  \n\n \n#define E1000_RDBAL(_n)\t((_n) < 4 ? (0x02800 + ((_n) * 0x100)) : \\\n\t\t\t (0x0C000 + ((_n) * 0x40)))\n#define E1000_RDBAH(_n)\t((_n) < 4 ? (0x02804 + ((_n) * 0x100)) : \\\n\t\t\t (0x0C004 + ((_n) * 0x40)))\n#define E1000_RDLEN(_n)\t((_n) < 4 ? (0x02808 + ((_n) * 0x100)) : \\\n\t\t\t (0x0C008 + ((_n) * 0x40)))\n#define E1000_SRRCTL(_n)\t((_n) < 4 ? (0x0280C + ((_n) * 0x100)) : \\\n\t\t\t\t (0x0C00C + ((_n) * 0x40)))\n#define E1000_RDH(_n)\t((_n) < 4 ? (0x02810 + ((_n) * 0x100)) : \\\n\t\t\t (0x0C010 + ((_n) * 0x40)))\n#define E1000_RDT(_n)\t((_n) < 4 ? (0x02818 + ((_n) * 0x100)) : \\\n\t\t\t (0x0C018 + ((_n) * 0x40)))\n#define E1000_RXDCTL(_n)\t((_n) < 4 ? (0x02828 + ((_n) * 0x100)) : \\\n\t\t\t\t (0x0C028 + ((_n) * 0x40)))\n#define E1000_TDBAL(_n)\t((_n) < 4 ? (0x03800 + ((_n) * 0x100)) : \\\n\t\t\t (0x0E000 + ((_n) * 0x40)))\n#define E1000_TDBAH(_n)\t((_n) < 4 ? (0x03804 + ((_n) * 0x100)) : \\\n\t\t\t (0x0E004 + ((_n) * 0x40)))\n#define E1000_TDLEN(_n)\t((_n) < 4 ? (0x03808 + ((_n) * 0x100)) : \\\n\t\t\t (0x0E008 + ((_n) * 0x40)))\n#define E1000_TDH(_n)\t((_n) < 4 ? (0x03810 + ((_n) * 0x100)) : \\\n\t\t\t (0x0E010 + ((_n) * 0x40)))\n#define E1000_TDT(_n)\t((_n) < 4 ? (0x03818 + ((_n) * 0x100)) : \\\n\t\t\t (0x0E018 + ((_n) * 0x40)))\n#define E1000_TXDCTL(_n)\t((_n) < 4 ? (0x03828 + ((_n) * 0x100)) : \\\n\t\t\t\t (0x0E028 + ((_n) * 0x40)))\n#define E1000_DCA_TXCTRL(_n)\t(0x03814 + (_n << 8))\n#define E1000_DCA_RXCTRL(_n)\t(0x02814 + (_n << 8))\n#define E1000_RAL(_i)\t(((_i) <= 15) ? (0x05400 + ((_i) * 8)) : \\\n\t\t\t (0x054E0 + ((_i - 16) * 8)))\n#define E1000_RAH(_i)\t(((_i) <= 15) ? (0x05404 + ((_i) * 8)) : \\\n\t\t\t (0x054E4 + ((_i - 16) * 8)))\n\n \n#define E1000_VFGPRC\t0x00F10\n#define E1000_VFGORC\t0x00F18\n#define E1000_VFMPRC\t0x00F3C\n#define E1000_VFGPTC\t0x00F14\n#define E1000_VFGOTC\t0x00F34\n#define E1000_VFGOTLBC\t0x00F50\n#define E1000_VFGPTLBC\t0x00F44\n#define E1000_VFGORLBC\t0x00F48\n#define E1000_VFGPRLBC\t0x00F40\n\n \n#define E1000_V2PMAILBOX(_n)\t(0x00C40 + (4 * (_n)))\n#define E1000_VMBMEM(_n)\t(0x00800 + (64 * (_n)))\n\n \n#define er32(reg)\treadl(hw->hw_addr + E1000_##reg)\n#define ew32(reg, val)\twritel((val), hw->hw_addr +  E1000_##reg)\n#define array_er32(reg, offset) \\\n\treadl(hw->hw_addr + E1000_##reg + (offset << 2))\n#define array_ew32(reg, offset, val) \\\n\twritel((val), hw->hw_addr +  E1000_##reg + (offset << 2))\n#define e1e_flush()\ter32(STATUS)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}