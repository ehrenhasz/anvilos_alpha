{
  "module_name": "ethtool.c",
  "hash_id": "d9eaa359bb4c4bede0b7a78c267e02e2acda3cc1db2e0253d95ef6361c6372a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igbvf/ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n\n#include \"igbvf.h\"\n#include <linux/if_vlan.h>\n\nstruct igbvf_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n\tint base_stat_offset;\n};\n\n#define IGBVF_STAT(current, base) \\\n\t\tsizeof(((struct igbvf_adapter *)0)->current), \\\n\t\toffsetof(struct igbvf_adapter, current), \\\n\t\toffsetof(struct igbvf_adapter, base)\n\nstatic const struct igbvf_stats igbvf_gstrings_stats[] = {\n\t{ \"rx_packets\", IGBVF_STAT(stats.gprc, stats.base_gprc) },\n\t{ \"tx_packets\", IGBVF_STAT(stats.gptc, stats.base_gptc) },\n\t{ \"rx_bytes\", IGBVF_STAT(stats.gorc, stats.base_gorc) },\n\t{ \"tx_bytes\", IGBVF_STAT(stats.gotc, stats.base_gotc) },\n\t{ \"multicast\", IGBVF_STAT(stats.mprc, stats.base_mprc) },\n\t{ \"lbrx_bytes\", IGBVF_STAT(stats.gorlbc, stats.base_gorlbc) },\n\t{ \"lbrx_packets\", IGBVF_STAT(stats.gprlbc, stats.base_gprlbc) },\n\t{ \"tx_restart_queue\", IGBVF_STAT(restart_queue, zero_base) },\n\t{ \"rx_long_byte_count\", IGBVF_STAT(stats.gorc, stats.base_gorc) },\n\t{ \"rx_csum_offload_good\", IGBVF_STAT(hw_csum_good, zero_base) },\n\t{ \"rx_csum_offload_errors\", IGBVF_STAT(hw_csum_err, zero_base) },\n\t{ \"rx_header_split\", IGBVF_STAT(rx_hdr_split, zero_base) },\n\t{ \"alloc_rx_buff_failed\", IGBVF_STAT(alloc_rx_buff_failed, zero_base) },\n};\n\n#define IGBVF_GLOBAL_STATS_LEN ARRAY_SIZE(igbvf_gstrings_stats)\n\nstatic const char igbvf_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Link test   (on/offline)\"\n};\n\n#define IGBVF_TEST_LEN ARRAY_SIZE(igbvf_gstrings_test)\n\nstatic int igbvf_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 status;\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 1000baseT_Full);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, 1000baseT_Full);\n\n\tcmd->base.port = -1;\n\n\tstatus = er32(STATUS);\n\tif (status & E1000_STATUS_LU) {\n\t\tif (status & E1000_STATUS_SPEED_1000)\n\t\t\tcmd->base.speed = SPEED_1000;\n\t\telse if (status & E1000_STATUS_SPEED_100)\n\t\t\tcmd->base.speed = SPEED_100;\n\t\telse\n\t\t\tcmd->base.speed = SPEED_10;\n\n\t\tif (status & E1000_STATUS_FD)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic int igbvf_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void igbvf_get_pauseparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n}\n\nstatic int igbvf_set_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic u32 igbvf_get_msglevel(struct net_device *netdev)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->msg_enable;\n}\n\nstatic void igbvf_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->msg_enable = data;\n}\n\nstatic int igbvf_get_regs_len(struct net_device *netdev)\n{\n#define IGBVF_REGS_LEN 8\n\treturn IGBVF_REGS_LEN * sizeof(u32);\n}\n\nstatic void igbvf_get_regs(struct net_device *netdev,\n\t\t\t   struct ethtool_regs *regs, void *p)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\n\tmemset(p, 0, IGBVF_REGS_LEN * sizeof(u32));\n\n\tregs->version = (1u << 24) |\n\t\t\t(adapter->pdev->revision << 16) |\n\t\t\tadapter->pdev->device;\n\n\tregs_buff[0] = er32(CTRL);\n\tregs_buff[1] = er32(STATUS);\n\n\tregs_buff[2] = er32(RDLEN(0));\n\tregs_buff[3] = er32(RDH(0));\n\tregs_buff[4] = er32(RDT(0));\n\n\tregs_buff[5] = er32(TDLEN(0));\n\tregs_buff[6] = er32(TDH(0));\n\tregs_buff[7] = er32(TDT(0));\n}\n\nstatic int igbvf_get_eeprom_len(struct net_device *netdev)\n{\n\treturn 0;\n}\n\nstatic int igbvf_get_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int igbvf_set_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void igbvf_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver,  igbvf_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void igbvf_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\tstruct igbvf_ring *tx_ring = adapter->tx_ring;\n\tstruct igbvf_ring *rx_ring = adapter->rx_ring;\n\n\tring->rx_max_pending = IGBVF_MAX_RXD;\n\tring->tx_max_pending = IGBVF_MAX_TXD;\n\tring->rx_pending = rx_ring->count;\n\tring->tx_pending = tx_ring->count;\n}\n\nstatic int igbvf_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\tstruct igbvf_ring *temp_ring;\n\tint err = 0;\n\tu32 new_rx_count, new_tx_count;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tnew_rx_count = max_t(u32, ring->rx_pending, IGBVF_MIN_RXD);\n\tnew_rx_count = min_t(u32, new_rx_count, IGBVF_MAX_RXD);\n\tnew_rx_count = ALIGN(new_rx_count, REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\tnew_tx_count = max_t(u32, ring->tx_pending, IGBVF_MIN_TXD);\n\tnew_tx_count = min_t(u32, new_tx_count, IGBVF_MAX_TXD);\n\tnew_tx_count = ALIGN(new_tx_count, REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tif ((new_tx_count == adapter->tx_ring->count) &&\n\t    (new_rx_count == adapter->rx_ring->count)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\twhile (test_and_set_bit(__IGBVF_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(adapter->netdev)) {\n\t\tadapter->tx_ring->count = new_tx_count;\n\t\tadapter->rx_ring->count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\ttemp_ring = vmalloc(sizeof(struct igbvf_ring));\n\tif (!temp_ring) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_reset;\n\t}\n\n\tigbvf_down(adapter);\n\n\t \n\tif (new_tx_count != adapter->tx_ring->count) {\n\t\tmemcpy(temp_ring, adapter->tx_ring, sizeof(struct igbvf_ring));\n\n\t\ttemp_ring->count = new_tx_count;\n\t\terr = igbvf_setup_tx_resources(adapter, temp_ring);\n\t\tif (err)\n\t\t\tgoto err_setup;\n\n\t\tigbvf_free_tx_resources(adapter->tx_ring);\n\n\t\tmemcpy(adapter->tx_ring, temp_ring, sizeof(struct igbvf_ring));\n\t}\n\n\tif (new_rx_count != adapter->rx_ring->count) {\n\t\tmemcpy(temp_ring, adapter->rx_ring, sizeof(struct igbvf_ring));\n\n\t\ttemp_ring->count = new_rx_count;\n\t\terr = igbvf_setup_rx_resources(adapter, temp_ring);\n\t\tif (err)\n\t\t\tgoto err_setup;\n\n\t\tigbvf_free_rx_resources(adapter->rx_ring);\n\n\t\tmemcpy(adapter->rx_ring, temp_ring, sizeof(struct igbvf_ring));\n\t}\nerr_setup:\n\tigbvf_up(adapter);\n\tvfree(temp_ring);\nclear_reset:\n\tclear_bit(__IGBVF_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic int igbvf_link_test(struct igbvf_adapter *adapter, u64 *data)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\t*data = 0;\n\n\tspin_lock_bh(&hw->mbx_lock);\n\n\thw->mac.ops.check_for_link(hw);\n\n\tspin_unlock_bh(&hw->mbx_lock);\n\n\tif (!(er32(STATUS) & E1000_STATUS_LU))\n\t\t*data = 1;\n\n\treturn *data;\n}\n\nstatic void igbvf_diag_test(struct net_device *netdev,\n\t\t\t    struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\n\tset_bit(__IGBVF_TESTING, &adapter->state);\n\n\t \n\tif (igbvf_link_test(adapter, &data[0]))\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\tclear_bit(__IGBVF_TESTING, &adapter->state);\n\tmsleep_interruptible(4 * 1000);\n}\n\nstatic void igbvf_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\twol->supported = 0;\n\twol->wolopts = 0;\n}\n\nstatic int igbvf_set_wol(struct net_device *netdev,\n\t\t\t struct ethtool_wolinfo *wol)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int igbvf_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->requested_itr <= 3)\n\t\tec->rx_coalesce_usecs = adapter->requested_itr;\n\telse\n\t\tec->rx_coalesce_usecs = adapter->current_itr >> 2;\n\n\treturn 0;\n}\n\nstatic int igbvf_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif ((ec->rx_coalesce_usecs >= IGBVF_MIN_ITR_USECS) &&\n\t    (ec->rx_coalesce_usecs <= IGBVF_MAX_ITR_USECS)) {\n\t\tadapter->current_itr = ec->rx_coalesce_usecs << 2;\n\t\tadapter->requested_itr = 1000000000 /\n\t\t\t\t\t(adapter->current_itr * 256);\n\t} else if ((ec->rx_coalesce_usecs == 3) ||\n\t\t   (ec->rx_coalesce_usecs == 2)) {\n\t\tadapter->current_itr = IGBVF_START_ITR;\n\t\tadapter->requested_itr = ec->rx_coalesce_usecs;\n\t} else if (ec->rx_coalesce_usecs == 0) {\n\t\t \n\t\tadapter->current_itr = 4;\n\t\tadapter->requested_itr = 1000000000 /\n\t\t\t\t\t(adapter->current_itr * 256);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\twritel(adapter->current_itr,\n\t       hw->hw_addr + adapter->rx_ring->itr_register);\n\n\treturn 0;\n}\n\nstatic int igbvf_nway_reset(struct net_device *netdev)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\tigbvf_reinit_locked(adapter);\n\treturn 0;\n}\n\nstatic void igbvf_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats *stats,\n\t\t\t\t    u64 *data)\n{\n\tstruct igbvf_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\n\tigbvf_update_stats(adapter);\n\tfor (i = 0; i < IGBVF_GLOBAL_STATS_LEN; i++) {\n\t\tchar *p = (char *)adapter +\n\t\t\t  igbvf_gstrings_stats[i].stat_offset;\n\t\tchar *b = (char *)adapter +\n\t\t\t  igbvf_gstrings_stats[i].base_stat_offset;\n\t\tdata[i] = ((igbvf_gstrings_stats[i].sizeof_stat ==\n\t\t\t    sizeof(u64)) ? (*(u64 *)p - *(u64 *)b) :\n\t\t\t    (*(u32 *)p - *(u32 *)b));\n\t}\n}\n\nstatic int igbvf_get_sset_count(struct net_device *dev, int stringset)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\treturn IGBVF_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn IGBVF_GLOBAL_STATS_LEN;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void igbvf_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t      u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, *igbvf_gstrings_test, sizeof(igbvf_gstrings_test));\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < IGBVF_GLOBAL_STATS_LEN; i++) {\n\t\t\tmemcpy(p, igbvf_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic const struct ethtool_ops igbvf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo\t\t= igbvf_get_drvinfo,\n\t.get_regs_len\t\t= igbvf_get_regs_len,\n\t.get_regs\t\t= igbvf_get_regs,\n\t.get_wol\t\t= igbvf_get_wol,\n\t.set_wol\t\t= igbvf_set_wol,\n\t.get_msglevel\t\t= igbvf_get_msglevel,\n\t.set_msglevel\t\t= igbvf_set_msglevel,\n\t.nway_reset\t\t= igbvf_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= igbvf_get_eeprom_len,\n\t.get_eeprom\t\t= igbvf_get_eeprom,\n\t.set_eeprom\t\t= igbvf_set_eeprom,\n\t.get_ringparam\t\t= igbvf_get_ringparam,\n\t.set_ringparam\t\t= igbvf_set_ringparam,\n\t.get_pauseparam\t\t= igbvf_get_pauseparam,\n\t.set_pauseparam\t\t= igbvf_set_pauseparam,\n\t.self_test\t\t= igbvf_diag_test,\n\t.get_sset_count\t\t= igbvf_get_sset_count,\n\t.get_strings\t\t= igbvf_get_strings,\n\t.get_ethtool_stats\t= igbvf_get_ethtool_stats,\n\t.get_coalesce\t\t= igbvf_get_coalesce,\n\t.set_coalesce\t\t= igbvf_set_coalesce,\n\t.get_link_ksettings\t= igbvf_get_link_ksettings,\n\t.set_link_ksettings\t= igbvf_set_link_ksettings,\n};\n\nvoid igbvf_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &igbvf_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}