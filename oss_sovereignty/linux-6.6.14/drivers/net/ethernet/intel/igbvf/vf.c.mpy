{
  "module_name": "vf.c",
  "hash_id": "206724033725f7f15a1cc5f17e58de3e557628aa050bd2d73b7be50421218c74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igbvf/vf.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n\n#include \"vf.h\"\n\nstatic s32 e1000_check_for_link_vf(struct e1000_hw *hw);\nstatic s32 e1000_get_link_up_info_vf(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t     u16 *duplex);\nstatic s32 e1000_init_hw_vf(struct e1000_hw *hw);\nstatic s32 e1000_reset_hw_vf(struct e1000_hw *hw);\n\nstatic void e1000_update_mc_addr_list_vf(struct e1000_hw *hw, u8 *,\n\t\t\t\t\t u32, u32, u32);\nstatic void e1000_rar_set_vf(struct e1000_hw *, u8 *, u32);\nstatic s32 e1000_read_mac_addr_vf(struct e1000_hw *);\nstatic s32 e1000_set_uc_addr_vf(struct e1000_hw *hw, u32 subcmd, u8 *addr);\nstatic s32 e1000_set_vfta_vf(struct e1000_hw *, u16, bool);\n\n \nstatic s32 e1000_init_mac_params_vf(struct e1000_hw *hw)\n{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\n\t \n\tmac->mta_reg_count = 128;\n\t \n\tmac->rar_entry_count = 1;\n\n\t \n\t \n\tmac->ops.reset_hw = e1000_reset_hw_vf;\n\t \n\tmac->ops.init_hw = e1000_init_hw_vf;\n\t \n\tmac->ops.check_for_link = e1000_check_for_link_vf;\n\t \n\tmac->ops.get_link_up_info = e1000_get_link_up_info_vf;\n\t \n\tmac->ops.update_mc_addr_list = e1000_update_mc_addr_list_vf;\n\t \n\tmac->ops.rar_set = e1000_rar_set_vf;\n\t \n\tmac->ops.read_mac_addr = e1000_read_mac_addr_vf;\n\t \n\tmac->ops.set_uc_addr = e1000_set_uc_addr_vf;\n\t \n\tmac->ops.set_vfta = e1000_set_vfta_vf;\n\n\treturn E1000_SUCCESS;\n}\n\n \nvoid e1000_init_function_pointers_vf(struct e1000_hw *hw)\n{\n\thw->mac.ops.init_params = e1000_init_mac_params_vf;\n\thw->mbx.ops.init_params = e1000_init_mbx_params_vf;\n}\n\n \nstatic s32 e1000_get_link_up_info_vf(struct e1000_hw *hw, u16 *speed,\n\t\t\t\t     u16 *duplex)\n{\n\ts32 status;\n\n\tstatus = er32(STATUS);\n\tif (status & E1000_STATUS_SPEED_1000)\n\t\t*speed = SPEED_1000;\n\telse if (status & E1000_STATUS_SPEED_100)\n\t\t*speed = SPEED_100;\n\telse\n\t\t*speed = SPEED_10;\n\n\tif (status & E1000_STATUS_FD)\n\t\t*duplex = FULL_DUPLEX;\n\telse\n\t\t*duplex = HALF_DUPLEX;\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_reset_hw_vf(struct e1000_hw *hw)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tu32 timeout = E1000_VF_INIT_TIMEOUT;\n\tu32 ret_val = -E1000_ERR_MAC_INIT;\n\tu32 msgbuf[3];\n\tu8 *addr = (u8 *)(&msgbuf[1]);\n\tu32 ctrl;\n\n\t \n\tctrl = er32(CTRL);\n\tew32(CTRL, ctrl | E1000_CTRL_RST);\n\n\t \n\twhile (!mbx->ops.check_for_rst(hw) && timeout) {\n\t\ttimeout--;\n\t\tudelay(5);\n\t}\n\n\tif (timeout) {\n\t\t \n\t\tmbx->timeout = E1000_VF_MBX_INIT_TIMEOUT;\n\n\t\t \n\t\tmsgbuf[0] = E1000_VF_RESET;\n\t\tmbx->ops.write_posted(hw, msgbuf, 1);\n\n\t\tmdelay(10);\n\n\t\t \n\t\tret_val = mbx->ops.read_posted(hw, msgbuf, 3);\n\t\tif (!ret_val) {\n\t\t\tswitch (msgbuf[0]) {\n\t\t\tcase E1000_VF_RESET | E1000_VT_MSGTYPE_ACK:\n\t\t\t\tmemcpy(hw->mac.perm_addr, addr, ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\tcase E1000_VF_RESET | E1000_VT_MSGTYPE_NACK:\n\t\t\t\teth_zero_addr(hw->mac.perm_addr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret_val = -E1000_ERR_MAC_INIT;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_init_hw_vf(struct e1000_hw *hw)\n{\n\t \n\te1000_rar_set_vf(hw, hw->mac.addr, 0);\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic u32 e1000_hash_mc_addr_vf(struct e1000_hw *hw, u8 *mc_addr)\n{\n\tu32 hash_value, hash_mask;\n\tu8 bit_shift = 0;\n\n\t \n\thash_mask = (hw->mac.mta_reg_count * 32) - 1;\n\n\t \n\twhile (hash_mask >> bit_shift != 0xFF)\n\t\tbit_shift++;\n\n\thash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\n\t\t\t\t  (((u16)mc_addr[5]) << bit_shift)));\n\n\treturn hash_value;\n}\n\n \nstatic void e1000_update_mc_addr_list_vf(struct e1000_hw *hw,\n\t\t\t\t\t u8 *mc_addr_list, u32 mc_addr_count,\n\t\t\t\t\t u32 rar_used_count, u32 rar_count)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tu32 msgbuf[E1000_VFMAILBOX_SIZE];\n\tu16 *hash_list = (u16 *)&msgbuf[1];\n\tu32 hash_value;\n\tu32 cnt, i;\n\ts32 ret_val;\n\n\t \n\n\tcnt = (mc_addr_count > 30) ? 30 : mc_addr_count;\n\tmsgbuf[0] = E1000_VF_SET_MULTICAST;\n\tmsgbuf[0] |= cnt << E1000_VT_MSGINFO_SHIFT;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\thash_value = e1000_hash_mc_addr_vf(hw, mc_addr_list);\n\t\thash_list[i] = hash_value & 0x0FFFF;\n\t\tmc_addr_list += ETH_ALEN;\n\t}\n\n\tret_val = mbx->ops.write_posted(hw, msgbuf, E1000_VFMAILBOX_SIZE);\n\tif (!ret_val)\n\t\tmbx->ops.read_posted(hw, msgbuf, 1);\n}\n\n \nstatic s32 e1000_set_vfta_vf(struct e1000_hw *hw, u16 vid, bool set)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tu32 msgbuf[2];\n\ts32 err;\n\n\tmsgbuf[0] = E1000_VF_SET_VLAN;\n\tmsgbuf[1] = vid;\n\t \n\tif (set)\n\t\tmsgbuf[0] |= BIT(E1000_VT_MSGINFO_SHIFT);\n\n\tmbx->ops.write_posted(hw, msgbuf, 2);\n\n\terr = mbx->ops.read_posted(hw, msgbuf, 2);\n\n\tmsgbuf[0] &= ~E1000_VT_MSGTYPE_CTS;\n\n\t \n\tif (!err && (msgbuf[0] == (E1000_VF_SET_VLAN | E1000_VT_MSGTYPE_NACK)))\n\t\terr = -E1000_ERR_MAC_INIT;\n\n\treturn err;\n}\n\n \nvoid e1000_rlpml_set_vf(struct e1000_hw *hw, u16 max_size)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tu32 msgbuf[2];\n\ts32 ret_val;\n\n\tmsgbuf[0] = E1000_VF_SET_LPE;\n\tmsgbuf[1] = max_size;\n\n\tret_val = mbx->ops.write_posted(hw, msgbuf, 2);\n\tif (!ret_val)\n\t\tmbx->ops.read_posted(hw, msgbuf, 1);\n}\n\n \nstatic void e1000_rar_set_vf(struct e1000_hw *hw, u8 *addr, u32 index)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tu32 msgbuf[3];\n\tu8 *msg_addr = (u8 *)(&msgbuf[1]);\n\ts32 ret_val;\n\n\tmemset(msgbuf, 0, 12);\n\tmsgbuf[0] = E1000_VF_SET_MAC_ADDR;\n\tmemcpy(msg_addr, addr, ETH_ALEN);\n\tret_val = mbx->ops.write_posted(hw, msgbuf, 3);\n\n\tif (!ret_val)\n\t\tret_val = mbx->ops.read_posted(hw, msgbuf, 3);\n\n\tmsgbuf[0] &= ~E1000_VT_MSGTYPE_CTS;\n\n\t \n\tif (!ret_val &&\n\t    (msgbuf[0] == (E1000_VF_SET_MAC_ADDR | E1000_VT_MSGTYPE_NACK)))\n\t\te1000_read_mac_addr_vf(hw);\n}\n\n \nstatic s32 e1000_read_mac_addr_vf(struct e1000_hw *hw)\n{\n\tmemcpy(hw->mac.addr, hw->mac.perm_addr, ETH_ALEN);\n\n\treturn E1000_SUCCESS;\n}\n\n \nstatic s32 e1000_set_uc_addr_vf(struct e1000_hw *hw, u32 sub_cmd, u8 *addr)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tu32 msgbuf[3], msgbuf_chk;\n\tu8 *msg_addr = (u8 *)(&msgbuf[1]);\n\ts32 ret_val;\n\n\tmemset(msgbuf, 0, sizeof(msgbuf));\n\tmsgbuf[0] |= sub_cmd;\n\tmsgbuf[0] |= E1000_VF_SET_MAC_ADDR;\n\tmsgbuf_chk = msgbuf[0];\n\n\tif (addr)\n\t\tmemcpy(msg_addr, addr, ETH_ALEN);\n\n\tret_val = mbx->ops.write_posted(hw, msgbuf, 3);\n\n\tif (!ret_val)\n\t\tret_val = mbx->ops.read_posted(hw, msgbuf, 3);\n\n\tmsgbuf[0] &= ~E1000_VT_MSGTYPE_CTS;\n\n\tif (!ret_val) {\n\t\tmsgbuf[0] &= ~E1000_VT_MSGTYPE_CTS;\n\n\t\tif (msgbuf[0] == (msgbuf_chk | E1000_VT_MSGTYPE_NACK))\n\t\t\treturn -ENOSPC;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_check_for_link_vf(struct e1000_hw *hw)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val = E1000_SUCCESS;\n\tu32 in_msg = 0;\n\n\t \n\n\t \n\tif (!mbx->ops.check_for_rst(hw) || !mbx->timeout)\n\t\tmac->get_link_status = true;\n\n\tif (!mac->get_link_status)\n\t\tgoto out;\n\n\t \n\tif (!(er32(STATUS) & E1000_STATUS_LU))\n\t\tgoto out;\n\n\t \n\tif (mbx->ops.read(hw, &in_msg, 1))\n\t\tgoto out;\n\n\t \n\tif (!(in_msg & E1000_VT_MSGTYPE_CTS)) {\n\t\t \n\t\tif (in_msg & E1000_VT_MSGTYPE_NACK)\n\t\t\tret_val = -E1000_ERR_MAC_INIT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!mbx->timeout) {\n\t\tret_val = -E1000_ERR_MAC_INIT;\n\t\tgoto out;\n\t}\n\n\t \n\tmac->get_link_status = false;\n\nout:\n\treturn ret_val;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}