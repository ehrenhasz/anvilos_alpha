{
  "module_name": "mbx.c",
  "hash_id": "22a8ce8366ebd029a6528d5a54b2f3f8b5d86441dcfce9c72cd3521b4c2e1a05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/intel/igbvf/mbx.c",
  "human_readable_source": "\n \n\n#include \"mbx.h\"\n\n \nstatic s32 e1000_poll_for_msg(struct e1000_hw *hw)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!mbx->ops.check_for_msg)\n\t\tgoto out;\n\n\twhile (countdown && mbx->ops.check_for_msg(hw)) {\n\t\tcountdown--;\n\t\tudelay(mbx->usec_delay);\n\t}\n\n\t \n\tif (!countdown)\n\t\tmbx->timeout = 0;\nout:\n\treturn countdown ? E1000_SUCCESS : -E1000_ERR_MBX;\n}\n\n \nstatic s32 e1000_poll_for_ack(struct e1000_hw *hw)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\tint countdown = mbx->timeout;\n\n\tif (!mbx->ops.check_for_ack)\n\t\tgoto out;\n\n\twhile (countdown && mbx->ops.check_for_ack(hw)) {\n\t\tcountdown--;\n\t\tudelay(mbx->usec_delay);\n\t}\n\n\t \n\tif (!countdown)\n\t\tmbx->timeout = 0;\nout:\n\treturn countdown ? E1000_SUCCESS : -E1000_ERR_MBX;\n}\n\n \nstatic s32 e1000_read_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (!mbx->ops.read)\n\t\tgoto out;\n\n\tret_val = e1000_poll_for_msg(hw);\n\n\t \n\tif (!ret_val)\n\t\tret_val = mbx->ops.read(hw, msg, size);\nout:\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\t \n\tif (!mbx->ops.write || !mbx->timeout)\n\t\tgoto out;\n\n\t \n\tret_val = mbx->ops.write(hw, msg, size);\n\n\t \n\tif (!ret_val)\n\t\tret_val = e1000_poll_for_ack(hw);\nout:\n\treturn ret_val;\n}\n\n \nstatic u32 e1000_read_v2p_mailbox(struct e1000_hw *hw)\n{\n\tu32 v2p_mailbox = er32(V2PMAILBOX(0));\n\n\tv2p_mailbox |= hw->dev_spec.vf.v2p_mailbox;\n\thw->dev_spec.vf.v2p_mailbox |= v2p_mailbox & E1000_V2PMAILBOX_R2C_BITS;\n\n\treturn v2p_mailbox;\n}\n\n \nstatic s32 e1000_check_for_bit_vf(struct e1000_hw *hw, u32 mask)\n{\n\tu32 v2p_mailbox = e1000_read_v2p_mailbox(hw);\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (v2p_mailbox & mask)\n\t\tret_val = E1000_SUCCESS;\n\n\thw->dev_spec.vf.v2p_mailbox &= ~mask;\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_check_for_msg_vf(struct e1000_hw *hw)\n{\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (!e1000_check_for_bit_vf(hw, E1000_V2PMAILBOX_PFSTS)) {\n\t\tret_val = E1000_SUCCESS;\n\t\thw->mbx.stats.reqs++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_check_for_ack_vf(struct e1000_hw *hw)\n{\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (!e1000_check_for_bit_vf(hw, E1000_V2PMAILBOX_PFACK)) {\n\t\tret_val = E1000_SUCCESS;\n\t\thw->mbx.stats.acks++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_check_for_rst_vf(struct e1000_hw *hw)\n{\n\ts32 ret_val = -E1000_ERR_MBX;\n\n\tif (!e1000_check_for_bit_vf(hw, (E1000_V2PMAILBOX_RSTD |\n\t\t\t\t\t E1000_V2PMAILBOX_RSTI))) {\n\t\tret_val = E1000_SUCCESS;\n\t\thw->mbx.stats.rsts++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_obtain_mbx_lock_vf(struct e1000_hw *hw)\n{\n\ts32 ret_val = -E1000_ERR_MBX;\n\tint count = 10;\n\n\tdo {\n\t\t \n\t\tew32(V2PMAILBOX(0), E1000_V2PMAILBOX_VFU);\n\n\t\t \n\t\tif (e1000_read_v2p_mailbox(hw) & E1000_V2PMAILBOX_VFU) {\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1000);\n\t} while (count-- > 0);\n\n\treturn ret_val;\n}\n\n \nstatic s32 e1000_write_mbx_vf(struct e1000_hw *hw, u32 *msg, u16 size)\n{\n\ts32 err;\n\tu16 i;\n\n\tlockdep_assert_held(&hw->mbx_lock);\n\n\t \n\terr = e1000_obtain_mbx_lock_vf(hw);\n\tif (err)\n\t\tgoto out_no_write;\n\n\t \n\te1000_check_for_ack_vf(hw);\n\te1000_check_for_msg_vf(hw);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tarray_ew32(VMBMEM(0), i, msg[i]);\n\n\t \n\thw->mbx.stats.msgs_tx++;\n\n\t \n\tew32(V2PMAILBOX(0), E1000_V2PMAILBOX_REQ);\n\nout_no_write:\n\treturn err;\n}\n\n \nstatic s32 e1000_read_mbx_vf(struct e1000_hw *hw, u32 *msg, u16 size)\n{\n\ts32 err;\n\tu16 i;\n\n\tlockdep_assert_held(&hw->mbx_lock);\n\n\t \n\terr = e1000_obtain_mbx_lock_vf(hw);\n\tif (err)\n\t\tgoto out_no_read;\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tmsg[i] = array_er32(VMBMEM(0), i);\n\n\t \n\tew32(V2PMAILBOX(0), E1000_V2PMAILBOX_ACK);\n\n\t \n\thw->mbx.stats.msgs_rx++;\n\nout_no_read:\n\treturn err;\n}\n\n \ns32 e1000_init_mbx_params_vf(struct e1000_hw *hw)\n{\n\tstruct e1000_mbx_info *mbx = &hw->mbx;\n\n\t \n\tmbx->timeout = 0;\n\tmbx->usec_delay = E1000_VF_MBX_INIT_DELAY;\n\n\tmbx->size = E1000_VFMAILBOX_SIZE;\n\n\tmbx->ops.read = e1000_read_mbx_vf;\n\tmbx->ops.write = e1000_write_mbx_vf;\n\tmbx->ops.read_posted = e1000_read_posted_mbx;\n\tmbx->ops.write_posted = e1000_write_posted_mbx;\n\tmbx->ops.check_for_msg = e1000_check_for_msg_vf;\n\tmbx->ops.check_for_ack = e1000_check_for_ack_vf;\n\tmbx->ops.check_for_rst = e1000_check_for_rst_vf;\n\n\tmbx->stats.msgs_tx = 0;\n\tmbx->stats.msgs_rx = 0;\n\tmbx->stats.reqs = 0;\n\tmbx->stats.acks = 0;\n\tmbx->stats.rsts = 0;\n\n\treturn E1000_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}