{
  "module_name": "hclge_ptp.c",
  "hash_id": "211d85f81fc3553359fa2d0c40787c9b1c32551e133b713646afb2da68479bb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c",
  "human_readable_source": "\n\n\n#include <linux/skbuff.h>\n#include \"hclge_main.h\"\n#include \"hnae3.h\"\n\nstatic int hclge_ptp_get_cycle(struct hclge_dev *hdev)\n{\n\tstruct hclge_ptp *ptp = hdev->ptp;\n\n\tptp->cycle.quo = readl(hdev->ptp->io_base + HCLGE_PTP_CYCLE_QUO_REG) &\n\t\t\t HCLGE_PTP_CYCLE_QUO_MASK;\n\tptp->cycle.numer = readl(hdev->ptp->io_base + HCLGE_PTP_CYCLE_NUM_REG);\n\tptp->cycle.den = readl(hdev->ptp->io_base + HCLGE_PTP_CYCLE_DEN_REG);\n\n\tif (ptp->cycle.den == 0) {\n\t\tdev_err(&hdev->pdev->dev, \"invalid ptp cycle denominator!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct hclge_dev *hdev = hclge_ptp_get_hdev(ptp);\n\tstruct hclge_ptp_cycle *cycle = &hdev->ptp->cycle;\n\tu64 adj_val, adj_base;\n\tunsigned long flags;\n\tu32 quo, numerator;\n\n\tadj_base = (u64)cycle->quo * (u64)cycle->den + (u64)cycle->numer;\n\tadj_val = adjust_by_scaled_ppm(adj_base, scaled_ppm);\n\n\t \n\tquo = div_u64_rem(adj_val, cycle->den, &numerator);\n\n\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\twritel(quo & HCLGE_PTP_CYCLE_QUO_MASK,\n\t       hdev->ptp->io_base + HCLGE_PTP_CYCLE_QUO_REG);\n\twritel(numerator, hdev->ptp->io_base + HCLGE_PTP_CYCLE_NUM_REG);\n\twritel(cycle->den, hdev->ptp->io_base + HCLGE_PTP_CYCLE_DEN_REG);\n\twritel(HCLGE_PTP_CYCLE_ADJ_EN,\n\t       hdev->ptp->io_base + HCLGE_PTP_CYCLE_CFG_REG);\n\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n\n\treturn 0;\n}\n\nbool hclge_ptp_set_tx_info(struct hnae3_handle *handle, struct sk_buff *skb)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_ptp *ptp = hdev->ptp;\n\n\tif (!test_bit(HCLGE_PTP_FLAG_TX_EN, &ptp->flags) ||\n\t    test_and_set_bit(HCLGE_STATE_PTP_TX_HANDLING, &hdev->state)) {\n\t\tptp->tx_skipped++;\n\t\treturn false;\n\t}\n\n\tptp->tx_start = jiffies;\n\tptp->tx_skb = skb_get(skb);\n\tptp->tx_cnt++;\n\n\treturn true;\n}\n\nvoid hclge_ptp_clean_tx_hwts(struct hclge_dev *hdev)\n{\n\tstruct sk_buff *skb = hdev->ptp->tx_skb;\n\tstruct skb_shared_hwtstamps hwts;\n\tu32 hi, lo;\n\tu64 ns;\n\n\tns = readl(hdev->ptp->io_base + HCLGE_PTP_TX_TS_NSEC_REG) &\n\t     HCLGE_PTP_TX_TS_NSEC_MASK;\n\tlo = readl(hdev->ptp->io_base + HCLGE_PTP_TX_TS_SEC_L_REG);\n\thi = readl(hdev->ptp->io_base + HCLGE_PTP_TX_TS_SEC_H_REG) &\n\t     HCLGE_PTP_TX_TS_SEC_H_MASK;\n\thdev->ptp->last_tx_seqid = readl(hdev->ptp->io_base +\n\t\tHCLGE_PTP_TX_TS_SEQID_REG);\n\n\tif (skb) {\n\t\thdev->ptp->tx_skb = NULL;\n\t\thdev->ptp->tx_cleaned++;\n\n\t\tns += (((u64)hi) << 32 | lo) * NSEC_PER_SEC;\n\t\thwts.hwtstamp = ns_to_ktime(ns);\n\t\tskb_tstamp_tx(skb, &hwts);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\tclear_bit(HCLGE_STATE_PTP_TX_HANDLING, &hdev->state);\n}\n\nvoid hclge_ptp_get_rx_hwts(struct hnae3_handle *handle, struct sk_buff *skb,\n\t\t\t   u32 nsec, u32 sec)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tunsigned long flags;\n\tu64 ns = nsec;\n\tu32 sec_h;\n\n\tif (!test_bit(HCLGE_PTP_FLAG_RX_EN, &hdev->ptp->flags))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\tsec_h = readl(hdev->ptp->io_base + HCLGE_PTP_CUR_TIME_SEC_H_REG);\n\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n\n\tns += (((u64)sec_h) << HCLGE_PTP_SEC_H_OFFSET | sec) * NSEC_PER_SEC;\n\tskb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);\n\thdev->ptp->last_rx = jiffies;\n\thdev->ptp->rx_cnt++;\n}\n\nstatic int hclge_ptp_gettimex(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t      struct ptp_system_timestamp *sts)\n{\n\tstruct hclge_dev *hdev = hclge_ptp_get_hdev(ptp);\n\tunsigned long flags;\n\tu32 hi, lo;\n\tu64 ns;\n\n\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\tns = readl(hdev->ptp->io_base + HCLGE_PTP_CUR_TIME_NSEC_REG);\n\thi = readl(hdev->ptp->io_base + HCLGE_PTP_CUR_TIME_SEC_H_REG);\n\tlo = readl(hdev->ptp->io_base + HCLGE_PTP_CUR_TIME_SEC_L_REG);\n\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n\n\tns += (((u64)hi) << HCLGE_PTP_SEC_H_OFFSET | lo) * NSEC_PER_SEC;\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int hclge_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t     const struct timespec64 *ts)\n{\n\tstruct hclge_dev *hdev = hclge_ptp_get_hdev(ptp);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\twritel(ts->tv_nsec, hdev->ptp->io_base + HCLGE_PTP_TIME_NSEC_REG);\n\twritel(ts->tv_sec >> HCLGE_PTP_SEC_H_OFFSET,\n\t       hdev->ptp->io_base + HCLGE_PTP_TIME_SEC_H_REG);\n\twritel(ts->tv_sec & HCLGE_PTP_SEC_L_MASK,\n\t       hdev->ptp->io_base + HCLGE_PTP_TIME_SEC_L_REG);\n\t \n\twritel(HCLGE_PTP_TIME_SYNC_EN,\n\t       hdev->ptp->io_base + HCLGE_PTP_TIME_SYNC_REG);\n\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n\n\treturn 0;\n}\n\nstatic int hclge_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct hclge_dev *hdev = hclge_ptp_get_hdev(ptp);\n\tunsigned long flags;\n\tbool is_neg = false;\n\tu32 adj_val = 0;\n\n\tif (delta < 0) {\n\t\tadj_val |= HCLGE_PTP_TIME_NSEC_NEG;\n\t\tdelta = -delta;\n\t\tis_neg = true;\n\t}\n\n\tif (delta > HCLGE_PTP_TIME_NSEC_MASK) {\n\t\tstruct timespec64 ts;\n\t\ts64 ns;\n\n\t\thclge_ptp_gettimex(ptp, &ts, NULL);\n\t\tns = timespec64_to_ns(&ts);\n\t\tns = is_neg ? ns - delta : ns + delta;\n\t\tts = ns_to_timespec64(ns);\n\t\treturn hclge_ptp_settime(ptp, &ts);\n\t}\n\n\tadj_val |= delta & HCLGE_PTP_TIME_NSEC_MASK;\n\n\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\twritel(adj_val, hdev->ptp->io_base + HCLGE_PTP_TIME_NSEC_REG);\n\twritel(HCLGE_PTP_TIME_ADJ_EN,\n\t       hdev->ptp->io_base + HCLGE_PTP_TIME_ADJ_REG);\n\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n\n\treturn 0;\n}\n\nint hclge_ptp_get_cfg(struct hclge_dev *hdev, struct ifreq *ifr)\n{\n\tif (!test_bit(HCLGE_STATE_PTP_EN, &hdev->state))\n\t\treturn -EOPNOTSUPP;\n\n\treturn copy_to_user(ifr->ifr_data, &hdev->ptp->ts_cfg,\n\t\tsizeof(struct hwtstamp_config)) ? -EFAULT : 0;\n}\n\nstatic int hclge_ptp_int_en(struct hclge_dev *hdev, bool en)\n{\n\tstruct hclge_ptp_int_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\treq = (struct hclge_ptp_int_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PTP_INT_EN, false);\n\treq->int_en = en ? 1 : 0;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to %s ptp interrupt, ret = %d\\n\",\n\t\t\ten ? \"enable\" : \"disable\", ret);\n\n\treturn ret;\n}\n\nint hclge_ptp_cfg_qry(struct hclge_dev *hdev, u32 *cfg)\n{\n\tstruct hclge_ptp_cfg_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\treq = (struct hclge_ptp_cfg_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PTP_MODE_CFG, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to query ptp config, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*cfg = le32_to_cpu(req->cfg);\n\n\treturn 0;\n}\n\nstatic int hclge_ptp_cfg(struct hclge_dev *hdev, u32 cfg)\n{\n\tstruct hclge_ptp_cfg_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\treq = (struct hclge_ptp_cfg_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PTP_MODE_CFG, false);\n\treq->cfg = cpu_to_le32(cfg);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to config ptp, ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_ptp_set_tx_mode(struct hwtstamp_config *cfg,\n\t\t\t\t unsigned long *flags, u32 *ptp_cfg)\n{\n\tswitch (cfg->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tclear_bit(HCLGE_PTP_FLAG_TX_EN, flags);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tset_bit(HCLGE_PTP_FLAG_TX_EN, flags);\n\t\t*ptp_cfg |= HCLGE_PTP_TX_EN_B;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_ptp_set_rx_mode(struct hwtstamp_config *cfg,\n\t\t\t\t unsigned long *flags, u32 *ptp_cfg)\n{\n\tint rx_filter = cfg->rx_filter;\n\n\tswitch (cfg->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tclear_bit(HCLGE_PTP_FLAG_RX_EN, flags);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\tset_bit(HCLGE_PTP_FLAG_RX_EN, flags);\n\t\t*ptp_cfg |= HCLGE_PTP_RX_EN_B;\n\t\t*ptp_cfg |= HCLGE_PTP_UDP_FULL_TYPE << HCLGE_PTP_UDP_EN_SHIFT;\n\t\trx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tset_bit(HCLGE_PTP_FLAG_RX_EN, flags);\n\t\t*ptp_cfg |= HCLGE_PTP_RX_EN_B;\n\t\t*ptp_cfg |= HCLGE_PTP_UDP_FULL_TYPE << HCLGE_PTP_UDP_EN_SHIFT;\n\t\t*ptp_cfg |= HCLGE_PTP_MSG1_V2_DEFAULT << HCLGE_PTP_MSG1_SHIFT;\n\t\t*ptp_cfg |= HCLGE_PTP_MSG0_V2_EVENT << HCLGE_PTP_MSG0_SHIFT;\n\t\t*ptp_cfg |= HCLGE_PTP_MSG_TYPE_V2 << HCLGE_PTP_MSG_TYPE_SHIFT;\n\t\trx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tcfg->rx_filter = rx_filter;\n\n\treturn 0;\n}\n\nstatic int hclge_ptp_set_ts_mode(struct hclge_dev *hdev,\n\t\t\t\t struct hwtstamp_config *cfg)\n{\n\tunsigned long flags = hdev->ptp->flags;\n\tu32 ptp_cfg = 0;\n\tint ret;\n\n\tif (test_bit(HCLGE_PTP_FLAG_EN, &hdev->ptp->flags))\n\t\tptp_cfg |= HCLGE_PTP_EN_B;\n\n\tret = hclge_ptp_set_tx_mode(cfg, &flags, &ptp_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_ptp_set_rx_mode(cfg, &flags, &ptp_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_ptp_cfg(hdev, ptp_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->ptp->flags = flags;\n\thdev->ptp->ptp_cfg = ptp_cfg;\n\n\treturn 0;\n}\n\nint hclge_ptp_set_cfg(struct hclge_dev *hdev, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config cfg;\n\tint ret;\n\n\tif (!test_bit(HCLGE_STATE_PTP_EN, &hdev->state)) {\n\t\tdev_err(&hdev->pdev->dev, \"phc is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tret = hclge_ptp_set_ts_mode(hdev, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->ptp->ts_cfg = cfg;\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nint hclge_ptp_get_ts_info(struct hnae3_handle *handle,\n\t\t\t  struct ethtool_ts_info *info)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (!test_bit(HCLGE_STATE_PTP_EN, &hdev->state)) {\n\t\tdev_err(&hdev->pdev->dev, \"phc is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tif (hdev->ptp->clock)\n\t\tinfo->phc_index = ptp_clock_index(hdev->ptp->clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ);\n\n\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);\n\n\treturn 0;\n}\n\nstatic int hclge_ptp_create_clock(struct hclge_dev *hdev)\n{\n\tstruct hclge_ptp *ptp;\n\n\tptp = devm_kzalloc(&hdev->pdev->dev, sizeof(*ptp), GFP_KERNEL);\n\tif (!ptp)\n\t\treturn -ENOMEM;\n\n\tptp->hdev = hdev;\n\tsnprintf(ptp->info.name, sizeof(ptp->info.name), \"%s\",\n\t\t HCLGE_DRIVER_NAME);\n\tptp->info.owner = THIS_MODULE;\n\tptp->info.max_adj = HCLGE_PTP_CYCLE_ADJ_MAX;\n\tptp->info.n_ext_ts = 0;\n\tptp->info.pps = 0;\n\tptp->info.adjfine = hclge_ptp_adjfine;\n\tptp->info.adjtime = hclge_ptp_adjtime;\n\tptp->info.gettimex64 = hclge_ptp_gettimex;\n\tptp->info.settime64 = hclge_ptp_settime;\n\n\tptp->info.n_alarm = 0;\n\tptp->clock = ptp_clock_register(&ptp->info, &hdev->pdev->dev);\n\tif (IS_ERR(ptp->clock)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"%d failed to register ptp clock, ret = %ld\\n\",\n\t\t\tptp->info.n_alarm, PTR_ERR(ptp->clock));\n\t\treturn -ENODEV;\n\t} else if (!ptp->clock) {\n\t\tdev_err(&hdev->pdev->dev, \"failed to register ptp clock\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_init(&ptp->lock);\n\tptp->io_base = hdev->hw.hw.io_base + HCLGE_PTP_REG_OFFSET;\n\tptp->ts_cfg.rx_filter = HWTSTAMP_FILTER_NONE;\n\tptp->ts_cfg.tx_type = HWTSTAMP_TX_OFF;\n\thdev->ptp = ptp;\n\n\treturn 0;\n}\n\nstatic void hclge_ptp_destroy_clock(struct hclge_dev *hdev)\n{\n\tptp_clock_unregister(hdev->ptp->clock);\n\thdev->ptp->clock = NULL;\n\tdevm_kfree(&hdev->pdev->dev, hdev->ptp);\n\thdev->ptp = NULL;\n}\n\nint hclge_ptp_init(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tstruct timespec64 ts;\n\tint ret;\n\n\tif (!test_bit(HNAE3_DEV_SUPPORT_PTP_B, ae_dev->caps))\n\t\treturn 0;\n\n\tif (!hdev->ptp) {\n\t\tret = hclge_ptp_create_clock(hdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_ptp_get_cycle(hdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hclge_ptp_int_en(hdev, true);\n\tif (ret)\n\t\tgoto out;\n\n\tset_bit(HCLGE_PTP_FLAG_EN, &hdev->ptp->flags);\n\tret = hclge_ptp_adjfine(&hdev->ptp->info, 0);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to init freq, ret = %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = hclge_ptp_set_ts_mode(hdev, &hdev->ptp->ts_cfg);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to init ts mode, ret = %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tktime_get_real_ts64(&ts);\n\tret = hclge_ptp_settime(&hdev->ptp->info, &ts);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to init ts time, ret = %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tset_bit(HCLGE_STATE_PTP_EN, &hdev->state);\n\tdev_info(&hdev->pdev->dev, \"phc initializes ok!\\n\");\n\n\treturn 0;\n\nout:\n\thclge_ptp_destroy_clock(hdev);\n\n\treturn ret;\n}\n\nvoid hclge_ptp_uninit(struct hclge_dev *hdev)\n{\n\tstruct hclge_ptp *ptp = hdev->ptp;\n\n\tif (!ptp)\n\t\treturn;\n\n\thclge_ptp_int_en(hdev, false);\n\tclear_bit(HCLGE_STATE_PTP_EN, &hdev->state);\n\tclear_bit(HCLGE_PTP_FLAG_EN, &ptp->flags);\n\tptp->ts_cfg.rx_filter = HWTSTAMP_FILTER_NONE;\n\tptp->ts_cfg.tx_type = HWTSTAMP_TX_OFF;\n\n\tif (hclge_ptp_set_ts_mode(hdev, &ptp->ts_cfg))\n\t\tdev_err(&hdev->pdev->dev, \"failed to disable phc\\n\");\n\n\tif (ptp->tx_skb) {\n\t\tstruct sk_buff *skb = ptp->tx_skb;\n\n\t\tptp->tx_skb = NULL;\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\thclge_ptp_destroy_clock(hdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}