{
  "module_name": "hclge_debugfs.c",
  "hash_id": "7a23e4cb3649814818aefcf92711efb0d5d16c885f00c888f5a0a7137de072b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/sched/clock.h>\n\n#include \"hclge_debugfs.h\"\n#include \"hclge_err.h\"\n#include \"hclge_main.h\"\n#include \"hclge_regs.h\"\n#include \"hclge_tm.h\"\n#include \"hnae3.h\"\n\nstatic const char * const state_str[] = { \"off\", \"on\" };\nstatic const char * const hclge_mac_state_str[] = {\n\t\"TO_ADD\", \"TO_DEL\", \"ACTIVE\"\n};\n\nstatic const char * const tc_map_mode_str[] = { \"PRIO\", \"DSCP\" };\n\nstatic const struct hclge_dbg_reg_type_info hclge_dbg_reg_info[] = {\n\t{ .cmd = HNAE3_DBG_CMD_REG_BIOS_COMMON,\n\t  .dfx_msg = &hclge_dbg_bios_common_reg[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_bios_common_reg),\n\t\t       .offset = HCLGE_DBG_DFX_BIOS_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_BIOS_COMMON_REG } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_SSU,\n\t  .dfx_msg = &hclge_dbg_ssu_reg_0[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_ssu_reg_0),\n\t\t       .offset = HCLGE_DBG_DFX_SSU_0_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_SSU_REG_0 } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_SSU,\n\t  .dfx_msg = &hclge_dbg_ssu_reg_1[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_ssu_reg_1),\n\t\t       .offset = HCLGE_DBG_DFX_SSU_1_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_SSU_REG_1 } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_SSU,\n\t  .dfx_msg = &hclge_dbg_ssu_reg_2[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_ssu_reg_2),\n\t\t       .offset = HCLGE_DBG_DFX_SSU_2_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_SSU_REG_2 } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_IGU_EGU,\n\t  .dfx_msg = &hclge_dbg_igu_egu_reg[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_igu_egu_reg),\n\t\t       .offset = HCLGE_DBG_DFX_IGU_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_IGU_EGU_REG } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_RPU,\n\t  .dfx_msg = &hclge_dbg_rpu_reg_0[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_rpu_reg_0),\n\t\t       .offset = HCLGE_DBG_DFX_RPU_0_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_RPU_REG_0 } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_RPU,\n\t  .dfx_msg = &hclge_dbg_rpu_reg_1[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_rpu_reg_1),\n\t\t       .offset = HCLGE_DBG_DFX_RPU_1_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_RPU_REG_1 } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_NCSI,\n\t  .dfx_msg = &hclge_dbg_ncsi_reg[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_ncsi_reg),\n\t\t       .offset = HCLGE_DBG_DFX_NCSI_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_NCSI_REG } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_RTC,\n\t  .dfx_msg = &hclge_dbg_rtc_reg[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_rtc_reg),\n\t\t       .offset = HCLGE_DBG_DFX_RTC_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_RTC_REG } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_PPP,\n\t  .dfx_msg = &hclge_dbg_ppp_reg[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_ppp_reg),\n\t\t       .offset = HCLGE_DBG_DFX_PPP_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_PPP_REG } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_RCB,\n\t  .dfx_msg = &hclge_dbg_rcb_reg[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_rcb_reg),\n\t\t       .offset = HCLGE_DBG_DFX_RCB_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_RCB_REG } },\n\t{ .cmd = HNAE3_DBG_CMD_REG_TQP,\n\t  .dfx_msg = &hclge_dbg_tqp_reg[0],\n\t  .reg_msg = { .msg_num = ARRAY_SIZE(hclge_dbg_tqp_reg),\n\t\t       .offset = HCLGE_DBG_DFX_TQP_OFFSET,\n\t\t       .cmd = HCLGE_OPC_DFX_TQP_REG } },\n};\n\n \nstatic void hclge_dbg_fill_content(char *content, u16 len,\n\t\t\t\t   const struct hclge_dbg_item *items,\n\t\t\t\t   const char **result, u16 size)\n{\n#define HCLGE_DBG_LINE_END_LEN\t2\n\tchar *pos = content;\n\tu16 item_len;\n\tu16 i;\n\n\tif (!len) {\n\t\treturn;\n\t} else if (len <= HCLGE_DBG_LINE_END_LEN) {\n\t\t*pos++ = '\\0';\n\t\treturn;\n\t}\n\n\tmemset(content, ' ', len);\n\tlen -= HCLGE_DBG_LINE_END_LEN;\n\n\tfor (i = 0; i < size; i++) {\n\t\titem_len = strlen(items[i].name) + items[i].interval;\n\t\tif (len < item_len)\n\t\t\tbreak;\n\n\t\tif (result) {\n\t\t\tif (item_len < strlen(result[i]))\n\t\t\t\tbreak;\n\t\t\tmemcpy(pos, result[i], strlen(result[i]));\n\t\t} else {\n\t\t\tmemcpy(pos, items[i].name, strlen(items[i].name));\n\t\t}\n\t\tpos += item_len;\n\t\tlen -= item_len;\n\t}\n\t*pos++ = '\\n';\n\t*pos++ = '\\0';\n}\n\nstatic char *hclge_dbg_get_func_id_str(char *buf, u8 id)\n{\n\tif (id)\n\t\tsprintf(buf, \"vf%u\", id - 1U);\n\telse\n\t\tsprintf(buf, \"pf\");\n\n\treturn buf;\n}\n\nstatic int hclge_dbg_get_dfx_bd_num(struct hclge_dev *hdev, int offset,\n\t\t\t\t    u32 *bd_num)\n{\n\tstruct hclge_desc desc[HCLGE_GET_DFX_REG_TYPE_CNT];\n\tint entries_per_desc;\n\tint index;\n\tint ret;\n\n\tret = hclge_query_bd_num_cmd_send(hdev, desc);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get dfx bd_num, offset = %d, ret = %d\\n\",\n\t\t\toffset, ret);\n\t\treturn ret;\n\t}\n\n\tentries_per_desc = ARRAY_SIZE(desc[0].data);\n\tindex = offset % entries_per_desc;\n\n\t*bd_num = le32_to_cpu(desc[offset / entries_per_desc].data[index]);\n\tif (!(*bd_num)) {\n\t\tdev_err(&hdev->pdev->dev, \"The value of dfx bd_num is 0!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_cmd_send(struct hclge_dev *hdev,\n\t\t\t      struct hclge_desc *desc_src,\n\t\t\t      int index, int bd_num,\n\t\t\t      enum hclge_opcode_type cmd)\n{\n\tstruct hclge_desc *desc = desc_src;\n\tint ret, i;\n\n\thclge_cmd_setup_basic_desc(desc, cmd, true);\n\tdesc->data[0] = cpu_to_le32(index);\n\n\tfor (i = 1; i < bd_num; i++) {\n\t\tdesc->flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\tdesc++;\n\t\thclge_cmd_setup_basic_desc(desc, cmd, true);\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, desc_src, bd_num);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"cmd(0x%x) send fail, ret = %d\\n\", cmd, ret);\n\treturn ret;\n}\n\nstatic int\nhclge_dbg_dump_reg_tqp(struct hclge_dev *hdev,\n\t\t       const struct hclge_dbg_reg_type_info *reg_info,\n\t\t       char *buf, int len, int *pos)\n{\n\tconst struct hclge_dbg_dfx_message *dfx_message = reg_info->dfx_msg;\n\tconst struct hclge_dbg_reg_common_msg *reg_msg = &reg_info->reg_msg;\n\tstruct hclge_desc *desc_src;\n\tu32 index, entry, i, cnt;\n\tint bd_num, min_num, ret;\n\tstruct hclge_desc *desc;\n\n\tret = hclge_dbg_get_dfx_bd_num(hdev, reg_msg->offset, &bd_num);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc_src = kcalloc(bd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc_src)\n\t\treturn -ENOMEM;\n\n\tmin_num = min_t(int, bd_num * HCLGE_DESC_DATA_LEN, reg_msg->msg_num);\n\n\tfor (i = 0, cnt = 0; i < min_num; i++, dfx_message++)\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"item%u = %s\\n\",\n\t\t\t\t  cnt++, dfx_message->message);\n\n\tfor (i = 0; i < cnt; i++)\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"item%u\\t\", i);\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"\\n\");\n\n\tfor (index = 0; index < hdev->vport[0].alloc_tqps; index++) {\n\t\tdfx_message = reg_info->dfx_msg;\n\t\tdesc = desc_src;\n\t\tret = hclge_dbg_cmd_send(hdev, desc, index, bd_num,\n\t\t\t\t\t reg_msg->cmd);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < min_num; i++, dfx_message++) {\n\t\t\tentry = i % HCLGE_DESC_DATA_LEN;\n\t\t\tif (i > 0 && !entry)\n\t\t\t\tdesc++;\n\n\t\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%#x\\t\",\n\t\t\t\t\t  le32_to_cpu(desc->data[entry]));\n\t\t}\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"\\n\");\n\t}\n\n\tkfree(desc_src);\n\treturn ret;\n}\n\nstatic int\nhclge_dbg_dump_reg_common(struct hclge_dev *hdev,\n\t\t\t  const struct hclge_dbg_reg_type_info *reg_info,\n\t\t\t  char *buf, int len, int *pos)\n{\n\tconst struct hclge_dbg_reg_common_msg *reg_msg = &reg_info->reg_msg;\n\tconst struct hclge_dbg_dfx_message *dfx_message = reg_info->dfx_msg;\n\tstruct hclge_desc *desc_src;\n\tint bd_num, min_num, ret;\n\tstruct hclge_desc *desc;\n\tu32 entry, i;\n\n\tret = hclge_dbg_get_dfx_bd_num(hdev, reg_msg->offset, &bd_num);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc_src = kcalloc(bd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc_src)\n\t\treturn -ENOMEM;\n\n\tdesc = desc_src;\n\n\tret = hclge_dbg_cmd_send(hdev, desc, 0, bd_num, reg_msg->cmd);\n\tif (ret) {\n\t\tkfree(desc);\n\t\treturn ret;\n\t}\n\n\tmin_num = min_t(int, bd_num * HCLGE_DESC_DATA_LEN, reg_msg->msg_num);\n\n\tfor (i = 0; i < min_num; i++, dfx_message++) {\n\t\tentry = i % HCLGE_DESC_DATA_LEN;\n\t\tif (i > 0 && !entry)\n\t\t\tdesc++;\n\t\tif (!dfx_message->flag)\n\t\t\tcontinue;\n\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%s: %#x\\n\",\n\t\t\t\t  dfx_message->message,\n\t\t\t\t  le32_to_cpu(desc->data[entry]));\n\t}\n\n\tkfree(desc_src);\n\treturn 0;\n}\n\nstatic const struct hclge_dbg_status_dfx_info hclge_dbg_mac_en_status[] = {\n\t{HCLGE_MAC_TX_EN_B,  \"mac_trans_en\"},\n\t{HCLGE_MAC_RX_EN_B,  \"mac_rcv_en\"},\n\t{HCLGE_MAC_PAD_TX_B, \"pad_trans_en\"},\n\t{HCLGE_MAC_PAD_RX_B, \"pad_rcv_en\"},\n\t{HCLGE_MAC_1588_TX_B, \"1588_trans_en\"},\n\t{HCLGE_MAC_1588_RX_B, \"1588_rcv_en\"},\n\t{HCLGE_MAC_APP_LP_B,  \"mac_app_loop_en\"},\n\t{HCLGE_MAC_LINE_LP_B, \"mac_line_loop_en\"},\n\t{HCLGE_MAC_FCS_TX_B,  \"mac_fcs_tx_en\"},\n\t{HCLGE_MAC_RX_OVERSIZE_TRUNCATE_B, \"mac_rx_oversize_truncate_en\"},\n\t{HCLGE_MAC_RX_FCS_STRIP_B, \"mac_rx_fcs_strip_en\"},\n\t{HCLGE_MAC_RX_FCS_B, \"mac_rx_fcs_en\"},\n\t{HCLGE_MAC_TX_UNDER_MIN_ERR_B, \"mac_tx_under_min_err_en\"},\n\t{HCLGE_MAC_TX_OVERSIZE_TRUNCATE_B, \"mac_tx_oversize_truncate_en\"}\n};\n\nstatic int  hclge_dbg_dump_mac_enable_status(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t     int len, int *pos)\n{\n\tstruct hclge_config_mac_mode_cmd *req;\n\tstruct hclge_desc desc;\n\tu32 loop_en, i, offset;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAC_MODE, true);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump mac enable status, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treq = (struct hclge_config_mac_mode_cmd *)desc.data;\n\tloop_en = le32_to_cpu(req->txrx_pad_fcs_loop_en);\n\n\tfor (i = 0; i < ARRAY_SIZE(hclge_dbg_mac_en_status); i++) {\n\t\toffset = hclge_dbg_mac_en_status[i].offset;\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%s: %#x\\n\",\n\t\t\t\t  hclge_dbg_mac_en_status[i].message,\n\t\t\t\t  hnae3_get_bit(loop_en, offset));\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_mac_frame_size(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t int len, int *pos)\n{\n\tstruct hclge_config_max_frm_size_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAX_FRM_SIZE, true);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump mac frame size, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treq = (struct hclge_config_max_frm_size_cmd *)desc.data;\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"max_frame_size: %u\\n\",\n\t\t\t  le16_to_cpu(req->max_frm_size));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"min_frame_size: %u\\n\",\n\t\t\t  req->min_frm_size);\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_mac_speed_duplex(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t   int len, int *pos)\n{\n#define HCLGE_MAC_SPEED_SHIFT\t0\n#define HCLGE_MAC_SPEED_MASK\tGENMASK(5, 0)\n#define HCLGE_MAC_DUPLEX_SHIFT\t7\n\n\tstruct hclge_config_mac_speed_dup_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_SPEED_DUP, true);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump mac speed duplex, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treq = (struct hclge_config_mac_speed_dup_cmd *)desc.data;\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"speed: %#lx\\n\",\n\t\t\t  hnae3_get_field(req->speed_dup, HCLGE_MAC_SPEED_MASK,\n\t\t\t\t\t  HCLGE_MAC_SPEED_SHIFT));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"duplex: %#x\\n\",\n\t\t\t  hnae3_get_bit(req->speed_dup,\n\t\t\t\t\tHCLGE_MAC_DUPLEX_SHIFT));\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_mac(struct hclge_dev *hdev, char *buf, int len)\n{\n\tint pos = 0;\n\tint ret;\n\n\tret = hclge_dbg_dump_mac_enable_status(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_dbg_dump_mac_frame_size(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_dbg_dump_mac_speed_duplex(hdev, buf, len, &pos);\n}\n\nstatic int hclge_dbg_dump_dcb_qset(struct hclge_dev *hdev, char *buf, int len,\n\t\t\t\t   int *pos)\n{\n\tstruct hclge_dbg_bitmap_cmd req;\n\tstruct hclge_desc desc;\n\tu16 qset_id, qset_num;\n\tint ret;\n\n\tret = hclge_tm_get_qset_num(hdev, &qset_num);\n\tif (ret)\n\t\treturn ret;\n\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"qset_id  roce_qset_mask  nic_qset_mask  qset_shaping_pass  qset_bp_status\\n\");\n\tfor (qset_id = 0; qset_id < qset_num; qset_id++) {\n\t\tret = hclge_dbg_cmd_send(hdev, &desc, qset_id, 1,\n\t\t\t\t\t HCLGE_OPC_QSET_DFX_STS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treq.bitmap = (u8)le32_to_cpu(desc.data[1]);\n\n\t\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t\t  \"%04u           %#x            %#x             %#x               %#x\\n\",\n\t\t\t\t  qset_id, req.bit0, req.bit1, req.bit2,\n\t\t\t\t  req.bit3);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_dcb_pri(struct hclge_dev *hdev, char *buf, int len,\n\t\t\t\t  int *pos)\n{\n\tstruct hclge_dbg_bitmap_cmd req;\n\tstruct hclge_desc desc;\n\tu8 pri_id, pri_num;\n\tint ret;\n\n\tret = hclge_tm_get_pri_num(hdev, &pri_num);\n\tif (ret)\n\t\treturn ret;\n\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"pri_id  pri_mask  pri_cshaping_pass  pri_pshaping_pass\\n\");\n\tfor (pri_id = 0; pri_id < pri_num; pri_id++) {\n\t\tret = hclge_dbg_cmd_send(hdev, &desc, pri_id, 1,\n\t\t\t\t\t HCLGE_OPC_PRI_DFX_STS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treq.bitmap = (u8)le32_to_cpu(desc.data[1]);\n\n\t\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t\t  \"%03u       %#x           %#x                %#x\\n\",\n\t\t\t\t  pri_id, req.bit0, req.bit1, req.bit2);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_dcb_pg(struct hclge_dev *hdev, char *buf, int len,\n\t\t\t\t int *pos)\n{\n\tstruct hclge_dbg_bitmap_cmd req;\n\tstruct hclge_desc desc;\n\tu8 pg_id;\n\tint ret;\n\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"pg_id  pg_mask  pg_cshaping_pass  pg_pshaping_pass\\n\");\n\tfor (pg_id = 0; pg_id < hdev->tm_info.num_pg; pg_id++) {\n\t\tret = hclge_dbg_cmd_send(hdev, &desc, pg_id, 1,\n\t\t\t\t\t HCLGE_OPC_PG_DFX_STS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treq.bitmap = (u8)le32_to_cpu(desc.data[1]);\n\n\t\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t\t  \"%03u      %#x           %#x               %#x\\n\",\n\t\t\t\t  pg_id, req.bit0, req.bit1, req.bit2);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_dcb_queue(struct hclge_dev *hdev, char *buf, int len,\n\t\t\t\t    int *pos)\n{\n\tstruct hclge_desc desc;\n\tu16 nq_id;\n\tint ret;\n\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"nq_id  sch_nic_queue_cnt  sch_roce_queue_cnt\\n\");\n\tfor (nq_id = 0; nq_id < hdev->num_tqps; nq_id++) {\n\t\tret = hclge_dbg_cmd_send(hdev, &desc, nq_id, 1,\n\t\t\t\t\t HCLGE_OPC_SCH_NQ_CNT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%04u           %#x\",\n\t\t\t\t  nq_id, le32_to_cpu(desc.data[1]));\n\n\t\tret = hclge_dbg_cmd_send(hdev, &desc, nq_id, 1,\n\t\t\t\t\t HCLGE_OPC_SCH_RQ_CNT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t\t  \"               %#x\\n\",\n\t\t\t\t  le32_to_cpu(desc.data[1]));\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_dcb_port(struct hclge_dev *hdev, char *buf, int len,\n\t\t\t\t   int *pos)\n{\n\tstruct hclge_dbg_bitmap_cmd req;\n\tstruct hclge_desc desc;\n\tu8 port_id = 0;\n\tint ret;\n\n\tret = hclge_dbg_cmd_send(hdev, &desc, port_id, 1,\n\t\t\t\t HCLGE_OPC_PORT_DFX_STS);\n\tif (ret)\n\t\treturn ret;\n\n\treq.bitmap = (u8)le32_to_cpu(desc.data[1]);\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"port_mask: %#x\\n\",\n\t\t\t req.bit0);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"port_shaping_pass: %#x\\n\",\n\t\t\t req.bit1);\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_dcb_tm(struct hclge_dev *hdev, char *buf, int len,\n\t\t\t\t int *pos)\n{\n\tstruct hclge_desc desc[2];\n\tu8 port_id = 0;\n\tint ret;\n\n\tret = hclge_dbg_cmd_send(hdev, desc, port_id, 1,\n\t\t\t\t HCLGE_OPC_TM_INTERNAL_CNT);\n\tif (ret)\n\t\treturn ret;\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"SCH_NIC_NUM: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[1]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"SCH_ROCE_NUM: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[2]));\n\n\tret = hclge_dbg_cmd_send(hdev, desc, port_id, 2,\n\t\t\t\t HCLGE_OPC_TM_INTERNAL_STS);\n\tif (ret)\n\t\treturn ret;\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"pri_bp: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[1]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"fifo_dfx_info: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[2]));\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"sch_roce_fifo_afull_gap: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[3]));\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"tx_private_waterline: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[4]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"tm_bypass_en: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[5]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"SSU_TM_BYPASS_EN: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[1].data[0]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"SSU_RESERVE_CFG: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[1].data[1]));\n\n\tif (hdev->hw.mac.media_type == HNAE3_MEDIA_TYPE_COPPER)\n\t\treturn 0;\n\n\tret = hclge_dbg_cmd_send(hdev, desc, port_id, 1,\n\t\t\t\t HCLGE_OPC_TM_INTERNAL_STS_1);\n\tif (ret)\n\t\treturn ret;\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"TC_MAP_SEL: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[1]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"IGU_PFC_PRI_EN: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[2]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAC_PFC_PRI_EN: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[3]));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"IGU_PRI_MAP_TC_CFG: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[4]));\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"IGU_TX_PRI_MAP_TC_CFG: %#x\\n\",\n\t\t\t  le32_to_cpu(desc[0].data[5]));\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_dcb(struct hclge_dev *hdev, char *buf, int len)\n{\n\tint pos = 0;\n\tint ret;\n\n\tret = hclge_dbg_dump_dcb_qset(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_dbg_dump_dcb_pri(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_dbg_dump_dcb_pg(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_dbg_dump_dcb_queue(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_dbg_dump_dcb_port(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_dbg_dump_dcb_tm(hdev, buf, len, &pos);\n}\n\nstatic int hclge_dbg_dump_reg_cmd(struct hclge_dev *hdev,\n\t\t\t\t  enum hnae3_dbg_cmd cmd, char *buf, int len)\n{\n\tconst struct hclge_dbg_reg_type_info *reg_info;\n\tint pos = 0, ret = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hclge_dbg_reg_info); i++) {\n\t\treg_info = &hclge_dbg_reg_info[i];\n\t\tif (cmd == reg_info->cmd) {\n\t\t\tif (cmd == HNAE3_DBG_CMD_REG_TQP)\n\t\t\t\treturn hclge_dbg_dump_reg_tqp(hdev, reg_info,\n\t\t\t\t\t\t\t      buf, len, &pos);\n\n\t\t\tret = hclge_dbg_dump_reg_common(hdev, reg_info, buf,\n\t\t\t\t\t\t\tlen, &pos);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int hclge_dbg_dump_tc(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct hclge_ets_tc_weight_cmd *ets_weight;\n\tstruct hclge_desc desc;\n\tchar *sch_mode_str;\n\tint pos = 0;\n\tint ret;\n\tu8 i;\n\n\tif (!hnae3_dev_dcb_supported(hdev)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Only DCB-supported dev supports tc\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_ETS_TC_WEIGHT, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"failed to get tc weight, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tets_weight = (struct hclge_ets_tc_weight_cmd *)desc.data;\n\n\tpos += scnprintf(buf + pos, len - pos, \"enabled tc number: %u\\n\",\n\t\t\t hdev->tm_info.num_tc);\n\tpos += scnprintf(buf + pos, len - pos, \"weight_offset: %u\\n\",\n\t\t\t ets_weight->weight_offset);\n\n\tpos += scnprintf(buf + pos, len - pos, \"TC    MODE  WEIGHT\\n\");\n\tfor (i = 0; i < HNAE3_MAX_TC; i++) {\n\t\tsch_mode_str = ets_weight->tc_weight[i] ? \"dwrr\" : \"sp\";\n\t\tpos += scnprintf(buf + pos, len - pos, \"%u     %4s    %3u\\n\",\n\t\t\t\t i, sch_mode_str, ets_weight->tc_weight[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hclge_dbg_item tm_pg_items[] = {\n\t{ \"ID\", 2 },\n\t{ \"PRI_MAP\", 2 },\n\t{ \"MODE\", 2 },\n\t{ \"DWRR\", 2 },\n\t{ \"C_IR_B\", 2 },\n\t{ \"C_IR_U\", 2 },\n\t{ \"C_IR_S\", 2 },\n\t{ \"C_BS_B\", 2 },\n\t{ \"C_BS_S\", 2 },\n\t{ \"C_FLAG\", 2 },\n\t{ \"C_RATE(Mbps)\", 2 },\n\t{ \"P_IR_B\", 2 },\n\t{ \"P_IR_U\", 2 },\n\t{ \"P_IR_S\", 2 },\n\t{ \"P_BS_B\", 2 },\n\t{ \"P_BS_S\", 2 },\n\t{ \"P_FLAG\", 2 },\n\t{ \"P_RATE(Mbps)\", 0 }\n};\n\nstatic void hclge_dbg_fill_shaper_content(struct hclge_tm_shaper_para *para,\n\t\t\t\t\t  char **result, u8 *index)\n{\n\tsprintf(result[(*index)++], \"%3u\", para->ir_b);\n\tsprintf(result[(*index)++], \"%3u\", para->ir_u);\n\tsprintf(result[(*index)++], \"%3u\", para->ir_s);\n\tsprintf(result[(*index)++], \"%3u\", para->bs_b);\n\tsprintf(result[(*index)++], \"%3u\", para->bs_s);\n\tsprintf(result[(*index)++], \"%3u\", para->flag);\n\tsprintf(result[(*index)++], \"%6u\", para->rate);\n}\n\nstatic int __hclge_dbg_dump_tm_pg(struct hclge_dev *hdev, char *data_str,\n\t\t\t\t  char *buf, int len)\n{\n\tstruct hclge_tm_shaper_para c_shaper_para, p_shaper_para;\n\tchar *result[ARRAY_SIZE(tm_pg_items)], *sch_mode_str;\n\tu8 pg_id, sch_mode, weight, pri_bit_map, i, j;\n\tchar content[HCLGE_DBG_TM_INFO_LEN];\n\tint pos = 0;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_pg_items); i++) {\n\t\tresult[i] = data_str;\n\t\tdata_str += HCLGE_DBG_DATA_STR_LEN;\n\t}\n\n\thclge_dbg_fill_content(content, sizeof(content), tm_pg_items,\n\t\t\t       NULL, ARRAY_SIZE(tm_pg_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\n\tfor (pg_id = 0; pg_id < hdev->tm_info.num_pg; pg_id++) {\n\t\tret = hclge_tm_get_pg_to_pri_map(hdev, pg_id, &pri_bit_map);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_pg_sch_mode(hdev, pg_id, &sch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_pg_weight(hdev, pg_id, &weight);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_pg_shaper(hdev, pg_id,\n\t\t\t\t\t     HCLGE_OPC_TM_PG_C_SHAPPING,\n\t\t\t\t\t     &c_shaper_para);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_pg_shaper(hdev, pg_id,\n\t\t\t\t\t     HCLGE_OPC_TM_PG_P_SHAPPING,\n\t\t\t\t\t     &p_shaper_para);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsch_mode_str = sch_mode & HCLGE_TM_TX_SCHD_DWRR_MSK ? \"dwrr\" :\n\t\t\t\t       \"sp\";\n\n\t\tj = 0;\n\t\tsprintf(result[j++], \"%02u\", pg_id);\n\t\tsprintf(result[j++], \"0x%02x\", pri_bit_map);\n\t\tsprintf(result[j++], \"%4s\", sch_mode_str);\n\t\tsprintf(result[j++], \"%3u\", weight);\n\t\thclge_dbg_fill_shaper_content(&c_shaper_para, result, &j);\n\t\thclge_dbg_fill_shaper_content(&p_shaper_para, result, &j);\n\n\t\thclge_dbg_fill_content(content, sizeof(content), tm_pg_items,\n\t\t\t\t       (const char **)result,\n\t\t\t\t       ARRAY_SIZE(tm_pg_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_tm_pg(struct hclge_dev *hdev, char *buf, int len)\n{\n\tchar *data_str;\n\tint ret;\n\n\tdata_str = kcalloc(ARRAY_SIZE(tm_pg_items),\n\t\t\t   HCLGE_DBG_DATA_STR_LEN, GFP_KERNEL);\n\tif (!data_str)\n\t\treturn -ENOMEM;\n\n\tret = __hclge_dbg_dump_tm_pg(hdev, data_str, buf, len);\n\n\tkfree(data_str);\n\n\treturn ret;\n}\n\nstatic int hclge_dbg_dump_tm_port(struct hclge_dev *hdev,  char *buf, int len)\n{\n\tstruct hclge_tm_shaper_para shaper_para;\n\tint pos = 0;\n\tint ret;\n\n\tret = hclge_tm_get_port_shaper(hdev, &shaper_para);\n\tif (ret)\n\t\treturn ret;\n\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"IR_B  IR_U  IR_S  BS_B  BS_S  FLAG  RATE(Mbps)\\n\");\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"%3u   %3u   %3u   %3u   %3u     %1u   %6u\\n\",\n\t\t\t shaper_para.ir_b, shaper_para.ir_u, shaper_para.ir_s,\n\t\t\t shaper_para.bs_b, shaper_para.bs_s, shaper_para.flag,\n\t\t\t shaper_para.rate);\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_tm_bp_qset_map(struct hclge_dev *hdev, u8 tc_id,\n\t\t\t\t\t char *buf, int len)\n{\n\tu32 qset_mapping[HCLGE_BP_EXT_GRP_NUM];\n\tstruct hclge_bp_to_qs_map_cmd *map;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tu8 group_id;\n\tu8 grp_num;\n\tu16 i = 0;\n\tint ret;\n\n\tgrp_num = hdev->num_tqps <= HCLGE_TQP_MAX_SIZE_DEV_V2 ?\n\t\t  HCLGE_BP_GRP_NUM : HCLGE_BP_EXT_GRP_NUM;\n\tmap = (struct hclge_bp_to_qs_map_cmd *)desc.data;\n\tfor (group_id = 0; group_id < grp_num; group_id++) {\n\t\thclge_cmd_setup_basic_desc(&desc,\n\t\t\t\t\t   HCLGE_OPC_TM_BP_TO_QSET_MAPPING,\n\t\t\t\t\t   true);\n\t\tmap->tc_id = tc_id;\n\t\tmap->qs_group_id = group_id;\n\t\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to get bp to qset map, ret = %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tqset_mapping[group_id] = le32_to_cpu(map->qs_bit_map);\n\t}\n\n\tpos += scnprintf(buf + pos, len - pos, \"INDEX | TM BP QSET MAPPING:\\n\");\n\tfor (group_id = 0; group_id < grp_num / 8; group_id++) {\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"%04d  | %08x:%08x:%08x:%08x:%08x:%08x:%08x:%08x\\n\",\n\t\t\t group_id * 256, qset_mapping[i + 7],\n\t\t\t qset_mapping[i + 6], qset_mapping[i + 5],\n\t\t\t qset_mapping[i + 4], qset_mapping[i + 3],\n\t\t\t qset_mapping[i + 2], qset_mapping[i + 1],\n\t\t\t qset_mapping[i]);\n\t\ti += 8;\n\t}\n\n\treturn pos;\n}\n\nstatic int hclge_dbg_dump_tm_map(struct hclge_dev *hdev, char *buf, int len)\n{\n\tu16 queue_id;\n\tu16 qset_id;\n\tu8 link_vld;\n\tint pos = 0;\n\tu8 pri_id;\n\tu8 tc_id;\n\tint ret;\n\n\tfor (queue_id = 0; queue_id < hdev->num_tqps; queue_id++) {\n\t\tret = hclge_tm_get_q_to_qs_map(hdev, queue_id, &qset_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_qset_map_pri(hdev, qset_id, &pri_id,\n\t\t\t\t\t\t&link_vld);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_q_to_tc(hdev, queue_id, &tc_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"QUEUE_ID   QSET_ID   PRI_ID   TC_ID\\n\");\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"%04u        %4u       %3u      %2u\\n\",\n\t\t\t\t queue_id, qset_id, pri_id, tc_id);\n\n\t\tif (!hnae3_dev_dcb_supported(hdev))\n\t\t\tcontinue;\n\n\t\tret = hclge_dbg_dump_tm_bp_qset_map(hdev, tc_id, buf + pos,\n\t\t\t\t\t\t    len - pos);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpos += ret;\n\n\t\tpos += scnprintf(buf + pos, len - pos, \"\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_tm_nodes(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct hclge_tm_nodes_cmd *nodes;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_TM_NODES, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump tm nodes, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnodes = (struct hclge_tm_nodes_cmd *)desc.data;\n\n\tpos += scnprintf(buf + pos, len - pos, \"       BASE_ID  MAX_NUM\\n\");\n\tpos += scnprintf(buf + pos, len - pos, \"PG      %4u      %4u\\n\",\n\t\t\t nodes->pg_base_id, nodes->pg_num);\n\tpos += scnprintf(buf + pos, len - pos, \"PRI     %4u      %4u\\n\",\n\t\t\t nodes->pri_base_id, nodes->pri_num);\n\tpos += scnprintf(buf + pos, len - pos, \"QSET    %4u      %4u\\n\",\n\t\t\t le16_to_cpu(nodes->qset_base_id),\n\t\t\t le16_to_cpu(nodes->qset_num));\n\tpos += scnprintf(buf + pos, len - pos, \"QUEUE   %4u      %4u\\n\",\n\t\t\t le16_to_cpu(nodes->queue_base_id),\n\t\t\t le16_to_cpu(nodes->queue_num));\n\n\treturn 0;\n}\n\nstatic const struct hclge_dbg_item tm_pri_items[] = {\n\t{ \"ID\", 4 },\n\t{ \"MODE\", 2 },\n\t{ \"DWRR\", 2 },\n\t{ \"C_IR_B\", 2 },\n\t{ \"C_IR_U\", 2 },\n\t{ \"C_IR_S\", 2 },\n\t{ \"C_BS_B\", 2 },\n\t{ \"C_BS_S\", 2 },\n\t{ \"C_FLAG\", 2 },\n\t{ \"C_RATE(Mbps)\", 2 },\n\t{ \"P_IR_B\", 2 },\n\t{ \"P_IR_U\", 2 },\n\t{ \"P_IR_S\", 2 },\n\t{ \"P_BS_B\", 2 },\n\t{ \"P_BS_S\", 2 },\n\t{ \"P_FLAG\", 2 },\n\t{ \"P_RATE(Mbps)\", 0 }\n};\n\nstatic int hclge_dbg_dump_tm_pri(struct hclge_dev *hdev, char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(tm_pri_items)][HCLGE_DBG_DATA_STR_LEN];\n\tstruct hclge_tm_shaper_para c_shaper_para, p_shaper_para;\n\tchar *result[ARRAY_SIZE(tm_pri_items)], *sch_mode_str;\n\tchar content[HCLGE_DBG_TM_INFO_LEN];\n\tu8 pri_num, sch_mode, weight, i, j;\n\tint pos, ret;\n\n\tret = hclge_tm_get_pri_num(hdev, &pri_num);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_pri_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\thclge_dbg_fill_content(content, sizeof(content), tm_pri_items,\n\t\t\t       NULL, ARRAY_SIZE(tm_pri_items));\n\tpos = scnprintf(buf, len, \"%s\", content);\n\n\tfor (i = 0; i < pri_num; i++) {\n\t\tret = hclge_tm_get_pri_sch_mode(hdev, i, &sch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_pri_weight(hdev, i, &weight);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_pri_shaper(hdev, i,\n\t\t\t\t\t      HCLGE_OPC_TM_PRI_C_SHAPPING,\n\t\t\t\t\t      &c_shaper_para);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_pri_shaper(hdev, i,\n\t\t\t\t\t      HCLGE_OPC_TM_PRI_P_SHAPPING,\n\t\t\t\t\t      &p_shaper_para);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsch_mode_str = sch_mode & HCLGE_TM_TX_SCHD_DWRR_MSK ? \"dwrr\" :\n\t\t\t       \"sp\";\n\n\t\tj = 0;\n\t\tsprintf(result[j++], \"%04u\", i);\n\t\tsprintf(result[j++], \"%4s\", sch_mode_str);\n\t\tsprintf(result[j++], \"%3u\", weight);\n\t\thclge_dbg_fill_shaper_content(&c_shaper_para, result, &j);\n\t\thclge_dbg_fill_shaper_content(&p_shaper_para, result, &j);\n\t\thclge_dbg_fill_content(content, sizeof(content), tm_pri_items,\n\t\t\t\t       (const char **)result,\n\t\t\t\t       ARRAY_SIZE(tm_pri_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hclge_dbg_item tm_qset_items[] = {\n\t{ \"ID\", 4 },\n\t{ \"MAP_PRI\", 2 },\n\t{ \"LINK_VLD\", 2 },\n\t{ \"MODE\", 2 },\n\t{ \"DWRR\", 2 },\n\t{ \"IR_B\", 2 },\n\t{ \"IR_U\", 2 },\n\t{ \"IR_S\", 2 },\n\t{ \"BS_B\", 2 },\n\t{ \"BS_S\", 2 },\n\t{ \"FLAG\", 2 },\n\t{ \"RATE(Mbps)\", 0 }\n};\n\nstatic int hclge_dbg_dump_tm_qset(struct hclge_dev *hdev, char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(tm_qset_items)][HCLGE_DBG_DATA_STR_LEN];\n\tchar *result[ARRAY_SIZE(tm_qset_items)], *sch_mode_str;\n\tu8 priority, link_vld, sch_mode, weight;\n\tstruct hclge_tm_shaper_para shaper_para;\n\tchar content[HCLGE_DBG_TM_INFO_LEN];\n\tu16 qset_num, i;\n\tint ret, pos;\n\tu8 j;\n\n\tret = hclge_tm_get_qset_num(hdev, &qset_num);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_qset_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\thclge_dbg_fill_content(content, sizeof(content), tm_qset_items,\n\t\t\t       NULL, ARRAY_SIZE(tm_qset_items));\n\tpos = scnprintf(buf, len, \"%s\", content);\n\n\tfor (i = 0; i < qset_num; i++) {\n\t\tret = hclge_tm_get_qset_map_pri(hdev, i, &priority, &link_vld);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_qset_sch_mode(hdev, i, &sch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_qset_weight(hdev, i, &weight);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_tm_get_qset_shaper(hdev, i, &shaper_para);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsch_mode_str = sch_mode & HCLGE_TM_TX_SCHD_DWRR_MSK ? \"dwrr\" :\n\t\t\t       \"sp\";\n\n\t\tj = 0;\n\t\tsprintf(result[j++], \"%04u\", i);\n\t\tsprintf(result[j++], \"%4u\", priority);\n\t\tsprintf(result[j++], \"%4u\", link_vld);\n\t\tsprintf(result[j++], \"%4s\", sch_mode_str);\n\t\tsprintf(result[j++], \"%3u\", weight);\n\t\thclge_dbg_fill_shaper_content(&shaper_para, result, &j);\n\n\t\thclge_dbg_fill_content(content, sizeof(content), tm_qset_items,\n\t\t\t\t       (const char **)result,\n\t\t\t\t       ARRAY_SIZE(tm_qset_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_qos_pause_cfg(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\tint len)\n{\n\tstruct hclge_cfg_pause_param_cmd *pause_param;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CFG_MAC_PARA, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump qos pause, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpause_param = (struct hclge_cfg_pause_param_cmd *)desc.data;\n\n\tpos += scnprintf(buf + pos, len - pos, \"pause_trans_gap: 0x%x\\n\",\n\t\t\t pause_param->pause_trans_gap);\n\tpos += scnprintf(buf + pos, len - pos, \"pause_trans_time: 0x%x\\n\",\n\t\t\t le16_to_cpu(pause_param->pause_trans_time));\n\treturn 0;\n}\n\n#define HCLGE_DBG_TC_MASK\t\t0x0F\n\nstatic int hclge_dbg_dump_qos_pri_map(struct hclge_dev *hdev, char *buf,\n\t\t\t\t      int len)\n{\n#define HCLGE_DBG_TC_BIT_WIDTH\t\t4\n\n\tstruct hclge_qos_pri_map_cmd *pri_map;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tu8 *pri_tc;\n\tu8 tc, i;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PRI_TO_TC_MAPPING, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump qos pri map, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpri_map = (struct hclge_qos_pri_map_cmd *)desc.data;\n\n\tpos += scnprintf(buf + pos, len - pos, \"vlan_to_pri: 0x%x\\n\",\n\t\t\t pri_map->vlan_pri);\n\tpos += scnprintf(buf + pos, len - pos, \"PRI  TC\\n\");\n\n\tpri_tc = (u8 *)pri_map;\n\tfor (i = 0; i < HNAE3_MAX_TC; i++) {\n\t\ttc = pri_tc[i >> 1] >> ((i & 1) * HCLGE_DBG_TC_BIT_WIDTH);\n\t\ttc &= HCLGE_DBG_TC_MASK;\n\t\tpos += scnprintf(buf + pos, len - pos, \"%u     %u\\n\", i, tc);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_qos_dscp_map(struct hclge_dev *hdev, char *buf,\n\t\t\t\t       int len)\n{\n\tstruct hnae3_knic_private_info *kinfo = &hdev->vport[0].nic.kinfo;\n\tstruct hclge_desc desc[HCLGE_DSCP_MAP_TC_BD_NUM];\n\tu8 *req0 = (u8 *)desc[0].data;\n\tu8 *req1 = (u8 *)desc[1].data;\n\tu8 dscp_tc[HNAE3_MAX_DSCP];\n\tint pos, ret;\n\tu8 i, j;\n\n\tpos = scnprintf(buf, len, \"tc map mode: %s\\n\",\n\t\t\ttc_map_mode_str[kinfo->tc_map_mode]);\n\n\tif (kinfo->tc_map_mode != HNAE3_TC_MAP_MODE_DSCP)\n\t\treturn 0;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_QOS_MAP, true);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_OPC_QOS_MAP, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, HCLGE_DSCP_MAP_TC_BD_NUM);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump qos dscp map, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpos += scnprintf(buf + pos, len - pos, \"\\nDSCP  PRIO  TC\\n\");\n\n\t \n\tfor (i = 0; i < HNAE3_MAX_DSCP / HCLGE_DSCP_MAP_TC_BD_NUM; i++) {\n\t\tj = i + HNAE3_MAX_DSCP / HCLGE_DSCP_MAP_TC_BD_NUM;\n\t\t \n\t\tdscp_tc[i] = req0[i >> 1] >> HCLGE_DSCP_TC_SHIFT(i);\n\t\tdscp_tc[j] = req1[i >> 1] >> HCLGE_DSCP_TC_SHIFT(i);\n\t\tdscp_tc[i] &= HCLGE_DBG_TC_MASK;\n\t\tdscp_tc[j] &= HCLGE_DBG_TC_MASK;\n\t}\n\n\tfor (i = 0; i < HNAE3_MAX_DSCP; i++) {\n\t\tif (kinfo->dscp_prio[i] == HNAE3_PRIO_ID_INVALID)\n\t\t\tcontinue;\n\n\t\tpos += scnprintf(buf + pos, len - pos, \" %2u    %u    %u\\n\",\n\t\t\t\t i, kinfo->dscp_prio[i], dscp_tc[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_tx_buf_cfg(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct hclge_tx_buff_alloc_cmd *tx_buf_cmd;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tint i, ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_TX_BUFF_ALLOC, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump tx buf, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttx_buf_cmd = (struct hclge_tx_buff_alloc_cmd *)desc.data;\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++)\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"tx_packet_buf_tc_%d: 0x%x\\n\", i,\n\t\t\t\t le16_to_cpu(tx_buf_cmd->tx_pkt_buff[i]));\n\n\treturn pos;\n}\n\nstatic int hclge_dbg_dump_rx_priv_buf_cfg(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t  int len)\n{\n\tstruct hclge_rx_priv_buff_cmd *rx_buf_cmd;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tint i, ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_RX_PRIV_BUFF_ALLOC, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump rx priv buf, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpos += scnprintf(buf + pos, len - pos, \"\\n\");\n\n\trx_buf_cmd = (struct hclge_rx_priv_buff_cmd *)desc.data;\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++)\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"rx_packet_buf_tc_%d: 0x%x\\n\", i,\n\t\t\t\t le16_to_cpu(rx_buf_cmd->buf_num[i]));\n\n\tpos += scnprintf(buf + pos, len - pos, \"rx_share_buf: 0x%x\\n\",\n\t\t\t le16_to_cpu(rx_buf_cmd->shared_buf));\n\n\treturn pos;\n}\n\nstatic int hclge_dbg_dump_rx_common_wl_cfg(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t   int len)\n{\n\tstruct hclge_rx_com_wl *rx_com_wl;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_RX_COM_WL_ALLOC, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump rx common wl, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trx_com_wl = (struct hclge_rx_com_wl *)desc.data;\n\tpos += scnprintf(buf + pos, len - pos, \"\\n\");\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"rx_com_wl: high: 0x%x, low: 0x%x\\n\",\n\t\t\t le16_to_cpu(rx_com_wl->com_wl.high),\n\t\t\t le16_to_cpu(rx_com_wl->com_wl.low));\n\n\treturn pos;\n}\n\nstatic int hclge_dbg_dump_rx_global_pkt_cnt(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t    int len)\n{\n\tstruct hclge_rx_com_wl *rx_packet_cnt;\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_RX_GBL_PKT_CNT, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump rx global pkt cnt, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trx_packet_cnt = (struct hclge_rx_com_wl *)desc.data;\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"rx_global_packet_cnt: high: 0x%x, low: 0x%x\\n\",\n\t\t\t le16_to_cpu(rx_packet_cnt->com_wl.high),\n\t\t\t le16_to_cpu(rx_packet_cnt->com_wl.low));\n\n\treturn pos;\n}\n\nstatic int hclge_dbg_dump_rx_priv_wl_buf_cfg(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t     int len)\n{\n\tstruct hclge_rx_priv_wl_buf *rx_priv_wl;\n\tstruct hclge_desc desc[2];\n\tint pos = 0;\n\tint i, ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_RX_PRIV_WL_ALLOC, true);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_OPC_RX_PRIV_WL_ALLOC, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, 2);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump rx priv wl buf, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trx_priv_wl = (struct hclge_rx_priv_wl_buf *)desc[0].data;\n\tfor (i = 0; i < HCLGE_TC_NUM_ONE_DESC; i++)\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"rx_priv_wl_tc_%d: high: 0x%x, low: 0x%x\\n\", i,\n\t\t\t le16_to_cpu(rx_priv_wl->tc_wl[i].high),\n\t\t\t le16_to_cpu(rx_priv_wl->tc_wl[i].low));\n\n\trx_priv_wl = (struct hclge_rx_priv_wl_buf *)desc[1].data;\n\tfor (i = 0; i < HCLGE_TC_NUM_ONE_DESC; i++)\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"rx_priv_wl_tc_%d: high: 0x%x, low: 0x%x\\n\",\n\t\t\t i + HCLGE_TC_NUM_ONE_DESC,\n\t\t\t le16_to_cpu(rx_priv_wl->tc_wl[i].high),\n\t\t\t le16_to_cpu(rx_priv_wl->tc_wl[i].low));\n\n\treturn pos;\n}\n\nstatic int hclge_dbg_dump_rx_common_threshold_cfg(struct hclge_dev *hdev,\n\t\t\t\t\t\t  char *buf, int len)\n{\n\tstruct hclge_rx_com_thrd *rx_com_thrd;\n\tstruct hclge_desc desc[2];\n\tint pos = 0;\n\tint i, ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_RX_COM_THRD_ALLOC, true);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_OPC_RX_COM_THRD_ALLOC, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, 2);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump rx common threshold, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpos += scnprintf(buf + pos, len - pos, \"\\n\");\n\trx_com_thrd = (struct hclge_rx_com_thrd *)desc[0].data;\n\tfor (i = 0; i < HCLGE_TC_NUM_ONE_DESC; i++)\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"rx_com_thrd_tc_%d: high: 0x%x, low: 0x%x\\n\", i,\n\t\t\t le16_to_cpu(rx_com_thrd->com_thrd[i].high),\n\t\t\t le16_to_cpu(rx_com_thrd->com_thrd[i].low));\n\n\trx_com_thrd = (struct hclge_rx_com_thrd *)desc[1].data;\n\tfor (i = 0; i < HCLGE_TC_NUM_ONE_DESC; i++)\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"rx_com_thrd_tc_%d: high: 0x%x, low: 0x%x\\n\",\n\t\t\t i + HCLGE_TC_NUM_ONE_DESC,\n\t\t\t le16_to_cpu(rx_com_thrd->com_thrd[i].high),\n\t\t\t le16_to_cpu(rx_com_thrd->com_thrd[i].low));\n\n\treturn pos;\n}\n\nstatic int hclge_dbg_dump_qos_buf_cfg(struct hclge_dev *hdev, char *buf,\n\t\t\t\t      int len)\n{\n\tint pos = 0;\n\tint ret;\n\n\tret = hclge_dbg_dump_tx_buf_cfg(hdev, buf + pos, len - pos);\n\tif (ret < 0)\n\t\treturn ret;\n\tpos += ret;\n\n\tret = hclge_dbg_dump_rx_priv_buf_cfg(hdev, buf + pos, len - pos);\n\tif (ret < 0)\n\t\treturn ret;\n\tpos += ret;\n\n\tret = hclge_dbg_dump_rx_common_wl_cfg(hdev, buf + pos, len - pos);\n\tif (ret < 0)\n\t\treturn ret;\n\tpos += ret;\n\n\tret = hclge_dbg_dump_rx_global_pkt_cnt(hdev, buf + pos, len - pos);\n\tif (ret < 0)\n\t\treturn ret;\n\tpos += ret;\n\n\tpos += scnprintf(buf + pos, len - pos, \"\\n\");\n\tif (!hnae3_dev_dcb_supported(hdev))\n\t\treturn 0;\n\n\tret = hclge_dbg_dump_rx_priv_wl_buf_cfg(hdev, buf + pos, len - pos);\n\tif (ret < 0)\n\t\treturn ret;\n\tpos += ret;\n\n\tret = hclge_dbg_dump_rx_common_threshold_cfg(hdev, buf + pos,\n\t\t\t\t\t\t     len - pos);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_mng_table(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct hclge_mac_ethertype_idx_rd_cmd *req0;\n\tstruct hclge_desc desc;\n\tu32 msg_egress_port;\n\tint pos = 0;\n\tint ret, i;\n\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"entry  mac_addr          mask  ether  \");\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"mask  vlan  mask  i_map  i_dir  e_type  \");\n\tpos += scnprintf(buf + pos, len - pos, \"pf_id  vf_id  q_id  drop\\n\");\n\n\tfor (i = 0; i < HCLGE_DBG_MNG_TBL_MAX; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc, HCLGE_MAC_ETHERTYPE_IDX_RD,\n\t\t\t\t\t   true);\n\t\treq0 = (struct hclge_mac_ethertype_idx_rd_cmd *)&desc.data;\n\t\treq0->index = cpu_to_le16(i);\n\n\t\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to dump manage table, ret = %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!req0->resp_code)\n\t\t\tcontinue;\n\n\t\tpos += scnprintf(buf + pos, len - pos, \"%02u     %pM \",\n\t\t\t\t le16_to_cpu(req0->index), req0->mac_addr);\n\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"%x     %04x   %x     %04x  \",\n\t\t\t\t !!(req0->flags & HCLGE_DBG_MNG_MAC_MASK_B),\n\t\t\t\t le16_to_cpu(req0->ethter_type),\n\t\t\t\t !!(req0->flags & HCLGE_DBG_MNG_ETHER_MASK_B),\n\t\t\t\t le16_to_cpu(req0->vlan_tag) &\n\t\t\t\t HCLGE_DBG_MNG_VLAN_TAG);\n\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"%x     %02x     %02x     \",\n\t\t\t\t !!(req0->flags & HCLGE_DBG_MNG_VLAN_MASK_B),\n\t\t\t\t req0->i_port_bitmap, req0->i_port_direction);\n\n\t\tmsg_egress_port = le16_to_cpu(req0->egress_port);\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"%x       %x      %02x     %04x  %x\\n\",\n\t\t\t\t !!(msg_egress_port & HCLGE_DBG_MNG_E_TYPE_B),\n\t\t\t\t msg_egress_port & HCLGE_DBG_MNG_PF_ID,\n\t\t\t\t (msg_egress_port >> 3) & HCLGE_DBG_MNG_VF_ID,\n\t\t\t\t le16_to_cpu(req0->egress_queue),\n\t\t\t\t !!(msg_egress_port & HCLGE_DBG_MNG_DROP_B));\n\t}\n\n\treturn 0;\n}\n\n#define HCLGE_DBG_TCAM_BUF_SIZE 256\n\nstatic int hclge_dbg_fd_tcam_read(struct hclge_dev *hdev, bool sel_x,\n\t\t\t\t  char *tcam_buf,\n\t\t\t\t  struct hclge_dbg_tcam_msg tcam_msg)\n{\n\tstruct hclge_fd_tcam_config_1_cmd *req1;\n\tstruct hclge_fd_tcam_config_2_cmd *req2;\n\tstruct hclge_fd_tcam_config_3_cmd *req3;\n\tstruct hclge_desc desc[3];\n\tint pos = 0;\n\tint ret, i;\n\t__le32 *req;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_FD_TCAM_OP, true);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_OPC_FD_TCAM_OP, true);\n\tdesc[1].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[2], HCLGE_OPC_FD_TCAM_OP, true);\n\n\treq1 = (struct hclge_fd_tcam_config_1_cmd *)desc[0].data;\n\treq2 = (struct hclge_fd_tcam_config_2_cmd *)desc[1].data;\n\treq3 = (struct hclge_fd_tcam_config_3_cmd *)desc[2].data;\n\n\treq1->stage  = tcam_msg.stage;\n\treq1->xy_sel = sel_x ? 1 : 0;\n\treq1->index  = cpu_to_le32(tcam_msg.loc);\n\n\tret = hclge_cmd_send(&hdev->hw, desc, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tpos += scnprintf(tcam_buf + pos, HCLGE_DBG_TCAM_BUF_SIZE - pos,\n\t\t\t \"read result tcam key %s(%u):\\n\", sel_x ? \"x\" : \"y\",\n\t\t\t tcam_msg.loc);\n\n\t \n\treq = (__le32 *)req1->tcam_data;\n\tfor (i = 0; i < 2; i++)\n\t\tpos += scnprintf(tcam_buf + pos, HCLGE_DBG_TCAM_BUF_SIZE - pos,\n\t\t\t\t \"%08x\\n\", le32_to_cpu(*req++));\n\n\t \n\treq = (__le32 *)req2->tcam_data;\n\tfor (i = 0; i < 6; i++)\n\t\tpos += scnprintf(tcam_buf + pos, HCLGE_DBG_TCAM_BUF_SIZE - pos,\n\t\t\t\t \"%08x\\n\", le32_to_cpu(*req++));\n\n\t \n\treq = (__le32 *)req3->tcam_data;\n\tfor (i = 0; i < 5; i++)\n\t\tpos += scnprintf(tcam_buf + pos, HCLGE_DBG_TCAM_BUF_SIZE - pos,\n\t\t\t\t \"%08x\\n\", le32_to_cpu(*req++));\n\n\treturn ret;\n}\n\nstatic int hclge_dbg_get_rules_location(struct hclge_dev *hdev, u16 *rule_locs)\n{\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\tint cnt = 0;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\thlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {\n\t\trule_locs[cnt] = rule->location;\n\t\tcnt++;\n\t}\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\n\tif (cnt != hdev->hclge_fd_rule_num || cnt == 0)\n\t\treturn -EINVAL;\n\n\treturn cnt;\n}\n\nstatic int hclge_dbg_dump_fd_tcam(struct hclge_dev *hdev, char *buf, int len)\n{\n\tu32 rule_num = hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1];\n\tstruct hclge_dbg_tcam_msg tcam_msg;\n\tint i, ret, rule_cnt;\n\tu16 *rule_locs;\n\tchar *tcam_buf;\n\tint pos = 0;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Only FD-supported dev supports dump fd tcam\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!hdev->hclge_fd_rule_num || !rule_num)\n\t\treturn 0;\n\n\trule_locs = kcalloc(rule_num, sizeof(u16), GFP_KERNEL);\n\tif (!rule_locs)\n\t\treturn -ENOMEM;\n\n\ttcam_buf = kzalloc(HCLGE_DBG_TCAM_BUF_SIZE, GFP_KERNEL);\n\tif (!tcam_buf) {\n\t\tkfree(rule_locs);\n\t\treturn -ENOMEM;\n\t}\n\n\trule_cnt = hclge_dbg_get_rules_location(hdev, rule_locs);\n\tif (rule_cnt < 0) {\n\t\tret = rule_cnt;\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get rule number, ret = %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tfor (i = 0; i < rule_cnt; i++) {\n\t\ttcam_msg.stage = HCLGE_FD_STAGE_1;\n\t\ttcam_msg.loc = rule_locs[i];\n\n\t\tret = hclge_dbg_fd_tcam_read(hdev, true, tcam_buf, tcam_msg);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to get fd tcam key x, ret = %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", tcam_buf);\n\n\t\tret = hclge_dbg_fd_tcam_read(hdev, false, tcam_buf, tcam_msg);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to get fd tcam key y, ret = %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", tcam_buf);\n\t}\n\nout:\n\tkfree(tcam_buf);\n\tkfree(rule_locs);\n\treturn ret;\n}\n\nstatic int hclge_dbg_dump_fd_counter(struct hclge_dev *hdev, char *buf, int len)\n{\n\tu8 func_num = pci_num_vf(hdev->pdev) + 1;  \n\tstruct hclge_fd_ad_cnt_read_cmd *req;\n\tchar str_id[HCLGE_DBG_ID_LEN];\n\tstruct hclge_desc desc;\n\tint pos = 0;\n\tint ret;\n\tu64 cnt;\n\tu8 i;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"func_id\\thit_times\\n\");\n\n\tfor (i = 0; i < func_num; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_FD_CNT_OP, true);\n\t\treq = (struct hclge_fd_ad_cnt_read_cmd *)desc.data;\n\t\treq->index = cpu_to_le16(i);\n\t\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev, \"failed to get fd counter, ret = %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tcnt = le64_to_cpu(req->cnt);\n\t\thclge_dbg_get_func_id_str(str_id, i);\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"%s\\t%llu\\n\", str_id, cnt);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hclge_dbg_status_dfx_info hclge_dbg_rst_info[] = {\n\t{HCLGE_MISC_VECTOR_REG_BASE, \"vector0 interrupt enable status\"},\n\t{HCLGE_MISC_RESET_STS_REG,   \"reset interrupt source\"},\n\t{HCLGE_MISC_VECTOR_INT_STS,  \"reset interrupt status\"},\n\t{HCLGE_RAS_PF_OTHER_INT_STS_REG, \"RAS interrupt status\"},\n\t{HCLGE_GLOBAL_RESET_REG,  \"hardware reset status\"},\n\t{HCLGE_NIC_CSQ_DEPTH_REG, \"handshake status\"},\n\t{HCLGE_FUN_RST_ING, \"function reset status\"}\n};\n\nint hclge_dbg_dump_rst_info(struct hclge_dev *hdev, char *buf, int len)\n{\n\tu32 i, offset;\n\tint pos = 0;\n\n\tpos += scnprintf(buf + pos, len - pos, \"PF reset count: %u\\n\",\n\t\t\t hdev->rst_stats.pf_rst_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"FLR reset count: %u\\n\",\n\t\t\t hdev->rst_stats.flr_rst_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"GLOBAL reset count: %u\\n\",\n\t\t\t hdev->rst_stats.global_rst_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"IMP reset count: %u\\n\",\n\t\t\t hdev->rst_stats.imp_rst_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"reset done count: %u\\n\",\n\t\t\t hdev->rst_stats.reset_done_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"HW reset done count: %u\\n\",\n\t\t\t hdev->rst_stats.hw_reset_done_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"reset count: %u\\n\",\n\t\t\t hdev->rst_stats.reset_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"reset fail count: %u\\n\",\n\t\t\t hdev->rst_stats.reset_fail_cnt);\n\n\tfor (i = 0; i < ARRAY_SIZE(hclge_dbg_rst_info); i++) {\n\t\toffset = hclge_dbg_rst_info[i].offset;\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s: 0x%x\\n\",\n\t\t\t\t hclge_dbg_rst_info[i].message,\n\t\t\t\t hclge_read_dev(&hdev->hw, offset));\n\t}\n\n\tpos += scnprintf(buf + pos, len - pos, \"hdev state: 0x%lx\\n\",\n\t\t\t hdev->state);\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_serv_info(struct hclge_dev *hdev, char *buf, int len)\n{\n\tunsigned long rem_nsec;\n\tint pos = 0;\n\tu64 lc;\n\n\tlc = local_clock();\n\trem_nsec = do_div(lc, HCLGE_BILLION_NANO_SECONDS);\n\n\tpos += scnprintf(buf + pos, len - pos, \"local_clock: [%5lu.%06lu]\\n\",\n\t\t\t (unsigned long)lc, rem_nsec / 1000);\n\tpos += scnprintf(buf + pos, len - pos, \"delta: %u(ms)\\n\",\n\t\t\t jiffies_to_msecs(jiffies - hdev->last_serv_processed));\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"last_service_task_processed: %lu(jiffies)\\n\",\n\t\t\t hdev->last_serv_processed);\n\tpos += scnprintf(buf + pos, len - pos, \"last_service_task_cnt: %lu\\n\",\n\t\t\t hdev->serv_processed_cnt);\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_interrupt(struct hclge_dev *hdev, char *buf, int len)\n{\n\tint pos = 0;\n\n\tpos += scnprintf(buf + pos, len - pos, \"num_nic_msi: %u\\n\",\n\t\t\t hdev->num_nic_msi);\n\tpos += scnprintf(buf + pos, len - pos, \"num_roce_msi: %u\\n\",\n\t\t\t hdev->num_roce_msi);\n\tpos += scnprintf(buf + pos, len - pos, \"num_msi_used: %u\\n\",\n\t\t\t hdev->num_msi_used);\n\tpos += scnprintf(buf + pos, len - pos, \"num_msi_left: %u\\n\",\n\t\t\t hdev->num_msi_left);\n\n\treturn 0;\n}\n\nstatic void hclge_dbg_imp_info_data_print(struct hclge_desc *desc_src,\n\t\t\t\t\t  char *buf, int len, u32 bd_num)\n{\n#define HCLGE_DBG_IMP_INFO_PRINT_OFFSET 0x2\n\n\tstruct hclge_desc *desc_index = desc_src;\n\tu32 offset = 0;\n\tint pos = 0;\n\tu32 i, j;\n\n\tpos += scnprintf(buf + pos, len - pos, \"offset | data\\n\");\n\n\tfor (i = 0; i < bd_num; i++) {\n\t\tj = 0;\n\t\twhile (j < HCLGE_DESC_DATA_LEN - 1) {\n\t\t\tpos += scnprintf(buf + pos, len - pos, \"0x%04x | \",\n\t\t\t\t\t offset);\n\t\t\tpos += scnprintf(buf + pos, len - pos, \"0x%08x  \",\n\t\t\t\t\t le32_to_cpu(desc_index->data[j++]));\n\t\t\tpos += scnprintf(buf + pos, len - pos, \"0x%08x\\n\",\n\t\t\t\t\t le32_to_cpu(desc_index->data[j++]));\n\t\t\toffset += sizeof(u32) * HCLGE_DBG_IMP_INFO_PRINT_OFFSET;\n\t\t}\n\t\tdesc_index++;\n\t}\n}\n\nstatic int\nhclge_dbg_get_imp_stats_info(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct hclge_get_imp_bd_cmd *req;\n\tstruct hclge_desc *desc_src;\n\tstruct hclge_desc desc;\n\tu32 bd_num;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_IMP_STATS_BD, true);\n\n\treq = (struct hclge_get_imp_bd_cmd *)desc.data;\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get imp statistics bd number, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tbd_num = le32_to_cpu(req->bd_num);\n\tif (!bd_num) {\n\t\tdev_err(&hdev->pdev->dev, \"imp statistics bd number is 0!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdesc_src = kcalloc(bd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc_src)\n\t\treturn -ENOMEM;\n\n\tret  = hclge_dbg_cmd_send(hdev, desc_src, 0, bd_num,\n\t\t\t\t  HCLGE_OPC_IMP_STATS_INFO);\n\tif (ret) {\n\t\tkfree(desc_src);\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get imp statistics, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thclge_dbg_imp_info_data_print(desc_src, buf, len, bd_num);\n\n\tkfree(desc_src);\n\n\treturn 0;\n}\n\n#define HCLGE_CMD_NCL_CONFIG_BD_NUM\t5\n#define HCLGE_MAX_NCL_CONFIG_LENGTH\t16384\n\nstatic void hclge_ncl_config_data_print(struct hclge_desc *desc, int *index,\n\t\t\t\t\tchar *buf, int len, int *pos)\n{\n#define HCLGE_CMD_DATA_NUM\t\t6\n\n\tint offset = HCLGE_MAX_NCL_CONFIG_LENGTH - *index;\n\tint i, j;\n\n\tfor (i = 0; i < HCLGE_CMD_NCL_CONFIG_BD_NUM; i++) {\n\t\tfor (j = 0; j < HCLGE_CMD_DATA_NUM; j++) {\n\t\t\tif (i == 0 && j == 0)\n\t\t\t\tcontinue;\n\n\t\t\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t\t\t  \"0x%04x | 0x%08x\\n\", offset,\n\t\t\t\t\t  le32_to_cpu(desc[i].data[j]));\n\n\t\t\toffset += sizeof(u32);\n\t\t\t*index -= sizeof(u32);\n\n\t\t\tif (*index <= 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int\nhclge_dbg_dump_ncl_config(struct hclge_dev *hdev, char *buf, int len)\n{\n#define HCLGE_NCL_CONFIG_LENGTH_IN_EACH_CMD\t(20 + 24 * 4)\n\n\tstruct hclge_desc desc[HCLGE_CMD_NCL_CONFIG_BD_NUM];\n\tint bd_num = HCLGE_CMD_NCL_CONFIG_BD_NUM;\n\tint index = HCLGE_MAX_NCL_CONFIG_LENGTH;\n\tint pos = 0;\n\tu32 data0;\n\tint ret;\n\n\tpos += scnprintf(buf + pos, len - pos, \"offset | data\\n\");\n\n\twhile (index > 0) {\n\t\tdata0 = HCLGE_MAX_NCL_CONFIG_LENGTH - index;\n\t\tif (index >= HCLGE_NCL_CONFIG_LENGTH_IN_EACH_CMD)\n\t\t\tdata0 |= HCLGE_NCL_CONFIG_LENGTH_IN_EACH_CMD << 16;\n\t\telse\n\t\t\tdata0 |= (u32)index << 16;\n\t\tret = hclge_dbg_cmd_send(hdev, desc, data0, bd_num,\n\t\t\t\t\t HCLGE_OPC_QUERY_NCL_CONFIG);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\thclge_ncl_config_data_print(desc, &index, buf, len, &pos);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_loopback(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\tstruct hclge_config_mac_mode_cmd *req_app;\n\tstruct hclge_common_lb_cmd *req_common;\n\tstruct hclge_desc desc;\n\tu8 loopback_en;\n\tint pos = 0;\n\tint ret;\n\n\treq_app = (struct hclge_config_mac_mode_cmd *)desc.data;\n\treq_common = (struct hclge_common_lb_cmd *)desc.data;\n\n\tpos += scnprintf(buf + pos, len - pos, \"mac id: %u\\n\",\n\t\t\t hdev->hw.mac.mac_id);\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAC_MODE, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump app loopback status, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tloopback_en = hnae3_get_bit(le32_to_cpu(req_app->txrx_pad_fcs_loop_en),\n\t\t\t\t    HCLGE_MAC_APP_LP_B);\n\tpos += scnprintf(buf + pos, len - pos, \"app loopback: %s\\n\",\n\t\t\t state_str[loopback_en]);\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_COMMON_LOOPBACK, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to dump common loopback status, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tloopback_en = req_common->enable & HCLGE_CMD_SERDES_SERIAL_INNER_LOOP_B;\n\tpos += scnprintf(buf + pos, len - pos, \"serdes serial loopback: %s\\n\",\n\t\t\t state_str[loopback_en]);\n\n\tloopback_en = req_common->enable &\n\t\t\tHCLGE_CMD_SERDES_PARALLEL_INNER_LOOP_B ? 1 : 0;\n\tpos += scnprintf(buf + pos, len - pos, \"serdes parallel loopback: %s\\n\",\n\t\t\t state_str[loopback_en]);\n\n\tif (phydev) {\n\t\tloopback_en = phydev->loopback_enabled;\n\t\tpos += scnprintf(buf + pos, len - pos, \"phy loopback: %s\\n\",\n\t\t\t\t state_str[loopback_en]);\n\t} else if (hnae3_dev_phy_imp_supported(hdev)) {\n\t\tloopback_en = req_common->enable &\n\t\t\t      HCLGE_CMD_GE_PHY_INNER_LOOP_B;\n\t\tpos += scnprintf(buf + pos, len - pos, \"phy loopback: %s\\n\",\n\t\t\t\t state_str[loopback_en]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nhclge_dbg_dump_mac_tnl_status(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct hclge_mac_tnl_stats stats;\n\tunsigned long rem_nsec;\n\tint pos = 0;\n\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t \"Recently generated mac tnl interruption:\\n\");\n\n\twhile (kfifo_get(&hdev->mac_tnl_log, &stats)) {\n\t\trem_nsec = do_div(stats.time, HCLGE_BILLION_NANO_SECONDS);\n\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"[%07lu.%03lu] status = 0x%x\\n\",\n\t\t\t\t (unsigned long)stats.time, rem_nsec / 1000,\n\t\t\t\t stats.status);\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct hclge_dbg_item mac_list_items[] = {\n\t{ \"FUNC_ID\", 2 },\n\t{ \"MAC_ADDR\", 12 },\n\t{ \"STATE\", 2 },\n};\n\nstatic void hclge_dbg_dump_mac_list(struct hclge_dev *hdev, char *buf, int len,\n\t\t\t\t    bool is_unicast)\n{\n\tchar data_str[ARRAY_SIZE(mac_list_items)][HCLGE_DBG_DATA_STR_LEN];\n\tchar content[HCLGE_DBG_INFO_LEN], str_id[HCLGE_DBG_ID_LEN];\n\tchar *result[ARRAY_SIZE(mac_list_items)];\n\tstruct hclge_mac_node *mac_node, *tmp;\n\tstruct hclge_vport *vport;\n\tstruct list_head *list;\n\tu32 func_id;\n\tint pos = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mac_list_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\tpos += scnprintf(buf + pos, len - pos, \"%s MAC_LIST:\\n\",\n\t\t\t is_unicast ? \"UC\" : \"MC\");\n\thclge_dbg_fill_content(content, sizeof(content), mac_list_items,\n\t\t\t       NULL, ARRAY_SIZE(mac_list_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\n\tfor (func_id = 0; func_id < hdev->num_alloc_vport; func_id++) {\n\t\tvport = &hdev->vport[func_id];\n\t\tlist = is_unicast ? &vport->uc_mac_list : &vport->mc_mac_list;\n\t\tspin_lock_bh(&vport->mac_list_lock);\n\t\tlist_for_each_entry_safe(mac_node, tmp, list, node) {\n\t\t\ti = 0;\n\t\t\tresult[i++] = hclge_dbg_get_func_id_str(str_id,\n\t\t\t\t\t\t\t\tfunc_id);\n\t\t\tsprintf(result[i++], \"%pM\", mac_node->mac_addr);\n\t\t\tsprintf(result[i++], \"%5s\",\n\t\t\t\thclge_mac_state_str[mac_node->state]);\n\t\t\thclge_dbg_fill_content(content, sizeof(content),\n\t\t\t\t\t       mac_list_items,\n\t\t\t\t\t       (const char **)result,\n\t\t\t\t\t       ARRAY_SIZE(mac_list_items));\n\t\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t\t}\n\t\tspin_unlock_bh(&vport->mac_list_lock);\n\t}\n}\n\nstatic int hclge_dbg_dump_umv_info(struct hclge_dev *hdev, char *buf, int len)\n{\n\tu8 func_num = pci_num_vf(hdev->pdev) + 1;\n\tstruct hclge_vport *vport;\n\tint pos = 0;\n\tu8 i;\n\n\tpos += scnprintf(buf, len, \"num_alloc_vport   : %u\\n\",\n\t\t\t  hdev->num_alloc_vport);\n\tpos += scnprintf(buf + pos, len - pos, \"max_umv_size     : %u\\n\",\n\t\t\t hdev->max_umv_size);\n\tpos += scnprintf(buf + pos, len - pos, \"wanted_umv_size  : %u\\n\",\n\t\t\t hdev->wanted_umv_size);\n\tpos += scnprintf(buf + pos, len - pos, \"priv_umv_size    : %u\\n\",\n\t\t\t hdev->priv_umv_size);\n\n\tmutex_lock(&hdev->vport_lock);\n\tpos += scnprintf(buf + pos, len - pos, \"share_umv_size   : %u\\n\",\n\t\t\t hdev->share_umv_size);\n\tfor (i = 0; i < func_num; i++) {\n\t\tvport = &hdev->vport[i];\n\t\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t\t \"vport(%u) used_umv_num : %u\\n\",\n\t\t\t\t i, vport->used_umv_num);\n\t}\n\tmutex_unlock(&hdev->vport_lock);\n\n\tpos += scnprintf(buf + pos, len - pos, \"used_mc_mac_num  : %u\\n\",\n\t\t\t hdev->used_mc_mac_num);\n\n\treturn 0;\n}\n\nstatic int hclge_get_vlan_rx_offload_cfg(struct hclge_dev *hdev, u8 vf_id,\n\t\t\t\t\t struct hclge_dbg_vlan_cfg *vlan_cfg)\n{\n\tstruct hclge_vport_vtag_rx_cfg_cmd *req;\n\tstruct hclge_desc desc;\n\tu16 bmap_index;\n\tu8 rx_cfg;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_RX_CFG, true);\n\n\treq = (struct hclge_vport_vtag_rx_cfg_cmd *)desc.data;\n\treq->vf_offset = vf_id / HCLGE_VF_NUM_PER_CMD;\n\tbmap_index = vf_id % HCLGE_VF_NUM_PER_CMD / HCLGE_VF_NUM_PER_BYTE;\n\treq->vf_bitmap[bmap_index] = 1U << (vf_id % HCLGE_VF_NUM_PER_BYTE);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get vport%u rxvlan cfg, ret = %d\\n\",\n\t\t\tvf_id, ret);\n\t\treturn ret;\n\t}\n\n\trx_cfg = req->vport_vlan_cfg;\n\tvlan_cfg->strip_tag1 = hnae3_get_bit(rx_cfg, HCLGE_REM_TAG1_EN_B);\n\tvlan_cfg->strip_tag2 = hnae3_get_bit(rx_cfg, HCLGE_REM_TAG2_EN_B);\n\tvlan_cfg->drop_tag1 = hnae3_get_bit(rx_cfg, HCLGE_DISCARD_TAG1_EN_B);\n\tvlan_cfg->drop_tag2 = hnae3_get_bit(rx_cfg, HCLGE_DISCARD_TAG2_EN_B);\n\tvlan_cfg->pri_only1 = hnae3_get_bit(rx_cfg, HCLGE_SHOW_TAG1_EN_B);\n\tvlan_cfg->pri_only2 = hnae3_get_bit(rx_cfg, HCLGE_SHOW_TAG2_EN_B);\n\n\treturn 0;\n}\n\nstatic int hclge_get_vlan_tx_offload_cfg(struct hclge_dev *hdev, u8 vf_id,\n\t\t\t\t\t struct hclge_dbg_vlan_cfg *vlan_cfg)\n{\n\tstruct hclge_vport_vtag_tx_cfg_cmd *req;\n\tstruct hclge_desc desc;\n\tu16 bmap_index;\n\tu8 tx_cfg;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_TX_CFG, true);\n\treq = (struct hclge_vport_vtag_tx_cfg_cmd *)desc.data;\n\treq->vf_offset = vf_id / HCLGE_VF_NUM_PER_CMD;\n\tbmap_index = vf_id % HCLGE_VF_NUM_PER_CMD / HCLGE_VF_NUM_PER_BYTE;\n\treq->vf_bitmap[bmap_index] = 1U << (vf_id % HCLGE_VF_NUM_PER_BYTE);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get vport%u txvlan cfg, ret = %d\\n\",\n\t\t\tvf_id, ret);\n\t\treturn ret;\n\t}\n\n\ttx_cfg = req->vport_vlan_cfg;\n\tvlan_cfg->pvid = le16_to_cpu(req->def_vlan_tag1);\n\n\tvlan_cfg->accept_tag1 = hnae3_get_bit(tx_cfg, HCLGE_ACCEPT_TAG1_B);\n\tvlan_cfg->accept_tag2 = hnae3_get_bit(tx_cfg, HCLGE_ACCEPT_TAG2_B);\n\tvlan_cfg->accept_untag1 = hnae3_get_bit(tx_cfg, HCLGE_ACCEPT_UNTAG1_B);\n\tvlan_cfg->accept_untag2 = hnae3_get_bit(tx_cfg, HCLGE_ACCEPT_UNTAG2_B);\n\tvlan_cfg->insert_tag1 = hnae3_get_bit(tx_cfg, HCLGE_PORT_INS_TAG1_EN_B);\n\tvlan_cfg->insert_tag2 = hnae3_get_bit(tx_cfg, HCLGE_PORT_INS_TAG2_EN_B);\n\tvlan_cfg->shift_tag = hnae3_get_bit(tx_cfg, HCLGE_TAG_SHIFT_MODE_EN_B);\n\n\treturn 0;\n}\n\nstatic int hclge_get_vlan_filter_config_cmd(struct hclge_dev *hdev,\n\t\t\t\t\t    u8 vlan_type, u8 vf_id,\n\t\t\t\t\t    struct hclge_desc *desc)\n{\n\tstruct hclge_vlan_filter_ctrl_cmd *req;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(desc, HCLGE_OPC_VLAN_FILTER_CTRL, true);\n\treq = (struct hclge_vlan_filter_ctrl_cmd *)desc->data;\n\treq->vlan_type = vlan_type;\n\treq->vf_id = vf_id;\n\n\tret = hclge_cmd_send(&hdev->hw, desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get vport%u vlan filter config, ret = %d.\\n\",\n\t\t\tvf_id, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_get_vlan_filter_state(struct hclge_dev *hdev, u8 vlan_type,\n\t\t\t\t       u8 vf_id, u8 *vlan_fe)\n{\n\tstruct hclge_vlan_filter_ctrl_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tret = hclge_get_vlan_filter_config_cmd(hdev, vlan_type, vf_id, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\treq = (struct hclge_vlan_filter_ctrl_cmd *)desc.data;\n\t*vlan_fe = req->vlan_fe;\n\n\treturn 0;\n}\n\nstatic int hclge_get_port_vlan_filter_bypass_state(struct hclge_dev *hdev,\n\t\t\t\t\t\t   u8 vf_id, u8 *bypass_en)\n{\n\tstruct hclge_port_vlan_filter_bypass_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tif (!test_bit(HNAE3_DEV_SUPPORT_PORT_VLAN_BYPASS_B, hdev->ae_dev->caps))\n\t\treturn 0;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PORT_VLAN_BYPASS, true);\n\treq = (struct hclge_port_vlan_filter_bypass_cmd *)desc.data;\n\treq->vf_id = vf_id;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get vport%u port vlan filter bypass state, ret = %d.\\n\",\n\t\t\tvf_id, ret);\n\t\treturn ret;\n\t}\n\n\t*bypass_en = hnae3_get_bit(req->bypass_state, HCLGE_INGRESS_BYPASS_B);\n\n\treturn 0;\n}\n\nstatic const struct hclge_dbg_item vlan_filter_items[] = {\n\t{ \"FUNC_ID\", 2 },\n\t{ \"I_VF_VLAN_FILTER\", 2 },\n\t{ \"E_VF_VLAN_FILTER\", 2 },\n\t{ \"PORT_VLAN_FILTER_BYPASS\", 0 }\n};\n\nstatic const struct hclge_dbg_item vlan_offload_items[] = {\n\t{ \"FUNC_ID\", 2 },\n\t{ \"PVID\", 4 },\n\t{ \"ACCEPT_TAG1\", 2 },\n\t{ \"ACCEPT_TAG2\", 2 },\n\t{ \"ACCEPT_UNTAG1\", 2 },\n\t{ \"ACCEPT_UNTAG2\", 2 },\n\t{ \"INSERT_TAG1\", 2 },\n\t{ \"INSERT_TAG2\", 2 },\n\t{ \"SHIFT_TAG\", 2 },\n\t{ \"STRIP_TAG1\", 2 },\n\t{ \"STRIP_TAG2\", 2 },\n\t{ \"DROP_TAG1\", 2 },\n\t{ \"DROP_TAG2\", 2 },\n\t{ \"PRI_ONLY_TAG1\", 2 },\n\t{ \"PRI_ONLY_TAG2\", 0 }\n};\n\nstatic int hclge_dbg_dump_vlan_filter_config(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t     int len, int *pos)\n{\n\tchar content[HCLGE_DBG_VLAN_FLTR_INFO_LEN], str_id[HCLGE_DBG_ID_LEN];\n\tconst char *result[ARRAY_SIZE(vlan_filter_items)];\n\tu8 i, j, vlan_fe, bypass, ingress, egress;\n\tu8 func_num = pci_num_vf(hdev->pdev) + 1;  \n\tint ret;\n\n\tret = hclge_get_vlan_filter_state(hdev, HCLGE_FILTER_TYPE_PORT, 0,\n\t\t\t\t\t  &vlan_fe);\n\tif (ret)\n\t\treturn ret;\n\tingress = vlan_fe & HCLGE_FILTER_FE_NIC_INGRESS_B;\n\tegress = vlan_fe & HCLGE_FILTER_FE_NIC_EGRESS_B ? 1 : 0;\n\n\t*pos += scnprintf(buf, len, \"I_PORT_VLAN_FILTER: %s\\n\",\n\t\t\t  state_str[ingress]);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"E_PORT_VLAN_FILTER: %s\\n\",\n\t\t\t  state_str[egress]);\n\n\thclge_dbg_fill_content(content, sizeof(content), vlan_filter_items,\n\t\t\t       NULL, ARRAY_SIZE(vlan_filter_items));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\n\tfor (i = 0; i < func_num; i++) {\n\t\tret = hclge_get_vlan_filter_state(hdev, HCLGE_FILTER_TYPE_VF, i,\n\t\t\t\t\t\t  &vlan_fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tingress = vlan_fe & HCLGE_FILTER_FE_NIC_INGRESS_B;\n\t\tegress = vlan_fe & HCLGE_FILTER_FE_NIC_EGRESS_B ? 1 : 0;\n\t\tret = hclge_get_port_vlan_filter_bypass_state(hdev, i, &bypass);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tj = 0;\n\t\tresult[j++] = hclge_dbg_get_func_id_str(str_id, i);\n\t\tresult[j++] = state_str[ingress];\n\t\tresult[j++] = state_str[egress];\n\t\tresult[j++] =\n\t\t\ttest_bit(HNAE3_DEV_SUPPORT_PORT_VLAN_BYPASS_B,\n\t\t\t\t hdev->ae_dev->caps) ? state_str[bypass] : \"NA\";\n\t\thclge_dbg_fill_content(content, sizeof(content),\n\t\t\t\t       vlan_filter_items, result,\n\t\t\t\t       ARRAY_SIZE(vlan_filter_items));\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\t}\n\t*pos += scnprintf(buf + *pos, len - *pos, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_vlan_offload_config(struct hclge_dev *hdev, char *buf,\n\t\t\t\t\t      int len, int *pos)\n{\n\tchar str_id[HCLGE_DBG_ID_LEN], str_pvid[HCLGE_DBG_ID_LEN];\n\tconst char *result[ARRAY_SIZE(vlan_offload_items)];\n\tchar content[HCLGE_DBG_VLAN_OFFLOAD_INFO_LEN];\n\tu8 func_num = pci_num_vf(hdev->pdev) + 1;  \n\tstruct hclge_dbg_vlan_cfg vlan_cfg;\n\tint ret;\n\tu8 i, j;\n\n\thclge_dbg_fill_content(content, sizeof(content), vlan_offload_items,\n\t\t\t       NULL, ARRAY_SIZE(vlan_offload_items));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\n\tfor (i = 0; i < func_num; i++) {\n\t\tret = hclge_get_vlan_tx_offload_cfg(hdev, i, &vlan_cfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_get_vlan_rx_offload_cfg(hdev, i, &vlan_cfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsprintf(str_pvid, \"%u\", vlan_cfg.pvid);\n\t\tj = 0;\n\t\tresult[j++] = hclge_dbg_get_func_id_str(str_id, i);\n\t\tresult[j++] = str_pvid;\n\t\tresult[j++] = state_str[vlan_cfg.accept_tag1];\n\t\tresult[j++] = state_str[vlan_cfg.accept_tag2];\n\t\tresult[j++] = state_str[vlan_cfg.accept_untag1];\n\t\tresult[j++] = state_str[vlan_cfg.accept_untag2];\n\t\tresult[j++] = state_str[vlan_cfg.insert_tag1];\n\t\tresult[j++] = state_str[vlan_cfg.insert_tag2];\n\t\tresult[j++] = state_str[vlan_cfg.shift_tag];\n\t\tresult[j++] = state_str[vlan_cfg.strip_tag1];\n\t\tresult[j++] = state_str[vlan_cfg.strip_tag2];\n\t\tresult[j++] = state_str[vlan_cfg.drop_tag1];\n\t\tresult[j++] = state_str[vlan_cfg.drop_tag2];\n\t\tresult[j++] = state_str[vlan_cfg.pri_only1];\n\t\tresult[j++] = state_str[vlan_cfg.pri_only2];\n\n\t\thclge_dbg_fill_content(content, sizeof(content),\n\t\t\t\t       vlan_offload_items, result,\n\t\t\t\t       ARRAY_SIZE(vlan_offload_items));\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_vlan_config(struct hclge_dev *hdev, char *buf,\n\t\t\t\t      int len)\n{\n\tint pos = 0;\n\tint ret;\n\n\tret = hclge_dbg_dump_vlan_filter_config(hdev, buf, len, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_dbg_dump_vlan_offload_config(hdev, buf, len, &pos);\n}\n\nstatic int hclge_dbg_dump_ptp_info(struct hclge_dev *hdev, char *buf, int len)\n{\n\tstruct hclge_ptp *ptp = hdev->ptp;\n\tu32 sw_cfg = ptp->ptp_cfg;\n\tunsigned int tx_start;\n\tunsigned int last_rx;\n\tint pos = 0;\n\tu32 hw_cfg;\n\tint ret;\n\n\tpos += scnprintf(buf + pos, len - pos, \"phc %s's debug info:\\n\",\n\t\t\t ptp->info.name);\n\tpos += scnprintf(buf + pos, len - pos, \"ptp enable: %s\\n\",\n\t\t\t test_bit(HCLGE_PTP_FLAG_EN, &ptp->flags) ?\n\t\t\t \"yes\" : \"no\");\n\tpos += scnprintf(buf + pos, len - pos, \"ptp tx enable: %s\\n\",\n\t\t\t test_bit(HCLGE_PTP_FLAG_TX_EN, &ptp->flags) ?\n\t\t\t \"yes\" : \"no\");\n\tpos += scnprintf(buf + pos, len - pos, \"ptp rx enable: %s\\n\",\n\t\t\t test_bit(HCLGE_PTP_FLAG_RX_EN, &ptp->flags) ?\n\t\t\t \"yes\" : \"no\");\n\n\tlast_rx = jiffies_to_msecs(ptp->last_rx);\n\tpos += scnprintf(buf + pos, len - pos, \"last rx time: %lu.%lu\\n\",\n\t\t\t last_rx / MSEC_PER_SEC, last_rx % MSEC_PER_SEC);\n\tpos += scnprintf(buf + pos, len - pos, \"rx count: %lu\\n\", ptp->rx_cnt);\n\n\ttx_start = jiffies_to_msecs(ptp->tx_start);\n\tpos += scnprintf(buf + pos, len - pos, \"last tx start time: %lu.%lu\\n\",\n\t\t\t tx_start / MSEC_PER_SEC, tx_start % MSEC_PER_SEC);\n\tpos += scnprintf(buf + pos, len - pos, \"tx count: %lu\\n\", ptp->tx_cnt);\n\tpos += scnprintf(buf + pos, len - pos, \"tx skipped count: %lu\\n\",\n\t\t\t ptp->tx_skipped);\n\tpos += scnprintf(buf + pos, len - pos, \"tx timeout count: %lu\\n\",\n\t\t\t ptp->tx_timeout);\n\tpos += scnprintf(buf + pos, len - pos, \"last tx seqid: %u\\n\",\n\t\t\t ptp->last_tx_seqid);\n\n\tret = hclge_ptp_cfg_qry(hdev, &hw_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tpos += scnprintf(buf + pos, len - pos, \"sw_cfg: %#x, hw_cfg: %#x\\n\",\n\t\t\t sw_cfg, hw_cfg);\n\n\tpos += scnprintf(buf + pos, len - pos, \"tx type: %d, rx filter: %d\\n\",\n\t\t\t ptp->ts_cfg.tx_type, ptp->ts_cfg.rx_filter);\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_mac_uc(struct hclge_dev *hdev, char *buf, int len)\n{\n\thclge_dbg_dump_mac_list(hdev, buf, len, true);\n\n\treturn 0;\n}\n\nstatic int hclge_dbg_dump_mac_mc(struct hclge_dev *hdev, char *buf, int len)\n{\n\thclge_dbg_dump_mac_list(hdev, buf, len, false);\n\n\treturn 0;\n}\n\nstatic const struct hclge_dbg_func hclge_dbg_cmd_func[] = {\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TM_NODES,\n\t\t.dbg_dump = hclge_dbg_dump_tm_nodes,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TM_PRI,\n\t\t.dbg_dump = hclge_dbg_dump_tm_pri,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TM_QSET,\n\t\t.dbg_dump = hclge_dbg_dump_tm_qset,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TM_MAP,\n\t\t.dbg_dump = hclge_dbg_dump_tm_map,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TM_PG,\n\t\t.dbg_dump = hclge_dbg_dump_tm_pg,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TM_PORT,\n\t\t.dbg_dump = hclge_dbg_dump_tm_port,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TC_SCH_INFO,\n\t\t.dbg_dump = hclge_dbg_dump_tc,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_QOS_PAUSE_CFG,\n\t\t.dbg_dump = hclge_dbg_dump_qos_pause_cfg,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_QOS_PRI_MAP,\n\t\t.dbg_dump = hclge_dbg_dump_qos_pri_map,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_QOS_DSCP_MAP,\n\t\t.dbg_dump = hclge_dbg_dump_qos_dscp_map,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_QOS_BUF_CFG,\n\t\t.dbg_dump = hclge_dbg_dump_qos_buf_cfg,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_MAC_UC,\n\t\t.dbg_dump = hclge_dbg_dump_mac_uc,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_MAC_MC,\n\t\t.dbg_dump = hclge_dbg_dump_mac_mc,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_MNG_TBL,\n\t\t.dbg_dump = hclge_dbg_dump_mng_table,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_LOOPBACK,\n\t\t.dbg_dump = hclge_dbg_dump_loopback,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_PTP_INFO,\n\t\t.dbg_dump = hclge_dbg_dump_ptp_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_INTERRUPT_INFO,\n\t\t.dbg_dump = hclge_dbg_dump_interrupt,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_RESET_INFO,\n\t\t.dbg_dump = hclge_dbg_dump_rst_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_IMP_INFO,\n\t\t.dbg_dump = hclge_dbg_get_imp_stats_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_NCL_CONFIG,\n\t\t.dbg_dump = hclge_dbg_dump_ncl_config,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_BIOS_COMMON,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_SSU,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_IGU_EGU,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_RPU,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_NCSI,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_RTC,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_PPP,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_RCB,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_TQP,\n\t\t.dbg_dump_reg = hclge_dbg_dump_reg_cmd,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_MAC,\n\t\t.dbg_dump = hclge_dbg_dump_mac,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_REG_DCB,\n\t\t.dbg_dump = hclge_dbg_dump_dcb,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_FD_TCAM,\n\t\t.dbg_dump = hclge_dbg_dump_fd_tcam,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_MAC_TNL_STATUS,\n\t\t.dbg_dump = hclge_dbg_dump_mac_tnl_status,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_SERV_INFO,\n\t\t.dbg_dump = hclge_dbg_dump_serv_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_VLAN_CONFIG,\n\t\t.dbg_dump = hclge_dbg_dump_vlan_config,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_FD_COUNTER,\n\t\t.dbg_dump = hclge_dbg_dump_fd_counter,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_UMV_INFO,\n\t\t.dbg_dump = hclge_dbg_dump_umv_info,\n\t},\n};\n\nint hclge_dbg_read_cmd(struct hnae3_handle *handle, enum hnae3_dbg_cmd cmd,\n\t\t       char *buf, int len)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tconst struct hclge_dbg_func *cmd_func;\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hclge_dbg_cmd_func); i++) {\n\t\tif (cmd == hclge_dbg_cmd_func[i].cmd) {\n\t\t\tcmd_func = &hclge_dbg_cmd_func[i];\n\t\t\tif (cmd_func->dbg_dump)\n\t\t\t\treturn cmd_func->dbg_dump(hdev, buf, len);\n\t\t\telse\n\t\t\t\treturn cmd_func->dbg_dump_reg(hdev, cmd, buf,\n\t\t\t\t\t\t\t      len);\n\t\t}\n\t}\n\n\tdev_err(&hdev->pdev->dev, \"invalid command(%d)\\n\", cmd);\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}