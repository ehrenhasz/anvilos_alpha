{
  "module_name": "hclge_main.c",
  "hash_id": "3ae334c98ab08e46bff7b66558f284ebc2499648c5e49081f67de7dc07e64f47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/if_vlan.h>\n#include <linux/crash_dump.h>\n#include <net/ipv6.h>\n#include <net/rtnetlink.h>\n#include \"hclge_cmd.h\"\n#include \"hclge_dcb.h\"\n#include \"hclge_main.h\"\n#include \"hclge_mbx.h\"\n#include \"hclge_mdio.h\"\n#include \"hclge_regs.h\"\n#include \"hclge_tm.h\"\n#include \"hclge_err.h\"\n#include \"hnae3.h\"\n#include \"hclge_devlink.h\"\n#include \"hclge_comm_cmd.h\"\n\n#define HCLGE_NAME\t\t\t\"hclge\"\n\n#define HCLGE_BUF_SIZE_UNIT\t256U\n#define HCLGE_BUF_MUL_BY\t2\n#define HCLGE_BUF_DIV_BY\t2\n#define NEED_RESERVE_TC_NUM\t2\n#define BUF_MAX_PERCENT\t\t100\n#define BUF_RESERVE_PERCENT\t90\n\n#define HCLGE_RESET_MAX_FAIL_CNT\t5\n#define HCLGE_RESET_SYNC_TIME\t\t100\n#define HCLGE_PF_RESET_SYNC_TIME\t20\n#define HCLGE_PF_RESET_SYNC_CNT\t\t1500\n\n#define HCLGE_LINK_STATUS_MS\t10\n\nstatic int hclge_set_mac_mtu(struct hclge_dev *hdev, int new_mps);\nstatic int hclge_init_vlan_config(struct hclge_dev *hdev);\nstatic void hclge_sync_vlan_filter(struct hclge_dev *hdev);\nstatic int hclge_reset_ae_dev(struct hnae3_ae_dev *ae_dev);\nstatic bool hclge_get_hw_reset_stat(struct hnae3_handle *handle);\nstatic void hclge_rfs_filter_expire(struct hclge_dev *hdev);\nstatic int hclge_clear_arfs_rules(struct hclge_dev *hdev);\nstatic enum hnae3_reset_type hclge_get_reset_level(struct hnae3_ae_dev *ae_dev,\n\t\t\t\t\t\t   unsigned long *addr);\nstatic int hclge_set_default_loopback(struct hclge_dev *hdev);\n\nstatic void hclge_sync_mac_table(struct hclge_dev *hdev);\nstatic void hclge_restore_hw_table(struct hclge_dev *hdev);\nstatic void hclge_sync_promisc_mode(struct hclge_dev *hdev);\nstatic void hclge_sync_fd_table(struct hclge_dev *hdev);\nstatic void hclge_update_fec_stats(struct hclge_dev *hdev);\nstatic int hclge_mac_link_status_wait(struct hclge_dev *hdev, int link_ret,\n\t\t\t\t      int wait_cnt);\nstatic int hclge_update_port_info(struct hclge_dev *hdev);\n\nstatic struct hnae3_ae_algo ae_algo;\n\nstatic struct workqueue_struct *hclge_wq;\n\nstatic const struct pci_device_id ae_algo_pci_tbl[] = {\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_GE), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_25GE), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_25GE_RDMA), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_25GE_RDMA_MACSEC), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_50GE_RDMA), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_50GE_RDMA_MACSEC), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_100G_RDMA_MACSEC), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_200G_RDMA), 0},\n\t \n\t{0, }\n};\n\nMODULE_DEVICE_TABLE(pci, ae_algo_pci_tbl);\n\nstatic const char hns3_nic_test_strs[][ETH_GSTRING_LEN] = {\n\t\"External Loopback test\",\n\t\"App      Loopback test\",\n\t\"Serdes   serial Loopback test\",\n\t\"Serdes   parallel Loopback test\",\n\t\"Phy      Loopback test\"\n};\n\nstatic const struct hclge_comm_stats_str g_mac_stats_string[] = {\n\t{\"mac_tx_mac_pause_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_mac_pause_num)},\n\t{\"mac_rx_mac_pause_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_mac_pause_num)},\n\t{\"mac_tx_pause_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pause_xoff_time)},\n\t{\"mac_rx_pause_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pause_xoff_time)},\n\t{\"mac_tx_control_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_ctrl_pkt_num)},\n\t{\"mac_rx_control_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_ctrl_pkt_num)},\n\t{\"mac_tx_pfc_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pause_pkt_num)},\n\t{\"mac_tx_pfc_pri0_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri0_pkt_num)},\n\t{\"mac_tx_pfc_pri1_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri1_pkt_num)},\n\t{\"mac_tx_pfc_pri2_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri2_pkt_num)},\n\t{\"mac_tx_pfc_pri3_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri3_pkt_num)},\n\t{\"mac_tx_pfc_pri4_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri4_pkt_num)},\n\t{\"mac_tx_pfc_pri5_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri5_pkt_num)},\n\t{\"mac_tx_pfc_pri6_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri6_pkt_num)},\n\t{\"mac_tx_pfc_pri7_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri7_pkt_num)},\n\t{\"mac_tx_pfc_pri0_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri0_xoff_time)},\n\t{\"mac_tx_pfc_pri1_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri1_xoff_time)},\n\t{\"mac_tx_pfc_pri2_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri2_xoff_time)},\n\t{\"mac_tx_pfc_pri3_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri3_xoff_time)},\n\t{\"mac_tx_pfc_pri4_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri4_xoff_time)},\n\t{\"mac_tx_pfc_pri5_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri5_xoff_time)},\n\t{\"mac_tx_pfc_pri6_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri6_xoff_time)},\n\t{\"mac_tx_pfc_pri7_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_pfc_pri7_xoff_time)},\n\t{\"mac_rx_pfc_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pause_pkt_num)},\n\t{\"mac_rx_pfc_pri0_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri0_pkt_num)},\n\t{\"mac_rx_pfc_pri1_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri1_pkt_num)},\n\t{\"mac_rx_pfc_pri2_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri2_pkt_num)},\n\t{\"mac_rx_pfc_pri3_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri3_pkt_num)},\n\t{\"mac_rx_pfc_pri4_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri4_pkt_num)},\n\t{\"mac_rx_pfc_pri5_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri5_pkt_num)},\n\t{\"mac_rx_pfc_pri6_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri6_pkt_num)},\n\t{\"mac_rx_pfc_pri7_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri7_pkt_num)},\n\t{\"mac_rx_pfc_pri0_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri0_xoff_time)},\n\t{\"mac_rx_pfc_pri1_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri1_xoff_time)},\n\t{\"mac_rx_pfc_pri2_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri2_xoff_time)},\n\t{\"mac_rx_pfc_pri3_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri3_xoff_time)},\n\t{\"mac_rx_pfc_pri4_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri4_xoff_time)},\n\t{\"mac_rx_pfc_pri5_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri5_xoff_time)},\n\t{\"mac_rx_pfc_pri6_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri6_xoff_time)},\n\t{\"mac_rx_pfc_pri7_xoff_time\", HCLGE_MAC_STATS_MAX_NUM_V2,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_pfc_pri7_xoff_time)},\n\t{\"mac_tx_total_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_total_pkt_num)},\n\t{\"mac_tx_total_oct_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_total_oct_num)},\n\t{\"mac_tx_good_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_good_pkt_num)},\n\t{\"mac_tx_bad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_bad_pkt_num)},\n\t{\"mac_tx_good_oct_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_good_oct_num)},\n\t{\"mac_tx_bad_oct_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_bad_oct_num)},\n\t{\"mac_tx_uni_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_uni_pkt_num)},\n\t{\"mac_tx_multi_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_multi_pkt_num)},\n\t{\"mac_tx_broad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_broad_pkt_num)},\n\t{\"mac_tx_undersize_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_undersize_pkt_num)},\n\t{\"mac_tx_oversize_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_oversize_pkt_num)},\n\t{\"mac_tx_64_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_64_oct_pkt_num)},\n\t{\"mac_tx_65_127_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_65_127_oct_pkt_num)},\n\t{\"mac_tx_128_255_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_128_255_oct_pkt_num)},\n\t{\"mac_tx_256_511_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_256_511_oct_pkt_num)},\n\t{\"mac_tx_512_1023_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_512_1023_oct_pkt_num)},\n\t{\"mac_tx_1024_1518_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_1024_1518_oct_pkt_num)},\n\t{\"mac_tx_1519_2047_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_1519_2047_oct_pkt_num)},\n\t{\"mac_tx_2048_4095_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_2048_4095_oct_pkt_num)},\n\t{\"mac_tx_4096_8191_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_4096_8191_oct_pkt_num)},\n\t{\"mac_tx_8192_9216_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_8192_9216_oct_pkt_num)},\n\t{\"mac_tx_9217_12287_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_9217_12287_oct_pkt_num)},\n\t{\"mac_tx_12288_16383_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_12288_16383_oct_pkt_num)},\n\t{\"mac_tx_1519_max_good_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_1519_max_good_oct_pkt_num)},\n\t{\"mac_tx_1519_max_bad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_1519_max_bad_oct_pkt_num)},\n\t{\"mac_rx_total_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_total_pkt_num)},\n\t{\"mac_rx_total_oct_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_total_oct_num)},\n\t{\"mac_rx_good_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_good_pkt_num)},\n\t{\"mac_rx_bad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_bad_pkt_num)},\n\t{\"mac_rx_good_oct_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_good_oct_num)},\n\t{\"mac_rx_bad_oct_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_bad_oct_num)},\n\t{\"mac_rx_uni_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_uni_pkt_num)},\n\t{\"mac_rx_multi_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_multi_pkt_num)},\n\t{\"mac_rx_broad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_broad_pkt_num)},\n\t{\"mac_rx_undersize_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_undersize_pkt_num)},\n\t{\"mac_rx_oversize_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_oversize_pkt_num)},\n\t{\"mac_rx_64_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_64_oct_pkt_num)},\n\t{\"mac_rx_65_127_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_65_127_oct_pkt_num)},\n\t{\"mac_rx_128_255_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_128_255_oct_pkt_num)},\n\t{\"mac_rx_256_511_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_256_511_oct_pkt_num)},\n\t{\"mac_rx_512_1023_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_512_1023_oct_pkt_num)},\n\t{\"mac_rx_1024_1518_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_1024_1518_oct_pkt_num)},\n\t{\"mac_rx_1519_2047_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_1519_2047_oct_pkt_num)},\n\t{\"mac_rx_2048_4095_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_2048_4095_oct_pkt_num)},\n\t{\"mac_rx_4096_8191_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_4096_8191_oct_pkt_num)},\n\t{\"mac_rx_8192_9216_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_8192_9216_oct_pkt_num)},\n\t{\"mac_rx_9217_12287_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_9217_12287_oct_pkt_num)},\n\t{\"mac_rx_12288_16383_oct_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_12288_16383_oct_pkt_num)},\n\t{\"mac_rx_1519_max_good_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_1519_max_good_oct_pkt_num)},\n\t{\"mac_rx_1519_max_bad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_1519_max_bad_oct_pkt_num)},\n\n\t{\"mac_tx_fragment_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_fragment_pkt_num)},\n\t{\"mac_tx_undermin_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_undermin_pkt_num)},\n\t{\"mac_tx_jabber_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_jabber_pkt_num)},\n\t{\"mac_tx_err_all_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_err_all_pkt_num)},\n\t{\"mac_tx_from_app_good_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_from_app_good_pkt_num)},\n\t{\"mac_tx_from_app_bad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_tx_from_app_bad_pkt_num)},\n\t{\"mac_rx_fragment_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_fragment_pkt_num)},\n\t{\"mac_rx_undermin_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_undermin_pkt_num)},\n\t{\"mac_rx_jabber_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_jabber_pkt_num)},\n\t{\"mac_rx_fcs_err_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_fcs_err_pkt_num)},\n\t{\"mac_rx_send_app_good_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_send_app_good_pkt_num)},\n\t{\"mac_rx_send_app_bad_pkt_num\", HCLGE_MAC_STATS_MAX_NUM_V1,\n\t\tHCLGE_MAC_STATS_FIELD_OFF(mac_rx_send_app_bad_pkt_num)}\n};\n\nstatic const struct hclge_mac_mgr_tbl_entry_cmd hclge_mgr_table[] = {\n\t{\n\t\t.flags = HCLGE_MAC_MGR_MASK_VLAN_B,\n\t\t.ethter_type = cpu_to_le16(ETH_P_LLDP),\n\t\t.mac_addr = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e},\n\t\t.i_port_bitmap = 0x1,\n\t},\n};\n\nstatic const struct key_info meta_data_key_info[] = {\n\t{ PACKET_TYPE_ID, 6 },\n\t{ IP_FRAGEMENT, 1 },\n\t{ ROCE_TYPE, 1 },\n\t{ NEXT_KEY, 5 },\n\t{ VLAN_NUMBER, 2 },\n\t{ SRC_VPORT, 12 },\n\t{ DST_VPORT, 12 },\n\t{ TUNNEL_PACKET, 1 },\n};\n\nstatic const struct key_info tuple_key_info[] = {\n\t{ OUTER_DST_MAC, 48, KEY_OPT_MAC, -1, -1 },\n\t{ OUTER_SRC_MAC, 48, KEY_OPT_MAC, -1, -1 },\n\t{ OUTER_VLAN_TAG_FST, 16, KEY_OPT_LE16, -1, -1 },\n\t{ OUTER_VLAN_TAG_SEC, 16, KEY_OPT_LE16, -1, -1 },\n\t{ OUTER_ETH_TYPE, 16, KEY_OPT_LE16, -1, -1 },\n\t{ OUTER_L2_RSV, 16, KEY_OPT_LE16, -1, -1 },\n\t{ OUTER_IP_TOS, 8, KEY_OPT_U8, -1, -1 },\n\t{ OUTER_IP_PROTO, 8, KEY_OPT_U8, -1, -1 },\n\t{ OUTER_SRC_IP, 32, KEY_OPT_IP, -1, -1 },\n\t{ OUTER_DST_IP, 32, KEY_OPT_IP, -1, -1 },\n\t{ OUTER_L3_RSV, 16, KEY_OPT_LE16, -1, -1 },\n\t{ OUTER_SRC_PORT, 16, KEY_OPT_LE16, -1, -1 },\n\t{ OUTER_DST_PORT, 16, KEY_OPT_LE16, -1, -1 },\n\t{ OUTER_L4_RSV, 32, KEY_OPT_LE32, -1, -1 },\n\t{ OUTER_TUN_VNI, 24, KEY_OPT_VNI, -1, -1 },\n\t{ OUTER_TUN_FLOW_ID, 8, KEY_OPT_U8, -1, -1 },\n\t{ INNER_DST_MAC, 48, KEY_OPT_MAC,\n\t  offsetof(struct hclge_fd_rule, tuples.dst_mac),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.dst_mac) },\n\t{ INNER_SRC_MAC, 48, KEY_OPT_MAC,\n\t  offsetof(struct hclge_fd_rule, tuples.src_mac),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.src_mac) },\n\t{ INNER_VLAN_TAG_FST, 16, KEY_OPT_LE16,\n\t  offsetof(struct hclge_fd_rule, tuples.vlan_tag1),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.vlan_tag1) },\n\t{ INNER_VLAN_TAG_SEC, 16, KEY_OPT_LE16, -1, -1 },\n\t{ INNER_ETH_TYPE, 16, KEY_OPT_LE16,\n\t  offsetof(struct hclge_fd_rule, tuples.ether_proto),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.ether_proto) },\n\t{ INNER_L2_RSV, 16, KEY_OPT_LE16,\n\t  offsetof(struct hclge_fd_rule, tuples.l2_user_def),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.l2_user_def) },\n\t{ INNER_IP_TOS, 8, KEY_OPT_U8,\n\t  offsetof(struct hclge_fd_rule, tuples.ip_tos),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.ip_tos) },\n\t{ INNER_IP_PROTO, 8, KEY_OPT_U8,\n\t  offsetof(struct hclge_fd_rule, tuples.ip_proto),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.ip_proto) },\n\t{ INNER_SRC_IP, 32, KEY_OPT_IP,\n\t  offsetof(struct hclge_fd_rule, tuples.src_ip),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.src_ip) },\n\t{ INNER_DST_IP, 32, KEY_OPT_IP,\n\t  offsetof(struct hclge_fd_rule, tuples.dst_ip),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.dst_ip) },\n\t{ INNER_L3_RSV, 16, KEY_OPT_LE16,\n\t  offsetof(struct hclge_fd_rule, tuples.l3_user_def),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.l3_user_def) },\n\t{ INNER_SRC_PORT, 16, KEY_OPT_LE16,\n\t  offsetof(struct hclge_fd_rule, tuples.src_port),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.src_port) },\n\t{ INNER_DST_PORT, 16, KEY_OPT_LE16,\n\t  offsetof(struct hclge_fd_rule, tuples.dst_port),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.dst_port) },\n\t{ INNER_L4_RSV, 32, KEY_OPT_LE32,\n\t  offsetof(struct hclge_fd_rule, tuples.l4_user_def),\n\t  offsetof(struct hclge_fd_rule, tuples_mask.l4_user_def) },\n};\n\n \nint hclge_cmd_send(struct hclge_hw *hw, struct hclge_desc *desc, int num)\n{\n\treturn hclge_comm_cmd_send(&hw->hw, desc, num);\n}\n\nstatic int hclge_mac_update_stats_defective(struct hclge_dev *hdev)\n{\n#define HCLGE_MAC_CMD_NUM 21\n\n\tu64 *data = (u64 *)(&hdev->mac_stats);\n\tstruct hclge_desc desc[HCLGE_MAC_CMD_NUM];\n\t__le64 *desc_data;\n\tu32 data_size;\n\tint ret;\n\tu32 i;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_STATS_MAC, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, HCLGE_MAC_CMD_NUM);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get MAC pkt stats fail, status = %d.\\n\", ret);\n\n\t\treturn ret;\n\t}\n\n\t \n\tdata_size = sizeof(desc) / (sizeof(u64)) - 1;\n\n\tdesc_data = (__le64 *)(&desc[0].data[0]);\n\tfor (i = 0; i < data_size; i++) {\n\t\t \n\t\t*data += le64_to_cpu(*desc_data);\n\t\tdata++;\n\t\tdesc_data++;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_mac_update_stats_complete(struct hclge_dev *hdev)\n{\n#define HCLGE_REG_NUM_PER_DESC\t\t4\n\n\tu32 reg_num = hdev->ae_dev->dev_specs.mac_stats_num;\n\tu64 *data = (u64 *)(&hdev->mac_stats);\n\tstruct hclge_desc *desc;\n\t__le64 *desc_data;\n\tu32 data_size;\n\tu32 desc_num;\n\tint ret;\n\tu32 i;\n\n\t \n\tdesc_num = reg_num / HCLGE_REG_NUM_PER_DESC + 1;\n\n\t \n\tdesc = kcalloc(desc_num, sizeof(struct hclge_desc), GFP_ATOMIC);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_STATS_MAC_ALL, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, desc_num);\n\tif (ret) {\n\t\tkfree(desc);\n\t\treturn ret;\n\t}\n\n\tdata_size = min_t(u32, sizeof(hdev->mac_stats) / sizeof(u64), reg_num);\n\n\tdesc_data = (__le64 *)(&desc[0].data[0]);\n\tfor (i = 0; i < data_size; i++) {\n\t\t \n\t\t*data += le64_to_cpu(*desc_data);\n\t\tdata++;\n\t\tdesc_data++;\n\t}\n\n\tkfree(desc);\n\n\treturn 0;\n}\n\nstatic int hclge_mac_query_reg_num(struct hclge_dev *hdev, u32 *reg_num)\n{\n\tstruct hclge_desc desc;\n\tint ret;\n\n\t \n\tif (hdev->ae_dev->dev_version == HNAE3_DEVICE_VERSION_V2) {\n\t\t*reg_num = HCLGE_MAC_STATS_MAX_NUM_V1;\n\t\treturn 0;\n\t}\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_MAC_REG_NUM, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to query mac statistic reg number, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*reg_num = le32_to_cpu(desc.data[0]);\n\tif (*reg_num == 0) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mac statistic reg number is invalid!\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\treturn 0;\n}\n\nint hclge_mac_update_stats(struct hclge_dev *hdev)\n{\n\t \n\tif (hdev->ae_dev->dev_specs.mac_stats_num)\n\t\treturn hclge_mac_update_stats_complete(hdev);\n\telse\n\t\treturn hclge_mac_update_stats_defective(hdev);\n}\n\nstatic int hclge_comm_get_count(struct hclge_dev *hdev,\n\t\t\t\tconst struct hclge_comm_stats_str strs[],\n\t\t\t\tu32 size)\n{\n\tint count = 0;\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (strs[i].stats_num <= hdev->ae_dev->dev_specs.mac_stats_num)\n\t\t\tcount++;\n\n\treturn count;\n}\n\nstatic u64 *hclge_comm_get_stats(struct hclge_dev *hdev,\n\t\t\t\t const struct hclge_comm_stats_str strs[],\n\t\t\t\t int size, u64 *data)\n{\n\tu64 *buf = data;\n\tu32 i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (strs[i].stats_num > hdev->ae_dev->dev_specs.mac_stats_num)\n\t\t\tcontinue;\n\n\t\t*buf = HCLGE_STATS_READ(&hdev->mac_stats, strs[i].offset);\n\t\tbuf++;\n\t}\n\n\treturn buf;\n}\n\nstatic u8 *hclge_comm_get_strings(struct hclge_dev *hdev, u32 stringset,\n\t\t\t\t  const struct hclge_comm_stats_str strs[],\n\t\t\t\t  int size, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tu32 i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn buff;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (strs[i].stats_num > hdev->ae_dev->dev_specs.mac_stats_num)\n\t\t\tcontinue;\n\n\t\tsnprintf(buff, ETH_GSTRING_LEN, \"%s\", strs[i].desc);\n\t\tbuff = buff + ETH_GSTRING_LEN;\n\t}\n\n\treturn (u8 *)buff;\n}\n\nstatic void hclge_update_stats_for_all(struct hclge_dev *hdev)\n{\n\tstruct hnae3_handle *handle;\n\tint status;\n\n\thandle = &hdev->vport[0].nic;\n\tif (handle->client) {\n\t\tstatus = hclge_comm_tqps_update_stats(handle, &hdev->hw.hw);\n\t\tif (status) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"Update TQPS stats fail, status = %d.\\n\",\n\t\t\t\tstatus);\n\t\t}\n\t}\n\n\thclge_update_fec_stats(hdev);\n\n\tstatus = hclge_mac_update_stats(hdev);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Update MAC stats fail, status = %d.\\n\", status);\n}\n\nstatic void hclge_update_stats(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint status;\n\n\tif (test_and_set_bit(HCLGE_STATE_STATISTICS_UPDATING, &hdev->state))\n\t\treturn;\n\n\tstatus = hclge_mac_update_stats(hdev);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Update MAC stats fail, status = %d.\\n\",\n\t\t\tstatus);\n\n\tstatus = hclge_comm_tqps_update_stats(handle, &hdev->hw.hw);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Update TQPS stats fail, status = %d.\\n\",\n\t\t\tstatus);\n\n\tclear_bit(HCLGE_STATE_STATISTICS_UPDATING, &hdev->state);\n}\n\nstatic int hclge_get_sset_count(struct hnae3_handle *handle, int stringset)\n{\n#define HCLGE_LOOPBACK_TEST_FLAGS (HNAE3_SUPPORT_APP_LOOPBACK | \\\n\t\tHNAE3_SUPPORT_PHY_LOOPBACK | \\\n\t\tHNAE3_SUPPORT_SERDES_SERIAL_LOOPBACK | \\\n\t\tHNAE3_SUPPORT_SERDES_PARALLEL_LOOPBACK | \\\n\t\tHNAE3_SUPPORT_EXTERNAL_LOOPBACK)\n\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint count = 0;\n\n\t \n\tif (stringset == ETH_SS_TEST) {\n\t\t \n\t\thandle->flags = (handle->flags & (~HCLGE_LOOPBACK_TEST_FLAGS));\n\t\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2 ||\n\t\t    hdev->hw.mac.speed == HCLGE_MAC_SPEED_10M ||\n\t\t    hdev->hw.mac.speed == HCLGE_MAC_SPEED_100M ||\n\t\t    hdev->hw.mac.speed == HCLGE_MAC_SPEED_1G) {\n\t\t\tcount += 1;\n\t\t\thandle->flags |= HNAE3_SUPPORT_APP_LOOPBACK;\n\t\t}\n\n\t\tcount += 1;\n\t\thandle->flags |= HNAE3_SUPPORT_SERDES_SERIAL_LOOPBACK;\n\t\tcount += 1;\n\t\thandle->flags |= HNAE3_SUPPORT_SERDES_PARALLEL_LOOPBACK;\n\t\tcount += 1;\n\t\thandle->flags |= HNAE3_SUPPORT_EXTERNAL_LOOPBACK;\n\n\t\tif ((hdev->hw.mac.phydev && hdev->hw.mac.phydev->drv &&\n\t\t     hdev->hw.mac.phydev->drv->set_loopback) ||\n\t\t    hnae3_dev_phy_imp_supported(hdev)) {\n\t\t\tcount += 1;\n\t\t\thandle->flags |= HNAE3_SUPPORT_PHY_LOOPBACK;\n\t\t}\n\t} else if (stringset == ETH_SS_STATS) {\n\t\tcount = hclge_comm_get_count(hdev, g_mac_stats_string,\n\t\t\t\t\t     ARRAY_SIZE(g_mac_stats_string)) +\n\t\t\thclge_comm_tqps_get_sset_count(handle);\n\t}\n\n\treturn count;\n}\n\nstatic void hclge_get_strings(struct hnae3_handle *handle, u32 stringset,\n\t\t\t      u8 *data)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu8 *p = (char *)data;\n\tint size;\n\n\tif (stringset == ETH_SS_STATS) {\n\t\tsize = ARRAY_SIZE(g_mac_stats_string);\n\t\tp = hclge_comm_get_strings(hdev, stringset, g_mac_stats_string,\n\t\t\t\t\t   size, p);\n\t\tp = hclge_comm_tqps_get_strings(handle, p);\n\t} else if (stringset == ETH_SS_TEST) {\n\t\tif (handle->flags & HNAE3_SUPPORT_EXTERNAL_LOOPBACK) {\n\t\t\tmemcpy(p, hns3_nic_test_strs[HNAE3_LOOP_EXTERNAL],\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tif (handle->flags & HNAE3_SUPPORT_APP_LOOPBACK) {\n\t\t\tmemcpy(p, hns3_nic_test_strs[HNAE3_LOOP_APP],\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tif (handle->flags & HNAE3_SUPPORT_SERDES_SERIAL_LOOPBACK) {\n\t\t\tmemcpy(p, hns3_nic_test_strs[HNAE3_LOOP_SERIAL_SERDES],\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tif (handle->flags & HNAE3_SUPPORT_SERDES_PARALLEL_LOOPBACK) {\n\t\t\tmemcpy(p,\n\t\t\t       hns3_nic_test_strs[HNAE3_LOOP_PARALLEL_SERDES],\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tif (handle->flags & HNAE3_SUPPORT_PHY_LOOPBACK) {\n\t\t\tmemcpy(p, hns3_nic_test_strs[HNAE3_LOOP_PHY],\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t}\n}\n\nstatic void hclge_get_stats(struct hnae3_handle *handle, u64 *data)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu64 *p;\n\n\tp = hclge_comm_get_stats(hdev, g_mac_stats_string,\n\t\t\t\t ARRAY_SIZE(g_mac_stats_string), data);\n\tp = hclge_comm_tqps_get_stats(handle, p);\n}\n\nstatic void hclge_get_mac_stat(struct hnae3_handle *handle,\n\t\t\t       struct hns3_mac_stats *mac_stats)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\thclge_update_stats(handle);\n\n\tmac_stats->tx_pause_cnt = hdev->mac_stats.mac_tx_mac_pause_num;\n\tmac_stats->rx_pause_cnt = hdev->mac_stats.mac_rx_mac_pause_num;\n}\n\nstatic int hclge_parse_func_status(struct hclge_dev *hdev,\n\t\t\t\t   struct hclge_func_status_cmd *status)\n{\n#define HCLGE_MAC_ID_MASK\t0xF\n\n\tif (!(status->pf_state & HCLGE_PF_STATE_DONE))\n\t\treturn -EINVAL;\n\n\t \n\tif (status->pf_state & HCLGE_PF_STATE_MAIN)\n\t\thdev->flag |= HCLGE_FLAG_MAIN;\n\telse\n\t\thdev->flag &= ~HCLGE_FLAG_MAIN;\n\n\thdev->hw.mac.mac_id = status->mac_id & HCLGE_MAC_ID_MASK;\n\treturn 0;\n}\n\nstatic int hclge_query_function_status(struct hclge_dev *hdev)\n{\n#define HCLGE_QUERY_MAX_CNT\t5\n\n\tstruct hclge_func_status_cmd *req;\n\tstruct hclge_desc desc;\n\tint timeout = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_FUNC_STATUS, true);\n\treq = (struct hclge_func_status_cmd *)desc.data;\n\n\tdo {\n\t\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"query function status failed %d.\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (req->pf_state)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (timeout++ < HCLGE_QUERY_MAX_CNT);\n\n\treturn hclge_parse_func_status(hdev, req);\n}\n\nstatic int hclge_query_pf_resource(struct hclge_dev *hdev)\n{\n\tstruct hclge_pf_res_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_PF_RSRC, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"query pf resource failed %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treq = (struct hclge_pf_res_cmd *)desc.data;\n\thdev->num_tqps = le16_to_cpu(req->tqp_num) +\n\t\t\t le16_to_cpu(req->ext_tqp_num);\n\thdev->pkt_buf_size = le16_to_cpu(req->buf_size) << HCLGE_BUF_UNIT_S;\n\n\tif (req->tx_buf_size)\n\t\thdev->tx_buf_size =\n\t\t\tle16_to_cpu(req->tx_buf_size) << HCLGE_BUF_UNIT_S;\n\telse\n\t\thdev->tx_buf_size = HCLGE_DEFAULT_TX_BUF;\n\n\thdev->tx_buf_size = roundup(hdev->tx_buf_size, HCLGE_BUF_SIZE_UNIT);\n\n\tif (req->dv_buf_size)\n\t\thdev->dv_buf_size =\n\t\t\tle16_to_cpu(req->dv_buf_size) << HCLGE_BUF_UNIT_S;\n\telse\n\t\thdev->dv_buf_size = HCLGE_DEFAULT_DV;\n\n\thdev->dv_buf_size = roundup(hdev->dv_buf_size, HCLGE_BUF_SIZE_UNIT);\n\n\thdev->num_nic_msi = le16_to_cpu(req->msixcap_localid_number_nic);\n\tif (hdev->num_nic_msi < HNAE3_MIN_VECTOR_NUM) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"only %u msi resources available, not enough for pf(min:2).\\n\",\n\t\t\thdev->num_nic_msi);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hnae3_dev_roce_supported(hdev)) {\n\t\thdev->num_roce_msi =\n\t\t\tle16_to_cpu(req->pf_intr_vector_number_roce);\n\n\t\t \n\t\thdev->num_msi = hdev->num_nic_msi + hdev->num_roce_msi;\n\t} else {\n\t\thdev->num_msi = hdev->num_nic_msi;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_parse_speed(u8 speed_cmd, u32 *speed)\n{\n\tswitch (speed_cmd) {\n\tcase HCLGE_FW_MAC_SPEED_10M:\n\t\t*speed = HCLGE_MAC_SPEED_10M;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_100M:\n\t\t*speed = HCLGE_MAC_SPEED_100M;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_1G:\n\t\t*speed = HCLGE_MAC_SPEED_1G;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_10G:\n\t\t*speed = HCLGE_MAC_SPEED_10G;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_25G:\n\t\t*speed = HCLGE_MAC_SPEED_25G;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_40G:\n\t\t*speed = HCLGE_MAC_SPEED_40G;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_50G:\n\t\t*speed = HCLGE_MAC_SPEED_50G;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_100G:\n\t\t*speed = HCLGE_MAC_SPEED_100G;\n\t\tbreak;\n\tcase HCLGE_FW_MAC_SPEED_200G:\n\t\t*speed = HCLGE_MAC_SPEED_200G;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hclge_speed_bit_map speed_bit_map[] = {\n\t{HCLGE_MAC_SPEED_10M, HCLGE_SUPPORT_10M_BIT},\n\t{HCLGE_MAC_SPEED_100M, HCLGE_SUPPORT_100M_BIT},\n\t{HCLGE_MAC_SPEED_1G, HCLGE_SUPPORT_1G_BIT},\n\t{HCLGE_MAC_SPEED_10G, HCLGE_SUPPORT_10G_BIT},\n\t{HCLGE_MAC_SPEED_25G, HCLGE_SUPPORT_25G_BIT},\n\t{HCLGE_MAC_SPEED_40G, HCLGE_SUPPORT_40G_BIT},\n\t{HCLGE_MAC_SPEED_50G, HCLGE_SUPPORT_50G_BIT},\n\t{HCLGE_MAC_SPEED_100G, HCLGE_SUPPORT_100G_BIT},\n\t{HCLGE_MAC_SPEED_200G, HCLGE_SUPPORT_200G_BIT},\n};\n\nstatic int hclge_get_speed_bit(u32 speed, u32 *speed_bit)\n{\n\tu16 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(speed_bit_map); i++) {\n\t\tif (speed == speed_bit_map[i].speed) {\n\t\t\t*speed_bit = speed_bit_map[i].speed_bit;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hclge_check_port_speed(struct hnae3_handle *handle, u32 speed)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 speed_ability = hdev->hw.mac.speed_ability;\n\tu32 speed_bit = 0;\n\tint ret;\n\n\tret = hclge_get_speed_bit(speed, &speed_bit);\n\tif (ret)\n\t\treturn ret;\n\n\tif (speed_bit & speed_ability)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void hclge_update_fec_support(struct hclge_mac *mac)\n{\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT, mac->supported);\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT, mac->supported);\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_FEC_LLRS_BIT, mac->supported);\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT, mac->supported);\n\n\tif (mac->fec_ability & BIT(HNAE3_FEC_BASER))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT,\n\t\t\t\t mac->supported);\n\tif (mac->fec_ability & BIT(HNAE3_FEC_RS))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t\t\t\t mac->supported);\n\tif (mac->fec_ability & BIT(HNAE3_FEC_LLRS))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_LLRS_BIT,\n\t\t\t\t mac->supported);\n\tif (mac->fec_ability & BIT(HNAE3_FEC_NONE))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT,\n\t\t\t\t mac->supported);\n}\n\nstatic void hclge_convert_setting_sr(u16 speed_ability,\n\t\t\t\t     unsigned long *link_mode)\n{\n\tif (speed_ability & HCLGE_SUPPORT_10G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_25G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_40G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_50G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_100G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_200G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT,\n\t\t\t\t link_mode);\n}\n\nstatic void hclge_convert_setting_lr(u16 speed_ability,\n\t\t\t\t     unsigned long *link_mode)\n{\n\tif (speed_ability & HCLGE_SUPPORT_10G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_25G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_50G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_40G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_100G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_200G_BIT)\n\t\tlinkmode_set_bit(\n\t\t\tETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT,\n\t\t\tlink_mode);\n}\n\nstatic void hclge_convert_setting_cr(u16 speed_ability,\n\t\t\t\t     unsigned long *link_mode)\n{\n\tif (speed_ability & HCLGE_SUPPORT_10G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseCR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_25G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_40G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_50G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_100G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_200G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT,\n\t\t\t\t link_mode);\n}\n\nstatic void hclge_convert_setting_kr(u16 speed_ability,\n\t\t\t\t     unsigned long *link_mode)\n{\n\tif (speed_ability & HCLGE_SUPPORT_1G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_10G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_25G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_40G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_50G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_100G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT,\n\t\t\t\t link_mode);\n\tif (speed_ability & HCLGE_SUPPORT_200G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT,\n\t\t\t\t link_mode);\n}\n\nstatic void hclge_convert_setting_fec(struct hclge_mac *mac)\n{\n\t \n\tif (mac->fec_ability)\n\t\tgoto out;\n\n\tswitch (mac->speed) {\n\tcase HCLGE_MAC_SPEED_10G:\n\tcase HCLGE_MAC_SPEED_40G:\n\t\tmac->fec_ability = BIT(HNAE3_FEC_BASER) | BIT(HNAE3_FEC_AUTO) |\n\t\t\t\t   BIT(HNAE3_FEC_NONE);\n\t\tbreak;\n\tcase HCLGE_MAC_SPEED_25G:\n\tcase HCLGE_MAC_SPEED_50G:\n\t\tmac->fec_ability = BIT(HNAE3_FEC_BASER) | BIT(HNAE3_FEC_RS) |\n\t\t\t\t   BIT(HNAE3_FEC_AUTO) | BIT(HNAE3_FEC_NONE);\n\t\tbreak;\n\tcase HCLGE_MAC_SPEED_100G:\n\t\tmac->fec_ability = BIT(HNAE3_FEC_RS) | BIT(HNAE3_FEC_AUTO) |\n\t\t\t\t   BIT(HNAE3_FEC_NONE);\n\t\tbreak;\n\tcase HCLGE_MAC_SPEED_200G:\n\t\tmac->fec_ability = BIT(HNAE3_FEC_RS) | BIT(HNAE3_FEC_AUTO) |\n\t\t\t\t   BIT(HNAE3_FEC_LLRS);\n\t\tbreak;\n\tdefault:\n\t\tmac->fec_ability = 0;\n\t\tbreak;\n\t}\n\nout:\n\thclge_update_fec_support(mac);\n}\n\nstatic void hclge_parse_fiber_link_mode(struct hclge_dev *hdev,\n\t\t\t\t\tu16 speed_ability)\n{\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\n\tif (speed_ability & HCLGE_SUPPORT_1G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t mac->supported);\n\n\thclge_convert_setting_sr(speed_ability, mac->supported);\n\thclge_convert_setting_lr(speed_ability, mac->supported);\n\thclge_convert_setting_cr(speed_ability, mac->supported);\n\tif (hnae3_dev_fec_supported(hdev))\n\t\thclge_convert_setting_fec(mac);\n\n\tif (hnae3_dev_pause_supported(hdev))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, mac->supported);\n\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, mac->supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT, mac->supported);\n}\n\nstatic void hclge_parse_backplane_link_mode(struct hclge_dev *hdev,\n\t\t\t\t\t    u16 speed_ability)\n{\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\n\thclge_convert_setting_kr(speed_ability, mac->supported);\n\tif (hnae3_dev_fec_supported(hdev))\n\t\thclge_convert_setting_fec(mac);\n\n\tif (hnae3_dev_pause_supported(hdev))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, mac->supported);\n\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Backplane_BIT, mac->supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT, mac->supported);\n}\n\nstatic void hclge_parse_copper_link_mode(struct hclge_dev *hdev,\n\t\t\t\t\t u16 speed_ability)\n{\n\tunsigned long *supported = hdev->hw.mac.supported;\n\n\t \n\tif (!speed_ability)\n\t\tspeed_ability = HCLGE_SUPPORT_GE;\n\n\tif (speed_ability & HCLGE_SUPPORT_1G_BIT)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t supported);\n\n\tif (speed_ability & HCLGE_SUPPORT_100M_BIT) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\t\t\t supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\t\t\t\t supported);\n\t}\n\n\tif (speed_ability & HCLGE_SUPPORT_10M_BIT) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, supported);\n\t}\n\n\tif (hnae3_dev_pause_supported(hdev)) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, supported);\n\t}\n\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT, supported);\n}\n\nstatic void hclge_parse_link_mode(struct hclge_dev *hdev, u16 speed_ability)\n{\n\tu8 media_type = hdev->hw.mac.media_type;\n\n\tif (media_type == HNAE3_MEDIA_TYPE_FIBER)\n\t\thclge_parse_fiber_link_mode(hdev, speed_ability);\n\telse if (media_type == HNAE3_MEDIA_TYPE_COPPER)\n\t\thclge_parse_copper_link_mode(hdev, speed_ability);\n\telse if (media_type == HNAE3_MEDIA_TYPE_BACKPLANE)\n\t\thclge_parse_backplane_link_mode(hdev, speed_ability);\n}\n\nstatic u32 hclge_get_max_speed(u16 speed_ability)\n{\n\tif (speed_ability & HCLGE_SUPPORT_200G_BIT)\n\t\treturn HCLGE_MAC_SPEED_200G;\n\n\tif (speed_ability & HCLGE_SUPPORT_100G_BIT)\n\t\treturn HCLGE_MAC_SPEED_100G;\n\n\tif (speed_ability & HCLGE_SUPPORT_50G_BIT)\n\t\treturn HCLGE_MAC_SPEED_50G;\n\n\tif (speed_ability & HCLGE_SUPPORT_40G_BIT)\n\t\treturn HCLGE_MAC_SPEED_40G;\n\n\tif (speed_ability & HCLGE_SUPPORT_25G_BIT)\n\t\treturn HCLGE_MAC_SPEED_25G;\n\n\tif (speed_ability & HCLGE_SUPPORT_10G_BIT)\n\t\treturn HCLGE_MAC_SPEED_10G;\n\n\tif (speed_ability & HCLGE_SUPPORT_1G_BIT)\n\t\treturn HCLGE_MAC_SPEED_1G;\n\n\tif (speed_ability & HCLGE_SUPPORT_100M_BIT)\n\t\treturn HCLGE_MAC_SPEED_100M;\n\n\tif (speed_ability & HCLGE_SUPPORT_10M_BIT)\n\t\treturn HCLGE_MAC_SPEED_10M;\n\n\treturn HCLGE_MAC_SPEED_1G;\n}\n\nstatic void hclge_parse_cfg(struct hclge_cfg *cfg, struct hclge_desc *desc)\n{\n#define HCLGE_TX_SPARE_SIZE_UNIT\t\t4096\n#define SPEED_ABILITY_EXT_SHIFT\t\t\t8\n\n\tstruct hclge_cfg_param_cmd *req;\n\tu64 mac_addr_tmp_high;\n\tu16 speed_ability_ext;\n\tu64 mac_addr_tmp;\n\tunsigned int i;\n\n\treq = (struct hclge_cfg_param_cmd *)desc[0].data;\n\n\t \n\tcfg->tc_num = hnae3_get_field(__le32_to_cpu(req->param[0]),\n\t\t\t\t      HCLGE_CFG_TC_NUM_M, HCLGE_CFG_TC_NUM_S);\n\tcfg->tqp_desc_num = hnae3_get_field(__le32_to_cpu(req->param[0]),\n\t\t\t\t\t    HCLGE_CFG_TQP_DESC_N_M,\n\t\t\t\t\t    HCLGE_CFG_TQP_DESC_N_S);\n\n\tcfg->phy_addr = hnae3_get_field(__le32_to_cpu(req->param[1]),\n\t\t\t\t\tHCLGE_CFG_PHY_ADDR_M,\n\t\t\t\t\tHCLGE_CFG_PHY_ADDR_S);\n\tcfg->media_type = hnae3_get_field(__le32_to_cpu(req->param[1]),\n\t\t\t\t\t  HCLGE_CFG_MEDIA_TP_M,\n\t\t\t\t\t  HCLGE_CFG_MEDIA_TP_S);\n\tcfg->rx_buf_len = hnae3_get_field(__le32_to_cpu(req->param[1]),\n\t\t\t\t\t  HCLGE_CFG_RX_BUF_LEN_M,\n\t\t\t\t\t  HCLGE_CFG_RX_BUF_LEN_S);\n\t \n\tmac_addr_tmp = __le32_to_cpu(req->param[2]);\n\tmac_addr_tmp_high = hnae3_get_field(__le32_to_cpu(req->param[3]),\n\t\t\t\t\t    HCLGE_CFG_MAC_ADDR_H_M,\n\t\t\t\t\t    HCLGE_CFG_MAC_ADDR_H_S);\n\n\tmac_addr_tmp |= (mac_addr_tmp_high << 31) << 1;\n\n\tcfg->default_speed = hnae3_get_field(__le32_to_cpu(req->param[3]),\n\t\t\t\t\t     HCLGE_CFG_DEFAULT_SPEED_M,\n\t\t\t\t\t     HCLGE_CFG_DEFAULT_SPEED_S);\n\tcfg->vf_rss_size_max = hnae3_get_field(__le32_to_cpu(req->param[3]),\n\t\t\t\t\t       HCLGE_CFG_RSS_SIZE_M,\n\t\t\t\t\t       HCLGE_CFG_RSS_SIZE_S);\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tcfg->mac_addr[i] = (mac_addr_tmp >> (8 * i)) & 0xff;\n\n\treq = (struct hclge_cfg_param_cmd *)desc[1].data;\n\tcfg->numa_node_map = __le32_to_cpu(req->param[0]);\n\n\tcfg->speed_ability = hnae3_get_field(__le32_to_cpu(req->param[1]),\n\t\t\t\t\t     HCLGE_CFG_SPEED_ABILITY_M,\n\t\t\t\t\t     HCLGE_CFG_SPEED_ABILITY_S);\n\tspeed_ability_ext = hnae3_get_field(__le32_to_cpu(req->param[1]),\n\t\t\t\t\t    HCLGE_CFG_SPEED_ABILITY_EXT_M,\n\t\t\t\t\t    HCLGE_CFG_SPEED_ABILITY_EXT_S);\n\tcfg->speed_ability |= speed_ability_ext << SPEED_ABILITY_EXT_SHIFT;\n\n\tcfg->vlan_fliter_cap = hnae3_get_field(__le32_to_cpu(req->param[1]),\n\t\t\t\t\t       HCLGE_CFG_VLAN_FLTR_CAP_M,\n\t\t\t\t\t       HCLGE_CFG_VLAN_FLTR_CAP_S);\n\n\tcfg->umv_space = hnae3_get_field(__le32_to_cpu(req->param[1]),\n\t\t\t\t\t HCLGE_CFG_UMV_TBL_SPACE_M,\n\t\t\t\t\t HCLGE_CFG_UMV_TBL_SPACE_S);\n\n\tcfg->pf_rss_size_max = hnae3_get_field(__le32_to_cpu(req->param[2]),\n\t\t\t\t\t       HCLGE_CFG_PF_RSS_SIZE_M,\n\t\t\t\t\t       HCLGE_CFG_PF_RSS_SIZE_S);\n\n\t \n\tcfg->pf_rss_size_max = cfg->pf_rss_size_max ?\n\t\t\t       1U << cfg->pf_rss_size_max :\n\t\t\t       cfg->vf_rss_size_max;\n\n\t \n\tcfg->tx_spare_buf_size = hnae3_get_field(__le32_to_cpu(req->param[2]),\n\t\t\t\t\t\t HCLGE_CFG_TX_SPARE_BUF_SIZE_M,\n\t\t\t\t\t\t HCLGE_CFG_TX_SPARE_BUF_SIZE_S);\n\tcfg->tx_spare_buf_size *= HCLGE_TX_SPARE_SIZE_UNIT;\n}\n\n \nstatic int hclge_get_cfg(struct hclge_dev *hdev, struct hclge_cfg *hcfg)\n{\n\tstruct hclge_desc desc[HCLGE_PF_CFG_DESC_NUM];\n\tstruct hclge_cfg_param_cmd *req;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < HCLGE_PF_CFG_DESC_NUM; i++) {\n\t\tu32 offset = 0;\n\n\t\treq = (struct hclge_cfg_param_cmd *)desc[i].data;\n\t\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_GET_CFG_PARAM,\n\t\t\t\t\t   true);\n\t\thnae3_set_field(offset, HCLGE_CFG_OFFSET_M,\n\t\t\t\tHCLGE_CFG_OFFSET_S, i * HCLGE_CFG_RD_LEN_BYTES);\n\t\t \n\t\thnae3_set_field(offset, HCLGE_CFG_RD_LEN_M, HCLGE_CFG_RD_LEN_S,\n\t\t\t\tHCLGE_CFG_RD_LEN_BYTES / HCLGE_CFG_RD_LEN_UNIT);\n\t\treq->offset = cpu_to_le32(offset);\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, desc, HCLGE_PF_CFG_DESC_NUM);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"get config failed %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thclge_parse_cfg(hcfg, desc);\n\n\treturn 0;\n}\n\nstatic void hclge_set_default_dev_specs(struct hclge_dev *hdev)\n{\n#define HCLGE_MAX_NON_TSO_BD_NUM\t\t\t8U\n\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\n\tae_dev->dev_specs.max_non_tso_bd_num = HCLGE_MAX_NON_TSO_BD_NUM;\n\tae_dev->dev_specs.rss_ind_tbl_size = HCLGE_RSS_IND_TBL_SIZE;\n\tae_dev->dev_specs.rss_key_size = HCLGE_COMM_RSS_KEY_SIZE;\n\tae_dev->dev_specs.max_tm_rate = HCLGE_ETHER_MAX_RATE;\n\tae_dev->dev_specs.max_int_gl = HCLGE_DEF_MAX_INT_GL;\n\tae_dev->dev_specs.max_frm_size = HCLGE_MAC_MAX_FRAME;\n\tae_dev->dev_specs.max_qset_num = HCLGE_MAX_QSET_NUM;\n\tae_dev->dev_specs.umv_size = HCLGE_DEFAULT_UMV_SPACE_PER_PF;\n\tae_dev->dev_specs.tnl_num = 0;\n}\n\nstatic void hclge_parse_dev_specs(struct hclge_dev *hdev,\n\t\t\t\t  struct hclge_desc *desc)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tstruct hclge_dev_specs_0_cmd *req0;\n\tstruct hclge_dev_specs_1_cmd *req1;\n\n\treq0 = (struct hclge_dev_specs_0_cmd *)desc[0].data;\n\treq1 = (struct hclge_dev_specs_1_cmd *)desc[1].data;\n\n\tae_dev->dev_specs.max_non_tso_bd_num = req0->max_non_tso_bd_num;\n\tae_dev->dev_specs.rss_ind_tbl_size =\n\t\tle16_to_cpu(req0->rss_ind_tbl_size);\n\tae_dev->dev_specs.int_ql_max = le16_to_cpu(req0->int_ql_max);\n\tae_dev->dev_specs.rss_key_size = le16_to_cpu(req0->rss_key_size);\n\tae_dev->dev_specs.max_tm_rate = le32_to_cpu(req0->max_tm_rate);\n\tae_dev->dev_specs.max_qset_num = le16_to_cpu(req1->max_qset_num);\n\tae_dev->dev_specs.max_int_gl = le16_to_cpu(req1->max_int_gl);\n\tae_dev->dev_specs.max_frm_size = le16_to_cpu(req1->max_frm_size);\n\tae_dev->dev_specs.umv_size = le16_to_cpu(req1->umv_size);\n\tae_dev->dev_specs.mc_mac_size = le16_to_cpu(req1->mc_mac_size);\n\tae_dev->dev_specs.tnl_num = req1->tnl_num;\n}\n\nstatic void hclge_check_dev_specs(struct hclge_dev *hdev)\n{\n\tstruct hnae3_dev_specs *dev_specs = &hdev->ae_dev->dev_specs;\n\n\tif (!dev_specs->max_non_tso_bd_num)\n\t\tdev_specs->max_non_tso_bd_num = HCLGE_MAX_NON_TSO_BD_NUM;\n\tif (!dev_specs->rss_ind_tbl_size)\n\t\tdev_specs->rss_ind_tbl_size = HCLGE_RSS_IND_TBL_SIZE;\n\tif (!dev_specs->rss_key_size)\n\t\tdev_specs->rss_key_size = HCLGE_COMM_RSS_KEY_SIZE;\n\tif (!dev_specs->max_tm_rate)\n\t\tdev_specs->max_tm_rate = HCLGE_ETHER_MAX_RATE;\n\tif (!dev_specs->max_qset_num)\n\t\tdev_specs->max_qset_num = HCLGE_MAX_QSET_NUM;\n\tif (!dev_specs->max_int_gl)\n\t\tdev_specs->max_int_gl = HCLGE_DEF_MAX_INT_GL;\n\tif (!dev_specs->max_frm_size)\n\t\tdev_specs->max_frm_size = HCLGE_MAC_MAX_FRAME;\n\tif (!dev_specs->umv_size)\n\t\tdev_specs->umv_size = HCLGE_DEFAULT_UMV_SPACE_PER_PF;\n}\n\nstatic int hclge_query_mac_stats_num(struct hclge_dev *hdev)\n{\n\tu32 reg_num = 0;\n\tint ret;\n\n\tret = hclge_mac_query_reg_num(hdev, &reg_num);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\thdev->ae_dev->dev_specs.mac_stats_num = reg_num;\n\treturn 0;\n}\n\nstatic int hclge_query_dev_specs(struct hclge_dev *hdev)\n{\n\tstruct hclge_desc desc[HCLGE_QUERY_DEV_SPECS_BD_NUM];\n\tint ret;\n\tint i;\n\n\tret = hclge_query_mac_stats_num(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V3) {\n\t\thclge_set_default_dev_specs(hdev);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < HCLGE_QUERY_DEV_SPECS_BD_NUM - 1; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_QUERY_DEV_SPECS,\n\t\t\t\t\t   true);\n\t\tdesc[i].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t}\n\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_QUERY_DEV_SPECS, true);\n\n\tret = hclge_cmd_send(&hdev->hw, desc, HCLGE_QUERY_DEV_SPECS_BD_NUM);\n\tif (ret)\n\t\treturn ret;\n\n\thclge_parse_dev_specs(hdev, desc);\n\thclge_check_dev_specs(hdev);\n\n\treturn 0;\n}\n\nstatic int hclge_get_cap(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\tret = hclge_query_function_status(hdev);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"query function status error %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn hclge_query_pf_resource(hdev);\n}\n\nstatic void hclge_init_kdump_kernel_config(struct hclge_dev *hdev)\n{\n#define HCLGE_MIN_TX_DESC\t64\n#define HCLGE_MIN_RX_DESC\t64\n\n\tif (!is_kdump_kernel())\n\t\treturn;\n\n\tdev_info(&hdev->pdev->dev,\n\t\t \"Running kdump kernel. Using minimal resources\\n\");\n\n\t \n\thdev->num_tqps = hdev->num_req_vfs + 1;\n\thdev->num_tx_desc = HCLGE_MIN_TX_DESC;\n\thdev->num_rx_desc = HCLGE_MIN_RX_DESC;\n}\n\nstatic void hclge_init_tc_config(struct hclge_dev *hdev)\n{\n\tunsigned int i;\n\n\tif (hdev->tc_max > HNAE3_MAX_TC ||\n\t    hdev->tc_max < 1) {\n\t\tdev_warn(&hdev->pdev->dev, \"TC num = %u.\\n\",\n\t\t\t hdev->tc_max);\n\t\thdev->tc_max = 1;\n\t}\n\n\t \n\tif (!hnae3_dev_dcb_supported(hdev)) {\n\t\thdev->tc_max = 1;\n\t\thdev->pfc_max = 0;\n\t} else {\n\t\thdev->pfc_max = hdev->tc_max;\n\t}\n\n\thdev->tm_info.num_tc = 1;\n\n\t \n\tfor (i = 0; i < hdev->tm_info.num_tc; i++)\n\t\thnae3_set_bit(hdev->hw_tc_map, i, 1);\n\n\thdev->tx_sch_mode = HCLGE_FLAG_TC_BASE_SCH_MODE;\n}\n\nstatic int hclge_configure(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tstruct hclge_cfg cfg;\n\tint ret;\n\n\tret = hclge_get_cfg(hdev, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->base_tqp_pid = 0;\n\thdev->vf_rss_size_max = cfg.vf_rss_size_max;\n\thdev->pf_rss_size_max = cfg.pf_rss_size_max;\n\thdev->rx_buf_len = cfg.rx_buf_len;\n\tether_addr_copy(hdev->hw.mac.mac_addr, cfg.mac_addr);\n\thdev->hw.mac.media_type = cfg.media_type;\n\thdev->hw.mac.phy_addr = cfg.phy_addr;\n\thdev->num_tx_desc = cfg.tqp_desc_num;\n\thdev->num_rx_desc = cfg.tqp_desc_num;\n\thdev->tm_info.num_pg = 1;\n\thdev->tc_max = cfg.tc_num;\n\thdev->tm_info.hw_pfc_map = 0;\n\tif (cfg.umv_space)\n\t\thdev->wanted_umv_size = cfg.umv_space;\n\telse\n\t\thdev->wanted_umv_size = hdev->ae_dev->dev_specs.umv_size;\n\thdev->tx_spare_buf_size = cfg.tx_spare_buf_size;\n\thdev->gro_en = true;\n\tif (cfg.vlan_fliter_cap == HCLGE_VLAN_FLTR_CAN_MDF)\n\t\tset_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, ae_dev->caps);\n\n\tif (hnae3_ae_dev_fd_supported(hdev->ae_dev)) {\n\t\thdev->fd_en = true;\n\t\thdev->fd_active_type = HCLGE_FD_RULE_NONE;\n\t}\n\n\tret = hclge_parse_speed(cfg.default_speed, &hdev->hw.mac.speed);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"failed to parse speed %u, ret = %d\\n\",\n\t\t\tcfg.default_speed, ret);\n\t\treturn ret;\n\t}\n\n\thclge_parse_link_mode(hdev, cfg.speed_ability);\n\n\thdev->hw.mac.max_speed = hclge_get_max_speed(cfg.speed_ability);\n\n\thclge_init_tc_config(hdev);\n\thclge_init_kdump_kernel_config(hdev);\n\n\treturn ret;\n}\n\nstatic int hclge_config_tso(struct hclge_dev *hdev, u16 tso_mss_min,\n\t\t\t    u16 tso_mss_max)\n{\n\tstruct hclge_cfg_tso_status_cmd *req;\n\tstruct hclge_desc desc;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_TSO_GENERIC_CONFIG, false);\n\n\treq = (struct hclge_cfg_tso_status_cmd *)desc.data;\n\treq->tso_mss_min = cpu_to_le16(tso_mss_min);\n\treq->tso_mss_max = cpu_to_le16(tso_mss_max);\n\n\treturn hclge_cmd_send(&hdev->hw, &desc, 1);\n}\n\nstatic int hclge_config_gro(struct hclge_dev *hdev)\n{\n\tstruct hclge_cfg_gro_status_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tif (!hnae3_ae_dev_gro_supported(hdev->ae_dev))\n\t\treturn 0;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_GRO_GENERIC_CONFIG, false);\n\treq = (struct hclge_cfg_gro_status_cmd *)desc.data;\n\n\treq->gro_en = hdev->gro_en ? 1 : 0;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"GRO hardware config cmd failed, ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_alloc_tqps(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tstruct hclge_comm_tqp *tqp;\n\tint i;\n\n\thdev->htqp = devm_kcalloc(&hdev->pdev->dev, hdev->num_tqps,\n\t\t\t\t  sizeof(struct hclge_comm_tqp), GFP_KERNEL);\n\tif (!hdev->htqp)\n\t\treturn -ENOMEM;\n\n\ttqp = hdev->htqp;\n\n\tfor (i = 0; i < hdev->num_tqps; i++) {\n\t\ttqp->dev = &hdev->pdev->dev;\n\t\ttqp->index = i;\n\n\t\ttqp->q.ae_algo = &ae_algo;\n\t\ttqp->q.buf_size = hdev->rx_buf_len;\n\t\ttqp->q.tx_desc_num = hdev->num_tx_desc;\n\t\ttqp->q.rx_desc_num = hdev->num_rx_desc;\n\n\t\t \n\t\tif (i < HCLGE_TQP_MAX_SIZE_DEV_V2)\n\t\t\ttqp->q.io_base = hdev->hw.hw.io_base +\n\t\t\t\t\t HCLGE_TQP_REG_OFFSET +\n\t\t\t\t\t i * HCLGE_TQP_REG_SIZE;\n\t\telse\n\t\t\ttqp->q.io_base = hdev->hw.hw.io_base +\n\t\t\t\t\t HCLGE_TQP_REG_OFFSET +\n\t\t\t\t\t HCLGE_TQP_EXT_REG_OFFSET +\n\t\t\t\t\t (i - HCLGE_TQP_MAX_SIZE_DEV_V2) *\n\t\t\t\t\t HCLGE_TQP_REG_SIZE;\n\n\t\t \n\t\tif (test_bit(HNAE3_DEV_SUPPORT_TX_PUSH_B, ae_dev->caps))\n\t\t\ttqp->q.mem_base = hdev->hw.hw.mem_base +\n\t\t\t\t\t  HCLGE_TQP_MEM_OFFSET(hdev, i);\n\n\t\ttqp++;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_map_tqps_to_func(struct hclge_dev *hdev, u16 func_id,\n\t\t\t\t  u16 tqp_pid, u16 tqp_vid, bool is_pf)\n{\n\tstruct hclge_tqp_map_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_SET_TQP_MAP, false);\n\n\treq = (struct hclge_tqp_map_cmd *)desc.data;\n\treq->tqp_id = cpu_to_le16(tqp_pid);\n\treq->tqp_vf = func_id;\n\treq->tqp_flag = 1U << HCLGE_TQP_MAP_EN_B;\n\tif (!is_pf)\n\t\treq->tqp_flag |= 1U << HCLGE_TQP_MAP_TYPE_B;\n\treq->tqp_vid = cpu_to_le16(tqp_vid);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"TQP map failed %d.\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int  hclge_assign_tqp(struct hclge_vport *vport, u16 num_tqps)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint i, alloced;\n\n\tfor (i = 0, alloced = 0; i < hdev->num_tqps &&\n\t     alloced < num_tqps; i++) {\n\t\tif (!hdev->htqp[i].alloced) {\n\t\t\thdev->htqp[i].q.handle = &vport->nic;\n\t\t\thdev->htqp[i].q.tqp_index = alloced;\n\t\t\thdev->htqp[i].q.tx_desc_num = kinfo->num_tx_desc;\n\t\t\thdev->htqp[i].q.rx_desc_num = kinfo->num_rx_desc;\n\t\t\tkinfo->tqp[alloced] = &hdev->htqp[i].q;\n\t\t\thdev->htqp[i].alloced = true;\n\t\t\talloced++;\n\t\t}\n\t}\n\tvport->alloc_tqps = alloced;\n\tkinfo->rss_size = min_t(u16, hdev->pf_rss_size_max,\n\t\t\t\tvport->alloc_tqps / hdev->tm_info.num_tc);\n\n\t \n\tkinfo->rss_size = min_t(u16, kinfo->rss_size,\n\t\t\t\t(hdev->num_nic_msi - 1) / hdev->tm_info.num_tc);\n\n\treturn 0;\n}\n\nstatic int hclge_knic_setup(struct hclge_vport *vport, u16 num_tqps,\n\t\t\t    u16 num_tx_desc, u16 num_rx_desc)\n\n{\n\tstruct hnae3_handle *nic = &vport->nic;\n\tstruct hnae3_knic_private_info *kinfo = &nic->kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tkinfo->num_tx_desc = num_tx_desc;\n\tkinfo->num_rx_desc = num_rx_desc;\n\n\tkinfo->rx_buf_len = hdev->rx_buf_len;\n\tkinfo->tx_spare_buf_size = hdev->tx_spare_buf_size;\n\n\tkinfo->tqp = devm_kcalloc(&hdev->pdev->dev, num_tqps,\n\t\t\t\t  sizeof(struct hnae3_queue *), GFP_KERNEL);\n\tif (!kinfo->tqp)\n\t\treturn -ENOMEM;\n\n\tret = hclge_assign_tqp(vport, num_tqps);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"fail to assign TQPs %d.\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_map_tqp_to_vport(struct hclge_dev *hdev,\n\t\t\t\t  struct hclge_vport *vport)\n{\n\tstruct hnae3_handle *nic = &vport->nic;\n\tstruct hnae3_knic_private_info *kinfo;\n\tu16 i;\n\n\tkinfo = &nic->kinfo;\n\tfor (i = 0; i < vport->alloc_tqps; i++) {\n\t\tstruct hclge_comm_tqp *q =\n\t\t\tcontainer_of(kinfo->tqp[i], struct hclge_comm_tqp, q);\n\t\tbool is_pf;\n\t\tint ret;\n\n\t\tis_pf = !(vport->vport_id);\n\t\tret = hclge_map_tqps_to_func(hdev, vport->vport_id, q->index,\n\t\t\t\t\t     i, is_pf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_map_tqp(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport = hdev->vport;\n\tu16 i, num_vport;\n\n\tnum_vport = hdev->num_req_vfs + 1;\n\tfor (i = 0; i < num_vport; i++) {\n\t\tint ret;\n\n\t\tret = hclge_map_tqp_to_vport(hdev, vport);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvport++;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_vport_setup(struct hclge_vport *vport, u16 num_tqps)\n{\n\tstruct hnae3_handle *nic = &vport->nic;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tnic->pdev = hdev->pdev;\n\tnic->ae_algo = &ae_algo;\n\tnic->numa_node_mask = hdev->numa_node_mask;\n\tnic->kinfo.io_base = hdev->hw.hw.io_base;\n\n\tret = hclge_knic_setup(vport, num_tqps,\n\t\t\t       hdev->num_tx_desc, hdev->num_rx_desc);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"knic setup failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_alloc_vport(struct hclge_dev *hdev)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tstruct hclge_vport *vport;\n\tu32 tqp_main_vport;\n\tu32 tqp_per_vport;\n\tint num_vport, i;\n\tint ret;\n\n\t \n\tnum_vport = hdev->num_req_vfs + 1;\n\n\tif (hdev->num_tqps < num_vport) {\n\t\tdev_err(&hdev->pdev->dev, \"tqps(%u) is less than vports(%d)\",\n\t\t\thdev->num_tqps, num_vport);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttqp_per_vport = hdev->num_tqps / num_vport;\n\ttqp_main_vport = tqp_per_vport + hdev->num_tqps % num_vport;\n\n\tvport = devm_kcalloc(&pdev->dev, num_vport, sizeof(struct hclge_vport),\n\t\t\t     GFP_KERNEL);\n\tif (!vport)\n\t\treturn -ENOMEM;\n\n\thdev->vport = vport;\n\thdev->num_alloc_vport = num_vport;\n\n\tif (IS_ENABLED(CONFIG_PCI_IOV))\n\t\thdev->num_alloc_vfs = hdev->num_req_vfs;\n\n\tfor (i = 0; i < num_vport; i++) {\n\t\tvport->back = hdev;\n\t\tvport->vport_id = i;\n\t\tvport->vf_info.link_state = IFLA_VF_LINK_STATE_AUTO;\n\t\tvport->mps = HCLGE_MAC_DEFAULT_FRAME;\n\t\tvport->port_base_vlan_cfg.state = HNAE3_PORT_BASE_VLAN_DISABLE;\n\t\tvport->port_base_vlan_cfg.tbl_sta = true;\n\t\tvport->rxvlan_cfg.rx_vlan_offload_en = true;\n\t\tvport->req_vlan_fltr_en = true;\n\t\tINIT_LIST_HEAD(&vport->vlan_list);\n\t\tINIT_LIST_HEAD(&vport->uc_mac_list);\n\t\tINIT_LIST_HEAD(&vport->mc_mac_list);\n\t\tspin_lock_init(&vport->mac_list_lock);\n\n\t\tif (i == 0)\n\t\t\tret = hclge_vport_setup(vport, tqp_main_vport);\n\t\telse\n\t\t\tret = hclge_vport_setup(vport, tqp_per_vport);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"vport setup failed for vport %d, %d\\n\",\n\t\t\t\ti, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tvport++;\n\t}\n\n\treturn 0;\n}\n\nstatic int  hclge_cmd_alloc_tx_buff(struct hclge_dev *hdev,\n\t\t\t\t    struct hclge_pkt_buf_alloc *buf_alloc)\n{\n \n#define HCLGE_BUF_SIZE_UNIT_SHIFT\t7\n#define HCLGE_BUF_SIZE_UPDATE_EN_MSK\tBIT(15)\n\tstruct hclge_tx_buff_alloc_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\tu8 i;\n\n\treq = (struct hclge_tx_buff_alloc_cmd *)desc.data;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_TX_BUFF_ALLOC, 0);\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tu32 buf_size = buf_alloc->priv_buf[i].tx_buf_size;\n\n\t\treq->tx_pkt_buff[i] =\n\t\t\tcpu_to_le16((buf_size >> HCLGE_BUF_SIZE_UNIT_SHIFT) |\n\t\t\t\t     HCLGE_BUF_SIZE_UPDATE_EN_MSK);\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"tx buffer alloc cmd failed %d.\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int hclge_tx_buffer_alloc(struct hclge_dev *hdev,\n\t\t\t\t struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tint ret = hclge_cmd_alloc_tx_buff(hdev, buf_alloc);\n\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"tx buffer alloc failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic u32 hclge_get_tc_num(struct hclge_dev *hdev)\n{\n\tunsigned int i;\n\tu32 cnt = 0;\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++)\n\t\tif (hdev->hw_tc_map & BIT(i))\n\t\t\tcnt++;\n\treturn cnt;\n}\n\n \nstatic int hclge_get_pfc_priv_num(struct hclge_dev *hdev,\n\t\t\t\t  struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tstruct hclge_priv_buf *priv;\n\tunsigned int i;\n\tint cnt = 0;\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tpriv = &buf_alloc->priv_buf[i];\n\t\tif ((hdev->tm_info.hw_pfc_map & BIT(i)) &&\n\t\t    priv->enable)\n\t\t\tcnt++;\n\t}\n\n\treturn cnt;\n}\n\n \nstatic int hclge_get_no_pfc_priv_num(struct hclge_dev *hdev,\n\t\t\t\t     struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tstruct hclge_priv_buf *priv;\n\tunsigned int i;\n\tint cnt = 0;\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tpriv = &buf_alloc->priv_buf[i];\n\t\tif (hdev->hw_tc_map & BIT(i) &&\n\t\t    !(hdev->tm_info.hw_pfc_map & BIT(i)) &&\n\t\t    priv->enable)\n\t\t\tcnt++;\n\t}\n\n\treturn cnt;\n}\n\nstatic u32 hclge_get_rx_priv_buff_alloced(struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tstruct hclge_priv_buf *priv;\n\tu32 rx_priv = 0;\n\tint i;\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tpriv = &buf_alloc->priv_buf[i];\n\t\tif (priv->enable)\n\t\t\trx_priv += priv->buf_size;\n\t}\n\treturn rx_priv;\n}\n\nstatic u32 hclge_get_tx_buff_alloced(struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tu32 i, total_tx_size = 0;\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++)\n\t\ttotal_tx_size += buf_alloc->priv_buf[i].tx_buf_size;\n\n\treturn total_tx_size;\n}\n\nstatic bool  hclge_is_rx_buf_ok(struct hclge_dev *hdev,\n\t\t\t\tstruct hclge_pkt_buf_alloc *buf_alloc,\n\t\t\t\tu32 rx_all)\n{\n\tu32 shared_buf_min, shared_buf_tc, shared_std, hi_thrd, lo_thrd;\n\tu32 tc_num = hclge_get_tc_num(hdev);\n\tu32 shared_buf, aligned_mps;\n\tu32 rx_priv;\n\tint i;\n\n\taligned_mps = roundup(hdev->mps, HCLGE_BUF_SIZE_UNIT);\n\n\tif (hnae3_dev_dcb_supported(hdev))\n\t\tshared_buf_min = HCLGE_BUF_MUL_BY * aligned_mps +\n\t\t\t\t\thdev->dv_buf_size;\n\telse\n\t\tshared_buf_min = aligned_mps + HCLGE_NON_DCB_ADDITIONAL_BUF\n\t\t\t\t\t+ hdev->dv_buf_size;\n\n\tshared_buf_tc = tc_num * aligned_mps + aligned_mps;\n\tshared_std = roundup(max_t(u32, shared_buf_min, shared_buf_tc),\n\t\t\t     HCLGE_BUF_SIZE_UNIT);\n\n\trx_priv = hclge_get_rx_priv_buff_alloced(buf_alloc);\n\tif (rx_all < rx_priv + shared_std)\n\t\treturn false;\n\n\tshared_buf = rounddown(rx_all - rx_priv, HCLGE_BUF_SIZE_UNIT);\n\tbuf_alloc->s_buf.buf_size = shared_buf;\n\tif (hnae3_dev_dcb_supported(hdev)) {\n\t\tbuf_alloc->s_buf.self.high = shared_buf - hdev->dv_buf_size;\n\t\tbuf_alloc->s_buf.self.low = buf_alloc->s_buf.self.high\n\t\t\t- roundup(aligned_mps / HCLGE_BUF_DIV_BY,\n\t\t\t\t  HCLGE_BUF_SIZE_UNIT);\n\t} else {\n\t\tbuf_alloc->s_buf.self.high = aligned_mps +\n\t\t\t\t\t\tHCLGE_NON_DCB_ADDITIONAL_BUF;\n\t\tbuf_alloc->s_buf.self.low = aligned_mps;\n\t}\n\n\tif (hnae3_dev_dcb_supported(hdev)) {\n\t\thi_thrd = shared_buf - hdev->dv_buf_size;\n\n\t\tif (tc_num <= NEED_RESERVE_TC_NUM)\n\t\t\thi_thrd = hi_thrd * BUF_RESERVE_PERCENT\n\t\t\t\t\t/ BUF_MAX_PERCENT;\n\n\t\tif (tc_num)\n\t\t\thi_thrd = hi_thrd / tc_num;\n\n\t\thi_thrd = max_t(u32, hi_thrd, HCLGE_BUF_MUL_BY * aligned_mps);\n\t\thi_thrd = rounddown(hi_thrd, HCLGE_BUF_SIZE_UNIT);\n\t\tlo_thrd = hi_thrd - aligned_mps / HCLGE_BUF_DIV_BY;\n\t} else {\n\t\thi_thrd = aligned_mps + HCLGE_NON_DCB_ADDITIONAL_BUF;\n\t\tlo_thrd = aligned_mps;\n\t}\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tbuf_alloc->s_buf.tc_thrd[i].low = lo_thrd;\n\t\tbuf_alloc->s_buf.tc_thrd[i].high = hi_thrd;\n\t}\n\n\treturn true;\n}\n\nstatic int hclge_tx_buffer_calc(struct hclge_dev *hdev,\n\t\t\t\tstruct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tu32 i, total_size;\n\n\ttotal_size = hdev->pkt_buf_size;\n\n\t \n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tstruct hclge_priv_buf *priv = &buf_alloc->priv_buf[i];\n\n\t\tif (hdev->hw_tc_map & BIT(i)) {\n\t\t\tif (total_size < hdev->tx_buf_size)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpriv->tx_buf_size = hdev->tx_buf_size;\n\t\t} else {\n\t\t\tpriv->tx_buf_size = 0;\n\t\t}\n\n\t\ttotal_size -= priv->tx_buf_size;\n\t}\n\n\treturn 0;\n}\n\nstatic bool hclge_rx_buf_calc_all(struct hclge_dev *hdev, bool max,\n\t\t\t\t  struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tu32 rx_all = hdev->pkt_buf_size - hclge_get_tx_buff_alloced(buf_alloc);\n\tu32 aligned_mps = round_up(hdev->mps, HCLGE_BUF_SIZE_UNIT);\n\tunsigned int i;\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tstruct hclge_priv_buf *priv = &buf_alloc->priv_buf[i];\n\n\t\tpriv->enable = 0;\n\t\tpriv->wl.low = 0;\n\t\tpriv->wl.high = 0;\n\t\tpriv->buf_size = 0;\n\n\t\tif (!(hdev->hw_tc_map & BIT(i)))\n\t\t\tcontinue;\n\n\t\tpriv->enable = 1;\n\n\t\tif (hdev->tm_info.hw_pfc_map & BIT(i)) {\n\t\t\tpriv->wl.low = max ? aligned_mps : HCLGE_BUF_SIZE_UNIT;\n\t\t\tpriv->wl.high = roundup(priv->wl.low + aligned_mps,\n\t\t\t\t\t\tHCLGE_BUF_SIZE_UNIT);\n\t\t} else {\n\t\t\tpriv->wl.low = 0;\n\t\t\tpriv->wl.high = max ? (aligned_mps * HCLGE_BUF_MUL_BY) :\n\t\t\t\t\taligned_mps;\n\t\t}\n\n\t\tpriv->buf_size = priv->wl.high + hdev->dv_buf_size;\n\t}\n\n\treturn hclge_is_rx_buf_ok(hdev, buf_alloc, rx_all);\n}\n\nstatic bool hclge_drop_nopfc_buf_till_fit(struct hclge_dev *hdev,\n\t\t\t\t\t  struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tu32 rx_all = hdev->pkt_buf_size - hclge_get_tx_buff_alloced(buf_alloc);\n\tint no_pfc_priv_num = hclge_get_no_pfc_priv_num(hdev, buf_alloc);\n\tint i;\n\n\t \n\tfor (i = HCLGE_MAX_TC_NUM - 1; i >= 0; i--) {\n\t\tstruct hclge_priv_buf *priv = &buf_alloc->priv_buf[i];\n\t\tunsigned int mask = BIT((unsigned int)i);\n\n\t\tif (hdev->hw_tc_map & mask &&\n\t\t    !(hdev->tm_info.hw_pfc_map & mask)) {\n\t\t\t \n\t\t\tpriv->wl.low = 0;\n\t\t\tpriv->wl.high = 0;\n\t\t\tpriv->buf_size = 0;\n\t\t\tpriv->enable = 0;\n\t\t\tno_pfc_priv_num--;\n\t\t}\n\n\t\tif (hclge_is_rx_buf_ok(hdev, buf_alloc, rx_all) ||\n\t\t    no_pfc_priv_num == 0)\n\t\t\tbreak;\n\t}\n\n\treturn hclge_is_rx_buf_ok(hdev, buf_alloc, rx_all);\n}\n\nstatic bool hclge_drop_pfc_buf_till_fit(struct hclge_dev *hdev,\n\t\t\t\t\tstruct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tu32 rx_all = hdev->pkt_buf_size - hclge_get_tx_buff_alloced(buf_alloc);\n\tint pfc_priv_num = hclge_get_pfc_priv_num(hdev, buf_alloc);\n\tint i;\n\n\t \n\tfor (i = HCLGE_MAX_TC_NUM - 1; i >= 0; i--) {\n\t\tstruct hclge_priv_buf *priv = &buf_alloc->priv_buf[i];\n\t\tunsigned int mask = BIT((unsigned int)i);\n\n\t\tif (hdev->hw_tc_map & mask &&\n\t\t    hdev->tm_info.hw_pfc_map & mask) {\n\t\t\t \n\t\t\tpriv->wl.low = 0;\n\t\t\tpriv->enable = 0;\n\t\t\tpriv->wl.high = 0;\n\t\t\tpriv->buf_size = 0;\n\t\t\tpfc_priv_num--;\n\t\t}\n\n\t\tif (hclge_is_rx_buf_ok(hdev, buf_alloc, rx_all) ||\n\t\t    pfc_priv_num == 0)\n\t\t\tbreak;\n\t}\n\n\treturn hclge_is_rx_buf_ok(hdev, buf_alloc, rx_all);\n}\n\nstatic int hclge_only_alloc_priv_buff(struct hclge_dev *hdev,\n\t\t\t\t      struct hclge_pkt_buf_alloc *buf_alloc)\n{\n#define COMPENSATE_BUFFER\t0x3C00\n#define COMPENSATE_HALF_MPS_NUM\t5\n#define PRIV_WL_GAP\t\t0x1800\n\n\tu32 rx_priv = hdev->pkt_buf_size - hclge_get_tx_buff_alloced(buf_alloc);\n\tu32 tc_num = hclge_get_tc_num(hdev);\n\tu32 half_mps = hdev->mps >> 1;\n\tu32 min_rx_priv;\n\tunsigned int i;\n\n\tif (tc_num)\n\t\trx_priv = rx_priv / tc_num;\n\n\tif (tc_num <= NEED_RESERVE_TC_NUM)\n\t\trx_priv = rx_priv * BUF_RESERVE_PERCENT / BUF_MAX_PERCENT;\n\n\tmin_rx_priv = hdev->dv_buf_size + COMPENSATE_BUFFER +\n\t\t\tCOMPENSATE_HALF_MPS_NUM * half_mps;\n\tmin_rx_priv = round_up(min_rx_priv, HCLGE_BUF_SIZE_UNIT);\n\trx_priv = round_down(rx_priv, HCLGE_BUF_SIZE_UNIT);\n\tif (rx_priv < min_rx_priv)\n\t\treturn false;\n\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tstruct hclge_priv_buf *priv = &buf_alloc->priv_buf[i];\n\n\t\tpriv->enable = 0;\n\t\tpriv->wl.low = 0;\n\t\tpriv->wl.high = 0;\n\t\tpriv->buf_size = 0;\n\n\t\tif (!(hdev->hw_tc_map & BIT(i)))\n\t\t\tcontinue;\n\n\t\tpriv->enable = 1;\n\t\tpriv->buf_size = rx_priv;\n\t\tpriv->wl.high = rx_priv - hdev->dv_buf_size;\n\t\tpriv->wl.low = priv->wl.high - PRIV_WL_GAP;\n\t}\n\n\tbuf_alloc->s_buf.buf_size = 0;\n\n\treturn true;\n}\n\n \nstatic int hclge_rx_buffer_calc(struct hclge_dev *hdev,\n\t\t\t\tstruct hclge_pkt_buf_alloc *buf_alloc)\n{\n\t \n\tif (!hnae3_dev_dcb_supported(hdev)) {\n\t\tu32 rx_all = hdev->pkt_buf_size;\n\n\t\trx_all -= hclge_get_tx_buff_alloced(buf_alloc);\n\t\tif (!hclge_is_rx_buf_ok(hdev, buf_alloc, rx_all))\n\t\t\treturn -ENOMEM;\n\n\t\treturn 0;\n\t}\n\n\tif (hclge_only_alloc_priv_buff(hdev, buf_alloc))\n\t\treturn 0;\n\n\tif (hclge_rx_buf_calc_all(hdev, true, buf_alloc))\n\t\treturn 0;\n\n\t \n\tif (hclge_rx_buf_calc_all(hdev, false, buf_alloc))\n\t\treturn 0;\n\n\tif (hclge_drop_nopfc_buf_till_fit(hdev, buf_alloc))\n\t\treturn 0;\n\n\tif (hclge_drop_pfc_buf_till_fit(hdev, buf_alloc))\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}\n\nstatic int hclge_rx_priv_buf_alloc(struct hclge_dev *hdev,\n\t\t\t\t   struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tstruct hclge_rx_priv_buff_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\tint i;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_RX_PRIV_BUFF_ALLOC, false);\n\treq = (struct hclge_rx_priv_buff_cmd *)desc.data;\n\n\t \n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\tstruct hclge_priv_buf *priv = &buf_alloc->priv_buf[i];\n\n\t\treq->buf_num[i] =\n\t\t\tcpu_to_le16(priv->buf_size >> HCLGE_BUF_UNIT_S);\n\t\treq->buf_num[i] |=\n\t\t\tcpu_to_le16(1 << HCLGE_TC0_PRI_BUF_EN_B);\n\t}\n\n\treq->shared_buf =\n\t\tcpu_to_le16((buf_alloc->s_buf.buf_size >> HCLGE_BUF_UNIT_S) |\n\t\t\t    (1 << HCLGE_TC0_PRI_BUF_EN_B));\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"rx private buffer alloc cmd failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_rx_priv_wl_config(struct hclge_dev *hdev,\n\t\t\t\t   struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tstruct hclge_rx_priv_wl_buf *req;\n\tstruct hclge_priv_buf *priv;\n\tstruct hclge_desc desc[2];\n\tint i, j;\n\tint ret;\n\n\tfor (i = 0; i < 2; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_RX_PRIV_WL_ALLOC,\n\t\t\t\t\t   false);\n\t\treq = (struct hclge_rx_priv_wl_buf *)desc[i].data;\n\n\t\t \n\t\tif (i == 0)\n\t\t\tdesc[i].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\telse\n\t\t\tdesc[i].flag &= ~cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\n\t\tfor (j = 0; j < HCLGE_TC_NUM_ONE_DESC; j++) {\n\t\t\tu32 idx = i * HCLGE_TC_NUM_ONE_DESC + j;\n\n\t\t\tpriv = &buf_alloc->priv_buf[idx];\n\t\t\treq->tc_wl[j].high =\n\t\t\t\tcpu_to_le16(priv->wl.high >> HCLGE_BUF_UNIT_S);\n\t\t\treq->tc_wl[j].high |=\n\t\t\t\tcpu_to_le16(BIT(HCLGE_RX_PRIV_EN_B));\n\t\t\treq->tc_wl[j].low =\n\t\t\t\tcpu_to_le16(priv->wl.low >> HCLGE_BUF_UNIT_S);\n\t\t\treq->tc_wl[j].low |=\n\t\t\t\t cpu_to_le16(BIT(HCLGE_RX_PRIV_EN_B));\n\t\t}\n\t}\n\n\t \n\tret = hclge_cmd_send(&hdev->hw, desc, 2);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"rx private waterline config cmd failed %d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_common_thrd_config(struct hclge_dev *hdev,\n\t\t\t\t    struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tstruct hclge_shared_buf *s_buf = &buf_alloc->s_buf;\n\tstruct hclge_rx_com_thrd *req;\n\tstruct hclge_desc desc[2];\n\tstruct hclge_tc_thrd *tc;\n\tint i, j;\n\tint ret;\n\n\tfor (i = 0; i < 2; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc[i],\n\t\t\t\t\t   HCLGE_OPC_RX_COM_THRD_ALLOC, false);\n\t\treq = (struct hclge_rx_com_thrd *)&desc[i].data;\n\n\t\t \n\t\tif (i == 0)\n\t\t\tdesc[i].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\telse\n\t\t\tdesc[i].flag &= ~cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\n\t\tfor (j = 0; j < HCLGE_TC_NUM_ONE_DESC; j++) {\n\t\t\ttc = &s_buf->tc_thrd[i * HCLGE_TC_NUM_ONE_DESC + j];\n\n\t\t\treq->com_thrd[j].high =\n\t\t\t\tcpu_to_le16(tc->high >> HCLGE_BUF_UNIT_S);\n\t\t\treq->com_thrd[j].high |=\n\t\t\t\t cpu_to_le16(BIT(HCLGE_RX_PRIV_EN_B));\n\t\t\treq->com_thrd[j].low =\n\t\t\t\tcpu_to_le16(tc->low >> HCLGE_BUF_UNIT_S);\n\t\t\treq->com_thrd[j].low |=\n\t\t\t\t cpu_to_le16(BIT(HCLGE_RX_PRIV_EN_B));\n\t\t}\n\t}\n\n\t \n\tret = hclge_cmd_send(&hdev->hw, desc, 2);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"common threshold config cmd failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int hclge_common_wl_config(struct hclge_dev *hdev,\n\t\t\t\t  struct hclge_pkt_buf_alloc *buf_alloc)\n{\n\tstruct hclge_shared_buf *buf = &buf_alloc->s_buf;\n\tstruct hclge_rx_com_wl *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_RX_COM_WL_ALLOC, false);\n\n\treq = (struct hclge_rx_com_wl *)desc.data;\n\treq->com_wl.high = cpu_to_le16(buf->self.high >> HCLGE_BUF_UNIT_S);\n\treq->com_wl.high |=  cpu_to_le16(BIT(HCLGE_RX_PRIV_EN_B));\n\n\treq->com_wl.low = cpu_to_le16(buf->self.low >> HCLGE_BUF_UNIT_S);\n\treq->com_wl.low |=  cpu_to_le16(BIT(HCLGE_RX_PRIV_EN_B));\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"common waterline config cmd failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nint hclge_buffer_alloc(struct hclge_dev *hdev)\n{\n\tstruct hclge_pkt_buf_alloc *pkt_buf;\n\tint ret;\n\n\tpkt_buf = kzalloc(sizeof(*pkt_buf), GFP_KERNEL);\n\tif (!pkt_buf)\n\t\treturn -ENOMEM;\n\n\tret = hclge_tx_buffer_calc(hdev, pkt_buf);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"could not calc tx buffer size for all TCs %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = hclge_tx_buffer_alloc(hdev, pkt_buf);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"could not alloc tx buffers %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = hclge_rx_buffer_calc(hdev, pkt_buf);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"could not calc rx priv buffer size for all TCs %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = hclge_rx_priv_buf_alloc(hdev, pkt_buf);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"could not alloc rx priv buffer %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tif (hnae3_dev_dcb_supported(hdev)) {\n\t\tret = hclge_rx_priv_wl_config(hdev, pkt_buf);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"could not configure rx private waterline %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = hclge_common_thrd_config(hdev, pkt_buf);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"could not configure common threshold %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = hclge_common_wl_config(hdev, pkt_buf);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"could not configure common waterline %d\\n\", ret);\n\nout:\n\tkfree(pkt_buf);\n\treturn ret;\n}\n\nstatic int hclge_init_roce_base_info(struct hclge_vport *vport)\n{\n\tstruct hnae3_handle *roce = &vport->roce;\n\tstruct hnae3_handle *nic = &vport->nic;\n\tstruct hclge_dev *hdev = vport->back;\n\n\troce->rinfo.num_vectors = vport->back->num_roce_msi;\n\n\tif (hdev->num_msi < hdev->num_nic_msi + hdev->num_roce_msi)\n\t\treturn -EINVAL;\n\n\troce->rinfo.base_vector = hdev->num_nic_msi;\n\n\troce->rinfo.netdev = nic->kinfo.netdev;\n\troce->rinfo.roce_io_base = hdev->hw.hw.io_base;\n\troce->rinfo.roce_mem_base = hdev->hw.hw.mem_base;\n\n\troce->pdev = nic->pdev;\n\troce->ae_algo = nic->ae_algo;\n\troce->numa_node_mask = nic->numa_node_mask;\n\n\treturn 0;\n}\n\nstatic int hclge_init_msi(struct hclge_dev *hdev)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tint vectors;\n\tint i;\n\n\tvectors = pci_alloc_irq_vectors(pdev, HNAE3_MIN_VECTOR_NUM,\n\t\t\t\t\thdev->num_msi,\n\t\t\t\t\tPCI_IRQ_MSI | PCI_IRQ_MSIX);\n\tif (vectors < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed(%d) to allocate MSI/MSI-X vectors\\n\",\n\t\t\tvectors);\n\t\treturn vectors;\n\t}\n\tif (vectors < hdev->num_msi)\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"requested %u MSI/MSI-X, but allocated %d MSI/MSI-X\\n\",\n\t\t\t hdev->num_msi, vectors);\n\n\thdev->num_msi = vectors;\n\thdev->num_msi_left = vectors;\n\n\thdev->vector_status = devm_kcalloc(&pdev->dev, hdev->num_msi,\n\t\t\t\t\t   sizeof(u16), GFP_KERNEL);\n\tif (!hdev->vector_status) {\n\t\tpci_free_irq_vectors(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < hdev->num_msi; i++)\n\t\thdev->vector_status[i] = HCLGE_INVALID_VPORT;\n\n\thdev->vector_irq = devm_kcalloc(&pdev->dev, hdev->num_msi,\n\t\t\t\t\tsizeof(int), GFP_KERNEL);\n\tif (!hdev->vector_irq) {\n\t\tpci_free_irq_vectors(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 hclge_check_speed_dup(u8 duplex, int speed)\n{\n\tif (!(speed == HCLGE_MAC_SPEED_10M || speed == HCLGE_MAC_SPEED_100M))\n\t\tduplex = HCLGE_MAC_FULL;\n\n\treturn duplex;\n}\n\nstatic struct hclge_mac_speed_map hclge_mac_speed_map_to_fw[] = {\n\t{HCLGE_MAC_SPEED_10M, HCLGE_FW_MAC_SPEED_10M},\n\t{HCLGE_MAC_SPEED_100M, HCLGE_FW_MAC_SPEED_100M},\n\t{HCLGE_MAC_SPEED_1G, HCLGE_FW_MAC_SPEED_1G},\n\t{HCLGE_MAC_SPEED_10G, HCLGE_FW_MAC_SPEED_10G},\n\t{HCLGE_MAC_SPEED_25G, HCLGE_FW_MAC_SPEED_25G},\n\t{HCLGE_MAC_SPEED_40G, HCLGE_FW_MAC_SPEED_40G},\n\t{HCLGE_MAC_SPEED_50G, HCLGE_FW_MAC_SPEED_50G},\n\t{HCLGE_MAC_SPEED_100G, HCLGE_FW_MAC_SPEED_100G},\n\t{HCLGE_MAC_SPEED_200G, HCLGE_FW_MAC_SPEED_200G},\n};\n\nstatic int hclge_convert_to_fw_speed(u32 speed_drv, u32 *speed_fw)\n{\n\tu16 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hclge_mac_speed_map_to_fw); i++) {\n\t\tif (hclge_mac_speed_map_to_fw[i].speed_drv == speed_drv) {\n\t\t\t*speed_fw = hclge_mac_speed_map_to_fw[i].speed_fw;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hclge_cfg_mac_speed_dup_hw(struct hclge_dev *hdev, int speed,\n\t\t\t\t      u8 duplex, u8 lane_num)\n{\n\tstruct hclge_config_mac_speed_dup_cmd *req;\n\tstruct hclge_desc desc;\n\tu32 speed_fw;\n\tint ret;\n\n\treq = (struct hclge_config_mac_speed_dup_cmd *)desc.data;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_SPEED_DUP, false);\n\n\tif (duplex)\n\t\thnae3_set_bit(req->speed_dup, HCLGE_CFG_DUPLEX_B, 1);\n\n\tret = hclge_convert_to_fw_speed(speed, &speed_fw);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"invalid speed (%d)\\n\", speed);\n\t\treturn ret;\n\t}\n\n\thnae3_set_field(req->speed_dup, HCLGE_CFG_SPEED_M, HCLGE_CFG_SPEED_S,\n\t\t\tspeed_fw);\n\thnae3_set_bit(req->mac_change_fec_en, HCLGE_CFG_MAC_SPEED_CHANGE_EN_B,\n\t\t      1);\n\treq->lane_num = lane_num;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mac speed/duplex config cmd failed %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint hclge_cfg_mac_speed_dup(struct hclge_dev *hdev, int speed, u8 duplex, u8 lane_num)\n{\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\tint ret;\n\n\tduplex = hclge_check_speed_dup(duplex, speed);\n\tif (!mac->support_autoneg && mac->speed == speed &&\n\t    mac->duplex == duplex && (mac->lane_num == lane_num || lane_num == 0))\n\t\treturn 0;\n\n\tret = hclge_cfg_mac_speed_dup_hw(hdev, speed, duplex, lane_num);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->hw.mac.speed = speed;\n\thdev->hw.mac.duplex = duplex;\n\tif (!lane_num)\n\t\thdev->hw.mac.lane_num = lane_num;\n\n\treturn 0;\n}\n\nstatic int hclge_cfg_mac_speed_dup_h(struct hnae3_handle *handle, int speed,\n\t\t\t\t     u8 duplex, u8 lane_num)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn hclge_cfg_mac_speed_dup(hdev, speed, duplex, lane_num);\n}\n\nstatic int hclge_set_autoneg_en(struct hclge_dev *hdev, bool enable)\n{\n\tstruct hclge_config_auto_neg_cmd *req;\n\tstruct hclge_desc desc;\n\tu32 flag = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_AN_MODE, false);\n\n\treq = (struct hclge_config_auto_neg_cmd *)desc.data;\n\tif (enable)\n\t\thnae3_set_bit(flag, HCLGE_MAC_CFG_AN_EN_B, 1U);\n\treq->cfg_an_cmd_flag = cpu_to_le32(flag);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"auto neg set cmd failed %d.\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int hclge_set_autoneg(struct hnae3_handle *handle, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (!hdev->hw.mac.support_autoneg) {\n\t\tif (enable) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"autoneg is not supported by current port\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn hclge_set_autoneg_en(hdev, enable);\n}\n\nstatic int hclge_get_autoneg(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\n\tif (phydev)\n\t\treturn phydev->autoneg;\n\n\treturn hdev->hw.mac.autoneg;\n}\n\nstatic int hclge_restart_autoneg(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tdev_dbg(&hdev->pdev->dev, \"restart autoneg\\n\");\n\n\tret = hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\treturn hclge_notify_client(hdev, HNAE3_UP_CLIENT);\n}\n\nstatic int hclge_halt_autoneg(struct hnae3_handle *handle, bool halt)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (hdev->hw.mac.support_autoneg && hdev->hw.mac.autoneg)\n\t\treturn hclge_set_autoneg_en(hdev, !halt);\n\n\treturn 0;\n}\n\nstatic void hclge_parse_fec_stats_lanes(struct hclge_dev *hdev,\n\t\t\t\t\tstruct hclge_desc *desc, u32 desc_len)\n{\n\tu32 lane_size = HCLGE_FEC_STATS_MAX_LANES * 2;\n\tu32 desc_index = 0;\n\tu32 data_index = 0;\n\tu32 i;\n\n\tfor (i = 0; i < lane_size; i++) {\n\t\tif (data_index >= HCLGE_DESC_DATA_LEN) {\n\t\t\tdesc_index++;\n\t\t\tdata_index = 0;\n\t\t}\n\n\t\tif (desc_index >= desc_len)\n\t\t\treturn;\n\n\t\thdev->fec_stats.per_lanes[i] +=\n\t\t\tle32_to_cpu(desc[desc_index].data[data_index]);\n\t\tdata_index++;\n\t}\n}\n\nstatic void hclge_parse_fec_stats(struct hclge_dev *hdev,\n\t\t\t\t  struct hclge_desc *desc, u32 desc_len)\n{\n\tstruct hclge_query_fec_stats_cmd *req;\n\n\treq = (struct hclge_query_fec_stats_cmd *)desc[0].data;\n\n\thdev->fec_stats.base_r_lane_num = req->base_r_lane_num;\n\thdev->fec_stats.rs_corr_blocks +=\n\t\tle32_to_cpu(req->rs_fec_corr_blocks);\n\thdev->fec_stats.rs_uncorr_blocks +=\n\t\tle32_to_cpu(req->rs_fec_uncorr_blocks);\n\thdev->fec_stats.rs_error_blocks +=\n\t\tle32_to_cpu(req->rs_fec_error_blocks);\n\thdev->fec_stats.base_r_corr_blocks +=\n\t\tle32_to_cpu(req->base_r_fec_corr_blocks);\n\thdev->fec_stats.base_r_uncorr_blocks +=\n\t\tle32_to_cpu(req->base_r_fec_uncorr_blocks);\n\n\thclge_parse_fec_stats_lanes(hdev, &desc[1], desc_len - 1);\n}\n\nstatic int hclge_update_fec_stats_hw(struct hclge_dev *hdev)\n{\n\tstruct hclge_desc desc[HCLGE_FEC_STATS_CMD_NUM];\n\tint ret;\n\tu32 i;\n\n\tfor (i = 0; i < HCLGE_FEC_STATS_CMD_NUM; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_QUERY_FEC_STATS,\n\t\t\t\t\t   true);\n\t\tif (i != (HCLGE_FEC_STATS_CMD_NUM - 1))\n\t\t\tdesc[i].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, desc, HCLGE_FEC_STATS_CMD_NUM);\n\tif (ret)\n\t\treturn ret;\n\n\thclge_parse_fec_stats(hdev, desc, HCLGE_FEC_STATS_CMD_NUM);\n\n\treturn 0;\n}\n\nstatic void hclge_update_fec_stats(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tint ret;\n\n\tif (!hnae3_ae_dev_fec_stats_supported(ae_dev) ||\n\t    test_and_set_bit(HCLGE_STATE_FEC_STATS_UPDATING, &hdev->state))\n\t\treturn;\n\n\tret = hclge_update_fec_stats_hw(hdev);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to update fec stats, ret = %d\\n\", ret);\n\n\tclear_bit(HCLGE_STATE_FEC_STATS_UPDATING, &hdev->state);\n}\n\nstatic void hclge_get_fec_stats_total(struct hclge_dev *hdev,\n\t\t\t\t      struct ethtool_fec_stats *fec_stats)\n{\n\tfec_stats->corrected_blocks.total = hdev->fec_stats.rs_corr_blocks;\n\tfec_stats->uncorrectable_blocks.total =\n\t\thdev->fec_stats.rs_uncorr_blocks;\n}\n\nstatic void hclge_get_fec_stats_lanes(struct hclge_dev *hdev,\n\t\t\t\t      struct ethtool_fec_stats *fec_stats)\n{\n\tu32 i;\n\n\tif (hdev->fec_stats.base_r_lane_num == 0 ||\n\t    hdev->fec_stats.base_r_lane_num > HCLGE_FEC_STATS_MAX_LANES) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"fec stats lane number(%llu) is invalid\\n\",\n\t\t\thdev->fec_stats.base_r_lane_num);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < hdev->fec_stats.base_r_lane_num; i++) {\n\t\tfec_stats->corrected_blocks.lanes[i] =\n\t\t\thdev->fec_stats.base_r_corr_per_lanes[i];\n\t\tfec_stats->uncorrectable_blocks.lanes[i] =\n\t\t\thdev->fec_stats.base_r_uncorr_per_lanes[i];\n\t}\n}\n\nstatic void hclge_comm_get_fec_stats(struct hclge_dev *hdev,\n\t\t\t\t     struct ethtool_fec_stats *fec_stats)\n{\n\tu32 fec_mode = hdev->hw.mac.fec_mode;\n\n\tswitch (fec_mode) {\n\tcase BIT(HNAE3_FEC_RS):\n\tcase BIT(HNAE3_FEC_LLRS):\n\t\thclge_get_fec_stats_total(hdev, fec_stats);\n\t\tbreak;\n\tcase BIT(HNAE3_FEC_BASER):\n\t\thclge_get_fec_stats_lanes(hdev, fec_stats);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"fec stats is not supported by current fec mode(0x%x)\\n\",\n\t\t\tfec_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void hclge_get_fec_stats(struct hnae3_handle *handle,\n\t\t\t\tstruct ethtool_fec_stats *fec_stats)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 fec_mode = hdev->hw.mac.fec_mode;\n\n\tif (fec_mode == BIT(HNAE3_FEC_NONE) ||\n\t    fec_mode == BIT(HNAE3_FEC_AUTO) ||\n\t    fec_mode == BIT(HNAE3_FEC_USER_DEF))\n\t\treturn;\n\n\thclge_update_fec_stats(hdev);\n\n\thclge_comm_get_fec_stats(hdev, fec_stats);\n}\n\nstatic int hclge_set_fec_hw(struct hclge_dev *hdev, u32 fec_mode)\n{\n\tstruct hclge_config_fec_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_FEC_MODE, false);\n\n\treq = (struct hclge_config_fec_cmd *)desc.data;\n\tif (fec_mode & BIT(HNAE3_FEC_AUTO))\n\t\thnae3_set_bit(req->fec_mode, HCLGE_MAC_CFG_FEC_AUTO_EN_B, 1);\n\tif (fec_mode & BIT(HNAE3_FEC_RS))\n\t\thnae3_set_field(req->fec_mode, HCLGE_MAC_CFG_FEC_MODE_M,\n\t\t\t\tHCLGE_MAC_CFG_FEC_MODE_S, HCLGE_MAC_FEC_RS);\n\tif (fec_mode & BIT(HNAE3_FEC_LLRS))\n\t\thnae3_set_field(req->fec_mode, HCLGE_MAC_CFG_FEC_MODE_M,\n\t\t\t\tHCLGE_MAC_CFG_FEC_MODE_S, HCLGE_MAC_FEC_LLRS);\n\tif (fec_mode & BIT(HNAE3_FEC_BASER))\n\t\thnae3_set_field(req->fec_mode, HCLGE_MAC_CFG_FEC_MODE_M,\n\t\t\t\tHCLGE_MAC_CFG_FEC_MODE_S, HCLGE_MAC_FEC_BASER);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"set fec mode failed %d.\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_set_fec(struct hnae3_handle *handle, u32 fec_mode)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\tint ret;\n\n\tif (fec_mode && !(mac->fec_ability & fec_mode)) {\n\t\tdev_err(&hdev->pdev->dev, \"unsupported fec mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = hclge_set_fec_hw(hdev, fec_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tmac->user_fec_mode = fec_mode | BIT(HNAE3_FEC_USER_DEF);\n\treturn 0;\n}\n\nstatic void hclge_get_fec(struct hnae3_handle *handle, u8 *fec_ability,\n\t\t\t  u8 *fec_mode)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\n\tif (fec_ability)\n\t\t*fec_ability = mac->fec_ability;\n\tif (fec_mode)\n\t\t*fec_mode = mac->fec_mode;\n}\n\nstatic int hclge_mac_init(struct hclge_dev *hdev)\n{\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\tint ret;\n\n\thdev->support_sfp_query = true;\n\thdev->hw.mac.duplex = HCLGE_MAC_FULL;\n\tret = hclge_cfg_mac_speed_dup_hw(hdev, hdev->hw.mac.speed,\n\t\t\t\t\t hdev->hw.mac.duplex, hdev->hw.mac.lane_num);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hdev->hw.mac.support_autoneg) {\n\t\tret = hclge_set_autoneg_en(hdev, hdev->hw.mac.autoneg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmac->link = 0;\n\n\tif (mac->user_fec_mode & BIT(HNAE3_FEC_USER_DEF)) {\n\t\tret = hclge_set_fec_hw(hdev, mac->user_fec_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hclge_set_mac_mtu(hdev, hdev->mps);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"set mtu failed ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_set_default_loopback(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_buffer_alloc(hdev);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"allocate buffer fail, ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void hclge_mbx_task_schedule(struct hclge_dev *hdev)\n{\n\tif (!test_bit(HCLGE_STATE_REMOVING, &hdev->state) &&\n\t    !test_and_set_bit(HCLGE_STATE_MBX_SERVICE_SCHED, &hdev->state)) {\n\t\thdev->last_mbx_scheduled = jiffies;\n\t\tmod_delayed_work(hclge_wq, &hdev->service_task, 0);\n\t}\n}\n\nstatic void hclge_reset_task_schedule(struct hclge_dev *hdev)\n{\n\tif (!test_bit(HCLGE_STATE_REMOVING, &hdev->state) &&\n\t    test_bit(HCLGE_STATE_SERVICE_INITED, &hdev->state) &&\n\t    !test_and_set_bit(HCLGE_STATE_RST_SERVICE_SCHED, &hdev->state)) {\n\t\thdev->last_rst_scheduled = jiffies;\n\t\tmod_delayed_work(hclge_wq, &hdev->service_task, 0);\n\t}\n}\n\nstatic void hclge_errhand_task_schedule(struct hclge_dev *hdev)\n{\n\tif (!test_bit(HCLGE_STATE_REMOVING, &hdev->state) &&\n\t    !test_and_set_bit(HCLGE_STATE_ERR_SERVICE_SCHED, &hdev->state))\n\t\tmod_delayed_work(hclge_wq, &hdev->service_task, 0);\n}\n\nvoid hclge_task_schedule(struct hclge_dev *hdev, unsigned long delay_time)\n{\n\tif (!test_bit(HCLGE_STATE_REMOVING, &hdev->state) &&\n\t    !test_bit(HCLGE_STATE_RST_FAIL, &hdev->state))\n\t\tmod_delayed_work(hclge_wq, &hdev->service_task, delay_time);\n}\n\nstatic int hclge_get_mac_link_status(struct hclge_dev *hdev, int *link_status)\n{\n\tstruct hclge_link_status_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_LINK_STATUS, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"get link status cmd failed %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treq = (struct hclge_link_status_cmd *)desc.data;\n\t*link_status = (req->status & HCLGE_LINK_STATUS_UP_M) > 0 ?\n\t\tHCLGE_LINK_STATUS_UP : HCLGE_LINK_STATUS_DOWN;\n\n\treturn 0;\n}\n\nstatic int hclge_get_mac_phy_link(struct hclge_dev *hdev, int *link_status)\n{\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\n\t*link_status = HCLGE_LINK_STATUS_DOWN;\n\n\tif (test_bit(HCLGE_STATE_DOWN, &hdev->state))\n\t\treturn 0;\n\n\tif (phydev && (phydev->state != PHY_RUNNING || !phydev->link))\n\t\treturn 0;\n\n\treturn hclge_get_mac_link_status(hdev, link_status);\n}\n\nstatic void hclge_push_link_status(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport;\n\tint ret;\n\tu16 i;\n\n\tfor (i = 0; i < pci_num_vf(hdev->pdev); i++) {\n\t\tvport = &hdev->vport[i + HCLGE_VF_VPORT_START_NUM];\n\n\t\tif (!test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state) ||\n\t\t    vport->vf_info.link_state != IFLA_VF_LINK_STATE_AUTO)\n\t\t\tcontinue;\n\n\t\tret = hclge_push_vf_link_status(vport);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to push link status to vf%u, ret = %d\\n\",\n\t\t\t\ti, ret);\n\t\t}\n\t}\n}\n\nstatic void hclge_update_link_status(struct hclge_dev *hdev)\n{\n\tstruct hnae3_handle *rhandle = &hdev->vport[0].roce;\n\tstruct hnae3_handle *handle = &hdev->vport[0].nic;\n\tstruct hnae3_client *rclient = hdev->roce_client;\n\tstruct hnae3_client *client = hdev->nic_client;\n\tint state;\n\tint ret;\n\n\tif (!client)\n\t\treturn;\n\n\tif (test_and_set_bit(HCLGE_STATE_LINK_UPDATING, &hdev->state))\n\t\treturn;\n\n\tret = hclge_get_mac_phy_link(hdev, &state);\n\tif (ret) {\n\t\tclear_bit(HCLGE_STATE_LINK_UPDATING, &hdev->state);\n\t\treturn;\n\t}\n\n\tif (state != hdev->hw.mac.link) {\n\t\thdev->hw.mac.link = state;\n\t\tif (state == HCLGE_LINK_STATUS_UP)\n\t\t\thclge_update_port_info(hdev);\n\n\t\tclient->ops->link_status_change(handle, state);\n\t\thclge_config_mac_tnl_int(hdev, state);\n\t\tif (rclient && rclient->ops->link_status_change)\n\t\t\trclient->ops->link_status_change(rhandle, state);\n\n\t\thclge_push_link_status(hdev);\n\t}\n\n\tclear_bit(HCLGE_STATE_LINK_UPDATING, &hdev->state);\n}\n\nstatic void hclge_update_speed_advertising(struct hclge_mac *mac)\n{\n\tu32 speed_ability;\n\n\tif (hclge_get_speed_bit(mac->speed, &speed_ability))\n\t\treturn;\n\n\tswitch (mac->module_type) {\n\tcase HNAE3_MODULE_TYPE_FIBRE_LR:\n\t\thclge_convert_setting_lr(speed_ability, mac->advertising);\n\t\tbreak;\n\tcase HNAE3_MODULE_TYPE_FIBRE_SR:\n\tcase HNAE3_MODULE_TYPE_AOC:\n\t\thclge_convert_setting_sr(speed_ability, mac->advertising);\n\t\tbreak;\n\tcase HNAE3_MODULE_TYPE_CR:\n\t\thclge_convert_setting_cr(speed_ability, mac->advertising);\n\t\tbreak;\n\tcase HNAE3_MODULE_TYPE_KR:\n\t\thclge_convert_setting_kr(speed_ability, mac->advertising);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void hclge_update_fec_advertising(struct hclge_mac *mac)\n{\n\tif (mac->fec_mode & BIT(HNAE3_FEC_RS))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t\t\t\t mac->advertising);\n\telse if (mac->fec_mode & BIT(HNAE3_FEC_LLRS))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_LLRS_BIT,\n\t\t\t\t mac->advertising);\n\telse if (mac->fec_mode & BIT(HNAE3_FEC_BASER))\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT,\n\t\t\t\t mac->advertising);\n\telse\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT,\n\t\t\t\t mac->advertising);\n}\n\nstatic void hclge_update_pause_advertising(struct hclge_dev *hdev)\n{\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\tbool rx_en, tx_en;\n\n\tswitch (hdev->fc_mode_last_time) {\n\tcase HCLGE_FC_RX_PAUSE:\n\t\trx_en = true;\n\t\ttx_en = false;\n\t\tbreak;\n\tcase HCLGE_FC_TX_PAUSE:\n\t\trx_en = false;\n\t\ttx_en = true;\n\t\tbreak;\n\tcase HCLGE_FC_FULL:\n\t\trx_en = true;\n\t\ttx_en = true;\n\t\tbreak;\n\tdefault:\n\t\trx_en = false;\n\t\ttx_en = false;\n\t\tbreak;\n\t}\n\n\tlinkmode_set_pause(mac->advertising, tx_en, rx_en);\n}\n\nstatic void hclge_update_advertising(struct hclge_dev *hdev)\n{\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\n\tlinkmode_zero(mac->advertising);\n\thclge_update_speed_advertising(mac);\n\thclge_update_fec_advertising(mac);\n\thclge_update_pause_advertising(hdev);\n}\n\nstatic void hclge_update_port_capability(struct hclge_dev *hdev,\n\t\t\t\t\t struct hclge_mac *mac)\n{\n\tif (hnae3_dev_fec_supported(hdev))\n\t\thclge_convert_setting_fec(mac);\n\n\t \n\tif (mac->media_type == HNAE3_MEDIA_TYPE_BACKPLANE &&\n\t    mac->module_type == HNAE3_MODULE_TYPE_UNKNOWN)\n\t\tmac->module_type = HNAE3_MODULE_TYPE_KR;\n\telse if (mac->media_type == HNAE3_MEDIA_TYPE_COPPER)\n\t\tmac->module_type = HNAE3_MODULE_TYPE_TP;\n\n\tif (mac->support_autoneg) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, mac->supported);\n\t\tlinkmode_copy(mac->advertising, mac->supported);\n\t} else {\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t   mac->supported);\n\t\thclge_update_advertising(hdev);\n\t}\n}\n\nstatic int hclge_get_sfp_speed(struct hclge_dev *hdev, u32 *speed)\n{\n\tstruct hclge_sfp_info_cmd *resp;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_GET_SFP_INFO, true);\n\tresp = (struct hclge_sfp_info_cmd *)desc.data;\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret == -EOPNOTSUPP) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"IMP do not support get SFP speed %d\\n\", ret);\n\t\treturn ret;\n\t} else if (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"get sfp speed failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*speed = le32_to_cpu(resp->speed);\n\n\treturn 0;\n}\n\nstatic int hclge_get_sfp_info(struct hclge_dev *hdev, struct hclge_mac *mac)\n{\n\tstruct hclge_sfp_info_cmd *resp;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_GET_SFP_INFO, true);\n\tresp = (struct hclge_sfp_info_cmd *)desc.data;\n\n\tresp->query_type = QUERY_ACTIVE_SPEED;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret == -EOPNOTSUPP) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"IMP does not support get SFP info %d\\n\", ret);\n\t\treturn ret;\n\t} else if (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"get sfp info failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!le32_to_cpu(resp->speed))\n\t\treturn 0;\n\n\tmac->speed = le32_to_cpu(resp->speed);\n\t \n\tif (resp->speed_ability) {\n\t\tmac->module_type = le32_to_cpu(resp->module_type);\n\t\tmac->speed_ability = le32_to_cpu(resp->speed_ability);\n\t\tmac->autoneg = resp->autoneg;\n\t\tmac->support_autoneg = resp->autoneg_ability;\n\t\tmac->speed_type = QUERY_ACTIVE_SPEED;\n\t\tmac->lane_num = resp->lane_num;\n\t\tif (!resp->active_fec)\n\t\t\tmac->fec_mode = 0;\n\t\telse\n\t\t\tmac->fec_mode = BIT(resp->active_fec);\n\t\tmac->fec_ability = resp->fec_ability;\n\t} else {\n\t\tmac->speed_type = QUERY_SFP_SPEED;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_get_phy_link_ksettings(struct hnae3_handle *handle,\n\t\t\t\t\tstruct ethtool_link_ksettings *cmd)\n{\n\tstruct hclge_desc desc[HCLGE_PHY_LINK_SETTING_BD_NUM];\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_phy_link_ksetting_0_cmd *req0;\n\tstruct hclge_phy_link_ksetting_1_cmd *req1;\n\tu32 supported, advertising, lp_advertising;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_PHY_LINK_KSETTING,\n\t\t\t\t   true);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_OPC_PHY_LINK_KSETTING,\n\t\t\t\t   true);\n\n\tret = hclge_cmd_send(&hdev->hw, desc, HCLGE_PHY_LINK_SETTING_BD_NUM);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get phy link ksetting, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treq0 = (struct hclge_phy_link_ksetting_0_cmd *)desc[0].data;\n\tcmd->base.autoneg = req0->autoneg;\n\tcmd->base.speed = le32_to_cpu(req0->speed);\n\tcmd->base.duplex = req0->duplex;\n\tcmd->base.port = req0->port;\n\tcmd->base.transceiver = req0->transceiver;\n\tcmd->base.phy_address = req0->phy_address;\n\tcmd->base.eth_tp_mdix = req0->eth_tp_mdix;\n\tcmd->base.eth_tp_mdix_ctrl = req0->eth_tp_mdix_ctrl;\n\tsupported = le32_to_cpu(req0->supported);\n\tadvertising = le32_to_cpu(req0->advertising);\n\tlp_advertising = le32_to_cpu(req0->lp_advertising);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,\n\t\t\t\t\t\tlp_advertising);\n\n\treq1 = (struct hclge_phy_link_ksetting_1_cmd *)desc[1].data;\n\tcmd->base.master_slave_cfg = req1->master_slave_cfg;\n\tcmd->base.master_slave_state = req1->master_slave_state;\n\n\treturn 0;\n}\n\nstatic int\nhclge_set_phy_link_ksettings(struct hnae3_handle *handle,\n\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct hclge_desc desc[HCLGE_PHY_LINK_SETTING_BD_NUM];\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_phy_link_ksetting_0_cmd *req0;\n\tstruct hclge_phy_link_ksetting_1_cmd *req1;\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 advertising;\n\tint ret;\n\n\tif (cmd->base.autoneg == AUTONEG_DISABLE &&\n\t    ((cmd->base.speed != SPEED_100 && cmd->base.speed != SPEED_10) ||\n\t     (cmd->base.duplex != DUPLEX_HALF &&\n\t      cmd->base.duplex != DUPLEX_FULL)))\n\t\treturn -EINVAL;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_PHY_LINK_KSETTING,\n\t\t\t\t   false);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_OPC_PHY_LINK_KSETTING,\n\t\t\t\t   false);\n\n\treq0 = (struct hclge_phy_link_ksetting_0_cmd *)desc[0].data;\n\treq0->autoneg = cmd->base.autoneg;\n\treq0->speed = cpu_to_le32(cmd->base.speed);\n\treq0->duplex = cmd->base.duplex;\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\treq0->advertising = cpu_to_le32(advertising);\n\treq0->eth_tp_mdix_ctrl = cmd->base.eth_tp_mdix_ctrl;\n\n\treq1 = (struct hclge_phy_link_ksetting_1_cmd *)desc[1].data;\n\treq1->master_slave_cfg = cmd->base.master_slave_cfg;\n\n\tret = hclge_cmd_send(&hdev->hw, desc, HCLGE_PHY_LINK_SETTING_BD_NUM);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set phy link ksettings, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thdev->hw.mac.autoneg = cmd->base.autoneg;\n\thdev->hw.mac.speed = cmd->base.speed;\n\thdev->hw.mac.duplex = cmd->base.duplex;\n\tlinkmode_copy(hdev->hw.mac.advertising, cmd->link_modes.advertising);\n\n\treturn 0;\n}\n\nstatic int hclge_update_tp_port_info(struct hclge_dev *hdev)\n{\n\tstruct ethtool_link_ksettings cmd;\n\tint ret;\n\n\tif (!hnae3_dev_phy_imp_supported(hdev))\n\t\treturn 0;\n\n\tret = hclge_get_phy_link_ksettings(&hdev->vport->nic, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->hw.mac.autoneg = cmd.base.autoneg;\n\thdev->hw.mac.speed = cmd.base.speed;\n\thdev->hw.mac.duplex = cmd.base.duplex;\n\tlinkmode_copy(hdev->hw.mac.advertising, cmd.link_modes.advertising);\n\n\treturn 0;\n}\n\nstatic int hclge_tp_port_init(struct hclge_dev *hdev)\n{\n\tstruct ethtool_link_ksettings cmd;\n\n\tif (!hnae3_dev_phy_imp_supported(hdev))\n\t\treturn 0;\n\n\tcmd.base.autoneg = hdev->hw.mac.autoneg;\n\tcmd.base.speed = hdev->hw.mac.speed;\n\tcmd.base.duplex = hdev->hw.mac.duplex;\n\tlinkmode_copy(cmd.link_modes.advertising, hdev->hw.mac.advertising);\n\n\treturn hclge_set_phy_link_ksettings(&hdev->vport->nic, &cmd);\n}\n\nstatic int hclge_update_port_info(struct hclge_dev *hdev)\n{\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\tint speed;\n\tint ret;\n\n\t \n\tif (mac->media_type == HNAE3_MEDIA_TYPE_COPPER)\n\t\treturn hclge_update_tp_port_info(hdev);\n\n\t \n\tif (!hdev->support_sfp_query)\n\t\treturn 0;\n\n\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2) {\n\t\tspeed = mac->speed;\n\t\tret = hclge_get_sfp_info(hdev, mac);\n\t} else {\n\t\tspeed = HCLGE_MAC_SPEED_UNKNOWN;\n\t\tret = hclge_get_sfp_speed(hdev, &speed);\n\t}\n\n\tif (ret == -EOPNOTSUPP) {\n\t\thdev->support_sfp_query = false;\n\t\treturn ret;\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\n\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2) {\n\t\tif (mac->speed_type == QUERY_ACTIVE_SPEED) {\n\t\t\thclge_update_port_capability(hdev, mac);\n\t\t\tif (mac->speed != speed)\n\t\t\t\t(void)hclge_tm_port_shaper_cfg(hdev);\n\t\t\treturn 0;\n\t\t}\n\t\treturn hclge_cfg_mac_speed_dup(hdev, mac->speed,\n\t\t\t\t\t       HCLGE_MAC_FULL, mac->lane_num);\n\t} else {\n\t\tif (speed == HCLGE_MAC_SPEED_UNKNOWN)\n\t\t\treturn 0;  \n\n\t\t \n\t\treturn hclge_cfg_mac_speed_dup(hdev, speed, HCLGE_MAC_FULL, 0);\n\t}\n}\n\nstatic int hclge_get_status(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\thclge_update_link_status(hdev);\n\n\treturn hdev->hw.mac.link;\n}\n\nstatic struct hclge_vport *hclge_get_vf_vport(struct hclge_dev *hdev, int vf)\n{\n\tif (!pci_num_vf(hdev->pdev)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"SRIOV is disabled, can not get vport(%d) info.\\n\", vf);\n\t\treturn NULL;\n\t}\n\n\tif (vf < 0 || vf >= pci_num_vf(hdev->pdev)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"vf id(%d) is out of range(0 <= vfid < %d)\\n\",\n\t\t\tvf, pci_num_vf(hdev->pdev));\n\t\treturn NULL;\n\t}\n\n\t \n\tvf += HCLGE_VF_VPORT_START_NUM;\n\treturn &hdev->vport[vf];\n}\n\nstatic int hclge_get_vf_config(struct hnae3_handle *handle, int vf,\n\t\t\t       struct ifla_vf_info *ivf)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tvport = hclge_get_vf_vport(hdev, vf);\n\tif (!vport)\n\t\treturn -EINVAL;\n\n\tivf->vf = vf;\n\tivf->linkstate = vport->vf_info.link_state;\n\tivf->spoofchk = vport->vf_info.spoofchk;\n\tivf->trusted = vport->vf_info.trusted;\n\tivf->min_tx_rate = 0;\n\tivf->max_tx_rate = vport->vf_info.max_tx_rate;\n\tivf->vlan = vport->port_base_vlan_cfg.vlan_info.vlan_tag;\n\tivf->vlan_proto = htons(vport->port_base_vlan_cfg.vlan_info.vlan_proto);\n\tivf->qos = vport->port_base_vlan_cfg.vlan_info.qos;\n\tether_addr_copy(ivf->mac, vport->vf_info.mac);\n\n\treturn 0;\n}\n\nstatic int hclge_set_vf_link_state(struct hnae3_handle *handle, int vf,\n\t\t\t\t   int link_state)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint link_state_old;\n\tint ret;\n\n\tvport = hclge_get_vf_vport(hdev, vf);\n\tif (!vport)\n\t\treturn -EINVAL;\n\n\tlink_state_old = vport->vf_info.link_state;\n\tvport->vf_info.link_state = link_state;\n\n\t \n\tif (!test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state))\n\t\treturn 0;\n\n\tret = hclge_push_vf_link_status(vport);\n\tif (ret) {\n\t\tvport->vf_info.link_state = link_state_old;\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to push vf%d link status, ret = %d\\n\", vf, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 hclge_check_event_cause(struct hclge_dev *hdev, u32 *clearval)\n{\n\tu32 cmdq_src_reg, msix_src_reg, hw_err_src_reg;\n\n\t \n\tcmdq_src_reg = hclge_read_dev(&hdev->hw, HCLGE_VECTOR0_CMDQ_SRC_REG);\n\tmsix_src_reg = hclge_read_dev(&hdev->hw, HCLGE_MISC_VECTOR_INT_STS);\n\thw_err_src_reg = hclge_read_dev(&hdev->hw,\n\t\t\t\t\tHCLGE_RAS_PF_OTHER_INT_STS_REG);\n\n\t \n\tif (BIT(HCLGE_VECTOR0_IMPRESET_INT_B) & msix_src_reg) {\n\t\tdev_info(&hdev->pdev->dev, \"IMP reset interrupt\\n\");\n\t\tset_bit(HNAE3_IMP_RESET, &hdev->reset_pending);\n\t\tset_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);\n\t\t*clearval = BIT(HCLGE_VECTOR0_IMPRESET_INT_B);\n\t\thdev->rst_stats.imp_rst_cnt++;\n\t\treturn HCLGE_VECTOR0_EVENT_RST;\n\t}\n\n\tif (BIT(HCLGE_VECTOR0_GLOBALRESET_INT_B) & msix_src_reg) {\n\t\tdev_info(&hdev->pdev->dev, \"global reset interrupt\\n\");\n\t\tset_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);\n\t\tset_bit(HNAE3_GLOBAL_RESET, &hdev->reset_pending);\n\t\t*clearval = BIT(HCLGE_VECTOR0_GLOBALRESET_INT_B);\n\t\thdev->rst_stats.global_rst_cnt++;\n\t\treturn HCLGE_VECTOR0_EVENT_RST;\n\t}\n\n\t \n\tif (msix_src_reg & HCLGE_VECTOR0_REG_MSIX_MASK ||\n\t    hw_err_src_reg & HCLGE_RAS_REG_ERR_MASK)\n\t\treturn HCLGE_VECTOR0_EVENT_ERR;\n\n\t \n\tif (BIT(HCLGE_VECTOR0_REG_PTP_INT_B) & msix_src_reg) {\n\t\t*clearval = msix_src_reg;\n\t\treturn HCLGE_VECTOR0_EVENT_PTP;\n\t}\n\n\t \n\tif (BIT(HCLGE_VECTOR0_RX_CMDQ_INT_B) & cmdq_src_reg) {\n\t\tcmdq_src_reg &= ~BIT(HCLGE_VECTOR0_RX_CMDQ_INT_B);\n\t\t*clearval = cmdq_src_reg;\n\t\treturn HCLGE_VECTOR0_EVENT_MBX;\n\t}\n\n\t \n\tdev_info(&hdev->pdev->dev,\n\t\t \"INT status: CMDQ(%#x) HW errors(%#x) other(%#x)\\n\",\n\t\t cmdq_src_reg, hw_err_src_reg, msix_src_reg);\n\n\treturn HCLGE_VECTOR0_EVENT_OTHER;\n}\n\nstatic void hclge_clear_event_cause(struct hclge_dev *hdev, u32 event_type,\n\t\t\t\t    u32 regclr)\n{\n#define HCLGE_IMP_RESET_DELAY\t\t5\n\n\tswitch (event_type) {\n\tcase HCLGE_VECTOR0_EVENT_PTP:\n\tcase HCLGE_VECTOR0_EVENT_RST:\n\t\tif (regclr == BIT(HCLGE_VECTOR0_IMPRESET_INT_B))\n\t\t\tmdelay(HCLGE_IMP_RESET_DELAY);\n\n\t\thclge_write_dev(&hdev->hw, HCLGE_MISC_RESET_STS_REG, regclr);\n\t\tbreak;\n\tcase HCLGE_VECTOR0_EVENT_MBX:\n\t\thclge_write_dev(&hdev->hw, HCLGE_VECTOR0_CMDQ_SRC_REG, regclr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void hclge_clear_all_event_cause(struct hclge_dev *hdev)\n{\n\thclge_clear_event_cause(hdev, HCLGE_VECTOR0_EVENT_RST,\n\t\t\t\tBIT(HCLGE_VECTOR0_GLOBALRESET_INT_B) |\n\t\t\t\tBIT(HCLGE_VECTOR0_CORERESET_INT_B) |\n\t\t\t\tBIT(HCLGE_VECTOR0_IMPRESET_INT_B));\n\thclge_clear_event_cause(hdev, HCLGE_VECTOR0_EVENT_MBX, 0);\n}\n\nstatic void hclge_enable_vector(struct hclge_misc_vector *vector, bool enable)\n{\n\twritel(enable ? 1 : 0, vector->addr);\n}\n\nstatic irqreturn_t hclge_misc_irq_handle(int irq, void *data)\n{\n\tstruct hclge_dev *hdev = data;\n\tunsigned long flags;\n\tu32 clearval = 0;\n\tu32 event_cause;\n\n\thclge_enable_vector(&hdev->misc_vector, false);\n\tevent_cause = hclge_check_event_cause(hdev, &clearval);\n\n\t \n\tswitch (event_cause) {\n\tcase HCLGE_VECTOR0_EVENT_ERR:\n\t\thclge_errhand_task_schedule(hdev);\n\t\tbreak;\n\tcase HCLGE_VECTOR0_EVENT_RST:\n\t\thclge_reset_task_schedule(hdev);\n\t\tbreak;\n\tcase HCLGE_VECTOR0_EVENT_PTP:\n\t\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\t\thclge_ptp_clean_tx_hwts(hdev);\n\t\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n\t\tbreak;\n\tcase HCLGE_VECTOR0_EVENT_MBX:\n\t\t \n\t\thclge_mbx_task_schedule(hdev);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"received unknown or unhandled event of vector0\\n\");\n\t\tbreak;\n\t}\n\n\thclge_clear_event_cause(hdev, event_cause, clearval);\n\n\t \n\tif (event_cause == HCLGE_VECTOR0_EVENT_PTP ||\n\t    event_cause == HCLGE_VECTOR0_EVENT_MBX ||\n\t    event_cause == HCLGE_VECTOR0_EVENT_OTHER)\n\t\thclge_enable_vector(&hdev->misc_vector, true);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hclge_free_vector(struct hclge_dev *hdev, int vector_id)\n{\n\tif (hdev->vector_status[vector_id] == HCLGE_INVALID_VPORT) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"vector(vector_id %d) has been freed.\\n\", vector_id);\n\t\treturn;\n\t}\n\n\thdev->vector_status[vector_id] = HCLGE_INVALID_VPORT;\n\thdev->num_msi_left += 1;\n\thdev->num_msi_used -= 1;\n}\n\nstatic void hclge_get_misc_vector(struct hclge_dev *hdev)\n{\n\tstruct hclge_misc_vector *vector = &hdev->misc_vector;\n\n\tvector->vector_irq = pci_irq_vector(hdev->pdev, 0);\n\n\tvector->addr = hdev->hw.hw.io_base + HCLGE_MISC_VECTOR_REG_BASE;\n\thdev->vector_status[0] = 0;\n\n\thdev->num_msi_left -= 1;\n\thdev->num_msi_used += 1;\n}\n\nstatic int hclge_misc_irq_init(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\thclge_get_misc_vector(hdev);\n\n\t \n\tsnprintf(hdev->misc_vector.name, HNAE3_INT_NAME_LEN, \"%s-misc-%s\",\n\t\t HCLGE_NAME, pci_name(hdev->pdev));\n\tret = request_irq(hdev->misc_vector.vector_irq, hclge_misc_irq_handle,\n\t\t\t  0, hdev->misc_vector.name, hdev);\n\tif (ret) {\n\t\thclge_free_vector(hdev, 0);\n\t\tdev_err(&hdev->pdev->dev, \"request misc irq(%d) fail\\n\",\n\t\t\thdev->misc_vector.vector_irq);\n\t}\n\n\treturn ret;\n}\n\nstatic void hclge_misc_irq_uninit(struct hclge_dev *hdev)\n{\n\tfree_irq(hdev->misc_vector.vector_irq, hdev);\n\thclge_free_vector(hdev, 0);\n}\n\nint hclge_notify_client(struct hclge_dev *hdev,\n\t\t\tenum hnae3_reset_notify_type type)\n{\n\tstruct hnae3_handle *handle = &hdev->vport[0].nic;\n\tstruct hnae3_client *client = hdev->nic_client;\n\tint ret;\n\n\tif (!test_bit(HCLGE_STATE_NIC_REGISTERED, &hdev->state) || !client)\n\t\treturn 0;\n\n\tif (!client->ops->reset_notify)\n\t\treturn -EOPNOTSUPP;\n\n\tret = client->ops->reset_notify(handle, type);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"notify nic client failed %d(%d)\\n\",\n\t\t\ttype, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_notify_roce_client(struct hclge_dev *hdev,\n\t\t\t\t    enum hnae3_reset_notify_type type)\n{\n\tstruct hnae3_handle *handle = &hdev->vport[0].roce;\n\tstruct hnae3_client *client = hdev->roce_client;\n\tint ret;\n\n\tif (!test_bit(HCLGE_STATE_ROCE_REGISTERED, &hdev->state) || !client)\n\t\treturn 0;\n\n\tif (!client->ops->reset_notify)\n\t\treturn -EOPNOTSUPP;\n\n\tret = client->ops->reset_notify(handle, type);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"notify roce client failed %d(%d)\",\n\t\t\ttype, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_reset_wait(struct hclge_dev *hdev)\n{\n#define HCLGE_RESET_WATI_MS\t100\n#define HCLGE_RESET_WAIT_CNT\t350\n\n\tu32 val, reg, reg_bit;\n\tu32 cnt = 0;\n\n\tswitch (hdev->reset_type) {\n\tcase HNAE3_IMP_RESET:\n\t\treg = HCLGE_GLOBAL_RESET_REG;\n\t\treg_bit = HCLGE_IMP_RESET_BIT;\n\t\tbreak;\n\tcase HNAE3_GLOBAL_RESET:\n\t\treg = HCLGE_GLOBAL_RESET_REG;\n\t\treg_bit = HCLGE_GLOBAL_RESET_BIT;\n\t\tbreak;\n\tcase HNAE3_FUNC_RESET:\n\t\treg = HCLGE_FUN_RST_ING;\n\t\treg_bit = HCLGE_FUN_RST_ING_B;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Wait for unsupported reset type: %d\\n\",\n\t\t\thdev->reset_type);\n\t\treturn -EINVAL;\n\t}\n\n\tval = hclge_read_dev(&hdev->hw, reg);\n\twhile (hnae3_get_bit(val, reg_bit) && cnt < HCLGE_RESET_WAIT_CNT) {\n\t\tmsleep(HCLGE_RESET_WATI_MS);\n\t\tval = hclge_read_dev(&hdev->hw, reg);\n\t\tcnt++;\n\t}\n\n\tif (cnt >= HCLGE_RESET_WAIT_CNT) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"Wait for reset timeout: %d\\n\", hdev->reset_type);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_set_vf_rst(struct hclge_dev *hdev, int func_id, bool reset)\n{\n\tstruct hclge_vf_rst_cmd *req;\n\tstruct hclge_desc desc;\n\n\treq = (struct hclge_vf_rst_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_GBL_RST_STATUS, false);\n\treq->dest_vfid = func_id;\n\n\tif (reset)\n\t\treq->vf_rst = 0x1;\n\n\treturn hclge_cmd_send(&hdev->hw, &desc, 1);\n}\n\nstatic int hclge_set_all_vf_rst(struct hclge_dev *hdev, bool reset)\n{\n\tint i;\n\n\tfor (i = HCLGE_VF_VPORT_START_NUM; i < hdev->num_alloc_vport; i++) {\n\t\tstruct hclge_vport *vport = &hdev->vport[i];\n\t\tint ret;\n\n\t\t \n\t\tret = hclge_set_vf_rst(hdev, vport->vport_id, reset);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"set vf(%u) rst failed %d!\\n\",\n\t\t\t\tvport->vport_id - HCLGE_VF_VPORT_START_NUM,\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!reset ||\n\t\t    !test_bit(HCLGE_VPORT_STATE_INITED, &vport->state))\n\t\t\tcontinue;\n\n\t\tif (!test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state) &&\n\t\t    hdev->reset_type == HNAE3_FUNC_RESET) {\n\t\t\tset_bit(HCLGE_VPORT_NEED_NOTIFY_RESET,\n\t\t\t\t&vport->need_notify);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = hclge_inform_reset_assert_to_vf(vport);\n\t\tif (ret)\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"inform reset to vf(%u) failed %d!\\n\",\n\t\t\t\t vport->vport_id - HCLGE_VF_VPORT_START_NUM,\n\t\t\t\t ret);\n\t}\n\n\treturn 0;\n}\n\nstatic void hclge_mailbox_service_task(struct hclge_dev *hdev)\n{\n\tif (!test_and_clear_bit(HCLGE_STATE_MBX_SERVICE_SCHED, &hdev->state) ||\n\t    test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state) ||\n\t    test_and_set_bit(HCLGE_STATE_MBX_HANDLING, &hdev->state))\n\t\treturn;\n\n\tif (time_is_before_jiffies(hdev->last_mbx_scheduled +\n\t\t\t\t   HCLGE_MBX_SCHED_TIMEOUT))\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"mbx service task is scheduled after %ums on cpu%u!\\n\",\n\t\t\t jiffies_to_msecs(jiffies - hdev->last_mbx_scheduled),\n\t\t\t smp_processor_id());\n\n\thclge_mbx_handler(hdev);\n\n\tclear_bit(HCLGE_STATE_MBX_HANDLING, &hdev->state);\n}\n\nstatic void hclge_func_reset_sync_vf(struct hclge_dev *hdev)\n{\n\tstruct hclge_pf_rst_sync_cmd *req;\n\tstruct hclge_desc desc;\n\tint cnt = 0;\n\tint ret;\n\n\treq = (struct hclge_pf_rst_sync_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_VF_RST_RDY, true);\n\n\tdo {\n\t\t \n\t\thclge_mailbox_service_task(hdev);\n\n\t\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\t \n\t\tif (ret == -EOPNOTSUPP) {\n\t\t\tmsleep(HCLGE_RESET_SYNC_TIME);\n\t\t\treturn;\n\t\t} else if (ret) {\n\t\t\tdev_warn(&hdev->pdev->dev, \"sync with VF fail %d!\\n\",\n\t\t\t\t ret);\n\t\t\treturn;\n\t\t} else if (req->all_vf_ready) {\n\t\t\treturn;\n\t\t}\n\t\tmsleep(HCLGE_PF_RESET_SYNC_TIME);\n\t\thclge_comm_cmd_reuse_desc(&desc, true);\n\t} while (cnt++ < HCLGE_PF_RESET_SYNC_CNT);\n\n\tdev_warn(&hdev->pdev->dev, \"sync with VF timeout!\\n\");\n}\n\nvoid hclge_report_hw_error(struct hclge_dev *hdev,\n\t\t\t   enum hnae3_hw_error_type type)\n{\n\tstruct hnae3_client *client = hdev->nic_client;\n\n\tif (!client || !client->ops->process_hw_error ||\n\t    !test_bit(HCLGE_STATE_NIC_REGISTERED, &hdev->state))\n\t\treturn;\n\n\tclient->ops->process_hw_error(&hdev->vport[0].nic, type);\n}\n\nstatic void hclge_handle_imp_error(struct hclge_dev *hdev)\n{\n\tu32 reg_val;\n\n\treg_val = hclge_read_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG);\n\tif (reg_val & BIT(HCLGE_VECTOR0_IMP_RD_POISON_B)) {\n\t\thclge_report_hw_error(hdev, HNAE3_IMP_RD_POISON_ERROR);\n\t\treg_val &= ~BIT(HCLGE_VECTOR0_IMP_RD_POISON_B);\n\t\thclge_write_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG, reg_val);\n\t}\n\n\tif (reg_val & BIT(HCLGE_VECTOR0_IMP_CMDQ_ERR_B)) {\n\t\thclge_report_hw_error(hdev, HNAE3_CMDQ_ECC_ERROR);\n\t\treg_val &= ~BIT(HCLGE_VECTOR0_IMP_CMDQ_ERR_B);\n\t\thclge_write_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG, reg_val);\n\t}\n}\n\nint hclge_func_reset_cmd(struct hclge_dev *hdev, int func_id)\n{\n\tstruct hclge_desc desc;\n\tstruct hclge_reset_cmd *req = (struct hclge_reset_cmd *)desc.data;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CFG_RST_TRIGGER, false);\n\thnae3_set_bit(req->mac_func_reset, HCLGE_CFG_RESET_FUNC_B, 1);\n\treq->fun_reset_vfid = func_id;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"send function reset cmd fail, status =%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void hclge_do_reset(struct hclge_dev *hdev)\n{\n\tstruct hnae3_handle *handle = &hdev->vport[0].nic;\n\tstruct pci_dev *pdev = hdev->pdev;\n\tu32 val;\n\n\tif (hclge_get_hw_reset_stat(handle)) {\n\t\tdev_info(&pdev->dev, \"hardware reset not finish\\n\");\n\t\tdev_info(&pdev->dev, \"func_rst_reg:0x%x, global_rst_reg:0x%x\\n\",\n\t\t\t hclge_read_dev(&hdev->hw, HCLGE_FUN_RST_ING),\n\t\t\t hclge_read_dev(&hdev->hw, HCLGE_GLOBAL_RESET_REG));\n\t\treturn;\n\t}\n\n\tswitch (hdev->reset_type) {\n\tcase HNAE3_IMP_RESET:\n\t\tdev_info(&pdev->dev, \"IMP reset requested\\n\");\n\t\tval = hclge_read_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG);\n\t\thnae3_set_bit(val, HCLGE_TRIGGER_IMP_RESET_B, 1);\n\t\thclge_write_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG, val);\n\t\tbreak;\n\tcase HNAE3_GLOBAL_RESET:\n\t\tdev_info(&pdev->dev, \"global reset requested\\n\");\n\t\tval = hclge_read_dev(&hdev->hw, HCLGE_GLOBAL_RESET_REG);\n\t\thnae3_set_bit(val, HCLGE_GLOBAL_RESET_BIT, 1);\n\t\thclge_write_dev(&hdev->hw, HCLGE_GLOBAL_RESET_REG, val);\n\t\tbreak;\n\tcase HNAE3_FUNC_RESET:\n\t\tdev_info(&pdev->dev, \"PF reset requested\\n\");\n\t\t \n\t\tset_bit(HNAE3_FUNC_RESET, &hdev->reset_pending);\n\t\thclge_reset_task_schedule(hdev);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"unsupported reset type: %d\\n\", hdev->reset_type);\n\t\tbreak;\n\t}\n}\n\nstatic enum hnae3_reset_type hclge_get_reset_level(struct hnae3_ae_dev *ae_dev,\n\t\t\t\t\t\t   unsigned long *addr)\n{\n\tenum hnae3_reset_type rst_level = HNAE3_NONE_RESET;\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\n\t \n\tif (test_bit(HNAE3_IMP_RESET, addr)) {\n\t\trst_level = HNAE3_IMP_RESET;\n\t\tclear_bit(HNAE3_IMP_RESET, addr);\n\t\tclear_bit(HNAE3_GLOBAL_RESET, addr);\n\t\tclear_bit(HNAE3_FUNC_RESET, addr);\n\t} else if (test_bit(HNAE3_GLOBAL_RESET, addr)) {\n\t\trst_level = HNAE3_GLOBAL_RESET;\n\t\tclear_bit(HNAE3_GLOBAL_RESET, addr);\n\t\tclear_bit(HNAE3_FUNC_RESET, addr);\n\t} else if (test_bit(HNAE3_FUNC_RESET, addr)) {\n\t\trst_level = HNAE3_FUNC_RESET;\n\t\tclear_bit(HNAE3_FUNC_RESET, addr);\n\t} else if (test_bit(HNAE3_FLR_RESET, addr)) {\n\t\trst_level = HNAE3_FLR_RESET;\n\t\tclear_bit(HNAE3_FLR_RESET, addr);\n\t}\n\n\tif (hdev->reset_type != HNAE3_NONE_RESET &&\n\t    rst_level < hdev->reset_type)\n\t\treturn HNAE3_NONE_RESET;\n\n\treturn rst_level;\n}\n\nstatic void hclge_clear_reset_cause(struct hclge_dev *hdev)\n{\n\tu32 clearval = 0;\n\n\tswitch (hdev->reset_type) {\n\tcase HNAE3_IMP_RESET:\n\t\tclearval = BIT(HCLGE_VECTOR0_IMPRESET_INT_B);\n\t\tbreak;\n\tcase HNAE3_GLOBAL_RESET:\n\t\tclearval = BIT(HCLGE_VECTOR0_GLOBALRESET_INT_B);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!clearval)\n\t\treturn;\n\n\t \n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\thclge_write_dev(&hdev->hw, HCLGE_MISC_RESET_STS_REG,\n\t\t\t\tclearval);\n\n\thclge_enable_vector(&hdev->misc_vector, true);\n}\n\nstatic void hclge_reset_handshake(struct hclge_dev *hdev, bool enable)\n{\n\tu32 reg_val;\n\n\treg_val = hclge_read_dev(&hdev->hw, HCLGE_COMM_NIC_CSQ_DEPTH_REG);\n\tif (enable)\n\t\treg_val |= HCLGE_COMM_NIC_SW_RST_RDY;\n\telse\n\t\treg_val &= ~HCLGE_COMM_NIC_SW_RST_RDY;\n\n\thclge_write_dev(&hdev->hw, HCLGE_COMM_NIC_CSQ_DEPTH_REG, reg_val);\n}\n\nstatic int hclge_func_reset_notify_vf(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\tret = hclge_set_all_vf_rst(hdev, true);\n\tif (ret)\n\t\treturn ret;\n\n\thclge_func_reset_sync_vf(hdev);\n\n\treturn 0;\n}\n\nstatic int hclge_reset_prepare_wait(struct hclge_dev *hdev)\n{\n\tu32 reg_val;\n\tint ret = 0;\n\n\tswitch (hdev->reset_type) {\n\tcase HNAE3_FUNC_RESET:\n\t\tret = hclge_func_reset_notify_vf(hdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hclge_func_reset_cmd(hdev, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"asserting function reset fail %d!\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tset_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);\n\t\thdev->rst_stats.pf_rst_cnt++;\n\t\tbreak;\n\tcase HNAE3_FLR_RESET:\n\t\tret = hclge_func_reset_notify_vf(hdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase HNAE3_IMP_RESET:\n\t\thclge_handle_imp_error(hdev);\n\t\treg_val = hclge_read_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG);\n\t\thclge_write_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG,\n\t\t\t\tBIT(HCLGE_VECTOR0_IMP_RESET_INT_B) | reg_val);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tmsleep(HCLGE_RESET_SYNC_TIME);\n\thclge_reset_handshake(hdev, true);\n\tdev_info(&hdev->pdev->dev, \"prepare wait ok\\n\");\n\n\treturn ret;\n}\n\nstatic void hclge_show_rst_info(struct hclge_dev *hdev)\n{\n\tchar *buf;\n\n\tbuf = kzalloc(HCLGE_DBG_RESET_INFO_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\thclge_dbg_dump_rst_info(hdev, buf, HCLGE_DBG_RESET_INFO_LEN);\n\n\tdev_info(&hdev->pdev->dev, \"dump reset info:\\n%s\", buf);\n\n\tkfree(buf);\n}\n\nstatic bool hclge_reset_err_handle(struct hclge_dev *hdev)\n{\n#define MAX_RESET_FAIL_CNT 5\n\n\tif (hdev->reset_pending) {\n\t\tdev_info(&hdev->pdev->dev, \"Reset pending %lu\\n\",\n\t\t\t hdev->reset_pending);\n\t\treturn true;\n\t} else if (hclge_read_dev(&hdev->hw, HCLGE_MISC_VECTOR_INT_STS) &\n\t\t   HCLGE_RESET_INT_M) {\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"reset failed because new reset interrupt\\n\");\n\t\thclge_clear_reset_cause(hdev);\n\t\treturn false;\n\t} else if (hdev->rst_stats.reset_fail_cnt < MAX_RESET_FAIL_CNT) {\n\t\thdev->rst_stats.reset_fail_cnt++;\n\t\tset_bit(hdev->reset_type, &hdev->reset_pending);\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"re-schedule reset task(%u)\\n\",\n\t\t\t hdev->rst_stats.reset_fail_cnt);\n\t\treturn true;\n\t}\n\n\thclge_clear_reset_cause(hdev);\n\n\t \n\thclge_reset_handshake(hdev, true);\n\n\tdev_err(&hdev->pdev->dev, \"Reset fail!\\n\");\n\n\thclge_show_rst_info(hdev);\n\n\tset_bit(HCLGE_STATE_RST_FAIL, &hdev->state);\n\n\treturn false;\n}\n\nstatic void hclge_update_reset_level(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tenum hnae3_reset_type reset_level;\n\n\t \n\thclge_get_reset_level(ae_dev, &hdev->reset_request);\n\n\t \n\treset_level = hclge_get_reset_level(ae_dev,\n\t\t\t\t\t    &hdev->default_reset_request);\n\tif (reset_level != HNAE3_NONE_RESET)\n\t\tset_bit(reset_level, &hdev->reset_request);\n}\n\nstatic int hclge_set_rst_done(struct hclge_dev *hdev)\n{\n\tstruct hclge_pf_rst_done_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\treq = (struct hclge_pf_rst_done_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PF_RST_DONE, false);\n\treq->pf_rst_done |= HCLGE_PF_RESET_DONE_BIT;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t \n\tif (ret == -EOPNOTSUPP) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"current firmware does not support command(0x%x)!\\n\",\n\t\t\t HCLGE_OPC_PF_RST_DONE);\n\t\treturn 0;\n\t} else if (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"assert PF reset done fail %d!\\n\",\n\t\t\tret);\n\t}\n\n\treturn ret;\n}\n\nstatic int hclge_reset_prepare_up(struct hclge_dev *hdev)\n{\n\tint ret = 0;\n\n\tswitch (hdev->reset_type) {\n\tcase HNAE3_FUNC_RESET:\n\tcase HNAE3_FLR_RESET:\n\t\tret = hclge_set_all_vf_rst(hdev, false);\n\t\tbreak;\n\tcase HNAE3_GLOBAL_RESET:\n\tcase HNAE3_IMP_RESET:\n\t\tret = hclge_set_rst_done(hdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\thclge_reset_handshake(hdev, false);\n\n\treturn ret;\n}\n\nstatic int hclge_reset_stack(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\tret = hclge_notify_client(hdev, HNAE3_UNINIT_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_reset_ae_dev(hdev->ae_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_notify_client(hdev, HNAE3_INIT_CLIENT);\n}\n\nstatic int hclge_reset_prepare(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\thdev->rst_stats.reset_cnt++;\n\t \n\tret = hclge_notify_roce_client(hdev, HNAE3_DOWN_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\trtnl_lock();\n\tret = hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);\n\trtnl_unlock();\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_reset_prepare_wait(hdev);\n}\n\nstatic int hclge_reset_rebuild(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\thdev->rst_stats.hw_reset_done_cnt++;\n\n\tret = hclge_notify_roce_client(hdev, HNAE3_UNINIT_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\trtnl_lock();\n\tret = hclge_reset_stack(hdev);\n\trtnl_unlock();\n\tif (ret)\n\t\treturn ret;\n\n\thclge_clear_reset_cause(hdev);\n\n\tret = hclge_notify_roce_client(hdev, HNAE3_INIT_CLIENT);\n\t \n\tif (ret &&\n\t    hdev->rst_stats.reset_fail_cnt < HCLGE_RESET_MAX_FAIL_CNT - 1)\n\t\treturn ret;\n\n\tret = hclge_reset_prepare_up(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\trtnl_lock();\n\tret = hclge_notify_client(hdev, HNAE3_UP_CLIENT);\n\trtnl_unlock();\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_notify_roce_client(hdev, HNAE3_UP_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->last_reset_time = jiffies;\n\thdev->rst_stats.reset_fail_cnt = 0;\n\thdev->rst_stats.reset_done_cnt++;\n\tclear_bit(HCLGE_STATE_RST_FAIL, &hdev->state);\n\n\thclge_update_reset_level(hdev);\n\n\treturn 0;\n}\n\nstatic void hclge_reset(struct hclge_dev *hdev)\n{\n\tif (hclge_reset_prepare(hdev))\n\t\tgoto err_reset;\n\n\tif (hclge_reset_wait(hdev))\n\t\tgoto err_reset;\n\n\tif (hclge_reset_rebuild(hdev))\n\t\tgoto err_reset;\n\n\treturn;\n\nerr_reset:\n\tif (hclge_reset_err_handle(hdev))\n\t\thclge_reset_task_schedule(hdev);\n}\n\nstatic void hclge_reset_event(struct pci_dev *pdev, struct hnae3_handle *handle)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\n\t \n\n\tif (time_before(jiffies, (hdev->last_reset_time +\n\t\t\t\t  HCLGE_RESET_INTERVAL))) {\n\t\tmod_timer(&hdev->reset_timer, jiffies + HCLGE_RESET_INTERVAL);\n\t\treturn;\n\t}\n\n\tif (hdev->default_reset_request) {\n\t\thdev->reset_level =\n\t\t\thclge_get_reset_level(ae_dev,\n\t\t\t\t\t      &hdev->default_reset_request);\n\t} else if (time_after(jiffies, (hdev->last_reset_time + 4 * 5 * HZ))) {\n\t\thdev->reset_level = HNAE3_FUNC_RESET;\n\t}\n\n\tdev_info(&hdev->pdev->dev, \"received reset event, reset type is %d\\n\",\n\t\t hdev->reset_level);\n\n\t \n\tset_bit(hdev->reset_level, &hdev->reset_request);\n\thclge_reset_task_schedule(hdev);\n\n\tif (hdev->reset_level < HNAE3_GLOBAL_RESET)\n\t\thdev->reset_level++;\n}\n\nstatic void hclge_set_def_reset_request(struct hnae3_ae_dev *ae_dev,\n\t\t\t\t\tenum hnae3_reset_type rst_type)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\n\tset_bit(rst_type, &hdev->default_reset_request);\n}\n\nstatic void hclge_reset_timer(struct timer_list *t)\n{\n\tstruct hclge_dev *hdev = from_timer(hdev, t, reset_timer);\n\n\t \n\tif (!hdev->default_reset_request)\n\t\treturn;\n\n\tdev_info(&hdev->pdev->dev,\n\t\t \"triggering reset in reset timer\\n\");\n\thclge_reset_event(hdev->pdev, NULL);\n}\n\nstatic void hclge_reset_subtask(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\n\t \n\thdev->last_reset_time = jiffies;\n\thdev->reset_type = hclge_get_reset_level(ae_dev, &hdev->reset_pending);\n\tif (hdev->reset_type != HNAE3_NONE_RESET)\n\t\thclge_reset(hdev);\n\n\t \n\thdev->reset_type = hclge_get_reset_level(ae_dev, &hdev->reset_request);\n\tif (hdev->reset_type != HNAE3_NONE_RESET)\n\t\thclge_do_reset(hdev);\n\n\thdev->reset_type = HNAE3_NONE_RESET;\n}\n\nstatic void hclge_handle_err_reset_request(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tenum hnae3_reset_type reset_type;\n\n\tif (ae_dev->hw_err_reset_req) {\n\t\treset_type = hclge_get_reset_level(ae_dev,\n\t\t\t\t\t\t   &ae_dev->hw_err_reset_req);\n\t\thclge_set_def_reset_request(ae_dev, reset_type);\n\t}\n\n\tif (hdev->default_reset_request && ae_dev->ops->reset_event)\n\t\tae_dev->ops->reset_event(hdev->pdev, NULL);\n\n\t \n\thclge_enable_vector(&hdev->misc_vector, true);\n}\n\nstatic void hclge_handle_err_recovery(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\n\tae_dev->hw_err_reset_req = 0;\n\n\tif (hclge_find_error_source(hdev)) {\n\t\thclge_handle_error_info_log(ae_dev);\n\t\thclge_handle_mac_tnl(hdev);\n\t}\n\n\thclge_handle_err_reset_request(hdev);\n}\n\nstatic void hclge_misc_err_recovery(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tstruct device *dev = &hdev->pdev->dev;\n\tu32 msix_sts_reg;\n\n\tmsix_sts_reg = hclge_read_dev(&hdev->hw, HCLGE_MISC_VECTOR_INT_STS);\n\tif (msix_sts_reg & HCLGE_VECTOR0_REG_MSIX_MASK) {\n\t\tif (hclge_handle_hw_msix_error\n\t\t\t\t(hdev, &hdev->default_reset_request))\n\t\t\tdev_info(dev, \"received msix interrupt 0x%x\\n\",\n\t\t\t\t msix_sts_reg);\n\t}\n\n\thclge_handle_hw_ras_error(ae_dev);\n\n\thclge_handle_err_reset_request(hdev);\n}\n\nstatic void hclge_errhand_service_task(struct hclge_dev *hdev)\n{\n\tif (!test_and_clear_bit(HCLGE_STATE_ERR_SERVICE_SCHED, &hdev->state))\n\t\treturn;\n\n\tif (hnae3_dev_ras_imp_supported(hdev))\n\t\thclge_handle_err_recovery(hdev);\n\telse\n\t\thclge_misc_err_recovery(hdev);\n}\n\nstatic void hclge_reset_service_task(struct hclge_dev *hdev)\n{\n\tif (!test_and_clear_bit(HCLGE_STATE_RST_SERVICE_SCHED, &hdev->state))\n\t\treturn;\n\n\tif (time_is_before_jiffies(hdev->last_rst_scheduled +\n\t\t\t\t   HCLGE_RESET_SCHED_TIMEOUT))\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"reset service task is scheduled after %ums on cpu%u!\\n\",\n\t\t\t jiffies_to_msecs(jiffies - hdev->last_rst_scheduled),\n\t\t\t smp_processor_id());\n\n\tdown(&hdev->reset_sem);\n\tset_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);\n\n\thclge_reset_subtask(hdev);\n\n\tclear_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);\n\tup(&hdev->reset_sem);\n}\n\nstatic void hclge_update_vport_alive(struct hclge_dev *hdev)\n{\n#define HCLGE_ALIVE_SECONDS_NORMAL\t\t8\n\n\tunsigned long alive_time = HCLGE_ALIVE_SECONDS_NORMAL * HZ;\n\tint i;\n\n\t \n\tfor (i = 1; i < hdev->num_alloc_vport; i++) {\n\t\tstruct hclge_vport *vport = &hdev->vport[i];\n\n\t\tif (!test_bit(HCLGE_VPORT_STATE_INITED, &vport->state) ||\n\t\t    !test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state))\n\t\t\tcontinue;\n\t\tif (time_after(jiffies, vport->last_active_jiffies +\n\t\t\t       alive_time)) {\n\t\t\tclear_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"VF %u heartbeat timeout\\n\",\n\t\t\t\t i - HCLGE_VF_VPORT_START_NUM);\n\t\t}\n\t}\n}\n\nstatic void hclge_periodic_service_task(struct hclge_dev *hdev)\n{\n\tunsigned long delta = round_jiffies_relative(HZ);\n\n\tif (test_bit(HCLGE_STATE_RST_FAIL, &hdev->state))\n\t\treturn;\n\n\t \n\thclge_update_link_status(hdev);\n\thclge_sync_mac_table(hdev);\n\thclge_sync_promisc_mode(hdev);\n\thclge_sync_fd_table(hdev);\n\n\tif (time_is_after_jiffies(hdev->last_serv_processed + HZ)) {\n\t\tdelta = jiffies - hdev->last_serv_processed;\n\n\t\tif (delta < round_jiffies_relative(HZ)) {\n\t\t\tdelta = round_jiffies_relative(HZ) - delta;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thdev->serv_processed_cnt++;\n\thclge_update_vport_alive(hdev);\n\n\tif (test_bit(HCLGE_STATE_DOWN, &hdev->state)) {\n\t\thdev->last_serv_processed = jiffies;\n\t\tgoto out;\n\t}\n\n\tif (!(hdev->serv_processed_cnt % HCLGE_STATS_TIMER_INTERVAL))\n\t\thclge_update_stats_for_all(hdev);\n\n\thclge_update_port_info(hdev);\n\thclge_sync_vlan_filter(hdev);\n\n\tif (!(hdev->serv_processed_cnt % HCLGE_ARFS_EXPIRE_INTERVAL))\n\t\thclge_rfs_filter_expire(hdev);\n\n\thdev->last_serv_processed = jiffies;\n\nout:\n\thclge_task_schedule(hdev, delta);\n}\n\nstatic void hclge_ptp_service_task(struct hclge_dev *hdev)\n{\n\tunsigned long flags;\n\n\tif (!test_bit(HCLGE_STATE_PTP_EN, &hdev->state) ||\n\t    !test_bit(HCLGE_STATE_PTP_TX_HANDLING, &hdev->state) ||\n\t    !time_is_before_jiffies(hdev->ptp->tx_start + HZ))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\n\t \n\tif (test_bit(HCLGE_STATE_PTP_TX_HANDLING, &hdev->state))\n\t\thclge_ptp_clean_tx_hwts(hdev);\n\n\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n}\n\nstatic void hclge_service_task(struct work_struct *work)\n{\n\tstruct hclge_dev *hdev =\n\t\tcontainer_of(work, struct hclge_dev, service_task.work);\n\n\thclge_errhand_service_task(hdev);\n\thclge_reset_service_task(hdev);\n\thclge_ptp_service_task(hdev);\n\thclge_mailbox_service_task(hdev);\n\thclge_periodic_service_task(hdev);\n\n\t \n\thclge_errhand_service_task(hdev);\n\thclge_reset_service_task(hdev);\n\thclge_mailbox_service_task(hdev);\n}\n\nstruct hclge_vport *hclge_get_vport(struct hnae3_handle *handle)\n{\n\t \n\tif (!handle->client)\n\t\treturn container_of(handle, struct hclge_vport, nic);\n\telse if (handle->client->type == HNAE3_CLIENT_ROCE)\n\t\treturn container_of(handle, struct hclge_vport, roce);\n\telse\n\t\treturn container_of(handle, struct hclge_vport, nic);\n}\n\nstatic void hclge_get_vector_info(struct hclge_dev *hdev, u16 idx,\n\t\t\t\t  struct hnae3_vector_info *vector_info)\n{\n#define HCLGE_PF_MAX_VECTOR_NUM_DEV_V2\t64\n\n\tvector_info->vector = pci_irq_vector(hdev->pdev, idx);\n\n\t \n\tif (idx - 1 < HCLGE_PF_MAX_VECTOR_NUM_DEV_V2)\n\t\tvector_info->io_addr = hdev->hw.hw.io_base +\n\t\t\t\tHCLGE_VECTOR_REG_BASE +\n\t\t\t\t(idx - 1) * HCLGE_VECTOR_REG_OFFSET;\n\telse\n\t\tvector_info->io_addr = hdev->hw.hw.io_base +\n\t\t\t\tHCLGE_VECTOR_EXT_REG_BASE +\n\t\t\t\t(idx - 1) / HCLGE_PF_MAX_VECTOR_NUM_DEV_V2 *\n\t\t\t\tHCLGE_VECTOR_REG_OFFSET_H +\n\t\t\t\t(idx - 1) % HCLGE_PF_MAX_VECTOR_NUM_DEV_V2 *\n\t\t\t\tHCLGE_VECTOR_REG_OFFSET;\n\n\thdev->vector_status[idx] = hdev->vport[0].vport_id;\n\thdev->vector_irq[idx] = vector_info->vector;\n}\n\nstatic int hclge_get_vector(struct hnae3_handle *handle, u16 vector_num,\n\t\t\t    struct hnae3_vector_info *vector_info)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hnae3_vector_info *vector = vector_info;\n\tstruct hclge_dev *hdev = vport->back;\n\tint alloc = 0;\n\tu16 i = 0;\n\tu16 j;\n\n\tvector_num = min_t(u16, hdev->num_nic_msi - 1, vector_num);\n\tvector_num = min(hdev->num_msi_left, vector_num);\n\n\tfor (j = 0; j < vector_num; j++) {\n\t\twhile (++i < hdev->num_nic_msi) {\n\t\t\tif (hdev->vector_status[i] == HCLGE_INVALID_VPORT) {\n\t\t\t\thclge_get_vector_info(hdev, i, vector);\n\t\t\t\tvector++;\n\t\t\t\talloc++;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\thdev->num_msi_left -= alloc;\n\thdev->num_msi_used += alloc;\n\n\treturn alloc;\n}\n\nstatic int hclge_get_vector_index(struct hclge_dev *hdev, int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < hdev->num_msi; i++)\n\t\tif (vector == hdev->vector_irq[i])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int hclge_put_vector(struct hnae3_handle *handle, int vector)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint vector_id;\n\n\tvector_id = hclge_get_vector_index(hdev, vector);\n\tif (vector_id < 0) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get vector index fail. vector = %d\\n\", vector);\n\t\treturn vector_id;\n\t}\n\n\thclge_free_vector(hdev, vector_id);\n\n\treturn 0;\n}\n\nstatic int hclge_get_rss(struct hnae3_handle *handle, u32 *indir,\n\t\t\t u8 *key, u8 *hfunc)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_comm_rss_cfg *rss_cfg = &vport->back->rss_cfg;\n\n\thclge_comm_get_rss_hash_info(rss_cfg, key, hfunc);\n\n\thclge_comm_get_rss_indir_tbl(rss_cfg, indir,\n\t\t\t\t     ae_dev->dev_specs.rss_ind_tbl_size);\n\n\treturn 0;\n}\n\nstatic int hclge_set_rss(struct hnae3_handle *handle, const u32 *indir,\n\t\t\t const  u8 *key, const  u8 hfunc)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_comm_rss_cfg *rss_cfg = &hdev->rss_cfg;\n\tint ret, i;\n\n\tret = hclge_comm_set_rss_hash_key(rss_cfg, &hdev->hw.hw, key, hfunc);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"invalid hfunc type %u\\n\", hfunc);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ae_dev->dev_specs.rss_ind_tbl_size; i++)\n\t\trss_cfg->rss_indirection_tbl[i] = indir[i];\n\n\t \n\treturn hclge_comm_set_rss_indir_table(ae_dev, &hdev->hw.hw,\n\t\t\t\t\t      rss_cfg->rss_indirection_tbl);\n}\n\nstatic int hclge_set_rss_tuple(struct hnae3_handle *handle,\n\t\t\t       struct ethtool_rxnfc *nfc)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tret = hclge_comm_set_rss_tuple(hdev->ae_dev, &hdev->hw.hw,\n\t\t\t\t       &hdev->rss_cfg, nfc);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set rss tuple, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_get_rss_tuple(struct hnae3_handle *handle,\n\t\t\t       struct ethtool_rxnfc *nfc)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tu8 tuple_sets;\n\tint ret;\n\n\tnfc->data = 0;\n\n\tret = hclge_comm_get_rss_tuple(&vport->back->rss_cfg, nfc->flow_type,\n\t\t\t\t       &tuple_sets);\n\tif (ret || !tuple_sets)\n\t\treturn ret;\n\n\tnfc->data = hclge_comm_convert_rss_tuple(tuple_sets);\n\n\treturn 0;\n}\n\nstatic int hclge_get_tc_size(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn hdev->pf_rss_size_max;\n}\n\nstatic int hclge_init_rss_tc_mode(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = hdev->ae_dev;\n\tstruct hclge_vport *vport = hdev->vport;\n\tu16 tc_offset[HCLGE_MAX_TC_NUM] = {0};\n\tu16 tc_valid[HCLGE_MAX_TC_NUM] = {0};\n\tu16 tc_size[HCLGE_MAX_TC_NUM] = {0};\n\tstruct hnae3_tc_info *tc_info;\n\tu16 roundup_size;\n\tu16 rss_size;\n\tint i;\n\n\ttc_info = &vport->nic.kinfo.tc_info;\n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\trss_size = tc_info->tqp_count[i];\n\t\ttc_valid[i] = 0;\n\n\t\tif (!(hdev->hw_tc_map & BIT(i)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (rss_size > ae_dev->dev_specs.rss_ind_tbl_size ||\n\t\t    rss_size == 0) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"Configure rss tc size failed, invalid TC_SIZE = %u\\n\",\n\t\t\t\trss_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\troundup_size = roundup_pow_of_two(rss_size);\n\t\troundup_size = ilog2(roundup_size);\n\n\t\ttc_valid[i] = 1;\n\t\ttc_size[i] = roundup_size;\n\t\ttc_offset[i] = tc_info->tqp_offset[i];\n\t}\n\n\treturn hclge_comm_set_rss_tc_mode(&hdev->hw.hw, tc_offset, tc_valid,\n\t\t\t\t\t  tc_size);\n}\n\nint hclge_rss_init_hw(struct hclge_dev *hdev)\n{\n\tu16 *rss_indir = hdev->rss_cfg.rss_indirection_tbl;\n\tu8 *key = hdev->rss_cfg.rss_hash_key;\n\tu8 hfunc = hdev->rss_cfg.rss_algo;\n\tint ret;\n\n\tret = hclge_comm_set_rss_indir_table(hdev->ae_dev, &hdev->hw.hw,\n\t\t\t\t\t     rss_indir);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_comm_set_rss_algo_key(&hdev->hw.hw, hfunc, key);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_comm_set_rss_input_tuple(&hdev->hw.hw, &hdev->rss_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_init_rss_tc_mode(hdev);\n}\n\nint hclge_bind_ring_with_vector(struct hclge_vport *vport,\n\t\t\t\tint vector_id, bool en,\n\t\t\t\tstruct hnae3_ring_chain_node *ring_chain)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hnae3_ring_chain_node *node;\n\tstruct hclge_desc desc;\n\tstruct hclge_ctrl_vector_chain_cmd *req =\n\t\t(struct hclge_ctrl_vector_chain_cmd *)desc.data;\n\tenum hclge_comm_cmd_status status;\n\tenum hclge_opcode_type op;\n\tu16 tqp_type_and_id;\n\tint i;\n\n\top = en ? HCLGE_OPC_ADD_RING_TO_VECTOR : HCLGE_OPC_DEL_RING_TO_VECTOR;\n\thclge_cmd_setup_basic_desc(&desc, op, false);\n\treq->int_vector_id_l = hnae3_get_field(vector_id,\n\t\t\t\t\t       HCLGE_VECTOR_ID_L_M,\n\t\t\t\t\t       HCLGE_VECTOR_ID_L_S);\n\treq->int_vector_id_h = hnae3_get_field(vector_id,\n\t\t\t\t\t       HCLGE_VECTOR_ID_H_M,\n\t\t\t\t\t       HCLGE_VECTOR_ID_H_S);\n\n\ti = 0;\n\tfor (node = ring_chain; node; node = node->next) {\n\t\ttqp_type_and_id = le16_to_cpu(req->tqp_type_and_id[i]);\n\t\thnae3_set_field(tqp_type_and_id,  HCLGE_INT_TYPE_M,\n\t\t\t\tHCLGE_INT_TYPE_S,\n\t\t\t\thnae3_get_bit(node->flag, HNAE3_RING_TYPE_B));\n\t\thnae3_set_field(tqp_type_and_id, HCLGE_TQP_ID_M,\n\t\t\t\tHCLGE_TQP_ID_S, node->tqp_index);\n\t\thnae3_set_field(tqp_type_and_id, HCLGE_INT_GL_IDX_M,\n\t\t\t\tHCLGE_INT_GL_IDX_S,\n\t\t\t\thnae3_get_field(node->int_gl_idx,\n\t\t\t\t\t\tHNAE3_RING_GL_IDX_M,\n\t\t\t\t\t\tHNAE3_RING_GL_IDX_S));\n\t\treq->tqp_type_and_id[i] = cpu_to_le16(tqp_type_and_id);\n\t\tif (++i >= HCLGE_VECTOR_ELEMENTS_PER_CMD) {\n\t\t\treq->int_cause_num = HCLGE_VECTOR_ELEMENTS_PER_CMD;\n\t\t\treq->vfid = vport->vport_id;\n\n\t\t\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\t\tif (status) {\n\t\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\t\"Map TQP fail, status is %d.\\n\",\n\t\t\t\t\tstatus);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\ti = 0;\n\n\t\t\thclge_cmd_setup_basic_desc(&desc,\n\t\t\t\t\t\t   op,\n\t\t\t\t\t\t   false);\n\t\t\treq->int_vector_id_l =\n\t\t\t\thnae3_get_field(vector_id,\n\t\t\t\t\t\tHCLGE_VECTOR_ID_L_M,\n\t\t\t\t\t\tHCLGE_VECTOR_ID_L_S);\n\t\t\treq->int_vector_id_h =\n\t\t\t\thnae3_get_field(vector_id,\n\t\t\t\t\t\tHCLGE_VECTOR_ID_H_M,\n\t\t\t\t\t\tHCLGE_VECTOR_ID_H_S);\n\t\t}\n\t}\n\n\tif (i > 0) {\n\t\treq->int_cause_num = i;\n\t\treq->vfid = vport->vport_id;\n\t\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (status) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"Map TQP fail, status is %d.\\n\", status);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_map_ring_to_vector(struct hnae3_handle *handle, int vector,\n\t\t\t\t    struct hnae3_ring_chain_node *ring_chain)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint vector_id;\n\n\tvector_id = hclge_get_vector_index(hdev, vector);\n\tif (vector_id < 0) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get vector index. vector=%d\\n\", vector);\n\t\treturn vector_id;\n\t}\n\n\treturn hclge_bind_ring_with_vector(vport, vector_id, true, ring_chain);\n}\n\nstatic int hclge_unmap_ring_frm_vector(struct hnae3_handle *handle, int vector,\n\t\t\t\t       struct hnae3_ring_chain_node *ring_chain)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint vector_id, ret;\n\n\tif (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state))\n\t\treturn 0;\n\n\tvector_id = hclge_get_vector_index(hdev, vector);\n\tif (vector_id < 0) {\n\t\tdev_err(&handle->pdev->dev,\n\t\t\t\"Get vector index fail. ret =%d\\n\", vector_id);\n\t\treturn vector_id;\n\t}\n\n\tret = hclge_bind_ring_with_vector(vport, vector_id, false, ring_chain);\n\tif (ret)\n\t\tdev_err(&handle->pdev->dev,\n\t\t\t\"Unmap ring from vector fail. vectorid=%d, ret =%d\\n\",\n\t\t\tvector_id, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_cmd_set_promisc_mode(struct hclge_dev *hdev, u8 vf_id,\n\t\t\t\t      bool en_uc, bool en_mc, bool en_bc)\n{\n\tstruct hclge_vport *vport = &hdev->vport[vf_id];\n\tstruct hnae3_handle *handle = &vport->nic;\n\tstruct hclge_promisc_cfg_cmd *req;\n\tstruct hclge_desc desc;\n\tbool uc_tx_en = en_uc;\n\tu8 promisc_cfg = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CFG_PROMISC_MODE, false);\n\n\treq = (struct hclge_promisc_cfg_cmd *)desc.data;\n\treq->vf_id = vf_id;\n\n\tif (test_bit(HNAE3_PFLAG_LIMIT_PROMISC, &handle->priv_flags))\n\t\tuc_tx_en = false;\n\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_UC_RX_EN, en_uc ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_MC_RX_EN, en_mc ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_BC_RX_EN, en_bc ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_UC_TX_EN, uc_tx_en ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_MC_TX_EN, en_mc ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_BC_TX_EN, en_bc ? 1 : 0);\n\treq->extend_promisc = promisc_cfg;\n\n\t \n\tpromisc_cfg = 0;\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_EN_UC, en_uc ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_EN_MC, en_mc ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_EN_BC, en_bc ? 1 : 0);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_TX_EN, 1);\n\thnae3_set_bit(promisc_cfg, HCLGE_PROMISC_RX_EN, 1);\n\treq->promisc = promisc_cfg;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set vport %u promisc mode, ret = %d.\\n\",\n\t\t\tvf_id, ret);\n\n\treturn ret;\n}\n\nint hclge_set_vport_promisc_mode(struct hclge_vport *vport, bool en_uc_pmc,\n\t\t\t\t bool en_mc_pmc, bool en_bc_pmc)\n{\n\treturn hclge_cmd_set_promisc_mode(vport->back, vport->vport_id,\n\t\t\t\t\t  en_uc_pmc, en_mc_pmc, en_bc_pmc);\n}\n\nstatic int hclge_set_promisc_mode(struct hnae3_handle *handle, bool en_uc_pmc,\n\t\t\t\t  bool en_mc_pmc)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tbool en_bc_pmc = true;\n\n\t \n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\ten_bc_pmc = handle->netdev_flags & HNAE3_BPE ? true : false;\n\n\treturn hclge_set_vport_promisc_mode(vport, en_uc_pmc, en_mc_pmc,\n\t\t\t\t\t    en_bc_pmc);\n}\n\nstatic void hclge_request_update_promisc_mode(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\tset_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE, &vport->state);\n}\n\nstatic void hclge_sync_fd_state(struct hclge_dev *hdev)\n{\n\tif (hlist_empty(&hdev->fd_rule_list))\n\t\thdev->fd_active_type = HCLGE_FD_RULE_NONE;\n}\n\nstatic void hclge_fd_inc_rule_cnt(struct hclge_dev *hdev, u16 location)\n{\n\tif (!test_bit(location, hdev->fd_bmap)) {\n\t\tset_bit(location, hdev->fd_bmap);\n\t\thdev->hclge_fd_rule_num++;\n\t}\n}\n\nstatic void hclge_fd_dec_rule_cnt(struct hclge_dev *hdev, u16 location)\n{\n\tif (test_bit(location, hdev->fd_bmap)) {\n\t\tclear_bit(location, hdev->fd_bmap);\n\t\thdev->hclge_fd_rule_num--;\n\t}\n}\n\nstatic void hclge_fd_free_node(struct hclge_dev *hdev,\n\t\t\t       struct hclge_fd_rule *rule)\n{\n\thlist_del(&rule->rule_node);\n\tkfree(rule);\n\thclge_sync_fd_state(hdev);\n}\n\nstatic void hclge_update_fd_rule_node(struct hclge_dev *hdev,\n\t\t\t\t      struct hclge_fd_rule *old_rule,\n\t\t\t\t      struct hclge_fd_rule *new_rule,\n\t\t\t\t      enum HCLGE_FD_NODE_STATE state)\n{\n\tswitch (state) {\n\tcase HCLGE_FD_TO_ADD:\n\tcase HCLGE_FD_ACTIVE:\n\t\t \n\t\tnew_rule->rule_node.next = old_rule->rule_node.next;\n\t\tnew_rule->rule_node.pprev = old_rule->rule_node.pprev;\n\t\tmemcpy(old_rule, new_rule, sizeof(*old_rule));\n\t\tkfree(new_rule);\n\t\tbreak;\n\tcase HCLGE_FD_DELETED:\n\t\thclge_fd_dec_rule_cnt(hdev, old_rule->location);\n\t\thclge_fd_free_node(hdev, old_rule);\n\t\tbreak;\n\tcase HCLGE_FD_TO_DEL:\n\t\t \n\t\tif (old_rule->state == HCLGE_FD_TO_ADD) {\n\t\t\thclge_fd_dec_rule_cnt(hdev, old_rule->location);\n\t\t\thclge_fd_free_node(hdev, old_rule);\n\t\t\treturn;\n\t\t}\n\t\told_rule->state = HCLGE_FD_TO_DEL;\n\t\tbreak;\n\t}\n}\n\nstatic struct hclge_fd_rule *hclge_find_fd_rule(struct hlist_head *hlist,\n\t\t\t\t\t\tu16 location,\n\t\t\t\t\t\tstruct hclge_fd_rule **parent)\n{\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(rule, node, hlist, rule_node) {\n\t\tif (rule->location == location)\n\t\t\treturn rule;\n\t\telse if (rule->location > location)\n\t\t\treturn NULL;\n\t\t \n\t\t*parent = rule;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void hclge_fd_insert_rule_node(struct hlist_head *hlist,\n\t\t\t\t      struct hclge_fd_rule *rule,\n\t\t\t\t      struct hclge_fd_rule *parent)\n{\n\tINIT_HLIST_NODE(&rule->rule_node);\n\n\tif (parent)\n\t\thlist_add_behind(&rule->rule_node, &parent->rule_node);\n\telse\n\t\thlist_add_head(&rule->rule_node, hlist);\n}\n\nstatic int hclge_fd_set_user_def_cmd(struct hclge_dev *hdev,\n\t\t\t\t     struct hclge_fd_user_def_cfg *cfg)\n{\n\tstruct hclge_fd_user_def_cfg_cmd *req;\n\tstruct hclge_desc desc;\n\tu16 data = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_FD_USER_DEF_OP, false);\n\n\treq = (struct hclge_fd_user_def_cfg_cmd *)desc.data;\n\n\thnae3_set_bit(data, HCLGE_FD_USER_DEF_EN_B, cfg[0].ref_cnt > 0);\n\thnae3_set_field(data, HCLGE_FD_USER_DEF_OFT_M,\n\t\t\tHCLGE_FD_USER_DEF_OFT_S, cfg[0].offset);\n\treq->ol2_cfg = cpu_to_le16(data);\n\n\tdata = 0;\n\thnae3_set_bit(data, HCLGE_FD_USER_DEF_EN_B, cfg[1].ref_cnt > 0);\n\thnae3_set_field(data, HCLGE_FD_USER_DEF_OFT_M,\n\t\t\tHCLGE_FD_USER_DEF_OFT_S, cfg[1].offset);\n\treq->ol3_cfg = cpu_to_le16(data);\n\n\tdata = 0;\n\thnae3_set_bit(data, HCLGE_FD_USER_DEF_EN_B, cfg[2].ref_cnt > 0);\n\thnae3_set_field(data, HCLGE_FD_USER_DEF_OFT_M,\n\t\t\tHCLGE_FD_USER_DEF_OFT_S, cfg[2].offset);\n\treq->ol4_cfg = cpu_to_le16(data);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set fd user def data, ret= %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void hclge_sync_fd_user_def_cfg(struct hclge_dev *hdev, bool locked)\n{\n\tint ret;\n\n\tif (!test_and_clear_bit(HCLGE_STATE_FD_USER_DEF_CHANGED, &hdev->state))\n\t\treturn;\n\n\tif (!locked)\n\t\tspin_lock_bh(&hdev->fd_rule_lock);\n\n\tret = hclge_fd_set_user_def_cmd(hdev, hdev->fd_cfg.user_def_cfg);\n\tif (ret)\n\t\tset_bit(HCLGE_STATE_FD_USER_DEF_CHANGED, &hdev->state);\n\n\tif (!locked)\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n}\n\nstatic int hclge_fd_check_user_def_refcnt(struct hclge_dev *hdev,\n\t\t\t\t\t  struct hclge_fd_rule *rule)\n{\n\tstruct hlist_head *hlist = &hdev->fd_rule_list;\n\tstruct hclge_fd_rule *fd_rule, *parent = NULL;\n\tstruct hclge_fd_user_def_info *info, *old_info;\n\tstruct hclge_fd_user_def_cfg *cfg;\n\n\tif (!rule || rule->rule_type != HCLGE_FD_EP_ACTIVE ||\n\t    rule->ep.user_def.layer == HCLGE_FD_USER_DEF_NONE)\n\t\treturn 0;\n\n\t \n\tcfg = &hdev->fd_cfg.user_def_cfg[rule->ep.user_def.layer - 1];\n\tinfo = &rule->ep.user_def;\n\n\tif (!cfg->ref_cnt || cfg->offset == info->offset)\n\t\treturn 0;\n\n\tif (cfg->ref_cnt > 1)\n\t\tgoto error;\n\n\tfd_rule = hclge_find_fd_rule(hlist, rule->location, &parent);\n\tif (fd_rule) {\n\t\told_info = &fd_rule->ep.user_def;\n\t\tif (info->layer == old_info->layer)\n\t\t\treturn 0;\n\t}\n\nerror:\n\tdev_err(&hdev->pdev->dev,\n\t\t\"No available offset for layer%d fd rule, each layer only support one user def offset.\\n\",\n\t\tinfo->layer + 1);\n\treturn -ENOSPC;\n}\n\nstatic void hclge_fd_inc_user_def_refcnt(struct hclge_dev *hdev,\n\t\t\t\t\t struct hclge_fd_rule *rule)\n{\n\tstruct hclge_fd_user_def_cfg *cfg;\n\n\tif (!rule || rule->rule_type != HCLGE_FD_EP_ACTIVE ||\n\t    rule->ep.user_def.layer == HCLGE_FD_USER_DEF_NONE)\n\t\treturn;\n\n\tcfg = &hdev->fd_cfg.user_def_cfg[rule->ep.user_def.layer - 1];\n\tif (!cfg->ref_cnt) {\n\t\tcfg->offset = rule->ep.user_def.offset;\n\t\tset_bit(HCLGE_STATE_FD_USER_DEF_CHANGED, &hdev->state);\n\t}\n\tcfg->ref_cnt++;\n}\n\nstatic void hclge_fd_dec_user_def_refcnt(struct hclge_dev *hdev,\n\t\t\t\t\t struct hclge_fd_rule *rule)\n{\n\tstruct hclge_fd_user_def_cfg *cfg;\n\n\tif (!rule || rule->rule_type != HCLGE_FD_EP_ACTIVE ||\n\t    rule->ep.user_def.layer == HCLGE_FD_USER_DEF_NONE)\n\t\treturn;\n\n\tcfg = &hdev->fd_cfg.user_def_cfg[rule->ep.user_def.layer - 1];\n\tif (!cfg->ref_cnt)\n\t\treturn;\n\n\tcfg->ref_cnt--;\n\tif (!cfg->ref_cnt) {\n\t\tcfg->offset = 0;\n\t\tset_bit(HCLGE_STATE_FD_USER_DEF_CHANGED, &hdev->state);\n\t}\n}\n\nstatic void hclge_update_fd_list(struct hclge_dev *hdev,\n\t\t\t\t enum HCLGE_FD_NODE_STATE state, u16 location,\n\t\t\t\t struct hclge_fd_rule *new_rule)\n{\n\tstruct hlist_head *hlist = &hdev->fd_rule_list;\n\tstruct hclge_fd_rule *fd_rule, *parent = NULL;\n\n\tfd_rule = hclge_find_fd_rule(hlist, location, &parent);\n\tif (fd_rule) {\n\t\thclge_fd_dec_user_def_refcnt(hdev, fd_rule);\n\t\tif (state == HCLGE_FD_ACTIVE)\n\t\t\thclge_fd_inc_user_def_refcnt(hdev, new_rule);\n\t\thclge_sync_fd_user_def_cfg(hdev, true);\n\n\t\thclge_update_fd_rule_node(hdev, fd_rule, new_rule, state);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(state == HCLGE_FD_TO_DEL || state == HCLGE_FD_DELETED)) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"failed to delete fd rule %u, it's inexistent\\n\",\n\t\t\t location);\n\t\treturn;\n\t}\n\n\thclge_fd_inc_user_def_refcnt(hdev, new_rule);\n\thclge_sync_fd_user_def_cfg(hdev, true);\n\n\thclge_fd_insert_rule_node(hlist, new_rule, parent);\n\thclge_fd_inc_rule_cnt(hdev, new_rule->location);\n\n\tif (state == HCLGE_FD_TO_ADD) {\n\t\tset_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);\n\t\thclge_task_schedule(hdev, 0);\n\t}\n}\n\nstatic int hclge_get_fd_mode(struct hclge_dev *hdev, u8 *fd_mode)\n{\n\tstruct hclge_get_fd_mode_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_FD_MODE_CTRL, true);\n\n\treq = (struct hclge_get_fd_mode_cmd *)desc.data;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"get fd mode fail, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*fd_mode = req->mode;\n\n\treturn ret;\n}\n\nstatic int hclge_get_fd_allocation(struct hclge_dev *hdev,\n\t\t\t\t   u32 *stage1_entry_num,\n\t\t\t\t   u32 *stage2_entry_num,\n\t\t\t\t   u16 *stage1_counter_num,\n\t\t\t\t   u16 *stage2_counter_num)\n{\n\tstruct hclge_get_fd_allocation_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_FD_GET_ALLOCATION, true);\n\n\treq = (struct hclge_get_fd_allocation_cmd *)desc.data;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"query fd allocation fail, ret=%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*stage1_entry_num = le32_to_cpu(req->stage1_entry_num);\n\t*stage2_entry_num = le32_to_cpu(req->stage2_entry_num);\n\t*stage1_counter_num = le16_to_cpu(req->stage1_counter_num);\n\t*stage2_counter_num = le16_to_cpu(req->stage2_counter_num);\n\n\treturn ret;\n}\n\nstatic int hclge_set_fd_key_config(struct hclge_dev *hdev,\n\t\t\t\t   enum HCLGE_FD_STAGE stage_num)\n{\n\tstruct hclge_set_fd_key_config_cmd *req;\n\tstruct hclge_fd_key_cfg *stage;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_FD_KEY_CONFIG, false);\n\n\treq = (struct hclge_set_fd_key_config_cmd *)desc.data;\n\tstage = &hdev->fd_cfg.key_cfg[stage_num];\n\treq->stage = stage_num;\n\treq->key_select = stage->key_sel;\n\treq->inner_sipv6_word_en = stage->inner_sipv6_word_en;\n\treq->inner_dipv6_word_en = stage->inner_dipv6_word_en;\n\treq->outer_sipv6_word_en = stage->outer_sipv6_word_en;\n\treq->outer_dipv6_word_en = stage->outer_dipv6_word_en;\n\treq->tuple_mask = cpu_to_le32(~stage->tuple_active);\n\treq->meta_data_mask = cpu_to_le32(~stage->meta_data_active);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"set fd key fail, ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void hclge_fd_disable_user_def(struct hclge_dev *hdev)\n{\n\tstruct hclge_fd_user_def_cfg *cfg = hdev->fd_cfg.user_def_cfg;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\tmemset(cfg, 0, sizeof(hdev->fd_cfg.user_def_cfg));\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\n\thclge_fd_set_user_def_cmd(hdev, cfg);\n}\n\nstatic int hclge_init_fd_config(struct hclge_dev *hdev)\n{\n#define LOW_2_WORDS\t\t0x03\n\tstruct hclge_fd_key_cfg *key_cfg;\n\tint ret;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn 0;\n\n\tret = hclge_get_fd_mode(hdev, &hdev->fd_cfg.fd_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (hdev->fd_cfg.fd_mode) {\n\tcase HCLGE_FD_MODE_DEPTH_2K_WIDTH_400B_STAGE_1:\n\t\thdev->fd_cfg.max_key_length = MAX_KEY_LENGTH;\n\t\tbreak;\n\tcase HCLGE_FD_MODE_DEPTH_4K_WIDTH_200B_STAGE_1:\n\t\thdev->fd_cfg.max_key_length = MAX_KEY_LENGTH / 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Unsupported flow director mode %u\\n\",\n\t\t\thdev->fd_cfg.fd_mode);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tkey_cfg = &hdev->fd_cfg.key_cfg[HCLGE_FD_STAGE_1];\n\tkey_cfg->key_sel = HCLGE_FD_KEY_BASE_ON_TUPLE;\n\tkey_cfg->inner_sipv6_word_en = LOW_2_WORDS;\n\tkey_cfg->inner_dipv6_word_en = LOW_2_WORDS;\n\tkey_cfg->outer_sipv6_word_en = 0;\n\tkey_cfg->outer_dipv6_word_en = 0;\n\n\tkey_cfg->tuple_active = BIT(INNER_VLAN_TAG_FST) | BIT(INNER_ETH_TYPE) |\n\t\t\t\tBIT(INNER_IP_PROTO) | BIT(INNER_IP_TOS) |\n\t\t\t\tBIT(INNER_SRC_IP) | BIT(INNER_DST_IP) |\n\t\t\t\tBIT(INNER_SRC_PORT) | BIT(INNER_DST_PORT);\n\n\t \n\tif (hdev->fd_cfg.fd_mode == HCLGE_FD_MODE_DEPTH_2K_WIDTH_400B_STAGE_1) {\n\t\tkey_cfg->tuple_active |=\n\t\t\t\tBIT(INNER_DST_MAC) | BIT(INNER_SRC_MAC);\n\t\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3)\n\t\t\tkey_cfg->tuple_active |= HCLGE_FD_TUPLE_USER_DEF_TUPLES;\n\t}\n\n\t \n\tkey_cfg->meta_data_active = BIT(ROCE_TYPE) | BIT(DST_VPORT);\n\n\tret = hclge_get_fd_allocation(hdev,\n\t\t\t\t      &hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1],\n\t\t\t\t      &hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_2],\n\t\t\t\t      &hdev->fd_cfg.cnt_num[HCLGE_FD_STAGE_1],\n\t\t\t\t      &hdev->fd_cfg.cnt_num[HCLGE_FD_STAGE_2]);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_set_fd_key_config(hdev, HCLGE_FD_STAGE_1);\n}\n\nstatic int hclge_fd_tcam_config(struct hclge_dev *hdev, u8 stage, bool sel_x,\n\t\t\t\tint loc, u8 *key, bool is_add)\n{\n\tstruct hclge_fd_tcam_config_1_cmd *req1;\n\tstruct hclge_fd_tcam_config_2_cmd *req2;\n\tstruct hclge_fd_tcam_config_3_cmd *req3;\n\tstruct hclge_desc desc[3];\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_FD_TCAM_OP, false);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_OPC_FD_TCAM_OP, false);\n\tdesc[1].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[2], HCLGE_OPC_FD_TCAM_OP, false);\n\n\treq1 = (struct hclge_fd_tcam_config_1_cmd *)desc[0].data;\n\treq2 = (struct hclge_fd_tcam_config_2_cmd *)desc[1].data;\n\treq3 = (struct hclge_fd_tcam_config_3_cmd *)desc[2].data;\n\n\treq1->stage = stage;\n\treq1->xy_sel = sel_x ? 1 : 0;\n\thnae3_set_bit(req1->port_info, HCLGE_FD_EPORT_SW_EN_B, 0);\n\treq1->index = cpu_to_le32(loc);\n\treq1->entry_vld = sel_x ? is_add : 0;\n\n\tif (key) {\n\t\tmemcpy(req1->tcam_data, &key[0], sizeof(req1->tcam_data));\n\t\tmemcpy(req2->tcam_data, &key[sizeof(req1->tcam_data)],\n\t\t       sizeof(req2->tcam_data));\n\t\tmemcpy(req3->tcam_data, &key[sizeof(req1->tcam_data) +\n\t\t       sizeof(req2->tcam_data)], sizeof(req3->tcam_data));\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, desc, 3);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"config tcam key fail, ret=%d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int hclge_fd_ad_config(struct hclge_dev *hdev, u8 stage, int loc,\n\t\t\t      struct hclge_fd_ad_data *action)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tstruct hclge_fd_ad_config_cmd *req;\n\tstruct hclge_desc desc;\n\tu64 ad_data = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_FD_AD_OP, false);\n\n\treq = (struct hclge_fd_ad_config_cmd *)desc.data;\n\treq->index = cpu_to_le32(loc);\n\treq->stage = stage;\n\n\thnae3_set_bit(ad_data, HCLGE_FD_AD_WR_RULE_ID_B,\n\t\t      action->write_rule_id_to_bd);\n\thnae3_set_field(ad_data, HCLGE_FD_AD_RULE_ID_M, HCLGE_FD_AD_RULE_ID_S,\n\t\t\taction->rule_id);\n\tif (test_bit(HNAE3_DEV_SUPPORT_FD_FORWARD_TC_B, ae_dev->caps)) {\n\t\thnae3_set_bit(ad_data, HCLGE_FD_AD_TC_OVRD_B,\n\t\t\t      action->override_tc);\n\t\thnae3_set_field(ad_data, HCLGE_FD_AD_TC_SIZE_M,\n\t\t\t\tHCLGE_FD_AD_TC_SIZE_S, (u32)action->tc_size);\n\t}\n\tad_data <<= 32;\n\thnae3_set_bit(ad_data, HCLGE_FD_AD_DROP_B, action->drop_packet);\n\thnae3_set_bit(ad_data, HCLGE_FD_AD_DIRECT_QID_B,\n\t\t      action->forward_to_direct_queue);\n\thnae3_set_field(ad_data, HCLGE_FD_AD_QID_M, HCLGE_FD_AD_QID_S,\n\t\t\taction->queue_id);\n\thnae3_set_bit(ad_data, HCLGE_FD_AD_USE_COUNTER_B, action->use_counter);\n\thnae3_set_field(ad_data, HCLGE_FD_AD_COUNTER_NUM_M,\n\t\t\tHCLGE_FD_AD_COUNTER_NUM_S, action->counter_id);\n\thnae3_set_bit(ad_data, HCLGE_FD_AD_NXT_STEP_B, action->use_next_stage);\n\thnae3_set_field(ad_data, HCLGE_FD_AD_NXT_KEY_M, HCLGE_FD_AD_NXT_KEY_S,\n\t\t\taction->counter_id);\n\n\treq->ad_data = cpu_to_le64(ad_data);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"fd ad config fail, ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic bool hclge_fd_convert_tuple(u32 tuple_bit, u8 *key_x, u8 *key_y,\n\t\t\t\t   struct hclge_fd_rule *rule)\n{\n\tint offset, moffset, ip_offset;\n\tenum HCLGE_FD_KEY_OPT key_opt;\n\tu16 tmp_x_s, tmp_y_s;\n\tu32 tmp_x_l, tmp_y_l;\n\tu8 *p = (u8 *)rule;\n\tint i;\n\n\tif (rule->unused_tuple & BIT(tuple_bit))\n\t\treturn true;\n\n\tkey_opt = tuple_key_info[tuple_bit].key_opt;\n\toffset = tuple_key_info[tuple_bit].offset;\n\tmoffset = tuple_key_info[tuple_bit].moffset;\n\n\tswitch (key_opt) {\n\tcase KEY_OPT_U8:\n\t\tcalc_x(*key_x, p[offset], p[moffset]);\n\t\tcalc_y(*key_y, p[offset], p[moffset]);\n\n\t\treturn true;\n\tcase KEY_OPT_LE16:\n\t\tcalc_x(tmp_x_s, *(u16 *)(&p[offset]), *(u16 *)(&p[moffset]));\n\t\tcalc_y(tmp_y_s, *(u16 *)(&p[offset]), *(u16 *)(&p[moffset]));\n\t\t*(__le16 *)key_x = cpu_to_le16(tmp_x_s);\n\t\t*(__le16 *)key_y = cpu_to_le16(tmp_y_s);\n\n\t\treturn true;\n\tcase KEY_OPT_LE32:\n\t\tcalc_x(tmp_x_l, *(u32 *)(&p[offset]), *(u32 *)(&p[moffset]));\n\t\tcalc_y(tmp_y_l, *(u32 *)(&p[offset]), *(u32 *)(&p[moffset]));\n\t\t*(__le32 *)key_x = cpu_to_le32(tmp_x_l);\n\t\t*(__le32 *)key_y = cpu_to_le32(tmp_y_l);\n\n\t\treturn true;\n\tcase KEY_OPT_MAC:\n\t\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\t\tcalc_x(key_x[ETH_ALEN - 1 - i], p[offset + i],\n\t\t\t       p[moffset + i]);\n\t\t\tcalc_y(key_y[ETH_ALEN - 1 - i], p[offset + i],\n\t\t\t       p[moffset + i]);\n\t\t}\n\n\t\treturn true;\n\tcase KEY_OPT_IP:\n\t\tip_offset = IPV4_INDEX * sizeof(u32);\n\t\tcalc_x(tmp_x_l, *(u32 *)(&p[offset + ip_offset]),\n\t\t       *(u32 *)(&p[moffset + ip_offset]));\n\t\tcalc_y(tmp_y_l, *(u32 *)(&p[offset + ip_offset]),\n\t\t       *(u32 *)(&p[moffset + ip_offset]));\n\t\t*(__le32 *)key_x = cpu_to_le32(tmp_x_l);\n\t\t*(__le32 *)key_y = cpu_to_le32(tmp_y_l);\n\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic u32 hclge_get_port_number(enum HLCGE_PORT_TYPE port_type, u8 pf_id,\n\t\t\t\t u8 vf_id, u8 network_port_id)\n{\n\tu32 port_number = 0;\n\n\tif (port_type == HOST_PORT) {\n\t\thnae3_set_field(port_number, HCLGE_PF_ID_M, HCLGE_PF_ID_S,\n\t\t\t\tpf_id);\n\t\thnae3_set_field(port_number, HCLGE_VF_ID_M, HCLGE_VF_ID_S,\n\t\t\t\tvf_id);\n\t\thnae3_set_bit(port_number, HCLGE_PORT_TYPE_B, HOST_PORT);\n\t} else {\n\t\thnae3_set_field(port_number, HCLGE_NETWORK_PORT_ID_M,\n\t\t\t\tHCLGE_NETWORK_PORT_ID_S, network_port_id);\n\t\thnae3_set_bit(port_number, HCLGE_PORT_TYPE_B, NETWORK_PORT);\n\t}\n\n\treturn port_number;\n}\n\nstatic void hclge_fd_convert_meta_data(struct hclge_fd_key_cfg *key_cfg,\n\t\t\t\t       __le32 *key_x, __le32 *key_y,\n\t\t\t\t       struct hclge_fd_rule *rule)\n{\n\tu32 tuple_bit, meta_data = 0, tmp_x, tmp_y, port_number;\n\tu8 cur_pos = 0, tuple_size, shift_bits;\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX_META_DATA; i++) {\n\t\ttuple_size = meta_data_key_info[i].key_length;\n\t\ttuple_bit = key_cfg->meta_data_active & BIT(i);\n\n\t\tswitch (tuple_bit) {\n\t\tcase BIT(ROCE_TYPE):\n\t\t\thnae3_set_bit(meta_data, cur_pos, NIC_PACKET);\n\t\t\tcur_pos += tuple_size;\n\t\t\tbreak;\n\t\tcase BIT(DST_VPORT):\n\t\t\tport_number = hclge_get_port_number(HOST_PORT, 0,\n\t\t\t\t\t\t\t    rule->vf_id, 0);\n\t\t\thnae3_set_field(meta_data,\n\t\t\t\t\tGENMASK(cur_pos + tuple_size, cur_pos),\n\t\t\t\t\tcur_pos, port_number);\n\t\t\tcur_pos += tuple_size;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcalc_x(tmp_x, meta_data, 0xFFFFFFFF);\n\tcalc_y(tmp_y, meta_data, 0xFFFFFFFF);\n\tshift_bits = sizeof(meta_data) * 8 - cur_pos;\n\n\t*key_x = cpu_to_le32(tmp_x << shift_bits);\n\t*key_y = cpu_to_le32(tmp_y << shift_bits);\n}\n\n \nstatic int hclge_config_key(struct hclge_dev *hdev, u8 stage,\n\t\t\t    struct hclge_fd_rule *rule)\n{\n\tstruct hclge_fd_key_cfg *key_cfg = &hdev->fd_cfg.key_cfg[stage];\n\tu8 key_x[MAX_KEY_BYTES], key_y[MAX_KEY_BYTES];\n\tu8 *cur_key_x, *cur_key_y;\n\tu8 meta_data_region;\n\tu8 tuple_size;\n\tint ret;\n\tu32 i;\n\n\tmemset(key_x, 0, sizeof(key_x));\n\tmemset(key_y, 0, sizeof(key_y));\n\tcur_key_x = key_x;\n\tcur_key_y = key_y;\n\n\tfor (i = 0; i < MAX_TUPLE; i++) {\n\t\tbool tuple_valid;\n\n\t\ttuple_size = tuple_key_info[i].key_length / 8;\n\t\tif (!(key_cfg->tuple_active & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttuple_valid = hclge_fd_convert_tuple(i, cur_key_x,\n\t\t\t\t\t\t     cur_key_y, rule);\n\t\tif (tuple_valid) {\n\t\t\tcur_key_x += tuple_size;\n\t\t\tcur_key_y += tuple_size;\n\t\t}\n\t}\n\n\tmeta_data_region = hdev->fd_cfg.max_key_length / 8 -\n\t\t\tMAX_META_DATA_LENGTH / 8;\n\n\thclge_fd_convert_meta_data(key_cfg,\n\t\t\t\t   (__le32 *)(key_x + meta_data_region),\n\t\t\t\t   (__le32 *)(key_y + meta_data_region),\n\t\t\t\t   rule);\n\n\tret = hclge_fd_tcam_config(hdev, stage, false, rule->location, key_y,\n\t\t\t\t   true);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"fd key_y config fail, loc=%u, ret=%d\\n\",\n\t\t\trule->queue_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_fd_tcam_config(hdev, stage, true, rule->location, key_x,\n\t\t\t\t   true);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"fd key_x config fail, loc=%u, ret=%d\\n\",\n\t\t\trule->queue_id, ret);\n\treturn ret;\n}\n\nstatic int hclge_config_action(struct hclge_dev *hdev, u8 stage,\n\t\t\t       struct hclge_fd_rule *rule)\n{\n\tstruct hclge_vport *vport = hdev->vport;\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_fd_ad_data ad_data;\n\n\tmemset(&ad_data, 0, sizeof(struct hclge_fd_ad_data));\n\tad_data.ad_id = rule->location;\n\n\tif (rule->action == HCLGE_FD_ACTION_DROP_PACKET) {\n\t\tad_data.drop_packet = true;\n\t} else if (rule->action == HCLGE_FD_ACTION_SELECT_TC) {\n\t\tad_data.override_tc = true;\n\t\tad_data.queue_id =\n\t\t\tkinfo->tc_info.tqp_offset[rule->cls_flower.tc];\n\t\tad_data.tc_size =\n\t\t\tilog2(kinfo->tc_info.tqp_count[rule->cls_flower.tc]);\n\t} else {\n\t\tad_data.forward_to_direct_queue = true;\n\t\tad_data.queue_id = rule->queue_id;\n\t}\n\n\tif (hdev->fd_cfg.cnt_num[HCLGE_FD_STAGE_1]) {\n\t\tad_data.use_counter = true;\n\t\tad_data.counter_id = rule->vf_id %\n\t\t\t\t     hdev->fd_cfg.cnt_num[HCLGE_FD_STAGE_1];\n\t} else {\n\t\tad_data.use_counter = false;\n\t\tad_data.counter_id = 0;\n\t}\n\n\tad_data.use_next_stage = false;\n\tad_data.next_input_key = 0;\n\n\tad_data.write_rule_id_to_bd = true;\n\tad_data.rule_id = rule->location;\n\n\treturn hclge_fd_ad_config(hdev, stage, ad_data.ad_id, &ad_data);\n}\n\nstatic int hclge_fd_check_tcpip4_tuple(struct ethtool_tcpip4_spec *spec,\n\t\t\t\t       u32 *unused_tuple)\n{\n\tif (!spec || !unused_tuple)\n\t\treturn -EINVAL;\n\n\t*unused_tuple |= BIT(INNER_SRC_MAC) | BIT(INNER_DST_MAC);\n\n\tif (!spec->ip4src)\n\t\t*unused_tuple |= BIT(INNER_SRC_IP);\n\n\tif (!spec->ip4dst)\n\t\t*unused_tuple |= BIT(INNER_DST_IP);\n\n\tif (!spec->psrc)\n\t\t*unused_tuple |= BIT(INNER_SRC_PORT);\n\n\tif (!spec->pdst)\n\t\t*unused_tuple |= BIT(INNER_DST_PORT);\n\n\tif (!spec->tos)\n\t\t*unused_tuple |= BIT(INNER_IP_TOS);\n\n\treturn 0;\n}\n\nstatic int hclge_fd_check_ip4_tuple(struct ethtool_usrip4_spec *spec,\n\t\t\t\t    u32 *unused_tuple)\n{\n\tif (!spec || !unused_tuple)\n\t\treturn -EINVAL;\n\n\t*unused_tuple |= BIT(INNER_SRC_MAC) | BIT(INNER_DST_MAC) |\n\t\tBIT(INNER_SRC_PORT) | BIT(INNER_DST_PORT);\n\n\tif (!spec->ip4src)\n\t\t*unused_tuple |= BIT(INNER_SRC_IP);\n\n\tif (!spec->ip4dst)\n\t\t*unused_tuple |= BIT(INNER_DST_IP);\n\n\tif (!spec->tos)\n\t\t*unused_tuple |= BIT(INNER_IP_TOS);\n\n\tif (!spec->proto)\n\t\t*unused_tuple |= BIT(INNER_IP_PROTO);\n\n\tif (spec->l4_4_bytes)\n\t\treturn -EOPNOTSUPP;\n\n\tif (spec->ip_ver != ETH_RX_NFC_IP4)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int hclge_fd_check_tcpip6_tuple(struct ethtool_tcpip6_spec *spec,\n\t\t\t\t       u32 *unused_tuple)\n{\n\tif (!spec || !unused_tuple)\n\t\treturn -EINVAL;\n\n\t*unused_tuple |= BIT(INNER_SRC_MAC) | BIT(INNER_DST_MAC);\n\n\t \n\tif (ipv6_addr_any((struct in6_addr *)spec->ip6src))\n\t\t*unused_tuple |= BIT(INNER_SRC_IP);\n\n\tif (ipv6_addr_any((struct in6_addr *)spec->ip6dst))\n\t\t*unused_tuple |= BIT(INNER_DST_IP);\n\n\tif (!spec->psrc)\n\t\t*unused_tuple |= BIT(INNER_SRC_PORT);\n\n\tif (!spec->pdst)\n\t\t*unused_tuple |= BIT(INNER_DST_PORT);\n\n\tif (!spec->tclass)\n\t\t*unused_tuple |= BIT(INNER_IP_TOS);\n\n\treturn 0;\n}\n\nstatic int hclge_fd_check_ip6_tuple(struct ethtool_usrip6_spec *spec,\n\t\t\t\t    u32 *unused_tuple)\n{\n\tif (!spec || !unused_tuple)\n\t\treturn -EINVAL;\n\n\t*unused_tuple |= BIT(INNER_SRC_MAC) | BIT(INNER_DST_MAC) |\n\t\t\tBIT(INNER_SRC_PORT) | BIT(INNER_DST_PORT);\n\n\t \n\tif (ipv6_addr_any((struct in6_addr *)spec->ip6src))\n\t\t*unused_tuple |= BIT(INNER_SRC_IP);\n\n\tif (ipv6_addr_any((struct in6_addr *)spec->ip6dst))\n\t\t*unused_tuple |= BIT(INNER_DST_IP);\n\n\tif (!spec->l4_proto)\n\t\t*unused_tuple |= BIT(INNER_IP_PROTO);\n\n\tif (!spec->tclass)\n\t\t*unused_tuple |= BIT(INNER_IP_TOS);\n\n\tif (spec->l4_4_bytes)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int hclge_fd_check_ether_tuple(struct ethhdr *spec, u32 *unused_tuple)\n{\n\tif (!spec || !unused_tuple)\n\t\treturn -EINVAL;\n\n\t*unused_tuple |= BIT(INNER_SRC_IP) | BIT(INNER_DST_IP) |\n\t\tBIT(INNER_SRC_PORT) | BIT(INNER_DST_PORT) |\n\t\tBIT(INNER_IP_TOS) | BIT(INNER_IP_PROTO);\n\n\tif (is_zero_ether_addr(spec->h_source))\n\t\t*unused_tuple |= BIT(INNER_SRC_MAC);\n\n\tif (is_zero_ether_addr(spec->h_dest))\n\t\t*unused_tuple |= BIT(INNER_DST_MAC);\n\n\tif (!spec->h_proto)\n\t\t*unused_tuple |= BIT(INNER_ETH_TYPE);\n\n\treturn 0;\n}\n\nstatic int hclge_fd_check_ext_tuple(struct hclge_dev *hdev,\n\t\t\t\t    struct ethtool_rx_flow_spec *fs,\n\t\t\t\t    u32 *unused_tuple)\n{\n\tif (fs->flow_type & FLOW_EXT) {\n\t\tif (fs->h_ext.vlan_etype) {\n\t\t\tdev_err(&hdev->pdev->dev, \"vlan-etype is not supported!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!fs->h_ext.vlan_tci)\n\t\t\t*unused_tuple |= BIT(INNER_VLAN_TAG_FST);\n\n\t\tif (fs->m_ext.vlan_tci &&\n\t\t    be16_to_cpu(fs->h_ext.vlan_tci) >= VLAN_N_VID) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to config vlan_tci, invalid vlan_tci: %u, max is %d.\\n\",\n\t\t\t\tntohs(fs->h_ext.vlan_tci), VLAN_N_VID - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t*unused_tuple |= BIT(INNER_VLAN_TAG_FST);\n\t}\n\n\tif (fs->flow_type & FLOW_MAC_EXT) {\n\t\tif (hdev->fd_cfg.fd_mode !=\n\t\t    HCLGE_FD_MODE_DEPTH_2K_WIDTH_400B_STAGE_1) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"FLOW_MAC_EXT is not supported in current fd mode!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (is_zero_ether_addr(fs->h_ext.h_dest))\n\t\t\t*unused_tuple |= BIT(INNER_DST_MAC);\n\t\telse\n\t\t\t*unused_tuple &= ~BIT(INNER_DST_MAC);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_fd_get_user_def_layer(u32 flow_type, u32 *unused_tuple,\n\t\t\t\t       struct hclge_fd_user_def_info *info)\n{\n\tswitch (flow_type) {\n\tcase ETHER_FLOW:\n\t\tinfo->layer = HCLGE_FD_USER_DEF_L2;\n\t\t*unused_tuple &= ~BIT(INNER_L2_RSV);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\tcase IPV6_USER_FLOW:\n\t\tinfo->layer = HCLGE_FD_USER_DEF_L3;\n\t\t*unused_tuple &= ~BIT(INNER_L3_RSV);\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tinfo->layer = HCLGE_FD_USER_DEF_L4;\n\t\t*unused_tuple &= ~BIT(INNER_L4_RSV);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool hclge_fd_is_user_def_all_masked(struct ethtool_rx_flow_spec *fs)\n{\n\treturn be32_to_cpu(fs->m_ext.data[1] | fs->m_ext.data[0]) == 0;\n}\n\nstatic int hclge_fd_parse_user_def_field(struct hclge_dev *hdev,\n\t\t\t\t\t struct ethtool_rx_flow_spec *fs,\n\t\t\t\t\t u32 *unused_tuple,\n\t\t\t\t\t struct hclge_fd_user_def_info *info)\n{\n\tu32 tuple_active = hdev->fd_cfg.key_cfg[HCLGE_FD_STAGE_1].tuple_active;\n\tu32 flow_type = fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT);\n\tu16 data, offset, data_mask, offset_mask;\n\tint ret;\n\n\tinfo->layer = HCLGE_FD_USER_DEF_NONE;\n\t*unused_tuple |= HCLGE_FD_TUPLE_USER_DEF_TUPLES;\n\n\tif (!(fs->flow_type & FLOW_EXT) || hclge_fd_is_user_def_all_masked(fs))\n\t\treturn 0;\n\n\t \n\tdata = be32_to_cpu(fs->h_ext.data[1]) & HCLGE_FD_USER_DEF_DATA;\n\tdata_mask = be32_to_cpu(fs->m_ext.data[1]) & HCLGE_FD_USER_DEF_DATA;\n\toffset = be32_to_cpu(fs->h_ext.data[0]) & HCLGE_FD_USER_DEF_OFFSET;\n\toffset_mask = be32_to_cpu(fs->m_ext.data[0]) & HCLGE_FD_USER_DEF_OFFSET;\n\n\tif (!(tuple_active & HCLGE_FD_TUPLE_USER_DEF_TUPLES)) {\n\t\tdev_err(&hdev->pdev->dev, \"user-def bytes are not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (offset > HCLGE_FD_MAX_USER_DEF_OFFSET) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"user-def offset[%u] should be no more than %u\\n\",\n\t\t\toffset, HCLGE_FD_MAX_USER_DEF_OFFSET);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset_mask != HCLGE_FD_USER_DEF_OFFSET_UNMASK) {\n\t\tdev_err(&hdev->pdev->dev, \"user-def offset can't be masked\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = hclge_fd_get_user_def_layer(flow_type, unused_tuple, info);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"unsupported flow type for user-def bytes, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tinfo->data = data;\n\tinfo->data_mask = data_mask;\n\tinfo->offset = offset;\n\n\treturn 0;\n}\n\nstatic int hclge_fd_check_spec(struct hclge_dev *hdev,\n\t\t\t       struct ethtool_rx_flow_spec *fs,\n\t\t\t       u32 *unused_tuple,\n\t\t\t       struct hclge_fd_user_def_info *info)\n{\n\tu32 flow_type;\n\tint ret;\n\n\tif (fs->location >= hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to config fd rules, invalid rule location: %u, max is %u\\n.\",\n\t\t\tfs->location,\n\t\t\thdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1] - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = hclge_fd_parse_user_def_field(hdev, fs, unused_tuple, info);\n\tif (ret)\n\t\treturn ret;\n\n\tflow_type = fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT);\n\tswitch (flow_type) {\n\tcase SCTP_V4_FLOW:\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\tret = hclge_fd_check_tcpip4_tuple(&fs->h_u.tcp_ip4_spec,\n\t\t\t\t\t\t  unused_tuple);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tret = hclge_fd_check_ip4_tuple(&fs->h_u.usr_ip4_spec,\n\t\t\t\t\t       unused_tuple);\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tret = hclge_fd_check_tcpip6_tuple(&fs->h_u.tcp_ip6_spec,\n\t\t\t\t\t\t  unused_tuple);\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tret = hclge_fd_check_ip6_tuple(&fs->h_u.usr_ip6_spec,\n\t\t\t\t\t       unused_tuple);\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\tif (hdev->fd_cfg.fd_mode !=\n\t\t\tHCLGE_FD_MODE_DEPTH_2K_WIDTH_400B_STAGE_1) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"ETHER_FLOW is not supported in current fd mode!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tret = hclge_fd_check_ether_tuple(&fs->h_u.ether_spec,\n\t\t\t\t\t\t unused_tuple);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"unsupported protocol type, protocol type = %#x\\n\",\n\t\t\tflow_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to check flow union tuple, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn hclge_fd_check_ext_tuple(hdev, fs, unused_tuple);\n}\n\nstatic void hclge_fd_get_tcpip4_tuple(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t      struct hclge_fd_rule *rule, u8 ip_proto)\n{\n\trule->tuples.src_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->h_u.tcp_ip4_spec.ip4src);\n\trule->tuples_mask.src_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->m_u.tcp_ip4_spec.ip4src);\n\n\trule->tuples.dst_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->h_u.tcp_ip4_spec.ip4dst);\n\trule->tuples_mask.dst_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->m_u.tcp_ip4_spec.ip4dst);\n\n\trule->tuples.src_port = be16_to_cpu(fs->h_u.tcp_ip4_spec.psrc);\n\trule->tuples_mask.src_port = be16_to_cpu(fs->m_u.tcp_ip4_spec.psrc);\n\n\trule->tuples.dst_port = be16_to_cpu(fs->h_u.tcp_ip4_spec.pdst);\n\trule->tuples_mask.dst_port = be16_to_cpu(fs->m_u.tcp_ip4_spec.pdst);\n\n\trule->tuples.ip_tos = fs->h_u.tcp_ip4_spec.tos;\n\trule->tuples_mask.ip_tos = fs->m_u.tcp_ip4_spec.tos;\n\n\trule->tuples.ether_proto = ETH_P_IP;\n\trule->tuples_mask.ether_proto = 0xFFFF;\n\n\trule->tuples.ip_proto = ip_proto;\n\trule->tuples_mask.ip_proto = 0xFF;\n}\n\nstatic void hclge_fd_get_ip4_tuple(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t   struct hclge_fd_rule *rule)\n{\n\trule->tuples.src_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->h_u.usr_ip4_spec.ip4src);\n\trule->tuples_mask.src_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->m_u.usr_ip4_spec.ip4src);\n\n\trule->tuples.dst_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->h_u.usr_ip4_spec.ip4dst);\n\trule->tuples_mask.dst_ip[IPV4_INDEX] =\n\t\t\tbe32_to_cpu(fs->m_u.usr_ip4_spec.ip4dst);\n\n\trule->tuples.ip_tos = fs->h_u.usr_ip4_spec.tos;\n\trule->tuples_mask.ip_tos = fs->m_u.usr_ip4_spec.tos;\n\n\trule->tuples.ip_proto = fs->h_u.usr_ip4_spec.proto;\n\trule->tuples_mask.ip_proto = fs->m_u.usr_ip4_spec.proto;\n\n\trule->tuples.ether_proto = ETH_P_IP;\n\trule->tuples_mask.ether_proto = 0xFFFF;\n}\n\nstatic void hclge_fd_get_tcpip6_tuple(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t      struct hclge_fd_rule *rule, u8 ip_proto)\n{\n\tbe32_to_cpu_array(rule->tuples.src_ip, fs->h_u.tcp_ip6_spec.ip6src,\n\t\t\t  IPV6_SIZE);\n\tbe32_to_cpu_array(rule->tuples_mask.src_ip, fs->m_u.tcp_ip6_spec.ip6src,\n\t\t\t  IPV6_SIZE);\n\n\tbe32_to_cpu_array(rule->tuples.dst_ip, fs->h_u.tcp_ip6_spec.ip6dst,\n\t\t\t  IPV6_SIZE);\n\tbe32_to_cpu_array(rule->tuples_mask.dst_ip, fs->m_u.tcp_ip6_spec.ip6dst,\n\t\t\t  IPV6_SIZE);\n\n\trule->tuples.src_port = be16_to_cpu(fs->h_u.tcp_ip6_spec.psrc);\n\trule->tuples_mask.src_port = be16_to_cpu(fs->m_u.tcp_ip6_spec.psrc);\n\n\trule->tuples.dst_port = be16_to_cpu(fs->h_u.tcp_ip6_spec.pdst);\n\trule->tuples_mask.dst_port = be16_to_cpu(fs->m_u.tcp_ip6_spec.pdst);\n\n\trule->tuples.ether_proto = ETH_P_IPV6;\n\trule->tuples_mask.ether_proto = 0xFFFF;\n\n\trule->tuples.ip_tos = fs->h_u.tcp_ip6_spec.tclass;\n\trule->tuples_mask.ip_tos = fs->m_u.tcp_ip6_spec.tclass;\n\n\trule->tuples.ip_proto = ip_proto;\n\trule->tuples_mask.ip_proto = 0xFF;\n}\n\nstatic void hclge_fd_get_ip6_tuple(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t   struct hclge_fd_rule *rule)\n{\n\tbe32_to_cpu_array(rule->tuples.src_ip, fs->h_u.usr_ip6_spec.ip6src,\n\t\t\t  IPV6_SIZE);\n\tbe32_to_cpu_array(rule->tuples_mask.src_ip, fs->m_u.usr_ip6_spec.ip6src,\n\t\t\t  IPV6_SIZE);\n\n\tbe32_to_cpu_array(rule->tuples.dst_ip, fs->h_u.usr_ip6_spec.ip6dst,\n\t\t\t  IPV6_SIZE);\n\tbe32_to_cpu_array(rule->tuples_mask.dst_ip, fs->m_u.usr_ip6_spec.ip6dst,\n\t\t\t  IPV6_SIZE);\n\n\trule->tuples.ip_proto = fs->h_u.usr_ip6_spec.l4_proto;\n\trule->tuples_mask.ip_proto = fs->m_u.usr_ip6_spec.l4_proto;\n\n\trule->tuples.ip_tos = fs->h_u.tcp_ip6_spec.tclass;\n\trule->tuples_mask.ip_tos = fs->m_u.tcp_ip6_spec.tclass;\n\n\trule->tuples.ether_proto = ETH_P_IPV6;\n\trule->tuples_mask.ether_proto = 0xFFFF;\n}\n\nstatic void hclge_fd_get_ether_tuple(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t     struct hclge_fd_rule *rule)\n{\n\tether_addr_copy(rule->tuples.src_mac, fs->h_u.ether_spec.h_source);\n\tether_addr_copy(rule->tuples_mask.src_mac, fs->m_u.ether_spec.h_source);\n\n\tether_addr_copy(rule->tuples.dst_mac, fs->h_u.ether_spec.h_dest);\n\tether_addr_copy(rule->tuples_mask.dst_mac, fs->m_u.ether_spec.h_dest);\n\n\trule->tuples.ether_proto = be16_to_cpu(fs->h_u.ether_spec.h_proto);\n\trule->tuples_mask.ether_proto = be16_to_cpu(fs->m_u.ether_spec.h_proto);\n}\n\nstatic void hclge_fd_get_user_def_tuple(struct hclge_fd_user_def_info *info,\n\t\t\t\t\tstruct hclge_fd_rule *rule)\n{\n\tswitch (info->layer) {\n\tcase HCLGE_FD_USER_DEF_L2:\n\t\trule->tuples.l2_user_def = info->data;\n\t\trule->tuples_mask.l2_user_def = info->data_mask;\n\t\tbreak;\n\tcase HCLGE_FD_USER_DEF_L3:\n\t\trule->tuples.l3_user_def = info->data;\n\t\trule->tuples_mask.l3_user_def = info->data_mask;\n\t\tbreak;\n\tcase HCLGE_FD_USER_DEF_L4:\n\t\trule->tuples.l4_user_def = (u32)info->data << 16;\n\t\trule->tuples_mask.l4_user_def = (u32)info->data_mask << 16;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trule->ep.user_def = *info;\n}\n\nstatic int hclge_fd_get_tuple(struct ethtool_rx_flow_spec *fs,\n\t\t\t      struct hclge_fd_rule *rule,\n\t\t\t      struct hclge_fd_user_def_info *info)\n{\n\tu32 flow_type = fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT);\n\n\tswitch (flow_type) {\n\tcase SCTP_V4_FLOW:\n\t\thclge_fd_get_tcpip4_tuple(fs, rule, IPPROTO_SCTP);\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\t\thclge_fd_get_tcpip4_tuple(fs, rule, IPPROTO_TCP);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\thclge_fd_get_tcpip4_tuple(fs, rule, IPPROTO_UDP);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\thclge_fd_get_ip4_tuple(fs, rule);\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\thclge_fd_get_tcpip6_tuple(fs, rule, IPPROTO_SCTP);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\thclge_fd_get_tcpip6_tuple(fs, rule, IPPROTO_TCP);\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\thclge_fd_get_tcpip6_tuple(fs, rule, IPPROTO_UDP);\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\thclge_fd_get_ip6_tuple(fs, rule);\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\thclge_fd_get_ether_tuple(fs, rule);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (fs->flow_type & FLOW_EXT) {\n\t\trule->tuples.vlan_tag1 = be16_to_cpu(fs->h_ext.vlan_tci);\n\t\trule->tuples_mask.vlan_tag1 = be16_to_cpu(fs->m_ext.vlan_tci);\n\t\thclge_fd_get_user_def_tuple(info, rule);\n\t}\n\n\tif (fs->flow_type & FLOW_MAC_EXT) {\n\t\tether_addr_copy(rule->tuples.dst_mac, fs->h_ext.h_dest);\n\t\tether_addr_copy(rule->tuples_mask.dst_mac, fs->m_ext.h_dest);\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_fd_config_rule(struct hclge_dev *hdev,\n\t\t\t\tstruct hclge_fd_rule *rule)\n{\n\tint ret;\n\n\tret = hclge_config_action(hdev, HCLGE_FD_STAGE_1, rule);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_config_key(hdev, HCLGE_FD_STAGE_1, rule);\n}\n\nstatic int hclge_add_fd_entry_common(struct hclge_dev *hdev,\n\t\t\t\t     struct hclge_fd_rule *rule)\n{\n\tint ret;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\n\tif (hdev->fd_active_type != rule->rule_type &&\n\t    (hdev->fd_active_type == HCLGE_FD_TC_FLOWER_ACTIVE ||\n\t     hdev->fd_active_type == HCLGE_FD_EP_ACTIVE)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mode conflict(new type %d, active type %d), please delete existent rules first\\n\",\n\t\t\trule->rule_type, hdev->fd_active_type);\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tret = hclge_fd_check_user_def_refcnt(hdev, rule);\n\tif (ret)\n\t\tgoto out;\n\n\tret = hclge_clear_arfs_rules(hdev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = hclge_fd_config_rule(hdev, rule);\n\tif (ret)\n\t\tgoto out;\n\n\trule->state = HCLGE_FD_ACTIVE;\n\thdev->fd_active_type = rule->rule_type;\n\thclge_update_fd_list(hdev, rule->state, rule->location, rule);\n\nout:\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\treturn ret;\n}\n\nstatic bool hclge_is_cls_flower_active(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn hdev->fd_active_type == HCLGE_FD_TC_FLOWER_ACTIVE;\n}\n\nstatic int hclge_fd_parse_ring_cookie(struct hclge_dev *hdev, u64 ring_cookie,\n\t\t\t\t      u16 *vport_id, u8 *action, u16 *queue_id)\n{\n\tstruct hclge_vport *vport = hdev->vport;\n\n\tif (ring_cookie == RX_CLS_FLOW_DISC) {\n\t\t*action = HCLGE_FD_ACTION_DROP_PACKET;\n\t} else {\n\t\tu32 ring = ethtool_get_flow_spec_ring(ring_cookie);\n\t\tu8 vf = ethtool_get_flow_spec_ring_vf(ring_cookie);\n\t\tu16 tqps;\n\n\t\t \n\t\tif (vf > hdev->num_req_vfs) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"Error: vf id (%u) should be less than %u\\n\",\n\t\t\t\tvf - 1U, hdev->num_req_vfs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*vport_id = vf ? hdev->vport[vf].vport_id : vport->vport_id;\n\t\ttqps = hdev->vport[vf].nic.kinfo.num_tqps;\n\n\t\tif (ring >= tqps) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"Error: queue id (%u) > max tqp num (%u)\\n\",\n\t\t\t\tring, tqps - 1U);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*action = HCLGE_FD_ACTION_SELECT_QUEUE;\n\t\t*queue_id = ring;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_add_fd_entry(struct hnae3_handle *handle,\n\t\t\t      struct ethtool_rxnfc *cmd)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_fd_user_def_info info;\n\tu16 dst_vport_id = 0, q_index = 0;\n\tstruct ethtool_rx_flow_spec *fs;\n\tstruct hclge_fd_rule *rule;\n\tu32 unused = 0;\n\tu8 action;\n\tint ret;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"flow table director is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!hdev->fd_en) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"please enable flow director first\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfs = (struct ethtool_rx_flow_spec *)&cmd->fs;\n\n\tret = hclge_fd_check_spec(hdev, fs, &unused, &info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_fd_parse_ring_cookie(hdev, fs->ring_cookie, &dst_vport_id,\n\t\t\t\t\t &action, &q_index);\n\tif (ret)\n\t\treturn ret;\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn -ENOMEM;\n\n\tret = hclge_fd_get_tuple(fs, rule, &info);\n\tif (ret) {\n\t\tkfree(rule);\n\t\treturn ret;\n\t}\n\n\trule->flow_type = fs->flow_type;\n\trule->location = fs->location;\n\trule->unused_tuple = unused;\n\trule->vf_id = dst_vport_id;\n\trule->queue_id = q_index;\n\trule->action = action;\n\trule->rule_type = HCLGE_FD_EP_ACTIVE;\n\n\tret = hclge_add_fd_entry_common(hdev, rule);\n\tif (ret)\n\t\tkfree(rule);\n\n\treturn ret;\n}\n\nstatic int hclge_del_fd_entry(struct hnae3_handle *handle,\n\t\t\t      struct ethtool_rxnfc *cmd)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct ethtool_rx_flow_spec *fs;\n\tint ret;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tfs = (struct ethtool_rx_flow_spec *)&cmd->fs;\n\n\tif (fs->location >= hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1])\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\tif (hdev->fd_active_type == HCLGE_FD_TC_FLOWER_ACTIVE ||\n\t    !test_bit(fs->location, hdev->fd_bmap)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Delete fail, rule %u is inexistent\\n\", fs->location);\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true, fs->location,\n\t\t\t\t   NULL, false);\n\tif (ret)\n\t\tgoto out;\n\n\thclge_update_fd_list(hdev, HCLGE_FD_DELETED, fs->location, NULL);\n\nout:\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\treturn ret;\n}\n\nstatic void hclge_clear_fd_rules_in_list(struct hclge_dev *hdev,\n\t\t\t\t\t bool clear_list)\n{\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\tu16 location;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\n\tfor_each_set_bit(location, hdev->fd_bmap,\n\t\t\t hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1])\n\t\thclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true, location,\n\t\t\t\t     NULL, false);\n\n\tif (clear_list) {\n\t\thlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list,\n\t\t\t\t\t  rule_node) {\n\t\t\thlist_del(&rule->rule_node);\n\t\t\tkfree(rule);\n\t\t}\n\t\thdev->fd_active_type = HCLGE_FD_RULE_NONE;\n\t\thdev->hclge_fd_rule_num = 0;\n\t\tbitmap_zero(hdev->fd_bmap,\n\t\t\t    hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]);\n\t}\n\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n}\n\nstatic void hclge_del_all_fd_entries(struct hclge_dev *hdev)\n{\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn;\n\n\thclge_clear_fd_rules_in_list(hdev, true);\n\thclge_fd_disable_user_def(hdev);\n}\n\nstatic int hclge_restore_fd_entries(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\n\t \n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn 0;\n\n\t \n\tif (!hdev->fd_en)\n\t\treturn 0;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\thlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {\n\t\tif (rule->state == HCLGE_FD_ACTIVE)\n\t\t\trule->state = HCLGE_FD_TO_ADD;\n\t}\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\tset_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);\n\n\treturn 0;\n}\n\nstatic int hclge_get_fd_rule_cnt(struct hnae3_handle *handle,\n\t\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev) || hclge_is_cls_flower_active(handle))\n\t\treturn -EOPNOTSUPP;\n\n\tcmd->rule_cnt = hdev->hclge_fd_rule_num;\n\tcmd->data = hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1];\n\n\treturn 0;\n}\n\nstatic void hclge_fd_get_tcpip4_info(struct hclge_fd_rule *rule,\n\t\t\t\t     struct ethtool_tcpip4_spec *spec,\n\t\t\t\t     struct ethtool_tcpip4_spec *spec_mask)\n{\n\tspec->ip4src = cpu_to_be32(rule->tuples.src_ip[IPV4_INDEX]);\n\tspec_mask->ip4src = rule->unused_tuple & BIT(INNER_SRC_IP) ?\n\t\t\t0 : cpu_to_be32(rule->tuples_mask.src_ip[IPV4_INDEX]);\n\n\tspec->ip4dst = cpu_to_be32(rule->tuples.dst_ip[IPV4_INDEX]);\n\tspec_mask->ip4dst = rule->unused_tuple & BIT(INNER_DST_IP) ?\n\t\t\t0 : cpu_to_be32(rule->tuples_mask.dst_ip[IPV4_INDEX]);\n\n\tspec->psrc = cpu_to_be16(rule->tuples.src_port);\n\tspec_mask->psrc = rule->unused_tuple & BIT(INNER_SRC_PORT) ?\n\t\t\t0 : cpu_to_be16(rule->tuples_mask.src_port);\n\n\tspec->pdst = cpu_to_be16(rule->tuples.dst_port);\n\tspec_mask->pdst = rule->unused_tuple & BIT(INNER_DST_PORT) ?\n\t\t\t0 : cpu_to_be16(rule->tuples_mask.dst_port);\n\n\tspec->tos = rule->tuples.ip_tos;\n\tspec_mask->tos = rule->unused_tuple & BIT(INNER_IP_TOS) ?\n\t\t\t0 : rule->tuples_mask.ip_tos;\n}\n\nstatic void hclge_fd_get_ip4_info(struct hclge_fd_rule *rule,\n\t\t\t\t  struct ethtool_usrip4_spec *spec,\n\t\t\t\t  struct ethtool_usrip4_spec *spec_mask)\n{\n\tspec->ip4src = cpu_to_be32(rule->tuples.src_ip[IPV4_INDEX]);\n\tspec_mask->ip4src = rule->unused_tuple & BIT(INNER_SRC_IP) ?\n\t\t\t0 : cpu_to_be32(rule->tuples_mask.src_ip[IPV4_INDEX]);\n\n\tspec->ip4dst = cpu_to_be32(rule->tuples.dst_ip[IPV4_INDEX]);\n\tspec_mask->ip4dst = rule->unused_tuple & BIT(INNER_DST_IP) ?\n\t\t\t0 : cpu_to_be32(rule->tuples_mask.dst_ip[IPV4_INDEX]);\n\n\tspec->tos = rule->tuples.ip_tos;\n\tspec_mask->tos = rule->unused_tuple & BIT(INNER_IP_TOS) ?\n\t\t\t0 : rule->tuples_mask.ip_tos;\n\n\tspec->proto = rule->tuples.ip_proto;\n\tspec_mask->proto = rule->unused_tuple & BIT(INNER_IP_PROTO) ?\n\t\t\t0 : rule->tuples_mask.ip_proto;\n\n\tspec->ip_ver = ETH_RX_NFC_IP4;\n}\n\nstatic void hclge_fd_get_tcpip6_info(struct hclge_fd_rule *rule,\n\t\t\t\t     struct ethtool_tcpip6_spec *spec,\n\t\t\t\t     struct ethtool_tcpip6_spec *spec_mask)\n{\n\tcpu_to_be32_array(spec->ip6src,\n\t\t\t  rule->tuples.src_ip, IPV6_SIZE);\n\tcpu_to_be32_array(spec->ip6dst,\n\t\t\t  rule->tuples.dst_ip, IPV6_SIZE);\n\tif (rule->unused_tuple & BIT(INNER_SRC_IP))\n\t\tmemset(spec_mask->ip6src, 0, sizeof(spec_mask->ip6src));\n\telse\n\t\tcpu_to_be32_array(spec_mask->ip6src, rule->tuples_mask.src_ip,\n\t\t\t\t  IPV6_SIZE);\n\n\tif (rule->unused_tuple & BIT(INNER_DST_IP))\n\t\tmemset(spec_mask->ip6dst, 0, sizeof(spec_mask->ip6dst));\n\telse\n\t\tcpu_to_be32_array(spec_mask->ip6dst, rule->tuples_mask.dst_ip,\n\t\t\t\t  IPV6_SIZE);\n\n\tspec->tclass = rule->tuples.ip_tos;\n\tspec_mask->tclass = rule->unused_tuple & BIT(INNER_IP_TOS) ?\n\t\t\t0 : rule->tuples_mask.ip_tos;\n\n\tspec->psrc = cpu_to_be16(rule->tuples.src_port);\n\tspec_mask->psrc = rule->unused_tuple & BIT(INNER_SRC_PORT) ?\n\t\t\t0 : cpu_to_be16(rule->tuples_mask.src_port);\n\n\tspec->pdst = cpu_to_be16(rule->tuples.dst_port);\n\tspec_mask->pdst = rule->unused_tuple & BIT(INNER_DST_PORT) ?\n\t\t\t0 : cpu_to_be16(rule->tuples_mask.dst_port);\n}\n\nstatic void hclge_fd_get_ip6_info(struct hclge_fd_rule *rule,\n\t\t\t\t  struct ethtool_usrip6_spec *spec,\n\t\t\t\t  struct ethtool_usrip6_spec *spec_mask)\n{\n\tcpu_to_be32_array(spec->ip6src, rule->tuples.src_ip, IPV6_SIZE);\n\tcpu_to_be32_array(spec->ip6dst, rule->tuples.dst_ip, IPV6_SIZE);\n\tif (rule->unused_tuple & BIT(INNER_SRC_IP))\n\t\tmemset(spec_mask->ip6src, 0, sizeof(spec_mask->ip6src));\n\telse\n\t\tcpu_to_be32_array(spec_mask->ip6src,\n\t\t\t\t  rule->tuples_mask.src_ip, IPV6_SIZE);\n\n\tif (rule->unused_tuple & BIT(INNER_DST_IP))\n\t\tmemset(spec_mask->ip6dst, 0, sizeof(spec_mask->ip6dst));\n\telse\n\t\tcpu_to_be32_array(spec_mask->ip6dst,\n\t\t\t\t  rule->tuples_mask.dst_ip, IPV6_SIZE);\n\n\tspec->tclass = rule->tuples.ip_tos;\n\tspec_mask->tclass = rule->unused_tuple & BIT(INNER_IP_TOS) ?\n\t\t\t0 : rule->tuples_mask.ip_tos;\n\n\tspec->l4_proto = rule->tuples.ip_proto;\n\tspec_mask->l4_proto = rule->unused_tuple & BIT(INNER_IP_PROTO) ?\n\t\t\t0 : rule->tuples_mask.ip_proto;\n}\n\nstatic void hclge_fd_get_ether_info(struct hclge_fd_rule *rule,\n\t\t\t\t    struct ethhdr *spec,\n\t\t\t\t    struct ethhdr *spec_mask)\n{\n\tether_addr_copy(spec->h_source, rule->tuples.src_mac);\n\tether_addr_copy(spec->h_dest, rule->tuples.dst_mac);\n\n\tif (rule->unused_tuple & BIT(INNER_SRC_MAC))\n\t\teth_zero_addr(spec_mask->h_source);\n\telse\n\t\tether_addr_copy(spec_mask->h_source, rule->tuples_mask.src_mac);\n\n\tif (rule->unused_tuple & BIT(INNER_DST_MAC))\n\t\teth_zero_addr(spec_mask->h_dest);\n\telse\n\t\tether_addr_copy(spec_mask->h_dest, rule->tuples_mask.dst_mac);\n\n\tspec->h_proto = cpu_to_be16(rule->tuples.ether_proto);\n\tspec_mask->h_proto = rule->unused_tuple & BIT(INNER_ETH_TYPE) ?\n\t\t\t0 : cpu_to_be16(rule->tuples_mask.ether_proto);\n}\n\nstatic void hclge_fd_get_user_def_info(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t       struct hclge_fd_rule *rule)\n{\n\tif ((rule->unused_tuple & HCLGE_FD_TUPLE_USER_DEF_TUPLES) ==\n\t    HCLGE_FD_TUPLE_USER_DEF_TUPLES) {\n\t\tfs->h_ext.data[0] = 0;\n\t\tfs->h_ext.data[1] = 0;\n\t\tfs->m_ext.data[0] = 0;\n\t\tfs->m_ext.data[1] = 0;\n\t} else {\n\t\tfs->h_ext.data[0] = cpu_to_be32(rule->ep.user_def.offset);\n\t\tfs->h_ext.data[1] = cpu_to_be32(rule->ep.user_def.data);\n\t\tfs->m_ext.data[0] =\n\t\t\t\tcpu_to_be32(HCLGE_FD_USER_DEF_OFFSET_UNMASK);\n\t\tfs->m_ext.data[1] = cpu_to_be32(rule->ep.user_def.data_mask);\n\t}\n}\n\nstatic void hclge_fd_get_ext_info(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t  struct hclge_fd_rule *rule)\n{\n\tif (fs->flow_type & FLOW_EXT) {\n\t\tfs->h_ext.vlan_tci = cpu_to_be16(rule->tuples.vlan_tag1);\n\t\tfs->m_ext.vlan_tci =\n\t\t\t\trule->unused_tuple & BIT(INNER_VLAN_TAG_FST) ?\n\t\t\t\t0 : cpu_to_be16(rule->tuples_mask.vlan_tag1);\n\n\t\thclge_fd_get_user_def_info(fs, rule);\n\t}\n\n\tif (fs->flow_type & FLOW_MAC_EXT) {\n\t\tether_addr_copy(fs->h_ext.h_dest, rule->tuples.dst_mac);\n\t\tif (rule->unused_tuple & BIT(INNER_DST_MAC))\n\t\t\teth_zero_addr(fs->m_u.ether_spec.h_dest);\n\t\telse\n\t\t\tether_addr_copy(fs->m_u.ether_spec.h_dest,\n\t\t\t\t\trule->tuples_mask.dst_mac);\n\t}\n}\n\nstatic struct hclge_fd_rule *hclge_get_fd_rule(struct hclge_dev *hdev,\n\t\t\t\t\t       u16 location)\n{\n\tstruct hclge_fd_rule *rule = NULL;\n\tstruct hlist_node *node2;\n\n\thlist_for_each_entry_safe(rule, node2, &hdev->fd_rule_list, rule_node) {\n\t\tif (rule->location == location)\n\t\t\treturn rule;\n\t\telse if (rule->location > location)\n\t\t\treturn NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hclge_fd_get_ring_cookie(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t     struct hclge_fd_rule *rule)\n{\n\tif (rule->action == HCLGE_FD_ACTION_DROP_PACKET) {\n\t\tfs->ring_cookie = RX_CLS_FLOW_DISC;\n\t} else {\n\t\tu64 vf_id;\n\n\t\tfs->ring_cookie = rule->queue_id;\n\t\tvf_id = rule->vf_id;\n\t\tvf_id <<= ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;\n\t\tfs->ring_cookie |= vf_id;\n\t}\n}\n\nstatic int hclge_get_fd_rule_info(struct hnae3_handle *handle,\n\t\t\t\t  struct ethtool_rxnfc *cmd)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_fd_rule *rule = NULL;\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct ethtool_rx_flow_spec *fs;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tfs = (struct ethtool_rx_flow_spec *)&cmd->fs;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\n\trule = hclge_get_fd_rule(hdev, fs->location);\n\tif (!rule) {\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tfs->flow_type = rule->flow_type;\n\tswitch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {\n\tcase SCTP_V4_FLOW:\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\thclge_fd_get_tcpip4_info(rule, &fs->h_u.tcp_ip4_spec,\n\t\t\t\t\t &fs->m_u.tcp_ip4_spec);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\thclge_fd_get_ip4_info(rule, &fs->h_u.usr_ip4_spec,\n\t\t\t\t      &fs->m_u.usr_ip4_spec);\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\thclge_fd_get_tcpip6_info(rule, &fs->h_u.tcp_ip6_spec,\n\t\t\t\t\t &fs->m_u.tcp_ip6_spec);\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\thclge_fd_get_ip6_info(rule, &fs->h_u.usr_ip6_spec,\n\t\t\t\t      &fs->m_u.usr_ip6_spec);\n\t\tbreak;\n\t \n\tdefault:\n\t\thclge_fd_get_ether_info(rule, &fs->h_u.ether_spec,\n\t\t\t\t\t&fs->m_u.ether_spec);\n\t\tbreak;\n\t}\n\n\thclge_fd_get_ext_info(fs, rule);\n\n\thclge_fd_get_ring_cookie(fs, rule);\n\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\n\treturn 0;\n}\n\nstatic int hclge_get_all_rules(struct hnae3_handle *handle,\n\t\t\t       struct ethtool_rxnfc *cmd, u32 *rule_locs)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node2;\n\tint cnt = 0;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tcmd->data = hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1];\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &hdev->fd_rule_list, rule_node) {\n\t\tif (cnt == cmd->rule_cnt) {\n\t\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (rule->state == HCLGE_FD_TO_DEL)\n\t\t\tcontinue;\n\n\t\trule_locs[cnt] = rule->location;\n\t\tcnt++;\n\t}\n\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\n\tcmd->rule_cnt = cnt;\n\n\treturn 0;\n}\n\nstatic void hclge_fd_get_flow_tuples(const struct flow_keys *fkeys,\n\t\t\t\t     struct hclge_fd_rule_tuples *tuples)\n{\n#define flow_ip6_src fkeys->addrs.v6addrs.src.in6_u.u6_addr32\n#define flow_ip6_dst fkeys->addrs.v6addrs.dst.in6_u.u6_addr32\n\n\ttuples->ether_proto = be16_to_cpu(fkeys->basic.n_proto);\n\ttuples->ip_proto = fkeys->basic.ip_proto;\n\ttuples->dst_port = be16_to_cpu(fkeys->ports.dst);\n\n\tif (fkeys->basic.n_proto == htons(ETH_P_IP)) {\n\t\ttuples->src_ip[3] = be32_to_cpu(fkeys->addrs.v4addrs.src);\n\t\ttuples->dst_ip[3] = be32_to_cpu(fkeys->addrs.v4addrs.dst);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < IPV6_SIZE; i++) {\n\t\t\ttuples->src_ip[i] = be32_to_cpu(flow_ip6_src[i]);\n\t\t\ttuples->dst_ip[i] = be32_to_cpu(flow_ip6_dst[i]);\n\t\t}\n\t}\n}\n\n \nstatic struct hclge_fd_rule *\nhclge_fd_search_flow_keys(struct hclge_dev *hdev,\n\t\t\t  const struct hclge_fd_rule_tuples *tuples)\n{\n\tstruct hclge_fd_rule *rule = NULL;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {\n\t\tif (!memcmp(tuples, &rule->tuples, sizeof(*tuples)))\n\t\t\treturn rule;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hclge_fd_build_arfs_rule(const struct hclge_fd_rule_tuples *tuples,\n\t\t\t\t     struct hclge_fd_rule *rule)\n{\n\trule->unused_tuple = BIT(INNER_SRC_MAC) | BIT(INNER_DST_MAC) |\n\t\t\t     BIT(INNER_VLAN_TAG_FST) | BIT(INNER_IP_TOS) |\n\t\t\t     BIT(INNER_SRC_PORT);\n\trule->action = 0;\n\trule->vf_id = 0;\n\trule->rule_type = HCLGE_FD_ARFS_ACTIVE;\n\trule->state = HCLGE_FD_TO_ADD;\n\tif (tuples->ether_proto == ETH_P_IP) {\n\t\tif (tuples->ip_proto == IPPROTO_TCP)\n\t\t\trule->flow_type = TCP_V4_FLOW;\n\t\telse\n\t\t\trule->flow_type = UDP_V4_FLOW;\n\t} else {\n\t\tif (tuples->ip_proto == IPPROTO_TCP)\n\t\t\trule->flow_type = TCP_V6_FLOW;\n\t\telse\n\t\t\trule->flow_type = UDP_V6_FLOW;\n\t}\n\tmemcpy(&rule->tuples, tuples, sizeof(rule->tuples));\n\tmemset(&rule->tuples_mask, 0xFF, sizeof(rule->tuples_mask));\n}\n\nstatic int hclge_add_fd_entry_by_arfs(struct hnae3_handle *handle, u16 queue_id,\n\t\t\t\t      u16 flow_id, struct flow_keys *fkeys)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_fd_rule_tuples new_tuples = {};\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_fd_rule *rule;\n\tu16 bit_id;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tspin_lock_bh(&hdev->fd_rule_lock);\n\tif (hdev->fd_active_type != HCLGE_FD_ARFS_ACTIVE &&\n\t    hdev->fd_active_type != HCLGE_FD_RULE_NONE) {\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\thclge_fd_get_flow_tuples(fkeys, &new_tuples);\n\n\t \n\trule = hclge_fd_search_flow_keys(hdev, &new_tuples);\n\tif (!rule) {\n\t\tbit_id = find_first_zero_bit(hdev->fd_bmap, MAX_FD_FILTER_NUM);\n\t\tif (bit_id >= hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]) {\n\t\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\trule = kzalloc(sizeof(*rule), GFP_ATOMIC);\n\t\tif (!rule) {\n\t\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trule->location = bit_id;\n\t\trule->arfs.flow_id = flow_id;\n\t\trule->queue_id = queue_id;\n\t\thclge_fd_build_arfs_rule(&new_tuples, rule);\n\t\thclge_update_fd_list(hdev, rule->state, rule->location, rule);\n\t\thdev->fd_active_type = HCLGE_FD_ARFS_ACTIVE;\n\t} else if (rule->queue_id != queue_id) {\n\t\trule->queue_id = queue_id;\n\t\trule->state = HCLGE_FD_TO_ADD;\n\t\tset_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);\n\t\thclge_task_schedule(hdev, 0);\n\t}\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\treturn rule->location;\n}\n\nstatic void hclge_rfs_filter_expire(struct hclge_dev *hdev)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tstruct hnae3_handle *handle = &hdev->vport[0].nic;\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\tif (hdev->fd_active_type != HCLGE_FD_ARFS_ACTIVE) {\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\treturn;\n\t}\n\thlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {\n\t\tif (rule->state != HCLGE_FD_ACTIVE)\n\t\t\tcontinue;\n\t\tif (rps_may_expire_flow(handle->netdev, rule->queue_id,\n\t\t\t\t\trule->arfs.flow_id, rule->location)) {\n\t\t\trule->state = HCLGE_FD_TO_DEL;\n\t\t\tset_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);\n\t\t}\n\t}\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n#endif\n}\n\n \nstatic int hclge_clear_arfs_rules(struct hclge_dev *hdev)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\tint ret;\n\n\tif (hdev->fd_active_type != HCLGE_FD_ARFS_ACTIVE)\n\t\treturn 0;\n\n\thlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {\n\t\tswitch (rule->state) {\n\t\tcase HCLGE_FD_TO_DEL:\n\t\tcase HCLGE_FD_ACTIVE:\n\t\t\tret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true,\n\t\t\t\t\t\t   rule->location, NULL, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tfallthrough;\n\t\tcase HCLGE_FD_TO_ADD:\n\t\t\thclge_fd_dec_rule_cnt(hdev, rule->location);\n\t\t\thlist_del(&rule->rule_node);\n\t\t\tkfree(rule);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\thclge_sync_fd_state(hdev);\n\n#endif\n\treturn 0;\n}\n\nstatic void hclge_get_cls_key_basic(const struct flow_rule *flow,\n\t\t\t\t    struct hclge_fd_rule *rule)\n{\n\tif (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\t\tu16 ethtype_key, ethtype_mask;\n\n\t\tflow_rule_match_basic(flow, &match);\n\t\tethtype_key = ntohs(match.key->n_proto);\n\t\tethtype_mask = ntohs(match.mask->n_proto);\n\n\t\tif (ethtype_key == ETH_P_ALL) {\n\t\t\tethtype_key = 0;\n\t\t\tethtype_mask = 0;\n\t\t}\n\t\trule->tuples.ether_proto = ethtype_key;\n\t\trule->tuples_mask.ether_proto = ethtype_mask;\n\t\trule->tuples.ip_proto = match.key->ip_proto;\n\t\trule->tuples_mask.ip_proto = match.mask->ip_proto;\n\t} else {\n\t\trule->unused_tuple |= BIT(INNER_IP_PROTO);\n\t\trule->unused_tuple |= BIT(INNER_ETH_TYPE);\n\t}\n}\n\nstatic void hclge_get_cls_key_mac(const struct flow_rule *flow,\n\t\t\t\t  struct hclge_fd_rule *rule)\n{\n\tif (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(flow, &match);\n\t\tether_addr_copy(rule->tuples.dst_mac, match.key->dst);\n\t\tether_addr_copy(rule->tuples_mask.dst_mac, match.mask->dst);\n\t\tether_addr_copy(rule->tuples.src_mac, match.key->src);\n\t\tether_addr_copy(rule->tuples_mask.src_mac, match.mask->src);\n\t} else {\n\t\trule->unused_tuple |= BIT(INNER_DST_MAC);\n\t\trule->unused_tuple |= BIT(INNER_SRC_MAC);\n\t}\n}\n\nstatic void hclge_get_cls_key_vlan(const struct flow_rule *flow,\n\t\t\t\t   struct hclge_fd_rule *rule)\n{\n\tif (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(flow, &match);\n\t\trule->tuples.vlan_tag1 = match.key->vlan_id |\n\t\t\t\t(match.key->vlan_priority << VLAN_PRIO_SHIFT);\n\t\trule->tuples_mask.vlan_tag1 = match.mask->vlan_id |\n\t\t\t\t(match.mask->vlan_priority << VLAN_PRIO_SHIFT);\n\t} else {\n\t\trule->unused_tuple |= BIT(INNER_VLAN_TAG_FST);\n\t}\n}\n\nstatic void hclge_get_cls_key_ip(const struct flow_rule *flow,\n\t\t\t\t struct hclge_fd_rule *rule)\n{\n\tu16 addr_type = 0;\n\n\tif (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(flow, &match);\n\t\taddr_type = match.key->addr_type;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_ipv4_addrs(flow, &match);\n\t\trule->tuples.src_ip[IPV4_INDEX] = be32_to_cpu(match.key->src);\n\t\trule->tuples_mask.src_ip[IPV4_INDEX] =\n\t\t\t\t\t\tbe32_to_cpu(match.mask->src);\n\t\trule->tuples.dst_ip[IPV4_INDEX] = be32_to_cpu(match.key->dst);\n\t\trule->tuples_mask.dst_ip[IPV4_INDEX] =\n\t\t\t\t\t\tbe32_to_cpu(match.mask->dst);\n\t} else if (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\tstruct flow_match_ipv6_addrs match;\n\n\t\tflow_rule_match_ipv6_addrs(flow, &match);\n\t\tbe32_to_cpu_array(rule->tuples.src_ip, match.key->src.s6_addr32,\n\t\t\t\t  IPV6_SIZE);\n\t\tbe32_to_cpu_array(rule->tuples_mask.src_ip,\n\t\t\t\t  match.mask->src.s6_addr32, IPV6_SIZE);\n\t\tbe32_to_cpu_array(rule->tuples.dst_ip, match.key->dst.s6_addr32,\n\t\t\t\t  IPV6_SIZE);\n\t\tbe32_to_cpu_array(rule->tuples_mask.dst_ip,\n\t\t\t\t  match.mask->dst.s6_addr32, IPV6_SIZE);\n\t} else {\n\t\trule->unused_tuple |= BIT(INNER_SRC_IP);\n\t\trule->unused_tuple |= BIT(INNER_DST_IP);\n\t}\n}\n\nstatic void hclge_get_cls_key_port(const struct flow_rule *flow,\n\t\t\t\t   struct hclge_fd_rule *rule)\n{\n\tif (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_ports(flow, &match);\n\n\t\trule->tuples.src_port = be16_to_cpu(match.key->src);\n\t\trule->tuples_mask.src_port = be16_to_cpu(match.mask->src);\n\t\trule->tuples.dst_port = be16_to_cpu(match.key->dst);\n\t\trule->tuples_mask.dst_port = be16_to_cpu(match.mask->dst);\n\t} else {\n\t\trule->unused_tuple |= BIT(INNER_SRC_PORT);\n\t\trule->unused_tuple |= BIT(INNER_DST_PORT);\n\t}\n}\n\nstatic int hclge_parse_cls_flower(struct hclge_dev *hdev,\n\t\t\t\t  struct flow_cls_offload *cls_flower,\n\t\t\t\t  struct hclge_fd_rule *rule)\n{\n\tstruct flow_rule *flow = flow_cls_offload_flow_rule(cls_flower);\n\tstruct flow_dissector *dissector = flow->match.dissector;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS))) {\n\t\tdev_err(&hdev->pdev->dev, \"unsupported key set: %#llx\\n\",\n\t\t\tdissector->used_keys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\thclge_get_cls_key_basic(flow, rule);\n\thclge_get_cls_key_mac(flow, rule);\n\thclge_get_cls_key_vlan(flow, rule);\n\thclge_get_cls_key_ip(flow, rule);\n\thclge_get_cls_key_port(flow, rule);\n\n\treturn 0;\n}\n\nstatic int hclge_check_cls_flower(struct hclge_dev *hdev,\n\t\t\t\t  struct flow_cls_offload *cls_flower, int tc)\n{\n\tu32 prio = cls_flower->common.prio;\n\n\tif (tc < 0 || tc > hdev->tc_max) {\n\t\tdev_err(&hdev->pdev->dev, \"invalid traffic class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (prio == 0 ||\n\t    prio > hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"prio %u should be in range[1, %u]\\n\",\n\t\t\tprio, hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_bit(prio - 1, hdev->fd_bmap)) {\n\t\tdev_err(&hdev->pdev->dev, \"prio %u is already used\\n\", prio);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int hclge_add_cls_flower(struct hnae3_handle *handle,\n\t\t\t\tstruct flow_cls_offload *cls_flower,\n\t\t\t\tint tc)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_fd_rule *rule;\n\tint ret;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"cls flower is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = hclge_check_cls_flower(hdev, cls_flower, tc);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to check cls flower params, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn -ENOMEM;\n\n\tret = hclge_parse_cls_flower(hdev, cls_flower, rule);\n\tif (ret) {\n\t\tkfree(rule);\n\t\treturn ret;\n\t}\n\n\trule->action = HCLGE_FD_ACTION_SELECT_TC;\n\trule->cls_flower.tc = tc;\n\trule->location = cls_flower->common.prio - 1;\n\trule->vf_id = 0;\n\trule->cls_flower.cookie = cls_flower->cookie;\n\trule->rule_type = HCLGE_FD_TC_FLOWER_ACTIVE;\n\n\tret = hclge_add_fd_entry_common(hdev, rule);\n\tif (ret)\n\t\tkfree(rule);\n\n\treturn ret;\n}\n\nstatic struct hclge_fd_rule *hclge_find_cls_flower(struct hclge_dev *hdev,\n\t\t\t\t\t\t   unsigned long cookie)\n{\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {\n\t\tif (rule->cls_flower.cookie == cookie)\n\t\t\treturn rule;\n\t}\n\n\treturn NULL;\n}\n\nstatic int hclge_del_cls_flower(struct hnae3_handle *handle,\n\t\t\t\tstruct flow_cls_offload *cls_flower)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_fd_rule *rule;\n\tint ret;\n\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\n\trule = hclge_find_cls_flower(hdev, cls_flower->cookie);\n\tif (!rule) {\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true, rule->location,\n\t\t\t\t   NULL, false);\n\tif (ret) {\n\t\t \n\t\thclge_update_fd_list(hdev, HCLGE_FD_TO_DEL, rule->location, NULL);\n\t\tset_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);\n\t\tspin_unlock_bh(&hdev->fd_rule_lock);\n\t\treturn ret;\n\t}\n\n\thclge_update_fd_list(hdev, HCLGE_FD_DELETED, rule->location, NULL);\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\n\treturn 0;\n}\n\nstatic void hclge_sync_fd_list(struct hclge_dev *hdev, struct hlist_head *hlist)\n{\n\tstruct hclge_fd_rule *rule;\n\tstruct hlist_node *node;\n\tint ret = 0;\n\n\tif (!test_and_clear_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state))\n\t\treturn;\n\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\n\thlist_for_each_entry_safe(rule, node, hlist, rule_node) {\n\t\tswitch (rule->state) {\n\t\tcase HCLGE_FD_TO_ADD:\n\t\t\tret = hclge_fd_config_rule(hdev, rule);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\trule->state = HCLGE_FD_ACTIVE;\n\t\t\tbreak;\n\t\tcase HCLGE_FD_TO_DEL:\n\t\t\tret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true,\n\t\t\t\t\t\t   rule->location, NULL, false);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\thclge_fd_dec_rule_cnt(hdev, rule->location);\n\t\t\thclge_fd_free_node(hdev, rule);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (ret)\n\t\tset_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);\n\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n}\n\nstatic void hclge_sync_fd_table(struct hclge_dev *hdev)\n{\n\tif (!hnae3_ae_dev_fd_supported(hdev->ae_dev))\n\t\treturn;\n\n\tif (test_and_clear_bit(HCLGE_STATE_FD_CLEAR_ALL, &hdev->state)) {\n\t\tbool clear_list = hdev->fd_active_type == HCLGE_FD_ARFS_ACTIVE;\n\n\t\thclge_clear_fd_rules_in_list(hdev, clear_list);\n\t}\n\n\thclge_sync_fd_user_def_cfg(hdev, false);\n\n\thclge_sync_fd_list(hdev, &hdev->fd_rule_list);\n}\n\nstatic bool hclge_get_hw_reset_stat(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn hclge_read_dev(&hdev->hw, HCLGE_GLOBAL_RESET_REG) ||\n\t       hclge_read_dev(&hdev->hw, HCLGE_FUN_RST_ING);\n}\n\nstatic bool hclge_get_cmdq_stat(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);\n}\n\nstatic bool hclge_ae_dev_resetting(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);\n}\n\nstatic unsigned long hclge_ae_dev_reset_cnt(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn hdev->rst_stats.hw_reset_done_cnt;\n}\n\nstatic void hclge_enable_fd(struct hnae3_handle *handle, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\thdev->fd_en = enable;\n\n\tif (!enable)\n\t\tset_bit(HCLGE_STATE_FD_CLEAR_ALL, &hdev->state);\n\telse\n\t\thclge_restore_fd_entries(handle);\n\n\thclge_task_schedule(hdev, 0);\n}\n\nstatic void hclge_cfg_mac_mode(struct hclge_dev *hdev, bool enable)\n{\n#define HCLGE_LINK_STATUS_WAIT_CNT  3\n\n\tstruct hclge_desc desc;\n\tstruct hclge_config_mac_mode_cmd *req =\n\t\t(struct hclge_config_mac_mode_cmd *)desc.data;\n\tu32 loop_en = 0;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAC_MODE, false);\n\n\tif (enable) {\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_TX_EN_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_RX_EN_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_PAD_TX_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_PAD_RX_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_FCS_TX_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_RX_FCS_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_RX_FCS_STRIP_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_TX_OVERSIZE_TRUNCATE_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_RX_OVERSIZE_TRUNCATE_B, 1U);\n\t\thnae3_set_bit(loop_en, HCLGE_MAC_TX_UNDER_MIN_ERR_B, 1U);\n\t}\n\n\treq->txrx_pad_fcs_loop_en = cpu_to_le32(loop_en);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mac enable fail, ret =%d.\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (!enable)\n\t\thclge_mac_link_status_wait(hdev, HCLGE_LINK_STATUS_DOWN,\n\t\t\t\t\t   HCLGE_LINK_STATUS_WAIT_CNT);\n}\n\nstatic int hclge_config_switch_param(struct hclge_dev *hdev, int vfid,\n\t\t\t\t     u8 switch_param, u8 param_mask)\n{\n\tstruct hclge_mac_vlan_switch_cmd *req;\n\tstruct hclge_desc desc;\n\tu32 func_id;\n\tint ret;\n\n\tfunc_id = hclge_get_port_number(HOST_PORT, 0, vfid, 0);\n\treq = (struct hclge_mac_vlan_switch_cmd *)desc.data;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_SWITCH_PARAM,\n\t\t\t\t   true);\n\treq->roce_sel = HCLGE_MAC_VLAN_NIC_SEL;\n\treq->func_id = cpu_to_le32(func_id);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"read mac vlan switch parameter fail, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\thclge_comm_cmd_reuse_desc(&desc, false);\n\treq->switch_param = (req->switch_param & param_mask) | switch_param;\n\treq->param_mask = param_mask;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"set mac vlan switch parameter fail, ret = %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void hclge_phy_link_status_wait(struct hclge_dev *hdev,\n\t\t\t\t       int link_ret)\n{\n#define HCLGE_PHY_LINK_STATUS_NUM  200\n\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\tint i = 0;\n\tint ret;\n\n\tdo {\n\t\tret = phy_read_status(phydev);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"phy update link status fail, ret = %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\tif (phydev->link == link_ret)\n\t\t\tbreak;\n\n\t\tmsleep(HCLGE_LINK_STATUS_MS);\n\t} while (++i < HCLGE_PHY_LINK_STATUS_NUM);\n}\n\nstatic int hclge_mac_link_status_wait(struct hclge_dev *hdev, int link_ret,\n\t\t\t\t      int wait_cnt)\n{\n\tint link_status;\n\tint i = 0;\n\tint ret;\n\n\tdo {\n\t\tret = hclge_get_mac_link_status(hdev, &link_status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (link_status == link_ret)\n\t\t\treturn 0;\n\n\t\tmsleep(HCLGE_LINK_STATUS_MS);\n\t} while (++i < wait_cnt);\n\treturn -EBUSY;\n}\n\nstatic int hclge_mac_phy_link_status_wait(struct hclge_dev *hdev, bool en,\n\t\t\t\t\t  bool is_phy)\n{\n#define HCLGE_MAC_LINK_STATUS_NUM  100\n\n\tint link_ret;\n\n\tlink_ret = en ? HCLGE_LINK_STATUS_UP : HCLGE_LINK_STATUS_DOWN;\n\n\tif (is_phy)\n\t\thclge_phy_link_status_wait(hdev, link_ret);\n\n\treturn hclge_mac_link_status_wait(hdev, link_ret,\n\t\t\t\t\t  HCLGE_MAC_LINK_STATUS_NUM);\n}\n\nstatic int hclge_set_app_loopback(struct hclge_dev *hdev, bool en)\n{\n\tstruct hclge_config_mac_mode_cmd *req;\n\tstruct hclge_desc desc;\n\tu32 loop_en;\n\tint ret;\n\n\treq = (struct hclge_config_mac_mode_cmd *)&desc.data[0];\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAC_MODE, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mac loopback get fail, ret =%d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tloop_en = le32_to_cpu(req->txrx_pad_fcs_loop_en);\n\thnae3_set_bit(loop_en, HCLGE_MAC_APP_LP_B, en ? 1 : 0);\n\n\treq->txrx_pad_fcs_loop_en = cpu_to_le32(loop_en);\n\n\t \n\thclge_comm_cmd_reuse_desc(&desc, false);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mac loopback set fail, ret =%d.\\n\", ret);\n\treturn ret;\n}\n\nstatic int hclge_cfg_common_loopback_cmd_send(struct hclge_dev *hdev, bool en,\n\t\t\t\t\t      enum hnae3_loop loop_mode)\n{\n\tstruct hclge_common_lb_cmd *req;\n\tstruct hclge_desc desc;\n\tu8 loop_mode_b;\n\tint ret;\n\n\treq = (struct hclge_common_lb_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_COMMON_LOOPBACK, false);\n\n\tswitch (loop_mode) {\n\tcase HNAE3_LOOP_SERIAL_SERDES:\n\t\tloop_mode_b = HCLGE_CMD_SERDES_SERIAL_INNER_LOOP_B;\n\t\tbreak;\n\tcase HNAE3_LOOP_PARALLEL_SERDES:\n\t\tloop_mode_b = HCLGE_CMD_SERDES_PARALLEL_INNER_LOOP_B;\n\t\tbreak;\n\tcase HNAE3_LOOP_PHY:\n\t\tloop_mode_b = HCLGE_CMD_GE_PHY_INNER_LOOP_B;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"unsupported loopback mode %d\\n\", loop_mode);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treq->mask = loop_mode_b;\n\tif (en)\n\t\treq->enable = loop_mode_b;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to send loopback cmd, loop_mode = %d, ret = %d\\n\",\n\t\t\tloop_mode, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_cfg_common_loopback_wait(struct hclge_dev *hdev)\n{\n#define HCLGE_COMMON_LB_RETRY_MS\t10\n#define HCLGE_COMMON_LB_RETRY_NUM\t100\n\n\tstruct hclge_common_lb_cmd *req;\n\tstruct hclge_desc desc;\n\tu32 i = 0;\n\tint ret;\n\n\treq = (struct hclge_common_lb_cmd *)desc.data;\n\n\tdo {\n\t\tmsleep(HCLGE_COMMON_LB_RETRY_MS);\n\t\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_COMMON_LOOPBACK,\n\t\t\t\t\t   true);\n\t\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to get loopback done status, ret = %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t} while (++i < HCLGE_COMMON_LB_RETRY_NUM &&\n\t\t !(req->result & HCLGE_CMD_COMMON_LB_DONE_B));\n\n\tif (!(req->result & HCLGE_CMD_COMMON_LB_DONE_B)) {\n\t\tdev_err(&hdev->pdev->dev, \"wait loopback timeout\\n\");\n\t\treturn -EBUSY;\n\t} else if (!(req->result & HCLGE_CMD_COMMON_LB_SUCCESS_B)) {\n\t\tdev_err(&hdev->pdev->dev, \"failed to do loopback test\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_cfg_common_loopback(struct hclge_dev *hdev, bool en,\n\t\t\t\t     enum hnae3_loop loop_mode)\n{\n\tint ret;\n\n\tret = hclge_cfg_common_loopback_cmd_send(hdev, en, loop_mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_cfg_common_loopback_wait(hdev);\n}\n\nstatic int hclge_set_common_loopback(struct hclge_dev *hdev, bool en,\n\t\t\t\t     enum hnae3_loop loop_mode)\n{\n\tint ret;\n\n\tret = hclge_cfg_common_loopback(hdev, en, loop_mode);\n\tif (ret)\n\t\treturn ret;\n\n\thclge_cfg_mac_mode(hdev, en);\n\n\tret = hclge_mac_phy_link_status_wait(hdev, en, false);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"serdes loopback config mac mode timeout\\n\");\n\n\treturn ret;\n}\n\nstatic int hclge_enable_phy_loopback(struct hclge_dev *hdev,\n\t\t\t\t     struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (!phydev->suspended) {\n\t\tret = phy_suspend(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = phy_resume(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_loopback(phydev, true);\n}\n\nstatic int hclge_disable_phy_loopback(struct hclge_dev *hdev,\n\t\t\t\t      struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_loopback(phydev, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_suspend(phydev);\n}\n\nstatic int hclge_set_phy_loopback(struct hclge_dev *hdev, bool en)\n{\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\tint ret;\n\n\tif (!phydev) {\n\t\tif (hnae3_dev_phy_imp_supported(hdev))\n\t\t\treturn hclge_set_common_loopback(hdev, en,\n\t\t\t\t\t\t\t HNAE3_LOOP_PHY);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (en)\n\t\tret = hclge_enable_phy_loopback(hdev, phydev);\n\telse\n\t\tret = hclge_disable_phy_loopback(hdev, phydev);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"set phy loopback fail, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thclge_cfg_mac_mode(hdev, en);\n\n\tret = hclge_mac_phy_link_status_wait(hdev, en, true);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"phy loopback config mac mode timeout\\n\");\n\n\treturn ret;\n}\n\nstatic int hclge_tqp_enable_cmd_send(struct hclge_dev *hdev, u16 tqp_id,\n\t\t\t\t     u16 stream_id, bool enable)\n{\n\tstruct hclge_desc desc;\n\tstruct hclge_cfg_com_tqp_queue_cmd *req =\n\t\t(struct hclge_cfg_com_tqp_queue_cmd *)desc.data;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CFG_COM_TQP_QUEUE, false);\n\treq->tqp_id = cpu_to_le16(tqp_id);\n\treq->stream_id = cpu_to_le16(stream_id);\n\tif (enable)\n\t\treq->enable |= 1U << HCLGE_TQP_ENABLE_B;\n\n\treturn hclge_cmd_send(&hdev->hw, &desc, 1);\n}\n\nstatic int hclge_tqp_enable(struct hnae3_handle *handle, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu16 i;\n\n\tfor (i = 0; i < handle->kinfo.num_tqps; i++) {\n\t\tret = hclge_tqp_enable_cmd_send(hdev, i, 0, enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int hclge_set_loopback(struct hnae3_handle *handle,\n\t\t\t      enum hnae3_loop loop_mode, bool en)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret = 0;\n\n\t \n\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2) {\n\t\tu8 switch_param = en ? 0 : BIT(HCLGE_SWITCH_ALW_LPBK_B);\n\n\t\tret = hclge_config_switch_param(hdev, PF_VPORT_ID, switch_param,\n\t\t\t\t\t\tHCLGE_SWITCH_ALW_LPBK_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (loop_mode) {\n\tcase HNAE3_LOOP_APP:\n\t\tret = hclge_set_app_loopback(hdev, en);\n\t\tbreak;\n\tcase HNAE3_LOOP_SERIAL_SERDES:\n\tcase HNAE3_LOOP_PARALLEL_SERDES:\n\t\tret = hclge_set_common_loopback(hdev, en, loop_mode);\n\t\tbreak;\n\tcase HNAE3_LOOP_PHY:\n\t\tret = hclge_set_phy_loopback(hdev, en);\n\t\tbreak;\n\tcase HNAE3_LOOP_EXTERNAL:\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"loop_mode %d is not supported\\n\", loop_mode);\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_tqp_enable(handle, en);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"failed to %s tqp in loopback, ret = %d\\n\",\n\t\t\ten ? \"enable\" : \"disable\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_set_default_loopback(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\tret = hclge_set_app_loopback(hdev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_cfg_common_loopback(hdev, false, HNAE3_LOOP_SERIAL_SERDES);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_cfg_common_loopback(hdev, false,\n\t\t\t\t\t HNAE3_LOOP_PARALLEL_SERDES);\n}\n\nstatic void hclge_flush_link_update(struct hclge_dev *hdev)\n{\n#define HCLGE_FLUSH_LINK_TIMEOUT\t100000\n\n\tunsigned long last = hdev->serv_processed_cnt;\n\tint i = 0;\n\n\twhile (test_bit(HCLGE_STATE_LINK_UPDATING, &hdev->state) &&\n\t       i++ < HCLGE_FLUSH_LINK_TIMEOUT &&\n\t       last == hdev->serv_processed_cnt)\n\t\tusleep_range(1, 1);\n}\n\nstatic void hclge_set_timer_task(struct hnae3_handle *handle, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (enable) {\n\t\thclge_task_schedule(hdev, 0);\n\t} else {\n\t\t \n\t\tset_bit(HCLGE_STATE_DOWN, &hdev->state);\n\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\thclge_flush_link_update(hdev);\n\t}\n}\n\nstatic int hclge_ae_start(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\t \n\thclge_cfg_mac_mode(hdev, true);\n\tclear_bit(HCLGE_STATE_DOWN, &hdev->state);\n\thdev->hw.mac.link = 0;\n\n\t \n\thclge_comm_reset_tqp_stats(handle);\n\n\thclge_mac_start_phy(hdev);\n\n\treturn 0;\n}\n\nstatic void hclge_ae_stop(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tset_bit(HCLGE_STATE_DOWN, &hdev->state);\n\tspin_lock_bh(&hdev->fd_rule_lock);\n\thclge_clear_arfs_rules(hdev);\n\tspin_unlock_bh(&hdev->fd_rule_lock);\n\n\t \n\tif (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state)) {\n\t\thclge_pfc_pause_en_cfg(hdev, HCLGE_PFC_TX_RX_DISABLE,\n\t\t\t\t       HCLGE_PFC_DISABLE);\n\t\tif (hdev->reset_type != HNAE3_FUNC_RESET &&\n\t\t    hdev->reset_type != HNAE3_FLR_RESET) {\n\t\t\thclge_mac_stop_phy(hdev);\n\t\t\thclge_update_link_status(hdev);\n\t\t\treturn;\n\t\t}\n\t}\n\n\thclge_reset_tqp(handle);\n\n\thclge_config_mac_tnl_int(hdev, false);\n\n\t \n\thclge_cfg_mac_mode(hdev, false);\n\n\thclge_mac_stop_phy(hdev);\n\n\t \n\thclge_comm_reset_tqp_stats(handle);\n\thclge_update_link_status(hdev);\n}\n\nint hclge_vport_start(struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\n\tset_bit(HCLGE_VPORT_STATE_INITED, &vport->state);\n\tset_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);\n\tset_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE, &vport->state);\n\tvport->last_active_jiffies = jiffies;\n\tvport->need_notify = 0;\n\n\tif (test_bit(vport->vport_id, hdev->vport_config_block)) {\n\t\tif (vport->vport_id) {\n\t\t\thclge_restore_mac_table_common(vport);\n\t\t\thclge_restore_vport_vlan_table(vport);\n\t\t} else {\n\t\t\thclge_restore_hw_table(hdev);\n\t\t}\n\t}\n\n\tclear_bit(vport->vport_id, hdev->vport_config_block);\n\n\treturn 0;\n}\n\nvoid hclge_vport_stop(struct hclge_vport *vport)\n{\n\tclear_bit(HCLGE_VPORT_STATE_INITED, &vport->state);\n\tclear_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);\n\tvport->need_notify = 0;\n}\n\nstatic int hclge_client_start(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn hclge_vport_start(vport);\n}\n\nstatic void hclge_client_stop(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\thclge_vport_stop(vport);\n}\n\nstatic int hclge_get_mac_vlan_cmd_status(struct hclge_vport *vport,\n\t\t\t\t\t u16 cmdq_resp, u8  resp_code,\n\t\t\t\t\t enum hclge_mac_vlan_tbl_opcode op)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (cmdq_resp) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"cmdq execute failed for get_mac_vlan_cmd_status,status=%u.\\n\",\n\t\t\tcmdq_resp);\n\t\treturn -EIO;\n\t}\n\n\tif (op == HCLGE_MAC_VLAN_ADD) {\n\t\tif (!resp_code || resp_code == 1)\n\t\t\treturn 0;\n\t\telse if (resp_code == HCLGE_ADD_UC_OVERFLOW ||\n\t\t\t resp_code == HCLGE_ADD_MC_OVERFLOW)\n\t\t\treturn -ENOSPC;\n\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"add mac addr failed for undefined, code=%u.\\n\",\n\t\t\tresp_code);\n\t\treturn -EIO;\n\t} else if (op == HCLGE_MAC_VLAN_REMOVE) {\n\t\tif (!resp_code) {\n\t\t\treturn 0;\n\t\t} else if (resp_code == 1) {\n\t\t\tdev_dbg(&hdev->pdev->dev,\n\t\t\t\t\"remove mac addr failed for miss.\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"remove mac addr failed for undefined, code=%u.\\n\",\n\t\t\tresp_code);\n\t\treturn -EIO;\n\t} else if (op == HCLGE_MAC_VLAN_LKUP) {\n\t\tif (!resp_code) {\n\t\t\treturn 0;\n\t\t} else if (resp_code == 1) {\n\t\t\tdev_dbg(&hdev->pdev->dev,\n\t\t\t\t\"lookup mac addr failed for miss.\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"lookup mac addr failed for undefined, code=%u.\\n\",\n\t\t\tresp_code);\n\t\treturn -EIO;\n\t}\n\n\tdev_err(&hdev->pdev->dev,\n\t\t\"unknown opcode for get_mac_vlan_cmd_status, opcode=%d.\\n\", op);\n\n\treturn -EINVAL;\n}\n\nstatic int hclge_update_desc_vfid(struct hclge_desc *desc, int vfid, bool clr)\n{\n#define HCLGE_VF_NUM_IN_FIRST_DESC 192\n\n\tunsigned int word_num;\n\tunsigned int bit_num;\n\n\tif (vfid > 255 || vfid < 0)\n\t\treturn -EIO;\n\n\tif (vfid >= 0 && vfid < HCLGE_VF_NUM_IN_FIRST_DESC) {\n\t\tword_num = vfid / 32;\n\t\tbit_num  = vfid % 32;\n\t\tif (clr)\n\t\t\tdesc[1].data[word_num] &= cpu_to_le32(~(1 << bit_num));\n\t\telse\n\t\t\tdesc[1].data[word_num] |= cpu_to_le32(1 << bit_num);\n\t} else {\n\t\tword_num = (vfid - HCLGE_VF_NUM_IN_FIRST_DESC) / 32;\n\t\tbit_num  = vfid % 32;\n\t\tif (clr)\n\t\t\tdesc[2].data[word_num] &= cpu_to_le32(~(1 << bit_num));\n\t\telse\n\t\t\tdesc[2].data[word_num] |= cpu_to_le32(1 << bit_num);\n\t}\n\n\treturn 0;\n}\n\nstatic bool hclge_is_all_function_id_zero(struct hclge_desc *desc)\n{\n#define HCLGE_DESC_NUMBER 3\n#define HCLGE_FUNC_NUMBER_PER_DESC 6\n\tint i, j;\n\n\tfor (i = 1; i < HCLGE_DESC_NUMBER; i++)\n\t\tfor (j = 0; j < HCLGE_FUNC_NUMBER_PER_DESC; j++)\n\t\t\tif (desc[i].data[j])\n\t\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void hclge_prepare_mac_addr(struct hclge_mac_vlan_tbl_entry_cmd *new_req,\n\t\t\t\t   const u8 *addr, bool is_mc)\n{\n\tconst unsigned char *mac_addr = addr;\n\tu32 high_val = mac_addr[2] << 16 | (mac_addr[3] << 24) |\n\t\t       (mac_addr[0]) | (mac_addr[1] << 8);\n\tu32 low_val  = mac_addr[4] | (mac_addr[5] << 8);\n\n\thnae3_set_bit(new_req->flags, HCLGE_MAC_VLAN_BIT0_EN_B, 1);\n\tif (is_mc) {\n\t\thnae3_set_bit(new_req->entry_type, HCLGE_MAC_VLAN_BIT1_EN_B, 1);\n\t\thnae3_set_bit(new_req->mc_mac_en, HCLGE_MAC_VLAN_BIT0_EN_B, 1);\n\t}\n\n\tnew_req->mac_addr_hi32 = cpu_to_le32(high_val);\n\tnew_req->mac_addr_lo16 = cpu_to_le16(low_val & 0xffff);\n}\n\nstatic int hclge_remove_mac_vlan_tbl(struct hclge_vport *vport,\n\t\t\t\t     struct hclge_mac_vlan_tbl_entry_cmd *req)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_desc desc;\n\tu8 resp_code;\n\tu16 retval;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_REMOVE, false);\n\n\tmemcpy(desc.data, req, sizeof(struct hclge_mac_vlan_tbl_entry_cmd));\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"del mac addr failed for cmd_send, ret =%d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tresp_code = (le32_to_cpu(desc.data[0]) >> 8) & 0xff;\n\tretval = le16_to_cpu(desc.retval);\n\n\treturn hclge_get_mac_vlan_cmd_status(vport, retval, resp_code,\n\t\t\t\t\t     HCLGE_MAC_VLAN_REMOVE);\n}\n\nstatic int hclge_lookup_mac_vlan_tbl(struct hclge_vport *vport,\n\t\t\t\t     struct hclge_mac_vlan_tbl_entry_cmd *req,\n\t\t\t\t     struct hclge_desc *desc,\n\t\t\t\t     bool is_mc)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tu8 resp_code;\n\tu16 retval;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_MAC_VLAN_ADD, true);\n\tif (is_mc) {\n\t\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\tmemcpy(desc[0].data,\n\t\t       req,\n\t\t       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));\n\t\thclge_cmd_setup_basic_desc(&desc[1],\n\t\t\t\t\t   HCLGE_OPC_MAC_VLAN_ADD,\n\t\t\t\t\t   true);\n\t\tdesc[1].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\thclge_cmd_setup_basic_desc(&desc[2],\n\t\t\t\t\t   HCLGE_OPC_MAC_VLAN_ADD,\n\t\t\t\t\t   true);\n\t\tret = hclge_cmd_send(&hdev->hw, desc, 3);\n\t} else {\n\t\tmemcpy(desc[0].data,\n\t\t       req,\n\t\t       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));\n\t\tret = hclge_cmd_send(&hdev->hw, desc, 1);\n\t}\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"lookup mac addr failed for cmd_send, ret =%d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tresp_code = (le32_to_cpu(desc[0].data[0]) >> 8) & 0xff;\n\tretval = le16_to_cpu(desc[0].retval);\n\n\treturn hclge_get_mac_vlan_cmd_status(vport, retval, resp_code,\n\t\t\t\t\t     HCLGE_MAC_VLAN_LKUP);\n}\n\nstatic int hclge_add_mac_vlan_tbl(struct hclge_vport *vport,\n\t\t\t\t  struct hclge_mac_vlan_tbl_entry_cmd *req,\n\t\t\t\t  struct hclge_desc *mc_desc)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tint cfg_status;\n\tu8 resp_code;\n\tu16 retval;\n\tint ret;\n\n\tif (!mc_desc) {\n\t\tstruct hclge_desc desc;\n\n\t\thclge_cmd_setup_basic_desc(&desc,\n\t\t\t\t\t   HCLGE_OPC_MAC_VLAN_ADD,\n\t\t\t\t\t   false);\n\t\tmemcpy(desc.data, req,\n\t\t       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));\n\t\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t\tresp_code = (le32_to_cpu(desc.data[0]) >> 8) & 0xff;\n\t\tretval = le16_to_cpu(desc.retval);\n\n\t\tcfg_status = hclge_get_mac_vlan_cmd_status(vport, retval,\n\t\t\t\t\t\t\t   resp_code,\n\t\t\t\t\t\t\t   HCLGE_MAC_VLAN_ADD);\n\t} else {\n\t\thclge_comm_cmd_reuse_desc(&mc_desc[0], false);\n\t\tmc_desc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\thclge_comm_cmd_reuse_desc(&mc_desc[1], false);\n\t\tmc_desc[1].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\thclge_comm_cmd_reuse_desc(&mc_desc[2], false);\n\t\tmc_desc[2].flag &= cpu_to_le16(~HCLGE_COMM_CMD_FLAG_NEXT);\n\t\tmemcpy(mc_desc[0].data, req,\n\t\t       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));\n\t\tret = hclge_cmd_send(&hdev->hw, mc_desc, 3);\n\t\tresp_code = (le32_to_cpu(mc_desc[0].data[0]) >> 8) & 0xff;\n\t\tretval = le16_to_cpu(mc_desc[0].retval);\n\n\t\tcfg_status = hclge_get_mac_vlan_cmd_status(vport, retval,\n\t\t\t\t\t\t\t   resp_code,\n\t\t\t\t\t\t\t   HCLGE_MAC_VLAN_ADD);\n\t}\n\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"add mac addr failed for cmd_send, ret =%d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn cfg_status;\n}\n\nstatic int hclge_set_umv_space(struct hclge_dev *hdev, u16 space_size,\n\t\t\t       u16 *allocated_size)\n{\n\tstruct hclge_umv_spc_alc_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\treq = (struct hclge_umv_spc_alc_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_ALLOCATE, false);\n\n\treq->space_size = cpu_to_le32(space_size);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"failed to set umv space, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*allocated_size = le32_to_cpu(desc.data[1]);\n\n\treturn 0;\n}\n\nstatic int hclge_init_umv_space(struct hclge_dev *hdev)\n{\n\tu16 allocated_size = 0;\n\tint ret;\n\n\tret = hclge_set_umv_space(hdev, hdev->wanted_umv_size, &allocated_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (allocated_size < hdev->wanted_umv_size)\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"failed to alloc umv space, want %u, get %u\\n\",\n\t\t\t hdev->wanted_umv_size, allocated_size);\n\n\thdev->max_umv_size = allocated_size;\n\thdev->priv_umv_size = hdev->max_umv_size / (hdev->num_alloc_vport + 1);\n\thdev->share_umv_size = hdev->priv_umv_size +\n\t\t\thdev->max_umv_size % (hdev->num_alloc_vport + 1);\n\n\tif (hdev->ae_dev->dev_specs.mc_mac_size)\n\t\tset_bit(HNAE3_DEV_SUPPORT_MC_MAC_MNG_B, hdev->ae_dev->caps);\n\n\treturn 0;\n}\n\nstatic void hclge_reset_umv_space(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport;\n\tint i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tvport = &hdev->vport[i];\n\t\tvport->used_umv_num = 0;\n\t}\n\n\tmutex_lock(&hdev->vport_lock);\n\thdev->share_umv_size = hdev->priv_umv_size +\n\t\t\thdev->max_umv_size % (hdev->num_alloc_vport + 1);\n\tmutex_unlock(&hdev->vport_lock);\n\n\thdev->used_mc_mac_num = 0;\n}\n\nstatic bool hclge_is_umv_space_full(struct hclge_vport *vport, bool need_lock)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tbool is_full;\n\n\tif (need_lock)\n\t\tmutex_lock(&hdev->vport_lock);\n\n\tis_full = (vport->used_umv_num >= hdev->priv_umv_size &&\n\t\t   hdev->share_umv_size == 0);\n\n\tif (need_lock)\n\t\tmutex_unlock(&hdev->vport_lock);\n\n\treturn is_full;\n}\n\nstatic void hclge_update_umv_space(struct hclge_vport *vport, bool is_free)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (is_free) {\n\t\tif (vport->used_umv_num > hdev->priv_umv_size)\n\t\t\thdev->share_umv_size++;\n\n\t\tif (vport->used_umv_num > 0)\n\t\t\tvport->used_umv_num--;\n\t} else {\n\t\tif (vport->used_umv_num >= hdev->priv_umv_size &&\n\t\t    hdev->share_umv_size > 0)\n\t\t\thdev->share_umv_size--;\n\t\tvport->used_umv_num++;\n\t}\n}\n\nstatic struct hclge_mac_node *hclge_find_mac_node(struct list_head *list,\n\t\t\t\t\t\t  const u8 *mac_addr)\n{\n\tstruct hclge_mac_node *mac_node, *tmp;\n\n\tlist_for_each_entry_safe(mac_node, tmp, list, node)\n\t\tif (ether_addr_equal(mac_addr, mac_node->mac_addr))\n\t\t\treturn mac_node;\n\n\treturn NULL;\n}\n\nstatic void hclge_update_mac_node(struct hclge_mac_node *mac_node,\n\t\t\t\t  enum HCLGE_MAC_NODE_STATE state)\n{\n\tswitch (state) {\n\t \n\tcase HCLGE_MAC_TO_ADD:\n\t\tif (mac_node->state == HCLGE_MAC_TO_DEL)\n\t\t\tmac_node->state = HCLGE_MAC_ACTIVE;\n\t\tbreak;\n\t \n\tcase HCLGE_MAC_TO_DEL:\n\t\tif (mac_node->state == HCLGE_MAC_TO_ADD) {\n\t\t\tlist_del(&mac_node->node);\n\t\t\tkfree(mac_node);\n\t\t} else {\n\t\t\tmac_node->state = HCLGE_MAC_TO_DEL;\n\t\t}\n\t\tbreak;\n\t \n\tcase HCLGE_MAC_ACTIVE:\n\t\tif (mac_node->state == HCLGE_MAC_TO_ADD)\n\t\t\tmac_node->state = HCLGE_MAC_ACTIVE;\n\n\t\tbreak;\n\t}\n}\n\nint hclge_update_mac_list(struct hclge_vport *vport,\n\t\t\t  enum HCLGE_MAC_NODE_STATE state,\n\t\t\t  enum HCLGE_MAC_ADDR_TYPE mac_type,\n\t\t\t  const unsigned char *addr)\n{\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_mac_node *mac_node;\n\tstruct list_head *list;\n\n\tlist = (mac_type == HCLGE_MAC_ADDR_UC) ?\n\t\t&vport->uc_mac_list : &vport->mc_mac_list;\n\n\tspin_lock_bh(&vport->mac_list_lock);\n\n\t \n\tmac_node = hclge_find_mac_node(list, addr);\n\tif (mac_node) {\n\t\thclge_update_mac_node(mac_node, state);\n\t\tspin_unlock_bh(&vport->mac_list_lock);\n\t\tset_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);\n\t\treturn 0;\n\t}\n\n\t \n\tif (state == HCLGE_MAC_TO_DEL) {\n\t\tspin_unlock_bh(&vport->mac_list_lock);\n\t\thnae3_format_mac_addr(format_mac_addr, addr);\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to delete address %s from mac list\\n\",\n\t\t\tformat_mac_addr);\n\t\treturn -ENOENT;\n\t}\n\n\tmac_node = kzalloc(sizeof(*mac_node), GFP_ATOMIC);\n\tif (!mac_node) {\n\t\tspin_unlock_bh(&vport->mac_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);\n\n\tmac_node->state = state;\n\tether_addr_copy(mac_node->mac_addr, addr);\n\tlist_add_tail(&mac_node->node, list);\n\n\tspin_unlock_bh(&vport->mac_list_lock);\n\n\treturn 0;\n}\n\nstatic int hclge_add_uc_addr(struct hnae3_handle *handle,\n\t\t\t     const unsigned char *addr)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn hclge_update_mac_list(vport, HCLGE_MAC_TO_ADD, HCLGE_MAC_ADDR_UC,\n\t\t\t\t     addr);\n}\n\nint hclge_add_uc_addr_common(struct hclge_vport *vport,\n\t\t\t     const unsigned char *addr)\n{\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_mac_vlan_tbl_entry_cmd req;\n\tstruct hclge_desc desc;\n\tu16 egress_port = 0;\n\tint ret;\n\n\t \n\tif (is_zero_ether_addr(addr) ||\n\t    is_broadcast_ether_addr(addr) ||\n\t    is_multicast_ether_addr(addr)) {\n\t\thnae3_format_mac_addr(format_mac_addr, addr);\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Set_uc mac err! invalid mac:%s. is_zero:%d,is_br=%d,is_mul=%d\\n\",\n\t\t\t format_mac_addr, is_zero_ether_addr(addr),\n\t\t\t is_broadcast_ether_addr(addr),\n\t\t\t is_multicast_ether_addr(addr));\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\thnae3_set_field(egress_port, HCLGE_MAC_EPORT_VFID_M,\n\t\t\tHCLGE_MAC_EPORT_VFID_S, vport->vport_id);\n\n\treq.egress_port = cpu_to_le16(egress_port);\n\n\thclge_prepare_mac_addr(&req, addr, false);\n\n\t \n\tret = hclge_lookup_mac_vlan_tbl(vport, &req, &desc, false);\n\tif (ret == -ENOENT) {\n\t\tmutex_lock(&hdev->vport_lock);\n\t\tif (!hclge_is_umv_space_full(vport, false)) {\n\t\t\tret = hclge_add_mac_vlan_tbl(vport, &req, NULL);\n\t\t\tif (!ret)\n\t\t\t\thclge_update_umv_space(vport, false);\n\t\t\tmutex_unlock(&hdev->vport_lock);\n\t\t\treturn ret;\n\t\t}\n\t\tmutex_unlock(&hdev->vport_lock);\n\n\t\tif (!(vport->overflow_promisc_flags & HNAE3_OVERFLOW_UPE))\n\t\t\tdev_err(&hdev->pdev->dev, \"UC MAC table full(%u)\\n\",\n\t\t\t\thdev->priv_umv_size);\n\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tif (!ret)\n\t\treturn -EEXIST;\n\n\treturn ret;\n}\n\nstatic int hclge_rm_uc_addr(struct hnae3_handle *handle,\n\t\t\t    const unsigned char *addr)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn hclge_update_mac_list(vport, HCLGE_MAC_TO_DEL, HCLGE_MAC_ADDR_UC,\n\t\t\t\t     addr);\n}\n\nint hclge_rm_uc_addr_common(struct hclge_vport *vport,\n\t\t\t    const unsigned char *addr)\n{\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_mac_vlan_tbl_entry_cmd req;\n\tint ret;\n\n\t \n\tif (is_zero_ether_addr(addr) ||\n\t    is_broadcast_ether_addr(addr) ||\n\t    is_multicast_ether_addr(addr)) {\n\t\thnae3_format_mac_addr(format_mac_addr, addr);\n\t\tdev_dbg(&hdev->pdev->dev, \"Remove mac err! invalid mac:%s.\\n\",\n\t\t\tformat_mac_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\thnae3_set_bit(req.entry_type, HCLGE_MAC_VLAN_BIT0_EN_B, 0);\n\thclge_prepare_mac_addr(&req, addr, false);\n\tret = hclge_remove_mac_vlan_tbl(vport, &req);\n\tif (!ret || ret == -ENOENT) {\n\t\tmutex_lock(&hdev->vport_lock);\n\t\thclge_update_umv_space(vport, true);\n\t\tmutex_unlock(&hdev->vport_lock);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int hclge_add_mc_addr(struct hnae3_handle *handle,\n\t\t\t     const unsigned char *addr)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn hclge_update_mac_list(vport, HCLGE_MAC_TO_ADD, HCLGE_MAC_ADDR_MC,\n\t\t\t\t     addr);\n}\n\nint hclge_add_mc_addr_common(struct hclge_vport *vport,\n\t\t\t     const unsigned char *addr)\n{\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_mac_vlan_tbl_entry_cmd req;\n\tstruct hclge_desc desc[3];\n\tbool is_new_addr = false;\n\tint status;\n\n\t \n\tif (!is_multicast_ether_addr(addr)) {\n\t\thnae3_format_mac_addr(format_mac_addr, addr);\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Add mc mac err! invalid mac:%s.\\n\",\n\t\t\t format_mac_addr);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&req, 0, sizeof(req));\n\thclge_prepare_mac_addr(&req, addr, true);\n\tstatus = hclge_lookup_mac_vlan_tbl(vport, &req, desc, true);\n\tif (status) {\n\t\tif (hnae3_ae_dev_mc_mac_mng_supported(hdev->ae_dev) &&\n\t\t    hdev->used_mc_mac_num >=\n\t\t    hdev->ae_dev->dev_specs.mc_mac_size)\n\t\t\tgoto err_no_space;\n\n\t\tis_new_addr = true;\n\n\t\t \n\t\tmemset(desc[0].data, 0, sizeof(desc[0].data));\n\t\tmemset(desc[1].data, 0, sizeof(desc[0].data));\n\t\tmemset(desc[2].data, 0, sizeof(desc[0].data));\n\t}\n\tstatus = hclge_update_desc_vfid(desc, vport->vport_id, false);\n\tif (status)\n\t\treturn status;\n\tstatus = hclge_add_mac_vlan_tbl(vport, &req, desc);\n\tif (status == -ENOSPC)\n\t\tgoto err_no_space;\n\telse if (!status && is_new_addr)\n\t\thdev->used_mc_mac_num++;\n\n\treturn status;\n\nerr_no_space:\n\t \n\tif (!(vport->overflow_promisc_flags & HNAE3_OVERFLOW_MPE)) {\n\t\tvport->overflow_promisc_flags |= HNAE3_OVERFLOW_MPE;\n\t\tdev_err(&hdev->pdev->dev, \"mc mac vlan table is full\\n\");\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic int hclge_rm_mc_addr(struct hnae3_handle *handle,\n\t\t\t    const unsigned char *addr)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn hclge_update_mac_list(vport, HCLGE_MAC_TO_DEL, HCLGE_MAC_ADDR_MC,\n\t\t\t\t     addr);\n}\n\nint hclge_rm_mc_addr_common(struct hclge_vport *vport,\n\t\t\t    const unsigned char *addr)\n{\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_mac_vlan_tbl_entry_cmd req;\n\tenum hclge_comm_cmd_status status;\n\tstruct hclge_desc desc[3];\n\n\t \n\tif (!is_multicast_ether_addr(addr)) {\n\t\thnae3_format_mac_addr(format_mac_addr, addr);\n\t\tdev_dbg(&hdev->pdev->dev,\n\t\t\t\"Remove mc mac err! invalid mac:%s.\\n\",\n\t\t\t format_mac_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\thclge_prepare_mac_addr(&req, addr, true);\n\tstatus = hclge_lookup_mac_vlan_tbl(vport, &req, desc, true);\n\tif (!status) {\n\t\t \n\t\tstatus = hclge_update_desc_vfid(desc, vport->vport_id, true);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (hclge_is_all_function_id_zero(desc)) {\n\t\t\t \n\t\t\tstatus = hclge_remove_mac_vlan_tbl(vport, &req);\n\t\t\tif (!status)\n\t\t\t\thdev->used_mc_mac_num--;\n\t\t} else {\n\t\t\t \n\t\t\tstatus = hclge_add_mac_vlan_tbl(vport, &req, desc);\n\t\t}\n\t} else if (status == -ENOENT) {\n\t\tstatus = 0;\n\t}\n\n\treturn status;\n}\n\nstatic void hclge_sync_vport_mac_list(struct hclge_vport *vport,\n\t\t\t\t      struct list_head *list,\n\t\t\t\t      enum HCLGE_MAC_ADDR_TYPE mac_type)\n{\n\tint (*sync)(struct hclge_vport *vport, const unsigned char *addr);\n\tstruct hclge_mac_node *mac_node, *tmp;\n\tint ret;\n\n\tif (mac_type == HCLGE_MAC_ADDR_UC)\n\t\tsync = hclge_add_uc_addr_common;\n\telse\n\t\tsync = hclge_add_mc_addr_common;\n\n\tlist_for_each_entry_safe(mac_node, tmp, list, node) {\n\t\tret = sync(vport, mac_node->mac_addr);\n\t\tif (!ret) {\n\t\t\tmac_node->state = HCLGE_MAC_ACTIVE;\n\t\t} else {\n\t\t\tset_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE,\n\t\t\t\t&vport->state);\n\n\t\t\t \n\t\t\tif ((mac_type == HCLGE_MAC_ADDR_UC && ret != -EEXIST) ||\n\t\t\t    (mac_type == HCLGE_MAC_ADDR_MC && ret != -ENOSPC))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void hclge_unsync_vport_mac_list(struct hclge_vport *vport,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t\tenum HCLGE_MAC_ADDR_TYPE mac_type)\n{\n\tint (*unsync)(struct hclge_vport *vport, const unsigned char *addr);\n\tstruct hclge_mac_node *mac_node, *tmp;\n\tint ret;\n\n\tif (mac_type == HCLGE_MAC_ADDR_UC)\n\t\tunsync = hclge_rm_uc_addr_common;\n\telse\n\t\tunsync = hclge_rm_mc_addr_common;\n\n\tlist_for_each_entry_safe(mac_node, tmp, list, node) {\n\t\tret = unsync(vport, mac_node->mac_addr);\n\t\tif (!ret || ret == -ENOENT) {\n\t\t\tlist_del(&mac_node->node);\n\t\t\tkfree(mac_node);\n\t\t} else {\n\t\t\tset_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE,\n\t\t\t\t&vport->state);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool hclge_sync_from_add_list(struct list_head *add_list,\n\t\t\t\t     struct list_head *mac_list)\n{\n\tstruct hclge_mac_node *mac_node, *tmp, *new_node;\n\tbool all_added = true;\n\n\tlist_for_each_entry_safe(mac_node, tmp, add_list, node) {\n\t\tif (mac_node->state == HCLGE_MAC_TO_ADD)\n\t\t\tall_added = false;\n\n\t\t \n\t\tnew_node = hclge_find_mac_node(mac_list, mac_node->mac_addr);\n\t\tif (new_node) {\n\t\t\thclge_update_mac_node(new_node, mac_node->state);\n\t\t\tlist_del(&mac_node->node);\n\t\t\tkfree(mac_node);\n\t\t} else if (mac_node->state == HCLGE_MAC_ACTIVE) {\n\t\t\tmac_node->state = HCLGE_MAC_TO_DEL;\n\t\t\tlist_move_tail(&mac_node->node, mac_list);\n\t\t} else {\n\t\t\tlist_del(&mac_node->node);\n\t\t\tkfree(mac_node);\n\t\t}\n\t}\n\n\treturn all_added;\n}\n\nstatic void hclge_sync_from_del_list(struct list_head *del_list,\n\t\t\t\t     struct list_head *mac_list)\n{\n\tstruct hclge_mac_node *mac_node, *tmp, *new_node;\n\n\tlist_for_each_entry_safe(mac_node, tmp, del_list, node) {\n\t\tnew_node = hclge_find_mac_node(mac_list, mac_node->mac_addr);\n\t\tif (new_node) {\n\t\t\t \n\t\t\tnew_node->state = HCLGE_MAC_ACTIVE;\n\t\t\tlist_del(&mac_node->node);\n\t\t\tkfree(mac_node);\n\t\t} else {\n\t\t\tlist_move_tail(&mac_node->node, mac_list);\n\t\t}\n\t}\n}\n\nstatic void hclge_update_overflow_flags(struct hclge_vport *vport,\n\t\t\t\t\tenum HCLGE_MAC_ADDR_TYPE mac_type,\n\t\t\t\t\tbool is_all_added)\n{\n\tif (mac_type == HCLGE_MAC_ADDR_UC) {\n\t\tif (is_all_added)\n\t\t\tvport->overflow_promisc_flags &= ~HNAE3_OVERFLOW_UPE;\n\t\telse if (hclge_is_umv_space_full(vport, true))\n\t\t\tvport->overflow_promisc_flags |= HNAE3_OVERFLOW_UPE;\n\t} else {\n\t\tif (is_all_added)\n\t\t\tvport->overflow_promisc_flags &= ~HNAE3_OVERFLOW_MPE;\n\t\telse\n\t\t\tvport->overflow_promisc_flags |= HNAE3_OVERFLOW_MPE;\n\t}\n}\n\nstatic void hclge_sync_vport_mac_table(struct hclge_vport *vport,\n\t\t\t\t       enum HCLGE_MAC_ADDR_TYPE mac_type)\n{\n\tstruct hclge_mac_node *mac_node, *tmp, *new_node;\n\tstruct list_head tmp_add_list, tmp_del_list;\n\tstruct list_head *list;\n\tbool all_added;\n\n\tINIT_LIST_HEAD(&tmp_add_list);\n\tINIT_LIST_HEAD(&tmp_del_list);\n\n\t \n\tlist = (mac_type == HCLGE_MAC_ADDR_UC) ?\n\t\t&vport->uc_mac_list : &vport->mc_mac_list;\n\n\tspin_lock_bh(&vport->mac_list_lock);\n\n\tlist_for_each_entry_safe(mac_node, tmp, list, node) {\n\t\tswitch (mac_node->state) {\n\t\tcase HCLGE_MAC_TO_DEL:\n\t\t\tlist_move_tail(&mac_node->node, &tmp_del_list);\n\t\t\tbreak;\n\t\tcase HCLGE_MAC_TO_ADD:\n\t\t\tnew_node = kzalloc(sizeof(*new_node), GFP_ATOMIC);\n\t\t\tif (!new_node)\n\t\t\t\tgoto stop_traverse;\n\t\t\tether_addr_copy(new_node->mac_addr, mac_node->mac_addr);\n\t\t\tnew_node->state = mac_node->state;\n\t\t\tlist_add_tail(&new_node->node, &tmp_add_list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nstop_traverse:\n\tspin_unlock_bh(&vport->mac_list_lock);\n\n\t \n\thclge_unsync_vport_mac_list(vport, &tmp_del_list, mac_type);\n\thclge_sync_vport_mac_list(vport, &tmp_add_list, mac_type);\n\n\t \n\tspin_lock_bh(&vport->mac_list_lock);\n\n\thclge_sync_from_del_list(&tmp_del_list, list);\n\tall_added = hclge_sync_from_add_list(&tmp_add_list, list);\n\n\tspin_unlock_bh(&vport->mac_list_lock);\n\n\thclge_update_overflow_flags(vport, mac_type, all_added);\n}\n\nstatic bool hclge_need_sync_mac_table(struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (test_bit(vport->vport_id, hdev->vport_config_block))\n\t\treturn false;\n\n\tif (test_and_clear_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void hclge_sync_mac_table(struct hclge_dev *hdev)\n{\n\tint i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tstruct hclge_vport *vport = &hdev->vport[i];\n\n\t\tif (!hclge_need_sync_mac_table(vport))\n\t\t\tcontinue;\n\n\t\thclge_sync_vport_mac_table(vport, HCLGE_MAC_ADDR_UC);\n\t\thclge_sync_vport_mac_table(vport, HCLGE_MAC_ADDR_MC);\n\t}\n}\n\nstatic void hclge_build_del_list(struct list_head *list,\n\t\t\t\t bool is_del_list,\n\t\t\t\t struct list_head *tmp_del_list)\n{\n\tstruct hclge_mac_node *mac_cfg, *tmp;\n\n\tlist_for_each_entry_safe(mac_cfg, tmp, list, node) {\n\t\tswitch (mac_cfg->state) {\n\t\tcase HCLGE_MAC_TO_DEL:\n\t\tcase HCLGE_MAC_ACTIVE:\n\t\t\tlist_move_tail(&mac_cfg->node, tmp_del_list);\n\t\t\tbreak;\n\t\tcase HCLGE_MAC_TO_ADD:\n\t\t\tif (is_del_list) {\n\t\t\t\tlist_del(&mac_cfg->node);\n\t\t\t\tkfree(mac_cfg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void hclge_unsync_del_list(struct hclge_vport *vport,\n\t\t\t\t  int (*unsync)(struct hclge_vport *vport,\n\t\t\t\t\t\tconst unsigned char *addr),\n\t\t\t\t  bool is_del_list,\n\t\t\t\t  struct list_head *tmp_del_list)\n{\n\tstruct hclge_mac_node *mac_cfg, *tmp;\n\tint ret;\n\n\tlist_for_each_entry_safe(mac_cfg, tmp, tmp_del_list, node) {\n\t\tret = unsync(vport, mac_cfg->mac_addr);\n\t\tif (!ret || ret == -ENOENT) {\n\t\t\t \n\t\t\tif (!is_del_list &&\n\t\t\t    mac_cfg->state == HCLGE_MAC_ACTIVE) {\n\t\t\t\tmac_cfg->state = HCLGE_MAC_TO_ADD;\n\t\t\t} else {\n\t\t\t\tlist_del(&mac_cfg->node);\n\t\t\t\tkfree(mac_cfg);\n\t\t\t}\n\t\t} else if (is_del_list) {\n\t\t\tmac_cfg->state = HCLGE_MAC_TO_DEL;\n\t\t}\n\t}\n}\n\nvoid hclge_rm_vport_all_mac_table(struct hclge_vport *vport, bool is_del_list,\n\t\t\t\t  enum HCLGE_MAC_ADDR_TYPE mac_type)\n{\n\tint (*unsync)(struct hclge_vport *vport, const unsigned char *addr);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct list_head tmp_del_list, *list;\n\n\tif (mac_type == HCLGE_MAC_ADDR_UC) {\n\t\tlist = &vport->uc_mac_list;\n\t\tunsync = hclge_rm_uc_addr_common;\n\t} else {\n\t\tlist = &vport->mc_mac_list;\n\t\tunsync = hclge_rm_mc_addr_common;\n\t}\n\n\tINIT_LIST_HEAD(&tmp_del_list);\n\n\tif (!is_del_list)\n\t\tset_bit(vport->vport_id, hdev->vport_config_block);\n\n\tspin_lock_bh(&vport->mac_list_lock);\n\n\thclge_build_del_list(list, is_del_list, &tmp_del_list);\n\n\tspin_unlock_bh(&vport->mac_list_lock);\n\n\thclge_unsync_del_list(vport, unsync, is_del_list, &tmp_del_list);\n\n\tspin_lock_bh(&vport->mac_list_lock);\n\n\thclge_sync_from_del_list(&tmp_del_list, list);\n\n\tspin_unlock_bh(&vport->mac_list_lock);\n}\n\n \nstatic void hclge_uninit_vport_mac_list(struct hclge_vport *vport,\n\t\t\t\t\tenum HCLGE_MAC_ADDR_TYPE mac_type)\n{\n\tstruct hclge_mac_node *mac_node, *tmp;\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct list_head tmp_del_list, *list;\n\n\tINIT_LIST_HEAD(&tmp_del_list);\n\n\tlist = (mac_type == HCLGE_MAC_ADDR_UC) ?\n\t\t&vport->uc_mac_list : &vport->mc_mac_list;\n\n\tspin_lock_bh(&vport->mac_list_lock);\n\n\tlist_for_each_entry_safe(mac_node, tmp, list, node) {\n\t\tswitch (mac_node->state) {\n\t\tcase HCLGE_MAC_TO_DEL:\n\t\tcase HCLGE_MAC_ACTIVE:\n\t\t\tlist_move_tail(&mac_node->node, &tmp_del_list);\n\t\t\tbreak;\n\t\tcase HCLGE_MAC_TO_ADD:\n\t\t\tlist_del(&mac_node->node);\n\t\t\tkfree(mac_node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&vport->mac_list_lock);\n\n\thclge_unsync_vport_mac_list(vport, &tmp_del_list, mac_type);\n\n\tif (!list_empty(&tmp_del_list))\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"uninit %s mac list for vport %u not completely.\\n\",\n\t\t\t mac_type == HCLGE_MAC_ADDR_UC ? \"uc\" : \"mc\",\n\t\t\t vport->vport_id);\n\n\tlist_for_each_entry_safe(mac_node, tmp, &tmp_del_list, node) {\n\t\tlist_del(&mac_node->node);\n\t\tkfree(mac_node);\n\t}\n}\n\nstatic void hclge_uninit_mac_table(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport;\n\tint i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tvport = &hdev->vport[i];\n\t\thclge_uninit_vport_mac_list(vport, HCLGE_MAC_ADDR_UC);\n\t\thclge_uninit_vport_mac_list(vport, HCLGE_MAC_ADDR_MC);\n\t}\n}\n\nstatic int hclge_get_mac_ethertype_cmd_status(struct hclge_dev *hdev,\n\t\t\t\t\t      u16 cmdq_resp, u8 resp_code)\n{\n#define HCLGE_ETHERTYPE_SUCCESS_ADD\t\t0\n#define HCLGE_ETHERTYPE_ALREADY_ADD\t\t1\n#define HCLGE_ETHERTYPE_MGR_TBL_OVERFLOW\t2\n#define HCLGE_ETHERTYPE_KEY_CONFLICT\t\t3\n\n\tint return_status;\n\n\tif (cmdq_resp) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"cmdq execute failed for get_mac_ethertype_cmd_status, status=%u.\\n\",\n\t\t\tcmdq_resp);\n\t\treturn -EIO;\n\t}\n\n\tswitch (resp_code) {\n\tcase HCLGE_ETHERTYPE_SUCCESS_ADD:\n\tcase HCLGE_ETHERTYPE_ALREADY_ADD:\n\t\treturn_status = 0;\n\t\tbreak;\n\tcase HCLGE_ETHERTYPE_MGR_TBL_OVERFLOW:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"add mac ethertype failed for manager table overflow.\\n\");\n\t\treturn_status = -EIO;\n\t\tbreak;\n\tcase HCLGE_ETHERTYPE_KEY_CONFLICT:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"add mac ethertype failed for key conflict.\\n\");\n\t\treturn_status = -EIO;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"add mac ethertype failed for undefined, code=%u.\\n\",\n\t\t\tresp_code);\n\t\treturn_status = -EIO;\n\t}\n\n\treturn return_status;\n}\n\nstatic int hclge_set_vf_mac(struct hnae3_handle *handle, int vf,\n\t\t\t    u8 *mac_addr)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hclge_dev *hdev = vport->back;\n\n\tvport = hclge_get_vf_vport(hdev, vf);\n\tif (!vport)\n\t\treturn -EINVAL;\n\n\thnae3_format_mac_addr(format_mac_addr, mac_addr);\n\tif (ether_addr_equal(mac_addr, vport->vf_info.mac)) {\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"Specified MAC(=%s) is same as before, no change committed!\\n\",\n\t\t\t format_mac_addr);\n\t\treturn 0;\n\t}\n\n\tether_addr_copy(vport->vf_info.mac, mac_addr);\n\n\t \n\tif (test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state)) {\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"MAC of VF %d has been set to %s, and it will be reinitialized!\\n\",\n\t\t\t vf, format_mac_addr);\n\t\t(void)hclge_inform_reset_assert_to_vf(vport);\n\t\treturn 0;\n\t}\n\n\tdev_info(&hdev->pdev->dev,\n\t\t \"MAC of VF %d has been set to %s, will be active after VF reset\\n\",\n\t\t vf, format_mac_addr);\n\treturn 0;\n}\n\nstatic int hclge_add_mgr_tbl(struct hclge_dev *hdev,\n\t\t\t     const struct hclge_mac_mgr_tbl_entry_cmd *req)\n{\n\tstruct hclge_desc desc;\n\tu8 resp_code;\n\tu16 retval;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_ETHTYPE_ADD, false);\n\tmemcpy(desc.data, req, sizeof(struct hclge_mac_mgr_tbl_entry_cmd));\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"add mac ethertype failed for cmd_send, ret =%d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tresp_code = (le32_to_cpu(desc.data[0]) >> 8) & 0xff;\n\tretval = le16_to_cpu(desc.retval);\n\n\treturn hclge_get_mac_ethertype_cmd_status(hdev, retval, resp_code);\n}\n\nstatic int init_mgr_tbl(struct hclge_dev *hdev)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hclge_mgr_table); i++) {\n\t\tret = hclge_add_mgr_tbl(hdev, &hclge_mgr_table[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"add mac ethertype failed, ret =%d.\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hclge_get_mac_addr(struct hnae3_handle *handle, u8 *p)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tether_addr_copy(p, hdev->hw.mac.mac_addr);\n}\n\nint hclge_update_mac_node_for_dev_addr(struct hclge_vport *vport,\n\t\t\t\t       const u8 *old_addr, const u8 *new_addr)\n{\n\tstruct list_head *list = &vport->uc_mac_list;\n\tstruct hclge_mac_node *old_node, *new_node;\n\n\tnew_node = hclge_find_mac_node(list, new_addr);\n\tif (!new_node) {\n\t\tnew_node = kzalloc(sizeof(*new_node), GFP_ATOMIC);\n\t\tif (!new_node)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_node->state = HCLGE_MAC_TO_ADD;\n\t\tether_addr_copy(new_node->mac_addr, new_addr);\n\t\tlist_add(&new_node->node, list);\n\t} else {\n\t\tif (new_node->state == HCLGE_MAC_TO_DEL)\n\t\t\tnew_node->state = HCLGE_MAC_ACTIVE;\n\n\t\t \n\t\tlist_move(&new_node->node, list);\n\t}\n\n\tif (old_addr && !ether_addr_equal(old_addr, new_addr)) {\n\t\told_node = hclge_find_mac_node(list, old_addr);\n\t\tif (old_node) {\n\t\t\tif (old_node->state == HCLGE_MAC_TO_ADD) {\n\t\t\t\tlist_del(&old_node->node);\n\t\t\t\tkfree(old_node);\n\t\t\t} else {\n\t\t\t\told_node->state = HCLGE_MAC_TO_DEL;\n\t\t\t}\n\t\t}\n\t}\n\n\tset_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);\n\n\treturn 0;\n}\n\nstatic int hclge_set_mac_addr(struct hnae3_handle *handle, const void *p,\n\t\t\t      bool is_first)\n{\n\tconst unsigned char *new_addr = (const unsigned char *)p;\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hclge_dev *hdev = vport->back;\n\tunsigned char *old_addr = NULL;\n\tint ret;\n\n\t \n\tif (is_zero_ether_addr(new_addr) ||\n\t    is_broadcast_ether_addr(new_addr) ||\n\t    is_multicast_ether_addr(new_addr)) {\n\t\thnae3_format_mac_addr(format_mac_addr, new_addr);\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"change uc mac err! invalid mac: %s.\\n\",\n\t\t\t format_mac_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tret = hclge_pause_addr_cfg(hdev, new_addr);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to configure mac pause address, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (!is_first)\n\t\told_addr = hdev->hw.mac.mac_addr;\n\n\tspin_lock_bh(&vport->mac_list_lock);\n\tret = hclge_update_mac_node_for_dev_addr(vport, old_addr, new_addr);\n\tif (ret) {\n\t\thnae3_format_mac_addr(format_mac_addr, new_addr);\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to change the mac addr:%s, ret = %d\\n\",\n\t\t\tformat_mac_addr, ret);\n\t\tspin_unlock_bh(&vport->mac_list_lock);\n\n\t\tif (!is_first)\n\t\t\thclge_pause_addr_cfg(hdev, old_addr);\n\n\t\treturn ret;\n\t}\n\t \n\tether_addr_copy(hdev->hw.mac.mac_addr, new_addr);\n\tspin_unlock_bh(&vport->mac_list_lock);\n\n\thclge_task_schedule(hdev, 0);\n\n\treturn 0;\n}\n\nstatic int hclge_mii_ioctl(struct hclge_dev *hdev, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\tif (!hnae3_dev_phy_imp_supported(hdev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = hdev->hw.mac.phy_addr;\n\t\t \n\t\tfallthrough;\n\tcase SIOCGMIIREG:\n\t\tdata->val_out = hclge_read_phy_reg(hdev, data->reg_num);\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\n\t\treturn hclge_write_phy_reg(hdev, data->reg_num, data->val_in);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int hclge_do_ioctl(struct hnae3_handle *handle, struct ifreq *ifr,\n\t\t\t  int cmd)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tswitch (cmd) {\n\tcase SIOCGHWTSTAMP:\n\t\treturn hclge_ptp_get_cfg(hdev, ifr);\n\tcase SIOCSHWTSTAMP:\n\t\treturn hclge_ptp_set_cfg(hdev, ifr);\n\tdefault:\n\t\tif (!hdev->hw.mac.phydev)\n\t\t\treturn hclge_mii_ioctl(hdev, ifr, cmd);\n\t}\n\n\treturn phy_mii_ioctl(hdev->hw.mac.phydev, ifr, cmd);\n}\n\nstatic int hclge_set_port_vlan_filter_bypass(struct hclge_dev *hdev, u8 vf_id,\n\t\t\t\t\t     bool bypass_en)\n{\n\tstruct hclge_port_vlan_filter_bypass_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PORT_VLAN_BYPASS, false);\n\treq = (struct hclge_port_vlan_filter_bypass_cmd *)desc.data;\n\treq->vf_id = vf_id;\n\thnae3_set_bit(req->bypass_state, HCLGE_INGRESS_BYPASS_B,\n\t\t      bypass_en ? 1 : 0);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set vport%u port vlan filter bypass state, ret = %d.\\n\",\n\t\t\tvf_id, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_set_vlan_filter_ctrl(struct hclge_dev *hdev, u8 vlan_type,\n\t\t\t\t      u8 fe_type, bool filter_en, u8 vf_id)\n{\n\tstruct hclge_vlan_filter_ctrl_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_FILTER_CTRL, true);\n\treq = (struct hclge_vlan_filter_ctrl_cmd *)desc.data;\n\treq->vlan_type = vlan_type;\n\treq->vf_id = vf_id;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"failed to get vport%u vlan filter config, ret = %d.\\n\",\n\t\t\tvf_id, ret);\n\t\treturn ret;\n\t}\n\n\t \n\thclge_comm_cmd_reuse_desc(&desc, false);\n\treq->vlan_fe = filter_en ?\n\t\t\t(req->vlan_fe | fe_type) : (req->vlan_fe & ~fe_type);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"failed to set vport%u vlan filter, ret = %d.\\n\",\n\t\t\tvf_id, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_set_vport_vlan_filter(struct hclge_vport *vport, bool enable)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hnae3_ae_dev *ae_dev = hdev->ae_dev;\n\tint ret;\n\n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\treturn hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,\n\t\t\t\t\t\t  HCLGE_FILTER_FE_EGRESS_V1_B,\n\t\t\t\t\t\t  enable, vport->vport_id);\n\n\tret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,\n\t\t\t\t\t HCLGE_FILTER_FE_EGRESS, enable,\n\t\t\t\t\t vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_PORT_VLAN_BYPASS_B, ae_dev->caps)) {\n\t\tret = hclge_set_port_vlan_filter_bypass(hdev, vport->vport_id,\n\t\t\t\t\t\t\t!enable);\n\t} else if (!vport->vport_id) {\n\t\tif (test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, ae_dev->caps))\n\t\t\tenable = false;\n\n\t\tret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_PORT,\n\t\t\t\t\t\t HCLGE_FILTER_FE_INGRESS,\n\t\t\t\t\t\t enable, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic bool hclge_need_enable_vport_vlan_filter(struct hclge_vport *vport)\n{\n\tstruct hnae3_handle *handle = &vport->nic;\n\tstruct hclge_vport_vlan_cfg *vlan, *tmp;\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (vport->vport_id) {\n\t\tif (vport->port_base_vlan_cfg.state !=\n\t\t\tHNAE3_PORT_BASE_VLAN_DISABLE)\n\t\t\treturn true;\n\n\t\tif (vport->vf_info.trusted && vport->vf_info.request_uc_en)\n\t\t\treturn false;\n\t} else if (handle->netdev_flags & HNAE3_USER_UPE) {\n\t\treturn false;\n\t}\n\n\tif (!vport->req_vlan_fltr_en)\n\t\treturn false;\n\n\t \n\tif (!test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, hdev->ae_dev->caps))\n\t\treturn true;\n\n\tlist_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node)\n\t\tif (vlan->vlan_id != 0)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint hclge_enable_vport_vlan_filter(struct hclge_vport *vport, bool request_en)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tbool need_en;\n\tint ret;\n\n\tmutex_lock(&hdev->vport_lock);\n\n\tvport->req_vlan_fltr_en = request_en;\n\n\tneed_en = hclge_need_enable_vport_vlan_filter(vport);\n\tif (need_en == vport->cur_vlan_fltr_en) {\n\t\tmutex_unlock(&hdev->vport_lock);\n\t\treturn 0;\n\t}\n\n\tret = hclge_set_vport_vlan_filter(vport, need_en);\n\tif (ret) {\n\t\tmutex_unlock(&hdev->vport_lock);\n\t\treturn ret;\n\t}\n\n\tvport->cur_vlan_fltr_en = need_en;\n\n\tmutex_unlock(&hdev->vport_lock);\n\n\treturn 0;\n}\n\nstatic int hclge_enable_vlan_filter(struct hnae3_handle *handle, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn hclge_enable_vport_vlan_filter(vport, enable);\n}\n\nstatic int hclge_set_vf_vlan_filter_cmd(struct hclge_dev *hdev, u16 vfid,\n\t\t\t\t\tbool is_kill, u16 vlan,\n\t\t\t\t\tstruct hclge_desc *desc)\n{\n\tstruct hclge_vlan_filter_vf_cfg_cmd *req0;\n\tstruct hclge_vlan_filter_vf_cfg_cmd *req1;\n\tu8 vf_byte_val;\n\tu8 vf_byte_off;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0],\n\t\t\t\t   HCLGE_OPC_VLAN_FILTER_VF_CFG, false);\n\thclge_cmd_setup_basic_desc(&desc[1],\n\t\t\t\t   HCLGE_OPC_VLAN_FILTER_VF_CFG, false);\n\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\n\tvf_byte_off = vfid / 8;\n\tvf_byte_val = 1 << (vfid % 8);\n\n\treq0 = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[0].data;\n\treq1 = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[1].data;\n\n\treq0->vlan_id  = cpu_to_le16(vlan);\n\treq0->vlan_cfg = is_kill;\n\n\tif (vf_byte_off < HCLGE_MAX_VF_BYTES)\n\t\treq0->vf_bitmap[vf_byte_off] = vf_byte_val;\n\telse\n\t\treq1->vf_bitmap[vf_byte_off - HCLGE_MAX_VF_BYTES] = vf_byte_val;\n\n\tret = hclge_cmd_send(&hdev->hw, desc, 2);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Send vf vlan command fail, ret =%d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_check_vf_vlan_cmd_status(struct hclge_dev *hdev, u16 vfid,\n\t\t\t\t\t  bool is_kill, struct hclge_desc *desc)\n{\n\tstruct hclge_vlan_filter_vf_cfg_cmd *req;\n\n\treq = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[0].data;\n\n\tif (!is_kill) {\n#define HCLGE_VF_VLAN_NO_ENTRY\t2\n\t\tif (!req->resp_code || req->resp_code == 1)\n\t\t\treturn 0;\n\n\t\tif (req->resp_code == HCLGE_VF_VLAN_NO_ENTRY) {\n\t\t\tset_bit(vfid, hdev->vf_vlan_full);\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"vf vlan table is full, vf vlan filter is disabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Add vf vlan filter fail, ret =%u.\\n\",\n\t\t\treq->resp_code);\n\t} else {\n#define HCLGE_VF_VLAN_DEL_NO_FOUND\t1\n\t\tif (!req->resp_code)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (req->resp_code == HCLGE_VF_VLAN_DEL_NO_FOUND)\n\t\t\treturn 0;\n\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Kill vf vlan filter fail, ret =%u.\\n\",\n\t\t\treq->resp_code);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int hclge_set_vf_vlan_common(struct hclge_dev *hdev, u16 vfid,\n\t\t\t\t    bool is_kill, u16 vlan)\n{\n\tstruct hclge_vport *vport = &hdev->vport[vfid];\n\tstruct hclge_desc desc[2];\n\tint ret;\n\n\t \n\tif (test_bit(vfid, hdev->vf_vlan_full) && !is_kill) {\n\t\tif (vport->vf_info.spoofchk && vlan) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"Can't add vlan due to spoof check is on and vf vlan table is full\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tret = hclge_set_vf_vlan_filter_cmd(hdev, vfid, is_kill, vlan, desc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_check_vf_vlan_cmd_status(hdev, vfid, is_kill, desc);\n}\n\nstatic int hclge_set_port_vlan_filter(struct hclge_dev *hdev, __be16 proto,\n\t\t\t\t      u16 vlan_id, bool is_kill)\n{\n\tstruct hclge_vlan_filter_pf_cfg_cmd *req;\n\tstruct hclge_desc desc;\n\tu8 vlan_offset_byte_val;\n\tu8 vlan_offset_byte;\n\tu8 vlan_offset_160;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_FILTER_PF_CFG, false);\n\n\tvlan_offset_160 = vlan_id / HCLGE_VLAN_ID_OFFSET_STEP;\n\tvlan_offset_byte = (vlan_id % HCLGE_VLAN_ID_OFFSET_STEP) /\n\t\t\t   HCLGE_VLAN_BYTE_SIZE;\n\tvlan_offset_byte_val = 1 << (vlan_id % HCLGE_VLAN_BYTE_SIZE);\n\n\treq = (struct hclge_vlan_filter_pf_cfg_cmd *)desc.data;\n\treq->vlan_offset = vlan_offset_160;\n\treq->vlan_cfg = is_kill;\n\treq->vlan_offset_bitmap[vlan_offset_byte] = vlan_offset_byte_val;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"port vlan command, send fail, ret =%d.\\n\", ret);\n\treturn ret;\n}\n\nstatic bool hclge_need_update_port_vlan(struct hclge_dev *hdev, u16 vport_id,\n\t\t\t\t\tu16 vlan_id, bool is_kill)\n{\n\t \n\tif (!is_kill && !vlan_id &&\n\t    test_bit(vport_id, hdev->vlan_table[vlan_id]))\n\t\treturn false;\n\n\tif (!is_kill && test_and_set_bit(vport_id, hdev->vlan_table[vlan_id])) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"Add port vlan failed, vport %u is already in vlan %u\\n\",\n\t\t\t vport_id, vlan_id);\n\t\treturn false;\n\t}\n\n\tif (is_kill &&\n\t    !test_and_clear_bit(vport_id, hdev->vlan_table[vlan_id])) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"Delete port vlan failed, vport %u is not in vlan %u\\n\",\n\t\t\t vport_id, vlan_id);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int hclge_set_vlan_filter_hw(struct hclge_dev *hdev, __be16 proto,\n\t\t\t\t    u16 vport_id, u16 vlan_id,\n\t\t\t\t    bool is_kill)\n{\n\tu16 vport_idx, vport_num = 0;\n\tint ret;\n\n\tif (is_kill && !vlan_id)\n\t\treturn 0;\n\n\tif (vlan_id >= VLAN_N_VID)\n\t\treturn -EINVAL;\n\n\tret = hclge_set_vf_vlan_common(hdev, vport_id, is_kill, vlan_id);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Set %u vport vlan filter config fail, ret =%d.\\n\",\n\t\t\tvport_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (!hclge_need_update_port_vlan(hdev, vport_id, vlan_id, is_kill))\n\t\treturn 0;\n\n\tfor_each_set_bit(vport_idx, hdev->vlan_table[vlan_id], HCLGE_VPORT_NUM)\n\t\tvport_num++;\n\n\tif ((is_kill && vport_num == 0) || (!is_kill && vport_num == 1))\n\t\tret = hclge_set_port_vlan_filter(hdev, proto, vlan_id,\n\t\t\t\t\t\t is_kill);\n\n\treturn ret;\n}\n\nstatic int hclge_set_vlan_tx_offload_cfg(struct hclge_vport *vport)\n{\n\tstruct hclge_tx_vtag_cfg *vcfg = &vport->txvlan_cfg;\n\tstruct hclge_vport_vtag_tx_cfg_cmd *req;\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_desc desc;\n\tu16 bmap_index;\n\tint status;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_TX_CFG, false);\n\n\treq = (struct hclge_vport_vtag_tx_cfg_cmd *)desc.data;\n\treq->def_vlan_tag1 = cpu_to_le16(vcfg->default_tag1);\n\treq->def_vlan_tag2 = cpu_to_le16(vcfg->default_tag2);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_TAG1_B,\n\t\t      vcfg->accept_tag1 ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_UNTAG1_B,\n\t\t      vcfg->accept_untag1 ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_TAG2_B,\n\t\t      vcfg->accept_tag2 ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_UNTAG2_B,\n\t\t      vcfg->accept_untag2 ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_PORT_INS_TAG1_EN_B,\n\t\t      vcfg->insert_tag1_en ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_PORT_INS_TAG2_EN_B,\n\t\t      vcfg->insert_tag2_en ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_TAG_SHIFT_MODE_EN_B,\n\t\t      vcfg->tag_shift_mode_en ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_CFG_NIC_ROCE_SEL_B, 0);\n\n\treq->vf_offset = vport->vport_id / HCLGE_VF_NUM_PER_CMD;\n\tbmap_index = vport->vport_id % HCLGE_VF_NUM_PER_CMD /\n\t\t\tHCLGE_VF_NUM_PER_BYTE;\n\treq->vf_bitmap[bmap_index] =\n\t\t1U << (vport->vport_id % HCLGE_VF_NUM_PER_BYTE);\n\n\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Send port txvlan cfg command fail, ret =%d\\n\",\n\t\t\tstatus);\n\n\treturn status;\n}\n\nstatic int hclge_set_vlan_rx_offload_cfg(struct hclge_vport *vport)\n{\n\tstruct hclge_rx_vtag_cfg *vcfg = &vport->rxvlan_cfg;\n\tstruct hclge_vport_vtag_rx_cfg_cmd *req;\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_desc desc;\n\tu16 bmap_index;\n\tint status;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_RX_CFG, false);\n\n\treq = (struct hclge_vport_vtag_rx_cfg_cmd *)desc.data;\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_REM_TAG1_EN_B,\n\t\t      vcfg->strip_tag1_en ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_REM_TAG2_EN_B,\n\t\t      vcfg->strip_tag2_en ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_SHOW_TAG1_EN_B,\n\t\t      vcfg->vlan1_vlan_prionly ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_SHOW_TAG2_EN_B,\n\t\t      vcfg->vlan2_vlan_prionly ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_DISCARD_TAG1_EN_B,\n\t\t      vcfg->strip_tag1_discard_en ? 1 : 0);\n\thnae3_set_bit(req->vport_vlan_cfg, HCLGE_DISCARD_TAG2_EN_B,\n\t\t      vcfg->strip_tag2_discard_en ? 1 : 0);\n\n\treq->vf_offset = vport->vport_id / HCLGE_VF_NUM_PER_CMD;\n\tbmap_index = vport->vport_id % HCLGE_VF_NUM_PER_CMD /\n\t\t\tHCLGE_VF_NUM_PER_BYTE;\n\treq->vf_bitmap[bmap_index] =\n\t\t1U << (vport->vport_id % HCLGE_VF_NUM_PER_BYTE);\n\n\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Send port rxvlan cfg command fail, ret =%d\\n\",\n\t\t\tstatus);\n\n\treturn status;\n}\n\nstatic int hclge_vlan_offload_cfg(struct hclge_vport *vport,\n\t\t\t\t  u16 port_base_vlan_state,\n\t\t\t\t  u16 vlan_tag, u8 qos)\n{\n\tint ret;\n\n\tif (port_base_vlan_state == HNAE3_PORT_BASE_VLAN_DISABLE) {\n\t\tvport->txvlan_cfg.accept_tag1 = true;\n\t\tvport->txvlan_cfg.insert_tag1_en = false;\n\t\tvport->txvlan_cfg.default_tag1 = 0;\n\t} else {\n\t\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(vport->nic.pdev);\n\n\t\tvport->txvlan_cfg.accept_tag1 =\n\t\t\tae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3;\n\t\tvport->txvlan_cfg.insert_tag1_en = true;\n\t\tvport->txvlan_cfg.default_tag1 = (qos << VLAN_PRIO_SHIFT) |\n\t\t\t\t\t\t vlan_tag;\n\t}\n\n\tvport->txvlan_cfg.accept_untag1 = true;\n\n\t \n\tvport->txvlan_cfg.accept_tag2 = true;\n\tvport->txvlan_cfg.accept_untag2 = true;\n\tvport->txvlan_cfg.insert_tag2_en = false;\n\tvport->txvlan_cfg.default_tag2 = 0;\n\tvport->txvlan_cfg.tag_shift_mode_en = true;\n\n\tif (port_base_vlan_state == HNAE3_PORT_BASE_VLAN_DISABLE) {\n\t\tvport->rxvlan_cfg.strip_tag1_en = false;\n\t\tvport->rxvlan_cfg.strip_tag2_en =\n\t\t\t\tvport->rxvlan_cfg.rx_vlan_offload_en;\n\t\tvport->rxvlan_cfg.strip_tag2_discard_en = false;\n\t} else {\n\t\tvport->rxvlan_cfg.strip_tag1_en =\n\t\t\t\tvport->rxvlan_cfg.rx_vlan_offload_en;\n\t\tvport->rxvlan_cfg.strip_tag2_en = true;\n\t\tvport->rxvlan_cfg.strip_tag2_discard_en = true;\n\t}\n\n\tvport->rxvlan_cfg.strip_tag1_discard_en = false;\n\tvport->rxvlan_cfg.vlan1_vlan_prionly = false;\n\tvport->rxvlan_cfg.vlan2_vlan_prionly = false;\n\n\tret = hclge_set_vlan_tx_offload_cfg(vport);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_set_vlan_rx_offload_cfg(vport);\n}\n\nstatic int hclge_set_vlan_protocol_type(struct hclge_dev *hdev)\n{\n\tstruct hclge_rx_vlan_type_cfg_cmd *rx_req;\n\tstruct hclge_tx_vlan_type_cfg_cmd *tx_req;\n\tstruct hclge_desc desc;\n\tint status;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_TYPE_ID, false);\n\trx_req = (struct hclge_rx_vlan_type_cfg_cmd *)desc.data;\n\trx_req->ot_fst_vlan_type =\n\t\tcpu_to_le16(hdev->vlan_type_cfg.rx_ot_fst_vlan_type);\n\trx_req->ot_sec_vlan_type =\n\t\tcpu_to_le16(hdev->vlan_type_cfg.rx_ot_sec_vlan_type);\n\trx_req->in_fst_vlan_type =\n\t\tcpu_to_le16(hdev->vlan_type_cfg.rx_in_fst_vlan_type);\n\trx_req->in_sec_vlan_type =\n\t\tcpu_to_le16(hdev->vlan_type_cfg.rx_in_sec_vlan_type);\n\n\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (status) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Send rxvlan protocol type command fail, ret =%d\\n\",\n\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_INSERT, false);\n\n\ttx_req = (struct hclge_tx_vlan_type_cfg_cmd *)desc.data;\n\ttx_req->ot_vlan_type = cpu_to_le16(hdev->vlan_type_cfg.tx_ot_vlan_type);\n\ttx_req->in_vlan_type = cpu_to_le16(hdev->vlan_type_cfg.tx_in_vlan_type);\n\n\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Send txvlan protocol type command fail, ret =%d\\n\",\n\t\t\tstatus);\n\n\treturn status;\n}\n\nstatic int hclge_init_vlan_filter(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport;\n\tint ret;\n\tint i;\n\n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\treturn hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,\n\t\t\t\t\t\t  HCLGE_FILTER_FE_EGRESS_V1_B,\n\t\t\t\t\t\t  true, 0);\n\n\t \n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tvport = &hdev->vport[i];\n\t\tret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,\n\t\t\t\t\t\t HCLGE_FILTER_FE_EGRESS, true,\n\t\t\t\t\t\t vport->vport_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tvport->cur_vlan_fltr_en = true;\n\t}\n\n\treturn hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_PORT,\n\t\t\t\t\t  HCLGE_FILTER_FE_INGRESS, true, 0);\n}\n\nstatic int hclge_init_vlan_type(struct hclge_dev *hdev)\n{\n\thdev->vlan_type_cfg.rx_in_fst_vlan_type = ETH_P_8021Q;\n\thdev->vlan_type_cfg.rx_in_sec_vlan_type = ETH_P_8021Q;\n\thdev->vlan_type_cfg.rx_ot_fst_vlan_type = ETH_P_8021Q;\n\thdev->vlan_type_cfg.rx_ot_sec_vlan_type = ETH_P_8021Q;\n\thdev->vlan_type_cfg.tx_ot_vlan_type = ETH_P_8021Q;\n\thdev->vlan_type_cfg.tx_in_vlan_type = ETH_P_8021Q;\n\n\treturn hclge_set_vlan_protocol_type(hdev);\n}\n\nstatic int hclge_init_vport_vlan_offload(struct hclge_dev *hdev)\n{\n\tstruct hclge_port_base_vlan_config *cfg;\n\tstruct hclge_vport *vport;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tvport = &hdev->vport[i];\n\t\tcfg = &vport->port_base_vlan_cfg;\n\n\t\tret = hclge_vlan_offload_cfg(vport, cfg->state,\n\t\t\t\t\t     cfg->vlan_info.vlan_tag,\n\t\t\t\t\t     cfg->vlan_info.qos);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int hclge_init_vlan_config(struct hclge_dev *hdev)\n{\n\tstruct hnae3_handle *handle = &hdev->vport[0].nic;\n\tint ret;\n\n\tret = hclge_init_vlan_filter(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_init_vlan_type(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_init_vport_vlan_offload(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_set_vlan_filter(handle, htons(ETH_P_8021Q), 0, false);\n}\n\nstatic void hclge_add_vport_vlan_table(struct hclge_vport *vport, u16 vlan_id,\n\t\t\t\t       bool writen_to_tbl)\n{\n\tstruct hclge_vport_vlan_cfg *vlan, *tmp;\n\tstruct hclge_dev *hdev = vport->back;\n\n\tmutex_lock(&hdev->vport_lock);\n\n\tlist_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {\n\t\tif (vlan->vlan_id == vlan_id) {\n\t\t\tmutex_unlock(&hdev->vport_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan) {\n\t\tmutex_unlock(&hdev->vport_lock);\n\t\treturn;\n\t}\n\n\tvlan->hd_tbl_status = writen_to_tbl;\n\tvlan->vlan_id = vlan_id;\n\n\tlist_add_tail(&vlan->node, &vport->vlan_list);\n\tmutex_unlock(&hdev->vport_lock);\n}\n\nstatic int hclge_add_vport_all_vlan_table(struct hclge_vport *vport)\n{\n\tstruct hclge_vport_vlan_cfg *vlan, *tmp;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tmutex_lock(&hdev->vport_lock);\n\n\tlist_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {\n\t\tif (!vlan->hd_tbl_status) {\n\t\t\tret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),\n\t\t\t\t\t\t       vport->vport_id,\n\t\t\t\t\t\t       vlan->vlan_id, false);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\t\"restore vport vlan list failed, ret=%d\\n\",\n\t\t\t\t\tret);\n\n\t\t\t\tmutex_unlock(&hdev->vport_lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tvlan->hd_tbl_status = true;\n\t}\n\n\tmutex_unlock(&hdev->vport_lock);\n\n\treturn 0;\n}\n\nstatic void hclge_rm_vport_vlan_table(struct hclge_vport *vport, u16 vlan_id,\n\t\t\t\t      bool is_write_tbl)\n{\n\tstruct hclge_vport_vlan_cfg *vlan, *tmp;\n\tstruct hclge_dev *hdev = vport->back;\n\n\tlist_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {\n\t\tif (vlan->vlan_id == vlan_id) {\n\t\t\tif (is_write_tbl && vlan->hd_tbl_status)\n\t\t\t\thclge_set_vlan_filter_hw(hdev,\n\t\t\t\t\t\t\t htons(ETH_P_8021Q),\n\t\t\t\t\t\t\t vport->vport_id,\n\t\t\t\t\t\t\t vlan_id,\n\t\t\t\t\t\t\t true);\n\n\t\t\tlist_del(&vlan->node);\n\t\t\tkfree(vlan);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid hclge_rm_vport_all_vlan_table(struct hclge_vport *vport, bool is_del_list)\n{\n\tstruct hclge_vport_vlan_cfg *vlan, *tmp;\n\tstruct hclge_dev *hdev = vport->back;\n\n\tmutex_lock(&hdev->vport_lock);\n\n\tlist_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {\n\t\tif (vlan->hd_tbl_status)\n\t\t\thclge_set_vlan_filter_hw(hdev,\n\t\t\t\t\t\t htons(ETH_P_8021Q),\n\t\t\t\t\t\t vport->vport_id,\n\t\t\t\t\t\t vlan->vlan_id,\n\t\t\t\t\t\t true);\n\n\t\tvlan->hd_tbl_status = false;\n\t\tif (is_del_list) {\n\t\t\tlist_del(&vlan->node);\n\t\t\tkfree(vlan);\n\t\t}\n\t}\n\tclear_bit(vport->vport_id, hdev->vf_vlan_full);\n\tmutex_unlock(&hdev->vport_lock);\n}\n\nvoid hclge_uninit_vport_vlan_table(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport_vlan_cfg *vlan, *tmp;\n\tstruct hclge_vport *vport;\n\tint i;\n\n\tmutex_lock(&hdev->vport_lock);\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tvport = &hdev->vport[i];\n\t\tlist_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {\n\t\t\tlist_del(&vlan->node);\n\t\t\tkfree(vlan);\n\t\t}\n\t}\n\n\tmutex_unlock(&hdev->vport_lock);\n}\n\nvoid hclge_restore_vport_port_base_vlan_config(struct hclge_dev *hdev)\n{\n\tstruct hclge_vlan_info *vlan_info;\n\tstruct hclge_vport *vport;\n\tu16 vlan_proto;\n\tu16 vlan_id;\n\tu16 state;\n\tint vf_id;\n\tint ret;\n\n\t \n\tfor (vf_id = 0; vf_id < hdev->num_alloc_vfs; vf_id++) {\n\t\tvport = &hdev->vport[vf_id + HCLGE_VF_VPORT_START_NUM];\n\t\tvlan_info = vport->port_base_vlan_cfg.tbl_sta ?\n\t\t\t    &vport->port_base_vlan_cfg.vlan_info :\n\t\t\t    &vport->port_base_vlan_cfg.old_vlan_info;\n\n\t\tvlan_id = vlan_info->vlan_tag;\n\t\tvlan_proto = vlan_info->vlan_proto;\n\t\tstate = vport->port_base_vlan_cfg.state;\n\n\t\tif (state != HNAE3_PORT_BASE_VLAN_DISABLE) {\n\t\t\tclear_bit(vport->vport_id, hdev->vlan_table[vlan_id]);\n\t\t\tret = hclge_set_vlan_filter_hw(hdev, htons(vlan_proto),\n\t\t\t\t\t\t       vport->vport_id,\n\t\t\t\t\t\t       vlan_id, false);\n\t\t\tvport->port_base_vlan_cfg.tbl_sta = ret == 0;\n\t\t}\n\t}\n}\n\nvoid hclge_restore_vport_vlan_table(struct hclge_vport *vport)\n{\n\tstruct hclge_vport_vlan_cfg *vlan, *tmp;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tmutex_lock(&hdev->vport_lock);\n\n\tif (vport->port_base_vlan_cfg.state == HNAE3_PORT_BASE_VLAN_DISABLE) {\n\t\tlist_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {\n\t\t\tret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),\n\t\t\t\t\t\t       vport->vport_id,\n\t\t\t\t\t\t       vlan->vlan_id, false);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tvlan->hd_tbl_status = true;\n\t\t}\n\t}\n\n\tmutex_unlock(&hdev->vport_lock);\n}\n\n \nstatic void hclge_mac_node_convert_for_reset(struct list_head *list)\n{\n\tstruct hclge_mac_node *mac_node, *tmp;\n\n\tlist_for_each_entry_safe(mac_node, tmp, list, node) {\n\t\tif (mac_node->state == HCLGE_MAC_ACTIVE) {\n\t\t\tmac_node->state = HCLGE_MAC_TO_ADD;\n\t\t} else if (mac_node->state == HCLGE_MAC_TO_DEL) {\n\t\t\tlist_del(&mac_node->node);\n\t\t\tkfree(mac_node);\n\t\t}\n\t}\n}\n\nvoid hclge_restore_mac_table_common(struct hclge_vport *vport)\n{\n\tspin_lock_bh(&vport->mac_list_lock);\n\n\thclge_mac_node_convert_for_reset(&vport->uc_mac_list);\n\thclge_mac_node_convert_for_reset(&vport->mc_mac_list);\n\tset_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);\n\n\tspin_unlock_bh(&vport->mac_list_lock);\n}\n\nstatic void hclge_restore_hw_table(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport = &hdev->vport[0];\n\tstruct hnae3_handle *handle = &vport->nic;\n\n\thclge_restore_mac_table_common(vport);\n\thclge_restore_vport_port_base_vlan_config(hdev);\n\thclge_restore_vport_vlan_table(vport);\n\tset_bit(HCLGE_STATE_FD_USER_DEF_CHANGED, &hdev->state);\n\thclge_restore_fd_entries(handle);\n}\n\nint hclge_en_hw_strip_rxvtag(struct hnae3_handle *handle, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\tif (vport->port_base_vlan_cfg.state == HNAE3_PORT_BASE_VLAN_DISABLE) {\n\t\tvport->rxvlan_cfg.strip_tag1_en = false;\n\t\tvport->rxvlan_cfg.strip_tag2_en = enable;\n\t\tvport->rxvlan_cfg.strip_tag2_discard_en = false;\n\t} else {\n\t\tvport->rxvlan_cfg.strip_tag1_en = enable;\n\t\tvport->rxvlan_cfg.strip_tag2_en = true;\n\t\tvport->rxvlan_cfg.strip_tag2_discard_en = true;\n\t}\n\n\tvport->rxvlan_cfg.strip_tag1_discard_en = false;\n\tvport->rxvlan_cfg.vlan1_vlan_prionly = false;\n\tvport->rxvlan_cfg.vlan2_vlan_prionly = false;\n\tvport->rxvlan_cfg.rx_vlan_offload_en = enable;\n\n\treturn hclge_set_vlan_rx_offload_cfg(vport);\n}\n\nstatic void hclge_set_vport_vlan_fltr_change(struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, hdev->ae_dev->caps))\n\t\tset_bit(HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE, &vport->state);\n}\n\nstatic int hclge_update_vlan_filter_entries(struct hclge_vport *vport,\n\t\t\t\t\t    u16 port_base_vlan_state,\n\t\t\t\t\t    struct hclge_vlan_info *new_info,\n\t\t\t\t\t    struct hclge_vlan_info *old_info)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tif (port_base_vlan_state == HNAE3_PORT_BASE_VLAN_ENABLE) {\n\t\thclge_rm_vport_all_vlan_table(vport, false);\n\t\t \n\t\tret = hclge_set_vf_vlan_common(hdev, vport->vport_id, true, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn hclge_set_vlan_filter_hw(hdev,\n\t\t\t\t\t\t htons(new_info->vlan_proto),\n\t\t\t\t\t\t vport->vport_id,\n\t\t\t\t\t\t new_info->vlan_tag,\n\t\t\t\t\t\t false);\n\t}\n\n\tvport->port_base_vlan_cfg.tbl_sta = false;\n\n\t \n\tret = hclge_set_vf_vlan_common(hdev, vport->vport_id, false, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_set_vlan_filter_hw(hdev, htons(old_info->vlan_proto),\n\t\t\t\t       vport->vport_id, old_info->vlan_tag,\n\t\t\t\t       true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_add_vport_all_vlan_table(vport);\n}\n\nstatic bool hclge_need_update_vlan_filter(const struct hclge_vlan_info *new_cfg,\n\t\t\t\t\t  const struct hclge_vlan_info *old_cfg)\n{\n\tif (new_cfg->vlan_tag != old_cfg->vlan_tag)\n\t\treturn true;\n\n\tif (new_cfg->vlan_tag == 0 && (new_cfg->qos == 0 || old_cfg->qos == 0))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int hclge_modify_port_base_vlan_tag(struct hclge_vport *vport,\n\t\t\t\t\t   struct hclge_vlan_info *new_info,\n\t\t\t\t\t   struct hclge_vlan_info *old_info)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\t \n\tret = hclge_set_vlan_filter_hw(hdev, htons(new_info->vlan_proto),\n\t\t\t\t       vport->vport_id, new_info->vlan_tag,\n\t\t\t\t       false);\n\tif (ret)\n\t\treturn ret;\n\n\tvport->port_base_vlan_cfg.tbl_sta = false;\n\t \n\tif (old_info->vlan_tag == 0)\n\t\tret = hclge_set_vf_vlan_common(hdev, vport->vport_id,\n\t\t\t\t\t       true, 0);\n\telse\n\t\tret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),\n\t\t\t\t\t       vport->vport_id,\n\t\t\t\t\t       old_info->vlan_tag, true);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to clear vport%u port base vlan %u, ret = %d.\\n\",\n\t\t\tvport->vport_id, old_info->vlan_tag, ret);\n\n\treturn ret;\n}\n\nint hclge_update_port_base_vlan_cfg(struct hclge_vport *vport, u16 state,\n\t\t\t\t    struct hclge_vlan_info *vlan_info)\n{\n\tstruct hnae3_handle *nic = &vport->nic;\n\tstruct hclge_vlan_info *old_vlan_info;\n\tint ret;\n\n\told_vlan_info = &vport->port_base_vlan_cfg.vlan_info;\n\n\tret = hclge_vlan_offload_cfg(vport, state, vlan_info->vlan_tag,\n\t\t\t\t     vlan_info->qos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!hclge_need_update_vlan_filter(vlan_info, old_vlan_info))\n\t\tgoto out;\n\n\tif (state == HNAE3_PORT_BASE_VLAN_MODIFY)\n\t\tret = hclge_modify_port_base_vlan_tag(vport, vlan_info,\n\t\t\t\t\t\t      old_vlan_info);\n\telse\n\t\tret = hclge_update_vlan_filter_entries(vport, state, vlan_info,\n\t\t\t\t\t\t       old_vlan_info);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tvport->port_base_vlan_cfg.state = state;\n\tif (state == HNAE3_PORT_BASE_VLAN_DISABLE)\n\t\tnic->port_base_vlan_state = HNAE3_PORT_BASE_VLAN_DISABLE;\n\telse\n\t\tnic->port_base_vlan_state = HNAE3_PORT_BASE_VLAN_ENABLE;\n\n\tvport->port_base_vlan_cfg.old_vlan_info = *old_vlan_info;\n\tvport->port_base_vlan_cfg.vlan_info = *vlan_info;\n\tvport->port_base_vlan_cfg.tbl_sta = true;\n\thclge_set_vport_vlan_fltr_change(vport);\n\n\treturn 0;\n}\n\nstatic u16 hclge_get_port_base_vlan_state(struct hclge_vport *vport,\n\t\t\t\t\t  enum hnae3_port_base_vlan_state state,\n\t\t\t\t\t  u16 vlan, u8 qos)\n{\n\tif (state == HNAE3_PORT_BASE_VLAN_DISABLE) {\n\t\tif (!vlan && !qos)\n\t\t\treturn HNAE3_PORT_BASE_VLAN_NOCHANGE;\n\n\t\treturn HNAE3_PORT_BASE_VLAN_ENABLE;\n\t}\n\n\tif (!vlan && !qos)\n\t\treturn HNAE3_PORT_BASE_VLAN_DISABLE;\n\n\tif (vport->port_base_vlan_cfg.vlan_info.vlan_tag == vlan &&\n\t    vport->port_base_vlan_cfg.vlan_info.qos == qos)\n\t\treturn HNAE3_PORT_BASE_VLAN_NOCHANGE;\n\n\treturn HNAE3_PORT_BASE_VLAN_MODIFY;\n}\n\nstatic int hclge_set_vf_vlan_filter(struct hnae3_handle *handle, int vfid,\n\t\t\t\t    u16 vlan, u8 qos, __be16 proto)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_vlan_info vlan_info;\n\tu16 state;\n\tint ret;\n\n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\treturn -EOPNOTSUPP;\n\n\tvport = hclge_get_vf_vport(hdev, vfid);\n\tif (!vport)\n\t\treturn -EINVAL;\n\n\t \n\tif (vlan > VLAN_N_VID - 1 || qos > 7)\n\t\treturn -EINVAL;\n\tif (proto != htons(ETH_P_8021Q))\n\t\treturn -EPROTONOSUPPORT;\n\n\tstate = hclge_get_port_base_vlan_state(vport,\n\t\t\t\t\t       vport->port_base_vlan_cfg.state,\n\t\t\t\t\t       vlan, qos);\n\tif (state == HNAE3_PORT_BASE_VLAN_NOCHANGE)\n\t\treturn 0;\n\n\tvlan_info.vlan_tag = vlan;\n\tvlan_info.qos = qos;\n\tvlan_info.vlan_proto = ntohs(proto);\n\n\tret = hclge_update_port_base_vlan_cfg(vport, state, &vlan_info);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to update port base vlan for vf %d, ret = %d\\n\",\n\t\t\tvfid, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ae_dev->dev_version < HNAE3_DEVICE_VERSION_V3) {\n\t\tif (test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state))\n\t\t\t(void)hclge_push_vf_port_base_vlan_info(&hdev->vport[0],\n\t\t\t\t\t\t\t\tvport->vport_id,\n\t\t\t\t\t\t\t\tstate,\n\t\t\t\t\t\t\t\t&vlan_info);\n\t\telse\n\t\t\tset_bit(HCLGE_VPORT_NEED_NOTIFY_VF_VLAN,\n\t\t\t\t&vport->need_notify);\n\t}\n\treturn 0;\n}\n\nstatic void hclge_clear_vf_vlan(struct hclge_dev *hdev)\n{\n\tstruct hclge_vlan_info *vlan_info;\n\tstruct hclge_vport *vport;\n\tint ret;\n\tint vf;\n\n\t \n\tfor (vf = HCLGE_VF_VPORT_START_NUM; vf < hdev->num_alloc_vport; vf++) {\n\t\tvport = &hdev->vport[vf];\n\t\tvlan_info = &vport->port_base_vlan_cfg.vlan_info;\n\n\t\tret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),\n\t\t\t\t\t       vport->vport_id,\n\t\t\t\t\t       vlan_info->vlan_tag, true);\n\t\tif (ret)\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to clear vf vlan for vf%d, ret = %d\\n\",\n\t\t\t\tvf - HCLGE_VF_VPORT_START_NUM, ret);\n\t}\n}\n\nint hclge_set_vlan_filter(struct hnae3_handle *handle, __be16 proto,\n\t\t\t  u16 vlan_id, bool is_kill)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tbool writen_to_tbl = false;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&hdev->vport_lock);\n\tif ((test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state) ||\n\t     test_bit(HCLGE_STATE_RST_FAIL, &hdev->state)) && is_kill) {\n\t\tset_bit(vlan_id, vport->vlan_del_fail_bmap);\n\t\tmutex_unlock(&hdev->vport_lock);\n\t\treturn -EBUSY;\n\t} else if (!is_kill && test_bit(vlan_id, vport->vlan_del_fail_bmap)) {\n\t\tclear_bit(vlan_id, vport->vlan_del_fail_bmap);\n\t}\n\tmutex_unlock(&hdev->vport_lock);\n\n\t \n\tif (handle->port_base_vlan_state == HNAE3_PORT_BASE_VLAN_DISABLE) {\n\t\tret = hclge_set_vlan_filter_hw(hdev, proto, vport->vport_id,\n\t\t\t\t\t       vlan_id, is_kill);\n\t\twriten_to_tbl = true;\n\t}\n\n\tif (!ret) {\n\t\tif (!is_kill) {\n\t\t\thclge_add_vport_vlan_table(vport, vlan_id,\n\t\t\t\t\t\t   writen_to_tbl);\n\t\t} else if (is_kill && vlan_id != 0) {\n\t\t\tmutex_lock(&hdev->vport_lock);\n\t\t\thclge_rm_vport_vlan_table(vport, vlan_id, false);\n\t\t\tmutex_unlock(&hdev->vport_lock);\n\t\t}\n\t} else if (is_kill) {\n\t\t \n\t\tmutex_lock(&hdev->vport_lock);\n\t\tset_bit(vlan_id, vport->vlan_del_fail_bmap);\n\t\tmutex_unlock(&hdev->vport_lock);\n\t}\n\n\thclge_set_vport_vlan_fltr_change(vport);\n\n\treturn ret;\n}\n\nstatic void hclge_sync_vlan_fltr_state(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport;\n\tint ret;\n\tu16 i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tvport = &hdev->vport[i];\n\t\tif (!test_and_clear_bit(HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE,\n\t\t\t\t\t&vport->state))\n\t\t\tcontinue;\n\n\t\tret = hclge_enable_vport_vlan_filter(vport,\n\t\t\t\t\t\t     vport->req_vlan_fltr_en);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to sync vlan filter state for vport%u, ret = %d\\n\",\n\t\t\t\tvport->vport_id, ret);\n\t\t\tset_bit(HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE,\n\t\t\t\t&vport->state);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void hclge_sync_vlan_filter(struct hclge_dev *hdev)\n{\n#define HCLGE_MAX_SYNC_COUNT\t60\n\n\tint i, ret, sync_cnt = 0;\n\tu16 vlan_id;\n\n\tmutex_lock(&hdev->vport_lock);\n\t \n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tstruct hclge_vport *vport = &hdev->vport[i];\n\n\t\tvlan_id = find_first_bit(vport->vlan_del_fail_bmap,\n\t\t\t\t\t VLAN_N_VID);\n\t\twhile (vlan_id != VLAN_N_VID) {\n\t\t\tret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),\n\t\t\t\t\t\t       vport->vport_id, vlan_id,\n\t\t\t\t\t\t       true);\n\t\t\tif (ret && ret != -EINVAL) {\n\t\t\t\tmutex_unlock(&hdev->vport_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclear_bit(vlan_id, vport->vlan_del_fail_bmap);\n\t\t\thclge_rm_vport_vlan_table(vport, vlan_id, false);\n\t\t\thclge_set_vport_vlan_fltr_change(vport);\n\n\t\t\tsync_cnt++;\n\t\t\tif (sync_cnt >= HCLGE_MAX_SYNC_COUNT) {\n\t\t\t\tmutex_unlock(&hdev->vport_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvlan_id = find_first_bit(vport->vlan_del_fail_bmap,\n\t\t\t\t\t\t VLAN_N_VID);\n\t\t}\n\t}\n\tmutex_unlock(&hdev->vport_lock);\n\n\thclge_sync_vlan_fltr_state(hdev);\n}\n\nstatic int hclge_set_mac_mtu(struct hclge_dev *hdev, int new_mps)\n{\n\tstruct hclge_config_max_frm_size_cmd *req;\n\tstruct hclge_desc desc;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAX_FRM_SIZE, false);\n\n\treq = (struct hclge_config_max_frm_size_cmd *)desc.data;\n\treq->max_frm_size = cpu_to_le16(new_mps);\n\treq->min_frm_size = HCLGE_MAC_MIN_FRAME;\n\n\treturn hclge_cmd_send(&hdev->hw, &desc, 1);\n}\n\nstatic int hclge_set_mtu(struct hnae3_handle *handle, int new_mtu)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn hclge_set_vport_mtu(vport, new_mtu);\n}\n\nint hclge_set_vport_mtu(struct hclge_vport *vport, int new_mtu)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tint i, max_frm_size, ret;\n\n\t \n\tmax_frm_size = new_mtu + ETH_HLEN + ETH_FCS_LEN + 2 * VLAN_HLEN;\n\tif (max_frm_size < HCLGE_MAC_MIN_FRAME ||\n\t    max_frm_size > hdev->ae_dev->dev_specs.max_frm_size)\n\t\treturn -EINVAL;\n\n\tmax_frm_size = max(max_frm_size, HCLGE_MAC_DEFAULT_FRAME);\n\tmutex_lock(&hdev->vport_lock);\n\t \n\tif (vport->vport_id && max_frm_size > hdev->mps) {\n\t\tmutex_unlock(&hdev->vport_lock);\n\t\treturn -EINVAL;\n\t} else if (vport->vport_id) {\n\t\tvport->mps = max_frm_size;\n\t\tmutex_unlock(&hdev->vport_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 1; i < hdev->num_alloc_vport; i++)\n\t\tif (max_frm_size < hdev->vport[i].mps) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to set pf mtu for less than vport %d, mps = %u.\\n\",\n\t\t\t\ti, hdev->vport[i].mps);\n\t\t\tmutex_unlock(&hdev->vport_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\thclge_notify_client(hdev, HNAE3_DOWN_CLIENT);\n\n\tret = hclge_set_mac_mtu(hdev, max_frm_size);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Change mtu fail, ret =%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\thdev->mps = max_frm_size;\n\tvport->mps = max_frm_size;\n\n\tret = hclge_buffer_alloc(hdev);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Allocate buffer fail, ret =%d\\n\", ret);\n\nout:\n\thclge_notify_client(hdev, HNAE3_UP_CLIENT);\n\tmutex_unlock(&hdev->vport_lock);\n\treturn ret;\n}\n\nstatic int hclge_reset_tqp_cmd_send(struct hclge_dev *hdev, u16 queue_id,\n\t\t\t\t    bool enable)\n{\n\tstruct hclge_reset_tqp_queue_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_RESET_TQP_QUEUE, false);\n\n\treq = (struct hclge_reset_tqp_queue_cmd *)desc.data;\n\treq->tqp_id = cpu_to_le16(queue_id);\n\tif (enable)\n\t\thnae3_set_bit(req->reset_req, HCLGE_TQP_RESET_B, 1U);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Send tqp reset cmd error, status =%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_get_reset_status(struct hclge_dev *hdev, u16 queue_id,\n\t\t\t\t  u8 *reset_status)\n{\n\tstruct hclge_reset_tqp_queue_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_RESET_TQP_QUEUE, true);\n\n\treq = (struct hclge_reset_tqp_queue_cmd *)desc.data;\n\treq->tqp_id = cpu_to_le16(queue_id);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get reset status error, status =%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*reset_status = hnae3_get_bit(req->ready_to_reset, HCLGE_TQP_RESET_B);\n\n\treturn 0;\n}\n\nu16 hclge_covert_handle_qid_global(struct hnae3_handle *handle, u16 queue_id)\n{\n\tstruct hclge_comm_tqp *tqp;\n\tstruct hnae3_queue *queue;\n\n\tqueue = handle->kinfo.tqp[queue_id];\n\ttqp = container_of(queue, struct hclge_comm_tqp, q);\n\n\treturn tqp->index;\n}\n\nstatic int hclge_reset_tqp_cmd(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 reset_try_times = 0;\n\tu8 reset_status;\n\tu16 queue_gid;\n\tint ret;\n\tu16 i;\n\n\tfor (i = 0; i < handle->kinfo.num_tqps; i++) {\n\t\tqueue_gid = hclge_covert_handle_qid_global(handle, i);\n\t\tret = hclge_reset_tqp_cmd_send(hdev, queue_gid, true);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to send reset tqp cmd, ret = %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\twhile (reset_try_times++ < HCLGE_TQP_RESET_TRY_TIMES) {\n\t\t\tret = hclge_get_reset_status(hdev, queue_gid,\n\t\t\t\t\t\t     &reset_status);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (reset_status)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tusleep_range(1000, 1200);\n\t\t}\n\n\t\tif (reset_try_times >= HCLGE_TQP_RESET_TRY_TIMES) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"wait for tqp hw reset timeout\\n\");\n\t\t\treturn -ETIME;\n\t\t}\n\n\t\tret = hclge_reset_tqp_cmd_send(hdev, queue_gid, false);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to deassert soft reset, ret = %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\treset_try_times = 0;\n\t}\n\treturn 0;\n}\n\nstatic int hclge_reset_rcb(struct hnae3_handle *handle)\n{\n#define HCLGE_RESET_RCB_NOT_SUPPORT\t0U\n#define HCLGE_RESET_RCB_SUCCESS\t\t1U\n\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_reset_cmd *req;\n\tstruct hclge_desc desc;\n\tu8 return_status;\n\tu16 queue_gid;\n\tint ret;\n\n\tqueue_gid = hclge_covert_handle_qid_global(handle, 0);\n\n\treq = (struct hclge_reset_cmd *)desc.data;\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CFG_RST_TRIGGER, false);\n\thnae3_set_bit(req->fun_reset_rcb, HCLGE_CFG_RESET_RCB_B, 1);\n\treq->fun_reset_rcb_vqid_start = cpu_to_le16(queue_gid);\n\treq->fun_reset_rcb_vqid_num = cpu_to_le16(handle->kinfo.num_tqps);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to send rcb reset cmd, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn_status = req->fun_reset_rcb_return_status;\n\tif (return_status == HCLGE_RESET_RCB_SUCCESS)\n\t\treturn 0;\n\n\tif (return_status != HCLGE_RESET_RCB_NOT_SUPPORT) {\n\t\tdev_err(&hdev->pdev->dev, \"failed to reset rcb, ret = %u\\n\",\n\t\t\treturn_status);\n\t\treturn -EIO;\n\t}\n\n\t \n\treturn hclge_reset_tqp_cmd(handle);\n}\n\nint hclge_reset_tqp(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\t \n\tif (!vport->vport_id) {\n\t\tret = hclge_tqp_enable(handle, false);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to disable tqp, ret = %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn hclge_reset_rcb(handle);\n}\n\nstatic u32 hclge_get_fw_version(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn hdev->fw_version;\n}\n\nstatic void hclge_set_flowctrl_adv(struct hclge_dev *hdev, u32 rx_en, u32 tx_en)\n{\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\n\tif (!phydev)\n\t\treturn;\n\n\tphy_set_asym_pause(phydev, rx_en, tx_en);\n}\n\nstatic int hclge_cfg_pauseparam(struct hclge_dev *hdev, u32 rx_en, u32 tx_en)\n{\n\tint ret;\n\n\tif (hdev->tm_info.fc_mode == HCLGE_FC_PFC)\n\t\treturn 0;\n\n\tret = hclge_mac_pause_en_cfg(hdev, tx_en, rx_en);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"configure pauseparam error, ret = %d.\\n\", ret);\n\n\treturn ret;\n}\n\nint hclge_cfg_flowctrl(struct hclge_dev *hdev)\n{\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\tu16 remote_advertising = 0;\n\tu16 local_advertising;\n\tu32 rx_pause, tx_pause;\n\tu8 flowctl;\n\n\tif (!phydev->link)\n\t\treturn 0;\n\n\tif (!phydev->autoneg)\n\t\treturn hclge_mac_pause_setup_hw(hdev);\n\n\tlocal_advertising = linkmode_adv_to_lcl_adv_t(phydev->advertising);\n\n\tif (phydev->pause)\n\t\tremote_advertising = LPA_PAUSE_CAP;\n\n\tif (phydev->asym_pause)\n\t\tremote_advertising |= LPA_PAUSE_ASYM;\n\n\tflowctl = mii_resolve_flowctrl_fdx(local_advertising,\n\t\t\t\t\t   remote_advertising);\n\ttx_pause = flowctl & FLOW_CTRL_TX;\n\trx_pause = flowctl & FLOW_CTRL_RX;\n\n\tif (phydev->duplex == HCLGE_MAC_HALF) {\n\t\ttx_pause = 0;\n\t\trx_pause = 0;\n\t}\n\n\treturn hclge_cfg_pauseparam(hdev, rx_pause, tx_pause);\n}\n\nstatic void hclge_get_pauseparam(struct hnae3_handle *handle, u32 *auto_neg,\n\t\t\t\t u32 *rx_en, u32 *tx_en)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu8 media_type = hdev->hw.mac.media_type;\n\n\t*auto_neg = (media_type == HNAE3_MEDIA_TYPE_COPPER) ?\n\t\t    hclge_get_autoneg(handle) : 0;\n\n\tif (hdev->tm_info.fc_mode == HCLGE_FC_PFC) {\n\t\t*rx_en = 0;\n\t\t*tx_en = 0;\n\t\treturn;\n\t}\n\n\tif (hdev->tm_info.fc_mode == HCLGE_FC_RX_PAUSE) {\n\t\t*rx_en = 1;\n\t\t*tx_en = 0;\n\t} else if (hdev->tm_info.fc_mode == HCLGE_FC_TX_PAUSE) {\n\t\t*tx_en = 1;\n\t\t*rx_en = 0;\n\t} else if (hdev->tm_info.fc_mode == HCLGE_FC_FULL) {\n\t\t*rx_en = 1;\n\t\t*tx_en = 1;\n\t} else {\n\t\t*rx_en = 0;\n\t\t*tx_en = 0;\n\t}\n}\n\nstatic void hclge_record_user_pauseparam(struct hclge_dev *hdev,\n\t\t\t\t\t u32 rx_en, u32 tx_en)\n{\n\tif (rx_en && tx_en)\n\t\thdev->fc_mode_last_time = HCLGE_FC_FULL;\n\telse if (rx_en && !tx_en)\n\t\thdev->fc_mode_last_time = HCLGE_FC_RX_PAUSE;\n\telse if (!rx_en && tx_en)\n\t\thdev->fc_mode_last_time = HCLGE_FC_TX_PAUSE;\n\telse\n\t\thdev->fc_mode_last_time = HCLGE_FC_NONE;\n\n\thdev->tm_info.fc_mode = hdev->fc_mode_last_time;\n}\n\nstatic int hclge_set_pauseparam(struct hnae3_handle *handle, u32 auto_neg,\n\t\t\t\tu32 rx_en, u32 tx_en)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\tu32 fc_autoneg;\n\n\tif (phydev || hnae3_dev_phy_imp_supported(hdev)) {\n\t\tfc_autoneg = hclge_get_autoneg(handle);\n\t\tif (auto_neg != fc_autoneg) {\n\t\t\tdev_info(&hdev->pdev->dev,\n\t\t\t\t \"To change autoneg please use: ethtool -s <dev> autoneg <on|off>\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (hdev->tm_info.fc_mode == HCLGE_FC_PFC) {\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"Priority flow control enabled. Cannot set link flow control.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\thclge_set_flowctrl_adv(hdev, rx_en, tx_en);\n\n\thclge_record_user_pauseparam(hdev, rx_en, tx_en);\n\n\tif (!auto_neg || hnae3_dev_phy_imp_supported(hdev))\n\t\treturn hclge_cfg_pauseparam(hdev, rx_en, tx_en);\n\n\tif (phydev)\n\t\treturn phy_start_aneg(phydev);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void hclge_get_ksettings_an_result(struct hnae3_handle *handle,\n\t\t\t\t\t  u8 *auto_neg, u32 *speed, u8 *duplex, u32 *lane_num)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (speed)\n\t\t*speed = hdev->hw.mac.speed;\n\tif (duplex)\n\t\t*duplex = hdev->hw.mac.duplex;\n\tif (auto_neg)\n\t\t*auto_neg = hdev->hw.mac.autoneg;\n\tif (lane_num)\n\t\t*lane_num = hdev->hw.mac.lane_num;\n}\n\nstatic void hclge_get_media_type(struct hnae3_handle *handle, u8 *media_type,\n\t\t\t\t u8 *module_type)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\t \n\thclge_update_port_info(hdev);\n\n\tif (media_type)\n\t\t*media_type = hdev->hw.mac.media_type;\n\n\tif (module_type)\n\t\t*module_type = hdev->hw.mac.module_type;\n}\n\nstatic void hclge_get_mdix_mode(struct hnae3_handle *handle,\n\t\t\t\tu8 *tp_mdix_ctrl, u8 *tp_mdix)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\tint mdix_ctrl, mdix, is_resolved;\n\tunsigned int retval;\n\n\tif (!phydev) {\n\t\t*tp_mdix_ctrl = ETH_TP_MDI_INVALID;\n\t\t*tp_mdix = ETH_TP_MDI_INVALID;\n\t\treturn;\n\t}\n\n\tphy_write(phydev, HCLGE_PHY_PAGE_REG, HCLGE_PHY_PAGE_MDIX);\n\n\tretval = phy_read(phydev, HCLGE_PHY_CSC_REG);\n\tmdix_ctrl = hnae3_get_field(retval, HCLGE_PHY_MDIX_CTRL_M,\n\t\t\t\t    HCLGE_PHY_MDIX_CTRL_S);\n\n\tretval = phy_read(phydev, HCLGE_PHY_CSS_REG);\n\tmdix = hnae3_get_bit(retval, HCLGE_PHY_MDIX_STATUS_B);\n\tis_resolved = hnae3_get_bit(retval, HCLGE_PHY_SPEED_DUP_RESOLVE_B);\n\n\tphy_write(phydev, HCLGE_PHY_PAGE_REG, HCLGE_PHY_PAGE_COPPER);\n\n\tswitch (mdix_ctrl) {\n\tcase 0x0:\n\t\t*tp_mdix_ctrl = ETH_TP_MDI;\n\t\tbreak;\n\tcase 0x1:\n\t\t*tp_mdix_ctrl = ETH_TP_MDI_X;\n\t\tbreak;\n\tcase 0x3:\n\t\t*tp_mdix_ctrl = ETH_TP_MDI_AUTO;\n\t\tbreak;\n\tdefault:\n\t\t*tp_mdix_ctrl = ETH_TP_MDI_INVALID;\n\t\tbreak;\n\t}\n\n\tif (!is_resolved)\n\t\t*tp_mdix = ETH_TP_MDI_INVALID;\n\telse if (mdix)\n\t\t*tp_mdix = ETH_TP_MDI_X;\n\telse\n\t\t*tp_mdix = ETH_TP_MDI;\n}\n\nstatic void hclge_info_show(struct hclge_dev *hdev)\n{\n\tstruct hnae3_handle *handle = &hdev->vport->nic;\n\tstruct device *dev = &hdev->pdev->dev;\n\n\tdev_info(dev, \"PF info begin:\\n\");\n\n\tdev_info(dev, \"Task queue pairs numbers: %u\\n\", hdev->num_tqps);\n\tdev_info(dev, \"Desc num per TX queue: %u\\n\", hdev->num_tx_desc);\n\tdev_info(dev, \"Desc num per RX queue: %u\\n\", hdev->num_rx_desc);\n\tdev_info(dev, \"Numbers of vports: %u\\n\", hdev->num_alloc_vport);\n\tdev_info(dev, \"Numbers of VF for this PF: %u\\n\", hdev->num_req_vfs);\n\tdev_info(dev, \"HW tc map: 0x%x\\n\", hdev->hw_tc_map);\n\tdev_info(dev, \"Total buffer size for TX/RX: %u\\n\", hdev->pkt_buf_size);\n\tdev_info(dev, \"TX buffer size for each TC: %u\\n\", hdev->tx_buf_size);\n\tdev_info(dev, \"DV buffer size for each TC: %u\\n\", hdev->dv_buf_size);\n\tdev_info(dev, \"This is %s PF\\n\",\n\t\t hdev->flag & HCLGE_FLAG_MAIN ? \"main\" : \"not main\");\n\tdev_info(dev, \"DCB %s\\n\",\n\t\t handle->kinfo.tc_info.dcb_ets_active ? \"enable\" : \"disable\");\n\tdev_info(dev, \"MQPRIO %s\\n\",\n\t\t handle->kinfo.tc_info.mqprio_active ? \"enable\" : \"disable\");\n\tdev_info(dev, \"Default tx spare buffer size: %u\\n\",\n\t\t hdev->tx_spare_buf_size);\n\n\tdev_info(dev, \"PF info end.\\n\");\n}\n\nstatic int hclge_init_nic_client_instance(struct hnae3_ae_dev *ae_dev,\n\t\t\t\t\t  struct hclge_vport *vport)\n{\n\tstruct hnae3_client *client = vport->nic.client;\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tint rst_cnt = hdev->rst_stats.reset_cnt;\n\tint ret;\n\n\tret = client->ops->init_instance(&vport->nic);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(HCLGE_STATE_NIC_REGISTERED, &hdev->state);\n\tif (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state) ||\n\t    rst_cnt != hdev->rst_stats.reset_cnt) {\n\t\tret = -EBUSY;\n\t\tgoto init_nic_err;\n\t}\n\n\t \n\tret = hclge_config_nic_hw_error(hdev, true);\n\tif (ret) {\n\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\"fail(%d) to enable hw error interrupts\\n\", ret);\n\t\tgoto init_nic_err;\n\t}\n\n\thnae3_set_client_init_flag(client, ae_dev, 1);\n\n\tif (netif_msg_drv(&hdev->vport->nic))\n\t\thclge_info_show(hdev);\n\n\treturn ret;\n\ninit_nic_err:\n\tclear_bit(HCLGE_STATE_NIC_REGISTERED, &hdev->state);\n\twhile (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state))\n\t\tmsleep(HCLGE_WAIT_RESET_DONE);\n\n\tclient->ops->uninit_instance(&vport->nic, 0);\n\n\treturn ret;\n}\n\nstatic int hclge_init_roce_client_instance(struct hnae3_ae_dev *ae_dev,\n\t\t\t\t\t   struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct hnae3_client *client;\n\tint rst_cnt;\n\tint ret;\n\n\tif (!hnae3_dev_roce_supported(hdev) || !hdev->roce_client ||\n\t    !hdev->nic_client)\n\t\treturn 0;\n\n\tclient = hdev->roce_client;\n\tret = hclge_init_roce_base_info(vport);\n\tif (ret)\n\t\treturn ret;\n\n\trst_cnt = hdev->rst_stats.reset_cnt;\n\tret = client->ops->init_instance(&vport->roce);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(HCLGE_STATE_ROCE_REGISTERED, &hdev->state);\n\tif (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state) ||\n\t    rst_cnt != hdev->rst_stats.reset_cnt) {\n\t\tret = -EBUSY;\n\t\tgoto init_roce_err;\n\t}\n\n\t \n\tret = hclge_config_rocee_ras_interrupt(hdev, true);\n\tif (ret) {\n\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\"fail(%d) to enable roce ras interrupts\\n\", ret);\n\t\tgoto init_roce_err;\n\t}\n\n\thnae3_set_client_init_flag(client, ae_dev, 1);\n\n\treturn 0;\n\ninit_roce_err:\n\tclear_bit(HCLGE_STATE_ROCE_REGISTERED, &hdev->state);\n\twhile (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state))\n\t\tmsleep(HCLGE_WAIT_RESET_DONE);\n\n\thdev->roce_client->ops->uninit_instance(&vport->roce, 0);\n\n\treturn ret;\n}\n\nstatic int hclge_init_client_instance(struct hnae3_client *client,\n\t\t\t\t      struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct hclge_vport *vport = &hdev->vport[0];\n\tint ret;\n\n\tswitch (client->type) {\n\tcase HNAE3_CLIENT_KNIC:\n\t\thdev->nic_client = client;\n\t\tvport->nic.client = client;\n\t\tret = hclge_init_nic_client_instance(ae_dev, vport);\n\t\tif (ret)\n\t\t\tgoto clear_nic;\n\n\t\tret = hclge_init_roce_client_instance(ae_dev, vport);\n\t\tif (ret)\n\t\t\tgoto clear_roce;\n\n\t\tbreak;\n\tcase HNAE3_CLIENT_ROCE:\n\t\tif (hnae3_dev_roce_supported(hdev)) {\n\t\t\thdev->roce_client = client;\n\t\t\tvport->roce.client = client;\n\t\t}\n\n\t\tret = hclge_init_roce_client_instance(ae_dev, vport);\n\t\tif (ret)\n\t\t\tgoto clear_roce;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nclear_nic:\n\thdev->nic_client = NULL;\n\tvport->nic.client = NULL;\n\treturn ret;\nclear_roce:\n\thdev->roce_client = NULL;\n\tvport->roce.client = NULL;\n\treturn ret;\n}\n\nstatic void hclge_uninit_client_instance(struct hnae3_client *client,\n\t\t\t\t\t struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct hclge_vport *vport = &hdev->vport[0];\n\n\tif (hdev->roce_client) {\n\t\tclear_bit(HCLGE_STATE_ROCE_REGISTERED, &hdev->state);\n\t\twhile (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state))\n\t\t\tmsleep(HCLGE_WAIT_RESET_DONE);\n\n\t\thdev->roce_client->ops->uninit_instance(&vport->roce, 0);\n\t\thdev->roce_client = NULL;\n\t\tvport->roce.client = NULL;\n\t}\n\tif (client->type == HNAE3_CLIENT_ROCE)\n\t\treturn;\n\tif (hdev->nic_client && client->ops->uninit_instance) {\n\t\tclear_bit(HCLGE_STATE_NIC_REGISTERED, &hdev->state);\n\t\twhile (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state))\n\t\t\tmsleep(HCLGE_WAIT_RESET_DONE);\n\n\t\tclient->ops->uninit_instance(&vport->nic, 0);\n\t\thdev->nic_client = NULL;\n\t\tvport->nic.client = NULL;\n\t}\n}\n\nstatic int hclge_dev_mem_map(struct hclge_dev *hdev)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tstruct hclge_hw *hw = &hdev->hw;\n\n\t \n\tif (!(pci_select_bars(pdev, IORESOURCE_MEM) & BIT(HCLGE_MEM_BAR)))\n\t\treturn 0;\n\n\thw->hw.mem_base =\n\t\tdevm_ioremap_wc(&pdev->dev,\n\t\t\t\tpci_resource_start(pdev, HCLGE_MEM_BAR),\n\t\t\t\tpci_resource_len(pdev, HCLGE_MEM_BAR));\n\tif (!hw->hw.mem_base) {\n\t\tdev_err(&pdev->dev, \"failed to map device memory\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_pci_init(struct hclge_dev *hdev)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tstruct hclge_hw *hw;\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable PCI device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"can't set consistent PCI DMA\");\n\t\t\tgoto err_disable_device;\n\t\t}\n\t\tdev_warn(&pdev->dev, \"set DMA mask to 32 bits\\n\");\n\t}\n\n\tret = pci_request_regions(pdev, HCLGE_DRIVER_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"PCI request regions failed %d\\n\", ret);\n\t\tgoto err_disable_device;\n\t}\n\n\tpci_set_master(pdev);\n\thw = &hdev->hw;\n\thw->hw.io_base = pcim_iomap(pdev, 2, 0);\n\tif (!hw->hw.io_base) {\n\t\tdev_err(&pdev->dev, \"Can't map configuration register space\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\tret = hclge_dev_mem_map(hdev);\n\tif (ret)\n\t\tgoto err_unmap_io_base;\n\n\thdev->num_req_vfs = pci_sriov_get_totalvfs(pdev);\n\n\treturn 0;\n\nerr_unmap_io_base:\n\tpcim_iounmap(pdev, hdev->hw.hw.io_base);\nerr_release_regions:\n\tpci_release_regions(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn ret;\n}\n\nstatic void hclge_pci_uninit(struct hclge_dev *hdev)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\n\tif (hdev->hw.hw.mem_base)\n\t\tdevm_iounmap(&pdev->dev, hdev->hw.hw.mem_base);\n\n\tpcim_iounmap(pdev, hdev->hw.hw.io_base);\n\tpci_free_irq_vectors(pdev);\n\tpci_release_mem_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic void hclge_state_init(struct hclge_dev *hdev)\n{\n\tset_bit(HCLGE_STATE_SERVICE_INITED, &hdev->state);\n\tset_bit(HCLGE_STATE_DOWN, &hdev->state);\n\tclear_bit(HCLGE_STATE_RST_SERVICE_SCHED, &hdev->state);\n\tclear_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);\n\tclear_bit(HCLGE_STATE_RST_FAIL, &hdev->state);\n\tclear_bit(HCLGE_STATE_MBX_SERVICE_SCHED, &hdev->state);\n\tclear_bit(HCLGE_STATE_MBX_HANDLING, &hdev->state);\n}\n\nstatic void hclge_state_uninit(struct hclge_dev *hdev)\n{\n\tset_bit(HCLGE_STATE_DOWN, &hdev->state);\n\tset_bit(HCLGE_STATE_REMOVING, &hdev->state);\n\n\tif (hdev->reset_timer.function)\n\t\tdel_timer_sync(&hdev->reset_timer);\n\tif (hdev->service_task.work.func)\n\t\tcancel_delayed_work_sync(&hdev->service_task);\n}\n\nstatic void hclge_reset_prepare_general(struct hnae3_ae_dev *ae_dev,\n\t\t\t\t\tenum hnae3_reset_type rst_type)\n{\n#define HCLGE_RESET_RETRY_WAIT_MS\t500\n#define HCLGE_RESET_RETRY_CNT\t5\n\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tint retry_cnt = 0;\n\tint ret;\n\n\twhile (retry_cnt++ < HCLGE_RESET_RETRY_CNT) {\n\t\tdown(&hdev->reset_sem);\n\t\tset_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);\n\t\thdev->reset_type = rst_type;\n\t\tret = hclge_reset_prepare(hdev);\n\t\tif (!ret && !hdev->reset_pending)\n\t\t\tbreak;\n\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to prepare to reset, ret=%d, reset_pending:0x%lx, retry_cnt:%d\\n\",\n\t\t\tret, hdev->reset_pending, retry_cnt);\n\t\tclear_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);\n\t\tup(&hdev->reset_sem);\n\t\tmsleep(HCLGE_RESET_RETRY_WAIT_MS);\n\t}\n\n\t \n\thclge_enable_vector(&hdev->misc_vector, false);\n\tset_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);\n\n\tif (hdev->reset_type == HNAE3_FLR_RESET)\n\t\thdev->rst_stats.flr_rst_cnt++;\n}\n\nstatic void hclge_reset_done(struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tint ret;\n\n\thclge_enable_vector(&hdev->misc_vector, true);\n\n\tret = hclge_reset_rebuild(hdev);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"fail to rebuild, ret=%d\\n\", ret);\n\n\thdev->reset_type = HNAE3_NONE_RESET;\n\tclear_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);\n\tup(&hdev->reset_sem);\n}\n\nstatic void hclge_clear_resetting_state(struct hclge_dev *hdev)\n{\n\tu16 i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tstruct hclge_vport *vport = &hdev->vport[i];\n\t\tint ret;\n\n\t\t  \n\t\tret = hclge_set_vf_rst(hdev, vport->vport_id, false);\n\t\tif (ret)\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"clear vport(%u) rst failed %d!\\n\",\n\t\t\t\t vport->vport_id, ret);\n\t}\n}\n\nstatic int hclge_clear_hw_resource(struct hclge_dev *hdev)\n{\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CLEAR_HW_RESOURCE, false);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\t \n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to clear hw resource, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void hclge_init_rxd_adv_layout(struct hclge_dev *hdev)\n{\n\tif (hnae3_ae_dev_rxd_adv_layout_supported(hdev->ae_dev))\n\t\thclge_write_dev(&hdev->hw, HCLGE_RXD_ADV_LAYOUT_EN_REG, 1);\n}\n\nstatic void hclge_uninit_rxd_adv_layout(struct hclge_dev *hdev)\n{\n\tif (hnae3_ae_dev_rxd_adv_layout_supported(hdev->ae_dev))\n\t\thclge_write_dev(&hdev->hw, HCLGE_RXD_ADV_LAYOUT_EN_REG, 0);\n}\n\nstatic struct hclge_wol_info *hclge_get_wol_info(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\n\treturn &vport->back->hw.mac.wol;\n}\n\nstatic int hclge_get_wol_supported_mode(struct hclge_dev *hdev,\n\t\t\t\t\tu32 *wol_supported)\n{\n\tstruct hclge_query_wol_supported_cmd *wol_supported_cmd;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_WOL_GET_SUPPORTED_MODE,\n\t\t\t\t   true);\n\twol_supported_cmd = (struct hclge_query_wol_supported_cmd *)desc.data;\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to query wol supported, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*wol_supported = le32_to_cpu(wol_supported_cmd->supported_wake_mode);\n\n\treturn 0;\n}\n\nstatic int hclge_set_wol_cfg(struct hclge_dev *hdev,\n\t\t\t     struct hclge_wol_info *wol_info)\n{\n\tstruct hclge_wol_cfg_cmd *wol_cfg_cmd;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_WOL_CFG, false);\n\twol_cfg_cmd = (struct hclge_wol_cfg_cmd *)desc.data;\n\twol_cfg_cmd->wake_on_lan_mode = cpu_to_le32(wol_info->wol_current_mode);\n\twol_cfg_cmd->sopass_size = wol_info->wol_sopass_size;\n\tmemcpy(wol_cfg_cmd->sopass, wol_info->wol_sopass, SOPASS_MAX);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set wol config, ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_update_wol(struct hclge_dev *hdev)\n{\n\tstruct hclge_wol_info *wol_info = &hdev->hw.mac.wol;\n\n\tif (!hnae3_ae_dev_wol_supported(hdev->ae_dev))\n\t\treturn 0;\n\n\treturn hclge_set_wol_cfg(hdev, wol_info);\n}\n\nstatic int hclge_init_wol(struct hclge_dev *hdev)\n{\n\tstruct hclge_wol_info *wol_info = &hdev->hw.mac.wol;\n\tint ret;\n\n\tif (!hnae3_ae_dev_wol_supported(hdev->ae_dev))\n\t\treturn 0;\n\n\tmemset(wol_info, 0, sizeof(struct hclge_wol_info));\n\tret = hclge_get_wol_supported_mode(hdev,\n\t\t\t\t\t   &wol_info->wol_support_mode);\n\tif (ret) {\n\t\twol_info->wol_support_mode = 0;\n\t\treturn ret;\n\t}\n\n\treturn hclge_update_wol(hdev);\n}\n\nstatic void hclge_get_wol(struct hnae3_handle *handle,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct hclge_wol_info *wol_info = hclge_get_wol_info(handle);\n\n\twol->supported = wol_info->wol_support_mode;\n\twol->wolopts = wol_info->wol_current_mode;\n\tif (wol_info->wol_current_mode & WAKE_MAGICSECURE)\n\t\tmemcpy(wol->sopass, wol_info->wol_sopass, SOPASS_MAX);\n}\n\nstatic int hclge_set_wol(struct hnae3_handle *handle,\n\t\t\t struct ethtool_wolinfo *wol)\n{\n\tstruct hclge_wol_info *wol_info = hclge_get_wol_info(handle);\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tu32 wol_mode;\n\tint ret;\n\n\twol_mode = wol->wolopts;\n\tif (wol_mode & ~wol_info->wol_support_mode)\n\t\treturn -EINVAL;\n\n\twol_info->wol_current_mode = wol_mode;\n\tif (wol_mode & WAKE_MAGICSECURE) {\n\t\tmemcpy(wol_info->wol_sopass, wol->sopass, SOPASS_MAX);\n\t\twol_info->wol_sopass_size = SOPASS_MAX;\n\t} else {\n\t\twol_info->wol_sopass_size = 0;\n\t}\n\n\tret = hclge_set_wol_cfg(vport->back, wol_info);\n\tif (ret)\n\t\twol_info->wol_current_mode = 0;\n\n\treturn ret;\n}\n\nstatic int hclge_init_ae_dev(struct hnae3_ae_dev *ae_dev)\n{\n\tstruct pci_dev *pdev = ae_dev->pdev;\n\tstruct hclge_dev *hdev;\n\tint ret;\n\n\thdev = devm_kzalloc(&pdev->dev, sizeof(*hdev), GFP_KERNEL);\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\n\thdev->pdev = pdev;\n\thdev->ae_dev = ae_dev;\n\thdev->reset_type = HNAE3_NONE_RESET;\n\thdev->reset_level = HNAE3_FUNC_RESET;\n\tae_dev->priv = hdev;\n\n\t \n\thdev->mps = ETH_FRAME_LEN + ETH_FCS_LEN + 2 * VLAN_HLEN;\n\n\tmutex_init(&hdev->vport_lock);\n\tspin_lock_init(&hdev->fd_rule_lock);\n\tsema_init(&hdev->reset_sem, 1);\n\n\tret = hclge_pci_init(hdev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = hclge_devlink_init(hdev);\n\tif (ret)\n\t\tgoto err_pci_uninit;\n\n\t \n\tret = hclge_comm_cmd_queue_init(hdev->pdev, &hdev->hw.hw);\n\tif (ret)\n\t\tgoto err_devlink_uninit;\n\n\t \n\tret = hclge_comm_cmd_init(hdev->ae_dev, &hdev->hw.hw, &hdev->fw_version,\n\t\t\t\t  true, hdev->reset_pending);\n\tif (ret)\n\t\tgoto err_cmd_uninit;\n\n\tret  = hclge_clear_hw_resource(hdev);\n\tif (ret)\n\t\tgoto err_cmd_uninit;\n\n\tret = hclge_get_cap(hdev);\n\tif (ret)\n\t\tgoto err_cmd_uninit;\n\n\tret = hclge_query_dev_specs(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to query dev specifications, ret = %d.\\n\",\n\t\t\tret);\n\t\tgoto err_cmd_uninit;\n\t}\n\n\tret = hclge_configure(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Configure dev error, ret = %d.\\n\", ret);\n\t\tgoto err_cmd_uninit;\n\t}\n\n\tret = hclge_init_msi(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Init MSI/MSI-X error, ret = %d.\\n\", ret);\n\t\tgoto err_cmd_uninit;\n\t}\n\n\tret = hclge_misc_irq_init(hdev);\n\tif (ret)\n\t\tgoto err_msi_uninit;\n\n\tret = hclge_alloc_tqps(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Allocate TQPs error, ret = %d.\\n\", ret);\n\t\tgoto err_msi_irq_uninit;\n\t}\n\n\tret = hclge_alloc_vport(hdev);\n\tif (ret)\n\t\tgoto err_msi_irq_uninit;\n\n\tret = hclge_map_tqp(hdev);\n\tif (ret)\n\t\tgoto err_msi_irq_uninit;\n\n\tif (hdev->hw.mac.media_type == HNAE3_MEDIA_TYPE_COPPER) {\n\t\tclear_bit(HNAE3_DEV_SUPPORT_FEC_B, ae_dev->caps);\n\t\tif (hnae3_dev_phy_imp_supported(hdev))\n\t\t\tret = hclge_update_tp_port_info(hdev);\n\t\telse\n\t\t\tret = hclge_mac_mdio_config(hdev);\n\n\t\tif (ret)\n\t\t\tgoto err_msi_irq_uninit;\n\t}\n\n\tret = hclge_init_umv_space(hdev);\n\tif (ret)\n\t\tgoto err_mdiobus_unreg;\n\n\tret = hclge_mac_init(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Mac init error, ret = %d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = hclge_config_tso(hdev, HCLGE_TSO_MSS_MIN, HCLGE_TSO_MSS_MAX);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Enable tso fail, ret =%d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = hclge_config_gro(hdev);\n\tif (ret)\n\t\tgoto err_mdiobus_unreg;\n\n\tret = hclge_init_vlan_config(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"VLAN init fail, ret =%d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = hclge_tm_schd_init(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"tm schd init fail, ret =%d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = hclge_comm_rss_init_cfg(&hdev->vport->nic, hdev->ae_dev,\n\t\t\t\t      &hdev->rss_cfg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to init rss cfg, ret = %d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = hclge_rss_init_hw(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Rss init fail, ret =%d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = init_mgr_tbl(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"manager table init fail, ret =%d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = hclge_init_fd_config(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"fd table init fail, ret=%d\\n\", ret);\n\t\tgoto err_mdiobus_unreg;\n\t}\n\n\tret = hclge_ptp_init(hdev);\n\tif (ret)\n\t\tgoto err_mdiobus_unreg;\n\n\tret = hclge_update_port_info(hdev);\n\tif (ret)\n\t\tgoto err_mdiobus_unreg;\n\n\tINIT_KFIFO(hdev->mac_tnl_log);\n\n\thclge_dcb_ops_set(hdev);\n\n\ttimer_setup(&hdev->reset_timer, hclge_reset_timer, 0);\n\tINIT_DELAYED_WORK(&hdev->service_task, hclge_service_task);\n\n\thclge_clear_all_event_cause(hdev);\n\thclge_clear_resetting_state(hdev);\n\n\t \n\tif (hnae3_dev_ras_imp_supported(hdev))\n\t\thclge_handle_occurred_error(hdev);\n\telse\n\t\thclge_handle_all_hns_hw_errors(ae_dev);\n\n\t \n\tif (ae_dev->hw_err_reset_req) {\n\t\tenum hnae3_reset_type reset_level;\n\n\t\treset_level = hclge_get_reset_level(ae_dev,\n\t\t\t\t\t\t    &ae_dev->hw_err_reset_req);\n\t\thclge_set_def_reset_request(ae_dev, reset_level);\n\t\tmod_timer(&hdev->reset_timer, jiffies + HCLGE_RESET_INTERVAL);\n\t}\n\n\thclge_init_rxd_adv_layout(hdev);\n\n\t \n\thclge_enable_vector(&hdev->misc_vector, true);\n\n\tret = hclge_init_wol(hdev);\n\tif (ret)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"failed to wake on lan init, ret = %d\\n\", ret);\n\n\thclge_state_init(hdev);\n\thdev->last_reset_time = jiffies;\n\n\tdev_info(&hdev->pdev->dev, \"%s driver initialization finished.\\n\",\n\t\t HCLGE_DRIVER_NAME);\n\n\thclge_task_schedule(hdev, round_jiffies_relative(HZ));\n\n\treturn 0;\n\nerr_mdiobus_unreg:\n\tif (hdev->hw.mac.phydev)\n\t\tmdiobus_unregister(hdev->hw.mac.mdio_bus);\nerr_msi_irq_uninit:\n\thclge_misc_irq_uninit(hdev);\nerr_msi_uninit:\n\tpci_free_irq_vectors(pdev);\nerr_cmd_uninit:\n\thclge_comm_cmd_uninit(hdev->ae_dev, &hdev->hw.hw);\nerr_devlink_uninit:\n\thclge_devlink_uninit(hdev);\nerr_pci_uninit:\n\tpcim_iounmap(pdev, hdev->hw.hw.io_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\nout:\n\tmutex_destroy(&hdev->vport_lock);\n\treturn ret;\n}\n\nstatic void hclge_stats_clear(struct hclge_dev *hdev)\n{\n\tmemset(&hdev->mac_stats, 0, sizeof(hdev->mac_stats));\n\tmemset(&hdev->fec_stats, 0, sizeof(hdev->fec_stats));\n}\n\nstatic int hclge_set_mac_spoofchk(struct hclge_dev *hdev, int vf, bool enable)\n{\n\treturn hclge_config_switch_param(hdev, vf, enable,\n\t\t\t\t\t HCLGE_SWITCH_ANTI_SPOOF_MASK);\n}\n\nstatic int hclge_set_vlan_spoofchk(struct hclge_dev *hdev, int vf, bool enable)\n{\n\treturn hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,\n\t\t\t\t\t  HCLGE_FILTER_FE_NIC_INGRESS_B,\n\t\t\t\t\t  enable, vf);\n}\n\nstatic int hclge_set_vf_spoofchk_hw(struct hclge_dev *hdev, int vf, bool enable)\n{\n\tint ret;\n\n\tret = hclge_set_mac_spoofchk(hdev, vf, enable);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Set vf %d mac spoof check %s failed, ret=%d\\n\",\n\t\t\tvf, enable ? \"on\" : \"off\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_set_vlan_spoofchk(hdev, vf, enable);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Set vf %d vlan spoof check %s failed, ret=%d\\n\",\n\t\t\tvf, enable ? \"on\" : \"off\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_set_vf_spoofchk(struct hnae3_handle *handle, int vf,\n\t\t\t\t bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 new_spoofchk = enable ? 1 : 0;\n\tint ret;\n\n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\treturn -EOPNOTSUPP;\n\n\tvport = hclge_get_vf_vport(hdev, vf);\n\tif (!vport)\n\t\treturn -EINVAL;\n\n\tif (vport->vf_info.spoofchk == new_spoofchk)\n\t\treturn 0;\n\n\tif (enable && test_bit(vport->vport_id, hdev->vf_vlan_full))\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"vf %d vlan table is full, enable spoof check may cause its packet send fail\\n\",\n\t\t\t vf);\n\telse if (enable && hclge_is_umv_space_full(vport, true))\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"vf %d mac table is full, enable spoof check may cause its packet send fail\\n\",\n\t\t\t vf);\n\n\tret = hclge_set_vf_spoofchk_hw(hdev, vport->vport_id, enable);\n\tif (ret)\n\t\treturn ret;\n\n\tvport->vf_info.spoofchk = new_spoofchk;\n\treturn 0;\n}\n\nstatic int hclge_reset_vport_spoofchk(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport = hdev->vport;\n\tint ret;\n\tint i;\n\n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tret = hclge_set_vf_spoofchk_hw(hdev, vport->vport_id,\n\t\t\t\t\t       vport->vf_info.spoofchk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvport++;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_set_vf_trust(struct hnae3_handle *handle, int vf, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 new_trusted = enable ? 1 : 0;\n\n\tvport = hclge_get_vf_vport(hdev, vf);\n\tif (!vport)\n\t\treturn -EINVAL;\n\n\tif (vport->vf_info.trusted == new_trusted)\n\t\treturn 0;\n\n\tvport->vf_info.trusted = new_trusted;\n\tset_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE, &vport->state);\n\thclge_task_schedule(hdev, 0);\n\n\treturn 0;\n}\n\nstatic void hclge_reset_vf_rate(struct hclge_dev *hdev)\n{\n\tint ret;\n\tint vf;\n\n\t \n\tfor (vf = HCLGE_VF_VPORT_START_NUM; vf < hdev->num_alloc_vport; vf++) {\n\t\tstruct hclge_vport *vport = &hdev->vport[vf];\n\n\t\tvport->vf_info.max_tx_rate = 0;\n\t\tret = hclge_tm_qs_shaper_cfg(vport, vport->vf_info.max_tx_rate);\n\t\tif (ret)\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"vf%d failed to reset to default, ret=%d\\n\",\n\t\t\t\tvf - HCLGE_VF_VPORT_START_NUM, ret);\n\t}\n}\n\nstatic int hclge_vf_rate_param_check(struct hclge_dev *hdev,\n\t\t\t\t     int min_tx_rate, int max_tx_rate)\n{\n\tif (min_tx_rate != 0 ||\n\t    max_tx_rate < 0 || max_tx_rate > hdev->hw.mac.max_speed) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"min_tx_rate:%d [0], max_tx_rate:%d [0, %u]\\n\",\n\t\t\tmin_tx_rate, max_tx_rate, hdev->hw.mac.max_speed);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_set_vf_rate(struct hnae3_handle *handle, int vf,\n\t\t\t     int min_tx_rate, int max_tx_rate, bool force)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tret = hclge_vf_rate_param_check(hdev, min_tx_rate, max_tx_rate);\n\tif (ret)\n\t\treturn ret;\n\n\tvport = hclge_get_vf_vport(hdev, vf);\n\tif (!vport)\n\t\treturn -EINVAL;\n\n\tif (!force && max_tx_rate == vport->vf_info.max_tx_rate)\n\t\treturn 0;\n\n\tret = hclge_tm_qs_shaper_cfg(vport, max_tx_rate);\n\tif (ret)\n\t\treturn ret;\n\n\tvport->vf_info.max_tx_rate = max_tx_rate;\n\n\treturn 0;\n}\n\nstatic int hclge_resume_vf_rate(struct hclge_dev *hdev)\n{\n\tstruct hnae3_handle *handle = &hdev->vport->nic;\n\tstruct hclge_vport *vport;\n\tint ret;\n\tint vf;\n\n\t \n\tfor (vf = 0; vf < pci_num_vf(hdev->pdev); vf++) {\n\t\tvport = hclge_get_vf_vport(hdev, vf);\n\t\tif (!vport)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!vport->vf_info.max_tx_rate)\n\t\t\tcontinue;\n\n\t\tret = hclge_set_vf_rate(handle, vf, 0,\n\t\t\t\t\tvport->vf_info.max_tx_rate, true);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"vf%d failed to resume tx_rate:%u, ret=%d\\n\",\n\t\t\t\tvf, vport->vf_info.max_tx_rate, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hclge_reset_vport_state(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport = hdev->vport;\n\tint i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tclear_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);\n\t\tvport++;\n\t}\n}\n\nstatic int hclge_reset_ae_dev(struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct pci_dev *pdev = ae_dev->pdev;\n\tint ret;\n\n\tset_bit(HCLGE_STATE_DOWN, &hdev->state);\n\n\thclge_stats_clear(hdev);\n\t \n\tif (hdev->reset_type == HNAE3_IMP_RESET ||\n\t    hdev->reset_type == HNAE3_GLOBAL_RESET) {\n\t\tmemset(hdev->vlan_table, 0, sizeof(hdev->vlan_table));\n\t\tmemset(hdev->vf_vlan_full, 0, sizeof(hdev->vf_vlan_full));\n\t\tbitmap_set(hdev->vport_config_block, 0, hdev->num_alloc_vport);\n\t\thclge_reset_umv_space(hdev);\n\t}\n\n\tret = hclge_comm_cmd_init(hdev->ae_dev, &hdev->hw.hw, &hdev->fw_version,\n\t\t\t\t  true, hdev->reset_pending);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cmd queue init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hclge_map_tqp(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Map tqp error, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_mac_init(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Mac init error, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_tp_port_init(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to init tp port, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_config_tso(hdev, HCLGE_TSO_MSS_MIN, HCLGE_TSO_MSS_MAX);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Enable tso fail, ret =%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_config_gro(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_init_vlan_config(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"VLAN init fail, ret =%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_tm_init_hw(hdev, true);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"tm init hw fail, ret =%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_rss_init_hw(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Rss init fail, ret =%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = init_mgr_tbl(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to reinit manager table, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_init_fd_config(hdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fd table init fail, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_ptp_init(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (hnae3_dev_ras_imp_supported(hdev))\n\t\thclge_handle_occurred_error(hdev);\n\telse\n\t\thclge_handle_all_hns_hw_errors(ae_dev);\n\n\t \n\tret = hclge_config_nic_hw_error(hdev, true);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"fail(%d) to re-enable NIC hw error interrupts\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (hdev->roce_client) {\n\t\tret = hclge_config_rocee_ras_interrupt(hdev, true);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"fail(%d) to re-enable roce ras interrupts\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thclge_reset_vport_state(hdev);\n\tret = hclge_reset_vport_spoofchk(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_resume_vf_rate(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\thclge_init_rxd_adv_layout(hdev);\n\n\tret = hclge_update_wol(hdev);\n\tif (ret)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"failed to update wol config, ret = %d\\n\", ret);\n\n\tdev_info(&pdev->dev, \"Reset done, %s driver initialization finished.\\n\",\n\t\t HCLGE_DRIVER_NAME);\n\n\treturn 0;\n}\n\nstatic void hclge_uninit_ae_dev(struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\n\thclge_reset_vf_rate(hdev);\n\thclge_clear_vf_vlan(hdev);\n\thclge_state_uninit(hdev);\n\thclge_ptp_uninit(hdev);\n\thclge_uninit_rxd_adv_layout(hdev);\n\thclge_uninit_mac_table(hdev);\n\thclge_del_all_fd_entries(hdev);\n\n\tif (mac->phydev)\n\t\tmdiobus_unregister(mac->mdio_bus);\n\n\t \n\thclge_enable_vector(&hdev->misc_vector, false);\n\tsynchronize_irq(hdev->misc_vector.vector_irq);\n\n\t \n\thclge_config_mac_tnl_int(hdev, false);\n\thclge_config_nic_hw_error(hdev, false);\n\thclge_config_rocee_ras_interrupt(hdev, false);\n\n\thclge_comm_cmd_uninit(hdev->ae_dev, &hdev->hw.hw);\n\thclge_misc_irq_uninit(hdev);\n\thclge_devlink_uninit(hdev);\n\thclge_pci_uninit(hdev);\n\thclge_uninit_vport_vlan_table(hdev);\n\tmutex_destroy(&hdev->vport_lock);\n\tae_dev->priv = NULL;\n}\n\nstatic u32 hclge_get_max_channels(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\treturn min_t(u32, hdev->pf_rss_size_max, vport->alloc_tqps);\n}\n\nstatic void hclge_get_channels(struct hnae3_handle *handle,\n\t\t\t       struct ethtool_channels *ch)\n{\n\tch->max_combined = hclge_get_max_channels(handle);\n\tch->other_count = 1;\n\tch->max_other = 1;\n\tch->combined_count = handle->kinfo.rss_size;\n}\n\nstatic void hclge_get_tqps_and_rss_info(struct hnae3_handle *handle,\n\t\t\t\t\tu16 *alloc_tqps, u16 *max_rss_size)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\t*alloc_tqps = vport->alloc_tqps;\n\t*max_rss_size = hdev->pf_rss_size_max;\n}\n\nstatic int hclge_set_rss_tc_mode_cfg(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tu16 tc_offset[HCLGE_MAX_TC_NUM] = {0};\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 tc_size[HCLGE_MAX_TC_NUM] = {0};\n\tu16 tc_valid[HCLGE_MAX_TC_NUM];\n\tu16 roundup_size;\n\tunsigned int i;\n\n\troundup_size = roundup_pow_of_two(vport->nic.kinfo.rss_size);\n\troundup_size = ilog2(roundup_size);\n\t \n\tfor (i = 0; i < HCLGE_MAX_TC_NUM; i++) {\n\t\ttc_valid[i] = 0;\n\n\t\tif (!(hdev->hw_tc_map & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttc_valid[i] = 1;\n\t\ttc_size[i] = roundup_size;\n\t\ttc_offset[i] = vport->nic.kinfo.rss_size * i;\n\t}\n\n\treturn hclge_comm_set_rss_tc_mode(&hdev->hw.hw, tc_offset, tc_valid,\n\t\t\t\t\t  tc_size);\n}\n\nstatic int hclge_set_channels(struct hnae3_handle *handle, u32 new_tqps_num,\n\t\t\t      bool rxfh_configured)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 cur_rss_size = kinfo->rss_size;\n\tu16 cur_tqps = kinfo->num_tqps;\n\tu32 *rss_indir;\n\tunsigned int i;\n\tint ret;\n\n\tkinfo->req_rss_size = new_tqps_num;\n\n\tret = hclge_tm_vport_map_update(hdev);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev, \"tm vport map fail, ret =%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_set_rss_tc_mode_cfg(handle);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (rxfh_configured)\n\t\tgoto out;\n\n\t \n\trss_indir = kcalloc(ae_dev->dev_specs.rss_ind_tbl_size, sizeof(u32),\n\t\t\t    GFP_KERNEL);\n\tif (!rss_indir)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ae_dev->dev_specs.rss_ind_tbl_size; i++)\n\t\trss_indir[i] = i % kinfo->rss_size;\n\n\tret = hclge_set_rss(handle, rss_indir, NULL, 0);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"set rss indir table fail, ret=%d\\n\",\n\t\t\tret);\n\n\tkfree(rss_indir);\n\nout:\n\tif (!ret)\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"Channels changed, rss_size from %u to %u, tqps from %u to %u\",\n\t\t\t cur_rss_size, kinfo->rss_size,\n\t\t\t cur_tqps, kinfo->rss_size * kinfo->tc_info.num_tc);\n\n\treturn ret;\n}\n\nstatic int hclge_set_led_status(struct hclge_dev *hdev, u8 locate_led_status)\n{\n\tstruct hclge_set_led_state_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_LED_STATUS_CFG, false);\n\n\treq = (struct hclge_set_led_state_cmd *)desc.data;\n\thnae3_set_field(req->locate_led_config, HCLGE_LED_LOCATE_STATE_M,\n\t\t\tHCLGE_LED_LOCATE_STATE_S, locate_led_status);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Send set led state cmd error, ret =%d\\n\", ret);\n\n\treturn ret;\n}\n\nenum hclge_led_status {\n\tHCLGE_LED_OFF,\n\tHCLGE_LED_ON,\n\tHCLGE_LED_NO_CHANGE = 0xFF,\n};\n\nstatic int hclge_set_led_id(struct hnae3_handle *handle,\n\t\t\t    enum ethtool_phys_id_state status)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tswitch (status) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn hclge_set_led_status(hdev, HCLGE_LED_ON);\n\tcase ETHTOOL_ID_INACTIVE:\n\t\treturn hclge_set_led_status(hdev, HCLGE_LED_OFF);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void hclge_get_link_mode(struct hnae3_handle *handle,\n\t\t\t\tunsigned long *supported,\n\t\t\t\tunsigned long *advertising)\n{\n\tunsigned int size = BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS);\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tunsigned int idx = 0;\n\n\tfor (; idx < size; idx++) {\n\t\tsupported[idx] = hdev->hw.mac.supported[idx];\n\t\tadvertising[idx] = hdev->hw.mac.advertising[idx];\n\t}\n}\n\nstatic int hclge_gro_en(struct hnae3_handle *handle, bool enable)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tbool gro_en_old = hdev->gro_en;\n\tint ret;\n\n\thdev->gro_en = enable;\n\tret = hclge_config_gro(hdev);\n\tif (ret)\n\t\thdev->gro_en = gro_en_old;\n\n\treturn ret;\n}\n\nstatic int hclge_sync_vport_promisc_mode(struct hclge_vport *vport)\n{\n\tstruct hnae3_handle *handle = &vport->nic;\n\tstruct hclge_dev *hdev = vport->back;\n\tbool uc_en = false;\n\tbool mc_en = false;\n\tu8 tmp_flags;\n\tbool bc_en;\n\tint ret;\n\n\tif (vport->last_promisc_flags != vport->overflow_promisc_flags) {\n\t\tset_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE, &vport->state);\n\t\tvport->last_promisc_flags = vport->overflow_promisc_flags;\n\t}\n\n\tif (!test_and_clear_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE,\n\t\t\t\t&vport->state))\n\t\treturn 0;\n\n\t \n\tif (!vport->vport_id) {\n\t\ttmp_flags = handle->netdev_flags | vport->last_promisc_flags;\n\t\tret = hclge_set_promisc_mode(handle, tmp_flags & HNAE3_UPE,\n\t\t\t\t\t     tmp_flags & HNAE3_MPE);\n\t\tif (!ret)\n\t\t\tset_bit(HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE,\n\t\t\t\t&vport->state);\n\t\telse\n\t\t\tset_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE,\n\t\t\t\t&vport->state);\n\t\treturn ret;\n\t}\n\n\t \n\tif (vport->vf_info.trusted) {\n\t\tuc_en = vport->vf_info.request_uc_en > 0 ||\n\t\t\tvport->overflow_promisc_flags & HNAE3_OVERFLOW_UPE;\n\t\tmc_en = vport->vf_info.request_mc_en > 0 ||\n\t\t\tvport->overflow_promisc_flags & HNAE3_OVERFLOW_MPE;\n\t}\n\tbc_en = vport->vf_info.request_bc_en > 0;\n\n\tret = hclge_cmd_set_promisc_mode(hdev, vport->vport_id, uc_en,\n\t\t\t\t\t mc_en, bc_en);\n\tif (ret) {\n\t\tset_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE, &vport->state);\n\t\treturn ret;\n\t}\n\thclge_set_vport_vlan_fltr_change(vport);\n\n\treturn 0;\n}\n\nstatic void hclge_sync_promisc_mode(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport;\n\tint ret;\n\tu16 i;\n\n\tfor (i = 0; i < hdev->num_alloc_vport; i++) {\n\t\tvport = &hdev->vport[i];\n\n\t\tret = hclge_sync_vport_promisc_mode(vport);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n}\n\nstatic bool hclge_module_existed(struct hclge_dev *hdev)\n{\n\tstruct hclge_desc desc;\n\tu32 existed;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_GET_SFP_EXIST, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get SFP exist state, ret = %d\\n\", ret);\n\t\treturn false;\n\t}\n\n\texisted = le32_to_cpu(desc.data[0]);\n\n\treturn existed != 0;\n}\n\n \nstatic u16 hclge_get_sfp_eeprom_info(struct hclge_dev *hdev, u32 offset,\n\t\t\t\t     u32 len, u8 *data)\n{\n\tstruct hclge_desc desc[HCLGE_SFP_INFO_CMD_NUM];\n\tstruct hclge_sfp_info_bd0_cmd *sfp_info_bd0;\n\tu16 read_len;\n\tu16 copy_len;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < HCLGE_SFP_INFO_CMD_NUM; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_GET_SFP_EEPROM,\n\t\t\t\t\t   true);\n\n\t\t \n\t\tif (i < HCLGE_SFP_INFO_CMD_NUM - 1)\n\t\t\tdesc[i].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t}\n\n\t \n\tsfp_info_bd0 = (struct hclge_sfp_info_bd0_cmd *)desc[0].data;\n\tsfp_info_bd0->offset = cpu_to_le16((u16)offset);\n\tread_len = min_t(u16, len, HCLGE_SFP_INFO_MAX_LEN);\n\tsfp_info_bd0->read_len = cpu_to_le16(read_len);\n\n\tret = hclge_cmd_send(&hdev->hw, desc, i);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to get SFP eeprom info, ret = %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\t \n\tcopy_len = min_t(u16, len, HCLGE_SFP_INFO_BD0_LEN);\n\tmemcpy(data, sfp_info_bd0->data, copy_len);\n\tread_len = copy_len;\n\n\t \n\tfor (i = 1; i < HCLGE_SFP_INFO_CMD_NUM; i++) {\n\t\tif (read_len >= len)\n\t\t\treturn read_len;\n\n\t\tcopy_len = min_t(u16, len - read_len, HCLGE_SFP_INFO_BDX_LEN);\n\t\tmemcpy(data + read_len, desc[i].data, copy_len);\n\t\tread_len += copy_len;\n\t}\n\n\treturn read_len;\n}\n\nstatic int hclge_get_module_eeprom(struct hnae3_handle *handle, u32 offset,\n\t\t\t\t   u32 len, u8 *data)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 read_len = 0;\n\tu16 data_len;\n\n\tif (hdev->hw.mac.media_type != HNAE3_MEDIA_TYPE_FIBER)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!hclge_module_existed(hdev))\n\t\treturn -ENXIO;\n\n\twhile (read_len < len) {\n\t\tdata_len = hclge_get_sfp_eeprom_info(hdev,\n\t\t\t\t\t\t     offset + read_len,\n\t\t\t\t\t\t     len - read_len,\n\t\t\t\t\t\t     data + read_len);\n\t\tif (!data_len)\n\t\t\treturn -EIO;\n\n\t\tread_len += data_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_get_link_diagnosis_info(struct hnae3_handle *handle,\n\t\t\t\t\t u32 *status_code)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tif (hdev->ae_dev->dev_version <= HNAE3_DEVICE_VERSION_V2)\n\t\treturn -EOPNOTSUPP;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_LINK_DIAGNOSIS, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to query link diagnosis info, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*status_code = le32_to_cpu(desc.data[0]);\n\treturn 0;\n}\n\n \nstatic void hclge_clear_vport_vf_info(struct hclge_vport *vport, int vfid)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_vlan_info vlan_info;\n\tint ret;\n\n\tclear_bit(HCLGE_VPORT_STATE_INITED, &vport->state);\n\tclear_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);\n\tvport->need_notify = 0;\n\tvport->mps = 0;\n\n\t \n\tret = hclge_tm_qs_shaper_cfg(vport, 0);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to clean vf%d rate config, ret = %d\\n\",\n\t\t\tvfid, ret);\n\n\tvlan_info.vlan_tag = 0;\n\tvlan_info.qos = 0;\n\tvlan_info.vlan_proto = ETH_P_8021Q;\n\tret = hclge_update_port_base_vlan_cfg(vport,\n\t\t\t\t\t      HNAE3_PORT_BASE_VLAN_DISABLE,\n\t\t\t\t\t      &vlan_info);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to clean vf%d port base vlan, ret = %d\\n\",\n\t\t\tvfid, ret);\n\n\tret = hclge_set_vf_spoofchk_hw(hdev, vport->vport_id, false);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to clean vf%d spoof config, ret = %d\\n\",\n\t\t\tvfid, ret);\n\n\tmemset(&vport->vf_info, 0, sizeof(vport->vf_info));\n}\n\nstatic void hclge_clean_vport_config(struct hnae3_ae_dev *ae_dev, int num_vfs)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct hclge_vport *vport;\n\tint i;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tvport = &hdev->vport[i + HCLGE_VF_VPORT_START_NUM];\n\n\t\thclge_clear_vport_vf_info(vport, i);\n\t}\n}\n\nstatic int hclge_get_dscp_prio(struct hnae3_handle *h, u8 dscp, u8 *tc_mode,\n\t\t\t       u8 *priority)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\n\tif (dscp >= HNAE3_MAX_DSCP)\n\t\treturn -EINVAL;\n\n\tif (tc_mode)\n\t\t*tc_mode = vport->nic.kinfo.tc_map_mode;\n\tif (priority)\n\t\t*priority = vport->nic.kinfo.dscp_prio[dscp] == HNAE3_PRIO_ID_INVALID ? 0 :\n\t\t\t    vport->nic.kinfo.dscp_prio[dscp];\n\n\treturn 0;\n}\n\nstatic const struct hnae3_ae_ops hclge_ops = {\n\t.init_ae_dev = hclge_init_ae_dev,\n\t.uninit_ae_dev = hclge_uninit_ae_dev,\n\t.reset_prepare = hclge_reset_prepare_general,\n\t.reset_done = hclge_reset_done,\n\t.init_client_instance = hclge_init_client_instance,\n\t.uninit_client_instance = hclge_uninit_client_instance,\n\t.map_ring_to_vector = hclge_map_ring_to_vector,\n\t.unmap_ring_from_vector = hclge_unmap_ring_frm_vector,\n\t.get_vector = hclge_get_vector,\n\t.put_vector = hclge_put_vector,\n\t.set_promisc_mode = hclge_set_promisc_mode,\n\t.request_update_promisc_mode = hclge_request_update_promisc_mode,\n\t.set_loopback = hclge_set_loopback,\n\t.start = hclge_ae_start,\n\t.stop = hclge_ae_stop,\n\t.client_start = hclge_client_start,\n\t.client_stop = hclge_client_stop,\n\t.get_status = hclge_get_status,\n\t.get_ksettings_an_result = hclge_get_ksettings_an_result,\n\t.cfg_mac_speed_dup_h = hclge_cfg_mac_speed_dup_h,\n\t.get_media_type = hclge_get_media_type,\n\t.check_port_speed = hclge_check_port_speed,\n\t.get_fec_stats = hclge_get_fec_stats,\n\t.get_fec = hclge_get_fec,\n\t.set_fec = hclge_set_fec,\n\t.get_rss_key_size = hclge_comm_get_rss_key_size,\n\t.get_rss = hclge_get_rss,\n\t.set_rss = hclge_set_rss,\n\t.set_rss_tuple = hclge_set_rss_tuple,\n\t.get_rss_tuple = hclge_get_rss_tuple,\n\t.get_tc_size = hclge_get_tc_size,\n\t.get_mac_addr = hclge_get_mac_addr,\n\t.set_mac_addr = hclge_set_mac_addr,\n\t.do_ioctl = hclge_do_ioctl,\n\t.add_uc_addr = hclge_add_uc_addr,\n\t.rm_uc_addr = hclge_rm_uc_addr,\n\t.add_mc_addr = hclge_add_mc_addr,\n\t.rm_mc_addr = hclge_rm_mc_addr,\n\t.set_autoneg = hclge_set_autoneg,\n\t.get_autoneg = hclge_get_autoneg,\n\t.restart_autoneg = hclge_restart_autoneg,\n\t.halt_autoneg = hclge_halt_autoneg,\n\t.get_pauseparam = hclge_get_pauseparam,\n\t.set_pauseparam = hclge_set_pauseparam,\n\t.set_mtu = hclge_set_mtu,\n\t.reset_queue = hclge_reset_tqp,\n\t.get_stats = hclge_get_stats,\n\t.get_mac_stats = hclge_get_mac_stat,\n\t.update_stats = hclge_update_stats,\n\t.get_strings = hclge_get_strings,\n\t.get_sset_count = hclge_get_sset_count,\n\t.get_fw_version = hclge_get_fw_version,\n\t.get_mdix_mode = hclge_get_mdix_mode,\n\t.enable_vlan_filter = hclge_enable_vlan_filter,\n\t.set_vlan_filter = hclge_set_vlan_filter,\n\t.set_vf_vlan_filter = hclge_set_vf_vlan_filter,\n\t.enable_hw_strip_rxvtag = hclge_en_hw_strip_rxvtag,\n\t.reset_event = hclge_reset_event,\n\t.get_reset_level = hclge_get_reset_level,\n\t.set_default_reset_request = hclge_set_def_reset_request,\n\t.get_tqps_and_rss_info = hclge_get_tqps_and_rss_info,\n\t.set_channels = hclge_set_channels,\n\t.get_channels = hclge_get_channels,\n\t.get_regs_len = hclge_get_regs_len,\n\t.get_regs = hclge_get_regs,\n\t.set_led_id = hclge_set_led_id,\n\t.get_link_mode = hclge_get_link_mode,\n\t.add_fd_entry = hclge_add_fd_entry,\n\t.del_fd_entry = hclge_del_fd_entry,\n\t.get_fd_rule_cnt = hclge_get_fd_rule_cnt,\n\t.get_fd_rule_info = hclge_get_fd_rule_info,\n\t.get_fd_all_rules = hclge_get_all_rules,\n\t.enable_fd = hclge_enable_fd,\n\t.add_arfs_entry = hclge_add_fd_entry_by_arfs,\n\t.dbg_read_cmd = hclge_dbg_read_cmd,\n\t.handle_hw_ras_error = hclge_handle_hw_ras_error,\n\t.get_hw_reset_stat = hclge_get_hw_reset_stat,\n\t.ae_dev_resetting = hclge_ae_dev_resetting,\n\t.ae_dev_reset_cnt = hclge_ae_dev_reset_cnt,\n\t.set_gro_en = hclge_gro_en,\n\t.get_global_queue_id = hclge_covert_handle_qid_global,\n\t.set_timer_task = hclge_set_timer_task,\n\t.mac_connect_phy = hclge_mac_connect_phy,\n\t.mac_disconnect_phy = hclge_mac_disconnect_phy,\n\t.get_vf_config = hclge_get_vf_config,\n\t.set_vf_link_state = hclge_set_vf_link_state,\n\t.set_vf_spoofchk = hclge_set_vf_spoofchk,\n\t.set_vf_trust = hclge_set_vf_trust,\n\t.set_vf_rate = hclge_set_vf_rate,\n\t.set_vf_mac = hclge_set_vf_mac,\n\t.get_module_eeprom = hclge_get_module_eeprom,\n\t.get_cmdq_stat = hclge_get_cmdq_stat,\n\t.add_cls_flower = hclge_add_cls_flower,\n\t.del_cls_flower = hclge_del_cls_flower,\n\t.cls_flower_active = hclge_is_cls_flower_active,\n\t.get_phy_link_ksettings = hclge_get_phy_link_ksettings,\n\t.set_phy_link_ksettings = hclge_set_phy_link_ksettings,\n\t.set_tx_hwts_info = hclge_ptp_set_tx_info,\n\t.get_rx_hwts = hclge_ptp_get_rx_hwts,\n\t.get_ts_info = hclge_ptp_get_ts_info,\n\t.get_link_diagnosis_info = hclge_get_link_diagnosis_info,\n\t.clean_vf_config = hclge_clean_vport_config,\n\t.get_dscp_prio = hclge_get_dscp_prio,\n\t.get_wol = hclge_get_wol,\n\t.set_wol = hclge_set_wol,\n};\n\nstatic struct hnae3_ae_algo ae_algo = {\n\t.ops = &hclge_ops,\n\t.pdev_id_table = ae_algo_pci_tbl,\n};\n\nstatic int __init hclge_init(void)\n{\n\tpr_info(\"%s is initializing\\n\", HCLGE_NAME);\n\n\thclge_wq = alloc_workqueue(\"%s\", WQ_UNBOUND, 0, HCLGE_NAME);\n\tif (!hclge_wq) {\n\t\tpr_err(\"%s: failed to create workqueue\\n\", HCLGE_NAME);\n\t\treturn -ENOMEM;\n\t}\n\n\thnae3_register_ae_algo(&ae_algo);\n\n\treturn 0;\n}\n\nstatic void __exit hclge_exit(void)\n{\n\thnae3_unregister_ae_algo_prepare(&ae_algo);\n\thnae3_unregister_ae_algo(&ae_algo);\n\tdestroy_workqueue(hclge_wq);\n}\nmodule_init(hclge_init);\nmodule_exit(hclge_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Huawei Tech. Co., Ltd.\");\nMODULE_DESCRIPTION(\"HCLGE Driver\");\nMODULE_VERSION(HCLGE_MOD_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}