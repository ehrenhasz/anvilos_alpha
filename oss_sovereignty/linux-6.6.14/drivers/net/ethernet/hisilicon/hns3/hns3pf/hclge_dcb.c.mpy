{
  "module_name": "hclge_dcb.c",
  "hash_id": "51815bf1a10c340f9d2c60c12eb56e39c76628069fd546de3c1b6d7b8ca54570",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_dcb.c",
  "human_readable_source": "\n\n\n#include \"hclge_main.h\"\n#include \"hclge_dcb.h\"\n#include \"hclge_tm.h\"\n#include \"hnae3.h\"\n\n#define BW_PERCENT\t100\n\nstatic int hclge_ieee_ets_to_tm_info(struct hclge_dev *hdev,\n\t\t\t\t     struct ieee_ets *ets)\n{\n\tu8 i;\n\n\tfor (i = 0; i < HNAE3_MAX_TC; i++) {\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\thdev->tm_info.tc_info[i].tc_sch_mode =\n\t\t\t\tHCLGE_SCH_MODE_SP;\n\t\t\thdev->tm_info.pg_info[0].tc_dwrr[i] = 0;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\thdev->tm_info.tc_info[i].tc_sch_mode =\n\t\t\t\tHCLGE_SCH_MODE_DWRR;\n\t\t\thdev->tm_info.pg_info[0].tc_dwrr[i] =\n\t\t\t\tets->tc_tx_bw[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\thclge_tm_prio_tc_info_update(hdev, ets->prio_tc);\n\n\treturn 0;\n}\n\nstatic void hclge_tm_info_to_ieee_ets(struct hclge_dev *hdev,\n\t\t\t\t      struct ieee_ets *ets)\n{\n\tu32 i;\n\n\tmemset(ets, 0, sizeof(*ets));\n\tets->willing = 1;\n\tets->ets_cap = hdev->tc_max;\n\n\tfor (i = 0; i < HNAE3_MAX_TC; i++) {\n\t\tets->prio_tc[i] = hdev->tm_info.prio_tc[i];\n\t\tif (i < hdev->tm_info.num_tc)\n\t\t\tets->tc_tx_bw[i] = hdev->tm_info.pg_info[0].tc_dwrr[i];\n\t\telse\n\t\t\tets->tc_tx_bw[i] = 0;\n\n\t\tif (hdev->tm_info.tc_info[i].tc_sch_mode ==\n\t\t    HCLGE_SCH_MODE_SP)\n\t\t\tets->tc_tsa[i] = IEEE_8021QAZ_TSA_STRICT;\n\t\telse\n\t\t\tets->tc_tsa[i] = IEEE_8021QAZ_TSA_ETS;\n\t}\n}\n\n \nstatic int hclge_ieee_getets(struct hnae3_handle *h, struct ieee_ets *ets)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct hclge_dev *hdev = vport->back;\n\n\thclge_tm_info_to_ieee_ets(hdev, ets);\n\n\treturn 0;\n}\n\nstatic int hclge_dcb_common_validate(struct hclge_dev *hdev, u8 num_tc,\n\t\t\t\t     u8 *prio_tc)\n{\n\tint i;\n\n\tif (num_tc > hdev->tc_max) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"tc num checking failed, %u > tc_max(%u)\\n\",\n\t\t\tnum_tc, hdev->tc_max);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < HNAE3_MAX_USER_PRIO; i++) {\n\t\tif (prio_tc[i] >= num_tc) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"prio_tc[%d] checking failed, %u >= num_tc(%u)\\n\",\n\t\t\t\ti, prio_tc[i], num_tc);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (num_tc > hdev->vport[0].alloc_tqps) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"allocated tqp checking failed, %u > tqp(%u)\\n\",\n\t\t\tnum_tc, hdev->vport[0].alloc_tqps);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 hclge_ets_tc_changed(struct hclge_dev *hdev, struct ieee_ets *ets,\n\t\t\t       bool *changed)\n{\n\tu8 max_tc_id = 0;\n\tu8 i;\n\n\tfor (i = 0; i < HNAE3_MAX_USER_PRIO; i++) {\n\t\tif (ets->prio_tc[i] != hdev->tm_info.prio_tc[i])\n\t\t\t*changed = true;\n\n\t\tif (ets->prio_tc[i] > max_tc_id)\n\t\t\tmax_tc_id = ets->prio_tc[i];\n\t}\n\n\t \n\treturn max_tc_id + 1;\n}\n\nstatic int hclge_ets_sch_mode_validate(struct hclge_dev *hdev,\n\t\t\t\t       struct ieee_ets *ets, bool *changed,\n\t\t\t\t       u8 tc_num)\n{\n\tbool has_ets_tc = false;\n\tu32 total_ets_bw = 0;\n\tu8 i;\n\n\tfor (i = 0; i < HNAE3_MAX_TC; i++) {\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\tif (hdev->tm_info.tc_info[i].tc_sch_mode !=\n\t\t\t\tHCLGE_SCH_MODE_SP)\n\t\t\t\t*changed = true;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\tif (i >= tc_num) {\n\t\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\t\"tc%u is disabled, cannot set ets bw\\n\",\n\t\t\t\t\ti);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!ets->tc_tx_bw[i]) {\n\t\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\t\"tc%u ets bw cannot be 0\\n\", i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (hdev->tm_info.tc_info[i].tc_sch_mode !=\n\t\t\t\tHCLGE_SCH_MODE_DWRR)\n\t\t\t\t*changed = true;\n\n\t\t\ttotal_ets_bw += ets->tc_tx_bw[i];\n\t\t\thas_ets_tc = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (has_ets_tc && total_ets_bw != BW_PERCENT)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hclge_ets_validate(struct hclge_dev *hdev, struct ieee_ets *ets,\n\t\t\t      u8 *tc, bool *changed)\n{\n\tu8 tc_num;\n\tint ret;\n\n\ttc_num = hclge_ets_tc_changed(hdev, ets, changed);\n\n\tret = hclge_dcb_common_validate(hdev, tc_num, ets->prio_tc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_ets_sch_mode_validate(hdev, ets, changed, tc_num);\n\tif (ret)\n\t\treturn ret;\n\n\t*tc = tc_num;\n\tif (*tc != hdev->tm_info.num_tc)\n\t\t*changed = true;\n\n\treturn 0;\n}\n\nstatic int hclge_map_update(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\tret = hclge_tm_schd_setup_hw(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_pause_setup_hw(hdev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_buffer_alloc(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\thclge_comm_rss_indir_init_cfg(hdev->ae_dev, &hdev->rss_cfg);\n\n\treturn hclge_rss_init_hw(hdev);\n}\n\nstatic int hclge_notify_down_uinit(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\tret = hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_tm_flush_cfg(hdev, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_notify_client(hdev, HNAE3_UNINIT_CLIENT);\n}\n\nstatic int hclge_notify_init_up(struct hclge_dev *hdev)\n{\n\tint ret;\n\n\tret = hclge_notify_client(hdev, HNAE3_INIT_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_tm_flush_cfg(hdev, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hclge_notify_client(hdev, HNAE3_UP_CLIENT);\n}\n\nstatic int hclge_ieee_setets(struct hnae3_handle *h, struct ieee_ets *ets)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct net_device *netdev = h->kinfo.netdev;\n\tstruct hclge_dev *hdev = vport->back;\n\tbool map_changed = false;\n\tu8 num_tc = 0;\n\tint ret;\n\n\tif (!(hdev->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    h->kinfo.tc_info.mqprio_active)\n\t\treturn -EINVAL;\n\n\tret = hclge_ets_validate(hdev, ets, &num_tc, &map_changed);\n\tif (ret)\n\t\treturn ret;\n\n\tif (map_changed) {\n\t\tnetif_dbg(h, drv, netdev, \"set ets\\n\");\n\n\t\tret = hclge_notify_down_uinit(hdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\thclge_tm_schd_info_update(hdev, num_tc);\n\th->kinfo.tc_info.dcb_ets_active = num_tc > 1;\n\n\tret = hclge_ieee_ets_to_tm_info(hdev, ets);\n\tif (ret)\n\t\tgoto err_out;\n\n\tif (map_changed) {\n\t\tret = hclge_map_update(hdev);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\n\t\treturn hclge_notify_init_up(hdev);\n\t}\n\n\treturn hclge_tm_dwrr_cfg(hdev);\n\nerr_out:\n\tif (!map_changed)\n\t\treturn ret;\n\n\thclge_notify_init_up(hdev);\n\n\treturn ret;\n}\n\nstatic int hclge_ieee_getpfc(struct hnae3_handle *h, struct ieee_pfc *pfc)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tmemset(pfc, 0, sizeof(*pfc));\n\tpfc->pfc_cap = hdev->pfc_max;\n\tpfc->pfc_en = hdev->tm_info.pfc_en;\n\n\tret = hclge_mac_update_stats(hdev);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to update MAC stats, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thclge_pfc_tx_stats_get(hdev, pfc->requests);\n\thclge_pfc_rx_stats_get(hdev, pfc->indications);\n\n\treturn 0;\n}\n\nstatic int hclge_ieee_setpfc(struct hnae3_handle *h, struct ieee_pfc *pfc)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct net_device *netdev = h->kinfo.netdev;\n\tstruct hclge_dev *hdev = vport->back;\n\tu8 i, j, pfc_map, *prio_tc;\n\tint last_bad_ret = 0;\n\tint ret;\n\n\tif (!(hdev->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\n\t\treturn -EINVAL;\n\n\tif (pfc->pfc_en == hdev->tm_info.pfc_en)\n\t\treturn 0;\n\n\tprio_tc = hdev->tm_info.prio_tc;\n\tpfc_map = 0;\n\n\tfor (i = 0; i < hdev->tm_info.num_tc; i++) {\n\t\tfor (j = 0; j < HNAE3_MAX_USER_PRIO; j++) {\n\t\t\tif ((prio_tc[j] == i) && (pfc->pfc_en & BIT(j))) {\n\t\t\t\tpfc_map |= BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\thdev->tm_info.hw_pfc_map = pfc_map;\n\thdev->tm_info.pfc_en = pfc->pfc_en;\n\n\tnetif_dbg(h, drv, netdev,\n\t\t  \"set pfc: pfc_en=%x, pfc_map=%x, num_tc=%u\\n\",\n\t\t  pfc->pfc_en, pfc_map, hdev->tm_info.num_tc);\n\n\thclge_tm_pfc_info_update(hdev);\n\n\tret = hclge_pause_setup_hw(hdev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_tm_flush_cfg(hdev, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = hclge_buffer_alloc(hdev);\n\tif (ret)\n\t\tlast_bad_ret = ret;\n\n\tret = hclge_tm_flush_cfg(hdev, false);\n\tif (ret)\n\t\tlast_bad_ret = ret;\n\n\tret = hclge_notify_client(hdev, HNAE3_UP_CLIENT);\n\tif (ret)\n\t\tlast_bad_ret = ret;\n\n\treturn last_bad_ret;\n}\n\nstatic int hclge_ieee_setapp(struct hnae3_handle *h, struct dcb_app *app)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct net_device *netdev = h->kinfo.netdev;\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct dcb_app old_app;\n\tint ret;\n\n\tif (app->selector != IEEE_8021QAZ_APP_SEL_DSCP ||\n\t    app->protocol >= HNAE3_MAX_DSCP ||\n\t    app->priority >= HNAE3_MAX_USER_PRIO)\n\t\treturn -EINVAL;\n\n\tdev_info(&hdev->pdev->dev, \"setapp dscp=%u priority=%u\\n\",\n\t\t app->protocol, app->priority);\n\n\tif (app->priority == h->kinfo.dscp_prio[app->protocol])\n\t\treturn 0;\n\n\tret = dcb_ieee_setapp(netdev, app);\n\tif (ret)\n\t\treturn ret;\n\n\told_app.selector = IEEE_8021QAZ_APP_SEL_DSCP;\n\told_app.protocol = app->protocol;\n\told_app.priority = h->kinfo.dscp_prio[app->protocol];\n\n\th->kinfo.dscp_prio[app->protocol] = app->priority;\n\tret = hclge_dscp_to_tc_map(hdev);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set dscp to tc map, ret = %d\\n\", ret);\n\t\th->kinfo.dscp_prio[app->protocol] = old_app.priority;\n\t\t(void)dcb_ieee_delapp(netdev, app);\n\t\treturn ret;\n\t}\n\n\tvport->nic.kinfo.tc_map_mode = HNAE3_TC_MAP_MODE_DSCP;\n\tif (old_app.priority == HNAE3_PRIO_ID_INVALID)\n\t\th->kinfo.dscp_app_cnt++;\n\telse\n\t\tret = dcb_ieee_delapp(netdev, &old_app);\n\n\treturn ret;\n}\n\nstatic int hclge_ieee_delapp(struct hnae3_handle *h, struct dcb_app *app)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct net_device *netdev = h->kinfo.netdev;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tif (app->selector != IEEE_8021QAZ_APP_SEL_DSCP ||\n\t    app->protocol >= HNAE3_MAX_DSCP ||\n\t    app->priority >= HNAE3_MAX_USER_PRIO ||\n\t    app->priority != h->kinfo.dscp_prio[app->protocol])\n\t\treturn -EINVAL;\n\n\tdev_info(&hdev->pdev->dev, \"delapp dscp=%u priority=%u\\n\",\n\t\t app->protocol, app->priority);\n\n\tret = dcb_ieee_delapp(netdev, app);\n\tif (ret)\n\t\treturn ret;\n\n\th->kinfo.dscp_prio[app->protocol] = HNAE3_PRIO_ID_INVALID;\n\tret = hclge_dscp_to_tc_map(hdev);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to del dscp to tc map, ret = %d\\n\", ret);\n\t\th->kinfo.dscp_prio[app->protocol] = app->priority;\n\t\t(void)dcb_ieee_setapp(netdev, app);\n\t\treturn ret;\n\t}\n\n\tif (h->kinfo.dscp_app_cnt)\n\t\th->kinfo.dscp_app_cnt--;\n\n\tif (!h->kinfo.dscp_app_cnt) {\n\t\tvport->nic.kinfo.tc_map_mode = HNAE3_TC_MAP_MODE_PRIO;\n\t\tret = hclge_up_to_tc_map(hdev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic u8 hclge_getdcbx(struct hnae3_handle *h)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (h->kinfo.tc_info.mqprio_active)\n\t\treturn 0;\n\n\treturn hdev->dcbx_cap;\n}\n\nstatic u8 hclge_setdcbx(struct hnae3_handle *h, u8 mode)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct net_device *netdev = h->kinfo.netdev;\n\tstruct hclge_dev *hdev = vport->back;\n\n\tnetif_dbg(h, drv, netdev, \"set dcbx: mode=%u\\n\", mode);\n\n\t \n\tif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    (mode & DCB_CAP_DCBX_VER_CEE) ||\n\t    !(mode & DCB_CAP_DCBX_HOST))\n\t\treturn 1;\n\n\thdev->dcbx_cap = mode;\n\n\treturn 0;\n}\n\nstatic int hclge_mqprio_qopt_check(struct hclge_dev *hdev,\n\t\t\t\t   struct tc_mqprio_qopt_offload *mqprio_qopt)\n{\n\tu16 queue_sum = 0;\n\tint ret;\n\tint i;\n\n\tif (!mqprio_qopt->qopt.num_tc) {\n\t\tmqprio_qopt->qopt.num_tc = 1;\n\t\treturn 0;\n\t}\n\n\tret = hclge_dcb_common_validate(hdev, mqprio_qopt->qopt.num_tc,\n\t\t\t\t\tmqprio_qopt->qopt.prio_tc_map);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < mqprio_qopt->qopt.num_tc; i++) {\n\t\tif (!is_power_of_2(mqprio_qopt->qopt.count[i])) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"qopt queue count must be power of 2\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mqprio_qopt->qopt.count[i] > hdev->pf_rss_size_max) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"qopt queue count should be no more than %u\\n\",\n\t\t\t\thdev->pf_rss_size_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mqprio_qopt->qopt.offset[i] != queue_sum) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"qopt queue offset must start from 0, and being continuous\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mqprio_qopt->min_rate[i] || mqprio_qopt->max_rate[i]) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"qopt tx_rate is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tqueue_sum = mqprio_qopt->qopt.offset[i];\n\t\tqueue_sum += mqprio_qopt->qopt.count[i];\n\t}\n\tif (hdev->vport[0].alloc_tqps < queue_sum) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"qopt queue count sum should be less than %u\\n\",\n\t\t\thdev->vport[0].alloc_tqps);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hclge_sync_mqprio_qopt(struct hnae3_tc_info *tc_info,\n\t\t\t\t   struct tc_mqprio_qopt_offload *mqprio_qopt)\n{\n\tmemset(tc_info, 0, sizeof(*tc_info));\n\ttc_info->num_tc = mqprio_qopt->qopt.num_tc;\n\tmemcpy(tc_info->prio_tc, mqprio_qopt->qopt.prio_tc_map,\n\t       sizeof_field(struct hnae3_tc_info, prio_tc));\n\tmemcpy(tc_info->tqp_count, mqprio_qopt->qopt.count,\n\t       sizeof_field(struct hnae3_tc_info, tqp_count));\n\tmemcpy(tc_info->tqp_offset, mqprio_qopt->qopt.offset,\n\t       sizeof_field(struct hnae3_tc_info, tqp_offset));\n}\n\nstatic int hclge_config_tc(struct hclge_dev *hdev,\n\t\t\t   struct hnae3_tc_info *tc_info)\n{\n\tint i;\n\n\thclge_tm_schd_info_update(hdev, tc_info->num_tc);\n\tfor (i = 0; i < HNAE3_MAX_USER_PRIO; i++)\n\t\thdev->tm_info.prio_tc[i] = tc_info->prio_tc[i];\n\n\treturn hclge_map_update(hdev);\n}\n\n \nstatic int hclge_setup_tc(struct hnae3_handle *h,\n\t\t\t  struct tc_mqprio_qopt_offload *mqprio_qopt)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct hnae3_knic_private_info *kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hnae3_tc_info old_tc_info;\n\tu8 tc = mqprio_qopt->qopt.num_tc;\n\tint ret;\n\n\t \n\tif (!test_bit(HCLGE_STATE_NIC_REGISTERED, &hdev->state))\n\t\treturn -EBUSY;\n\n\tkinfo = &vport->nic.kinfo;\n\tif (kinfo->tc_info.dcb_ets_active)\n\t\treturn -EINVAL;\n\n\tret = hclge_mqprio_qopt_check(hdev, mqprio_qopt);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to check mqprio qopt params, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_notify_down_uinit(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&old_tc_info, &kinfo->tc_info, sizeof(old_tc_info));\n\thclge_sync_mqprio_qopt(&kinfo->tc_info, mqprio_qopt);\n\tkinfo->tc_info.mqprio_active = tc > 0;\n\n\tret = hclge_config_tc(hdev, &kinfo->tc_info);\n\tif (ret)\n\t\tgoto err_out;\n\n\treturn hclge_notify_init_up(hdev);\n\nerr_out:\n\tif (!tc) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"failed to destroy mqprio, will active after reset, ret = %d\\n\",\n\t\t\t ret);\n\t} else {\n\t\t \n\t\tmemcpy(&kinfo->tc_info, &old_tc_info, sizeof(old_tc_info));\n\t\tif (hclge_config_tc(hdev, &kinfo->tc_info))\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to roll back tc configuration\\n\");\n\t}\n\thclge_notify_init_up(hdev);\n\n\treturn ret;\n}\n\nstatic const struct hnae3_dcb_ops hns3_dcb_ops = {\n\t.ieee_getets\t= hclge_ieee_getets,\n\t.ieee_setets\t= hclge_ieee_setets,\n\t.ieee_getpfc\t= hclge_ieee_getpfc,\n\t.ieee_setpfc\t= hclge_ieee_setpfc,\n\t.ieee_setapp    = hclge_ieee_setapp,\n\t.ieee_delapp    = hclge_ieee_delapp,\n\t.getdcbx\t= hclge_getdcbx,\n\t.setdcbx\t= hclge_setdcbx,\n\t.setup_tc\t= hclge_setup_tc,\n};\n\nvoid hclge_dcb_ops_set(struct hclge_dev *hdev)\n{\n\tstruct hclge_vport *vport = hdev->vport;\n\tstruct hnae3_knic_private_info *kinfo;\n\n\t \n\tif (!hnae3_dev_dcb_supported(hdev) ||\n\t    vport->vport_id != 0)\n\t\treturn;\n\n\tkinfo = &vport->nic.kinfo;\n\tkinfo->dcb_ops = &hns3_dcb_ops;\n\thdev->dcbx_cap = DCB_CAP_DCBX_VER_IEEE | DCB_CAP_DCBX_HOST;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}