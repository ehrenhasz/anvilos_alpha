{
  "module_name": "hclge_err.c",
  "hash_id": "9dc387e1c6e8e8cff31da2161a7fbd8366d1e2ffa800e99f562e0cb19a1d9e3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_err.c",
  "human_readable_source": "\n \n\n#include <linux/sched/clock.h>\n\n#include \"hclge_err.h\"\n\nstatic const struct hclge_hw_error hclge_imp_tcm_ecc_int[] = {\n\t{\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"imp_itcm0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"imp_itcm1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"imp_itcm2_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"imp_itcm3_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"imp_dtcm0_mem0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"imp_dtcm0_mem1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"imp_dtcm1_mem0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"imp_dtcm1_mem1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"imp_itcm4_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_cmdq_nic_mem_ecc_int[] = {\n\t{\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"cmdq_nic_rx_depth_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"cmdq_nic_tx_depth_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"cmdq_nic_rx_tail_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"cmdq_nic_tx_tail_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"cmdq_nic_rx_head_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"cmdq_nic_tx_head_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"cmdq_nic_rx_addr_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"cmdq_nic_tx_addr_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"cmdq_rocee_rx_depth_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(19),\n\t\t.msg = \"cmdq_rocee_tx_depth_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(21),\n\t\t.msg = \"cmdq_rocee_rx_tail_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(23),\n\t\t.msg = \"cmdq_rocee_tx_tail_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(25),\n\t\t.msg = \"cmdq_rocee_rx_head_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(27),\n\t\t.msg = \"cmdq_rocee_tx_head_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(29),\n\t\t.msg = \"cmdq_rocee_rx_addr_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(31),\n\t\t.msg = \"cmdq_rocee_tx_addr_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_tqp_int_ecc_int[] = {\n\t{\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"tqp_int_cfg_even_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"tqp_int_cfg_odd_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"tqp_int_ctrl_even_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"tqp_int_ctrl_odd_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(10),\n\t\t.msg = \"tx_que_scan_int_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"rx_que_scan_int_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_msix_sram_ecc_int[] = {\n\t{\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"msix_nic_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"msix_rocee_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_igu_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"igu_rx_buf0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"igu_rx_buf1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_igu_egu_tnl_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"rx_buf_overflow\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"rx_stp_fifo_overflow\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"rx_stp_fifo_underflow\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"tx_buf_overflow\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"tx_buf_underrun\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"rx_stp_buf_overflow\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ncsi_err_int[] = {\n\t{\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"ncsi_tx_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ppp_mpf_abnormal_int_st1[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"vf_vlan_ad_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"umv_mcast_group_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"umv_key_mem0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"umv_key_mem1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"umv_key_mem2_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"umv_key_mem3_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"umv_ad_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"rss_tc_mode_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"rss_idt_mem0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"rss_idt_mem1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(10),\n\t\t.msg = \"rss_idt_mem2_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"rss_idt_mem3_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(12),\n\t\t.msg = \"rss_idt_mem4_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"rss_idt_mem5_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(14),\n\t\t.msg = \"rss_idt_mem6_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"rss_idt_mem7_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(16),\n\t\t.msg = \"rss_idt_mem8_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"rss_idt_mem9_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(18),\n\t\t.msg = \"rss_idt_mem10_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(19),\n\t\t.msg = \"rss_idt_mem11_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(20),\n\t\t.msg = \"rss_idt_mem12_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(21),\n\t\t.msg = \"rss_idt_mem13_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(22),\n\t\t.msg = \"rss_idt_mem14_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(23),\n\t\t.msg = \"rss_idt_mem15_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(24),\n\t\t.msg = \"port_vlan_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(25),\n\t\t.msg = \"mcast_linear_table_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(26),\n\t\t.msg = \"mcast_result_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(27),\n\t\t.msg = \"flow_director_ad_mem0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(28),\n\t\t.msg = \"flow_director_ad_mem1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(29),\n\t\t.msg = \"rx_vlan_tag_memory_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(30),\n\t\t.msg = \"Tx_UP_mapping_config_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ppp_pf_abnormal_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"tx_vlan_tag_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"rss_list_tc_unassigned_queue_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ppp_mpf_abnormal_int_st3[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"hfs_fifo_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"rslt_descr_fifo_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"tx_vlan_tag_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"FD_CN0_memory_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"FD_CN1_memory_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"GRO_AD_memory_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_tm_sch_rint[] = {\n\t{\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"tm_sch_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"tm_sch_port_shap_sub_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"tm_sch_port_shap_sub_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"tm_sch_pg_pshap_sub_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"tm_sch_pg_pshap_sub_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"tm_sch_pg_cshap_sub_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"tm_sch_pg_cshap_sub_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"tm_sch_pri_pshap_sub_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"tm_sch_pri_pshap_sub_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(10),\n\t\t.msg = \"tm_sch_pri_cshap_sub_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"tm_sch_pri_cshap_sub_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(12),\n\t\t.msg = \"tm_sch_port_shap_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"tm_sch_port_shap_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(14),\n\t\t.msg = \"tm_sch_pg_pshap_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"tm_sch_pg_pshap_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(16),\n\t\t.msg = \"tm_sch_pg_cshap_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"tm_sch_pg_cshap_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(18),\n\t\t.msg = \"tm_sch_pri_pshap_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(19),\n\t\t.msg = \"tm_sch_pri_pshap_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(20),\n\t\t.msg = \"tm_sch_pri_cshap_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(21),\n\t\t.msg = \"tm_sch_pri_cshap_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(22),\n\t\t.msg = \"tm_sch_rq_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(23),\n\t\t.msg = \"tm_sch_rq_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(24),\n\t\t.msg = \"tm_sch_nq_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(25),\n\t\t.msg = \"tm_sch_nq_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(26),\n\t\t.msg = \"tm_sch_roce_up_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(27),\n\t\t.msg = \"tm_sch_roce_up_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(28),\n\t\t.msg = \"tm_sch_rcb_byte_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(29),\n\t\t.msg = \"tm_sch_rcb_byte_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(30),\n\t\t.msg = \"tm_sch_ssu_byte_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(31),\n\t\t.msg = \"tm_sch_ssu_byte_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_qcn_fifo_rint[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"qcn_shap_gp0_sch_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"qcn_shap_gp0_sch_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"qcn_shap_gp1_sch_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"qcn_shap_gp1_sch_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"qcn_shap_gp2_sch_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"qcn_shap_gp2_sch_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"qcn_shap_gp3_sch_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"qcn_shap_gp3_sch_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"qcn_shap_gp0_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"qcn_shap_gp0_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(10),\n\t\t.msg = \"qcn_shap_gp1_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"qcn_shap_gp1_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(12),\n\t\t.msg = \"qcn_shap_gp2_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"qcn_shap_gp2_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(14),\n\t\t.msg = \"qcn_shap_gp3_offset_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"qcn_shap_gp3_offset_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(16),\n\t\t.msg = \"qcn_byte_info_fifo_rd_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"qcn_byte_info_fifo_wr_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_qcn_ecc_rint[] = {\n\t{\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"qcn_byte_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"qcn_time_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"qcn_fb_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"qcn_link_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"qcn_rate_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"qcn_tmplt_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"qcn_shap_cfg_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"qcn_gp0_barrel_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"qcn_gp1_barrel_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(19),\n\t\t.msg = \"qcn_gp2_barrel_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(21),\n\t\t.msg = \"qcn_gp3_barral_mem_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_mac_afifo_tnl_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"egu_cge_afifo_ecc_1bit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"egu_cge_afifo_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"egu_lge_afifo_ecc_1bit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"egu_lge_afifo_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"cge_igu_afifo_ecc_1bit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"cge_igu_afifo_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"lge_igu_afifo_ecc_1bit_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"lge_igu_afifo_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"cge_igu_afifo_overflow_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"lge_igu_afifo_overflow_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(10),\n\t\t.msg = \"egu_cge_afifo_underrun_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"egu_lge_afifo_underrun_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(12),\n\t\t.msg = \"egu_ge_afifo_underrun_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"ge_igu_afifo_overflow_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ppu_mpf_abnormal_int_st2[] = {\n\t{\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"rpu_rx_pkt_bit32_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(14),\n\t\t.msg = \"rpu_rx_pkt_bit33_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"rpu_rx_pkt_bit34_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(16),\n\t\t.msg = \"rpu_rx_pkt_bit35_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"rcb_tx_ring_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(18),\n\t\t.msg = \"rcb_rx_ring_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(19),\n\t\t.msg = \"rcb_tx_fbd_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(20),\n\t\t.msg = \"rcb_rx_ebd_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(21),\n\t\t.msg = \"rcb_tso_info_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(22),\n\t\t.msg = \"rcb_tx_int_info_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(23),\n\t\t.msg = \"rcb_rx_int_info_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(24),\n\t\t.msg = \"tpu_tx_pkt_0_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(25),\n\t\t.msg = \"tpu_tx_pkt_1_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(26),\n\t\t.msg = \"rd_bus_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(27),\n\t\t.msg = \"wr_bus_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(28),\n\t\t.msg = \"reg_search_miss\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(29),\n\t\t.msg = \"rx_q_search_miss\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(30),\n\t\t.msg = \"ooo_ecc_err_detect\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(31),\n\t\t.msg = \"ooo_ecc_err_multpl\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ppu_mpf_abnormal_int_st3[] = {\n\t{\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"gro_bd_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"gro_context_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"rx_stash_cfg_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"axi_rd_fbd_ecc_mbit_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ppu_pf_abnormal_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"over_8bd_no_fe\",\n\t\t.reset_level = HNAE3_FUNC_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"tso_mss_cmp_min_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"tso_mss_cmp_max_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"tx_rd_fbd_poison\",\n\t\t.reset_level = HNAE3_FUNC_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"rx_rd_ebd_poison\",\n\t\t.reset_level = HNAE3_FUNC_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"buf_wait_timeout\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ssu_com_err_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"buf_sum_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"ppp_mb_num_err\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"ppp_mbid_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"ppp_rlt_mac_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"ppp_rlt_host_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"cks_edit_position_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"cks_edit_condition_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"vlan_edit_condition_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"vlan_num_ot_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"vlan_num_in_err\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\n#define HCLGE_SSU_MEM_ECC_ERR(x) \\\n{ \\\n\t.int_msk = BIT(x), \\\n\t.msg = \"ssu_mem\" #x \"_ecc_mbit_err\", \\\n\t.reset_level = HNAE3_GLOBAL_RESET \\\n}\n\nstatic const struct hclge_hw_error hclge_ssu_mem_ecc_err_int[] = {\n\tHCLGE_SSU_MEM_ECC_ERR(0),\n\tHCLGE_SSU_MEM_ECC_ERR(1),\n\tHCLGE_SSU_MEM_ECC_ERR(2),\n\tHCLGE_SSU_MEM_ECC_ERR(3),\n\tHCLGE_SSU_MEM_ECC_ERR(4),\n\tHCLGE_SSU_MEM_ECC_ERR(5),\n\tHCLGE_SSU_MEM_ECC_ERR(6),\n\tHCLGE_SSU_MEM_ECC_ERR(7),\n\tHCLGE_SSU_MEM_ECC_ERR(8),\n\tHCLGE_SSU_MEM_ECC_ERR(9),\n\tHCLGE_SSU_MEM_ECC_ERR(10),\n\tHCLGE_SSU_MEM_ECC_ERR(11),\n\tHCLGE_SSU_MEM_ECC_ERR(12),\n\tHCLGE_SSU_MEM_ECC_ERR(13),\n\tHCLGE_SSU_MEM_ECC_ERR(14),\n\tHCLGE_SSU_MEM_ECC_ERR(15),\n\tHCLGE_SSU_MEM_ECC_ERR(16),\n\tHCLGE_SSU_MEM_ECC_ERR(17),\n\tHCLGE_SSU_MEM_ECC_ERR(18),\n\tHCLGE_SSU_MEM_ECC_ERR(19),\n\tHCLGE_SSU_MEM_ECC_ERR(20),\n\tHCLGE_SSU_MEM_ECC_ERR(21),\n\tHCLGE_SSU_MEM_ECC_ERR(22),\n\tHCLGE_SSU_MEM_ECC_ERR(23),\n\tHCLGE_SSU_MEM_ECC_ERR(24),\n\tHCLGE_SSU_MEM_ECC_ERR(25),\n\tHCLGE_SSU_MEM_ECC_ERR(26),\n\tHCLGE_SSU_MEM_ECC_ERR(27),\n\tHCLGE_SSU_MEM_ECC_ERR(28),\n\tHCLGE_SSU_MEM_ECC_ERR(29),\n\tHCLGE_SSU_MEM_ECC_ERR(30),\n\tHCLGE_SSU_MEM_ECC_ERR(31),\n\t{   }\n};\n\nstatic const struct hclge_hw_error hclge_ssu_port_based_err_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"roc_pkt_without_key_port\",\n\t\t.reset_level = HNAE3_FUNC_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"tpu_pkt_without_key_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"igu_pkt_without_key_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"roc_eof_mis_match_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"tpu_eof_mis_match_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"igu_eof_mis_match_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"roc_sof_mis_match_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"tpu_sof_mis_match_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"igu_sof_mis_match_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"ets_rd_int_rx_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(12),\n\t\t.msg = \"ets_wr_int_rx_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"ets_rd_int_tx_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(14),\n\t\t.msg = \"ets_wr_int_tx_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ssu_fifo_overflow_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"ig_mac_inf_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"ig_host_inf_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"ig_roc_buf_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"ig_host_data_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(4),\n\t\t.msg = \"ig_host_key_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(5),\n\t\t.msg = \"tx_qcn_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(6),\n\t\t.msg = \"rx_qcn_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(7),\n\t\t.msg = \"tx_pf_rd_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(8),\n\t\t.msg = \"rx_pf_rd_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"qm_eof_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(10),\n\t\t.msg = \"mb_rlt_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(11),\n\t\t.msg = \"dup_uncopy_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(12),\n\t\t.msg = \"dup_cnt_rd_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(13),\n\t\t.msg = \"dup_cnt_drop_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(14),\n\t\t.msg = \"dup_cnt_wrb_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(15),\n\t\t.msg = \"host_cmd_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(16),\n\t\t.msg = \"mac_cmd_fifo_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(17),\n\t\t.msg = \"host_cmd_bitmap_empty_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(18),\n\t\t.msg = \"mac_cmd_bitmap_empty_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(19),\n\t\t.msg = \"dup_bitmap_empty_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(20),\n\t\t.msg = \"out_queue_bitmap_empty_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(21),\n\t\t.msg = \"bank2_bitmap_empty_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(22),\n\t\t.msg = \"bank1_bitmap_empty_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(23),\n\t\t.msg = \"bank0_bitmap_empty_int\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ssu_ets_tcg_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"ets_rd_int_rx_tcg\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(1),\n\t\t.msg = \"ets_wr_int_rx_tcg\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(2),\n\t\t.msg = \"ets_rd_int_tx_tcg\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t.int_msk = BIT(3),\n\t\t.msg = \"ets_wr_int_tx_tcg\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_ssu_port_based_pf_int[] = {\n\t{\n\t\t.int_msk = BIT(0),\n\t\t.msg = \"roc_pkt_without_key_port\",\n\t\t.reset_level = HNAE3_FUNC_RESET\n\t}, {\n\t\t.int_msk = BIT(9),\n\t\t.msg = \"low_water_line_err_port\",\n\t\t.reset_level = HNAE3_NONE_RESET\n\t}, {\n\t\t.int_msk = BIT(10),\n\t\t.msg = \"hi_water_line_err_port\",\n\t\t.reset_level = HNAE3_GLOBAL_RESET\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_error hclge_rocee_qmm_ovf_err_int[] = {\n\t{\n\t\t.int_msk = 0,\n\t\t.msg = \"rocee qmm ovf: sgid invalid err\"\n\t}, {\n\t\t.int_msk = 0x4,\n\t\t.msg = \"rocee qmm ovf: sgid ovf err\"\n\t}, {\n\t\t.int_msk = 0x8,\n\t\t.msg = \"rocee qmm ovf: smac invalid err\"\n\t}, {\n\t\t.int_msk = 0xC,\n\t\t.msg = \"rocee qmm ovf: smac ovf err\"\n\t}, {\n\t\t.int_msk = 0x10,\n\t\t.msg = \"rocee qmm ovf: cqc invalid err\"\n\t}, {\n\t\t.int_msk = 0x11,\n\t\t.msg = \"rocee qmm ovf: cqc ovf err\"\n\t}, {\n\t\t.int_msk = 0x12,\n\t\t.msg = \"rocee qmm ovf: cqc hopnum err\"\n\t}, {\n\t\t.int_msk = 0x13,\n\t\t.msg = \"rocee qmm ovf: cqc ba0 err\"\n\t}, {\n\t\t.int_msk = 0x14,\n\t\t.msg = \"rocee qmm ovf: srqc invalid err\"\n\t}, {\n\t\t.int_msk = 0x15,\n\t\t.msg = \"rocee qmm ovf: srqc ovf err\"\n\t}, {\n\t\t.int_msk = 0x16,\n\t\t.msg = \"rocee qmm ovf: srqc hopnum err\"\n\t}, {\n\t\t.int_msk = 0x17,\n\t\t.msg = \"rocee qmm ovf: srqc ba0 err\"\n\t}, {\n\t\t.int_msk = 0x18,\n\t\t.msg = \"rocee qmm ovf: mpt invalid err\"\n\t}, {\n\t\t.int_msk = 0x19,\n\t\t.msg = \"rocee qmm ovf: mpt ovf err\"\n\t}, {\n\t\t.int_msk = 0x1A,\n\t\t.msg = \"rocee qmm ovf: mpt hopnum err\"\n\t}, {\n\t\t.int_msk = 0x1B,\n\t\t.msg = \"rocee qmm ovf: mpt ba0 err\"\n\t}, {\n\t\t.int_msk = 0x1C,\n\t\t.msg = \"rocee qmm ovf: qpc invalid err\"\n\t}, {\n\t\t.int_msk = 0x1D,\n\t\t.msg = \"rocee qmm ovf: qpc ovf err\"\n\t}, {\n\t\t.int_msk = 0x1E,\n\t\t.msg = \"rocee qmm ovf: qpc hopnum err\"\n\t}, {\n\t\t.int_msk = 0x1F,\n\t\t.msg = \"rocee qmm ovf: qpc ba0 err\"\n\t}, {\n\t\t \n\t}\n};\n\nstatic const struct hclge_hw_module_id hclge_hw_module_id_st[] = {\n\t{\n\t\t.module_id = MODULE_NONE,\n\t\t.msg = \"MODULE_NONE\"\n\t}, {\n\t\t.module_id = MODULE_BIOS_COMMON,\n\t\t.msg = \"MODULE_BIOS_COMMON\"\n\t}, {\n\t\t.module_id = MODULE_GE,\n\t\t.msg = \"MODULE_GE\"\n\t}, {\n\t\t.module_id = MODULE_IGU_EGU,\n\t\t.msg = \"MODULE_IGU_EGU\"\n\t}, {\n\t\t.module_id = MODULE_LGE,\n\t\t.msg = \"MODULE_LGE\"\n\t}, {\n\t\t.module_id = MODULE_NCSI,\n\t\t.msg = \"MODULE_NCSI\"\n\t}, {\n\t\t.module_id = MODULE_PPP,\n\t\t.msg = \"MODULE_PPP\"\n\t}, {\n\t\t.module_id = MODULE_QCN,\n\t\t.msg = \"MODULE_QCN\"\n\t}, {\n\t\t.module_id = MODULE_RCB_RX,\n\t\t.msg = \"MODULE_RCB_RX\"\n\t}, {\n\t\t.module_id = MODULE_RTC,\n\t\t.msg = \"MODULE_RTC\"\n\t}, {\n\t\t.module_id = MODULE_SSU,\n\t\t.msg = \"MODULE_SSU\"\n\t}, {\n\t\t.module_id = MODULE_TM,\n\t\t.msg = \"MODULE_TM\"\n\t}, {\n\t\t.module_id = MODULE_RCB_TX,\n\t\t.msg = \"MODULE_RCB_TX\"\n\t}, {\n\t\t.module_id = MODULE_TXDMA,\n\t\t.msg = \"MODULE_TXDMA\"\n\t}, {\n\t\t.module_id = MODULE_MASTER,\n\t\t.msg = \"MODULE_MASTER\"\n\t}, {\n\t\t.module_id = MODULE_HIMAC,\n\t\t.msg = \"MODULE_HIMAC\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_TOP,\n\t\t.msg = \"MODULE_ROCEE_TOP\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_TIMER,\n\t\t.msg = \"MODULE_ROCEE_TIMER\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_MDB,\n\t\t.msg = \"MODULE_ROCEE_MDB\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_TSP,\n\t\t.msg = \"MODULE_ROCEE_TSP\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_TRP,\n\t\t.msg = \"MODULE_ROCEE_TRP\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_SCC,\n\t\t.msg = \"MODULE_ROCEE_SCC\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_CAEP,\n\t\t.msg = \"MODULE_ROCEE_CAEP\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_GEN_AC,\n\t\t.msg = \"MODULE_ROCEE_GEN_AC\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_QMM,\n\t\t.msg = \"MODULE_ROCEE_QMM\"\n\t}, {\n\t\t.module_id = MODULE_ROCEE_LSAN,\n\t\t.msg = \"MODULE_ROCEE_LSAN\"\n\t}\n};\n\nstatic const struct hclge_hw_type_id hclge_hw_type_id_st[] = {\n\t{\n\t\t.type_id = NONE_ERROR,\n\t\t.msg = \"none_error\"\n\t}, {\n\t\t.type_id = FIFO_ERROR,\n\t\t.msg = \"fifo_error\"\n\t}, {\n\t\t.type_id = MEMORY_ERROR,\n\t\t.msg = \"memory_error\"\n\t}, {\n\t\t.type_id = POISON_ERROR,\n\t\t.msg = \"poison_error\"\n\t}, {\n\t\t.type_id = MSIX_ECC_ERROR,\n\t\t.msg = \"msix_ecc_error\"\n\t}, {\n\t\t.type_id = TQP_INT_ECC_ERROR,\n\t\t.msg = \"tqp_int_ecc_error\"\n\t}, {\n\t\t.type_id = PF_ABNORMAL_INT_ERROR,\n\t\t.msg = \"pf_abnormal_int_error\"\n\t}, {\n\t\t.type_id = MPF_ABNORMAL_INT_ERROR,\n\t\t.msg = \"mpf_abnormal_int_error\"\n\t}, {\n\t\t.type_id = COMMON_ERROR,\n\t\t.msg = \"common_error\"\n\t}, {\n\t\t.type_id = PORT_ERROR,\n\t\t.msg = \"port_error\"\n\t}, {\n\t\t.type_id = ETS_ERROR,\n\t\t.msg = \"ets_error\"\n\t}, {\n\t\t.type_id = NCSI_ERROR,\n\t\t.msg = \"ncsi_error\"\n\t}, {\n\t\t.type_id = GLB_ERROR,\n\t\t.msg = \"glb_error\"\n\t}, {\n\t\t.type_id = LINK_ERROR,\n\t\t.msg = \"link_error\"\n\t}, {\n\t\t.type_id = PTP_ERROR,\n\t\t.msg = \"ptp_error\"\n\t}, {\n\t\t.type_id = ROCEE_NORMAL_ERR,\n\t\t.msg = \"rocee_normal_error\"\n\t}, {\n\t\t.type_id = ROCEE_OVF_ERR,\n\t\t.msg = \"rocee_ovf_error\"\n\t}, {\n\t\t.type_id = ROCEE_BUS_ERR,\n\t\t.msg = \"rocee_bus_error\"\n\t},\n};\n\nstatic void hclge_log_error(struct device *dev, char *reg,\n\t\t\t    const struct hclge_hw_error *err,\n\t\t\t    u32 err_sts, unsigned long *reset_requests)\n{\n\twhile (err->msg) {\n\t\tif (err->int_msk & err_sts) {\n\t\t\tdev_err(dev, \"%s %s found [error status=0x%x]\\n\",\n\t\t\t\treg, err->msg, err_sts);\n\t\t\tif (err->reset_level &&\n\t\t\t    err->reset_level != HNAE3_NONE_RESET)\n\t\t\t\tset_bit(err->reset_level, reset_requests);\n\t\t}\n\t\terr++;\n\t}\n}\n\n \nstatic int hclge_cmd_query_error(struct hclge_dev *hdev,\n\t\t\t\t struct hclge_desc *desc, u32 cmd, u16 flag)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tint desc_num = 1;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0], cmd, true);\n\tif (flag) {\n\t\tdesc[0].flag |= cpu_to_le16(flag);\n\t\thclge_cmd_setup_basic_desc(&desc[1], cmd, true);\n\t\tdesc_num = 2;\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], desc_num);\n\tif (ret)\n\t\tdev_err(dev, \"query error cmd failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_clear_mac_tnl_int(struct hclge_dev *hdev)\n{\n\tstruct hclge_desc desc;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CLEAR_MAC_TNL_INT, false);\n\tdesc.data[0] = cpu_to_le32(HCLGE_MAC_TNL_INT_CLR);\n\n\treturn hclge_cmd_send(&hdev->hw, &desc, 1);\n}\n\nstatic int hclge_config_common_hw_err_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[2];\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_COMMON_ECC_INT_CFG, false);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_COMMON_ECC_INT_CFG, false);\n\n\tif (en) {\n\t\tdesc[0].data[0] = cpu_to_le32(HCLGE_IMP_TCM_ECC_ERR_INT_EN);\n\t\tdesc[0].data[2] = cpu_to_le32(HCLGE_CMDQ_NIC_ECC_ERR_INT_EN |\n\t\t\t\t\tHCLGE_CMDQ_ROCEE_ECC_ERR_INT_EN);\n\t\tdesc[0].data[3] = cpu_to_le32(HCLGE_IMP_RD_POISON_ERR_INT_EN);\n\t\tdesc[0].data[4] = cpu_to_le32(HCLGE_TQP_ECC_ERR_INT_EN |\n\t\t\t\t\t      HCLGE_MSIX_SRAM_ECC_ERR_INT_EN);\n\t\tdesc[0].data[5] = cpu_to_le32(HCLGE_IMP_ITCM4_ECC_ERR_INT_EN);\n\t}\n\n\tdesc[1].data[0] = cpu_to_le32(HCLGE_IMP_TCM_ECC_ERR_INT_EN_MASK);\n\tdesc[1].data[2] = cpu_to_le32(HCLGE_CMDQ_NIC_ECC_ERR_INT_EN_MASK |\n\t\t\t\tHCLGE_CMDQ_ROCEE_ECC_ERR_INT_EN_MASK);\n\tdesc[1].data[3] = cpu_to_le32(HCLGE_IMP_RD_POISON_ERR_INT_EN_MASK);\n\tdesc[1].data[4] = cpu_to_le32(HCLGE_TQP_ECC_ERR_INT_EN_MASK |\n\t\t\t\t      HCLGE_MSIX_SRAM_ECC_ERR_INT_EN_MASK);\n\tdesc[1].data[5] = cpu_to_le32(HCLGE_IMP_ITCM4_ECC_ERR_INT_EN_MASK);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], 2);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure common err interrupts\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_config_ncsi_hw_err_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\treturn 0;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_NCSI_INT_EN, false);\n\tif (en)\n\t\tdesc.data[0] = cpu_to_le32(HCLGE_NCSI_ERR_INT_EN);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure  NCSI error interrupts\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_config_igu_egu_hw_err_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_IGU_COMMON_INT_EN, false);\n\tdesc.data[0] = cpu_to_le32(HCLGE_IGU_ERR_INT_TYPE);\n\tif (en)\n\t\tdesc.data[0] |= cpu_to_le32(HCLGE_IGU_ERR_INT_EN);\n\n\tdesc.data[1] = cpu_to_le32(HCLGE_IGU_ERR_INT_EN_MASK);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure IGU common interrupts\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_IGU_EGU_TNL_INT_EN, false);\n\tif (en)\n\t\tdesc.data[0] = cpu_to_le32(HCLGE_IGU_TNL_ERR_INT_EN);\n\n\tdesc.data[1] = cpu_to_le32(HCLGE_IGU_TNL_ERR_INT_EN_MASK);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure IGU-EGU TNL interrupts\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_config_ncsi_hw_err_int(hdev, en);\n\n\treturn ret;\n}\n\nstatic int hclge_config_ppp_error_interrupt(struct hclge_dev *hdev, u32 cmd,\n\t\t\t\t\t    bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[2];\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], cmd, false);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], cmd, false);\n\n\tif (cmd == HCLGE_PPP_CMD0_INT_CMD) {\n\t\tif (en) {\n\t\t\tdesc[0].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT0_EN);\n\t\t\tdesc[0].data[1] =\n\t\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT1_EN);\n\t\t\tdesc[0].data[4] = cpu_to_le32(HCLGE_PPP_PF_ERR_INT_EN);\n\t\t}\n\n\t\tdesc[1].data[0] =\n\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT0_EN_MASK);\n\t\tdesc[1].data[1] =\n\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT1_EN_MASK);\n\t\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2)\n\t\t\tdesc[1].data[2] =\n\t\t\t\tcpu_to_le32(HCLGE_PPP_PF_ERR_INT_EN_MASK);\n\t} else if (cmd == HCLGE_PPP_CMD1_INT_CMD) {\n\t\tif (en) {\n\t\t\tdesc[0].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT2_EN);\n\t\t\tdesc[0].data[1] =\n\t\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT3_EN);\n\t\t}\n\n\t\tdesc[1].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT2_EN_MASK);\n\t\tdesc[1].data[1] =\n\t\t\t\tcpu_to_le32(HCLGE_PPP_MPF_ECC_ERR_INT3_EN_MASK);\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], 2);\n\tif (ret)\n\t\tdev_err(dev, \"fail(%d) to configure PPP error intr\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_config_ppp_hw_err_int(struct hclge_dev *hdev, bool en)\n{\n\tint ret;\n\n\tret = hclge_config_ppp_error_interrupt(hdev, HCLGE_PPP_CMD0_INT_CMD,\n\t\t\t\t\t       en);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_config_ppp_error_interrupt(hdev, HCLGE_PPP_CMD1_INT_CMD,\n\t\t\t\t\t       en);\n\n\treturn ret;\n}\n\nstatic int hclge_config_tm_hw_err_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_TM_SCH_ECC_INT_EN, false);\n\tif (en)\n\t\tdesc.data[0] = cpu_to_le32(HCLGE_TM_SCH_ECC_ERR_INT_EN);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"fail(%d) to configure TM SCH errors\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_TM_QCN_MEM_INT_CFG, false);\n\tdesc.data[0] = cpu_to_le32(HCLGE_TM_QCN_ERR_INT_TYPE);\n\tif (en) {\n\t\tdesc.data[0] |= cpu_to_le32(HCLGE_TM_QCN_FIFO_INT_EN);\n\t\tdesc.data[1] = cpu_to_le32(HCLGE_TM_QCN_MEM_ERR_INT_EN);\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure TM QCN mem errors\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_config_mac_err_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_MAC_COMMON_INT_EN, false);\n\tif (en)\n\t\tdesc.data[0] = cpu_to_le32(HCLGE_MAC_COMMON_ERR_INT_EN);\n\n\tdesc.data[1] = cpu_to_le32(HCLGE_MAC_COMMON_ERR_INT_EN_MASK);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure MAC COMMON error intr\\n\", ret);\n\n\treturn ret;\n}\n\nint hclge_config_mac_tnl_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct hclge_desc desc;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_TNL_INT_EN, false);\n\tif (en)\n\t\tdesc.data[0] = cpu_to_le32(HCLGE_MAC_TNL_INT_EN);\n\telse\n\t\tdesc.data[0] = 0;\n\n\tdesc.data[1] = cpu_to_le32(HCLGE_MAC_TNL_INT_EN_MASK);\n\n\treturn hclge_cmd_send(&hdev->hw, &desc, 1);\n}\n\nstatic int hclge_config_ppu_error_interrupts(struct hclge_dev *hdev, u32 cmd,\n\t\t\t\t\t     bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[2];\n\tint desc_num = 1;\n\tint ret;\n\n\t \n\tif (cmd == HCLGE_PPU_MPF_ECC_INT_CMD) {\n\t\thclge_cmd_setup_basic_desc(&desc[0], cmd, false);\n\t\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\thclge_cmd_setup_basic_desc(&desc[1], cmd, false);\n\t\tif (en) {\n\t\t\tdesc[0].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT0_EN);\n\t\t\tdesc[0].data[1] =\n\t\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT1_EN);\n\t\t\tdesc[1].data[3] =\n\t\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT3_EN);\n\t\t\tdesc[1].data[4] =\n\t\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT2_EN);\n\t\t}\n\n\t\tdesc[1].data[0] =\n\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT0_EN_MASK);\n\t\tdesc[1].data[1] =\n\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT1_EN_MASK);\n\t\tdesc[1].data[2] =\n\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT2_EN_MASK);\n\t\tdesc[1].data[3] |=\n\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT3_EN_MASK);\n\t\tdesc_num = 2;\n\t} else if (cmd == HCLGE_PPU_MPF_OTHER_INT_CMD) {\n\t\thclge_cmd_setup_basic_desc(&desc[0], cmd, false);\n\t\tif (en)\n\t\t\tdesc[0].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT2_EN2);\n\n\t\tdesc[0].data[2] =\n\t\t\tcpu_to_le32(HCLGE_PPU_MPF_ABNORMAL_INT2_EN2_MASK);\n\t} else if (cmd == HCLGE_PPU_PF_OTHER_INT_CMD) {\n\t\thclge_cmd_setup_basic_desc(&desc[0], cmd, false);\n\t\tif (en)\n\t\t\tdesc[0].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_PPU_PF_ABNORMAL_INT_EN);\n\n\t\tdesc[0].data[2] =\n\t\t\tcpu_to_le32(HCLGE_PPU_PF_ABNORMAL_INT_EN_MASK);\n\t} else {\n\t\tdev_err(dev, \"Invalid cmd to configure PPU error interrupts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], desc_num);\n\n\treturn ret;\n}\n\nstatic int hclge_config_ppu_hw_err_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tint ret;\n\n\tret = hclge_config_ppu_error_interrupts(hdev, HCLGE_PPU_MPF_ECC_INT_CMD,\n\t\t\t\t\t\ten);\n\tif (ret) {\n\t\tdev_err(dev, \"fail(%d) to configure PPU MPF ECC error intr\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_config_ppu_error_interrupts(hdev,\n\t\t\t\t\t\tHCLGE_PPU_MPF_OTHER_INT_CMD,\n\t\t\t\t\t\ten);\n\tif (ret) {\n\t\tdev_err(dev, \"fail(%d) to configure PPU MPF other intr\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_config_ppu_error_interrupts(hdev,\n\t\t\t\t\t\tHCLGE_PPU_PF_OTHER_INT_CMD, en);\n\tif (ret)\n\t\tdev_err(dev, \"fail(%d) to configure PPU PF error interrupts\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_config_ssu_hw_err_int(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[2];\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_SSU_ECC_INT_CMD, false);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_SSU_ECC_INT_CMD, false);\n\tif (en) {\n\t\tdesc[0].data[0] = cpu_to_le32(HCLGE_SSU_1BIT_ECC_ERR_INT_EN);\n\t\tdesc[0].data[1] =\n\t\t\tcpu_to_le32(HCLGE_SSU_MULTI_BIT_ECC_ERR_INT_EN);\n\t\tdesc[0].data[4] = cpu_to_le32(HCLGE_SSU_BIT32_ECC_ERR_INT_EN);\n\t}\n\n\tdesc[1].data[0] = cpu_to_le32(HCLGE_SSU_1BIT_ECC_ERR_INT_EN_MASK);\n\tdesc[1].data[1] = cpu_to_le32(HCLGE_SSU_MULTI_BIT_ECC_ERR_INT_EN_MASK);\n\tdesc[1].data[2] = cpu_to_le32(HCLGE_SSU_BIT32_ECC_ERR_INT_EN_MASK);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], 2);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure SSU ECC error interrupt\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_SSU_COMMON_INT_CMD, false);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_SSU_COMMON_INT_CMD, false);\n\n\tif (en) {\n\t\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2)\n\t\t\tdesc[0].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_SSU_COMMON_INT_EN);\n\t\telse\n\t\t\tdesc[0].data[0] =\n\t\t\t\tcpu_to_le32(HCLGE_SSU_COMMON_INT_EN & ~BIT(5));\n\t\tdesc[0].data[1] = cpu_to_le32(HCLGE_SSU_PORT_BASED_ERR_INT_EN);\n\t\tdesc[0].data[2] =\n\t\t\tcpu_to_le32(HCLGE_SSU_FIFO_OVERFLOW_ERR_INT_EN);\n\t}\n\n\tdesc[1].data[0] = cpu_to_le32(HCLGE_SSU_COMMON_INT_EN_MASK |\n\t\t\t\tHCLGE_SSU_PORT_BASED_ERR_INT_EN_MASK);\n\tdesc[1].data[1] = cpu_to_le32(HCLGE_SSU_FIFO_OVERFLOW_ERR_INT_EN_MASK);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], 2);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"fail(%d) to configure SSU COMMON error intr\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int hclge_query_bd_num(struct hclge_dev *hdev, bool is_ras,\n\t\t\t      u32 *mpf_bd_num, u32 *pf_bd_num)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tu32 mpf_min_bd_num, pf_min_bd_num;\n\tenum hclge_opcode_type opcode;\n\tstruct hclge_desc desc_bd;\n\tint ret;\n\n\tif (is_ras) {\n\t\topcode = HCLGE_QUERY_RAS_INT_STS_BD_NUM;\n\t\tmpf_min_bd_num = HCLGE_MPF_RAS_INT_MIN_BD_NUM;\n\t\tpf_min_bd_num = HCLGE_PF_RAS_INT_MIN_BD_NUM;\n\t} else {\n\t\topcode = HCLGE_QUERY_MSIX_INT_STS_BD_NUM;\n\t\tmpf_min_bd_num = HCLGE_MPF_MSIX_INT_MIN_BD_NUM;\n\t\tpf_min_bd_num = HCLGE_PF_MSIX_INT_MIN_BD_NUM;\n\t}\n\n\thclge_cmd_setup_basic_desc(&desc_bd, opcode, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc_bd, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"fail(%d) to query msix int status bd num\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*mpf_bd_num = le32_to_cpu(desc_bd.data[0]);\n\t*pf_bd_num = le32_to_cpu(desc_bd.data[1]);\n\tif (*mpf_bd_num < mpf_min_bd_num || *pf_bd_num < pf_min_bd_num) {\n\t\tdev_err(dev, \"Invalid bd num: mpf(%u), pf(%u)\\n\",\n\t\t\t*mpf_bd_num, *pf_bd_num);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hclge_handle_mpf_ras_error(struct hclge_dev *hdev,\n\t\t\t\t      struct hclge_desc *desc,\n\t\t\t\t      int num)\n{\n\tstruct hnae3_ae_dev *ae_dev = hdev->ae_dev;\n\tstruct device *dev = &hdev->pdev->dev;\n\t__le32 *desc_data;\n\tu32 status;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_QUERY_CLEAR_MPF_RAS_INT,\n\t\t\t\t   true);\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], num);\n\tif (ret) {\n\t\tdev_err(dev, \"query all mpf ras int cmd failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tstatus = le32_to_cpu(desc[0].data[0]);\n\tif (status)\n\t\thclge_log_error(dev, \"IMP_TCM_ECC_INT_STS\",\n\t\t\t\t&hclge_imp_tcm_ecc_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(desc[0].data[1]);\n\tif (status)\n\t\thclge_log_error(dev, \"CMDQ_MEM_ECC_INT_STS\",\n\t\t\t\t&hclge_cmdq_nic_mem_ecc_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tif ((le32_to_cpu(desc[0].data[2])) & BIT(0))\n\t\tdev_warn(dev, \"imp_rd_data_poison_err found\\n\");\n\n\tstatus = le32_to_cpu(desc[0].data[3]);\n\tif (status)\n\t\thclge_log_error(dev, \"TQP_INT_ECC_INT_STS\",\n\t\t\t\t&hclge_tqp_int_ecc_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(desc[0].data[4]);\n\tif (status)\n\t\thclge_log_error(dev, \"MSIX_ECC_INT_STS\",\n\t\t\t\t&hclge_msix_sram_ecc_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[2];\n\tstatus = le32_to_cpu(*(desc_data + 2));\n\tif (status)\n\t\thclge_log_error(dev, \"SSU_ECC_MULTI_BIT_INT_0\",\n\t\t\t\t&hclge_ssu_mem_ecc_err_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(*(desc_data + 3)) & BIT(0);\n\tif (status) {\n\t\tdev_err(dev, \"SSU_ECC_MULTI_BIT_INT_1 ssu_mem32_ecc_mbit_err found [error status=0x%x]\\n\",\n\t\t\tstatus);\n\t\tset_bit(HNAE3_GLOBAL_RESET, &ae_dev->hw_err_reset_req);\n\t}\n\n\tstatus = le32_to_cpu(*(desc_data + 4)) & HCLGE_SSU_COMMON_ERR_INT_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"SSU_COMMON_ERR_INT\",\n\t\t\t\t&hclge_ssu_com_err_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[3];\n\tstatus = le32_to_cpu(*desc_data) & HCLGE_IGU_INT_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"IGU_INT_STS\",\n\t\t\t\t&hclge_igu_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[4];\n\tstatus = le32_to_cpu(*(desc_data + 1));\n\tif (status)\n\t\thclge_log_error(dev, \"PPP_MPF_ABNORMAL_INT_ST1\",\n\t\t\t\t&hclge_ppp_mpf_abnormal_int_st1[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(*(desc_data + 3)) & HCLGE_PPP_MPF_INT_ST3_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"PPP_MPF_ABNORMAL_INT_ST3\",\n\t\t\t\t&hclge_ppp_mpf_abnormal_int_st3[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[5];\n\tstatus = le32_to_cpu(*(desc_data + 1));\n\tif (status) {\n\t\tdev_err(dev,\n\t\t\t\"PPU_MPF_ABNORMAL_INT_ST1 rpu_rx_pkt_ecc_mbit_err found\\n\");\n\t\tset_bit(HNAE3_GLOBAL_RESET, &ae_dev->hw_err_reset_req);\n\t}\n\n\tstatus = le32_to_cpu(*(desc_data + 2));\n\tif (status)\n\t\thclge_log_error(dev, \"PPU_MPF_ABNORMAL_INT_ST2\",\n\t\t\t\t&hclge_ppu_mpf_abnormal_int_st2[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(*(desc_data + 3)) & HCLGE_PPU_MPF_INT_ST3_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"PPU_MPF_ABNORMAL_INT_ST3\",\n\t\t\t\t&hclge_ppu_mpf_abnormal_int_st3[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[6];\n\tstatus = le32_to_cpu(*desc_data);\n\tif (status)\n\t\thclge_log_error(dev, \"TM_SCH_RINT\",\n\t\t\t\t&hclge_tm_sch_rint[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[7];\n\tstatus = le32_to_cpu(*desc_data) & HCLGE_QCN_FIFO_INT_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"QCN_FIFO_RINT\",\n\t\t\t\t&hclge_qcn_fifo_rint[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(*(desc_data + 1)) & HCLGE_QCN_ECC_INT_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"QCN_ECC_RINT\",\n\t\t\t\t&hclge_qcn_ecc_rint[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[9];\n\tstatus = le32_to_cpu(*desc_data) & HCLGE_NCSI_ECC_INT_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"NCSI_ECC_INT_RPT\",\n\t\t\t\t&hclge_ncsi_err_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\thclge_comm_cmd_reuse_desc(&desc[0], false);\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], num);\n\tif (ret)\n\t\tdev_err(dev, \"clear all mpf ras int cmd failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int hclge_handle_pf_ras_error(struct hclge_dev *hdev,\n\t\t\t\t     struct hclge_desc *desc,\n\t\t\t\t     int num)\n{\n\tstruct hnae3_ae_dev *ae_dev = hdev->ae_dev;\n\tstruct device *dev = &hdev->pdev->dev;\n\t__le32 *desc_data;\n\tu32 status;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_QUERY_CLEAR_PF_RAS_INT,\n\t\t\t\t   true);\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], num);\n\tif (ret) {\n\t\tdev_err(dev, \"query all pf ras int cmd failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tstatus = le32_to_cpu(desc[0].data[0]);\n\tif (status)\n\t\thclge_log_error(dev, \"SSU_PORT_BASED_ERR_INT\",\n\t\t\t\t&hclge_ssu_port_based_err_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(desc[0].data[1]);\n\tif (status)\n\t\thclge_log_error(dev, \"SSU_FIFO_OVERFLOW_INT\",\n\t\t\t\t&hclge_ssu_fifo_overflow_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\tstatus = le32_to_cpu(desc[0].data[2]);\n\tif (status)\n\t\thclge_log_error(dev, \"SSU_ETS_TCG_INT\",\n\t\t\t\t&hclge_ssu_ets_tcg_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[1];\n\tstatus = le32_to_cpu(*desc_data) & HCLGE_IGU_EGU_TNL_INT_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"IGU_EGU_TNL_INT_STS\",\n\t\t\t\t&hclge_igu_egu_tnl_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\n\t \n\tdesc_data = (__le32 *)&desc[3];\n\tstatus = le32_to_cpu(*desc_data) & HCLGE_PPU_PF_INT_RAS_MASK;\n\tif (status) {\n\t\thclge_log_error(dev, \"PPU_PF_ABNORMAL_INT_ST0\",\n\t\t\t\t&hclge_ppu_pf_abnormal_int[0], status,\n\t\t\t\t&ae_dev->hw_err_reset_req);\n\t\thclge_report_hw_error(hdev, HNAE3_PPU_POISON_ERROR);\n\t}\n\n\t \n\thclge_comm_cmd_reuse_desc(&desc[0], false);\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], num);\n\tif (ret)\n\t\tdev_err(dev, \"clear all pf ras int cmd failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_handle_all_ras_errors(struct hclge_dev *hdev)\n{\n\tu32 mpf_bd_num, pf_bd_num, bd_num;\n\tstruct hclge_desc *desc;\n\tint ret;\n\n\t \n\tret = hclge_query_bd_num(hdev, true, &mpf_bd_num, &pf_bd_num);\n\tif (ret)\n\t\treturn ret;\n\n\tbd_num = max_t(u32, mpf_bd_num, pf_bd_num);\n\tdesc = kcalloc(bd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t \n\tret = hclge_handle_mpf_ras_error(hdev, desc, mpf_bd_num);\n\tif (ret) {\n\t\tkfree(desc);\n\t\treturn ret;\n\t}\n\tmemset(desc, 0, bd_num * sizeof(struct hclge_desc));\n\n\t \n\tret = hclge_handle_pf_ras_error(hdev, desc, pf_bd_num);\n\tkfree(desc);\n\n\treturn ret;\n}\n\nstatic int hclge_log_rocee_axi_error(struct hclge_dev *hdev)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[3];\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_QUERY_ROCEE_AXI_RAS_INFO_CMD,\n\t\t\t\t   true);\n\thclge_cmd_setup_basic_desc(&desc[1], HCLGE_QUERY_ROCEE_AXI_RAS_INFO_CMD,\n\t\t\t\t   true);\n\thclge_cmd_setup_basic_desc(&desc[2], HCLGE_QUERY_ROCEE_AXI_RAS_INFO_CMD,\n\t\t\t\t   true);\n\tdesc[0].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\tdesc[1].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], 3);\n\tif (ret) {\n\t\tdev_err(dev, \"failed(%d) to query ROCEE AXI error sts\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_err(dev, \"AXI1: %08X %08X %08X %08X %08X %08X\\n\",\n\t\tle32_to_cpu(desc[0].data[0]), le32_to_cpu(desc[0].data[1]),\n\t\tle32_to_cpu(desc[0].data[2]), le32_to_cpu(desc[0].data[3]),\n\t\tle32_to_cpu(desc[0].data[4]), le32_to_cpu(desc[0].data[5]));\n\tdev_err(dev, \"AXI2: %08X %08X %08X %08X %08X %08X\\n\",\n\t\tle32_to_cpu(desc[1].data[0]), le32_to_cpu(desc[1].data[1]),\n\t\tle32_to_cpu(desc[1].data[2]), le32_to_cpu(desc[1].data[3]),\n\t\tle32_to_cpu(desc[1].data[4]), le32_to_cpu(desc[1].data[5]));\n\tdev_err(dev, \"AXI3: %08X %08X %08X %08X\\n\",\n\t\tle32_to_cpu(desc[2].data[0]), le32_to_cpu(desc[2].data[1]),\n\t\tle32_to_cpu(desc[2].data[2]), le32_to_cpu(desc[2].data[3]));\n\n\treturn 0;\n}\n\nstatic int hclge_log_rocee_ecc_error(struct hclge_dev *hdev)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[2];\n\tint ret;\n\n\tret = hclge_cmd_query_error(hdev, &desc[0],\n\t\t\t\t    HCLGE_QUERY_ROCEE_ECC_RAS_INFO_CMD,\n\t\t\t\t    HCLGE_COMM_CMD_FLAG_NEXT);\n\tif (ret) {\n\t\tdev_err(dev, \"failed(%d) to query ROCEE ECC error sts\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_err(dev, \"ECC1: %08X %08X %08X %08X %08X %08X\\n\",\n\t\tle32_to_cpu(desc[0].data[0]), le32_to_cpu(desc[0].data[1]),\n\t\tle32_to_cpu(desc[0].data[2]), le32_to_cpu(desc[0].data[3]),\n\t\tle32_to_cpu(desc[0].data[4]), le32_to_cpu(desc[0].data[5]));\n\tdev_err(dev, \"ECC2: %08X %08X %08X\\n\", le32_to_cpu(desc[1].data[0]),\n\t\tle32_to_cpu(desc[1].data[1]), le32_to_cpu(desc[1].data[2]));\n\n\treturn 0;\n}\n\nstatic int hclge_log_rocee_ovf_error(struct hclge_dev *hdev)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[2];\n\tint ret;\n\n\t \n\tret = hclge_cmd_query_error(hdev, &desc[0], HCLGE_ROCEE_PF_RAS_INT_CMD,\n\t\t\t\t    0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed(%d) to query ROCEE OVF error sts\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (le32_to_cpu(desc[0].data[0]) & HCLGE_ROCEE_OVF_ERR_INT_MASK) {\n\t\tconst struct hclge_hw_error *err;\n\t\tu32 err_sts;\n\n\t\terr = &hclge_rocee_qmm_ovf_err_int[0];\n\t\terr_sts = HCLGE_ROCEE_OVF_ERR_TYPE_MASK &\n\t\t\t  le32_to_cpu(desc[0].data[0]);\n\t\twhile (err->msg) {\n\t\t\tif (err->int_msk == err_sts) {\n\t\t\t\tdev_err(dev, \"%s [error status=0x%x] found\\n\",\n\t\t\t\t\terr->msg,\n\t\t\t\t\tle32_to_cpu(desc[0].data[0]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr++;\n\t\t}\n\t}\n\n\tif (le32_to_cpu(desc[0].data[1]) & HCLGE_ROCEE_OVF_ERR_INT_MASK) {\n\t\tdev_err(dev, \"ROCEE TSP OVF [error status=0x%x] found\\n\",\n\t\t\tle32_to_cpu(desc[0].data[1]));\n\t}\n\n\tif (le32_to_cpu(desc[0].data[2]) & HCLGE_ROCEE_OVF_ERR_INT_MASK) {\n\t\tdev_err(dev, \"ROCEE SCC OVF [error status=0x%x] found\\n\",\n\t\t\tle32_to_cpu(desc[0].data[2]));\n\t}\n\n\treturn 0;\n}\n\nstatic enum hnae3_reset_type\nhclge_log_and_clear_rocee_ras_error(struct hclge_dev *hdev)\n{\n\tenum hnae3_reset_type reset_type = HNAE3_NONE_RESET;\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc[2];\n\tunsigned int status;\n\tint ret;\n\n\t \n\tret = hclge_cmd_query_error(hdev, &desc[0],\n\t\t\t\t    HCLGE_QUERY_CLEAR_ROCEE_RAS_INT, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed(%d) to query ROCEE RAS INT SRC\\n\", ret);\n\t\t \n\t\treturn HNAE3_GLOBAL_RESET;\n\t}\n\n\tstatus = le32_to_cpu(desc[0].data[0]);\n\tif (status & HCLGE_ROCEE_AXI_ERR_INT_MASK) {\n\t\tif (status & HCLGE_ROCEE_RERR_INT_MASK)\n\t\t\tdev_err(dev, \"ROCEE RAS AXI rresp error\\n\");\n\n\t\tif (status & HCLGE_ROCEE_BERR_INT_MASK)\n\t\t\tdev_err(dev, \"ROCEE RAS AXI bresp error\\n\");\n\n\t\treset_type = HNAE3_FUNC_RESET;\n\n\t\thclge_report_hw_error(hdev, HNAE3_ROCEE_AXI_RESP_ERROR);\n\n\t\tret = hclge_log_rocee_axi_error(hdev);\n\t\tif (ret)\n\t\t\treturn HNAE3_GLOBAL_RESET;\n\t}\n\n\tif (status & HCLGE_ROCEE_ECC_INT_MASK) {\n\t\tdev_err(dev, \"ROCEE RAS 2bit ECC error\\n\");\n\t\treset_type = HNAE3_GLOBAL_RESET;\n\n\t\tret = hclge_log_rocee_ecc_error(hdev);\n\t\tif (ret)\n\t\t\treturn HNAE3_GLOBAL_RESET;\n\t}\n\n\tif (status & HCLGE_ROCEE_OVF_INT_MASK) {\n\t\tret = hclge_log_rocee_ovf_error(hdev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed(%d) to process ovf error\\n\", ret);\n\t\t\t \n\t\t\treturn HNAE3_GLOBAL_RESET;\n\t\t}\n\t}\n\n\t \n\thclge_comm_cmd_reuse_desc(&desc[0], false);\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed(%d) to clear ROCEE RAS error\\n\", ret);\n\t\t \n\t\treturn HNAE3_GLOBAL_RESET;\n\t}\n\n\treturn reset_type;\n}\n\nint hclge_config_rocee_ras_interrupt(struct hclge_dev *hdev, bool en)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tif (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2 ||\n\t    !hnae3_dev_roce_supported(hdev))\n\t\treturn 0;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_CONFIG_ROCEE_RAS_INT_EN, false);\n\tif (en) {\n\t\t \n\t\tdesc.data[0] = cpu_to_le32(HCLGE_ROCEE_RAS_NFE_INT_EN);\n\t\tdesc.data[1] = cpu_to_le32(HCLGE_ROCEE_RAS_CE_INT_EN);\n\n\t\thclge_log_and_clear_rocee_ras_error(hdev);\n\t}\n\tdesc.data[2] = cpu_to_le32(HCLGE_ROCEE_RAS_NFE_INT_EN_MASK);\n\tdesc.data[3] = cpu_to_le32(HCLGE_ROCEE_RAS_CE_INT_EN_MASK);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(dev, \"failed(%d) to config ROCEE RAS interrupt\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void hclge_handle_rocee_ras_error(struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tenum hnae3_reset_type reset_type;\n\n\tif (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state))\n\t\treturn;\n\n\treset_type = hclge_log_and_clear_rocee_ras_error(hdev);\n\tif (reset_type != HNAE3_NONE_RESET)\n\t\tset_bit(reset_type, &ae_dev->hw_err_reset_req);\n}\n\nstatic const struct hclge_hw_blk hw_blk[] = {\n\t{\n\t\t.msk = BIT(0),\n\t\t.name = \"IGU_EGU\",\n\t\t.config_err_int = hclge_config_igu_egu_hw_err_int,\n\t}, {\n\t\t.msk = BIT(1),\n\t\t.name = \"PPP\",\n\t\t.config_err_int = hclge_config_ppp_hw_err_int,\n\t}, {\n\t\t.msk = BIT(2),\n\t\t.name = \"SSU\",\n\t\t.config_err_int = hclge_config_ssu_hw_err_int,\n\t}, {\n\t\t.msk = BIT(3),\n\t\t.name = \"PPU\",\n\t\t.config_err_int = hclge_config_ppu_hw_err_int,\n\t}, {\n\t\t.msk = BIT(4),\n\t\t.name = \"TM\",\n\t\t.config_err_int = hclge_config_tm_hw_err_int,\n\t}, {\n\t\t.msk = BIT(5),\n\t\t.name = \"COMMON\",\n\t\t.config_err_int = hclge_config_common_hw_err_int,\n\t}, {\n\t\t.msk = BIT(8),\n\t\t.name = \"MAC\",\n\t\t.config_err_int = hclge_config_mac_err_int,\n\t}, {\n\t\t \n\t}\n};\n\nstatic void hclge_config_all_msix_error(struct hclge_dev *hdev, bool enable)\n{\n\tu32 reg_val;\n\n\treg_val = hclge_read_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG);\n\n\tif (enable)\n\t\treg_val |= BIT(HCLGE_VECTOR0_ALL_MSIX_ERR_B);\n\telse\n\t\treg_val &= ~BIT(HCLGE_VECTOR0_ALL_MSIX_ERR_B);\n\n\thclge_write_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG, reg_val);\n}\n\nint hclge_config_nic_hw_error(struct hclge_dev *hdev, bool state)\n{\n\tconst struct hclge_hw_blk *module = hw_blk;\n\tint ret = 0;\n\n\thclge_config_all_msix_error(hdev, state);\n\n\twhile (module->name) {\n\t\tif (module->config_err_int) {\n\t\t\tret = module->config_err_int(hdev, state);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tmodule++;\n\t}\n\n\treturn ret;\n}\n\npci_ers_result_t hclge_handle_hw_ras_error(struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct device *dev = &hdev->pdev->dev;\n\tu32 status;\n\n\tif (!test_bit(HCLGE_STATE_SERVICE_INITED, &hdev->state)) {\n\t\tdev_err(dev,\n\t\t\t\"Can't recover - RAS error reported during dev init\\n\");\n\t\treturn PCI_ERS_RESULT_NONE;\n\t}\n\n\tstatus = hclge_read_dev(&hdev->hw, HCLGE_RAS_PF_OTHER_INT_STS_REG);\n\tif (status & HCLGE_RAS_REG_NFE_MASK ||\n\t    status & HCLGE_RAS_REG_ROCEE_ERR_MASK)\n\t\tae_dev->hw_err_reset_req = 0;\n\telse\n\t\tgoto out;\n\n\t \n\tif (status & HCLGE_RAS_REG_NFE_MASK) {\n\t\tdev_err(dev,\n\t\t\t\"HNS Non-Fatal RAS error(status=0x%x) identified\\n\",\n\t\t\tstatus);\n\t\thclge_handle_all_ras_errors(hdev);\n\t}\n\n\t \n\tif (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2 &&\n\t    status & HCLGE_RAS_REG_ROCEE_ERR_MASK) {\n\t\tdev_err(dev, \"ROCEE Non-Fatal RAS error identified\\n\");\n\t\thclge_handle_rocee_ras_error(ae_dev);\n\t}\n\n\tif (ae_dev->hw_err_reset_req)\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\nout:\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic int hclge_clear_hw_msix_error(struct hclge_dev *hdev,\n\t\t\t\t     struct hclge_desc *desc, bool is_mpf,\n\t\t\t\t     u32 bd_num)\n{\n\tif (is_mpf)\n\t\tdesc[0].opcode =\n\t\t\tcpu_to_le16(HCLGE_QUERY_CLEAR_ALL_MPF_MSIX_INT);\n\telse\n\t\tdesc[0].opcode = cpu_to_le16(HCLGE_QUERY_CLEAR_ALL_PF_MSIX_INT);\n\n\tdesc[0].flag = cpu_to_le16(HCLGE_COMM_CMD_FLAG_NO_INTR |\n\t\t\t\t   HCLGE_COMM_CMD_FLAG_IN);\n\n\treturn hclge_cmd_send(&hdev->hw, &desc[0], bd_num);\n}\n\n \nstatic int hclge_query_over_8bd_err_info(struct hclge_dev *hdev, u16 *vf_id,\n\t\t\t\t\t u16 *q_id)\n{\n\tstruct hclge_query_ppu_pf_other_int_dfx_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PPU_PF_OTHER_INT_DFX, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treq = (struct hclge_query_ppu_pf_other_int_dfx_cmd *)desc.data;\n\t*vf_id = le16_to_cpu(req->over_8bd_no_fe_vf_id);\n\t*q_id = le16_to_cpu(req->over_8bd_no_fe_qid);\n\n\treturn 0;\n}\n\n \nstatic void hclge_handle_over_8bd_err(struct hclge_dev *hdev,\n\t\t\t\t      unsigned long *reset_requests)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tu16 vf_id;\n\tu16 q_id;\n\tint ret;\n\n\tret = hclge_query_over_8bd_err_info(hdev, &vf_id, &q_id);\n\tif (ret) {\n\t\tdev_err(dev, \"fail(%d) to query over_8bd_no_fe info\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tdev_err(dev, \"PPU_PF_ABNORMAL_INT_ST over_8bd_no_fe found, vport(%u), queue_id(%u)\\n\",\n\t\tvf_id, q_id);\n\n\tif (vf_id) {\n\t\tif (vf_id >= hdev->num_alloc_vport) {\n\t\t\tdev_err(dev, \"invalid vport(%u)\\n\", vf_id);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (*reset_requests != 0)\n\t\t\treturn;\n\n\t\tret = hclge_inform_reset_assert_to_vf(&hdev->vport[vf_id]);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"inform reset to vport(%u) failed %d!\\n\",\n\t\t\t\tvf_id, ret);\n\t} else {\n\t\tset_bit(HNAE3_FUNC_RESET, reset_requests);\n\t}\n}\n\n \nstatic int hclge_handle_mpf_msix_error(struct hclge_dev *hdev,\n\t\t\t\t       struct hclge_desc *desc,\n\t\t\t\t       int mpf_bd_num,\n\t\t\t\t       unsigned long *reset_requests)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\t__le32 *desc_data;\n\tu32 status;\n\tint ret;\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_QUERY_CLEAR_ALL_MPF_MSIX_INT,\n\t\t\t\t   true);\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], mpf_bd_num);\n\tif (ret) {\n\t\tdev_err(dev, \"query all mpf msix int cmd failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdesc_data = (__le32 *)&desc[1];\n\tstatus = le32_to_cpu(*desc_data);\n\tif (status)\n\t\thclge_log_error(dev, \"MAC_AFIFO_TNL_INT_R\",\n\t\t\t\t&hclge_mac_afifo_tnl_int[0], status,\n\t\t\t\treset_requests);\n\n\t \n\tdesc_data = (__le32 *)&desc[5];\n\tstatus = le32_to_cpu(*(desc_data + 2)) &\n\t\t\tHCLGE_PPU_MPF_INT_ST2_MSIX_MASK;\n\tif (status)\n\t\tdev_err(dev, \"PPU_MPF_ABNORMAL_INT_ST2 rx_q_search_miss found [dfx status=0x%x\\n]\",\n\t\t\tstatus);\n\n\t \n\tret = hclge_clear_hw_msix_error(hdev, desc, true, mpf_bd_num);\n\tif (ret)\n\t\tdev_err(dev, \"clear all mpf msix int cmd failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int hclge_handle_pf_msix_error(struct hclge_dev *hdev,\n\t\t\t\t      struct hclge_desc *desc,\n\t\t\t\t      int pf_bd_num,\n\t\t\t\t      unsigned long *reset_requests)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\t__le32 *desc_data;\n\tu32 status;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_QUERY_CLEAR_ALL_PF_MSIX_INT,\n\t\t\t\t   true);\n\tret = hclge_cmd_send(&hdev->hw, &desc[0], pf_bd_num);\n\tif (ret) {\n\t\tdev_err(dev, \"query all pf msix int cmd failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tstatus = le32_to_cpu(desc[0].data[0]) & HCLGE_SSU_PORT_INT_MSIX_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"SSU_PORT_BASED_ERR_INT\",\n\t\t\t\t&hclge_ssu_port_based_pf_int[0],\n\t\t\t\tstatus, reset_requests);\n\n\t \n\tdesc_data = (__le32 *)&desc[2];\n\tstatus = le32_to_cpu(*desc_data);\n\tif (status)\n\t\thclge_log_error(dev, \"PPP_PF_ABNORMAL_INT_ST0\",\n\t\t\t\t&hclge_ppp_pf_abnormal_int[0],\n\t\t\t\tstatus, reset_requests);\n\n\t \n\tdesc_data = (__le32 *)&desc[3];\n\tstatus = le32_to_cpu(*desc_data) & HCLGE_PPU_PF_INT_MSIX_MASK;\n\tif (status)\n\t\thclge_log_error(dev, \"PPU_PF_ABNORMAL_INT_ST\",\n\t\t\t\t&hclge_ppu_pf_abnormal_int[0],\n\t\t\t\tstatus, reset_requests);\n\n\tstatus = le32_to_cpu(*desc_data) & HCLGE_PPU_PF_OVER_8BD_ERR_MASK;\n\tif (status)\n\t\thclge_handle_over_8bd_err(hdev, reset_requests);\n\n\t \n\tret = hclge_clear_hw_msix_error(hdev, desc, false, pf_bd_num);\n\tif (ret)\n\t\tdev_err(dev, \"clear all pf msix int cmd failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hclge_handle_all_hw_msix_error(struct hclge_dev *hdev,\n\t\t\t\t\t  unsigned long *reset_requests)\n{\n\tu32 mpf_bd_num, pf_bd_num, bd_num;\n\tstruct hclge_desc *desc;\n\tint ret;\n\n\t \n\tret = hclge_query_bd_num(hdev, false, &mpf_bd_num, &pf_bd_num);\n\tif (ret)\n\t\tgoto out;\n\n\tbd_num = max_t(u32, mpf_bd_num, pf_bd_num);\n\tdesc = kcalloc(bd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tret = hclge_handle_mpf_msix_error(hdev, desc, mpf_bd_num,\n\t\t\t\t\t  reset_requests);\n\tif (ret)\n\t\tgoto msi_error;\n\n\tmemset(desc, 0, bd_num * sizeof(struct hclge_desc));\n\tret = hclge_handle_pf_msix_error(hdev, desc, pf_bd_num, reset_requests);\n\tif (ret)\n\t\tgoto msi_error;\n\n\tret = hclge_handle_mac_tnl(hdev);\n\nmsi_error:\n\tkfree(desc);\nout:\n\treturn ret;\n}\n\nint hclge_handle_hw_msix_error(struct hclge_dev *hdev,\n\t\t\t       unsigned long *reset_requests)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\n\tif (!test_bit(HCLGE_STATE_SERVICE_INITED, &hdev->state)) {\n\t\tdev_err(dev,\n\t\t\t\"failed to handle msix error during dev init\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn hclge_handle_all_hw_msix_error(hdev, reset_requests);\n}\n\nint hclge_handle_mac_tnl(struct hclge_dev *hdev)\n{\n\tstruct hclge_mac_tnl_stats mac_tnl_stats;\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc;\n\tu32 status;\n\tint ret;\n\n\t \n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_MAC_TNL_INT, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to query mac tnl int, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tstatus = le32_to_cpu(desc.data[0]);\n\tif (status) {\n\t\t \n\t\tmac_tnl_stats.time = local_clock();\n\t\tmac_tnl_stats.status = status;\n\t\tkfifo_put(&hdev->mac_tnl_log, mac_tnl_stats);\n\t\tret = hclge_clear_mac_tnl_int(hdev);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to clear mac tnl int, ret = %d.\\n\",\n\t\t\t\tret);\n\t}\n\n\treturn ret;\n}\n\nvoid hclge_handle_all_hns_hw_errors(struct hnae3_ae_dev *ae_dev)\n{\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct device *dev = &hdev->pdev->dev;\n\tu32 mpf_bd_num, pf_bd_num, bd_num;\n\tstruct hclge_desc *desc;\n\tu32 status;\n\tint ret;\n\n\tae_dev->hw_err_reset_req = 0;\n\tstatus = hclge_read_dev(&hdev->hw, HCLGE_RAS_PF_OTHER_INT_STS_REG);\n\n\t \n\tret = hclge_query_bd_num(hdev, false, &mpf_bd_num, &pf_bd_num);\n\tif (ret)\n\t\treturn;\n\n\tbd_num = max_t(u32, mpf_bd_num, pf_bd_num);\n\tdesc = kcalloc(bd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn;\n\n\t \n\tmemset(&desc[0].data[0], 0xFF, mpf_bd_num * sizeof(struct hclge_desc) -\n\t       HCLGE_DESC_NO_DATA_LEN);\n\tret = hclge_clear_hw_msix_error(hdev, desc, true, mpf_bd_num);\n\tif (ret) {\n\t\tdev_err(dev, \"fail(%d) to clear mpf msix int during init\\n\",\n\t\t\tret);\n\t\tgoto msi_error;\n\t}\n\n\tmemset(&desc[0].data[0], 0xFF, pf_bd_num * sizeof(struct hclge_desc) -\n\t       HCLGE_DESC_NO_DATA_LEN);\n\tret = hclge_clear_hw_msix_error(hdev, desc, false, pf_bd_num);\n\tif (ret) {\n\t\tdev_err(dev, \"fail(%d) to clear pf msix int during init\\n\",\n\t\t\tret);\n\t\tgoto msi_error;\n\t}\n\n\t \n\tif (status & HCLGE_RAS_REG_NFE_MASK) {\n\t\tdev_err(dev, \"HNS hw error(RAS) identified during init\\n\");\n\t\thclge_handle_all_ras_errors(hdev);\n\t}\n\nmsi_error:\n\tkfree(desc);\n}\n\nbool hclge_find_error_source(struct hclge_dev *hdev)\n{\n\tu32 msix_src_flag, hw_err_src_flag;\n\n\tmsix_src_flag = hclge_read_dev(&hdev->hw, HCLGE_MISC_VECTOR_INT_STS) &\n\t\t\tHCLGE_VECTOR0_REG_MSIX_MASK;\n\n\thw_err_src_flag = hclge_read_dev(&hdev->hw,\n\t\t\t\t\t HCLGE_RAS_PF_OTHER_INT_STS_REG) &\n\t\t\t  HCLGE_RAS_REG_ERR_MASK;\n\n\treturn msix_src_flag || hw_err_src_flag;\n}\n\nvoid hclge_handle_occurred_error(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\n\tif (hclge_find_error_source(hdev))\n\t\thclge_handle_error_info_log(ae_dev);\n}\n\nstatic void\nhclge_handle_error_type_reg_log(struct device *dev,\n\t\t\t\tstruct hclge_mod_err_info *mod_info,\n\t\t\t\tstruct hclge_type_reg_err_info *type_reg_info)\n{\n#define HCLGE_ERR_TYPE_MASK 0x7F\n#define HCLGE_ERR_TYPE_IS_RAS_OFFSET 7\n\n\tu8 mod_id, total_module, type_id, total_type, i, is_ras;\n\tu8 index_module = MODULE_NONE;\n\tu8 index_type = NONE_ERROR;\n\n\tmod_id = mod_info->mod_id;\n\ttype_id = type_reg_info->type_id & HCLGE_ERR_TYPE_MASK;\n\tis_ras = type_reg_info->type_id >> HCLGE_ERR_TYPE_IS_RAS_OFFSET;\n\n\ttotal_module = ARRAY_SIZE(hclge_hw_module_id_st);\n\ttotal_type = ARRAY_SIZE(hclge_hw_type_id_st);\n\n\tfor (i = 0; i < total_module; i++) {\n\t\tif (mod_id == hclge_hw_module_id_st[i].module_id) {\n\t\t\tindex_module = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < total_type; i++) {\n\t\tif (type_id == hclge_hw_type_id_st[i].type_id) {\n\t\t\tindex_type = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index_module != MODULE_NONE && index_type != NONE_ERROR)\n\t\tdev_err(dev,\n\t\t\t\"found %s %s, is %s error.\\n\",\n\t\t\thclge_hw_module_id_st[index_module].msg,\n\t\t\thclge_hw_type_id_st[index_type].msg,\n\t\t\tis_ras ? \"ras\" : \"msix\");\n\telse\n\t\tdev_err(dev,\n\t\t\t\"unknown module[%u] or type[%u].\\n\", mod_id, type_id);\n\n\tdev_err(dev, \"reg_value:\\n\");\n\tfor (i = 0; i < type_reg_info->reg_num; i++)\n\t\tdev_err(dev, \"0x%08x\\n\", type_reg_info->hclge_reg[i]);\n}\n\nstatic void hclge_handle_error_module_log(struct hnae3_ae_dev *ae_dev,\n\t\t\t\t\t  const u32 *buf, u32 buf_size)\n{\n\tstruct hclge_type_reg_err_info *type_reg_info;\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_mod_err_info *mod_info;\n\tstruct hclge_sum_err_info *sum_info;\n\tu8 mod_num, err_num, i;\n\tu32 offset = 0;\n\n\tsum_info = (struct hclge_sum_err_info *)&buf[offset++];\n\tif (sum_info->reset_type &&\n\t    sum_info->reset_type != HNAE3_NONE_RESET)\n\t\tset_bit(sum_info->reset_type, &ae_dev->hw_err_reset_req);\n\tmod_num = sum_info->mod_num;\n\n\twhile (mod_num--) {\n\t\tif (offset >= buf_size) {\n\t\t\tdev_err(dev, \"The offset(%u) exceeds buf's size(%u).\\n\",\n\t\t\t\toffset, buf_size);\n\t\t\treturn;\n\t\t}\n\t\tmod_info = (struct hclge_mod_err_info *)&buf[offset++];\n\t\terr_num = mod_info->err_num;\n\n\t\tfor (i = 0; i < err_num; i++) {\n\t\t\tif (offset >= buf_size) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"The offset(%u) exceeds buf size(%u).\\n\",\n\t\t\t\t\toffset, buf_size);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype_reg_info = (struct hclge_type_reg_err_info *)\n\t\t\t\t\t    &buf[offset++];\n\t\t\thclge_handle_error_type_reg_log(dev, mod_info,\n\t\t\t\t\t\t\ttype_reg_info);\n\n\t\t\toffset += type_reg_info->reg_num;\n\t\t}\n\t}\n}\n\nstatic int hclge_query_all_err_bd_num(struct hclge_dev *hdev, u32 *bd_num)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tstruct hclge_desc desc_bd;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc_bd, HCLGE_QUERY_ALL_ERR_BD_NUM, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc_bd, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to query error bd_num, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*bd_num = le32_to_cpu(desc_bd.data[0]);\n\tif (!(*bd_num)) {\n\t\tdev_err(dev, \"The value of bd_num is 0!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_query_all_err_info(struct hclge_dev *hdev,\n\t\t\t\t    struct hclge_desc *desc, u32 bd_num)\n{\n\tstruct device *dev = &hdev->pdev->dev;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(desc, HCLGE_QUERY_ALL_ERR_INFO, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, bd_num);\n\tif (ret)\n\t\tdev_err(dev, \"failed to query error info, ret = %d.\\n\", ret);\n\n\treturn ret;\n}\n\nint hclge_handle_error_info_log(struct hnae3_ae_dev *ae_dev)\n{\n\tu32 bd_num, desc_len, buf_len, buf_size, i;\n\tstruct hclge_dev *hdev = ae_dev->priv;\n\tstruct hclge_desc *desc;\n\t__le32 *desc_data;\n\tu32 *buf;\n\tint ret;\n\n\tret = hclge_query_all_err_bd_num(hdev, &bd_num);\n\tif (ret)\n\t\tgoto out;\n\n\tdesc_len = bd_num * sizeof(struct hclge_desc);\n\tdesc = kzalloc(desc_len, GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = hclge_query_all_err_info(hdev, desc, bd_num);\n\tif (ret)\n\t\tgoto err_desc;\n\n\tbuf_len = bd_num * sizeof(struct hclge_desc) - HCLGE_DESC_NO_DATA_LEN;\n\tbuf_size = buf_len / sizeof(u32);\n\n\tdesc_data = kzalloc(buf_len, GFP_KERNEL);\n\tif (!desc_data) {\n\t\tret = -ENOMEM;\n\t\tgoto err_desc;\n\t}\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_buf_alloc;\n\t}\n\n\tmemcpy(desc_data, &desc[0].data[0], buf_len);\n\tfor (i = 0; i < buf_size; i++)\n\t\tbuf[i] = le32_to_cpu(desc_data[i]);\n\n\thclge_handle_error_module_log(ae_dev, buf, buf_size);\n\tkfree(buf);\n\nerr_buf_alloc:\n\tkfree(desc_data);\nerr_desc:\n\tkfree(desc);\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}