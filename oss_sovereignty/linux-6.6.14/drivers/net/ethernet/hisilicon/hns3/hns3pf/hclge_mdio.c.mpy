{
  "module_name": "hclge_mdio.c",
  "hash_id": "bf43da7bed54946ea611272665d87cd61f992a7a77a1eb1c242faa8f60e7ff5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c",
  "human_readable_source": "\n\n\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/marvell_phy.h>\n\n#include \"hclge_cmd.h\"\n#include \"hclge_main.h\"\n#include \"hclge_mdio.h\"\n\nenum hclge_mdio_c22_op_seq {\n\tHCLGE_MDIO_C22_WRITE = 1,\n\tHCLGE_MDIO_C22_READ = 2\n};\n\n#define HCLGE_MDIO_CTRL_START_B\t\t0\n#define HCLGE_MDIO_CTRL_ST_S\t\t1\n#define HCLGE_MDIO_CTRL_ST_M\t\t(0x3 << HCLGE_MDIO_CTRL_ST_S)\n#define HCLGE_MDIO_CTRL_OP_S\t\t3\n#define HCLGE_MDIO_CTRL_OP_M\t\t(0x3 << HCLGE_MDIO_CTRL_OP_S)\n\n#define HCLGE_MDIO_PHYID_S\t\t0\n#define HCLGE_MDIO_PHYID_M\t\t(0x1f << HCLGE_MDIO_PHYID_S)\n\n#define HCLGE_MDIO_PHYREG_S\t\t0\n#define HCLGE_MDIO_PHYREG_M\t\t(0x1f << HCLGE_MDIO_PHYREG_S)\n\n#define HCLGE_MDIO_STA_B\t\t0\n\nstruct hclge_mdio_cfg_cmd {\n\tu8 ctrl_bit;\n\tu8 phyid;\n\tu8 phyad;\n\tu8 rsvd;\n\t__le16 reserve;\n\t__le16 data_wr;\n\t__le16 data_rd;\n\t__le16 sta;\n};\n\nstatic int hclge_mdio_write(struct mii_bus *bus, int phyid, int regnum,\n\t\t\t    u16 data)\n{\n\tstruct hclge_mdio_cfg_cmd *mdio_cmd;\n\tstruct hclge_dev *hdev = bus->priv;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tif (test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state))\n\t\treturn -EBUSY;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MDIO_CONFIG, false);\n\n\tmdio_cmd = (struct hclge_mdio_cfg_cmd *)desc.data;\n\n\thnae3_set_field(mdio_cmd->phyid, HCLGE_MDIO_PHYID_M,\n\t\t\tHCLGE_MDIO_PHYID_S, (u32)phyid);\n\thnae3_set_field(mdio_cmd->phyad, HCLGE_MDIO_PHYREG_M,\n\t\t\tHCLGE_MDIO_PHYREG_S, (u32)regnum);\n\n\thnae3_set_bit(mdio_cmd->ctrl_bit, HCLGE_MDIO_CTRL_START_B, 1);\n\thnae3_set_field(mdio_cmd->ctrl_bit, HCLGE_MDIO_CTRL_ST_M,\n\t\t\tHCLGE_MDIO_CTRL_ST_S, 1);\n\thnae3_set_field(mdio_cmd->ctrl_bit, HCLGE_MDIO_CTRL_OP_M,\n\t\t\tHCLGE_MDIO_CTRL_OP_S, HCLGE_MDIO_C22_WRITE);\n\n\tmdio_cmd->data_wr = cpu_to_le16(data);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mdio write fail when sending cmd, status is %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hclge_mdio_read(struct mii_bus *bus, int phyid, int regnum)\n{\n\tstruct hclge_mdio_cfg_cmd *mdio_cmd;\n\tstruct hclge_dev *hdev = bus->priv;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\tif (test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state))\n\t\treturn -EBUSY;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MDIO_CONFIG, true);\n\n\tmdio_cmd = (struct hclge_mdio_cfg_cmd *)desc.data;\n\n\thnae3_set_field(mdio_cmd->phyid, HCLGE_MDIO_PHYID_M,\n\t\t\tHCLGE_MDIO_PHYID_S, (u32)phyid);\n\thnae3_set_field(mdio_cmd->phyad, HCLGE_MDIO_PHYREG_M,\n\t\t\tHCLGE_MDIO_PHYREG_S, (u32)regnum);\n\n\thnae3_set_bit(mdio_cmd->ctrl_bit, HCLGE_MDIO_CTRL_START_B, 1);\n\thnae3_set_field(mdio_cmd->ctrl_bit, HCLGE_MDIO_CTRL_ST_M,\n\t\t\tHCLGE_MDIO_CTRL_ST_S, 1);\n\thnae3_set_field(mdio_cmd->ctrl_bit, HCLGE_MDIO_CTRL_OP_M,\n\t\t\tHCLGE_MDIO_CTRL_OP_S, HCLGE_MDIO_C22_READ);\n\n\t \n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"mdio read fail when get data, status is %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (hnae3_get_bit(le16_to_cpu(mdio_cmd->sta), HCLGE_MDIO_STA_B)) {\n\t\tdev_err(&hdev->pdev->dev, \"mdio read data error\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn le16_to_cpu(mdio_cmd->data_rd);\n}\n\nint hclge_mac_mdio_config(struct hclge_dev *hdev)\n{\n#define PHY_INEXISTENT\t255\n\n\tstruct hclge_mac *mac = &hdev->hw.mac;\n\tstruct phy_device *phydev;\n\tstruct mii_bus *mdio_bus;\n\tint ret;\n\n\tif (hdev->hw.mac.phy_addr == PHY_INEXISTENT) {\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"no phy device is connected to mdio bus\\n\");\n\t\treturn 0;\n\t} else if (hdev->hw.mac.phy_addr >= PHY_MAX_ADDR) {\n\t\tdev_err(&hdev->pdev->dev, \"phy_addr(%u) is too large.\\n\",\n\t\t\thdev->hw.mac.phy_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tmdio_bus = devm_mdiobus_alloc(&hdev->pdev->dev);\n\tif (!mdio_bus)\n\t\treturn -ENOMEM;\n\n\tmdio_bus->name = \"hisilicon MII bus\";\n\tmdio_bus->read = hclge_mdio_read;\n\tmdio_bus->write = hclge_mdio_write;\n\tsnprintf(mdio_bus->id, MII_BUS_ID_SIZE, \"%s-%s\", \"mii\",\n\t\t dev_name(&hdev->pdev->dev));\n\n\tmdio_bus->parent = &hdev->pdev->dev;\n\tmdio_bus->priv = hdev;\n\tmdio_bus->phy_mask = ~(1 << mac->phy_addr);\n\tret = mdiobus_register(mdio_bus);\n\tif (ret) {\n\t\tdev_err(mdio_bus->parent,\n\t\t\t\"failed to register MDIO bus, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphydev = mdiobus_get_phy(mdio_bus, mac->phy_addr);\n\tif (!phydev) {\n\t\tdev_err(mdio_bus->parent, \"Failed to get phy device\\n\");\n\t\tmdiobus_unregister(mdio_bus);\n\t\treturn -EIO;\n\t}\n\n\tmac->phydev = phydev;\n\tmac->mdio_bus = mdio_bus;\n\n\treturn 0;\n}\n\nstatic void hclge_mac_adjust_link(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = *((void **)netdev_priv(netdev));\n\tstruct hclge_vport *vport = hclge_get_vport(h);\n\tstruct hclge_dev *hdev = vport->back;\n\tint duplex, speed;\n\tint ret;\n\n\t \n\tif (netdev->phydev->link == 0)\n\t\treturn;\n\n\tspeed = netdev->phydev->speed;\n\tduplex = netdev->phydev->duplex;\n\n\tret = hclge_cfg_mac_speed_dup(hdev, speed, duplex, 0);\n\tif (ret)\n\t\tnetdev_err(netdev, \"failed to adjust link.\\n\");\n\n\tret = hclge_cfg_flowctrl(hdev);\n\tif (ret)\n\t\tnetdev_err(netdev, \"failed to configure flow control.\\n\");\n}\n\nint hclge_mac_connect_phy(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct net_device *netdev = hdev->vport[0].nic.netdev;\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };\n\tint ret;\n\n\tif (!phydev)\n\t\treturn 0;\n\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, phydev->supported);\n\n\tphydev->dev_flags |= MARVELL_PHY_LED0_LINK_LED1_ACTIVE;\n\n\tret = phy_connect_direct(netdev, phydev,\n\t\t\t\t hclge_mac_adjust_link,\n\t\t\t\t PHY_INTERFACE_MODE_SGMII);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"phy_connect_direct err.\\n\");\n\t\treturn ret;\n\t}\n\n\tlinkmode_copy(mask, hdev->hw.mac.supported);\n\tlinkmode_and(phydev->supported, phydev->supported, mask);\n\tlinkmode_copy(phydev->advertising, phydev->supported);\n\n\t \n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t   phydev->advertising);\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\nvoid hclge_mac_disconnect_phy(struct hnae3_handle *handle)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\n\tif (!phydev)\n\t\treturn;\n\n\tphy_disconnect(phydev);\n}\n\nvoid hclge_mac_start_phy(struct hclge_dev *hdev)\n{\n\tstruct phy_device *phydev = hdev->hw.mac.phydev;\n\n\tif (!phydev)\n\t\treturn;\n\n\tphy_loopback(phydev, false);\n\n\tphy_start(phydev);\n}\n\nvoid hclge_mac_stop_phy(struct hclge_dev *hdev)\n{\n\tstruct net_device *netdev = hdev->vport[0].nic.netdev;\n\tstruct phy_device *phydev = netdev->phydev;\n\n\tif (!phydev)\n\t\treturn;\n\n\tphy_stop(phydev);\n}\n\nu16 hclge_read_phy_reg(struct hclge_dev *hdev, u16 reg_addr)\n{\n\tstruct hclge_phy_reg_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PHY_REG, true);\n\n\treq = (struct hclge_phy_reg_cmd *)desc.data;\n\treq->reg_addr = cpu_to_le16(reg_addr);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to read phy reg, ret = %d.\\n\", ret);\n\n\treturn le16_to_cpu(req->reg_val);\n}\n\nint hclge_write_phy_reg(struct hclge_dev *hdev, u16 reg_addr, u16 val)\n{\n\tstruct hclge_phy_reg_cmd *req;\n\tstruct hclge_desc desc;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PHY_REG, false);\n\n\treq = (struct hclge_phy_reg_cmd *)desc.data;\n\treq->reg_addr = cpu_to_le16(reg_addr);\n\treq->reg_val = cpu_to_le16(val);\n\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to write phy reg, ret = %d.\\n\", ret);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}