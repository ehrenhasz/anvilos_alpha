{
  "module_name": "hclge_mbx.c",
  "hash_id": "f69487404469651e6090af8a3547f6083dfb2d445cd879d2b8c8910bbda15f22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mbx.c",
  "human_readable_source": "\n\n\n#include \"hclge_main.h\"\n#include \"hclge_mbx.h\"\n#include \"hnae3.h\"\n#include \"hclge_comm_rss.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"hclge_trace.h\"\n\nstatic u16 hclge_errno_to_resp(int errno)\n{\n\tint resp = abs(errno);\n\n\t \n\treturn (u16)resp;\n}\n\n \nstatic int hclge_gen_resp_to_vf(struct hclge_vport *vport,\n\t\t\t\tstruct hclge_mbx_vf_to_pf_cmd *vf_to_pf_req,\n\t\t\t\tstruct hclge_respond_to_vf_msg *resp_msg)\n{\n\tstruct hclge_mbx_pf_to_vf_cmd *resp_pf_to_vf;\n\tstruct hclge_dev *hdev = vport->back;\n\tenum hclge_comm_cmd_status status;\n\tstruct hclge_desc desc;\n\tu16 resp;\n\n\tresp_pf_to_vf = (struct hclge_mbx_pf_to_vf_cmd *)desc.data;\n\n\tif (resp_msg->len > HCLGE_MBX_MAX_RESP_DATA_SIZE) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"PF fail to gen resp to VF len %u exceeds max len %u\\n\",\n\t\t\tresp_msg->len,\n\t\t\tHCLGE_MBX_MAX_RESP_DATA_SIZE);\n\t\t \n\t\tresp_msg->len = HCLGE_MBX_MAX_RESP_DATA_SIZE;\n\t}\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGEVF_OPC_MBX_PF_TO_VF, false);\n\n\tresp_pf_to_vf->dest_vfid = vf_to_pf_req->mbx_src_vfid;\n\tresp_pf_to_vf->msg_len = vf_to_pf_req->msg_len;\n\tresp_pf_to_vf->match_id = vf_to_pf_req->match_id;\n\n\tresp_pf_to_vf->msg.code = cpu_to_le16(HCLGE_MBX_PF_VF_RESP);\n\tresp_pf_to_vf->msg.vf_mbx_msg_code =\n\t\t\t\tcpu_to_le16(vf_to_pf_req->msg.code);\n\tresp_pf_to_vf->msg.vf_mbx_msg_subcode =\n\t\t\t\tcpu_to_le16(vf_to_pf_req->msg.subcode);\n\tresp = hclge_errno_to_resp(resp_msg->status);\n\tif (resp < SHRT_MAX) {\n\t\tresp_pf_to_vf->msg.resp_status = cpu_to_le16(resp);\n\t} else {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"failed to send response to VF, response status %u is out-of-bound\\n\",\n\t\t\t resp);\n\t\tresp_pf_to_vf->msg.resp_status = cpu_to_le16(EIO);\n\t}\n\n\tif (resp_msg->len > 0)\n\t\tmemcpy(resp_pf_to_vf->msg.resp_data, resp_msg->data,\n\t\t       resp_msg->len);\n\n\ttrace_hclge_pf_mbx_send(hdev, resp_pf_to_vf);\n\n\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to send response to VF, status: %d, vfid: %u, code: %u, subcode: %u.\\n\",\n\t\t\tstatus, vf_to_pf_req->mbx_src_vfid,\n\t\t\tvf_to_pf_req->msg.code, vf_to_pf_req->msg.subcode);\n\n\treturn status;\n}\n\nstatic int hclge_send_mbx_msg(struct hclge_vport *vport, u8 *msg, u16 msg_len,\n\t\t\t      u16 mbx_opcode, u8 dest_vfid)\n{\n\tstruct hclge_mbx_pf_to_vf_cmd *resp_pf_to_vf;\n\tstruct hclge_dev *hdev = vport->back;\n\tenum hclge_comm_cmd_status status;\n\tstruct hclge_desc desc;\n\n\tif (msg_len > HCLGE_MBX_MAX_MSG_SIZE) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"msg data length(=%u) exceeds maximum(=%u)\\n\",\n\t\t\tmsg_len, HCLGE_MBX_MAX_MSG_SIZE);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tresp_pf_to_vf = (struct hclge_mbx_pf_to_vf_cmd *)desc.data;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGEVF_OPC_MBX_PF_TO_VF, false);\n\n\tresp_pf_to_vf->dest_vfid = dest_vfid;\n\tresp_pf_to_vf->msg_len = msg_len;\n\tresp_pf_to_vf->msg.code = cpu_to_le16(mbx_opcode);\n\n\tmemcpy(resp_pf_to_vf->msg.msg_data, msg, msg_len);\n\n\ttrace_hclge_pf_mbx_send(hdev, resp_pf_to_vf);\n\n\tstatus = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to send mailbox to VF, status: %d, vfid: %u, opcode: %u\\n\",\n\t\t\tstatus, dest_vfid, mbx_opcode);\n\n\treturn status;\n}\n\nstatic int hclge_inform_vf_reset(struct hclge_vport *vport, u16 reset_type)\n{\n\t__le16 msg_data;\n\tu8 dest_vfid;\n\n\tdest_vfid = (u8)vport->vport_id;\n\tmsg_data = cpu_to_le16(reset_type);\n\n\t \n\treturn hclge_send_mbx_msg(vport, (u8 *)&msg_data, sizeof(msg_data),\n\t\t\t\t  HCLGE_MBX_ASSERTING_RESET, dest_vfid);\n}\n\nint hclge_inform_reset_assert_to_vf(struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 reset_type;\n\n\tBUILD_BUG_ON(HNAE3_MAX_RESET > U16_MAX);\n\n\tif (hdev->reset_type == HNAE3_FUNC_RESET)\n\t\treset_type = HNAE3_VF_PF_FUNC_RESET;\n\telse if (hdev->reset_type == HNAE3_FLR_RESET)\n\t\treset_type = HNAE3_VF_FULL_RESET;\n\telse\n\t\treset_type = HNAE3_VF_FUNC_RESET;\n\n\treturn hclge_inform_vf_reset(vport, reset_type);\n}\n\nstatic void hclge_free_vector_ring_chain(struct hnae3_ring_chain_node *head)\n{\n\tstruct hnae3_ring_chain_node *chain_tmp, *chain;\n\n\tchain = head->next;\n\n\twhile (chain) {\n\t\tchain_tmp = chain->next;\n\t\tkfree_sensitive(chain);\n\t\tchain = chain_tmp;\n\t}\n}\n\n \nstatic int hclge_get_ring_chain_from_mbx(\n\t\t\tstruct hclge_mbx_vf_to_pf_cmd *req,\n\t\t\tstruct hnae3_ring_chain_node *ring_chain,\n\t\t\tstruct hclge_vport *vport)\n{\n\tstruct hnae3_ring_chain_node *cur_chain, *new_chain;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ring_num;\n\tint i;\n\n\tring_num = req->msg.ring_num;\n\n\tif (ring_num > HCLGE_MBX_MAX_RING_CHAIN_PARAM_NUM)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ring_num; i++) {\n\t\tif (req->msg.param[i].tqp_index >= vport->nic.kinfo.rss_size) {\n\t\t\tdev_err(&hdev->pdev->dev, \"tqp index(%u) is out of range(0-%u)\\n\",\n\t\t\t\treq->msg.param[i].tqp_index,\n\t\t\t\tvport->nic.kinfo.rss_size - 1U);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\thnae3_set_bit(ring_chain->flag, HNAE3_RING_TYPE_B,\n\t\t      req->msg.param[0].ring_type);\n\tring_chain->tqp_index =\n\t\thclge_get_queue_id(vport->nic.kinfo.tqp\n\t\t\t\t   [req->msg.param[0].tqp_index]);\n\thnae3_set_field(ring_chain->int_gl_idx, HNAE3_RING_GL_IDX_M,\n\t\t\tHNAE3_RING_GL_IDX_S, req->msg.param[0].int_gl_index);\n\n\tcur_chain = ring_chain;\n\n\tfor (i = 1; i < ring_num; i++) {\n\t\tnew_chain = kzalloc(sizeof(*new_chain), GFP_KERNEL);\n\t\tif (!new_chain)\n\t\t\tgoto err;\n\n\t\thnae3_set_bit(new_chain->flag, HNAE3_RING_TYPE_B,\n\t\t\t      req->msg.param[i].ring_type);\n\n\t\tnew_chain->tqp_index =\n\t\thclge_get_queue_id(vport->nic.kinfo.tqp\n\t\t\t[req->msg.param[i].tqp_index]);\n\n\t\thnae3_set_field(new_chain->int_gl_idx, HNAE3_RING_GL_IDX_M,\n\t\t\t\tHNAE3_RING_GL_IDX_S,\n\t\t\t\treq->msg.param[i].int_gl_index);\n\n\t\tcur_chain->next = new_chain;\n\t\tcur_chain = new_chain;\n\t}\n\n\treturn 0;\nerr:\n\thclge_free_vector_ring_chain(ring_chain);\n\treturn -ENOMEM;\n}\n\nstatic int hclge_map_unmap_ring_to_vf_vector(struct hclge_vport *vport, bool en,\n\t\t\t\t\t     struct hclge_mbx_vf_to_pf_cmd *req)\n{\n\tstruct hnae3_ring_chain_node ring_chain;\n\tint vector_id = req->msg.vector_id;\n\tint ret;\n\n\tmemset(&ring_chain, 0, sizeof(ring_chain));\n\tret = hclge_get_ring_chain_from_mbx(req, &ring_chain, vport);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_bind_ring_with_vector(vport, vector_id, en, &ring_chain);\n\n\thclge_free_vector_ring_chain(&ring_chain);\n\n\treturn ret;\n}\n\nstatic int hclge_query_ring_vector_map(struct hclge_vport *vport,\n\t\t\t\t       struct hnae3_ring_chain_node *ring_chain,\n\t\t\t\t       struct hclge_desc *desc)\n{\n\tstruct hclge_ctrl_vector_chain_cmd *req =\n\t\t(struct hclge_ctrl_vector_chain_cmd *)desc->data;\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 tqp_type_and_id;\n\tint status;\n\n\thclge_cmd_setup_basic_desc(desc, HCLGE_OPC_ADD_RING_TO_VECTOR, true);\n\n\ttqp_type_and_id = le16_to_cpu(req->tqp_type_and_id[0]);\n\thnae3_set_field(tqp_type_and_id, HCLGE_INT_TYPE_M, HCLGE_INT_TYPE_S,\n\t\t\thnae3_get_bit(ring_chain->flag, HNAE3_RING_TYPE_B));\n\thnae3_set_field(tqp_type_and_id, HCLGE_TQP_ID_M, HCLGE_TQP_ID_S,\n\t\t\tring_chain->tqp_index);\n\treq->tqp_type_and_id[0] = cpu_to_le16(tqp_type_and_id);\n\treq->vfid = vport->vport_id;\n\n\tstatus = hclge_cmd_send(&hdev->hw, desc, 1);\n\tif (status)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get VF ring vector map info fail, status is %d.\\n\",\n\t\t\tstatus);\n\n\treturn status;\n}\n\nstatic int hclge_get_vf_ring_vector_map(struct hclge_vport *vport,\n\t\t\t\t\tstruct hclge_mbx_vf_to_pf_cmd *req,\n\t\t\t\t\tstruct hclge_respond_to_vf_msg *resp)\n{\n#define HCLGE_LIMIT_RING_NUM\t\t\t1\n#define HCLGE_RING_TYPE_OFFSET\t\t\t0\n#define HCLGE_TQP_INDEX_OFFSET\t\t\t1\n#define HCLGE_INT_GL_INDEX_OFFSET\t\t2\n#define HCLGE_VECTOR_ID_OFFSET\t\t\t3\n#define HCLGE_RING_VECTOR_MAP_INFO_LEN\t\t4\n\tstruct hnae3_ring_chain_node ring_chain;\n\tstruct hclge_desc desc;\n\tstruct hclge_ctrl_vector_chain_cmd *data =\n\t\t(struct hclge_ctrl_vector_chain_cmd *)desc.data;\n\tu16 tqp_type_and_id;\n\tu8 int_gl_index;\n\tint ret;\n\n\treq->msg.ring_num = HCLGE_LIMIT_RING_NUM;\n\n\tmemset(&ring_chain, 0, sizeof(ring_chain));\n\tret = hclge_get_ring_chain_from_mbx(req, &ring_chain, vport);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hclge_query_ring_vector_map(vport, &ring_chain, &desc);\n\tif (ret) {\n\t\thclge_free_vector_ring_chain(&ring_chain);\n\t\treturn ret;\n\t}\n\n\ttqp_type_and_id = le16_to_cpu(data->tqp_type_and_id[0]);\n\tint_gl_index = hnae3_get_field(tqp_type_and_id,\n\t\t\t\t       HCLGE_INT_GL_IDX_M, HCLGE_INT_GL_IDX_S);\n\n\tresp->data[HCLGE_RING_TYPE_OFFSET] = req->msg.param[0].ring_type;\n\tresp->data[HCLGE_TQP_INDEX_OFFSET] = req->msg.param[0].tqp_index;\n\tresp->data[HCLGE_INT_GL_INDEX_OFFSET] = int_gl_index;\n\tresp->data[HCLGE_VECTOR_ID_OFFSET] = data->int_vector_id_l;\n\tresp->len = HCLGE_RING_VECTOR_MAP_INFO_LEN;\n\n\thclge_free_vector_ring_chain(&ring_chain);\n\n\treturn ret;\n}\n\nstatic void hclge_set_vf_promisc_mode(struct hclge_vport *vport,\n\t\t\t\t      struct hclge_mbx_vf_to_pf_cmd *req)\n{\n\tstruct hnae3_handle *handle = &vport->nic;\n\tstruct hclge_dev *hdev = vport->back;\n\n\tvport->vf_info.request_uc_en = req->msg.en_uc;\n\tvport->vf_info.request_mc_en = req->msg.en_mc;\n\tvport->vf_info.request_bc_en = req->msg.en_bc;\n\n\tif (req->msg.en_limit_promisc)\n\t\tset_bit(HNAE3_PFLAG_LIMIT_PROMISC, &handle->priv_flags);\n\telse\n\t\tclear_bit(HNAE3_PFLAG_LIMIT_PROMISC,\n\t\t\t  &handle->priv_flags);\n\n\tset_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE, &vport->state);\n\thclge_task_schedule(hdev, 0);\n}\n\nstatic int hclge_set_vf_uc_mac_addr(struct hclge_vport *vport,\n\t\t\t\t    struct hclge_mbx_vf_to_pf_cmd *mbx_req)\n{\n#define HCLGE_MBX_VF_OLD_MAC_ADDR_OFFSET\t6\n\n\tconst u8 *mac_addr = (const u8 *)(mbx_req->msg.data);\n\tstruct hclge_dev *hdev = vport->back;\n\tint status;\n\n\tif (mbx_req->msg.subcode == HCLGE_MBX_MAC_VLAN_UC_MODIFY) {\n\t\tconst u8 *old_addr = (const u8 *)\n\t\t(&mbx_req->msg.data[HCLGE_MBX_VF_OLD_MAC_ADDR_OFFSET]);\n\n\t\t \n\t\tif (!is_zero_ether_addr(vport->vf_info.mac) &&\n\t\t    !ether_addr_equal(mac_addr, vport->vf_info.mac))\n\t\t\treturn -EPERM;\n\n\t\tif (!is_valid_ether_addr(mac_addr))\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_bh(&vport->mac_list_lock);\n\t\tstatus = hclge_update_mac_node_for_dev_addr(vport, old_addr,\n\t\t\t\t\t\t\t    mac_addr);\n\t\tspin_unlock_bh(&vport->mac_list_lock);\n\t\thclge_task_schedule(hdev, 0);\n\t} else if (mbx_req->msg.subcode == HCLGE_MBX_MAC_VLAN_UC_ADD) {\n\t\tstatus = hclge_update_mac_list(vport, HCLGE_MAC_TO_ADD,\n\t\t\t\t\t       HCLGE_MAC_ADDR_UC, mac_addr);\n\t} else if (mbx_req->msg.subcode == HCLGE_MBX_MAC_VLAN_UC_REMOVE) {\n\t\tstatus = hclge_update_mac_list(vport, HCLGE_MAC_TO_DEL,\n\t\t\t\t\t       HCLGE_MAC_ADDR_UC, mac_addr);\n\t} else {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set unicast mac addr, unknown subcode %u\\n\",\n\t\t\tmbx_req->msg.subcode);\n\t\treturn -EIO;\n\t}\n\n\treturn status;\n}\n\nstatic int hclge_set_vf_mc_mac_addr(struct hclge_vport *vport,\n\t\t\t\t    struct hclge_mbx_vf_to_pf_cmd *mbx_req)\n{\n\tconst u8 *mac_addr = (const u8 *)(mbx_req->msg.data);\n\tstruct hclge_dev *hdev = vport->back;\n\n\tif (mbx_req->msg.subcode == HCLGE_MBX_MAC_VLAN_MC_ADD) {\n\t\thclge_update_mac_list(vport, HCLGE_MAC_TO_ADD,\n\t\t\t\t      HCLGE_MAC_ADDR_MC, mac_addr);\n\t} else if (mbx_req->msg.subcode == HCLGE_MBX_MAC_VLAN_MC_REMOVE) {\n\t\thclge_update_mac_list(vport, HCLGE_MAC_TO_DEL,\n\t\t\t\t      HCLGE_MAC_ADDR_MC, mac_addr);\n\t} else {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to set mcast mac addr, unknown subcode %u\\n\",\n\t\t\tmbx_req->msg.subcode);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hclge_push_vf_port_base_vlan_info(struct hclge_vport *vport, u8 vfid,\n\t\t\t\t      u16 state,\n\t\t\t\t      struct hclge_vlan_info *vlan_info)\n{\n\tstruct hclge_mbx_port_base_vlan base_vlan;\n\n\tbase_vlan.state = cpu_to_le16(state);\n\tbase_vlan.vlan_proto = cpu_to_le16(vlan_info->vlan_proto);\n\tbase_vlan.qos = cpu_to_le16(vlan_info->qos);\n\tbase_vlan.vlan_tag = cpu_to_le16(vlan_info->vlan_tag);\n\n\treturn hclge_send_mbx_msg(vport, (u8 *)&base_vlan, sizeof(base_vlan),\n\t\t\t\t  HCLGE_MBX_PUSH_VLAN_INFO, vfid);\n}\n\nstatic int hclge_set_vf_vlan_cfg(struct hclge_vport *vport,\n\t\t\t\t struct hclge_mbx_vf_to_pf_cmd *mbx_req,\n\t\t\t\t struct hclge_respond_to_vf_msg *resp_msg)\n{\n#define HCLGE_MBX_VLAN_STATE_OFFSET\t0\n#define HCLGE_MBX_VLAN_INFO_OFFSET\t2\n\n\tstruct hnae3_handle *handle = &vport->nic;\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_vf_vlan_cfg *msg_cmd;\n\t__be16 proto;\n\tu16 vlan_id;\n\n\tmsg_cmd = (struct hclge_vf_vlan_cfg *)&mbx_req->msg;\n\tswitch (msg_cmd->subcode) {\n\tcase HCLGE_MBX_VLAN_FILTER:\n\t\tproto = cpu_to_be16(le16_to_cpu(msg_cmd->proto));\n\t\tvlan_id = le16_to_cpu(msg_cmd->vlan);\n\t\treturn hclge_set_vlan_filter(handle, proto, vlan_id,\n\t\t\t\t\t     msg_cmd->is_kill);\n\tcase HCLGE_MBX_VLAN_RX_OFF_CFG:\n\t\treturn hclge_en_hw_strip_rxvtag(handle, msg_cmd->enable);\n\tcase HCLGE_MBX_GET_PORT_BASE_VLAN_STATE:\n\t\t \n\t\tresp_msg->data[0] =\n\t\t\thdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3 ?\n\t\t\tHNAE3_PORT_BASE_VLAN_DISABLE :\n\t\t\tvport->port_base_vlan_cfg.state;\n\t\tresp_msg->len = sizeof(u8);\n\t\treturn 0;\n\tcase HCLGE_MBX_ENABLE_VLAN_FILTER:\n\t\treturn hclge_enable_vport_vlan_filter(vport, msg_cmd->enable);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int hclge_set_vf_alive(struct hclge_vport *vport,\n\t\t\t      struct hclge_mbx_vf_to_pf_cmd *mbx_req)\n{\n\tbool alive = !!mbx_req->msg.data[0];\n\tint ret = 0;\n\n\tif (alive)\n\t\tret = hclge_vport_start(vport);\n\telse\n\t\thclge_vport_stop(vport);\n\n\treturn ret;\n}\n\nstatic void hclge_get_basic_info(struct hclge_vport *vport,\n\t\t\t\t struct hclge_respond_to_vf_msg *resp_msg)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hnae3_ae_dev *ae_dev = vport->back->ae_dev;\n\tstruct hclge_basic_info *basic_info;\n\tunsigned int i;\n\tu32 pf_caps;\n\n\tbasic_info = (struct hclge_basic_info *)resp_msg->data;\n\tfor (i = 0; i < kinfo->tc_info.num_tc; i++)\n\t\tbasic_info->hw_tc_map |= BIT(i);\n\n\tpf_caps = le32_to_cpu(basic_info->pf_caps);\n\tif (test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, ae_dev->caps))\n\t\thnae3_set_bit(pf_caps, HNAE3_PF_SUPPORT_VLAN_FLTR_MDF_B, 1);\n\n\tbasic_info->pf_caps = cpu_to_le32(pf_caps);\n\tresp_msg->len = HCLGE_MBX_MAX_RESP_DATA_SIZE;\n}\n\nstatic void hclge_get_vf_queue_info(struct hclge_vport *vport,\n\t\t\t\t    struct hclge_respond_to_vf_msg *resp_msg)\n{\n#define HCLGE_TQPS_RSS_INFO_LEN\t\t6\n\n\tstruct hclge_mbx_vf_queue_info *queue_info;\n\tstruct hclge_dev *hdev = vport->back;\n\n\t \n\tqueue_info = (struct hclge_mbx_vf_queue_info *)resp_msg->data;\n\tqueue_info->num_tqps = cpu_to_le16(vport->alloc_tqps);\n\tqueue_info->rss_size = cpu_to_le16(vport->nic.kinfo.rss_size);\n\tqueue_info->rx_buf_len = cpu_to_le16(hdev->rx_buf_len);\n\tresp_msg->len = HCLGE_TQPS_RSS_INFO_LEN;\n}\n\nstatic void hclge_get_vf_mac_addr(struct hclge_vport *vport,\n\t\t\t\t  struct hclge_respond_to_vf_msg *resp_msg)\n{\n\tether_addr_copy(resp_msg->data, vport->vf_info.mac);\n\tresp_msg->len = ETH_ALEN;\n}\n\nstatic void hclge_get_vf_queue_depth(struct hclge_vport *vport,\n\t\t\t\t     struct hclge_respond_to_vf_msg *resp_msg)\n{\n#define HCLGE_TQPS_DEPTH_INFO_LEN\t4\n\n\tstruct hclge_mbx_vf_queue_depth *queue_depth;\n\tstruct hclge_dev *hdev = vport->back;\n\n\t \n\tqueue_depth = (struct hclge_mbx_vf_queue_depth *)resp_msg->data;\n\tqueue_depth->num_tx_desc = cpu_to_le16(hdev->num_tx_desc);\n\tqueue_depth->num_rx_desc = cpu_to_le16(hdev->num_rx_desc);\n\n\tresp_msg->len = HCLGE_TQPS_DEPTH_INFO_LEN;\n}\n\nstatic void hclge_get_vf_media_type(struct hclge_vport *vport,\n\t\t\t\t    struct hclge_respond_to_vf_msg *resp_msg)\n{\n#define HCLGE_VF_MEDIA_TYPE_OFFSET\t0\n#define HCLGE_VF_MODULE_TYPE_OFFSET\t1\n#define HCLGE_VF_MEDIA_TYPE_LENGTH\t2\n\n\tstruct hclge_dev *hdev = vport->back;\n\n\tresp_msg->data[HCLGE_VF_MEDIA_TYPE_OFFSET] =\n\t\thdev->hw.mac.media_type;\n\tresp_msg->data[HCLGE_VF_MODULE_TYPE_OFFSET] =\n\t\thdev->hw.mac.module_type;\n\tresp_msg->len = HCLGE_VF_MEDIA_TYPE_LENGTH;\n}\n\nint hclge_push_vf_link_status(struct hclge_vport *vport)\n{\n#define HCLGE_VF_LINK_STATE_UP\t\t1U\n#define HCLGE_VF_LINK_STATE_DOWN\t0U\n\n\tstruct hclge_mbx_link_status link_info;\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 link_status;\n\n\t \n\tswitch (vport->vf_info.link_state) {\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\tlink_status = HCLGE_VF_LINK_STATE_UP;\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tlink_status = HCLGE_VF_LINK_STATE_DOWN;\n\t\tbreak;\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\tdefault:\n\t\tlink_status = (u16)hdev->hw.mac.link;\n\t\tbreak;\n\t}\n\n\tlink_info.link_status = cpu_to_le16(link_status);\n\tlink_info.speed = cpu_to_le32(hdev->hw.mac.speed);\n\tlink_info.duplex = cpu_to_le16(hdev->hw.mac.duplex);\n\tlink_info.flag = HCLGE_MBX_PUSH_LINK_STATUS_EN;\n\n\t \n\treturn hclge_send_mbx_msg(vport, (u8 *)&link_info, sizeof(link_info),\n\t\t\t\t  HCLGE_MBX_LINK_STAT_CHANGE, vport->vport_id);\n}\n\nstatic void hclge_get_link_mode(struct hclge_vport *vport,\n\t\t\t\tstruct hclge_mbx_vf_to_pf_cmd *mbx_req)\n{\n#define HCLGE_SUPPORTED   1\n\tstruct hclge_mbx_link_mode link_mode;\n\tstruct hclge_dev *hdev = vport->back;\n\tunsigned long advertising;\n\tunsigned long supported;\n\tunsigned long send_data;\n\tu8 dest_vfid;\n\n\tadvertising = hdev->hw.mac.advertising[0];\n\tsupported = hdev->hw.mac.supported[0];\n\tdest_vfid = mbx_req->mbx_src_vfid;\n\tsend_data = mbx_req->msg.data[0] == HCLGE_SUPPORTED ? supported :\n\t\t\t\t\t\t\t      advertising;\n\tlink_mode.idx = cpu_to_le16((u16)mbx_req->msg.data[0]);\n\tlink_mode.link_mode = cpu_to_le64(send_data);\n\n\thclge_send_mbx_msg(vport, (u8 *)&link_mode, sizeof(link_mode),\n\t\t\t   HCLGE_MBX_LINK_STAT_MODE, dest_vfid);\n}\n\nstatic int hclge_mbx_reset_vf_queue(struct hclge_vport *vport,\n\t\t\t\t    struct hclge_mbx_vf_to_pf_cmd *mbx_req,\n\t\t\t\t    struct hclge_respond_to_vf_msg *resp_msg)\n{\n#define HCLGE_RESET_ALL_QUEUE_DONE\t1U\n\tstruct hnae3_handle *handle = &vport->nic;\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 queue_id;\n\tint ret;\n\n\tqueue_id = le16_to_cpu(*(__le16 *)mbx_req->msg.data);\n\tresp_msg->data[0] = HCLGE_RESET_ALL_QUEUE_DONE;\n\tresp_msg->len = sizeof(u8);\n\n\t \n\tif (queue_id > 0)\n\t\treturn 0;\n\n\tret = hclge_reset_tqp(handle);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev, \"failed to reset vf %u queue, ret = %d\\n\",\n\t\t\tvport->vport_id - HCLGE_VF_VPORT_START_NUM, ret);\n\n\treturn ret;\n}\n\nstatic int hclge_reset_vf(struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\n\tdev_warn(&hdev->pdev->dev, \"PF received VF reset request from VF %u!\",\n\t\t vport->vport_id - HCLGE_VF_VPORT_START_NUM);\n\n\treturn hclge_func_reset_cmd(hdev, vport->vport_id);\n}\n\nstatic void hclge_notify_vf_config(struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tstruct hclge_port_base_vlan_config *vlan_cfg;\n\tint ret;\n\n\thclge_push_vf_link_status(vport);\n\tif (test_bit(HCLGE_VPORT_NEED_NOTIFY_RESET, &vport->need_notify)) {\n\t\tret = hclge_inform_vf_reset(vport, HNAE3_VF_PF_FUNC_RESET);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to inform VF %u reset!\",\n\t\t\t\tvport->vport_id - HCLGE_VF_VPORT_START_NUM);\n\t\t\treturn;\n\t\t}\n\t\tvport->need_notify = 0;\n\t\treturn;\n\t}\n\n\tif (ae_dev->dev_version < HNAE3_DEVICE_VERSION_V3 &&\n\t    test_bit(HCLGE_VPORT_NEED_NOTIFY_VF_VLAN, &vport->need_notify)) {\n\t\tvlan_cfg = &vport->port_base_vlan_cfg;\n\t\tret = hclge_push_vf_port_base_vlan_info(&hdev->vport[0],\n\t\t\t\t\t\t\tvport->vport_id,\n\t\t\t\t\t\t\tvlan_cfg->state,\n\t\t\t\t\t\t\t&vlan_cfg->vlan_info);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"failed to inform VF %u port base vlan!\",\n\t\t\t\tvport->vport_id - HCLGE_VF_VPORT_START_NUM);\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(HCLGE_VPORT_NEED_NOTIFY_VF_VLAN, &vport->need_notify);\n\t}\n}\n\nstatic void hclge_vf_keep_alive(struct hclge_vport *vport)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\n\tvport->last_active_jiffies = jiffies;\n\n\tif (test_bit(HCLGE_VPORT_STATE_INITED, &vport->state) &&\n\t    !test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state)) {\n\t\tset_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);\n\t\tdev_info(&hdev->pdev->dev, \"VF %u is alive!\",\n\t\t\t vport->vport_id - HCLGE_VF_VPORT_START_NUM);\n\t\thclge_notify_vf_config(vport);\n\t}\n}\n\nstatic int hclge_set_vf_mtu(struct hclge_vport *vport,\n\t\t\t    struct hclge_mbx_vf_to_pf_cmd *mbx_req)\n{\n\tstruct hclge_mbx_mtu_info *mtu_info;\n\tu32 mtu;\n\n\tmtu_info = (struct hclge_mbx_mtu_info *)mbx_req->msg.data;\n\tmtu = le32_to_cpu(mtu_info->mtu);\n\n\treturn hclge_set_vport_mtu(vport, mtu);\n}\n\nstatic int hclge_get_queue_id_in_pf(struct hclge_vport *vport,\n\t\t\t\t    struct hclge_mbx_vf_to_pf_cmd *mbx_req,\n\t\t\t\t    struct hclge_respond_to_vf_msg *resp_msg)\n{\n\tstruct hnae3_handle *handle = &vport->nic;\n\tstruct hclge_dev *hdev = vport->back;\n\tu16 queue_id, qid_in_pf;\n\n\tqueue_id = le16_to_cpu(*(__le16 *)mbx_req->msg.data);\n\tif (queue_id >= handle->kinfo.num_tqps) {\n\t\tdev_err(&hdev->pdev->dev, \"Invalid queue id(%u) from VF %u\\n\",\n\t\t\tqueue_id, mbx_req->mbx_src_vfid);\n\t\treturn -EINVAL;\n\t}\n\n\tqid_in_pf = hclge_covert_handle_qid_global(&vport->nic, queue_id);\n\t*(__le16 *)resp_msg->data = cpu_to_le16(qid_in_pf);\n\tresp_msg->len = sizeof(qid_in_pf);\n\treturn 0;\n}\n\nstatic int hclge_get_rss_key(struct hclge_vport *vport,\n\t\t\t     struct hclge_mbx_vf_to_pf_cmd *mbx_req,\n\t\t\t     struct hclge_respond_to_vf_msg *resp_msg)\n{\n#define HCLGE_RSS_MBX_RESP_LEN\t8\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_comm_rss_cfg *rss_cfg;\n\tu8 index;\n\n\tindex = mbx_req->msg.data[0];\n\trss_cfg = &hdev->rss_cfg;\n\n\t \n\tif (((index + 1) * HCLGE_RSS_MBX_RESP_LEN) >\n\t      sizeof(rss_cfg->rss_hash_key)) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"failed to get the rss hash key, the index(%u) invalid !\\n\",\n\t\t\t index);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(resp_msg->data,\n\t       &rss_cfg->rss_hash_key[index * HCLGE_RSS_MBX_RESP_LEN],\n\t       HCLGE_RSS_MBX_RESP_LEN);\n\tresp_msg->len = HCLGE_RSS_MBX_RESP_LEN;\n\treturn 0;\n}\n\nstatic void hclge_link_fail_parse(struct hclge_dev *hdev, u8 link_fail_code)\n{\n\tswitch (link_fail_code) {\n\tcase HCLGE_LF_REF_CLOCK_LOST:\n\t\tdev_warn(&hdev->pdev->dev, \"Reference clock lost!\\n\");\n\t\tbreak;\n\tcase HCLGE_LF_XSFP_TX_DISABLE:\n\t\tdev_warn(&hdev->pdev->dev, \"SFP tx is disabled!\\n\");\n\t\tbreak;\n\tcase HCLGE_LF_XSFP_ABSENT:\n\t\tdev_warn(&hdev->pdev->dev, \"SFP is absent!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void hclge_handle_link_change_event(struct hclge_dev *hdev,\n\t\t\t\t\t   struct hclge_mbx_vf_to_pf_cmd *req)\n{\n\thclge_task_schedule(hdev, 0);\n\n\tif (!req->msg.subcode)\n\t\thclge_link_fail_parse(hdev, req->msg.data[0]);\n}\n\nstatic bool hclge_cmd_crq_empty(struct hclge_hw *hw)\n{\n\tu32 tail = hclge_read_dev(hw, HCLGE_COMM_NIC_CRQ_TAIL_REG);\n\n\treturn tail == hw->hw.cmq.crq.next_to_use;\n}\n\nstatic void hclge_handle_ncsi_error(struct hclge_dev *hdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = hdev->ae_dev;\n\n\tae_dev->ops->set_default_reset_request(ae_dev, HNAE3_GLOBAL_RESET);\n\tdev_warn(&hdev->pdev->dev, \"requesting reset due to NCSI error\\n\");\n\tae_dev->ops->reset_event(hdev->pdev, NULL);\n}\n\nstatic void hclge_handle_vf_tbl(struct hclge_vport *vport,\n\t\t\t\tstruct hclge_mbx_vf_to_pf_cmd *mbx_req)\n{\n\tstruct hclge_dev *hdev = vport->back;\n\tstruct hclge_vf_vlan_cfg *msg_cmd;\n\n\tmsg_cmd = (struct hclge_vf_vlan_cfg *)&mbx_req->msg;\n\tif (msg_cmd->subcode == HCLGE_MBX_VPORT_LIST_CLEAR) {\n\t\thclge_rm_vport_all_mac_table(vport, true, HCLGE_MAC_ADDR_UC);\n\t\thclge_rm_vport_all_mac_table(vport, true, HCLGE_MAC_ADDR_MC);\n\t\thclge_rm_vport_all_vlan_table(vport, true);\n\t} else {\n\t\tdev_warn(&hdev->pdev->dev, \"Invalid cmd(%u)\\n\",\n\t\t\t msg_cmd->subcode);\n\t}\n}\n\nstatic int\nhclge_mbx_map_ring_to_vector_handler(struct hclge_mbx_ops_param *param)\n{\n\treturn hclge_map_unmap_ring_to_vf_vector(param->vport, true,\n\t\t\t\t\t\t param->req);\n}\n\nstatic int\nhclge_mbx_unmap_ring_to_vector_handler(struct hclge_mbx_ops_param *param)\n{\n\treturn hclge_map_unmap_ring_to_vf_vector(param->vport, false,\n\t\t\t\t\t\t param->req);\n}\n\nstatic int\nhclge_mbx_get_ring_vector_map_handler(struct hclge_mbx_ops_param *param)\n{\n\tint ret;\n\n\tret = hclge_get_vf_ring_vector_map(param->vport, param->req,\n\t\t\t\t\t   param->resp_msg);\n\tif (ret)\n\t\tdev_err(&param->vport->back->pdev->dev,\n\t\t\t\"PF fail(%d) to get VF ring vector map\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_mbx_set_promisc_mode_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_set_vf_promisc_mode(param->vport, param->req);\n\treturn 0;\n}\n\nstatic int hclge_mbx_set_unicast_handler(struct hclge_mbx_ops_param *param)\n{\n\tint ret;\n\n\tret = hclge_set_vf_uc_mac_addr(param->vport, param->req);\n\tif (ret)\n\t\tdev_err(&param->vport->back->pdev->dev,\n\t\t\t\"PF fail(%d) to set VF UC MAC Addr\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_mbx_set_multicast_handler(struct hclge_mbx_ops_param *param)\n{\n\tint ret;\n\n\tret = hclge_set_vf_mc_mac_addr(param->vport, param->req);\n\tif (ret)\n\t\tdev_err(&param->vport->back->pdev->dev,\n\t\t\t\"PF fail(%d) to set VF MC MAC Addr\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_mbx_set_vlan_handler(struct hclge_mbx_ops_param *param)\n{\n\tint ret;\n\n\tret = hclge_set_vf_vlan_cfg(param->vport, param->req, param->resp_msg);\n\tif (ret)\n\t\tdev_err(&param->vport->back->pdev->dev,\n\t\t\t\"PF failed(%d) to config VF's VLAN\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_mbx_set_alive_handler(struct hclge_mbx_ops_param *param)\n{\n\tint ret;\n\n\tret = hclge_set_vf_alive(param->vport, param->req);\n\tif (ret)\n\t\tdev_err(&param->vport->back->pdev->dev,\n\t\t\t\"PF failed(%d) to set VF's ALIVE\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_mbx_get_qinfo_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_get_vf_queue_info(param->vport, param->resp_msg);\n\treturn 0;\n}\n\nstatic int hclge_mbx_get_qdepth_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_get_vf_queue_depth(param->vport, param->resp_msg);\n\treturn 0;\n}\n\nstatic int hclge_mbx_get_basic_info_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_get_basic_info(param->vport, param->resp_msg);\n\treturn 0;\n}\n\nstatic int hclge_mbx_get_link_status_handler(struct hclge_mbx_ops_param *param)\n{\n\tint ret;\n\n\tret = hclge_push_vf_link_status(param->vport);\n\tif (ret)\n\t\tdev_err(&param->vport->back->pdev->dev,\n\t\t\t\"failed to inform link stat to VF, ret = %d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_mbx_queue_reset_handler(struct hclge_mbx_ops_param *param)\n{\n\treturn hclge_mbx_reset_vf_queue(param->vport, param->req,\n\t\t\t\t\tparam->resp_msg);\n}\n\nstatic int hclge_mbx_reset_handler(struct hclge_mbx_ops_param *param)\n{\n\treturn hclge_reset_vf(param->vport);\n}\n\nstatic int hclge_mbx_keep_alive_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_vf_keep_alive(param->vport);\n\treturn 0;\n}\n\nstatic int hclge_mbx_set_mtu_handler(struct hclge_mbx_ops_param *param)\n{\n\tint ret;\n\n\tret = hclge_set_vf_mtu(param->vport, param->req);\n\tif (ret)\n\t\tdev_err(&param->vport->back->pdev->dev,\n\t\t\t\"VF fail(%d) to set mtu\\n\", ret);\n\treturn ret;\n}\n\nstatic int hclge_mbx_get_qid_in_pf_handler(struct hclge_mbx_ops_param *param)\n{\n\treturn hclge_get_queue_id_in_pf(param->vport, param->req,\n\t\t\t\t\tparam->resp_msg);\n}\n\nstatic int hclge_mbx_get_rss_key_handler(struct hclge_mbx_ops_param *param)\n{\n\treturn hclge_get_rss_key(param->vport, param->req, param->resp_msg);\n}\n\nstatic int hclge_mbx_get_link_mode_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_get_link_mode(param->vport, param->req);\n\treturn 0;\n}\n\nstatic int\nhclge_mbx_get_vf_flr_status_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_rm_vport_all_mac_table(param->vport, false,\n\t\t\t\t     HCLGE_MAC_ADDR_UC);\n\thclge_rm_vport_all_mac_table(param->vport, false,\n\t\t\t\t     HCLGE_MAC_ADDR_MC);\n\thclge_rm_vport_all_vlan_table(param->vport, false);\n\treturn 0;\n}\n\nstatic int hclge_mbx_vf_uninit_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_rm_vport_all_mac_table(param->vport, true,\n\t\t\t\t     HCLGE_MAC_ADDR_UC);\n\thclge_rm_vport_all_mac_table(param->vport, true,\n\t\t\t\t     HCLGE_MAC_ADDR_MC);\n\thclge_rm_vport_all_vlan_table(param->vport, true);\n\tparam->vport->mps = 0;\n\treturn 0;\n}\n\nstatic int hclge_mbx_get_media_type_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_get_vf_media_type(param->vport, param->resp_msg);\n\treturn 0;\n}\n\nstatic int hclge_mbx_push_link_status_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_handle_link_change_event(param->vport->back, param->req);\n\treturn 0;\n}\n\nstatic int hclge_mbx_get_mac_addr_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_get_vf_mac_addr(param->vport, param->resp_msg);\n\treturn 0;\n}\n\nstatic int hclge_mbx_ncsi_error_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_handle_ncsi_error(param->vport->back);\n\treturn 0;\n}\n\nstatic int hclge_mbx_handle_vf_tbl_handler(struct hclge_mbx_ops_param *param)\n{\n\thclge_handle_vf_tbl(param->vport, param->req);\n\treturn 0;\n}\n\nstatic const hclge_mbx_ops_fn hclge_mbx_ops_list[HCLGE_MBX_OPCODE_MAX] = {\n\t[HCLGE_MBX_RESET]   = hclge_mbx_reset_handler,\n\t[HCLGE_MBX_SET_UNICAST] = hclge_mbx_set_unicast_handler,\n\t[HCLGE_MBX_SET_MULTICAST] = hclge_mbx_set_multicast_handler,\n\t[HCLGE_MBX_SET_VLAN] = hclge_mbx_set_vlan_handler,\n\t[HCLGE_MBX_MAP_RING_TO_VECTOR] = hclge_mbx_map_ring_to_vector_handler,\n\t[HCLGE_MBX_UNMAP_RING_TO_VECTOR] = hclge_mbx_unmap_ring_to_vector_handler,\n\t[HCLGE_MBX_SET_PROMISC_MODE] = hclge_mbx_set_promisc_mode_handler,\n\t[HCLGE_MBX_GET_QINFO] = hclge_mbx_get_qinfo_handler,\n\t[HCLGE_MBX_GET_QDEPTH] = hclge_mbx_get_qdepth_handler,\n\t[HCLGE_MBX_GET_BASIC_INFO] = hclge_mbx_get_basic_info_handler,\n\t[HCLGE_MBX_GET_RSS_KEY] = hclge_mbx_get_rss_key_handler,\n\t[HCLGE_MBX_GET_MAC_ADDR] = hclge_mbx_get_mac_addr_handler,\n\t[HCLGE_MBX_GET_LINK_STATUS] = hclge_mbx_get_link_status_handler,\n\t[HCLGE_MBX_QUEUE_RESET] = hclge_mbx_queue_reset_handler,\n\t[HCLGE_MBX_KEEP_ALIVE] = hclge_mbx_keep_alive_handler,\n\t[HCLGE_MBX_SET_ALIVE] = hclge_mbx_set_alive_handler,\n\t[HCLGE_MBX_SET_MTU] = hclge_mbx_set_mtu_handler,\n\t[HCLGE_MBX_GET_QID_IN_PF] = hclge_mbx_get_qid_in_pf_handler,\n\t[HCLGE_MBX_GET_LINK_MODE] = hclge_mbx_get_link_mode_handler,\n\t[HCLGE_MBX_GET_MEDIA_TYPE] = hclge_mbx_get_media_type_handler,\n\t[HCLGE_MBX_VF_UNINIT] = hclge_mbx_vf_uninit_handler,\n\t[HCLGE_MBX_HANDLE_VF_TBL] = hclge_mbx_handle_vf_tbl_handler,\n\t[HCLGE_MBX_GET_RING_VECTOR_MAP] = hclge_mbx_get_ring_vector_map_handler,\n\t[HCLGE_MBX_GET_VF_FLR_STATUS] = hclge_mbx_get_vf_flr_status_handler,\n\t[HCLGE_MBX_PUSH_LINK_STATUS] = hclge_mbx_push_link_status_handler,\n\t[HCLGE_MBX_NCSI_ERROR] = hclge_mbx_ncsi_error_handler,\n};\n\nstatic void hclge_mbx_request_handling(struct hclge_mbx_ops_param *param)\n{\n\thclge_mbx_ops_fn cmd_func = NULL;\n\tstruct hclge_dev *hdev;\n\tint ret = 0;\n\n\thdev = param->vport->back;\n\tcmd_func = hclge_mbx_ops_list[param->req->msg.code];\n\tif (cmd_func)\n\t\tret = cmd_func(param);\n\telse\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"un-supported mailbox message, code = %u\\n\",\n\t\t\tparam->req->msg.code);\n\n\t \n\tif (hnae3_get_bit(param->req->mbx_need_resp, HCLGE_MBX_NEED_RESP_B) &&\n\t    param->req->msg.code < HCLGE_MBX_GET_VF_FLR_STATUS) {\n\t\tparam->resp_msg->status = ret;\n\t\tif (time_is_before_jiffies(hdev->last_mbx_scheduled +\n\t\t\t\t\t   HCLGE_MBX_SCHED_TIMEOUT))\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"resp vport%u mbx(%u,%u) late\\n\",\n\t\t\t\t param->req->mbx_src_vfid,\n\t\t\t\t param->req->msg.code,\n\t\t\t\t param->req->msg.subcode);\n\n\t\thclge_gen_resp_to_vf(param->vport, param->req, param->resp_msg);\n\t}\n}\n\nvoid hclge_mbx_handler(struct hclge_dev *hdev)\n{\n\tstruct hclge_comm_cmq_ring *crq = &hdev->hw.hw.cmq.crq;\n\tstruct hclge_respond_to_vf_msg resp_msg;\n\tstruct hclge_mbx_vf_to_pf_cmd *req;\n\tstruct hclge_mbx_ops_param param;\n\tstruct hclge_desc *desc;\n\tunsigned int flag;\n\n\tparam.resp_msg = &resp_msg;\n\t \n\twhile (!hclge_cmd_crq_empty(&hdev->hw)) {\n\t\tif (test_bit(HCLGE_COMM_STATE_CMD_DISABLE,\n\t\t\t     &hdev->hw.hw.comm_state)) {\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"command queue needs re-initializing\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tdesc = &crq->desc[crq->next_to_use];\n\t\treq = (struct hclge_mbx_vf_to_pf_cmd *)desc->data;\n\n\t\tflag = le16_to_cpu(crq->desc[crq->next_to_use].flag);\n\t\tif (unlikely(!hnae3_get_bit(flag, HCLGE_CMDQ_RX_OUTVLD_B))) {\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"dropped invalid mailbox message, code = %u\\n\",\n\t\t\t\t req->msg.code);\n\n\t\t\t \n\t\t\tcrq->desc[crq->next_to_use].flag = 0;\n\t\t\thclge_mbx_ring_ptr_move_crq(crq);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttrace_hclge_pf_mbx_get(hdev, req);\n\n\t\t \n\t\tmemset(&resp_msg, 0, sizeof(resp_msg));\n\t\tparam.vport = &hdev->vport[req->mbx_src_vfid];\n\t\tparam.req = req;\n\t\thclge_mbx_request_handling(&param);\n\n\t\tcrq->desc[crq->next_to_use].flag = 0;\n\t\thclge_mbx_ring_ptr_move_crq(crq);\n\t}\n\n\t \n\thclge_write_dev(&hdev->hw, HCLGE_COMM_NIC_CRQ_HEAD_REG,\n\t\t\tcrq->next_to_use);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}