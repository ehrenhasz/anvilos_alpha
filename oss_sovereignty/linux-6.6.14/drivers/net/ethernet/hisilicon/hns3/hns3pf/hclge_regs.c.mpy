{
  "module_name": "hclge_regs.c",
  "hash_id": "52697bd332d161acee04630805bf63136f05062f6d9dae2575846d7bec644f02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_regs.c",
  "human_readable_source": "\n\n\n#include \"hclge_cmd.h\"\n#include \"hclge_main.h\"\n#include \"hclge_regs.h\"\n#include \"hnae3.h\"\n\nstatic const u32 cmdq_reg_addr_list[] = {HCLGE_COMM_NIC_CSQ_BASEADDR_L_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CSQ_BASEADDR_H_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CSQ_DEPTH_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CSQ_TAIL_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CSQ_HEAD_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CRQ_BASEADDR_L_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CRQ_BASEADDR_H_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CRQ_DEPTH_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CRQ_TAIL_REG,\n\t\t\t\t\t HCLGE_COMM_NIC_CRQ_HEAD_REG,\n\t\t\t\t\t HCLGE_COMM_VECTOR0_CMDQ_SRC_REG,\n\t\t\t\t\t HCLGE_COMM_CMDQ_INTR_STS_REG,\n\t\t\t\t\t HCLGE_COMM_CMDQ_INTR_EN_REG,\n\t\t\t\t\t HCLGE_COMM_CMDQ_INTR_GEN_REG};\n\nstatic const u32 common_reg_addr_list[] = {HCLGE_MISC_VECTOR_REG_BASE,\n\t\t\t\t\t   HCLGE_PF_OTHER_INT_REG,\n\t\t\t\t\t   HCLGE_MISC_RESET_STS_REG,\n\t\t\t\t\t   HCLGE_MISC_VECTOR_INT_STS,\n\t\t\t\t\t   HCLGE_GLOBAL_RESET_REG,\n\t\t\t\t\t   HCLGE_FUN_RST_ING,\n\t\t\t\t\t   HCLGE_GRO_EN_REG};\n\nstatic const u32 ring_reg_addr_list[] = {HCLGE_RING_RX_ADDR_L_REG,\n\t\t\t\t\t HCLGE_RING_RX_ADDR_H_REG,\n\t\t\t\t\t HCLGE_RING_RX_BD_NUM_REG,\n\t\t\t\t\t HCLGE_RING_RX_BD_LENGTH_REG,\n\t\t\t\t\t HCLGE_RING_RX_MERGE_EN_REG,\n\t\t\t\t\t HCLGE_RING_RX_TAIL_REG,\n\t\t\t\t\t HCLGE_RING_RX_HEAD_REG,\n\t\t\t\t\t HCLGE_RING_RX_FBD_NUM_REG,\n\t\t\t\t\t HCLGE_RING_RX_OFFSET_REG,\n\t\t\t\t\t HCLGE_RING_RX_FBD_OFFSET_REG,\n\t\t\t\t\t HCLGE_RING_RX_STASH_REG,\n\t\t\t\t\t HCLGE_RING_RX_BD_ERR_REG,\n\t\t\t\t\t HCLGE_RING_TX_ADDR_L_REG,\n\t\t\t\t\t HCLGE_RING_TX_ADDR_H_REG,\n\t\t\t\t\t HCLGE_RING_TX_BD_NUM_REG,\n\t\t\t\t\t HCLGE_RING_TX_PRIORITY_REG,\n\t\t\t\t\t HCLGE_RING_TX_TC_REG,\n\t\t\t\t\t HCLGE_RING_TX_MERGE_EN_REG,\n\t\t\t\t\t HCLGE_RING_TX_TAIL_REG,\n\t\t\t\t\t HCLGE_RING_TX_HEAD_REG,\n\t\t\t\t\t HCLGE_RING_TX_FBD_NUM_REG,\n\t\t\t\t\t HCLGE_RING_TX_OFFSET_REG,\n\t\t\t\t\t HCLGE_RING_TX_EBD_NUM_REG,\n\t\t\t\t\t HCLGE_RING_TX_EBD_OFFSET_REG,\n\t\t\t\t\t HCLGE_RING_TX_BD_ERR_REG,\n\t\t\t\t\t HCLGE_RING_EN_REG};\n\nstatic const u32 tqp_intr_reg_addr_list[] = {HCLGE_TQP_INTR_CTRL_REG,\n\t\t\t\t\t     HCLGE_TQP_INTR_GL0_REG,\n\t\t\t\t\t     HCLGE_TQP_INTR_GL1_REG,\n\t\t\t\t\t     HCLGE_TQP_INTR_GL2_REG,\n\t\t\t\t\t     HCLGE_TQP_INTR_RL_REG};\n\n \n#define HCLGE_DFX_BIOS_BD_OFFSET        1\n#define HCLGE_DFX_SSU_0_BD_OFFSET       2\n#define HCLGE_DFX_SSU_1_BD_OFFSET       3\n#define HCLGE_DFX_IGU_BD_OFFSET         4\n#define HCLGE_DFX_RPU_0_BD_OFFSET       5\n#define HCLGE_DFX_RPU_1_BD_OFFSET       6\n#define HCLGE_DFX_NCSI_BD_OFFSET        7\n#define HCLGE_DFX_RTC_BD_OFFSET         8\n#define HCLGE_DFX_PPP_BD_OFFSET         9\n#define HCLGE_DFX_RCB_BD_OFFSET         10\n#define HCLGE_DFX_TQP_BD_OFFSET         11\n#define HCLGE_DFX_SSU_2_BD_OFFSET       12\n\nstatic const u32 hclge_dfx_bd_offset_list[] = {\n\tHCLGE_DFX_BIOS_BD_OFFSET,\n\tHCLGE_DFX_SSU_0_BD_OFFSET,\n\tHCLGE_DFX_SSU_1_BD_OFFSET,\n\tHCLGE_DFX_IGU_BD_OFFSET,\n\tHCLGE_DFX_RPU_0_BD_OFFSET,\n\tHCLGE_DFX_RPU_1_BD_OFFSET,\n\tHCLGE_DFX_NCSI_BD_OFFSET,\n\tHCLGE_DFX_RTC_BD_OFFSET,\n\tHCLGE_DFX_PPP_BD_OFFSET,\n\tHCLGE_DFX_RCB_BD_OFFSET,\n\tHCLGE_DFX_TQP_BD_OFFSET,\n\tHCLGE_DFX_SSU_2_BD_OFFSET\n};\n\nstatic const enum hclge_opcode_type hclge_dfx_reg_opcode_list[] = {\n\tHCLGE_OPC_DFX_BIOS_COMMON_REG,\n\tHCLGE_OPC_DFX_SSU_REG_0,\n\tHCLGE_OPC_DFX_SSU_REG_1,\n\tHCLGE_OPC_DFX_IGU_EGU_REG,\n\tHCLGE_OPC_DFX_RPU_REG_0,\n\tHCLGE_OPC_DFX_RPU_REG_1,\n\tHCLGE_OPC_DFX_NCSI_REG,\n\tHCLGE_OPC_DFX_RTC_REG,\n\tHCLGE_OPC_DFX_PPP_REG,\n\tHCLGE_OPC_DFX_RCB_REG,\n\tHCLGE_OPC_DFX_TQP_REG,\n\tHCLGE_OPC_DFX_SSU_REG_2\n};\n\nenum hclge_reg_tag {\n\tHCLGE_REG_TAG_CMDQ = 0,\n\tHCLGE_REG_TAG_COMMON,\n\tHCLGE_REG_TAG_RING,\n\tHCLGE_REG_TAG_TQP_INTR,\n\tHCLGE_REG_TAG_QUERY_32_BIT,\n\tHCLGE_REG_TAG_QUERY_64_BIT,\n\tHCLGE_REG_TAG_DFX_BIOS_COMMON,\n\tHCLGE_REG_TAG_DFX_SSU_0,\n\tHCLGE_REG_TAG_DFX_SSU_1,\n\tHCLGE_REG_TAG_DFX_IGU_EGU,\n\tHCLGE_REG_TAG_DFX_RPU_0,\n\tHCLGE_REG_TAG_DFX_RPU_1,\n\tHCLGE_REG_TAG_DFX_NCSI,\n\tHCLGE_REG_TAG_DFX_RTC,\n\tHCLGE_REG_TAG_DFX_PPP,\n\tHCLGE_REG_TAG_DFX_RCB,\n\tHCLGE_REG_TAG_DFX_TQP,\n\tHCLGE_REG_TAG_DFX_SSU_2,\n\tHCLGE_REG_TAG_RPU_TNL,\n};\n\n#pragma pack(4)\nstruct hclge_reg_tlv {\n\tu16 tag;\n\tu16 len;\n};\n\nstruct hclge_reg_header {\n\tu64 magic_number;\n\tu8 is_vf;\n\tu8 rsv[7];\n};\n\n#pragma pack()\n\n#define HCLGE_REG_TLV_SIZE\tsizeof(struct hclge_reg_tlv)\n#define HCLGE_REG_HEADER_SIZE\tsizeof(struct hclge_reg_header)\n#define HCLGE_REG_TLV_SPACE\t(sizeof(struct hclge_reg_tlv) / sizeof(u32))\n#define HCLGE_REG_HEADER_SPACE\t(sizeof(struct hclge_reg_header) / sizeof(u32))\n#define HCLGE_REG_MAGIC_NUMBER\t0x686e733372656773  \n\n#define HCLGE_REG_RPU_TNL_ID_0\t1\n\nstatic u32 hclge_reg_get_header(void *data)\n{\n\tstruct hclge_reg_header *header = data;\n\n\theader->magic_number = HCLGE_REG_MAGIC_NUMBER;\n\theader->is_vf = 0x0;\n\n\treturn HCLGE_REG_HEADER_SPACE;\n}\n\nstatic u32 hclge_reg_get_tlv(u32 tag, u32 regs_num, void *data)\n{\n\tstruct hclge_reg_tlv *tlv = data;\n\n\ttlv->tag = tag;\n\ttlv->len = regs_num * sizeof(u32) + HCLGE_REG_TLV_SIZE;\n\n\treturn HCLGE_REG_TLV_SPACE;\n}\n\nstatic int hclge_get_32_bit_regs(struct hclge_dev *hdev, u32 regs_num,\n\t\t\t\t void *data)\n{\n#define HCLGE_32_BIT_REG_RTN_DATANUM 8\n#define HCLGE_32_BIT_DESC_NODATA_LEN 2\n\n\tstruct hclge_desc *desc;\n\tu32 *reg_val = data;\n\t__le32 *desc_data;\n\tint nodata_num;\n\tint cmd_num;\n\tint i, k, n;\n\tint ret;\n\n\tif (regs_num == 0)\n\t\treturn 0;\n\n\tnodata_num = HCLGE_32_BIT_DESC_NODATA_LEN;\n\tcmd_num = DIV_ROUND_UP(regs_num + nodata_num,\n\t\t\t       HCLGE_32_BIT_REG_RTN_DATANUM);\n\tdesc = kcalloc(cmd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_QUERY_32_BIT_REG, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, cmd_num);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Query 32 bit register cmd failed, ret = %d.\\n\", ret);\n\t\tkfree(desc);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < cmd_num; i++) {\n\t\tif (i == 0) {\n\t\t\tdesc_data = (__le32 *)(&desc[i].data[0]);\n\t\t\tn = HCLGE_32_BIT_REG_RTN_DATANUM - nodata_num;\n\t\t} else {\n\t\t\tdesc_data = (__le32 *)(&desc[i]);\n\t\t\tn = HCLGE_32_BIT_REG_RTN_DATANUM;\n\t\t}\n\t\tfor (k = 0; k < n; k++) {\n\t\t\t*reg_val++ = le32_to_cpu(*desc_data++);\n\n\t\t\tregs_num--;\n\t\t\tif (!regs_num)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(desc);\n\treturn 0;\n}\n\nstatic int hclge_get_64_bit_regs(struct hclge_dev *hdev, u32 regs_num,\n\t\t\t\t void *data)\n{\n#define HCLGE_64_BIT_REG_RTN_DATANUM 4\n#define HCLGE_64_BIT_DESC_NODATA_LEN 1\n\n\tstruct hclge_desc *desc;\n\tu64 *reg_val = data;\n\t__le64 *desc_data;\n\tint nodata_len;\n\tint cmd_num;\n\tint i, k, n;\n\tint ret;\n\n\tif (regs_num == 0)\n\t\treturn 0;\n\n\tnodata_len = HCLGE_64_BIT_DESC_NODATA_LEN;\n\tcmd_num = DIV_ROUND_UP(regs_num + nodata_len,\n\t\t\t       HCLGE_64_BIT_REG_RTN_DATANUM);\n\tdesc = kcalloc(cmd_num, sizeof(struct hclge_desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\thclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_QUERY_64_BIT_REG, true);\n\tret = hclge_cmd_send(&hdev->hw, desc, cmd_num);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Query 64 bit register cmd failed, ret = %d.\\n\", ret);\n\t\tkfree(desc);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < cmd_num; i++) {\n\t\tif (i == 0) {\n\t\t\tdesc_data = (__le64 *)(&desc[i].data[0]);\n\t\t\tn = HCLGE_64_BIT_REG_RTN_DATANUM - nodata_len;\n\t\t} else {\n\t\t\tdesc_data = (__le64 *)(&desc[i]);\n\t\t\tn = HCLGE_64_BIT_REG_RTN_DATANUM;\n\t\t}\n\t\tfor (k = 0; k < n; k++) {\n\t\t\t*reg_val++ = le64_to_cpu(*desc_data++);\n\n\t\t\tregs_num--;\n\t\t\tif (!regs_num)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(desc);\n\treturn 0;\n}\n\nint hclge_query_bd_num_cmd_send(struct hclge_dev *hdev, struct hclge_desc *desc)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < HCLGE_GET_DFX_REG_TYPE_CNT - 1; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_DFX_BD_NUM,\n\t\t\t\t\t   true);\n\t\tdesc[i].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t}\n\n\t \n\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_DFX_BD_NUM, true);\n\n\treturn hclge_cmd_send(&hdev->hw, desc, HCLGE_GET_DFX_REG_TYPE_CNT);\n}\n\nstatic int hclge_get_dfx_reg_bd_num(struct hclge_dev *hdev,\n\t\t\t\t    int *bd_num_list,\n\t\t\t\t    u32 type_num)\n{\n\tu32 entries_per_desc, desc_index, index, offset, i;\n\tstruct hclge_desc desc[HCLGE_GET_DFX_REG_TYPE_CNT];\n\tint ret;\n\n\tret = hclge_query_bd_num_cmd_send(hdev, desc);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get dfx bd num fail, status is %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tentries_per_desc = ARRAY_SIZE(desc[0].data);\n\tfor (i = 0; i < type_num; i++) {\n\t\toffset = hclge_dfx_bd_offset_list[i];\n\t\tindex = offset % entries_per_desc;\n\t\tdesc_index = offset / entries_per_desc;\n\t\tbd_num_list[i] = le32_to_cpu(desc[desc_index].data[index]);\n\t}\n\n\treturn ret;\n}\n\nstatic int hclge_dfx_reg_cmd_send(struct hclge_dev *hdev,\n\t\t\t\t  struct hclge_desc *desc_src, int bd_num,\n\t\t\t\t  enum hclge_opcode_type cmd)\n{\n\tstruct hclge_desc *desc = desc_src;\n\tint i, ret;\n\n\thclge_cmd_setup_basic_desc(desc, cmd, true);\n\tfor (i = 0; i < bd_num - 1; i++) {\n\t\tdesc->flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t\tdesc++;\n\t\thclge_cmd_setup_basic_desc(desc, cmd, true);\n\t}\n\n\tdesc = desc_src;\n\tret = hclge_cmd_send(&hdev->hw, desc, bd_num);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Query dfx reg cmd(0x%x) send fail, status is %d.\\n\",\n\t\t\tcmd, ret);\n\n\treturn ret;\n}\n\n \nstatic int hclge_dfx_reg_rpu_tnl_cmd_send(struct hclge_dev *hdev, u32 tnl_id,\n\t\t\t\t\t  struct hclge_desc *desc, int bd_num)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < bd_num; i++) {\n\t\thclge_cmd_setup_basic_desc(&desc[i], HCLGE_OPC_DFX_RPU_REG_0,\n\t\t\t\t\t   true);\n\t\tif (i != bd_num - 1)\n\t\t\tdesc[i].flag |= cpu_to_le16(HCLGE_COMM_CMD_FLAG_NEXT);\n\t}\n\n\tdesc[0].data[0] = cpu_to_le32(tnl_id);\n\tret = hclge_cmd_send(&hdev->hw, desc, bd_num);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to query dfx rpu tnl reg, ret = %d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hclge_dfx_reg_fetch_data(struct hclge_desc *desc_src, int bd_num,\n\t\t\t\t    void *data)\n{\n\tint entries_per_desc, reg_num, desc_index, index, i;\n\tstruct hclge_desc *desc = desc_src;\n\tu32 *reg = data;\n\n\tentries_per_desc = ARRAY_SIZE(desc->data);\n\treg_num = entries_per_desc * bd_num;\n\tfor (i = 0; i < reg_num; i++) {\n\t\tindex = i % entries_per_desc;\n\t\tdesc_index = i / entries_per_desc;\n\t\t*reg++ = le32_to_cpu(desc[desc_index].data[index]);\n\t}\n\n\treturn reg_num;\n}\n\nstatic int hclge_get_dfx_reg_len(struct hclge_dev *hdev, int *len)\n{\n\tu32 dfx_reg_type_num = ARRAY_SIZE(hclge_dfx_bd_offset_list);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tint data_len_per_desc;\n\tint *bd_num_list;\n\tint ret;\n\tu32 i;\n\n\tbd_num_list = kcalloc(dfx_reg_type_num, sizeof(int), GFP_KERNEL);\n\tif (!bd_num_list)\n\t\treturn -ENOMEM;\n\n\tret = hclge_get_dfx_reg_bd_num(hdev, bd_num_list, dfx_reg_type_num);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get dfx reg bd num fail, status is %d.\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tdata_len_per_desc = sizeof_field(struct hclge_desc, data);\n\t*len = 0;\n\tfor (i = 0; i < dfx_reg_type_num; i++)\n\t\t*len += bd_num_list[i] * data_len_per_desc + HCLGE_REG_TLV_SIZE;\n\n\t \n\t*len += (bd_num_list[HCLGE_DFX_RPU_0_BD_OFFSET - 1] * data_len_per_desc +\n\t\t HCLGE_REG_TLV_SIZE) * ae_dev->dev_specs.tnl_num;\n\nout:\n\tkfree(bd_num_list);\n\treturn ret;\n}\n\nstatic int hclge_get_dfx_rpu_tnl_reg(struct hclge_dev *hdev, u32 *reg,\n\t\t\t\t     struct hclge_desc *desc_src,\n\t\t\t\t     int bd_num)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);\n\tint ret = 0;\n\tu8 i;\n\n\tfor (i = HCLGE_REG_RPU_TNL_ID_0; i <= ae_dev->dev_specs.tnl_num; i++) {\n\t\tret = hclge_dfx_reg_rpu_tnl_cmd_send(hdev, i, desc_src, bd_num);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_RPU_TNL,\n\t\t\t\t\t ARRAY_SIZE(desc_src->data) * bd_num,\n\t\t\t\t\t reg);\n\t\treg += hclge_dfx_reg_fetch_data(desc_src, bd_num, reg);\n\t}\n\n\treturn ret;\n}\n\nstatic int hclge_get_dfx_reg(struct hclge_dev *hdev, void *data)\n{\n\tu32 dfx_reg_type_num = ARRAY_SIZE(hclge_dfx_bd_offset_list);\n\tint bd_num, bd_num_max, buf_len;\n\tstruct hclge_desc *desc_src;\n\tint *bd_num_list;\n\tu32 *reg = data;\n\tint ret;\n\tu32 i;\n\n\tbd_num_list = kcalloc(dfx_reg_type_num, sizeof(int), GFP_KERNEL);\n\tif (!bd_num_list)\n\t\treturn -ENOMEM;\n\n\tret = hclge_get_dfx_reg_bd_num(hdev, bd_num_list, dfx_reg_type_num);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get dfx reg bd num fail, status is %d.\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tbd_num_max = bd_num_list[0];\n\tfor (i = 1; i < dfx_reg_type_num; i++)\n\t\tbd_num_max = max_t(int, bd_num_max, bd_num_list[i]);\n\n\tbuf_len = sizeof(*desc_src) * bd_num_max;\n\tdesc_src = kzalloc(buf_len, GFP_KERNEL);\n\tif (!desc_src) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < dfx_reg_type_num; i++) {\n\t\tbd_num = bd_num_list[i];\n\t\tret = hclge_dfx_reg_cmd_send(hdev, desc_src, bd_num,\n\t\t\t\t\t     hclge_dfx_reg_opcode_list[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"Get dfx reg fail, status is %d.\\n\", ret);\n\t\t\tgoto free;\n\t\t}\n\n\t\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_DFX_BIOS_COMMON + i,\n\t\t\t\t\t ARRAY_SIZE(desc_src->data) * bd_num,\n\t\t\t\t\t reg);\n\t\treg += hclge_dfx_reg_fetch_data(desc_src, bd_num, reg);\n\t}\n\n\t \n\tbd_num = bd_num_list[HCLGE_DFX_RPU_0_BD_OFFSET - 1];\n\tret = hclge_get_dfx_rpu_tnl_reg(hdev, reg, desc_src, bd_num);\n\nfree:\n\tkfree(desc_src);\nout:\n\tkfree(bd_num_list);\n\treturn ret;\n}\n\nstatic int hclge_fetch_pf_reg(struct hclge_dev *hdev, void *data,\n\t\t\t      struct hnae3_knic_private_info *kinfo)\n{\n#define HCLGE_RING_REG_OFFSET\t\t0x200\n#define HCLGE_RING_INT_REG_OFFSET\t0x4\n\n\tint i, j, reg_num;\n\tint data_num_sum;\n\tu32 *reg = data;\n\n\t \n\treg_num = ARRAY_SIZE(cmdq_reg_addr_list);\n\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_CMDQ, reg_num, reg);\n\tfor (i = 0; i < reg_num; i++)\n\t\t*reg++ = hclge_read_dev(&hdev->hw, cmdq_reg_addr_list[i]);\n\tdata_num_sum = reg_num + HCLGE_REG_TLV_SPACE;\n\n\treg_num = ARRAY_SIZE(common_reg_addr_list);\n\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_COMMON, reg_num, reg);\n\tfor (i = 0; i < reg_num; i++)\n\t\t*reg++ = hclge_read_dev(&hdev->hw, common_reg_addr_list[i]);\n\tdata_num_sum += reg_num + HCLGE_REG_TLV_SPACE;\n\n\treg_num = ARRAY_SIZE(ring_reg_addr_list);\n\tfor (j = 0; j < kinfo->num_tqps; j++) {\n\t\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_RING, reg_num, reg);\n\t\tfor (i = 0; i < reg_num; i++)\n\t\t\t*reg++ = hclge_read_dev(&hdev->hw,\n\t\t\t\t\t\tring_reg_addr_list[i] +\n\t\t\t\t\t\tHCLGE_RING_REG_OFFSET * j);\n\t}\n\tdata_num_sum += (reg_num + HCLGE_REG_TLV_SPACE) * kinfo->num_tqps;\n\n\treg_num = ARRAY_SIZE(tqp_intr_reg_addr_list);\n\tfor (j = 0; j < hdev->num_msi_used - 1; j++) {\n\t\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_TQP_INTR, reg_num, reg);\n\t\tfor (i = 0; i < reg_num; i++)\n\t\t\t*reg++ = hclge_read_dev(&hdev->hw,\n\t\t\t\t\t\ttqp_intr_reg_addr_list[i] +\n\t\t\t\t\t\tHCLGE_RING_INT_REG_OFFSET * j);\n\t}\n\tdata_num_sum += (reg_num + HCLGE_REG_TLV_SPACE) *\n\t\t\t(hdev->num_msi_used - 1);\n\n\treturn data_num_sum;\n}\n\nstatic int hclge_get_regs_num(struct hclge_dev *hdev, u32 *regs_num_32_bit,\n\t\t\t      u32 *regs_num_64_bit)\n{\n\tstruct hclge_desc desc;\n\tu32 total_num;\n\tint ret;\n\n\thclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_QUERY_REG_NUM, true);\n\tret = hclge_cmd_send(&hdev->hw, &desc, 1);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Query register number cmd failed, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*regs_num_32_bit = le32_to_cpu(desc.data[0]);\n\t*regs_num_64_bit = le32_to_cpu(desc.data[1]);\n\n\ttotal_num = *regs_num_32_bit + *regs_num_64_bit;\n\tif (!total_num)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint hclge_get_regs_len(struct hnae3_handle *handle)\n{\n\tstruct hnae3_knic_private_info *kinfo = &handle->kinfo;\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tint regs_num_32_bit, regs_num_64_bit, dfx_regs_len;\n\tint cmdq_len, common_len, ring_len, tqp_intr_len;\n\tint regs_len_32_bit, regs_len_64_bit;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\n\tret = hclge_get_regs_num(hdev, &regs_num_32_bit, &regs_num_64_bit);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get register number failed, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hclge_get_dfx_reg_len(hdev, &dfx_regs_len);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get dfx reg len failed, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcmdq_len = HCLGE_REG_TLV_SIZE + sizeof(cmdq_reg_addr_list);\n\tcommon_len = HCLGE_REG_TLV_SIZE + sizeof(common_reg_addr_list);\n\tring_len = HCLGE_REG_TLV_SIZE + sizeof(ring_reg_addr_list);\n\ttqp_intr_len = HCLGE_REG_TLV_SIZE + sizeof(tqp_intr_reg_addr_list);\n\tregs_len_32_bit = HCLGE_REG_TLV_SIZE + regs_num_32_bit * sizeof(u32);\n\tregs_len_64_bit = HCLGE_REG_TLV_SIZE + regs_num_64_bit * sizeof(u64);\n\n\t \n\treturn HCLGE_REG_HEADER_SIZE + cmdq_len + common_len + ring_len *\n\t\tkinfo->num_tqps + tqp_intr_len * (hdev->num_msi_used - 1) +\n\t\tregs_len_32_bit + regs_len_64_bit + dfx_regs_len;\n}\n\nvoid hclge_get_regs(struct hnae3_handle *handle, u32 *version,\n\t\t    void *data)\n{\n#define HCLGE_REG_64_BIT_SPACE_MULTIPLE\t\t2\n\n\tstruct hnae3_knic_private_info *kinfo = &handle->kinfo;\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tu32 regs_num_32_bit, regs_num_64_bit;\n\tu32 *reg = data;\n\tint ret;\n\n\t*version = hdev->fw_version;\n\n\tret = hclge_get_regs_num(hdev, &regs_num_32_bit, &regs_num_64_bit);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get register number failed, ret = %d.\\n\", ret);\n\t\treturn;\n\t}\n\n\treg += hclge_reg_get_header(reg);\n\treg += hclge_fetch_pf_reg(hdev, reg, kinfo);\n\n\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_QUERY_32_BIT,\n\t\t\t\t regs_num_32_bit, reg);\n\tret = hclge_get_32_bit_regs(hdev, regs_num_32_bit, reg);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get 32 bit register failed, ret = %d.\\n\", ret);\n\t\treturn;\n\t}\n\treg += regs_num_32_bit;\n\n\treg += hclge_reg_get_tlv(HCLGE_REG_TAG_QUERY_64_BIT,\n\t\t\t\t regs_num_64_bit *\n\t\t\t\t HCLGE_REG_64_BIT_SPACE_MULTIPLE, reg);\n\tret = hclge_get_64_bit_regs(hdev, regs_num_64_bit, reg);\n\tif (ret) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get 64 bit register failed, ret = %d.\\n\", ret);\n\t\treturn;\n\t}\n\treg += regs_num_64_bit * HCLGE_REG_64_BIT_SPACE_MULTIPLE;\n\n\tret = hclge_get_dfx_reg(hdev, reg);\n\tif (ret)\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"Get dfx register failed, ret = %d.\\n\", ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}