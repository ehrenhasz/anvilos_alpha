{
  "module_name": "hns3_ethtool.c",
  "hash_id": "0e57ba2203f4cf15ad408d30f9055b4f20412a6c6ab3058e040bf936478f57dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3_ethtool.c",
  "human_readable_source": "\n\n\n#include <linux/etherdevice.h>\n#include <linux/string.h>\n#include <linux/phy.h>\n#include <linux/sfp.h>\n\n#include \"hns3_enet.h\"\n#include \"hns3_ethtool.h\"\n\n \n#define HNS3_TQP_STAT(_string, _member)\t{\t\t\t\\\n\t.stats_string = _string,\t\t\t\t\\\n\t.stats_offset = offsetof(struct hns3_enet_ring, stats) +\\\n\t\t\toffsetof(struct ring_stats, _member),   \\\n}\n\nstatic const struct hns3_stats hns3_txq_stats[] = {\n\t \n\tHNS3_TQP_STAT(\"dropped\", sw_err_cnt),\n\tHNS3_TQP_STAT(\"seg_pkt_cnt\", seg_pkt_cnt),\n\tHNS3_TQP_STAT(\"packets\", tx_pkts),\n\tHNS3_TQP_STAT(\"bytes\", tx_bytes),\n\tHNS3_TQP_STAT(\"more\", tx_more),\n\tHNS3_TQP_STAT(\"push\", tx_push),\n\tHNS3_TQP_STAT(\"mem_doorbell\", tx_mem_doorbell),\n\tHNS3_TQP_STAT(\"wake\", restart_queue),\n\tHNS3_TQP_STAT(\"busy\", tx_busy),\n\tHNS3_TQP_STAT(\"copy\", tx_copy),\n\tHNS3_TQP_STAT(\"vlan_err\", tx_vlan_err),\n\tHNS3_TQP_STAT(\"l4_proto_err\", tx_l4_proto_err),\n\tHNS3_TQP_STAT(\"l2l3l4_err\", tx_l2l3l4_err),\n\tHNS3_TQP_STAT(\"tso_err\", tx_tso_err),\n\tHNS3_TQP_STAT(\"over_max_recursion\", over_max_recursion),\n\tHNS3_TQP_STAT(\"hw_limitation\", hw_limitation),\n\tHNS3_TQP_STAT(\"bounce\", tx_bounce),\n\tHNS3_TQP_STAT(\"spare_full\", tx_spare_full),\n\tHNS3_TQP_STAT(\"copy_bits_err\", copy_bits_err),\n\tHNS3_TQP_STAT(\"sgl\", tx_sgl),\n\tHNS3_TQP_STAT(\"skb2sgl_err\", skb2sgl_err),\n\tHNS3_TQP_STAT(\"map_sg_err\", map_sg_err),\n};\n\n#define HNS3_TXQ_STATS_COUNT ARRAY_SIZE(hns3_txq_stats)\n\nstatic const struct hns3_stats hns3_rxq_stats[] = {\n\t \n\tHNS3_TQP_STAT(\"dropped\", sw_err_cnt),\n\tHNS3_TQP_STAT(\"seg_pkt_cnt\", seg_pkt_cnt),\n\tHNS3_TQP_STAT(\"packets\", rx_pkts),\n\tHNS3_TQP_STAT(\"bytes\", rx_bytes),\n\tHNS3_TQP_STAT(\"errors\", rx_err_cnt),\n\tHNS3_TQP_STAT(\"reuse_pg_cnt\", reuse_pg_cnt),\n\tHNS3_TQP_STAT(\"err_pkt_len\", err_pkt_len),\n\tHNS3_TQP_STAT(\"err_bd_num\", err_bd_num),\n\tHNS3_TQP_STAT(\"l2_err\", l2_err),\n\tHNS3_TQP_STAT(\"l3l4_csum_err\", l3l4_csum_err),\n\tHNS3_TQP_STAT(\"csum_complete\", csum_complete),\n\tHNS3_TQP_STAT(\"multicast\", rx_multicast),\n\tHNS3_TQP_STAT(\"non_reuse_pg\", non_reuse_pg),\n\tHNS3_TQP_STAT(\"frag_alloc_err\", frag_alloc_err),\n\tHNS3_TQP_STAT(\"frag_alloc\", frag_alloc),\n};\n\n#define HNS3_PRIV_FLAGS_LEN ARRAY_SIZE(hns3_priv_flags)\n\n#define HNS3_RXQ_STATS_COUNT ARRAY_SIZE(hns3_rxq_stats)\n\n#define HNS3_TQP_STATS_COUNT (HNS3_TXQ_STATS_COUNT + HNS3_RXQ_STATS_COUNT)\n\n#define HNS3_NIC_LB_TEST_PKT_NUM\t1\n#define HNS3_NIC_LB_TEST_RING_ID\t0\n#define HNS3_NIC_LB_TEST_PACKET_SIZE\t128\n#define HNS3_NIC_LB_SETUP_USEC\t\t10000\n\n \n#define HNS3_NIC_LB_TEST_NO_MEM_ERR\t1\n#define HNS3_NIC_LB_TEST_TX_CNT_ERR\t2\n#define HNS3_NIC_LB_TEST_RX_CNT_ERR\t3\n\nstatic int hns3_lp_setup(struct net_device *ndev, enum hnae3_loop loop, bool en)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(ndev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tint ret;\n\n\tif (!h->ae_algo->ops->set_loopback ||\n\t    !h->ae_algo->ops->set_promisc_mode)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (loop) {\n\tcase HNAE3_LOOP_SERIAL_SERDES:\n\tcase HNAE3_LOOP_PARALLEL_SERDES:\n\tcase HNAE3_LOOP_APP:\n\tcase HNAE3_LOOP_PHY:\n\tcase HNAE3_LOOP_EXTERNAL:\n\t\tret = h->ae_algo->ops->set_loopback(h, loop, en);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (ret || ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2)\n\t\treturn ret;\n\n\tif (en)\n\t\th->ae_algo->ops->set_promisc_mode(h, true, true);\n\telse\n\t\t \n\t\thns3_request_update_promisc_mode(h);\n\n\treturn ret;\n}\n\nstatic int hns3_lp_up(struct net_device *ndev, enum hnae3_loop loop_mode)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(ndev);\n\tint ret;\n\n\tret = hns3_nic_reset_all_ring(h);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_lp_setup(ndev, loop_mode, true);\n\tusleep_range(HNS3_NIC_LB_SETUP_USEC, HNS3_NIC_LB_SETUP_USEC * 2);\n\n\treturn ret;\n}\n\nstatic int hns3_lp_down(struct net_device *ndev, enum hnae3_loop loop_mode)\n{\n\tint ret;\n\n\tret = hns3_lp_setup(ndev, loop_mode, false);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"lb_setup return error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(HNS3_NIC_LB_SETUP_USEC, HNS3_NIC_LB_SETUP_USEC * 2);\n\n\treturn 0;\n}\n\nstatic void hns3_lp_setup_skb(struct sk_buff *skb)\n{\n#define\tHNS3_NIC_LB_DST_MAC_ADDR\t0x1f\n\n\tstruct net_device *ndev = skb->dev;\n\tstruct hnae3_handle *handle;\n\tstruct hnae3_ae_dev *ae_dev;\n\tunsigned char *packet;\n\tstruct ethhdr *ethh;\n\tunsigned int i;\n\n\tskb_reserve(skb, NET_IP_ALIGN);\n\tethh = skb_put(skb, sizeof(struct ethhdr));\n\tpacket = skb_put(skb, HNS3_NIC_LB_TEST_PACKET_SIZE);\n\n\tmemcpy(ethh->h_dest, ndev->dev_addr, ETH_ALEN);\n\n\t \n\thandle = hns3_get_handle(ndev);\n\tae_dev = pci_get_drvdata(handle->pdev);\n\tif (ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\tethh->h_dest[5] += HNS3_NIC_LB_DST_MAC_ADDR;\n\teth_zero_addr(ethh->h_source);\n\tethh->h_proto = htons(ETH_P_ARP);\n\tskb_reset_mac_header(skb);\n\n\tfor (i = 0; i < HNS3_NIC_LB_TEST_PACKET_SIZE; i++)\n\t\tpacket[i] = (unsigned char)(i & 0xff);\n}\n\nstatic void hns3_lb_check_skb_data(struct hns3_enet_ring *ring,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hns3_enet_tqp_vector *tqp_vector = ring->tqp_vector;\n\tunsigned char *packet = skb->data;\n\tu32 len = skb_headlen(skb);\n\tu32 i;\n\n\tlen = min_t(u32, len, HNS3_NIC_LB_TEST_PACKET_SIZE);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (packet[i] != (unsigned char)(i & 0xff))\n\t\t\tbreak;\n\n\t \n\tif (i == HNS3_NIC_LB_TEST_PACKET_SIZE)\n\t\ttqp_vector->rx_group.total_packets++;\n\telse\n\t\tprint_hex_dump(KERN_ERR, \"selftest:\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       skb->data, len, true);\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic u32 hns3_lb_check_rx_ring(struct hns3_nic_priv *priv, u32 budget)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tstruct hnae3_knic_private_info *kinfo;\n\tu32 i, rcv_good_pkt_total = 0;\n\n\tkinfo = &h->kinfo;\n\tfor (i = kinfo->num_tqps; i < kinfo->num_tqps * 2; i++) {\n\t\tstruct hns3_enet_ring *ring = &priv->ring[i];\n\t\tstruct hns3_enet_ring_group *rx_group;\n\t\tu64 pre_rx_pkt;\n\n\t\trx_group = &ring->tqp_vector->rx_group;\n\t\tpre_rx_pkt = rx_group->total_packets;\n\n\t\tpreempt_disable();\n\t\thns3_clean_rx_ring(ring, budget, hns3_lb_check_skb_data);\n\t\tpreempt_enable();\n\n\t\trcv_good_pkt_total += (rx_group->total_packets - pre_rx_pkt);\n\t\trx_group->total_packets = pre_rx_pkt;\n\t}\n\treturn rcv_good_pkt_total;\n}\n\nstatic void hns3_lb_clear_tx_ring(struct hns3_nic_priv *priv, u32 start_ringid,\n\t\t\t\t  u32 end_ringid)\n{\n\tu32 i;\n\n\tfor (i = start_ringid; i <= end_ringid; i++) {\n\t\tstruct hns3_enet_ring *ring = &priv->ring[i];\n\n\t\thns3_clean_tx_ring(ring, 0);\n\t}\n}\n\n \nstatic int hns3_lp_run_test(struct net_device *ndev, enum hnae3_loop mode)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tu32 i, good_cnt;\n\tint ret_val = 0;\n\n\tskb = alloc_skb(HNS3_NIC_LB_TEST_PACKET_SIZE + ETH_HLEN + NET_IP_ALIGN,\n\t\t\tGFP_KERNEL);\n\tif (!skb)\n\t\treturn HNS3_NIC_LB_TEST_NO_MEM_ERR;\n\n\tskb->dev = ndev;\n\thns3_lp_setup_skb(skb);\n\tskb->queue_mapping = HNS3_NIC_LB_TEST_RING_ID;\n\n\tgood_cnt = 0;\n\tfor (i = 0; i < HNS3_NIC_LB_TEST_PKT_NUM; i++) {\n\t\tnetdev_tx_t tx_ret;\n\n\t\tskb_get(skb);\n\t\ttx_ret = hns3_nic_net_xmit(skb, ndev);\n\t\tif (tx_ret == NETDEV_TX_OK) {\n\t\t\tgood_cnt++;\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t\tnetdev_err(ndev, \"hns3_lb_run_test xmit failed: %d\\n\",\n\t\t\t\t   tx_ret);\n\t\t}\n\t}\n\tif (good_cnt != HNS3_NIC_LB_TEST_PKT_NUM) {\n\t\tret_val = HNS3_NIC_LB_TEST_TX_CNT_ERR;\n\t\tnetdev_err(ndev, \"mode %d sent fail, cnt=0x%x, budget=0x%x\\n\",\n\t\t\t   mode, good_cnt, HNS3_NIC_LB_TEST_PKT_NUM);\n\t\tgoto out;\n\t}\n\n\t \n\tmsleep(200);\n\n\tgood_cnt = hns3_lb_check_rx_ring(priv, HNS3_NIC_LB_TEST_PKT_NUM);\n\tif (good_cnt != HNS3_NIC_LB_TEST_PKT_NUM) {\n\t\tret_val = HNS3_NIC_LB_TEST_RX_CNT_ERR;\n\t\tnetdev_err(ndev, \"mode %d recv fail, cnt=0x%x, budget=0x%x\\n\",\n\t\t\t   mode, good_cnt, HNS3_NIC_LB_TEST_PKT_NUM);\n\t}\n\nout:\n\thns3_lb_clear_tx_ring(priv, HNS3_NIC_LB_TEST_RING_ID,\n\t\t\t      HNS3_NIC_LB_TEST_RING_ID);\n\n\tkfree_skb(skb);\n\treturn ret_val;\n}\n\nstatic void hns3_set_selftest_param(struct hnae3_handle *h, int (*st_param)[2])\n{\n\tst_param[HNAE3_LOOP_EXTERNAL][0] = HNAE3_LOOP_EXTERNAL;\n\tst_param[HNAE3_LOOP_EXTERNAL][1] =\n\t\t\th->flags & HNAE3_SUPPORT_EXTERNAL_LOOPBACK;\n\n\tst_param[HNAE3_LOOP_APP][0] = HNAE3_LOOP_APP;\n\tst_param[HNAE3_LOOP_APP][1] =\n\t\t\th->flags & HNAE3_SUPPORT_APP_LOOPBACK;\n\n\tst_param[HNAE3_LOOP_SERIAL_SERDES][0] = HNAE3_LOOP_SERIAL_SERDES;\n\tst_param[HNAE3_LOOP_SERIAL_SERDES][1] =\n\t\t\th->flags & HNAE3_SUPPORT_SERDES_SERIAL_LOOPBACK;\n\n\tst_param[HNAE3_LOOP_PARALLEL_SERDES][0] =\n\t\t\tHNAE3_LOOP_PARALLEL_SERDES;\n\tst_param[HNAE3_LOOP_PARALLEL_SERDES][1] =\n\t\t\th->flags & HNAE3_SUPPORT_SERDES_PARALLEL_LOOPBACK;\n\n\tst_param[HNAE3_LOOP_PHY][0] = HNAE3_LOOP_PHY;\n\tst_param[HNAE3_LOOP_PHY][1] =\n\t\t\th->flags & HNAE3_SUPPORT_PHY_LOOPBACK;\n}\n\nstatic void hns3_selftest_prepare(struct net_device *ndev, bool if_running)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\n\tif (if_running)\n\t\tndev->netdev_ops->ndo_stop(ndev);\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\t \n\tif (h->ae_algo->ops->enable_vlan_filter &&\n\t    ndev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\th->ae_algo->ops->enable_vlan_filter(h, false);\n#endif\n\n\t \n\tif (h->ae_algo->ops->halt_autoneg)\n\t\th->ae_algo->ops->halt_autoneg(h, true);\n\n\tset_bit(HNS3_NIC_STATE_TESTING, &priv->state);\n}\n\nstatic void hns3_selftest_restore(struct net_device *ndev, bool if_running)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\n\tclear_bit(HNS3_NIC_STATE_TESTING, &priv->state);\n\n\tif (h->ae_algo->ops->halt_autoneg)\n\t\th->ae_algo->ops->halt_autoneg(h, false);\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\tif (h->ae_algo->ops->enable_vlan_filter &&\n\t    ndev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\th->ae_algo->ops->enable_vlan_filter(h, true);\n#endif\n\n\tif (if_running)\n\t\tndev->netdev_ops->ndo_open(ndev);\n}\n\nstatic void hns3_do_selftest(struct net_device *ndev, int (*st_param)[2],\n\t\t\t     struct ethtool_test *eth_test, u64 *data)\n{\n\tint test_index = HNAE3_LOOP_APP;\n\tu32 i;\n\n\tfor (i = HNAE3_LOOP_APP; i < HNAE3_LOOP_NONE; i++) {\n\t\tenum hnae3_loop loop_type = (enum hnae3_loop)st_param[i][0];\n\n\t\tif (!st_param[i][1])\n\t\t\tcontinue;\n\n\t\tdata[test_index] = hns3_lp_up(ndev, loop_type);\n\t\tif (!data[test_index])\n\t\t\tdata[test_index] = hns3_lp_run_test(ndev, loop_type);\n\n\t\thns3_lp_down(ndev, loop_type);\n\n\t\tif (data[test_index])\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\ttest_index++;\n\t}\n}\n\nstatic void hns3_do_external_lb(struct net_device *ndev,\n\t\t\t\tstruct ethtool_test *eth_test, u64 *data)\n{\n\tdata[HNAE3_LOOP_EXTERNAL] = hns3_lp_up(ndev, HNAE3_LOOP_EXTERNAL);\n\tif (!data[HNAE3_LOOP_EXTERNAL])\n\t\tdata[HNAE3_LOOP_EXTERNAL] = hns3_lp_run_test(ndev, HNAE3_LOOP_EXTERNAL);\n\thns3_lp_down(ndev, HNAE3_LOOP_EXTERNAL);\n\n\tif (data[HNAE3_LOOP_EXTERNAL])\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\teth_test->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\n}\n\n \nstatic void hns3_self_test(struct net_device *ndev,\n\t\t\t   struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint st_param[HNAE3_LOOP_NONE][2];\n\tbool if_running = netif_running(ndev);\n\n\tif (hns3_nic_resetting(ndev)) {\n\t\tnetdev_err(ndev, \"dev resetting!\");\n\t\treturn;\n\t}\n\n\tif (!(eth_test->flags & ETH_TEST_FL_OFFLINE))\n\t\treturn;\n\n\tif (netif_msg_ifdown(h))\n\t\tnetdev_info(ndev, \"self test start\\n\");\n\n\thns3_set_selftest_param(h, st_param);\n\n\t \n\tif (eth_test->flags & ETH_TEST_FL_EXTERNAL_LB) {\n\t\thns3_external_lb_prepare(ndev, if_running);\n\t\thns3_do_external_lb(ndev, eth_test, data);\n\t\thns3_external_lb_restore(ndev, if_running);\n\t}\n\n\thns3_selftest_prepare(ndev, if_running);\n\thns3_do_selftest(ndev, st_param, eth_test, data);\n\thns3_selftest_restore(ndev, if_running);\n\n\tif (netif_msg_ifdown(h))\n\t\tnetdev_info(ndev, \"self test end\\n\");\n}\n\nstatic void hns3_update_limit_promisc_mode(struct net_device *netdev,\n\t\t\t\t\t   bool enable)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\n\tif (enable)\n\t\tset_bit(HNAE3_PFLAG_LIMIT_PROMISC, &handle->priv_flags);\n\telse\n\t\tclear_bit(HNAE3_PFLAG_LIMIT_PROMISC, &handle->priv_flags);\n\n\thns3_request_update_promisc_mode(handle);\n}\n\nstatic const struct hns3_pflag_desc hns3_priv_flags[HNAE3_PFLAG_MAX] = {\n\t{ \"limit_promisc\",\thns3_update_limit_promisc_mode }\n};\n\nstatic int hns3_get_sset_count(struct net_device *netdev, int stringset)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tconst struct hnae3_ae_ops *ops = h->ae_algo->ops;\n\n\tif (!ops->get_sset_count)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\treturn ((HNS3_TQP_STATS_COUNT * h->kinfo.num_tqps) +\n\t\t\tops->get_sset_count(h, stringset));\n\n\tcase ETH_SS_TEST:\n\t\treturn ops->get_sset_count(h, stringset);\n\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn HNAE3_PFLAG_MAX;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void *hns3_update_strings(u8 *data, const struct hns3_stats *stats,\n\t\tu32 stat_count, u32 num_tqps, const char *prefix)\n{\n#define MAX_PREFIX_SIZE (6 + 4)\n\tu32 size_left;\n\tu32 i, j;\n\tu32 n1;\n\n\tfor (i = 0; i < num_tqps; i++) {\n\t\tfor (j = 0; j < stat_count; j++) {\n\t\t\tdata[ETH_GSTRING_LEN - 1] = '\\0';\n\n\t\t\t \n\t\t\tn1 = scnprintf(data, MAX_PREFIX_SIZE, \"%s%u_\",\n\t\t\t\t       prefix, i);\n\t\t\tsize_left = (ETH_GSTRING_LEN - 1) - n1;\n\n\t\t\t \n\t\t\tstrncat(data, stats[j].stats_string, size_left);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nstatic u8 *hns3_get_strings_tqps(struct hnae3_handle *handle, u8 *data)\n{\n\tstruct hnae3_knic_private_info *kinfo = &handle->kinfo;\n\tconst char tx_prefix[] = \"txq\";\n\tconst char rx_prefix[] = \"rxq\";\n\n\t \n\tdata = hns3_update_strings(data, hns3_txq_stats, HNS3_TXQ_STATS_COUNT,\n\t\t\t\t   kinfo->num_tqps, tx_prefix);\n\n\t \n\tdata = hns3_update_strings(data, hns3_rxq_stats, HNS3_RXQ_STATS_COUNT,\n\t\t\t\t   kinfo->num_tqps, rx_prefix);\n\n\treturn data;\n}\n\nstatic void hns3_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tconst struct hnae3_ae_ops *ops = h->ae_algo->ops;\n\tchar *buff = (char *)data;\n\tint i;\n\n\tif (!ops->get_strings)\n\t\treturn;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tbuff = hns3_get_strings_tqps(h, buff);\n\t\tops->get_strings(h, stringset, (u8 *)buff);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tops->get_strings(h, stringset, data);\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tfor (i = 0; i < HNS3_PRIV_FLAGS_LEN; i++) {\n\t\t\tsnprintf(buff, ETH_GSTRING_LEN, \"%s\",\n\t\t\t\t hns3_priv_flags[i].name);\n\t\t\tbuff += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u64 *hns3_get_stats_tqps(struct hnae3_handle *handle, u64 *data)\n{\n\tstruct hnae3_knic_private_info *kinfo = &handle->kinfo;\n\tstruct hns3_nic_priv *nic_priv = handle->priv;\n\tstruct hns3_enet_ring *ring;\n\tu8 *stat;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < kinfo->num_tqps; i++) {\n\t\tring = &nic_priv->ring[i];\n\t\tfor (j = 0; j < HNS3_TXQ_STATS_COUNT; j++) {\n\t\t\tstat = (u8 *)ring + hns3_txq_stats[j].stats_offset;\n\t\t\t*data++ = *(u64 *)stat;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < kinfo->num_tqps; i++) {\n\t\tring = &nic_priv->ring[i + kinfo->num_tqps];\n\t\tfor (j = 0; j < HNS3_RXQ_STATS_COUNT; j++) {\n\t\t\tstat = (u8 *)ring + hns3_rxq_stats[j].stats_offset;\n\t\t\t*data++ = *(u64 *)stat;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n \nstatic void hns3_get_stats(struct net_device *netdev,\n\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tu64 *p = data;\n\n\tif (hns3_nic_resetting(netdev)) {\n\t\tnetdev_err(netdev, \"dev resetting, could not get stats\\n\");\n\t\treturn;\n\t}\n\n\tif (!h->ae_algo->ops->get_stats || !h->ae_algo->ops->update_stats) {\n\t\tnetdev_err(netdev, \"could not get any statistics\\n\");\n\t\treturn;\n\t}\n\n\th->ae_algo->ops->update_stats(h);\n\n\t \n\tp = hns3_get_stats_tqps(h, p);\n\n\t \n\th->ae_algo->ops->get_stats(h, p);\n}\n\nstatic void hns3_get_drvinfo(struct net_device *netdev,\n\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tu32 fw_version;\n\n\tif (!h->ae_algo->ops->get_fw_version) {\n\t\tnetdev_err(netdev, \"could not get fw version!\\n\");\n\t\treturn;\n\t}\n\n\tstrscpy(drvinfo->driver, dev_driver_string(&h->pdev->dev),\n\t\tsizeof(drvinfo->driver));\n\n\tstrscpy(drvinfo->bus_info, pci_name(h->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\n\tfw_version = priv->ae_handle->ae_algo->ops->get_fw_version(h);\n\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%lu.%lu.%lu.%lu\",\n\t\t hnae3_get_field(fw_version, HNAE3_FW_VERSION_BYTE3_MASK,\n\t\t\t\t HNAE3_FW_VERSION_BYTE3_SHIFT),\n\t\t hnae3_get_field(fw_version, HNAE3_FW_VERSION_BYTE2_MASK,\n\t\t\t\t HNAE3_FW_VERSION_BYTE2_SHIFT),\n\t\t hnae3_get_field(fw_version, HNAE3_FW_VERSION_BYTE1_MASK,\n\t\t\t\t HNAE3_FW_VERSION_BYTE1_SHIFT),\n\t\t hnae3_get_field(fw_version, HNAE3_FW_VERSION_BYTE0_MASK,\n\t\t\t\t HNAE3_FW_VERSION_BYTE0_SHIFT));\n}\n\nstatic u32 hns3_get_link(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (h->ae_algo->ops->get_status)\n\t\treturn h->ae_algo->ops->get_status(h);\n\telse\n\t\treturn 0;\n}\n\nstatic void hns3_get_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *param,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint rx_queue_index = h->kinfo.num_tqps;\n\n\tif (hns3_nic_resetting(netdev) || !priv->ring) {\n\t\tnetdev_err(netdev, \"failed to get ringparam value, due to dev resetting or uninited\\n\");\n\t\treturn;\n\t}\n\n\tparam->tx_max_pending = HNS3_RING_MAX_PENDING;\n\tparam->rx_max_pending = HNS3_RING_MAX_PENDING;\n\n\tparam->tx_pending = priv->ring[0].desc_num;\n\tparam->rx_pending = priv->ring[rx_queue_index].desc_num;\n\tkernel_param->rx_buf_len = priv->ring[rx_queue_index].buf_size;\n\tkernel_param->tx_push = test_bit(HNS3_NIC_STATE_TX_PUSH_ENABLE,\n\t\t\t\t\t &priv->state);\n}\n\nstatic void hns3_get_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *param)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\n\tif (!test_bit(HNAE3_DEV_SUPPORT_PAUSE_B, ae_dev->caps))\n\t\treturn;\n\n\tif (h->ae_algo->ops->get_pauseparam)\n\t\th->ae_algo->ops->get_pauseparam(h, &param->autoneg,\n\t\t\t&param->rx_pause, &param->tx_pause);\n}\n\nstatic int hns3_set_pauseparam(struct net_device *netdev,\n\t\t\t       struct ethtool_pauseparam *param)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\n\tif (!test_bit(HNAE3_DEV_SUPPORT_PAUSE_B, ae_dev->caps))\n\t\treturn -EOPNOTSUPP;\n\n\tnetif_dbg(h, drv, netdev,\n\t\t  \"set pauseparam: autoneg=%u, rx:%u, tx:%u\\n\",\n\t\t  param->autoneg, param->rx_pause, param->tx_pause);\n\n\tif (h->ae_algo->ops->set_pauseparam)\n\t\treturn h->ae_algo->ops->set_pauseparam(h, param->autoneg,\n\t\t\t\t\t\t       param->rx_pause,\n\t\t\t\t\t\t       param->tx_pause);\n\treturn -EOPNOTSUPP;\n}\n\nstatic void hns3_get_ksettings(struct hnae3_handle *h,\n\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tconst struct hnae3_ae_ops *ops = h->ae_algo->ops;\n\n\t \n\tif (ops->get_ksettings_an_result)\n\t\tops->get_ksettings_an_result(h,\n\t\t\t\t\t     &cmd->base.autoneg,\n\t\t\t\t\t     &cmd->base.speed,\n\t\t\t\t\t     &cmd->base.duplex,\n\t\t\t\t\t     &cmd->lanes);\n\n\t \n\tif (ops->get_link_mode)\n\t\tops->get_link_mode(h,\n\t\t\t\t   cmd->link_modes.supported,\n\t\t\t\t   cmd->link_modes.advertising);\n\n\t \n\tif (ops->get_mdix_mode)\n\t\tops->get_mdix_mode(h, &cmd->base.eth_tp_mdix_ctrl,\n\t\t\t\t   &cmd->base.eth_tp_mdix);\n}\n\nstatic int hns3_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tconst struct hnae3_ae_ops *ops;\n\tu8 module_type;\n\tu8 media_type;\n\tu8 link_stat;\n\n\tops = h->ae_algo->ops;\n\tif (ops->get_media_type)\n\t\tops->get_media_type(h, &media_type, &module_type);\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (media_type) {\n\tcase HNAE3_MEDIA_TYPE_NONE:\n\t\tcmd->base.port = PORT_NONE;\n\t\thns3_get_ksettings(h, cmd);\n\t\tbreak;\n\tcase HNAE3_MEDIA_TYPE_FIBER:\n\t\tif (module_type == HNAE3_MODULE_TYPE_UNKNOWN)\n\t\t\tcmd->base.port = PORT_OTHER;\n\t\telse if (module_type == HNAE3_MODULE_TYPE_CR)\n\t\t\tcmd->base.port = PORT_DA;\n\t\telse\n\t\t\tcmd->base.port = PORT_FIBRE;\n\n\t\thns3_get_ksettings(h, cmd);\n\t\tbreak;\n\tcase HNAE3_MEDIA_TYPE_BACKPLANE:\n\t\tcmd->base.port = PORT_NONE;\n\t\thns3_get_ksettings(h, cmd);\n\t\tbreak;\n\tcase HNAE3_MEDIA_TYPE_COPPER:\n\t\tcmd->base.port = PORT_TP;\n\t\tif (test_bit(HNAE3_DEV_SUPPORT_PHY_IMP_B, ae_dev->caps) &&\n\t\t    ops->get_phy_link_ksettings)\n\t\t\tops->get_phy_link_ksettings(h, cmd);\n\t\telse if (!netdev->phydev)\n\t\t\thns3_get_ksettings(h, cmd);\n\t\telse\n\t\t\tphy_ethtool_ksettings_get(netdev->phydev, cmd);\n\t\tbreak;\n\tdefault:\n\n\t\tnetdev_warn(netdev, \"Unknown media type\");\n\t\treturn 0;\n\t}\n\n\t \n\tcmd->base.mdio_support = ETH_MDIO_SUPPORTS_C22;\n\n\tlink_stat = hns3_get_link(netdev);\n\tif (!link_stat) {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_check_ksettings_param(const struct net_device *netdev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\tu8 module_type = HNAE3_MODULE_TYPE_UNKNOWN;\n\tu8 media_type = HNAE3_MEDIA_TYPE_UNKNOWN;\n\tu32 lane_num;\n\tu8 autoneg;\n\tu32 speed;\n\tu8 duplex;\n\tint ret;\n\n\t \n\tif (cmd->base.autoneg)\n\t\treturn 0;\n\n\tif (ops->get_ksettings_an_result) {\n\t\tops->get_ksettings_an_result(handle, &autoneg, &speed, &duplex, &lane_num);\n\t\tif (cmd->base.autoneg == autoneg && cmd->base.speed == speed &&\n\t\t    cmd->base.duplex == duplex && cmd->lanes == lane_num)\n\t\t\treturn 0;\n\t}\n\n\tif (ops->get_media_type)\n\t\tops->get_media_type(handle, &media_type, &module_type);\n\n\tif (cmd->base.duplex == DUPLEX_HALF &&\n\t    media_type != HNAE3_MEDIA_TYPE_COPPER) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"only copper port supports half duplex!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ops->check_port_speed) {\n\t\tret = ops->check_port_speed(handle, cmd->base.speed);\n\t\tif (ret) {\n\t\t\tnetdev_err(netdev, \"unsupported speed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\tint ret;\n\n\t \n\tif (cmd->base.speed == SPEED_1000 && cmd->base.duplex == DUPLEX_HALF)\n\t\treturn -EINVAL;\n\n\tif (cmd->lanes && !hnae3_ae_dev_lane_num_supported(ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tnetif_dbg(handle, drv, netdev,\n\t\t  \"set link(%s): autoneg=%u, speed=%u, duplex=%u, lanes=%u\\n\",\n\t\t  netdev->phydev ? \"phy\" : \"mac\",\n\t\t  cmd->base.autoneg, cmd->base.speed, cmd->base.duplex,\n\t\t  cmd->lanes);\n\n\t \n\tif (netdev->phydev) {\n\t\tif (cmd->base.speed == SPEED_1000 &&\n\t\t    cmd->base.autoneg == AUTONEG_DISABLE)\n\t\t\treturn -EINVAL;\n\n\t\treturn phy_ethtool_ksettings_set(netdev->phydev, cmd);\n\t} else if (test_bit(HNAE3_DEV_SUPPORT_PHY_IMP_B, ae_dev->caps) &&\n\t\t   ops->set_phy_link_ksettings) {\n\t\treturn ops->set_phy_link_ksettings(handle, cmd);\n\t}\n\n\tif (ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)\n\t\treturn -EOPNOTSUPP;\n\n\tret = hns3_check_ksettings_param(netdev, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ops->set_autoneg) {\n\t\tret = ops->set_autoneg(handle, cmd->base.autoneg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (cmd->base.autoneg) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"autoneg is on, ignore the speed and duplex\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ops->cfg_mac_speed_dup_h)\n\t\tret = ops->cfg_mac_speed_dup_h(handle, cmd->base.speed,\n\t\t\t\t\t       cmd->base.duplex, (u8)(cmd->lanes));\n\n\treturn ret;\n}\n\nstatic u32 hns3_get_rss_key_size(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (!h->ae_algo->ops->get_rss_key_size)\n\t\treturn 0;\n\n\treturn h->ae_algo->ops->get_rss_key_size(h);\n}\n\nstatic u32 hns3_get_rss_indir_size(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\n\treturn ae_dev->dev_specs.rss_ind_tbl_size;\n}\n\nstatic int hns3_get_rss(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\tu8 *hfunc)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (!h->ae_algo->ops->get_rss)\n\t\treturn -EOPNOTSUPP;\n\n\treturn h->ae_algo->ops->get_rss(h, indir, key, hfunc);\n}\n\nstatic int hns3_set_rss(struct net_device *netdev, const u32 *indir,\n\t\t\tconst u8 *key, const u8 hfunc)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\n\tif (!h->ae_algo->ops->set_rss)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2 &&\n\t     hfunc != ETH_RSS_HASH_TOP) || (hfunc != ETH_RSS_HASH_NO_CHANGE &&\n\t     hfunc != ETH_RSS_HASH_TOP && hfunc != ETH_RSS_HASH_XOR)) {\n\t\tnetdev_err(netdev, \"hash func not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!indir) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"set rss failed for indir is empty\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn h->ae_algo->ops->set_rss(h, indir, key, hfunc);\n}\n\nstatic int hns3_get_rxnfc(struct net_device *netdev,\n\t\t\t  struct ethtool_rxnfc *cmd,\n\t\t\t  u32 *rule_locs)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = h->kinfo.num_tqps;\n\t\treturn 0;\n\tcase ETHTOOL_GRXFH:\n\t\tif (h->ae_algo->ops->get_rss_tuple)\n\t\t\treturn h->ae_algo->ops->get_rss_tuple(h, cmd);\n\t\treturn -EOPNOTSUPP;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tif (h->ae_algo->ops->get_fd_rule_cnt)\n\t\t\treturn h->ae_algo->ops->get_fd_rule_cnt(h, cmd);\n\t\treturn -EOPNOTSUPP;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tif (h->ae_algo->ops->get_fd_rule_info)\n\t\t\treturn h->ae_algo->ops->get_fd_rule_info(h, cmd);\n\t\treturn -EOPNOTSUPP;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tif (h->ae_algo->ops->get_fd_all_rules)\n\t\t\treturn h->ae_algo->ops->get_fd_all_rules(h, cmd,\n\t\t\t\t\t\t\t\t rule_locs);\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hns3_reset_type_map hns3_reset_type[] = {\n\t{ETH_RESET_MGMT, HNAE3_IMP_RESET},\n\t{ETH_RESET_ALL, HNAE3_GLOBAL_RESET},\n\t{ETH_RESET_DEDICATED, HNAE3_FUNC_RESET},\n};\n\nstatic const struct hns3_reset_type_map hns3vf_reset_type[] = {\n\t{ETH_RESET_DEDICATED, HNAE3_VF_FUNC_RESET},\n};\n\nstatic int hns3_set_reset(struct net_device *netdev, u32 *flags)\n{\n\tenum hnae3_reset_type rst_type = HNAE3_NONE_RESET;\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tconst struct hnae3_ae_ops *ops = h->ae_algo->ops;\n\tconst struct hns3_reset_type_map *rst_type_map;\n\tenum ethtool_reset_flags rst_flags;\n\tu32 i, size;\n\n\tif (ops->ae_dev_resetting && ops->ae_dev_resetting(h))\n\t\treturn -EBUSY;\n\n\tif (!ops->set_default_reset_request || !ops->reset_event)\n\t\treturn -EOPNOTSUPP;\n\n\tif (h->flags & HNAE3_SUPPORT_VF) {\n\t\trst_type_map = hns3vf_reset_type;\n\t\tsize = ARRAY_SIZE(hns3vf_reset_type);\n\t} else {\n\t\trst_type_map = hns3_reset_type;\n\t\tsize = ARRAY_SIZE(hns3_reset_type);\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (rst_type_map[i].rst_flags == *flags) {\n\t\t\trst_type = rst_type_map[i].rst_type;\n\t\t\trst_flags = rst_type_map[i].rst_flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rst_type == HNAE3_NONE_RESET ||\n\t    (rst_type == HNAE3_IMP_RESET &&\n\t     ae_dev->dev_version <= HNAE3_DEVICE_VERSION_V2))\n\t\treturn -EOPNOTSUPP;\n\n\tnetdev_info(netdev, \"Setting reset type %d\\n\", rst_type);\n\n\tops->set_default_reset_request(ae_dev, rst_type);\n\n\tops->reset_event(h->pdev, h);\n\n\t*flags &= ~rst_flags;\n\n\treturn 0;\n}\n\nstatic void hns3_change_all_ring_bd_num(struct hns3_nic_priv *priv,\n\t\t\t\t\tu32 tx_desc_num, u32 rx_desc_num)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint i;\n\n\th->kinfo.num_tx_desc = tx_desc_num;\n\th->kinfo.num_rx_desc = rx_desc_num;\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\tpriv->ring[i].desc_num = tx_desc_num;\n\t\tpriv->ring[i + h->kinfo.num_tqps].desc_num = rx_desc_num;\n\t}\n}\n\nstatic struct hns3_enet_ring *hns3_backup_ringparam(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_handle *handle = priv->ae_handle;\n\tstruct hns3_enet_ring *tmp_rings;\n\tint i;\n\n\ttmp_rings = kcalloc(handle->kinfo.num_tqps * 2,\n\t\t\t    sizeof(struct hns3_enet_ring), GFP_KERNEL);\n\tif (!tmp_rings)\n\t\treturn NULL;\n\n\tfor (i = 0; i < handle->kinfo.num_tqps * 2; i++) {\n\t\tmemcpy(&tmp_rings[i], &priv->ring[i],\n\t\t       sizeof(struct hns3_enet_ring));\n\t\ttmp_rings[i].skb = NULL;\n\t}\n\n\treturn tmp_rings;\n}\n\nstatic int hns3_check_ringparam(struct net_device *ndev,\n\t\t\t\tstruct ethtool_ringparam *param,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_param)\n{\n#define RX_BUF_LEN_2K 2048\n#define RX_BUF_LEN_4K 4096\n\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\n\tif (hns3_nic_resetting(ndev) || !priv->ring) {\n\t\tnetdev_err(ndev, \"failed to set ringparam value, due to dev resetting or uninited\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\n\tif (param->rx_mini_pending || param->rx_jumbo_pending)\n\t\treturn -EINVAL;\n\n\tif (kernel_param->rx_buf_len != RX_BUF_LEN_2K &&\n\t    kernel_param->rx_buf_len != RX_BUF_LEN_4K) {\n\t\tnetdev_err(ndev, \"Rx buf len only support 2048 and 4096\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (param->tx_pending > HNS3_RING_MAX_PENDING ||\n\t    param->tx_pending < HNS3_RING_MIN_PENDING ||\n\t    param->rx_pending > HNS3_RING_MAX_PENDING ||\n\t    param->rx_pending < HNS3_RING_MIN_PENDING) {\n\t\tnetdev_err(ndev, \"Queue depth out of range [%d-%d]\\n\",\n\t\t\t   HNS3_RING_MIN_PENDING, HNS3_RING_MAX_PENDING);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nhns3_is_ringparam_changed(struct net_device *ndev,\n\t\t\t  struct ethtool_ringparam *param,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t  struct hns3_ring_param *old_ringparam,\n\t\t\t  struct hns3_ring_param *new_ringparam)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tu16 queue_num = h->kinfo.num_tqps;\n\n\tnew_ringparam->tx_desc_num = ALIGN(param->tx_pending,\n\t\t\t\t\t   HNS3_RING_BD_MULTIPLE);\n\tnew_ringparam->rx_desc_num = ALIGN(param->rx_pending,\n\t\t\t\t\t   HNS3_RING_BD_MULTIPLE);\n\told_ringparam->tx_desc_num = priv->ring[0].desc_num;\n\told_ringparam->rx_desc_num = priv->ring[queue_num].desc_num;\n\told_ringparam->rx_buf_len = priv->ring[queue_num].buf_size;\n\tnew_ringparam->rx_buf_len = kernel_param->rx_buf_len;\n\n\tif (old_ringparam->tx_desc_num == new_ringparam->tx_desc_num &&\n\t    old_ringparam->rx_desc_num == new_ringparam->rx_desc_num &&\n\t    old_ringparam->rx_buf_len == new_ringparam->rx_buf_len) {\n\t\tnetdev_info(ndev, \"descriptor number and rx buffer length not changed\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int hns3_change_rx_buf_len(struct net_device *ndev, u32 rx_buf_len)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint i;\n\n\th->kinfo.rx_buf_len = rx_buf_len;\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\th->kinfo.tqp[i]->buf_size = rx_buf_len;\n\t\tpriv->ring[i + h->kinfo.num_tqps].buf_size = rx_buf_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_set_tx_push(struct net_device *netdev, u32 tx_push)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tu32 old_state = test_bit(HNS3_NIC_STATE_TX_PUSH_ENABLE, &priv->state);\n\n\tif (!test_bit(HNAE3_DEV_SUPPORT_TX_PUSH_B, ae_dev->caps) && tx_push)\n\t\treturn -EOPNOTSUPP;\n\n\tif (tx_push == old_state)\n\t\treturn 0;\n\n\tnetdev_dbg(netdev, \"Changing tx push from %s to %s\\n\",\n\t\t   old_state ? \"on\" : \"off\", tx_push ? \"on\" : \"off\");\n\n\tif (tx_push)\n\t\tset_bit(HNS3_NIC_STATE_TX_PUSH_ENABLE, &priv->state);\n\telse\n\t\tclear_bit(HNS3_NIC_STATE_TX_PUSH_ENABLE, &priv->state);\n\n\treturn 0;\n}\n\nstatic int hns3_set_ringparam(struct net_device *ndev,\n\t\t\t      struct ethtool_ringparam *param,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct hns3_ring_param old_ringparam, new_ringparam;\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tstruct hns3_enet_ring *tmp_rings;\n\tbool if_running = netif_running(ndev);\n\tint ret, i;\n\n\tret = hns3_check_ringparam(ndev, param, kernel_param);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_set_tx_push(ndev, kernel_param->tx_push);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!hns3_is_ringparam_changed(ndev, param, kernel_param,\n\t\t\t\t       &old_ringparam, &new_ringparam))\n\t\treturn 0;\n\n\ttmp_rings = hns3_backup_ringparam(priv);\n\tif (!tmp_rings) {\n\t\tnetdev_err(ndev, \"backup ring param failed by allocating memory fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnetdev_info(ndev,\n\t\t    \"Changing Tx/Rx ring depth from %u/%u to %u/%u, Changing rx buffer len from %u to %u\\n\",\n\t\t    old_ringparam.tx_desc_num, old_ringparam.rx_desc_num,\n\t\t    new_ringparam.tx_desc_num, new_ringparam.rx_desc_num,\n\t\t    old_ringparam.rx_buf_len, new_ringparam.rx_buf_len);\n\n\tif (if_running)\n\t\tndev->netdev_ops->ndo_stop(ndev);\n\n\thns3_change_all_ring_bd_num(priv, new_ringparam.tx_desc_num,\n\t\t\t\t    new_ringparam.rx_desc_num);\n\thns3_change_rx_buf_len(ndev, new_ringparam.rx_buf_len);\n\tret = hns3_init_all_ring(priv);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"set ringparam fail, revert to old value(%d)\\n\",\n\t\t\t   ret);\n\n\t\thns3_change_rx_buf_len(ndev, old_ringparam.rx_buf_len);\n\t\thns3_change_all_ring_bd_num(priv, old_ringparam.tx_desc_num,\n\t\t\t\t\t    old_ringparam.rx_desc_num);\n\t\tfor (i = 0; i < h->kinfo.num_tqps * 2; i++)\n\t\t\tmemcpy(&priv->ring[i], &tmp_rings[i],\n\t\t\t       sizeof(struct hns3_enet_ring));\n\t} else {\n\t\tfor (i = 0; i < h->kinfo.num_tqps * 2; i++)\n\t\t\thns3_fini_ring(&tmp_rings[i]);\n\t}\n\n\tkfree(tmp_rings);\n\n\tif (if_running)\n\t\tret = ndev->netdev_ops->ndo_open(ndev);\n\n\treturn ret;\n}\n\nstatic int hns3_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tif (h->ae_algo->ops->set_rss_tuple)\n\t\t\treturn h->ae_algo->ops->set_rss_tuple(h, cmd);\n\t\treturn -EOPNOTSUPP;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tif (h->ae_algo->ops->add_fd_entry)\n\t\t\treturn h->ae_algo->ops->add_fd_entry(h, cmd);\n\t\treturn -EOPNOTSUPP;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tif (h->ae_algo->ops->del_fd_entry)\n\t\t\treturn h->ae_algo->ops->del_fd_entry(h, cmd);\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int hns3_nway_reset(struct net_device *netdev)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\tstruct phy_device *phy = netdev->phydev;\n\tint autoneg;\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\tif (hns3_nic_resetting(netdev)) {\n\t\tnetdev_err(netdev, \"dev resetting!\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!ops->get_autoneg || !ops->restart_autoneg)\n\t\treturn -EOPNOTSUPP;\n\n\tautoneg = ops->get_autoneg(handle);\n\tif (autoneg != AUTONEG_ENABLE) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Autoneg is off, don't support to restart it\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnetif_dbg(handle, drv, netdev,\n\t\t  \"nway reset (using %s)\\n\", phy ? \"phy\" : \"mac\");\n\n\tif (phy)\n\t\treturn genphy_restart_aneg(phy);\n\n\treturn ops->restart_autoneg(handle);\n}\n\nstatic void hns3_get_channels(struct net_device *netdev,\n\t\t\t      struct ethtool_channels *ch)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (h->ae_algo->ops->get_channels)\n\t\th->ae_algo->ops->get_channels(h, ch);\n}\n\nstatic int hns3_get_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *cmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hns3_enet_coalesce *tx_coal = &priv->tx_coal;\n\tstruct hns3_enet_coalesce *rx_coal = &priv->rx_coal;\n\tstruct hnae3_handle *h = priv->ae_handle;\n\n\tif (hns3_nic_resetting(netdev))\n\t\treturn -EBUSY;\n\n\tcmd->use_adaptive_tx_coalesce = tx_coal->adapt_enable;\n\tcmd->use_adaptive_rx_coalesce = rx_coal->adapt_enable;\n\n\tcmd->tx_coalesce_usecs = tx_coal->int_gl;\n\tcmd->rx_coalesce_usecs = rx_coal->int_gl;\n\n\tcmd->tx_coalesce_usecs_high = h->kinfo.int_rl_setting;\n\tcmd->rx_coalesce_usecs_high = h->kinfo.int_rl_setting;\n\n\tcmd->tx_max_coalesced_frames = tx_coal->int_ql;\n\tcmd->rx_max_coalesced_frames = rx_coal->int_ql;\n\n\tkernel_coal->use_cqe_mode_tx = (priv->tx_cqe_mode ==\n\t\t\t\t\tDIM_CQ_PERIOD_MODE_START_FROM_CQE);\n\tkernel_coal->use_cqe_mode_rx = (priv->rx_cqe_mode ==\n\t\t\t\t\tDIM_CQ_PERIOD_MODE_START_FROM_CQE);\n\n\treturn 0;\n}\n\nstatic int hns3_check_gl_coalesce_para(struct net_device *netdev,\n\t\t\t\t       struct ethtool_coalesce *cmd)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tu32 rx_gl, tx_gl;\n\n\tif (cmd->rx_coalesce_usecs > ae_dev->dev_specs.max_int_gl) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"invalid rx-usecs value, rx-usecs range is 0-%u\\n\",\n\t\t\t   ae_dev->dev_specs.max_int_gl);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->tx_coalesce_usecs > ae_dev->dev_specs.max_int_gl) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"invalid tx-usecs value, tx-usecs range is 0-%u\\n\",\n\t\t\t   ae_dev->dev_specs.max_int_gl);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3)\n\t\treturn 0;\n\n\trx_gl = hns3_gl_round_down(cmd->rx_coalesce_usecs);\n\tif (rx_gl != cmd->rx_coalesce_usecs) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"rx_usecs(%u) rounded down to %u, because it must be multiple of 2.\\n\",\n\t\t\t    cmd->rx_coalesce_usecs, rx_gl);\n\t}\n\n\ttx_gl = hns3_gl_round_down(cmd->tx_coalesce_usecs);\n\tif (tx_gl != cmd->tx_coalesce_usecs) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"tx_usecs(%u) rounded down to %u, because it must be multiple of 2.\\n\",\n\t\t\t    cmd->tx_coalesce_usecs, tx_gl);\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_check_rl_coalesce_para(struct net_device *netdev,\n\t\t\t\t       struct ethtool_coalesce *cmd)\n{\n\tu32 rl;\n\n\tif (cmd->tx_coalesce_usecs_high != cmd->rx_coalesce_usecs_high) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"tx_usecs_high must be same as rx_usecs_high.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->rx_coalesce_usecs_high > HNS3_INT_RL_MAX) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Invalid usecs_high value, usecs_high range is 0-%d\\n\",\n\t\t\t   HNS3_INT_RL_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\trl = hns3_rl_round_down(cmd->rx_coalesce_usecs_high);\n\tif (rl != cmd->rx_coalesce_usecs_high) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"usecs_high(%u) rounded down to %u, because it must be multiple of 4.\\n\",\n\t\t\t    cmd->rx_coalesce_usecs_high, rl);\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_check_ql_coalesce_param(struct net_device *netdev,\n\t\t\t\t\tstruct ethtool_coalesce *cmd)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\n\tif ((cmd->tx_max_coalesced_frames || cmd->rx_max_coalesced_frames) &&\n\t    !ae_dev->dev_specs.int_ql_max) {\n\t\tnetdev_err(netdev, \"coalesced frames is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (cmd->tx_max_coalesced_frames > ae_dev->dev_specs.int_ql_max ||\n\t    cmd->rx_max_coalesced_frames > ae_dev->dev_specs.int_ql_max) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"invalid coalesced_frames value, range is 0-%u\\n\",\n\t\t\t   ae_dev->dev_specs.int_ql_max);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhns3_check_cqe_coalesce_param(struct net_device *netdev,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\n\tif ((kernel_coal->use_cqe_mode_tx || kernel_coal->use_cqe_mode_rx) &&\n\t    !hnae3_ae_dev_cq_supported(ae_dev)) {\n\t\tnetdev_err(netdev, \"coalesced cqe mode is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhns3_check_coalesce_para(struct net_device *netdev,\n\t\t\t struct ethtool_coalesce *cmd,\n\t\t\t struct kernel_ethtool_coalesce *kernel_coal)\n{\n\tint ret;\n\n\tret = hns3_check_cqe_coalesce_param(netdev, kernel_coal);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_check_gl_coalesce_para(netdev, cmd);\n\tif (ret) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Check gl coalesce param fail. ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hns3_check_rl_coalesce_para(netdev, cmd);\n\tif (ret) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Check rl coalesce param fail. ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn hns3_check_ql_coalesce_param(netdev, cmd);\n}\n\nstatic void hns3_set_coalesce_per_queue(struct net_device *netdev,\n\t\t\t\t\tstruct ethtool_coalesce *cmd,\n\t\t\t\t\tu32 queue)\n{\n\tstruct hns3_enet_tqp_vector *tx_vector, *rx_vector;\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint queue_num = h->kinfo.num_tqps;\n\n\ttx_vector = priv->ring[queue].tqp_vector;\n\trx_vector = priv->ring[queue_num + queue].tqp_vector;\n\n\ttx_vector->tx_group.coal.adapt_enable =\n\t\t\t\tcmd->use_adaptive_tx_coalesce;\n\trx_vector->rx_group.coal.adapt_enable =\n\t\t\t\tcmd->use_adaptive_rx_coalesce;\n\n\ttx_vector->tx_group.coal.int_gl = cmd->tx_coalesce_usecs;\n\trx_vector->rx_group.coal.int_gl = cmd->rx_coalesce_usecs;\n\n\ttx_vector->tx_group.coal.int_ql = cmd->tx_max_coalesced_frames;\n\trx_vector->rx_group.coal.int_ql = cmd->rx_max_coalesced_frames;\n\n\thns3_set_vector_coalesce_tx_gl(tx_vector,\n\t\t\t\t       tx_vector->tx_group.coal.int_gl);\n\thns3_set_vector_coalesce_rx_gl(rx_vector,\n\t\t\t\t       rx_vector->rx_group.coal.int_gl);\n\n\thns3_set_vector_coalesce_rl(tx_vector, h->kinfo.int_rl_setting);\n\thns3_set_vector_coalesce_rl(rx_vector, h->kinfo.int_rl_setting);\n\n\tif (tx_vector->tx_group.coal.ql_enable)\n\t\thns3_set_vector_coalesce_tx_ql(tx_vector,\n\t\t\t\t\t       tx_vector->tx_group.coal.int_ql);\n\tif (rx_vector->rx_group.coal.ql_enable)\n\t\thns3_set_vector_coalesce_rx_ql(rx_vector,\n\t\t\t\t\t       rx_vector->rx_group.coal.int_ql);\n}\n\nstatic int hns3_set_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *cmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hns3_enet_coalesce *tx_coal = &priv->tx_coal;\n\tstruct hns3_enet_coalesce *rx_coal = &priv->rx_coal;\n\tu16 queue_num = h->kinfo.num_tqps;\n\tenum dim_cq_period_mode tx_mode;\n\tenum dim_cq_period_mode rx_mode;\n\tint ret;\n\tint i;\n\n\tif (hns3_nic_resetting(netdev))\n\t\treturn -EBUSY;\n\n\tret = hns3_check_coalesce_para(netdev, cmd, kernel_coal);\n\tif (ret)\n\t\treturn ret;\n\n\th->kinfo.int_rl_setting =\n\t\thns3_rl_round_down(cmd->rx_coalesce_usecs_high);\n\n\ttx_coal->adapt_enable = cmd->use_adaptive_tx_coalesce;\n\trx_coal->adapt_enable = cmd->use_adaptive_rx_coalesce;\n\n\ttx_coal->int_gl = cmd->tx_coalesce_usecs;\n\trx_coal->int_gl = cmd->rx_coalesce_usecs;\n\n\ttx_coal->int_ql = cmd->tx_max_coalesced_frames;\n\trx_coal->int_ql = cmd->rx_max_coalesced_frames;\n\n\tfor (i = 0; i < queue_num; i++)\n\t\thns3_set_coalesce_per_queue(netdev, cmd, i);\n\n\ttx_mode = kernel_coal->use_cqe_mode_tx ?\n\t\t  DIM_CQ_PERIOD_MODE_START_FROM_CQE :\n\t\t  DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\trx_mode = kernel_coal->use_cqe_mode_rx ?\n\t\t  DIM_CQ_PERIOD_MODE_START_FROM_CQE :\n\t\t  DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\thns3_cq_period_mode_init(priv, tx_mode, rx_mode);\n\n\treturn 0;\n}\n\nstatic int hns3_get_regs_len(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (!h->ae_algo->ops->get_regs_len)\n\t\treturn -EOPNOTSUPP;\n\n\treturn h->ae_algo->ops->get_regs_len(h);\n}\n\nstatic void hns3_get_regs(struct net_device *netdev,\n\t\t\t  struct ethtool_regs *cmd, void *data)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (!h->ae_algo->ops->get_regs)\n\t\treturn;\n\n\th->ae_algo->ops->get_regs(h, &cmd->version, data);\n}\n\nstatic int hns3_set_phys_id(struct net_device *netdev,\n\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (!h->ae_algo->ops->set_led_id)\n\t\treturn -EOPNOTSUPP;\n\n\treturn h->ae_algo->ops->set_led_id(h, state);\n}\n\nstatic u32 hns3_get_msglevel(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\treturn h->msg_enable;\n}\n\nstatic void hns3_set_msglevel(struct net_device *netdev, u32 msg_level)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\th->msg_enable = msg_level;\n}\n\nstatic void hns3_get_fec_stats(struct net_device *netdev,\n\t\t\t       struct ethtool_fec_stats *fec_stats)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\n\tif (!hnae3_ae_dev_fec_stats_supported(ae_dev) || !ops->get_fec_stats)\n\t\treturn;\n\n\tops->get_fec_stats(handle, fec_stats);\n}\n\n \nstatic unsigned int loc_to_eth_fec(u8 loc_fec)\n{\n\tu32 eth_fec = 0;\n\n\tif (loc_fec & BIT(HNAE3_FEC_AUTO))\n\t\teth_fec |= ETHTOOL_FEC_AUTO;\n\tif (loc_fec & BIT(HNAE3_FEC_RS))\n\t\teth_fec |= ETHTOOL_FEC_RS;\n\tif (loc_fec & BIT(HNAE3_FEC_LLRS))\n\t\teth_fec |= ETHTOOL_FEC_LLRS;\n\tif (loc_fec & BIT(HNAE3_FEC_BASER))\n\t\teth_fec |= ETHTOOL_FEC_BASER;\n\tif (loc_fec & BIT(HNAE3_FEC_NONE))\n\t\teth_fec |= ETHTOOL_FEC_OFF;\n\n\treturn eth_fec;\n}\n\n \nstatic unsigned int eth_to_loc_fec(unsigned int eth_fec)\n{\n\tu32 loc_fec = 0;\n\n\tif (eth_fec & ETHTOOL_FEC_OFF)\n\t\tloc_fec |= BIT(HNAE3_FEC_NONE);\n\tif (eth_fec & ETHTOOL_FEC_AUTO)\n\t\tloc_fec |= BIT(HNAE3_FEC_AUTO);\n\tif (eth_fec & ETHTOOL_FEC_RS)\n\t\tloc_fec |= BIT(HNAE3_FEC_RS);\n\tif (eth_fec & ETHTOOL_FEC_LLRS)\n\t\tloc_fec |= BIT(HNAE3_FEC_LLRS);\n\tif (eth_fec & ETHTOOL_FEC_BASER)\n\t\tloc_fec |= BIT(HNAE3_FEC_BASER);\n\n\treturn loc_fec;\n}\n\nstatic int hns3_get_fecparam(struct net_device *netdev,\n\t\t\t     struct ethtool_fecparam *fec)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\tu8 fec_ability;\n\tu8 fec_mode;\n\n\tif (!test_bit(HNAE3_DEV_SUPPORT_FEC_B, ae_dev->caps))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ops->get_fec)\n\t\treturn -EOPNOTSUPP;\n\n\tops->get_fec(handle, &fec_ability, &fec_mode);\n\n\tfec->fec = loc_to_eth_fec(fec_ability);\n\tfec->active_fec = loc_to_eth_fec(fec_mode);\n\tif (!fec->active_fec)\n\t\tfec->active_fec = ETHTOOL_FEC_OFF;\n\n\treturn 0;\n}\n\nstatic int hns3_set_fecparam(struct net_device *netdev,\n\t\t\t     struct ethtool_fecparam *fec)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\tu32 fec_mode;\n\n\tif (!test_bit(HNAE3_DEV_SUPPORT_FEC_B, ae_dev->caps))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ops->set_fec)\n\t\treturn -EOPNOTSUPP;\n\tfec_mode = eth_to_loc_fec(fec->fec);\n\n\tnetif_dbg(handle, drv, netdev, \"set fecparam: mode=%u\\n\", fec_mode);\n\n\treturn ops->set_fec(handle, fec_mode);\n}\n\nstatic int hns3_get_module_info(struct net_device *netdev,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n#define HNS3_SFF_8636_V1_3 0x03\n\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\tstruct hns3_sfp_type sfp_type;\n\tint ret;\n\n\tif (ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2 ||\n\t    !ops->get_module_eeprom)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&sfp_type, 0, sizeof(sfp_type));\n\tret = ops->get_module_eeprom(handle, 0, sizeof(sfp_type) / sizeof(u8),\n\t\t\t\t     (u8 *)&sfp_type);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (sfp_type.type) {\n\tcase SFF8024_ID_SFP:\n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\tbreak;\n\tcase SFF8024_ID_QSFP_8438:\n\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\tbreak;\n\tcase SFF8024_ID_QSFP_8436_8636:\n\t\tif (sfp_type.ext_type < HNS3_SFF_8636_V1_3) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\t\t}\n\t\tbreak;\n\tcase SFF8024_ID_QSFP28_8636:\n\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"Optical module unknown: %#x\\n\",\n\t\t\t   sfp_type.type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_get_module_eeprom(struct net_device *netdev,\n\t\t\t\t  struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\n\tif (ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2 ||\n\t    !ops->get_module_eeprom)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ee->len)\n\t\treturn -EINVAL;\n\n\tmemset(data, 0, ee->len);\n\n\treturn ops->get_module_eeprom(handle, ee->offset, ee->len, data);\n}\n\nstatic u32 hns3_get_priv_flags(struct net_device *netdev)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\n\treturn handle->priv_flags;\n}\n\nstatic int hns3_check_priv_flags(struct hnae3_handle *h, u32 changed)\n{\n\tu32 i;\n\n\tfor (i = 0; i < HNAE3_PFLAG_MAX; i++)\n\t\tif ((changed & BIT(i)) && !test_bit(i, &h->supported_pflags)) {\n\t\t\tnetdev_err(h->netdev, \"%s is unsupported\\n\",\n\t\t\t\t   hns3_priv_flags[i].name);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\treturn 0;\n}\n\nstatic int hns3_set_priv_flags(struct net_device *netdev, u32 pflags)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tu32 changed = pflags ^ handle->priv_flags;\n\tint ret;\n\tu32 i;\n\n\tret = hns3_check_priv_flags(handle, changed);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < HNAE3_PFLAG_MAX; i++) {\n\t\tif (changed & BIT(i)) {\n\t\t\tbool enable = !(handle->priv_flags & BIT(i));\n\n\t\t\tif (enable)\n\t\t\t\thandle->priv_flags |= BIT(i);\n\t\t\telse\n\t\t\t\thandle->priv_flags &= ~BIT(i);\n\t\t\thns3_priv_flags[i].handler(netdev, enable);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_get_tunable(struct net_device *netdev,\n\t\t\t    const struct ethtool_tunable *tuna,\n\t\t\t    void *data)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_TX_COPYBREAK:\n\t\t \n\t\t*(u32 *)data = priv->tx_copybreak;\n\t\tbreak;\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = priv->rx_copybreak;\n\t\tbreak;\n\tcase ETHTOOL_TX_COPYBREAK_BUF_SIZE:\n\t\t*(u32 *)data = h->kinfo.tx_spare_buf_size;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int hns3_set_tx_spare_buf_size(struct net_device *netdev,\n\t\t\t\t      u32 data)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint ret;\n\n\th->kinfo.tx_spare_buf_size = data;\n\n\tret = hns3_reset_notify(h, HNAE3_DOWN_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_reset_notify(h, HNAE3_UNINIT_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_reset_notify(h, HNAE3_INIT_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_reset_notify(h, HNAE3_UP_CLIENT);\n\tif (ret)\n\t\thns3_reset_notify(h, HNAE3_UNINIT_CLIENT);\n\n\treturn ret;\n}\n\nstatic int hns3_set_tunable(struct net_device *netdev,\n\t\t\t    const struct ethtool_tunable *tuna,\n\t\t\t    const void *data)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tu32 old_tx_spare_buf_size, new_tx_spare_buf_size;\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint i, ret = 0;\n\n\tif (hns3_nic_resetting(netdev) || !priv->ring) {\n\t\tnetdev_err(netdev, \"failed to set tunable value, dev resetting!\");\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_TX_COPYBREAK:\n\t\tpriv->tx_copybreak = *(u32 *)data;\n\n\t\tfor (i = 0; i < h->kinfo.num_tqps; i++)\n\t\t\tpriv->ring[i].tx_copybreak = priv->tx_copybreak;\n\n\t\tbreak;\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tpriv->rx_copybreak = *(u32 *)data;\n\n\t\tfor (i = h->kinfo.num_tqps; i < h->kinfo.num_tqps * 2; i++)\n\t\t\tpriv->ring[i].rx_copybreak = priv->rx_copybreak;\n\n\t\tbreak;\n\tcase ETHTOOL_TX_COPYBREAK_BUF_SIZE:\n\t\told_tx_spare_buf_size = h->kinfo.tx_spare_buf_size;\n\t\tnew_tx_spare_buf_size = *(u32 *)data;\n\t\tnetdev_info(netdev, \"request to set tx spare buf size from %u to %u\\n\",\n\t\t\t    old_tx_spare_buf_size, new_tx_spare_buf_size);\n\t\tret = hns3_set_tx_spare_buf_size(netdev, new_tx_spare_buf_size);\n\t\tif (ret ||\n\t\t    (!priv->ring->tx_spare && new_tx_spare_buf_size != 0)) {\n\t\t\tint ret1;\n\n\t\t\tnetdev_warn(netdev, \"change tx spare buf size fail, revert to old value\\n\");\n\t\t\tret1 = hns3_set_tx_spare_buf_size(netdev,\n\t\t\t\t\t\t\t  old_tx_spare_buf_size);\n\t\t\tif (ret1) {\n\t\t\t\tnetdev_err(netdev, \"revert to old tx spare buf size fail\\n\");\n\t\t\t\treturn ret1;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!priv->ring->tx_spare)\n\t\t\tnetdev_info(netdev, \"the active tx spare buf size is 0, disable tx spare buffer\\n\");\n\t\telse\n\t\t\tnetdev_info(netdev, \"the active tx spare buf size is %u, due to page order\\n\",\n\t\t\t\t    priv->ring->tx_spare->len);\n\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#define HNS3_ETHTOOL_COALESCE\t(ETHTOOL_COALESCE_USECS |\t\t\\\n\t\t\t\t ETHTOOL_COALESCE_USE_ADAPTIVE |\t\\\n\t\t\t\t ETHTOOL_COALESCE_RX_USECS_HIGH |\t\\\n\t\t\t\t ETHTOOL_COALESCE_TX_USECS_HIGH |\t\\\n\t\t\t\t ETHTOOL_COALESCE_MAX_FRAMES |\t\t\\\n\t\t\t\t ETHTOOL_COALESCE_USE_CQE)\n\n#define HNS3_ETHTOOL_RING\t(ETHTOOL_RING_USE_RX_BUF_LEN |\t\t\\\n\t\t\t\t ETHTOOL_RING_USE_TX_PUSH)\n\nstatic int hns3_get_ts_info(struct net_device *netdev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\n\tif (handle->ae_algo->ops->get_ts_info)\n\t\treturn handle->ae_algo->ops->get_ts_info(handle, info);\n\n\treturn ethtool_op_get_ts_info(netdev, info);\n}\n\nstatic const struct hns3_ethtool_link_ext_state_mapping\nhns3_link_ext_state_map[] = {\n\t{1, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD},\n\t{2, ETHTOOL_LINK_EXT_STATE_AUTONEG,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED},\n\n\t{256, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT},\n\t{257, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY},\n\t{512, ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT},\n\n\t{513, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK},\n\t{514, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED},\n\t{515, ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED},\n\n\t{768, ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS},\n\t{769, ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST},\n\t{770, ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS},\n\n\t{1024, ETHTOOL_LINK_EXT_STATE_NO_CABLE, 0},\n\t{1025, ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE,\n\t\tETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE},\n\n\t{1026, ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE, 0},\n};\n\nstatic int hns3_get_link_ext_state(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ext_state_info *info)\n{\n\tconst struct hns3_ethtool_link_ext_state_mapping *map;\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tu32 status_code, i;\n\tint ret;\n\n\tif (netif_carrier_ok(netdev))\n\t\treturn -ENODATA;\n\n\tif (!h->ae_algo->ops->get_link_diagnosis_info)\n\t\treturn -EOPNOTSUPP;\n\n\tret = h->ae_algo->ops->get_link_diagnosis_info(h, &status_code);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_link_ext_state_map); i++) {\n\t\tmap = &hns3_link_ext_state_map[i];\n\t\tif (map->status_code == status_code) {\n\t\t\tinfo->link_ext_state = map->link_ext_state;\n\t\t\tinfo->__link_ext_substate = map->link_ext_substate;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENODATA;\n}\n\nstatic void hns3_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tconst struct hnae3_ae_ops *ops = hns3_get_ops(handle);\n\tstruct hnae3_ae_dev *ae_dev = hns3_get_ae_dev(handle);\n\n\tif (!hnae3_ae_dev_wol_supported(ae_dev))\n\t\treturn;\n\n\tops->get_wol(handle, wol);\n}\n\nstatic int hns3_set_wol(struct net_device *netdev,\n\t\t\tstruct ethtool_wolinfo *wol)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\tconst struct hnae3_ae_ops *ops = hns3_get_ops(handle);\n\tstruct hnae3_ae_dev *ae_dev = hns3_get_ae_dev(handle);\n\n\tif (!hnae3_ae_dev_wol_supported(ae_dev))\n\t\treturn -EOPNOTSUPP;\n\n\treturn ops->set_wol(handle, wol);\n}\n\nstatic const struct ethtool_ops hns3vf_ethtool_ops = {\n\t.supported_coalesce_params = HNS3_ETHTOOL_COALESCE,\n\t.supported_ring_params = HNS3_ETHTOOL_RING,\n\t.get_drvinfo = hns3_get_drvinfo,\n\t.get_ringparam = hns3_get_ringparam,\n\t.set_ringparam = hns3_set_ringparam,\n\t.get_strings = hns3_get_strings,\n\t.get_ethtool_stats = hns3_get_stats,\n\t.get_sset_count = hns3_get_sset_count,\n\t.get_rxnfc = hns3_get_rxnfc,\n\t.set_rxnfc = hns3_set_rxnfc,\n\t.get_rxfh_key_size = hns3_get_rss_key_size,\n\t.get_rxfh_indir_size = hns3_get_rss_indir_size,\n\t.get_rxfh = hns3_get_rss,\n\t.set_rxfh = hns3_set_rss,\n\t.get_link_ksettings = hns3_get_link_ksettings,\n\t.get_channels = hns3_get_channels,\n\t.set_channels = hns3_set_channels,\n\t.get_coalesce = hns3_get_coalesce,\n\t.set_coalesce = hns3_set_coalesce,\n\t.get_regs_len = hns3_get_regs_len,\n\t.get_regs = hns3_get_regs,\n\t.get_link = hns3_get_link,\n\t.get_msglevel = hns3_get_msglevel,\n\t.set_msglevel = hns3_set_msglevel,\n\t.get_priv_flags = hns3_get_priv_flags,\n\t.set_priv_flags = hns3_set_priv_flags,\n\t.get_tunable = hns3_get_tunable,\n\t.set_tunable = hns3_set_tunable,\n\t.reset = hns3_set_reset,\n};\n\nstatic const struct ethtool_ops hns3_ethtool_ops = {\n\t.supported_coalesce_params = HNS3_ETHTOOL_COALESCE,\n\t.supported_ring_params = HNS3_ETHTOOL_RING,\n\t.cap_link_lanes_supported = true,\n\t.self_test = hns3_self_test,\n\t.get_drvinfo = hns3_get_drvinfo,\n\t.get_link = hns3_get_link,\n\t.get_ringparam = hns3_get_ringparam,\n\t.set_ringparam = hns3_set_ringparam,\n\t.get_pauseparam = hns3_get_pauseparam,\n\t.set_pauseparam = hns3_set_pauseparam,\n\t.get_strings = hns3_get_strings,\n\t.get_ethtool_stats = hns3_get_stats,\n\t.get_sset_count = hns3_get_sset_count,\n\t.get_rxnfc = hns3_get_rxnfc,\n\t.set_rxnfc = hns3_set_rxnfc,\n\t.get_rxfh_key_size = hns3_get_rss_key_size,\n\t.get_rxfh_indir_size = hns3_get_rss_indir_size,\n\t.get_rxfh = hns3_get_rss,\n\t.set_rxfh = hns3_set_rss,\n\t.get_link_ksettings = hns3_get_link_ksettings,\n\t.set_link_ksettings = hns3_set_link_ksettings,\n\t.nway_reset = hns3_nway_reset,\n\t.get_channels = hns3_get_channels,\n\t.set_channels = hns3_set_channels,\n\t.get_coalesce = hns3_get_coalesce,\n\t.set_coalesce = hns3_set_coalesce,\n\t.get_regs_len = hns3_get_regs_len,\n\t.get_regs = hns3_get_regs,\n\t.set_phys_id = hns3_set_phys_id,\n\t.get_msglevel = hns3_get_msglevel,\n\t.set_msglevel = hns3_set_msglevel,\n\t.get_fecparam = hns3_get_fecparam,\n\t.set_fecparam = hns3_set_fecparam,\n\t.get_fec_stats = hns3_get_fec_stats,\n\t.get_module_info = hns3_get_module_info,\n\t.get_module_eeprom = hns3_get_module_eeprom,\n\t.get_priv_flags = hns3_get_priv_flags,\n\t.set_priv_flags = hns3_set_priv_flags,\n\t.get_ts_info = hns3_get_ts_info,\n\t.get_tunable = hns3_get_tunable,\n\t.set_tunable = hns3_set_tunable,\n\t.reset = hns3_set_reset,\n\t.get_link_ext_state = hns3_get_link_ext_state,\n\t.get_wol = hns3_get_wol,\n\t.set_wol = hns3_set_wol,\n};\n\nvoid hns3_ethtool_set_ops(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (h->flags & HNAE3_SUPPORT_VF)\n\t\tnetdev->ethtool_ops = &hns3vf_ethtool_ops;\n\telse\n\t\tnetdev->ethtool_ops = &hns3_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}