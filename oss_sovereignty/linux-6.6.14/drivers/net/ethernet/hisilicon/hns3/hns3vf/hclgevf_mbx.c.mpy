{
  "module_name": "hclgevf_mbx.c",
  "hash_id": "bbac803adb0da2dbdd803be970cda1c84646edc2f4a2dddce31a61102e16d66b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_mbx.c",
  "human_readable_source": "\n\n\n#include \"hclge_mbx.h\"\n#include \"hclgevf_main.h\"\n#include \"hnae3.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"hclgevf_trace.h\"\n\nstatic int hclgevf_resp_to_errno(u16 resp_code)\n{\n\treturn resp_code ? -resp_code : 0;\n}\n\n#define HCLGEVF_MBX_MATCH_ID_START\t1\nstatic void hclgevf_reset_mbx_resp_status(struct hclgevf_dev *hdev)\n{\n\t \n\thdev->mbx_resp.received_resp  = false;\n\thdev->mbx_resp.origin_mbx_msg = 0;\n\thdev->mbx_resp.resp_status    = 0;\n\thdev->mbx_resp.match_id++;\n\t \n\tif (hdev->mbx_resp.match_id == 0)\n\t\thdev->mbx_resp.match_id = HCLGEVF_MBX_MATCH_ID_START;\n\tmemset(hdev->mbx_resp.additional_info, 0, HCLGE_MBX_MAX_RESP_DATA_SIZE);\n}\n\n \nstatic int hclgevf_get_mbx_resp(struct hclgevf_dev *hdev, u16 code0, u16 code1,\n\t\t\t\tu8 *resp_data, u16 resp_len)\n{\n#define HCLGEVF_MAX_TRY_TIMES\t500\n#define HCLGEVF_SLEEP_USECOND\t1000\n\tstruct hclgevf_mbx_resp_status *mbx_resp;\n\tu16 r_code0, r_code1;\n\tint i = 0;\n\n\tif (resp_len > HCLGE_MBX_MAX_RESP_DATA_SIZE) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"VF mbx response len(=%u) exceeds maximum(=%u)\\n\",\n\t\t\tresp_len,\n\t\t\tHCLGE_MBX_MAX_RESP_DATA_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\twhile ((!hdev->mbx_resp.received_resp) && (i < HCLGEVF_MAX_TRY_TIMES)) {\n\t\tif (test_bit(HCLGE_COMM_STATE_CMD_DISABLE,\n\t\t\t     &hdev->hw.hw.comm_state))\n\t\t\treturn -EIO;\n\n\t\tusleep_range(HCLGEVF_SLEEP_USECOND, HCLGEVF_SLEEP_USECOND * 2);\n\t\ti++;\n\t}\n\n\t \n\tsmp_rmb();\n\n\tif (i >= HCLGEVF_MAX_TRY_TIMES) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"VF could not get mbx(%u,%u) resp(=%d) from PF in %d tries\\n\",\n\t\t\tcode0, code1, hdev->mbx_resp.received_resp, i);\n\t\treturn -EIO;\n\t}\n\n\tmbx_resp = &hdev->mbx_resp;\n\tr_code0 = (u16)(mbx_resp->origin_mbx_msg >> 16);\n\tr_code1 = (u16)(mbx_resp->origin_mbx_msg & 0xff);\n\n\tif (mbx_resp->resp_status)\n\t\treturn mbx_resp->resp_status;\n\n\tif (resp_data)\n\t\tmemcpy(resp_data, &mbx_resp->additional_info[0], resp_len);\n\n\thclgevf_reset_mbx_resp_status(hdev);\n\n\tif (!(r_code0 == code0 && r_code1 == code1 && !mbx_resp->resp_status)) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"VF could not match resp code(code0=%u,code1=%u), %d\\n\",\n\t\t\tcode0, code1, mbx_resp->resp_status);\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"VF could not match resp r_code(r_code0=%u,r_code1=%u)\\n\",\n\t\t\tr_code0, r_code1);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hclgevf_send_mbx_msg(struct hclgevf_dev *hdev,\n\t\t\t struct hclge_vf_to_pf_msg *send_msg, bool need_resp,\n\t\t\t u8 *resp_data, u16 resp_len)\n{\n\tstruct hclge_mbx_vf_to_pf_cmd *req;\n\tstruct hclge_desc desc;\n\tint status;\n\n\treq = (struct hclge_mbx_vf_to_pf_cmd *)desc.data;\n\n\tif (!send_msg) {\n\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\"failed to send mbx, msg is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thclgevf_cmd_setup_basic_desc(&desc, HCLGEVF_OPC_MBX_VF_TO_PF, false);\n\tif (need_resp)\n\t\thnae3_set_bit(req->mbx_need_resp, HCLGE_MBX_NEED_RESP_B, 1);\n\n\tmemcpy(&req->msg, send_msg, sizeof(struct hclge_vf_to_pf_msg));\n\n\tif (test_bit(HCLGEVF_STATE_NIC_REGISTERED, &hdev->state))\n\t\ttrace_hclge_vf_mbx_send(hdev, req);\n\n\t \n\tif (need_resp) {\n\t\tmutex_lock(&hdev->mbx_resp.mbx_mutex);\n\t\thclgevf_reset_mbx_resp_status(hdev);\n\t\treq->match_id = cpu_to_le16(hdev->mbx_resp.match_id);\n\t\tstatus = hclgevf_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (status) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"VF failed(=%d) to send mbx message to PF\\n\",\n\t\t\t\tstatus);\n\t\t\tmutex_unlock(&hdev->mbx_resp.mbx_mutex);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = hclgevf_get_mbx_resp(hdev, send_msg->code,\n\t\t\t\t\t      send_msg->subcode, resp_data,\n\t\t\t\t\t      resp_len);\n\t\tmutex_unlock(&hdev->mbx_resp.mbx_mutex);\n\t} else {\n\t\t \n\t\tstatus = hclgevf_cmd_send(&hdev->hw, &desc, 1);\n\t\tif (status) {\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"VF failed(=%d) to send mbx message to PF\\n\",\n\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic bool hclgevf_cmd_crq_empty(struct hclgevf_hw *hw)\n{\n\tu32 tail = hclgevf_read_dev(hw, HCLGE_COMM_NIC_CRQ_TAIL_REG);\n\n\treturn tail == hw->hw.cmq.crq.next_to_use;\n}\n\nstatic void hclgevf_handle_mbx_response(struct hclgevf_dev *hdev,\n\t\t\t\t\tstruct hclge_mbx_pf_to_vf_cmd *req)\n{\n\tu16 vf_mbx_msg_subcode = le16_to_cpu(req->msg.vf_mbx_msg_subcode);\n\tu16 vf_mbx_msg_code = le16_to_cpu(req->msg.vf_mbx_msg_code);\n\tstruct hclgevf_mbx_resp_status *resp = &hdev->mbx_resp;\n\tu16 resp_status = le16_to_cpu(req->msg.resp_status);\n\tu16 match_id = le16_to_cpu(req->match_id);\n\n\tif (resp->received_resp)\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\"VF mbx resp flag not clear(%u)\\n\",\n\t\t\t vf_mbx_msg_code);\n\n\tresp->origin_mbx_msg = (vf_mbx_msg_code << 16);\n\tresp->origin_mbx_msg |= vf_mbx_msg_subcode;\n\tresp->resp_status = hclgevf_resp_to_errno(resp_status);\n\tmemcpy(resp->additional_info, req->msg.resp_data,\n\t       HCLGE_MBX_MAX_RESP_DATA_SIZE * sizeof(u8));\n\n\t \n\tsmp_wmb();\n\n\tif (match_id) {\n\t\t \n\t\tif (match_id == resp->match_id)\n\t\t\tresp->received_resp = true;\n\t} else {\n\t\tresp->received_resp = true;\n\t}\n}\n\nstatic void hclgevf_handle_mbx_msg(struct hclgevf_dev *hdev,\n\t\t\t\t   struct hclge_mbx_pf_to_vf_cmd *req)\n{\n\t \n\tif (atomic_read(&hdev->arq.count) >=\n\t    HCLGE_MBX_MAX_ARQ_MSG_NUM) {\n\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t \"Async Q full, dropping msg(%u)\\n\",\n\t\t\t le16_to_cpu(req->msg.code));\n\t\treturn;\n\t}\n\n\t \n\tmemcpy(hdev->arq.msg_q[hdev->arq.tail], &req->msg,\n\t       HCLGE_MBX_MAX_ARQ_MSG_SIZE * sizeof(u16));\n\thclge_mbx_tail_ptr_move_arq(hdev->arq);\n\tatomic_inc(&hdev->arq.count);\n\n\thclgevf_mbx_task_schedule(hdev);\n}\n\nvoid hclgevf_mbx_handler(struct hclgevf_dev *hdev)\n{\n\tstruct hclge_mbx_pf_to_vf_cmd *req;\n\tstruct hclge_comm_cmq_ring *crq;\n\tstruct hclge_desc *desc;\n\tu16 flag;\n\tu16 code;\n\n\tcrq = &hdev->hw.hw.cmq.crq;\n\n\twhile (!hclgevf_cmd_crq_empty(&hdev->hw)) {\n\t\tif (test_bit(HCLGE_COMM_STATE_CMD_DISABLE,\n\t\t\t     &hdev->hw.hw.comm_state)) {\n\t\t\tdev_info(&hdev->pdev->dev, \"vf crq need init\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tdesc = &crq->desc[crq->next_to_use];\n\t\treq = (struct hclge_mbx_pf_to_vf_cmd *)desc->data;\n\n\t\tflag = le16_to_cpu(crq->desc[crq->next_to_use].flag);\n\t\tcode = le16_to_cpu(req->msg.code);\n\t\tif (unlikely(!hnae3_get_bit(flag, HCLGEVF_CMDQ_RX_OUTVLD_B))) {\n\t\t\tdev_warn(&hdev->pdev->dev,\n\t\t\t\t \"dropped invalid mailbox message, code = %u\\n\",\n\t\t\t\t code);\n\n\t\t\t \n\t\t\tcrq->desc[crq->next_to_use].flag = 0;\n\t\t\thclge_mbx_ring_ptr_move_crq(crq);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttrace_hclge_vf_mbx_get(hdev, req);\n\n\t\t \n\t\tswitch (code) {\n\t\tcase HCLGE_MBX_PF_VF_RESP:\n\t\t\thclgevf_handle_mbx_response(hdev, req);\n\t\t\tbreak;\n\t\tcase HCLGE_MBX_LINK_STAT_CHANGE:\n\t\tcase HCLGE_MBX_ASSERTING_RESET:\n\t\tcase HCLGE_MBX_LINK_STAT_MODE:\n\t\tcase HCLGE_MBX_PUSH_VLAN_INFO:\n\t\tcase HCLGE_MBX_PUSH_PROMISC_INFO:\n\t\t\thclgevf_handle_mbx_msg(hdev, req);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"VF received unsupported(%u) mbx msg from PF\\n\",\n\t\t\t\tcode);\n\t\t\tbreak;\n\t\t}\n\t\tcrq->desc[crq->next_to_use].flag = 0;\n\t\thclge_mbx_ring_ptr_move_crq(crq);\n\t}\n\n\t \n\thclgevf_write_dev(&hdev->hw, HCLGE_COMM_NIC_CRQ_HEAD_REG,\n\t\t\t  crq->next_to_use);\n}\n\nstatic void hclgevf_parse_promisc_info(struct hclgevf_dev *hdev,\n\t\t\t\t       u16 promisc_info)\n{\n\tif (!promisc_info)\n\t\tdev_info(&hdev->pdev->dev,\n\t\t\t \"Promisc mode is closed by host for being untrusted.\\n\");\n}\n\nvoid hclgevf_mbx_async_handler(struct hclgevf_dev *hdev)\n{\n\tstruct hclge_mbx_port_base_vlan *vlan_info;\n\tstruct hclge_mbx_link_status *link_info;\n\tstruct hclge_mbx_link_mode *link_mode;\n\tenum hnae3_reset_type reset_type;\n\tu16 link_status, state;\n\t__le16 *msg_q;\n\tu16 opcode;\n\tu8 duplex;\n\tu32 speed;\n\tu32 tail;\n\tu8 flag;\n\tu16 idx;\n\n\ttail = hdev->arq.tail;\n\n\t \n\twhile (tail != hdev->arq.head) {\n\t\tif (test_bit(HCLGE_COMM_STATE_CMD_DISABLE,\n\t\t\t     &hdev->hw.hw.comm_state)) {\n\t\t\tdev_info(&hdev->pdev->dev,\n\t\t\t\t \"vf crq need init in async\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmsg_q = hdev->arq.msg_q[hdev->arq.head];\n\t\topcode = le16_to_cpu(msg_q[0]);\n\t\tswitch (opcode) {\n\t\tcase HCLGE_MBX_LINK_STAT_CHANGE:\n\t\t\tlink_info = (struct hclge_mbx_link_status *)(msg_q + 1);\n\t\t\tlink_status = le16_to_cpu(link_info->link_status);\n\t\t\tspeed = le32_to_cpu(link_info->speed);\n\t\t\tduplex = (u8)le16_to_cpu(link_info->duplex);\n\t\t\tflag = link_info->flag;\n\n\t\t\t \n\t\t\thclgevf_update_speed_duplex(hdev, speed, duplex);\n\t\t\thclgevf_update_link_status(hdev, link_status);\n\n\t\t\tif (flag & HCLGE_MBX_PUSH_LINK_STATUS_EN)\n\t\t\t\tset_bit(HCLGEVF_STATE_PF_PUSH_LINK_STATUS,\n\t\t\t\t\t&hdev->state);\n\n\t\t\tbreak;\n\t\tcase HCLGE_MBX_LINK_STAT_MODE:\n\t\t\tlink_mode = (struct hclge_mbx_link_mode *)(msg_q + 1);\n\t\t\tidx = le16_to_cpu(link_mode->idx);\n\t\t\tif (idx)\n\t\t\t\thdev->hw.mac.supported =\n\t\t\t\t\tle64_to_cpu(link_mode->link_mode);\n\t\t\telse\n\t\t\t\thdev->hw.mac.advertising =\n\t\t\t\t\tle64_to_cpu(link_mode->link_mode);\n\t\t\tbreak;\n\t\tcase HCLGE_MBX_ASSERTING_RESET:\n\t\t\t \n\t\t\treset_type =\n\t\t\t\t(enum hnae3_reset_type)le16_to_cpu(msg_q[1]);\n\t\t\tset_bit(reset_type, &hdev->reset_pending);\n\t\t\tset_bit(HCLGEVF_RESET_PENDING, &hdev->reset_state);\n\t\t\thclgevf_reset_task_schedule(hdev);\n\n\t\t\tbreak;\n\t\tcase HCLGE_MBX_PUSH_VLAN_INFO:\n\t\t\tvlan_info =\n\t\t\t\t(struct hclge_mbx_port_base_vlan *)(msg_q + 1);\n\t\t\tstate = le16_to_cpu(vlan_info->state);\n\t\t\thclgevf_update_port_base_vlan_info(hdev, state,\n\t\t\t\t\t\t\t   vlan_info);\n\t\t\tbreak;\n\t\tcase HCLGE_MBX_PUSH_PROMISC_INFO:\n\t\t\thclgevf_parse_promisc_info(hdev, le16_to_cpu(msg_q[1]));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&hdev->pdev->dev,\n\t\t\t\t\"fetched unsupported(%u) message from arq\\n\",\n\t\t\t\topcode);\n\t\t\tbreak;\n\t\t}\n\n\t\thclge_mbx_head_ptr_move_arq(hdev->arq);\n\t\tatomic_dec(&hdev->arq.count);\n\t\tmsg_q = hdev->arq.msg_q[hdev->arq.head];\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}