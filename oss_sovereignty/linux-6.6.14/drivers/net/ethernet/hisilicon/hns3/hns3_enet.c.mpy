{
  "module_name": "hns3_enet.c",
  "hash_id": "a0b9120f47b6a1104ae5ee3e2bdcc50259ee85f2eb8fbfcfd651bd4bd8ce6fb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c",
  "human_readable_source": "\n\n\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#ifdef CONFIG_RFS_ACCEL\n#include <linux/cpu_rmap.h>\n#endif\n#include <linux/if_vlan.h>\n#include <linux/irq.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/skbuff.h>\n#include <linux/sctp.h>\n#include <net/gre.h>\n#include <net/gro.h>\n#include <net/ip6_checksum.h>\n#include <net/page_pool/helpers.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <net/tcp.h>\n#include <net/vxlan.h>\n#include <net/geneve.h>\n\n#include \"hnae3.h\"\n#include \"hns3_enet.h\"\n \n#define CREATE_TRACE_POINTS\n#include \"hns3_trace.h\"\n\n#define hns3_set_field(origin, shift, val)\t((origin) |= (val) << (shift))\n#define hns3_tx_bd_count(S)\tDIV_ROUND_UP(S, HNS3_MAX_BD_SIZE)\n\n#define hns3_rl_err(fmt, ...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (net_ratelimit())\t\t\t\t\t\\\n\t\t\tnetdev_err(fmt, ##__VA_ARGS__);\t\t\t\\\n\t} while (0)\n\nstatic void hns3_clear_all_ring(struct hnae3_handle *h, bool force);\n\nstatic const char hns3_driver_name[] = \"hns3\";\nstatic const char hns3_driver_string[] =\n\t\t\t\"Hisilicon Ethernet Network Driver for Hip08 Family\";\nstatic const char hns3_copyright[] = \"Copyright (c) 2017 Huawei Corporation.\";\nstatic struct hnae3_client client;\n\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \" Network interface message level setting\");\n\nstatic unsigned int tx_sgl = 1;\nmodule_param(tx_sgl, uint, 0600);\nMODULE_PARM_DESC(tx_sgl, \"Minimum number of frags when using dma_map_sg() to optimize the IOMMU mapping\");\n\nstatic bool page_pool_enabled = true;\nmodule_param(page_pool_enabled, bool, 0400);\n\n#define HNS3_SGL_SIZE(nfrag)\t(sizeof(struct scatterlist) * (nfrag) +\t\\\n\t\t\t\t sizeof(struct sg_table))\n#define HNS3_MAX_SGL_SIZE\tALIGN(HNS3_SGL_SIZE(HNS3_MAX_TSO_BD_NUM), \\\n\t\t\t\t      dma_get_cache_alignment())\n\n#define DEFAULT_MSG_LEVEL (NETIF_MSG_PROBE | NETIF_MSG_LINK | \\\n\t\t\t   NETIF_MSG_IFDOWN | NETIF_MSG_IFUP)\n\n#define HNS3_INNER_VLAN_TAG\t1\n#define HNS3_OUTER_VLAN_TAG\t2\n\n#define HNS3_MIN_TX_LEN\t\t33U\n#define HNS3_MIN_TUN_PKT_LEN\t65U\n\n \nstatic const struct pci_device_id hns3_pci_tbl[] = {\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_GE), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_25GE), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_25GE_RDMA),\n\t HNAE3_DEV_SUPPORT_ROCE_DCB_BITS},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_25GE_RDMA_MACSEC),\n\t HNAE3_DEV_SUPPORT_ROCE_DCB_BITS},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_50GE_RDMA),\n\t HNAE3_DEV_SUPPORT_ROCE_DCB_BITS},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_50GE_RDMA_MACSEC),\n\t HNAE3_DEV_SUPPORT_ROCE_DCB_BITS},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_100G_RDMA_MACSEC),\n\t HNAE3_DEV_SUPPORT_ROCE_DCB_BITS},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_200G_RDMA),\n\t HNAE3_DEV_SUPPORT_ROCE_DCB_BITS},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_VF), 0},\n\t{PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_RDMA_DCB_PFC_VF),\n\t HNAE3_DEV_SUPPORT_ROCE_DCB_BITS},\n\t \n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, hns3_pci_tbl);\n\n#define HNS3_RX_PTYPE_ENTRY(ptype, l, s, t, h) \\\n\t{\tptype, \\\n\t\tl, \\\n\t\tCHECKSUM_##s, \\\n\t\tHNS3_L3_TYPE_##t, \\\n\t\t1, \\\n\t\th}\n\n#define HNS3_RX_PTYPE_UNUSED_ENTRY(ptype) \\\n\t\t{ ptype, 0, CHECKSUM_NONE, HNS3_L3_TYPE_PARSE_FAIL, 0, \\\n\t\t  PKT_HASH_TYPE_NONE }\n\nstatic const struct hns3_rx_ptype hns3_rx_ptype_tbl[] = {\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(0),\n\tHNS3_RX_PTYPE_ENTRY(1, 0, COMPLETE, ARP, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(2, 0, COMPLETE, RARP, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(3, 0, COMPLETE, LLDP, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(4, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(5, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(6, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(7, 0, COMPLETE, CNM, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(8, 0, NONE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(9),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(10),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(11),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(12),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(13),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(14),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(15),\n\tHNS3_RX_PTYPE_ENTRY(16, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(17, 0, COMPLETE, IPV4, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(18, 0, COMPLETE, IPV4, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(19, 0, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(20, 0, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(21, 0, NONE, IPV4, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(22, 0, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(23, 0, NONE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(24, 0, NONE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(25, 0, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(26),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(27),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(28),\n\tHNS3_RX_PTYPE_ENTRY(29, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(30, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(31, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(32, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(33, 1, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(34, 1, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(35, 1, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(36, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(37, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(38),\n\tHNS3_RX_PTYPE_ENTRY(39, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(40, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(41, 1, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(42, 1, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(43, 1, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(44, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(45, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(46),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(47),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(48),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(49),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(50),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(51),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(52),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(53),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(54),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(55),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(56),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(57),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(58),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(59),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(60),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(61),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(62),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(63),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(64),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(65),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(66),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(67),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(68),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(69),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(70),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(71),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(72),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(73),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(74),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(75),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(76),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(77),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(78),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(79),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(80),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(81),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(82),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(83),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(84),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(85),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(86),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(87),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(88),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(89),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(90),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(91),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(92),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(93),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(94),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(95),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(96),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(97),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(98),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(99),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(100),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(101),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(102),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(103),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(104),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(105),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(106),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(107),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(108),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(109),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(110),\n\tHNS3_RX_PTYPE_ENTRY(111, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(112, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(113, 0, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(114, 0, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(115, 0, NONE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(116, 0, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(117, 0, NONE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(118, 0, NONE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(119, 0, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(120),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(121),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(122),\n\tHNS3_RX_PTYPE_ENTRY(123, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(124, 0, COMPLETE, PARSE_FAIL, PKT_HASH_TYPE_NONE),\n\tHNS3_RX_PTYPE_ENTRY(125, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(126, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(127, 1, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(128, 1, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(129, 1, UNNECESSARY, IPV4, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(130, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(131, 0, COMPLETE, IPV4, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(132),\n\tHNS3_RX_PTYPE_ENTRY(133, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(134, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(135, 1, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(136, 1, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(137, 1, UNNECESSARY, IPV6, PKT_HASH_TYPE_L4),\n\tHNS3_RX_PTYPE_ENTRY(138, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_ENTRY(139, 0, COMPLETE, IPV6, PKT_HASH_TYPE_L3),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(140),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(141),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(142),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(143),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(144),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(145),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(146),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(147),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(148),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(149),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(150),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(151),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(152),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(153),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(154),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(155),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(156),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(157),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(158),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(159),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(160),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(161),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(162),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(163),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(164),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(165),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(166),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(167),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(168),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(169),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(170),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(171),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(172),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(173),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(174),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(175),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(176),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(177),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(178),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(179),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(180),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(181),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(182),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(183),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(184),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(185),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(186),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(187),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(188),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(189),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(190),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(191),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(192),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(193),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(194),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(195),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(196),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(197),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(198),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(199),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(200),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(201),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(202),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(203),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(204),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(205),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(206),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(207),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(208),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(209),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(210),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(211),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(212),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(213),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(214),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(215),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(216),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(217),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(218),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(219),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(220),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(221),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(222),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(223),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(224),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(225),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(226),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(227),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(228),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(229),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(230),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(231),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(232),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(233),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(234),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(235),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(236),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(237),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(238),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(239),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(240),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(241),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(242),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(243),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(244),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(245),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(246),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(247),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(248),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(249),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(250),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(251),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(252),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(253),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(254),\n\tHNS3_RX_PTYPE_UNUSED_ENTRY(255),\n};\n\n#define HNS3_INVALID_PTYPE \\\n\t\tARRAY_SIZE(hns3_rx_ptype_tbl)\n\nstatic irqreturn_t hns3_irq_handle(int irq, void *vector)\n{\n\tstruct hns3_enet_tqp_vector *tqp_vector = vector;\n\n\tnapi_schedule_irqoff(&tqp_vector->napi);\n\ttqp_vector->event_cnt++;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hns3_nic_uninit_irq(struct hns3_nic_priv *priv)\n{\n\tstruct hns3_enet_tqp_vector *tqp_vectors;\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\ttqp_vectors = &priv->tqp_vector[i];\n\n\t\tif (tqp_vectors->irq_init_flag != HNS3_VECTOR_INITED)\n\t\t\tcontinue;\n\n\t\t \n\t\tirq_set_affinity_hint(tqp_vectors->vector_irq, NULL);\n\n\t\t \n\t\tfree_irq(tqp_vectors->vector_irq, tqp_vectors);\n\t\ttqp_vectors->irq_init_flag = HNS3_VECTOR_NOT_INITED;\n\t}\n}\n\nstatic int hns3_nic_init_irq(struct hns3_nic_priv *priv)\n{\n\tstruct hns3_enet_tqp_vector *tqp_vectors;\n\tint txrx_int_idx = 0;\n\tint rx_int_idx = 0;\n\tint tx_int_idx = 0;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\ttqp_vectors = &priv->tqp_vector[i];\n\n\t\tif (tqp_vectors->irq_init_flag == HNS3_VECTOR_INITED)\n\t\t\tcontinue;\n\n\t\tif (tqp_vectors->tx_group.ring && tqp_vectors->rx_group.ring) {\n\t\t\tsnprintf(tqp_vectors->name, HNAE3_INT_NAME_LEN,\n\t\t\t\t \"%s-%s-%s-%d\", hns3_driver_name,\n\t\t\t\t pci_name(priv->ae_handle->pdev),\n\t\t\t\t \"TxRx\", txrx_int_idx++);\n\t\t\ttxrx_int_idx++;\n\t\t} else if (tqp_vectors->rx_group.ring) {\n\t\t\tsnprintf(tqp_vectors->name, HNAE3_INT_NAME_LEN,\n\t\t\t\t \"%s-%s-%s-%d\", hns3_driver_name,\n\t\t\t\t pci_name(priv->ae_handle->pdev),\n\t\t\t\t \"Rx\", rx_int_idx++);\n\t\t} else if (tqp_vectors->tx_group.ring) {\n\t\t\tsnprintf(tqp_vectors->name, HNAE3_INT_NAME_LEN,\n\t\t\t\t \"%s-%s-%s-%d\", hns3_driver_name,\n\t\t\t\t pci_name(priv->ae_handle->pdev),\n\t\t\t\t \"Tx\", tx_int_idx++);\n\t\t} else {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\ttqp_vectors->name[HNAE3_INT_NAME_LEN - 1] = '\\0';\n\n\t\tirq_set_status_flags(tqp_vectors->vector_irq, IRQ_NOAUTOEN);\n\t\tret = request_irq(tqp_vectors->vector_irq, hns3_irq_handle, 0,\n\t\t\t\t  tqp_vectors->name, tqp_vectors);\n\t\tif (ret) {\n\t\t\tnetdev_err(priv->netdev, \"request irq(%d) fail\\n\",\n\t\t\t\t   tqp_vectors->vector_irq);\n\t\t\thns3_nic_uninit_irq(priv);\n\t\t\treturn ret;\n\t\t}\n\n\t\tirq_set_affinity_hint(tqp_vectors->vector_irq,\n\t\t\t\t      &tqp_vectors->affinity_mask);\n\n\t\ttqp_vectors->irq_init_flag = HNS3_VECTOR_INITED;\n\t}\n\n\treturn 0;\n}\n\nstatic void hns3_mask_vector_irq(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t u32 mask_en)\n{\n\twritel(mask_en, tqp_vector->mask_addr);\n}\n\nstatic void hns3_vector_enable(struct hns3_enet_tqp_vector *tqp_vector)\n{\n\tnapi_enable(&tqp_vector->napi);\n\tenable_irq(tqp_vector->vector_irq);\n\n\t \n\thns3_mask_vector_irq(tqp_vector, 1);\n}\n\nstatic void hns3_vector_disable(struct hns3_enet_tqp_vector *tqp_vector)\n{\n\t \n\thns3_mask_vector_irq(tqp_vector, 0);\n\n\tdisable_irq(tqp_vector->vector_irq);\n\tnapi_disable(&tqp_vector->napi);\n\tcancel_work_sync(&tqp_vector->rx_group.dim.work);\n\tcancel_work_sync(&tqp_vector->tx_group.dim.work);\n}\n\nvoid hns3_set_vector_coalesce_rl(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t u32 rl_value)\n{\n\tu32 rl_reg = hns3_rl_usec_to_reg(rl_value);\n\n\t \n\tif (rl_reg > 0 && !tqp_vector->tx_group.coal.adapt_enable &&\n\t    !tqp_vector->rx_group.coal.adapt_enable)\n\t\t \n\t\trl_reg |=  HNS3_INT_RL_ENABLE_MASK;\n\n\twritel(rl_reg, tqp_vector->mask_addr + HNS3_VECTOR_RL_OFFSET);\n}\n\nvoid hns3_set_vector_coalesce_rx_gl(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t    u32 gl_value)\n{\n\tu32 new_val;\n\n\tif (tqp_vector->rx_group.coal.unit_1us)\n\t\tnew_val = gl_value | HNS3_INT_GL_1US;\n\telse\n\t\tnew_val = hns3_gl_usec_to_reg(gl_value);\n\n\twritel(new_val, tqp_vector->mask_addr + HNS3_VECTOR_GL0_OFFSET);\n}\n\nvoid hns3_set_vector_coalesce_tx_gl(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t    u32 gl_value)\n{\n\tu32 new_val;\n\n\tif (tqp_vector->tx_group.coal.unit_1us)\n\t\tnew_val = gl_value | HNS3_INT_GL_1US;\n\telse\n\t\tnew_val = hns3_gl_usec_to_reg(gl_value);\n\n\twritel(new_val, tqp_vector->mask_addr + HNS3_VECTOR_GL1_OFFSET);\n}\n\nvoid hns3_set_vector_coalesce_tx_ql(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t    u32 ql_value)\n{\n\twritel(ql_value, tqp_vector->mask_addr + HNS3_VECTOR_TX_QL_OFFSET);\n}\n\nvoid hns3_set_vector_coalesce_rx_ql(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t    u32 ql_value)\n{\n\twritel(ql_value, tqp_vector->mask_addr + HNS3_VECTOR_RX_QL_OFFSET);\n}\n\nstatic void hns3_vector_coalesce_init(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t      struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(priv->ae_handle->pdev);\n\tstruct hns3_enet_coalesce *tx_coal = &tqp_vector->tx_group.coal;\n\tstruct hns3_enet_coalesce *rx_coal = &tqp_vector->rx_group.coal;\n\tstruct hns3_enet_coalesce *ptx_coal = &priv->tx_coal;\n\tstruct hns3_enet_coalesce *prx_coal = &priv->rx_coal;\n\n\ttx_coal->adapt_enable = ptx_coal->adapt_enable;\n\trx_coal->adapt_enable = prx_coal->adapt_enable;\n\n\ttx_coal->int_gl = ptx_coal->int_gl;\n\trx_coal->int_gl = prx_coal->int_gl;\n\n\trx_coal->flow_level = prx_coal->flow_level;\n\ttx_coal->flow_level = ptx_coal->flow_level;\n\n\t \n\tif (ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3) {\n\t\ttx_coal->unit_1us = 1;\n\t\trx_coal->unit_1us = 1;\n\t}\n\n\tif (ae_dev->dev_specs.int_ql_max) {\n\t\ttx_coal->ql_enable = 1;\n\t\trx_coal->ql_enable = 1;\n\t\ttx_coal->int_ql_max = ae_dev->dev_specs.int_ql_max;\n\t\trx_coal->int_ql_max = ae_dev->dev_specs.int_ql_max;\n\t\ttx_coal->int_ql = ptx_coal->int_ql;\n\t\trx_coal->int_ql = prx_coal->int_ql;\n\t}\n}\n\nstatic void\nhns3_vector_coalesce_init_hw(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t     struct hns3_nic_priv *priv)\n{\n\tstruct hns3_enet_coalesce *tx_coal = &tqp_vector->tx_group.coal;\n\tstruct hns3_enet_coalesce *rx_coal = &tqp_vector->rx_group.coal;\n\tstruct hnae3_handle *h = priv->ae_handle;\n\n\thns3_set_vector_coalesce_tx_gl(tqp_vector, tx_coal->int_gl);\n\thns3_set_vector_coalesce_rx_gl(tqp_vector, rx_coal->int_gl);\n\thns3_set_vector_coalesce_rl(tqp_vector, h->kinfo.int_rl_setting);\n\n\tif (tx_coal->ql_enable)\n\t\thns3_set_vector_coalesce_tx_ql(tqp_vector, tx_coal->int_ql);\n\n\tif (rx_coal->ql_enable)\n\t\thns3_set_vector_coalesce_rx_ql(tqp_vector, rx_coal->int_ql);\n}\n\nstatic int hns3_nic_set_real_num_queue(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_knic_private_info *kinfo = &h->kinfo;\n\tstruct hnae3_tc_info *tc_info = &kinfo->tc_info;\n\tunsigned int queue_size = kinfo->num_tqps;\n\tint i, ret;\n\n\tif (tc_info->num_tc <= 1 && !tc_info->mqprio_active) {\n\t\tnetdev_reset_tc(netdev);\n\t} else {\n\t\tret = netdev_set_num_tc(netdev, tc_info->num_tc);\n\t\tif (ret) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"netdev_set_num_tc fail, ret=%d!\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < tc_info->num_tc; i++)\n\t\t\tnetdev_set_tc_queue(netdev, i, tc_info->tqp_count[i],\n\t\t\t\t\t    tc_info->tqp_offset[i]);\n\t}\n\n\tret = netif_set_real_num_tx_queues(netdev, queue_size);\n\tif (ret) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"netif_set_real_num_tx_queues fail, ret=%d!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = netif_set_real_num_rx_queues(netdev, queue_size);\n\tif (ret) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"netif_set_real_num_rx_queues fail, ret=%d!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nu16 hns3_get_max_available_channels(struct hnae3_handle *h)\n{\n\tu16 alloc_tqps, max_rss_size, rss_size;\n\n\th->ae_algo->ops->get_tqps_and_rss_info(h, &alloc_tqps, &max_rss_size);\n\trss_size = alloc_tqps / h->kinfo.tc_info.num_tc;\n\n\treturn min_t(u16, rss_size, max_rss_size);\n}\n\nstatic void hns3_tqp_enable(struct hnae3_queue *tqp)\n{\n\tu32 rcb_reg;\n\n\trcb_reg = hns3_read_dev(tqp, HNS3_RING_EN_REG);\n\trcb_reg |= BIT(HNS3_RING_EN_B);\n\thns3_write_dev(tqp, HNS3_RING_EN_REG, rcb_reg);\n}\n\nstatic void hns3_tqp_disable(struct hnae3_queue *tqp)\n{\n\tu32 rcb_reg;\n\n\trcb_reg = hns3_read_dev(tqp, HNS3_RING_EN_REG);\n\trcb_reg &= ~BIT(HNS3_RING_EN_B);\n\thns3_write_dev(tqp, HNS3_RING_EN_REG, rcb_reg);\n}\n\nstatic void hns3_free_rx_cpu_rmap(struct net_device *netdev)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tfree_irq_cpu_rmap(netdev->rx_cpu_rmap);\n\tnetdev->rx_cpu_rmap = NULL;\n#endif\n}\n\nstatic int hns3_set_rx_cpu_rmap(struct net_device *netdev)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hns3_enet_tqp_vector *tqp_vector;\n\tint i, ret;\n\n\tif (!netdev->rx_cpu_rmap) {\n\t\tnetdev->rx_cpu_rmap = alloc_irq_cpu_rmap(priv->vector_num);\n\t\tif (!netdev->rx_cpu_rmap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\ttqp_vector = &priv->tqp_vector[i];\n\t\tret = irq_cpu_rmap_add(netdev->rx_cpu_rmap,\n\t\t\t\t       tqp_vector->vector_irq);\n\t\tif (ret) {\n\t\t\thns3_free_rx_cpu_rmap(netdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int hns3_nic_net_up(struct net_device *netdev)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint i, j;\n\tint ret;\n\n\tret = hns3_nic_reset_all_ring(h);\n\tif (ret)\n\t\treturn ret;\n\n\tclear_bit(HNS3_NIC_STATE_DOWN, &priv->state);\n\n\t \n\tfor (i = 0; i < priv->vector_num; i++)\n\t\thns3_vector_enable(&priv->tqp_vector[i]);\n\n\t \n\tfor (j = 0; j < h->kinfo.num_tqps; j++)\n\t\thns3_tqp_enable(h->kinfo.tqp[j]);\n\n\t \n\tret = h->ae_algo->ops->start ? h->ae_algo->ops->start(h) : 0;\n\tif (ret) {\n\t\tset_bit(HNS3_NIC_STATE_DOWN, &priv->state);\n\t\twhile (j--)\n\t\t\thns3_tqp_disable(h->kinfo.tqp[j]);\n\n\t\tfor (j = i - 1; j >= 0; j--)\n\t\t\thns3_vector_disable(&priv->tqp_vector[j]);\n\t}\n\n\treturn ret;\n}\n\nstatic void hns3_config_xps(struct hns3_nic_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\tstruct hns3_enet_tqp_vector *tqp_vector = &priv->tqp_vector[i];\n\t\tstruct hns3_enet_ring *ring = tqp_vector->tx_group.ring;\n\n\t\twhile (ring) {\n\t\t\tint ret;\n\n\t\t\tret = netif_set_xps_queue(priv->netdev,\n\t\t\t\t\t\t  &tqp_vector->affinity_mask,\n\t\t\t\t\t\t  ring->tqp->tqp_index);\n\t\t\tif (ret)\n\t\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t\t    \"set xps queue failed: %d\", ret);\n\n\t\t\tring = ring->next;\n\t\t}\n\t}\n}\n\nstatic int hns3_nic_net_open(struct net_device *netdev)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_knic_private_info *kinfo;\n\tint i, ret;\n\n\tif (hns3_nic_resetting(netdev))\n\t\treturn -EBUSY;\n\n\tif (!test_bit(HNS3_NIC_STATE_DOWN, &priv->state)) {\n\t\tnetdev_warn(netdev, \"net open repeatedly!\\n\");\n\t\treturn 0;\n\t}\n\n\tnetif_carrier_off(netdev);\n\n\tret = hns3_nic_set_real_num_queue(netdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_nic_net_up(netdev);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"net up fail, ret=%d!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tkinfo = &h->kinfo;\n\tfor (i = 0; i < HNAE3_MAX_USER_PRIO; i++)\n\t\tnetdev_set_prio_tc_map(netdev, i, kinfo->tc_info.prio_tc[i]);\n\n\tif (h->ae_algo->ops->set_timer_task)\n\t\th->ae_algo->ops->set_timer_task(priv->ae_handle, true);\n\n\thns3_config_xps(priv);\n\n\tnetif_dbg(h, drv, netdev, \"net open\\n\");\n\n\treturn 0;\n}\n\nstatic void hns3_reset_tx_queue(struct hnae3_handle *h)\n{\n\tstruct net_device *ndev = h->kinfo.netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct netdev_queue *dev_queue;\n\tu32 i;\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\tdev_queue = netdev_get_tx_queue(ndev,\n\t\t\t\t\t\tpriv->ring[i].queue_index);\n\t\tnetdev_tx_reset_queue(dev_queue);\n\t}\n}\n\nstatic void hns3_nic_net_down(struct net_device *netdev)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tconst struct hnae3_ae_ops *ops;\n\tint i;\n\n\t \n\tfor (i = 0; i < priv->vector_num; i++)\n\t\thns3_vector_disable(&priv->tqp_vector[i]);\n\n\t \n\tfor (i = 0; i < h->kinfo.num_tqps; i++)\n\t\thns3_tqp_disable(h->kinfo.tqp[i]);\n\n\t \n\tops = priv->ae_handle->ae_algo->ops;\n\tif (ops->stop)\n\t\tops->stop(priv->ae_handle);\n\n\t \n\tif (!hns3_nic_resetting(netdev))\n\t\thns3_clear_all_ring(priv->ae_handle, false);\n\n\thns3_reset_tx_queue(priv->ae_handle);\n}\n\nstatic int hns3_nic_net_stop(struct net_device *netdev)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (test_and_set_bit(HNS3_NIC_STATE_DOWN, &priv->state))\n\t\treturn 0;\n\n\tnetif_dbg(h, drv, netdev, \"net stop\\n\");\n\n\tif (h->ae_algo->ops->set_timer_task)\n\t\th->ae_algo->ops->set_timer_task(priv->ae_handle, false);\n\n\tnetif_carrier_off(netdev);\n\tnetif_tx_disable(netdev);\n\n\thns3_nic_net_down(netdev);\n\n\treturn 0;\n}\n\nstatic int hns3_nic_uc_sync(struct net_device *netdev,\n\t\t\t    const unsigned char *addr)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (h->ae_algo->ops->add_uc_addr)\n\t\treturn h->ae_algo->ops->add_uc_addr(h, addr);\n\n\treturn 0;\n}\n\nstatic int hns3_nic_uc_unsync(struct net_device *netdev,\n\t\t\t      const unsigned char *addr)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\t \n\tif (ether_addr_equal(addr, netdev->dev_addr))\n\t\treturn 0;\n\n\tif (h->ae_algo->ops->rm_uc_addr)\n\t\treturn h->ae_algo->ops->rm_uc_addr(h, addr);\n\n\treturn 0;\n}\n\nstatic int hns3_nic_mc_sync(struct net_device *netdev,\n\t\t\t    const unsigned char *addr)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (h->ae_algo->ops->add_mc_addr)\n\t\treturn h->ae_algo->ops->add_mc_addr(h, addr);\n\n\treturn 0;\n}\n\nstatic int hns3_nic_mc_unsync(struct net_device *netdev,\n\t\t\t      const unsigned char *addr)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (h->ae_algo->ops->rm_mc_addr)\n\t\treturn h->ae_algo->ops->rm_mc_addr(h, addr);\n\n\treturn 0;\n}\n\nstatic u8 hns3_get_netdev_flags(struct net_device *netdev)\n{\n\tu8 flags = 0;\n\n\tif (netdev->flags & IFF_PROMISC)\n\t\tflags = HNAE3_USER_UPE | HNAE3_USER_MPE | HNAE3_BPE;\n\telse if (netdev->flags & IFF_ALLMULTI)\n\t\tflags = HNAE3_USER_MPE;\n\n\treturn flags;\n}\n\nstatic void hns3_nic_set_rx_mode(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tu8 new_flags;\n\n\tnew_flags = hns3_get_netdev_flags(netdev);\n\n\t__dev_uc_sync(netdev, hns3_nic_uc_sync, hns3_nic_uc_unsync);\n\t__dev_mc_sync(netdev, hns3_nic_mc_sync, hns3_nic_mc_unsync);\n\n\t \n\th->netdev_flags = new_flags;\n\thns3_request_update_promisc_mode(h);\n}\n\nvoid hns3_request_update_promisc_mode(struct hnae3_handle *handle)\n{\n\tconst struct hnae3_ae_ops *ops = handle->ae_algo->ops;\n\n\tif (ops->request_update_promisc_mode)\n\t\tops->request_update_promisc_mode(handle);\n}\n\nstatic u32 hns3_tx_spare_space(struct hns3_enet_ring *ring)\n{\n\tstruct hns3_tx_spare *tx_spare = ring->tx_spare;\n\tu32 ntc, ntu;\n\n\t \n\tntc = smp_load_acquire(&tx_spare->last_to_clean);\n\tntu = tx_spare->next_to_use;\n\n\tif (ntc > ntu)\n\t\treturn ntc - ntu - 1;\n\n\t \n\treturn max(ntc, tx_spare->len - ntu) - 1;\n}\n\nstatic void hns3_tx_spare_update(struct hns3_enet_ring *ring)\n{\n\tstruct hns3_tx_spare *tx_spare = ring->tx_spare;\n\n\tif (!tx_spare ||\n\t    tx_spare->last_to_clean == tx_spare->next_to_clean)\n\t\treturn;\n\n\t \n\tsmp_store_release(&tx_spare->last_to_clean,\n\t\t\t  tx_spare->next_to_clean);\n}\n\nstatic bool hns3_can_use_tx_bounce(struct hns3_enet_ring *ring,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u32 space)\n{\n\tu32 len = skb->len <= ring->tx_copybreak ? skb->len :\n\t\t\t\tskb_headlen(skb);\n\n\tif (len > ring->tx_copybreak)\n\t\treturn false;\n\n\tif (ALIGN(len, dma_get_cache_alignment()) > space) {\n\t\thns3_ring_stats_update(ring, tx_spare_full);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool hns3_can_use_tx_sgl(struct hns3_enet_ring *ring,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu32 space)\n{\n\tif (skb->len <= ring->tx_copybreak || !tx_sgl ||\n\t    (!skb_has_frag_list(skb) &&\n\t     skb_shinfo(skb)->nr_frags < tx_sgl))\n\t\treturn false;\n\n\tif (space < HNS3_MAX_SGL_SIZE) {\n\t\thns3_ring_stats_update(ring, tx_spare_full);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void hns3_init_tx_spare_buffer(struct hns3_enet_ring *ring)\n{\n\tu32 alloc_size = ring->tqp->handle->kinfo.tx_spare_buf_size;\n\tstruct hns3_tx_spare *tx_spare;\n\tstruct page *page;\n\tdma_addr_t dma;\n\tint order;\n\n\tif (!alloc_size)\n\t\treturn;\n\n\torder = get_order(alloc_size);\n\tif (order > MAX_ORDER) {\n\t\tif (net_ratelimit())\n\t\t\tdev_warn(ring_to_dev(ring), \"failed to allocate tx spare buffer, exceed to max order\\n\");\n\t\treturn;\n\t}\n\n\ttx_spare = devm_kzalloc(ring_to_dev(ring), sizeof(*tx_spare),\n\t\t\t\tGFP_KERNEL);\n\tif (!tx_spare) {\n\t\t \n\t\tdev_warn(ring_to_dev(ring), \"failed to allocate hns3_tx_spare\\n\");\n\t\tgoto devm_kzalloc_error;\n\t}\n\n\tpage = alloc_pages_node(dev_to_node(ring_to_dev(ring)),\n\t\t\t\tGFP_KERNEL, order);\n\tif (!page) {\n\t\tdev_warn(ring_to_dev(ring), \"failed to allocate tx spare pages\\n\");\n\t\tgoto alloc_pages_error;\n\t}\n\n\tdma = dma_map_page(ring_to_dev(ring), page, 0,\n\t\t\t   PAGE_SIZE << order, DMA_TO_DEVICE);\n\tif (dma_mapping_error(ring_to_dev(ring), dma)) {\n\t\tdev_warn(ring_to_dev(ring), \"failed to map pages for tx spare\\n\");\n\t\tgoto dma_mapping_error;\n\t}\n\n\ttx_spare->dma = dma;\n\ttx_spare->buf = page_address(page);\n\ttx_spare->len = PAGE_SIZE << order;\n\tring->tx_spare = tx_spare;\n\treturn;\n\ndma_mapping_error:\n\tput_page(page);\nalloc_pages_error:\n\tdevm_kfree(ring_to_dev(ring), tx_spare);\ndevm_kzalloc_error:\n\tring->tqp->handle->kinfo.tx_spare_buf_size = 0;\n}\n\n \nstatic void *hns3_tx_spare_alloc(struct hns3_enet_ring *ring,\n\t\t\t\t unsigned int size, dma_addr_t *dma,\n\t\t\t\t u32 *cb_len)\n{\n\tstruct hns3_tx_spare *tx_spare = ring->tx_spare;\n\tu32 ntu = tx_spare->next_to_use;\n\n\tsize = ALIGN(size, dma_get_cache_alignment());\n\t*cb_len = size;\n\n\t \n\tif (ntu + size > tx_spare->len) {\n\t\t*cb_len += (tx_spare->len - ntu);\n\t\tntu = 0;\n\t}\n\n\ttx_spare->next_to_use = ntu + size;\n\tif (tx_spare->next_to_use == tx_spare->len)\n\t\ttx_spare->next_to_use = 0;\n\n\t*dma = tx_spare->dma + ntu;\n\n\treturn tx_spare->buf + ntu;\n}\n\nstatic void hns3_tx_spare_rollback(struct hns3_enet_ring *ring, u32 len)\n{\n\tstruct hns3_tx_spare *tx_spare = ring->tx_spare;\n\n\tif (len > tx_spare->next_to_use) {\n\t\tlen -= tx_spare->next_to_use;\n\t\ttx_spare->next_to_use = tx_spare->len - len;\n\t} else {\n\t\ttx_spare->next_to_use -= len;\n\t}\n}\n\nstatic void hns3_tx_spare_reclaim_cb(struct hns3_enet_ring *ring,\n\t\t\t\t     struct hns3_desc_cb *cb)\n{\n\tstruct hns3_tx_spare *tx_spare = ring->tx_spare;\n\tu32 ntc = tx_spare->next_to_clean;\n\tu32 len = cb->length;\n\n\ttx_spare->next_to_clean += len;\n\n\tif (tx_spare->next_to_clean >= tx_spare->len) {\n\t\ttx_spare->next_to_clean -= tx_spare->len;\n\n\t\tif (tx_spare->next_to_clean) {\n\t\t\tntc = 0;\n\t\t\tlen = tx_spare->next_to_clean;\n\t\t}\n\t}\n\n\t \n\tif (cb->type & (DESC_TYPE_BOUNCE_HEAD | DESC_TYPE_BOUNCE_ALL)) {\n\t\tdma_addr_t dma = tx_spare->dma + ntc;\n\n\t\tdma_sync_single_for_cpu(ring_to_dev(ring), dma, len,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t} else {\n\t\tstruct sg_table *sgt = tx_spare->buf + ntc;\n\n\t\tdma_unmap_sg(ring_to_dev(ring), sgt->sgl, sgt->orig_nents,\n\t\t\t     DMA_TO_DEVICE);\n\t}\n}\n\nstatic int hns3_set_tso(struct sk_buff *skb, u32 *paylen_fdop_ol4cs,\n\t\t\tu16 *mss, u32 *type_cs_vlan_tso, u32 *send_bytes)\n{\n\tu32 l4_offset, hdr_len;\n\tunion l3_hdr_info l3;\n\tunion l4_hdr_info l4;\n\tu32 l4_paylen;\n\tint ret;\n\n\tif (!skb_is_gso(skb))\n\t\treturn 0;\n\n\tret = skb_cow_head(skb, 0);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tl3.hdr = skb_network_header(skb);\n\tl4.hdr = skb_transport_header(skb);\n\n\t \n\tif (l3.v4->version == 4)\n\t\tl3.v4->check = 0;\n\n\t \n\tif (skb_shinfo(skb)->gso_type & (SKB_GSO_GRE |\n\t\t\t\t\t SKB_GSO_GRE_CSUM |\n\t\t\t\t\t SKB_GSO_UDP_TUNNEL |\n\t\t\t\t\t SKB_GSO_UDP_TUNNEL_CSUM)) {\n\t\t \n\t\tl3.hdr = skb_inner_network_header(skb);\n\t\tl4.hdr = skb_inner_transport_header(skb);\n\n\t\t \n\t\tif (l3.v4->version == 4)\n\t\t\tl3.v4->check = 0;\n\t}\n\n\t \n\tl4_offset = l4.hdr - skb->data;\n\n\t \n\tl4_paylen = skb->len - l4_offset;\n\n\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4) {\n\t\thdr_len = sizeof(*l4.udp) + l4_offset;\n\t\tcsum_replace_by_diff(&l4.udp->check,\n\t\t\t\t     (__force __wsum)htonl(l4_paylen));\n\t} else {\n\t\thdr_len = (l4.tcp->doff << 2) + l4_offset;\n\t\tcsum_replace_by_diff(&l4.tcp->check,\n\t\t\t\t     (__force __wsum)htonl(l4_paylen));\n\t}\n\n\t*send_bytes = (skb_shinfo(skb)->gso_segs - 1) * hdr_len + skb->len;\n\n\t \n\t*paylen_fdop_ol4cs = skb->len - hdr_len;\n\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_TSO_B, 1);\n\n\t \n\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM)\n\t\thns3_set_field(*paylen_fdop_ol4cs, HNS3_TXD_OL4CS_B, 1);\n\n\t \n\t*mss = skb_shinfo(skb)->gso_size;\n\n\ttrace_hns3_tso(skb);\n\n\treturn 0;\n}\n\nstatic int hns3_get_l4_protocol(struct sk_buff *skb, u8 *ol4_proto,\n\t\t\t\tu8 *il4_proto)\n{\n\tunion l3_hdr_info l3;\n\tunsigned char *l4_hdr;\n\tunsigned char *exthdr;\n\tu8 l4_proto_tmp;\n\t__be16 frag_off;\n\n\t \n\tl3.hdr = skb_network_header(skb);\n\tl4_hdr = skb_transport_header(skb);\n\n\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\texthdr = l3.hdr + sizeof(*l3.v6);\n\t\tl4_proto_tmp = l3.v6->nexthdr;\n\t\tif (l4_hdr != exthdr)\n\t\t\tipv6_skip_exthdr(skb, exthdr - skb->data,\n\t\t\t\t\t &l4_proto_tmp, &frag_off);\n\t} else if (skb->protocol == htons(ETH_P_IP)) {\n\t\tl4_proto_tmp = l3.v4->protocol;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t*ol4_proto = l4_proto_tmp;\n\n\t \n\tif (!skb->encapsulation) {\n\t\t*il4_proto = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tl3.hdr = skb_inner_network_header(skb);\n\tl4_hdr = skb_inner_transport_header(skb);\n\n\tif (l3.v6->version == 6) {\n\t\texthdr = l3.hdr + sizeof(*l3.v6);\n\t\tl4_proto_tmp = l3.v6->nexthdr;\n\t\tif (l4_hdr != exthdr)\n\t\t\tipv6_skip_exthdr(skb, exthdr - skb->data,\n\t\t\t\t\t &l4_proto_tmp, &frag_off);\n\t} else if (l3.v4->version == 4) {\n\t\tl4_proto_tmp = l3.v4->protocol;\n\t}\n\n\t*il4_proto = l4_proto_tmp;\n\n\treturn 0;\n}\n\n \nstatic bool hns3_tunnel_csum_bug(struct sk_buff *skb)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(skb->dev);\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(priv->ae_handle->pdev);\n\tunion l4_hdr_info l4;\n\n\t \n\tif (ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3)\n\t\treturn false;\n\n\tl4.hdr = skb_transport_header(skb);\n\n\tif (!(!skb->encapsulation &&\n\t      (l4.udp->dest == htons(IANA_VXLAN_UDP_PORT) ||\n\t      l4.udp->dest == htons(GENEVE_UDP_PORT) ||\n\t      l4.udp->dest == htons(IANA_VXLAN_GPE_UDP_PORT))))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void hns3_set_outer_l2l3l4(struct sk_buff *skb, u8 ol4_proto,\n\t\t\t\t  u32 *ol_type_vlan_len_msec)\n{\n\tu32 l2_len, l3_len, l4_len;\n\tunsigned char *il2_hdr;\n\tunion l3_hdr_info l3;\n\tunion l4_hdr_info l4;\n\n\tl3.hdr = skb_network_header(skb);\n\tl4.hdr = skb_transport_header(skb);\n\n\t \n\tl2_len = l3.hdr - skb->data;\n\thns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_L2LEN_S, l2_len >> 1);\n\n\t \n\tl3_len = l4.hdr - l3.hdr;\n\thns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_L3LEN_S, l3_len >> 2);\n\n\til2_hdr = skb_inner_mac_header(skb);\n\t \n\tl4_len = il2_hdr - l4.hdr;\n\thns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_L4LEN_S, l4_len >> 2);\n\n\t \n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tif (skb_is_gso(skb))\n\t\t\thns3_set_field(*ol_type_vlan_len_msec,\n\t\t\t\t       HNS3_TXD_OL3T_S,\n\t\t\t\t       HNS3_OL3T_IPV4_CSUM);\n\t\telse\n\t\t\thns3_set_field(*ol_type_vlan_len_msec,\n\t\t\t\t       HNS3_TXD_OL3T_S,\n\t\t\t\t       HNS3_OL3T_IPV4_NO_CSUM);\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\thns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_OL3T_S,\n\t\t\t       HNS3_OL3T_IPV6);\n\t}\n\n\tif (ol4_proto == IPPROTO_UDP)\n\t\thns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_TUNTYPE_S,\n\t\t\t       HNS3_TUN_MAC_IN_UDP);\n\telse if (ol4_proto == IPPROTO_GRE)\n\t\thns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_TUNTYPE_S,\n\t\t\t       HNS3_TUN_NVGRE);\n}\n\nstatic void hns3_set_l3_type(struct sk_buff *skb, union l3_hdr_info l3,\n\t\t\t     u32 *type_cs_vlan_tso)\n{\n\tif (l3.v4->version == 4) {\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L3T_S,\n\t\t\t       HNS3_L3T_IPV4);\n\n\t\t \n\t\tif (skb_is_gso(skb))\n\t\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L3CS_B, 1);\n\t} else if (l3.v6->version == 6) {\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L3T_S,\n\t\t\t       HNS3_L3T_IPV6);\n\t}\n}\n\nstatic int hns3_set_l4_csum_length(struct sk_buff *skb, union l4_hdr_info l4,\n\t\t\t\t   u32 l4_proto, u32 *type_cs_vlan_tso)\n{\n\t \n\tswitch (l4_proto) {\n\tcase IPPROTO_TCP:\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4CS_B, 1);\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4T_S,\n\t\t\t       HNS3_L4T_TCP);\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4LEN_S,\n\t\t\t       l4.tcp->doff);\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tif (hns3_tunnel_csum_bug(skb)) {\n\t\t\tint ret = skb_put_padto(skb, HNS3_MIN_TUN_PKT_LEN);\n\n\t\t\treturn ret ? ret : skb_checksum_help(skb);\n\t\t}\n\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4CS_B, 1);\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4T_S,\n\t\t\t       HNS3_L4T_UDP);\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4LEN_S,\n\t\t\t       (sizeof(struct udphdr) >> 2));\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4CS_B, 1);\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4T_S,\n\t\t\t       HNS3_L4T_SCTP);\n\t\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L4LEN_S,\n\t\t\t       (sizeof(struct sctphdr) >> 2));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (skb_is_gso(skb))\n\t\t\treturn -EDOM;\n\n\t\t \n\t\treturn skb_checksum_help(skb);\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_set_l2l3l4(struct sk_buff *skb, u8 ol4_proto,\n\t\t\t   u8 il4_proto, u32 *type_cs_vlan_tso,\n\t\t\t   u32 *ol_type_vlan_len_msec)\n{\n\tunsigned char *l2_hdr = skb->data;\n\tu32 l4_proto = ol4_proto;\n\tunion l4_hdr_info l4;\n\tunion l3_hdr_info l3;\n\tu32 l2_len, l3_len;\n\n\tl4.hdr = skb_transport_header(skb);\n\tl3.hdr = skb_network_header(skb);\n\n\t \n\tif (skb->encapsulation) {\n\t\t \n\t\tif (!(ol4_proto == IPPROTO_UDP || ol4_proto == IPPROTO_GRE)) {\n\t\t\t \n\t\t\tif (skb_is_gso(skb))\n\t\t\t\treturn -EDOM;\n\n\t\t\t \n\t\t\treturn skb_checksum_help(skb);\n\t\t}\n\n\t\thns3_set_outer_l2l3l4(skb, ol4_proto, ol_type_vlan_len_msec);\n\n\t\t \n\t\tl2_hdr = skb_inner_mac_header(skb);\n\t\tl3.hdr = skb_inner_network_header(skb);\n\t\tl4.hdr = skb_inner_transport_header(skb);\n\t\tl4_proto = il4_proto;\n\t}\n\n\thns3_set_l3_type(skb, l3, type_cs_vlan_tso);\n\n\t \n\tl2_len = l3.hdr - l2_hdr;\n\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L2LEN_S, l2_len >> 1);\n\n\t \n\tl3_len = l4.hdr - l3.hdr;\n\thns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L3LEN_S, l3_len >> 2);\n\n\treturn hns3_set_l4_csum_length(skb, l4, l4_proto, type_cs_vlan_tso);\n}\n\nstatic int hns3_handle_vtags(struct hns3_enet_ring *tx_ring,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct hnae3_handle *handle = tx_ring->tqp->handle;\n\tstruct hnae3_ae_dev *ae_dev;\n\tstruct vlan_ethhdr *vhdr;\n\tint rc;\n\n\tif (!(skb->protocol == htons(ETH_P_8021Q) ||\n\t      skb_vlan_tag_present(skb)))\n\t\treturn 0;\n\n\t \n\tae_dev = pci_get_drvdata(handle->pdev);\n\tif (unlikely(skb_vlan_tagged_multi(skb) &&\n\t\t     ae_dev->dev_version <= HNAE3_DEVICE_VERSION_V2 &&\n\t\t     handle->port_base_vlan_state ==\n\t\t     HNAE3_PORT_BASE_VLAN_ENABLE))\n\t\treturn -EINVAL;\n\n\tif (skb->protocol == htons(ETH_P_8021Q) &&\n\t    !(handle->kinfo.netdev->features & NETIF_F_HW_VLAN_CTAG_TX)) {\n\t\t \n\t\tskb->protocol = vlan_get_protocol(skb);\n\t\treturn 0;\n\t}\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\t \n\t\tif (skb->protocol == htons(ETH_P_8021Q) &&\n\t\t    handle->port_base_vlan_state ==\n\t\t    HNAE3_PORT_BASE_VLAN_DISABLE)\n\t\t\trc = HNS3_OUTER_VLAN_TAG;\n\t\telse\n\t\t\trc = HNS3_INNER_VLAN_TAG;\n\n\t\tskb->protocol = vlan_get_protocol(skb);\n\t\treturn rc;\n\t}\n\n\trc = skb_cow_head(skb, 0);\n\tif (unlikely(rc < 0))\n\t\treturn rc;\n\n\tvhdr = skb_vlan_eth_hdr(skb);\n\tvhdr->h_vlan_TCI |= cpu_to_be16((skb->priority << VLAN_PRIO_SHIFT)\n\t\t\t\t\t & VLAN_PRIO_MASK);\n\n\tskb->protocol = vlan_get_protocol(skb);\n\treturn 0;\n}\n\n \nstatic bool hns3_check_hw_tx_csum(struct sk_buff *skb)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(skb->dev);\n\n\t \n\tif (skb_csum_is_sctp(skb) || skb_is_gso(skb) ||\n\t    !test_bit(HNS3_NIC_STATE_HW_TX_CSUM_ENABLE, &priv->state))\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct hns3_desc_param {\n\tu32 paylen_ol4cs;\n\tu32 ol_type_vlan_len_msec;\n\tu32 type_cs_vlan_tso;\n\tu16 mss_hw_csum;\n\tu16 inner_vtag;\n\tu16 out_vtag;\n};\n\nstatic void hns3_init_desc_data(struct sk_buff *skb, struct hns3_desc_param *pa)\n{\n\tpa->paylen_ol4cs = skb->len;\n\tpa->ol_type_vlan_len_msec = 0;\n\tpa->type_cs_vlan_tso = 0;\n\tpa->mss_hw_csum = 0;\n\tpa->inner_vtag = 0;\n\tpa->out_vtag = 0;\n}\n\nstatic int hns3_handle_vlan_info(struct hns3_enet_ring *ring,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct hns3_desc_param *param)\n{\n\tint ret;\n\n\tret = hns3_handle_vtags(ring, skb);\n\tif (unlikely(ret < 0)) {\n\t\thns3_ring_stats_update(ring, tx_vlan_err);\n\t\treturn ret;\n\t} else if (ret == HNS3_INNER_VLAN_TAG) {\n\t\tparam->inner_vtag = skb_vlan_tag_get(skb);\n\t\tparam->inner_vtag |= (skb->priority << VLAN_PRIO_SHIFT) &\n\t\t\t\tVLAN_PRIO_MASK;\n\t\thns3_set_field(param->type_cs_vlan_tso, HNS3_TXD_VLAN_B, 1);\n\t} else if (ret == HNS3_OUTER_VLAN_TAG) {\n\t\tparam->out_vtag = skb_vlan_tag_get(skb);\n\t\tparam->out_vtag |= (skb->priority << VLAN_PRIO_SHIFT) &\n\t\t\t\tVLAN_PRIO_MASK;\n\t\thns3_set_field(param->ol_type_vlan_len_msec, HNS3_TXD_OVLAN_B,\n\t\t\t       1);\n\t}\n\treturn 0;\n}\n\nstatic int hns3_handle_csum_partial(struct hns3_enet_ring *ring,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct hns3_desc_cb *desc_cb,\n\t\t\t\t    struct hns3_desc_param *param)\n{\n\tu8 ol4_proto, il4_proto;\n\tint ret;\n\n\tif (hns3_check_hw_tx_csum(skb)) {\n\t\t \n\t\thns3_set_field(param->type_cs_vlan_tso, HNS3_TXD_CSUM_START_S,\n\t\t\t       skb_checksum_start_offset(skb) >> 1);\n\t\thns3_set_field(param->ol_type_vlan_len_msec,\n\t\t\t       HNS3_TXD_CSUM_OFFSET_S,\n\t\t\t       skb->csum_offset >> 1);\n\t\tparam->mss_hw_csum |= BIT(HNS3_TXD_HW_CS_B);\n\t\treturn 0;\n\t}\n\n\tskb_reset_mac_len(skb);\n\n\tret = hns3_get_l4_protocol(skb, &ol4_proto, &il4_proto);\n\tif (unlikely(ret < 0)) {\n\t\thns3_ring_stats_update(ring, tx_l4_proto_err);\n\t\treturn ret;\n\t}\n\n\tret = hns3_set_l2l3l4(skb, ol4_proto, il4_proto,\n\t\t\t      &param->type_cs_vlan_tso,\n\t\t\t      &param->ol_type_vlan_len_msec);\n\tif (unlikely(ret < 0)) {\n\t\thns3_ring_stats_update(ring, tx_l2l3l4_err);\n\t\treturn ret;\n\t}\n\n\tret = hns3_set_tso(skb, &param->paylen_ol4cs, &param->mss_hw_csum,\n\t\t\t   &param->type_cs_vlan_tso, &desc_cb->send_bytes);\n\tif (unlikely(ret < 0)) {\n\t\thns3_ring_stats_update(ring, tx_tso_err);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int hns3_fill_skb_desc(struct hns3_enet_ring *ring,\n\t\t\t      struct sk_buff *skb, struct hns3_desc *desc,\n\t\t\t      struct hns3_desc_cb *desc_cb)\n{\n\tstruct hns3_desc_param param;\n\tint ret;\n\n\thns3_init_desc_data(skb, &param);\n\tret = hns3_handle_vlan_info(ring, skb, &param);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tdesc_cb->send_bytes = skb->len;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tret = hns3_handle_csum_partial(ring, skb, desc_cb, &param);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tdesc->tx.ol_type_vlan_len_msec =\n\t\tcpu_to_le32(param.ol_type_vlan_len_msec);\n\tdesc->tx.type_cs_vlan_tso_len = cpu_to_le32(param.type_cs_vlan_tso);\n\tdesc->tx.paylen_ol4cs = cpu_to_le32(param.paylen_ol4cs);\n\tdesc->tx.mss_hw_csum = cpu_to_le16(param.mss_hw_csum);\n\tdesc->tx.vlan_tag = cpu_to_le16(param.inner_vtag);\n\tdesc->tx.outer_vlan_tag = cpu_to_le16(param.out_vtag);\n\n\treturn 0;\n}\n\nstatic int hns3_fill_desc(struct hns3_enet_ring *ring, dma_addr_t dma,\n\t\t\t  unsigned int size)\n{\n#define HNS3_LIKELY_BD_NUM\t1\n\n\tstruct hns3_desc *desc = &ring->desc[ring->next_to_use];\n\tunsigned int frag_buf_num;\n\tint k, sizeoflast;\n\n\tif (likely(size <= HNS3_MAX_BD_SIZE)) {\n\t\tdesc->addr = cpu_to_le64(dma);\n\t\tdesc->tx.send_size = cpu_to_le16(size);\n\t\tdesc->tx.bdtp_fe_sc_vld_ra_ri =\n\t\t\tcpu_to_le16(BIT(HNS3_TXD_VLD_B));\n\n\t\ttrace_hns3_tx_desc(ring, ring->next_to_use);\n\t\tring_ptr_move_fw(ring, next_to_use);\n\t\treturn HNS3_LIKELY_BD_NUM;\n\t}\n\n\tfrag_buf_num = hns3_tx_bd_count(size);\n\tsizeoflast = size % HNS3_MAX_BD_SIZE;\n\tsizeoflast = sizeoflast ? sizeoflast : HNS3_MAX_BD_SIZE;\n\n\t \n\tfor (k = 0; k < frag_buf_num; k++) {\n\t\t \n\t\tdesc->addr = cpu_to_le64(dma + HNS3_MAX_BD_SIZE * k);\n\t\tdesc->tx.send_size = cpu_to_le16((k == frag_buf_num - 1) ?\n\t\t\t\t     (u16)sizeoflast : (u16)HNS3_MAX_BD_SIZE);\n\t\tdesc->tx.bdtp_fe_sc_vld_ra_ri =\n\t\t\t\tcpu_to_le16(BIT(HNS3_TXD_VLD_B));\n\n\t\ttrace_hns3_tx_desc(ring, ring->next_to_use);\n\t\t \n\t\tring_ptr_move_fw(ring, next_to_use);\n\n\t\tdesc = &ring->desc[ring->next_to_use];\n\t}\n\n\treturn frag_buf_num;\n}\n\nstatic int hns3_map_and_fill_desc(struct hns3_enet_ring *ring, void *priv,\n\t\t\t\t  unsigned int type)\n{\n\tstruct hns3_desc_cb *desc_cb = &ring->desc_cb[ring->next_to_use];\n\tstruct device *dev = ring_to_dev(ring);\n\tunsigned int size;\n\tdma_addr_t dma;\n\n\tif (type & (DESC_TYPE_FRAGLIST_SKB | DESC_TYPE_SKB)) {\n\t\tstruct sk_buff *skb = (struct sk_buff *)priv;\n\n\t\tsize = skb_headlen(skb);\n\t\tif (!size)\n\t\t\treturn 0;\n\n\t\tdma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);\n\t} else if (type & DESC_TYPE_BOUNCE_HEAD) {\n\t\t \n\t\treturn 0;\n\t} else {\n\t\tskb_frag_t *frag = (skb_frag_t *)priv;\n\n\t\tsize = skb_frag_size(frag);\n\t\tif (!size)\n\t\t\treturn 0;\n\n\t\tdma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);\n\t}\n\n\tif (unlikely(dma_mapping_error(dev, dma))) {\n\t\thns3_ring_stats_update(ring, sw_err_cnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc_cb->priv = priv;\n\tdesc_cb->length = size;\n\tdesc_cb->dma = dma;\n\tdesc_cb->type = type;\n\n\treturn hns3_fill_desc(ring, dma, size);\n}\n\nstatic unsigned int hns3_skb_bd_num(struct sk_buff *skb, unsigned int *bd_size,\n\t\t\t\t    unsigned int bd_num)\n{\n\tunsigned int size;\n\tint i;\n\n\tsize = skb_headlen(skb);\n\twhile (size > HNS3_MAX_BD_SIZE) {\n\t\tbd_size[bd_num++] = HNS3_MAX_BD_SIZE;\n\t\tsize -= HNS3_MAX_BD_SIZE;\n\n\t\tif (bd_num > HNS3_MAX_TSO_BD_NUM)\n\t\t\treturn bd_num;\n\t}\n\n\tif (size) {\n\t\tbd_size[bd_num++] = size;\n\t\tif (bd_num > HNS3_MAX_TSO_BD_NUM)\n\t\t\treturn bd_num;\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tsize = skb_frag_size(frag);\n\t\tif (!size)\n\t\t\tcontinue;\n\n\t\twhile (size > HNS3_MAX_BD_SIZE) {\n\t\t\tbd_size[bd_num++] = HNS3_MAX_BD_SIZE;\n\t\t\tsize -= HNS3_MAX_BD_SIZE;\n\n\t\t\tif (bd_num > HNS3_MAX_TSO_BD_NUM)\n\t\t\t\treturn bd_num;\n\t\t}\n\n\t\tbd_size[bd_num++] = size;\n\t\tif (bd_num > HNS3_MAX_TSO_BD_NUM)\n\t\t\treturn bd_num;\n\t}\n\n\treturn bd_num;\n}\n\nstatic unsigned int hns3_tx_bd_num(struct sk_buff *skb, unsigned int *bd_size,\n\t\t\t\t   u8 max_non_tso_bd_num, unsigned int bd_num,\n\t\t\t\t   unsigned int recursion_level)\n{\n#define HNS3_MAX_RECURSION_LEVEL\t24\n\n\tstruct sk_buff *frag_skb;\n\n\t \n\tif (likely(skb->len <= HNS3_MAX_BD_SIZE && !recursion_level &&\n\t\t   !skb_has_frag_list(skb) &&\n\t\t   skb_shinfo(skb)->nr_frags < max_non_tso_bd_num))\n\t\treturn skb_shinfo(skb)->nr_frags + 1U;\n\n\tif (unlikely(recursion_level >= HNS3_MAX_RECURSION_LEVEL))\n\t\treturn UINT_MAX;\n\n\tbd_num = hns3_skb_bd_num(skb, bd_size, bd_num);\n\tif (!skb_has_frag_list(skb) || bd_num > HNS3_MAX_TSO_BD_NUM)\n\t\treturn bd_num;\n\n\tskb_walk_frags(skb, frag_skb) {\n\t\tbd_num = hns3_tx_bd_num(frag_skb, bd_size, max_non_tso_bd_num,\n\t\t\t\t\tbd_num, recursion_level + 1);\n\t\tif (bd_num > HNS3_MAX_TSO_BD_NUM)\n\t\t\treturn bd_num;\n\t}\n\n\treturn bd_num;\n}\n\nstatic unsigned int hns3_gso_hdr_len(struct sk_buff *skb)\n{\n\tif (!skb->encapsulation)\n\t\treturn skb_tcp_all_headers(skb);\n\n\treturn skb_inner_tcp_all_headers(skb);\n}\n\n \nstatic bool hns3_skb_need_linearized(struct sk_buff *skb, unsigned int *bd_size,\n\t\t\t\t     unsigned int bd_num, u8 max_non_tso_bd_num)\n{\n\tunsigned int tot_len = 0;\n\tint i;\n\n\tfor (i = 0; i < max_non_tso_bd_num - 1U; i++)\n\t\ttot_len += bd_size[i];\n\n\t \n\tif (tot_len + bd_size[max_non_tso_bd_num - 1U] <\n\t    skb_shinfo(skb)->gso_size + hns3_gso_hdr_len(skb))\n\t\treturn true;\n\n\t \n\tfor (i = 0; i < bd_num - max_non_tso_bd_num; i++) {\n\t\ttot_len -= bd_size[i];\n\t\ttot_len += bd_size[i + max_non_tso_bd_num - 1U];\n\n\t\tif (tot_len < skb_shinfo(skb)->gso_size)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid hns3_shinfo_pack(struct skb_shared_info *shinfo, __u32 *size)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_SKB_FRAGS; i++)\n\t\tsize[i] = skb_frag_size(&shinfo->frags[i]);\n}\n\nstatic int hns3_skb_linearize(struct hns3_enet_ring *ring,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      unsigned int bd_num)\n{\n\t \n\tif (bd_num == UINT_MAX) {\n\t\thns3_ring_stats_update(ring, over_max_recursion);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (skb->len > HNS3_MAX_TSO_SIZE ||\n\t    (!skb_is_gso(skb) && skb->len > HNS3_MAX_NON_TSO_SIZE)) {\n\t\thns3_ring_stats_update(ring, hw_limitation);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (__skb_linearize(skb)) {\n\t\thns3_ring_stats_update(ring, sw_err_cnt);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_nic_maybe_stop_tx(struct hns3_enet_ring *ring,\n\t\t\t\t  struct net_device *netdev,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tu8 max_non_tso_bd_num = priv->max_non_tso_bd_num;\n\tunsigned int bd_size[HNS3_MAX_TSO_BD_NUM + 1U];\n\tunsigned int bd_num;\n\n\tbd_num = hns3_tx_bd_num(skb, bd_size, max_non_tso_bd_num, 0, 0);\n\tif (unlikely(bd_num > max_non_tso_bd_num)) {\n\t\tif (bd_num <= HNS3_MAX_TSO_BD_NUM && skb_is_gso(skb) &&\n\t\t    !hns3_skb_need_linearized(skb, bd_size, bd_num,\n\t\t\t\t\t      max_non_tso_bd_num)) {\n\t\t\ttrace_hns3_over_max_bd(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hns3_skb_linearize(ring, skb, bd_num))\n\t\t\treturn -ENOMEM;\n\n\t\tbd_num = hns3_tx_bd_count(skb->len);\n\n\t\thns3_ring_stats_update(ring, tx_copy);\n\t}\n\nout:\n\tif (likely(ring_space(ring) >= bd_num))\n\t\treturn bd_num;\n\n\tnetif_stop_subqueue(netdev, ring->queue_index);\n\tsmp_mb();  \n\n\t \n\tif (ring_space(ring) >= bd_num && netif_carrier_ok(netdev) &&\n\t    !test_bit(HNS3_NIC_STATE_DOWN, &priv->state)) {\n\t\tnetif_start_subqueue(netdev, ring->queue_index);\n\t\treturn bd_num;\n\t}\n\n\thns3_ring_stats_update(ring, tx_busy);\n\n\treturn -EBUSY;\n}\n\nstatic void hns3_clear_desc(struct hns3_enet_ring *ring, int next_to_use_orig)\n{\n\tstruct device *dev = ring_to_dev(ring);\n\tunsigned int i;\n\n\tfor (i = 0; i < ring->desc_num; i++) {\n\t\tstruct hns3_desc *desc = &ring->desc[ring->next_to_use];\n\t\tstruct hns3_desc_cb *desc_cb;\n\n\t\tmemset(desc, 0, sizeof(*desc));\n\n\t\t \n\t\tif (ring->next_to_use == next_to_use_orig)\n\t\t\tbreak;\n\n\t\t \n\t\tring_ptr_move_bw(ring, next_to_use);\n\n\t\tdesc_cb = &ring->desc_cb[ring->next_to_use];\n\n\t\tif (!desc_cb->dma)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (desc_cb->type & (DESC_TYPE_SKB | DESC_TYPE_FRAGLIST_SKB))\n\t\t\tdma_unmap_single(dev, desc_cb->dma, desc_cb->length,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\telse if (desc_cb->type &\n\t\t\t (DESC_TYPE_BOUNCE_HEAD | DESC_TYPE_BOUNCE_ALL))\n\t\t\thns3_tx_spare_rollback(ring, desc_cb->length);\n\t\telse if (desc_cb->length)\n\t\t\tdma_unmap_page(dev, desc_cb->dma, desc_cb->length,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\tdesc_cb->length = 0;\n\t\tdesc_cb->dma = 0;\n\t\tdesc_cb->type = DESC_TYPE_UNKNOWN;\n\t}\n}\n\nstatic int hns3_fill_skb_to_desc(struct hns3_enet_ring *ring,\n\t\t\t\t struct sk_buff *skb, unsigned int type)\n{\n\tstruct sk_buff *frag_skb;\n\tint i, ret, bd_num = 0;\n\n\tret = hns3_map_and_fill_desc(ring, skb, type);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tbd_num += ret;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tret = hns3_map_and_fill_desc(ring, frag, DESC_TYPE_PAGE);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tbd_num += ret;\n\t}\n\n\tskb_walk_frags(skb, frag_skb) {\n\t\tret = hns3_fill_skb_to_desc(ring, frag_skb,\n\t\t\t\t\t    DESC_TYPE_FRAGLIST_SKB);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tbd_num += ret;\n\t}\n\n\treturn bd_num;\n}\n\nstatic void hns3_tx_push_bd(struct hns3_enet_ring *ring, int num)\n{\n#define HNS3_BYTES_PER_64BIT\t\t8\n\n\tstruct hns3_desc desc[HNS3_MAX_PUSH_BD_NUM] = {};\n\tint offset = 0;\n\n\t \n\tdma_wmb();\n\n\tdo {\n\t\tint idx = (ring->next_to_use - num + ring->desc_num) %\n\t\t\t  ring->desc_num;\n\n\t\tu64_stats_update_begin(&ring->syncp);\n\t\tring->stats.tx_push++;\n\t\tu64_stats_update_end(&ring->syncp);\n\t\tmemcpy(&desc[offset], &ring->desc[idx],\n\t\t       sizeof(struct hns3_desc));\n\t\toffset++;\n\t} while (--num);\n\n\t__iowrite64_copy(ring->tqp->mem_base, desc,\n\t\t\t (sizeof(struct hns3_desc) * HNS3_MAX_PUSH_BD_NUM) /\n\t\t\t HNS3_BYTES_PER_64BIT);\n\n\tio_stop_wc();\n}\n\nstatic void hns3_tx_mem_doorbell(struct hns3_enet_ring *ring)\n{\n#define HNS3_MEM_DOORBELL_OFFSET\t64\n\n\t__le64 bd_num = cpu_to_le64((u64)ring->pending_buf);\n\n\t \n\tdma_wmb();\n\n\t__iowrite64_copy(ring->tqp->mem_base + HNS3_MEM_DOORBELL_OFFSET,\n\t\t\t &bd_num, 1);\n\tu64_stats_update_begin(&ring->syncp);\n\tring->stats.tx_mem_doorbell += ring->pending_buf;\n\tu64_stats_update_end(&ring->syncp);\n\n\tio_stop_wc();\n}\n\nstatic void hns3_tx_doorbell(struct hns3_enet_ring *ring, int num,\n\t\t\t     bool doorbell)\n{\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\n\t \n\tif (test_bit(HNS3_NIC_STATE_TX_PUSH_ENABLE, &priv->state) && num &&\n\t    !ring->pending_buf && num <= HNS3_MAX_PUSH_BD_NUM && doorbell) {\n\t\t \n\t\tsmp_store_release(&ring->last_to_use, ring->next_to_use);\n\t\thns3_tx_push_bd(ring, num);\n\t\treturn;\n\t}\n\n\tring->pending_buf += num;\n\n\tif (!doorbell) {\n\t\thns3_ring_stats_update(ring, tx_more);\n\t\treturn;\n\t}\n\n\t \n\tsmp_store_release(&ring->last_to_use, ring->next_to_use);\n\n\tif (ring->tqp->mem_base)\n\t\thns3_tx_mem_doorbell(ring);\n\telse\n\t\twritel(ring->pending_buf,\n\t\t       ring->tqp->io_base + HNS3_RING_TX_RING_TAIL_REG);\n\n\tring->pending_buf = 0;\n}\n\nstatic void hns3_tsyn(struct net_device *netdev, struct sk_buff *skb,\n\t\t      struct hns3_desc *desc)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (!(h->ae_algo->ops->set_tx_hwts_info &&\n\t      h->ae_algo->ops->set_tx_hwts_info(h, skb)))\n\t\treturn;\n\n\tdesc->tx.bdtp_fe_sc_vld_ra_ri |= cpu_to_le16(BIT(HNS3_TXD_TSYN_B));\n}\n\nstatic int hns3_handle_tx_bounce(struct hns3_enet_ring *ring,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hns3_desc_cb *desc_cb = &ring->desc_cb[ring->next_to_use];\n\tunsigned int type = DESC_TYPE_BOUNCE_HEAD;\n\tunsigned int size = skb_headlen(skb);\n\tdma_addr_t dma;\n\tint bd_num = 0;\n\tu32 cb_len;\n\tvoid *buf;\n\tint ret;\n\n\tif (skb->len <= ring->tx_copybreak) {\n\t\tsize = skb->len;\n\t\ttype = DESC_TYPE_BOUNCE_ALL;\n\t}\n\n\t \n\tbuf = hns3_tx_spare_alloc(ring, size, &dma, &cb_len);\n\n\tret = skb_copy_bits(skb, 0, buf, size);\n\tif (unlikely(ret < 0)) {\n\t\thns3_tx_spare_rollback(ring, cb_len);\n\t\thns3_ring_stats_update(ring, copy_bits_err);\n\t\treturn ret;\n\t}\n\n\tdesc_cb->priv = skb;\n\tdesc_cb->length = cb_len;\n\tdesc_cb->dma = dma;\n\tdesc_cb->type = type;\n\n\tbd_num += hns3_fill_desc(ring, dma, size);\n\n\tif (type == DESC_TYPE_BOUNCE_HEAD) {\n\t\tret = hns3_fill_skb_to_desc(ring, skb,\n\t\t\t\t\t    DESC_TYPE_BOUNCE_HEAD);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tbd_num += ret;\n\t}\n\n\tdma_sync_single_for_device(ring_to_dev(ring), dma, size,\n\t\t\t\t   DMA_TO_DEVICE);\n\n\thns3_ring_stats_update(ring, tx_bounce);\n\n\treturn bd_num;\n}\n\nstatic int hns3_handle_tx_sgl(struct hns3_enet_ring *ring,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct hns3_desc_cb *desc_cb = &ring->desc_cb[ring->next_to_use];\n\tu32 nfrag = skb_shinfo(skb)->nr_frags + 1;\n\tstruct sg_table *sgt;\n\tint i, bd_num = 0;\n\tdma_addr_t dma;\n\tu32 cb_len;\n\tint nents;\n\n\tif (skb_has_frag_list(skb))\n\t\tnfrag = HNS3_MAX_TSO_BD_NUM;\n\n\t \n\tsgt = hns3_tx_spare_alloc(ring, HNS3_SGL_SIZE(nfrag),\n\t\t\t\t  &dma, &cb_len);\n\n\t \n\tsgt->sgl = (struct scatterlist *)(sgt + 1);\n\tsg_init_table(sgt->sgl, nfrag);\n\tnents = skb_to_sgvec(skb, sgt->sgl, 0, skb->len);\n\tif (unlikely(nents < 0)) {\n\t\thns3_tx_spare_rollback(ring, cb_len);\n\t\thns3_ring_stats_update(ring, skb2sgl_err);\n\t\treturn -ENOMEM;\n\t}\n\n\tsgt->orig_nents = nents;\n\tsgt->nents = dma_map_sg(ring_to_dev(ring), sgt->sgl, sgt->orig_nents,\n\t\t\t\tDMA_TO_DEVICE);\n\tif (unlikely(!sgt->nents)) {\n\t\thns3_tx_spare_rollback(ring, cb_len);\n\t\thns3_ring_stats_update(ring, map_sg_err);\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc_cb->priv = skb;\n\tdesc_cb->length = cb_len;\n\tdesc_cb->dma = dma;\n\tdesc_cb->type = DESC_TYPE_SGL_SKB;\n\n\tfor (i = 0; i < sgt->nents; i++)\n\t\tbd_num += hns3_fill_desc(ring, sg_dma_address(sgt->sgl + i),\n\t\t\t\t\t sg_dma_len(sgt->sgl + i));\n\thns3_ring_stats_update(ring, tx_sgl);\n\n\treturn bd_num;\n}\n\nstatic int hns3_handle_desc_filling(struct hns3_enet_ring *ring,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tu32 space;\n\n\tif (!ring->tx_spare)\n\t\tgoto out;\n\n\tspace = hns3_tx_spare_space(ring);\n\n\tif (hns3_can_use_tx_sgl(ring, skb, space))\n\t\treturn hns3_handle_tx_sgl(ring, skb);\n\n\tif (hns3_can_use_tx_bounce(ring, skb, space))\n\t\treturn hns3_handle_tx_bounce(ring, skb);\n\nout:\n\treturn hns3_fill_skb_to_desc(ring, skb, DESC_TYPE_SKB);\n}\n\nstatic int hns3_handle_skb_desc(struct hns3_enet_ring *ring,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct hns3_desc_cb *desc_cb,\n\t\t\t\tint next_to_use_head)\n{\n\tint ret;\n\n\tret = hns3_fill_skb_desc(ring, skb, &ring->desc[ring->next_to_use],\n\t\t\t\t desc_cb);\n\tif (unlikely(ret < 0))\n\t\tgoto fill_err;\n\n\t \n\tret = hns3_handle_desc_filling(ring, skb);\n\tif (likely(ret > 0))\n\t\treturn ret;\n\nfill_err:\n\thns3_clear_desc(ring, next_to_use_head);\n\treturn ret;\n}\n\nnetdev_tx_t hns3_nic_net_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hns3_enet_ring *ring = &priv->ring[skb->queue_mapping];\n\tstruct hns3_desc_cb *desc_cb = &ring->desc_cb[ring->next_to_use];\n\tstruct netdev_queue *dev_queue;\n\tint pre_ntu, ret;\n\tbool doorbell;\n\n\t \n\tif (skb_put_padto(skb, HNS3_MIN_TX_LEN)) {\n\t\thns3_tx_doorbell(ring, 0, !netdev_xmit_more());\n\n\t\thns3_ring_stats_update(ring, sw_err_cnt);\n\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tprefetch(skb->data);\n\n\tret = hns3_nic_maybe_stop_tx(ring, netdev, skb);\n\tif (unlikely(ret <= 0)) {\n\t\tif (ret == -EBUSY) {\n\t\t\thns3_tx_doorbell(ring, 0, true);\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\n\t\thns3_rl_err(netdev, \"xmit error: %d!\\n\", ret);\n\t\tgoto out_err_tx_ok;\n\t}\n\n\tret = hns3_handle_skb_desc(ring, skb, desc_cb, ring->next_to_use);\n\tif (unlikely(ret <= 0))\n\t\tgoto out_err_tx_ok;\n\n\tpre_ntu = ring->next_to_use ? (ring->next_to_use - 1) :\n\t\t\t\t\t(ring->desc_num - 1);\n\n\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))\n\t\thns3_tsyn(netdev, skb, &ring->desc[pre_ntu]);\n\n\tring->desc[pre_ntu].tx.bdtp_fe_sc_vld_ra_ri |=\n\t\t\t\tcpu_to_le16(BIT(HNS3_TXD_FE_B));\n\ttrace_hns3_tx_desc(ring, pre_ntu);\n\n\tskb_tx_timestamp(skb);\n\n\t \n\tdev_queue = netdev_get_tx_queue(netdev, ring->queue_index);\n\tdoorbell = __netdev_tx_sent_queue(dev_queue, desc_cb->send_bytes,\n\t\t\t\t\t  netdev_xmit_more());\n\thns3_tx_doorbell(ring, ret, doorbell);\n\n\treturn NETDEV_TX_OK;\n\nout_err_tx_ok:\n\tdev_kfree_skb_any(skb);\n\thns3_tx_doorbell(ring, 0, !netdev_xmit_more());\n\treturn NETDEV_TX_OK;\n}\n\nstatic int hns3_nic_net_set_mac_address(struct net_device *netdev, void *p)\n{\n\tchar format_mac_addr_perm[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tchar format_mac_addr_sa[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct sockaddr *mac_addr = p;\n\tint ret;\n\n\tif (!mac_addr || !is_valid_ether_addr((const u8 *)mac_addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (ether_addr_equal(netdev->dev_addr, mac_addr->sa_data)) {\n\t\thnae3_format_mac_addr(format_mac_addr_sa, mac_addr->sa_data);\n\t\tnetdev_info(netdev, \"already using mac address %s\\n\",\n\t\t\t    format_mac_addr_sa);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!hns3_is_phys_func(h->pdev) &&\n\t    !is_zero_ether_addr(netdev->perm_addr)) {\n\t\thnae3_format_mac_addr(format_mac_addr_perm, netdev->perm_addr);\n\t\thnae3_format_mac_addr(format_mac_addr_sa, mac_addr->sa_data);\n\t\tnetdev_err(netdev, \"has permanent MAC %s, user MAC %s not allow\\n\",\n\t\t\t   format_mac_addr_perm, format_mac_addr_sa);\n\t\treturn -EPERM;\n\t}\n\n\tret = h->ae_algo->ops->set_mac_addr(h, mac_addr->sa_data, false);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"set_mac_address fail, ret=%d!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\teth_hw_addr_set(netdev, mac_addr->sa_data);\n\n\treturn 0;\n}\n\nstatic int hns3_nic_do_ioctl(struct net_device *netdev,\n\t\t\t     struct ifreq *ifr, int cmd)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (!netif_running(netdev))\n\t\treturn -EINVAL;\n\n\tif (!h->ae_algo->ops->do_ioctl)\n\t\treturn -EOPNOTSUPP;\n\n\treturn h->ae_algo->ops->do_ioctl(h, ifr, cmd);\n}\n\nstatic int hns3_nic_set_features(struct net_device *netdev,\n\t\t\t\t netdev_features_t features)\n{\n\tnetdev_features_t changed = netdev->features ^ features;\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tbool enable;\n\tint ret;\n\n\tif (changed & (NETIF_F_GRO_HW) && h->ae_algo->ops->set_gro_en) {\n\t\tenable = !!(features & NETIF_F_GRO_HW);\n\t\tret = h->ae_algo->ops->set_gro_en(h, enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((changed & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    h->ae_algo->ops->enable_hw_strip_rxvtag) {\n\t\tenable = !!(features & NETIF_F_HW_VLAN_CTAG_RX);\n\t\tret = h->ae_algo->ops->enable_hw_strip_rxvtag(h, enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((changed & NETIF_F_NTUPLE) && h->ae_algo->ops->enable_fd) {\n\t\tenable = !!(features & NETIF_F_NTUPLE);\n\t\th->ae_algo->ops->enable_fd(h, enable);\n\t}\n\n\tif ((netdev->features & NETIF_F_HW_TC) > (features & NETIF_F_HW_TC) &&\n\t    h->ae_algo->ops->cls_flower_active(h)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"there are offloaded TC filters active, cannot disable HW TC offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((changed & NETIF_F_HW_VLAN_CTAG_FILTER) &&\n\t    h->ae_algo->ops->enable_vlan_filter) {\n\t\tenable = !!(features & NETIF_F_HW_VLAN_CTAG_FILTER);\n\t\tret = h->ae_algo->ops->enable_vlan_filter(h, enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnetdev->features = features;\n\treturn 0;\n}\n\nstatic netdev_features_t hns3_features_check(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     netdev_features_t features)\n{\n#define HNS3_MAX_HDR_LEN\t480U\n#define HNS3_MAX_L4_HDR_LEN\t60U\n\n\tsize_t len;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn features;\n\n\tif (skb->encapsulation)\n\t\tlen = skb_inner_transport_header(skb) - skb->data;\n\telse\n\t\tlen = skb_transport_header(skb) - skb->data;\n\n\t \n\tlen += HNS3_MAX_L4_HDR_LEN;\n\n\t \n\tif (len > HNS3_MAX_HDR_LEN)\n\t\tfeatures &= ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\n\treturn features;\n}\n\nstatic void hns3_fetch_stats(struct rtnl_link_stats64 *stats,\n\t\t\t     struct hns3_enet_ring *ring, bool is_tx)\n{\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&ring->syncp);\n\t\tif (is_tx) {\n\t\t\tstats->tx_bytes += ring->stats.tx_bytes;\n\t\t\tstats->tx_packets += ring->stats.tx_pkts;\n\t\t\tstats->tx_dropped += ring->stats.sw_err_cnt;\n\t\t\tstats->tx_dropped += ring->stats.tx_vlan_err;\n\t\t\tstats->tx_dropped += ring->stats.tx_l4_proto_err;\n\t\t\tstats->tx_dropped += ring->stats.tx_l2l3l4_err;\n\t\t\tstats->tx_dropped += ring->stats.tx_tso_err;\n\t\t\tstats->tx_dropped += ring->stats.over_max_recursion;\n\t\t\tstats->tx_dropped += ring->stats.hw_limitation;\n\t\t\tstats->tx_dropped += ring->stats.copy_bits_err;\n\t\t\tstats->tx_dropped += ring->stats.skb2sgl_err;\n\t\t\tstats->tx_dropped += ring->stats.map_sg_err;\n\t\t\tstats->tx_errors += ring->stats.sw_err_cnt;\n\t\t\tstats->tx_errors += ring->stats.tx_vlan_err;\n\t\t\tstats->tx_errors += ring->stats.tx_l4_proto_err;\n\t\t\tstats->tx_errors += ring->stats.tx_l2l3l4_err;\n\t\t\tstats->tx_errors += ring->stats.tx_tso_err;\n\t\t\tstats->tx_errors += ring->stats.over_max_recursion;\n\t\t\tstats->tx_errors += ring->stats.hw_limitation;\n\t\t\tstats->tx_errors += ring->stats.copy_bits_err;\n\t\t\tstats->tx_errors += ring->stats.skb2sgl_err;\n\t\t\tstats->tx_errors += ring->stats.map_sg_err;\n\t\t} else {\n\t\t\tstats->rx_bytes += ring->stats.rx_bytes;\n\t\t\tstats->rx_packets += ring->stats.rx_pkts;\n\t\t\tstats->rx_dropped += ring->stats.l2_err;\n\t\t\tstats->rx_errors += ring->stats.l2_err;\n\t\t\tstats->rx_errors += ring->stats.l3l4_csum_err;\n\t\t\tstats->rx_crc_errors += ring->stats.l2_err;\n\t\t\tstats->multicast += ring->stats.rx_multicast;\n\t\t\tstats->rx_length_errors += ring->stats.err_pkt_len;\n\t\t}\n\t} while (u64_stats_fetch_retry(&ring->syncp, start));\n}\n\nstatic void hns3_nic_get_stats64(struct net_device *netdev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tint queue_num = priv->ae_handle->kinfo.num_tqps;\n\tstruct hnae3_handle *handle = priv->ae_handle;\n\tstruct rtnl_link_stats64 ring_total_stats;\n\tstruct hns3_enet_ring *ring;\n\tunsigned int idx;\n\n\tif (test_bit(HNS3_NIC_STATE_DOWN, &priv->state))\n\t\treturn;\n\n\thandle->ae_algo->ops->update_stats(handle);\n\n\tmemset(&ring_total_stats, 0, sizeof(ring_total_stats));\n\tfor (idx = 0; idx < queue_num; idx++) {\n\t\t \n\t\tring = &priv->ring[idx];\n\t\thns3_fetch_stats(&ring_total_stats, ring, true);\n\n\t\t \n\t\tring = &priv->ring[idx + queue_num];\n\t\thns3_fetch_stats(&ring_total_stats, ring, false);\n\t}\n\n\tstats->tx_bytes = ring_total_stats.tx_bytes;\n\tstats->tx_packets = ring_total_stats.tx_packets;\n\tstats->rx_bytes = ring_total_stats.rx_bytes;\n\tstats->rx_packets = ring_total_stats.rx_packets;\n\n\tstats->rx_errors = ring_total_stats.rx_errors;\n\tstats->multicast = ring_total_stats.multicast;\n\tstats->rx_length_errors = ring_total_stats.rx_length_errors;\n\tstats->rx_crc_errors = ring_total_stats.rx_crc_errors;\n\tstats->rx_missed_errors = netdev->stats.rx_missed_errors;\n\n\tstats->tx_errors = ring_total_stats.tx_errors;\n\tstats->rx_dropped = ring_total_stats.rx_dropped;\n\tstats->tx_dropped = ring_total_stats.tx_dropped;\n\tstats->collisions = netdev->stats.collisions;\n\tstats->rx_over_errors = netdev->stats.rx_over_errors;\n\tstats->rx_frame_errors = netdev->stats.rx_frame_errors;\n\tstats->rx_fifo_errors = netdev->stats.rx_fifo_errors;\n\tstats->tx_aborted_errors = netdev->stats.tx_aborted_errors;\n\tstats->tx_carrier_errors = netdev->stats.tx_carrier_errors;\n\tstats->tx_fifo_errors = netdev->stats.tx_fifo_errors;\n\tstats->tx_heartbeat_errors = netdev->stats.tx_heartbeat_errors;\n\tstats->tx_window_errors = netdev->stats.tx_window_errors;\n\tstats->rx_compressed = netdev->stats.rx_compressed;\n\tstats->tx_compressed = netdev->stats.tx_compressed;\n}\n\nstatic int hns3_setup_tc(struct net_device *netdev, void *type_data)\n{\n\tstruct tc_mqprio_qopt_offload *mqprio_qopt = type_data;\n\tstruct hnae3_knic_private_info *kinfo;\n\tu8 tc = mqprio_qopt->qopt.num_tc;\n\tu16 mode = mqprio_qopt->mode;\n\tu8 hw = mqprio_qopt->qopt.hw;\n\tstruct hnae3_handle *h;\n\n\tif (!((hw == TC_MQPRIO_HW_OFFLOAD_TCS &&\n\t       mode == TC_MQPRIO_MODE_CHANNEL) || (!hw && tc == 0)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (tc > HNAE3_MAX_TC)\n\t\treturn -EINVAL;\n\n\tif (!netdev)\n\t\treturn -EINVAL;\n\n\th = hns3_get_handle(netdev);\n\tkinfo = &h->kinfo;\n\n\tnetif_dbg(h, drv, netdev, \"setup tc: num_tc=%u\\n\", tc);\n\n\treturn (kinfo->dcb_ops && kinfo->dcb_ops->setup_tc) ?\n\t\tkinfo->dcb_ops->setup_tc(h, mqprio_qopt) : -EOPNOTSUPP;\n}\n\nstatic int hns3_setup_tc_cls_flower(struct hns3_nic_priv *priv,\n\t\t\t\t    struct flow_cls_offload *flow)\n{\n\tint tc = tc_classid_to_hwtc(priv->netdev, flow->classid);\n\tstruct hnae3_handle *h = hns3_get_handle(priv->netdev);\n\n\tswitch (flow->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\tif (h->ae_algo->ops->add_cls_flower)\n\t\t\treturn h->ae_algo->ops->add_cls_flower(h, flow, tc);\n\t\tbreak;\n\tcase FLOW_CLS_DESTROY:\n\t\tif (h->ae_algo->ops->del_cls_flower)\n\t\t\treturn h->ae_algo->ops->del_cls_flower(h, flow);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hns3_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t\t  void *cb_priv)\n{\n\tstruct hns3_nic_priv *priv = cb_priv;\n\n\tif (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn hns3_setup_tc_cls_flower(priv, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(hns3_block_cb_list);\n\nstatic int hns3_nic_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t     void *type_data)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\tret = hns3_setup_tc(dev, type_data);\n\t\tbreak;\n\tcase TC_SETUP_BLOCK:\n\t\tret = flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t &hns3_block_cb_list,\n\t\t\t\t\t\t hns3_setup_tc_block_cb,\n\t\t\t\t\t\t priv, priv, true);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int hns3_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t__be16 proto, u16 vid)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tint ret = -EIO;\n\n\tif (h->ae_algo->ops->set_vlan_filter)\n\t\tret = h->ae_algo->ops->set_vlan_filter(h, proto, vid, false);\n\n\treturn ret;\n}\n\nstatic int hns3_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t __be16 proto, u16 vid)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tint ret = -EIO;\n\n\tif (h->ae_algo->ops->set_vlan_filter)\n\t\tret = h->ae_algo->ops->set_vlan_filter(h, proto, vid, true);\n\n\treturn ret;\n}\n\nstatic int hns3_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan,\n\t\t\t\tu8 qos, __be16 vlan_proto)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tint ret = -EIO;\n\n\tnetif_dbg(h, drv, netdev,\n\t\t  \"set vf vlan: vf=%d, vlan=%u, qos=%u, vlan_proto=0x%x\\n\",\n\t\t  vf, vlan, qos, ntohs(vlan_proto));\n\n\tif (h->ae_algo->ops->set_vf_vlan_filter)\n\t\tret = h->ae_algo->ops->set_vf_vlan_filter(h, vf, vlan,\n\t\t\t\t\t\t\t  qos, vlan_proto);\n\n\treturn ret;\n}\n\nstatic int hns3_set_vf_spoofchk(struct net_device *netdev, int vf, bool enable)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\n\tif (hns3_nic_resetting(netdev))\n\t\treturn -EBUSY;\n\n\tif (!handle->ae_algo->ops->set_vf_spoofchk)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handle->ae_algo->ops->set_vf_spoofchk(handle, vf, enable);\n}\n\nstatic int hns3_set_vf_trust(struct net_device *netdev, int vf, bool enable)\n{\n\tstruct hnae3_handle *handle = hns3_get_handle(netdev);\n\n\tif (!handle->ae_algo->ops->set_vf_trust)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handle->ae_algo->ops->set_vf_trust(handle, vf, enable);\n}\n\nstatic int hns3_nic_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tint ret;\n\n\tif (hns3_nic_resetting(netdev))\n\t\treturn -EBUSY;\n\n\tif (!h->ae_algo->ops->set_mtu)\n\t\treturn -EOPNOTSUPP;\n\n\tnetif_dbg(h, drv, netdev,\n\t\t  \"change mtu from %u to %d\\n\", netdev->mtu, new_mtu);\n\n\tret = h->ae_algo->ops->set_mtu(h, new_mtu);\n\tif (ret)\n\t\tnetdev_err(netdev, \"failed to change MTU in hardware %d\\n\",\n\t\t\t   ret);\n\telse\n\t\tnetdev->mtu = new_mtu;\n\n\treturn ret;\n}\n\nstatic int hns3_get_timeout_queue(struct net_device *ndev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ndev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *q;\n\t\tunsigned long trans_start;\n\n\t\tq = netdev_get_tx_queue(ndev, i);\n\t\ttrans_start = READ_ONCE(q->trans_start);\n\t\tif (netif_xmit_stopped(q) &&\n\t\t    time_after(jiffies,\n\t\t\t       (trans_start + ndev->watchdog_timeo))) {\n#ifdef CONFIG_BQL\n\t\t\tstruct dql *dql = &q->dql;\n\n\t\t\tnetdev_info(ndev, \"DQL info last_cnt: %u, queued: %u, adj_limit: %u, completed: %u\\n\",\n\t\t\t\t    dql->last_obj_cnt, dql->num_queued,\n\t\t\t\t    dql->adj_limit, dql->num_completed);\n#endif\n\t\t\tnetdev_info(ndev, \"queue state: 0x%lx, delta msecs: %u\\n\",\n\t\t\t\t    q->state,\n\t\t\t\t    jiffies_to_msecs(jiffies - trans_start));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic void hns3_dump_queue_stats(struct net_device *ndev,\n\t\t\t\t  struct hns3_enet_ring *tx_ring,\n\t\t\t\t  int timeout_queue)\n{\n\tstruct napi_struct *napi = &tx_ring->tqp_vector->napi;\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\n\tnetdev_info(ndev,\n\t\t    \"tx_timeout count: %llu, queue id: %d, SW_NTU: 0x%x, SW_NTC: 0x%x, napi state: %lu\\n\",\n\t\t    priv->tx_timeout_count, timeout_queue, tx_ring->next_to_use,\n\t\t    tx_ring->next_to_clean, napi->state);\n\n\tnetdev_info(ndev,\n\t\t    \"tx_pkts: %llu, tx_bytes: %llu, sw_err_cnt: %llu, tx_pending: %d\\n\",\n\t\t    tx_ring->stats.tx_pkts, tx_ring->stats.tx_bytes,\n\t\t    tx_ring->stats.sw_err_cnt, tx_ring->pending_buf);\n\n\tnetdev_info(ndev,\n\t\t    \"seg_pkt_cnt: %llu, tx_more: %llu, restart_queue: %llu, tx_busy: %llu\\n\",\n\t\t    tx_ring->stats.seg_pkt_cnt, tx_ring->stats.tx_more,\n\t\t    tx_ring->stats.restart_queue, tx_ring->stats.tx_busy);\n\n\tnetdev_info(ndev, \"tx_push: %llu, tx_mem_doorbell: %llu\\n\",\n\t\t    tx_ring->stats.tx_push, tx_ring->stats.tx_mem_doorbell);\n}\n\nstatic void hns3_dump_queue_reg(struct net_device *ndev,\n\t\t\t\tstruct hns3_enet_ring *tx_ring)\n{\n\tnetdev_info(ndev,\n\t\t    \"BD_NUM: 0x%x HW_HEAD: 0x%x, HW_TAIL: 0x%x, BD_ERR: 0x%x, INT: 0x%x\\n\",\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_BD_NUM_REG),\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_HEAD_REG),\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_TAIL_REG),\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_BD_ERR_REG),\n\t\t    readl(tx_ring->tqp_vector->mask_addr));\n\tnetdev_info(ndev,\n\t\t    \"RING_EN: 0x%x, TC: 0x%x, FBD_NUM: 0x%x FBD_OFT: 0x%x, EBD_NUM: 0x%x, EBD_OFT: 0x%x\\n\",\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_EN_REG),\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_TC_REG),\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_FBDNUM_REG),\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_OFFSET_REG),\n\t\t    hns3_tqp_read_reg(tx_ring, HNS3_RING_TX_RING_EBDNUM_REG),\n\t\t    hns3_tqp_read_reg(tx_ring,\n\t\t\t\t      HNS3_RING_TX_RING_EBD_OFFSET_REG));\n}\n\nstatic bool hns3_get_tx_timeo_queue_info(struct net_device *ndev)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = hns3_get_handle(ndev);\n\tstruct hns3_enet_ring *tx_ring;\n\tint timeout_queue;\n\n\ttimeout_queue = hns3_get_timeout_queue(ndev);\n\tif (timeout_queue >= ndev->num_tx_queues) {\n\t\tnetdev_info(ndev,\n\t\t\t    \"no netdev TX timeout queue found, timeout count: %llu\\n\",\n\t\t\t    priv->tx_timeout_count);\n\t\treturn false;\n\t}\n\n\tpriv->tx_timeout_count++;\n\n\ttx_ring = &priv->ring[timeout_queue];\n\thns3_dump_queue_stats(ndev, tx_ring, timeout_queue);\n\n\t \n\tif (h->ae_algo->ops->get_mac_stats) {\n\t\tstruct hns3_mac_stats mac_stats;\n\n\t\th->ae_algo->ops->get_mac_stats(h, &mac_stats);\n\t\tnetdev_info(ndev, \"tx_pause_cnt: %llu, rx_pause_cnt: %llu\\n\",\n\t\t\t    mac_stats.tx_pause_cnt, mac_stats.rx_pause_cnt);\n\t}\n\n\thns3_dump_queue_reg(ndev, tx_ring);\n\n\treturn true;\n}\n\nstatic void hns3_nic_net_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\n\tif (!hns3_get_tx_timeo_queue_info(ndev))\n\t\treturn;\n\n\t \n\tif (h->ae_algo->ops->reset_event)\n\t\th->ae_algo->ops->reset_event(h->pdev, h);\n}\n\n#ifdef CONFIG_RFS_ACCEL\nstatic int hns3_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,\n\t\t\t      u16 rxq_index, u32 flow_id)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(dev);\n\tstruct flow_keys fkeys;\n\n\tif (!h->ae_algo->ops->add_arfs_entry)\n\t\treturn -EOPNOTSUPP;\n\n\tif (skb->encapsulation)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (!skb_flow_dissect_flow_keys(skb, &fkeys, 0))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif ((fkeys.basic.n_proto != htons(ETH_P_IP) &&\n\t     fkeys.basic.n_proto != htons(ETH_P_IPV6)) ||\n\t    (fkeys.basic.ip_proto != IPPROTO_TCP &&\n\t     fkeys.basic.ip_proto != IPPROTO_UDP))\n\t\treturn -EPROTONOSUPPORT;\n\n\treturn h->ae_algo->ops->add_arfs_entry(h, rxq_index, flow_id, &fkeys);\n}\n#endif\n\nstatic int hns3_nic_get_vf_config(struct net_device *ndev, int vf,\n\t\t\t\t  struct ifla_vf_info *ivf)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(ndev);\n\n\tif (!h->ae_algo->ops->get_vf_config)\n\t\treturn -EOPNOTSUPP;\n\n\treturn h->ae_algo->ops->get_vf_config(h, vf, ivf);\n}\n\nstatic int hns3_nic_set_vf_link_state(struct net_device *ndev, int vf,\n\t\t\t\t      int link_state)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(ndev);\n\n\tif (!h->ae_algo->ops->set_vf_link_state)\n\t\treturn -EOPNOTSUPP;\n\n\treturn h->ae_algo->ops->set_vf_link_state(h, vf, link_state);\n}\n\nstatic int hns3_nic_set_vf_rate(struct net_device *ndev, int vf,\n\t\t\t\tint min_tx_rate, int max_tx_rate)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(ndev);\n\n\tif (!h->ae_algo->ops->set_vf_rate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn h->ae_algo->ops->set_vf_rate(h, vf, min_tx_rate, max_tx_rate,\n\t\t\t\t\t    false);\n}\n\nstatic int hns3_nic_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\n\tif (!h->ae_algo->ops->set_vf_mac)\n\t\treturn -EOPNOTSUPP;\n\n\tif (is_multicast_ether_addr(mac)) {\n\t\thnae3_format_mac_addr(format_mac_addr, mac);\n\t\tnetdev_err(netdev,\n\t\t\t   \"Invalid MAC:%s specified. Could not set MAC\\n\",\n\t\t\t   format_mac_addr);\n\t\treturn -EINVAL;\n\t}\n\n\treturn h->ae_algo->ops->set_vf_mac(h, vf_id, mac);\n}\n\n#define HNS3_INVALID_DSCP\t\t0xff\n#define HNS3_DSCP_SHIFT\t\t\t2\n\nstatic u8 hns3_get_skb_dscp(struct sk_buff *skb)\n{\n\t__be16 protocol = skb->protocol;\n\tu8 dscp = HNS3_INVALID_DSCP;\n\n\tif (protocol == htons(ETH_P_8021Q))\n\t\tprotocol = vlan_get_protocol(skb);\n\n\tif (protocol == htons(ETH_P_IP))\n\t\tdscp = ipv4_get_dsfield(ip_hdr(skb)) >> HNS3_DSCP_SHIFT;\n\telse if (protocol == htons(ETH_P_IPV6))\n\t\tdscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> HNS3_DSCP_SHIFT;\n\n\treturn dscp;\n}\n\nstatic u16 hns3_nic_select_queue(struct net_device *netdev,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct net_device *sb_dev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tu8 dscp;\n\n\tif (h->kinfo.tc_map_mode != HNAE3_TC_MAP_MODE_DSCP ||\n\t    !h->ae_algo->ops->get_dscp_prio)\n\t\tgoto out;\n\n\tdscp = hns3_get_skb_dscp(skb);\n\tif (unlikely(dscp >= HNAE3_MAX_DSCP))\n\t\tgoto out;\n\n\tskb->priority = h->kinfo.dscp_prio[dscp];\n\tif (skb->priority == HNAE3_PRIO_ID_INVALID)\n\t\tskb->priority = 0;\n\nout:\n\treturn netdev_pick_tx(netdev, skb, sb_dev);\n}\n\nstatic const struct net_device_ops hns3_nic_netdev_ops = {\n\t.ndo_open\t\t= hns3_nic_net_open,\n\t.ndo_stop\t\t= hns3_nic_net_stop,\n\t.ndo_start_xmit\t\t= hns3_nic_net_xmit,\n\t.ndo_tx_timeout\t\t= hns3_nic_net_timeout,\n\t.ndo_set_mac_address\t= hns3_nic_net_set_mac_address,\n\t.ndo_eth_ioctl\t\t= hns3_nic_do_ioctl,\n\t.ndo_change_mtu\t\t= hns3_nic_change_mtu,\n\t.ndo_set_features\t= hns3_nic_set_features,\n\t.ndo_features_check\t= hns3_features_check,\n\t.ndo_get_stats64\t= hns3_nic_get_stats64,\n\t.ndo_setup_tc\t\t= hns3_nic_setup_tc,\n\t.ndo_set_rx_mode\t= hns3_nic_set_rx_mode,\n\t.ndo_vlan_rx_add_vid\t= hns3_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= hns3_vlan_rx_kill_vid,\n\t.ndo_set_vf_vlan\t= hns3_ndo_set_vf_vlan,\n\t.ndo_set_vf_spoofchk\t= hns3_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= hns3_set_vf_trust,\n#ifdef CONFIG_RFS_ACCEL\n\t.ndo_rx_flow_steer\t= hns3_rx_flow_steer,\n#endif\n\t.ndo_get_vf_config\t= hns3_nic_get_vf_config,\n\t.ndo_set_vf_link_state\t= hns3_nic_set_vf_link_state,\n\t.ndo_set_vf_rate\t= hns3_nic_set_vf_rate,\n\t.ndo_set_vf_mac\t\t= hns3_nic_set_vf_mac,\n\t.ndo_select_queue\t= hns3_nic_select_queue,\n};\n\nbool hns3_is_phys_func(struct pci_dev *pdev)\n{\n\tu32 dev_id = pdev->device;\n\n\tswitch (dev_id) {\n\tcase HNAE3_DEV_ID_GE:\n\tcase HNAE3_DEV_ID_25GE:\n\tcase HNAE3_DEV_ID_25GE_RDMA:\n\tcase HNAE3_DEV_ID_25GE_RDMA_MACSEC:\n\tcase HNAE3_DEV_ID_50GE_RDMA:\n\tcase HNAE3_DEV_ID_50GE_RDMA_MACSEC:\n\tcase HNAE3_DEV_ID_100G_RDMA_MACSEC:\n\tcase HNAE3_DEV_ID_200G_RDMA:\n\t\treturn true;\n\tcase HNAE3_DEV_ID_VF:\n\tcase HNAE3_DEV_ID_RDMA_DCB_PFC_VF:\n\t\treturn false;\n\tdefault:\n\t\tdev_warn(&pdev->dev, \"un-recognized pci device-id %u\",\n\t\t\t dev_id);\n\t}\n\n\treturn false;\n}\n\nstatic void hns3_disable_sriov(struct pci_dev *pdev)\n{\n\t \n\tif (pci_vfs_assigned(pdev)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"disabling driver while VFs are assigned\\n\");\n\t\treturn;\n\t}\n\n\tpci_disable_sriov(pdev);\n}\n\n \nstatic int hns3_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct hnae3_ae_dev *ae_dev;\n\tint ret;\n\n\tae_dev = devm_kzalloc(&pdev->dev, sizeof(*ae_dev), GFP_KERNEL);\n\tif (!ae_dev)\n\t\treturn -ENOMEM;\n\n\tae_dev->pdev = pdev;\n\tae_dev->flag = ent->driver_data;\n\tpci_set_drvdata(pdev, ae_dev);\n\n\tret = hnae3_register_ae_dev(ae_dev);\n\tif (ret)\n\t\tpci_set_drvdata(pdev, NULL);\n\n\treturn ret;\n}\n\n \nstatic void hns3_clean_vf_config(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\n\tif (ae_dev->ops->clean_vf_config)\n\t\tae_dev->ops->clean_vf_config(ae_dev, num_vfs);\n}\n\n \nstatic void hns3_remove(struct pci_dev *pdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\n\tif (hns3_is_phys_func(pdev) && IS_ENABLED(CONFIG_PCI_IOV))\n\t\thns3_disable_sriov(pdev);\n\n\thnae3_unregister_ae_dev(ae_dev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\n \nstatic int hns3_pci_sriov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tint ret;\n\n\tif (!(hns3_is_phys_func(pdev) && IS_ENABLED(CONFIG_PCI_IOV))) {\n\t\tdev_warn(&pdev->dev, \"Can not config SRIOV\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_vfs) {\n\t\tret = pci_enable_sriov(pdev, num_vfs);\n\t\tif (ret)\n\t\t\tdev_err(&pdev->dev, \"SRIOV enable failed %d\\n\", ret);\n\t\telse\n\t\t\treturn num_vfs;\n\t} else if (!pci_vfs_assigned(pdev)) {\n\t\tint num_vfs_pre = pci_num_vf(pdev);\n\n\t\tpci_disable_sriov(pdev);\n\t\thns3_clean_vf_config(pdev, num_vfs_pre);\n\t} else {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Unable to free VFs because some are assigned to VMs.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void hns3_shutdown(struct pci_dev *pdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\n\thnae3_unregister_ae_dev(ae_dev);\n\tpci_set_drvdata(pdev, NULL);\n\n\tif (system_state == SYSTEM_POWER_OFF)\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n}\n\nstatic int __maybe_unused hns3_suspend(struct device *dev)\n{\n\tstruct hnae3_ae_dev *ae_dev = dev_get_drvdata(dev);\n\n\tif (ae_dev && hns3_is_phys_func(ae_dev->pdev)) {\n\t\tdev_info(dev, \"Begin to suspend.\\n\");\n\t\tif (ae_dev->ops && ae_dev->ops->reset_prepare)\n\t\t\tae_dev->ops->reset_prepare(ae_dev, HNAE3_FUNC_RESET);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hns3_resume(struct device *dev)\n{\n\tstruct hnae3_ae_dev *ae_dev = dev_get_drvdata(dev);\n\n\tif (ae_dev && hns3_is_phys_func(ae_dev->pdev)) {\n\t\tdev_info(dev, \"Begin to resume.\\n\");\n\t\tif (ae_dev->ops && ae_dev->ops->reset_done)\n\t\t\tae_dev->ops->reset_done(ae_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic pci_ers_result_t hns3_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t    pci_channel_state_t state)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\tpci_ers_result_t ret;\n\n\tdev_info(&pdev->dev, \"PCI error detected, state(=%u)!!\\n\", state);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (!ae_dev || !ae_dev->ops) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Can't recover - error happened before device initialized\\n\");\n\t\treturn PCI_ERS_RESULT_NONE;\n\t}\n\n\tif (ae_dev->ops->handle_hw_ras_error)\n\t\tret = ae_dev->ops->handle_hw_ras_error(ae_dev);\n\telse\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\treturn ret;\n}\n\nstatic pci_ers_result_t hns3_slot_reset(struct pci_dev *pdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\tconst struct hnae3_ae_ops *ops;\n\tenum hnae3_reset_type reset_type;\n\tstruct device *dev = &pdev->dev;\n\n\tif (!ae_dev || !ae_dev->ops)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\tops = ae_dev->ops;\n\t \n\tif (ops->reset_event && ops->get_reset_level &&\n\t    ops->set_default_reset_request) {\n\t\tif (ae_dev->hw_err_reset_req) {\n\t\t\treset_type = ops->get_reset_level(ae_dev,\n\t\t\t\t\t\t&ae_dev->hw_err_reset_req);\n\t\t\tops->set_default_reset_request(ae_dev, reset_type);\n\t\t\tdev_info(dev, \"requesting reset due to PCI error\\n\");\n\t\t\tops->reset_event(pdev, NULL);\n\t\t}\n\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\treturn PCI_ERS_RESULT_DISCONNECT;\n}\n\nstatic void hns3_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\n\tdev_info(&pdev->dev, \"FLR prepare\\n\");\n\tif (ae_dev && ae_dev->ops && ae_dev->ops->reset_prepare)\n\t\tae_dev->ops->reset_prepare(ae_dev, HNAE3_FLR_RESET);\n}\n\nstatic void hns3_reset_done(struct pci_dev *pdev)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\n\tdev_info(&pdev->dev, \"FLR done\\n\");\n\tif (ae_dev && ae_dev->ops && ae_dev->ops->reset_done)\n\t\tae_dev->ops->reset_done(ae_dev);\n}\n\nstatic const struct pci_error_handlers hns3_err_handler = {\n\t.error_detected = hns3_error_detected,\n\t.slot_reset     = hns3_slot_reset,\n\t.reset_prepare\t= hns3_reset_prepare,\n\t.reset_done\t= hns3_reset_done,\n};\n\nstatic SIMPLE_DEV_PM_OPS(hns3_pm_ops, hns3_suspend, hns3_resume);\n\nstatic struct pci_driver hns3_driver = {\n\t.name     = hns3_driver_name,\n\t.id_table = hns3_pci_tbl,\n\t.probe    = hns3_probe,\n\t.remove   = hns3_remove,\n\t.shutdown = hns3_shutdown,\n\t.driver.pm  = &hns3_pm_ops,\n\t.sriov_configure = hns3_pci_sriov_configure,\n\t.err_handler    = &hns3_err_handler,\n};\n\n \nstatic void hns3_set_default_feature(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct pci_dev *pdev = h->pdev;\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER |\n\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\tNETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_GSO |\n\t\tNETIF_F_GRO | NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_GSO_GRE |\n\t\tNETIF_F_GSO_GRE_CSUM | NETIF_F_GSO_UDP_TUNNEL |\n\t\tNETIF_F_SCTP_CRC | NETIF_F_FRAGLIST;\n\n\tif (hnae3_ae_dev_gro_supported(ae_dev))\n\t\tnetdev->features |= NETIF_F_GRO_HW;\n\n\tif (hnae3_ae_dev_fd_supported(ae_dev))\n\t\tnetdev->features |= NETIF_F_NTUPLE;\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_UDP_GSO_B, ae_dev->caps))\n\t\tnetdev->features |= NETIF_F_GSO_UDP_L4;\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_HW_TX_CSUM_B, ae_dev->caps))\n\t\tnetdev->features |= NETIF_F_HW_CSUM;\n\telse\n\t\tnetdev->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_UDP_TUNNEL_CSUM_B, ae_dev->caps))\n\t\tnetdev->features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_FD_FORWARD_TC_B, ae_dev->caps))\n\t\tnetdev->features |= NETIF_F_HW_TC;\n\n\tnetdev->hw_features |= netdev->features;\n\tif (!test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, ae_dev->caps))\n\t\tnetdev->hw_features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tnetdev->vlan_features |= netdev->features &\n\t\t~(NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t  NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_GRO_HW | NETIF_F_NTUPLE |\n\t\t  NETIF_F_HW_TC);\n\n\tnetdev->hw_enc_features |= netdev->vlan_features | NETIF_F_TSO_MANGLEID;\n\n\t \n\tif (ae_dev->dev_version > HNAE3_DEVICE_VERSION_V2) {\n\t\tnetdev->features &= ~NETIF_F_GSO_GRE;\n\t\tnetdev->features &= ~NETIF_F_GSO_GRE_CSUM;\n\t}\n}\n\nstatic int hns3_alloc_buffer(struct hns3_enet_ring *ring,\n\t\t\t     struct hns3_desc_cb *cb)\n{\n\tunsigned int order = hns3_page_order(ring);\n\tstruct page *p;\n\n\tif (ring->page_pool) {\n\t\tp = page_pool_dev_alloc_frag(ring->page_pool,\n\t\t\t\t\t     &cb->page_offset,\n\t\t\t\t\t     hns3_buf_size(ring));\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\n\t\tcb->priv = p;\n\t\tcb->buf = page_address(p);\n\t\tcb->dma = page_pool_get_dma_addr(p);\n\t\tcb->type = DESC_TYPE_PP_FRAG;\n\t\tcb->reuse_flag = 0;\n\t\treturn 0;\n\t}\n\n\tp = dev_alloc_pages(order);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tcb->priv = p;\n\tcb->page_offset = 0;\n\tcb->reuse_flag = 0;\n\tcb->buf  = page_address(p);\n\tcb->length = hns3_page_size(ring);\n\tcb->type = DESC_TYPE_PAGE;\n\tpage_ref_add(p, USHRT_MAX - 1);\n\tcb->pagecnt_bias = USHRT_MAX;\n\n\treturn 0;\n}\n\nstatic void hns3_free_buffer(struct hns3_enet_ring *ring,\n\t\t\t     struct hns3_desc_cb *cb, int budget)\n{\n\tif (cb->type & (DESC_TYPE_SKB | DESC_TYPE_BOUNCE_HEAD |\n\t\t\tDESC_TYPE_BOUNCE_ALL | DESC_TYPE_SGL_SKB))\n\t\tnapi_consume_skb(cb->priv, budget);\n\telse if (!HNAE3_IS_TX_RING(ring)) {\n\t\tif (cb->type & DESC_TYPE_PAGE && cb->pagecnt_bias)\n\t\t\t__page_frag_cache_drain(cb->priv, cb->pagecnt_bias);\n\t\telse if (cb->type & DESC_TYPE_PP_FRAG)\n\t\t\tpage_pool_put_full_page(ring->page_pool, cb->priv,\n\t\t\t\t\t\tfalse);\n\t}\n\tmemset(cb, 0, sizeof(*cb));\n}\n\nstatic int hns3_map_buffer(struct hns3_enet_ring *ring, struct hns3_desc_cb *cb)\n{\n\tcb->dma = dma_map_page(ring_to_dev(ring), cb->priv, 0,\n\t\t\t       cb->length, ring_to_dma_dir(ring));\n\n\tif (unlikely(dma_mapping_error(ring_to_dev(ring), cb->dma)))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void hns3_unmap_buffer(struct hns3_enet_ring *ring,\n\t\t\t      struct hns3_desc_cb *cb)\n{\n\tif (cb->type & (DESC_TYPE_SKB | DESC_TYPE_FRAGLIST_SKB))\n\t\tdma_unmap_single(ring_to_dev(ring), cb->dma, cb->length,\n\t\t\t\t ring_to_dma_dir(ring));\n\telse if ((cb->type & DESC_TYPE_PAGE) && cb->length)\n\t\tdma_unmap_page(ring_to_dev(ring), cb->dma, cb->length,\n\t\t\t       ring_to_dma_dir(ring));\n\telse if (cb->type & (DESC_TYPE_BOUNCE_ALL | DESC_TYPE_BOUNCE_HEAD |\n\t\t\t     DESC_TYPE_SGL_SKB))\n\t\thns3_tx_spare_reclaim_cb(ring, cb);\n}\n\nstatic void hns3_buffer_detach(struct hns3_enet_ring *ring, int i)\n{\n\thns3_unmap_buffer(ring, &ring->desc_cb[i]);\n\tring->desc[i].addr = 0;\n\tring->desc_cb[i].refill = 0;\n}\n\nstatic void hns3_free_buffer_detach(struct hns3_enet_ring *ring, int i,\n\t\t\t\t    int budget)\n{\n\tstruct hns3_desc_cb *cb = &ring->desc_cb[i];\n\n\tif (!ring->desc_cb[i].dma)\n\t\treturn;\n\n\thns3_buffer_detach(ring, i);\n\thns3_free_buffer(ring, cb, budget);\n}\n\nstatic void hns3_free_buffers(struct hns3_enet_ring *ring)\n{\n\tint i;\n\n\tfor (i = 0; i < ring->desc_num; i++)\n\t\thns3_free_buffer_detach(ring, i, 0);\n}\n\n \nstatic void hns3_free_desc(struct hns3_enet_ring *ring)\n{\n\tint size = ring->desc_num * sizeof(ring->desc[0]);\n\n\thns3_free_buffers(ring);\n\n\tif (ring->desc) {\n\t\tdma_free_coherent(ring_to_dev(ring), size,\n\t\t\t\t  ring->desc, ring->desc_dma_addr);\n\t\tring->desc = NULL;\n\t}\n}\n\nstatic int hns3_alloc_desc(struct hns3_enet_ring *ring)\n{\n\tint size = ring->desc_num * sizeof(ring->desc[0]);\n\n\tring->desc = dma_alloc_coherent(ring_to_dev(ring), size,\n\t\t\t\t\t&ring->desc_dma_addr, GFP_KERNEL);\n\tif (!ring->desc)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int hns3_alloc_and_map_buffer(struct hns3_enet_ring *ring,\n\t\t\t\t   struct hns3_desc_cb *cb)\n{\n\tint ret;\n\n\tret = hns3_alloc_buffer(ring, cb);\n\tif (ret || ring->page_pool)\n\t\tgoto out;\n\n\tret = hns3_map_buffer(ring, cb);\n\tif (ret)\n\t\tgoto out_with_buf;\n\n\treturn 0;\n\nout_with_buf:\n\thns3_free_buffer(ring, cb, 0);\nout:\n\treturn ret;\n}\n\nstatic int hns3_alloc_and_attach_buffer(struct hns3_enet_ring *ring, int i)\n{\n\tint ret = hns3_alloc_and_map_buffer(ring, &ring->desc_cb[i]);\n\n\tif (ret)\n\t\treturn ret;\n\n\tring->desc[i].addr = cpu_to_le64(ring->desc_cb[i].dma +\n\t\t\t\t\t ring->desc_cb[i].page_offset);\n\tring->desc_cb[i].refill = 1;\n\n\treturn 0;\n}\n\n \nstatic int hns3_alloc_ring_buffers(struct hns3_enet_ring *ring)\n{\n\tint i, j, ret;\n\n\tfor (i = 0; i < ring->desc_num; i++) {\n\t\tret = hns3_alloc_and_attach_buffer(ring, i);\n\t\tif (ret)\n\t\t\tgoto out_buffer_fail;\n\t}\n\n\treturn 0;\n\nout_buffer_fail:\n\tfor (j = i - 1; j >= 0; j--)\n\t\thns3_free_buffer_detach(ring, j, 0);\n\treturn ret;\n}\n\n \nstatic void hns3_replace_buffer(struct hns3_enet_ring *ring, int i,\n\t\t\t\tstruct hns3_desc_cb *res_cb)\n{\n\thns3_unmap_buffer(ring, &ring->desc_cb[i]);\n\tring->desc_cb[i] = *res_cb;\n\tring->desc_cb[i].refill = 1;\n\tring->desc[i].addr = cpu_to_le64(ring->desc_cb[i].dma +\n\t\t\t\t\t ring->desc_cb[i].page_offset);\n\tring->desc[i].rx.bd_base_info = 0;\n}\n\nstatic void hns3_reuse_buffer(struct hns3_enet_ring *ring, int i)\n{\n\tring->desc_cb[i].reuse_flag = 0;\n\tring->desc_cb[i].refill = 1;\n\tring->desc[i].addr = cpu_to_le64(ring->desc_cb[i].dma +\n\t\t\t\t\t ring->desc_cb[i].page_offset);\n\tring->desc[i].rx.bd_base_info = 0;\n\n\tdma_sync_single_for_device(ring_to_dev(ring),\n\t\t\tring->desc_cb[i].dma + ring->desc_cb[i].page_offset,\n\t\t\thns3_buf_size(ring),\n\t\t\tDMA_FROM_DEVICE);\n}\n\nstatic bool hns3_nic_reclaim_desc(struct hns3_enet_ring *ring,\n\t\t\t\t  int *bytes, int *pkts, int budget)\n{\n\t \n\tint ltu = smp_load_acquire(&ring->last_to_use);\n\tint ntc = ring->next_to_clean;\n\tstruct hns3_desc_cb *desc_cb;\n\tbool reclaimed = false;\n\tstruct hns3_desc *desc;\n\n\twhile (ltu != ntc) {\n\t\tdesc = &ring->desc[ntc];\n\n\t\tif (le16_to_cpu(desc->tx.bdtp_fe_sc_vld_ra_ri) &\n\t\t\t\tBIT(HNS3_TXD_VLD_B))\n\t\t\tbreak;\n\n\t\tdesc_cb = &ring->desc_cb[ntc];\n\n\t\tif (desc_cb->type & (DESC_TYPE_SKB | DESC_TYPE_BOUNCE_ALL |\n\t\t\t\t     DESC_TYPE_BOUNCE_HEAD |\n\t\t\t\t     DESC_TYPE_SGL_SKB)) {\n\t\t\t(*pkts)++;\n\t\t\t(*bytes) += desc_cb->send_bytes;\n\t\t}\n\n\t\t \n\t\thns3_free_buffer_detach(ring, ntc, budget);\n\n\t\tif (++ntc == ring->desc_num)\n\t\t\tntc = 0;\n\n\t\t \n\t\tprefetch(&ring->desc_cb[ntc]);\n\t\treclaimed = true;\n\t}\n\n\tif (unlikely(!reclaimed))\n\t\treturn false;\n\n\t \n\tsmp_store_release(&ring->next_to_clean, ntc);\n\n\thns3_tx_spare_update(ring);\n\n\treturn true;\n}\n\nvoid hns3_clean_tx_ring(struct hns3_enet_ring *ring, int budget)\n{\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tstruct netdev_queue *dev_queue;\n\tint bytes, pkts;\n\n\tbytes = 0;\n\tpkts = 0;\n\n\tif (unlikely(!hns3_nic_reclaim_desc(ring, &bytes, &pkts, budget)))\n\t\treturn;\n\n\tring->tqp_vector->tx_group.total_bytes += bytes;\n\tring->tqp_vector->tx_group.total_packets += pkts;\n\n\tu64_stats_update_begin(&ring->syncp);\n\tring->stats.tx_bytes += bytes;\n\tring->stats.tx_pkts += pkts;\n\tu64_stats_update_end(&ring->syncp);\n\n\tdev_queue = netdev_get_tx_queue(netdev, ring->tqp->tqp_index);\n\tnetdev_tx_completed_queue(dev_queue, pkts, bytes);\n\n\tif (unlikely(netif_carrier_ok(netdev) &&\n\t\t     ring_space(ring) > HNS3_MAX_TSO_BD_NUM)) {\n\t\t \n\t\tsmp_mb();\n\t\tif (netif_tx_queue_stopped(dev_queue) &&\n\t\t    !test_bit(HNS3_NIC_STATE_DOWN, &priv->state)) {\n\t\t\tnetif_tx_wake_queue(dev_queue);\n\t\t\tring->stats.restart_queue++;\n\t\t}\n\t}\n}\n\nstatic int hns3_desc_unused(struct hns3_enet_ring *ring)\n{\n\tint ntc = ring->next_to_clean;\n\tint ntu = ring->next_to_use;\n\n\tif (unlikely(ntc == ntu && !ring->desc_cb[ntc].refill))\n\t\treturn ring->desc_num;\n\n\treturn ((ntc >= ntu) ? 0 : ring->desc_num) + ntc - ntu;\n}\n\n \nstatic bool hns3_nic_alloc_rx_buffers(struct hns3_enet_ring *ring,\n\t\t\t\t      int cleand_count)\n{\n\tstruct hns3_desc_cb *desc_cb;\n\tstruct hns3_desc_cb res_cbs;\n\tint i, ret;\n\n\tfor (i = 0; i < cleand_count; i++) {\n\t\tdesc_cb = &ring->desc_cb[ring->next_to_use];\n\t\tif (desc_cb->reuse_flag) {\n\t\t\thns3_ring_stats_update(ring, reuse_pg_cnt);\n\n\t\t\thns3_reuse_buffer(ring, ring->next_to_use);\n\t\t} else {\n\t\t\tret = hns3_alloc_and_map_buffer(ring, &res_cbs);\n\t\t\tif (ret) {\n\t\t\t\thns3_ring_stats_update(ring, sw_err_cnt);\n\n\t\t\t\thns3_rl_err(ring_to_netdev(ring),\n\t\t\t\t\t    \"alloc rx buffer failed: %d\\n\",\n\t\t\t\t\t    ret);\n\n\t\t\t\twritel(i, ring->tqp->io_base +\n\t\t\t\t       HNS3_RING_RX_RING_HEAD_REG);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\thns3_replace_buffer(ring, ring->next_to_use, &res_cbs);\n\n\t\t\thns3_ring_stats_update(ring, non_reuse_pg);\n\t\t}\n\n\t\tring_ptr_move_fw(ring, next_to_use);\n\t}\n\n\twritel(i, ring->tqp->io_base + HNS3_RING_RX_RING_HEAD_REG);\n\treturn false;\n}\n\nstatic bool hns3_can_reuse_page(struct hns3_desc_cb *cb)\n{\n\treturn page_count(cb->priv) == cb->pagecnt_bias;\n}\n\nstatic int hns3_handle_rx_copybreak(struct sk_buff *skb, int i,\n\t\t\t\t    struct hns3_enet_ring *ring,\n\t\t\t\t    int pull_len,\n\t\t\t\t    struct hns3_desc_cb *desc_cb)\n{\n\tstruct hns3_desc *desc = &ring->desc[ring->next_to_clean];\n\tu32 frag_offset = desc_cb->page_offset + pull_len;\n\tint size = le16_to_cpu(desc->rx.size);\n\tu32 frag_size = size - pull_len;\n\tvoid *frag = napi_alloc_frag(frag_size);\n\n\tif (unlikely(!frag)) {\n\t\thns3_ring_stats_update(ring, frag_alloc_err);\n\n\t\thns3_rl_err(ring_to_netdev(ring),\n\t\t\t    \"failed to allocate rx frag\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc_cb->reuse_flag = 1;\n\tmemcpy(frag, desc_cb->buf + frag_offset, frag_size);\n\tskb_add_rx_frag(skb, i, virt_to_page(frag),\n\t\t\toffset_in_page(frag), frag_size, frag_size);\n\n\thns3_ring_stats_update(ring, frag_alloc);\n\treturn 0;\n}\n\nstatic void hns3_nic_reuse_page(struct sk_buff *skb, int i,\n\t\t\t\tstruct hns3_enet_ring *ring, int pull_len,\n\t\t\t\tstruct hns3_desc_cb *desc_cb)\n{\n\tstruct hns3_desc *desc = &ring->desc[ring->next_to_clean];\n\tu32 frag_offset = desc_cb->page_offset + pull_len;\n\tint size = le16_to_cpu(desc->rx.size);\n\tu32 truesize = hns3_buf_size(ring);\n\tu32 frag_size = size - pull_len;\n\tint ret = 0;\n\tbool reused;\n\n\tif (ring->page_pool) {\n\t\tskb_add_rx_frag(skb, i, desc_cb->priv, frag_offset,\n\t\t\t\tfrag_size, truesize);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(!dev_page_is_reusable(desc_cb->priv)))\n\t\tgoto out;\n\n\treused = hns3_can_reuse_page(desc_cb);\n\n\t \n\tif ((!desc_cb->page_offset && reused) ||\n\t    ((desc_cb->page_offset + truesize + truesize) <=\n\t     hns3_page_size(ring) && desc_cb->page_offset)) {\n\t\tdesc_cb->page_offset += truesize;\n\t\tdesc_cb->reuse_flag = 1;\n\t} else if (desc_cb->page_offset && reused) {\n\t\tdesc_cb->page_offset = 0;\n\t\tdesc_cb->reuse_flag = 1;\n\t} else if (frag_size <= ring->rx_copybreak) {\n\t\tret = hns3_handle_rx_copybreak(skb, i, ring, pull_len, desc_cb);\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\nout:\n\tdesc_cb->pagecnt_bias--;\n\n\tif (unlikely(!desc_cb->pagecnt_bias)) {\n\t\tpage_ref_add(desc_cb->priv, USHRT_MAX);\n\t\tdesc_cb->pagecnt_bias = USHRT_MAX;\n\t}\n\n\tskb_add_rx_frag(skb, i, desc_cb->priv, frag_offset,\n\t\t\tfrag_size, truesize);\n\n\tif (unlikely(!desc_cb->reuse_flag))\n\t\t__page_frag_cache_drain(desc_cb->priv, desc_cb->pagecnt_bias);\n}\n\nstatic int hns3_gro_complete(struct sk_buff *skb, u32 l234info)\n{\n\t__be16 type = skb->protocol;\n\tstruct tcphdr *th;\n\tint depth = 0;\n\n\twhile (eth_type_vlan(type)) {\n\t\tstruct vlan_hdr *vh;\n\n\t\tif ((depth + VLAN_HLEN) > skb_headlen(skb))\n\t\t\treturn -EFAULT;\n\n\t\tvh = (struct vlan_hdr *)(skb->data + depth);\n\t\ttype = vh->h_vlan_encapsulated_proto;\n\t\tdepth += VLAN_HLEN;\n\t}\n\n\tskb_set_network_header(skb, depth);\n\n\tif (type == htons(ETH_P_IP)) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tdepth += sizeof(struct iphdr);\n\t\tskb_set_transport_header(skb, depth);\n\t\tth = tcp_hdr(skb);\n\t\tth->check = ~tcp_v4_check(skb->len - depth, iph->saddr,\n\t\t\t\t\t  iph->daddr, 0);\n\t} else if (type == htons(ETH_P_IPV6)) {\n\t\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\tdepth += sizeof(struct ipv6hdr);\n\t\tskb_set_transport_header(skb, depth);\n\t\tth = tcp_hdr(skb);\n\t\tth->check = ~tcp_v6_check(skb->len - depth, &iph->saddr,\n\t\t\t\t\t  &iph->daddr, 0);\n\t} else {\n\t\thns3_rl_err(skb->dev,\n\t\t\t    \"Error: FW GRO supports only IPv4/IPv6, not 0x%04x, depth: %d\\n\",\n\t\t\t    be16_to_cpu(type), depth);\n\t\treturn -EFAULT;\n\t}\n\n\tskb_shinfo(skb)->gso_segs = NAPI_GRO_CB(skb)->count;\n\tif (th->cwr)\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_ECN;\n\n\tif (l234info & BIT(HNS3_RXD_GRO_FIXID_B))\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_FIXEDID;\n\n\tskb->csum_start = (unsigned char *)th - skb->head;\n\tskb->csum_offset = offsetof(struct tcphdr, check);\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\n\ttrace_hns3_gro(skb);\n\n\treturn 0;\n}\n\nstatic void hns3_checksum_complete(struct hns3_enet_ring *ring,\n\t\t\t\t   struct sk_buff *skb, u32 ptype, u16 csum)\n{\n\tif (ptype == HNS3_INVALID_PTYPE ||\n\t    hns3_rx_ptype_tbl[ptype].ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\n\thns3_ring_stats_update(ring, csum_complete);\n\tskb->ip_summed = CHECKSUM_COMPLETE;\n\tskb->csum = csum_unfold((__force __sum16)csum);\n}\n\nstatic void hns3_rx_handle_csum(struct sk_buff *skb, u32 l234info,\n\t\t\t\tu32 ol_info, u32 ptype)\n{\n\tint l3_type, l4_type;\n\tint ol4_type;\n\n\tif (ptype != HNS3_INVALID_PTYPE) {\n\t\tskb->csum_level = hns3_rx_ptype_tbl[ptype].csum_level;\n\t\tskb->ip_summed = hns3_rx_ptype_tbl[ptype].ip_summed;\n\n\t\treturn;\n\t}\n\n\tol4_type = hnae3_get_field(ol_info, HNS3_RXD_OL4ID_M,\n\t\t\t\t   HNS3_RXD_OL4ID_S);\n\tswitch (ol4_type) {\n\tcase HNS3_OL4_TYPE_MAC_IN_UDP:\n\tcase HNS3_OL4_TYPE_NVGRE:\n\t\tskb->csum_level = 1;\n\t\tfallthrough;\n\tcase HNS3_OL4_TYPE_NO_TUN:\n\t\tl3_type = hnae3_get_field(l234info, HNS3_RXD_L3ID_M,\n\t\t\t\t\t  HNS3_RXD_L3ID_S);\n\t\tl4_type = hnae3_get_field(l234info, HNS3_RXD_L4ID_M,\n\t\t\t\t\t  HNS3_RXD_L4ID_S);\n\t\t \n\t\tif ((l3_type == HNS3_L3_TYPE_IPV4 ||\n\t\t     l3_type == HNS3_L3_TYPE_IPV6) &&\n\t\t    (l4_type == HNS3_L4_TYPE_UDP ||\n\t\t     l4_type == HNS3_L4_TYPE_TCP ||\n\t\t     l4_type == HNS3_L4_TYPE_SCTP))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void hns3_rx_checksum(struct hns3_enet_ring *ring, struct sk_buff *skb,\n\t\t\t     u32 l234info, u32 bd_base_info, u32 ol_info,\n\t\t\t     u16 csum)\n{\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tu32 ptype = HNS3_INVALID_PTYPE;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_checksum_none_assert(skb);\n\n\tif (!(netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\tif (test_bit(HNS3_NIC_STATE_RXD_ADV_LAYOUT_ENABLE, &priv->state))\n\t\tptype = hnae3_get_field(ol_info, HNS3_RXD_PTYPE_M,\n\t\t\t\t\tHNS3_RXD_PTYPE_S);\n\n\thns3_checksum_complete(ring, skb, ptype, csum);\n\n\t \n\tif (!(bd_base_info & BIT(HNS3_RXD_L3L4P_B)))\n\t\treturn;\n\n\tif (unlikely(l234info & (BIT(HNS3_RXD_L3E_B) | BIT(HNS3_RXD_L4E_B) |\n\t\t\t\t BIT(HNS3_RXD_OL3E_B) |\n\t\t\t\t BIT(HNS3_RXD_OL4E_B)))) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\thns3_ring_stats_update(ring, l3l4_csum_err);\n\n\t\treturn;\n\t}\n\n\thns3_rx_handle_csum(skb, l234info, ol_info, ptype);\n}\n\nstatic void hns3_rx_skb(struct hns3_enet_ring *ring, struct sk_buff *skb)\n{\n\tif (skb_has_frag_list(skb))\n\t\tnapi_gro_flush(&ring->tqp_vector->napi, false);\n\n\tnapi_gro_receive(&ring->tqp_vector->napi, skb);\n}\n\nstatic bool hns3_parse_vlan_tag(struct hns3_enet_ring *ring,\n\t\t\t\tstruct hns3_desc *desc, u32 l234info,\n\t\t\t\tu16 *vlan_tag)\n{\n\tstruct hnae3_handle *handle = ring->tqp->handle;\n\tstruct pci_dev *pdev = ring->tqp->handle->pdev;\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\n\tif (unlikely(ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)) {\n\t\t*vlan_tag = le16_to_cpu(desc->rx.ot_vlan_tag);\n\t\tif (!(*vlan_tag & VLAN_VID_MASK))\n\t\t\t*vlan_tag = le16_to_cpu(desc->rx.vlan_tag);\n\n\t\treturn (*vlan_tag != 0);\n\t}\n\n#define HNS3_STRP_OUTER_VLAN\t0x1\n#define HNS3_STRP_INNER_VLAN\t0x2\n#define HNS3_STRP_BOTH\t\t0x3\n\n\t \n\tswitch (hnae3_get_field(l234info, HNS3_RXD_STRP_TAGP_M,\n\t\t\t\tHNS3_RXD_STRP_TAGP_S)) {\n\tcase HNS3_STRP_OUTER_VLAN:\n\t\tif (handle->port_base_vlan_state !=\n\t\t\t\tHNAE3_PORT_BASE_VLAN_DISABLE)\n\t\t\treturn false;\n\n\t\t*vlan_tag = le16_to_cpu(desc->rx.ot_vlan_tag);\n\t\treturn true;\n\tcase HNS3_STRP_INNER_VLAN:\n\t\tif (handle->port_base_vlan_state !=\n\t\t\t\tHNAE3_PORT_BASE_VLAN_DISABLE)\n\t\t\treturn false;\n\n\t\t*vlan_tag = le16_to_cpu(desc->rx.vlan_tag);\n\t\treturn true;\n\tcase HNS3_STRP_BOTH:\n\t\tif (handle->port_base_vlan_state ==\n\t\t\t\tHNAE3_PORT_BASE_VLAN_DISABLE)\n\t\t\t*vlan_tag = le16_to_cpu(desc->rx.ot_vlan_tag);\n\t\telse\n\t\t\t*vlan_tag = le16_to_cpu(desc->rx.vlan_tag);\n\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void hns3_rx_ring_move_fw(struct hns3_enet_ring *ring)\n{\n\tring->desc[ring->next_to_clean].rx.bd_base_info &=\n\t\tcpu_to_le32(~BIT(HNS3_RXD_VLD_B));\n\tring->desc_cb[ring->next_to_clean].refill = 0;\n\tring->next_to_clean += 1;\n\n\tif (unlikely(ring->next_to_clean == ring->desc_num))\n\t\tring->next_to_clean = 0;\n}\n\nstatic int hns3_alloc_skb(struct hns3_enet_ring *ring, unsigned int length,\n\t\t\t  unsigned char *va)\n{\n\tstruct hns3_desc_cb *desc_cb = &ring->desc_cb[ring->next_to_clean];\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\tstruct sk_buff *skb;\n\n\tring->skb = napi_alloc_skb(&ring->tqp_vector->napi, HNS3_RX_HEAD_SIZE);\n\tskb = ring->skb;\n\tif (unlikely(!skb)) {\n\t\thns3_rl_err(netdev, \"alloc rx skb fail\\n\");\n\t\thns3_ring_stats_update(ring, sw_err_cnt);\n\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_hns3_rx_desc(ring);\n\tprefetchw(skb->data);\n\n\tring->pending_buf = 1;\n\tring->frag_num = 0;\n\tring->tail_skb = NULL;\n\tif (length <= HNS3_RX_HEAD_SIZE) {\n\t\tmemcpy(__skb_put(skb, length), va, ALIGN(length, sizeof(long)));\n\n\t\t \n\t\tif (dev_page_is_reusable(desc_cb->priv))\n\t\t\tdesc_cb->reuse_flag = 1;\n\t\telse if (desc_cb->type & DESC_TYPE_PP_FRAG)\n\t\t\tpage_pool_put_full_page(ring->page_pool, desc_cb->priv,\n\t\t\t\t\t\tfalse);\n\t\telse  \n\t\t\t__page_frag_cache_drain(desc_cb->priv,\n\t\t\t\t\t\tdesc_cb->pagecnt_bias);\n\n\t\thns3_rx_ring_move_fw(ring);\n\t\treturn 0;\n\t}\n\n\tif (ring->page_pool)\n\t\tskb_mark_for_recycle(skb);\n\n\thns3_ring_stats_update(ring, seg_pkt_cnt);\n\n\tring->pull_len = eth_get_headlen(netdev, va, HNS3_RX_HEAD_SIZE);\n\t__skb_put(skb, ring->pull_len);\n\thns3_nic_reuse_page(skb, ring->frag_num++, ring, ring->pull_len,\n\t\t\t    desc_cb);\n\thns3_rx_ring_move_fw(ring);\n\n\treturn 0;\n}\n\nstatic int hns3_add_frag(struct hns3_enet_ring *ring)\n{\n\tstruct sk_buff *skb = ring->skb;\n\tstruct sk_buff *head_skb = skb;\n\tstruct sk_buff *new_skb;\n\tstruct hns3_desc_cb *desc_cb;\n\tstruct hns3_desc *desc;\n\tu32 bd_base_info;\n\n\tdo {\n\t\tdesc = &ring->desc[ring->next_to_clean];\n\t\tdesc_cb = &ring->desc_cb[ring->next_to_clean];\n\t\tbd_base_info = le32_to_cpu(desc->rx.bd_base_info);\n\t\t \n\t\tdma_rmb();\n\t\tif (!(bd_base_info & BIT(HNS3_RXD_VLD_B)))\n\t\t\treturn -ENXIO;\n\n\t\tif (unlikely(ring->frag_num >= MAX_SKB_FRAGS)) {\n\t\t\tnew_skb = napi_alloc_skb(&ring->tqp_vector->napi, 0);\n\t\t\tif (unlikely(!new_skb)) {\n\t\t\t\thns3_rl_err(ring_to_netdev(ring),\n\t\t\t\t\t    \"alloc rx fraglist skb fail\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\n\t\t\tif (ring->page_pool)\n\t\t\t\tskb_mark_for_recycle(new_skb);\n\n\t\t\tring->frag_num = 0;\n\n\t\t\tif (ring->tail_skb) {\n\t\t\t\tring->tail_skb->next = new_skb;\n\t\t\t\tring->tail_skb = new_skb;\n\t\t\t} else {\n\t\t\t\tskb_shinfo(skb)->frag_list = new_skb;\n\t\t\t\tring->tail_skb = new_skb;\n\t\t\t}\n\t\t}\n\n\t\tif (ring->tail_skb) {\n\t\t\thead_skb->truesize += hns3_buf_size(ring);\n\t\t\thead_skb->data_len += le16_to_cpu(desc->rx.size);\n\t\t\thead_skb->len += le16_to_cpu(desc->rx.size);\n\t\t\tskb = ring->tail_skb;\n\t\t}\n\n\t\tdma_sync_single_for_cpu(ring_to_dev(ring),\n\t\t\t\tdesc_cb->dma + desc_cb->page_offset,\n\t\t\t\thns3_buf_size(ring),\n\t\t\t\tDMA_FROM_DEVICE);\n\n\t\thns3_nic_reuse_page(skb, ring->frag_num++, ring, 0, desc_cb);\n\t\ttrace_hns3_rx_desc(ring);\n\t\thns3_rx_ring_move_fw(ring);\n\t\tring->pending_buf++;\n\t} while (!(bd_base_info & BIT(HNS3_RXD_FE_B)));\n\n\treturn 0;\n}\n\nstatic int hns3_set_gro_and_checksum(struct hns3_enet_ring *ring,\n\t\t\t\t     struct sk_buff *skb, u32 l234info,\n\t\t\t\t     u32 bd_base_info, u32 ol_info, u16 csum)\n{\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tu32 l3_type;\n\n\tskb_shinfo(skb)->gso_size = hnae3_get_field(bd_base_info,\n\t\t\t\t\t\t    HNS3_RXD_GRO_SIZE_M,\n\t\t\t\t\t\t    HNS3_RXD_GRO_SIZE_S);\n\t \n\tif (!skb_shinfo(skb)->gso_size) {\n\t\thns3_rx_checksum(ring, skb, l234info, bd_base_info, ol_info,\n\t\t\t\t csum);\n\t\treturn 0;\n\t}\n\n\tNAPI_GRO_CB(skb)->count = hnae3_get_field(l234info,\n\t\t\t\t\t\t  HNS3_RXD_GRO_COUNT_M,\n\t\t\t\t\t\t  HNS3_RXD_GRO_COUNT_S);\n\n\tif (test_bit(HNS3_NIC_STATE_RXD_ADV_LAYOUT_ENABLE, &priv->state)) {\n\t\tu32 ptype = hnae3_get_field(ol_info, HNS3_RXD_PTYPE_M,\n\t\t\t\t\t    HNS3_RXD_PTYPE_S);\n\n\t\tl3_type = hns3_rx_ptype_tbl[ptype].l3_type;\n\t} else {\n\t\tl3_type = hnae3_get_field(l234info, HNS3_RXD_L3ID_M,\n\t\t\t\t\t  HNS3_RXD_L3ID_S);\n\t}\n\n\tif (l3_type == HNS3_L3_TYPE_IPV4)\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\telse if (l3_type == HNS3_L3_TYPE_IPV6)\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV6;\n\telse\n\t\treturn -EFAULT;\n\n\treturn  hns3_gro_complete(skb, l234info);\n}\n\nstatic void hns3_set_rx_skb_rss_type(struct hns3_enet_ring *ring,\n\t\t\t\t     struct sk_buff *skb, u32 rss_hash,\n\t\t\t\t     u32 l234info, u32 ol_info)\n{\n\tenum pkt_hash_types rss_type = PKT_HASH_TYPE_NONE;\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\n\tif (test_bit(HNS3_NIC_STATE_RXD_ADV_LAYOUT_ENABLE, &priv->state)) {\n\t\tu32 ptype = hnae3_get_field(ol_info, HNS3_RXD_PTYPE_M,\n\t\t\t\t\t    HNS3_RXD_PTYPE_S);\n\n\t\trss_type = hns3_rx_ptype_tbl[ptype].hash_type;\n\t} else {\n\t\tint l3_type = hnae3_get_field(l234info, HNS3_RXD_L3ID_M,\n\t\t\t\t\t      HNS3_RXD_L3ID_S);\n\t\tint l4_type = hnae3_get_field(l234info, HNS3_RXD_L4ID_M,\n\t\t\t\t\t      HNS3_RXD_L4ID_S);\n\n\t\tif (l3_type == HNS3_L3_TYPE_IPV4 ||\n\t\t    l3_type == HNS3_L3_TYPE_IPV6) {\n\t\t\tif (l4_type == HNS3_L4_TYPE_UDP ||\n\t\t\t    l4_type == HNS3_L4_TYPE_TCP ||\n\t\t\t    l4_type == HNS3_L4_TYPE_SCTP)\n\t\t\t\trss_type = PKT_HASH_TYPE_L4;\n\t\t\telse if (l4_type == HNS3_L4_TYPE_IGMP ||\n\t\t\t\t l4_type == HNS3_L4_TYPE_ICMP)\n\t\t\t\trss_type = PKT_HASH_TYPE_L3;\n\t\t}\n\t}\n\n\tskb_set_hash(skb, rss_hash, rss_type);\n}\n\nstatic void hns3_handle_rx_ts_info(struct net_device *netdev,\n\t\t\t\t   struct hns3_desc *desc, struct sk_buff *skb,\n\t\t\t\t   u32 bd_base_info)\n{\n\tif (unlikely(bd_base_info & BIT(HNS3_RXD_TS_VLD_B))) {\n\t\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\t\tu32 nsec = le32_to_cpu(desc->ts_nsec);\n\t\tu32 sec = le32_to_cpu(desc->ts_sec);\n\n\t\tif (h->ae_algo->ops->get_rx_hwts)\n\t\t\th->ae_algo->ops->get_rx_hwts(h, skb, nsec, sec);\n\t}\n}\n\nstatic void hns3_handle_rx_vlan_tag(struct hns3_enet_ring *ring,\n\t\t\t\t    struct hns3_desc *desc, struct sk_buff *skb,\n\t\t\t\t    u32 l234info)\n{\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\n\t \n\tif (netdev->features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\tu16 vlan_tag;\n\n\t\tif (hns3_parse_vlan_tag(ring, desc, l234info, &vlan_tag))\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       vlan_tag);\n\t}\n}\n\nstatic int hns3_handle_bdinfo(struct hns3_enet_ring *ring, struct sk_buff *skb)\n{\n\tstruct net_device *netdev = ring_to_netdev(ring);\n\tenum hns3_pkt_l2t_type l2_frame_type;\n\tu32 bd_base_info, l234info, ol_info;\n\tstruct hns3_desc *desc;\n\tunsigned int len;\n\tint pre_ntc, ret;\n\tu16 csum;\n\n\t \n\tpre_ntc = ring->next_to_clean ? (ring->next_to_clean - 1) :\n\t\t\t\t\t(ring->desc_num - 1);\n\tdesc = &ring->desc[pre_ntc];\n\tbd_base_info = le32_to_cpu(desc->rx.bd_base_info);\n\tl234info = le32_to_cpu(desc->rx.l234_info);\n\tol_info = le32_to_cpu(desc->rx.ol_info);\n\tcsum = le16_to_cpu(desc->csum);\n\n\thns3_handle_rx_ts_info(netdev, desc, skb, bd_base_info);\n\n\thns3_handle_rx_vlan_tag(ring, desc, skb, l234info);\n\n\tif (unlikely(!desc->rx.pkt_len || (l234info & (BIT(HNS3_RXD_TRUNCAT_B) |\n\t\t\t\t  BIT(HNS3_RXD_L2E_B))))) {\n\t\tu64_stats_update_begin(&ring->syncp);\n\t\tif (l234info & BIT(HNS3_RXD_L2E_B))\n\t\t\tring->stats.l2_err++;\n\t\telse\n\t\t\tring->stats.err_pkt_len++;\n\t\tu64_stats_update_end(&ring->syncp);\n\n\t\treturn -EFAULT;\n\t}\n\n\tlen = skb->len;\n\n\t \n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t \n\tret = hns3_set_gro_and_checksum(ring, skb, l234info,\n\t\t\t\t\tbd_base_info, ol_info, csum);\n\tif (unlikely(ret)) {\n\t\thns3_ring_stats_update(ring, rx_err_cnt);\n\t\treturn ret;\n\t}\n\n\tl2_frame_type = hnae3_get_field(l234info, HNS3_RXD_DMAC_M,\n\t\t\t\t\tHNS3_RXD_DMAC_S);\n\n\tu64_stats_update_begin(&ring->syncp);\n\tring->stats.rx_pkts++;\n\tring->stats.rx_bytes += len;\n\n\tif (l2_frame_type == HNS3_L2_TYPE_MULTICAST)\n\t\tring->stats.rx_multicast++;\n\n\tu64_stats_update_end(&ring->syncp);\n\n\tring->tqp_vector->rx_group.total_bytes += len;\n\n\thns3_set_rx_skb_rss_type(ring, skb, le32_to_cpu(desc->rx.rss_hash),\n\t\t\t\t l234info, ol_info);\n\treturn 0;\n}\n\nstatic int hns3_handle_rx_bd(struct hns3_enet_ring *ring)\n{\n\tstruct sk_buff *skb = ring->skb;\n\tstruct hns3_desc_cb *desc_cb;\n\tstruct hns3_desc *desc;\n\tunsigned int length;\n\tu32 bd_base_info;\n\tint ret;\n\n\tdesc = &ring->desc[ring->next_to_clean];\n\tdesc_cb = &ring->desc_cb[ring->next_to_clean];\n\n\tprefetch(desc);\n\n\tif (!skb) {\n\t\tbd_base_info = le32_to_cpu(desc->rx.bd_base_info);\n\t\t \n\t\tif (unlikely(!(bd_base_info & BIT(HNS3_RXD_VLD_B))))\n\t\t\treturn -ENXIO;\n\n\t\tdma_rmb();\n\t\tlength = le16_to_cpu(desc->rx.size);\n\n\t\tring->va = desc_cb->buf + desc_cb->page_offset;\n\n\t\tdma_sync_single_for_cpu(ring_to_dev(ring),\n\t\t\t\tdesc_cb->dma + desc_cb->page_offset,\n\t\t\t\thns3_buf_size(ring),\n\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t \n\t\tnet_prefetch(ring->va);\n\n\t\tret = hns3_alloc_skb(ring, length, ring->va);\n\t\tskb = ring->skb;\n\n\t\tif (ret < 0)  \n\t\t\treturn ret;\n\t\tif (!(bd_base_info & BIT(HNS3_RXD_FE_B))) {  \n\t\t\tret = hns3_add_frag(ring);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = hns3_add_frag(ring);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (skb->len > HNS3_RX_HEAD_SIZE)\n\t\tmemcpy(skb->data, ring->va,\n\t\t       ALIGN(ring->pull_len, sizeof(long)));\n\n\tret = hns3_handle_bdinfo(ring, skb);\n\tif (unlikely(ret)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\tskb_record_rx_queue(skb, ring->tqp->tqp_index);\n\treturn 0;\n}\n\nint hns3_clean_rx_ring(struct hns3_enet_ring *ring, int budget,\n\t\t       void (*rx_fn)(struct hns3_enet_ring *, struct sk_buff *))\n{\n#define RCB_NOF_ALLOC_RX_BUFF_ONCE 16\n\tint unused_count = hns3_desc_unused(ring);\n\tbool failure = false;\n\tint recv_pkts = 0;\n\tint err;\n\n\tunused_count -= ring->pending_buf;\n\n\twhile (recv_pkts < budget) {\n\t\t \n\t\tif (unused_count >= RCB_NOF_ALLOC_RX_BUFF_ONCE) {\n\t\t\tfailure = failure ||\n\t\t\t\thns3_nic_alloc_rx_buffers(ring, unused_count);\n\t\t\tunused_count = 0;\n\t\t}\n\n\t\t \n\t\terr = hns3_handle_rx_bd(ring);\n\t\t \n\t\tif (unlikely(!ring->skb || err == -ENXIO)) {\n\t\t\tgoto out;\n\t\t} else if (likely(!err)) {\n\t\t\trx_fn(ring, ring->skb);\n\t\t\trecv_pkts++;\n\t\t}\n\n\t\tunused_count += ring->pending_buf;\n\t\tring->skb = NULL;\n\t\tring->pending_buf = 0;\n\t}\n\nout:\n\t \n\tif (unused_count > 0)\n\t\tfailure = failure ||\n\t\t\t  hns3_nic_alloc_rx_buffers(ring, unused_count);\n\n\treturn failure ? budget : recv_pkts;\n}\n\nstatic void hns3_update_rx_int_coalesce(struct hns3_enet_tqp_vector *tqp_vector)\n{\n\tstruct hns3_enet_ring_group *rx_group = &tqp_vector->rx_group;\n\tstruct dim_sample sample = {};\n\n\tif (!rx_group->coal.adapt_enable)\n\t\treturn;\n\n\tdim_update_sample(tqp_vector->event_cnt, rx_group->total_packets,\n\t\t\t  rx_group->total_bytes, &sample);\n\tnet_dim(&rx_group->dim, sample);\n}\n\nstatic void hns3_update_tx_int_coalesce(struct hns3_enet_tqp_vector *tqp_vector)\n{\n\tstruct hns3_enet_ring_group *tx_group = &tqp_vector->tx_group;\n\tstruct dim_sample sample = {};\n\n\tif (!tx_group->coal.adapt_enable)\n\t\treturn;\n\n\tdim_update_sample(tqp_vector->event_cnt, tx_group->total_packets,\n\t\t\t  tx_group->total_bytes, &sample);\n\tnet_dim(&tx_group->dim, sample);\n}\n\nstatic int hns3_nic_common_poll(struct napi_struct *napi, int budget)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(napi->dev);\n\tstruct hns3_enet_ring *ring;\n\tint rx_pkt_total = 0;\n\n\tstruct hns3_enet_tqp_vector *tqp_vector =\n\t\tcontainer_of(napi, struct hns3_enet_tqp_vector, napi);\n\tbool clean_complete = true;\n\tint rx_budget = budget;\n\n\tif (unlikely(test_bit(HNS3_NIC_STATE_DOWN, &priv->state))) {\n\t\tnapi_complete(napi);\n\t\treturn 0;\n\t}\n\n\t \n\thns3_for_each_ring(ring, tqp_vector->tx_group)\n\t\thns3_clean_tx_ring(ring, budget);\n\n\t \n\tif (tqp_vector->num_tqps > 1)\n\t\trx_budget = max(budget / tqp_vector->num_tqps, 1);\n\n\thns3_for_each_ring(ring, tqp_vector->rx_group) {\n\t\tint rx_cleaned = hns3_clean_rx_ring(ring, rx_budget,\n\t\t\t\t\t\t    hns3_rx_skb);\n\t\tif (rx_cleaned >= rx_budget)\n\t\t\tclean_complete = false;\n\n\t\trx_pkt_total += rx_cleaned;\n\t}\n\n\ttqp_vector->rx_group.total_packets += rx_pkt_total;\n\n\tif (!clean_complete)\n\t\treturn budget;\n\n\tif (napi_complete(napi) &&\n\t    likely(!test_bit(HNS3_NIC_STATE_DOWN, &priv->state))) {\n\t\thns3_update_rx_int_coalesce(tqp_vector);\n\t\thns3_update_tx_int_coalesce(tqp_vector);\n\n\t\thns3_mask_vector_irq(tqp_vector, 1);\n\t}\n\n\treturn rx_pkt_total;\n}\n\nstatic int hns3_create_ring_chain(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t  struct hnae3_ring_chain_node **head,\n\t\t\t\t  bool is_tx)\n{\n\tu32 bit_value = is_tx ? HNAE3_RING_TYPE_TX : HNAE3_RING_TYPE_RX;\n\tu32 field_value = is_tx ? HNAE3_RING_GL_TX : HNAE3_RING_GL_RX;\n\tstruct hnae3_ring_chain_node *cur_chain = *head;\n\tstruct pci_dev *pdev = tqp_vector->handle->pdev;\n\tstruct hnae3_ring_chain_node *chain;\n\tstruct hns3_enet_ring *ring;\n\n\tring = is_tx ? tqp_vector->tx_group.ring : tqp_vector->rx_group.ring;\n\n\tif (cur_chain) {\n\t\twhile (cur_chain->next)\n\t\t\tcur_chain = cur_chain->next;\n\t}\n\n\twhile (ring) {\n\t\tchain = devm_kzalloc(&pdev->dev, sizeof(*chain), GFP_KERNEL);\n\t\tif (!chain)\n\t\t\treturn -ENOMEM;\n\t\tif (cur_chain)\n\t\t\tcur_chain->next = chain;\n\t\telse\n\t\t\t*head = chain;\n\t\tchain->tqp_index = ring->tqp->tqp_index;\n\t\thnae3_set_bit(chain->flag, HNAE3_RING_TYPE_B,\n\t\t\t\tbit_value);\n\t\thnae3_set_field(chain->int_gl_idx,\n\t\t\t\tHNAE3_RING_GL_IDX_M,\n\t\t\t\tHNAE3_RING_GL_IDX_S, field_value);\n\n\t\tcur_chain = chain;\n\n\t\tring = ring->next;\n\t}\n\n\treturn 0;\n}\n\nstatic struct hnae3_ring_chain_node *\nhns3_get_vector_ring_chain(struct hns3_enet_tqp_vector *tqp_vector)\n{\n\tstruct pci_dev *pdev = tqp_vector->handle->pdev;\n\tstruct hnae3_ring_chain_node *cur_chain = NULL;\n\tstruct hnae3_ring_chain_node *chain;\n\n\tif (hns3_create_ring_chain(tqp_vector, &cur_chain, true))\n\t\tgoto err_free_chain;\n\n\tif (hns3_create_ring_chain(tqp_vector, &cur_chain, false))\n\t\tgoto err_free_chain;\n\n\treturn cur_chain;\n\nerr_free_chain:\n\twhile (cur_chain) {\n\t\tchain = cur_chain->next;\n\t\tdevm_kfree(&pdev->dev, cur_chain);\n\t\tcur_chain = chain;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hns3_free_vector_ring_chain(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t\t\tstruct hnae3_ring_chain_node *head)\n{\n\tstruct pci_dev *pdev = tqp_vector->handle->pdev;\n\tstruct hnae3_ring_chain_node *chain_tmp, *chain;\n\n\tchain = head;\n\n\twhile (chain) {\n\t\tchain_tmp = chain->next;\n\t\tdevm_kfree(&pdev->dev, chain);\n\t\tchain = chain_tmp;\n\t}\n}\n\nstatic void hns3_add_ring_to_group(struct hns3_enet_ring_group *group,\n\t\t\t\t   struct hns3_enet_ring *ring)\n{\n\tring->next = group->ring;\n\tgroup->ring = ring;\n\n\tgroup->count++;\n}\n\nstatic void hns3_nic_set_cpumask(struct hns3_nic_priv *priv)\n{\n\tstruct pci_dev *pdev = priv->ae_handle->pdev;\n\tstruct hns3_enet_tqp_vector *tqp_vector;\n\tint num_vectors = priv->vector_num;\n\tint numa_node;\n\tint vector_i;\n\n\tnuma_node = dev_to_node(&pdev->dev);\n\n\tfor (vector_i = 0; vector_i < num_vectors; vector_i++) {\n\t\ttqp_vector = &priv->tqp_vector[vector_i];\n\t\tcpumask_set_cpu(cpumask_local_spread(vector_i, numa_node),\n\t\t\t\t&tqp_vector->affinity_mask);\n\t}\n}\n\nstatic void hns3_rx_dim_work(struct work_struct *work)\n{\n\tstruct dim *dim = container_of(work, struct dim, work);\n\tstruct hns3_enet_ring_group *group = container_of(dim,\n\t\tstruct hns3_enet_ring_group, dim);\n\tstruct hns3_enet_tqp_vector *tqp_vector = group->ring->tqp_vector;\n\tstruct dim_cq_moder cur_moder =\n\t\tnet_dim_get_rx_moderation(dim->mode, dim->profile_ix);\n\n\thns3_set_vector_coalesce_rx_gl(group->ring->tqp_vector, cur_moder.usec);\n\ttqp_vector->rx_group.coal.int_gl = cur_moder.usec;\n\n\tif (cur_moder.pkts < tqp_vector->rx_group.coal.int_ql_max) {\n\t\thns3_set_vector_coalesce_rx_ql(tqp_vector, cur_moder.pkts);\n\t\ttqp_vector->rx_group.coal.int_ql = cur_moder.pkts;\n\t}\n\n\tdim->state = DIM_START_MEASURE;\n}\n\nstatic void hns3_tx_dim_work(struct work_struct *work)\n{\n\tstruct dim *dim = container_of(work, struct dim, work);\n\tstruct hns3_enet_ring_group *group = container_of(dim,\n\t\tstruct hns3_enet_ring_group, dim);\n\tstruct hns3_enet_tqp_vector *tqp_vector = group->ring->tqp_vector;\n\tstruct dim_cq_moder cur_moder =\n\t\tnet_dim_get_tx_moderation(dim->mode, dim->profile_ix);\n\n\thns3_set_vector_coalesce_tx_gl(tqp_vector, cur_moder.usec);\n\ttqp_vector->tx_group.coal.int_gl = cur_moder.usec;\n\n\tif (cur_moder.pkts < tqp_vector->tx_group.coal.int_ql_max) {\n\t\thns3_set_vector_coalesce_tx_ql(tqp_vector, cur_moder.pkts);\n\t\ttqp_vector->tx_group.coal.int_ql = cur_moder.pkts;\n\t}\n\n\tdim->state = DIM_START_MEASURE;\n}\n\nstatic void hns3_nic_init_dim(struct hns3_enet_tqp_vector *tqp_vector)\n{\n\tINIT_WORK(&tqp_vector->rx_group.dim.work, hns3_rx_dim_work);\n\tINIT_WORK(&tqp_vector->tx_group.dim.work, hns3_tx_dim_work);\n}\n\nstatic int hns3_nic_init_vector_data(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tstruct hns3_enet_tqp_vector *tqp_vector;\n\tint ret;\n\tint i;\n\n\thns3_nic_set_cpumask(priv);\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\ttqp_vector = &priv->tqp_vector[i];\n\t\thns3_vector_coalesce_init_hw(tqp_vector, priv);\n\t\ttqp_vector->num_tqps = 0;\n\t\thns3_nic_init_dim(tqp_vector);\n\t}\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\tu16 vector_i = i % priv->vector_num;\n\t\tu16 tqp_num = h->kinfo.num_tqps;\n\n\t\ttqp_vector = &priv->tqp_vector[vector_i];\n\n\t\thns3_add_ring_to_group(&tqp_vector->tx_group,\n\t\t\t\t       &priv->ring[i]);\n\n\t\thns3_add_ring_to_group(&tqp_vector->rx_group,\n\t\t\t\t       &priv->ring[i + tqp_num]);\n\n\t\tpriv->ring[i].tqp_vector = tqp_vector;\n\t\tpriv->ring[i + tqp_num].tqp_vector = tqp_vector;\n\t\ttqp_vector->num_tqps++;\n\t}\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\tstruct hnae3_ring_chain_node *vector_ring_chain;\n\n\t\ttqp_vector = &priv->tqp_vector[i];\n\n\t\ttqp_vector->rx_group.total_bytes = 0;\n\t\ttqp_vector->rx_group.total_packets = 0;\n\t\ttqp_vector->tx_group.total_bytes = 0;\n\t\ttqp_vector->tx_group.total_packets = 0;\n\t\ttqp_vector->handle = h;\n\n\t\tvector_ring_chain = hns3_get_vector_ring_chain(tqp_vector);\n\t\tif (!vector_ring_chain) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto map_ring_fail;\n\t\t}\n\n\t\tret = h->ae_algo->ops->map_ring_to_vector(h,\n\t\t\ttqp_vector->vector_irq, vector_ring_chain);\n\n\t\thns3_free_vector_ring_chain(tqp_vector, vector_ring_chain);\n\n\t\tif (ret)\n\t\t\tgoto map_ring_fail;\n\n\t\tnetif_napi_add(priv->netdev, &tqp_vector->napi,\n\t\t\t       hns3_nic_common_poll);\n\t}\n\n\treturn 0;\n\nmap_ring_fail:\n\twhile (i--)\n\t\tnetif_napi_del(&priv->tqp_vector[i].napi);\n\n\treturn ret;\n}\n\nstatic void hns3_nic_init_coal_cfg(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(priv->ae_handle->pdev);\n\tstruct hns3_enet_coalesce *tx_coal = &priv->tx_coal;\n\tstruct hns3_enet_coalesce *rx_coal = &priv->rx_coal;\n\n\t \n\ttx_coal->adapt_enable = 1;\n\trx_coal->adapt_enable = 1;\n\n\ttx_coal->int_gl = HNS3_INT_GL_50K;\n\trx_coal->int_gl = HNS3_INT_GL_50K;\n\n\trx_coal->flow_level = HNS3_FLOW_LOW;\n\ttx_coal->flow_level = HNS3_FLOW_LOW;\n\n\tif (ae_dev->dev_specs.int_ql_max) {\n\t\ttx_coal->int_ql = HNS3_INT_QL_DEFAULT_CFG;\n\t\trx_coal->int_ql = HNS3_INT_QL_DEFAULT_CFG;\n\t}\n}\n\nstatic int hns3_nic_alloc_vector_data(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tstruct hns3_enet_tqp_vector *tqp_vector;\n\tstruct hnae3_vector_info *vector;\n\tstruct pci_dev *pdev = h->pdev;\n\tu16 tqp_num = h->kinfo.num_tqps;\n\tu16 vector_num;\n\tint ret = 0;\n\tu16 i;\n\n\t \n\t \n\tvector_num = min_t(u16, num_online_cpus(), tqp_num);\n\n\tvector = devm_kcalloc(&pdev->dev, vector_num, sizeof(*vector),\n\t\t\t      GFP_KERNEL);\n\tif (!vector)\n\t\treturn -ENOMEM;\n\n\t \n\tvector_num = h->ae_algo->ops->get_vector(h, vector_num, vector);\n\n\tpriv->vector_num = vector_num;\n\tpriv->tqp_vector = (struct hns3_enet_tqp_vector *)\n\t\tdevm_kcalloc(&pdev->dev, vector_num, sizeof(*priv->tqp_vector),\n\t\t\t     GFP_KERNEL);\n\tif (!priv->tqp_vector) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\ttqp_vector = &priv->tqp_vector[i];\n\t\ttqp_vector->idx = i;\n\t\ttqp_vector->mask_addr = vector[i].io_addr;\n\t\ttqp_vector->vector_irq = vector[i].vector;\n\t\thns3_vector_coalesce_init(tqp_vector, priv);\n\t}\n\nout:\n\tdevm_kfree(&pdev->dev, vector);\n\treturn ret;\n}\n\nstatic void hns3_clear_ring_group(struct hns3_enet_ring_group *group)\n{\n\tgroup->ring = NULL;\n\tgroup->count = 0;\n}\n\nstatic void hns3_nic_uninit_vector_data(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_ring_chain_node *vector_ring_chain;\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tstruct hns3_enet_tqp_vector *tqp_vector;\n\tint i;\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\ttqp_vector = &priv->tqp_vector[i];\n\n\t\tif (!tqp_vector->rx_group.ring && !tqp_vector->tx_group.ring)\n\t\t\tcontinue;\n\n\t\t \n\t\tvector_ring_chain = hns3_get_vector_ring_chain(tqp_vector);\n\t\tif (!vector_ring_chain)\n\t\t\tdev_warn(priv->dev, \"failed to get ring chain\\n\");\n\n\t\th->ae_algo->ops->unmap_ring_from_vector(h,\n\t\t\ttqp_vector->vector_irq, vector_ring_chain);\n\n\t\thns3_free_vector_ring_chain(tqp_vector, vector_ring_chain);\n\n\t\thns3_clear_ring_group(&tqp_vector->rx_group);\n\t\thns3_clear_ring_group(&tqp_vector->tx_group);\n\t\tnetif_napi_del(&priv->tqp_vector[i].napi);\n\t}\n}\n\nstatic void hns3_nic_dealloc_vector_data(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tstruct pci_dev *pdev = h->pdev;\n\tint i, ret;\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\tstruct hns3_enet_tqp_vector *tqp_vector;\n\n\t\ttqp_vector = &priv->tqp_vector[i];\n\t\tret = h->ae_algo->ops->put_vector(h, tqp_vector->vector_irq);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tdevm_kfree(&pdev->dev, priv->tqp_vector);\n}\n\nstatic void hns3_ring_get_cfg(struct hnae3_queue *q, struct hns3_nic_priv *priv,\n\t\t\t      unsigned int ring_type)\n{\n\tint queue_num = priv->ae_handle->kinfo.num_tqps;\n\tstruct hns3_enet_ring *ring;\n\tint desc_num;\n\n\tif (ring_type == HNAE3_RING_TYPE_TX) {\n\t\tring = &priv->ring[q->tqp_index];\n\t\tdesc_num = priv->ae_handle->kinfo.num_tx_desc;\n\t\tring->queue_index = q->tqp_index;\n\t\tring->tx_copybreak = priv->tx_copybreak;\n\t\tring->last_to_use = 0;\n\t} else {\n\t\tring = &priv->ring[q->tqp_index + queue_num];\n\t\tdesc_num = priv->ae_handle->kinfo.num_rx_desc;\n\t\tring->queue_index = q->tqp_index;\n\t\tring->rx_copybreak = priv->rx_copybreak;\n\t}\n\n\thnae3_set_bit(ring->flag, HNAE3_RING_TYPE_B, ring_type);\n\n\tring->tqp = q;\n\tring->desc = NULL;\n\tring->desc_cb = NULL;\n\tring->dev = priv->dev;\n\tring->desc_dma_addr = 0;\n\tring->buf_size = q->buf_size;\n\tring->desc_num = desc_num;\n\tring->next_to_use = 0;\n\tring->next_to_clean = 0;\n}\n\nstatic void hns3_queue_to_ring(struct hnae3_queue *tqp,\n\t\t\t       struct hns3_nic_priv *priv)\n{\n\thns3_ring_get_cfg(tqp, priv, HNAE3_RING_TYPE_TX);\n\thns3_ring_get_cfg(tqp, priv, HNAE3_RING_TYPE_RX);\n}\n\nstatic int hns3_get_ring_config(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tstruct pci_dev *pdev = h->pdev;\n\tint i;\n\n\tpriv->ring = devm_kzalloc(&pdev->dev,\n\t\t\t\t  array3_size(h->kinfo.num_tqps,\n\t\t\t\t\t      sizeof(*priv->ring), 2),\n\t\t\t\t  GFP_KERNEL);\n\tif (!priv->ring)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++)\n\t\thns3_queue_to_ring(h->kinfo.tqp[i], priv);\n\n\treturn 0;\n}\n\nstatic void hns3_put_ring_config(struct hns3_nic_priv *priv)\n{\n\tif (!priv->ring)\n\t\treturn;\n\n\tdevm_kfree(priv->dev, priv->ring);\n\tpriv->ring = NULL;\n}\n\nstatic void hns3_alloc_page_pool(struct hns3_enet_ring *ring)\n{\n\tstruct page_pool_params pp_params = {\n\t\t.flags = PP_FLAG_DMA_MAP | PP_FLAG_PAGE_FRAG |\n\t\t\t\tPP_FLAG_DMA_SYNC_DEV,\n\t\t.order = hns3_page_order(ring),\n\t\t.pool_size = ring->desc_num * hns3_buf_size(ring) /\n\t\t\t\t(PAGE_SIZE << hns3_page_order(ring)),\n\t\t.nid = dev_to_node(ring_to_dev(ring)),\n\t\t.dev = ring_to_dev(ring),\n\t\t.dma_dir = DMA_FROM_DEVICE,\n\t\t.offset = 0,\n\t\t.max_len = PAGE_SIZE << hns3_page_order(ring),\n\t};\n\n\tring->page_pool = page_pool_create(&pp_params);\n\tif (IS_ERR(ring->page_pool)) {\n\t\tdev_warn(ring_to_dev(ring), \"page pool creation failed: %ld\\n\",\n\t\t\t PTR_ERR(ring->page_pool));\n\t\tring->page_pool = NULL;\n\t}\n}\n\nstatic int hns3_alloc_ring_memory(struct hns3_enet_ring *ring)\n{\n\tint ret;\n\n\tif (ring->desc_num <= 0 || ring->buf_size <= 0)\n\t\treturn -EINVAL;\n\n\tring->desc_cb = devm_kcalloc(ring_to_dev(ring), ring->desc_num,\n\t\t\t\t     sizeof(ring->desc_cb[0]), GFP_KERNEL);\n\tif (!ring->desc_cb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = hns3_alloc_desc(ring);\n\tif (ret)\n\t\tgoto out_with_desc_cb;\n\n\tif (!HNAE3_IS_TX_RING(ring)) {\n\t\tif (page_pool_enabled)\n\t\t\thns3_alloc_page_pool(ring);\n\n\t\tret = hns3_alloc_ring_buffers(ring);\n\t\tif (ret)\n\t\t\tgoto out_with_desc;\n\t} else {\n\t\thns3_init_tx_spare_buffer(ring);\n\t}\n\n\treturn 0;\n\nout_with_desc:\n\thns3_free_desc(ring);\nout_with_desc_cb:\n\tdevm_kfree(ring_to_dev(ring), ring->desc_cb);\n\tring->desc_cb = NULL;\nout:\n\treturn ret;\n}\n\nvoid hns3_fini_ring(struct hns3_enet_ring *ring)\n{\n\thns3_free_desc(ring);\n\tdevm_kfree(ring_to_dev(ring), ring->desc_cb);\n\tring->desc_cb = NULL;\n\tring->next_to_clean = 0;\n\tring->next_to_use = 0;\n\tring->last_to_use = 0;\n\tring->pending_buf = 0;\n\tif (!HNAE3_IS_TX_RING(ring) && ring->skb) {\n\t\tdev_kfree_skb_any(ring->skb);\n\t\tring->skb = NULL;\n\t} else if (HNAE3_IS_TX_RING(ring) && ring->tx_spare) {\n\t\tstruct hns3_tx_spare *tx_spare = ring->tx_spare;\n\n\t\tdma_unmap_page(ring_to_dev(ring), tx_spare->dma, tx_spare->len,\n\t\t\t       DMA_TO_DEVICE);\n\t\tfree_pages((unsigned long)tx_spare->buf,\n\t\t\t   get_order(tx_spare->len));\n\t\tdevm_kfree(ring_to_dev(ring), tx_spare);\n\t\tring->tx_spare = NULL;\n\t}\n\n\tif (!HNAE3_IS_TX_RING(ring) && ring->page_pool) {\n\t\tpage_pool_destroy(ring->page_pool);\n\t\tring->page_pool = NULL;\n\t}\n}\n\nstatic int hns3_buf_size2type(u32 buf_size)\n{\n\tint bd_size_type;\n\n\tswitch (buf_size) {\n\tcase 512:\n\t\tbd_size_type = HNS3_BD_SIZE_512_TYPE;\n\t\tbreak;\n\tcase 1024:\n\t\tbd_size_type = HNS3_BD_SIZE_1024_TYPE;\n\t\tbreak;\n\tcase 2048:\n\t\tbd_size_type = HNS3_BD_SIZE_2048_TYPE;\n\t\tbreak;\n\tcase 4096:\n\t\tbd_size_type = HNS3_BD_SIZE_4096_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tbd_size_type = HNS3_BD_SIZE_2048_TYPE;\n\t}\n\n\treturn bd_size_type;\n}\n\nstatic void hns3_init_ring_hw(struct hns3_enet_ring *ring)\n{\n\tdma_addr_t dma = ring->desc_dma_addr;\n\tstruct hnae3_queue *q = ring->tqp;\n\n\tif (!HNAE3_IS_TX_RING(ring)) {\n\t\thns3_write_dev(q, HNS3_RING_RX_RING_BASEADDR_L_REG, (u32)dma);\n\t\thns3_write_dev(q, HNS3_RING_RX_RING_BASEADDR_H_REG,\n\t\t\t       (u32)((dma >> 31) >> 1));\n\n\t\thns3_write_dev(q, HNS3_RING_RX_RING_BD_LEN_REG,\n\t\t\t       hns3_buf_size2type(ring->buf_size));\n\t\thns3_write_dev(q, HNS3_RING_RX_RING_BD_NUM_REG,\n\t\t\t       ring->desc_num / 8 - 1);\n\t} else {\n\t\thns3_write_dev(q, HNS3_RING_TX_RING_BASEADDR_L_REG,\n\t\t\t       (u32)dma);\n\t\thns3_write_dev(q, HNS3_RING_TX_RING_BASEADDR_H_REG,\n\t\t\t       (u32)((dma >> 31) >> 1));\n\n\t\thns3_write_dev(q, HNS3_RING_TX_RING_BD_NUM_REG,\n\t\t\t       ring->desc_num / 8 - 1);\n\t}\n}\n\nstatic void hns3_init_tx_ring_tc(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_knic_private_info *kinfo = &priv->ae_handle->kinfo;\n\tstruct hnae3_tc_info *tc_info = &kinfo->tc_info;\n\tint i;\n\n\tfor (i = 0; i < tc_info->num_tc; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < tc_info->tqp_count[i]; j++) {\n\t\t\tstruct hnae3_queue *q;\n\n\t\t\tq = priv->ring[tc_info->tqp_offset[i] + j].tqp;\n\t\t\thns3_write_dev(q, HNS3_RING_TX_RING_TC_REG, i);\n\t\t}\n\t}\n}\n\nint hns3_init_all_ring(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint ring_num = h->kinfo.num_tqps * 2;\n\tint i, j;\n\tint ret;\n\n\tfor (i = 0; i < ring_num; i++) {\n\t\tret = hns3_alloc_ring_memory(&priv->ring[i]);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Alloc ring memory fail! ret=%d\\n\", ret);\n\t\t\tgoto out_when_alloc_ring_memory;\n\t\t}\n\n\t\tu64_stats_init(&priv->ring[i].syncp);\n\t}\n\n\treturn 0;\n\nout_when_alloc_ring_memory:\n\tfor (j = i - 1; j >= 0; j--)\n\t\thns3_fini_ring(&priv->ring[j]);\n\n\treturn -ENOMEM;\n}\n\nstatic void hns3_uninit_all_ring(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint i;\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\thns3_fini_ring(&priv->ring[i]);\n\t\thns3_fini_ring(&priv->ring[i + h->kinfo.num_tqps]);\n\t}\n}\n\n \nstatic int hns3_init_mac_addr(struct net_device *netdev)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tu8 mac_addr_temp[ETH_ALEN] = {0};\n\tint ret = 0;\n\n\tif (h->ae_algo->ops->get_mac_addr)\n\t\th->ae_algo->ops->get_mac_addr(h, mac_addr_temp);\n\n\t \n\tif (!is_valid_ether_addr(mac_addr_temp)) {\n\t\teth_hw_addr_random(netdev);\n\t\thnae3_format_mac_addr(format_mac_addr, netdev->dev_addr);\n\t\tdev_warn(priv->dev, \"using random MAC address %s\\n\",\n\t\t\t format_mac_addr);\n\t} else if (!ether_addr_equal(netdev->dev_addr, mac_addr_temp)) {\n\t\teth_hw_addr_set(netdev, mac_addr_temp);\n\t\tether_addr_copy(netdev->perm_addr, mac_addr_temp);\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (h->ae_algo->ops->set_mac_addr)\n\t\tret = h->ae_algo->ops->set_mac_addr(h, netdev->dev_addr, true);\n\n\treturn ret;\n}\n\nstatic int hns3_init_phy(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tint ret = 0;\n\n\tif (h->ae_algo->ops->mac_connect_phy)\n\t\tret = h->ae_algo->ops->mac_connect_phy(h);\n\n\treturn ret;\n}\n\nstatic void hns3_uninit_phy(struct net_device *netdev)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\n\tif (h->ae_algo->ops->mac_disconnect_phy)\n\t\th->ae_algo->ops->mac_disconnect_phy(h);\n}\n\nstatic int hns3_client_start(struct hnae3_handle *handle)\n{\n\tif (!handle->ae_algo->ops->client_start)\n\t\treturn 0;\n\n\treturn handle->ae_algo->ops->client_start(handle);\n}\n\nstatic void hns3_client_stop(struct hnae3_handle *handle)\n{\n\tif (!handle->ae_algo->ops->client_stop)\n\t\treturn;\n\n\thandle->ae_algo->ops->client_stop(handle);\n}\n\nstatic void hns3_info_show(struct hns3_nic_priv *priv)\n{\n\tstruct hnae3_knic_private_info *kinfo = &priv->ae_handle->kinfo;\n\tchar format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];\n\n\thnae3_format_mac_addr(format_mac_addr, priv->netdev->dev_addr);\n\tdev_info(priv->dev, \"MAC address: %s\\n\", format_mac_addr);\n\tdev_info(priv->dev, \"Task queue pairs numbers: %u\\n\", kinfo->num_tqps);\n\tdev_info(priv->dev, \"RSS size: %u\\n\", kinfo->rss_size);\n\tdev_info(priv->dev, \"Allocated RSS size: %u\\n\", kinfo->req_rss_size);\n\tdev_info(priv->dev, \"RX buffer length: %u\\n\", kinfo->rx_buf_len);\n\tdev_info(priv->dev, \"Desc num per TX queue: %u\\n\", kinfo->num_tx_desc);\n\tdev_info(priv->dev, \"Desc num per RX queue: %u\\n\", kinfo->num_rx_desc);\n\tdev_info(priv->dev, \"Total number of enabled TCs: %u\\n\",\n\t\t kinfo->tc_info.num_tc);\n\tdev_info(priv->dev, \"Max mtu size: %u\\n\", priv->netdev->max_mtu);\n}\n\nstatic void hns3_set_cq_period_mode(struct hns3_nic_priv *priv,\n\t\t\t\t    enum dim_cq_period_mode mode, bool is_tx)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(priv->ae_handle->pdev);\n\tstruct hnae3_handle *handle = priv->ae_handle;\n\tint i;\n\n\tif (is_tx) {\n\t\tpriv->tx_cqe_mode = mode;\n\n\t\tfor (i = 0; i < priv->vector_num; i++)\n\t\t\tpriv->tqp_vector[i].tx_group.dim.mode = mode;\n\t} else {\n\t\tpriv->rx_cqe_mode = mode;\n\n\t\tfor (i = 0; i < priv->vector_num; i++)\n\t\t\tpriv->tqp_vector[i].rx_group.dim.mode = mode;\n\t}\n\n\tif (hnae3_ae_dev_cq_supported(ae_dev)) {\n\t\tu32 new_mode;\n\t\tu64 reg;\n\n\t\tnew_mode = (mode == DIM_CQ_PERIOD_MODE_START_FROM_CQE) ?\n\t\t\tHNS3_CQ_MODE_CQE : HNS3_CQ_MODE_EQE;\n\t\treg = is_tx ? HNS3_GL1_CQ_MODE_REG : HNS3_GL0_CQ_MODE_REG;\n\n\t\twritel(new_mode, handle->kinfo.io_base + reg);\n\t}\n}\n\nvoid hns3_cq_period_mode_init(struct hns3_nic_priv *priv,\n\t\t\t      enum dim_cq_period_mode tx_mode,\n\t\t\t      enum dim_cq_period_mode rx_mode)\n{\n\thns3_set_cq_period_mode(priv, tx_mode, true);\n\thns3_set_cq_period_mode(priv, rx_mode, false);\n}\n\nstatic void hns3_state_init(struct hnae3_handle *handle)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tstruct net_device *netdev = handle->kinfo.netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\n\tset_bit(HNS3_NIC_STATE_INITED, &priv->state);\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_TX_PUSH_B, ae_dev->caps))\n\t\tset_bit(HNS3_NIC_STATE_TX_PUSH_ENABLE, &priv->state);\n\n\tif (ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3)\n\t\tset_bit(HNAE3_PFLAG_LIMIT_PROMISC, &handle->supported_pflags);\n\n\tif (test_bit(HNAE3_DEV_SUPPORT_HW_TX_CSUM_B, ae_dev->caps))\n\t\tset_bit(HNS3_NIC_STATE_HW_TX_CSUM_ENABLE, &priv->state);\n\n\tif (hnae3_ae_dev_rxd_adv_layout_supported(ae_dev))\n\t\tset_bit(HNS3_NIC_STATE_RXD_ADV_LAYOUT_ENABLE, &priv->state);\n}\n\nstatic void hns3_state_uninit(struct hnae3_handle *handle)\n{\n\tstruct hns3_nic_priv *priv  = handle->priv;\n\n\tclear_bit(HNS3_NIC_STATE_INITED, &priv->state);\n}\n\nstatic int hns3_client_init(struct hnae3_handle *handle)\n{\n\tstruct pci_dev *pdev = handle->pdev;\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);\n\tu16 alloc_tqps, max_rss_size;\n\tstruct hns3_nic_priv *priv;\n\tstruct net_device *netdev;\n\tint ret;\n\n\thandle->ae_algo->ops->get_tqps_and_rss_info(handle, &alloc_tqps,\n\t\t\t\t\t\t    &max_rss_size);\n\tnetdev = alloc_etherdev_mq(sizeof(struct hns3_nic_priv), alloc_tqps);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(netdev);\n\tpriv->dev = &pdev->dev;\n\tpriv->netdev = netdev;\n\tpriv->ae_handle = handle;\n\tpriv->tx_timeout_count = 0;\n\tpriv->max_non_tso_bd_num = ae_dev->dev_specs.max_non_tso_bd_num;\n\tset_bit(HNS3_NIC_STATE_DOWN, &priv->state);\n\n\thandle->msg_enable = netif_msg_init(debug, DEFAULT_MSG_LEVEL);\n\n\thandle->kinfo.netdev = netdev;\n\thandle->priv = (void *)priv;\n\n\thns3_init_mac_addr(netdev);\n\n\thns3_set_default_feature(netdev);\n\n\tnetdev->watchdog_timeo = HNS3_TX_TIMEOUT;\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\tnetdev->netdev_ops = &hns3_nic_netdev_ops;\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\thns3_ethtool_set_ops(netdev);\n\n\t \n\tnetif_carrier_off(netdev);\n\n\tret = hns3_get_ring_config(priv);\n\tif (ret) {\n\t\tret = -ENOMEM;\n\t\tgoto out_get_ring_cfg;\n\t}\n\n\thns3_nic_init_coal_cfg(priv);\n\n\tret = hns3_nic_alloc_vector_data(priv);\n\tif (ret) {\n\t\tret = -ENOMEM;\n\t\tgoto out_alloc_vector_data;\n\t}\n\n\tret = hns3_nic_init_vector_data(priv);\n\tif (ret) {\n\t\tret = -ENOMEM;\n\t\tgoto out_init_vector_data;\n\t}\n\n\tret = hns3_init_all_ring(priv);\n\tif (ret) {\n\t\tret = -ENOMEM;\n\t\tgoto out_init_ring;\n\t}\n\n\thns3_cq_period_mode_init(priv, DIM_CQ_PERIOD_MODE_START_FROM_EQE,\n\t\t\t\t DIM_CQ_PERIOD_MODE_START_FROM_EQE);\n\n\tret = hns3_init_phy(netdev);\n\tif (ret)\n\t\tgoto out_init_phy;\n\n\t \n\tret = hns3_set_rx_cpu_rmap(netdev);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"set rx cpu rmap fail, ret=%d\\n\", ret);\n\n\tret = hns3_nic_init_irq(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"init irq failed! ret=%d\\n\", ret);\n\t\thns3_free_rx_cpu_rmap(netdev);\n\t\tgoto out_init_irq_fail;\n\t}\n\n\tret = hns3_client_start(handle);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"hns3_client_start fail! ret=%d\\n\", ret);\n\t\tgoto out_client_start;\n\t}\n\n\thns3_dcbnl_setup(handle);\n\n\tret = hns3_dbg_init(handle);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to init debugfs, ret = %d\\n\",\n\t\t\tret);\n\t\tgoto out_client_start;\n\t}\n\n\tnetdev->max_mtu = HNS3_MAX_MTU(ae_dev->dev_specs.max_frm_size);\n\n\thns3_state_init(handle);\n\n\tret = register_netdev(netdev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"probe register netdev fail!\\n\");\n\t\tgoto out_reg_netdev_fail;\n\t}\n\n\tif (netif_msg_drv(handle))\n\t\thns3_info_show(priv);\n\n\treturn ret;\n\nout_reg_netdev_fail:\n\thns3_state_uninit(handle);\n\thns3_dbg_uninit(handle);\n\thns3_client_stop(handle);\nout_client_start:\n\thns3_free_rx_cpu_rmap(netdev);\n\thns3_nic_uninit_irq(priv);\nout_init_irq_fail:\n\thns3_uninit_phy(netdev);\nout_init_phy:\n\thns3_uninit_all_ring(priv);\nout_init_ring:\n\thns3_nic_uninit_vector_data(priv);\nout_init_vector_data:\n\thns3_nic_dealloc_vector_data(priv);\nout_alloc_vector_data:\n\tpriv->ring = NULL;\nout_get_ring_cfg:\n\tpriv->ae_handle = NULL;\n\tfree_netdev(netdev);\n\treturn ret;\n}\n\nstatic void hns3_client_uninit(struct hnae3_handle *handle, bool reset)\n{\n\tstruct net_device *netdev = handle->kinfo.netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\n\tif (netdev->reg_state != NETREG_UNINITIALIZED)\n\t\tunregister_netdev(netdev);\n\n\thns3_client_stop(handle);\n\n\thns3_uninit_phy(netdev);\n\n\tif (!test_and_clear_bit(HNS3_NIC_STATE_INITED, &priv->state)) {\n\t\tnetdev_warn(netdev, \"already uninitialized\\n\");\n\t\tgoto out_netdev_free;\n\t}\n\n\thns3_free_rx_cpu_rmap(netdev);\n\n\thns3_nic_uninit_irq(priv);\n\n\thns3_clear_all_ring(handle, true);\n\n\thns3_nic_uninit_vector_data(priv);\n\n\thns3_nic_dealloc_vector_data(priv);\n\n\thns3_uninit_all_ring(priv);\n\n\thns3_put_ring_config(priv);\n\nout_netdev_free:\n\thns3_dbg_uninit(handle);\n\tfree_netdev(netdev);\n}\n\nstatic void hns3_link_status_change(struct hnae3_handle *handle, bool linkup)\n{\n\tstruct net_device *netdev = handle->kinfo.netdev;\n\n\tif (!netdev)\n\t\treturn;\n\n\tif (linkup) {\n\t\tnetif_tx_wake_all_queues(netdev);\n\t\tnetif_carrier_on(netdev);\n\t\tif (netif_msg_link(handle))\n\t\t\tnetdev_info(netdev, \"link up\\n\");\n\t} else {\n\t\tnetif_carrier_off(netdev);\n\t\tnetif_tx_stop_all_queues(netdev);\n\t\tif (netif_msg_link(handle))\n\t\t\tnetdev_info(netdev, \"link down\\n\");\n\t}\n}\n\nstatic void hns3_clear_tx_ring(struct hns3_enet_ring *ring)\n{\n\twhile (ring->next_to_clean != ring->next_to_use) {\n\t\tring->desc[ring->next_to_clean].tx.bdtp_fe_sc_vld_ra_ri = 0;\n\t\thns3_free_buffer_detach(ring, ring->next_to_clean, 0);\n\t\tring_ptr_move_fw(ring, next_to_clean);\n\t}\n\n\tring->pending_buf = 0;\n}\n\nstatic int hns3_clear_rx_ring(struct hns3_enet_ring *ring)\n{\n\tstruct hns3_desc_cb res_cbs;\n\tint ret;\n\n\twhile (ring->next_to_use != ring->next_to_clean) {\n\t\t \n\t\tif (!ring->desc_cb[ring->next_to_use].reuse_flag) {\n\t\t\tret = hns3_alloc_and_map_buffer(ring, &res_cbs);\n\t\t\tif (ret) {\n\t\t\t\thns3_ring_stats_update(ring, sw_err_cnt);\n\t\t\t\t \n\t\t\t\tnetdev_warn(ring_to_netdev(ring),\n\t\t\t\t\t    \"reserve buffer map failed, ret = %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\thns3_replace_buffer(ring, ring->next_to_use, &res_cbs);\n\t\t}\n\t\tring_ptr_move_fw(ring, next_to_use);\n\t}\n\n\t \n\tif (ring->skb) {\n\t\tdev_kfree_skb_any(ring->skb);\n\t\tring->skb = NULL;\n\t\tring->pending_buf = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void hns3_force_clear_rx_ring(struct hns3_enet_ring *ring)\n{\n\twhile (ring->next_to_use != ring->next_to_clean) {\n\t\t \n\t\tif (!ring->desc_cb[ring->next_to_use].reuse_flag) {\n\t\t\thns3_unmap_buffer(ring,\n\t\t\t\t\t  &ring->desc_cb[ring->next_to_use]);\n\t\t\tring->desc_cb[ring->next_to_use].dma = 0;\n\t\t}\n\n\t\tring_ptr_move_fw(ring, next_to_use);\n\t}\n}\n\nstatic void hns3_clear_all_ring(struct hnae3_handle *h, bool force)\n{\n\tstruct net_device *ndev = h->kinfo.netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tu32 i;\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\tstruct hns3_enet_ring *ring;\n\n\t\tring = &priv->ring[i];\n\t\thns3_clear_tx_ring(ring);\n\n\t\tring = &priv->ring[i + h->kinfo.num_tqps];\n\t\t \n\t\tif (force)\n\t\t\thns3_force_clear_rx_ring(ring);\n\t\telse\n\t\t\thns3_clear_rx_ring(ring);\n\t}\n}\n\nint hns3_nic_reset_all_ring(struct hnae3_handle *h)\n{\n\tstruct net_device *ndev = h->kinfo.netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hns3_enet_ring *rx_ring;\n\tint i, j;\n\tint ret;\n\n\tret = h->ae_algo->ops->reset_queue(h);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\thns3_init_ring_hw(&priv->ring[i]);\n\n\t\t \n\t\thns3_clear_tx_ring(&priv->ring[i]);\n\t\tpriv->ring[i].next_to_clean = 0;\n\t\tpriv->ring[i].next_to_use = 0;\n\t\tpriv->ring[i].last_to_use = 0;\n\n\t\trx_ring = &priv->ring[i + h->kinfo.num_tqps];\n\t\thns3_init_ring_hw(rx_ring);\n\t\tret = hns3_clear_rx_ring(rx_ring);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (j = 0; j < rx_ring->desc_num; j++)\n\t\t\thns3_reuse_buffer(rx_ring, j);\n\n\t\trx_ring->next_to_clean = 0;\n\t\trx_ring->next_to_use = 0;\n\t}\n\n\thns3_init_tx_ring_tc(priv);\n\n\treturn 0;\n}\n\nstatic int hns3_reset_notify_down_enet(struct hnae3_handle *handle)\n{\n\tstruct hnae3_knic_private_info *kinfo = &handle->kinfo;\n\tstruct net_device *ndev = kinfo->netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\n\tif (test_and_set_bit(HNS3_NIC_STATE_RESETTING, &priv->state))\n\t\treturn 0;\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\treturn hns3_nic_net_stop(ndev);\n}\n\nstatic int hns3_reset_notify_up_enet(struct hnae3_handle *handle)\n{\n\tstruct hnae3_knic_private_info *kinfo = &handle->kinfo;\n\tstruct hns3_nic_priv *priv = netdev_priv(kinfo->netdev);\n\tint ret = 0;\n\n\tif (!test_bit(HNS3_NIC_STATE_INITED, &priv->state)) {\n\t\tnetdev_err(kinfo->netdev, \"device is not initialized yet\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tclear_bit(HNS3_NIC_STATE_RESETTING, &priv->state);\n\n\tif (netif_running(kinfo->netdev)) {\n\t\tret = hns3_nic_net_open(kinfo->netdev);\n\t\tif (ret) {\n\t\t\tset_bit(HNS3_NIC_STATE_RESETTING, &priv->state);\n\t\t\tnetdev_err(kinfo->netdev,\n\t\t\t\t   \"net up fail, ret=%d!\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int hns3_reset_notify_init_enet(struct hnae3_handle *handle)\n{\n\tstruct net_device *netdev = handle->kinfo.netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\tint ret;\n\n\t \n\tnetif_carrier_off(netdev);\n\n\tret = hns3_get_ring_config(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_nic_alloc_vector_data(priv);\n\tif (ret)\n\t\tgoto err_put_ring;\n\n\tret = hns3_nic_init_vector_data(priv);\n\tif (ret)\n\t\tgoto err_dealloc_vector;\n\n\tret = hns3_init_all_ring(priv);\n\tif (ret)\n\t\tgoto err_uninit_vector;\n\n\thns3_cq_period_mode_init(priv, priv->tx_cqe_mode, priv->rx_cqe_mode);\n\n\t \n\tret = hns3_set_rx_cpu_rmap(netdev);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"set rx cpu rmap fail, ret=%d\\n\", ret);\n\n\tret = hns3_nic_init_irq(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"init irq failed! ret=%d\\n\", ret);\n\t\thns3_free_rx_cpu_rmap(netdev);\n\t\tgoto err_init_irq_fail;\n\t}\n\n\tif (!hns3_is_phys_func(handle->pdev))\n\t\thns3_init_mac_addr(netdev);\n\n\tret = hns3_client_start(handle);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"hns3_client_start fail! ret=%d\\n\", ret);\n\t\tgoto err_client_start_fail;\n\t}\n\n\tset_bit(HNS3_NIC_STATE_INITED, &priv->state);\n\n\treturn ret;\n\nerr_client_start_fail:\n\thns3_free_rx_cpu_rmap(netdev);\n\thns3_nic_uninit_irq(priv);\nerr_init_irq_fail:\n\thns3_uninit_all_ring(priv);\nerr_uninit_vector:\n\thns3_nic_uninit_vector_data(priv);\nerr_dealloc_vector:\n\thns3_nic_dealloc_vector_data(priv);\nerr_put_ring:\n\thns3_put_ring_config(priv);\n\n\treturn ret;\n}\n\nstatic int hns3_reset_notify_uninit_enet(struct hnae3_handle *handle)\n{\n\tstruct net_device *netdev = handle->kinfo.netdev;\n\tstruct hns3_nic_priv *priv = netdev_priv(netdev);\n\n\tif (!test_and_clear_bit(HNS3_NIC_STATE_INITED, &priv->state)) {\n\t\tnetdev_warn(netdev, \"already uninitialized\\n\");\n\t\treturn 0;\n\t}\n\n\thns3_free_rx_cpu_rmap(netdev);\n\thns3_nic_uninit_irq(priv);\n\thns3_clear_all_ring(handle, true);\n\thns3_reset_tx_queue(priv->ae_handle);\n\n\thns3_nic_uninit_vector_data(priv);\n\n\thns3_nic_dealloc_vector_data(priv);\n\n\thns3_uninit_all_ring(priv);\n\n\thns3_put_ring_config(priv);\n\n\treturn 0;\n}\n\nint hns3_reset_notify(struct hnae3_handle *handle,\n\t\t      enum hnae3_reset_notify_type type)\n{\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase HNAE3_UP_CLIENT:\n\t\tret = hns3_reset_notify_up_enet(handle);\n\t\tbreak;\n\tcase HNAE3_DOWN_CLIENT:\n\t\tret = hns3_reset_notify_down_enet(handle);\n\t\tbreak;\n\tcase HNAE3_INIT_CLIENT:\n\t\tret = hns3_reset_notify_init_enet(handle);\n\t\tbreak;\n\tcase HNAE3_UNINIT_CLIENT:\n\t\tret = hns3_reset_notify_uninit_enet(handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int hns3_change_channels(struct hnae3_handle *handle, u32 new_tqp_num,\n\t\t\t\tbool rxfh_configured)\n{\n\tint ret;\n\n\tret = handle->ae_algo->ops->set_channels(handle, new_tqp_num,\n\t\t\t\t\t\t rxfh_configured);\n\tif (ret) {\n\t\tdev_err(&handle->pdev->dev,\n\t\t\t\"Change tqp num(%u) fail.\\n\", new_tqp_num);\n\t\treturn ret;\n\t}\n\n\tret = hns3_reset_notify(handle, HNAE3_INIT_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret =  hns3_reset_notify(handle, HNAE3_UP_CLIENT);\n\tif (ret)\n\t\thns3_reset_notify(handle, HNAE3_UNINIT_CLIENT);\n\n\treturn ret;\n}\n\nint hns3_set_channels(struct net_device *netdev,\n\t\t      struct ethtool_channels *ch)\n{\n\tstruct hnae3_handle *h = hns3_get_handle(netdev);\n\tstruct hnae3_knic_private_info *kinfo = &h->kinfo;\n\tbool rxfh_configured = netif_is_rxfh_configured(netdev);\n\tu32 new_tqp_num = ch->combined_count;\n\tu16 org_tqp_num;\n\tint ret;\n\n\tif (hns3_nic_resetting(netdev))\n\t\treturn -EBUSY;\n\n\tif (ch->rx_count || ch->tx_count)\n\t\treturn -EINVAL;\n\n\tif (kinfo->tc_info.mqprio_active) {\n\t\tdev_err(&netdev->dev,\n\t\t\t\"it's not allowed to set channels via ethtool when MQPRIO mode is on\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_tqp_num > hns3_get_max_available_channels(h) ||\n\t    new_tqp_num < 1) {\n\t\tdev_err(&netdev->dev,\n\t\t\t\"Change tqps fail, the tqp range is from 1 to %u\",\n\t\t\thns3_get_max_available_channels(h));\n\t\treturn -EINVAL;\n\t}\n\n\tif (kinfo->rss_size == new_tqp_num)\n\t\treturn 0;\n\n\tnetif_dbg(h, drv, netdev,\n\t\t  \"set channels: tqp_num=%u, rxfh=%d\\n\",\n\t\t  new_tqp_num, rxfh_configured);\n\n\tret = hns3_reset_notify(h, HNAE3_DOWN_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_reset_notify(h, HNAE3_UNINIT_CLIENT);\n\tif (ret)\n\t\treturn ret;\n\n\torg_tqp_num = h->kinfo.num_tqps;\n\tret = hns3_change_channels(h, new_tqp_num, rxfh_configured);\n\tif (ret) {\n\t\tint ret1;\n\n\t\tnetdev_warn(netdev,\n\t\t\t    \"Change channels fail, revert to old value\\n\");\n\t\tret1 = hns3_change_channels(h, org_tqp_num, rxfh_configured);\n\t\tif (ret1) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"revert to old channel fail\\n\");\n\t\t\treturn ret1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid hns3_external_lb_prepare(struct net_device *ndev, bool if_running)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint i;\n\n\tif (!if_running)\n\t\treturn;\n\n\tif (test_and_set_bit(HNS3_NIC_STATE_DOWN, &priv->state))\n\t\treturn;\n\n\tnetif_carrier_off(ndev);\n\tnetif_tx_disable(ndev);\n\n\tfor (i = 0; i < priv->vector_num; i++)\n\t\thns3_vector_disable(&priv->tqp_vector[i]);\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++)\n\t\thns3_tqp_disable(h->kinfo.tqp[i]);\n\n\t \n\tif (!hns3_nic_resetting(ndev))\n\t\thns3_nic_reset_all_ring(priv->ae_handle);\n\n\thns3_reset_tx_queue(priv->ae_handle);\n}\n\nvoid hns3_external_lb_restore(struct net_device *ndev, bool if_running)\n{\n\tstruct hns3_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae3_handle *h = priv->ae_handle;\n\tint i;\n\n\tif (!if_running)\n\t\treturn;\n\n\tif (hns3_nic_resetting(ndev))\n\t\treturn;\n\n\tif (!test_bit(HNS3_NIC_STATE_DOWN, &priv->state))\n\t\treturn;\n\n\tif (hns3_nic_reset_all_ring(priv->ae_handle))\n\t\treturn;\n\n\tclear_bit(HNS3_NIC_STATE_DOWN, &priv->state);\n\n\tfor (i = 0; i < priv->vector_num; i++)\n\t\thns3_vector_enable(&priv->tqp_vector[i]);\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++)\n\t\thns3_tqp_enable(h->kinfo.tqp[i]);\n\n\tnetif_tx_wake_all_queues(ndev);\n\n\tif (h->ae_algo->ops->get_status(h))\n\t\tnetif_carrier_on(ndev);\n}\n\nstatic const struct hns3_hw_error_info hns3_hw_err[] = {\n\t{ .type = HNAE3_PPU_POISON_ERROR,\n\t  .msg = \"PPU poison\" },\n\t{ .type = HNAE3_CMDQ_ECC_ERROR,\n\t  .msg = \"IMP CMDQ error\" },\n\t{ .type = HNAE3_IMP_RD_POISON_ERROR,\n\t  .msg = \"IMP RD poison\" },\n\t{ .type = HNAE3_ROCEE_AXI_RESP_ERROR,\n\t  .msg = \"ROCEE AXI RESP error\" },\n};\n\nstatic void hns3_process_hw_error(struct hnae3_handle *handle,\n\t\t\t\t  enum hnae3_hw_error_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_hw_err); i++) {\n\t\tif (hns3_hw_err[i].type == type) {\n\t\t\tdev_err(&handle->pdev->dev, \"Detected %s!\\n\",\n\t\t\t\thns3_hw_err[i].msg);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct hnae3_client_ops client_ops = {\n\t.init_instance = hns3_client_init,\n\t.uninit_instance = hns3_client_uninit,\n\t.link_status_change = hns3_link_status_change,\n\t.reset_notify = hns3_reset_notify,\n\t.process_hw_error = hns3_process_hw_error,\n};\n\n \nstatic int __init hns3_init_module(void)\n{\n\tint ret;\n\n\tpr_info(\"%s: %s - version\\n\", hns3_driver_name, hns3_driver_string);\n\tpr_info(\"%s: %s\\n\", hns3_driver_name, hns3_copyright);\n\n\tclient.type = HNAE3_CLIENT_KNIC;\n\tsnprintf(client.name, HNAE3_CLIENT_NAME_LENGTH, \"%s\",\n\t\t hns3_driver_name);\n\n\tclient.ops = &client_ops;\n\n\tINIT_LIST_HEAD(&client.node);\n\n\thns3_dbg_register_debugfs(hns3_driver_name);\n\n\tret = hnae3_register_client(&client);\n\tif (ret)\n\t\tgoto err_reg_client;\n\n\tret = pci_register_driver(&hns3_driver);\n\tif (ret)\n\t\tgoto err_reg_driver;\n\n\treturn ret;\n\nerr_reg_driver:\n\thnae3_unregister_client(&client);\nerr_reg_client:\n\thns3_dbg_unregister_debugfs();\n\treturn ret;\n}\nmodule_init(hns3_init_module);\n\n \nstatic void __exit hns3_exit_module(void)\n{\n\tpci_unregister_driver(&hns3_driver);\n\thnae3_unregister_client(&client);\n\thns3_dbg_unregister_debugfs();\n}\nmodule_exit(hns3_exit_module);\n\nMODULE_DESCRIPTION(\"HNS3: Hisilicon Ethernet Driver\");\nMODULE_AUTHOR(\"Huawei Tech. Co., Ltd.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"pci:hns-nic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}