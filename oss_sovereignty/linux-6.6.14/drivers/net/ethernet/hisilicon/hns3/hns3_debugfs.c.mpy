{
  "module_name": "hns3_debugfs.c",
  "hash_id": "f55514e66f4cc8bc268e1ccaf74ae7c044765bd757e655b4b8abca490a570dd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hns3_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n\n#include \"hnae3.h\"\n#include \"hns3_debugfs.h\"\n#include \"hns3_enet.h\"\n\nstatic struct dentry *hns3_dbgfs_root;\n\nstatic struct hns3_dbg_dentry_info hns3_dbg_dentry[] = {\n\t{\n\t\t.name = \"tm\"\n\t},\n\t{\n\t\t.name = \"tx_bd_info\"\n\t},\n\t{\n\t\t.name = \"rx_bd_info\"\n\t},\n\t{\n\t\t.name = \"mac_list\"\n\t},\n\t{\n\t\t.name = \"reg\"\n\t},\n\t{\n\t\t.name = \"queue\"\n\t},\n\t{\n\t\t.name = \"fd\"\n\t},\n\t \n\t{\n\t\t.name = \"common\"\n\t},\n};\n\nstatic int hns3_dbg_bd_file_init(struct hnae3_handle *handle, u32 cmd);\nstatic int hns3_dbg_common_file_init(struct hnae3_handle *handle, u32 cmd);\n\nstatic struct hns3_dbg_cmd_info hns3_dbg_cmd[] = {\n\t{\n\t\t.name = \"tm_nodes\",\n\t\t.cmd = HNAE3_DBG_CMD_TM_NODES,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tm_priority\",\n\t\t.cmd = HNAE3_DBG_CMD_TM_PRI,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tm_qset\",\n\t\t.cmd = HNAE3_DBG_CMD_TM_QSET,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tm_map\",\n\t\t.cmd = HNAE3_DBG_CMD_TM_MAP,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN_1MB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tm_pg\",\n\t\t.cmd = HNAE3_DBG_CMD_TM_PG,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tm_port\",\n\t\t.cmd = HNAE3_DBG_CMD_TM_PORT,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tc_sch_info\",\n\t\t.cmd = HNAE3_DBG_CMD_TC_SCH_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"qos_pause_cfg\",\n\t\t.cmd = HNAE3_DBG_CMD_QOS_PAUSE_CFG,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"qos_pri_map\",\n\t\t.cmd = HNAE3_DBG_CMD_QOS_PRI_MAP,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"qos_dscp_map\",\n\t\t.cmd = HNAE3_DBG_CMD_QOS_DSCP_MAP,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"qos_buf_cfg\",\n\t\t.cmd = HNAE3_DBG_CMD_QOS_BUF_CFG,\n\t\t.dentry = HNS3_DBG_DENTRY_TM,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"dev_info\",\n\t\t.cmd = HNAE3_DBG_CMD_DEV_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tx_bd_queue\",\n\t\t.cmd = HNAE3_DBG_CMD_TX_BD,\n\t\t.dentry = HNS3_DBG_DENTRY_TX_BD,\n\t\t.buf_len = HNS3_DBG_READ_LEN_5MB,\n\t\t.init = hns3_dbg_bd_file_init,\n\t},\n\t{\n\t\t.name = \"rx_bd_queue\",\n\t\t.cmd = HNAE3_DBG_CMD_RX_BD,\n\t\t.dentry = HNS3_DBG_DENTRY_RX_BD,\n\t\t.buf_len = HNS3_DBG_READ_LEN_4MB,\n\t\t.init = hns3_dbg_bd_file_init,\n\t},\n\t{\n\t\t.name = \"uc\",\n\t\t.cmd = HNAE3_DBG_CMD_MAC_UC,\n\t\t.dentry = HNS3_DBG_DENTRY_MAC,\n\t\t.buf_len = HNS3_DBG_READ_LEN_128KB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"mc\",\n\t\t.cmd = HNAE3_DBG_CMD_MAC_MC,\n\t\t.dentry = HNS3_DBG_DENTRY_MAC,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"mng_tbl\",\n\t\t.cmd = HNAE3_DBG_CMD_MNG_TBL,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"loopback\",\n\t\t.cmd = HNAE3_DBG_CMD_LOOPBACK,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"interrupt_info\",\n\t\t.cmd = HNAE3_DBG_CMD_INTERRUPT_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"reset_info\",\n\t\t.cmd = HNAE3_DBG_CMD_RESET_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"imp_info\",\n\t\t.cmd = HNAE3_DBG_CMD_IMP_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"ncl_config\",\n\t\t.cmd = HNAE3_DBG_CMD_NCL_CONFIG,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN_128KB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"mac_tnl_status\",\n\t\t.cmd = HNAE3_DBG_CMD_MAC_TNL_STATUS,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"bios_common\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_BIOS_COMMON,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"ssu\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_SSU,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"igu_egu\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_IGU_EGU,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"rpu\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_RPU,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"ncsi\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_NCSI,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"rtc\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_RTC,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"ppp\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_PPP,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"rcb\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_RCB,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tqp\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_TQP,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN_128KB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"mac\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_MAC,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"dcb\",\n\t\t.cmd = HNAE3_DBG_CMD_REG_DCB,\n\t\t.dentry = HNS3_DBG_DENTRY_REG,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"queue_map\",\n\t\t.cmd = HNAE3_DBG_CMD_QUEUE_MAP,\n\t\t.dentry = HNS3_DBG_DENTRY_QUEUE,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"rx_queue_info\",\n\t\t.cmd = HNAE3_DBG_CMD_RX_QUEUE_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_QUEUE,\n\t\t.buf_len = HNS3_DBG_READ_LEN_1MB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"tx_queue_info\",\n\t\t.cmd = HNAE3_DBG_CMD_TX_QUEUE_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_QUEUE,\n\t\t.buf_len = HNS3_DBG_READ_LEN_1MB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"fd_tcam\",\n\t\t.cmd = HNAE3_DBG_CMD_FD_TCAM,\n\t\t.dentry = HNS3_DBG_DENTRY_FD,\n\t\t.buf_len = HNS3_DBG_READ_LEN_1MB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"service_task_info\",\n\t\t.cmd = HNAE3_DBG_CMD_SERV_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"vlan_config\",\n\t\t.cmd = HNAE3_DBG_CMD_VLAN_CONFIG,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"ptp_info\",\n\t\t.cmd = HNAE3_DBG_CMD_PTP_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"fd_counter\",\n\t\t.cmd = HNAE3_DBG_CMD_FD_COUNTER,\n\t\t.dentry = HNS3_DBG_DENTRY_FD,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"umv_info\",\n\t\t.cmd = HNAE3_DBG_CMD_UMV_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"page_pool_info\",\n\t\t.cmd = HNAE3_DBG_CMD_PAGE_POOL_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n\t{\n\t\t.name = \"coalesce_info\",\n\t\t.cmd = HNAE3_DBG_CMD_COAL_INFO,\n\t\t.dentry = HNS3_DBG_DENTRY_COMMON,\n\t\t.buf_len = HNS3_DBG_READ_LEN_1MB,\n\t\t.init = hns3_dbg_common_file_init,\n\t},\n};\n\nstatic struct hns3_dbg_cap_info hns3_dbg_cap[] = {\n\t{\n\t\t.name = \"support FD\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_FD_B,\n\t}, {\n\t\t.name = \"support GRO\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_GRO_B,\n\t}, {\n\t\t.name = \"support FEC\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_FEC_B,\n\t}, {\n\t\t.name = \"support UDP GSO\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_UDP_GSO_B,\n\t}, {\n\t\t.name = \"support PTP\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_PTP_B,\n\t}, {\n\t\t.name = \"support INT QL\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_INT_QL_B,\n\t}, {\n\t\t.name = \"support HW TX csum\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_HW_TX_CSUM_B,\n\t}, {\n\t\t.name = \"support UDP tunnel csum\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_UDP_TUNNEL_CSUM_B,\n\t}, {\n\t\t.name = \"support TX push\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_TX_PUSH_B,\n\t}, {\n\t\t.name = \"support imp-controlled PHY\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_PHY_IMP_B,\n\t}, {\n\t\t.name = \"support imp-controlled RAS\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_RAS_IMP_B,\n\t}, {\n\t\t.name = \"support rxd advanced layout\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_RXD_ADV_LAYOUT_B,\n\t}, {\n\t\t.name = \"support port vlan bypass\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_PORT_VLAN_BYPASS_B,\n\t}, {\n\t\t.name = \"support modify vlan filter state\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B,\n\t}, {\n\t\t.name = \"support FEC statistics\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_FEC_STATS_B,\n\t}, {\n\t\t.name = \"support lane num\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_LANE_NUM_B,\n\t}, {\n\t\t.name = \"support wake on lan\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_WOL_B,\n\t}, {\n\t\t.name = \"support tm flush\",\n\t\t.cap_bit = HNAE3_DEV_SUPPORT_TM_FLUSH_B,\n\t}\n};\n\nstatic const struct hns3_dbg_item coal_info_items[] = {\n\t{ \"VEC_ID\", 2 },\n\t{ \"ALGO_STATE\", 2 },\n\t{ \"PROFILE_ID\", 2 },\n\t{ \"CQE_MODE\", 2 },\n\t{ \"TUNE_STATE\", 2 },\n\t{ \"STEPS_LEFT\", 2 },\n\t{ \"STEPS_RIGHT\", 2 },\n\t{ \"TIRED\", 2 },\n\t{ \"SW_GL\", 2 },\n\t{ \"SW_QL\", 2 },\n\t{ \"HW_GL\", 2 },\n\t{ \"HW_QL\", 2 },\n};\n\nstatic const char * const dim_cqe_mode_str[] = { \"EQE\", \"CQE\" };\nstatic const char * const dim_state_str[] = { \"START\", \"IN_PROG\", \"APPLY\" };\nstatic const char * const\ndim_tune_stat_str[] = { \"ON_TOP\", \"TIRED\", \"RIGHT\", \"LEFT\" };\n\nstatic void hns3_dbg_fill_content(char *content, u16 len,\n\t\t\t\t  const struct hns3_dbg_item *items,\n\t\t\t\t  const char **result, u16 size)\n{\n#define HNS3_DBG_LINE_END_LEN\t2\n\tchar *pos = content;\n\tu16 item_len;\n\tu16 i;\n\n\tif (!len) {\n\t\treturn;\n\t} else if (len <= HNS3_DBG_LINE_END_LEN) {\n\t\t*pos++ = '\\0';\n\t\treturn;\n\t}\n\n\tmemset(content, ' ', len);\n\tlen -= HNS3_DBG_LINE_END_LEN;\n\n\tfor (i = 0; i < size; i++) {\n\t\titem_len = strlen(items[i].name) + items[i].interval;\n\t\tif (len < item_len)\n\t\t\tbreak;\n\n\t\tif (result) {\n\t\t\tif (item_len < strlen(result[i]))\n\t\t\t\tbreak;\n\t\t\tmemcpy(pos, result[i], strlen(result[i]));\n\t\t} else {\n\t\t\tmemcpy(pos, items[i].name, strlen(items[i].name));\n\t\t}\n\t\tpos += item_len;\n\t\tlen -= item_len;\n\t}\n\t*pos++ = '\\n';\n\t*pos++ = '\\0';\n}\n\nstatic void hns3_get_coal_info(struct hns3_enet_tqp_vector *tqp_vector,\n\t\t\t       char **result, int i, bool is_tx)\n{\n\tunsigned int gl_offset, ql_offset;\n\tstruct hns3_enet_coalesce *coal;\n\tunsigned int reg_val;\n\tunsigned int j = 0;\n\tstruct dim *dim;\n\tbool ql_enable;\n\n\tif (is_tx) {\n\t\tcoal = &tqp_vector->tx_group.coal;\n\t\tdim = &tqp_vector->tx_group.dim;\n\t\tgl_offset = HNS3_VECTOR_GL1_OFFSET;\n\t\tql_offset = HNS3_VECTOR_TX_QL_OFFSET;\n\t\tql_enable = tqp_vector->tx_group.coal.ql_enable;\n\t} else {\n\t\tcoal = &tqp_vector->rx_group.coal;\n\t\tdim = &tqp_vector->rx_group.dim;\n\t\tgl_offset = HNS3_VECTOR_GL0_OFFSET;\n\t\tql_offset = HNS3_VECTOR_RX_QL_OFFSET;\n\t\tql_enable = tqp_vector->rx_group.coal.ql_enable;\n\t}\n\n\tsprintf(result[j++], \"%d\", i);\n\tsprintf(result[j++], \"%s\", dim->state < ARRAY_SIZE(dim_state_str) ?\n\t\tdim_state_str[dim->state] : \"unknown\");\n\tsprintf(result[j++], \"%u\", dim->profile_ix);\n\tsprintf(result[j++], \"%s\", dim->mode < ARRAY_SIZE(dim_cqe_mode_str) ?\n\t\tdim_cqe_mode_str[dim->mode] : \"unknown\");\n\tsprintf(result[j++], \"%s\",\n\t\tdim->tune_state < ARRAY_SIZE(dim_tune_stat_str) ?\n\t\tdim_tune_stat_str[dim->tune_state] : \"unknown\");\n\tsprintf(result[j++], \"%u\", dim->steps_left);\n\tsprintf(result[j++], \"%u\", dim->steps_right);\n\tsprintf(result[j++], \"%u\", dim->tired);\n\tsprintf(result[j++], \"%u\", coal->int_gl);\n\tsprintf(result[j++], \"%u\", coal->int_ql);\n\treg_val = readl(tqp_vector->mask_addr + gl_offset) &\n\t\t  HNS3_VECTOR_GL_MASK;\n\tsprintf(result[j++], \"%u\", reg_val);\n\tif (ql_enable) {\n\t\treg_val = readl(tqp_vector->mask_addr + ql_offset) &\n\t\t\t  HNS3_VECTOR_QL_MASK;\n\t\tsprintf(result[j++], \"%u\", reg_val);\n\t} else {\n\t\tsprintf(result[j++], \"NA\");\n\t}\n}\n\nstatic void hns3_dump_coal_info(struct hnae3_handle *h, char *buf, int len,\n\t\t\t\tint *pos, bool is_tx)\n{\n\tchar data_str[ARRAY_SIZE(coal_info_items)][HNS3_DBG_DATA_STR_LEN];\n\tchar *result[ARRAY_SIZE(coal_info_items)];\n\tstruct hns3_enet_tqp_vector *tqp_vector;\n\tstruct hns3_nic_priv *priv = h->priv;\n\tchar content[HNS3_DBG_INFO_LEN];\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coal_info_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"%s interrupt coalesce info:\\n\",\n\t\t\t  is_tx ? \"tx\" : \"rx\");\n\thns3_dbg_fill_content(content, sizeof(content), coal_info_items,\n\t\t\t      NULL, ARRAY_SIZE(coal_info_items));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\n\tfor (i = 0; i < priv->vector_num; i++) {\n\t\ttqp_vector = &priv->tqp_vector[i];\n\t\thns3_get_coal_info(tqp_vector, result, i, is_tx);\n\t\thns3_dbg_fill_content(content, sizeof(content), coal_info_items,\n\t\t\t\t      (const char **)result,\n\t\t\t\t      ARRAY_SIZE(coal_info_items));\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\t}\n}\n\nstatic int hns3_dbg_coal_info(struct hnae3_handle *h, char *buf, int len)\n{\n\tint pos = 0;\n\n\thns3_dump_coal_info(h, buf, len, &pos, true);\n\tpos += scnprintf(buf + pos, len - pos, \"\\n\");\n\thns3_dump_coal_info(h, buf, len, &pos, false);\n\n\treturn 0;\n}\n\nstatic const struct hns3_dbg_item tx_spare_info_items[] = {\n\t{ \"QUEUE_ID\", 2 },\n\t{ \"COPYBREAK\", 2 },\n\t{ \"LEN\", 7 },\n\t{ \"NTU\", 4 },\n\t{ \"NTC\", 4 },\n\t{ \"LTC\", 4 },\n\t{ \"DMA\", 17 },\n};\n\nstatic void hns3_dbg_tx_spare_info(struct hns3_enet_ring *ring, char *buf,\n\t\t\t\t   int len, u32 ring_num, int *pos)\n{\n\tchar data_str[ARRAY_SIZE(tx_spare_info_items)][HNS3_DBG_DATA_STR_LEN];\n\tstruct hns3_tx_spare *tx_spare = ring->tx_spare;\n\tchar *result[ARRAY_SIZE(tx_spare_info_items)];\n\tchar content[HNS3_DBG_INFO_LEN];\n\tu32 i, j;\n\n\tif (!tx_spare) {\n\t\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t\t  \"tx spare buffer is not enabled\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tx_spare_info_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"tx spare buffer info\\n\");\n\thns3_dbg_fill_content(content, sizeof(content), tx_spare_info_items,\n\t\t\t      NULL, ARRAY_SIZE(tx_spare_info_items));\n\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\n\tfor (i = 0; i < ring_num; i++) {\n\t\tj = 0;\n\t\tsprintf(result[j++], \"%u\", i);\n\t\tsprintf(result[j++], \"%u\", ring->tx_copybreak);\n\t\tsprintf(result[j++], \"%u\", tx_spare->len);\n\t\tsprintf(result[j++], \"%u\", tx_spare->next_to_use);\n\t\tsprintf(result[j++], \"%u\", tx_spare->next_to_clean);\n\t\tsprintf(result[j++], \"%u\", tx_spare->last_to_clean);\n\t\tsprintf(result[j++], \"%pad\", &tx_spare->dma);\n\t\thns3_dbg_fill_content(content, sizeof(content),\n\t\t\t\t      tx_spare_info_items,\n\t\t\t\t      (const char **)result,\n\t\t\t\t      ARRAY_SIZE(tx_spare_info_items));\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%s\", content);\n\t}\n}\n\nstatic const struct hns3_dbg_item rx_queue_info_items[] = {\n\t{ \"QUEUE_ID\", 2 },\n\t{ \"BD_NUM\", 2 },\n\t{ \"BD_LEN\", 2 },\n\t{ \"TAIL\", 2 },\n\t{ \"HEAD\", 2 },\n\t{ \"FBDNUM\", 2 },\n\t{ \"PKTNUM\", 5 },\n\t{ \"COPYBREAK\", 2 },\n\t{ \"RING_EN\", 2 },\n\t{ \"RX_RING_EN\", 2 },\n\t{ \"BASE_ADDR\", 10 },\n};\n\nstatic void hns3_dump_rx_queue_info(struct hns3_enet_ring *ring,\n\t\t\t\t    struct hnae3_ae_dev *ae_dev, char **result,\n\t\t\t\t    u32 index)\n{\n\tu32 base_add_l, base_add_h;\n\tu32 j = 0;\n\n\tsprintf(result[j++], \"%u\", index);\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_RX_RING_BD_NUM_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_RX_RING_BD_LEN_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_RX_RING_TAIL_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_RX_RING_HEAD_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_RX_RING_FBDNUM_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_RX_RING_PKTNUM_RECORD_REG));\n\tsprintf(result[j++], \"%u\", ring->rx_copybreak);\n\n\tsprintf(result[j++], \"%s\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_EN_REG) ? \"on\" : \"off\");\n\n\tif (hnae3_ae_dev_tqp_txrx_indep_supported(ae_dev))\n\t\tsprintf(result[j++], \"%s\", readl_relaxed(ring->tqp->io_base +\n\t\t\tHNS3_RING_RX_EN_REG) ? \"on\" : \"off\");\n\telse\n\t\tsprintf(result[j++], \"%s\", \"NA\");\n\n\tbase_add_h = readl_relaxed(ring->tqp->io_base +\n\t\t\t\t\tHNS3_RING_RX_RING_BASEADDR_H_REG);\n\tbase_add_l = readl_relaxed(ring->tqp->io_base +\n\t\t\t\t\tHNS3_RING_RX_RING_BASEADDR_L_REG);\n\tsprintf(result[j++], \"0x%08x%08x\", base_add_h, base_add_l);\n}\n\nstatic int hns3_dbg_rx_queue_info(struct hnae3_handle *h,\n\t\t\t\t  char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(rx_queue_info_items)][HNS3_DBG_DATA_STR_LEN];\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tchar *result[ARRAY_SIZE(rx_queue_info_items)];\n\tstruct hns3_nic_priv *priv = h->priv;\n\tchar content[HNS3_DBG_INFO_LEN];\n\tstruct hns3_enet_ring *ring;\n\tint pos = 0;\n\tu32 i;\n\n\tif (!priv->ring) {\n\t\tdev_err(&h->pdev->dev, \"priv->ring is NULL\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rx_queue_info_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\thns3_dbg_fill_content(content, sizeof(content), rx_queue_info_items,\n\t\t\t      NULL, ARRAY_SIZE(rx_queue_info_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\t \n\t\tif (!test_bit(HNS3_NIC_STATE_INITED, &priv->state) ||\n\t\t    test_bit(HNS3_NIC_STATE_RESETTING, &priv->state))\n\t\t\treturn -EPERM;\n\n\t\tring = &priv->ring[(u32)(i + h->kinfo.num_tqps)];\n\t\thns3_dump_rx_queue_info(ring, ae_dev, result, i);\n\t\thns3_dbg_fill_content(content, sizeof(content),\n\t\t\t\t      rx_queue_info_items,\n\t\t\t\t      (const char **)result,\n\t\t\t\t      ARRAY_SIZE(rx_queue_info_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hns3_dbg_item tx_queue_info_items[] = {\n\t{ \"QUEUE_ID\", 2 },\n\t{ \"BD_NUM\", 2 },\n\t{ \"TC\", 2 },\n\t{ \"TAIL\", 2 },\n\t{ \"HEAD\", 2 },\n\t{ \"FBDNUM\", 2 },\n\t{ \"OFFSET\", 2 },\n\t{ \"PKTNUM\", 5 },\n\t{ \"RING_EN\", 2 },\n\t{ \"TX_RING_EN\", 2 },\n\t{ \"BASE_ADDR\", 10 },\n};\n\nstatic void hns3_dump_tx_queue_info(struct hns3_enet_ring *ring,\n\t\t\t\t    struct hnae3_ae_dev *ae_dev, char **result,\n\t\t\t\t    u32 index)\n{\n\tu32 base_add_l, base_add_h;\n\tu32 j = 0;\n\n\tsprintf(result[j++], \"%u\", index);\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_TX_RING_BD_NUM_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_TX_RING_TC_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_TX_RING_TAIL_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_TX_RING_HEAD_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_TX_RING_FBDNUM_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_TX_RING_OFFSET_REG));\n\n\tsprintf(result[j++], \"%u\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_TX_RING_PKTNUM_RECORD_REG));\n\n\tsprintf(result[j++], \"%s\", readl_relaxed(ring->tqp->io_base +\n\t\tHNS3_RING_EN_REG) ? \"on\" : \"off\");\n\n\tif (hnae3_ae_dev_tqp_txrx_indep_supported(ae_dev))\n\t\tsprintf(result[j++], \"%s\", readl_relaxed(ring->tqp->io_base +\n\t\t\tHNS3_RING_TX_EN_REG) ? \"on\" : \"off\");\n\telse\n\t\tsprintf(result[j++], \"%s\", \"NA\");\n\n\tbase_add_h = readl_relaxed(ring->tqp->io_base +\n\t\t\t\t\tHNS3_RING_TX_RING_BASEADDR_H_REG);\n\tbase_add_l = readl_relaxed(ring->tqp->io_base +\n\t\t\t\t\tHNS3_RING_TX_RING_BASEADDR_L_REG);\n\tsprintf(result[j++], \"0x%08x%08x\", base_add_h, base_add_l);\n}\n\nstatic int hns3_dbg_tx_queue_info(struct hnae3_handle *h,\n\t\t\t\t  char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(tx_queue_info_items)][HNS3_DBG_DATA_STR_LEN];\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tchar *result[ARRAY_SIZE(tx_queue_info_items)];\n\tstruct hns3_nic_priv *priv = h->priv;\n\tchar content[HNS3_DBG_INFO_LEN];\n\tstruct hns3_enet_ring *ring;\n\tint pos = 0;\n\tu32 i;\n\n\tif (!priv->ring) {\n\t\tdev_err(&h->pdev->dev, \"priv->ring is NULL\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tx_queue_info_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\thns3_dbg_fill_content(content, sizeof(content), tx_queue_info_items,\n\t\t\t      NULL, ARRAY_SIZE(tx_queue_info_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\t \n\t\tif (!test_bit(HNS3_NIC_STATE_INITED, &priv->state) ||\n\t\t    test_bit(HNS3_NIC_STATE_RESETTING, &priv->state))\n\t\t\treturn -EPERM;\n\n\t\tring = &priv->ring[i];\n\t\thns3_dump_tx_queue_info(ring, ae_dev, result, i);\n\t\thns3_dbg_fill_content(content, sizeof(content),\n\t\t\t\t      tx_queue_info_items,\n\t\t\t\t      (const char **)result,\n\t\t\t\t      ARRAY_SIZE(tx_queue_info_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\thns3_dbg_tx_spare_info(ring, buf, len, h->kinfo.num_tqps, &pos);\n\n\treturn 0;\n}\n\nstatic const struct hns3_dbg_item queue_map_items[] = {\n\t{ \"local_queue_id\", 2 },\n\t{ \"global_queue_id\", 2 },\n\t{ \"vector_id\", 2 },\n};\n\nstatic int hns3_dbg_queue_map(struct hnae3_handle *h, char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(queue_map_items)][HNS3_DBG_DATA_STR_LEN];\n\tchar *result[ARRAY_SIZE(queue_map_items)];\n\tstruct hns3_nic_priv *priv = h->priv;\n\tchar content[HNS3_DBG_INFO_LEN];\n\tint pos = 0;\n\tint j;\n\tu32 i;\n\n\tif (!h->ae_algo->ops->get_global_queue_id)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < ARRAY_SIZE(queue_map_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\thns3_dbg_fill_content(content, sizeof(content), queue_map_items,\n\t\t\t      NULL, ARRAY_SIZE(queue_map_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\tif (!priv->ring || !priv->ring[i].tqp_vector)\n\t\t\tcontinue;\n\t\tj = 0;\n\t\tsprintf(result[j++], \"%u\", i);\n\t\tsprintf(result[j++], \"%u\",\n\t\t\th->ae_algo->ops->get_global_queue_id(h, i));\n\t\tsprintf(result[j++], \"%d\",\n\t\t\tpriv->ring[i].tqp_vector->vector_irq);\n\t\thns3_dbg_fill_content(content, sizeof(content), queue_map_items,\n\t\t\t\t      (const char **)result,\n\t\t\t\t      ARRAY_SIZE(queue_map_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hns3_dbg_item rx_bd_info_items[] = {\n\t{ \"BD_IDX\", 3 },\n\t{ \"L234_INFO\", 2 },\n\t{ \"PKT_LEN\", 3 },\n\t{ \"SIZE\", 4 },\n\t{ \"RSS_HASH\", 4 },\n\t{ \"FD_ID\", 2 },\n\t{ \"VLAN_TAG\", 2 },\n\t{ \"O_DM_VLAN_ID_FB\", 2 },\n\t{ \"OT_VLAN_TAG\", 2 },\n\t{ \"BD_BASE_INFO\", 2 },\n\t{ \"PTYPE\", 2 },\n\t{ \"HW_CSUM\", 2 },\n};\n\nstatic void hns3_dump_rx_bd_info(struct hns3_nic_priv *priv,\n\t\t\t\t struct hns3_desc *desc, char **result, int idx)\n{\n\tunsigned int j = 0;\n\n\tsprintf(result[j++], \"%d\", idx);\n\tsprintf(result[j++], \"%#x\", le32_to_cpu(desc->rx.l234_info));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->rx.pkt_len));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->rx.size));\n\tsprintf(result[j++], \"%#x\", le32_to_cpu(desc->rx.rss_hash));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->rx.fd_id));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->rx.vlan_tag));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->rx.o_dm_vlan_id_fb));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->rx.ot_vlan_tag));\n\tsprintf(result[j++], \"%#x\", le32_to_cpu(desc->rx.bd_base_info));\n\tif (test_bit(HNS3_NIC_STATE_RXD_ADV_LAYOUT_ENABLE, &priv->state)) {\n\t\tu32 ol_info = le32_to_cpu(desc->rx.ol_info);\n\n\t\tsprintf(result[j++], \"%5lu\", hnae3_get_field(ol_info,\n\t\t\t\t\t\t\t     HNS3_RXD_PTYPE_M,\n\t\t\t\t\t\t\t     HNS3_RXD_PTYPE_S));\n\t\tsprintf(result[j++], \"%7u\", le16_to_cpu(desc->csum));\n\t} else {\n\t\tsprintf(result[j++], \"NA\");\n\t\tsprintf(result[j++], \"NA\");\n\t}\n}\n\nstatic int hns3_dbg_rx_bd_info(struct hns3_dbg_data *d, char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(rx_bd_info_items)][HNS3_DBG_DATA_STR_LEN];\n\tstruct hns3_nic_priv *priv = d->handle->priv;\n\tchar *result[ARRAY_SIZE(rx_bd_info_items)];\n\tchar content[HNS3_DBG_INFO_LEN];\n\tstruct hns3_enet_ring *ring;\n\tstruct hns3_desc *desc;\n\tunsigned int i;\n\tint pos = 0;\n\n\tif (d->qid >= d->handle->kinfo.num_tqps) {\n\t\tdev_err(&d->handle->pdev->dev,\n\t\t\t\"queue%u is not in use\\n\", d->qid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rx_bd_info_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t  \"Queue %u rx bd info:\\n\", d->qid);\n\thns3_dbg_fill_content(content, sizeof(content), rx_bd_info_items,\n\t\t\t      NULL, ARRAY_SIZE(rx_bd_info_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\n\tring = &priv->ring[d->qid + d->handle->kinfo.num_tqps];\n\tfor (i = 0; i < ring->desc_num; i++) {\n\t\tdesc = &ring->desc[i];\n\n\t\thns3_dump_rx_bd_info(priv, desc, result, i);\n\t\thns3_dbg_fill_content(content, sizeof(content),\n\t\t\t\t      rx_bd_info_items, (const char **)result,\n\t\t\t\t      ARRAY_SIZE(rx_bd_info_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hns3_dbg_item tx_bd_info_items[] = {\n\t{ \"BD_IDX\", 2 },\n\t{ \"ADDRESS\", 13 },\n\t{ \"VLAN_TAG\", 2 },\n\t{ \"SIZE\", 2 },\n\t{ \"T_CS_VLAN_TSO\", 2 },\n\t{ \"OT_VLAN_TAG\", 3 },\n\t{ \"TV\", 5 },\n\t{ \"OLT_VLAN_LEN\", 2 },\n\t{ \"PAYLEN_OL4CS\", 2 },\n\t{ \"BD_FE_SC_VLD\", 2 },\n\t{ \"MSS_HW_CSUM\", 0 },\n};\n\nstatic void hns3_dump_tx_bd_info(struct hns3_desc *desc, char **result, int idx)\n{\n\tunsigned int j = 0;\n\n\tsprintf(result[j++], \"%d\", idx);\n\tsprintf(result[j++], \"%#llx\", le64_to_cpu(desc->addr));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->tx.vlan_tag));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->tx.send_size));\n\tsprintf(result[j++], \"%#x\",\n\t\tle32_to_cpu(desc->tx.type_cs_vlan_tso_len));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->tx.outer_vlan_tag));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->tx.tv));\n\tsprintf(result[j++], \"%u\",\n\t\tle32_to_cpu(desc->tx.ol_type_vlan_len_msec));\n\tsprintf(result[j++], \"%#x\", le32_to_cpu(desc->tx.paylen_ol4cs));\n\tsprintf(result[j++], \"%#x\", le16_to_cpu(desc->tx.bdtp_fe_sc_vld_ra_ri));\n\tsprintf(result[j++], \"%u\", le16_to_cpu(desc->tx.mss_hw_csum));\n}\n\nstatic int hns3_dbg_tx_bd_info(struct hns3_dbg_data *d, char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(tx_bd_info_items)][HNS3_DBG_DATA_STR_LEN];\n\tstruct hns3_nic_priv *priv = d->handle->priv;\n\tchar *result[ARRAY_SIZE(tx_bd_info_items)];\n\tchar content[HNS3_DBG_INFO_LEN];\n\tstruct hns3_enet_ring *ring;\n\tstruct hns3_desc *desc;\n\tunsigned int i;\n\tint pos = 0;\n\n\tif (d->qid >= d->handle->kinfo.num_tqps) {\n\t\tdev_err(&d->handle->pdev->dev,\n\t\t\t\"queue%u is not in use\\n\", d->qid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tx_bd_info_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\tpos += scnprintf(buf + pos, len - pos,\n\t\t\t  \"Queue %u tx bd info:\\n\", d->qid);\n\thns3_dbg_fill_content(content, sizeof(content), tx_bd_info_items,\n\t\t\t      NULL, ARRAY_SIZE(tx_bd_info_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\n\tring = &priv->ring[d->qid];\n\tfor (i = 0; i < ring->desc_num; i++) {\n\t\tdesc = &ring->desc[i];\n\n\t\thns3_dump_tx_bd_info(desc, result, i);\n\t\thns3_dbg_fill_content(content, sizeof(content),\n\t\t\t\t      tx_bd_info_items, (const char **)result,\n\t\t\t\t      ARRAY_SIZE(tx_bd_info_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nhns3_dbg_dev_caps(struct hnae3_handle *h, char *buf, int len, int *pos)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tconst char * const str[] = {\"no\", \"yes\"};\n\tunsigned long *caps = ae_dev->caps;\n\tu32 i, state;\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"dev capability:\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_dbg_cap); i++) {\n\t\tstate = test_bit(hns3_dbg_cap[i].cap_bit, caps);\n\t\t*pos += scnprintf(buf + *pos, len - *pos, \"%s: %s\\n\",\n\t\t\t\t  hns3_dbg_cap[i].name, str[state]);\n\t}\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"\\n\");\n}\n\nstatic void\nhns3_dbg_dev_specs(struct hnae3_handle *h, char *buf, int len, int *pos)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(h->pdev);\n\tstruct hnae3_dev_specs *dev_specs = &ae_dev->dev_specs;\n\tstruct hnae3_knic_private_info *kinfo = &h->kinfo;\n\tstruct net_device *dev = kinfo->netdev;\n\n\t*pos += scnprintf(buf + *pos, len - *pos, \"dev_spec:\\n\");\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAC entry num: %u\\n\",\n\t\t\t  dev_specs->mac_entry_num);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MNG entry num: %u\\n\",\n\t\t\t  dev_specs->mng_entry_num);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAX non tso bd num: %u\\n\",\n\t\t\t  dev_specs->max_non_tso_bd_num);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"RSS ind tbl size: %u\\n\",\n\t\t\t  dev_specs->rss_ind_tbl_size);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"RSS key size: %u\\n\",\n\t\t\t  dev_specs->rss_key_size);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"RSS size: %u\\n\",\n\t\t\t  kinfo->rss_size);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"Allocated RSS size: %u\\n\",\n\t\t\t  kinfo->req_rss_size);\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"Task queue pairs numbers: %u\\n\",\n\t\t\t  kinfo->num_tqps);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"RX buffer length: %u\\n\",\n\t\t\t  kinfo->rx_buf_len);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"Desc num per TX queue: %u\\n\",\n\t\t\t  kinfo->num_tx_desc);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"Desc num per RX queue: %u\\n\",\n\t\t\t  kinfo->num_rx_desc);\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"Total number of enabled TCs: %u\\n\",\n\t\t\t  kinfo->tc_info.num_tc);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAX INT QL: %u\\n\",\n\t\t\t  dev_specs->int_ql_max);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAX INT GL: %u\\n\",\n\t\t\t  dev_specs->max_int_gl);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAX TM RATE: %u\\n\",\n\t\t\t  dev_specs->max_tm_rate);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAX QSET number: %u\\n\",\n\t\t\t  dev_specs->max_qset_num);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"umv size: %u\\n\",\n\t\t\t  dev_specs->umv_size);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"mc mac size: %u\\n\",\n\t\t\t  dev_specs->mc_mac_size);\n\t*pos += scnprintf(buf + *pos, len - *pos, \"MAC statistics number: %u\\n\",\n\t\t\t  dev_specs->mac_stats_num);\n\t*pos += scnprintf(buf + *pos, len - *pos,\n\t\t\t  \"TX timeout threshold: %d seconds\\n\",\n\t\t\t  dev->watchdog_timeo / HZ);\n}\n\nstatic int hns3_dbg_dev_info(struct hnae3_handle *h, char *buf, int len)\n{\n\tint pos = 0;\n\n\thns3_dbg_dev_caps(h, buf, len, &pos);\n\n\thns3_dbg_dev_specs(h, buf, len, &pos);\n\n\treturn 0;\n}\n\nstatic const struct hns3_dbg_item page_pool_info_items[] = {\n\t{ \"QUEUE_ID\", 2 },\n\t{ \"ALLOCATE_CNT\", 2 },\n\t{ \"FREE_CNT\", 6 },\n\t{ \"POOL_SIZE(PAGE_NUM)\", 2 },\n\t{ \"ORDER\", 2 },\n\t{ \"NUMA_ID\", 2 },\n\t{ \"MAX_LEN\", 2 },\n};\n\nstatic void hns3_dump_page_pool_info(struct hns3_enet_ring *ring,\n\t\t\t\t     char **result, u32 index)\n{\n\tu32 j = 0;\n\n\tsprintf(result[j++], \"%u\", index);\n\tsprintf(result[j++], \"%u\",\n\t\tREAD_ONCE(ring->page_pool->pages_state_hold_cnt));\n\tsprintf(result[j++], \"%d\",\n\t\tatomic_read(&ring->page_pool->pages_state_release_cnt));\n\tsprintf(result[j++], \"%u\", ring->page_pool->p.pool_size);\n\tsprintf(result[j++], \"%u\", ring->page_pool->p.order);\n\tsprintf(result[j++], \"%d\", ring->page_pool->p.nid);\n\tsprintf(result[j++], \"%uK\", ring->page_pool->p.max_len / 1024);\n}\n\nstatic int\nhns3_dbg_page_pool_info(struct hnae3_handle *h, char *buf, int len)\n{\n\tchar data_str[ARRAY_SIZE(page_pool_info_items)][HNS3_DBG_DATA_STR_LEN];\n\tchar *result[ARRAY_SIZE(page_pool_info_items)];\n\tstruct hns3_nic_priv *priv = h->priv;\n\tchar content[HNS3_DBG_INFO_LEN];\n\tstruct hns3_enet_ring *ring;\n\tint pos = 0;\n\tu32 i;\n\n\tif (!priv->ring) {\n\t\tdev_err(&h->pdev->dev, \"priv->ring is NULL\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!priv->ring[h->kinfo.num_tqps].page_pool) {\n\t\tdev_err(&h->pdev->dev, \"page pool is not initialized\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(page_pool_info_items); i++)\n\t\tresult[i] = &data_str[i][0];\n\n\thns3_dbg_fill_content(content, sizeof(content), page_pool_info_items,\n\t\t\t      NULL, ARRAY_SIZE(page_pool_info_items));\n\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\tfor (i = 0; i < h->kinfo.num_tqps; i++) {\n\t\tif (!test_bit(HNS3_NIC_STATE_INITED, &priv->state) ||\n\t\t    test_bit(HNS3_NIC_STATE_RESETTING, &priv->state))\n\t\t\treturn -EPERM;\n\t\tring = &priv->ring[(u32)(i + h->kinfo.num_tqps)];\n\t\thns3_dump_page_pool_info(ring, result, i);\n\t\thns3_dbg_fill_content(content, sizeof(content),\n\t\t\t\t      page_pool_info_items,\n\t\t\t\t      (const char **)result,\n\t\t\t\t      ARRAY_SIZE(page_pool_info_items));\n\t\tpos += scnprintf(buf + pos, len - pos, \"%s\", content);\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_dbg_get_cmd_index(struct hns3_dbg_data *dbg_data, u32 *index)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_dbg_cmd); i++) {\n\t\tif (hns3_dbg_cmd[i].cmd == dbg_data->cmd) {\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(&dbg_data->handle->pdev->dev, \"unknown command(%d)\\n\",\n\t\tdbg_data->cmd);\n\treturn -EINVAL;\n}\n\nstatic const struct hns3_dbg_func hns3_dbg_cmd_func[] = {\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_QUEUE_MAP,\n\t\t.dbg_dump = hns3_dbg_queue_map,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_DEV_INFO,\n\t\t.dbg_dump = hns3_dbg_dev_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TX_BD,\n\t\t.dbg_dump_bd = hns3_dbg_tx_bd_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_RX_BD,\n\t\t.dbg_dump_bd = hns3_dbg_rx_bd_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_RX_QUEUE_INFO,\n\t\t.dbg_dump = hns3_dbg_rx_queue_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_TX_QUEUE_INFO,\n\t\t.dbg_dump = hns3_dbg_tx_queue_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_PAGE_POOL_INFO,\n\t\t.dbg_dump = hns3_dbg_page_pool_info,\n\t},\n\t{\n\t\t.cmd = HNAE3_DBG_CMD_COAL_INFO,\n\t\t.dbg_dump = hns3_dbg_coal_info,\n\t},\n};\n\nstatic int hns3_dbg_read_cmd(struct hns3_dbg_data *dbg_data,\n\t\t\t     enum hnae3_dbg_cmd cmd, char *buf, int len)\n{\n\tconst struct hnae3_ae_ops *ops = dbg_data->handle->ae_algo->ops;\n\tconst struct hns3_dbg_func *cmd_func;\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_dbg_cmd_func); i++) {\n\t\tif (cmd == hns3_dbg_cmd_func[i].cmd) {\n\t\t\tcmd_func = &hns3_dbg_cmd_func[i];\n\t\t\tif (cmd_func->dbg_dump)\n\t\t\t\treturn cmd_func->dbg_dump(dbg_data->handle, buf,\n\t\t\t\t\t\t\t  len);\n\t\t\telse\n\t\t\t\treturn cmd_func->dbg_dump_bd(dbg_data, buf,\n\t\t\t\t\t\t\t     len);\n\t\t}\n\t}\n\n\tif (!ops->dbg_read_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ops->dbg_read_cmd(dbg_data->handle, cmd, buf, len);\n}\n\nstatic ssize_t hns3_dbg_read(struct file *filp, char __user *buffer,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct hns3_dbg_data *dbg_data = filp->private_data;\n\tstruct hnae3_handle *handle = dbg_data->handle;\n\tstruct hns3_nic_priv *priv = handle->priv;\n\tssize_t size = 0;\n\tchar **save_buf;\n\tchar *read_buf;\n\tu32 index;\n\tint ret;\n\n\tret = hns3_dbg_get_cmd_index(dbg_data, &index);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&handle->dbgfs_lock);\n\tsave_buf = &handle->dbgfs_buf[index];\n\n\tif (!test_bit(HNS3_NIC_STATE_INITED, &priv->state) ||\n\t    test_bit(HNS3_NIC_STATE_RESETTING, &priv->state)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (*save_buf) {\n\t\tread_buf = *save_buf;\n\t} else {\n\t\tread_buf = kvzalloc(hns3_dbg_cmd[index].buf_len, GFP_KERNEL);\n\t\tif (!read_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\t*save_buf = read_buf;\n\n\t\t \n\t\tret = hns3_dbg_read_cmd(dbg_data, hns3_dbg_cmd[index].cmd,\n\t\t\t\t\tread_buf, hns3_dbg_cmd[index].buf_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tsize = simple_read_from_buffer(buffer, count, ppos, read_buf,\n\t\t\t\t       strlen(read_buf));\n\tif (size > 0) {\n\t\tmutex_unlock(&handle->dbgfs_lock);\n\t\treturn size;\n\t}\n\nout:\n\t \n\tif (*save_buf) {\n\t\tkvfree(*save_buf);\n\t\t*save_buf = NULL;\n\t}\n\n\tmutex_unlock(&handle->dbgfs_lock);\n\treturn ret;\n}\n\nstatic const struct file_operations hns3_dbg_fops = {\n\t.owner = THIS_MODULE,\n\t.open  = simple_open,\n\t.read  = hns3_dbg_read,\n};\n\nstatic int hns3_dbg_bd_file_init(struct hnae3_handle *handle, u32 cmd)\n{\n\tstruct dentry *entry_dir;\n\tstruct hns3_dbg_data *data;\n\tu16 max_queue_num;\n\tunsigned int i;\n\n\tentry_dir = hns3_dbg_dentry[hns3_dbg_cmd[cmd].dentry].dentry;\n\tmax_queue_num = hns3_get_max_available_channels(handle);\n\tdata = devm_kzalloc(&handle->pdev->dev, max_queue_num * sizeof(*data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max_queue_num; i++) {\n\t\tchar name[HNS3_DBG_FILE_NAME_LEN];\n\n\t\tdata[i].handle = handle;\n\t\tdata[i].cmd = hns3_dbg_cmd[cmd].cmd;\n\t\tdata[i].qid = i;\n\t\tsprintf(name, \"%s%u\", hns3_dbg_cmd[cmd].name, i);\n\t\tdebugfs_create_file(name, 0400, entry_dir, &data[i],\n\t\t\t\t    &hns3_dbg_fops);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhns3_dbg_common_file_init(struct hnae3_handle *handle, u32 cmd)\n{\n\tstruct hns3_dbg_data *data;\n\tstruct dentry *entry_dir;\n\n\tdata = devm_kzalloc(&handle->pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = handle;\n\tdata->cmd = hns3_dbg_cmd[cmd].cmd;\n\tentry_dir = hns3_dbg_dentry[hns3_dbg_cmd[cmd].dentry].dentry;\n\tdebugfs_create_file(hns3_dbg_cmd[cmd].name, 0400, entry_dir,\n\t\t\t    data, &hns3_dbg_fops);\n\n\treturn 0;\n}\n\nint hns3_dbg_init(struct hnae3_handle *handle)\n{\n\tstruct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);\n\tconst char *name = pci_name(handle->pdev);\n\tint ret;\n\tu32 i;\n\n\thandle->dbgfs_buf = devm_kcalloc(&handle->pdev->dev,\n\t\t\t\t\t ARRAY_SIZE(hns3_dbg_cmd),\n\t\t\t\t\t sizeof(*handle->dbgfs_buf),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!handle->dbgfs_buf)\n\t\treturn -ENOMEM;\n\n\thns3_dbg_dentry[HNS3_DBG_DENTRY_COMMON].dentry =\n\t\t\t\tdebugfs_create_dir(name, hns3_dbgfs_root);\n\thandle->hnae3_dbgfs = hns3_dbg_dentry[HNS3_DBG_DENTRY_COMMON].dentry;\n\n\tfor (i = 0; i < HNS3_DBG_DENTRY_COMMON; i++)\n\t\thns3_dbg_dentry[i].dentry =\n\t\t\tdebugfs_create_dir(hns3_dbg_dentry[i].name,\n\t\t\t\t\t   handle->hnae3_dbgfs);\n\n\tmutex_init(&handle->dbgfs_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_dbg_cmd); i++) {\n\t\tif ((hns3_dbg_cmd[i].cmd == HNAE3_DBG_CMD_TM_NODES &&\n\t\t     ae_dev->dev_version <= HNAE3_DEVICE_VERSION_V2) ||\n\t\t    (hns3_dbg_cmd[i].cmd == HNAE3_DBG_CMD_PTP_INFO &&\n\t\t     !test_bit(HNAE3_DEV_SUPPORT_PTP_B, ae_dev->caps)))\n\t\t\tcontinue;\n\n\t\tif (!hns3_dbg_cmd[i].init) {\n\t\t\tdev_err(&handle->pdev->dev,\n\t\t\t\t\"cmd %s lack of init func\\n\",\n\t\t\t\thns3_dbg_cmd[i].name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = hns3_dbg_cmd[i].init(handle, i);\n\t\tif (ret) {\n\t\t\tdev_err(&handle->pdev->dev, \"failed to init cmd %s\\n\",\n\t\t\t\thns3_dbg_cmd[i].name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\n\nout:\n\tdebugfs_remove_recursive(handle->hnae3_dbgfs);\n\thandle->hnae3_dbgfs = NULL;\n\tmutex_destroy(&handle->dbgfs_lock);\n\treturn ret;\n}\n\nvoid hns3_dbg_uninit(struct hnae3_handle *handle)\n{\n\tu32 i;\n\n\tdebugfs_remove_recursive(handle->hnae3_dbgfs);\n\thandle->hnae3_dbgfs = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_dbg_cmd); i++)\n\t\tif (handle->dbgfs_buf[i]) {\n\t\t\tkvfree(handle->dbgfs_buf[i]);\n\t\t\thandle->dbgfs_buf[i] = NULL;\n\t\t}\n\n\tmutex_destroy(&handle->dbgfs_lock);\n}\n\nvoid hns3_dbg_register_debugfs(const char *debugfs_dir_name)\n{\n\thns3_dbgfs_root = debugfs_create_dir(debugfs_dir_name, NULL);\n}\n\nvoid hns3_dbg_unregister_debugfs(void)\n{\n\tdebugfs_remove_recursive(hns3_dbgfs_root);\n\thns3_dbgfs_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}