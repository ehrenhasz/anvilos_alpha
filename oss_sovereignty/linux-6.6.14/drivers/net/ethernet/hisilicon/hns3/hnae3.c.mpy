{
  "module_name": "hnae3.c",
  "hash_id": "833d85b89ab238deb2295fb96a2db270dec2cf34be628008e19b26d74c49d8c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns3/hnae3.c",
  "human_readable_source": "\n\n\n#include <linux/list.h>\n#include <linux/spinlock.h>\n\n#include \"hnae3.h\"\n\nstatic LIST_HEAD(hnae3_ae_algo_list);\nstatic LIST_HEAD(hnae3_client_list);\nstatic LIST_HEAD(hnae3_ae_dev_list);\n\nvoid hnae3_unregister_ae_algo_prepare(struct hnae3_ae_algo *ae_algo)\n{\n\tconst struct pci_device_id *pci_id;\n\tstruct hnae3_ae_dev *ae_dev;\n\n\tif (!ae_algo)\n\t\treturn;\n\n\tlist_for_each_entry(ae_dev, &hnae3_ae_dev_list, node) {\n\t\tif (!hnae3_get_bit(ae_dev->flag, HNAE3_DEV_INITED_B))\n\t\t\tcontinue;\n\n\t\tpci_id = pci_match_id(ae_algo->pdev_id_table, ae_dev->pdev);\n\t\tif (!pci_id)\n\t\t\tcontinue;\n\t\tif (IS_ENABLED(CONFIG_PCI_IOV))\n\t\t\tpci_disable_sriov(ae_dev->pdev);\n\t}\n}\nEXPORT_SYMBOL(hnae3_unregister_ae_algo_prepare);\n\n \nstatic DEFINE_MUTEX(hnae3_common_lock);\n\nstatic bool hnae3_client_match(enum hnae3_client_type client_type)\n{\n\tif (client_type == HNAE3_CLIENT_KNIC ||\n\t    client_type == HNAE3_CLIENT_ROCE)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid hnae3_set_client_init_flag(struct hnae3_client *client,\n\t\t\t\tstruct hnae3_ae_dev *ae_dev,\n\t\t\t\tunsigned int inited)\n{\n\tif (!client || !ae_dev)\n\t\treturn;\n\n\tswitch (client->type) {\n\tcase HNAE3_CLIENT_KNIC:\n\t\thnae3_set_bit(ae_dev->flag, HNAE3_KNIC_CLIENT_INITED_B, inited);\n\t\tbreak;\n\tcase HNAE3_CLIENT_ROCE:\n\t\thnae3_set_bit(ae_dev->flag, HNAE3_ROCE_CLIENT_INITED_B, inited);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(hnae3_set_client_init_flag);\n\nstatic int hnae3_get_client_init_flag(struct hnae3_client *client,\n\t\t\t\t      struct hnae3_ae_dev *ae_dev)\n{\n\tint inited = 0;\n\n\tswitch (client->type) {\n\tcase HNAE3_CLIENT_KNIC:\n\t\tinited = hnae3_get_bit(ae_dev->flag,\n\t\t\t\t       HNAE3_KNIC_CLIENT_INITED_B);\n\t\tbreak;\n\tcase HNAE3_CLIENT_ROCE:\n\t\tinited = hnae3_get_bit(ae_dev->flag,\n\t\t\t\t       HNAE3_ROCE_CLIENT_INITED_B);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn inited;\n}\n\nstatic int hnae3_init_client_instance(struct hnae3_client *client,\n\t\t\t\t      struct hnae3_ae_dev *ae_dev)\n{\n\tint ret;\n\n\t \n\tif (!(hnae3_client_match(client->type) &&\n\t      hnae3_get_bit(ae_dev->flag, HNAE3_DEV_INITED_B))) {\n\t\treturn 0;\n\t}\n\n\tret = ae_dev->ops->init_client_instance(client, ae_dev);\n\tif (ret)\n\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\"fail to instantiate client, ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void hnae3_uninit_client_instance(struct hnae3_client *client,\n\t\t\t\t\t struct hnae3_ae_dev *ae_dev)\n{\n\t \n\tif (!(hnae3_client_match(client->type) &&\n\t      hnae3_get_bit(ae_dev->flag, HNAE3_DEV_INITED_B)))\n\t\treturn;\n\n\tif (hnae3_get_client_init_flag(client, ae_dev)) {\n\t\tae_dev->ops->uninit_client_instance(client, ae_dev);\n\n\t\thnae3_set_client_init_flag(client, ae_dev, 0);\n\t}\n}\n\nint hnae3_register_client(struct hnae3_client *client)\n{\n\tstruct hnae3_client *client_tmp;\n\tstruct hnae3_ae_dev *ae_dev;\n\n\tif (!client)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&hnae3_common_lock);\n\t \n\tlist_for_each_entry(client_tmp, &hnae3_client_list, node) {\n\t\tif (client_tmp->type == client->type)\n\t\t\tgoto exit;\n\t}\n\n\tlist_add_tail(&client->node, &hnae3_client_list);\n\n\t \n\tlist_for_each_entry(ae_dev, &hnae3_ae_dev_list, node) {\n\t\t \n\t\tint ret = hnae3_init_client_instance(client, ae_dev);\n\t\tif (ret)\n\t\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\t\"match and instantiation failed for port, ret = %d\\n\",\n\t\t\t\tret);\n\t}\n\nexit:\n\tmutex_unlock(&hnae3_common_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hnae3_register_client);\n\nvoid hnae3_unregister_client(struct hnae3_client *client)\n{\n\tstruct hnae3_client *client_tmp;\n\tstruct hnae3_ae_dev *ae_dev;\n\tbool existed = false;\n\n\tif (!client)\n\t\treturn;\n\n\tmutex_lock(&hnae3_common_lock);\n\t \n\tlist_for_each_entry(client_tmp, &hnae3_client_list, node) {\n\t\tif (client_tmp->type == client->type) {\n\t\t\texisted = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!existed) {\n\t\tmutex_unlock(&hnae3_common_lock);\n\t\tpr_err(\"client %s does not exist!\\n\", client->name);\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry(ae_dev, &hnae3_ae_dev_list, node) {\n\t\thnae3_uninit_client_instance(client, ae_dev);\n\t}\n\n\tlist_del(&client->node);\n\tmutex_unlock(&hnae3_common_lock);\n}\nEXPORT_SYMBOL(hnae3_unregister_client);\n\n \nvoid hnae3_register_ae_algo(struct hnae3_ae_algo *ae_algo)\n{\n\tconst struct pci_device_id *id;\n\tstruct hnae3_ae_dev *ae_dev;\n\tstruct hnae3_client *client;\n\tint ret;\n\n\tif (!ae_algo)\n\t\treturn;\n\n\tmutex_lock(&hnae3_common_lock);\n\n\tlist_add_tail(&ae_algo->node, &hnae3_ae_algo_list);\n\n\t \n\tlist_for_each_entry(ae_dev, &hnae3_ae_dev_list, node) {\n\t\tid = pci_match_id(ae_algo->pdev_id_table, ae_dev->pdev);\n\t\tif (!id)\n\t\t\tcontinue;\n\n\t\tif (!ae_algo->ops) {\n\t\t\tdev_err(&ae_dev->pdev->dev, \"ae_algo ops are null\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tae_dev->ops = ae_algo->ops;\n\n\t\tret = ae_algo->ops->init_ae_dev(ae_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\t\"init ae_dev error, ret = %d\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\thnae3_set_bit(ae_dev->flag, HNAE3_DEV_INITED_B, 1);\n\n\t\t \n\t\tlist_for_each_entry(client, &hnae3_client_list, node) {\n\t\t\tret = hnae3_init_client_instance(client, ae_dev);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\t\t\"match and instantiation failed, ret = %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\t}\n\n\tmutex_unlock(&hnae3_common_lock);\n}\nEXPORT_SYMBOL(hnae3_register_ae_algo);\n\n \nvoid hnae3_unregister_ae_algo(struct hnae3_ae_algo *ae_algo)\n{\n\tconst struct pci_device_id *id;\n\tstruct hnae3_ae_dev *ae_dev;\n\tstruct hnae3_client *client;\n\n\tif (!ae_algo)\n\t\treturn;\n\n\tmutex_lock(&hnae3_common_lock);\n\t \n\tlist_for_each_entry(ae_dev, &hnae3_ae_dev_list, node) {\n\t\tif (!hnae3_get_bit(ae_dev->flag, HNAE3_DEV_INITED_B))\n\t\t\tcontinue;\n\n\t\tid = pci_match_id(ae_algo->pdev_id_table, ae_dev->pdev);\n\t\tif (!id)\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each_entry(client, &hnae3_client_list, node)\n\t\t\thnae3_uninit_client_instance(client, ae_dev);\n\n\t\tae_algo->ops->uninit_ae_dev(ae_dev);\n\t\thnae3_set_bit(ae_dev->flag, HNAE3_DEV_INITED_B, 0);\n\t\tae_dev->ops = NULL;\n\t}\n\n\tlist_del(&ae_algo->node);\n\tmutex_unlock(&hnae3_common_lock);\n}\nEXPORT_SYMBOL(hnae3_unregister_ae_algo);\n\n \nint hnae3_register_ae_dev(struct hnae3_ae_dev *ae_dev)\n{\n\tconst struct pci_device_id *id;\n\tstruct hnae3_ae_algo *ae_algo;\n\tstruct hnae3_client *client;\n\tint ret;\n\n\tif (!ae_dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&hnae3_common_lock);\n\n\tlist_add_tail(&ae_dev->node, &hnae3_ae_dev_list);\n\n\t \n\tlist_for_each_entry(ae_algo, &hnae3_ae_algo_list, node) {\n\t\tid = pci_match_id(ae_algo->pdev_id_table, ae_dev->pdev);\n\t\tif (!id)\n\t\t\tcontinue;\n\n\t\tif (!ae_algo->ops) {\n\t\t\tdev_err(&ae_dev->pdev->dev, \"ae_algo ops are null\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out_err;\n\t\t}\n\t\tae_dev->ops = ae_algo->ops;\n\n\t\tret = ae_dev->ops->init_ae_dev(ae_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\t\"init ae_dev error, ret = %d\\n\", ret);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t \n\t\thnae3_set_bit(ae_dev->flag, HNAE3_DEV_INITED_B, 1);\n\t\tbreak;\n\t}\n\n\t \n\tlist_for_each_entry(client, &hnae3_client_list, node) {\n\t\tret = hnae3_init_client_instance(client, ae_dev);\n\t\tif (ret)\n\t\t\tdev_err(&ae_dev->pdev->dev,\n\t\t\t\t\"match and instantiation failed, ret = %d\\n\",\n\t\t\t\tret);\n\t}\n\n\tmutex_unlock(&hnae3_common_lock);\n\n\treturn 0;\n\nout_err:\n\tlist_del(&ae_dev->node);\n\tmutex_unlock(&hnae3_common_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(hnae3_register_ae_dev);\n\n \nvoid hnae3_unregister_ae_dev(struct hnae3_ae_dev *ae_dev)\n{\n\tconst struct pci_device_id *id;\n\tstruct hnae3_ae_algo *ae_algo;\n\tstruct hnae3_client *client;\n\n\tif (!ae_dev)\n\t\treturn;\n\n\tmutex_lock(&hnae3_common_lock);\n\t \n\tlist_for_each_entry(ae_algo, &hnae3_ae_algo_list, node) {\n\t\tif (!hnae3_get_bit(ae_dev->flag, HNAE3_DEV_INITED_B))\n\t\t\tcontinue;\n\n\t\tid = pci_match_id(ae_algo->pdev_id_table, ae_dev->pdev);\n\t\tif (!id)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(client, &hnae3_client_list, node)\n\t\t\thnae3_uninit_client_instance(client, ae_dev);\n\n\t\tae_algo->ops->uninit_ae_dev(ae_dev);\n\t\thnae3_set_bit(ae_dev->flag, HNAE3_DEV_INITED_B, 0);\n\t\tae_dev->ops = NULL;\n\t}\n\n\tlist_del(&ae_dev->node);\n\tmutex_unlock(&hnae3_common_lock);\n}\nEXPORT_SYMBOL(hnae3_unregister_ae_dev);\n\nMODULE_AUTHOR(\"Huawei Tech. Co., Ltd.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"HNAE3(Hisilicon Network Acceleration Engine) Framework\");\nMODULE_VERSION(HNAE3_MOD_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}