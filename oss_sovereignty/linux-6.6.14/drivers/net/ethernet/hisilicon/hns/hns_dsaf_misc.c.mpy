{
  "module_name": "hns_dsaf_misc.c",
  "hash_id": "7395f757cd2a9d76633a3e8f5c979ffc3c0aab87293263b449178d3dfcb6fcf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns/hns_dsaf_misc.c",
  "human_readable_source": "\n \n\n#include \"hns_dsaf_mac.h\"\n#include \"hns_dsaf_misc.h\"\n#include \"hns_dsaf_ppe.h\"\n#include \"hns_dsaf_reg.h\"\n\nenum _dsm_op_index {\n\tHNS_OP_RESET_FUNC               = 0x1,\n\tHNS_OP_SERDES_LP_FUNC           = 0x2,\n\tHNS_OP_LED_SET_FUNC             = 0x3,\n\tHNS_OP_GET_PORT_TYPE_FUNC       = 0x4,\n\tHNS_OP_GET_SFP_STAT_FUNC        = 0x5,\n\tHNS_OP_LOCATE_LED_SET_FUNC      = 0x6,\n};\n\nenum _dsm_rst_type {\n\tHNS_DSAF_RESET_FUNC     = 0x1,\n\tHNS_PPE_RESET_FUNC      = 0x2,\n\tHNS_XGE_RESET_FUNC      = 0x4,\n\tHNS_GE_RESET_FUNC       = 0x5,\n\tHNS_DSAF_CHN_RESET_FUNC = 0x6,\n\tHNS_ROCE_RESET_FUNC     = 0x7,\n};\n\nstatic const guid_t hns_dsaf_acpi_dsm_guid =\n\tGUID_INIT(0x1A85AA1A, 0xE293, 0x415E,\n\t\t  0x8E, 0x28, 0x8D, 0x69, 0x0A, 0x0F, 0x82, 0x0A);\n\nstatic void dsaf_write_sub(struct dsaf_device *dsaf_dev, u32 reg, u32 val)\n{\n\tif (dsaf_dev->sub_ctrl)\n\t\tdsaf_write_syscon(dsaf_dev->sub_ctrl, reg, val);\n\telse\n\t\tdsaf_write_reg(dsaf_dev->sc_base, reg, val);\n}\n\nstatic u32 dsaf_read_sub(struct dsaf_device *dsaf_dev, u32 reg)\n{\n\tu32 ret = 0;\n\tint err;\n\n\tif (dsaf_dev->sub_ctrl) {\n\t\terr = dsaf_read_syscon(dsaf_dev->sub_ctrl, reg, &ret);\n\t\tif (err)\n\t\t\tdev_err(dsaf_dev->dev, \"dsaf_read_syscon error %d!\\n\",\n\t\t\t\terr);\n\t} else {\n\t\tret = dsaf_read_reg(dsaf_dev->sc_base, reg);\n\t}\n\n\treturn ret;\n}\n\nstatic void hns_dsaf_acpi_ledctrl_by_port(struct hns_mac_cb *mac_cb, u8 op_type,\n\t\t\t\t\t  u32 link, u32 port, u32 act)\n{\n\tunion acpi_object *obj;\n\tunion acpi_object obj_args[3], argv4;\n\n\tobj_args[0].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[0].integer.value = link;\n\tobj_args[1].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[1].integer.value = port;\n\tobj_args[2].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[2].integer.value = act;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 3;\n\targv4.package.elements = obj_args;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(mac_cb->dev),\n\t\t\t\t&hns_dsaf_acpi_dsm_guid, 0, op_type, &argv4);\n\tif (!obj) {\n\t\tdev_warn(mac_cb->dev, \"ledctrl fail, link:%d port:%d act:%d!\\n\",\n\t\t\t link, port, act);\n\t\treturn;\n\t}\n\n\tACPI_FREE(obj);\n}\n\nstatic void hns_dsaf_acpi_locate_ledctrl_by_port(struct hns_mac_cb *mac_cb,\n\t\t\t\t\t\t u8 op_type, u32 locate,\n\t\t\t\t\t\t u32 port)\n{\n\tunion acpi_object obj_args[2], argv4;\n\tunion acpi_object *obj;\n\n\tobj_args[0].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[0].integer.value = locate;\n\tobj_args[1].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[1].integer.value = port;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 2;\n\targv4.package.elements = obj_args;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(mac_cb->dev),\n\t\t\t\t&hns_dsaf_acpi_dsm_guid, 0, op_type, &argv4);\n\tif (!obj) {\n\t\tdev_err(mac_cb->dev, \"ledctrl fail, locate:%d port:%d!\\n\",\n\t\t\tlocate, port);\n\t\treturn;\n\t}\n\n\tACPI_FREE(obj);\n}\n\nstatic void hns_cpld_set_led(struct hns_mac_cb *mac_cb, int link_status,\n\t\t\t     u16 speed, int data)\n{\n\tint speed_reg = 0;\n\tu8 value;\n\n\tif (!mac_cb) {\n\t\tpr_err(\"sfp_led_opt mac_dev is null!\\n\");\n\t\treturn;\n\t}\n\tif (!mac_cb->cpld_ctrl) {\n\t\tdev_err(mac_cb->dev, \"mac_id=%d, cpld syscon is null !\\n\",\n\t\t\tmac_cb->mac_id);\n\t\treturn;\n\t}\n\n\tif (speed == MAC_SPEED_10000)\n\t\tspeed_reg = 1;\n\n\tvalue = mac_cb->cpld_led_value;\n\n\tif (link_status) {\n\t\tdsaf_set_bit(value, DSAF_LED_LINK_B, link_status);\n\t\tdsaf_set_field(value, DSAF_LED_SPEED_M,\n\t\t\t       DSAF_LED_SPEED_S, speed_reg);\n\t\tdsaf_set_bit(value, DSAF_LED_DATA_B, data);\n\n\t\tif (value != mac_cb->cpld_led_value) {\n\t\t\tdsaf_write_syscon(mac_cb->cpld_ctrl,\n\t\t\t\t\t  mac_cb->cpld_ctrl_reg, value);\n\t\t\tmac_cb->cpld_led_value = value;\n\t\t}\n\t} else {\n\t\tvalue = (mac_cb->cpld_led_value) & (0x1 << DSAF_LED_ANCHOR_B);\n\t\tdsaf_write_syscon(mac_cb->cpld_ctrl,\n\t\t\t\t  mac_cb->cpld_ctrl_reg, value);\n\t\tmac_cb->cpld_led_value = value;\n\t}\n}\n\nstatic void hns_cpld_set_led_acpi(struct hns_mac_cb *mac_cb, int link_status,\n\t\t\t\t  u16 speed, int data)\n{\n\tif (!mac_cb) {\n\t\tpr_err(\"cpld_led_set mac_cb is null!\\n\");\n\t\treturn;\n\t}\n\n\thns_dsaf_acpi_ledctrl_by_port(mac_cb, HNS_OP_LED_SET_FUNC,\n\t\t\t\t      link_status, mac_cb->mac_id, data);\n}\n\nstatic void cpld_led_reset(struct hns_mac_cb *mac_cb)\n{\n\tif (!mac_cb || !mac_cb->cpld_ctrl)\n\t\treturn;\n\n\tdsaf_write_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg,\n\t\t\t  CPLD_LED_DEFAULT_VALUE);\n\tmac_cb->cpld_led_value = CPLD_LED_DEFAULT_VALUE;\n}\n\nstatic void cpld_led_reset_acpi(struct hns_mac_cb *mac_cb)\n{\n\tif (!mac_cb) {\n\t\tpr_err(\"cpld_led_reset mac_cb is null!\\n\");\n\t\treturn;\n\t}\n\n\tif (mac_cb->media_type != HNAE_MEDIA_TYPE_FIBER)\n\t\treturn;\n\n\thns_dsaf_acpi_ledctrl_by_port(mac_cb, HNS_OP_LED_SET_FUNC,\n\t\t\t\t      0, mac_cb->mac_id, 0);\n}\n\nstatic int cpld_set_led_id(struct hns_mac_cb *mac_cb,\n\t\t\t   enum hnae_led_state status)\n{\n\tu32 val = 0;\n\tint ret;\n\n\tif (!mac_cb->cpld_ctrl)\n\t\treturn 0;\n\n\tswitch (status) {\n\tcase HNAE_LED_ACTIVE:\n\t\tret = dsaf_read_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg,\n\t\t\t\t       &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdsaf_set_bit(val, DSAF_LED_ANCHOR_B, CPLD_LED_ON_VALUE);\n\t\tdsaf_write_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg,\n\t\t\t\t  val);\n\t\tmac_cb->cpld_led_value = val;\n\t\tbreak;\n\tcase HNAE_LED_INACTIVE:\n\t\tdsaf_set_bit(mac_cb->cpld_led_value, DSAF_LED_ANCHOR_B,\n\t\t\t     CPLD_LED_DEFAULT_VALUE);\n\t\tdsaf_write_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg,\n\t\t\t\t  mac_cb->cpld_led_value);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mac_cb->dev, \"invalid led state: %d!\", status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpld_set_led_id_acpi(struct hns_mac_cb *mac_cb,\n\t\t\t\tenum hnae_led_state status)\n{\n\tswitch (status) {\n\tcase HNAE_LED_ACTIVE:\n\t\thns_dsaf_acpi_locate_ledctrl_by_port(mac_cb,\n\t\t\t\t\t\t     HNS_OP_LOCATE_LED_SET_FUNC,\n\t\t\t\t\t\t     CPLD_LED_ON_VALUE,\n\t\t\t\t\t\t     mac_cb->mac_id);\n\t\tbreak;\n\tcase HNAE_LED_INACTIVE:\n\t\thns_dsaf_acpi_locate_ledctrl_by_port(mac_cb,\n\t\t\t\t\t\t     HNS_OP_LOCATE_LED_SET_FUNC,\n\t\t\t\t\t\t     CPLD_LED_DEFAULT_VALUE,\n\t\t\t\t\t\t     mac_cb->mac_id);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mac_cb->dev, \"invalid led state: %d!\", status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define RESET_REQ_OR_DREQ 1\n\nstatic void hns_dsaf_acpi_srst_by_port(struct dsaf_device *dsaf_dev, u8 op_type,\n\t\t\t\t       u32 port_type, u32 port, u32 val)\n{\n\tunion acpi_object *obj;\n\tunion acpi_object obj_args[3], argv4;\n\n\tobj_args[0].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[0].integer.value = port_type;\n\tobj_args[1].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[1].integer.value = port;\n\tobj_args[2].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[2].integer.value = val;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 3;\n\targv4.package.elements = obj_args;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(dsaf_dev->dev),\n\t\t\t\t&hns_dsaf_acpi_dsm_guid, 0, op_type, &argv4);\n\tif (!obj) {\n\t\tdev_warn(dsaf_dev->dev, \"reset port_type%d port%d fail!\",\n\t\t\t port_type, port);\n\t\treturn;\n\t}\n\n\tACPI_FREE(obj);\n}\n\nstatic void hns_dsaf_rst(struct dsaf_device *dsaf_dev, bool dereset)\n{\n\tu32 xbar_reg_addr;\n\tu32 nt_reg_addr;\n\n\tif (!dereset) {\n\t\txbar_reg_addr = DSAF_SUB_SC_XBAR_RESET_REQ_REG;\n\t\tnt_reg_addr = DSAF_SUB_SC_NT_RESET_REQ_REG;\n\t} else {\n\t\txbar_reg_addr = DSAF_SUB_SC_XBAR_RESET_DREQ_REG;\n\t\tnt_reg_addr = DSAF_SUB_SC_NT_RESET_DREQ_REG;\n\t}\n\n\tdsaf_write_sub(dsaf_dev, xbar_reg_addr, RESET_REQ_OR_DREQ);\n\tdsaf_write_sub(dsaf_dev, nt_reg_addr, RESET_REQ_OR_DREQ);\n}\n\nstatic void hns_dsaf_rst_acpi(struct dsaf_device *dsaf_dev, bool dereset)\n{\n\thns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\n\t\t\t\t   HNS_DSAF_RESET_FUNC,\n\t\t\t\t   0, dereset);\n}\n\nstatic void hns_dsaf_xge_srst_by_port(struct dsaf_device *dsaf_dev, u32 port,\n\t\t\t\t      bool dereset)\n{\n\tu32 reg_val = 0;\n\tu32 reg_addr;\n\n\tif (port >= DSAF_XGE_NUM)\n\t\treturn;\n\n\treg_val |= RESET_REQ_OR_DREQ;\n\treg_val |= 0x2082082 << dsaf_dev->mac_cb[port]->port_rst_off;\n\n\tif (!dereset)\n\t\treg_addr = DSAF_SUB_SC_XGE_RESET_REQ_REG;\n\telse\n\t\treg_addr = DSAF_SUB_SC_XGE_RESET_DREQ_REG;\n\n\tdsaf_write_sub(dsaf_dev, reg_addr, reg_val);\n}\n\nstatic void hns_dsaf_xge_srst_by_port_acpi(struct dsaf_device *dsaf_dev,\n\t\t\t\t\t   u32 port, bool dereset)\n{\n\thns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\n\t\t\t\t   HNS_XGE_RESET_FUNC, port, dereset);\n}\n\n \nstatic void\nhns_dsaf_srst_chns(struct dsaf_device *dsaf_dev, u32 msk, bool dereset)\n{\n\tu32 reg_addr;\n\n\tif (!dereset)\n\t\treg_addr = DSAF_SUB_SC_DSAF_RESET_REQ_REG;\n\telse\n\t\treg_addr = DSAF_SUB_SC_DSAF_RESET_DREQ_REG;\n\n\tdsaf_write_sub(dsaf_dev, reg_addr, msk);\n}\n\n \nstatic void\nhns_dsaf_srst_chns_acpi(struct dsaf_device *dsaf_dev, u32 msk, bool dereset)\n{\n\thns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\n\t\t\t\t   HNS_DSAF_CHN_RESET_FUNC,\n\t\t\t\t   msk, dereset);\n}\n\nstatic void hns_dsaf_roce_srst(struct dsaf_device *dsaf_dev, bool dereset)\n{\n\tif (!dereset) {\n\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_ROCEE_RESET_REQ_REG, 1);\n\t} else {\n\t\tdsaf_write_sub(dsaf_dev,\n\t\t\t       DSAF_SUB_SC_ROCEE_CLK_DIS_REG, 1);\n\t\tdsaf_write_sub(dsaf_dev,\n\t\t\t       DSAF_SUB_SC_ROCEE_RESET_DREQ_REG, 1);\n\t\tmsleep(20);\n\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_ROCEE_CLK_EN_REG, 1);\n\t}\n}\n\nstatic void hns_dsaf_roce_srst_acpi(struct dsaf_device *dsaf_dev, bool dereset)\n{\n\thns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\n\t\t\t\t   HNS_ROCE_RESET_FUNC, 0, dereset);\n}\n\nstatic void hns_dsaf_ge_srst_by_port(struct dsaf_device *dsaf_dev, u32 port,\n\t\t\t\t     bool dereset)\n{\n\tu32 reg_val_1;\n\tu32 reg_val_2;\n\tu32 port_rst_off;\n\n\tif (port >= DSAF_GE_NUM)\n\t\treturn;\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\n\t\t \n\t\tif (port >= DSAF_MAX_PORT_NUM)\n\t\t\treturn;\n\t\treg_val_1  = 0x1 << port;\n\t\tport_rst_off = dsaf_dev->mac_cb[port]->port_rst_off;\n\t\t \n\t\treg_val_2 = AE_IS_VER1(dsaf_dev->dsaf_ver) ?\n\t\t\t\t0x1041041 : 0x2082082;\n\t\treg_val_2 <<= port_rst_off;\n\n\t\tif (!dereset) {\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_REQ1_REG,\n\t\t\t\t       reg_val_1);\n\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_REQ0_REG,\n\t\t\t\t       reg_val_2);\n\t\t} else {\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_DREQ0_REG,\n\t\t\t\t       reg_val_2);\n\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_DREQ1_REG,\n\t\t\t\t       reg_val_1);\n\t\t}\n\t} else {\n\t\treg_val_1 = 0x15540;\n\t\treg_val_2 = AE_IS_VER1(dsaf_dev->dsaf_ver) ? 0x100 : 0x40;\n\n\t\treg_val_1 <<= dsaf_dev->reset_offset;\n\t\treg_val_2 <<= dsaf_dev->reset_offset;\n\n\t\tif (!dereset) {\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_REQ1_REG,\n\t\t\t\t       reg_val_1);\n\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_PPE_RESET_REQ_REG,\n\t\t\t\t       reg_val_2);\n\t\t} else {\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_DREQ1_REG,\n\t\t\t\t       reg_val_1);\n\n\t\t\tdsaf_write_sub(dsaf_dev, DSAF_SUB_SC_PPE_RESET_DREQ_REG,\n\t\t\t\t       reg_val_2);\n\t\t}\n\t}\n}\n\nstatic void hns_dsaf_ge_srst_by_port_acpi(struct dsaf_device *dsaf_dev,\n\t\t\t\t\t  u32 port, bool dereset)\n{\n\thns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\n\t\t\t\t   HNS_GE_RESET_FUNC, port, dereset);\n}\n\nstatic void hns_ppe_srst_by_port(struct dsaf_device *dsaf_dev, u32 port,\n\t\t\t\t bool dereset)\n{\n\tu32 reg_val = 0;\n\tu32 reg_addr;\n\n\treg_val |= RESET_REQ_OR_DREQ <<\tdsaf_dev->mac_cb[port]->port_rst_off;\n\n\tif (!dereset)\n\t\treg_addr = DSAF_SUB_SC_PPE_RESET_REQ_REG;\n\telse\n\t\treg_addr = DSAF_SUB_SC_PPE_RESET_DREQ_REG;\n\n\tdsaf_write_sub(dsaf_dev, reg_addr, reg_val);\n}\n\nstatic void\nhns_ppe_srst_by_port_acpi(struct dsaf_device *dsaf_dev, u32 port, bool dereset)\n{\n\thns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\n\t\t\t\t   HNS_PPE_RESET_FUNC, port, dereset);\n}\n\nstatic void hns_ppe_com_srst(struct dsaf_device *dsaf_dev, bool dereset)\n{\n\tu32 reg_val;\n\tu32 reg_addr;\n\n\tif (!(dev_of_node(dsaf_dev->dev)))\n\t\treturn;\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\n\t\treg_val = RESET_REQ_OR_DREQ;\n\t\tif (!dereset)\n\t\t\treg_addr = DSAF_SUB_SC_RCB_PPE_COM_RESET_REQ_REG;\n\t\telse\n\t\t\treg_addr = DSAF_SUB_SC_RCB_PPE_COM_RESET_DREQ_REG;\n\n\t} else {\n\t\treg_val = 0x100 << dsaf_dev->reset_offset;\n\n\t\tif (!dereset)\n\t\t\treg_addr = DSAF_SUB_SC_PPE_RESET_REQ_REG;\n\t\telse\n\t\t\treg_addr = DSAF_SUB_SC_PPE_RESET_DREQ_REG;\n\t}\n\n\tdsaf_write_sub(dsaf_dev, reg_addr, reg_val);\n}\n\n \nstatic phy_interface_t hns_mac_get_phy_if(struct hns_mac_cb *mac_cb)\n{\n\tu32 mode;\n\tu32 reg;\n\tbool is_ver1 = AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver);\n\tint mac_id = mac_cb->mac_id;\n\tphy_interface_t phy_if;\n\n\tif (is_ver1) {\n\t\tif (HNS_DSAF_IS_DEBUG(mac_cb->dsaf_dev))\n\t\t\treturn PHY_INTERFACE_MODE_SGMII;\n\n\t\tif (mac_id >= 0 && mac_id <= 3)\n\t\t\treg = HNS_MAC_HILINK4_REG;\n\t\telse\n\t\t\treg = HNS_MAC_HILINK3_REG;\n\t} else {\n\t\tif (!HNS_DSAF_IS_DEBUG(mac_cb->dsaf_dev) && mac_id <= 3)\n\t\t\treg = HNS_MAC_HILINK4V2_REG;\n\t\telse\n\t\t\treg = HNS_MAC_HILINK3V2_REG;\n\t}\n\n\tmode = dsaf_read_sub(mac_cb->dsaf_dev, reg);\n\tif (dsaf_get_bit(mode, mac_cb->port_mode_off))\n\t\tphy_if = PHY_INTERFACE_MODE_XGMII;\n\telse\n\t\tphy_if = PHY_INTERFACE_MODE_SGMII;\n\n\treturn phy_if;\n}\n\nstatic phy_interface_t hns_mac_get_phy_if_acpi(struct hns_mac_cb *mac_cb)\n{\n\tphy_interface_t phy_if = PHY_INTERFACE_MODE_NA;\n\tunion acpi_object *obj;\n\tunion acpi_object obj_args, argv4;\n\n\tobj_args.integer.type = ACPI_TYPE_INTEGER;\n\tobj_args.integer.value = mac_cb->mac_id;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 1;\n\targv4.package.elements = &obj_args;\n\n\tobj = acpi_evaluate_dsm_typed(ACPI_HANDLE(mac_cb->dev),\n\t\t\t\t      &hns_dsaf_acpi_dsm_guid, 0,\n\t\t\t\t      HNS_OP_GET_PORT_TYPE_FUNC, &argv4,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\tif (!obj)\n\t\treturn phy_if;\n\n\tphy_if = obj->integer.value ?\n\t\tPHY_INTERFACE_MODE_XGMII : PHY_INTERFACE_MODE_SGMII;\n\n\tdev_dbg(mac_cb->dev, \"mac_id=%d, phy_if=%d\\n\", mac_cb->mac_id, phy_if);\n\n\tACPI_FREE(obj);\n\n\treturn phy_if;\n}\n\nstatic int hns_mac_get_sfp_prsnt(struct hns_mac_cb *mac_cb, int *sfp_prsnt)\n{\n\tu32 val = 0;\n\tint ret;\n\n\tif (!mac_cb->cpld_ctrl)\n\t\treturn -ENODEV;\n\n\tret = dsaf_read_syscon(mac_cb->cpld_ctrl,\n\t\t\t       mac_cb->cpld_ctrl_reg + MAC_SFP_PORT_OFFSET,\n\t\t\t       &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*sfp_prsnt = !val;\n\treturn 0;\n}\n\nstatic int hns_mac_get_sfp_prsnt_acpi(struct hns_mac_cb *mac_cb, int *sfp_prsnt)\n{\n\tunion acpi_object *obj;\n\tunion acpi_object obj_args, argv4;\n\n\tobj_args.integer.type = ACPI_TYPE_INTEGER;\n\tobj_args.integer.value = mac_cb->mac_id;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 1;\n\targv4.package.elements = &obj_args;\n\n\tobj = acpi_evaluate_dsm_typed(ACPI_HANDLE(mac_cb->dev),\n\t\t\t\t      &hns_dsaf_acpi_dsm_guid, 0,\n\t\t\t\t      HNS_OP_GET_SFP_STAT_FUNC, &argv4,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\tif (!obj)\n\t\treturn -ENODEV;\n\n\t*sfp_prsnt = obj->integer.value;\n\n\tACPI_FREE(obj);\n\n\treturn 0;\n}\n\n \nstatic int hns_mac_config_sds_loopback(struct hns_mac_cb *mac_cb, bool en)\n{\n\tconst u8 lane_id[] = {\n\t\t0,\t \n\t\t1,\t \n\t\t2,\t \n\t\t3,\t \n\t\t2,\t \n\t\t3,\t \n\t\t0,\t \n\t\t1\t \n\t};\n#define RX_CSR(lane, reg) ((0x4080 + (reg) * 0x0002 + (lane) * 0x0200) * 2)\n\tu64 reg_offset = RX_CSR(lane_id[mac_cb->mac_id], 0);\n\n\tint sfp_prsnt = 0;\n\tint ret = hns_mac_get_sfp_prsnt(mac_cb, &sfp_prsnt);\n\n\tif (!mac_cb->phy_dev) {\n\t\tif (ret)\n\t\t\tpr_info(\"please confirm sfp is present or not\\n\");\n\t\telse\n\t\t\tif (!sfp_prsnt)\n\t\t\t\tpr_info(\"no sfp in this eth\\n\");\n\t}\n\n\tif (mac_cb->serdes_ctrl) {\n\t\tu32 origin = 0;\n\n\t\tif (!AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver)) {\n#define HILINK_ACCESS_SEL_CFG\t\t0x40008\n\t\t\t \n\t\t\tif ((!HNS_DSAF_IS_DEBUG(mac_cb->dsaf_dev)) &&\n\t\t\t    (mac_cb->mac_id <= 3))\n\t\t\t\tdsaf_write_syscon(mac_cb->serdes_ctrl,\n\t\t\t\t\t\t  HILINK_ACCESS_SEL_CFG, 0);\n\t\t\telse\n\t\t\t\tdsaf_write_syscon(mac_cb->serdes_ctrl,\n\t\t\t\t\t\t  HILINK_ACCESS_SEL_CFG, 3);\n\t\t}\n\n\t\tret = dsaf_read_syscon(mac_cb->serdes_ctrl, reg_offset,\n\t\t\t\t       &origin);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdsaf_set_field(origin, 1ull << 10, 10, en);\n\t\tdsaf_write_syscon(mac_cb->serdes_ctrl, reg_offset, origin);\n\t} else {\n\t\tu8 __iomem *base_addr = mac_cb->serdes_vaddr +\n\t\t\t\t(mac_cb->mac_id <= 3 ? 0x00280000 : 0x00200000);\n\t\tdsaf_set_reg_field(base_addr, reg_offset, 1ull << 10, 10, en);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhns_mac_config_sds_loopback_acpi(struct hns_mac_cb *mac_cb, bool en)\n{\n\tunion acpi_object *obj;\n\tunion acpi_object obj_args[3], argv4;\n\n\tobj_args[0].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[0].integer.value = mac_cb->mac_id;\n\tobj_args[1].integer.type = ACPI_TYPE_INTEGER;\n\tobj_args[1].integer.value = en;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 2;\n\targv4.package.elements = obj_args;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(mac_cb->dsaf_dev->dev),\n\t\t\t\t&hns_dsaf_acpi_dsm_guid, 0,\n\t\t\t\tHNS_OP_SERDES_LP_FUNC, &argv4);\n\tif (!obj) {\n\t\tdev_warn(mac_cb->dsaf_dev->dev, \"set port%d serdes lp fail!\",\n\t\t\t mac_cb->mac_id);\n\n\t\treturn -ENOTSUPP;\n\t}\n\n\tACPI_FREE(obj);\n\n\treturn 0;\n}\n\nstruct dsaf_misc_op *hns_misc_op_get(struct dsaf_device *dsaf_dev)\n{\n\tstruct dsaf_misc_op *misc_op;\n\n\tmisc_op = devm_kzalloc(dsaf_dev->dev, sizeof(*misc_op), GFP_KERNEL);\n\tif (!misc_op)\n\t\treturn NULL;\n\n\tif (dev_of_node(dsaf_dev->dev)) {\n\t\tmisc_op->cpld_set_led = hns_cpld_set_led;\n\t\tmisc_op->cpld_reset_led = cpld_led_reset;\n\t\tmisc_op->cpld_set_led_id = cpld_set_led_id;\n\n\t\tmisc_op->dsaf_reset = hns_dsaf_rst;\n\t\tmisc_op->xge_srst = hns_dsaf_xge_srst_by_port;\n\t\tmisc_op->ge_srst = hns_dsaf_ge_srst_by_port;\n\t\tmisc_op->ppe_srst = hns_ppe_srst_by_port;\n\t\tmisc_op->ppe_comm_srst = hns_ppe_com_srst;\n\t\tmisc_op->hns_dsaf_srst_chns = hns_dsaf_srst_chns;\n\t\tmisc_op->hns_dsaf_roce_srst = hns_dsaf_roce_srst;\n\n\t\tmisc_op->get_phy_if = hns_mac_get_phy_if;\n\t\tmisc_op->get_sfp_prsnt = hns_mac_get_sfp_prsnt;\n\n\t\tmisc_op->cfg_serdes_loopback = hns_mac_config_sds_loopback;\n\t} else if (is_acpi_node(dsaf_dev->dev->fwnode)) {\n\t\tmisc_op->cpld_set_led = hns_cpld_set_led_acpi;\n\t\tmisc_op->cpld_reset_led = cpld_led_reset_acpi;\n\t\tmisc_op->cpld_set_led_id = cpld_set_led_id_acpi;\n\n\t\tmisc_op->dsaf_reset = hns_dsaf_rst_acpi;\n\t\tmisc_op->xge_srst = hns_dsaf_xge_srst_by_port_acpi;\n\t\tmisc_op->ge_srst = hns_dsaf_ge_srst_by_port_acpi;\n\t\tmisc_op->ppe_srst = hns_ppe_srst_by_port_acpi;\n\t\tmisc_op->ppe_comm_srst = hns_ppe_com_srst;\n\t\tmisc_op->hns_dsaf_srst_chns = hns_dsaf_srst_chns_acpi;\n\t\tmisc_op->hns_dsaf_roce_srst = hns_dsaf_roce_srst_acpi;\n\n\t\tmisc_op->get_phy_if = hns_mac_get_phy_if_acpi;\n\t\tmisc_op->get_sfp_prsnt = hns_mac_get_sfp_prsnt_acpi;\n\n\t\tmisc_op->cfg_serdes_loopback = hns_mac_config_sds_loopback_acpi;\n\t} else {\n\t\tdevm_kfree(dsaf_dev->dev, (void *)misc_op);\n\t\tmisc_op = NULL;\n\t}\n\n\treturn (void *)misc_op;\n}\n\nstruct\nplatform_device *hns_dsaf_find_platform_device(struct fwnode_handle *fwnode)\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device_by_fwnode(&platform_bus_type, fwnode);\n\treturn dev ? to_platform_device(dev) : NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}