{
  "module_name": "hnae.c",
  "hash_id": "726c4844fed4a8aac3b0e21f2d0c920034429bb43da6565034ef01bed81f3956",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns/hnae.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include \"hnae.h\"\n\n#define cls_to_ae_dev(dev) container_of(dev, struct hnae_ae_dev, cls_dev)\n\nstatic struct class *hnae_class;\n\nstatic void\nhnae_list_add(spinlock_t *lock, struct list_head *node, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lock, flags);\n\tlist_add_tail_rcu(node, head);\n\tspin_unlock_irqrestore(lock, flags);\n}\n\nstatic void hnae_list_del(spinlock_t *lock, struct list_head *node)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lock, flags);\n\tlist_del_rcu(node);\n\tspin_unlock_irqrestore(lock, flags);\n}\n\nstatic int hnae_alloc_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\n{\n\tunsigned int order = hnae_page_order(ring);\n\tstruct page *p = dev_alloc_pages(order);\n\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tcb->priv = p;\n\tcb->page_offset = 0;\n\tcb->reuse_flag = 0;\n\tcb->buf  = page_address(p);\n\tcb->length = hnae_page_size(ring);\n\tcb->type = DESC_TYPE_PAGE;\n\n\treturn 0;\n}\n\nstatic void hnae_free_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\n{\n\tif (unlikely(!cb->priv))\n\t\treturn;\n\n\tif (cb->type == DESC_TYPE_SKB)\n\t\tdev_kfree_skb_any((struct sk_buff *)cb->priv);\n\telse if (unlikely(is_rx_ring(ring)))\n\t\tput_page((struct page *)cb->priv);\n\n\tcb->priv = NULL;\n}\n\nstatic int hnae_map_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\n{\n\tcb->dma = dma_map_page(ring_to_dev(ring), cb->priv, 0,\n\t\t\t       cb->length, ring_to_dma_dir(ring));\n\n\tif (dma_mapping_error(ring_to_dev(ring), cb->dma))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void hnae_unmap_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\n{\n\tif (cb->type == DESC_TYPE_SKB)\n\t\tdma_unmap_single(ring_to_dev(ring), cb->dma, cb->length,\n\t\t\t\t ring_to_dma_dir(ring));\n\telse if (cb->length)\n\t\tdma_unmap_page(ring_to_dev(ring), cb->dma, cb->length,\n\t\t\t       ring_to_dma_dir(ring));\n}\n\nstatic struct hnae_buf_ops hnae_bops = {\n\t.alloc_buffer = hnae_alloc_buffer,\n\t.free_buffer = hnae_free_buffer,\n\t.map_buffer = hnae_map_buffer,\n\t.unmap_buffer = hnae_unmap_buffer,\n};\n\nstatic int __ae_match(struct device *dev, const void *data)\n{\n\tstruct hnae_ae_dev *hdev = cls_to_ae_dev(dev);\n\n\tif (dev_of_node(hdev->dev))\n\t\treturn (data == &hdev->dev->of_node->fwnode);\n\telse if (is_acpi_node(hdev->dev->fwnode))\n\t\treturn (data == hdev->dev->fwnode);\n\n\tdev_err(dev, \"__ae_match cannot read cfg data from OF or acpi\\n\");\n\treturn 0;\n}\n\nstatic struct hnae_ae_dev *find_ae(const struct fwnode_handle *fwnode)\n{\n\tstruct device *dev;\n\n\tWARN_ON(!fwnode);\n\n\tdev = class_find_device(hnae_class, NULL, fwnode, __ae_match);\n\n\treturn dev ? cls_to_ae_dev(dev) : NULL;\n}\n\nstatic void hnae_free_buffers(struct hnae_ring *ring)\n{\n\tint i;\n\n\tfor (i = 0; i < ring->desc_num; i++)\n\t\thnae_free_buffer_detach(ring, i);\n}\n\n \nstatic int hnae_alloc_buffers(struct hnae_ring *ring)\n{\n\tint i, j, ret;\n\n\tfor (i = 0; i < ring->desc_num; i++) {\n\t\tret = hnae_alloc_buffer_attach(ring, i);\n\t\tif (ret)\n\t\t\tgoto out_buffer_fail;\n\t}\n\n\treturn 0;\n\nout_buffer_fail:\n\tfor (j = i - 1; j >= 0; j--)\n\t\thnae_free_buffer_detach(ring, j);\n\treturn ret;\n}\n\n \nstatic void hnae_free_desc(struct hnae_ring *ring)\n{\n\tdma_unmap_single(ring_to_dev(ring), ring->desc_dma_addr,\n\t\t\t ring->desc_num * sizeof(ring->desc[0]),\n\t\t\t ring_to_dma_dir(ring));\n\tring->desc_dma_addr = 0;\n\tkfree(ring->desc);\n\tring->desc = NULL;\n}\n\n \nstatic int hnae_alloc_desc(struct hnae_ring *ring)\n{\n\tint size = ring->desc_num * sizeof(ring->desc[0]);\n\n\tring->desc = kzalloc(size, GFP_KERNEL);\n\tif (!ring->desc)\n\t\treturn -ENOMEM;\n\n\tring->desc_dma_addr = dma_map_single(ring_to_dev(ring),\n\t\tring->desc, size, ring_to_dma_dir(ring));\n\tif (dma_mapping_error(ring_to_dev(ring), ring->desc_dma_addr)) {\n\t\tring->desc_dma_addr = 0;\n\t\tkfree(ring->desc);\n\t\tring->desc = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hnae_fini_ring(struct hnae_ring *ring)\n{\n\tif (is_rx_ring(ring))\n\t\thnae_free_buffers(ring);\n\n\thnae_free_desc(ring);\n\tkfree(ring->desc_cb);\n\tring->desc_cb = NULL;\n\tring->next_to_clean = 0;\n\tring->next_to_use = 0;\n}\n\n \nstatic int\nhnae_init_ring(struct hnae_queue *q, struct hnae_ring *ring, int flags)\n{\n\tint ret;\n\n\tif (ring->desc_num <= 0 || ring->buf_size <= 0)\n\t\treturn -EINVAL;\n\n\tring->q = q;\n\tring->flags = flags;\n\tring->coal_param = q->handle->coal_param;\n\tassert(!ring->desc && !ring->desc_cb && !ring->desc_dma_addr);\n\n\t \n\tassert(ring->next_to_use == 0);\n\tassert(ring->next_to_clean == 0);\n\n\tring->desc_cb = kcalloc(ring->desc_num, sizeof(ring->desc_cb[0]),\n\t\t\tGFP_KERNEL);\n\tif (!ring->desc_cb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = hnae_alloc_desc(ring);\n\tif (ret)\n\t\tgoto out_with_desc_cb;\n\n\tif (is_rx_ring(ring)) {\n\t\tret = hnae_alloc_buffers(ring);\n\t\tif (ret)\n\t\t\tgoto out_with_desc;\n\t}\n\n\treturn 0;\n\nout_with_desc:\n\thnae_free_desc(ring);\nout_with_desc_cb:\n\tkfree(ring->desc_cb);\n\tring->desc_cb = NULL;\nout:\n\treturn ret;\n}\n\nstatic int hnae_init_queue(struct hnae_handle *h, struct hnae_queue *q,\n\t\t\t   struct hnae_ae_dev *dev)\n{\n\tint ret;\n\n\tq->dev = dev;\n\tq->handle = h;\n\n\tret = hnae_init_ring(q, &q->tx_ring, q->tx_ring.flags | RINGF_DIR);\n\tif (ret)\n\t\tgoto out;\n\n\tret = hnae_init_ring(q, &q->rx_ring, q->rx_ring.flags & ~RINGF_DIR);\n\tif (ret)\n\t\tgoto out_with_tx_ring;\n\n\tif (dev->ops->init_queue)\n\t\tdev->ops->init_queue(q);\n\n\treturn 0;\n\nout_with_tx_ring:\n\thnae_fini_ring(&q->tx_ring);\nout:\n\treturn ret;\n}\n\nstatic void hnae_fini_queue(struct hnae_queue *q)\n{\n\tif (q->dev->ops->fini_queue)\n\t\tq->dev->ops->fini_queue(q);\n\n\thnae_fini_ring(&q->tx_ring);\n\thnae_fini_ring(&q->rx_ring);\n}\n\n \nstatic RAW_NOTIFIER_HEAD(ae_chain);\n\nint hnae_register_notifier(struct notifier_block *nb)\n{\n\treturn raw_notifier_chain_register(&ae_chain, nb);\n}\nEXPORT_SYMBOL(hnae_register_notifier);\n\nvoid hnae_unregister_notifier(struct notifier_block *nb)\n{\n\tif (raw_notifier_chain_unregister(&ae_chain, nb))\n\t\tdev_err(NULL, \"notifier chain unregister fail\\n\");\n}\nEXPORT_SYMBOL(hnae_unregister_notifier);\n\nint hnae_reinit_handle(struct hnae_handle *handle)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = 0; i < handle->q_num; i++)  \n\t\thnae_fini_queue(handle->qs[i]);\n\n\tif (handle->dev->ops->reset)\n\t\thandle->dev->ops->reset(handle);\n\n\tfor (i = 0; i < handle->q_num; i++) { \n\t\tret = hnae_init_queue(handle, handle->qs[i], handle->dev);\n\t\tif (ret)\n\t\t\tgoto out_when_init_queue;\n\t}\n\treturn 0;\nout_when_init_queue:\n\tfor (j = i - 1; j >= 0; j--)\n\t\thnae_fini_queue(handle->qs[j]);\n\treturn ret;\n}\nEXPORT_SYMBOL(hnae_reinit_handle);\n\n \nstruct hnae_handle *hnae_get_handle(struct device *owner_dev,\n\t\t\t\t    const struct fwnode_handle\t*fwnode,\n\t\t\t\t    u32 port_id,\n\t\t\t\t    struct hnae_buf_ops *bops)\n{\n\tstruct hnae_ae_dev *dev;\n\tstruct hnae_handle *handle;\n\tint i, j;\n\tint ret;\n\n\tdev = find_ae(fwnode);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\thandle = dev->ops->get_handle(dev, port_id);\n\tif (IS_ERR(handle)) {\n\t\tput_device(&dev->cls_dev);\n\t\treturn handle;\n\t}\n\n\thandle->dev = dev;\n\thandle->owner_dev = owner_dev;\n\thandle->bops = bops ? bops : &hnae_bops;\n\thandle->eport_id = port_id;\n\n\tfor (i = 0; i < handle->q_num; i++) {\n\t\tret = hnae_init_queue(handle, handle->qs[i], dev);\n\t\tif (ret)\n\t\t\tgoto out_when_init_queue;\n\t}\n\n\t__module_get(dev->owner);\n\n\thnae_list_add(&dev->lock, &handle->node, &dev->handle_list);\n\n\treturn handle;\n\nout_when_init_queue:\n\tfor (j = i - 1; j >= 0; j--)\n\t\thnae_fini_queue(handle->qs[j]);\n\n\tput_device(&dev->cls_dev);\n\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL(hnae_get_handle);\n\nvoid hnae_put_handle(struct hnae_handle *h)\n{\n\tstruct hnae_ae_dev *dev = h->dev;\n\tint i;\n\n\tfor (i = 0; i < h->q_num; i++)\n\t\thnae_fini_queue(h->qs[i]);\n\n\tif (h->dev->ops->reset)\n\t\th->dev->ops->reset(h);\n\n\thnae_list_del(&dev->lock, &h->node);\n\n\tif (dev->ops->put_handle)\n\t\tdev->ops->put_handle(h);\n\n\tmodule_put(dev->owner);\n\n\tput_device(&dev->cls_dev);\n}\nEXPORT_SYMBOL(hnae_put_handle);\n\nstatic void hnae_release(struct device *dev)\n{\n}\n\n \nint hnae_ae_register(struct hnae_ae_dev *hdev, struct module *owner)\n{\n\tstatic atomic_t id = ATOMIC_INIT(-1);\n\tint ret;\n\n\tif (!hdev->dev)\n\t\treturn -ENODEV;\n\n\tif (!hdev->ops || !hdev->ops->get_handle ||\n\t    !hdev->ops->toggle_ring_irq ||\n\t    !hdev->ops->get_status || !hdev->ops->adjust_link)\n\t\treturn -EINVAL;\n\n\thdev->owner = owner;\n\thdev->id = (int)atomic_inc_return(&id);\n\thdev->cls_dev.parent = hdev->dev;\n\thdev->cls_dev.class = hnae_class;\n\thdev->cls_dev.release = hnae_release;\n\t(void)dev_set_name(&hdev->cls_dev, \"hnae%d\", hdev->id);\n\tret = device_register(&hdev->cls_dev);\n\tif (ret) {\n\t\tput_device(&hdev->cls_dev);\n\t\treturn ret;\n\t}\n\n\tINIT_LIST_HEAD(&hdev->handle_list);\n\tspin_lock_init(&hdev->lock);\n\n\tret = raw_notifier_call_chain(&ae_chain, HNAE_AE_REGISTER, NULL);\n\tif (ret)\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"has not notifier for AE: %s\\n\", hdev->name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hnae_ae_register);\n\n \nvoid hnae_ae_unregister(struct hnae_ae_dev *hdev)\n{\n\tdevice_unregister(&hdev->cls_dev);\n}\nEXPORT_SYMBOL(hnae_ae_unregister);\n\nstatic int __init hnae_init(void)\n{\n\thnae_class = class_create(\"hnae\");\n\treturn PTR_ERR_OR_ZERO(hnae_class);\n}\n\nstatic void __exit hnae_exit(void)\n{\n\tclass_destroy(hnae_class);\n}\n\nsubsys_initcall(hnae_init);\nmodule_exit(hnae_exit);\n\nMODULE_AUTHOR(\"Hisilicon, Inc.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Hisilicon Network Acceleration Engine Framework\");\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}