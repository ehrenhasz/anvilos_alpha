{
  "module_name": "hnae.h",
  "hash_id": "e239d4c844c8b8aa27df49091192fcd06519c36cd5897d17781fe823879eeed0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns/hnae.h",
  "human_readable_source": " \n \n\n#ifndef __HNAE_H\n#define __HNAE_H\n\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/phy.h>\n#include <linux/types.h>\n\n#define HNAE_DRIVER_VERSION \"2.0\"\n#define HNAE_DRIVER_NAME \"hns\"\n#define HNAE_COPYRIGHT \"Copyright(c) 2015 Huawei Corporation.\"\n#define HNAE_DRIVER_STRING \"Hisilicon Network Subsystem Driver\"\n#define HNAE_DEFAULT_DEVICE_DESCR \"Hisilicon Network Subsystem\"\n\n#ifdef DEBUG\n\n#ifndef assert\n#define assert(expr) \\\ndo { \\\n\tif (!(expr)) { \\\n\t\tpr_err(\"Assertion failed! %s, %s, %s, line %d\\n\", \\\n\t\t\t   #expr, __FILE__, __func__, __LINE__); \\\n\t} \\\n} while (0)\n#endif\n\n#else\n\n#ifndef assert\n#define assert(expr)\n#endif\n\n#endif\n\n#define AE_VERSION_1 ('6' << 16 | '6' << 8 | '0')\n#define AE_VERSION_2 ('1' << 24 | '6' << 16 | '1' << 8 | '0')\n#define AE_IS_VER1(ver) ((ver) == AE_VERSION_1)\n#define AE_NAME_SIZE 16\n\n#define BD_SIZE_2048_MAX_MTU   6000\n\n \n#define RCB_REG_BASEADDR_L         0x00  \n#define RCB_REG_BASEADDR_H         0x04\n#define RCB_REG_BD_NUM             0x08\n#define RCB_REG_BD_LEN             0x0C\n#define RCB_REG_PKTLINE            0x10\n#define RCB_REG_TAIL               0x18\n#define RCB_REG_HEAD               0x1C\n#define RCB_REG_FBDNUM             0x20\n#define RCB_REG_OFFSET             0x24  \n#define RCB_REG_PKTNUM_RECORD      0x2C  \n\n#define HNS_RX_HEAD_SIZE 256\n\n#define HNAE_AE_REGISTER 0x1\n\n#define RCB_RING_NAME_LEN (IFNAMSIZ + 4)\n\n#define HNAE_LOWEST_LATENCY_COAL_PARAM\t30\n#define HNAE_LOW_LATENCY_COAL_PARAM\t80\n#define HNAE_BULK_LATENCY_COAL_PARAM\t150\n\nenum hnae_led_state {\n\tHNAE_LED_INACTIVE,\n\tHNAE_LED_ACTIVE,\n\tHNAE_LED_ON,\n\tHNAE_LED_OFF\n};\n\n#define HNS_RX_FLAG_VLAN_PRESENT 0x1\n#define HNS_RX_FLAG_L3ID_IPV4 0x0\n#define HNS_RX_FLAG_L3ID_IPV6 0x1\n#define HNS_RX_FLAG_L4ID_UDP 0x0\n#define HNS_RX_FLAG_L4ID_TCP 0x1\n#define HNS_RX_FLAG_L4ID_SCTP 0x3\n\n#define HNS_TXD_ASID_S 0\n#define HNS_TXD_ASID_M (0xff << HNS_TXD_ASID_S)\n#define HNS_TXD_BUFNUM_S 8\n#define HNS_TXD_BUFNUM_M (0x3 << HNS_TXD_BUFNUM_S)\n#define HNS_TXD_PORTID_S 10\n#define HNS_TXD_PORTID_M (0x7 << HNS_TXD_PORTID_S)\n\n#define HNS_TXD_RA_B 8\n#define HNS_TXD_RI_B 9\n#define HNS_TXD_L4CS_B 10\n#define HNS_TXD_L3CS_B 11\n#define HNS_TXD_FE_B 12\n#define HNS_TXD_VLD_B 13\n#define HNS_TXD_IPOFFSET_S 14\n#define HNS_TXD_IPOFFSET_M (0xff << HNS_TXD_IPOFFSET_S)\n\n#define HNS_RXD_IPOFFSET_S 0\n#define HNS_RXD_IPOFFSET_M (0xff << HNS_TXD_IPOFFSET_S)\n#define HNS_RXD_BUFNUM_S 8\n#define HNS_RXD_BUFNUM_M (0x3 << HNS_RXD_BUFNUM_S)\n#define HNS_RXD_PORTID_S 10\n#define HNS_RXD_PORTID_M (0x7 << HNS_RXD_PORTID_S)\n#define HNS_RXD_DMAC_S 13\n#define HNS_RXD_DMAC_M (0x3 << HNS_RXD_DMAC_S)\n#define HNS_RXD_VLAN_S 15\n#define HNS_RXD_VLAN_M (0x3 << HNS_RXD_VLAN_S)\n#define HNS_RXD_L3ID_S 17\n#define HNS_RXD_L3ID_M (0xf << HNS_RXD_L3ID_S)\n#define HNS_RXD_L4ID_S 21\n#define HNS_RXD_L4ID_M (0xf << HNS_RXD_L4ID_S)\n#define HNS_RXD_FE_B 25\n#define HNS_RXD_FRAG_B 26\n#define HNS_RXD_VLD_B 27\n#define HNS_RXD_L2E_B 28\n#define HNS_RXD_L3E_B 29\n#define HNS_RXD_L4E_B 30\n#define HNS_RXD_DROP_B 31\n\n#define HNS_RXD_VLANID_S 8\n#define HNS_RXD_VLANID_M (0xfff << HNS_RXD_VLANID_S)\n#define HNS_RXD_CFI_B 20\n#define HNS_RXD_PRI_S 21\n#define HNS_RXD_PRI_M (0x7 << HNS_RXD_PRI_S)\n#define HNS_RXD_ASID_S 24\n#define HNS_RXD_ASID_M (0xff << HNS_RXD_ASID_S)\n\n#define HNSV2_TXD_BUFNUM_S 0\n#define HNSV2_TXD_BUFNUM_M (0x7 << HNSV2_TXD_BUFNUM_S)\n#define HNSV2_TXD_PORTID_S\t4\n#define HNSV2_TXD_PORTID_M\t(0X7 << HNSV2_TXD_PORTID_S)\n#define HNSV2_TXD_RI_B   1\n#define HNSV2_TXD_L4CS_B   2\n#define HNSV2_TXD_L3CS_B   3\n#define HNSV2_TXD_FE_B   4\n#define HNSV2_TXD_VLD_B  5\n\n#define HNSV2_TXD_TSE_B   0\n#define HNSV2_TXD_VLAN_EN_B   1\n#define HNSV2_TXD_SNAP_B   2\n#define HNSV2_TXD_IPV6_B   3\n#define HNSV2_TXD_SCTP_B   4\n\n \nstruct __packed hnae_desc {\n\t__le64 addr;\n\tunion {\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\t__le16 asid_bufnum_pid;\n\t\t\t\t__le16 asid;\n\t\t\t};\n\t\t\t__le16 send_size;\n\t\t\tunion {\n\t\t\t\t__le32 flag_ipoffset;\n\t\t\t\tstruct {\n\t\t\t\t\t__u8 bn_pid;\n\t\t\t\t\t__u8 ra_ri_cs_fe_vld;\n\t\t\t\t\t__u8 ip_offset;\n\t\t\t\t\t__u8 tse_vlan_snap_v6_sctp_nth;\n\t\t\t\t};\n\t\t\t};\n\t\t\t__le16 mss;\n\t\t\t__u8 l4_len;\n\t\t\t__u8 reserved1;\n\t\t\t__le16 paylen;\n\t\t\t__u8 vmid;\n\t\t\t__u8 qid;\n\t\t\t__le32 reserved2[2];\n\t\t} tx;\n\n\t\tstruct {\n\t\t\t__le32 ipoff_bnum_pid_flag;\n\t\t\t__le16 pkt_len;\n\t\t\t__le16 size;\n\t\t\tunion {\n\t\t\t\t__le32 vlan_pri_asid;\n\t\t\t\tstruct {\n\t\t\t\t\t__le16 asid;\n\t\t\t\t\t__le16 vlan_cfi_pri;\n\t\t\t\t};\n\t\t\t};\n\t\t\t__le32 rss_hash;\n\t\t\t__le32 reserved_1[2];\n\t\t} rx;\n\t};\n};\n\nstruct hnae_desc_cb {\n\tdma_addr_t dma;  \n\tvoid *buf;       \n\n\t \n\tvoid *priv;\n\tu32 page_offset;\n\tu32 length;      \n\n\tu16 reuse_flag;\n\n        \n\tu16 type;\n};\n\n#define setflags(flags, bits) ((flags) |= (bits))\n#define unsetflags(flags, bits) ((flags) &= ~(bits))\n\n \n#define RINGF_DIR 0x1\t     \n#define is_tx_ring(ring) ((ring)->flags & RINGF_DIR)\n#define is_rx_ring(ring) (!is_tx_ring(ring))\n#define ring_to_dma_dir(ring) (is_tx_ring(ring) ? \\\n\tDMA_TO_DEVICE : DMA_FROM_DEVICE)\n\nstruct ring_stats {\n\tu64 io_err_cnt;\n\tu64 sw_err_cnt;\n\tu64 seg_pkt_cnt;\n\tunion {\n\t\tstruct {\n\t\t\tu64 tx_pkts;\n\t\t\tu64 tx_bytes;\n\t\t\tu64 tx_err_cnt;\n\t\t\tu64 restart_queue;\n\t\t\tu64 tx_busy;\n\t\t};\n\t\tstruct {\n\t\t\tu64 rx_pkts;\n\t\t\tu64 rx_bytes;\n\t\t\tu64 rx_err_cnt;\n\t\t\tu64 reuse_pg_cnt;\n\t\t\tu64 err_pkt_len;\n\t\t\tu64 non_vld_descs;\n\t\t\tu64 err_bd_num;\n\t\t\tu64 l2_err;\n\t\t\tu64 l3l4_csum_err;\n\t\t};\n\t};\n};\n\nstruct hnae_queue;\n\nstruct hnae_ring {\n\tu8 __iomem *io_base;  \n\tstruct hnae_desc *desc;  \n\tstruct hnae_desc_cb *desc_cb;\n\tstruct hnae_queue *q;\n\tint irq;\n\tchar ring_name[RCB_RING_NAME_LEN];\n\n\t \n\tstruct ring_stats stats;\n\n\tdma_addr_t desc_dma_addr;\n\tu32 buf_size;        \n\tu16 desc_num;        \n\tu16 max_desc_num_per_pkt;\n\tu16 max_raw_data_sz_per_desc;\n\tu16 max_pkt_size;\n\tint next_to_use;     \n\n\t \n\tint next_to_clean;\n\n\tint flags;           \n\tint irq_init_flag;\n\n\t \n\tu64 coal_last_rx_bytes;\n\tunsigned long coal_last_jiffies;\n\tu32 coal_param;\n\tu32 coal_rx_rate;\t \n};\n\n#define ring_ptr_move_fw(ring, p) \\\n\t((ring)->p = ((ring)->p + 1) % (ring)->desc_num)\n#define ring_ptr_move_bw(ring, p) \\\n\t((ring)->p = ((ring)->p - 1 + (ring)->desc_num) % (ring)->desc_num)\n\nenum hns_desc_type {\n\tDESC_TYPE_SKB,\n\tDESC_TYPE_PAGE,\n};\n\n#define assert_is_ring_idx(ring, idx) \\\n\tassert((idx) >= 0 && (idx) < (ring)->desc_num)\n\n \nstatic inline int ring_dist(struct hnae_ring *ring, int begin, int end)\n{\n\tassert_is_ring_idx(ring, begin);\n\tassert_is_ring_idx(ring, end);\n\n\treturn (end - begin + ring->desc_num) % ring->desc_num;\n}\n\nstatic inline int ring_space(struct hnae_ring *ring)\n{\n\treturn ring->desc_num -\n\t\tring_dist(ring, ring->next_to_clean, ring->next_to_use) - 1;\n}\n\nstatic inline int is_ring_empty(struct hnae_ring *ring)\n{\n\tassert_is_ring_idx(ring, ring->next_to_use);\n\tassert_is_ring_idx(ring, ring->next_to_clean);\n\n\treturn ring->next_to_use == ring->next_to_clean;\n}\n\n#define hnae_buf_size(_ring) ((_ring)->buf_size)\n#define hnae_page_order(_ring) (get_order(hnae_buf_size(_ring)))\n#define hnae_page_size(_ring) (PAGE_SIZE << hnae_page_order(_ring))\n\nstruct hnae_handle;\n\n \nstruct hnae_buf_ops {\n\tint (*alloc_buffer)(struct hnae_ring *ring, struct hnae_desc_cb *cb);\n\tvoid (*free_buffer)(struct hnae_ring *ring, struct hnae_desc_cb *cb);\n\tint (*map_buffer)(struct hnae_ring *ring, struct hnae_desc_cb *cb);\n\tvoid (*unmap_buffer)(struct hnae_ring *ring, struct hnae_desc_cb *cb);\n};\n\nstruct hnae_queue {\n\tu8 __iomem *io_base;\n\tphys_addr_t phy_base;\n\tstruct hnae_ae_dev *dev;\t \n\tstruct hnae_ring rx_ring ____cacheline_internodealigned_in_smp;\n\tstruct hnae_ring tx_ring ____cacheline_internodealigned_in_smp;\n\tstruct hnae_handle *handle;\n};\n\n \nenum hnae_loop {\n\tMAC_INTERNALLOOP_MAC = 0,\n\tMAC_INTERNALLOOP_SERDES,\n\tMAC_INTERNALLOOP_PHY,\n\tMAC_LOOP_PHY_NONE,\n\tMAC_LOOP_NONE,\n};\n\n \nenum hnae_port_type {\n\tHNAE_PORT_SERVICE = 0,\n\tHNAE_PORT_DEBUG\n};\n\n \nenum hnae_media_type {\n\tHNAE_MEDIA_TYPE_UNKNOWN = 0,\n\tHNAE_MEDIA_TYPE_FIBER,\n\tHNAE_MEDIA_TYPE_COPPER,\n\tHNAE_MEDIA_TYPE_BACKPLANE,\n};\n\n \nstruct hnae_ae_ops {\n\tstruct hnae_handle *(*get_handle)(struct hnae_ae_dev *dev,\n\t\t\t\t\t  u32 port_id);\n\tvoid (*put_handle)(struct hnae_handle *handle);\n\tvoid (*init_queue)(struct hnae_queue *q);\n\tvoid (*fini_queue)(struct hnae_queue *q);\n\tint (*start)(struct hnae_handle *handle);\n\tvoid (*stop)(struct hnae_handle *handle);\n\tvoid (*reset)(struct hnae_handle *handle);\n\tint (*set_opts)(struct hnae_handle *handle, int type, void *opts);\n\tint (*get_opts)(struct hnae_handle *handle, int type, void **opts);\n\tint (*get_status)(struct hnae_handle *handle);\n\tint (*get_info)(struct hnae_handle *handle,\n\t\t\tu8 *auto_neg, u16 *speed, u8 *duplex);\n\tvoid (*toggle_ring_irq)(struct hnae_ring *ring, u32 val);\n\tvoid (*adjust_link)(struct hnae_handle *handle, int speed, int duplex);\n\tbool (*need_adjust_link)(struct hnae_handle *handle,\n\t\t\t\t int speed, int duplex);\n\tint (*set_loopback)(struct hnae_handle *handle,\n\t\t\t    enum hnae_loop loop_mode, int en);\n\tvoid (*get_ring_bdnum_limit)(struct hnae_queue *queue,\n\t\t\t\t     u32 *uplimit);\n\tvoid (*get_pauseparam)(struct hnae_handle *handle,\n\t\t\t       u32 *auto_neg, u32 *rx_en, u32 *tx_en);\n\tint (*set_pauseparam)(struct hnae_handle *handle,\n\t\t\t      u32 auto_neg, u32 rx_en, u32 tx_en);\n\tvoid (*get_coalesce_usecs)(struct hnae_handle *handle,\n\t\t\t\t   u32 *tx_usecs, u32 *rx_usecs);\n\tvoid (*get_max_coalesced_frames)(struct hnae_handle *handle,\n\t\t\t\t\t u32 *tx_frames, u32 *rx_frames);\n\tint (*set_coalesce_usecs)(struct hnae_handle *handle, u32 timeout);\n\tint (*set_coalesce_frames)(struct hnae_handle *handle,\n\t\t\t\t   u32 tx_frames, u32 rx_frames);\n\tvoid (*get_coalesce_range)(struct hnae_handle *handle,\n\t\t\t\t   u32 *tx_frames_low, u32 *rx_frames_low,\n\t\t\t\t   u32 *tx_frames_high, u32 *rx_frames_high,\n\t\t\t\t   u32 *tx_usecs_low, u32 *rx_usecs_low,\n\t\t\t\t   u32 *tx_usecs_high, u32 *rx_usecs_high);\n\tvoid (*set_promisc_mode)(struct hnae_handle *handle, u32 en);\n\tint (*get_mac_addr)(struct hnae_handle *handle, void **p);\n\tint (*set_mac_addr)(struct hnae_handle *handle, const void *p);\n\tint (*add_uc_addr)(struct hnae_handle *handle,\n\t\t\t   const unsigned char *addr);\n\tint (*rm_uc_addr)(struct hnae_handle *handle,\n\t\t\t  const unsigned char *addr);\n\tint (*clr_mc_addr)(struct hnae_handle *handle);\n\tint (*set_mc_addr)(struct hnae_handle *handle, void *addr);\n\tint (*set_mtu)(struct hnae_handle *handle, int new_mtu);\n\tvoid (*set_tso_stats)(struct hnae_handle *handle, int enable);\n\tvoid (*update_stats)(struct hnae_handle *handle,\n\t\t\t     struct net_device_stats *net_stats);\n\tvoid (*get_stats)(struct hnae_handle *handle, u64 *data);\n\tvoid (*get_strings)(struct hnae_handle *handle,\n\t\t\t    u32 stringset, u8 *data);\n\tint (*get_sset_count)(struct hnae_handle *handle, int stringset);\n\tvoid (*update_led_status)(struct hnae_handle *handle);\n\tint (*set_led_id)(struct hnae_handle *handle,\n\t\t\t  enum hnae_led_state status);\n\tvoid (*get_regs)(struct hnae_handle *handle, void *data);\n\tint (*get_regs_len)(struct hnae_handle *handle);\n\tu32\t(*get_rss_key_size)(struct hnae_handle *handle);\n\tu32\t(*get_rss_indir_size)(struct hnae_handle *handle);\n\tint\t(*get_rss)(struct hnae_handle *handle, u32 *indir, u8 *key,\n\t\t\t   u8 *hfunc);\n\tint\t(*set_rss)(struct hnae_handle *handle, const u32 *indir,\n\t\t\t   const u8 *key, const u8 hfunc);\n};\n\nstruct hnae_ae_dev {\n\tstruct device cls_dev;  \n\tstruct device *dev;  \n\tstruct hnae_ae_ops *ops;\n\tstruct list_head node;\n\tstruct module *owner;  \n\tint id;\n\tchar name[AE_NAME_SIZE];\n\tstruct list_head handle_list;\n\tspinlock_t lock;  \n};\n\nstruct hnae_handle {\n\tstruct device *owner_dev;  \n\tstruct hnae_ae_dev *dev;   \n\tstruct phy_device *phy_dev;\n\tphy_interface_t phy_if;\n\tu32 if_support;\n\tint q_num;\n\tint vf_id;\n\tunsigned long coal_last_jiffies;\n\tu32 coal_param;\t\t \n\t \n\tu32 coal_ring_idx;\n\tu32 eport_id;\n\tu32 dport_id;\t \n\tbool coal_adapt_en;\n\tenum hnae_port_type port_type;\n\tenum hnae_media_type media_type;\n\tstruct list_head node;     \n\tstruct hnae_buf_ops *bops;  \n\tstruct hnae_queue *qs[];   \n};\n\n#define ring_to_dev(ring) ((ring)->q->dev->dev)\n\nstruct hnae_handle *hnae_get_handle(struct device *owner_dev,\n\t\t\t\t    const struct fwnode_handle\t*fwnode,\n\t\t\t\t    u32 port_id,\n\t\t\t\t    struct hnae_buf_ops *bops);\n\nvoid hnae_put_handle(struct hnae_handle *handle);\nint hnae_ae_register(struct hnae_ae_dev *dev, struct module *owner);\nvoid hnae_ae_unregister(struct hnae_ae_dev *dev);\n\nint hnae_register_notifier(struct notifier_block *nb);\nvoid hnae_unregister_notifier(struct notifier_block *nb);\nint hnae_reinit_handle(struct hnae_handle *handle);\n\n#define hnae_queue_xmit(q, buf_num) writel_relaxed(buf_num, \\\n\t(q)->tx_ring.io_base + RCB_REG_TAIL)\n\n#ifndef assert\n#define assert(cond)\n#endif\n\nstatic inline int hnae_reserve_buffer_map(struct hnae_ring *ring,\n\t\t\t\t\t  struct hnae_desc_cb *cb)\n{\n\tstruct hnae_buf_ops *bops = ring->q->handle->bops;\n\tint ret;\n\n\tret = bops->alloc_buffer(ring, cb);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bops->map_buffer(ring, cb);\n\tif (ret)\n\t\tgoto out_with_buf;\n\n\treturn 0;\n\nout_with_buf:\n\tbops->free_buffer(ring, cb);\nout:\n\treturn ret;\n}\n\nstatic inline int hnae_alloc_buffer_attach(struct hnae_ring *ring, int i)\n{\n\tint ret = hnae_reserve_buffer_map(ring, &ring->desc_cb[i]);\n\n\tif (ret)\n\t\treturn ret;\n\n\tring->desc[i].addr = cpu_to_le64(ring->desc_cb[i].dma);\n\n\treturn 0;\n}\n\nstatic inline void hnae_buffer_detach(struct hnae_ring *ring, int i)\n{\n\tring->q->handle->bops->unmap_buffer(ring, &ring->desc_cb[i]);\n\tring->desc[i].addr = 0;\n}\n\nstatic inline void hnae_free_buffer_detach(struct hnae_ring *ring, int i)\n{\n\tstruct hnae_buf_ops *bops = ring->q->handle->bops;\n\tstruct hnae_desc_cb *cb = &ring->desc_cb[i];\n\n\tif (!ring->desc_cb[i].dma)\n\t\treturn;\n\n\thnae_buffer_detach(ring, i);\n\tbops->free_buffer(ring, cb);\n}\n\n \nstatic inline void hnae_replace_buffer(struct hnae_ring *ring, int i,\n\t\t\t\t       struct hnae_desc_cb *res_cb)\n{\n\tstruct hnae_buf_ops *bops = ring->q->handle->bops;\n\n\tbops->unmap_buffer(ring, &ring->desc_cb[i]);\n\tring->desc_cb[i] = *res_cb;\n\tring->desc[i].addr = cpu_to_le64(ring->desc_cb[i].dma);\n\tring->desc[i].rx.ipoff_bnum_pid_flag = 0;\n}\n\nstatic inline void hnae_reuse_buffer(struct hnae_ring *ring, int i)\n{\n\tring->desc_cb[i].reuse_flag = 0;\n\tring->desc[i].addr = cpu_to_le64(ring->desc_cb[i].dma\n\t\t+ ring->desc_cb[i].page_offset);\n\tring->desc[i].rx.ipoff_bnum_pid_flag = 0;\n}\n\n \nstatic inline void hnae_reinit_all_ring_desc(struct hnae_handle *h)\n{\n\tint i, j;\n\tstruct hnae_ring *ring;\n\n\tfor (i = 0; i < h->q_num; i++) {\n\t\tring = &h->qs[i]->rx_ring;\n\t\tfor (j = 0; j < ring->desc_num; j++)\n\t\t\tring->desc[j].addr = cpu_to_le64(ring->desc_cb[j].dma);\n\t}\n\n\twmb();\t \n}\n\n \nstatic inline void hnae_reinit_all_ring_page_off(struct hnae_handle *h)\n{\n\tint i, j;\n\tstruct hnae_ring *ring;\n\n\tfor (i = 0; i < h->q_num; i++) {\n\t\tring = &h->qs[i]->rx_ring;\n\t\tfor (j = 0; j < ring->desc_num; j++) {\n\t\t\tring->desc_cb[j].page_offset = 0;\n\t\t\tif (ring->desc[j].addr !=\n\t\t\t    cpu_to_le64(ring->desc_cb[j].dma))\n\t\t\t\tring->desc[j].addr =\n\t\t\t\t\tcpu_to_le64(ring->desc_cb[j].dma);\n\t\t}\n\t}\n\n\twmb();\t \n}\n\n#define hnae_set_field(origin, mask, shift, val) \\\n\tdo { \\\n\t\t(origin) &= (~(mask)); \\\n\t\t(origin) |= ((val) << (shift)) & (mask); \\\n\t} while (0)\n\n#define hnae_set_bit(origin, shift, val) \\\n\thnae_set_field((origin), (0x1 << (shift)), (shift), (val))\n\n#define hnae_get_field(origin, mask, shift) (((origin) & (mask)) >> (shift))\n\n#define hnae_get_bit(origin, shift) \\\n\thnae_get_field((origin), (0x1 << (shift)), (shift))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}