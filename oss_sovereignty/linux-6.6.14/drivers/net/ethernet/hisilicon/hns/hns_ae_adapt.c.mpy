{
  "module_name": "hns_ae_adapt.c",
  "hash_id": "e341d3a6fd4310c01bcdcfdae7ff1df5858c401463f0d1e36075cc04fc4d7cc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns/hns_ae_adapt.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n\n#include \"hnae.h\"\n#include \"hns_dsaf_mac.h\"\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_ppe.h\"\n#include \"hns_dsaf_rcb.h\"\n\nstatic struct hns_mac_cb *hns_get_mac_cb(struct hnae_handle *handle)\n{\n\tstruct  hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\n\treturn vf_cb->mac_cb;\n}\n\nstatic struct dsaf_device *hns_ae_get_dsaf_dev(struct hnae_ae_dev *dev)\n{\n\treturn container_of(dev, struct dsaf_device, ae_dev);\n}\n\nstatic struct hns_ppe_cb *hns_get_ppe_cb(struct hnae_handle *handle)\n{\n\tint ppe_index;\n\tstruct ppe_common_cb *ppe_comm;\n\tstruct  hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\n\tppe_comm = vf_cb->dsaf_dev->ppe_common[0];\n\tppe_index = vf_cb->port_index;\n\n\treturn &ppe_comm->ppe_cb[ppe_index];\n}\n\nstatic int hns_ae_get_q_num_per_vf(\n\tstruct dsaf_device *dsaf_dev, int port)\n{\n\treturn dsaf_dev->rcb_common[0]->max_q_per_vf;\n}\n\nstatic int hns_ae_get_vf_num_per_port(\n\tstruct dsaf_device *dsaf_dev, int port)\n{\n\treturn dsaf_dev->rcb_common[0]->max_vfn;\n}\n\nstatic struct ring_pair_cb *hns_ae_get_base_ring_pair(\n\tstruct dsaf_device *dsaf_dev, int port)\n{\n\tstruct rcb_common_cb *rcb_comm = dsaf_dev->rcb_common[0];\n\tint q_num = rcb_comm->max_q_per_vf;\n\tint vf_num = rcb_comm->max_vfn;\n\n\treturn &rcb_comm->ring_pair_cb[port * q_num * vf_num];\n}\n\nstatic struct ring_pair_cb *hns_ae_get_ring_pair(struct hnae_queue *q)\n{\n\treturn container_of(q, struct ring_pair_cb, q);\n}\n\nstatic struct hnae_handle *hns_ae_get_handle(struct hnae_ae_dev *dev,\n\t\t\t\t\t     u32 port_id)\n{\n\tint vfnum_per_port;\n\tint qnum_per_vf;\n\tint i;\n\tstruct dsaf_device *dsaf_dev;\n\tstruct hnae_handle *ae_handle;\n\tstruct ring_pair_cb *ring_pair_cb;\n\tstruct hnae_vf_cb *vf_cb;\n\n\tdsaf_dev = hns_ae_get_dsaf_dev(dev);\n\n\tring_pair_cb = hns_ae_get_base_ring_pair(dsaf_dev, port_id);\n\tvfnum_per_port = hns_ae_get_vf_num_per_port(dsaf_dev, port_id);\n\tqnum_per_vf = hns_ae_get_q_num_per_vf(dsaf_dev, port_id);\n\n\tvf_cb = kzalloc(struct_size(vf_cb, ae_handle.qs, qnum_per_vf),\n\t\t\tGFP_KERNEL);\n\tif (unlikely(!vf_cb)) {\n\t\tdev_err(dsaf_dev->dev, \"malloc vf_cb fail!\\n\");\n\t\tae_handle = ERR_PTR(-ENOMEM);\n\t\tgoto handle_err;\n\t}\n\tae_handle = &vf_cb->ae_handle;\n\t \n\tae_handle->owner_dev = dsaf_dev->dev;\n\tae_handle->dev = dev;\n\tae_handle->q_num = qnum_per_vf;\n\tae_handle->coal_param = HNAE_LOWEST_LATENCY_COAL_PARAM;\n\n\t \n\tfor (ae_handle->vf_id = 0;\n\t\tae_handle->vf_id < vfnum_per_port; ae_handle->vf_id++) {\n\t\tif (!ring_pair_cb->used_by_vf)\n\t\t\tbreak;\n\t\tring_pair_cb += qnum_per_vf;\n\t}\n\tif (ae_handle->vf_id >= vfnum_per_port) {\n\t\tdev_err(dsaf_dev->dev, \"malloc queue fail!\\n\");\n\t\tae_handle = ERR_PTR(-EINVAL);\n\t\tgoto vf_id_err;\n\t}\n\n\tfor (i = 0; i < qnum_per_vf; i++) {\n\t\tae_handle->qs[i] = &ring_pair_cb->q;\n\t\tae_handle->qs[i]->rx_ring.q = ae_handle->qs[i];\n\t\tae_handle->qs[i]->tx_ring.q = ae_handle->qs[i];\n\n\t\tring_pair_cb->used_by_vf = 1;\n\t\tring_pair_cb++;\n\t}\n\n\tvf_cb->dsaf_dev = dsaf_dev;\n\tvf_cb->port_index = port_id;\n\tvf_cb->mac_cb = dsaf_dev->mac_cb[port_id];\n\n\tae_handle->phy_if = vf_cb->mac_cb->phy_if;\n\tae_handle->phy_dev = vf_cb->mac_cb->phy_dev;\n\tae_handle->if_support = vf_cb->mac_cb->if_support;\n\tae_handle->port_type = vf_cb->mac_cb->mac_type;\n\tae_handle->media_type = vf_cb->mac_cb->media_type;\n\tae_handle->dport_id = port_id;\n\n\treturn ae_handle;\nvf_id_err:\n\tkfree(vf_cb);\nhandle_err:\n\treturn ae_handle;\n}\n\nstatic void hns_ae_put_handle(struct hnae_handle *handle)\n{\n\tstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\tint i;\n\n\tfor (i = 0; i < handle->q_num; i++)\n\t\thns_ae_get_ring_pair(handle->qs[i])->used_by_vf = 0;\n\n\tkfree(vf_cb);\n}\n\nstatic int hns_ae_wait_flow_down(struct hnae_handle *handle)\n{\n\tstruct dsaf_device *dsaf_dev;\n\tstruct hns_ppe_cb *ppe_cb;\n\tstruct hnae_vf_cb *vf_cb;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < handle->q_num; i++) {\n\t\tret = hns_rcb_wait_tx_ring_clean(handle->qs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tppe_cb = hns_get_ppe_cb(handle);\n\tret = hns_ppe_wait_tx_fifo_clean(ppe_cb);\n\tif (ret)\n\t\treturn ret;\n\n\tdsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\n\tif (!dsaf_dev)\n\t\treturn -EINVAL;\n\tret = hns_dsaf_wait_pkt_clean(dsaf_dev, handle->dport_id);\n\tif (ret)\n\t\treturn ret;\n\n\tvf_cb = hns_ae_get_vf_cb(handle);\n\tret = hns_mac_wait_fifo_clean(vf_cb->mac_cb);\n\tif (ret)\n\t\treturn ret;\n\n\tmdelay(10);\n\treturn 0;\n}\n\nstatic void hns_ae_ring_enable_all(struct hnae_handle *handle, int val)\n{\n\tint q_num = handle->q_num;\n\tint i;\n\n\tfor (i = 0; i < q_num; i++)\n\t\thns_rcb_ring_enable_hw(handle->qs[i], val);\n}\n\nstatic void hns_ae_init_queue(struct hnae_queue *q)\n{\n\tstruct ring_pair_cb *ring =\n\t\tcontainer_of(q, struct ring_pair_cb, q);\n\n\thns_rcb_init_hw(ring);\n}\n\nstatic void hns_ae_fini_queue(struct hnae_queue *q)\n{\n\tstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(q->handle);\n\n\tif (vf_cb->mac_cb->mac_type == HNAE_PORT_SERVICE)\n\t\thns_rcb_reset_ring_hw(q);\n}\n\nstatic int hns_ae_set_mac_address(struct hnae_handle *handle, const void *p)\n{\n\tint ret;\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\tif (!p || !is_valid_ether_addr((const u8 *)p)) {\n\t\tdev_err(handle->owner_dev, \"is not valid ether addr !\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tret = hns_mac_change_vf_addr(mac_cb, handle->vf_id, p);\n\tif (ret != 0) {\n\t\tdev_err(handle->owner_dev,\n\t\t\t\"set_mac_address fail, ret=%d!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hns_ae_add_uc_address(struct hnae_handle *handle,\n\t\t\t\t const unsigned char *addr)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\tif (mac_cb->mac_type != HNAE_PORT_SERVICE)\n\t\treturn -ENOSPC;\n\n\treturn hns_mac_add_uc_addr(mac_cb, handle->vf_id, addr);\n}\n\nstatic int hns_ae_rm_uc_address(struct hnae_handle *handle,\n\t\t\t\tconst unsigned char *addr)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\tif (mac_cb->mac_type != HNAE_PORT_SERVICE)\n\t\treturn -ENOSPC;\n\n\treturn hns_mac_rm_uc_addr(mac_cb, handle->vf_id, addr);\n}\n\nstatic int hns_ae_set_multicast_one(struct hnae_handle *handle, void *addr)\n{\n\tint ret;\n\tchar *mac_addr = (char *)addr;\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\tu8 port_num;\n\n\tassert(mac_cb);\n\n\tif (mac_cb->mac_type != HNAE_PORT_SERVICE)\n\t\treturn 0;\n\n\tret = hns_mac_set_multi(mac_cb, mac_cb->mac_id, mac_addr, true);\n\tif (ret) {\n\t\tdev_err(handle->owner_dev,\n\t\t\t\"mac add mul_mac:%pM port%d  fail, ret = %#x!\\n\",\n\t\t\tmac_addr, mac_cb->mac_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = hns_mac_get_inner_port_num(mac_cb, handle->vf_id, &port_num);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns_mac_set_multi(mac_cb, port_num, mac_addr, true);\n\tif (ret)\n\t\tdev_err(handle->owner_dev,\n\t\t\t\"mac add mul_mac:%pM port%d  fail, ret = %#x!\\n\",\n\t\t\tmac_addr, DSAF_BASE_INNER_PORT_NUM, ret);\n\n\treturn ret;\n}\n\nstatic int hns_ae_clr_multicast(struct hnae_handle *handle)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\tif (mac_cb->mac_type != HNAE_PORT_SERVICE)\n\t\treturn 0;\n\n\treturn hns_mac_clr_multicast(mac_cb, handle->vf_id);\n}\n\nstatic int hns_ae_set_mtu(struct hnae_handle *handle, int new_mtu)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\tstruct hnae_queue *q;\n\tu32 rx_buf_size;\n\tint i, ret;\n\n\t \n\tif (!AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver)) {\n\t\tif (new_mtu <= BD_SIZE_2048_MAX_MTU)\n\t\t\trx_buf_size = 2048;\n\t\telse\n\t\t\trx_buf_size = 4096;\n\t} else {\n\t\trx_buf_size = mac_cb->dsaf_dev->buf_size;\n\t}\n\n\tret = hns_mac_set_mtu(mac_cb, new_mtu, rx_buf_size);\n\n\tif (!ret) {\n\t\t \n\t\tfor (i = 0; i < handle->q_num; i++) {\n\t\t\tq = handle->qs[i];\n\t\t\tq->rx_ring.buf_size = rx_buf_size;\n\t\t\thns_rcb_set_rx_ring_bs(q, rx_buf_size);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void hns_ae_set_tso_stats(struct hnae_handle *handle, int enable)\n{\n\tstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\n\n\thns_ppe_set_tso_enable(ppe_cb, enable);\n}\n\nstatic int hns_ae_start(struct hnae_handle *handle)\n{\n\tint ret;\n\tint k;\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\tret = hns_mac_vm_config_bc_en(mac_cb, 0, true);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (k = 0; k < handle->q_num; k++) {\n\t\tif (AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver))\n\t\t\thns_rcb_int_clr_hw(handle->qs[k],\n\t\t\t\t\t   RCB_INT_FLAG_TX | RCB_INT_FLAG_RX);\n\t\telse\n\t\t\thns_rcbv2_int_clr_hw(handle->qs[k],\n\t\t\t\t\t     RCB_INT_FLAG_TX | RCB_INT_FLAG_RX);\n\t}\n\thns_ae_ring_enable_all(handle, 1);\n\tmsleep(100);\n\n\thns_mac_start(mac_cb);\n\n\treturn 0;\n}\n\nstatic void hns_ae_stop(struct hnae_handle *handle)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\t \n\thns_rcb_wait_fbd_clean(handle->qs, handle->q_num, RCB_INT_FLAG_TX);\n\n\tmsleep(20);\n\n\thns_mac_stop(mac_cb);\n\n\tusleep_range(10000, 20000);\n\n\thns_ae_ring_enable_all(handle, 0);\n\n\t \n\thns_rcb_wait_fbd_clean(handle->qs, handle->q_num, RCB_INT_FLAG_RX);\n\n\t(void)hns_mac_vm_config_bc_en(mac_cb, 0, false);\n}\n\nstatic void hns_ae_reset(struct hnae_handle *handle)\n{\n\tstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\n\tif (vf_cb->mac_cb->mac_type == HNAE_PORT_DEBUG) {\n\t\thns_mac_reset(vf_cb->mac_cb);\n\t\thns_ppe_reset_common(vf_cb->dsaf_dev, 0);\n\t}\n}\n\nstatic void hns_ae_toggle_ring_irq(struct hnae_ring *ring, u32 mask)\n{\n\tu32 flag;\n\n\tif (is_tx_ring(ring))\n\t\tflag = RCB_INT_FLAG_TX;\n\telse\n\t\tflag = RCB_INT_FLAG_RX;\n\n\thns_rcb_int_ctrl_hw(ring->q, flag, mask);\n}\n\nstatic void hns_aev2_toggle_ring_irq(struct hnae_ring *ring, u32 mask)\n{\n\tu32 flag;\n\n\tif (is_tx_ring(ring))\n\t\tflag = RCB_INT_FLAG_TX;\n\telse\n\t\tflag = RCB_INT_FLAG_RX;\n\n\thns_rcbv2_int_ctrl_hw(ring->q, flag, mask);\n}\n\nstatic int hns_ae_get_link_status(struct hnae_handle *handle)\n{\n\tu32 link_status;\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\thns_mac_get_link_status(mac_cb, &link_status);\n\n\treturn !!link_status;\n}\n\nstatic int hns_ae_get_mac_info(struct hnae_handle *handle,\n\t\t\t       u8 *auto_neg, u16 *speed, u8 *duplex)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\treturn hns_mac_get_port_info(mac_cb, auto_neg, speed, duplex);\n}\n\nstatic bool hns_ae_need_adjust_link(struct hnae_handle *handle, int speed,\n\t\t\t\t    int duplex)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\treturn hns_mac_need_adjust_link(mac_cb, speed, duplex);\n}\n\nstatic void hns_ae_adjust_link(struct hnae_handle *handle, int speed,\n\t\t\t       int duplex)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\tswitch (mac_cb->dsaf_dev->dsaf_ver) {\n\tcase AE_VERSION_1:\n\t\thns_mac_adjust_link(mac_cb, speed, duplex);\n\t\tbreak;\n\n\tcase AE_VERSION_2:\n\t\t \n\t\thns_mac_disable(mac_cb, MAC_COMM_MODE_RX);\n\t\tif (hns_ae_wait_flow_down(handle)) {\n\t\t\thns_mac_enable(mac_cb, MAC_COMM_MODE_RX);\n\t\t\tbreak;\n\t\t}\n\n\t\thns_mac_adjust_link(mac_cb, speed, duplex);\n\t\thns_mac_enable(mac_cb, MAC_COMM_MODE_RX);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void hns_ae_get_ring_bdnum_limit(struct hnae_queue *queue,\n\t\t\t\t\tu32 *uplimit)\n{\n\t*uplimit = HNS_RCB_RING_MAX_PENDING_BD;\n}\n\nstatic void hns_ae_get_pauseparam(struct hnae_handle *handle,\n\t\t\t\t  u32 *auto_neg, u32 *rx_en, u32 *tx_en)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\n\thns_mac_get_autoneg(mac_cb, auto_neg);\n\n\thns_mac_get_pauseparam(mac_cb, rx_en, tx_en);\n\n\t \n\tif (handle->port_type == HNAE_PORT_SERVICE)\n\t\thns_dsaf_get_rx_mac_pause_en(dsaf_dev, mac_cb->mac_id, rx_en);\n}\n\nstatic void hns_ae_set_promisc_mode(struct hnae_handle *handle, u32 en)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\n\thns_dsaf_set_promisc_mode(hns_ae_get_dsaf_dev(handle->dev), en);\n\thns_mac_set_promisc(mac_cb, (u8)!!en);\n}\n\nstatic int hns_ae_set_pauseparam(struct hnae_handle *handle,\n\t\t\t\t u32 autoneg, u32 rx_en, u32 tx_en)\n{\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tint ret;\n\n\tret = hns_mac_set_autoneg(mac_cb, autoneg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (handle->port_type == HNAE_PORT_SERVICE) {\n\t\tret = hns_dsaf_set_rx_mac_pause_en(dsaf_dev,\n\t\t\t\t\t\t   mac_cb->mac_id, rx_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trx_en = 0;\n\t}\n\treturn hns_mac_set_pauseparam(mac_cb, rx_en, tx_en);\n}\n\nstatic void hns_ae_get_coalesce_usecs(struct hnae_handle *handle,\n\t\t\t\t      u32 *tx_usecs, u32 *rx_usecs)\n{\n\tstruct ring_pair_cb *ring_pair =\n\t\tcontainer_of(handle->qs[0], struct ring_pair_cb, q);\n\n\t*tx_usecs = hns_rcb_get_coalesce_usecs(ring_pair->rcb_common,\n\t\t\t\t\t       ring_pair->port_id_in_comm);\n\t*rx_usecs = hns_rcb_get_coalesce_usecs(ring_pair->rcb_common,\n\t\t\t\t\t       ring_pair->port_id_in_comm);\n}\n\nstatic void hns_ae_get_max_coalesced_frames(struct hnae_handle *handle,\n\t\t\t\t\t    u32 *tx_frames, u32 *rx_frames)\n{\n\tstruct ring_pair_cb *ring_pair =\n\t\tcontainer_of(handle->qs[0], struct ring_pair_cb, q);\n\tstruct dsaf_device *dsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\n\n\tif (AE_IS_VER1(dsaf_dev->dsaf_ver) ||\n\t    handle->port_type == HNAE_PORT_DEBUG)\n\t\t*tx_frames = hns_rcb_get_rx_coalesced_frames(\n\t\t\tring_pair->rcb_common, ring_pair->port_id_in_comm);\n\telse\n\t\t*tx_frames = hns_rcb_get_tx_coalesced_frames(\n\t\t\tring_pair->rcb_common, ring_pair->port_id_in_comm);\n\t*rx_frames = hns_rcb_get_rx_coalesced_frames(ring_pair->rcb_common,\n\t\t\t\t\t\t  ring_pair->port_id_in_comm);\n}\n\nstatic int hns_ae_set_coalesce_usecs(struct hnae_handle *handle,\n\t\t\t\t     u32 timeout)\n{\n\tstruct ring_pair_cb *ring_pair =\n\t\tcontainer_of(handle->qs[0], struct ring_pair_cb, q);\n\n\treturn hns_rcb_set_coalesce_usecs(\n\t\tring_pair->rcb_common, ring_pair->port_id_in_comm, timeout);\n}\n\nstatic int hns_ae_set_coalesce_frames(struct hnae_handle *handle,\n\t\t\t\t      u32 tx_frames, u32 rx_frames)\n{\n\tint ret;\n\tstruct ring_pair_cb *ring_pair =\n\t\tcontainer_of(handle->qs[0], struct ring_pair_cb, q);\n\tstruct dsaf_device *dsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\n\n\tif (AE_IS_VER1(dsaf_dev->dsaf_ver) ||\n\t    handle->port_type == HNAE_PORT_DEBUG) {\n\t\tif (tx_frames != rx_frames)\n\t\t\treturn -EINVAL;\n\t\treturn hns_rcb_set_rx_coalesced_frames(\n\t\t\tring_pair->rcb_common,\n\t\t\tring_pair->port_id_in_comm, rx_frames);\n\t} else {\n\t\tif (tx_frames != 1)\n\t\t\treturn -EINVAL;\n\t\tret = hns_rcb_set_tx_coalesced_frames(\n\t\t\tring_pair->rcb_common,\n\t\t\tring_pair->port_id_in_comm, tx_frames);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn hns_rcb_set_rx_coalesced_frames(\n\t\t\tring_pair->rcb_common,\n\t\t\tring_pair->port_id_in_comm, rx_frames);\n\t}\n}\n\nstatic void hns_ae_get_coalesce_range(struct hnae_handle *handle,\n\t\t\t\t      u32 *tx_frames_low, u32 *rx_frames_low,\n\t\t\t\t      u32 *tx_frames_high, u32 *rx_frames_high,\n\t\t\t\t      u32 *tx_usecs_low, u32 *rx_usecs_low,\n\t\t\t\t      u32 *tx_usecs_high, u32 *rx_usecs_high)\n{\n\tstruct dsaf_device *dsaf_dev;\n\n\tassert(handle);\n\n\tdsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\n\n\t*tx_frames_low  = HNS_RCB_TX_FRAMES_LOW;\n\t*rx_frames_low  = HNS_RCB_RX_FRAMES_LOW;\n\n\tif (AE_IS_VER1(dsaf_dev->dsaf_ver) ||\n\t    handle->port_type == HNAE_PORT_DEBUG)\n\t\t*tx_frames_high =\n\t\t\t(dsaf_dev->desc_num - 1 > HNS_RCB_TX_FRAMES_HIGH) ?\n\t\t\tHNS_RCB_TX_FRAMES_HIGH : dsaf_dev->desc_num - 1;\n\telse\n\t\t*tx_frames_high = 1;\n\n\t*rx_frames_high = (dsaf_dev->desc_num - 1 > HNS_RCB_RX_FRAMES_HIGH) ?\n\t\tHNS_RCB_RX_FRAMES_HIGH : dsaf_dev->desc_num - 1;\n\t*tx_usecs_low   = HNS_RCB_TX_USECS_LOW;\n\t*rx_usecs_low   = HNS_RCB_RX_USECS_LOW;\n\t*tx_usecs_high  = HNS_RCB_TX_USECS_HIGH;\n\t*rx_usecs_high  = HNS_RCB_RX_USECS_HIGH;\n}\n\nstatic void hns_ae_update_stats(struct hnae_handle *handle,\n\t\t\t\tstruct net_device_stats *net_stats)\n{\n\tint port;\n\tint idx;\n\tstruct dsaf_device *dsaf_dev;\n\tstruct hns_mac_cb *mac_cb;\n\tstruct hns_ppe_cb *ppe_cb;\n\tstruct hnae_queue *queue;\n\tstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\tu64 tx_bytes = 0, rx_bytes = 0, tx_packets = 0, rx_packets = 0;\n\tu64 rx_errors = 0, tx_errors = 0, tx_dropped = 0;\n\tu64 rx_missed_errors;\n\n\tdsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\n\tif (!dsaf_dev)\n\t\treturn;\n\tport = vf_cb->port_index;\n\tppe_cb = hns_get_ppe_cb(handle);\n\tmac_cb = hns_get_mac_cb(handle);\n\n\tfor (idx = 0; idx < handle->q_num; idx++) {\n\t\tqueue = handle->qs[idx];\n\t\thns_rcb_update_stats(queue);\n\n\t\ttx_bytes += queue->tx_ring.stats.tx_bytes;\n\t\ttx_packets += queue->tx_ring.stats.tx_pkts;\n\t\trx_bytes += queue->rx_ring.stats.rx_bytes;\n\t\trx_packets += queue->rx_ring.stats.rx_pkts;\n\n\t\trx_errors += queue->rx_ring.stats.err_pkt_len\n\t\t\t\t+ queue->rx_ring.stats.l2_err\n\t\t\t\t+ queue->rx_ring.stats.l3l4_csum_err;\n\t}\n\n\thns_ppe_update_stats(ppe_cb);\n\trx_missed_errors = ppe_cb->hw_stats.rx_drop_no_buf;\n\ttx_errors += ppe_cb->hw_stats.tx_err_checksum\n\t\t+ ppe_cb->hw_stats.tx_err_fifo_empty;\n\n\tif (mac_cb->mac_type == HNAE_PORT_SERVICE) {\n\t\thns_dsaf_update_stats(dsaf_dev, port);\n\t\t \n\t\trx_missed_errors += dsaf_dev->hw_stats[port].bp_drop;\n\t\trx_missed_errors += dsaf_dev->hw_stats[port].pad_drop;\n\t\trx_missed_errors += dsaf_dev->hw_stats[port].crc_false;\n\n\t\t \n\t\tport = port + DSAF_PPE_INODE_BASE;\n\t\thns_dsaf_update_stats(dsaf_dev, port);\n\t\ttx_dropped += dsaf_dev->hw_stats[port].bp_drop;\n\t\ttx_dropped += dsaf_dev->hw_stats[port].pad_drop;\n\t\ttx_dropped += dsaf_dev->hw_stats[port].crc_false;\n\t\ttx_dropped += dsaf_dev->hw_stats[port].rslt_drop;\n\t\ttx_dropped += dsaf_dev->hw_stats[port].vlan_drop;\n\t\ttx_dropped += dsaf_dev->hw_stats[port].stp_drop;\n\t}\n\n\thns_mac_update_stats(mac_cb);\n\trx_errors += mac_cb->hw_stats.rx_fifo_overrun_err;\n\n\ttx_errors += mac_cb->hw_stats.tx_bad_pkts\n\t\t+ mac_cb->hw_stats.tx_fragment_err\n\t\t+ mac_cb->hw_stats.tx_jabber_err\n\t\t+ mac_cb->hw_stats.tx_underrun_err\n\t\t+ mac_cb->hw_stats.tx_crc_err;\n\n\tnet_stats->tx_bytes = tx_bytes;\n\tnet_stats->tx_packets = tx_packets;\n\tnet_stats->rx_bytes = rx_bytes;\n\tnet_stats->rx_dropped = 0;\n\tnet_stats->rx_packets = rx_packets;\n\tnet_stats->rx_errors = rx_errors;\n\tnet_stats->tx_errors = tx_errors;\n\tnet_stats->tx_dropped = tx_dropped;\n\tnet_stats->rx_missed_errors = rx_missed_errors;\n\tnet_stats->rx_crc_errors = mac_cb->hw_stats.rx_fcs_err;\n\tnet_stats->rx_frame_errors = mac_cb->hw_stats.rx_align_err;\n\tnet_stats->rx_fifo_errors = mac_cb->hw_stats.rx_fifo_overrun_err;\n\tnet_stats->rx_length_errors = mac_cb->hw_stats.rx_len_err;\n\tnet_stats->multicast = mac_cb->hw_stats.rx_mc_pkts;\n}\n\nstatic void hns_ae_get_stats(struct hnae_handle *handle, u64 *data)\n{\n\tint idx;\n\tstruct hns_mac_cb *mac_cb;\n\tstruct hns_ppe_cb *ppe_cb;\n\tu64 *p = data;\n\tstruct  hnae_vf_cb *vf_cb;\n\n\tif (!handle || !data) {\n\t\tpr_err(\"hns_ae_get_stats NULL handle or data pointer!\\n\");\n\t\treturn;\n\t}\n\n\tvf_cb = hns_ae_get_vf_cb(handle);\n\tmac_cb = hns_get_mac_cb(handle);\n\tppe_cb = hns_get_ppe_cb(handle);\n\n\tfor (idx = 0; idx < handle->q_num; idx++) {\n\t\thns_rcb_get_stats(handle->qs[idx], p);\n\t\tp += hns_rcb_get_ring_sset_count((int)ETH_SS_STATS);\n\t}\n\n\thns_ppe_get_stats(ppe_cb, p);\n\tp += hns_ppe_get_sset_count((int)ETH_SS_STATS);\n\n\thns_mac_get_stats(mac_cb, p);\n\tp += hns_mac_get_sset_count(mac_cb, (int)ETH_SS_STATS);\n\n\tif (mac_cb->mac_type == HNAE_PORT_SERVICE)\n\t\thns_dsaf_get_stats(vf_cb->dsaf_dev, p, vf_cb->port_index);\n}\n\nstatic void hns_ae_get_strings(struct hnae_handle *handle,\n\t\t\t       u32 stringset, u8 *data)\n{\n\tint port;\n\tint idx;\n\tstruct hns_mac_cb *mac_cb;\n\tstruct hns_ppe_cb *ppe_cb;\n\tstruct dsaf_device *dsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\n\tu8 *p = data;\n\tstruct\thnae_vf_cb *vf_cb;\n\n\tassert(handle);\n\n\tvf_cb = hns_ae_get_vf_cb(handle);\n\tport = vf_cb->port_index;\n\tmac_cb = hns_get_mac_cb(handle);\n\tppe_cb = hns_get_ppe_cb(handle);\n\n\tfor (idx = 0; idx < handle->q_num; idx++) {\n\t\thns_rcb_get_strings(stringset, p, idx);\n\t\tp += ETH_GSTRING_LEN * hns_rcb_get_ring_sset_count(stringset);\n\t}\n\n\thns_ppe_get_strings(ppe_cb, stringset, p);\n\tp += ETH_GSTRING_LEN * hns_ppe_get_sset_count(stringset);\n\n\thns_mac_get_strings(mac_cb, stringset, p);\n\tp += ETH_GSTRING_LEN * hns_mac_get_sset_count(mac_cb, stringset);\n\n\tif (mac_cb->mac_type == HNAE_PORT_SERVICE)\n\t\thns_dsaf_get_strings(stringset, p, port, dsaf_dev);\n}\n\nstatic int hns_ae_get_sset_count(struct hnae_handle *handle, int stringset)\n{\n\tu32 sset_count = 0;\n\tstruct hns_mac_cb *mac_cb;\n\tstruct dsaf_device *dsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\n\n\tassert(handle);\n\n\tmac_cb = hns_get_mac_cb(handle);\n\n\tsset_count += hns_rcb_get_ring_sset_count(stringset) * handle->q_num;\n\tsset_count += hns_ppe_get_sset_count(stringset);\n\tsset_count += hns_mac_get_sset_count(mac_cb, stringset);\n\n\tif (mac_cb->mac_type == HNAE_PORT_SERVICE)\n\t\tsset_count += hns_dsaf_get_sset_count(dsaf_dev, stringset);\n\n\treturn sset_count;\n}\n\nstatic int hns_ae_config_loopback(struct hnae_handle *handle,\n\t\t\t\t  enum hnae_loop loop, int en)\n{\n\tint ret;\n\tstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\tstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\n\tswitch (loop) {\n\tcase MAC_INTERNALLOOP_PHY:\n\t\tret = 0;\n\t\tbreak;\n\tcase MAC_INTERNALLOOP_SERDES:\n\t\tret = dsaf_dev->misc_op->cfg_serdes_loopback(vf_cb->mac_cb,\n\t\t\t\t\t\t\t     !!en);\n\t\tbreak;\n\tcase MAC_INTERNALLOOP_MAC:\n\t\tret = hns_mac_config_mac_loopback(vf_cb->mac_cb, loop, en);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void hns_ae_update_led_status(struct hnae_handle *handle)\n{\n\tstruct hns_mac_cb *mac_cb;\n\n\tassert(handle);\n\tmac_cb = hns_get_mac_cb(handle);\n\tif (mac_cb->media_type != HNAE_MEDIA_TYPE_FIBER)\n\t\treturn;\n\n\thns_set_led_opt(mac_cb);\n}\n\nstatic int hns_ae_cpld_set_led_id(struct hnae_handle *handle,\n\t\t\t\t  enum hnae_led_state status)\n{\n\tstruct hns_mac_cb *mac_cb;\n\n\tassert(handle);\n\n\tmac_cb = hns_get_mac_cb(handle);\n\n\treturn hns_cpld_led_set_id(mac_cb, status);\n}\n\nstatic void hns_ae_get_regs(struct hnae_handle *handle, void *data)\n{\n\tu32 *p = data;\n\tint i;\n\tstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\tstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\n\n\thns_ppe_get_regs(ppe_cb, p);\n\tp += hns_ppe_get_regs_count();\n\n\thns_rcb_get_common_regs(vf_cb->dsaf_dev->rcb_common[0], p);\n\tp += hns_rcb_get_common_regs_count();\n\n\tfor (i = 0; i < handle->q_num; i++) {\n\t\thns_rcb_get_ring_regs(handle->qs[i], p);\n\t\tp += hns_rcb_get_ring_regs_count();\n\t}\n\n\thns_mac_get_regs(vf_cb->mac_cb, p);\n\tp += hns_mac_get_regs_count(vf_cb->mac_cb);\n\n\tif (vf_cb->mac_cb->mac_type == HNAE_PORT_SERVICE)\n\t\thns_dsaf_get_regs(vf_cb->dsaf_dev, vf_cb->port_index, p);\n}\n\nstatic int hns_ae_get_regs_len(struct hnae_handle *handle)\n{\n\tu32 total_num;\n\tstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\n\n\ttotal_num = hns_ppe_get_regs_count();\n\ttotal_num += hns_rcb_get_common_regs_count();\n\ttotal_num += hns_rcb_get_ring_regs_count() * handle->q_num;\n\ttotal_num += hns_mac_get_regs_count(vf_cb->mac_cb);\n\n\tif (vf_cb->mac_cb->mac_type == HNAE_PORT_SERVICE)\n\t\ttotal_num += hns_dsaf_get_regs_count();\n\n\treturn total_num;\n}\n\nstatic u32 hns_ae_get_rss_key_size(struct hnae_handle *handle)\n{\n\treturn HNS_PPEV2_RSS_KEY_SIZE;\n}\n\nstatic u32 hns_ae_get_rss_indir_size(struct hnae_handle *handle)\n{\n\treturn HNS_PPEV2_RSS_IND_TBL_SIZE;\n}\n\nstatic int hns_ae_get_rss(struct hnae_handle *handle, u32 *indir, u8 *key,\n\t\t\t  u8 *hfunc)\n{\n\tstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\n\n\t \n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\t \n\tif (key)\n\t\tmemcpy(key, ppe_cb->rss_key, HNS_PPEV2_RSS_KEY_SIZE);\n\n\t \n\tif (indir)\n\t\tmemcpy(indir, ppe_cb->rss_indir_table,\n\t\t       HNS_PPEV2_RSS_IND_TBL_SIZE  * sizeof(*indir));\n\n\treturn 0;\n}\n\nstatic int hns_ae_set_rss(struct hnae_handle *handle, const u32 *indir,\n\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\n\n\t \n\tif (key) {\n\t\tmemcpy(ppe_cb->rss_key, key, HNS_PPEV2_RSS_KEY_SIZE);\n\t\thns_ppe_set_rss_key(ppe_cb, ppe_cb->rss_key);\n\t}\n\n\tif (indir) {\n\t\t \n\t\tmemcpy(ppe_cb->rss_indir_table, indir,\n\t\t       HNS_PPEV2_RSS_IND_TBL_SIZE  * sizeof(*indir));\n\n\t\t \n\t\thns_ppe_set_indir_table(ppe_cb, ppe_cb->rss_indir_table);\n\t}\n\n\treturn 0;\n}\n\nstatic struct hnae_ae_ops hns_dsaf_ops = {\n\t.get_handle = hns_ae_get_handle,\n\t.put_handle = hns_ae_put_handle,\n\t.init_queue = hns_ae_init_queue,\n\t.fini_queue = hns_ae_fini_queue,\n\t.start = hns_ae_start,\n\t.stop = hns_ae_stop,\n\t.reset = hns_ae_reset,\n\t.toggle_ring_irq = hns_ae_toggle_ring_irq,\n\t.get_status = hns_ae_get_link_status,\n\t.get_info = hns_ae_get_mac_info,\n\t.adjust_link = hns_ae_adjust_link,\n\t.need_adjust_link = hns_ae_need_adjust_link,\n\t.set_loopback = hns_ae_config_loopback,\n\t.get_ring_bdnum_limit = hns_ae_get_ring_bdnum_limit,\n\t.get_pauseparam = hns_ae_get_pauseparam,\n\t.set_pauseparam = hns_ae_set_pauseparam,\n\t.get_coalesce_usecs = hns_ae_get_coalesce_usecs,\n\t.get_max_coalesced_frames = hns_ae_get_max_coalesced_frames,\n\t.set_coalesce_usecs = hns_ae_set_coalesce_usecs,\n\t.set_coalesce_frames = hns_ae_set_coalesce_frames,\n\t.get_coalesce_range = hns_ae_get_coalesce_range,\n\t.set_promisc_mode = hns_ae_set_promisc_mode,\n\t.set_mac_addr = hns_ae_set_mac_address,\n\t.add_uc_addr = hns_ae_add_uc_address,\n\t.rm_uc_addr = hns_ae_rm_uc_address,\n\t.set_mc_addr = hns_ae_set_multicast_one,\n\t.clr_mc_addr = hns_ae_clr_multicast,\n\t.set_mtu = hns_ae_set_mtu,\n\t.update_stats = hns_ae_update_stats,\n\t.set_tso_stats = hns_ae_set_tso_stats,\n\t.get_stats = hns_ae_get_stats,\n\t.get_strings = hns_ae_get_strings,\n\t.get_sset_count = hns_ae_get_sset_count,\n\t.update_led_status = hns_ae_update_led_status,\n\t.set_led_id = hns_ae_cpld_set_led_id,\n\t.get_regs = hns_ae_get_regs,\n\t.get_regs_len = hns_ae_get_regs_len,\n\t.get_rss_key_size = hns_ae_get_rss_key_size,\n\t.get_rss_indir_size = hns_ae_get_rss_indir_size,\n\t.get_rss = hns_ae_get_rss,\n\t.set_rss = hns_ae_set_rss\n};\n\nint hns_dsaf_ae_init(struct dsaf_device *dsaf_dev)\n{\n\tstruct hnae_ae_dev *ae_dev = &dsaf_dev->ae_dev;\n\tstatic atomic_t id = ATOMIC_INIT(-1);\n\n\tswitch (dsaf_dev->dsaf_ver) {\n\tcase AE_VERSION_1:\n\t\thns_dsaf_ops.toggle_ring_irq = hns_ae_toggle_ring_irq;\n\t\tbreak;\n\tcase AE_VERSION_2:\n\t\thns_dsaf_ops.toggle_ring_irq = hns_aev2_toggle_ring_irq;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsnprintf(ae_dev->name, AE_NAME_SIZE, \"%s%d\", DSAF_DEVICE_NAME,\n\t\t (int)atomic_inc_return(&id));\n\tae_dev->ops = &hns_dsaf_ops;\n\tae_dev->dev = dsaf_dev->dev;\n\n\treturn hnae_ae_register(ae_dev, THIS_MODULE);\n}\n\nvoid hns_dsaf_ae_uninit(struct dsaf_device *dsaf_dev)\n{\n\thnae_ae_unregister(&dsaf_dev->ae_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}