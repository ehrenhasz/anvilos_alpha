{
  "module_name": "hns_dsaf_mac.c",
  "hash_id": "39f13f79c0b552066fce59de9ce569345f1c0863416fcd406a7e2b596c652800",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_misc.h\"\n#include \"hns_dsaf_rcb.h\"\n\n#define MAC_EN_FLAG_V\t\t0xada0328\n\nstatic const u16 mac_phy_to_speed[] = {\n\t[PHY_INTERFACE_MODE_MII] = MAC_SPEED_100,\n\t[PHY_INTERFACE_MODE_GMII] = MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_SGMII] = MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_TBI] = MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_RMII] = MAC_SPEED_100,\n\t[PHY_INTERFACE_MODE_RGMII] = MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_RGMII_ID] = MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_RGMII_RXID]\t= MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_RGMII_TXID]\t= MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_RTBI] = MAC_SPEED_1000,\n\t[PHY_INTERFACE_MODE_XGMII] = MAC_SPEED_10000\n};\n\nstatic const enum mac_mode g_mac_mode_100[] = {\n\t[PHY_INTERFACE_MODE_MII]\t= MAC_MODE_MII_100,\n\t[PHY_INTERFACE_MODE_RMII]   = MAC_MODE_RMII_100\n};\n\nstatic const enum mac_mode g_mac_mode_1000[] = {\n\t[PHY_INTERFACE_MODE_GMII]   = MAC_MODE_GMII_1000,\n\t[PHY_INTERFACE_MODE_SGMII]  = MAC_MODE_SGMII_1000,\n\t[PHY_INTERFACE_MODE_TBI]\t= MAC_MODE_TBI_1000,\n\t[PHY_INTERFACE_MODE_RGMII]  = MAC_MODE_RGMII_1000,\n\t[PHY_INTERFACE_MODE_RGMII_ID]   = MAC_MODE_RGMII_1000,\n\t[PHY_INTERFACE_MODE_RGMII_RXID] = MAC_MODE_RGMII_1000,\n\t[PHY_INTERFACE_MODE_RGMII_TXID] = MAC_MODE_RGMII_1000,\n\t[PHY_INTERFACE_MODE_RTBI]   = MAC_MODE_RTBI_1000\n};\n\nstatic enum mac_mode hns_get_enet_interface(const struct hns_mac_cb *mac_cb)\n{\n\tswitch (mac_cb->max_speed) {\n\tcase MAC_SPEED_100:\n\t\treturn g_mac_mode_100[mac_cb->phy_if];\n\tcase MAC_SPEED_1000:\n\t\treturn g_mac_mode_1000[mac_cb->phy_if];\n\tcase MAC_SPEED_10000:\n\t\treturn MAC_MODE_XGMII_10000;\n\tdefault:\n\t\treturn MAC_MODE_MII_100;\n\t}\n}\n\nstatic u32 hns_mac_link_anti_shake(struct mac_driver *mac_ctrl_drv)\n{\n#define HNS_MAC_LINK_WAIT_TIME 5\n#define HNS_MAC_LINK_WAIT_CNT 40\n\n\tu32 link_status = 0;\n\tint i;\n\n\tif (!mac_ctrl_drv->get_link_status)\n\t\treturn link_status;\n\n\tfor (i = 0; i < HNS_MAC_LINK_WAIT_CNT; i++) {\n\t\tmsleep(HNS_MAC_LINK_WAIT_TIME);\n\t\tmac_ctrl_drv->get_link_status(mac_ctrl_drv, &link_status);\n\t\tif (!link_status)\n\t\t\tbreak;\n\t}\n\n\treturn link_status;\n}\n\nvoid hns_mac_get_link_status(struct hns_mac_cb *mac_cb, u32 *link_status)\n{\n\tstruct mac_driver *mac_ctrl_drv;\n\tint ret, sfp_prsnt;\n\n\tmac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_ctrl_drv->get_link_status)\n\t\tmac_ctrl_drv->get_link_status(mac_ctrl_drv, link_status);\n\telse\n\t\t*link_status = 0;\n\n\tif (mac_cb->media_type == HNAE_MEDIA_TYPE_FIBER) {\n\t\tret = mac_cb->dsaf_dev->misc_op->get_sfp_prsnt(mac_cb,\n\t\t\t\t\t\t\t       &sfp_prsnt);\n\t\tif (!ret)\n\t\t\t*link_status = *link_status && sfp_prsnt;\n\n\t\t \n\t\tif (*link_status && !mac_cb->link)\n\t\t\t*link_status = hns_mac_link_anti_shake(mac_ctrl_drv);\n\t}\n\n\tmac_cb->link = *link_status;\n}\n\nint hns_mac_get_port_info(struct hns_mac_cb *mac_cb,\n\t\t\t  u8 *auto_neg, u16 *speed, u8 *duplex)\n{\n\tstruct mac_driver *mac_ctrl_drv;\n\tstruct mac_info    info;\n\n\tmac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (!mac_ctrl_drv->get_info)\n\t\treturn -ENODEV;\n\n\tmac_ctrl_drv->get_info(mac_ctrl_drv, &info);\n\tif (auto_neg)\n\t\t*auto_neg = info.auto_neg;\n\tif (speed)\n\t\t*speed = info.speed;\n\tif (duplex)\n\t\t*duplex = info.duplex;\n\n\treturn 0;\n}\n\n \nbool hns_mac_need_adjust_link(struct hns_mac_cb *mac_cb, int speed, int duplex)\n{\n\tstruct mac_driver *mac_ctrl_drv;\n\n\tmac_ctrl_drv = (struct mac_driver *)(mac_cb->priv.mac);\n\n\tif (mac_ctrl_drv->need_adjust_link)\n\t\treturn mac_ctrl_drv->need_adjust_link(mac_ctrl_drv,\n\t\t\t(enum mac_speed)speed, duplex);\n\telse\n\t\treturn true;\n}\n\nvoid hns_mac_adjust_link(struct hns_mac_cb *mac_cb, int speed, int duplex)\n{\n\tint ret;\n\tstruct mac_driver *mac_ctrl_drv;\n\n\tmac_ctrl_drv = (struct mac_driver *)(mac_cb->priv.mac);\n\n\tmac_cb->speed = speed;\n\tmac_cb->half_duplex = !duplex;\n\n\tif (mac_ctrl_drv->adjust_link) {\n\t\tret = mac_ctrl_drv->adjust_link(mac_ctrl_drv,\n\t\t\t(enum mac_speed)speed, duplex);\n\t\tif (ret) {\n\t\t\tdev_err(mac_cb->dev,\n\t\t\t\t\"adjust_link failed, %s mac%d ret = %#x!\\n\",\n\t\t\t\tmac_cb->dsaf_dev->ae_dev.name,\n\t\t\t\tmac_cb->mac_id, ret);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nint hns_mac_get_inner_port_num(struct hns_mac_cb *mac_cb, u8 vmid, u8 *port_num)\n{\n\tint q_num_per_vf, vf_num_per_port;\n\tint vm_queue_id;\n\tu8 tmp_port;\n\n\tif (mac_cb->dsaf_dev->dsaf_mode <= DSAF_MODE_ENABLE) {\n\t\tif (mac_cb->mac_id != DSAF_MAX_PORT_NUM) {\n\t\t\tdev_err(mac_cb->dev,\n\t\t\t\t\"input invalid, %s mac%d vmid%d !\\n\",\n\t\t\t\tmac_cb->dsaf_dev->ae_dev.name,\n\t\t\t\tmac_cb->mac_id, vmid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (mac_cb->dsaf_dev->dsaf_mode < DSAF_MODE_MAX) {\n\t\tif (mac_cb->mac_id >= DSAF_MAX_PORT_NUM) {\n\t\t\tdev_err(mac_cb->dev,\n\t\t\t\t\"input invalid, %s mac%d vmid%d!\\n\",\n\t\t\t\tmac_cb->dsaf_dev->ae_dev.name,\n\t\t\t\tmac_cb->mac_id, vmid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tdev_err(mac_cb->dev, \"dsaf mode invalid, %s mac%d!\\n\",\n\t\t\tmac_cb->dsaf_dev->ae_dev.name, mac_cb->mac_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vmid >= mac_cb->dsaf_dev->rcb_common[0]->max_vfn) {\n\t\tdev_err(mac_cb->dev, \"input invalid, %s mac%d vmid%d !\\n\",\n\t\t\tmac_cb->dsaf_dev->ae_dev.name, mac_cb->mac_id, vmid);\n\t\treturn -EINVAL;\n\t}\n\n\tq_num_per_vf = mac_cb->dsaf_dev->rcb_common[0]->max_q_per_vf;\n\tvf_num_per_port = mac_cb->dsaf_dev->rcb_common[0]->max_vfn;\n\n\tvm_queue_id = vmid * q_num_per_vf +\n\t\t\tvf_num_per_port * q_num_per_vf * mac_cb->mac_id;\n\n\tswitch (mac_cb->dsaf_dev->dsaf_mode) {\n\tcase DSAF_MODE_ENABLE_FIX:\n\t\ttmp_port = 0;\n\t\tbreak;\n\tcase DSAF_MODE_DISABLE_FIX:\n\t\ttmp_port = 0;\n\t\tbreak;\n\tcase DSAF_MODE_ENABLE_0VM:\n\tcase DSAF_MODE_ENABLE_8VM:\n\tcase DSAF_MODE_ENABLE_16VM:\n\tcase DSAF_MODE_ENABLE_32VM:\n\tcase DSAF_MODE_ENABLE_128VM:\n\tcase DSAF_MODE_DISABLE_2PORT_8VM:\n\tcase DSAF_MODE_DISABLE_2PORT_16VM:\n\tcase DSAF_MODE_DISABLE_2PORT_64VM:\n\tcase DSAF_MODE_DISABLE_6PORT_0VM:\n\tcase DSAF_MODE_DISABLE_6PORT_2VM:\n\tcase DSAF_MODE_DISABLE_6PORT_4VM:\n\tcase DSAF_MODE_DISABLE_6PORT_16VM:\n\t\ttmp_port = vm_queue_id;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mac_cb->dev, \"dsaf mode invalid, %s mac%d!\\n\",\n\t\t\tmac_cb->dsaf_dev->ae_dev.name, mac_cb->mac_id);\n\t\treturn -EINVAL;\n\t}\n\ttmp_port += DSAF_BASE_INNER_PORT_NUM;\n\n\t*port_num = tmp_port;\n\n\treturn 0;\n}\n\n \nint hns_mac_change_vf_addr(struct hns_mac_cb *mac_cb,\n\t\t\t   u32 vmid, const char *addr)\n{\n\tint ret;\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tstruct dsaf_drv_mac_single_dest_entry mac_entry;\n\tstruct mac_entry_idx *old_entry;\n\n\told_entry = &mac_cb->addr_entry_idx[vmid];\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\n\t\tmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\n\t\tmac_entry.in_vlan_id = old_entry->vlan_id;\n\t\tmac_entry.in_port_num = mac_cb->mac_id;\n\t\tret = hns_mac_get_inner_port_num(mac_cb, (u8)vmid,\n\t\t\t\t\t\t &mac_entry.port_num);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((old_entry->valid != 0) &&\n\t\t    (memcmp(old_entry->addr,\n\t\t    addr, sizeof(mac_entry.addr)) != 0)) {\n\t\t\tret = hns_dsaf_del_mac_entry(dsaf_dev,\n\t\t\t\t\t\t     old_entry->vlan_id,\n\t\t\t\t\t\t     mac_cb->mac_id,\n\t\t\t\t\t\t     old_entry->addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = hns_dsaf_set_mac_uc_entry(dsaf_dev, &mac_entry);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((mac_ctrl_drv->set_mac_addr) && (vmid == 0))\n\t\tmac_ctrl_drv->set_mac_addr(mac_cb->priv.mac, addr);\n\n\tmemcpy(old_entry->addr, addr, sizeof(old_entry->addr));\n\told_entry->valid = 1;\n\treturn 0;\n}\n\nint hns_mac_add_uc_addr(struct hns_mac_cb *mac_cb, u8 vf_id,\n\t\t\tconst unsigned char *addr)\n{\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tstruct dsaf_drv_mac_single_dest_entry mac_entry;\n\tint ret;\n\n\tif (HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\treturn -ENOSPC;\n\n\tmemset(&mac_entry, 0, sizeof(mac_entry));\n\tmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\n\tmac_entry.in_port_num = mac_cb->mac_id;\n\tret = hns_mac_get_inner_port_num(mac_cb, vf_id, &mac_entry.port_num);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hns_dsaf_set_mac_uc_entry(dsaf_dev, &mac_entry);\n}\n\nint hns_mac_rm_uc_addr(struct hns_mac_cb *mac_cb, u8 vf_id,\n\t\t       const unsigned char *addr)\n{\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tstruct dsaf_drv_mac_single_dest_entry mac_entry;\n\tint ret;\n\n\tif (HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\treturn -ENOSPC;\n\n\tmemset(&mac_entry, 0, sizeof(mac_entry));\n\tmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\n\tmac_entry.in_port_num = mac_cb->mac_id;\n\tret = hns_mac_get_inner_port_num(mac_cb, vf_id, &mac_entry.port_num);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hns_dsaf_rm_mac_addr(dsaf_dev, &mac_entry);\n}\n\nint hns_mac_set_multi(struct hns_mac_cb *mac_cb,\n\t\t      u32 port_num, char *addr, bool enable)\n{\n\tint ret;\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tstruct dsaf_drv_mac_single_dest_entry mac_entry;\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev) && addr) {\n\t\tmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\n\t\tmac_entry.in_vlan_id = 0; \n\t\tmac_entry.in_port_num = mac_cb->mac_id;\n\t\tmac_entry.port_num = port_num;\n\n\t\tif (!enable)\n\t\t\tret = hns_dsaf_del_mac_mc_port(dsaf_dev, &mac_entry);\n\t\telse\n\t\t\tret = hns_dsaf_add_mac_mc_port(dsaf_dev, &mac_entry);\n\t\tif (ret) {\n\t\t\tdev_err(dsaf_dev->dev,\n\t\t\t\t\"set mac mc port failed, %s mac%d ret = %#x!\\n\",\n\t\t\t\tmac_cb->dsaf_dev->ae_dev.name,\n\t\t\t\tmac_cb->mac_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint hns_mac_clr_multicast(struct hns_mac_cb *mac_cb, int vfn)\n{\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tu8 port_num;\n\tint ret = hns_mac_get_inner_port_num(mac_cb, vfn, &port_num);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn hns_dsaf_clr_mac_mc_port(dsaf_dev, mac_cb->mac_id, port_num);\n}\n\nstatic void hns_mac_param_get(struct mac_params *param,\n\t\t\t      struct hns_mac_cb *mac_cb)\n{\n\tparam->vaddr = mac_cb->vaddr;\n\tparam->mac_mode = hns_get_enet_interface(mac_cb);\n\tether_addr_copy(param->addr, mac_cb->addr_entry_idx[0].addr);\n\tparam->mac_id = mac_cb->mac_id;\n\tparam->dev = mac_cb->dev;\n}\n\n \nstatic int hns_mac_port_config_bc_en(struct hns_mac_cb *mac_cb,\n\t\t\t\t     u32 port_num, u16 vlan_id, bool enable)\n{\n\tint ret;\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tstruct dsaf_drv_mac_single_dest_entry mac_entry;\n\n\t \n\tif (mac_cb->mac_type == HNAE_PORT_DEBUG)\n\t\treturn 0;\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\n\t\teth_broadcast_addr(mac_entry.addr);\n\t\tmac_entry.in_vlan_id = vlan_id;\n\t\tmac_entry.in_port_num = mac_cb->mac_id;\n\t\tmac_entry.port_num = port_num;\n\n\t\tif (!enable)\n\t\t\tret = hns_dsaf_del_mac_mc_port(dsaf_dev, &mac_entry);\n\t\telse\n\t\t\tret = hns_dsaf_add_mac_mc_port(dsaf_dev, &mac_entry);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint hns_mac_vm_config_bc_en(struct hns_mac_cb *mac_cb, u32 vmid, bool enable)\n{\n\tint ret;\n\tstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\n\tu8 port_num;\n\tstruct mac_entry_idx *uc_mac_entry;\n\tstruct dsaf_drv_mac_single_dest_entry mac_entry;\n\n\tif (mac_cb->mac_type == HNAE_PORT_DEBUG)\n\t\treturn 0;\n\n\tuc_mac_entry = &mac_cb->addr_entry_idx[vmid];\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev))  {\n\t\teth_broadcast_addr(mac_entry.addr);\n\t\tmac_entry.in_vlan_id = uc_mac_entry->vlan_id;\n\t\tmac_entry.in_port_num = mac_cb->mac_id;\n\t\tret = hns_mac_get_inner_port_num(mac_cb, vmid, &port_num);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmac_entry.port_num = port_num;\n\n\t\tif (!enable)\n\t\t\tret = hns_dsaf_del_mac_mc_port(dsaf_dev, &mac_entry);\n\t\telse\n\t\t\tret = hns_dsaf_add_mac_mc_port(dsaf_dev, &mac_entry);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint hns_mac_wait_fifo_clean(struct hns_mac_cb *mac_cb)\n{\n\tstruct mac_driver *drv = hns_mac_get_drv(mac_cb);\n\n\tif (drv->wait_fifo_clean)\n\t\treturn drv->wait_fifo_clean(drv);\n\n\treturn 0;\n}\n\nvoid hns_mac_reset(struct hns_mac_cb *mac_cb)\n{\n\tstruct mac_driver *drv = hns_mac_get_drv(mac_cb);\n\tbool is_ver1 = AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver);\n\n\tdrv->mac_init(drv);\n\n\tif (drv->config_max_frame_length)\n\t\tdrv->config_max_frame_length(drv, mac_cb->max_frm);\n\n\tif (drv->set_tx_auto_pause_frames)\n\t\tdrv->set_tx_auto_pause_frames(drv, mac_cb->tx_pause_frm_time);\n\n\tif (drv->set_an_mode)\n\t\tdrv->set_an_mode(drv, 1);\n\n\tif (drv->mac_pausefrm_cfg) {\n\t\tif (mac_cb->mac_type == HNAE_PORT_DEBUG)\n\t\t\tdrv->mac_pausefrm_cfg(drv, !is_ver1, !is_ver1);\n\t\telse  \n\t\t\tdrv->mac_pausefrm_cfg(drv, 0, 1);\n\t}\n}\n\nint hns_mac_set_mtu(struct hns_mac_cb *mac_cb, u32 new_mtu, u32 buf_size)\n{\n\tstruct mac_driver *drv = hns_mac_get_drv(mac_cb);\n\tu32 new_frm = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\n\n\tif (new_frm > HNS_RCB_RING_MAX_BD_PER_PKT * buf_size)\n\t\treturn -EINVAL;\n\n\tif (!drv->config_max_frame_length)\n\t\treturn -ECHILD;\n\n\t \n\tif (new_frm < (ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN))\n\t\tnew_frm = (ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN);\n\n\tdrv->config_max_frame_length(drv, new_frm);\n\n\tmac_cb->max_frm = new_frm;\n\n\treturn 0;\n}\n\nvoid hns_mac_start(struct hns_mac_cb *mac_cb)\n{\n\tstruct mac_driver *mac_drv = hns_mac_get_drv(mac_cb);\n\n\t \n\tif (mac_drv->mac_en_flg == MAC_EN_FLAG_V) {\n\t\t \n\t\tmac_drv->virt_dev_num += 1;\n\t\treturn;\n\t}\n\n\tif (mac_drv->mac_enable) {\n\t\tmac_drv->mac_enable(mac_cb->priv.mac, MAC_COMM_MODE_RX_AND_TX);\n\t\tmac_drv->mac_en_flg = MAC_EN_FLAG_V;\n\t}\n}\n\nvoid hns_mac_stop(struct hns_mac_cb *mac_cb)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\t \n\tif (mac_ctrl_drv->virt_dev_num > 0) {\n\t\tmac_ctrl_drv->virt_dev_num -= 1;\n\t\tif (mac_ctrl_drv->virt_dev_num > 0)\n\t\t\treturn;\n\t}\n\n\tif (mac_ctrl_drv->mac_disable)\n\t\tmac_ctrl_drv->mac_disable(mac_cb->priv.mac,\n\t\t\tMAC_COMM_MODE_RX_AND_TX);\n\n\tmac_ctrl_drv->mac_en_flg = 0;\n\tmac_cb->link = 0;\n\tmac_cb->dsaf_dev->misc_op->cpld_reset_led(mac_cb);\n}\n\n \nvoid hns_mac_get_autoneg(struct hns_mac_cb *mac_cb, u32 *auto_neg)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_ctrl_drv->autoneg_stat)\n\t\tmac_ctrl_drv->autoneg_stat(mac_ctrl_drv, auto_neg);\n\telse\n\t\t*auto_neg = 0;\n}\n\n \nvoid hns_mac_get_pauseparam(struct hns_mac_cb *mac_cb, u32 *rx_en, u32 *tx_en)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_ctrl_drv->get_pause_enable) {\n\t\tmac_ctrl_drv->get_pause_enable(mac_ctrl_drv, rx_en, tx_en);\n\t} else {\n\t\t*rx_en = 0;\n\t\t*tx_en = 0;\n\t}\n}\n\n \nint hns_mac_set_autoneg(struct hns_mac_cb *mac_cb, u8 enable)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_cb->phy_if == PHY_INTERFACE_MODE_XGMII && enable) {\n\t\tdev_err(mac_cb->dev, \"enabling autoneg is not allowed!\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (mac_ctrl_drv->set_an_mode)\n\t\tmac_ctrl_drv->set_an_mode(mac_ctrl_drv, enable);\n\n\treturn 0;\n}\n\n \nint hns_mac_set_pauseparam(struct hns_mac_cb *mac_cb, u32 rx_en, u32 tx_en)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\tbool is_ver1 = AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver);\n\n\tif (mac_cb->mac_type == HNAE_PORT_DEBUG) {\n\t\tif (is_ver1 && (tx_en || rx_en)) {\n\t\t\tdev_err(mac_cb->dev, \"macv1 can't enable tx/rx_pause!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (mac_ctrl_drv->mac_pausefrm_cfg)\n\t\tmac_ctrl_drv->mac_pausefrm_cfg(mac_ctrl_drv, rx_en, tx_en);\n\n\treturn 0;\n}\n\n \nstatic int hns_mac_init_ex(struct hns_mac_cb *mac_cb)\n{\n\tint ret;\n\tstruct mac_params param;\n\tstruct mac_driver *drv;\n\n\thns_dsaf_fix_mac_mode(mac_cb);\n\n\tmemset(&param, 0, sizeof(struct mac_params));\n\thns_mac_param_get(&param, mac_cb);\n\n\tif (MAC_SPEED_FROM_MODE(param.mac_mode) < MAC_SPEED_10000)\n\t\tdrv = (struct mac_driver *)hns_gmac_config(mac_cb, &param);\n\telse\n\t\tdrv = (struct mac_driver *)hns_xgmac_config(mac_cb, &param);\n\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tmac_cb->priv.mac = (void *)drv;\n\thns_mac_reset(mac_cb);\n\n\thns_mac_adjust_link(mac_cb, mac_cb->speed, !mac_cb->half_duplex);\n\n\tret = hns_mac_port_config_bc_en(mac_cb, mac_cb->mac_id, 0, true);\n\tif (ret)\n\t\tgoto free_mac_drv;\n\n\treturn 0;\n\nfree_mac_drv:\n\tdrv->mac_free(mac_cb->priv.mac);\n\tmac_cb->priv.mac = NULL;\n\n\treturn ret;\n}\n\nstatic int\nhns_mac_phy_parse_addr(struct device *dev, struct fwnode_handle *fwnode)\n{\n\tu32 addr;\n\tint ret;\n\n\tret = fwnode_property_read_u32(fwnode, \"phy-addr\", &addr);\n\tif (ret) {\n\t\tdev_err(dev, \"has invalid PHY address ret:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (addr >= PHY_MAX_ADDR) {\n\t\tdev_err(dev, \"PHY address %i is too large\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\treturn addr;\n}\n\nstatic int\nhns_mac_register_phydev(struct mii_bus *mdio, struct hns_mac_cb *mac_cb,\n\t\t\tu32 addr)\n{\n\tstruct phy_device *phy;\n\tconst char *phy_type;\n\tbool is_c45;\n\tint rc;\n\n\trc = fwnode_property_read_string(mac_cb->fw_port,\n\t\t\t\t\t \"phy-mode\", &phy_type);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!strcmp(phy_type, phy_modes(PHY_INTERFACE_MODE_XGMII)))\n\t\tis_c45 = true;\n\telse if (!strcmp(phy_type, phy_modes(PHY_INTERFACE_MODE_SGMII)))\n\t\tis_c45 = false;\n\telse\n\t\treturn -ENODATA;\n\n\tphy = get_phy_device(mdio, addr, is_c45);\n\tif (!phy || IS_ERR(phy))\n\t\treturn -EIO;\n\n\tphy->irq = mdio->irq[addr];\n\n\t \n\trc = phy_device_register(phy);\n\tif (rc) {\n\t\tphy_device_free(phy);\n\t\tdev_err(&mdio->dev, \"registered phy fail at address %i\\n\",\n\t\t\taddr);\n\t\treturn -ENODEV;\n\t}\n\n\tmac_cb->phy_dev = phy;\n\n\tdev_dbg(&mdio->dev, \"registered phy at address %i\\n\", addr);\n\n\treturn 0;\n}\n\nstatic int hns_mac_register_phy(struct hns_mac_cb *mac_cb)\n{\n\tstruct fwnode_reference_args args;\n\tstruct platform_device *pdev;\n\tstruct mii_bus *mii_bus;\n\tint rc;\n\tint addr;\n\n\t \n\tif (!to_acpi_device_node(mac_cb->fw_port))\n\t\treturn -ENODEV;\n\n\trc = acpi_node_get_property_reference(\n\t\t\tmac_cb->fw_port, \"mdio-node\", 0, &args);\n\tif (rc)\n\t\treturn rc;\n\tif (!is_acpi_device_node(args.fwnode))\n\t\treturn -EINVAL;\n\n\taddr = hns_mac_phy_parse_addr(mac_cb->dev, mac_cb->fw_port);\n\tif (addr < 0)\n\t\treturn addr;\n\n\t \n\tpdev = hns_dsaf_find_platform_device(args.fwnode);\n\tif (!pdev) {\n\t\tdev_err(mac_cb->dev, \"mac%d mdio pdev is NULL\\n\",\n\t\t\tmac_cb->mac_id);\n\t\treturn  -EINVAL;\n\t}\n\n\tmii_bus = platform_get_drvdata(pdev);\n\tif (!mii_bus) {\n\t\tdev_err(mac_cb->dev,\n\t\t\t\"mac%d mdio is NULL, dsaf will probe again later\\n\",\n\t\t\tmac_cb->mac_id);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\trc = hns_mac_register_phydev(mii_bus, mac_cb, addr);\n\tif (!rc)\n\t\tdev_dbg(mac_cb->dev, \"mac%d register phy addr:%d\\n\",\n\t\t\tmac_cb->mac_id, addr);\n\n\treturn rc;\n}\n\nstatic void hns_mac_remove_phydev(struct hns_mac_cb *mac_cb)\n{\n\tif (!to_acpi_device_node(mac_cb->fw_port) || !mac_cb->phy_dev)\n\t\treturn;\n\n\tphy_device_remove(mac_cb->phy_dev);\n\tphy_device_free(mac_cb->phy_dev);\n\n\tmac_cb->phy_dev = NULL;\n}\n\n#define MAC_MEDIA_TYPE_MAX_LEN\t\t16\n\nstatic const struct {\n\tenum hnae_media_type value;\n\tconst char *name;\n} media_type_defs[] = {\n\t{HNAE_MEDIA_TYPE_UNKNOWN,\t\"unknown\" },\n\t{HNAE_MEDIA_TYPE_FIBER,\t\t\"fiber\" },\n\t{HNAE_MEDIA_TYPE_COPPER,\t\"copper\" },\n\t{HNAE_MEDIA_TYPE_BACKPLANE,\t\"backplane\" },\n};\n\n \nstatic int hns_mac_get_info(struct hns_mac_cb *mac_cb)\n{\n\tstruct device_node *np;\n\tstruct regmap *syscon;\n\tstruct of_phandle_args cpld_args;\n\tconst char *media_type;\n\tu32 i;\n\tu32 ret;\n\n\tmac_cb->link = false;\n\tmac_cb->half_duplex = false;\n\tmac_cb->media_type = HNAE_MEDIA_TYPE_UNKNOWN;\n\tmac_cb->speed = mac_phy_to_speed[mac_cb->phy_if];\n\tmac_cb->max_speed = mac_cb->speed;\n\n\tif (mac_cb->phy_if == PHY_INTERFACE_MODE_SGMII) {\n\t\tmac_cb->if_support = MAC_GMAC_SUPPORTED;\n\t\tmac_cb->if_support |= SUPPORTED_1000baseT_Full;\n\t} else if (mac_cb->phy_if == PHY_INTERFACE_MODE_XGMII) {\n\t\tmac_cb->if_support = SUPPORTED_10000baseR_FEC;\n\t\tmac_cb->if_support |= SUPPORTED_10000baseKR_Full;\n\t}\n\n\tmac_cb->max_frm = MAC_DEFAULT_MTU;\n\tmac_cb->tx_pause_frm_time = MAC_DEFAULT_PAUSE_TIME;\n\tmac_cb->port_rst_off = mac_cb->mac_id;\n\tmac_cb->port_mode_off = 0;\n\n\t \n\tif (!mac_cb->fw_port) {\n\t\tnp = of_parse_phandle(mac_cb->dev->of_node, \"phy-handle\",\n\t\t\t\t      mac_cb->mac_id);\n\t\tmac_cb->phy_dev = of_phy_find_device(np);\n\t\tif (mac_cb->phy_dev) {\n\t\t\t \n\t\t\tput_device(&mac_cb->phy_dev->mdio.dev);\n\n\t\t\tdev_dbg(mac_cb->dev, \"mac%d phy_node: %pOFn\\n\",\n\t\t\t\tmac_cb->mac_id, np);\n\t\t}\n\t\tof_node_put(np);\n\n\t\treturn 0;\n\t}\n\n\tif (is_of_node(mac_cb->fw_port)) {\n\t\t \n\t\tnp = of_parse_phandle(to_of_node(mac_cb->fw_port),\n\t\t\t\t      \"phy-handle\", 0);\n\t\tmac_cb->phy_dev = of_phy_find_device(np);\n\t\tif (mac_cb->phy_dev) {\n\t\t\t \n\t\t\tput_device(&mac_cb->phy_dev->mdio.dev);\n\t\t\tdev_dbg(mac_cb->dev, \"mac%d phy_node: %pOFn\\n\",\n\t\t\t\tmac_cb->mac_id, np);\n\t\t}\n\t\tof_node_put(np);\n\n\t\tnp = of_parse_phandle(to_of_node(mac_cb->fw_port),\n\t\t\t\t      \"serdes-syscon\", 0);\n\t\tsyscon = syscon_node_to_regmap(np);\n\t\tof_node_put(np);\n\t\tif (IS_ERR_OR_NULL(syscon)) {\n\t\t\tdev_err(mac_cb->dev, \"serdes-syscon is needed!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmac_cb->serdes_ctrl = syscon;\n\n\t\tret = fwnode_property_read_u32(mac_cb->fw_port,\n\t\t\t\t\t       \"port-rst-offset\",\n\t\t\t\t\t       &mac_cb->port_rst_off);\n\t\tif (ret) {\n\t\t\tdev_dbg(mac_cb->dev,\n\t\t\t\t\"mac%d port-rst-offset not found, use default value.\\n\",\n\t\t\t\tmac_cb->mac_id);\n\t\t}\n\n\t\tret = fwnode_property_read_u32(mac_cb->fw_port,\n\t\t\t\t\t       \"port-mode-offset\",\n\t\t\t\t\t       &mac_cb->port_mode_off);\n\t\tif (ret) {\n\t\t\tdev_dbg(mac_cb->dev,\n\t\t\t\t\"mac%d port-mode-offset not found, use default value.\\n\",\n\t\t\t\tmac_cb->mac_id);\n\t\t}\n\n\t\tret = of_parse_phandle_with_fixed_args(\n\t\t\tto_of_node(mac_cb->fw_port), \"cpld-syscon\", 1, 0,\n\t\t\t&cpld_args);\n\t\tif (ret) {\n\t\t\tdev_dbg(mac_cb->dev, \"mac%d no cpld-syscon found.\\n\",\n\t\t\t\tmac_cb->mac_id);\n\t\t\tmac_cb->cpld_ctrl = NULL;\n\t\t} else {\n\t\t\tsyscon = syscon_node_to_regmap(cpld_args.np);\n\t\t\tif (IS_ERR_OR_NULL(syscon)) {\n\t\t\t\tdev_dbg(mac_cb->dev, \"no cpld-syscon found!\\n\");\n\t\t\t\tmac_cb->cpld_ctrl = NULL;\n\t\t\t} else {\n\t\t\t\tmac_cb->cpld_ctrl = syscon;\n\t\t\t\tmac_cb->cpld_ctrl_reg = cpld_args.args[0];\n\t\t\t}\n\t\t}\n\t} else if (is_acpi_node(mac_cb->fw_port)) {\n\t\tret = hns_mac_register_phy(mac_cb);\n\t\t \n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t} else {\n\t\tdev_err(mac_cb->dev, \"mac%d cannot find phy node\\n\",\n\t\t\tmac_cb->mac_id);\n\t}\n\n\tif (!fwnode_property_read_string(mac_cb->fw_port, \"media-type\",\n\t\t\t\t\t &media_type)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(media_type_defs); i++) {\n\t\t\tif (!strncmp(media_type_defs[i].name, media_type,\n\t\t\t\t     MAC_MEDIA_TYPE_MAX_LEN)) {\n\t\t\t\tmac_cb->media_type = media_type_defs[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fwnode_property_read_u8_array(mac_cb->fw_port, \"mc-mac-mask\",\n\t\t\t\t\t  mac_cb->mc_mask, ETH_ALEN)) {\n\t\tdev_warn(mac_cb->dev,\n\t\t\t \"no mc-mac-mask property, set to default value.\\n\");\n\t\teth_broadcast_addr(mac_cb->mc_mask);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hns_mac_get_mode(phy_interface_t phy_if)\n{\n\tswitch (phy_if) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\treturn MAC_GMAC_IDX;\n\tcase PHY_INTERFACE_MODE_XGMII:\n\t\treturn MAC_XGMAC_IDX;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u8 __iomem *\nhns_mac_get_vaddr(struct dsaf_device *dsaf_dev,\n\t\t  struct hns_mac_cb *mac_cb, u32 mac_mode_idx)\n{\n\tu8 __iomem *base = dsaf_dev->io_base;\n\tint mac_id = mac_cb->mac_id;\n\n\tif (mac_cb->mac_type == HNAE_PORT_SERVICE)\n\t\treturn base + 0x40000 + mac_id * 0x4000 -\n\t\t\t\tmac_mode_idx * 0x20000;\n\telse\n\t\treturn dsaf_dev->ppe_base + 0x1000;\n}\n\n \nstatic int\nhns_mac_get_cfg(struct dsaf_device *dsaf_dev, struct hns_mac_cb *mac_cb)\n{\n\tint ret;\n\tu32 mac_mode_idx;\n\n\tmac_cb->dsaf_dev = dsaf_dev;\n\tmac_cb->dev = dsaf_dev->dev;\n\n\tmac_cb->sys_ctl_vaddr =\tdsaf_dev->sc_base;\n\tmac_cb->serdes_vaddr = dsaf_dev->sds_base;\n\n\tmac_cb->sfp_prsnt = 0;\n\tmac_cb->txpkt_for_led = 0;\n\tmac_cb->rxpkt_for_led = 0;\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\tmac_cb->mac_type = HNAE_PORT_SERVICE;\n\telse\n\t\tmac_cb->mac_type = HNAE_PORT_DEBUG;\n\n\tmac_cb->phy_if = dsaf_dev->misc_op->get_phy_if(mac_cb);\n\n\tret = hns_mac_get_mode(mac_cb->phy_if);\n\tif (ret < 0) {\n\t\tdev_err(dsaf_dev->dev,\n\t\t\t\"hns_mac_get_mode failed, mac%d ret = %#x!\\n\",\n\t\t\tmac_cb->mac_id, ret);\n\t\treturn ret;\n\t}\n\tmac_mode_idx = (u32)ret;\n\n\tret  = hns_mac_get_info(mac_cb);\n\tif (ret)\n\t\treturn ret;\n\n\tmac_cb->dsaf_dev->misc_op->cpld_reset_led(mac_cb);\n\tmac_cb->vaddr = hns_mac_get_vaddr(dsaf_dev, mac_cb, mac_mode_idx);\n\n\treturn 0;\n}\n\nstatic int hns_mac_get_max_port_num(struct dsaf_device *dsaf_dev)\n{\n\tif (HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\treturn 1;\n\telse\n\t\treturn  DSAF_MAX_PORT_NUM;\n}\n\nvoid hns_mac_enable(struct hns_mac_cb *mac_cb, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tmac_ctrl_drv->mac_enable(mac_cb->priv.mac, mode);\n}\n\nvoid hns_mac_disable(struct hns_mac_cb *mac_cb, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tmac_ctrl_drv->mac_disable(mac_cb->priv.mac, mode);\n}\n\n \nint hns_mac_init(struct dsaf_device *dsaf_dev)\n{\n\tbool found = false;\n\tint ret;\n\tu32 port_id;\n\tint max_port_num = hns_mac_get_max_port_num(dsaf_dev);\n\tstruct hns_mac_cb *mac_cb;\n\tstruct fwnode_handle *child;\n\n\tdevice_for_each_child_node(dsaf_dev->dev, child) {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &port_id);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\tdev_err(dsaf_dev->dev,\n\t\t\t\t\"get reg fail, ret=%d!\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (port_id >= max_port_num) {\n\t\t\tfwnode_handle_put(child);\n\t\t\tdev_err(dsaf_dev->dev,\n\t\t\t\t\"reg(%u) out of range!\\n\", port_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmac_cb = devm_kzalloc(dsaf_dev->dev, sizeof(*mac_cb),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!mac_cb) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmac_cb->fw_port = child;\n\t\tmac_cb->mac_id = (u8)port_id;\n\t\tdsaf_dev->mac_cb[port_id] = mac_cb;\n\t\tfound = true;\n\t}\n\n\t \n\tif (!found) {\n\t\tfor (port_id = 0; port_id < max_port_num; port_id++) {\n\t\t\tmac_cb = devm_kzalloc(dsaf_dev->dev, sizeof(*mac_cb),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!mac_cb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmac_cb->mac_id = port_id;\n\t\t\tdsaf_dev->mac_cb[port_id] = mac_cb;\n\t\t}\n\t}\n\n\t \n\tfor (port_id = 0; port_id < max_port_num; port_id++) {\n\t\tmac_cb = dsaf_dev->mac_cb[port_id];\n\t\tif (!mac_cb)\n\t\t\tcontinue;\n\n\t\tret = hns_mac_get_cfg(dsaf_dev, mac_cb);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hns_mac_init_ex(mac_cb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid hns_mac_uninit(struct dsaf_device *dsaf_dev)\n{\n\tint i;\n\tint max_port_num = hns_mac_get_max_port_num(dsaf_dev);\n\n\tfor (i = 0; i < max_port_num; i++) {\n\t\tif (!dsaf_dev->mac_cb[i])\n\t\t\tcontinue;\n\n\t\tdsaf_dev->misc_op->cpld_reset_led(dsaf_dev->mac_cb[i]);\n\t\thns_mac_remove_phydev(dsaf_dev->mac_cb[i]);\n\t\tdsaf_dev->mac_cb[i] = NULL;\n\t}\n}\n\nint hns_mac_config_mac_loopback(struct hns_mac_cb *mac_cb,\n\t\t\t\tenum hnae_loop loop, int en)\n{\n\tint ret;\n\tstruct mac_driver *drv = hns_mac_get_drv(mac_cb);\n\n\tif (drv->config_loopback)\n\t\tret = drv->config_loopback(drv, loop, en);\n\telse\n\t\tret = -ENOTSUPP;\n\n\treturn ret;\n}\n\nvoid hns_mac_update_stats(struct hns_mac_cb *mac_cb)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tmac_ctrl_drv->update_stats(mac_ctrl_drv);\n}\n\nvoid hns_mac_get_stats(struct hns_mac_cb *mac_cb, u64 *data)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tmac_ctrl_drv->get_ethtool_stats(mac_ctrl_drv, data);\n}\n\nvoid hns_mac_get_strings(struct hns_mac_cb *mac_cb,\n\t\t\t int stringset, u8 *data)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tmac_ctrl_drv->get_strings(stringset, data);\n}\n\nint hns_mac_get_sset_count(struct hns_mac_cb *mac_cb, int stringset)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\treturn mac_ctrl_drv->get_sset_count(stringset);\n}\n\nvoid hns_mac_set_promisc(struct hns_mac_cb *mac_cb, u8 en)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\thns_dsaf_set_promisc_tcam(mac_cb->dsaf_dev, mac_cb->mac_id, !!en);\n\n\tif (mac_ctrl_drv->set_promiscuous)\n\t\tmac_ctrl_drv->set_promiscuous(mac_ctrl_drv, en);\n}\n\nint hns_mac_get_regs_count(struct hns_mac_cb *mac_cb)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\treturn mac_ctrl_drv->get_regs_count();\n}\n\nvoid hns_mac_get_regs(struct hns_mac_cb *mac_cb, void *data)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tmac_ctrl_drv->get_regs(mac_ctrl_drv, data);\n}\n\nvoid hns_set_led_opt(struct hns_mac_cb *mac_cb)\n{\n\tint nic_data;\n\tint txpkts, rxpkts;\n\n\ttxpkts = mac_cb->txpkt_for_led - mac_cb->hw_stats.tx_good_pkts;\n\trxpkts = mac_cb->rxpkt_for_led - mac_cb->hw_stats.rx_good_pkts;\n\tif (txpkts || rxpkts)\n\t\tnic_data = 1;\n\telse\n\t\tnic_data = 0;\n\tmac_cb->txpkt_for_led = mac_cb->hw_stats.tx_good_pkts;\n\tmac_cb->rxpkt_for_led = mac_cb->hw_stats.rx_good_pkts;\n\tmac_cb->dsaf_dev->misc_op->cpld_set_led(mac_cb, (int)mac_cb->link,\n\t\t\t mac_cb->speed, nic_data);\n}\n\nint hns_cpld_led_set_id(struct hns_mac_cb *mac_cb,\n\t\t\tenum hnae_led_state status)\n{\n\tif (!mac_cb)\n\t\treturn 0;\n\n\treturn mac_cb->dsaf_dev->misc_op->cpld_set_led_id(mac_cb, status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}