{
  "module_name": "hns_ethtool.c",
  "hash_id": "64031680f9b9fff6cbb18fc39432514369b047765b05dc389dcdc9d7cd24889d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns/hns_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include \"hns_enet.h\"\n\n#define HNS_PHY_PAGE_MDIX\t0\n#define HNS_PHY_PAGE_LED\t3\n#define HNS_PHY_PAGE_COPPER\t0\n\n#define HNS_PHY_PAGE_REG\t22\t \n#define HNS_PHY_CSC_REG\t\t16\t \n#define HNS_PHY_CSS_REG\t\t17\t \n#define HNS_LED_FC_REG\t\t16\t \n\n#define HNS_LED_FORCE_ON\t9\n#define HNS_LED_FORCE_OFF\t8\n\n#define HNS_CHIP_VERSION 660\n#define HNS_NET_STATS_CNT 26\n\n#define PHY_MDIX_CTRL_S\t\t(5)\n#define PHY_MDIX_CTRL_M\t\t(3 << PHY_MDIX_CTRL_S)\n\n#define PHY_MDIX_STATUS_B\t(6)\n#define PHY_SPEED_DUP_RESOLVE_B\t(11)\n\n \nstatic u32 hns_nic_get_link(struct net_device *net_dev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tu32 link_stat = priv->link;\n\tstruct hnae_handle *h;\n\n\th = priv->ae_handle;\n\n\tif (net_dev->phydev) {\n\t\tif (!genphy_read_status(net_dev->phydev))\n\t\t\tlink_stat = net_dev->phydev->link;\n\t\telse\n\t\t\tlink_stat = 0;\n\t}\n\n\tif (h->dev && h->dev->ops && h->dev->ops->get_status)\n\t\tlink_stat = link_stat && h->dev->ops->get_status(h);\n\telse\n\t\tlink_stat = 0;\n\n\treturn link_stat;\n}\n\nstatic void hns_get_mdix_mode(struct net_device *net_dev,\n\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tint mdix_ctrl, mdix, retval, is_resolved;\n\tstruct phy_device *phy_dev = net_dev->phydev;\n\n\tif (!phy_dev || !phy_dev->mdio.bus) {\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_INVALID;\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\t\treturn;\n\t}\n\n\tphy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_MDIX);\n\n\tretval = phy_read(phy_dev, HNS_PHY_CSC_REG);\n\tmdix_ctrl = hnae_get_field(retval, PHY_MDIX_CTRL_M, PHY_MDIX_CTRL_S);\n\n\tretval = phy_read(phy_dev, HNS_PHY_CSS_REG);\n\tmdix = hnae_get_bit(retval, PHY_MDIX_STATUS_B);\n\tis_resolved = hnae_get_bit(retval, PHY_SPEED_DUP_RESOLVE_B);\n\n\tphy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_COPPER);\n\n\tswitch (mdix_ctrl) {\n\tcase 0x0:\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI;\n\t\tbreak;\n\tcase 0x1:\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_X;\n\t\tbreak;\n\tcase 0x3:\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\n\t\tbreak;\n\tdefault:\n\t\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_INVALID;\n\t\tbreak;\n\t}\n\n\tif (!is_resolved)\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\telse if (mdix)\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_X;\n\telse\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI;\n}\n\n \nstatic int hns_nic_get_link_ksettings(struct net_device *net_dev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_handle *h;\n\tu32 link_stat;\n\tint ret;\n\tu8 duplex;\n\tu16 speed;\n\tu32 supported, advertising;\n\n\tif (!priv || !priv->ae_handle)\n\t\treturn -ESRCH;\n\n\th = priv->ae_handle;\n\tif (!h->dev || !h->dev->ops || !h->dev->ops->get_info)\n\t\treturn -ESRCH;\n\n\tret = h->dev->ops->get_info(h, NULL, &speed, &duplex);\n\tif (ret < 0) {\n\t\tnetdev_err(net_dev, \"%s get_info error!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tethtool_convert_link_mode_to_legacy_u32(&supported,\n\t\t\t\t\t\tcmd->link_modes.supported);\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\t \n\tcmd->base.autoneg = false;\n\tcmd->base.speed = speed;\n\tcmd->base.duplex = duplex;\n\n\tif (net_dev->phydev)\n\t\tphy_ethtool_ksettings_get(net_dev->phydev, cmd);\n\n\tlink_stat = hns_nic_get_link(net_dev);\n\tif (!link_stat) {\n\t\tcmd->base.speed = (u32)SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tif (cmd->base.autoneg)\n\t\tadvertising |= ADVERTISED_Autoneg;\n\n\tsupported |= h->if_support;\n\tif (h->phy_if == PHY_INTERFACE_MODE_SGMII) {\n\t\tsupported |= SUPPORTED_TP;\n\t\tadvertising |= ADVERTISED_1000baseT_Full;\n\t} else if (h->phy_if == PHY_INTERFACE_MODE_XGMII) {\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tadvertising |= ADVERTISED_10000baseKR_Full;\n\t}\n\n\tswitch (h->media_type) {\n\tcase HNAE_MEDIA_TYPE_FIBER:\n\t\tcmd->base.port = PORT_FIBRE;\n\t\tbreak;\n\tcase HNAE_MEDIA_TYPE_COPPER:\n\t\tcmd->base.port = PORT_TP;\n\t\tbreak;\n\tcase HNAE_MEDIA_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!(AE_IS_VER1(priv->enet_ver) && h->port_type == HNAE_PORT_DEBUG))\n\t\tsupported |= SUPPORTED_Pause;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\tcmd->base.mdio_support = ETH_MDIO_SUPPORTS_C45 | ETH_MDIO_SUPPORTS_C22;\n\thns_get_mdix_mode(net_dev, cmd);\n\n\treturn 0;\n}\n\n \nstatic int hns_nic_set_link_ksettings(struct net_device *net_dev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_handle *h;\n\tu32 speed;\n\n\tif (!netif_running(net_dev))\n\t\treturn -ESRCH;\n\n\tif (!priv || !priv->ae_handle || !priv->ae_handle->dev ||\n\t    !priv->ae_handle->dev->ops)\n\t\treturn -ENODEV;\n\n\th = priv->ae_handle;\n\tspeed = cmd->base.speed;\n\n\tif (h->phy_if == PHY_INTERFACE_MODE_XGMII) {\n\t\tif (cmd->base.autoneg == AUTONEG_ENABLE ||\n\t\t    speed != SPEED_10000 ||\n\t\t    cmd->base.duplex != DUPLEX_FULL)\n\t\t\treturn -EINVAL;\n\t} else if (h->phy_if == PHY_INTERFACE_MODE_SGMII) {\n\t\tif (!net_dev->phydev && cmd->base.autoneg == AUTONEG_ENABLE)\n\t\t\treturn -EINVAL;\n\n\t\tif (speed == SPEED_1000 && cmd->base.duplex == DUPLEX_HALF)\n\t\t\treturn -EINVAL;\n\t\tif (net_dev->phydev)\n\t\t\treturn phy_ethtool_ksettings_set(net_dev->phydev, cmd);\n\n\t\tif ((speed != SPEED_10 && speed != SPEED_100 &&\n\t\t     speed != SPEED_1000) || (cmd->base.duplex != DUPLEX_HALF &&\n\t\t     cmd->base.duplex != DUPLEX_FULL))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tnetdev_err(net_dev, \"Not supported!\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (h->dev->ops->adjust_link) {\n\t\tnetif_carrier_off(net_dev);\n\t\th->dev->ops->adjust_link(h, (int)speed, cmd->base.duplex);\n\t\tnetif_carrier_on(net_dev);\n\t\treturn 0;\n\t}\n\n\tnetdev_err(net_dev, \"Not supported!\");\n\treturn -ENOTSUPP;\n}\n\nstatic const char hns_nic_test_strs[][ETH_GSTRING_LEN] = {\n\t\"Mac    Loopback test\",\n\t\"Serdes Loopback test\",\n\t\"Phy    Loopback test\"\n};\n\nstatic int hns_nic_config_phy_loopback(struct phy_device *phy_dev, u8 en)\n{\n\tint err;\n\n\tif (en) {\n\t\t \n\t\terr = phy_resume(phy_dev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = phy_loopback(phy_dev, true);\n\t} else {\n\t\terr = phy_loopback(phy_dev, false);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = phy_suspend(phy_dev);\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int __lb_setup(struct net_device *ndev,\n\t\t      enum hnae_loop loop)\n{\n\tint ret = 0;\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct phy_device *phy_dev = ndev->phydev;\n\tstruct hnae_handle *h = priv->ae_handle;\n\n\tswitch (loop) {\n\tcase MAC_INTERNALLOOP_PHY:\n\t\tret = hns_nic_config_phy_loopback(phy_dev, 0x1);\n\t\tif (!ret)\n\t\t\tret = h->dev->ops->set_loopback(h, loop, 0x1);\n\t\tbreak;\n\tcase MAC_INTERNALLOOP_MAC:\n\t\tif ((h->dev->ops->set_loopback) &&\n\t\t    (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII))\n\t\t\tret = h->dev->ops->set_loopback(h, loop, 0x1);\n\t\tbreak;\n\tcase MAC_INTERNALLOOP_SERDES:\n\t\tif (h->dev->ops->set_loopback)\n\t\t\tret = h->dev->ops->set_loopback(h, loop, 0x1);\n\t\tbreak;\n\tcase MAC_LOOP_PHY_NONE:\n\t\tret = hns_nic_config_phy_loopback(phy_dev, 0x0);\n\t\tfallthrough;\n\tcase MAC_LOOP_NONE:\n\t\tif (!ret && h->dev->ops->set_loopback) {\n\t\t\tif (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII)\n\t\t\t\tret = h->dev->ops->set_loopback(h,\n\t\t\t\t\tMAC_INTERNALLOOP_MAC, 0x0);\n\n\t\t\tif (!ret)\n\t\t\t\tret = h->dev->ops->set_loopback(h,\n\t\t\t\t\tMAC_INTERNALLOOP_SERDES, 0x0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tif (loop == MAC_LOOP_NONE)\n\t\t\th->dev->ops->set_promisc_mode(\n\t\t\t\th, ndev->flags & IFF_PROMISC);\n\t\telse\n\t\t\th->dev->ops->set_promisc_mode(h, 1);\n\t}\n\treturn ret;\n}\n\nstatic int __lb_up(struct net_device *ndev,\n\t\t   enum hnae_loop loop_mode)\n{\n#define NIC_LB_TEST_WAIT_PHY_LINK_TIME 300\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tint speed, duplex;\n\tint ret;\n\n\thns_nic_net_reset(ndev);\n\n\tret = __lb_setup(ndev, loop_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(200);\n\n\tret = h->dev->ops->start ? h->dev->ops->start(h) : 0;\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII)\n\t\tspeed = 1000;\n\telse\n\t\tspeed = 10000;\n\tduplex = 1;\n\n\th->dev->ops->adjust_link(h, speed, duplex);\n\n\t \n\tmsleep(NIC_LB_TEST_WAIT_PHY_LINK_TIME);\n\n\treturn 0;\n}\n\nstatic void __lb_other_process(struct hns_nic_ring_data *ring_data,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct net_device *ndev;\n\tstruct hns_nic_priv *priv;\n\tstruct hnae_ring *ring;\n\tstruct netdev_queue *dev_queue;\n\tstruct sk_buff *new_skb;\n\tunsigned int frame_size;\n\tint check_ok;\n\tu32 i;\n\tchar buff[33];  \n\n\tif (!ring_data) {  \n\t\tndev = skb->dev;\n\t\tpriv = netdev_priv(ndev);\n\n\t\tframe_size = skb->len;\n\t\tmemset(skb->data, 0xFF, frame_size);\n\t\tif ((!AE_IS_VER1(priv->enet_ver)) &&\n\t\t    (priv->ae_handle->port_type == HNAE_PORT_SERVICE)) {\n\t\t\tmemcpy(skb->data, ndev->dev_addr, 6);\n\t\t\tskb->data[5] += 0x1f;\n\t\t}\n\n\t\tframe_size &= ~1ul;\n\t\tmemset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);\n\t\tmemset(&skb->data[frame_size / 2 + 10], 0xBE,\n\t\t       frame_size / 2 - 11);\n\t\tmemset(&skb->data[frame_size / 2 + 12], 0xAF,\n\t\t       frame_size / 2 - 13);\n\t\treturn;\n\t}\n\n\tring = ring_data->ring;\n\tndev = ring_data->napi.dev;\n\tif (is_tx_ring(ring)) {  \n\t\tdev_queue = netdev_get_tx_queue(ndev, ring_data->queue_index);\n\t\tnetdev_tx_reset_queue(dev_queue);\n\t\treturn;\n\t}\n\n\tframe_size = skb->len;\n\tframe_size &= ~1ul;\n\t \n\tnew_skb = skb_copy(skb, GFP_ATOMIC);\n\tdev_kfree_skb_any(skb);\n\tif (!new_skb) {\n\t\tnetdev_err(ndev, \"skb alloc failed\\n\");\n\t\treturn;\n\t}\n\tskb = new_skb;\n\n\tcheck_ok = 0;\n\tif (*(skb->data + 10) == 0xFF) {  \n\t\tif ((*(skb->data + frame_size / 2 + 10) == 0xBE) &&\n\t\t    (*(skb->data + frame_size / 2 + 12) == 0xAF))\n\t\t\tcheck_ok = 1;\n\t}\n\n\tif (check_ok) {\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += skb->len;\n\t} else {\n\t\tndev->stats.rx_frame_errors++;\n\t\tfor (i = 0; i < skb->len; i++) {\n\t\t\tsnprintf(buff + i % 16 * 2, 3,  \n\t\t\t\t \"%02x\", *(skb->data + i));\n\t\t\tif ((i % 16 == 15) || (i == skb->len - 1))\n\t\t\t\tpr_info(\"%s\\n\", buff);\n\t\t}\n\t}\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int __lb_clean_rings(struct hns_nic_priv *priv,\n\t\t\t    int ringid0, int ringid1, int budget)\n{\n\tint i, ret;\n\tstruct hns_nic_ring_data *ring_data;\n\tstruct net_device *ndev = priv->netdev;\n\tunsigned long rx_packets = ndev->stats.rx_packets;\n\tunsigned long rx_bytes = ndev->stats.rx_bytes;\n\tunsigned long rx_frame_errors = ndev->stats.rx_frame_errors;\n\n\tfor (i = ringid0; i <= ringid1; i++) {\n\t\tring_data = &priv->ring_data[i];\n\t\t(void)ring_data->poll_one(ring_data,\n\t\t\t\t\t  budget, __lb_other_process);\n\t}\n\tret = (int)(ndev->stats.rx_packets - rx_packets);\n\tndev->stats.rx_packets = rx_packets;\n\tndev->stats.rx_bytes = rx_bytes;\n\tndev->stats.rx_frame_errors = rx_frame_errors;\n\treturn ret;\n}\n\n \nstatic int __lb_run_test(struct net_device *ndev,\n\t\t\t enum hnae_loop loop_mode)\n{\n#define NIC_LB_TEST_PKT_NUM_PER_CYCLE 1\n#define NIC_LB_TEST_RING_ID 0\n#define NIC_LB_TEST_FRAME_SIZE 128\n \n#define NIC_LB_TEST_NO_MEM_ERR 1\n#define NIC_LB_TEST_TX_CNT_ERR 2\n#define NIC_LB_TEST_RX_CNT_ERR 3\n\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tint i, j, lc, good_cnt, ret_val = 0;\n\tunsigned int size;\n\tnetdev_tx_t tx_ret_val;\n\tstruct sk_buff *skb;\n\n\tsize = NIC_LB_TEST_FRAME_SIZE;\n\t \n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NIC_LB_TEST_NO_MEM_ERR;\n\n\t \n\t(void)skb_put(skb, size);\n\tskb->dev = ndev;\n\t__lb_other_process(NULL, skb);\n\tskb->queue_mapping = NIC_LB_TEST_RING_ID;\n\n\tlc = 1;\n\tfor (j = 0; j < lc; j++) {\n\t\t \n\t\tgood_cnt = 0;\n\t\t \n\t\tfor (i = 0; i < NIC_LB_TEST_PKT_NUM_PER_CYCLE; i++) {\n\t\t\t(void)skb_get(skb);\n\n\t\t\ttx_ret_val = (netdev_tx_t)hns_nic_net_xmit_hw(\n\t\t\t\tndev, skb,\n\t\t\t\t&tx_ring_data(priv, skb->queue_mapping));\n\t\t\tif (tx_ret_val == NETDEV_TX_OK)\n\t\t\t\tgood_cnt++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (good_cnt != NIC_LB_TEST_PKT_NUM_PER_CYCLE) {\n\t\t\tret_val = NIC_LB_TEST_TX_CNT_ERR;\n\t\t\tdev_err(priv->dev, \"%s sent fail, cnt=0x%x, budget=0x%x\\n\",\n\t\t\t\thns_nic_test_strs[loop_mode], good_cnt,\n\t\t\t\tNIC_LB_TEST_PKT_NUM_PER_CYCLE);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmsleep(100);\n\n\t\tgood_cnt = __lb_clean_rings(priv,\n\t\t\t\t\t    h->q_num, h->q_num * 2 - 1,\n\t\t\t\t\t    NIC_LB_TEST_PKT_NUM_PER_CYCLE);\n\t\tif (good_cnt != NIC_LB_TEST_PKT_NUM_PER_CYCLE) {\n\t\t\tret_val = NIC_LB_TEST_RX_CNT_ERR;\n\t\t\tdev_err(priv->dev, \"%s recv fail, cnt=0x%x, budget=0x%x\\n\",\n\t\t\t\thns_nic_test_strs[loop_mode], good_cnt,\n\t\t\t\tNIC_LB_TEST_PKT_NUM_PER_CYCLE);\n\t\t\tbreak;\n\t\t}\n\t\t(void)__lb_clean_rings(priv,\n\t\t\t\t       NIC_LB_TEST_RING_ID, NIC_LB_TEST_RING_ID,\n\t\t\t\t       NIC_LB_TEST_PKT_NUM_PER_CYCLE);\n\t}\n\n\t \n\tkfree_skb(skb);\n\n\treturn ret_val;\n}\n\nstatic int __lb_down(struct net_device *ndev, enum hnae_loop loop)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tint ret;\n\n\tif (loop == MAC_INTERNALLOOP_PHY)\n\t\tret = __lb_setup(ndev, MAC_LOOP_PHY_NONE);\n\telse\n\t\tret = __lb_setup(ndev, MAC_LOOP_NONE);\n\tif (ret)\n\t\tnetdev_err(ndev, \"%s: __lb_setup return error(%d)!\\n\",\n\t\t\t   __func__,\n\t\t\t   ret);\n\n\tif (h->dev->ops->stop)\n\t\th->dev->ops->stop(h);\n\n\tusleep_range(10000, 20000);\n\t(void)__lb_clean_rings(priv, 0, h->q_num - 1, 256);\n\n\thns_nic_net_reset(ndev);\n\n\treturn 0;\n}\n\n \nstatic void hns_nic_self_test(struct net_device *ndev,\n\t\t\t      struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tbool if_running = netif_running(ndev);\n#define SELF_TEST_TPYE_NUM 3\n\tint st_param[SELF_TEST_TPYE_NUM][2];\n\tint i;\n\tint test_index = 0;\n\n\tst_param[0][0] = MAC_INTERNALLOOP_MAC;  \n\tst_param[0][1] = (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII);\n\tst_param[1][0] = MAC_INTERNALLOOP_SERDES;\n\tst_param[1][1] = 1;  \n\tst_param[2][0] = MAC_INTERNALLOOP_PHY;  \n\tst_param[2][1] = ((!!(priv->ae_handle->phy_dev)) &&\n\t\t(priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII));\n\n\tif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\n\t\tset_bit(NIC_STATE_TESTING, &priv->state);\n\n\t\tif (if_running)\n\t\t\tdev_close(ndev);\n\n\t\tfor (i = 0; i < SELF_TEST_TPYE_NUM; i++) {\n\t\t\tif (!st_param[i][1])\n\t\t\t\tcontinue;\t \n\n\t\t\tdata[test_index] = __lb_up(ndev,\n\t\t\t\t(enum hnae_loop)st_param[i][0]);\n\t\t\tif (!data[test_index]) {\n\t\t\t\tdata[test_index] = __lb_run_test(\n\t\t\t\t\tndev, (enum hnae_loop)st_param[i][0]);\n\t\t\t\t(void)__lb_down(ndev,\n\t\t\t\t\t\t(enum hnae_loop)st_param[i][0]);\n\t\t\t}\n\n\t\t\tif (data[test_index])\n\t\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\t\ttest_index++;\n\t\t}\n\n\t\thns_nic_net_reset(priv->netdev);\n\n\t\tclear_bit(NIC_STATE_TESTING, &priv->state);\n\n\t\tif (if_running)\n\t\t\t(void)dev_open(ndev, NULL);\n\t}\n\t \n\n\t(void)msleep_interruptible(4 * 1000);\n}\n\n \nstatic void hns_nic_get_drvinfo(struct net_device *net_dev,\n\t\t\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\n\tstrscpy(drvinfo->version, HNAE_DRIVER_VERSION,\n\t\tsizeof(drvinfo->version));\n\n\tstrscpy(drvinfo->driver, HNAE_DRIVER_NAME, sizeof(drvinfo->driver));\n\n\tstrscpy(drvinfo->bus_info, priv->dev->bus->name,\n\t\tsizeof(drvinfo->bus_info));\n\n\tstrscpy(drvinfo->fw_version, \"N/A\", ETHTOOL_FWVERS_LEN);\n\tdrvinfo->eedump_len = 0;\n}\n\n \nstatic void hns_get_ringparam(struct net_device *net_dev,\n\t\t\t      struct ethtool_ringparam *param,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_ae_ops *ops;\n\tstruct hnae_queue *queue;\n\tu32 uplimit = 0;\n\n\tqueue = priv->ae_handle->qs[0];\n\tops = priv->ae_handle->dev->ops;\n\n\tif (ops->get_ring_bdnum_limit)\n\t\tops->get_ring_bdnum_limit(queue, &uplimit);\n\n\tparam->rx_max_pending = uplimit;\n\tparam->tx_max_pending = uplimit;\n\tparam->rx_pending = queue->rx_ring.desc_num;\n\tparam->tx_pending = queue->tx_ring.desc_num;\n}\n\n \nstatic void hns_get_pauseparam(struct net_device *net_dev,\n\t\t\t       struct ethtool_pauseparam *param)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_ae_ops *ops;\n\n\tops = priv->ae_handle->dev->ops;\n\n\tif (ops->get_pauseparam)\n\t\tops->get_pauseparam(priv->ae_handle, &param->autoneg,\n\t\t\t\t\t    &param->rx_pause, &param->tx_pause);\n}\n\n \nstatic int hns_set_pauseparam(struct net_device *net_dev,\n\t\t\t      struct ethtool_pauseparam *param)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_handle *h;\n\tstruct hnae_ae_ops *ops;\n\n\th = priv->ae_handle;\n\tops = h->dev->ops;\n\n\tif (!ops->set_pauseparam)\n\t\treturn -ESRCH;\n\n\treturn ops->set_pauseparam(priv->ae_handle, param->autoneg,\n\t\t\t\t   param->rx_pause, param->tx_pause);\n}\n\n \nstatic int hns_get_coalesce(struct net_device *net_dev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_ae_ops *ops;\n\n\tops = priv->ae_handle->dev->ops;\n\n\tec->use_adaptive_rx_coalesce = priv->ae_handle->coal_adapt_en;\n\tec->use_adaptive_tx_coalesce = priv->ae_handle->coal_adapt_en;\n\n\tif ((!ops->get_coalesce_usecs) ||\n\t    (!ops->get_max_coalesced_frames))\n\t\treturn -ESRCH;\n\n\tops->get_coalesce_usecs(priv->ae_handle,\n\t\t\t\t\t&ec->tx_coalesce_usecs,\n\t\t\t\t\t&ec->rx_coalesce_usecs);\n\n\tops->get_max_coalesced_frames(\n\t\tpriv->ae_handle,\n\t\t&ec->tx_max_coalesced_frames,\n\t\t&ec->rx_max_coalesced_frames);\n\n\tops->get_coalesce_range(priv->ae_handle,\n\t\t\t\t&ec->tx_max_coalesced_frames_low,\n\t\t\t\t&ec->rx_max_coalesced_frames_low,\n\t\t\t\t&ec->tx_max_coalesced_frames_high,\n\t\t\t\t&ec->rx_max_coalesced_frames_high,\n\t\t\t\t&ec->tx_coalesce_usecs_low,\n\t\t\t\t&ec->rx_coalesce_usecs_low,\n\t\t\t\t&ec->tx_coalesce_usecs_high,\n\t\t\t\t&ec->rx_coalesce_usecs_high);\n\n\treturn 0;\n}\n\n \nstatic int hns_set_coalesce(struct net_device *net_dev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_ae_ops *ops;\n\tint rc1, rc2;\n\n\tops = priv->ae_handle->dev->ops;\n\n\tif (ec->tx_coalesce_usecs != ec->rx_coalesce_usecs)\n\t\treturn -EINVAL;\n\n\tif ((!ops->set_coalesce_usecs) ||\n\t    (!ops->set_coalesce_frames))\n\t\treturn -ESRCH;\n\n\tif (ec->use_adaptive_rx_coalesce != priv->ae_handle->coal_adapt_en)\n\t\tpriv->ae_handle->coal_adapt_en = ec->use_adaptive_rx_coalesce;\n\n\trc1 = ops->set_coalesce_usecs(priv->ae_handle,\n\t\t\t\t      ec->rx_coalesce_usecs);\n\n\trc2 = ops->set_coalesce_frames(priv->ae_handle,\n\t\t\t\t       ec->tx_max_coalesced_frames,\n\t\t\t\t       ec->rx_max_coalesced_frames);\n\n\tif (rc1 || rc2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void\nhns_get_channels(struct net_device *net_dev, struct ethtool_channels *ch)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\n\tch->max_rx = priv->ae_handle->q_num;\n\tch->max_tx = priv->ae_handle->q_num;\n\n\tch->rx_count = priv->ae_handle->q_num;\n\tch->tx_count = priv->ae_handle->q_num;\n}\n\n \nstatic void hns_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tu64 *p = data;\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tconst struct rtnl_link_stats64 *net_stats;\n\tstruct rtnl_link_stats64 temp;\n\n\tif (!h->dev->ops->get_stats || !h->dev->ops->update_stats) {\n\t\tnetdev_err(netdev, \"get_stats or update_stats is null!\\n\");\n\t\treturn;\n\t}\n\n\th->dev->ops->update_stats(h, &netdev->stats);\n\n\tnet_stats = dev_get_stats(netdev, &temp);\n\n\t \n\tp[0] = net_stats->rx_packets;\n\tp[1] = net_stats->tx_packets;\n\tp[2] = net_stats->rx_bytes;\n\tp[3] = net_stats->tx_bytes;\n\tp[4] = net_stats->rx_errors;\n\tp[5] = net_stats->tx_errors;\n\tp[6] = net_stats->rx_dropped;\n\tp[7] = net_stats->tx_dropped;\n\tp[8] = net_stats->multicast;\n\tp[9] = net_stats->collisions;\n\tp[10] = net_stats->rx_over_errors;\n\tp[11] = net_stats->rx_crc_errors;\n\tp[12] = net_stats->rx_frame_errors;\n\tp[13] = net_stats->rx_fifo_errors;\n\tp[14] = net_stats->rx_missed_errors;\n\tp[15] = net_stats->tx_aborted_errors;\n\tp[16] = net_stats->tx_carrier_errors;\n\tp[17] = net_stats->tx_fifo_errors;\n\tp[18] = net_stats->tx_heartbeat_errors;\n\tp[19] = net_stats->rx_length_errors;\n\tp[20] = net_stats->tx_window_errors;\n\tp[21] = net_stats->rx_compressed;\n\tp[22] = net_stats->tx_compressed;\n\n\tp[23] = 0;  \n\tp[24] = 0;  \n\n\tp[25] = priv->tx_timeout_count;\n\n\t \n\th->dev->ops->get_stats(h, &p[26]);\n}\n\n \nstatic void hns_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tu8 *buff = data;\n\n\tif (!h->dev->ops->get_strings) {\n\t\tnetdev_err(netdev, \"h->dev->ops->get_strings is null!\\n\");\n\t\treturn;\n\t}\n\n\tif (stringset == ETH_SS_TEST) {\n\t\tif (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII)\n\t\t\tethtool_sprintf(&buff,\n\t\t\t\t\thns_nic_test_strs[MAC_INTERNALLOOP_MAC]);\n\t\tethtool_sprintf(&buff,\n\t\t\t\thns_nic_test_strs[MAC_INTERNALLOOP_SERDES]);\n\t\tif ((netdev->phydev) && (!netdev->phydev->is_c45))\n\t\t\tethtool_sprintf(&buff,\n\t\t\t\t\thns_nic_test_strs[MAC_INTERNALLOOP_PHY]);\n\n\t} else {\n\t\tethtool_sprintf(&buff, \"rx_packets\");\n\t\tethtool_sprintf(&buff, \"tx_packets\");\n\t\tethtool_sprintf(&buff, \"rx_bytes\");\n\t\tethtool_sprintf(&buff, \"tx_bytes\");\n\t\tethtool_sprintf(&buff, \"rx_errors\");\n\t\tethtool_sprintf(&buff, \"tx_errors\");\n\t\tethtool_sprintf(&buff, \"rx_dropped\");\n\t\tethtool_sprintf(&buff, \"tx_dropped\");\n\t\tethtool_sprintf(&buff, \"multicast\");\n\t\tethtool_sprintf(&buff, \"collisions\");\n\t\tethtool_sprintf(&buff, \"rx_over_errors\");\n\t\tethtool_sprintf(&buff, \"rx_crc_errors\");\n\t\tethtool_sprintf(&buff, \"rx_frame_errors\");\n\t\tethtool_sprintf(&buff, \"rx_fifo_errors\");\n\t\tethtool_sprintf(&buff, \"rx_missed_errors\");\n\t\tethtool_sprintf(&buff, \"tx_aborted_errors\");\n\t\tethtool_sprintf(&buff, \"tx_carrier_errors\");\n\t\tethtool_sprintf(&buff, \"tx_fifo_errors\");\n\t\tethtool_sprintf(&buff, \"tx_heartbeat_errors\");\n\t\tethtool_sprintf(&buff, \"rx_length_errors\");\n\t\tethtool_sprintf(&buff, \"tx_window_errors\");\n\t\tethtool_sprintf(&buff, \"rx_compressed\");\n\t\tethtool_sprintf(&buff, \"tx_compressed\");\n\t\tethtool_sprintf(&buff, \"netdev_rx_dropped\");\n\t\tethtool_sprintf(&buff, \"netdev_tx_dropped\");\n\n\t\tethtool_sprintf(&buff, \"netdev_tx_timeout\");\n\n\t\th->dev->ops->get_strings(h, stringset, buff);\n\t}\n}\n\n \nstatic int hns_get_sset_count(struct net_device *netdev, int stringset)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tstruct hnae_ae_ops *ops = h->dev->ops;\n\n\tif (!ops->get_sset_count) {\n\t\tnetdev_err(netdev, \"get_sset_count is null!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (stringset == ETH_SS_TEST) {\n\t\tu32 cnt = (sizeof(hns_nic_test_strs) / ETH_GSTRING_LEN);\n\n\t\tif (priv->ae_handle->phy_if == PHY_INTERFACE_MODE_XGMII)\n\t\t\tcnt--;\n\n\t\tif ((!netdev->phydev) || (netdev->phydev->is_c45))\n\t\t\tcnt--;\n\n\t\treturn cnt;\n\t} else if (stringset == ETH_SS_STATS) {\n\t\treturn (HNS_NET_STATS_CNT + ops->get_sset_count(h, stringset));\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int hns_phy_led_set(struct net_device *netdev, int value)\n{\n\tint retval;\n\tstruct phy_device *phy_dev = netdev->phydev;\n\n\tretval = phy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_LED);\n\tretval |= phy_write(phy_dev, HNS_LED_FC_REG, value);\n\tretval |= phy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_COPPER);\n\tif (retval) {\n\t\tnetdev_err(netdev, \"mdiobus_write fail !\\n\");\n\t\treturn retval;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nhns_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tstruct phy_device *phy_dev = netdev->phydev;\n\tint ret;\n\n\tif (phy_dev)\n\t\tswitch (state) {\n\t\tcase ETHTOOL_ID_ACTIVE:\n\t\t\tret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\n\t\t\t\t\tHNS_PHY_PAGE_LED);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tpriv->phy_led_val = phy_read(phy_dev, HNS_LED_FC_REG);\n\n\t\t\tret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\n\t\t\t\t\tHNS_PHY_PAGE_COPPER);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn 2;\n\t\tcase ETHTOOL_ID_ON:\n\t\t\tret = hns_phy_led_set(netdev, HNS_LED_FORCE_ON);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase ETHTOOL_ID_OFF:\n\t\t\tret = hns_phy_led_set(netdev, HNS_LED_FORCE_OFF);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase ETHTOOL_ID_INACTIVE:\n\t\t\tret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\n\t\t\t\t\tHNS_PHY_PAGE_LED);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = phy_write(phy_dev, HNS_LED_FC_REG,\n\t\t\t\t\tpriv->phy_led_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\n\t\t\t\t\tHNS_PHY_PAGE_COPPER);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\telse\n\t\tswitch (state) {\n\t\tcase ETHTOOL_ID_ACTIVE:\n\t\t\treturn h->dev->ops->set_led_id(h, HNAE_LED_ACTIVE);\n\t\tcase ETHTOOL_ID_ON:\n\t\t\treturn h->dev->ops->set_led_id(h, HNAE_LED_ON);\n\t\tcase ETHTOOL_ID_OFF:\n\t\t\treturn h->dev->ops->set_led_id(h, HNAE_LED_OFF);\n\t\tcase ETHTOOL_ID_INACTIVE:\n\t\t\treturn h->dev->ops->set_led_id(h, HNAE_LED_INACTIVE);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\treturn 0;\n}\n\n \nstatic void hns_get_regs(struct net_device *net_dev, struct ethtool_regs *cmd,\n\t\t\t void *data)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_ae_ops *ops;\n\n\tops = priv->ae_handle->dev->ops;\n\n\tcmd->version = HNS_CHIP_VERSION;\n\tif (!ops->get_regs) {\n\t\tnetdev_err(net_dev, \"ops->get_regs is null!\\n\");\n\t\treturn;\n\t}\n\tops->get_regs(priv->ae_handle, data);\n}\n\n \nstatic int hns_get_regs_len(struct net_device *net_dev)\n{\n\tu32 reg_num;\n\tstruct hns_nic_priv *priv = netdev_priv(net_dev);\n\tstruct hnae_ae_ops *ops;\n\n\tops = priv->ae_handle->dev->ops;\n\tif (!ops->get_regs_len) {\n\t\tnetdev_err(net_dev, \"ops->get_regs_len is null!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treg_num = ops->get_regs_len(priv->ae_handle);\n\tif (reg_num > 0)\n\t\treturn reg_num * sizeof(u32);\n\telse\n\t\treturn reg_num;\t \n}\n\n \nstatic int hns_nic_nway_reset(struct net_device *netdev)\n{\n\tstruct phy_device *phy = netdev->phydev;\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\tif (!phy)\n\t\treturn -EOPNOTSUPP;\n\n\tif (phy->autoneg != AUTONEG_ENABLE)\n\t\treturn -EINVAL;\n\n\treturn genphy_restart_aneg(phy);\n}\n\nstatic u32\nhns_get_rss_key_size(struct net_device *netdev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_ae_ops *ops;\n\n\tif (AE_IS_VER1(priv->enet_ver)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"RSS feature is not supported on this hardware\\n\");\n\t\treturn 0;\n\t}\n\n\tops = priv->ae_handle->dev->ops;\n\treturn ops->get_rss_key_size(priv->ae_handle);\n}\n\nstatic u32\nhns_get_rss_indir_size(struct net_device *netdev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_ae_ops *ops;\n\n\tif (AE_IS_VER1(priv->enet_ver)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"RSS feature is not supported on this hardware\\n\");\n\t\treturn 0;\n\t}\n\n\tops = priv->ae_handle->dev->ops;\n\treturn ops->get_rss_indir_size(priv->ae_handle);\n}\n\nstatic int\nhns_get_rss(struct net_device *netdev, u32 *indir, u8 *key, u8 *hfunc)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_ae_ops *ops;\n\n\tif (AE_IS_VER1(priv->enet_ver)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"RSS feature is not supported on this hardware\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tops = priv->ae_handle->dev->ops;\n\n\tif (!indir)\n\t\treturn 0;\n\n\treturn ops->get_rss(priv->ae_handle, indir, key, hfunc);\n}\n\nstatic int\nhns_set_rss(struct net_device *netdev, const u32 *indir, const u8 *key,\n\t    const u8 hfunc)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_ae_ops *ops;\n\n\tif (AE_IS_VER1(priv->enet_ver)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"RSS feature is not supported on this hardware\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tops = priv->ae_handle->dev->ops;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP) {\n\t\tnetdev_err(netdev, \"Invalid hfunc!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ops->set_rss(priv->ae_handle, indir, key, hfunc);\n}\n\nstatic int hns_get_rxnfc(struct net_device *netdev,\n\t\t\t struct ethtool_rxnfc *cmd,\n\t\t\t u32 *rule_locs)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = priv->ae_handle->q_num;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops hns_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE |\n\t\t\t\t     ETHTOOL_COALESCE_USECS_LOW_HIGH |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES_LOW_HIGH,\n\t.get_drvinfo = hns_nic_get_drvinfo,\n\t.get_link  = hns_nic_get_link,\n\t.get_ringparam = hns_get_ringparam,\n\t.get_pauseparam = hns_get_pauseparam,\n\t.set_pauseparam = hns_set_pauseparam,\n\t.get_coalesce = hns_get_coalesce,\n\t.set_coalesce = hns_set_coalesce,\n\t.get_channels = hns_get_channels,\n\t.self_test = hns_nic_self_test,\n\t.get_strings = hns_get_strings,\n\t.get_sset_count = hns_get_sset_count,\n\t.get_ethtool_stats = hns_get_ethtool_stats,\n\t.set_phys_id = hns_set_phys_id,\n\t.get_regs_len = hns_get_regs_len,\n\t.get_regs = hns_get_regs,\n\t.nway_reset = hns_nic_nway_reset,\n\t.get_rxfh_key_size = hns_get_rss_key_size,\n\t.get_rxfh_indir_size = hns_get_rss_indir_size,\n\t.get_rxfh = hns_get_rss,\n\t.set_rxfh = hns_set_rss,\n\t.get_rxnfc = hns_get_rxnfc,\n\t.get_link_ksettings  = hns_nic_get_link_ksettings,\n\t.set_link_ksettings  = hns_nic_set_link_ksettings,\n};\n\nvoid hns_ethtool_set_ops(struct net_device *ndev)\n{\n\tndev->ethtool_ops = &hns_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}