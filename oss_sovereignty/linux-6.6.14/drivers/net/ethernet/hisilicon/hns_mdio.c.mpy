{
  "module_name": "hns_mdio.c",
  "hash_id": "d3be03e0e3804491d4601526172baf4a6133e2e2e134bcffb63eb70de7ead2a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hns_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_platform.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define MDIO_DRV_NAME \"Hi-HNS_MDIO\"\n#define MDIO_BUS_NAME \"Hisilicon MII Bus\"\n\n#define MDIO_TIMEOUT\t\t\t1000000\n\nstruct hns_mdio_sc_reg {\n\tu16 mdio_clk_en;\n\tu16 mdio_clk_dis;\n\tu16 mdio_reset_req;\n\tu16 mdio_reset_dreq;\n\tu16 mdio_clk_st;\n\tu16 mdio_reset_st;\n};\n\nstruct hns_mdio_device {\n\tu8 __iomem *vbase;\t\t \n\tstruct regmap *subctrl_vbase;\n\tstruct hns_mdio_sc_reg sc_reg;\n};\n\n \n#define MDIO_COMMAND_REG\t\t0x0\n#define MDIO_ADDR_REG\t\t\t0x4\n#define MDIO_WDATA_REG\t\t\t0x8\n#define MDIO_RDATA_REG\t\t\t0xc\n#define MDIO_STA_REG\t\t\t0x10\n\n \n#define MDIO_CMD_DEVAD_M\t0x1f\n#define MDIO_CMD_DEVAD_S\t0\n#define MDIO_CMD_PRTAD_M\t0x1f\n#define MDIO_CMD_PRTAD_S\t5\n#define MDIO_CMD_OP_S\t\t10\n#define MDIO_CMD_ST_S\t\t12\n#define MDIO_CMD_START_B\t14\n\n#define MDIO_ADDR_DATA_M\t0xffff\n#define MDIO_ADDR_DATA_S\t0\n\n#define MDIO_WDATA_DATA_M\t0xffff\n#define MDIO_WDATA_DATA_S\t0\n\n#define MDIO_RDATA_DATA_M\t0xffff\n#define MDIO_RDATA_DATA_S\t0\n\n#define MDIO_STATE_STA_B\t0\n\nenum mdio_st_clause {\n\tMDIO_ST_CLAUSE_45 = 0,\n\tMDIO_ST_CLAUSE_22\n};\n\nenum mdio_c22_op_seq {\n\tMDIO_C22_WRITE = 1,\n\tMDIO_C22_READ = 2\n};\n\nenum mdio_c45_op_seq {\n\tMDIO_C45_WRITE_ADDR = 0,\n\tMDIO_C45_WRITE_DATA,\n\tMDIO_C45_READ_INCREMENT,\n\tMDIO_C45_READ\n};\n\n \n#define MDIO_SC_CLK_EN\t\t0x338\n#define MDIO_SC_CLK_DIS\t\t0x33C\n#define MDIO_SC_RESET_REQ\t0xA38\n#define MDIO_SC_RESET_DREQ\t0xA3C\n#define MDIO_SC_CLK_ST\t\t0x531C\n#define MDIO_SC_RESET_ST\t0x5A1C\n\nstatic void mdio_write_reg(u8 __iomem *base, u32 reg, u32 value)\n{\n\twritel_relaxed(value, base + reg);\n}\n\n#define MDIO_WRITE_REG(a, reg, value) \\\n\tmdio_write_reg((a)->vbase, (reg), (value))\n\nstatic u32 mdio_read_reg(u8 __iomem *base, u32 reg)\n{\n\treturn readl_relaxed(base + reg);\n}\n\n#define mdio_set_field(origin, mask, shift, val) \\\n\tdo { \\\n\t\t(origin) &= (~((mask) << (shift))); \\\n\t\t(origin) |= (((val) & (mask)) << (shift)); \\\n\t} while (0)\n\n#define mdio_get_field(origin, mask, shift) (((origin) >> (shift)) & (mask))\n\nstatic void mdio_set_reg_field(u8 __iomem *base, u32 reg, u32 mask, u32 shift,\n\t\t\t       u32 val)\n{\n\tu32 origin = mdio_read_reg(base, reg);\n\n\tmdio_set_field(origin, mask, shift, val);\n\tmdio_write_reg(base, reg, origin);\n}\n\n#define MDIO_SET_REG_FIELD(dev, reg, mask, shift, val) \\\n\tmdio_set_reg_field((dev)->vbase, (reg), (mask), (shift), (val))\n\nstatic u32 mdio_get_reg_field(u8 __iomem *base, u32 reg, u32 mask, u32 shift)\n{\n\tu32 origin;\n\n\torigin = mdio_read_reg(base, reg);\n\treturn mdio_get_field(origin, mask, shift);\n}\n\n#define MDIO_GET_REG_FIELD(dev, reg, mask, shift) \\\n\t\tmdio_get_reg_field((dev)->vbase, (reg), (mask), (shift))\n\n#define MDIO_GET_REG_BIT(dev, reg, bit) \\\n\t\tmdio_get_reg_field((dev)->vbase, (reg), 0x1ull, (bit))\n\n#define MDIO_CHECK_SET_ST\t1\n#define MDIO_CHECK_CLR_ST\t0\n\nstatic int mdio_sc_cfg_reg_write(struct hns_mdio_device *mdio_dev,\n\t\t\t\t u32 cfg_reg, u32 set_val,\n\t\t\t\t u32 st_reg, u32 st_msk, u8 check_st)\n{\n\tu32 time_cnt;\n\tu32 reg_value;\n\tint ret;\n\n\tregmap_write(mdio_dev->subctrl_vbase, cfg_reg, set_val);\n\n\tfor (time_cnt = MDIO_TIMEOUT; time_cnt; time_cnt--) {\n\t\tret = regmap_read(mdio_dev->subctrl_vbase, st_reg, &reg_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treg_value &= st_msk;\n\t\tif ((!!check_st) == (!!reg_value))\n\t\t\tbreak;\n\t}\n\n\tif ((!!check_st) != (!!reg_value))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int hns_mdio_wait_ready(struct mii_bus *bus)\n{\n\tstruct hns_mdio_device *mdio_dev = bus->priv;\n\tu32 cmd_reg_value;\n\tint i;\n\n\t \n\t \n\tfor (i = 0; i < MDIO_TIMEOUT; i++) {\n\t\tcmd_reg_value = MDIO_GET_REG_BIT(mdio_dev,\n\t\t\t\t\t\t MDIO_COMMAND_REG,\n\t\t\t\t\t\t MDIO_CMD_START_B);\n\t\tif (!cmd_reg_value)\n\t\t\tbreak;\n\t}\n\tif ((i == MDIO_TIMEOUT) && cmd_reg_value)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void hns_mdio_cmd_write(struct hns_mdio_device *mdio_dev,\n\t\t\t       u8 is_c45, u8 op, u8 phy_id, u16 cmd)\n{\n\tu32 cmd_reg_value;\n\tu8 st = is_c45 ? MDIO_ST_CLAUSE_45 : MDIO_ST_CLAUSE_22;\n\n\tcmd_reg_value = st << MDIO_CMD_ST_S;\n\tcmd_reg_value |= op << MDIO_CMD_OP_S;\n\tcmd_reg_value |=\n\t\t(phy_id & MDIO_CMD_PRTAD_M) << MDIO_CMD_PRTAD_S;\n\tcmd_reg_value |= (cmd & MDIO_CMD_DEVAD_M) << MDIO_CMD_DEVAD_S;\n\tcmd_reg_value |= 1 << MDIO_CMD_START_B;\n\n\tMDIO_WRITE_REG(mdio_dev, MDIO_COMMAND_REG, cmd_reg_value);\n}\n\n \nstatic int hns_mdio_write_c22(struct mii_bus *bus,\n\t\t\t      int phy_id, int regnum, u16 data)\n{\n\tstruct hns_mdio_device *mdio_dev = bus->priv;\n\tu16 reg = (u16)(regnum & 0xffff);\n\tu16 cmd_reg_cfg;\n\tint ret;\n\tu8 op;\n\n\tdev_dbg(&bus->dev, \"mdio write %s,base is %p\\n\",\n\t\tbus->id, mdio_dev->vbase);\n\tdev_dbg(&bus->dev, \"phy id=%d, reg=%#x, write data=%d\\n\",\n\t\tphy_id, reg, data);\n\n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\tcmd_reg_cfg = reg;\n\top = MDIO_C22_WRITE;\n\n\tMDIO_SET_REG_FIELD(mdio_dev, MDIO_WDATA_REG, MDIO_WDATA_DATA_M,\n\t\t\t   MDIO_WDATA_DATA_S, data);\n\n\thns_mdio_cmd_write(mdio_dev, false, op, phy_id, cmd_reg_cfg);\n\n\treturn 0;\n}\n\n \nstatic int hns_mdio_write_c45(struct mii_bus *bus, int phy_id, int devad,\n\t\t\t      int regnum, u16 data)\n{\n\tstruct hns_mdio_device *mdio_dev = bus->priv;\n\tu16 reg = (u16)(regnum & 0xffff);\n\tu16 cmd_reg_cfg;\n\tint ret;\n\tu8 op;\n\n\tdev_dbg(&bus->dev, \"mdio write %s,base is %p\\n\",\n\t\tbus->id, mdio_dev->vbase);\n\tdev_dbg(&bus->dev, \"phy id=%d, devad=%d, reg=%#x, write data=%d\\n\",\n\t\tphy_id, devad, reg, data);\n\n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tMDIO_SET_REG_FIELD(mdio_dev, MDIO_ADDR_REG, MDIO_ADDR_DATA_M,\n\t\t\t   MDIO_ADDR_DATA_S, reg);\n\n\thns_mdio_cmd_write(mdio_dev, true, MDIO_C45_WRITE_ADDR, phy_id, devad);\n\n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcmd_reg_cfg = devad;\n\top = MDIO_C45_WRITE_DATA;\n\n\tMDIO_SET_REG_FIELD(mdio_dev, MDIO_WDATA_REG, MDIO_WDATA_DATA_M,\n\t\t\t   MDIO_WDATA_DATA_S, data);\n\n\thns_mdio_cmd_write(mdio_dev, true, op, phy_id, cmd_reg_cfg);\n\n\treturn 0;\n}\n\n \nstatic int hns_mdio_read_c22(struct mii_bus *bus, int phy_id, int regnum)\n{\n\tstruct hns_mdio_device *mdio_dev = bus->priv;\n\tu16 reg = (u16)(regnum & 0xffff);\n\tu16 reg_val;\n\tint ret;\n\n\tdev_dbg(&bus->dev, \"mdio read %s,base is %p\\n\",\n\t\tbus->id, mdio_dev->vbase);\n\tdev_dbg(&bus->dev, \"phy id=%d, reg=%#x!\\n\", phy_id, reg);\n\n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\thns_mdio_cmd_write(mdio_dev, false, MDIO_C22_READ, phy_id, reg);\n\n\t \n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\treg_val = MDIO_GET_REG_BIT(mdio_dev, MDIO_STA_REG, MDIO_STATE_STA_B);\n\tif (reg_val) {\n\t\tdev_err(&bus->dev, \" ERROR! MDIO Read failed!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\treg_val = (u16)MDIO_GET_REG_FIELD(mdio_dev, MDIO_RDATA_REG,\n\t\t\t\t\t  MDIO_RDATA_DATA_M, MDIO_RDATA_DATA_S);\n\n\treturn reg_val;\n}\n\n \nstatic int hns_mdio_read_c45(struct mii_bus *bus, int phy_id, int devad,\n\t\t\t     int regnum)\n{\n\tstruct hns_mdio_device *mdio_dev = bus->priv;\n\tu16 reg = (u16)(regnum & 0xffff);\n\tu16 reg_val;\n\tint ret;\n\n\tdev_dbg(&bus->dev, \"mdio read %s,base is %p\\n\",\n\t\tbus->id, mdio_dev->vbase);\n\tdev_dbg(&bus->dev, \"phy id=%d, devad=%d, reg=%#x!\\n\",\n\t\tphy_id, devad, reg);\n\n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\tMDIO_SET_REG_FIELD(mdio_dev, MDIO_ADDR_REG, MDIO_ADDR_DATA_M,\n\t\t\t   MDIO_ADDR_DATA_S, reg);\n\n\t \n\thns_mdio_cmd_write(mdio_dev, true, MDIO_C45_WRITE_ADDR, phy_id, devad);\n\n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\thns_mdio_cmd_write(mdio_dev, true, MDIO_C45_READ, phy_id, devad);\n\n\t \n\t \n\tret = hns_mdio_wait_ready(bus);\n\tif (ret) {\n\t\tdev_err(&bus->dev, \"MDIO bus is busy\\n\");\n\t\treturn ret;\n\t}\n\n\treg_val = MDIO_GET_REG_BIT(mdio_dev, MDIO_STA_REG, MDIO_STATE_STA_B);\n\tif (reg_val) {\n\t\tdev_err(&bus->dev, \" ERROR! MDIO Read failed!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\treg_val = (u16)MDIO_GET_REG_FIELD(mdio_dev, MDIO_RDATA_REG,\n\t\t\t\t\t  MDIO_RDATA_DATA_M, MDIO_RDATA_DATA_S);\n\n\treturn reg_val;\n}\n\n \nstatic int hns_mdio_reset(struct mii_bus *bus)\n{\n\tstruct hns_mdio_device *mdio_dev = bus->priv;\n\tconst struct hns_mdio_sc_reg *sc_reg;\n\tint ret;\n\n\tif (dev_of_node(bus->parent)) {\n\t\tif (!mdio_dev->subctrl_vbase) {\n\t\t\tdev_err(&bus->dev, \"mdio sys ctl reg has not mapped\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tsc_reg = &mdio_dev->sc_reg;\n\t\t \n\t\tret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_reset_req,\n\t\t\t\t\t    0x1, sc_reg->mdio_reset_st, 0x1,\n\t\t\t\t\t    MDIO_CHECK_SET_ST);\n\t\tif (ret) {\n\t\t\tdev_err(&bus->dev, \"MDIO reset fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_clk_dis,\n\t\t\t\t\t    0x1, sc_reg->mdio_clk_st, 0x1,\n\t\t\t\t\t    MDIO_CHECK_CLR_ST);\n\t\tif (ret) {\n\t\t\tdev_err(&bus->dev, \"MDIO dis clk fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_reset_dreq,\n\t\t\t\t\t    0x1, sc_reg->mdio_reset_st, 0x1,\n\t\t\t\t\t    MDIO_CHECK_CLR_ST);\n\t\tif (ret) {\n\t\t\tdev_err(&bus->dev, \"MDIO dis clk fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_clk_en,\n\t\t\t\t\t    0x1, sc_reg->mdio_clk_st, 0x1,\n\t\t\t\t\t    MDIO_CHECK_SET_ST);\n\t\tif (ret)\n\t\t\tdev_err(&bus->dev, \"MDIO en clk fail\\n\");\n\t} else if (is_acpi_node(bus->parent->fwnode)) {\n\t\tacpi_status s;\n\n\t\ts = acpi_evaluate_object(ACPI_HANDLE(bus->parent),\n\t\t\t\t\t \"_RST\", NULL, NULL);\n\t\tif (ACPI_FAILURE(s)) {\n\t\t\tdev_err(&bus->dev, \"Reset failed, return:%#x\\n\", s);\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tdev_err(&bus->dev, \"Can not get cfg data from DT or ACPI\\n\");\n\t\tret = -ENXIO;\n\t}\n\treturn ret;\n}\n\n \nstatic int hns_mdio_probe(struct platform_device *pdev)\n{\n\tstruct hns_mdio_device *mdio_dev;\n\tstruct mii_bus *new_bus;\n\tint ret;\n\n\tif (!pdev) {\n\t\tdev_err(NULL, \"pdev is NULL!\\r\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmdio_dev = devm_kzalloc(&pdev->dev, sizeof(*mdio_dev), GFP_KERNEL);\n\tif (!mdio_dev)\n\t\treturn -ENOMEM;\n\n\tnew_bus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!new_bus) {\n\t\tdev_err(&pdev->dev, \"mdiobus_alloc fail!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_bus->name = MDIO_BUS_NAME;\n\tnew_bus->read = hns_mdio_read_c22;\n\tnew_bus->write = hns_mdio_write_c22;\n\tnew_bus->read_c45 = hns_mdio_read_c45;\n\tnew_bus->write_c45 = hns_mdio_write_c45;\n\tnew_bus->reset = hns_mdio_reset;\n\tnew_bus->priv = mdio_dev;\n\tnew_bus->parent = &pdev->dev;\n\n\tmdio_dev->vbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdio_dev->vbase)) {\n\t\tret = PTR_ERR(mdio_dev->vbase);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, new_bus);\n\tsnprintf(new_bus->id, MII_BUS_ID_SIZE, \"%s-%s\", \"Mii\",\n\t\t dev_name(&pdev->dev));\n\tif (dev_of_node(&pdev->dev)) {\n\t\tstruct of_phandle_args reg_args;\n\n\t\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\n\t\t\t\t\t\t       \"subctrl-vbase\",\n\t\t\t\t\t\t       4,\n\t\t\t\t\t\t       0,\n\t\t\t\t\t\t       &reg_args);\n\t\tif (!ret) {\n\t\t\tmdio_dev->subctrl_vbase =\n\t\t\t\tsyscon_node_to_regmap(reg_args.np);\n\t\t\tif (IS_ERR(mdio_dev->subctrl_vbase)) {\n\t\t\t\tdev_warn(&pdev->dev, \"syscon_node_to_regmap error\\n\");\n\t\t\t\tmdio_dev->subctrl_vbase = NULL;\n\t\t\t} else {\n\t\t\t\tif (reg_args.args_count == 4) {\n\t\t\t\t\tmdio_dev->sc_reg.mdio_clk_en =\n\t\t\t\t\t\t(u16)reg_args.args[0];\n\t\t\t\t\tmdio_dev->sc_reg.mdio_clk_dis =\n\t\t\t\t\t\t(u16)reg_args.args[0] + 4;\n\t\t\t\t\tmdio_dev->sc_reg.mdio_reset_req =\n\t\t\t\t\t\t(u16)reg_args.args[1];\n\t\t\t\t\tmdio_dev->sc_reg.mdio_reset_dreq =\n\t\t\t\t\t\t(u16)reg_args.args[1] + 4;\n\t\t\t\t\tmdio_dev->sc_reg.mdio_clk_st =\n\t\t\t\t\t\t(u16)reg_args.args[2];\n\t\t\t\t\tmdio_dev->sc_reg.mdio_reset_st =\n\t\t\t\t\t\t(u16)reg_args.args[3];\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tmdio_dev->sc_reg.mdio_clk_en =\n\t\t\t\t\t\tMDIO_SC_CLK_EN;\n\t\t\t\t\tmdio_dev->sc_reg.mdio_clk_dis =\n\t\t\t\t\t\tMDIO_SC_CLK_DIS;\n\t\t\t\t\tmdio_dev->sc_reg.mdio_reset_req =\n\t\t\t\t\t\tMDIO_SC_RESET_REQ;\n\t\t\t\t\tmdio_dev->sc_reg.mdio_reset_dreq =\n\t\t\t\t\t\tMDIO_SC_RESET_DREQ;\n\t\t\t\t\tmdio_dev->sc_reg.mdio_clk_st =\n\t\t\t\t\t\tMDIO_SC_CLK_ST;\n\t\t\t\t\tmdio_dev->sc_reg.mdio_reset_st =\n\t\t\t\t\t\tMDIO_SC_RESET_ST;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(&pdev->dev, \"find syscon ret = %#x\\n\", ret);\n\t\t\tmdio_dev->subctrl_vbase = NULL;\n\t\t}\n\n\t\tret = of_mdiobus_register(new_bus, pdev->dev.of_node);\n\t} else if (is_acpi_node(pdev->dev.fwnode)) {\n\t\t \n\t\tmemset(new_bus->irq, PHY_POLL, 4 * PHY_MAX_ADDR);\n\n\t\t \n\t\tnew_bus->phy_mask = ~0;\n\n\t\t \n\t\tret = mdiobus_register(new_bus);\n\t} else {\n\t\tdev_err(&pdev->dev, \"Can not get cfg data from DT or ACPI\\n\");\n\t\tret = -ENXIO;\n\t}\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot register as MDIO bus!\\n\");\n\t\tplatform_set_drvdata(pdev, NULL);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hns_mdio_remove(struct platform_device *pdev)\n{\n\tstruct mii_bus *bus;\n\n\tbus = platform_get_drvdata(pdev);\n\n\tmdiobus_unregister(bus);\n\tplatform_set_drvdata(pdev, NULL);\n\treturn 0;\n}\n\nstatic const struct of_device_id hns_mdio_match[] = {\n\t{.compatible = \"hisilicon,mdio\"},\n\t{.compatible = \"hisilicon,hns-mdio\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, hns_mdio_match);\n\nstatic const struct acpi_device_id hns_mdio_acpi_match[] = {\n\t{ \"HISI0141\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, hns_mdio_acpi_match);\n\nstatic struct platform_driver hns_mdio_driver = {\n\t.probe = hns_mdio_probe,\n\t.remove = hns_mdio_remove,\n\t.driver = {\n\t\t   .name = MDIO_DRV_NAME,\n\t\t   .of_match_table = hns_mdio_match,\n\t\t   .acpi_match_table = ACPI_PTR(hns_mdio_acpi_match),\n\t\t   },\n};\n\nmodule_platform_driver(hns_mdio_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Huawei Tech. Co., Ltd.\");\nMODULE_DESCRIPTION(\"Hisilicon HNS MDIO driver\");\nMODULE_ALIAS(\"platform:\" MDIO_DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}