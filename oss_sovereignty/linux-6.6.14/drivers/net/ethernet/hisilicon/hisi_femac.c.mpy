{
  "module_name": "hisi_femac.c",
  "hash_id": "08bbf60f4ad518ddf743e76aa35b6bd8b0d305bbc616ee04ffd40cb6faaf470a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hisi_femac.c",
  "human_readable_source": "\n \n\n#include <linux/circ_buf.h>\n#include <linux/clk.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n \n#define MAC_PORTSEL\t\t\t0x0200\n#define MAC_PORTSEL_STAT_CPU\t\tBIT(0)\n#define MAC_PORTSEL_RMII\t\tBIT(1)\n#define MAC_PORTSET\t\t\t0x0208\n#define MAC_PORTSET_DUPLEX_FULL\t\tBIT(0)\n#define MAC_PORTSET_LINKED\t\tBIT(1)\n#define MAC_PORTSET_SPEED_100M\t\tBIT(2)\n#define MAC_SET\t\t\t\t0x0210\n#define MAX_FRAME_SIZE\t\t\t1600\n#define MAX_FRAME_SIZE_MASK\t\tGENMASK(10, 0)\n#define BIT_PAUSE_EN\t\t\tBIT(18)\n#define RX_COALESCE_SET\t\t\t0x0340\n#define RX_COALESCED_FRAME_OFFSET\t24\n#define RX_COALESCED_FRAMES\t\t8\n#define RX_COALESCED_TIMER\t\t0x74\n#define QLEN_SET\t\t\t0x0344\n#define RX_DEPTH_OFFSET\t\t\t8\n#define MAX_HW_FIFO_DEPTH\t\t64\n#define HW_TX_FIFO_DEPTH\t\t12\n#define HW_RX_FIFO_DEPTH\t\t(MAX_HW_FIFO_DEPTH - HW_TX_FIFO_DEPTH)\n#define IQFRM_DES\t\t\t0x0354\n#define RX_FRAME_LEN_MASK\t\tGENMASK(11, 0)\n#define IQ_ADDR\t\t\t\t0x0358\n#define EQ_ADDR\t\t\t\t0x0360\n#define EQFRM_LEN\t\t\t0x0364\n#define ADDRQ_STAT\t\t\t0x036C\n#define TX_CNT_INUSE_MASK\t\tGENMASK(5, 0)\n#define BIT_TX_READY\t\t\tBIT(24)\n#define BIT_RX_READY\t\t\tBIT(25)\n \n#define GLB_HOSTMAC_L32\t\t\t0x0000\n#define GLB_HOSTMAC_H16\t\t\t0x0004\n#define GLB_SOFT_RESET\t\t\t0x0008\n#define SOFT_RESET_ALL\t\t\tBIT(0)\n#define GLB_FWCTRL\t\t\t0x0010\n#define FWCTRL_VLAN_ENABLE\t\tBIT(0)\n#define FWCTRL_FW2CPU_ENA\t\tBIT(5)\n#define FWCTRL_FWALL2CPU\t\tBIT(7)\n#define GLB_MACTCTRL\t\t\t0x0014\n#define MACTCTRL_UNI2CPU\t\tBIT(1)\n#define MACTCTRL_MULTI2CPU\t\tBIT(3)\n#define MACTCTRL_BROAD2CPU\t\tBIT(5)\n#define MACTCTRL_MACT_ENA\t\tBIT(7)\n#define GLB_IRQ_STAT\t\t\t0x0030\n#define GLB_IRQ_ENA\t\t\t0x0034\n#define IRQ_ENA_PORT0_MASK\t\tGENMASK(7, 0)\n#define IRQ_ENA_PORT0\t\t\tBIT(18)\n#define IRQ_ENA_ALL\t\t\tBIT(19)\n#define GLB_IRQ_RAW\t\t\t0x0038\n#define IRQ_INT_RX_RDY\t\t\tBIT(0)\n#define IRQ_INT_TX_PER_PACKET\t\tBIT(1)\n#define IRQ_INT_TX_FIFO_EMPTY\t\tBIT(6)\n#define IRQ_INT_MULTI_RXRDY\t\tBIT(7)\n#define DEF_INT_MASK\t\t\t(IRQ_INT_MULTI_RXRDY | \\\n\t\t\t\t\tIRQ_INT_TX_PER_PACKET | \\\n\t\t\t\t\tIRQ_INT_TX_FIFO_EMPTY)\n#define GLB_MAC_L32_BASE\t\t0x0100\n#define GLB_MAC_H16_BASE\t\t0x0104\n#define MACFLT_HI16_MASK\t\tGENMASK(15, 0)\n#define BIT_MACFLT_ENA\t\t\tBIT(17)\n#define BIT_MACFLT_FW2CPU\t\tBIT(21)\n#define GLB_MAC_H16(reg)\t\t(GLB_MAC_H16_BASE + ((reg) * 0x8))\n#define GLB_MAC_L32(reg)\t\t(GLB_MAC_L32_BASE + ((reg) * 0x8))\n#define MAX_MAC_FILTER_NUM\t\t8\n#define MAX_UNICAST_ADDRESSES\t\t2\n#define MAX_MULTICAST_ADDRESSES\t\t(MAX_MAC_FILTER_NUM - \\\n\t\t\t\t\tMAX_UNICAST_ADDRESSES)\n \n#define TXQ_NUM\t\t\t\t64\n#define RXQ_NUM\t\t\t\t128\n#define FEMAC_POLL_WEIGHT\t\t16\n\n#define PHY_RESET_DELAYS_PROPERTY\t\"hisilicon,phy-reset-delays-us\"\n\nenum phy_reset_delays {\n\tPRE_DELAY,\n\tPULSE,\n\tPOST_DELAY,\n\tDELAYS_NUM,\n};\n\nstruct hisi_femac_queue {\n\tstruct sk_buff **skb;\n\tdma_addr_t *dma_phys;\n\tint num;\n\tunsigned int head;\n\tunsigned int tail;\n};\n\nstruct hisi_femac_priv {\n\tvoid __iomem *port_base;\n\tvoid __iomem *glb_base;\n\tstruct clk *clk;\n\tstruct reset_control *mac_rst;\n\tstruct reset_control *phy_rst;\n\tu32 phy_reset_delays[DELAYS_NUM];\n\tu32 link_status;\n\n\tstruct device *dev;\n\tstruct net_device *ndev;\n\n\tstruct hisi_femac_queue txq;\n\tstruct hisi_femac_queue rxq;\n\tu32 tx_fifo_used_cnt;\n\tstruct napi_struct napi;\n};\n\nstatic void hisi_femac_irq_enable(struct hisi_femac_priv *priv, int irqs)\n{\n\tu32 val;\n\n\tval = readl(priv->glb_base + GLB_IRQ_ENA);\n\twritel(val | irqs, priv->glb_base + GLB_IRQ_ENA);\n}\n\nstatic void hisi_femac_irq_disable(struct hisi_femac_priv *priv, int irqs)\n{\n\tu32 val;\n\n\tval = readl(priv->glb_base + GLB_IRQ_ENA);\n\twritel(val & (~irqs), priv->glb_base + GLB_IRQ_ENA);\n}\n\nstatic void hisi_femac_tx_dma_unmap(struct hisi_femac_priv *priv,\n\t\t\t\t    struct sk_buff *skb, unsigned int pos)\n{\n\tdma_addr_t dma_addr;\n\n\tdma_addr = priv->txq.dma_phys[pos];\n\tdma_unmap_single(priv->dev, dma_addr, skb->len, DMA_TO_DEVICE);\n}\n\nstatic void hisi_femac_xmit_reclaim(struct net_device *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\tstruct hisi_femac_queue *txq = &priv->txq;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\tu32 val;\n\n\tnetif_tx_lock(dev);\n\n\tval = readl(priv->port_base + ADDRQ_STAT) & TX_CNT_INUSE_MASK;\n\twhile (val < priv->tx_fifo_used_cnt) {\n\t\tskb = txq->skb[txq->tail];\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(dev, \"xmitq_cnt_inuse=%d, tx_fifo_used=%d\\n\",\n\t\t\t\t   val, priv->tx_fifo_used_cnt);\n\t\t\tbreak;\n\t\t}\n\t\thisi_femac_tx_dma_unmap(priv, skb, txq->tail);\n\t\tpkts_compl++;\n\t\tbytes_compl += skb->len;\n\t\tdev_kfree_skb_any(skb);\n\n\t\tpriv->tx_fifo_used_cnt--;\n\n\t\tval = readl(priv->port_base + ADDRQ_STAT) & TX_CNT_INUSE_MASK;\n\t\ttxq->skb[txq->tail] = NULL;\n\t\ttxq->tail = (txq->tail + 1) % txq->num;\n\t}\n\n\tnetdev_completed_queue(dev, pkts_compl, bytes_compl);\n\n\tif (unlikely(netif_queue_stopped(dev)) && pkts_compl)\n\t\tnetif_wake_queue(dev);\n\n\tnetif_tx_unlock(dev);\n}\n\nstatic void hisi_femac_adjust_link(struct net_device *dev)\n{\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phy = dev->phydev;\n\tu32 status = 0;\n\n\tif (phy->link)\n\t\tstatus |= MAC_PORTSET_LINKED;\n\tif (phy->duplex == DUPLEX_FULL)\n\t\tstatus |= MAC_PORTSET_DUPLEX_FULL;\n\tif (phy->speed == SPEED_100)\n\t\tstatus |= MAC_PORTSET_SPEED_100M;\n\n\tif ((status != priv->link_status) &&\n\t    ((status | priv->link_status) & MAC_PORTSET_LINKED)) {\n\t\twritel(status, priv->port_base + MAC_PORTSET);\n\t\tpriv->link_status = status;\n\t\tphy_print_status(phy);\n\t}\n}\n\nstatic void hisi_femac_rx_refill(struct hisi_femac_priv *priv)\n{\n\tstruct hisi_femac_queue *rxq = &priv->rxq;\n\tstruct sk_buff *skb;\n\tu32 pos;\n\tu32 len = MAX_FRAME_SIZE;\n\tdma_addr_t addr;\n\n\tpos = rxq->head;\n\twhile (readl(priv->port_base + ADDRQ_STAT) & BIT_RX_READY) {\n\t\tif (!CIRC_SPACE(pos, rxq->tail, rxq->num))\n\t\t\tbreak;\n\t\tif (unlikely(rxq->skb[pos])) {\n\t\t\tnetdev_err(priv->ndev, \"err skb[%d]=%p\\n\",\n\t\t\t\t   pos, rxq->skb[pos]);\n\t\t\tbreak;\n\t\t}\n\t\tskb = netdev_alloc_skb_ip_align(priv->ndev, len);\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\n\t\taddr = dma_map_single(priv->dev, skb->data, len,\n\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(priv->dev, addr)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbreak;\n\t\t}\n\t\trxq->dma_phys[pos] = addr;\n\t\trxq->skb[pos] = skb;\n\t\twritel(addr, priv->port_base + IQ_ADDR);\n\t\tpos = (pos + 1) % rxq->num;\n\t}\n\trxq->head = pos;\n}\n\nstatic int hisi_femac_rx(struct net_device *dev, int limit)\n{\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\tstruct hisi_femac_queue *rxq = &priv->rxq;\n\tstruct sk_buff *skb;\n\tdma_addr_t addr;\n\tu32 rx_pkt_info, pos, len, rx_pkts_num = 0;\n\n\tpos = rxq->tail;\n\twhile (readl(priv->glb_base + GLB_IRQ_RAW) & IRQ_INT_RX_RDY) {\n\t\trx_pkt_info = readl(priv->port_base + IQFRM_DES);\n\t\tlen = rx_pkt_info & RX_FRAME_LEN_MASK;\n\t\tlen -= ETH_FCS_LEN;\n\n\t\t \n\t\twritel(IRQ_INT_RX_RDY, priv->glb_base + GLB_IRQ_RAW);\n\n\t\trx_pkts_num++;\n\n\t\tskb = rxq->skb[pos];\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(dev, \"rx skb NULL. pos=%d\\n\", pos);\n\t\t\tbreak;\n\t\t}\n\t\trxq->skb[pos] = NULL;\n\n\t\taddr = rxq->dma_phys[pos];\n\t\tdma_unmap_single(priv->dev, addr, MAX_FRAME_SIZE,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tskb_put(skb, len);\n\t\tif (unlikely(skb->len > MAX_FRAME_SIZE)) {\n\t\t\tnetdev_err(dev, \"rcv len err, len = %d\\n\", skb->len);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_length_errors++;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto next;\n\t\t}\n\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnapi_gro_receive(&priv->napi, skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += len;\nnext:\n\t\tpos = (pos + 1) % rxq->num;\n\t\tif (rx_pkts_num >= limit)\n\t\t\tbreak;\n\t}\n\trxq->tail = pos;\n\n\thisi_femac_rx_refill(priv);\n\n\treturn rx_pkts_num;\n}\n\nstatic int hisi_femac_poll(struct napi_struct *napi, int budget)\n{\n\tstruct hisi_femac_priv *priv = container_of(napi,\n\t\t\t\t\tstruct hisi_femac_priv, napi);\n\tstruct net_device *dev = priv->ndev;\n\tint work_done = 0, task = budget;\n\tint ints, num;\n\n\tdo {\n\t\thisi_femac_xmit_reclaim(dev);\n\t\tnum = hisi_femac_rx(dev, task);\n\t\twork_done += num;\n\t\ttask -= num;\n\t\tif (work_done >= budget)\n\t\t\tbreak;\n\n\t\tints = readl(priv->glb_base + GLB_IRQ_RAW);\n\t\twritel(ints & DEF_INT_MASK,\n\t\t       priv->glb_base + GLB_IRQ_RAW);\n\t} while (ints & DEF_INT_MASK);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\thisi_femac_irq_enable(priv, DEF_INT_MASK &\n\t\t\t\t\t(~IRQ_INT_TX_PER_PACKET));\n\t}\n\n\treturn work_done;\n}\n\nstatic irqreturn_t hisi_femac_interrupt(int irq, void *dev_id)\n{\n\tint ints;\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\n\tints = readl(priv->glb_base + GLB_IRQ_RAW);\n\n\tif (likely(ints & DEF_INT_MASK)) {\n\t\twritel(ints & DEF_INT_MASK,\n\t\t       priv->glb_base + GLB_IRQ_RAW);\n\t\thisi_femac_irq_disable(priv, DEF_INT_MASK);\n\t\tnapi_schedule(&priv->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hisi_femac_init_queue(struct device *dev,\n\t\t\t\t struct hisi_femac_queue *queue,\n\t\t\t\t unsigned int num)\n{\n\tqueue->skb = devm_kcalloc(dev, num, sizeof(struct sk_buff *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!queue->skb)\n\t\treturn -ENOMEM;\n\n\tqueue->dma_phys = devm_kcalloc(dev, num, sizeof(dma_addr_t),\n\t\t\t\t       GFP_KERNEL);\n\tif (!queue->dma_phys)\n\t\treturn -ENOMEM;\n\n\tqueue->num = num;\n\tqueue->head = 0;\n\tqueue->tail = 0;\n\n\treturn 0;\n}\n\nstatic int hisi_femac_init_tx_and_rx_queues(struct hisi_femac_priv *priv)\n{\n\tint ret;\n\n\tret = hisi_femac_init_queue(priv->dev, &priv->txq, TXQ_NUM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_femac_init_queue(priv->dev, &priv->rxq, RXQ_NUM);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->tx_fifo_used_cnt = 0;\n\n\treturn 0;\n}\n\nstatic void hisi_femac_free_skb_rings(struct hisi_femac_priv *priv)\n{\n\tstruct hisi_femac_queue *txq = &priv->txq;\n\tstruct hisi_femac_queue *rxq = &priv->rxq;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n\tu32 pos;\n\n\tpos = rxq->tail;\n\twhile (pos != rxq->head) {\n\t\tskb = rxq->skb[pos];\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(priv->ndev, \"NULL rx skb. pos=%d, head=%d\\n\",\n\t\t\t\t   pos, rxq->head);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdma_addr = rxq->dma_phys[pos];\n\t\tdma_unmap_single(priv->dev, dma_addr, MAX_FRAME_SIZE,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\tdev_kfree_skb_any(skb);\n\t\trxq->skb[pos] = NULL;\n\t\tpos = (pos + 1) % rxq->num;\n\t}\n\trxq->tail = pos;\n\n\tpos = txq->tail;\n\twhile (pos != txq->head) {\n\t\tskb = txq->skb[pos];\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(priv->ndev, \"NULL tx skb. pos=%d, head=%d\\n\",\n\t\t\t\t   pos, txq->head);\n\t\t\tcontinue;\n\t\t}\n\t\thisi_femac_tx_dma_unmap(priv, skb, pos);\n\t\tdev_kfree_skb_any(skb);\n\t\ttxq->skb[pos] = NULL;\n\t\tpos = (pos + 1) % txq->num;\n\t}\n\ttxq->tail = pos;\n\tpriv->tx_fifo_used_cnt = 0;\n}\n\nstatic int hisi_femac_set_hw_mac_addr(struct hisi_femac_priv *priv,\n\t\t\t\t      const unsigned char *mac)\n{\n\tu32 reg;\n\n\treg = mac[1] | (mac[0] << 8);\n\twritel(reg, priv->glb_base + GLB_HOSTMAC_H16);\n\n\treg = mac[5] | (mac[4] << 8) | (mac[3] << 16) | (mac[2] << 24);\n\twritel(reg, priv->glb_base + GLB_HOSTMAC_L32);\n\n\treturn 0;\n}\n\nstatic int hisi_femac_port_reset(struct hisi_femac_priv *priv)\n{\n\tu32 val;\n\n\tval = readl(priv->glb_base + GLB_SOFT_RESET);\n\tval |= SOFT_RESET_ALL;\n\twritel(val, priv->glb_base + GLB_SOFT_RESET);\n\n\tusleep_range(500, 800);\n\n\tval &= ~SOFT_RESET_ALL;\n\twritel(val, priv->glb_base + GLB_SOFT_RESET);\n\n\treturn 0;\n}\n\nstatic int hisi_femac_net_open(struct net_device *dev)\n{\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\n\thisi_femac_port_reset(priv);\n\thisi_femac_set_hw_mac_addr(priv, dev->dev_addr);\n\thisi_femac_rx_refill(priv);\n\n\tnetif_carrier_off(dev);\n\tnetdev_reset_queue(dev);\n\tnetif_start_queue(dev);\n\tnapi_enable(&priv->napi);\n\n\tpriv->link_status = 0;\n\tif (dev->phydev)\n\t\tphy_start(dev->phydev);\n\n\twritel(IRQ_ENA_PORT0_MASK, priv->glb_base + GLB_IRQ_RAW);\n\thisi_femac_irq_enable(priv, IRQ_ENA_ALL | IRQ_ENA_PORT0 | DEF_INT_MASK);\n\n\treturn 0;\n}\n\nstatic int hisi_femac_net_close(struct net_device *dev)\n{\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\n\thisi_femac_irq_disable(priv, IRQ_ENA_PORT0);\n\n\tif (dev->phydev)\n\t\tphy_stop(dev->phydev);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&priv->napi);\n\n\thisi_femac_free_skb_rings(priv);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t hisi_femac_net_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\tstruct hisi_femac_queue *txq = &priv->txq;\n\tdma_addr_t addr;\n\tu32 val;\n\n\tval = readl(priv->port_base + ADDRQ_STAT);\n\tval &= BIT_TX_READY;\n\tif (!val) {\n\t\thisi_femac_irq_enable(priv, IRQ_INT_TX_PER_PACKET);\n\t\tdev->stats.tx_dropped++;\n\t\tdev->stats.tx_fifo_errors++;\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (unlikely(!CIRC_SPACE(txq->head, txq->tail,\n\t\t\t\t txq->num))) {\n\t\thisi_femac_irq_enable(priv, IRQ_INT_TX_PER_PACKET);\n\t\tdev->stats.tx_dropped++;\n\t\tdev->stats.tx_fifo_errors++;\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\taddr = dma_map_single(priv->dev, skb->data,\n\t\t\t      skb->len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(priv->dev, addr))) {\n\t\tdev_kfree_skb_any(skb);\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\ttxq->dma_phys[txq->head] = addr;\n\n\ttxq->skb[txq->head] = skb;\n\ttxq->head = (txq->head + 1) % txq->num;\n\n\twritel(addr, priv->port_base + EQ_ADDR);\n\twritel(skb->len + ETH_FCS_LEN, priv->port_base + EQFRM_LEN);\n\n\tpriv->tx_fifo_used_cnt++;\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\tnetdev_sent_queue(dev, skb->len);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int hisi_femac_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\tstruct sockaddr *skaddr = p;\n\n\tif (!is_valid_ether_addr(skaddr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, skaddr->sa_data);\n\tdev->addr_assign_type &= ~NET_ADDR_RANDOM;\n\n\thisi_femac_set_hw_mac_addr(priv, dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic void hisi_femac_enable_hw_addr_filter(struct hisi_femac_priv *priv,\n\t\t\t\t\t     unsigned int reg_n, bool enable)\n{\n\tu32 val;\n\n\tval = readl(priv->glb_base + GLB_MAC_H16(reg_n));\n\tif (enable)\n\t\tval |= BIT_MACFLT_ENA;\n\telse\n\t\tval &= ~BIT_MACFLT_ENA;\n\twritel(val, priv->glb_base + GLB_MAC_H16(reg_n));\n}\n\nstatic void hisi_femac_set_hw_addr_filter(struct hisi_femac_priv *priv,\n\t\t\t\t\t  unsigned char *addr,\n\t\t\t\t\t  unsigned int reg_n)\n{\n\tunsigned int high, low;\n\tu32 val;\n\n\thigh = GLB_MAC_H16(reg_n);\n\tlow = GLB_MAC_L32(reg_n);\n\n\tval = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) | addr[5];\n\twritel(val, priv->glb_base + low);\n\n\tval = readl(priv->glb_base + high);\n\tval &= ~MACFLT_HI16_MASK;\n\tval |= ((addr[0] << 8) | addr[1]);\n\tval |= (BIT_MACFLT_ENA | BIT_MACFLT_FW2CPU);\n\twritel(val, priv->glb_base + high);\n}\n\nstatic void hisi_femac_set_promisc_mode(struct hisi_femac_priv *priv,\n\t\t\t\t\tbool promisc_mode)\n{\n\tu32 val;\n\n\tval = readl(priv->glb_base + GLB_FWCTRL);\n\tif (promisc_mode)\n\t\tval |= FWCTRL_FWALL2CPU;\n\telse\n\t\tval &= ~FWCTRL_FWALL2CPU;\n\twritel(val, priv->glb_base + GLB_FWCTRL);\n}\n\n \nstatic void hisi_femac_set_mc_addr_filter(struct hisi_femac_priv *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tu32 val;\n\n\tval = readl(priv->glb_base + GLB_MACTCTRL);\n\tif ((netdev_mc_count(dev) > MAX_MULTICAST_ADDRESSES) ||\n\t    (dev->flags & IFF_ALLMULTI)) {\n\t\tval |= MACTCTRL_MULTI2CPU;\n\t} else {\n\t\tint reg = MAX_UNICAST_ADDRESSES;\n\t\tint i;\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tfor (i = reg; i < MAX_MAC_FILTER_NUM; i++)\n\t\t\thisi_femac_enable_hw_addr_filter(priv, i, false);\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\thisi_femac_set_hw_addr_filter(priv, ha->addr, reg);\n\t\t\treg++;\n\t\t}\n\t\tval &= ~MACTCTRL_MULTI2CPU;\n\t}\n\twritel(val, priv->glb_base + GLB_MACTCTRL);\n}\n\n \nstatic void hisi_femac_set_uc_addr_filter(struct hisi_femac_priv *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tu32 val;\n\n\tval = readl(priv->glb_base + GLB_MACTCTRL);\n\tif (netdev_uc_count(dev) > MAX_UNICAST_ADDRESSES) {\n\t\tval |= MACTCTRL_UNI2CPU;\n\t} else {\n\t\tint reg = 0;\n\t\tint i;\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tfor (i = reg; i < MAX_UNICAST_ADDRESSES; i++)\n\t\t\thisi_femac_enable_hw_addr_filter(priv, i, false);\n\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\thisi_femac_set_hw_addr_filter(priv, ha->addr, reg);\n\t\t\treg++;\n\t\t}\n\t\tval &= ~MACTCTRL_UNI2CPU;\n\t}\n\twritel(val, priv->glb_base + GLB_MACTCTRL);\n}\n\nstatic void hisi_femac_net_set_rx_mode(struct net_device *dev)\n{\n\tstruct hisi_femac_priv *priv = netdev_priv(dev);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\thisi_femac_set_promisc_mode(priv, true);\n\t} else {\n\t\thisi_femac_set_promisc_mode(priv, false);\n\t\thisi_femac_set_mc_addr_filter(priv);\n\t\thisi_femac_set_uc_addr_filter(priv);\n\t}\n}\n\nstatic const struct ethtool_ops hisi_femac_ethtools_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops hisi_femac_netdev_ops = {\n\t.ndo_open\t\t= hisi_femac_net_open,\n\t.ndo_stop\t\t= hisi_femac_net_close,\n\t.ndo_start_xmit\t\t= hisi_femac_net_xmit,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_set_mac_address\t= hisi_femac_set_mac_address,\n\t.ndo_set_rx_mode\t= hisi_femac_net_set_rx_mode,\n};\n\nstatic void hisi_femac_core_reset(struct hisi_femac_priv *priv)\n{\n\treset_control_assert(priv->mac_rst);\n\treset_control_deassert(priv->mac_rst);\n}\n\nstatic void hisi_femac_sleep_us(u32 time_us)\n{\n\tu32 time_ms;\n\n\tif (!time_us)\n\t\treturn;\n\n\ttime_ms = DIV_ROUND_UP(time_us, 1000);\n\tif (time_ms < 20)\n\t\tusleep_range(time_us, time_us + 500);\n\telse\n\t\tmsleep(time_ms);\n}\n\nstatic void hisi_femac_phy_reset(struct hisi_femac_priv *priv)\n{\n\t \n\treset_control_deassert(priv->phy_rst);\n\thisi_femac_sleep_us(priv->phy_reset_delays[PRE_DELAY]);\n\n\treset_control_assert(priv->phy_rst);\n\t \n\thisi_femac_sleep_us(priv->phy_reset_delays[PULSE]);\n\treset_control_deassert(priv->phy_rst);\n\t \n\thisi_femac_sleep_us(priv->phy_reset_delays[POST_DELAY]);\n}\n\nstatic void hisi_femac_port_init(struct hisi_femac_priv *priv)\n{\n\tu32 val;\n\n\t \n\tval = MAC_PORTSEL_STAT_CPU;\n\tif (priv->ndev->phydev->interface == PHY_INTERFACE_MODE_RMII)\n\t\tval |= MAC_PORTSEL_RMII;\n\twritel(val, priv->port_base + MAC_PORTSEL);\n\n\t \n\twritel(IRQ_ENA_PORT0_MASK, priv->glb_base + GLB_IRQ_RAW);\n\thisi_femac_irq_disable(priv, IRQ_ENA_PORT0_MASK | IRQ_ENA_PORT0);\n\n\tval = readl(priv->glb_base + GLB_FWCTRL);\n\tval &= ~(FWCTRL_VLAN_ENABLE | FWCTRL_FWALL2CPU);\n\tval |= FWCTRL_FW2CPU_ENA;\n\twritel(val, priv->glb_base + GLB_FWCTRL);\n\n\tval = readl(priv->glb_base + GLB_MACTCTRL);\n\tval |= (MACTCTRL_BROAD2CPU | MACTCTRL_MACT_ENA);\n\twritel(val, priv->glb_base + GLB_MACTCTRL);\n\n\tval = readl(priv->port_base + MAC_SET);\n\tval &= ~MAX_FRAME_SIZE_MASK;\n\tval |= MAX_FRAME_SIZE;\n\twritel(val, priv->port_base + MAC_SET);\n\n\tval = RX_COALESCED_TIMER |\n\t\t(RX_COALESCED_FRAMES << RX_COALESCED_FRAME_OFFSET);\n\twritel(val, priv->port_base + RX_COALESCE_SET);\n\n\tval = (HW_RX_FIFO_DEPTH << RX_DEPTH_OFFSET) | HW_TX_FIFO_DEPTH;\n\twritel(val, priv->port_base + QLEN_SET);\n}\n\nstatic int hisi_femac_drv_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct net_device *ndev;\n\tstruct hisi_femac_priv *priv;\n\tstruct phy_device *phy;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(*priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tpriv = netdev_priv(ndev);\n\tpriv->dev = dev;\n\tpriv->ndev = ndev;\n\n\tpriv->port_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->port_base)) {\n\t\tret = PTR_ERR(priv->port_base);\n\t\tgoto out_free_netdev;\n\t}\n\n\tpriv->glb_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->glb_base)) {\n\t\tret = PTR_ERR(priv->glb_base);\n\t\tgoto out_free_netdev;\n\t}\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get clk\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free_netdev;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clk %d\\n\", ret);\n\t\tgoto out_free_netdev;\n\t}\n\n\tpriv->mac_rst = devm_reset_control_get(dev, \"mac\");\n\tif (IS_ERR(priv->mac_rst)) {\n\t\tret = PTR_ERR(priv->mac_rst);\n\t\tgoto out_disable_clk;\n\t}\n\thisi_femac_core_reset(priv);\n\n\tpriv->phy_rst = devm_reset_control_get(dev, \"phy\");\n\tif (IS_ERR(priv->phy_rst)) {\n\t\tpriv->phy_rst = NULL;\n\t} else {\n\t\tret = of_property_read_u32_array(node,\n\t\t\t\t\t\t PHY_RESET_DELAYS_PROPERTY,\n\t\t\t\t\t\t priv->phy_reset_delays,\n\t\t\t\t\t\t DELAYS_NUM);\n\t\tif (ret)\n\t\t\tgoto out_disable_clk;\n\t\thisi_femac_phy_reset(priv);\n\t}\n\n\tphy = of_phy_get_and_connect(ndev, node, hisi_femac_adjust_link);\n\tif (!phy) {\n\t\tdev_err(dev, \"connect to PHY failed!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_disable_clk;\n\t}\n\n\tphy_attached_print(phy, \"phy_id=0x%.8lx, phy_mode=%s\\n\",\n\t\t\t   (unsigned long)phy->phy_id,\n\t\t\t   phy_modes(phy->interface));\n\n\tret = of_get_ethdev_address(node, ndev);\n\tif (ret) {\n\t\teth_hw_addr_random(ndev);\n\t\tdev_warn(dev, \"using random MAC address %pM\\n\",\n\t\t\t ndev->dev_addr);\n\t}\n\n\tndev->watchdog_timeo = 6 * HZ;\n\tndev->priv_flags |= IFF_UNICAST_FLT;\n\tndev->netdev_ops = &hisi_femac_netdev_ops;\n\tndev->ethtool_ops = &hisi_femac_ethtools_ops;\n\tnetif_napi_add_weight(ndev, &priv->napi, hisi_femac_poll,\n\t\t\t      FEMAC_POLL_WEIGHT);\n\n\thisi_femac_port_init(priv);\n\n\tret = hisi_femac_init_tx_and_rx_queues(priv);\n\tif (ret)\n\t\tgoto out_disconnect_phy;\n\n\tndev->irq = platform_get_irq(pdev, 0);\n\tif (ndev->irq < 0) {\n\t\tret = ndev->irq;\n\t\tgoto out_disconnect_phy;\n\t}\n\n\tret = devm_request_irq(dev, ndev->irq, hisi_femac_interrupt,\n\t\t\t       IRQF_SHARED, pdev->name, ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"devm_request_irq %d failed!\\n\", ndev->irq);\n\t\tgoto out_disconnect_phy;\n\t}\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"register_netdev failed!\\n\");\n\t\tgoto out_disconnect_phy;\n\t}\n\n\treturn ret;\n\nout_disconnect_phy:\n\tnetif_napi_del(&priv->napi);\n\tphy_disconnect(phy);\nout_disable_clk:\n\tclk_disable_unprepare(priv->clk);\nout_free_netdev:\n\tfree_netdev(ndev);\n\n\treturn ret;\n}\n\nstatic int hisi_femac_drv_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct hisi_femac_priv *priv = netdev_priv(ndev);\n\n\tnetif_napi_del(&priv->napi);\n\tunregister_netdev(ndev);\n\n\tphy_disconnect(ndev->phydev);\n\tclk_disable_unprepare(priv->clk);\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int hisi_femac_drv_suspend(struct platform_device *pdev,\n\t\t\t\t  pm_message_t state)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct hisi_femac_priv *priv = netdev_priv(ndev);\n\n\tdisable_irq(ndev->irq);\n\tif (netif_running(ndev)) {\n\t\thisi_femac_net_close(ndev);\n\t\tnetif_device_detach(ndev);\n\t}\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int hisi_femac_drv_resume(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct hisi_femac_priv *priv = netdev_priv(ndev);\n\n\tclk_prepare_enable(priv->clk);\n\tif (priv->phy_rst)\n\t\thisi_femac_phy_reset(priv);\n\n\tif (netif_running(ndev)) {\n\t\thisi_femac_port_init(priv);\n\t\thisi_femac_net_open(ndev);\n\t\tnetif_device_attach(ndev);\n\t}\n\tenable_irq(ndev->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id hisi_femac_match[] = {\n\t{.compatible = \"hisilicon,hisi-femac-v1\",},\n\t{.compatible = \"hisilicon,hisi-femac-v2\",},\n\t{.compatible = \"hisilicon,hi3516cv300-femac\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, hisi_femac_match);\n\nstatic struct platform_driver hisi_femac_driver = {\n\t.driver = {\n\t\t.name = \"hisi-femac\",\n\t\t.of_match_table = hisi_femac_match,\n\t},\n\t.probe = hisi_femac_drv_probe,\n\t.remove = hisi_femac_drv_remove,\n#ifdef CONFIG_PM\n\t.suspend = hisi_femac_drv_suspend,\n\t.resume = hisi_femac_drv_resume,\n#endif\n};\n\nmodule_platform_driver(hisi_femac_driver);\n\nMODULE_DESCRIPTION(\"Hisilicon Fast Ethernet MAC driver\");\nMODULE_AUTHOR(\"Dongpo Li <lidongpo@hisilicon.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:hisi-femac\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}