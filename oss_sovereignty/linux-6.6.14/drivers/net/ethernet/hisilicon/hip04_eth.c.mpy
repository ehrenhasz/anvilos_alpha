{
  "module_name": "hip04_eth.c",
  "hash_id": "55bd21266a31b16deaebc1bef0e48eef585a7e5385abb1b3b61bf8cbb9df6357",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/hisilicon/hip04_eth.c",
  "human_readable_source": "\n\n \n\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/ktime.h>\n#include <linux/of_address.h>\n#include <linux/phy.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#define SC_PPE_RESET_DREQ\t\t0x026C\n\n#define PPE_CFG_RX_ADDR\t\t\t0x100\n#define PPE_CFG_POOL_GRP\t\t0x300\n#define PPE_CFG_RX_BUF_SIZE\t\t0x400\n#define PPE_CFG_RX_FIFO_SIZE\t\t0x500\n#define PPE_CURR_BUF_CNT\t\t0xa200\n\n#define GE_DUPLEX_TYPE\t\t\t0x08\n#define GE_MAX_FRM_SIZE_REG\t\t0x3c\n#define GE_PORT_MODE\t\t\t0x40\n#define GE_PORT_EN\t\t\t0x44\n#define GE_SHORT_RUNTS_THR_REG\t\t0x50\n#define GE_TX_LOCAL_PAGE_REG\t\t0x5c\n#define GE_TRANSMIT_CONTROL_REG\t\t0x60\n#define GE_CF_CRC_STRIP_REG\t\t0x1b0\n#define GE_MODE_CHANGE_REG\t\t0x1b4\n#define GE_RECV_CONTROL_REG\t\t0x1e0\n#define GE_STATION_MAC_ADDRESS\t\t0x210\n\n#define PPE_CFG_BUS_CTRL_REG\t\t0x424\n#define PPE_CFG_RX_CTRL_REG\t\t0x428\n\n#if defined(CONFIG_HI13X1_GMAC)\n#define PPE_CFG_CPU_ADD_ADDR\t\t0x6D0\n#define PPE_CFG_MAX_FRAME_LEN_REG\t0x500\n#define PPE_CFG_RX_PKT_MODE_REG\t\t0x504\n#define PPE_CFG_QOS_VMID_GEN\t\t0x520\n#define PPE_CFG_RX_PKT_INT\t\t0x740\n#define PPE_INTEN\t\t\t0x700\n#define PPE_INTSTS\t\t\t0x708\n#define PPE_RINT\t\t\t0x704\n#define PPE_CFG_STS_MODE\t\t0x880\n#else\n#define PPE_CFG_CPU_ADD_ADDR\t\t0x580\n#define PPE_CFG_MAX_FRAME_LEN_REG\t0x408\n#define PPE_CFG_RX_PKT_MODE_REG\t\t0x438\n#define PPE_CFG_QOS_VMID_GEN\t\t0x500\n#define PPE_CFG_RX_PKT_INT\t\t0x538\n#define PPE_INTEN\t\t\t0x600\n#define PPE_INTSTS\t\t\t0x608\n#define PPE_RINT\t\t\t0x604\n#define PPE_CFG_STS_MODE\t\t0x700\n#endif  \n\n#define PPE_HIS_RX_PKT_CNT\t\t0x804\n\n#define RESET_DREQ_ALL\t\t\t0xffffffff\n\n \n#define RCV_INT\t\t\t\tBIT(10)\n#define RCV_NOBUF\t\t\tBIT(8)\n#define RCV_DROP\t\t\tBIT(7)\n#define TX_DROP\t\t\t\tBIT(6)\n#define DEF_INT_ERR\t\t\t(RCV_NOBUF | RCV_DROP | TX_DROP)\n#define DEF_INT_MASK\t\t\t(RCV_INT | DEF_INT_ERR)\n\n \n#define TX_FREE_MEM\t\t\tBIT(0)\n#define TX_READ_ALLOC_L3\t\tBIT(1)\n#if defined(CONFIG_HI13X1_GMAC)\n#define TX_CLEAR_WB\t\t\tBIT(7)\n#define TX_RELEASE_TO_PPE\t\tBIT(4)\n#define TX_FINISH_CACHE_INV\t\tBIT(6)\n#define TX_POOL_SHIFT\t\t\t16\n#else\n#define TX_CLEAR_WB\t\t\tBIT(4)\n#define TX_FINISH_CACHE_INV\t\tBIT(2)\n#endif\n#define TX_L3_CHECKSUM\t\t\tBIT(5)\n#define TX_LOOP_BACK\t\t\tBIT(11)\n\n \n#define RX_PKT_DROP\t\t\tBIT(0)\n#define RX_L2_ERR\t\t\tBIT(1)\n#define RX_PKT_ERR\t\t\t(RX_PKT_DROP | RX_L2_ERR)\n\n#define SGMII_SPEED_1000\t\t0x08\n#define SGMII_SPEED_100\t\t\t0x07\n#define SGMII_SPEED_10\t\t\t0x06\n#define MII_SPEED_100\t\t\t0x01\n#define MII_SPEED_10\t\t\t0x00\n\n#define GE_DUPLEX_FULL\t\t\tBIT(0)\n#define GE_DUPLEX_HALF\t\t\t0x00\n#define GE_MODE_CHANGE_EN\t\tBIT(0)\n\n#define GE_TX_AUTO_NEG\t\t\tBIT(5)\n#define GE_TX_ADD_CRC\t\t\tBIT(6)\n#define GE_TX_SHORT_PAD_THROUGH\t\tBIT(7)\n\n#define GE_RX_STRIP_CRC\t\t\tBIT(0)\n#define GE_RX_STRIP_PAD\t\t\tBIT(3)\n#define GE_RX_PAD_EN\t\t\tBIT(4)\n\n#define GE_AUTO_NEG_CTL\t\t\tBIT(0)\n\n#define GE_RX_INT_THRESHOLD\t\tBIT(6)\n#define GE_RX_TIMEOUT\t\t\t0x04\n\n#define GE_RX_PORT_EN\t\t\tBIT(1)\n#define GE_TX_PORT_EN\t\t\tBIT(2)\n\n#define PPE_CFG_RX_PKT_ALIGN\t\tBIT(18)\n\n#if defined(CONFIG_HI13X1_GMAC)\n#define PPE_CFG_QOS_VMID_GRP_SHIFT\t4\n#define PPE_CFG_RX_CTRL_ALIGN_SHIFT\t7\n#define PPE_CFG_STS_RX_PKT_CNT_RC\tBIT(0)\n#define PPE_CFG_QOS_VMID_MODE\t\tBIT(15)\n#define PPE_CFG_BUS_LOCAL_REL\t\t(BIT(9) | BIT(15) | BIT(19) | BIT(23))\n\n \n#define PPE_BUF_SIZE_SHIFT\t\t6\n#define PPE_TX_BUF_HOLD\t\t\tBIT(31)\n#define SOC_CACHE_LINE_MASK\t\t0x3F\n#else\n#define PPE_CFG_QOS_VMID_GRP_SHIFT\t8\n#define PPE_CFG_RX_CTRL_ALIGN_SHIFT\t11\n#define PPE_CFG_STS_RX_PKT_CNT_RC\tBIT(12)\n#define PPE_CFG_QOS_VMID_MODE\t\tBIT(14)\n#define PPE_CFG_BUS_LOCAL_REL\t\tBIT(14)\n\n \n#define PPE_BUF_SIZE_SHIFT\t\t0\n#define PPE_TX_BUF_HOLD\t\t\t0\n#endif  \n\n#define PPE_CFG_RX_FIFO_FSFU\t\tBIT(11)\n#define PPE_CFG_RX_DEPTH_SHIFT\t\t16\n#define PPE_CFG_RX_START_SHIFT\t\t0\n\n#define PPE_CFG_BUS_BIG_ENDIEN\t\tBIT(0)\n\n#define RX_DESC_NUM\t\t\t128\n#define TX_DESC_NUM\t\t\t256\n#define TX_NEXT(N)\t\t\t(((N) + 1) & (TX_DESC_NUM-1))\n#define RX_NEXT(N)\t\t\t(((N) + 1) & (RX_DESC_NUM-1))\n\n#define GMAC_PPE_RX_PKT_MAX_LEN\t\t379\n#define GMAC_MAX_PKT_LEN\t\t1516\n#define GMAC_MIN_PKT_LEN\t\t31\n#define RX_BUF_SIZE\t\t\t1600\n#define RESET_TIMEOUT\t\t\t1000\n#define TX_TIMEOUT\t\t\t(6 * HZ)\n\n#define DRV_NAME\t\t\t\"hip04-ether\"\n#define DRV_VERSION\t\t\t\"v1.0\"\n\n#define HIP04_MAX_TX_COALESCE_USECS\t200\n#define HIP04_MIN_TX_COALESCE_USECS\t100\n#define HIP04_MAX_TX_COALESCE_FRAMES\t200\n#define HIP04_MIN_TX_COALESCE_FRAMES\t100\n\nstruct tx_desc {\n#if defined(CONFIG_HI13X1_GMAC)\n\tu32 reserved1[2];\n\tu32 send_addr;\n\tu16 send_size;\n\tu16 data_offset;\n\tu32 reserved2[7];\n\tu32 cfg;\n\tu32 wb_addr;\n\tu32 reserved3[3];\n#else\n\tu32 send_addr;\n\tu32 send_size;\n\tu32 next_addr;\n\tu32 cfg;\n\tu32 wb_addr;\n#endif\n} __aligned(64);\n\nstruct rx_desc {\n#if defined(CONFIG_HI13X1_GMAC)\n\tu32 reserved1[3];\n\tu16 pkt_len;\n\tu16 reserved_16;\n\tu32 reserved2[6];\n\tu32 pkt_err;\n\tu32 reserved3[5];\n#else\n\tu16 reserved_16;\n\tu16 pkt_len;\n\tu32 reserve1[3];\n\tu32 pkt_err;\n\tu32 reserve2[4];\n#endif\n};\n\nstruct hip04_priv {\n\tvoid __iomem *base;\n#if defined(CONFIG_HI13X1_GMAC)\n\tvoid __iomem *sysctrl_base;\n#endif\n\tphy_interface_t phy_mode;\n\tint chan;\n\tunsigned int port;\n\tunsigned int group;\n\tunsigned int speed;\n\tunsigned int duplex;\n\tunsigned int reg_inten;\n\n\tstruct napi_struct napi;\n\tstruct device *dev;\n\tstruct net_device *ndev;\n\n\tstruct tx_desc *tx_desc;\n\tdma_addr_t tx_desc_dma;\n\tstruct sk_buff *tx_skb[TX_DESC_NUM];\n\tdma_addr_t tx_phys[TX_DESC_NUM];\n\tunsigned int tx_head;\n\n\tint tx_coalesce_frames;\n\tint tx_coalesce_usecs;\n\tstruct hrtimer tx_coalesce_timer;\n\n\tunsigned char *rx_buf[RX_DESC_NUM];\n\tdma_addr_t rx_phys[RX_DESC_NUM];\n\tunsigned int rx_head;\n\tunsigned int rx_buf_size;\n\tunsigned int rx_cnt_remaining;\n\n\tstruct device_node *phy_node;\n\tstruct phy_device *phy;\n\tstruct regmap *map;\n\tstruct work_struct tx_timeout_task;\n\n\t \n\tunsigned int tx_tail ____cacheline_aligned_in_smp;\n};\n\nstatic inline unsigned int tx_count(unsigned int head, unsigned int tail)\n{\n\treturn (head - tail) % TX_DESC_NUM;\n}\n\nstatic void hip04_config_port(struct net_device *ndev, u32 speed, u32 duplex)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tu32 val;\n\n\tpriv->speed = speed;\n\tpriv->duplex = duplex;\n\n\tswitch (priv->phy_mode) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tif (speed == SPEED_1000)\n\t\t\tval = SGMII_SPEED_1000;\n\t\telse if (speed == SPEED_100)\n\t\t\tval = SGMII_SPEED_100;\n\t\telse\n\t\t\tval = SGMII_SPEED_10;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tif (speed == SPEED_100)\n\t\t\tval = MII_SPEED_100;\n\t\telse\n\t\t\tval = MII_SPEED_10;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(ndev, \"not supported mode\\n\");\n\t\tval = MII_SPEED_10;\n\t\tbreak;\n\t}\n\twritel_relaxed(val, priv->base + GE_PORT_MODE);\n\n\tval = duplex ? GE_DUPLEX_FULL : GE_DUPLEX_HALF;\n\twritel_relaxed(val, priv->base + GE_DUPLEX_TYPE);\n\n\tval = GE_MODE_CHANGE_EN;\n\twritel_relaxed(val, priv->base + GE_MODE_CHANGE_REG);\n}\n\nstatic void hip04_reset_dreq(struct hip04_priv *priv)\n{\n#if defined(CONFIG_HI13X1_GMAC)\n\twritel_relaxed(RESET_DREQ_ALL, priv->sysctrl_base + SC_PPE_RESET_DREQ);\n#endif\n}\n\nstatic void hip04_reset_ppe(struct hip04_priv *priv)\n{\n\tu32 val, tmp, timeout = 0;\n\n\tdo {\n\t\tregmap_read(priv->map, priv->port * 4 + PPE_CURR_BUF_CNT, &val);\n\t\tregmap_read(priv->map, priv->port * 4 + PPE_CFG_RX_ADDR, &tmp);\n\t\tif (timeout++ > RESET_TIMEOUT)\n\t\t\tbreak;\n\t} while (val & 0xfff);\n}\n\nstatic void hip04_config_fifo(struct hip04_priv *priv)\n{\n\tu32 val;\n\n\tval = readl_relaxed(priv->base + PPE_CFG_STS_MODE);\n\tval |= PPE_CFG_STS_RX_PKT_CNT_RC;\n\twritel_relaxed(val, priv->base + PPE_CFG_STS_MODE);\n\n\tval = BIT(priv->group);\n\tregmap_write(priv->map, priv->port * 4 + PPE_CFG_POOL_GRP, val);\n\n\tval = priv->group << PPE_CFG_QOS_VMID_GRP_SHIFT;\n\tval |= PPE_CFG_QOS_VMID_MODE;\n\twritel_relaxed(val, priv->base + PPE_CFG_QOS_VMID_GEN);\n\n\tval = RX_BUF_SIZE >> PPE_BUF_SIZE_SHIFT;\n\tregmap_write(priv->map, priv->port * 4 + PPE_CFG_RX_BUF_SIZE, val);\n\n\tval = RX_DESC_NUM << PPE_CFG_RX_DEPTH_SHIFT;\n\tval |= PPE_CFG_RX_FIFO_FSFU;\n\tval |= priv->chan << PPE_CFG_RX_START_SHIFT;\n\tregmap_write(priv->map, priv->port * 4 + PPE_CFG_RX_FIFO_SIZE, val);\n\n\tval = NET_IP_ALIGN << PPE_CFG_RX_CTRL_ALIGN_SHIFT;\n\twritel_relaxed(val, priv->base + PPE_CFG_RX_CTRL_REG);\n\n\tval = PPE_CFG_RX_PKT_ALIGN;\n\twritel_relaxed(val, priv->base + PPE_CFG_RX_PKT_MODE_REG);\n\n\tval = PPE_CFG_BUS_LOCAL_REL | PPE_CFG_BUS_BIG_ENDIEN;\n\twritel_relaxed(val, priv->base + PPE_CFG_BUS_CTRL_REG);\n\n\tval = GMAC_PPE_RX_PKT_MAX_LEN;\n\twritel_relaxed(val, priv->base + PPE_CFG_MAX_FRAME_LEN_REG);\n\n\tval = GMAC_MAX_PKT_LEN;\n\twritel_relaxed(val, priv->base + GE_MAX_FRM_SIZE_REG);\n\n\tval = GMAC_MIN_PKT_LEN;\n\twritel_relaxed(val, priv->base + GE_SHORT_RUNTS_THR_REG);\n\n\tval = readl_relaxed(priv->base + GE_TRANSMIT_CONTROL_REG);\n\tval |= GE_TX_AUTO_NEG | GE_TX_ADD_CRC | GE_TX_SHORT_PAD_THROUGH;\n\twritel_relaxed(val, priv->base + GE_TRANSMIT_CONTROL_REG);\n\n\tval = GE_RX_STRIP_CRC;\n\twritel_relaxed(val, priv->base + GE_CF_CRC_STRIP_REG);\n\n\tval = readl_relaxed(priv->base + GE_RECV_CONTROL_REG);\n\tval |= GE_RX_STRIP_PAD | GE_RX_PAD_EN;\n\twritel_relaxed(val, priv->base + GE_RECV_CONTROL_REG);\n\n#ifndef CONFIG_HI13X1_GMAC\n\tval = GE_AUTO_NEG_CTL;\n\twritel_relaxed(val, priv->base + GE_TX_LOCAL_PAGE_REG);\n#endif\n}\n\nstatic void hip04_mac_enable(struct net_device *ndev)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tu32 val;\n\n\t \n\tval = readl_relaxed(priv->base + GE_PORT_EN);\n\tval |= GE_RX_PORT_EN | GE_TX_PORT_EN;\n\twritel_relaxed(val, priv->base + GE_PORT_EN);\n\n\t \n\tval = RCV_INT;\n\twritel_relaxed(val, priv->base + PPE_RINT);\n\n\t \n\tval = GE_RX_INT_THRESHOLD | GE_RX_TIMEOUT;\n\twritel_relaxed(val, priv->base + PPE_CFG_RX_PKT_INT);\n\n\t \n\tpriv->reg_inten = DEF_INT_MASK;\n\twritel_relaxed(priv->reg_inten, priv->base + PPE_INTEN);\n}\n\nstatic void hip04_mac_disable(struct net_device *ndev)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tu32 val;\n\n\t \n\tpriv->reg_inten &= ~(DEF_INT_MASK);\n\twritel_relaxed(priv->reg_inten, priv->base + PPE_INTEN);\n\n\t \n\tval = readl_relaxed(priv->base + GE_PORT_EN);\n\tval &= ~(GE_RX_PORT_EN | GE_TX_PORT_EN);\n\twritel_relaxed(val, priv->base + GE_PORT_EN);\n}\n\nstatic void hip04_set_xmit_desc(struct hip04_priv *priv, dma_addr_t phys)\n{\n\tu32 val;\n\n\tval = phys >> PPE_BUF_SIZE_SHIFT | PPE_TX_BUF_HOLD;\n\twritel(val, priv->base + PPE_CFG_CPU_ADD_ADDR);\n}\n\nstatic void hip04_set_recv_desc(struct hip04_priv *priv, dma_addr_t phys)\n{\n\tu32 val;\n\n\tval = phys >> PPE_BUF_SIZE_SHIFT;\n\tregmap_write(priv->map, priv->port * 4 + PPE_CFG_RX_ADDR, val);\n}\n\nstatic u32 hip04_recv_cnt(struct hip04_priv *priv)\n{\n\treturn readl(priv->base + PPE_HIS_RX_PKT_CNT);\n}\n\nstatic void hip04_update_mac_address(struct net_device *ndev)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\n\twritel_relaxed(((ndev->dev_addr[0] << 8) | (ndev->dev_addr[1])),\n\t\t       priv->base + GE_STATION_MAC_ADDRESS);\n\twritel_relaxed(((ndev->dev_addr[2] << 24) | (ndev->dev_addr[3] << 16) |\n\t\t\t(ndev->dev_addr[4] << 8) | (ndev->dev_addr[5])),\n\t\t       priv->base + GE_STATION_MAC_ADDRESS + 4);\n}\n\nstatic int hip04_set_mac_address(struct net_device *ndev, void *addr)\n{\n\teth_mac_addr(ndev, addr);\n\thip04_update_mac_address(ndev);\n\treturn 0;\n}\n\nstatic int hip04_tx_reclaim(struct net_device *ndev, bool force)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tunsigned tx_tail = priv->tx_tail;\n\tstruct tx_desc *desc;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\tunsigned int count;\n\n\tsmp_rmb();\n\tcount = tx_count(READ_ONCE(priv->tx_head), tx_tail);\n\tif (count == 0)\n\t\tgoto out;\n\n\twhile (count) {\n\t\tdesc = &priv->tx_desc[tx_tail];\n\t\tif (desc->send_addr != 0) {\n\t\t\tif (force)\n\t\t\t\tdesc->send_addr = 0;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (priv->tx_phys[tx_tail]) {\n\t\t\tdma_unmap_single(priv->dev, priv->tx_phys[tx_tail],\n\t\t\t\t\t priv->tx_skb[tx_tail]->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tpriv->tx_phys[tx_tail] = 0;\n\t\t}\n\t\tpkts_compl++;\n\t\tbytes_compl += priv->tx_skb[tx_tail]->len;\n\t\tdev_kfree_skb(priv->tx_skb[tx_tail]);\n\t\tpriv->tx_skb[tx_tail] = NULL;\n\t\ttx_tail = TX_NEXT(tx_tail);\n\t\tcount--;\n\t}\n\n\tpriv->tx_tail = tx_tail;\n\tsmp_wmb();  \n\nout:\n\tif (pkts_compl || bytes_compl)\n\t\tnetdev_completed_queue(ndev, pkts_compl, bytes_compl);\n\n\tif (unlikely(netif_queue_stopped(ndev)) && (count < (TX_DESC_NUM - 1)))\n\t\tnetif_wake_queue(ndev);\n\n\treturn count;\n}\n\nstatic void hip04_start_tx_timer(struct hip04_priv *priv)\n{\n\tunsigned long ns = priv->tx_coalesce_usecs * NSEC_PER_USEC / 2;\n\n\t \n\thrtimer_start_range_ns(&priv->tx_coalesce_timer, ns_to_ktime(ns),\n\t\t\t       ns, HRTIMER_MODE_REL);\n}\n\nstatic netdev_tx_t\nhip04_mac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tunsigned int tx_head = priv->tx_head, count;\n\tstruct tx_desc *desc = &priv->tx_desc[tx_head];\n\tdma_addr_t phys;\n\n\tsmp_rmb();\n\tcount = tx_count(tx_head, READ_ONCE(priv->tx_tail));\n\tif (count == (TX_DESC_NUM - 1)) {\n\t\tnetif_stop_queue(ndev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tphys = dma_map_single(priv->dev, skb->data, skb->len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(priv->dev, phys)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tpriv->tx_skb[tx_head] = skb;\n\tpriv->tx_phys[tx_head] = phys;\n\n\tdesc->send_size = (__force u32)cpu_to_be32(skb->len);\n#if defined(CONFIG_HI13X1_GMAC)\n\tdesc->cfg = (__force u32)cpu_to_be32(TX_CLEAR_WB | TX_FINISH_CACHE_INV\n\t\t| TX_RELEASE_TO_PPE | priv->port << TX_POOL_SHIFT);\n\tdesc->data_offset = (__force u32)cpu_to_be32(phys & SOC_CACHE_LINE_MASK);\n\tdesc->send_addr =  (__force u32)cpu_to_be32(phys & ~SOC_CACHE_LINE_MASK);\n#else\n\tdesc->cfg = (__force u32)cpu_to_be32(TX_CLEAR_WB | TX_FINISH_CACHE_INV);\n\tdesc->send_addr = (__force u32)cpu_to_be32(phys);\n#endif\n\tphys = priv->tx_desc_dma + tx_head * sizeof(struct tx_desc);\n\tdesc->wb_addr = (__force u32)cpu_to_be32(phys +\n\t\toffsetof(struct tx_desc, send_addr));\n\tskb_tx_timestamp(skb);\n\n\thip04_set_xmit_desc(priv, phys);\n\tcount++;\n\tnetdev_sent_queue(ndev, skb->len);\n\tpriv->tx_head = TX_NEXT(tx_head);\n\n\tstats->tx_bytes += skb->len;\n\tstats->tx_packets++;\n\n\t \n\tsmp_wmb();\n\n\t \n\tif (count >= priv->tx_coalesce_frames) {\n\t\tif (napi_schedule_prep(&priv->napi)) {\n\t\t\t \n\t\t\tpriv->reg_inten &= ~(RCV_INT);\n\t\t\twritel_relaxed(DEF_INT_MASK & ~RCV_INT,\n\t\t\t\t       priv->base + PPE_INTEN);\n\t\t\thrtimer_cancel(&priv->tx_coalesce_timer);\n\t\t\t__napi_schedule(&priv->napi);\n\t\t}\n\t} else if (!hrtimer_is_queued(&priv->tx_coalesce_timer)) {\n\t\t \n\t\thip04_start_tx_timer(priv);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int hip04_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct hip04_priv *priv = container_of(napi, struct hip04_priv, napi);\n\tstruct net_device *ndev = priv->ndev;\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct rx_desc *desc;\n\tstruct sk_buff *skb;\n\tunsigned char *buf;\n\tbool last = false;\n\tdma_addr_t phys;\n\tint rx = 0;\n\tint tx_remaining;\n\tu16 len;\n\tu32 err;\n\n\t \n\ttx_remaining = hip04_tx_reclaim(ndev, false);\n\tpriv->rx_cnt_remaining += hip04_recv_cnt(priv);\n\twhile (priv->rx_cnt_remaining && !last) {\n\t\tbuf = priv->rx_buf[priv->rx_head];\n\t\tskb = build_skb(buf, priv->rx_buf_size);\n\t\tif (unlikely(!skb)) {\n\t\t\tnet_dbg_ratelimited(\"build_skb failed\\n\");\n\t\t\tgoto refill;\n\t\t}\n\n\t\tdma_unmap_single(priv->dev, priv->rx_phys[priv->rx_head],\n\t\t\t\t RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tpriv->rx_phys[priv->rx_head] = 0;\n\n\t\tdesc = (struct rx_desc *)skb->data;\n\t\tlen = be16_to_cpu((__force __be16)desc->pkt_len);\n\t\terr = be32_to_cpu((__force __be32)desc->pkt_err);\n\n\t\tif (0 == len) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tlast = true;\n\t\t} else if ((err & RX_PKT_ERR) || (len >= GMAC_MAX_PKT_LEN)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tstats->rx_dropped++;\n\t\t\tstats->rx_errors++;\n\t\t} else {\n\t\t\tskb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);\n\t\t\tskb_put(skb, len);\n\t\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\t\tnapi_gro_receive(&priv->napi, skb);\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += len;\n\t\t\trx++;\n\t\t}\n\nrefill:\n\t\tbuf = netdev_alloc_frag(priv->rx_buf_size);\n\t\tif (!buf)\n\t\t\tgoto done;\n\t\tphys = dma_map_single(priv->dev, buf,\n\t\t\t\t      RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(priv->dev, phys))\n\t\t\tgoto done;\n\t\tpriv->rx_buf[priv->rx_head] = buf;\n\t\tpriv->rx_phys[priv->rx_head] = phys;\n\t\thip04_set_recv_desc(priv, phys);\n\n\t\tpriv->rx_head = RX_NEXT(priv->rx_head);\n\t\tif (rx >= budget) {\n\t\t\t--priv->rx_cnt_remaining;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (--priv->rx_cnt_remaining == 0)\n\t\t\tpriv->rx_cnt_remaining += hip04_recv_cnt(priv);\n\t}\n\n\tif (!(priv->reg_inten & RCV_INT)) {\n\t\t \n\t\tpriv->reg_inten |= RCV_INT;\n\t\twritel_relaxed(priv->reg_inten, priv->base + PPE_INTEN);\n\t}\n\tnapi_complete_done(napi, rx);\ndone:\n\t \n\tif (rx < budget && tx_remaining)\n\t\thip04_start_tx_timer(priv);\n\n\treturn rx;\n}\n\nstatic irqreturn_t hip04_mac_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = (struct net_device *)dev_id;\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tu32 ists = readl_relaxed(priv->base + PPE_INTSTS);\n\n\tif (!ists)\n\t\treturn IRQ_NONE;\n\n\twritel_relaxed(DEF_INT_MASK, priv->base + PPE_RINT);\n\n\tif (unlikely(ists & DEF_INT_ERR)) {\n\t\tif (ists & (RCV_NOBUF | RCV_DROP)) {\n\t\t\tstats->rx_errors++;\n\t\t\tstats->rx_dropped++;\n\t\t\tnetdev_err(ndev, \"rx drop\\n\");\n\t\t}\n\t\tif (ists & TX_DROP) {\n\t\t\tstats->tx_dropped++;\n\t\t\tnetdev_err(ndev, \"tx drop\\n\");\n\t\t}\n\t}\n\n\tif (ists & RCV_INT && napi_schedule_prep(&priv->napi)) {\n\t\t \n\t\tpriv->reg_inten &= ~(RCV_INT);\n\t\twritel_relaxed(DEF_INT_MASK & ~RCV_INT, priv->base + PPE_INTEN);\n\t\thrtimer_cancel(&priv->tx_coalesce_timer);\n\t\t__napi_schedule(&priv->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic enum hrtimer_restart tx_done(struct hrtimer *hrtimer)\n{\n\tstruct hip04_priv *priv;\n\n\tpriv = container_of(hrtimer, struct hip04_priv, tx_coalesce_timer);\n\n\tif (napi_schedule_prep(&priv->napi)) {\n\t\t \n\t\tpriv->reg_inten &= ~(RCV_INT);\n\t\twritel_relaxed(DEF_INT_MASK & ~RCV_INT, priv->base + PPE_INTEN);\n\t\t__napi_schedule(&priv->napi);\n\t}\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void hip04_adjust_link(struct net_device *ndev)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tstruct phy_device *phy = priv->phy;\n\n\tif ((priv->speed != phy->speed) || (priv->duplex != phy->duplex)) {\n\t\thip04_config_port(ndev, phy->speed, phy->duplex);\n\t\tphy_print_status(phy);\n\t}\n}\n\nstatic int hip04_mac_open(struct net_device *ndev)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tint i;\n\n\tpriv->rx_head = 0;\n\tpriv->rx_cnt_remaining = 0;\n\tpriv->tx_head = 0;\n\tpriv->tx_tail = 0;\n\thip04_reset_ppe(priv);\n\n\tfor (i = 0; i < RX_DESC_NUM; i++) {\n\t\tdma_addr_t phys;\n\n\t\tphys = dma_map_single(priv->dev, priv->rx_buf[i],\n\t\t\t\t      RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(priv->dev, phys))\n\t\t\treturn -EIO;\n\n\t\tpriv->rx_phys[i] = phys;\n\t\thip04_set_recv_desc(priv, phys);\n\t}\n\n\tif (priv->phy)\n\t\tphy_start(priv->phy);\n\n\tnetdev_reset_queue(ndev);\n\tnetif_start_queue(ndev);\n\thip04_mac_enable(ndev);\n\tnapi_enable(&priv->napi);\n\n\treturn 0;\n}\n\nstatic int hip04_mac_stop(struct net_device *ndev)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tint i;\n\n\tnapi_disable(&priv->napi);\n\tnetif_stop_queue(ndev);\n\thip04_mac_disable(ndev);\n\thip04_tx_reclaim(ndev, true);\n\thip04_reset_ppe(priv);\n\n\tif (priv->phy)\n\t\tphy_stop(priv->phy);\n\n\tfor (i = 0; i < RX_DESC_NUM; i++) {\n\t\tif (priv->rx_phys[i]) {\n\t\t\tdma_unmap_single(priv->dev, priv->rx_phys[i],\n\t\t\t\t\t RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tpriv->rx_phys[i] = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hip04_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\n\tschedule_work(&priv->tx_timeout_task);\n}\n\nstatic void hip04_tx_timeout_task(struct work_struct *work)\n{\n\tstruct hip04_priv *priv;\n\n\tpriv = container_of(work, struct hip04_priv, tx_timeout_task);\n\thip04_mac_stop(priv->ndev);\n\thip04_mac_open(priv->ndev);\n}\n\nstatic int hip04_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct hip04_priv *priv = netdev_priv(netdev);\n\n\tec->tx_coalesce_usecs = priv->tx_coalesce_usecs;\n\tec->tx_max_coalesced_frames = priv->tx_coalesce_frames;\n\n\treturn 0;\n}\n\nstatic int hip04_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct hip04_priv *priv = netdev_priv(netdev);\n\n\tif ((ec->tx_coalesce_usecs > HIP04_MAX_TX_COALESCE_USECS ||\n\t     ec->tx_coalesce_usecs < HIP04_MIN_TX_COALESCE_USECS) ||\n\t    (ec->tx_max_coalesced_frames > HIP04_MAX_TX_COALESCE_FRAMES ||\n\t     ec->tx_max_coalesced_frames < HIP04_MIN_TX_COALESCE_FRAMES))\n\t\treturn -EINVAL;\n\n\tpriv->tx_coalesce_usecs = ec->tx_coalesce_usecs;\n\tpriv->tx_coalesce_frames = ec->tx_max_coalesced_frames;\n\n\treturn 0;\n}\n\nstatic void hip04_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));\n}\n\nstatic const struct ethtool_ops hip04_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_TX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_TX_MAX_FRAMES,\n\t.get_coalesce\t\t= hip04_get_coalesce,\n\t.set_coalesce\t\t= hip04_set_coalesce,\n\t.get_drvinfo\t\t= hip04_get_drvinfo,\n};\n\nstatic const struct net_device_ops hip04_netdev_ops = {\n\t.ndo_open\t\t= hip04_mac_open,\n\t.ndo_stop\t\t= hip04_mac_stop,\n\t.ndo_start_xmit\t\t= hip04_mac_start_xmit,\n\t.ndo_set_mac_address\t= hip04_set_mac_address,\n\t.ndo_tx_timeout         = hip04_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int hip04_alloc_ring(struct net_device *ndev, struct device *d)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tint i;\n\n\tpriv->tx_desc = dma_alloc_coherent(d,\n\t\t\t\t\t   TX_DESC_NUM * sizeof(struct tx_desc),\n\t\t\t\t\t   &priv->tx_desc_dma, GFP_KERNEL);\n\tif (!priv->tx_desc)\n\t\treturn -ENOMEM;\n\n\tpriv->rx_buf_size = RX_BUF_SIZE +\n\t\t\t    SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\tfor (i = 0; i < RX_DESC_NUM; i++) {\n\t\tpriv->rx_buf[i] = netdev_alloc_frag(priv->rx_buf_size);\n\t\tif (!priv->rx_buf[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void hip04_free_ring(struct net_device *ndev, struct device *d)\n{\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tint i;\n\n\tfor (i = 0; i < RX_DESC_NUM; i++)\n\t\tif (priv->rx_buf[i])\n\t\t\tskb_free_frag(priv->rx_buf[i]);\n\n\tfor (i = 0; i < TX_DESC_NUM; i++)\n\t\tif (priv->tx_skb[i])\n\t\t\tdev_kfree_skb_any(priv->tx_skb[i]);\n\n\tdma_free_coherent(d, TX_DESC_NUM * sizeof(struct tx_desc),\n\t\t\t  priv->tx_desc, priv->tx_desc_dma);\n}\n\nstatic int hip04_mac_probe(struct platform_device *pdev)\n{\n\tstruct device *d = &pdev->dev;\n\tstruct device_node *node = d->of_node;\n\tstruct of_phandle_args arg;\n\tstruct net_device *ndev;\n\tstruct hip04_priv *priv;\n\tint irq;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(struct hip04_priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(ndev);\n\tpriv->dev = d;\n\tpriv->ndev = ndev;\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto init_fail;\n\t}\n\n#if defined(CONFIG_HI13X1_GMAC)\n\tpriv->sysctrl_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->sysctrl_base)) {\n\t\tret = PTR_ERR(priv->sysctrl_base);\n\t\tgoto init_fail;\n\t}\n#endif\n\n\tret = of_parse_phandle_with_fixed_args(node, \"port-handle\", 3, 0, &arg);\n\tif (ret < 0) {\n\t\tdev_warn(d, \"no port-handle\\n\");\n\t\tgoto init_fail;\n\t}\n\n\tpriv->port = arg.args[0];\n\tpriv->chan = arg.args[1] * RX_DESC_NUM;\n\tpriv->group = arg.args[2];\n\n\thrtimer_init(&priv->tx_coalesce_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\n\t \n\tpriv->tx_coalesce_frames = TX_DESC_NUM * 3 / 4;\n\tpriv->tx_coalesce_usecs = 200;\n\tpriv->tx_coalesce_timer.function = tx_done;\n\n\tpriv->map = syscon_node_to_regmap(arg.np);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_warn(d, \"no syscon hisilicon,hip04-ppe\\n\");\n\t\tret = PTR_ERR(priv->map);\n\t\tgoto init_fail;\n\t}\n\n\tret = of_get_phy_mode(node, &priv->phy_mode);\n\tif (ret) {\n\t\tdev_warn(d, \"not find phy-mode\\n\");\n\t\tgoto init_fail;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto init_fail;\n\t}\n\n\tret = devm_request_irq(d, irq, hip04_mac_interrupt,\n\t\t\t       0, pdev->name, ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"devm_request_irq failed\\n\");\n\t\tgoto init_fail;\n\t}\n\n\tpriv->phy_node = of_parse_phandle(node, \"phy-handle\", 0);\n\tif (priv->phy_node) {\n\t\tpriv->phy = of_phy_connect(ndev, priv->phy_node,\n\t\t\t\t\t   &hip04_adjust_link,\n\t\t\t\t\t   0, priv->phy_mode);\n\t\tif (!priv->phy) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto init_fail;\n\t\t}\n\t}\n\n\tINIT_WORK(&priv->tx_timeout_task, hip04_tx_timeout_task);\n\n\tndev->netdev_ops = &hip04_netdev_ops;\n\tndev->ethtool_ops = &hip04_ethtool_ops;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\tndev->priv_flags |= IFF_UNICAST_FLT;\n\tndev->irq = irq;\n\tnetif_napi_add(ndev, &priv->napi, hip04_rx_poll);\n\n\thip04_reset_dreq(priv);\n\thip04_reset_ppe(priv);\n\tif (priv->phy_mode == PHY_INTERFACE_MODE_MII)\n\t\thip04_config_port(ndev, SPEED_100, DUPLEX_FULL);\n\n\thip04_config_fifo(priv);\n\teth_hw_addr_random(ndev);\n\thip04_update_mac_address(ndev);\n\n\tret = hip04_alloc_ring(ndev, d);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"alloc ring fail\\n\");\n\t\tgoto alloc_fail;\n\t}\n\n\tret = register_netdev(ndev);\n\tif (ret)\n\t\tgoto alloc_fail;\n\n\treturn 0;\n\nalloc_fail:\n\thip04_free_ring(ndev, d);\ninit_fail:\n\tof_node_put(priv->phy_node);\n\tfree_netdev(ndev);\n\treturn ret;\n}\n\nstatic int hip04_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct hip04_priv *priv = netdev_priv(ndev);\n\tstruct device *d = &pdev->dev;\n\n\tif (priv->phy)\n\t\tphy_disconnect(priv->phy);\n\n\thip04_free_ring(ndev, d);\n\tunregister_netdev(ndev);\n\tof_node_put(priv->phy_node);\n\tcancel_work_sync(&priv->tx_timeout_task);\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id hip04_mac_match[] = {\n\t{ .compatible = \"hisilicon,hip04-mac\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, hip04_mac_match);\n\nstatic struct platform_driver hip04_mac_driver = {\n\t.probe\t= hip04_mac_probe,\n\t.remove\t= hip04_remove,\n\t.driver\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= hip04_mac_match,\n\t},\n};\nmodule_platform_driver(hip04_mac_driver);\n\nMODULE_DESCRIPTION(\"HISILICON P04 Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}