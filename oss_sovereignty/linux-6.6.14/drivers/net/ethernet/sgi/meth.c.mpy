{
  "module_name": "meth.c",
  "hash_id": "2ce0f283c47c1e5ce60f865c16ebfce146abfc28fe1ed9247e661e4fcd459e50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sgi/meth.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/device.h>  \n#include <linux/netdevice.h>    \n#include <linux/etherdevice.h>  \n#include <linux/ip.h>           \n#include <linux/tcp.h>          \n#include <linux/skbuff.h>\n#include <linux/mii.h>          \n#include <linux/crc32.h>\n\n#include <asm/ip32/mace.h>\n#include <asm/ip32/ip32_ints.h>\n\n#include <asm/io.h>\n\n#include \"meth.h\"\n\n#ifndef MFE_DEBUG\n#define MFE_DEBUG 0\n#endif\n\n#if MFE_DEBUG>=1\n#define DPRINTK(str,args...) printk(KERN_DEBUG \"meth: %s: \" str, __func__ , ## args)\n#define MFE_RX_DEBUG 2\n#else\n#define DPRINTK(str,args...)\n#define MFE_RX_DEBUG 0\n#endif\n\n\nstatic const char *meth_str=\"SGI O2 Fast Ethernet\";\n\n \n#define TX_TIMEOUT (400*HZ/1000)\n\nstatic int timeout = TX_TIMEOUT;\nmodule_param(timeout, int, 0);\n\n \n#define METH_MCF_LIMIT 32\n\n \nstruct meth_private {\n\tstruct platform_device *pdev;\n\n\t \n\tu64 mac_ctrl;\n\n\t \n\tunsigned long dma_ctrl;\n\t \n\tunsigned long phy_addr;\n\ttx_packet *tx_ring;\n\tdma_addr_t tx_ring_dma;\n\tstruct sk_buff *tx_skbs[TX_RING_ENTRIES];\n\tdma_addr_t tx_skb_dmas[TX_RING_ENTRIES];\n\tunsigned long tx_read, tx_write, tx_count;\n\n\trx_packet *rx_ring[RX_RING_ENTRIES];\n\tdma_addr_t rx_ring_dmas[RX_RING_ENTRIES];\n\tstruct sk_buff *rx_skbs[RX_RING_ENTRIES];\n\tunsigned long rx_write;\n\n\t \n\tu64 mcast_filter;\n\n\tspinlock_t meth_lock;\n};\n\nstatic void meth_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic irqreturn_t meth_interrupt(int irq, void *dev_id);\n\n \nchar o2meth_eaddr[8]={0,0,0,0,0,0,0,0};\n\nstatic inline void load_eaddr(struct net_device *dev)\n{\n\tint i;\n\tu64 macaddr;\n\n\tDPRINTK(\"Loading MAC Address: %pM\\n\", dev->dev_addr);\n\tmacaddr = 0;\n\tfor (i = 0; i < 6; i++)\n\t\tmacaddr |= (u64)dev->dev_addr[i] << ((5 - i) * 8);\n\n\tmace->eth.mac_addr = macaddr;\n}\n\n \n#define WAIT_FOR_PHY(___rval)\t\t\t\t\t\\\n\twhile ((___rval = mace->eth.phy_data) & MDIO_BUSY) {\t\\\n\t\tudelay(25);\t\t\t\t\t\\\n\t}\n \nstatic unsigned long mdio_read(struct meth_private *priv, unsigned long phyreg)\n{\n\tunsigned long rval;\n\tWAIT_FOR_PHY(rval);\n\tmace->eth.phy_regs = (priv->phy_addr << 5) | (phyreg & 0x1f);\n\tudelay(25);\n\tmace->eth.phy_trans_go = 1;\n\tudelay(25);\n\tWAIT_FOR_PHY(rval);\n\treturn rval & MDIO_DATA_MASK;\n}\n\nstatic int mdio_probe(struct meth_private *priv)\n{\n\tint i;\n\tunsigned long p2, p3, flags;\n\t \n\tif(priv->phy_addr>=0&&priv->phy_addr<32)\n\t\treturn 0;\n\tspin_lock_irqsave(&priv->meth_lock, flags);\n\tfor (i=0;i<32;++i){\n\t\tpriv->phy_addr=i;\n\t\tp2=mdio_read(priv,2);\n\t\tp3=mdio_read(priv,3);\n#if MFE_DEBUG>=2\n\t\tswitch ((p2<<12)|(p3>>4)){\n\t\tcase PHY_QS6612X:\n\t\t\tDPRINTK(\"PHY is QS6612X\\n\");\n\t\t\tbreak;\n\t\tcase PHY_ICS1889:\n\t\t\tDPRINTK(\"PHY is ICS1889\\n\");\n\t\t\tbreak;\n\t\tcase PHY_ICS1890:\n\t\t\tDPRINTK(\"PHY is ICS1890\\n\");\n\t\t\tbreak;\n\t\tcase PHY_DP83840:\n\t\t\tDPRINTK(\"PHY is DP83840\\n\");\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tif(p2!=0xffff&&p2!=0x0000){\n\t\t\tDPRINTK(\"PHY code: %x\\n\",(p2<<12)|(p3>>4));\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n\tif(priv->phy_addr<32) {\n\t\treturn 0;\n\t}\n\tDPRINTK(\"Oopsie! PHY is not known!\\n\");\n\tpriv->phy_addr=-1;\n\treturn -ENODEV;\n}\n\nstatic void meth_check_link(struct net_device *dev)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long mii_advertising = mdio_read(priv, 4);\n\tunsigned long mii_partner = mdio_read(priv, 5);\n\tunsigned long negotiated = mii_advertising & mii_partner;\n\tunsigned long duplex, speed;\n\n\tif (mii_partner == 0xffff)\n\t\treturn;\n\n\tspeed = (negotiated & 0x0380) ? METH_100MBIT : 0;\n\tduplex = ((negotiated & 0x0100) || (negotiated & 0x01C0) == 0x0040) ?\n\t\t METH_PHY_FDX : 0;\n\n\tif ((priv->mac_ctrl & METH_PHY_FDX) ^ duplex) {\n\t\tDPRINTK(\"Setting %s-duplex\\n\", duplex ? \"full\" : \"half\");\n\t\tif (duplex)\n\t\t\tpriv->mac_ctrl |= METH_PHY_FDX;\n\t\telse\n\t\t\tpriv->mac_ctrl &= ~METH_PHY_FDX;\n\t\tmace->eth.mac_ctrl = priv->mac_ctrl;\n\t}\n\n\tif ((priv->mac_ctrl & METH_100MBIT) ^ speed) {\n\t\tDPRINTK(\"Setting %dMbs mode\\n\", speed ? 100 : 10);\n\t\tif (duplex)\n\t\t\tpriv->mac_ctrl |= METH_100MBIT;\n\t\telse\n\t\t\tpriv->mac_ctrl &= ~METH_100MBIT;\n\t\tmace->eth.mac_ctrl = priv->mac_ctrl;\n\t}\n}\n\n\nstatic int meth_init_tx_ring(struct meth_private *priv)\n{\n\t \n\tpriv->tx_ring = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\tTX_RING_BUFFER_SIZE, &priv->tx_ring_dma, GFP_ATOMIC);\n\tif (!priv->tx_ring)\n\t\treturn -ENOMEM;\n\n\tpriv->tx_count = priv->tx_read = priv->tx_write = 0;\n\tmace->eth.tx_ring_base = priv->tx_ring_dma;\n\t \n\tmemset(priv->tx_skbs, 0, sizeof(priv->tx_skbs));\n\tmemset(priv->tx_skb_dmas, 0, sizeof(priv->tx_skb_dmas));\n\treturn 0;\n}\n\nstatic int meth_init_rx_ring(struct meth_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_RING_ENTRIES; i++) {\n\t\tpriv->rx_skbs[i] = alloc_skb(METH_RX_BUFF_SIZE, 0);\n\t\t \n\t\tskb_reserve(priv->rx_skbs[i],METH_RX_HEAD);\n\t\tpriv->rx_ring[i]=(rx_packet*)(priv->rx_skbs[i]->head);\n\t\t \n\t\tpriv->rx_ring_dmas[i] =\n\t\t\tdma_map_single(&priv->pdev->dev, priv->rx_ring[i],\n\t\t\t\t       METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\n\t\tmace->eth.rx_fifo = priv->rx_ring_dmas[i];\n\t}\n        priv->rx_write = 0;\n\treturn 0;\n}\nstatic void meth_free_tx_ring(struct meth_private *priv)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < TX_RING_ENTRIES; i++) {\n\t\tdev_kfree_skb(priv->tx_skbs[i]);\n\t\tpriv->tx_skbs[i] = NULL;\n\t}\n\tdma_free_coherent(&priv->pdev->dev, TX_RING_BUFFER_SIZE, priv->tx_ring,\n\t                  priv->tx_ring_dma);\n}\n\n \nstatic void meth_free_rx_ring(struct meth_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_RING_ENTRIES; i++) {\n\t\tdma_unmap_single(&priv->pdev->dev, priv->rx_ring_dmas[i],\n\t\t\t\t METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\n\t\tpriv->rx_ring[i] = 0;\n\t\tpriv->rx_ring_dmas[i] = 0;\n\t\tkfree_skb(priv->rx_skbs[i]);\n\t}\n}\n\nint meth_reset(struct net_device *dev)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\n\t \n\tmace->eth.mac_ctrl = SGI_MAC_RESET;\n\tudelay(1);\n\tmace->eth.mac_ctrl = 0;\n\tudelay(25);\n\n\t \n\tload_eaddr(dev);\n\t \n\n\t \n\tif (mdio_probe(priv) < 0) {\n\t\tDPRINTK(\"Unable to find PHY\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpriv->mac_ctrl = METH_ACCEPT_MCAST | METH_DEFAULT_IPG;\n\tif (dev->flags & IFF_PROMISC)\n\t\tpriv->mac_ctrl |= METH_PROMISC;\n\tmace->eth.mac_ctrl = priv->mac_ctrl;\n\n\t \n\tmeth_check_link(dev);\n\n\t \n\tpriv->dma_ctrl = (4 << METH_RX_OFFSET_SHIFT) |\n\t\t\t (RX_RING_ENTRIES << METH_RX_DEPTH_SHIFT);\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\n\treturn 0;\n}\n\n \n\n \nstatic int meth_open(struct net_device *dev)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\tint ret;\n\n\tpriv->phy_addr = -1;     \n\n\t \n\tret = meth_reset(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = meth_init_tx_ring(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = meth_init_rx_ring(priv);\n\tif (ret < 0)\n\t\tgoto out_free_tx_ring;\n\n\tret = request_irq(dev->irq, meth_interrupt, 0, meth_str, dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: Can't get irq %d\\n\", dev->name, dev->irq);\n\t\tgoto out_free_rx_ring;\n\t}\n\n\t \n\tpriv->dma_ctrl |= METH_DMA_TX_EN |  \n\t\t\t  METH_DMA_RX_EN | METH_DMA_RX_INT_EN;\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\n\tDPRINTK(\"About to start queue\\n\");\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nout_free_rx_ring:\n\tmeth_free_rx_ring(priv);\nout_free_tx_ring:\n\tmeth_free_tx_ring(priv);\n\n\treturn ret;\n}\n\nstatic int meth_release(struct net_device *dev)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\n\tDPRINTK(\"Stopping queue\\n\");\n\tnetif_stop_queue(dev);  \n\t \n\tpriv->dma_ctrl &= ~(METH_DMA_TX_EN | METH_DMA_TX_INT_EN |\n\t\t\t    METH_DMA_RX_EN | METH_DMA_RX_INT_EN);\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\tfree_irq(dev->irq, dev);\n\tmeth_free_tx_ring(priv);\n\tmeth_free_rx_ring(priv);\n\n\treturn 0;\n}\n\n \nstatic void meth_rx(struct net_device* dev, unsigned long int_status)\n{\n\tstruct sk_buff *skb;\n\tunsigned long status, flags;\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long fifo_rptr = (int_status & METH_INT_RX_RPTR_MASK) >> 8;\n\n\tspin_lock_irqsave(&priv->meth_lock, flags);\n\tpriv->dma_ctrl &= ~METH_DMA_RX_INT_EN;\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n\n\tif (int_status & METH_INT_RX_UNDERFLOW) {\n\t\tfifo_rptr = (fifo_rptr - 1) & 0x0f;\n\t}\n\twhile (priv->rx_write != fifo_rptr) {\n\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t priv->rx_ring_dmas[priv->rx_write],\n\t\t\t\t METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\n\t\tstatus = priv->rx_ring[priv->rx_write]->status.raw;\n#if MFE_DEBUG\n\t\tif (!(status & METH_RX_ST_VALID)) {\n\t\t\tDPRINTK(\"Not received? status=%016lx\\n\",status);\n\t\t}\n#endif\n\t\tif ((!(status & METH_RX_STATUS_ERRORS)) && (status & METH_RX_ST_VALID)) {\n\t\t\tint len = (status & 0xffff) - 4;  \n\t\t\t \n\t\t\tif (len < 60 || len > 1518) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: bogus packet size: %ld, status=%#2Lx.\\n\",\n\t\t\t\t       dev->name, priv->rx_write,\n\t\t\t\t       priv->rx_ring[priv->rx_write]->status.raw);\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tskb = priv->rx_skbs[priv->rx_write];\n\t\t\t} else {\n\t\t\t\tskb = alloc_skb(METH_RX_BUFF_SIZE, GFP_ATOMIC);\n\t\t\t\tif (!skb) {\n\t\t\t\t\t \n\t\t\t\t\tDPRINTK(\"No mem: dropping packet\\n\");\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\tskb = priv->rx_skbs[priv->rx_write];\n\t\t\t\t} else {\n\t\t\t\t\tstruct sk_buff *skb_c = priv->rx_skbs[priv->rx_write];\n\t\t\t\t\t \n\t\t\t\t\tskb_reserve(skb, METH_RX_HEAD);\n\t\t\t\t\t \n\t\t\t\t\tskb_put(skb_c, len);\n\t\t\t\t\tpriv->rx_skbs[priv->rx_write] = skb;\n\t\t\t\t\tskb_c->protocol = eth_type_trans(skb_c, dev);\n\t\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\t\tdev->stats.rx_bytes += len;\n\t\t\t\t\tnetif_rx(skb_c);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tskb=priv->rx_skbs[priv->rx_write];\n#if MFE_DEBUG>0\n\t\t\tprintk(KERN_WARNING \"meth: RX error: status=0x%016lx\\n\",status);\n\t\t\tif(status&METH_RX_ST_RCV_CODE_VIOLATION)\n\t\t\t\tprintk(KERN_WARNING \"Receive Code Violation\\n\");\n\t\t\tif(status&METH_RX_ST_CRC_ERR)\n\t\t\t\tprintk(KERN_WARNING \"CRC error\\n\");\n\t\t\tif(status&METH_RX_ST_INV_PREAMBLE_CTX)\n\t\t\t\tprintk(KERN_WARNING \"Invalid Preamble Context\\n\");\n\t\t\tif(status&METH_RX_ST_LONG_EVT_SEEN)\n\t\t\t\tprintk(KERN_WARNING \"Long Event Seen...\\n\");\n\t\t\tif(status&METH_RX_ST_BAD_PACKET)\n\t\t\t\tprintk(KERN_WARNING \"Bad Packet\\n\");\n\t\t\tif(status&METH_RX_ST_CARRIER_EVT_SEEN)\n\t\t\t\tprintk(KERN_WARNING \"Carrier Event Seen\\n\");\n#endif\n\t\t}\n\t\tpriv->rx_ring[priv->rx_write] = (rx_packet*)skb->head;\n\t\tpriv->rx_ring[priv->rx_write]->status.raw = 0;\n\t\tpriv->rx_ring_dmas[priv->rx_write] =\n\t\t\tdma_map_single(&priv->pdev->dev,\n\t\t\t\t       priv->rx_ring[priv->rx_write],\n\t\t\t\t       METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\n\t\tmace->eth.rx_fifo = priv->rx_ring_dmas[priv->rx_write];\n\t\tADVANCE_RX_PTR(priv->rx_write);\n\t}\n\tspin_lock_irqsave(&priv->meth_lock, flags);\n\t \n\tpriv->dma_ctrl |= METH_DMA_RX_INT_EN | METH_DMA_RX_EN;\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\tmace->eth.int_stat = METH_INT_RX_THRESHOLD;\n\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n}\n\nstatic int meth_tx_full(struct net_device *dev)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\n\treturn priv->tx_count >= TX_RING_ENTRIES - 1;\n}\n\nstatic void meth_tx_cleanup(struct net_device* dev, unsigned long int_status)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long status, flags;\n\tstruct sk_buff *skb;\n\tunsigned long rptr = (int_status&TX_INFO_RPTR) >> 16;\n\n\tspin_lock_irqsave(&priv->meth_lock, flags);\n\n\t \n\tpriv->dma_ctrl &= ~(METH_DMA_TX_INT_EN);\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\n\twhile (priv->tx_read != rptr) {\n\t\tskb = priv->tx_skbs[priv->tx_read];\n\t\tstatus = priv->tx_ring[priv->tx_read].header.raw;\n#if MFE_DEBUG>=1\n\t\tif (priv->tx_read == priv->tx_write)\n\t\t\tDPRINTK(\"Auchi! tx_read=%d,tx_write=%d,rptr=%d?\\n\", priv->tx_read, priv->tx_write,rptr);\n#endif\n\t\tif (status & METH_TX_ST_DONE) {\n\t\t\tif (status & METH_TX_ST_SUCCESS){\n\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\t} else {\n\t\t\t\tdev->stats.tx_errors++;\n#if MFE_DEBUG>=1\n\t\t\t\tDPRINTK(\"TX error: status=%016lx <\",status);\n\t\t\t\tif(status & METH_TX_ST_SUCCESS)\n\t\t\t\t\tprintk(\" SUCCESS\");\n\t\t\t\tif(status & METH_TX_ST_TOOLONG)\n\t\t\t\t\tprintk(\" TOOLONG\");\n\t\t\t\tif(status & METH_TX_ST_UNDERRUN)\n\t\t\t\t\tprintk(\" UNDERRUN\");\n\t\t\t\tif(status & METH_TX_ST_EXCCOLL)\n\t\t\t\t\tprintk(\" EXCCOLL\");\n\t\t\t\tif(status & METH_TX_ST_DEFER)\n\t\t\t\t\tprintk(\" DEFER\");\n\t\t\t\tif(status & METH_TX_ST_LATECOLL)\n\t\t\t\t\tprintk(\" LATECOLL\");\n\t\t\t\tprintk(\" >\\n\");\n#endif\n\t\t\t}\n\t\t} else {\n\t\t\tDPRINTK(\"RPTR points us here, but packet not done?\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tdev_consume_skb_irq(skb);\n\t\tpriv->tx_skbs[priv->tx_read] = NULL;\n\t\tpriv->tx_ring[priv->tx_read].header.raw = 0;\n\t\tpriv->tx_read = (priv->tx_read+1)&(TX_RING_ENTRIES-1);\n\t\tpriv->tx_count--;\n\t}\n\n\t \n\tif (netif_queue_stopped(dev) && !meth_tx_full(dev)) {\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tmace->eth.int_stat = METH_INT_TX_EMPTY | METH_INT_TX_PKT;\n\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n}\n\nstatic void meth_error(struct net_device* dev, unsigned status)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tprintk(KERN_WARNING \"meth: error status: 0x%08x\\n\",status);\n\t \n\tif (status & (METH_INT_TX_LINK_FAIL))\n\t\tprintk(KERN_WARNING \"meth: link failure\\n\");\n\t \n\tif (status & (METH_INT_MEM_ERROR))\n\t\tprintk(KERN_WARNING \"meth: memory error\\n\");\n\tif (status & (METH_INT_TX_ABORT))\n\t\tprintk(KERN_WARNING \"meth: aborted\\n\");\n\tif (status & (METH_INT_RX_OVERFLOW))\n\t\tprintk(KERN_WARNING \"meth: Rx overflow\\n\");\n\tif (status & (METH_INT_RX_UNDERFLOW)) {\n\t\tprintk(KERN_WARNING \"meth: Rx underflow\\n\");\n\t\tspin_lock_irqsave(&priv->meth_lock, flags);\n\t\tmace->eth.int_stat = METH_INT_RX_UNDERFLOW;\n\t\t \n\t\tpriv->dma_ctrl &= ~METH_DMA_RX_EN;\n\t\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\t\tDPRINTK(\"Disabled meth Rx DMA temporarily\\n\");\n\t\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n\t}\n\tmace->eth.int_stat = METH_INT_ERROR;\n}\n\n \nstatic irqreturn_t meth_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long status;\n\n\tstatus = mace->eth.int_stat;\n\twhile (status & 0xff) {\n\t\t \n\t\tif (status & METH_INT_ERROR) {\n\t\t\tmeth_error(dev, status);\n\t\t}\n\t\tif (status & (METH_INT_TX_EMPTY | METH_INT_TX_PKT)) {\n\t\t\t \n\t\t\tmeth_tx_cleanup(dev, status);\n\t\t}\n\t\tif (status & METH_INT_RX_THRESHOLD) {\n\t\t\tif (!(priv->dma_ctrl & METH_DMA_RX_INT_EN))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tmeth_rx(dev, status);\n\t\t}\n\t\tstatus = mace->eth.int_stat;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void meth_tx_short_prepare(struct meth_private *priv,\n\t\t\t\t  struct sk_buff *skb)\n{\n\ttx_packet *desc = &priv->tx_ring[priv->tx_write];\n\tint len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;\n\n\tdesc->header.raw = METH_TX_CMD_INT_EN | (len-1) | ((128-len) << 16);\n\t \n\tskb_copy_from_linear_data(skb, desc->data.dt + (120 - len), skb->len);\n\tif (skb->len < len)\n\t\tmemset(desc->data.dt + 120 - len + skb->len, 0, len-skb->len);\n}\n#define TX_CATBUF1 BIT(25)\nstatic void meth_tx_1page_prepare(struct meth_private *priv,\n\t\t\t\t  struct sk_buff *skb)\n{\n\ttx_packet *desc = &priv->tx_ring[priv->tx_write];\n\tvoid *buffer_data = (void *)(((unsigned long)skb->data + 7) & ~7);\n\tint unaligned_len = (int)((unsigned long)buffer_data - (unsigned long)skb->data);\n\tint buffer_len = skb->len - unaligned_len;\n\tdma_addr_t catbuf;\n\n\tdesc->header.raw = METH_TX_CMD_INT_EN | TX_CATBUF1 | (skb->len - 1);\n\n\t \n\tif (unaligned_len) {\n\t\tskb_copy_from_linear_data(skb, desc->data.dt + (120 - unaligned_len),\n\t\t\t      unaligned_len);\n\t\tdesc->header.raw |= (128 - unaligned_len) << 16;\n\t}\n\n\t \n\tcatbuf = dma_map_single(&priv->pdev->dev, buffer_data, buffer_len,\n\t\t\t\tDMA_TO_DEVICE);\n\tdesc->data.cat_buf[0].form.start_addr = catbuf >> 3;\n\tdesc->data.cat_buf[0].form.len = buffer_len - 1;\n}\n#define TX_CATBUF2 BIT(26)\nstatic void meth_tx_2page_prepare(struct meth_private *priv,\n\t\t\t\t  struct sk_buff *skb)\n{\n\ttx_packet *desc = &priv->tx_ring[priv->tx_write];\n\tvoid *buffer1_data = (void *)(((unsigned long)skb->data + 7) & ~7);\n\tvoid *buffer2_data = (void *)PAGE_ALIGN((unsigned long)skb->data);\n\tint unaligned_len = (int)((unsigned long)buffer1_data - (unsigned long)skb->data);\n\tint buffer1_len = (int)((unsigned long)buffer2_data - (unsigned long)buffer1_data);\n\tint buffer2_len = skb->len - buffer1_len - unaligned_len;\n\tdma_addr_t catbuf1, catbuf2;\n\n\tdesc->header.raw = METH_TX_CMD_INT_EN | TX_CATBUF1 | TX_CATBUF2| (skb->len - 1);\n\t \n\tif (unaligned_len){\n\t\tskb_copy_from_linear_data(skb, desc->data.dt + (120 - unaligned_len),\n\t\t\t      unaligned_len);\n\t\tdesc->header.raw |= (128 - unaligned_len) << 16;\n\t}\n\n\t \n\tcatbuf1 = dma_map_single(&priv->pdev->dev, buffer1_data, buffer1_len,\n\t\t\t\t DMA_TO_DEVICE);\n\tdesc->data.cat_buf[0].form.start_addr = catbuf1 >> 3;\n\tdesc->data.cat_buf[0].form.len = buffer1_len - 1;\n\t \n\tcatbuf2 = dma_map_single(&priv->pdev->dev, buffer2_data, buffer2_len,\n\t\t\t\t DMA_TO_DEVICE);\n\tdesc->data.cat_buf[1].form.start_addr = catbuf2 >> 3;\n\tdesc->data.cat_buf[1].form.len = buffer2_len - 1;\n}\n\nstatic void meth_add_to_tx_ring(struct meth_private *priv, struct sk_buff *skb)\n{\n\t \n\tpriv->tx_skbs[priv->tx_write] = skb;\n\tif (skb->len <= 120) {\n\t\t \n\t\tmeth_tx_short_prepare(priv, skb);\n\t} else if (PAGE_ALIGN((unsigned long)skb->data) !=\n\t\t   PAGE_ALIGN((unsigned long)skb->data + skb->len - 1)) {\n\t\t \n\t\tmeth_tx_2page_prepare(priv, skb);\n\t} else {\n\t\t \n\t\tmeth_tx_1page_prepare(priv, skb);\n\t}\n\tpriv->tx_write = (priv->tx_write + 1) & (TX_RING_ENTRIES - 1);\n\tmace->eth.tx_info = priv->tx_write;\n\tpriv->tx_count++;\n}\n\n \nstatic netdev_tx_t meth_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->meth_lock, flags);\n\t \n\tpriv->dma_ctrl &= ~(METH_DMA_TX_INT_EN);\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\n\tmeth_add_to_tx_ring(priv, skb);\n\tnetif_trans_update(dev);  \n\n\t \n\tif (meth_tx_full(dev)) {\n\t        printk(KERN_DEBUG \"TX full: stopping\\n\");\n\t\tnetif_stop_queue(dev);\n\t}\n\n\t \n\tpriv->dma_ctrl |= METH_DMA_TX_INT_EN;\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\n\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void meth_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tprintk(KERN_WARNING \"%s: transmit timed out\\n\", dev->name);\n\n\t \n\tspin_lock_irqsave(&priv->meth_lock,flags);\n\n\t \n\tmeth_reset(dev);\n\n\tdev->stats.tx_errors++;\n\n\t \n\tmeth_free_tx_ring(priv);\n\tmeth_free_rx_ring(priv);\n\tmeth_init_tx_ring(priv);\n\tmeth_init_rx_ring(priv);\n\n\t \n\tpriv->dma_ctrl |= METH_DMA_TX_EN | METH_DMA_RX_EN | METH_DMA_RX_INT_EN;\n\tmace->eth.dma_ctrl = priv->dma_ctrl;\n\n\t \n\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\n \nstatic int meth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\t \n\tswitch(cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void meth_set_rx_mode(struct net_device *dev)\n{\n\tstruct meth_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnetif_stop_queue(dev);\n\tspin_lock_irqsave(&priv->meth_lock, flags);\n\tpriv->mac_ctrl &= ~METH_PROMISC;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tpriv->mac_ctrl |= METH_PROMISC;\n\t\tpriv->mcast_filter = 0xffffffffffffffffUL;\n\t} else if ((netdev_mc_count(dev) > METH_MCF_LIMIT) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\tpriv->mac_ctrl |= METH_ACCEPT_AMCAST;\n\t\tpriv->mcast_filter = 0xffffffffffffffffUL;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tpriv->mac_ctrl |= METH_ACCEPT_MCAST;\n\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tset_bit((ether_crc(ETH_ALEN, ha->addr) >> 26),\n\t\t\t        (volatile unsigned long *)&priv->mcast_filter);\n\t}\n\n\t \n\tmace->eth.mac_ctrl = priv->mac_ctrl;\n\tmace->eth.mcast_filter = priv->mcast_filter;\n\n\t \n\tspin_unlock_irqrestore(&priv->meth_lock, flags);\n\tnetif_wake_queue(dev);\n}\n\nstatic const struct net_device_ops meth_netdev_ops = {\n\t.ndo_open\t\t= meth_open,\n\t.ndo_stop\t\t= meth_release,\n\t.ndo_start_xmit\t\t= meth_tx,\n\t.ndo_eth_ioctl\t\t= meth_ioctl,\n\t.ndo_tx_timeout\t\t= meth_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_set_rx_mode    \t= meth_set_rx_mode,\n};\n\n \nstatic int meth_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct meth_private *priv;\n\tint err;\n\n\tdev = alloc_etherdev(sizeof(struct meth_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->netdev_ops\t\t= &meth_netdev_ops;\n\tdev->watchdog_timeo\t= timeout;\n\tdev->irq\t\t= MACE_ETHERNET_IRQ;\n\tdev->base_addr\t\t= (unsigned long)&mace->eth;\n\teth_hw_addr_set(dev, o2meth_eaddr);\n\n\tpriv = netdev_priv(dev);\n\tpriv->pdev = pdev;\n\tspin_lock_init(&priv->meth_lock);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\n\tprintk(KERN_INFO \"%s: SGI MACE Ethernet rev. %d\\n\",\n\t       dev->name, (unsigned int)(mace->eth.mac_ctrl >> 29));\n\treturn 0;\n}\n\nstatic int meth_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver meth_driver = {\n\t.probe\t= meth_probe,\n\t.remove\t= meth_remove,\n\t.driver = {\n\t\t.name\t= \"meth\",\n\t}\n};\n\nmodule_platform_driver(meth_driver);\n\nMODULE_AUTHOR(\"Ilya Volynets <ilya@theIlya.com>\");\nMODULE_DESCRIPTION(\"SGI O2 Builtin Fast Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:meth\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}