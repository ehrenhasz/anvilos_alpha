{
  "module_name": "natsemi.c",
  "hash_id": "b14bb731b436223ea1c684ed608da948b1734d559a1b6770cb935eedd60fbd14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/natsemi/natsemi.c",
  "human_readable_source": " \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/delay.h>\n#include <linux/rtnetlink.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <linux/prefetch.h>\n#include <asm/processor.h>\t \n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n#define DRV_NAME\t\"natsemi\"\n#define DRV_VERSION\t\"2.1\"\n#define DRV_RELDATE\t\"Sept 11, 2006\"\n\n#define RX_OFFSET\t2\n\n \n\n \n\n#define NATSEMI_DEF_MSG\t\t(NETIF_MSG_DRV\t\t| \\\n\t\t\t\t NETIF_MSG_LINK\t\t| \\\n\t\t\t\t NETIF_MSG_WOL\t\t| \\\n\t\t\t\t NETIF_MSG_RX_ERR\t| \\\n\t\t\t\t NETIF_MSG_TX_ERR)\nstatic int debug = -1;\n\nstatic int mtu;\n\n \nstatic const int multicast_filter_limit = 100;\n\n \nstatic int rx_copybreak;\n\nstatic int dspcfg_workaround = 1;\n\n \n#define MAX_UNITS 8\t\t \nstatic int options[MAX_UNITS];\nstatic int full_duplex[MAX_UNITS];\n\n \n\n \n#define TX_RING_SIZE\t16\n#define TX_QUEUE_LEN\t10  \n#define RX_RING_SIZE\t32\n\n \n \n#define TX_TIMEOUT  (2*HZ)\n\n#define NATSEMI_HW_TIMEOUT\t400\n#define NATSEMI_TIMER_FREQ\t5*HZ\n#define NATSEMI_PG0_NREGS\t64\n#define NATSEMI_RFDR_NREGS\t8\n#define NATSEMI_PG1_NREGS\t4\n#define NATSEMI_NREGS\t\t(NATSEMI_PG0_NREGS + NATSEMI_RFDR_NREGS + \\\n\t\t\t\t NATSEMI_PG1_NREGS)\n#define NATSEMI_REGS_VER\t1  \n#define NATSEMI_REGS_SIZE\t(NATSEMI_NREGS * sizeof(u32))\n\n \n#define NATSEMI_HEADERS\t\t22\t \n#define NATSEMI_PADDING\t\t16\t \n#define NATSEMI_LONGPKT\t\t1518\t \n#define NATSEMI_RX_LIMIT\t2046\t \n\n \nstatic const char version[] =\n  KERN_INFO DRV_NAME \" dp8381x driver, version \"\n      DRV_VERSION \", \" DRV_RELDATE \"\\n\"\n  \"  originally by Donald Becker <becker@scyld.com>\\n\"\n  \"  2.4.x kernel port by Jeff Garzik, Tjeerd Mulder\\n\";\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"National Semiconductor DP8381x series PCI Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(mtu, int, 0);\nmodule_param(debug, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param(dspcfg_workaround, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nMODULE_PARM_DESC(mtu, \"DP8381x MTU (all boards)\");\nMODULE_PARM_DESC(debug, \"DP8381x default debug level\");\nMODULE_PARM_DESC(rx_copybreak,\n\t\"DP8381x copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(dspcfg_workaround, \"DP8381x: control DspCfg workaround\");\nMODULE_PARM_DESC(options,\n\t\"DP8381x: Bits 0-3: media type, bit 17: full duplex\");\nMODULE_PARM_DESC(full_duplex, \"DP8381x full duplex setting(s) (1)\");\n\n \n\n\n\n \n#define PHYID_AM79C874\t0x0022561b\n\nenum {\n\tMII_MCTRL\t= 0x15,\t\t \n\tMII_FX_SEL\t= 0x0001,\t \n\tMII_EN_SCRM\t= 0x0004,\t \n};\n\nenum {\n\tNATSEMI_FLAG_IGNORE_PHY\t\t= 0x1,\n};\n\n \nstatic struct {\n\tconst char *name;\n\tunsigned long flags;\n\tunsigned int eeprom_size;\n} natsemi_pci_info[] = {\n\t{ \"Aculab E1/T1 PMXc cPCI carrier card\", NATSEMI_FLAG_IGNORE_PHY, 128 },\n\t{ \"NatSemi DP8381[56]\", 0, 24 },\n};\n\nstatic const struct pci_device_id natsemi_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_NS, 0x0020, 0x12d9,     0x000c,     0, 0, 0 },\n\t{ PCI_VENDOR_ID_NS, 0x0020, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },\n\t{ }\t \n};\nMODULE_DEVICE_TABLE(pci, natsemi_pci_tbl);\n\n \nenum register_offsets {\n\tChipCmd\t\t\t= 0x00,\n\tChipConfig\t\t= 0x04,\n\tEECtrl\t\t\t= 0x08,\n\tPCIBusCfg\t\t= 0x0C,\n\tIntrStatus\t\t= 0x10,\n\tIntrMask\t\t= 0x14,\n\tIntrEnable\t\t= 0x18,\n\tIntrHoldoff\t\t= 0x1C,  \n\tTxRingPtr\t\t= 0x20,\n\tTxConfig\t\t= 0x24,\n\tRxRingPtr\t\t= 0x30,\n\tRxConfig\t\t= 0x34,\n\tClkRun\t\t\t= 0x3C,\n\tWOLCmd\t\t\t= 0x40,\n\tPauseCmd\t\t= 0x44,\n\tRxFilterAddr\t\t= 0x48,\n\tRxFilterData\t\t= 0x4C,\n\tBootRomAddr\t\t= 0x50,\n\tBootRomData\t\t= 0x54,\n\tSiliconRev\t\t= 0x58,\n\tStatsCtrl\t\t= 0x5C,\n\tStatsData\t\t= 0x60,\n\tRxPktErrs\t\t= 0x60,\n\tRxMissed\t\t= 0x68,\n\tRxCRCErrs\t\t= 0x64,\n\tBasicControl\t\t= 0x80,\n\tBasicStatus\t\t= 0x84,\n\tAnegAdv\t\t\t= 0x90,\n\tAnegPeer\t\t= 0x94,\n\tPhyStatus\t\t= 0xC0,\n\tMIntrCtrl\t\t= 0xC4,\n\tMIntrStatus\t\t= 0xC8,\n\tPhyCtrl\t\t\t= 0xE4,\n\n\t \n\tPGSEL\t\t\t= 0xCC,\n\tPMDCSR\t\t\t= 0xE4,\n\tTSTDAT\t\t\t= 0xFC,\n\tDSPCFG\t\t\t= 0xF4,\n\tSDCFG\t\t\t= 0xF8\n};\n \n#define PMDCSR_VAL\t0x189c\t \n#define TSTDAT_VAL\t0x0\n#define DSPCFG_VAL\t0x5040\n#define SDCFG_VAL\t0x008c\t \n#define DSPCFG_LOCK\t0x20\t \n#define DSPCFG_COEF\t0x1000\t \n#define TSTDAT_FIXED\t0xe8\t \n\n \nenum pci_register_offsets {\n\tPCIPM\t\t\t= 0x44,\n};\n\nenum ChipCmd_bits {\n\tChipReset\t\t= 0x100,\n\tRxReset\t\t\t= 0x20,\n\tTxReset\t\t\t= 0x10,\n\tRxOff\t\t\t= 0x08,\n\tRxOn\t\t\t= 0x04,\n\tTxOff\t\t\t= 0x02,\n\tTxOn\t\t\t= 0x01,\n};\n\nenum ChipConfig_bits {\n\tCfgPhyDis\t\t= 0x200,\n\tCfgPhyRst\t\t= 0x400,\n\tCfgExtPhy\t\t= 0x1000,\n\tCfgAnegEnable\t\t= 0x2000,\n\tCfgAneg100\t\t= 0x4000,\n\tCfgAnegFull\t\t= 0x8000,\n\tCfgAnegDone\t\t= 0x8000000,\n\tCfgFullDuplex\t\t= 0x20000000,\n\tCfgSpeed100\t\t= 0x40000000,\n\tCfgLink\t\t\t= 0x80000000,\n};\n\nenum EECtrl_bits {\n\tEE_ShiftClk\t\t= 0x04,\n\tEE_DataIn\t\t= 0x01,\n\tEE_ChipSelect\t\t= 0x08,\n\tEE_DataOut\t\t= 0x02,\n\tMII_Data \t\t= 0x10,\n\tMII_Write\t\t= 0x20,\n\tMII_ShiftClk\t\t= 0x40,\n};\n\nenum PCIBusCfg_bits {\n\tEepromReload\t\t= 0x4,\n};\n\n \nenum IntrStatus_bits {\n\tIntrRxDone\t\t= 0x0001,\n\tIntrRxIntr\t\t= 0x0002,\n\tIntrRxErr\t\t= 0x0004,\n\tIntrRxEarly\t\t= 0x0008,\n\tIntrRxIdle\t\t= 0x0010,\n\tIntrRxOverrun\t\t= 0x0020,\n\tIntrTxDone\t\t= 0x0040,\n\tIntrTxIntr\t\t= 0x0080,\n\tIntrTxErr\t\t= 0x0100,\n\tIntrTxIdle\t\t= 0x0200,\n\tIntrTxUnderrun\t\t= 0x0400,\n\tStatsMax\t\t= 0x0800,\n\tSWInt\t\t\t= 0x1000,\n\tWOLPkt\t\t\t= 0x2000,\n\tLinkChange\t\t= 0x4000,\n\tIntrHighBits\t\t= 0x8000,\n\tRxStatusFIFOOver\t= 0x10000,\n\tIntrPCIErr\t\t= 0xf00000,\n\tRxResetDone\t\t= 0x1000000,\n\tTxResetDone\t\t= 0x2000000,\n\tIntrAbnormalSummary\t= 0xCD20,\n};\n\n \n#define DEFAULT_INTR 0x00f1cd65\n\nenum TxConfig_bits {\n\tTxDrthMask\t\t= 0x3f,\n\tTxFlthMask\t\t= 0x3f00,\n\tTxMxdmaMask\t\t= 0x700000,\n\tTxMxdma_512\t\t= 0x0,\n\tTxMxdma_4\t\t= 0x100000,\n\tTxMxdma_8\t\t= 0x200000,\n\tTxMxdma_16\t\t= 0x300000,\n\tTxMxdma_32\t\t= 0x400000,\n\tTxMxdma_64\t\t= 0x500000,\n\tTxMxdma_128\t\t= 0x600000,\n\tTxMxdma_256\t\t= 0x700000,\n\tTxCollRetry\t\t= 0x800000,\n\tTxAutoPad\t\t= 0x10000000,\n\tTxMacLoop\t\t= 0x20000000,\n\tTxHeartIgn\t\t= 0x40000000,\n\tTxCarrierIgn\t\t= 0x80000000\n};\n\n \n#define TX_FLTH_VAL\t\t((512/32) << 8)\n#define TX_DRTH_VAL_START\t(64/32)\n#define TX_DRTH_VAL_INC\t\t2\n#define TX_DRTH_VAL_LIMIT\t(1472/32)\n\nenum RxConfig_bits {\n\tRxDrthMask\t\t= 0x3e,\n\tRxMxdmaMask\t\t= 0x700000,\n\tRxMxdma_512\t\t= 0x0,\n\tRxMxdma_4\t\t= 0x100000,\n\tRxMxdma_8\t\t= 0x200000,\n\tRxMxdma_16\t\t= 0x300000,\n\tRxMxdma_32\t\t= 0x400000,\n\tRxMxdma_64\t\t= 0x500000,\n\tRxMxdma_128\t\t= 0x600000,\n\tRxMxdma_256\t\t= 0x700000,\n\tRxAcceptLong\t\t= 0x8000000,\n\tRxAcceptTx\t\t= 0x10000000,\n\tRxAcceptRunt\t\t= 0x40000000,\n\tRxAcceptErr\t\t= 0x80000000\n};\n#define RX_DRTH_VAL\t\t(128/8)\n\nenum ClkRun_bits {\n\tPMEEnable\t\t= 0x100,\n\tPMEStatus\t\t= 0x8000,\n};\n\nenum WolCmd_bits {\n\tWakePhy\t\t\t= 0x1,\n\tWakeUnicast\t\t= 0x2,\n\tWakeMulticast\t\t= 0x4,\n\tWakeBroadcast\t\t= 0x8,\n\tWakeArp\t\t\t= 0x10,\n\tWakePMatch0\t\t= 0x20,\n\tWakePMatch1\t\t= 0x40,\n\tWakePMatch2\t\t= 0x80,\n\tWakePMatch3\t\t= 0x100,\n\tWakeMagic\t\t= 0x200,\n\tWakeMagicSecure\t\t= 0x400,\n\tSecureHack\t\t= 0x100000,\n\tWokePhy\t\t\t= 0x400000,\n\tWokeUnicast\t\t= 0x800000,\n\tWokeMulticast\t\t= 0x1000000,\n\tWokeBroadcast\t\t= 0x2000000,\n\tWokeArp\t\t\t= 0x4000000,\n\tWokePMatch0\t\t= 0x8000000,\n\tWokePMatch1\t\t= 0x10000000,\n\tWokePMatch2\t\t= 0x20000000,\n\tWokePMatch3\t\t= 0x40000000,\n\tWokeMagic\t\t= 0x80000000,\n\tWakeOptsSummary\t\t= 0x7ff\n};\n\nenum RxFilterAddr_bits {\n\tRFCRAddressMask\t\t= 0x3ff,\n\tAcceptMulticast\t\t= 0x00200000,\n\tAcceptMyPhys\t\t= 0x08000000,\n\tAcceptAllPhys\t\t= 0x10000000,\n\tAcceptAllMulticast\t= 0x20000000,\n\tAcceptBroadcast\t\t= 0x40000000,\n\tRxFilterEnable\t\t= 0x80000000\n};\n\nenum StatsCtrl_bits {\n\tStatsWarn\t\t= 0x1,\n\tStatsFreeze\t\t= 0x2,\n\tStatsClear\t\t= 0x4,\n\tStatsStrobe\t\t= 0x8,\n};\n\nenum MIntrCtrl_bits {\n\tMICRIntEn\t\t= 0x2,\n};\n\nenum PhyCtrl_bits {\n\tPhyAddrMask\t\t= 0x1f,\n};\n\n#define PHY_ADDR_NONE\t\t32\n#define PHY_ADDR_INTERNAL\t1\n\n \n#define SRR_DP83815_C\t0x0302\n#define SRR_DP83815_D\t0x0403\n#define SRR_DP83816_A4\t0x0504\n#define SRR_DP83816_A5\t0x0505\n\n \n \nstruct netdev_desc {\n\t__le32 next_desc;\n\t__le32 cmd_status;\n\t__le32 addr;\n\t__le32 software_use;\n};\n\n \nenum desc_status_bits {\n\tDescOwn=0x80000000, DescMore=0x40000000, DescIntr=0x20000000,\n\tDescNoCRC=0x10000000, DescPktOK=0x08000000,\n\tDescSizeMask=0xfff,\n\n\tDescTxAbort=0x04000000, DescTxFIFO=0x02000000,\n\tDescTxCarrier=0x01000000, DescTxDefer=0x00800000,\n\tDescTxExcDefer=0x00400000, DescTxOOWCol=0x00200000,\n\tDescTxExcColl=0x00100000, DescTxCollCount=0x000f0000,\n\n\tDescRxAbort=0x04000000, DescRxOver=0x02000000,\n\tDescRxDest=0x01800000, DescRxLong=0x00400000,\n\tDescRxRunt=0x00200000, DescRxInvalid=0x00100000,\n\tDescRxCRC=0x00080000, DescRxAlign=0x00040000,\n\tDescRxLoop=0x00020000, DesRxColl=0x00010000,\n};\n\nstruct netdev_private {\n\t \n\tdma_addr_t ring_dma;\n\tstruct netdev_desc *rx_ring;\n\tstruct netdev_desc *tx_ring;\n\t \n\tstruct sk_buff *rx_skbuff[RX_RING_SIZE];\n\tdma_addr_t rx_dma[RX_RING_SIZE];\n\t \n\tstruct sk_buff *tx_skbuff[TX_RING_SIZE];\n\tdma_addr_t tx_dma[TX_RING_SIZE];\n\tstruct net_device *dev;\n\tvoid __iomem *ioaddr;\n\tstruct napi_struct napi;\n\t \n\tstruct timer_list timer;\n\t \n\tstruct pci_dev *pci_dev;\n\tstruct netdev_desc *rx_head_desc;\n\t \n\tunsigned int cur_rx, dirty_rx;\n\tunsigned int cur_tx, dirty_tx;\n\t \n\tunsigned int rx_buf_sz;\n\tint oom;\n\t \n\tu32 intr_status;\n\t \n\tint hands_off;\n\t \n\tint ignore_phy;\n\t \n\tint mii;\n\tint phy_addr_external;\n\tunsigned int full_duplex;\n\t \n\tu32 cur_rx_mode;\n\tu32 rx_filter[16];\n\t \n\tu32 tx_config, rx_config;\n\t \n\tu32 SavedClkRun;\n\t \n\tu32 srr;\n\t \n\tu16 dspcfg;\n\tint dspcfg_workaround;\n\t \n\tu16\tspeed;\t\t \n\tu8\tduplex;\t\t \n\tu8\tautoneg;\t \n\t \n\tu16 advertising;\n\tunsigned int iosize;\n\tspinlock_t lock;\n\tu32 msg_enable;\n\t \n\tint eeprom_size;\n};\n\nstatic void move_int_phy(struct net_device *dev, int addr);\nstatic int eeprom_read(void __iomem *ioaddr, int location);\nstatic int mdio_read(struct net_device *dev, int reg);\nstatic void mdio_write(struct net_device *dev, int reg, u16 data);\nstatic void init_phy_fixup(struct net_device *dev);\nstatic int miiport_read(struct net_device *dev, int phy_id, int reg);\nstatic void miiport_write(struct net_device *dev, int phy_id, int reg, u16 data);\nstatic int find_mii(struct net_device *dev);\nstatic void natsemi_reset(struct net_device *dev);\nstatic void natsemi_reload_eeprom(struct net_device *dev);\nstatic void natsemi_stop_rxtx(struct net_device *dev);\nstatic int netdev_open(struct net_device *dev);\nstatic void do_cable_magic(struct net_device *dev);\nstatic void undo_cable_magic(struct net_device *dev);\nstatic void check_link(struct net_device *dev);\nstatic void netdev_timer(struct timer_list *t);\nstatic void dump_ring(struct net_device *dev);\nstatic void ns_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic int alloc_ring(struct net_device *dev);\nstatic void refill_rx(struct net_device *dev);\nstatic void init_ring(struct net_device *dev);\nstatic void drain_tx(struct net_device *dev);\nstatic void drain_ring(struct net_device *dev);\nstatic void free_ring(struct net_device *dev);\nstatic void reinit_ring(struct net_device *dev);\nstatic void init_registers(struct net_device *dev);\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t intr_handler(int irq, void *dev_instance);\nstatic void netdev_error(struct net_device *dev, int intr_status);\nstatic int natsemi_poll(struct napi_struct *napi, int budget);\nstatic void netdev_rx(struct net_device *dev, int *work_done, int work_to_do);\nstatic void netdev_tx_done(struct net_device *dev);\nstatic int natsemi_change_mtu(struct net_device *dev, int new_mtu);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void natsemi_poll_controller(struct net_device *dev);\n#endif\nstatic void __set_rx_mode(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic void __get_stats(struct net_device *dev);\nstatic struct net_device_stats *get_stats(struct net_device *dev);\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int netdev_set_wol(struct net_device *dev, u32 newval);\nstatic int netdev_get_wol(struct net_device *dev, u32 *supported, u32 *cur);\nstatic int netdev_set_sopass(struct net_device *dev, u8 *newval);\nstatic int netdev_get_sopass(struct net_device *dev, u8 *data);\nstatic int netdev_get_ecmd(struct net_device *dev,\n\t\t\t   struct ethtool_link_ksettings *ecmd);\nstatic int netdev_set_ecmd(struct net_device *dev,\n\t\t\t   const struct ethtool_link_ksettings *ecmd);\nstatic void enable_wol_mode(struct net_device *dev, int enable_intr);\nstatic int netdev_close(struct net_device *dev);\nstatic int netdev_get_regs(struct net_device *dev, u8 *buf);\nstatic int netdev_get_eeprom(struct net_device *dev, u8 *buf);\nstatic const struct ethtool_ops ethtool_ops;\n\n#define NATSEMI_ATTR(_name) \\\nstatic ssize_t natsemi_show_##_name(struct device *dev, \\\n         struct device_attribute *attr, char *buf); \\\n\t static ssize_t natsemi_set_##_name(struct device *dev, \\\n\t\tstruct device_attribute *attr, \\\n\t        const char *buf, size_t count); \\\n\t static DEVICE_ATTR(_name, 0644, natsemi_show_##_name, natsemi_set_##_name)\n\n#define NATSEMI_CREATE_FILE(_dev, _name) \\\n         device_create_file(&_dev->dev, &dev_attr_##_name)\n#define NATSEMI_REMOVE_FILE(_dev, _name) \\\n         device_remove_file(&_dev->dev, &dev_attr_##_name)\n\nNATSEMI_ATTR(dspcfg_workaround);\n\nstatic ssize_t natsemi_show_dspcfg_workaround(struct device *dev,\n\t\t\t\t  \t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct netdev_private *np = netdev_priv(to_net_dev(dev));\n\n\treturn sprintf(buf, \"%s\\n\", np->dspcfg_workaround ? \"on\" : \"off\");\n}\n\nstatic ssize_t natsemi_set_dspcfg_workaround(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct netdev_private *np = netdev_priv(to_net_dev(dev));\n\tint new_setting;\n\tunsigned long flags;\n\n         \n        if (!strncmp(\"on\", buf, count - 1) || !strncmp(\"1\", buf, count - 1))\n                new_setting = 1;\n        else if (!strncmp(\"off\", buf, count - 1) ||\n                 !strncmp(\"0\", buf, count - 1))\n\t\tnew_setting = 0;\n\telse\n                 return count;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tnp->dspcfg_workaround = new_setting;\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn count;\n}\n\nstatic inline void __iomem *ns_ioaddr(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\treturn np->ioaddr;\n}\n\nstatic inline void natsemi_irq_enable(struct net_device *dev)\n{\n\twritel(1, ns_ioaddr(dev) + IntrEnable);\n\treadl(ns_ioaddr(dev) + IntrEnable);\n}\n\nstatic inline void natsemi_irq_disable(struct net_device *dev)\n{\n\twritel(0, ns_ioaddr(dev) + IntrEnable);\n\treadl(ns_ioaddr(dev) + IntrEnable);\n}\n\nstatic void move_int_phy(struct net_device *dev, int addr)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\tint target = 31;\n\n\t \n\n\tif (target == addr)\n\t\ttarget--;\n\tif (target == np->phy_addr_external)\n\t\ttarget--;\n\twritew(target, ioaddr + PhyCtrl);\n\treadw(ioaddr + PhyCtrl);\n\tudelay(1);\n}\n\nstatic void natsemi_init_media(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu32 tmp;\n\n\tif (np->ignore_phy)\n\t\tnetif_carrier_on(dev);\n\telse\n\t\tnetif_carrier_off(dev);\n\n\t \n\ttmp            = mdio_read(dev, MII_BMCR);\n\tnp->speed      = (tmp & BMCR_SPEED100)? SPEED_100     : SPEED_10;\n\tnp->duplex     = (tmp & BMCR_FULLDPLX)? DUPLEX_FULL   : DUPLEX_HALF;\n\tnp->autoneg    = (tmp & BMCR_ANENABLE)? AUTONEG_ENABLE: AUTONEG_DISABLE;\n\tnp->advertising= mdio_read(dev, MII_ADVERTISE);\n\n\tif ((np->advertising & ADVERTISE_ALL) != ADVERTISE_ALL &&\n\t    netif_msg_probe(np)) {\n\t\tprintk(KERN_INFO \"natsemi %s: Transceiver default autonegotiation %s \"\n\t\t\t\"10%s %s duplex.\\n\",\n\t\t\tpci_name(np->pci_dev),\n\t\t\t(mdio_read(dev, MII_BMCR) & BMCR_ANENABLE)?\n\t\t\t  \"enabled, advertise\" : \"disabled, force\",\n\t\t\t(np->advertising &\n\t\t\t  (ADVERTISE_100FULL|ADVERTISE_100HALF))?\n\t\t\t    \"0\" : \"\",\n\t\t\t(np->advertising &\n\t\t\t  (ADVERTISE_100FULL|ADVERTISE_10FULL))?\n\t\t\t    \"full\" : \"half\");\n\t}\n\tif (netif_msg_probe(np))\n\t\tprintk(KERN_INFO\n\t\t\t\"natsemi %s: Transceiver status %#04x advertising %#04x.\\n\",\n\t\t\tpci_name(np->pci_dev), mdio_read(dev, MII_BMSR),\n\t\t\tnp->advertising);\n\n}\n\nstatic const struct net_device_ops natsemi_netdev_ops = {\n\t.ndo_open\t\t= netdev_open,\n\t.ndo_stop\t\t= netdev_close,\n\t.ndo_start_xmit\t\t= start_tx,\n\t.ndo_get_stats\t\t= get_stats,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_change_mtu\t\t= natsemi_change_mtu,\n\t.ndo_eth_ioctl\t\t= netdev_ioctl,\n\t.ndo_tx_timeout \t= ns_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= natsemi_poll_controller,\n#endif\n};\n\nstatic int natsemi_probe1(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct netdev_private *np;\n\tint i, option, irq, chip_idx = ent->driver_data;\n\tstatic int find_cnt = -1;\n\tresource_size_t iostart;\n\tunsigned long iosize;\n\tvoid __iomem *ioaddr;\n\tconst int pcibar = 1;  \n\tu8 addr[ETH_ALEN];\n\tint prev_eedata;\n\tu32 tmp;\n\n \n#ifndef MODULE\n\tstatic int printed_version;\n\tif (!printed_version++)\n\t\tprintk(version);\n#endif\n\n\ti = pcim_enable_device(pdev);\n\tif (i) return i;\n\n\t \n\tpci_read_config_dword(pdev, PCIPM, &tmp);\n\tif (tmp & PCI_PM_CTRL_STATE_MASK) {\n\t\t \n\t\tu32 newtmp = tmp & ~PCI_PM_CTRL_STATE_MASK;\n\t\tpci_write_config_dword(pdev, PCIPM, newtmp);\n\t}\n\n\tfind_cnt++;\n\tiostart = pci_resource_start(pdev, pcibar);\n\tiosize = pci_resource_len(pdev, pcibar);\n\tirq = pdev->irq;\n\n\tpci_set_master(pdev);\n\n\tdev = alloc_etherdev(sizeof (struct netdev_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\ti = pci_request_regions(pdev, DRV_NAME);\n\tif (i)\n\t\tgoto err_pci_request_regions;\n\n\tioaddr = ioremap(iostart, iosize);\n\tif (!ioaddr) {\n\t\ti = -ENOMEM;\n\t\tgoto err_pci_request_regions;\n\t}\n\n\t \n\tprev_eedata = eeprom_read(ioaddr, 6);\n\tfor (i = 0; i < 3; i++) {\n\t\tint eedata = eeprom_read(ioaddr, i + 7);\n\t\taddr[i*2] = (eedata << 1) + (prev_eedata >> 15);\n\t\taddr[i*2+1] = eedata >> 7;\n\t\tprev_eedata = eedata;\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\tnp = netdev_priv(dev);\n\tnp->ioaddr = ioaddr;\n\n\tnetif_napi_add(dev, &np->napi, natsemi_poll);\n\tnp->dev = dev;\n\n\tnp->pci_dev = pdev;\n\tpci_set_drvdata(pdev, dev);\n\tnp->iosize = iosize;\n\tspin_lock_init(&np->lock);\n\tnp->msg_enable = (debug >= 0) ? (1<<debug)-1 : NATSEMI_DEF_MSG;\n\tnp->hands_off = 0;\n\tnp->intr_status = 0;\n\tnp->eeprom_size = natsemi_pci_info[chip_idx].eeprom_size;\n\tif (natsemi_pci_info[chip_idx].flags & NATSEMI_FLAG_IGNORE_PHY)\n\t\tnp->ignore_phy = 1;\n\telse\n\t\tnp->ignore_phy = 0;\n\tnp->dspcfg_workaround = dspcfg_workaround;\n\n\t \n\tif (np->ignore_phy || readl(ioaddr + ChipConfig) & CfgExtPhy)\n\t\tdev->if_port = PORT_MII;\n\telse\n\t\tdev->if_port = PORT_TP;\n\t \n\tnatsemi_reload_eeprom(dev);\n\tnatsemi_reset(dev);\n\n\tif (dev->if_port != PORT_TP) {\n\t\tnp->phy_addr_external = find_mii(dev);\n\t\t \n\t\tif (!np->ignore_phy && np->phy_addr_external == PHY_ADDR_NONE) {\n\t\t\tdev->if_port = PORT_TP;\n\t\t\tnp->phy_addr_external = PHY_ADDR_INTERNAL;\n\t\t}\n\t} else {\n\t\tnp->phy_addr_external = PHY_ADDR_INTERNAL;\n\t}\n\n\toption = find_cnt < MAX_UNITS ? options[find_cnt] : 0;\n\t \n\tif (option) {\n\t\tif (option & 0x200)\n\t\t\tnp->full_duplex = 1;\n\t\tif (option & 15)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"natsemi %s: ignoring user supplied media type %d\",\n\t\t\t\tpci_name(np->pci_dev), option & 15);\n\t}\n\tif (find_cnt < MAX_UNITS  &&  full_duplex[find_cnt])\n\t\tnp->full_duplex = 1;\n\n\tdev->netdev_ops = &natsemi_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tdev->ethtool_ops = &ethtool_ops;\n\n\t \n\tdev->min_mtu = ETH_ZLEN + ETH_FCS_LEN;\n\tdev->max_mtu = NATSEMI_RX_LIMIT - NATSEMI_HEADERS;\n\n\tif (mtu)\n\t\tdev->mtu = mtu;\n\n\tnatsemi_init_media(dev);\n\n\t \n\tnp->srr = readl(ioaddr + SiliconRev);\n\tif (netif_msg_hw(np))\n\t\tprintk(KERN_INFO \"natsemi %s: silicon revision %#04x.\\n\",\n\t\t\t\tpci_name(np->pci_dev), np->srr);\n\n\ti = register_netdev(dev);\n\tif (i)\n\t\tgoto err_register_netdev;\n\ti = NATSEMI_CREATE_FILE(pdev, dspcfg_workaround);\n\tif (i)\n\t\tgoto err_create_file;\n\n\tif (netif_msg_drv(np)) {\n\t\tprintk(KERN_INFO \"natsemi %s: %s at %#08llx \"\n\t\t       \"(%s), %pM, IRQ %d\",\n\t\t       dev->name, natsemi_pci_info[chip_idx].name,\n\t\t       (unsigned long long)iostart, pci_name(np->pci_dev),\n\t\t       dev->dev_addr, irq);\n\t\tif (dev->if_port == PORT_TP)\n\t\t\tprintk(\", port TP.\\n\");\n\t\telse if (np->ignore_phy)\n\t\t\tprintk(\", port MII, ignoring PHY\\n\");\n\t\telse\n\t\t\tprintk(\", port MII, phy ad %d.\\n\", np->phy_addr_external);\n\t}\n\treturn 0;\n\n err_create_file:\n\tunregister_netdev(dev);\n\n err_register_netdev:\n\tiounmap(ioaddr);\n\n err_pci_request_regions:\n\tfree_netdev(dev);\n\treturn i;\n}\n\n\n \n\n \n#define eeprom_delay(ee_addr)\treadl(ee_addr)\n\n#define EE_Write0 (EE_ChipSelect)\n#define EE_Write1 (EE_ChipSelect | EE_DataIn)\n\n \nenum EEPROM_Cmds {\n\tEE_WriteCmd=(5 << 6), EE_ReadCmd=(6 << 6), EE_EraseCmd=(7 << 6),\n};\n\nstatic int eeprom_read(void __iomem *addr, int location)\n{\n\tint i;\n\tint retval = 0;\n\tvoid __iomem *ee_addr = addr + EECtrl;\n\tint read_cmd = location | EE_ReadCmd;\n\n\twritel(EE_Write0, ee_addr);\n\n\t \n\tfor (i = 10; i >= 0; i--) {\n\t\tshort dataval = (read_cmd & (1 << i)) ? EE_Write1 : EE_Write0;\n\t\twritel(dataval, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t\twritel(dataval | EE_ShiftClk, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t}\n\twritel(EE_ChipSelect, ee_addr);\n\teeprom_delay(ee_addr);\n\n\tfor (i = 0; i < 16; i++) {\n\t\twritel(EE_ChipSelect | EE_ShiftClk, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t\tretval |= (readl(ee_addr) & EE_DataOut) ? 1 << i : 0;\n\t\twritel(EE_ChipSelect, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t}\n\n\t \n\twritel(EE_Write0, ee_addr);\n\twritel(0, ee_addr);\n\treturn retval;\n}\n\n \n\n \n#define mii_delay(ioaddr)  readl(ioaddr + EECtrl)\n\nstatic int mii_getbit (struct net_device *dev)\n{\n\tint data;\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\n\twritel(MII_ShiftClk, ioaddr + EECtrl);\n\tdata = readl(ioaddr + EECtrl);\n\twritel(0, ioaddr + EECtrl);\n\tmii_delay(ioaddr);\n\treturn (data & MII_Data)? 1 : 0;\n}\n\nstatic void mii_send_bits (struct net_device *dev, u32 data, int len)\n{\n\tu32 i;\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\n\tfor (i = (1 << (len-1)); i; i >>= 1)\n\t{\n\t\tu32 mdio_val = MII_Write | ((data & i)? MII_Data : 0);\n\t\twritel(mdio_val, ioaddr + EECtrl);\n\t\tmii_delay(ioaddr);\n\t\twritel(mdio_val | MII_ShiftClk, ioaddr + EECtrl);\n\t\tmii_delay(ioaddr);\n\t}\n\twritel(0, ioaddr + EECtrl);\n\tmii_delay(ioaddr);\n}\n\nstatic int miiport_read(struct net_device *dev, int phy_id, int reg)\n{\n\tu32 cmd;\n\tint i;\n\tu32 retval = 0;\n\n\t \n\tmii_send_bits (dev, 0xffffffff, 32);\n\t \n\t \n\tcmd = (0x06 << 10) | (phy_id << 5) | reg;\n\tmii_send_bits (dev, cmd, 14);\n\t \n\tif (mii_getbit (dev))\n\t\treturn 0;\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tretval <<= 1;\n\t\tretval |= mii_getbit (dev);\n\t}\n\t \n\tmii_getbit (dev);\n\treturn retval;\n}\n\nstatic void miiport_write(struct net_device *dev, int phy_id, int reg, u16 data)\n{\n\tu32 cmd;\n\n\t \n\tmii_send_bits (dev, 0xffffffff, 32);\n\t \n\t \n\tcmd = (0x5002 << 16) | (phy_id << 23) | (reg << 18) | data;\n\tmii_send_bits (dev, cmd, 32);\n\t \n\tmii_getbit (dev);\n}\n\nstatic int mdio_read(struct net_device *dev, int reg)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\n\t \n\tif (dev->if_port == PORT_TP)\n\t\treturn readw(ioaddr+BasicControl+(reg<<2));\n\telse\n\t\treturn miiport_read(dev, np->phy_addr_external, reg);\n}\n\nstatic void mdio_write(struct net_device *dev, int reg, u16 data)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\n\t \n\tif (dev->if_port == PORT_TP)\n\t\twritew(data, ioaddr+BasicControl+(reg<<2));\n\telse\n\t\tmiiport_write(dev, np->phy_addr_external, reg, data);\n}\n\nstatic void init_phy_fixup(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\tint i;\n\tu32 cfg;\n\tu16 tmp;\n\n\t \n\ttmp = mdio_read(dev, MII_BMCR);\n\tif (np->autoneg == AUTONEG_ENABLE) {\n\t\t \n\t\tif ((tmp & BMCR_ANENABLE) == 0 ||\n\t\t    np->advertising != mdio_read(dev, MII_ADVERTISE))\n\t\t{\n\t\t\t \n\t\t\ttmp |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t\t\tmdio_write(dev, MII_ADVERTISE, np->advertising);\n\t\t}\n\t} else {\n\t\t \n\t\ttmp &= ~(BMCR_ANENABLE | BMCR_SPEED100 | BMCR_FULLDPLX);\n\t\tif (np->speed == SPEED_100)\n\t\t\ttmp |= BMCR_SPEED100;\n\t\tif (np->duplex == DUPLEX_FULL)\n\t\t\ttmp |= BMCR_FULLDPLX;\n\t\t \n\t}\n\tmdio_write(dev, MII_BMCR, tmp);\n\treadl(ioaddr + ChipConfig);\n\tudelay(1);\n\n\t \n\tnp->mii = (mdio_read(dev, MII_PHYSID1) << 16)\n\t\t\t\t+ mdio_read(dev, MII_PHYSID2);\n\n\t \n\tswitch (np->mii) {\n\tcase PHYID_AM79C874:\n\t\t \n\t\ttmp = mdio_read(dev, MII_MCTRL);\n\t\ttmp &= ~(MII_FX_SEL | MII_EN_SCRM);\n\t\tif (dev->if_port == PORT_FIBRE)\n\t\t\ttmp |= MII_FX_SEL;\n\t\telse\n\t\t\ttmp |= MII_EN_SCRM;\n\t\tmdio_write(dev, MII_MCTRL, tmp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tcfg = readl(ioaddr + ChipConfig);\n\tif (cfg & CfgExtPhy)\n\t\treturn;\n\n\t \n\tfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\n\n\t\tint dspcfg;\n\t\twritew(1, ioaddr + PGSEL);\n\t\twritew(PMDCSR_VAL, ioaddr + PMDCSR);\n\t\twritew(TSTDAT_VAL, ioaddr + TSTDAT);\n\t\tnp->dspcfg = (np->srr <= SRR_DP83815_C)?\n\t\t\tDSPCFG_VAL : (DSPCFG_COEF | readw(ioaddr + DSPCFG));\n\t\twritew(np->dspcfg, ioaddr + DSPCFG);\n\t\twritew(SDCFG_VAL, ioaddr + SDCFG);\n\t\twritew(0, ioaddr + PGSEL);\n\t\treadl(ioaddr + ChipConfig);\n\t\tudelay(10);\n\n\t\twritew(1, ioaddr + PGSEL);\n\t\tdspcfg = readw(ioaddr + DSPCFG);\n\t\twritew(0, ioaddr + PGSEL);\n\t\tif (np->dspcfg == dspcfg)\n\t\t\tbreak;\n\t}\n\n\tif (netif_msg_link(np)) {\n\t\tif (i==NATSEMI_HW_TIMEOUT) {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"%s: DSPCFG mismatch after retrying for %d usec.\\n\",\n\t\t\t\tdev->name, i*10);\n\t\t} else {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"%s: DSPCFG accepted after %d usec.\\n\",\n\t\t\t\tdev->name, i*10);\n\t\t}\n\t}\n\t \n\treadw(ioaddr + MIntrStatus);\n\twritew(MICRIntEn, ioaddr + MIntrCtrl);\n}\n\nstatic int switch_port_external(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\tu32 cfg;\n\n\tcfg = readl(ioaddr + ChipConfig);\n\tif (cfg & CfgExtPhy)\n\t\treturn 0;\n\n\tif (netif_msg_link(np)) {\n\t\tprintk(KERN_INFO \"%s: switching to external transceiver.\\n\",\n\t\t\t\tdev->name);\n\t}\n\n\t \n\twritel(cfg | (CfgExtPhy | CfgPhyDis), ioaddr + ChipConfig);\n\treadl(ioaddr + ChipConfig);\n\tudelay(1);\n\n\t \n\t \n\n\t \n\tmove_int_phy(dev, np->phy_addr_external);\n\tinit_phy_fixup(dev);\n\n\treturn 1;\n}\n\nstatic int switch_port_internal(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\tint i;\n\tu32 cfg;\n\tu16 bmcr;\n\n\tcfg = readl(ioaddr + ChipConfig);\n\tif (!(cfg &CfgExtPhy))\n\t\treturn 0;\n\n\tif (netif_msg_link(np)) {\n\t\tprintk(KERN_INFO \"%s: switching to internal transceiver.\\n\",\n\t\t\t\tdev->name);\n\t}\n\t \n\tcfg = cfg & ~(CfgExtPhy | CfgPhyDis);\n\twritel(cfg, ioaddr + ChipConfig);\n\treadl(ioaddr + ChipConfig);\n\tudelay(1);\n\n\t \n\tbmcr = readw(ioaddr+BasicControl+(MII_BMCR<<2));\n\twritel(bmcr | BMCR_RESET, ioaddr+BasicControl+(MII_BMCR<<2));\n\treadl(ioaddr + ChipConfig);\n\tudelay(10);\n\tfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\n\t\tbmcr = readw(ioaddr+BasicControl+(MII_BMCR<<2));\n\t\tif (!(bmcr & BMCR_RESET))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (i==NATSEMI_HW_TIMEOUT && netif_msg_link(np)) {\n\t\tprintk(KERN_INFO\n\t\t\t\"%s: phy reset did not complete in %d usec.\\n\",\n\t\t\tdev->name, i*10);\n\t}\n\t \n\tinit_phy_fixup(dev);\n\n\treturn 1;\n}\n\n \nstatic int find_mii(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint tmp;\n\tint i;\n\tint did_switch;\n\n\t \n\tdid_switch = switch_port_external(dev);\n\n\t \n\tfor (i = 1; i <= 31; i++) {\n\t\tmove_int_phy(dev, i);\n\t\ttmp = miiport_read(dev, i, MII_BMSR);\n\t\tif (tmp != 0xffff && tmp != 0x0000) {\n\t\t\t \n\t\t\tnp->mii = (mdio_read(dev, MII_PHYSID1) << 16)\n\t\t\t\t\t+ mdio_read(dev, MII_PHYSID2);\n\t \t\tif (netif_msg_probe(np)) {\n\t\t\t\tprintk(KERN_INFO \"natsemi %s: found external phy %08x at address %d.\\n\",\n\t\t\t\t\t\tpci_name(np->pci_dev), np->mii, i);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (did_switch)\n\t\tswitch_port_internal(dev);\n\treturn i;\n}\n\n \n#define CFG_RESET_SAVE 0xfde000\n \n#define WCSR_RESET_SAVE 0x61f\n \n#define RFCR_RESET_SAVE 0xf8500000\n\nstatic void natsemi_reset(struct net_device *dev)\n{\n\tint i;\n\tu32 cfg;\n\tu32 wcsr;\n\tu32 rfcr;\n\tu16 pmatch[3];\n\tu16 sopass[3];\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\n\t \n\n\t \n\tcfg = readl(ioaddr + ChipConfig) & CFG_RESET_SAVE;\n\t \n\twcsr = readl(ioaddr + WOLCmd) & WCSR_RESET_SAVE;\n\t \n\trfcr = readl(ioaddr + RxFilterAddr) & RFCR_RESET_SAVE;\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\twritel(i*2, ioaddr + RxFilterAddr);\n\t\tpmatch[i] = readw(ioaddr + RxFilterData);\n\t}\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\twritel(0xa+(i*2), ioaddr + RxFilterAddr);\n\t\tsopass[i] = readw(ioaddr + RxFilterData);\n\t}\n\n\t \n\twritel(ChipReset, ioaddr + ChipCmd);\n\tfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\n\t\tif (!(readl(ioaddr + ChipCmd) & ChipReset))\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\tif (i==NATSEMI_HW_TIMEOUT) {\n\t\tprintk(KERN_WARNING \"%s: reset did not complete in %d usec.\\n\",\n\t\t\tdev->name, i*5);\n\t} else if (netif_msg_hw(np)) {\n\t\tprintk(KERN_DEBUG \"%s: reset completed in %d usec.\\n\",\n\t\t\tdev->name, i*5);\n\t}\n\n\t \n\tcfg |= readl(ioaddr + ChipConfig) & ~CFG_RESET_SAVE;\n\t \n\tif (dev->if_port == PORT_TP)\n\t\tcfg &= ~(CfgExtPhy | CfgPhyDis);\n\telse\n\t\tcfg |= (CfgExtPhy | CfgPhyDis);\n\twritel(cfg, ioaddr + ChipConfig);\n\t \n\twcsr |= readl(ioaddr + WOLCmd) & ~WCSR_RESET_SAVE;\n\twritel(wcsr, ioaddr + WOLCmd);\n\t \n\trfcr |= readl(ioaddr + RxFilterAddr) & ~RFCR_RESET_SAVE;\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\twritel(i*2, ioaddr + RxFilterAddr);\n\t\twritew(pmatch[i], ioaddr + RxFilterData);\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\twritel(0xa+(i*2), ioaddr + RxFilterAddr);\n\t\twritew(sopass[i], ioaddr + RxFilterData);\n\t}\n\t \n\twritel(rfcr, ioaddr + RxFilterAddr);\n}\n\nstatic void reset_rx(struct net_device *dev)\n{\n\tint i;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\n\tnp->intr_status &= ~RxResetDone;\n\n\twritel(RxReset, ioaddr + ChipCmd);\n\n\tfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\n\t\tnp->intr_status |= readl(ioaddr + IntrStatus);\n\t\tif (np->intr_status & RxResetDone)\n\t\t\tbreak;\n\t\tudelay(15);\n\t}\n\tif (i==NATSEMI_HW_TIMEOUT) {\n\t\tprintk(KERN_WARNING \"%s: RX reset did not complete in %d usec.\\n\",\n\t\t       dev->name, i*15);\n\t} else if (netif_msg_hw(np)) {\n\t\tprintk(KERN_WARNING \"%s: RX reset took %d usec.\\n\",\n\t\t       dev->name, i*15);\n\t}\n}\n\nstatic void natsemi_reload_eeprom(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\tint i;\n\n\twritel(EepromReload, ioaddr + PCIBusCfg);\n\tfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\n\t\tudelay(50);\n\t\tif (!(readl(ioaddr + PCIBusCfg) & EepromReload))\n\t\t\tbreak;\n\t}\n\tif (i==NATSEMI_HW_TIMEOUT) {\n\t\tprintk(KERN_WARNING \"natsemi %s: EEPROM did not reload in %d usec.\\n\",\n\t\t\tpci_name(np->pci_dev), i*50);\n\t} else if (netif_msg_hw(np)) {\n\t\tprintk(KERN_DEBUG \"natsemi %s: EEPROM reloaded in %d usec.\\n\",\n\t\t\tpci_name(np->pci_dev), i*50);\n\t}\n}\n\nstatic void natsemi_stop_rxtx(struct net_device *dev)\n{\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\twritel(RxOff | TxOff, ioaddr + ChipCmd);\n\tfor(i=0;i< NATSEMI_HW_TIMEOUT;i++) {\n\t\tif ((readl(ioaddr + ChipCmd) & (TxOn|RxOn)) == 0)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\tif (i==NATSEMI_HW_TIMEOUT) {\n\t\tprintk(KERN_WARNING \"%s: Tx/Rx process did not stop in %d usec.\\n\",\n\t\t\tdev->name, i*5);\n\t} else if (netif_msg_hw(np)) {\n\t\tprintk(KERN_DEBUG \"%s: Tx/Rx process stopped in %d usec.\\n\",\n\t\t\tdev->name, i*5);\n\t}\n}\n\nstatic int netdev_open(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tconst int irq = np->pci_dev->irq;\n\tint i;\n\n\t \n\tnatsemi_reset(dev);\n\n\ti = request_irq(irq, intr_handler, IRQF_SHARED, dev->name, dev);\n\tif (i) return i;\n\n\tif (netif_msg_ifup(np))\n\t\tprintk(KERN_DEBUG \"%s: netdev_open() irq %d.\\n\",\n\t\t\tdev->name, irq);\n\ti = alloc_ring(dev);\n\tif (i < 0) {\n\t\tfree_irq(irq, dev);\n\t\treturn i;\n\t}\n\tnapi_enable(&np->napi);\n\n\tinit_ring(dev);\n\tspin_lock_irq(&np->lock);\n\tinit_registers(dev);\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tu16 mac = (dev->dev_addr[2*i+1]<<8) + dev->dev_addr[2*i];\n\n\t\twritel(i*2, ioaddr + RxFilterAddr);\n\t\twritew(mac, ioaddr + RxFilterData);\n\t}\n\twritel(np->cur_rx_mode, ioaddr + RxFilterAddr);\n\tspin_unlock_irq(&np->lock);\n\n\tnetif_start_queue(dev);\n\n\tif (netif_msg_ifup(np))\n\t\tprintk(KERN_DEBUG \"%s: Done netdev_open(), status: %#08x.\\n\",\n\t\t\tdev->name, (int)readl(ioaddr + ChipCmd));\n\n\t \n\ttimer_setup(&np->timer, netdev_timer, 0);\n\tnp->timer.expires = round_jiffies(jiffies + NATSEMI_TIMER_FREQ);\n\tadd_timer(&np->timer);\n\n\treturn 0;\n}\n\nstatic void do_cable_magic(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ns_ioaddr(dev);\n\n\tif (dev->if_port != PORT_TP)\n\t\treturn;\n\n\tif (np->srr >= SRR_DP83816_A5)\n\t\treturn;\n\n\t \n\tif (readl(ioaddr + ChipConfig) & CfgSpeed100) {\n\t\tu16 data;\n\n\t\twritew(1, ioaddr + PGSEL);\n\t\t \n\t\tdata = readw(ioaddr + TSTDAT) & 0xff;\n\t\t \n\t\tif (!(data & 0x80) || ((data >= 0xd8) && (data <= 0xff))) {\n\t\t\tnp = netdev_priv(dev);\n\n\t\t\t \n\t\t\twritew(TSTDAT_FIXED, ioaddr + TSTDAT);\n\t\t\t \n\t\t\tdata = readw(ioaddr + DSPCFG);\n\t\t\tnp->dspcfg = data | DSPCFG_LOCK;\n\t\t\twritew(np->dspcfg, ioaddr + DSPCFG);\n\t\t}\n\t\twritew(0, ioaddr + PGSEL);\n\t}\n}\n\nstatic void undo_cable_magic(struct net_device *dev)\n{\n\tu16 data;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\tif (dev->if_port != PORT_TP)\n\t\treturn;\n\n\tif (np->srr >= SRR_DP83816_A5)\n\t\treturn;\n\n\twritew(1, ioaddr + PGSEL);\n\t \n\tdata = readw(ioaddr + DSPCFG);\n\tnp->dspcfg = data & ~DSPCFG_LOCK;\n\twritew(np->dspcfg, ioaddr + DSPCFG);\n\twritew(0, ioaddr + PGSEL);\n}\n\nstatic void check_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tint duplex = np->duplex;\n\tu16 bmsr;\n\n\t \n\tif (np->ignore_phy)\n\t\tgoto propagate_state;\n\n\t \n\tmdio_read(dev, MII_BMSR);\n\tbmsr = mdio_read(dev, MII_BMSR);\n\n\tif (!(bmsr & BMSR_LSTATUS)) {\n\t\tif (netif_carrier_ok(dev)) {\n\t\t\tif (netif_msg_link(np))\n\t\t\t\tprintk(KERN_NOTICE \"%s: link down.\\n\",\n\t\t\t\t       dev->name);\n\t\t\tnetif_carrier_off(dev);\n\t\t\tundo_cable_magic(dev);\n\t\t}\n\t\treturn;\n\t}\n\tif (!netif_carrier_ok(dev)) {\n\t\tif (netif_msg_link(np))\n\t\t\tprintk(KERN_NOTICE \"%s: link up.\\n\", dev->name);\n\t\tnetif_carrier_on(dev);\n\t\tdo_cable_magic(dev);\n\t}\n\n\tduplex = np->full_duplex;\n\tif (!duplex) {\n\t\tif (bmsr & BMSR_ANEGCOMPLETE) {\n\t\t\tint tmp = mii_nway_result(\n\t\t\t\tnp->advertising & mdio_read(dev, MII_LPA));\n\t\t\tif (tmp == LPA_100FULL || tmp == LPA_10FULL)\n\t\t\t\tduplex = 1;\n\t\t} else if (mdio_read(dev, MII_BMCR) & BMCR_FULLDPLX)\n\t\t\tduplex = 1;\n\t}\n\npropagate_state:\n\t \n\tif (duplex ^ !!(np->rx_config & RxAcceptTx)) {\n\t\tif (netif_msg_link(np))\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"%s: Setting %s-duplex based on negotiated \"\n\t\t\t\t\"link capability.\\n\", dev->name,\n\t\t\t\tduplex ? \"full\" : \"half\");\n\t\tif (duplex) {\n\t\t\tnp->rx_config |= RxAcceptTx;\n\t\t\tnp->tx_config |= TxCarrierIgn | TxHeartIgn;\n\t\t} else {\n\t\t\tnp->rx_config &= ~RxAcceptTx;\n\t\t\tnp->tx_config &= ~(TxCarrierIgn | TxHeartIgn);\n\t\t}\n\t\twritel(np->tx_config, ioaddr + TxConfig);\n\t\twritel(np->rx_config, ioaddr + RxConfig);\n\t}\n}\n\nstatic void init_registers(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\tinit_phy_fixup(dev);\n\n\t \n\treadl(ioaddr + IntrStatus);\n\n\twritel(np->ring_dma, ioaddr + RxRingPtr);\n\twritel(np->ring_dma + RX_RING_SIZE * sizeof(struct netdev_desc),\n\t\tioaddr + TxRingPtr);\n\n\t \n\n\t \n\tnp->tx_config = TxAutoPad | TxCollRetry | TxMxdma_256 |\n\t\t\t\tTX_FLTH_VAL | TX_DRTH_VAL_START;\n\twritel(np->tx_config, ioaddr + TxConfig);\n\n\t \n\tnp->rx_config = RxMxdma_256 | RX_DRTH_VAL;\n\t \n\tif (np->rx_buf_sz > NATSEMI_LONGPKT)\n\t\tnp->rx_config |= RxAcceptLong;\n\n\twritel(np->rx_config, ioaddr + RxConfig);\n\n\t \n\tnp->SavedClkRun = readl(ioaddr + ClkRun);\n\twritel(np->SavedClkRun & ~PMEEnable, ioaddr + ClkRun);\n\tif (np->SavedClkRun & PMEStatus && netif_msg_wol(np)) {\n\t\tprintk(KERN_NOTICE \"%s: Wake-up event %#08x\\n\",\n\t\t\tdev->name, readl(ioaddr + WOLCmd));\n\t}\n\n\tcheck_link(dev);\n\t__set_rx_mode(dev);\n\n\t \n\twritel(DEFAULT_INTR, ioaddr + IntrMask);\n\tnatsemi_irq_enable(dev);\n\n\twritel(RxOn | TxOn, ioaddr + ChipCmd);\n\twritel(StatsClear, ioaddr + StatsCtrl);  \n}\n\n \nstatic void netdev_timer(struct timer_list *t)\n{\n\tstruct netdev_private *np = from_timer(np, t, timer);\n\tstruct net_device *dev = np->dev;\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tint next_tick = NATSEMI_TIMER_FREQ;\n\tconst int irq = np->pci_dev->irq;\n\n\tif (netif_msg_timer(np)) {\n\t\t \n\t\tprintk(KERN_DEBUG \"%s: Media selection timer tick.\\n\",\n\t\t\tdev->name);\n\t}\n\n\tif (dev->if_port == PORT_TP) {\n\t\tu16 dspcfg;\n\n\t\tspin_lock_irq(&np->lock);\n\t\t \n\t\twritew(1, ioaddr+PGSEL);\n\t\tdspcfg = readw(ioaddr+DSPCFG);\n\t\twritew(0, ioaddr+PGSEL);\n\t\tif (np->dspcfg_workaround && dspcfg != np->dspcfg) {\n\t\t\tif (!netif_queue_stopped(dev)) {\n\t\t\t\tspin_unlock_irq(&np->lock);\n\t\t\t\tif (netif_msg_drv(np))\n\t\t\t\t\tprintk(KERN_NOTICE \"%s: possible phy reset: \"\n\t\t\t\t\t\t\"re-initializing\\n\", dev->name);\n\t\t\t\tdisable_irq(irq);\n\t\t\t\tspin_lock_irq(&np->lock);\n\t\t\t\tnatsemi_stop_rxtx(dev);\n\t\t\t\tdump_ring(dev);\n\t\t\t\treinit_ring(dev);\n\t\t\t\tinit_registers(dev);\n\t\t\t\tspin_unlock_irq(&np->lock);\n\t\t\t\tenable_irq(irq);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnext_tick = HZ;\n\t\t\t\tspin_unlock_irq(&np->lock);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tcheck_link(dev);\n\t\t\tspin_unlock_irq(&np->lock);\n\t\t}\n\t} else {\n\t\tspin_lock_irq(&np->lock);\n\t\tcheck_link(dev);\n\t\tspin_unlock_irq(&np->lock);\n\t}\n\tif (np->oom) {\n\t\tdisable_irq(irq);\n\t\tnp->oom = 0;\n\t\trefill_rx(dev);\n\t\tenable_irq(irq);\n\t\tif (!np->oom) {\n\t\t\twritel(RxOn, ioaddr + ChipCmd);\n\t\t} else {\n\t\t\tnext_tick = 1;\n\t\t}\n\t}\n\n\tif (next_tick > 1)\n\t\tmod_timer(&np->timer, round_jiffies(jiffies + next_tick));\n\telse\n\t\tmod_timer(&np->timer, jiffies + next_tick);\n}\n\nstatic void dump_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tif (netif_msg_pktdata(np)) {\n\t\tint i;\n\t\tprintk(KERN_DEBUG \"  Tx ring at %p:\\n\", np->tx_ring);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tprintk(KERN_DEBUG \" #%d desc. %#08x %#08x %#08x.\\n\",\n\t\t\t\ti, np->tx_ring[i].next_desc,\n\t\t\t\tnp->tx_ring[i].cmd_status,\n\t\t\t\tnp->tx_ring[i].addr);\n\t\t}\n\t\tprintk(KERN_DEBUG \"  Rx ring %p:\\n\", np->rx_ring);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tprintk(KERN_DEBUG \" #%d desc. %#08x %#08x %#08x.\\n\",\n\t\t\t\ti, np->rx_ring[i].next_desc,\n\t\t\t\tnp->rx_ring[i].cmd_status,\n\t\t\t\tnp->rx_ring[i].addr);\n\t\t}\n\t}\n}\n\nstatic void ns_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tconst int irq = np->pci_dev->irq;\n\n\tdisable_irq(irq);\n\tspin_lock_irq(&np->lock);\n\tif (!np->hands_off) {\n\t\tif (netif_msg_tx_err(np))\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"%s: Transmit timed out, status %#08x,\"\n\t\t\t\t\" resetting...\\n\",\n\t\t\t\tdev->name, readl(ioaddr + IntrStatus));\n\t\tdump_ring(dev);\n\n\t\tnatsemi_reset(dev);\n\t\treinit_ring(dev);\n\t\tinit_registers(dev);\n\t} else {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: tx_timeout while in hands_off state?\\n\",\n\t\t\tdev->name);\n\t}\n\tspin_unlock_irq(&np->lock);\n\tenable_irq(irq);\n\n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n\tnetif_wake_queue(dev);\n}\n\nstatic int alloc_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tnp->rx_ring = dma_alloc_coherent(&np->pci_dev->dev,\n\t\t\t\t\t sizeof(struct netdev_desc) * (RX_RING_SIZE + TX_RING_SIZE),\n\t\t\t\t\t &np->ring_dma, GFP_KERNEL);\n\tif (!np->rx_ring)\n\t\treturn -ENOMEM;\n\tnp->tx_ring = &np->rx_ring[RX_RING_SIZE];\n\treturn 0;\n}\n\nstatic void refill_rx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\t \n\tfor (; np->cur_rx - np->dirty_rx > 0; np->dirty_rx++) {\n\t\tstruct sk_buff *skb;\n\t\tint entry = np->dirty_rx % RX_RING_SIZE;\n\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\tunsigned int buflen = np->rx_buf_sz+NATSEMI_PADDING;\n\t\t\tskb = netdev_alloc_skb(dev, buflen);\n\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;  \n\t\t\tnp->rx_dma[entry] = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\t   skb->data, buflen,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&np->pci_dev->dev, np->rx_dma[entry])) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tnp->rx_skbuff[entry] = NULL;\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t\tnp->rx_ring[entry].addr = cpu_to_le32(np->rx_dma[entry]);\n\t\t}\n\t\tnp->rx_ring[entry].cmd_status = cpu_to_le32(np->rx_buf_sz);\n\t}\n\tif (np->cur_rx - np->dirty_rx == RX_RING_SIZE) {\n\t\tif (netif_msg_rx_err(np))\n\t\t\tprintk(KERN_WARNING \"%s: going OOM.\\n\", dev->name);\n\t\tnp->oom = 1;\n\t}\n}\n\nstatic void set_bufsize(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tif (dev->mtu <= ETH_DATA_LEN)\n\t\tnp->rx_buf_sz = ETH_DATA_LEN + NATSEMI_HEADERS;\n\telse\n\t\tnp->rx_buf_sz = dev->mtu + NATSEMI_HEADERS;\n}\n\n \nstatic void init_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\t \n\tnp->dirty_tx = np->cur_tx = 0;\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tnp->tx_skbuff[i] = NULL;\n\t\tnp->tx_ring[i].next_desc = cpu_to_le32(np->ring_dma\n\t\t\t+sizeof(struct netdev_desc)\n\t\t\t*((i+1)%TX_RING_SIZE+RX_RING_SIZE));\n\t\tnp->tx_ring[i].cmd_status = 0;\n\t}\n\n\t \n\tnp->dirty_rx = 0;\n\tnp->cur_rx = RX_RING_SIZE;\n\tnp->oom = 0;\n\tset_bufsize(dev);\n\n\tnp->rx_head_desc = &np->rx_ring[0];\n\n\t \n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].next_desc = cpu_to_le32(np->ring_dma\n\t\t\t\t+sizeof(struct netdev_desc)\n\t\t\t\t*((i+1)%RX_RING_SIZE));\n\t\tnp->rx_ring[i].cmd_status = cpu_to_le32(DescOwn);\n\t\tnp->rx_skbuff[i] = NULL;\n\t}\n\trefill_rx(dev);\n\tdump_ring(dev);\n}\n\nstatic void drain_tx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tif (np->tx_skbuff[i]) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev, np->tx_dma[i],\n\t\t\t\t\t np->tx_skbuff[i]->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(np->tx_skbuff[i]);\n\t\t\tdev->stats.tx_dropped++;\n\t\t}\n\t\tnp->tx_skbuff[i] = NULL;\n\t}\n}\n\nstatic void drain_rx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tunsigned int buflen = np->rx_buf_sz;\n\tint i;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].cmd_status = 0;\n\t\tnp->rx_ring[i].addr = cpu_to_le32(0xBADF00D0);  \n\t\tif (np->rx_skbuff[i]) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev, np->rx_dma[i],\n\t\t\t\t\t buflen + NATSEMI_PADDING,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(np->rx_skbuff[i]);\n\t\t}\n\t\tnp->rx_skbuff[i] = NULL;\n\t}\n}\n\nstatic void drain_ring(struct net_device *dev)\n{\n\tdrain_rx(dev);\n\tdrain_tx(dev);\n}\n\nstatic void free_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tdma_free_coherent(&np->pci_dev->dev,\n\t\t\t  sizeof(struct netdev_desc) * (RX_RING_SIZE + TX_RING_SIZE),\n\t\t\t  np->rx_ring, np->ring_dma);\n}\n\nstatic void reinit_rx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\t \n\tnp->dirty_rx = 0;\n\tnp->cur_rx = RX_RING_SIZE;\n\tnp->rx_head_desc = &np->rx_ring[0];\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\tnp->rx_ring[i].cmd_status = cpu_to_le32(DescOwn);\n\n\trefill_rx(dev);\n}\n\nstatic void reinit_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\t \n\tdrain_tx(dev);\n\tnp->dirty_tx = np->cur_tx = 0;\n\tfor (i=0;i<TX_RING_SIZE;i++)\n\t\tnp->tx_ring[i].cmd_status = 0;\n\n\treinit_rx(dev);\n}\n\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tunsigned entry;\n\tunsigned long flags;\n\n\t \n\n\t \n\tentry = np->cur_tx % TX_RING_SIZE;\n\n\tnp->tx_skbuff[entry] = skb;\n\tnp->tx_dma[entry] = dma_map_single(&np->pci_dev->dev, skb->data,\n\t\t\t\t\t   skb->len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(&np->pci_dev->dev, np->tx_dma[entry])) {\n\t\tnp->tx_skbuff[entry] = NULL;\n\t\tdev_kfree_skb_irq(skb);\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tnp->tx_ring[entry].addr = cpu_to_le32(np->tx_dma[entry]);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tif (!np->hands_off) {\n\t\tnp->tx_ring[entry].cmd_status = cpu_to_le32(DescOwn | skb->len);\n\t\t \n\t\twmb();\n\t\tnp->cur_tx++;\n\t\tif (np->cur_tx - np->dirty_tx >= TX_QUEUE_LEN - 1) {\n\t\t\tnetdev_tx_done(dev);\n\t\t\tif (np->cur_tx - np->dirty_tx >= TX_QUEUE_LEN - 1)\n\t\t\t\tnetif_stop_queue(dev);\n\t\t}\n\t\t \n\t\twritel(TxOn, ioaddr + ChipCmd);\n\t} else {\n\t\tdev_kfree_skb_irq(skb);\n\t\tdev->stats.tx_dropped++;\n\t}\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tif (netif_msg_tx_queued(np)) {\n\t\tprintk(KERN_DEBUG \"%s: Transmit frame #%d queued in slot %d.\\n\",\n\t\t\tdev->name, np->cur_tx, entry);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic void netdev_tx_done(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tfor (; np->cur_tx - np->dirty_tx > 0; np->dirty_tx++) {\n\t\tint entry = np->dirty_tx % TX_RING_SIZE;\n\t\tif (np->tx_ring[entry].cmd_status & cpu_to_le32(DescOwn))\n\t\t\tbreak;\n\t\tif (netif_msg_tx_done(np))\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: tx frame #%d finished, status %#08x.\\n\",\n\t\t\t\t\tdev->name, np->dirty_tx,\n\t\t\t\t\tle32_to_cpu(np->tx_ring[entry].cmd_status));\n\t\tif (np->tx_ring[entry].cmd_status & cpu_to_le32(DescPktOK)) {\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += np->tx_skbuff[entry]->len;\n\t\t} else {  \n\t\t\tint tx_status =\n\t\t\t\tle32_to_cpu(np->tx_ring[entry].cmd_status);\n\t\t\tif (tx_status & (DescTxAbort|DescTxExcColl))\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tif (tx_status & DescTxFIFO)\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\tif (tx_status & DescTxCarrier)\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\tif (tx_status & DescTxOOWCol)\n\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\tdev->stats.tx_errors++;\n\t\t}\n\t\tdma_unmap_single(&np->pci_dev->dev, np->tx_dma[entry],\n\t\t\t\t np->tx_skbuff[entry]->len, DMA_TO_DEVICE);\n\t\t \n\t\tdev_consume_skb_irq(np->tx_skbuff[entry]);\n\t\tnp->tx_skbuff[entry] = NULL;\n\t}\n\tif (netif_queue_stopped(dev) &&\n\t    np->cur_tx - np->dirty_tx < TX_QUEUE_LEN - 4) {\n\t\t \n\t\tnetif_wake_queue(dev);\n\t}\n}\n\n \nstatic irqreturn_t intr_handler(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\t \n\tif (np->hands_off || !readl(ioaddr + IntrEnable))\n\t\treturn IRQ_NONE;\n\n\tnp->intr_status = readl(ioaddr + IntrStatus);\n\n\tif (!np->intr_status)\n\t\treturn IRQ_NONE;\n\n\tif (netif_msg_intr(np))\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: Interrupt, status %#08x, mask %#08x.\\n\",\n\t\t       dev->name, np->intr_status,\n\t\t       readl(ioaddr + IntrMask));\n\n\tprefetch(&np->rx_skbuff[np->cur_rx % RX_RING_SIZE]);\n\n\tif (napi_schedule_prep(&np->napi)) {\n\t\t \n\t\tnatsemi_irq_disable(dev);\n\t\t__napi_schedule(&np->napi);\n\t} else\n\t\tprintk(KERN_WARNING\n\t       \t       \"%s: Ignoring interrupt, status %#08x, mask %#08x.\\n\",\n\t\t       dev->name, np->intr_status,\n\t\t       readl(ioaddr + IntrMask));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int natsemi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct netdev_private *np = container_of(napi, struct netdev_private, napi);\n\tstruct net_device *dev = np->dev;\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tint work_done = 0;\n\n\tdo {\n\t\tif (netif_msg_intr(np))\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: Poll, status %#08x, mask %#08x.\\n\",\n\t\t\t       dev->name, np->intr_status,\n\t\t\t       readl(ioaddr + IntrMask));\n\n\t\t \n\t\tif (np->intr_status &\n\t\t    (IntrRxDone | IntrRxIntr | RxStatusFIFOOver |\n\t\t     IntrRxErr | IntrRxOverrun)) {\n\t\t\tnetdev_rx(dev, &work_done, budget);\n\t\t}\n\n\t\tif (np->intr_status &\n\t\t    (IntrTxDone | IntrTxIntr | IntrTxIdle | IntrTxErr)) {\n\t\t\tspin_lock(&np->lock);\n\t\t\tnetdev_tx_done(dev);\n\t\t\tspin_unlock(&np->lock);\n\t\t}\n\n\t\t \n\t\tif (np->intr_status & IntrAbnormalSummary)\n\t\t\tnetdev_error(dev, np->intr_status);\n\n\t\tif (work_done >= budget)\n\t\t\treturn work_done;\n\n\t\tnp->intr_status = readl(ioaddr + IntrStatus);\n\t} while (np->intr_status);\n\n\tnapi_complete_done(napi, work_done);\n\n\t \n\tspin_lock(&np->lock);\n\tif (!np->hands_off)\n\t\tnatsemi_irq_enable(dev);\n\tspin_unlock(&np->lock);\n\n\treturn work_done;\n}\n\n \nstatic void netdev_rx(struct net_device *dev, int *work_done, int work_to_do)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->cur_rx % RX_RING_SIZE;\n\tint boguscnt = np->dirty_rx + RX_RING_SIZE - np->cur_rx;\n\ts32 desc_status = le32_to_cpu(np->rx_head_desc->cmd_status);\n\tunsigned int buflen = np->rx_buf_sz;\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\t \n\twhile (desc_status < 0) {  \n\t\tint pkt_len;\n\t\tif (netif_msg_rx_status(np))\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"  netdev_rx() entry %d status was %#08x.\\n\",\n\t\t\t\tentry, desc_status);\n\t\tif (--boguscnt < 0)\n\t\t\tbreak;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\n\t\t(*work_done)++;\n\n\t\tpkt_len = (desc_status & DescSizeMask) - 4;\n\t\tif ((desc_status&(DescMore|DescPktOK|DescRxLong)) != DescPktOK){\n\t\t\tif (desc_status & DescMore) {\n\t\t\t\tunsigned long flags;\n\n\t\t\t\tif (netif_msg_rx_err(np))\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\t\"%s: Oversized(?) Ethernet \"\n\t\t\t\t\t\t\"frame spanned multiple \"\n\t\t\t\t\t\t\"buffers, entry %#08x \"\n\t\t\t\t\t\t\"status %#08x.\\n\", dev->name,\n\t\t\t\t\t\tnp->cur_rx, desc_status);\n\t\t\t\tdev->stats.rx_length_errors++;\n\n\t\t\t\t \n\n\t\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\t\treset_rx(dev);\n\t\t\t\treinit_rx(dev);\n\t\t\t\twritel(np->ring_dma, ioaddr + RxRingPtr);\n\t\t\t\tcheck_link(dev);\n\t\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tif (desc_status & (DescRxAbort|DescRxOver))\n\t\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\t\tif (desc_status & (DescRxLong|DescRxRunt))\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tif (desc_status & (DescRxInvalid|DescRxAlign))\n\t\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tif (desc_status & DescRxCRC)\n\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t}\n\t\t} else if (pkt_len > np->rx_buf_sz) {\n\t\t\t \n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\t\t\t \n\t\t\t \n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + RX_OFFSET)) != NULL) {\n\t\t\t\t \n\t\t\t\tskb_reserve(skb, RX_OFFSET);\n\t\t\t\tdma_sync_single_for_cpu(&np->pci_dev->dev,\n\t\t\t\t\t\t\tnp->rx_dma[entry],\n\t\t\t\t\t\t\tbuflen,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\tnp->rx_skbuff[entry]->data, pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\tdma_sync_single_for_device(&np->pci_dev->dev,\n\t\t\t\t\t\t\t   np->rx_dma[entry],\n\t\t\t\t\t\t\t   buflen,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t\t np->rx_dma[entry],\n\t\t\t\t\t\t buflen + NATSEMI_PADDING,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put(skb = np->rx_skbuff[entry], pkt_len);\n\t\t\t\tnp->rx_skbuff[entry] = NULL;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_receive_skb(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\t\tentry = (++np->cur_rx) % RX_RING_SIZE;\n\t\tnp->rx_head_desc = &np->rx_ring[entry];\n\t\tdesc_status = le32_to_cpu(np->rx_head_desc->cmd_status);\n\t}\n\trefill_rx(dev);\n\n\t \n\tif (np->oom)\n\t\tmod_timer(&np->timer, jiffies + 1);\n\telse\n\t\twritel(RxOn, ioaddr + ChipCmd);\n}\n\nstatic void netdev_error(struct net_device *dev, int intr_status)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\tspin_lock(&np->lock);\n\tif (intr_status & LinkChange) {\n\t\tu16 lpa = mdio_read(dev, MII_LPA);\n\t\tif (mdio_read(dev, MII_BMCR) & BMCR_ANENABLE &&\n\t\t    netif_msg_link(np)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"%s: Autonegotiation advertising\"\n\t\t\t\t\" %#04x  partner %#04x.\\n\", dev->name,\n\t\t\t\tnp->advertising, lpa);\n\t\t}\n\n\t\t \n\t\treadw(ioaddr + MIntrStatus);\n\t\tcheck_link(dev);\n\t}\n\tif (intr_status & StatsMax) {\n\t\t__get_stats(dev);\n\t}\n\tif (intr_status & IntrTxUnderrun) {\n\t\tif ((np->tx_config & TxDrthMask) < TX_DRTH_VAL_LIMIT) {\n\t\t\tnp->tx_config += TX_DRTH_VAL_INC;\n\t\t\tif (netif_msg_tx_err(np))\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\t\"%s: increased tx threshold, txcfg %#08x.\\n\",\n\t\t\t\t\tdev->name, np->tx_config);\n\t\t} else {\n\t\t\tif (netif_msg_tx_err(np))\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\t\"%s: tx underrun with maximum tx threshold, txcfg %#08x.\\n\",\n\t\t\t\t\tdev->name, np->tx_config);\n\t\t}\n\t\twritel(np->tx_config, ioaddr + TxConfig);\n\t}\n\tif (intr_status & WOLPkt && netif_msg_wol(np)) {\n\t\tint wol_status = readl(ioaddr + WOLCmd);\n\t\tprintk(KERN_NOTICE \"%s: Link wake-up event %#08x\\n\",\n\t\t\tdev->name, wol_status);\n\t}\n\tif (intr_status & RxStatusFIFOOver) {\n\t\tif (netif_msg_rx_err(np) && netif_msg_intr(np)) {\n\t\t\tprintk(KERN_NOTICE \"%s: Rx status FIFO overrun\\n\",\n\t\t\t\tdev->name);\n\t\t}\n\t\tdev->stats.rx_fifo_errors++;\n\t\tdev->stats.rx_errors++;\n\t}\n\t \n\tif (intr_status & IntrPCIErr) {\n\t\tprintk(KERN_NOTICE \"%s: PCI error %#08x\\n\", dev->name,\n\t\t\tintr_status & IntrPCIErr);\n\t\tdev->stats.tx_fifo_errors++;\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.rx_fifo_errors++;\n\t\tdev->stats.rx_errors++;\n\t}\n\tspin_unlock(&np->lock);\n}\n\nstatic void __get_stats(struct net_device *dev)\n{\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\t \n\tdev->stats.rx_crc_errors += readl(ioaddr + RxCRCErrs);\n\tdev->stats.rx_missed_errors += readl(ioaddr + RxMissed);\n}\n\nstatic struct net_device_stats *get_stats(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\t \n\tspin_lock_irq(&np->lock);\n\tif (netif_running(dev) && !np->hands_off)\n\t\t__get_stats(dev);\n\tspin_unlock_irq(&np->lock);\n\n\treturn &dev->stats;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void natsemi_poll_controller(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tconst int irq = np->pci_dev->irq;\n\n\tdisable_irq(irq);\n\tintr_handler(irq, dev);\n\tenable_irq(irq);\n}\n#endif\n\n#define HASH_TABLE\t0x200\nstatic void __set_rx_mode(struct net_device *dev)\n{\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu8 mc_filter[64];  \n\tu32 rx_mode;\n\n\tif (dev->flags & IFF_PROMISC) {  \n\t\trx_mode = RxFilterEnable | AcceptBroadcast\n\t\t\t| AcceptAllMulticast | AcceptAllPhys | AcceptMyPhys;\n\t} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\trx_mode = RxFilterEnable | AcceptBroadcast\n\t\t\t| AcceptAllMulticast | AcceptMyPhys;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i;\n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint b = (ether_crc(ETH_ALEN, ha->addr) >> 23) & 0x1ff;\n\t\t\tmc_filter[b/8] |= (1 << (b & 0x07));\n\t\t}\n\t\trx_mode = RxFilterEnable | AcceptBroadcast\n\t\t\t| AcceptMulticast | AcceptMyPhys;\n\t\tfor (i = 0; i < 64; i += 2) {\n\t\t\twritel(HASH_TABLE + i, ioaddr + RxFilterAddr);\n\t\t\twritel((mc_filter[i + 1] << 8) + mc_filter[i],\n\t\t\t       ioaddr + RxFilterData);\n\t\t}\n\t}\n\twritel(rx_mode, ioaddr + RxFilterAddr);\n\tnp->cur_rx_mode = rx_mode;\n}\n\nstatic int natsemi_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tdev->mtu = new_mtu;\n\n\t \n\tif (netif_running(dev)) {\n\t\tstruct netdev_private *np = netdev_priv(dev);\n\t\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\t\tconst int irq = np->pci_dev->irq;\n\n\t\tdisable_irq(irq);\n\t\tspin_lock(&np->lock);\n\t\t \n\t\tnatsemi_stop_rxtx(dev);\n\t\t \n\t\tdrain_rx(dev);\n\t\t \n\t\tset_bufsize(dev);\n\t\treinit_rx(dev);\n\t\twritel(np->ring_dma, ioaddr + RxRingPtr);\n\t\t \n\t\twritel(RxOn | TxOn, ioaddr + ChipCmd);\n\t\tspin_unlock(&np->lock);\n\t\tenable_irq(irq);\n\t}\n\treturn 0;\n}\n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tspin_lock_irq(&np->lock);\n\tif (!np->hands_off)\n\t\t__set_rx_mode(dev);\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int get_regs_len(struct net_device *dev)\n{\n\treturn NATSEMI_REGS_SIZE;\n}\n\nstatic int get_eeprom_len(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->eeprom_size;\n}\n\nstatic int get_link_ksettings(struct net_device *dev,\n\t\t\t      struct ethtool_link_ksettings *ecmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tspin_lock_irq(&np->lock);\n\tnetdev_get_ecmd(dev, ecmd);\n\tspin_unlock_irq(&np->lock);\n\treturn 0;\n}\n\nstatic int set_link_ksettings(struct net_device *dev,\n\t\t\t      const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint res;\n\tspin_lock_irq(&np->lock);\n\tres = netdev_set_ecmd(dev, ecmd);\n\tspin_unlock_irq(&np->lock);\n\treturn res;\n}\n\nstatic void get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tspin_lock_irq(&np->lock);\n\tnetdev_get_wol(dev, &wol->supported, &wol->wolopts);\n\tnetdev_get_sopass(dev, wol->sopass);\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic int set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint res;\n\tspin_lock_irq(&np->lock);\n\tnetdev_set_wol(dev, wol->wolopts);\n\tres = netdev_set_sopass(dev, wol->sopass);\n\tspin_unlock_irq(&np->lock);\n\treturn res;\n}\n\nstatic void get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tregs->version = NATSEMI_REGS_VER;\n\tspin_lock_irq(&np->lock);\n\tnetdev_get_regs(dev, buf);\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic u32 get_msglevel(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->msg_enable;\n}\n\nstatic void set_msglevel(struct net_device *dev, u32 val)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tnp->msg_enable = val;\n}\n\nstatic int nway_reset(struct net_device *dev)\n{\n\tint tmp;\n\tint r = -EINVAL;\n\t \n\ttmp = mdio_read(dev, MII_BMCR);\n\tif (tmp & BMCR_ANENABLE) {\n\t\ttmp |= (BMCR_ANRESTART);\n\t\tmdio_write(dev, MII_BMCR, tmp);\n\t\tr = 0;\n\t}\n\treturn r;\n}\n\nstatic u32 get_link(struct net_device *dev)\n{\n\t \n\tmdio_read(dev, MII_BMSR);\n\treturn (mdio_read(dev, MII_BMSR)&BMSR_LSTATUS) ? 1:0;\n}\n\nstatic int get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu8 *eebuf;\n\tint res;\n\n\teebuf = kmalloc(np->eeprom_size, GFP_KERNEL);\n\tif (!eebuf)\n\t\treturn -ENOMEM;\n\n\teeprom->magic = PCI_VENDOR_ID_NS | (PCI_DEVICE_ID_NS_83815<<16);\n\tspin_lock_irq(&np->lock);\n\tres = netdev_get_eeprom(dev, eebuf);\n\tspin_unlock_irq(&np->lock);\n\tif (!res)\n\t\tmemcpy(data, eebuf+eeprom->offset, eeprom->len);\n\tkfree(eebuf);\n\treturn res;\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.get_drvinfo = get_drvinfo,\n\t.get_regs_len = get_regs_len,\n\t.get_eeprom_len = get_eeprom_len,\n\t.get_wol = get_wol,\n\t.set_wol = set_wol,\n\t.get_regs = get_regs,\n\t.get_msglevel = get_msglevel,\n\t.set_msglevel = set_msglevel,\n\t.nway_reset = nway_reset,\n\t.get_link = get_link,\n\t.get_eeprom = get_eeprom,\n\t.get_link_ksettings = get_link_ksettings,\n\t.set_link_ksettings = set_link_ksettings,\n};\n\nstatic int netdev_set_wol(struct net_device *dev, u32 newval)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tu32 data = readl(ioaddr + WOLCmd) & ~WakeOptsSummary;\n\n\t \n\tif (newval & WAKE_PHY)\n\t\tdata |= WakePhy;\n\tif (newval & WAKE_UCAST)\n\t\tdata |= WakeUnicast;\n\tif (newval & WAKE_MCAST)\n\t\tdata |= WakeMulticast;\n\tif (newval & WAKE_BCAST)\n\t\tdata |= WakeBroadcast;\n\tif (newval & WAKE_ARP)\n\t\tdata |= WakeArp;\n\tif (newval & WAKE_MAGIC)\n\t\tdata |= WakeMagic;\n\tif (np->srr >= SRR_DP83815_D) {\n\t\tif (newval & WAKE_MAGICSECURE) {\n\t\t\tdata |= WakeMagicSecure;\n\t\t}\n\t}\n\n\twritel(data, ioaddr + WOLCmd);\n\n\treturn 0;\n}\n\nstatic int netdev_get_wol(struct net_device *dev, u32 *supported, u32 *cur)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tu32 regval = readl(ioaddr + WOLCmd);\n\n\t*supported = (WAKE_PHY | WAKE_UCAST | WAKE_MCAST | WAKE_BCAST\n\t\t\t| WAKE_ARP | WAKE_MAGIC);\n\n\tif (np->srr >= SRR_DP83815_D) {\n\t\t \n\t\t*supported |= WAKE_MAGICSECURE;\n\t}\n\t*cur = 0;\n\n\t \n\tif (regval & WakePhy)\n\t\t*cur |= WAKE_PHY;\n\tif (regval & WakeUnicast)\n\t\t*cur |= WAKE_UCAST;\n\tif (regval & WakeMulticast)\n\t\t*cur |= WAKE_MCAST;\n\tif (regval & WakeBroadcast)\n\t\t*cur |= WAKE_BCAST;\n\tif (regval & WakeArp)\n\t\t*cur |= WAKE_ARP;\n\tif (regval & WakeMagic)\n\t\t*cur |= WAKE_MAGIC;\n\tif (regval & WakeMagicSecure) {\n\t\t \n\t\t*cur |= WAKE_MAGICSECURE;\n\t}\n\n\treturn 0;\n}\n\nstatic int netdev_set_sopass(struct net_device *dev, u8 *newval)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tu16 *sval = (u16 *)newval;\n\tu32 addr;\n\n\tif (np->srr < SRR_DP83815_D) {\n\t\treturn 0;\n\t}\n\n\t \n\taddr = readl(ioaddr + RxFilterAddr) & ~RFCRAddressMask;\n\taddr &= ~RxFilterEnable;\n\twritel(addr, ioaddr + RxFilterAddr);\n\n\t \n\twritel(addr | 0xa, ioaddr + RxFilterAddr);\n\twritew(sval[0], ioaddr + RxFilterData);\n\n\twritel(addr | 0xc, ioaddr + RxFilterAddr);\n\twritew(sval[1], ioaddr + RxFilterData);\n\n\twritel(addr | 0xe, ioaddr + RxFilterAddr);\n\twritew(sval[2], ioaddr + RxFilterData);\n\n\t \n\twritel(addr | RxFilterEnable, ioaddr + RxFilterAddr);\n\n\treturn 0;\n}\n\nstatic int netdev_get_sopass(struct net_device *dev, u8 *data)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tu16 *sval = (u16 *)data;\n\tu32 addr;\n\n\tif (np->srr < SRR_DP83815_D) {\n\t\tsval[0] = sval[1] = sval[2] = 0;\n\t\treturn 0;\n\t}\n\n\t \n\taddr = readl(ioaddr + RxFilterAddr) & ~RFCRAddressMask;\n\n\twritel(addr | 0xa, ioaddr + RxFilterAddr);\n\tsval[0] = readw(ioaddr + RxFilterData);\n\n\twritel(addr | 0xc, ioaddr + RxFilterAddr);\n\tsval[1] = readw(ioaddr + RxFilterData);\n\n\twritel(addr | 0xe, ioaddr + RxFilterAddr);\n\tsval[2] = readw(ioaddr + RxFilterData);\n\n\twritel(addr, ioaddr + RxFilterAddr);\n\n\treturn 0;\n}\n\nstatic int netdev_get_ecmd(struct net_device *dev,\n\t\t\t   struct ethtool_link_ksettings *ecmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu32 supported, advertising;\n\tu32 tmp;\n\n\tecmd->base.port   = dev->if_port;\n\tecmd->base.speed  = np->speed;\n\tecmd->base.duplex = np->duplex;\n\tecmd->base.autoneg = np->autoneg;\n\tadvertising = 0;\n\n\tif (np->advertising & ADVERTISE_10HALF)\n\t\tadvertising |= ADVERTISED_10baseT_Half;\n\tif (np->advertising & ADVERTISE_10FULL)\n\t\tadvertising |= ADVERTISED_10baseT_Full;\n\tif (np->advertising & ADVERTISE_100HALF)\n\t\tadvertising |= ADVERTISED_100baseT_Half;\n\tif (np->advertising & ADVERTISE_100FULL)\n\t\tadvertising |= ADVERTISED_100baseT_Full;\n\tsupported   = (SUPPORTED_Autoneg |\n\t\tSUPPORTED_10baseT_Half  | SUPPORTED_10baseT_Full  |\n\t\tSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\n\t\tSUPPORTED_TP | SUPPORTED_MII | SUPPORTED_FIBRE);\n\tecmd->base.phy_address = np->phy_addr_external;\n\t \n\n\t \n\tswitch (ecmd->base.port) {\n\tdefault:\n\tcase PORT_TP:\n\t\tadvertising |= ADVERTISED_TP;\n\t\tbreak;\n\tcase PORT_MII:\n\t\tadvertising |= ADVERTISED_MII;\n\t\tbreak;\n\tcase PORT_FIBRE:\n\t\tadvertising |= ADVERTISED_FIBRE;\n\t\tbreak;\n\t}\n\n\t \n\tif (ecmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tadvertising |= ADVERTISED_Autoneg;\n\t\ttmp = mii_nway_result(\n\t\t\tnp->advertising & mdio_read(dev, MII_LPA));\n\t\tif (tmp == LPA_100FULL || tmp == LPA_100HALF)\n\t\t\tecmd->base.speed = SPEED_100;\n\t\telse\n\t\t\tecmd->base.speed = SPEED_10;\n\t\tif (tmp == LPA_100FULL || tmp == LPA_10FULL)\n\t\t\tecmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tecmd->base.duplex = DUPLEX_HALF;\n\t}\n\n\t \n\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int netdev_set_ecmd(struct net_device *dev,\n\t\t\t   const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tecmd->link_modes.advertising);\n\n\tif (ecmd->base.port != PORT_TP &&\n\t    ecmd->base.port != PORT_MII &&\n\t    ecmd->base.port != PORT_FIBRE)\n\t\treturn -EINVAL;\n\tif (ecmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tif ((advertising & (ADVERTISED_10baseT_Half |\n\t\t\t\t\t  ADVERTISED_10baseT_Full |\n\t\t\t\t\t  ADVERTISED_100baseT_Half |\n\t\t\t\t\t  ADVERTISED_100baseT_Full)) == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ecmd->base.autoneg == AUTONEG_DISABLE) {\n\t\tu32 speed = ecmd->base.speed;\n\t\tif (speed != SPEED_10 && speed != SPEED_100)\n\t\t\treturn -EINVAL;\n\t\tif (ecmd->base.duplex != DUPLEX_HALF &&\n\t\t    ecmd->base.duplex != DUPLEX_FULL)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (np->ignore_phy && (ecmd->base.autoneg == AUTONEG_ENABLE ||\n\t\t\t       ecmd->base.port == PORT_TP))\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\n\t \n\tdev->if_port          = ecmd->base.port;\n\tnp->autoneg           = ecmd->base.autoneg;\n\tnp->phy_addr_external = ecmd->base.phy_address & PhyAddrMask;\n\tif (np->autoneg == AUTONEG_ENABLE) {\n\t\t \n\t\tnp->advertising &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);\n\t\tif (advertising & ADVERTISED_10baseT_Half)\n\t\t\tnp->advertising |= ADVERTISE_10HALF;\n\t\tif (advertising & ADVERTISED_10baseT_Full)\n\t\t\tnp->advertising |= ADVERTISE_10FULL;\n\t\tif (advertising & ADVERTISED_100baseT_Half)\n\t\t\tnp->advertising |= ADVERTISE_100HALF;\n\t\tif (advertising & ADVERTISED_100baseT_Full)\n\t\t\tnp->advertising |= ADVERTISE_100FULL;\n\t} else {\n\t\tnp->speed  = ecmd->base.speed;\n\t\tnp->duplex = ecmd->base.duplex;\n\t\t \n\t\tif (np->duplex == DUPLEX_HALF)\n\t\t\tnp->full_duplex = 0;\n\t}\n\n\t \n\tif (ecmd->base.port == PORT_TP)\n\t\tswitch_port_internal(dev);\n\telse\n\t\tswitch_port_external(dev);\n\n\t \n\tinit_phy_fixup(dev);\n\tcheck_link(dev);\n\treturn 0;\n}\n\nstatic int netdev_get_regs(struct net_device *dev, u8 *buf)\n{\n\tint i;\n\tint j;\n\tu32 rfcr;\n\tu32 *rbuf = (u32 *)buf;\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\t \n\tfor (i = 0; i < NATSEMI_PG0_NREGS/2; i++) {\n\t\trbuf[i] = readl(ioaddr + i*4);\n\t}\n\n\t \n\tfor (i = NATSEMI_PG0_NREGS/2; i < NATSEMI_PG0_NREGS; i++)\n\t\trbuf[i] = mdio_read(dev, i & 0x1f);\n\n\t \n\twritew(1, ioaddr + PGSEL);\n\trbuf[i++] = readw(ioaddr + PMDCSR);\n\trbuf[i++] = readw(ioaddr + TSTDAT);\n\trbuf[i++] = readw(ioaddr + DSPCFG);\n\trbuf[i++] = readw(ioaddr + SDCFG);\n\twritew(0, ioaddr + PGSEL);\n\n\t \n\trfcr = readl(ioaddr + RxFilterAddr);\n\tfor (j = 0; j < NATSEMI_RFDR_NREGS; j++) {\n\t\twritel(j*2, ioaddr + RxFilterAddr);\n\t\trbuf[i++] = readw(ioaddr + RxFilterData);\n\t}\n\twritel(rfcr, ioaddr + RxFilterAddr);\n\n\t \n\tif (rbuf[4] & rbuf[5]) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: shoot, we dropped an interrupt (%#08x)\\n\",\n\t\t\tdev->name, rbuf[4] & rbuf[5]);\n\t}\n\n\treturn 0;\n}\n\n#define SWAP_BITS(x)\t( (((x) & 0x0001) << 15) | (((x) & 0x0002) << 13) \\\n\t\t\t| (((x) & 0x0004) << 11) | (((x) & 0x0008) << 9)  \\\n\t\t\t| (((x) & 0x0010) << 7)  | (((x) & 0x0020) << 5)  \\\n\t\t\t| (((x) & 0x0040) << 3)  | (((x) & 0x0080) << 1)  \\\n\t\t\t| (((x) & 0x0100) >> 1)  | (((x) & 0x0200) >> 3)  \\\n\t\t\t| (((x) & 0x0400) >> 5)  | (((x) & 0x0800) >> 7)  \\\n\t\t\t| (((x) & 0x1000) >> 9)  | (((x) & 0x2000) >> 11) \\\n\t\t\t| (((x) & 0x4000) >> 13) | (((x) & 0x8000) >> 15) )\n\nstatic int netdev_get_eeprom(struct net_device *dev, u8 *buf)\n{\n\tint i;\n\tu16 *ebuf = (u16 *)buf;\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\t \n\tfor (i = 0; i < np->eeprom_size/2; i++) {\n\t\tebuf[i] = eeprom_read(ioaddr, i);\n\t\t \n\t\tebuf[i] = SWAP_BITS(ebuf[i]);\n\t}\n\treturn 0;\n}\n\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tswitch(cmd) {\n\tcase SIOCGMIIPHY:\t\t \n\t\tdata->phy_id = np->phy_addr_external;\n\t\tfallthrough;\n\n\tcase SIOCGMIIREG:\t\t \n\t\t \n\t\tif (dev->if_port == PORT_TP) {\n\t\t\tif ((data->phy_id & 0x1f) == np->phy_addr_external)\n\t\t\t\tdata->val_out = mdio_read(dev,\n\t\t\t\t\t\t\tdata->reg_num & 0x1f);\n\t\t\telse\n\t\t\t\tdata->val_out = 0;\n\t\t} else {\n\t\t\tmove_int_phy(dev, data->phy_id & 0x1f);\n\t\t\tdata->val_out = miiport_read(dev, data->phy_id & 0x1f,\n\t\t\t\t\t\t\tdata->reg_num & 0x1f);\n\t\t}\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\t\t \n\t\tif (dev->if_port == PORT_TP) {\n\t\t\tif ((data->phy_id & 0x1f) == np->phy_addr_external) {\n\t\t\t\tif ((data->reg_num & 0x1f) == MII_ADVERTISE)\n\t\t\t\t\tnp->advertising = data->val_in;\n\t\t\t\tmdio_write(dev, data->reg_num & 0x1f,\n\t\t\t\t\t\t\tdata->val_in);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((data->phy_id & 0x1f) == np->phy_addr_external) {\n\t\t\t\tif ((data->reg_num & 0x1f) == MII_ADVERTISE)\n\t\t\t\t\tnp->advertising = data->val_in;\n\t\t\t}\n\t\t\tmove_int_phy(dev, data->phy_id & 0x1f);\n\t\t\tmiiport_write(dev, data->phy_id & 0x1f,\n\t\t\t\t\t\tdata->reg_num & 0x1f,\n\t\t\t\t\t\tdata->val_in);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void enable_wol_mode(struct net_device *dev, int enable_intr)\n{\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tif (netif_msg_wol(np))\n\t\tprintk(KERN_INFO \"%s: remaining active for wake-on-lan\\n\",\n\t\t\tdev->name);\n\n\t \n\twritel(0, ioaddr + RxRingPtr);\n\n\t \n\treadl(ioaddr + WOLCmd);\n\n\t \n\twritel(np->SavedClkRun | PMEEnable | PMEStatus, ioaddr + ClkRun);\n\n\t \n\twritel(RxOn, ioaddr + ChipCmd);\n\n\tif (enable_intr) {\n\t\t \n\t\twritel(WOLPkt | LinkChange, ioaddr + IntrMask);\n\t\tnatsemi_irq_enable(dev);\n\t}\n}\n\nstatic int netdev_close(struct net_device *dev)\n{\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\tstruct netdev_private *np = netdev_priv(dev);\n\tconst int irq = np->pci_dev->irq;\n\n\tif (netif_msg_ifdown(np))\n\t\tprintk(KERN_DEBUG\n\t\t\t\"%s: Shutting down ethercard, status was %#04x.\\n\",\n\t\t\tdev->name, (int)readl(ioaddr + ChipCmd));\n\tif (netif_msg_pktdata(np))\n\t\tprintk(KERN_DEBUG\n\t\t\t\"%s: Queue pointers were Tx %d / %d,  Rx %d / %d.\\n\",\n\t\t\tdev->name, np->cur_tx, np->dirty_tx,\n\t\t\tnp->cur_rx, np->dirty_rx);\n\n\tnapi_disable(&np->napi);\n\n\t \n\n\tdel_timer_sync(&np->timer);\n\tdisable_irq(irq);\n\tspin_lock_irq(&np->lock);\n\tnatsemi_irq_disable(dev);\n\tnp->hands_off = 1;\n\tspin_unlock_irq(&np->lock);\n\tenable_irq(irq);\n\n\tfree_irq(irq, dev);\n\n\t \n\tspin_lock_irq(&np->lock);\n\tnp->hands_off = 0;\n\treadl(ioaddr + IntrMask);\n\treadw(ioaddr + MIntrStatus);\n\n\t \n\twritel(StatsFreeze, ioaddr + StatsCtrl);\n\n\t \n\tnatsemi_stop_rxtx(dev);\n\n\t__get_stats(dev);\n\tspin_unlock_irq(&np->lock);\n\n\t \n\tnetif_carrier_off(dev);\n\tnetif_stop_queue(dev);\n\n\tdump_ring(dev);\n\tdrain_ring(dev);\n\tfree_ring(dev);\n\n\t{\n\t\tu32 wol = readl(ioaddr + WOLCmd) & WakeOptsSummary;\n\t\tif (wol) {\n\t\t\t \n\t\t\tenable_wol_mode(dev, 0);\n\t\t} else {\n\t\t\t \n\t\t\twritel(np->SavedClkRun, ioaddr + ClkRun);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic void natsemi_remove1(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\tNATSEMI_REMOVE_FILE(pdev, dspcfg_workaround);\n\tunregister_netdev (dev);\n\tiounmap(ioaddr);\n\tfree_netdev (dev);\n}\n\n \n\nstatic int __maybe_unused natsemi_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem * ioaddr = ns_ioaddr(dev);\n\n\trtnl_lock();\n\tif (netif_running (dev)) {\n\t\tconst int irq = np->pci_dev->irq;\n\n\t\tdel_timer_sync(&np->timer);\n\n\t\tdisable_irq(irq);\n\t\tspin_lock_irq(&np->lock);\n\n\t\tnatsemi_irq_disable(dev);\n\t\tnp->hands_off = 1;\n\t\tnatsemi_stop_rxtx(dev);\n\t\tnetif_stop_queue(dev);\n\n\t\tspin_unlock_irq(&np->lock);\n\t\tenable_irq(irq);\n\n\t\tnapi_disable(&np->napi);\n\n\t\t \n\t\t__get_stats(dev);\n\n\t\t \n\t\tdrain_ring(dev);\n\t\t{\n\t\t\tu32 wol = readl(ioaddr + WOLCmd) & WakeOptsSummary;\n\t\t\t \n\t\t\tif (wol) {\n\t\t\t\t \n\t\t\t\tenable_wol_mode(dev, 0);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twritel(np->SavedClkRun, ioaddr + ClkRun);\n\t\t\t}\n\t\t}\n\t}\n\tnetif_device_detach(dev);\n\trtnl_unlock();\n\treturn 0;\n}\n\n\nstatic int __maybe_unused natsemi_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\trtnl_lock();\n\tif (netif_device_present(dev))\n\t\tgoto out;\n\tif (netif_running(dev)) {\n\t\tconst int irq = np->pci_dev->irq;\n\n\t\tBUG_ON(!np->hands_off);\n\t \n\n\t\tnapi_enable(&np->napi);\n\n\t\tnatsemi_reset(dev);\n\t\tinit_ring(dev);\n\t\tdisable_irq(irq);\n\t\tspin_lock_irq(&np->lock);\n\t\tnp->hands_off = 0;\n\t\tinit_registers(dev);\n\t\tnetif_device_attach(dev);\n\t\tspin_unlock_irq(&np->lock);\n\t\tenable_irq(irq);\n\n\t\tmod_timer(&np->timer, round_jiffies(jiffies + 1*HZ));\n\t}\n\tnetif_device_attach(dev);\nout:\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(natsemi_pm_ops, natsemi_suspend, natsemi_resume);\n\nstatic struct pci_driver natsemi_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= natsemi_pci_tbl,\n\t.probe\t\t= natsemi_probe1,\n\t.remove\t\t= natsemi_remove1,\n\t.driver.pm\t= &natsemi_pm_ops,\n};\n\nstatic int __init natsemi_init_mod (void)\n{\n \n#ifdef MODULE\n\tprintk(version);\n#endif\n\n\treturn pci_register_driver(&natsemi_driver);\n}\n\nstatic void __exit natsemi_exit_mod (void)\n{\n\tpci_unregister_driver (&natsemi_driver);\n}\n\nmodule_init(natsemi_init_mod);\nmodule_exit(natsemi_exit_mod);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}