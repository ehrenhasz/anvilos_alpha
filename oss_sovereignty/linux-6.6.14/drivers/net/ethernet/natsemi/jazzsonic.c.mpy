{
  "module_name": "jazzsonic.c",
  "hash_id": "16f09b061f9d8636f6621fa952bead98fbc3affb616640e16a7bc2130bacdb4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/natsemi/jazzsonic.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/pgtable.h>\n\n#include <asm/bootinfo.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/jazz.h>\n#include <asm/jazzdma.h>\n\nstatic char jazz_sonic_string[] = \"jazzsonic\";\n\n#define SONIC_MEM_SIZE\t0x100\n\n#include \"sonic.h\"\n\n \n#define SONIC_READ(reg) (*((volatile unsigned int *)dev->base_addr+reg))\n\n#define SONIC_WRITE(reg,val)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t*((volatile unsigned int *)dev->base_addr+(reg)) = (val);\t\t\\\n} while (0)\n\n \nstatic unsigned short known_revisions[] =\n{\n\t0x04,\t\t\t \n\t0xffff\t\t\t \n};\n\nstatic int jazzsonic_open(struct net_device* dev)\n{\n\tint retval;\n\n\tretval = request_irq(dev->irq, sonic_interrupt, 0, \"sonic\", dev);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d.\\n\",\n\t\t\t\tdev->name, dev->irq);\n\t\treturn retval;\n\t}\n\n\tretval = sonic_open(dev);\n\tif (retval)\n\t\tfree_irq(dev->irq, dev);\n\treturn retval;\n}\n\nstatic int jazzsonic_close(struct net_device* dev)\n{\n\tint err;\n\terr = sonic_close(dev);\n\tfree_irq(dev->irq, dev);\n\treturn err;\n}\n\nstatic const struct net_device_ops sonic_netdev_ops = {\n\t.ndo_open\t\t= jazzsonic_open,\n\t.ndo_stop\t\t= jazzsonic_close,\n\t.ndo_start_xmit\t\t= sonic_send_packet,\n\t.ndo_get_stats\t\t= sonic_get_stats,\n\t.ndo_set_rx_mode\t= sonic_multicast_list,\n\t.ndo_tx_timeout\t\t= sonic_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int sonic_probe1(struct net_device *dev)\n{\n\tunsigned int silicon_revision;\n\tunsigned int val;\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tint err = -ENODEV;\n\tint i;\n\tunsigned char addr[ETH_ALEN];\n\n\tif (!request_mem_region(dev->base_addr, SONIC_MEM_SIZE, jazz_sonic_string))\n\t\treturn -EBUSY;\n\n\t \n\tsilicon_revision = SONIC_READ(SONIC_SR);\n\ti = 0;\n\twhile (known_revisions[i] != 0xffff &&\n\t       known_revisions[i] != silicon_revision)\n\t\ti++;\n\n\tif (known_revisions[i] == 0xffff) {\n\t\tpr_info(\"SONIC ethernet controller not found (0x%4x)\\n\",\n\t\t\tsilicon_revision);\n\t\tgoto out;\n\t}\n\n\t \n\tSONIC_WRITE(SONIC_CMD,SONIC_CR_RST);\n\tSONIC_WRITE(SONIC_CEP,0);\n\tfor (i=0; i<3; i++) {\n\t\tval = SONIC_READ(SONIC_CAP0-i);\n\t\taddr[i*2] = val;\n\t\taddr[i*2+1] = val >> 8;\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\tlp->dma_bitmode = SONIC_BITMODE32;\n\n\terr = sonic_alloc_descriptors(dev);\n\tif (err)\n\t\tgoto out;\n\n\tdev->netdev_ops = &sonic_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\t \n\tSONIC_WRITE(SONIC_CRCT,0xffff);\n\tSONIC_WRITE(SONIC_FAET,0xffff);\n\tSONIC_WRITE(SONIC_MPT,0xffff);\n\n\treturn 0;\nout:\n\trelease_mem_region(dev->base_addr, SONIC_MEM_SIZE);\n\treturn err;\n}\n\n \nstatic int jazz_sonic_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct sonic_local *lp;\n\tstruct resource *res;\n\tint err = 0;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tdev = alloc_etherdev(sizeof(struct sonic_local));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tlp = netdev_priv(dev);\n\tlp->device = &pdev->dev;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->base_addr = res->start;\n\tdev->irq = platform_get_irq(pdev, 0);\n\terr = sonic_probe1(dev);\n\tif (err)\n\t\tgoto out;\n\n\tpr_info(\"SONIC ethernet @%08lx, MAC %pM, IRQ %d\\n\",\n\t\tdev->base_addr, dev->dev_addr, dev->irq);\n\n\tsonic_msg_init(dev);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto undo_probe1;\n\n\treturn 0;\n\nundo_probe1:\n\tdma_free_coherent(lp->device, SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t\t\t  lp->descriptors, lp->descriptors_laddr);\n\trelease_mem_region(dev->base_addr, SONIC_MEM_SIZE);\nout:\n\tfree_netdev(dev);\n\n\treturn err;\n}\n\nMODULE_DESCRIPTION(\"Jazz SONIC ethernet driver\");\nMODULE_ALIAS(\"platform:jazzsonic\");\n\n#include \"sonic.c\"\n\nstatic int jazz_sonic_device_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct sonic_local* lp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tdma_free_coherent(lp->device, SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t                  lp->descriptors, lp->descriptors_laddr);\n\trelease_mem_region(dev->base_addr, SONIC_MEM_SIZE);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver jazz_sonic_driver = {\n\t.probe\t= jazz_sonic_probe,\n\t.remove\t= jazz_sonic_device_remove,\n\t.driver\t= {\n\t\t.name\t= jazz_sonic_string,\n\t},\n};\n\nmodule_platform_driver(jazz_sonic_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}