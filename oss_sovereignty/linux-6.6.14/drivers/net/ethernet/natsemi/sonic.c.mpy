{
  "module_name": "sonic.c",
  "hash_id": "cff072b8d338da3ecedb9466195adb35c02e6545332179d74bac939284e0a16a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/natsemi/sonic.c",
  "human_readable_source": "\n \n\n \n\nstatic unsigned int version_printed;\n\nstatic int sonic_debug = -1;\nmodule_param(sonic_debug, int, 0);\nMODULE_PARM_DESC(sonic_debug, \"debug message level\");\n\nstatic void sonic_msg_init(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\n\tlp->msg_enable = netif_msg_init(sonic_debug, 0);\n\n\tif (version_printed++ == 0)\n\t\tnetif_dbg(lp, drv, dev, \"%s\", version);\n}\n\nstatic int sonic_alloc_descriptors(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\n\t \n\tlp->descriptors =\n\t\tdma_alloc_coherent(lp->device,\n\t\t\t\t   SIZEOF_SONIC_DESC *\n\t\t\t\t   SONIC_BUS_SCALE(lp->dma_bitmode),\n\t\t\t\t   &lp->descriptors_laddr, GFP_KERNEL);\n\n\tif (!lp->descriptors)\n\t\treturn -ENOMEM;\n\n\tlp->cda = lp->descriptors;\n\tlp->tda = lp->cda + SIZEOF_SONIC_CDA *\n\t\t\t    SONIC_BUS_SCALE(lp->dma_bitmode);\n\tlp->rda = lp->tda + SIZEOF_SONIC_TD * SONIC_NUM_TDS *\n\t\t\t    SONIC_BUS_SCALE(lp->dma_bitmode);\n\tlp->rra = lp->rda + SIZEOF_SONIC_RD * SONIC_NUM_RDS *\n\t\t\t    SONIC_BUS_SCALE(lp->dma_bitmode);\n\n\tlp->cda_laddr = lp->descriptors_laddr;\n\tlp->tda_laddr = lp->cda_laddr + SIZEOF_SONIC_CDA *\n\t\t\t\t\tSONIC_BUS_SCALE(lp->dma_bitmode);\n\tlp->rda_laddr = lp->tda_laddr + SIZEOF_SONIC_TD * SONIC_NUM_TDS *\n\t\t\t\t\tSONIC_BUS_SCALE(lp->dma_bitmode);\n\tlp->rra_laddr = lp->rda_laddr + SIZEOF_SONIC_RD * SONIC_NUM_RDS *\n\t\t\t\t\tSONIC_BUS_SCALE(lp->dma_bitmode);\n\n\treturn 0;\n}\n\n \nstatic int sonic_open(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tint i;\n\n\tnetif_dbg(lp, ifup, dev, \"%s: initializing sonic driver\\n\", __func__);\n\n\tspin_lock_init(&lp->lock);\n\n\tfor (i = 0; i < SONIC_NUM_RRS; i++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, SONIC_RBSIZE + 2);\n\t\tif (skb == NULL) {\n\t\t\twhile(i > 0) {  \n\t\t\t\ti--;\n\t\t\t\tdev_kfree_skb(lp->rx_skb[i]);\n\t\t\t\tlp->rx_skb[i] = NULL;\n\t\t\t}\n\t\t\tprintk(KERN_ERR \"%s: couldn't allocate receive buffers\\n\",\n\t\t\t       dev->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tif (SONIC_BUS_SCALE(lp->dma_bitmode) == 2)\n\t\t\tskb_reserve(skb, 2);\n\t\tlp->rx_skb[i] = skb;\n\t}\n\n\tfor (i = 0; i < SONIC_NUM_RRS; i++) {\n\t\tdma_addr_t laddr = dma_map_single(lp->device, skb_put(lp->rx_skb[i], SONIC_RBSIZE),\n\t\t                                  SONIC_RBSIZE, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(lp->device, laddr)) {\n\t\t\twhile(i > 0) {  \n\t\t\t\ti--;\n\t\t\t\tdma_unmap_single(lp->device, lp->rx_laddr[i], SONIC_RBSIZE, DMA_FROM_DEVICE);\n\t\t\t\tlp->rx_laddr[i] = (dma_addr_t)0;\n\t\t\t}\n\t\t\tfor (i = 0; i < SONIC_NUM_RRS; i++) {\n\t\t\t\tdev_kfree_skb(lp->rx_skb[i]);\n\t\t\t\tlp->rx_skb[i] = NULL;\n\t\t\t}\n\t\t\tprintk(KERN_ERR \"%s: couldn't map rx DMA buffers\\n\",\n\t\t\t       dev->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlp->rx_laddr[i] = laddr;\n\t}\n\n\t \n\tsonic_init(dev, true);\n\n\tnetif_start_queue(dev);\n\n\tnetif_dbg(lp, ifup, dev, \"%s: Initialization done\\n\", __func__);\n\n\treturn 0;\n}\n\n \nstatic void sonic_quiesce(struct net_device *dev, u16 mask, bool may_sleep)\n{\n\tstruct sonic_local * __maybe_unused lp = netdev_priv(dev);\n\tint i;\n\tu16 bits;\n\n\tfor (i = 0; i < 1000; ++i) {\n\t\tbits = SONIC_READ(SONIC_CMD) & mask;\n\t\tif (!bits)\n\t\t\treturn;\n\t\tif (!may_sleep)\n\t\t\tudelay(20);\n\t\telse\n\t\t\tusleep_range(100, 200);\n\t}\n\tWARN_ONCE(1, \"command deadline expired! 0x%04x\\n\", bits);\n}\n\n \nstatic int sonic_close(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tint i;\n\n\tnetif_dbg(lp, ifdown, dev, \"%s\\n\", __func__);\n\n\tnetif_stop_queue(dev);\n\n\t \n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RXDIS);\n\tsonic_quiesce(dev, SONIC_CR_ALL, true);\n\n\tSONIC_WRITE(SONIC_IMR, 0);\n\tSONIC_WRITE(SONIC_ISR, 0x7fff);\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\n\n\t \n\tfor (i = 0; i < SONIC_NUM_TDS; i++) {\n\t\tif(lp->tx_laddr[i]) {\n\t\t\tdma_unmap_single(lp->device, lp->tx_laddr[i], lp->tx_len[i], DMA_TO_DEVICE);\n\t\t\tlp->tx_laddr[i] = (dma_addr_t)0;\n\t\t}\n\t\tif(lp->tx_skb[i]) {\n\t\t\tdev_kfree_skb(lp->tx_skb[i]);\n\t\t\tlp->tx_skb[i] = NULL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < SONIC_NUM_RRS; i++) {\n\t\tif(lp->rx_laddr[i]) {\n\t\t\tdma_unmap_single(lp->device, lp->rx_laddr[i], SONIC_RBSIZE, DMA_FROM_DEVICE);\n\t\t\tlp->rx_laddr[i] = (dma_addr_t)0;\n\t\t}\n\t\tif(lp->rx_skb[i]) {\n\t\t\tdev_kfree_skb(lp->rx_skb[i]);\n\t\t\tlp->rx_skb[i] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sonic_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tint i;\n\t \n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RXDIS);\n\tsonic_quiesce(dev, SONIC_CR_ALL, false);\n\n\tSONIC_WRITE(SONIC_IMR, 0);\n\tSONIC_WRITE(SONIC_ISR, 0x7fff);\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\n\t \n\tfor (i = 0; i < SONIC_NUM_TDS; i++) {\n\t\tif(lp->tx_laddr[i]) {\n\t\t\tdma_unmap_single(lp->device, lp->tx_laddr[i], lp->tx_len[i], DMA_TO_DEVICE);\n\t\t\tlp->tx_laddr[i] = (dma_addr_t)0;\n\t\t}\n\t\tif(lp->tx_skb[i]) {\n\t\t\tdev_kfree_skb(lp->tx_skb[i]);\n\t\t\tlp->tx_skb[i] = NULL;\n\t\t}\n\t}\n\t \n\tsonic_init(dev, false);\n\tlp->stats.tx_errors++;\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\n \n\nstatic int sonic_send_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tdma_addr_t laddr;\n\tint length;\n\tint entry;\n\tunsigned long flags;\n\n\tnetif_dbg(lp, tx_queued, dev, \"%s: skb=%p\\n\", __func__, skb);\n\n\tlength = skb->len;\n\tif (length < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\treturn NETDEV_TX_OK;\n\t\tlength = ETH_ZLEN;\n\t}\n\n\t \n\n\tladdr = dma_map_single(lp->device, skb->data, length, DMA_TO_DEVICE);\n\tif (dma_mapping_error(lp->device, laddr)) {\n\t\tpr_err_ratelimited(\"%s: failed to map tx DMA buffer.\\n\", dev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tentry = (lp->eol_tx + 1) & SONIC_TDS_MASK;\n\n\tsonic_tda_put(dev, entry, SONIC_TD_STATUS, 0);        \n\tsonic_tda_put(dev, entry, SONIC_TD_FRAG_COUNT, 1);    \n\tsonic_tda_put(dev, entry, SONIC_TD_PKTSIZE, length);  \n\tsonic_tda_put(dev, entry, SONIC_TD_FRAG_PTR_L, laddr & 0xffff);\n\tsonic_tda_put(dev, entry, SONIC_TD_FRAG_PTR_H, laddr >> 16);\n\tsonic_tda_put(dev, entry, SONIC_TD_FRAG_SIZE, length);\n\tsonic_tda_put(dev, entry, SONIC_TD_LINK,\n\t\tsonic_tda_get(dev, entry, SONIC_TD_LINK) | SONIC_EOL);\n\n\tsonic_tda_put(dev, lp->eol_tx, SONIC_TD_LINK, ~SONIC_EOL &\n\t\t      sonic_tda_get(dev, lp->eol_tx, SONIC_TD_LINK));\n\n\tnetif_dbg(lp, tx_queued, dev, \"%s: issuing Tx command\\n\", __func__);\n\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_TXP);\n\n\tlp->tx_len[entry] = length;\n\tlp->tx_laddr[entry] = laddr;\n\tlp->tx_skb[entry] = skb;\n\n\tlp->eol_tx = entry;\n\n\tentry = (entry + 1) & SONIC_TDS_MASK;\n\tif (lp->tx_skb[entry]) {\n\t\t \n\t\tnetif_dbg(lp, tx_queued, dev, \"%s: stopping queue\\n\", __func__);\n\t\tnetif_stop_queue(dev);\n\t\t \n\t}\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t sonic_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tint status;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tstatus = SONIC_READ(SONIC_ISR) & SONIC_IMR_DEFAULT;\n\tif (!status) {\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\t\treturn IRQ_NONE;\n\t}\n\n\tdo {\n\t\tSONIC_WRITE(SONIC_ISR, status);  \n\n\t\tif (status & SONIC_INT_PKTRX) {\n\t\t\tnetif_dbg(lp, intr, dev, \"%s: packet rx\\n\", __func__);\n\t\t\tsonic_rx(dev);\t \n\t\t}\n\n\t\tif (status & SONIC_INT_TXDN) {\n\t\t\tint entry = lp->cur_tx;\n\t\t\tint td_status;\n\t\t\tint freed_some = 0;\n\n\t\t\t \n\n\t\t\tnetif_dbg(lp, intr, dev, \"%s: tx done\\n\", __func__);\n\n\t\t\twhile (lp->tx_skb[entry] != NULL) {\n\t\t\t\tif ((td_status = sonic_tda_get(dev, entry, SONIC_TD_STATUS)) == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (td_status & SONIC_TCR_PTX) {\n\t\t\t\t\tlp->stats.tx_packets++;\n\t\t\t\t\tlp->stats.tx_bytes += sonic_tda_get(dev, entry, SONIC_TD_PKTSIZE);\n\t\t\t\t} else {\n\t\t\t\t\tif (td_status & (SONIC_TCR_EXD |\n\t\t\t\t\t    SONIC_TCR_EXC | SONIC_TCR_BCM))\n\t\t\t\t\t\tlp->stats.tx_aborted_errors++;\n\t\t\t\t\tif (td_status &\n\t\t\t\t\t    (SONIC_TCR_NCRS | SONIC_TCR_CRLS))\n\t\t\t\t\t\tlp->stats.tx_carrier_errors++;\n\t\t\t\t\tif (td_status & SONIC_TCR_OWC)\n\t\t\t\t\t\tlp->stats.tx_window_errors++;\n\t\t\t\t\tif (td_status & SONIC_TCR_FU)\n\t\t\t\t\t\tlp->stats.tx_fifo_errors++;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tdev_consume_skb_irq(lp->tx_skb[entry]);\n\t\t\t\tlp->tx_skb[entry] = NULL;\n\t\t\t\t \n\t\t\t\tdma_unmap_single(lp->device, lp->tx_laddr[entry], lp->tx_len[entry], DMA_TO_DEVICE);\n\t\t\t\tlp->tx_laddr[entry] = (dma_addr_t)0;\n\t\t\t\tfreed_some = 1;\n\n\t\t\t\tif (sonic_tda_get(dev, entry, SONIC_TD_LINK) & SONIC_EOL) {\n\t\t\t\t\tentry = (entry + 1) & SONIC_TDS_MASK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tentry = (entry + 1) & SONIC_TDS_MASK;\n\t\t\t}\n\n\t\t\tif (freed_some || lp->tx_skb[entry] == NULL)\n\t\t\t\tnetif_wake_queue(dev);   \n\t\t\tlp->cur_tx = entry;\n\t\t}\n\n\t\t \n\t\tif (status & SONIC_INT_RFO) {\n\t\t\tnetif_dbg(lp, rx_err, dev, \"%s: rx fifo overrun\\n\",\n\t\t\t\t  __func__);\n\t\t}\n\t\tif (status & SONIC_INT_RDE) {\n\t\t\tnetif_dbg(lp, rx_err, dev, \"%s: rx descriptors exhausted\\n\",\n\t\t\t\t  __func__);\n\t\t}\n\t\tif (status & SONIC_INT_RBAE) {\n\t\t\tnetif_dbg(lp, rx_err, dev, \"%s: rx buffer area exceeded\\n\",\n\t\t\t\t  __func__);\n\t\t}\n\n\t\t \n\t\tif (status & SONIC_INT_FAE)\n\t\t\tlp->stats.rx_frame_errors += 65536;\n\t\tif (status & SONIC_INT_CRC)\n\t\t\tlp->stats.rx_crc_errors += 65536;\n\t\tif (status & SONIC_INT_MP)\n\t\t\tlp->stats.rx_missed_errors += 65536;\n\n\t\t \n\t\tif (status & SONIC_INT_TXER) {\n\t\t\tu16 tcr = SONIC_READ(SONIC_TCR);\n\n\t\t\tnetif_dbg(lp, tx_err, dev, \"%s: TXER intr, TCR %04x\\n\",\n\t\t\t\t  __func__, tcr);\n\n\t\t\tif (tcr & (SONIC_TCR_EXD | SONIC_TCR_EXC |\n\t\t\t\t   SONIC_TCR_FU | SONIC_TCR_BCM)) {\n\t\t\t\t \n\t\t\t\tnetif_stop_queue(dev);\n\t\t\t\tSONIC_WRITE(SONIC_CMD, SONIC_CR_TXP);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (status & SONIC_INT_BR) {\n\t\t\tprintk(KERN_ERR \"%s: Bus retry occurred! Device interrupt disabled.\\n\",\n\t\t\t\tdev->name);\n\t\t\t \n\t\t\t \n\t\t\tSONIC_WRITE(SONIC_IMR, 0);\n\t\t}\n\n\t\tstatus = SONIC_READ(SONIC_ISR) & SONIC_IMR_DEFAULT;\n\t} while (status);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int index_from_addr(struct sonic_local *lp, dma_addr_t addr,\n\t\t\t   unsigned int last)\n{\n\tunsigned int i = last;\n\n\tdo {\n\t\ti = (i + 1) & SONIC_RRS_MASK;\n\t\tif (addr == lp->rx_laddr[i])\n\t\t\treturn i;\n\t} while (i != last);\n\n\treturn -ENOENT;\n}\n\n \nstatic bool sonic_alloc_rb(struct net_device *dev, struct sonic_local *lp,\n\t\t\t   struct sk_buff **new_skb, dma_addr_t *new_addr)\n{\n\t*new_skb = netdev_alloc_skb(dev, SONIC_RBSIZE + 2);\n\tif (!*new_skb)\n\t\treturn false;\n\n\tif (SONIC_BUS_SCALE(lp->dma_bitmode) == 2)\n\t\tskb_reserve(*new_skb, 2);\n\n\t*new_addr = dma_map_single(lp->device, skb_put(*new_skb, SONIC_RBSIZE),\n\t\t\t\t   SONIC_RBSIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(lp->device, *new_addr)) {\n\t\tdev_kfree_skb(*new_skb);\n\t\t*new_skb = NULL;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void sonic_update_rra(struct net_device *dev, struct sonic_local *lp,\n\t\t\t     dma_addr_t old_addr, dma_addr_t new_addr)\n{\n\tunsigned int entry = sonic_rr_entry(dev, SONIC_READ(SONIC_RWP));\n\tunsigned int end = sonic_rr_entry(dev, SONIC_READ(SONIC_RRP));\n\tu32 buf;\n\n\t \n\tdo {\n\t\tbuf = (sonic_rra_get(dev, entry, SONIC_RR_BUFADR_H) << 16) |\n\t\t      sonic_rra_get(dev, entry, SONIC_RR_BUFADR_L);\n\n\t\tif (buf == old_addr)\n\t\t\tbreak;\n\n\t\tentry = (entry + 1) & SONIC_RRS_MASK;\n\t} while (entry != end);\n\n\tWARN_ONCE(buf != old_addr, \"failed to find resource!\\n\");\n\n\tsonic_rra_put(dev, entry, SONIC_RR_BUFADR_H, new_addr >> 16);\n\tsonic_rra_put(dev, entry, SONIC_RR_BUFADR_L, new_addr & 0xffff);\n\n\tentry = (entry + 1) & SONIC_RRS_MASK;\n\n\tSONIC_WRITE(SONIC_RWP, sonic_rr_addr(dev, entry));\n}\n\n \nstatic void sonic_rx(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tint entry = lp->cur_rx;\n\tint prev_entry = lp->eol_rx;\n\tbool rbe = false;\n\n\twhile (sonic_rda_get(dev, entry, SONIC_RD_IN_USE) == 0) {\n\t\tu16 status = sonic_rda_get(dev, entry, SONIC_RD_STATUS);\n\n\t\t \n\t\tif ((status & SONIC_RCR_PRX) && (status & SONIC_RCR_LPKT)) {\n\t\t\tstruct sk_buff *new_skb;\n\t\t\tdma_addr_t new_laddr;\n\t\t\tu32 addr = (sonic_rda_get(dev, entry,\n\t\t\t\t\t\t  SONIC_RD_PKTPTR_H) << 16) |\n\t\t\t\t   sonic_rda_get(dev, entry, SONIC_RD_PKTPTR_L);\n\t\t\tint i = index_from_addr(lp, addr, entry);\n\n\t\t\tif (i < 0) {\n\t\t\t\tWARN_ONCE(1, \"failed to find buffer!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sonic_alloc_rb(dev, lp, &new_skb, &new_laddr)) {\n\t\t\t\tstruct sk_buff *used_skb = lp->rx_skb[i];\n\t\t\t\tint pkt_len;\n\n\t\t\t\t \n\t\t\t\tdma_unmap_single(lp->device, addr, SONIC_RBSIZE,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\t\tpkt_len = sonic_rda_get(dev, entry,\n\t\t\t\t\t\t\tSONIC_RD_PKTLEN);\n\t\t\t\tskb_trim(used_skb, pkt_len);\n\t\t\t\tused_skb->protocol = eth_type_trans(used_skb,\n\t\t\t\t\t\t\t\t    dev);\n\t\t\t\tnetif_rx(used_skb);\n\t\t\t\tlp->stats.rx_packets++;\n\t\t\t\tlp->stats.rx_bytes += pkt_len;\n\n\t\t\t\tlp->rx_skb[i] = new_skb;\n\t\t\t\tlp->rx_laddr[i] = new_laddr;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnew_laddr = addr;\n\t\t\t\tlp->stats.rx_dropped++;\n\t\t\t}\n\t\t\t \n\t\t\trbe = rbe || SONIC_READ(SONIC_ISR) & SONIC_INT_RBE;\n\t\t\tsonic_update_rra(dev, lp, addr, new_laddr);\n\t\t}\n\t\t \n\t\tsonic_rda_put(dev, entry, SONIC_RD_STATUS, 0);\n\t\tsonic_rda_put(dev, entry, SONIC_RD_IN_USE, 1);\n\n\t\tprev_entry = entry;\n\t\tentry = (entry + 1) & SONIC_RDS_MASK;\n\t}\n\n\tlp->cur_rx = entry;\n\n\tif (prev_entry != lp->eol_rx) {\n\t\t \n\t\tsonic_rda_put(dev, prev_entry, SONIC_RD_LINK, SONIC_EOL |\n\t\t\t      sonic_rda_get(dev, prev_entry, SONIC_RD_LINK));\n\t\tsonic_rda_put(dev, lp->eol_rx, SONIC_RD_LINK, ~SONIC_EOL &\n\t\t\t      sonic_rda_get(dev, lp->eol_rx, SONIC_RD_LINK));\n\t\tlp->eol_rx = prev_entry;\n\t}\n\n\tif (rbe)\n\t\tSONIC_WRITE(SONIC_ISR, SONIC_INT_RBE);\n}\n\n\n \nstatic struct net_device_stats *sonic_get_stats(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\n\t \n\tlp->stats.rx_crc_errors += SONIC_READ(SONIC_CRCT);\n\tSONIC_WRITE(SONIC_CRCT, 0xffff);\n\tlp->stats.rx_frame_errors += SONIC_READ(SONIC_FAET);\n\tSONIC_WRITE(SONIC_FAET, 0xffff);\n\tlp->stats.rx_missed_errors += SONIC_READ(SONIC_MPT);\n\tSONIC_WRITE(SONIC_MPT, 0xffff);\n\n\treturn &lp->stats;\n}\n\n\n \nstatic void sonic_multicast_list(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tunsigned int rcr;\n\tstruct netdev_hw_addr *ha;\n\tunsigned char *addr;\n\tint i;\n\n\trcr = SONIC_READ(SONIC_RCR) & ~(SONIC_RCR_PRO | SONIC_RCR_AMC);\n\trcr |= SONIC_RCR_BRD;\t \n\n\tif (dev->flags & IFF_PROMISC) {\t \n\t\trcr |= SONIC_RCR_PRO;\n\t} else {\n\t\tif ((dev->flags & IFF_ALLMULTI) ||\n\t\t    (netdev_mc_count(dev) > 15)) {\n\t\t\trcr |= SONIC_RCR_AMC;\n\t\t} else {\n\t\t\tunsigned long flags;\n\n\t\t\tnetif_dbg(lp, ifup, dev, \"%s: mc_count %d\\n\", __func__,\n\t\t\t\t  netdev_mc_count(dev));\n\t\t\tsonic_set_cam_enable(dev, 1);   \n\t\t\ti = 1;\n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\taddr = ha->addr;\n\t\t\t\tsonic_cda_put(dev, i, SONIC_CD_CAP0, addr[1] << 8 | addr[0]);\n\t\t\t\tsonic_cda_put(dev, i, SONIC_CD_CAP1, addr[3] << 8 | addr[2]);\n\t\t\t\tsonic_cda_put(dev, i, SONIC_CD_CAP2, addr[5] << 8 | addr[4]);\n\t\t\t\tsonic_set_cam_enable(dev, sonic_get_cam_enable(dev) | (1 << i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tSONIC_WRITE(SONIC_CDC, 16);\n\t\t\tSONIC_WRITE(SONIC_CDP, lp->cda_laddr & 0xffff);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\t\tsonic_quiesce(dev, SONIC_CR_TXP, false);\n\t\t\tSONIC_WRITE(SONIC_CMD, SONIC_CR_LCAM);\n\t\t\tsonic_quiesce(dev, SONIC_CR_LCAM, false);\n\t\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\t}\n\t}\n\n\tnetif_dbg(lp, ifup, dev, \"%s: setting RCR=%x\\n\", __func__, rcr);\n\n\tSONIC_WRITE(SONIC_RCR, rcr);\n}\n\n\n \nstatic int sonic_init(struct net_device *dev, bool may_sleep)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tint i;\n\n\t \n\tSONIC_WRITE(SONIC_IMR, 0);\n\tSONIC_WRITE(SONIC_ISR, 0x7fff);\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\n\n\t \n\tSONIC_WRITE(SONIC_CE, 0);\n\n\t \n\tSONIC_WRITE(SONIC_CMD, 0);\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RXDIS | SONIC_CR_STP);\n\tsonic_quiesce(dev, SONIC_CR_ALL, may_sleep);\n\n\t \n\tnetif_dbg(lp, ifup, dev, \"%s: initialize receive resource area\\n\",\n\t\t  __func__);\n\n\tfor (i = 0; i < SONIC_NUM_RRS; i++) {\n\t\tu16 bufadr_l = (unsigned long)lp->rx_laddr[i] & 0xffff;\n\t\tu16 bufadr_h = (unsigned long)lp->rx_laddr[i] >> 16;\n\t\tsonic_rra_put(dev, i, SONIC_RR_BUFADR_L, bufadr_l);\n\t\tsonic_rra_put(dev, i, SONIC_RR_BUFADR_H, bufadr_h);\n\t\tsonic_rra_put(dev, i, SONIC_RR_BUFSIZE_L, SONIC_RBSIZE >> 1);\n\t\tsonic_rra_put(dev, i, SONIC_RR_BUFSIZE_H, 0);\n\t}\n\n\t \n\tSONIC_WRITE(SONIC_RSA, sonic_rr_addr(dev, 0));\n\tSONIC_WRITE(SONIC_REA, sonic_rr_addr(dev, SONIC_NUM_RRS));\n\tSONIC_WRITE(SONIC_RRP, sonic_rr_addr(dev, 0));\n\tSONIC_WRITE(SONIC_RWP, sonic_rr_addr(dev, SONIC_NUM_RRS - 1));\n\tSONIC_WRITE(SONIC_URRA, lp->rra_laddr >> 16);\n\tSONIC_WRITE(SONIC_EOBC, (SONIC_RBSIZE >> 1) - (lp->dma_bitmode ? 2 : 1));\n\n\t \n\tnetif_dbg(lp, ifup, dev, \"%s: issuing RRRA command\\n\", __func__);\n\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RRRA);\n\tsonic_quiesce(dev, SONIC_CR_RRRA, may_sleep);\n\n\t \n\tnetif_dbg(lp, ifup, dev, \"%s: initialize receive descriptors\\n\",\n\t\t  __func__);\n\n\tfor (i=0; i<SONIC_NUM_RDS; i++) {\n\t\tsonic_rda_put(dev, i, SONIC_RD_STATUS, 0);\n\t\tsonic_rda_put(dev, i, SONIC_RD_PKTLEN, 0);\n\t\tsonic_rda_put(dev, i, SONIC_RD_PKTPTR_L, 0);\n\t\tsonic_rda_put(dev, i, SONIC_RD_PKTPTR_H, 0);\n\t\tsonic_rda_put(dev, i, SONIC_RD_SEQNO, 0);\n\t\tsonic_rda_put(dev, i, SONIC_RD_IN_USE, 1);\n\t\tsonic_rda_put(dev, i, SONIC_RD_LINK,\n\t\t\tlp->rda_laddr +\n\t\t\t((i+1) * SIZEOF_SONIC_RD * SONIC_BUS_SCALE(lp->dma_bitmode)));\n\t}\n\t \n\tsonic_rda_put(dev, SONIC_NUM_RDS - 1, SONIC_RD_LINK,\n\t\t(lp->rda_laddr & 0xffff) | SONIC_EOL);\n\tlp->eol_rx = SONIC_NUM_RDS - 1;\n\tlp->cur_rx = 0;\n\tSONIC_WRITE(SONIC_URDA, lp->rda_laddr >> 16);\n\tSONIC_WRITE(SONIC_CRDA, lp->rda_laddr & 0xffff);\n\n\t \n\tnetif_dbg(lp, ifup, dev, \"%s: initialize transmit descriptors\\n\",\n\t\t  __func__);\n\n\tfor (i = 0; i < SONIC_NUM_TDS; i++) {\n\t\tsonic_tda_put(dev, i, SONIC_TD_STATUS, 0);\n\t\tsonic_tda_put(dev, i, SONIC_TD_CONFIG, 0);\n\t\tsonic_tda_put(dev, i, SONIC_TD_PKTSIZE, 0);\n\t\tsonic_tda_put(dev, i, SONIC_TD_FRAG_COUNT, 0);\n\t\tsonic_tda_put(dev, i, SONIC_TD_LINK,\n\t\t\t(lp->tda_laddr & 0xffff) +\n\t\t\t(i + 1) * SIZEOF_SONIC_TD * SONIC_BUS_SCALE(lp->dma_bitmode));\n\t\tlp->tx_skb[i] = NULL;\n\t}\n\t \n\tsonic_tda_put(dev, SONIC_NUM_TDS - 1, SONIC_TD_LINK,\n\t\t(lp->tda_laddr & 0xffff));\n\n\tSONIC_WRITE(SONIC_UTDA, lp->tda_laddr >> 16);\n\tSONIC_WRITE(SONIC_CTDA, lp->tda_laddr & 0xffff);\n\tlp->cur_tx = 0;\n\tlp->eol_tx = SONIC_NUM_TDS - 1;\n\n\t \n\tsonic_cda_put(dev, 0, SONIC_CD_CAP0, dev->dev_addr[1] << 8 | dev->dev_addr[0]);\n\tsonic_cda_put(dev, 0, SONIC_CD_CAP1, dev->dev_addr[3] << 8 | dev->dev_addr[2]);\n\tsonic_cda_put(dev, 0, SONIC_CD_CAP2, dev->dev_addr[5] << 8 | dev->dev_addr[4]);\n\tsonic_set_cam_enable(dev, 1);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsonic_cda_put(dev, i, SONIC_CD_ENTRY_POINTER, i);\n\n\t \n\tSONIC_WRITE(SONIC_CDP, lp->cda_laddr & 0xffff);\n\tSONIC_WRITE(SONIC_CDC, 16);\n\n\t \n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_LCAM);\n\tsonic_quiesce(dev, SONIC_CR_LCAM, may_sleep);\n\n\t \n\tSONIC_WRITE(SONIC_RCR, SONIC_RCR_DEFAULT);\n\tSONIC_WRITE(SONIC_TCR, SONIC_TCR_DEFAULT);\n\tSONIC_WRITE(SONIC_ISR, 0x7fff);\n\tSONIC_WRITE(SONIC_IMR, SONIC_IMR_DEFAULT);\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RXEN);\n\n\tnetif_dbg(lp, ifup, dev, \"%s: new status=%x\\n\", __func__,\n\t\t  SONIC_READ(SONIC_CMD));\n\n\treturn 0;\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}