{
  "module_name": "xtsonic.c",
  "hash_id": "c3d953cf922e91249a30f89ac4544b381c53ad8ce4f856744badb792d42820da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/natsemi/xtsonic.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/pgtable.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\nstatic char xtsonic_string[] = \"xtsonic\";\n\nextern unsigned xtboard_nvram_valid(void);\nextern void xtboard_get_ether_addr(unsigned char *buf);\n\n#include \"sonic.h\"\n\n \n#undef SONIC_RBSIZE\n#define SONIC_RBSIZE\t1524\n\n \n#define SONIC_MEM_SIZE\t0x100\n\n \n#define SONIC_READ(reg) \\\n\t(0xffff & *((volatile unsigned int *)dev->base_addr+reg))\n\n#define SONIC_WRITE(reg,val) \\\n\t*((volatile unsigned int *)dev->base_addr+reg) = val\n\n \nstatic unsigned short known_revisions[] =\n{\n\t0x101,\t\t\t \n\t0xffff\t\t\t \n};\n\nstatic int xtsonic_open(struct net_device *dev)\n{\n\tint retval;\n\n\tretval = request_irq(dev->irq, sonic_interrupt, 0, \"sonic\", dev);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d.\\n\",\n\t\t       dev->name, dev->irq);\n\t\treturn -EAGAIN;\n\t}\n\n\tretval = sonic_open(dev);\n\tif (retval)\n\t\tfree_irq(dev->irq, dev);\n\treturn retval;\n}\n\nstatic int xtsonic_close(struct net_device *dev)\n{\n\tint err;\n\terr = sonic_close(dev);\n\tfree_irq(dev->irq, dev);\n\treturn err;\n}\n\nstatic const struct net_device_ops xtsonic_netdev_ops = {\n\t.ndo_open\t\t= xtsonic_open,\n\t.ndo_stop\t\t= xtsonic_close,\n\t.ndo_start_xmit\t\t= sonic_send_packet,\n\t.ndo_get_stats\t\t= sonic_get_stats,\n\t.ndo_set_rx_mode\t= sonic_multicast_list,\n\t.ndo_tx_timeout\t\t= sonic_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int sonic_probe1(struct net_device *dev)\n{\n\tunsigned int silicon_revision;\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tunsigned int base_addr = dev->base_addr;\n\tint i;\n\tint err = 0;\n\tunsigned char addr[ETH_ALEN];\n\n\tif (!request_mem_region(base_addr, 0x100, xtsonic_string))\n\t\treturn -EBUSY;\n\n\t \n\tsilicon_revision = SONIC_READ(SONIC_SR);\n\ti = 0;\n\twhile ((known_revisions[i] != 0xffff) &&\n\t\t\t(known_revisions[i] != silicon_revision))\n\t\ti++;\n\n\tif (known_revisions[i] == 0xffff) {\n\t\tpr_info(\"SONIC ethernet controller not found (0x%4x)\\n\",\n\t\t\tsilicon_revision);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tSONIC_WRITE(SONIC_CMD,SONIC_CR_RST);\n\tSONIC_WRITE(SONIC_DCR,\n\t\t    SONIC_DCR_WC0|SONIC_DCR_DW|SONIC_DCR_LBR|SONIC_DCR_SBUS);\n\tSONIC_WRITE(SONIC_CEP,0);\n\tSONIC_WRITE(SONIC_IMR,0);\n\n\tSONIC_WRITE(SONIC_CMD,SONIC_CR_RST);\n\tSONIC_WRITE(SONIC_CEP,0);\n\n\tfor (i=0; i<3; i++) {\n\t\tunsigned int val = SONIC_READ(SONIC_CAP0-i);\n\t\taddr[i*2] = val;\n\t\taddr[i*2+1] = val >> 8;\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\tlp->dma_bitmode = SONIC_BITMODE32;\n\n\terr = sonic_alloc_descriptors(dev);\n\tif (err)\n\t\tgoto out;\n\n\tdev->netdev_ops\t\t= &xtsonic_netdev_ops;\n\tdev->watchdog_timeo\t= TX_TIMEOUT;\n\n\t \n\tSONIC_WRITE(SONIC_CRCT,0xffff);\n\tSONIC_WRITE(SONIC_FAET,0xffff);\n\tSONIC_WRITE(SONIC_MPT,0xffff);\n\n\treturn 0;\nout:\n\trelease_region(dev->base_addr, SONIC_MEM_SIZE);\n\treturn err;\n}\n\n\n \n\nint xtsonic_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct sonic_local *lp;\n\tstruct resource *resmem, *resirq;\n\tint err = 0;\n\n\tif ((resmem = platform_get_resource(pdev, IORESOURCE_MEM, 0)) == NULL)\n\t\treturn -ENODEV;\n\n\tif ((resirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0)) == NULL)\n\t\treturn -ENODEV;\n\n\tif ((dev = alloc_etherdev(sizeof(struct sonic_local))) == NULL)\n\t\treturn -ENOMEM;\n\n\tlp = netdev_priv(dev);\n\tlp->device = &pdev->dev;\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tdev->base_addr = resmem->start;\n\tdev->irq = resirq->start;\n\n\tif ((err = sonic_probe1(dev)))\n\t\tgoto out;\n\n\tpr_info(\"SONIC ethernet @%08lx, MAC %pM, IRQ %d\\n\",\n\t\tdev->base_addr, dev->dev_addr, dev->irq);\n\n\tsonic_msg_init(dev);\n\n\tif ((err = register_netdev(dev)))\n\t\tgoto undo_probe1;\n\n\treturn 0;\n\nundo_probe1:\n\tdma_free_coherent(lp->device,\n\t\t\t  SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t\t\t  lp->descriptors, lp->descriptors_laddr);\n\trelease_region(dev->base_addr, SONIC_MEM_SIZE);\nout:\n\tfree_netdev(dev);\n\n\treturn err;\n}\n\nMODULE_DESCRIPTION(\"Xtensa XT2000 SONIC ethernet driver\");\n\n#include \"sonic.c\"\n\nstatic int xtsonic_device_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct sonic_local *lp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tdma_free_coherent(lp->device,\n\t\t\t  SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t\t\t  lp->descriptors, lp->descriptors_laddr);\n\trelease_region (dev->base_addr, SONIC_MEM_SIZE);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver xtsonic_driver = {\n\t.probe = xtsonic_probe,\n\t.remove = xtsonic_device_remove,\n\t.driver = {\n\t\t.name = xtsonic_string,\n\t},\n};\n\nmodule_platform_driver(xtsonic_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}