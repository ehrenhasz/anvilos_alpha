{
  "module_name": "macsonic.c",
  "hash_id": "071baa4b38a47ac3dfe94bb9344aaa4c9d9015eb871854b3b924302836332f1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/natsemi/macsonic.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/nubus.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/bitrev.h>\n#include <linux/slab.h>\n#include <linux/pgtable.h>\n\n#include <asm/io.h>\n#include <asm/hwtest.h>\n#include <asm/dma.h>\n#include <asm/macintosh.h>\n#include <asm/macints.h>\n#include <asm/mac_via.h>\n\n#include \"sonic.h\"\n\n \n#define SONIC_READ(reg) (nubus_readw(dev->base_addr + (reg * 4) \\\n\t      + lp->reg_offset))\n#define SONIC_WRITE(reg,val) (nubus_writew(val, dev->base_addr + (reg * 4) \\\n\t      + lp->reg_offset))\n\n \n#define ONBOARD_SONIC_REGISTERS\t0x50F0A000\n#define ONBOARD_SONIC_PROM_BASE\t0x50f08000\n\nenum macsonic_type {\n\tMACSONIC_DUODOCK,\n\tMACSONIC_APPLE,\n\tMACSONIC_APPLE16,\n\tMACSONIC_DAYNA,\n\tMACSONIC_DAYNALINK\n};\n\n \n#define DUODOCK_SONIC_REGISTERS 0xe10000\n#define DUODOCK_SONIC_PROM_BASE 0xe12000\n\n \n#define APPLE_SONIC_REGISTERS\t0\n#define APPLE_SONIC_PROM_BASE\t0x40000\n\n \n#define DAYNALINK_PROM_BASE 0x400000\n\n \n#define DAYNA_SONIC_REGISTERS   0x180000\n \n#define DAYNA_SONIC_MAC_ADDR\t0xffe004\n\n#define SONIC_READ_PROM(addr) nubus_readb(prom_addr+addr)\n\n \n\nstatic inline void bit_reverse_addr(unsigned char addr[6])\n{\n\tint i;\n\n\tfor(i = 0; i < 6; i++)\n\t\taddr[i] = bitrev8(addr[i]);\n}\n\nstatic int macsonic_open(struct net_device* dev)\n{\n\tint retval;\n\n\tretval = request_irq(dev->irq, sonic_interrupt, 0, \"sonic\", dev);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d.\\n\",\n\t\t\t\tdev->name, dev->irq);\n\t\tgoto err;\n\t}\n\t \n\tif (dev->irq == IRQ_AUTO_3) {\n\t\tretval = request_irq(IRQ_NUBUS_9, sonic_interrupt, 0,\n\t\t\t\t     \"sonic\", dev);\n\t\tif (retval) {\n\t\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d.\\n\",\n\t\t\t\t\tdev->name, IRQ_NUBUS_9);\n\t\t\tgoto err_irq;\n\t\t}\n\t}\n\tretval = sonic_open(dev);\n\tif (retval)\n\t\tgoto err_irq_nubus;\n\treturn 0;\n\nerr_irq_nubus:\n\tif (dev->irq == IRQ_AUTO_3)\n\t\tfree_irq(IRQ_NUBUS_9, dev);\nerr_irq:\n\tfree_irq(dev->irq, dev);\nerr:\n\treturn retval;\n}\n\nstatic int macsonic_close(struct net_device* dev)\n{\n\tint err;\n\terr = sonic_close(dev);\n\tfree_irq(dev->irq, dev);\n\tif (dev->irq == IRQ_AUTO_3)\n\t\tfree_irq(IRQ_NUBUS_9, dev);\n\treturn err;\n}\n\nstatic const struct net_device_ops macsonic_netdev_ops = {\n\t.ndo_open\t\t= macsonic_open,\n\t.ndo_stop\t\t= macsonic_close,\n\t.ndo_start_xmit\t\t= sonic_send_packet,\n\t.ndo_set_rx_mode\t= sonic_multicast_list,\n\t.ndo_tx_timeout\t\t= sonic_tx_timeout,\n\t.ndo_get_stats\t\t= sonic_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int macsonic_init(struct net_device *dev)\n{\n\tstruct sonic_local* lp = netdev_priv(dev);\n\tint err = sonic_alloc_descriptors(dev);\n\n\tif (err)\n\t\treturn err;\n\n\tdev->netdev_ops = &macsonic_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\t \n\tSONIC_WRITE(SONIC_CRCT, 0xffff);\n\tSONIC_WRITE(SONIC_FAET, 0xffff);\n\tSONIC_WRITE(SONIC_MPT, 0xffff);\n\n\treturn 0;\n}\n\n#define INVALID_MAC(mac) (memcmp(mac, \"\\x08\\x00\\x07\", 3) && \\\n                          memcmp(mac, \"\\x00\\xA0\\x40\", 3) && \\\n                          memcmp(mac, \"\\x00\\x80\\x19\", 3) && \\\n                          memcmp(mac, \"\\x00\\x05\\x02\", 3))\n\nstatic void mac_onboard_sonic_ethernet_addr(struct net_device *dev)\n{\n\tstruct sonic_local *lp = netdev_priv(dev);\n\tconst int prom_addr = ONBOARD_SONIC_PROM_BASE;\n\tunsigned short val;\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (hwreg_present((void *)prom_addr)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 6; i++)\n\t\t\taddr[i] = SONIC_READ_PROM(i);\n\t\teth_hw_addr_set(dev, addr);\n\t\tif (!INVALID_MAC(dev->dev_addr))\n\t\t\treturn;\n\n\t\t \n\t\tbit_reverse_addr(addr);\n\t\teth_hw_addr_set(dev, addr);\n\t\tif (!INVALID_MAC(dev->dev_addr))\n\t\t\treturn;\n\n\t\t \n\t\tprintk(KERN_WARNING \"macsonic: MAC address in PROM seems \"\n\t\t                    \"to be invalid, trying CAM\\n\");\n\t} else {\n\t\tprintk(KERN_WARNING \"macsonic: cannot read MAC address from \"\n\t\t                    \"PROM, trying CAM\\n\");\n\t}\n\n\t \n\n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\n\tSONIC_WRITE(SONIC_CEP, 15);\n\n\tval = SONIC_READ(SONIC_CAP2);\n\taddr[5] = val >> 8;\n\taddr[4] = val & 0xff;\n\tval = SONIC_READ(SONIC_CAP1);\n\taddr[3] = val >> 8;\n\taddr[2] = val & 0xff;\n\tval = SONIC_READ(SONIC_CAP0);\n\taddr[1] = val >> 8;\n\taddr[0] = val & 0xff;\n\teth_hw_addr_set(dev, addr);\n\n\tif (!INVALID_MAC(dev->dev_addr))\n\t\treturn;\n\n\t \n\n\tprintk(KERN_WARNING \"macsonic: MAC address in CAM entry 15 \"\n\t                    \"seems invalid, will use a random MAC\\n\");\n\teth_hw_addr_random(dev);\n}\n\nstatic int mac_onboard_sonic_probe(struct net_device *dev)\n{\n\tstruct sonic_local* lp = netdev_priv(dev);\n\tint sr;\n\tbool commslot = macintosh_config->expansion_type == MAC_EXP_PDS_COMM;\n\n\t \n\tif (commslot || macintosh_config->ident == MAC_MODEL_C610) {\n\t\tint card_present;\n\n\t\tcard_present = hwreg_present((void*)ONBOARD_SONIC_REGISTERS);\n\t\tif (!card_present) {\n\t\t\tpr_info(\"Onboard/comm-slot SONIC not found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tdev->base_addr = ONBOARD_SONIC_REGISTERS;\n\tif (via_alt_mapping)\n\t\tdev->irq = IRQ_AUTO_3;\n\telse\n\t\tdev->irq = IRQ_NUBUS_9;\n\n\t \n\tif (macintosh_config->ident == MAC_MODEL_PB520) {\n\t\tlp->reg_offset = 0;\n\t\tlp->dma_bitmode = SONIC_BITMODE16;\n\t} else if (commslot) {\n\t\t \n\t\tlp->reg_offset = 2;\n\t\tlp->dma_bitmode = SONIC_BITMODE16;\n\n\t\tsr = SONIC_READ(SONIC_SR);\n\t\tif (sr == 0x0004 || sr == 0x0006 || sr == 0x0100 || sr == 0x0101)\n\t\t\t \n\t\t\tlp->dma_bitmode = SONIC_BITMODE32;\n\t\telse {\n\t\t\tlp->dma_bitmode = SONIC_BITMODE16;\n\t\t\tlp->reg_offset = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tlp->reg_offset = 2;\n\t\tlp->dma_bitmode = SONIC_BITMODE32;\n\t}\n\n\tpr_info(\"Onboard/comm-slot SONIC, revision 0x%04x, %d bit DMA, register offset %d\\n\",\n\t\tSONIC_READ(SONIC_SR), lp->dma_bitmode ? 32 : 16,\n\t\tlp->reg_offset);\n\n\t \n\tpr_debug(\"%s: DCR=0x%04x, DCR2=0x%04x\\n\", __func__,\n\t\t SONIC_READ(SONIC_DCR) & 0xffff,\n\t\t SONIC_READ(SONIC_DCR2) & 0xffff);\n\n\t \n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\n\n\tSONIC_WRITE(SONIC_DCR, SONIC_DCR_EXBUS | SONIC_DCR_BMS |\n\t                       SONIC_DCR_RFT1  | SONIC_DCR_TFT0 |\n\t                       (lp->dma_bitmode ? SONIC_DCR_DW : 0));\n\n\t \n\tSONIC_WRITE(SONIC_DCR2, 0);\n\n\t \n\tSONIC_WRITE(SONIC_IMR, 0);\n\tSONIC_WRITE(SONIC_ISR, 0x7fff);\n\n\t \n\tmac_onboard_sonic_ethernet_addr(dev);\n\n\tpr_info(\"SONIC ethernet @%08lx, MAC %pM, IRQ %d\\n\",\n\t\tdev->base_addr, dev->dev_addr, dev->irq);\n\n\t \n\treturn macsonic_init(dev);\n}\n\nstatic int mac_sonic_nubus_ethernet_addr(struct net_device *dev,\n\t\t\t\t\t unsigned long prom_addr, int id)\n{\n\tu8 addr[ETH_ALEN];\n\tint i;\n\n\tfor(i = 0; i < 6; i++)\n\t\taddr[i] = SONIC_READ_PROM(i);\n\n\t \n\tif (id != MACSONIC_DAYNA)\n\t\tbit_reverse_addr(addr);\n\teth_hw_addr_set(dev, addr);\n\n\treturn 0;\n}\n\nstatic int macsonic_ident(struct nubus_rsrc *fres)\n{\n\tif (fres->dr_hw == NUBUS_DRHW_ASANTE_LC &&\n\t    fres->dr_sw == NUBUS_DRSW_SONIC_LC)\n\t\treturn MACSONIC_DAYNALINK;\n\tif (fres->dr_hw == NUBUS_DRHW_SONIC &&\n\t    fres->dr_sw == NUBUS_DRSW_APPLE) {\n\t\t \n\t\tif (strstr(fres->board->name, \"DuoDock\"))\n\t\t\treturn MACSONIC_DUODOCK;\n\t\telse\n\t\t\treturn MACSONIC_APPLE;\n\t}\n\n\tif (fres->dr_hw == NUBUS_DRHW_SMC9194 &&\n\t    fres->dr_sw == NUBUS_DRSW_DAYNA)\n\t\treturn MACSONIC_DAYNA;\n\n\tif (fres->dr_hw == NUBUS_DRHW_APPLE_SONIC_LC &&\n\t    fres->dr_sw == 0) {  \n\t\treturn MACSONIC_APPLE16;\n\t}\n\treturn -1;\n}\n\nstatic int mac_sonic_nubus_probe_board(struct nubus_board *board, int id,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct sonic_local* lp = netdev_priv(dev);\n\tunsigned long base_addr, prom_addr;\n\tu16 sonic_dcr;\n\tint reg_offset, dma_bitmode;\n\n\tswitch (id) {\n\tcase MACSONIC_DUODOCK:\n\t\tbase_addr = board->slot_addr + DUODOCK_SONIC_REGISTERS;\n\t\tprom_addr = board->slot_addr + DUODOCK_SONIC_PROM_BASE;\n\t\tsonic_dcr = SONIC_DCR_EXBUS | SONIC_DCR_RFT0 | SONIC_DCR_RFT1 |\n\t\t            SONIC_DCR_TFT0;\n\t\treg_offset = 2;\n\t\tdma_bitmode = SONIC_BITMODE32;\n\t\tbreak;\n\tcase MACSONIC_APPLE:\n\t\tbase_addr = board->slot_addr + APPLE_SONIC_REGISTERS;\n\t\tprom_addr = board->slot_addr + APPLE_SONIC_PROM_BASE;\n\t\tsonic_dcr = SONIC_DCR_BMS | SONIC_DCR_RFT1 | SONIC_DCR_TFT0;\n\t\treg_offset = 0;\n\t\tdma_bitmode = SONIC_BITMODE32;\n\t\tbreak;\n\tcase MACSONIC_APPLE16:\n\t\tbase_addr = board->slot_addr + APPLE_SONIC_REGISTERS;\n\t\tprom_addr = board->slot_addr + APPLE_SONIC_PROM_BASE;\n\t\tsonic_dcr = SONIC_DCR_EXBUS | SONIC_DCR_RFT1 | SONIC_DCR_TFT0 |\n\t\t            SONIC_DCR_PO1 | SONIC_DCR_BMS;\n\t\treg_offset = 0;\n\t\tdma_bitmode = SONIC_BITMODE16;\n\t\tbreak;\n\tcase MACSONIC_DAYNALINK:\n\t\tbase_addr = board->slot_addr + APPLE_SONIC_REGISTERS;\n\t\tprom_addr = board->slot_addr + DAYNALINK_PROM_BASE;\n\t\tsonic_dcr = SONIC_DCR_RFT1 | SONIC_DCR_TFT0 |\n\t\t            SONIC_DCR_PO1 | SONIC_DCR_BMS;\n\t\treg_offset = 0;\n\t\tdma_bitmode = SONIC_BITMODE16;\n\t\tbreak;\n\tcase MACSONIC_DAYNA:\n\t\tbase_addr = board->slot_addr + DAYNA_SONIC_REGISTERS;\n\t\tprom_addr = board->slot_addr + DAYNA_SONIC_MAC_ADDR;\n\t\tsonic_dcr = SONIC_DCR_BMS |\n\t\t            SONIC_DCR_RFT1 | SONIC_DCR_TFT0 | SONIC_DCR_PO1;\n\t\treg_offset = 0;\n\t\tdma_bitmode = SONIC_BITMODE16;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"macsonic: WTF, id is %d\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->base_addr = base_addr;\n\tlp->reg_offset = reg_offset;\n\tlp->dma_bitmode = dma_bitmode;\n\tdev->irq = SLOT2IRQ(board->slot);\n\n\tdev_info(&board->dev, \"%s, revision 0x%04x, %d bit DMA, register offset %d\\n\",\n\t\t board->name, SONIC_READ(SONIC_SR),\n\t\t lp->dma_bitmode ? 32 : 16, lp->reg_offset);\n\n\t \n\tdev_dbg(&board->dev, \"%s: DCR=0x%04x, DCR2=0x%04x\\n\", __func__,\n\t\tSONIC_READ(SONIC_DCR) & 0xffff,\n\t\tSONIC_READ(SONIC_DCR2) & 0xffff);\n\n\t \n\tSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\n\tSONIC_WRITE(SONIC_DCR, sonic_dcr | (dma_bitmode ? SONIC_DCR_DW : 0));\n\t \n\tSONIC_WRITE(SONIC_DCR2, 0);\n\n\t \n\tSONIC_WRITE(SONIC_IMR, 0);\n\tSONIC_WRITE(SONIC_ISR, 0x7fff);\n\n\t \n\tif (mac_sonic_nubus_ethernet_addr(dev, prom_addr, id) != 0)\n\t\treturn -ENODEV;\n\n\tdev_info(&board->dev, \"SONIC ethernet @%08lx, MAC %pM, IRQ %d\\n\",\n\t\t dev->base_addr, dev->dev_addr, dev->irq);\n\n\t \n\treturn macsonic_init(dev);\n}\n\nstatic int mac_sonic_platform_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct sonic_local *lp;\n\tint err;\n\n\tdev = alloc_etherdev(sizeof(struct sonic_local));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tlp = netdev_priv(dev);\n\tlp->device = &pdev->dev;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tplatform_set_drvdata(pdev, dev);\n\n\terr = mac_onboard_sonic_probe(dev);\n\tif (err)\n\t\tgoto out;\n\n\tsonic_msg_init(dev);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto undo_probe;\n\n\treturn 0;\n\nundo_probe:\n\tdma_free_coherent(lp->device,\n\t\t\t  SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t\t\t  lp->descriptors, lp->descriptors_laddr);\nout:\n\tfree_netdev(dev);\n\n\treturn err;\n}\n\nMODULE_DESCRIPTION(\"Macintosh SONIC ethernet driver\");\nMODULE_ALIAS(\"platform:macsonic\");\n\n#include \"sonic.c\"\n\nstatic int mac_sonic_platform_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct sonic_local* lp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tdma_free_coherent(lp->device, SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t                  lp->descriptors, lp->descriptors_laddr);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mac_sonic_platform_driver = {\n\t.probe  = mac_sonic_platform_probe,\n\t.remove = mac_sonic_platform_remove,\n\t.driver = {\n\t\t.name = \"macsonic\",\n\t},\n};\n\nstatic int mac_sonic_nubus_probe(struct nubus_board *board)\n{\n\tstruct net_device *ndev;\n\tstruct sonic_local *lp;\n\tstruct nubus_rsrc *fres;\n\tint id = -1;\n\tint err;\n\n\t \n\tif (macintosh_config->expansion_type == MAC_EXP_PDS_COMM)\n\t\treturn -ENODEV;\n\n\tfor_each_board_func_rsrc(board, fres) {\n\t\tif (fres->category != NUBUS_CAT_NETWORK ||\n\t\t    fres->type != NUBUS_TYPE_ETHERNET)\n\t\t\tcontinue;\n\n\t\tid = macsonic_ident(fres);\n\t\tif (id != -1)\n\t\t\tbreak;\n\t}\n\tif (!fres)\n\t\treturn -ENODEV;\n\n\tndev = alloc_etherdev(sizeof(struct sonic_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tlp = netdev_priv(ndev);\n\tlp->device = &board->dev;\n\tSET_NETDEV_DEV(ndev, &board->dev);\n\n\terr = mac_sonic_nubus_probe_board(board, id, ndev);\n\tif (err)\n\t\tgoto out;\n\n\tsonic_msg_init(ndev);\n\n\terr = register_netdev(ndev);\n\tif (err)\n\t\tgoto undo_probe;\n\n\tnubus_set_drvdata(board, ndev);\n\n\treturn 0;\n\nundo_probe:\n\tdma_free_coherent(lp->device,\n\t\t\t  SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t\t\t  lp->descriptors, lp->descriptors_laddr);\nout:\n\tfree_netdev(ndev);\n\treturn err;\n}\n\nstatic void mac_sonic_nubus_remove(struct nubus_board *board)\n{\n\tstruct net_device *ndev = nubus_get_drvdata(board);\n\tstruct sonic_local *lp = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\tdma_free_coherent(lp->device,\n\t\t\t  SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\n\t\t\t  lp->descriptors, lp->descriptors_laddr);\n\tfree_netdev(ndev);\n}\n\nstatic struct nubus_driver mac_sonic_nubus_driver = {\n\t.probe  = mac_sonic_nubus_probe,\n\t.remove = mac_sonic_nubus_remove,\n\t.driver = {\n\t\t.name = \"macsonic-nubus\",\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic int perr, nerr;\n\nstatic int __init mac_sonic_init(void)\n{\n\tperr = platform_driver_register(&mac_sonic_platform_driver);\n\tnerr = nubus_driver_register(&mac_sonic_nubus_driver);\n\treturn 0;\n}\nmodule_init(mac_sonic_init);\n\nstatic void __exit mac_sonic_exit(void)\n{\n\tif (!perr)\n\t\tplatform_driver_unregister(&mac_sonic_platform_driver);\n\tif (!nerr)\n\t\tnubus_driver_unregister(&mac_sonic_nubus_driver);\n}\nmodule_exit(mac_sonic_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}