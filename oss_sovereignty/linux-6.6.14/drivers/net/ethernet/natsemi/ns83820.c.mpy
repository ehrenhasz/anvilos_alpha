{
  "module_name": "ns83820.c",
  "hash_id": "9950bfacc35ed4b1f3ae13aabeadf559743c840fb6c2bca63a3120d536f17e3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/natsemi/ns83820.c",
  "human_readable_source": "\n#define VERSION \"0.23\"\n \n \n#define dprintk(x...)\t\tdo { } while (0)\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\t \n#include <linux/in.h>\t \n#include <linux/compiler.h>\n#include <linux/prefetch.h>\n#include <linux/ethtool.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/if_vlan.h>\n#include <linux/rtnetlink.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#define DRV_NAME \"ns83820\"\n\n \nstatic int ihr = 2;\nstatic int reset_phy = 0;\nstatic int lnksts = 0;\t\t \n\n \n#undef Dprintk\n#define\tDprintk\t\t\tdprintk\n\n \n#define RX_BUF_SIZE\t1500\t \n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n#define NS83820_VLAN_ACCEL_SUPPORT\n#endif\n\n \n#define NR_RX_DESC\t64\n#define NR_TX_DESC\t128\n\n \n#define REAL_RX_BUF_SIZE (RX_BUF_SIZE + 14)\t \n\n#define MIN_TX_DESC_FREE\t8\n\n \n#define CFGCS\t\t0x04\n\n#define CR_TXE\t\t0x00000001\n#define CR_TXD\t\t0x00000002\n \n#define CR_RXE\t\t0x00000004\n#define CR_RXD\t\t0x00000008\n#define CR_TXR\t\t0x00000010\n#define CR_RXR\t\t0x00000020\n#define CR_SWI\t\t0x00000080\n#define CR_RST\t\t0x00000100\n\n#define PTSCR_EEBIST_FAIL       0x00000001\n#define PTSCR_EEBIST_EN         0x00000002\n#define PTSCR_EELOAD_EN         0x00000004\n#define PTSCR_RBIST_FAIL        0x000001b8\n#define PTSCR_RBIST_DONE        0x00000200\n#define PTSCR_RBIST_EN          0x00000400\n#define PTSCR_RBIST_RST         0x00002000\n\n#define MEAR_EEDI\t\t0x00000001\n#define MEAR_EEDO\t\t0x00000002\n#define MEAR_EECLK\t\t0x00000004\n#define MEAR_EESEL\t\t0x00000008\n#define MEAR_MDIO\t\t0x00000010\n#define MEAR_MDDIR\t\t0x00000020\n#define MEAR_MDC\t\t0x00000040\n\n#define ISR_TXDESC3\t0x40000000\n#define ISR_TXDESC2\t0x20000000\n#define ISR_TXDESC1\t0x10000000\n#define ISR_TXDESC0\t0x08000000\n#define ISR_RXDESC3\t0x04000000\n#define ISR_RXDESC2\t0x02000000\n#define ISR_RXDESC1\t0x01000000\n#define ISR_RXDESC0\t0x00800000\n#define ISR_TXRCMP\t0x00400000\n#define ISR_RXRCMP\t0x00200000\n#define ISR_DPERR\t0x00100000\n#define ISR_SSERR\t0x00080000\n#define ISR_RMABT\t0x00040000\n#define ISR_RTABT\t0x00020000\n#define ISR_RXSOVR\t0x00010000\n#define ISR_HIBINT\t0x00008000\n#define ISR_PHY\t\t0x00004000\n#define ISR_PME\t\t0x00002000\n#define ISR_SWI\t\t0x00001000\n#define ISR_MIB\t\t0x00000800\n#define ISR_TXURN\t0x00000400\n#define ISR_TXIDLE\t0x00000200\n#define ISR_TXERR\t0x00000100\n#define ISR_TXDESC\t0x00000080\n#define ISR_TXOK\t0x00000040\n#define ISR_RXORN\t0x00000020\n#define ISR_RXIDLE\t0x00000010\n#define ISR_RXEARLY\t0x00000008\n#define ISR_RXERR\t0x00000004\n#define ISR_RXDESC\t0x00000002\n#define ISR_RXOK\t0x00000001\n\n#define TXCFG_CSI\t0x80000000\n#define TXCFG_HBI\t0x40000000\n#define TXCFG_MLB\t0x20000000\n#define TXCFG_ATP\t0x10000000\n#define TXCFG_ECRETRY\t0x00800000\n#define TXCFG_BRST_DIS\t0x00080000\n#define TXCFG_MXDMA1024\t0x00000000\n#define TXCFG_MXDMA512\t0x00700000\n#define TXCFG_MXDMA256\t0x00600000\n#define TXCFG_MXDMA128\t0x00500000\n#define TXCFG_MXDMA64\t0x00400000\n#define TXCFG_MXDMA32\t0x00300000\n#define TXCFG_MXDMA16\t0x00200000\n#define TXCFG_MXDMA8\t0x00100000\n\n#define CFG_LNKSTS\t0x80000000\n#define CFG_SPDSTS\t0x60000000\n#define CFG_SPDSTS1\t0x40000000\n#define CFG_SPDSTS0\t0x20000000\n#define CFG_DUPSTS\t0x10000000\n#define CFG_TBI_EN\t0x01000000\n#define CFG_MODE_1000\t0x00400000\n \n#define CFG_AUTO_1000\t0x00200000\n#define CFG_PINT_CTL\t0x001c0000\n#define CFG_PINT_DUPSTS\t0x00100000\n#define CFG_PINT_LNKSTS\t0x00080000\n#define CFG_PINT_SPDSTS\t0x00040000\n#define CFG_TMRTEST\t0x00020000\n#define CFG_MRM_DIS\t0x00010000\n#define CFG_MWI_DIS\t0x00008000\n#define CFG_T64ADDR\t0x00004000\n#define CFG_PCI64_DET\t0x00002000\n#define CFG_DATA64_EN\t0x00001000\n#define CFG_M64ADDR\t0x00000800\n#define CFG_PHY_RST\t0x00000400\n#define CFG_PHY_DIS\t0x00000200\n#define CFG_EXTSTS_EN\t0x00000100\n#define CFG_REQALG\t0x00000080\n#define CFG_SB\t\t0x00000040\n#define CFG_POW\t\t0x00000020\n#define CFG_EXD\t\t0x00000010\n#define CFG_PESEL\t0x00000008\n#define CFG_BROM_DIS\t0x00000004\n#define CFG_EXT_125\t0x00000002\n#define CFG_BEM\t\t0x00000001\n\n#define EXTSTS_UDPPKT\t0x00200000\n#define EXTSTS_TCPPKT\t0x00080000\n#define EXTSTS_IPPKT\t0x00020000\n#define EXTSTS_VPKT\t0x00010000\n#define EXTSTS_VTG_MASK\t0x0000ffff\n\n#define SPDSTS_POLARITY\t(CFG_SPDSTS1 | CFG_SPDSTS0 | CFG_DUPSTS | (lnksts ? CFG_LNKSTS : 0))\n\n#define MIBC_MIBS\t0x00000008\n#define MIBC_ACLR\t0x00000004\n#define MIBC_FRZ\t0x00000002\n#define MIBC_WRN\t0x00000001\n\n#define PCR_PSEN\t(1 << 31)\n#define PCR_PS_MCAST\t(1 << 30)\n#define PCR_PS_DA\t(1 << 29)\n#define PCR_STHI_8\t(3 << 23)\n#define PCR_STLO_4\t(1 << 23)\n#define PCR_FFHI_8K\t(3 << 21)\n#define PCR_FFLO_4K\t(1 << 21)\n#define PCR_PAUSE_CNT\t0xFFFE\n\n#define RXCFG_AEP\t0x80000000\n#define RXCFG_ARP\t0x40000000\n#define RXCFG_STRIPCRC\t0x20000000\n#define RXCFG_RX_FD\t0x10000000\n#define RXCFG_ALP\t0x08000000\n#define RXCFG_AIRL\t0x04000000\n#define RXCFG_MXDMA512\t0x00700000\n#define RXCFG_DRTH\t0x0000003e\n#define RXCFG_DRTH0\t0x00000002\n\n#define RFCR_RFEN\t0x80000000\n#define RFCR_AAB\t0x40000000\n#define RFCR_AAM\t0x20000000\n#define RFCR_AAU\t0x10000000\n#define RFCR_APM\t0x08000000\n#define RFCR_APAT\t0x07800000\n#define RFCR_APAT3\t0x04000000\n#define RFCR_APAT2\t0x02000000\n#define RFCR_APAT1\t0x01000000\n#define RFCR_APAT0\t0x00800000\n#define RFCR_AARP\t0x00400000\n#define RFCR_MHEN\t0x00200000\n#define RFCR_UHEN\t0x00100000\n#define RFCR_ULM\t0x00080000\n\n#define VRCR_RUDPE\t0x00000080\n#define VRCR_RTCPE\t0x00000040\n#define VRCR_RIPE\t0x00000020\n#define VRCR_IPEN\t0x00000010\n#define VRCR_DUTF\t0x00000008\n#define VRCR_DVTF\t0x00000004\n#define VRCR_VTREN\t0x00000002\n#define VRCR_VTDEN\t0x00000001\n\n#define VTCR_PPCHK\t0x00000008\n#define VTCR_GCHK\t0x00000004\n#define VTCR_VPPTI\t0x00000002\n#define VTCR_VGTI\t0x00000001\n\n#define CR\t\t0x00\n#define CFG\t\t0x04\n#define MEAR\t\t0x08\n#define PTSCR\t\t0x0c\n#define\tISR\t\t0x10\n#define\tIMR\t\t0x14\n#define\tIER\t\t0x18\n#define\tIHR\t\t0x1c\n#define TXDP\t\t0x20\n#define TXDP_HI\t\t0x24\n#define TXCFG\t\t0x28\n#define GPIOR\t\t0x2c\n#define RXDP\t\t0x30\n#define RXDP_HI\t\t0x34\n#define RXCFG\t\t0x38\n#define PQCR\t\t0x3c\n#define WCSR\t\t0x40\n#define PCR\t\t0x44\n#define RFCR\t\t0x48\n#define RFDR\t\t0x4c\n\n#define SRR\t\t0x58\n\n#define VRCR\t\t0xbc\n#define VTCR\t\t0xc0\n#define VDR\t\t0xc4\n#define CCSR\t\t0xcc\n\n#define TBICR\t\t0xe0\n#define TBISR\t\t0xe4\n#define TANAR\t\t0xe8\n#define TANLPAR\t\t0xec\n#define TANER\t\t0xf0\n#define TESR\t\t0xf4\n\n#define TBICR_MR_AN_ENABLE\t0x00001000\n#define TBICR_MR_RESTART_AN\t0x00000200\n\n#define TBISR_MR_LINK_STATUS\t0x00000020\n#define TBISR_MR_AN_COMPLETE\t0x00000004\n\n#define TANAR_PS2 \t\t0x00000100\n#define TANAR_PS1 \t\t0x00000080\n#define TANAR_HALF_DUP \t\t0x00000040\n#define TANAR_FULL_DUP \t\t0x00000020\n\n#define GPIOR_GP5_OE\t\t0x00000200\n#define GPIOR_GP4_OE\t\t0x00000100\n#define GPIOR_GP3_OE\t\t0x00000080\n#define GPIOR_GP2_OE\t\t0x00000040\n#define GPIOR_GP1_OE\t\t0x00000020\n#define GPIOR_GP3_OUT\t\t0x00000004\n#define GPIOR_GP1_OUT\t\t0x00000001\n\n#define LINK_AUTONEGOTIATE\t0x01\n#define LINK_DOWN\t\t0x02\n#define LINK_UP\t\t\t0x04\n\n#define HW_ADDR_LEN\tsizeof(dma_addr_t)\n#define desc_addr_set(desc, addr)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\t((desc)[0] = cpu_to_le32(addr));\t\t\\\n\t\tif (HW_ADDR_LEN == 8)\t\t \t\t\\\n\t\t\t(desc)[1] = cpu_to_le32(((u64)addr) >> 32);\t\\\n\t} while(0)\n#define desc_addr_get(desc)\t\t\t\t\t\\\n\t(le32_to_cpu((desc)[0]) | \\\n\t(HW_ADDR_LEN == 8 ? ((dma_addr_t)le32_to_cpu((desc)[1]))<<32 : 0))\n\n#define DESC_LINK\t\t0\n#define DESC_BUFPTR\t\t(DESC_LINK + HW_ADDR_LEN/4)\n#define DESC_CMDSTS\t\t(DESC_BUFPTR + HW_ADDR_LEN/4)\n#define DESC_EXTSTS\t\t(DESC_CMDSTS + 4/4)\n\n#define CMDSTS_OWN\t0x80000000\n#define CMDSTS_MORE\t0x40000000\n#define CMDSTS_INTR\t0x20000000\n#define CMDSTS_ERR\t0x10000000\n#define CMDSTS_OK\t0x08000000\n#define CMDSTS_RUNT\t0x00200000\n#define CMDSTS_LEN_MASK\t0x0000ffff\n\n#define CMDSTS_DEST_MASK\t0x01800000\n#define CMDSTS_DEST_SELF\t0x00800000\n#define CMDSTS_DEST_MULTI\t0x01000000\n\n#define DESC_SIZE\t8\t\t \n\nstruct rx_info {\n\tspinlock_t\tlock;\n\tint\t\tup;\n\tunsigned long\tidle;\n\n\tstruct sk_buff\t*skbs[NR_RX_DESC];\n\n\t__le32\t\t*next_rx_desc;\n\tu16\t\tnext_rx, next_empty;\n\n\t__le32\t\t*descs;\n\tdma_addr_t\tphy_descs;\n};\n\n\nstruct ns83820 {\n\tu8\t\t\t__iomem *base;\n\n\tstruct pci_dev\t\t*pci_dev;\n\tstruct net_device\t*ndev;\n\n\tstruct rx_info\t\trx_info;\n\tstruct tasklet_struct\trx_tasklet;\n\n\tunsigned\t\tihr;\n\tstruct work_struct\ttq_refill;\n\n\t \n\tspinlock_t\t\tmisc_lock;\n\n\tu32\t\t\tCFG_cache;\n\n\tu32\t\t\tMEAR_cache;\n\tu32\t\t\tIMR_cache;\n\n\tunsigned\t\tlinkstate;\n\n\tspinlock_t\ttx_lock;\n\n\tu16\t\ttx_done_idx;\n\tu16\t\ttx_idx;\n\tvolatile u16\ttx_free_idx;\t \n\tu16\t\ttx_intr_idx;\n\n\tatomic_t\tnr_tx_skbs;\n\tstruct sk_buff\t*tx_skbs[NR_TX_DESC];\n\n\tchar\t\tpad[16] __attribute__((aligned(16)));\n\t__le32\t\t*tx_descs;\n\tdma_addr_t\ttx_phy_descs;\n\n\tstruct timer_list\ttx_watchdog;\n};\n\nstatic inline struct ns83820 *PRIV(struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\n#define __kick_rx(dev)\twritel(CR_RXE, dev->base + CR)\n\nstatic inline void kick_rx(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tdprintk(\"kick_rx: maybe kicking\\n\");\n\tif (test_and_clear_bit(0, &dev->rx_info.idle)) {\n\t\tdprintk(\"actually kicking\\n\");\n\t\twritel(dev->rx_info.phy_descs +\n\t\t\t(4 * DESC_SIZE * dev->rx_info.next_rx),\n\t\t       dev->base + RXDP);\n\t\tif (dev->rx_info.next_rx == dev->rx_info.next_empty)\n\t\t\tprintk(KERN_DEBUG \"%s: uh-oh: next_rx == next_empty???\\n\",\n\t\t\t\tndev->name);\n\t\t__kick_rx(dev);\n\t}\n}\n\n\n#define start_tx_okay(dev)\t\\\n\t(((NR_TX_DESC-2 + dev->tx_done_idx - dev->tx_free_idx) % NR_TX_DESC) > MIN_TX_DESC_FREE)\n\n \nstatic inline void build_rx_desc(struct ns83820 *dev, __le32 *desc, dma_addr_t link, dma_addr_t buf, u32 cmdsts, u32 extsts)\n{\n\tdesc_addr_set(desc + DESC_LINK, link);\n\tdesc_addr_set(desc + DESC_BUFPTR, buf);\n\tdesc[DESC_EXTSTS] = cpu_to_le32(extsts);\n\tmb();\n\tdesc[DESC_CMDSTS] = cpu_to_le32(cmdsts);\n}\n\n#define nr_rx_empty(dev) ((NR_RX_DESC-2 + dev->rx_info.next_rx - dev->rx_info.next_empty) % NR_RX_DESC)\nstatic inline int ns83820_add_rx_skb(struct ns83820 *dev, struct sk_buff *skb)\n{\n\tunsigned next_empty;\n\tu32 cmdsts;\n\t__le32 *sg;\n\tdma_addr_t buf;\n\n\tnext_empty = dev->rx_info.next_empty;\n\n\t \n\tif (unlikely(nr_rx_empty(dev) <= 2)) {\n\t\tkfree_skb(skb);\n\t\treturn 1;\n\t}\n\n#if 0\n\tdprintk(\"next_empty[%d] nr_used[%d] next_rx[%d]\\n\",\n\t\tdev->rx_info.next_empty,\n\t\tdev->rx_info.nr_used,\n\t\tdev->rx_info.next_rx\n\t\t);\n#endif\n\n\tsg = dev->rx_info.descs + (next_empty * DESC_SIZE);\n\tBUG_ON(NULL != dev->rx_info.skbs[next_empty]);\n\tdev->rx_info.skbs[next_empty] = skb;\n\n\tdev->rx_info.next_empty = (next_empty + 1) % NR_RX_DESC;\n\tcmdsts = REAL_RX_BUF_SIZE | CMDSTS_INTR;\n\tbuf = dma_map_single(&dev->pci_dev->dev, skb->data, REAL_RX_BUF_SIZE,\n\t\t\t     DMA_FROM_DEVICE);\n\tbuild_rx_desc(dev, sg, 0, buf, cmdsts, 0);\n\t \n\tif (likely(next_empty != dev->rx_info.next_rx))\n\t\tdev->rx_info.descs[((NR_RX_DESC + next_empty - 1) % NR_RX_DESC) * DESC_SIZE] = cpu_to_le32(dev->rx_info.phy_descs + (next_empty * DESC_SIZE * 4));\n\n\treturn 0;\n}\n\nstatic inline int rx_refill(struct net_device *ndev, gfp_t gfp)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tunsigned i;\n\tunsigned long flags = 0;\n\n\tif (unlikely(nr_rx_empty(dev) <= 2))\n\t\treturn 0;\n\n\tdprintk(\"rx_refill(%p)\\n\", ndev);\n\tif (gfp == GFP_ATOMIC)\n\t\tspin_lock_irqsave(&dev->rx_info.lock, flags);\n\tfor (i=0; i<NR_RX_DESC; i++) {\n\t\tstruct sk_buff *skb;\n\t\tlong res;\n\n\t\t \n\t\tskb = __netdev_alloc_skb(ndev, REAL_RX_BUF_SIZE+16, gfp);\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\n\t\tskb_reserve(skb, skb->data - PTR_ALIGN(skb->data, 16));\n\t\tif (gfp != GFP_ATOMIC)\n\t\t\tspin_lock_irqsave(&dev->rx_info.lock, flags);\n\t\tres = ns83820_add_rx_skb(dev, skb);\n\t\tif (gfp != GFP_ATOMIC)\n\t\t\tspin_unlock_irqrestore(&dev->rx_info.lock, flags);\n\t\tif (res) {\n\t\t\ti = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (gfp == GFP_ATOMIC)\n\t\tspin_unlock_irqrestore(&dev->rx_info.lock, flags);\n\n\treturn i ? 0 : -ENOMEM;\n}\n\nstatic void rx_refill_atomic(struct net_device *ndev)\n{\n\trx_refill(ndev, GFP_ATOMIC);\n}\n\n \nstatic inline void queue_refill(struct work_struct *work)\n{\n\tstruct ns83820 *dev = container_of(work, struct ns83820, tq_refill);\n\tstruct net_device *ndev = dev->ndev;\n\n\trx_refill(ndev, GFP_KERNEL);\n\tif (dev->rx_info.up)\n\t\tkick_rx(ndev);\n}\n\nstatic inline void clear_rx_desc(struct ns83820 *dev, unsigned i)\n{\n\tbuild_rx_desc(dev, dev->rx_info.descs + (DESC_SIZE * i), 0, 0, CMDSTS_OWN, 0);\n}\n\nstatic void phy_intr(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tstatic const char *speeds[] = { \"10\", \"100\", \"1000\", \"1000(?)\", \"1000F\" };\n\tu32 cfg, new_cfg;\n\tu32 tanar, tanlpar;\n\tint speed, fullduplex, newlinkstate;\n\n\tcfg = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\n\n\tif (dev->CFG_cache & CFG_TBI_EN) {\n\t\tu32 __maybe_unused tbisr;\n\n\t\t \n\t\ttbisr = readl(dev->base + TBISR);\n\t\ttanar = readl(dev->base + TANAR);\n\t\ttanlpar = readl(dev->base + TANLPAR);\n\t\tdprintk(\"phy_intr: tbisr=%08x, tanar=%08x, tanlpar=%08x\\n\",\n\t\t\ttbisr, tanar, tanlpar);\n\n\t\tif ( (fullduplex = (tanlpar & TANAR_FULL_DUP) &&\n\t\t      (tanar & TANAR_FULL_DUP)) ) {\n\n\t\t\t \n\t\t\twritel(readl(dev->base + TXCFG)\n\t\t\t       | TXCFG_CSI | TXCFG_HBI | TXCFG_ATP,\n\t\t\t       dev->base + TXCFG);\n\t\t\twritel(readl(dev->base + RXCFG) | RXCFG_RX_FD,\n\t\t\t       dev->base + RXCFG);\n\t\t\t \n\t\t\twritel(readl(dev->base + GPIOR) | GPIOR_GP1_OUT,\n\t\t\t       dev->base + GPIOR);\n\n\t\t} else if (((tanlpar & TANAR_HALF_DUP) &&\n\t\t\t    (tanar & TANAR_HALF_DUP)) ||\n\t\t\t   ((tanlpar & TANAR_FULL_DUP) &&\n\t\t\t    (tanar & TANAR_HALF_DUP)) ||\n\t\t\t   ((tanlpar & TANAR_HALF_DUP) &&\n\t\t\t    (tanar & TANAR_FULL_DUP))) {\n\n\t\t\t \n\t\t\twritel((readl(dev->base + TXCFG)\n\t\t\t\t& ~(TXCFG_CSI | TXCFG_HBI)) | TXCFG_ATP,\n\t\t\t       dev->base + TXCFG);\n\t\t\twritel(readl(dev->base + RXCFG) & ~RXCFG_RX_FD,\n\t\t\t       dev->base + RXCFG);\n\t\t\t \n\t\t\twritel(readl(dev->base + GPIOR) & ~GPIOR_GP1_OUT,\n\t\t\t       dev->base + GPIOR);\n\t\t}\n\n\t\tspeed = 4;  \n\n\t} else {\n\t\t \n\t\tnew_cfg = dev->CFG_cache & ~(CFG_SB | CFG_MODE_1000 | CFG_SPDSTS);\n\n\t\tif (cfg & CFG_SPDSTS1)\n\t\t\tnew_cfg |= CFG_MODE_1000;\n\t\telse\n\t\t\tnew_cfg &= ~CFG_MODE_1000;\n\n\t\tspeed = ((cfg / CFG_SPDSTS0) & 3);\n\t\tfullduplex = (cfg & CFG_DUPSTS);\n\n\t\tif (fullduplex) {\n\t\t\tnew_cfg |= CFG_SB;\n\t\t\twritel(readl(dev->base + TXCFG)\n\t\t\t\t\t| TXCFG_CSI | TXCFG_HBI,\n\t\t\t       dev->base + TXCFG);\n\t\t\twritel(readl(dev->base + RXCFG) | RXCFG_RX_FD,\n\t\t\t       dev->base + RXCFG);\n\t\t} else {\n\t\t\twritel(readl(dev->base + TXCFG)\n\t\t\t\t\t& ~(TXCFG_CSI | TXCFG_HBI),\n\t\t\t       dev->base + TXCFG);\n\t\t\twritel(readl(dev->base + RXCFG) & ~(RXCFG_RX_FD),\n\t\t\t       dev->base + RXCFG);\n\t\t}\n\n\t\tif ((cfg & CFG_LNKSTS) &&\n\t\t    ((new_cfg ^ dev->CFG_cache) != 0)) {\n\t\t\twritel(new_cfg, dev->base + CFG);\n\t\t\tdev->CFG_cache = new_cfg;\n\t\t}\n\n\t\tdev->CFG_cache &= ~CFG_SPDSTS;\n\t\tdev->CFG_cache |= cfg & CFG_SPDSTS;\n\t}\n\n\tnewlinkstate = (cfg & CFG_LNKSTS) ? LINK_UP : LINK_DOWN;\n\n\tif (newlinkstate & LINK_UP &&\n\t    dev->linkstate != newlinkstate) {\n\t\tnetif_start_queue(ndev);\n\t\tnetif_wake_queue(ndev);\n\t\tprintk(KERN_INFO \"%s: link now %s mbps, %s duplex and up.\\n\",\n\t\t\tndev->name,\n\t\t\tspeeds[speed],\n\t\t\tfullduplex ? \"full\" : \"half\");\n\t} else if (newlinkstate & LINK_DOWN &&\n\t\t   dev->linkstate != newlinkstate) {\n\t\tnetif_stop_queue(ndev);\n\t\tprintk(KERN_INFO \"%s: link now down.\\n\", ndev->name);\n\t}\n\n\tdev->linkstate = newlinkstate;\n}\n\nstatic int ns83820_setup_rx(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tunsigned i;\n\tint ret;\n\n\tdprintk(\"ns83820_setup_rx(%p)\\n\", ndev);\n\n\tdev->rx_info.idle = 1;\n\tdev->rx_info.next_rx = 0;\n\tdev->rx_info.next_rx_desc = dev->rx_info.descs;\n\tdev->rx_info.next_empty = 0;\n\n\tfor (i=0; i<NR_RX_DESC; i++)\n\t\tclear_rx_desc(dev, i);\n\n\twritel(0, dev->base + RXDP_HI);\n\twritel(dev->rx_info.phy_descs, dev->base + RXDP);\n\n\tret = rx_refill(ndev, GFP_KERNEL);\n\tif (!ret) {\n\t\tdprintk(\"starting receiver\\n\");\n\t\t \n\t\tspin_lock_irq(&dev->rx_info.lock);\n\n\t\twritel(0x0001, dev->base + CCSR);\n\t\twritel(0, dev->base + RFCR);\n\t\twritel(0x7fc00000, dev->base + RFCR);\n\t\twritel(0xffc00000, dev->base + RFCR);\n\n\t\tdev->rx_info.up = 1;\n\n\t\tphy_intr(ndev);\n\n\t\t \n\t\tspin_lock(&dev->misc_lock);\n\t\tdev->IMR_cache |= ISR_PHY;\n\t\tdev->IMR_cache |= ISR_RXRCMP;\n\t\t \n\t\t \n\t\tdev->IMR_cache |= ISR_RXORN;\n\t\tdev->IMR_cache |= ISR_RXSOVR;\n\t\tdev->IMR_cache |= ISR_RXDESC;\n\t\tdev->IMR_cache |= ISR_RXIDLE;\n\t\tdev->IMR_cache |= ISR_TXDESC;\n\t\tdev->IMR_cache |= ISR_TXIDLE;\n\n\t\twritel(dev->IMR_cache, dev->base + IMR);\n\t\twritel(1, dev->base + IER);\n\t\tspin_unlock(&dev->misc_lock);\n\n\t\tkick_rx(ndev);\n\n\t\tspin_unlock_irq(&dev->rx_info.lock);\n\t}\n\treturn ret;\n}\n\nstatic void ns83820_cleanup_rx(struct ns83820 *dev)\n{\n\tunsigned i;\n\tunsigned long flags;\n\n\tdprintk(\"ns83820_cleanup_rx(%p)\\n\", dev);\n\n\t \n\tspin_lock_irqsave(&dev->misc_lock, flags);\n\tdev->IMR_cache &= ~(ISR_RXOK | ISR_RXDESC | ISR_RXERR | ISR_RXEARLY | ISR_RXIDLE);\n\twritel(dev->IMR_cache, dev->base + IMR);\n\tspin_unlock_irqrestore(&dev->misc_lock, flags);\n\n\t \n\tdev->rx_info.up = 0;\n\tsynchronize_irq(dev->pci_dev->irq);\n\n\t \n\treadl(dev->base + IMR);\n\n\t \n\twritel(0, dev->base + RXDP_HI);\n\twritel(0, dev->base + RXDP);\n\n\tfor (i=0; i<NR_RX_DESC; i++) {\n\t\tstruct sk_buff *skb = dev->rx_info.skbs[i];\n\t\tdev->rx_info.skbs[i] = NULL;\n\t\tclear_rx_desc(dev, i);\n\t\tkfree_skb(skb);\n\t}\n}\n\nstatic void ns83820_rx_kick(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\t  {\n\t\tif (dev->rx_info.up) {\n\t\t\trx_refill_atomic(ndev);\n\t\t\tkick_rx(ndev);\n\t\t}\n\t}\n\n\tif (dev->rx_info.up && nr_rx_empty(dev) > NR_RX_DESC*3/4)\n\t\tschedule_work(&dev->tq_refill);\n\telse\n\t\tkick_rx(ndev);\n\tif (dev->rx_info.idle)\n\t\tprintk(KERN_DEBUG \"%s: BAD\\n\", ndev->name);\n}\n\n \nstatic void rx_irq(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tstruct rx_info *info = &dev->rx_info;\n\tunsigned next_rx;\n\tint rx_rc, len;\n\tu32 cmdsts;\n\t__le32 *desc;\n\tunsigned long flags;\n\tint nr = 0;\n\n\tdprintk(\"rx_irq(%p)\\n\", ndev);\n\tdprintk(\"rxdp: %08x, descs: %08lx next_rx[%d]: %p next_empty[%d]: %p\\n\",\n\t\treadl(dev->base + RXDP),\n\t\t(long)(dev->rx_info.phy_descs),\n\t\t(int)dev->rx_info.next_rx,\n\t\t(dev->rx_info.descs + (DESC_SIZE * dev->rx_info.next_rx)),\n\t\t(int)dev->rx_info.next_empty,\n\t\t(dev->rx_info.descs + (DESC_SIZE * dev->rx_info.next_empty))\n\t\t);\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tif (!info->up)\n\t\tgoto out;\n\n\tdprintk(\"walking descs\\n\");\n\tnext_rx = info->next_rx;\n\tdesc = info->next_rx_desc;\n\twhile ((CMDSTS_OWN & (cmdsts = le32_to_cpu(desc[DESC_CMDSTS]))) &&\n\t       (cmdsts != CMDSTS_OWN)) {\n\t\tstruct sk_buff *skb;\n\t\tu32 extsts = le32_to_cpu(desc[DESC_EXTSTS]);\n\t\tdma_addr_t bufptr = desc_addr_get(desc + DESC_BUFPTR);\n\n\t\tdprintk(\"cmdsts: %08x\\n\", cmdsts);\n\t\tdprintk(\"link: %08x\\n\", cpu_to_le32(desc[DESC_LINK]));\n\t\tdprintk(\"extsts: %08x\\n\", extsts);\n\n\t\tskb = info->skbs[next_rx];\n\t\tinfo->skbs[next_rx] = NULL;\n\t\tinfo->next_rx = (next_rx + 1) % NR_RX_DESC;\n\n\t\tmb();\n\t\tclear_rx_desc(dev, next_rx);\n\n\t\tdma_unmap_single(&dev->pci_dev->dev, bufptr, RX_BUF_SIZE,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tlen = cmdsts & CMDSTS_LEN_MASK;\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\n\t\t \n\t\tif (likely((CMDSTS_OK & cmdsts) ||\n\t\t\t((cmdsts & CMDSTS_RUNT) && len >= 56))) {\n#else\n\t\tif (likely(CMDSTS_OK & cmdsts)) {\n#endif\n\t\t\tskb_put(skb, len);\n\t\t\tif (unlikely(!skb))\n\t\t\t\tgoto netdev_mangle_me_harder_failed;\n\t\t\tif (cmdsts & CMDSTS_DEST_MULTI)\n\t\t\t\tndev->stats.multicast++;\n\t\t\tndev->stats.rx_packets++;\n\t\t\tndev->stats.rx_bytes += len;\n\t\t\tif ((extsts & 0x002a0000) && !(extsts & 0x00540000)) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t} else {\n\t\t\t\tskb_checksum_none_assert(skb);\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, ndev);\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\n\t\t\tif(extsts & EXTSTS_VPKT) {\n\t\t\t\tunsigned short tag;\n\n\t\t\t\ttag = ntohs(extsts & EXTSTS_VTG_MASK);\n\t\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_IPV6), tag);\n\t\t\t}\n#endif\n\t\t\trx_rc = netif_rx(skb);\n\t\t\tif (NET_RX_DROP == rx_rc) {\nnetdev_mangle_me_harder_failed:\n\t\t\t\tndev->stats.rx_dropped++;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t}\n\n\t\tnr++;\n\t\tnext_rx = info->next_rx;\n\t\tdesc = info->descs + (DESC_SIZE * next_rx);\n\t}\n\tinfo->next_rx = next_rx;\n\tinfo->next_rx_desc = info->descs + (DESC_SIZE * next_rx);\n\nout:\n\tif (0 && !nr) {\n\t\tDprintk(\"dazed: cmdsts_f: %08x\\n\", cmdsts);\n\t}\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n}\n\nstatic void rx_action(struct tasklet_struct *t)\n{\n\tstruct ns83820 *dev = from_tasklet(dev, t, rx_tasklet);\n\tstruct net_device *ndev = dev->ndev;\n\trx_irq(ndev);\n\twritel(ihr, dev->base + IHR);\n\n\tspin_lock_irq(&dev->misc_lock);\n\tdev->IMR_cache |= ISR_RXDESC;\n\twritel(dev->IMR_cache, dev->base + IMR);\n\tspin_unlock_irq(&dev->misc_lock);\n\n\trx_irq(ndev);\n\tns83820_rx_kick(ndev);\n}\n\n \nstatic inline void kick_tx(struct ns83820 *dev)\n{\n\tdprintk(\"kick_tx(%p): tx_idx=%d free_idx=%d\\n\",\n\t\tdev, dev->tx_idx, dev->tx_free_idx);\n\twritel(CR_TXE, dev->base + CR);\n}\n\n \nstatic void do_tx_done(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tu32 cmdsts, tx_done_idx;\n\t__le32 *desc;\n\n\tdprintk(\"do_tx_done(%p)\\n\", ndev);\n\ttx_done_idx = dev->tx_done_idx;\n\tdesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\n\n\tdprintk(\"tx_done_idx=%d free_idx=%d cmdsts=%08x\\n\",\n\t\ttx_done_idx, dev->tx_free_idx, le32_to_cpu(desc[DESC_CMDSTS]));\n\twhile ((tx_done_idx != dev->tx_free_idx) &&\n\t       !(CMDSTS_OWN & (cmdsts = le32_to_cpu(desc[DESC_CMDSTS]))) ) {\n\t\tstruct sk_buff *skb;\n\t\tunsigned len;\n\t\tdma_addr_t addr;\n\n\t\tif (cmdsts & CMDSTS_ERR)\n\t\t\tndev->stats.tx_errors++;\n\t\tif (cmdsts & CMDSTS_OK)\n\t\t\tndev->stats.tx_packets++;\n\t\tif (cmdsts & CMDSTS_OK)\n\t\t\tndev->stats.tx_bytes += cmdsts & 0xffff;\n\n\t\tdprintk(\"tx_done_idx=%d free_idx=%d cmdsts=%08x\\n\",\n\t\t\ttx_done_idx, dev->tx_free_idx, cmdsts);\n\t\tskb = dev->tx_skbs[tx_done_idx];\n\t\tdev->tx_skbs[tx_done_idx] = NULL;\n\t\tdprintk(\"done(%p)\\n\", skb);\n\n\t\tlen = cmdsts & CMDSTS_LEN_MASK;\n\t\taddr = desc_addr_get(desc + DESC_BUFPTR);\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&dev->pci_dev->dev, addr, len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_consume_skb_irq(skb);\n\t\t\tatomic_dec(&dev->nr_tx_skbs);\n\t\t} else\n\t\t\tdma_unmap_page(&dev->pci_dev->dev, addr, len,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\ttx_done_idx = (tx_done_idx + 1) % NR_TX_DESC;\n\t\tdev->tx_done_idx = tx_done_idx;\n\t\tdesc[DESC_CMDSTS] = cpu_to_le32(0);\n\t\tmb();\n\t\tdesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\n\t}\n\n\t \n\tif (netif_queue_stopped(ndev) && start_tx_okay(dev)) {\n\t\tdprintk(\"start_queue(%p)\\n\", ndev);\n\t\tnetif_start_queue(ndev);\n\t\tnetif_wake_queue(ndev);\n\t}\n}\n\nstatic void ns83820_cleanup_tx(struct ns83820 *dev)\n{\n\tunsigned i;\n\n\tfor (i=0; i<NR_TX_DESC; i++) {\n\t\tstruct sk_buff *skb = dev->tx_skbs[i];\n\t\tdev->tx_skbs[i] = NULL;\n\t\tif (skb) {\n\t\t\t__le32 *desc = dev->tx_descs + (i * DESC_SIZE);\n\t\t\tdma_unmap_single(&dev->pci_dev->dev,\n\t\t\t\t\t desc_addr_get(desc + DESC_BUFPTR),\n\t\t\t\t\t le32_to_cpu(desc[DESC_CMDSTS]) & CMDSTS_LEN_MASK,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tatomic_dec(&dev->nr_tx_skbs);\n\t\t}\n\t}\n\n\tmemset(dev->tx_descs, 0, NR_TX_DESC * DESC_SIZE * 4);\n}\n\n \nstatic netdev_tx_t ns83820_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tu32 free_idx, cmdsts, extsts;\n\tint nr_free, nr_frags;\n\tunsigned tx_done_idx, last_idx;\n\tdma_addr_t buf;\n\tunsigned len;\n\tskb_frag_t *frag;\n\tint stopped = 0;\n\tint do_intr = 0;\n\tvolatile __le32 *first_desc;\n\n\tdprintk(\"ns83820_hard_start_xmit\\n\");\n\n\tnr_frags =  skb_shinfo(skb)->nr_frags;\nagain:\n\tif (unlikely(dev->CFG_cache & CFG_LNKSTS)) {\n\t\tnetif_stop_queue(ndev);\n\t\tif (unlikely(dev->CFG_cache & CFG_LNKSTS))\n\t\t\treturn NETDEV_TX_BUSY;\n\t\tnetif_start_queue(ndev);\n\t}\n\n\tlast_idx = free_idx = dev->tx_free_idx;\n\ttx_done_idx = dev->tx_done_idx;\n\tnr_free = (tx_done_idx + NR_TX_DESC-2 - free_idx) % NR_TX_DESC;\n\tnr_free -= 1;\n\tif (nr_free <= nr_frags) {\n\t\tdprintk(\"stop_queue - not enough(%p)\\n\", ndev);\n\t\tnetif_stop_queue(ndev);\n\n\t\t \n\t\tif (dev->tx_done_idx != tx_done_idx) {\n\t\t\tdprintk(\"restart queue(%p)\\n\", ndev);\n\t\t\tnetif_start_queue(ndev);\n\t\t\tgoto again;\n\t\t}\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (free_idx == dev->tx_intr_idx) {\n\t\tdo_intr = 1;\n\t\tdev->tx_intr_idx = (dev->tx_intr_idx + NR_TX_DESC/4) % NR_TX_DESC;\n\t}\n\n\tnr_free -= nr_frags;\n\tif (nr_free < MIN_TX_DESC_FREE) {\n\t\tdprintk(\"stop_queue - last entry(%p)\\n\", ndev);\n\t\tnetif_stop_queue(ndev);\n\t\tstopped = 1;\n\t}\n\n\tfrag = skb_shinfo(skb)->frags;\n\tif (!nr_frags)\n\t\tfrag = NULL;\n\textsts = 0;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\textsts |= EXTSTS_IPPKT;\n\t\tif (IPPROTO_TCP == ip_hdr(skb)->protocol)\n\t\t\textsts |= EXTSTS_TCPPKT;\n\t\telse if (IPPROTO_UDP == ip_hdr(skb)->protocol)\n\t\t\textsts |= EXTSTS_UDPPKT;\n\t}\n\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\n\tif (skb_vlan_tag_present(skb)) {\n\t\t \n\t\tshort tag = skb_vlan_tag_get(skb);\n\t\textsts |= (EXTSTS_VPKT | htons(tag));\n\t}\n#endif\n\n\tlen = skb->len;\n\tif (nr_frags)\n\t\tlen -= skb->data_len;\n\tbuf = dma_map_single(&dev->pci_dev->dev, skb->data, len,\n\t\t\t     DMA_TO_DEVICE);\n\n\tfirst_desc = dev->tx_descs + (free_idx * DESC_SIZE);\n\n\tfor (;;) {\n\t\tvolatile __le32 *desc = dev->tx_descs + (free_idx * DESC_SIZE);\n\n\t\tdprintk(\"frag[%3u]: %4u @ 0x%08Lx\\n\", free_idx, len,\n\t\t\t(unsigned long long)buf);\n\t\tlast_idx = free_idx;\n\t\tfree_idx = (free_idx + 1) % NR_TX_DESC;\n\t\tdesc[DESC_LINK] = cpu_to_le32(dev->tx_phy_descs + (free_idx * DESC_SIZE * 4));\n\t\tdesc_addr_set(desc + DESC_BUFPTR, buf);\n\t\tdesc[DESC_EXTSTS] = cpu_to_le32(extsts);\n\n\t\tcmdsts = ((nr_frags) ? CMDSTS_MORE : do_intr ? CMDSTS_INTR : 0);\n\t\tcmdsts |= (desc == first_desc) ? 0 : CMDSTS_OWN;\n\t\tcmdsts |= len;\n\t\tdesc[DESC_CMDSTS] = cpu_to_le32(cmdsts);\n\n\t\tif (!nr_frags)\n\t\t\tbreak;\n\n\t\tbuf = skb_frag_dma_map(&dev->pci_dev->dev, frag, 0,\n\t\t\t\t       skb_frag_size(frag), DMA_TO_DEVICE);\n\t\tdprintk(\"frag: buf=%08Lx  page=%08lx offset=%08lx\\n\",\n\t\t\t(long long)buf, (long) page_to_pfn(frag->page),\n\t\t\tfrag->page_offset);\n\t\tlen = skb_frag_size(frag);\n\t\tfrag++;\n\t\tnr_frags--;\n\t}\n\tdprintk(\"done pkt\\n\");\n\n\tspin_lock_irq(&dev->tx_lock);\n\tdev->tx_skbs[last_idx] = skb;\n\tfirst_desc[DESC_CMDSTS] |= cpu_to_le32(CMDSTS_OWN);\n\tdev->tx_free_idx = free_idx;\n\tatomic_inc(&dev->nr_tx_skbs);\n\tspin_unlock_irq(&dev->tx_lock);\n\n\tkick_tx(dev);\n\n\t \n\tif (stopped && (dev->tx_done_idx != tx_done_idx) && start_tx_okay(dev))\n\t\tnetif_start_queue(ndev);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ns83820_update_stats(struct ns83820 *dev)\n{\n\tstruct net_device *ndev = dev->ndev;\n\tu8 __iomem *base = dev->base;\n\n\t \n\tndev->stats.rx_errors\t\t+= readl(base + 0x60) & 0xffff;\n\tndev->stats.rx_crc_errors\t+= readl(base + 0x64) & 0xffff;\n\tndev->stats.rx_missed_errors\t+= readl(base + 0x68) & 0xffff;\n\tndev->stats.rx_frame_errors\t+= readl(base + 0x6c) & 0xffff;\n\t  readl(base + 0x70);\n\tndev->stats.rx_length_errors\t+= readl(base + 0x74) & 0xffff;\n\tndev->stats.rx_length_errors\t+= readl(base + 0x78) & 0xffff;\n\t  readl(base + 0x7c);\n\t   readl(base + 0x80);\n\t   readl(base + 0x84);\n\tndev->stats.tx_carrier_errors\t+= readl(base + 0x88) & 0xff;\n}\n\nstatic struct net_device_stats *ns83820_get_stats(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\n\t \n\tspin_lock_irq(&dev->misc_lock);\n\tns83820_update_stats(dev);\n\tspin_unlock_irq(&dev->misc_lock);\n\n\treturn &ndev->stats;\n}\n\n \nstatic int ns83820_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tu32 cfg, tbicr;\n\tint fullduplex   = 0;\n\tu32 supported;\n\n\t \n\n\t \n\tcfg   = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\n\treadl(dev->base + TANAR);\n\ttbicr = readl(dev->base + TBICR);\n\n\tfullduplex = (cfg & CFG_DUPSTS) ? 1 : 0;\n\n\tsupported = SUPPORTED_Autoneg;\n\n\tif (dev->CFG_cache & CFG_TBI_EN) {\n\t\t \n\t\tsupported |= SUPPORTED_1000baseT_Half |\n\t\t\t\t\tSUPPORTED_1000baseT_Full |\n\t\t\t\t\tSUPPORTED_FIBRE;\n\t\tcmd->base.port       = PORT_FIBRE;\n\t} else {\n\t\t \n\t\tsupported |= SUPPORTED_10baseT_Half |\n\t\t\tSUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half |\n\t\t\tSUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Half |\n\t\t\tSUPPORTED_1000baseT_Full |\n\t\t\tSUPPORTED_MII;\n\t\tcmd->base.port = PORT_MII;\n\t}\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\n\tcmd->base.duplex = fullduplex ? DUPLEX_FULL : DUPLEX_HALF;\n\tswitch (cfg / CFG_SPDSTS0 & 3) {\n\tcase 2:\n\t\tcmd->base.speed = SPEED_1000;\n\t\tbreak;\n\tcase 1:\n\t\tcmd->base.speed = SPEED_100;\n\t\tbreak;\n\tdefault:\n\t\tcmd->base.speed = SPEED_10;\n\t\tbreak;\n\t}\n\tcmd->base.autoneg = (tbicr & TBICR_MR_AN_ENABLE)\n\t\t? AUTONEG_ENABLE : AUTONEG_DISABLE;\n\treturn 0;\n}\n\n \nstatic int ns83820_set_link_ksettings(struct net_device *ndev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tu32 cfg, tanar;\n\tint have_optical = 0;\n\tint fullduplex   = 0;\n\n\t \n\tcfg = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\n\ttanar = readl(dev->base + TANAR);\n\n\tif (dev->CFG_cache & CFG_TBI_EN) {\n\t\t \n\t\thave_optical = 1;\n\t\tfullduplex   = (tanar & TANAR_FULL_DUP);\n\n\t} else {\n\t\t \n\t\tfullduplex = cfg & CFG_DUPSTS;\n\t}\n\n\tspin_lock_irq(&dev->misc_lock);\n\tspin_lock(&dev->tx_lock);\n\n\t \n\tif (cmd->base.duplex != fullduplex) {\n\t\tif (have_optical) {\n\t\t\t \n\t\t\tif (cmd->base.duplex == DUPLEX_FULL) {\n\t\t\t\t \n\t\t\t\twritel(readl(dev->base + TXCFG)\n\t\t\t\t\t| TXCFG_CSI | TXCFG_HBI | TXCFG_ATP,\n\t\t\t\t\tdev->base + TXCFG);\n\t\t\t\twritel(readl(dev->base + RXCFG) | RXCFG_RX_FD,\n\t\t\t\t\tdev->base + RXCFG);\n\t\t\t\t \n\t\t\t\twritel(readl(dev->base + GPIOR) | GPIOR_GP1_OUT,\n\t\t\t\t\tdev->base + GPIOR);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t}\n\t\tprintk(KERN_INFO \"%s: Duplex set via ethtool\\n\",\n\t\tndev->name);\n\t}\n\n\t \n\tif (1) {\n\t\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\t\t \n\t\t\twritel(TBICR_MR_AN_ENABLE | TBICR_MR_RESTART_AN,\n\t\t\t\tdev->base + TBICR);\n\t\t\twritel(TBICR_MR_AN_ENABLE, dev->base + TBICR);\n\t\t\t\tdev->linkstate = LINK_AUTONEGOTIATE;\n\n\t\t\tprintk(KERN_INFO \"%s: autoneg enabled via ethtool\\n\",\n\t\t\t\tndev->name);\n\t\t} else {\n\t\t\t \n\t\t\twritel(0x00000000, dev->base + TBICR);\n\t\t}\n\n\t\tprintk(KERN_INFO \"%s: autoneg %s via ethtool\\n\", ndev->name,\n\t\t\t\tcmd->base.autoneg ? \"ENABLED\" : \"DISABLED\");\n\t}\n\n\tphy_intr(ndev);\n\tspin_unlock(&dev->tx_lock);\n\tspin_unlock_irq(&dev->misc_lock);\n\n\treturn 0;\n}\n \n\nstatic void ns83820_get_drvinfo(struct net_device *ndev, struct ethtool_drvinfo *info)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tstrscpy(info->driver, \"ns83820\", sizeof(info->driver));\n\tstrscpy(info->version, VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(dev->pci_dev), sizeof(info->bus_info));\n}\n\nstatic u32 ns83820_get_link(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tu32 cfg = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\n\treturn cfg & CFG_LNKSTS ? 1 : 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo     = ns83820_get_drvinfo,\n\t.get_link        = ns83820_get_link,\n\t.get_link_ksettings = ns83820_get_link_ksettings,\n\t.set_link_ksettings = ns83820_set_link_ksettings,\n};\n\nstatic inline void ns83820_disable_interrupts(struct ns83820 *dev)\n{\n\twritel(0, dev->base + IMR);\n\twritel(0, dev->base + IER);\n\treadl(dev->base + IER);\n}\n\n \nstatic void ns83820_mib_isr(struct ns83820 *dev)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->misc_lock, flags);\n\tns83820_update_stats(dev);\n\tspin_unlock_irqrestore(&dev->misc_lock, flags);\n}\n\nstatic void ns83820_do_isr(struct net_device *ndev, u32 isr);\nstatic irqreturn_t ns83820_irq(int foo, void *data)\n{\n\tstruct net_device *ndev = data;\n\tstruct ns83820 *dev = PRIV(ndev);\n\tu32 isr;\n\tdprintk(\"ns83820_irq(%p)\\n\", ndev);\n\n\tdev->ihr = 0;\n\n\tisr = readl(dev->base + ISR);\n\tdprintk(\"irq: %08x\\n\", isr);\n\tns83820_do_isr(ndev, isr);\n\treturn IRQ_HANDLED;\n}\n\nstatic void ns83820_do_isr(struct net_device *ndev, u32 isr)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tunsigned long flags;\n\n#ifdef DEBUG\n\tif (isr & ~(ISR_PHY | ISR_RXDESC | ISR_RXEARLY | ISR_RXOK | ISR_RXERR | ISR_TXIDLE | ISR_TXOK | ISR_TXDESC))\n\t\tDprintk(\"odd isr? 0x%08x\\n\", isr);\n#endif\n\n\tif (ISR_RXIDLE & isr) {\n\t\tdev->rx_info.idle = 1;\n\t\tDprintk(\"oh dear, we are idle\\n\");\n\t\tns83820_rx_kick(ndev);\n\t}\n\n\tif ((ISR_RXDESC | ISR_RXOK) & isr) {\n\t\tprefetch(dev->rx_info.next_rx_desc);\n\n\t\tspin_lock_irqsave(&dev->misc_lock, flags);\n\t\tdev->IMR_cache &= ~(ISR_RXDESC | ISR_RXOK);\n\t\twritel(dev->IMR_cache, dev->base + IMR);\n\t\tspin_unlock_irqrestore(&dev->misc_lock, flags);\n\n\t\ttasklet_schedule(&dev->rx_tasklet);\n\t\t \n\t\t \n\t}\n\n\tif ((ISR_RXIDLE | ISR_RXORN | ISR_RXDESC | ISR_RXOK | ISR_RXERR) & isr)\n\t\tns83820_rx_kick(ndev);\n\n\tif (unlikely(ISR_RXSOVR & isr)) {\n\t\t \n\t\tndev->stats.rx_fifo_errors++;\n\t}\n\n\tif (unlikely(ISR_RXORN & isr)) {\n\t\t \n\t\tndev->stats.rx_fifo_errors++;\n\t}\n\n\tif ((ISR_RXRCMP & isr) && dev->rx_info.up)\n\t\twritel(CR_RXE, dev->base + CR);\n\n\tif (ISR_TXIDLE & isr) {\n\t\tu32 txdp;\n\t\ttxdp = readl(dev->base + TXDP);\n\t\tdprintk(\"txdp: %08x\\n\", txdp);\n\t\ttxdp -= dev->tx_phy_descs;\n\t\tdev->tx_idx = txdp / (DESC_SIZE * 4);\n\t\tif (dev->tx_idx >= NR_TX_DESC) {\n\t\t\tprintk(KERN_ALERT \"%s: BUG -- txdp out of range\\n\", ndev->name);\n\t\t\tdev->tx_idx = 0;\n\t\t}\n\t\t \n\t\tif (dev->tx_idx != dev->tx_free_idx)\n\t\t\tkick_tx(dev);\n\t}\n\n\t \n\tif ((ISR_TXDESC | ISR_TXIDLE | ISR_TXOK | ISR_TXERR) & isr) {\n\t\tspin_lock_irqsave(&dev->tx_lock, flags);\n\t\tdo_tx_done(ndev);\n\t\tspin_unlock_irqrestore(&dev->tx_lock, flags);\n\n\t\t \n\t\tif ((dev->tx_done_idx == dev->tx_free_idx) &&\n\t\t    (dev->IMR_cache & ISR_TXOK)) {\n\t\t\tspin_lock_irqsave(&dev->misc_lock, flags);\n\t\t\tdev->IMR_cache &= ~ISR_TXOK;\n\t\t\twritel(dev->IMR_cache, dev->base + IMR);\n\t\t\tspin_unlock_irqrestore(&dev->misc_lock, flags);\n\t\t}\n\t}\n\n\t \n\tif ((ISR_TXIDLE & isr) && (dev->tx_done_idx != dev->tx_free_idx)) {\n\t\tspin_lock_irqsave(&dev->misc_lock, flags);\n\t\tdev->IMR_cache |= ISR_TXOK;\n\t\twritel(dev->IMR_cache, dev->base + IMR);\n\t\tspin_unlock_irqrestore(&dev->misc_lock, flags);\n\t}\n\n\t \n\tif (unlikely(ISR_MIB & isr))\n\t\tns83820_mib_isr(dev);\n\n\t \n\tif (unlikely(ISR_PHY & isr))\n\t\tphy_intr(ndev);\n\n#if 0\t \n\tif (dev->ihr)\n\t\twritel(dev->ihr, dev->base + IHR);\n#endif\n}\n\nstatic void ns83820_do_reset(struct ns83820 *dev, u32 which)\n{\n\tDprintk(\"resetting chip...\\n\");\n\twritel(which, dev->base + CR);\n\tdo {\n\t\tschedule();\n\t} while (readl(dev->base + CR) & which);\n\tDprintk(\"okay!\\n\");\n}\n\nstatic int ns83820_stop(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\n\t \n\tdel_timer_sync(&dev->tx_watchdog);\n\n\tns83820_disable_interrupts(dev);\n\n\tdev->rx_info.up = 0;\n\tsynchronize_irq(dev->pci_dev->irq);\n\n\tns83820_do_reset(dev, CR_RST);\n\n\tsynchronize_irq(dev->pci_dev->irq);\n\n\tspin_lock_irq(&dev->misc_lock);\n\tdev->IMR_cache &= ~(ISR_TXURN | ISR_TXIDLE | ISR_TXERR | ISR_TXDESC | ISR_TXOK);\n\tspin_unlock_irq(&dev->misc_lock);\n\n\tns83820_cleanup_rx(dev);\n\tns83820_cleanup_tx(dev);\n\n\treturn 0;\n}\n\nstatic void ns83820_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n        u32 tx_done_idx;\n\t__le32 *desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->tx_lock, flags);\n\n\ttx_done_idx = dev->tx_done_idx;\n\tdesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\n\n\tprintk(KERN_INFO \"%s: tx_timeout: tx_done_idx=%d free_idx=%d cmdsts=%08x\\n\",\n\t\tndev->name,\n\t\ttx_done_idx, dev->tx_free_idx, le32_to_cpu(desc[DESC_CMDSTS]));\n\n#if defined(DEBUG)\n\t{\n\t\tu32 isr;\n\t\tisr = readl(dev->base + ISR);\n\t\tprintk(\"irq: %08x imr: %08x\\n\", isr, dev->IMR_cache);\n\t\tns83820_do_isr(ndev, isr);\n\t}\n#endif\n\n\tdo_tx_done(ndev);\n\n\ttx_done_idx = dev->tx_done_idx;\n\tdesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\n\n\tprintk(KERN_INFO \"%s: after: tx_done_idx=%d free_idx=%d cmdsts=%08x\\n\",\n\t\tndev->name,\n\t\ttx_done_idx, dev->tx_free_idx, le32_to_cpu(desc[DESC_CMDSTS]));\n\n\tspin_unlock_irqrestore(&dev->tx_lock, flags);\n}\n\nstatic void ns83820_tx_watch(struct timer_list *t)\n{\n\tstruct ns83820 *dev = from_timer(dev, t, tx_watchdog);\n\tstruct net_device *ndev = dev->ndev;\n\n#if defined(DEBUG)\n\tprintk(\"ns83820_tx_watch: %u %u %d\\n\",\n\t\tdev->tx_done_idx, dev->tx_free_idx, atomic_read(&dev->nr_tx_skbs)\n\t\t);\n#endif\n\n\tif (time_after(jiffies, dev_trans_start(ndev) + 1*HZ) &&\n\t    dev->tx_done_idx != dev->tx_free_idx) {\n\t\tprintk(KERN_DEBUG \"%s: ns83820_tx_watch: %u %u %d\\n\",\n\t\t\tndev->name,\n\t\t\tdev->tx_done_idx, dev->tx_free_idx,\n\t\t\tatomic_read(&dev->nr_tx_skbs));\n\t\tns83820_tx_timeout(ndev, UINT_MAX);\n\t}\n\n\tmod_timer(&dev->tx_watchdog, jiffies + 2*HZ);\n}\n\nstatic int ns83820_open(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tunsigned i;\n\tu32 desc;\n\tint ret;\n\n\tdprintk(\"ns83820_open\\n\");\n\n\twritel(0, dev->base + PQCR);\n\n\tret = ns83820_setup_rx(ndev);\n\tif (ret)\n\t\tgoto failed;\n\n\tmemset(dev->tx_descs, 0, 4 * NR_TX_DESC * DESC_SIZE);\n\tfor (i=0; i<NR_TX_DESC; i++) {\n\t\tdev->tx_descs[(i * DESC_SIZE) + DESC_LINK]\n\t\t\t\t= cpu_to_le32(\n\t\t\t\t  dev->tx_phy_descs\n\t\t\t\t  + ((i+1) % NR_TX_DESC) * DESC_SIZE * 4);\n\t}\n\n\tdev->tx_idx = 0;\n\tdev->tx_done_idx = 0;\n\tdesc = dev->tx_phy_descs;\n\twritel(0, dev->base + TXDP_HI);\n\twritel(desc, dev->base + TXDP);\n\n\ttimer_setup(&dev->tx_watchdog, ns83820_tx_watch, 0);\n\tmod_timer(&dev->tx_watchdog, jiffies + 2*HZ);\n\n\tnetif_start_queue(ndev);\t \n\n\treturn 0;\n\nfailed:\n\tns83820_stop(ndev);\n\treturn ret;\n}\n\nstatic void ns83820_getmac(struct ns83820 *dev, struct net_device *ndev)\n{\n\tu8 mac[ETH_ALEN];\n\tunsigned i;\n\n\tfor (i=0; i<3; i++) {\n\t\tu32 data;\n\n\t\t \n\t\twritel(i*2, dev->base + RFCR);\n\t\tdata = readl(dev->base + RFDR);\n\n\t\tmac[i * 2] = data;\n\t\tmac[i * 2 + 1] = data >> 8;\n\t}\n\teth_hw_addr_set(ndev, mac);\n}\n\nstatic void ns83820_set_multicast(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tu8 __iomem *rfcr = dev->base + RFCR;\n\tu32 and_mask = 0xffffffff;\n\tu32 or_mask = 0;\n\tu32 val;\n\n\tif (ndev->flags & IFF_PROMISC)\n\t\tor_mask |= RFCR_AAU | RFCR_AAM;\n\telse\n\t\tand_mask &= ~(RFCR_AAU | RFCR_AAM);\n\n\tif (ndev->flags & IFF_ALLMULTI || netdev_mc_count(ndev))\n\t\tor_mask |= RFCR_AAM;\n\telse\n\t\tand_mask &= ~RFCR_AAM;\n\n\tspin_lock_irq(&dev->misc_lock);\n\tval = (readl(rfcr) & and_mask) | or_mask;\n\t \n\twritel(val & ~RFCR_RFEN, rfcr);\n\twritel(val, rfcr);\n\tspin_unlock_irq(&dev->misc_lock);\n}\n\nstatic void ns83820_run_bist(struct net_device *ndev, const char *name, u32 enable, u32 done, u32 fail)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tint timed_out = 0;\n\tunsigned long start;\n\tu32 status;\n\tint loops = 0;\n\n\tdprintk(\"%s: start %s\\n\", ndev->name, name);\n\n\tstart = jiffies;\n\n\twritel(enable, dev->base + PTSCR);\n\tfor (;;) {\n\t\tloops++;\n\t\tstatus = readl(dev->base + PTSCR);\n\t\tif (!(status & enable))\n\t\t\tbreak;\n\t\tif (status & done)\n\t\t\tbreak;\n\t\tif (status & fail)\n\t\t\tbreak;\n\t\tif (time_after_eq(jiffies, start + HZ)) {\n\t\t\ttimed_out = 1;\n\t\t\tbreak;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\tif (status & fail)\n\t\tprintk(KERN_INFO \"%s: %s failed! (0x%08x & 0x%08x)\\n\",\n\t\t\tndev->name, name, status, fail);\n\telse if (timed_out)\n\t\tprintk(KERN_INFO \"%s: run_bist %s timed out! (%08x)\\n\",\n\t\t\tndev->name, name, status);\n\n\tdprintk(\"%s: done %s in %d loops\\n\", ndev->name, name, loops);\n}\n\n#ifdef PHY_CODE_IS_FINISHED\nstatic void ns83820_mii_write_bit(struct ns83820 *dev, int bit)\n{\n\t \n\tdev->MEAR_cache &= ~MEAR_MDC;\n\twritel(dev->MEAR_cache, dev->base + MEAR);\n\treadl(dev->base + MEAR);\n\n\t \n\tdev->MEAR_cache |= MEAR_MDDIR;\n\tif (bit)\n\t\tdev->MEAR_cache |= MEAR_MDIO;\n\telse\n\t\tdev->MEAR_cache &= ~MEAR_MDIO;\n\n\t \n\twritel(dev->MEAR_cache, dev->base + MEAR);\n\treadl(dev->base + MEAR);\n\n\t \n\tudelay(1);\n\n\t \n\tdev->MEAR_cache |= MEAR_MDC;\n\twritel(dev->MEAR_cache, dev->base + MEAR);\n\treadl(dev->base + MEAR);\n\n\t \n\tudelay(1);\n}\n\nstatic int ns83820_mii_read_bit(struct ns83820 *dev)\n{\n\tint bit;\n\n\t \n\tdev->MEAR_cache &= ~MEAR_MDC;\n\tdev->MEAR_cache &= ~MEAR_MDDIR;\n\twritel(dev->MEAR_cache, dev->base + MEAR);\n\treadl(dev->base + MEAR);\n\n\t \n\tudelay(1);\n\n\t \n\tbit = (readl(dev->base + MEAR) & MEAR_MDIO) ? 1 : 0;\n\tdev->MEAR_cache |= MEAR_MDC;\n\twritel(dev->MEAR_cache, dev->base + MEAR);\n\n\t \n\tudelay(1);\n\n\treturn bit;\n}\n\nstatic unsigned ns83820_mii_read_reg(struct ns83820 *dev, unsigned phy, unsigned reg)\n{\n\tunsigned data = 0;\n\tint i;\n\n\t \n\tfor (i=0; i<64; i++)\n\t\tns83820_mii_read_bit(dev);\n\n\tns83820_mii_write_bit(dev, 0);\t \n\tns83820_mii_write_bit(dev, 1);\n\tns83820_mii_write_bit(dev, 1);\t \n\tns83820_mii_write_bit(dev, 0);\n\n\t \n\tfor (i=0; i<5; i++)\n\t\tns83820_mii_write_bit(dev, phy & (0x10 >> i));\n\n\t \n\tfor (i=0; i<5; i++)\n\t\tns83820_mii_write_bit(dev, reg & (0x10 >> i));\n\n\tns83820_mii_read_bit(dev);\t \n\tns83820_mii_read_bit(dev);\n\n\t \n\tfor (i=0; i<16; i++) {\n\t\tdata <<= 1;\n\t\tdata |= ns83820_mii_read_bit(dev);\n\t}\n\n\treturn data;\n}\n\nstatic unsigned ns83820_mii_write_reg(struct ns83820 *dev, unsigned phy, unsigned reg, unsigned data)\n{\n\tint i;\n\n\t \n\tfor (i=0; i<64; i++)\n\t\tns83820_mii_read_bit(dev);\n\n\tns83820_mii_write_bit(dev, 0);\t \n\tns83820_mii_write_bit(dev, 1);\n\tns83820_mii_write_bit(dev, 0);\t \n\tns83820_mii_write_bit(dev, 1);\n\n\t \n\tfor (i=0; i<5; i++)\n\t\tns83820_mii_write_bit(dev, phy & (0x10 >> i));\n\n\t \n\tfor (i=0; i<5; i++)\n\t\tns83820_mii_write_bit(dev, reg & (0x10 >> i));\n\n\tns83820_mii_read_bit(dev);\t \n\tns83820_mii_read_bit(dev);\n\n\t \n\tfor (i=0; i<16; i++)\n\t\tns83820_mii_write_bit(dev, (data >> (15 - i)) & 1);\n\n\treturn data;\n}\n\nstatic void ns83820_probe_phy(struct net_device *ndev)\n{\n\tstruct ns83820 *dev = PRIV(ndev);\n\tint j;\n\tunsigned a, b;\n\n\tfor (j = 0; j < 0x16; j += 4) {\n\t\tdprintk(\"%s: [0x%02x] %04x %04x %04x %04x\\n\",\n\t\t\tndev->name, j,\n\t\t\tns83820_mii_read_reg(dev, 1, 0 + j),\n\t\t\tns83820_mii_read_reg(dev, 1, 1 + j),\n\t\t\tns83820_mii_read_reg(dev, 1, 2 + j),\n\t\t\tns83820_mii_read_reg(dev, 1, 3 + j)\n\t\t\t);\n\t}\n\n\t \n\tns83820_mii_write_reg(dev, 1, 0x16, 0x000d);\n\tns83820_mii_write_reg(dev, 1, 0x1e, 0x810e);\n\ta = ns83820_mii_read_reg(dev, 1, 0x1d);\n\n\tns83820_mii_write_reg(dev, 1, 0x16, 0x000d);\n\tns83820_mii_write_reg(dev, 1, 0x1e, 0x810e);\n\tb = ns83820_mii_read_reg(dev, 1, 0x1d);\n\tdprintk(\"version: 0x%04x 0x%04x\\n\", a, b);\n}\n#endif\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= ns83820_open,\n\t.ndo_stop\t\t= ns83820_stop,\n\t.ndo_start_xmit\t\t= ns83820_hard_start_xmit,\n\t.ndo_get_stats\t\t= ns83820_get_stats,\n\t.ndo_set_rx_mode\t= ns83820_set_multicast,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_tx_timeout\t\t= ns83820_tx_timeout,\n};\n\nstatic int ns83820_init_one(struct pci_dev *pci_dev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstruct net_device *ndev;\n\tstruct ns83820 *dev;\n\tlong addr;\n\tint err;\n\tint using_dac = 0;\n\n\t \n\tif (sizeof(dma_addr_t) == 8 &&\n\t\t!dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(64))) {\n\t\tusing_dac = 1;\n\t} else if (!dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {\n\t\tusing_dac = 0;\n\t} else {\n\t\tdev_warn(&pci_dev->dev, \"dma_set_mask failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tndev = alloc_etherdev(sizeof(struct ns83820));\n\terr = -ENOMEM;\n\tif (!ndev)\n\t\tgoto out;\n\n\tdev = PRIV(ndev);\n\tdev->ndev = ndev;\n\n\tspin_lock_init(&dev->rx_info.lock);\n\tspin_lock_init(&dev->tx_lock);\n\tspin_lock_init(&dev->misc_lock);\n\tdev->pci_dev = pci_dev;\n\n\tSET_NETDEV_DEV(ndev, &pci_dev->dev);\n\n\tINIT_WORK(&dev->tq_refill, queue_refill);\n\ttasklet_setup(&dev->rx_tasklet, rx_action);\n\n\terr = pci_enable_device(pci_dev);\n\tif (err) {\n\t\tdev_info(&pci_dev->dev, \"pci_enable_dev failed: %d\\n\", err);\n\t\tgoto out_free;\n\t}\n\n\tpci_set_master(pci_dev);\n\taddr = pci_resource_start(pci_dev, 1);\n\tdev->base = ioremap(addr, PAGE_SIZE);\n\tdev->tx_descs = dma_alloc_coherent(&pci_dev->dev,\n\t\t\t\t\t   4 * DESC_SIZE * NR_TX_DESC,\n\t\t\t\t\t   &dev->tx_phy_descs, GFP_KERNEL);\n\tdev->rx_info.descs = dma_alloc_coherent(&pci_dev->dev,\n\t\t\t\t\t\t4 * DESC_SIZE * NR_RX_DESC,\n\t\t\t\t\t\t&dev->rx_info.phy_descs, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!dev->base || !dev->tx_descs || !dev->rx_info.descs)\n\t\tgoto out_disable;\n\n\tdprintk(\"%p: %08lx  %p: %08lx\\n\",\n\t\tdev->tx_descs, (long)dev->tx_phy_descs,\n\t\tdev->rx_info.descs, (long)dev->rx_info.phy_descs);\n\n\tns83820_disable_interrupts(dev);\n\n\tdev->IMR_cache = 0;\n\n\terr = request_irq(pci_dev->irq, ns83820_irq, IRQF_SHARED,\n\t\t\t  DRV_NAME, ndev);\n\tif (err) {\n\t\tdev_info(&pci_dev->dev, \"unable to register irq %d, err %d\\n\",\n\t\t\tpci_dev->irq, err);\n\t\tgoto out_disable;\n\t}\n\n\t \n\trtnl_lock();\n\terr = dev_alloc_name(ndev, ndev->name);\n\tif (err < 0) {\n\t\tdev_info(&pci_dev->dev, \"unable to get netdev name: %d\\n\", err);\n\t\tgoto out_free_irq;\n\t}\n\n\tprintk(\"%s: ns83820.c: 0x22c: %08x, subsystem: %04x:%04x\\n\",\n\t\tndev->name, le32_to_cpu(readl(dev->base + 0x22c)),\n\t\tpci_dev->subsystem_vendor, pci_dev->subsystem_device);\n\n\tndev->netdev_ops = &netdev_ops;\n\tndev->ethtool_ops = &ops;\n\tndev->watchdog_timeo = 5 * HZ;\n\tpci_set_drvdata(pci_dev, ndev);\n\n\tns83820_do_reset(dev, CR_RST);\n\n\t \n\twritel(PTSCR_RBIST_RST, dev->base + PTSCR);\n\tns83820_run_bist(ndev, \"sram bist\",   PTSCR_RBIST_EN,\n\t\t\t PTSCR_RBIST_DONE, PTSCR_RBIST_FAIL);\n\tns83820_run_bist(ndev, \"eeprom bist\", PTSCR_EEBIST_EN, 0,\n\t\t\t PTSCR_EEBIST_FAIL);\n\tns83820_run_bist(ndev, \"eeprom load\", PTSCR_EELOAD_EN, 0, 0);\n\n\t \n\tdev->CFG_cache = readl(dev->base + CFG);\n\n\tif ((dev->CFG_cache & CFG_PCI64_DET)) {\n\t\tprintk(KERN_INFO \"%s: detected 64 bit PCI data bus.\\n\",\n\t\t\tndev->name);\n\t\t \n\t\tif (!(dev->CFG_cache & CFG_DATA64_EN))\n\t\t\tprintk(KERN_INFO \"%s: EEPROM did not enable 64 bit bus.  Disabled.\\n\",\n\t\t\t\tndev->name);\n\t} else\n\t\tdev->CFG_cache &= ~(CFG_DATA64_EN);\n\n\tdev->CFG_cache &= (CFG_TBI_EN  | CFG_MRM_DIS   | CFG_MWI_DIS |\n\t\t\t   CFG_T64ADDR | CFG_DATA64_EN | CFG_EXT_125 |\n\t\t\t   CFG_M64ADDR);\n\tdev->CFG_cache |= CFG_PINT_DUPSTS | CFG_PINT_LNKSTS | CFG_PINT_SPDSTS |\n\t\t\t  CFG_EXTSTS_EN   | CFG_EXD         | CFG_PESEL;\n\tdev->CFG_cache |= CFG_REQALG;\n\tdev->CFG_cache |= CFG_POW;\n\tdev->CFG_cache |= CFG_TMRTEST;\n\n\t \n\tif (sizeof(dma_addr_t) == 8)\n\t\tdev->CFG_cache |= CFG_M64ADDR;\n\tif (using_dac)\n\t\tdev->CFG_cache |= CFG_T64ADDR;\n\n\t \n\tdev->CFG_cache &= ~CFG_BEM;\n\n\t \n\tif (dev->CFG_cache & CFG_TBI_EN) {\n\t\tprintk(KERN_INFO \"%s: enabling optical transceiver\\n\",\n\t\t\tndev->name);\n\t\twritel(readl(dev->base + GPIOR) | 0x3e8, dev->base + GPIOR);\n\n\t\t \n\t\twritel(readl(dev->base + TANAR)\n\t\t       | TANAR_HALF_DUP | TANAR_FULL_DUP,\n\t\t       dev->base + TANAR);\n\n\t\t \n\t\twritel(TBICR_MR_AN_ENABLE | TBICR_MR_RESTART_AN,\n\t\t       dev->base + TBICR);\n\t\twritel(TBICR_MR_AN_ENABLE, dev->base + TBICR);\n\t\tdev->linkstate = LINK_AUTONEGOTIATE;\n\n\t\tdev->CFG_cache |= CFG_MODE_1000;\n\t}\n\n\twritel(dev->CFG_cache, dev->base + CFG);\n\tdprintk(\"CFG: %08x\\n\", dev->CFG_cache);\n\n\tif (reset_phy) {\n\t\tprintk(KERN_INFO \"%s: resetting phy\\n\", ndev->name);\n\t\twritel(dev->CFG_cache | CFG_PHY_RST, dev->base + CFG);\n\t\tmsleep(10);\n\t\twritel(dev->CFG_cache, dev->base + CFG);\n\t}\n\n#if 0\t \n\tif (readl(dev->base + SRR))\n\t\twritel(readl(dev->base+0x20c) | 0xfe00, dev->base + 0x20c);\n#endif\n\n\t \n\t \n\twritel(TXCFG_CSI | TXCFG_HBI | TXCFG_ATP | TXCFG_MXDMA512\n\t\t| ((1600 / 32) * 0x100),\n\t\tdev->base + TXCFG);\n\n\t \n\twritel(0x000, dev->base + IHR);\n\twritel(0x100, dev->base + IHR);\n\twritel(0x000, dev->base + IHR);\n\n\t \n\t \n\twritel(RXCFG_AEP | RXCFG_ARP | RXCFG_AIRL | RXCFG_RX_FD\n\t\t| RXCFG_STRIPCRC\n\t\t \n\t\t| (RXCFG_MXDMA512) | 0, dev->base + RXCFG);\n\n\t \n\twritel(0, dev->base + PQCR);\n\n\t \n\t \n#ifdef NS83820_VLAN_ACCEL_SUPPORT\n#define VRCR_INIT_VALUE (VRCR_IPEN|VRCR_VTDEN|VRCR_VTREN)\n#else\n#define VRCR_INIT_VALUE (VRCR_IPEN|VRCR_VTDEN)\n#endif\n\twritel(VRCR_INIT_VALUE, dev->base + VRCR);\n\n\t \n#ifdef NS83820_VLAN_ACCEL_SUPPORT\n#define VTCR_INIT_VALUE (VTCR_PPCHK|VTCR_VPPTI)\n#else\n#define VTCR_INIT_VALUE VTCR_PPCHK\n#endif\n\twritel(VTCR_INIT_VALUE, dev->base + VTCR);\n\n\t \n\t \n\twritel((PCR_PS_MCAST | PCR_PS_DA | PCR_PSEN | PCR_FFLO_4K |\n\t\tPCR_FFHI_8K | PCR_STLO_4 | PCR_STHI_8 | PCR_PAUSE_CNT),\n\t\tdev->base + PCR);\n\n\t \n\twritel(0, dev->base + WCSR);\n\n\tns83820_getmac(dev, ndev);\n\n\t \n\tndev->features |= NETIF_F_SG;\n\tndev->features |= NETIF_F_IP_CSUM;\n\n\tndev->min_mtu = 0;\n\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\n\t \n\tndev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;\n#endif\n\n\tif (using_dac) {\n\t\tprintk(KERN_INFO \"%s: using 64 bit addressing.\\n\",\n\t\t\tndev->name);\n\t\tndev->features |= NETIF_F_HIGHDMA;\n\t}\n\n\tprintk(KERN_INFO \"%s: ns83820 v\" VERSION \": DP83820 v%u.%u: %pM io=0x%08lx irq=%d f=%s\\n\",\n\t\tndev->name,\n\t\t(unsigned)readl(dev->base + SRR) >> 8,\n\t\t(unsigned)readl(dev->base + SRR) & 0xff,\n\t\tndev->dev_addr, addr, pci_dev->irq,\n\t\t(ndev->features & NETIF_F_HIGHDMA) ? \"h,sg\" : \"sg\"\n\t\t);\n\n#ifdef PHY_CODE_IS_FINISHED\n\tns83820_probe_phy(ndev);\n#endif\n\n\terr = register_netdevice(ndev);\n\tif (err) {\n\t\tprintk(KERN_INFO \"ns83820: unable to register netdev: %d\\n\", err);\n\t\tgoto out_cleanup;\n\t}\n\trtnl_unlock();\n\n\treturn 0;\n\nout_cleanup:\n\tns83820_disable_interrupts(dev);  \nout_free_irq:\n\trtnl_unlock();\n\tfree_irq(pci_dev->irq, ndev);\nout_disable:\n\tif (dev->base)\n\t\tiounmap(dev->base);\n\tdma_free_coherent(&pci_dev->dev, 4 * DESC_SIZE * NR_TX_DESC,\n\t\t\t  dev->tx_descs, dev->tx_phy_descs);\n\tdma_free_coherent(&pci_dev->dev, 4 * DESC_SIZE * NR_RX_DESC,\n\t\t\t  dev->rx_info.descs, dev->rx_info.phy_descs);\n\tpci_disable_device(pci_dev);\nout_free:\n\tfree_netdev(ndev);\nout:\n\treturn err;\n}\n\nstatic void ns83820_remove_one(struct pci_dev *pci_dev)\n{\n\tstruct net_device *ndev = pci_get_drvdata(pci_dev);\n\tstruct ns83820 *dev = PRIV(ndev);  \n\n\tif (!ndev)\t\t\t \n\t\treturn;\n\n\tns83820_disable_interrupts(dev);  \n\n\tunregister_netdev(ndev);\n\tfree_irq(dev->pci_dev->irq, ndev);\n\tiounmap(dev->base);\n\tdma_free_coherent(&dev->pci_dev->dev, 4 * DESC_SIZE * NR_TX_DESC,\n\t\t\t  dev->tx_descs, dev->tx_phy_descs);\n\tdma_free_coherent(&dev->pci_dev->dev, 4 * DESC_SIZE * NR_RX_DESC,\n\t\t\t  dev->rx_info.descs, dev->rx_info.phy_descs);\n\tpci_disable_device(dev->pci_dev);\n\tfree_netdev(ndev);\n}\n\nstatic const struct pci_device_id ns83820_pci_tbl[] = {\n\t{ 0x100b, 0x0022, PCI_ANY_ID, PCI_ANY_ID, 0, .driver_data = 0, },\n\t{ 0, },\n};\n\nstatic struct pci_driver driver = {\n\t.name\t\t= \"ns83820\",\n\t.id_table\t= ns83820_pci_tbl,\n\t.probe\t\t= ns83820_init_one,\n\t.remove\t\t= ns83820_remove_one,\n#if 0\t \n\t.suspend\t= ,\n\t.resume\t\t= ,\n#endif\n};\n\n\nstatic int __init ns83820_init(void)\n{\n\tprintk(KERN_INFO \"ns83820.c: National Semiconductor DP83820 10/100/1000 driver.\\n\");\n\treturn pci_register_driver(&driver);\n}\n\nstatic void __exit ns83820_exit(void)\n{\n\tpci_unregister_driver(&driver);\n}\n\nMODULE_AUTHOR(\"Benjamin LaHaise <bcrl@kvack.org>\");\nMODULE_DESCRIPTION(\"National Semiconductor DP83820 10/100/1000 driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_DEVICE_TABLE(pci, ns83820_pci_tbl);\n\nmodule_param(lnksts, int, 0);\nMODULE_PARM_DESC(lnksts, \"Polarity of LNKSTS bit\");\n\nmodule_param(ihr, int, 0);\nMODULE_PARM_DESC(ihr, \"Time in 100 us increments to delay interrupts (range 0-127)\");\n\nmodule_param(reset_phy, int, 0);\nMODULE_PARM_DESC(reset_phy, \"Set to 1 to reset the PHY on startup\");\n\nmodule_init(ns83820_init);\nmodule_exit(ns83820_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}