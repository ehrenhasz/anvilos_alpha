{
  "module_name": "s2io.c",
  "hash_id": "5c8cb5ee75d04ef1e937695ac5c60ca4d9491ab0da54c5314d0f8241af3c14f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/neterion/s2io.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mdio.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/stddef.h>\n#include <linux/ioctl.h>\n#include <linux/timex.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/slab.h>\n#include <linux/prefetch.h>\n#include <net/tcp.h>\n#include <net/checksum.h>\n\n#include <asm/div64.h>\n#include <asm/irq.h>\n\n \n#include \"s2io.h\"\n#include \"s2io-regs.h\"\n\n#define DRV_VERSION \"2.0.26.28\"\n\n \nstatic const char s2io_driver_name[] = \"Neterion\";\nstatic const char s2io_driver_version[] = DRV_VERSION;\n\nstatic const int rxd_size[2] = {32, 48};\nstatic const int rxd_count[2] = {127, 85};\n\nstatic inline int RXD_IS_UP2DT(struct RxD_t *rxdp)\n{\n\tint ret;\n\n\tret = ((!(rxdp->Control_1 & RXD_OWN_XENA)) &&\n\t       (GET_RXD_MARKER(rxdp->Control_2) != THE_RXD_MARK));\n\n\treturn ret;\n}\n\n \n#define CARDS_WITH_FAULTY_LINK_INDICATORS(dev_type, subid)\t\t\\\n\t(dev_type == XFRAME_I_DEVICE) ?\t\t\t\t\t\\\n\t((((subid >= 0x600B) && (subid <= 0x600D)) ||\t\t\t\\\n\t  ((subid >= 0x640B) && (subid <= 0x640D))) ? 1 : 0) : 0\n\n#define LINK_IS_UP(val64) (!(val64 & (ADAPTER_STATUS_RMAC_REMOTE_FAULT | \\\n\t\t\t\t      ADAPTER_STATUS_RMAC_LOCAL_FAULT)))\n\nstatic inline int is_s2io_card_up(const struct s2io_nic *sp)\n{\n\treturn test_bit(__S2IO_STATE_CARD_UP, &sp->state);\n}\n\n \nstatic const char s2io_gstrings[][ETH_GSTRING_LEN] = {\n\t\"Register test\\t(offline)\",\n\t\"Eeprom test\\t(offline)\",\n\t\"Link test\\t(online)\",\n\t\"RLDRAM test\\t(offline)\",\n\t\"BIST Test\\t(offline)\"\n};\n\nstatic const char ethtool_xena_stats_keys[][ETH_GSTRING_LEN] = {\n\t{\"tmac_frms\"},\n\t{\"tmac_data_octets\"},\n\t{\"tmac_drop_frms\"},\n\t{\"tmac_mcst_frms\"},\n\t{\"tmac_bcst_frms\"},\n\t{\"tmac_pause_ctrl_frms\"},\n\t{\"tmac_ttl_octets\"},\n\t{\"tmac_ucst_frms\"},\n\t{\"tmac_nucst_frms\"},\n\t{\"tmac_any_err_frms\"},\n\t{\"tmac_ttl_less_fb_octets\"},\n\t{\"tmac_vld_ip_octets\"},\n\t{\"tmac_vld_ip\"},\n\t{\"tmac_drop_ip\"},\n\t{\"tmac_icmp\"},\n\t{\"tmac_rst_tcp\"},\n\t{\"tmac_tcp\"},\n\t{\"tmac_udp\"},\n\t{\"rmac_vld_frms\"},\n\t{\"rmac_data_octets\"},\n\t{\"rmac_fcs_err_frms\"},\n\t{\"rmac_drop_frms\"},\n\t{\"rmac_vld_mcst_frms\"},\n\t{\"rmac_vld_bcst_frms\"},\n\t{\"rmac_in_rng_len_err_frms\"},\n\t{\"rmac_out_rng_len_err_frms\"},\n\t{\"rmac_long_frms\"},\n\t{\"rmac_pause_ctrl_frms\"},\n\t{\"rmac_unsup_ctrl_frms\"},\n\t{\"rmac_ttl_octets\"},\n\t{\"rmac_accepted_ucst_frms\"},\n\t{\"rmac_accepted_nucst_frms\"},\n\t{\"rmac_discarded_frms\"},\n\t{\"rmac_drop_events\"},\n\t{\"rmac_ttl_less_fb_octets\"},\n\t{\"rmac_ttl_frms\"},\n\t{\"rmac_usized_frms\"},\n\t{\"rmac_osized_frms\"},\n\t{\"rmac_frag_frms\"},\n\t{\"rmac_jabber_frms\"},\n\t{\"rmac_ttl_64_frms\"},\n\t{\"rmac_ttl_65_127_frms\"},\n\t{\"rmac_ttl_128_255_frms\"},\n\t{\"rmac_ttl_256_511_frms\"},\n\t{\"rmac_ttl_512_1023_frms\"},\n\t{\"rmac_ttl_1024_1518_frms\"},\n\t{\"rmac_ip\"},\n\t{\"rmac_ip_octets\"},\n\t{\"rmac_hdr_err_ip\"},\n\t{\"rmac_drop_ip\"},\n\t{\"rmac_icmp\"},\n\t{\"rmac_tcp\"},\n\t{\"rmac_udp\"},\n\t{\"rmac_err_drp_udp\"},\n\t{\"rmac_xgmii_err_sym\"},\n\t{\"rmac_frms_q0\"},\n\t{\"rmac_frms_q1\"},\n\t{\"rmac_frms_q2\"},\n\t{\"rmac_frms_q3\"},\n\t{\"rmac_frms_q4\"},\n\t{\"rmac_frms_q5\"},\n\t{\"rmac_frms_q6\"},\n\t{\"rmac_frms_q7\"},\n\t{\"rmac_full_q0\"},\n\t{\"rmac_full_q1\"},\n\t{\"rmac_full_q2\"},\n\t{\"rmac_full_q3\"},\n\t{\"rmac_full_q4\"},\n\t{\"rmac_full_q5\"},\n\t{\"rmac_full_q6\"},\n\t{\"rmac_full_q7\"},\n\t{\"rmac_pause_cnt\"},\n\t{\"rmac_xgmii_data_err_cnt\"},\n\t{\"rmac_xgmii_ctrl_err_cnt\"},\n\t{\"rmac_accepted_ip\"},\n\t{\"rmac_err_tcp\"},\n\t{\"rd_req_cnt\"},\n\t{\"new_rd_req_cnt\"},\n\t{\"new_rd_req_rtry_cnt\"},\n\t{\"rd_rtry_cnt\"},\n\t{\"wr_rtry_rd_ack_cnt\"},\n\t{\"wr_req_cnt\"},\n\t{\"new_wr_req_cnt\"},\n\t{\"new_wr_req_rtry_cnt\"},\n\t{\"wr_rtry_cnt\"},\n\t{\"wr_disc_cnt\"},\n\t{\"rd_rtry_wr_ack_cnt\"},\n\t{\"txp_wr_cnt\"},\n\t{\"txd_rd_cnt\"},\n\t{\"txd_wr_cnt\"},\n\t{\"rxd_rd_cnt\"},\n\t{\"rxd_wr_cnt\"},\n\t{\"txf_rd_cnt\"},\n\t{\"rxf_wr_cnt\"}\n};\n\nstatic const char ethtool_enhanced_stats_keys[][ETH_GSTRING_LEN] = {\n\t{\"rmac_ttl_1519_4095_frms\"},\n\t{\"rmac_ttl_4096_8191_frms\"},\n\t{\"rmac_ttl_8192_max_frms\"},\n\t{\"rmac_ttl_gt_max_frms\"},\n\t{\"rmac_osized_alt_frms\"},\n\t{\"rmac_jabber_alt_frms\"},\n\t{\"rmac_gt_max_alt_frms\"},\n\t{\"rmac_vlan_frms\"},\n\t{\"rmac_len_discard\"},\n\t{\"rmac_fcs_discard\"},\n\t{\"rmac_pf_discard\"},\n\t{\"rmac_da_discard\"},\n\t{\"rmac_red_discard\"},\n\t{\"rmac_rts_discard\"},\n\t{\"rmac_ingm_full_discard\"},\n\t{\"link_fault_cnt\"}\n};\n\nstatic const char ethtool_driver_stats_keys[][ETH_GSTRING_LEN] = {\n\t{\"\\n DRIVER STATISTICS\"},\n\t{\"single_bit_ecc_errs\"},\n\t{\"double_bit_ecc_errs\"},\n\t{\"parity_err_cnt\"},\n\t{\"serious_err_cnt\"},\n\t{\"soft_reset_cnt\"},\n\t{\"fifo_full_cnt\"},\n\t{\"ring_0_full_cnt\"},\n\t{\"ring_1_full_cnt\"},\n\t{\"ring_2_full_cnt\"},\n\t{\"ring_3_full_cnt\"},\n\t{\"ring_4_full_cnt\"},\n\t{\"ring_5_full_cnt\"},\n\t{\"ring_6_full_cnt\"},\n\t{\"ring_7_full_cnt\"},\n\t{\"alarm_transceiver_temp_high\"},\n\t{\"alarm_transceiver_temp_low\"},\n\t{\"alarm_laser_bias_current_high\"},\n\t{\"alarm_laser_bias_current_low\"},\n\t{\"alarm_laser_output_power_high\"},\n\t{\"alarm_laser_output_power_low\"},\n\t{\"warn_transceiver_temp_high\"},\n\t{\"warn_transceiver_temp_low\"},\n\t{\"warn_laser_bias_current_high\"},\n\t{\"warn_laser_bias_current_low\"},\n\t{\"warn_laser_output_power_high\"},\n\t{\"warn_laser_output_power_low\"},\n\t{\"lro_aggregated_pkts\"},\n\t{\"lro_flush_both_count\"},\n\t{\"lro_out_of_sequence_pkts\"},\n\t{\"lro_flush_due_to_max_pkts\"},\n\t{\"lro_avg_aggr_pkts\"},\n\t{\"mem_alloc_fail_cnt\"},\n\t{\"pci_map_fail_cnt\"},\n\t{\"watchdog_timer_cnt\"},\n\t{\"mem_allocated\"},\n\t{\"mem_freed\"},\n\t{\"link_up_cnt\"},\n\t{\"link_down_cnt\"},\n\t{\"link_up_time\"},\n\t{\"link_down_time\"},\n\t{\"tx_tcode_buf_abort_cnt\"},\n\t{\"tx_tcode_desc_abort_cnt\"},\n\t{\"tx_tcode_parity_err_cnt\"},\n\t{\"tx_tcode_link_loss_cnt\"},\n\t{\"tx_tcode_list_proc_err_cnt\"},\n\t{\"rx_tcode_parity_err_cnt\"},\n\t{\"rx_tcode_abort_cnt\"},\n\t{\"rx_tcode_parity_abort_cnt\"},\n\t{\"rx_tcode_rda_fail_cnt\"},\n\t{\"rx_tcode_unkn_prot_cnt\"},\n\t{\"rx_tcode_fcs_err_cnt\"},\n\t{\"rx_tcode_buf_size_err_cnt\"},\n\t{\"rx_tcode_rxd_corrupt_cnt\"},\n\t{\"rx_tcode_unkn_err_cnt\"},\n\t{\"tda_err_cnt\"},\n\t{\"pfc_err_cnt\"},\n\t{\"pcc_err_cnt\"},\n\t{\"tti_err_cnt\"},\n\t{\"tpa_err_cnt\"},\n\t{\"sm_err_cnt\"},\n\t{\"lso_err_cnt\"},\n\t{\"mac_tmac_err_cnt\"},\n\t{\"mac_rmac_err_cnt\"},\n\t{\"xgxs_txgxs_err_cnt\"},\n\t{\"xgxs_rxgxs_err_cnt\"},\n\t{\"rc_err_cnt\"},\n\t{\"prc_pcix_err_cnt\"},\n\t{\"rpa_err_cnt\"},\n\t{\"rda_err_cnt\"},\n\t{\"rti_err_cnt\"},\n\t{\"mc_err_cnt\"}\n};\n\n#define S2IO_XENA_STAT_LEN\tARRAY_SIZE(ethtool_xena_stats_keys)\n#define S2IO_ENHANCED_STAT_LEN\tARRAY_SIZE(ethtool_enhanced_stats_keys)\n#define S2IO_DRIVER_STAT_LEN\tARRAY_SIZE(ethtool_driver_stats_keys)\n\n#define XFRAME_I_STAT_LEN (S2IO_XENA_STAT_LEN + S2IO_DRIVER_STAT_LEN)\n#define XFRAME_II_STAT_LEN (XFRAME_I_STAT_LEN + S2IO_ENHANCED_STAT_LEN)\n\n#define XFRAME_I_STAT_STRINGS_LEN (XFRAME_I_STAT_LEN * ETH_GSTRING_LEN)\n#define XFRAME_II_STAT_STRINGS_LEN (XFRAME_II_STAT_LEN * ETH_GSTRING_LEN)\n\n#define S2IO_TEST_LEN\tARRAY_SIZE(s2io_gstrings)\n#define S2IO_STRINGS_LEN\t(S2IO_TEST_LEN * ETH_GSTRING_LEN)\n\n \nstatic void do_s2io_copy_mac_addr(struct s2io_nic *sp, int offset, u64 mac_addr)\n{\n\tsp->def_mac_addr[offset].mac_addr[5] = (u8) (mac_addr);\n\tsp->def_mac_addr[offset].mac_addr[4] = (u8) (mac_addr >> 8);\n\tsp->def_mac_addr[offset].mac_addr[3] = (u8) (mac_addr >> 16);\n\tsp->def_mac_addr[offset].mac_addr[2] = (u8) (mac_addr >> 24);\n\tsp->def_mac_addr[offset].mac_addr[1] = (u8) (mac_addr >> 32);\n\tsp->def_mac_addr[offset].mac_addr[0] = (u8) (mac_addr >> 40);\n}\n\n \n\n#define\tEND_SIGN\t0x0\nstatic const u64 herc_act_dtx_cfg[] = {\n\t \n\t0x8000051536750000ULL, 0x80000515367500E0ULL,\n\t \n\t0x8000051536750004ULL, 0x80000515367500E4ULL,\n\t \n\t0x80010515003F0000ULL, 0x80010515003F00E0ULL,\n\t \n\t0x80010515003F0004ULL, 0x80010515003F00E4ULL,\n\t \n\t0x801205150D440000ULL, 0x801205150D4400E0ULL,\n\t \n\t0x801205150D440004ULL, 0x801205150D4400E4ULL,\n\t \n\t0x80020515F2100000ULL, 0x80020515F21000E0ULL,\n\t \n\t0x80020515F2100004ULL, 0x80020515F21000E4ULL,\n\t \n\tEND_SIGN\n};\n\nstatic const u64 xena_dtx_cfg[] = {\n\t \n\t0x8000051500000000ULL, 0x80000515000000E0ULL,\n\t \n\t0x80000515D9350004ULL, 0x80000515D93500E4ULL,\n\t \n\t0x8001051500000000ULL, 0x80010515000000E0ULL,\n\t \n\t0x80010515001E0004ULL, 0x80010515001E00E4ULL,\n\t \n\t0x8002051500000000ULL, 0x80020515000000E0ULL,\n\t \n\t0x80020515F2100004ULL, 0x80020515F21000E4ULL,\n\tEND_SIGN\n};\n\n \nstatic const u64 fix_mac[] = {\n\t0x0060000000000000ULL, 0x0060600000000000ULL,\n\t0x0040600000000000ULL, 0x0000600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0060600000000000ULL,\n\t0x0020600000000000ULL, 0x0000600000000000ULL,\n\t0x0040600000000000ULL, 0x0060600000000000ULL,\n\tEND_SIGN\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\n\n \nS2IO_PARM_INT(tx_fifo_num, FIFO_DEFAULT_NUM);\nS2IO_PARM_INT(rx_ring_num, 1);\nS2IO_PARM_INT(multiq, 0);\nS2IO_PARM_INT(rx_ring_mode, 1);\nS2IO_PARM_INT(use_continuous_tx_intrs, 1);\nS2IO_PARM_INT(rmac_pause_time, 0x100);\nS2IO_PARM_INT(mc_pause_threshold_q0q3, 187);\nS2IO_PARM_INT(mc_pause_threshold_q4q7, 187);\nS2IO_PARM_INT(shared_splits, 0);\nS2IO_PARM_INT(tmac_util_period, 5);\nS2IO_PARM_INT(rmac_util_period, 5);\nS2IO_PARM_INT(l3l4hdr_size, 128);\n \nS2IO_PARM_INT(tx_steering_type, TX_DEFAULT_STEERING);\n \nS2IO_PARM_INT(rxsync_frequency, 3);\n \nS2IO_PARM_INT(intr_type, 2);\n \n\n \nS2IO_PARM_INT(lro_max_pkts, 0xFFFF);\nS2IO_PARM_INT(indicate_max_pkts, 0);\n\nS2IO_PARM_INT(napi, 1);\nS2IO_PARM_INT(vlan_tag_strip, NO_STRIP_IN_PROMISC);\n\nstatic unsigned int tx_fifo_len[MAX_TX_FIFOS] =\n{DEFAULT_FIFO_0_LEN, [1 ...(MAX_TX_FIFOS - 1)] = DEFAULT_FIFO_1_7_LEN};\nstatic unsigned int rx_ring_sz[MAX_RX_RINGS] =\n{[0 ...(MAX_RX_RINGS - 1)] = SMALL_BLK_CNT};\nstatic unsigned int rts_frm_len[MAX_RX_RINGS] =\n{[0 ...(MAX_RX_RINGS - 1)] = 0 };\n\nmodule_param_array(tx_fifo_len, uint, NULL, 0);\nmodule_param_array(rx_ring_sz, uint, NULL, 0);\nmodule_param_array(rts_frm_len, uint, NULL, 0);\n\n \nstatic const struct pci_device_id s2io_tbl[] = {\n\t{PCI_VENDOR_ID_S2IO, PCI_DEVICE_ID_S2IO_WIN,\n\t PCI_ANY_ID, PCI_ANY_ID},\n\t{PCI_VENDOR_ID_S2IO, PCI_DEVICE_ID_S2IO_UNI,\n\t PCI_ANY_ID, PCI_ANY_ID},\n\t{PCI_VENDOR_ID_S2IO, PCI_DEVICE_ID_HERC_WIN,\n\t PCI_ANY_ID, PCI_ANY_ID},\n\t{PCI_VENDOR_ID_S2IO, PCI_DEVICE_ID_HERC_UNI,\n\t PCI_ANY_ID, PCI_ANY_ID},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, s2io_tbl);\n\nstatic const struct pci_error_handlers s2io_err_handler = {\n\t.error_detected = s2io_io_error_detected,\n\t.slot_reset = s2io_io_slot_reset,\n\t.resume = s2io_io_resume,\n};\n\nstatic struct pci_driver s2io_driver = {\n\t.name = \"S2IO\",\n\t.id_table = s2io_tbl,\n\t.probe = s2io_init_nic,\n\t.remove = s2io_rem_nic,\n\t.err_handler = &s2io_err_handler,\n};\n\n \n#define TXD_MEM_PAGE_CNT(len, per_each) DIV_ROUND_UP(len, per_each)\n\n \nstatic inline void s2io_stop_all_tx_queue(struct s2io_nic *sp)\n{\n\tif (!sp->config.multiq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < sp->config.tx_fifo_num; i++)\n\t\t\tsp->mac_control.fifos[i].queue_state = FIFO_QUEUE_STOP;\n\t}\n\tnetif_tx_stop_all_queues(sp->dev);\n}\n\nstatic inline void s2io_stop_tx_queue(struct s2io_nic *sp, int fifo_no)\n{\n\tif (!sp->config.multiq)\n\t\tsp->mac_control.fifos[fifo_no].queue_state =\n\t\t\tFIFO_QUEUE_STOP;\n\n\tnetif_tx_stop_all_queues(sp->dev);\n}\n\nstatic inline void s2io_start_all_tx_queue(struct s2io_nic *sp)\n{\n\tif (!sp->config.multiq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < sp->config.tx_fifo_num; i++)\n\t\t\tsp->mac_control.fifos[i].queue_state = FIFO_QUEUE_START;\n\t}\n\tnetif_tx_start_all_queues(sp->dev);\n}\n\nstatic inline void s2io_wake_all_tx_queue(struct s2io_nic *sp)\n{\n\tif (!sp->config.multiq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < sp->config.tx_fifo_num; i++)\n\t\t\tsp->mac_control.fifos[i].queue_state = FIFO_QUEUE_START;\n\t}\n\tnetif_tx_wake_all_queues(sp->dev);\n}\n\nstatic inline void s2io_wake_tx_queue(\n\tstruct fifo_info *fifo, int cnt, u8 multiq)\n{\n\n\tif (multiq) {\n\t\tif (cnt && __netif_subqueue_stopped(fifo->dev, fifo->fifo_no))\n\t\t\tnetif_wake_subqueue(fifo->dev, fifo->fifo_no);\n\t} else if (cnt && (fifo->queue_state == FIFO_QUEUE_STOP)) {\n\t\tif (netif_queue_stopped(fifo->dev)) {\n\t\t\tfifo->queue_state = FIFO_QUEUE_START;\n\t\t\tnetif_wake_queue(fifo->dev);\n\t\t}\n\t}\n}\n\n \n\nstatic int init_shared_mem(struct s2io_nic *nic)\n{\n\tu32 size;\n\tvoid *tmp_v_addr, *tmp_v_addr_next;\n\tdma_addr_t tmp_p_addr, tmp_p_addr_next;\n\tstruct RxD_block *pre_rxd_blk = NULL;\n\tint i, j, blk_cnt;\n\tint lst_size, lst_per_page;\n\tstruct net_device *dev = nic->dev;\n\tunsigned long tmp;\n\tstruct buffAdd *ba;\n\tstruct config_param *config = &nic->config;\n\tstruct mac_info *mac_control = &nic->mac_control;\n\tunsigned long long mem_allocated = 0;\n\n\t \n\tsize = 0;\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\tsize += tx_cfg->fifo_len;\n\t}\n\tif (size > MAX_AVAILABLE_TXDS) {\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"Too many TxDs requested: %d, max supported: %d\\n\",\n\t\t\t  size, MAX_AVAILABLE_TXDS);\n\t\treturn -EINVAL;\n\t}\n\n\tsize = 0;\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\tsize = tx_cfg->fifo_len;\n\t\t \n\t\tif (size < 2) {\n\t\t\tDBG_PRINT(ERR_DBG, \"Fifo %d: Invalid length (%d) - \"\n\t\t\t\t  \"Valid lengths are 2 through 8192\\n\",\n\t\t\t\t  i, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tlst_size = (sizeof(struct TxD) * config->max_txds);\n\tlst_per_page = PAGE_SIZE / lst_size;\n\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\t\tint fifo_len = tx_cfg->fifo_len;\n\t\tint list_holder_size = fifo_len * sizeof(struct list_info_hold);\n\n\t\tfifo->list_info = kzalloc(list_holder_size, GFP_KERNEL);\n\t\tif (!fifo->list_info) {\n\t\t\tDBG_PRINT(INFO_DBG, \"Malloc failed for list_info\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmem_allocated += list_holder_size;\n\t}\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tint page_num = TXD_MEM_PAGE_CNT(config->tx_cfg[i].fifo_len,\n\t\t\t\t\t\tlst_per_page);\n\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\tfifo->tx_curr_put_info.offset = 0;\n\t\tfifo->tx_curr_put_info.fifo_len = tx_cfg->fifo_len - 1;\n\t\tfifo->tx_curr_get_info.offset = 0;\n\t\tfifo->tx_curr_get_info.fifo_len = tx_cfg->fifo_len - 1;\n\t\tfifo->fifo_no = i;\n\t\tfifo->nic = nic;\n\t\tfifo->max_txds = MAX_SKB_FRAGS + 2;\n\t\tfifo->dev = dev;\n\n\t\tfor (j = 0; j < page_num; j++) {\n\t\t\tint k = 0;\n\t\t\tdma_addr_t tmp_p;\n\t\t\tvoid *tmp_v;\n\t\t\ttmp_v = dma_alloc_coherent(&nic->pdev->dev, PAGE_SIZE,\n\t\t\t\t\t\t   &tmp_p, GFP_KERNEL);\n\t\t\tif (!tmp_v) {\n\t\t\t\tDBG_PRINT(INFO_DBG,\n\t\t\t\t\t  \"dma_alloc_coherent failed for TxDL\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t \n\t\t\tif (!tmp_p) {\n\t\t\t\tmac_control->zerodma_virt_addr = tmp_v;\n\t\t\t\tDBG_PRINT(INIT_DBG,\n\t\t\t\t\t  \"%s: Zero DMA address for TxDL. \"\n\t\t\t\t\t  \"Virtual address %p\\n\",\n\t\t\t\t\t  dev->name, tmp_v);\n\t\t\t\ttmp_v = dma_alloc_coherent(&nic->pdev->dev,\n\t\t\t\t\t\t\t   PAGE_SIZE, &tmp_p,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\t\tif (!tmp_v) {\n\t\t\t\t\tDBG_PRINT(INFO_DBG,\n\t\t\t\t\t\t  \"dma_alloc_coherent failed for TxDL\\n\");\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tmem_allocated += PAGE_SIZE;\n\t\t\t}\n\t\t\twhile (k < lst_per_page) {\n\t\t\t\tint l = (j * lst_per_page) + k;\n\t\t\t\tif (l == tx_cfg->fifo_len)\n\t\t\t\t\tbreak;\n\t\t\t\tfifo->list_info[l].list_virt_addr =\n\t\t\t\t\ttmp_v + (k * lst_size);\n\t\t\t\tfifo->list_info[l].list_phy_addr =\n\t\t\t\t\ttmp_p + (k * lst_size);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\tsize = tx_cfg->fifo_len;\n\t\tfifo->ufo_in_band_v = kcalloc(size, sizeof(u64), GFP_KERNEL);\n\t\tif (!fifo->ufo_in_band_v)\n\t\t\treturn -ENOMEM;\n\t\tmem_allocated += (size * sizeof(u64));\n\t}\n\n\t \n\tsize = 0;\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\tif (rx_cfg->num_rxd % (rxd_count[nic->rxd_mode] + 1)) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Ring%d RxD count is not a \"\n\t\t\t\t  \"multiple of RxDs per Block\\n\",\n\t\t\t\t  dev->name, i);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tsize += rx_cfg->num_rxd;\n\t\tring->block_count = rx_cfg->num_rxd /\n\t\t\t(rxd_count[nic->rxd_mode] + 1);\n\t\tring->pkt_cnt = rx_cfg->num_rxd - ring->block_count;\n\t}\n\tif (nic->rxd_mode == RXD_MODE_1)\n\t\tsize = (size * (sizeof(struct RxD1)));\n\telse\n\t\tsize = (size * (sizeof(struct RxD3)));\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\tring->rx_curr_get_info.block_index = 0;\n\t\tring->rx_curr_get_info.offset = 0;\n\t\tring->rx_curr_get_info.ring_len = rx_cfg->num_rxd - 1;\n\t\tring->rx_curr_put_info.block_index = 0;\n\t\tring->rx_curr_put_info.offset = 0;\n\t\tring->rx_curr_put_info.ring_len = rx_cfg->num_rxd - 1;\n\t\tring->nic = nic;\n\t\tring->ring_no = i;\n\n\t\tblk_cnt = rx_cfg->num_rxd / (rxd_count[nic->rxd_mode] + 1);\n\t\t \n\t\tfor (j = 0; j < blk_cnt; j++) {\n\t\t\tstruct rx_block_info *rx_blocks;\n\t\t\tint l;\n\n\t\t\trx_blocks = &ring->rx_blocks[j];\n\t\t\tsize = SIZE_OF_BLOCK;\t \n\t\t\ttmp_v_addr = dma_alloc_coherent(&nic->pdev->dev, size,\n\t\t\t\t\t\t\t&tmp_p_addr, GFP_KERNEL);\n\t\t\tif (tmp_v_addr == NULL) {\n\t\t\t\t \n\t\t\t\trx_blocks->block_virt_addr = tmp_v_addr;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmem_allocated += size;\n\n\t\t\tsize = sizeof(struct rxd_info) *\n\t\t\t\trxd_count[nic->rxd_mode];\n\t\t\trx_blocks->block_virt_addr = tmp_v_addr;\n\t\t\trx_blocks->block_dma_addr = tmp_p_addr;\n\t\t\trx_blocks->rxds = kmalloc(size,  GFP_KERNEL);\n\t\t\tif (!rx_blocks->rxds)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmem_allocated += size;\n\t\t\tfor (l = 0; l < rxd_count[nic->rxd_mode]; l++) {\n\t\t\t\trx_blocks->rxds[l].virt_addr =\n\t\t\t\t\trx_blocks->block_virt_addr +\n\t\t\t\t\t(rxd_size[nic->rxd_mode] * l);\n\t\t\t\trx_blocks->rxds[l].dma_addr =\n\t\t\t\t\trx_blocks->block_dma_addr +\n\t\t\t\t\t(rxd_size[nic->rxd_mode] * l);\n\t\t\t}\n\t\t}\n\t\t \n\t\tfor (j = 0; j < blk_cnt; j++) {\n\t\t\tint next = (j + 1) % blk_cnt;\n\t\t\ttmp_v_addr = ring->rx_blocks[j].block_virt_addr;\n\t\t\ttmp_v_addr_next = ring->rx_blocks[next].block_virt_addr;\n\t\t\ttmp_p_addr = ring->rx_blocks[j].block_dma_addr;\n\t\t\ttmp_p_addr_next = ring->rx_blocks[next].block_dma_addr;\n\n\t\t\tpre_rxd_blk = tmp_v_addr;\n\t\t\tpre_rxd_blk->reserved_2_pNext_RxD_block =\n\t\t\t\t(unsigned long)tmp_v_addr_next;\n\t\t\tpre_rxd_blk->pNext_RxD_Blk_physical =\n\t\t\t\t(u64)tmp_p_addr_next;\n\t\t}\n\t}\n\tif (nic->rxd_mode == RXD_MODE_3B) {\n\t\t \n\t\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\t\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\t\tblk_cnt = rx_cfg->num_rxd /\n\t\t\t\t(rxd_count[nic->rxd_mode] + 1);\n\t\t\tsize = sizeof(struct buffAdd *) * blk_cnt;\n\t\t\tring->ba = kmalloc(size, GFP_KERNEL);\n\t\t\tif (!ring->ba)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmem_allocated += size;\n\t\t\tfor (j = 0; j < blk_cnt; j++) {\n\t\t\t\tint k = 0;\n\n\t\t\t\tsize = sizeof(struct buffAdd) *\n\t\t\t\t\t(rxd_count[nic->rxd_mode] + 1);\n\t\t\t\tring->ba[j] = kmalloc(size, GFP_KERNEL);\n\t\t\t\tif (!ring->ba[j])\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tmem_allocated += size;\n\t\t\t\twhile (k != rxd_count[nic->rxd_mode]) {\n\t\t\t\t\tba = &ring->ba[j][k];\n\t\t\t\t\tsize = BUF0_LEN + ALIGN_SIZE;\n\t\t\t\t\tba->ba_0_org = kmalloc(size, GFP_KERNEL);\n\t\t\t\t\tif (!ba->ba_0_org)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tmem_allocated += size;\n\t\t\t\t\ttmp = (unsigned long)ba->ba_0_org;\n\t\t\t\t\ttmp += ALIGN_SIZE;\n\t\t\t\t\ttmp &= ~((unsigned long)ALIGN_SIZE);\n\t\t\t\t\tba->ba_0 = (void *)tmp;\n\n\t\t\t\t\tsize = BUF1_LEN + ALIGN_SIZE;\n\t\t\t\t\tba->ba_1_org = kmalloc(size, GFP_KERNEL);\n\t\t\t\t\tif (!ba->ba_1_org)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tmem_allocated += size;\n\t\t\t\t\ttmp = (unsigned long)ba->ba_1_org;\n\t\t\t\t\ttmp += ALIGN_SIZE;\n\t\t\t\t\ttmp &= ~((unsigned long)ALIGN_SIZE);\n\t\t\t\t\tba->ba_1 = (void *)tmp;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tsize = sizeof(struct stat_block);\n\tmac_control->stats_mem =\n\t\tdma_alloc_coherent(&nic->pdev->dev, size,\n\t\t\t\t   &mac_control->stats_mem_phy, GFP_KERNEL);\n\n\tif (!mac_control->stats_mem) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\tmem_allocated += size;\n\tmac_control->stats_mem_sz = size;\n\n\ttmp_v_addr = mac_control->stats_mem;\n\tmac_control->stats_info = tmp_v_addr;\n\tmemset(tmp_v_addr, 0, size);\n\tDBG_PRINT(INIT_DBG, \"%s: Ring Mem PHY: 0x%llx\\n\",\n\t\tdev_name(&nic->pdev->dev), (unsigned long long)tmp_p_addr);\n\tmac_control->stats_info->sw_stat.mem_allocated += mem_allocated;\n\treturn SUCCESS;\n}\n\n \n\nstatic void free_shared_mem(struct s2io_nic *nic)\n{\n\tint i, j, blk_cnt, size;\n\tvoid *tmp_v_addr;\n\tdma_addr_t tmp_p_addr;\n\tint lst_size, lst_per_page;\n\tstruct net_device *dev;\n\tint page_num = 0;\n\tstruct config_param *config;\n\tstruct mac_info *mac_control;\n\tstruct stat_block *stats;\n\tstruct swStat *swstats;\n\n\tif (!nic)\n\t\treturn;\n\n\tdev = nic->dev;\n\n\tconfig = &nic->config;\n\tmac_control = &nic->mac_control;\n\tstats = mac_control->stats_info;\n\tswstats = &stats->sw_stat;\n\n\tlst_size = sizeof(struct TxD) * config->max_txds;\n\tlst_per_page = PAGE_SIZE / lst_size;\n\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\tpage_num = TXD_MEM_PAGE_CNT(tx_cfg->fifo_len, lst_per_page);\n\t\tfor (j = 0; j < page_num; j++) {\n\t\t\tint mem_blks = (j * lst_per_page);\n\t\t\tstruct list_info_hold *fli;\n\n\t\t\tif (!fifo->list_info)\n\t\t\t\treturn;\n\n\t\t\tfli = &fifo->list_info[mem_blks];\n\t\t\tif (!fli->list_virt_addr)\n\t\t\t\tbreak;\n\t\t\tdma_free_coherent(&nic->pdev->dev, PAGE_SIZE,\n\t\t\t\t\t  fli->list_virt_addr,\n\t\t\t\t\t  fli->list_phy_addr);\n\t\t\tswstats->mem_freed += PAGE_SIZE;\n\t\t}\n\t\t \n\t\tif (mac_control->zerodma_virt_addr) {\n\t\t\tdma_free_coherent(&nic->pdev->dev, PAGE_SIZE,\n\t\t\t\t\t  mac_control->zerodma_virt_addr,\n\t\t\t\t\t  (dma_addr_t)0);\n\t\t\tDBG_PRINT(INIT_DBG,\n\t\t\t\t  \"%s: Freeing TxDL with zero DMA address. \"\n\t\t\t\t  \"Virtual address %p\\n\",\n\t\t\t\t  dev->name, mac_control->zerodma_virt_addr);\n\t\t\tswstats->mem_freed += PAGE_SIZE;\n\t\t}\n\t\tkfree(fifo->list_info);\n\t\tswstats->mem_freed += tx_cfg->fifo_len *\n\t\t\tsizeof(struct list_info_hold);\n\t}\n\n\tsize = SIZE_OF_BLOCK;\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\tblk_cnt = ring->block_count;\n\t\tfor (j = 0; j < blk_cnt; j++) {\n\t\t\ttmp_v_addr = ring->rx_blocks[j].block_virt_addr;\n\t\t\ttmp_p_addr = ring->rx_blocks[j].block_dma_addr;\n\t\t\tif (tmp_v_addr == NULL)\n\t\t\t\tbreak;\n\t\t\tdma_free_coherent(&nic->pdev->dev, size, tmp_v_addr,\n\t\t\t\t\t  tmp_p_addr);\n\t\t\tswstats->mem_freed += size;\n\t\t\tkfree(ring->rx_blocks[j].rxds);\n\t\t\tswstats->mem_freed += sizeof(struct rxd_info) *\n\t\t\t\trxd_count[nic->rxd_mode];\n\t\t}\n\t}\n\n\tif (nic->rxd_mode == RXD_MODE_3B) {\n\t\t \n\t\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\t\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\t\tblk_cnt = rx_cfg->num_rxd /\n\t\t\t\t(rxd_count[nic->rxd_mode] + 1);\n\t\t\tfor (j = 0; j < blk_cnt; j++) {\n\t\t\t\tint k = 0;\n\t\t\t\tif (!ring->ba[j])\n\t\t\t\t\tcontinue;\n\t\t\t\twhile (k != rxd_count[nic->rxd_mode]) {\n\t\t\t\t\tstruct buffAdd *ba = &ring->ba[j][k];\n\t\t\t\t\tkfree(ba->ba_0_org);\n\t\t\t\t\tswstats->mem_freed +=\n\t\t\t\t\t\tBUF0_LEN + ALIGN_SIZE;\n\t\t\t\t\tkfree(ba->ba_1_org);\n\t\t\t\t\tswstats->mem_freed +=\n\t\t\t\t\t\tBUF1_LEN + ALIGN_SIZE;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tkfree(ring->ba[j]);\n\t\t\t\tswstats->mem_freed += sizeof(struct buffAdd) *\n\t\t\t\t\t(rxd_count[nic->rxd_mode] + 1);\n\t\t\t}\n\t\t\tkfree(ring->ba);\n\t\t\tswstats->mem_freed += sizeof(struct buffAdd *) *\n\t\t\t\tblk_cnt;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nic->config.tx_fifo_num; i++) {\n\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\tif (fifo->ufo_in_band_v) {\n\t\t\tswstats->mem_freed += tx_cfg->fifo_len *\n\t\t\t\tsizeof(u64);\n\t\t\tkfree(fifo->ufo_in_band_v);\n\t\t}\n\t}\n\n\tif (mac_control->stats_mem) {\n\t\tswstats->mem_freed += mac_control->stats_mem_sz;\n\t\tdma_free_coherent(&nic->pdev->dev, mac_control->stats_mem_sz,\n\t\t\t\t  mac_control->stats_mem,\n\t\t\t\t  mac_control->stats_mem_phy);\n\t}\n}\n\n \n\nstatic int s2io_verify_pci_mode(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 val64 = 0;\n\tint     mode;\n\n\tval64 = readq(&bar0->pci_mode);\n\tmode = (u8)GET_PCI_MODE(val64);\n\n\tif (val64 & PCI_MODE_UNKNOWN_MODE)\n\t\treturn -1;       \n\treturn mode;\n}\n\n#define NEC_VENID   0x1033\n#define NEC_DEVID   0x0125\nstatic int s2io_on_nec_bridge(struct pci_dev *s2io_pdev)\n{\n\tstruct pci_dev *tdev = NULL;\n\tfor_each_pci_dev(tdev) {\n\t\tif (tdev->vendor == NEC_VENID && tdev->device == NEC_DEVID) {\n\t\t\tif (tdev->bus == s2io_pdev->bus->parent) {\n\t\t\t\tpci_dev_put(tdev);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int bus_speed[8] = {33, 133, 133, 200, 266, 133, 200, 266};\n \nstatic int s2io_print_pci_mode(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 val64 = 0;\n\tint\tmode;\n\tstruct config_param *config = &nic->config;\n\tconst char *pcimode;\n\n\tval64 = readq(&bar0->pci_mode);\n\tmode = (u8)GET_PCI_MODE(val64);\n\n\tif (val64 & PCI_MODE_UNKNOWN_MODE)\n\t\treturn -1;\t \n\n\tconfig->bus_speed = bus_speed[mode];\n\n\tif (s2io_on_nec_bridge(nic->pdev)) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Device is on PCI-E bus\\n\",\n\t\t\t  nic->dev->name);\n\t\treturn mode;\n\t}\n\n\tswitch (mode) {\n\tcase PCI_MODE_PCI_33:\n\t\tpcimode = \"33MHz PCI bus\";\n\t\tbreak;\n\tcase PCI_MODE_PCI_66:\n\t\tpcimode = \"66MHz PCI bus\";\n\t\tbreak;\n\tcase PCI_MODE_PCIX_M1_66:\n\t\tpcimode = \"66MHz PCIX(M1) bus\";\n\t\tbreak;\n\tcase PCI_MODE_PCIX_M1_100:\n\t\tpcimode = \"100MHz PCIX(M1) bus\";\n\t\tbreak;\n\tcase PCI_MODE_PCIX_M1_133:\n\t\tpcimode = \"133MHz PCIX(M1) bus\";\n\t\tbreak;\n\tcase PCI_MODE_PCIX_M2_66:\n\t\tpcimode = \"133MHz PCIX(M2) bus\";\n\t\tbreak;\n\tcase PCI_MODE_PCIX_M2_100:\n\t\tpcimode = \"200MHz PCIX(M2) bus\";\n\t\tbreak;\n\tcase PCI_MODE_PCIX_M2_133:\n\t\tpcimode = \"266MHz PCIX(M2) bus\";\n\t\tbreak;\n\tdefault:\n\t\tpcimode = \"unsupported bus!\";\n\t\tmode = -1;\n\t}\n\n\tDBG_PRINT(ERR_DBG, \"%s: Device is on %d bit %s\\n\",\n\t\t  nic->dev->name, val64 & PCI_MODE_32_BITS ? 32 : 64, pcimode);\n\n\treturn mode;\n}\n\n \n\nstatic int init_tti(struct s2io_nic *nic, int link, bool may_sleep)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 val64 = 0;\n\tint i;\n\tstruct config_param *config = &nic->config;\n\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\t \n\t\tif (nic->device_type == XFRAME_II_DEVICE) {\n\t\t\tint count = (nic->config.bus_speed * 125)/2;\n\t\t\tval64 = TTI_DATA1_MEM_TX_TIMER_VAL(count);\n\t\t} else\n\t\t\tval64 = TTI_DATA1_MEM_TX_TIMER_VAL(0x2078);\n\n\t\tval64 |= TTI_DATA1_MEM_TX_URNG_A(0xA) |\n\t\t\tTTI_DATA1_MEM_TX_URNG_B(0x10) |\n\t\t\tTTI_DATA1_MEM_TX_URNG_C(0x30) |\n\t\t\tTTI_DATA1_MEM_TX_TIMER_AC_EN;\n\t\tif (i == 0)\n\t\t\tif (use_continuous_tx_intrs && (link == LINK_UP))\n\t\t\t\tval64 |= TTI_DATA1_MEM_TX_TIMER_CI_EN;\n\t\twriteq(val64, &bar0->tti_data1_mem);\n\n\t\tif (nic->config.intr_type == MSI_X) {\n\t\t\tval64 = TTI_DATA2_MEM_TX_UFC_A(0x10) |\n\t\t\t\tTTI_DATA2_MEM_TX_UFC_B(0x100) |\n\t\t\t\tTTI_DATA2_MEM_TX_UFC_C(0x200) |\n\t\t\t\tTTI_DATA2_MEM_TX_UFC_D(0x300);\n\t\t} else {\n\t\t\tif ((nic->config.tx_steering_type ==\n\t\t\t     TX_DEFAULT_STEERING) &&\n\t\t\t    (config->tx_fifo_num > 1) &&\n\t\t\t    (i >= nic->udp_fifo_idx) &&\n\t\t\t    (i < (nic->udp_fifo_idx +\n\t\t\t\t  nic->total_udp_fifos)))\n\t\t\t\tval64 = TTI_DATA2_MEM_TX_UFC_A(0x50) |\n\t\t\t\t\tTTI_DATA2_MEM_TX_UFC_B(0x80) |\n\t\t\t\t\tTTI_DATA2_MEM_TX_UFC_C(0x100) |\n\t\t\t\t\tTTI_DATA2_MEM_TX_UFC_D(0x120);\n\t\t\telse\n\t\t\t\tval64 = TTI_DATA2_MEM_TX_UFC_A(0x10) |\n\t\t\t\t\tTTI_DATA2_MEM_TX_UFC_B(0x20) |\n\t\t\t\t\tTTI_DATA2_MEM_TX_UFC_C(0x40) |\n\t\t\t\t\tTTI_DATA2_MEM_TX_UFC_D(0x80);\n\t\t}\n\n\t\twriteq(val64, &bar0->tti_data2_mem);\n\n\t\tval64 = TTI_CMD_MEM_WE |\n\t\t\tTTI_CMD_MEM_STROBE_NEW_CMD |\n\t\t\tTTI_CMD_MEM_OFFSET(i);\n\t\twriteq(val64, &bar0->tti_command_mem);\n\n\t\tif (wait_for_cmd_complete(&bar0->tti_command_mem,\n\t\t\t\t\t  TTI_CMD_MEM_STROBE_NEW_CMD,\n\t\t\t\t\t  S2IO_BIT_RESET, may_sleep) != SUCCESS)\n\t\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n\n \n\nstatic int init_nic(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tstruct net_device *dev = nic->dev;\n\tregister u64 val64 = 0;\n\tvoid __iomem *add;\n\tu32 time;\n\tint i, j;\n\tint dtx_cnt = 0;\n\tunsigned long long mem_share;\n\tint mem_size;\n\tstruct config_param *config = &nic->config;\n\tstruct mac_info *mac_control = &nic->mac_control;\n\n\t \n\tif (s2io_set_swapper(nic)) {\n\t\tDBG_PRINT(ERR_DBG, \"ERROR: Setting Swapper failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (nic->device_type & XFRAME_II_DEVICE) {\n\t\tval64 = 0xA500000000ULL;\n\t\twriteq(val64, &bar0->sw_reset);\n\t\tmsleep(500);\n\t\tval64 = readq(&bar0->sw_reset);\n\t}\n\n\t \n\tval64 = 0;\n\twriteq(val64, &bar0->sw_reset);\n\tmsleep(500);\n\tval64 = readq(&bar0->sw_reset);\n\n\t \n\tif (nic->device_type == XFRAME_II_DEVICE) {\n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tval64 = readq(&bar0->adapter_status);\n\t\t\tif (!(val64 & ADAPTER_STATUS_RIC_RUNNING))\n\t\t\t\tbreak;\n\t\t\tmsleep(10);\n\t\t}\n\t\tif (i == 50)\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\tadd = &bar0->mac_cfg;\n\tval64 = readq(&bar0->mac_cfg);\n\tval64 |= MAC_RMAC_BCAST_ENABLE;\n\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\twritel((u32)val64, add);\n\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\twritel((u32) (val64 >> 32), (add + 4));\n\n\t \n\tval64 = readq(&bar0->mac_int_mask);\n\tval64 = readq(&bar0->mc_int_mask);\n\tval64 = readq(&bar0->xgxs_int_mask);\n\n\t \n\tval64 = dev->mtu;\n\twriteq(vBIT(val64, 2, 14), &bar0->rmac_max_pyld_len);\n\n\tif (nic->device_type & XFRAME_II_DEVICE) {\n\t\twhile (herc_act_dtx_cfg[dtx_cnt] != END_SIGN) {\n\t\t\tSPECIAL_REG_WRITE(herc_act_dtx_cfg[dtx_cnt],\n\t\t\t\t\t  &bar0->dtx_control, UF);\n\t\t\tif (dtx_cnt & 0x1)\n\t\t\t\tmsleep(1);  \n\t\t\tdtx_cnt++;\n\t\t}\n\t} else {\n\t\twhile (xena_dtx_cfg[dtx_cnt] != END_SIGN) {\n\t\t\tSPECIAL_REG_WRITE(xena_dtx_cfg[dtx_cnt],\n\t\t\t\t\t  &bar0->dtx_control, UF);\n\t\t\tval64 = readq(&bar0->dtx_control);\n\t\t\tdtx_cnt++;\n\t\t}\n\t}\n\n\t \n\tval64 = 0;\n\twriteq(val64, &bar0->tx_fifo_partition_0);\n\twriteq(val64, &bar0->tx_fifo_partition_1);\n\twriteq(val64, &bar0->tx_fifo_partition_2);\n\twriteq(val64, &bar0->tx_fifo_partition_3);\n\n\tfor (i = 0, j = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\tval64 |= vBIT(tx_cfg->fifo_len - 1, ((j * 32) + 19), 13) |\n\t\t\tvBIT(tx_cfg->fifo_priority, ((j * 32) + 5), 3);\n\n\t\tif (i == (config->tx_fifo_num - 1)) {\n\t\t\tif (i % 2 == 0)\n\t\t\t\ti++;\n\t\t}\n\n\t\tswitch (i) {\n\t\tcase 1:\n\t\t\twriteq(val64, &bar0->tx_fifo_partition_0);\n\t\t\tval64 = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\twriteq(val64, &bar0->tx_fifo_partition_1);\n\t\t\tval64 = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\twriteq(val64, &bar0->tx_fifo_partition_2);\n\t\t\tval64 = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\twriteq(val64, &bar0->tx_fifo_partition_3);\n\t\t\tval64 = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tj++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif ((nic->device_type == XFRAME_I_DEVICE) && (nic->pdev->revision < 4))\n\t\twriteq(PCC_ENABLE_FOUR, &bar0->pcc_enable);\n\n\tval64 = readq(&bar0->tx_fifo_partition_0);\n\tDBG_PRINT(INIT_DBG, \"Fifo partition at: 0x%p is: 0x%llx\\n\",\n\t\t  &bar0->tx_fifo_partition_0, (unsigned long long)val64);\n\n\t \n\tval64 = readq(&bar0->tx_pa_cfg);\n\tval64 |= TX_PA_CFG_IGNORE_FRM_ERR |\n\t\tTX_PA_CFG_IGNORE_SNAP_OUI |\n\t\tTX_PA_CFG_IGNORE_LLC_CTRL |\n\t\tTX_PA_CFG_IGNORE_L2_ERR;\n\twriteq(val64, &bar0->tx_pa_cfg);\n\n\t \n\tval64 = 0;\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\n\t\tval64 |= vBIT(rx_cfg->ring_priority, (5 + (i * 8)), 3);\n\t}\n\twriteq(val64, &bar0->rx_queue_priority);\n\n\t \n\tval64 = 0;\n\tif (nic->device_type & XFRAME_II_DEVICE)\n\t\tmem_size = 32;\n\telse\n\t\tmem_size = 64;\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tmem_share = (mem_size / config->rx_ring_num +\n\t\t\t\t     mem_size % config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q0_SZ(mem_share);\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tmem_share = (mem_size / config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q1_SZ(mem_share);\n\t\t\tcontinue;\n\t\tcase 2:\n\t\t\tmem_share = (mem_size / config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q2_SZ(mem_share);\n\t\t\tcontinue;\n\t\tcase 3:\n\t\t\tmem_share = (mem_size / config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q3_SZ(mem_share);\n\t\t\tcontinue;\n\t\tcase 4:\n\t\t\tmem_share = (mem_size / config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q4_SZ(mem_share);\n\t\t\tcontinue;\n\t\tcase 5:\n\t\t\tmem_share = (mem_size / config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q5_SZ(mem_share);\n\t\t\tcontinue;\n\t\tcase 6:\n\t\t\tmem_share = (mem_size / config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q6_SZ(mem_share);\n\t\t\tcontinue;\n\t\tcase 7:\n\t\t\tmem_share = (mem_size / config->rx_ring_num);\n\t\t\tval64 |= RX_QUEUE_CFG_Q7_SZ(mem_share);\n\t\t\tcontinue;\n\t\t}\n\t}\n\twriteq(val64, &bar0->rx_queue_cfg);\n\n\t \n\tswitch (config->tx_fifo_num) {\n\tcase 1:\n\t\tval64 = 0x0;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\tcase 2:\n\t\tval64 = 0x0001000100010001ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\tval64 = 0x0001000100000000ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\tcase 3:\n\t\tval64 = 0x0001020001020001ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\tval64 = 0x0200010200010200ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\tval64 = 0x0102000102000102ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\tval64 = 0x0001020001020001ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\tval64 = 0x0200010200000000ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\tcase 4:\n\t\tval64 = 0x0001020300010203ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\tval64 = 0x0001020300000000ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\tcase 5:\n\t\tval64 = 0x0001020304000102ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\tval64 = 0x0304000102030400ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\tval64 = 0x0102030400010203ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\tval64 = 0x0400010203040001ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\tval64 = 0x0203040000000000ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\tcase 6:\n\t\tval64 = 0x0001020304050001ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\tval64 = 0x0203040500010203ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\tval64 = 0x0405000102030405ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\tval64 = 0x0001020304050001ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\tval64 = 0x0203040500000000ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\tcase 7:\n\t\tval64 = 0x0001020304050600ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\tval64 = 0x0102030405060001ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\tval64 = 0x0203040506000102ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\tval64 = 0x0304050600010203ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\tval64 = 0x0405060000000000ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\tcase 8:\n\t\tval64 = 0x0001020304050607ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_0);\n\t\twriteq(val64, &bar0->tx_w_round_robin_1);\n\t\twriteq(val64, &bar0->tx_w_round_robin_2);\n\t\twriteq(val64, &bar0->tx_w_round_robin_3);\n\t\tval64 = 0x0001020300000000ULL;\n\t\twriteq(val64, &bar0->tx_w_round_robin_4);\n\t\tbreak;\n\t}\n\n\t \n\tval64 = readq(&bar0->tx_fifo_partition_0);\n\tval64 |= (TX_FIFO_PARTITION_EN);\n\twriteq(val64, &bar0->tx_fifo_partition_0);\n\n\t \n\tswitch (config->rx_ring_num) {\n\tcase 1:\n\t\tval64 = 0x0;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8080808080808080ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\tcase 2:\n\t\tval64 = 0x0001000100010001ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\tval64 = 0x0001000100000000ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8080808040404040ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\tcase 3:\n\t\tval64 = 0x0001020001020001ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\tval64 = 0x0200010200010200ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\tval64 = 0x0102000102000102ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\tval64 = 0x0001020001020001ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\tval64 = 0x0200010200000000ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8080804040402020ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\tcase 4:\n\t\tval64 = 0x0001020300010203ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\tval64 = 0x0001020300000000ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8080404020201010ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\tcase 5:\n\t\tval64 = 0x0001020304000102ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\tval64 = 0x0304000102030400ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\tval64 = 0x0102030400010203ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\tval64 = 0x0400010203040001ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\tval64 = 0x0203040000000000ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8080404020201008ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\tcase 6:\n\t\tval64 = 0x0001020304050001ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\tval64 = 0x0203040500010203ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\tval64 = 0x0405000102030405ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\tval64 = 0x0001020304050001ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\tval64 = 0x0203040500000000ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8080404020100804ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\tcase 7:\n\t\tval64 = 0x0001020304050600ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\tval64 = 0x0102030405060001ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\tval64 = 0x0203040506000102ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\tval64 = 0x0304050600010203ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\tval64 = 0x0405060000000000ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8080402010080402ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\tcase 8:\n\t\tval64 = 0x0001020304050607ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_0);\n\t\twriteq(val64, &bar0->rx_w_round_robin_1);\n\t\twriteq(val64, &bar0->rx_w_round_robin_2);\n\t\twriteq(val64, &bar0->rx_w_round_robin_3);\n\t\tval64 = 0x0001020300000000ULL;\n\t\twriteq(val64, &bar0->rx_w_round_robin_4);\n\n\t\tval64 = 0x8040201008040201ULL;\n\t\twriteq(val64, &bar0->rts_qos_steering);\n\t\tbreak;\n\t}\n\n\t \n\tval64 = 0;\n\tfor (i = 0; i < 8; i++)\n\t\twriteq(val64, &bar0->rts_frm_len_n[i]);\n\n\t \n\tval64 = MAC_RTS_FRM_LEN_SET(dev->mtu+22);\n\tfor (i = 0 ; i < config->rx_ring_num ; i++)\n\t\twriteq(val64, &bar0->rts_frm_len_n[i]);\n\n\t \n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\t \n\t\tif (rts_frm_len[i] != 0) {\n\t\t\twriteq(MAC_RTS_FRM_LEN_SET(rts_frm_len[i]),\n\t\t\t       &bar0->rts_frm_len_n[i]);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\tif (rts_ds_steer(nic, i, 0) == FAILURE) {\n\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t  \"%s: rts_ds_steer failed on codepoint %d\\n\",\n\t\t\t\t  dev->name, i);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\twriteq(mac_control->stats_mem_phy, &bar0->stat_addr);\n\n\tif (nic->device_type == XFRAME_II_DEVICE) {\n\t\tval64 = STAT_BC(0x320);\n\t\twriteq(val64, &bar0->stat_byte_cnt);\n\t}\n\n\t \n\tval64 = MAC_TX_LINK_UTIL_VAL(tmac_util_period) |\n\t\tMAC_RX_LINK_UTIL_VAL(rmac_util_period);\n\twriteq(val64, &bar0->mac_link_util);\n\n\t \n\n\t \n\tif (SUCCESS != init_tti(nic, nic->last_link_state, true))\n\t\treturn -ENODEV;\n\n\t \n\tif (nic->device_type == XFRAME_II_DEVICE) {\n\t\t \n\t\tint count = (nic->config.bus_speed * 125)/4;\n\t\tval64 = RTI_DATA1_MEM_RX_TIMER_VAL(count);\n\t} else\n\t\tval64 = RTI_DATA1_MEM_RX_TIMER_VAL(0xFFF);\n\tval64 |= RTI_DATA1_MEM_RX_URNG_A(0xA) |\n\t\tRTI_DATA1_MEM_RX_URNG_B(0x10) |\n\t\tRTI_DATA1_MEM_RX_URNG_C(0x30) |\n\t\tRTI_DATA1_MEM_RX_TIMER_AC_EN;\n\n\twriteq(val64, &bar0->rti_data1_mem);\n\n\tval64 = RTI_DATA2_MEM_RX_UFC_A(0x1) |\n\t\tRTI_DATA2_MEM_RX_UFC_B(0x2) ;\n\tif (nic->config.intr_type == MSI_X)\n\t\tval64 |= (RTI_DATA2_MEM_RX_UFC_C(0x20) |\n\t\t\t  RTI_DATA2_MEM_RX_UFC_D(0x40));\n\telse\n\t\tval64 |= (RTI_DATA2_MEM_RX_UFC_C(0x40) |\n\t\t\t  RTI_DATA2_MEM_RX_UFC_D(0x80));\n\twriteq(val64, &bar0->rti_data2_mem);\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tval64 = RTI_CMD_MEM_WE |\n\t\t\tRTI_CMD_MEM_STROBE_NEW_CMD |\n\t\t\tRTI_CMD_MEM_OFFSET(i);\n\t\twriteq(val64, &bar0->rti_command_mem);\n\n\t\t \n\t\ttime = 0;\n\t\twhile (true) {\n\t\t\tval64 = readq(&bar0->rti_command_mem);\n\t\t\tif (!(val64 & RTI_CMD_MEM_STROBE_NEW_CMD))\n\t\t\t\tbreak;\n\n\t\t\tif (time > 10) {\n\t\t\t\tDBG_PRINT(ERR_DBG, \"%s: RTI init failed\\n\",\n\t\t\t\t\t  dev->name);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\ttime++;\n\t\t\tmsleep(50);\n\t\t}\n\t}\n\n\t \n\twriteq(0xffbbffbbffbbffbbULL, &bar0->mc_pause_thresh_q0q3);\n\twriteq(0xffbbffbbffbbffbbULL, &bar0->mc_pause_thresh_q4q7);\n\n\t \n\tadd = &bar0->mac_cfg;\n\tval64 = readq(&bar0->mac_cfg);\n\tval64 &= ~(MAC_CFG_RMAC_STRIP_PAD);\n\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\twritel((u32) (val64), add);\n\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\twritel((u32) (val64 >> 32), (add + 4));\n\tval64 = readq(&bar0->mac_cfg);\n\n\t \n\tadd = &bar0->mac_cfg;\n\tval64 = readq(&bar0->mac_cfg);\n\tval64 |= MAC_CFG_RMAC_STRIP_FCS;\n\tif (nic->device_type == XFRAME_II_DEVICE)\n\t\twriteq(val64, &bar0->mac_cfg);\n\telse {\n\t\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\t\twritel((u32) (val64), add);\n\t\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\t\twritel((u32) (val64 >> 32), (add + 4));\n\t}\n\n\t \n\tval64 = readq(&bar0->rmac_pause_cfg);\n\tval64 &= ~(RMAC_PAUSE_HG_PTIME(0xffff));\n\tval64 |= RMAC_PAUSE_HG_PTIME(nic->mac_control.rmac_pause_time);\n\twriteq(val64, &bar0->rmac_pause_cfg);\n\n\t \n\tval64 = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tval64 |= (((u64)0xFF00 |\n\t\t\t   nic->mac_control.mc_pause_threshold_q0q3)\n\t\t\t  << (i * 2 * 8));\n\t}\n\twriteq(val64, &bar0->mc_pause_thresh_q0q3);\n\n\tval64 = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tval64 |= (((u64)0xFF00 |\n\t\t\t   nic->mac_control.mc_pause_threshold_q4q7)\n\t\t\t  << (i * 2 * 8));\n\t}\n\twriteq(val64, &bar0->mc_pause_thresh_q4q7);\n\n\t \n\tval64 = readq(&bar0->pic_control);\n\tval64 |= PIC_CNTL_SHARED_SPLITS(shared_splits);\n\twriteq(val64, &bar0->pic_control);\n\n\tif (nic->config.bus_speed == 266) {\n\t\twriteq(TXREQTO_VAL(0x7f) | TXREQTO_EN, &bar0->txreqtimeout);\n\t\twriteq(0x0, &bar0->read_retry_delay);\n\t\twriteq(0x0, &bar0->write_retry_delay);\n\t}\n\n\t \n\tif (nic->device_type == XFRAME_II_DEVICE) {\n\t\tval64 = FAULT_BEHAVIOUR | EXT_REQ_EN |\n\t\t\tMISC_LINK_STABILITY_PRD(3);\n\t\twriteq(val64, &bar0->misc_control);\n\t\tval64 = readq(&bar0->pic_control2);\n\t\tval64 &= ~(s2BIT(13)|s2BIT(14)|s2BIT(15));\n\t\twriteq(val64, &bar0->pic_control2);\n\t}\n\tif (strstr(nic->product_name, \"CX4\")) {\n\t\tval64 = TMAC_AVG_IPG(0x17);\n\t\twriteq(val64, &bar0->tmac_avg_ipg);\n\t}\n\n\treturn SUCCESS;\n}\n#define LINK_UP_DOWN_INTERRUPT\t\t1\n#define MAC_RMAC_ERR_TIMER\t\t2\n\nstatic int s2io_link_fault_indication(struct s2io_nic *nic)\n{\n\tif (nic->device_type == XFRAME_II_DEVICE)\n\t\treturn LINK_UP_DOWN_INTERRUPT;\n\telse\n\t\treturn MAC_RMAC_ERR_TIMER;\n}\n\n \nstatic void do_s2io_write_bits(u64 value, int flag, void __iomem *addr)\n{\n\tu64 temp64;\n\n\ttemp64 = readq(addr);\n\n\tif (flag == ENABLE_INTRS)\n\t\ttemp64 &= ~((u64)value);\n\telse\n\t\ttemp64 |= ((u64)value);\n\twriteq(temp64, addr);\n}\n\nstatic void en_dis_err_alarms(struct s2io_nic *nic, u16 mask, int flag)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 gen_int_mask = 0;\n\tu64 interruptible;\n\n\twriteq(DISABLE_ALL_INTRS, &bar0->general_int_mask);\n\tif (mask & TX_DMA_INTR) {\n\t\tgen_int_mask |= TXDMA_INT_M;\n\n\t\tdo_s2io_write_bits(TXDMA_TDA_INT | TXDMA_PFC_INT |\n\t\t\t\t   TXDMA_PCC_INT | TXDMA_TTI_INT |\n\t\t\t\t   TXDMA_LSO_INT | TXDMA_TPA_INT |\n\t\t\t\t   TXDMA_SM_INT, flag, &bar0->txdma_int_mask);\n\n\t\tdo_s2io_write_bits(PFC_ECC_DB_ERR | PFC_SM_ERR_ALARM |\n\t\t\t\t   PFC_MISC_0_ERR | PFC_MISC_1_ERR |\n\t\t\t\t   PFC_PCIX_ERR | PFC_ECC_SG_ERR, flag,\n\t\t\t\t   &bar0->pfc_err_mask);\n\n\t\tdo_s2io_write_bits(TDA_Fn_ECC_DB_ERR | TDA_SM0_ERR_ALARM |\n\t\t\t\t   TDA_SM1_ERR_ALARM | TDA_Fn_ECC_SG_ERR |\n\t\t\t\t   TDA_PCIX_ERR, flag, &bar0->tda_err_mask);\n\n\t\tdo_s2io_write_bits(PCC_FB_ECC_DB_ERR | PCC_TXB_ECC_DB_ERR |\n\t\t\t\t   PCC_SM_ERR_ALARM | PCC_WR_ERR_ALARM |\n\t\t\t\t   PCC_N_SERR | PCC_6_COF_OV_ERR |\n\t\t\t\t   PCC_7_COF_OV_ERR | PCC_6_LSO_OV_ERR |\n\t\t\t\t   PCC_7_LSO_OV_ERR | PCC_FB_ECC_SG_ERR |\n\t\t\t\t   PCC_TXB_ECC_SG_ERR,\n\t\t\t\t   flag, &bar0->pcc_err_mask);\n\n\t\tdo_s2io_write_bits(TTI_SM_ERR_ALARM | TTI_ECC_SG_ERR |\n\t\t\t\t   TTI_ECC_DB_ERR, flag, &bar0->tti_err_mask);\n\n\t\tdo_s2io_write_bits(LSO6_ABORT | LSO7_ABORT |\n\t\t\t\t   LSO6_SM_ERR_ALARM | LSO7_SM_ERR_ALARM |\n\t\t\t\t   LSO6_SEND_OFLOW | LSO7_SEND_OFLOW,\n\t\t\t\t   flag, &bar0->lso_err_mask);\n\n\t\tdo_s2io_write_bits(TPA_SM_ERR_ALARM | TPA_TX_FRM_DROP,\n\t\t\t\t   flag, &bar0->tpa_err_mask);\n\n\t\tdo_s2io_write_bits(SM_SM_ERR_ALARM, flag, &bar0->sm_err_mask);\n\t}\n\n\tif (mask & TX_MAC_INTR) {\n\t\tgen_int_mask |= TXMAC_INT_M;\n\t\tdo_s2io_write_bits(MAC_INT_STATUS_TMAC_INT, flag,\n\t\t\t\t   &bar0->mac_int_mask);\n\t\tdo_s2io_write_bits(TMAC_TX_BUF_OVRN | TMAC_TX_SM_ERR |\n\t\t\t\t   TMAC_ECC_SG_ERR | TMAC_ECC_DB_ERR |\n\t\t\t\t   TMAC_DESC_ECC_SG_ERR | TMAC_DESC_ECC_DB_ERR,\n\t\t\t\t   flag, &bar0->mac_tmac_err_mask);\n\t}\n\n\tif (mask & TX_XGXS_INTR) {\n\t\tgen_int_mask |= TXXGXS_INT_M;\n\t\tdo_s2io_write_bits(XGXS_INT_STATUS_TXGXS, flag,\n\t\t\t\t   &bar0->xgxs_int_mask);\n\t\tdo_s2io_write_bits(TXGXS_ESTORE_UFLOW | TXGXS_TX_SM_ERR |\n\t\t\t\t   TXGXS_ECC_SG_ERR | TXGXS_ECC_DB_ERR,\n\t\t\t\t   flag, &bar0->xgxs_txgxs_err_mask);\n\t}\n\n\tif (mask & RX_DMA_INTR) {\n\t\tgen_int_mask |= RXDMA_INT_M;\n\t\tdo_s2io_write_bits(RXDMA_INT_RC_INT_M | RXDMA_INT_RPA_INT_M |\n\t\t\t\t   RXDMA_INT_RDA_INT_M | RXDMA_INT_RTI_INT_M,\n\t\t\t\t   flag, &bar0->rxdma_int_mask);\n\t\tdo_s2io_write_bits(RC_PRCn_ECC_DB_ERR | RC_FTC_ECC_DB_ERR |\n\t\t\t\t   RC_PRCn_SM_ERR_ALARM | RC_FTC_SM_ERR_ALARM |\n\t\t\t\t   RC_PRCn_ECC_SG_ERR | RC_FTC_ECC_SG_ERR |\n\t\t\t\t   RC_RDA_FAIL_WR_Rn, flag, &bar0->rc_err_mask);\n\t\tdo_s2io_write_bits(PRC_PCI_AB_RD_Rn | PRC_PCI_AB_WR_Rn |\n\t\t\t\t   PRC_PCI_AB_F_WR_Rn | PRC_PCI_DP_RD_Rn |\n\t\t\t\t   PRC_PCI_DP_WR_Rn | PRC_PCI_DP_F_WR_Rn, flag,\n\t\t\t\t   &bar0->prc_pcix_err_mask);\n\t\tdo_s2io_write_bits(RPA_SM_ERR_ALARM | RPA_CREDIT_ERR |\n\t\t\t\t   RPA_ECC_SG_ERR | RPA_ECC_DB_ERR, flag,\n\t\t\t\t   &bar0->rpa_err_mask);\n\t\tdo_s2io_write_bits(RDA_RXDn_ECC_DB_ERR | RDA_FRM_ECC_DB_N_AERR |\n\t\t\t\t   RDA_SM1_ERR_ALARM | RDA_SM0_ERR_ALARM |\n\t\t\t\t   RDA_RXD_ECC_DB_SERR | RDA_RXDn_ECC_SG_ERR |\n\t\t\t\t   RDA_FRM_ECC_SG_ERR |\n\t\t\t\t   RDA_MISC_ERR|RDA_PCIX_ERR,\n\t\t\t\t   flag, &bar0->rda_err_mask);\n\t\tdo_s2io_write_bits(RTI_SM_ERR_ALARM |\n\t\t\t\t   RTI_ECC_SG_ERR | RTI_ECC_DB_ERR,\n\t\t\t\t   flag, &bar0->rti_err_mask);\n\t}\n\n\tif (mask & RX_MAC_INTR) {\n\t\tgen_int_mask |= RXMAC_INT_M;\n\t\tdo_s2io_write_bits(MAC_INT_STATUS_RMAC_INT, flag,\n\t\t\t\t   &bar0->mac_int_mask);\n\t\tinterruptible = (RMAC_RX_BUFF_OVRN | RMAC_RX_SM_ERR |\n\t\t\t\t RMAC_UNUSED_INT | RMAC_SINGLE_ECC_ERR |\n\t\t\t\t RMAC_DOUBLE_ECC_ERR);\n\t\tif (s2io_link_fault_indication(nic) == MAC_RMAC_ERR_TIMER)\n\t\t\tinterruptible |= RMAC_LINK_STATE_CHANGE_INT;\n\t\tdo_s2io_write_bits(interruptible,\n\t\t\t\t   flag, &bar0->mac_rmac_err_mask);\n\t}\n\n\tif (mask & RX_XGXS_INTR) {\n\t\tgen_int_mask |= RXXGXS_INT_M;\n\t\tdo_s2io_write_bits(XGXS_INT_STATUS_RXGXS, flag,\n\t\t\t\t   &bar0->xgxs_int_mask);\n\t\tdo_s2io_write_bits(RXGXS_ESTORE_OFLOW | RXGXS_RX_SM_ERR, flag,\n\t\t\t\t   &bar0->xgxs_rxgxs_err_mask);\n\t}\n\n\tif (mask & MC_INTR) {\n\t\tgen_int_mask |= MC_INT_M;\n\t\tdo_s2io_write_bits(MC_INT_MASK_MC_INT,\n\t\t\t\t   flag, &bar0->mc_int_mask);\n\t\tdo_s2io_write_bits(MC_ERR_REG_SM_ERR | MC_ERR_REG_ECC_ALL_SNG |\n\t\t\t\t   MC_ERR_REG_ECC_ALL_DBL | PLL_LOCK_N, flag,\n\t\t\t\t   &bar0->mc_err_mask);\n\t}\n\tnic->general_int_mask = gen_int_mask;\n\n\t \n\tnic->general_int_mask = 0;\n}\n\n \n\nstatic void en_dis_able_nic_intrs(struct s2io_nic *nic, u16 mask, int flag)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 temp64 = 0, intr_mask = 0;\n\n\tintr_mask = nic->general_int_mask;\n\n\t \n\t \n\tif (mask & TX_PIC_INTR) {\n\t\t \n\t\tintr_mask |= TXPIC_INT_M;\n\t\tif (flag == ENABLE_INTRS) {\n\t\t\t \n\t\t\tif (s2io_link_fault_indication(nic) ==\n\t\t\t    LINK_UP_DOWN_INTERRUPT) {\n\t\t\t\tdo_s2io_write_bits(PIC_INT_GPIO, flag,\n\t\t\t\t\t\t   &bar0->pic_int_mask);\n\t\t\t\tdo_s2io_write_bits(GPIO_INT_MASK_LINK_UP, flag,\n\t\t\t\t\t\t   &bar0->gpio_int_mask);\n\t\t\t} else\n\t\t\t\twriteq(DISABLE_ALL_INTRS, &bar0->pic_int_mask);\n\t\t} else if (flag == DISABLE_INTRS) {\n\t\t\t \n\t\t\twriteq(DISABLE_ALL_INTRS, &bar0->pic_int_mask);\n\t\t}\n\t}\n\n\t \n\tif (mask & TX_TRAFFIC_INTR) {\n\t\tintr_mask |= TXTRAFFIC_INT_M;\n\t\tif (flag == ENABLE_INTRS) {\n\t\t\t \n\t\t\twriteq(0x0, &bar0->tx_traffic_mask);\n\t\t} else if (flag == DISABLE_INTRS) {\n\t\t\t \n\t\t\twriteq(DISABLE_ALL_INTRS, &bar0->tx_traffic_mask);\n\t\t}\n\t}\n\n\t \n\tif (mask & RX_TRAFFIC_INTR) {\n\t\tintr_mask |= RXTRAFFIC_INT_M;\n\t\tif (flag == ENABLE_INTRS) {\n\t\t\t \n\t\t\twriteq(0x0, &bar0->rx_traffic_mask);\n\t\t} else if (flag == DISABLE_INTRS) {\n\t\t\t \n\t\t\twriteq(DISABLE_ALL_INTRS, &bar0->rx_traffic_mask);\n\t\t}\n\t}\n\n\ttemp64 = readq(&bar0->general_int_mask);\n\tif (flag == ENABLE_INTRS)\n\t\ttemp64 &= ~((u64)intr_mask);\n\telse\n\t\ttemp64 = DISABLE_ALL_INTRS;\n\twriteq(temp64, &bar0->general_int_mask);\n\n\tnic->general_int_mask = readq(&bar0->general_int_mask);\n}\n\n \nstatic int verify_pcc_quiescent(struct s2io_nic *sp, int flag)\n{\n\tint ret = 0, herc;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64 = readq(&bar0->adapter_status);\n\n\therc = (sp->device_type == XFRAME_II_DEVICE);\n\n\tif (flag == false) {\n\t\tif ((!herc && (sp->pdev->revision >= 4)) || herc) {\n\t\t\tif (!(val64 & ADAPTER_STATUS_RMAC_PCC_IDLE))\n\t\t\t\tret = 1;\n\t\t} else {\n\t\t\tif (!(val64 & ADAPTER_STATUS_RMAC_PCC_FOUR_IDLE))\n\t\t\t\tret = 1;\n\t\t}\n\t} else {\n\t\tif ((!herc && (sp->pdev->revision >= 4)) || herc) {\n\t\t\tif (((val64 & ADAPTER_STATUS_RMAC_PCC_IDLE) ==\n\t\t\t     ADAPTER_STATUS_RMAC_PCC_IDLE))\n\t\t\t\tret = 1;\n\t\t} else {\n\t\t\tif (((val64 & ADAPTER_STATUS_RMAC_PCC_FOUR_IDLE) ==\n\t\t\t     ADAPTER_STATUS_RMAC_PCC_FOUR_IDLE))\n\t\t\t\tret = 1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n \n\nstatic int verify_xena_quiescence(struct s2io_nic *sp)\n{\n\tint  mode;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64 = readq(&bar0->adapter_status);\n\tmode = s2io_verify_pci_mode(sp);\n\n\tif (!(val64 & ADAPTER_STATUS_TDMA_READY)) {\n\t\tDBG_PRINT(ERR_DBG, \"TDMA is not ready!\\n\");\n\t\treturn 0;\n\t}\n\tif (!(val64 & ADAPTER_STATUS_RDMA_READY)) {\n\t\tDBG_PRINT(ERR_DBG, \"RDMA is not ready!\\n\");\n\t\treturn 0;\n\t}\n\tif (!(val64 & ADAPTER_STATUS_PFC_READY)) {\n\t\tDBG_PRINT(ERR_DBG, \"PFC is not ready!\\n\");\n\t\treturn 0;\n\t}\n\tif (!(val64 & ADAPTER_STATUS_TMAC_BUF_EMPTY)) {\n\t\tDBG_PRINT(ERR_DBG, \"TMAC BUF is not empty!\\n\");\n\t\treturn 0;\n\t}\n\tif (!(val64 & ADAPTER_STATUS_PIC_QUIESCENT)) {\n\t\tDBG_PRINT(ERR_DBG, \"PIC is not QUIESCENT!\\n\");\n\t\treturn 0;\n\t}\n\tif (!(val64 & ADAPTER_STATUS_MC_DRAM_READY)) {\n\t\tDBG_PRINT(ERR_DBG, \"MC_DRAM is not ready!\\n\");\n\t\treturn 0;\n\t}\n\tif (!(val64 & ADAPTER_STATUS_MC_QUEUES_READY)) {\n\t\tDBG_PRINT(ERR_DBG, \"MC_QUEUES is not ready!\\n\");\n\t\treturn 0;\n\t}\n\tif (!(val64 & ADAPTER_STATUS_M_PLL_LOCK)) {\n\t\tDBG_PRINT(ERR_DBG, \"M_PLL is not locked!\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(val64 & ADAPTER_STATUS_P_PLL_LOCK) &&\n\t    sp->device_type == XFRAME_II_DEVICE &&\n\t    mode != PCI_MODE_PCI_33) {\n\t\tDBG_PRINT(ERR_DBG, \"P_PLL is not locked!\\n\");\n\t\treturn 0;\n\t}\n\tif (!((val64 & ADAPTER_STATUS_RC_PRC_QUIESCENT) ==\n\t      ADAPTER_STATUS_RC_PRC_QUIESCENT)) {\n\t\tDBG_PRINT(ERR_DBG, \"RC_PRC is not QUIESCENT!\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \n\nstatic void fix_mac_address(struct s2io_nic *sp)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tint i = 0;\n\n\twhile (fix_mac[i] != END_SIGN) {\n\t\twriteq(fix_mac[i++], &bar0->gpio_control);\n\t\tudelay(10);\n\t\t(void) readq(&bar0->gpio_control);\n\t}\n}\n\n \n\nstatic int start_nic(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tstruct net_device *dev = nic->dev;\n\tregister u64 val64 = 0;\n\tu16 subid, i;\n\tstruct config_param *config = &nic->config;\n\tstruct mac_info *mac_control = &nic->mac_control;\n\n\t \n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\twriteq((u64)ring->rx_blocks[0].block_dma_addr,\n\t\t       &bar0->prc_rxd0_n[i]);\n\n\t\tval64 = readq(&bar0->prc_ctrl_n[i]);\n\t\tif (nic->rxd_mode == RXD_MODE_1)\n\t\t\tval64 |= PRC_CTRL_RC_ENABLED;\n\t\telse\n\t\t\tval64 |= PRC_CTRL_RC_ENABLED | PRC_CTRL_RING_MODE_3;\n\t\tif (nic->device_type == XFRAME_II_DEVICE)\n\t\t\tval64 |= PRC_CTRL_GROUP_READS;\n\t\tval64 &= ~PRC_CTRL_RXD_BACKOFF_INTERVAL(0xFFFFFF);\n\t\tval64 |= PRC_CTRL_RXD_BACKOFF_INTERVAL(0x1000);\n\t\twriteq(val64, &bar0->prc_ctrl_n[i]);\n\t}\n\n\tif (nic->rxd_mode == RXD_MODE_3B) {\n\t\t \n\t\tval64 = readq(&bar0->rx_pa_cfg);\n\t\tval64 |= RX_PA_CFG_IGNORE_L2_ERR;\n\t\twriteq(val64, &bar0->rx_pa_cfg);\n\t}\n\n\tif (vlan_tag_strip == 0) {\n\t\tval64 = readq(&bar0->rx_pa_cfg);\n\t\tval64 &= ~RX_PA_CFG_STRIP_VLAN_TAG;\n\t\twriteq(val64, &bar0->rx_pa_cfg);\n\t\tnic->vlan_strip_flag = 0;\n\t}\n\n\t \n\tval64 = readq(&bar0->mc_rldram_mrs);\n\tval64 |= MC_RLDRAM_QUEUE_SIZE_ENABLE | MC_RLDRAM_MRS_ENABLE;\n\tSPECIAL_REG_WRITE(val64, &bar0->mc_rldram_mrs, UF);\n\tval64 = readq(&bar0->mc_rldram_mrs);\n\n\tmsleep(100);\t \n\n\t \n\tval64 = readq(&bar0->adapter_control);\n\tval64 &= ~ADAPTER_ECC_EN;\n\twriteq(val64, &bar0->adapter_control);\n\n\t \n\tval64 = readq(&bar0->adapter_status);\n\tif (!verify_xena_quiescence(nic)) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: device is not ready, \"\n\t\t\t  \"Adapter status reads: 0x%llx\\n\",\n\t\t\t  dev->name, (unsigned long long)val64);\n\t\treturn FAILURE;\n\t}\n\n\t \n\n\t \n\tval64 = readq(&bar0->adapter_control);\n\tval64 |= ADAPTER_EOI_TX_ON;\n\twriteq(val64, &bar0->adapter_control);\n\n\tif (s2io_link_fault_indication(nic) == MAC_RMAC_ERR_TIMER) {\n\t\t \n\t\tschedule_work(&nic->set_link_task);\n\t}\n\t \n\tsubid = nic->pdev->subsystem_device;\n\tif (((subid & 0xFF) >= 0x07) &&\n\t    (nic->device_type == XFRAME_I_DEVICE)) {\n\t\tval64 = readq(&bar0->gpio_control);\n\t\tval64 |= 0x0000800000000000ULL;\n\t\twriteq(val64, &bar0->gpio_control);\n\t\tval64 = 0x0411040400000000ULL;\n\t\twriteq(val64, (void __iomem *)bar0 + 0x2700);\n\t}\n\n\treturn SUCCESS;\n}\n \nstatic struct sk_buff *s2io_txdl_getskb(struct fifo_info *fifo_data,\n\t\t\t\t\tstruct TxD *txdlp, int get_off)\n{\n\tstruct s2io_nic *nic = fifo_data->nic;\n\tstruct sk_buff *skb;\n\tstruct TxD *txds;\n\tu16 j, frg_cnt;\n\n\ttxds = txdlp;\n\tif (txds->Host_Control == (u64)(long)fifo_data->ufo_in_band_v) {\n\t\tdma_unmap_single(&nic->pdev->dev,\n\t\t\t\t (dma_addr_t)txds->Buffer_Pointer,\n\t\t\t\t sizeof(u64), DMA_TO_DEVICE);\n\t\ttxds++;\n\t}\n\n\tskb = (struct sk_buff *)((unsigned long)txds->Host_Control);\n\tif (!skb) {\n\t\tmemset(txdlp, 0, (sizeof(struct TxD) * fifo_data->max_txds));\n\t\treturn NULL;\n\t}\n\tdma_unmap_single(&nic->pdev->dev, (dma_addr_t)txds->Buffer_Pointer,\n\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\tfrg_cnt = skb_shinfo(skb)->nr_frags;\n\tif (frg_cnt) {\n\t\ttxds++;\n\t\tfor (j = 0; j < frg_cnt; j++, txds++) {\n\t\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[j];\n\t\t\tif (!txds->Buffer_Pointer)\n\t\t\t\tbreak;\n\t\t\tdma_unmap_page(&nic->pdev->dev,\n\t\t\t\t       (dma_addr_t)txds->Buffer_Pointer,\n\t\t\t\t       skb_frag_size(frag), DMA_TO_DEVICE);\n\t\t}\n\t}\n\tmemset(txdlp, 0, (sizeof(struct TxD) * fifo_data->max_txds));\n\treturn skb;\n}\n\n \n\nstatic void free_tx_buffers(struct s2io_nic *nic)\n{\n\tstruct net_device *dev = nic->dev;\n\tstruct sk_buff *skb;\n\tstruct TxD *txdp;\n\tint i, j;\n\tint cnt = 0;\n\tstruct config_param *config = &nic->config;\n\tstruct mac_info *mac_control = &nic->mac_control;\n\tstruct stat_block *stats = mac_control->stats_info;\n\tstruct swStat *swstats = &stats->sw_stat;\n\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&fifo->tx_lock, flags);\n\t\tfor (j = 0; j < tx_cfg->fifo_len; j++) {\n\t\t\ttxdp = fifo->list_info[j].list_virt_addr;\n\t\t\tskb = s2io_txdl_getskb(&mac_control->fifos[i], txdp, j);\n\t\t\tif (skb) {\n\t\t\t\tswstats->mem_freed += skb->truesize;\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tDBG_PRINT(INTR_DBG,\n\t\t\t  \"%s: forcibly freeing %d skbs on FIFO%d\\n\",\n\t\t\t  dev->name, cnt, i);\n\t\tfifo->tx_curr_get_info.offset = 0;\n\t\tfifo->tx_curr_put_info.offset = 0;\n\t\tspin_unlock_irqrestore(&fifo->tx_lock, flags);\n\t}\n}\n\n \n\nstatic void stop_nic(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 val64 = 0;\n\tu16 interruptible;\n\n\t \n\ten_dis_err_alarms(nic, ENA_ALL_INTRS, DISABLE_INTRS);\n\tinterruptible = TX_TRAFFIC_INTR | RX_TRAFFIC_INTR;\n\tinterruptible |= TX_PIC_INTR;\n\ten_dis_able_nic_intrs(nic, interruptible, DISABLE_INTRS);\n\n\t \n\tval64 = readq(&bar0->adapter_control);\n\tval64 &= ~(ADAPTER_CNTL_EN);\n\twriteq(val64, &bar0->adapter_control);\n}\n\n \nstatic int fill_rx_buffers(struct s2io_nic *nic, struct ring_info *ring,\n\t\t\t   int from_card_up)\n{\n\tstruct sk_buff *skb;\n\tstruct RxD_t *rxdp;\n\tint off, size, block_no, block_no1;\n\tu32 alloc_tab = 0;\n\tu32 alloc_cnt;\n\tu64 tmp;\n\tstruct buffAdd *ba;\n\tstruct RxD_t *first_rxdp = NULL;\n\tu64 Buffer0_ptr = 0, Buffer1_ptr = 0;\n\tstruct RxD1 *rxdp1;\n\tstruct RxD3 *rxdp3;\n\tstruct swStat *swstats = &ring->nic->mac_control.stats_info->sw_stat;\n\n\talloc_cnt = ring->pkt_cnt - ring->rx_bufs_left;\n\n\tblock_no1 = ring->rx_curr_get_info.block_index;\n\twhile (alloc_tab < alloc_cnt) {\n\t\tblock_no = ring->rx_curr_put_info.block_index;\n\n\t\toff = ring->rx_curr_put_info.offset;\n\n\t\trxdp = ring->rx_blocks[block_no].rxds[off].virt_addr;\n\n\t\tif ((block_no == block_no1) &&\n\t\t    (off == ring->rx_curr_get_info.offset) &&\n\t\t    (rxdp->Host_Control)) {\n\t\t\tDBG_PRINT(INTR_DBG, \"%s: Get and Put info equated\\n\",\n\t\t\t\t  ring->dev->name);\n\t\t\tgoto end;\n\t\t}\n\t\tif (off && (off == ring->rxd_count)) {\n\t\t\tring->rx_curr_put_info.block_index++;\n\t\t\tif (ring->rx_curr_put_info.block_index ==\n\t\t\t    ring->block_count)\n\t\t\t\tring->rx_curr_put_info.block_index = 0;\n\t\t\tblock_no = ring->rx_curr_put_info.block_index;\n\t\t\toff = 0;\n\t\t\tring->rx_curr_put_info.offset = off;\n\t\t\trxdp = ring->rx_blocks[block_no].block_virt_addr;\n\t\t\tDBG_PRINT(INTR_DBG, \"%s: Next block at: %p\\n\",\n\t\t\t\t  ring->dev->name, rxdp);\n\n\t\t}\n\n\t\tif ((rxdp->Control_1 & RXD_OWN_XENA) &&\n\t\t    ((ring->rxd_mode == RXD_MODE_3B) &&\n\t\t     (rxdp->Control_2 & s2BIT(0)))) {\n\t\t\tring->rx_curr_put_info.offset = off;\n\t\t\tgoto end;\n\t\t}\n\t\t \n\t\tsize = ring->mtu +\n\t\t\tHEADER_ETHERNET_II_802_3_SIZE +\n\t\t\tHEADER_802_2_SIZE + HEADER_SNAP_SIZE;\n\t\tif (ring->rxd_mode == RXD_MODE_1)\n\t\t\tsize += NET_IP_ALIGN;\n\t\telse\n\t\t\tsize = ring->mtu + ALIGN_SIZE + BUF0_LEN + 4;\n\n\t\t \n\t\tskb = netdev_alloc_skb(nic->dev, size);\n\t\tif (!skb) {\n\t\t\tDBG_PRINT(INFO_DBG, \"%s: Could not allocate skb\\n\",\n\t\t\t\t  ring->dev->name);\n\t\t\tif (first_rxdp) {\n\t\t\t\tdma_wmb();\n\t\t\t\tfirst_rxdp->Control_1 |= RXD_OWN_XENA;\n\t\t\t}\n\t\t\tswstats->mem_alloc_fail_cnt++;\n\n\t\t\treturn -ENOMEM ;\n\t\t}\n\t\tswstats->mem_allocated += skb->truesize;\n\n\t\tif (ring->rxd_mode == RXD_MODE_1) {\n\t\t\t \n\t\t\trxdp1 = (struct RxD1 *)rxdp;\n\t\t\tmemset(rxdp, 0, sizeof(struct RxD1));\n\t\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\t\trxdp1->Buffer0_ptr =\n\t\t\t\tdma_map_single(&ring->pdev->dev, skb->data,\n\t\t\t\t\t       size - NET_IP_ALIGN,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&nic->pdev->dev, rxdp1->Buffer0_ptr))\n\t\t\t\tgoto pci_map_failed;\n\n\t\t\trxdp->Control_2 =\n\t\t\t\tSET_BUFFER0_SIZE_1(size - NET_IP_ALIGN);\n\t\t\trxdp->Host_Control = (unsigned long)skb;\n\t\t} else if (ring->rxd_mode == RXD_MODE_3B) {\n\t\t\t \n\n\t\t\trxdp3 = (struct RxD3 *)rxdp;\n\t\t\t \n\t\t\tBuffer0_ptr = rxdp3->Buffer0_ptr;\n\t\t\tBuffer1_ptr = rxdp3->Buffer1_ptr;\n\t\t\tmemset(rxdp, 0, sizeof(struct RxD3));\n\t\t\t \n\t\t\trxdp3->Buffer0_ptr = Buffer0_ptr;\n\t\t\trxdp3->Buffer1_ptr = Buffer1_ptr;\n\n\t\t\tba = &ring->ba[block_no][off];\n\t\t\tskb_reserve(skb, BUF0_LEN);\n\t\t\ttmp = (u64)(unsigned long)skb->data;\n\t\t\ttmp += ALIGN_SIZE;\n\t\t\ttmp &= ~ALIGN_SIZE;\n\t\t\tskb->data = (void *) (unsigned long)tmp;\n\t\t\tskb_reset_tail_pointer(skb);\n\n\t\t\tif (from_card_up) {\n\t\t\t\trxdp3->Buffer0_ptr =\n\t\t\t\t\tdma_map_single(&ring->pdev->dev,\n\t\t\t\t\t\t       ba->ba_0, BUF0_LEN,\n\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&nic->pdev->dev, rxdp3->Buffer0_ptr))\n\t\t\t\t\tgoto pci_map_failed;\n\t\t\t} else\n\t\t\t\tdma_sync_single_for_device(&ring->pdev->dev,\n\t\t\t\t\t\t\t   (dma_addr_t)rxdp3->Buffer0_ptr,\n\t\t\t\t\t\t\t   BUF0_LEN,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t\trxdp->Control_2 = SET_BUFFER0_SIZE_3(BUF0_LEN);\n\t\t\tif (ring->rxd_mode == RXD_MODE_3B) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\trxdp3->Buffer2_ptr = dma_map_single(&ring->pdev->dev,\n\t\t\t\t\t\t\t\t    skb->data,\n\t\t\t\t\t\t\t\t    ring->mtu + 4,\n\t\t\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\n\t\t\t\tif (dma_mapping_error(&nic->pdev->dev, rxdp3->Buffer2_ptr))\n\t\t\t\t\tgoto pci_map_failed;\n\n\t\t\t\tif (from_card_up) {\n\t\t\t\t\trxdp3->Buffer1_ptr =\n\t\t\t\t\t\tdma_map_single(&ring->pdev->dev,\n\t\t\t\t\t\t\t       ba->ba_1,\n\t\t\t\t\t\t\t       BUF1_LEN,\n\t\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\n\t\t\t\t\tif (dma_mapping_error(&nic->pdev->dev,\n\t\t\t\t\t\t\t      rxdp3->Buffer1_ptr)) {\n\t\t\t\t\t\tdma_unmap_single(&ring->pdev->dev,\n\t\t\t\t\t\t\t\t (dma_addr_t)(unsigned long)\n\t\t\t\t\t\t\t\t skb->data,\n\t\t\t\t\t\t\t\t ring->mtu + 4,\n\t\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\t\t\tgoto pci_map_failed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trxdp->Control_2 |= SET_BUFFER1_SIZE_3(1);\n\t\t\t\trxdp->Control_2 |= SET_BUFFER2_SIZE_3\n\t\t\t\t\t(ring->mtu + 4);\n\t\t\t}\n\t\t\trxdp->Control_2 |= s2BIT(0);\n\t\t\trxdp->Host_Control = (unsigned long) (skb);\n\t\t}\n\t\tif (alloc_tab & ((1 << rxsync_frequency) - 1))\n\t\t\trxdp->Control_1 |= RXD_OWN_XENA;\n\t\toff++;\n\t\tif (off == (ring->rxd_count + 1))\n\t\t\toff = 0;\n\t\tring->rx_curr_put_info.offset = off;\n\n\t\trxdp->Control_2 |= SET_RXD_MARKER;\n\t\tif (!(alloc_tab & ((1 << rxsync_frequency) - 1))) {\n\t\t\tif (first_rxdp) {\n\t\t\t\tdma_wmb();\n\t\t\t\tfirst_rxdp->Control_1 |= RXD_OWN_XENA;\n\t\t\t}\n\t\t\tfirst_rxdp = rxdp;\n\t\t}\n\t\tring->rx_bufs_left += 1;\n\t\talloc_tab++;\n\t}\n\nend:\n\t \n\tif (first_rxdp) {\n\t\tdma_wmb();\n\t\tfirst_rxdp->Control_1 |= RXD_OWN_XENA;\n\t}\n\n\treturn SUCCESS;\n\npci_map_failed:\n\tswstats->pci_map_fail_cnt++;\n\tswstats->mem_freed += skb->truesize;\n\tdev_kfree_skb_irq(skb);\n\treturn -ENOMEM;\n}\n\nstatic void free_rxd_blk(struct s2io_nic *sp, int ring_no, int blk)\n{\n\tstruct net_device *dev = sp->dev;\n\tint j;\n\tstruct sk_buff *skb;\n\tstruct RxD_t *rxdp;\n\tstruct RxD1 *rxdp1;\n\tstruct RxD3 *rxdp3;\n\tstruct mac_info *mac_control = &sp->mac_control;\n\tstruct stat_block *stats = mac_control->stats_info;\n\tstruct swStat *swstats = &stats->sw_stat;\n\n\tfor (j = 0 ; j < rxd_count[sp->rxd_mode]; j++) {\n\t\trxdp = mac_control->rings[ring_no].\n\t\t\trx_blocks[blk].rxds[j].virt_addr;\n\t\tskb = (struct sk_buff *)((unsigned long)rxdp->Host_Control);\n\t\tif (!skb)\n\t\t\tcontinue;\n\t\tif (sp->rxd_mode == RXD_MODE_1) {\n\t\t\trxdp1 = (struct RxD1 *)rxdp;\n\t\t\tdma_unmap_single(&sp->pdev->dev,\n\t\t\t\t\t (dma_addr_t)rxdp1->Buffer0_ptr,\n\t\t\t\t\t dev->mtu +\n\t\t\t\t\t HEADER_ETHERNET_II_802_3_SIZE +\n\t\t\t\t\t HEADER_802_2_SIZE + HEADER_SNAP_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tmemset(rxdp, 0, sizeof(struct RxD1));\n\t\t} else if (sp->rxd_mode == RXD_MODE_3B) {\n\t\t\trxdp3 = (struct RxD3 *)rxdp;\n\t\t\tdma_unmap_single(&sp->pdev->dev,\n\t\t\t\t\t (dma_addr_t)rxdp3->Buffer0_ptr,\n\t\t\t\t\t BUF0_LEN, DMA_FROM_DEVICE);\n\t\t\tdma_unmap_single(&sp->pdev->dev,\n\t\t\t\t\t (dma_addr_t)rxdp3->Buffer1_ptr,\n\t\t\t\t\t BUF1_LEN, DMA_FROM_DEVICE);\n\t\t\tdma_unmap_single(&sp->pdev->dev,\n\t\t\t\t\t (dma_addr_t)rxdp3->Buffer2_ptr,\n\t\t\t\t\t dev->mtu + 4, DMA_FROM_DEVICE);\n\t\t\tmemset(rxdp, 0, sizeof(struct RxD3));\n\t\t}\n\t\tswstats->mem_freed += skb->truesize;\n\t\tdev_kfree_skb(skb);\n\t\tmac_control->rings[ring_no].rx_bufs_left -= 1;\n\t}\n}\n\n \n\nstatic void free_rx_buffers(struct s2io_nic *sp)\n{\n\tstruct net_device *dev = sp->dev;\n\tint i, blk = 0, buf_cnt = 0;\n\tstruct config_param *config = &sp->config;\n\tstruct mac_info *mac_control = &sp->mac_control;\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\tfor (blk = 0; blk < rx_ring_sz[i]; blk++)\n\t\t\tfree_rxd_blk(sp, i, blk);\n\n\t\tring->rx_curr_put_info.block_index = 0;\n\t\tring->rx_curr_get_info.block_index = 0;\n\t\tring->rx_curr_put_info.offset = 0;\n\t\tring->rx_curr_get_info.offset = 0;\n\t\tring->rx_bufs_left = 0;\n\t\tDBG_PRINT(INIT_DBG, \"%s: Freed 0x%x Rx Buffers on ring%d\\n\",\n\t\t\t  dev->name, buf_cnt, i);\n\t}\n}\n\nstatic int s2io_chk_rx_buffers(struct s2io_nic *nic, struct ring_info *ring)\n{\n\tif (fill_rx_buffers(nic, ring, 0) == -ENOMEM) {\n\t\tDBG_PRINT(INFO_DBG, \"%s: Out of memory in Rx Intr!!\\n\",\n\t\t\t  ring->dev->name);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int s2io_poll_msix(struct napi_struct *napi, int budget)\n{\n\tstruct ring_info *ring = container_of(napi, struct ring_info, napi);\n\tstruct net_device *dev = ring->dev;\n\tint pkts_processed = 0;\n\tu8 __iomem *addr = NULL;\n\tu8 val8 = 0;\n\tstruct s2io_nic *nic = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tint budget_org = budget;\n\n\tif (unlikely(!is_s2io_card_up(nic)))\n\t\treturn 0;\n\n\tpkts_processed = rx_intr_handler(ring, budget);\n\ts2io_chk_rx_buffers(nic, ring);\n\n\tif (pkts_processed < budget_org) {\n\t\tnapi_complete_done(napi, pkts_processed);\n\t\t \n\t\taddr = (u8 __iomem *)&bar0->xmsi_mask_reg;\n\t\taddr += 7 - ring->ring_no;\n\t\tval8 = (ring->ring_no == 0) ? 0x3f : 0xbf;\n\t\twriteb(val8, addr);\n\t\tval8 = readb(addr);\n\t}\n\treturn pkts_processed;\n}\n\nstatic int s2io_poll_inta(struct napi_struct *napi, int budget)\n{\n\tstruct s2io_nic *nic = container_of(napi, struct s2io_nic, napi);\n\tint pkts_processed = 0;\n\tint ring_pkts_processed, i;\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tint budget_org = budget;\n\tstruct config_param *config = &nic->config;\n\tstruct mac_info *mac_control = &nic->mac_control;\n\n\tif (unlikely(!is_s2io_card_up(nic)))\n\t\treturn 0;\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\t\tring_pkts_processed = rx_intr_handler(ring, budget);\n\t\ts2io_chk_rx_buffers(nic, ring);\n\t\tpkts_processed += ring_pkts_processed;\n\t\tbudget -= ring_pkts_processed;\n\t\tif (budget <= 0)\n\t\t\tbreak;\n\t}\n\tif (pkts_processed < budget_org) {\n\t\tnapi_complete_done(napi, pkts_processed);\n\t\t \n\t\twriteq(0, &bar0->rx_traffic_mask);\n\t\treadl(&bar0->rx_traffic_mask);\n\t}\n\treturn pkts_processed;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void s2io_netpoll(struct net_device *dev)\n{\n\tstruct s2io_nic *nic = netdev_priv(dev);\n\tconst int irq = nic->pdev->irq;\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tu64 val64 = 0xFFFFFFFFFFFFFFFFULL;\n\tint i;\n\tstruct config_param *config = &nic->config;\n\tstruct mac_info *mac_control = &nic->mac_control;\n\n\tif (pci_channel_offline(nic->pdev))\n\t\treturn;\n\n\tdisable_irq(irq);\n\n\twriteq(val64, &bar0->rx_traffic_int);\n\twriteq(val64, &bar0->tx_traffic_int);\n\n\t \n\tfor (i = 0; i < config->tx_fifo_num; i++)\n\t\ttx_intr_handler(&mac_control->fifos[i]);\n\n\t \n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\trx_intr_handler(ring, 0);\n\t}\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\tif (fill_rx_buffers(nic, ring, 0) == -ENOMEM) {\n\t\t\tDBG_PRINT(INFO_DBG,\n\t\t\t\t  \"%s: Out of memory in Rx Netpoll!!\\n\",\n\t\t\t\t  dev->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tenable_irq(irq);\n}\n#endif\n\n \nstatic int rx_intr_handler(struct ring_info *ring_data, int budget)\n{\n\tint get_block, put_block;\n\tstruct rx_curr_get_info get_info, put_info;\n\tstruct RxD_t *rxdp;\n\tstruct sk_buff *skb;\n\tint pkt_cnt = 0, napi_pkts = 0;\n\tint i;\n\tstruct RxD1 *rxdp1;\n\tstruct RxD3 *rxdp3;\n\n\tif (budget <= 0)\n\t\treturn napi_pkts;\n\n\tget_info = ring_data->rx_curr_get_info;\n\tget_block = get_info.block_index;\n\tmemcpy(&put_info, &ring_data->rx_curr_put_info, sizeof(put_info));\n\tput_block = put_info.block_index;\n\trxdp = ring_data->rx_blocks[get_block].rxds[get_info.offset].virt_addr;\n\n\twhile (RXD_IS_UP2DT(rxdp)) {\n\t\t \n\t\tif ((get_block == put_block) &&\n\t\t    (get_info.offset + 1) == put_info.offset) {\n\t\t\tDBG_PRINT(INTR_DBG, \"%s: Ring Full\\n\",\n\t\t\t\t  ring_data->dev->name);\n\t\t\tbreak;\n\t\t}\n\t\tskb = (struct sk_buff *)((unsigned long)rxdp->Host_Control);\n\t\tif (skb == NULL) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: NULL skb in Rx Intr\\n\",\n\t\t\t\t  ring_data->dev->name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ring_data->rxd_mode == RXD_MODE_1) {\n\t\t\trxdp1 = (struct RxD1 *)rxdp;\n\t\t\tdma_unmap_single(&ring_data->pdev->dev,\n\t\t\t\t\t (dma_addr_t)rxdp1->Buffer0_ptr,\n\t\t\t\t\t ring_data->mtu +\n\t\t\t\t\t HEADER_ETHERNET_II_802_3_SIZE +\n\t\t\t\t\t HEADER_802_2_SIZE +\n\t\t\t\t\t HEADER_SNAP_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t} else if (ring_data->rxd_mode == RXD_MODE_3B) {\n\t\t\trxdp3 = (struct RxD3 *)rxdp;\n\t\t\tdma_sync_single_for_cpu(&ring_data->pdev->dev,\n\t\t\t\t\t\t(dma_addr_t)rxdp3->Buffer0_ptr,\n\t\t\t\t\t\tBUF0_LEN, DMA_FROM_DEVICE);\n\t\t\tdma_unmap_single(&ring_data->pdev->dev,\n\t\t\t\t\t (dma_addr_t)rxdp3->Buffer2_ptr,\n\t\t\t\t\t ring_data->mtu + 4, DMA_FROM_DEVICE);\n\t\t}\n\t\tprefetch(skb->data);\n\t\trx_osm_handler(ring_data, rxdp);\n\t\tget_info.offset++;\n\t\tring_data->rx_curr_get_info.offset = get_info.offset;\n\t\trxdp = ring_data->rx_blocks[get_block].\n\t\t\trxds[get_info.offset].virt_addr;\n\t\tif (get_info.offset == rxd_count[ring_data->rxd_mode]) {\n\t\t\tget_info.offset = 0;\n\t\t\tring_data->rx_curr_get_info.offset = get_info.offset;\n\t\t\tget_block++;\n\t\t\tif (get_block == ring_data->block_count)\n\t\t\t\tget_block = 0;\n\t\t\tring_data->rx_curr_get_info.block_index = get_block;\n\t\t\trxdp = ring_data->rx_blocks[get_block].block_virt_addr;\n\t\t}\n\n\t\tif (ring_data->nic->config.napi) {\n\t\t\tbudget--;\n\t\t\tnapi_pkts++;\n\t\t\tif (!budget)\n\t\t\t\tbreak;\n\t\t}\n\t\tpkt_cnt++;\n\t\tif ((indicate_max_pkts) && (pkt_cnt > indicate_max_pkts))\n\t\t\tbreak;\n\t}\n\tif (ring_data->lro) {\n\t\t \n\t\tfor (i = 0; i < MAX_LRO_SESSIONS; i++) {\n\t\t\tstruct lro *lro = &ring_data->lro0_n[i];\n\t\t\tif (lro->in_use) {\n\t\t\t\tupdate_L3L4_header(ring_data->nic, lro);\n\t\t\t\tqueue_rx_frame(lro->parent, lro->vlan_tag);\n\t\t\t\tclear_lro_session(lro);\n\t\t\t}\n\t\t}\n\t}\n\treturn napi_pkts;\n}\n\n \n\nstatic void tx_intr_handler(struct fifo_info *fifo_data)\n{\n\tstruct s2io_nic *nic = fifo_data->nic;\n\tstruct tx_curr_get_info get_info, put_info;\n\tstruct sk_buff *skb = NULL;\n\tstruct TxD *txdlp;\n\tint pkt_cnt = 0;\n\tunsigned long flags = 0;\n\tu8 err_mask;\n\tstruct stat_block *stats = nic->mac_control.stats_info;\n\tstruct swStat *swstats = &stats->sw_stat;\n\n\tif (!spin_trylock_irqsave(&fifo_data->tx_lock, flags))\n\t\treturn;\n\n\tget_info = fifo_data->tx_curr_get_info;\n\tmemcpy(&put_info, &fifo_data->tx_curr_put_info, sizeof(put_info));\n\ttxdlp = fifo_data->list_info[get_info.offset].list_virt_addr;\n\twhile ((!(txdlp->Control_1 & TXD_LIST_OWN_XENA)) &&\n\t       (get_info.offset != put_info.offset) &&\n\t       (txdlp->Host_Control)) {\n\t\t \n\t\tif (txdlp->Control_1 & TXD_T_CODE) {\n\t\t\tunsigned long long err;\n\t\t\terr = txdlp->Control_1 & TXD_T_CODE;\n\t\t\tif (err & 0x1) {\n\t\t\t\tswstats->parity_err_cnt++;\n\t\t\t}\n\n\t\t\t \n\t\t\terr_mask = err >> 48;\n\t\t\tswitch (err_mask) {\n\t\t\tcase 2:\n\t\t\t\tswstats->tx_buf_abort_cnt++;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tswstats->tx_desc_abort_cnt++;\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tswstats->tx_parity_err_cnt++;\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tswstats->tx_link_loss_cnt++;\n\t\t\t\tbreak;\n\n\t\t\tcase 15:\n\t\t\t\tswstats->tx_list_proc_err_cnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tskb = s2io_txdl_getskb(fifo_data, txdlp, get_info.offset);\n\t\tif (skb == NULL) {\n\t\t\tspin_unlock_irqrestore(&fifo_data->tx_lock, flags);\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: NULL skb in Tx Free Intr\\n\",\n\t\t\t\t  __func__);\n\t\t\treturn;\n\t\t}\n\t\tpkt_cnt++;\n\n\t\t \n\t\tswstats->mem_freed += skb->truesize;\n\t\tdev_consume_skb_irq(skb);\n\n\t\tget_info.offset++;\n\t\tif (get_info.offset == get_info.fifo_len + 1)\n\t\t\tget_info.offset = 0;\n\t\ttxdlp = fifo_data->list_info[get_info.offset].list_virt_addr;\n\t\tfifo_data->tx_curr_get_info.offset = get_info.offset;\n\t}\n\n\ts2io_wake_tx_queue(fifo_data, pkt_cnt, nic->config.multiq);\n\n\tspin_unlock_irqrestore(&fifo_data->tx_lock, flags);\n}\n\n \nstatic void s2io_mdio_write(u32 mmd_type, u64 addr, u16 value,\n\t\t\t    struct net_device *dev)\n{\n\tu64 val64;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\t \n\tval64 = MDIO_MMD_INDX_ADDR(addr) |\n\t\tMDIO_MMD_DEV_ADDR(mmd_type) |\n\t\tMDIO_MMS_PRT_ADDR(0x0);\n\twriteq(val64, &bar0->mdio_control);\n\tval64 = val64 | MDIO_CTRL_START_TRANS(0xE);\n\twriteq(val64, &bar0->mdio_control);\n\tudelay(100);\n\n\t \n\tval64 = MDIO_MMD_INDX_ADDR(addr) |\n\t\tMDIO_MMD_DEV_ADDR(mmd_type) |\n\t\tMDIO_MMS_PRT_ADDR(0x0) |\n\t\tMDIO_MDIO_DATA(value) |\n\t\tMDIO_OP(MDIO_OP_WRITE_TRANS);\n\twriteq(val64, &bar0->mdio_control);\n\tval64 = val64 | MDIO_CTRL_START_TRANS(0xE);\n\twriteq(val64, &bar0->mdio_control);\n\tudelay(100);\n\n\tval64 = MDIO_MMD_INDX_ADDR(addr) |\n\t\tMDIO_MMD_DEV_ADDR(mmd_type) |\n\t\tMDIO_MMS_PRT_ADDR(0x0) |\n\t\tMDIO_OP(MDIO_OP_READ_TRANS);\n\twriteq(val64, &bar0->mdio_control);\n\tval64 = val64 | MDIO_CTRL_START_TRANS(0xE);\n\twriteq(val64, &bar0->mdio_control);\n\tudelay(100);\n}\n\n \nstatic u64 s2io_mdio_read(u32 mmd_type, u64 addr, struct net_device *dev)\n{\n\tu64 val64 = 0x0;\n\tu64 rval64 = 0x0;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\t \n\tval64 = val64 | (MDIO_MMD_INDX_ADDR(addr)\n\t\t\t | MDIO_MMD_DEV_ADDR(mmd_type)\n\t\t\t | MDIO_MMS_PRT_ADDR(0x0));\n\twriteq(val64, &bar0->mdio_control);\n\tval64 = val64 | MDIO_CTRL_START_TRANS(0xE);\n\twriteq(val64, &bar0->mdio_control);\n\tudelay(100);\n\n\t \n\tval64 = MDIO_MMD_INDX_ADDR(addr) |\n\t\tMDIO_MMD_DEV_ADDR(mmd_type) |\n\t\tMDIO_MMS_PRT_ADDR(0x0) |\n\t\tMDIO_OP(MDIO_OP_READ_TRANS);\n\twriteq(val64, &bar0->mdio_control);\n\tval64 = val64 | MDIO_CTRL_START_TRANS(0xE);\n\twriteq(val64, &bar0->mdio_control);\n\tudelay(100);\n\n\t \n\trval64 = readq(&bar0->mdio_control);\n\trval64 = rval64 & 0xFFFF0000;\n\trval64 = rval64 >> 16;\n\treturn rval64;\n}\n\n \n\nstatic void s2io_chk_xpak_counter(u64 *counter, u64 * regs_stat, u32 index,\n\t\t\t\t  u16 flag, u16 type)\n{\n\tu64 mask = 0x3;\n\tu64 val64;\n\tint i;\n\tfor (i = 0; i < index; i++)\n\t\tmask = mask << 0x2;\n\n\tif (flag > 0) {\n\t\t*counter = *counter + 1;\n\t\tval64 = *regs_stat & mask;\n\t\tval64 = val64 >> (index * 0x2);\n\t\tval64 = val64 + 1;\n\t\tif (val64 == 3) {\n\t\t\tswitch (type) {\n\t\t\tcase 1:\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t  \"Take Xframe NIC out of service.\\n\");\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\"Excessive temperatures may result in premature transceiver failure.\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t  \"Take Xframe NIC out of service.\\n\");\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\"Excessive bias currents may indicate imminent laser diode failure.\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t  \"Take Xframe NIC out of service.\\n\");\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\"Excessive laser output power may saturate far-end receiver.\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t  \"Incorrect XPAK Alarm type\\n\");\n\t\t\t}\n\t\t\tval64 = 0x0;\n\t\t}\n\t\tval64 = val64 << (index * 0x2);\n\t\t*regs_stat = (*regs_stat & (~mask)) | (val64);\n\n\t} else {\n\t\t*regs_stat = *regs_stat & (~mask);\n\t}\n}\n\n \nstatic void s2io_updt_xpak_counter(struct net_device *dev)\n{\n\tu16 flag  = 0x0;\n\tu16 type  = 0x0;\n\tu16 val16 = 0x0;\n\tu64 val64 = 0x0;\n\tu64 addr  = 0x0;\n\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct stat_block *stats = sp->mac_control.stats_info;\n\tstruct xpakStat *xstats = &stats->xpak_stat;\n\n\t \n\taddr = MDIO_CTRL1;\n\tval64 = 0x0;\n\tval64 = s2io_mdio_read(MDIO_MMD_PMAPMD, addr, dev);\n\tif ((val64 == 0xFFFF) || (val64 == 0x0000)) {\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"ERR: MDIO slave access failed - Returned %llx\\n\",\n\t\t\t  (unsigned long long)val64);\n\t\treturn;\n\t}\n\n\t \n\tif (val64 != MDIO_CTRL1_SPEED10G) {\n\t\tDBG_PRINT(ERR_DBG, \"Incorrect value at PMA address 0x0000 - \"\n\t\t\t  \"Returned: %llx- Expected: 0x%x\\n\",\n\t\t\t  (unsigned long long)val64, MDIO_CTRL1_SPEED10G);\n\t\treturn;\n\t}\n\n\t \n\taddr = 0xA100;\n\ts2io_mdio_write(MDIO_MMD_PMAPMD, addr, val16, dev);\n\tval64 = s2io_mdio_read(MDIO_MMD_PMAPMD, addr, dev);\n\n\t \n\taddr = 0xA070;\n\tval64 = 0x0;\n\tval64 = s2io_mdio_read(MDIO_MMD_PMAPMD, addr, dev);\n\n\tflag = CHECKBIT(val64, 0x7);\n\ttype = 1;\n\ts2io_chk_xpak_counter(&xstats->alarm_transceiver_temp_high,\n\t\t\t      &xstats->xpak_regs_stat,\n\t\t\t      0x0, flag, type);\n\n\tif (CHECKBIT(val64, 0x6))\n\t\txstats->alarm_transceiver_temp_low++;\n\n\tflag = CHECKBIT(val64, 0x3);\n\ttype = 2;\n\ts2io_chk_xpak_counter(&xstats->alarm_laser_bias_current_high,\n\t\t\t      &xstats->xpak_regs_stat,\n\t\t\t      0x2, flag, type);\n\n\tif (CHECKBIT(val64, 0x2))\n\t\txstats->alarm_laser_bias_current_low++;\n\n\tflag = CHECKBIT(val64, 0x1);\n\ttype = 3;\n\ts2io_chk_xpak_counter(&xstats->alarm_laser_output_power_high,\n\t\t\t      &xstats->xpak_regs_stat,\n\t\t\t      0x4, flag, type);\n\n\tif (CHECKBIT(val64, 0x0))\n\t\txstats->alarm_laser_output_power_low++;\n\n\t \n\taddr = 0xA074;\n\tval64 = 0x0;\n\tval64 = s2io_mdio_read(MDIO_MMD_PMAPMD, addr, dev);\n\n\tif (CHECKBIT(val64, 0x7))\n\t\txstats->warn_transceiver_temp_high++;\n\n\tif (CHECKBIT(val64, 0x6))\n\t\txstats->warn_transceiver_temp_low++;\n\n\tif (CHECKBIT(val64, 0x3))\n\t\txstats->warn_laser_bias_current_high++;\n\n\tif (CHECKBIT(val64, 0x2))\n\t\txstats->warn_laser_bias_current_low++;\n\n\tif (CHECKBIT(val64, 0x1))\n\t\txstats->warn_laser_output_power_high++;\n\n\tif (CHECKBIT(val64, 0x0))\n\t\txstats->warn_laser_output_power_low++;\n}\n\n \n\nstatic int wait_for_cmd_complete(void __iomem *addr, u64 busy_bit,\n\t\t\t\t int bit_state, bool may_sleep)\n{\n\tint ret = FAILURE, cnt = 0, delay = 1;\n\tu64 val64;\n\n\tif ((bit_state != S2IO_BIT_RESET) && (bit_state != S2IO_BIT_SET))\n\t\treturn FAILURE;\n\n\tdo {\n\t\tval64 = readq(addr);\n\t\tif (bit_state == S2IO_BIT_RESET) {\n\t\t\tif (!(val64 & busy_bit)) {\n\t\t\t\tret = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (val64 & busy_bit) {\n\t\t\t\tret = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!may_sleep)\n\t\t\tmdelay(delay);\n\t\telse\n\t\t\tmsleep(delay);\n\n\t\tif (++cnt >= 10)\n\t\t\tdelay = 50;\n\t} while (cnt < 20);\n\treturn ret;\n}\n \nstatic u16 check_pci_device_id(u16 id)\n{\n\tswitch (id) {\n\tcase PCI_DEVICE_ID_HERC_WIN:\n\tcase PCI_DEVICE_ID_HERC_UNI:\n\t\treturn XFRAME_II_DEVICE;\n\tcase PCI_DEVICE_ID_S2IO_UNI:\n\tcase PCI_DEVICE_ID_S2IO_WIN:\n\t\treturn XFRAME_I_DEVICE;\n\tdefault:\n\t\treturn PCI_ANY_ID;\n\t}\n}\n\n \n\nstatic void s2io_reset(struct s2io_nic *sp)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64;\n\tu16 subid, pci_cmd;\n\tint i;\n\tu16 val16;\n\tunsigned long long up_cnt, down_cnt, up_time, down_time, reset_cnt;\n\tunsigned long long mem_alloc_cnt, mem_free_cnt, watchdog_cnt;\n\tstruct stat_block *stats;\n\tstruct swStat *swstats;\n\n\tDBG_PRINT(INIT_DBG, \"%s: Resetting XFrame card %s\\n\",\n\t\t  __func__, pci_name(sp->pdev));\n\n\t \n\tpci_read_config_word(sp->pdev, PCIX_COMMAND_REGISTER, &(pci_cmd));\n\n\tval64 = SW_RESET_ALL;\n\twriteq(val64, &bar0->sw_reset);\n\tif (strstr(sp->product_name, \"CX4\"))\n\t\tmsleep(750);\n\tmsleep(250);\n\tfor (i = 0; i < S2IO_MAX_PCI_CONFIG_SPACE_REINIT; i++) {\n\n\t\t \n\t\tpci_restore_state(sp->pdev);\n\t\tpci_save_state(sp->pdev);\n\t\tpci_read_config_word(sp->pdev, 0x2, &val16);\n\t\tif (check_pci_device_id(val16) != (u16)PCI_ANY_ID)\n\t\t\tbreak;\n\t\tmsleep(200);\n\t}\n\n\tif (check_pci_device_id(val16) == (u16)PCI_ANY_ID)\n\t\tDBG_PRINT(ERR_DBG, \"%s SW_Reset failed!\\n\", __func__);\n\n\tpci_write_config_word(sp->pdev, PCIX_COMMAND_REGISTER, pci_cmd);\n\n\ts2io_init_pci(sp);\n\n\t \n\ts2io_set_swapper(sp);\n\n\t \n\tdo_s2io_restore_unicast_mc(sp);\n\n\t \n\trestore_xmsi_data(sp);\n\n\t \n\tif (sp->device_type == XFRAME_II_DEVICE) {\n\t\t \n\t\tpci_write_config_word(sp->pdev, PCI_STATUS, 0x8000);\n\n\t\t \n\t\tpci_write_config_dword(sp->pdev, 0x68, 0x7C);\n\n\t\t \n\t\twriteq(s2BIT(62), &bar0->txpic_int_reg);\n\t}\n\n\t \n\tmemset(&sp->stats, 0, sizeof(struct net_device_stats));\n\n\tstats = sp->mac_control.stats_info;\n\tswstats = &stats->sw_stat;\n\n\t \n\tup_cnt = swstats->link_up_cnt;\n\tdown_cnt = swstats->link_down_cnt;\n\tup_time = swstats->link_up_time;\n\tdown_time = swstats->link_down_time;\n\treset_cnt = swstats->soft_reset_cnt;\n\tmem_alloc_cnt = swstats->mem_allocated;\n\tmem_free_cnt = swstats->mem_freed;\n\twatchdog_cnt = swstats->watchdog_timer_cnt;\n\n\tmemset(stats, 0, sizeof(struct stat_block));\n\n\t \n\tswstats->link_up_cnt = up_cnt;\n\tswstats->link_down_cnt = down_cnt;\n\tswstats->link_up_time = up_time;\n\tswstats->link_down_time = down_time;\n\tswstats->soft_reset_cnt = reset_cnt;\n\tswstats->mem_allocated = mem_alloc_cnt;\n\tswstats->mem_freed = mem_free_cnt;\n\tswstats->watchdog_timer_cnt = watchdog_cnt;\n\n\t \n\tsubid = sp->pdev->subsystem_device;\n\tif (((subid & 0xFF) >= 0x07) &&\n\t    (sp->device_type == XFRAME_I_DEVICE)) {\n\t\tval64 = readq(&bar0->gpio_control);\n\t\tval64 |= 0x0000800000000000ULL;\n\t\twriteq(val64, &bar0->gpio_control);\n\t\tval64 = 0x0411040400000000ULL;\n\t\twriteq(val64, (void __iomem *)bar0 + 0x2700);\n\t}\n\n\t \n\tif (sp->device_type == XFRAME_II_DEVICE) {\n\t\tval64 = readq(&bar0->pcc_err_reg);\n\t\twriteq(val64, &bar0->pcc_err_reg);\n\t}\n\n\tsp->device_enabled_once = false;\n}\n\n \n\nstatic int s2io_set_swapper(struct s2io_nic *sp)\n{\n\tstruct net_device *dev = sp->dev;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64, valt, valr;\n\n\t \n\n\tval64 = readq(&bar0->pif_rd_swapper_fb);\n\tif (val64 != 0x0123456789ABCDEFULL) {\n\t\tint i = 0;\n\t\tstatic const u64 value[] = {\n\t\t\t0xC30000C3C30000C3ULL,\t \n\t\t\t0x8100008181000081ULL,\t \n\t\t\t0x4200004242000042ULL,\t \n\t\t\t0\t\t\t \n\t\t};\n\n\t\twhile (i < 4) {\n\t\t\twriteq(value[i], &bar0->swapper_ctrl);\n\t\t\tval64 = readq(&bar0->pif_rd_swapper_fb);\n\t\t\tif (val64 == 0x0123456789ABCDEFULL)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == 4) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Endian settings are wrong, \"\n\t\t\t\t  \"feedback read %llx\\n\",\n\t\t\t\t  dev->name, (unsigned long long)val64);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tvalr = value[i];\n\t} else {\n\t\tvalr = readq(&bar0->swapper_ctrl);\n\t}\n\n\tvalt = 0x0123456789ABCDEFULL;\n\twriteq(valt, &bar0->xmsi_address);\n\tval64 = readq(&bar0->xmsi_address);\n\n\tif (val64 != valt) {\n\t\tint i = 0;\n\t\tstatic const u64 value[] = {\n\t\t\t0x00C3C30000C3C300ULL,\t \n\t\t\t0x0081810000818100ULL,\t \n\t\t\t0x0042420000424200ULL,\t \n\t\t\t0\t\t\t \n\t\t};\n\n\t\twhile (i < 4) {\n\t\t\twriteq((value[i] | valr), &bar0->swapper_ctrl);\n\t\t\twriteq(valt, &bar0->xmsi_address);\n\t\t\tval64 = readq(&bar0->xmsi_address);\n\t\t\tif (val64 == valt)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == 4) {\n\t\t\tunsigned long long x = val64;\n\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t  \"Write failed, Xmsi_addr reads:0x%llx\\n\", x);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tval64 = readq(&bar0->swapper_ctrl);\n\tval64 &= 0xFFFF000000000000ULL;\n\n#ifdef __BIG_ENDIAN\n\t \n\tval64 |= (SWAPPER_CTRL_TXP_FE |\n\t\t  SWAPPER_CTRL_TXP_SE |\n\t\t  SWAPPER_CTRL_TXD_R_FE |\n\t\t  SWAPPER_CTRL_TXD_W_FE |\n\t\t  SWAPPER_CTRL_TXF_R_FE |\n\t\t  SWAPPER_CTRL_RXD_R_FE |\n\t\t  SWAPPER_CTRL_RXD_W_FE |\n\t\t  SWAPPER_CTRL_RXF_W_FE |\n\t\t  SWAPPER_CTRL_XMSI_FE |\n\t\t  SWAPPER_CTRL_STATS_FE |\n\t\t  SWAPPER_CTRL_STATS_SE);\n\tif (sp->config.intr_type == INTA)\n\t\tval64 |= SWAPPER_CTRL_XMSI_SE;\n\twriteq(val64, &bar0->swapper_ctrl);\n#else\n\t \n\tval64 |= (SWAPPER_CTRL_TXP_FE |\n\t\t  SWAPPER_CTRL_TXP_SE |\n\t\t  SWAPPER_CTRL_TXD_R_FE |\n\t\t  SWAPPER_CTRL_TXD_R_SE |\n\t\t  SWAPPER_CTRL_TXD_W_FE |\n\t\t  SWAPPER_CTRL_TXD_W_SE |\n\t\t  SWAPPER_CTRL_TXF_R_FE |\n\t\t  SWAPPER_CTRL_RXD_R_FE |\n\t\t  SWAPPER_CTRL_RXD_R_SE |\n\t\t  SWAPPER_CTRL_RXD_W_FE |\n\t\t  SWAPPER_CTRL_RXD_W_SE |\n\t\t  SWAPPER_CTRL_RXF_W_FE |\n\t\t  SWAPPER_CTRL_XMSI_FE |\n\t\t  SWAPPER_CTRL_STATS_FE |\n\t\t  SWAPPER_CTRL_STATS_SE);\n\tif (sp->config.intr_type == INTA)\n\t\tval64 |= SWAPPER_CTRL_XMSI_SE;\n\twriteq(val64, &bar0->swapper_ctrl);\n#endif\n\tval64 = readq(&bar0->swapper_ctrl);\n\n\t \n\tval64 = readq(&bar0->pif_rd_swapper_fb);\n\tif (val64 != 0x0123456789ABCDEFULL) {\n\t\t \n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"%s: Endian settings are wrong, feedback read %llx\\n\",\n\t\t\t  dev->name, (unsigned long long)val64);\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n\nstatic int wait_for_msix_trans(struct s2io_nic *nic, int i)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tu64 val64;\n\tint ret = 0, cnt = 0;\n\n\tdo {\n\t\tval64 = readq(&bar0->xmsi_access);\n\t\tif (!(val64 & s2BIT(15)))\n\t\t\tbreak;\n\t\tmdelay(1);\n\t\tcnt++;\n\t} while (cnt < 5);\n\tif (cnt == 5) {\n\t\tDBG_PRINT(ERR_DBG, \"XMSI # %d Access failed\\n\", i);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void restore_xmsi_data(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tu64 val64;\n\tint i, msix_index;\n\n\tif (nic->device_type == XFRAME_I_DEVICE)\n\t\treturn;\n\n\tfor (i = 0; i < MAX_REQUESTED_MSI_X; i++) {\n\t\tmsix_index = (i) ? ((i-1) * 8 + 1) : 0;\n\t\twriteq(nic->msix_info[i].addr, &bar0->xmsi_address);\n\t\twriteq(nic->msix_info[i].data, &bar0->xmsi_data);\n\t\tval64 = (s2BIT(7) | s2BIT(15) | vBIT(msix_index, 26, 6));\n\t\twriteq(val64, &bar0->xmsi_access);\n\t\tif (wait_for_msix_trans(nic, msix_index))\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: index: %d failed\\n\",\n\t\t\t\t  __func__, msix_index);\n\t}\n}\n\nstatic void store_xmsi_data(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tu64 val64, addr, data;\n\tint i, msix_index;\n\n\tif (nic->device_type == XFRAME_I_DEVICE)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < MAX_REQUESTED_MSI_X; i++) {\n\t\tmsix_index = (i) ? ((i-1) * 8 + 1) : 0;\n\t\tval64 = (s2BIT(15) | vBIT(msix_index, 26, 6));\n\t\twriteq(val64, &bar0->xmsi_access);\n\t\tif (wait_for_msix_trans(nic, msix_index)) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: index: %d failed\\n\",\n\t\t\t\t  __func__, msix_index);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = readq(&bar0->xmsi_address);\n\t\tdata = readq(&bar0->xmsi_data);\n\t\tif (addr && data) {\n\t\t\tnic->msix_info[i].addr = addr;\n\t\t\tnic->msix_info[i].data = data;\n\t\t}\n\t}\n}\n\nstatic int s2io_enable_msi_x(struct s2io_nic *nic)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tu64 rx_mat;\n\tu16 msi_control;  \n\tint ret, i, j, msix_indx = 1;\n\tint size;\n\tstruct stat_block *stats = nic->mac_control.stats_info;\n\tstruct swStat *swstats = &stats->sw_stat;\n\n\tsize = nic->num_entries * sizeof(struct msix_entry);\n\tnic->entries = kzalloc(size, GFP_KERNEL);\n\tif (!nic->entries) {\n\t\tDBG_PRINT(INFO_DBG, \"%s: Memory allocation failed\\n\",\n\t\t\t  __func__);\n\t\tswstats->mem_alloc_fail_cnt++;\n\t\treturn -ENOMEM;\n\t}\n\tswstats->mem_allocated += size;\n\n\tsize = nic->num_entries * sizeof(struct s2io_msix_entry);\n\tnic->s2io_entries = kzalloc(size, GFP_KERNEL);\n\tif (!nic->s2io_entries) {\n\t\tDBG_PRINT(INFO_DBG, \"%s: Memory allocation failed\\n\",\n\t\t\t  __func__);\n\t\tswstats->mem_alloc_fail_cnt++;\n\t\tkfree(nic->entries);\n\t\tswstats->mem_freed\n\t\t\t+= (nic->num_entries * sizeof(struct msix_entry));\n\t\treturn -ENOMEM;\n\t}\n\tswstats->mem_allocated += size;\n\n\tnic->entries[0].entry = 0;\n\tnic->s2io_entries[0].entry = 0;\n\tnic->s2io_entries[0].in_use = MSIX_FLG;\n\tnic->s2io_entries[0].type = MSIX_ALARM_TYPE;\n\tnic->s2io_entries[0].arg = &nic->mac_control.fifos;\n\n\tfor (i = 1; i < nic->num_entries; i++) {\n\t\tnic->entries[i].entry = ((i - 1) * 8) + 1;\n\t\tnic->s2io_entries[i].entry = ((i - 1) * 8) + 1;\n\t\tnic->s2io_entries[i].arg = NULL;\n\t\tnic->s2io_entries[i].in_use = 0;\n\t}\n\n\trx_mat = readq(&bar0->rx_mat);\n\tfor (j = 0; j < nic->config.rx_ring_num; j++) {\n\t\trx_mat |= RX_MAT_SET(j, msix_indx);\n\t\tnic->s2io_entries[j+1].arg = &nic->mac_control.rings[j];\n\t\tnic->s2io_entries[j+1].type = MSIX_RING_TYPE;\n\t\tnic->s2io_entries[j+1].in_use = MSIX_FLG;\n\t\tmsix_indx += 8;\n\t}\n\twriteq(rx_mat, &bar0->rx_mat);\n\treadq(&bar0->rx_mat);\n\n\tret = pci_enable_msix_range(nic->pdev, nic->entries,\n\t\t\t\t    nic->num_entries, nic->num_entries);\n\t \n\tif (ret < 0) {\n\t\tDBG_PRINT(ERR_DBG, \"Enabling MSI-X failed\\n\");\n\t\tkfree(nic->entries);\n\t\tswstats->mem_freed += nic->num_entries *\n\t\t\tsizeof(struct msix_entry);\n\t\tkfree(nic->s2io_entries);\n\t\tswstats->mem_freed += nic->num_entries *\n\t\t\tsizeof(struct s2io_msix_entry);\n\t\tnic->entries = NULL;\n\t\tnic->s2io_entries = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpci_read_config_word(nic->pdev, 0x42, &msi_control);\n\tmsi_control |= 0x1;  \n\tpci_write_config_word(nic->pdev, 0x42, msi_control);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t s2io_test_intr(int irq, void *dev_id)\n{\n\tstruct s2io_nic *sp = dev_id;\n\n\tsp->msi_detected = 1;\n\twake_up(&sp->msi_wait);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int s2io_test_msi(struct s2io_nic *sp)\n{\n\tstruct pci_dev *pdev = sp->pdev;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tint err;\n\tu64 val64, saved64;\n\n\terr = request_irq(sp->entries[1].vector, s2io_test_intr, 0,\n\t\t\t  sp->name, sp);\n\tif (err) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: PCI %s: cannot assign irq %d\\n\",\n\t\t\t  sp->dev->name, pci_name(pdev), pdev->irq);\n\t\treturn err;\n\t}\n\n\tinit_waitqueue_head(&sp->msi_wait);\n\tsp->msi_detected = 0;\n\n\tsaved64 = val64 = readq(&bar0->scheduled_int_ctrl);\n\tval64 |= SCHED_INT_CTRL_ONE_SHOT;\n\tval64 |= SCHED_INT_CTRL_TIMER_EN;\n\tval64 |= SCHED_INT_CTRL_INT2MSI(1);\n\twriteq(val64, &bar0->scheduled_int_ctrl);\n\n\twait_event_timeout(sp->msi_wait, sp->msi_detected, HZ/10);\n\n\tif (!sp->msi_detected) {\n\t\t \n\t\tDBG_PRINT(ERR_DBG, \"%s: PCI %s: No interrupt was generated \"\n\t\t\t  \"using MSI(X) during test\\n\",\n\t\t\t  sp->dev->name, pci_name(pdev));\n\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\tfree_irq(sp->entries[1].vector, sp);\n\n\twriteq(saved64, &bar0->scheduled_int_ctrl);\n\n\treturn err;\n}\n\nstatic void remove_msix_isr(struct s2io_nic *sp)\n{\n\tint i;\n\tu16 msi_control;\n\n\tfor (i = 0; i < sp->num_entries; i++) {\n\t\tif (sp->s2io_entries[i].in_use == MSIX_REGISTERED_SUCCESS) {\n\t\t\tint vector = sp->entries[i].vector;\n\t\t\tvoid *arg = sp->s2io_entries[i].arg;\n\t\t\tfree_irq(vector, arg);\n\t\t}\n\t}\n\n\tkfree(sp->entries);\n\tkfree(sp->s2io_entries);\n\tsp->entries = NULL;\n\tsp->s2io_entries = NULL;\n\n\tpci_read_config_word(sp->pdev, 0x42, &msi_control);\n\tmsi_control &= 0xFFFE;  \n\tpci_write_config_word(sp->pdev, 0x42, msi_control);\n\n\tpci_disable_msix(sp->pdev);\n}\n\nstatic void remove_inta_isr(struct s2io_nic *sp)\n{\n\tfree_irq(sp->pdev->irq, sp->dev);\n}\n\n \n\n \n\nstatic int s2io_open(struct net_device *dev)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct swStat *swstats = &sp->mac_control.stats_info->sw_stat;\n\tint err = 0;\n\n\t \n\tnetif_carrier_off(dev);\n\tsp->last_link_state = 0;\n\n\t \n\terr = s2io_card_up(sp);\n\tif (err) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: H/W initialization failed\\n\",\n\t\t\t  dev->name);\n\t\tgoto hw_init_failed;\n\t}\n\n\tif (do_s2io_prog_unicast(dev, dev->dev_addr) == FAILURE) {\n\t\tDBG_PRINT(ERR_DBG, \"Set Mac Address Failed\\n\");\n\t\ts2io_card_down(sp);\n\t\terr = -ENODEV;\n\t\tgoto hw_init_failed;\n\t}\n\ts2io_start_all_tx_queue(sp);\n\treturn 0;\n\nhw_init_failed:\n\tif (sp->config.intr_type == MSI_X) {\n\t\tif (sp->entries) {\n\t\t\tkfree(sp->entries);\n\t\t\tswstats->mem_freed += sp->num_entries *\n\t\t\t\tsizeof(struct msix_entry);\n\t\t}\n\t\tif (sp->s2io_entries) {\n\t\t\tkfree(sp->s2io_entries);\n\t\t\tswstats->mem_freed += sp->num_entries *\n\t\t\t\tsizeof(struct s2io_msix_entry);\n\t\t}\n\t}\n\treturn err;\n}\n\n \n\nstatic int s2io_close(struct net_device *dev)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct config_param *config = &sp->config;\n\tu64 tmp64;\n\tint offset;\n\n\t \n\tif (!is_s2io_card_up(sp))\n\t\treturn 0;\n\n\ts2io_stop_all_tx_queue(sp);\n\t \n\tfor (offset = 1; offset < config->max_mc_addr; offset++) {\n\t\ttmp64 = do_s2io_read_unicast_mc(sp, offset);\n\t\tif (tmp64 != S2IO_DISABLE_MAC_ENTRY)\n\t\t\tdo_s2io_delete_unicast_mc(sp, tmp64);\n\t}\n\n\ts2io_card_down(sp);\n\n\treturn 0;\n}\n\n \n\nstatic netdev_tx_t s2io_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tu16 frg_cnt, frg_len, i, queue, queue_len, put_off, get_off;\n\tregister u64 val64;\n\tstruct TxD *txdp;\n\tstruct TxFIFO_element __iomem *tx_fifo;\n\tunsigned long flags = 0;\n\tu16 vlan_tag = 0;\n\tstruct fifo_info *fifo = NULL;\n\tint offload_type;\n\tint enable_per_list_interrupt = 0;\n\tstruct config_param *config = &sp->config;\n\tstruct mac_info *mac_control = &sp->mac_control;\n\tstruct stat_block *stats = mac_control->stats_info;\n\tstruct swStat *swstats = &stats->sw_stat;\n\n\tDBG_PRINT(TX_DBG, \"%s: In Neterion Tx routine\\n\", dev->name);\n\n\tif (unlikely(skb->len <= 0)) {\n\t\tDBG_PRINT(TX_DBG, \"%s: Buffer has no data..\\n\", dev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (!is_s2io_card_up(sp)) {\n\t\tDBG_PRINT(TX_DBG, \"%s: Card going down for reset\\n\",\n\t\t\t  dev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tqueue = 0;\n\tif (skb_vlan_tag_present(skb))\n\t\tvlan_tag = skb_vlan_tag_get(skb);\n\tif (sp->config.tx_steering_type == TX_DEFAULT_STEERING) {\n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\tstruct iphdr *ip;\n\t\t\tstruct tcphdr *th;\n\t\t\tip = ip_hdr(skb);\n\n\t\t\tif (!ip_is_fragment(ip)) {\n\t\t\t\tth = (struct tcphdr *)(((unsigned char *)ip) +\n\t\t\t\t\t\t       ip->ihl*4);\n\n\t\t\t\tif (ip->protocol == IPPROTO_TCP) {\n\t\t\t\t\tqueue_len = sp->total_tcp_fifos;\n\t\t\t\t\tqueue = (ntohs(th->source) +\n\t\t\t\t\t\t ntohs(th->dest)) &\n\t\t\t\t\t\tsp->fifo_selector[queue_len - 1];\n\t\t\t\t\tif (queue >= queue_len)\n\t\t\t\t\t\tqueue = queue_len - 1;\n\t\t\t\t} else if (ip->protocol == IPPROTO_UDP) {\n\t\t\t\t\tqueue_len = sp->total_udp_fifos;\n\t\t\t\t\tqueue = (ntohs(th->source) +\n\t\t\t\t\t\t ntohs(th->dest)) &\n\t\t\t\t\t\tsp->fifo_selector[queue_len - 1];\n\t\t\t\t\tif (queue >= queue_len)\n\t\t\t\t\t\tqueue = queue_len - 1;\n\t\t\t\t\tqueue += sp->udp_fifo_idx;\n\t\t\t\t\tif (skb->len > 1024)\n\t\t\t\t\t\tenable_per_list_interrupt = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (sp->config.tx_steering_type == TX_PRIORITY_STEERING)\n\t\t \n\t\tqueue = config->fifo_mapping\n\t\t\t[skb->priority & (MAX_TX_FIFOS - 1)];\n\tfifo = &mac_control->fifos[queue];\n\n\tspin_lock_irqsave(&fifo->tx_lock, flags);\n\n\tif (sp->config.multiq) {\n\t\tif (__netif_subqueue_stopped(dev, fifo->fifo_no)) {\n\t\t\tspin_unlock_irqrestore(&fifo->tx_lock, flags);\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t} else if (unlikely(fifo->queue_state == FIFO_QUEUE_STOP)) {\n\t\tif (netif_queue_stopped(dev)) {\n\t\t\tspin_unlock_irqrestore(&fifo->tx_lock, flags);\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\n\tput_off = (u16)fifo->tx_curr_put_info.offset;\n\tget_off = (u16)fifo->tx_curr_get_info.offset;\n\ttxdp = fifo->list_info[put_off].list_virt_addr;\n\n\tqueue_len = fifo->tx_curr_put_info.fifo_len + 1;\n\t \n\tif (txdp->Host_Control ||\n\t    ((put_off+1) == queue_len ? 0 : (put_off+1)) == get_off) {\n\t\tDBG_PRINT(TX_DBG, \"Error in xmit, No free TXDs.\\n\");\n\t\ts2io_stop_tx_queue(sp, fifo->fifo_no);\n\t\tdev_kfree_skb_any(skb);\n\t\tspin_unlock_irqrestore(&fifo->tx_lock, flags);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\toffload_type = s2io_offload_type(skb);\n\tif (offload_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)) {\n\t\ttxdp->Control_1 |= TXD_TCP_LSO_EN;\n\t\ttxdp->Control_1 |= TXD_TCP_LSO_MSS(s2io_tcp_mss(skb));\n\t}\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttxdp->Control_2 |= (TXD_TX_CKO_IPV4_EN |\n\t\t\t\t    TXD_TX_CKO_TCP_EN |\n\t\t\t\t    TXD_TX_CKO_UDP_EN);\n\t}\n\ttxdp->Control_1 |= TXD_GATHER_CODE_FIRST;\n\ttxdp->Control_1 |= TXD_LIST_OWN_XENA;\n\ttxdp->Control_2 |= TXD_INT_NUMBER(fifo->fifo_no);\n\tif (enable_per_list_interrupt)\n\t\tif (put_off & (queue_len >> 5))\n\t\t\ttxdp->Control_2 |= TXD_INT_TYPE_PER_LIST;\n\tif (vlan_tag) {\n\t\ttxdp->Control_2 |= TXD_VLAN_ENABLE;\n\t\ttxdp->Control_2 |= TXD_VLAN_TAG(vlan_tag);\n\t}\n\n\tfrg_len = skb_headlen(skb);\n\ttxdp->Buffer_Pointer = dma_map_single(&sp->pdev->dev, skb->data,\n\t\t\t\t\t      frg_len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(&sp->pdev->dev, txdp->Buffer_Pointer))\n\t\tgoto pci_map_failed;\n\n\ttxdp->Host_Control = (unsigned long)skb;\n\ttxdp->Control_1 |= TXD_BUFFER0_SIZE(frg_len);\n\n\tfrg_cnt = skb_shinfo(skb)->nr_frags;\n\t \n\tfor (i = 0; i < frg_cnt; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\t \n\t\tif (!skb_frag_size(frag))\n\t\t\tcontinue;\n\t\ttxdp++;\n\t\ttxdp->Buffer_Pointer = (u64)skb_frag_dma_map(&sp->pdev->dev,\n\t\t\t\t\t\t\t     frag, 0,\n\t\t\t\t\t\t\t     skb_frag_size(frag),\n\t\t\t\t\t\t\t     DMA_TO_DEVICE);\n\t\ttxdp->Control_1 = TXD_BUFFER0_SIZE(skb_frag_size(frag));\n\t}\n\ttxdp->Control_1 |= TXD_GATHER_CODE_LAST;\n\n\ttx_fifo = mac_control->tx_FIFO_start[queue];\n\tval64 = fifo->list_info[put_off].list_phy_addr;\n\twriteq(val64, &tx_fifo->TxDL_Pointer);\n\n\tval64 = (TX_FIFO_LAST_TXD_NUM(frg_cnt) | TX_FIFO_FIRST_LIST |\n\t\t TX_FIFO_LAST_LIST);\n\tif (offload_type)\n\t\tval64 |= TX_FIFO_SPECIAL_FUNC;\n\n\twriteq(val64, &tx_fifo->List_Control);\n\n\tput_off++;\n\tif (put_off == fifo->tx_curr_put_info.fifo_len + 1)\n\t\tput_off = 0;\n\tfifo->tx_curr_put_info.offset = put_off;\n\n\t \n\tif (((put_off+1) == queue_len ? 0 : (put_off+1)) == get_off) {\n\t\tswstats->fifo_full_cnt++;\n\t\tDBG_PRINT(TX_DBG,\n\t\t\t  \"No free TxDs for xmit, Put: 0x%x Get:0x%x\\n\",\n\t\t\t  put_off, get_off);\n\t\ts2io_stop_tx_queue(sp, fifo->fifo_no);\n\t}\n\tswstats->mem_allocated += skb->truesize;\n\tspin_unlock_irqrestore(&fifo->tx_lock, flags);\n\n\tif (sp->config.intr_type == MSI_X)\n\t\ttx_intr_handler(fifo);\n\n\treturn NETDEV_TX_OK;\n\npci_map_failed:\n\tswstats->pci_map_fail_cnt++;\n\ts2io_stop_tx_queue(sp, fifo->fifo_no);\n\tswstats->mem_freed += skb->truesize;\n\tdev_kfree_skb_any(skb);\n\tspin_unlock_irqrestore(&fifo->tx_lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\ns2io_alarm_handle(struct timer_list *t)\n{\n\tstruct s2io_nic *sp = from_timer(sp, t, alarm_timer);\n\tstruct net_device *dev = sp->dev;\n\n\ts2io_handle_errors(dev);\n\tmod_timer(&sp->alarm_timer, jiffies + HZ / 2);\n}\n\nstatic irqreturn_t s2io_msix_ring_handle(int irq, void *dev_id)\n{\n\tstruct ring_info *ring = (struct ring_info *)dev_id;\n\tstruct s2io_nic *sp = ring->nic;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\tif (unlikely(!is_s2io_card_up(sp)))\n\t\treturn IRQ_HANDLED;\n\n\tif (sp->config.napi) {\n\t\tu8 __iomem *addr = NULL;\n\t\tu8 val8 = 0;\n\n\t\taddr = (u8 __iomem *)&bar0->xmsi_mask_reg;\n\t\taddr += (7 - ring->ring_no);\n\t\tval8 = (ring->ring_no == 0) ? 0x7f : 0xff;\n\t\twriteb(val8, addr);\n\t\tval8 = readb(addr);\n\t\tnapi_schedule(&ring->napi);\n\t} else {\n\t\trx_intr_handler(ring, 0);\n\t\ts2io_chk_rx_buffers(sp, ring);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t s2io_msix_fifo_handle(int irq, void *dev_id)\n{\n\tint i;\n\tstruct fifo_info *fifos = (struct fifo_info *)dev_id;\n\tstruct s2io_nic *sp = fifos->nic;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tstruct config_param *config  = &sp->config;\n\tu64 reason;\n\n\tif (unlikely(!is_s2io_card_up(sp)))\n\t\treturn IRQ_NONE;\n\n\treason = readq(&bar0->general_int_status);\n\tif (unlikely(reason == S2IO_MINUS_ONE))\n\t\t \n\t\treturn IRQ_HANDLED;\n\n\tif (reason & (GEN_INTR_TXPIC | GEN_INTR_TXTRAFFIC)) {\n\t\twriteq(S2IO_MINUS_ONE, &bar0->general_int_mask);\n\n\t\tif (reason & GEN_INTR_TXPIC)\n\t\t\ts2io_txpic_intr_handle(sp);\n\n\t\tif (reason & GEN_INTR_TXTRAFFIC)\n\t\t\twriteq(S2IO_MINUS_ONE, &bar0->tx_traffic_int);\n\n\t\tfor (i = 0; i < config->tx_fifo_num; i++)\n\t\t\ttx_intr_handler(&fifos[i]);\n\n\t\twriteq(sp->general_int_mask, &bar0->general_int_mask);\n\t\treadl(&bar0->general_int_status);\n\t\treturn IRQ_HANDLED;\n\t}\n\t \n\treturn IRQ_NONE;\n}\n\nstatic void s2io_txpic_intr_handle(struct s2io_nic *sp)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64;\n\n\tval64 = readq(&bar0->pic_int_status);\n\tif (val64 & PIC_INT_GPIO) {\n\t\tval64 = readq(&bar0->gpio_int_reg);\n\t\tif ((val64 & GPIO_INT_REG_LINK_DOWN) &&\n\t\t    (val64 & GPIO_INT_REG_LINK_UP)) {\n\t\t\t \n\t\t\tval64 |= GPIO_INT_REG_LINK_DOWN;\n\t\t\tval64 |= GPIO_INT_REG_LINK_UP;\n\t\t\twriteq(val64, &bar0->gpio_int_reg);\n\t\t\tval64 = readq(&bar0->gpio_int_mask);\n\t\t\tval64 &= ~(GPIO_INT_MASK_LINK_UP |\n\t\t\t\t   GPIO_INT_MASK_LINK_DOWN);\n\t\t\twriteq(val64, &bar0->gpio_int_mask);\n\t\t} else if (val64 & GPIO_INT_REG_LINK_UP) {\n\t\t\tval64 = readq(&bar0->adapter_status);\n\t\t\t \n\t\t\tval64 = readq(&bar0->adapter_control);\n\t\t\tval64 |= ADAPTER_CNTL_EN;\n\t\t\twriteq(val64, &bar0->adapter_control);\n\t\t\tval64 |= ADAPTER_LED_ON;\n\t\t\twriteq(val64, &bar0->adapter_control);\n\t\t\tif (!sp->device_enabled_once)\n\t\t\t\tsp->device_enabled_once = 1;\n\n\t\t\ts2io_link(sp, LINK_UP);\n\t\t\t \n\t\t\tval64 = readq(&bar0->gpio_int_mask);\n\t\t\tval64 &= ~GPIO_INT_MASK_LINK_DOWN;\n\t\t\tval64 |= GPIO_INT_MASK_LINK_UP;\n\t\t\twriteq(val64, &bar0->gpio_int_mask);\n\n\t\t} else if (val64 & GPIO_INT_REG_LINK_DOWN) {\n\t\t\tval64 = readq(&bar0->adapter_status);\n\t\t\ts2io_link(sp, LINK_DOWN);\n\t\t\t \n\t\t\tval64 = readq(&bar0->gpio_int_mask);\n\t\t\tval64 &= ~GPIO_INT_MASK_LINK_UP;\n\t\t\tval64 |= GPIO_INT_MASK_LINK_DOWN;\n\t\t\twriteq(val64, &bar0->gpio_int_mask);\n\n\t\t\t \n\t\t\tval64 = readq(&bar0->adapter_control);\n\t\t\tval64 = val64 & (~ADAPTER_LED_ON);\n\t\t\twriteq(val64, &bar0->adapter_control);\n\t\t}\n\t}\n\tval64 = readq(&bar0->gpio_int_mask);\n}\n\n \nstatic int do_s2io_chk_alarm_bit(u64 value, void __iomem *addr,\n\t\t\t\t unsigned long long *cnt)\n{\n\tu64 val64;\n\tval64 = readq(addr);\n\tif (val64 & value) {\n\t\twriteq(val64, addr);\n\t\t(*cnt)++;\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}\n\n \nstatic void s2io_handle_errors(void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 temp64 = 0, val64 = 0;\n\tint i = 0;\n\n\tstruct swStat *sw_stat = &sp->mac_control.stats_info->sw_stat;\n\tstruct xpakStat *stats = &sp->mac_control.stats_info->xpak_stat;\n\n\tif (!is_s2io_card_up(sp))\n\t\treturn;\n\n\tif (pci_channel_offline(sp->pdev))\n\t\treturn;\n\n\tmemset(&sw_stat->ring_full_cnt, 0,\n\t       sizeof(sw_stat->ring_full_cnt));\n\n\t \n\tif (stats->xpak_timer_count < 72000) {\n\t\t \n\t\tstats->xpak_timer_count++;\n\t} else {\n\t\ts2io_updt_xpak_counter(dev);\n\t\t \n\t\tstats->xpak_timer_count = 0;\n\t}\n\n\t \n\tif (s2io_link_fault_indication(sp) == MAC_RMAC_ERR_TIMER) {\n\t\tval64 = readq(&bar0->mac_rmac_err_reg);\n\t\twriteq(val64, &bar0->mac_rmac_err_reg);\n\t\tif (val64 & RMAC_LINK_STATE_CHANGE_INT)\n\t\t\tschedule_work(&sp->set_link_task);\n\t}\n\n\t \n\tif (do_s2io_chk_alarm_bit(SERR_SOURCE_ANY, &bar0->serr_source,\n\t\t\t\t  &sw_stat->serious_err_cnt))\n\t\tgoto reset;\n\n\t \n\tif (do_s2io_chk_alarm_bit(GPIO_INT_REG_DP_ERR_INT, &bar0->gpio_int_reg,\n\t\t\t\t  &sw_stat->parity_err_cnt))\n\t\tgoto reset;\n\n\t \n\tif (sp->device_type == XFRAME_II_DEVICE) {\n\t\tval64 = readq(&bar0->ring_bump_counter1);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\ttemp64 = (val64 & vBIT(0xFFFF, (i*16), 16));\n\t\t\ttemp64 >>= 64 - ((i+1)*16);\n\t\t\tsw_stat->ring_full_cnt[i] += temp64;\n\t\t}\n\n\t\tval64 = readq(&bar0->ring_bump_counter2);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\ttemp64 = (val64 & vBIT(0xFFFF, (i*16), 16));\n\t\t\ttemp64 >>= 64 - ((i+1)*16);\n\t\t\tsw_stat->ring_full_cnt[i+4] += temp64;\n\t\t}\n\t}\n\n\tval64 = readq(&bar0->txdma_int_status);\n\t \n\tif (val64 & TXDMA_PFC_INT) {\n\t\tif (do_s2io_chk_alarm_bit(PFC_ECC_DB_ERR | PFC_SM_ERR_ALARM |\n\t\t\t\t\t  PFC_MISC_0_ERR | PFC_MISC_1_ERR |\n\t\t\t\t\t  PFC_PCIX_ERR,\n\t\t\t\t\t  &bar0->pfc_err_reg,\n\t\t\t\t\t  &sw_stat->pfc_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(PFC_ECC_SG_ERR,\n\t\t\t\t      &bar0->pfc_err_reg,\n\t\t\t\t      &sw_stat->pfc_err_cnt);\n\t}\n\n\t \n\tif (val64 & TXDMA_TDA_INT) {\n\t\tif (do_s2io_chk_alarm_bit(TDA_Fn_ECC_DB_ERR |\n\t\t\t\t\t  TDA_SM0_ERR_ALARM |\n\t\t\t\t\t  TDA_SM1_ERR_ALARM,\n\t\t\t\t\t  &bar0->tda_err_reg,\n\t\t\t\t\t  &sw_stat->tda_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(TDA_Fn_ECC_SG_ERR | TDA_PCIX_ERR,\n\t\t\t\t      &bar0->tda_err_reg,\n\t\t\t\t      &sw_stat->tda_err_cnt);\n\t}\n\t \n\tif (val64 & TXDMA_PCC_INT) {\n\t\tif (do_s2io_chk_alarm_bit(PCC_SM_ERR_ALARM | PCC_WR_ERR_ALARM |\n\t\t\t\t\t  PCC_N_SERR | PCC_6_COF_OV_ERR |\n\t\t\t\t\t  PCC_7_COF_OV_ERR | PCC_6_LSO_OV_ERR |\n\t\t\t\t\t  PCC_7_LSO_OV_ERR | PCC_FB_ECC_DB_ERR |\n\t\t\t\t\t  PCC_TXB_ECC_DB_ERR,\n\t\t\t\t\t  &bar0->pcc_err_reg,\n\t\t\t\t\t  &sw_stat->pcc_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(PCC_FB_ECC_SG_ERR | PCC_TXB_ECC_SG_ERR,\n\t\t\t\t      &bar0->pcc_err_reg,\n\t\t\t\t      &sw_stat->pcc_err_cnt);\n\t}\n\n\t \n\tif (val64 & TXDMA_TTI_INT) {\n\t\tif (do_s2io_chk_alarm_bit(TTI_SM_ERR_ALARM,\n\t\t\t\t\t  &bar0->tti_err_reg,\n\t\t\t\t\t  &sw_stat->tti_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(TTI_ECC_SG_ERR | TTI_ECC_DB_ERR,\n\t\t\t\t      &bar0->tti_err_reg,\n\t\t\t\t      &sw_stat->tti_err_cnt);\n\t}\n\n\t \n\tif (val64 & TXDMA_LSO_INT) {\n\t\tif (do_s2io_chk_alarm_bit(LSO6_ABORT | LSO7_ABORT |\n\t\t\t\t\t  LSO6_SM_ERR_ALARM | LSO7_SM_ERR_ALARM,\n\t\t\t\t\t  &bar0->lso_err_reg,\n\t\t\t\t\t  &sw_stat->lso_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(LSO6_SEND_OFLOW | LSO7_SEND_OFLOW,\n\t\t\t\t      &bar0->lso_err_reg,\n\t\t\t\t      &sw_stat->lso_err_cnt);\n\t}\n\n\t \n\tif (val64 & TXDMA_TPA_INT) {\n\t\tif (do_s2io_chk_alarm_bit(TPA_SM_ERR_ALARM,\n\t\t\t\t\t  &bar0->tpa_err_reg,\n\t\t\t\t\t  &sw_stat->tpa_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(TPA_TX_FRM_DROP,\n\t\t\t\t      &bar0->tpa_err_reg,\n\t\t\t\t      &sw_stat->tpa_err_cnt);\n\t}\n\n\t \n\tif (val64 & TXDMA_SM_INT) {\n\t\tif (do_s2io_chk_alarm_bit(SM_SM_ERR_ALARM,\n\t\t\t\t\t  &bar0->sm_err_reg,\n\t\t\t\t\t  &sw_stat->sm_err_cnt))\n\t\t\tgoto reset;\n\t}\n\n\tval64 = readq(&bar0->mac_int_status);\n\tif (val64 & MAC_INT_STATUS_TMAC_INT) {\n\t\tif (do_s2io_chk_alarm_bit(TMAC_TX_BUF_OVRN | TMAC_TX_SM_ERR,\n\t\t\t\t\t  &bar0->mac_tmac_err_reg,\n\t\t\t\t\t  &sw_stat->mac_tmac_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(TMAC_ECC_SG_ERR | TMAC_ECC_DB_ERR |\n\t\t\t\t      TMAC_DESC_ECC_SG_ERR |\n\t\t\t\t      TMAC_DESC_ECC_DB_ERR,\n\t\t\t\t      &bar0->mac_tmac_err_reg,\n\t\t\t\t      &sw_stat->mac_tmac_err_cnt);\n\t}\n\n\tval64 = readq(&bar0->xgxs_int_status);\n\tif (val64 & XGXS_INT_STATUS_TXGXS) {\n\t\tif (do_s2io_chk_alarm_bit(TXGXS_ESTORE_UFLOW | TXGXS_TX_SM_ERR,\n\t\t\t\t\t  &bar0->xgxs_txgxs_err_reg,\n\t\t\t\t\t  &sw_stat->xgxs_txgxs_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(TXGXS_ECC_SG_ERR | TXGXS_ECC_DB_ERR,\n\t\t\t\t      &bar0->xgxs_txgxs_err_reg,\n\t\t\t\t      &sw_stat->xgxs_txgxs_err_cnt);\n\t}\n\n\tval64 = readq(&bar0->rxdma_int_status);\n\tif (val64 & RXDMA_INT_RC_INT_M) {\n\t\tif (do_s2io_chk_alarm_bit(RC_PRCn_ECC_DB_ERR |\n\t\t\t\t\t  RC_FTC_ECC_DB_ERR |\n\t\t\t\t\t  RC_PRCn_SM_ERR_ALARM |\n\t\t\t\t\t  RC_FTC_SM_ERR_ALARM,\n\t\t\t\t\t  &bar0->rc_err_reg,\n\t\t\t\t\t  &sw_stat->rc_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(RC_PRCn_ECC_SG_ERR |\n\t\t\t\t      RC_FTC_ECC_SG_ERR |\n\t\t\t\t      RC_RDA_FAIL_WR_Rn, &bar0->rc_err_reg,\n\t\t\t\t      &sw_stat->rc_err_cnt);\n\t\tif (do_s2io_chk_alarm_bit(PRC_PCI_AB_RD_Rn |\n\t\t\t\t\t  PRC_PCI_AB_WR_Rn |\n\t\t\t\t\t  PRC_PCI_AB_F_WR_Rn,\n\t\t\t\t\t  &bar0->prc_pcix_err_reg,\n\t\t\t\t\t  &sw_stat->prc_pcix_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(PRC_PCI_DP_RD_Rn |\n\t\t\t\t      PRC_PCI_DP_WR_Rn |\n\t\t\t\t      PRC_PCI_DP_F_WR_Rn,\n\t\t\t\t      &bar0->prc_pcix_err_reg,\n\t\t\t\t      &sw_stat->prc_pcix_err_cnt);\n\t}\n\n\tif (val64 & RXDMA_INT_RPA_INT_M) {\n\t\tif (do_s2io_chk_alarm_bit(RPA_SM_ERR_ALARM | RPA_CREDIT_ERR,\n\t\t\t\t\t  &bar0->rpa_err_reg,\n\t\t\t\t\t  &sw_stat->rpa_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(RPA_ECC_SG_ERR | RPA_ECC_DB_ERR,\n\t\t\t\t      &bar0->rpa_err_reg,\n\t\t\t\t      &sw_stat->rpa_err_cnt);\n\t}\n\n\tif (val64 & RXDMA_INT_RDA_INT_M) {\n\t\tif (do_s2io_chk_alarm_bit(RDA_RXDn_ECC_DB_ERR |\n\t\t\t\t\t  RDA_FRM_ECC_DB_N_AERR |\n\t\t\t\t\t  RDA_SM1_ERR_ALARM |\n\t\t\t\t\t  RDA_SM0_ERR_ALARM |\n\t\t\t\t\t  RDA_RXD_ECC_DB_SERR,\n\t\t\t\t\t  &bar0->rda_err_reg,\n\t\t\t\t\t  &sw_stat->rda_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(RDA_RXDn_ECC_SG_ERR |\n\t\t\t\t      RDA_FRM_ECC_SG_ERR |\n\t\t\t\t      RDA_MISC_ERR |\n\t\t\t\t      RDA_PCIX_ERR,\n\t\t\t\t      &bar0->rda_err_reg,\n\t\t\t\t      &sw_stat->rda_err_cnt);\n\t}\n\n\tif (val64 & RXDMA_INT_RTI_INT_M) {\n\t\tif (do_s2io_chk_alarm_bit(RTI_SM_ERR_ALARM,\n\t\t\t\t\t  &bar0->rti_err_reg,\n\t\t\t\t\t  &sw_stat->rti_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(RTI_ECC_SG_ERR | RTI_ECC_DB_ERR,\n\t\t\t\t      &bar0->rti_err_reg,\n\t\t\t\t      &sw_stat->rti_err_cnt);\n\t}\n\n\tval64 = readq(&bar0->mac_int_status);\n\tif (val64 & MAC_INT_STATUS_RMAC_INT) {\n\t\tif (do_s2io_chk_alarm_bit(RMAC_RX_BUFF_OVRN | RMAC_RX_SM_ERR,\n\t\t\t\t\t  &bar0->mac_rmac_err_reg,\n\t\t\t\t\t  &sw_stat->mac_rmac_err_cnt))\n\t\t\tgoto reset;\n\t\tdo_s2io_chk_alarm_bit(RMAC_UNUSED_INT |\n\t\t\t\t      RMAC_SINGLE_ECC_ERR |\n\t\t\t\t      RMAC_DOUBLE_ECC_ERR,\n\t\t\t\t      &bar0->mac_rmac_err_reg,\n\t\t\t\t      &sw_stat->mac_rmac_err_cnt);\n\t}\n\n\tval64 = readq(&bar0->xgxs_int_status);\n\tif (val64 & XGXS_INT_STATUS_RXGXS) {\n\t\tif (do_s2io_chk_alarm_bit(RXGXS_ESTORE_OFLOW | RXGXS_RX_SM_ERR,\n\t\t\t\t\t  &bar0->xgxs_rxgxs_err_reg,\n\t\t\t\t\t  &sw_stat->xgxs_rxgxs_err_cnt))\n\t\t\tgoto reset;\n\t}\n\n\tval64 = readq(&bar0->mc_int_status);\n\tif (val64 & MC_INT_STATUS_MC_INT) {\n\t\tif (do_s2io_chk_alarm_bit(MC_ERR_REG_SM_ERR,\n\t\t\t\t\t  &bar0->mc_err_reg,\n\t\t\t\t\t  &sw_stat->mc_err_cnt))\n\t\t\tgoto reset;\n\n\t\t \n\t\tif (val64 & (MC_ERR_REG_ECC_ALL_SNG | MC_ERR_REG_ECC_ALL_DBL)) {\n\t\t\twriteq(val64, &bar0->mc_err_reg);\n\t\t\tif (val64 & MC_ERR_REG_ECC_ALL_DBL) {\n\t\t\t\tsw_stat->double_ecc_errs++;\n\t\t\t\tif (sp->device_type != XFRAME_II_DEVICE) {\n\t\t\t\t\t \n\t\t\t\t\tif (val64 &\n\t\t\t\t\t    (MC_ERR_REG_MIRI_ECC_DB_ERR_0 |\n\t\t\t\t\t     MC_ERR_REG_MIRI_ECC_DB_ERR_1))\n\t\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tsw_stat->single_ecc_errs++;\n\t\t}\n\t}\n\treturn;\n\nreset:\n\ts2io_stop_all_tx_queue(sp);\n\tschedule_work(&sp->rst_timer_task);\n\tsw_stat->soft_reset_cnt++;\n}\n\n \nstatic irqreturn_t s2io_isr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tint i;\n\tu64 reason = 0;\n\tstruct mac_info *mac_control;\n\tstruct config_param *config;\n\n\t \n\tif (pci_channel_offline(sp->pdev))\n\t\treturn IRQ_NONE;\n\n\tif (!is_s2io_card_up(sp))\n\t\treturn IRQ_NONE;\n\n\tconfig = &sp->config;\n\tmac_control = &sp->mac_control;\n\n\t \n\treason = readq(&bar0->general_int_status);\n\n\tif (unlikely(reason == S2IO_MINUS_ONE))\n\t\treturn IRQ_HANDLED;\t \n\n\tif (reason &\n\t    (GEN_INTR_RXTRAFFIC | GEN_INTR_TXTRAFFIC | GEN_INTR_TXPIC)) {\n\t\twriteq(S2IO_MINUS_ONE, &bar0->general_int_mask);\n\n\t\tif (config->napi) {\n\t\t\tif (reason & GEN_INTR_RXTRAFFIC) {\n\t\t\t\tnapi_schedule(&sp->napi);\n\t\t\t\twriteq(S2IO_MINUS_ONE, &bar0->rx_traffic_mask);\n\t\t\t\twriteq(S2IO_MINUS_ONE, &bar0->rx_traffic_int);\n\t\t\t\treadl(&bar0->rx_traffic_int);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (reason & GEN_INTR_RXTRAFFIC)\n\t\t\t\twriteq(S2IO_MINUS_ONE, &bar0->rx_traffic_int);\n\n\t\t\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\t\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\t\t\trx_intr_handler(ring, 0);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (reason & GEN_INTR_TXTRAFFIC)\n\t\t\twriteq(S2IO_MINUS_ONE, &bar0->tx_traffic_int);\n\n\t\tfor (i = 0; i < config->tx_fifo_num; i++)\n\t\t\ttx_intr_handler(&mac_control->fifos[i]);\n\n\t\tif (reason & GEN_INTR_TXPIC)\n\t\t\ts2io_txpic_intr_handle(sp);\n\n\t\t \n\t\tif (!config->napi) {\n\t\t\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\t\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\t\t\ts2io_chk_rx_buffers(sp, ring);\n\t\t\t}\n\t\t}\n\t\twriteq(sp->general_int_mask, &bar0->general_int_mask);\n\t\treadl(&bar0->general_int_status);\n\n\t\treturn IRQ_HANDLED;\n\n\t} else if (!reason) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void s2io_updt_stats(struct s2io_nic *sp)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64;\n\tint cnt = 0;\n\n\tif (is_s2io_card_up(sp)) {\n\t\t \n\t\tval64 = SET_UPDT_CLICKS(10) |\n\t\t\tSTAT_CFG_ONE_SHOT_EN | STAT_CFG_STAT_EN;\n\t\twriteq(val64, &bar0->stat_cfg);\n\t\tdo {\n\t\t\tudelay(100);\n\t\t\tval64 = readq(&bar0->stat_cfg);\n\t\t\tif (!(val64 & s2BIT(0)))\n\t\t\t\tbreak;\n\t\t\tcnt++;\n\t\t\tif (cnt == 5)\n\t\t\t\tbreak;  \n\t\t} while (1);\n\t}\n}\n\n \nstatic struct net_device_stats *s2io_get_stats(struct net_device *dev)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct mac_info *mac_control = &sp->mac_control;\n\tstruct stat_block *stats = mac_control->stats_info;\n\tu64 delta;\n\n\t \n\ts2io_updt_stats(sp);\n\n\t \n\tdelta = ((u64) le32_to_cpu(stats->rmac_vld_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_vld_frms)) - sp->stats.rx_packets;\n\tsp->stats.rx_packets += delta;\n\tdev->stats.rx_packets += delta;\n\n\tdelta = ((u64) le32_to_cpu(stats->tmac_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_frms)) - sp->stats.tx_packets;\n\tsp->stats.tx_packets += delta;\n\tdev->stats.tx_packets += delta;\n\n\tdelta = ((u64) le32_to_cpu(stats->rmac_data_octets_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_data_octets)) - sp->stats.rx_bytes;\n\tsp->stats.rx_bytes += delta;\n\tdev->stats.rx_bytes += delta;\n\n\tdelta = ((u64) le32_to_cpu(stats->tmac_data_octets_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_data_octets)) - sp->stats.tx_bytes;\n\tsp->stats.tx_bytes += delta;\n\tdev->stats.tx_bytes += delta;\n\n\tdelta = le64_to_cpu(stats->rmac_drop_frms) - sp->stats.rx_errors;\n\tsp->stats.rx_errors += delta;\n\tdev->stats.rx_errors += delta;\n\n\tdelta = ((u64) le32_to_cpu(stats->tmac_any_err_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_any_err_frms)) - sp->stats.tx_errors;\n\tsp->stats.tx_errors += delta;\n\tdev->stats.tx_errors += delta;\n\n\tdelta = le64_to_cpu(stats->rmac_drop_frms) - sp->stats.rx_dropped;\n\tsp->stats.rx_dropped += delta;\n\tdev->stats.rx_dropped += delta;\n\n\tdelta = le64_to_cpu(stats->tmac_drop_frms) - sp->stats.tx_dropped;\n\tsp->stats.tx_dropped += delta;\n\tdev->stats.tx_dropped += delta;\n\n\t \n\tdelta = (u64) le32_to_cpu(stats->rmac_vld_mcst_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_vld_mcst_frms);\n\tdelta -= le64_to_cpu(stats->rmac_pause_ctrl_frms);\n\tdelta -= sp->stats.multicast;\n\tsp->stats.multicast += delta;\n\tdev->stats.multicast += delta;\n\n\tdelta = ((u64) le32_to_cpu(stats->rmac_usized_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_usized_frms)) +\n\t\tle64_to_cpu(stats->rmac_long_frms) - sp->stats.rx_length_errors;\n\tsp->stats.rx_length_errors += delta;\n\tdev->stats.rx_length_errors += delta;\n\n\tdelta = le64_to_cpu(stats->rmac_fcs_err_frms) - sp->stats.rx_crc_errors;\n\tsp->stats.rx_crc_errors += delta;\n\tdev->stats.rx_crc_errors += delta;\n\n\treturn &dev->stats;\n}\n\n \nstatic void s2io_set_multicast(struct net_device *dev, bool may_sleep)\n{\n\tint i, j, prev_cnt;\n\tstruct netdev_hw_addr *ha;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64 = 0, multi_mac = 0x010203040506ULL, mask =\n\t\t0xfeffffffffffULL;\n\tu64 dis_addr = S2IO_DISABLE_MAC_ENTRY, mac_addr = 0;\n\tvoid __iomem *add;\n\tstruct config_param *config = &sp->config;\n\n\tif ((dev->flags & IFF_ALLMULTI) && (!sp->m_cast_flg)) {\n\t\t \n\t\twriteq(RMAC_ADDR_DATA0_MEM_ADDR(multi_mac),\n\t\t       &bar0->rmac_addr_data0_mem);\n\t\twriteq(RMAC_ADDR_DATA1_MEM_MASK(mask),\n\t\t       &bar0->rmac_addr_data1_mem);\n\t\tval64 = RMAC_ADDR_CMD_MEM_WE |\n\t\t\tRMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |\n\t\t\tRMAC_ADDR_CMD_MEM_OFFSET(config->max_mc_addr - 1);\n\t\twriteq(val64, &bar0->rmac_addr_cmd_mem);\n\t\t \n\t\twait_for_cmd_complete(&bar0->rmac_addr_cmd_mem,\n\t\t\t\t      RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING,\n\t\t\t\t      S2IO_BIT_RESET, may_sleep);\n\n\t\tsp->m_cast_flg = 1;\n\t\tsp->all_multi_pos = config->max_mc_addr - 1;\n\t} else if ((dev->flags & IFF_ALLMULTI) && (sp->m_cast_flg)) {\n\t\t \n\t\twriteq(RMAC_ADDR_DATA0_MEM_ADDR(dis_addr),\n\t\t       &bar0->rmac_addr_data0_mem);\n\t\twriteq(RMAC_ADDR_DATA1_MEM_MASK(0x0),\n\t\t       &bar0->rmac_addr_data1_mem);\n\t\tval64 = RMAC_ADDR_CMD_MEM_WE |\n\t\t\tRMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |\n\t\t\tRMAC_ADDR_CMD_MEM_OFFSET(sp->all_multi_pos);\n\t\twriteq(val64, &bar0->rmac_addr_cmd_mem);\n\t\t \n\t\twait_for_cmd_complete(&bar0->rmac_addr_cmd_mem,\n\t\t\t\t      RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING,\n\t\t\t\t      S2IO_BIT_RESET, may_sleep);\n\n\t\tsp->m_cast_flg = 0;\n\t\tsp->all_multi_pos = 0;\n\t}\n\n\tif ((dev->flags & IFF_PROMISC) && (!sp->promisc_flg)) {\n\t\t \n\t\tadd = &bar0->mac_cfg;\n\t\tval64 = readq(&bar0->mac_cfg);\n\t\tval64 |= MAC_CFG_RMAC_PROM_ENABLE;\n\n\t\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\t\twritel((u32)val64, add);\n\t\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\t\twritel((u32) (val64 >> 32), (add + 4));\n\n\t\tif (vlan_tag_strip != 1) {\n\t\t\tval64 = readq(&bar0->rx_pa_cfg);\n\t\t\tval64 &= ~RX_PA_CFG_STRIP_VLAN_TAG;\n\t\t\twriteq(val64, &bar0->rx_pa_cfg);\n\t\t\tsp->vlan_strip_flag = 0;\n\t\t}\n\n\t\tval64 = readq(&bar0->mac_cfg);\n\t\tsp->promisc_flg = 1;\n\t\tDBG_PRINT(INFO_DBG, \"%s: entered promiscuous mode\\n\",\n\t\t\t  dev->name);\n\t} else if (!(dev->flags & IFF_PROMISC) && (sp->promisc_flg)) {\n\t\t \n\t\tadd = &bar0->mac_cfg;\n\t\tval64 = readq(&bar0->mac_cfg);\n\t\tval64 &= ~MAC_CFG_RMAC_PROM_ENABLE;\n\n\t\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\t\twritel((u32)val64, add);\n\t\twriteq(RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);\n\t\twritel((u32) (val64 >> 32), (add + 4));\n\n\t\tif (vlan_tag_strip != 0) {\n\t\t\tval64 = readq(&bar0->rx_pa_cfg);\n\t\t\tval64 |= RX_PA_CFG_STRIP_VLAN_TAG;\n\t\t\twriteq(val64, &bar0->rx_pa_cfg);\n\t\t\tsp->vlan_strip_flag = 1;\n\t\t}\n\n\t\tval64 = readq(&bar0->mac_cfg);\n\t\tsp->promisc_flg = 0;\n\t\tDBG_PRINT(INFO_DBG, \"%s: left promiscuous mode\\n\", dev->name);\n\t}\n\n\t \n\tif ((!sp->m_cast_flg) && netdev_mc_count(dev)) {\n\t\tif (netdev_mc_count(dev) >\n\t\t    (config->max_mc_addr - config->max_mac_addr)) {\n\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t  \"%s: No more Rx filters can be added - \"\n\t\t\t\t  \"please enable ALL_MULTI instead\\n\",\n\t\t\t\t  dev->name);\n\t\t\treturn;\n\t\t}\n\n\t\tprev_cnt = sp->mc_addr_count;\n\t\tsp->mc_addr_count = netdev_mc_count(dev);\n\n\t\t \n\t\tfor (i = 0; i < prev_cnt; i++) {\n\t\t\twriteq(RMAC_ADDR_DATA0_MEM_ADDR(dis_addr),\n\t\t\t       &bar0->rmac_addr_data0_mem);\n\t\t\twriteq(RMAC_ADDR_DATA1_MEM_MASK(0ULL),\n\t\t\t       &bar0->rmac_addr_data1_mem);\n\t\t\tval64 = RMAC_ADDR_CMD_MEM_WE |\n\t\t\t\tRMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |\n\t\t\t\tRMAC_ADDR_CMD_MEM_OFFSET\n\t\t\t\t(config->mc_start_offset + i);\n\t\t\twriteq(val64, &bar0->rmac_addr_cmd_mem);\n\n\t\t\t \n\t\t\tif (wait_for_cmd_complete(&bar0->rmac_addr_cmd_mem,\n\t\t\t\t\t\t  RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING,\n\t\t\t\t\t\t  S2IO_BIT_RESET, may_sleep)) {\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t  \"%s: Adding Multicasts failed\\n\",\n\t\t\t\t\t  dev->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tmac_addr = 0;\n\t\t\tfor (j = 0; j < ETH_ALEN; j++) {\n\t\t\t\tmac_addr |= ha->addr[j];\n\t\t\t\tmac_addr <<= 8;\n\t\t\t}\n\t\t\tmac_addr >>= 8;\n\t\t\twriteq(RMAC_ADDR_DATA0_MEM_ADDR(mac_addr),\n\t\t\t       &bar0->rmac_addr_data0_mem);\n\t\t\twriteq(RMAC_ADDR_DATA1_MEM_MASK(0ULL),\n\t\t\t       &bar0->rmac_addr_data1_mem);\n\t\t\tval64 = RMAC_ADDR_CMD_MEM_WE |\n\t\t\t\tRMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |\n\t\t\t\tRMAC_ADDR_CMD_MEM_OFFSET\n\t\t\t\t(i + config->mc_start_offset);\n\t\t\twriteq(val64, &bar0->rmac_addr_cmd_mem);\n\n\t\t\t \n\t\t\tif (wait_for_cmd_complete(&bar0->rmac_addr_cmd_mem,\n\t\t\t\t\t\t  RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING,\n\t\t\t\t\t\t  S2IO_BIT_RESET, may_sleep)) {\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t  \"%s: Adding Multicasts failed\\n\",\n\t\t\t\t\t  dev->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n \nstatic void s2io_ndo_set_multicast(struct net_device *dev)\n{\n\ts2io_set_multicast(dev, false);\n}\n\n \nstatic void do_s2io_store_unicast_mc(struct s2io_nic *sp)\n{\n\tint offset;\n\tu64 mac_addr = 0x0;\n\tstruct config_param *config = &sp->config;\n\n\t \n\tfor (offset = 0; offset < config->max_mc_addr; offset++) {\n\t\tmac_addr = do_s2io_read_unicast_mc(sp, offset);\n\t\t \n\t\tif (mac_addr == FAILURE)\n\t\t\tmac_addr = S2IO_DISABLE_MAC_ENTRY;\n\t\tdo_s2io_copy_mac_addr(sp, offset, mac_addr);\n\t}\n}\n\n \nstatic void do_s2io_restore_unicast_mc(struct s2io_nic *sp)\n{\n\tint offset;\n\tstruct config_param *config = &sp->config;\n\t \n\tfor (offset = 0; offset < config->max_mac_addr; offset++)\n\t\tdo_s2io_prog_unicast(sp->dev,\n\t\t\t\t     sp->def_mac_addr[offset].mac_addr);\n\n\t \n\tfor (offset = config->mc_start_offset;\n\t     offset < config->max_mc_addr; offset++)\n\t\tdo_s2io_add_mc(sp, sp->def_mac_addr[offset].mac_addr);\n}\n\n \nstatic int do_s2io_add_mc(struct s2io_nic *sp, u8 *addr)\n{\n\tint i;\n\tu64 mac_addr;\n\tstruct config_param *config = &sp->config;\n\n\tmac_addr = ether_addr_to_u64(addr);\n\tif ((0ULL == mac_addr) || (mac_addr == S2IO_DISABLE_MAC_ENTRY))\n\t\treturn SUCCESS;\n\n\t \n\tfor (i = config->mc_start_offset; i < config->max_mc_addr; i++) {\n\t\tu64 tmp64;\n\t\ttmp64 = do_s2io_read_unicast_mc(sp, i);\n\t\tif (tmp64 == S2IO_DISABLE_MAC_ENTRY)  \n\t\t\tbreak;\n\n\t\tif (tmp64 == mac_addr)\n\t\t\treturn SUCCESS;\n\t}\n\tif (i == config->max_mc_addr) {\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"CAM full no space left for multicast MAC\\n\");\n\t\treturn FAILURE;\n\t}\n\t \n\tdo_s2io_copy_mac_addr(sp, i, mac_addr);\n\n\treturn do_s2io_add_mac(sp, mac_addr, i);\n}\n\n \nstatic int do_s2io_add_mac(struct s2io_nic *sp, u64 addr, int off)\n{\n\tu64 val64;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\twriteq(RMAC_ADDR_DATA0_MEM_ADDR(addr),\n\t       &bar0->rmac_addr_data0_mem);\n\n\tval64 =\tRMAC_ADDR_CMD_MEM_WE | RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |\n\t\tRMAC_ADDR_CMD_MEM_OFFSET(off);\n\twriteq(val64, &bar0->rmac_addr_cmd_mem);\n\n\t \n\tif (wait_for_cmd_complete(&bar0->rmac_addr_cmd_mem,\n\t\t\t\t  RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING,\n\t\t\t\t  S2IO_BIT_RESET, true)) {\n\t\tDBG_PRINT(INFO_DBG, \"do_s2io_add_mac failed\\n\");\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n \nstatic int do_s2io_delete_unicast_mc(struct s2io_nic *sp, u64 addr)\n{\n\tint offset;\n\tu64 dis_addr = S2IO_DISABLE_MAC_ENTRY, tmp64;\n\tstruct config_param *config = &sp->config;\n\n\tfor (offset = 1;\n\t     offset < config->max_mc_addr; offset++) {\n\t\ttmp64 = do_s2io_read_unicast_mc(sp, offset);\n\t\tif (tmp64 == addr) {\n\t\t\t \n\t\t\tif (do_s2io_add_mac(sp, dis_addr, offset) ==  FAILURE)\n\t\t\t\treturn FAILURE;\n\t\t\t \n\t\t\tdo_s2io_store_unicast_mc(sp);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\tDBG_PRINT(ERR_DBG, \"MAC address 0x%llx not found in CAM\\n\",\n\t\t  (unsigned long long)addr);\n\treturn FAILURE;\n}\n\n \nstatic u64 do_s2io_read_unicast_mc(struct s2io_nic *sp, int offset)\n{\n\tu64 tmp64, val64;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\t \n\tval64 =\tRMAC_ADDR_CMD_MEM_RD | RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |\n\t\tRMAC_ADDR_CMD_MEM_OFFSET(offset);\n\twriteq(val64, &bar0->rmac_addr_cmd_mem);\n\n\t \n\tif (wait_for_cmd_complete(&bar0->rmac_addr_cmd_mem,\n\t\t\t\t  RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING,\n\t\t\t\t  S2IO_BIT_RESET, true)) {\n\t\tDBG_PRINT(INFO_DBG, \"do_s2io_read_unicast_mc failed\\n\");\n\t\treturn FAILURE;\n\t}\n\ttmp64 = readq(&bar0->rmac_addr_data0_mem);\n\n\treturn tmp64 >> 16;\n}\n\n \n\nstatic int s2io_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\t \n\treturn do_s2io_prog_unicast(dev, dev->dev_addr);\n}\n \n\nstatic int do_s2io_prog_unicast(struct net_device *dev, const u8 *addr)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tregister u64 mac_addr, perm_addr;\n\tint i;\n\tu64 tmp64;\n\tstruct config_param *config = &sp->config;\n\n\t \n\tmac_addr = ether_addr_to_u64(addr);\n\tperm_addr = ether_addr_to_u64(sp->def_mac_addr[0].mac_addr);\n\n\t \n\tif (mac_addr == perm_addr)\n\t\treturn SUCCESS;\n\n\t \n\tfor (i = 1; i < config->max_mac_addr; i++) {\n\t\ttmp64 = do_s2io_read_unicast_mc(sp, i);\n\t\tif (tmp64 == S2IO_DISABLE_MAC_ENTRY)  \n\t\t\tbreak;\n\n\t\tif (tmp64 == mac_addr) {\n\t\t\tDBG_PRINT(INFO_DBG,\n\t\t\t\t  \"MAC addr:0x%llx already present in CAM\\n\",\n\t\t\t\t  (unsigned long long)mac_addr);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\tif (i == config->max_mac_addr) {\n\t\tDBG_PRINT(ERR_DBG, \"CAM full no space left for Unicast MAC\\n\");\n\t\treturn FAILURE;\n\t}\n\t \n\tdo_s2io_copy_mac_addr(sp, i, mac_addr);\n\n\treturn do_s2io_add_mac(sp, mac_addr, i);\n}\n\n \n\nstatic int\ns2io_ethtool_set_link_ksettings(struct net_device *dev,\n\t\t\t\tconst struct ethtool_link_ksettings *cmd)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tif ((cmd->base.autoneg == AUTONEG_ENABLE) ||\n\t    (cmd->base.speed != SPEED_10000) ||\n\t    (cmd->base.duplex != DUPLEX_FULL))\n\t\treturn -EINVAL;\n\telse {\n\t\ts2io_close(sp->dev);\n\t\ts2io_open(sp->dev);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int\ns2io_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\tstruct ethtool_link_ksettings *cmd)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10000baseT_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\n\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, 10000baseT_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);\n\n\tcmd->base.port = PORT_FIBRE;\n\n\tif (netif_carrier_ok(sp->dev)) {\n\t\tcmd->base.speed = SPEED_10000;\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\treturn 0;\n}\n\n \n\nstatic void s2io_ethtool_gdrvinfo(struct net_device *dev,\n\t\t\t\t  struct ethtool_drvinfo *info)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\tstrscpy(info->driver, s2io_driver_name, sizeof(info->driver));\n\tstrscpy(info->version, s2io_driver_version, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(sp->pdev), sizeof(info->bus_info));\n}\n\n \n\nstatic void s2io_ethtool_gregs(struct net_device *dev,\n\t\t\t       struct ethtool_regs *regs, void *space)\n{\n\tint i;\n\tu64 reg;\n\tu8 *reg_space = (u8 *)space;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\tregs->len = XENA_REG_SPACE;\n\tregs->version = sp->pdev->subsystem_device;\n\n\tfor (i = 0; i < regs->len; i += 8) {\n\t\treg = readq(sp->bar0 + i);\n\t\tmemcpy((reg_space + i), &reg, 8);\n\t}\n}\n\n \nstatic void s2io_set_led(struct s2io_nic *sp, bool on)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu16 subid = sp->pdev->subsystem_device;\n\tu64 val64;\n\n\tif ((sp->device_type == XFRAME_II_DEVICE) ||\n\t    ((subid & 0xFF) >= 0x07)) {\n\t\tval64 = readq(&bar0->gpio_control);\n\t\tif (on)\n\t\t\tval64 |= GPIO_CTRL_GPIO_0;\n\t\telse\n\t\t\tval64 &= ~GPIO_CTRL_GPIO_0;\n\n\t\twriteq(val64, &bar0->gpio_control);\n\t} else {\n\t\tval64 = readq(&bar0->adapter_control);\n\t\tif (on)\n\t\t\tval64 |= ADAPTER_LED_ON;\n\t\telse\n\t\t\tval64 &= ~ADAPTER_LED_ON;\n\n\t\twriteq(val64, &bar0->adapter_control);\n\t}\n\n}\n\n \n\nstatic int s2io_ethtool_set_led(struct net_device *dev,\n\t\t\t\tenum ethtool_phys_id_state state)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu16 subid = sp->pdev->subsystem_device;\n\n\tif ((sp->device_type == XFRAME_I_DEVICE) && ((subid & 0xFF) < 0x07)) {\n\t\tu64 val64 = readq(&bar0->adapter_control);\n\t\tif (!(val64 & ADAPTER_CNTL_EN)) {\n\t\t\tpr_err(\"Adapter Link down, cannot blink LED\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tsp->adapt_ctrl_org = readq(&bar0->gpio_control);\n\t\treturn 1;\t \n\n\tcase ETHTOOL_ID_ON:\n\t\ts2io_set_led(sp, true);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\ts2io_set_led(sp, false);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tif (CARDS_WITH_FAULTY_LINK_INDICATORS(sp->device_type, subid))\n\t\t\twriteq(sp->adapt_ctrl_org, &bar0->gpio_control);\n\t}\n\n\treturn 0;\n}\n\nstatic void\ns2io_ethtool_gringparam(struct net_device *dev,\n\t\t\tstruct ethtool_ringparam *ering,\n\t\t\tstruct kernel_ethtool_ringparam *kernel_ering,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tint i, tx_desc_count = 0, rx_desc_count = 0;\n\n\tif (sp->rxd_mode == RXD_MODE_1) {\n\t\tering->rx_max_pending = MAX_RX_DESC_1;\n\t\tering->rx_jumbo_max_pending = MAX_RX_DESC_1;\n\t} else {\n\t\tering->rx_max_pending = MAX_RX_DESC_2;\n\t\tering->rx_jumbo_max_pending = MAX_RX_DESC_2;\n\t}\n\n\tering->tx_max_pending = MAX_TX_DESC;\n\n\tfor (i = 0; i < sp->config.rx_ring_num; i++)\n\t\trx_desc_count += sp->config.rx_cfg[i].num_rxd;\n\tering->rx_pending = rx_desc_count;\n\tering->rx_jumbo_pending = rx_desc_count;\n\n\tfor (i = 0; i < sp->config.tx_fifo_num; i++)\n\t\ttx_desc_count += sp->config.tx_cfg[i].fifo_len;\n\tering->tx_pending = tx_desc_count;\n\tDBG_PRINT(INFO_DBG, \"max txds: %d\\n\", sp->config.max_txds);\n}\n\n \nstatic void s2io_ethtool_getpause_data(struct net_device *dev,\n\t\t\t\t       struct ethtool_pauseparam *ep)\n{\n\tu64 val64;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\tval64 = readq(&bar0->rmac_pause_cfg);\n\tif (val64 & RMAC_PAUSE_GEN_ENABLE)\n\t\tep->tx_pause = true;\n\tif (val64 & RMAC_PAUSE_RX_ENABLE)\n\t\tep->rx_pause = true;\n\tep->autoneg = false;\n}\n\n \n\nstatic int s2io_ethtool_setpause_data(struct net_device *dev,\n\t\t\t\t      struct ethtool_pauseparam *ep)\n{\n\tu64 val64;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\tval64 = readq(&bar0->rmac_pause_cfg);\n\tif (ep->tx_pause)\n\t\tval64 |= RMAC_PAUSE_GEN_ENABLE;\n\telse\n\t\tval64 &= ~RMAC_PAUSE_GEN_ENABLE;\n\tif (ep->rx_pause)\n\t\tval64 |= RMAC_PAUSE_RX_ENABLE;\n\telse\n\t\tval64 &= ~RMAC_PAUSE_RX_ENABLE;\n\twriteq(val64, &bar0->rmac_pause_cfg);\n\treturn 0;\n}\n\n#define S2IO_DEV_ID\t\t5\n \nstatic int read_eeprom(struct s2io_nic *sp, int off, u64 *data)\n{\n\tint ret = -1;\n\tu32 exit_cnt = 0;\n\tu64 val64;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\tif (sp->device_type == XFRAME_I_DEVICE) {\n\t\tval64 = I2C_CONTROL_DEV_ID(S2IO_DEV_ID) |\n\t\t\tI2C_CONTROL_ADDR(off) |\n\t\t\tI2C_CONTROL_BYTE_CNT(0x3) |\n\t\t\tI2C_CONTROL_READ |\n\t\t\tI2C_CONTROL_CNTL_START;\n\t\tSPECIAL_REG_WRITE(val64, &bar0->i2c_control, LF);\n\n\t\twhile (exit_cnt < 5) {\n\t\t\tval64 = readq(&bar0->i2c_control);\n\t\t\tif (I2C_CONTROL_CNTL_END(val64)) {\n\t\t\t\t*data = I2C_CONTROL_GET_DATA(val64);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(50);\n\t\t\texit_cnt++;\n\t\t}\n\t}\n\n\tif (sp->device_type == XFRAME_II_DEVICE) {\n\t\tval64 = SPI_CONTROL_KEY(0x9) | SPI_CONTROL_SEL1 |\n\t\t\tSPI_CONTROL_BYTECNT(0x3) |\n\t\t\tSPI_CONTROL_CMD(0x3) | SPI_CONTROL_ADDR(off);\n\t\tSPECIAL_REG_WRITE(val64, &bar0->spi_control, LF);\n\t\tval64 |= SPI_CONTROL_REQ;\n\t\tSPECIAL_REG_WRITE(val64, &bar0->spi_control, LF);\n\t\twhile (exit_cnt < 5) {\n\t\t\tval64 = readq(&bar0->spi_control);\n\t\t\tif (val64 & SPI_CONTROL_NACK) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t} else if (val64 & SPI_CONTROL_DONE) {\n\t\t\t\t*data = readq(&bar0->spi_data);\n\t\t\t\t*data &= 0xffffff;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(50);\n\t\t\texit_cnt++;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \n\nstatic int write_eeprom(struct s2io_nic *sp, int off, u64 data, int cnt)\n{\n\tint exit_cnt = 0, ret = -1;\n\tu64 val64;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\n\tif (sp->device_type == XFRAME_I_DEVICE) {\n\t\tval64 = I2C_CONTROL_DEV_ID(S2IO_DEV_ID) |\n\t\t\tI2C_CONTROL_ADDR(off) |\n\t\t\tI2C_CONTROL_BYTE_CNT(cnt) |\n\t\t\tI2C_CONTROL_SET_DATA((u32)data) |\n\t\t\tI2C_CONTROL_CNTL_START;\n\t\tSPECIAL_REG_WRITE(val64, &bar0->i2c_control, LF);\n\n\t\twhile (exit_cnt < 5) {\n\t\t\tval64 = readq(&bar0->i2c_control);\n\t\t\tif (I2C_CONTROL_CNTL_END(val64)) {\n\t\t\t\tif (!(val64 & I2C_CONTROL_NACK))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(50);\n\t\t\texit_cnt++;\n\t\t}\n\t}\n\n\tif (sp->device_type == XFRAME_II_DEVICE) {\n\t\tint write_cnt = (cnt == 8) ? 0 : cnt;\n\t\twriteq(SPI_DATA_WRITE(data, (cnt << 3)), &bar0->spi_data);\n\n\t\tval64 = SPI_CONTROL_KEY(0x9) | SPI_CONTROL_SEL1 |\n\t\t\tSPI_CONTROL_BYTECNT(write_cnt) |\n\t\t\tSPI_CONTROL_CMD(0x2) | SPI_CONTROL_ADDR(off);\n\t\tSPECIAL_REG_WRITE(val64, &bar0->spi_control, LF);\n\t\tval64 |= SPI_CONTROL_REQ;\n\t\tSPECIAL_REG_WRITE(val64, &bar0->spi_control, LF);\n\t\twhile (exit_cnt < 5) {\n\t\t\tval64 = readq(&bar0->spi_control);\n\t\t\tif (val64 & SPI_CONTROL_NACK) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t} else if (val64 & SPI_CONTROL_DONE) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(50);\n\t\t\texit_cnt++;\n\t\t}\n\t}\n\treturn ret;\n}\nstatic void s2io_vpd_read(struct s2io_nic *nic)\n{\n\tu8 *vpd_data;\n\tu8 data;\n\tint i = 0, cnt, len, fail = 0;\n\tint vpd_addr = 0x80;\n\tstruct swStat *swstats = &nic->mac_control.stats_info->sw_stat;\n\n\tif (nic->device_type == XFRAME_II_DEVICE) {\n\t\tstrcpy(nic->product_name, \"Xframe II 10GbE network adapter\");\n\t\tvpd_addr = 0x80;\n\t} else {\n\t\tstrcpy(nic->product_name, \"Xframe I 10GbE network adapter\");\n\t\tvpd_addr = 0x50;\n\t}\n\tstrcpy(nic->serial_num, \"NOT AVAILABLE\");\n\n\tvpd_data = kmalloc(256, GFP_KERNEL);\n\tif (!vpd_data) {\n\t\tswstats->mem_alloc_fail_cnt++;\n\t\treturn;\n\t}\n\tswstats->mem_allocated += 256;\n\n\tfor (i = 0; i < 256; i += 4) {\n\t\tpci_write_config_byte(nic->pdev, (vpd_addr + 2), i);\n\t\tpci_read_config_byte(nic->pdev,  (vpd_addr + 2), &data);\n\t\tpci_write_config_byte(nic->pdev, (vpd_addr + 3), 0);\n\t\tfor (cnt = 0; cnt < 5; cnt++) {\n\t\t\tmsleep(2);\n\t\t\tpci_read_config_byte(nic->pdev, (vpd_addr + 3), &data);\n\t\t\tif (data == 0x80)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (cnt >= 5) {\n\t\t\tDBG_PRINT(ERR_DBG, \"Read of VPD data failed\\n\");\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t\tpci_read_config_dword(nic->pdev,  (vpd_addr + 4),\n\t\t\t\t      (u32 *)&vpd_data[i]);\n\t}\n\n\tif (!fail) {\n\t\t \n\t\tfor (cnt = 0; cnt < 252; cnt++) {\n\t\t\tif ((vpd_data[cnt] == 'S') &&\n\t\t\t    (vpd_data[cnt+1] == 'N')) {\n\t\t\t\tlen = vpd_data[cnt+2];\n\t\t\t\tif (len < min(VPD_STRING_LEN, 256-cnt-2)) {\n\t\t\t\t\tmemcpy(nic->serial_num,\n\t\t\t\t\t       &vpd_data[cnt + 3],\n\t\t\t\t\t       len);\n\t\t\t\t\tmemset(nic->serial_num+len,\n\t\t\t\t\t       0,\n\t\t\t\t\t       VPD_STRING_LEN-len);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((!fail) && (vpd_data[1] < VPD_STRING_LEN)) {\n\t\tlen = vpd_data[1];\n\t\tmemcpy(nic->product_name, &vpd_data[3], len);\n\t\tnic->product_name[len] = 0;\n\t}\n\tkfree(vpd_data);\n\tswstats->mem_freed += 256;\n}\n\n \n\nstatic int s2io_ethtool_geeprom(struct net_device *dev,\n\t\t\t\tstruct ethtool_eeprom *eeprom, u8 * data_buf)\n{\n\tu32 i, valid;\n\tu64 data;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\teeprom->magic = sp->pdev->vendor | (sp->pdev->device << 16);\n\n\tif ((eeprom->offset + eeprom->len) > (XENA_EEPROM_SPACE))\n\t\teeprom->len = XENA_EEPROM_SPACE - eeprom->offset;\n\n\tfor (i = 0; i < eeprom->len; i += 4) {\n\t\tif (read_eeprom(sp, (eeprom->offset + i), &data)) {\n\t\t\tDBG_PRINT(ERR_DBG, \"Read of EEPROM failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tvalid = INV(data);\n\t\tmemcpy((data_buf + i), &valid, 4);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int s2io_ethtool_seeprom(struct net_device *dev,\n\t\t\t\tstruct ethtool_eeprom *eeprom,\n\t\t\t\tu8 *data_buf)\n{\n\tint len = eeprom->len, cnt = 0;\n\tu64 valid = 0, data;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\tif (eeprom->magic != (sp->pdev->vendor | (sp->pdev->device << 16))) {\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"ETHTOOL_WRITE_EEPROM Err: \"\n\t\t\t  \"Magic value is wrong, it is 0x%x should be 0x%x\\n\",\n\t\t\t  (sp->pdev->vendor | (sp->pdev->device << 16)),\n\t\t\t  eeprom->magic);\n\t\treturn -EFAULT;\n\t}\n\n\twhile (len) {\n\t\tdata = (u32)data_buf[cnt] & 0x000000FF;\n\t\tif (data)\n\t\t\tvalid = (u32)(data << 24);\n\t\telse\n\t\t\tvalid = data;\n\n\t\tif (write_eeprom(sp, (eeprom->offset + cnt), valid, 0)) {\n\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t  \"ETHTOOL_WRITE_EEPROM Err: \"\n\t\t\t\t  \"Cannot write into the specified offset\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tcnt++;\n\t\tlen--;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int s2io_register_test(struct s2io_nic *sp, uint64_t *data)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64 = 0, exp_val;\n\tint fail = 0;\n\n\tval64 = readq(&bar0->pif_rd_swapper_fb);\n\tif (val64 != 0x123456789abcdefULL) {\n\t\tfail = 1;\n\t\tDBG_PRINT(INFO_DBG, \"Read Test level %d fails\\n\", 1);\n\t}\n\n\tval64 = readq(&bar0->rmac_pause_cfg);\n\tif (val64 != 0xc000ffff00000000ULL) {\n\t\tfail = 1;\n\t\tDBG_PRINT(INFO_DBG, \"Read Test level %d fails\\n\", 2);\n\t}\n\n\tval64 = readq(&bar0->rx_queue_cfg);\n\tif (sp->device_type == XFRAME_II_DEVICE)\n\t\texp_val = 0x0404040404040404ULL;\n\telse\n\t\texp_val = 0x0808080808080808ULL;\n\tif (val64 != exp_val) {\n\t\tfail = 1;\n\t\tDBG_PRINT(INFO_DBG, \"Read Test level %d fails\\n\", 3);\n\t}\n\n\tval64 = readq(&bar0->xgxs_efifo_cfg);\n\tif (val64 != 0x000000001923141EULL) {\n\t\tfail = 1;\n\t\tDBG_PRINT(INFO_DBG, \"Read Test level %d fails\\n\", 4);\n\t}\n\n\tval64 = 0x5A5A5A5A5A5A5A5AULL;\n\twriteq(val64, &bar0->xmsi_data);\n\tval64 = readq(&bar0->xmsi_data);\n\tif (val64 != 0x5A5A5A5A5A5A5A5AULL) {\n\t\tfail = 1;\n\t\tDBG_PRINT(ERR_DBG, \"Write Test level %d fails\\n\", 1);\n\t}\n\n\tval64 = 0xA5A5A5A5A5A5A5A5ULL;\n\twriteq(val64, &bar0->xmsi_data);\n\tval64 = readq(&bar0->xmsi_data);\n\tif (val64 != 0xA5A5A5A5A5A5A5A5ULL) {\n\t\tfail = 1;\n\t\tDBG_PRINT(ERR_DBG, \"Write Test level %d fails\\n\", 2);\n\t}\n\n\t*data = fail;\n\treturn fail;\n}\n\n \n\nstatic int s2io_eeprom_test(struct s2io_nic *sp, uint64_t *data)\n{\n\tint fail = 0;\n\tu64 ret_data, org_4F0, org_7F0;\n\tu8 saved_4F0 = 0, saved_7F0 = 0;\n\tstruct net_device *dev = sp->dev;\n\n\t \n\t \n\tif (sp->device_type == XFRAME_I_DEVICE)\n\t\tif (!write_eeprom(sp, 0, 0, 3))\n\t\t\tfail = 1;\n\n\t \n\tif (!read_eeprom(sp, 0x4F0, &org_4F0))\n\t\tsaved_4F0 = 1;\n\tif (!read_eeprom(sp, 0x7F0, &org_7F0))\n\t\tsaved_7F0 = 1;\n\n\t \n\tif (write_eeprom(sp, 0x4F0, 0x012345, 3))\n\t\tfail = 1;\n\tif (read_eeprom(sp, 0x4F0, &ret_data))\n\t\tfail = 1;\n\n\tif (ret_data != 0x012345) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: eeprom test error at offset 0x4F0. \"\n\t\t\t  \"Data written %llx Data read %llx\\n\",\n\t\t\t  dev->name, (unsigned long long)0x12345,\n\t\t\t  (unsigned long long)ret_data);\n\t\tfail = 1;\n\t}\n\n\t \n\twrite_eeprom(sp, 0x4F0, 0xFFFFFF, 3);\n\n\t \n\tif (sp->device_type == XFRAME_I_DEVICE)\n\t\tif (!write_eeprom(sp, 0x07C, 0, 3))\n\t\t\tfail = 1;\n\n\t \n\tif (write_eeprom(sp, 0x7F0, 0x012345, 3))\n\t\tfail = 1;\n\tif (read_eeprom(sp, 0x7F0, &ret_data))\n\t\tfail = 1;\n\n\tif (ret_data != 0x012345) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: eeprom test error at offset 0x7F0. \"\n\t\t\t  \"Data written %llx Data read %llx\\n\",\n\t\t\t  dev->name, (unsigned long long)0x12345,\n\t\t\t  (unsigned long long)ret_data);\n\t\tfail = 1;\n\t}\n\n\t \n\twrite_eeprom(sp, 0x7F0, 0xFFFFFF, 3);\n\n\tif (sp->device_type == XFRAME_I_DEVICE) {\n\t\t \n\t\tif (!write_eeprom(sp, 0x080, 0, 3))\n\t\t\tfail = 1;\n\n\t\t \n\t\tif (!write_eeprom(sp, 0x0FC, 0, 3))\n\t\t\tfail = 1;\n\n\t\t \n\t\tif (!write_eeprom(sp, 0x100, 0, 3))\n\t\t\tfail = 1;\n\n\t\t \n\t\tif (!write_eeprom(sp, 0x4EC, 0, 3))\n\t\t\tfail = 1;\n\t}\n\n\t \n\tif (saved_4F0)\n\t\twrite_eeprom(sp, 0x4F0, org_4F0, 3);\n\tif (saved_7F0)\n\t\twrite_eeprom(sp, 0x7F0, org_7F0, 3);\n\n\t*data = fail;\n\treturn fail;\n}\n\n \n\nstatic int s2io_bist_test(struct s2io_nic *sp, uint64_t *data)\n{\n\tu8 bist = 0;\n\tint cnt = 0, ret = -1;\n\n\tpci_read_config_byte(sp->pdev, PCI_BIST, &bist);\n\tbist |= PCI_BIST_START;\n\tpci_write_config_word(sp->pdev, PCI_BIST, bist);\n\n\twhile (cnt < 20) {\n\t\tpci_read_config_byte(sp->pdev, PCI_BIST, &bist);\n\t\tif (!(bist & PCI_BIST_START)) {\n\t\t\t*data = (bist & PCI_BIST_CODE_MASK);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(100);\n\t\tcnt++;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int s2io_link_test(struct s2io_nic *sp, uint64_t *data)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64;\n\n\tval64 = readq(&bar0->adapter_status);\n\tif (!(LINK_IS_UP(val64)))\n\t\t*data = 1;\n\telse\n\t\t*data = 0;\n\n\treturn *data;\n}\n\n \n\nstatic int s2io_rldram_test(struct s2io_nic *sp, uint64_t *data)\n{\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tu64 val64;\n\tint cnt, iteration = 0, test_fail = 0;\n\n\tval64 = readq(&bar0->adapter_control);\n\tval64 &= ~ADAPTER_ECC_EN;\n\twriteq(val64, &bar0->adapter_control);\n\n\tval64 = readq(&bar0->mc_rldram_test_ctrl);\n\tval64 |= MC_RLDRAM_TEST_MODE;\n\tSPECIAL_REG_WRITE(val64, &bar0->mc_rldram_test_ctrl, LF);\n\n\tval64 = readq(&bar0->mc_rldram_mrs);\n\tval64 |= MC_RLDRAM_QUEUE_SIZE_ENABLE;\n\tSPECIAL_REG_WRITE(val64, &bar0->mc_rldram_mrs, UF);\n\n\tval64 |= MC_RLDRAM_MRS_ENABLE;\n\tSPECIAL_REG_WRITE(val64, &bar0->mc_rldram_mrs, UF);\n\n\twhile (iteration < 2) {\n\t\tval64 = 0x55555555aaaa0000ULL;\n\t\tif (iteration == 1)\n\t\t\tval64 ^= 0xFFFFFFFFFFFF0000ULL;\n\t\twriteq(val64, &bar0->mc_rldram_test_d0);\n\n\t\tval64 = 0xaaaa5a5555550000ULL;\n\t\tif (iteration == 1)\n\t\t\tval64 ^= 0xFFFFFFFFFFFF0000ULL;\n\t\twriteq(val64, &bar0->mc_rldram_test_d1);\n\n\t\tval64 = 0x55aaaaaaaa5a0000ULL;\n\t\tif (iteration == 1)\n\t\t\tval64 ^= 0xFFFFFFFFFFFF0000ULL;\n\t\twriteq(val64, &bar0->mc_rldram_test_d2);\n\n\t\tval64 = (u64) (0x0000003ffffe0100ULL);\n\t\twriteq(val64, &bar0->mc_rldram_test_add);\n\n\t\tval64 = MC_RLDRAM_TEST_MODE |\n\t\t\tMC_RLDRAM_TEST_WRITE |\n\t\t\tMC_RLDRAM_TEST_GO;\n\t\tSPECIAL_REG_WRITE(val64, &bar0->mc_rldram_test_ctrl, LF);\n\n\t\tfor (cnt = 0; cnt < 5; cnt++) {\n\t\t\tval64 = readq(&bar0->mc_rldram_test_ctrl);\n\t\t\tif (val64 & MC_RLDRAM_TEST_DONE)\n\t\t\t\tbreak;\n\t\t\tmsleep(200);\n\t\t}\n\n\t\tif (cnt == 5)\n\t\t\tbreak;\n\n\t\tval64 = MC_RLDRAM_TEST_MODE | MC_RLDRAM_TEST_GO;\n\t\tSPECIAL_REG_WRITE(val64, &bar0->mc_rldram_test_ctrl, LF);\n\n\t\tfor (cnt = 0; cnt < 5; cnt++) {\n\t\t\tval64 = readq(&bar0->mc_rldram_test_ctrl);\n\t\t\tif (val64 & MC_RLDRAM_TEST_DONE)\n\t\t\t\tbreak;\n\t\t\tmsleep(500);\n\t\t}\n\n\t\tif (cnt == 5)\n\t\t\tbreak;\n\n\t\tval64 = readq(&bar0->mc_rldram_test_ctrl);\n\t\tif (!(val64 & MC_RLDRAM_TEST_PASS))\n\t\t\ttest_fail = 1;\n\n\t\titeration++;\n\t}\n\n\t*data = test_fail;\n\n\t \n\tSPECIAL_REG_WRITE(0, &bar0->mc_rldram_test_ctrl, LF);\n\n\treturn test_fail;\n}\n\n \n\nstatic void s2io_ethtool_test(struct net_device *dev,\n\t\t\t      struct ethtool_test *ethtest,\n\t\t\t      uint64_t *data)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tint orig_state = netif_running(sp->dev);\n\n\tif (ethtest->flags == ETH_TEST_FL_OFFLINE) {\n\t\t \n\t\tif (orig_state)\n\t\t\ts2io_close(sp->dev);\n\n\t\tif (s2io_register_test(sp, &data[0]))\n\t\t\tethtest->flags |= ETH_TEST_FL_FAILED;\n\n\t\ts2io_reset(sp);\n\n\t\tif (s2io_rldram_test(sp, &data[3]))\n\t\t\tethtest->flags |= ETH_TEST_FL_FAILED;\n\n\t\ts2io_reset(sp);\n\n\t\tif (s2io_eeprom_test(sp, &data[1]))\n\t\t\tethtest->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (s2io_bist_test(sp, &data[4]))\n\t\t\tethtest->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (orig_state)\n\t\t\ts2io_open(sp->dev);\n\n\t\tdata[2] = 0;\n\t} else {\n\t\t \n\t\tif (!orig_state) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: is not up, cannot run test\\n\",\n\t\t\t\t  dev->name);\n\t\t\tdata[0] = -1;\n\t\t\tdata[1] = -1;\n\t\t\tdata[2] = -1;\n\t\t\tdata[3] = -1;\n\t\t\tdata[4] = -1;\n\t\t}\n\n\t\tif (s2io_link_test(sp, &data[2]))\n\t\t\tethtest->flags |= ETH_TEST_FL_FAILED;\n\n\t\tdata[0] = 0;\n\t\tdata[1] = 0;\n\t\tdata[3] = 0;\n\t\tdata[4] = 0;\n\t}\n}\n\nstatic void s2io_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *estats,\n\t\t\t\t   u64 *tmp_stats)\n{\n\tint i = 0, k;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct stat_block *stats = sp->mac_control.stats_info;\n\tstruct swStat *swstats = &stats->sw_stat;\n\tstruct xpakStat *xstats = &stats->xpak_stat;\n\n\ts2io_updt_stats(sp);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_frms_oflow) << 32  |\n\t\tle32_to_cpu(stats->tmac_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_data_octets_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_data_octets);\n\ttmp_stats[i++] = le64_to_cpu(stats->tmac_drop_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_mcst_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_mcst_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_bcst_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_bcst_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->tmac_pause_ctrl_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_ttl_octets_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_ttl_octets);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_ucst_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_ucst_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_nucst_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_nucst_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_any_err_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_any_err_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->tmac_ttl_less_fb_octets);\n\ttmp_stats[i++] = le64_to_cpu(stats->tmac_vld_ip_octets);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_vld_ip_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_vld_ip);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_drop_ip_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_drop_ip);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_icmp_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_icmp);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->tmac_rst_tcp_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_rst_tcp);\n\ttmp_stats[i++] = le64_to_cpu(stats->tmac_tcp);\n\ttmp_stats[i++] = (u64)le32_to_cpu(stats->tmac_udp_oflow) << 32 |\n\t\tle32_to_cpu(stats->tmac_udp);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_vld_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_vld_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_data_octets_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_data_octets);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_fcs_err_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_drop_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_vld_mcst_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_vld_mcst_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_vld_bcst_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_vld_bcst_frms);\n\ttmp_stats[i++] = le32_to_cpu(stats->rmac_in_rng_len_err_frms);\n\ttmp_stats[i++] = le32_to_cpu(stats->rmac_out_rng_len_err_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_long_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_pause_ctrl_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_unsup_ctrl_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_ttl_octets_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_ttl_octets);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_accepted_ucst_frms_oflow) << 32\n\t\t| le32_to_cpu(stats->rmac_accepted_ucst_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_accepted_nucst_frms_oflow)\n\t\t<< 32 | le32_to_cpu(stats->rmac_accepted_nucst_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_discarded_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_discarded_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_drop_events_oflow)\n\t\t<< 32 | le32_to_cpu(stats->rmac_drop_events);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_less_fb_octets);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_usized_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_usized_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_osized_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_osized_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_frag_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_frag_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_jabber_frms_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_jabber_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_64_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_65_127_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_128_255_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_256_511_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_512_1023_frms);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_1024_1518_frms);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_ip_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_ip);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ip_octets);\n\ttmp_stats[i++] = le32_to_cpu(stats->rmac_hdr_err_ip);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_drop_ip_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_drop_ip);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_icmp_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_icmp);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_tcp);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_udp_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_udp);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_err_drp_udp_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_err_drp_udp);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_xgmii_err_sym);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q0);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q1);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q2);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q3);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q4);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q5);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q6);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_frms_q7);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q0);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q1);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q2);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q3);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q4);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q5);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q6);\n\ttmp_stats[i++] = le16_to_cpu(stats->rmac_full_q7);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_pause_cnt_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_pause_cnt);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_xgmii_data_err_cnt);\n\ttmp_stats[i++] = le64_to_cpu(stats->rmac_xgmii_ctrl_err_cnt);\n\ttmp_stats[i++] =\n\t\t(u64)le32_to_cpu(stats->rmac_accepted_ip_oflow) << 32 |\n\t\tle32_to_cpu(stats->rmac_accepted_ip);\n\ttmp_stats[i++] = le32_to_cpu(stats->rmac_err_tcp);\n\ttmp_stats[i++] = le32_to_cpu(stats->rd_req_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->new_rd_req_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->new_rd_req_rtry_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->rd_rtry_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->wr_rtry_rd_ack_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->wr_req_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->new_wr_req_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->new_wr_req_rtry_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->wr_rtry_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->wr_disc_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->rd_rtry_wr_ack_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->txp_wr_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->txd_rd_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->txd_wr_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->rxd_rd_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->rxd_wr_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->txf_rd_cnt);\n\ttmp_stats[i++] = le32_to_cpu(stats->rxf_wr_cnt);\n\n\t \n\tif (sp->device_type == XFRAME_II_DEVICE) {\n\t\ttmp_stats[i++] =\n\t\t\tle64_to_cpu(stats->rmac_ttl_1519_4095_frms);\n\t\ttmp_stats[i++] =\n\t\t\tle64_to_cpu(stats->rmac_ttl_4096_8191_frms);\n\t\ttmp_stats[i++] =\n\t\t\tle64_to_cpu(stats->rmac_ttl_8192_max_frms);\n\t\ttmp_stats[i++] = le64_to_cpu(stats->rmac_ttl_gt_max_frms);\n\t\ttmp_stats[i++] = le64_to_cpu(stats->rmac_osized_alt_frms);\n\t\ttmp_stats[i++] = le64_to_cpu(stats->rmac_jabber_alt_frms);\n\t\ttmp_stats[i++] = le64_to_cpu(stats->rmac_gt_max_alt_frms);\n\t\ttmp_stats[i++] = le64_to_cpu(stats->rmac_vlan_frms);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->rmac_len_discard);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->rmac_fcs_discard);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->rmac_pf_discard);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->rmac_da_discard);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->rmac_red_discard);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->rmac_rts_discard);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->rmac_ingm_full_discard);\n\t\ttmp_stats[i++] = le32_to_cpu(stats->link_fault_cnt);\n\t}\n\n\ttmp_stats[i++] = 0;\n\ttmp_stats[i++] = swstats->single_ecc_errs;\n\ttmp_stats[i++] = swstats->double_ecc_errs;\n\ttmp_stats[i++] = swstats->parity_err_cnt;\n\ttmp_stats[i++] = swstats->serious_err_cnt;\n\ttmp_stats[i++] = swstats->soft_reset_cnt;\n\ttmp_stats[i++] = swstats->fifo_full_cnt;\n\tfor (k = 0; k < MAX_RX_RINGS; k++)\n\t\ttmp_stats[i++] = swstats->ring_full_cnt[k];\n\ttmp_stats[i++] = xstats->alarm_transceiver_temp_high;\n\ttmp_stats[i++] = xstats->alarm_transceiver_temp_low;\n\ttmp_stats[i++] = xstats->alarm_laser_bias_current_high;\n\ttmp_stats[i++] = xstats->alarm_laser_bias_current_low;\n\ttmp_stats[i++] = xstats->alarm_laser_output_power_high;\n\ttmp_stats[i++] = xstats->alarm_laser_output_power_low;\n\ttmp_stats[i++] = xstats->warn_transceiver_temp_high;\n\ttmp_stats[i++] = xstats->warn_transceiver_temp_low;\n\ttmp_stats[i++] = xstats->warn_laser_bias_current_high;\n\ttmp_stats[i++] = xstats->warn_laser_bias_current_low;\n\ttmp_stats[i++] = xstats->warn_laser_output_power_high;\n\ttmp_stats[i++] = xstats->warn_laser_output_power_low;\n\ttmp_stats[i++] = swstats->clubbed_frms_cnt;\n\ttmp_stats[i++] = swstats->sending_both;\n\ttmp_stats[i++] = swstats->outof_sequence_pkts;\n\ttmp_stats[i++] = swstats->flush_max_pkts;\n\tif (swstats->num_aggregations) {\n\t\tu64 tmp = swstats->sum_avg_pkts_aggregated;\n\t\tint count = 0;\n\t\t \n\t\twhile (tmp >= swstats->num_aggregations) {\n\t\t\ttmp -= swstats->num_aggregations;\n\t\t\tcount++;\n\t\t}\n\t\ttmp_stats[i++] = count;\n\t} else\n\t\ttmp_stats[i++] = 0;\n\ttmp_stats[i++] = swstats->mem_alloc_fail_cnt;\n\ttmp_stats[i++] = swstats->pci_map_fail_cnt;\n\ttmp_stats[i++] = swstats->watchdog_timer_cnt;\n\ttmp_stats[i++] = swstats->mem_allocated;\n\ttmp_stats[i++] = swstats->mem_freed;\n\ttmp_stats[i++] = swstats->link_up_cnt;\n\ttmp_stats[i++] = swstats->link_down_cnt;\n\ttmp_stats[i++] = swstats->link_up_time;\n\ttmp_stats[i++] = swstats->link_down_time;\n\n\ttmp_stats[i++] = swstats->tx_buf_abort_cnt;\n\ttmp_stats[i++] = swstats->tx_desc_abort_cnt;\n\ttmp_stats[i++] = swstats->tx_parity_err_cnt;\n\ttmp_stats[i++] = swstats->tx_link_loss_cnt;\n\ttmp_stats[i++] = swstats->tx_list_proc_err_cnt;\n\n\ttmp_stats[i++] = swstats->rx_parity_err_cnt;\n\ttmp_stats[i++] = swstats->rx_abort_cnt;\n\ttmp_stats[i++] = swstats->rx_parity_abort_cnt;\n\ttmp_stats[i++] = swstats->rx_rda_fail_cnt;\n\ttmp_stats[i++] = swstats->rx_unkn_prot_cnt;\n\ttmp_stats[i++] = swstats->rx_fcs_err_cnt;\n\ttmp_stats[i++] = swstats->rx_buf_size_err_cnt;\n\ttmp_stats[i++] = swstats->rx_rxd_corrupt_cnt;\n\ttmp_stats[i++] = swstats->rx_unkn_err_cnt;\n\ttmp_stats[i++] = swstats->tda_err_cnt;\n\ttmp_stats[i++] = swstats->pfc_err_cnt;\n\ttmp_stats[i++] = swstats->pcc_err_cnt;\n\ttmp_stats[i++] = swstats->tti_err_cnt;\n\ttmp_stats[i++] = swstats->tpa_err_cnt;\n\ttmp_stats[i++] = swstats->sm_err_cnt;\n\ttmp_stats[i++] = swstats->lso_err_cnt;\n\ttmp_stats[i++] = swstats->mac_tmac_err_cnt;\n\ttmp_stats[i++] = swstats->mac_rmac_err_cnt;\n\ttmp_stats[i++] = swstats->xgxs_txgxs_err_cnt;\n\ttmp_stats[i++] = swstats->xgxs_rxgxs_err_cnt;\n\ttmp_stats[i++] = swstats->rc_err_cnt;\n\ttmp_stats[i++] = swstats->prc_pcix_err_cnt;\n\ttmp_stats[i++] = swstats->rpa_err_cnt;\n\ttmp_stats[i++] = swstats->rda_err_cnt;\n\ttmp_stats[i++] = swstats->rti_err_cnt;\n\ttmp_stats[i++] = swstats->mc_err_cnt;\n}\n\nstatic int s2io_ethtool_get_regs_len(struct net_device *dev)\n{\n\treturn XENA_REG_SPACE;\n}\n\n\nstatic int s2io_get_eeprom_len(struct net_device *dev)\n{\n\treturn XENA_EEPROM_SPACE;\n}\n\nstatic int s2io_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn S2IO_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\tswitch (sp->device_type) {\n\t\tcase XFRAME_I_DEVICE:\n\t\t\treturn XFRAME_I_STAT_LEN;\n\t\tcase XFRAME_II_DEVICE:\n\t\t\treturn XFRAME_II_STAT_LEN;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void s2io_ethtool_get_strings(struct net_device *dev,\n\t\t\t\t     u32 stringset, u8 *data)\n{\n\tint stat_size = 0;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, s2io_gstrings, S2IO_STRINGS_LEN);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tstat_size = sizeof(ethtool_xena_stats_keys);\n\t\tmemcpy(data, &ethtool_xena_stats_keys, stat_size);\n\t\tif (sp->device_type == XFRAME_II_DEVICE) {\n\t\t\tmemcpy(data + stat_size,\n\t\t\t       &ethtool_enhanced_stats_keys,\n\t\t\t       sizeof(ethtool_enhanced_stats_keys));\n\t\t\tstat_size += sizeof(ethtool_enhanced_stats_keys);\n\t\t}\n\n\t\tmemcpy(data + stat_size, &ethtool_driver_stats_keys,\n\t\t       sizeof(ethtool_driver_stats_keys));\n\t}\n}\n\nstatic int s2io_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tnetdev_features_t changed = (features ^ dev->features) & NETIF_F_LRO;\n\n\tif (changed && netif_running(dev)) {\n\t\tint rc;\n\n\t\ts2io_stop_all_tx_queue(sp);\n\t\ts2io_card_down(sp);\n\t\tdev->features = features;\n\t\trc = s2io_card_up(sp);\n\t\tif (rc)\n\t\t\ts2io_reset(sp);\n\t\telse\n\t\t\ts2io_start_all_tx_queue(sp);\n\n\t\treturn rc ? rc : 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo = s2io_ethtool_gdrvinfo,\n\t.get_regs_len = s2io_ethtool_get_regs_len,\n\t.get_regs = s2io_ethtool_gregs,\n\t.get_link = ethtool_op_get_link,\n\t.get_eeprom_len = s2io_get_eeprom_len,\n\t.get_eeprom = s2io_ethtool_geeprom,\n\t.set_eeprom = s2io_ethtool_seeprom,\n\t.get_ringparam = s2io_ethtool_gringparam,\n\t.get_pauseparam = s2io_ethtool_getpause_data,\n\t.set_pauseparam = s2io_ethtool_setpause_data,\n\t.self_test = s2io_ethtool_test,\n\t.get_strings = s2io_ethtool_get_strings,\n\t.set_phys_id = s2io_ethtool_set_led,\n\t.get_ethtool_stats = s2io_get_ethtool_stats,\n\t.get_sset_count = s2io_get_sset_count,\n\t.get_link_ksettings = s2io_ethtool_get_link_ksettings,\n\t.set_link_ksettings = s2io_ethtool_set_link_ksettings,\n};\n\n \n\nstatic int s2io_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic int s2io_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tint ret = 0;\n\n\tdev->mtu = new_mtu;\n\tif (netif_running(dev)) {\n\t\ts2io_stop_all_tx_queue(sp);\n\t\ts2io_card_down(sp);\n\t\tret = s2io_card_up(sp);\n\t\tif (ret) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Device bring up failed\\n\",\n\t\t\t\t  __func__);\n\t\t\treturn ret;\n\t\t}\n\t\ts2io_wake_all_tx_queue(sp);\n\t} else {  \n\t\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\t\tu64 val64 = new_mtu;\n\n\t\twriteq(vBIT(val64, 2, 14), &bar0->rmac_max_pyld_len);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic void s2io_set_link(struct work_struct *work)\n{\n\tstruct s2io_nic *nic = container_of(work, struct s2io_nic,\n\t\t\t\t\t    set_link_task);\n\tstruct net_device *dev = nic->dev;\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 val64;\n\tu16 subid;\n\n\trtnl_lock();\n\n\tif (!netif_running(dev))\n\t\tgoto out_unlock;\n\n\tif (test_and_set_bit(__S2IO_STATE_LINK_TASK, &(nic->state))) {\n\t\t \n\t\tgoto out_unlock;\n\t}\n\n\tsubid = nic->pdev->subsystem_device;\n\tif (s2io_link_fault_indication(nic) == MAC_RMAC_ERR_TIMER) {\n\t\t \n\t\tmsleep(100);\n\t}\n\n\tval64 = readq(&bar0->adapter_status);\n\tif (LINK_IS_UP(val64)) {\n\t\tif (!(readq(&bar0->adapter_control) & ADAPTER_CNTL_EN)) {\n\t\t\tif (verify_xena_quiescence(nic)) {\n\t\t\t\tval64 = readq(&bar0->adapter_control);\n\t\t\t\tval64 |= ADAPTER_CNTL_EN;\n\t\t\t\twriteq(val64, &bar0->adapter_control);\n\t\t\t\tif (CARDS_WITH_FAULTY_LINK_INDICATORS(\n\t\t\t\t\t    nic->device_type, subid)) {\n\t\t\t\t\tval64 = readq(&bar0->gpio_control);\n\t\t\t\t\tval64 |= GPIO_CTRL_GPIO_0;\n\t\t\t\t\twriteq(val64, &bar0->gpio_control);\n\t\t\t\t\tval64 = readq(&bar0->gpio_control);\n\t\t\t\t} else {\n\t\t\t\t\tval64 |= ADAPTER_LED_ON;\n\t\t\t\t\twriteq(val64, &bar0->adapter_control);\n\t\t\t\t}\n\t\t\t\tnic->device_enabled_once = true;\n\t\t\t} else {\n\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t  \"%s: Error: device is not Quiescent\\n\",\n\t\t\t\t\t  dev->name);\n\t\t\t\ts2io_stop_all_tx_queue(nic);\n\t\t\t}\n\t\t}\n\t\tval64 = readq(&bar0->adapter_control);\n\t\tval64 |= ADAPTER_LED_ON;\n\t\twriteq(val64, &bar0->adapter_control);\n\t\ts2io_link(nic, LINK_UP);\n\t} else {\n\t\tif (CARDS_WITH_FAULTY_LINK_INDICATORS(nic->device_type,\n\t\t\t\t\t\t      subid)) {\n\t\t\tval64 = readq(&bar0->gpio_control);\n\t\t\tval64 &= ~GPIO_CTRL_GPIO_0;\n\t\t\twriteq(val64, &bar0->gpio_control);\n\t\t\tval64 = readq(&bar0->gpio_control);\n\t\t}\n\t\t \n\t\tval64 = readq(&bar0->adapter_control);\n\t\tval64 = val64 & (~ADAPTER_LED_ON);\n\t\twriteq(val64, &bar0->adapter_control);\n\t\ts2io_link(nic, LINK_DOWN);\n\t}\n\tclear_bit(__S2IO_STATE_LINK_TASK, &(nic->state));\n\nout_unlock:\n\trtnl_unlock();\n}\n\nstatic int set_rxd_buffer_pointer(struct s2io_nic *sp, struct RxD_t *rxdp,\n\t\t\t\t  struct buffAdd *ba,\n\t\t\t\t  struct sk_buff **skb, u64 *temp0, u64 *temp1,\n\t\t\t\t  u64 *temp2, int size)\n{\n\tstruct net_device *dev = sp->dev;\n\tstruct swStat *stats = &sp->mac_control.stats_info->sw_stat;\n\n\tif ((sp->rxd_mode == RXD_MODE_1) && (rxdp->Host_Control == 0)) {\n\t\tstruct RxD1 *rxdp1 = (struct RxD1 *)rxdp;\n\t\t \n\t\tif (*skb) {\n\t\t\tDBG_PRINT(INFO_DBG, \"SKB is not NULL\\n\");\n\t\t\t \n\t\t\trxdp1->Buffer0_ptr = *temp0;\n\t\t} else {\n\t\t\t*skb = netdev_alloc_skb(dev, size);\n\t\t\tif (!(*skb)) {\n\t\t\t\tDBG_PRINT(INFO_DBG,\n\t\t\t\t\t  \"%s: Out of memory to allocate %s\\n\",\n\t\t\t\t\t  dev->name, \"1 buf mode SKBs\");\n\t\t\t\tstats->mem_alloc_fail_cnt++;\n\t\t\t\treturn -ENOMEM ;\n\t\t\t}\n\t\t\tstats->mem_allocated += (*skb)->truesize;\n\t\t\t \n\t\t\trxdp1->Buffer0_ptr = *temp0 =\n\t\t\t\tdma_map_single(&sp->pdev->dev, (*skb)->data,\n\t\t\t\t\t       size - NET_IP_ALIGN,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&sp->pdev->dev, rxdp1->Buffer0_ptr))\n\t\t\t\tgoto memalloc_failed;\n\t\t\trxdp->Host_Control = (unsigned long) (*skb);\n\t\t}\n\t} else if ((sp->rxd_mode == RXD_MODE_3B) && (rxdp->Host_Control == 0)) {\n\t\tstruct RxD3 *rxdp3 = (struct RxD3 *)rxdp;\n\t\t \n\t\tif (*skb) {\n\t\t\trxdp3->Buffer2_ptr = *temp2;\n\t\t\trxdp3->Buffer0_ptr = *temp0;\n\t\t\trxdp3->Buffer1_ptr = *temp1;\n\t\t} else {\n\t\t\t*skb = netdev_alloc_skb(dev, size);\n\t\t\tif (!(*skb)) {\n\t\t\t\tDBG_PRINT(INFO_DBG,\n\t\t\t\t\t  \"%s: Out of memory to allocate %s\\n\",\n\t\t\t\t\t  dev->name,\n\t\t\t\t\t  \"2 buf mode SKBs\");\n\t\t\t\tstats->mem_alloc_fail_cnt++;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tstats->mem_allocated += (*skb)->truesize;\n\t\t\trxdp3->Buffer2_ptr = *temp2 =\n\t\t\t\tdma_map_single(&sp->pdev->dev, (*skb)->data,\n\t\t\t\t\t       dev->mtu + 4, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&sp->pdev->dev, rxdp3->Buffer2_ptr))\n\t\t\t\tgoto memalloc_failed;\n\t\t\trxdp3->Buffer0_ptr = *temp0 =\n\t\t\t\tdma_map_single(&sp->pdev->dev, ba->ba_0,\n\t\t\t\t\t       BUF0_LEN, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&sp->pdev->dev, rxdp3->Buffer0_ptr)) {\n\t\t\t\tdma_unmap_single(&sp->pdev->dev,\n\t\t\t\t\t\t (dma_addr_t)rxdp3->Buffer2_ptr,\n\t\t\t\t\t\t dev->mtu + 4,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tgoto memalloc_failed;\n\t\t\t}\n\t\t\trxdp->Host_Control = (unsigned long) (*skb);\n\n\t\t\t \n\t\t\trxdp3->Buffer1_ptr = *temp1 =\n\t\t\t\tdma_map_single(&sp->pdev->dev, ba->ba_1,\n\t\t\t\t\t       BUF1_LEN, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&sp->pdev->dev, rxdp3->Buffer1_ptr)) {\n\t\t\t\tdma_unmap_single(&sp->pdev->dev,\n\t\t\t\t\t\t (dma_addr_t)rxdp3->Buffer0_ptr,\n\t\t\t\t\t\t BUF0_LEN, DMA_FROM_DEVICE);\n\t\t\t\tdma_unmap_single(&sp->pdev->dev,\n\t\t\t\t\t\t (dma_addr_t)rxdp3->Buffer2_ptr,\n\t\t\t\t\t\t dev->mtu + 4,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tgoto memalloc_failed;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\nmemalloc_failed:\n\tstats->pci_map_fail_cnt++;\n\tstats->mem_freed += (*skb)->truesize;\n\tdev_kfree_skb(*skb);\n\treturn -ENOMEM;\n}\n\nstatic void set_rxd_buffer_size(struct s2io_nic *sp, struct RxD_t *rxdp,\n\t\t\t\tint size)\n{\n\tstruct net_device *dev = sp->dev;\n\tif (sp->rxd_mode == RXD_MODE_1) {\n\t\trxdp->Control_2 = SET_BUFFER0_SIZE_1(size - NET_IP_ALIGN);\n\t} else if (sp->rxd_mode == RXD_MODE_3B) {\n\t\trxdp->Control_2 = SET_BUFFER0_SIZE_3(BUF0_LEN);\n\t\trxdp->Control_2 |= SET_BUFFER1_SIZE_3(1);\n\t\trxdp->Control_2 |= SET_BUFFER2_SIZE_3(dev->mtu + 4);\n\t}\n}\n\nstatic  int rxd_owner_bit_reset(struct s2io_nic *sp)\n{\n\tint i, j, k, blk_cnt = 0, size;\n\tstruct config_param *config = &sp->config;\n\tstruct mac_info *mac_control = &sp->mac_control;\n\tstruct net_device *dev = sp->dev;\n\tstruct RxD_t *rxdp = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct buffAdd *ba = NULL;\n\tu64 temp0_64 = 0, temp1_64 = 0, temp2_64 = 0;\n\n\t \n\tsize = dev->mtu + HEADER_ETHERNET_II_802_3_SIZE +\n\t\tHEADER_802_2_SIZE + HEADER_SNAP_SIZE;\n\tif (sp->rxd_mode == RXD_MODE_1)\n\t\tsize += NET_IP_ALIGN;\n\telse if (sp->rxd_mode == RXD_MODE_3B)\n\t\tsize = dev->mtu + ALIGN_SIZE + BUF0_LEN + 4;\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\tblk_cnt = rx_cfg->num_rxd / (rxd_count[sp->rxd_mode] + 1);\n\n\t\tfor (j = 0; j < blk_cnt; j++) {\n\t\t\tfor (k = 0; k < rxd_count[sp->rxd_mode]; k++) {\n\t\t\t\trxdp = ring->rx_blocks[j].rxds[k].virt_addr;\n\t\t\t\tif (sp->rxd_mode == RXD_MODE_3B)\n\t\t\t\t\tba = &ring->ba[j][k];\n\t\t\t\tif (set_rxd_buffer_pointer(sp, rxdp, ba, &skb,\n\t\t\t\t\t\t\t   &temp0_64,\n\t\t\t\t\t\t\t   &temp1_64,\n\t\t\t\t\t\t\t   &temp2_64,\n\t\t\t\t\t\t\t   size) == -ENOMEM) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tset_rxd_buffer_size(sp, rxdp, size);\n\t\t\t\tdma_wmb();\n\t\t\t\t \n\t\t\t\trxdp->Control_1 |= RXD_OWN_XENA;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}\n\nstatic int s2io_add_isr(struct s2io_nic *sp)\n{\n\tint ret = 0;\n\tstruct net_device *dev = sp->dev;\n\tint err = 0;\n\n\tif (sp->config.intr_type == MSI_X)\n\t\tret = s2io_enable_msi_x(sp);\n\tif (ret) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Defaulting to INTA\\n\", dev->name);\n\t\tsp->config.intr_type = INTA;\n\t}\n\n\t \n\tstore_xmsi_data(sp);\n\n\t \n\tif (sp->config.intr_type == MSI_X) {\n\t\tint i, msix_rx_cnt = 0;\n\n\t\tfor (i = 0; i < sp->num_entries; i++) {\n\t\t\tif (sp->s2io_entries[i].in_use == MSIX_FLG) {\n\t\t\t\tif (sp->s2io_entries[i].type ==\n\t\t\t\t    MSIX_RING_TYPE) {\n\t\t\t\t\tsnprintf(sp->desc[i],\n\t\t\t\t\t\tsizeof(sp->desc[i]),\n\t\t\t\t\t\t\"%s:MSI-X-%d-RX\",\n\t\t\t\t\t\tdev->name, i);\n\t\t\t\t\terr = request_irq(sp->entries[i].vector,\n\t\t\t\t\t\t\t  s2io_msix_ring_handle,\n\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t  sp->desc[i],\n\t\t\t\t\t\t\t  sp->s2io_entries[i].arg);\n\t\t\t\t} else if (sp->s2io_entries[i].type ==\n\t\t\t\t\t   MSIX_ALARM_TYPE) {\n\t\t\t\t\tsnprintf(sp->desc[i],\n\t\t\t\t\t\tsizeof(sp->desc[i]),\n\t\t\t\t\t\t\"%s:MSI-X-%d-TX\",\n\t\t\t\t\t\tdev->name, i);\n\t\t\t\t\terr = request_irq(sp->entries[i].vector,\n\t\t\t\t\t\t\t  s2io_msix_fifo_handle,\n\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t  sp->desc[i],\n\t\t\t\t\t\t\t  sp->s2io_entries[i].arg);\n\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (!(sp->msix_info[i].addr &&\n\t\t\t\t      sp->msix_info[i].data)) {\n\t\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t\t  \"%s @Addr:0x%llx Data:0x%llx\\n\",\n\t\t\t\t\t\t  sp->desc[i],\n\t\t\t\t\t\t  (unsigned long long)\n\t\t\t\t\t\t  sp->msix_info[i].addr,\n\t\t\t\t\t\t  (unsigned long long)\n\t\t\t\t\t\t  ntohl(sp->msix_info[i].data));\n\t\t\t\t} else\n\t\t\t\t\tmsix_rx_cnt++;\n\t\t\t\tif (err) {\n\t\t\t\t\tremove_msix_isr(sp);\n\n\t\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t\t  \"%s:MSI-X-%d registration \"\n\t\t\t\t\t\t  \"failed\\n\", dev->name, i);\n\n\t\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t\t  \"%s: Defaulting to INTA\\n\",\n\t\t\t\t\t\t  dev->name);\n\t\t\t\t\tsp->config.intr_type = INTA;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsp->s2io_entries[i].in_use =\n\t\t\t\t\tMSIX_REGISTERED_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tif (!err) {\n\t\t\tpr_info(\"MSI-X-RX %d entries enabled\\n\", --msix_rx_cnt);\n\t\t\tDBG_PRINT(INFO_DBG,\n\t\t\t\t  \"MSI-X-TX entries enabled through alarm vector\\n\");\n\t\t}\n\t}\n\tif (sp->config.intr_type == INTA) {\n\t\terr = request_irq(sp->pdev->irq, s2io_isr, IRQF_SHARED,\n\t\t\t\t  sp->name, dev);\n\t\tif (err) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: ISR registration failed\\n\",\n\t\t\t\t  dev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void s2io_rem_isr(struct s2io_nic *sp)\n{\n\tif (sp->config.intr_type == MSI_X)\n\t\tremove_msix_isr(sp);\n\telse\n\t\tremove_inta_isr(sp);\n}\n\nstatic void do_s2io_card_down(struct s2io_nic *sp, int do_io)\n{\n\tint cnt = 0;\n\tstruct XENA_dev_config __iomem *bar0 = sp->bar0;\n\tregister u64 val64 = 0;\n\tstruct config_param *config;\n\tconfig = &sp->config;\n\n\tif (!is_s2io_card_up(sp))\n\t\treturn;\n\n\tdel_timer_sync(&sp->alarm_timer);\n\t \n\twhile (test_and_set_bit(__S2IO_STATE_LINK_TASK, &(sp->state)))\n\t\tmsleep(50);\n\tclear_bit(__S2IO_STATE_CARD_UP, &sp->state);\n\n\t \n\tif (sp->config.napi) {\n\t\tint off = 0;\n\t\tif (config->intr_type ==  MSI_X) {\n\t\t\tfor (; off < sp->config.rx_ring_num; off++)\n\t\t\t\tnapi_disable(&sp->mac_control.rings[off].napi);\n\t\t}\n\t\telse\n\t\t\tnapi_disable(&sp->napi);\n\t}\n\n\t \n\tif (do_io)\n\t\tstop_nic(sp);\n\n\ts2io_rem_isr(sp);\n\n\t \n\ts2io_link(sp, LINK_DOWN);\n\n\t \n\twhile (do_io) {\n\t\t \n\t\trxd_owner_bit_reset(sp);\n\n\t\tval64 = readq(&bar0->adapter_status);\n\t\tif (verify_xena_quiescence(sp)) {\n\t\t\tif (verify_pcc_quiescent(sp, sp->device_enabled_once))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(50);\n\t\tcnt++;\n\t\tif (cnt == 10) {\n\t\t\tDBG_PRINT(ERR_DBG, \"Device not Quiescent - \"\n\t\t\t\t  \"adapter status reads 0x%llx\\n\",\n\t\t\t\t  (unsigned long long)val64);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_io)\n\t\ts2io_reset(sp);\n\n\t \n\tfree_tx_buffers(sp);\n\n\t \n\tfree_rx_buffers(sp);\n\n\tclear_bit(__S2IO_STATE_LINK_TASK, &(sp->state));\n}\n\nstatic void s2io_card_down(struct s2io_nic *sp)\n{\n\tdo_s2io_card_down(sp, 1);\n}\n\nstatic int s2io_card_up(struct s2io_nic *sp)\n{\n\tint i, ret = 0;\n\tstruct config_param *config;\n\tstruct mac_info *mac_control;\n\tstruct net_device *dev = sp->dev;\n\tu16 interruptible;\n\n\t \n\tret = init_nic(sp);\n\tif (ret != 0) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: H/W initialization failed\\n\",\n\t\t\t  dev->name);\n\t\tif (ret != -EIO)\n\t\t\ts2io_reset(sp);\n\t\treturn ret;\n\t}\n\n\t \n\tconfig = &sp->config;\n\tmac_control = &sp->mac_control;\n\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\tring->mtu = dev->mtu;\n\t\tring->lro = !!(dev->features & NETIF_F_LRO);\n\t\tret = fill_rx_buffers(sp, ring, 1);\n\t\tif (ret) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Out of memory in Open\\n\",\n\t\t\t\t  dev->name);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fill_buff;\n\t\t}\n\t\tDBG_PRINT(INFO_DBG, \"Buf in ring:%d is %d:\\n\", i,\n\t\t\t  ring->rx_bufs_left);\n\t}\n\n\t \n\tif (config->napi) {\n\t\tif (config->intr_type ==  MSI_X) {\n\t\t\tfor (i = 0; i < sp->config.rx_ring_num; i++)\n\t\t\t\tnapi_enable(&sp->mac_control.rings[i].napi);\n\t\t} else {\n\t\t\tnapi_enable(&sp->napi);\n\t\t}\n\t}\n\n\t \n\tif (sp->promisc_flg)\n\t\tsp->promisc_flg = 0;\n\tif (sp->m_cast_flg) {\n\t\tsp->m_cast_flg = 0;\n\t\tsp->all_multi_pos = 0;\n\t}\n\n\t \n\ts2io_set_multicast(dev, true);\n\n\tif (dev->features & NETIF_F_LRO) {\n\t\t \n\t\tsp->lro_max_aggr_per_sess = ((1<<16) - 1) / dev->mtu;\n\t\t \n\t\tif (lro_max_pkts < sp->lro_max_aggr_per_sess)\n\t\t\tsp->lro_max_aggr_per_sess = lro_max_pkts;\n\t}\n\n\t \n\tif (start_nic(sp)) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Starting NIC failed\\n\", dev->name);\n\t\tret = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (s2io_add_isr(sp) != 0) {\n\t\tif (sp->config.intr_type == MSI_X)\n\t\t\ts2io_rem_isr(sp);\n\t\tret = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\ttimer_setup(&sp->alarm_timer, s2io_alarm_handle, 0);\n\tmod_timer(&sp->alarm_timer, jiffies + HZ / 2);\n\n\tset_bit(__S2IO_STATE_CARD_UP, &sp->state);\n\n\t \n\ten_dis_err_alarms(sp, ENA_ALL_INTRS, ENABLE_INTRS);\n\tif (sp->config.intr_type != INTA) {\n\t\tinterruptible = TX_TRAFFIC_INTR | TX_PIC_INTR;\n\t\ten_dis_able_nic_intrs(sp, interruptible, ENABLE_INTRS);\n\t} else {\n\t\tinterruptible = TX_TRAFFIC_INTR | RX_TRAFFIC_INTR;\n\t\tinterruptible |= TX_PIC_INTR;\n\t\ten_dis_able_nic_intrs(sp, interruptible, ENABLE_INTRS);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tif (config->napi) {\n\t\tif (config->intr_type == MSI_X) {\n\t\t\tfor (i = 0; i < sp->config.rx_ring_num; i++)\n\t\t\t\tnapi_disable(&sp->mac_control.rings[i].napi);\n\t\t} else {\n\t\t\tnapi_disable(&sp->napi);\n\t\t}\n\t}\nerr_fill_buff:\n\ts2io_reset(sp);\n\tfree_rx_buffers(sp);\n\treturn ret;\n}\n\n \n\nstatic void s2io_restart_nic(struct work_struct *work)\n{\n\tstruct s2io_nic *sp = container_of(work, struct s2io_nic, rst_timer_task);\n\tstruct net_device *dev = sp->dev;\n\n\trtnl_lock();\n\n\tif (!netif_running(dev))\n\t\tgoto out_unlock;\n\n\ts2io_card_down(sp);\n\tif (s2io_card_up(sp)) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Device bring up failed\\n\", dev->name);\n\t}\n\ts2io_wake_all_tx_queue(sp);\n\tDBG_PRINT(ERR_DBG, \"%s: was reset by Tx watchdog timer\\n\", dev->name);\nout_unlock:\n\trtnl_unlock();\n}\n\n \n\nstatic void s2io_tx_watchdog(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\tstruct swStat *swstats = &sp->mac_control.stats_info->sw_stat;\n\n\tif (netif_carrier_ok(dev)) {\n\t\tswstats->watchdog_timer_cnt++;\n\t\tschedule_work(&sp->rst_timer_task);\n\t\tswstats->soft_reset_cnt++;\n\t}\n}\n\n \nstatic int rx_osm_handler(struct ring_info *ring_data, struct RxD_t * rxdp)\n{\n\tstruct s2io_nic *sp = ring_data->nic;\n\tstruct net_device *dev = ring_data->dev;\n\tstruct sk_buff *skb = (struct sk_buff *)\n\t\t((unsigned long)rxdp->Host_Control);\n\tint ring_no = ring_data->ring_no;\n\tu16 l3_csum, l4_csum;\n\tunsigned long long err = rxdp->Control_1 & RXD_T_CODE;\n\tstruct lro *lro;\n\tu8 err_mask;\n\tstruct swStat *swstats = &sp->mac_control.stats_info->sw_stat;\n\n\tskb->dev = dev;\n\n\tif (err) {\n\t\t \n\t\tif (err & 0x1)\n\t\t\tswstats->parity_err_cnt++;\n\n\t\terr_mask = err >> 48;\n\t\tswitch (err_mask) {\n\t\tcase 1:\n\t\t\tswstats->rx_parity_err_cnt++;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tswstats->rx_abort_cnt++;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tswstats->rx_parity_abort_cnt++;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tswstats->rx_rda_fail_cnt++;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tswstats->rx_unkn_prot_cnt++;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tswstats->rx_fcs_err_cnt++;\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\tswstats->rx_buf_size_err_cnt++;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tswstats->rx_rxd_corrupt_cnt++;\n\t\t\tbreak;\n\n\t\tcase 15:\n\t\t\tswstats->rx_unkn_err_cnt++;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (err_mask != 0x5) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Rx error Value: 0x%x\\n\",\n\t\t\t\t  dev->name, err_mask);\n\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tswstats->mem_freed\n\t\t\t\t+= skb->truesize;\n\t\t\tdev_kfree_skb(skb);\n\t\t\tring_data->rx_bufs_left -= 1;\n\t\t\trxdp->Host_Control = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trxdp->Host_Control = 0;\n\tif (sp->rxd_mode == RXD_MODE_1) {\n\t\tint len = RXD_GET_BUFFER0_SIZE_1(rxdp->Control_2);\n\n\t\tskb_put(skb, len);\n\t} else if (sp->rxd_mode == RXD_MODE_3B) {\n\t\tint get_block = ring_data->rx_curr_get_info.block_index;\n\t\tint get_off = ring_data->rx_curr_get_info.offset;\n\t\tint buf0_len = RXD_GET_BUFFER0_SIZE_3(rxdp->Control_2);\n\t\tint buf2_len = RXD_GET_BUFFER2_SIZE_3(rxdp->Control_2);\n\n\t\tstruct buffAdd *ba = &ring_data->ba[get_block][get_off];\n\t\tskb_put_data(skb, ba->ba_0, buf0_len);\n\t\tskb_put(skb, buf2_len);\n\t}\n\n\tif ((rxdp->Control_1 & TCP_OR_UDP_FRAME) &&\n\t    ((!ring_data->lro) ||\n\t     (!(rxdp->Control_1 & RXD_FRAME_IP_FRAG))) &&\n\t    (dev->features & NETIF_F_RXCSUM)) {\n\t\tl3_csum = RXD_GET_L3_CKSUM(rxdp->Control_1);\n\t\tl4_csum = RXD_GET_L4_CKSUM(rxdp->Control_1);\n\t\tif ((l3_csum == L3_CKSUM_OK) && (l4_csum == L4_CKSUM_OK)) {\n\t\t\t \n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tif (ring_data->lro) {\n\t\t\t\tu32 tcp_len = 0;\n\t\t\t\tu8 *tcp;\n\t\t\t\tint ret = 0;\n\n\t\t\t\tret = s2io_club_tcp_session(ring_data,\n\t\t\t\t\t\t\t    skb->data, &tcp,\n\t\t\t\t\t\t\t    &tcp_len, &lro,\n\t\t\t\t\t\t\t    rxdp, sp);\n\t\t\t\tswitch (ret) {\n\t\t\t\tcase 3:  \n\t\t\t\t\tlro->parent = skb;\n\t\t\t\t\tgoto aggregate;\n\t\t\t\tcase 1:  \n\t\t\t\t\tlro_append_pkt(sp, lro, skb, tcp_len);\n\t\t\t\t\tgoto aggregate;\n\t\t\t\tcase 4:  \n\t\t\t\t\tlro_append_pkt(sp, lro, skb, tcp_len);\n\t\t\t\t\tqueue_rx_frame(lro->parent,\n\t\t\t\t\t\t       lro->vlan_tag);\n\t\t\t\t\tclear_lro_session(lro);\n\t\t\t\t\tswstats->flush_max_pkts++;\n\t\t\t\t\tgoto aggregate;\n\t\t\t\tcase 2:  \n\t\t\t\t\tlro->parent->data_len = lro->frags_len;\n\t\t\t\t\tswstats->sending_both++;\n\t\t\t\t\tqueue_rx_frame(lro->parent,\n\t\t\t\t\t\t       lro->vlan_tag);\n\t\t\t\t\tclear_lro_session(lro);\n\t\t\t\t\tgoto send_up;\n\t\t\t\tcase 0:  \n\t\t\t\tcase -1:  \n\t\t\t\tcase 5:  \n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t\t\t  \"%s: Samadhana!!\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tskb_checksum_none_assert(skb);\n\t\t}\n\t} else\n\t\tskb_checksum_none_assert(skb);\n\n\tswstats->mem_freed += skb->truesize;\nsend_up:\n\tskb_record_rx_queue(skb, ring_no);\n\tqueue_rx_frame(skb, RXD_GET_VLAN_TAG(rxdp->Control_2));\naggregate:\n\tsp->mac_control.rings[ring_no].rx_bufs_left -= 1;\n\treturn SUCCESS;\n}\n\n \n\nstatic void s2io_link(struct s2io_nic *sp, int link)\n{\n\tstruct net_device *dev = sp->dev;\n\tstruct swStat *swstats = &sp->mac_control.stats_info->sw_stat;\n\n\tif (link != sp->last_link_state) {\n\t\tinit_tti(sp, link, false);\n\t\tif (link == LINK_DOWN) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Link down\\n\", dev->name);\n\t\t\ts2io_stop_all_tx_queue(sp);\n\t\t\tnetif_carrier_off(dev);\n\t\t\tif (swstats->link_up_cnt)\n\t\t\t\tswstats->link_up_time =\n\t\t\t\t\tjiffies - sp->start_time;\n\t\t\tswstats->link_down_cnt++;\n\t\t} else {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Link Up\\n\", dev->name);\n\t\t\tif (swstats->link_down_cnt)\n\t\t\t\tswstats->link_down_time =\n\t\t\t\t\tjiffies - sp->start_time;\n\t\t\tswstats->link_up_cnt++;\n\t\t\tnetif_carrier_on(dev);\n\t\t\ts2io_wake_all_tx_queue(sp);\n\t\t}\n\t}\n\tsp->last_link_state = link;\n\tsp->start_time = jiffies;\n}\n\n \n\nstatic void s2io_init_pci(struct s2io_nic *sp)\n{\n\tu16 pci_cmd = 0, pcix_cmd = 0;\n\n\t \n\tpci_read_config_word(sp->pdev, PCIX_COMMAND_REGISTER,\n\t\t\t     &(pcix_cmd));\n\tpci_write_config_word(sp->pdev, PCIX_COMMAND_REGISTER,\n\t\t\t      (pcix_cmd | 1));\n\tpci_read_config_word(sp->pdev, PCIX_COMMAND_REGISTER,\n\t\t\t     &(pcix_cmd));\n\n\t \n\tpci_read_config_word(sp->pdev, PCI_COMMAND, &pci_cmd);\n\tpci_write_config_word(sp->pdev, PCI_COMMAND,\n\t\t\t      (pci_cmd | PCI_COMMAND_PARITY));\n\tpci_read_config_word(sp->pdev, PCI_COMMAND, &pci_cmd);\n}\n\nstatic int s2io_verify_parm(struct pci_dev *pdev, u8 *dev_intr_type,\n\t\t\t    u8 *dev_multiq)\n{\n\tint i;\n\n\tif ((tx_fifo_num > MAX_TX_FIFOS) || (tx_fifo_num < 1)) {\n\t\tDBG_PRINT(ERR_DBG, \"Requested number of tx fifos \"\n\t\t\t  \"(%d) not supported\\n\", tx_fifo_num);\n\n\t\tif (tx_fifo_num < 1)\n\t\t\ttx_fifo_num = 1;\n\t\telse\n\t\t\ttx_fifo_num = MAX_TX_FIFOS;\n\n\t\tDBG_PRINT(ERR_DBG, \"Default to %d tx fifos\\n\", tx_fifo_num);\n\t}\n\n\tif (multiq)\n\t\t*dev_multiq = multiq;\n\n\tif (tx_steering_type && (1 == tx_fifo_num)) {\n\t\tif (tx_steering_type != TX_DEFAULT_STEERING)\n\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t  \"Tx steering is not supported with \"\n\t\t\t\t  \"one fifo. Disabling Tx steering.\\n\");\n\t\ttx_steering_type = NO_STEERING;\n\t}\n\n\tif ((tx_steering_type < NO_STEERING) ||\n\t    (tx_steering_type > TX_DEFAULT_STEERING)) {\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"Requested transmit steering not supported\\n\");\n\t\tDBG_PRINT(ERR_DBG, \"Disabling transmit steering\\n\");\n\t\ttx_steering_type = NO_STEERING;\n\t}\n\n\tif (rx_ring_num > MAX_RX_RINGS) {\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"Requested number of rx rings not supported\\n\");\n\t\tDBG_PRINT(ERR_DBG, \"Default to %d rx rings\\n\",\n\t\t\t  MAX_RX_RINGS);\n\t\trx_ring_num = MAX_RX_RINGS;\n\t}\n\n\tif ((*dev_intr_type != INTA) && (*dev_intr_type != MSI_X)) {\n\t\tDBG_PRINT(ERR_DBG, \"Wrong intr_type requested. \"\n\t\t\t  \"Defaulting to INTA\\n\");\n\t\t*dev_intr_type = INTA;\n\t}\n\n\tif ((*dev_intr_type == MSI_X) &&\n\t    ((pdev->device != PCI_DEVICE_ID_HERC_WIN) &&\n\t     (pdev->device != PCI_DEVICE_ID_HERC_UNI))) {\n\t\tDBG_PRINT(ERR_DBG, \"Xframe I does not support MSI_X. \"\n\t\t\t  \"Defaulting to INTA\\n\");\n\t\t*dev_intr_type = INTA;\n\t}\n\n\tif ((rx_ring_mode != 1) && (rx_ring_mode != 2)) {\n\t\tDBG_PRINT(ERR_DBG, \"Requested ring mode not supported\\n\");\n\t\tDBG_PRINT(ERR_DBG, \"Defaulting to 1-buffer mode\\n\");\n\t\trx_ring_mode = 1;\n\t}\n\n\tfor (i = 0; i < MAX_RX_RINGS; i++)\n\t\tif (rx_ring_sz[i] > MAX_RX_BLOCKS_PER_RING) {\n\t\t\tDBG_PRINT(ERR_DBG, \"Requested rx ring size not \"\n\t\t\t\t  \"supported\\nDefaulting to %d\\n\",\n\t\t\t\t  MAX_RX_BLOCKS_PER_RING);\n\t\t\trx_ring_sz[i] = MAX_RX_BLOCKS_PER_RING;\n\t\t}\n\n\treturn SUCCESS;\n}\n\n \nstatic int rts_ds_steer(struct s2io_nic *nic, u8 ds_codepoint, u8 ring)\n{\n\tstruct XENA_dev_config __iomem *bar0 = nic->bar0;\n\tregister u64 val64 = 0;\n\n\tif (ds_codepoint > 63)\n\t\treturn FAILURE;\n\n\tval64 = RTS_DS_MEM_DATA(ring);\n\twriteq(val64, &bar0->rts_ds_mem_data);\n\n\tval64 = RTS_DS_MEM_CTRL_WE |\n\t\tRTS_DS_MEM_CTRL_STROBE_NEW_CMD |\n\t\tRTS_DS_MEM_CTRL_OFFSET(ds_codepoint);\n\n\twriteq(val64, &bar0->rts_ds_mem_ctrl);\n\n\treturn wait_for_cmd_complete(&bar0->rts_ds_mem_ctrl,\n\t\t\t\t     RTS_DS_MEM_CTRL_STROBE_CMD_BEING_EXECUTED,\n\t\t\t\t     S2IO_BIT_RESET, true);\n}\n\nstatic const struct net_device_ops s2io_netdev_ops = {\n\t.ndo_open\t        = s2io_open,\n\t.ndo_stop\t        = s2io_close,\n\t.ndo_get_stats\t        = s2io_get_stats,\n\t.ndo_start_xmit    \t= s2io_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= s2io_ndo_set_multicast,\n\t.ndo_eth_ioctl\t\t= s2io_ioctl,\n\t.ndo_set_mac_address    = s2io_set_mac_addr,\n\t.ndo_change_mtu\t   \t= s2io_change_mtu,\n\t.ndo_set_features\t= s2io_set_features,\n\t.ndo_tx_timeout\t   \t= s2io_tx_watchdog,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller    = s2io_netpoll,\n#endif\n};\n\n \n\nstatic int\ns2io_init_nic(struct pci_dev *pdev, const struct pci_device_id *pre)\n{\n\tstruct s2io_nic *sp;\n\tstruct net_device *dev;\n\tint i, j, ret;\n\tu32 mac_up, mac_down;\n\tu64 val64 = 0, tmp64 = 0;\n\tstruct XENA_dev_config __iomem *bar0 = NULL;\n\tu16 subid;\n\tstruct config_param *config;\n\tstruct mac_info *mac_control;\n\tint mode;\n\tu8 dev_intr_type = intr_type;\n\tu8 dev_multiq = 0;\n\n\tret = s2io_verify_parm(pdev, &dev_intr_type, &dev_multiq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"%s: pci_enable_device failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tDBG_PRINT(INIT_DBG, \"%s: Using 64bit DMA\\n\", __func__);\n\t} else {\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOMEM;\n\t}\n\tret = pci_request_regions(pdev, s2io_driver_name);\n\tif (ret) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Request Regions failed - %x\\n\",\n\t\t\t  __func__, ret);\n\t\tpci_disable_device(pdev);\n\t\treturn -ENODEV;\n\t}\n\tif (dev_multiq)\n\t\tdev = alloc_etherdev_mq(sizeof(struct s2io_nic), tx_fifo_num);\n\telse\n\t\tdev = alloc_etherdev(sizeof(struct s2io_nic));\n\tif (dev == NULL) {\n\t\tpci_disable_device(pdev);\n\t\tpci_release_regions(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\t \n\tsp = netdev_priv(dev);\n\tsp->dev = dev;\n\tsp->pdev = pdev;\n\tsp->device_enabled_once = false;\n\tif (rx_ring_mode == 1)\n\t\tsp->rxd_mode = RXD_MODE_1;\n\tif (rx_ring_mode == 2)\n\t\tsp->rxd_mode = RXD_MODE_3B;\n\n\tsp->config.intr_type = dev_intr_type;\n\n\tif ((pdev->device == PCI_DEVICE_ID_HERC_WIN) ||\n\t    (pdev->device == PCI_DEVICE_ID_HERC_UNI))\n\t\tsp->device_type = XFRAME_II_DEVICE;\n\telse\n\t\tsp->device_type = XFRAME_I_DEVICE;\n\n\n\t \n\ts2io_init_pci(sp);\n\n\t \n\tconfig = &sp->config;\n\tmac_control = &sp->mac_control;\n\n\tconfig->napi = napi;\n\tconfig->tx_steering_type = tx_steering_type;\n\n\t \n\tif (config->tx_steering_type == TX_PRIORITY_STEERING)\n\t\tconfig->tx_fifo_num = MAX_TX_FIFOS;\n\telse\n\t\tconfig->tx_fifo_num = tx_fifo_num;\n\n\t \n\tif (config->tx_fifo_num < 5) {\n\t\tif (config->tx_fifo_num  == 1)\n\t\t\tsp->total_tcp_fifos = 1;\n\t\telse\n\t\t\tsp->total_tcp_fifos = config->tx_fifo_num - 1;\n\t\tsp->udp_fifo_idx = config->tx_fifo_num - 1;\n\t\tsp->total_udp_fifos = 1;\n\t\tsp->other_fifo_idx = sp->total_tcp_fifos - 1;\n\t} else {\n\t\tsp->total_tcp_fifos = (tx_fifo_num - FIFO_UDP_MAX_NUM -\n\t\t\t\t       FIFO_OTHER_MAX_NUM);\n\t\tsp->udp_fifo_idx = sp->total_tcp_fifos;\n\t\tsp->total_udp_fifos = FIFO_UDP_MAX_NUM;\n\t\tsp->other_fifo_idx = sp->udp_fifo_idx + FIFO_UDP_MAX_NUM;\n\t}\n\n\tconfig->multiq = dev_multiq;\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\ttx_cfg->fifo_len = tx_fifo_len[i];\n\t\ttx_cfg->fifo_priority = i;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_TX_FIFOS; i++)\n\t\tconfig->fifo_mapping[i] = fifo_map[config->tx_fifo_num - 1][i];\n\n\t \n\tfor (i = 0; i < config->tx_fifo_num; i++)\n\t\tsp->fifo_selector[i] = fifo_selector[i];\n\n\n\tconfig->tx_intr_type = TXD_INT_TYPE_UTILZ;\n\tfor (i = 0; i < config->tx_fifo_num; i++) {\n\t\tstruct tx_fifo_config *tx_cfg = &config->tx_cfg[i];\n\n\t\ttx_cfg->f_no_snoop = (NO_SNOOP_TXD | NO_SNOOP_TXD_BUFFER);\n\t\tif (tx_cfg->fifo_len < 65) {\n\t\t\tconfig->tx_intr_type = TXD_INT_TYPE_PER_LIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tconfig->max_txds = MAX_SKB_FRAGS + 2;\n\n\t \n\tconfig->rx_ring_num = rx_ring_num;\n\tfor (i = 0; i < config->rx_ring_num; i++) {\n\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\trx_cfg->num_rxd = rx_ring_sz[i] * (rxd_count[sp->rxd_mode] + 1);\n\t\trx_cfg->ring_priority = i;\n\t\tring->rx_bufs_left = 0;\n\t\tring->rxd_mode = sp->rxd_mode;\n\t\tring->rxd_count = rxd_count[sp->rxd_mode];\n\t\tring->pdev = sp->pdev;\n\t\tring->dev = sp->dev;\n\t}\n\n\tfor (i = 0; i < rx_ring_num; i++) {\n\t\tstruct rx_ring_config *rx_cfg = &config->rx_cfg[i];\n\n\t\trx_cfg->ring_org = RING_ORG_BUFF1;\n\t\trx_cfg->f_no_snoop = (NO_SNOOP_RXD | NO_SNOOP_RXD_BUFFER);\n\t}\n\n\t \n\tmac_control->rmac_pause_time = rmac_pause_time;\n\tmac_control->mc_pause_threshold_q0q3 = mc_pause_threshold_q0q3;\n\tmac_control->mc_pause_threshold_q4q7 = mc_pause_threshold_q4q7;\n\n\n\t \n\tif (init_shared_mem(sp)) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Memory allocation failed\\n\", dev->name);\n\t\tret = -ENOMEM;\n\t\tgoto mem_alloc_failed;\n\t}\n\n\tsp->bar0 = pci_ioremap_bar(pdev, 0);\n\tif (!sp->bar0) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Neterion: cannot remap io mem1\\n\",\n\t\t\t  dev->name);\n\t\tret = -ENOMEM;\n\t\tgoto bar0_remap_failed;\n\t}\n\n\tsp->bar1 = pci_ioremap_bar(pdev, 2);\n\tif (!sp->bar1) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: Neterion: cannot remap io mem2\\n\",\n\t\t\t  dev->name);\n\t\tret = -ENOMEM;\n\t\tgoto bar1_remap_failed;\n\t}\n\n\t \n\tfor (j = 0; j < MAX_TX_FIFOS; j++) {\n\t\tmac_control->tx_FIFO_start[j] = sp->bar1 + (j * 0x00020000);\n\t}\n\n\t \n\tdev->netdev_ops = &s2io_netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\tdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\tNETIF_F_TSO | NETIF_F_TSO6 |\n\t\tNETIF_F_RXCSUM | NETIF_F_LRO;\n\tdev->features |= dev->hw_features |\n\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\tNETIF_F_HIGHDMA;\n\tdev->watchdog_timeo = WATCH_DOG_TIMEOUT;\n\tINIT_WORK(&sp->rst_timer_task, s2io_restart_nic);\n\tINIT_WORK(&sp->set_link_task, s2io_set_link);\n\n\tpci_save_state(sp->pdev);\n\n\t \n\tif (s2io_set_swapper(sp)) {\n\t\tDBG_PRINT(ERR_DBG, \"%s: swapper settings are wrong\\n\",\n\t\t\t  dev->name);\n\t\tret = -EAGAIN;\n\t\tgoto set_swap_failed;\n\t}\n\n\t \n\tif (sp->device_type & XFRAME_II_DEVICE) {\n\t\tmode = s2io_verify_pci_mode(sp);\n\t\tif (mode < 0) {\n\t\t\tDBG_PRINT(ERR_DBG, \"%s: Unsupported PCI bus mode\\n\",\n\t\t\t\t  __func__);\n\t\t\tret = -EBADSLT;\n\t\t\tgoto set_swap_failed;\n\t\t}\n\t}\n\n\tif (sp->config.intr_type == MSI_X) {\n\t\tsp->num_entries = config->rx_ring_num + 1;\n\t\tret = s2io_enable_msi_x(sp);\n\n\t\tif (!ret) {\n\t\t\tret = s2io_test_msi(sp);\n\t\t\t \n\t\t\tremove_msix_isr(sp);\n\t\t}\n\t\tif (ret) {\n\n\t\t\tDBG_PRINT(ERR_DBG,\n\t\t\t\t  \"MSI-X requested but failed to enable\\n\");\n\t\t\tsp->config.intr_type = INTA;\n\t\t}\n\t}\n\n\tif (config->intr_type ==  MSI_X) {\n\t\tfor (i = 0; i < config->rx_ring_num ; i++) {\n\t\t\tstruct ring_info *ring = &mac_control->rings[i];\n\n\t\t\tnetif_napi_add(dev, &ring->napi, s2io_poll_msix);\n\t\t}\n\t} else {\n\t\tnetif_napi_add(dev, &sp->napi, s2io_poll_inta);\n\t}\n\n\t \n\tif (sp->device_type & XFRAME_I_DEVICE) {\n\t\t \n\t\tfix_mac_address(sp);\n\t\ts2io_reset(sp);\n\t}\n\n\t \n\tbar0 = sp->bar0;\n\tval64 = RMAC_ADDR_CMD_MEM_RD | RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |\n\t\tRMAC_ADDR_CMD_MEM_OFFSET(0 + S2IO_MAC_ADDR_START_OFFSET);\n\twriteq(val64, &bar0->rmac_addr_cmd_mem);\n\twait_for_cmd_complete(&bar0->rmac_addr_cmd_mem,\n\t\t\t      RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING,\n\t\t\t      S2IO_BIT_RESET, true);\n\ttmp64 = readq(&bar0->rmac_addr_data0_mem);\n\tmac_down = (u32)tmp64;\n\tmac_up = (u32) (tmp64 >> 32);\n\n\tsp->def_mac_addr[0].mac_addr[3] = (u8) (mac_up);\n\tsp->def_mac_addr[0].mac_addr[2] = (u8) (mac_up >> 8);\n\tsp->def_mac_addr[0].mac_addr[1] = (u8) (mac_up >> 16);\n\tsp->def_mac_addr[0].mac_addr[0] = (u8) (mac_up >> 24);\n\tsp->def_mac_addr[0].mac_addr[5] = (u8) (mac_down >> 16);\n\tsp->def_mac_addr[0].mac_addr[4] = (u8) (mac_down >> 24);\n\n\t \n\tdev->addr_len = ETH_ALEN;\n\teth_hw_addr_set(dev, sp->def_mac_addr[0].mac_addr);\n\n\t \n\tif (sp->device_type == XFRAME_I_DEVICE) {\n\t\tconfig->max_mc_addr = S2IO_XENA_MAX_MC_ADDRESSES;\n\t\tconfig->max_mac_addr = S2IO_XENA_MAX_MAC_ADDRESSES;\n\t\tconfig->mc_start_offset = S2IO_XENA_MC_ADDR_START_OFFSET;\n\t} else if (sp->device_type == XFRAME_II_DEVICE) {\n\t\tconfig->max_mc_addr = S2IO_HERC_MAX_MC_ADDRESSES;\n\t\tconfig->max_mac_addr = S2IO_HERC_MAX_MAC_ADDRESSES;\n\t\tconfig->mc_start_offset = S2IO_HERC_MC_ADDR_START_OFFSET;\n\t}\n\n\t \n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = S2IO_JUMBO_SIZE;\n\n\t \n\tdo_s2io_store_unicast_mc(sp);\n\n\t \n\tif ((sp->device_type == XFRAME_II_DEVICE) &&\n\t    (config->intr_type == MSI_X))\n\t\tsp->num_entries = config->rx_ring_num + 1;\n\n\t \n\tstore_xmsi_data(sp);\n\t \n\ts2io_reset(sp);\n\n\t \n\tsp->state = 0;\n\n\t \n\tfor (i = 0; i < sp->config.tx_fifo_num; i++) {\n\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\n\t\tspin_lock_init(&fifo->tx_lock);\n\t}\n\n\t \n\tsubid = sp->pdev->subsystem_device;\n\tif ((subid & 0xFF) >= 0x07) {\n\t\tval64 = readq(&bar0->gpio_control);\n\t\tval64 |= 0x0000800000000000ULL;\n\t\twriteq(val64, &bar0->gpio_control);\n\t\tval64 = 0x0411040400000000ULL;\n\t\twriteq(val64, (void __iomem *)bar0 + 0x2700);\n\t\tval64 = readq(&bar0->gpio_control);\n\t}\n\n\tsp->rx_csum = 1;\t \n\n\tif (register_netdev(dev)) {\n\t\tDBG_PRINT(ERR_DBG, \"Device registration failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto register_failed;\n\t}\n\ts2io_vpd_read(sp);\n\tDBG_PRINT(ERR_DBG, \"Copyright(c) 2002-2010 Exar Corp.\\n\");\n\tDBG_PRINT(ERR_DBG, \"%s: Neterion %s (rev %d)\\n\", dev->name,\n\t\t  sp->product_name, pdev->revision);\n\tDBG_PRINT(ERR_DBG, \"%s: Driver version %s\\n\", dev->name,\n\t\t  s2io_driver_version);\n\tDBG_PRINT(ERR_DBG, \"%s: MAC Address: %pM\\n\", dev->name, dev->dev_addr);\n\tDBG_PRINT(ERR_DBG, \"Serial number: %s\\n\", sp->serial_num);\n\tif (sp->device_type & XFRAME_II_DEVICE) {\n\t\tmode = s2io_print_pci_mode(sp);\n\t\tif (mode < 0) {\n\t\t\tret = -EBADSLT;\n\t\t\tunregister_netdev(dev);\n\t\t\tgoto set_swap_failed;\n\t\t}\n\t}\n\tswitch (sp->rxd_mode) {\n\tcase RXD_MODE_1:\n\t\tDBG_PRINT(ERR_DBG, \"%s: 1-Buffer receive mode enabled\\n\",\n\t\t\t  dev->name);\n\t\tbreak;\n\tcase RXD_MODE_3B:\n\t\tDBG_PRINT(ERR_DBG, \"%s: 2-Buffer receive mode enabled\\n\",\n\t\t\t  dev->name);\n\t\tbreak;\n\t}\n\n\tswitch (sp->config.napi) {\n\tcase 0:\n\t\tDBG_PRINT(ERR_DBG, \"%s: NAPI disabled\\n\", dev->name);\n\t\tbreak;\n\tcase 1:\n\t\tDBG_PRINT(ERR_DBG, \"%s: NAPI enabled\\n\", dev->name);\n\t\tbreak;\n\t}\n\n\tDBG_PRINT(ERR_DBG, \"%s: Using %d Tx fifo(s)\\n\", dev->name,\n\t\t  sp->config.tx_fifo_num);\n\n\tDBG_PRINT(ERR_DBG, \"%s: Using %d Rx ring(s)\\n\", dev->name,\n\t\t  sp->config.rx_ring_num);\n\n\tswitch (sp->config.intr_type) {\n\tcase INTA:\n\t\tDBG_PRINT(ERR_DBG, \"%s: Interrupt type INTA\\n\", dev->name);\n\t\tbreak;\n\tcase MSI_X:\n\t\tDBG_PRINT(ERR_DBG, \"%s: Interrupt type MSI-X\\n\", dev->name);\n\t\tbreak;\n\t}\n\tif (sp->config.multiq) {\n\t\tfor (i = 0; i < sp->config.tx_fifo_num; i++) {\n\t\t\tstruct fifo_info *fifo = &mac_control->fifos[i];\n\n\t\t\tfifo->multiq = config->multiq;\n\t\t}\n\t\tDBG_PRINT(ERR_DBG, \"%s: Multiqueue support enabled\\n\",\n\t\t\t  dev->name);\n\t} else\n\t\tDBG_PRINT(ERR_DBG, \"%s: Multiqueue support disabled\\n\",\n\t\t\t  dev->name);\n\n\tswitch (sp->config.tx_steering_type) {\n\tcase NO_STEERING:\n\t\tDBG_PRINT(ERR_DBG, \"%s: No steering enabled for transmit\\n\",\n\t\t\t  dev->name);\n\t\tbreak;\n\tcase TX_PRIORITY_STEERING:\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"%s: Priority steering enabled for transmit\\n\",\n\t\t\t  dev->name);\n\t\tbreak;\n\tcase TX_DEFAULT_STEERING:\n\t\tDBG_PRINT(ERR_DBG,\n\t\t\t  \"%s: Default steering enabled for transmit\\n\",\n\t\t\t  dev->name);\n\t}\n\n\tDBG_PRINT(ERR_DBG, \"%s: Large receive offload enabled\\n\",\n\t\t  dev->name);\n\t \n\tsnprintf(sp->name, sizeof(sp->name), \"%s Neterion %s\", dev->name,\n\t\t sp->product_name);\n\n\tif (vlan_tag_strip)\n\t\tsp->vlan_strip_flag = 1;\n\telse\n\t\tsp->vlan_strip_flag = 0;\n\n\t \n\tnetif_carrier_off(dev);\n\n\treturn 0;\n\nregister_failed:\nset_swap_failed:\n\tiounmap(sp->bar1);\nbar1_remap_failed:\n\tiounmap(sp->bar0);\nbar0_remap_failed:\nmem_alloc_failed:\n\tfree_shared_mem(sp);\n\tpci_disable_device(pdev);\n\tpci_release_regions(pdev);\n\tfree_netdev(dev);\n\n\treturn ret;\n}\n\n \n\nstatic void s2io_rem_nic(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct s2io_nic *sp;\n\n\tif (dev == NULL) {\n\t\tDBG_PRINT(ERR_DBG, \"Driver Data is NULL!!\\n\");\n\t\treturn;\n\t}\n\n\tsp = netdev_priv(dev);\n\n\tcancel_work_sync(&sp->rst_timer_task);\n\tcancel_work_sync(&sp->set_link_task);\n\n\tunregister_netdev(dev);\n\n\tfree_shared_mem(sp);\n\tiounmap(sp->bar0);\n\tiounmap(sp->bar1);\n\tpci_release_regions(pdev);\n\tfree_netdev(dev);\n\tpci_disable_device(pdev);\n}\n\nmodule_pci_driver(s2io_driver);\n\nstatic int check_L2_lro_capable(u8 *buffer, struct iphdr **ip,\n\t\t\t\tstruct tcphdr **tcp, struct RxD_t *rxdp,\n\t\t\t\tstruct s2io_nic *sp)\n{\n\tint ip_off;\n\tu8 l2_type = (u8)((rxdp->Control_1 >> 37) & 0x7), ip_len;\n\n\tif (!(rxdp->Control_1 & RXD_FRAME_PROTO_TCP)) {\n\t\tDBG_PRINT(INIT_DBG,\n\t\t\t  \"%s: Non-TCP frames not supported for LRO\\n\",\n\t\t\t  __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tif ((l2_type == 0) || (l2_type == 4)) {\n\t\tip_off = HEADER_ETHERNET_II_802_3_SIZE;\n\t\t \n\t\tif ((!sp->vlan_strip_flag) &&\n\t\t    (rxdp->Control_1 & RXD_FRAME_VLAN_TAG))\n\t\t\tip_off += HEADER_VLAN_SIZE;\n\t} else {\n\t\t \n\t\treturn -1;\n\t}\n\n\t*ip = (struct iphdr *)(buffer + ip_off);\n\tip_len = (u8)((*ip)->ihl);\n\tip_len <<= 2;\n\t*tcp = (struct tcphdr *)((unsigned long)*ip + ip_len);\n\n\treturn 0;\n}\n\nstatic int check_for_socket_match(struct lro *lro, struct iphdr *ip,\n\t\t\t\t  struct tcphdr *tcp)\n{\n\tDBG_PRINT(INFO_DBG, \"%s: Been here...\\n\", __func__);\n\tif ((lro->iph->saddr != ip->saddr) ||\n\t    (lro->iph->daddr != ip->daddr) ||\n\t    (lro->tcph->source != tcp->source) ||\n\t    (lro->tcph->dest != tcp->dest))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic inline int get_l4_pyld_length(struct iphdr *ip, struct tcphdr *tcp)\n{\n\treturn ntohs(ip->tot_len) - (ip->ihl << 2) - (tcp->doff << 2);\n}\n\nstatic void initiate_new_session(struct lro *lro, u8 *l2h,\n\t\t\t\t struct iphdr *ip, struct tcphdr *tcp,\n\t\t\t\t u32 tcp_pyld_len, u16 vlan_tag)\n{\n\tDBG_PRINT(INFO_DBG, \"%s: Been here...\\n\", __func__);\n\tlro->l2h = l2h;\n\tlro->iph = ip;\n\tlro->tcph = tcp;\n\tlro->tcp_next_seq = tcp_pyld_len + ntohl(tcp->seq);\n\tlro->tcp_ack = tcp->ack_seq;\n\tlro->sg_num = 1;\n\tlro->total_len = ntohs(ip->tot_len);\n\tlro->frags_len = 0;\n\tlro->vlan_tag = vlan_tag;\n\t \n\tif (tcp->doff == 8) {\n\t\t__be32 *ptr;\n\t\tptr = (__be32 *)(tcp+1);\n\t\tlro->saw_ts = 1;\n\t\tlro->cur_tsval = ntohl(*(ptr+1));\n\t\tlro->cur_tsecr = *(ptr+2);\n\t}\n\tlro->in_use = 1;\n}\n\nstatic void update_L3L4_header(struct s2io_nic *sp, struct lro *lro)\n{\n\tstruct iphdr *ip = lro->iph;\n\tstruct tcphdr *tcp = lro->tcph;\n\tstruct swStat *swstats = &sp->mac_control.stats_info->sw_stat;\n\n\tDBG_PRINT(INFO_DBG, \"%s: Been here...\\n\", __func__);\n\n\t \n\tcsum_replace2(&ip->check, ip->tot_len, htons(lro->total_len));\n\tip->tot_len = htons(lro->total_len);\n\n\t \n\ttcp->ack_seq = lro->tcp_ack;\n\ttcp->window = lro->window;\n\n\t \n\tif (lro->saw_ts) {\n\t\t__be32 *ptr = (__be32 *)(tcp + 1);\n\t\t*(ptr+2) = lro->cur_tsecr;\n\t}\n\n\t \n\tswstats->sum_avg_pkts_aggregated += lro->sg_num;\n\tswstats->num_aggregations++;\n}\n\nstatic void aggregate_new_rx(struct lro *lro, struct iphdr *ip,\n\t\t\t     struct tcphdr *tcp, u32 l4_pyld)\n{\n\tDBG_PRINT(INFO_DBG, \"%s: Been here...\\n\", __func__);\n\tlro->total_len += l4_pyld;\n\tlro->frags_len += l4_pyld;\n\tlro->tcp_next_seq += l4_pyld;\n\tlro->sg_num++;\n\n\t \n\tlro->tcp_ack = tcp->ack_seq;\n\tlro->window = tcp->window;\n\n\tif (lro->saw_ts) {\n\t\t__be32 *ptr;\n\t\t \n\t\tptr = (__be32 *)(tcp+1);\n\t\tlro->cur_tsval = ntohl(*(ptr+1));\n\t\tlro->cur_tsecr = *(ptr + 2);\n\t}\n}\n\nstatic int verify_l3_l4_lro_capable(struct lro *l_lro, struct iphdr *ip,\n\t\t\t\t    struct tcphdr *tcp, u32 tcp_pyld_len)\n{\n\tu8 *ptr;\n\n\tDBG_PRINT(INFO_DBG, \"%s: Been here...\\n\", __func__);\n\n\tif (!tcp_pyld_len) {\n\t\t \n\t\treturn -1;\n\t}\n\n\tif (ip->ihl != 5)  \n\t\treturn -1;\n\n\t \n\tif (INET_ECN_is_ce(ipv4_get_dsfield(ip)))\n\t\treturn -1;\n\n\t \n\tif (tcp->urg || tcp->psh || tcp->rst ||\n\t    tcp->syn || tcp->fin ||\n\t    tcp->ece || tcp->cwr || !tcp->ack) {\n\t\t \n\t\treturn -1;\n\t}\n\n\t \n\tif (tcp->doff != 5 && tcp->doff != 8)\n\t\treturn -1;\n\n\tif (tcp->doff == 8) {\n\t\tptr = (u8 *)(tcp + 1);\n\t\twhile (*ptr == TCPOPT_NOP)\n\t\t\tptr++;\n\t\tif (*ptr != TCPOPT_TIMESTAMP || *(ptr+1) != TCPOLEN_TIMESTAMP)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (l_lro)\n\t\t\tif (l_lro->cur_tsval > ntohl(*((__be32 *)(ptr+2))))\n\t\t\t\treturn -1;\n\n\t\t \n\t\tif (*((__be32 *)(ptr+6)) == 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int s2io_club_tcp_session(struct ring_info *ring_data, u8 *buffer,\n\t\t\t\t u8 **tcp, u32 *tcp_len, struct lro **lro,\n\t\t\t\t struct RxD_t *rxdp, struct s2io_nic *sp)\n{\n\tstruct iphdr *ip;\n\tstruct tcphdr *tcph;\n\tint ret = 0, i;\n\tu16 vlan_tag = 0;\n\tstruct swStat *swstats = &sp->mac_control.stats_info->sw_stat;\n\n\tret = check_L2_lro_capable(buffer, &ip, (struct tcphdr **)tcp,\n\t\t\t\t   rxdp, sp);\n\tif (ret)\n\t\treturn ret;\n\n\tDBG_PRINT(INFO_DBG, \"IP Saddr: %x Daddr: %x\\n\", ip->saddr, ip->daddr);\n\n\tvlan_tag = RXD_GET_VLAN_TAG(rxdp->Control_2);\n\ttcph = (struct tcphdr *)*tcp;\n\t*tcp_len = get_l4_pyld_length(ip, tcph);\n\tfor (i = 0; i < MAX_LRO_SESSIONS; i++) {\n\t\tstruct lro *l_lro = &ring_data->lro0_n[i];\n\t\tif (l_lro->in_use) {\n\t\t\tif (check_for_socket_match(l_lro, ip, tcph))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\t*lro = l_lro;\n\n\t\t\tif ((*lro)->tcp_next_seq != ntohl(tcph->seq)) {\n\t\t\t\tDBG_PRINT(INFO_DBG, \"%s: Out of sequence. \"\n\t\t\t\t\t  \"expected 0x%x, actual 0x%x\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  (*lro)->tcp_next_seq,\n\t\t\t\t\t  ntohl(tcph->seq));\n\n\t\t\t\tswstats->outof_sequence_pkts++;\n\t\t\t\tret = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!verify_l3_l4_lro_capable(l_lro, ip, tcph,\n\t\t\t\t\t\t      *tcp_len))\n\t\t\t\tret = 1;  \n\t\t\telse\n\t\t\t\tret = 2;  \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\t \n\t\tif (verify_l3_l4_lro_capable(NULL, ip, tcph, *tcp_len))\n\t\t\treturn 5;\n\n\t\tfor (i = 0; i < MAX_LRO_SESSIONS; i++) {\n\t\t\tstruct lro *l_lro = &ring_data->lro0_n[i];\n\t\t\tif (!(l_lro->in_use)) {\n\t\t\t\t*lro = l_lro;\n\t\t\t\tret = 3;  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret == 0) {  \n\t\tDBG_PRINT(INFO_DBG, \"%s: All LRO sessions already in use\\n\",\n\t\t\t  __func__);\n\t\t*lro = NULL;\n\t\treturn ret;\n\t}\n\n\tswitch (ret) {\n\tcase 3:\n\t\tinitiate_new_session(*lro, buffer, ip, tcph, *tcp_len,\n\t\t\t\t     vlan_tag);\n\t\tbreak;\n\tcase 2:\n\t\tupdate_L3L4_header(sp, *lro);\n\t\tbreak;\n\tcase 1:\n\t\taggregate_new_rx(*lro, ip, tcph, *tcp_len);\n\t\tif ((*lro)->sg_num == sp->lro_max_aggr_per_sess) {\n\t\t\tupdate_L3L4_header(sp, *lro);\n\t\t\tret = 4;  \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDBG_PRINT(ERR_DBG, \"%s: Don't know, can't say!!\\n\", __func__);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void clear_lro_session(struct lro *lro)\n{\n\tstatic u16 lro_struct_size = sizeof(struct lro);\n\n\tmemset(lro, 0, lro_struct_size);\n}\n\nstatic void queue_rx_frame(struct sk_buff *skb, u16 vlan_tag)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct s2io_nic *sp = netdev_priv(dev);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tif (vlan_tag && sp->vlan_strip_flag)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);\n\tif (sp->config.napi)\n\t\tnetif_receive_skb(skb);\n\telse\n\t\tnetif_rx(skb);\n}\n\nstatic void lro_append_pkt(struct s2io_nic *sp, struct lro *lro,\n\t\t\t   struct sk_buff *skb, u32 tcp_len)\n{\n\tstruct sk_buff *first = lro->parent;\n\tstruct swStat *swstats = &sp->mac_control.stats_info->sw_stat;\n\n\tfirst->len += tcp_len;\n\tfirst->data_len = lro->frags_len;\n\tskb_pull(skb, (skb->len - tcp_len));\n\tif (skb_shinfo(first)->frag_list)\n\t\tlro->last_frag->next = skb;\n\telse\n\t\tskb_shinfo(first)->frag_list = skb;\n\tfirst->truesize += skb->truesize;\n\tlro->last_frag = skb;\n\tswstats->clubbed_frms_cnt++;\n}\n\n \nstatic pci_ers_result_t s2io_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct s2io_nic *sp = netdev_priv(netdev);\n\n\tnetif_device_detach(netdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (netif_running(netdev)) {\n\t\t \n\t\tdo_s2io_card_down(sp, 0);\n\t}\n\tpci_disable_device(pdev);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t s2io_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct s2io_nic *sp = netdev_priv(netdev);\n\n\tif (pci_enable_device(pdev)) {\n\t\tpr_err(\"Cannot re-enable PCI device after reset.\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tpci_set_master(pdev);\n\ts2io_reset(sp);\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n \nstatic void s2io_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct s2io_nic *sp = netdev_priv(netdev);\n\n\tif (netif_running(netdev)) {\n\t\tif (s2io_card_up(sp)) {\n\t\t\tpr_err(\"Can't bring device back up after reset.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (do_s2io_prog_unicast(netdev, netdev->dev_addr) == FAILURE) {\n\t\t\ts2io_card_down(sp);\n\t\t\tpr_err(\"Can't restore mac addr after reset.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tnetif_device_attach(netdev);\n\tnetif_tx_wake_all_queues(netdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}