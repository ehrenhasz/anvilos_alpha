{
  "module_name": "tc_encap_actions.c",
  "hash_id": "4a08e939237187c7edf880aac3cac99ff9dd9aa3371f4f6d8cbbcdf3b29ea035",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/tc_encap_actions.c",
  "human_readable_source": "\n \n\n#include \"tc_encap_actions.h\"\n#include \"tc.h\"\n#include \"mae.h\"\n#include <net/vxlan.h>\n#include <net/geneve.h>\n#include <net/netevent.h>\n#include <net/arp.h>\n\nstatic const struct rhashtable_params efx_neigh_ht_params = {\n\t.key_len\t= offsetof(struct efx_neigh_binder, ha),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_neigh_binder, linkage),\n};\n\nstatic const struct rhashtable_params efx_tc_encap_ht_params = {\n\t.key_len\t= offsetofend(struct efx_tc_encap_action, key),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_encap_action, linkage),\n};\n\nstatic void efx_tc_encap_free(void *ptr, void *__unused)\n{\n\tstruct efx_tc_encap_action *enc = ptr;\n\n\tWARN_ON(refcount_read(&enc->ref));\n\tkfree(enc);\n}\n\nstatic void efx_neigh_free(void *ptr, void *__unused)\n{\n\tstruct efx_neigh_binder *neigh = ptr;\n\n\tWARN_ON(refcount_read(&neigh->ref));\n\tWARN_ON(!list_empty(&neigh->users));\n\tput_net_track(neigh->net, &neigh->ns_tracker);\n\tnetdev_put(neigh->egdev, &neigh->dev_tracker);\n\tkfree(neigh);\n}\n\nint efx_tc_init_encap_actions(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = rhashtable_init(&efx->tc->neigh_ht, &efx_neigh_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_neigh_ht;\n\trc = rhashtable_init(&efx->tc->encap_ht, &efx_tc_encap_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_encap_ht;\n\treturn 0;\nfail_encap_ht:\n\trhashtable_destroy(&efx->tc->neigh_ht);\nfail_neigh_ht:\n\treturn rc;\n}\n\n \nvoid efx_tc_destroy_encap_actions(struct efx_nic *efx)\n{\n\trhashtable_destroy(&efx->tc->encap_ht);\n\trhashtable_destroy(&efx->tc->neigh_ht);\n}\n\nvoid efx_tc_fini_encap_actions(struct efx_nic *efx)\n{\n\trhashtable_free_and_destroy(&efx->tc->encap_ht, efx_tc_encap_free, NULL);\n\trhashtable_free_and_destroy(&efx->tc->neigh_ht, efx_neigh_free, NULL);\n}\n\nstatic void efx_neigh_update(struct work_struct *work);\n\nstatic int efx_bind_neigh(struct efx_nic *efx,\n\t\t\t  struct efx_tc_encap_action *encap, struct net *net,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct efx_neigh_binder *neigh, *old;\n\tstruct flowi6 flow6 = {};\n\tstruct flowi4 flow4 = {};\n\tint rc;\n\n\t \n\tswitch ((int)encap->type) {\n\tcase EFX_ENCAP_TYPE_VXLAN:\n\tcase EFX_ENCAP_TYPE_GENEVE:\n\t\tflow4.flowi4_proto = IPPROTO_UDP;\n\t\tflow4.fl4_dport = encap->key.tp_dst;\n\t\tflow4.flowi4_tos = encap->key.tos;\n\t\tflow4.daddr = encap->key.u.ipv4.dst;\n\t\tflow4.saddr = encap->key.u.ipv4.src;\n\t\tbreak;\n\tcase EFX_ENCAP_TYPE_VXLAN | EFX_ENCAP_FLAG_IPV6:\n\tcase EFX_ENCAP_TYPE_GENEVE | EFX_ENCAP_FLAG_IPV6:\n\t\tflow6.flowi6_proto = IPPROTO_UDP;\n\t\tflow6.fl6_dport = encap->key.tp_dst;\n\t\tflow6.flowlabel = ip6_make_flowinfo(encap->key.tos,\n\t\t\t\t\t\t    encap->key.label);\n\t\tflow6.daddr = encap->key.u.ipv6.dst;\n\t\tflow6.saddr = encap->key.u.ipv6.src;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unsupported encap type %d\",\n\t\t\t\t       (int)encap->type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tneigh = kzalloc(sizeof(*neigh), GFP_KERNEL_ACCOUNT);\n\tif (!neigh)\n\t\treturn -ENOMEM;\n\tneigh->net = get_net_track(net, &neigh->ns_tracker, GFP_KERNEL_ACCOUNT);\n\tneigh->dst_ip = flow4.daddr;\n\tneigh->dst_ip6 = flow6.daddr;\n\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->neigh_ht,\n\t\t\t\t\t\t&neigh->linkage,\n\t\t\t\t\t\tefx_neigh_ht_params);\n\tif (old) {\n\t\t \n\t\tput_net_track(neigh->net, &neigh->ns_tracker);\n\t\tkfree(neigh);\n\t\tif (IS_ERR(old))  \n\t\t\treturn PTR_ERR(old);\n\t\tif (!refcount_inc_not_zero(&old->ref))\n\t\t\treturn -EAGAIN;\n\t\t \n\t\tneigh = old;\n\t} else {\n\t\t \n\t\tstruct neighbour *n;\n\t\tstruct rtable *rt;\n\n\t\tif (encap->type & EFX_ENCAP_FLAG_IPV6) {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tstruct dst_entry *dst;\n\n\t\t\tdst = ipv6_stub->ipv6_dst_lookup_flow(net, NULL, &flow6,\n\t\t\t\t\t\t\t      NULL);\n\t\t\trc = PTR_ERR_OR_ZERO(dst);\n\t\t\tif (rc) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to lookup route for IPv6 encap\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tneigh->egdev = dst->dev;\n\t\t\tnetdev_hold(neigh->egdev, &neigh->dev_tracker,\n\t\t\t\t    GFP_KERNEL_ACCOUNT);\n\t\t\tneigh->ttl = ip6_dst_hoplimit(dst);\n\t\t\tn = dst_neigh_lookup(dst, &flow6.daddr);\n\t\t\tdst_release(dst);\n#else\n\t\t\t \n\t\t\trc = -EOPNOTSUPP;\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No IPv6 support (neigh bind)\");\n\t\t\tgoto out_free;\n#endif\n\t\t} else {\n\t\t\trt = ip_route_output_key(net, &flow4);\n\t\t\tif (IS_ERR_OR_NULL(rt)) {\n\t\t\t\trc = PTR_ERR_OR_ZERO(rt);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = -EIO;\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to lookup route for encap\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tneigh->egdev = rt->dst.dev;\n\t\t\tnetdev_hold(neigh->egdev, &neigh->dev_tracker,\n\t\t\t\t    GFP_KERNEL_ACCOUNT);\n\t\t\tneigh->ttl = ip4_dst_hoplimit(&rt->dst);\n\t\t\tn = dst_neigh_lookup(&rt->dst, &flow4.daddr);\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tif (!n) {\n\t\t\trc = -ENETUNREACH;\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to lookup neighbour for encap\");\n\t\t\tnetdev_put(neigh->egdev, &neigh->dev_tracker);\n\t\t\tgoto out_free;\n\t\t}\n\t\trefcount_set(&neigh->ref, 1);\n\t\tINIT_LIST_HEAD(&neigh->users);\n\t\tread_lock_bh(&n->lock);\n\t\tether_addr_copy(neigh->ha, n->ha);\n\t\tneigh->n_valid = n->nud_state & NUD_VALID;\n\t\tread_unlock_bh(&n->lock);\n\t\trwlock_init(&neigh->lock);\n\t\tINIT_WORK(&neigh->work, efx_neigh_update);\n\t\tneigh->efx = efx;\n\t\tneigh->used = jiffies;\n\t\tif (!neigh->n_valid)\n\t\t\t \n\t\t\tneigh_event_send(n, NULL);\n\t\tneigh_release(n);\n\t}\n\t \n\tencap->neigh = neigh;\n\tlist_add_tail(&encap->list, &neigh->users);\n\treturn 0;\n\nout_free:\n\t \n\trhashtable_remove_fast(&efx->tc->neigh_ht, &neigh->linkage,\n\t\t\t       efx_neigh_ht_params);\n\tsynchronize_rcu();\n\tput_net_track(net, &neigh->ns_tracker);\n\tkfree(neigh);\n\treturn rc;\n}\n\nstatic void efx_free_neigh(struct efx_neigh_binder *neigh)\n{\n\tstruct efx_nic *efx = neigh->efx;\n\n\trhashtable_remove_fast(&efx->tc->neigh_ht, &neigh->linkage,\n\t\t\t       efx_neigh_ht_params);\n\tsynchronize_rcu();\n\tnetdev_put(neigh->egdev, &neigh->dev_tracker);\n\tput_net_track(neigh->net, &neigh->ns_tracker);\n\tkfree(neigh);\n}\n\nstatic void efx_release_neigh(struct efx_nic *efx,\n\t\t\t      struct efx_tc_encap_action *encap)\n{\n\tstruct efx_neigh_binder *neigh = encap->neigh;\n\n\tif (!neigh)\n\t\treturn;\n\tlist_del(&encap->list);\n\tencap->neigh = NULL;\n\tif (!refcount_dec_and_test(&neigh->ref))\n\t\treturn;  \n\tefx_free_neigh(neigh);\n}\n\nstatic void efx_gen_tun_header_eth(struct efx_tc_encap_action *encap, u16 proto)\n{\n\tstruct efx_neigh_binder *neigh = encap->neigh;\n\tstruct ethhdr *eth;\n\n\tencap->encap_hdr_len = sizeof(*eth);\n\teth = (struct ethhdr *)encap->encap_hdr;\n\n\tif (encap->neigh->n_valid)\n\t\tether_addr_copy(eth->h_dest, neigh->ha);\n\telse\n\t\teth_zero_addr(eth->h_dest);\n\tether_addr_copy(eth->h_source, neigh->egdev->dev_addr);\n\teth->h_proto = htons(proto);\n}\n\nstatic void efx_gen_tun_header_ipv4(struct efx_tc_encap_action *encap, u8 ipproto, u8 len)\n{\n\tstruct efx_neigh_binder *neigh = encap->neigh;\n\tstruct ip_tunnel_key *key = &encap->key;\n\tstruct iphdr *ip;\n\n\tip = (struct iphdr *)(encap->encap_hdr + encap->encap_hdr_len);\n\tencap->encap_hdr_len += sizeof(*ip);\n\n\tip->daddr = key->u.ipv4.dst;\n\tip->saddr = key->u.ipv4.src;\n\tip->ttl = neigh->ttl;\n\tip->protocol = ipproto;\n\tip->version = 0x4;\n\tip->ihl = 0x5;\n\tip->tot_len = cpu_to_be16(ip->ihl * 4 + len);\n\tip_send_check(ip);\n}\n\n#ifdef CONFIG_IPV6\nstatic void efx_gen_tun_header_ipv6(struct efx_tc_encap_action *encap, u8 ipproto, u8 len)\n{\n\tstruct efx_neigh_binder *neigh = encap->neigh;\n\tstruct ip_tunnel_key *key = &encap->key;\n\tstruct ipv6hdr *ip;\n\n\tip = (struct ipv6hdr *)(encap->encap_hdr + encap->encap_hdr_len);\n\tencap->encap_hdr_len += sizeof(*ip);\n\n\tip6_flow_hdr(ip, key->tos, key->label);\n\tip->daddr = key->u.ipv6.dst;\n\tip->saddr = key->u.ipv6.src;\n\tip->hop_limit = neigh->ttl;\n\tip->nexthdr = ipproto;\n\tip->version = 0x6;\n\tip->payload_len = cpu_to_be16(len);\n}\n#endif\n\nstatic void efx_gen_tun_header_udp(struct efx_tc_encap_action *encap, u8 len)\n{\n\tstruct ip_tunnel_key *key = &encap->key;\n\tstruct udphdr *udp;\n\n\tudp = (struct udphdr *)(encap->encap_hdr + encap->encap_hdr_len);\n\tencap->encap_hdr_len += sizeof(*udp);\n\n\tudp->dest = key->tp_dst;\n\tudp->len = cpu_to_be16(sizeof(*udp) + len);\n}\n\nstatic void efx_gen_tun_header_vxlan(struct efx_tc_encap_action *encap)\n{\n\tstruct ip_tunnel_key *key = &encap->key;\n\tstruct vxlanhdr *vxlan;\n\n\tvxlan = (struct vxlanhdr *)(encap->encap_hdr + encap->encap_hdr_len);\n\tencap->encap_hdr_len += sizeof(*vxlan);\n\n\tvxlan->vx_flags = VXLAN_HF_VNI;\n\tvxlan->vx_vni = vxlan_vni_field(tunnel_id_to_key32(key->tun_id));\n}\n\nstatic void efx_gen_tun_header_geneve(struct efx_tc_encap_action *encap)\n{\n\tstruct ip_tunnel_key *key = &encap->key;\n\tstruct genevehdr *geneve;\n\tu32 vni;\n\n\tgeneve = (struct genevehdr *)(encap->encap_hdr + encap->encap_hdr_len);\n\tencap->encap_hdr_len += sizeof(*geneve);\n\n\tgeneve->proto_type = htons(ETH_P_TEB);\n\t \n\tvni = ntohl(tunnel_id_to_key32(key->tun_id));\n\tgeneve->vni[0] = vni >> 16;\n\tgeneve->vni[1] = vni >> 8;\n\tgeneve->vni[2] = vni;\n}\n\n#define vxlan_header_l4_len\t(sizeof(struct udphdr) + sizeof(struct vxlanhdr))\n#define vxlan4_header_len\t(sizeof(struct ethhdr) + sizeof(struct iphdr) + vxlan_header_l4_len)\nstatic void efx_gen_vxlan_header_ipv4(struct efx_tc_encap_action *encap)\n{\n\tBUILD_BUG_ON(sizeof(encap->encap_hdr) < vxlan4_header_len);\n\tefx_gen_tun_header_eth(encap, ETH_P_IP);\n\tefx_gen_tun_header_ipv4(encap, IPPROTO_UDP, vxlan_header_l4_len);\n\tefx_gen_tun_header_udp(encap, sizeof(struct vxlanhdr));\n\tefx_gen_tun_header_vxlan(encap);\n}\n\n#define geneve_header_l4_len\t(sizeof(struct udphdr) + sizeof(struct genevehdr))\n#define geneve4_header_len\t(sizeof(struct ethhdr) + sizeof(struct iphdr) + geneve_header_l4_len)\nstatic void efx_gen_geneve_header_ipv4(struct efx_tc_encap_action *encap)\n{\n\tBUILD_BUG_ON(sizeof(encap->encap_hdr) < geneve4_header_len);\n\tefx_gen_tun_header_eth(encap, ETH_P_IP);\n\tefx_gen_tun_header_ipv4(encap, IPPROTO_UDP, geneve_header_l4_len);\n\tefx_gen_tun_header_udp(encap, sizeof(struct genevehdr));\n\tefx_gen_tun_header_geneve(encap);\n}\n\n#ifdef CONFIG_IPV6\n#define vxlan6_header_len\t(sizeof(struct ethhdr) + sizeof(struct ipv6hdr) + vxlan_header_l4_len)\nstatic void efx_gen_vxlan_header_ipv6(struct efx_tc_encap_action *encap)\n{\n\tBUILD_BUG_ON(sizeof(encap->encap_hdr) < vxlan6_header_len);\n\tefx_gen_tun_header_eth(encap, ETH_P_IPV6);\n\tefx_gen_tun_header_ipv6(encap, IPPROTO_UDP, vxlan_header_l4_len);\n\tefx_gen_tun_header_udp(encap, sizeof(struct vxlanhdr));\n\tefx_gen_tun_header_vxlan(encap);\n}\n\n#define geneve6_header_len\t(sizeof(struct ethhdr) + sizeof(struct ipv6hdr) + geneve_header_l4_len)\nstatic void efx_gen_geneve_header_ipv6(struct efx_tc_encap_action *encap)\n{\n\tBUILD_BUG_ON(sizeof(encap->encap_hdr) < geneve6_header_len);\n\tefx_gen_tun_header_eth(encap, ETH_P_IPV6);\n\tefx_gen_tun_header_ipv6(encap, IPPROTO_UDP, geneve_header_l4_len);\n\tefx_gen_tun_header_udp(encap, sizeof(struct genevehdr));\n\tefx_gen_tun_header_geneve(encap);\n}\n#endif\n\nstatic void efx_gen_encap_header(struct efx_nic *efx,\n\t\t\t\t struct efx_tc_encap_action *encap)\n{\n\tencap->n_valid = encap->neigh->n_valid;\n\n\t \n\tswitch ((int)encap->type) {\n\tcase EFX_ENCAP_TYPE_VXLAN:\n\t\tefx_gen_vxlan_header_ipv4(encap);\n\t\tbreak;\n\tcase EFX_ENCAP_TYPE_GENEVE:\n\t\tefx_gen_geneve_header_ipv4(encap);\n\t\tbreak;\n#ifdef CONFIG_IPV6\n\tcase EFX_ENCAP_TYPE_VXLAN | EFX_ENCAP_FLAG_IPV6:\n\t\tefx_gen_vxlan_header_ipv6(encap);\n\t\tbreak;\n\tcase EFX_ENCAP_TYPE_GENEVE | EFX_ENCAP_FLAG_IPV6:\n\t\tefx_gen_geneve_header_ipv6(encap);\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\tif (net_ratelimit())\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"Bogus encap type %d, can't generate\\n\",\n\t\t\t\t  encap->type);\n\n\t\t \n\t\tencap->n_valid = false;\n\t\tbreak;\n\t}\n}\n\nstatic void efx_tc_update_encap(struct efx_nic *efx,\n\t\t\t\tstruct efx_tc_encap_action *encap)\n{\n\tstruct efx_tc_action_set_list *acts, *fallback;\n\tstruct efx_tc_flow_rule *rule;\n\tstruct efx_tc_action_set *act;\n\tint rc;\n\n\tif (encap->n_valid) {\n\t\t \n\t\tlist_for_each_entry(act, &encap->users, encap_user) {\n\t\t\tacts = act->user;\n\t\t\tif (WARN_ON(!acts))  \n\t\t\t\tcontinue;\n\t\t\trule = container_of(acts, struct efx_tc_flow_rule, acts);\n\t\t\tif (rule->fallback)\n\t\t\t\tfallback = rule->fallback;\n\t\t\telse  \n\t\t\t\tfallback = &efx->tc->facts.pf;\n\t\t\trc = efx_mae_update_rule(efx, fallback->fw_id,\n\t\t\t\t\t\t rule->fw_id);\n\t\t\tif (rc)\n\t\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t\t  \"Failed to update (f) rule %08x rc %d\\n\",\n\t\t\t\t\t  rule->fw_id, rc);\n\t\t\telse\n\t\t\t\tnetif_dbg(efx, drv, efx->net_dev, \"Updated (f) rule %08x\\n\",\n\t\t\t\t\t  rule->fw_id);\n\t\t}\n\t}\n\n\t \n\tmemset(encap->encap_hdr, 0, sizeof(encap->encap_hdr));\n\tencap->encap_hdr_len = ETH_HLEN;\n\n\tif (encap->neigh) {\n\t\tread_lock_bh(&encap->neigh->lock);\n\t\tefx_gen_encap_header(efx, encap);\n\t\tread_unlock_bh(&encap->neigh->lock);\n\t} else {\n\t\tencap->n_valid = false;\n\t}\n\n\trc = efx_mae_update_encap_md(efx, encap);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Failed to update encap hdr %08x rc %d\\n\",\n\t\t\t  encap->fw_id, rc);\n\t\treturn;\n\t}\n\tnetif_dbg(efx, drv, efx->net_dev, \"Updated encap hdr %08x\\n\",\n\t\t  encap->fw_id);\n\tif (!encap->n_valid)\n\t\treturn;\n\t \n\tlist_for_each_entry(act, &encap->users, encap_user) {\n\t\tacts = act->user;\n\t\tif (WARN_ON(!acts))  \n\t\t\tcontinue;\n\t\trule = container_of(acts, struct efx_tc_flow_rule, acts);\n\t\tif (!efx_tc_check_ready(efx, rule))\n\t\t\tcontinue;\n\t\trc = efx_mae_update_rule(efx, acts->fw_id, rule->fw_id);\n\t\tif (rc)\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"Failed to update rule %08x rc %d\\n\",\n\t\t\t\t  rule->fw_id, rc);\n\t\telse\n\t\t\tnetif_dbg(efx, drv, efx->net_dev, \"Updated rule %08x\\n\",\n\t\t\t\t  rule->fw_id);\n\t}\n}\n\nstatic void efx_neigh_update(struct work_struct *work)\n{\n\tstruct efx_neigh_binder *neigh = container_of(work, struct efx_neigh_binder, work);\n\tstruct efx_tc_encap_action *encap;\n\tstruct efx_nic *efx = neigh->efx;\n\n\tmutex_lock(&efx->tc->mutex);\n\tlist_for_each_entry(encap, &neigh->users, list)\n\t\tefx_tc_update_encap(neigh->efx, encap);\n\t \n\tif (refcount_dec_and_test(&neigh->ref))\n\t\tefx_free_neigh(neigh);\n\tmutex_unlock(&efx->tc->mutex);\n}\n\nstatic int efx_neigh_event(struct efx_nic *efx, struct neighbour *n)\n{\n\tstruct efx_neigh_binder keys = {NULL}, *neigh;\n\tbool n_valid, ipv6 = false;\n\tchar ha[ETH_ALEN];\n\tsize_t keysize;\n\n\tif (WARN_ON(!efx->tc))\n\t\treturn NOTIFY_DONE;\n\n\tif (n->tbl == &arp_tbl) {\n\t\tkeysize = sizeof(keys.dst_ip);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (n->tbl == ipv6_stub->nd_tbl) {\n\t\tipv6 = true;\n\t\tkeysize = sizeof(keys.dst_ip6);\n#endif\n\t} else {\n\t\treturn NOTIFY_DONE;\n\t}\n\tif (!n->parms) {\n\t\tnetif_warn(efx, drv, efx->net_dev, \"neigh_event with no parms!\\n\");\n\t\treturn NOTIFY_DONE;\n\t}\n\tkeys.net = read_pnet(&n->parms->net);\n\tif (n->tbl->key_len != keysize) {\n\t\tnetif_warn(efx, drv, efx->net_dev, \"neigh_event with bad key_len %u\\n\",\n\t\t\t   n->tbl->key_len);\n\t\treturn NOTIFY_DONE;\n\t}\n\tread_lock_bh(&n->lock);  \n\tmemcpy(ha, n->ha, ETH_ALEN);\n\tn_valid = (n->nud_state & NUD_VALID) && !n->dead;\n\tread_unlock_bh(&n->lock);\n\tif (ipv6)\n\t\tmemcpy(&keys.dst_ip6, n->primary_key, n->tbl->key_len);\n\telse\n\t\tmemcpy(&keys.dst_ip, n->primary_key, n->tbl->key_len);\n\trcu_read_lock();\n\tneigh = rhashtable_lookup_fast(&efx->tc->neigh_ht, &keys,\n\t\t\t\t       efx_neigh_ht_params);\n\tif (!neigh || neigh->dying)\n\t\t \n\t\tgoto done;\n\twrite_lock_bh(&neigh->lock);\n\tif (n_valid == neigh->n_valid && !memcmp(ha, neigh->ha, ETH_ALEN)) {\n\t\twrite_unlock_bh(&neigh->lock);\n\t\t \n\t\tgoto done;\n\t}\n\tneigh->n_valid = n_valid;\n\tmemcpy(neigh->ha, ha, ETH_ALEN);\n\twrite_unlock_bh(&neigh->lock);\n\tif (refcount_inc_not_zero(&neigh->ref)) {\n\t\trcu_read_unlock();\n\t\tif (!schedule_work(&neigh->work))\n\t\t\t \n\t\t\tif (refcount_dec_and_test(&neigh->ref))\n\t\t\t\tefx_free_neigh(neigh);\n\t} else {\ndone:\n\t\trcu_read_unlock();\n\t}\n\treturn NOTIFY_DONE;\n}\n\nbool efx_tc_check_ready(struct efx_nic *efx, struct efx_tc_flow_rule *rule)\n{\n\tstruct efx_tc_action_set *act;\n\n\t \n\tlist_for_each_entry(act, &rule->acts.list, list)\n\t\tif (act->encap_md && !act->encap_md->n_valid)\n\t\t\treturn false;\n\treturn true;\n}\n\nstruct efx_tc_encap_action *efx_tc_flower_create_encap_md(\n\t\t\tstruct efx_nic *efx, const struct ip_tunnel_info *info,\n\t\t\tstruct net_device *egdev, struct netlink_ext_ack *extack)\n{\n\tenum efx_encap_type type = efx_tc_indr_netdev_type(egdev);\n\tstruct efx_tc_encap_action *encap, *old;\n\tstruct efx_rep *to_efv;\n\ts64 rc;\n\n\tif (type == EFX_ENCAP_TYPE_NONE) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"Not a (supported) tunnel device but tunnel_key is set\");\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\trc = efx_mae_check_encap_type_supported(efx, type);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware reports no support for this tunnel type\");\n\t\treturn ERR_PTR(rc);\n\t}\n\t \n\tif (info->options_len) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported tunnel options\");\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tswitch (info->mode) {\n\tcase IP_TUNNEL_INFO_TX:\n\t\tbreak;\n\tcase IP_TUNNEL_INFO_TX | IP_TUNNEL_INFO_IPV6:\n\t\ttype |= EFX_ENCAP_FLAG_IPV6;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unsupported tunnel mode %u\",\n\t\t\t\t       info->mode);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tencap = kzalloc(sizeof(*encap), GFP_KERNEL_ACCOUNT);\n\tif (!encap)\n\t\treturn ERR_PTR(-ENOMEM);\n\tencap->type = type;\n\tencap->key = info->key;\n\tINIT_LIST_HEAD(&encap->users);\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->encap_ht,\n\t\t\t\t\t\t&encap->linkage,\n\t\t\t\t\t\tefx_tc_encap_ht_params);\n\tif (old) {\n\t\t \n\t\tkfree(encap);\n\t\tif (IS_ERR(old))  \n\t\t\treturn ERR_CAST(old);\n\t\tif (!refcount_inc_not_zero(&old->ref))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t \n\t\treturn old;\n\t}\n\n\trc = efx_bind_neigh(efx, encap, dev_net(egdev), extack);\n\tif (rc < 0)\n\t\tgoto out_remove;\n\tto_efv = efx_tc_flower_lookup_efv(efx, encap->neigh->egdev);\n\tif (IS_ERR(to_efv)) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"Tunnel egress device not on switch\");\n\t\trc = PTR_ERR(to_efv);\n\t\tgoto out_release;\n\t}\n\trc = efx_tc_flower_external_mport(efx, to_efv);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to identify tunnel egress m-port\");\n\t\tgoto out_release;\n\t}\n\tencap->dest_mport = rc;\n\tread_lock_bh(&encap->neigh->lock);\n\tefx_gen_encap_header(efx, encap);\n\tread_unlock_bh(&encap->neigh->lock);\n\n\trc = efx_mae_allocate_encap_md(efx, encap);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write tunnel header to hw\");\n\t\tgoto out_release;\n\t}\n\n\t \n\trefcount_set(&encap->ref, 1);\n\treturn encap;\nout_release:\n\tefx_release_neigh(efx, encap);\nout_remove:\n\trhashtable_remove_fast(&efx->tc->encap_ht, &encap->linkage,\n\t\t\t       efx_tc_encap_ht_params);\n\tkfree(encap);\n\treturn ERR_PTR(rc);\n}\n\nvoid efx_tc_flower_release_encap_md(struct efx_nic *efx,\n\t\t\t\t    struct efx_tc_encap_action *encap)\n{\n\tif (!refcount_dec_and_test(&encap->ref))\n\t\treturn;  \n\tefx_release_neigh(efx, encap);\n\trhashtable_remove_fast(&efx->tc->encap_ht, &encap->linkage,\n\t\t\t       efx_tc_encap_ht_params);\n\tefx_mae_free_encap_md(efx, encap);\n\tkfree(encap);\n}\n\nstatic void efx_tc_remove_neigh_users(struct efx_nic *efx, struct efx_neigh_binder *neigh)\n{\n\tstruct efx_tc_encap_action *encap, *next;\n\n\tlist_for_each_entry_safe(encap, next, &neigh->users, list) {\n\t\t \n\t\tefx_release_neigh(efx, encap);\n\t\t \n\t\tefx_tc_update_encap(efx, encap);\n\t}\n}\n\nvoid efx_tc_unregister_egdev(struct efx_nic *efx, struct net_device *net_dev)\n{\n\tstruct efx_neigh_binder *neigh;\n\tstruct rhashtable_iter walk;\n\n\tmutex_lock(&efx->tc->mutex);\n\trhashtable_walk_enter(&efx->tc->neigh_ht, &walk);\n\trhashtable_walk_start(&walk);\n\twhile ((neigh = rhashtable_walk_next(&walk)) != NULL) {\n\t\tif (IS_ERR(neigh))\n\t\t\tcontinue;\n\t\tif (neigh->egdev != net_dev)\n\t\t\tcontinue;\n\t\tneigh->dying = true;\n\t\trhashtable_walk_stop(&walk);\n\t\tsynchronize_rcu();  \n\t\tefx_tc_remove_neigh_users(efx, neigh);  \n\t\trhashtable_walk_start(&walk);\n\t}\n\trhashtable_walk_stop(&walk);\n\trhashtable_walk_exit(&walk);\n\tmutex_unlock(&efx->tc->mutex);\n}\n\nint efx_tc_netevent_event(struct efx_nic *efx, unsigned long event,\n\t\t\t  void *ptr)\n{\n\tif (efx->type->is_vf)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\treturn efx_neigh_event(efx, ptr);\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}