{
  "module_name": "nic_common.h",
  "hash_id": "89d8c05dc1c61fbd11d8e813891fe923e5248b87c36e2668e39e4c6331039df9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/nic_common.h",
  "human_readable_source": " \n \n\n#ifndef EFX_NIC_COMMON_H\n#define EFX_NIC_COMMON_H\n\n#include \"net_driver.h\"\n#include \"efx_common.h\"\n#include \"mcdi.h\"\n#include \"ptp.h\"\n\nenum {\n\t \n\tEFX_REV_HUNT_A0 = 4,\n\tEFX_REV_EF100 = 5,\n};\n\nstatic inline int efx_nic_rev(struct efx_nic *efx)\n{\n\treturn efx->type->revision;\n}\n\n \nstatic inline efx_qword_t *efx_event(struct efx_channel *channel,\n\t\t\t\t     unsigned int index)\n{\n\treturn ((efx_qword_t *)(channel->eventq.addr)) +\n\t\t(index & channel->eventq_mask);\n}\n\n \nstatic inline int efx_event_present(efx_qword_t *event)\n{\n\treturn !(EFX_DWORD_IS_ALL_ONES(event->dword[0]) |\n\t\t  EFX_DWORD_IS_ALL_ONES(event->dword[1]));\n}\n\n \nstatic inline efx_qword_t *\nefx_tx_desc(struct efx_tx_queue *tx_queue, unsigned int index)\n{\n\treturn ((efx_qword_t *)(tx_queue->txd.addr)) + index;\n}\n\n \nstatic inline bool efx_nic_tx_is_empty(struct efx_tx_queue *tx_queue, unsigned int write_count)\n{\n\tunsigned int empty_read_count = READ_ONCE(tx_queue->empty_read_count);\n\n\tif (empty_read_count == 0)\n\t\treturn false;\n\n\treturn ((empty_read_count ^ write_count) & ~EFX_EMPTY_COUNT_VALID) == 0;\n}\n\nint efx_enqueue_skb_tso(struct efx_tx_queue *tx_queue, struct sk_buff *skb,\n\t\t\tbool *data_mapped);\n\n \nstatic inline bool efx_nic_may_push_tx_desc(struct efx_tx_queue *tx_queue,\n\t\t\t\t\t    unsigned int write_count)\n{\n\tbool was_empty = efx_nic_tx_is_empty(tx_queue, write_count);\n\n\ttx_queue->empty_read_count = 0;\n\treturn was_empty && tx_queue->write_count - write_count == 1;\n}\n\n \nstatic inline efx_qword_t *\nefx_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)\n{\n\treturn ((efx_qword_t *)(rx_queue->rxd.addr)) + index;\n}\n\n \n#define EFX_PAGE_SIZE\t4096\n \n#define EFX_BUF_SIZE\tEFX_PAGE_SIZE\n\n \nenum {\n\tGENERIC_STAT_rx_noskb_drops,\n\tGENERIC_STAT_rx_nodesc_trunc,\n\tGENERIC_STAT_COUNT\n};\n\n#define EFX_GENERIC_SW_STAT(ext_name)\t\t\t\t\\\n\t[GENERIC_STAT_ ## ext_name] = { #ext_name, 0, 0 }\n\n \nstatic inline int efx_nic_probe_tx(struct efx_tx_queue *tx_queue)\n{\n\treturn tx_queue->efx->type->tx_probe(tx_queue);\n}\nstatic inline void efx_nic_init_tx(struct efx_tx_queue *tx_queue)\n{\n\ttx_queue->efx->type->tx_init(tx_queue);\n}\nstatic inline void efx_nic_remove_tx(struct efx_tx_queue *tx_queue)\n{\n\tif (tx_queue->efx->type->tx_remove)\n\t\ttx_queue->efx->type->tx_remove(tx_queue);\n}\nstatic inline void efx_nic_push_buffers(struct efx_tx_queue *tx_queue)\n{\n\ttx_queue->efx->type->tx_write(tx_queue);\n}\n\n \nstatic inline int efx_nic_probe_rx(struct efx_rx_queue *rx_queue)\n{\n\treturn rx_queue->efx->type->rx_probe(rx_queue);\n}\nstatic inline void efx_nic_init_rx(struct efx_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_init(rx_queue);\n}\nstatic inline void efx_nic_remove_rx(struct efx_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_remove(rx_queue);\n}\nstatic inline void efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_write(rx_queue);\n}\nstatic inline void efx_nic_generate_fill_event(struct efx_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_defer_refill(rx_queue);\n}\n\n \nstatic inline int efx_nic_probe_eventq(struct efx_channel *channel)\n{\n\treturn channel->efx->type->ev_probe(channel);\n}\nstatic inline int efx_nic_init_eventq(struct efx_channel *channel)\n{\n\treturn channel->efx->type->ev_init(channel);\n}\nstatic inline void efx_nic_fini_eventq(struct efx_channel *channel)\n{\n\tchannel->efx->type->ev_fini(channel);\n}\nstatic inline void efx_nic_remove_eventq(struct efx_channel *channel)\n{\n\tchannel->efx->type->ev_remove(channel);\n}\nstatic inline int\nefx_nic_process_eventq(struct efx_channel *channel, int quota)\n{\n\treturn channel->efx->type->ev_process(channel, quota);\n}\nstatic inline void efx_nic_eventq_read_ack(struct efx_channel *channel)\n{\n\tchannel->efx->type->ev_read_ack(channel);\n}\n\nvoid efx_nic_event_test_start(struct efx_channel *channel);\n\nbool efx_nic_event_present(struct efx_channel *channel);\n\nstatic inline void efx_sensor_event(struct efx_nic *efx, efx_qword_t *ev)\n{\n\tif (efx->type->sensor_event)\n\t\tefx->type->sensor_event(efx, ev);\n}\n\nstatic inline unsigned int efx_rx_recycle_ring_size(const struct efx_nic *efx)\n{\n\treturn efx->type->rx_recycle_ring_size(efx);\n}\n\n \nstatic inline void efx_update_diff_stat(u64 *stat, u64 diff)\n{\n\tif ((s64)(diff - *stat) > 0)\n\t\t*stat = diff;\n}\n\n \nint efx_nic_init_interrupt(struct efx_nic *efx);\nint efx_nic_irq_test_start(struct efx_nic *efx);\nvoid efx_nic_fini_interrupt(struct efx_nic *efx);\n\nstatic inline int efx_nic_event_test_irq_cpu(struct efx_channel *channel)\n{\n\treturn READ_ONCE(channel->event_test_cpu);\n}\nstatic inline int efx_nic_irq_test_irq_cpu(struct efx_nic *efx)\n{\n\treturn READ_ONCE(efx->last_irq_cpu);\n}\n\n \nint efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer,\n\t\t\t unsigned int len, gfp_t gfp_flags);\nvoid efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer);\n\nsize_t efx_nic_get_regs_len(struct efx_nic *efx);\nvoid efx_nic_get_regs(struct efx_nic *efx, void *buf);\n\n#define EFX_MC_STATS_GENERATION_INVALID ((__force __le64)(-1))\n\nsize_t efx_nic_describe_stats(const struct efx_hw_stat_desc *desc, size_t count,\n\t\t\t      const unsigned long *mask, u8 *names);\nint efx_nic_copy_stats(struct efx_nic *efx, __le64 *dest);\nvoid efx_nic_update_stats(const struct efx_hw_stat_desc *desc, size_t count,\n\t\t\t  const unsigned long *mask, u64 *stats,\n\t\t\t  const void *dma_buf, bool accumulate);\nvoid efx_nic_fix_nodesc_drop_stat(struct efx_nic *efx, u64 *stat);\nstatic inline size_t efx_nic_update_stats_atomic(struct efx_nic *efx, u64 *full_stats,\n\t\t\t\t\t\t struct rtnl_link_stats64 *core_stats)\n{\n\tif (efx->type->update_stats_atomic)\n\t\treturn efx->type->update_stats_atomic(efx, full_stats, core_stats);\n\treturn efx->type->update_stats(efx, full_stats, core_stats);\n}\n\n#define EFX_MAX_FLUSH_TIME 5000\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}