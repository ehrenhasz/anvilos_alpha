{
  "module_name": "mae.c",
  "hash_id": "51cc362b94f9047aa3a03c525bc751974e10df979b686fce5c7c01b9cf2c66a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/mae.c",
  "human_readable_source": "\n \n\n#include <linux/rhashtable.h>\n#include \"ef100_nic.h\"\n#include \"mae.h\"\n#include \"mcdi.h\"\n#include \"mcdi_pcol.h\"\n#include \"mcdi_pcol_mae.h\"\n#include \"tc_encap_actions.h\"\n#include \"tc_conntrack.h\"\n\nint efx_mae_allocate_mport(struct efx_nic *efx, u32 *id, u32 *label)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_MPORT_ALLOC_ALIAS_OUT_LEN);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_MPORT_ALLOC_ALIAS_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -EINVAL;\n\tif (WARN_ON_ONCE(!label))\n\t\treturn -EINVAL;\n\n\tMCDI_SET_DWORD(inbuf, MAE_MPORT_ALLOC_ALIAS_IN_TYPE,\n\t\t       MC_CMD_MAE_MPORT_ALLOC_ALIAS_IN_MPORT_TYPE_ALIAS);\n\tMCDI_SET_DWORD(inbuf, MAE_MPORT_ALLOC_ALIAS_IN_DELIVER_MPORT,\n\t\t       MAE_MPORT_SELECTOR_ASSIGNED);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_MPORT_ALLOC, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t*id = MCDI_DWORD(outbuf, MAE_MPORT_ALLOC_ALIAS_OUT_MPORT_ID);\n\t*label = MCDI_DWORD(outbuf, MAE_MPORT_ALLOC_ALIAS_OUT_LABEL);\n\treturn 0;\n}\n\nint efx_mae_free_mport(struct efx_nic *efx, u32 id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_MPORT_FREE_IN_LEN);\n\n\tBUILD_BUG_ON(MC_CMD_MAE_MPORT_FREE_OUT_LEN);\n\tMCDI_SET_DWORD(inbuf, MAE_MPORT_FREE_IN_MPORT_ID, id);\n\treturn efx_mcdi_rpc(efx, MC_CMD_MAE_MPORT_FREE, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nvoid efx_mae_mport_wire(struct efx_nic *efx, u32 *out)\n{\n\tefx_dword_t mport;\n\n\tEFX_POPULATE_DWORD_2(mport,\n\t\t\t     MAE_MPORT_SELECTOR_TYPE, MAE_MPORT_SELECTOR_TYPE_PPORT,\n\t\t\t     MAE_MPORT_SELECTOR_PPORT_ID, efx->port_num);\n\t*out = EFX_DWORD_VAL(mport);\n}\n\nvoid efx_mae_mport_uplink(struct efx_nic *efx __always_unused, u32 *out)\n{\n\tefx_dword_t mport;\n\n\tEFX_POPULATE_DWORD_3(mport,\n\t\t\t     MAE_MPORT_SELECTOR_TYPE, MAE_MPORT_SELECTOR_TYPE_FUNC,\n\t\t\t     MAE_MPORT_SELECTOR_FUNC_PF_ID, MAE_MPORT_SELECTOR_FUNC_PF_ID_CALLER,\n\t\t\t     MAE_MPORT_SELECTOR_FUNC_VF_ID, MAE_MPORT_SELECTOR_FUNC_VF_ID_NULL);\n\t*out = EFX_DWORD_VAL(mport);\n}\n\nvoid efx_mae_mport_vf(struct efx_nic *efx __always_unused, u32 vf_id, u32 *out)\n{\n\tefx_dword_t mport;\n\n\tEFX_POPULATE_DWORD_3(mport,\n\t\t\t     MAE_MPORT_SELECTOR_TYPE, MAE_MPORT_SELECTOR_TYPE_FUNC,\n\t\t\t     MAE_MPORT_SELECTOR_FUNC_PF_ID, MAE_MPORT_SELECTOR_FUNC_PF_ID_CALLER,\n\t\t\t     MAE_MPORT_SELECTOR_FUNC_VF_ID, vf_id);\n\t*out = EFX_DWORD_VAL(mport);\n}\n\n \nvoid efx_mae_mport_mport(struct efx_nic *efx __always_unused, u32 mport_id, u32 *out)\n{\n\tefx_dword_t mport;\n\n\tEFX_POPULATE_DWORD_2(mport,\n\t\t\t     MAE_MPORT_SELECTOR_TYPE, MAE_MPORT_SELECTOR_TYPE_MPORT_ID,\n\t\t\t     MAE_MPORT_SELECTOR_MPORT_ID, mport_id);\n\t*out = EFX_DWORD_VAL(mport);\n}\n\n \nint efx_mae_fw_lookup_mport(struct efx_nic *efx, u32 selector, u32 *id)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_MPORT_LOOKUP_OUT_LEN);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_MPORT_LOOKUP_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_MPORT_LOOKUP_IN_MPORT_SELECTOR, selector);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_MPORT_LOOKUP, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t*id = MCDI_DWORD(outbuf, MAE_MPORT_LOOKUP_OUT_MPORT_ID);\n\treturn 0;\n}\n\nint efx_mae_start_counters(struct efx_nic *efx, struct efx_rx_queue *rx_queue)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_COUNTERS_STREAM_START_V2_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_COUNTERS_STREAM_START_OUT_LEN);\n\tu32 out_flags;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_WORD(inbuf, MAE_COUNTERS_STREAM_START_V2_IN_QID,\n\t\t      efx_rx_queue_index(rx_queue));\n\tMCDI_SET_WORD(inbuf, MAE_COUNTERS_STREAM_START_V2_IN_PACKET_SIZE,\n\t\t      efx->net_dev->mtu);\n\tMCDI_SET_DWORD(inbuf, MAE_COUNTERS_STREAM_START_V2_IN_COUNTER_TYPES_MASK,\n\t\t       BIT(MAE_COUNTER_TYPE_AR) | BIT(MAE_COUNTER_TYPE_CT) |\n\t\t       BIT(MAE_COUNTER_TYPE_OR));\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_COUNTERS_STREAM_START,\n\t\t\t  inbuf, sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\tout_flags = MCDI_DWORD(outbuf, MAE_COUNTERS_STREAM_START_OUT_FLAGS);\n\tif (out_flags & BIT(MC_CMD_MAE_COUNTERS_STREAM_START_OUT_USES_CREDITS_OFST)) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"MAE counter stream uses credits\\n\");\n\t\trx_queue->grant_credits = true;\n\t\tout_flags &= ~BIT(MC_CMD_MAE_COUNTERS_STREAM_START_OUT_USES_CREDITS_OFST);\n\t}\n\tif (out_flags) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"MAE counter stream start: unrecognised flags %x\\n\",\n\t\t\t  out_flags);\n\t\tgoto out_stop;\n\t}\n\treturn 0;\nout_stop:\n\tefx_mae_stop_counters(efx, rx_queue);\n\treturn -EOPNOTSUPP;\n}\n\nstatic bool efx_mae_counters_flushed(u32 *flush_gen, u32 *seen_gen)\n{\n\tint i;\n\n\tfor (i = 0; i < EFX_TC_COUNTER_TYPE_MAX; i++)\n\t\tif ((s32)(flush_gen[i] - seen_gen[i]) > 0)\n\t\t\treturn false;\n\treturn true;\n}\n\nint efx_mae_stop_counters(struct efx_nic *efx, struct efx_rx_queue *rx_queue)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_COUNTERS_STREAM_STOP_V2_OUT_LENMAX);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_COUNTERS_STREAM_STOP_IN_LEN);\n\tsize_t outlen;\n\tint rc, i;\n\n\tMCDI_SET_WORD(inbuf, MAE_COUNTERS_STREAM_STOP_IN_QID,\n\t\t      efx_rx_queue_index(rx_queue));\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_COUNTERS_STREAM_STOP,\n\t\t\t  inbuf, sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\n\tif (rc)\n\t\treturn rc;\n\n\tnetif_dbg(efx, drv, efx->net_dev, \"Draining counters:\\n\");\n\t \n\tfor (i = 0; (i < (outlen / 4)) && (i < EFX_TC_COUNTER_TYPE_MAX); i++) {\n\t\tefx->tc->flush_gen[i] = MCDI_ARRAY_DWORD(outbuf,\n\t\t\t\t\t\t\t MAE_COUNTERS_STREAM_STOP_V2_OUT_GENERATION_COUNT,\n\t\t\t\t\t\t\t i);\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"\\ttype %u, awaiting gen %u\\n\", i,\n\t\t\t  efx->tc->flush_gen[i]);\n\t}\n\n\tefx->tc->flush_counters = true;\n\n\t \n\tif (!wait_event_timeout(efx->tc->flush_wq,\n\t\t\t\tefx_mae_counters_flushed(efx->tc->flush_gen,\n\t\t\t\t\t\t\t efx->tc->seen_gen),\n\t\t\t\tmsecs_to_jiffies(2500)))\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"Failed to drain counters RXQ, FW may be unhappy\\n\");\n\n\tefx->tc->flush_counters = false;\n\n\treturn rc;\n}\n\nvoid efx_mae_counters_grant_credits(struct work_struct *work)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_COUNTERS_STREAM_GIVE_CREDITS_IN_LEN);\n\tstruct efx_rx_queue *rx_queue = container_of(work, struct efx_rx_queue,\n\t\t\t\t\t\t     grant_work);\n\tstruct efx_nic *efx = rx_queue->efx;\n\tunsigned int credits;\n\n\tBUILD_BUG_ON(MC_CMD_MAE_COUNTERS_STREAM_GIVE_CREDITS_OUT_LEN);\n\tcredits = READ_ONCE(rx_queue->notified_count) - rx_queue->granted_count;\n\tMCDI_SET_DWORD(inbuf, MAE_COUNTERS_STREAM_GIVE_CREDITS_IN_NUM_CREDITS,\n\t\t       credits);\n\tif (!efx_mcdi_rpc(efx, MC_CMD_MAE_COUNTERS_STREAM_GIVE_CREDITS,\n\t\t\t  inbuf, sizeof(inbuf), NULL, 0, NULL))\n\t\trx_queue->granted_count += credits;\n}\n\nstatic int efx_mae_table_get_desc(struct efx_nic *efx,\n\t\t\t\t  struct efx_tc_table_desc *desc,\n\t\t\t\t  u32 table_id)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_TABLE_DESCRIPTOR_OUT_LEN(16));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_TABLE_DESCRIPTOR_IN_LEN);\n\tunsigned int offset = 0, i;\n\tsize_t outlen;\n\tint rc;\n\n\tmemset(desc, 0, sizeof(*desc));\n\n\tMCDI_SET_DWORD(inbuf, TABLE_DESCRIPTOR_IN_TABLE_ID, table_id);\nmore:\n\tMCDI_SET_DWORD(inbuf, TABLE_DESCRIPTOR_IN_FIRST_FIELDS_INDEX, offset);\n\trc = efx_mcdi_rpc(efx, MC_CMD_TABLE_DESCRIPTOR, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\tif (outlen < MC_CMD_TABLE_DESCRIPTOR_OUT_LEN(1)) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\tif (!offset) {  \n\t\tdesc->type = MCDI_WORD(outbuf, TABLE_DESCRIPTOR_OUT_TYPE);\n\t\tdesc->key_width = MCDI_WORD(outbuf, TABLE_DESCRIPTOR_OUT_KEY_WIDTH);\n\t\tdesc->resp_width = MCDI_WORD(outbuf, TABLE_DESCRIPTOR_OUT_RESP_WIDTH);\n\t\tdesc->n_keys = MCDI_WORD(outbuf, TABLE_DESCRIPTOR_OUT_N_KEY_FIELDS);\n\t\tdesc->n_resps = MCDI_WORD(outbuf, TABLE_DESCRIPTOR_OUT_N_RESP_FIELDS);\n\t\tdesc->n_prios = MCDI_WORD(outbuf, TABLE_DESCRIPTOR_OUT_N_PRIORITIES);\n\t\tdesc->flags = MCDI_BYTE(outbuf, TABLE_DESCRIPTOR_OUT_FLAGS);\n\t\trc = -EOPNOTSUPP;\n\t\tif (desc->flags)\n\t\t\tgoto fail;\n\t\tdesc->scheme = MCDI_BYTE(outbuf, TABLE_DESCRIPTOR_OUT_SCHEME);\n\t\tif (desc->scheme)\n\t\t\tgoto fail;\n\t\trc = -ENOMEM;\n\t\tdesc->keys = kcalloc(desc->n_keys,\n\t\t\t\t     sizeof(struct efx_tc_table_field_fmt),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!desc->keys)\n\t\t\tgoto fail;\n\t\tdesc->resps = kcalloc(desc->n_resps,\n\t\t\t\t      sizeof(struct efx_tc_table_field_fmt),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!desc->resps)\n\t\t\tgoto fail;\n\t}\n\t \n\toutlen = min(outlen, sizeof(outbuf));\n\tfor (i = 0; i + offset < desc->n_keys + desc->n_resps; i++) {\n\t\tstruct efx_tc_table_field_fmt *field;\n\t\tMCDI_DECLARE_STRUCT_PTR(fdesc);\n\n\t\tif (outlen < MC_CMD_TABLE_DESCRIPTOR_OUT_LEN(i + 1)) {\n\t\t\toffset += i;\n\t\t\tgoto more;\n\t\t}\n\t\tif (i + offset < desc->n_keys)\n\t\t\tfield = desc->keys + i + offset;\n\t\telse\n\t\t\tfield = desc->resps + (i + offset - desc->n_keys);\n\t\tfdesc = MCDI_ARRAY_STRUCT_PTR(outbuf,\n\t\t\t\t\t      TABLE_DESCRIPTOR_OUT_FIELDS, i);\n\t\tfield->field_id = MCDI_STRUCT_WORD(fdesc,\n\t\t\t\t\t\t   TABLE_FIELD_DESCR_FIELD_ID);\n\t\tfield->lbn = MCDI_STRUCT_WORD(fdesc, TABLE_FIELD_DESCR_LBN);\n\t\tfield->width = MCDI_STRUCT_WORD(fdesc, TABLE_FIELD_DESCR_WIDTH);\n\t\tfield->masking = MCDI_STRUCT_BYTE(fdesc, TABLE_FIELD_DESCR_MASK_TYPE);\n\t\tfield->scheme = MCDI_STRUCT_BYTE(fdesc, TABLE_FIELD_DESCR_SCHEME);\n\t}\n\treturn 0;\n\nfail:\n\tkfree(desc->keys);\n\tkfree(desc->resps);\n\treturn rc;\n}\n\nstatic int efx_mae_table_hook_find(u16 n_fields,\n\t\t\t\t   struct efx_tc_table_field_fmt *fields,\n\t\t\t\t   u16 field_id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].field_id == field_id)\n\t\t\treturn i;\n\t}\n\treturn -EPROTO;\n}\n\n#define TABLE_FIND_KEY(_desc, _id)\t\\\n\tefx_mae_table_hook_find((_desc)->n_keys, (_desc)->keys, _id)\n#define TABLE_FIND_RESP(_desc, _id)\t\\\n\tefx_mae_table_hook_find((_desc)->n_resps, (_desc)->resps, _id)\n\n#define TABLE_HOOK_KEY(_meta, _name, _mcdi_name)\t({\t\t\t\\\n\tint _rc = TABLE_FIND_KEY(&_meta->desc, TABLE_FIELD_ID_##_mcdi_name);\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (_rc > U8_MAX)\t\t\t\t\t\t\t\\\n\t\t_rc = -EOPNOTSUPP;\t\t\t\t\t\t\\\n\tif (_rc >= 0) {\t\t\t\t\t\t\t\t\\\n\t\t_meta->keys._name##_idx = _rc;\t\t\t\t\t\\\n\t\t_rc = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\t\\\n})\n#define TABLE_HOOK_RESP(_meta, _name, _mcdi_name)\t({\t\t\t\\\n\tint _rc = TABLE_FIND_RESP(&_meta->desc, TABLE_FIELD_ID_##_mcdi_name);\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (_rc > U8_MAX)\t\t\t\t\t\t\t\\\n\t\t_rc = -EOPNOTSUPP;\t\t\t\t\t\t\\\n\tif (_rc >= 0) {\t\t\t\t\t\t\t\t\\\n\t\t_meta->resps._name##_idx = _rc;\t\t\t\t\t\\\n\t\t_rc = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\t\\\n})\n\nstatic int efx_mae_table_hook_ct(struct efx_nic *efx,\n\t\t\t\t struct efx_tc_table_ct *meta_ct)\n{\n\tint rc;\n\n\trc = TABLE_HOOK_KEY(meta_ct, eth_proto, ETHER_TYPE);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_KEY(meta_ct, ip_proto, IP_PROTO);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_KEY(meta_ct, src_ip, SRC_IP);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_KEY(meta_ct, dst_ip, DST_IP);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_KEY(meta_ct, l4_sport, SRC_PORT);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_KEY(meta_ct, l4_dport, DST_PORT);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_KEY(meta_ct, zone, DOMAIN);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_RESP(meta_ct, dnat, NAT_DIR);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_RESP(meta_ct, nat_ip, NAT_IP);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_RESP(meta_ct, l4_natport, NAT_PORT);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_RESP(meta_ct, mark, CT_MARK);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_HOOK_RESP(meta_ct, counter_id, COUNTER_ID);\n\tif (rc)\n\t\treturn rc;\n\tmeta_ct->hooked = true;\n\treturn 0;\n}\n\nstatic void efx_mae_table_free_desc(struct efx_tc_table_desc *desc)\n{\n\tkfree(desc->keys);\n\tkfree(desc->resps);\n\tmemset(desc, 0, sizeof(*desc));\n}\n\nstatic bool efx_mae_check_table_exists(struct efx_nic *efx, u32 tbl_req)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_TABLE_LIST_OUT_LEN(16));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_TABLE_LIST_IN_LEN);\n\tu32 tbl_id, tbl_total, tbl_cnt, pos = 0;\n\tsize_t outlen, msg_max;\n\tbool ct_tbl = false;\n\tint rc, idx;\n\n\tmsg_max = sizeof(outbuf);\n\tefx->tc->meta_ct.hooked = false;\nmore:\n\tmemset(outbuf, 0, sizeof(*outbuf));\n\tMCDI_SET_DWORD(inbuf, TABLE_LIST_IN_FIRST_TABLE_ID_INDEX, pos);\n\trc = efx_mcdi_rpc(efx, MC_CMD_TABLE_LIST, inbuf, sizeof(inbuf), outbuf,\n\t\t\t  msg_max, &outlen);\n\tif (rc)\n\t\treturn false;\n\n\tif (outlen < MC_CMD_TABLE_LIST_OUT_LEN(1))\n\t\treturn false;\n\n\ttbl_total = MCDI_DWORD(outbuf, TABLE_LIST_OUT_N_TABLES);\n\ttbl_cnt = MC_CMD_TABLE_LIST_OUT_TABLE_ID_NUM(min(outlen, msg_max));\n\n\tfor (idx = 0; idx < tbl_cnt; idx++) {\n\t\ttbl_id = MCDI_ARRAY_DWORD(outbuf, TABLE_LIST_OUT_TABLE_ID, idx);\n\t\tif (tbl_id == tbl_req) {\n\t\t\tct_tbl = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpos += tbl_cnt;\n\tif (!ct_tbl && pos < tbl_total)\n\t\tgoto more;\n\n\treturn ct_tbl;\n}\n\nint efx_mae_get_tables(struct efx_nic *efx)\n{\n\tint rc;\n\n\tefx->tc->meta_ct.hooked = false;\n\tif (efx_mae_check_table_exists(efx, TABLE_ID_CONNTRACK_TABLE)) {\n\t\trc = efx_mae_table_get_desc(efx, &efx->tc->meta_ct.desc,\n\t\t\t\t\t    TABLE_ID_CONNTRACK_TABLE);\n\t\tif (rc) {\n\t\t\tpci_info(efx->pci_dev,\n\t\t\t\t \"FW does not support conntrack desc rc %d\\n\",\n\t\t\t\t rc);\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = efx_mae_table_hook_ct(efx, &efx->tc->meta_ct);\n\t\tif (rc) {\n\t\t\tpci_info(efx->pci_dev,\n\t\t\t\t \"FW does not support conntrack hook rc %d\\n\",\n\t\t\t\t rc);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tpci_info(efx->pci_dev,\n\t\t\t \"FW does not support conntrack table\\n\");\n\t}\n\treturn 0;\n}\n\nvoid efx_mae_free_tables(struct efx_nic *efx)\n{\n\tefx_mae_table_free_desc(&efx->tc->meta_ct.desc);\n\tefx->tc->meta_ct.hooked = false;\n}\n\nstatic int efx_mae_get_basic_caps(struct efx_nic *efx, struct mae_caps *caps)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_GET_CAPS_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_MAE_GET_CAPS_IN_LEN);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_GET_CAPS, NULL, 0, outbuf,\n\t\t\t  sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\tcaps->match_field_count = MCDI_DWORD(outbuf, MAE_GET_CAPS_OUT_MATCH_FIELD_COUNT);\n\tcaps->encap_types = MCDI_DWORD(outbuf, MAE_GET_CAPS_OUT_ENCAP_TYPES_SUPPORTED);\n\tcaps->action_prios = MCDI_DWORD(outbuf, MAE_GET_CAPS_OUT_ACTION_PRIOS);\n\treturn 0;\n}\n\nstatic int efx_mae_get_rule_fields(struct efx_nic *efx, u32 cmd,\n\t\t\t\t   u8 *field_support)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_GET_AR_CAPS_OUT_LEN(MAE_NUM_FIELDS));\n\tMCDI_DECLARE_STRUCT_PTR(caps);\n\tunsigned int count;\n\tsize_t outlen;\n\tint rc, i;\n\n\t \n\tBUILD_BUG_ON(MC_CMD_MAE_GET_AR_CAPS_OUT_LEN(MAE_NUM_FIELDS) <\n\t\t     MC_CMD_MAE_GET_OR_CAPS_OUT_LEN(MAE_NUM_FIELDS));\n\tBUILD_BUG_ON(MC_CMD_MAE_GET_AR_CAPS_IN_LEN);\n\tBUILD_BUG_ON(MC_CMD_MAE_GET_OR_CAPS_IN_LEN);\n\n\trc = efx_mcdi_rpc(efx, cmd, NULL, 0, outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tBUILD_BUG_ON(MC_CMD_MAE_GET_AR_CAPS_OUT_COUNT_OFST !=\n\t\t     MC_CMD_MAE_GET_OR_CAPS_OUT_COUNT_OFST);\n\tcount = MCDI_DWORD(outbuf, MAE_GET_AR_CAPS_OUT_COUNT);\n\tmemset(field_support, MAE_FIELD_UNSUPPORTED, MAE_NUM_FIELDS);\n\tBUILD_BUG_ON(MC_CMD_MAE_GET_AR_CAPS_OUT_FIELD_FLAGS_OFST !=\n\t\t     MC_CMD_MAE_GET_OR_CAPS_OUT_FIELD_FLAGS_OFST);\n\tcaps = _MCDI_DWORD(outbuf, MAE_GET_AR_CAPS_OUT_FIELD_FLAGS);\n\t \n\tfor (i = 0; i < count; i++)\n\t\tif (i * sizeof(*outbuf) + MC_CMD_MAE_GET_AR_CAPS_OUT_FIELD_FLAGS_OFST < outlen)\n\t\t\tfield_support[i] = EFX_DWORD_FIELD(caps[i], MAE_FIELD_FLAGS_SUPPORT_STATUS);\n\treturn 0;\n}\n\nint efx_mae_get_caps(struct efx_nic *efx, struct mae_caps *caps)\n{\n\tint rc;\n\n\trc = efx_mae_get_basic_caps(efx, caps);\n\tif (rc)\n\t\treturn rc;\n\trc = efx_mae_get_rule_fields(efx, MC_CMD_MAE_GET_AR_CAPS,\n\t\t\t\t     caps->action_rule_fields);\n\tif (rc)\n\t\treturn rc;\n\treturn efx_mae_get_rule_fields(efx, MC_CMD_MAE_GET_OR_CAPS,\n\t\t\t\t       caps->outer_rule_fields);\n}\n\n \n#define is_prefix_byte(_x)\t!(((_x) ^ 0xff) & (((_x) ^ 0xff) + 1))\n\nenum mask_type { MASK_ONES, MASK_ZEROES, MASK_PREFIX, MASK_OTHER };\n\nstatic const char *mask_type_name(enum mask_type typ)\n{\n\tswitch (typ) {\n\tcase MASK_ONES:\n\t\treturn \"all-1s\";\n\tcase MASK_ZEROES:\n\t\treturn \"all-0s\";\n\tcase MASK_PREFIX:\n\t\treturn \"prefix\";\n\tcase MASK_OTHER:\n\t\treturn \"arbitrary\";\n\tdefault:  \n\t\treturn \"unknown\";\n\t}\n}\n\n \nstatic enum mask_type classify_mask(const u8 *mask, size_t len)\n{\n\tbool zeroes = true;  \n\tbool ones = true;  \n\tbool prefix = true;  \n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (ones) {\n\t\t\tif (!is_prefix_byte(mask[i]))\n\t\t\t\tprefix = false;\n\t\t} else if (mask[i]) {\n\t\t\tprefix = false;\n\t\t}\n\t\tif (mask[i] != 0xff)\n\t\t\tones = false;\n\t\tif (mask[i])\n\t\t\tzeroes = false;\n\t}\n\tif (ones)\n\t\treturn MASK_ONES;\n\tif (zeroes)\n\t\treturn MASK_ZEROES;\n\tif (prefix)\n\t\treturn MASK_PREFIX;\n\treturn MASK_OTHER;\n}\n\nstatic int efx_mae_match_check_cap_typ(u8 support, enum mask_type typ)\n{\n\tswitch (support) {\n\tcase MAE_FIELD_UNSUPPORTED:\n\tcase MAE_FIELD_SUPPORTED_MATCH_NEVER:\n\t\tif (typ == MASK_ZEROES)\n\t\t\treturn 0;\n\t\treturn -EOPNOTSUPP;\n\tcase MAE_FIELD_SUPPORTED_MATCH_OPTIONAL:\n\t\tif (typ == MASK_ZEROES)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase MAE_FIELD_SUPPORTED_MATCH_ALWAYS:\n\t\tif (typ == MASK_ONES)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase MAE_FIELD_SUPPORTED_MATCH_PREFIX:\n\t\tif (typ == MASK_OTHER)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\tcase MAE_FIELD_SUPPORTED_MATCH_MASK:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \n#define CHECK(_mcdi, _field)\t({\t\t\t\t\t       \\\n\tenum mask_type typ = classify_mask((const u8 *)&mask->_field,\t       \\\n\t\t\t\t\t   sizeof(mask->_field));\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\trc = efx_mae_match_check_cap_typ(supported_fields[MAE_FIELD_ ## _mcdi],\\\n\t\t\t\t\t typ);\t\t\t\t       \\\n\tif (rc)\t\t\t\t\t\t\t\t       \\\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\t\t\t\t       \\\n\t\t\t\t       \"No support for %s mask in field %s\",   \\\n\t\t\t\t       mask_type_name(typ), #_field);\t       \\\n\trc;\t\t\t\t\t\t\t\t       \\\n})\n \n#define CHECK_BIT(_mcdi, _field)\t({\t\t\t\t       \\\n\tenum mask_type typ = mask->_field ? MASK_ONES : MASK_ZEROES;\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\trc = efx_mae_match_check_cap_typ(supported_fields[MAE_FIELD_ ## _mcdi],\\\n\t\t\t\t\t typ);\t\t\t\t       \\\n\tif (rc)\t\t\t\t\t\t\t\t       \\\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\t\t\t\t       \\\n\t\t\t\t       \"No support for %s mask in field %s\",   \\\n\t\t\t\t       mask_type_name(typ), #_field);\t       \\\n\trc;\t\t\t\t\t\t\t\t       \\\n})\n\nint efx_mae_match_check_caps(struct efx_nic *efx,\n\t\t\t     const struct efx_tc_match_fields *mask,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tconst u8 *supported_fields = efx->tc->caps->action_rule_fields;\n\t__be32 ingress_port = cpu_to_be32(mask->ingress_port);\n\tenum mask_type ingress_port_mask_type;\n\tint rc;\n\n\t \n\tingress_port_mask_type = classify_mask((const u8 *)&ingress_port,\n\t\t\t\t\t       sizeof(ingress_port));\n\trc = efx_mae_match_check_cap_typ(supported_fields[MAE_FIELD_INGRESS_PORT],\n\t\t\t\t\t ingress_port_mask_type);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"No support for %s mask in field ingress_port\",\n\t\t\t\t       mask_type_name(ingress_port_mask_type));\n\t\treturn rc;\n\t}\n\tif (CHECK(ETHER_TYPE, eth_proto) ||\n\t    CHECK(VLAN0_TCI, vlan_tci[0]) ||\n\t    CHECK(VLAN0_PROTO, vlan_proto[0]) ||\n\t    CHECK(VLAN1_TCI, vlan_tci[1]) ||\n\t    CHECK(VLAN1_PROTO, vlan_proto[1]) ||\n\t    CHECK(ETH_SADDR, eth_saddr) ||\n\t    CHECK(ETH_DADDR, eth_daddr) ||\n\t    CHECK(IP_PROTO, ip_proto) ||\n\t    CHECK(IP_TOS, ip_tos) ||\n\t    CHECK(IP_TTL, ip_ttl) ||\n\t    CHECK(SRC_IP4, src_ip) ||\n\t    CHECK(DST_IP4, dst_ip) ||\n#ifdef CONFIG_IPV6\n\t    CHECK(SRC_IP6, src_ip6) ||\n\t    CHECK(DST_IP6, dst_ip6) ||\n#endif\n\t    CHECK(L4_SPORT, l4_sport) ||\n\t    CHECK(L4_DPORT, l4_dport) ||\n\t    CHECK(TCP_FLAGS, tcp_flags) ||\n\t    CHECK_BIT(TCP_SYN_FIN_RST, tcp_syn_fin_rst) ||\n\t    CHECK_BIT(IS_IP_FRAG, ip_frag) ||\n\t    CHECK_BIT(IP_FIRST_FRAG, ip_firstfrag) ||\n\t    CHECK_BIT(DO_CT, ct_state_trk) ||\n\t    CHECK_BIT(CT_HIT, ct_state_est) ||\n\t    CHECK(CT_MARK, ct_mark) ||\n\t    CHECK(CT_DOMAIN, ct_zone) ||\n\t    CHECK(RECIRC_ID, recirc_id))\n\t\treturn rc;\n\t \n\tif (efx_tc_match_is_encap(mask)) {\n\t\trc = efx_mae_match_check_cap_typ(\n\t\t\t\tsupported_fields[MAE_FIELD_OUTER_RULE_ID],\n\t\t\t\tMASK_ONES);\n\t\tif (rc) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No support for encap rule ID matches\");\n\t\t\treturn rc;\n\t\t}\n\t\tif (CHECK(ENC_VNET_ID, enc_keyid))\n\t\t\treturn rc;\n\t} else if (mask->enc_keyid) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Match on enc_keyid requires other encap fields\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n#define UNSUPPORTED(_field)\t({\t\t\t\t\t       \\\n\tenum mask_type typ = classify_mask((const u8 *)&mask->_field,\t       \\\n\t\t\t\t\t   sizeof(mask->_field));\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tif (typ != MASK_ZEROES) {\t\t\t\t\t       \\\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported match field \" #_field);\\\n\t\trc = -EOPNOTSUPP;\t\t\t\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n\trc;\t\t\t\t\t\t\t\t       \\\n})\n#define UNSUPPORTED_BIT(_field)\t({\t\t\t\t\t       \\\n\tif (mask->_field) {\t\t\t\t\t\t       \\\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported match field \" #_field);\\\n\t\trc = -EOPNOTSUPP;\t\t\t\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n\trc;\t\t\t\t\t\t\t\t       \\\n})\n\n \nint efx_mae_match_check_caps_lhs(struct efx_nic *efx,\n\t\t\t\t const struct efx_tc_match_fields *mask,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst u8 *supported_fields = efx->tc->caps->outer_rule_fields;\n\t__be32 ingress_port = cpu_to_be32(mask->ingress_port);\n\tenum mask_type ingress_port_mask_type;\n\tint rc;\n\n\t \n\tingress_port_mask_type = classify_mask((const u8 *)&ingress_port,\n\t\t\t\t\t       sizeof(ingress_port));\n\trc = efx_mae_match_check_cap_typ(supported_fields[MAE_FIELD_INGRESS_PORT],\n\t\t\t\t\t ingress_port_mask_type);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"No support for %s mask in field %s\\n\",\n\t\t\t\t       mask_type_name(ingress_port_mask_type),\n\t\t\t\t       \"ingress_port\");\n\t\treturn rc;\n\t}\n\tif (CHECK(ENC_ETHER_TYPE, eth_proto) ||\n\t    CHECK(ENC_VLAN0_TCI, vlan_tci[0]) ||\n\t    CHECK(ENC_VLAN0_PROTO, vlan_proto[0]) ||\n\t    CHECK(ENC_VLAN1_TCI, vlan_tci[1]) ||\n\t    CHECK(ENC_VLAN1_PROTO, vlan_proto[1]) ||\n\t    CHECK(ENC_ETH_SADDR, eth_saddr) ||\n\t    CHECK(ENC_ETH_DADDR, eth_daddr) ||\n\t    CHECK(ENC_IP_PROTO, ip_proto) ||\n\t    CHECK(ENC_IP_TOS, ip_tos) ||\n\t    CHECK(ENC_IP_TTL, ip_ttl) ||\n\t    CHECK_BIT(ENC_IP_FRAG, ip_frag) ||\n\t    UNSUPPORTED_BIT(ip_firstfrag) ||\n\t    CHECK(ENC_SRC_IP4, src_ip) ||\n\t    CHECK(ENC_DST_IP4, dst_ip) ||\n#ifdef CONFIG_IPV6\n\t    CHECK(ENC_SRC_IP6, src_ip6) ||\n\t    CHECK(ENC_DST_IP6, dst_ip6) ||\n#endif\n\t    CHECK(ENC_L4_SPORT, l4_sport) ||\n\t    CHECK(ENC_L4_DPORT, l4_dport) ||\n\t    UNSUPPORTED(tcp_flags) ||\n\t    CHECK_BIT(TCP_SYN_FIN_RST, tcp_syn_fin_rst))\n\t\treturn rc;\n\tif (efx_tc_match_is_encap(mask)) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unexpected encap match in LHS rule\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (UNSUPPORTED(enc_keyid) ||\n\t     \n\t    UNSUPPORTED_BIT(ct_state_trk) ||\n\t    UNSUPPORTED_BIT(ct_state_est) ||\n\t    UNSUPPORTED(ct_mark) ||\n\t    UNSUPPORTED(recirc_id))\n\t\treturn rc;\n\treturn 0;\n}\n#undef UNSUPPORTED\n#undef CHECK_BIT\n#undef CHECK\n\n#define CHECK(_mcdi)\t({\t\t\t\t\t\t       \\\n\trc = efx_mae_match_check_cap_typ(supported_fields[MAE_FIELD_ ## _mcdi],\\\n\t\t\t\t\t MASK_ONES);\t\t\t       \\\n\tif (rc)\t\t\t\t\t\t\t\t       \\\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\t\t\t\t       \\\n\t\t\t\t       \"No support for field %s\", #_mcdi);     \\\n\trc;\t\t\t\t\t\t\t\t       \\\n})\n \nint efx_mae_check_encap_match_caps(struct efx_nic *efx, bool ipv6,\n\t\t\t\t   u8 ip_tos_mask, __be16 udp_sport_mask,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tu8 *supported_fields = efx->tc->caps->outer_rule_fields;\n\tenum mask_type typ;\n\tint rc;\n\n\tif (CHECK(ENC_ETHER_TYPE))\n\t\treturn rc;\n\tif (ipv6) {\n\t\tif (CHECK(ENC_SRC_IP6) ||\n\t\t    CHECK(ENC_DST_IP6))\n\t\t\treturn rc;\n\t} else {\n\t\tif (CHECK(ENC_SRC_IP4) ||\n\t\t    CHECK(ENC_DST_IP4))\n\t\t\treturn rc;\n\t}\n\tif (CHECK(ENC_L4_DPORT) ||\n\t    CHECK(ENC_IP_PROTO))\n\t\treturn rc;\n\ttyp = classify_mask((const u8 *)&udp_sport_mask, sizeof(udp_sport_mask));\n\trc = efx_mae_match_check_cap_typ(supported_fields[MAE_FIELD_ENC_L4_SPORT],\n\t\t\t\t\t typ);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"No support for %s mask in field %s\",\n\t\t\t\t       mask_type_name(typ), \"enc_src_port\");\n\t\treturn rc;\n\t}\n\ttyp = classify_mask(&ip_tos_mask, sizeof(ip_tos_mask));\n\trc = efx_mae_match_check_cap_typ(supported_fields[MAE_FIELD_ENC_IP_TOS],\n\t\t\t\t\t typ);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"No support for %s mask in field %s\",\n\t\t\t\t       mask_type_name(typ), \"enc_ip_tos\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n#undef CHECK\n\nint efx_mae_check_encap_type_supported(struct efx_nic *efx, enum efx_encap_type typ)\n{\n\tunsigned int bit;\n\n\tswitch (typ & EFX_ENCAP_TYPES_MASK) {\n\tcase EFX_ENCAP_TYPE_VXLAN:\n\t\tbit = MC_CMD_MAE_GET_CAPS_OUT_ENCAP_TYPE_VXLAN_LBN;\n\t\tbreak;\n\tcase EFX_ENCAP_TYPE_GENEVE:\n\t\tbit = MC_CMD_MAE_GET_CAPS_OUT_ENCAP_TYPE_GENEVE_LBN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (efx->tc->caps->encap_types & BIT(bit))\n\t\treturn 0;\n\treturn -EOPNOTSUPP;\n}\n\nint efx_mae_allocate_counter(struct efx_nic *efx, struct efx_tc_counter *cnt)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_COUNTER_ALLOC_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_COUNTER_ALLOC_V2_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tMCDI_SET_DWORD(inbuf, MAE_COUNTER_ALLOC_V2_IN_REQUESTED_COUNT, 1);\n\tMCDI_SET_DWORD(inbuf, MAE_COUNTER_ALLOC_V2_IN_COUNTER_TYPE, cnt->type);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_COUNTER_ALLOC, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\t \n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\tcnt->fw_id = MCDI_DWORD(outbuf, MAE_COUNTER_ALLOC_OUT_COUNTER_ID);\n\tcnt->gen = MCDI_DWORD(outbuf, MAE_COUNTER_ALLOC_OUT_GENERATION_COUNT);\n\treturn 0;\n}\n\nint efx_mae_free_counter(struct efx_nic *efx, struct efx_tc_counter *cnt)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_COUNTER_FREE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_COUNTER_FREE_V2_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_COUNTER_FREE_V2_IN_COUNTER_ID_COUNT, 1);\n\tMCDI_SET_DWORD(inbuf, MAE_COUNTER_FREE_V2_IN_FREE_COUNTER_ID, cnt->fw_id);\n\tMCDI_SET_DWORD(inbuf, MAE_COUNTER_FREE_V2_IN_COUNTER_TYPE, cnt->type);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_COUNTER_FREE, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\t \n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t \n\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_COUNTER_FREE_OUT_FREED_COUNTER_ID) !=\n\t\t    cnt->fw_id))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int efx_mae_encap_type_to_mae_type(enum efx_encap_type type)\n{\n\tswitch (type & EFX_ENCAP_TYPES_MASK) {\n\tcase EFX_ENCAP_TYPE_NONE:\n\t\treturn MAE_MCDI_ENCAP_TYPE_NONE;\n\tcase EFX_ENCAP_TYPE_VXLAN:\n\t\treturn MAE_MCDI_ENCAP_TYPE_VXLAN;\n\tcase EFX_ENCAP_TYPE_GENEVE:\n\t\treturn MAE_MCDI_ENCAP_TYPE_GENEVE;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint efx_mae_allocate_encap_md(struct efx_nic *efx,\n\t\t\t      struct efx_tc_encap_action *encap)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ENCAP_HEADER_ALLOC_IN_LEN(EFX_TC_MAX_ENCAP_HDR));\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ENCAP_HEADER_ALLOC_OUT_LEN);\n\tsize_t inlen, outlen;\n\tint rc;\n\n\trc = efx_mae_encap_type_to_mae_type(encap->type);\n\tif (rc < 0)\n\t\treturn rc;\n\tMCDI_SET_DWORD(inbuf, MAE_ENCAP_HEADER_ALLOC_IN_ENCAP_TYPE, rc);\n\tinlen = MC_CMD_MAE_ENCAP_HEADER_ALLOC_IN_LEN(encap->encap_hdr_len);\n\tif (WARN_ON(inlen > sizeof(inbuf)))  \n\t\treturn -EINVAL;\n\tmemcpy(MCDI_PTR(inbuf, MAE_ENCAP_HEADER_ALLOC_IN_HDR_DATA),\n\t       encap->encap_hdr,\n\t       encap->encap_hdr_len);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ENCAP_HEADER_ALLOC, inbuf,\n\t\t\t  inlen, outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\tencap->fw_id = MCDI_DWORD(outbuf, MAE_ENCAP_HEADER_ALLOC_OUT_ENCAP_HEADER_ID);\n\treturn 0;\n}\n\nint efx_mae_update_encap_md(struct efx_nic *efx,\n\t\t\t    struct efx_tc_encap_action *encap)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ENCAP_HEADER_UPDATE_IN_LEN(EFX_TC_MAX_ENCAP_HDR));\n\tsize_t inlen;\n\tint rc;\n\n\trc = efx_mae_encap_type_to_mae_type(encap->type);\n\tif (rc < 0)\n\t\treturn rc;\n\tMCDI_SET_DWORD(inbuf, MAE_ENCAP_HEADER_UPDATE_IN_ENCAP_TYPE, rc);\n\tMCDI_SET_DWORD(inbuf, MAE_ENCAP_HEADER_UPDATE_IN_EH_ID,\n\t\t       encap->fw_id);\n\tinlen = MC_CMD_MAE_ENCAP_HEADER_UPDATE_IN_LEN(encap->encap_hdr_len);\n\tif (WARN_ON(inlen > sizeof(inbuf)))  \n\t\treturn -EINVAL;\n\tmemcpy(MCDI_PTR(inbuf, MAE_ENCAP_HEADER_UPDATE_IN_HDR_DATA),\n\t       encap->encap_hdr,\n\t       encap->encap_hdr_len);\n\n\tBUILD_BUG_ON(MC_CMD_MAE_ENCAP_HEADER_UPDATE_OUT_LEN != 0);\n\treturn efx_mcdi_rpc(efx, MC_CMD_MAE_ENCAP_HEADER_UPDATE, inbuf,\n\t\t\t    inlen, NULL, 0, NULL);\n}\n\nint efx_mae_free_encap_md(struct efx_nic *efx,\n\t\t\t  struct efx_tc_encap_action *encap)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ENCAP_HEADER_FREE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ENCAP_HEADER_FREE_IN_LEN(1));\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_ENCAP_HEADER_FREE_IN_EH_ID, encap->fw_id);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ENCAP_HEADER_FREE, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t \n\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_ENCAP_HEADER_FREE_OUT_FREED_EH_ID) != encap->fw_id))\n\t\treturn -EIO;\n\t \n\tencap->fw_id = MC_CMD_MAE_ENCAP_HEADER_ALLOC_OUT_ENCAP_HEADER_ID_NULL;\n\treturn 0;\n}\n\nint efx_mae_lookup_mport(struct efx_nic *efx, u32 vf_idx, u32 *id)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tstruct efx_mae *mae = efx->mae;\n\tstruct rhashtable_iter walk;\n\tstruct mae_mport_desc *m;\n\tint rc = -ENOENT;\n\n\trhashtable_walk_enter(&mae->mports_ht, &walk);\n\trhashtable_walk_start(&walk);\n\twhile ((m = rhashtable_walk_next(&walk)) != NULL) {\n\t\tif (m->mport_type == MAE_MPORT_DESC_MPORT_TYPE_VNIC &&\n\t\t    m->interface_idx == nic_data->local_mae_intf &&\n\t\t    m->pf_idx == 0 &&\n\t\t    m->vf_idx == vf_idx) {\n\t\t\t*id = m->mport_id;\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\trhashtable_walk_stop(&walk);\n\trhashtable_walk_exit(&walk);\n\treturn rc;\n}\n\nstatic bool efx_mae_asl_id(u32 id)\n{\n\treturn !!(id & BIT(31));\n}\n\n \nstatic const struct rhashtable_params efx_mae_mports_ht_params = {\n\t.key_len\t= sizeof(u32),\n\t.key_offset\t= offsetof(struct mae_mport_desc, mport_id),\n\t.head_offset\t= offsetof(struct mae_mport_desc, linkage),\n};\n\nstruct mae_mport_desc *efx_mae_get_mport(struct efx_nic *efx, u32 mport_id)\n{\n\treturn rhashtable_lookup_fast(&efx->mae->mports_ht, &mport_id,\n\t\t\t\t      efx_mae_mports_ht_params);\n}\n\nstatic int efx_mae_add_mport(struct efx_nic *efx, struct mae_mport_desc *desc)\n{\n\tstruct efx_mae *mae = efx->mae;\n\tint rc;\n\n\trc = rhashtable_insert_fast(&mae->mports_ht, &desc->linkage,\n\t\t\t\t    efx_mae_mports_ht_params);\n\n\tif (rc) {\n\t\tpci_err(efx->pci_dev, \"Failed to insert MPORT %08x, rc %d\\n\",\n\t\t\tdesc->mport_id, rc);\n\t\tkfree(desc);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nvoid efx_mae_remove_mport(void *desc, void *arg)\n{\n\tstruct mae_mport_desc *mport = desc;\n\n\tsynchronize_rcu();\n\tkfree(mport);\n}\n\nstatic int efx_mae_process_mport(struct efx_nic *efx,\n\t\t\t\t struct mae_mport_desc *desc)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tstruct mae_mport_desc *mport;\n\n\tmport = efx_mae_get_mport(efx, desc->mport_id);\n\tif (!IS_ERR_OR_NULL(mport)) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"mport with id %u does exist!!!\\n\", desc->mport_id);\n\t\treturn -EEXIST;\n\t}\n\n\tif (nic_data->have_own_mport &&\n\t    desc->mport_id == nic_data->own_mport) {\n\t\tWARN_ON(desc->mport_type != MAE_MPORT_DESC_MPORT_TYPE_VNIC);\n\t\tWARN_ON(desc->vnic_client_type !=\n\t\t\tMAE_MPORT_DESC_VNIC_CLIENT_TYPE_FUNCTION);\n\t\tnic_data->local_mae_intf = desc->interface_idx;\n\t\tnic_data->have_local_intf = true;\n\t\tpci_dbg(efx->pci_dev, \"MAE interface_idx is %u\\n\",\n\t\t\tnic_data->local_mae_intf);\n\t}\n\n\treturn efx_mae_add_mport(efx, desc);\n}\n\n#define MCDI_MPORT_JOURNAL_LEN \\\n\tALIGN(MC_CMD_MAE_MPORT_READ_JOURNAL_OUT_LENMAX_MCDI2, 4)\n\nint efx_mae_enumerate_mports(struct efx_nic *efx)\n{\n\tefx_dword_t *outbuf = kzalloc(MCDI_MPORT_JOURNAL_LEN, GFP_KERNEL);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_MPORT_READ_JOURNAL_IN_LEN);\n\tMCDI_DECLARE_STRUCT_PTR(desc);\n\tsize_t outlen, stride, count;\n\tint rc = 0, i;\n\n\tif (!outbuf)\n\t\treturn -ENOMEM;\n\tdo {\n\t\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_MPORT_READ_JOURNAL, inbuf,\n\t\t\t\t  sizeof(inbuf), outbuf,\n\t\t\t\t  MCDI_MPORT_JOURNAL_LEN, &outlen);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tif (outlen < MC_CMD_MAE_MPORT_READ_JOURNAL_OUT_MPORT_DESC_DATA_OFST) {\n\t\t\trc = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcount = MCDI_DWORD(outbuf, MAE_MPORT_READ_JOURNAL_OUT_MPORT_DESC_COUNT);\n\t\tif (!count)\n\t\t\tcontinue;  \n\t\tstride = MCDI_DWORD(outbuf, MAE_MPORT_READ_JOURNAL_OUT_SIZEOF_MPORT_DESC);\n\t\tif (stride < MAE_MPORT_DESC_LEN) {\n\t\t\trc = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (outlen < MC_CMD_MAE_MPORT_READ_JOURNAL_OUT_LEN(count * stride)) {\n\t\t\trc = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstruct mae_mport_desc *d;\n\n\t\t\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\t\t\tif (!d) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdesc = (efx_dword_t *)\n\t\t\t\t_MCDI_PTR(outbuf, MC_CMD_MAE_MPORT_READ_JOURNAL_OUT_MPORT_DESC_DATA_OFST +\n\t\t\t\t\t  i * stride);\n\t\t\td->mport_id = MCDI_STRUCT_DWORD(desc, MAE_MPORT_DESC_MPORT_ID);\n\t\t\td->flags = MCDI_STRUCT_DWORD(desc, MAE_MPORT_DESC_FLAGS);\n\t\t\td->caller_flags = MCDI_STRUCT_DWORD(desc,\n\t\t\t\t\t\t\t    MAE_MPORT_DESC_CALLER_FLAGS);\n\t\t\td->mport_type = MCDI_STRUCT_DWORD(desc,\n\t\t\t\t\t\t\t  MAE_MPORT_DESC_MPORT_TYPE);\n\t\t\tswitch (d->mport_type) {\n\t\t\tcase MAE_MPORT_DESC_MPORT_TYPE_NET_PORT:\n\t\t\t\td->port_idx = MCDI_STRUCT_DWORD(desc,\n\t\t\t\t\t\t\t\tMAE_MPORT_DESC_NET_PORT_IDX);\n\t\t\t\tbreak;\n\t\t\tcase MAE_MPORT_DESC_MPORT_TYPE_ALIAS:\n\t\t\t\td->alias_mport_id = MCDI_STRUCT_DWORD(desc,\n\t\t\t\t\t\t\t\t      MAE_MPORT_DESC_ALIAS_DELIVER_MPORT_ID);\n\t\t\t\tbreak;\n\t\t\tcase MAE_MPORT_DESC_MPORT_TYPE_VNIC:\n\t\t\t\td->vnic_client_type = MCDI_STRUCT_DWORD(desc,\n\t\t\t\t\t\t\t\t\tMAE_MPORT_DESC_VNIC_CLIENT_TYPE);\n\t\t\t\td->interface_idx = MCDI_STRUCT_DWORD(desc,\n\t\t\t\t\t\t\t\t     MAE_MPORT_DESC_VNIC_FUNCTION_INTERFACE);\n\t\t\t\td->pf_idx = MCDI_STRUCT_WORD(desc,\n\t\t\t\t\t\t\t     MAE_MPORT_DESC_VNIC_FUNCTION_PF_IDX);\n\t\t\t\td->vf_idx = MCDI_STRUCT_WORD(desc,\n\t\t\t\t\t\t\t     MAE_MPORT_DESC_VNIC_FUNCTION_VF_IDX);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trc = efx_mae_process_mport(efx, d);\n\t\t\t \n\t\t\tif (rc)\n\t\t\t\tgoto fail;\n\t\t}\n\t} while (MCDI_FIELD(outbuf, MAE_MPORT_READ_JOURNAL_OUT, MORE) &&\n\t\t !WARN_ON(!count));\nfail:\n\tkfree(outbuf);\n\treturn rc;\n}\n\n \nint efx_mae_allocate_pedit_mac(struct efx_nic *efx,\n\t\t\t       struct efx_tc_mac_pedit_action *ped)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_MAC_ADDR_ALLOC_OUT_LEN);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_MAC_ADDR_ALLOC_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_MAE_MAC_ADDR_ALLOC_IN_MAC_ADDR_LEN !=\n\t\t     sizeof(ped->h_addr));\n\tmemcpy(MCDI_PTR(inbuf, MAE_MAC_ADDR_ALLOC_IN_MAC_ADDR), ped->h_addr,\n\t       sizeof(ped->h_addr));\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_MAC_ADDR_ALLOC, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\tped->fw_id = MCDI_DWORD(outbuf, MAE_MAC_ADDR_ALLOC_OUT_MAC_ID);\n\treturn 0;\n}\n\n \nvoid efx_mae_free_pedit_mac(struct efx_nic *efx,\n\t\t\t    struct efx_tc_mac_pedit_action *ped)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_MAC_ADDR_FREE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_MAC_ADDR_FREE_IN_LEN(1));\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_MAC_ADDR_FREE_IN_MAC_ID, ped->fw_id);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_MAC_ADDR_FREE, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc || outlen < sizeof(outbuf))\n\t\treturn;\n\t \n\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_MAC_ADDR_FREE_OUT_FREED_MAC_ID) != ped->fw_id))\n\t\treturn;\n\t \n\tped->fw_id = MC_CMD_MAE_MAC_ADDR_ALLOC_OUT_MAC_ID_NULL;\n}\n\nint efx_mae_alloc_action_set(struct efx_nic *efx, struct efx_tc_action_set *act)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ACTION_SET_ALLOC_OUT_LEN);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ACTION_SET_ALLOC_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_POPULATE_DWORD_4(inbuf, MAE_ACTION_SET_ALLOC_IN_FLAGS,\n\t\t\t      MAE_ACTION_SET_ALLOC_IN_VLAN_PUSH, act->vlan_push,\n\t\t\t      MAE_ACTION_SET_ALLOC_IN_VLAN_POP, act->vlan_pop,\n\t\t\t      MAE_ACTION_SET_ALLOC_IN_DECAP, act->decap,\n\t\t\t      MAE_ACTION_SET_ALLOC_IN_DO_DECR_IP_TTL,\n\t\t\t      act->do_ttl_dec);\n\n\tif (act->src_mac)\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_SRC_MAC_ID,\n\t\t\t       act->src_mac->fw_id);\n\telse\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_SRC_MAC_ID,\n\t\t\t       MC_CMD_MAE_MAC_ADDR_ALLOC_OUT_MAC_ID_NULL);\n\n\tif (act->dst_mac)\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_DST_MAC_ID,\n\t\t\t       act->dst_mac->fw_id);\n\telse\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_DST_MAC_ID,\n\t\t\t       MC_CMD_MAE_MAC_ADDR_ALLOC_OUT_MAC_ID_NULL);\n\n\tif (act->count && !WARN_ON(!act->count->cnt))\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_COUNTER_ID,\n\t\t\t       act->count->cnt->fw_id);\n\telse\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_COUNTER_ID,\n\t\t\t       MC_CMD_MAE_COUNTER_ALLOC_OUT_COUNTER_ID_NULL);\n\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_COUNTER_LIST_ID,\n\t\t       MC_CMD_MAE_COUNTER_LIST_ALLOC_OUT_COUNTER_LIST_ID_NULL);\n\tif (act->vlan_push) {\n\t\tMCDI_SET_WORD_BE(inbuf, MAE_ACTION_SET_ALLOC_IN_VLAN0_TCI_BE,\n\t\t\t\t act->vlan_tci[0]);\n\t\tMCDI_SET_WORD_BE(inbuf, MAE_ACTION_SET_ALLOC_IN_VLAN0_PROTO_BE,\n\t\t\t\t act->vlan_proto[0]);\n\t}\n\tif (act->vlan_push >= 2) {\n\t\tMCDI_SET_WORD_BE(inbuf, MAE_ACTION_SET_ALLOC_IN_VLAN1_TCI_BE,\n\t\t\t\t act->vlan_tci[1]);\n\t\tMCDI_SET_WORD_BE(inbuf, MAE_ACTION_SET_ALLOC_IN_VLAN1_PROTO_BE,\n\t\t\t\t act->vlan_proto[1]);\n\t}\n\tif (act->encap_md)\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_ENCAP_HEADER_ID,\n\t\t\t       act->encap_md->fw_id);\n\telse\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_ENCAP_HEADER_ID,\n\t\t\t       MC_CMD_MAE_ENCAP_HEADER_ALLOC_OUT_ENCAP_HEADER_ID_NULL);\n\tif (act->deliver)\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_ALLOC_IN_DELIVER,\n\t\t\t       act->dest_mport);\n\tBUILD_BUG_ON(MAE_MPORT_SELECTOR_NULL);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ACTION_SET_ALLOC, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\tact->fw_id = MCDI_DWORD(outbuf, MAE_ACTION_SET_ALLOC_OUT_AS_ID);\n\t \n\tif (WARN_ON_ONCE(efx_mae_asl_id(act->fw_id))) {\n\t\tefx_mae_free_action_set(efx, act->fw_id);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nint efx_mae_free_action_set(struct efx_nic *efx, u32 fw_id)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ACTION_SET_FREE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ACTION_SET_FREE_IN_LEN(1));\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_FREE_IN_AS_ID, fw_id);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ACTION_SET_FREE, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t \n\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_ACTION_SET_FREE_OUT_FREED_AS_ID) != fw_id))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nint efx_mae_alloc_action_set_list(struct efx_nic *efx,\n\t\t\t\t  struct efx_tc_action_set_list *acts)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ACTION_SET_LIST_ALLOC_OUT_LEN);\n\tstruct efx_tc_action_set *act;\n\tsize_t inlen, outlen, i = 0;\n\tefx_dword_t *inbuf;\n\tint rc;\n\n\tlist_for_each_entry(act, &acts->list, list)\n\t\ti++;\n\tif (i == 0)\n\t\treturn -EINVAL;\n\tif (i == 1) {\n\t\t \n\t\tact = list_first_entry(&acts->list, struct efx_tc_action_set, list);\n\t\tacts->fw_id = act->fw_id;\n\t\treturn 0;\n\t}\n\tif (i > MC_CMD_MAE_ACTION_SET_LIST_ALLOC_IN_AS_IDS_MAXNUM_MCDI2)\n\t\treturn -EOPNOTSUPP;  \n\tinlen = MC_CMD_MAE_ACTION_SET_LIST_ALLOC_IN_LEN(i);\n\tinbuf = kzalloc(inlen, GFP_KERNEL);\n\tif (!inbuf)\n\t\treturn -ENOMEM;\n\ti = 0;\n\tlist_for_each_entry(act, &acts->list, list) {\n\t\tMCDI_SET_ARRAY_DWORD(inbuf, MAE_ACTION_SET_LIST_ALLOC_IN_AS_IDS,\n\t\t\t\t     i, act->fw_id);\n\t\ti++;\n\t}\n\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_LIST_ALLOC_IN_COUNT, i);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ACTION_SET_LIST_ALLOC, inbuf, inlen,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto out_free;\n\tif (outlen < sizeof(outbuf)) {\n\t\trc = -EIO;\n\t\tgoto out_free;\n\t}\n\tacts->fw_id = MCDI_DWORD(outbuf, MAE_ACTION_SET_LIST_ALLOC_OUT_ASL_ID);\n\t \n\tif (WARN_ON_ONCE(!efx_mae_asl_id(acts->fw_id))) {\n\t\tefx_mae_free_action_set_list(efx, acts);\n\t\trc = -EIO;\n\t}\nout_free:\n\tkfree(inbuf);\n\treturn rc;\n}\n\nint efx_mae_free_action_set_list(struct efx_nic *efx,\n\t\t\t\t struct efx_tc_action_set_list *acts)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ACTION_SET_LIST_FREE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ACTION_SET_LIST_FREE_IN_LEN(1));\n\tsize_t outlen;\n\tint rc;\n\n\t \n\tif (efx_mae_asl_id(acts->fw_id)) {\n\t\tMCDI_SET_DWORD(inbuf, MAE_ACTION_SET_LIST_FREE_IN_ASL_ID,\n\t\t\t       acts->fw_id);\n\t\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ACTION_SET_LIST_FREE, inbuf,\n\t\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (outlen < sizeof(outbuf))\n\t\t\treturn -EIO;\n\t\t \n\t\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_ACTION_SET_LIST_FREE_OUT_FREED_ASL_ID) != acts->fw_id))\n\t\t\treturn -EIO;\n\t}\n\t \n\tacts->fw_id = MC_CMD_MAE_ACTION_SET_LIST_ALLOC_OUT_ACTION_SET_LIST_ID_NULL;\n\treturn 0;\n}\n\nint efx_mae_register_encap_match(struct efx_nic *efx,\n\t\t\t\t struct efx_tc_encap_match *encap)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_OUTER_RULE_INSERT_IN_LEN(MAE_ENC_FIELD_PAIRS_LEN));\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_OUTER_RULE_INSERT_OUT_LEN);\n\tMCDI_DECLARE_STRUCT_PTR(match_crit);\n\tsize_t outlen;\n\tint rc;\n\n\trc = efx_mae_encap_type_to_mae_type(encap->tun_type);\n\tif (rc < 0)\n\t\treturn rc;\n\tmatch_crit = _MCDI_DWORD(inbuf, MAE_OUTER_RULE_INSERT_IN_FIELD_MATCH_CRITERIA);\n\t \n\tMCDI_SET_DWORD(inbuf, MAE_OUTER_RULE_INSERT_IN_ENCAP_TYPE, rc);\n#ifdef CONFIG_IPV6\n\tif (encap->src_ip | encap->dst_ip) {\n#endif\n\t\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP4_BE,\n\t\t\t\t\t encap->src_ip);\n\t\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP4_BE_MASK,\n\t\t\t\t\t ~(__be32)0);\n\t\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP4_BE,\n\t\t\t\t\t encap->dst_ip);\n\t\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP4_BE_MASK,\n\t\t\t\t\t ~(__be32)0);\n\t\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETHER_TYPE_BE,\n\t\t\t\t\thtons(ETH_P_IP));\n#ifdef CONFIG_IPV6\n\t} else {\n\t\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP6_BE),\n\t\t       &encap->src_ip6, sizeof(encap->src_ip6));\n\t\tmemset(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP6_BE_MASK),\n\t\t       0xff, sizeof(encap->src_ip6));\n\t\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP6_BE),\n\t\t       &encap->dst_ip6, sizeof(encap->dst_ip6));\n\t\tmemset(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP6_BE_MASK),\n\t\t       0xff, sizeof(encap->dst_ip6));\n\t\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETHER_TYPE_BE,\n\t\t\t\t\thtons(ETH_P_IPV6));\n\t}\n#endif\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETHER_TYPE_BE_MASK,\n\t\t\t\t~(__be16)0);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_DPORT_BE,\n\t\t\t\tencap->udp_dport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_DPORT_BE_MASK,\n\t\t\t\t~(__be16)0);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_DPORT_BE,\n\t\t\t\tencap->udp_sport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_DPORT_BE_MASK,\n\t\t\t\tencap->udp_sport_mask);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_PROTO, IPPROTO_UDP);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_PROTO_MASK, ~0);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_TOS,\n\t\t\t     encap->ip_tos);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_TOS_MASK,\n\t\t\t     encap->ip_tos_mask);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_OUTER_RULE_INSERT, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\tencap->fw_id = MCDI_DWORD(outbuf, MAE_OUTER_RULE_INSERT_OUT_OR_ID);\n\treturn 0;\n}\n\nint efx_mae_unregister_encap_match(struct efx_nic *efx,\n\t\t\t\t   struct efx_tc_encap_match *encap)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_OUTER_RULE_REMOVE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_OUTER_RULE_REMOVE_IN_LEN(1));\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_OUTER_RULE_REMOVE_IN_OR_ID, encap->fw_id);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_OUTER_RULE_REMOVE, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t \n\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_OUTER_RULE_REMOVE_OUT_REMOVED_OR_ID) != encap->fw_id))\n\t\treturn -EIO;\n\t \n\tencap->fw_id = MC_CMD_MAE_OUTER_RULE_INSERT_OUT_OUTER_RULE_ID_NULL;\n\treturn 0;\n}\n\nstatic int efx_mae_populate_lhs_match_criteria(MCDI_DECLARE_STRUCT_PTR(match_crit),\n\t\t\t\t\t       const struct efx_tc_match *match)\n{\n\tif (match->mask.ingress_port) {\n\t\tif (~match->mask.ingress_port)\n\t\t\treturn -EOPNOTSUPP;\n\t\tMCDI_STRUCT_SET_DWORD(match_crit,\n\t\t\t\t      MAE_ENC_FIELD_PAIRS_INGRESS_MPORT_SELECTOR,\n\t\t\t\t      match->value.ingress_port);\n\t}\n\tMCDI_STRUCT_SET_DWORD(match_crit, MAE_ENC_FIELD_PAIRS_INGRESS_MPORT_SELECTOR_MASK,\n\t\t\t      match->mask.ingress_port);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETHER_TYPE_BE,\n\t\t\t\tmatch->value.eth_proto);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETHER_TYPE_BE_MASK,\n\t\t\t\tmatch->mask.eth_proto);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN0_TCI_BE,\n\t\t\t\tmatch->value.vlan_tci[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN0_TCI_BE_MASK,\n\t\t\t\tmatch->mask.vlan_tci[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN0_PROTO_BE,\n\t\t\t\tmatch->value.vlan_proto[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN0_PROTO_BE_MASK,\n\t\t\t\tmatch->mask.vlan_proto[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN1_TCI_BE,\n\t\t\t\tmatch->value.vlan_tci[1]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN1_TCI_BE_MASK,\n\t\t\t\tmatch->mask.vlan_tci[1]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN1_PROTO_BE,\n\t\t\t\tmatch->value.vlan_proto[1]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_VLAN1_PROTO_BE_MASK,\n\t\t\t\tmatch->mask.vlan_proto[1]);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETH_SADDR_BE),\n\t       match->value.eth_saddr, ETH_ALEN);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETH_SADDR_BE_MASK),\n\t       match->mask.eth_saddr, ETH_ALEN);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETH_DADDR_BE),\n\t       match->value.eth_daddr, ETH_ALEN);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_ETH_DADDR_BE_MASK),\n\t       match->mask.eth_daddr, ETH_ALEN);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_PROTO,\n\t\t\t     match->value.ip_proto);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_PROTO_MASK,\n\t\t\t     match->mask.ip_proto);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_TOS,\n\t\t\t     match->value.ip_tos);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_TOS_MASK,\n\t\t\t     match->mask.ip_tos);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_TTL,\n\t\t\t     match->value.ip_ttl);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_IP_TTL_MASK,\n\t\t\t     match->mask.ip_ttl);\n\tMCDI_STRUCT_POPULATE_BYTE_1(match_crit,\n\t\t\t\t    MAE_ENC_FIELD_PAIRS_ENC_VLAN_FLAGS,\n\t\t\t\t    MAE_ENC_FIELD_PAIRS_ENC_IP_FRAG,\n\t\t\t\t    match->value.ip_frag);\n\tMCDI_STRUCT_POPULATE_BYTE_1(match_crit,\n\t\t\t\t    MAE_ENC_FIELD_PAIRS_ENC_VLAN_FLAGS_MASK,\n\t\t\t\t    MAE_ENC_FIELD_PAIRS_ENC_IP_FRAG_MASK,\n\t\t\t\t    match->mask.ip_frag);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP4_BE,\n\t\t\t\t match->value.src_ip);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP4_BE_MASK,\n\t\t\t\t match->mask.src_ip);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP4_BE,\n\t\t\t\t match->value.dst_ip);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP4_BE_MASK,\n\t\t\t\t match->mask.dst_ip);\n#ifdef CONFIG_IPV6\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP6_BE),\n\t       &match->value.src_ip6, sizeof(struct in6_addr));\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_SRC_IP6_BE_MASK),\n\t       &match->mask.src_ip6, sizeof(struct in6_addr));\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP6_BE),\n\t       &match->value.dst_ip6, sizeof(struct in6_addr));\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_ENC_FIELD_PAIRS_ENC_DST_IP6_BE_MASK),\n\t       &match->mask.dst_ip6, sizeof(struct in6_addr));\n#endif\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_SPORT_BE,\n\t\t\t\tmatch->value.l4_sport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_SPORT_BE_MASK,\n\t\t\t\tmatch->mask.l4_sport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_DPORT_BE,\n\t\t\t\tmatch->value.l4_dport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_ENC_FIELD_PAIRS_ENC_L4_DPORT_BE_MASK,\n\t\t\t\tmatch->mask.l4_dport);\n\t \n\tif (WARN_ON_ONCE(match->encap && !match->encap->type))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON_ONCE(match->mask.enc_src_ip))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON_ONCE(match->mask.enc_dst_ip))\n\t\treturn -EOPNOTSUPP;\n#ifdef CONFIG_IPV6\n\tif (WARN_ON_ONCE(!ipv6_addr_any(&match->mask.enc_src_ip6)))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON_ONCE(!ipv6_addr_any(&match->mask.enc_dst_ip6)))\n\t\treturn -EOPNOTSUPP;\n#endif\n\tif (WARN_ON_ONCE(match->mask.enc_ip_tos))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON_ONCE(match->mask.enc_ip_ttl))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON_ONCE(match->mask.enc_sport))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON_ONCE(match->mask.enc_dport))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON_ONCE(match->mask.enc_keyid))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic int efx_mae_insert_lhs_outer_rule(struct efx_nic *efx,\n\t\t\t\t\t struct efx_tc_lhs_rule *rule, u32 prio)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_OUTER_RULE_INSERT_IN_LEN(MAE_ENC_FIELD_PAIRS_LEN));\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_OUTER_RULE_INSERT_OUT_LEN);\n\tMCDI_DECLARE_STRUCT_PTR(match_crit);\n\tconst struct efx_tc_lhs_action *act;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_OUTER_RULE_INSERT_IN_PRIO, prio);\n\t \n\tmatch_crit = _MCDI_DWORD(inbuf, MAE_OUTER_RULE_INSERT_IN_FIELD_MATCH_CRITERIA);\n\trc = efx_mae_populate_lhs_match_criteria(match_crit, &rule->match);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tact = &rule->lhs_act;\n\tMCDI_SET_DWORD(inbuf, MAE_OUTER_RULE_INSERT_IN_ENCAP_TYPE,\n\t\t       MAE_MCDI_ENCAP_TYPE_NONE);\n\t \n\tMCDI_POPULATE_DWORD_6(inbuf, MAE_OUTER_RULE_INSERT_IN_LOOKUP_CONTROL,\n\t\t\t      MAE_OUTER_RULE_INSERT_IN_DO_CT, !!act->zone,\n\t\t\t      MAE_OUTER_RULE_INSERT_IN_CT_TCP_FLAGS_INHIBIT, 1,\n\t\t\t      MAE_OUTER_RULE_INSERT_IN_CT_DOMAIN,\n\t\t\t      act->zone ? act->zone->zone : 0,\n\t\t\t      MAE_OUTER_RULE_INSERT_IN_CT_VNI_MODE,\n\t\t\t      MAE_CT_VNI_MODE_ZERO,\n\t\t\t      MAE_OUTER_RULE_INSERT_IN_DO_COUNT, !!act->count,\n\t\t\t      MAE_OUTER_RULE_INSERT_IN_RECIRC_ID,\n\t\t\t      act->rid ? act->rid->fw_id : 0);\n\tif (act->count)\n\t\tMCDI_SET_DWORD(inbuf, MAE_OUTER_RULE_INSERT_IN_COUNTER_ID,\n\t\t\t       act->count->cnt->fw_id);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_OUTER_RULE_INSERT, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\trule->fw_id = MCDI_DWORD(outbuf, MAE_OUTER_RULE_INSERT_OUT_OR_ID);\n\treturn 0;\n}\n\nint efx_mae_insert_lhs_rule(struct efx_nic *efx, struct efx_tc_lhs_rule *rule,\n\t\t\t    u32 prio)\n{\n\treturn efx_mae_insert_lhs_outer_rule(efx, rule, prio);\n}\n\nstatic int efx_mae_remove_lhs_outer_rule(struct efx_nic *efx,\n\t\t\t\t\t struct efx_tc_lhs_rule *rule)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_OUTER_RULE_REMOVE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_OUTER_RULE_REMOVE_IN_LEN(1));\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_OUTER_RULE_REMOVE_IN_OR_ID, rule->fw_id);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_OUTER_RULE_REMOVE, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t \n\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_OUTER_RULE_REMOVE_OUT_REMOVED_OR_ID) != rule->fw_id))\n\t\treturn -EIO;\n\t \n\trule->fw_id = MC_CMD_MAE_OUTER_RULE_INSERT_OUT_OUTER_RULE_ID_NULL;\n\treturn 0;\n}\n\nint efx_mae_remove_lhs_rule(struct efx_nic *efx, struct efx_tc_lhs_rule *rule)\n{\n\treturn efx_mae_remove_lhs_outer_rule(efx, rule);\n}\n\n \nstatic int efx_mae_table_populate(struct efx_tc_table_field_fmt field,\n\t\t\t\t  __le32 *row, size_t row_bits,\n\t\t\t\t  void *value, size_t value_size)\n{\n\tunsigned int i;\n\n\t \n\tif (field.scheme)\n\t\treturn -EOPNOTSUPP;\n\tif (DIV_ROUND_UP(field.width, 8) != value_size)\n\t\treturn -EINVAL;\n\tif (field.lbn + field.width > row_bits)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < value_size; i++) {\n\t\tunsigned int bn = field.lbn + i * 8;\n\t\tunsigned int wn = bn / 32;\n\t\tu64 v;\n\n\t\tv = ((u8 *)value)[value_size - i - 1];\n\t\tv <<= (bn % 32);\n\t\trow[wn] |= cpu_to_le32(v & 0xffffffff);\n\t\tif (wn * 32 < row_bits)\n\t\t\trow[wn + 1] |= cpu_to_le32(v >> 32);\n\t}\n\treturn 0;\n}\n\nstatic int efx_mae_table_populate_bool(struct efx_tc_table_field_fmt field,\n\t\t\t\t       __le32 *row, size_t row_bits, bool value)\n{\n\tu8 v = value ? 1 : 0;\n\n\tif (field.width != 1)\n\t\treturn -EINVAL;\n\treturn efx_mae_table_populate(field, row, row_bits, &v, 1);\n}\n\nstatic int efx_mae_table_populate_ipv4(struct efx_tc_table_field_fmt field,\n\t\t\t\t       __le32 *row, size_t row_bits, __be32 value)\n{\n\t \n\tstruct in6_addr v = {};\n\n\tif (field.width != 128)\n\t\treturn -EINVAL;\n\tv.s6_addr32[0] = value;\n\treturn efx_mae_table_populate(field, row, row_bits, &v, sizeof(v));\n}\n\nstatic int efx_mae_table_populate_u24(struct efx_tc_table_field_fmt field,\n\t\t\t\t      __le32 *row, size_t row_bits, u32 value)\n{\n\t__be32 v = cpu_to_be32(value);\n\n\t \n\treturn efx_mae_table_populate(field, row, row_bits, ((void *)&v) + 1,\n\t\t\t\t      sizeof(v) - 1);\n}\n\n#define _TABLE_POPULATE(dst, dw, _field, _value) ({\t\\\n\ttypeof(_value) _v = _value;\t\t\t\\\n\t\t\t\t\t\t\t\\\n\t(_field.width == sizeof(_value) * 8) ?\t\t\\\n\t efx_mae_table_populate(_field, dst, dw, &_v,\t\\\n\t\t\t\tsizeof(_v)) : -EINVAL;\t\\\n})\n#define TABLE_POPULATE_KEY_IPV4(dst, _table, _field, _value)\t\t       \\\n\tefx_mae_table_populate_ipv4(efx->tc->meta_##_table.desc.keys\t       \\\n\t\t\t\t    [efx->tc->meta_##_table.keys._field##_idx],\\\n\t\t\t\t    dst, efx->tc->meta_##_table.desc.key_width,\\\n\t\t\t\t    _value)\n#define TABLE_POPULATE_KEY(dst, _table, _field, _value)\t\t\t\\\n\t_TABLE_POPULATE(dst, efx->tc->meta_##_table.desc.key_width,\t\\\n\t\t\tefx->tc->meta_##_table.desc.keys\t\t\\\n\t\t\t[efx->tc->meta_##_table.keys._field##_idx],\t\\\n\t\t\t_value)\n\n#define TABLE_POPULATE_RESP_BOOL(dst, _table, _field, _value)\t\t\t\\\n\tefx_mae_table_populate_bool(efx->tc->meta_##_table.desc.resps\t\t\\\n\t\t\t\t    [efx->tc->meta_##_table.resps._field##_idx],\\\n\t\t\t\t    dst, efx->tc->meta_##_table.desc.resp_width,\\\n\t\t\t\t    _value)\n#define TABLE_POPULATE_RESP(dst, _table, _field, _value)\t\t\\\n\t_TABLE_POPULATE(dst, efx->tc->meta_##_table.desc.resp_width,\t\\\n\t\t\tefx->tc->meta_##_table.desc.resps\t\t\\\n\t\t\t[efx->tc->meta_##_table.resps._field##_idx],\t\\\n\t\t\t_value)\n\n#define TABLE_POPULATE_RESP_U24(dst, _table, _field, _value)\t\t       \\\n\tefx_mae_table_populate_u24(efx->tc->meta_##_table.desc.resps\t       \\\n\t\t\t\t   [efx->tc->meta_##_table.resps._field##_idx],\\\n\t\t\t\t   dst, efx->tc->meta_##_table.desc.resp_width,\\\n\t\t\t\t   _value)\n\nstatic int efx_mae_populate_ct_key(struct efx_nic *efx, __le32 *key, size_t kw,\n\t\t\t\t   struct efx_tc_ct_entry *conn)\n{\n\tbool ipv6 = conn->eth_proto == htons(ETH_P_IPV6);\n\tint rc;\n\n\trc = TABLE_POPULATE_KEY(key, ct, eth_proto, conn->eth_proto);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_POPULATE_KEY(key, ct, ip_proto, conn->ip_proto);\n\tif (rc)\n\t\treturn rc;\n\tif (ipv6)\n\t\trc = TABLE_POPULATE_KEY(key, ct, src_ip, conn->src_ip6);\n\telse\n\t\trc = TABLE_POPULATE_KEY_IPV4(key, ct, src_ip, conn->src_ip);\n\tif (rc)\n\t\treturn rc;\n\tif (ipv6)\n\t\trc = TABLE_POPULATE_KEY(key, ct, dst_ip, conn->dst_ip6);\n\telse\n\t\trc = TABLE_POPULATE_KEY_IPV4(key, ct, dst_ip, conn->dst_ip);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_POPULATE_KEY(key, ct, l4_sport, conn->l4_sport);\n\tif (rc)\n\t\treturn rc;\n\trc = TABLE_POPULATE_KEY(key, ct, l4_dport, conn->l4_dport);\n\tif (rc)\n\t\treturn rc;\n\treturn TABLE_POPULATE_KEY(key, ct, zone, cpu_to_be16(conn->zone->zone));\n}\n\nint efx_mae_insert_ct(struct efx_nic *efx, struct efx_tc_ct_entry *conn)\n{\n\tbool ipv6 = conn->eth_proto == htons(ETH_P_IPV6);\n\t__le32 *key = NULL, *resp = NULL;\n\tsize_t inlen, kw, rw;\n\tefx_dword_t *inbuf;\n\tint rc = -ENOMEM;\n\n\t \n\tif (!efx->tc->meta_ct.hooked)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tkw = DIV_ROUND_UP(efx->tc->meta_ct.desc.key_width, 32);\n\trw = DIV_ROUND_UP(efx->tc->meta_ct.desc.resp_width, 32);\n\tBUILD_BUG_ON(sizeof(__le32) != MC_CMD_TABLE_INSERT_IN_DATA_LEN);\n\tinlen = MC_CMD_TABLE_INSERT_IN_LEN(kw + rw);\n\tif (inlen > MC_CMD_TABLE_INSERT_IN_LENMAX_MCDI2)\n\t\treturn -E2BIG;\n\tinbuf = kzalloc(inlen, GFP_KERNEL);\n\tif (!inbuf)\n\t\treturn -ENOMEM;\n\n\tkey = kcalloc(kw, sizeof(__le32), GFP_KERNEL);\n\tif (!key)\n\t\tgoto out_free;\n\tresp = kcalloc(rw, sizeof(__le32), GFP_KERNEL);\n\tif (!resp)\n\t\tgoto out_free;\n\n\trc = efx_mae_populate_ct_key(efx, key, kw, conn);\n\tif (rc)\n\t\tgoto out_free;\n\n\trc = TABLE_POPULATE_RESP_BOOL(resp, ct, dnat, conn->dnat);\n\tif (rc)\n\t\tgoto out_free;\n\t \n\tif (!ipv6)\n\t\trc = TABLE_POPULATE_RESP(resp, ct, nat_ip, conn->nat_ip);\n\tif (rc)\n\t\tgoto out_free;\n\trc = TABLE_POPULATE_RESP(resp, ct, l4_natport, conn->l4_natport);\n\tif (rc)\n\t\tgoto out_free;\n\trc = TABLE_POPULATE_RESP(resp, ct, mark, cpu_to_be32(conn->mark));\n\tif (rc)\n\t\tgoto out_free;\n\trc = TABLE_POPULATE_RESP_U24(resp, ct, counter_id, conn->cnt->fw_id);\n\tif (rc)\n\t\tgoto out_free;\n\n\tMCDI_SET_DWORD(inbuf, TABLE_INSERT_IN_TABLE_ID, TABLE_ID_CONNTRACK_TABLE);\n\tMCDI_SET_WORD(inbuf, TABLE_INSERT_IN_KEY_WIDTH,\n\t\t      efx->tc->meta_ct.desc.key_width);\n\t \n\tMCDI_SET_WORD(inbuf, TABLE_INSERT_IN_RESP_WIDTH,\n\t\t      efx->tc->meta_ct.desc.resp_width);\n\tmemcpy(MCDI_PTR(inbuf, TABLE_INSERT_IN_DATA), key, kw * sizeof(__le32));\n\tmemcpy(MCDI_PTR(inbuf, TABLE_INSERT_IN_DATA) + kw * sizeof(__le32),\n\t       resp, rw * sizeof(__le32));\n\n\tBUILD_BUG_ON(MC_CMD_TABLE_INSERT_OUT_LEN);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_TABLE_INSERT, inbuf, inlen, NULL, 0, NULL);\n\nout_free:\n\tkfree(resp);\n\tkfree(key);\n\tkfree(inbuf);\n\treturn rc;\n}\n\nint efx_mae_remove_ct(struct efx_nic *efx, struct efx_tc_ct_entry *conn)\n{\n\t__le32 *key = NULL;\n\tefx_dword_t *inbuf;\n\tsize_t inlen, kw;\n\tint rc = -ENOMEM;\n\n\t \n\tif (!efx->tc->meta_ct.hooked)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tkw = DIV_ROUND_UP(efx->tc->meta_ct.desc.key_width, 32);\n\tBUILD_BUG_ON(sizeof(__le32) != MC_CMD_TABLE_DELETE_IN_DATA_LEN);\n\tinlen = MC_CMD_TABLE_DELETE_IN_LEN(kw);\n\tif (inlen > MC_CMD_TABLE_DELETE_IN_LENMAX_MCDI2)\n\t\treturn -E2BIG;\n\tinbuf = kzalloc(inlen, GFP_KERNEL);\n\tif (!inbuf)\n\t\treturn -ENOMEM;\n\n\tkey = kcalloc(kw, sizeof(__le32), GFP_KERNEL);\n\tif (!key)\n\t\tgoto out_free;\n\n\trc = efx_mae_populate_ct_key(efx, key, kw, conn);\n\tif (rc)\n\t\tgoto out_free;\n\n\tMCDI_SET_DWORD(inbuf, TABLE_DELETE_IN_TABLE_ID, TABLE_ID_CONNTRACK_TABLE);\n\tMCDI_SET_WORD(inbuf, TABLE_DELETE_IN_KEY_WIDTH,\n\t\t      efx->tc->meta_ct.desc.key_width);\n\t \n\t \n\tmemcpy(MCDI_PTR(inbuf, TABLE_DELETE_IN_DATA), key, kw * sizeof(__le32));\n\n\tBUILD_BUG_ON(MC_CMD_TABLE_DELETE_OUT_LEN);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_TABLE_DELETE, inbuf, inlen, NULL, 0, NULL);\n\nout_free:\n\tkfree(key);\n\tkfree(inbuf);\n\treturn rc;\n}\n\nstatic int efx_mae_populate_match_criteria(MCDI_DECLARE_STRUCT_PTR(match_crit),\n\t\t\t\t\t   const struct efx_tc_match *match)\n{\n\tif (match->mask.ingress_port) {\n\t\tif (~match->mask.ingress_port)\n\t\t\treturn -EOPNOTSUPP;\n\t\tMCDI_STRUCT_SET_DWORD(match_crit,\n\t\t\t\t      MAE_FIELD_MASK_VALUE_PAIRS_V2_INGRESS_MPORT_SELECTOR,\n\t\t\t\t      match->value.ingress_port);\n\t}\n\tMCDI_STRUCT_SET_DWORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_INGRESS_MPORT_SELECTOR_MASK,\n\t\t\t      match->mask.ingress_port);\n\tEFX_POPULATE_DWORD_5(*_MCDI_STRUCT_DWORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_FLAGS),\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_DO_CT,\n\t\t\t     match->value.ct_state_trk,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_CT_HIT,\n\t\t\t     match->value.ct_state_est,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_IS_IP_FRAG,\n\t\t\t     match->value.ip_frag,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_FIRST_FRAG,\n\t\t\t     match->value.ip_firstfrag,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_TCP_SYN_FIN_RST,\n\t\t\t     match->value.tcp_syn_fin_rst);\n\tEFX_POPULATE_DWORD_5(*_MCDI_STRUCT_DWORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_FLAGS_MASK),\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_DO_CT,\n\t\t\t     match->mask.ct_state_trk,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_CT_HIT,\n\t\t\t     match->mask.ct_state_est,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_IS_IP_FRAG,\n\t\t\t     match->mask.ip_frag,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_FIRST_FRAG,\n\t\t\t     match->mask.ip_firstfrag,\n\t\t\t     MAE_FIELD_MASK_VALUE_PAIRS_V2_TCP_SYN_FIN_RST,\n\t\t\t     match->mask.tcp_syn_fin_rst);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_RECIRC_ID,\n\t\t\t     match->value.recirc_id);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_RECIRC_ID_MASK,\n\t\t\t     match->mask.recirc_id);\n\tMCDI_STRUCT_SET_DWORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_CT_MARK,\n\t\t\t      match->value.ct_mark);\n\tMCDI_STRUCT_SET_DWORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_CT_MARK_MASK,\n\t\t\t      match->mask.ct_mark);\n\tMCDI_STRUCT_SET_WORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_CT_DOMAIN,\n\t\t\t     match->value.ct_zone);\n\tMCDI_STRUCT_SET_WORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_CT_DOMAIN_MASK,\n\t\t\t     match->mask.ct_zone);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ETHER_TYPE_BE,\n\t\t\t\tmatch->value.eth_proto);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ETHER_TYPE_BE_MASK,\n\t\t\t\tmatch->mask.eth_proto);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN0_TCI_BE,\n\t\t\t\tmatch->value.vlan_tci[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN0_TCI_BE_MASK,\n\t\t\t\tmatch->mask.vlan_tci[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN0_PROTO_BE,\n\t\t\t\tmatch->value.vlan_proto[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN0_PROTO_BE_MASK,\n\t\t\t\tmatch->mask.vlan_proto[0]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN1_TCI_BE,\n\t\t\t\tmatch->value.vlan_tci[1]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN1_TCI_BE_MASK,\n\t\t\t\tmatch->mask.vlan_tci[1]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN1_PROTO_BE,\n\t\t\t\tmatch->value.vlan_proto[1]);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_VLAN1_PROTO_BE_MASK,\n\t\t\t\tmatch->mask.vlan_proto[1]);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ETH_SADDR_BE),\n\t       match->value.eth_saddr, ETH_ALEN);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ETH_SADDR_BE_MASK),\n\t       match->mask.eth_saddr, ETH_ALEN);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ETH_DADDR_BE),\n\t       match->value.eth_daddr, ETH_ALEN);\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ETH_DADDR_BE_MASK),\n\t       match->mask.eth_daddr, ETH_ALEN);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_PROTO,\n\t\t\t     match->value.ip_proto);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_PROTO_MASK,\n\t\t\t     match->mask.ip_proto);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_TOS,\n\t\t\t     match->value.ip_tos);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_TOS_MASK,\n\t\t\t     match->mask.ip_tos);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_TTL,\n\t\t\t     match->value.ip_ttl);\n\tMCDI_STRUCT_SET_BYTE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_IP_TTL_MASK,\n\t\t\t     match->mask.ip_ttl);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_SRC_IP4_BE,\n\t\t\t\t match->value.src_ip);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_SRC_IP4_BE_MASK,\n\t\t\t\t match->mask.src_ip);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_DST_IP4_BE,\n\t\t\t\t match->value.dst_ip);\n\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_DST_IP4_BE_MASK,\n\t\t\t\t match->mask.dst_ip);\n#ifdef CONFIG_IPV6\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_SRC_IP6_BE),\n\t       &match->value.src_ip6, sizeof(struct in6_addr));\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_SRC_IP6_BE_MASK),\n\t       &match->mask.src_ip6, sizeof(struct in6_addr));\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_DST_IP6_BE),\n\t       &match->value.dst_ip6, sizeof(struct in6_addr));\n\tmemcpy(MCDI_STRUCT_PTR(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_DST_IP6_BE_MASK),\n\t       &match->mask.dst_ip6, sizeof(struct in6_addr));\n#endif\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_L4_SPORT_BE,\n\t\t\t\tmatch->value.l4_sport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_L4_SPORT_BE_MASK,\n\t\t\t\tmatch->mask.l4_sport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_L4_DPORT_BE,\n\t\t\t\tmatch->value.l4_dport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_L4_DPORT_BE_MASK,\n\t\t\t\tmatch->mask.l4_dport);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_TCP_FLAGS_BE,\n\t\t\t\tmatch->value.tcp_flags);\n\tMCDI_STRUCT_SET_WORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_TCP_FLAGS_BE_MASK,\n\t\t\t\tmatch->mask.tcp_flags);\n\t \n\tif (match->encap) {\n\t\tMCDI_STRUCT_SET_DWORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_OUTER_RULE_ID,\n\t\t\t\t      match->encap->fw_id);\n\t\tMCDI_STRUCT_SET_DWORD(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_OUTER_RULE_ID_MASK,\n\t\t\t\t      U32_MAX);\n\t\t \n\t\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ENC_VNET_ID_BE,\n\t\t\t\t\t match->value.enc_keyid);\n\t\tMCDI_STRUCT_SET_DWORD_BE(match_crit, MAE_FIELD_MASK_VALUE_PAIRS_V2_ENC_VNET_ID_BE_MASK,\n\t\t\t\t\t match->mask.enc_keyid);\n\t} else if (WARN_ON_ONCE(match->mask.enc_src_ip) ||\n\t\t   WARN_ON_ONCE(match->mask.enc_dst_ip) ||\n\t\t   WARN_ON_ONCE(!ipv6_addr_any(&match->mask.enc_src_ip6)) ||\n\t\t   WARN_ON_ONCE(!ipv6_addr_any(&match->mask.enc_dst_ip6)) ||\n\t\t   WARN_ON_ONCE(match->mask.enc_ip_tos) ||\n\t\t   WARN_ON_ONCE(match->mask.enc_ip_ttl) ||\n\t\t   WARN_ON_ONCE(match->mask.enc_sport) ||\n\t\t   WARN_ON_ONCE(match->mask.enc_dport) ||\n\t\t   WARN_ON_ONCE(match->mask.enc_keyid)) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nint efx_mae_insert_rule(struct efx_nic *efx, const struct efx_tc_match *match,\n\t\t\tu32 prio, u32 acts_id, u32 *id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ACTION_RULE_INSERT_IN_LEN(MAE_FIELD_MASK_VALUE_PAIRS_V2_LEN));\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ACTION_RULE_INSERT_OUT_LEN);\n\tMCDI_DECLARE_STRUCT_PTR(match_crit);\n\tMCDI_DECLARE_STRUCT_PTR(response);\n\tsize_t outlen;\n\tint rc;\n\n\tif (!id)\n\t\treturn -EINVAL;\n\n\tmatch_crit = _MCDI_DWORD(inbuf, MAE_ACTION_RULE_INSERT_IN_MATCH_CRITERIA);\n\tresponse = _MCDI_DWORD(inbuf, MAE_ACTION_RULE_INSERT_IN_RESPONSE);\n\tif (efx_mae_asl_id(acts_id)) {\n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_ASL_ID, acts_id);\n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_AS_ID,\n\t\t\t\t      MC_CMD_MAE_ACTION_SET_ALLOC_OUT_ACTION_SET_ID_NULL);\n\t} else {\n\t\t \n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_ASL_ID,\n\t\t\t\t      MC_CMD_MAE_ACTION_SET_LIST_ALLOC_OUT_ACTION_SET_LIST_ID_NULL);\n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_AS_ID, acts_id);\n\t}\n\tMCDI_SET_DWORD(inbuf, MAE_ACTION_RULE_INSERT_IN_PRIO, prio);\n\trc = efx_mae_populate_match_criteria(match_crit, match);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ACTION_RULE_INSERT, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t*id = MCDI_DWORD(outbuf, MAE_ACTION_RULE_INSERT_OUT_AR_ID);\n\treturn 0;\n}\n\nint efx_mae_update_rule(struct efx_nic *efx, u32 acts_id, u32 id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ACTION_RULE_UPDATE_IN_LEN);\n\tMCDI_DECLARE_STRUCT_PTR(response);\n\n\tBUILD_BUG_ON(MC_CMD_MAE_ACTION_RULE_UPDATE_OUT_LEN);\n\tresponse = _MCDI_DWORD(inbuf, MAE_ACTION_RULE_UPDATE_IN_RESPONSE);\n\n\tMCDI_SET_DWORD(inbuf, MAE_ACTION_RULE_UPDATE_IN_AR_ID, id);\n\tif (efx_mae_asl_id(acts_id)) {\n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_ASL_ID, acts_id);\n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_AS_ID,\n\t\t\t\t      MC_CMD_MAE_ACTION_SET_ALLOC_OUT_ACTION_SET_ID_NULL);\n\t} else {\n\t\t \n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_ASL_ID,\n\t\t\t\t      MC_CMD_MAE_ACTION_SET_LIST_ALLOC_OUT_ACTION_SET_LIST_ID_NULL);\n\t\tMCDI_STRUCT_SET_DWORD(response, MAE_ACTION_RULE_RESPONSE_AS_ID, acts_id);\n\t}\n\treturn efx_mcdi_rpc(efx, MC_CMD_MAE_ACTION_RULE_UPDATE, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nint efx_mae_delete_rule(struct efx_nic *efx, u32 id)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_MAE_ACTION_RULE_DELETE_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAE_ACTION_RULE_DELETE_IN_LEN(1));\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, MAE_ACTION_RULE_DELETE_IN_AR_ID, id);\n\trc = efx_mcdi_rpc(efx, MC_CMD_MAE_ACTION_RULE_DELETE, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t \n\tif (WARN_ON(MCDI_DWORD(outbuf, MAE_ACTION_RULE_DELETE_OUT_DELETED_AR_ID) != id))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nint efx_init_mae(struct efx_nic *efx)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tstruct efx_mae *mae;\n\tint rc;\n\n\tif (!nic_data->have_mport)\n\t\treturn -EINVAL;\n\n\tmae = kmalloc(sizeof(*mae), GFP_KERNEL);\n\tif (!mae)\n\t\treturn -ENOMEM;\n\n\trc = rhashtable_init(&mae->mports_ht, &efx_mae_mports_ht_params);\n\tif (rc < 0) {\n\t\tkfree(mae);\n\t\treturn rc;\n\t}\n\tefx->mae = mae;\n\tmae->efx = efx;\n\treturn 0;\n}\n\nvoid efx_fini_mae(struct efx_nic *efx)\n{\n\tstruct efx_mae *mae = efx->mae;\n\n\tkfree(mae);\n\tefx->mae = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}