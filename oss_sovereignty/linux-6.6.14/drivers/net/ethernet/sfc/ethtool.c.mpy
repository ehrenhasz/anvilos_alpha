{
  "module_name": "ethtool.c",
  "hash_id": "cc6eb0fa31d21a5272dd701b4c2b22b183d4fb1032a60bc354bcd8abe33cd9ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/rtnetlink.h>\n#include <linux/in.h>\n#include \"net_driver.h\"\n#include \"workarounds.h\"\n#include \"selftest.h\"\n#include \"efx.h\"\n#include \"efx_channels.h\"\n#include \"rx_common.h\"\n#include \"tx_common.h\"\n#include \"ethtool_common.h\"\n#include \"filter.h\"\n#include \"nic.h\"\n\n#define EFX_ETHTOOL_EEPROM_MAGIC 0xEFAB\n\n \n\n \nstatic int efx_ethtool_phys_id(struct net_device *net_dev,\n\t\t\t       enum ethtool_phys_id_state state)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tenum efx_led_mode mode = EFX_LED_DEFAULT;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ON:\n\t\tmode = EFX_LED_ON;\n\t\tbreak;\n\tcase ETHTOOL_ID_OFF:\n\t\tmode = EFX_LED_OFF;\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tmode = EFX_LED_DEFAULT;\n\t\tbreak;\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 1;\t \n\t}\n\n\treturn efx_mcdi_set_id_led(efx, mode);\n}\n\nstatic int efx_ethtool_get_regs_len(struct net_device *net_dev)\n{\n\treturn efx_nic_get_regs_len(efx_netdev_priv(net_dev));\n}\n\nstatic void efx_ethtool_get_regs(struct net_device *net_dev,\n\t\t\t\t struct ethtool_regs *regs, void *buf)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tregs->version = efx->type->revision;\n\tefx_nic_get_regs(efx, buf);\n}\n\n \n\nstatic int efx_ethtool_get_coalesce(struct net_device *net_dev,\n\t\t\t\t    struct ethtool_coalesce *coalesce,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tunsigned int tx_usecs, rx_usecs;\n\tbool rx_adaptive;\n\n\tefx_get_irq_moderation(efx, &tx_usecs, &rx_usecs, &rx_adaptive);\n\n\tcoalesce->tx_coalesce_usecs = tx_usecs;\n\tcoalesce->tx_coalesce_usecs_irq = tx_usecs;\n\tcoalesce->rx_coalesce_usecs = rx_usecs;\n\tcoalesce->rx_coalesce_usecs_irq = rx_usecs;\n\tcoalesce->use_adaptive_rx_coalesce = rx_adaptive;\n\n\treturn 0;\n}\n\nstatic int efx_ethtool_set_coalesce(struct net_device *net_dev,\n\t\t\t\t    struct ethtool_coalesce *coalesce,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tstruct efx_channel *channel;\n\tunsigned int tx_usecs, rx_usecs;\n\tbool adaptive, rx_may_override_tx;\n\tint rc;\n\n\tefx_get_irq_moderation(efx, &tx_usecs, &rx_usecs, &adaptive);\n\n\tif (coalesce->rx_coalesce_usecs != rx_usecs)\n\t\trx_usecs = coalesce->rx_coalesce_usecs;\n\telse\n\t\trx_usecs = coalesce->rx_coalesce_usecs_irq;\n\n\tadaptive = coalesce->use_adaptive_rx_coalesce;\n\n\t \n\trx_may_override_tx = (coalesce->tx_coalesce_usecs == tx_usecs &&\n\t\t\t      coalesce->tx_coalesce_usecs_irq == tx_usecs);\n\tif (coalesce->tx_coalesce_usecs != tx_usecs)\n\t\ttx_usecs = coalesce->tx_coalesce_usecs;\n\telse\n\t\ttx_usecs = coalesce->tx_coalesce_usecs_irq;\n\n\trc = efx_init_irq_moderation(efx, tx_usecs, rx_usecs, adaptive,\n\t\t\t\t     rx_may_override_tx);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tefx_for_each_channel(channel, efx)\n\t\tefx->type->push_irq_moderation(channel);\n\n\treturn 0;\n}\n\nstatic void\nefx_ethtool_get_ringparam(struct net_device *net_dev,\n\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tring->rx_max_pending = EFX_MAX_DMAQ_SIZE;\n\tring->tx_max_pending = EFX_TXQ_MAX_ENT(efx);\n\tring->rx_pending = efx->rxq_entries;\n\tring->tx_pending = efx->txq_entries;\n}\n\nstatic int\nefx_ethtool_set_ringparam(struct net_device *net_dev,\n\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tu32 txq_entries;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n\t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n\t    ring->tx_pending > EFX_TXQ_MAX_ENT(efx))\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending < EFX_RXQ_MIN_ENT) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"RX queues cannot be smaller than %u\\n\",\n\t\t\t  EFX_RXQ_MIN_ENT);\n\t\treturn -EINVAL;\n\t}\n\n\ttxq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));\n\tif (txq_entries != ring->tx_pending)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"increasing TX queue size to minimum of %u\\n\",\n\t\t\t   txq_entries);\n\n\treturn efx_realloc_channels(efx, ring->rx_pending, txq_entries);\n}\n\nstatic void efx_ethtool_get_wol(struct net_device *net_dev,\n\t\t\t\tstruct ethtool_wolinfo *wol)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\treturn efx->type->get_wol(efx, wol);\n}\n\n\nstatic int efx_ethtool_set_wol(struct net_device *net_dev,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\treturn efx->type->set_wol(efx, wol->wolopts);\n}\n\nstatic void efx_ethtool_get_fec_stats(struct net_device *net_dev,\n\t\t\t\t      struct ethtool_fec_stats *fec_stats)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tif (efx->type->get_fec_stats)\n\t\tefx->type->get_fec_stats(efx, fec_stats);\n}\n\nstatic int efx_ethtool_get_ts_info(struct net_device *net_dev,\n\t\t\t\t   struct ethtool_ts_info *ts_info)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\t \n\tts_info->so_timestamping = (SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t    SOF_TIMESTAMPING_SOFTWARE);\n\tts_info->phc_index = -1;\n\n\tefx_ptp_get_ts_info(efx, ts_info);\n\treturn 0;\n}\n\nconst struct ethtool_ops efx_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USECS_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_drvinfo\t\t= efx_ethtool_get_drvinfo,\n\t.get_regs_len\t\t= efx_ethtool_get_regs_len,\n\t.get_regs\t\t= efx_ethtool_get_regs,\n\t.get_msglevel\t\t= efx_ethtool_get_msglevel,\n\t.set_msglevel\t\t= efx_ethtool_set_msglevel,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_coalesce\t\t= efx_ethtool_get_coalesce,\n\t.set_coalesce\t\t= efx_ethtool_set_coalesce,\n\t.get_ringparam\t\t= efx_ethtool_get_ringparam,\n\t.set_ringparam\t\t= efx_ethtool_set_ringparam,\n\t.get_pauseparam         = efx_ethtool_get_pauseparam,\n\t.set_pauseparam         = efx_ethtool_set_pauseparam,\n\t.get_sset_count\t\t= efx_ethtool_get_sset_count,\n\t.self_test\t\t= efx_ethtool_self_test,\n\t.get_strings\t\t= efx_ethtool_get_strings,\n\t.set_phys_id\t\t= efx_ethtool_phys_id,\n\t.get_ethtool_stats\t= efx_ethtool_get_stats,\n\t.get_wol                = efx_ethtool_get_wol,\n\t.set_wol                = efx_ethtool_set_wol,\n\t.reset\t\t\t= efx_ethtool_reset,\n\t.get_rxnfc\t\t= efx_ethtool_get_rxnfc,\n\t.set_rxnfc\t\t= efx_ethtool_set_rxnfc,\n\t.get_rxfh_indir_size\t= efx_ethtool_get_rxfh_indir_size,\n\t.get_rxfh_key_size\t= efx_ethtool_get_rxfh_key_size,\n\t.get_rxfh\t\t= efx_ethtool_get_rxfh,\n\t.set_rxfh\t\t= efx_ethtool_set_rxfh,\n\t.get_rxfh_context\t= efx_ethtool_get_rxfh_context,\n\t.set_rxfh_context\t= efx_ethtool_set_rxfh_context,\n\t.get_ts_info\t\t= efx_ethtool_get_ts_info,\n\t.get_module_info\t= efx_ethtool_get_module_info,\n\t.get_module_eeprom\t= efx_ethtool_get_module_eeprom,\n\t.get_link_ksettings\t= efx_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= efx_ethtool_set_link_ksettings,\n\t.get_fec_stats\t\t= efx_ethtool_get_fec_stats,\n\t.get_fecparam\t\t= efx_ethtool_get_fecparam,\n\t.set_fecparam\t\t= efx_ethtool_set_fecparam,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}