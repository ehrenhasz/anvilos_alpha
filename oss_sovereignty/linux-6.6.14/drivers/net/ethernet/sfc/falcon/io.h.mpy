{
  "module_name": "io.h",
  "hash_id": "7de4dde893a3739a3d5bd4f367eb38f4b1d75502b5c2b4d10bacacfc193463d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/io.h",
  "human_readable_source": " \n \n\n#ifndef EF4_IO_H\n#define EF4_IO_H\n\n#include <linux/io.h>\n#include <linux/spinlock.h>\n\n \n\n#if BITS_PER_LONG == 64\n#define EF4_USE_QWORD_IO 1\n#endif\n\n#ifdef EF4_USE_QWORD_IO\nstatic inline void _ef4_writeq(struct ef4_nic *efx, __le64 value,\n\t\t\t\t  unsigned int reg)\n{\n\t__raw_writeq((__force u64)value, efx->membase + reg);\n}\nstatic inline __le64 _ef4_readq(struct ef4_nic *efx, unsigned int reg)\n{\n\treturn (__force __le64)__raw_readq(efx->membase + reg);\n}\n#endif\n\nstatic inline void _ef4_writed(struct ef4_nic *efx, __le32 value,\n\t\t\t\t  unsigned int reg)\n{\n\t__raw_writel((__force u32)value, efx->membase + reg);\n}\nstatic inline __le32 _ef4_readd(struct ef4_nic *efx, unsigned int reg)\n{\n\treturn (__force __le32)__raw_readl(efx->membase + reg);\n}\n\n \nstatic inline void ef4_writeo(struct ef4_nic *efx, const ef4_oword_t *value,\n\t\t\t      unsigned int reg)\n{\n\tunsigned long flags __attribute__ ((unused));\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing register %x with \" EF4_OWORD_FMT \"\\n\", reg,\n\t\t   EF4_OWORD_VAL(*value));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n#ifdef EF4_USE_QWORD_IO\n\t_ef4_writeq(efx, value->u64[0], reg + 0);\n\t_ef4_writeq(efx, value->u64[1], reg + 8);\n#else\n\t_ef4_writed(efx, value->u32[0], reg + 0);\n\t_ef4_writed(efx, value->u32[1], reg + 4);\n\t_ef4_writed(efx, value->u32[2], reg + 8);\n\t_ef4_writed(efx, value->u32[3], reg + 12);\n#endif\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n}\n\n \nstatic inline void ef4_sram_writeq(struct ef4_nic *efx, void __iomem *membase,\n\t\t\t\t   const ef4_qword_t *value, unsigned int index)\n{\n\tunsigned int addr = index * sizeof(*value);\n\tunsigned long flags __attribute__ ((unused));\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing SRAM address %x with \" EF4_QWORD_FMT \"\\n\",\n\t\t   addr, EF4_QWORD_VAL(*value));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n#ifdef EF4_USE_QWORD_IO\n\t__raw_writeq((__force u64)value->u64[0], membase + addr);\n#else\n\t__raw_writel((__force u32)value->u32[0], membase + addr);\n\t__raw_writel((__force u32)value->u32[1], membase + addr + 4);\n#endif\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n}\n\n \nstatic inline void ef4_writed(struct ef4_nic *efx, const ef4_dword_t *value,\n\t\t\t      unsigned int reg)\n{\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing register %x with \"EF4_DWORD_FMT\"\\n\",\n\t\t   reg, EF4_DWORD_VAL(*value));\n\n\t \n\t_ef4_writed(efx, value->u32[0], reg);\n}\n\n \nstatic inline void ef4_reado(struct ef4_nic *efx, ef4_oword_t *value,\n\t\t\t     unsigned int reg)\n{\n\tunsigned long flags __attribute__ ((unused));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n\tvalue->u32[0] = _ef4_readd(efx, reg + 0);\n\tvalue->u32[1] = _ef4_readd(efx, reg + 4);\n\tvalue->u32[2] = _ef4_readd(efx, reg + 8);\n\tvalue->u32[3] = _ef4_readd(efx, reg + 12);\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"read from register %x, got \" EF4_OWORD_FMT \"\\n\", reg,\n\t\t   EF4_OWORD_VAL(*value));\n}\n\n \nstatic inline void ef4_sram_readq(struct ef4_nic *efx, void __iomem *membase,\n\t\t\t\t  ef4_qword_t *value, unsigned int index)\n{\n\tunsigned int addr = index * sizeof(*value);\n\tunsigned long flags __attribute__ ((unused));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n#ifdef EF4_USE_QWORD_IO\n\tvalue->u64[0] = (__force __le64)__raw_readq(membase + addr);\n#else\n\tvalue->u32[0] = (__force __le32)__raw_readl(membase + addr);\n\tvalue->u32[1] = (__force __le32)__raw_readl(membase + addr + 4);\n#endif\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"read from SRAM address %x, got \"EF4_QWORD_FMT\"\\n\",\n\t\t   addr, EF4_QWORD_VAL(*value));\n}\n\n \nstatic inline void ef4_readd(struct ef4_nic *efx, ef4_dword_t *value,\n\t\t\t\tunsigned int reg)\n{\n\tvalue->u32[0] = _ef4_readd(efx, reg);\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"read from register %x, got \"EF4_DWORD_FMT\"\\n\",\n\t\t   reg, EF4_DWORD_VAL(*value));\n}\n\n \nstatic inline void\nef4_writeo_table(struct ef4_nic *efx, const ef4_oword_t *value,\n\t\t unsigned int reg, unsigned int index)\n{\n\tef4_writeo(efx, value, reg + index * sizeof(ef4_oword_t));\n}\n\n \nstatic inline void ef4_reado_table(struct ef4_nic *efx, ef4_oword_t *value,\n\t\t\t\t     unsigned int reg, unsigned int index)\n{\n\tef4_reado(efx, value, reg + index * sizeof(ef4_oword_t));\n}\n\n \n#define EF4_VI_PAGE_SIZE 0x2000\n\n \n#define EF4_PAGED_REG(page, reg) \\\n\t((page) * EF4_VI_PAGE_SIZE + (reg))\n\n \nstatic inline void _ef4_writeo_page(struct ef4_nic *efx, ef4_oword_t *value,\n\t\t\t\t    unsigned int reg, unsigned int page)\n{\n\treg = EF4_PAGED_REG(page, reg);\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing register %x with \" EF4_OWORD_FMT \"\\n\", reg,\n\t\t   EF4_OWORD_VAL(*value));\n\n#ifdef EF4_USE_QWORD_IO\n\t_ef4_writeq(efx, value->u64[0], reg + 0);\n\t_ef4_writeq(efx, value->u64[1], reg + 8);\n#else\n\t_ef4_writed(efx, value->u32[0], reg + 0);\n\t_ef4_writed(efx, value->u32[1], reg + 4);\n\t_ef4_writed(efx, value->u32[2], reg + 8);\n\t_ef4_writed(efx, value->u32[3], reg + 12);\n#endif\n}\n#define ef4_writeo_page(efx, value, reg, page)\t\t\t\t\\\n\t_ef4_writeo_page(efx, value,\t\t\t\t\t\\\n\t\t\t reg +\t\t\t\t\t\t\\\n\t\t\t BUILD_BUG_ON_ZERO((reg) != 0x830 && (reg) != 0xa10), \\\n\t\t\t page)\n\n \nstatic inline void\n_ef4_writed_page(struct ef4_nic *efx, const ef4_dword_t *value,\n\t\t unsigned int reg, unsigned int page)\n{\n\tef4_writed(efx, value, EF4_PAGED_REG(page, reg));\n}\n#define ef4_writed_page(efx, value, reg, page)\t\t\t\t\\\n\t_ef4_writed_page(efx, value,\t\t\t\t\t\\\n\t\t\t reg +\t\t\t\t\t\t\\\n\t\t\t BUILD_BUG_ON_ZERO((reg) != 0x400 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x420 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x830 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x83c &&\t\t\\\n\t\t\t\t\t   (reg) != 0xa18 &&\t\t\\\n\t\t\t\t\t   (reg) != 0xa1c),\t\t\\\n\t\t\t page)\n\n \nstatic inline void _ef4_writed_page_locked(struct ef4_nic *efx,\n\t\t\t\t\t   const ef4_dword_t *value,\n\t\t\t\t\t   unsigned int reg,\n\t\t\t\t\t   unsigned int page)\n{\n\tunsigned long flags __attribute__ ((unused));\n\n\tif (page == 0) {\n\t\tspin_lock_irqsave(&efx->biu_lock, flags);\n\t\tef4_writed(efx, value, EF4_PAGED_REG(page, reg));\n\t\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n\t} else {\n\t\tef4_writed(efx, value, EF4_PAGED_REG(page, reg));\n\t}\n}\n#define ef4_writed_page_locked(efx, value, reg, page)\t\t\t\\\n\t_ef4_writed_page_locked(efx, value,\t\t\t\t\\\n\t\t\t\treg + BUILD_BUG_ON_ZERO((reg) != 0x420), \\\n\t\t\t\tpage)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}