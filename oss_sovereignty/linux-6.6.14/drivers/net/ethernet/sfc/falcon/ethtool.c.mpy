{
  "module_name": "ethtool.c",
  "hash_id": "3d38459b2d0291d3ddc94d5f21453c0f79dcdb22411a96557a4743581fcaceb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/rtnetlink.h>\n#include <linux/in.h>\n#include \"net_driver.h\"\n#include \"workarounds.h\"\n#include \"selftest.h\"\n#include \"efx.h\"\n#include \"filter.h\"\n#include \"nic.h\"\n\nstruct ef4_sw_stat_desc {\n\tconst char *name;\n\tenum {\n\t\tEF4_ETHTOOL_STAT_SOURCE_nic,\n\t\tEF4_ETHTOOL_STAT_SOURCE_channel,\n\t\tEF4_ETHTOOL_STAT_SOURCE_tx_queue\n\t} source;\n\tunsigned offset;\n\tu64(*get_stat) (void *field);  \n};\n\n \n#define EF4_ETHTOOL_STAT(stat_name, source_name, field, field_type, \\\n\t\t\t\tget_stat_function) {\t\t\t\\\n\t.name = #stat_name,\t\t\t\t\t\t\\\n\t.source = EF4_ETHTOOL_STAT_SOURCE_##source_name,\t\t\\\n\t.offset = ((((field_type *) 0) ==\t\t\t\t\\\n\t\t      &((struct ef4_##source_name *)0)->field) ?\t\\\n\t\t    offsetof(struct ef4_##source_name, field) :\t\t\\\n\t\t    offsetof(struct ef4_##source_name, field)),\t\t\\\n\t.get_stat = get_stat_function,\t\t\t\t\t\\\n}\n\nstatic u64 ef4_get_uint_stat(void *field)\n{\n\treturn *(unsigned int *)field;\n}\n\nstatic u64 ef4_get_atomic_stat(void *field)\n{\n\treturn atomic_read((atomic_t *) field);\n}\n\n#define EF4_ETHTOOL_ATOMIC_NIC_ERROR_STAT(field)\t\t\\\n\tEF4_ETHTOOL_STAT(field, nic, field,\t\t\t\\\n\t\t\t atomic_t, ef4_get_atomic_stat)\n\n#define EF4_ETHTOOL_UINT_CHANNEL_STAT(field)\t\t\t\\\n\tEF4_ETHTOOL_STAT(field, channel, n_##field,\t\t\\\n\t\t\t unsigned int, ef4_get_uint_stat)\n\n#define EF4_ETHTOOL_UINT_TXQ_STAT(field)\t\t\t\\\n\tEF4_ETHTOOL_STAT(tx_##field, tx_queue, field,\t\t\\\n\t\t\t unsigned int, ef4_get_uint_stat)\n\nstatic const struct ef4_sw_stat_desc ef4_sw_stat_desc[] = {\n\tEF4_ETHTOOL_UINT_TXQ_STAT(merge_events),\n\tEF4_ETHTOOL_UINT_TXQ_STAT(pushes),\n\tEF4_ETHTOOL_UINT_TXQ_STAT(cb_packets),\n\tEF4_ETHTOOL_ATOMIC_NIC_ERROR_STAT(rx_reset),\n\tEF4_ETHTOOL_UINT_CHANNEL_STAT(rx_tobe_disc),\n\tEF4_ETHTOOL_UINT_CHANNEL_STAT(rx_ip_hdr_chksum_err),\n\tEF4_ETHTOOL_UINT_CHANNEL_STAT(rx_tcp_udp_chksum_err),\n\tEF4_ETHTOOL_UINT_CHANNEL_STAT(rx_mcast_mismatch),\n\tEF4_ETHTOOL_UINT_CHANNEL_STAT(rx_frm_trunc),\n\tEF4_ETHTOOL_UINT_CHANNEL_STAT(rx_merge_events),\n\tEF4_ETHTOOL_UINT_CHANNEL_STAT(rx_merge_packets),\n};\n\n#define EF4_ETHTOOL_SW_STAT_COUNT ARRAY_SIZE(ef4_sw_stat_desc)\n\n#define EF4_ETHTOOL_EEPROM_MAGIC 0xEFAB\n\n \n\n \nstatic int ef4_ethtool_phys_id(struct net_device *net_dev,\n\t\t\t       enum ethtool_phys_id_state state)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tenum ef4_led_mode mode = EF4_LED_DEFAULT;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ON:\n\t\tmode = EF4_LED_ON;\n\t\tbreak;\n\tcase ETHTOOL_ID_OFF:\n\t\tmode = EF4_LED_OFF;\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tmode = EF4_LED_DEFAULT;\n\t\tbreak;\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 1;\t \n\t}\n\n\tefx->type->set_id_led(efx, mode);\n\treturn 0;\n}\n\n \nstatic int\nef4_ethtool_get_link_ksettings(struct net_device *net_dev,\n\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tstruct ef4_link_state *link_state = &efx->link_state;\n\n\tmutex_lock(&efx->mac_lock);\n\tefx->phy_op->get_link_ksettings(efx, cmd);\n\tmutex_unlock(&efx->mac_lock);\n\n\t \n\tethtool_link_ksettings_add_link_mode(cmd, supported, Pause);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, Asym_Pause);\n\n\tif (LOOPBACK_INTERNAL(efx)) {\n\t\tcmd->base.speed = link_state->speed;\n\t\tcmd->base.duplex = link_state->fd ? DUPLEX_FULL : DUPLEX_HALF;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nef4_ethtool_set_link_ksettings(struct net_device *net_dev,\n\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tint rc;\n\n\t \n\tif ((cmd->base.speed == SPEED_1000) &&\n\t    (cmd->base.duplex != DUPLEX_FULL)) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"rejecting unsupported 1000Mbps HD setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&efx->mac_lock);\n\trc = efx->phy_op->set_link_ksettings(efx, cmd);\n\tmutex_unlock(&efx->mac_lock);\n\treturn rc;\n}\n\nstatic void ef4_ethtool_get_drvinfo(struct net_device *net_dev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->version, EF4_DRIVER_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(efx->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int ef4_ethtool_get_regs_len(struct net_device *net_dev)\n{\n\treturn ef4_nic_get_regs_len(netdev_priv(net_dev));\n}\n\nstatic void ef4_ethtool_get_regs(struct net_device *net_dev,\n\t\t\t\t struct ethtool_regs *regs, void *buf)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tregs->version = efx->type->revision;\n\tef4_nic_get_regs(efx, buf);\n}\n\nstatic u32 ef4_ethtool_get_msglevel(struct net_device *net_dev)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\treturn efx->msg_enable;\n}\n\nstatic void ef4_ethtool_set_msglevel(struct net_device *net_dev, u32 msg_enable)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tefx->msg_enable = msg_enable;\n}\n\n \nstatic void ef4_fill_test(unsigned int test_index, u8 *strings, u64 *data,\n\t\t\t  int *test, const char *unit_format, int unit_id,\n\t\t\t  const char *test_format, const char *test_id)\n{\n\tchar unit_str[ETH_GSTRING_LEN], test_str[ETH_GSTRING_LEN];\n\n\t \n\tif (data)\n\t\tdata[test_index] = *test;\n\n\t \n\tif (strings) {\n\t\tif (strchr(unit_format, '%'))\n\t\t\tsnprintf(unit_str, sizeof(unit_str),\n\t\t\t\t unit_format, unit_id);\n\t\telse\n\t\t\tstrcpy(unit_str, unit_format);\n\t\tsnprintf(test_str, sizeof(test_str), test_format, test_id);\n\t\tsnprintf(strings + test_index * ETH_GSTRING_LEN,\n\t\t\t ETH_GSTRING_LEN,\n\t\t\t \"%-6s %-24s\", unit_str, test_str);\n\t}\n}\n\n#define EF4_CHANNEL_NAME(_channel) \"chan%d\", _channel->channel\n#define EF4_TX_QUEUE_NAME(_tx_queue) \"txq%d\", _tx_queue->queue\n#define EF4_RX_QUEUE_NAME(_rx_queue) \"rxq%d\", _rx_queue->queue\n#define EF4_LOOPBACK_NAME(_mode, _counter)\t\t\t\\\n\t\"loopback.%s.\" _counter, STRING_TABLE_LOOKUP(_mode, ef4_loopback_mode)\n\n \nstatic int ef4_fill_loopback_test(struct ef4_nic *efx,\n\t\t\t\t  struct ef4_loopback_self_tests *lb_tests,\n\t\t\t\t  enum ef4_loopback_mode mode,\n\t\t\t\t  unsigned int test_index,\n\t\t\t\t  u8 *strings, u64 *data)\n{\n\tstruct ef4_channel *channel =\n\t\tef4_get_channel(efx, efx->tx_channel_offset);\n\tstruct ef4_tx_queue *tx_queue;\n\n\tef4_for_each_channel_tx_queue(tx_queue, channel) {\n\t\tef4_fill_test(test_index++, strings, data,\n\t\t\t      &lb_tests->tx_sent[tx_queue->queue],\n\t\t\t      EF4_TX_QUEUE_NAME(tx_queue),\n\t\t\t      EF4_LOOPBACK_NAME(mode, \"tx_sent\"));\n\t\tef4_fill_test(test_index++, strings, data,\n\t\t\t      &lb_tests->tx_done[tx_queue->queue],\n\t\t\t      EF4_TX_QUEUE_NAME(tx_queue),\n\t\t\t      EF4_LOOPBACK_NAME(mode, \"tx_done\"));\n\t}\n\tef4_fill_test(test_index++, strings, data,\n\t\t      &lb_tests->rx_good,\n\t\t      \"rx\", 0,\n\t\t      EF4_LOOPBACK_NAME(mode, \"rx_good\"));\n\tef4_fill_test(test_index++, strings, data,\n\t\t      &lb_tests->rx_bad,\n\t\t      \"rx\", 0,\n\t\t      EF4_LOOPBACK_NAME(mode, \"rx_bad\"));\n\n\treturn test_index;\n}\n\n \nstatic int ef4_ethtool_fill_self_tests(struct ef4_nic *efx,\n\t\t\t\t       struct ef4_self_tests *tests,\n\t\t\t\t       u8 *strings, u64 *data)\n{\n\tstruct ef4_channel *channel;\n\tunsigned int n = 0, i;\n\tenum ef4_loopback_mode mode;\n\n\tef4_fill_test(n++, strings, data, &tests->phy_alive,\n\t\t      \"phy\", 0, \"alive\", NULL);\n\tef4_fill_test(n++, strings, data, &tests->nvram,\n\t\t      \"core\", 0, \"nvram\", NULL);\n\tef4_fill_test(n++, strings, data, &tests->interrupt,\n\t\t      \"core\", 0, \"interrupt\", NULL);\n\n\t \n\tef4_for_each_channel(channel, efx) {\n\t\tef4_fill_test(n++, strings, data,\n\t\t\t      &tests->eventq_dma[channel->channel],\n\t\t\t      EF4_CHANNEL_NAME(channel),\n\t\t\t      \"eventq.dma\", NULL);\n\t\tef4_fill_test(n++, strings, data,\n\t\t\t      &tests->eventq_int[channel->channel],\n\t\t\t      EF4_CHANNEL_NAME(channel),\n\t\t\t      \"eventq.int\", NULL);\n\t}\n\n\tef4_fill_test(n++, strings, data, &tests->memory,\n\t\t      \"core\", 0, \"memory\", NULL);\n\tef4_fill_test(n++, strings, data, &tests->registers,\n\t\t      \"core\", 0, \"registers\", NULL);\n\n\tif (efx->phy_op->run_tests != NULL) {\n\t\tEF4_BUG_ON_PARANOID(efx->phy_op->test_name == NULL);\n\n\t\tfor (i = 0; true; ++i) {\n\t\t\tconst char *name;\n\n\t\t\tEF4_BUG_ON_PARANOID(i >= EF4_MAX_PHY_TESTS);\n\t\t\tname = efx->phy_op->test_name(efx, i);\n\t\t\tif (name == NULL)\n\t\t\t\tbreak;\n\n\t\t\tef4_fill_test(n++, strings, data, &tests->phy_ext[i],\n\t\t\t\t      \"phy\", 0, name, NULL);\n\t\t}\n\t}\n\n\t \n\tfor (mode = LOOPBACK_NONE; mode <= LOOPBACK_TEST_MAX; mode++) {\n\t\tif (!(efx->loopback_modes & (1 << mode)))\n\t\t\tcontinue;\n\t\tn = ef4_fill_loopback_test(efx,\n\t\t\t\t\t   &tests->loopback[mode], mode, n,\n\t\t\t\t\t   strings, data);\n\t}\n\n\treturn n;\n}\n\nstatic size_t ef4_describe_per_queue_stats(struct ef4_nic *efx, u8 *strings)\n{\n\tsize_t n_stats = 0;\n\tstruct ef4_channel *channel;\n\n\tef4_for_each_channel(channel, efx) {\n\t\tif (ef4_channel_has_tx_queues(channel)) {\n\t\t\tn_stats++;\n\t\t\tif (strings != NULL) {\n\t\t\t\tsnprintf(strings, ETH_GSTRING_LEN,\n\t\t\t\t\t \"tx-%u.tx_packets\",\n\t\t\t\t\t channel->tx_queue[0].queue /\n\t\t\t\t\t EF4_TXQ_TYPES);\n\n\t\t\t\tstrings += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t}\n\tef4_for_each_channel(channel, efx) {\n\t\tif (ef4_channel_has_rx_queue(channel)) {\n\t\t\tn_stats++;\n\t\t\tif (strings != NULL) {\n\t\t\t\tsnprintf(strings, ETH_GSTRING_LEN,\n\t\t\t\t\t \"rx-%d.rx_packets\", channel->channel);\n\t\t\t\tstrings += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t}\n\treturn n_stats;\n}\n\nstatic int ef4_ethtool_get_sset_count(struct net_device *net_dev,\n\t\t\t\t      int string_set)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\treturn efx->type->describe_stats(efx, NULL) +\n\t\t       EF4_ETHTOOL_SW_STAT_COUNT +\n\t\t       ef4_describe_per_queue_stats(efx, NULL);\n\tcase ETH_SS_TEST:\n\t\treturn ef4_ethtool_fill_self_tests(efx, NULL, NULL, NULL);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void ef4_ethtool_get_strings(struct net_device *net_dev,\n\t\t\t\t    u32 string_set, u8 *strings)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tint i;\n\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\tstrings += (efx->type->describe_stats(efx, strings) *\n\t\t\t    ETH_GSTRING_LEN);\n\t\tfor (i = 0; i < EF4_ETHTOOL_SW_STAT_COUNT; i++)\n\t\t\tstrscpy(strings + i * ETH_GSTRING_LEN,\n\t\t\t\tef4_sw_stat_desc[i].name, ETH_GSTRING_LEN);\n\t\tstrings += EF4_ETHTOOL_SW_STAT_COUNT * ETH_GSTRING_LEN;\n\t\tstrings += (ef4_describe_per_queue_stats(efx, strings) *\n\t\t\t    ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tef4_ethtool_fill_self_tests(efx, NULL, strings, NULL);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void ef4_ethtool_get_stats(struct net_device *net_dev,\n\t\t\t\t  struct ethtool_stats *stats,\n\t\t\t\t  u64 *data)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tconst struct ef4_sw_stat_desc *stat;\n\tstruct ef4_channel *channel;\n\tstruct ef4_tx_queue *tx_queue;\n\tstruct ef4_rx_queue *rx_queue;\n\tint i;\n\n\tspin_lock_bh(&efx->stats_lock);\n\n\t \n\tdata += efx->type->update_stats(efx, data, NULL);\n\n\t \n\tfor (i = 0; i < EF4_ETHTOOL_SW_STAT_COUNT; i++) {\n\t\tstat = &ef4_sw_stat_desc[i];\n\t\tswitch (stat->source) {\n\t\tcase EF4_ETHTOOL_STAT_SOURCE_nic:\n\t\t\tdata[i] = stat->get_stat((void *)efx + stat->offset);\n\t\t\tbreak;\n\t\tcase EF4_ETHTOOL_STAT_SOURCE_channel:\n\t\t\tdata[i] = 0;\n\t\t\tef4_for_each_channel(channel, efx)\n\t\t\t\tdata[i] += stat->get_stat((void *)channel +\n\t\t\t\t\t\t\t  stat->offset);\n\t\t\tbreak;\n\t\tcase EF4_ETHTOOL_STAT_SOURCE_tx_queue:\n\t\t\tdata[i] = 0;\n\t\t\tef4_for_each_channel(channel, efx) {\n\t\t\t\tef4_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\t\t\tdata[i] +=\n\t\t\t\t\t\tstat->get_stat((void *)tx_queue\n\t\t\t\t\t\t\t       + stat->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tdata += EF4_ETHTOOL_SW_STAT_COUNT;\n\n\tspin_unlock_bh(&efx->stats_lock);\n\n\tef4_for_each_channel(channel, efx) {\n\t\tif (ef4_channel_has_tx_queues(channel)) {\n\t\t\t*data = 0;\n\t\t\tef4_for_each_channel_tx_queue(tx_queue, channel) {\n\t\t\t\t*data += tx_queue->tx_packets;\n\t\t\t}\n\t\t\tdata++;\n\t\t}\n\t}\n\tef4_for_each_channel(channel, efx) {\n\t\tif (ef4_channel_has_rx_queue(channel)) {\n\t\t\t*data = 0;\n\t\t\tef4_for_each_channel_rx_queue(rx_queue, channel) {\n\t\t\t\t*data += rx_queue->rx_packets;\n\t\t\t}\n\t\t\tdata++;\n\t\t}\n\t}\n}\n\nstatic void ef4_ethtool_self_test(struct net_device *net_dev,\n\t\t\t\t  struct ethtool_test *test, u64 *data)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tstruct ef4_self_tests *ef4_tests;\n\tbool already_up;\n\tint rc = -ENOMEM;\n\n\tef4_tests = kzalloc(sizeof(*ef4_tests), GFP_KERNEL);\n\tif (!ef4_tests)\n\t\tgoto fail;\n\n\tif (efx->state != STATE_READY) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tnetif_info(efx, drv, efx->net_dev, \"starting %sline testing\\n\",\n\t\t   (test->flags & ETH_TEST_FL_OFFLINE) ? \"off\" : \"on\");\n\n\t \n\talready_up = (efx->net_dev->flags & IFF_UP);\n\tif (!already_up) {\n\t\trc = dev_open(efx->net_dev, NULL);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"failed opening device.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ef4_selftest(efx, ef4_tests, test->flags);\n\n\tif (!already_up)\n\t\tdev_close(efx->net_dev);\n\n\tnetif_info(efx, drv, efx->net_dev, \"%s %sline self-tests\\n\",\n\t\t   rc == 0 ? \"passed\" : \"failed\",\n\t\t   (test->flags & ETH_TEST_FL_OFFLINE) ? \"off\" : \"on\");\n\nout:\n\tef4_ethtool_fill_self_tests(efx, ef4_tests, NULL, data);\n\tkfree(ef4_tests);\nfail:\n\tif (rc)\n\t\ttest->flags |= ETH_TEST_FL_FAILED;\n}\n\n \nstatic int ef4_ethtool_nway_reset(struct net_device *net_dev)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\treturn mdio45_nway_restart(&efx->mdio);\n}\n\n \n\nstatic int ef4_ethtool_get_coalesce(struct net_device *net_dev,\n\t\t\t\t    struct ethtool_coalesce *coalesce,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tunsigned int tx_usecs, rx_usecs;\n\tbool rx_adaptive;\n\n\tef4_get_irq_moderation(efx, &tx_usecs, &rx_usecs, &rx_adaptive);\n\n\tcoalesce->tx_coalesce_usecs = tx_usecs;\n\tcoalesce->tx_coalesce_usecs_irq = tx_usecs;\n\tcoalesce->rx_coalesce_usecs = rx_usecs;\n\tcoalesce->rx_coalesce_usecs_irq = rx_usecs;\n\tcoalesce->use_adaptive_rx_coalesce = rx_adaptive;\n\n\treturn 0;\n}\n\nstatic int ef4_ethtool_set_coalesce(struct net_device *net_dev,\n\t\t\t\t    struct ethtool_coalesce *coalesce,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tstruct ef4_channel *channel;\n\tunsigned int tx_usecs, rx_usecs;\n\tbool adaptive, rx_may_override_tx;\n\tint rc;\n\n\tef4_get_irq_moderation(efx, &tx_usecs, &rx_usecs, &adaptive);\n\n\tif (coalesce->rx_coalesce_usecs != rx_usecs)\n\t\trx_usecs = coalesce->rx_coalesce_usecs;\n\telse\n\t\trx_usecs = coalesce->rx_coalesce_usecs_irq;\n\n\tadaptive = coalesce->use_adaptive_rx_coalesce;\n\n\t \n\trx_may_override_tx = (coalesce->tx_coalesce_usecs == tx_usecs &&\n\t\t\t      coalesce->tx_coalesce_usecs_irq == tx_usecs);\n\tif (coalesce->tx_coalesce_usecs != tx_usecs)\n\t\ttx_usecs = coalesce->tx_coalesce_usecs;\n\telse\n\t\ttx_usecs = coalesce->tx_coalesce_usecs_irq;\n\n\trc = ef4_init_irq_moderation(efx, tx_usecs, rx_usecs, adaptive,\n\t\t\t\t     rx_may_override_tx);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tef4_for_each_channel(channel, efx)\n\t\tefx->type->push_irq_moderation(channel);\n\n\treturn 0;\n}\n\nstatic void\nef4_ethtool_get_ringparam(struct net_device *net_dev,\n\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tring->rx_max_pending = EF4_MAX_DMAQ_SIZE;\n\tring->tx_max_pending = EF4_MAX_DMAQ_SIZE;\n\tring->rx_pending = efx->rxq_entries;\n\tring->tx_pending = efx->txq_entries;\n}\n\nstatic int\nef4_ethtool_set_ringparam(struct net_device *net_dev,\n\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tu32 txq_entries;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n\t    ring->rx_pending > EF4_MAX_DMAQ_SIZE ||\n\t    ring->tx_pending > EF4_MAX_DMAQ_SIZE)\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending < EF4_RXQ_MIN_ENT) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"RX queues cannot be smaller than %u\\n\",\n\t\t\t  EF4_RXQ_MIN_ENT);\n\t\treturn -EINVAL;\n\t}\n\n\ttxq_entries = max(ring->tx_pending, EF4_TXQ_MIN_ENT(efx));\n\tif (txq_entries != ring->tx_pending)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"increasing TX queue size to minimum of %u\\n\",\n\t\t\t   txq_entries);\n\n\treturn ef4_realloc_channels(efx, ring->rx_pending, txq_entries);\n}\n\nstatic int ef4_ethtool_set_pauseparam(struct net_device *net_dev,\n\t\t\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tu8 wanted_fc, old_fc;\n\tu32 old_adv;\n\tint rc = 0;\n\n\tmutex_lock(&efx->mac_lock);\n\n\twanted_fc = ((pause->rx_pause ? EF4_FC_RX : 0) |\n\t\t     (pause->tx_pause ? EF4_FC_TX : 0) |\n\t\t     (pause->autoneg ? EF4_FC_AUTO : 0));\n\n\tif ((wanted_fc & EF4_FC_TX) && !(wanted_fc & EF4_FC_RX)) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Flow control unsupported: tx ON rx OFF\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((wanted_fc & EF4_FC_AUTO) && !efx->link_advertising) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Autonegotiation is disabled\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (efx->type->prepare_enable_fc_tx &&\n\t    (wanted_fc & EF4_FC_TX) && !(efx->wanted_fc & EF4_FC_TX))\n\t\tefx->type->prepare_enable_fc_tx(efx);\n\n\told_adv = efx->link_advertising;\n\told_fc = efx->wanted_fc;\n\tef4_link_set_wanted_fc(efx, wanted_fc);\n\tif (efx->link_advertising != old_adv ||\n\t    (efx->wanted_fc ^ old_fc) & EF4_FC_AUTO) {\n\t\trc = efx->phy_op->reconfigure(efx);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"Unable to advertise requested flow \"\n\t\t\t\t  \"control setting\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tef4_mac_reconfigure(efx);\n\nout:\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn rc;\n}\n\nstatic void ef4_ethtool_get_pauseparam(struct net_device *net_dev,\n\t\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tpause->rx_pause = !!(efx->wanted_fc & EF4_FC_RX);\n\tpause->tx_pause = !!(efx->wanted_fc & EF4_FC_TX);\n\tpause->autoneg = !!(efx->wanted_fc & EF4_FC_AUTO);\n}\n\nstatic void ef4_ethtool_get_wol(struct net_device *net_dev,\n\t\t\t\tstruct ethtool_wolinfo *wol)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\treturn efx->type->get_wol(efx, wol);\n}\n\n\nstatic int ef4_ethtool_set_wol(struct net_device *net_dev,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\treturn efx->type->set_wol(efx, wol->wolopts);\n}\n\nstatic int ef4_ethtool_reset(struct net_device *net_dev, u32 *flags)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tint rc;\n\n\trc = efx->type->map_reset_flags(flags);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn ef4_reset(efx, rc);\n}\n\n \nstatic const u8 mac_addr_ig_mask[ETH_ALEN] __aligned(2) = {0x01, 0, 0, 0, 0, 0};\n\n#define IP4_ADDR_FULL_MASK\t((__force __be32)~0)\n#define IP_PROTO_FULL_MASK\t0xFF\n#define PORT_FULL_MASK\t\t((__force __be16)~0)\n#define ETHER_TYPE_FULL_MASK\t((__force __be16)~0)\n\nstatic inline void ip6_fill_mask(__be32 *mask)\n{\n\tmask[0] = mask[1] = mask[2] = mask[3] = ~(__be32)0;\n}\n\nstatic int ef4_ethtool_get_class_rule(struct ef4_nic *efx,\n\t\t\t\t      struct ethtool_rx_flow_spec *rule)\n{\n\tstruct ethtool_tcpip4_spec *ip_entry = &rule->h_u.tcp_ip4_spec;\n\tstruct ethtool_tcpip4_spec *ip_mask = &rule->m_u.tcp_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_entry = &rule->h_u.usr_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_mask = &rule->m_u.usr_ip4_spec;\n\tstruct ethtool_tcpip6_spec *ip6_entry = &rule->h_u.tcp_ip6_spec;\n\tstruct ethtool_tcpip6_spec *ip6_mask = &rule->m_u.tcp_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_entry = &rule->h_u.usr_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_mask = &rule->m_u.usr_ip6_spec;\n\tstruct ethhdr *mac_entry = &rule->h_u.ether_spec;\n\tstruct ethhdr *mac_mask = &rule->m_u.ether_spec;\n\tstruct ef4_filter_spec spec;\n\tint rc;\n\n\trc = ef4_filter_get_filter_safe(efx, EF4_FILTER_PRI_MANUAL,\n\t\t\t\t\trule->location, &spec);\n\tif (rc)\n\t\treturn rc;\n\n\tif (spec.dmaq_id == EF4_FILTER_RX_DMAQ_ID_DROP)\n\t\trule->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\trule->ring_cookie = spec.dmaq_id;\n\n\tif ((spec.match_flags & EF4_FILTER_MATCH_ETHER_TYPE) &&\n\t    spec.ether_type == htons(ETH_P_IP) &&\n\t    (spec.match_flags & EF4_FILTER_MATCH_IP_PROTO) &&\n\t    (spec.ip_proto == IPPROTO_TCP || spec.ip_proto == IPPROTO_UDP) &&\n\t    !(spec.match_flags &\n\t      ~(EF4_FILTER_MATCH_ETHER_TYPE | EF4_FILTER_MATCH_OUTER_VID |\n\t\tEF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_REM_HOST |\n\t\tEF4_FILTER_MATCH_IP_PROTO |\n\t\tEF4_FILTER_MATCH_LOC_PORT | EF4_FILTER_MATCH_REM_PORT))) {\n\t\trule->flow_type = ((spec.ip_proto == IPPROTO_TCP) ?\n\t\t\t\t   TCP_V4_FLOW : UDP_V4_FLOW);\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_LOC_HOST) {\n\t\t\tip_entry->ip4dst = spec.loc_host[0];\n\t\t\tip_mask->ip4dst = IP4_ADDR_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_REM_HOST) {\n\t\t\tip_entry->ip4src = spec.rem_host[0];\n\t\t\tip_mask->ip4src = IP4_ADDR_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_LOC_PORT) {\n\t\t\tip_entry->pdst = spec.loc_port;\n\t\t\tip_mask->pdst = PORT_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_REM_PORT) {\n\t\t\tip_entry->psrc = spec.rem_port;\n\t\t\tip_mask->psrc = PORT_FULL_MASK;\n\t\t}\n\t} else if ((spec.match_flags & EF4_FILTER_MATCH_ETHER_TYPE) &&\n\t    spec.ether_type == htons(ETH_P_IPV6) &&\n\t    (spec.match_flags & EF4_FILTER_MATCH_IP_PROTO) &&\n\t    (spec.ip_proto == IPPROTO_TCP || spec.ip_proto == IPPROTO_UDP) &&\n\t    !(spec.match_flags &\n\t      ~(EF4_FILTER_MATCH_ETHER_TYPE | EF4_FILTER_MATCH_OUTER_VID |\n\t\tEF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_REM_HOST |\n\t\tEF4_FILTER_MATCH_IP_PROTO |\n\t\tEF4_FILTER_MATCH_LOC_PORT | EF4_FILTER_MATCH_REM_PORT))) {\n\t\trule->flow_type = ((spec.ip_proto == IPPROTO_TCP) ?\n\t\t\t\t   TCP_V6_FLOW : UDP_V6_FLOW);\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_LOC_HOST) {\n\t\t\tmemcpy(ip6_entry->ip6dst, spec.loc_host,\n\t\t\t       sizeof(ip6_entry->ip6dst));\n\t\t\tip6_fill_mask(ip6_mask->ip6dst);\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_REM_HOST) {\n\t\t\tmemcpy(ip6_entry->ip6src, spec.rem_host,\n\t\t\t       sizeof(ip6_entry->ip6src));\n\t\t\tip6_fill_mask(ip6_mask->ip6src);\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_LOC_PORT) {\n\t\t\tip6_entry->pdst = spec.loc_port;\n\t\t\tip6_mask->pdst = PORT_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_REM_PORT) {\n\t\t\tip6_entry->psrc = spec.rem_port;\n\t\t\tip6_mask->psrc = PORT_FULL_MASK;\n\t\t}\n\t} else if (!(spec.match_flags &\n\t\t     ~(EF4_FILTER_MATCH_LOC_MAC | EF4_FILTER_MATCH_LOC_MAC_IG |\n\t\t       EF4_FILTER_MATCH_REM_MAC | EF4_FILTER_MATCH_ETHER_TYPE |\n\t\t       EF4_FILTER_MATCH_OUTER_VID))) {\n\t\trule->flow_type = ETHER_FLOW;\n\t\tif (spec.match_flags &\n\t\t    (EF4_FILTER_MATCH_LOC_MAC | EF4_FILTER_MATCH_LOC_MAC_IG)) {\n\t\t\tether_addr_copy(mac_entry->h_dest, spec.loc_mac);\n\t\t\tif (spec.match_flags & EF4_FILTER_MATCH_LOC_MAC)\n\t\t\t\teth_broadcast_addr(mac_mask->h_dest);\n\t\t\telse\n\t\t\t\tether_addr_copy(mac_mask->h_dest,\n\t\t\t\t\t\tmac_addr_ig_mask);\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_REM_MAC) {\n\t\t\tether_addr_copy(mac_entry->h_source, spec.rem_mac);\n\t\t\teth_broadcast_addr(mac_mask->h_source);\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_ETHER_TYPE) {\n\t\t\tmac_entry->h_proto = spec.ether_type;\n\t\t\tmac_mask->h_proto = ETHER_TYPE_FULL_MASK;\n\t\t}\n\t} else if (spec.match_flags & EF4_FILTER_MATCH_ETHER_TYPE &&\n\t\t   spec.ether_type == htons(ETH_P_IP) &&\n\t\t   !(spec.match_flags &\n\t\t     ~(EF4_FILTER_MATCH_ETHER_TYPE | EF4_FILTER_MATCH_OUTER_VID |\n\t\t       EF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_REM_HOST |\n\t\t       EF4_FILTER_MATCH_IP_PROTO))) {\n\t\trule->flow_type = IPV4_USER_FLOW;\n\t\tuip_entry->ip_ver = ETH_RX_NFC_IP4;\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_IP_PROTO) {\n\t\t\tuip_mask->proto = IP_PROTO_FULL_MASK;\n\t\t\tuip_entry->proto = spec.ip_proto;\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_LOC_HOST) {\n\t\t\tuip_entry->ip4dst = spec.loc_host[0];\n\t\t\tuip_mask->ip4dst = IP4_ADDR_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_REM_HOST) {\n\t\t\tuip_entry->ip4src = spec.rem_host[0];\n\t\t\tuip_mask->ip4src = IP4_ADDR_FULL_MASK;\n\t\t}\n\t} else if (spec.match_flags & EF4_FILTER_MATCH_ETHER_TYPE &&\n\t\t   spec.ether_type == htons(ETH_P_IPV6) &&\n\t\t   !(spec.match_flags &\n\t\t     ~(EF4_FILTER_MATCH_ETHER_TYPE | EF4_FILTER_MATCH_OUTER_VID |\n\t\t       EF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_REM_HOST |\n\t\t       EF4_FILTER_MATCH_IP_PROTO))) {\n\t\trule->flow_type = IPV6_USER_FLOW;\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_IP_PROTO) {\n\t\t\tuip6_mask->l4_proto = IP_PROTO_FULL_MASK;\n\t\t\tuip6_entry->l4_proto = spec.ip_proto;\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_LOC_HOST) {\n\t\t\tmemcpy(uip6_entry->ip6dst, spec.loc_host,\n\t\t\t       sizeof(uip6_entry->ip6dst));\n\t\t\tip6_fill_mask(uip6_mask->ip6dst);\n\t\t}\n\t\tif (spec.match_flags & EF4_FILTER_MATCH_REM_HOST) {\n\t\t\tmemcpy(uip6_entry->ip6src, spec.rem_host,\n\t\t\t       sizeof(uip6_entry->ip6src));\n\t\t\tip6_fill_mask(uip6_mask->ip6src);\n\t\t}\n\t} else {\n\t\t \n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (spec.match_flags & EF4_FILTER_MATCH_OUTER_VID) {\n\t\trule->flow_type |= FLOW_EXT;\n\t\trule->h_ext.vlan_tci = spec.outer_vid;\n\t\trule->m_ext.vlan_tci = htons(0xfff);\n\t}\n\n\treturn rc;\n}\n\nstatic int\nef4_ethtool_get_rxnfc(struct net_device *net_dev,\n\t\t      struct ethtool_rxnfc *info, u32 *rule_locs)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = efx->n_rx_channels;\n\t\treturn 0;\n\n\tcase ETHTOOL_GRXFH: {\n\t\tunsigned min_revision = 0;\n\n\t\tinfo->data = 0;\n\t\tswitch (info->flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\tfallthrough;\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\tcase AH_ESP_V4_FLOW:\n\t\tcase IPV4_FLOW:\n\t\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\t\tmin_revision = EF4_REV_FALCON_B0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (ef4_nic_rev(efx) < min_revision)\n\t\t\tinfo->data = 0;\n\t\treturn 0;\n\t}\n\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tinfo->data = ef4_filter_get_rx_id_limit(efx);\n\t\tif (info->data == 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tinfo->data |= RX_CLS_LOC_SPECIAL;\n\t\tinfo->rule_cnt =\n\t\t\tef4_filter_count_rx_used(efx, EF4_FILTER_PRI_MANUAL);\n\t\treturn 0;\n\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tif (ef4_filter_get_rx_id_limit(efx) == 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn ef4_ethtool_get_class_rule(efx, &info->fs);\n\n\tcase ETHTOOL_GRXCLSRLALL: {\n\t\ts32 rc;\n\t\tinfo->data = ef4_filter_get_rx_id_limit(efx);\n\t\tif (info->data == 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\trc = ef4_filter_get_rx_ids(efx, EF4_FILTER_PRI_MANUAL,\n\t\t\t\t\t   rule_locs, info->rule_cnt);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tinfo->rule_cnt = rc;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic inline bool ip6_mask_is_full(__be32 mask[4])\n{\n\treturn !~(mask[0] & mask[1] & mask[2] & mask[3]);\n}\n\nstatic inline bool ip6_mask_is_empty(__be32 mask[4])\n{\n\treturn !(mask[0] | mask[1] | mask[2] | mask[3]);\n}\n\nstatic int ef4_ethtool_set_class_rule(struct ef4_nic *efx,\n\t\t\t\t      struct ethtool_rx_flow_spec *rule)\n{\n\tstruct ethtool_tcpip4_spec *ip_entry = &rule->h_u.tcp_ip4_spec;\n\tstruct ethtool_tcpip4_spec *ip_mask = &rule->m_u.tcp_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_entry = &rule->h_u.usr_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_mask = &rule->m_u.usr_ip4_spec;\n\tstruct ethtool_tcpip6_spec *ip6_entry = &rule->h_u.tcp_ip6_spec;\n\tstruct ethtool_tcpip6_spec *ip6_mask = &rule->m_u.tcp_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_entry = &rule->h_u.usr_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_mask = &rule->m_u.usr_ip6_spec;\n\tstruct ethhdr *mac_entry = &rule->h_u.ether_spec;\n\tstruct ethhdr *mac_mask = &rule->m_u.ether_spec;\n\tstruct ef4_filter_spec spec;\n\tint rc;\n\n\t \n\tif (rule->location != RX_CLS_LOC_ANY)\n\t\treturn -EINVAL;\n\n\t \n\tif (rule->ring_cookie >= efx->n_rx_channels &&\n\t    rule->ring_cookie != RX_CLS_FLOW_DISC)\n\t\treturn -EINVAL;\n\n\t \n\tif ((rule->flow_type & FLOW_EXT) &&\n\t    (rule->m_ext.vlan_etype || rule->m_ext.data[0] ||\n\t     rule->m_ext.data[1]))\n\t\treturn -EINVAL;\n\n\tef4_filter_init_rx(&spec, EF4_FILTER_PRI_MANUAL,\n\t\t\t   efx->rx_scatter ? EF4_FILTER_FLAG_RX_SCATTER : 0,\n\t\t\t   (rule->ring_cookie == RX_CLS_FLOW_DISC) ?\n\t\t\t   EF4_FILTER_RX_DMAQ_ID_DROP : rule->ring_cookie);\n\n\tswitch (rule->flow_type & ~FLOW_EXT) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\tspec.match_flags = (EF4_FILTER_MATCH_ETHER_TYPE |\n\t\t\t\t    EF4_FILTER_MATCH_IP_PROTO);\n\t\tspec.ether_type = htons(ETH_P_IP);\n\t\tspec.ip_proto = ((rule->flow_type & ~FLOW_EXT) == TCP_V4_FLOW ?\n\t\t\t\t IPPROTO_TCP : IPPROTO_UDP);\n\t\tif (ip_mask->ip4dst) {\n\t\t\tif (ip_mask->ip4dst != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_HOST;\n\t\t\tspec.loc_host[0] = ip_entry->ip4dst;\n\t\t}\n\t\tif (ip_mask->ip4src) {\n\t\t\tif (ip_mask->ip4src != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_REM_HOST;\n\t\t\tspec.rem_host[0] = ip_entry->ip4src;\n\t\t}\n\t\tif (ip_mask->pdst) {\n\t\t\tif (ip_mask->pdst != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_PORT;\n\t\t\tspec.loc_port = ip_entry->pdst;\n\t\t}\n\t\tif (ip_mask->psrc) {\n\t\t\tif (ip_mask->psrc != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_REM_PORT;\n\t\t\tspec.rem_port = ip_entry->psrc;\n\t\t}\n\t\tif (ip_mask->tos)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tspec.match_flags = (EF4_FILTER_MATCH_ETHER_TYPE |\n\t\t\t\t    EF4_FILTER_MATCH_IP_PROTO);\n\t\tspec.ether_type = htons(ETH_P_IPV6);\n\t\tspec.ip_proto = ((rule->flow_type & ~FLOW_EXT) == TCP_V6_FLOW ?\n\t\t\t\t IPPROTO_TCP : IPPROTO_UDP);\n\t\tif (!ip6_mask_is_empty(ip6_mask->ip6dst)) {\n\t\t\tif (!ip6_mask_is_full(ip6_mask->ip6dst))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_HOST;\n\t\t\tmemcpy(spec.loc_host, ip6_entry->ip6dst, sizeof(spec.loc_host));\n\t\t}\n\t\tif (!ip6_mask_is_empty(ip6_mask->ip6src)) {\n\t\t\tif (!ip6_mask_is_full(ip6_mask->ip6src))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_REM_HOST;\n\t\t\tmemcpy(spec.rem_host, ip6_entry->ip6src, sizeof(spec.rem_host));\n\t\t}\n\t\tif (ip6_mask->pdst) {\n\t\t\tif (ip6_mask->pdst != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_PORT;\n\t\t\tspec.loc_port = ip6_entry->pdst;\n\t\t}\n\t\tif (ip6_mask->psrc) {\n\t\t\tif (ip6_mask->psrc != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_REM_PORT;\n\t\t\tspec.rem_port = ip6_entry->psrc;\n\t\t}\n\t\tif (ip6_mask->tclass)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase IPV4_USER_FLOW:\n\t\tif (uip_mask->l4_4_bytes || uip_mask->tos || uip_mask->ip_ver ||\n\t\t    uip_entry->ip_ver != ETH_RX_NFC_IP4)\n\t\t\treturn -EINVAL;\n\t\tspec.match_flags = EF4_FILTER_MATCH_ETHER_TYPE;\n\t\tspec.ether_type = htons(ETH_P_IP);\n\t\tif (uip_mask->ip4dst) {\n\t\t\tif (uip_mask->ip4dst != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_HOST;\n\t\t\tspec.loc_host[0] = uip_entry->ip4dst;\n\t\t}\n\t\tif (uip_mask->ip4src) {\n\t\t\tif (uip_mask->ip4src != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_REM_HOST;\n\t\t\tspec.rem_host[0] = uip_entry->ip4src;\n\t\t}\n\t\tif (uip_mask->proto) {\n\t\t\tif (uip_mask->proto != IP_PROTO_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_IP_PROTO;\n\t\t\tspec.ip_proto = uip_entry->proto;\n\t\t}\n\t\tbreak;\n\n\tcase IPV6_USER_FLOW:\n\t\tif (uip6_mask->l4_4_bytes || uip6_mask->tclass)\n\t\t\treturn -EINVAL;\n\t\tspec.match_flags = EF4_FILTER_MATCH_ETHER_TYPE;\n\t\tspec.ether_type = htons(ETH_P_IPV6);\n\t\tif (!ip6_mask_is_empty(uip6_mask->ip6dst)) {\n\t\t\tif (!ip6_mask_is_full(uip6_mask->ip6dst))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_HOST;\n\t\t\tmemcpy(spec.loc_host, uip6_entry->ip6dst, sizeof(spec.loc_host));\n\t\t}\n\t\tif (!ip6_mask_is_empty(uip6_mask->ip6src)) {\n\t\t\tif (!ip6_mask_is_full(uip6_mask->ip6src))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_REM_HOST;\n\t\t\tmemcpy(spec.rem_host, uip6_entry->ip6src, sizeof(spec.rem_host));\n\t\t}\n\t\tif (uip6_mask->l4_proto) {\n\t\t\tif (uip6_mask->l4_proto != IP_PROTO_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_IP_PROTO;\n\t\t\tspec.ip_proto = uip6_entry->l4_proto;\n\t\t}\n\t\tbreak;\n\n\tcase ETHER_FLOW:\n\t\tif (!is_zero_ether_addr(mac_mask->h_dest)) {\n\t\t\tif (ether_addr_equal(mac_mask->h_dest,\n\t\t\t\t\t     mac_addr_ig_mask))\n\t\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_MAC_IG;\n\t\t\telse if (is_broadcast_ether_addr(mac_mask->h_dest))\n\t\t\t\tspec.match_flags |= EF4_FILTER_MATCH_LOC_MAC;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tether_addr_copy(spec.loc_mac, mac_entry->h_dest);\n\t\t}\n\t\tif (!is_zero_ether_addr(mac_mask->h_source)) {\n\t\t\tif (!is_broadcast_ether_addr(mac_mask->h_source))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_REM_MAC;\n\t\t\tether_addr_copy(spec.rem_mac, mac_entry->h_source);\n\t\t}\n\t\tif (mac_mask->h_proto) {\n\t\t\tif (mac_mask->h_proto != ETHER_TYPE_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EF4_FILTER_MATCH_ETHER_TYPE;\n\t\t\tspec.ether_type = mac_entry->h_proto;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((rule->flow_type & FLOW_EXT) && rule->m_ext.vlan_tci) {\n\t\tif (rule->m_ext.vlan_tci != htons(0xfff))\n\t\t\treturn -EINVAL;\n\t\tspec.match_flags |= EF4_FILTER_MATCH_OUTER_VID;\n\t\tspec.outer_vid = rule->h_ext.vlan_tci;\n\t}\n\n\trc = ef4_filter_insert_filter(efx, &spec, true);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trule->location = rc;\n\treturn 0;\n}\n\nstatic int ef4_ethtool_set_rxnfc(struct net_device *net_dev,\n\t\t\t\t struct ethtool_rxnfc *info)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tif (ef4_filter_get_rx_id_limit(efx) == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\treturn ef4_ethtool_set_class_rule(efx, &info->fs);\n\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\treturn ef4_filter_remove_id_safe(efx, EF4_FILTER_PRI_MANUAL,\n\t\t\t\t\t\t info->fs.location);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32 ef4_ethtool_get_rxfh_indir_size(struct net_device *net_dev)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\treturn ((ef4_nic_rev(efx) < EF4_REV_FALCON_B0 ||\n\t\t efx->n_rx_channels == 1) ?\n\t\t0 : ARRAY_SIZE(efx->rx_indir_table));\n}\n\nstatic int ef4_ethtool_get_rxfh(struct net_device *net_dev, u32 *indir, u8 *key,\n\t\t\t\tu8 *hfunc)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (indir)\n\t\tmemcpy(indir, efx->rx_indir_table, sizeof(efx->rx_indir_table));\n\treturn 0;\n}\n\nstatic int ef4_ethtool_set_rxfh(struct net_device *net_dev, const u32 *indir,\n\t\t\t\tconst u8 *key, const u8 hfunc)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\n\t \n\tif (key ||\n\t    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\tif (!indir)\n\t\treturn 0;\n\n\treturn efx->type->rx_push_rss_config(efx, true, indir);\n}\n\nstatic int ef4_ethtool_get_module_eeprom(struct net_device *net_dev,\n\t\t\t\t\t struct ethtool_eeprom *ee,\n\t\t\t\t\t u8 *data)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tint ret;\n\n\tif (!efx->phy_op || !efx->phy_op->get_module_eeprom)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&efx->mac_lock);\n\tret = efx->phy_op->get_module_eeprom(efx, ee, data);\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn ret;\n}\n\nstatic int ef4_ethtool_get_module_info(struct net_device *net_dev,\n\t\t\t\t       struct ethtool_modinfo *modinfo)\n{\n\tstruct ef4_nic *efx = netdev_priv(net_dev);\n\tint ret;\n\n\tif (!efx->phy_op || !efx->phy_op->get_module_info)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&efx->mac_lock);\n\tret = efx->phy_op->get_module_info(efx, modinfo);\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn ret;\n}\n\nconst struct ethtool_ops ef4_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USECS_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_drvinfo\t\t= ef4_ethtool_get_drvinfo,\n\t.get_regs_len\t\t= ef4_ethtool_get_regs_len,\n\t.get_regs\t\t= ef4_ethtool_get_regs,\n\t.get_msglevel\t\t= ef4_ethtool_get_msglevel,\n\t.set_msglevel\t\t= ef4_ethtool_set_msglevel,\n\t.nway_reset\t\t= ef4_ethtool_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_coalesce\t\t= ef4_ethtool_get_coalesce,\n\t.set_coalesce\t\t= ef4_ethtool_set_coalesce,\n\t.get_ringparam\t\t= ef4_ethtool_get_ringparam,\n\t.set_ringparam\t\t= ef4_ethtool_set_ringparam,\n\t.get_pauseparam         = ef4_ethtool_get_pauseparam,\n\t.set_pauseparam         = ef4_ethtool_set_pauseparam,\n\t.get_sset_count\t\t= ef4_ethtool_get_sset_count,\n\t.self_test\t\t= ef4_ethtool_self_test,\n\t.get_strings\t\t= ef4_ethtool_get_strings,\n\t.set_phys_id\t\t= ef4_ethtool_phys_id,\n\t.get_ethtool_stats\t= ef4_ethtool_get_stats,\n\t.get_wol                = ef4_ethtool_get_wol,\n\t.set_wol                = ef4_ethtool_set_wol,\n\t.reset\t\t\t= ef4_ethtool_reset,\n\t.get_rxnfc\t\t= ef4_ethtool_get_rxnfc,\n\t.set_rxnfc\t\t= ef4_ethtool_set_rxnfc,\n\t.get_rxfh_indir_size\t= ef4_ethtool_get_rxfh_indir_size,\n\t.get_rxfh\t\t= ef4_ethtool_get_rxfh,\n\t.set_rxfh\t\t= ef4_ethtool_set_rxfh,\n\t.get_module_info\t= ef4_ethtool_get_module_info,\n\t.get_module_eeprom\t= ef4_ethtool_get_module_eeprom,\n\t.get_link_ksettings\t= ef4_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= ef4_ethtool_set_link_ksettings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}