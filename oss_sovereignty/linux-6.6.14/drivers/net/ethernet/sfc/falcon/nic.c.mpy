{
  "module_name": "nic.c",
  "hash_id": "d4b0ebf76b7d93e45c7b45083d37c1d4727d0e92f36b5343fd4b99ac05096fbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/nic.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/cpu_rmap.h>\n#include \"net_driver.h\"\n#include \"bitfield.h\"\n#include \"efx.h\"\n#include \"nic.h\"\n#include \"farch_regs.h\"\n#include \"io.h\"\n#include \"workarounds.h\"\n\n \n\nint ef4_nic_alloc_buffer(struct ef4_nic *efx, struct ef4_buffer *buffer,\n\t\t\t unsigned int len, gfp_t gfp_flags)\n{\n\tbuffer->addr = dma_alloc_coherent(&efx->pci_dev->dev, len,\n\t\t\t\t\t  &buffer->dma_addr, gfp_flags);\n\tif (!buffer->addr)\n\t\treturn -ENOMEM;\n\tbuffer->len = len;\n\treturn 0;\n}\n\nvoid ef4_nic_free_buffer(struct ef4_nic *efx, struct ef4_buffer *buffer)\n{\n\tif (buffer->addr) {\n\t\tdma_free_coherent(&efx->pci_dev->dev, buffer->len,\n\t\t\t\t  buffer->addr, buffer->dma_addr);\n\t\tbuffer->addr = NULL;\n\t}\n}\n\n \nbool ef4_nic_event_present(struct ef4_channel *channel)\n{\n\treturn ef4_event_present(ef4_event(channel, channel->eventq_read_ptr));\n}\n\nvoid ef4_nic_event_test_start(struct ef4_channel *channel)\n{\n\tchannel->event_test_cpu = -1;\n\tsmp_wmb();\n\tchannel->efx->type->ev_test_generate(channel);\n}\n\nint ef4_nic_irq_test_start(struct ef4_nic *efx)\n{\n\tefx->last_irq_cpu = -1;\n\tsmp_wmb();\n\treturn efx->type->irq_test_generate(efx);\n}\n\n \nint ef4_nic_init_interrupt(struct ef4_nic *efx)\n{\n\tstruct ef4_channel *channel;\n\tunsigned int n_irqs;\n\tint rc;\n\n\tif (!EF4_INT_MODE_USE_MSI(efx)) {\n\t\trc = request_irq(efx->legacy_irq,\n\t\t\t\t efx->type->irq_handle_legacy, IRQF_SHARED,\n\t\t\t\t efx->name, efx);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"failed to hook legacy IRQ %d\\n\",\n\t\t\t\t  efx->pci_dev->irq);\n\t\t\tgoto fail1;\n\t\t}\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_RFS_ACCEL\n\tif (efx->interrupt_mode == EF4_INT_MODE_MSIX) {\n\t\tefx->net_dev->rx_cpu_rmap =\n\t\t\talloc_irq_cpu_rmap(efx->n_rx_channels);\n\t\tif (!efx->net_dev->rx_cpu_rmap) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail1;\n\t\t}\n\t}\n#endif\n\n\t \n\tn_irqs = 0;\n\tef4_for_each_channel(channel, efx) {\n\t\trc = request_irq(channel->irq, efx->type->irq_handle_msi,\n\t\t\t\t IRQF_PROBE_SHARED,  \n\t\t\t\t efx->msi_context[channel->channel].name,\n\t\t\t\t &efx->msi_context[channel->channel]);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"failed to hook IRQ %d\\n\", channel->irq);\n\t\t\tgoto fail2;\n\t\t}\n\t\t++n_irqs;\n\n#ifdef CONFIG_RFS_ACCEL\n\t\tif (efx->interrupt_mode == EF4_INT_MODE_MSIX &&\n\t\t    channel->channel < efx->n_rx_channels) {\n\t\t\trc = irq_cpu_rmap_add(efx->net_dev->rx_cpu_rmap,\n\t\t\t\t\t      channel->irq);\n\t\t\tif (rc)\n\t\t\t\tgoto fail2;\n\t\t}\n#endif\n\t}\n\n\treturn 0;\n\n fail2:\n#ifdef CONFIG_RFS_ACCEL\n\tfree_irq_cpu_rmap(efx->net_dev->rx_cpu_rmap);\n\tefx->net_dev->rx_cpu_rmap = NULL;\n#endif\n\tef4_for_each_channel(channel, efx) {\n\t\tif (n_irqs-- == 0)\n\t\t\tbreak;\n\t\tfree_irq(channel->irq, &efx->msi_context[channel->channel]);\n\t}\n fail1:\n\treturn rc;\n}\n\nvoid ef4_nic_fini_interrupt(struct ef4_nic *efx)\n{\n\tstruct ef4_channel *channel;\n\n#ifdef CONFIG_RFS_ACCEL\n\tfree_irq_cpu_rmap(efx->net_dev->rx_cpu_rmap);\n\tefx->net_dev->rx_cpu_rmap = NULL;\n#endif\n\n\tif (EF4_INT_MODE_USE_MSI(efx)) {\n\t\t \n\t\tef4_for_each_channel(channel, efx)\n\t\t\tfree_irq(channel->irq,\n\t\t\t\t &efx->msi_context[channel->channel]);\n\t} else {\n\t\t \n\t\tfree_irq(efx->legacy_irq, efx);\n\t}\n}\n\n \n\n#define REGISTER_REVISION_FA\t1\n#define REGISTER_REVISION_FB\t2\n#define REGISTER_REVISION_FC\t3\n#define REGISTER_REVISION_FZ\t3\t \n#define REGISTER_REVISION_ED\t4\n#define REGISTER_REVISION_EZ\t4\t \n\nstruct ef4_nic_reg {\n\tu32 offset:24;\n\tu32 min_revision:3, max_revision:3;\n};\n\n#define REGISTER(name, arch, min_rev, max_rev) {\t\t\t\\\n\tarch ## R_ ## min_rev ## max_rev ## _ ## name,\t\t\t\\\n\tREGISTER_REVISION_ ## arch ## min_rev,\t\t\t\t\\\n\tREGISTER_REVISION_ ## arch ## max_rev\t\t\t\t\\\n}\n#define REGISTER_AA(name) REGISTER(name, F, A, A)\n#define REGISTER_AB(name) REGISTER(name, F, A, B)\n#define REGISTER_AZ(name) REGISTER(name, F, A, Z)\n#define REGISTER_BB(name) REGISTER(name, F, B, B)\n#define REGISTER_BZ(name) REGISTER(name, F, B, Z)\n#define REGISTER_CZ(name) REGISTER(name, F, C, Z)\n\nstatic const struct ef4_nic_reg ef4_nic_regs[] = {\n\tREGISTER_AZ(ADR_REGION),\n\tREGISTER_AZ(INT_EN_KER),\n\tREGISTER_BZ(INT_EN_CHAR),\n\tREGISTER_AZ(INT_ADR_KER),\n\tREGISTER_BZ(INT_ADR_CHAR),\n\t \n\t \n\tREGISTER_AZ(HW_INIT),\n\tREGISTER_CZ(USR_EV_CFG),\n\tREGISTER_AB(EE_SPI_HCMD),\n\tREGISTER_AB(EE_SPI_HADR),\n\tREGISTER_AB(EE_SPI_HDATA),\n\tREGISTER_AB(EE_BASE_PAGE),\n\tREGISTER_AB(EE_VPD_CFG0),\n\t \n\t \n\t \n\tREGISTER_AB(NIC_STAT),\n\tREGISTER_AB(GPIO_CTL),\n\tREGISTER_AB(GLB_CTL),\n\t \n\tREGISTER_BZ(DP_CTRL),\n\tREGISTER_AZ(MEM_STAT),\n\tREGISTER_AZ(CS_DEBUG),\n\tREGISTER_AZ(ALTERA_BUILD),\n\tREGISTER_AZ(CSR_SPARE),\n\tREGISTER_AB(PCIE_SD_CTL0123),\n\tREGISTER_AB(PCIE_SD_CTL45),\n\tREGISTER_AB(PCIE_PCS_CTL_STAT),\n\t \n\t \n\tREGISTER_AZ(EVQ_CTL),\n\tREGISTER_AZ(EVQ_CNT1),\n\tREGISTER_AZ(EVQ_CNT2),\n\tREGISTER_AZ(BUF_TBL_CFG),\n\tREGISTER_AZ(SRM_RX_DC_CFG),\n\tREGISTER_AZ(SRM_TX_DC_CFG),\n\tREGISTER_AZ(SRM_CFG),\n\t \n\tREGISTER_AZ(SRM_UPD_EVQ),\n\tREGISTER_AZ(SRAM_PARITY),\n\tREGISTER_AZ(RX_CFG),\n\tREGISTER_BZ(RX_FILTER_CTL),\n\t \n\tREGISTER_AZ(RX_DC_CFG),\n\tREGISTER_AZ(RX_DC_PF_WM),\n\tREGISTER_BZ(RX_RSS_TKEY),\n\t \n\tREGISTER_AA(RX_SELF_RST),\n\t \n\tREGISTER_CZ(RX_RSS_IPV6_REG1),\n\tREGISTER_CZ(RX_RSS_IPV6_REG2),\n\tREGISTER_CZ(RX_RSS_IPV6_REG3),\n\t \n\tREGISTER_AZ(TX_DC_CFG),\n\tREGISTER_AA(TX_CHKSM_CFG),\n\tREGISTER_AZ(TX_CFG),\n\t \n\tREGISTER_AZ(TX_RESERVED),\n\tREGISTER_BZ(TX_PACE),\n\t \n\tREGISTER_BB(TX_VLAN),\n\tREGISTER_BZ(TX_IPFIL_PORTEN),\n\tREGISTER_AB(MD_TXD),\n\tREGISTER_AB(MD_RXD),\n\tREGISTER_AB(MD_CS),\n\tREGISTER_AB(MD_PHY_ADR),\n\tREGISTER_AB(MD_ID),\n\t \n\tREGISTER_AB(MAC_STAT_DMA),\n\tREGISTER_AB(MAC_CTRL),\n\tREGISTER_BB(GEN_MODE),\n\tREGISTER_AB(MAC_MC_HASH_REG0),\n\tREGISTER_AB(MAC_MC_HASH_REG1),\n\tREGISTER_AB(GM_CFG1),\n\tREGISTER_AB(GM_CFG2),\n\t \n\tREGISTER_AB(GM_MAX_FLEN),\n\t \n\tREGISTER_AB(GM_ADR1),\n\tREGISTER_AB(GM_ADR2),\n\tREGISTER_AB(GMF_CFG0),\n\tREGISTER_AB(GMF_CFG1),\n\tREGISTER_AB(GMF_CFG2),\n\tREGISTER_AB(GMF_CFG3),\n\tREGISTER_AB(GMF_CFG4),\n\tREGISTER_AB(GMF_CFG5),\n\tREGISTER_BB(TX_SRC_MAC_CTL),\n\tREGISTER_AB(XM_ADR_LO),\n\tREGISTER_AB(XM_ADR_HI),\n\tREGISTER_AB(XM_GLB_CFG),\n\tREGISTER_AB(XM_TX_CFG),\n\tREGISTER_AB(XM_RX_CFG),\n\tREGISTER_AB(XM_MGT_INT_MASK),\n\tREGISTER_AB(XM_FC),\n\tREGISTER_AB(XM_PAUSE_TIME),\n\tREGISTER_AB(XM_TX_PARAM),\n\tREGISTER_AB(XM_RX_PARAM),\n\t \n\tREGISTER_AB(XX_PWR_RST),\n\tREGISTER_AB(XX_SD_CTL),\n\tREGISTER_AB(XX_TXDRV_CTL),\n\t \n\t \n};\n\nstruct ef4_nic_reg_table {\n\tu32 offset:24;\n\tu32 min_revision:3, max_revision:3;\n\tu32 step:6, rows:21;\n};\n\n#define REGISTER_TABLE_DIMENSIONS(_, offset, arch, min_rev, max_rev, step, rows) { \\\n\toffset,\t\t\t\t\t\t\t\t\\\n\tREGISTER_REVISION_ ## arch ## min_rev,\t\t\t\t\\\n\tREGISTER_REVISION_ ## arch ## max_rev,\t\t\t\t\\\n\tstep, rows\t\t\t\t\t\t\t\\\n}\n#define REGISTER_TABLE(name, arch, min_rev, max_rev)\t\t\t\\\n\tREGISTER_TABLE_DIMENSIONS(\t\t\t\t\t\\\n\t\tname, arch ## R_ ## min_rev ## max_rev ## _ ## name,\t\\\n\t\tarch, min_rev, max_rev,\t\t\t\t\t\\\n\t\tarch ## R_ ## min_rev ## max_rev ## _ ## name ## _STEP,\t\\\n\t\tarch ## R_ ## min_rev ## max_rev ## _ ## name ## _ROWS)\n#define REGISTER_TABLE_AA(name) REGISTER_TABLE(name, F, A, A)\n#define REGISTER_TABLE_AZ(name) REGISTER_TABLE(name, F, A, Z)\n#define REGISTER_TABLE_BB(name) REGISTER_TABLE(name, F, B, B)\n#define REGISTER_TABLE_BZ(name) REGISTER_TABLE(name, F, B, Z)\n#define REGISTER_TABLE_BB_CZ(name)\t\t\t\t\t\\\n\tREGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, F, B, B,\t\\\n\t\t\t\t  FR_BZ_ ## name ## _STEP,\t\t\\\n\t\t\t\t  FR_BB_ ## name ## _ROWS),\t\t\\\n\tREGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, F, C, Z,\t\\\n\t\t\t\t  FR_BZ_ ## name ## _STEP,\t\t\\\n\t\t\t\t  FR_CZ_ ## name ## _ROWS)\n#define REGISTER_TABLE_CZ(name) REGISTER_TABLE(name, F, C, Z)\n\nstatic const struct ef4_nic_reg_table ef4_nic_reg_tables[] = {\n\t \n\t \n\tREGISTER_TABLE_BB(TX_IPFIL_TBL),\n\tREGISTER_TABLE_BB(TX_SRC_MAC_TBL),\n\tREGISTER_TABLE_AA(RX_DESC_PTR_TBL_KER),\n\tREGISTER_TABLE_BB_CZ(RX_DESC_PTR_TBL),\n\tREGISTER_TABLE_AA(TX_DESC_PTR_TBL_KER),\n\tREGISTER_TABLE_BB_CZ(TX_DESC_PTR_TBL),\n\tREGISTER_TABLE_AA(EVQ_PTR_TBL_KER),\n\tREGISTER_TABLE_BB_CZ(EVQ_PTR_TBL),\n\t \n\tREGISTER_TABLE_DIMENSIONS(BUF_FULL_TBL_KER, FR_AA_BUF_FULL_TBL_KER,\n\t\t\t\t  F, A, A, 8, 1024),\n\tREGISTER_TABLE_DIMENSIONS(BUF_FULL_TBL, FR_BZ_BUF_FULL_TBL,\n\t\t\t\t  F, B, Z, 8, 1024),\n\tREGISTER_TABLE_CZ(RX_MAC_FILTER_TBL0),\n\tREGISTER_TABLE_BB_CZ(TIMER_TBL),\n\tREGISTER_TABLE_BB_CZ(TX_PACE_TBL),\n\tREGISTER_TABLE_BZ(RX_INDIRECTION_TBL),\n\t \n\tREGISTER_TABLE_CZ(TX_MAC_FILTER_TBL0),\n\tREGISTER_TABLE_CZ(MC_TREG_SMEM),\n\t \n\t \n\tREGISTER_TABLE_BZ(RX_FILTER_TBL0),\n};\n\nsize_t ef4_nic_get_regs_len(struct ef4_nic *efx)\n{\n\tconst struct ef4_nic_reg *reg;\n\tconst struct ef4_nic_reg_table *table;\n\tsize_t len = 0;\n\n\tfor (reg = ef4_nic_regs;\n\t     reg < ef4_nic_regs + ARRAY_SIZE(ef4_nic_regs);\n\t     reg++)\n\t\tif (efx->type->revision >= reg->min_revision &&\n\t\t    efx->type->revision <= reg->max_revision)\n\t\t\tlen += sizeof(ef4_oword_t);\n\n\tfor (table = ef4_nic_reg_tables;\n\t     table < ef4_nic_reg_tables + ARRAY_SIZE(ef4_nic_reg_tables);\n\t     table++)\n\t\tif (efx->type->revision >= table->min_revision &&\n\t\t    efx->type->revision <= table->max_revision)\n\t\t\tlen += table->rows * min_t(size_t, table->step, 16);\n\n\treturn len;\n}\n\nvoid ef4_nic_get_regs(struct ef4_nic *efx, void *buf)\n{\n\tconst struct ef4_nic_reg *reg;\n\tconst struct ef4_nic_reg_table *table;\n\n\tfor (reg = ef4_nic_regs;\n\t     reg < ef4_nic_regs + ARRAY_SIZE(ef4_nic_regs);\n\t     reg++) {\n\t\tif (efx->type->revision >= reg->min_revision &&\n\t\t    efx->type->revision <= reg->max_revision) {\n\t\t\tef4_reado(efx, (ef4_oword_t *)buf, reg->offset);\n\t\t\tbuf += sizeof(ef4_oword_t);\n\t\t}\n\t}\n\n\tfor (table = ef4_nic_reg_tables;\n\t     table < ef4_nic_reg_tables + ARRAY_SIZE(ef4_nic_reg_tables);\n\t     table++) {\n\t\tsize_t size, i;\n\n\t\tif (!(efx->type->revision >= table->min_revision &&\n\t\t      efx->type->revision <= table->max_revision))\n\t\t\tcontinue;\n\n\t\tsize = min_t(size_t, table->step, 16);\n\n\t\tfor (i = 0; i < table->rows; i++) {\n\t\t\tswitch (table->step) {\n\t\t\tcase 4:  \n\t\t\t\tef4_readd(efx, buf, table->offset + 4 * i);\n\t\t\t\tbreak;\n\t\t\tcase 8:  \n\t\t\t\tef4_sram_readq(efx,\n\t\t\t\t\t       efx->membase + table->offset,\n\t\t\t\t\t       buf, i);\n\t\t\t\tbreak;\n\t\t\tcase 16:  \n\t\t\t\tef4_reado_table(efx, buf, table->offset, i);\n\t\t\t\tbreak;\n\t\t\tcase 32:  \n\t\t\t\tef4_reado_table(efx, buf, table->offset, 2 * i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbuf += size;\n\t\t}\n\t}\n}\n\n \nsize_t ef4_nic_describe_stats(const struct ef4_hw_stat_desc *desc, size_t count,\n\t\t\t      const unsigned long *mask, u8 *names)\n{\n\tsize_t visible = 0;\n\tsize_t index;\n\n\tfor_each_set_bit(index, mask, count) {\n\t\tif (desc[index].name) {\n\t\t\tif (names) {\n\t\t\t\tstrscpy(names, desc[index].name,\n\t\t\t\t\tETH_GSTRING_LEN);\n\t\t\t\tnames += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t\t++visible;\n\t\t}\n\t}\n\n\treturn visible;\n}\n\n \nvoid ef4_nic_update_stats(const struct ef4_hw_stat_desc *desc, size_t count,\n\t\t\t  const unsigned long *mask,\n\t\t\t  u64 *stats, const void *dma_buf, bool accumulate)\n{\n\tsize_t index;\n\n\tfor_each_set_bit(index, mask, count) {\n\t\tif (desc[index].dma_width) {\n\t\t\tconst void *addr = dma_buf + desc[index].offset;\n\t\t\tu64 val;\n\n\t\t\tswitch (desc[index].dma_width) {\n\t\t\tcase 16:\n\t\t\t\tval = le16_to_cpup((__le16 *)addr);\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tval = le32_to_cpup((__le32 *)addr);\n\t\t\t\tbreak;\n\t\t\tcase 64:\n\t\t\t\tval = le64_to_cpup((__le64 *)addr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\tval = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (accumulate)\n\t\t\t\tstats[index] += val;\n\t\t\telse\n\t\t\t\tstats[index] = val;\n\t\t}\n\t}\n}\n\nvoid ef4_nic_fix_nodesc_drop_stat(struct ef4_nic *efx, u64 *rx_nodesc_drops)\n{\n\t \n\tif (!(efx->net_dev->flags & IFF_UP) || !efx->rx_nodesc_drops_prev_state)\n\t\tefx->rx_nodesc_drops_while_down +=\n\t\t\t*rx_nodesc_drops - efx->rx_nodesc_drops_total;\n\tefx->rx_nodesc_drops_total = *rx_nodesc_drops;\n\tefx->rx_nodesc_drops_prev_state = !!(efx->net_dev->flags & IFF_UP);\n\t*rx_nodesc_drops -= efx->rx_nodesc_drops_while_down;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}