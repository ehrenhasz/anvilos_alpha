{
  "module_name": "txc43128_phy.c",
  "hash_id": "5853233778156caa7a41f394e4eb416fc350a590f510d8f0d971c5df6cd88dbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/txc43128_phy.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include \"efx.h\"\n#include \"mdio_10g.h\"\n#include \"phy.h\"\n#include \"nic.h\"\n\n \n#define TXC_REQUIRED_DEVS (MDIO_DEVS_PCS |\t\\\n\t\t\t   MDIO_DEVS_PMAPMD |\t\\\n\t\t\t   MDIO_DEVS_PHYXS)\n\n#define TXC_LOOPBACKS ((1 << LOOPBACK_PCS) |\t\\\n\t\t       (1 << LOOPBACK_PMAPMD) |\t\\\n\t\t       (1 << LOOPBACK_PHYXS_WS))\n\n \n#define TXCNAME \"TXC43128\"\n \n#define TXC_MAX_RESET_TIME\t500\n \n#define TXC_RESET_WAIT\t\t10\n \n#define TXC_BIST_DURATION\t50\n\n \n\n \n#define TXC_GLRGS_GLCMD\t\t0xc004\n \n \n#define TXC_GLCMD_L01PD_LBN\t5\n#define TXC_GLCMD_L23PD_LBN\t6\n \n#define TXC_GLCMD_LMTSWRST_LBN\t14\n\n \n#define TXC_GLRGS_GSGQLCTL\t0xc01a\n \n#define TXC_GSGQLCT_SGQLEN_LBN\t15\n \n#define TXC_GSGQLCT_LNSL_LBN\t13\n#define TXC_GSGQLCT_LNSL_WIDTH\t2\n\n \n#define TXC_ALRGS_ATXCTL\t0xc040\n \n#define TXC_ATXCTL_TXPD3_LBN\t15\n#define TXC_ATXCTL_TXPD2_LBN\t14\n#define TXC_ATXCTL_TXPD1_LBN\t13\n#define TXC_ATXCTL_TXPD0_LBN\t12\n\n \n#define TXC_ALRGS_ATXAMP0\t0xc041\n \n#define TXC_ALRGS_ATXAMP1\t0xc042\n \n#define TXC_ATXAMP_LANE02_LBN\t3\n \n#define TXC_ATXAMP_LANE13_LBN\t11\n\n#define TXC_ATXAMP_1280_mV\t0\n#define TXC_ATXAMP_1200_mV\t8\n#define TXC_ATXAMP_1120_mV\t12\n#define TXC_ATXAMP_1060_mV\t14\n#define TXC_ATXAMP_0820_mV\t25\n#define TXC_ATXAMP_0720_mV\t26\n#define TXC_ATXAMP_0580_mV\t27\n#define TXC_ATXAMP_0440_mV\t28\n\n#define TXC_ATXAMP_0820_BOTH\t\t\t\t\t\\\n\t((TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE02_LBN)\t\t\\\n\t | (TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE13_LBN))\n\n#define TXC_ATXAMP_DEFAULT\t0x6060  \n\n \n#define TXC_ALRGS_ATXPRE0\t0xc043\n \n#define TXC_ALRGS_ATXPRE1\t0xc044\n\n#define TXC_ATXPRE_NONE 0\n#define TXC_ATXPRE_DEFAULT\t0x1010  \n\n#define TXC_ALRGS_ARXCTL\t0xc045\n \n#define TXC_ARXCTL_RXPD3_LBN\t15\n#define TXC_ARXCTL_RXPD2_LBN\t14\n#define TXC_ARXCTL_RXPD1_LBN\t13\n#define TXC_ARXCTL_RXPD0_LBN\t12\n\n \n#define TXC_MRGS_CTL\t\t0xc340\n \n#define TXC_MCTL_RESET_LBN\t15\t \n#define TXC_MCTL_TXLED_LBN\t14\t \n#define TXC_MCTL_RXLED_LBN\t13\t \n\n \n#define TXC_GPIO_OUTPUT\t\t0xc346\n#define TXC_GPIO_DIR\t\t0xc348\n\n \n#define TXC_BIST_CTL\t\t0xc280\n#define TXC_BIST_TXFRMCNT\t0xc281\n#define TXC_BIST_RX0FRMCNT\t0xc282\n#define TXC_BIST_RX1FRMCNT\t0xc283\n#define TXC_BIST_RX2FRMCNT\t0xc284\n#define TXC_BIST_RX3FRMCNT\t0xc285\n#define TXC_BIST_RX0ERRCNT\t0xc286\n#define TXC_BIST_RX1ERRCNT\t0xc287\n#define TXC_BIST_RX2ERRCNT\t0xc288\n#define TXC_BIST_RX3ERRCNT\t0xc289\n\n \n#define TXC_BIST_CTRL_TYPE_LBN\t10\n#define TXC_BIST_CTRL_TYPE_TSD\t0\t \n#define TXC_BIST_CTRL_TYPE_CRP\t1\t \n#define TXC_BIST_CTRL_TYPE_CJP\t2\t \n#define TXC_BIST_CTRL_TYPE_TSR\t3\t \n \n#define TXC_BIST_CTRL_B10EN_LBN\t12\n \n#define TXC_BIST_CTRL_ENAB_LBN\t13\n \n#define TXC_BIST_CTRL_STOP_LBN\t14\n \n#define TXC_BIST_CTRL_STRT_LBN\t15\n\n \n#define TXC_MTDIABLO_CTRL\t0xc34f\n#define TXC_MTDIABLO_CTRL_PMA_LOOP_LBN\t10\n\nstruct txc43128_data {\n\tunsigned long bug10934_timer;\n\tenum ef4_phy_mode phy_mode;\n\tenum ef4_loopback_mode loopback_mode;\n};\n\n \n#define BUG10934_RESET_INTERVAL (5 * HZ)\n\n \nstatic void txc_reset_logic(struct ef4_nic *efx);\n\n \nvoid falcon_txc_set_gpio_val(struct ef4_nic *efx, int pin, int on)\n{\n\tef4_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_OUTPUT, 1 << pin, on);\n}\n\n \nvoid falcon_txc_set_gpio_dir(struct ef4_nic *efx, int pin, int dir)\n{\n\tef4_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_DIR, 1 << pin, dir);\n}\n\n \nstatic int txc_reset_phy(struct ef4_nic *efx)\n{\n\tint rc = ef4_mdio_reset_mmd(efx, MDIO_MMD_PMAPMD,\n\t\t\t\t    TXC_MAX_RESET_TIME / TXC_RESET_WAIT,\n\t\t\t\t    TXC_RESET_WAIT);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t \n\trc = ef4_mdio_check_mmds(efx, TXC_REQUIRED_DEVS);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tnetif_err(efx, hw, efx->net_dev, TXCNAME \": reset timed out!\\n\");\n\treturn rc;\n}\n\n \nstatic int txc_bist_one(struct ef4_nic *efx, int mmd, int test)\n{\n\tint ctrl, bctl;\n\tint lane;\n\tint rc = 0;\n\n\t \n\tctrl = ef4_mdio_read(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL);\n\tctrl |= (1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);\n\tef4_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);\n\n\t \n\t \n\tbctl = (test << TXC_BIST_CTRL_TYPE_LBN);\n\tef4_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);\n\n\t \n\tbctl |= (1 << TXC_BIST_CTRL_ENAB_LBN);\n\tef4_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);\n\n\t \n\tef4_mdio_write(efx, mmd, TXC_BIST_CTL,\n\t\t       bctl | (1 << TXC_BIST_CTRL_STRT_LBN));\n\n\t \n\tudelay(TXC_BIST_DURATION);\n\n\t \n\tbctl |= (1 << TXC_BIST_CTRL_STOP_LBN);\n\tef4_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);\n\n\t \n\twhile (bctl & (1 << TXC_BIST_CTRL_STOP_LBN))\n\t\tbctl = ef4_mdio_read(efx, mmd, TXC_BIST_CTL);\n\n\t \n\tfor (lane = 0; lane < 4; lane++) {\n\t\tint count = ef4_mdio_read(efx, mmd, TXC_BIST_RX0ERRCNT + lane);\n\t\tif (count != 0) {\n\t\t\tnetif_err(efx, hw, efx->net_dev, TXCNAME\": BIST error. \"\n\t\t\t\t  \"Lane %d had %d errs\\n\", lane, count);\n\t\t\trc = -EIO;\n\t\t}\n\t\tcount = ef4_mdio_read(efx, mmd, TXC_BIST_RX0FRMCNT + lane);\n\t\tif (count == 0) {\n\t\t\tnetif_err(efx, hw, efx->net_dev, TXCNAME\": BIST error. \"\n\t\t\t\t  \"Lane %d got 0 frames\\n\", lane);\n\t\t\trc = -EIO;\n\t\t}\n\t}\n\n\tif (rc == 0)\n\t\tnetif_info(efx, hw, efx->net_dev, TXCNAME\": BIST pass\\n\");\n\n\t \n\tef4_mdio_write(efx, mmd, TXC_BIST_CTL, 0);\n\n\t \n\tctrl &= ~(1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);\n\tef4_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);\n\n\treturn rc;\n}\n\nstatic int txc_bist(struct ef4_nic *efx)\n{\n\treturn txc_bist_one(efx, MDIO_MMD_PCS, TXC_BIST_CTRL_TYPE_TSD);\n}\n\n \nstatic void txc_apply_defaults(struct ef4_nic *efx)\n{\n\tint mctrl;\n\n\t \n\n\t \n\tef4_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE0, TXC_ATXPRE_NONE);\n\tef4_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE1, TXC_ATXPRE_NONE);\n\n\t \n\tef4_mdio_write(efx, MDIO_MMD_PHYXS,\n\t\t       TXC_ALRGS_ATXAMP0, TXC_ATXAMP_0820_BOTH);\n\tef4_mdio_write(efx, MDIO_MMD_PHYXS,\n\t\t       TXC_ALRGS_ATXAMP1, TXC_ATXAMP_0820_BOTH);\n\n\t \n\tef4_mdio_write(efx, MDIO_MMD_PMAPMD,\n\t\t       TXC_ALRGS_ATXPRE0, TXC_ATXPRE_DEFAULT);\n\tef4_mdio_write(efx, MDIO_MMD_PMAPMD,\n\t\t       TXC_ALRGS_ATXPRE1, TXC_ATXPRE_DEFAULT);\n\tef4_mdio_write(efx, MDIO_MMD_PMAPMD,\n\t\t       TXC_ALRGS_ATXAMP0, TXC_ATXAMP_DEFAULT);\n\tef4_mdio_write(efx, MDIO_MMD_PMAPMD,\n\t\t       TXC_ALRGS_ATXAMP1, TXC_ATXAMP_DEFAULT);\n\n\t \n\tmctrl = ef4_mdio_read(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL);\n\n\t \n\tmctrl &= ~((1 << TXC_MCTL_TXLED_LBN) | (1 << TXC_MCTL_RXLED_LBN));\n\tef4_mdio_write(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL, mctrl);\n\n\t \n\ttxc_reset_logic(efx);\n\n\tfalcon_board(efx)->type->init_phy(efx);\n}\n\nstatic int txc43128_phy_probe(struct ef4_nic *efx)\n{\n\tstruct txc43128_data *phy_data;\n\n\t \n\tphy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);\n\tif (!phy_data)\n\t\treturn -ENOMEM;\n\tefx->phy_data = phy_data;\n\tphy_data->phy_mode = efx->phy_mode;\n\n\tefx->mdio.mmds = TXC_REQUIRED_DEVS;\n\tefx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\n\n\tefx->loopback_modes = TXC_LOOPBACKS | FALCON_XMAC_LOOPBACKS;\n\n\treturn 0;\n}\n\n \nstatic int txc43128_phy_init(struct ef4_nic *efx)\n{\n\tint rc;\n\n\trc = txc_reset_phy(efx);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = txc_bist(efx);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttxc_apply_defaults(efx);\n\n\treturn 0;\n}\n\n \nstatic void txc_glrgs_lane_power(struct ef4_nic *efx, int mmd)\n{\n\tint pd = (1 << TXC_GLCMD_L01PD_LBN) | (1 << TXC_GLCMD_L23PD_LBN);\n\tint ctl = ef4_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);\n\n\tif (!(efx->phy_mode & PHY_MODE_LOW_POWER))\n\t\tctl &= ~pd;\n\telse\n\t\tctl |= pd;\n\n\tef4_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, ctl);\n}\n\n \nstatic void txc_analog_lane_power(struct ef4_nic *efx, int mmd)\n{\n\tint txpd = (1 << TXC_ATXCTL_TXPD3_LBN) | (1 << TXC_ATXCTL_TXPD2_LBN)\n\t\t| (1 << TXC_ATXCTL_TXPD1_LBN) | (1 << TXC_ATXCTL_TXPD0_LBN);\n\tint rxpd = (1 << TXC_ARXCTL_RXPD3_LBN) | (1 << TXC_ARXCTL_RXPD2_LBN)\n\t\t| (1 << TXC_ARXCTL_RXPD1_LBN) | (1 << TXC_ARXCTL_RXPD0_LBN);\n\tint txctl = ef4_mdio_read(efx, mmd, TXC_ALRGS_ATXCTL);\n\tint rxctl = ef4_mdio_read(efx, mmd, TXC_ALRGS_ARXCTL);\n\n\tif (!(efx->phy_mode & PHY_MODE_LOW_POWER)) {\n\t\ttxctl &= ~txpd;\n\t\trxctl &= ~rxpd;\n\t} else {\n\t\ttxctl |= txpd;\n\t\trxctl |= rxpd;\n\t}\n\n\tef4_mdio_write(efx, mmd, TXC_ALRGS_ATXCTL, txctl);\n\tef4_mdio_write(efx, mmd, TXC_ALRGS_ARXCTL, rxctl);\n}\n\nstatic void txc_set_power(struct ef4_nic *efx)\n{\n\t \n\tef4_mdio_set_mmds_lpower(efx,\n\t\t\t\t !!(efx->phy_mode & PHY_MODE_LOW_POWER),\n\t\t\t\t TXC_REQUIRED_DEVS);\n\n\t \n\ttxc_glrgs_lane_power(efx, MDIO_MMD_PCS);\n\ttxc_glrgs_lane_power(efx, MDIO_MMD_PHYXS);\n\n\t \n\ttxc_analog_lane_power(efx, MDIO_MMD_PMAPMD);\n\ttxc_analog_lane_power(efx, MDIO_MMD_PHYXS);\n}\n\nstatic void txc_reset_logic_mmd(struct ef4_nic *efx, int mmd)\n{\n\tint val = ef4_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);\n\tint tries = 50;\n\n\tval |= (1 << TXC_GLCMD_LMTSWRST_LBN);\n\tef4_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, val);\n\twhile (--tries) {\n\t\tval = ef4_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);\n\t\tif (!(val & (1 << TXC_GLCMD_LMTSWRST_LBN)))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (!tries)\n\t\tnetif_info(efx, hw, efx->net_dev,\n\t\t\t   TXCNAME \" Logic reset timed out!\\n\");\n}\n\n \nstatic void txc_reset_logic(struct ef4_nic *efx)\n{\n\t \n\ttxc_reset_logic_mmd(efx, MDIO_MMD_PCS);\n}\n\nstatic bool txc43128_phy_read_link(struct ef4_nic *efx)\n{\n\treturn ef4_mdio_links_ok(efx, TXC_REQUIRED_DEVS);\n}\n\nstatic int txc43128_phy_reconfigure(struct ef4_nic *efx)\n{\n\tstruct txc43128_data *phy_data = efx->phy_data;\n\tenum ef4_phy_mode mode_change = efx->phy_mode ^ phy_data->phy_mode;\n\tbool loop_change = LOOPBACK_CHANGED(phy_data, efx, TXC_LOOPBACKS);\n\n\tif (efx->phy_mode & mode_change & PHY_MODE_TX_DISABLED) {\n\t\ttxc_reset_phy(efx);\n\t\ttxc_apply_defaults(efx);\n\t\tfalcon_reset_xaui(efx);\n\t\tmode_change &= ~PHY_MODE_TX_DISABLED;\n\t}\n\n\tef4_mdio_transmit_disable(efx);\n\tef4_mdio_phy_reconfigure(efx);\n\tif (mode_change & PHY_MODE_LOW_POWER)\n\t\ttxc_set_power(efx);\n\n\t \n\tif (loop_change || mode_change)\n\t\ttxc_reset_logic(efx);\n\n\tphy_data->phy_mode = efx->phy_mode;\n\tphy_data->loopback_mode = efx->loopback_mode;\n\n\treturn 0;\n}\n\nstatic void txc43128_phy_fini(struct ef4_nic *efx)\n{\n\t \n\tef4_mdio_write(efx, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0);\n}\n\nstatic void txc43128_phy_remove(struct ef4_nic *efx)\n{\n\tkfree(efx->phy_data);\n\tefx->phy_data = NULL;\n}\n\n \nstatic bool txc43128_phy_poll(struct ef4_nic *efx)\n{\n\tstruct txc43128_data *data = efx->phy_data;\n\tbool was_up = efx->link_state.up;\n\n\tefx->link_state.up = txc43128_phy_read_link(efx);\n\tefx->link_state.speed = 10000;\n\tefx->link_state.fd = true;\n\tefx->link_state.fc = efx->wanted_fc;\n\n\tif (efx->link_state.up || (efx->loopback_mode != LOOPBACK_NONE)) {\n\t\tdata->bug10934_timer = jiffies;\n\t} else {\n\t\tif (time_after_eq(jiffies, (data->bug10934_timer +\n\t\t\t\t\t    BUG10934_RESET_INTERVAL))) {\n\t\t\tdata->bug10934_timer = jiffies;\n\t\t\ttxc_reset_logic(efx);\n\t\t}\n\t}\n\n\treturn efx->link_state.up != was_up;\n}\n\nstatic const char *const txc43128_test_names[] = {\n\t\"bist\"\n};\n\nstatic const char *txc43128_test_name(struct ef4_nic *efx, unsigned int index)\n{\n\tif (index < ARRAY_SIZE(txc43128_test_names))\n\t\treturn txc43128_test_names[index];\n\treturn NULL;\n}\n\nstatic int txc43128_run_tests(struct ef4_nic *efx, int *results, unsigned flags)\n{\n\tint rc;\n\n\tif (!(flags & ETH_TEST_FL_OFFLINE))\n\t\treturn 0;\n\n\trc = txc_reset_phy(efx);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = txc_bist(efx);\n\ttxc_apply_defaults(efx);\n\tresults[0] = rc ? -1 : 1;\n\treturn rc;\n}\n\nstatic void txc43128_get_link_ksettings(struct ef4_nic *efx,\n\t\t\t\t\tstruct ethtool_link_ksettings *cmd)\n{\n\tmdio45_ethtool_ksettings_get(&efx->mdio, cmd);\n}\n\nconst struct ef4_phy_operations falcon_txc_phy_ops = {\n\t.probe\t\t= txc43128_phy_probe,\n\t.init\t\t= txc43128_phy_init,\n\t.reconfigure\t= txc43128_phy_reconfigure,\n\t.poll\t\t= txc43128_phy_poll,\n\t.fini\t\t= txc43128_phy_fini,\n\t.remove\t\t= txc43128_phy_remove,\n\t.get_link_ksettings = txc43128_get_link_ksettings,\n\t.set_link_ksettings = ef4_mdio_set_link_ksettings,\n\t.test_alive\t= ef4_mdio_test_alive,\n\t.run_tests\t= txc43128_run_tests,\n\t.test_name\t= txc43128_test_name,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}