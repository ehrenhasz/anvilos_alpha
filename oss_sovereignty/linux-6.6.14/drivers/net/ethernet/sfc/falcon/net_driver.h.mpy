{
  "module_name": "net_driver.h",
  "hash_id": "15da067c305cfd055f4c7ebd16b6d8fa393a1efce7e22daefc528679f3467aca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/net_driver.h",
  "human_readable_source": " \n \n\n \n\n#ifndef EF4_NET_DRIVER_H\n#define EF4_NET_DRIVER_H\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/timer.h>\n#include <linux/mdio.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/highmem.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/vmalloc.h>\n#include <linux/i2c.h>\n#include <linux/mtd/mtd.h>\n#include <net/busy_poll.h>\n\n#include \"enum.h\"\n#include \"bitfield.h\"\n#include \"filter.h\"\n\n \n\n#define EF4_DRIVER_VERSION\t\"4.1\"\n\n#ifdef DEBUG\n#define EF4_BUG_ON_PARANOID(x) BUG_ON(x)\n#define EF4_WARN_ON_PARANOID(x) WARN_ON(x)\n#else\n#define EF4_BUG_ON_PARANOID(x) do {} while (0)\n#define EF4_WARN_ON_PARANOID(x) do {} while (0)\n#endif\n\n \n\n#define EF4_MAX_CHANNELS 32U\n#define EF4_MAX_RX_QUEUES EF4_MAX_CHANNELS\n#define EF4_EXTRA_CHANNEL_IOV\t0\n#define EF4_EXTRA_CHANNEL_PTP\t1\n#define EF4_MAX_EXTRA_CHANNELS\t2U\n\n \n#define EF4_MAX_TX_TC\t\t2\n#define EF4_MAX_CORE_TX_QUEUES\t(EF4_MAX_TX_TC * EF4_MAX_CHANNELS)\n#define EF4_TXQ_TYPE_OFFLOAD\t1\t \n#define EF4_TXQ_TYPE_HIGHPRI\t2\t \n#define EF4_TXQ_TYPES\t\t4\n#define EF4_MAX_TX_QUEUES\t(EF4_TXQ_TYPES * EF4_MAX_CHANNELS)\n\n \n#define EF4_MAX_MTU (9 * 1024)\n\n \n#define EF4_MIN_MTU 68\n\n \n#define EF4_RX_USR_BUF_SIZE\t(2048 - 256)\n\n \n#if NET_IP_ALIGN == 0\n#define EF4_RX_BUF_ALIGNMENT\tL1_CACHE_BYTES\n#else\n#define EF4_RX_BUF_ALIGNMENT\t4\n#endif\n\nstruct ef4_self_tests;\n\n \nstruct ef4_buffer {\n\tvoid *addr;\n\tdma_addr_t dma_addr;\n\tunsigned int len;\n};\n\n \nstruct ef4_special_buffer {\n\tstruct ef4_buffer buf;\n\tunsigned int index;\n\tunsigned int entries;\n};\n\n \nstruct ef4_tx_buffer {\n\tconst struct sk_buff *skb;\n\tunion {\n\t\tef4_qword_t option;\n\t\tdma_addr_t dma_addr;\n\t};\n\tunsigned short flags;\n\tunsigned short len;\n\tunsigned short unmap_len;\n\tunsigned short dma_offset;\n};\n#define EF4_TX_BUF_CONT\t\t1\t \n#define EF4_TX_BUF_SKB\t\t2\t \n#define EF4_TX_BUF_MAP_SINGLE\t8\t \n#define EF4_TX_BUF_OPTION\t0x10\t \n\n \nstruct ef4_tx_queue {\n\t \n\tstruct ef4_nic *efx ____cacheline_aligned_in_smp;\n\tunsigned queue;\n\tstruct ef4_channel *channel;\n\tstruct netdev_queue *core_txq;\n\tstruct ef4_tx_buffer *buffer;\n\tstruct ef4_buffer *cb_page;\n\tstruct ef4_special_buffer txd;\n\tunsigned int ptr_mask;\n\tbool initialised;\n\tunsigned int tx_min_size;\n\n\t \n\tint (*handle_tso)(struct ef4_tx_queue*, struct sk_buff*, bool *);\n\n\t \n\tunsigned int read_count ____cacheline_aligned_in_smp;\n\tunsigned int old_write_count;\n\tunsigned int merge_events;\n\tunsigned int bytes_compl;\n\tunsigned int pkts_compl;\n\n\t \n\tunsigned int insert_count ____cacheline_aligned_in_smp;\n\tunsigned int write_count;\n\tunsigned int old_read_count;\n\tunsigned int pushes;\n\tbool xmit_more_available;\n\tunsigned int cb_packets;\n\t \n\tunsigned long tx_packets;\n\n\t \n\tunsigned int empty_read_count ____cacheline_aligned_in_smp;\n#define EF4_EMPTY_COUNT_VALID 0x80000000\n\tatomic_t flush_outstanding;\n};\n\n#define EF4_TX_CB_ORDER\t7\n#define EF4_TX_CB_SIZE\t(1 << EF4_TX_CB_ORDER) - NET_IP_ALIGN\n\n \nstruct ef4_rx_buffer {\n\tdma_addr_t dma_addr;\n\tstruct page *page;\n\tu16 page_offset;\n\tu16 len;\n\tu16 flags;\n};\n#define EF4_RX_BUF_LAST_IN_PAGE\t0x0001\n#define EF4_RX_PKT_CSUMMED\t0x0002\n#define EF4_RX_PKT_DISCARD\t0x0004\n#define EF4_RX_PKT_TCP\t\t0x0040\n#define EF4_RX_PKT_PREFIX_LEN\t0x0080\t \n\n \nstruct ef4_rx_page_state {\n\tdma_addr_t dma_addr;\n\n\tunsigned int __pad[] ____cacheline_aligned;\n};\n\n \nstruct ef4_rx_queue {\n\tstruct ef4_nic *efx;\n\tint core_index;\n\tstruct ef4_rx_buffer *buffer;\n\tstruct ef4_special_buffer rxd;\n\tunsigned int ptr_mask;\n\tbool refill_enabled;\n\tbool flush_pending;\n\n\tunsigned int added_count;\n\tunsigned int notified_count;\n\tunsigned int removed_count;\n\tunsigned int scatter_n;\n\tunsigned int scatter_len;\n\tstruct page **page_ring;\n\tunsigned int page_add;\n\tunsigned int page_remove;\n\tunsigned int page_recycle_count;\n\tunsigned int page_recycle_failed;\n\tunsigned int page_recycle_full;\n\tunsigned int page_ptr_mask;\n\tunsigned int max_fill;\n\tunsigned int fast_fill_trigger;\n\tunsigned int min_fill;\n\tunsigned int min_overfill;\n\tunsigned int recycle_count;\n\tstruct timer_list slow_fill;\n\tunsigned int slow_fill_count;\n\t \n\tunsigned long rx_packets;\n};\n\n \nstruct ef4_channel {\n\tstruct ef4_nic *efx;\n\tint channel;\n\tconst struct ef4_channel_type *type;\n\tbool eventq_init;\n\tbool enabled;\n\tint irq;\n\tunsigned int irq_moderation_us;\n\tstruct net_device *napi_dev;\n\tstruct napi_struct napi_str;\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tunsigned long busy_poll_state;\n#endif\n\tstruct ef4_special_buffer eventq;\n\tunsigned int eventq_mask;\n\tunsigned int eventq_read_ptr;\n\tint event_test_cpu;\n\n\tunsigned int irq_count;\n\tunsigned int irq_mod_score;\n#ifdef CONFIG_RFS_ACCEL\n\tunsigned int rfs_filters_added;\n#define RPS_FLOW_ID_INVALID 0xFFFFFFFF\n\tu32 *rps_flow_id;\n#endif\n\n\tunsigned n_rx_tobe_disc;\n\tunsigned n_rx_ip_hdr_chksum_err;\n\tunsigned n_rx_tcp_udp_chksum_err;\n\tunsigned n_rx_mcast_mismatch;\n\tunsigned n_rx_frm_trunc;\n\tunsigned n_rx_overlength;\n\tunsigned n_skbuff_leaks;\n\tunsigned int n_rx_nodesc_trunc;\n\tunsigned int n_rx_merge_events;\n\tunsigned int n_rx_merge_packets;\n\n\tunsigned int rx_pkt_n_frags;\n\tunsigned int rx_pkt_index;\n\n\tstruct ef4_rx_queue rx_queue;\n\tstruct ef4_tx_queue tx_queue[EF4_TXQ_TYPES];\n};\n\n \nstruct ef4_msi_context {\n\tstruct ef4_nic *efx;\n\tunsigned int index;\n\tchar name[IFNAMSIZ + 6];\n};\n\n \nstruct ef4_channel_type {\n\tvoid (*handle_no_channel)(struct ef4_nic *);\n\tint (*pre_probe)(struct ef4_channel *);\n\tvoid (*post_remove)(struct ef4_channel *);\n\tvoid (*get_name)(struct ef4_channel *, char *buf, size_t len);\n\tstruct ef4_channel *(*copy)(const struct ef4_channel *);\n\tbool (*receive_skb)(struct ef4_channel *, struct sk_buff *);\n\tbool keep_eventq;\n};\n\nenum ef4_led_mode {\n\tEF4_LED_OFF\t= 0,\n\tEF4_LED_ON\t= 1,\n\tEF4_LED_DEFAULT\t= 2\n};\n\n#define STRING_TABLE_LOOKUP(val, member) \\\n\t((val) < member ## _max) ? member ## _names[val] : \"(invalid)\"\n\nextern const char *const ef4_loopback_mode_names[];\nextern const unsigned int ef4_loopback_mode_max;\n#define LOOPBACK_MODE(efx) \\\n\tSTRING_TABLE_LOOKUP((efx)->loopback_mode, ef4_loopback_mode)\n\nextern const char *const ef4_reset_type_names[];\nextern const unsigned int ef4_reset_type_max;\n#define RESET_TYPE(type) \\\n\tSTRING_TABLE_LOOKUP(type, ef4_reset_type)\n\nenum ef4_int_mode {\n\t \n\tEF4_INT_MODE_MSIX = 0,\n\tEF4_INT_MODE_MSI = 1,\n\tEF4_INT_MODE_LEGACY = 2,\n\tEF4_INT_MODE_MAX\t \n};\n#define EF4_INT_MODE_USE_MSI(x) (((x)->interrupt_mode) <= EF4_INT_MODE_MSI)\n\nenum nic_state {\n\tSTATE_UNINIT = 0,\t \n\tSTATE_READY = 1,\t \n\tSTATE_DISABLED = 2,\t \n\tSTATE_RECOVERY = 3,\t \n};\n\n \nstruct ef4_nic;\n\n \n#define EF4_FC_RX\tFLOW_CTRL_RX\n#define EF4_FC_TX\tFLOW_CTRL_TX\n#define EF4_FC_AUTO\t4\n\n \nstruct ef4_link_state {\n\tbool up;\n\tbool fd;\n\tu8 fc;\n\tunsigned int speed;\n};\n\nstatic inline bool ef4_link_state_equal(const struct ef4_link_state *left,\n\t\t\t\t\tconst struct ef4_link_state *right)\n{\n\treturn left->up == right->up && left->fd == right->fd &&\n\t\tleft->fc == right->fc && left->speed == right->speed;\n}\n\n \nstruct ef4_phy_operations {\n\tint (*probe) (struct ef4_nic *efx);\n\tint (*init) (struct ef4_nic *efx);\n\tvoid (*fini) (struct ef4_nic *efx);\n\tvoid (*remove) (struct ef4_nic *efx);\n\tint (*reconfigure) (struct ef4_nic *efx);\n\tbool (*poll) (struct ef4_nic *efx);\n\tvoid (*get_link_ksettings)(struct ef4_nic *efx,\n\t\t\t\t   struct ethtool_link_ksettings *cmd);\n\tint (*set_link_ksettings)(struct ef4_nic *efx,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd);\n\tvoid (*set_npage_adv) (struct ef4_nic *efx, u32);\n\tint (*test_alive) (struct ef4_nic *efx);\n\tconst char *(*test_name) (struct ef4_nic *efx, unsigned int index);\n\tint (*run_tests) (struct ef4_nic *efx, int *results, unsigned flags);\n\tint (*get_module_eeprom) (struct ef4_nic *efx,\n\t\t\t       struct ethtool_eeprom *ee,\n\t\t\t       u8 *data);\n\tint (*get_module_info) (struct ef4_nic *efx,\n\t\t\t\tstruct ethtool_modinfo *modinfo);\n};\n\n \nenum ef4_phy_mode {\n\tPHY_MODE_NORMAL\t\t= 0,\n\tPHY_MODE_TX_DISABLED\t= 1,\n\tPHY_MODE_LOW_POWER\t= 2,\n\tPHY_MODE_OFF\t\t= 4,\n\tPHY_MODE_SPECIAL\t= 8,\n};\n\nstatic inline bool ef4_phy_mode_disabled(enum ef4_phy_mode mode)\n{\n\treturn !!(mode & ~PHY_MODE_TX_DISABLED);\n}\n\n \nstruct ef4_hw_stat_desc {\n\tconst char *name;\n\tu16 dma_width;\n\tu16 offset;\n};\n\n \n#define EF4_MCAST_HASH_BITS 8\n\n \n#define EF4_MCAST_HASH_ENTRIES (1 << EF4_MCAST_HASH_BITS)\n\n \nunion ef4_multicast_hash {\n\tu8 byte[EF4_MCAST_HASH_ENTRIES / 8];\n\tef4_oword_t oword[EF4_MCAST_HASH_ENTRIES / sizeof(ef4_oword_t) / 8];\n};\n\n \nstruct ef4_nic {\n\t \n\n\tchar name[IFNAMSIZ];\n\tstruct list_head node;\n\tstruct ef4_nic *primary;\n\tstruct list_head secondary_list;\n\tstruct pci_dev *pci_dev;\n\tunsigned int port_num;\n\tconst struct ef4_nic_type *type;\n\tint legacy_irq;\n\tbool eeh_disabled_legacy_irq;\n\tstruct workqueue_struct *workqueue;\n\tchar workqueue_name[16];\n\tstruct work_struct reset_work;\n\tresource_size_t membase_phys;\n\tvoid __iomem *membase;\n\n\tenum ef4_int_mode interrupt_mode;\n\tunsigned int timer_quantum_ns;\n\tunsigned int timer_max_ns;\n\tbool irq_rx_adaptive;\n\tunsigned int irq_mod_step_us;\n\tunsigned int irq_rx_moderation_us;\n\tu32 msg_enable;\n\n\tenum nic_state state;\n\tunsigned long reset_pending;\n\n\tstruct ef4_channel *channel[EF4_MAX_CHANNELS];\n\tstruct ef4_msi_context msi_context[EF4_MAX_CHANNELS];\n\tconst struct ef4_channel_type *\n\textra_channel_type[EF4_MAX_EXTRA_CHANNELS];\n\n\tunsigned rxq_entries;\n\tunsigned txq_entries;\n\tunsigned int txq_stop_thresh;\n\tunsigned int txq_wake_thresh;\n\n\tunsigned tx_dc_base;\n\tunsigned rx_dc_base;\n\tunsigned sram_lim_qw;\n\tunsigned next_buffer_table;\n\n\tunsigned int max_channels;\n\tunsigned int max_tx_channels;\n\tunsigned n_channels;\n\tunsigned n_rx_channels;\n\tunsigned rss_spread;\n\tunsigned tx_channel_offset;\n\tunsigned n_tx_channels;\n\tunsigned int rx_ip_align;\n\tunsigned int rx_dma_len;\n\tunsigned int rx_buffer_order;\n\tunsigned int rx_buffer_truesize;\n\tunsigned int rx_page_buf_step;\n\tunsigned int rx_bufs_per_page;\n\tunsigned int rx_pages_per_batch;\n\tunsigned int rx_prefix_size;\n\tint rx_packet_hash_offset;\n\tint rx_packet_len_offset;\n\tint rx_packet_ts_offset;\n\tu8 rx_hash_key[40];\n\tu32 rx_indir_table[128];\n\tbool rx_scatter;\n\n\tunsigned int_error_count;\n\tunsigned long int_error_expire;\n\n\tbool irq_soft_enabled;\n\tstruct ef4_buffer irq_status;\n\tunsigned irq_zero_count;\n\tunsigned irq_level;\n\tstruct delayed_work selftest_work;\n\n#ifdef CONFIG_SFC_FALCON_MTD\n\tstruct list_head mtd_list;\n#endif\n\n\tvoid *nic_data;\n\n\tstruct mutex mac_lock;\n\tstruct work_struct mac_work;\n\tbool port_enabled;\n\n\tbool mc_bist_for_other_fn;\n\tbool port_initialized;\n\tstruct net_device *net_dev;\n\n\tnetdev_features_t fixed_features;\n\n\tstruct ef4_buffer stats_buffer;\n\tu64 rx_nodesc_drops_total;\n\tu64 rx_nodesc_drops_while_down;\n\tbool rx_nodesc_drops_prev_state;\n\n\tunsigned int phy_type;\n\tconst struct ef4_phy_operations *phy_op;\n\tvoid *phy_data;\n\tstruct mdio_if_info mdio;\n\tenum ef4_phy_mode phy_mode;\n\n\tu32 link_advertising;\n\tstruct ef4_link_state link_state;\n\tunsigned int n_link_state_changes;\n\n\tbool unicast_filter;\n\tunion ef4_multicast_hash multicast_hash;\n\tu8 wanted_fc;\n\tunsigned fc_disable;\n\n\tatomic_t rx_reset;\n\tenum ef4_loopback_mode loopback_mode;\n\tu64 loopback_modes;\n\n\tvoid *loopback_selftest;\n\n\tstruct rw_semaphore filter_sem;\n\tspinlock_t filter_lock;\n\tvoid *filter_state;\n#ifdef CONFIG_RFS_ACCEL\n\tunsigned int rps_expire_channel;\n\tunsigned int rps_expire_index;\n#endif\n\n\tatomic_t active_queues;\n\tatomic_t rxq_flush_pending;\n\tatomic_t rxq_flush_outstanding;\n\twait_queue_head_t flush_wq;\n\n\tchar *vpd_sn;\n\n\t \n\n\tstruct delayed_work monitor_work ____cacheline_aligned_in_smp;\n\tspinlock_t biu_lock;\n\tint last_irq_cpu;\n\tspinlock_t stats_lock;\n\tatomic_t n_rx_noskb_drops;\n};\n\nstatic inline int ef4_dev_registered(struct ef4_nic *efx)\n{\n\treturn efx->net_dev->reg_state == NETREG_REGISTERED;\n}\n\nstatic inline unsigned int ef4_port_num(struct ef4_nic *efx)\n{\n\treturn efx->port_num;\n}\n\nstruct ef4_mtd_partition {\n\tstruct list_head node;\n\tstruct mtd_info mtd;\n\tconst char *dev_type_name;\n\tconst char *type_name;\n\tchar name[IFNAMSIZ + 20];\n};\n\n \nstruct ef4_nic_type {\n\tunsigned int mem_bar;\n\tunsigned int (*mem_map_size)(struct ef4_nic *efx);\n\tint (*probe)(struct ef4_nic *efx);\n\tvoid (*remove)(struct ef4_nic *efx);\n\tint (*init)(struct ef4_nic *efx);\n\tint (*dimension_resources)(struct ef4_nic *efx);\n\tvoid (*fini)(struct ef4_nic *efx);\n\tvoid (*monitor)(struct ef4_nic *efx);\n\tenum reset_type (*map_reset_reason)(enum reset_type reason);\n\tint (*map_reset_flags)(u32 *flags);\n\tint (*reset)(struct ef4_nic *efx, enum reset_type method);\n\tint (*probe_port)(struct ef4_nic *efx);\n\tvoid (*remove_port)(struct ef4_nic *efx);\n\tbool (*handle_global_event)(struct ef4_channel *channel, ef4_qword_t *);\n\tint (*fini_dmaq)(struct ef4_nic *efx);\n\tvoid (*prepare_flush)(struct ef4_nic *efx);\n\tvoid (*finish_flush)(struct ef4_nic *efx);\n\tvoid (*prepare_flr)(struct ef4_nic *efx);\n\tvoid (*finish_flr)(struct ef4_nic *efx);\n\tsize_t (*describe_stats)(struct ef4_nic *efx, u8 *names);\n\tsize_t (*update_stats)(struct ef4_nic *efx, u64 *full_stats,\n\t\t\t       struct rtnl_link_stats64 *core_stats);\n\tvoid (*start_stats)(struct ef4_nic *efx);\n\tvoid (*pull_stats)(struct ef4_nic *efx);\n\tvoid (*stop_stats)(struct ef4_nic *efx);\n\tvoid (*set_id_led)(struct ef4_nic *efx, enum ef4_led_mode mode);\n\tvoid (*push_irq_moderation)(struct ef4_channel *channel);\n\tint (*reconfigure_port)(struct ef4_nic *efx);\n\tvoid (*prepare_enable_fc_tx)(struct ef4_nic *efx);\n\tint (*reconfigure_mac)(struct ef4_nic *efx);\n\tbool (*check_mac_fault)(struct ef4_nic *efx);\n\tvoid (*get_wol)(struct ef4_nic *efx, struct ethtool_wolinfo *wol);\n\tint (*set_wol)(struct ef4_nic *efx, u32 type);\n\tvoid (*resume_wol)(struct ef4_nic *efx);\n\tint (*test_chip)(struct ef4_nic *efx, struct ef4_self_tests *tests);\n\tint (*test_nvram)(struct ef4_nic *efx);\n\tvoid (*irq_enable_master)(struct ef4_nic *efx);\n\tint (*irq_test_generate)(struct ef4_nic *efx);\n\tvoid (*irq_disable_non_ev)(struct ef4_nic *efx);\n\tirqreturn_t (*irq_handle_msi)(int irq, void *dev_id);\n\tirqreturn_t (*irq_handle_legacy)(int irq, void *dev_id);\n\tint (*tx_probe)(struct ef4_tx_queue *tx_queue);\n\tvoid (*tx_init)(struct ef4_tx_queue *tx_queue);\n\tvoid (*tx_remove)(struct ef4_tx_queue *tx_queue);\n\tvoid (*tx_write)(struct ef4_tx_queue *tx_queue);\n\tunsigned int (*tx_limit_len)(struct ef4_tx_queue *tx_queue,\n\t\t\t\t     dma_addr_t dma_addr, unsigned int len);\n\tint (*rx_push_rss_config)(struct ef4_nic *efx, bool user,\n\t\t\t\t  const u32 *rx_indir_table);\n\tint (*rx_probe)(struct ef4_rx_queue *rx_queue);\n\tvoid (*rx_init)(struct ef4_rx_queue *rx_queue);\n\tvoid (*rx_remove)(struct ef4_rx_queue *rx_queue);\n\tvoid (*rx_write)(struct ef4_rx_queue *rx_queue);\n\tvoid (*rx_defer_refill)(struct ef4_rx_queue *rx_queue);\n\tint (*ev_probe)(struct ef4_channel *channel);\n\tint (*ev_init)(struct ef4_channel *channel);\n\tvoid (*ev_fini)(struct ef4_channel *channel);\n\tvoid (*ev_remove)(struct ef4_channel *channel);\n\tint (*ev_process)(struct ef4_channel *channel, int quota);\n\tvoid (*ev_read_ack)(struct ef4_channel *channel);\n\tvoid (*ev_test_generate)(struct ef4_channel *channel);\n\tint (*filter_table_probe)(struct ef4_nic *efx);\n\tvoid (*filter_table_restore)(struct ef4_nic *efx);\n\tvoid (*filter_table_remove)(struct ef4_nic *efx);\n\tvoid (*filter_update_rx_scatter)(struct ef4_nic *efx);\n\ts32 (*filter_insert)(struct ef4_nic *efx,\n\t\t\t     struct ef4_filter_spec *spec, bool replace);\n\tint (*filter_remove_safe)(struct ef4_nic *efx,\n\t\t\t\t  enum ef4_filter_priority priority,\n\t\t\t\t  u32 filter_id);\n\tint (*filter_get_safe)(struct ef4_nic *efx,\n\t\t\t       enum ef4_filter_priority priority,\n\t\t\t       u32 filter_id, struct ef4_filter_spec *);\n\tint (*filter_clear_rx)(struct ef4_nic *efx,\n\t\t\t       enum ef4_filter_priority priority);\n\tu32 (*filter_count_rx_used)(struct ef4_nic *efx,\n\t\t\t\t    enum ef4_filter_priority priority);\n\tu32 (*filter_get_rx_id_limit)(struct ef4_nic *efx);\n\ts32 (*filter_get_rx_ids)(struct ef4_nic *efx,\n\t\t\t\t enum ef4_filter_priority priority,\n\t\t\t\t u32 *buf, u32 size);\n#ifdef CONFIG_RFS_ACCEL\n\ts32 (*filter_rfs_insert)(struct ef4_nic *efx,\n\t\t\t\t struct ef4_filter_spec *spec);\n\tbool (*filter_rfs_expire_one)(struct ef4_nic *efx, u32 flow_id,\n\t\t\t\t      unsigned int index);\n#endif\n#ifdef CONFIG_SFC_FALCON_MTD\n\tint (*mtd_probe)(struct ef4_nic *efx);\n\tvoid (*mtd_rename)(struct ef4_mtd_partition *part);\n\tint (*mtd_read)(struct mtd_info *mtd, loff_t start, size_t len,\n\t\t\tsize_t *retlen, u8 *buffer);\n\tint (*mtd_erase)(struct mtd_info *mtd, loff_t start, size_t len);\n\tint (*mtd_write)(struct mtd_info *mtd, loff_t start, size_t len,\n\t\t\t size_t *retlen, const u8 *buffer);\n\tint (*mtd_sync)(struct mtd_info *mtd);\n#endif\n\tint (*get_mac_address)(struct ef4_nic *efx, unsigned char *perm_addr);\n\tint (*set_mac_address)(struct ef4_nic *efx);\n\n\tint revision;\n\tunsigned int txd_ptr_tbl_base;\n\tunsigned int rxd_ptr_tbl_base;\n\tunsigned int buf_tbl_base;\n\tunsigned int evq_ptr_tbl_base;\n\tunsigned int evq_rptr_tbl_base;\n\tu64 max_dma_mask;\n\tunsigned int rx_prefix_size;\n\tunsigned int rx_hash_offset;\n\tunsigned int rx_ts_offset;\n\tunsigned int rx_buffer_padding;\n\tbool can_rx_scatter;\n\tbool always_rx_scatter;\n\tunsigned int max_interrupt_mode;\n\tunsigned int timer_period_max;\n\tnetdev_features_t offload_features;\n\tunsigned int max_rx_ip_filters;\n};\n\n \n\nstatic inline struct ef4_channel *\nef4_get_channel(struct ef4_nic *efx, unsigned index)\n{\n\tEF4_BUG_ON_PARANOID(index >= efx->n_channels);\n\treturn efx->channel[index];\n}\n\n \n#define ef4_for_each_channel(_channel, _efx)\t\t\t\t\\\n\tfor (_channel = (_efx)->channel[0];\t\t\t\t\\\n\t     _channel;\t\t\t\t\t\t\t\\\n\t     _channel = (_channel->channel + 1 < (_efx)->n_channels) ?\t\\\n\t\t     (_efx)->channel[_channel->channel + 1] : NULL)\n\n \n#define ef4_for_each_channel_rev(_channel, _efx)\t\t\t\\\n\tfor (_channel = (_efx)->channel[(_efx)->n_channels - 1];\t\\\n\t     _channel;\t\t\t\t\t\t\t\\\n\t     _channel = _channel->channel ?\t\t\t\t\\\n\t\t     (_efx)->channel[_channel->channel - 1] : NULL)\n\nstatic inline struct ef4_tx_queue *\nef4_get_tx_queue(struct ef4_nic *efx, unsigned index, unsigned type)\n{\n\tEF4_BUG_ON_PARANOID(index >= efx->n_tx_channels ||\n\t\t\t    type >= EF4_TXQ_TYPES);\n\treturn &efx->channel[efx->tx_channel_offset + index]->tx_queue[type];\n}\n\nstatic inline bool ef4_channel_has_tx_queues(struct ef4_channel *channel)\n{\n\treturn channel->channel - channel->efx->tx_channel_offset <\n\t\tchannel->efx->n_tx_channels;\n}\n\nstatic inline struct ef4_tx_queue *\nef4_channel_get_tx_queue(struct ef4_channel *channel, unsigned type)\n{\n\tEF4_BUG_ON_PARANOID(!ef4_channel_has_tx_queues(channel) ||\n\t\t\t    type >= EF4_TXQ_TYPES);\n\treturn &channel->tx_queue[type];\n}\n\nstatic inline bool ef4_tx_queue_used(struct ef4_tx_queue *tx_queue)\n{\n\treturn !(tx_queue->efx->net_dev->num_tc < 2 &&\n\t\t tx_queue->queue & EF4_TXQ_TYPE_HIGHPRI);\n}\n\n \n#define ef4_for_each_channel_tx_queue(_tx_queue, _channel)\t\t\\\n\tif (!ef4_channel_has_tx_queues(_channel))\t\t\t\\\n\t\t;\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tfor (_tx_queue = (_channel)->tx_queue;\t\t\t\\\n\t\t     _tx_queue < (_channel)->tx_queue + EF4_TXQ_TYPES && \\\n\t\t\t     ef4_tx_queue_used(_tx_queue);\t\t\\\n\t\t     _tx_queue++)\n\n \n#define ef4_for_each_possible_channel_tx_queue(_tx_queue, _channel)\t\\\n\tif (!ef4_channel_has_tx_queues(_channel))\t\t\t\\\n\t\t;\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tfor (_tx_queue = (_channel)->tx_queue;\t\t\t\\\n\t\t     _tx_queue < (_channel)->tx_queue + EF4_TXQ_TYPES;\t\\\n\t\t     _tx_queue++)\n\nstatic inline bool ef4_channel_has_rx_queue(struct ef4_channel *channel)\n{\n\treturn channel->rx_queue.core_index >= 0;\n}\n\nstatic inline struct ef4_rx_queue *\nef4_channel_get_rx_queue(struct ef4_channel *channel)\n{\n\tEF4_BUG_ON_PARANOID(!ef4_channel_has_rx_queue(channel));\n\treturn &channel->rx_queue;\n}\n\n \n#define ef4_for_each_channel_rx_queue(_rx_queue, _channel)\t\t\\\n\tif (!ef4_channel_has_rx_queue(_channel))\t\t\t\\\n\t\t;\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tfor (_rx_queue = &(_channel)->rx_queue;\t\t\t\\\n\t\t     _rx_queue;\t\t\t\t\t\t\\\n\t\t     _rx_queue = NULL)\n\nstatic inline struct ef4_channel *\nef4_rx_queue_channel(struct ef4_rx_queue *rx_queue)\n{\n\treturn container_of(rx_queue, struct ef4_channel, rx_queue);\n}\n\nstatic inline int ef4_rx_queue_index(struct ef4_rx_queue *rx_queue)\n{\n\treturn ef4_rx_queue_channel(rx_queue)->channel;\n}\n\n \nstatic inline struct ef4_rx_buffer *ef4_rx_buffer(struct ef4_rx_queue *rx_queue,\n\t\t\t\t\t\t  unsigned int index)\n{\n\treturn &rx_queue->buffer[index];\n}\n\n \n#define EF4_FRAME_PAD\t16\n#define EF4_MAX_FRAME_LEN(mtu) \\\n\t(ALIGN(((mtu) + ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN + EF4_FRAME_PAD), 8))\n\n \nstatic inline netdev_features_t ef4_supported_features(const struct ef4_nic *efx)\n{\n\tconst struct net_device *net_dev = efx->net_dev;\n\n\treturn net_dev->features | net_dev->hw_features;\n}\n\n \nstatic inline unsigned int\nef4_tx_queue_get_insert_index(const struct ef4_tx_queue *tx_queue)\n{\n\treturn tx_queue->insert_count & tx_queue->ptr_mask;\n}\n\n \nstatic inline struct ef4_tx_buffer *\n__ef4_tx_queue_get_insert_buffer(const struct ef4_tx_queue *tx_queue)\n{\n\treturn &tx_queue->buffer[ef4_tx_queue_get_insert_index(tx_queue)];\n}\n\n \nstatic inline struct ef4_tx_buffer *\nef4_tx_queue_get_insert_buffer(const struct ef4_tx_queue *tx_queue)\n{\n\tstruct ef4_tx_buffer *buffer =\n\t\t__ef4_tx_queue_get_insert_buffer(tx_queue);\n\n\tEF4_BUG_ON_PARANOID(buffer->len);\n\tEF4_BUG_ON_PARANOID(buffer->flags);\n\tEF4_BUG_ON_PARANOID(buffer->unmap_len);\n\n\treturn buffer;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}