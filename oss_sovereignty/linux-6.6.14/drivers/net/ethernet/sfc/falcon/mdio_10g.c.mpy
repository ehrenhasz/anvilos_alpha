{
  "module_name": "mdio_10g.c",
  "hash_id": "71f7628c62d07f6ffe5714fa1591587d6fe6030d18d6c5cce5a28f9e124736ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/mdio_10g.c",
  "human_readable_source": "\n \n \n#include <linux/types.h>\n#include <linux/ethtool.h>\n#include <linux/delay.h>\n#include \"net_driver.h\"\n#include \"mdio_10g.h\"\n#include \"workarounds.h\"\n\nunsigned ef4_mdio_id_oui(u32 id)\n{\n\tunsigned oui = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < 22; ++i)\n\t\tif (id & (1 << (i + 10)))\n\t\t\toui |= 1 << (i ^ 7);\n\n\treturn oui;\n}\n\nint ef4_mdio_reset_mmd(struct ef4_nic *port, int mmd,\n\t\t\t    int spins, int spintime)\n{\n\tu32 ctrl;\n\n\t \n\tEF4_BUG_ON_PARANOID(spins * spintime >= 5000);\n\n\tef4_mdio_write(port, mmd, MDIO_CTRL1, MDIO_CTRL1_RESET);\n\t \n\tdo {\n\t\tmsleep(spintime);\n\t\tctrl = ef4_mdio_read(port, mmd, MDIO_CTRL1);\n\t\tspins--;\n\n\t} while (spins && (ctrl & MDIO_CTRL1_RESET));\n\n\treturn spins ? spins : -ETIMEDOUT;\n}\n\nstatic int ef4_mdio_check_mmd(struct ef4_nic *efx, int mmd)\n{\n\tint status;\n\n\tif (mmd != MDIO_MMD_AN) {\n\t\t \n\t\tstatus = ef4_mdio_read(efx, mmd, MDIO_STAT2);\n\t\tif ((status & MDIO_STAT2_DEVPRST) != MDIO_STAT2_DEVPRST_VAL) {\n\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t  \"PHY MMD %d not responding.\\n\", mmd);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n#define MDIO45_RESET_TIME\t1000  \n#define MDIO45_RESET_ITERS\t100\n\nint ef4_mdio_wait_reset_mmds(struct ef4_nic *efx, unsigned int mmd_mask)\n{\n\tconst int spintime = MDIO45_RESET_TIME / MDIO45_RESET_ITERS;\n\tint tries = MDIO45_RESET_ITERS;\n\tint rc = 0;\n\tint in_reset;\n\n\twhile (tries) {\n\t\tint mask = mmd_mask;\n\t\tint mmd = 0;\n\t\tint stat;\n\t\tin_reset = 0;\n\t\twhile (mask) {\n\t\t\tif (mask & 1) {\n\t\t\t\tstat = ef4_mdio_read(efx, mmd, MDIO_CTRL1);\n\t\t\t\tif (stat < 0) {\n\t\t\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t\t\t  \"failed to read status of\"\n\t\t\t\t\t\t  \" MMD %d\\n\", mmd);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tif (stat & MDIO_CTRL1_RESET)\n\t\t\t\t\tin_reset |= (1 << mmd);\n\t\t\t}\n\t\t\tmask = mask >> 1;\n\t\t\tmmd++;\n\t\t}\n\t\tif (!in_reset)\n\t\t\tbreak;\n\t\ttries--;\n\t\tmsleep(spintime);\n\t}\n\tif (in_reset != 0) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"not all MMDs came out of reset in time.\"\n\t\t\t  \" MMDs still in reset: %x\\n\", in_reset);\n\t\trc = -ETIMEDOUT;\n\t}\n\treturn rc;\n}\n\nint ef4_mdio_check_mmds(struct ef4_nic *efx, unsigned int mmd_mask)\n{\n\tint mmd = 0, probe_mmd, devs1, devs2;\n\tu32 devices;\n\n\t \n\tprobe_mmd = (mmd_mask & MDIO_DEVS_PHYXS) ? MDIO_MMD_PHYXS :\n\t    __ffs(mmd_mask);\n\n\t \n\tdevs1 = ef4_mdio_read(efx, probe_mmd, MDIO_DEVS1);\n\tdevs2 = ef4_mdio_read(efx, probe_mmd, MDIO_DEVS2);\n\tif (devs1 < 0 || devs2 < 0) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"failed to read devices present\\n\");\n\t\treturn -EIO;\n\t}\n\tdevices = devs1 | (devs2 << 16);\n\tif ((devices & mmd_mask) != mmd_mask) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"required MMDs not present: got %x, wanted %x\\n\",\n\t\t\t  devices, mmd_mask);\n\t\treturn -ENODEV;\n\t}\n\tnetif_vdbg(efx, hw, efx->net_dev, \"Devices present: %x\\n\", devices);\n\n\t \n\twhile (mmd_mask) {\n\t\tif ((mmd_mask & 1) && ef4_mdio_check_mmd(efx, mmd))\n\t\t\treturn -EIO;\n\t\tmmd_mask = mmd_mask >> 1;\n\t\tmmd++;\n\t}\n\n\treturn 0;\n}\n\nbool ef4_mdio_links_ok(struct ef4_nic *efx, unsigned int mmd_mask)\n{\n\t \n\tif (LOOPBACK_INTERNAL(efx))\n\t\treturn true;\n\telse if (LOOPBACK_MASK(efx) & LOOPBACKS_WS)\n\t\treturn false;\n\telse if (ef4_phy_mode_disabled(efx->phy_mode))\n\t\treturn false;\n\telse if (efx->loopback_mode == LOOPBACK_PHYXS)\n\t\tmmd_mask &= ~(MDIO_DEVS_PHYXS |\n\t\t\t      MDIO_DEVS_PCS |\n\t\t\t      MDIO_DEVS_PMAPMD |\n\t\t\t      MDIO_DEVS_AN);\n\telse if (efx->loopback_mode == LOOPBACK_PCS)\n\t\tmmd_mask &= ~(MDIO_DEVS_PCS |\n\t\t\t      MDIO_DEVS_PMAPMD |\n\t\t\t      MDIO_DEVS_AN);\n\telse if (efx->loopback_mode == LOOPBACK_PMAPMD)\n\t\tmmd_mask &= ~(MDIO_DEVS_PMAPMD |\n\t\t\t      MDIO_DEVS_AN);\n\n\treturn mdio45_links_ok(&efx->mdio, mmd_mask);\n}\n\nvoid ef4_mdio_transmit_disable(struct ef4_nic *efx)\n{\n\tef4_mdio_set_flag(efx, MDIO_MMD_PMAPMD,\n\t\t\t  MDIO_PMA_TXDIS, MDIO_PMD_TXDIS_GLOBAL,\n\t\t\t  efx->phy_mode & PHY_MODE_TX_DISABLED);\n}\n\nvoid ef4_mdio_phy_reconfigure(struct ef4_nic *efx)\n{\n\tef4_mdio_set_flag(efx, MDIO_MMD_PMAPMD,\n\t\t\t  MDIO_CTRL1, MDIO_PMA_CTRL1_LOOPBACK,\n\t\t\t  efx->loopback_mode == LOOPBACK_PMAPMD);\n\tef4_mdio_set_flag(efx, MDIO_MMD_PCS,\n\t\t\t  MDIO_CTRL1, MDIO_PCS_CTRL1_LOOPBACK,\n\t\t\t  efx->loopback_mode == LOOPBACK_PCS);\n\tef4_mdio_set_flag(efx, MDIO_MMD_PHYXS,\n\t\t\t  MDIO_CTRL1, MDIO_PHYXS_CTRL1_LOOPBACK,\n\t\t\t  efx->loopback_mode == LOOPBACK_PHYXS_WS);\n}\n\nstatic void ef4_mdio_set_mmd_lpower(struct ef4_nic *efx,\n\t\t\t\t    int lpower, int mmd)\n{\n\tint stat = ef4_mdio_read(efx, mmd, MDIO_STAT1);\n\n\tnetif_vdbg(efx, drv, efx->net_dev, \"Setting low power mode for MMD %d to %d\\n\",\n\t\t  mmd, lpower);\n\n\tif (stat & MDIO_STAT1_LPOWERABLE) {\n\t\tef4_mdio_set_flag(efx, mmd, MDIO_CTRL1,\n\t\t\t\t  MDIO_CTRL1_LPOWER, lpower);\n\t}\n}\n\nvoid ef4_mdio_set_mmds_lpower(struct ef4_nic *efx,\n\t\t\t      int low_power, unsigned int mmd_mask)\n{\n\tint mmd = 0;\n\tmmd_mask &= ~MDIO_DEVS_AN;\n\twhile (mmd_mask) {\n\t\tif (mmd_mask & 1)\n\t\t\tef4_mdio_set_mmd_lpower(efx, low_power, mmd);\n\t\tmmd_mask = (mmd_mask >> 1);\n\t\tmmd++;\n\t}\n}\n\n \nint ef4_mdio_set_link_ksettings(struct ef4_nic *efx,\n\t\t\t\tconst struct ethtool_link_ksettings *cmd)\n{\n\tstruct ethtool_link_ksettings prev = {\n\t\t.base.cmd = ETHTOOL_GLINKSETTINGS\n\t};\n\tu32 prev_advertising, advertising;\n\tu32 prev_supported;\n\n\tefx->phy_op->get_link_ksettings(efx, &prev);\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\tethtool_convert_link_mode_to_legacy_u32(&prev_advertising,\n\t\t\t\t\t\tprev.link_modes.advertising);\n\tethtool_convert_link_mode_to_legacy_u32(&prev_supported,\n\t\t\t\t\t\tprev.link_modes.supported);\n\n\tif (advertising == prev_advertising &&\n\t    cmd->base.speed == prev.base.speed &&\n\t    cmd->base.duplex == prev.base.duplex &&\n\t    cmd->base.port == prev.base.port &&\n\t    cmd->base.autoneg == prev.base.autoneg)\n\t\treturn 0;\n\n\t \n\tif (prev.base.port != PORT_TP || cmd->base.port != PORT_TP)\n\t\treturn -EINVAL;\n\n\t \n\tif (!cmd->base.autoneg ||\n\t    (advertising | SUPPORTED_Autoneg) & ~prev_supported)\n\t\treturn -EINVAL;\n\n\tef4_link_set_advertising(efx, advertising | ADVERTISED_Autoneg);\n\tef4_mdio_an_reconfigure(efx);\n\treturn 0;\n}\n\n \nvoid ef4_mdio_an_reconfigure(struct ef4_nic *efx)\n{\n\tint reg;\n\n\tWARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));\n\n\t \n\treg = ADVERTISE_CSMA | ADVERTISE_RESV;\n\tif (efx->link_advertising & ADVERTISED_Pause)\n\t\treg |= ADVERTISE_PAUSE_CAP;\n\tif (efx->link_advertising & ADVERTISED_Asym_Pause)\n\t\treg |= ADVERTISE_PAUSE_ASYM;\n\tef4_mdio_write(efx, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);\n\n\t \n\tefx->phy_op->set_npage_adv(efx, efx->link_advertising);\n\n\t \n\treg = ef4_mdio_read(efx, MDIO_MMD_AN, MDIO_CTRL1);\n\treg |= MDIO_AN_CTRL1_ENABLE | MDIO_AN_CTRL1_RESTART | MDIO_AN_CTRL1_XNP;\n\tef4_mdio_write(efx, MDIO_MMD_AN, MDIO_CTRL1, reg);\n}\n\nu8 ef4_mdio_get_pause(struct ef4_nic *efx)\n{\n\tBUILD_BUG_ON(EF4_FC_AUTO & (EF4_FC_RX | EF4_FC_TX));\n\n\tif (!(efx->wanted_fc & EF4_FC_AUTO))\n\t\treturn efx->wanted_fc;\n\n\tWARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));\n\n\treturn mii_resolve_flowctrl_fdx(\n\t\tmii_advertise_flowctrl(efx->wanted_fc),\n\t\tef4_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_LPA));\n}\n\nint ef4_mdio_test_alive(struct ef4_nic *efx)\n{\n\tint rc;\n\tint devad = __ffs(efx->mdio.mmds);\n\tu16 physid1, physid2;\n\n\tmutex_lock(&efx->mac_lock);\n\n\tphysid1 = ef4_mdio_read(efx, devad, MDIO_DEVID1);\n\tphysid2 = ef4_mdio_read(efx, devad, MDIO_DEVID2);\n\n\tif ((physid1 == 0x0000) || (physid1 == 0xffff) ||\n\t    (physid2 == 0x0000) || (physid2 == 0xffff)) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"no MDIO PHY present with ID %d\\n\", efx->mdio.prtad);\n\t\trc = -EINVAL;\n\t} else {\n\t\trc = ef4_mdio_check_mmds(efx, efx->mdio.mmds);\n\t}\n\n\tmutex_unlock(&efx->mac_lock);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}