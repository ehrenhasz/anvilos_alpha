{
  "module_name": "qt202x_phy.c",
  "hash_id": "06949f5cb82addb755a5b01555c9b86a4ab3e6b94d3ef67ba4d282f08a9236e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/qt202x_phy.c",
  "human_readable_source": "\n \n \n\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include \"efx.h\"\n#include \"mdio_10g.h\"\n#include \"phy.h\"\n#include \"nic.h\"\n\n#define QT202X_REQUIRED_DEVS (MDIO_DEVS_PCS |\t\t\\\n\t\t\t      MDIO_DEVS_PMAPMD |\t\\\n\t\t\t      MDIO_DEVS_PHYXS)\n\n#define QT202X_LOOPBACKS ((1 << LOOPBACK_PCS) |\t\t\\\n\t\t\t  (1 << LOOPBACK_PMAPMD) |\t\\\n\t\t\t  (1 << LOOPBACK_PHYXS_WS))\n\n \n \n#define MDIO_QUAKE_LED0_REG\t(0xD006)\n\n \n#define PCS_FW_HEARTBEAT_REG\t0xd7ee\n#define PCS_FW_HEARTB_LBN\t0\n#define PCS_FW_HEARTB_WIDTH\t8\n#define PCS_FW_PRODUCT_CODE_1\t0xd7f0\n#define PCS_FW_VERSION_1\t0xd7f3\n#define PCS_FW_BUILD_1\t\t0xd7f6\n#define PCS_UC8051_STATUS_REG\t0xd7fd\n#define PCS_UC_STATUS_LBN\t0\n#define PCS_UC_STATUS_WIDTH\t8\n#define PCS_UC_STATUS_FW_SAVE\t0x20\n#define PMA_PMD_MODE_REG\t0xc301\n#define PMA_PMD_RXIN_SEL_LBN\t6\n#define PMA_PMD_FTX_CTRL2_REG\t0xc309\n#define PMA_PMD_FTX_STATIC_LBN\t13\n#define PMA_PMD_VEND1_REG\t0xc001\n#define PMA_PMD_VEND1_LBTXD_LBN\t15\n#define PCS_VEND1_REG\t\t0xc000\n#define PCS_VEND1_LBTXD_LBN\t5\n\nvoid falcon_qt202x_set_led(struct ef4_nic *p, int led, int mode)\n{\n\tint addr = MDIO_QUAKE_LED0_REG + led;\n\tef4_mdio_write(p, MDIO_MMD_PMAPMD, addr, mode);\n}\n\nstruct qt202x_phy_data {\n\tenum ef4_phy_mode phy_mode;\n\tbool bug17190_in_bad_state;\n\tunsigned long bug17190_timer;\n\tu32 firmware_ver;\n};\n\n#define QT2022C2_MAX_RESET_TIME 500\n#define QT2022C2_RESET_WAIT 10\n\n#define QT2025C_MAX_HEARTB_TIME (5 * HZ)\n#define QT2025C_HEARTB_WAIT 100\n#define QT2025C_MAX_FWSTART_TIME (25 * HZ / 10)\n#define QT2025C_FWSTART_WAIT 100\n\n#define BUG17190_INTERVAL (2 * HZ)\n\nstatic int qt2025c_wait_heartbeat(struct ef4_nic *efx)\n{\n\tunsigned long timeout = jiffies + QT2025C_MAX_HEARTB_TIME;\n\tint reg, old_counter = 0;\n\n\t \n\tfor (;;) {\n\t\tint counter;\n\t\treg = ef4_mdio_read(efx, MDIO_MMD_PCS, PCS_FW_HEARTBEAT_REG);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\t\tcounter = ((reg >> PCS_FW_HEARTB_LBN) &\n\t\t\t    ((1 << PCS_FW_HEARTB_WIDTH) - 1));\n\t\tif (old_counter == 0)\n\t\t\told_counter = counter;\n\t\telse if (counter != old_counter)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t  \"If an SFP+ direct attach cable is\"\n\t\t\t\t  \" connected, please check that it complies\"\n\t\t\t\t  \" with the SFP+ specification\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(QT2025C_HEARTB_WAIT);\n\t}\n\n\treturn 0;\n}\n\nstatic int qt2025c_wait_fw_status_good(struct ef4_nic *efx)\n{\n\tunsigned long timeout = jiffies + QT2025C_MAX_FWSTART_TIME;\n\tint reg;\n\n\t \n\tfor (;;) {\n\t\treg = ef4_mdio_read(efx, MDIO_MMD_PCS, PCS_UC8051_STATUS_REG);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\t\tif ((reg &\n\t\t     ((1 << PCS_UC_STATUS_WIDTH) - 1) << PCS_UC_STATUS_LBN) >=\n\t\t    PCS_UC_STATUS_FW_SAVE)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tmsleep(QT2025C_FWSTART_WAIT);\n\t}\n\n\treturn 0;\n}\n\nstatic void qt2025c_restart_firmware(struct ef4_nic *efx)\n{\n\t \n\tef4_mdio_write(efx, 3, 0xe854, 0x00c0);\n\tef4_mdio_write(efx, 3, 0xe854, 0x0040);\n\tmsleep(50);\n}\n\nstatic int qt2025c_wait_reset(struct ef4_nic *efx)\n{\n\tint rc;\n\n\trc = qt2025c_wait_heartbeat(efx);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = qt2025c_wait_fw_status_good(efx);\n\tif (rc == -ETIMEDOUT) {\n\t\t \n\t\tnetif_dbg(efx, hw, efx->net_dev,\n\t\t\t  \"bashing QT2025C microcontroller\\n\");\n\t\tqt2025c_restart_firmware(efx);\n\t\trc = qt2025c_wait_heartbeat(efx);\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t\trc = qt2025c_wait_fw_status_good(efx);\n\t}\n\n\treturn rc;\n}\n\nstatic void qt2025c_firmware_id(struct ef4_nic *efx)\n{\n\tstruct qt202x_phy_data *phy_data = efx->phy_data;\n\tu8 firmware_id[9];\n\tsize_t i;\n\n\tfor (i = 0; i < sizeof(firmware_id); i++)\n\t\tfirmware_id[i] = ef4_mdio_read(efx, MDIO_MMD_PCS,\n\t\t\t\t\t       PCS_FW_PRODUCT_CODE_1 + i);\n\tnetif_info(efx, probe, efx->net_dev,\n\t\t   \"QT2025C firmware %xr%d v%d.%d.%d.%d [20%02d-%02d-%02d]\\n\",\n\t\t   (firmware_id[0] << 8) | firmware_id[1], firmware_id[2],\n\t\t   firmware_id[3] >> 4, firmware_id[3] & 0xf,\n\t\t   firmware_id[4], firmware_id[5],\n\t\t   firmware_id[6], firmware_id[7], firmware_id[8]);\n\tphy_data->firmware_ver = ((firmware_id[3] & 0xf0) << 20) |\n\t\t\t\t ((firmware_id[3] & 0x0f) << 16) |\n\t\t\t\t (firmware_id[4] << 8) | firmware_id[5];\n}\n\nstatic void qt2025c_bug17190_workaround(struct ef4_nic *efx)\n{\n\tstruct qt202x_phy_data *phy_data = efx->phy_data;\n\n\t \n\tif (efx->link_state.up ||\n\t    !ef4_mdio_links_ok(efx, MDIO_DEVS_PMAPMD | MDIO_DEVS_PHYXS)) {\n\t\tphy_data->bug17190_in_bad_state = false;\n\t\treturn;\n\t}\n\n\tif (!phy_data->bug17190_in_bad_state) {\n\t\tphy_data->bug17190_in_bad_state = true;\n\t\tphy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;\n\t\treturn;\n\t}\n\n\tif (time_after_eq(jiffies, phy_data->bug17190_timer)) {\n\t\tnetif_dbg(efx, hw, efx->net_dev, \"bashing QT2025C PMA/PMD\\n\");\n\t\tef4_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,\n\t\t\t\t  MDIO_PMA_CTRL1_LOOPBACK, true);\n\t\tmsleep(100);\n\t\tef4_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,\n\t\t\t\t  MDIO_PMA_CTRL1_LOOPBACK, false);\n\t\tphy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;\n\t}\n}\n\nstatic int qt2025c_select_phy_mode(struct ef4_nic *efx)\n{\n\tstruct qt202x_phy_data *phy_data = efx->phy_data;\n\tstruct falcon_board *board = falcon_board(efx);\n\tint reg, rc, i;\n\tuint16_t phy_op_mode;\n\n\t \n\tif (phy_data->firmware_ver < 0x02000100)\n\t\treturn 0;\n\n\t \n\tphy_op_mode = (efx->loopback_mode == LOOPBACK_NONE) ? 0x0038 : 0x0020;\n\n\t \n\treg = ef4_mdio_read(efx, 1, 0xc319);\n\tif ((reg & 0x0038) == phy_op_mode)\n\t\treturn 0;\n\tnetif_dbg(efx, hw, efx->net_dev, \"Switching PHY to mode 0x%04x\\n\",\n\t\t  phy_op_mode);\n\n\t \n\tef4_mdio_write(efx, 1, 0xc300, 0x0000);\n\t \n\tif (board->major == 0 && board->minor < 2) {\n\t\tef4_mdio_write(efx, 1, 0xc303, 0x4498);\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tef4_mdio_write(efx, 1, 0xc303, 0x4488);\n\t\t\tef4_mdio_write(efx, 1, 0xc303, 0x4480);\n\t\t\tef4_mdio_write(efx, 1, 0xc303, 0x4490);\n\t\t\tef4_mdio_write(efx, 1, 0xc303, 0x4498);\n\t\t}\n\t} else {\n\t\tef4_mdio_write(efx, 1, 0xc303, 0x0920);\n\t\tef4_mdio_write(efx, 1, 0xd008, 0x0004);\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tef4_mdio_write(efx, 1, 0xc303, 0x0900);\n\t\t\tef4_mdio_write(efx, 1, 0xd008, 0x0005);\n\t\t\tef4_mdio_write(efx, 1, 0xc303, 0x0920);\n\t\t\tef4_mdio_write(efx, 1, 0xd008, 0x0004);\n\t\t}\n\t\tef4_mdio_write(efx, 1, 0xc303, 0x4900);\n\t}\n\tef4_mdio_write(efx, 1, 0xc303, 0x4900);\n\tef4_mdio_write(efx, 1, 0xc302, 0x0004);\n\tef4_mdio_write(efx, 1, 0xc316, 0x0013);\n\tef4_mdio_write(efx, 1, 0xc318, 0x0054);\n\tef4_mdio_write(efx, 1, 0xc319, phy_op_mode);\n\tef4_mdio_write(efx, 1, 0xc31a, 0x0098);\n\tef4_mdio_write(efx, 3, 0x0026, 0x0e00);\n\tef4_mdio_write(efx, 3, 0x0027, 0x0013);\n\tef4_mdio_write(efx, 3, 0x0028, 0xa528);\n\tef4_mdio_write(efx, 1, 0xd006, 0x000a);\n\tef4_mdio_write(efx, 1, 0xd007, 0x0009);\n\tef4_mdio_write(efx, 1, 0xd008, 0x0004);\n\t \n\tef4_mdio_write(efx, 1, 0xc317, 0x00ff);\n\t \n\tef4_mdio_set_flag(efx, 1, PMA_PMD_MODE_REG,\n\t\t\t  1 << PMA_PMD_RXIN_SEL_LBN, false);\n\tef4_mdio_write(efx, 1, 0xc300, 0x0002);\n\tmsleep(20);\n\n\t \n\tqt2025c_restart_firmware(efx);\n\n\t \n\trc = qt2025c_wait_reset(efx);\n\tif (rc < 0) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"PHY microcontroller reset during mode switch \"\n\t\t\t  \"timed out\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int qt202x_reset_phy(struct ef4_nic *efx)\n{\n\tint rc;\n\n\tif (efx->phy_type == PHY_TYPE_QT2025C) {\n\t\t \n\t\trc = qt2025c_wait_reset(efx);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\t \n\t\trc = ef4_mdio_reset_mmd(efx, MDIO_MMD_PHYXS,\n\t\t\t\t\tQT2022C2_MAX_RESET_TIME /\n\t\t\t\t\tQT2022C2_RESET_WAIT,\n\t\t\t\t\tQT2022C2_RESET_WAIT);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tmsleep(250);\n\n\tfalcon_board(efx)->type->init_phy(efx);\n\n\treturn 0;\n\n fail:\n\tnetif_err(efx, hw, efx->net_dev, \"PHY reset timed out\\n\");\n\treturn rc;\n}\n\nstatic int qt202x_phy_probe(struct ef4_nic *efx)\n{\n\tstruct qt202x_phy_data *phy_data;\n\n\tphy_data = kzalloc(sizeof(struct qt202x_phy_data), GFP_KERNEL);\n\tif (!phy_data)\n\t\treturn -ENOMEM;\n\tefx->phy_data = phy_data;\n\tphy_data->phy_mode = efx->phy_mode;\n\tphy_data->bug17190_in_bad_state = false;\n\tphy_data->bug17190_timer = 0;\n\n\tefx->mdio.mmds = QT202X_REQUIRED_DEVS;\n\tefx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\n\tefx->loopback_modes = QT202X_LOOPBACKS | FALCON_XMAC_LOOPBACKS;\n\treturn 0;\n}\n\nstatic int qt202x_phy_init(struct ef4_nic *efx)\n{\n\tu32 devid;\n\tint rc;\n\n\trc = qt202x_reset_phy(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"PHY init failed\\n\");\n\t\treturn rc;\n\t}\n\n\tdevid = ef4_mdio_read_id(efx, MDIO_MMD_PHYXS);\n\tnetif_info(efx, probe, efx->net_dev,\n\t\t   \"PHY ID reg %x (OUI %06x model %02x revision %x)\\n\",\n\t\t   devid, ef4_mdio_id_oui(devid), ef4_mdio_id_model(devid),\n\t\t   ef4_mdio_id_rev(devid));\n\n\tif (efx->phy_type == PHY_TYPE_QT2025C)\n\t\tqt2025c_firmware_id(efx);\n\n\treturn 0;\n}\n\nstatic int qt202x_link_ok(struct ef4_nic *efx)\n{\n\treturn ef4_mdio_links_ok(efx, QT202X_REQUIRED_DEVS);\n}\n\nstatic bool qt202x_phy_poll(struct ef4_nic *efx)\n{\n\tbool was_up = efx->link_state.up;\n\n\tefx->link_state.up = qt202x_link_ok(efx);\n\tefx->link_state.speed = 10000;\n\tefx->link_state.fd = true;\n\tefx->link_state.fc = efx->wanted_fc;\n\n\tif (efx->phy_type == PHY_TYPE_QT2025C)\n\t\tqt2025c_bug17190_workaround(efx);\n\n\treturn efx->link_state.up != was_up;\n}\n\nstatic int qt202x_phy_reconfigure(struct ef4_nic *efx)\n{\n\tstruct qt202x_phy_data *phy_data = efx->phy_data;\n\n\tif (efx->phy_type == PHY_TYPE_QT2025C) {\n\t\tint rc = qt2025c_select_phy_mode(efx);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tmdio_set_flag(\n\t\t\t&efx->mdio, efx->mdio.prtad, MDIO_MMD_PMAPMD,\n\t\t\tPMA_PMD_FTX_CTRL2_REG, 1 << PMA_PMD_FTX_STATIC_LBN,\n\t\t\tefx->phy_mode & PHY_MODE_TX_DISABLED ||\n\t\t\tefx->phy_mode & PHY_MODE_LOW_POWER ||\n\t\t\tefx->loopback_mode == LOOPBACK_PCS ||\n\t\t\tefx->loopback_mode == LOOPBACK_PMAPMD);\n\t} else {\n\t\t \n\t\tif (!(efx->phy_mode & PHY_MODE_TX_DISABLED) &&\n\t\t    (phy_data->phy_mode & PHY_MODE_TX_DISABLED))\n\t\t\tqt202x_reset_phy(efx);\n\n\t\tef4_mdio_transmit_disable(efx);\n\t}\n\n\tef4_mdio_phy_reconfigure(efx);\n\n\tphy_data->phy_mode = efx->phy_mode;\n\n\treturn 0;\n}\n\nstatic void qt202x_phy_get_link_ksettings(struct ef4_nic *efx,\n\t\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tmdio45_ethtool_ksettings_get(&efx->mdio, cmd);\n}\n\nstatic void qt202x_phy_remove(struct ef4_nic *efx)\n{\n\t \n\tkfree(efx->phy_data);\n\tefx->phy_data = NULL;\n}\n\nstatic int qt202x_phy_get_module_info(struct ef4_nic *efx,\n\t\t\t\t      struct ethtool_modinfo *modinfo)\n{\n\tmodinfo->type = ETH_MODULE_SFF_8079;\n\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\treturn 0;\n}\n\nstatic int qt202x_phy_get_module_eeprom(struct ef4_nic *efx,\n\t\t\t\t\tstruct ethtool_eeprom *ee, u8 *data)\n{\n\tint mmd, reg_base, rc, i;\n\n\tif (efx->phy_type == PHY_TYPE_QT2025C) {\n\t\tmmd = MDIO_MMD_PCS;\n\t\treg_base = 0xd000;\n\t} else {\n\t\tmmd = MDIO_MMD_PMAPMD;\n\t\treg_base = 0x8007;\n\t}\n\n\tfor (i = 0; i < ee->len; i++) {\n\t\trc = ef4_mdio_read(efx, mmd, reg_base + ee->offset + i);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tdata[i] = rc;\n\t}\n\n\treturn 0;\n}\n\nconst struct ef4_phy_operations falcon_qt202x_phy_ops = {\n\t.probe\t\t = qt202x_phy_probe,\n\t.init\t\t = qt202x_phy_init,\n\t.reconfigure\t = qt202x_phy_reconfigure,\n\t.poll\t\t = qt202x_phy_poll,\n\t.fini\t\t = ef4_port_dummy_op_void,\n\t.remove\t\t = qt202x_phy_remove,\n\t.get_link_ksettings = qt202x_phy_get_link_ksettings,\n\t.set_link_ksettings = ef4_mdio_set_link_ksettings,\n\t.test_alive\t = ef4_mdio_test_alive,\n\t.get_module_eeprom = qt202x_phy_get_module_eeprom,\n\t.get_module_info = qt202x_phy_get_module_info,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}