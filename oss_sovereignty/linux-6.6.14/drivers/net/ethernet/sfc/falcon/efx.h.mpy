{
  "module_name": "efx.h",
  "hash_id": "d9de049bf053dff9f1543aecf047e44aff8590d71dbba2d77b13e99647056a3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/efx.h",
  "human_readable_source": " \n \n\n#ifndef EF4_EFX_H\n#define EF4_EFX_H\n\n#include \"net_driver.h\"\n#include \"filter.h\"\n\n \n \n#define EF4_MEM_BAR 2\n#define EF4_MEM_VF_BAR 0\n\nint ef4_net_open(struct net_device *net_dev);\nint ef4_net_stop(struct net_device *net_dev);\n\n \nint ef4_probe_tx_queue(struct ef4_tx_queue *tx_queue);\nvoid ef4_remove_tx_queue(struct ef4_tx_queue *tx_queue);\nvoid ef4_init_tx_queue(struct ef4_tx_queue *tx_queue);\nvoid ef4_init_tx_queue_core_txq(struct ef4_tx_queue *tx_queue);\nvoid ef4_fini_tx_queue(struct ef4_tx_queue *tx_queue);\nnetdev_tx_t ef4_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\tstruct net_device *net_dev);\nnetdev_tx_t ef4_enqueue_skb(struct ef4_tx_queue *tx_queue, struct sk_buff *skb);\nvoid ef4_xmit_done(struct ef4_tx_queue *tx_queue, unsigned int index);\nint ef4_setup_tc(struct net_device *net_dev, enum tc_setup_type type,\n\t\t void *type_data);\nunsigned int ef4_tx_max_skb_descs(struct ef4_nic *efx);\nextern bool ef4_separate_tx_channels;\n\n \nvoid ef4_set_default_rx_indir_table(struct ef4_nic *efx);\nvoid ef4_rx_config_page_split(struct ef4_nic *efx);\nint ef4_probe_rx_queue(struct ef4_rx_queue *rx_queue);\nvoid ef4_remove_rx_queue(struct ef4_rx_queue *rx_queue);\nvoid ef4_init_rx_queue(struct ef4_rx_queue *rx_queue);\nvoid ef4_fini_rx_queue(struct ef4_rx_queue *rx_queue);\nvoid ef4_fast_push_rx_descriptors(struct ef4_rx_queue *rx_queue, bool atomic);\nvoid ef4_rx_slow_fill(struct timer_list *t);\nvoid __ef4_rx_packet(struct ef4_channel *channel);\nvoid ef4_rx_packet(struct ef4_rx_queue *rx_queue, unsigned int index,\n\t\t   unsigned int n_frags, unsigned int len, u16 flags);\nstatic inline void ef4_rx_flush_packet(struct ef4_channel *channel)\n{\n\tif (channel->rx_pkt_n_frags)\n\t\t__ef4_rx_packet(channel);\n}\nvoid ef4_schedule_slow_fill(struct ef4_rx_queue *rx_queue);\n\n#define EF4_MAX_DMAQ_SIZE 4096UL\n#define EF4_DEFAULT_DMAQ_SIZE 1024UL\n#define EF4_MIN_DMAQ_SIZE 512UL\n\n#define EF4_MAX_EVQ_SIZE 16384UL\n#define EF4_MIN_EVQ_SIZE 512UL\n\n \n#define EF4_TSO_MAX_SEGS\t100\n\n \n#define EF4_RXQ_MIN_ENT\t\t128U\n#define EF4_TXQ_MIN_ENT(efx)\t(2 * ef4_tx_max_skb_descs(efx))\n\nstatic inline bool ef4_rss_enabled(struct ef4_nic *efx)\n{\n\treturn efx->rss_spread > 1;\n}\n\n \n\nvoid ef4_mac_reconfigure(struct ef4_nic *efx);\n\n \nstatic inline s32 ef4_filter_insert_filter(struct ef4_nic *efx,\n\t\t\t\t\t   struct ef4_filter_spec *spec,\n\t\t\t\t\t   bool replace_equal)\n{\n\treturn efx->type->filter_insert(efx, spec, replace_equal);\n}\n\n \nstatic inline int ef4_filter_remove_id_safe(struct ef4_nic *efx,\n\t\t\t\t\t    enum ef4_filter_priority priority,\n\t\t\t\t\t    u32 filter_id)\n{\n\treturn efx->type->filter_remove_safe(efx, priority, filter_id);\n}\n\n \nstatic inline int\nef4_filter_get_filter_safe(struct ef4_nic *efx,\n\t\t\t   enum ef4_filter_priority priority,\n\t\t\t   u32 filter_id, struct ef4_filter_spec *spec)\n{\n\treturn efx->type->filter_get_safe(efx, priority, filter_id, spec);\n}\n\nstatic inline u32 ef4_filter_count_rx_used(struct ef4_nic *efx,\n\t\t\t\t\t   enum ef4_filter_priority priority)\n{\n\treturn efx->type->filter_count_rx_used(efx, priority);\n}\nstatic inline u32 ef4_filter_get_rx_id_limit(struct ef4_nic *efx)\n{\n\treturn efx->type->filter_get_rx_id_limit(efx);\n}\nstatic inline s32 ef4_filter_get_rx_ids(struct ef4_nic *efx,\n\t\t\t\t\tenum ef4_filter_priority priority,\n\t\t\t\t\tu32 *buf, u32 size)\n{\n\treturn efx->type->filter_get_rx_ids(efx, priority, buf, size);\n}\n#ifdef CONFIG_RFS_ACCEL\nint ef4_filter_rfs(struct net_device *net_dev, const struct sk_buff *skb,\n\t\t   u16 rxq_index, u32 flow_id);\nbool __ef4_filter_rfs_expire(struct ef4_nic *efx, unsigned quota);\nstatic inline void ef4_filter_rfs_expire(struct ef4_channel *channel)\n{\n\tif (channel->rfs_filters_added >= 60 &&\n\t    __ef4_filter_rfs_expire(channel->efx, 100))\n\t\tchannel->rfs_filters_added -= 60;\n}\n#define ef4_filter_rfs_enabled() 1\n#else\nstatic inline void ef4_filter_rfs_expire(struct ef4_channel *channel) {}\n#define ef4_filter_rfs_enabled() 0\n#endif\nbool ef4_filter_is_mc_recipient(const struct ef4_filter_spec *spec);\n\n \nint ef4_channel_dummy_op_int(struct ef4_channel *channel);\nvoid ef4_channel_dummy_op_void(struct ef4_channel *channel);\nint ef4_realloc_channels(struct ef4_nic *efx, u32 rxq_entries, u32 txq_entries);\n\n \nint ef4_reconfigure_port(struct ef4_nic *efx);\nint __ef4_reconfigure_port(struct ef4_nic *efx);\n\n \nextern const struct ethtool_ops ef4_ethtool_ops;\n\n \nint ef4_reset(struct ef4_nic *efx, enum reset_type method);\nvoid ef4_reset_down(struct ef4_nic *efx, enum reset_type method);\nint ef4_reset_up(struct ef4_nic *efx, enum reset_type method, bool ok);\nint ef4_try_recovery(struct ef4_nic *efx);\n\n \nvoid ef4_schedule_reset(struct ef4_nic *efx, enum reset_type type);\nunsigned int ef4_usecs_to_ticks(struct ef4_nic *efx, unsigned int usecs);\nunsigned int ef4_ticks_to_usecs(struct ef4_nic *efx, unsigned int ticks);\nint ef4_init_irq_moderation(struct ef4_nic *efx, unsigned int tx_usecs,\n\t\t\t    unsigned int rx_usecs, bool rx_adaptive,\n\t\t\t    bool rx_may_override_tx);\nvoid ef4_get_irq_moderation(struct ef4_nic *efx, unsigned int *tx_usecs,\n\t\t\t    unsigned int *rx_usecs, bool *rx_adaptive);\nvoid ef4_stop_eventq(struct ef4_channel *channel);\nvoid ef4_start_eventq(struct ef4_channel *channel);\n\n \nint ef4_port_dummy_op_int(struct ef4_nic *efx);\nvoid ef4_port_dummy_op_void(struct ef4_nic *efx);\n\n \nvoid ef4_update_sw_stats(struct ef4_nic *efx, u64 *stats);\n\n \n#ifdef CONFIG_SFC_FALCON_MTD\nint ef4_mtd_add(struct ef4_nic *efx, struct ef4_mtd_partition *parts,\n\t\tsize_t n_parts, size_t sizeof_part);\nstatic inline int ef4_mtd_probe(struct ef4_nic *efx)\n{\n\treturn efx->type->mtd_probe(efx);\n}\nvoid ef4_mtd_rename(struct ef4_nic *efx);\nvoid ef4_mtd_remove(struct ef4_nic *efx);\n#else\nstatic inline int ef4_mtd_probe(struct ef4_nic *efx) { return 0; }\nstatic inline void ef4_mtd_rename(struct ef4_nic *efx) {}\nstatic inline void ef4_mtd_remove(struct ef4_nic *efx) {}\n#endif\n\nstatic inline void ef4_schedule_channel(struct ef4_channel *channel)\n{\n\tnetif_vdbg(channel->efx, intr, channel->efx->net_dev,\n\t\t   \"channel %d scheduling NAPI poll on CPU%d\\n\",\n\t\t   channel->channel, raw_smp_processor_id());\n\n\tnapi_schedule(&channel->napi_str);\n}\n\nstatic inline void ef4_schedule_channel_irq(struct ef4_channel *channel)\n{\n\tchannel->event_test_cpu = raw_smp_processor_id();\n\tef4_schedule_channel(channel);\n}\n\nvoid ef4_link_status_changed(struct ef4_nic *efx);\nvoid ef4_link_set_advertising(struct ef4_nic *efx, u32);\nvoid ef4_link_set_wanted_fc(struct ef4_nic *efx, u8);\n\nstatic inline void ef4_device_detach_sync(struct ef4_nic *efx)\n{\n\tstruct net_device *dev = efx->net_dev;\n\n\t \n\tnetif_tx_lock_bh(dev);\n\tnetif_device_detach(dev);\n\tnetif_tx_unlock_bh(dev);\n}\n\nstatic inline bool ef4_rwsem_assert_write_locked(struct rw_semaphore *sem)\n{\n\tif (WARN_ON(down_read_trylock(sem))) {\n\t\tup_read(sem);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}