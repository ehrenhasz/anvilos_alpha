{
  "module_name": "nic.h",
  "hash_id": "6fb11cc82d3deea761c4c7fdbc0cba5301f3eef1fdc4934a1e4533de4109654e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/nic.h",
  "human_readable_source": " \n \n\n#ifndef EF4_NIC_H\n#define EF4_NIC_H\n\n#include <linux/net_tstamp.h>\n#include <linux/i2c-algo-bit.h>\n#include \"net_driver.h\"\n#include \"efx.h\"\n\nenum {\n\tEF4_REV_FALCON_A0 = 0,\n\tEF4_REV_FALCON_A1 = 1,\n\tEF4_REV_FALCON_B0 = 2,\n};\n\nstatic inline int ef4_nic_rev(struct ef4_nic *efx)\n{\n\treturn efx->type->revision;\n}\n\nu32 ef4_farch_fpga_ver(struct ef4_nic *efx);\n\n \nstatic inline bool ef4_nic_is_dual_func(struct ef4_nic *efx)\n{\n\treturn ef4_nic_rev(efx) < EF4_REV_FALCON_B0;\n}\n\n \nstatic inline ef4_qword_t *ef4_event(struct ef4_channel *channel,\n\t\t\t\t     unsigned int index)\n{\n\treturn ((ef4_qword_t *) (channel->eventq.buf.addr)) +\n\t\t(index & channel->eventq_mask);\n}\n\n \nstatic inline int ef4_event_present(ef4_qword_t *event)\n{\n\treturn !(EF4_DWORD_IS_ALL_ONES(event->dword[0]) |\n\t\t  EF4_DWORD_IS_ALL_ONES(event->dword[1]));\n}\n\n \nstatic inline ef4_qword_t *\nef4_tx_desc(struct ef4_tx_queue *tx_queue, unsigned int index)\n{\n\treturn ((ef4_qword_t *) (tx_queue->txd.buf.addr)) + index;\n}\n\n \nstatic inline struct ef4_tx_queue *ef4_tx_queue_partner(struct ef4_tx_queue *tx_queue)\n{\n\tif (tx_queue->queue & EF4_TXQ_TYPE_OFFLOAD)\n\t\treturn tx_queue - EF4_TXQ_TYPE_OFFLOAD;\n\telse\n\t\treturn tx_queue + EF4_TXQ_TYPE_OFFLOAD;\n}\n\n \nstatic inline bool __ef4_nic_tx_is_empty(struct ef4_tx_queue *tx_queue,\n\t\t\t\t\t unsigned int write_count)\n{\n\tunsigned int empty_read_count = READ_ONCE(tx_queue->empty_read_count);\n\n\tif (empty_read_count == 0)\n\t\treturn false;\n\n\treturn ((empty_read_count ^ write_count) & ~EF4_EMPTY_COUNT_VALID) == 0;\n}\n\n \nstatic inline bool ef4_nic_may_push_tx_desc(struct ef4_tx_queue *tx_queue,\n\t\t\t\t\t    unsigned int write_count)\n{\n\tbool was_empty = __ef4_nic_tx_is_empty(tx_queue, write_count);\n\n\ttx_queue->empty_read_count = 0;\n\treturn was_empty && tx_queue->write_count - write_count == 1;\n}\n\n \nstatic inline ef4_qword_t *\nef4_rx_desc(struct ef4_rx_queue *rx_queue, unsigned int index)\n{\n\treturn ((ef4_qword_t *) (rx_queue->rxd.buf.addr)) + index;\n}\n\nenum {\n\tPHY_TYPE_NONE = 0,\n\tPHY_TYPE_TXC43128 = 1,\n\tPHY_TYPE_88E1111 = 2,\n\tPHY_TYPE_SFX7101 = 3,\n\tPHY_TYPE_QT2022C2 = 4,\n\tPHY_TYPE_PM8358 = 6,\n\tPHY_TYPE_SFT9001A = 8,\n\tPHY_TYPE_QT2025C = 9,\n\tPHY_TYPE_SFT9001B = 10,\n};\n\n#define FALCON_XMAC_LOOPBACKS\t\t\t\\\n\t((1 << LOOPBACK_XGMII) |\t\t\\\n\t (1 << LOOPBACK_XGXS) |\t\t\t\\\n\t (1 << LOOPBACK_XAUI))\n\n \n#define EF4_PAGE_SIZE\t4096\n \n#define EF4_BUF_SIZE\tEF4_PAGE_SIZE\n\n \nenum {\n\tGENERIC_STAT_rx_noskb_drops,\n\tGENERIC_STAT_rx_nodesc_trunc,\n\tGENERIC_STAT_COUNT\n};\n\n \nstruct falcon_board_type {\n\tu8 id;\n\tint (*init) (struct ef4_nic *nic);\n\tvoid (*init_phy) (struct ef4_nic *efx);\n\tvoid (*fini) (struct ef4_nic *nic);\n\tvoid (*set_id_led) (struct ef4_nic *efx, enum ef4_led_mode mode);\n\tint (*monitor) (struct ef4_nic *nic);\n};\n\n \nstruct falcon_board {\n\tconst struct falcon_board_type *type;\n\tint major;\n\tint minor;\n\tstruct i2c_adapter i2c_adap;\n\tstruct i2c_algo_bit_data i2c_data;\n\tstruct i2c_client *hwmon_client, *ioexp_client;\n};\n\n \nstruct falcon_spi_device {\n\tint device_id;\n\tunsigned int size;\n\tunsigned int addr_len;\n\tunsigned int munge_address:1;\n\tu8 erase_command;\n\tunsigned int erase_size;\n\tunsigned int block_size;\n};\n\nstatic inline bool falcon_spi_present(const struct falcon_spi_device *spi)\n{\n\treturn spi->size != 0;\n}\n\nenum {\n\tFALCON_STAT_tx_bytes = GENERIC_STAT_COUNT,\n\tFALCON_STAT_tx_packets,\n\tFALCON_STAT_tx_pause,\n\tFALCON_STAT_tx_control,\n\tFALCON_STAT_tx_unicast,\n\tFALCON_STAT_tx_multicast,\n\tFALCON_STAT_tx_broadcast,\n\tFALCON_STAT_tx_lt64,\n\tFALCON_STAT_tx_64,\n\tFALCON_STAT_tx_65_to_127,\n\tFALCON_STAT_tx_128_to_255,\n\tFALCON_STAT_tx_256_to_511,\n\tFALCON_STAT_tx_512_to_1023,\n\tFALCON_STAT_tx_1024_to_15xx,\n\tFALCON_STAT_tx_15xx_to_jumbo,\n\tFALCON_STAT_tx_gtjumbo,\n\tFALCON_STAT_tx_non_tcpudp,\n\tFALCON_STAT_tx_mac_src_error,\n\tFALCON_STAT_tx_ip_src_error,\n\tFALCON_STAT_rx_bytes,\n\tFALCON_STAT_rx_good_bytes,\n\tFALCON_STAT_rx_bad_bytes,\n\tFALCON_STAT_rx_packets,\n\tFALCON_STAT_rx_good,\n\tFALCON_STAT_rx_bad,\n\tFALCON_STAT_rx_pause,\n\tFALCON_STAT_rx_control,\n\tFALCON_STAT_rx_unicast,\n\tFALCON_STAT_rx_multicast,\n\tFALCON_STAT_rx_broadcast,\n\tFALCON_STAT_rx_lt64,\n\tFALCON_STAT_rx_64,\n\tFALCON_STAT_rx_65_to_127,\n\tFALCON_STAT_rx_128_to_255,\n\tFALCON_STAT_rx_256_to_511,\n\tFALCON_STAT_rx_512_to_1023,\n\tFALCON_STAT_rx_1024_to_15xx,\n\tFALCON_STAT_rx_15xx_to_jumbo,\n\tFALCON_STAT_rx_gtjumbo,\n\tFALCON_STAT_rx_bad_lt64,\n\tFALCON_STAT_rx_bad_gtjumbo,\n\tFALCON_STAT_rx_overflow,\n\tFALCON_STAT_rx_symbol_error,\n\tFALCON_STAT_rx_align_error,\n\tFALCON_STAT_rx_length_error,\n\tFALCON_STAT_rx_internal_error,\n\tFALCON_STAT_rx_nodesc_drop_cnt,\n\tFALCON_STAT_COUNT\n};\n\n \nstruct falcon_nic_data {\n\tstruct pci_dev *pci_dev2;\n\tstruct ef4_nic *efx;\n\tstruct falcon_board board;\n\tu64 stats[FALCON_STAT_COUNT];\n\tunsigned int stats_disable_count;\n\tbool stats_pending;\n\tstruct timer_list stats_timer;\n\tstruct falcon_spi_device spi_flash;\n\tstruct falcon_spi_device spi_eeprom;\n\tstruct mutex spi_lock;\n\tstruct mutex mdio_lock;\n\tbool xmac_poll_required;\n};\n\nstatic inline struct falcon_board *falcon_board(struct ef4_nic *efx)\n{\n\tstruct falcon_nic_data *data = efx->nic_data;\n\treturn &data->board;\n}\n\nstruct ethtool_ts_info;\n\nextern const struct ef4_nic_type falcon_a1_nic_type;\nextern const struct ef4_nic_type falcon_b0_nic_type;\n\n \n\nint falcon_probe_board(struct ef4_nic *efx, u16 revision_info);\n\n \nstatic inline int ef4_nic_probe_tx(struct ef4_tx_queue *tx_queue)\n{\n\treturn tx_queue->efx->type->tx_probe(tx_queue);\n}\nstatic inline void ef4_nic_init_tx(struct ef4_tx_queue *tx_queue)\n{\n\ttx_queue->efx->type->tx_init(tx_queue);\n}\nstatic inline void ef4_nic_remove_tx(struct ef4_tx_queue *tx_queue)\n{\n\ttx_queue->efx->type->tx_remove(tx_queue);\n}\nstatic inline void ef4_nic_push_buffers(struct ef4_tx_queue *tx_queue)\n{\n\ttx_queue->efx->type->tx_write(tx_queue);\n}\n\n \nstatic inline int ef4_nic_probe_rx(struct ef4_rx_queue *rx_queue)\n{\n\treturn rx_queue->efx->type->rx_probe(rx_queue);\n}\nstatic inline void ef4_nic_init_rx(struct ef4_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_init(rx_queue);\n}\nstatic inline void ef4_nic_remove_rx(struct ef4_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_remove(rx_queue);\n}\nstatic inline void ef4_nic_notify_rx_desc(struct ef4_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_write(rx_queue);\n}\nstatic inline void ef4_nic_generate_fill_event(struct ef4_rx_queue *rx_queue)\n{\n\trx_queue->efx->type->rx_defer_refill(rx_queue);\n}\n\n \nstatic inline int ef4_nic_probe_eventq(struct ef4_channel *channel)\n{\n\treturn channel->efx->type->ev_probe(channel);\n}\nstatic inline int ef4_nic_init_eventq(struct ef4_channel *channel)\n{\n\treturn channel->efx->type->ev_init(channel);\n}\nstatic inline void ef4_nic_fini_eventq(struct ef4_channel *channel)\n{\n\tchannel->efx->type->ev_fini(channel);\n}\nstatic inline void ef4_nic_remove_eventq(struct ef4_channel *channel)\n{\n\tchannel->efx->type->ev_remove(channel);\n}\nstatic inline int\nef4_nic_process_eventq(struct ef4_channel *channel, int quota)\n{\n\treturn channel->efx->type->ev_process(channel, quota);\n}\nstatic inline void ef4_nic_eventq_read_ack(struct ef4_channel *channel)\n{\n\tchannel->efx->type->ev_read_ack(channel);\n}\nvoid ef4_nic_event_test_start(struct ef4_channel *channel);\n\n \nint ef4_farch_tx_probe(struct ef4_tx_queue *tx_queue);\nvoid ef4_farch_tx_init(struct ef4_tx_queue *tx_queue);\nvoid ef4_farch_tx_fini(struct ef4_tx_queue *tx_queue);\nvoid ef4_farch_tx_remove(struct ef4_tx_queue *tx_queue);\nvoid ef4_farch_tx_write(struct ef4_tx_queue *tx_queue);\nunsigned int ef4_farch_tx_limit_len(struct ef4_tx_queue *tx_queue,\n\t\t\t\t    dma_addr_t dma_addr, unsigned int len);\nint ef4_farch_rx_probe(struct ef4_rx_queue *rx_queue);\nvoid ef4_farch_rx_init(struct ef4_rx_queue *rx_queue);\nvoid ef4_farch_rx_fini(struct ef4_rx_queue *rx_queue);\nvoid ef4_farch_rx_remove(struct ef4_rx_queue *rx_queue);\nvoid ef4_farch_rx_write(struct ef4_rx_queue *rx_queue);\nvoid ef4_farch_rx_defer_refill(struct ef4_rx_queue *rx_queue);\nint ef4_farch_ev_probe(struct ef4_channel *channel);\nint ef4_farch_ev_init(struct ef4_channel *channel);\nvoid ef4_farch_ev_fini(struct ef4_channel *channel);\nvoid ef4_farch_ev_remove(struct ef4_channel *channel);\nint ef4_farch_ev_process(struct ef4_channel *channel, int quota);\nvoid ef4_farch_ev_read_ack(struct ef4_channel *channel);\nvoid ef4_farch_ev_test_generate(struct ef4_channel *channel);\n\n \nint ef4_farch_filter_table_probe(struct ef4_nic *efx);\nvoid ef4_farch_filter_table_restore(struct ef4_nic *efx);\nvoid ef4_farch_filter_table_remove(struct ef4_nic *efx);\nvoid ef4_farch_filter_update_rx_scatter(struct ef4_nic *efx);\ns32 ef4_farch_filter_insert(struct ef4_nic *efx, struct ef4_filter_spec *spec,\n\t\t\t    bool replace);\nint ef4_farch_filter_remove_safe(struct ef4_nic *efx,\n\t\t\t\t enum ef4_filter_priority priority,\n\t\t\t\t u32 filter_id);\nint ef4_farch_filter_get_safe(struct ef4_nic *efx,\n\t\t\t      enum ef4_filter_priority priority, u32 filter_id,\n\t\t\t      struct ef4_filter_spec *);\nint ef4_farch_filter_clear_rx(struct ef4_nic *efx,\n\t\t\t      enum ef4_filter_priority priority);\nu32 ef4_farch_filter_count_rx_used(struct ef4_nic *efx,\n\t\t\t\t   enum ef4_filter_priority priority);\nu32 ef4_farch_filter_get_rx_id_limit(struct ef4_nic *efx);\ns32 ef4_farch_filter_get_rx_ids(struct ef4_nic *efx,\n\t\t\t\tenum ef4_filter_priority priority, u32 *buf,\n\t\t\t\tu32 size);\n#ifdef CONFIG_RFS_ACCEL\ns32 ef4_farch_filter_rfs_insert(struct ef4_nic *efx,\n\t\t\t\tstruct ef4_filter_spec *spec);\nbool ef4_farch_filter_rfs_expire_one(struct ef4_nic *efx, u32 flow_id,\n\t\t\t\t     unsigned int index);\n#endif\nvoid ef4_farch_filter_sync_rx_mode(struct ef4_nic *efx);\n\nbool ef4_nic_event_present(struct ef4_channel *channel);\n\n \nstatic inline void ef4_update_diff_stat(u64 *stat, u64 diff)\n{\n\tif ((s64)(diff - *stat) > 0)\n\t\t*stat = diff;\n}\n\n \nint ef4_nic_init_interrupt(struct ef4_nic *efx);\nint ef4_nic_irq_test_start(struct ef4_nic *efx);\nvoid ef4_nic_fini_interrupt(struct ef4_nic *efx);\nvoid ef4_farch_irq_enable_master(struct ef4_nic *efx);\nint ef4_farch_irq_test_generate(struct ef4_nic *efx);\nvoid ef4_farch_irq_disable_master(struct ef4_nic *efx);\nirqreturn_t ef4_farch_msi_interrupt(int irq, void *dev_id);\nirqreturn_t ef4_farch_legacy_interrupt(int irq, void *dev_id);\nirqreturn_t ef4_farch_fatal_interrupt(struct ef4_nic *efx);\n\nstatic inline int ef4_nic_event_test_irq_cpu(struct ef4_channel *channel)\n{\n\treturn READ_ONCE(channel->event_test_cpu);\n}\nstatic inline int ef4_nic_irq_test_irq_cpu(struct ef4_nic *efx)\n{\n\treturn READ_ONCE(efx->last_irq_cpu);\n}\n\n \nint ef4_nic_flush_queues(struct ef4_nic *efx);\nint ef4_farch_fini_dmaq(struct ef4_nic *efx);\nvoid ef4_farch_finish_flr(struct ef4_nic *efx);\nvoid falcon_start_nic_stats(struct ef4_nic *efx);\nvoid falcon_stop_nic_stats(struct ef4_nic *efx);\nint falcon_reset_xaui(struct ef4_nic *efx);\nvoid ef4_farch_dimension_resources(struct ef4_nic *efx, unsigned sram_lim_qw);\nvoid ef4_farch_init_common(struct ef4_nic *efx);\nvoid ef4_farch_rx_push_indir_table(struct ef4_nic *efx);\n\nint ef4_nic_alloc_buffer(struct ef4_nic *efx, struct ef4_buffer *buffer,\n\t\t\t unsigned int len, gfp_t gfp_flags);\nvoid ef4_nic_free_buffer(struct ef4_nic *efx, struct ef4_buffer *buffer);\n\n \nstruct ef4_farch_register_test {\n\tunsigned address;\n\tef4_oword_t mask;\n};\nint ef4_farch_test_registers(struct ef4_nic *efx,\n\t\t\t     const struct ef4_farch_register_test *regs,\n\t\t\t     size_t n_regs);\n\nsize_t ef4_nic_get_regs_len(struct ef4_nic *efx);\nvoid ef4_nic_get_regs(struct ef4_nic *efx, void *buf);\n\nsize_t ef4_nic_describe_stats(const struct ef4_hw_stat_desc *desc, size_t count,\n\t\t\t      const unsigned long *mask, u8 *names);\nvoid ef4_nic_update_stats(const struct ef4_hw_stat_desc *desc, size_t count,\n\t\t\t  const unsigned long *mask, u64 *stats,\n\t\t\t  const void *dma_buf, bool accumulate);\nvoid ef4_nic_fix_nodesc_drop_stat(struct ef4_nic *efx, u64 *stat);\n\n#define EF4_MAX_FLUSH_TIME 5000\n\nvoid ef4_farch_generate_event(struct ef4_nic *efx, unsigned int evq,\n\t\t\t      ef4_qword_t *event);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}