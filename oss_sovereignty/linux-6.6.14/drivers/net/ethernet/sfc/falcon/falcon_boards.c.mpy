{
  "module_name": "falcon_boards.c",
  "hash_id": "5fd348431f0d7d3bff255f035053b5635aefccbb72f8064f6f8541e4576404a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/falcon/falcon_boards.c",
  "human_readable_source": "\n \n\n#include <linux/rtnetlink.h>\n\n#include \"net_driver.h\"\n#include \"phy.h\"\n#include \"efx.h\"\n#include \"nic.h\"\n#include \"workarounds.h\"\n\n \n \n#define FALCON_BOARD_TYPE(_rev) (_rev >> 8)\n#define FALCON_BOARD_MAJOR(_rev) ((_rev >> 4) & 0xf)\n#define FALCON_BOARD_MINOR(_rev) (_rev & 0xf)\n\n \n#define FALCON_BOARD_SFE4001 0x01\n#define FALCON_BOARD_SFE4002 0x02\n#define FALCON_BOARD_SFE4003 0x03\n#define FALCON_BOARD_SFN4112F 0x52\n\n \n#define FALCON_BOARD_TEMP_BIAS\t15\n#define FALCON_BOARD_TEMP_CRIT\t(80 + FALCON_BOARD_TEMP_BIAS)\n\n \n#define FALCON_JUNC_TEMP_MIN\t0\n#define FALCON_JUNC_TEMP_MAX\t90\n#define FALCON_JUNC_TEMP_CRIT\t125\n\n \n#define LM87_REG_TEMP_HW_INT_LOCK\t0x13\n#define LM87_REG_TEMP_HW_EXT_LOCK\t0x14\n#define LM87_REG_TEMP_HW_INT\t\t0x17\n#define LM87_REG_TEMP_HW_EXT\t\t0x18\n#define LM87_REG_TEMP_EXT1\t\t0x26\n#define LM87_REG_TEMP_INT\t\t0x27\n#define LM87_REG_ALARMS1\t\t0x41\n#define LM87_REG_ALARMS2\t\t0x42\n#define LM87_IN_LIMITS(nr, _min, _max)\t\t\t\\\n\t0x2B + (nr) * 2, _max, 0x2C + (nr) * 2, _min\n#define LM87_AIN_LIMITS(nr, _min, _max)\t\t\t\\\n\t0x3B + (nr), _max, 0x1A + (nr), _min\n#define LM87_TEMP_INT_LIMITS(_min, _max)\t\t\\\n\t0x39, _max, 0x3A, _min\n#define LM87_TEMP_EXT1_LIMITS(_min, _max)\t\t\\\n\t0x37, _max, 0x38, _min\n\n#define LM87_ALARM_TEMP_INT\t\t0x10\n#define LM87_ALARM_TEMP_EXT1\t\t0x20\n\n#if IS_ENABLED(CONFIG_SENSORS_LM87)\n\nstatic int ef4_poke_lm87(struct i2c_client *client, const u8 *reg_values)\n{\n\twhile (*reg_values) {\n\t\tu8 reg = *reg_values++;\n\t\tu8 value = *reg_values++;\n\t\tint rc = i2c_smbus_write_byte_data(client, reg, value);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic const u8 falcon_lm87_common_regs[] = {\n\tLM87_REG_TEMP_HW_INT_LOCK, FALCON_BOARD_TEMP_CRIT,\n\tLM87_REG_TEMP_HW_INT, FALCON_BOARD_TEMP_CRIT,\n\tLM87_TEMP_EXT1_LIMITS(FALCON_JUNC_TEMP_MIN, FALCON_JUNC_TEMP_MAX),\n\tLM87_REG_TEMP_HW_EXT_LOCK, FALCON_JUNC_TEMP_CRIT,\n\tLM87_REG_TEMP_HW_EXT, FALCON_JUNC_TEMP_CRIT,\n\t0\n};\n\nstatic int ef4_init_lm87(struct ef4_nic *efx, const struct i2c_board_info *info,\n\t\t\t const u8 *reg_values)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\tstruct i2c_client *client = i2c_new_client_device(&board->i2c_adap, info);\n\tint rc;\n\n\tif (IS_ERR(client))\n\t\treturn PTR_ERR(client);\n\n\t \n\ti2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);\n\ti2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);\n\n\trc = ef4_poke_lm87(client, reg_values);\n\tif (rc)\n\t\tgoto err;\n\trc = ef4_poke_lm87(client, falcon_lm87_common_regs);\n\tif (rc)\n\t\tgoto err;\n\n\tboard->hwmon_client = client;\n\treturn 0;\n\nerr:\n\ti2c_unregister_device(client);\n\treturn rc;\n}\n\nstatic void ef4_fini_lm87(struct ef4_nic *efx)\n{\n\ti2c_unregister_device(falcon_board(efx)->hwmon_client);\n}\n\nstatic int ef4_check_lm87(struct ef4_nic *efx, unsigned mask)\n{\n\tstruct i2c_client *client = falcon_board(efx)->hwmon_client;\n\tbool temp_crit, elec_fault, is_failure;\n\tu16 alarms;\n\ts32 reg;\n\n\t \n\tif (EF4_WORKAROUND_7884(efx) && efx->link_state.up)\n\t\treturn 0;\n\n\treg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);\n\tif (reg < 0)\n\t\treturn reg;\n\talarms = reg;\n\treg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);\n\tif (reg < 0)\n\t\treturn reg;\n\talarms |= reg << 8;\n\talarms &= mask;\n\n\ttemp_crit = false;\n\tif (alarms & LM87_ALARM_TEMP_INT) {\n\t\treg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_INT);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\t\tif (reg > FALCON_BOARD_TEMP_CRIT)\n\t\t\ttemp_crit = true;\n\t}\n\tif (alarms & LM87_ALARM_TEMP_EXT1) {\n\t\treg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_EXT1);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\t\tif (reg > FALCON_JUNC_TEMP_CRIT)\n\t\t\ttemp_crit = true;\n\t}\n\telec_fault = alarms & ~(LM87_ALARM_TEMP_INT | LM87_ALARM_TEMP_EXT1);\n\tis_failure = temp_crit || elec_fault;\n\n\tif (alarms)\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"LM87 detected a hardware %s (status %02x:%02x)\"\n\t\t\t  \"%s%s%s%s\\n\",\n\t\t\t  is_failure ? \"failure\" : \"problem\",\n\t\t\t  alarms & 0xff, alarms >> 8,\n\t\t\t  (alarms & LM87_ALARM_TEMP_INT) ?\n\t\t\t  \"; board is overheating\" : \"\",\n\t\t\t  (alarms & LM87_ALARM_TEMP_EXT1) ?\n\t\t\t  \"; controller is overheating\" : \"\",\n\t\t\t  temp_crit ? \"; reached critical temperature\" : \"\",\n\t\t\t  elec_fault ? \"; electrical fault\" : \"\");\n\n\treturn is_failure ? -ERANGE : 0;\n}\n\n#else  \n\nstatic inline int\nef4_init_lm87(struct ef4_nic *efx, const struct i2c_board_info *info,\n\t      const u8 *reg_values)\n{\n\treturn 0;\n}\nstatic inline void ef4_fini_lm87(struct ef4_nic *efx)\n{\n}\nstatic inline int ef4_check_lm87(struct ef4_nic *efx, unsigned mask)\n{\n\treturn 0;\n}\n\n#endif  \n\n \n\n \n#define\tPCA9539 0x74\n\n#define\tP0_IN 0x00\n#define\tP0_OUT 0x02\n#define\tP0_INVERT 0x04\n#define\tP0_CONFIG 0x06\n\n#define\tP0_EN_1V0X_LBN 0\n#define\tP0_EN_1V0X_WIDTH 1\n#define\tP0_EN_1V2_LBN 1\n#define\tP0_EN_1V2_WIDTH 1\n#define\tP0_EN_2V5_LBN 2\n#define\tP0_EN_2V5_WIDTH 1\n#define\tP0_EN_3V3X_LBN 3\n#define\tP0_EN_3V3X_WIDTH 1\n#define\tP0_EN_5V_LBN 4\n#define\tP0_EN_5V_WIDTH 1\n#define\tP0_SHORTEN_JTAG_LBN 5\n#define\tP0_SHORTEN_JTAG_WIDTH 1\n#define\tP0_X_TRST_LBN 6\n#define\tP0_X_TRST_WIDTH 1\n#define\tP0_DSP_RESET_LBN 7\n#define\tP0_DSP_RESET_WIDTH 1\n\n#define\tP1_IN 0x01\n#define\tP1_OUT 0x03\n#define\tP1_INVERT 0x05\n#define\tP1_CONFIG 0x07\n\n#define\tP1_AFE_PWD_LBN 0\n#define\tP1_AFE_PWD_WIDTH 1\n#define\tP1_DSP_PWD25_LBN 1\n#define\tP1_DSP_PWD25_WIDTH 1\n#define\tP1_RESERVED_LBN 2\n#define\tP1_RESERVED_WIDTH 2\n#define\tP1_SPARE_LBN 4\n#define\tP1_SPARE_WIDTH 4\n\n \n#define MAX664X_REG_RSL\t\t0x02\n#define MAX664X_REG_WLHO\t0x0B\n\nstatic void sfe4001_poweroff(struct ef4_nic *efx)\n{\n\tstruct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;\n\tstruct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;\n\n\t \n\ti2c_smbus_write_byte_data(ioexp_client, P0_OUT, 0xff);\n\ti2c_smbus_write_byte_data(ioexp_client, P1_CONFIG, 0xff);\n\ti2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0xff);\n\n\t \n\ti2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);\n}\n\nstatic int sfe4001_poweron(struct ef4_nic *efx)\n{\n\tstruct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;\n\tstruct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;\n\tunsigned int i, j;\n\tint rc;\n\tu8 out;\n\n\t \n\trc = i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0x00);\n\tif (rc)\n\t\treturn rc;\n\trc = i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG,\n\t\t\t\t       0xff & ~(1 << P1_SPARE_LBN));\n\tif (rc)\n\t\tgoto fail_on;\n\n\t \n\trc = i2c_smbus_read_byte_data(ioexp_client, P0_OUT);\n\tif (rc < 0)\n\t\tgoto fail_on;\n\tout = 0xff & ~((0 << P0_EN_1V2_LBN) | (0 << P0_EN_2V5_LBN) |\n\t\t       (0 << P0_EN_3V3X_LBN) | (0 << P0_EN_5V_LBN) |\n\t\t       (0 << P0_EN_1V0X_LBN));\n\tif (rc != out) {\n\t\tnetif_info(efx, hw, efx->net_dev, \"power-cycling PHY\\n\");\n\t\trc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);\n\t\tif (rc)\n\t\t\tgoto fail_on;\n\t\tschedule_timeout_uninterruptible(HZ);\n\t}\n\n\tfor (i = 0; i < 20; ++i) {\n\t\t \n\t\tout = 0xff & ~((1 << P0_EN_1V2_LBN) | (1 << P0_EN_2V5_LBN) |\n\t\t\t       (1 << P0_EN_3V3X_LBN) | (1 << P0_EN_5V_LBN) |\n\t\t\t       (1 << P0_X_TRST_LBN));\n\t\tif (efx->phy_mode & PHY_MODE_SPECIAL)\n\t\t\tout |= 1 << P0_EN_3V3X_LBN;\n\n\t\trc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);\n\t\tif (rc)\n\t\t\tgoto fail_on;\n\t\tmsleep(10);\n\n\t\t \n\t\tout &= ~(1 << P0_EN_1V0X_LBN);\n\t\trc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);\n\t\tif (rc)\n\t\t\tgoto fail_on;\n\n\t\tnetif_info(efx, hw, efx->net_dev,\n\t\t\t   \"waiting for DSP boot (attempt %d)...\\n\", i);\n\n\t\t \n\t\tif (efx->phy_mode & PHY_MODE_SPECIAL) {\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (j = 0; j < 10; ++j) {\n\t\t\tmsleep(100);\n\n\t\t\t \n\t\t\trc = i2c_smbus_read_byte_data(ioexp_client, P1_IN);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto fail_on;\n\t\t\tif (rc & (1 << P1_AFE_PWD_LBN))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnetif_info(efx, hw, efx->net_dev, \"timed out waiting for DSP boot\\n\");\n\trc = -ETIMEDOUT;\nfail_on:\n\tsfe4001_poweroff(efx);\n\treturn rc;\n}\n\nstatic ssize_t phy_flash_cfg_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ef4_nic *efx = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", !!(efx->phy_mode & PHY_MODE_SPECIAL));\n}\n\nstatic ssize_t phy_flash_cfg_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct ef4_nic *efx = dev_get_drvdata(dev);\n\tenum ef4_phy_mode old_mode, new_mode;\n\tint err;\n\n\trtnl_lock();\n\told_mode = efx->phy_mode;\n\tif (count == 0 || *buf == '0')\n\t\tnew_mode = old_mode & ~PHY_MODE_SPECIAL;\n\telse\n\t\tnew_mode = PHY_MODE_SPECIAL;\n\tif (!((old_mode ^ new_mode) & PHY_MODE_SPECIAL)) {\n\t\terr = 0;\n\t} else if (efx->state != STATE_READY || netif_running(efx->net_dev)) {\n\t\terr = -EBUSY;\n\t} else {\n\t\t \n\t\tefx->phy_mode = new_mode;\n\t\tif (new_mode & PHY_MODE_SPECIAL)\n\t\t\tfalcon_stop_nic_stats(efx);\n\t\terr = sfe4001_poweron(efx);\n\t\tif (!err)\n\t\t\terr = ef4_reconfigure_port(efx);\n\t\tif (!(new_mode & PHY_MODE_SPECIAL))\n\t\t\tfalcon_start_nic_stats(efx);\n\t}\n\trtnl_unlock();\n\n\treturn err ? err : count;\n}\n\nstatic DEVICE_ATTR_RW(phy_flash_cfg);\n\nstatic void sfe4001_fini(struct ef4_nic *efx)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\n\tnetif_info(efx, drv, efx->net_dev, \"%s\\n\", __func__);\n\n\tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);\n\tsfe4001_poweroff(efx);\n\ti2c_unregister_device(board->ioexp_client);\n\ti2c_unregister_device(board->hwmon_client);\n}\n\nstatic int sfe4001_check_hw(struct ef4_nic *efx)\n{\n\tstruct falcon_nic_data *nic_data = efx->nic_data;\n\ts32 status;\n\n\t \n\tif (EF4_WORKAROUND_7884(efx) && !nic_data->xmac_poll_required)\n\t\treturn 0;\n\n\t \n\tstatus = i2c_smbus_read_byte_data(falcon_board(efx)->ioexp_client, P1_IN);\n\tif (status >= 0 &&\n\t    (status & ((1 << P1_AFE_PWD_LBN) | (1 << P1_DSP_PWD25_LBN))) != 0)\n\t\treturn 0;\n\n\t \n\tsfe4001_poweroff(efx);\n\tefx->phy_mode = PHY_MODE_OFF;\n\n\treturn (status < 0) ? -EIO : -ERANGE;\n}\n\nstatic const struct i2c_board_info sfe4001_hwmon_info = {\n\tI2C_BOARD_INFO(\"max6647\", 0x4e),\n};\n\n \nstatic int sfe4001_init(struct ef4_nic *efx)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\tint rc;\n\n#if IS_ENABLED(CONFIG_SENSORS_LM90)\n\tboard->hwmon_client =\n\t\ti2c_new_client_device(&board->i2c_adap, &sfe4001_hwmon_info);\n#else\n\tboard->hwmon_client =\n\t\ti2c_new_dummy_device(&board->i2c_adap, sfe4001_hwmon_info.addr);\n#endif\n\tif (IS_ERR(board->hwmon_client))\n\t\treturn PTR_ERR(board->hwmon_client);\n\n\t \n\trc = i2c_smbus_write_byte_data(board->hwmon_client,\n\t\t\t\t       MAX664X_REG_WLHO, 90);\n\tif (rc)\n\t\tgoto fail_hwmon;\n\n\tboard->ioexp_client = i2c_new_dummy_device(&board->i2c_adap, PCA9539);\n\tif (IS_ERR(board->ioexp_client)) {\n\t\trc = PTR_ERR(board->ioexp_client);\n\t\tgoto fail_hwmon;\n\t}\n\n\tif (efx->phy_mode & PHY_MODE_SPECIAL) {\n\t\t \n\t\tfalcon_stop_nic_stats(efx);\n\t}\n\trc = sfe4001_poweron(efx);\n\tif (rc)\n\t\tgoto fail_ioexp;\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);\n\tif (rc)\n\t\tgoto fail_on;\n\n\tnetif_info(efx, hw, efx->net_dev, \"PHY is powered on\\n\");\n\treturn 0;\n\nfail_on:\n\tsfe4001_poweroff(efx);\nfail_ioexp:\n\ti2c_unregister_device(board->ioexp_client);\nfail_hwmon:\n\ti2c_unregister_device(board->hwmon_client);\n\treturn rc;\n}\n\n \nstatic u8 sfe4002_lm87_channel = 0x03;  \n\nstatic const u8 sfe4002_lm87_regs[] = {\n\tLM87_IN_LIMITS(0, 0x7c, 0x99),\t\t \n\tLM87_IN_LIMITS(1, 0x4c, 0x5e),\t\t \n\tLM87_IN_LIMITS(2, 0xac, 0xd4),\t\t \n\tLM87_IN_LIMITS(3, 0xac, 0xd4),\t\t \n\tLM87_IN_LIMITS(4, 0xac, 0xe0),\t\t \n\tLM87_IN_LIMITS(5, 0x3f, 0x4f),\t\t \n\tLM87_AIN_LIMITS(0, 0x98, 0xbb),\t\t \n\tLM87_AIN_LIMITS(1, 0x8a, 0xa9),\t\t \n\tLM87_TEMP_INT_LIMITS(0, 80 + FALCON_BOARD_TEMP_BIAS),\n\tLM87_TEMP_EXT1_LIMITS(0, FALCON_JUNC_TEMP_MAX),\n\t0\n};\n\nstatic const struct i2c_board_info sfe4002_hwmon_info = {\n\tI2C_BOARD_INFO(\"lm87\", 0x2e),\n\t.platform_data\t= &sfe4002_lm87_channel,\n};\n\n \n \n#define SFE4002_FAULT_LED (2)\t \n#define SFE4002_RX_LED    (0)\t \n#define SFE4002_TX_LED    (1)\t \n\nstatic void sfe4002_init_phy(struct ef4_nic *efx)\n{\n\t \n\tfalcon_qt202x_set_led(efx, SFE4002_TX_LED,\n\t\t\t      QUAKE_LED_TXLINK | QUAKE_LED_LINK_ACTSTAT);\n\tfalcon_qt202x_set_led(efx, SFE4002_RX_LED,\n\t\t\t      QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACTSTAT);\n\tfalcon_qt202x_set_led(efx, SFE4002_FAULT_LED, QUAKE_LED_OFF);\n}\n\nstatic void sfe4002_set_id_led(struct ef4_nic *efx, enum ef4_led_mode mode)\n{\n\tfalcon_qt202x_set_led(\n\t\tefx, SFE4002_FAULT_LED,\n\t\t(mode == EF4_LED_ON) ? QUAKE_LED_ON : QUAKE_LED_OFF);\n}\n\nstatic int sfe4002_check_hw(struct ef4_nic *efx)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\n\t \n\tunsigned alarm_mask =\n\t\t(board->major == 0 && board->minor == 0) ?\n\t\t~LM87_ALARM_TEMP_EXT1 : ~0;\n\n\treturn ef4_check_lm87(efx, alarm_mask);\n}\n\nstatic int sfe4002_init(struct ef4_nic *efx)\n{\n\treturn ef4_init_lm87(efx, &sfe4002_hwmon_info, sfe4002_lm87_regs);\n}\n\n \nstatic u8 sfn4112f_lm87_channel = 0x03;  \n\nstatic const u8 sfn4112f_lm87_regs[] = {\n\tLM87_IN_LIMITS(0, 0x7c, 0x99),\t\t \n\tLM87_IN_LIMITS(1, 0x4c, 0x5e),\t\t \n\tLM87_IN_LIMITS(2, 0xac, 0xd4),\t\t \n\tLM87_IN_LIMITS(4, 0xac, 0xe0),\t\t \n\tLM87_IN_LIMITS(5, 0x3f, 0x4f),\t\t \n\tLM87_AIN_LIMITS(1, 0x8a, 0xa9),\t\t \n\tLM87_TEMP_INT_LIMITS(0, 60 + FALCON_BOARD_TEMP_BIAS),\n\tLM87_TEMP_EXT1_LIMITS(0, FALCON_JUNC_TEMP_MAX),\n\t0\n};\n\nstatic const struct i2c_board_info sfn4112f_hwmon_info = {\n\tI2C_BOARD_INFO(\"lm87\", 0x2e),\n\t.platform_data\t= &sfn4112f_lm87_channel,\n};\n\n#define SFN4112F_ACT_LED\t0\n#define SFN4112F_LINK_LED\t1\n\nstatic void sfn4112f_init_phy(struct ef4_nic *efx)\n{\n\tfalcon_qt202x_set_led(efx, SFN4112F_ACT_LED,\n\t\t\t      QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACT);\n\tfalcon_qt202x_set_led(efx, SFN4112F_LINK_LED,\n\t\t\t      QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT);\n}\n\nstatic void sfn4112f_set_id_led(struct ef4_nic *efx, enum ef4_led_mode mode)\n{\n\tint reg;\n\n\tswitch (mode) {\n\tcase EF4_LED_OFF:\n\t\treg = QUAKE_LED_OFF;\n\t\tbreak;\n\tcase EF4_LED_ON:\n\t\treg = QUAKE_LED_ON;\n\t\tbreak;\n\tdefault:\n\t\treg = QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT;\n\t\tbreak;\n\t}\n\n\tfalcon_qt202x_set_led(efx, SFN4112F_LINK_LED, reg);\n}\n\nstatic int sfn4112f_check_hw(struct ef4_nic *efx)\n{\n\t \n\treturn ef4_check_lm87(efx, ~0x48);\n}\n\nstatic int sfn4112f_init(struct ef4_nic *efx)\n{\n\treturn ef4_init_lm87(efx, &sfn4112f_hwmon_info, sfn4112f_lm87_regs);\n}\n\n \nstatic u8 sfe4003_lm87_channel = 0x03;  \n\nstatic const u8 sfe4003_lm87_regs[] = {\n\tLM87_IN_LIMITS(0, 0x67, 0x7f),\t\t \n\tLM87_IN_LIMITS(1, 0x4c, 0x5e),\t\t \n\tLM87_IN_LIMITS(2, 0xac, 0xd4),\t\t \n\tLM87_IN_LIMITS(4, 0xac, 0xe0),\t\t \n\tLM87_IN_LIMITS(5, 0x3f, 0x4f),\t\t \n\tLM87_TEMP_INT_LIMITS(0, 70 + FALCON_BOARD_TEMP_BIAS),\n\t0\n};\n\nstatic const struct i2c_board_info sfe4003_hwmon_info = {\n\tI2C_BOARD_INFO(\"lm87\", 0x2e),\n\t.platform_data\t= &sfe4003_lm87_channel,\n};\n\n \n#define SFE4003_RED_LED_GPIO\t11\n#define SFE4003_LED_ON\t\t1\n#define SFE4003_LED_OFF\t\t0\n\nstatic void sfe4003_set_id_led(struct ef4_nic *efx, enum ef4_led_mode mode)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\n\t \n\tif (board->minor < 3 && board->major == 0)\n\t\treturn;\n\n\tfalcon_txc_set_gpio_val(\n\t\tefx, SFE4003_RED_LED_GPIO,\n\t\t(mode == EF4_LED_ON) ? SFE4003_LED_ON : SFE4003_LED_OFF);\n}\n\nstatic void sfe4003_init_phy(struct ef4_nic *efx)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\n\t \n\tif (board->minor < 3 && board->major == 0)\n\t\treturn;\n\n\tfalcon_txc_set_gpio_dir(efx, SFE4003_RED_LED_GPIO, TXC_GPIO_DIR_OUTPUT);\n\tfalcon_txc_set_gpio_val(efx, SFE4003_RED_LED_GPIO, SFE4003_LED_OFF);\n}\n\nstatic int sfe4003_check_hw(struct ef4_nic *efx)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\n\t \n\tunsigned alarm_mask =\n\t\t(board->major == 0 && board->minor <= 2) ?\n\t\t~LM87_ALARM_TEMP_EXT1 : ~0;\n\n\treturn ef4_check_lm87(efx, alarm_mask);\n}\n\nstatic int sfe4003_init(struct ef4_nic *efx)\n{\n\treturn ef4_init_lm87(efx, &sfe4003_hwmon_info, sfe4003_lm87_regs);\n}\n\nstatic const struct falcon_board_type board_types[] = {\n\t{\n\t\t.id\t\t= FALCON_BOARD_SFE4001,\n\t\t.init\t\t= sfe4001_init,\n\t\t.init_phy\t= ef4_port_dummy_op_void,\n\t\t.fini\t\t= sfe4001_fini,\n\t\t.set_id_led\t= tenxpress_set_id_led,\n\t\t.monitor\t= sfe4001_check_hw,\n\t},\n\t{\n\t\t.id\t\t= FALCON_BOARD_SFE4002,\n\t\t.init\t\t= sfe4002_init,\n\t\t.init_phy\t= sfe4002_init_phy,\n\t\t.fini\t\t= ef4_fini_lm87,\n\t\t.set_id_led\t= sfe4002_set_id_led,\n\t\t.monitor\t= sfe4002_check_hw,\n\t},\n\t{\n\t\t.id\t\t= FALCON_BOARD_SFE4003,\n\t\t.init\t\t= sfe4003_init,\n\t\t.init_phy\t= sfe4003_init_phy,\n\t\t.fini\t\t= ef4_fini_lm87,\n\t\t.set_id_led\t= sfe4003_set_id_led,\n\t\t.monitor\t= sfe4003_check_hw,\n\t},\n\t{\n\t\t.id\t\t= FALCON_BOARD_SFN4112F,\n\t\t.init\t\t= sfn4112f_init,\n\t\t.init_phy\t= sfn4112f_init_phy,\n\t\t.fini\t\t= ef4_fini_lm87,\n\t\t.set_id_led\t= sfn4112f_set_id_led,\n\t\t.monitor\t= sfn4112f_check_hw,\n\t},\n};\n\nint falcon_probe_board(struct ef4_nic *efx, u16 revision_info)\n{\n\tstruct falcon_board *board = falcon_board(efx);\n\tu8 type_id = FALCON_BOARD_TYPE(revision_info);\n\tint i;\n\n\tboard->major = FALCON_BOARD_MAJOR(revision_info);\n\tboard->minor = FALCON_BOARD_MINOR(revision_info);\n\n\tfor (i = 0; i < ARRAY_SIZE(board_types); i++)\n\t\tif (board_types[i].id == type_id)\n\t\t\tboard->type = &board_types[i];\n\n\tif (board->type) {\n\t\treturn 0;\n\t} else {\n\t\tnetif_err(efx, probe, efx->net_dev, \"unknown board type %d\\n\",\n\t\t\t  type_id);\n\t\treturn -ENODEV;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}