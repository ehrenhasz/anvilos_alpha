{
  "module_name": "ef100_nic.c",
  "hash_id": "f2edcf0d319b2b7e190c3856d874a11bfbcc1597a3f4e7eba144bbe5500cd8b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef100_nic.c",
  "human_readable_source": "\n \n\n#include \"ef100_nic.h\"\n#include \"efx_common.h\"\n#include \"efx_channels.h\"\n#include \"io.h\"\n#include \"selftest.h\"\n#include \"ef100_regs.h\"\n#include \"mcdi.h\"\n#include \"mcdi_pcol.h\"\n#include \"mcdi_port_common.h\"\n#include \"mcdi_functions.h\"\n#include \"mcdi_filters.h\"\n#include \"ef100_rx.h\"\n#include \"ef100_tx.h\"\n#include \"ef100_sriov.h\"\n#include \"ef100_netdev.h\"\n#include \"tc.h\"\n#include \"mae.h\"\n#include \"rx_common.h\"\n\n#define EF100_MAX_VIS 4096\n#define EF100_NUM_MCDI_BUFFERS\t1\n#define MCDI_BUF_LEN (8 + MCDI_CTL_SDU_LEN_MAX)\n\n#define EF100_RESET_PORT ((ETH_RESET_MAC | ETH_RESET_PHY) << ETH_RESET_SHARED_SHIFT)\n\n \nstatic u8 *ef100_mcdi_buf(struct efx_nic *efx, u8 bufid, dma_addr_t *dma_addr)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\n\tif (dma_addr)\n\t\t*dma_addr = nic_data->mcdi_buf.dma_addr +\n\t\t\t    bufid * ALIGN(MCDI_BUF_LEN, 256);\n\treturn nic_data->mcdi_buf.addr + bufid * ALIGN(MCDI_BUF_LEN, 256);\n}\n\nstatic int ef100_get_warm_boot_count(struct efx_nic *efx)\n{\n\tefx_dword_t reg;\n\n\tefx_readd(efx, &reg, efx_reg(efx, ER_GZ_MC_SFT_STATUS));\n\n\tif (EFX_DWORD_FIELD(reg, EFX_DWORD_0) == 0xffffffff) {\n\t\tnetif_err(efx, hw, efx->net_dev, \"Hardware unavailable\\n\");\n\t\tefx->state = STATE_DISABLED;\n\t\treturn -ENETDOWN;\n\t} else {\n\t\treturn EFX_DWORD_FIELD(reg, EFX_WORD_1) == 0xb007 ?\n\t\t\tEFX_DWORD_FIELD(reg, EFX_WORD_0) : -EIO;\n\t}\n}\n\nstatic void ef100_mcdi_request(struct efx_nic *efx,\n\t\t\t       const efx_dword_t *hdr, size_t hdr_len,\n\t\t\t       const efx_dword_t *sdu, size_t sdu_len)\n{\n\tdma_addr_t dma_addr;\n\tu8 *pdu = ef100_mcdi_buf(efx, 0, &dma_addr);\n\n\tmemcpy(pdu, hdr, hdr_len);\n\tmemcpy(pdu + hdr_len, sdu, sdu_len);\n\twmb();\n\n\t \n\t_efx_writed(efx, cpu_to_le32((u64)dma_addr >> 32),  efx_reg(efx, ER_GZ_MC_DB_LWRD));\n\t_efx_writed(efx, cpu_to_le32((u32)dma_addr),  efx_reg(efx, ER_GZ_MC_DB_HWRD));\n}\n\nstatic bool ef100_mcdi_poll_response(struct efx_nic *efx)\n{\n\tconst efx_dword_t hdr =\n\t\t*(const efx_dword_t *)(ef100_mcdi_buf(efx, 0, NULL));\n\n\trmb();\n\treturn EFX_DWORD_FIELD(hdr, MCDI_HEADER_RESPONSE);\n}\n\nstatic void ef100_mcdi_read_response(struct efx_nic *efx,\n\t\t\t\t     efx_dword_t *outbuf, size_t offset,\n\t\t\t\t     size_t outlen)\n{\n\tconst u8 *pdu = ef100_mcdi_buf(efx, 0, NULL);\n\n\tmemcpy(outbuf, pdu + offset, outlen);\n}\n\nstatic int ef100_mcdi_poll_reboot(struct efx_nic *efx)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\trc = ef100_get_warm_boot_count(efx);\n\tif (rc < 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (rc == nic_data->warm_boot_count)\n\t\treturn 0;\n\n\tnic_data->warm_boot_count = rc;\n\n\treturn -EIO;\n}\n\nstatic void ef100_mcdi_reboot_detected(struct efx_nic *efx)\n{\n}\n\n \nint ef100_get_mac_address(struct efx_nic *efx, u8 *mac_address,\n\t\t\t  int client_handle, bool empty_ok)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_CLIENT_MAC_ADDRESSES_OUT_LEN(1));\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_CLIENT_MAC_ADDRESSES_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_MAC_ADDRESSES_IN_LEN != 0);\n\tMCDI_SET_DWORD(inbuf, GET_CLIENT_MAC_ADDRESSES_IN_CLIENT_HANDLE,\n\t\t       client_handle);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_CLIENT_MAC_ADDRESSES, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\n\tif (outlen >= MC_CMD_GET_CLIENT_MAC_ADDRESSES_OUT_LEN(1)) {\n\t\tether_addr_copy(mac_address,\n\t\t\t\tMCDI_PTR(outbuf, GET_CLIENT_MAC_ADDRESSES_OUT_MAC_ADDRS));\n\t} else if (empty_ok) {\n\t\tpci_warn(efx->pci_dev,\n\t\t\t \"No MAC address provisioned for client ID %#x.\\n\",\n\t\t\t client_handle);\n\t\teth_zero_addr(mac_address);\n\t} else {\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nint efx_ef100_init_datapath_caps(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_CAPABILITIES_V7_OUT_LEN);\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tu8 vi_window_mode;\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_CAPABILITIES_IN_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_CAPABILITIES, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_GET_CAPABILITIES_V4_OUT_LEN) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"unable to read datapath firmware capabilities\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnic_data->datapath_caps = MCDI_DWORD(outbuf,\n\t\t\t\t\t     GET_CAPABILITIES_OUT_FLAGS1);\n\tnic_data->datapath_caps2 = MCDI_DWORD(outbuf,\n\t\t\t\t\t      GET_CAPABILITIES_V2_OUT_FLAGS2);\n\tif (outlen < MC_CMD_GET_CAPABILITIES_V7_OUT_LEN)\n\t\tnic_data->datapath_caps3 = 0;\n\telse\n\t\tnic_data->datapath_caps3 = MCDI_DWORD(outbuf,\n\t\t\t\t\t\t      GET_CAPABILITIES_V7_OUT_FLAGS3);\n\n\tvi_window_mode = MCDI_BYTE(outbuf,\n\t\t\t\t   GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE);\n\trc = efx_mcdi_window_mode_to_stride(efx, vi_window_mode);\n\tif (rc)\n\t\treturn rc;\n\n\tif (efx_ef100_has_cap(nic_data->datapath_caps2, TX_TSO_V3)) {\n\t\tstruct net_device *net_dev = efx->net_dev;\n\t\tnetdev_features_t tso = NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_GSO_PARTIAL |\n\t\t\t\t\tNETIF_F_GSO_UDP_TUNNEL | NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t\tNETIF_F_GSO_GRE | NETIF_F_GSO_GRE_CSUM;\n\n\t\tnet_dev->features |= tso;\n\t\tnet_dev->hw_features |= tso;\n\t\tnet_dev->hw_enc_features |= tso;\n\t\t \n\t\tnet_dev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;\n\t}\n\tefx->num_mac_stats = MCDI_WORD(outbuf,\n\t\t\t\t       GET_CAPABILITIES_V4_OUT_MAC_STATS_NUM_STATS);\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"firmware reports num_mac_stats = %u\\n\",\n\t\t  efx->num_mac_stats);\n\treturn 0;\n}\n\n \nstatic int ef100_ev_probe(struct efx_channel *channel)\n{\n\t \n\treturn efx_nic_alloc_buffer(channel->efx, &channel->eventq,\n\t\t\t\t    (channel->eventq_mask + 2) *\n\t\t\t\t    sizeof(efx_qword_t),\n\t\t\t\t    GFP_KERNEL);\n}\n\nstatic int ef100_ev_init(struct efx_channel *channel)\n{\n\tstruct ef100_nic_data *nic_data = channel->efx->nic_data;\n\n\t \n\tclear_bit(channel->channel, nic_data->evq_phases);\n\n\treturn efx_mcdi_ev_init(channel, false, false);\n}\n\nstatic void ef100_ev_read_ack(struct efx_channel *channel)\n{\n\tefx_dword_t evq_prime;\n\n\tEFX_POPULATE_DWORD_2(evq_prime,\n\t\t\t     ERF_GZ_EVQ_ID, channel->channel,\n\t\t\t     ERF_GZ_IDX, channel->eventq_read_ptr &\n\t\t\t\t\t channel->eventq_mask);\n\n\tefx_writed(channel->efx, &evq_prime,\n\t\t   efx_reg(channel->efx, ER_GZ_EVQ_INT_PRIME));\n}\n\n#define EFX_NAPI_MAX_TX 512\n\nstatic int ef100_ev_process(struct efx_channel *channel, int quota)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tstruct ef100_nic_data *nic_data;\n\tbool evq_phase, old_evq_phase;\n\tunsigned int read_ptr;\n\tefx_qword_t *p_event;\n\tint spent_tx = 0;\n\tint spent = 0;\n\tbool ev_phase;\n\tint ev_type;\n\n\tif (unlikely(!channel->enabled))\n\t\treturn 0;\n\n\tnic_data = efx->nic_data;\n\tevq_phase = test_bit(channel->channel, nic_data->evq_phases);\n\told_evq_phase = evq_phase;\n\tread_ptr = channel->eventq_read_ptr;\n\tBUILD_BUG_ON(ESF_GZ_EV_RXPKTS_PHASE_LBN != ESF_GZ_EV_TXCMPL_PHASE_LBN);\n\n\twhile (spent < quota) {\n\t\tp_event = efx_event(channel, read_ptr);\n\n\t\tev_phase = !!EFX_QWORD_FIELD(*p_event, ESF_GZ_EV_RXPKTS_PHASE);\n\t\tif (ev_phase != evq_phase)\n\t\t\tbreak;\n\n\t\tnetif_vdbg(efx, drv, efx->net_dev,\n\t\t\t   \"processing event on %d \" EFX_QWORD_FMT \"\\n\",\n\t\t\t   channel->channel, EFX_QWORD_VAL(*p_event));\n\n\t\tev_type = EFX_QWORD_FIELD(*p_event, ESF_GZ_E_TYPE);\n\n\t\tswitch (ev_type) {\n\t\tcase ESE_GZ_EF100_EV_RX_PKTS:\n\t\t\tefx_ef100_ev_rx(channel, p_event);\n\t\t\t++spent;\n\t\t\tbreak;\n\t\tcase ESE_GZ_EF100_EV_MCDI:\n\t\t\tefx_mcdi_process_event(channel, p_event);\n\t\t\tbreak;\n\t\tcase ESE_GZ_EF100_EV_TX_COMPLETION:\n\t\t\tspent_tx += ef100_ev_tx(channel, p_event);\n\t\t\tif (spent_tx >= EFX_NAPI_MAX_TX)\n\t\t\t\tspent = quota;\n\t\t\tbreak;\n\t\tcase ESE_GZ_EF100_EV_DRIVER:\n\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t   \"Driver initiated event \" EFX_QWORD_FMT \"\\n\",\n\t\t\t\t   EFX_QWORD_VAL(*p_event));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t   \"Unhandled event \" EFX_QWORD_FMT \"\\n\",\n\t\t\t\t   EFX_QWORD_VAL(*p_event));\n\t\t}\n\n\t\t++read_ptr;\n\t\tif ((read_ptr & channel->eventq_mask) == 0)\n\t\t\tevq_phase = !evq_phase;\n\t}\n\n\tchannel->eventq_read_ptr = read_ptr;\n\tif (evq_phase != old_evq_phase)\n\t\tchange_bit(channel->channel, nic_data->evq_phases);\n\n\treturn spent;\n}\n\nstatic irqreturn_t ef100_msi_interrupt(int irq, void *dev_id)\n{\n\tstruct efx_msi_context *context = dev_id;\n\tstruct efx_nic *efx = context->efx;\n\n\tnetif_vdbg(efx, intr, efx->net_dev,\n\t\t   \"IRQ %d on CPU %d\\n\", irq, raw_smp_processor_id());\n\n\tif (likely(READ_ONCE(efx->irq_soft_enabled))) {\n\t\t \n\t\tif (context->index == efx->irq_level)\n\t\t\tefx->last_irq_cpu = raw_smp_processor_id();\n\n\t\t \n\t\tefx_schedule_channel_irq(efx->channel[context->index]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint ef100_phy_probe(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_phy_data *phy_data;\n\tint rc;\n\n\t \n\tefx->phy_data = kzalloc(sizeof(struct efx_mcdi_phy_data), GFP_KERNEL);\n\tif (!efx->phy_data)\n\t\treturn -ENOMEM;\n\n\trc = efx_mcdi_get_phy_cfg(efx, efx->phy_data);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tphy_data = efx->phy_data;\n\tmcdi_to_ethtool_linkset(phy_data->media, phy_data->supported_cap,\n\t\t\t\tefx->link_advertising);\n\tefx->fec_config = mcdi_fec_caps_to_ethtool(phy_data->supported_cap,\n\t\t\t\t\t\t   false);\n\n\t \n\tefx->wanted_fc = EFX_FC_RX | EFX_FC_TX;\n\tif (phy_data->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\n\t\tefx->wanted_fc |= EFX_FC_AUTO;\n\tefx_link_set_wanted_fc(efx, efx->wanted_fc);\n\n\t \n\trc = efx_mcdi_port_reconfigure(efx);\n\tif (rc && rc != -EPERM)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"could not initialise PHY settings\\n\");\n\n\treturn 0;\n}\n\nint ef100_filter_table_probe(struct efx_nic *efx)\n{\n\treturn efx_mcdi_filter_table_probe(efx, true);\n}\n\nstatic int ef100_filter_table_up(struct efx_nic *efx)\n{\n\tint rc;\n\n\tdown_write(&efx->filter_sem);\n\trc = efx_mcdi_filter_add_vlan(efx, EFX_FILTER_VID_UNSPEC);\n\tif (rc)\n\t\tgoto fail_unspec;\n\n\trc = efx_mcdi_filter_add_vlan(efx, 0);\n\tif (rc)\n\t\tgoto fail_vlan0;\n\t \n\tup_write(&efx->filter_sem);\n\tif (IS_ENABLED(CONFIG_SFC_SRIOV))\n\t\trc = efx_tc_insert_rep_filters(efx);\n\n\t \n\tif (rc)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"Failed to insert representor filters, rc %d\\n\",\n\t\t\t   rc);\n\treturn 0;\n\nfail_vlan0:\n\tefx_mcdi_filter_del_vlan(efx, EFX_FILTER_VID_UNSPEC);\nfail_unspec:\n\tefx_mcdi_filter_table_down(efx);\n\tup_write(&efx->filter_sem);\n\treturn rc;\n}\n\nstatic void ef100_filter_table_down(struct efx_nic *efx)\n{\n\tif (IS_ENABLED(CONFIG_SFC_SRIOV))\n\t\tefx_tc_remove_rep_filters(efx);\n\tdown_write(&efx->filter_sem);\n\tefx_mcdi_filter_del_vlan(efx, 0);\n\tefx_mcdi_filter_del_vlan(efx, EFX_FILTER_VID_UNSPEC);\n\tefx_mcdi_filter_table_down(efx);\n\tup_write(&efx->filter_sem);\n}\n\n \nstatic int ef100_reconfigure_mac(struct efx_nic *efx, bool mtu_only)\n{\n\tWARN_ON(!mutex_is_locked(&efx->mac_lock));\n\n\tefx_mcdi_filter_sync_rx_mode(efx);\n\n\tif (mtu_only && efx_has_cap(efx, SET_MAC_ENHANCED))\n\t\treturn efx_mcdi_set_mtu(efx);\n\treturn efx_mcdi_set_mac(efx);\n}\n\nstatic enum reset_type ef100_map_reset_reason(enum reset_type reason)\n{\n\tif (reason == RESET_TYPE_TX_WATCHDOG)\n\t\treturn reason;\n\treturn RESET_TYPE_DISABLE;\n}\n\nstatic int ef100_map_reset_flags(u32 *flags)\n{\n\t \n\tif ((*flags & EF100_RESET_PORT)) {\n\t\t*flags &= ~EF100_RESET_PORT;\n\t\treturn RESET_TYPE_ALL;\n\t}\n\tif (*flags & ETH_RESET_MGMT) {\n\t\t*flags &= ~ETH_RESET_MGMT;\n\t\treturn RESET_TYPE_DISABLE;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ef100_reset(struct efx_nic *efx, enum reset_type reset_type)\n{\n\tint rc;\n\n\tdev_close(efx->net_dev);\n\n\tif (reset_type == RESET_TYPE_TX_WATCHDOG) {\n\t\tnetif_device_attach(efx->net_dev);\n\t\t__clear_bit(reset_type, &efx->reset_pending);\n\t\trc = dev_open(efx->net_dev, NULL);\n\t} else if (reset_type == RESET_TYPE_ALL) {\n\t\trc = efx_mcdi_reset(efx, reset_type);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tnetif_device_attach(efx->net_dev);\n\n\t\trc = dev_open(efx->net_dev, NULL);\n\t} else {\n\t\trc = 1;\t \n\t}\n\treturn rc;\n}\n\nstatic void ef100_common_stat_mask(unsigned long *mask)\n{\n\t__set_bit(EF100_STAT_port_rx_packets, mask);\n\t__set_bit(EF100_STAT_port_tx_packets, mask);\n\t__set_bit(EF100_STAT_port_rx_bytes, mask);\n\t__set_bit(EF100_STAT_port_tx_bytes, mask);\n\t__set_bit(EF100_STAT_port_rx_multicast, mask);\n\t__set_bit(EF100_STAT_port_rx_bad, mask);\n\t__set_bit(EF100_STAT_port_rx_align_error, mask);\n\t__set_bit(EF100_STAT_port_rx_overflow, mask);\n}\n\nstatic void ef100_ethtool_stat_mask(unsigned long *mask)\n{\n\t__set_bit(EF100_STAT_port_tx_pause, mask);\n\t__set_bit(EF100_STAT_port_tx_unicast, mask);\n\t__set_bit(EF100_STAT_port_tx_multicast, mask);\n\t__set_bit(EF100_STAT_port_tx_broadcast, mask);\n\t__set_bit(EF100_STAT_port_tx_lt64, mask);\n\t__set_bit(EF100_STAT_port_tx_64, mask);\n\t__set_bit(EF100_STAT_port_tx_65_to_127, mask);\n\t__set_bit(EF100_STAT_port_tx_128_to_255, mask);\n\t__set_bit(EF100_STAT_port_tx_256_to_511, mask);\n\t__set_bit(EF100_STAT_port_tx_512_to_1023, mask);\n\t__set_bit(EF100_STAT_port_tx_1024_to_15xx, mask);\n\t__set_bit(EF100_STAT_port_tx_15xx_to_jumbo, mask);\n\t__set_bit(EF100_STAT_port_rx_good, mask);\n\t__set_bit(EF100_STAT_port_rx_pause, mask);\n\t__set_bit(EF100_STAT_port_rx_unicast, mask);\n\t__set_bit(EF100_STAT_port_rx_broadcast, mask);\n\t__set_bit(EF100_STAT_port_rx_lt64, mask);\n\t__set_bit(EF100_STAT_port_rx_64, mask);\n\t__set_bit(EF100_STAT_port_rx_65_to_127, mask);\n\t__set_bit(EF100_STAT_port_rx_128_to_255, mask);\n\t__set_bit(EF100_STAT_port_rx_256_to_511, mask);\n\t__set_bit(EF100_STAT_port_rx_512_to_1023, mask);\n\t__set_bit(EF100_STAT_port_rx_1024_to_15xx, mask);\n\t__set_bit(EF100_STAT_port_rx_15xx_to_jumbo, mask);\n\t__set_bit(EF100_STAT_port_rx_gtjumbo, mask);\n\t__set_bit(EF100_STAT_port_rx_bad_gtjumbo, mask);\n\t__set_bit(EF100_STAT_port_rx_length_error, mask);\n\t__set_bit(EF100_STAT_port_rx_nodesc_drops, mask);\n\t__set_bit(GENERIC_STAT_rx_nodesc_trunc, mask);\n\t__set_bit(GENERIC_STAT_rx_noskb_drops, mask);\n}\n\n#define EF100_DMA_STAT(ext_name, mcdi_name)\t\t\t\\\n\t[EF100_STAT_ ## ext_name] =\t\t\t\t\\\n\t{ #ext_name, 64, 8 * MC_CMD_MAC_ ## mcdi_name }\n\nstatic const struct efx_hw_stat_desc ef100_stat_desc[EF100_STAT_COUNT] = {\n\tEF100_DMA_STAT(port_tx_bytes, TX_BYTES),\n\tEF100_DMA_STAT(port_tx_packets, TX_PKTS),\n\tEF100_DMA_STAT(port_tx_pause, TX_PAUSE_PKTS),\n\tEF100_DMA_STAT(port_tx_unicast, TX_UNICAST_PKTS),\n\tEF100_DMA_STAT(port_tx_multicast, TX_MULTICAST_PKTS),\n\tEF100_DMA_STAT(port_tx_broadcast, TX_BROADCAST_PKTS),\n\tEF100_DMA_STAT(port_tx_lt64, TX_LT64_PKTS),\n\tEF100_DMA_STAT(port_tx_64, TX_64_PKTS),\n\tEF100_DMA_STAT(port_tx_65_to_127, TX_65_TO_127_PKTS),\n\tEF100_DMA_STAT(port_tx_128_to_255, TX_128_TO_255_PKTS),\n\tEF100_DMA_STAT(port_tx_256_to_511, TX_256_TO_511_PKTS),\n\tEF100_DMA_STAT(port_tx_512_to_1023, TX_512_TO_1023_PKTS),\n\tEF100_DMA_STAT(port_tx_1024_to_15xx, TX_1024_TO_15XX_PKTS),\n\tEF100_DMA_STAT(port_tx_15xx_to_jumbo, TX_15XX_TO_JUMBO_PKTS),\n\tEF100_DMA_STAT(port_rx_bytes, RX_BYTES),\n\tEF100_DMA_STAT(port_rx_packets, RX_PKTS),\n\tEF100_DMA_STAT(port_rx_good, RX_GOOD_PKTS),\n\tEF100_DMA_STAT(port_rx_bad, RX_BAD_FCS_PKTS),\n\tEF100_DMA_STAT(port_rx_pause, RX_PAUSE_PKTS),\n\tEF100_DMA_STAT(port_rx_unicast, RX_UNICAST_PKTS),\n\tEF100_DMA_STAT(port_rx_multicast, RX_MULTICAST_PKTS),\n\tEF100_DMA_STAT(port_rx_broadcast, RX_BROADCAST_PKTS),\n\tEF100_DMA_STAT(port_rx_lt64, RX_UNDERSIZE_PKTS),\n\tEF100_DMA_STAT(port_rx_64, RX_64_PKTS),\n\tEF100_DMA_STAT(port_rx_65_to_127, RX_65_TO_127_PKTS),\n\tEF100_DMA_STAT(port_rx_128_to_255, RX_128_TO_255_PKTS),\n\tEF100_DMA_STAT(port_rx_256_to_511, RX_256_TO_511_PKTS),\n\tEF100_DMA_STAT(port_rx_512_to_1023, RX_512_TO_1023_PKTS),\n\tEF100_DMA_STAT(port_rx_1024_to_15xx, RX_1024_TO_15XX_PKTS),\n\tEF100_DMA_STAT(port_rx_15xx_to_jumbo, RX_15XX_TO_JUMBO_PKTS),\n\tEF100_DMA_STAT(port_rx_gtjumbo, RX_GTJUMBO_PKTS),\n\tEF100_DMA_STAT(port_rx_bad_gtjumbo, RX_JABBER_PKTS),\n\tEF100_DMA_STAT(port_rx_align_error, RX_ALIGN_ERROR_PKTS),\n\tEF100_DMA_STAT(port_rx_length_error, RX_LENGTH_ERROR_PKTS),\n\tEF100_DMA_STAT(port_rx_overflow, RX_OVERFLOW_PKTS),\n\tEF100_DMA_STAT(port_rx_nodesc_drops, RX_NODESC_DROPS),\n\tEFX_GENERIC_SW_STAT(rx_nodesc_trunc),\n\tEFX_GENERIC_SW_STAT(rx_noskb_drops),\n};\n\nstatic size_t ef100_describe_stats(struct efx_nic *efx, u8 *names)\n{\n\tDECLARE_BITMAP(mask, EF100_STAT_COUNT) = {};\n\n\tef100_ethtool_stat_mask(mask);\n\treturn efx_nic_describe_stats(ef100_stat_desc, EF100_STAT_COUNT,\n\t\t\t\t      mask, names);\n}\n\nstatic size_t ef100_update_stats_common(struct efx_nic *efx, u64 *full_stats,\n\t\t\t\t\tstruct rtnl_link_stats64 *core_stats)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tDECLARE_BITMAP(mask, EF100_STAT_COUNT) = {};\n\tsize_t stats_count = 0, index;\n\tu64 *stats = nic_data->stats;\n\n\tef100_ethtool_stat_mask(mask);\n\n\tif (full_stats) {\n\t\tfor_each_set_bit(index, mask, EF100_STAT_COUNT) {\n\t\t\tif (ef100_stat_desc[index].name) {\n\t\t\t\t*full_stats++ = stats[index];\n\t\t\t\t++stats_count;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!core_stats)\n\t\treturn stats_count;\n\n\tcore_stats->rx_packets = stats[EF100_STAT_port_rx_packets];\n\tcore_stats->tx_packets = stats[EF100_STAT_port_tx_packets];\n\tcore_stats->rx_bytes = stats[EF100_STAT_port_rx_bytes];\n\tcore_stats->tx_bytes = stats[EF100_STAT_port_tx_bytes];\n\tcore_stats->rx_dropped = stats[EF100_STAT_port_rx_nodesc_drops] +\n\t\t\t\t stats[GENERIC_STAT_rx_nodesc_trunc] +\n\t\t\t\t stats[GENERIC_STAT_rx_noskb_drops];\n\tcore_stats->multicast = stats[EF100_STAT_port_rx_multicast];\n\tcore_stats->rx_length_errors =\n\t\t\tstats[EF100_STAT_port_rx_gtjumbo] +\n\t\t\tstats[EF100_STAT_port_rx_length_error];\n\tcore_stats->rx_crc_errors = stats[EF100_STAT_port_rx_bad];\n\tcore_stats->rx_frame_errors =\n\t\t\tstats[EF100_STAT_port_rx_align_error];\n\tcore_stats->rx_fifo_errors = stats[EF100_STAT_port_rx_overflow];\n\tcore_stats->rx_errors = (core_stats->rx_length_errors +\n\t\t\t\t core_stats->rx_crc_errors +\n\t\t\t\t core_stats->rx_frame_errors);\n\n\treturn stats_count;\n}\n\nstatic size_t ef100_update_stats(struct efx_nic *efx,\n\t\t\t\t u64 *full_stats,\n\t\t\t\t struct rtnl_link_stats64 *core_stats)\n{\n\t__le64 *mc_stats = kmalloc(array_size(efx->num_mac_stats, sizeof(__le64)), GFP_ATOMIC);\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tDECLARE_BITMAP(mask, EF100_STAT_COUNT) = {};\n\tu64 *stats = nic_data->stats;\n\n\tef100_common_stat_mask(mask);\n\tef100_ethtool_stat_mask(mask);\n\n\tif (!mc_stats)\n\t\treturn 0;\n\n\tefx_nic_copy_stats(efx, mc_stats);\n\tefx_nic_update_stats(ef100_stat_desc, EF100_STAT_COUNT, mask,\n\t\t\t     stats, mc_stats, false);\n\n\tkfree(mc_stats);\n\n\treturn ef100_update_stats_common(efx, full_stats, core_stats);\n}\n\nstatic int efx_ef100_get_phys_port_id(struct efx_nic *efx,\n\t\t\t\t      struct netdev_phys_item_id *ppid)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\n\tif (!is_valid_ether_addr(nic_data->port_id))\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = ETH_ALEN;\n\tmemcpy(ppid->id, nic_data->port_id, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic int efx_ef100_irq_test_generate(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_TRIGGER_INTERRUPT_IN_LEN);\n\n\tBUILD_BUG_ON(MC_CMD_TRIGGER_INTERRUPT_OUT_LEN != 0);\n\n\tMCDI_SET_DWORD(inbuf, TRIGGER_INTERRUPT_IN_INTR_LEVEL, efx->irq_level);\n\treturn efx_mcdi_rpc_quiet(efx, MC_CMD_TRIGGER_INTERRUPT,\n\t\t\t\t  inbuf, sizeof(inbuf), NULL, 0, NULL);\n}\n\n#define EFX_EF100_TEST 1\n\nstatic void efx_ef100_ev_test_generate(struct efx_channel *channel)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_DRIVER_EVENT_IN_LEN);\n\tstruct efx_nic *efx = channel->efx;\n\tefx_qword_t event;\n\tint rc;\n\n\tEFX_POPULATE_QWORD_2(event,\n\t\t\t     ESF_GZ_E_TYPE, ESE_GZ_EF100_EV_DRIVER,\n\t\t\t     ESF_GZ_DRIVER_DATA, EFX_EF100_TEST);\n\n\tMCDI_SET_DWORD(inbuf, DRIVER_EVENT_IN_EVQ, channel->channel);\n\n\t \n\tmemcpy(MCDI_PTR(inbuf, DRIVER_EVENT_IN_DATA), &event.u64[0],\n\t       sizeof(efx_qword_t));\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_DRIVER_EVENT, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\tif (rc && (rc != -ENETDOWN))\n\t\tgoto fail;\n\n\treturn;\n\nfail:\n\tWARN_ON(true);\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n}\n\nstatic unsigned int ef100_check_caps(const struct efx_nic *efx,\n\t\t\t\t     u8 flag, u32 offset)\n{\n\tconst struct ef100_nic_data *nic_data = efx->nic_data;\n\n\tswitch (offset) {\n\tcase MC_CMD_GET_CAPABILITIES_V8_OUT_FLAGS1_OFST:\n\t\treturn nic_data->datapath_caps & BIT_ULL(flag);\n\tcase MC_CMD_GET_CAPABILITIES_V8_OUT_FLAGS2_OFST:\n\t\treturn nic_data->datapath_caps2 & BIT_ULL(flag);\n\tcase MC_CMD_GET_CAPABILITIES_V8_OUT_FLAGS3_OFST:\n\t\treturn nic_data->datapath_caps3 & BIT_ULL(flag);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic unsigned int efx_ef100_recycle_ring_size(const struct efx_nic *efx)\n{\n\t \n\treturn 10 * EFX_RECYCLE_RING_SIZE_10G;\n}\n\nstatic int efx_ef100_get_base_mport(struct efx_nic *efx)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tu32 selector, id;\n\tint rc;\n\n\t \n\tefx_mae_mport_wire(efx, &selector);\n\t \n\trc = efx_mae_fw_lookup_mport(efx, selector, &id);\n\tif (rc)\n\t\treturn rc;\n\t \n\tif (id >> 16)\n\t\tnetif_warn(efx, probe, efx->net_dev, \"Bad base m-port id %#x\\n\",\n\t\t\t   id);\n\tnic_data->base_mport = id;\n\tnic_data->have_mport = true;\n\n\t \n\tefx_mae_mport_uplink(efx, &selector);\n\t \n\trc = efx_mae_fw_lookup_mport(efx, selector, &id);\n\tif (rc)\n\t\treturn rc;\n\tif (id >> 16)\n\t\tnetif_warn(efx, probe, efx->net_dev, \"Bad own m-port id %#x\\n\",\n\t\t\t   id);\n\tnic_data->own_mport = id;\n\tnic_data->have_own_mport = true;\n\n\treturn 0;\n}\n\nstatic int compare_versions(const char *a, const char *b)\n{\n\tint a_major, a_minor, a_point, a_patch;\n\tint b_major, b_minor, b_point, b_patch;\n\tint a_matched, b_matched;\n\n\ta_matched = sscanf(a, \"%d.%d.%d.%d\", &a_major, &a_minor, &a_point, &a_patch);\n\tb_matched = sscanf(b, \"%d.%d.%d.%d\", &b_major, &b_minor, &b_point, &b_patch);\n\n\tif (a_matched == 4 && b_matched != 4)\n\t\treturn +1;\n\n\tif (a_matched != 4 && b_matched == 4)\n\t\treturn -1;\n\n\tif (a_matched != 4 && b_matched != 4)\n\t\treturn 0;\n\n\tif (a_major != b_major)\n\t\treturn a_major - b_major;\n\n\tif (a_minor != b_minor)\n\t\treturn a_minor - b_minor;\n\n\tif (a_point != b_point)\n\t\treturn a_point - b_point;\n\n\treturn a_patch - b_patch;\n}\n\nenum ef100_tlv_state_machine {\n\tEF100_TLV_TYPE,\n\tEF100_TLV_TYPE_CONT,\n\tEF100_TLV_LENGTH,\n\tEF100_TLV_VALUE\n};\n\nstruct ef100_tlv_state {\n\tenum ef100_tlv_state_machine state;\n\tu64 value;\n\tu32 value_offset;\n\tu16 type;\n\tu8 len;\n};\n\nstatic int ef100_tlv_feed(struct ef100_tlv_state *state, u8 byte)\n{\n\tswitch (state->state) {\n\tcase EF100_TLV_TYPE:\n\t\tstate->type = byte & 0x7f;\n\t\tstate->state = (byte & 0x80) ? EF100_TLV_TYPE_CONT\n\t\t\t\t\t     : EF100_TLV_LENGTH;\n\t\t \n\t\tstate->value = 0;\n\t\tstate->value_offset = 0;\n\t\treturn 0;\n\tcase EF100_TLV_TYPE_CONT:\n\t\tstate->type |= byte << 7;\n\t\tstate->state = EF100_TLV_LENGTH;\n\t\treturn 0;\n\tcase EF100_TLV_LENGTH:\n\t\tstate->len = byte;\n\t\t \n\t\tif (state->len > sizeof(state->value))\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\tstate->state = state->len ? EF100_TLV_VALUE : EF100_TLV_TYPE;\n\t\treturn 0;\n\tcase EF100_TLV_VALUE:\n\t\tstate->value |= ((u64)byte) << (state->value_offset * 8);\n\t\tstate->value_offset++;\n\t\tif (state->value_offset >= state->len)\n\t\t\tstate->state = EF100_TLV_TYPE;\n\t\treturn 0;\n\tdefault:  \n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n}\n\nstatic int ef100_process_design_param(struct efx_nic *efx,\n\t\t\t\t      const struct ef100_tlv_state *reader)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\n\tswitch (reader->type) {\n\tcase ESE_EF100_DP_GZ_PAD:  \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_PARTIAL_TSTAMP_SUB_NANO_BITS:\n\t\t \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_EVQ_UNSOL_CREDIT_SEQ_BITS:\n\t\t \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_NMMU_GROUP_SIZE:\n\t\t \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_RX_L4_CSUM_PROTOCOLS:\n\t\t \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_TSO_MAX_HDR_LEN:\n\t\tnic_data->tso_max_hdr_len = min_t(u64, reader->value, 0xffff);\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_TSO_MAX_HDR_NUM_SEGS:\n\t\t \n\t\tif (!reader->value) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"TSO_MAX_HDR_NUM_SEGS < 1\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_RXQ_SIZE_GRANULARITY:\n\tcase ESE_EF100_DP_GZ_TXQ_SIZE_GRANULARITY:\n\t\t \n\t\tif (!reader->value || reader->value > EFX_MIN_DMAQ_SIZE ||\n\t\t    EFX_MIN_DMAQ_SIZE % (u32)reader->value) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"%s size granularity is %llu, can't guarantee safety\\n\",\n\t\t\t\t  reader->type == ESE_EF100_DP_GZ_RXQ_SIZE_GRANULARITY ? \"RXQ\" : \"TXQ\",\n\t\t\t\t  reader->value);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_TSO_MAX_PAYLOAD_LEN:\n\t\tnic_data->tso_max_payload_len = min_t(u64, reader->value,\n\t\t\t\t\t\t      GSO_LEGACY_MAX_SIZE);\n\t\tnetif_set_tso_max_size(efx->net_dev,\n\t\t\t\t       nic_data->tso_max_payload_len);\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_TSO_MAX_PAYLOAD_NUM_SEGS:\n\t\tnic_data->tso_max_payload_num_segs = min_t(u64, reader->value, 0xffff);\n\t\tnetif_set_tso_max_segs(efx->net_dev,\n\t\t\t\t       nic_data->tso_max_payload_num_segs);\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_TSO_MAX_NUM_FRAMES:\n\t\tnic_data->tso_max_frames = min_t(u64, reader->value, 0xffff);\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_COMPAT:\n\t\tif (reader->value) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"DP_COMPAT has unknown bits %#llx, driver not compatible with this hw\\n\",\n\t\t\t\t  reader->value);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_MEM2MEM_MAX_LEN:\n\t\t \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_EVQ_TIMER_TICK_NANOS:\n\t\t \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_NMMU_PAGE_SIZES:\n\t\t \n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_VI_STRIDES:\n\t\t \n\t\tif (reader->value != ESE_EF100_DP_GZ_VI_STRIDES_DEFAULT)\n\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t  \"NIC has other than default VI_STRIDES (mask \"\n\t\t\t\t  \"%#llx), early probing might use wrong one\\n\",\n\t\t\t\t  reader->value);\n\t\treturn 0;\n\tcase ESE_EF100_DP_GZ_RX_MAX_RUNT:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\t \n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"Ignoring unrecognised design parameter %u\\n\",\n\t\t\t  reader->type);\n\t\treturn 0;\n\t}\n}\n\nstatic int ef100_check_design_params(struct efx_nic *efx)\n{\n\tstruct ef100_tlv_state reader = {};\n\tu32 total_len, offset = 0;\n\tefx_dword_t reg;\n\tint rc = 0, i;\n\tu32 data;\n\n\tefx_readd(efx, &reg, ER_GZ_PARAMS_TLV_LEN);\n\ttotal_len = EFX_DWORD_FIELD(reg, EFX_DWORD_0);\n\tpci_dbg(efx->pci_dev, \"%u bytes of design parameters\\n\", total_len);\n\twhile (offset < total_len) {\n\t\tefx_readd(efx, &reg, ER_GZ_PARAMS_TLV + offset);\n\t\tdata = EFX_DWORD_FIELD(reg, EFX_DWORD_0);\n\t\tfor (i = 0; i < sizeof(data); i++) {\n\t\t\trc = ef100_tlv_feed(&reader, data);\n\t\t\t \n\t\t\tif (!rc && reader.state == EF100_TLV_TYPE)\n\t\t\t\trc = ef100_process_design_param(efx, &reader);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tdata >>= 8;\n\t\t\toffset++;\n\t\t}\n\t}\n\t \n\tif (reader.state != EF100_TLV_TYPE) {\n\t\tif (reader.state == EF100_TLV_TYPE_CONT)\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"truncated design parameter (incomplete type %u)\\n\",\n\t\t\t\t  reader.type);\n\t\telse\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"truncated design parameter %u\\n\",\n\t\t\t\t  reader.type);\n\t\trc = -EIO;\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int ef100_probe_main(struct efx_nic *efx)\n{\n\tunsigned int bar_size = resource_size(&efx->pci_dev->resource[efx->mem_bar]);\n\tstruct ef100_nic_data *nic_data;\n\tchar fw_version[32];\n\tu32 priv_mask = 0;\n\tint i, rc;\n\n\tif (WARN_ON(bar_size == 0))\n\t\treturn -EIO;\n\n\tnic_data = kzalloc(sizeof(*nic_data), GFP_KERNEL);\n\tif (!nic_data)\n\t\treturn -ENOMEM;\n\tefx->nic_data = nic_data;\n\tnic_data->efx = efx;\n\tefx->max_vis = EF100_MAX_VIS;\n\n\t \n\tnic_data->tso_max_hdr_len = ESE_EF100_DP_GZ_TSO_MAX_HDR_LEN_DEFAULT;\n\tnic_data->tso_max_frames = ESE_EF100_DP_GZ_TSO_MAX_NUM_FRAMES_DEFAULT;\n\tnic_data->tso_max_payload_num_segs = ESE_EF100_DP_GZ_TSO_MAX_PAYLOAD_NUM_SEGS_DEFAULT;\n\tnic_data->tso_max_payload_len = ESE_EF100_DP_GZ_TSO_MAX_PAYLOAD_LEN_DEFAULT;\n\n\t \n\trc = ef100_check_design_params(efx);\n\tif (rc) {\n\t\tpci_err(efx->pci_dev, \"Unsupported design parameters\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tBUILD_BUG_ON(MCDI_CTL_SDU_LEN_MAX_V2 % 4);\n\n\t \n\trc = efx_nic_alloc_buffer(efx, &nic_data->mcdi_buf, MCDI_BUF_LEN,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\ti = 0;\n\tfor (;;) {\n\t\trc = ef100_get_warm_boot_count(efx);\n\t\tif (rc >= 0)\n\t\t\tbreak;\n\t\tif (++i == 5)\n\t\t\tgoto fail;\n\t\tssleep(1);\n\t}\n\tnic_data->warm_boot_count = rc;\n\n\t \n\t_efx_writed(efx, cpu_to_le32(1), efx_reg(efx, ER_GZ_MC_DB_HWRD));\n\n\t \n\n\trc = efx_mcdi_init(efx);\n\tif (rc)\n\t\tgoto fail;\n\t \n\trc = efx_mcdi_reset(efx, RESET_TYPE_ALL);\n\tif (rc)\n\t\tgoto fail;\n\t \n\trc = efx_mcdi_log_ctrl(efx, true, false, 0);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_get_pf_index(efx, &nic_data->pf_index);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_mcdi_port_get_number(efx);\n\tif (rc < 0)\n\t\tgoto fail;\n\tefx->port_num = rc;\n\n\tefx_mcdi_print_fwver(efx, fw_version, sizeof(fw_version));\n\tpci_dbg(efx->pci_dev, \"Firmware version %s\\n\", fw_version);\n\n\trc = efx_mcdi_get_privilege_mask(efx, &priv_mask);\n\tif (rc)  \n\t\tpci_info(efx->pci_dev,\n\t\t\t \"Failed to get privilege mask from FW, rc %d\\n\", rc);\n\tnic_data->grp_mae = !!(priv_mask & MC_CMD_PRIVILEGE_MASK_IN_GRP_MAE);\n\n\tif (compare_versions(fw_version, \"1.1.0.1000\") < 0) {\n\t\tpci_info(efx->pci_dev, \"Firmware uses old event descriptors\\n\");\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (efx_has_cap(efx, UNSOL_EV_CREDIT_SUPPORTED)) {\n\t\tpci_info(efx->pci_dev, \"Firmware uses unsolicited-event credits\\n\");\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\treturn rc;\n}\n\n \nint efx_ef100_lookup_client_id(struct efx_nic *efx, efx_qword_t pciefn, u32 *id)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_CLIENT_HANDLE_OUT_LEN);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_CLIENT_HANDLE_IN_LEN);\n\tu64 pciefn_flat = le64_to_cpu(pciefn.u64[0]);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, GET_CLIENT_HANDLE_IN_TYPE,\n\t\t       MC_CMD_GET_CLIENT_HANDLE_IN_TYPE_FUNC);\n\tMCDI_SET_QWORD(inbuf, GET_CLIENT_HANDLE_IN_FUNC,\n\t\t       pciefn_flat);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_CLIENT_HANDLE, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\t*id = MCDI_DWORD(outbuf, GET_CLIENT_HANDLE_OUT_HANDLE);\n\treturn 0;\n}\n\nint ef100_probe_netdev_pf(struct efx_nic *efx)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tstruct net_device *net_dev = efx->net_dev;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_SFC_SRIOV) || !nic_data->grp_mae)\n\t\treturn 0;\n\n\trc = efx_init_struct_tc(efx);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efx_ef100_get_base_mport(efx);\n\tif (rc) {\n\t\tnetif_warn(efx, probe, net_dev,\n\t\t\t   \"Failed to probe base mport rc %d; representors will not function\\n\",\n\t\t\t   rc);\n\t}\n\n\trc = efx_init_mae(efx);\n\tif (rc)\n\t\tnetif_warn(efx, probe, net_dev,\n\t\t\t   \"Failed to init MAE rc %d; representors will not function\\n\",\n\t\t\t   rc);\n\telse\n\t\tefx_ef100_init_reps(efx);\n\n\trc = efx_init_tc(efx);\n\tif (rc) {\n\t\t \n\t\tnetif_warn(efx, probe, net_dev, \"Failed to probe MAE rc %d\\n\",\n\t\t\t   rc);\n\t} else {\n\t\tnet_dev->features |= NETIF_F_HW_TC;\n\t\tefx->fixed_features |= NETIF_F_HW_TC;\n\t}\n\treturn 0;\n}\n\nint ef100_probe_vf(struct efx_nic *efx)\n{\n\treturn ef100_probe_main(efx);\n}\n\nvoid ef100_remove(struct efx_nic *efx)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\n\tif (IS_ENABLED(CONFIG_SFC_SRIOV) && efx->mae) {\n\t\tefx_ef100_fini_reps(efx);\n\t\tefx_fini_mae(efx);\n\t}\n\n\tefx_mcdi_detach(efx);\n\tefx_mcdi_fini(efx);\n\tif (nic_data)\n\t\tefx_nic_free_buffer(efx, &nic_data->mcdi_buf);\n\tkfree(nic_data);\n\tefx->nic_data = NULL;\n}\n\n \n#define EF100_OFFLOAD_FEATURES\t(NETIF_F_HW_CSUM | NETIF_F_RXCSUM |\t\\\n\tNETIF_F_HIGHDMA | NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_NTUPLE | \\\n\tNETIF_F_RXHASH | NETIF_F_RXFCS | NETIF_F_TSO_ECN | NETIF_F_RXALL | \\\n\tNETIF_F_HW_VLAN_CTAG_TX)\n\nconst struct efx_nic_type ef100_pf_nic_type = {\n\t.revision = EFX_REV_EF100,\n\t.is_vf = false,\n\t.probe = ef100_probe_main,\n\t.offload_features = EF100_OFFLOAD_FEATURES,\n\t.mcdi_max_ver = 2,\n\t.mcdi_request = ef100_mcdi_request,\n\t.mcdi_poll_response = ef100_mcdi_poll_response,\n\t.mcdi_read_response = ef100_mcdi_read_response,\n\t.mcdi_poll_reboot = ef100_mcdi_poll_reboot,\n\t.mcdi_reboot_detected = ef100_mcdi_reboot_detected,\n\t.irq_enable_master = efx_port_dummy_op_void,\n\t.irq_test_generate = efx_ef100_irq_test_generate,\n\t.irq_disable_non_ev = efx_port_dummy_op_void,\n\t.push_irq_moderation = efx_channel_dummy_op_void,\n\t.min_interrupt_mode = EFX_INT_MODE_MSIX,\n\t.map_reset_reason = ef100_map_reset_reason,\n\t.map_reset_flags = ef100_map_reset_flags,\n\t.reset = ef100_reset,\n\n\t.check_caps = ef100_check_caps,\n\n\t.ev_probe = ef100_ev_probe,\n\t.ev_init = ef100_ev_init,\n\t.ev_fini = efx_mcdi_ev_fini,\n\t.ev_remove = efx_mcdi_ev_remove,\n\t.irq_handle_msi = ef100_msi_interrupt,\n\t.ev_process = ef100_ev_process,\n\t.ev_read_ack = ef100_ev_read_ack,\n\t.ev_test_generate = efx_ef100_ev_test_generate,\n\t.tx_probe = ef100_tx_probe,\n\t.tx_init = ef100_tx_init,\n\t.tx_write = ef100_tx_write,\n\t.tx_enqueue = ef100_enqueue_skb,\n\t.rx_probe = efx_mcdi_rx_probe,\n\t.rx_init = efx_mcdi_rx_init,\n\t.rx_remove = efx_mcdi_rx_remove,\n\t.rx_write = ef100_rx_write,\n\t.rx_packet = __ef100_rx_packet,\n\t.rx_buf_hash_valid = ef100_rx_buf_hash_valid,\n\t.fini_dmaq = efx_fini_dmaq,\n\t.max_rx_ip_filters = EFX_MCDI_FILTER_TBL_ROWS,\n\t.filter_table_probe = ef100_filter_table_up,\n\t.filter_table_restore = efx_mcdi_filter_table_restore,\n\t.filter_table_remove = ef100_filter_table_down,\n\t.filter_insert = efx_mcdi_filter_insert,\n\t.filter_remove_safe = efx_mcdi_filter_remove_safe,\n\t.filter_get_safe = efx_mcdi_filter_get_safe,\n\t.filter_clear_rx = efx_mcdi_filter_clear_rx,\n\t.filter_count_rx_used = efx_mcdi_filter_count_rx_used,\n\t.filter_get_rx_id_limit = efx_mcdi_filter_get_rx_id_limit,\n\t.filter_get_rx_ids = efx_mcdi_filter_get_rx_ids,\n#ifdef CONFIG_RFS_ACCEL\n\t.filter_rfs_expire_one = efx_mcdi_filter_rfs_expire_one,\n#endif\n\n\t.get_phys_port_id = efx_ef100_get_phys_port_id,\n\n\t.rx_prefix_size = ESE_GZ_RX_PKT_PREFIX_LEN,\n\t.rx_hash_offset = ESF_GZ_RX_PREFIX_RSS_HASH_LBN / 8,\n\t.rx_ts_offset = ESF_GZ_RX_PREFIX_PARTIAL_TSTAMP_LBN / 8,\n\t.rx_hash_key_size = 40,\n\t.rx_pull_rss_config = efx_mcdi_rx_pull_rss_config,\n\t.rx_push_rss_config = efx_mcdi_pf_rx_push_rss_config,\n\t.rx_push_rss_context_config = efx_mcdi_rx_push_rss_context_config,\n\t.rx_pull_rss_context_config = efx_mcdi_rx_pull_rss_context_config,\n\t.rx_restore_rss_contexts = efx_mcdi_rx_restore_rss_contexts,\n\t.rx_recycle_ring_size = efx_ef100_recycle_ring_size,\n\n\t.reconfigure_mac = ef100_reconfigure_mac,\n\t.reconfigure_port = efx_mcdi_port_reconfigure,\n\t.test_nvram = efx_new_mcdi_nvram_test_all,\n\t.describe_stats = ef100_describe_stats,\n\t.start_stats = efx_mcdi_mac_start_stats,\n\t.update_stats = ef100_update_stats,\n\t.pull_stats = efx_mcdi_mac_pull_stats,\n\t.stop_stats = efx_mcdi_mac_stop_stats,\n\t.sriov_configure = IS_ENABLED(CONFIG_SFC_SRIOV) ?\n\t\tefx_ef100_sriov_configure : NULL,\n\n\t \n\t.mem_bar = NULL,\n\t.mem_map_size = NULL,\n\n};\n\nconst struct efx_nic_type ef100_vf_nic_type = {\n\t.revision = EFX_REV_EF100,\n\t.is_vf = true,\n\t.probe = ef100_probe_vf,\n\t.offload_features = EF100_OFFLOAD_FEATURES,\n\t.mcdi_max_ver = 2,\n\t.mcdi_request = ef100_mcdi_request,\n\t.mcdi_poll_response = ef100_mcdi_poll_response,\n\t.mcdi_read_response = ef100_mcdi_read_response,\n\t.mcdi_poll_reboot = ef100_mcdi_poll_reboot,\n\t.mcdi_reboot_detected = ef100_mcdi_reboot_detected,\n\t.irq_enable_master = efx_port_dummy_op_void,\n\t.irq_test_generate = efx_ef100_irq_test_generate,\n\t.irq_disable_non_ev = efx_port_dummy_op_void,\n\t.push_irq_moderation = efx_channel_dummy_op_void,\n\t.min_interrupt_mode = EFX_INT_MODE_MSIX,\n\t.map_reset_reason = ef100_map_reset_reason,\n\t.map_reset_flags = ef100_map_reset_flags,\n\t.reset = ef100_reset,\n\t.check_caps = ef100_check_caps,\n\t.ev_probe = ef100_ev_probe,\n\t.ev_init = ef100_ev_init,\n\t.ev_fini = efx_mcdi_ev_fini,\n\t.ev_remove = efx_mcdi_ev_remove,\n\t.irq_handle_msi = ef100_msi_interrupt,\n\t.ev_process = ef100_ev_process,\n\t.ev_read_ack = ef100_ev_read_ack,\n\t.ev_test_generate = efx_ef100_ev_test_generate,\n\t.tx_probe = ef100_tx_probe,\n\t.tx_init = ef100_tx_init,\n\t.tx_write = ef100_tx_write,\n\t.tx_enqueue = ef100_enqueue_skb,\n\t.rx_probe = efx_mcdi_rx_probe,\n\t.rx_init = efx_mcdi_rx_init,\n\t.rx_remove = efx_mcdi_rx_remove,\n\t.rx_write = ef100_rx_write,\n\t.rx_packet = __ef100_rx_packet,\n\t.rx_buf_hash_valid = ef100_rx_buf_hash_valid,\n\t.fini_dmaq = efx_fini_dmaq,\n\t.max_rx_ip_filters = EFX_MCDI_FILTER_TBL_ROWS,\n\t.filter_table_probe = ef100_filter_table_up,\n\t.filter_table_restore = efx_mcdi_filter_table_restore,\n\t.filter_table_remove = ef100_filter_table_down,\n\t.filter_insert = efx_mcdi_filter_insert,\n\t.filter_remove_safe = efx_mcdi_filter_remove_safe,\n\t.filter_get_safe = efx_mcdi_filter_get_safe,\n\t.filter_clear_rx = efx_mcdi_filter_clear_rx,\n\t.filter_count_rx_used = efx_mcdi_filter_count_rx_used,\n\t.filter_get_rx_id_limit = efx_mcdi_filter_get_rx_id_limit,\n\t.filter_get_rx_ids = efx_mcdi_filter_get_rx_ids,\n#ifdef CONFIG_RFS_ACCEL\n\t.filter_rfs_expire_one = efx_mcdi_filter_rfs_expire_one,\n#endif\n\n\t.rx_prefix_size = ESE_GZ_RX_PKT_PREFIX_LEN,\n\t.rx_hash_offset = ESF_GZ_RX_PREFIX_RSS_HASH_LBN / 8,\n\t.rx_ts_offset = ESF_GZ_RX_PREFIX_PARTIAL_TSTAMP_LBN / 8,\n\t.rx_hash_key_size = 40,\n\t.rx_pull_rss_config = efx_mcdi_rx_pull_rss_config,\n\t.rx_push_rss_config = efx_mcdi_pf_rx_push_rss_config,\n\t.rx_restore_rss_contexts = efx_mcdi_rx_restore_rss_contexts,\n\t.rx_recycle_ring_size = efx_ef100_recycle_ring_size,\n\n\t.reconfigure_mac = ef100_reconfigure_mac,\n\t.test_nvram = efx_new_mcdi_nvram_test_all,\n\t.describe_stats = ef100_describe_stats,\n\t.start_stats = efx_mcdi_mac_start_stats,\n\t.update_stats = ef100_update_stats,\n\t.pull_stats = efx_mcdi_mac_pull_stats,\n\t.stop_stats = efx_mcdi_mac_stop_stats,\n\n\t.mem_bar = NULL,\n\t.mem_map_size = NULL,\n\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}