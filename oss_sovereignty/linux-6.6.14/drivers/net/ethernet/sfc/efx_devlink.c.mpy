{
  "module_name": "efx_devlink.c",
  "hash_id": "07c8cdcce79c4f9b33486b5959296bce27c31548c6cff2708c7e8a198ff79076",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/efx_devlink.c",
  "human_readable_source": "\n \n\n#include \"net_driver.h\"\n#include \"ef100_nic.h\"\n#include \"efx_devlink.h\"\n#include <linux/rtc.h>\n#include \"mcdi.h\"\n#include \"mcdi_functions.h\"\n#include \"mcdi_pcol.h\"\n#ifdef CONFIG_SFC_SRIOV\n#include \"mae.h\"\n#include \"ef100_rep.h\"\n#endif\n\nstruct efx_devlink {\n\tstruct efx_nic *efx;\n};\n\n#ifdef CONFIG_SFC_SRIOV\n\nstatic int efx_devlink_port_addr_get(struct devlink_port *port, u8 *hw_addr,\n\t\t\t\t     int *hw_addr_len,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct efx_devlink *devlink = devlink_priv(port->devlink);\n\tstruct mae_mport_desc *mport_desc;\n\tefx_qword_t pciefn;\n\tu32 client_id;\n\tint rc = 0;\n\n\tmport_desc = container_of(port, struct mae_mport_desc, dl_port);\n\n\tif (!ef100_mport_on_local_intf(devlink->efx, mport_desc)) {\n\t\trc = -EINVAL;\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"Port not on local interface (mport: %u)\",\n\t\t\t\t   mport_desc->mport_id);\n\t\tgoto out;\n\t}\n\n\tif (ef100_mport_is_vf(mport_desc))\n\t\tEFX_POPULATE_QWORD_3(pciefn,\n\t\t\t\t     PCIE_FUNCTION_PF, PCIE_FUNCTION_PF_NULL,\n\t\t\t\t     PCIE_FUNCTION_VF, mport_desc->vf_idx,\n\t\t\t\t     PCIE_FUNCTION_INTF, PCIE_INTERFACE_CALLER);\n\telse\n\t\tEFX_POPULATE_QWORD_3(pciefn,\n\t\t\t\t     PCIE_FUNCTION_PF, mport_desc->pf_idx,\n\t\t\t\t     PCIE_FUNCTION_VF, PCIE_FUNCTION_VF_NULL,\n\t\t\t\t     PCIE_FUNCTION_INTF, PCIE_INTERFACE_CALLER);\n\n\trc = efx_ef100_lookup_client_id(devlink->efx, pciefn, &client_id);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"No internal client_ID for port (mport: %u)\",\n\t\t\t\t   mport_desc->mport_id);\n\t\tgoto out;\n\t}\n\n\trc = ef100_get_mac_address(devlink->efx, hw_addr, client_id, true);\n\tif (rc != 0)\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"No available MAC for port (mport: %u)\",\n\t\t\t\t   mport_desc->mport_id);\nout:\n\t*hw_addr_len = ETH_ALEN;\n\treturn rc;\n}\n\nstatic int efx_devlink_port_addr_set(struct devlink_port *port,\n\t\t\t\t     const u8 *hw_addr, int hw_addr_len,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_CLIENT_MAC_ADDRESSES_IN_LEN(1));\n\tstruct efx_devlink *devlink = devlink_priv(port->devlink);\n\tstruct mae_mport_desc *mport_desc;\n\tefx_qword_t pciefn;\n\tu32 client_id;\n\tint rc;\n\n\tmport_desc = container_of(port, struct mae_mport_desc, dl_port);\n\n\tif (!ef100_mport_is_vf(mport_desc)) {\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"port mac change not allowed (mport: %u)\",\n\t\t\t\t   mport_desc->mport_id);\n\t\treturn -EPERM;\n\t}\n\n\tEFX_POPULATE_QWORD_3(pciefn,\n\t\t\t     PCIE_FUNCTION_PF, PCIE_FUNCTION_PF_NULL,\n\t\t\t     PCIE_FUNCTION_VF, mport_desc->vf_idx,\n\t\t\t     PCIE_FUNCTION_INTF, PCIE_INTERFACE_CALLER);\n\n\trc = efx_ef100_lookup_client_id(devlink->efx, pciefn, &client_id);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"No internal client_ID for port (mport: %u)\",\n\t\t\t\t   mport_desc->mport_id);\n\t\treturn rc;\n\t}\n\n\tMCDI_SET_DWORD(inbuf, SET_CLIENT_MAC_ADDRESSES_IN_CLIENT_HANDLE,\n\t\t       client_id);\n\n\tether_addr_copy(MCDI_PTR(inbuf, SET_CLIENT_MAC_ADDRESSES_IN_MAC_ADDRS),\n\t\t\thw_addr);\n\n\trc = efx_mcdi_rpc(devlink->efx, MC_CMD_SET_CLIENT_MAC_ADDRESSES, inbuf,\n\t\t\t  sizeof(inbuf), NULL, 0, NULL);\n\tif (rc)\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"sfc MC_CMD_SET_CLIENT_MAC_ADDRESSES mcdi error (mport: %u)\",\n\t\t\t\t   mport_desc->mport_id);\n\n\treturn rc;\n}\n\nstatic const struct devlink_port_ops sfc_devlink_port_ops = {\n\t.port_fn_hw_addr_get = efx_devlink_port_addr_get,\n\t.port_fn_hw_addr_set = efx_devlink_port_addr_set,\n};\n\nstatic void efx_devlink_del_port(struct devlink_port *dl_port)\n{\n\tif (!dl_port)\n\t\treturn;\n\tdevl_port_unregister(dl_port);\n}\n\nstatic int efx_devlink_add_port(struct efx_nic *efx,\n\t\t\t\tstruct mae_mport_desc *mport)\n{\n\tbool external = false;\n\n\tif (!ef100_mport_on_local_intf(efx, mport))\n\t\texternal = true;\n\n\tswitch (mport->mport_type) {\n\tcase MAE_MPORT_DESC_MPORT_TYPE_VNIC:\n\t\tif (mport->vf_idx != MAE_MPORT_DESC_VF_IDX_NULL)\n\t\t\tdevlink_port_attrs_pci_vf_set(&mport->dl_port, 0, mport->pf_idx,\n\t\t\t\t\t\t      mport->vf_idx,\n\t\t\t\t\t\t      external);\n\t\telse\n\t\t\tdevlink_port_attrs_pci_pf_set(&mport->dl_port, 0, mport->pf_idx,\n\t\t\t\t\t\t      external);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\tmport->dl_port.index = mport->mport_id;\n\n\treturn devl_port_register_with_ops(efx->devlink, &mport->dl_port,\n\t\t\t\t\t   mport->mport_id,\n\t\t\t\t\t   &sfc_devlink_port_ops);\n}\n\n#endif\n\nstatic int efx_devlink_info_nvram_partition(struct efx_nic *efx,\n\t\t\t\t\t    struct devlink_info_req *req,\n\t\t\t\t\t    unsigned int partition_type,\n\t\t\t\t\t    const char *version_name)\n{\n\tchar buf[EFX_MAX_VERSION_INFO_LEN];\n\tu16 version[4];\n\tint rc;\n\n\trc = efx_mcdi_nvram_metadata(efx, partition_type, NULL, version, NULL,\n\t\t\t\t     0);\n\n\t \n\tif (rc == -ENOENT)\n\t\treturn 0;\n\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev, \"mcdi nvram %s: failed (rc=%d)\\n\",\n\t\t\t  version_name, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\", version[0],\n\t\t version[1], version[2], version[3]);\n\tdevlink_info_version_stored_put(req, version_name, buf);\n\n\treturn 0;\n}\n\nstatic int efx_devlink_info_stored_versions(struct efx_nic *efx,\n\t\t\t\t\t    struct devlink_info_req *req)\n{\n\tint err;\n\n\t \n\terr = efx_devlink_info_nvram_partition(efx, req,\n\t\t\t\t\t       NVRAM_PARTITION_TYPE_BUNDLE,\n\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_FW_BUNDLE_ID);\n\n\terr |= efx_devlink_info_nvram_partition(efx, req,\n\t\t\t\t\t\tNVRAM_PARTITION_TYPE_MC_FIRMWARE,\n\t\t\t\t\t\tDEVLINK_INFO_VERSION_GENERIC_FW_MGMT);\n\n\terr |= efx_devlink_info_nvram_partition(efx, req,\n\t\t\t\t\t\tNVRAM_PARTITION_TYPE_SUC_FIRMWARE,\n\t\t\t\t\t\tEFX_DEVLINK_INFO_VERSION_FW_MGMT_SUC);\n\n\terr |= efx_devlink_info_nvram_partition(efx, req,\n\t\t\t\t\t\tNVRAM_PARTITION_TYPE_EXPANSION_ROM,\n\t\t\t\t\t\tEFX_DEVLINK_INFO_VERSION_FW_EXPROM);\n\n\terr |= efx_devlink_info_nvram_partition(efx, req,\n\t\t\t\t\t\tNVRAM_PARTITION_TYPE_EXPANSION_UEFI,\n\t\t\t\t\t\tEFX_DEVLINK_INFO_VERSION_FW_UEFI);\n\treturn err;\n}\n\n#define EFX_VER_FLAG(_f)\t\\\n\t(MC_CMD_GET_VERSION_V5_OUT_ ## _f ## _PRESENT_LBN)\n\nstatic void efx_devlink_info_running_v2(struct efx_nic *efx,\n\t\t\t\t\tstruct devlink_info_req *req,\n\t\t\t\t\tunsigned int flags, efx_dword_t *outbuf)\n{\n\tchar buf[EFX_MAX_VERSION_INFO_LEN];\n\tunion {\n\t\tconst __le32 *dwords;\n\t\tconst __le16 *words;\n\t\tconst char *str;\n\t} ver;\n\tstruct rtc_time build_date;\n\tunsigned int build_id;\n\tsize_t offset;\n\t__maybe_unused u64 tstamp;\n\n\tif (flags & BIT(EFX_VER_FLAG(BOARD_EXT_INFO))) {\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%s\",\n\t\t\t MCDI_PTR(outbuf, GET_VERSION_V2_OUT_BOARD_NAME));\n\t\tdevlink_info_version_fixed_put(req,\n\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_BOARD_ID,\n\t\t\t\t\t       buf);\n\n\t\t \n\t\tif (~flags & BIT(EFX_VER_FLAG(BOARD_VERSION))) {\n\t\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u\",\n\t\t\t\t MCDI_DWORD(outbuf,\n\t\t\t\t\t    GET_VERSION_V2_OUT_BOARD_REVISION));\n\t\t\tdevlink_info_version_fixed_put(req,\n\t\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_BOARD_REV,\n\t\t\t\t\t\t       buf);\n\t\t}\n\n\t\tver.str = MCDI_PTR(outbuf, GET_VERSION_V2_OUT_BOARD_SERIAL);\n\t\tif (ver.str[0])\n\t\t\tdevlink_info_board_serial_number_put(req, ver.str);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(FPGA_EXT_INFO))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V2_OUT_FPGA_VERSION);\n\t\toffset = snprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u_%c%u\",\n\t\t\t\t  le32_to_cpu(ver.dwords[0]),\n\t\t\t\t  'A' + le32_to_cpu(ver.dwords[1]),\n\t\t\t\t  le32_to_cpu(ver.dwords[2]));\n\n\t\tver.str = MCDI_PTR(outbuf, GET_VERSION_V2_OUT_FPGA_EXTRA);\n\t\tif (ver.str[0])\n\t\t\tsnprintf(&buf[offset], EFX_MAX_VERSION_INFO_LEN - offset,\n\t\t\t\t \" (%s)\", ver.str);\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_FPGA_REV,\n\t\t\t\t\t\t buf);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(CMC_EXT_INFO))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V2_OUT_CMCFW_VERSION);\n\t\toffset = snprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t\t  le32_to_cpu(ver.dwords[0]),\n\t\t\t\t  le32_to_cpu(ver.dwords[1]),\n\t\t\t\t  le32_to_cpu(ver.dwords[2]),\n\t\t\t\t  le32_to_cpu(ver.dwords[3]));\n\n#ifdef CONFIG_RTC_LIB\n\t\ttstamp = MCDI_QWORD(outbuf,\n\t\t\t\t    GET_VERSION_V2_OUT_CMCFW_BUILD_DATE);\n\t\tif (tstamp) {\n\t\t\trtc_time64_to_tm(tstamp, &build_date);\n\t\t\tsnprintf(&buf[offset], EFX_MAX_VERSION_INFO_LEN - offset,\n\t\t\t\t \" (%ptRd)\", &build_date);\n\t\t}\n#endif\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_FW_MGMT_CMC,\n\t\t\t\t\t\t buf);\n\t}\n\n\tver.words = (__le16 *)MCDI_PTR(outbuf, GET_VERSION_V2_OUT_VERSION);\n\toffset = snprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t  le16_to_cpu(ver.words[0]), le16_to_cpu(ver.words[1]),\n\t\t\t  le16_to_cpu(ver.words[2]), le16_to_cpu(ver.words[3]));\n\tif (flags & BIT(EFX_VER_FLAG(MCFW_EXT_INFO))) {\n\t\tbuild_id = MCDI_DWORD(outbuf, GET_VERSION_V2_OUT_MCFW_BUILD_ID);\n\t\tsnprintf(&buf[offset], EFX_MAX_VERSION_INFO_LEN - offset,\n\t\t\t \" (%x) %s\", build_id,\n\t\t\t MCDI_PTR(outbuf, GET_VERSION_V2_OUT_MCFW_BUILD_NAME));\n\t}\n\tdevlink_info_version_running_put(req,\n\t\t\t\t\t DEVLINK_INFO_VERSION_GENERIC_FW_MGMT,\n\t\t\t\t\t buf);\n\n\tif (flags & BIT(EFX_VER_FLAG(SUCFW_EXT_INFO))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V2_OUT_SUCFW_VERSION);\n#ifdef CONFIG_RTC_LIB\n\t\ttstamp = MCDI_QWORD(outbuf,\n\t\t\t\t    GET_VERSION_V2_OUT_SUCFW_BUILD_DATE);\n\t\trtc_time64_to_tm(tstamp, &build_date);\n#else\n\t\tmemset(&build_date, 0, sizeof(build_date));\n#endif\n\t\tbuild_id = MCDI_DWORD(outbuf, GET_VERSION_V2_OUT_SUCFW_CHIP_ID);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN,\n\t\t\t \"%u.%u.%u.%u type %x (%ptRd)\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]), le32_to_cpu(ver.dwords[3]),\n\t\t\t build_id, &build_date);\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_FW_MGMT_SUC,\n\t\t\t\t\t\t buf);\n\t}\n}\n\nstatic void efx_devlink_info_running_v3(struct efx_nic *efx,\n\t\t\t\t\tstruct devlink_info_req *req,\n\t\t\t\t\tunsigned int flags, efx_dword_t *outbuf)\n{\n\tchar buf[EFX_MAX_VERSION_INFO_LEN];\n\tunion {\n\t\tconst __le32 *dwords;\n\t\tconst __le16 *words;\n\t\tconst char *str;\n\t} ver;\n\n\tif (flags & BIT(EFX_VER_FLAG(DATAPATH_HW_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V3_OUT_DATAPATH_HW_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_DATAPATH_HW,\n\t\t\t\t\t\t buf);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(DATAPATH_FW_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V3_OUT_DATAPATH_FW_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_DATAPATH_FW,\n\t\t\t\t\t\t buf);\n\t}\n}\n\nstatic void efx_devlink_info_running_v4(struct efx_nic *efx,\n\t\t\t\t\tstruct devlink_info_req *req,\n\t\t\t\t\tunsigned int flags, efx_dword_t *outbuf)\n{\n\tchar buf[EFX_MAX_VERSION_INFO_LEN];\n\tunion {\n\t\tconst __le32 *dwords;\n\t\tconst __le16 *words;\n\t\tconst char *str;\n\t} ver;\n\n\tif (flags & BIT(EFX_VER_FLAG(SOC_BOOT_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V4_OUT_SOC_BOOT_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]),\n\t\t\t le32_to_cpu(ver.dwords[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_SOC_BOOT,\n\t\t\t\t\t\t buf);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(SOC_UBOOT_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V4_OUT_SOC_UBOOT_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]),\n\t\t\t le32_to_cpu(ver.dwords[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_SOC_UBOOT,\n\t\t\t\t\t\t buf);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(SOC_MAIN_ROOTFS_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\tGET_VERSION_V4_OUT_SOC_MAIN_ROOTFS_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]),\n\t\t\t le32_to_cpu(ver.dwords[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_SOC_MAIN,\n\t\t\t\t\t\t buf);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(SOC_RECOVERY_BUILDROOT_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V4_OUT_SOC_RECOVERY_BUILDROOT_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]),\n\t\t\t le32_to_cpu(ver.dwords[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_SOC_RECOVERY,\n\t\t\t\t\t\t buf);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(SUCFW_VERSION)) &&\n\t    ~flags & BIT(EFX_VER_FLAG(SUCFW_EXT_INFO))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V4_OUT_SUCFW_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]),\n\t\t\t le32_to_cpu(ver.dwords[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t EFX_DEVLINK_INFO_VERSION_FW_MGMT_SUC,\n\t\t\t\t\t\t buf);\n\t}\n}\n\nstatic void efx_devlink_info_running_v5(struct efx_nic *efx,\n\t\t\t\t\tstruct devlink_info_req *req,\n\t\t\t\t\tunsigned int flags, efx_dword_t *outbuf)\n{\n\tchar buf[EFX_MAX_VERSION_INFO_LEN];\n\tunion {\n\t\tconst __le32 *dwords;\n\t\tconst __le16 *words;\n\t\tconst char *str;\n\t} ver;\n\n\tif (flags & BIT(EFX_VER_FLAG(BOARD_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V5_OUT_BOARD_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]),\n\t\t\t le32_to_cpu(ver.dwords[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t DEVLINK_INFO_VERSION_GENERIC_BOARD_REV,\n\t\t\t\t\t\t buf);\n\t}\n\n\tif (flags & BIT(EFX_VER_FLAG(BUNDLE_VERSION))) {\n\t\tver.dwords = (__le32 *)MCDI_PTR(outbuf,\n\t\t\t\t\t\tGET_VERSION_V5_OUT_BUNDLE_VERSION);\n\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le32_to_cpu(ver.dwords[0]), le32_to_cpu(ver.dwords[1]),\n\t\t\t le32_to_cpu(ver.dwords[2]),\n\t\t\t le32_to_cpu(ver.dwords[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t DEVLINK_INFO_VERSION_GENERIC_FW_BUNDLE_ID,\n\t\t\t\t\t\t buf);\n\t}\n}\n\nstatic int efx_devlink_info_running_versions(struct efx_nic *efx,\n\t\t\t\t\t     struct devlink_info_req *req)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_VERSION_V5_OUT_LEN);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_VERSION_EXT_IN_LEN);\n\tchar buf[EFX_MAX_VERSION_INFO_LEN];\n\tunion {\n\t\tconst __le32 *dwords;\n\t\tconst __le16 *words;\n\t\tconst char *str;\n\t} ver;\n\tsize_t outlength;\n\tunsigned int flags;\n\tint rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_VERSION, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlength);\n\tif (rc || outlength < MC_CMD_GET_VERSION_OUT_LEN) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"mcdi MC_CMD_GET_VERSION failed\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (outlength < MC_CMD_GET_VERSION_V2_OUT_LEN) {\n\t\tver.words = (__le16 *)MCDI_PTR(outbuf,\n\t\t\t\t\t       GET_VERSION_EXT_OUT_VERSION);\n\t\tsnprintf(buf, EFX_MAX_VERSION_INFO_LEN, \"%u.%u.%u.%u\",\n\t\t\t le16_to_cpu(ver.words[0]),\n\t\t\t le16_to_cpu(ver.words[1]),\n\t\t\t le16_to_cpu(ver.words[2]),\n\t\t\t le16_to_cpu(ver.words[3]));\n\n\t\tdevlink_info_version_running_put(req,\n\t\t\t\t\t\t DEVLINK_INFO_VERSION_GENERIC_FW_MGMT,\n\t\t\t\t\t\t buf);\n\t\treturn 0;\n\t}\n\n\t \n\tflags = MCDI_DWORD(outbuf, GET_VERSION_V2_OUT_FLAGS);\n\tefx_devlink_info_running_v2(efx, req, flags, outbuf);\n\n\tif (outlength < MC_CMD_GET_VERSION_V3_OUT_LEN)\n\t\treturn 0;\n\n\t \n\tefx_devlink_info_running_v3(efx, req, flags, outbuf);\n\n\tif (outlength < MC_CMD_GET_VERSION_V4_OUT_LEN)\n\t\treturn 0;\n\n\t \n\tefx_devlink_info_running_v4(efx, req, flags, outbuf);\n\n\tif (outlength < MC_CMD_GET_VERSION_V5_OUT_LEN)\n\t\treturn 0;\n\n\t \n\tefx_devlink_info_running_v5(efx, req, flags, outbuf);\n\n\treturn 0;\n}\n\n#define EFX_MAX_SERIALNUM_LEN\t(ETH_ALEN * 2 + 1)\n\nstatic int efx_devlink_info_board_cfg(struct efx_nic *efx,\n\t\t\t\t      struct devlink_info_req *req)\n{\n\tchar sn[EFX_MAX_SERIALNUM_LEN];\n\tu8 mac_address[ETH_ALEN];\n\tint rc;\n\n\trc = efx_mcdi_get_board_cfg(efx, (u8 *)mac_address, NULL, NULL);\n\tif (!rc) {\n\t\tsnprintf(sn, EFX_MAX_SERIALNUM_LEN, \"%pm\", mac_address);\n\t\tdevlink_info_serial_number_put(req, sn);\n\t}\n\treturn rc;\n}\n\nstatic int efx_devlink_info_get(struct devlink *devlink,\n\t\t\t\tstruct devlink_info_req *req,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct efx_devlink *devlink_private = devlink_priv(devlink);\n\tstruct efx_nic *efx = devlink_private->efx;\n\tint err;\n\n\t \n\terr = efx_devlink_info_board_cfg(efx, req);\n\n\terr |= efx_devlink_info_stored_versions(efx, req);\n\n\terr |= efx_devlink_info_running_versions(efx, req);\n\n\tif (err)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Errors when getting device info. Check system messages\");\n\n\treturn 0;\n}\n\nstatic const struct devlink_ops sfc_devlink_ops = {\n\t.info_get\t\t\t= efx_devlink_info_get,\n};\n\n#ifdef CONFIG_SFC_SRIOV\nstatic struct devlink_port *ef100_set_devlink_port(struct efx_nic *efx, u32 idx)\n{\n\tstruct mae_mport_desc *mport;\n\tu32 id;\n\tint rc;\n\n\tif (!efx->mae)\n\t\treturn NULL;\n\n\tif (efx_mae_lookup_mport(efx, idx, &id)) {\n\t\t \n\t\tif (idx == MAE_MPORT_DESC_VF_IDX_NULL)\n\t\t\tpci_warn_once(efx->pci_dev, \"No mport ID found for PF.\\n\");\n\t\telse\n\t\t\tpci_warn_once(efx->pci_dev, \"No mport ID found for VF %u.\\n\",\n\t\t\t\t      idx);\n\t\treturn NULL;\n\t}\n\n\tmport = efx_mae_get_mport(efx, id);\n\tif (!mport) {\n\t\t \n\t\tif (idx == MAE_MPORT_DESC_VF_IDX_NULL)\n\t\t\tpci_warn_once(efx->pci_dev, \"No mport found for PF.\\n\");\n\t\telse\n\t\t\tpci_warn_once(efx->pci_dev, \"No mport found for VF %u.\\n\",\n\t\t\t\t      idx);\n\t\treturn NULL;\n\t}\n\n\trc = efx_devlink_add_port(efx, mport);\n\tif (rc) {\n\t\tif (idx == MAE_MPORT_DESC_VF_IDX_NULL)\n\t\t\tpci_warn(efx->pci_dev,\n\t\t\t\t \"devlink port creation for PF failed.\\n\");\n\t\telse\n\t\t\tpci_warn(efx->pci_dev,\n\t\t\t\t \"devlink_port creation for VF %u failed.\\n\",\n\t\t\t\t idx);\n\t\treturn NULL;\n\t}\n\n\treturn &mport->dl_port;\n}\n\nvoid ef100_rep_set_devlink_port(struct efx_rep *efv)\n{\n\tefv->dl_port = ef100_set_devlink_port(efv->parent, efv->idx);\n}\n\nvoid ef100_pf_set_devlink_port(struct efx_nic *efx)\n{\n\tefx->dl_port = ef100_set_devlink_port(efx, MAE_MPORT_DESC_VF_IDX_NULL);\n}\n\nvoid ef100_rep_unset_devlink_port(struct efx_rep *efv)\n{\n\tefx_devlink_del_port(efv->dl_port);\n}\n\nvoid ef100_pf_unset_devlink_port(struct efx_nic *efx)\n{\n\tefx_devlink_del_port(efx->dl_port);\n}\n#endif\n\nvoid efx_fini_devlink_lock(struct efx_nic *efx)\n{\n\tif (efx->devlink)\n\t\tdevl_lock(efx->devlink);\n}\n\nvoid efx_fini_devlink_and_unlock(struct efx_nic *efx)\n{\n\tif (efx->devlink) {\n\t\tdevl_unregister(efx->devlink);\n\t\tdevl_unlock(efx->devlink);\n\t\tdevlink_free(efx->devlink);\n\t\tefx->devlink = NULL;\n\t}\n}\n\nint efx_probe_devlink_and_lock(struct efx_nic *efx)\n{\n\tstruct efx_devlink *devlink_private;\n\n\tif (efx->type->is_vf)\n\t\treturn 0;\n\n\tefx->devlink = devlink_alloc(&sfc_devlink_ops,\n\t\t\t\t     sizeof(struct efx_devlink),\n\t\t\t\t     &efx->pci_dev->dev);\n\tif (!efx->devlink)\n\t\treturn -ENOMEM;\n\n\tdevl_lock(efx->devlink);\n\tdevlink_private = devlink_priv(efx->devlink);\n\tdevlink_private->efx = efx;\n\n\tdevl_register(efx->devlink);\n\n\treturn 0;\n}\n\nvoid efx_probe_devlink_unlock(struct efx_nic *efx)\n{\n\tif (!efx->devlink)\n\t\treturn;\n\n\tdevl_unlock(efx->devlink);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}