{
  "module_name": "tc.c",
  "hash_id": "e85cbedf6dd0c080f3deaac163a7d3010d669cb1ad0ad3a51af4b61bd3ea0ea8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/tc.c",
  "human_readable_source": "\n \n\n#include <net/pkt_cls.h>\n#include <net/vxlan.h>\n#include <net/geneve.h>\n#include <net/tc_act/tc_ct.h>\n#include \"tc.h\"\n#include \"tc_bindings.h\"\n#include \"tc_encap_actions.h\"\n#include \"tc_conntrack.h\"\n#include \"mae.h\"\n#include \"ef100_rep.h\"\n#include \"efx.h\"\n\nenum efx_encap_type efx_tc_indr_netdev_type(struct net_device *net_dev)\n{\n\tif (netif_is_vxlan(net_dev))\n\t\treturn EFX_ENCAP_TYPE_VXLAN;\n\tif (netif_is_geneve(net_dev))\n\t\treturn EFX_ENCAP_TYPE_GENEVE;\n\n\treturn EFX_ENCAP_TYPE_NONE;\n}\n\n#define EFX_TC_HDR_TYPE_TTL_MASK ((u32)0xff)\n \n#define EFX_TC_HDR_TYPE_HLIMIT_MASK ~((u32)0xff000000)\n#define EFX_EFV_PF\tNULL\n \nstruct efx_rep *efx_tc_flower_lookup_efv(struct efx_nic *efx,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct efx_rep *efv;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t \n\tif (dev == efx->net_dev)\n\t\treturn EFX_EFV_PF;\n\t \n\tif (dev->netdev_ops != &efx_ef100_rep_netdev_ops)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t \n\tefv = netdev_priv(dev);\n\tif (efv->parent != efx)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\treturn efv;\n}\n\n \nstatic s64 efx_tc_flower_internal_mport(struct efx_nic *efx, struct efx_rep *efv)\n{\n\tu32 mport;\n\n\tif (IS_ERR(efv))\n\t\treturn PTR_ERR(efv);\n\tif (!efv)  \n\t\tefx_mae_mport_uplink(efx, &mport);\n\telse  \n\t\tefx_mae_mport_mport(efx, efv->mport, &mport);\n\treturn mport;\n}\n\n \ns64 efx_tc_flower_external_mport(struct efx_nic *efx, struct efx_rep *efv)\n{\n\tu32 mport;\n\n\tif (IS_ERR(efv))\n\t\treturn PTR_ERR(efv);\n\tif (!efv)  \n\t\tefx_mae_mport_wire(efx, &mport);\n\telse  \n\t\tefx_mae_mport_mport(efx, efv->mport, &mport);\n\treturn mport;\n}\n\nstatic const struct rhashtable_params efx_tc_mac_ht_params = {\n\t.key_len\t= offsetofend(struct efx_tc_mac_pedit_action, h_addr),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_mac_pedit_action, linkage),\n};\n\nstatic const struct rhashtable_params efx_tc_encap_match_ht_params = {\n\t.key_len\t= offsetof(struct efx_tc_encap_match, linkage),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_encap_match, linkage),\n};\n\nstatic const struct rhashtable_params efx_tc_match_action_ht_params = {\n\t.key_len\t= sizeof(unsigned long),\n\t.key_offset\t= offsetof(struct efx_tc_flow_rule, cookie),\n\t.head_offset\t= offsetof(struct efx_tc_flow_rule, linkage),\n};\n\nstatic const struct rhashtable_params efx_tc_lhs_rule_ht_params = {\n\t.key_len\t= sizeof(unsigned long),\n\t.key_offset\t= offsetof(struct efx_tc_lhs_rule, cookie),\n\t.head_offset\t= offsetof(struct efx_tc_lhs_rule, linkage),\n};\n\nstatic const struct rhashtable_params efx_tc_recirc_ht_params = {\n\t.key_len\t= offsetof(struct efx_tc_recirc_id, linkage),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_recirc_id, linkage),\n};\n\nstatic struct efx_tc_mac_pedit_action *efx_tc_flower_get_mac(struct efx_nic *efx,\n\t\t\t\t\t\t\t     unsigned char h_addr[ETH_ALEN],\n\t\t\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct efx_tc_mac_pedit_action *ped, *old;\n\tint rc;\n\n\tped = kzalloc(sizeof(*ped), GFP_USER);\n\tif (!ped)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmemcpy(ped->h_addr, h_addr, ETH_ALEN);\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->mac_ht,\n\t\t\t\t\t\t&ped->linkage,\n\t\t\t\t\t\tefx_tc_mac_ht_params);\n\tif (old) {\n\t\t \n\t\tkfree(ped);\n\t\tif (IS_ERR(old))  \n\t\t\treturn ERR_CAST(old);\n\t\tif (!refcount_inc_not_zero(&old->ref))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t \n\t\treturn old;\n\t}\n\n\trc = efx_mae_allocate_pedit_mac(efx, ped);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to store pedit MAC address in hw\");\n\t\tgoto out_remove;\n\t}\n\n\t \n\trefcount_set(&ped->ref, 1);\n\treturn ped;\nout_remove:\n\trhashtable_remove_fast(&efx->tc->mac_ht, &ped->linkage,\n\t\t\t       efx_tc_mac_ht_params);\n\tkfree(ped);\n\treturn ERR_PTR(rc);\n}\n\nstatic void efx_tc_flower_put_mac(struct efx_nic *efx,\n\t\t\t\t  struct efx_tc_mac_pedit_action *ped)\n{\n\tif (!refcount_dec_and_test(&ped->ref))\n\t\treturn;  \n\trhashtable_remove_fast(&efx->tc->mac_ht, &ped->linkage,\n\t\t\t       efx_tc_mac_ht_params);\n\tefx_mae_free_pedit_mac(efx, ped);\n\tkfree(ped);\n}\n\nstatic void efx_tc_free_action_set(struct efx_nic *efx,\n\t\t\t\t   struct efx_tc_action_set *act, bool in_hw)\n{\n\t \n\tif (in_hw) {\n\t\tefx_mae_free_action_set(efx, act->fw_id);\n\t\t \n\t\tlist_del(&act->list);\n\t}\n\tif (act->count) {\n\t\tspin_lock_bh(&act->count->cnt->lock);\n\t\tif (!list_empty(&act->count_user))\n\t\t\tlist_del(&act->count_user);\n\t\tspin_unlock_bh(&act->count->cnt->lock);\n\t\tefx_tc_flower_put_counter_index(efx, act->count);\n\t}\n\tif (act->encap_md) {\n\t\tlist_del(&act->encap_user);\n\t\tefx_tc_flower_release_encap_md(efx, act->encap_md);\n\t}\n\tif (act->src_mac)\n\t\tefx_tc_flower_put_mac(efx, act->src_mac);\n\tif (act->dst_mac)\n\t\tefx_tc_flower_put_mac(efx, act->dst_mac);\n\tkfree(act);\n}\n\nstatic void efx_tc_free_action_set_list(struct efx_nic *efx,\n\t\t\t\t\tstruct efx_tc_action_set_list *acts,\n\t\t\t\t\tbool in_hw)\n{\n\tstruct efx_tc_action_set *act, *next;\n\n\t \n\tif (in_hw)\n\t\tefx_mae_free_action_set_list(efx, acts);\n\t \n\tlist_for_each_entry_safe(act, next, &acts->list, list)\n\t\tefx_tc_free_action_set(efx, act, true);\n\t \n}\n\n \n#define _MAP_KEY_AND_MASK(_name, _type, _tcget, _tcfield, _field)\t\\\nif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_##_name)) {\t\t\\\n\tstruct flow_match_##_type fm;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tflow_rule_match_##_tcget(rule, &fm);\t\t\t\t\\\n\tmatch->value._field = fm.key->_tcfield;\t\t\t\t\\\n\tmatch->mask._field = fm.mask->_tcfield;\t\t\t\t\\\n}\n#define MAP_KEY_AND_MASK(_name, _type, _tcfield, _field)\t\\\n\t_MAP_KEY_AND_MASK(_name, _type, _type, _tcfield, _field)\n#define MAP_ENC_KEY_AND_MASK(_name, _type, _tcget, _tcfield, _field)\t\\\n\t_MAP_KEY_AND_MASK(ENC_##_name, _type, _tcget, _tcfield, _field)\n\nstatic int efx_tc_flower_parse_match(struct efx_nic *efx,\n\t\t\t\t     struct flow_rule *rule,\n\t\t\t\t     struct efx_tc_match *match,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tunsigned char ipv = 0;\n\n\t \n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control fm;\n\n\t\tflow_rule_match_control(rule, &fm);\n\t\tif (IS_ALL_ONES(fm.mask->addr_type))\n\t\t\tswitch (fm.key->addr_type) {\n\t\t\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\t\t\tipv = 4;\n\t\t\t\tbreak;\n\t\t\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\t\t\tipv = 6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (fm.mask->flags & FLOW_DIS_IS_FRAGMENT) {\n\t\t\tmatch->value.ip_frag = fm.key->flags & FLOW_DIS_IS_FRAGMENT;\n\t\t\tmatch->mask.ip_frag = true;\n\t\t}\n\t\tif (fm.mask->flags & FLOW_DIS_FIRST_FRAG) {\n\t\t\tmatch->value.ip_firstfrag = fm.key->flags & FLOW_DIS_FIRST_FRAG;\n\t\t\tmatch->mask.ip_firstfrag = true;\n\t\t}\n\t\tif (fm.mask->flags & ~(FLOW_DIS_IS_FRAGMENT | FLOW_DIS_FIRST_FRAG)) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unsupported match on control.flags %#x\",\n\t\t\t\t\t       fm.mask->flags);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CVLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_KEYID) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ENC_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CT) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_TCP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IP))) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unsupported flower keys %#llx\",\n\t\t\t\t       dissector->used_keys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tMAP_KEY_AND_MASK(BASIC, basic, n_proto, eth_proto);\n\t \n\tif (!IS_ALL_ONES(match->mask.eth_proto) ||\n\t    !(match->value.eth_proto == htons(ETH_P_IP) ||\n\t      match->value.eth_proto == htons(ETH_P_IPV6)))\n\t\tif (dissector->used_keys &\n\t\t    (BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_IP) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_TCP))) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"L3/L4 flower keys %#llx require protocol ipv[46]\",\n\t\t\t\t\t       dissector->used_keys);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan fm;\n\n\t\tflow_rule_match_vlan(rule, &fm);\n\t\tif (fm.mask->vlan_id || fm.mask->vlan_priority || fm.mask->vlan_tpid) {\n\t\t\tmatch->value.vlan_proto[0] = fm.key->vlan_tpid;\n\t\t\tmatch->mask.vlan_proto[0] = fm.mask->vlan_tpid;\n\t\t\tmatch->value.vlan_tci[0] = cpu_to_be16(fm.key->vlan_priority << 13 |\n\t\t\t\t\t\t\t       fm.key->vlan_id);\n\t\t\tmatch->mask.vlan_tci[0] = cpu_to_be16(fm.mask->vlan_priority << 13 |\n\t\t\t\t\t\t\t      fm.mask->vlan_id);\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {\n\t\tstruct flow_match_vlan fm;\n\n\t\tflow_rule_match_cvlan(rule, &fm);\n\t\tif (fm.mask->vlan_id || fm.mask->vlan_priority || fm.mask->vlan_tpid) {\n\t\t\tmatch->value.vlan_proto[1] = fm.key->vlan_tpid;\n\t\t\tmatch->mask.vlan_proto[1] = fm.mask->vlan_tpid;\n\t\t\tmatch->value.vlan_tci[1] = cpu_to_be16(fm.key->vlan_priority << 13 |\n\t\t\t\t\t\t\t       fm.key->vlan_id);\n\t\t\tmatch->mask.vlan_tci[1] = cpu_to_be16(fm.mask->vlan_priority << 13 |\n\t\t\t\t\t\t\t      fm.mask->vlan_id);\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs fm;\n\n\t\tflow_rule_match_eth_addrs(rule, &fm);\n\t\tether_addr_copy(match->value.eth_saddr, fm.key->src);\n\t\tether_addr_copy(match->value.eth_daddr, fm.key->dst);\n\t\tether_addr_copy(match->mask.eth_saddr, fm.mask->src);\n\t\tether_addr_copy(match->mask.eth_daddr, fm.mask->dst);\n\t}\n\n\tMAP_KEY_AND_MASK(BASIC, basic, ip_proto, ip_proto);\n\t \n\tif ((match->value.ip_proto != IPPROTO_UDP &&\n\t     match->value.ip_proto != IPPROTO_TCP) || !IS_ALL_ONES(match->mask.ip_proto))\n\t\tif (dissector->used_keys &\n\t\t    (BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_TCP))) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"L4 flower keys %#llx require ipproto udp or tcp\",\n\t\t\t\t\t       dissector->used_keys);\n\t\t\treturn -EINVAL;\n\t\t}\n\tMAP_KEY_AND_MASK(IP, ip, tos, ip_tos);\n\tMAP_KEY_AND_MASK(IP, ip, ttl, ip_ttl);\n\tif (ipv == 4) {\n\t\tMAP_KEY_AND_MASK(IPV4_ADDRS, ipv4_addrs, src, src_ip);\n\t\tMAP_KEY_AND_MASK(IPV4_ADDRS, ipv4_addrs, dst, dst_ip);\n\t}\n#ifdef CONFIG_IPV6\n\telse if (ipv == 6) {\n\t\tMAP_KEY_AND_MASK(IPV6_ADDRS, ipv6_addrs, src, src_ip6);\n\t\tMAP_KEY_AND_MASK(IPV6_ADDRS, ipv6_addrs, dst, dst_ip6);\n\t}\n#endif\n\tMAP_KEY_AND_MASK(PORTS, ports, src, l4_sport);\n\tMAP_KEY_AND_MASK(PORTS, ports, dst, l4_dport);\n\tMAP_KEY_AND_MASK(TCP, tcp, flags, tcp_flags);\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_CONTROL)) {\n\t\tstruct flow_match_control fm;\n\n\t\tflow_rule_match_enc_control(rule, &fm);\n\t\tif (fm.mask->flags) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unsupported match on enc_control.flags %#x\",\n\t\t\t\t\t       fm.mask->flags);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!IS_ALL_ONES(fm.mask->addr_type)) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unsupported enc addr_type mask %u (key %u)\",\n\t\t\t\t\t       fm.mask->addr_type,\n\t\t\t\t\t       fm.key->addr_type);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tswitch (fm.key->addr_type) {\n\t\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\t\tMAP_ENC_KEY_AND_MASK(IPV4_ADDRS, ipv4_addrs, enc_ipv4_addrs,\n\t\t\t\t\t     src, enc_src_ip);\n\t\t\tMAP_ENC_KEY_AND_MASK(IPV4_ADDRS, ipv4_addrs, enc_ipv4_addrs,\n\t\t\t\t\t     dst, enc_dst_ip);\n\t\t\tbreak;\n#ifdef CONFIG_IPV6\n\t\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\t\tMAP_ENC_KEY_AND_MASK(IPV6_ADDRS, ipv6_addrs, enc_ipv6_addrs,\n\t\t\t\t\t     src, enc_src_ip6);\n\t\t\tMAP_ENC_KEY_AND_MASK(IPV6_ADDRS, ipv6_addrs, enc_ipv6_addrs,\n\t\t\t\t\t     dst, enc_dst_ip6);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Unsupported enc addr_type %u (supported are IPv4, IPv6)\",\n\t\t\t\t\t       fm.key->addr_type);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tMAP_ENC_KEY_AND_MASK(IP, ip, enc_ip, tos, enc_ip_tos);\n\t\tMAP_ENC_KEY_AND_MASK(IP, ip, enc_ip, ttl, enc_ip_ttl);\n\t\tMAP_ENC_KEY_AND_MASK(PORTS, ports, enc_ports, src, enc_sport);\n\t\tMAP_ENC_KEY_AND_MASK(PORTS, ports, enc_ports, dst, enc_dport);\n\t\tMAP_ENC_KEY_AND_MASK(KEYID, enc_keyid, enc_keyid, keyid, enc_keyid);\n\t} else if (dissector->used_keys &\n\t\t   (BIT_ULL(FLOW_DISSECTOR_KEY_ENC_KEYID) |\n\t\t    BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) |\n\t\t    BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) |\n\t\t    BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IP) |\n\t\t    BIT_ULL(FLOW_DISSECTOR_KEY_ENC_PORTS))) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t       \"Flower enc keys require enc_control (keys: %#llx)\",\n\t\t\t\t       dissector->used_keys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CT)) {\n\t\tstruct flow_match_ct fm;\n\n\t\tflow_rule_match_ct(rule, &fm);\n\t\tmatch->value.ct_state_trk = !!(fm.key->ct_state & TCA_FLOWER_KEY_CT_FLAGS_TRACKED);\n\t\tmatch->mask.ct_state_trk = !!(fm.mask->ct_state & TCA_FLOWER_KEY_CT_FLAGS_TRACKED);\n\t\tmatch->value.ct_state_est = !!(fm.key->ct_state & TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED);\n\t\tmatch->mask.ct_state_est = !!(fm.mask->ct_state & TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED);\n\t\tif (fm.mask->ct_state & ~(TCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t\t\t\t  TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED)) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Unsupported ct_state match %#x\",\n\t\t\t\t\t       fm.mask->ct_state);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tmatch->value.ct_mark = fm.key->ct_mark;\n\t\tmatch->mask.ct_mark = fm.mask->ct_mark;\n\t\tmatch->value.ct_zone = fm.key->ct_zone;\n\t\tmatch->mask.ct_zone = fm.mask->ct_zone;\n\n\t\tif (memchr_inv(fm.mask->ct_labels, 0, sizeof(fm.mask->ct_labels))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Matching on ct_label not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void efx_tc_flower_release_encap_match(struct efx_nic *efx,\n\t\t\t\t\t      struct efx_tc_encap_match *encap)\n{\n\tint rc;\n\n\tif (!refcount_dec_and_test(&encap->ref))\n\t\treturn;  \n\n\tif (encap->type == EFX_TC_EM_DIRECT) {\n\t\trc = efx_mae_unregister_encap_match(efx, encap);\n\t\tif (rc)\n\t\t\t \n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"Failed to release encap match %#x, rc %d\\n\",\n\t\t\t\t  encap->fw_id, rc);\n\t}\n\trhashtable_remove_fast(&efx->tc->encap_match_ht, &encap->linkage,\n\t\t\t       efx_tc_encap_match_ht_params);\n\tif (encap->pseudo)\n\t\tefx_tc_flower_release_encap_match(efx, encap->pseudo);\n\tkfree(encap);\n}\n\nstatic int efx_tc_flower_record_encap_match(struct efx_nic *efx,\n\t\t\t\t\t    struct efx_tc_match *match,\n\t\t\t\t\t    enum efx_encap_type type,\n\t\t\t\t\t    enum efx_tc_em_pseudo_type em_type,\n\t\t\t\t\t    u8 child_ip_tos_mask,\n\t\t\t\t\t    __be16 child_udp_sport_mask,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct efx_tc_encap_match *encap, *old, *pseudo = NULL;\n\tbool ipv6 = false;\n\tint rc;\n\n\t \n\tif (match->mask.enc_dst_ip | match->mask.enc_src_ip) {\n\t\tif (!IS_ALL_ONES(match->mask.enc_dst_ip)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Egress encap match is not exact on dst IP address\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!IS_ALL_ONES(match->mask.enc_src_ip)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Egress encap match is not exact on src IP address\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n#ifdef CONFIG_IPV6\n\t\tif (!ipv6_addr_any(&match->mask.enc_dst_ip6) ||\n\t\t    !ipv6_addr_any(&match->mask.enc_src_ip6)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Egress encap match on both IPv4 and IPv6, don't understand\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tipv6 = true;\n\t\tif (!efx_ipv6_addr_all_ones(&match->mask.enc_dst_ip6)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Egress encap match is not exact on dst IP address\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!efx_ipv6_addr_all_ones(&match->mask.enc_src_ip6)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Egress encap match is not exact on src IP address\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n#endif\n\t}\n\tif (!IS_ALL_ONES(match->mask.enc_dport)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Egress encap match is not exact on dst UDP port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (match->mask.enc_sport || match->mask.enc_ip_tos) {\n\t\tstruct efx_tc_match pmatch = *match;\n\n\t\tif (em_type == EFX_TC_EM_PSEUDO_MASK) {  \n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Bad recursion in egress encap match handler\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tpmatch.value.enc_ip_tos = 0;\n\t\tpmatch.mask.enc_ip_tos = 0;\n\t\tpmatch.value.enc_sport = 0;\n\t\tpmatch.mask.enc_sport = 0;\n\t\trc = efx_tc_flower_record_encap_match(efx, &pmatch, type,\n\t\t\t\t\t\t      EFX_TC_EM_PSEUDO_MASK,\n\t\t\t\t\t\t      match->mask.enc_ip_tos,\n\t\t\t\t\t\t      match->mask.enc_sport,\n\t\t\t\t\t\t      extack);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tpseudo = pmatch.encap;\n\t}\n\tif (match->mask.enc_ip_ttl) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Egress encap match on IP TTL not supported\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto fail_pseudo;\n\t}\n\n\trc = efx_mae_check_encap_match_caps(efx, ipv6, match->mask.enc_ip_tos,\n\t\t\t\t\t    match->mask.enc_sport, extack);\n\tif (rc)\n\t\tgoto fail_pseudo;\n\n\tencap = kzalloc(sizeof(*encap), GFP_USER);\n\tif (!encap) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_pseudo;\n\t}\n\tencap->src_ip = match->value.enc_src_ip;\n\tencap->dst_ip = match->value.enc_dst_ip;\n#ifdef CONFIG_IPV6\n\tencap->src_ip6 = match->value.enc_src_ip6;\n\tencap->dst_ip6 = match->value.enc_dst_ip6;\n#endif\n\tencap->udp_dport = match->value.enc_dport;\n\tencap->tun_type = type;\n\tencap->ip_tos = match->value.enc_ip_tos;\n\tencap->ip_tos_mask = match->mask.enc_ip_tos;\n\tencap->child_ip_tos_mask = child_ip_tos_mask;\n\tencap->udp_sport = match->value.enc_sport;\n\tencap->udp_sport_mask = match->mask.enc_sport;\n\tencap->child_udp_sport_mask = child_udp_sport_mask;\n\tencap->type = em_type;\n\tencap->pseudo = pseudo;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->encap_match_ht,\n\t\t\t\t\t\t&encap->linkage,\n\t\t\t\t\t\tefx_tc_encap_match_ht_params);\n\tif (old) {\n\t\t \n\t\tkfree(encap);\n\t\tif (pseudo)  \n\t\t\tefx_tc_flower_release_encap_match(efx, pseudo);\n\t\tif (IS_ERR(old))  \n\t\t\treturn PTR_ERR(old);\n\t\t \n\t\tswitch (old->type) {\n\t\tcase EFX_TC_EM_DIRECT:\n\t\t\t \n\t\t\tif (em_type == EFX_TC_EM_DIRECT)\n\t\t\t\tbreak;\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Pseudo encap match conflicts with existing direct entry\");\n\t\t\treturn -EEXIST;\n\t\tcase EFX_TC_EM_PSEUDO_MASK:\n\t\t\t \n\t\t\tif (em_type != EFX_TC_EM_PSEUDO_MASK) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"%s encap match conflicts with existing pseudo(MASK) entry\",\n\t\t\t\t\t\t       em_type ? \"Pseudo\" : \"Direct\");\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tif (child_ip_tos_mask != old->child_ip_tos_mask) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"Pseudo encap match for TOS mask %#04x conflicts with existing mask %#04x\",\n\t\t\t\t\t\t       child_ip_tos_mask,\n\t\t\t\t\t\t       old->child_ip_tos_mask);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tif (child_udp_sport_mask != old->child_udp_sport_mask) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"Pseudo encap match for UDP src port mask %#x conflicts with existing mask %#x\",\n\t\t\t\t\t\t       child_udp_sport_mask,\n\t\t\t\t\t\t       old->child_udp_sport_mask);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"%s encap match conflicts with existing pseudo(%d) entry\",\n\t\t\t\t\t       em_type ? \"Pseudo\" : \"Direct\",\n\t\t\t\t\t       old->type);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\t \n\t\tif (old->tun_type != type) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Egress encap match with conflicting tun_type %u != %u\",\n\t\t\t\t\t       old->tun_type, type);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (!refcount_inc_not_zero(&old->ref))\n\t\t\treturn -EAGAIN;\n\t\t \n\t\tencap = old;\n\t} else {\n\t\tif (em_type == EFX_TC_EM_DIRECT) {\n\t\t\trc = efx_mae_register_encap_match(efx, encap);\n\t\t\tif (rc) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to record egress encap match in HW\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\trefcount_set(&encap->ref, 1);\n\t}\n\tmatch->encap = encap;\n\treturn 0;\nfail:\n\trhashtable_remove_fast(&efx->tc->encap_match_ht, &encap->linkage,\n\t\t\t       efx_tc_encap_match_ht_params);\n\tkfree(encap);\nfail_pseudo:\n\tif (pseudo)\n\t\tefx_tc_flower_release_encap_match(efx, pseudo);\n\treturn rc;\n}\n\nstatic struct efx_tc_recirc_id *efx_tc_get_recirc_id(struct efx_nic *efx,\n\t\t\t\t\t\t     u32 chain_index,\n\t\t\t\t\t\t     struct net_device *net_dev)\n{\n\tstruct efx_tc_recirc_id *rid, *old;\n\tint rc;\n\n\trid = kzalloc(sizeof(*rid), GFP_USER);\n\tif (!rid)\n\t\treturn ERR_PTR(-ENOMEM);\n\trid->chain_index = chain_index;\n\t \n\trid->net_dev = net_dev;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->recirc_ht,\n\t\t\t\t\t\t&rid->linkage,\n\t\t\t\t\t\tefx_tc_recirc_ht_params);\n\tif (old) {\n\t\t \n\t\tkfree(rid);\n\t\tif (IS_ERR(old))  \n\t\t\treturn ERR_CAST(old);\n\t\tif (!refcount_inc_not_zero(&old->ref))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t \n\t\trid = old;\n\t} else {\n\t\trc = ida_alloc_range(&efx->tc->recirc_ida, 1, U8_MAX, GFP_USER);\n\t\tif (rc < 0) {\n\t\t\trhashtable_remove_fast(&efx->tc->recirc_ht,\n\t\t\t\t\t       &rid->linkage,\n\t\t\t\t\t       efx_tc_recirc_ht_params);\n\t\t\tkfree(rid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\trid->fw_id = rc;\n\t\trefcount_set(&rid->ref, 1);\n\t}\n\treturn rid;\n}\n\nstatic void efx_tc_put_recirc_id(struct efx_nic *efx, struct efx_tc_recirc_id *rid)\n{\n\tif (!refcount_dec_and_test(&rid->ref))\n\t\treturn;  \n\trhashtable_remove_fast(&efx->tc->recirc_ht, &rid->linkage,\n\t\t\t       efx_tc_recirc_ht_params);\n\tida_free(&efx->tc->recirc_ida, rid->fw_id);\n\tkfree(rid);\n}\n\nstatic void efx_tc_delete_rule(struct efx_nic *efx, struct efx_tc_flow_rule *rule)\n{\n\tefx_mae_delete_rule(efx, rule->fw_id);\n\n\t \n\tefx_tc_free_action_set_list(efx, &rule->acts, true);\n\tif (rule->match.rid)\n\t\tefx_tc_put_recirc_id(efx, rule->match.rid);\n\tif (rule->match.encap)\n\t\tefx_tc_flower_release_encap_match(efx, rule->match.encap);\n\trule->fw_id = MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL;\n}\n\nstatic const char *efx_tc_encap_type_name(enum efx_encap_type typ)\n{\n\tswitch (typ) {\n\tcase EFX_ENCAP_TYPE_NONE:\n\t\treturn \"none\";\n\tcase EFX_ENCAP_TYPE_VXLAN:\n\t\treturn \"vxlan\";\n\tcase EFX_ENCAP_TYPE_GENEVE:\n\t\treturn \"geneve\";\n\tdefault:\n\t\tpr_warn_once(\"Unknown efx_encap_type %d encountered\\n\", typ);\n\t\treturn \"unknown\";\n\t}\n}\n\n \nenum efx_tc_action_order {\n\tEFX_TC_AO_DECAP,\n\tEFX_TC_AO_DEC_TTL,\n\tEFX_TC_AO_PEDIT_MAC_ADDRS,\n\tEFX_TC_AO_VLAN_POP,\n\tEFX_TC_AO_VLAN_PUSH,\n\tEFX_TC_AO_COUNT,\n\tEFX_TC_AO_ENCAP,\n\tEFX_TC_AO_DELIVER\n};\n \nstatic bool efx_tc_flower_action_order_ok(const struct efx_tc_action_set *act,\n\t\t\t\t\t  enum efx_tc_action_order new)\n{\n\tswitch (new) {\n\tcase EFX_TC_AO_DECAP:\n\t\tif (act->decap)\n\t\t\treturn false;\n\t\t \n\t\tif (act->dst_mac || act->src_mac)\n\t\t\treturn false;\n\n\t\t \n\t\tif (act->do_ttl_dec)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase EFX_TC_AO_VLAN_POP:\n\t\tif (act->vlan_pop >= 2)\n\t\t\treturn false;\n\t\t \n\t\tif (act->vlan_push)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase EFX_TC_AO_VLAN_PUSH:\n\t\tif (act->vlan_push >= 2)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase EFX_TC_AO_COUNT:\n\t\tif (act->count)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase EFX_TC_AO_PEDIT_MAC_ADDRS:\n\tcase EFX_TC_AO_ENCAP:\n\t\tif (act->encap_md)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase EFX_TC_AO_DELIVER:\n\t\treturn !act->deliver;\n\tcase EFX_TC_AO_DEC_TTL:\n\t\tif (act->encap_md)\n\t\t\treturn false;\n\t\treturn !act->do_ttl_dec;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n}\n\n \n\nstatic bool efx_tc_rule_is_lhs_rule(struct flow_rule *fr,\n\t\t\t\t    struct efx_tc_match *match)\n{\n\tconst struct flow_action_entry *fa;\n\tint i;\n\n\tflow_action_for_each(i, fa, &fr->action) {\n\t\tswitch (fa->id) {\n\t\tcase FLOW_ACTION_GOTO:\n\t\t\treturn true;\n\t\tcase FLOW_ACTION_CT:\n\t\t\t \n\t\t\tif (!match->mask.ct_state_trk || !match->value.ct_state_trk)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int efx_tc_flower_handle_lhs_actions(struct efx_nic *efx,\n\t\t\t\t\t    struct flow_cls_offload *tc,\n\t\t\t\t\t    struct flow_rule *fr,\n\t\t\t\t\t    struct net_device *net_dev,\n\t\t\t\t\t    struct efx_tc_lhs_rule *rule)\n\n{\n\tstruct netlink_ext_ack *extack = tc->common.extack;\n\tstruct efx_tc_lhs_action *act = &rule->lhs_act;\n\tconst struct flow_action_entry *fa;\n\tbool pipe = true;\n\tint i;\n\n\tflow_action_for_each(i, fa, &fr->action) {\n\t\tstruct efx_tc_ct_zone *ct_zone;\n\t\tstruct efx_tc_recirc_id *rid;\n\n\t\tif (!pipe) {\n\t\t\t \n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Action follows non-pipe action\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (fa->id) {\n\t\tcase FLOW_ACTION_GOTO:\n\t\t\tif (!fa->chain_index) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't goto chain 0, no looping in hw\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\trid = efx_tc_get_recirc_id(efx, fa->chain_index,\n\t\t\t\t\t\t   net_dev);\n\t\t\tif (IS_ERR(rid)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to allocate a hardware recirculation ID for this chain_index\");\n\t\t\t\treturn PTR_ERR(rid);\n\t\t\t}\n\t\t\tact->rid = rid;\n\t\t\tif (fa->hw_stats) {\n\t\t\t\tstruct efx_tc_counter_index *cnt;\n\n\t\t\t\tif (!(fa->hw_stats & FLOW_ACTION_HW_STATS_DELAYED)) {\n\t\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t\t       \"hw_stats_type %u not supported (only 'delayed')\",\n\t\t\t\t\t\t\t       fa->hw_stats);\n\t\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t\t}\n\t\t\t\tcnt = efx_tc_flower_get_counter_index(efx, tc->cookie,\n\t\t\t\t\t\t\t\t      EFX_TC_COUNTER_TYPE_OR);\n\t\t\t\tif (IS_ERR(cnt)) {\n\t\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to obtain a counter\");\n\t\t\t\t\treturn PTR_ERR(cnt);\n\t\t\t\t}\n\t\t\t\tWARN_ON(act->count);  \n\t\t\t\tact->count = cnt;\n\t\t\t}\n\t\t\tpipe = false;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_CT:\n\t\t\tif (act->zone) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't offload multiple ct actions\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (fa->ct.action & (TCA_CT_ACT_COMMIT |\n\t\t\t\t\t     TCA_CT_ACT_FORCE)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't offload ct commit/force\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (fa->ct.action & TCA_CT_ACT_CLEAR) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't clear ct in LHS rule\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (fa->ct.action & (TCA_CT_ACT_NAT |\n\t\t\t\t\t     TCA_CT_ACT_NAT_SRC |\n\t\t\t\t\t     TCA_CT_ACT_NAT_DST)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't perform NAT in LHS rule - packet isn't conntracked yet\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (fa->ct.action) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unhandled ct.action %u for LHS rule\\n\",\n\t\t\t\t\t\t       fa->ct.action);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tct_zone = efx_tc_ct_register_zone(efx, fa->ct.zone,\n\t\t\t\t\t\t\t  fa->ct.flow_table);\n\t\t\tif (IS_ERR(ct_zone)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to register for CT updates\");\n\t\t\t\treturn PTR_ERR(ct_zone);\n\t\t\t}\n\t\t\tact->zone = ct_zone;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unhandled action %u for LHS rule\\n\",\n\t\t\t\t\t       fa->id);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (pipe) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing goto chain in LHS rule\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic void efx_tc_flower_release_lhs_actions(struct efx_nic *efx,\n\t\t\t\t\t      struct efx_tc_lhs_action *act)\n{\n\tif (act->rid)\n\t\tefx_tc_put_recirc_id(efx, act->rid);\n\tif (act->zone)\n\t\tefx_tc_ct_unregister_zone(efx, act->zone);\n\tif (act->count)\n\t\tefx_tc_flower_put_counter_index(efx, act->count);\n}\n\n \nstruct efx_tc_mangler_state {\n\tu8 dst_mac_32:1;  \n\tu8 dst_mac_16:1;  \n\tu8 src_mac_16:1;  \n\tu8 src_mac_32:1;  \n\tunsigned char dst_mac[ETH_ALEN];\n\tunsigned char src_mac[ETH_ALEN];\n};\n\n \n\nstatic int efx_tc_complete_mac_mangle(struct efx_nic *efx,\n\t\t\t\t      struct efx_tc_action_set *act,\n\t\t\t\t      struct efx_tc_mangler_state *mung,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct efx_tc_mac_pedit_action *ped;\n\n\tif (mung->dst_mac_32 && mung->dst_mac_16) {\n\t\tped = efx_tc_flower_get_mac(efx, mung->dst_mac, extack);\n\t\tif (IS_ERR(ped))\n\t\t\treturn PTR_ERR(ped);\n\n\t\t \n\t\tif (act->dst_mac)\n\t\t\tefx_tc_flower_put_mac(efx, act->dst_mac);\n\n\t\tact->dst_mac = ped;\n\n\t\t \n\t\tmung->dst_mac_32 = 0;\n\t\tmung->dst_mac_16 = 0;\n\t}\n\tif (mung->src_mac_16 && mung->src_mac_32) {\n\t\tped = efx_tc_flower_get_mac(efx, mung->src_mac, extack);\n\t\tif (IS_ERR(ped))\n\t\t\treturn PTR_ERR(ped);\n\n\t\t \n\t\tif (act->src_mac)\n\t\t\tefx_tc_flower_put_mac(efx, act->src_mac);\n\n\t\tact->src_mac = ped;\n\n\t\t \n\t\tmung->src_mac_32 = 0;\n\t\tmung->src_mac_16 = 0;\n\t}\n\treturn 0;\n}\n\nstatic int efx_tc_pedit_add(struct efx_nic *efx, struct efx_tc_action_set *act,\n\t\t\t    const struct flow_action_entry *fa,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tswitch (fa->mangle.htype) {\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_IP4:\n\t\tswitch (fa->mangle.offset) {\n\t\tcase offsetof(struct iphdr, ttl):\n\t\t\t \n\t\t\tif (fa->mangle.mask != ~EFX_TC_HDR_TYPE_TTL_MASK)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif ((fa->mangle.val & EFX_TC_HDR_TYPE_TTL_MASK) != U8_MAX)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (!efx_tc_flower_action_order_ok(act,\n\t\t\t\t\t\t\t   EFX_TC_AO_DEC_TTL)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"multiple dec ttl are not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tact->do_ttl_dec = 1;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_IP6:\n\t\tswitch (fa->mangle.offset) {\n\t\tcase round_down(offsetof(struct ipv6hdr, hop_limit), 4):\n\t\t\t \n\t\t\tif (fa->mangle.mask != EFX_TC_HDR_TYPE_HLIMIT_MASK)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif ((fa->mangle.val >> 24) != U8_MAX)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (!efx_tc_flower_action_order_ok(act,\n\t\t\t\t\t\t\t   EFX_TC_AO_DEC_TTL)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"multiple dec ttl are not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tact->do_ttl_dec = 1;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t       \"ttl add action type %x %x %x/%x is not supported\",\n\t\t\t       fa->mangle.htype, fa->mangle.offset,\n\t\t\t       fa->mangle.val, fa->mangle.mask);\n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic int efx_tc_mangle(struct efx_nic *efx, struct efx_tc_action_set *act,\n\t\t\t const struct flow_action_entry *fa,\n\t\t\t struct efx_tc_mangler_state *mung,\n\t\t\t struct netlink_ext_ack *extack,\n\t\t\t struct efx_tc_match *match)\n{\n\t__le32 mac32;\n\t__le16 mac16;\n\tu8 tr_ttl;\n\n\tswitch (fa->mangle.htype) {\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_ETH:\n\t\tBUILD_BUG_ON(offsetof(struct ethhdr, h_dest) != 0);\n\t\tBUILD_BUG_ON(offsetof(struct ethhdr, h_source) != 6);\n\t\tif (!efx_tc_flower_action_order_ok(act, EFX_TC_AO_PEDIT_MAC_ADDRS)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Pedit mangle mac action violates action order\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tswitch (fa->mangle.offset) {\n\t\tcase 0:\n\t\t\tif (fa->mangle.mask) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"mask (%#x) of eth.dst32 mangle is not supported\",\n\t\t\t\t\t\t       fa->mangle.mask);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\t \n\t\t\tmac32 = cpu_to_le32(fa->mangle.val);\n\t\t\tmemcpy(mung->dst_mac, &mac32, sizeof(mac32));\n\t\t\tmung->dst_mac_32 = 1;\n\t\t\treturn efx_tc_complete_mac_mangle(efx, act, mung, extack);\n\t\tcase 4:\n\t\t\tif (fa->mangle.mask == 0xffff) {\n\t\t\t\tmac16 = cpu_to_le16(fa->mangle.val >> 16);\n\t\t\t\tmemcpy(mung->src_mac, &mac16, sizeof(mac16));\n\t\t\t\tmung->src_mac_16 = 1;\n\t\t\t} else if (fa->mangle.mask == 0xffff0000) {\n\t\t\t\tmac16 = cpu_to_le16((u16)fa->mangle.val);\n\t\t\t\tmemcpy(mung->dst_mac + 4, &mac16, sizeof(mac16));\n\t\t\t\tmung->dst_mac_16 = 1;\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"mask (%#x) of eth+4 mangle is not high or low 16b\",\n\t\t\t\t\t\t       fa->mangle.mask);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\treturn efx_tc_complete_mac_mangle(efx, act, mung, extack);\n\t\tcase 8:\n\t\t\tif (fa->mangle.mask) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"mask (%#x) of eth.src32 mangle is not supported\",\n\t\t\t\t\t\t       fa->mangle.mask);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tmac32 = cpu_to_le32(fa->mangle.val);\n\t\t\tmemcpy(mung->src_mac + 2, &mac32, sizeof(mac32));\n\t\t\tmung->src_mac_32 = 1;\n\t\t\treturn efx_tc_complete_mac_mangle(efx, act, mung, extack);\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"mangle eth+%u %x/%x is not supported\",\n\t\t\t\t\t       fa->mangle.offset, fa->mangle.val, fa->mangle.mask);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_IP4:\n\t\tswitch (fa->mangle.offset) {\n\t\tcase offsetof(struct iphdr, ttl):\n\t\t\t \n\n\t\t\t \n\t\t\tif (fa->mangle.mask != ~EFX_TC_HDR_TYPE_TTL_MASK) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"mask (%#x) out of range, only support mangle action on ipv4.ttl\",\n\t\t\t\t\t\t       fa->mangle.mask);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (match->mask.ip_ttl != U8_MAX) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"only support mangle ttl when we have an exact match, current mask (%#x)\",\n\t\t\t\t\t\t       match->mask.ip_ttl);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (match->value.ip_ttl == 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"decrement ttl past 0 is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!efx_tc_flower_action_order_ok(act,\n\t\t\t\t\t\t\t   EFX_TC_AO_DEC_TTL)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"multiple dec ttl is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\ttr_ttl = match->value.ip_ttl - 1;\n\t\t\tif ((fa->mangle.val & EFX_TC_HDR_TYPE_TTL_MASK) == tr_ttl) {\n\t\t\t\tact->do_ttl_dec = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"only support mangle on the ttl field (offset is %u)\",\n\t\t\t\t\t       fa->mangle.offset);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_IP6:\n\t\tswitch (fa->mangle.offset) {\n\t\tcase round_down(offsetof(struct ipv6hdr, hop_limit), 4):\n\t\t\t \n\n\t\t\t \n\t\t\tif (fa->mangle.mask != EFX_TC_HDR_TYPE_HLIMIT_MASK) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"mask (%#x) out of range, only support mangle action on ipv6.hop_limit\",\n\t\t\t\t\t\t       fa->mangle.mask);\n\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (match->mask.ip_ttl != U8_MAX) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"only support hop_limit when we have an exact match, current mask (%#x)\",\n\t\t\t\t\t\t       match->mask.ip_ttl);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (match->value.ip_ttl == 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"decrementing hop_limit past 0 is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!efx_tc_flower_action_order_ok(act,\n\t\t\t\t\t\t\t   EFX_TC_AO_DEC_TTL)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"multiple dec ttl is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\ttr_ttl = match->value.ip_ttl - 1;\n\t\t\tif ((fa->mangle.val >> 24) == tr_ttl) {\n\t\t\t\tact->do_ttl_dec = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"only support mangle on the hop_limit field\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unhandled mangle htype %u for action rule\",\n\t\t\t\t       fa->mangle.htype);\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int efx_tc_incomplete_mangle(struct efx_tc_mangler_state *mung,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (mung->dst_mac_32 || mung->dst_mac_16) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Incomplete pedit of destination MAC address\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (mung->src_mac_16 || mung->src_mac_32) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Incomplete pedit of source MAC address\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int efx_tc_flower_replace_foreign(struct efx_nic *efx,\n\t\t\t\t\t struct net_device *net_dev,\n\t\t\t\t\t struct flow_cls_offload *tc)\n{\n\tstruct flow_rule *fr = flow_cls_offload_flow_rule(tc);\n\tstruct netlink_ext_ack *extack = tc->common.extack;\n\tstruct efx_tc_flow_rule *rule = NULL, *old = NULL;\n\tstruct efx_tc_action_set *act = NULL;\n\tbool found = false, uplinked = false;\n\tconst struct flow_action_entry *fa;\n\tstruct efx_tc_match match;\n\tstruct efx_rep *to_efv;\n\ts64 rc;\n\tint i;\n\n\t \n\tmemset(&match, 0, sizeof(match));\n\trc = efx_tc_flower_parse_match(efx, fr, &match, NULL);\n\tif (rc)\n\t\treturn rc;\n\t \n\trc = efx_tc_flower_external_mport(efx, EFX_EFV_PF);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to identify ingress m-port for foreign filter\");\n\t\treturn rc;\n\t}\n\tmatch.value.ingress_port = rc;\n\tmatch.mask.ingress_port = ~0;\n\n\tif (tc->common.chain_index) {\n\t\tstruct efx_tc_recirc_id *rid;\n\n\t\trid = efx_tc_get_recirc_id(efx, tc->common.chain_index, net_dev);\n\t\tif (IS_ERR(rid)) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Failed to allocate a hardware recirculation ID for chain_index %u\",\n\t\t\t\t\t       tc->common.chain_index);\n\t\t\treturn PTR_ERR(rid);\n\t\t}\n\t\tmatch.rid = rid;\n\t\tmatch.value.recirc_id = rid->fw_id;\n\t}\n\tmatch.mask.recirc_id = 0xff;\n\n\t \n\tif (match.mask.ct_state_trk && match.value.ct_state_trk &&\n\t    match.mask.ct_state_est && match.value.ct_state_est)\n\t\tmatch.mask.ct_state_trk = 0;\n\t \n\tif (match.mask.ct_state_est && !match.value.ct_state_est) {\n\t\tif (match.value.tcp_syn_fin_rst) {\n\t\t\t \n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto release;\n\t\t}\n\t\tmatch.mask.tcp_syn_fin_rst = true;\n\t}\n\n\tflow_action_for_each(i, fa, &fr->action) {\n\t\tswitch (fa->id) {\n\t\tcase FLOW_ACTION_REDIRECT:\n\t\tcase FLOW_ACTION_MIRRED:  \n\t\t\tto_efv = efx_tc_flower_lookup_efv(efx, fa->dev);\n\t\t\tif (IS_ERR(to_efv))\n\t\t\t\tcontinue;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {  \n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Ignoring foreign filter that doesn't egdev us\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto release;\n\t}\n\n\trc = efx_mae_match_check_caps(efx, &match.mask, NULL);\n\tif (rc)\n\t\tgoto release;\n\n\tif (efx_tc_match_is_encap(&match.mask)) {\n\t\tenum efx_encap_type type;\n\n\t\ttype = efx_tc_indr_netdev_type(net_dev);\n\t\tif (type == EFX_ENCAP_TYPE_NONE) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Egress encap match on unsupported tunnel device\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto release;\n\t\t}\n\n\t\trc = efx_mae_check_encap_type_supported(efx, type);\n\t\tif (rc) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Firmware reports no support for %s encap match\",\n\t\t\t\t\t       efx_tc_encap_type_name(type));\n\t\t\tgoto release;\n\t\t}\n\n\t\trc = efx_tc_flower_record_encap_match(efx, &match, type,\n\t\t\t\t\t\t      EFX_TC_EM_DIRECT, 0, 0,\n\t\t\t\t\t\t      extack);\n\t\tif (rc)\n\t\t\tgoto release;\n\t} else {\n\t\t \n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Ignoring foreign filter without encap match\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto release;\n\t}\n\n\trule = kzalloc(sizeof(*rule), GFP_USER);\n\tif (!rule) {\n\t\trc = -ENOMEM;\n\t\tgoto release;\n\t}\n\tINIT_LIST_HEAD(&rule->acts.list);\n\trule->cookie = tc->cookie;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->match_action_ht,\n\t\t\t\t\t\t&rule->linkage,\n\t\t\t\t\t\tefx_tc_match_action_ht_params);\n\tif (IS_ERR(old)) {\n\t\trc = PTR_ERR(old);\n\t\tgoto release;\n\t} else if (old) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Ignoring already-offloaded rule (cookie %lx)\\n\",\n\t\t\t  tc->cookie);\n\t\trc = -EEXIST;\n\t\tgoto release;\n\t}\n\n\tact = kzalloc(sizeof(*act), GFP_USER);\n\tif (!act) {\n\t\trc = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\t \n\tflow_action_for_each(i, fa, &fr->action) {\n\t\tstruct efx_tc_action_set save;\n\n\t\tswitch (fa->id) {\n\t\tcase FLOW_ACTION_REDIRECT:\n\t\tcase FLOW_ACTION_MIRRED:\n\t\t\t \n\t\t\tsave = *act;\n\t\t\tif (fa->hw_stats) {\n\t\t\t\tstruct efx_tc_counter_index *ctr;\n\n\t\t\t\tif (!(fa->hw_stats & FLOW_ACTION_HW_STATS_DELAYED)) {\n\t\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t\t       \"hw_stats_type %u not supported (only 'delayed')\",\n\t\t\t\t\t\t\t       fa->hw_stats);\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\tif (!efx_tc_flower_action_order_ok(act, EFX_TC_AO_COUNT)) {\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\n\t\t\t\tctr = efx_tc_flower_get_counter_index(efx,\n\t\t\t\t\t\t\t\t      tc->cookie,\n\t\t\t\t\t\t\t\t      EFX_TC_COUNTER_TYPE_AR);\n\t\t\t\tif (IS_ERR(ctr)) {\n\t\t\t\t\trc = PTR_ERR(ctr);\n\t\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to obtain a counter\");\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\tact->count = ctr;\n\t\t\t\tINIT_LIST_HEAD(&act->count_user);\n\t\t\t}\n\n\t\t\tif (!efx_tc_flower_action_order_ok(act, EFX_TC_AO_DELIVER)) {\n\t\t\t\t \n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Deliver action violates action order (can't happen)\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tto_efv = efx_tc_flower_lookup_efv(efx, fa->dev);\n\t\t\t \n\t\t\tif (IS_ERR(to_efv))\n\t\t\t\tto_efv = EFX_EFV_PF;\n\t\t\tif (to_efv == EFX_EFV_PF) {\n\t\t\t\tif (uplinked)\n\t\t\t\t\tbreak;\n\t\t\t\tuplinked = true;\n\t\t\t}\n\t\t\trc = efx_tc_flower_internal_mport(efx, to_efv);\n\t\t\tif (rc < 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to identify egress m-port\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tact->dest_mport = rc;\n\t\t\tact->deliver = 1;\n\t\t\trc = efx_mae_alloc_action_set(efx, act);\n\t\t\tif (rc) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Failed to write action set to hw (mirred)\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tlist_add_tail(&act->list, &rule->acts.list);\n\t\t\tact = NULL;\n\t\t\tif (fa->id == FLOW_ACTION_REDIRECT)\n\t\t\t\tbreak;  \n\t\t\t \n\t\t\tact = kzalloc(sizeof(*act), GFP_USER);\n\t\t\tif (!act) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\t*act = save;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TUNNEL_DECAP:\n\t\t\tif (!efx_tc_flower_action_order_ok(act, EFX_TC_AO_DECAP)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Decap action violates action order\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tact->decap = 1;\n\t\t\t \n\t\t\tuplinked = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unhandled action %u\",\n\t\t\t\t\t       fa->id);\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto release;\n\t\t}\n\t}\n\n\tif (act) {\n\t\tif (!uplinked) {\n\t\t\t \n\t\t\tefx_mae_mport_uplink(efx, &act->dest_mport);\n\t\t\tact->deliver = 1;\n\t\t}\n\t\trc = efx_mae_alloc_action_set(efx, act);\n\t\tif (rc) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write action set to hw (deliver)\");\n\t\t\tgoto release;\n\t\t}\n\t\tlist_add_tail(&act->list, &rule->acts.list);\n\t\tact = NULL;  \n\t}\n\n\trule->match = match;\n\n\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t  \"Successfully parsed foreign filter (cookie %lx)\\n\",\n\t\t  tc->cookie);\n\n\trc = efx_mae_alloc_action_set_list(efx, &rule->acts);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write action set list to hw\");\n\t\tgoto release;\n\t}\n\trc = efx_mae_insert_rule(efx, &rule->match, EFX_TC_PRIO_TC,\n\t\t\t\t rule->acts.fw_id, &rule->fw_id);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to insert rule in hw\");\n\t\tgoto release_acts;\n\t}\n\treturn 0;\n\nrelease_acts:\n\tefx_mae_free_action_set_list(efx, &rule->acts);\nrelease:\n\t \n\tif (match.rid)\n\t\tefx_tc_put_recirc_id(efx, match.rid);\n\tif (act)\n\t\tefx_tc_free_action_set(efx, act, false);\n\tif (rule) {\n\t\tif (!old)\n\t\t\trhashtable_remove_fast(&efx->tc->match_action_ht,\n\t\t\t\t\t       &rule->linkage,\n\t\t\t\t\t       efx_tc_match_action_ht_params);\n\t\tefx_tc_free_action_set_list(efx, &rule->acts, false);\n\t}\n\tkfree(rule);\n\tif (match.encap)\n\t\tefx_tc_flower_release_encap_match(efx, match.encap);\n\treturn rc;\n}\n\nstatic int efx_tc_flower_replace_lhs(struct efx_nic *efx,\n\t\t\t\t     struct flow_cls_offload *tc,\n\t\t\t\t     struct flow_rule *fr,\n\t\t\t\t     struct efx_tc_match *match,\n\t\t\t\t     struct efx_rep *efv,\n\t\t\t\t     struct net_device *net_dev)\n{\n\tstruct netlink_ext_ack *extack = tc->common.extack;\n\tstruct efx_tc_lhs_rule *rule, *old;\n\tint rc;\n\n\tif (tc->common.chain_index) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"LHS rule only allowed in chain 0\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (match->mask.ct_state_trk && match->value.ct_state_trk) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"LHS rule can never match +trk\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\t \n\tmatch->mask.ct_state_trk = 0;\n\tmatch->value.ct_state_trk = 0;\n\n\trc = efx_mae_match_check_caps_lhs(efx, &match->mask, extack);\n\tif (rc)\n\t\treturn rc;\n\n\trule = kzalloc(sizeof(*rule), GFP_USER);\n\tif (!rule)\n\t\treturn -ENOMEM;\n\trule->cookie = tc->cookie;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->lhs_rule_ht,\n\t\t\t\t\t\t&rule->linkage,\n\t\t\t\t\t\tefx_tc_lhs_rule_ht_params);\n\tif (IS_ERR(old)) {\n\t\trc = PTR_ERR(old);\n\t\tgoto release;\n\t} else if (old) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Already offloaded rule (cookie %lx)\\n\", tc->cookie);\n\t\trc = -EEXIST;\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Rule already offloaded\");\n\t\tgoto release;\n\t}\n\n\t \n\t \n\trc = efx_tc_flower_handle_lhs_actions(efx, tc, fr, efx->net_dev, rule);\n\tif (rc)\n\t\tgoto release;\n\n\trule->match = *match;\n\n\trc = efx_mae_insert_lhs_rule(efx, rule, EFX_TC_PRIO_TC);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to insert rule in hw\");\n\t\tgoto release;\n\t}\n\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t  \"Successfully parsed lhs rule (cookie %lx)\\n\",\n\t\t  tc->cookie);\n\treturn 0;\n\nrelease:\n\tefx_tc_flower_release_lhs_actions(efx, &rule->lhs_act);\n\tif (!old)\n\t\trhashtable_remove_fast(&efx->tc->lhs_rule_ht, &rule->linkage,\n\t\t\t\t       efx_tc_lhs_rule_ht_params);\n\tkfree(rule);\n\treturn rc;\n}\n\nstatic int efx_tc_flower_replace(struct efx_nic *efx,\n\t\t\t\t struct net_device *net_dev,\n\t\t\t\t struct flow_cls_offload *tc,\n\t\t\t\t struct efx_rep *efv)\n{\n\tstruct flow_rule *fr = flow_cls_offload_flow_rule(tc);\n\tstruct netlink_ext_ack *extack = tc->common.extack;\n\tconst struct ip_tunnel_info *encap_info = NULL;\n\tstruct efx_tc_flow_rule *rule = NULL, *old;\n\tstruct efx_tc_mangler_state mung = {};\n\tstruct efx_tc_action_set *act = NULL;\n\tconst struct flow_action_entry *fa;\n\tstruct efx_rep *from_efv, *to_efv;\n\tstruct efx_tc_match match;\n\tu32 acts_id;\n\ts64 rc;\n\tint i;\n\n\tif (!tc_can_offload_extack(efx->net_dev, extack))\n\t\treturn -EOPNOTSUPP;\n\tif (WARN_ON(!efx->tc))\n\t\treturn -ENETDOWN;\n\tif (WARN_ON(!efx->tc->up))\n\t\treturn -ENETDOWN;\n\n\tfrom_efv = efx_tc_flower_lookup_efv(efx, net_dev);\n\tif (IS_ERR(from_efv)) {\n\t\t \n\t\treturn efx_tc_flower_replace_foreign(efx, net_dev, tc);\n\t}\n\n\tif (efv != from_efv) {\n\t\t \n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"for %s efv is %snull but from_efv is %snull (can't happen)\",\n\t\t\t\t       netdev_name(net_dev), efv ? \"non-\" : \"\",\n\t\t\t\t       from_efv ? \"non-\" : \"\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(&match, 0, sizeof(match));\n\trc = efx_tc_flower_external_mport(efx, from_efv);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to identify ingress m-port\");\n\t\treturn rc;\n\t}\n\tmatch.value.ingress_port = rc;\n\tmatch.mask.ingress_port = ~0;\n\trc = efx_tc_flower_parse_match(efx, fr, &match, extack);\n\tif (rc)\n\t\treturn rc;\n\tif (efx_tc_match_is_encap(&match.mask)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Ingress enc_key matches not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (efx_tc_rule_is_lhs_rule(fr, &match))\n\t\treturn efx_tc_flower_replace_lhs(efx, tc, fr, &match, efv,\n\t\t\t\t\t\t net_dev);\n\n\t \n\tif (tc->common.chain_index) {\n\t\tstruct efx_tc_recirc_id *rid;\n\n\t\t \n\t\trid = efx_tc_get_recirc_id(efx, tc->common.chain_index,\n\t\t\t\t\t   efx->net_dev);\n\t\tif (IS_ERR(rid)) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Failed to allocate a hardware recirculation ID for chain_index %u\",\n\t\t\t\t\t       tc->common.chain_index);\n\t\t\treturn PTR_ERR(rid);\n\t\t}\n\t\tmatch.rid = rid;\n\t\tmatch.value.recirc_id = rid->fw_id;\n\t}\n\tmatch.mask.recirc_id = 0xff;\n\n\t \n\tif (match.mask.ct_state_trk && match.value.ct_state_trk &&\n\t    match.mask.ct_state_est && match.value.ct_state_est)\n\t\tmatch.mask.ct_state_trk = 0;\n\t \n\tif (match.mask.ct_state_est && !match.value.ct_state_est) {\n\t\tif (match.value.tcp_syn_fin_rst) {\n\t\t\t \n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto release;\n\t\t}\n\t\tmatch.mask.tcp_syn_fin_rst = true;\n\t}\n\n\trc = efx_mae_match_check_caps(efx, &match.mask, extack);\n\tif (rc)\n\t\tgoto release;\n\n\trule = kzalloc(sizeof(*rule), GFP_USER);\n\tif (!rule) {\n\t\trc = -ENOMEM;\n\t\tgoto release;\n\t}\n\tINIT_LIST_HEAD(&rule->acts.list);\n\trule->cookie = tc->cookie;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->match_action_ht,\n\t\t\t\t\t\t&rule->linkage,\n\t\t\t\t\t\tefx_tc_match_action_ht_params);\n\tif (IS_ERR(old)) {\n\t\trc = PTR_ERR(old);\n\t\tgoto release;\n\t} else if (old) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Already offloaded rule (cookie %lx)\\n\", tc->cookie);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Rule already offloaded\");\n\t\trc = -EEXIST;\n\t\tgoto release;\n\t}\n\n\t \n\tact = kzalloc(sizeof(*act), GFP_USER);\n\tif (!act) {\n\t\trc = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\t \n\tflow_action_for_each(i, fa, &fr->action) {\n\t\tstruct efx_tc_action_set save;\n\t\tu16 tci;\n\n\t\tif (!act) {\n\t\t\t \n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Action follows non-pipe action\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release;\n\t\t}\n\n\t\tif ((fa->id == FLOW_ACTION_REDIRECT ||\n\t\t     fa->id == FLOW_ACTION_MIRRED ||\n\t\t     fa->id == FLOW_ACTION_DROP) && fa->hw_stats) {\n\t\t\tstruct efx_tc_counter_index *ctr;\n\n\t\t\t \n\t\t\tif (!efx_tc_flower_action_order_ok(act, EFX_TC_AO_COUNT)) {\n\t\t\t\t \n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Count-action conflict (can't happen)\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto release;\n\t\t\t}\n\n\t\t\tif (!(fa->hw_stats & FLOW_ACTION_HW_STATS_DELAYED)) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"hw_stats_type %u not supported (only 'delayed')\",\n\t\t\t\t\t\t       fa->hw_stats);\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto release;\n\t\t\t}\n\n\t\t\tctr = efx_tc_flower_get_counter_index(efx, tc->cookie,\n\t\t\t\t\t\t\t      EFX_TC_COUNTER_TYPE_AR);\n\t\t\tif (IS_ERR(ctr)) {\n\t\t\t\trc = PTR_ERR(ctr);\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to obtain a counter\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tact->count = ctr;\n\t\t\tINIT_LIST_HEAD(&act->count_user);\n\t\t}\n\n\t\tswitch (fa->id) {\n\t\tcase FLOW_ACTION_DROP:\n\t\t\trc = efx_mae_alloc_action_set(efx, act);\n\t\t\tif (rc) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write action set to hw (drop)\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tlist_add_tail(&act->list, &rule->acts.list);\n\t\t\tact = NULL;  \n\t\t\tbreak;\n\t\tcase FLOW_ACTION_REDIRECT:\n\t\tcase FLOW_ACTION_MIRRED:\n\t\t\tsave = *act;\n\n\t\t\tif (encap_info) {\n\t\t\t\tstruct efx_tc_encap_action *encap;\n\n\t\t\t\tif (!efx_tc_flower_action_order_ok(act,\n\t\t\t\t\t\t\t\t   EFX_TC_AO_ENCAP)) {\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Encap action violates action order\");\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\tencap = efx_tc_flower_create_encap_md(\n\t\t\t\t\t\tefx, encap_info, fa->dev, extack);\n\t\t\t\tif (IS_ERR_OR_NULL(encap)) {\n\t\t\t\t\trc = PTR_ERR(encap);\n\t\t\t\t\tif (!rc)\n\t\t\t\t\t\trc = -EIO;  \n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\tact->encap_md = encap;\n\t\t\t\tlist_add_tail(&act->encap_user, &encap->users);\n\t\t\t\tact->dest_mport = encap->dest_mport;\n\t\t\t\tact->deliver = 1;\n\t\t\t\tif (act->count && !WARN_ON(!act->count->cnt)) {\n\t\t\t\t\t \n\t\t\t\t\tspin_lock_bh(&act->count->cnt->lock);\n\t\t\t\t\tlist_add_tail(&act->count_user,\n\t\t\t\t\t\t      &act->count->cnt->users);\n\t\t\t\t\tspin_unlock_bh(&act->count->cnt->lock);\n\t\t\t\t}\n\t\t\t\trc = efx_mae_alloc_action_set(efx, act);\n\t\t\t\tif (rc) {\n\t\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write action set to hw (encap)\");\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\tlist_add_tail(&act->list, &rule->acts.list);\n\t\t\t\tact->user = &rule->acts;\n\t\t\t\tact = NULL;\n\t\t\t\tif (fa->id == FLOW_ACTION_REDIRECT)\n\t\t\t\t\tbreak;  \n\t\t\t\t \n\t\t\t\tsave.count = NULL;\n\t\t\t\tact = kzalloc(sizeof(*act), GFP_USER);\n\t\t\t\tif (!act) {\n\t\t\t\t\trc = -ENOMEM;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\t*act = save;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!efx_tc_flower_action_order_ok(act, EFX_TC_AO_DELIVER)) {\n\t\t\t\t \n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Deliver action violates action order (can't happen)\");\n\t\t\t\tgoto release;\n\t\t\t}\n\n\t\t\tto_efv = efx_tc_flower_lookup_efv(efx, fa->dev);\n\t\t\tif (IS_ERR(to_efv)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Mirred egress device not on switch\");\n\t\t\t\trc = PTR_ERR(to_efv);\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\trc = efx_tc_flower_external_mport(efx, to_efv);\n\t\t\tif (rc < 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to identify egress m-port\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tact->dest_mport = rc;\n\t\t\tact->deliver = 1;\n\t\t\trc = efx_mae_alloc_action_set(efx, act);\n\t\t\tif (rc) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write action set to hw (mirred)\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tlist_add_tail(&act->list, &rule->acts.list);\n\t\t\tact = NULL;\n\t\t\tif (fa->id == FLOW_ACTION_REDIRECT)\n\t\t\t\tbreak;  \n\t\t\t \n\t\t\tsave.count = NULL;\n\t\t\tact = kzalloc(sizeof(*act), GFP_USER);\n\t\t\tif (!act) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\t*act = save;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_POP:\n\t\t\tif (act->vlan_push) {\n\t\t\t\tact->vlan_push--;\n\t\t\t} else if (efx_tc_flower_action_order_ok(act, EFX_TC_AO_VLAN_POP)) {\n\t\t\t\tact->vlan_pop++;\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"More than two VLAN pops, or action order violated\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_PUSH:\n\t\t\tif (!efx_tc_flower_action_order_ok(act, EFX_TC_AO_VLAN_PUSH)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"More than two VLAN pushes, or action order violated\");\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\ttci = fa->vlan.vid & VLAN_VID_MASK;\n\t\t\ttci |= fa->vlan.prio << VLAN_PRIO_SHIFT;\n\t\t\tact->vlan_tci[act->vlan_push] = cpu_to_be16(tci);\n\t\t\tact->vlan_proto[act->vlan_push] = fa->vlan.proto;\n\t\t\tact->vlan_push++;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_ADD:\n\t\t\trc = efx_tc_pedit_add(efx, act, fa, extack);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto release;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_MANGLE:\n\t\t\trc = efx_tc_mangle(efx, act, fa, &mung, extack, &match);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto release;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TUNNEL_ENCAP:\n\t\t\tif (encap_info) {\n\t\t\t\t \n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Tunnel key set when already set\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tif (!fa->tunnel) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Tunnel key set is missing key\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tencap_info = fa->tunnel;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TUNNEL_DECAP:\n\t\t\tif (encap_info) {\n\t\t\t\tencap_info = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot offload tunnel decap action without tunnel device\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto release;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Unhandled action %u\",\n\t\t\t\t\t       fa->id);\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto release;\n\t\t}\n\t}\n\n\trc = efx_tc_incomplete_mangle(&mung, extack);\n\tif (rc < 0)\n\t\tgoto release;\n\tif (act) {\n\t\t \n\t\tif (from_efv == EFX_EFV_PF)\n\t\t\t \n\t\t\tefx_mae_mport_uplink(efx, &act->dest_mport);\n\t\telse\n\t\t\t \n\t\t\tefx_mae_mport_mport(efx, efx->tc->reps_mport_id,\n\t\t\t\t\t    &act->dest_mport);\n\t\tact->deliver = 1;\n\t\trc = efx_mae_alloc_action_set(efx, act);\n\t\tif (rc) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write action set to hw (deliver)\");\n\t\t\tgoto release;\n\t\t}\n\t\tlist_add_tail(&act->list, &rule->acts.list);\n\t\tact = NULL;  \n\t}\n\n\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t  \"Successfully parsed filter (cookie %lx)\\n\",\n\t\t  tc->cookie);\n\n\trule->match = match;\n\n\trc = efx_mae_alloc_action_set_list(efx, &rule->acts);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to write action set list to hw\");\n\t\tgoto release;\n\t}\n\tif (from_efv == EFX_EFV_PF)\n\t\t \n\t\trule->fallback = &efx->tc->facts.pf;\n\telse\n\t\t \n\t\trule->fallback = &efx->tc->facts.reps;\n\tif (!efx_tc_check_ready(efx, rule)) {\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"action not ready for hw\\n\");\n\t\tacts_id = rule->fallback->fw_id;\n\t} else {\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"ready for hw\\n\");\n\t\tacts_id = rule->acts.fw_id;\n\t}\n\trc = efx_mae_insert_rule(efx, &rule->match, EFX_TC_PRIO_TC,\n\t\t\t\t acts_id, &rule->fw_id);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to insert rule in hw\");\n\t\tgoto release_acts;\n\t}\n\treturn 0;\n\nrelease_acts:\n\tefx_mae_free_action_set_list(efx, &rule->acts);\nrelease:\n\t \n\tif (match.rid)\n\t\tefx_tc_put_recirc_id(efx, match.rid);\n\tif (act)\n\t\tefx_tc_free_action_set(efx, act, false);\n\tif (rule) {\n\t\tif (!old)\n\t\t\trhashtable_remove_fast(&efx->tc->match_action_ht,\n\t\t\t\t\t       &rule->linkage,\n\t\t\t\t\t       efx_tc_match_action_ht_params);\n\t\tefx_tc_free_action_set_list(efx, &rule->acts, false);\n\t}\n\tkfree(rule);\n\treturn rc;\n}\n\nstatic int efx_tc_flower_destroy(struct efx_nic *efx,\n\t\t\t\t struct net_device *net_dev,\n\t\t\t\t struct flow_cls_offload *tc)\n{\n\tstruct netlink_ext_ack *extack = tc->common.extack;\n\tstruct efx_tc_lhs_rule *lhs_rule;\n\tstruct efx_tc_flow_rule *rule;\n\n\tlhs_rule = rhashtable_lookup_fast(&efx->tc->lhs_rule_ht, &tc->cookie,\n\t\t\t\t\t  efx_tc_lhs_rule_ht_params);\n\tif (lhs_rule) {\n\t\t \n\t\tefx_mae_remove_lhs_rule(efx, lhs_rule);\n\t\t \n\t\tefx_tc_flower_release_lhs_actions(efx, &lhs_rule->lhs_act);\n\t\trhashtable_remove_fast(&efx->tc->lhs_rule_ht, &lhs_rule->linkage,\n\t\t\t\t       efx_tc_lhs_rule_ht_params);\n\t\tif (lhs_rule->match.encap)\n\t\t\tefx_tc_flower_release_encap_match(efx, lhs_rule->match.encap);\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"Removed (lhs) filter %lx\\n\",\n\t\t\t  lhs_rule->cookie);\n\t\tkfree(lhs_rule);\n\t\treturn 0;\n\t}\n\n\trule = rhashtable_lookup_fast(&efx->tc->match_action_ht, &tc->cookie,\n\t\t\t\t      efx_tc_match_action_ht_params);\n\tif (!rule) {\n\t\t \n\t\tif (!IS_ERR(efx_tc_flower_lookup_efv(efx, net_dev)))\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"Filter %lx not found to remove\\n\", tc->cookie);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Flow cookie not found in offloaded rules\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tefx_tc_delete_rule(efx, rule);\n\t \n\trhashtable_remove_fast(&efx->tc->match_action_ht, &rule->linkage,\n\t\t\t       efx_tc_match_action_ht_params);\n\tnetif_dbg(efx, drv, efx->net_dev, \"Removed filter %lx\\n\", rule->cookie);\n\tkfree(rule);\n\treturn 0;\n}\n\nstatic int efx_tc_flower_stats(struct efx_nic *efx, struct net_device *net_dev,\n\t\t\t       struct flow_cls_offload *tc)\n{\n\tstruct netlink_ext_ack *extack = tc->common.extack;\n\tstruct efx_tc_counter_index *ctr;\n\tstruct efx_tc_counter *cnt;\n\tu64 packets, bytes;\n\n\tctr = efx_tc_flower_find_counter_index(efx, tc->cookie);\n\tif (!ctr) {\n\t\t \n\t\tif (!IS_ERR(efx_tc_flower_lookup_efv(efx, net_dev)))\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t\t   \"Filter %lx not found for stats\\n\",\n\t\t\t\t\t   tc->cookie);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Flow cookie not found in offloaded rules\");\n\t\treturn -ENOENT;\n\t}\n\tif (WARN_ON(!ctr->cnt))  \n\t\treturn -EIO;\n\tcnt = ctr->cnt;\n\n\tspin_lock_bh(&cnt->lock);\n\t \n\tpackets = cnt->packets;\n\tbytes = cnt->bytes;\n\tflow_stats_update(&tc->stats, bytes - cnt->old_bytes,\n\t\t\t  packets - cnt->old_packets, 0, cnt->touched,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\tcnt->old_packets = packets;\n\tcnt->old_bytes = bytes;\n\tspin_unlock_bh(&cnt->lock);\n\treturn 0;\n}\n\nint efx_tc_flower(struct efx_nic *efx, struct net_device *net_dev,\n\t\t  struct flow_cls_offload *tc, struct efx_rep *efv)\n{\n\tint rc;\n\n\tif (!efx->tc)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&efx->tc->mutex);\n\tswitch (tc->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\trc = efx_tc_flower_replace(efx, net_dev, tc, efv);\n\t\tbreak;\n\tcase FLOW_CLS_DESTROY:\n\t\trc = efx_tc_flower_destroy(efx, net_dev, tc);\n\t\tbreak;\n\tcase FLOW_CLS_STATS:\n\t\trc = efx_tc_flower_stats(efx, net_dev, tc);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&efx->tc->mutex);\n\treturn rc;\n}\n\nstatic int efx_tc_configure_default_rule(struct efx_nic *efx, u32 ing_port,\n\t\t\t\t\t u32 eg_port, struct efx_tc_flow_rule *rule)\n{\n\tstruct efx_tc_action_set_list *acts = &rule->acts;\n\tstruct efx_tc_match *match = &rule->match;\n\tstruct efx_tc_action_set *act;\n\tint rc;\n\n\tmatch->value.ingress_port = ing_port;\n\tmatch->mask.ingress_port = ~0;\n\tact = kzalloc(sizeof(*act), GFP_KERNEL);\n\tif (!act)\n\t\treturn -ENOMEM;\n\tact->deliver = 1;\n\tact->dest_mport = eg_port;\n\trc = efx_mae_alloc_action_set(efx, act);\n\tif (rc)\n\t\tgoto fail1;\n\tEFX_WARN_ON_PARANOID(!list_empty(&acts->list));\n\tlist_add_tail(&act->list, &acts->list);\n\trc = efx_mae_alloc_action_set_list(efx, acts);\n\tif (rc)\n\t\tgoto fail2;\n\trc = efx_mae_insert_rule(efx, match, EFX_TC_PRIO_DFLT,\n\t\t\t\t acts->fw_id, &rule->fw_id);\n\tif (rc)\n\t\tgoto fail3;\n\treturn 0;\nfail3:\n\tefx_mae_free_action_set_list(efx, acts);\nfail2:\n\tlist_del(&act->list);\n\tefx_mae_free_action_set(efx, act->fw_id);\nfail1:\n\tkfree(act);\n\treturn rc;\n}\n\nstatic int efx_tc_configure_default_rule_pf(struct efx_nic *efx)\n{\n\tstruct efx_tc_flow_rule *rule = &efx->tc->dflt.pf;\n\tu32 ing_port, eg_port;\n\n\tefx_mae_mport_uplink(efx, &ing_port);\n\tefx_mae_mport_wire(efx, &eg_port);\n\treturn efx_tc_configure_default_rule(efx, ing_port, eg_port, rule);\n}\n\nstatic int efx_tc_configure_default_rule_wire(struct efx_nic *efx)\n{\n\tstruct efx_tc_flow_rule *rule = &efx->tc->dflt.wire;\n\tu32 ing_port, eg_port;\n\n\tefx_mae_mport_wire(efx, &ing_port);\n\tefx_mae_mport_uplink(efx, &eg_port);\n\treturn efx_tc_configure_default_rule(efx, ing_port, eg_port, rule);\n}\n\nint efx_tc_configure_default_rule_rep(struct efx_rep *efv)\n{\n\tstruct efx_tc_flow_rule *rule = &efv->dflt;\n\tstruct efx_nic *efx = efv->parent;\n\tu32 ing_port, eg_port;\n\n\tefx_mae_mport_mport(efx, efv->mport, &ing_port);\n\tefx_mae_mport_mport(efx, efx->tc->reps_mport_id, &eg_port);\n\treturn efx_tc_configure_default_rule(efx, ing_port, eg_port, rule);\n}\n\nvoid efx_tc_deconfigure_default_rule(struct efx_nic *efx,\n\t\t\t\t     struct efx_tc_flow_rule *rule)\n{\n\tif (rule->fw_id != MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL)\n\t\tefx_tc_delete_rule(efx, rule);\n\trule->fw_id = MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL;\n}\n\nstatic int efx_tc_configure_fallback_acts(struct efx_nic *efx, u32 eg_port,\n\t\t\t\t\t  struct efx_tc_action_set_list *acts)\n{\n\tstruct efx_tc_action_set *act;\n\tint rc;\n\n\tact = kzalloc(sizeof(*act), GFP_KERNEL);\n\tif (!act)\n\t\treturn -ENOMEM;\n\tact->deliver = 1;\n\tact->dest_mport = eg_port;\n\trc = efx_mae_alloc_action_set(efx, act);\n\tif (rc)\n\t\tgoto fail1;\n\tEFX_WARN_ON_PARANOID(!list_empty(&acts->list));\n\tlist_add_tail(&act->list, &acts->list);\n\trc = efx_mae_alloc_action_set_list(efx, acts);\n\tif (rc)\n\t\tgoto fail2;\n\treturn 0;\nfail2:\n\tlist_del(&act->list);\n\tefx_mae_free_action_set(efx, act->fw_id);\nfail1:\n\tkfree(act);\n\treturn rc;\n}\n\nstatic int efx_tc_configure_fallback_acts_pf(struct efx_nic *efx)\n{\n\tstruct efx_tc_action_set_list *acts = &efx->tc->facts.pf;\n\tu32 eg_port;\n\n\tefx_mae_mport_uplink(efx, &eg_port);\n\treturn efx_tc_configure_fallback_acts(efx, eg_port, acts);\n}\n\nstatic int efx_tc_configure_fallback_acts_reps(struct efx_nic *efx)\n{\n\tstruct efx_tc_action_set_list *acts = &efx->tc->facts.reps;\n\tu32 eg_port;\n\n\tefx_mae_mport_mport(efx, efx->tc->reps_mport_id, &eg_port);\n\treturn efx_tc_configure_fallback_acts(efx, eg_port, acts);\n}\n\nstatic void efx_tc_deconfigure_fallback_acts(struct efx_nic *efx,\n\t\t\t\t\t     struct efx_tc_action_set_list *acts)\n{\n\tefx_tc_free_action_set_list(efx, acts, true);\n}\n\nstatic int efx_tc_configure_rep_mport(struct efx_nic *efx)\n{\n\tu32 rep_mport_label;\n\tint rc;\n\n\trc = efx_mae_allocate_mport(efx, &efx->tc->reps_mport_id, &rep_mport_label);\n\tif (rc)\n\t\treturn rc;\n\tpci_dbg(efx->pci_dev, \"created rep mport 0x%08x (0x%04x)\\n\",\n\t\tefx->tc->reps_mport_id, rep_mport_label);\n\t \n\tefx_mae_mport_mport(efx, efx->tc->reps_mport_id,\n\t\t\t    &efx->tc->reps_mport_vport_id);\n\treturn 0;\n}\n\nstatic void efx_tc_deconfigure_rep_mport(struct efx_nic *efx)\n{\n\tefx_mae_free_mport(efx, efx->tc->reps_mport_id);\n\tefx->tc->reps_mport_id = MAE_MPORT_SELECTOR_NULL;\n}\n\nint efx_tc_insert_rep_filters(struct efx_nic *efx)\n{\n\tstruct efx_filter_spec promisc, allmulti;\n\tint rc;\n\n\tif (efx->type->is_vf)\n\t\treturn 0;\n\tif (!efx->tc)\n\t\treturn 0;\n\tefx_filter_init_rx(&promisc, EFX_FILTER_PRI_REQUIRED, 0, 0);\n\tefx_filter_set_uc_def(&promisc);\n\tefx_filter_set_vport_id(&promisc, efx->tc->reps_mport_vport_id);\n\trc = efx_filter_insert_filter(efx, &promisc, false);\n\tif (rc < 0)\n\t\treturn rc;\n\tefx->tc->reps_filter_uc = rc;\n\tefx_filter_init_rx(&allmulti, EFX_FILTER_PRI_REQUIRED, 0, 0);\n\tefx_filter_set_mc_def(&allmulti);\n\tefx_filter_set_vport_id(&allmulti, efx->tc->reps_mport_vport_id);\n\trc = efx_filter_insert_filter(efx, &allmulti, false);\n\tif (rc < 0)\n\t\treturn rc;\n\tefx->tc->reps_filter_mc = rc;\n\treturn 0;\n}\n\nvoid efx_tc_remove_rep_filters(struct efx_nic *efx)\n{\n\tif (efx->type->is_vf)\n\t\treturn;\n\tif (!efx->tc)\n\t\treturn;\n\tif (efx->tc->reps_filter_mc >= 0)\n\t\tefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED, efx->tc->reps_filter_mc);\n\tefx->tc->reps_filter_mc = -1;\n\tif (efx->tc->reps_filter_uc >= 0)\n\t\tefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED, efx->tc->reps_filter_uc);\n\tefx->tc->reps_filter_uc = -1;\n}\n\nint efx_init_tc(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_mae_get_caps(efx, efx->tc->caps);\n\tif (rc)\n\t\treturn rc;\n\tif (efx->tc->caps->match_field_count > MAE_NUM_FIELDS)\n\t\t \n\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t   \"FW reports additional match fields %u\\n\",\n\t\t\t   efx->tc->caps->match_field_count);\n\tif (efx->tc->caps->action_prios < EFX_TC_PRIO__NUM) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Too few action prios supported (have %u, need %u)\\n\",\n\t\t\t  efx->tc->caps->action_prios, EFX_TC_PRIO__NUM);\n\t\treturn -EIO;\n\t}\n\trc = efx_tc_configure_default_rule_pf(efx);\n\tif (rc)\n\t\treturn rc;\n\trc = efx_tc_configure_default_rule_wire(efx);\n\tif (rc)\n\t\treturn rc;\n\trc = efx_tc_configure_rep_mport(efx);\n\tif (rc)\n\t\treturn rc;\n\trc = efx_tc_configure_fallback_acts_pf(efx);\n\tif (rc)\n\t\treturn rc;\n\trc = efx_tc_configure_fallback_acts_reps(efx);\n\tif (rc)\n\t\treturn rc;\n\trc = efx_mae_get_tables(efx);\n\tif (rc)\n\t\treturn rc;\n\trc = flow_indr_dev_register(efx_tc_indr_setup_cb, efx);\n\tif (rc)\n\t\tgoto out_free;\n\tefx->tc->up = true;\n\treturn 0;\nout_free:\n\tefx_mae_free_tables(efx);\n\treturn rc;\n}\n\nvoid efx_fini_tc(struct efx_nic *efx)\n{\n\t \n\tif (!efx->tc)\n\t\treturn;\n\tif (efx->tc->up)\n\t\tflow_indr_dev_unregister(efx_tc_indr_setup_cb, efx, efx_tc_block_unbind);\n\tefx_tc_deconfigure_rep_mport(efx);\n\tefx_tc_deconfigure_default_rule(efx, &efx->tc->dflt.pf);\n\tefx_tc_deconfigure_default_rule(efx, &efx->tc->dflt.wire);\n\tefx_tc_deconfigure_fallback_acts(efx, &efx->tc->facts.pf);\n\tefx_tc_deconfigure_fallback_acts(efx, &efx->tc->facts.reps);\n\tefx->tc->up = false;\n\tefx_mae_free_tables(efx);\n}\n\n \nstatic void efx_tc_encap_match_free(void *ptr, void *__unused)\n{\n\tstruct efx_tc_encap_match *encap = ptr;\n\n\tWARN_ON(refcount_read(&encap->ref));\n\tkfree(encap);\n}\n\nstatic void efx_tc_recirc_free(void *ptr, void *arg)\n{\n\tstruct efx_tc_recirc_id *rid = ptr;\n\tstruct efx_nic *efx = arg;\n\n\tWARN_ON(refcount_read(&rid->ref));\n\tida_free(&efx->tc->recirc_ida, rid->fw_id);\n\tkfree(rid);\n}\n\nstatic void efx_tc_lhs_free(void *ptr, void *arg)\n{\n\tstruct efx_tc_lhs_rule *rule = ptr;\n\tstruct efx_nic *efx = arg;\n\n\tnetif_err(efx, drv, efx->net_dev,\n\t\t  \"tc lhs_rule %lx still present at teardown, removing\\n\",\n\t\t  rule->cookie);\n\n\tif (rule->lhs_act.zone)\n\t\tefx_tc_ct_unregister_zone(efx, rule->lhs_act.zone);\n\tif (rule->lhs_act.count)\n\t\tefx_tc_flower_put_counter_index(efx, rule->lhs_act.count);\n\tefx_mae_remove_lhs_rule(efx, rule);\n\n\tkfree(rule);\n}\n\nstatic void efx_tc_mac_free(void *ptr, void *__unused)\n{\n\tstruct efx_tc_mac_pedit_action *ped = ptr;\n\n\tWARN_ON(refcount_read(&ped->ref));\n\tkfree(ped);\n}\n\nstatic void efx_tc_flow_free(void *ptr, void *arg)\n{\n\tstruct efx_tc_flow_rule *rule = ptr;\n\tstruct efx_nic *efx = arg;\n\n\tnetif_err(efx, drv, efx->net_dev,\n\t\t  \"tc rule %lx still present at teardown, removing\\n\",\n\t\t  rule->cookie);\n\n\t \n\tefx_tc_delete_rule(efx, rule);\n\n\tkfree(rule);\n}\n\nint efx_init_struct_tc(struct efx_nic *efx)\n{\n\tint rc;\n\n\tif (efx->type->is_vf)\n\t\treturn 0;\n\n\tefx->tc = kzalloc(sizeof(*efx->tc), GFP_KERNEL);\n\tif (!efx->tc)\n\t\treturn -ENOMEM;\n\tefx->tc->caps = kzalloc(sizeof(struct mae_caps), GFP_KERNEL);\n\tif (!efx->tc->caps) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_alloc_caps;\n\t}\n\tINIT_LIST_HEAD(&efx->tc->block_list);\n\n\tmutex_init(&efx->tc->mutex);\n\tinit_waitqueue_head(&efx->tc->flush_wq);\n\trc = efx_tc_init_encap_actions(efx);\n\tif (rc < 0)\n\t\tgoto fail_encap_actions;\n\trc = efx_tc_init_counters(efx);\n\tif (rc < 0)\n\t\tgoto fail_counters;\n\trc = rhashtable_init(&efx->tc->mac_ht, &efx_tc_mac_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_mac_ht;\n\trc = rhashtable_init(&efx->tc->encap_match_ht, &efx_tc_encap_match_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_encap_match_ht;\n\trc = rhashtable_init(&efx->tc->match_action_ht, &efx_tc_match_action_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_match_action_ht;\n\trc = rhashtable_init(&efx->tc->lhs_rule_ht, &efx_tc_lhs_rule_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_lhs_rule_ht;\n\trc = efx_tc_init_conntrack(efx);\n\tif (rc < 0)\n\t\tgoto fail_conntrack;\n\trc = rhashtable_init(&efx->tc->recirc_ht, &efx_tc_recirc_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_recirc_ht;\n\tida_init(&efx->tc->recirc_ida);\n\tefx->tc->reps_filter_uc = -1;\n\tefx->tc->reps_filter_mc = -1;\n\tINIT_LIST_HEAD(&efx->tc->dflt.pf.acts.list);\n\tefx->tc->dflt.pf.fw_id = MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL;\n\tINIT_LIST_HEAD(&efx->tc->dflt.wire.acts.list);\n\tefx->tc->dflt.wire.fw_id = MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL;\n\tINIT_LIST_HEAD(&efx->tc->facts.pf.list);\n\tefx->tc->facts.pf.fw_id = MC_CMD_MAE_ACTION_SET_ALLOC_OUT_ACTION_SET_ID_NULL;\n\tINIT_LIST_HEAD(&efx->tc->facts.reps.list);\n\tefx->tc->facts.reps.fw_id = MC_CMD_MAE_ACTION_SET_ALLOC_OUT_ACTION_SET_ID_NULL;\n\tefx->extra_channel_type[EFX_EXTRA_CHANNEL_TC] = &efx_tc_channel_type;\n\treturn 0;\nfail_recirc_ht:\n\tefx_tc_destroy_conntrack(efx);\nfail_conntrack:\n\trhashtable_destroy(&efx->tc->lhs_rule_ht);\nfail_lhs_rule_ht:\n\trhashtable_destroy(&efx->tc->match_action_ht);\nfail_match_action_ht:\n\trhashtable_destroy(&efx->tc->encap_match_ht);\nfail_encap_match_ht:\n\trhashtable_destroy(&efx->tc->mac_ht);\nfail_mac_ht:\n\tefx_tc_destroy_counters(efx);\nfail_counters:\n\tefx_tc_destroy_encap_actions(efx);\nfail_encap_actions:\n\tmutex_destroy(&efx->tc->mutex);\n\tkfree(efx->tc->caps);\nfail_alloc_caps:\n\tkfree(efx->tc);\n\tefx->tc = NULL;\n\treturn rc;\n}\n\nvoid efx_fini_struct_tc(struct efx_nic *efx)\n{\n\tif (!efx->tc)\n\t\treturn;\n\n\tmutex_lock(&efx->tc->mutex);\n\tEFX_WARN_ON_PARANOID(efx->tc->dflt.pf.fw_id !=\n\t\t\t     MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL);\n\tEFX_WARN_ON_PARANOID(efx->tc->dflt.wire.fw_id !=\n\t\t\t     MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL);\n\tEFX_WARN_ON_PARANOID(efx->tc->facts.pf.fw_id !=\n\t\t\t     MC_CMD_MAE_ACTION_SET_LIST_ALLOC_OUT_ACTION_SET_LIST_ID_NULL);\n\tEFX_WARN_ON_PARANOID(efx->tc->facts.reps.fw_id !=\n\t\t\t     MC_CMD_MAE_ACTION_SET_LIST_ALLOC_OUT_ACTION_SET_LIST_ID_NULL);\n\trhashtable_free_and_destroy(&efx->tc->lhs_rule_ht, efx_tc_lhs_free, efx);\n\trhashtable_free_and_destroy(&efx->tc->match_action_ht, efx_tc_flow_free,\n\t\t\t\t    efx);\n\trhashtable_free_and_destroy(&efx->tc->encap_match_ht,\n\t\t\t\t    efx_tc_encap_match_free, NULL);\n\tefx_tc_fini_conntrack(efx);\n\trhashtable_free_and_destroy(&efx->tc->recirc_ht, efx_tc_recirc_free, efx);\n\tWARN_ON(!ida_is_empty(&efx->tc->recirc_ida));\n\tida_destroy(&efx->tc->recirc_ida);\n\trhashtable_free_and_destroy(&efx->tc->mac_ht, efx_tc_mac_free, NULL);\n\tefx_tc_fini_counters(efx);\n\tefx_tc_fini_encap_actions(efx);\n\tmutex_unlock(&efx->tc->mutex);\n\tmutex_destroy(&efx->tc->mutex);\n\tkfree(efx->tc->caps);\n\tkfree(efx->tc);\n\tefx->tc = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}