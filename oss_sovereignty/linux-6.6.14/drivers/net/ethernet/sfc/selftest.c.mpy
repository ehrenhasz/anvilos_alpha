{
  "module_name": "selftest.c",
  "hash_id": "33a2a716779d4917f79a49b993f993c46723bc846781ac5526ccfce8558d1cac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/selftest.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/kernel_stat.h>\n#include <linux/pci.h>\n#include <linux/ethtool.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include \"net_driver.h\"\n#include \"efx.h\"\n#include \"efx_common.h\"\n#include \"efx_channels.h\"\n#include \"nic.h\"\n#include \"mcdi_port_common.h\"\n#include \"selftest.h\"\n#include \"workarounds.h\"\n\n \n#define IRQ_TIMEOUT HZ\n\n \nstruct efx_loopback_payload {\n\tchar pad[2];  \n\tstruct_group_attr(packet, __packed,\n\t\tstruct ethhdr header;\n\t\tstruct iphdr ip;\n\t\tstruct udphdr udp;\n\t\t__be16 iteration;\n\t\tchar msg[64];\n\t);\n} __packed __aligned(4);\n#define EFX_LOOPBACK_PAYLOAD_LEN\t\\\n\t\tsizeof_field(struct efx_loopback_payload, packet)\n\n \nstatic const u8 payload_source[ETH_ALEN] __aligned(2) = {\n\t0x00, 0x0f, 0x53, 0x1b, 0x1b, 0x1b,\n};\n\nstatic const char payload_msg[] =\n\t\"Hello world! This is an Efx loopback test in progress!\";\n\n \nstatic const unsigned int efx_interrupt_mode_max = EFX_INT_MODE_MAX;\nstatic const char *const efx_interrupt_mode_names[] = {\n\t[EFX_INT_MODE_MSIX]   = \"MSI-X\",\n\t[EFX_INT_MODE_MSI]    = \"MSI\",\n\t[EFX_INT_MODE_LEGACY] = \"legacy\",\n};\n#define INT_MODE(efx) \\\n\tSTRING_TABLE_LOOKUP(efx->interrupt_mode, efx_interrupt_mode)\n\n \nstruct efx_loopback_state {\n\tbool flush;\n\tint packet_count;\n\tstruct sk_buff **skbs;\n\tbool offload_csum;\n\tatomic_t rx_good;\n\tatomic_t rx_bad;\n\tstruct efx_loopback_payload payload;\n};\n\n \n#define LOOPBACK_TIMEOUT_MS 1000\n\n \n\nstatic int efx_test_phy_alive(struct efx_nic *efx, struct efx_self_tests *tests)\n{\n\tint rc = 0;\n\n\trc = efx_mcdi_phy_test_alive(efx);\n\ttests->phy_alive = rc ? -1 : 1;\n\n\treturn rc;\n}\n\nstatic int efx_test_nvram(struct efx_nic *efx, struct efx_self_tests *tests)\n{\n\tint rc = 0;\n\n\tif (efx->type->test_nvram) {\n\t\trc = efx->type->test_nvram(efx);\n\t\tif (rc == -EPERM)\n\t\t\trc = 0;\n\t\telse\n\t\t\ttests->nvram = rc ? -1 : 1;\n\t}\n\n\treturn rc;\n}\n\n \n\n \nstatic int efx_test_interrupts(struct efx_nic *efx,\n\t\t\t       struct efx_self_tests *tests)\n{\n\tunsigned long timeout, wait;\n\tint cpu;\n\tint rc;\n\n\tnetif_dbg(efx, drv, efx->net_dev, \"testing interrupts\\n\");\n\ttests->interrupt = -1;\n\n\trc = efx_nic_irq_test_start(efx);\n\tif (rc == -ENOTSUPP) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"direct interrupt testing not supported\\n\");\n\t\ttests->interrupt = 0;\n\t\treturn 0;\n\t}\n\n\ttimeout = jiffies + IRQ_TIMEOUT;\n\twait = 1;\n\n\t \n\tnetif_dbg(efx, drv, efx->net_dev, \"waiting for test interrupt\\n\");\n\tdo {\n\t\tschedule_timeout_uninterruptible(wait);\n\t\tcpu = efx_nic_irq_test_irq_cpu(efx);\n\t\tif (cpu >= 0)\n\t\t\tgoto success;\n\t\twait *= 2;\n\t} while (time_before(jiffies, timeout));\n\n\tnetif_err(efx, drv, efx->net_dev, \"timed out waiting for interrupt\\n\");\n\treturn -ETIMEDOUT;\n\n success:\n\tnetif_dbg(efx, drv, efx->net_dev, \"%s test interrupt seen on CPU%d\\n\",\n\t\t  INT_MODE(efx), cpu);\n\ttests->interrupt = 1;\n\treturn 0;\n}\n\n \nstatic int efx_test_eventq_irq(struct efx_nic *efx,\n\t\t\t       struct efx_self_tests *tests)\n{\n\tstruct efx_channel *channel;\n\tunsigned int read_ptr[EFX_MAX_CHANNELS];\n\tunsigned long napi_ran = 0, dma_pend = 0, int_pend = 0;\n\tunsigned long timeout, wait;\n\n\tBUILD_BUG_ON(EFX_MAX_CHANNELS > BITS_PER_LONG);\n\n\tefx_for_each_channel(channel, efx) {\n\t\tread_ptr[channel->channel] = channel->eventq_read_ptr;\n\t\tset_bit(channel->channel, &dma_pend);\n\t\tset_bit(channel->channel, &int_pend);\n\t\tefx_nic_event_test_start(channel);\n\t}\n\n\ttimeout = jiffies + IRQ_TIMEOUT;\n\twait = 1;\n\n\t \n\tdo {\n\t\tschedule_timeout_uninterruptible(wait);\n\n\t\tefx_for_each_channel(channel, efx) {\n\t\t\tefx_stop_eventq(channel);\n\t\t\tif (channel->eventq_read_ptr !=\n\t\t\t    read_ptr[channel->channel]) {\n\t\t\t\tset_bit(channel->channel, &napi_ran);\n\t\t\t\tclear_bit(channel->channel, &dma_pend);\n\t\t\t\tclear_bit(channel->channel, &int_pend);\n\t\t\t} else {\n\t\t\t\tif (efx_nic_event_present(channel))\n\t\t\t\t\tclear_bit(channel->channel, &dma_pend);\n\t\t\t\tif (efx_nic_event_test_irq_cpu(channel) >= 0)\n\t\t\t\t\tclear_bit(channel->channel, &int_pend);\n\t\t\t}\n\t\t\tefx_start_eventq(channel);\n\t\t}\n\n\t\twait *= 2;\n\t} while ((dma_pend || int_pend) && time_before(jiffies, timeout));\n\n\tefx_for_each_channel(channel, efx) {\n\t\tbool dma_seen = !test_bit(channel->channel, &dma_pend);\n\t\tbool int_seen = !test_bit(channel->channel, &int_pend);\n\n\t\ttests->eventq_dma[channel->channel] = dma_seen ? 1 : -1;\n\t\ttests->eventq_int[channel->channel] = int_seen ? 1 : -1;\n\n\t\tif (dma_seen && int_seen) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"channel %d event queue passed (with%s NAPI)\\n\",\n\t\t\t\t  channel->channel,\n\t\t\t\t  test_bit(channel->channel, &napi_ran) ?\n\t\t\t\t  \"\" : \"out\");\n\t\t} else {\n\t\t\t \n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"channel %d timed out waiting for event queue\\n\",\n\t\t\t\t  channel->channel);\n\t\t\tif (int_seen)\n\t\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t\t  \"channel %d saw interrupt \"\n\t\t\t\t\t  \"during event queue test\\n\",\n\t\t\t\t\t  channel->channel);\n\t\t\tif (dma_seen)\n\t\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t\t  \"channel %d event was generated, but \"\n\t\t\t\t\t  \"failed to trigger an interrupt\\n\",\n\t\t\t\t\t  channel->channel);\n\t\t}\n\t}\n\n\treturn (dma_pend || int_pend) ? -ETIMEDOUT : 0;\n}\n\nstatic int efx_test_phy(struct efx_nic *efx, struct efx_self_tests *tests,\n\t\t\tunsigned flags)\n{\n\tint rc;\n\n\tmutex_lock(&efx->mac_lock);\n\trc = efx_mcdi_phy_run_tests(efx, tests->phy_ext, flags);\n\tmutex_unlock(&efx->mac_lock);\n\tif (rc == -EPERM)\n\t\trc = 0;\n\telse\n\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t   \"%s phy selftest\\n\", rc ? \"Failed\" : \"Passed\");\n\n\treturn rc;\n}\n\n \n\n \nvoid efx_loopback_rx_packet(struct efx_nic *efx,\n\t\t\t    const char *buf_ptr, int pkt_len)\n{\n\tstruct efx_loopback_state *state = efx->loopback_selftest;\n\tstruct efx_loopback_payload received;\n\tstruct efx_loopback_payload *payload;\n\n\tBUG_ON(!buf_ptr);\n\n\t \n\tif ((state == NULL) || state->flush)\n\t\treturn;\n\n\tpayload = &state->payload;\n\n\tmemcpy(&received.packet, buf_ptr,\n\t       min_t(int, pkt_len, EFX_LOOPBACK_PAYLOAD_LEN));\n\treceived.ip.saddr = payload->ip.saddr;\n\tif (state->offload_csum)\n\t\treceived.ip.check = payload->ip.check;\n\n\t \n\tif (pkt_len < sizeof(received.header)) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"saw runt RX packet (length %d) in %s loopback \"\n\t\t\t  \"test\\n\", pkt_len, LOOPBACK_MODE(efx));\n\t\tgoto err;\n\t}\n\n\t \n\tif (memcmp(&received.header, &payload->header, ETH_HLEN) != 0) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"saw non-loopback RX packet in %s loopback test\\n\",\n\t\t\t  LOOPBACK_MODE(efx));\n\t\tgoto err;\n\t}\n\n\t \n\tif (pkt_len != EFX_LOOPBACK_PAYLOAD_LEN) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"saw incorrect RX packet length %d (wanted %d) in \"\n\t\t\t  \"%s loopback test\\n\", pkt_len,\n\t\t\t  (int)EFX_LOOPBACK_PAYLOAD_LEN, LOOPBACK_MODE(efx));\n\t\tgoto err;\n\t}\n\n\t \n\tif (memcmp(&received.ip, &payload->ip, sizeof(payload->ip)) != 0) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"saw corrupted IP header in %s loopback test\\n\",\n\t\t\t  LOOPBACK_MODE(efx));\n\t\tgoto err;\n\t}\n\n\t \n\tif (memcmp(&received.msg, &payload->msg, sizeof(received.msg)) != 0) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"saw corrupted RX packet in %s loopback test\\n\",\n\t\t\t  LOOPBACK_MODE(efx));\n\t\tgoto err;\n\t}\n\n\t \n\tif (received.iteration != payload->iteration) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"saw RX packet from iteration %d (wanted %d) in \"\n\t\t\t  \"%s loopback test\\n\", ntohs(received.iteration),\n\t\t\t  ntohs(payload->iteration), LOOPBACK_MODE(efx));\n\t\tgoto err;\n\t}\n\n\t \n\tnetif_vdbg(efx, drv, efx->net_dev,\n\t\t   \"got loopback RX in %s loopback test\\n\", LOOPBACK_MODE(efx));\n\n\tatomic_inc(&state->rx_good);\n\treturn;\n\n err:\n#ifdef DEBUG\n\tif (atomic_read(&state->rx_bad) == 0) {\n\t\tnetif_err(efx, drv, efx->net_dev, \"received packet:\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 0x10, 1,\n\t\t\t       buf_ptr, pkt_len, 0);\n\t\tnetif_err(efx, drv, efx->net_dev, \"expected packet:\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 0x10, 1,\n\t\t\t       &state->payload.packet, EFX_LOOPBACK_PAYLOAD_LEN,\n\t\t\t       0);\n\t}\n#endif\n\tatomic_inc(&state->rx_bad);\n}\n\n \nstatic void efx_iterate_state(struct efx_nic *efx)\n{\n\tstruct efx_loopback_state *state = efx->loopback_selftest;\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_loopback_payload *payload = &state->payload;\n\n\t \n\tether_addr_copy((u8 *)&payload->header.h_dest, net_dev->dev_addr);\n\tether_addr_copy((u8 *)&payload->header.h_source, payload_source);\n\tpayload->header.h_proto = htons(ETH_P_IP);\n\n\t \n\tpayload->ip.daddr = htonl(INADDR_LOOPBACK);\n\tpayload->ip.ihl = 5;\n\tpayload->ip.check = (__force __sum16) htons(0xdead);\n\tpayload->ip.tot_len = htons(sizeof(*payload) -\n\t\t\t\t    offsetof(struct efx_loopback_payload, ip));\n\tpayload->ip.version = IPVERSION;\n\tpayload->ip.protocol = IPPROTO_UDP;\n\n\t \n\tpayload->udp.source = 0;\n\tpayload->udp.len = htons(sizeof(*payload) -\n\t\t\t\t offsetof(struct efx_loopback_payload, udp));\n\tpayload->udp.check = 0;\t \n\n\t \n\tpayload->iteration = htons(ntohs(payload->iteration) + 1);\n\tmemcpy(&payload->msg, payload_msg, sizeof(payload_msg));\n\n\t \n\tatomic_set(&state->rx_good, 0);\n\tatomic_set(&state->rx_bad, 0);\n\tsmp_wmb();\n}\n\nstatic int efx_begin_loopback(struct efx_tx_queue *tx_queue)\n{\n\tstruct efx_nic *efx = tx_queue->efx;\n\tstruct efx_loopback_state *state = efx->loopback_selftest;\n\tstruct efx_loopback_payload *payload;\n\tstruct sk_buff *skb;\n\tint i;\n\tnetdev_tx_t rc;\n\n\t \n\tfor (i = 0; i < state->packet_count; i++) {\n\t\t \n\t\tskb = alloc_skb(sizeof(state->payload), GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tstate->skbs[i] = skb;\n\t\tskb_get(skb);\n\n\t\t \n\t\tpayload = skb_put(skb, sizeof(state->payload));\n\t\tmemcpy(payload, &state->payload, sizeof(state->payload));\n\t\tpayload->ip.saddr = htonl(INADDR_LOOPBACK | (i << 2));\n\t\t \n\t\tskb_pull(skb, offsetof(struct efx_loopback_payload, header));\n\t\t \n\t\tskb_trim(skb, EFX_LOOPBACK_PAYLOAD_LEN);\n\n\t\t \n\t\tsmp_wmb();\n\n\t\tnetif_tx_lock_bh(efx->net_dev);\n\t\trc = efx_enqueue_skb(tx_queue, skb);\n\t\tnetif_tx_unlock_bh(efx->net_dev);\n\n\t\tif (rc != NETDEV_TX_OK) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"TX queue %d could not transmit packet %d of \"\n\t\t\t\t  \"%d in %s loopback test\\n\", tx_queue->label,\n\t\t\t\t  i + 1, state->packet_count,\n\t\t\t\t  LOOPBACK_MODE(efx));\n\n\t\t\t \n\t\t\tkfree_skb(skb);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int efx_poll_loopback(struct efx_nic *efx)\n{\n\tstruct efx_loopback_state *state = efx->loopback_selftest;\n\n\treturn atomic_read(&state->rx_good) == state->packet_count;\n}\n\nstatic int efx_end_loopback(struct efx_tx_queue *tx_queue,\n\t\t\t    struct efx_loopback_self_tests *lb_tests)\n{\n\tstruct efx_nic *efx = tx_queue->efx;\n\tstruct efx_loopback_state *state = efx->loopback_selftest;\n\tstruct sk_buff *skb;\n\tint tx_done = 0, rx_good, rx_bad;\n\tint i, rc = 0;\n\n\tnetif_tx_lock_bh(efx->net_dev);\n\n\t \n\tfor (i = 0; i < state->packet_count; i++) {\n\t\tskb = state->skbs[i];\n\t\tif (skb && !skb_shared(skb))\n\t\t\t++tx_done;\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tnetif_tx_unlock_bh(efx->net_dev);\n\n\t \n\trx_good = atomic_read(&state->rx_good);\n\trx_bad = atomic_read(&state->rx_bad);\n\tif (tx_done != state->packet_count) {\n\t\t \n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"TX queue %d saw only %d out of an expected %d \"\n\t\t\t  \"TX completion events in %s loopback test\\n\",\n\t\t\t  tx_queue->label, tx_done, state->packet_count,\n\t\t\t  LOOPBACK_MODE(efx));\n\t\trc = -ETIMEDOUT;\n\t\t \n\t}\n\n\t \n\tif (rx_good != state->packet_count) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"TX queue %d saw only %d out of an expected %d \"\n\t\t\t  \"received packets in %s loopback test\\n\",\n\t\t\t  tx_queue->label, rx_good, state->packet_count,\n\t\t\t  LOOPBACK_MODE(efx));\n\t\trc = -ETIMEDOUT;\n\t\t \n\t}\n\n\t \n\tlb_tests->tx_sent[tx_queue->label] += state->packet_count;\n\tlb_tests->tx_done[tx_queue->label] += tx_done;\n\tlb_tests->rx_good += rx_good;\n\tlb_tests->rx_bad += rx_bad;\n\n\treturn rc;\n}\n\nstatic int\nefx_test_loopback(struct efx_tx_queue *tx_queue,\n\t\t  struct efx_loopback_self_tests *lb_tests)\n{\n\tstruct efx_nic *efx = tx_queue->efx;\n\tstruct efx_loopback_state *state = efx->loopback_selftest;\n\tint i, begin_rc, end_rc;\n\n\tfor (i = 0; i < 3; i++) {\n\t\t \n\t\tstate->packet_count = efx->txq_entries / 3;\n\t\tstate->packet_count = min(1 << (i << 2), state->packet_count);\n\t\tstate->skbs = kcalloc(state->packet_count,\n\t\t\t\t      sizeof(state->skbs[0]), GFP_KERNEL);\n\t\tif (!state->skbs)\n\t\t\treturn -ENOMEM;\n\t\tstate->flush = false;\n\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"TX queue %d (hw %d) testing %s loopback with %d packets\\n\",\n\t\t\t  tx_queue->label, tx_queue->queue, LOOPBACK_MODE(efx),\n\t\t\t  state->packet_count);\n\n\t\tefx_iterate_state(efx);\n\t\tbegin_rc = efx_begin_loopback(tx_queue);\n\n\t\t \n\t\tmsleep(1);\n\t\tif (!efx_poll_loopback(efx)) {\n\t\t\tmsleep(LOOPBACK_TIMEOUT_MS);\n\t\t\tefx_poll_loopback(efx);\n\t\t}\n\n\t\tend_rc = efx_end_loopback(tx_queue, lb_tests);\n\t\tkfree(state->skbs);\n\n\t\tif (begin_rc || end_rc) {\n\t\t\t \n\t\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t\t\treturn begin_rc ? begin_rc : end_rc;\n\t\t}\n\t}\n\n\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t  \"TX queue %d passed %s loopback test with a burst length \"\n\t\t  \"of %d packets\\n\", tx_queue->label, LOOPBACK_MODE(efx),\n\t\t  state->packet_count);\n\n\treturn 0;\n}\n\nstatic int efx_wait_for_link(struct efx_nic *efx)\n{\n\tstruct efx_link_state *link_state = &efx->link_state;\n\tint count, link_up_count = 0;\n\tbool link_up;\n\n\tfor (count = 0; count < 40; count++) {\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\n\t\tif (efx->type->monitor != NULL) {\n\t\t\tmutex_lock(&efx->mac_lock);\n\t\t\tefx->type->monitor(efx);\n\t\t\tmutex_unlock(&efx->mac_lock);\n\t\t}\n\n\t\tmutex_lock(&efx->mac_lock);\n\t\tlink_up = link_state->up;\n\t\tif (link_up)\n\t\t\tlink_up = !efx->type->check_mac_fault(efx);\n\t\tmutex_unlock(&efx->mac_lock);\n\n\t\tif (link_up) {\n\t\t\tif (++link_up_count == 2)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tlink_up_count = 0;\n\t\t}\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int efx_test_loopbacks(struct efx_nic *efx, struct efx_self_tests *tests,\n\t\t\t      unsigned int loopback_modes)\n{\n\tenum efx_loopback_mode mode;\n\tstruct efx_loopback_state *state;\n\tstruct efx_channel *channel =\n\t\tefx_get_channel(efx, efx->tx_channel_offset);\n\tstruct efx_tx_queue *tx_queue;\n\tint rc = 0;\n\n\t \n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tBUG_ON(efx->loopback_selftest);\n\tstate->flush = true;\n\tefx->loopback_selftest = state;\n\n\t \n\tfor (mode = LOOPBACK_NONE; mode <= LOOPBACK_TEST_MAX; mode++) {\n\t\tif (!(loopback_modes & (1 << mode)))\n\t\t\tcontinue;\n\n\t\t \n\t\tstate->flush = true;\n\t\tmutex_lock(&efx->mac_lock);\n\t\tefx->loopback_mode = mode;\n\t\trc = __efx_reconfigure_port(efx);\n\t\tmutex_unlock(&efx->mac_lock);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"unable to move into %s loopback\\n\",\n\t\t\t\t  LOOPBACK_MODE(efx));\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = efx_wait_for_link(efx);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"loopback %s never came up\\n\",\n\t\t\t\t  LOOPBACK_MODE(efx));\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tefx_for_each_channel_tx_queue(tx_queue, channel) {\n\t\t\tstate->offload_csum = (tx_queue->type &\n\t\t\t\t\t       EFX_TXQ_TYPE_OUTER_CSUM);\n\t\t\trc = efx_test_loopback(tx_queue,\n\t\t\t\t\t       &tests->loopback[mode]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\t \n\tstate->flush = true;\n\tefx->loopback_selftest = NULL;\n\twmb();\n\tkfree(state);\n\n\tif (rc == -EPERM)\n\t\trc = 0;\n\n\treturn rc;\n}\n\n \n\nint efx_selftest(struct efx_nic *efx, struct efx_self_tests *tests,\n\t\t unsigned flags)\n{\n\tenum efx_loopback_mode loopback_mode = efx->loopback_mode;\n\tint phy_mode = efx->phy_mode;\n\tint rc_test = 0, rc_reset, rc;\n\n\tefx_selftest_async_cancel(efx);\n\n\t \n\n\trc = efx_test_phy_alive(efx, tests);\n\tif (rc && !rc_test)\n\t\trc_test = rc;\n\n\trc = efx_test_nvram(efx, tests);\n\tif (rc && !rc_test)\n\t\trc_test = rc;\n\n\trc = efx_test_interrupts(efx, tests);\n\tif (rc && !rc_test)\n\t\trc_test = rc;\n\n\trc = efx_test_eventq_irq(efx, tests);\n\tif (rc && !rc_test)\n\t\trc_test = rc;\n\n\tif (rc_test)\n\t\treturn rc_test;\n\n\tif (!(flags & ETH_TEST_FL_OFFLINE))\n\t\treturn efx_test_phy(efx, tests, flags);\n\n\t \n\n\t \n\tefx_device_detach_sync(efx);\n\n\tif (efx->type->test_chip) {\n\t\trc_reset = efx->type->test_chip(efx, tests);\n\t\tif (rc_reset) {\n\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t  \"Unable to recover from chip test\\n\");\n\t\t\tefx_schedule_reset(efx, RESET_TYPE_DISABLE);\n\t\t\treturn rc_reset;\n\t\t}\n\n\t\tif ((tests->memory < 0 || tests->registers < 0) && !rc_test)\n\t\t\trc_test = -EIO;\n\t}\n\n\t \n\tmutex_lock(&efx->mac_lock);\n\tefx->phy_mode &= ~PHY_MODE_LOW_POWER;\n\tefx->loopback_mode = LOOPBACK_NONE;\n\t__efx_reconfigure_port(efx);\n\tmutex_unlock(&efx->mac_lock);\n\n\trc = efx_test_phy(efx, tests, flags);\n\tif (rc && !rc_test)\n\t\trc_test = rc;\n\n\trc = efx_test_loopbacks(efx, tests, efx->loopback_modes);\n\tif (rc && !rc_test)\n\t\trc_test = rc;\n\n\t \n\tmutex_lock(&efx->mac_lock);\n\tefx->phy_mode = phy_mode;\n\tefx->loopback_mode = loopback_mode;\n\t__efx_reconfigure_port(efx);\n\tmutex_unlock(&efx->mac_lock);\n\n\tefx_device_attach_if_not_resetting(efx);\n\n\treturn rc_test;\n}\n\nvoid efx_selftest_async_start(struct efx_nic *efx)\n{\n\tstruct efx_channel *channel;\n\n\tefx_for_each_channel(channel, efx)\n\t\tefx_nic_event_test_start(channel);\n\tschedule_delayed_work(&efx->selftest_work, IRQ_TIMEOUT);\n}\n\nvoid efx_selftest_async_cancel(struct efx_nic *efx)\n{\n\tcancel_delayed_work_sync(&efx->selftest_work);\n}\n\nstatic void efx_selftest_async_work(struct work_struct *data)\n{\n\tstruct efx_nic *efx = container_of(data, struct efx_nic,\n\t\t\t\t\t   selftest_work.work);\n\tstruct efx_channel *channel;\n\tint cpu;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tcpu = efx_nic_event_test_irq_cpu(channel);\n\t\tif (cpu < 0)\n\t\t\tnetif_err(efx, ifup, efx->net_dev,\n\t\t\t\t  \"channel %d failed to trigger an interrupt\\n\",\n\t\t\t\t  channel->channel);\n\t\telse\n\t\t\tnetif_dbg(efx, ifup, efx->net_dev,\n\t\t\t\t  \"channel %d triggered interrupt on CPU %d\\n\",\n\t\t\t\t  channel->channel, cpu);\n\t}\n}\n\nvoid efx_selftest_async_init(struct efx_nic *efx)\n{\n\tINIT_DELAYED_WORK(&efx->selftest_work, efx_selftest_async_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}