{
  "module_name": "ef10_sriov.c",
  "hash_id": "8f216d555ad24cac9d1b53d1fd05b78e53c6d1bf52cdd6c799225381beb80eb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef10_sriov.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include \"net_driver.h\"\n#include \"ef10_sriov.h\"\n#include \"efx.h\"\n#include \"nic.h\"\n#include \"mcdi_pcol.h\"\n\nstatic int efx_ef10_evb_port_assign(struct efx_nic *efx, unsigned int port_id,\n\t\t\t\t    unsigned int vf_fn)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_EVB_PORT_ASSIGN_IN_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tMCDI_SET_DWORD(inbuf, EVB_PORT_ASSIGN_IN_PORT_ID, port_id);\n\tMCDI_POPULATE_DWORD_2(inbuf, EVB_PORT_ASSIGN_IN_FUNCTION,\n\t\t\t      EVB_PORT_ASSIGN_IN_PF, nic_data->pf_index,\n\t\t\t      EVB_PORT_ASSIGN_IN_VF, vf_fn);\n\n\treturn efx_mcdi_rpc(efx, MC_CMD_EVB_PORT_ASSIGN, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nstatic int efx_ef10_vswitch_alloc(struct efx_nic *efx, unsigned int port_id,\n\t\t\t\t  unsigned int vswitch_type)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_ALLOC_IN_LEN);\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_UPSTREAM_PORT_ID, port_id);\n\tMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_TYPE, vswitch_type);\n\tMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 2);\n\tMCDI_POPULATE_DWORD_1(inbuf, VSWITCH_ALLOC_IN_FLAGS,\n\t\t\t      VSWITCH_ALLOC_IN_FLAG_AUTO_PORT, 0);\n\n\t \n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_VSWITCH_ALLOC, inbuf, sizeof(inbuf),\n\t\t\t\tNULL, 0, NULL);\n\n\t \n\tif (rc == -EPROTO) {\n\t\tMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 1);\n\t\trc = efx_mcdi_rpc(efx, MC_CMD_VSWITCH_ALLOC, inbuf,\n\t\t\t\t  sizeof(inbuf), NULL, 0, NULL);\n\t} else if (rc) {\n\t\tefx_mcdi_display_error(efx, MC_CMD_VSWITCH_ALLOC,\n\t\t\t\t       MC_CMD_VSWITCH_ALLOC_IN_LEN,\n\t\t\t\t       NULL, 0, rc);\n\t}\n\treturn rc;\n}\n\nstatic int efx_ef10_vswitch_free(struct efx_nic *efx, unsigned int port_id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_FREE_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, VSWITCH_FREE_IN_UPSTREAM_PORT_ID, port_id);\n\n\treturn efx_mcdi_rpc(efx, MC_CMD_VSWITCH_FREE, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nstatic int efx_ef10_vport_alloc(struct efx_nic *efx,\n\t\t\t\tunsigned int port_id_in,\n\t\t\t\tunsigned int vport_type,\n\t\t\t\tu16 vlan,\n\t\t\t\tunsigned int *port_id_out)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ALLOC_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_ALLOC_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tEFX_WARN_ON_PARANOID(!port_id_out);\n\n\tMCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_UPSTREAM_PORT_ID, port_id_in);\n\tMCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_TYPE, vport_type);\n\tMCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_NUM_VLAN_TAGS,\n\t\t       (vlan != EFX_EF10_NO_VLAN));\n\tMCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_FLAGS,\n\t\t\t      VPORT_ALLOC_IN_FLAG_AUTO_PORT, 0);\n\tif (vlan != EFX_EF10_NO_VLAN)\n\t\tMCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_VLAN_TAGS,\n\t\t\t\t      VPORT_ALLOC_IN_VLAN_TAG_0, vlan);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_VPORT_ALLOC, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_VPORT_ALLOC_OUT_LEN)\n\t\treturn -EIO;\n\n\t*port_id_out = MCDI_DWORD(outbuf, VPORT_ALLOC_OUT_VPORT_ID);\n\treturn 0;\n}\n\nstatic int efx_ef10_vport_free(struct efx_nic *efx, unsigned int port_id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_FREE_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, VPORT_FREE_IN_VPORT_ID, port_id);\n\n\treturn efx_mcdi_rpc(efx, MC_CMD_VPORT_FREE, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nstatic void efx_ef10_sriov_free_vf_vports(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint i;\n\n\tif (!nic_data->vf)\n\t\treturn;\n\n\tfor (i = 0; i < efx->vf_count; i++) {\n\t\tstruct ef10_vf *vf = nic_data->vf + i;\n\n\t\t \n\t\tif (vf->pci_dev && pci_is_dev_assigned(vf->pci_dev))\n\t\t\tcontinue;\n\n\t\tif (vf->vport_assigned) {\n\t\t\tefx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, i);\n\t\t\tvf->vport_assigned = 0;\n\t\t}\n\n\t\tif (!is_zero_ether_addr(vf->mac)) {\n\t\t\tefx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);\n\t\t\teth_zero_addr(vf->mac);\n\t\t}\n\n\t\tif (vf->vport_id) {\n\t\t\tefx_ef10_vport_free(efx, vf->vport_id);\n\t\t\tvf->vport_id = 0;\n\t\t}\n\n\t\tvf->efx = NULL;\n\t}\n}\n\nstatic void efx_ef10_sriov_free_vf_vswitching(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tefx_ef10_sriov_free_vf_vports(efx);\n\tkfree(nic_data->vf);\n\tnic_data->vf = NULL;\n}\n\nstatic int efx_ef10_sriov_assign_vf_vport(struct efx_nic *efx,\n\t\t\t\t\t  unsigned int vf_i)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct ef10_vf *vf = nic_data->vf + vf_i;\n\tint rc;\n\n\tif (WARN_ON_ONCE(!nic_data->vf))\n\t\treturn -EOPNOTSUPP;\n\n\trc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,\n\t\t\t\t  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,\n\t\t\t\t  vf->vlan, &vf->vport_id);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);\n\tif (rc) {\n\t\teth_zero_addr(vf->mac);\n\t\treturn rc;\n\t}\n\n\trc =  efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);\n\tif (rc)\n\t\treturn rc;\n\n\tvf->vport_assigned = 1;\n\treturn 0;\n}\n\nstatic int efx_ef10_sriov_alloc_vf_vswitching(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tunsigned int i;\n\tint rc;\n\n\tnic_data->vf = kcalloc(efx->vf_count, sizeof(struct ef10_vf),\n\t\t\t       GFP_KERNEL);\n\tif (!nic_data->vf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < efx->vf_count; i++) {\n\t\teth_random_addr(nic_data->vf[i].mac);\n\t\tnic_data->vf[i].efx = NULL;\n\t\tnic_data->vf[i].vlan = EFX_EF10_NO_VLAN;\n\n\t\trc = efx_ef10_sriov_assign_vf_vport(efx, i);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tefx_ef10_sriov_free_vf_vswitching(efx);\n\treturn rc;\n}\n\nstatic int efx_ef10_sriov_restore_vf_vswitching(struct efx_nic *efx)\n{\n\tunsigned int i;\n\tint rc;\n\n\tfor (i = 0; i < efx->vf_count; i++) {\n\t\trc = efx_ef10_sriov_assign_vf_vport(efx, i);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tefx_ef10_sriov_free_vf_vswitching(efx);\n\treturn rc;\n}\n\nstatic int efx_ef10_vadaptor_alloc_set_features(struct efx_nic *efx)\n{\n\tu32 port_flags;\n\tint rc;\n\n\trc = efx_ef10_vadaptor_alloc(efx, efx->vport_id);\n\tif (rc)\n\t\tgoto fail_vadaptor_alloc;\n\n\trc = efx_ef10_vadaptor_query(efx, efx->vport_id,\n\t\t\t\t     &port_flags, NULL, NULL);\n\tif (rc)\n\t\tgoto fail_vadaptor_query;\n\n\tif (port_flags &\n\t    (1 << MC_CMD_VPORT_ALLOC_IN_FLAG_VLAN_RESTRICT_LBN))\n\t\tefx->fixed_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\telse\n\t\tefx->fixed_features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\treturn 0;\n\nfail_vadaptor_query:\n\tefx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);\nfail_vadaptor_alloc:\n\treturn rc;\n}\n\n \nint efx_ef10_vswitching_probe_pf(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct net_device *net_dev = efx->net_dev;\n\tint rc;\n\n\tif (pci_sriov_get_totalvfs(efx->pci_dev) <= 0) {\n\t\t \n\t\tefx_ef10_vadaptor_alloc_set_features(efx);\n\t\treturn 0;\n\t}\n\n\trc = efx_ef10_vswitch_alloc(efx, EVB_PORT_ID_ASSIGNED,\n\t\t\t\t    MC_CMD_VSWITCH_ALLOC_IN_VSWITCH_TYPE_VEB);\n\tif (rc)\n\t\tgoto fail1;\n\n\trc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,\n\t\t\t\t  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,\n\t\t\t\t  EFX_EF10_NO_VLAN, &efx->vport_id);\n\tif (rc)\n\t\tgoto fail2;\n\n\trc = efx_ef10_vport_add_mac(efx, efx->vport_id, net_dev->dev_addr);\n\tif (rc)\n\t\tgoto fail3;\n\tether_addr_copy(nic_data->vport_mac, net_dev->dev_addr);\n\n\trc = efx_ef10_vadaptor_alloc_set_features(efx);\n\tif (rc)\n\t\tgoto fail4;\n\n\treturn 0;\nfail4:\n\tefx_ef10_vport_del_mac(efx, efx->vport_id, nic_data->vport_mac);\n\teth_zero_addr(nic_data->vport_mac);\nfail3:\n\tefx_ef10_vport_free(efx, efx->vport_id);\n\tefx->vport_id = EVB_PORT_ID_ASSIGNED;\nfail2:\n\tefx_ef10_vswitch_free(efx, EVB_PORT_ID_ASSIGNED);\nfail1:\n\treturn rc;\n}\n\nint efx_ef10_vswitching_probe_vf(struct efx_nic *efx)\n{\n\treturn efx_ef10_vadaptor_alloc_set_features(efx);\n}\n\nint efx_ef10_vswitching_restore_pf(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\tif (!nic_data->must_probe_vswitching)\n\t\treturn 0;\n\n\trc = efx_ef10_vswitching_probe_pf(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_ef10_sriov_restore_vf_vswitching(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\tnic_data->must_probe_vswitching = false;\nfail:\n\treturn rc;\n}\n\nint efx_ef10_vswitching_restore_vf(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\tif (!nic_data->must_probe_vswitching)\n\t\treturn 0;\n\n\trc = efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);\n\tif (rc)\n\t\treturn rc;\n\n\tnic_data->must_probe_vswitching = false;\n\treturn 0;\n}\n\nvoid efx_ef10_vswitching_remove_pf(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tefx_ef10_sriov_free_vf_vswitching(efx);\n\n\tefx_ef10_vadaptor_free(efx, efx->vport_id);\n\n\tif (efx->vport_id == EVB_PORT_ID_ASSIGNED)\n\t\treturn;  \n\n\tif (!is_zero_ether_addr(nic_data->vport_mac)) {\n\t\tefx_ef10_vport_del_mac(efx, efx->vport_id,\n\t\t\t\t       efx->net_dev->dev_addr);\n\t\teth_zero_addr(nic_data->vport_mac);\n\t}\n\tefx_ef10_vport_free(efx, efx->vport_id);\n\tefx->vport_id = EVB_PORT_ID_ASSIGNED;\n\n\t \n\tif (!pci_vfs_assigned(efx->pci_dev))\n\t\tefx_ef10_vswitch_free(efx, efx->vport_id);\n}\n\nvoid efx_ef10_vswitching_remove_vf(struct efx_nic *efx)\n{\n\tefx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);\n}\n\nstatic int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)\n{\n\tint rc = 0;\n\tstruct pci_dev *dev = efx->pci_dev;\n\n\tefx->vf_count = num_vfs;\n\n\trc = efx_ef10_sriov_alloc_vf_vswitching(efx);\n\tif (rc)\n\t\tgoto fail1;\n\n\trc = pci_enable_sriov(dev, num_vfs);\n\tif (rc)\n\t\tgoto fail2;\n\n\treturn 0;\nfail2:\n\tefx_ef10_sriov_free_vf_vswitching(efx);\nfail1:\n\tefx->vf_count = 0;\n\tnetif_err(efx, probe, efx->net_dev,\n\t\t  \"Failed to enable SRIOV VFs\\n\");\n\treturn rc;\n}\n\n \nstatic int efx_ef10_pci_sriov_disable(struct efx_nic *efx, bool force)\n{\n\tstruct pci_dev *dev = efx->pci_dev;\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tunsigned int vfs_assigned = pci_vfs_assigned(dev);\n\tint i, rc = 0;\n\n\tif (vfs_assigned && !force) {\n\t\tnetif_info(efx, drv, efx->net_dev, \"VFs are assigned to guests; \"\n\t\t\t   \"please detach them before disabling SR-IOV\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!vfs_assigned) {\n\t\tfor (i = 0; i < efx->vf_count; i++)\n\t\t\tnic_data->vf[i].pci_dev = NULL;\n\t\tpci_disable_sriov(dev);\n\t} else {\n\t\trc = -EBUSY;\n\t}\n\n\tefx_ef10_sriov_free_vf_vswitching(efx);\n\tefx->vf_count = 0;\n\treturn rc;\n}\n\nint efx_ef10_sriov_configure(struct efx_nic *efx, int num_vfs)\n{\n\tif (num_vfs == 0)\n\t\treturn efx_ef10_pci_sriov_disable(efx, false);\n\telse\n\t\treturn efx_ef10_pci_sriov_enable(efx, num_vfs);\n}\n\nint efx_ef10_sriov_init(struct efx_nic *efx)\n{\n\treturn 0;\n}\n\nvoid efx_ef10_sriov_fini(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\tif (!nic_data->vf) {\n\t\t \n\t\tif (pci_num_vf(efx->pci_dev) && !pci_vfs_assigned(efx->pci_dev))\n\t\t\tpci_disable_sriov(efx->pci_dev);\n\t\treturn;\n\t}\n\n\t \n\trc = efx_ef10_pci_sriov_disable(efx, true);\n\tif (rc)\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Disabling SRIOV was not successful rc=%d\\n\", rc);\n\telse\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"SRIOV disabled\\n\");\n}\n\nstatic int efx_ef10_vport_del_vf_mac(struct efx_nic *efx, unsigned int port_id,\n\t\t\t\t     u8 *mac)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);\n\tether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\n\treturn rc;\n}\n\nint efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, const u8 *mac)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct ef10_vf *vf;\n\tint rc;\n\n\tif (!nic_data->vf)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf_i >= efx->vf_count)\n\t\treturn -EINVAL;\n\tvf = nic_data->vf + vf_i;\n\n\tif (vf->efx) {\n\t\tefx_device_detach_sync(vf->efx);\n\t\tefx_net_stop(vf->efx->net_dev);\n\n\t\tvf->efx->type->filter_table_remove(vf->efx);\n\n\t\trc = efx_ef10_vadaptor_free(vf->efx, EVB_PORT_ID_ASSIGNED);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, vf_i);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!is_zero_ether_addr(vf->mac)) {\n\t\trc = efx_ef10_vport_del_vf_mac(efx, vf->vport_id, vf->mac);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (!is_zero_ether_addr(mac)) {\n\t\trc = efx_ef10_vport_add_mac(efx, vf->vport_id, mac);\n\t\tif (rc)\n\t\t\tgoto fail;\n\n\t\tif (vf->efx)\n\t\t\teth_hw_addr_set(vf->efx->net_dev, mac);\n\t}\n\n\tether_addr_copy(vf->mac, mac);\n\n\trc = efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (vf->efx) {\n\t\t \n\t\trc = efx_ef10_vadaptor_alloc(vf->efx, EVB_PORT_ID_ASSIGNED);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tvf->efx->type->filter_table_probe(vf->efx);\n\t\tefx_net_open(vf->efx->net_dev);\n\t\tefx_device_attach_if_not_resetting(vf->efx);\n\t}\n\n\treturn 0;\n\nfail:\n\teth_zero_addr(vf->mac);\n\treturn rc;\n}\n\nint efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i, u16 vlan,\n\t\t\t       u8 qos)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct ef10_vf *vf;\n\tu16 new_vlan;\n\tint rc = 0, rc2 = 0;\n\n\tif (vf_i >= efx->vf_count)\n\t\treturn -EINVAL;\n\tif (qos != 0)\n\t\treturn -EINVAL;\n\n\tvf = nic_data->vf + vf_i;\n\n\tnew_vlan = (vlan == 0) ? EFX_EF10_NO_VLAN : vlan;\n\tif (new_vlan == vf->vlan)\n\t\treturn 0;\n\n\tif (vf->efx) {\n\t\tefx_device_detach_sync(vf->efx);\n\t\tefx_net_stop(vf->efx->net_dev);\n\n\t\tmutex_lock(&vf->efx->mac_lock);\n\t\tvf->efx->type->filter_table_remove(vf->efx);\n\n\t\trc = efx_ef10_vadaptor_free(vf->efx, EVB_PORT_ID_ASSIGNED);\n\t\tif (rc)\n\t\t\tgoto restore_filters;\n\t}\n\n\tif (vf->vport_assigned) {\n\t\trc = efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, vf_i);\n\t\tif (rc) {\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"Failed to change vlan on VF %d.\\n\", vf_i);\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"This is likely because the VF is bound to a driver in a VM.\\n\");\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"Please unload the driver in the VM.\\n\");\n\t\t\tgoto restore_vadaptor;\n\t\t}\n\t\tvf->vport_assigned = 0;\n\t}\n\n\tif (!is_zero_ether_addr(vf->mac)) {\n\t\trc = efx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);\n\t\tif (rc)\n\t\t\tgoto restore_evb_port;\n\t}\n\n\tif (vf->vport_id) {\n\t\trc = efx_ef10_vport_free(efx, vf->vport_id);\n\t\tif (rc)\n\t\t\tgoto restore_mac;\n\t\tvf->vport_id = 0;\n\t}\n\n\t \n\tvf->vlan = new_vlan;\n\n\t \n\trc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,\n\t\t\t\t  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,\n\t\t\t\t  vf->vlan, &vf->vport_id);\n\tif (rc)\n\t\tgoto reset_nic_up_write;\n\nrestore_mac:\n\tif (!is_zero_ether_addr(vf->mac)) {\n\t\trc2 = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);\n\t\tif (rc2) {\n\t\t\teth_zero_addr(vf->mac);\n\t\t\tgoto reset_nic_up_write;\n\t\t}\n\t}\n\nrestore_evb_port:\n\trc2 = efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);\n\tif (rc2)\n\t\tgoto reset_nic_up_write;\n\telse\n\t\tvf->vport_assigned = 1;\n\nrestore_vadaptor:\n\tif (vf->efx) {\n\t\trc2 = efx_ef10_vadaptor_alloc(vf->efx, EVB_PORT_ID_ASSIGNED);\n\t\tif (rc2)\n\t\t\tgoto reset_nic_up_write;\n\t}\n\nrestore_filters:\n\tif (vf->efx) {\n\t\trc2 = vf->efx->type->filter_table_probe(vf->efx);\n\t\tif (rc2)\n\t\t\tgoto reset_nic_up_write;\n\n\t\tmutex_unlock(&vf->efx->mac_lock);\n\n\t\trc2 = efx_net_open(vf->efx->net_dev);\n\t\tif (rc2)\n\t\t\tgoto reset_nic;\n\n\t\tefx_device_attach_if_not_resetting(vf->efx);\n\t}\n\treturn rc;\n\nreset_nic_up_write:\n\tif (vf->efx)\n\t\tmutex_unlock(&vf->efx->mac_lock);\nreset_nic:\n\tif (vf->efx) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Failed to restore VF - scheduling reset.\\n\");\n\t\tefx_schedule_reset(vf->efx, RESET_TYPE_DATAPATH);\n\t} else {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Failed to restore the VF and cannot reset the VF \"\n\t\t\t  \"- VF is not functional.\\n\");\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Please reload the driver attached to the VF.\\n\");\n\t}\n\n\treturn rc ? rc : rc2;\n}\n\nstatic int efx_ef10_sriov_set_privilege_mask(struct efx_nic *efx, int vf_i,\n\t\t\t\t\t     u32 mask, u32 value)\n{\n\tMCDI_DECLARE_BUF(pm_outbuf, MC_CMD_PRIVILEGE_MASK_OUT_LEN);\n\tMCDI_DECLARE_BUF(pm_inbuf, MC_CMD_PRIVILEGE_MASK_IN_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tu32 old_mask, new_mask;\n\tsize_t outlen;\n\tint rc;\n\n\tEFX_WARN_ON_PARANOID((value & ~mask) != 0);\n\n\t \n\tMCDI_POPULATE_DWORD_2(pm_inbuf, PRIVILEGE_MASK_IN_FUNCTION,\n\t\t\t      PRIVILEGE_MASK_IN_FUNCTION_PF, nic_data->pf_index,\n\t\t\t      PRIVILEGE_MASK_IN_FUNCTION_VF, vf_i);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_PRIVILEGE_MASK,\n\t\t\t  pm_inbuf, sizeof(pm_inbuf),\n\t\t\t  pm_outbuf, sizeof(pm_outbuf), &outlen);\n\n\tif (rc != 0)\n\t\treturn rc;\n\tif (outlen != MC_CMD_PRIVILEGE_MASK_OUT_LEN)\n\t\treturn -EIO;\n\n\told_mask = MCDI_DWORD(pm_outbuf, PRIVILEGE_MASK_OUT_OLD_MASK);\n\n\tnew_mask = old_mask & ~mask;\n\tnew_mask |= value;\n\n\tif (new_mask == old_mask)\n\t\treturn 0;\n\n\tnew_mask |= MC_CMD_PRIVILEGE_MASK_IN_DO_CHANGE;\n\n\t \n\tMCDI_SET_DWORD(pm_inbuf, PRIVILEGE_MASK_IN_NEW_MASK, new_mask);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_PRIVILEGE_MASK,\n\t\t\t  pm_inbuf, sizeof(pm_inbuf),\n\t\t\t  pm_outbuf, sizeof(pm_outbuf), &outlen);\n\n\tif (rc != 0)\n\t\treturn rc;\n\tif (outlen != MC_CMD_PRIVILEGE_MASK_OUT_LEN)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint efx_ef10_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf_i, bool spoofchk)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\t \n\tif (!(nic_data->datapath_caps &\n\t      BIT(MC_CMD_GET_CAPABILITIES_OUT_TX_MAC_SECURITY_FILTERING_LBN)) &&\n\t    spoofchk)\n\t\treturn -EOPNOTSUPP;\n\n\treturn efx_ef10_sriov_set_privilege_mask(efx, vf_i,\n\t\tMC_CMD_PRIVILEGE_MASK_IN_GRP_MAC_SPOOFING_TX,\n\t\tspoofchk ? 0 : MC_CMD_PRIVILEGE_MASK_IN_GRP_MAC_SPOOFING_TX);\n}\n\nint efx_ef10_sriov_set_vf_link_state(struct efx_nic *efx, int vf_i,\n\t\t\t\t     int link_state)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_LINK_STATE_MODE_IN_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tBUILD_BUG_ON(IFLA_VF_LINK_STATE_AUTO !=\n\t\t     MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_AUTO);\n\tBUILD_BUG_ON(IFLA_VF_LINK_STATE_ENABLE !=\n\t\t     MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_UP);\n\tBUILD_BUG_ON(IFLA_VF_LINK_STATE_DISABLE !=\n\t\t     MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_DOWN);\n\tMCDI_POPULATE_DWORD_2(inbuf, LINK_STATE_MODE_IN_FUNCTION,\n\t\t\t      LINK_STATE_MODE_IN_FUNCTION_PF,\n\t\t\t      nic_data->pf_index,\n\t\t\t      LINK_STATE_MODE_IN_FUNCTION_VF, vf_i);\n\tMCDI_SET_DWORD(inbuf, LINK_STATE_MODE_IN_NEW_MODE, link_state);\n\treturn efx_mcdi_rpc(efx, MC_CMD_LINK_STATE_MODE, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);  \n}\n\nint efx_ef10_sriov_get_vf_config(struct efx_nic *efx, int vf_i,\n\t\t\t\t struct ifla_vf_info *ivf)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_LINK_STATE_MODE_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_LINK_STATE_MODE_OUT_LEN);\n\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct ef10_vf *vf;\n\tsize_t outlen;\n\tint rc;\n\n\tif (vf_i >= efx->vf_count)\n\t\treturn -EINVAL;\n\n\tif (!nic_data->vf)\n\t\treturn -EOPNOTSUPP;\n\n\tvf = nic_data->vf + vf_i;\n\n\tivf->vf = vf_i;\n\tivf->min_tx_rate = 0;\n\tivf->max_tx_rate = 0;\n\tether_addr_copy(ivf->mac, vf->mac);\n\tivf->vlan = (vf->vlan == EFX_EF10_NO_VLAN) ? 0 : vf->vlan;\n\tivf->qos = 0;\n\n\tMCDI_POPULATE_DWORD_2(inbuf, LINK_STATE_MODE_IN_FUNCTION,\n\t\t\t      LINK_STATE_MODE_IN_FUNCTION_PF,\n\t\t\t      nic_data->pf_index,\n\t\t\t      LINK_STATE_MODE_IN_FUNCTION_VF, vf_i);\n\tMCDI_SET_DWORD(inbuf, LINK_STATE_MODE_IN_NEW_MODE,\n\t\t       MC_CMD_LINK_STATE_MODE_IN_DO_NOT_CHANGE);\n\trc = efx_mcdi_rpc(efx, MC_CMD_LINK_STATE_MODE, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_LINK_STATE_MODE_OUT_LEN)\n\t\treturn -EIO;\n\tivf->linkstate = MCDI_DWORD(outbuf, LINK_STATE_MODE_OUT_OLD_MODE);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}