{
  "module_name": "ef10.c",
  "hash_id": "239c635b8acb63b19da084d28b9102ea5f24c81aaac92a6565b6ca4a492696f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef10.c",
  "human_readable_source": "\n \n\n#include \"net_driver.h\"\n#include \"rx_common.h\"\n#include \"tx_common.h\"\n#include \"ef10_regs.h\"\n#include \"io.h\"\n#include \"mcdi.h\"\n#include \"mcdi_pcol.h\"\n#include \"mcdi_port.h\"\n#include \"mcdi_port_common.h\"\n#include \"mcdi_functions.h\"\n#include \"nic.h\"\n#include \"mcdi_filters.h\"\n#include \"workarounds.h\"\n#include \"selftest.h\"\n#include \"ef10_sriov.h\"\n#include <linux/in.h>\n#include <linux/jhash.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <net/udp_tunnel.h>\n\n \n\n#define EFX_EF10_DRVGEN_EV\t\t7\nenum {\n\tEFX_EF10_TEST = 1,\n\tEFX_EF10_REFILL,\n};\n\n \nstruct efx_ef10_vlan {\n\tstruct list_head list;\n\tu16 vid;\n};\n\nstatic int efx_ef10_set_udp_tnl_ports(struct efx_nic *efx, bool unloading);\nstatic const struct udp_tunnel_nic_info efx_ef10_udp_tunnels;\n\nstatic int efx_ef10_get_warm_boot_count(struct efx_nic *efx)\n{\n\tefx_dword_t reg;\n\n\tefx_readd(efx, &reg, ER_DZ_BIU_MC_SFT_STATUS);\n\treturn EFX_DWORD_FIELD(reg, EFX_WORD_1) == 0xb007 ?\n\t\tEFX_DWORD_FIELD(reg, EFX_WORD_0) : -EIO;\n}\n\n \nstatic unsigned int efx_ef10_pf_mem_bar(struct efx_nic *efx)\n{\n\tswitch (efx->pci_dev->device) {\n\tcase 0x0b03:  \n\t\treturn 0;\n\tdefault:\n\t\treturn 2;\n\t}\n}\n\n \nstatic unsigned int efx_ef10_vf_mem_bar(struct efx_nic *efx)\n{\n\treturn 0;\n}\n\nstatic unsigned int efx_ef10_mem_map_size(struct efx_nic *efx)\n{\n\tint bar;\n\n\tbar = efx->type->mem_bar(efx);\n\treturn resource_size(&efx->pci_dev->resource[bar]);\n}\n\nstatic bool efx_ef10_is_vf(struct efx_nic *efx)\n{\n\treturn efx->type->is_vf;\n}\n\n#ifdef CONFIG_SFC_SRIOV\nstatic int efx_ef10_get_vf_index(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_FUNCTION_INFO_OUT_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tsize_t outlen;\n\tint rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_FUNCTION_INFO, NULL, 0, outbuf,\n\t\t\t  sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\n\tnic_data->vf_index = MCDI_DWORD(outbuf, GET_FUNCTION_INFO_OUT_VF);\n\treturn 0;\n}\n#endif\n\nstatic int efx_ef10_init_datapath_caps(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_CAPABILITIES_V4_OUT_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_CAPABILITIES_IN_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_CAPABILITIES, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_GET_CAPABILITIES_OUT_LEN) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"unable to read datapath firmware capabilities\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnic_data->datapath_caps =\n\t\tMCDI_DWORD(outbuf, GET_CAPABILITIES_OUT_FLAGS1);\n\n\tif (outlen >= MC_CMD_GET_CAPABILITIES_V2_OUT_LEN) {\n\t\tnic_data->datapath_caps2 = MCDI_DWORD(outbuf,\n\t\t\t\tGET_CAPABILITIES_V2_OUT_FLAGS2);\n\t\tnic_data->piobuf_size = MCDI_WORD(outbuf,\n\t\t\t\tGET_CAPABILITIES_V2_OUT_SIZE_PIO_BUFF);\n\t} else {\n\t\tnic_data->datapath_caps2 = 0;\n\t\tnic_data->piobuf_size = ER_DZ_TX_PIOBUF_SIZE;\n\t}\n\n\t \n\tnic_data->rx_dpcpu_fw_id =\n\t\tMCDI_WORD(outbuf, GET_CAPABILITIES_OUT_RX_DPCPU_FW_ID);\n\tnic_data->tx_dpcpu_fw_id =\n\t\tMCDI_WORD(outbuf, GET_CAPABILITIES_OUT_TX_DPCPU_FW_ID);\n\n\tif (!(nic_data->datapath_caps &\n\t      (1 << MC_CMD_GET_CAPABILITIES_OUT_RX_PREFIX_LEN_14_LBN))) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"current firmware does not support an RX prefix\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (outlen >= MC_CMD_GET_CAPABILITIES_V3_OUT_LEN) {\n\t\tu8 vi_window_mode = MCDI_BYTE(outbuf,\n\t\t\t\tGET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE);\n\n\t\trc = efx_mcdi_window_mode_to_stride(efx, vi_window_mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\t \n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"firmware did not report VI window mode, assuming vi_stride = %u\\n\",\n\t\t\t  efx->vi_stride);\n\t}\n\n\tif (outlen >= MC_CMD_GET_CAPABILITIES_V4_OUT_LEN) {\n\t\tefx->num_mac_stats = MCDI_WORD(outbuf,\n\t\t\t\tGET_CAPABILITIES_V4_OUT_MAC_STATS_NUM_STATS);\n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"firmware reports num_mac_stats = %u\\n\",\n\t\t\t  efx->num_mac_stats);\n\t} else {\n\t\t \n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"firmware did not report num_mac_stats, assuming %u\\n\",\n\t\t\t  efx->num_mac_stats);\n\t}\n\n\treturn 0;\n}\n\nstatic void efx_ef10_read_licensed_features(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_LICENSING_V3_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_LICENSING_V3_OUT_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, LICENSING_V3_IN_OP,\n\t\t       MC_CMD_LICENSING_V3_IN_OP_REPORT_LICENSE);\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_LICENSING_V3, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\tif (rc || (outlen < MC_CMD_LICENSING_V3_OUT_LEN))\n\t\treturn;\n\n\tnic_data->licensed_features = MCDI_QWORD(outbuf,\n\t\t\t\t\t LICENSING_V3_OUT_LICENSED_FEATURES);\n}\n\nstatic int efx_ef10_get_sysclk_freq(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_CLOCK_OUT_LEN);\n\tint rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_CLOCK, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), NULL);\n\tif (rc)\n\t\treturn rc;\n\trc = MCDI_DWORD(outbuf, GET_CLOCK_OUT_SYS_FREQ);\n\treturn rc > 0 ? rc : -ERANGE;\n}\n\nstatic int efx_ef10_get_timer_workarounds(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tunsigned int implemented;\n\tunsigned int enabled;\n\tint rc;\n\n\tnic_data->workaround_35388 = false;\n\tnic_data->workaround_61265 = false;\n\n\trc = efx_mcdi_get_workarounds(efx, &implemented, &enabled);\n\n\tif (rc == -ENOSYS) {\n\t\t \n\t\trc = 0;\n\t} else if (rc == 0) {\n\t\t \n\t\tif (enabled & MC_CMD_GET_WORKAROUNDS_OUT_BUG61265)\n\t\t\tnic_data->workaround_61265 = true;\n\n\t\tif (enabled & MC_CMD_GET_WORKAROUNDS_OUT_BUG35388) {\n\t\t\tnic_data->workaround_35388 = true;\n\t\t} else if (implemented & MC_CMD_GET_WORKAROUNDS_OUT_BUG35388) {\n\t\t\t \n\t\t\trc = efx_mcdi_set_workaround(efx,\n\t\t\t\t\t\t     MC_CMD_WORKAROUND_BUG35388,\n\t\t\t\t\t\t     true, NULL);\n\t\t\tif (rc == 0)\n\t\t\t\tnic_data->workaround_35388 = true;\n\t\t\t \n\t\t\trc = 0;\n\t\t}\n\t}\n\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"workaround for bug 35388 is %sabled\\n\",\n\t\t  nic_data->workaround_35388 ? \"en\" : \"dis\");\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"workaround for bug 61265 is %sabled\\n\",\n\t\t  nic_data->workaround_61265 ? \"en\" : \"dis\");\n\n\treturn rc;\n}\n\nstatic void efx_ef10_process_timer_config(struct efx_nic *efx,\n\t\t\t\t\t  const efx_dword_t *data)\n{\n\tunsigned int max_count;\n\n\tif (EFX_EF10_WORKAROUND_61265(efx)) {\n\t\tefx->timer_quantum_ns = MCDI_DWORD(data,\n\t\t\tGET_EVQ_TMR_PROPERTIES_OUT_MCDI_TMR_STEP_NS);\n\t\tefx->timer_max_ns = MCDI_DWORD(data,\n\t\t\tGET_EVQ_TMR_PROPERTIES_OUT_MCDI_TMR_MAX_NS);\n\t} else if (EFX_EF10_WORKAROUND_35388(efx)) {\n\t\tefx->timer_quantum_ns = MCDI_DWORD(data,\n\t\t\tGET_EVQ_TMR_PROPERTIES_OUT_BUG35388_TMR_NS_PER_COUNT);\n\t\tmax_count = MCDI_DWORD(data,\n\t\t\tGET_EVQ_TMR_PROPERTIES_OUT_BUG35388_TMR_MAX_COUNT);\n\t\tefx->timer_max_ns = max_count * efx->timer_quantum_ns;\n\t} else {\n\t\tefx->timer_quantum_ns = MCDI_DWORD(data,\n\t\t\tGET_EVQ_TMR_PROPERTIES_OUT_TMR_REG_NS_PER_COUNT);\n\t\tmax_count = MCDI_DWORD(data,\n\t\t\tGET_EVQ_TMR_PROPERTIES_OUT_TMR_REG_MAX_COUNT);\n\t\tefx->timer_max_ns = max_count * efx->timer_quantum_ns;\n\t}\n\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"got timer properties from MC: quantum %u ns; max %u ns\\n\",\n\t\t  efx->timer_quantum_ns, efx->timer_max_ns);\n}\n\nstatic int efx_ef10_get_timer_config(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_LEN);\n\tint rc;\n\n\trc = efx_ef10_get_timer_workarounds(efx);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_GET_EVQ_TMR_PROPERTIES, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), NULL);\n\n\tif (rc == 0) {\n\t\tefx_ef10_process_timer_config(efx, outbuf);\n\t} else if (rc == -ENOSYS || rc == -EPERM) {\n\t\t \n\t\tunsigned int quantum;\n\n\t\trc = efx_ef10_get_sysclk_freq(efx);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tquantum = 1536000 / rc;  \n\t\tefx->timer_quantum_ns = quantum;\n\t\tefx->timer_max_ns = efx->type->timer_period_max * quantum;\n\t\trc = 0;\n\t} else {\n\t\tefx_mcdi_display_error(efx, MC_CMD_GET_EVQ_TMR_PROPERTIES,\n\t\t\t\t       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_LEN,\n\t\t\t\t       NULL, 0, rc);\n\t}\n\n\treturn rc;\n}\n\nstatic int efx_ef10_get_mac_address_pf(struct efx_nic *efx, u8 *mac_address)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_MAC_ADDRESSES_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_MAC_ADDRESSES_IN_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_MAC_ADDRESSES, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_GET_MAC_ADDRESSES_OUT_LEN)\n\t\treturn -EIO;\n\n\tether_addr_copy(mac_address,\n\t\t\tMCDI_PTR(outbuf, GET_MAC_ADDRESSES_OUT_MAC_ADDR_BASE));\n\treturn 0;\n}\n\nstatic int efx_ef10_get_mac_address_vf(struct efx_nic *efx, u8 *mac_address)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_GET_MAC_ADDRESSES_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMAX);\n\tsize_t outlen;\n\tint num_addrs, rc;\n\n\tMCDI_SET_DWORD(inbuf, VPORT_GET_MAC_ADDRESSES_IN_VPORT_ID,\n\t\t       EVB_PORT_ID_ASSIGNED);\n\trc = efx_mcdi_rpc(efx, MC_CMD_VPORT_GET_MAC_ADDRESSES, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMIN)\n\t\treturn -EIO;\n\n\tnum_addrs = MCDI_DWORD(outbuf,\n\t\t\t       VPORT_GET_MAC_ADDRESSES_OUT_MACADDR_COUNT);\n\n\tWARN_ON(num_addrs != 1);\n\n\tether_addr_copy(mac_address,\n\t\t\tMCDI_PTR(outbuf, VPORT_GET_MAC_ADDRESSES_OUT_MACADDR));\n\n\treturn 0;\n}\n\nstatic ssize_t link_control_flag_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct efx_nic *efx = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       ((efx->mcdi->fn_flags) &\n\t\t\t(1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL))\n\t\t       ? 1 : 0);\n}\n\nstatic ssize_t primary_flag_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct efx_nic *efx = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       ((efx->mcdi->fn_flags) &\n\t\t\t(1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY))\n\t\t       ? 1 : 0);\n}\n\nstatic struct efx_ef10_vlan *efx_ef10_find_vlan(struct efx_nic *efx, u16 vid)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct efx_ef10_vlan *vlan;\n\n\tWARN_ON(!mutex_is_locked(&nic_data->vlan_lock));\n\n\tlist_for_each_entry(vlan, &nic_data->vlan_list, list) {\n\t\tif (vlan->vid == vid)\n\t\t\treturn vlan;\n\t}\n\n\treturn NULL;\n}\n\nstatic int efx_ef10_add_vlan(struct efx_nic *efx, u16 vid)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct efx_ef10_vlan *vlan;\n\tint rc;\n\n\tmutex_lock(&nic_data->vlan_lock);\n\n\tvlan = efx_ef10_find_vlan(efx, vid);\n\tif (vlan) {\n\t\t \n\t\tif (vid == 0)\n\t\t\tgoto done_unlock;\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"VLAN %u already added\\n\", vid);\n\t\trc = -EALREADY;\n\t\tgoto fail_exist;\n\t}\n\n\trc = -ENOMEM;\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\tgoto fail_alloc;\n\n\tvlan->vid = vid;\n\n\tlist_add_tail(&vlan->list, &nic_data->vlan_list);\n\n\tif (efx->filter_state) {\n\t\tmutex_lock(&efx->mac_lock);\n\t\tdown_write(&efx->filter_sem);\n\t\trc = efx_mcdi_filter_add_vlan(efx, vlan->vid);\n\t\tup_write(&efx->filter_sem);\n\t\tmutex_unlock(&efx->mac_lock);\n\t\tif (rc)\n\t\t\tgoto fail_filter_add_vlan;\n\t}\n\ndone_unlock:\n\tmutex_unlock(&nic_data->vlan_lock);\n\treturn 0;\n\nfail_filter_add_vlan:\n\tlist_del(&vlan->list);\n\tkfree(vlan);\nfail_alloc:\nfail_exist:\n\tmutex_unlock(&nic_data->vlan_lock);\n\treturn rc;\n}\n\nstatic void efx_ef10_del_vlan_internal(struct efx_nic *efx,\n\t\t\t\t       struct efx_ef10_vlan *vlan)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tWARN_ON(!mutex_is_locked(&nic_data->vlan_lock));\n\n\tif (efx->filter_state) {\n\t\tdown_write(&efx->filter_sem);\n\t\tefx_mcdi_filter_del_vlan(efx, vlan->vid);\n\t\tup_write(&efx->filter_sem);\n\t}\n\n\tlist_del(&vlan->list);\n\tkfree(vlan);\n}\n\nstatic int efx_ef10_del_vlan(struct efx_nic *efx, u16 vid)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct efx_ef10_vlan *vlan;\n\tint rc = 0;\n\n\t \n\tif (vid == 0)\n\t\treturn 0;\n\n\tmutex_lock(&nic_data->vlan_lock);\n\n\tvlan = efx_ef10_find_vlan(efx, vid);\n\tif (!vlan) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"VLAN %u to be deleted not found\\n\", vid);\n\t\trc = -ENOENT;\n\t} else {\n\t\tefx_ef10_del_vlan_internal(efx, vlan);\n\t}\n\n\tmutex_unlock(&nic_data->vlan_lock);\n\n\treturn rc;\n}\n\nstatic void efx_ef10_cleanup_vlans(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct efx_ef10_vlan *vlan, *next_vlan;\n\n\tmutex_lock(&nic_data->vlan_lock);\n\tlist_for_each_entry_safe(vlan, next_vlan, &nic_data->vlan_list, list)\n\t\tefx_ef10_del_vlan_internal(efx, vlan);\n\tmutex_unlock(&nic_data->vlan_lock);\n}\n\nstatic DEVICE_ATTR_RO(link_control_flag);\nstatic DEVICE_ATTR_RO(primary_flag);\n\nstatic int efx_ef10_probe(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data;\n\tint i, rc;\n\n\tnic_data = kzalloc(sizeof(*nic_data), GFP_KERNEL);\n\tif (!nic_data)\n\t\treturn -ENOMEM;\n\tefx->nic_data = nic_data;\n\n\t \n\tBUILD_BUG_ON(MCDI_CTL_SDU_LEN_MAX_V2 % 4);\n\n\trc = efx_nic_alloc_buffer(efx, &nic_data->mcdi_buf,\n\t\t\t\t  8 + MCDI_CTL_SDU_LEN_MAX_V2, GFP_KERNEL);\n\tif (rc)\n\t\tgoto fail1;\n\n\t \n\ti = 0;\n\tfor (;;) {\n\t\trc = efx_ef10_get_warm_boot_count(efx);\n\t\tif (rc >= 0)\n\t\t\tbreak;\n\t\tif (++i == 5)\n\t\t\tgoto fail2;\n\t\tssleep(1);\n\t}\n\tnic_data->warm_boot_count = rc;\n\n\t \n\t_efx_writed(efx, cpu_to_le32(1), ER_DZ_MC_DB_HWRD);\n\n\trc = efx_mcdi_init(efx);\n\tif (rc)\n\t\tgoto fail2;\n\n\tmutex_init(&nic_data->udp_tunnels_lock);\n\tfor (i = 0; i < ARRAY_SIZE(nic_data->udp_tunnels); ++i)\n\t\tnic_data->udp_tunnels[i].type =\n\t\t\tTUNNEL_ENCAP_UDP_PORT_ENTRY_INVALID;\n\n\t \n\trc = efx_mcdi_reset(efx, RESET_TYPE_ALL);\n\tif (rc)\n\t\tgoto fail3;\n\n\t \n\trc = efx_mcdi_log_ctrl(efx, true, false, 0);\n\tif (rc)\n\t\tgoto fail3;\n\n\trc = device_create_file(&efx->pci_dev->dev,\n\t\t\t\t&dev_attr_link_control_flag);\n\tif (rc)\n\t\tgoto fail3;\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_primary_flag);\n\tif (rc)\n\t\tgoto fail4;\n\n\trc = efx_get_pf_index(efx, &nic_data->pf_index);\n\tif (rc)\n\t\tgoto fail5;\n\n\trc = efx_ef10_init_datapath_caps(efx);\n\tif (rc < 0)\n\t\tgoto fail5;\n\n\tefx_ef10_read_licensed_features(efx);\n\n\t \n\tif (nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN))\n\t\tefx->tx_queues_per_channel = 4;\n\telse\n\t\tefx->tx_queues_per_channel = 2;\n\tefx->max_vis = efx_ef10_mem_map_size(efx) / efx->vi_stride;\n\tif (!efx->max_vis) {\n\t\tnetif_err(efx, drv, efx->net_dev, \"error determining max VIs\\n\");\n\t\trc = -EIO;\n\t\tgoto fail5;\n\t}\n\tefx->max_channels = min_t(unsigned int, EFX_MAX_CHANNELS,\n\t\t\t\t  efx->max_vis / efx->tx_queues_per_channel);\n\tefx->max_tx_channels = efx->max_channels;\n\tif (WARN_ON(efx->max_channels == 0)) {\n\t\trc = -EIO;\n\t\tgoto fail5;\n\t}\n\n\tefx->rx_packet_len_offset =\n\t\tES_DZ_RX_PREFIX_PKTLEN_OFST - ES_DZ_RX_PREFIX_SIZE;\n\n\tif (nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_RX_INCLUDE_FCS_LBN))\n\t\tefx->net_dev->hw_features |= NETIF_F_RXFCS;\n\n\trc = efx_mcdi_port_get_number(efx);\n\tif (rc < 0)\n\t\tgoto fail5;\n\tefx->port_num = rc;\n\n\trc = efx->type->get_mac_address(efx, efx->net_dev->perm_addr);\n\tif (rc)\n\t\tgoto fail5;\n\n\trc = efx_ef10_get_timer_config(efx);\n\tif (rc < 0)\n\t\tgoto fail5;\n\n\trc = efx_mcdi_mon_probe(efx);\n\tif (rc && rc != -EPERM)\n\t\tgoto fail5;\n\n\tefx_ptp_defer_probe_with_channel(efx);\n\n#ifdef CONFIG_SFC_SRIOV\n\tif ((efx->pci_dev->physfn) && (!efx->pci_dev->is_physfn)) {\n\t\tstruct pci_dev *pci_dev_pf = efx->pci_dev->physfn;\n\t\tstruct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);\n\n\t\tefx_pf->type->get_mac_address(efx_pf, nic_data->port_id);\n\t} else\n#endif\n\t\tether_addr_copy(nic_data->port_id, efx->net_dev->perm_addr);\n\n\tINIT_LIST_HEAD(&nic_data->vlan_list);\n\tmutex_init(&nic_data->vlan_lock);\n\n\t \n\trc = efx_ef10_add_vlan(efx, EFX_FILTER_VID_UNSPEC);\n\tif (rc)\n\t\tgoto fail_add_vid_unspec;\n\n\t \n\trc = efx_ef10_add_vlan(efx, 0);\n\tif (rc)\n\t\tgoto fail_add_vid_0;\n\n\tif (nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN) &&\n\t    efx->mcdi->fn_flags &\n\t    (1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_TRUSTED))\n\t\tefx->net_dev->udp_tunnel_nic_info = &efx_ef10_udp_tunnels;\n\n\treturn 0;\n\nfail_add_vid_0:\n\tefx_ef10_cleanup_vlans(efx);\nfail_add_vid_unspec:\n\tmutex_destroy(&nic_data->vlan_lock);\n\tefx_ptp_remove(efx);\n\tefx_mcdi_mon_remove(efx);\nfail5:\n\tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_primary_flag);\nfail4:\n\tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_link_control_flag);\nfail3:\n\tefx_mcdi_detach(efx);\n\n\tmutex_lock(&nic_data->udp_tunnels_lock);\n\tmemset(nic_data->udp_tunnels, 0, sizeof(nic_data->udp_tunnels));\n\t(void)efx_ef10_set_udp_tnl_ports(efx, true);\n\tmutex_unlock(&nic_data->udp_tunnels_lock);\n\tmutex_destroy(&nic_data->udp_tunnels_lock);\n\n\tefx_mcdi_fini(efx);\nfail2:\n\tefx_nic_free_buffer(efx, &nic_data->mcdi_buf);\nfail1:\n\tkfree(nic_data);\n\tefx->nic_data = NULL;\n\treturn rc;\n}\n\n#ifdef EFX_USE_PIO\n\nstatic void efx_ef10_free_piobufs(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FREE_PIOBUF_IN_LEN);\n\tunsigned int i;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_FREE_PIOBUF_OUT_LEN != 0);\n\n\tfor (i = 0; i < nic_data->n_piobufs; i++) {\n\t\tMCDI_SET_DWORD(inbuf, FREE_PIOBUF_IN_PIOBUF_HANDLE,\n\t\t\t       nic_data->piobuf_handle[i]);\n\t\trc = efx_mcdi_rpc(efx, MC_CMD_FREE_PIOBUF, inbuf, sizeof(inbuf),\n\t\t\t\t  NULL, 0, NULL);\n\t\tWARN_ON(rc);\n\t}\n\n\tnic_data->n_piobufs = 0;\n}\n\nstatic int efx_ef10_alloc_piobufs(struct efx_nic *efx, unsigned int n)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_ALLOC_PIOBUF_OUT_LEN);\n\tunsigned int i;\n\tsize_t outlen;\n\tint rc = 0;\n\n\tBUILD_BUG_ON(MC_CMD_ALLOC_PIOBUF_IN_LEN != 0);\n\n\tfor (i = 0; i < n; i++) {\n\t\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_ALLOC_PIOBUF, NULL, 0,\n\t\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\t\tif (rc) {\n\t\t\t \n\t\t\tif (!(efx_ef10_is_vf(efx) && rc == -ENOSPC))\n\t\t\t\tefx_mcdi_display_error(efx, MC_CMD_ALLOC_PIOBUF,\n\t\t\t\t\t\t       0, outbuf, outlen, rc);\n\t\t\tbreak;\n\t\t}\n\t\tif (outlen < MC_CMD_ALLOC_PIOBUF_OUT_LEN) {\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tnic_data->piobuf_handle[i] =\n\t\t\tMCDI_DWORD(outbuf, ALLOC_PIOBUF_OUT_PIOBUF_HANDLE);\n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"allocated PIO buffer %u handle %x\\n\", i,\n\t\t\t  nic_data->piobuf_handle[i]);\n\t}\n\n\tnic_data->n_piobufs = i;\n\tif (rc)\n\t\tefx_ef10_free_piobufs(efx);\n\treturn rc;\n}\n\nstatic int efx_ef10_link_piobufs(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_LINK_PIOBUF_IN_LEN);\n\tstruct efx_channel *channel;\n\tstruct efx_tx_queue *tx_queue;\n\tunsigned int offset, index;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_LINK_PIOBUF_OUT_LEN != 0);\n\tBUILD_BUG_ON(MC_CMD_UNLINK_PIOBUF_OUT_LEN != 0);\n\n\t \n\tfor (index = 0; index < nic_data->n_piobufs; ++index) {\n\t\tMCDI_SET_DWORD(inbuf, LINK_PIOBUF_IN_PIOBUF_HANDLE,\n\t\t\t       nic_data->piobuf_handle[index]);\n\t\tMCDI_SET_DWORD(inbuf, LINK_PIOBUF_IN_TXQ_INSTANCE,\n\t\t\t       nic_data->pio_write_vi_base + index);\n\t\trc = efx_mcdi_rpc(efx, MC_CMD_LINK_PIOBUF,\n\t\t\t\t  inbuf, MC_CMD_LINK_PIOBUF_IN_LEN,\n\t\t\t\t  NULL, 0, NULL);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"failed to link VI %u to PIO buffer %u (%d)\\n\",\n\t\t\t\t  nic_data->pio_write_vi_base + index, index,\n\t\t\t\t  rc);\n\t\t\tgoto fail;\n\t\t}\n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"linked VI %u to PIO buffer %u\\n\",\n\t\t\t  nic_data->pio_write_vi_base + index, index);\n\t}\n\n\t \n\tefx_for_each_channel(channel, efx) {\n\t\t \n\t\tif (!channel->type->want_pio ||\n\t\t    channel->channel >= efx->xdp_channel_offset)\n\t\t\tcontinue;\n\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel) {\n\t\t\t \n\t\t\toffset = ((efx->tx_channel_offset + efx->n_tx_channels -\n\t\t\t\t   tx_queue->channel->channel - 1) *\n\t\t\t\t  efx_piobuf_size);\n\t\t\tindex = offset / nic_data->piobuf_size;\n\t\t\toffset = offset % nic_data->piobuf_size;\n\n\t\t\t \n\t\t\tif (tx_queue->queue == nic_data->pio_write_vi_base) {\n\t\t\t\tBUG_ON(index != 0);\n\t\t\t\trc = 0;\n\t\t\t} else {\n\t\t\t\tMCDI_SET_DWORD(inbuf,\n\t\t\t\t\t       LINK_PIOBUF_IN_PIOBUF_HANDLE,\n\t\t\t\t\t       nic_data->piobuf_handle[index]);\n\t\t\t\tMCDI_SET_DWORD(inbuf,\n\t\t\t\t\t       LINK_PIOBUF_IN_TXQ_INSTANCE,\n\t\t\t\t\t       tx_queue->queue);\n\t\t\t\trc = efx_mcdi_rpc(efx, MC_CMD_LINK_PIOBUF,\n\t\t\t\t\t\t  inbuf, MC_CMD_LINK_PIOBUF_IN_LEN,\n\t\t\t\t\t\t  NULL, 0, NULL);\n\t\t\t}\n\n\t\t\tif (rc) {\n\t\t\t\t \n\t\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t\t  \"failed to link VI %u to PIO buffer %u (%d)\\n\",\n\t\t\t\t\t  tx_queue->queue, index, rc);\n\t\t\t\ttx_queue->piobuf = NULL;\n\t\t\t} else {\n\t\t\t\ttx_queue->piobuf =\n\t\t\t\t\tnic_data->pio_write_base +\n\t\t\t\t\tindex * efx->vi_stride + offset;\n\t\t\t\ttx_queue->piobuf_offset = offset;\n\t\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t\t  \"linked VI %u to PIO buffer %u offset %x addr %p\\n\",\n\t\t\t\t\t  tx_queue->queue, index,\n\t\t\t\t\t  tx_queue->piobuf_offset,\n\t\t\t\t\t  tx_queue->piobuf);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\t \n\tBUILD_BUG_ON(MC_CMD_LINK_PIOBUF_IN_LEN < MC_CMD_UNLINK_PIOBUF_IN_LEN);\n\twhile (index--) {\n\t\tMCDI_SET_DWORD(inbuf, UNLINK_PIOBUF_IN_TXQ_INSTANCE,\n\t\t\t       nic_data->pio_write_vi_base + index);\n\t\tefx_mcdi_rpc(efx, MC_CMD_UNLINK_PIOBUF,\n\t\t\t     inbuf, MC_CMD_UNLINK_PIOBUF_IN_LEN,\n\t\t\t     NULL, 0, NULL);\n\t}\n\treturn rc;\n}\n\nstatic void efx_ef10_forget_old_piobufs(struct efx_nic *efx)\n{\n\tstruct efx_channel *channel;\n\tstruct efx_tx_queue *tx_queue;\n\n\t \n\tefx_for_each_channel(channel, efx)\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\ttx_queue->piobuf = NULL;\n}\n\n#else  \n\nstatic int efx_ef10_alloc_piobufs(struct efx_nic *efx, unsigned int n)\n{\n\treturn n == 0 ? 0 : -ENOBUFS;\n}\n\nstatic int efx_ef10_link_piobufs(struct efx_nic *efx)\n{\n\treturn 0;\n}\n\nstatic void efx_ef10_free_piobufs(struct efx_nic *efx)\n{\n}\n\nstatic void efx_ef10_forget_old_piobufs(struct efx_nic *efx)\n{\n}\n\n#endif  \n\nstatic void efx_ef10_remove(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n#ifdef CONFIG_SFC_SRIOV\n\tstruct efx_ef10_nic_data *nic_data_pf;\n\tstruct pci_dev *pci_dev_pf;\n\tstruct efx_nic *efx_pf;\n\tstruct ef10_vf *vf;\n\n\tif (efx->pci_dev->is_virtfn) {\n\t\tpci_dev_pf = efx->pci_dev->physfn;\n\t\tif (pci_dev_pf) {\n\t\t\tefx_pf = pci_get_drvdata(pci_dev_pf);\n\t\t\tnic_data_pf = efx_pf->nic_data;\n\t\t\tvf = nic_data_pf->vf + nic_data->vf_index;\n\t\t\tvf->efx = NULL;\n\t\t} else\n\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t   \"Could not get the PF id from VF\\n\");\n\t}\n#endif\n\n\tefx_ef10_cleanup_vlans(efx);\n\tmutex_destroy(&nic_data->vlan_lock);\n\n\tefx_ptp_remove(efx);\n\n\tefx_mcdi_mon_remove(efx);\n\n\tefx_mcdi_rx_free_indir_table(efx);\n\n\tif (nic_data->wc_membase)\n\t\tiounmap(nic_data->wc_membase);\n\n\trc = efx_mcdi_free_vis(efx);\n\tWARN_ON(rc != 0);\n\n\tif (!nic_data->must_restore_piobufs)\n\t\tefx_ef10_free_piobufs(efx);\n\n\tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_primary_flag);\n\tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_link_control_flag);\n\n\tefx_mcdi_detach(efx);\n\n\tmemset(nic_data->udp_tunnels, 0, sizeof(nic_data->udp_tunnels));\n\tmutex_lock(&nic_data->udp_tunnels_lock);\n\t(void)efx_ef10_set_udp_tnl_ports(efx, true);\n\tmutex_unlock(&nic_data->udp_tunnels_lock);\n\n\tmutex_destroy(&nic_data->udp_tunnels_lock);\n\n\tefx_mcdi_fini(efx);\n\tefx_nic_free_buffer(efx, &nic_data->mcdi_buf);\n\tkfree(nic_data);\n}\n\nstatic int efx_ef10_probe_pf(struct efx_nic *efx)\n{\n\treturn efx_ef10_probe(efx);\n}\n\nint efx_ef10_vadaptor_query(struct efx_nic *efx, unsigned int port_id,\n\t\t\t    u32 *port_flags, u32 *vadaptor_flags,\n\t\t\t    unsigned int *vlan_tags)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_QUERY_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_VADAPTOR_QUERY_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tif (nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_VADAPTOR_QUERY_LBN)) {\n\t\tMCDI_SET_DWORD(inbuf, VADAPTOR_QUERY_IN_UPSTREAM_PORT_ID,\n\t\t\t       port_id);\n\n\t\trc = efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_QUERY, inbuf, sizeof(inbuf),\n\t\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (outlen < sizeof(outbuf)) {\n\t\t\trc = -EIO;\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (port_flags)\n\t\t*port_flags = MCDI_DWORD(outbuf, VADAPTOR_QUERY_OUT_PORT_FLAGS);\n\tif (vadaptor_flags)\n\t\t*vadaptor_flags =\n\t\t\tMCDI_DWORD(outbuf, VADAPTOR_QUERY_OUT_VADAPTOR_FLAGS);\n\tif (vlan_tags)\n\t\t*vlan_tags =\n\t\t\tMCDI_DWORD(outbuf,\n\t\t\t\t   VADAPTOR_QUERY_OUT_NUM_AVAILABLE_VLAN_TAGS);\n\n\treturn 0;\n}\n\nint efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_ALLOC_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, VADAPTOR_ALLOC_IN_UPSTREAM_PORT_ID, port_id);\n\treturn efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_ALLOC, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nint efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_FREE_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, VADAPTOR_FREE_IN_UPSTREAM_PORT_ID, port_id);\n\treturn efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_FREE, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nint efx_ef10_vport_add_mac(struct efx_nic *efx,\n\t\t\t   unsigned int port_id, const u8 *mac)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ADD_MAC_ADDRESS_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, VPORT_ADD_MAC_ADDRESS_IN_VPORT_ID, port_id);\n\tether_addr_copy(MCDI_PTR(inbuf, VPORT_ADD_MAC_ADDRESS_IN_MACADDR), mac);\n\n\treturn efx_mcdi_rpc(efx, MC_CMD_VPORT_ADD_MAC_ADDRESS, inbuf,\n\t\t\t    sizeof(inbuf), NULL, 0, NULL);\n}\n\nint efx_ef10_vport_del_mac(struct efx_nic *efx,\n\t\t\t   unsigned int port_id, const u8 *mac)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);\n\tether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);\n\n\treturn efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,\n\t\t\t    sizeof(inbuf), NULL, 0, NULL);\n}\n\n#ifdef CONFIG_SFC_SRIOV\nstatic int efx_ef10_probe_vf(struct efx_nic *efx)\n{\n\tint rc;\n\tstruct pci_dev *pci_dev_pf;\n\n\t \n\tpci_dev_pf = efx->pci_dev->physfn;\n\tif (pci_dev_pf) {\n\t\tstruct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);\n\t\tstruct efx_ef10_nic_data *nic_data_pf = efx_pf->nic_data;\n\n\t\tif (!nic_data_pf->vf) {\n\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t   \"The VF cannot link to its parent PF; \"\n\t\t\t\t   \"please destroy and re-create the VF\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\trc = efx_ef10_probe(efx);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efx_ef10_get_vf_index(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (efx->pci_dev->is_virtfn) {\n\t\tif (efx->pci_dev->physfn) {\n\t\t\tstruct efx_nic *efx_pf =\n\t\t\t\tpci_get_drvdata(efx->pci_dev->physfn);\n\t\t\tstruct efx_ef10_nic_data *nic_data_p = efx_pf->nic_data;\n\t\t\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\t\t\tnic_data_p->vf[nic_data->vf_index].efx = efx;\n\t\t\tnic_data_p->vf[nic_data->vf_index].pci_dev =\n\t\t\t\tefx->pci_dev;\n\t\t} else\n\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t   \"Could not get the PF id from VF\\n\");\n\t}\n\n\treturn 0;\n\nfail:\n\tefx_ef10_remove(efx);\n\treturn rc;\n}\n#else\nstatic int efx_ef10_probe_vf(struct efx_nic *efx __attribute__ ((unused)))\n{\n\treturn 0;\n}\n#endif\n\nstatic int efx_ef10_alloc_vis(struct efx_nic *efx,\n\t\t\t      unsigned int min_vis, unsigned int max_vis)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\treturn efx_mcdi_alloc_vis(efx, min_vis, max_vis, &nic_data->vi_base,\n\t\t\t\t  &nic_data->n_allocated_vis);\n}\n\n \nstatic int efx_ef10_dimension_resources(struct efx_nic *efx)\n{\n\tunsigned int min_vis = max_t(unsigned int, efx->tx_queues_per_channel,\n\t\t\t\t     efx_separate_tx_channels ? 2 : 1);\n\tunsigned int channel_vis, pio_write_vi_base, max_vis;\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tunsigned int uc_mem_map_size, wc_mem_map_size;\n\tvoid __iomem *membase;\n\tint rc;\n\n\tchannel_vis = max(efx->n_channels,\n\t\t\t  ((efx->n_tx_channels + efx->n_extra_tx_channels) *\n\t\t\t   efx->tx_queues_per_channel) +\n\t\t\t   efx->n_xdp_channels * efx->xdp_tx_per_channel);\n\tif (efx->max_vis && efx->max_vis < channel_vis) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Reducing channel VIs from %u to %u\\n\",\n\t\t\t  channel_vis, efx->max_vis);\n\t\tchannel_vis = efx->max_vis;\n\t}\n\n#ifdef EFX_USE_PIO\n\t \n\tif (efx_piobuf_size != 0 &&\n\t    nic_data->piobuf_size / efx_piobuf_size * EF10_TX_PIOBUF_COUNT >=\n\t    efx->n_tx_channels) {\n\t\tunsigned int n_piobufs =\n\t\t\tDIV_ROUND_UP(efx->n_tx_channels,\n\t\t\t\t     nic_data->piobuf_size / efx_piobuf_size);\n\n\t\trc = efx_ef10_alloc_piobufs(efx, n_piobufs);\n\t\tif (rc == -ENOSPC)\n\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t  \"out of PIO buffers; cannot allocate more\\n\");\n\t\telse if (rc == -EPERM)\n\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t  \"not permitted to allocate PIO buffers\\n\");\n\t\telse if (rc)\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"failed to allocate PIO buffers (%d)\\n\", rc);\n\t\telse\n\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t  \"allocated %u PIO buffers\\n\", n_piobufs);\n\t}\n#else\n\tnic_data->n_piobufs = 0;\n#endif\n\n\t \n\tuc_mem_map_size = PAGE_ALIGN((channel_vis - 1) * efx->vi_stride +\n\t\t\t\t     ER_DZ_TX_PIOBUF);\n\tif (nic_data->n_piobufs) {\n\t\t \n\t\tpio_write_vi_base = uc_mem_map_size / efx->vi_stride;\n\t\twc_mem_map_size = (PAGE_ALIGN((pio_write_vi_base +\n\t\t\t\t\t       nic_data->n_piobufs) *\n\t\t\t\t\t      efx->vi_stride) -\n\t\t\t\t   uc_mem_map_size);\n\t\tmax_vis = pio_write_vi_base + nic_data->n_piobufs;\n\t} else {\n\t\tpio_write_vi_base = 0;\n\t\twc_mem_map_size = 0;\n\t\tmax_vis = channel_vis;\n\t}\n\n\t \n\trc = efx_mcdi_free_vis(efx);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = efx_ef10_alloc_vis(efx, min_vis, max_vis);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (nic_data->n_allocated_vis < channel_vis) {\n\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t   \"Could not allocate enough VIs to satisfy RSS\"\n\t\t\t   \" requirements. Performance may not be optimal.\\n\");\n\t\t \n\t\tefx->max_channels = nic_data->n_allocated_vis;\n\t\tefx->max_tx_channels =\n\t\t\tnic_data->n_allocated_vis / efx->tx_queues_per_channel;\n\n\t\tefx_mcdi_free_vis(efx);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (nic_data->n_piobufs &&\n\t    nic_data->n_allocated_vis <\n\t    pio_write_vi_base + nic_data->n_piobufs) {\n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"%u VIs are not sufficient to map %u PIO buffers\\n\",\n\t\t\t  nic_data->n_allocated_vis, nic_data->n_piobufs);\n\t\tefx_ef10_free_piobufs(efx);\n\t}\n\n\t \n\tmembase = ioremap(efx->membase_phys, uc_mem_map_size);\n\tif (!membase) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"could not shrink memory BAR to %x\\n\",\n\t\t\t  uc_mem_map_size);\n\t\treturn -ENOMEM;\n\t}\n\tiounmap(efx->membase);\n\tefx->membase = membase;\n\n\t \n\tif (wc_mem_map_size) {\n\t\tnic_data->wc_membase = ioremap_wc(efx->membase_phys +\n\t\t\t\t\t\t  uc_mem_map_size,\n\t\t\t\t\t\t  wc_mem_map_size);\n\t\tif (!nic_data->wc_membase) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"could not allocate WC mapping of size %x\\n\",\n\t\t\t\t  wc_mem_map_size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnic_data->pio_write_vi_base = pio_write_vi_base;\n\t\tnic_data->pio_write_base =\n\t\t\tnic_data->wc_membase +\n\t\t\t(pio_write_vi_base * efx->vi_stride + ER_DZ_TX_PIOBUF -\n\t\t\t uc_mem_map_size);\n\n\t\trc = efx_ef10_link_piobufs(efx);\n\t\tif (rc)\n\t\t\tefx_ef10_free_piobufs(efx);\n\t}\n\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"memory BAR at %pa (virtual %p+%x UC, %p+%x WC)\\n\",\n\t\t  &efx->membase_phys, efx->membase, uc_mem_map_size,\n\t\t  nic_data->wc_membase, wc_mem_map_size);\n\n\treturn 0;\n}\n\nstatic void efx_ef10_fini_nic(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tspin_lock_bh(&efx->stats_lock);\n\tkfree(nic_data->mc_stats);\n\tnic_data->mc_stats = NULL;\n\tspin_unlock_bh(&efx->stats_lock);\n}\n\nstatic int efx_ef10_init_nic(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct net_device *net_dev = efx->net_dev;\n\tnetdev_features_t tun_feats, tso_feats;\n\tint rc;\n\n\tif (nic_data->must_check_datapath_caps) {\n\t\trc = efx_ef10_init_datapath_caps(efx);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tnic_data->must_check_datapath_caps = false;\n\t}\n\n\tif (efx->must_realloc_vis) {\n\t\t \n\t\trc = efx_ef10_alloc_vis(efx, nic_data->n_allocated_vis,\n\t\t\t\t\tnic_data->n_allocated_vis);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tefx->must_realloc_vis = false;\n\t}\n\n\tnic_data->mc_stats = kmalloc(efx->num_mac_stats * sizeof(__le64),\n\t\t\t\t     GFP_KERNEL);\n\tif (!nic_data->mc_stats)\n\t\treturn -ENOMEM;\n\n\tif (nic_data->must_restore_piobufs && nic_data->n_piobufs) {\n\t\trc = efx_ef10_alloc_piobufs(efx, nic_data->n_piobufs);\n\t\tif (rc == 0) {\n\t\t\trc = efx_ef10_link_piobufs(efx);\n\t\t\tif (rc)\n\t\t\t\tefx_ef10_free_piobufs(efx);\n\t\t}\n\n\t\t \n\t\tif (rc == -EPERM)\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"not permitted to restore PIO buffers\\n\");\n\t\telse if (rc)\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"failed to restore PIO buffers (%d)\\n\", rc);\n\t\tnic_data->must_restore_piobufs = false;\n\t}\n\n\t \n\tif (efx_has_cap(efx, VXLAN_NVGRE) && !efx_ef10_is_vf(efx))\n\t\tnet_dev->hw_enc_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\telse\n\t\tnet_dev->hw_enc_features &= ~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);\n\n\ttun_feats = NETIF_F_GSO_UDP_TUNNEL | NETIF_F_GSO_GRE |\n\t\t    NETIF_F_GSO_UDP_TUNNEL_CSUM | NETIF_F_GSO_GRE_CSUM;\n\ttso_feats = NETIF_F_TSO | NETIF_F_TSO6;\n\n\tif (efx_has_cap(efx, TX_TSO_V2_ENCAP)) {\n\t\t \n\t\tif (!(net_dev->hw_features & tun_feats))\n\t\t\tnet_dev->features |= tun_feats;\n\t\tnet_dev->hw_enc_features |= tun_feats | tso_feats;\n\t\tnet_dev->hw_features |= tun_feats;\n\t} else {\n\t\tnet_dev->hw_enc_features &= ~(tun_feats | tso_feats);\n\t\tnet_dev->hw_features &= ~tun_feats;\n\t\tnet_dev->features &= ~tun_feats;\n\t}\n\n\t \n\trc = efx->type->rx_push_rss_config(efx, false,\n\t\t\t\t\t   efx->rss_context.rx_indir_table, NULL);\n\n\treturn 0;\n}\n\nstatic void efx_ef10_table_reset_mc_allocations(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n#ifdef CONFIG_SFC_SRIOV\n\tunsigned int i;\n#endif\n\n\t \n\tefx->must_realloc_vis = true;\n\tefx_mcdi_filter_table_reset_mc_allocations(efx);\n\tnic_data->must_restore_piobufs = true;\n\tefx_ef10_forget_old_piobufs(efx);\n\tefx->rss_context.context_id = EFX_MCDI_RSS_CONTEXT_INVALID;\n\n\t \n\tnic_data->must_probe_vswitching = true;\n\tefx->vport_id = EVB_PORT_ID_ASSIGNED;\n#ifdef CONFIG_SFC_SRIOV\n\tif (nic_data->vf)\n\t\tfor (i = 0; i < efx->vf_count; i++)\n\t\t\tnic_data->vf[i].vport_id = 0;\n#endif\n}\n\nstatic enum reset_type efx_ef10_map_reset_reason(enum reset_type reason)\n{\n\tif (reason == RESET_TYPE_MC_FAILURE)\n\t\treturn RESET_TYPE_DATAPATH;\n\n\treturn efx_mcdi_map_reset_reason(reason);\n}\n\nstatic int efx_ef10_map_reset_flags(u32 *flags)\n{\n\tenum {\n\t\tEF10_RESET_PORT = ((ETH_RESET_MAC | ETH_RESET_PHY) <<\n\t\t\t\t   ETH_RESET_SHARED_SHIFT),\n\t\tEF10_RESET_MC = ((ETH_RESET_DMA | ETH_RESET_FILTER |\n\t\t\t\t  ETH_RESET_OFFLOAD | ETH_RESET_MAC |\n\t\t\t\t  ETH_RESET_PHY | ETH_RESET_MGMT) <<\n\t\t\t\t ETH_RESET_SHARED_SHIFT)\n\t};\n\n\t \n\n\tif ((*flags & EF10_RESET_MC) == EF10_RESET_MC) {\n\t\t*flags &= ~EF10_RESET_MC;\n\t\treturn RESET_TYPE_WORLD;\n\t}\n\n\tif ((*flags & EF10_RESET_PORT) == EF10_RESET_PORT) {\n\t\t*flags &= ~EF10_RESET_PORT;\n\t\treturn RESET_TYPE_ALL;\n\t}\n\n\t \n\n\treturn -EINVAL;\n}\n\nstatic int efx_ef10_reset(struct efx_nic *efx, enum reset_type reset_type)\n{\n\tint rc = efx_mcdi_reset(efx, reset_type);\n\n\t \n\tif (reset_type == RESET_TYPE_WORLD && rc == -EPERM)\n\t\trc = 0;\n\n\t \n\tif ((reset_type == RESET_TYPE_ALL ||\n\t     reset_type == RESET_TYPE_MCDI_TIMEOUT) && !rc)\n\t\tefx_ef10_table_reset_mc_allocations(efx);\n\treturn rc;\n}\n\n#define EF10_DMA_STAT(ext_name, mcdi_name)\t\t\t\\\n\t[EF10_STAT_ ## ext_name] =\t\t\t\t\\\n\t{ #ext_name, 64, 8 * MC_CMD_MAC_ ## mcdi_name }\n#define EF10_DMA_INVIS_STAT(int_name, mcdi_name)\t\t\\\n\t[EF10_STAT_ ## int_name] =\t\t\t\t\\\n\t{ NULL, 64, 8 * MC_CMD_MAC_ ## mcdi_name }\n#define EF10_OTHER_STAT(ext_name)\t\t\t\t\\\n\t[EF10_STAT_ ## ext_name] = { #ext_name, 0, 0 }\n\nstatic const struct efx_hw_stat_desc efx_ef10_stat_desc[EF10_STAT_COUNT] = {\n\tEF10_DMA_STAT(port_tx_bytes, TX_BYTES),\n\tEF10_DMA_STAT(port_tx_packets, TX_PKTS),\n\tEF10_DMA_STAT(port_tx_pause, TX_PAUSE_PKTS),\n\tEF10_DMA_STAT(port_tx_control, TX_CONTROL_PKTS),\n\tEF10_DMA_STAT(port_tx_unicast, TX_UNICAST_PKTS),\n\tEF10_DMA_STAT(port_tx_multicast, TX_MULTICAST_PKTS),\n\tEF10_DMA_STAT(port_tx_broadcast, TX_BROADCAST_PKTS),\n\tEF10_DMA_STAT(port_tx_lt64, TX_LT64_PKTS),\n\tEF10_DMA_STAT(port_tx_64, TX_64_PKTS),\n\tEF10_DMA_STAT(port_tx_65_to_127, TX_65_TO_127_PKTS),\n\tEF10_DMA_STAT(port_tx_128_to_255, TX_128_TO_255_PKTS),\n\tEF10_DMA_STAT(port_tx_256_to_511, TX_256_TO_511_PKTS),\n\tEF10_DMA_STAT(port_tx_512_to_1023, TX_512_TO_1023_PKTS),\n\tEF10_DMA_STAT(port_tx_1024_to_15xx, TX_1024_TO_15XX_PKTS),\n\tEF10_DMA_STAT(port_tx_15xx_to_jumbo, TX_15XX_TO_JUMBO_PKTS),\n\tEF10_DMA_STAT(port_rx_bytes, RX_BYTES),\n\tEF10_DMA_INVIS_STAT(port_rx_bytes_minus_good_bytes, RX_BAD_BYTES),\n\tEF10_OTHER_STAT(port_rx_good_bytes),\n\tEF10_OTHER_STAT(port_rx_bad_bytes),\n\tEF10_DMA_STAT(port_rx_packets, RX_PKTS),\n\tEF10_DMA_STAT(port_rx_good, RX_GOOD_PKTS),\n\tEF10_DMA_STAT(port_rx_bad, RX_BAD_FCS_PKTS),\n\tEF10_DMA_STAT(port_rx_pause, RX_PAUSE_PKTS),\n\tEF10_DMA_STAT(port_rx_control, RX_CONTROL_PKTS),\n\tEF10_DMA_STAT(port_rx_unicast, RX_UNICAST_PKTS),\n\tEF10_DMA_STAT(port_rx_multicast, RX_MULTICAST_PKTS),\n\tEF10_DMA_STAT(port_rx_broadcast, RX_BROADCAST_PKTS),\n\tEF10_DMA_STAT(port_rx_lt64, RX_UNDERSIZE_PKTS),\n\tEF10_DMA_STAT(port_rx_64, RX_64_PKTS),\n\tEF10_DMA_STAT(port_rx_65_to_127, RX_65_TO_127_PKTS),\n\tEF10_DMA_STAT(port_rx_128_to_255, RX_128_TO_255_PKTS),\n\tEF10_DMA_STAT(port_rx_256_to_511, RX_256_TO_511_PKTS),\n\tEF10_DMA_STAT(port_rx_512_to_1023, RX_512_TO_1023_PKTS),\n\tEF10_DMA_STAT(port_rx_1024_to_15xx, RX_1024_TO_15XX_PKTS),\n\tEF10_DMA_STAT(port_rx_15xx_to_jumbo, RX_15XX_TO_JUMBO_PKTS),\n\tEF10_DMA_STAT(port_rx_gtjumbo, RX_GTJUMBO_PKTS),\n\tEF10_DMA_STAT(port_rx_bad_gtjumbo, RX_JABBER_PKTS),\n\tEF10_DMA_STAT(port_rx_overflow, RX_OVERFLOW_PKTS),\n\tEF10_DMA_STAT(port_rx_align_error, RX_ALIGN_ERROR_PKTS),\n\tEF10_DMA_STAT(port_rx_length_error, RX_LENGTH_ERROR_PKTS),\n\tEF10_DMA_STAT(port_rx_nodesc_drops, RX_NODESC_DROPS),\n\tEFX_GENERIC_SW_STAT(rx_nodesc_trunc),\n\tEFX_GENERIC_SW_STAT(rx_noskb_drops),\n\tEF10_DMA_STAT(port_rx_pm_trunc_bb_overflow, PM_TRUNC_BB_OVERFLOW),\n\tEF10_DMA_STAT(port_rx_pm_discard_bb_overflow, PM_DISCARD_BB_OVERFLOW),\n\tEF10_DMA_STAT(port_rx_pm_trunc_vfifo_full, PM_TRUNC_VFIFO_FULL),\n\tEF10_DMA_STAT(port_rx_pm_discard_vfifo_full, PM_DISCARD_VFIFO_FULL),\n\tEF10_DMA_STAT(port_rx_pm_trunc_qbb, PM_TRUNC_QBB),\n\tEF10_DMA_STAT(port_rx_pm_discard_qbb, PM_DISCARD_QBB),\n\tEF10_DMA_STAT(port_rx_pm_discard_mapping, PM_DISCARD_MAPPING),\n\tEF10_DMA_STAT(port_rx_dp_q_disabled_packets, RXDP_Q_DISABLED_PKTS),\n\tEF10_DMA_STAT(port_rx_dp_di_dropped_packets, RXDP_DI_DROPPED_PKTS),\n\tEF10_DMA_STAT(port_rx_dp_streaming_packets, RXDP_STREAMING_PKTS),\n\tEF10_DMA_STAT(port_rx_dp_hlb_fetch, RXDP_HLB_FETCH_CONDITIONS),\n\tEF10_DMA_STAT(port_rx_dp_hlb_wait, RXDP_HLB_WAIT_CONDITIONS),\n\tEF10_DMA_STAT(rx_unicast, VADAPTER_RX_UNICAST_PACKETS),\n\tEF10_DMA_STAT(rx_unicast_bytes, VADAPTER_RX_UNICAST_BYTES),\n\tEF10_DMA_STAT(rx_multicast, VADAPTER_RX_MULTICAST_PACKETS),\n\tEF10_DMA_STAT(rx_multicast_bytes, VADAPTER_RX_MULTICAST_BYTES),\n\tEF10_DMA_STAT(rx_broadcast, VADAPTER_RX_BROADCAST_PACKETS),\n\tEF10_DMA_STAT(rx_broadcast_bytes, VADAPTER_RX_BROADCAST_BYTES),\n\tEF10_DMA_STAT(rx_bad, VADAPTER_RX_BAD_PACKETS),\n\tEF10_DMA_STAT(rx_bad_bytes, VADAPTER_RX_BAD_BYTES),\n\tEF10_DMA_STAT(rx_overflow, VADAPTER_RX_OVERFLOW),\n\tEF10_DMA_STAT(tx_unicast, VADAPTER_TX_UNICAST_PACKETS),\n\tEF10_DMA_STAT(tx_unicast_bytes, VADAPTER_TX_UNICAST_BYTES),\n\tEF10_DMA_STAT(tx_multicast, VADAPTER_TX_MULTICAST_PACKETS),\n\tEF10_DMA_STAT(tx_multicast_bytes, VADAPTER_TX_MULTICAST_BYTES),\n\tEF10_DMA_STAT(tx_broadcast, VADAPTER_TX_BROADCAST_PACKETS),\n\tEF10_DMA_STAT(tx_broadcast_bytes, VADAPTER_TX_BROADCAST_BYTES),\n\tEF10_DMA_STAT(tx_bad, VADAPTER_TX_BAD_PACKETS),\n\tEF10_DMA_STAT(tx_bad_bytes, VADAPTER_TX_BAD_BYTES),\n\tEF10_DMA_STAT(tx_overflow, VADAPTER_TX_OVERFLOW),\n\tEF10_DMA_STAT(fec_uncorrected_errors, FEC_UNCORRECTED_ERRORS),\n\tEF10_DMA_STAT(fec_corrected_errors, FEC_CORRECTED_ERRORS),\n\tEF10_DMA_STAT(fec_corrected_symbols_lane0, FEC_CORRECTED_SYMBOLS_LANE0),\n\tEF10_DMA_STAT(fec_corrected_symbols_lane1, FEC_CORRECTED_SYMBOLS_LANE1),\n\tEF10_DMA_STAT(fec_corrected_symbols_lane2, FEC_CORRECTED_SYMBOLS_LANE2),\n\tEF10_DMA_STAT(fec_corrected_symbols_lane3, FEC_CORRECTED_SYMBOLS_LANE3),\n\tEF10_DMA_STAT(ctpio_vi_busy_fallback, CTPIO_VI_BUSY_FALLBACK),\n\tEF10_DMA_STAT(ctpio_long_write_success, CTPIO_LONG_WRITE_SUCCESS),\n\tEF10_DMA_STAT(ctpio_missing_dbell_fail, CTPIO_MISSING_DBELL_FAIL),\n\tEF10_DMA_STAT(ctpio_overflow_fail, CTPIO_OVERFLOW_FAIL),\n\tEF10_DMA_STAT(ctpio_underflow_fail, CTPIO_UNDERFLOW_FAIL),\n\tEF10_DMA_STAT(ctpio_timeout_fail, CTPIO_TIMEOUT_FAIL),\n\tEF10_DMA_STAT(ctpio_noncontig_wr_fail, CTPIO_NONCONTIG_WR_FAIL),\n\tEF10_DMA_STAT(ctpio_frm_clobber_fail, CTPIO_FRM_CLOBBER_FAIL),\n\tEF10_DMA_STAT(ctpio_invalid_wr_fail, CTPIO_INVALID_WR_FAIL),\n\tEF10_DMA_STAT(ctpio_vi_clobber_fallback, CTPIO_VI_CLOBBER_FALLBACK),\n\tEF10_DMA_STAT(ctpio_unqualified_fallback, CTPIO_UNQUALIFIED_FALLBACK),\n\tEF10_DMA_STAT(ctpio_runt_fallback, CTPIO_RUNT_FALLBACK),\n\tEF10_DMA_STAT(ctpio_success, CTPIO_SUCCESS),\n\tEF10_DMA_STAT(ctpio_fallback, CTPIO_FALLBACK),\n\tEF10_DMA_STAT(ctpio_poison, CTPIO_POISON),\n\tEF10_DMA_STAT(ctpio_erase, CTPIO_ERASE),\n};\n\n#define HUNT_COMMON_STAT_MASK ((1ULL << EF10_STAT_port_tx_bytes) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_tx_packets) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_tx_pause) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_tx_unicast) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_tx_multicast) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_tx_broadcast) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_bytes) |\t\\\n\t\t\t       (1ULL <<                                 \\\n\t\t\t\tEF10_STAT_port_rx_bytes_minus_good_bytes) | \\\n\t\t\t       (1ULL << EF10_STAT_port_rx_good_bytes) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_bad_bytes) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_packets) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_good) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_bad) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_pause) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_control) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_unicast) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_multicast) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_broadcast) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_lt64) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_64) |\t\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_65_to_127) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_128_to_255) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_256_to_511) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_512_to_1023) |\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_1024_to_15xx) |\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_15xx_to_jumbo) |\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_gtjumbo) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_bad_gtjumbo) |\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_overflow) |\t\\\n\t\t\t       (1ULL << EF10_STAT_port_rx_nodesc_drops) |\\\n\t\t\t       (1ULL << GENERIC_STAT_rx_nodesc_trunc) |\t\\\n\t\t\t       (1ULL << GENERIC_STAT_rx_noskb_drops))\n\n \n#define HUNT_10G_ONLY_STAT_MASK ((1ULL << EF10_STAT_port_tx_control) |\t\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_lt64) |\t\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_64) |\t\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_65_to_127) |\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_128_to_255) |\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_256_to_511) |\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_512_to_1023) |\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_1024_to_15xx) |\\\n\t\t\t\t (1ULL << EF10_STAT_port_tx_15xx_to_jumbo))\n\n \n#define HUNT_40G_EXTRA_STAT_MASK ((1ULL << EF10_STAT_port_rx_align_error) |\\\n\t\t\t\t  (1ULL << EF10_STAT_port_rx_length_error))\n\n \n#define HUNT_PM_AND_RXDP_STAT_MASK (\t\t\t\t\t\\\n\t(1ULL << EF10_STAT_port_rx_pm_trunc_bb_overflow) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_pm_discard_bb_overflow) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_pm_trunc_vfifo_full) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_pm_discard_vfifo_full) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_pm_trunc_qbb) |\t\t\t\\\n\t(1ULL << EF10_STAT_port_rx_pm_discard_qbb) |\t\t\t\\\n\t(1ULL << EF10_STAT_port_rx_pm_discard_mapping) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_dp_q_disabled_packets) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_dp_di_dropped_packets) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_dp_streaming_packets) |\t\t\\\n\t(1ULL << EF10_STAT_port_rx_dp_hlb_fetch) |\t\t\t\\\n\t(1ULL << EF10_STAT_port_rx_dp_hlb_wait))\n\n \n#define EF10_FEC_STAT_MASK (\t\t\t\t\t\t\\\n\t(1ULL << (EF10_STAT_fec_uncorrected_errors - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_fec_corrected_errors - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_fec_corrected_symbols_lane0 - 64)) |\t\\\n\t(1ULL << (EF10_STAT_fec_corrected_symbols_lane1 - 64)) |\t\\\n\t(1ULL << (EF10_STAT_fec_corrected_symbols_lane2 - 64)) |\t\\\n\t(1ULL << (EF10_STAT_fec_corrected_symbols_lane3 - 64)))\n\n \n#define EF10_CTPIO_STAT_MASK (\t\t\t\t\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_vi_busy_fallback - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_long_write_success - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_missing_dbell_fail - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_overflow_fail - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_underflow_fail - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_timeout_fail - 64)) |\t\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_noncontig_wr_fail - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_frm_clobber_fail - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_invalid_wr_fail - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_vi_clobber_fallback - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_unqualified_fallback - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_runt_fallback - 64)) |\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_success - 64)) |\t\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_fallback - 64)) |\t\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_poison - 64)) |\t\t\t\\\n\t(1ULL << (EF10_STAT_ctpio_erase - 64)))\n\nstatic u64 efx_ef10_raw_stat_mask(struct efx_nic *efx)\n{\n\tu64 raw_mask = HUNT_COMMON_STAT_MASK;\n\tu32 port_caps = efx_mcdi_phy_get_caps(efx);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tif (!(efx->mcdi->fn_flags &\n\t      1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL))\n\t\treturn 0;\n\n\tif (port_caps & (1 << MC_CMD_PHY_CAP_40000FDX_LBN)) {\n\t\traw_mask |= HUNT_40G_EXTRA_STAT_MASK;\n\t\t \n\t\tif (nic_data->datapath_caps2 &\n\t\t    (1 << MC_CMD_GET_CAPABILITIES_V2_OUT_MAC_STATS_40G_TX_SIZE_BINS_LBN))\n\t\t\traw_mask |= HUNT_10G_ONLY_STAT_MASK;\n\t} else {\n\t\traw_mask |= HUNT_10G_ONLY_STAT_MASK;\n\t}\n\n\tif (nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_PM_AND_RXDP_COUNTERS_LBN))\n\t\traw_mask |= HUNT_PM_AND_RXDP_STAT_MASK;\n\n\treturn raw_mask;\n}\n\nstatic void efx_ef10_get_stat_mask(struct efx_nic *efx, unsigned long *mask)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tu64 raw_mask[2];\n\n\traw_mask[0] = efx_ef10_raw_stat_mask(efx);\n\n\t \n\tif (nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_EVB_LBN)) {\n\t\traw_mask[0] |= ~((1ULL << EF10_STAT_rx_unicast) - 1);\n\t\traw_mask[1] = (1ULL << (EF10_STAT_V1_COUNT - 64)) - 1;\n\t} else {\n\t\traw_mask[1] = 0;\n\t}\n\t \n\tif (efx->num_mac_stats >= MC_CMD_MAC_NSTATS_V2)\n\t\traw_mask[1] |= EF10_FEC_STAT_MASK;\n\n\t \n\tif (efx->num_mac_stats >= MC_CMD_MAC_NSTATS_V3 &&\n\t    (nic_data->datapath_caps2 &\n\t     (1 << MC_CMD_GET_CAPABILITIES_V4_OUT_CTPIO_LBN)))\n\t\traw_mask[1] |= EF10_CTPIO_STAT_MASK;\n\n#if BITS_PER_LONG == 64\n\tBUILD_BUG_ON(BITS_TO_LONGS(EF10_STAT_COUNT) != 2);\n\tmask[0] = raw_mask[0];\n\tmask[1] = raw_mask[1];\n#else\n\tBUILD_BUG_ON(BITS_TO_LONGS(EF10_STAT_COUNT) != 3);\n\tmask[0] = raw_mask[0] & 0xffffffff;\n\tmask[1] = raw_mask[0] >> 32;\n\tmask[2] = raw_mask[1] & 0xffffffff;\n#endif\n}\n\nstatic size_t efx_ef10_describe_stats(struct efx_nic *efx, u8 *names)\n{\n\tDECLARE_BITMAP(mask, EF10_STAT_COUNT);\n\n\tefx_ef10_get_stat_mask(efx, mask);\n\treturn efx_nic_describe_stats(efx_ef10_stat_desc, EF10_STAT_COUNT,\n\t\t\t\t      mask, names);\n}\n\nstatic void efx_ef10_get_fec_stats(struct efx_nic *efx,\n\t\t\t\t   struct ethtool_fec_stats *fec_stats)\n{\n\tDECLARE_BITMAP(mask, EF10_STAT_COUNT);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tu64 *stats = nic_data->stats;\n\n\tefx_ef10_get_stat_mask(efx, mask);\n\tif (test_bit(EF10_STAT_fec_corrected_errors, mask))\n\t\tfec_stats->corrected_blocks.total =\n\t\t\tstats[EF10_STAT_fec_corrected_errors];\n\tif (test_bit(EF10_STAT_fec_uncorrected_errors, mask))\n\t\tfec_stats->uncorrectable_blocks.total =\n\t\t\tstats[EF10_STAT_fec_uncorrected_errors];\n}\n\nstatic size_t efx_ef10_update_stats_common(struct efx_nic *efx, u64 *full_stats,\n\t\t\t\t\t   struct rtnl_link_stats64 *core_stats)\n{\n\tDECLARE_BITMAP(mask, EF10_STAT_COUNT);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tu64 *stats = nic_data->stats;\n\tsize_t stats_count = 0, index;\n\n\tefx_ef10_get_stat_mask(efx, mask);\n\n\tif (full_stats) {\n\t\tfor_each_set_bit(index, mask, EF10_STAT_COUNT) {\n\t\t\tif (efx_ef10_stat_desc[index].name) {\n\t\t\t\t*full_stats++ = stats[index];\n\t\t\t\t++stats_count;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!core_stats)\n\t\treturn stats_count;\n\n\tif (nic_data->datapath_caps &\n\t\t\t1 << MC_CMD_GET_CAPABILITIES_OUT_EVB_LBN) {\n\t\t \n\t\tcore_stats->rx_packets = stats[EF10_STAT_rx_unicast] +\n\t\t\t\t\t stats[EF10_STAT_rx_multicast] +\n\t\t\t\t\t stats[EF10_STAT_rx_broadcast];\n\t\tcore_stats->tx_packets = stats[EF10_STAT_tx_unicast] +\n\t\t\t\t\t stats[EF10_STAT_tx_multicast] +\n\t\t\t\t\t stats[EF10_STAT_tx_broadcast];\n\t\tcore_stats->rx_bytes = stats[EF10_STAT_rx_unicast_bytes] +\n\t\t\t\t       stats[EF10_STAT_rx_multicast_bytes] +\n\t\t\t\t       stats[EF10_STAT_rx_broadcast_bytes];\n\t\tcore_stats->tx_bytes = stats[EF10_STAT_tx_unicast_bytes] +\n\t\t\t\t       stats[EF10_STAT_tx_multicast_bytes] +\n\t\t\t\t       stats[EF10_STAT_tx_broadcast_bytes];\n\t\tcore_stats->rx_dropped = stats[GENERIC_STAT_rx_nodesc_trunc] +\n\t\t\t\t\t stats[GENERIC_STAT_rx_noskb_drops];\n\t\tcore_stats->multicast = stats[EF10_STAT_rx_multicast];\n\t\tcore_stats->rx_crc_errors = stats[EF10_STAT_rx_bad];\n\t\tcore_stats->rx_fifo_errors = stats[EF10_STAT_rx_overflow];\n\t\tcore_stats->rx_errors = core_stats->rx_crc_errors;\n\t\tcore_stats->tx_errors = stats[EF10_STAT_tx_bad];\n\t} else {\n\t\t \n\t\tcore_stats->rx_packets = stats[EF10_STAT_port_rx_packets];\n\t\tcore_stats->tx_packets = stats[EF10_STAT_port_tx_packets];\n\t\tcore_stats->rx_bytes = stats[EF10_STAT_port_rx_bytes];\n\t\tcore_stats->tx_bytes = stats[EF10_STAT_port_tx_bytes];\n\t\tcore_stats->rx_dropped = stats[EF10_STAT_port_rx_nodesc_drops] +\n\t\t\t\t\t stats[GENERIC_STAT_rx_nodesc_trunc] +\n\t\t\t\t\t stats[GENERIC_STAT_rx_noskb_drops];\n\t\tcore_stats->multicast = stats[EF10_STAT_port_rx_multicast];\n\t\tcore_stats->rx_length_errors =\n\t\t\t\tstats[EF10_STAT_port_rx_gtjumbo] +\n\t\t\t\tstats[EF10_STAT_port_rx_length_error];\n\t\tcore_stats->rx_crc_errors = stats[EF10_STAT_port_rx_bad];\n\t\tcore_stats->rx_frame_errors =\n\t\t\t\tstats[EF10_STAT_port_rx_align_error];\n\t\tcore_stats->rx_fifo_errors = stats[EF10_STAT_port_rx_overflow];\n\t\tcore_stats->rx_errors = (core_stats->rx_length_errors +\n\t\t\t\t\t core_stats->rx_crc_errors +\n\t\t\t\t\t core_stats->rx_frame_errors);\n\t}\n\n\treturn stats_count;\n}\n\nstatic size_t efx_ef10_update_stats_pf(struct efx_nic *efx, u64 *full_stats,\n\t\t\t\t       struct rtnl_link_stats64 *core_stats)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tDECLARE_BITMAP(mask, EF10_STAT_COUNT);\n\tu64 *stats = nic_data->stats;\n\n\tefx_ef10_get_stat_mask(efx, mask);\n\n\t \n\tif (nic_data->mc_stats) {\n\t\tefx_nic_copy_stats(efx, nic_data->mc_stats);\n\t\tefx_nic_update_stats(efx_ef10_stat_desc, EF10_STAT_COUNT,\n\t\t\t\t     mask, stats, nic_data->mc_stats, false);\n\t}\n\n\t \n\tefx_nic_fix_nodesc_drop_stat(efx,\n\t\t\t\t     &stats[EF10_STAT_port_rx_nodesc_drops]);\n\t \n\tstats[EF10_STAT_port_rx_good_bytes] =\n\t\tstats[EF10_STAT_port_rx_bytes] -\n\t\tstats[EF10_STAT_port_rx_bytes_minus_good_bytes];\n\n\t \n\tefx_update_diff_stat(&stats[EF10_STAT_port_rx_bad_bytes],\n\t\t\t     stats[EF10_STAT_port_rx_bytes_minus_good_bytes]);\n\tefx_update_sw_stats(efx, stats);\n\n\treturn efx_ef10_update_stats_common(efx, full_stats, core_stats);\n}\n\nstatic int efx_ef10_try_update_nic_stats_vf(struct efx_nic *efx)\n\t__must_hold(&efx->stats_lock)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAC_STATS_IN_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tDECLARE_BITMAP(mask, EF10_STAT_COUNT);\n\t__le64 generation_start, generation_end;\n\tu64 *stats = nic_data->stats;\n\tu32 dma_len = efx->num_mac_stats * sizeof(u64);\n\tstruct efx_buffer stats_buf;\n\t__le64 *dma_stats;\n\tint rc;\n\n\tspin_unlock_bh(&efx->stats_lock);\n\n\tefx_ef10_get_stat_mask(efx, mask);\n\n\trc = efx_nic_alloc_buffer(efx, &stats_buf, dma_len, GFP_KERNEL);\n\tif (rc) {\n\t\tspin_lock_bh(&efx->stats_lock);\n\t\treturn rc;\n\t}\n\n\tdma_stats = stats_buf.addr;\n\tdma_stats[efx->num_mac_stats - 1] = EFX_MC_STATS_GENERATION_INVALID;\n\n\tMCDI_SET_QWORD(inbuf, MAC_STATS_IN_DMA_ADDR, stats_buf.dma_addr);\n\tMCDI_POPULATE_DWORD_1(inbuf, MAC_STATS_IN_CMD,\n\t\t\t      MAC_STATS_IN_DMA, 1);\n\tMCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_LEN, dma_len);\n\tMCDI_SET_DWORD(inbuf, MAC_STATS_IN_PORT_ID, EVB_PORT_ID_ASSIGNED);\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_MAC_STATS, inbuf, sizeof(inbuf),\n\t\t\t\tNULL, 0, NULL);\n\tspin_lock_bh(&efx->stats_lock);\n\tif (rc) {\n\t\t \n\t\tif (rc != -ENOENT || atomic_read(&efx->active_queues))\n\t\t\tefx_mcdi_display_error(efx, MC_CMD_MAC_STATS,\n\t\t\t\t\t       sizeof(inbuf), NULL, 0, rc);\n\t\tgoto out;\n\t}\n\n\tgeneration_end = dma_stats[efx->num_mac_stats - 1];\n\tif (generation_end == EFX_MC_STATS_GENERATION_INVALID) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\trmb();\n\tefx_nic_update_stats(efx_ef10_stat_desc, EF10_STAT_COUNT, mask,\n\t\t\t     stats, stats_buf.addr, false);\n\trmb();\n\tgeneration_start = dma_stats[MC_CMD_MAC_GENERATION_START];\n\tif (generation_end != generation_start) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tefx_update_sw_stats(efx, stats);\nout:\n\t \n\tspin_unlock_bh(&efx->stats_lock);\n\tefx_nic_free_buffer(efx, &stats_buf);\n\tspin_lock_bh(&efx->stats_lock);\n\treturn rc;\n}\n\nstatic size_t efx_ef10_update_stats_vf(struct efx_nic *efx, u64 *full_stats,\n\t\t\t\t       struct rtnl_link_stats64 *core_stats)\n{\n\tif (efx_ef10_try_update_nic_stats_vf(efx))\n\t\treturn 0;\n\n\treturn efx_ef10_update_stats_common(efx, full_stats, core_stats);\n}\n\nstatic size_t efx_ef10_update_stats_atomic_vf(struct efx_nic *efx, u64 *full_stats,\n\t\t\t\t\t      struct rtnl_link_stats64 *core_stats)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\t \n\tefx_update_sw_stats(efx, nic_data->stats);\n\treturn efx_ef10_update_stats_common(efx, full_stats, core_stats);\n}\n\nstatic void efx_ef10_push_irq_moderation(struct efx_channel *channel)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tunsigned int mode, usecs;\n\tefx_dword_t timer_cmd;\n\n\tif (channel->irq_moderation_us) {\n\t\tmode = 3;\n\t\tusecs = channel->irq_moderation_us;\n\t} else {\n\t\tmode = 0;\n\t\tusecs = 0;\n\t}\n\n\tif (EFX_EF10_WORKAROUND_61265(efx)) {\n\t\tMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_EVQ_TMR_IN_LEN);\n\t\tunsigned int ns = usecs * 1000;\n\n\t\tMCDI_SET_DWORD(inbuf, SET_EVQ_TMR_IN_INSTANCE,\n\t\t\t       channel->channel);\n\t\tMCDI_SET_DWORD(inbuf, SET_EVQ_TMR_IN_TMR_LOAD_REQ_NS, ns);\n\t\tMCDI_SET_DWORD(inbuf, SET_EVQ_TMR_IN_TMR_RELOAD_REQ_NS, ns);\n\t\tMCDI_SET_DWORD(inbuf, SET_EVQ_TMR_IN_TMR_MODE, mode);\n\n\t\tefx_mcdi_rpc_async(efx, MC_CMD_SET_EVQ_TMR,\n\t\t\t\t   inbuf, sizeof(inbuf), 0, NULL, 0);\n\t} else if (EFX_EF10_WORKAROUND_35388(efx)) {\n\t\tunsigned int ticks = efx_usecs_to_ticks(efx, usecs);\n\n\t\tEFX_POPULATE_DWORD_3(timer_cmd, ERF_DD_EVQ_IND_TIMER_FLAGS,\n\t\t\t\t     EFE_DD_EVQ_IND_TIMER_FLAGS,\n\t\t\t\t     ERF_DD_EVQ_IND_TIMER_MODE, mode,\n\t\t\t\t     ERF_DD_EVQ_IND_TIMER_VAL, ticks);\n\t\tefx_writed_page(efx, &timer_cmd, ER_DD_EVQ_INDIRECT,\n\t\t\t\tchannel->channel);\n\t} else {\n\t\tunsigned int ticks = efx_usecs_to_ticks(efx, usecs);\n\n\t\tEFX_POPULATE_DWORD_3(timer_cmd, ERF_DZ_TC_TIMER_MODE, mode,\n\t\t\t\t     ERF_DZ_TC_TIMER_VAL, ticks,\n\t\t\t\t     ERF_FZ_TC_TMR_REL_VAL, ticks);\n\t\tefx_writed_page(efx, &timer_cmd, ER_DZ_EVQ_TMR,\n\t\t\t\tchannel->channel);\n\t}\n}\n\nstatic void efx_ef10_get_wol_vf(struct efx_nic *efx,\n\t\t\t\tstruct ethtool_wolinfo *wol) {}\n\nstatic int efx_ef10_set_wol_vf(struct efx_nic *efx, u32 type)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void efx_ef10_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)\n{\n\twol->supported = 0;\n\twol->wolopts = 0;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic int efx_ef10_set_wol(struct efx_nic *efx, u32 type)\n{\n\tif (type != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void efx_ef10_mcdi_request(struct efx_nic *efx,\n\t\t\t\t  const efx_dword_t *hdr, size_t hdr_len,\n\t\t\t\t  const efx_dword_t *sdu, size_t sdu_len)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tu8 *pdu = nic_data->mcdi_buf.addr;\n\n\tmemcpy(pdu, hdr, hdr_len);\n\tmemcpy(pdu + hdr_len, sdu, sdu_len);\n\twmb();\n\n\t \n\t_efx_writed(efx, cpu_to_le32((u64)nic_data->mcdi_buf.dma_addr >> 32),\n\t\t    ER_DZ_MC_DB_LWRD);\n\t_efx_writed(efx, cpu_to_le32((u32)nic_data->mcdi_buf.dma_addr),\n\t\t    ER_DZ_MC_DB_HWRD);\n}\n\nstatic bool efx_ef10_mcdi_poll_response(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tconst efx_dword_t hdr = *(const efx_dword_t *)nic_data->mcdi_buf.addr;\n\n\trmb();\n\treturn EFX_DWORD_FIELD(hdr, MCDI_HEADER_RESPONSE);\n}\n\nstatic void\nefx_ef10_mcdi_read_response(struct efx_nic *efx, efx_dword_t *outbuf,\n\t\t\t    size_t offset, size_t outlen)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tconst u8 *pdu = nic_data->mcdi_buf.addr;\n\n\tmemcpy(outbuf, pdu + offset, outlen);\n}\n\nstatic void efx_ef10_mcdi_reboot_detected(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\t \n\tefx_ef10_table_reset_mc_allocations(efx);\n\n\t \n\tnic_data->must_check_datapath_caps = true;\n\n\t \n\tnic_data->stats[EF10_STAT_port_rx_bad_bytes] = 0;\n}\n\nstatic int efx_ef10_mcdi_poll_reboot(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\trc = efx_ef10_get_warm_boot_count(efx);\n\tif (rc < 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (rc == nic_data->warm_boot_count)\n\t\treturn 0;\n\n\tnic_data->warm_boot_count = rc;\n\tefx_ef10_mcdi_reboot_detected(efx);\n\n\treturn -EIO;\n}\n\n \nstatic irqreturn_t efx_ef10_msi_interrupt(int irq, void *dev_id)\n{\n\tstruct efx_msi_context *context = dev_id;\n\tstruct efx_nic *efx = context->efx;\n\n\tnetif_vdbg(efx, intr, efx->net_dev,\n\t\t   \"IRQ %d on CPU %d\\n\", irq, raw_smp_processor_id());\n\n\tif (likely(READ_ONCE(efx->irq_soft_enabled))) {\n\t\t \n\t\tif (context->index == efx->irq_level)\n\t\t\tefx->last_irq_cpu = raw_smp_processor_id();\n\n\t\t \n\t\tefx_schedule_channel_irq(efx->channel[context->index]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t efx_ef10_legacy_interrupt(int irq, void *dev_id)\n{\n\tstruct efx_nic *efx = dev_id;\n\tbool soft_enabled = READ_ONCE(efx->irq_soft_enabled);\n\tstruct efx_channel *channel;\n\tefx_dword_t reg;\n\tu32 queues;\n\n\t \n\tefx_readd(efx, &reg, ER_DZ_BIU_INT_ISR);\n\tqueues = EFX_DWORD_FIELD(reg, ERF_DZ_ISR_REG);\n\n\tif (queues == 0)\n\t\treturn IRQ_NONE;\n\n\tif (likely(soft_enabled)) {\n\t\t \n\t\tif (queues & (1U << efx->irq_level))\n\t\t\tefx->last_irq_cpu = raw_smp_processor_id();\n\n\t\tefx_for_each_channel(channel, efx) {\n\t\t\tif (queues & 1)\n\t\t\t\tefx_schedule_channel_irq(channel);\n\t\t\tqueues >>= 1;\n\t\t}\n\t}\n\n\tnetif_vdbg(efx, intr, efx->net_dev,\n\t\t   \"IRQ %d on CPU %d status \" EFX_DWORD_FMT \"\\n\",\n\t\t   irq, raw_smp_processor_id(), EFX_DWORD_VAL(reg));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int efx_ef10_irq_test_generate(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_TRIGGER_INTERRUPT_IN_LEN);\n\n\tif (efx_mcdi_set_workaround(efx, MC_CMD_WORKAROUND_BUG41750, true,\n\t\t\t\t    NULL) == 0)\n\t\treturn -ENOTSUPP;\n\n\tBUILD_BUG_ON(MC_CMD_TRIGGER_INTERRUPT_OUT_LEN != 0);\n\n\tMCDI_SET_DWORD(inbuf, TRIGGER_INTERRUPT_IN_INTR_LEVEL, efx->irq_level);\n\treturn efx_mcdi_rpc(efx, MC_CMD_TRIGGER_INTERRUPT,\n\t\t\t    inbuf, sizeof(inbuf), NULL, 0, NULL);\n}\n\nstatic int efx_ef10_tx_probe(struct efx_tx_queue *tx_queue)\n{\n\t \n\tBUILD_BUG_ON((EFX_TXQ_TYPE_OUTER_CSUM | EFX_TXQ_TYPE_INNER_CSUM) != 3);\n\ttx_queue->type = tx_queue->label & 3;\n\treturn efx_nic_alloc_buffer(tx_queue->efx, &tx_queue->txd,\n\t\t\t\t    (tx_queue->ptr_mask + 1) *\n\t\t\t\t    sizeof(efx_qword_t),\n\t\t\t\t    GFP_KERNEL);\n}\n\n \nstatic inline void efx_ef10_push_tx_desc(struct efx_tx_queue *tx_queue,\n\t\t\t\t\t const efx_qword_t *txd)\n{\n\tunsigned int write_ptr;\n\tefx_oword_t reg;\n\n\twrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\n\tEFX_POPULATE_OWORD_1(reg, ERF_DZ_TX_DESC_WPTR, write_ptr);\n\treg.qword[0] = *txd;\n\tefx_writeo_page(tx_queue->efx, &reg,\n\t\t\tER_DZ_TX_DESC_UPD, tx_queue->queue);\n}\n\n \nint efx_ef10_tx_tso_desc(struct efx_tx_queue *tx_queue, struct sk_buff *skb,\n\t\t\t bool *data_mapped)\n{\n\tstruct efx_tx_buffer *buffer;\n\tu16 inner_ipv4_id = 0;\n\tu16 outer_ipv4_id = 0;\n\tstruct tcphdr *tcp;\n\tstruct iphdr *ip;\n\tu16 ip_tot_len;\n\tu32 seqnum;\n\tu32 mss;\n\n\tEFX_WARN_ON_ONCE_PARANOID(tx_queue->tso_version != 2);\n\n\tmss = skb_shinfo(skb)->gso_size;\n\n\tif (unlikely(mss < 4)) {\n\t\tWARN_ONCE(1, \"MSS of %u is too small for TSO v2\\n\", mss);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb->encapsulation) {\n\t\tif (!tx_queue->tso_encap)\n\t\t\treturn -EINVAL;\n\t\tip = ip_hdr(skb);\n\t\tif (ip->version == 4)\n\t\t\touter_ipv4_id = ntohs(ip->id);\n\n\t\tip = inner_ip_hdr(skb);\n\t\ttcp = inner_tcp_hdr(skb);\n\t} else {\n\t\tip = ip_hdr(skb);\n\t\ttcp = tcp_hdr(skb);\n\t}\n\n\t \n\tip_tot_len = 0x10000 - EFX_TSO2_MAX_HDRLEN;\n\tEFX_WARN_ON_ONCE_PARANOID(mss + EFX_TSO2_MAX_HDRLEN +\n\t\t\t\t  (tcp->doff << 2u) > ip_tot_len);\n\n\tif (ip->version == 4) {\n\t\tip->tot_len = htons(ip_tot_len);\n\t\tip->check = 0;\n\t\tinner_ipv4_id = ntohs(ip->id);\n\t} else {\n\t\t((struct ipv6hdr *)ip)->payload_len = htons(ip_tot_len);\n\t}\n\n\tseqnum = ntohl(tcp->seq);\n\n\tbuffer = efx_tx_queue_get_insert_buffer(tx_queue);\n\n\tbuffer->flags = EFX_TX_BUF_OPTION;\n\tbuffer->len = 0;\n\tbuffer->unmap_len = 0;\n\tEFX_POPULATE_QWORD_5(buffer->option,\n\t\t\tESF_DZ_TX_DESC_IS_OPT, 1,\n\t\t\tESF_DZ_TX_OPTION_TYPE, ESE_DZ_TX_OPTION_DESC_TSO,\n\t\t\tESF_DZ_TX_TSO_OPTION_TYPE,\n\t\t\tESE_DZ_TX_TSO_OPTION_DESC_FATSO2A,\n\t\t\tESF_DZ_TX_TSO_IP_ID, inner_ipv4_id,\n\t\t\tESF_DZ_TX_TSO_TCP_SEQNO, seqnum\n\t\t\t);\n\t++tx_queue->insert_count;\n\n\tbuffer = efx_tx_queue_get_insert_buffer(tx_queue);\n\n\tbuffer->flags = EFX_TX_BUF_OPTION;\n\tbuffer->len = 0;\n\tbuffer->unmap_len = 0;\n\tEFX_POPULATE_QWORD_5(buffer->option,\n\t\t\tESF_DZ_TX_DESC_IS_OPT, 1,\n\t\t\tESF_DZ_TX_OPTION_TYPE, ESE_DZ_TX_OPTION_DESC_TSO,\n\t\t\tESF_DZ_TX_TSO_OPTION_TYPE,\n\t\t\tESE_DZ_TX_TSO_OPTION_DESC_FATSO2B,\n\t\t\tESF_DZ_TX_TSO_OUTER_IPID, outer_ipv4_id,\n\t\t\tESF_DZ_TX_TSO_TCP_MSS, mss\n\t\t\t);\n\t++tx_queue->insert_count;\n\n\treturn 0;\n}\n\nstatic u32 efx_ef10_tso_versions(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tu32 tso_versions = 0;\n\n\tif (nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_TX_TSO_LBN))\n\t\ttso_versions |= BIT(1);\n\tif (nic_data->datapath_caps2 &\n\t    (1 << MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_V2_LBN))\n\t\ttso_versions |= BIT(2);\n\treturn tso_versions;\n}\n\nstatic void efx_ef10_tx_init(struct efx_tx_queue *tx_queue)\n{\n\tbool csum_offload = tx_queue->type & EFX_TXQ_TYPE_OUTER_CSUM;\n\tbool inner_csum = tx_queue->type & EFX_TXQ_TYPE_INNER_CSUM;\n\tstruct efx_channel *channel = tx_queue->channel;\n\tstruct efx_nic *efx = tx_queue->efx;\n\tstruct efx_ef10_nic_data *nic_data;\n\tefx_qword_t *txd;\n\tint rc;\n\n\tnic_data = efx->nic_data;\n\n\t \n\tif (!(nic_data->licensed_features &\n\t      (1 << LICENSED_V3_FEATURES_TX_TIMESTAMPS_LBN))) {\n\t\ttx_queue->timestamping = false;\n\t\t \n\t\tif (efx->type->ptp_set_ts_sync_events)\n\t\t\tefx->type->ptp_set_ts_sync_events(efx, false, false);\n\t}\n\n\t \n\tif (efx_has_cap(efx, TX_TSO_V2)) {\n\t\tif ((csum_offload || inner_csum) &&\n\t\t    !tx_queue->timestamping && !tx_queue->xdp_tx) {\n\t\t\ttx_queue->tso_version = 2;\n\t\t\tnetif_dbg(efx, hw, efx->net_dev, \"Using TSOv2 for channel %u\\n\",\n\t\t\t\t  channel->channel);\n\t\t}\n\t} else if (efx_has_cap(efx, TX_TSO)) {\n\t\ttx_queue->tso_version = 1;\n\t}\n\n\trc = efx_mcdi_tx_init(tx_queue);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\ttx_queue->buffer[0].flags = EFX_TX_BUF_OPTION;\n\ttx_queue->insert_count = 1;\n\ttxd = efx_tx_desc(tx_queue, 0);\n\tEFX_POPULATE_QWORD_7(*txd,\n\t\t\t     ESF_DZ_TX_DESC_IS_OPT, true,\n\t\t\t     ESF_DZ_TX_OPTION_TYPE,\n\t\t\t     ESE_DZ_TX_OPTION_DESC_CRC_CSUM,\n\t\t\t     ESF_DZ_TX_OPTION_UDP_TCP_CSUM, csum_offload,\n\t\t\t     ESF_DZ_TX_OPTION_IP_CSUM, csum_offload && tx_queue->tso_version != 2,\n\t\t\t     ESF_DZ_TX_OPTION_INNER_UDP_TCP_CSUM, inner_csum,\n\t\t\t     ESF_DZ_TX_OPTION_INNER_IP_CSUM, inner_csum && tx_queue->tso_version != 2,\n\t\t\t     ESF_DZ_TX_TIMESTAMP, tx_queue->timestamping);\n\ttx_queue->write_count = 1;\n\n\tif (tx_queue->tso_version == 2 && efx_has_cap(efx, TX_TSO_V2_ENCAP))\n\t\ttx_queue->tso_encap = true;\n\n\twmb();\n\tefx_ef10_push_tx_desc(tx_queue, txd);\n\n\treturn;\n\nfail:\n\tnetdev_WARN(efx->net_dev, \"failed to initialise TXQ %d\\n\",\n\t\t    tx_queue->queue);\n}\n\n \nstatic inline void efx_ef10_notify_tx_desc(struct efx_tx_queue *tx_queue)\n{\n\tunsigned int write_ptr;\n\tefx_dword_t reg;\n\n\twrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\n\tEFX_POPULATE_DWORD_1(reg, ERF_DZ_TX_DESC_WPTR_DWORD, write_ptr);\n\tefx_writed_page(tx_queue->efx, &reg,\n\t\t\tER_DZ_TX_DESC_UPD_DWORD, tx_queue->queue);\n}\n\n#define EFX_EF10_MAX_TX_DESCRIPTOR_LEN 0x3fff\n\nstatic unsigned int efx_ef10_tx_limit_len(struct efx_tx_queue *tx_queue,\n\t\t\t\t\t  dma_addr_t dma_addr, unsigned int len)\n{\n\tif (len > EFX_EF10_MAX_TX_DESCRIPTOR_LEN) {\n\t\t \n\t\tdma_addr_t end = dma_addr + EFX_EF10_MAX_TX_DESCRIPTOR_LEN;\n\n\t\tBUILD_BUG_ON(EFX_EF10_MAX_TX_DESCRIPTOR_LEN < EFX_PAGE_SIZE);\n\t\tlen = (end & (~(EFX_PAGE_SIZE - 1))) - dma_addr;\n\t}\n\n\treturn len;\n}\n\nstatic void efx_ef10_tx_write(struct efx_tx_queue *tx_queue)\n{\n\tunsigned int old_write_count = tx_queue->write_count;\n\tstruct efx_tx_buffer *buffer;\n\tunsigned int write_ptr;\n\tefx_qword_t *txd;\n\n\ttx_queue->xmit_pending = false;\n\tif (unlikely(tx_queue->write_count == tx_queue->insert_count))\n\t\treturn;\n\n\tdo {\n\t\twrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\n\t\tbuffer = &tx_queue->buffer[write_ptr];\n\t\ttxd = efx_tx_desc(tx_queue, write_ptr);\n\t\t++tx_queue->write_count;\n\n\t\t \n\t\tif (buffer->flags & EFX_TX_BUF_OPTION) {\n\t\t\t*txd = buffer->option;\n\t\t\tif (EFX_QWORD_FIELD(*txd, ESF_DZ_TX_OPTION_TYPE) == 1)\n\t\t\t\t \n\t\t\t\ttx_queue->packet_write_count = tx_queue->write_count;\n\t\t} else {\n\t\t\ttx_queue->packet_write_count = tx_queue->write_count;\n\t\t\tBUILD_BUG_ON(EFX_TX_BUF_CONT != 1);\n\t\t\tEFX_POPULATE_QWORD_3(\n\t\t\t\t*txd,\n\t\t\t\tESF_DZ_TX_KER_CONT,\n\t\t\t\tbuffer->flags & EFX_TX_BUF_CONT,\n\t\t\t\tESF_DZ_TX_KER_BYTE_CNT, buffer->len,\n\t\t\t\tESF_DZ_TX_KER_BUF_ADDR, buffer->dma_addr);\n\t\t}\n\t} while (tx_queue->write_count != tx_queue->insert_count);\n\n\twmb();  \n\n\tif (efx_nic_may_push_tx_desc(tx_queue, old_write_count)) {\n\t\ttxd = efx_tx_desc(tx_queue,\n\t\t\t\t  old_write_count & tx_queue->ptr_mask);\n\t\tefx_ef10_push_tx_desc(tx_queue, txd);\n\t\t++tx_queue->pushes;\n\t} else {\n\t\tefx_ef10_notify_tx_desc(tx_queue);\n\t}\n}\n\nstatic int efx_ef10_probe_multicast_chaining(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tunsigned int enabled, implemented;\n\tbool want_workaround_26807;\n\tint rc;\n\n\trc = efx_mcdi_get_workarounds(efx, &implemented, &enabled);\n\tif (rc == -ENOSYS) {\n\t\t \n\t\tnic_data->workaround_26807 = false;\n\t\treturn 0;\n\t}\n\tif (rc)\n\t\treturn rc;\n\twant_workaround_26807 =\n\t\timplemented & MC_CMD_GET_WORKAROUNDS_OUT_BUG26807;\n\tnic_data->workaround_26807 =\n\t\t!!(enabled & MC_CMD_GET_WORKAROUNDS_OUT_BUG26807);\n\n\tif (want_workaround_26807 && !nic_data->workaround_26807) {\n\t\tunsigned int flags;\n\n\t\trc = efx_mcdi_set_workaround(efx,\n\t\t\t\t\t     MC_CMD_WORKAROUND_BUG26807,\n\t\t\t\t\t     true, &flags);\n\t\tif (!rc) {\n\t\t\tif (flags &\n\t\t\t    1 << MC_CMD_WORKAROUND_EXT_OUT_FLR_DONE_LBN) {\n\t\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t\t   \"other functions on NIC have been reset\\n\");\n\n\t\t\t\t \n\t\t\t\trc = efx_ef10_get_warm_boot_count(efx);\n\t\t\t\tif (rc >= 0) {\n\t\t\t\t\tnic_data->warm_boot_count = rc;\n\t\t\t\t\trc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnic_data->workaround_26807 = true;\n\t\t} else if (rc == -EPERM) {\n\t\t\trc = 0;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int efx_ef10_filter_table_probe(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint rc = efx_ef10_probe_multicast_chaining(efx);\n\tstruct efx_mcdi_filter_vlan *vlan;\n\n\tif (rc)\n\t\treturn rc;\n\tdown_write(&efx->filter_sem);\n\trc = efx_mcdi_filter_table_probe(efx, nic_data->workaround_26807);\n\n\tif (rc)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry(vlan, &nic_data->vlan_list, list) {\n\t\trc = efx_mcdi_filter_add_vlan(efx, vlan->vid);\n\t\tif (rc)\n\t\t\tgoto fail_add_vlan;\n\t}\n\tgoto out_unlock;\n\nfail_add_vlan:\n\tefx_mcdi_filter_table_remove(efx);\nout_unlock:\n\tup_write(&efx->filter_sem);\n\treturn rc;\n}\n\nstatic void efx_ef10_filter_table_remove(struct efx_nic *efx)\n{\n\tdown_write(&efx->filter_sem);\n\tefx_mcdi_filter_table_remove(efx);\n\tup_write(&efx->filter_sem);\n}\n\n \nstatic inline void\nefx_ef10_build_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)\n{\n\tstruct efx_rx_buffer *rx_buf;\n\tefx_qword_t *rxd;\n\n\trxd = efx_rx_desc(rx_queue, index);\n\trx_buf = efx_rx_buffer(rx_queue, index);\n\tEFX_POPULATE_QWORD_2(*rxd,\n\t\t\t     ESF_DZ_RX_KER_BYTE_CNT, rx_buf->len,\n\t\t\t     ESF_DZ_RX_KER_BUF_ADDR, rx_buf->dma_addr);\n}\n\nstatic void efx_ef10_rx_write(struct efx_rx_queue *rx_queue)\n{\n\tstruct efx_nic *efx = rx_queue->efx;\n\tunsigned int write_count;\n\tefx_dword_t reg;\n\n\t \n\twrite_count = rx_queue->added_count & ~7;\n\tif (rx_queue->notified_count == write_count)\n\t\treturn;\n\n\tdo\n\t\tefx_ef10_build_rx_desc(\n\t\t\trx_queue,\n\t\t\trx_queue->notified_count & rx_queue->ptr_mask);\n\twhile (++rx_queue->notified_count != write_count);\n\n\twmb();\n\tEFX_POPULATE_DWORD_1(reg, ERF_DZ_RX_DESC_WPTR,\n\t\t\t     write_count & rx_queue->ptr_mask);\n\tefx_writed_page(efx, &reg, ER_DZ_RX_DESC_UPD,\n\t\t\tefx_rx_queue_index(rx_queue));\n}\n\nstatic efx_mcdi_async_completer efx_ef10_rx_defer_refill_complete;\n\nstatic void efx_ef10_rx_defer_refill(struct efx_rx_queue *rx_queue)\n{\n\tstruct efx_channel *channel = efx_rx_queue_channel(rx_queue);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_DRIVER_EVENT_IN_LEN);\n\tefx_qword_t event;\n\n\tEFX_POPULATE_QWORD_2(event,\n\t\t\t     ESF_DZ_EV_CODE, EFX_EF10_DRVGEN_EV,\n\t\t\t     ESF_DZ_EV_DATA, EFX_EF10_REFILL);\n\n\tMCDI_SET_DWORD(inbuf, DRIVER_EVENT_IN_EVQ, channel->channel);\n\n\t \n\tmemcpy(MCDI_PTR(inbuf, DRIVER_EVENT_IN_DATA), &event.u64[0],\n\t       sizeof(efx_qword_t));\n\n\tefx_mcdi_rpc_async(channel->efx, MC_CMD_DRIVER_EVENT,\n\t\t\t   inbuf, sizeof(inbuf), 0,\n\t\t\t   efx_ef10_rx_defer_refill_complete, 0);\n}\n\nstatic void\nefx_ef10_rx_defer_refill_complete(struct efx_nic *efx, unsigned long cookie,\n\t\t\t\t  int rc, efx_dword_t *outbuf,\n\t\t\t\t  size_t outlen_actual)\n{\n\t \n}\n\nstatic int efx_ef10_ev_init(struct efx_channel *channel)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tstruct efx_ef10_nic_data *nic_data;\n\tbool use_v2, cut_thru;\n\n\tnic_data = efx->nic_data;\n\tuse_v2 = nic_data->datapath_caps2 &\n\t\t\t    1 << MC_CMD_GET_CAPABILITIES_V2_OUT_INIT_EVQ_V2_LBN;\n\tcut_thru = !(nic_data->datapath_caps &\n\t\t\t      1 << MC_CMD_GET_CAPABILITIES_OUT_RX_BATCHING_LBN);\n\treturn efx_mcdi_ev_init(channel, cut_thru, use_v2);\n}\n\nstatic void efx_ef10_handle_rx_wrong_queue(struct efx_rx_queue *rx_queue,\n\t\t\t\t\t   unsigned int rx_queue_label)\n{\n\tstruct efx_nic *efx = rx_queue->efx;\n\n\tnetif_info(efx, hw, efx->net_dev,\n\t\t   \"rx event arrived on queue %d labeled as queue %u\\n\",\n\t\t   efx_rx_queue_index(rx_queue), rx_queue_label);\n\n\tefx_schedule_reset(efx, RESET_TYPE_DISABLE);\n}\n\nstatic void\nefx_ef10_handle_rx_bad_lbits(struct efx_rx_queue *rx_queue,\n\t\t\t     unsigned int actual, unsigned int expected)\n{\n\tunsigned int dropped = (actual - expected) & rx_queue->ptr_mask;\n\tstruct efx_nic *efx = rx_queue->efx;\n\n\tnetif_info(efx, hw, efx->net_dev,\n\t\t   \"dropped %d events (index=%d expected=%d)\\n\",\n\t\t   dropped, actual, expected);\n\n\tefx_schedule_reset(efx, RESET_TYPE_DISABLE);\n}\n\n \nstatic void efx_ef10_handle_rx_abort(struct efx_rx_queue *rx_queue)\n{\n\tunsigned int rx_desc_ptr;\n\n\tnetif_dbg(rx_queue->efx, hw, rx_queue->efx->net_dev,\n\t\t  \"scattered RX aborted (dropping %u buffers)\\n\",\n\t\t  rx_queue->scatter_n);\n\n\trx_desc_ptr = rx_queue->removed_count & rx_queue->ptr_mask;\n\n\tefx_rx_packet(rx_queue, rx_desc_ptr, rx_queue->scatter_n,\n\t\t      0, EFX_RX_PKT_DISCARD);\n\n\trx_queue->removed_count += rx_queue->scatter_n;\n\trx_queue->scatter_n = 0;\n\trx_queue->scatter_len = 0;\n\t++efx_rx_queue_channel(rx_queue)->n_rx_nodesc_trunc;\n}\n\nstatic u16 efx_ef10_handle_rx_event_errors(struct efx_channel *channel,\n\t\t\t\t\t   unsigned int n_packets,\n\t\t\t\t\t   unsigned int rx_encap_hdr,\n\t\t\t\t\t   unsigned int rx_l3_class,\n\t\t\t\t\t   unsigned int rx_l4_class,\n\t\t\t\t\t   const efx_qword_t *event)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tbool handled = false;\n\n\tif (EFX_QWORD_FIELD(*event, ESF_DZ_RX_ECRC_ERR)) {\n\t\tif (!(efx->net_dev->features & NETIF_F_RXALL)) {\n\t\t\tif (!efx->loopback_selftest)\n\t\t\t\tchannel->n_rx_eth_crc_err += n_packets;\n\t\t\treturn EFX_RX_PKT_DISCARD;\n\t\t}\n\t\thandled = true;\n\t}\n\tif (EFX_QWORD_FIELD(*event, ESF_DZ_RX_IPCKSUM_ERR)) {\n\t\tif (unlikely(rx_encap_hdr != ESE_EZ_ENCAP_HDR_VXLAN &&\n\t\t\t     rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&\n\t\t\t     rx_l3_class != ESE_DZ_L3_CLASS_IP4_FRAG &&\n\t\t\t     rx_l3_class != ESE_DZ_L3_CLASS_IP6 &&\n\t\t\t     rx_l3_class != ESE_DZ_L3_CLASS_IP6_FRAG))\n\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t    \"invalid class for RX_IPCKSUM_ERR: event=\"\n\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\tif (!efx->loopback_selftest)\n\t\t\t*(rx_encap_hdr ?\n\t\t\t  &channel->n_rx_outer_ip_hdr_chksum_err :\n\t\t\t  &channel->n_rx_ip_hdr_chksum_err) += n_packets;\n\t\treturn 0;\n\t}\n\tif (EFX_QWORD_FIELD(*event, ESF_DZ_RX_TCPUDP_CKSUM_ERR)) {\n\t\tif (unlikely(rx_encap_hdr != ESE_EZ_ENCAP_HDR_VXLAN &&\n\t\t\t     ((rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&\n\t\t\t       rx_l3_class != ESE_DZ_L3_CLASS_IP6) ||\n\t\t\t      (rx_l4_class != ESE_FZ_L4_CLASS_TCP &&\n\t\t\t       rx_l4_class != ESE_FZ_L4_CLASS_UDP))))\n\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t    \"invalid class for RX_TCPUDP_CKSUM_ERR: event=\"\n\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\tif (!efx->loopback_selftest)\n\t\t\t*(rx_encap_hdr ?\n\t\t\t  &channel->n_rx_outer_tcp_udp_chksum_err :\n\t\t\t  &channel->n_rx_tcp_udp_chksum_err) += n_packets;\n\t\treturn 0;\n\t}\n\tif (EFX_QWORD_FIELD(*event, ESF_EZ_RX_IP_INNER_CHKSUM_ERR)) {\n\t\tif (unlikely(!rx_encap_hdr))\n\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t    \"invalid encapsulation type for RX_IP_INNER_CHKSUM_ERR: event=\"\n\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\telse if (unlikely(rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&\n\t\t\t\t  rx_l3_class != ESE_DZ_L3_CLASS_IP4_FRAG &&\n\t\t\t\t  rx_l3_class != ESE_DZ_L3_CLASS_IP6 &&\n\t\t\t\t  rx_l3_class != ESE_DZ_L3_CLASS_IP6_FRAG))\n\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t    \"invalid class for RX_IP_INNER_CHKSUM_ERR: event=\"\n\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\tif (!efx->loopback_selftest)\n\t\t\tchannel->n_rx_inner_ip_hdr_chksum_err += n_packets;\n\t\treturn 0;\n\t}\n\tif (EFX_QWORD_FIELD(*event, ESF_EZ_RX_TCP_UDP_INNER_CHKSUM_ERR)) {\n\t\tif (unlikely(!rx_encap_hdr))\n\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t    \"invalid encapsulation type for RX_TCP_UDP_INNER_CHKSUM_ERR: event=\"\n\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\telse if (unlikely((rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&\n\t\t\t\t   rx_l3_class != ESE_DZ_L3_CLASS_IP6) ||\n\t\t\t\t  (rx_l4_class != ESE_FZ_L4_CLASS_TCP &&\n\t\t\t\t   rx_l4_class != ESE_FZ_L4_CLASS_UDP)))\n\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t    \"invalid class for RX_TCP_UDP_INNER_CHKSUM_ERR: event=\"\n\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\tif (!efx->loopback_selftest)\n\t\t\tchannel->n_rx_inner_tcp_udp_chksum_err += n_packets;\n\t\treturn 0;\n\t}\n\n\tWARN_ON(!handled);  \n\treturn 0;\n}\n\nstatic int efx_ef10_handle_rx_event(struct efx_channel *channel,\n\t\t\t\t    const efx_qword_t *event)\n{\n\tunsigned int rx_bytes, next_ptr_lbits, rx_queue_label;\n\tunsigned int rx_l3_class, rx_l4_class, rx_encap_hdr;\n\tunsigned int n_descs, n_packets, i;\n\tstruct efx_nic *efx = channel->efx;\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tstruct efx_rx_queue *rx_queue;\n\tefx_qword_t errors;\n\tbool rx_cont;\n\tu16 flags = 0;\n\n\tif (unlikely(READ_ONCE(efx->reset_pending)))\n\t\treturn 0;\n\n\t \n\trx_bytes = EFX_QWORD_FIELD(*event, ESF_DZ_RX_BYTES);\n\tnext_ptr_lbits = EFX_QWORD_FIELD(*event, ESF_DZ_RX_DSC_PTR_LBITS);\n\trx_queue_label = EFX_QWORD_FIELD(*event, ESF_DZ_RX_QLABEL);\n\trx_l3_class = EFX_QWORD_FIELD(*event, ESF_DZ_RX_L3_CLASS);\n\trx_l4_class = EFX_QWORD_FIELD(*event, ESF_FZ_RX_L4_CLASS);\n\trx_cont = EFX_QWORD_FIELD(*event, ESF_DZ_RX_CONT);\n\trx_encap_hdr =\n\t\tnic_data->datapath_caps &\n\t\t\t(1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN) ?\n\t\tEFX_QWORD_FIELD(*event, ESF_EZ_RX_ENCAP_HDR) :\n\t\tESE_EZ_ENCAP_HDR_NONE;\n\n\tif (EFX_QWORD_FIELD(*event, ESF_DZ_RX_DROP_EVENT))\n\t\tnetdev_WARN(efx->net_dev, \"saw RX_DROP_EVENT: event=\"\n\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t    EFX_QWORD_VAL(*event));\n\n\trx_queue = efx_channel_get_rx_queue(channel);\n\n\tif (unlikely(rx_queue_label != efx_rx_queue_index(rx_queue)))\n\t\tefx_ef10_handle_rx_wrong_queue(rx_queue, rx_queue_label);\n\n\tn_descs = ((next_ptr_lbits - rx_queue->removed_count) &\n\t\t   ((1 << ESF_DZ_RX_DSC_PTR_LBITS_WIDTH) - 1));\n\n\tif (n_descs != rx_queue->scatter_n + 1) {\n\t\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\t\t \n\t\tif (unlikely(n_descs == rx_queue->scatter_n)) {\n\t\t\tif (rx_queue->scatter_n == 0 || rx_bytes != 0)\n\t\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t\t    \"invalid RX abort: scatter_n=%u event=\"\n\t\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t\t    rx_queue->scatter_n,\n\t\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\t\tefx_ef10_handle_rx_abort(rx_queue);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (!(nic_data->datapath_caps &\n\t\t      (1 << MC_CMD_GET_CAPABILITIES_OUT_RX_BATCHING_LBN)) ||\n\t\t    rx_queue->scatter_n != 0 || rx_cont) {\n\t\t\tefx_ef10_handle_rx_bad_lbits(\n\t\t\t\trx_queue, next_ptr_lbits,\n\t\t\t\t(rx_queue->removed_count +\n\t\t\t\t rx_queue->scatter_n + 1) &\n\t\t\t\t((1 << ESF_DZ_RX_DSC_PTR_LBITS_WIDTH) - 1));\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\trx_queue->scatter_n = 1;\n\t\trx_queue->scatter_len = 0;\n\t\tn_packets = n_descs;\n\t\t++channel->n_rx_merge_events;\n\t\tchannel->n_rx_merge_packets += n_packets;\n\t\tflags |= EFX_RX_PKT_PREFIX_LEN;\n\t} else {\n\t\t++rx_queue->scatter_n;\n\t\trx_queue->scatter_len += rx_bytes;\n\t\tif (rx_cont)\n\t\t\treturn 0;\n\t\tn_packets = 1;\n\t}\n\n\tEFX_POPULATE_QWORD_5(errors, ESF_DZ_RX_ECRC_ERR, 1,\n\t\t\t\t     ESF_DZ_RX_IPCKSUM_ERR, 1,\n\t\t\t\t     ESF_DZ_RX_TCPUDP_CKSUM_ERR, 1,\n\t\t\t\t     ESF_EZ_RX_IP_INNER_CHKSUM_ERR, 1,\n\t\t\t\t     ESF_EZ_RX_TCP_UDP_INNER_CHKSUM_ERR, 1);\n\tEFX_AND_QWORD(errors, *event, errors);\n\tif (unlikely(!EFX_QWORD_IS_ZERO(errors))) {\n\t\tflags |= efx_ef10_handle_rx_event_errors(channel, n_packets,\n\t\t\t\t\t\t\t rx_encap_hdr,\n\t\t\t\t\t\t\t rx_l3_class, rx_l4_class,\n\t\t\t\t\t\t\t event);\n\t} else {\n\t\tbool tcpudp = rx_l4_class == ESE_FZ_L4_CLASS_TCP ||\n\t\t\t      rx_l4_class == ESE_FZ_L4_CLASS_UDP;\n\n\t\tswitch (rx_encap_hdr) {\n\t\tcase ESE_EZ_ENCAP_HDR_VXLAN:  \n\t\t\tflags |= EFX_RX_PKT_CSUMMED;  \n\t\t\tif (tcpudp)\n\t\t\t\tflags |= EFX_RX_PKT_CSUM_LEVEL;  \n\t\t\tbreak;\n\t\tcase ESE_EZ_ENCAP_HDR_GRE:\n\t\tcase ESE_EZ_ENCAP_HDR_NONE:\n\t\t\tif (tcpudp)\n\t\t\t\tflags |= EFX_RX_PKT_CSUMMED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_WARN(efx->net_dev,\n\t\t\t\t    \"unknown encapsulation type: event=\"\n\t\t\t\t    EFX_QWORD_FMT \"\\n\",\n\t\t\t\t    EFX_QWORD_VAL(*event));\n\t\t}\n\t}\n\n\tif (rx_l4_class == ESE_FZ_L4_CLASS_TCP)\n\t\tflags |= EFX_RX_PKT_TCP;\n\n\tchannel->irq_mod_score += 2 * n_packets;\n\n\t \n\tfor (i = 0; i < n_packets; i++) {\n\t\tefx_rx_packet(rx_queue,\n\t\t\t      rx_queue->removed_count & rx_queue->ptr_mask,\n\t\t\t      rx_queue->scatter_n, rx_queue->scatter_len,\n\t\t\t      flags);\n\t\trx_queue->removed_count += rx_queue->scatter_n;\n\t}\n\n\trx_queue->scatter_n = 0;\n\trx_queue->scatter_len = 0;\n\n\treturn n_packets;\n}\n\nstatic u32 efx_ef10_extract_event_ts(efx_qword_t *event)\n{\n\tu32 tstamp;\n\n\ttstamp = EFX_QWORD_FIELD(*event, TX_TIMESTAMP_EVENT_TSTAMP_DATA_HI);\n\ttstamp <<= 16;\n\ttstamp |= EFX_QWORD_FIELD(*event, TX_TIMESTAMP_EVENT_TSTAMP_DATA_LO);\n\n\treturn tstamp;\n}\n\nstatic int\nefx_ef10_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tstruct efx_tx_queue *tx_queue;\n\tunsigned int tx_ev_desc_ptr;\n\tunsigned int tx_ev_q_label;\n\tunsigned int tx_ev_type;\n\tint work_done;\n\tu64 ts_part;\n\n\tif (unlikely(READ_ONCE(efx->reset_pending)))\n\t\treturn 0;\n\n\tif (unlikely(EFX_QWORD_FIELD(*event, ESF_DZ_TX_DROP_EVENT)))\n\t\treturn 0;\n\n\t \n\ttx_ev_q_label = EFX_QWORD_FIELD(*event, ESF_DZ_TX_QLABEL);\n\ttx_queue = channel->tx_queue + (tx_ev_q_label % EFX_MAX_TXQ_PER_CHANNEL);\n\n\tif (!tx_queue->timestamping) {\n\t\t \n\t\ttx_ev_desc_ptr = EFX_QWORD_FIELD(*event, ESF_DZ_TX_DESCR_INDX);\n\t\treturn efx_xmit_done(tx_queue, tx_ev_desc_ptr & tx_queue->ptr_mask);\n\t}\n\n\t \n\ttx_ev_type = EFX_QWORD_FIELD(*event, ESF_EZ_TX_SOFT1);\n\twork_done = 0;\n\n\tswitch (tx_ev_type) {\n\tcase TX_TIMESTAMP_EVENT_TX_EV_COMPLETION:\n\t\t \n\t\tbreak;\n\n\tcase TX_TIMESTAMP_EVENT_TX_EV_TSTAMP_LO:\n\t\tts_part = efx_ef10_extract_event_ts(event);\n\t\ttx_queue->completed_timestamp_minor = ts_part;\n\t\tbreak;\n\n\tcase TX_TIMESTAMP_EVENT_TX_EV_TSTAMP_HI:\n\t\tts_part = efx_ef10_extract_event_ts(event);\n\t\ttx_queue->completed_timestamp_major = ts_part;\n\n\t\tefx_xmit_done_single(tx_queue);\n\t\twork_done = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"channel %d unknown tx event type %d (data \"\n\t\t\t  EFX_QWORD_FMT \")\\n\",\n\t\t\t  channel->channel, tx_ev_type,\n\t\t\t  EFX_QWORD_VAL(*event));\n\t\tbreak;\n\t}\n\n\treturn work_done;\n}\n\nstatic void\nefx_ef10_handle_driver_event(struct efx_channel *channel, efx_qword_t *event)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tint subcode;\n\n\tsubcode = EFX_QWORD_FIELD(*event, ESF_DZ_DRV_SUB_CODE);\n\n\tswitch (subcode) {\n\tcase ESE_DZ_DRV_TIMER_EV:\n\tcase ESE_DZ_DRV_WAKE_UP_EV:\n\t\tbreak;\n\tcase ESE_DZ_DRV_START_UP_EV:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"channel %d unknown driver event type %d\"\n\t\t\t  \" (data \" EFX_QWORD_FMT \")\\n\",\n\t\t\t  channel->channel, subcode,\n\t\t\t  EFX_QWORD_VAL(*event));\n\n\t}\n}\n\nstatic void efx_ef10_handle_driver_generated_event(struct efx_channel *channel,\n\t\t\t\t\t\t   efx_qword_t *event)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tu32 subcode;\n\n\tsubcode = EFX_QWORD_FIELD(*event, EFX_DWORD_0);\n\n\tswitch (subcode) {\n\tcase EFX_EF10_TEST:\n\t\tchannel->event_test_cpu = raw_smp_processor_id();\n\t\tbreak;\n\tcase EFX_EF10_REFILL:\n\t\t \n\t\tefx_fast_push_rx_descriptors(&channel->rx_queue, true);\n\t\tbreak;\n\tdefault:\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"channel %d unknown driver event type %u\"\n\t\t\t  \" (data \" EFX_QWORD_FMT \")\\n\",\n\t\t\t  channel->channel, (unsigned) subcode,\n\t\t\t  EFX_QWORD_VAL(*event));\n\t}\n}\n\n#define EFX_NAPI_MAX_TX 512\n\nstatic int efx_ef10_ev_process(struct efx_channel *channel, int quota)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tefx_qword_t event, *p_event;\n\tunsigned int read_ptr;\n\tint spent_tx = 0;\n\tint spent = 0;\n\tint ev_code;\n\n\tif (quota <= 0)\n\t\treturn spent;\n\n\tread_ptr = channel->eventq_read_ptr;\n\n\tfor (;;) {\n\t\tp_event = efx_event(channel, read_ptr);\n\t\tevent = *p_event;\n\n\t\tif (!efx_event_present(&event))\n\t\t\tbreak;\n\n\t\tEFX_SET_QWORD(*p_event);\n\n\t\t++read_ptr;\n\n\t\tev_code = EFX_QWORD_FIELD(event, ESF_DZ_EV_CODE);\n\n\t\tnetif_vdbg(efx, drv, efx->net_dev,\n\t\t\t   \"processing event on %d \" EFX_QWORD_FMT \"\\n\",\n\t\t\t   channel->channel, EFX_QWORD_VAL(event));\n\n\t\tswitch (ev_code) {\n\t\tcase ESE_DZ_EV_CODE_MCDI_EV:\n\t\t\tefx_mcdi_process_event(channel, &event);\n\t\t\tbreak;\n\t\tcase ESE_DZ_EV_CODE_RX_EV:\n\t\t\tspent += efx_ef10_handle_rx_event(channel, &event);\n\t\t\tif (spent >= quota) {\n\t\t\t\t \n\t\t\t\tspent = quota;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ESE_DZ_EV_CODE_TX_EV:\n\t\t\tspent_tx += efx_ef10_handle_tx_event(channel, &event);\n\t\t\tif (spent_tx >= EFX_NAPI_MAX_TX) {\n\t\t\t\tspent = quota;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ESE_DZ_EV_CODE_DRIVER_EV:\n\t\t\tefx_ef10_handle_driver_event(channel, &event);\n\t\t\tif (++spent == quota)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase EFX_EF10_DRVGEN_EV:\n\t\t\tefx_ef10_handle_driver_generated_event(channel, &event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t  \"channel %d unknown event type %d\"\n\t\t\t\t  \" (data \" EFX_QWORD_FMT \")\\n\",\n\t\t\t\t  channel->channel, ev_code,\n\t\t\t\t  EFX_QWORD_VAL(event));\n\t\t}\n\t}\n\nout:\n\tchannel->eventq_read_ptr = read_ptr;\n\treturn spent;\n}\n\nstatic void efx_ef10_ev_read_ack(struct efx_channel *channel)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tefx_dword_t rptr;\n\n\tif (EFX_EF10_WORKAROUND_35388(efx)) {\n\t\tBUILD_BUG_ON(EFX_MIN_EVQ_SIZE <\n\t\t\t     (1 << ERF_DD_EVQ_IND_RPTR_WIDTH));\n\t\tBUILD_BUG_ON(EFX_MAX_EVQ_SIZE >\n\t\t\t     (1 << 2 * ERF_DD_EVQ_IND_RPTR_WIDTH));\n\n\t\tEFX_POPULATE_DWORD_2(rptr, ERF_DD_EVQ_IND_RPTR_FLAGS,\n\t\t\t\t     EFE_DD_EVQ_IND_RPTR_FLAGS_HIGH,\n\t\t\t\t     ERF_DD_EVQ_IND_RPTR,\n\t\t\t\t     (channel->eventq_read_ptr &\n\t\t\t\t      channel->eventq_mask) >>\n\t\t\t\t     ERF_DD_EVQ_IND_RPTR_WIDTH);\n\t\tefx_writed_page(efx, &rptr, ER_DD_EVQ_INDIRECT,\n\t\t\t\tchannel->channel);\n\t\tEFX_POPULATE_DWORD_2(rptr, ERF_DD_EVQ_IND_RPTR_FLAGS,\n\t\t\t\t     EFE_DD_EVQ_IND_RPTR_FLAGS_LOW,\n\t\t\t\t     ERF_DD_EVQ_IND_RPTR,\n\t\t\t\t     channel->eventq_read_ptr &\n\t\t\t\t     ((1 << ERF_DD_EVQ_IND_RPTR_WIDTH) - 1));\n\t\tefx_writed_page(efx, &rptr, ER_DD_EVQ_INDIRECT,\n\t\t\t\tchannel->channel);\n\t} else {\n\t\tEFX_POPULATE_DWORD_1(rptr, ERF_DZ_EVQ_RPTR,\n\t\t\t\t     channel->eventq_read_ptr &\n\t\t\t\t     channel->eventq_mask);\n\t\tefx_writed_page(efx, &rptr, ER_DZ_EVQ_RPTR, channel->channel);\n\t}\n}\n\nstatic void efx_ef10_ev_test_generate(struct efx_channel *channel)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_DRIVER_EVENT_IN_LEN);\n\tstruct efx_nic *efx = channel->efx;\n\tefx_qword_t event;\n\tint rc;\n\n\tEFX_POPULATE_QWORD_2(event,\n\t\t\t     ESF_DZ_EV_CODE, EFX_EF10_DRVGEN_EV,\n\t\t\t     ESF_DZ_EV_DATA, EFX_EF10_TEST);\n\n\tMCDI_SET_DWORD(inbuf, DRIVER_EVENT_IN_EVQ, channel->channel);\n\n\t \n\tmemcpy(MCDI_PTR(inbuf, DRIVER_EVENT_IN_DATA), &event.u64[0],\n\t       sizeof(efx_qword_t));\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_DRIVER_EVENT, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\tif (rc != 0)\n\t\tgoto fail;\n\n\treturn;\n\nfail:\n\tWARN_ON(true);\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n}\n\nstatic void efx_ef10_prepare_flr(struct efx_nic *efx)\n{\n\tatomic_set(&efx->active_queues, 0);\n}\n\nstatic int efx_ef10_vport_set_mac_address(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tu8 mac_old[ETH_ALEN];\n\tint rc, rc2;\n\n\t \n\tif (is_zero_ether_addr(nic_data->vport_mac))\n\t\treturn 0;\n\n\tefx_device_detach_sync(efx);\n\tefx_net_stop(efx->net_dev);\n\tefx_ef10_filter_table_remove(efx);\n\n\trc = efx_ef10_vadaptor_free(efx, efx->vport_id);\n\tif (rc)\n\t\tgoto restore_filters;\n\n\tether_addr_copy(mac_old, nic_data->vport_mac);\n\trc = efx_ef10_vport_del_mac(efx, efx->vport_id,\n\t\t\t\t    nic_data->vport_mac);\n\tif (rc)\n\t\tgoto restore_vadaptor;\n\n\trc = efx_ef10_vport_add_mac(efx, efx->vport_id,\n\t\t\t\t    efx->net_dev->dev_addr);\n\tif (!rc) {\n\t\tether_addr_copy(nic_data->vport_mac, efx->net_dev->dev_addr);\n\t} else {\n\t\trc2 = efx_ef10_vport_add_mac(efx, efx->vport_id, mac_old);\n\t\tif (rc2) {\n\t\t\t \n\t\t\teth_zero_addr(nic_data->vport_mac);\n\t\t\tgoto reset_nic;\n\t\t}\n\t}\n\nrestore_vadaptor:\n\trc2 = efx_ef10_vadaptor_alloc(efx, efx->vport_id);\n\tif (rc2)\n\t\tgoto reset_nic;\nrestore_filters:\n\trc2 = efx_ef10_filter_table_probe(efx);\n\tif (rc2)\n\t\tgoto reset_nic;\n\n\trc2 = efx_net_open(efx->net_dev);\n\tif (rc2)\n\t\tgoto reset_nic;\n\n\tefx_device_attach_if_not_resetting(efx);\n\n\treturn rc;\n\nreset_nic:\n\tnetif_err(efx, drv, efx->net_dev,\n\t\t  \"Failed to restore when changing MAC address - scheduling reset\\n\");\n\tefx_schedule_reset(efx, RESET_TYPE_DATAPATH);\n\n\treturn rc ? rc : rc2;\n}\n\nstatic int efx_ef10_set_mac_address(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_SET_MAC_IN_LEN);\n\tbool was_enabled = efx->port_enabled;\n\tint rc;\n\n#ifdef CONFIG_SFC_SRIOV\n\t \n\tif (efx->pci_dev->is_virtfn && efx->pci_dev->physfn) {\n\t\tstruct efx_nic *efx_pf = pci_get_drvdata(efx->pci_dev->physfn);\n\t\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\t\tu8 mac[ETH_ALEN];\n\n\t\t \n\t\tether_addr_copy(mac, efx->net_dev->dev_addr);\n\n\t\trc = efx_ef10_sriov_set_vf_mac(efx_pf, nic_data->vf_index, mac);\n\t\tif (!rc)\n\t\t\treturn 0;\n\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Updating VF mac via PF failed (%d), setting directly\\n\",\n\t\t\t  rc);\n\t}\n#endif\n\n\tefx_device_detach_sync(efx);\n\tefx_net_stop(efx->net_dev);\n\n\tmutex_lock(&efx->mac_lock);\n\tefx_ef10_filter_table_remove(efx);\n\n\tether_addr_copy(MCDI_PTR(inbuf, VADAPTOR_SET_MAC_IN_MACADDR),\n\t\t\tefx->net_dev->dev_addr);\n\tMCDI_SET_DWORD(inbuf, VADAPTOR_SET_MAC_IN_UPSTREAM_PORT_ID,\n\t\t       efx->vport_id);\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_VADAPTOR_SET_MAC, inbuf,\n\t\t\t\tsizeof(inbuf), NULL, 0, NULL);\n\n\tefx_ef10_filter_table_probe(efx);\n\tmutex_unlock(&efx->mac_lock);\n\n\tif (was_enabled)\n\t\tefx_net_open(efx->net_dev);\n\tefx_device_attach_if_not_resetting(efx);\n\n\tif (rc == -EPERM) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Cannot change MAC address; use sfboot to enable\"\n\t\t\t  \" mac-spoofing on this interface\\n\");\n\t} else if (rc == -ENOSYS && !efx_ef10_is_vf(efx)) {\n\t\t \n\t\trc = efx_ef10_vport_set_mac_address(efx);\n\t} else if (rc) {\n\t\tefx_mcdi_display_error(efx, MC_CMD_VADAPTOR_SET_MAC,\n\t\t\t\t       sizeof(inbuf), NULL, 0, rc);\n\t}\n\n\treturn rc;\n}\n\nstatic int efx_ef10_mac_reconfigure(struct efx_nic *efx, bool mtu_only)\n{\n\tWARN_ON(!mutex_is_locked(&efx->mac_lock));\n\n\tefx_mcdi_filter_sync_rx_mode(efx);\n\n\tif (mtu_only && efx_has_cap(efx, SET_MAC_ENHANCED))\n\t\treturn efx_mcdi_set_mtu(efx);\n\treturn efx_mcdi_set_mac(efx);\n}\n\nstatic int efx_ef10_start_bist(struct efx_nic *efx, u32 bist_type)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_START_BIST_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, START_BIST_IN_TYPE, bist_type);\n\treturn efx_mcdi_rpc(efx, MC_CMD_START_BIST, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\n \nstatic int efx_ef10_poll_bist(struct efx_nic *efx)\n{\n\tint rc;\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_POLL_BIST_OUT_LEN);\n\tsize_t outlen;\n\tu32 result;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_POLL_BIST, NULL, 0,\n\t\t\t   outbuf, sizeof(outbuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (outlen < MC_CMD_POLL_BIST_OUT_LEN)\n\t\treturn -EIO;\n\n\tresult = MCDI_DWORD(outbuf, POLL_BIST_OUT_RESULT);\n\tswitch (result) {\n\tcase MC_CMD_POLL_BIST_PASSED:\n\t\tnetif_dbg(efx, hw, efx->net_dev, \"BIST passed.\\n\");\n\t\treturn 0;\n\tcase MC_CMD_POLL_BIST_TIMEOUT:\n\t\tnetif_err(efx, hw, efx->net_dev, \"BIST timed out\\n\");\n\t\treturn -EIO;\n\tcase MC_CMD_POLL_BIST_FAILED:\n\t\tnetif_err(efx, hw, efx->net_dev, \"BIST failed.\\n\");\n\t\treturn -EIO;\n\tdefault:\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"BIST returned unknown result %u\", result);\n\t\treturn -EIO;\n\t}\n}\n\nstatic int efx_ef10_run_bist(struct efx_nic *efx, u32 bist_type)\n{\n\tint rc;\n\n\tnetif_dbg(efx, drv, efx->net_dev, \"starting BIST type %u\\n\", bist_type);\n\n\trc = efx_ef10_start_bist(efx, bist_type);\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn efx_ef10_poll_bist(efx);\n}\n\nstatic int\nefx_ef10_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)\n{\n\tint rc, rc2;\n\n\tefx_reset_down(efx, RESET_TYPE_WORLD);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_ENABLE_OFFLINE_BIST,\n\t\t\t  NULL, 0, NULL, 0, NULL);\n\tif (rc != 0)\n\t\tgoto out;\n\n\ttests->memory = efx_ef10_run_bist(efx, MC_CMD_MC_MEM_BIST) ? -1 : 1;\n\ttests->registers = efx_ef10_run_bist(efx, MC_CMD_REG_BIST) ? -1 : 1;\n\n\trc = efx_mcdi_reset(efx, RESET_TYPE_WORLD);\n\nout:\n\tif (rc == -EPERM)\n\t\trc = 0;\n\trc2 = efx_reset_up(efx, RESET_TYPE_WORLD, rc == 0);\n\treturn rc ? rc : rc2;\n}\n\n#ifdef CONFIG_SFC_MTD\n\nstruct efx_ef10_nvram_type_info {\n\tu16 type, type_mask;\n\tu8 port;\n\tconst char *name;\n};\n\nstatic const struct efx_ef10_nvram_type_info efx_ef10_nvram_types[] = {\n\t{ NVRAM_PARTITION_TYPE_MC_FIRMWARE,\t   0,    0, \"sfc_mcfw\" },\n\t{ NVRAM_PARTITION_TYPE_MC_FIRMWARE_BACKUP, 0,    0, \"sfc_mcfw_backup\" },\n\t{ NVRAM_PARTITION_TYPE_EXPANSION_ROM,\t   0,    0, \"sfc_exp_rom\" },\n\t{ NVRAM_PARTITION_TYPE_STATIC_CONFIG,\t   0,    0, \"sfc_static_cfg\" },\n\t{ NVRAM_PARTITION_TYPE_DYNAMIC_CONFIG,\t   0,    0, \"sfc_dynamic_cfg\" },\n\t{ NVRAM_PARTITION_TYPE_EXPROM_CONFIG_PORT0, 0,   0, \"sfc_exp_rom_cfg\" },\n\t{ NVRAM_PARTITION_TYPE_EXPROM_CONFIG_PORT1, 0,   1, \"sfc_exp_rom_cfg\" },\n\t{ NVRAM_PARTITION_TYPE_EXPROM_CONFIG_PORT2, 0,   2, \"sfc_exp_rom_cfg\" },\n\t{ NVRAM_PARTITION_TYPE_EXPROM_CONFIG_PORT3, 0,   3, \"sfc_exp_rom_cfg\" },\n\t{ NVRAM_PARTITION_TYPE_LICENSE,\t\t   0,    0, \"sfc_license\" },\n\t{ NVRAM_PARTITION_TYPE_PHY_MIN,\t\t   0xff, 0, \"sfc_phy_fw\" },\n\t{ NVRAM_PARTITION_TYPE_MUM_FIRMWARE,\t   0,    0, \"sfc_mumfw\" },\n\t{ NVRAM_PARTITION_TYPE_EXPANSION_UEFI,\t   0,    0, \"sfc_uefi\" },\n\t{ NVRAM_PARTITION_TYPE_DYNCONFIG_DEFAULTS, 0,    0, \"sfc_dynamic_cfg_dflt\" },\n\t{ NVRAM_PARTITION_TYPE_ROMCONFIG_DEFAULTS, 0,    0, \"sfc_exp_rom_cfg_dflt\" },\n\t{ NVRAM_PARTITION_TYPE_STATUS,\t\t   0,    0, \"sfc_status\" },\n\t{ NVRAM_PARTITION_TYPE_BUNDLE,\t\t   0,    0, \"sfc_bundle\" },\n\t{ NVRAM_PARTITION_TYPE_BUNDLE_METADATA,\t   0,    0, \"sfc_bundle_metadata\" },\n};\n#define EF10_NVRAM_PARTITION_COUNT\tARRAY_SIZE(efx_ef10_nvram_types)\n\nstatic int efx_ef10_mtd_probe_partition(struct efx_nic *efx,\n\t\t\t\t\tstruct efx_mcdi_mtd_partition *part,\n\t\t\t\t\tunsigned int type,\n\t\t\t\t\tunsigned long *found)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_METADATA_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_METADATA_OUT_LENMAX);\n\tconst struct efx_ef10_nvram_type_info *info;\n\tsize_t size, erase_size, outlen;\n\tint type_idx = 0;\n\tbool protected;\n\tint rc;\n\n\tfor (type_idx = 0; ; type_idx++) {\n\t\tif (type_idx == EF10_NVRAM_PARTITION_COUNT)\n\t\t\treturn -ENODEV;\n\t\tinfo = efx_ef10_nvram_types + type_idx;\n\t\tif ((type & ~info->type_mask) == info->type)\n\t\t\tbreak;\n\t}\n\tif (info->port != efx_port_num(efx))\n\t\treturn -ENODEV;\n\n\trc = efx_mcdi_nvram_info(efx, type, &size, &erase_size, &protected);\n\tif (rc)\n\t\treturn rc;\n\tif (protected &&\n\t    (type != NVRAM_PARTITION_TYPE_DYNCONFIG_DEFAULTS &&\n\t     type != NVRAM_PARTITION_TYPE_ROMCONFIG_DEFAULTS))\n\t\t \n\t\treturn -ENODEV;\n\n\tif (protected)\n\t\t \n\t\terase_size = 0;\n\n\t \n\tif (__test_and_set_bit(type_idx, found))\n\t\treturn -EEXIST;\n\n\tpart->nvram_type = type;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_METADATA_IN_TYPE, type);\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_METADATA, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_NVRAM_METADATA_OUT_LENMIN)\n\t\treturn -EIO;\n\tif (MCDI_DWORD(outbuf, NVRAM_METADATA_OUT_FLAGS) &\n\t    (1 << MC_CMD_NVRAM_METADATA_OUT_SUBTYPE_VALID_LBN))\n\t\tpart->fw_subtype = MCDI_DWORD(outbuf,\n\t\t\t\t\t      NVRAM_METADATA_OUT_SUBTYPE);\n\n\tpart->common.dev_type_name = \"EF10 NVRAM manager\";\n\tpart->common.type_name = info->name;\n\n\tpart->common.mtd.type = MTD_NORFLASH;\n\tpart->common.mtd.flags = MTD_CAP_NORFLASH;\n\tpart->common.mtd.size = size;\n\tpart->common.mtd.erasesize = erase_size;\n\t \n\tif (!erase_size)\n\t\tpart->common.mtd.flags |= MTD_NO_ERASE;\n\n\treturn 0;\n}\n\nstatic int efx_ef10_mtd_probe(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_PARTITIONS_OUT_LENMAX);\n\tDECLARE_BITMAP(found, EF10_NVRAM_PARTITION_COUNT) = { 0 };\n\tstruct efx_mcdi_mtd_partition *parts;\n\tsize_t outlen, n_parts_total, i, n_parts;\n\tunsigned int type;\n\tint rc;\n\n\tASSERT_RTNL();\n\n\tBUILD_BUG_ON(MC_CMD_NVRAM_PARTITIONS_IN_LEN != 0);\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_PARTITIONS, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_NVRAM_PARTITIONS_OUT_LENMIN)\n\t\treturn -EIO;\n\n\tn_parts_total = MCDI_DWORD(outbuf, NVRAM_PARTITIONS_OUT_NUM_PARTITIONS);\n\tif (n_parts_total >\n\t    MCDI_VAR_ARRAY_LEN(outlen, NVRAM_PARTITIONS_OUT_TYPE_ID))\n\t\treturn -EIO;\n\n\tparts = kcalloc(n_parts_total, sizeof(*parts), GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\tn_parts = 0;\n\tfor (i = 0; i < n_parts_total; i++) {\n\t\ttype = MCDI_ARRAY_DWORD(outbuf, NVRAM_PARTITIONS_OUT_TYPE_ID,\n\t\t\t\t\ti);\n\t\trc = efx_ef10_mtd_probe_partition(efx, &parts[n_parts], type,\n\t\t\t\t\t\t  found);\n\t\tif (rc == -EEXIST || rc == -ENODEV)\n\t\t\tcontinue;\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tn_parts++;\n\t}\n\n\tif (!n_parts) {\n\t\tkfree(parts);\n\t\treturn 0;\n\t}\n\n\trc = efx_mtd_add(efx, &parts[0].common, n_parts, sizeof(*parts));\nfail:\n\tif (rc)\n\t\tkfree(parts);\n\treturn rc;\n}\n\n#endif  \n\nstatic void efx_ef10_ptp_write_host_time(struct efx_nic *efx, u32 host_time)\n{\n\t_efx_writed(efx, cpu_to_le32(host_time), ER_DZ_MC_DB_LWRD);\n}\n\nstatic void efx_ef10_ptp_write_host_time_vf(struct efx_nic *efx,\n\t\t\t\t\t    u32 host_time) {}\n\nstatic int efx_ef10_rx_enable_timestamping(struct efx_channel *channel,\n\t\t\t\t\t   bool temp)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_TIME_EVENT_SUBSCRIBE_LEN);\n\tint rc;\n\n\tif (channel->sync_events_state == SYNC_EVENTS_REQUESTED ||\n\t    channel->sync_events_state == SYNC_EVENTS_VALID ||\n\t    (temp && channel->sync_events_state == SYNC_EVENTS_DISABLED))\n\t\treturn 0;\n\tchannel->sync_events_state = SYNC_EVENTS_REQUESTED;\n\n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_TIME_EVENT_SUBSCRIBE);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_TIME_EVENT_SUBSCRIBE_QUEUE,\n\t\t       channel->channel);\n\n\trc = efx_mcdi_rpc(channel->efx, MC_CMD_PTP,\n\t\t\t  inbuf, sizeof(inbuf), NULL, 0, NULL);\n\n\tif (rc != 0)\n\t\tchannel->sync_events_state = temp ? SYNC_EVENTS_QUIESCENT :\n\t\t\t\t\t\t    SYNC_EVENTS_DISABLED;\n\n\treturn rc;\n}\n\nstatic int efx_ef10_rx_disable_timestamping(struct efx_channel *channel,\n\t\t\t\t\t    bool temp)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_TIME_EVENT_UNSUBSCRIBE_LEN);\n\tint rc;\n\n\tif (channel->sync_events_state == SYNC_EVENTS_DISABLED ||\n\t    (temp && channel->sync_events_state == SYNC_EVENTS_QUIESCENT))\n\t\treturn 0;\n\tif (channel->sync_events_state == SYNC_EVENTS_QUIESCENT) {\n\t\tchannel->sync_events_state = SYNC_EVENTS_DISABLED;\n\t\treturn 0;\n\t}\n\tchannel->sync_events_state = temp ? SYNC_EVENTS_QUIESCENT :\n\t\t\t\t\t    SYNC_EVENTS_DISABLED;\n\n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_TIME_EVENT_UNSUBSCRIBE);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_TIME_EVENT_UNSUBSCRIBE_CONTROL,\n\t\t       MC_CMD_PTP_IN_TIME_EVENT_UNSUBSCRIBE_SINGLE);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_TIME_EVENT_UNSUBSCRIBE_QUEUE,\n\t\t       channel->channel);\n\n\trc = efx_mcdi_rpc(channel->efx, MC_CMD_PTP,\n\t\t\t  inbuf, sizeof(inbuf), NULL, 0, NULL);\n\n\treturn rc;\n}\n\nstatic int efx_ef10_ptp_set_ts_sync_events(struct efx_nic *efx, bool en,\n\t\t\t\t\t   bool temp)\n{\n\tint (*set)(struct efx_channel *channel, bool temp);\n\tstruct efx_channel *channel;\n\n\tset = en ?\n\t      efx_ef10_rx_enable_timestamping :\n\t      efx_ef10_rx_disable_timestamping;\n\n\tchannel = efx_ptp_channel(efx);\n\tif (channel) {\n\t\tint rc = set(channel, temp);\n\t\tif (en && rc != 0) {\n\t\t\tefx_ef10_ptp_set_ts_sync_events(efx, false, temp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int efx_ef10_ptp_set_ts_config_vf(struct efx_nic *efx,\n\t\t\t\t\t struct hwtstamp_config *init)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int efx_ef10_ptp_set_ts_config(struct efx_nic *efx,\n\t\t\t\t      struct hwtstamp_config *init)\n{\n\tint rc;\n\n\tswitch (init->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tefx_ef10_ptp_set_ts_sync_events(efx, false, false);\n\t\t \n\t\treturn efx_ptp_change_mode(efx,\n\t\t\t\t\t   init->tx_type != HWTSTAMP_TX_OFF, 0);\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\tinit->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\trc = efx_ptp_change_mode(efx, true, 0);\n\t\tif (!rc)\n\t\t\trc = efx_ef10_ptp_set_ts_sync_events(efx, true, false);\n\t\tif (rc)\n\t\t\tefx_ptp_change_mode(efx, false, 0);\n\t\treturn rc;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n}\n\nstatic int efx_ef10_get_phys_port_id(struct efx_nic *efx,\n\t\t\t\t     struct netdev_phys_item_id *ppid)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tif (!is_valid_ether_addr(nic_data->port_id))\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = ETH_ALEN;\n\tmemcpy(ppid->id, nic_data->port_id, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic int efx_ef10_vlan_rx_add_vid(struct efx_nic *efx, __be16 proto, u16 vid)\n{\n\tif (proto != htons(ETH_P_8021Q))\n\t\treturn -EINVAL;\n\n\treturn efx_ef10_add_vlan(efx, vid);\n}\n\nstatic int efx_ef10_vlan_rx_kill_vid(struct efx_nic *efx, __be16 proto, u16 vid)\n{\n\tif (proto != htons(ETH_P_8021Q))\n\t\treturn -EINVAL;\n\n\treturn efx_ef10_del_vlan(efx, vid);\n}\n\n \nstatic int efx_ef10_set_udp_tnl_ports(struct efx_nic *efx, bool unloading)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_LENMAX);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT_LEN);\n\tbool will_reset = false;\n\tsize_t num_entries = 0;\n\tsize_t inlen, outlen;\n\tsize_t i;\n\tint rc;\n\tefx_dword_t flags_and_num_entries;\n\n\tWARN_ON(!mutex_is_locked(&nic_data->udp_tunnels_lock));\n\n\tnic_data->udp_tunnels_dirty = false;\n\n\tif (!(nic_data->datapath_caps &\n\t    (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN))) {\n\t\tefx_device_attach_if_not_resetting(efx);\n\t\treturn 0;\n\t}\n\n\tBUILD_BUG_ON(ARRAY_SIZE(nic_data->udp_tunnels) >\n\t\t     MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_ENTRIES_MAXNUM);\n\n\tfor (i = 0; i < ARRAY_SIZE(nic_data->udp_tunnels); ++i) {\n\t\tif (nic_data->udp_tunnels[i].type !=\n\t\t    TUNNEL_ENCAP_UDP_PORT_ENTRY_INVALID) {\n\t\t\tefx_dword_t entry;\n\n\t\t\tEFX_POPULATE_DWORD_2(entry,\n\t\t\t\tTUNNEL_ENCAP_UDP_PORT_ENTRY_UDP_PORT,\n\t\t\t\t\tntohs(nic_data->udp_tunnels[i].port),\n\t\t\t\tTUNNEL_ENCAP_UDP_PORT_ENTRY_PROTOCOL,\n\t\t\t\t\tnic_data->udp_tunnels[i].type);\n\t\t\t*_MCDI_ARRAY_DWORD(inbuf,\n\t\t\t\tSET_TUNNEL_ENCAP_UDP_PORTS_IN_ENTRIES,\n\t\t\t\tnum_entries++) = entry;\n\t\t}\n\t}\n\n\tBUILD_BUG_ON((MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_NUM_ENTRIES_OFST -\n\t\t      MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_FLAGS_OFST) * 8 !=\n\t\t     EFX_WORD_1_LBN);\n\tBUILD_BUG_ON(MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_NUM_ENTRIES_LEN * 8 !=\n\t\t     EFX_WORD_1_WIDTH);\n\tEFX_POPULATE_DWORD_2(flags_and_num_entries,\n\t\t\t     MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_UNLOADING,\n\t\t\t\t!!unloading,\n\t\t\t     EFX_WORD_1, num_entries);\n\t*_MCDI_DWORD(inbuf, SET_TUNNEL_ENCAP_UDP_PORTS_IN_FLAGS) =\n\t\tflags_and_num_entries;\n\n\tinlen = MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_LEN(num_entries);\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS,\n\t\t\t\tinbuf, inlen, outbuf, sizeof(outbuf), &outlen);\n\tif (rc == -EIO) {\n\t\t \n\t\tnic_data->udp_tunnels_dirty = true;\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\t \n\t\tif (rc != -EPERM)\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"Unable to set UDP tunnel ports; rc=%d.\\n\", rc);\n\t} else if (MCDI_DWORD(outbuf, SET_TUNNEL_ENCAP_UDP_PORTS_OUT_FLAGS) &\n\t\t   (1 << MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT_RESETTING_LBN)) {\n\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t   \"Rebooting MC due to UDP tunnel port list change\\n\");\n\t\twill_reset = true;\n\t\tif (unloading)\n\t\t\t \n\t\t\tmsleep(100);\n\t}\n\tif (!will_reset && !unloading) {\n\t\t \n\t\tefx_device_attach_if_not_resetting(efx);\n\t}\n\n\treturn rc;\n}\n\nstatic int efx_ef10_udp_tnl_push_ports(struct efx_nic *efx)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tint rc = 0;\n\n\tmutex_lock(&nic_data->udp_tunnels_lock);\n\tif (nic_data->udp_tunnels_dirty) {\n\t\t \n\t\tefx_device_detach_sync(efx);\n\t\trc = efx_ef10_set_udp_tnl_ports(efx, false);\n\t}\n\tmutex_unlock(&nic_data->udp_tunnels_lock);\n\treturn rc;\n}\n\nstatic int efx_ef10_udp_tnl_set_port(struct net_device *dev,\n\t\t\t\t     unsigned int table, unsigned int entry,\n\t\t\t\t     struct udp_tunnel_info *ti)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(dev);\n\tstruct efx_ef10_nic_data *nic_data;\n\tint efx_tunnel_type, rc;\n\n\tif (ti->type == UDP_TUNNEL_TYPE_VXLAN)\n\t\tefx_tunnel_type = TUNNEL_ENCAP_UDP_PORT_ENTRY_VXLAN;\n\telse\n\t\tefx_tunnel_type = TUNNEL_ENCAP_UDP_PORT_ENTRY_GENEVE;\n\n\tnic_data = efx->nic_data;\n\tif (!(nic_data->datapath_caps &\n\t      (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN)))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&nic_data->udp_tunnels_lock);\n\t \n\tefx_device_detach_sync(efx);\n\tnic_data->udp_tunnels[entry].type = efx_tunnel_type;\n\tnic_data->udp_tunnels[entry].port = ti->port;\n\trc = efx_ef10_set_udp_tnl_ports(efx, false);\n\tmutex_unlock(&nic_data->udp_tunnels_lock);\n\n\treturn rc;\n}\n\n \nstatic bool efx_ef10_udp_tnl_has_port(struct efx_nic *efx, __be16 port)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tsize_t i;\n\n\tif (!(nic_data->datapath_caps &\n\t      (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN)))\n\t\treturn false;\n\n\tif (nic_data->udp_tunnels_dirty)\n\t\t \n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(nic_data->udp_tunnels); ++i)\n\t\tif (nic_data->udp_tunnels[i].type !=\n\t\t    TUNNEL_ENCAP_UDP_PORT_ENTRY_INVALID &&\n\t\t    nic_data->udp_tunnels[i].port == port)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int efx_ef10_udp_tnl_unset_port(struct net_device *dev,\n\t\t\t\t       unsigned int table, unsigned int entry,\n\t\t\t\t       struct udp_tunnel_info *ti)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(dev);\n\tstruct efx_ef10_nic_data *nic_data;\n\tint rc;\n\n\tnic_data = efx->nic_data;\n\n\tmutex_lock(&nic_data->udp_tunnels_lock);\n\t \n\tefx_device_detach_sync(efx);\n\tnic_data->udp_tunnels[entry].type = TUNNEL_ENCAP_UDP_PORT_ENTRY_INVALID;\n\tnic_data->udp_tunnels[entry].port = 0;\n\trc = efx_ef10_set_udp_tnl_ports(efx, false);\n\tmutex_unlock(&nic_data->udp_tunnels_lock);\n\n\treturn rc;\n}\n\nstatic const struct udp_tunnel_nic_info efx_ef10_udp_tunnels = {\n\t.set_port\t= efx_ef10_udp_tnl_set_port,\n\t.unset_port\t= efx_ef10_udp_tnl_unset_port,\n\t.flags          = UDP_TUNNEL_NIC_INFO_MAY_SLEEP,\n\t.tables         = {\n\t\t{\n\t\t\t.n_entries = 16,\n\t\t\t.tunnel_types = UDP_TUNNEL_TYPE_VXLAN |\n\t\t\t\t\tUDP_TUNNEL_TYPE_GENEVE,\n\t\t},\n\t},\n};\n\n \nstatic size_t efx_ef10_print_additional_fwver(struct efx_nic *efx, char *buf,\n\t\t\t\t\t      size_t len)\n{\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\treturn scnprintf(buf, len, \" rx%x tx%x\",\n\t\t\t nic_data->rx_dpcpu_fw_id,\n\t\t\t nic_data->tx_dpcpu_fw_id);\n}\n\nstatic unsigned int ef10_check_caps(const struct efx_nic *efx,\n\t\t\t\t    u8 flag,\n\t\t\t\t    u32 offset)\n{\n\tconst struct efx_ef10_nic_data *nic_data = efx->nic_data;\n\n\tswitch (offset) {\n\tcase(MC_CMD_GET_CAPABILITIES_V4_OUT_FLAGS1_OFST):\n\t\treturn nic_data->datapath_caps & BIT_ULL(flag);\n\tcase(MC_CMD_GET_CAPABILITIES_V4_OUT_FLAGS2_OFST):\n\t\treturn nic_data->datapath_caps2 & BIT_ULL(flag);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic unsigned int efx_ef10_recycle_ring_size(const struct efx_nic *efx)\n{\n\tunsigned int ret = EFX_RECYCLE_RING_SIZE_10G;\n\n\t \n\tswitch (efx->pci_dev->device & 0xfff) {\n\tcase 0x0903:\t \n\t\tbreak;\n\tcase 0x0923:\t \n\tcase 0x0a03:\t \n\t\tret *= 4;\n\t\tbreak;\n\tdefault:\t \n\t\tret *= 10;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC64))\n\t\tret *= 4;\n\n\treturn ret;\n}\n\n#define EF10_OFFLOAD_FEATURES\t\t\\\n\t(NETIF_F_IP_CSUM |\t\t\\\n\t NETIF_F_HW_VLAN_CTAG_FILTER |\t\\\n\t NETIF_F_IPV6_CSUM |\t\t\\\n\t NETIF_F_RXHASH |\t\t\\\n\t NETIF_F_NTUPLE |\t\t\\\n\t NETIF_F_SG |\t\t\t\\\n\t NETIF_F_RXCSUM |\t\t\\\n\t NETIF_F_RXALL)\n\nconst struct efx_nic_type efx_hunt_a0_vf_nic_type = {\n\t.is_vf = true,\n\t.mem_bar = efx_ef10_vf_mem_bar,\n\t.mem_map_size = efx_ef10_mem_map_size,\n\t.probe = efx_ef10_probe_vf,\n\t.remove = efx_ef10_remove,\n\t.dimension_resources = efx_ef10_dimension_resources,\n\t.init = efx_ef10_init_nic,\n\t.fini = efx_ef10_fini_nic,\n\t.map_reset_reason = efx_ef10_map_reset_reason,\n\t.map_reset_flags = efx_ef10_map_reset_flags,\n\t.reset = efx_ef10_reset,\n\t.probe_port = efx_mcdi_port_probe,\n\t.remove_port = efx_mcdi_port_remove,\n\t.fini_dmaq = efx_fini_dmaq,\n\t.prepare_flr = efx_ef10_prepare_flr,\n\t.finish_flr = efx_port_dummy_op_void,\n\t.describe_stats = efx_ef10_describe_stats,\n\t.update_stats = efx_ef10_update_stats_vf,\n\t.update_stats_atomic = efx_ef10_update_stats_atomic_vf,\n\t.start_stats = efx_port_dummy_op_void,\n\t.pull_stats = efx_port_dummy_op_void,\n\t.stop_stats = efx_port_dummy_op_void,\n\t.push_irq_moderation = efx_ef10_push_irq_moderation,\n\t.reconfigure_mac = efx_ef10_mac_reconfigure,\n\t.check_mac_fault = efx_mcdi_mac_check_fault,\n\t.reconfigure_port = efx_mcdi_port_reconfigure,\n\t.get_wol = efx_ef10_get_wol_vf,\n\t.set_wol = efx_ef10_set_wol_vf,\n\t.resume_wol = efx_port_dummy_op_void,\n\t.mcdi_request = efx_ef10_mcdi_request,\n\t.mcdi_poll_response = efx_ef10_mcdi_poll_response,\n\t.mcdi_read_response = efx_ef10_mcdi_read_response,\n\t.mcdi_poll_reboot = efx_ef10_mcdi_poll_reboot,\n\t.mcdi_reboot_detected = efx_ef10_mcdi_reboot_detected,\n\t.irq_enable_master = efx_port_dummy_op_void,\n\t.irq_test_generate = efx_ef10_irq_test_generate,\n\t.irq_disable_non_ev = efx_port_dummy_op_void,\n\t.irq_handle_msi = efx_ef10_msi_interrupt,\n\t.irq_handle_legacy = efx_ef10_legacy_interrupt,\n\t.tx_probe = efx_ef10_tx_probe,\n\t.tx_init = efx_ef10_tx_init,\n\t.tx_remove = efx_mcdi_tx_remove,\n\t.tx_write = efx_ef10_tx_write,\n\t.tx_limit_len = efx_ef10_tx_limit_len,\n\t.tx_enqueue = __efx_enqueue_skb,\n\t.rx_push_rss_config = efx_mcdi_vf_rx_push_rss_config,\n\t.rx_pull_rss_config = efx_mcdi_rx_pull_rss_config,\n\t.rx_probe = efx_mcdi_rx_probe,\n\t.rx_init = efx_mcdi_rx_init,\n\t.rx_remove = efx_mcdi_rx_remove,\n\t.rx_write = efx_ef10_rx_write,\n\t.rx_defer_refill = efx_ef10_rx_defer_refill,\n\t.rx_packet = __efx_rx_packet,\n\t.ev_probe = efx_mcdi_ev_probe,\n\t.ev_init = efx_ef10_ev_init,\n\t.ev_fini = efx_mcdi_ev_fini,\n\t.ev_remove = efx_mcdi_ev_remove,\n\t.ev_process = efx_ef10_ev_process,\n\t.ev_read_ack = efx_ef10_ev_read_ack,\n\t.ev_test_generate = efx_ef10_ev_test_generate,\n\t.filter_table_probe = efx_ef10_filter_table_probe,\n\t.filter_table_restore = efx_mcdi_filter_table_restore,\n\t.filter_table_remove = efx_ef10_filter_table_remove,\n\t.filter_update_rx_scatter = efx_mcdi_update_rx_scatter,\n\t.filter_insert = efx_mcdi_filter_insert,\n\t.filter_remove_safe = efx_mcdi_filter_remove_safe,\n\t.filter_get_safe = efx_mcdi_filter_get_safe,\n\t.filter_clear_rx = efx_mcdi_filter_clear_rx,\n\t.filter_count_rx_used = efx_mcdi_filter_count_rx_used,\n\t.filter_get_rx_id_limit = efx_mcdi_filter_get_rx_id_limit,\n\t.filter_get_rx_ids = efx_mcdi_filter_get_rx_ids,\n#ifdef CONFIG_RFS_ACCEL\n\t.filter_rfs_expire_one = efx_mcdi_filter_rfs_expire_one,\n#endif\n#ifdef CONFIG_SFC_MTD\n\t.mtd_probe = efx_port_dummy_op_int,\n#endif\n\t.ptp_write_host_time = efx_ef10_ptp_write_host_time_vf,\n\t.ptp_set_ts_config = efx_ef10_ptp_set_ts_config_vf,\n\t.vlan_rx_add_vid = efx_ef10_vlan_rx_add_vid,\n\t.vlan_rx_kill_vid = efx_ef10_vlan_rx_kill_vid,\n#ifdef CONFIG_SFC_SRIOV\n\t.vswitching_probe = efx_ef10_vswitching_probe_vf,\n\t.vswitching_restore = efx_ef10_vswitching_restore_vf,\n\t.vswitching_remove = efx_ef10_vswitching_remove_vf,\n#endif\n\t.get_mac_address = efx_ef10_get_mac_address_vf,\n\t.set_mac_address = efx_ef10_set_mac_address,\n\n\t.get_phys_port_id = efx_ef10_get_phys_port_id,\n\t.revision = EFX_REV_HUNT_A0,\n\t.max_dma_mask = DMA_BIT_MASK(ESF_DZ_TX_KER_BUF_ADDR_WIDTH),\n\t.rx_prefix_size = ES_DZ_RX_PREFIX_SIZE,\n\t.rx_hash_offset = ES_DZ_RX_PREFIX_HASH_OFST,\n\t.rx_ts_offset = ES_DZ_RX_PREFIX_TSTAMP_OFST,\n\t.can_rx_scatter = true,\n\t.always_rx_scatter = true,\n\t.min_interrupt_mode = EFX_INT_MODE_MSIX,\n\t.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,\n\t.offload_features = EF10_OFFLOAD_FEATURES,\n\t.mcdi_max_ver = 2,\n\t.max_rx_ip_filters = EFX_MCDI_FILTER_TBL_ROWS,\n\t.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |\n\t\t\t    1 << HWTSTAMP_FILTER_ALL,\n\t.rx_hash_key_size = 40,\n\t.check_caps = ef10_check_caps,\n\t.print_additional_fwver = efx_ef10_print_additional_fwver,\n\t.sensor_event = efx_mcdi_sensor_event,\n\t.rx_recycle_ring_size = efx_ef10_recycle_ring_size,\n};\n\nconst struct efx_nic_type efx_hunt_a0_nic_type = {\n\t.is_vf = false,\n\t.mem_bar = efx_ef10_pf_mem_bar,\n\t.mem_map_size = efx_ef10_mem_map_size,\n\t.probe = efx_ef10_probe_pf,\n\t.remove = efx_ef10_remove,\n\t.dimension_resources = efx_ef10_dimension_resources,\n\t.init = efx_ef10_init_nic,\n\t.fini = efx_ef10_fini_nic,\n\t.map_reset_reason = efx_ef10_map_reset_reason,\n\t.map_reset_flags = efx_ef10_map_reset_flags,\n\t.reset = efx_ef10_reset,\n\t.probe_port = efx_mcdi_port_probe,\n\t.remove_port = efx_mcdi_port_remove,\n\t.fini_dmaq = efx_fini_dmaq,\n\t.prepare_flr = efx_ef10_prepare_flr,\n\t.finish_flr = efx_port_dummy_op_void,\n\t.describe_stats = efx_ef10_describe_stats,\n\t.update_stats = efx_ef10_update_stats_pf,\n\t.start_stats = efx_mcdi_mac_start_stats,\n\t.pull_stats = efx_mcdi_mac_pull_stats,\n\t.stop_stats = efx_mcdi_mac_stop_stats,\n\t.push_irq_moderation = efx_ef10_push_irq_moderation,\n\t.reconfigure_mac = efx_ef10_mac_reconfigure,\n\t.check_mac_fault = efx_mcdi_mac_check_fault,\n\t.reconfigure_port = efx_mcdi_port_reconfigure,\n\t.get_wol = efx_ef10_get_wol,\n\t.set_wol = efx_ef10_set_wol,\n\t.resume_wol = efx_port_dummy_op_void,\n\t.get_fec_stats = efx_ef10_get_fec_stats,\n\t.test_chip = efx_ef10_test_chip,\n\t.test_nvram = efx_mcdi_nvram_test_all,\n\t.mcdi_request = efx_ef10_mcdi_request,\n\t.mcdi_poll_response = efx_ef10_mcdi_poll_response,\n\t.mcdi_read_response = efx_ef10_mcdi_read_response,\n\t.mcdi_poll_reboot = efx_ef10_mcdi_poll_reboot,\n\t.mcdi_reboot_detected = efx_ef10_mcdi_reboot_detected,\n\t.irq_enable_master = efx_port_dummy_op_void,\n\t.irq_test_generate = efx_ef10_irq_test_generate,\n\t.irq_disable_non_ev = efx_port_dummy_op_void,\n\t.irq_handle_msi = efx_ef10_msi_interrupt,\n\t.irq_handle_legacy = efx_ef10_legacy_interrupt,\n\t.tx_probe = efx_ef10_tx_probe,\n\t.tx_init = efx_ef10_tx_init,\n\t.tx_remove = efx_mcdi_tx_remove,\n\t.tx_write = efx_ef10_tx_write,\n\t.tx_limit_len = efx_ef10_tx_limit_len,\n\t.tx_enqueue = __efx_enqueue_skb,\n\t.rx_push_rss_config = efx_mcdi_pf_rx_push_rss_config,\n\t.rx_pull_rss_config = efx_mcdi_rx_pull_rss_config,\n\t.rx_push_rss_context_config = efx_mcdi_rx_push_rss_context_config,\n\t.rx_pull_rss_context_config = efx_mcdi_rx_pull_rss_context_config,\n\t.rx_restore_rss_contexts = efx_mcdi_rx_restore_rss_contexts,\n\t.rx_probe = efx_mcdi_rx_probe,\n\t.rx_init = efx_mcdi_rx_init,\n\t.rx_remove = efx_mcdi_rx_remove,\n\t.rx_write = efx_ef10_rx_write,\n\t.rx_defer_refill = efx_ef10_rx_defer_refill,\n\t.rx_packet = __efx_rx_packet,\n\t.ev_probe = efx_mcdi_ev_probe,\n\t.ev_init = efx_ef10_ev_init,\n\t.ev_fini = efx_mcdi_ev_fini,\n\t.ev_remove = efx_mcdi_ev_remove,\n\t.ev_process = efx_ef10_ev_process,\n\t.ev_read_ack = efx_ef10_ev_read_ack,\n\t.ev_test_generate = efx_ef10_ev_test_generate,\n\t.filter_table_probe = efx_ef10_filter_table_probe,\n\t.filter_table_restore = efx_mcdi_filter_table_restore,\n\t.filter_table_remove = efx_ef10_filter_table_remove,\n\t.filter_update_rx_scatter = efx_mcdi_update_rx_scatter,\n\t.filter_insert = efx_mcdi_filter_insert,\n\t.filter_remove_safe = efx_mcdi_filter_remove_safe,\n\t.filter_get_safe = efx_mcdi_filter_get_safe,\n\t.filter_clear_rx = efx_mcdi_filter_clear_rx,\n\t.filter_count_rx_used = efx_mcdi_filter_count_rx_used,\n\t.filter_get_rx_id_limit = efx_mcdi_filter_get_rx_id_limit,\n\t.filter_get_rx_ids = efx_mcdi_filter_get_rx_ids,\n#ifdef CONFIG_RFS_ACCEL\n\t.filter_rfs_expire_one = efx_mcdi_filter_rfs_expire_one,\n#endif\n#ifdef CONFIG_SFC_MTD\n\t.mtd_probe = efx_ef10_mtd_probe,\n\t.mtd_rename = efx_mcdi_mtd_rename,\n\t.mtd_read = efx_mcdi_mtd_read,\n\t.mtd_erase = efx_mcdi_mtd_erase,\n\t.mtd_write = efx_mcdi_mtd_write,\n\t.mtd_sync = efx_mcdi_mtd_sync,\n#endif\n\t.ptp_write_host_time = efx_ef10_ptp_write_host_time,\n\t.ptp_set_ts_sync_events = efx_ef10_ptp_set_ts_sync_events,\n\t.ptp_set_ts_config = efx_ef10_ptp_set_ts_config,\n\t.vlan_rx_add_vid = efx_ef10_vlan_rx_add_vid,\n\t.vlan_rx_kill_vid = efx_ef10_vlan_rx_kill_vid,\n\t.udp_tnl_push_ports = efx_ef10_udp_tnl_push_ports,\n\t.udp_tnl_has_port = efx_ef10_udp_tnl_has_port,\n#ifdef CONFIG_SFC_SRIOV\n\t.sriov_configure = efx_ef10_sriov_configure,\n\t.sriov_init = efx_ef10_sriov_init,\n\t.sriov_fini = efx_ef10_sriov_fini,\n\t.sriov_wanted = efx_ef10_sriov_wanted,\n\t.sriov_set_vf_mac = efx_ef10_sriov_set_vf_mac,\n\t.sriov_set_vf_vlan = efx_ef10_sriov_set_vf_vlan,\n\t.sriov_set_vf_spoofchk = efx_ef10_sriov_set_vf_spoofchk,\n\t.sriov_get_vf_config = efx_ef10_sriov_get_vf_config,\n\t.sriov_set_vf_link_state = efx_ef10_sriov_set_vf_link_state,\n\t.vswitching_probe = efx_ef10_vswitching_probe_pf,\n\t.vswitching_restore = efx_ef10_vswitching_restore_pf,\n\t.vswitching_remove = efx_ef10_vswitching_remove_pf,\n#endif\n\t.get_mac_address = efx_ef10_get_mac_address_pf,\n\t.set_mac_address = efx_ef10_set_mac_address,\n\t.tso_versions = efx_ef10_tso_versions,\n\n\t.get_phys_port_id = efx_ef10_get_phys_port_id,\n\t.revision = EFX_REV_HUNT_A0,\n\t.max_dma_mask = DMA_BIT_MASK(ESF_DZ_TX_KER_BUF_ADDR_WIDTH),\n\t.rx_prefix_size = ES_DZ_RX_PREFIX_SIZE,\n\t.rx_hash_offset = ES_DZ_RX_PREFIX_HASH_OFST,\n\t.rx_ts_offset = ES_DZ_RX_PREFIX_TSTAMP_OFST,\n\t.can_rx_scatter = true,\n\t.always_rx_scatter = true,\n\t.option_descriptors = true,\n\t.min_interrupt_mode = EFX_INT_MODE_LEGACY,\n\t.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,\n\t.offload_features = EF10_OFFLOAD_FEATURES,\n\t.mcdi_max_ver = 2,\n\t.max_rx_ip_filters = EFX_MCDI_FILTER_TBL_ROWS,\n\t.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |\n\t\t\t    1 << HWTSTAMP_FILTER_ALL,\n\t.rx_hash_key_size = 40,\n\t.check_caps = ef10_check_caps,\n\t.print_additional_fwver = efx_ef10_print_additional_fwver,\n\t.sensor_event = efx_mcdi_sensor_event,\n\t.rx_recycle_ring_size = efx_ef10_recycle_ring_size,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}