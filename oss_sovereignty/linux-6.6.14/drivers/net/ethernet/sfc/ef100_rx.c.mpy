{
  "module_name": "ef100_rx.c",
  "hash_id": "994af3adcd1adc8a48451c715a3b440f9e5be40f5f68c6d7eada4a283b7441d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef100_rx.c",
  "human_readable_source": "\n \n\n#include \"net_driver.h\"\n#include \"ef100_rx.h\"\n#include \"rx_common.h\"\n#include \"efx.h\"\n#include \"nic_common.h\"\n#include \"mcdi_functions.h\"\n#include \"ef100_regs.h\"\n#include \"ef100_nic.h\"\n#include \"io.h\"\n\n \n#define PREFIX_OFFSET_W(_f)\t(ESF_GZ_RX_PREFIX_ ## _f ## _LBN / 32)\n#define PREFIX_OFFSET_B(_f)\t(ESF_GZ_RX_PREFIX_ ## _f ## _LBN % 32)\n#define PREFIX_WIDTH_MASK(_f)\t((1ULL << ESF_GZ_RX_PREFIX_ ## _f ## _WIDTH) - 1)\n#define PREFIX_WORD(_p, _f)\tle32_to_cpu((__force __le32)(_p)[PREFIX_OFFSET_W(_f)])\n#define PREFIX_FIELD(_p, _f)\t((PREFIX_WORD(_p, _f) >> PREFIX_OFFSET_B(_f)) & \\\n\t\t\t\t PREFIX_WIDTH_MASK(_f))\n\n#define ESF_GZ_RX_PREFIX_NT_OR_INNER_L3_CLASS_LBN\t\\\n\t\t(ESF_GZ_RX_PREFIX_CLASS_LBN + ESF_GZ_RX_PREFIX_HCLASS_NT_OR_INNER_L3_CLASS_LBN)\n#define ESF_GZ_RX_PREFIX_NT_OR_INNER_L3_CLASS_WIDTH\t\\\n\t\tESF_GZ_RX_PREFIX_HCLASS_NT_OR_INNER_L3_CLASS_WIDTH\n\nbool ef100_rx_buf_hash_valid(const u8 *prefix)\n{\n\treturn PREFIX_FIELD(prefix, RSS_HASH_VALID);\n}\n\nstatic bool ef100_has_fcs_error(struct efx_channel *channel, u32 *prefix)\n{\n\tu16 rxclass;\n\tu8 l2status;\n\n\trxclass = le16_to_cpu((__force __le16)PREFIX_FIELD(prefix, CLASS));\n\tl2status = PREFIX_FIELD(&rxclass, HCLASS_L2_STATUS);\n\n\tif (likely(l2status == ESE_GZ_RH_HCLASS_L2_STATUS_OK))\n\t\t \n\t\treturn false;\n\n\tif (l2status == ESE_GZ_RH_HCLASS_L2_STATUS_FCS_ERR)\n\t\tchannel->n_rx_eth_crc_err++;\n\treturn true;\n}\n\nvoid __ef100_rx_packet(struct efx_channel *channel)\n{\n\tstruct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);\n\tstruct efx_rx_buffer *rx_buf = efx_rx_buffer(rx_queue,\n\t\t\t\t\t\t     channel->rx_pkt_index);\n\tstruct efx_nic *efx = channel->efx;\n\tstruct ef100_nic_data *nic_data;\n\tu8 *eh = efx_rx_buf_va(rx_buf);\n\t__wsum csum = 0;\n\tu16 ing_port;\n\tu32 *prefix;\n\n\tprefix = (u32 *)(eh - ESE_GZ_RX_PKT_PREFIX_LEN);\n\n\tif (channel->type->receive_raw) {\n\t\tu32 mark = PREFIX_FIELD(prefix, USER_MARK);\n\n\t\tif (channel->type->receive_raw(rx_queue, mark))\n\t\t\treturn;  \n\t}\n\n\tif (ef100_has_fcs_error(channel, prefix) &&\n\t    unlikely(!(efx->net_dev->features & NETIF_F_RXALL)))\n\t\tgoto out;\n\n\trx_buf->len = le16_to_cpu((__force __le16)PREFIX_FIELD(prefix, LENGTH));\n\tif (rx_buf->len <= sizeof(struct ethhdr)) {\n\t\tif (net_ratelimit())\n\t\t\tnetif_err(channel->efx, rx_err, channel->efx->net_dev,\n\t\t\t\t  \"RX packet too small (%d)\\n\", rx_buf->len);\n\t\t++channel->n_rx_frm_trunc;\n\t\tgoto out;\n\t}\n\n\ting_port = le16_to_cpu((__force __le16) PREFIX_FIELD(prefix, INGRESS_MPORT));\n\n\tnic_data = efx->nic_data;\n\n\tif (nic_data->have_mport && ing_port != nic_data->base_mport) {\n#ifdef CONFIG_SFC_SRIOV\n\t\tstruct efx_rep *efv;\n\n\t\trcu_read_lock();\n\t\tefv = efx_ef100_find_rep_by_mport(efx, ing_port);\n\t\tif (efv) {\n\t\t\tif (efv->net_dev->flags & IFF_UP)\n\t\t\t\tefx_ef100_rep_rx_packet(efv, rx_buf);\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\tgoto free_rx_buffer;\n\t\t}\n\t\trcu_read_unlock();\n#endif\n\t\tif (net_ratelimit())\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"Unrecognised ing_port %04x (base %04x), dropping\\n\",\n\t\t\t\t   ing_port, nic_data->base_mport);\n\t\tchannel->n_rx_mport_bad++;\n\t\tgoto free_rx_buffer;\n\t}\n\n\tif (likely(efx->net_dev->features & NETIF_F_RXCSUM)) {\n\t\tif (PREFIX_FIELD(prefix, NT_OR_INNER_L3_CLASS) == 1) {\n\t\t\t++channel->n_rx_ip_hdr_chksum_err;\n\t\t} else {\n\t\t\tu16 sum = be16_to_cpu((__force __be16)PREFIX_FIELD(prefix, CSUM_FRAME));\n\n\t\t\tcsum = (__force __wsum) sum;\n\t\t}\n\t}\n\n\tif (channel->type->receive_skb) {\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tgoto free_rx_buffer;\n\t}\n\n\tefx_rx_packet_gro(channel, rx_buf, channel->rx_pkt_n_frags, eh, csum);\n\tgoto out;\n\nfree_rx_buffer:\n\tefx_free_rx_buffers(rx_queue, rx_buf, 1);\nout:\n\tchannel->rx_pkt_n_frags = 0;\n}\n\nstatic void ef100_rx_packet(struct efx_rx_queue *rx_queue, unsigned int index)\n{\n\tstruct efx_rx_buffer *rx_buf = efx_rx_buffer(rx_queue, index);\n\tstruct efx_channel *channel = efx_rx_queue_channel(rx_queue);\n\tstruct efx_nic *efx = rx_queue->efx;\n\n\t++rx_queue->rx_packets;\n\n\tnetif_vdbg(efx, rx_status, efx->net_dev,\n\t\t   \"RX queue %d received id %x\\n\",\n\t\t   efx_rx_queue_index(rx_queue), index);\n\n\tefx_sync_rx_buffer(efx, rx_buf, efx->rx_dma_len);\n\n\tprefetch(efx_rx_buf_va(rx_buf));\n\n\trx_buf->page_offset += efx->rx_prefix_size;\n\n\tefx_recycle_rx_pages(channel, rx_buf, 1);\n\n\tefx_rx_flush_packet(channel);\n\tchannel->rx_pkt_n_frags = 1;\n\tchannel->rx_pkt_index = index;\n}\n\nvoid efx_ef100_ev_rx(struct efx_channel *channel, const efx_qword_t *p_event)\n{\n\tstruct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);\n\tunsigned int n_packets =\n\t\tEFX_QWORD_FIELD(*p_event, ESF_GZ_EV_RXPKTS_NUM_PKT);\n\tint i;\n\n\tWARN_ON_ONCE(!n_packets);\n\tif (n_packets > 1)\n\t\t++channel->n_rx_merge_events;\n\n\tchannel->irq_mod_score += 2 * n_packets;\n\n\tfor (i = 0; i < n_packets; ++i) {\n\t\tef100_rx_packet(rx_queue,\n\t\t\t\trx_queue->removed_count & rx_queue->ptr_mask);\n\t\t++rx_queue->removed_count;\n\t}\n}\n\nvoid ef100_rx_write(struct efx_rx_queue *rx_queue)\n{\n\tunsigned int notified_count = rx_queue->notified_count;\n\tstruct efx_rx_buffer *rx_buf;\n\tunsigned int idx;\n\tefx_qword_t *rxd;\n\tefx_dword_t rxdb;\n\n\twhile (notified_count != rx_queue->added_count) {\n\t\tidx = notified_count & rx_queue->ptr_mask;\n\t\trx_buf = efx_rx_buffer(rx_queue, idx);\n\t\trxd = efx_rx_desc(rx_queue, idx);\n\n\t\tEFX_POPULATE_QWORD_1(*rxd, ESF_GZ_RX_BUF_ADDR, rx_buf->dma_addr);\n\n\t\t++notified_count;\n\t}\n\tif (notified_count == rx_queue->notified_count)\n\t\treturn;\n\n\twmb();\n\tEFX_POPULATE_DWORD_1(rxdb, ERF_GZ_RX_RING_PIDX,\n\t\t\t     rx_queue->added_count & rx_queue->ptr_mask);\n\tefx_writed_page(rx_queue->efx, &rxdb,\n\t\t\tER_GZ_RX_RING_DOORBELL, efx_rx_queue_index(rx_queue));\n\tif (rx_queue->grant_credits)\n\t\twmb();\n\trx_queue->notified_count = notified_count;\n\tif (rx_queue->grant_credits)\n\t\tschedule_work(&rx_queue->grant_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}