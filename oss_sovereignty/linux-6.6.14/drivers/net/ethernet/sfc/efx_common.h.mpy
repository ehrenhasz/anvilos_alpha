{
  "module_name": "efx_common.h",
  "hash_id": "0c1ebe6b02cff772561131924ccd70678257a47cf574360db45730b489601e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/efx_common.h",
  "human_readable_source": " \n \n\n#ifndef EFX_COMMON_H\n#define EFX_COMMON_H\n\nint efx_init_io(struct efx_nic *efx, int bar, dma_addr_t dma_mask,\n\t\tunsigned int mem_map_size);\nvoid efx_fini_io(struct efx_nic *efx);\nint efx_init_struct(struct efx_nic *efx, struct pci_dev *pci_dev);\nvoid efx_fini_struct(struct efx_nic *efx);\n\n#define EFX_MAX_DMAQ_SIZE 4096UL\n#define EFX_DEFAULT_DMAQ_SIZE 1024UL\n#define EFX_MIN_DMAQ_SIZE 512UL\n\n#define EFX_MAX_EVQ_SIZE 16384UL\n#define EFX_MIN_EVQ_SIZE 512UL\n\nvoid efx_link_clear_advertising(struct efx_nic *efx);\nvoid efx_link_set_wanted_fc(struct efx_nic *efx, u8);\n\nvoid efx_start_all(struct efx_nic *efx);\nvoid efx_stop_all(struct efx_nic *efx);\n\nvoid efx_net_stats(struct net_device *net_dev, struct rtnl_link_stats64 *stats);\n\nint efx_create_reset_workqueue(void);\nvoid efx_queue_reset_work(struct efx_nic *efx);\nvoid efx_flush_reset_workqueue(struct efx_nic *efx);\nvoid efx_destroy_reset_workqueue(void);\n\nvoid efx_start_monitor(struct efx_nic *efx);\n\nint __efx_reconfigure_port(struct efx_nic *efx);\nint efx_reconfigure_port(struct efx_nic *efx);\n\n#define EFX_ASSERT_RESET_SERIALISED(efx)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((efx)->state != STATE_UNINIT &&\t\t\t\\\n\t\t    (efx)->state != STATE_PROBED)\t\t\t\\\n\t\t\tASSERT_RTNL();\t\t\t\t\t\\\n\t} while (0)\n\nint efx_try_recovery(struct efx_nic *efx);\nvoid efx_reset_down(struct efx_nic *efx, enum reset_type method);\nvoid efx_watchdog(struct net_device *net_dev, unsigned int txqueue);\nint efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok);\nint efx_reset(struct efx_nic *efx, enum reset_type method);\nvoid efx_schedule_reset(struct efx_nic *efx, enum reset_type type);\n\n \nint efx_port_dummy_op_int(struct efx_nic *efx);\nvoid efx_port_dummy_op_void(struct efx_nic *efx);\n\nstatic inline int efx_check_disabled(struct efx_nic *efx)\n{\n\tif (efx->state == STATE_DISABLED || efx_recovering(efx->state)) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"device is disabled due to earlier errors\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic inline void efx_schedule_channel(struct efx_channel *channel)\n{\n\tnetif_vdbg(channel->efx, intr, channel->efx->net_dev,\n\t\t   \"channel %d scheduling NAPI poll on CPU%d\\n\",\n\t\t   channel->channel, raw_smp_processor_id());\n\n\tnapi_schedule(&channel->napi_str);\n}\n\nstatic inline void efx_schedule_channel_irq(struct efx_channel *channel)\n{\n\tchannel->event_test_cpu = raw_smp_processor_id();\n\tefx_schedule_channel(channel);\n}\n\n#ifdef CONFIG_SFC_MCDI_LOGGING\nvoid efx_init_mcdi_logging(struct efx_nic *efx);\nvoid efx_fini_mcdi_logging(struct efx_nic *efx);\n#else\nstatic inline void efx_init_mcdi_logging(struct efx_nic *efx) {}\nstatic inline void efx_fini_mcdi_logging(struct efx_nic *efx) {}\n#endif\n\nvoid efx_mac_reconfigure(struct efx_nic *efx, bool mtu_only);\nint efx_set_mac_address(struct net_device *net_dev, void *data);\nvoid efx_set_rx_mode(struct net_device *net_dev);\nint efx_set_features(struct net_device *net_dev, netdev_features_t data);\nvoid efx_link_status_changed(struct efx_nic *efx);\nunsigned int efx_xdp_max_mtu(struct efx_nic *efx);\nint efx_change_mtu(struct net_device *net_dev, int new_mtu);\n\nextern const struct pci_error_handlers efx_err_handlers;\n\nnetdev_features_t efx_features_check(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t     netdev_features_t features);\n\nint efx_get_phys_port_id(struct net_device *net_dev,\n\t\t\t struct netdev_phys_item_id *ppid);\n\nint efx_get_phys_port_name(struct net_device *net_dev,\n\t\t\t   char *name, size_t len);\n\nvoid efx_detach_reps(struct efx_nic *efx);\nvoid efx_attach_reps(struct efx_nic *efx);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}