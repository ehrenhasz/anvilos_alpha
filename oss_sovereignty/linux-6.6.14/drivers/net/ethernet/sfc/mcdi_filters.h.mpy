{
  "module_name": "mcdi_filters.h",
  "hash_id": "fb6e3a18eb0a4edc271326154ab221b53ee81ff30d2b9b11db9131ee58c56b03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/mcdi_filters.h",
  "human_readable_source": " \n \n#ifndef EFX_MCDI_FILTERS_H\n#define EFX_MCDI_FILTERS_H\n\n#include \"net_driver.h\"\n#include \"filter.h\"\n#include \"mcdi_pcol.h\"\n\n#define EFX_EF10_FILTER_DEV_UC_MAX\t32\n#define EFX_EF10_FILTER_DEV_MC_MAX\t256\n\nenum efx_mcdi_filter_default_filters {\n\tEFX_EF10_BCAST,\n\tEFX_EF10_UCDEF,\n\tEFX_EF10_MCDEF,\n\tEFX_EF10_VXLAN4_UCDEF,\n\tEFX_EF10_VXLAN4_MCDEF,\n\tEFX_EF10_VXLAN6_UCDEF,\n\tEFX_EF10_VXLAN6_MCDEF,\n\tEFX_EF10_NVGRE4_UCDEF,\n\tEFX_EF10_NVGRE4_MCDEF,\n\tEFX_EF10_NVGRE6_UCDEF,\n\tEFX_EF10_NVGRE6_MCDEF,\n\tEFX_EF10_GENEVE4_UCDEF,\n\tEFX_EF10_GENEVE4_MCDEF,\n\tEFX_EF10_GENEVE6_UCDEF,\n\tEFX_EF10_GENEVE6_MCDEF,\n\n\tEFX_EF10_NUM_DEFAULT_FILTERS\n};\n\n \nstruct efx_mcdi_filter_vlan {\n\tstruct list_head list;\n\tu16 vid;\n\tu16 uc[EFX_EF10_FILTER_DEV_UC_MAX];\n\tu16 mc[EFX_EF10_FILTER_DEV_MC_MAX];\n\tu16 default_filters[EFX_EF10_NUM_DEFAULT_FILTERS];\n};\n\nstruct efx_mcdi_dev_addr {\n\tu8 addr[ETH_ALEN];\n};\n\nstruct efx_mcdi_filter_table {\n \n\tu32 rx_match_mcdi_flags[\n\t\tMC_CMD_GET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES_MAXNUM * 2];\n\tunsigned int rx_match_count;\n\t \n\tbool rx_rss_context_exclusive;\n\n\tstruct rw_semaphore lock;  \n\tstruct {\n\t\tunsigned long spec;\t \n \n \n#define EFX_EF10_FILTER_FLAG_AUTO_OLD\t2UL\n#define EFX_EF10_FILTER_FLAGS\t\t3UL\n\t\tu64 handle;\t\t \n\t} *entry;\n \n\tstruct efx_mcdi_dev_addr dev_uc_list[EFX_EF10_FILTER_DEV_UC_MAX];\n\tstruct efx_mcdi_dev_addr dev_mc_list[EFX_EF10_FILTER_DEV_MC_MAX];\n\tint dev_uc_count;\n\tint dev_mc_count;\n\tbool uc_promisc;\n\tbool mc_promisc;\n \n\tbool mc_promisc_last;\n\tbool mc_overflow;  \n\t \n\tbool must_restore_rss_contexts;\n\t \n\tbool must_restore_filters;\n\t \n\tbool mc_chaining;\n\tbool vlan_filter;\n\t \n\tstruct list_head vlan_list;\n};\n\nint efx_mcdi_filter_table_probe(struct efx_nic *efx, bool multicast_chaining);\nvoid efx_mcdi_filter_table_down(struct efx_nic *efx);\nvoid efx_mcdi_filter_table_remove(struct efx_nic *efx);\nvoid efx_mcdi_filter_table_restore(struct efx_nic *efx);\n\nvoid efx_mcdi_filter_table_reset_mc_allocations(struct efx_nic *efx);\n\n \n#define EFX_MCDI_FILTER_TBL_ROWS 8192\n\nbool efx_mcdi_filter_match_supported(struct efx_mcdi_filter_table *table,\n\t\t\t\t     bool encap,\n\t\t\t\t     enum efx_filter_match_flags match_flags);\n\nvoid efx_mcdi_filter_sync_rx_mode(struct efx_nic *efx);\ns32 efx_mcdi_filter_insert(struct efx_nic *efx, struct efx_filter_spec *spec,\n\t\t\t   bool replace_equal);\nint efx_mcdi_filter_remove_safe(struct efx_nic *efx,\n\t\t\t\tenum efx_filter_priority priority,\n\t\t\t\tu32 filter_id);\nint efx_mcdi_filter_get_safe(struct efx_nic *efx,\n\t\t\t     enum efx_filter_priority priority,\n\t\t\t     u32 filter_id, struct efx_filter_spec *spec);\n\nu32 efx_mcdi_filter_count_rx_used(struct efx_nic *efx,\n\t\t\t\t  enum efx_filter_priority priority);\nint efx_mcdi_filter_clear_rx(struct efx_nic *efx,\n\t\t\t     enum efx_filter_priority priority);\nu32 efx_mcdi_filter_get_rx_id_limit(struct efx_nic *efx);\ns32 efx_mcdi_filter_get_rx_ids(struct efx_nic *efx,\n\t\t\t       enum efx_filter_priority priority,\n\t\t\t       u32 *buf, u32 size);\n\nvoid efx_mcdi_filter_cleanup_vlans(struct efx_nic *efx);\nint efx_mcdi_filter_add_vlan(struct efx_nic *efx, u16 vid);\nstruct efx_mcdi_filter_vlan *efx_mcdi_filter_find_vlan(struct efx_nic *efx, u16 vid);\nvoid efx_mcdi_filter_del_vlan(struct efx_nic *efx, u16 vid);\n\nvoid efx_mcdi_rx_free_indir_table(struct efx_nic *efx);\nint efx_mcdi_rx_push_rss_context_config(struct efx_nic *efx,\n\t\t\t\t\tstruct efx_rss_context *ctx,\n\t\t\t\t\tconst u32 *rx_indir_table,\n\t\t\t\t\tconst u8 *key);\nint efx_mcdi_pf_rx_push_rss_config(struct efx_nic *efx, bool user,\n\t\t\t\t   const u32 *rx_indir_table,\n\t\t\t\t   const u8 *key);\nint efx_mcdi_vf_rx_push_rss_config(struct efx_nic *efx, bool user,\n\t\t\t\t   const u32 *rx_indir_table\n\t\t\t\t   __attribute__ ((unused)),\n\t\t\t\t   const u8 *key\n\t\t\t\t   __attribute__ ((unused)));\nint efx_mcdi_push_default_indir_table(struct efx_nic *efx,\n\t\t\t\t      unsigned int rss_spread);\nint efx_mcdi_rx_pull_rss_config(struct efx_nic *efx);\nint efx_mcdi_rx_pull_rss_context_config(struct efx_nic *efx,\n\t\t\t\t\tstruct efx_rss_context *ctx);\nint efx_mcdi_get_rss_context_flags(struct efx_nic *efx, u32 context,\n\t\t\t\t   u32 *flags);\nvoid efx_mcdi_set_rss_context_flags(struct efx_nic *efx,\n\t\t\t\t    struct efx_rss_context *ctx);\nvoid efx_mcdi_rx_restore_rss_contexts(struct efx_nic *efx);\n\nstatic inline void efx_mcdi_update_rx_scatter(struct efx_nic *efx)\n{\n\t \n}\n\nbool efx_mcdi_filter_rfs_expire_one(struct efx_nic *efx, u32 flow_id,\n\t\t\t\t    unsigned int filter_idx);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}