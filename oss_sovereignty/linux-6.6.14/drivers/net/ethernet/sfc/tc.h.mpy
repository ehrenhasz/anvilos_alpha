{
  "module_name": "tc.h",
  "hash_id": "b946ffb2bd678a3faf248237e524a6e8e3529afb7e28ce3dc807451799d5d496",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/tc.h",
  "human_readable_source": " \n \n\n#ifndef EFX_TC_H\n#define EFX_TC_H\n#include <net/flow_offload.h>\n#include <linux/rhashtable.h>\n#include \"net_driver.h\"\n#include \"tc_counters.h\"\n\n#define IS_ALL_ONES(v)\t(!(typeof (v))~(v))\n\n \nstruct efx_tc_mac_pedit_action {\n\tu8 h_addr[ETH_ALEN];\n\tstruct rhash_head linkage;\n\trefcount_t ref;\n\tu32 fw_id;  \n};\n\nstatic inline bool efx_ipv6_addr_all_ones(struct in6_addr *addr)\n{\n\treturn !memchr_inv(addr, 0xff, sizeof(*addr));\n}\n\nstruct efx_tc_encap_action;  \n\n \nstruct efx_tc_action_set {\n\tu16 vlan_push:2;\n\tu16 vlan_pop:2;\n\tu16 decap:1;\n\tu16 do_ttl_dec:1;\n\tu16 deliver:1;\n\t__be16 vlan_tci[2];\n\t__be16 vlan_proto[2];\n\tstruct efx_tc_counter_index *count;\n\tstruct efx_tc_encap_action *encap_md;\n\tstruct list_head encap_user;\n\tstruct efx_tc_action_set_list *user;\n\tstruct list_head count_user;\n\tu32 dest_mport;\n\tstruct efx_tc_mac_pedit_action *src_mac;\n\tstruct efx_tc_mac_pedit_action *dst_mac;\n\tu32 fw_id;\n\tstruct list_head list;\n};\n\nstruct efx_tc_match_fields {\n\t \n\tu32 ingress_port;\n\tu8 recirc_id;  \n\t \n\t__be16 eth_proto;\n\t__be16 vlan_tci[2], vlan_proto[2];\n\tu8 eth_saddr[ETH_ALEN], eth_daddr[ETH_ALEN];\n\t \n\tu8 ip_proto, ip_tos, ip_ttl;\n\t__be32 src_ip, dst_ip;\n#ifdef CONFIG_IPV6\n\tstruct in6_addr src_ip6, dst_ip6;\n#endif\n\tbool ip_frag, ip_firstfrag;\n\t \n\t__be16 l4_sport, l4_dport;  \n\t__be16 tcp_flags;\n\tbool tcp_syn_fin_rst;  \n\t \n\t__be32 enc_src_ip, enc_dst_ip;\n\tstruct in6_addr enc_src_ip6, enc_dst_ip6;\n\tu8 enc_ip_tos, enc_ip_ttl;\n\t__be16 enc_sport, enc_dport;\n\t__be32 enc_keyid;  \n\t \n\tu16 ct_state_trk:1, ct_state_est:1;\n\tu32 ct_mark;\n\tu16 ct_zone;\n};\n\nstatic inline bool efx_tc_match_is_encap(const struct efx_tc_match_fields *mask)\n{\n\treturn mask->enc_src_ip || mask->enc_dst_ip ||\n\t       !ipv6_addr_any(&mask->enc_src_ip6) ||\n\t       !ipv6_addr_any(&mask->enc_dst_ip6) || mask->enc_ip_tos ||\n\t       mask->enc_ip_ttl || mask->enc_sport || mask->enc_dport;\n}\n\n \nenum efx_tc_em_pseudo_type {\n\tEFX_TC_EM_DIRECT,\n\tEFX_TC_EM_PSEUDO_MASK,\n};\n\nstruct efx_tc_encap_match {\n\t__be32 src_ip, dst_ip;\n\tstruct in6_addr src_ip6, dst_ip6;\n\t__be16 udp_dport;\n\t__be16 udp_sport, udp_sport_mask;\n\tu8 ip_tos, ip_tos_mask;\n\tstruct rhash_head linkage;\n\tenum efx_encap_type tun_type;\n\tu8 child_ip_tos_mask;\n\t__be16 child_udp_sport_mask;\n\trefcount_t ref;\n\tenum efx_tc_em_pseudo_type type;\n\tu32 fw_id;  \n\tstruct efx_tc_encap_match *pseudo;  \n};\n\nstruct efx_tc_recirc_id {\n\tu32 chain_index;\n\tstruct net_device *net_dev;\n\tstruct rhash_head linkage;\n\trefcount_t ref;\n\tu8 fw_id;  \n};\n\nstruct efx_tc_match {\n\tstruct efx_tc_match_fields value;\n\tstruct efx_tc_match_fields mask;\n\tstruct efx_tc_encap_match *encap;\n\tstruct efx_tc_recirc_id *rid;\n};\n\nstruct efx_tc_action_set_list {\n\tstruct list_head list;\n\tu32 fw_id;\n};\n\nstruct efx_tc_lhs_action {\n\tstruct efx_tc_recirc_id *rid;\n\tstruct efx_tc_ct_zone *zone;\n\tstruct efx_tc_counter_index *count;\n};\n\nstruct efx_tc_flow_rule {\n\tunsigned long cookie;\n\tstruct rhash_head linkage;\n\tstruct efx_tc_match match;\n\tstruct efx_tc_action_set_list acts;\n\tstruct efx_tc_action_set_list *fallback;  \n\tu32 fw_id;\n};\n\nstruct efx_tc_lhs_rule {\n\tunsigned long cookie;\n\tstruct efx_tc_match match;\n\tstruct efx_tc_lhs_action lhs_act;\n\tstruct rhash_head linkage;\n\tu32 fw_id;\n};\n\nenum efx_tc_rule_prios {\n\tEFX_TC_PRIO_TC,  \n\tEFX_TC_PRIO_DFLT,  \n\tEFX_TC_PRIO__NUM\n};\n\nstruct efx_tc_table_field_fmt {\n\tu16 field_id;\n\tu16 lbn;\n\tu16 width;\n\tu8 masking;\n\tu8 scheme;\n};\n\nstruct efx_tc_table_desc {\n\tu16 type;\n\tu16 key_width;\n\tu16 resp_width;\n\tu16 n_keys;\n\tu16 n_resps;\n\tu16 n_prios;\n\tu8 flags;\n\tu8 scheme;\n\tstruct efx_tc_table_field_fmt *keys;\n\tstruct efx_tc_table_field_fmt *resps;\n};\n\nstruct efx_tc_table_ct {  \n\tstruct efx_tc_table_desc desc;\n\tbool hooked;\n\tstruct {  \n\t\tu8 eth_proto_idx;\n\t\tu8 ip_proto_idx;\n\t\tu8 src_ip_idx;  \n\t\tu8 dst_ip_idx;\n\t\tu8 l4_sport_idx;\n\t\tu8 l4_dport_idx;\n\t\tu8 zone_idx;  \n\t} keys;\n\tstruct {  \n\t\tu8 dnat_idx;\n\t\tu8 nat_ip_idx;\n\t\tu8 l4_natport_idx;\n\t\tu8 mark_idx;\n\t\tu8 counter_id_idx;\n\t} resps;\n};\n\n \nstruct efx_tc_state {\n\tstruct mae_caps *caps;\n\tstruct list_head block_list;\n\tstruct mutex mutex;\n\tstruct rhashtable counter_ht;\n\tstruct rhashtable counter_id_ht;\n\tstruct rhashtable encap_ht;\n\tstruct rhashtable mac_ht;\n\tstruct rhashtable encap_match_ht;\n\tstruct rhashtable match_action_ht;\n\tstruct rhashtable lhs_rule_ht;\n\tstruct rhashtable ct_zone_ht;\n\tstruct rhashtable ct_ht;\n\tstruct rhashtable neigh_ht;\n\tstruct rhashtable recirc_ht;\n\tstruct ida recirc_ida;\n\tstruct efx_tc_table_ct meta_ct;\n\tu32 reps_mport_id, reps_mport_vport_id;\n\ts32 reps_filter_uc, reps_filter_mc;\n\tbool flush_counters;\n\tu32 flush_gen[EFX_TC_COUNTER_TYPE_MAX];\n\tu32 seen_gen[EFX_TC_COUNTER_TYPE_MAX];\n\twait_queue_head_t flush_wq;\n\tstruct {\n\t\tstruct efx_tc_flow_rule pf;\n\t\tstruct efx_tc_flow_rule wire;\n\t} dflt;\n\tstruct {\n\t\tstruct efx_tc_action_set_list pf;\n\t\tstruct efx_tc_action_set_list reps;\n\t} facts;\n\tbool up;\n};\n\nstruct efx_rep;\n\nenum efx_encap_type efx_tc_indr_netdev_type(struct net_device *net_dev);\nstruct efx_rep *efx_tc_flower_lookup_efv(struct efx_nic *efx,\n\t\t\t\t\t struct net_device *dev);\ns64 efx_tc_flower_external_mport(struct efx_nic *efx, struct efx_rep *efv);\nint efx_tc_configure_default_rule_rep(struct efx_rep *efv);\nvoid efx_tc_deconfigure_default_rule(struct efx_nic *efx,\n\t\t\t\t     struct efx_tc_flow_rule *rule);\nint efx_tc_flower(struct efx_nic *efx, struct net_device *net_dev,\n\t\t  struct flow_cls_offload *tc, struct efx_rep *efv);\n\nint efx_tc_insert_rep_filters(struct efx_nic *efx);\nvoid efx_tc_remove_rep_filters(struct efx_nic *efx);\n\nint efx_init_tc(struct efx_nic *efx);\nvoid efx_fini_tc(struct efx_nic *efx);\n\nint efx_init_struct_tc(struct efx_nic *efx);\nvoid efx_fini_struct_tc(struct efx_nic *efx);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}