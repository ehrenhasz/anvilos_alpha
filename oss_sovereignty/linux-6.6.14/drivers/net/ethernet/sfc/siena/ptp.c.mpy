{
  "module_name": "ptp.c",
  "hash_id": "51274939829f4fe8941ab058777e93b59ed9ca7ea82b6817b3a1642ae88a69ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/siena/ptp.c",
  "human_readable_source": "\n \n\n \n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <linux/time.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/pps_kernel.h>\n#include <linux/ptp_clock_kernel.h>\n#include \"net_driver.h\"\n#include \"efx.h\"\n#include \"mcdi.h\"\n#include \"mcdi_pcol.h\"\n#include \"io.h\"\n#include \"farch_regs.h\"\n#include \"tx.h\"\n#include \"nic.h\"  \n\n \n#define\tMAX_EVENT_FRAGS\t\t\t3\n\n \n#define\tMAX_SYNCHRONISE_WAIT_MS\t\t2\n\n \n#define\tSYNCHRONISE_PERIOD_NS\t\t250000\n\n \n#define\tSYNCHRONISATION_GRANULARITY_NS\t200\n\n \n#define\tDEFAULT_MIN_SYNCHRONISATION_NS\t120\n\n \n#define\tMAX_SYNCHRONISATION_NS\t\t1000\n\n \n#define\tMAX_RECEIVE_EVENTS\t\t8\n\n \n#define\tAVERAGE_LENGTH\t\t\t16\n\n \n#define PKT_EVENT_LIFETIME_MS\t\t10\n\n \n#define PTP_DPORT_OFFSET\t22\n\n#define PTP_V1_VERSION_LENGTH\t2\n#define PTP_V1_VERSION_OFFSET\t28\n\n#define PTP_V1_UUID_LENGTH\t6\n#define PTP_V1_UUID_OFFSET\t50\n\n#define PTP_V1_SEQUENCE_LENGTH\t2\n#define PTP_V1_SEQUENCE_OFFSET\t58\n\n \n#define\tPTP_V1_MIN_LENGTH\t64\n\n#define PTP_V2_VERSION_LENGTH\t1\n#define PTP_V2_VERSION_OFFSET\t29\n\n#define PTP_V2_UUID_LENGTH\t8\n#define PTP_V2_UUID_OFFSET\t48\n\n \n#define PTP_V2_MC_UUID_LENGTH\t6\n#define PTP_V2_MC_UUID_OFFSET\t50\n\n#define PTP_V2_SEQUENCE_LENGTH\t2\n#define PTP_V2_SEQUENCE_OFFSET\t58\n\n \n#define\tPTP_V2_MIN_LENGTH\t63\n\n#define\tPTP_MIN_LENGTH\t\t63\n\n#define PTP_ADDRESS\t\t0xe0000181\t \n#define PTP_EVENT_PORT\t\t319\n#define PTP_GENERAL_PORT\t320\n\n \n#define\tPTP_VERSION_V1\t\t1\n\n#define\tPTP_VERSION_V2\t\t2\n#define\tPTP_VERSION_V2_MASK\t0x0f\n\nenum ptp_packet_state {\n\tPTP_PACKET_STATE_UNMATCHED = 0,\n\tPTP_PACKET_STATE_MATCHED,\n\tPTP_PACKET_STATE_TIMED_OUT,\n\tPTP_PACKET_STATE_MATCH_UNWANTED\n};\n\n \n#define\tMC_NANOSECOND_BITS\t30\n#define\tMC_NANOSECOND_MASK\t((1 << MC_NANOSECOND_BITS) - 1)\n#define\tMC_SECOND_MASK\t\t((1 << (32 - MC_NANOSECOND_BITS)) - 1)\n\n \n#define MAX_PPB\t\t\t1000000\n\n \n \n#define PPB_SCALE_WORD  ((1LL << (57)) / 1953125LL)\n\n \n#define PPB_SHIFT_FP40\t\t26\n \n#define PPB_SHIFT_FP44\t\t22\n\n#define PTP_SYNC_ATTEMPTS\t4\n\n \nstruct efx_ptp_match {\n\tu32 words[DIV_ROUND_UP(PTP_V1_UUID_LENGTH, 4)];\n\tunsigned long expiry;\n\tenum ptp_packet_state state;\n};\n\n \nstruct efx_ptp_event_rx {\n\tstruct list_head link;\n\tu32 seq0;\n\tu32 seq1;\n\tktime_t hwtimestamp;\n\tunsigned long expiry;\n};\n\n \nstruct efx_ptp_timeset {\n\tu32 host_start;\n\tu32 major;\n\tu32 minor;\n\tu32 host_end;\n\tu32 wait;\n\tu32 window;\t \n};\n\n \nstruct efx_ptp_data {\n\tstruct efx_nic *efx;\n\tstruct efx_channel *channel;\n\tbool rx_ts_inline;\n\tstruct sk_buff_head rxq;\n\tstruct sk_buff_head txq;\n\tstruct list_head evt_list;\n\tstruct list_head evt_free_list;\n\tspinlock_t evt_lock;\n\tstruct efx_ptp_event_rx rx_evts[MAX_RECEIVE_EVENTS];\n\tstruct workqueue_struct *workwq;\n\tstruct work_struct work;\n\tbool reset_required;\n\tu32 rxfilter_event;\n\tu32 rxfilter_general;\n\tbool rxfilter_installed;\n\tstruct hwtstamp_config config;\n\tbool enabled;\n\tunsigned int mode;\n\tvoid (*ns_to_nic_time)(s64 ns, u32 *nic_major, u32 *nic_minor);\n\tktime_t (*nic_to_kernel_time)(u32 nic_major, u32 nic_minor,\n\t\t\t\t      s32 correction);\n\tstruct {\n\t\tu32 minor_max;\n\t\tu32 sync_event_diff_min;\n\t\tu32 sync_event_diff_max;\n\t\tunsigned int sync_event_minor_shift;\n\t} nic_time;\n\tunsigned int min_synchronisation_ns;\n\tunsigned int capabilities;\n\tstruct {\n\t\ts32 ptp_tx;\n\t\ts32 ptp_rx;\n\t\ts32 pps_out;\n\t\ts32 pps_in;\n\t\ts32 general_tx;\n\t\ts32 general_rx;\n\t} ts_corrections;\n\tefx_qword_t evt_frags[MAX_EVENT_FRAGS];\n\tint evt_frag_idx;\n\tint evt_code;\n\tstruct efx_buffer start;\n\tstruct pps_event_time host_time_pps;\n\tunsigned int adjfreq_ppb_shift;\n\ts64 current_adjfreq;\n\tstruct ptp_clock *phc_clock;\n\tstruct ptp_clock_info phc_clock_info;\n\tstruct work_struct pps_work;\n\tstruct workqueue_struct *pps_workwq;\n\tbool nic_ts_enabled;\n\tefx_dword_t txbuf[MCDI_TX_BUF_LEN(MC_CMD_PTP_IN_TRANSMIT_LENMAX)];\n\n\tunsigned int good_syncs;\n\tunsigned int fast_syncs;\n\tunsigned int bad_syncs;\n\tunsigned int sync_timeouts;\n\tunsigned int no_time_syncs;\n\tunsigned int invalid_sync_windows;\n\tunsigned int undersize_sync_windows;\n\tunsigned int oversize_sync_windows;\n\tunsigned int rx_no_timestamp;\n\tstruct efx_ptp_timeset\n\ttimeset[MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_MAXNUM];\n\tvoid (*xmit_skb)(struct efx_nic *efx, struct sk_buff *skb);\n};\n\nstatic int efx_phc_adjfine(struct ptp_clock_info *ptp, long scaled_ppm);\nstatic int efx_phc_adjtime(struct ptp_clock_info *ptp, s64 delta);\nstatic int efx_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts);\nstatic int efx_phc_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *e_ts);\nstatic int efx_phc_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *request, int on);\n\nbool efx_siena_ptp_use_mac_tx_timestamps(struct efx_nic *efx)\n{\n\treturn efx_has_cap(efx, TX_MAC_TIMESTAMPING);\n}\n\n \nstatic bool efx_ptp_want_txqs(struct efx_channel *channel)\n{\n\treturn efx_siena_ptp_use_mac_tx_timestamps(channel->efx);\n}\n\n#define PTP_SW_STAT(ext_name, field_name)\t\t\t\t\\\n\t{ #ext_name, 0, offsetof(struct efx_ptp_data, field_name) }\n#define PTP_MC_STAT(ext_name, mcdi_name)\t\t\t\t\\\n\t{ #ext_name, 32, MC_CMD_PTP_OUT_STATUS_STATS_ ## mcdi_name ## _OFST }\nstatic const struct efx_hw_stat_desc efx_ptp_stat_desc[] = {\n\tPTP_SW_STAT(ptp_good_syncs, good_syncs),\n\tPTP_SW_STAT(ptp_fast_syncs, fast_syncs),\n\tPTP_SW_STAT(ptp_bad_syncs, bad_syncs),\n\tPTP_SW_STAT(ptp_sync_timeouts, sync_timeouts),\n\tPTP_SW_STAT(ptp_no_time_syncs, no_time_syncs),\n\tPTP_SW_STAT(ptp_invalid_sync_windows, invalid_sync_windows),\n\tPTP_SW_STAT(ptp_undersize_sync_windows, undersize_sync_windows),\n\tPTP_SW_STAT(ptp_oversize_sync_windows, oversize_sync_windows),\n\tPTP_SW_STAT(ptp_rx_no_timestamp, rx_no_timestamp),\n\tPTP_MC_STAT(ptp_tx_timestamp_packets, TX),\n\tPTP_MC_STAT(ptp_rx_timestamp_packets, RX),\n\tPTP_MC_STAT(ptp_timestamp_packets, TS),\n\tPTP_MC_STAT(ptp_filter_matches, FM),\n\tPTP_MC_STAT(ptp_non_filter_matches, NFM),\n};\n#define PTP_STAT_COUNT ARRAY_SIZE(efx_ptp_stat_desc)\nstatic const unsigned long efx_ptp_stat_mask[] = {\n\t[0 ... BITS_TO_LONGS(PTP_STAT_COUNT) - 1] = ~0UL,\n};\n\nsize_t efx_siena_ptp_describe_stats(struct efx_nic *efx, u8 *strings)\n{\n\tif (!efx->ptp_data)\n\t\treturn 0;\n\n\treturn efx_siena_describe_stats(efx_ptp_stat_desc, PTP_STAT_COUNT,\n\t\t\t\t\tefx_ptp_stat_mask, strings);\n}\n\nsize_t efx_siena_ptp_update_stats(struct efx_nic *efx, u64 *stats)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_STATUS_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_STATUS_LEN);\n\tsize_t i;\n\tint rc;\n\n\tif (!efx->ptp_data)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < PTP_STAT_COUNT; i++) {\n\t\tif (efx_ptp_stat_desc[i].dma_width)\n\t\t\tcontinue;\n\t\tstats[i] = *(unsigned int *)((char *)efx->ptp_data +\n\t\t\t\t\t     efx_ptp_stat_desc[i].offset);\n\t}\n\n\t \n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_STATUS);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), NULL);\n\tif (rc)\n\t\tmemset(outbuf, 0, sizeof(outbuf));\n\tefx_siena_update_stats(efx_ptp_stat_desc, PTP_STAT_COUNT,\n\t\t\t       efx_ptp_stat_mask,\n\t\t\t       stats, _MCDI_PTR(outbuf, 0), false);\n\n\treturn PTP_STAT_COUNT;\n}\n\n \nstatic void efx_ptp_ns_to_s_ns(s64 ns, u32 *nic_major, u32 *nic_minor)\n{\n\tstruct timespec64 ts = ns_to_timespec64(ns);\n\t*nic_major = (u32)ts.tv_sec;\n\t*nic_minor = ts.tv_nsec;\n}\n\nstatic ktime_t efx_ptp_s_ns_to_ktime_correction(u32 nic_major, u32 nic_minor,\n\t\t\t\t\t\ts32 correction)\n{\n\tktime_t kt = ktime_set(nic_major, nic_minor);\n\tif (correction >= 0)\n\t\tkt = ktime_add_ns(kt, (u64)correction);\n\telse\n\t\tkt = ktime_sub_ns(kt, (u64)-correction);\n\treturn kt;\n}\n\n \n#define S27_TO_NS_SHIFT\t(27)\n#define NS_TO_S27_MULT\t(((1ULL << 63) + NSEC_PER_SEC / 2) / NSEC_PER_SEC)\n#define NS_TO_S27_SHIFT\t(63 - S27_TO_NS_SHIFT)\n#define S27_MINOR_MAX\t(1 << S27_TO_NS_SHIFT)\n\n \nstatic void efx_ptp_ns_to_s27(s64 ns, u32 *nic_major, u32 *nic_minor)\n{\n\tstruct timespec64 ts = ns_to_timespec64(ns);\n\tu32 maj = (u32)ts.tv_sec;\n\tu32 min = (u32)(((u64)ts.tv_nsec * NS_TO_S27_MULT +\n\t\t\t (1ULL << (NS_TO_S27_SHIFT - 1))) >> NS_TO_S27_SHIFT);\n\n\t \n\tif (min >= S27_MINOR_MAX) {\n\t\tmin -= S27_MINOR_MAX;\n\t\tmaj++;\n\t}\n\n\t*nic_major = maj;\n\t*nic_minor = min;\n}\n\nstatic inline ktime_t efx_ptp_s27_to_ktime(u32 nic_major, u32 nic_minor)\n{\n\tu32 ns = (u32)(((u64)nic_minor * NSEC_PER_SEC +\n\t\t\t(1ULL << (S27_TO_NS_SHIFT - 1))) >> S27_TO_NS_SHIFT);\n\treturn ktime_set(nic_major, ns);\n}\n\nstatic ktime_t efx_ptp_s27_to_ktime_correction(u32 nic_major, u32 nic_minor,\n\t\t\t\t\t       s32 correction)\n{\n\t \n\tnic_minor += correction;\n\tif ((s32)nic_minor < 0) {\n\t\tnic_minor += S27_MINOR_MAX;\n\t\tnic_major--;\n\t} else if (nic_minor >= S27_MINOR_MAX) {\n\t\tnic_minor -= S27_MINOR_MAX;\n\t\tnic_major++;\n\t}\n\n\treturn efx_ptp_s27_to_ktime(nic_major, nic_minor);\n}\n\n \nstatic void efx_ptp_ns_to_s_qns(s64 ns, u32 *nic_major, u32 *nic_minor)\n{\n\tstruct timespec64 ts = ns_to_timespec64(ns);\n\n\t*nic_major = (u32)ts.tv_sec;\n\t*nic_minor = ts.tv_nsec * 4;\n}\n\nstatic ktime_t efx_ptp_s_qns_to_ktime_correction(u32 nic_major, u32 nic_minor,\n\t\t\t\t\t\t s32 correction)\n{\n\tktime_t kt;\n\n\tnic_minor = DIV_ROUND_CLOSEST(nic_minor, 4);\n\tcorrection = DIV_ROUND_CLOSEST(correction, 4);\n\n\tkt = ktime_set(nic_major, nic_minor);\n\n\tif (correction >= 0)\n\t\tkt = ktime_add_ns(kt, (u64)correction);\n\telse\n\t\tkt = ktime_sub_ns(kt, (u64)-correction);\n\treturn kt;\n}\n\nstruct efx_channel *efx_siena_ptp_channel(struct efx_nic *efx)\n{\n\treturn efx->ptp_data ? efx->ptp_data->channel : NULL;\n}\n\nstatic u32 last_sync_timestamp_major(struct efx_nic *efx)\n{\n\tstruct efx_channel *channel = efx_siena_ptp_channel(efx);\n\tu32 major = 0;\n\n\tif (channel)\n\t\tmajor = channel->sync_timestamp_major;\n\treturn major;\n}\n\n \nstatic ktime_t\nefx_ptp_mac_nic_to_ktime_correction(struct efx_nic *efx,\n\t\t\t\t    struct efx_ptp_data *ptp,\n\t\t\t\t    u32 nic_major, u32 nic_minor,\n\t\t\t\t    s32 correction)\n{\n\tu32 sync_timestamp;\n\tktime_t kt = { 0 };\n\ts16 delta;\n\n\tif (!(nic_major & 0x80000000)) {\n\t\tWARN_ON_ONCE(nic_major >> 16);\n\n\t\t \n\t\tsync_timestamp = last_sync_timestamp_major(efx);\n\n\t\t \n\t\tdelta = nic_major - sync_timestamp;\n\n\t\t \n\t\tnic_major = sync_timestamp + delta;\n\n\t\tkt = ptp->nic_to_kernel_time(nic_major, nic_minor,\n\t\t\t\t\t     correction);\n\t}\n\treturn kt;\n}\n\nktime_t efx_siena_ptp_nic_to_kernel_time(struct efx_tx_queue *tx_queue)\n{\n\tstruct efx_nic *efx = tx_queue->efx;\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tktime_t kt;\n\n\tif (efx_siena_ptp_use_mac_tx_timestamps(efx))\n\t\tkt = efx_ptp_mac_nic_to_ktime_correction(efx, ptp,\n\t\t\t\ttx_queue->completed_timestamp_major,\n\t\t\t\ttx_queue->completed_timestamp_minor,\n\t\t\t\tptp->ts_corrections.general_tx);\n\telse\n\t\tkt = ptp->nic_to_kernel_time(\n\t\t\t\ttx_queue->completed_timestamp_major,\n\t\t\t\ttx_queue->completed_timestamp_minor,\n\t\t\t\tptp->ts_corrections.general_tx);\n\treturn kt;\n}\n\n \nstatic int efx_ptp_get_attributes(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_GET_ATTRIBUTES_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_GET_ATTRIBUTES_LEN);\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tint rc;\n\tu32 fmt;\n\tsize_t out_len;\n\n\t \n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_GET_ATTRIBUTES);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\trc = efx_siena_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\n\t\t\t\t      outbuf, sizeof(outbuf), &out_len);\n\tif (rc == 0) {\n\t\tfmt = MCDI_DWORD(outbuf, PTP_OUT_GET_ATTRIBUTES_TIME_FORMAT);\n\t} else if (rc == -EINVAL) {\n\t\tfmt = MC_CMD_PTP_OUT_GET_ATTRIBUTES_SECONDS_NANOSECONDS;\n\t} else if (rc == -EPERM) {\n\t\tpci_info(efx->pci_dev, \"no PTP support\\n\");\n\t\treturn rc;\n\t} else {\n\t\tefx_siena_mcdi_display_error(efx, MC_CMD_PTP, sizeof(inbuf),\n\t\t\t\t\t     outbuf, sizeof(outbuf), rc);\n\t\treturn rc;\n\t}\n\n\tswitch (fmt) {\n\tcase MC_CMD_PTP_OUT_GET_ATTRIBUTES_SECONDS_27FRACTION:\n\t\tptp->ns_to_nic_time = efx_ptp_ns_to_s27;\n\t\tptp->nic_to_kernel_time = efx_ptp_s27_to_ktime_correction;\n\t\tptp->nic_time.minor_max = 1 << 27;\n\t\tptp->nic_time.sync_event_minor_shift = 19;\n\t\tbreak;\n\tcase MC_CMD_PTP_OUT_GET_ATTRIBUTES_SECONDS_NANOSECONDS:\n\t\tptp->ns_to_nic_time = efx_ptp_ns_to_s_ns;\n\t\tptp->nic_to_kernel_time = efx_ptp_s_ns_to_ktime_correction;\n\t\tptp->nic_time.minor_max = 1000000000;\n\t\tptp->nic_time.sync_event_minor_shift = 22;\n\t\tbreak;\n\tcase MC_CMD_PTP_OUT_GET_ATTRIBUTES_SECONDS_QTR_NANOSECONDS:\n\t\tptp->ns_to_nic_time = efx_ptp_ns_to_s_qns;\n\t\tptp->nic_to_kernel_time = efx_ptp_s_qns_to_ktime_correction;\n\t\tptp->nic_time.minor_max = 4000000000UL;\n\t\tptp->nic_time.sync_event_minor_shift = 24;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tptp->nic_time.sync_event_diff_min = ptp->nic_time.minor_max\n\t\t- (ptp->nic_time.minor_max / 10);\n\tptp->nic_time.sync_event_diff_max = (ptp->nic_time.minor_max / 4)\n\t\t+ (ptp->nic_time.minor_max / 10);\n\n\t \n\tif (rc == 0 &&\n\t    out_len >= MC_CMD_PTP_OUT_GET_ATTRIBUTES_CAPABILITIES_OFST)\n\t\tptp->min_synchronisation_ns =\n\t\t\tMCDI_DWORD(outbuf,\n\t\t\t\t   PTP_OUT_GET_ATTRIBUTES_SYNC_WINDOW_MIN);\n\telse\n\t\tptp->min_synchronisation_ns = DEFAULT_MIN_SYNCHRONISATION_NS;\n\n\tif (rc == 0 &&\n\t    out_len >= MC_CMD_PTP_OUT_GET_ATTRIBUTES_LEN)\n\t\tptp->capabilities = MCDI_DWORD(outbuf,\n\t\t\t\t\tPTP_OUT_GET_ATTRIBUTES_CAPABILITIES);\n\telse\n\t\tptp->capabilities = 0;\n\n\t \n\tif (ptp->capabilities & (1 << MC_CMD_PTP_OUT_GET_ATTRIBUTES_FP44_FREQ_ADJ_LBN))\n\t\tptp->adjfreq_ppb_shift = PPB_SHIFT_FP44;\n\telse\n\t\tptp->adjfreq_ppb_shift = PPB_SHIFT_FP40;\n\n\treturn 0;\n}\n\n \nstatic int efx_ptp_get_timestamp_corrections(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_GET_TIMESTAMP_CORRECTIONS_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_GET_TIMESTAMP_CORRECTIONS_V2_LEN);\n\tint rc;\n\tsize_t out_len;\n\n\t \n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP,\n\t\t       MC_CMD_PTP_OP_GET_TIMESTAMP_CORRECTIONS);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\n\trc = efx_siena_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\n\t\t\t\t      outbuf, sizeof(outbuf), &out_len);\n\tif (rc == 0) {\n\t\tefx->ptp_data->ts_corrections.ptp_tx = MCDI_DWORD(outbuf,\n\t\t\tPTP_OUT_GET_TIMESTAMP_CORRECTIONS_TRANSMIT);\n\t\tefx->ptp_data->ts_corrections.ptp_rx = MCDI_DWORD(outbuf,\n\t\t\tPTP_OUT_GET_TIMESTAMP_CORRECTIONS_RECEIVE);\n\t\tefx->ptp_data->ts_corrections.pps_out = MCDI_DWORD(outbuf,\n\t\t\tPTP_OUT_GET_TIMESTAMP_CORRECTIONS_PPS_OUT);\n\t\tefx->ptp_data->ts_corrections.pps_in = MCDI_DWORD(outbuf,\n\t\t\tPTP_OUT_GET_TIMESTAMP_CORRECTIONS_PPS_IN);\n\n\t\tif (out_len >= MC_CMD_PTP_OUT_GET_TIMESTAMP_CORRECTIONS_V2_LEN) {\n\t\t\tefx->ptp_data->ts_corrections.general_tx = MCDI_DWORD(\n\t\t\t\toutbuf,\n\t\t\t\tPTP_OUT_GET_TIMESTAMP_CORRECTIONS_V2_GENERAL_TX);\n\t\t\tefx->ptp_data->ts_corrections.general_rx = MCDI_DWORD(\n\t\t\t\toutbuf,\n\t\t\t\tPTP_OUT_GET_TIMESTAMP_CORRECTIONS_V2_GENERAL_RX);\n\t\t} else {\n\t\t\tefx->ptp_data->ts_corrections.general_tx =\n\t\t\t\tefx->ptp_data->ts_corrections.ptp_tx;\n\t\t\tefx->ptp_data->ts_corrections.general_rx =\n\t\t\t\tefx->ptp_data->ts_corrections.ptp_rx;\n\t\t}\n\t} else if (rc == -EINVAL) {\n\t\tefx->ptp_data->ts_corrections.ptp_tx = 0;\n\t\tefx->ptp_data->ts_corrections.ptp_rx = 0;\n\t\tefx->ptp_data->ts_corrections.pps_out = 0;\n\t\tefx->ptp_data->ts_corrections.pps_in = 0;\n\t\tefx->ptp_data->ts_corrections.general_tx = 0;\n\t\tefx->ptp_data->ts_corrections.general_rx = 0;\n\t} else {\n\t\tefx_siena_mcdi_display_error(efx, MC_CMD_PTP, sizeof(inbuf),\n\t\t\t\t\t     outbuf, sizeof(outbuf), rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int efx_ptp_enable(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_ENABLE_LEN);\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_ENABLE);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_QUEUE,\n\t\t       efx->ptp_data->channel ?\n\t\t       efx->ptp_data->channel->channel : 0);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_MODE, efx->ptp_data->mode);\n\n\trc = efx_siena_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\n\t\t\t\t      outbuf, sizeof(outbuf), NULL);\n\trc = (rc == -EALREADY) ? 0 : rc;\n\tif (rc)\n\t\tefx_siena_mcdi_display_error(efx, MC_CMD_PTP,\n\t\t\t\t\t     MC_CMD_PTP_IN_ENABLE_LEN,\n\t\t\t\t\t     outbuf, sizeof(outbuf), rc);\n\treturn rc;\n}\n\n \nstatic int efx_ptp_disable(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_DISABLE_LEN);\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_DISABLE);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\trc = efx_siena_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\n\t\t\t\t      outbuf, sizeof(outbuf), NULL);\n\trc = (rc == -EALREADY) ? 0 : rc;\n\t \n\tif (rc == -ENOSYS || rc == -EPERM)\n\t\tpci_info(efx->pci_dev, \"no PTP support\\n\");\n\telse if (rc)\n\t\tefx_siena_mcdi_display_error(efx, MC_CMD_PTP,\n\t\t\t\t\t     MC_CMD_PTP_IN_DISABLE_LEN,\n\t\t\t\t\t     outbuf, sizeof(outbuf), rc);\n\treturn rc;\n}\n\nstatic void efx_ptp_deliver_rx_queue(struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(q))) {\n\t\tlocal_bh_disable();\n\t\tnetif_receive_skb(skb);\n\t\tlocal_bh_enable();\n\t}\n}\n\nstatic void efx_ptp_handle_no_channel(struct efx_nic *efx)\n{\n\tnetif_err(efx, drv, efx->net_dev,\n\t\t  \"ERROR: PTP requires MSI-X and 1 additional interrupt\"\n\t\t  \"vector. PTP disabled\\n\");\n}\n\n \nstatic void efx_ptp_send_times(struct efx_nic *efx,\n\t\t\t       struct pps_event_time *last_time)\n{\n\tstruct pps_event_time now;\n\tstruct timespec64 limit;\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tint *mc_running = ptp->start.addr;\n\n\tpps_get_ts(&now);\n\tlimit = now.ts_real;\n\ttimespec64_add_ns(&limit, SYNCHRONISE_PERIOD_NS);\n\n\t \n\twhile ((timespec64_compare(&now.ts_real, &limit) < 0) &&\n\t       READ_ONCE(*mc_running)) {\n\t\tstruct timespec64 update_time;\n\t\tunsigned int host_time;\n\n\t\t \n\t\tupdate_time = now.ts_real;\n\t\ttimespec64_add_ns(&update_time, SYNCHRONISATION_GRANULARITY_NS);\n\t\tdo {\n\t\t\tpps_get_ts(&now);\n\t\t} while ((timespec64_compare(&now.ts_real, &update_time) < 0) &&\n\t\t\t READ_ONCE(*mc_running));\n\n\t\t \n\t\thost_time = (now.ts_real.tv_sec << MC_NANOSECOND_BITS |\n\t\t\t     now.ts_real.tv_nsec);\n\t\t \n\t\tefx->type->ptp_write_host_time(efx, host_time);\n\t}\n\t*last_time = now;\n}\n\n \nstatic void efx_ptp_read_timeset(MCDI_DECLARE_STRUCT_PTR(data),\n\t\t\t\t struct efx_ptp_timeset *timeset)\n{\n\tunsigned start_ns, end_ns;\n\n\ttimeset->host_start = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_HOSTSTART);\n\ttimeset->major = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_MAJOR);\n\ttimeset->minor = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_MINOR);\n\ttimeset->host_end = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_HOSTEND),\n\ttimeset->wait = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_WAITNS);\n\n\t \n\tstart_ns = timeset->host_start & MC_NANOSECOND_MASK;\n\tend_ns = timeset->host_end & MC_NANOSECOND_MASK;\n\t \n\tif (end_ns < start_ns)\n\t\tend_ns += NSEC_PER_SEC;\n\t \n\ttimeset->window = end_ns - start_ns;\n}\n\n \nstatic int\nefx_ptp_process_times(struct efx_nic *efx, MCDI_DECLARE_STRUCT_PTR(synch_buf),\n\t\t      size_t response_length,\n\t\t      const struct pps_event_time *last_time)\n{\n\tunsigned number_readings =\n\t\tMCDI_VAR_ARRAY_LEN(response_length,\n\t\t\t\t   PTP_OUT_SYNCHRONIZE_TIMESET);\n\tunsigned i;\n\tunsigned ngood = 0;\n\tunsigned last_good = 0;\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tu32 last_sec;\n\tu32 start_sec;\n\tstruct timespec64 delta;\n\tktime_t mc_time;\n\n\tif (number_readings == 0)\n\t\treturn -EAGAIN;\n\n\t \n\tfor (i = 0; i < number_readings; i++) {\n\t\ts32 window, corrected;\n\t\tstruct timespec64 wait;\n\n\t\tefx_ptp_read_timeset(\n\t\t\tMCDI_ARRAY_STRUCT_PTR(synch_buf,\n\t\t\t\t\t      PTP_OUT_SYNCHRONIZE_TIMESET, i),\n\t\t\t&ptp->timeset[i]);\n\n\t\twait = ktime_to_timespec64(\n\t\t\tptp->nic_to_kernel_time(0, ptp->timeset[i].wait, 0));\n\t\twindow = ptp->timeset[i].window;\n\t\tcorrected = window - wait.tv_nsec;\n\n\t\t \n\t\tif (window < SYNCHRONISATION_GRANULARITY_NS) {\n\t\t\t++ptp->invalid_sync_windows;\n\t\t} else if (corrected >= MAX_SYNCHRONISATION_NS) {\n\t\t\t++ptp->oversize_sync_windows;\n\t\t} else if (corrected < ptp->min_synchronisation_ns) {\n\t\t\t++ptp->undersize_sync_windows;\n\t\t} else {\n\t\t\tngood++;\n\t\t\tlast_good = i;\n\t\t}\n\t}\n\n\tif (ngood == 0) {\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"PTP no suitable synchronisations\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tstart_sec = ptp->timeset[last_good].host_start >> MC_NANOSECOND_BITS;\n\tlast_sec = last_time->ts_real.tv_sec & MC_SECOND_MASK;\n\tif (start_sec != last_sec &&\n\t    ((start_sec + 1) & MC_SECOND_MASK) != last_sec) {\n\t\tnetif_warn(efx, hw, efx->net_dev,\n\t\t\t   \"PTP bad synchronisation seconds\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tdelta.tv_sec = (last_sec - start_sec) & 1;\n\tdelta.tv_nsec =\n\t\tlast_time->ts_real.tv_nsec -\n\t\t(ptp->timeset[last_good].host_start & MC_NANOSECOND_MASK);\n\n\t \n\tmc_time = ptp->nic_to_kernel_time(ptp->timeset[last_good].major,\n\t\t\t\t\t  ptp->timeset[last_good].minor, 0);\n\n\t \n\tdelta.tv_nsec += ktime_to_timespec64(mc_time).tv_nsec;\n\n\t \n\tptp->host_time_pps = *last_time;\n\tpps_sub_ts(&ptp->host_time_pps, delta);\n\n\treturn 0;\n}\n\n \nstatic int efx_ptp_synchronize(struct efx_nic *efx, unsigned int num_readings)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tMCDI_DECLARE_BUF(synch_buf, MC_CMD_PTP_OUT_SYNCHRONIZE_LENMAX);\n\tsize_t response_length;\n\tint rc;\n\tunsigned long timeout;\n\tstruct pps_event_time last_time = {};\n\tunsigned int loops = 0;\n\tint *start = ptp->start.addr;\n\n\tMCDI_SET_DWORD(synch_buf, PTP_IN_OP, MC_CMD_PTP_OP_SYNCHRONIZE);\n\tMCDI_SET_DWORD(synch_buf, PTP_IN_PERIPH_ID, 0);\n\tMCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_NUMTIMESETS,\n\t\t       num_readings);\n\tMCDI_SET_QWORD(synch_buf, PTP_IN_SYNCHRONIZE_START_ADDR,\n\t\t       ptp->start.dma_addr);\n\n\t \n\tWRITE_ONCE(*start, 0);\n\trc = efx_siena_mcdi_rpc_start(efx, MC_CMD_PTP, synch_buf,\n\t\t\t\t      MC_CMD_PTP_IN_SYNCHRONIZE_LEN);\n\tEFX_WARN_ON_ONCE_PARANOID(rc);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(MAX_SYNCHRONISE_WAIT_MS);\n\twhile (!READ_ONCE(*start) && (time_before(jiffies, timeout))) {\n\t\tudelay(20);\t \n\t\tloops++;\n\t}\n\n\tif (loops <= 1)\n\t\t++ptp->fast_syncs;\n\tif (!time_before(jiffies, timeout))\n\t\t++ptp->sync_timeouts;\n\n\tif (READ_ONCE(*start))\n\t\tefx_ptp_send_times(efx, &last_time);\n\n\t \n\trc = efx_siena_mcdi_rpc_finish(efx, MC_CMD_PTP,\n\t\t\t\t       MC_CMD_PTP_IN_SYNCHRONIZE_LEN,\n\t\t\t\t       synch_buf, sizeof(synch_buf),\n\t\t\t\t       &response_length);\n\tif (rc == 0) {\n\t\trc = efx_ptp_process_times(efx, synch_buf, response_length,\n\t\t\t\t\t   &last_time);\n\t\tif (rc == 0)\n\t\t\t++ptp->good_syncs;\n\t\telse\n\t\t\t++ptp->no_time_syncs;\n\t}\n\n\t \n\tif (rc != 0)\n\t\t++ptp->bad_syncs;\n\n\treturn rc;\n}\n\n \nstatic void efx_ptp_xmit_skb_queue(struct efx_nic *efx, struct sk_buff *skb)\n{\n\tstruct efx_ptp_data *ptp_data = efx->ptp_data;\n\tu8 type = efx_tx_csum_type_skb(skb);\n\tstruct efx_tx_queue *tx_queue;\n\n\ttx_queue = efx_channel_get_tx_queue(ptp_data->channel, type);\n\tif (tx_queue && tx_queue->timestamping) {\n\t\tefx_enqueue_skb(tx_queue, skb);\n\t} else {\n\t\tWARN_ONCE(1, \"PTP channel has no timestamped tx queue\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\n \nstatic void efx_ptp_xmit_skb_mc(struct efx_nic *efx, struct sk_buff *skb)\n{\n\tstruct efx_ptp_data *ptp_data = efx->ptp_data;\n\tstruct skb_shared_hwtstamps timestamps;\n\tint rc = -EIO;\n\tMCDI_DECLARE_BUF(txtime, MC_CMD_PTP_OUT_TRANSMIT_LEN);\n\tsize_t len;\n\n\tMCDI_SET_DWORD(ptp_data->txbuf, PTP_IN_OP, MC_CMD_PTP_OP_TRANSMIT);\n\tMCDI_SET_DWORD(ptp_data->txbuf, PTP_IN_PERIPH_ID, 0);\n\tMCDI_SET_DWORD(ptp_data->txbuf, PTP_IN_TRANSMIT_LENGTH, skb->len);\n\tif (skb_shinfo(skb)->nr_frags != 0) {\n\t\trc = skb_linearize(skb);\n\t\tif (rc != 0)\n\t\t\tgoto fail;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\trc = skb_checksum_help(skb);\n\t\tif (rc != 0)\n\t\t\tgoto fail;\n\t}\n\tskb_copy_from_linear_data(skb,\n\t\t\t\t  MCDI_PTR(ptp_data->txbuf,\n\t\t\t\t\t   PTP_IN_TRANSMIT_PACKET),\n\t\t\t\t  skb->len);\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_PTP, ptp_data->txbuf,\n\t\t\t\tMC_CMD_PTP_IN_TRANSMIT_LEN(skb->len), txtime,\n\t\t\t\tsizeof(txtime), &len);\n\tif (rc != 0)\n\t\tgoto fail;\n\n\tmemset(&timestamps, 0, sizeof(timestamps));\n\ttimestamps.hwtstamp = ptp_data->nic_to_kernel_time(\n\t\tMCDI_DWORD(txtime, PTP_OUT_TRANSMIT_MAJOR),\n\t\tMCDI_DWORD(txtime, PTP_OUT_TRANSMIT_MINOR),\n\t\tptp_data->ts_corrections.ptp_tx);\n\n\tskb_tstamp_tx(skb, &timestamps);\n\n\trc = 0;\n\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn;\n}\n\nstatic void efx_ptp_drop_time_expired_events(struct efx_nic *efx)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tstruct list_head *cursor;\n\tstruct list_head *next;\n\n\tif (ptp->rx_ts_inline)\n\t\treturn;\n\n\t \n\tspin_lock_bh(&ptp->evt_lock);\n\tlist_for_each_safe(cursor, next, &ptp->evt_list) {\n\t\tstruct efx_ptp_event_rx *evt;\n\n\t\tevt = list_entry(cursor, struct efx_ptp_event_rx,\n\t\t\t\t link);\n\t\tif (time_after(jiffies, evt->expiry)) {\n\t\t\tlist_move(&evt->link, &ptp->evt_free_list);\n\t\t\tnetif_warn(efx, hw, efx->net_dev,\n\t\t\t\t   \"PTP rx event dropped\\n\");\n\t\t}\n\t}\n\tspin_unlock_bh(&ptp->evt_lock);\n}\n\nstatic enum ptp_packet_state efx_ptp_match_rx(struct efx_nic *efx,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tbool evts_waiting;\n\tstruct list_head *cursor;\n\tstruct list_head *next;\n\tstruct efx_ptp_match *match;\n\tenum ptp_packet_state rc = PTP_PACKET_STATE_UNMATCHED;\n\n\tWARN_ON_ONCE(ptp->rx_ts_inline);\n\n\tspin_lock_bh(&ptp->evt_lock);\n\tevts_waiting = !list_empty(&ptp->evt_list);\n\tspin_unlock_bh(&ptp->evt_lock);\n\n\tif (!evts_waiting)\n\t\treturn PTP_PACKET_STATE_UNMATCHED;\n\n\tmatch = (struct efx_ptp_match *)skb->cb;\n\t \n\tspin_lock_bh(&ptp->evt_lock);\n\tlist_for_each_safe(cursor, next, &ptp->evt_list) {\n\t\tstruct efx_ptp_event_rx *evt;\n\n\t\tevt = list_entry(cursor, struct efx_ptp_event_rx, link);\n\t\tif ((evt->seq0 == match->words[0]) &&\n\t\t    (evt->seq1 == match->words[1])) {\n\t\t\tstruct skb_shared_hwtstamps *timestamps;\n\n\t\t\t \n\t\t\ttimestamps = skb_hwtstamps(skb);\n\t\t\ttimestamps->hwtstamp = evt->hwtimestamp;\n\n\t\t\tmatch->state = PTP_PACKET_STATE_MATCHED;\n\t\t\trc = PTP_PACKET_STATE_MATCHED;\n\t\t\tlist_move(&evt->link, &ptp->evt_free_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&ptp->evt_lock);\n\n\treturn rc;\n}\n\n \nstatic void efx_ptp_process_events(struct efx_nic *efx, struct sk_buff_head *q)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&ptp->rxq))) {\n\t\tstruct efx_ptp_match *match;\n\n\t\tmatch = (struct efx_ptp_match *)skb->cb;\n\t\tif (match->state == PTP_PACKET_STATE_MATCH_UNWANTED) {\n\t\t\t__skb_queue_tail(q, skb);\n\t\t} else if (efx_ptp_match_rx(efx, skb) ==\n\t\t\t   PTP_PACKET_STATE_MATCHED) {\n\t\t\t__skb_queue_tail(q, skb);\n\t\t} else if (time_after(jiffies, match->expiry)) {\n\t\t\tmatch->state = PTP_PACKET_STATE_TIMED_OUT;\n\t\t\t++ptp->rx_no_timestamp;\n\t\t\t__skb_queue_tail(q, skb);\n\t\t} else {\n\t\t\t \n\t\t\tskb_queue_head(&ptp->rxq, skb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic inline void efx_ptp_process_rx(struct efx_nic *efx, struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tnetif_receive_skb(skb);\n\tlocal_bh_enable();\n}\n\nstatic void efx_ptp_remove_multicast_filters(struct efx_nic *efx)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\n\tif (ptp->rxfilter_installed) {\n\t\tefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\n\t\t\t\t\t  ptp->rxfilter_general);\n\t\tefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\n\t\t\t\t\t  ptp->rxfilter_event);\n\t\tptp->rxfilter_installed = false;\n\t}\n}\n\nstatic int efx_ptp_insert_multicast_filters(struct efx_nic *efx)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tstruct efx_filter_spec rxfilter;\n\tint rc;\n\n\tif (!ptp->channel || ptp->rxfilter_installed)\n\t\treturn 0;\n\n\t \n\tefx_filter_init_rx(&rxfilter, EFX_FILTER_PRI_REQUIRED, 0,\n\t\t\t   efx_rx_queue_index(\n\t\t\t\t   efx_channel_get_rx_queue(ptp->channel)));\n\trc = efx_filter_set_ipv4_local(&rxfilter, IPPROTO_UDP,\n\t\t\t\t       htonl(PTP_ADDRESS),\n\t\t\t\t       htons(PTP_EVENT_PORT));\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = efx_filter_insert_filter(efx, &rxfilter, true);\n\tif (rc < 0)\n\t\treturn rc;\n\tptp->rxfilter_event = rc;\n\n\tefx_filter_init_rx(&rxfilter, EFX_FILTER_PRI_REQUIRED, 0,\n\t\t\t   efx_rx_queue_index(\n\t\t\t\t   efx_channel_get_rx_queue(ptp->channel)));\n\trc = efx_filter_set_ipv4_local(&rxfilter, IPPROTO_UDP,\n\t\t\t\t       htonl(PTP_ADDRESS),\n\t\t\t\t       htons(PTP_GENERAL_PORT));\n\tif (rc != 0)\n\t\tgoto fail;\n\n\trc = efx_filter_insert_filter(efx, &rxfilter, true);\n\tif (rc < 0)\n\t\tgoto fail;\n\tptp->rxfilter_general = rc;\n\n\tptp->rxfilter_installed = true;\n\treturn 0;\n\nfail:\n\tefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\n\t\t\t\t  ptp->rxfilter_event);\n\treturn rc;\n}\n\nstatic int efx_ptp_start(struct efx_nic *efx)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tint rc;\n\n\tptp->reset_required = false;\n\n\trc = efx_ptp_insert_multicast_filters(efx);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efx_ptp_enable(efx);\n\tif (rc != 0)\n\t\tgoto fail;\n\n\tptp->evt_frag_idx = 0;\n\tptp->current_adjfreq = 0;\n\n\treturn 0;\n\nfail:\n\tefx_ptp_remove_multicast_filters(efx);\n\treturn rc;\n}\n\nstatic int efx_ptp_stop(struct efx_nic *efx)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tstruct list_head *cursor;\n\tstruct list_head *next;\n\tint rc;\n\n\tif (ptp == NULL)\n\t\treturn 0;\n\n\trc = efx_ptp_disable(efx);\n\n\tefx_ptp_remove_multicast_filters(efx);\n\n\t \n\tefx_ptp_deliver_rx_queue(&efx->ptp_data->rxq);\n\tskb_queue_purge(&efx->ptp_data->txq);\n\n\t \n\tspin_lock_bh(&efx->ptp_data->evt_lock);\n\tlist_for_each_safe(cursor, next, &efx->ptp_data->evt_list) {\n\t\tlist_move(cursor, &efx->ptp_data->evt_free_list);\n\t}\n\tspin_unlock_bh(&efx->ptp_data->evt_lock);\n\n\treturn rc;\n}\n\nstatic int efx_ptp_restart(struct efx_nic *efx)\n{\n\tif (efx->ptp_data && efx->ptp_data->enabled)\n\t\treturn efx_ptp_start(efx);\n\treturn 0;\n}\n\nstatic void efx_ptp_pps_worker(struct work_struct *work)\n{\n\tstruct efx_ptp_data *ptp =\n\t\tcontainer_of(work, struct efx_ptp_data, pps_work);\n\tstruct efx_nic *efx = ptp->efx;\n\tstruct ptp_clock_event ptp_evt;\n\n\tif (efx_ptp_synchronize(efx, PTP_SYNC_ATTEMPTS))\n\t\treturn;\n\n\tptp_evt.type = PTP_CLOCK_PPSUSR;\n\tptp_evt.pps_times = ptp->host_time_pps;\n\tptp_clock_event(ptp->phc_clock, &ptp_evt);\n}\n\nstatic void efx_ptp_worker(struct work_struct *work)\n{\n\tstruct efx_ptp_data *ptp_data =\n\t\tcontainer_of(work, struct efx_ptp_data, work);\n\tstruct efx_nic *efx = ptp_data->efx;\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head tempq;\n\n\tif (ptp_data->reset_required) {\n\t\tefx_ptp_stop(efx);\n\t\tefx_ptp_start(efx);\n\t\treturn;\n\t}\n\n\tefx_ptp_drop_time_expired_events(efx);\n\n\t__skb_queue_head_init(&tempq);\n\tefx_ptp_process_events(efx, &tempq);\n\n\twhile ((skb = skb_dequeue(&ptp_data->txq)))\n\t\tptp_data->xmit_skb(efx, skb);\n\n\twhile ((skb = __skb_dequeue(&tempq)))\n\t\tefx_ptp_process_rx(efx, skb);\n}\n\nstatic const struct ptp_clock_info efx_phc_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sfc_siena\",\n\t.max_adj\t= MAX_PPB,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 1,\n\t.adjfine\t= efx_phc_adjfine,\n\t.adjtime\t= efx_phc_adjtime,\n\t.gettime64\t= efx_phc_gettime,\n\t.settime64\t= efx_phc_settime,\n\t.enable\t\t= efx_phc_enable,\n};\n\n \nstatic int efx_ptp_probe(struct efx_nic *efx, struct efx_channel *channel)\n{\n\tstruct efx_ptp_data *ptp;\n\tint rc = 0;\n\tunsigned int pos;\n\n\tptp = kzalloc(sizeof(struct efx_ptp_data), GFP_KERNEL);\n\tefx->ptp_data = ptp;\n\tif (!efx->ptp_data)\n\t\treturn -ENOMEM;\n\n\tptp->efx = efx;\n\tptp->channel = channel;\n\tptp->rx_ts_inline = efx_nic_rev(efx) >= EFX_REV_HUNT_A0;\n\n\trc = efx_siena_alloc_buffer(efx, &ptp->start, sizeof(int), GFP_KERNEL);\n\tif (rc != 0)\n\t\tgoto fail1;\n\n\tskb_queue_head_init(&ptp->rxq);\n\tskb_queue_head_init(&ptp->txq);\n\tptp->workwq = create_singlethread_workqueue(\"sfc_siena_ptp\");\n\tif (!ptp->workwq) {\n\t\trc = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\tif (efx_siena_ptp_use_mac_tx_timestamps(efx)) {\n\t\tptp->xmit_skb = efx_ptp_xmit_skb_queue;\n\t\t \n\t\tchannel->sync_events_state = SYNC_EVENTS_QUIESCENT;\n\t} else {\n\t\tptp->xmit_skb = efx_ptp_xmit_skb_mc;\n\t}\n\n\tINIT_WORK(&ptp->work, efx_ptp_worker);\n\tptp->config.flags = 0;\n\tptp->config.tx_type = HWTSTAMP_TX_OFF;\n\tptp->config.rx_filter = HWTSTAMP_FILTER_NONE;\n\tINIT_LIST_HEAD(&ptp->evt_list);\n\tINIT_LIST_HEAD(&ptp->evt_free_list);\n\tspin_lock_init(&ptp->evt_lock);\n\tfor (pos = 0; pos < MAX_RECEIVE_EVENTS; pos++)\n\t\tlist_add(&ptp->rx_evts[pos].link, &ptp->evt_free_list);\n\n\t \n\trc = efx_ptp_get_attributes(efx);\n\tif (rc < 0)\n\t\tgoto fail3;\n\n\t \n\trc = efx_ptp_get_timestamp_corrections(efx);\n\tif (rc < 0)\n\t\tgoto fail3;\n\n\tif (efx->mcdi->fn_flags &\n\t    (1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY)) {\n\t\tptp->phc_clock_info = efx_phc_clock_info;\n\t\tptp->phc_clock = ptp_clock_register(&ptp->phc_clock_info,\n\t\t\t\t\t\t    &efx->pci_dev->dev);\n\t\tif (IS_ERR(ptp->phc_clock)) {\n\t\t\trc = PTR_ERR(ptp->phc_clock);\n\t\t\tgoto fail3;\n\t\t} else if (ptp->phc_clock) {\n\t\t\tINIT_WORK(&ptp->pps_work, efx_ptp_pps_worker);\n\t\t\tptp->pps_workwq =\n\t\t\t\tcreate_singlethread_workqueue(\"sfc_siena_pps\");\n\t\t\tif (!ptp->pps_workwq) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto fail4;\n\t\t\t}\n\t\t}\n\t}\n\tptp->nic_ts_enabled = false;\n\n\treturn 0;\nfail4:\n\tptp_clock_unregister(efx->ptp_data->phc_clock);\n\nfail3:\n\tdestroy_workqueue(efx->ptp_data->workwq);\n\nfail2:\n\tefx_siena_free_buffer(efx, &ptp->start);\n\nfail1:\n\tkfree(efx->ptp_data);\n\tefx->ptp_data = NULL;\n\n\treturn rc;\n}\n\n \nstatic int efx_ptp_probe_channel(struct efx_channel *channel)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tint rc;\n\n\tchannel->irq_moderation_us = 0;\n\tchannel->rx_queue.core_index = 0;\n\n\trc = efx_ptp_probe(efx, channel);\n\t \n\tif (rc && rc != -EPERM)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"Failed to probe PTP, rc=%d\\n\", rc);\n\treturn 0;\n}\n\nstatic void efx_ptp_remove(struct efx_nic *efx)\n{\n\tif (!efx->ptp_data)\n\t\treturn;\n\n\t(void)efx_ptp_disable(efx);\n\n\tcancel_work_sync(&efx->ptp_data->work);\n\tif (efx->ptp_data->pps_workwq)\n\t\tcancel_work_sync(&efx->ptp_data->pps_work);\n\n\tskb_queue_purge(&efx->ptp_data->rxq);\n\tskb_queue_purge(&efx->ptp_data->txq);\n\n\tif (efx->ptp_data->phc_clock) {\n\t\tdestroy_workqueue(efx->ptp_data->pps_workwq);\n\t\tptp_clock_unregister(efx->ptp_data->phc_clock);\n\t}\n\n\tdestroy_workqueue(efx->ptp_data->workwq);\n\n\tefx_siena_free_buffer(efx, &efx->ptp_data->start);\n\tkfree(efx->ptp_data);\n\tefx->ptp_data = NULL;\n}\n\nstatic void efx_ptp_remove_channel(struct efx_channel *channel)\n{\n\tefx_ptp_remove(channel->efx);\n}\n\nstatic void efx_ptp_get_channel_name(struct efx_channel *channel,\n\t\t\t\t     char *buf, size_t len)\n{\n\tsnprintf(buf, len, \"%s-ptp\", channel->efx->name);\n}\n\n \nbool efx_siena_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)\n{\n\treturn efx->ptp_data &&\n\t\tefx->ptp_data->enabled &&\n\t\tskb->len >= PTP_MIN_LENGTH &&\n\t\tskb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM &&\n\t\tlikely(skb->protocol == htons(ETH_P_IP)) &&\n\t\tskb_transport_header_was_set(skb) &&\n\t\tskb_network_header_len(skb) >= sizeof(struct iphdr) &&\n\t\tip_hdr(skb)->protocol == IPPROTO_UDP &&\n\t\tskb_headlen(skb) >=\n\t\tskb_transport_offset(skb) + sizeof(struct udphdr) &&\n\t\tudp_hdr(skb)->dest == htons(PTP_EVENT_PORT);\n}\n\n \nstatic bool efx_ptp_rx(struct efx_channel *channel, struct sk_buff *skb)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tstruct efx_ptp_match *match = (struct efx_ptp_match *)skb->cb;\n\tu8 *match_data_012, *match_data_345;\n\tunsigned int version;\n\tu8 *data;\n\n\tmatch->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);\n\n\t \n\tif (ptp->mode == MC_CMD_PTP_MODE_V1) {\n\t\tif (!pskb_may_pull(skb, PTP_V1_MIN_LENGTH)) {\n\t\t\treturn false;\n\t\t}\n\t\tdata = skb->data;\n\t\tversion = ntohs(*(__be16 *)&data[PTP_V1_VERSION_OFFSET]);\n\t\tif (version != PTP_VERSION_V1) {\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tmatch_data_012 = data + PTP_V1_UUID_OFFSET;\n\t\tmatch_data_345 = data + PTP_V1_UUID_OFFSET + 3;\n\t} else {\n\t\tif (!pskb_may_pull(skb, PTP_V2_MIN_LENGTH)) {\n\t\t\treturn false;\n\t\t}\n\t\tdata = skb->data;\n\t\tversion = data[PTP_V2_VERSION_OFFSET];\n\t\tif ((version & PTP_VERSION_V2_MASK) != PTP_VERSION_V2) {\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tmatch_data_345 = data + PTP_V2_UUID_OFFSET + 5;\n\t\tif (ptp->mode == MC_CMD_PTP_MODE_V2) {\n\t\t\tmatch_data_012 = data + PTP_V2_UUID_OFFSET + 2;\n\t\t} else {\n\t\t\tmatch_data_012 = data + PTP_V2_UUID_OFFSET + 0;\n\t\t\tBUG_ON(ptp->mode != MC_CMD_PTP_MODE_V2_ENHANCED);\n\t\t}\n\t}\n\n\t \n\tif (ntohs(*(__be16 *)&data[PTP_DPORT_OFFSET]) == PTP_EVENT_PORT) {\n\t\tmatch->state = PTP_PACKET_STATE_UNMATCHED;\n\n\t\t \n\t\tBUILD_BUG_ON(PTP_V1_SEQUENCE_OFFSET != PTP_V2_SEQUENCE_OFFSET);\n\t\tBUILD_BUG_ON(PTP_V1_SEQUENCE_LENGTH != PTP_V2_SEQUENCE_LENGTH);\n\n\t\t \n\t\tmatch->words[0] = (match_data_012[0]         |\n\t\t\t\t   (match_data_012[1] << 8)  |\n\t\t\t\t   (match_data_012[2] << 16) |\n\t\t\t\t   (match_data_345[0] << 24));\n\t\tmatch->words[1] = (match_data_345[1]         |\n\t\t\t\t   (match_data_345[2] << 8)  |\n\t\t\t\t   (data[PTP_V1_SEQUENCE_OFFSET +\n\t\t\t\t\t PTP_V1_SEQUENCE_LENGTH - 1] <<\n\t\t\t\t    16));\n\t} else {\n\t\tmatch->state = PTP_PACKET_STATE_MATCH_UNWANTED;\n\t}\n\n\tskb_queue_tail(&ptp->rxq, skb);\n\tqueue_work(ptp->workwq, &ptp->work);\n\n\treturn true;\n}\n\n \nint efx_siena_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\n\tskb_queue_tail(&ptp->txq, skb);\n\n\tif ((udp_hdr(skb)->dest == htons(PTP_EVENT_PORT)) &&\n\t    (skb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM))\n\t\tefx_xmit_hwtstamp_pending(skb);\n\tqueue_work(ptp->workwq, &ptp->work);\n\n\treturn NETDEV_TX_OK;\n}\n\nint efx_siena_ptp_get_mode(struct efx_nic *efx)\n{\n\treturn efx->ptp_data->mode;\n}\n\nint efx_siena_ptp_change_mode(struct efx_nic *efx, bool enable_wanted,\n\t\t\t      unsigned int new_mode)\n{\n\tif ((enable_wanted != efx->ptp_data->enabled) ||\n\t    (enable_wanted && (efx->ptp_data->mode != new_mode))) {\n\t\tint rc = 0;\n\n\t\tif (enable_wanted) {\n\t\t\t \n\t\t\tif (efx->ptp_data->enabled &&\n\t\t\t    (efx->ptp_data->mode != new_mode)) {\n\t\t\t\tefx->ptp_data->enabled = false;\n\t\t\t\trc = efx_ptp_stop(efx);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\t \n\t\t\tefx->ptp_data->mode = new_mode;\n\t\t\tif (netif_running(efx->net_dev))\n\t\t\t\trc = efx_ptp_start(efx);\n\t\t\tif (rc == 0) {\n\t\t\t\trc = efx_ptp_synchronize(efx,\n\t\t\t\t\t\t\t PTP_SYNC_ATTEMPTS * 2);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tefx_ptp_stop(efx);\n\t\t\t}\n\t\t} else {\n\t\t\trc = efx_ptp_stop(efx);\n\t\t}\n\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\n\t\tefx->ptp_data->enabled = enable_wanted;\n\t}\n\n\treturn 0;\n}\n\nstatic int efx_ptp_ts_init(struct efx_nic *efx, struct hwtstamp_config *init)\n{\n\tint rc;\n\n\tif ((init->tx_type != HWTSTAMP_TX_OFF) &&\n\t    (init->tx_type != HWTSTAMP_TX_ON))\n\t\treturn -ERANGE;\n\n\trc = efx->type->ptp_set_ts_config(efx, init);\n\tif (rc)\n\t\treturn rc;\n\n\tefx->ptp_data->config = *init;\n\treturn 0;\n}\n\nvoid efx_siena_ptp_get_ts_info(struct efx_nic *efx,\n\t\t\t       struct ethtool_ts_info *ts_info)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tstruct efx_nic *primary = efx->primary;\n\n\tASSERT_RTNL();\n\n\tif (!ptp)\n\t\treturn;\n\n\tts_info->so_timestamping |= (SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t     SOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t     SOF_TIMESTAMPING_RAW_HARDWARE);\n\tif (primary && primary->ptp_data && primary->ptp_data->phc_clock)\n\t\tts_info->phc_index =\n\t\t\tptp_clock_index(primary->ptp_data->phc_clock);\n\tts_info->tx_types = 1 << HWTSTAMP_TX_OFF | 1 << HWTSTAMP_TX_ON;\n\tts_info->rx_filters = ptp->efx->type->hwtstamp_filters;\n}\n\nint efx_siena_ptp_set_ts_config(struct efx_nic *efx, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint rc;\n\n\t \n\tif (!efx->ptp_data)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\trc = efx_ptp_ts_init(efx, &config);\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config))\n\t\t? -EFAULT : 0;\n}\n\nint efx_siena_ptp_get_ts_config(struct efx_nic *efx, struct ifreq *ifr)\n{\n\tif (!efx->ptp_data)\n\t\treturn -EOPNOTSUPP;\n\n\treturn copy_to_user(ifr->ifr_data, &efx->ptp_data->config,\n\t\t\t    sizeof(efx->ptp_data->config)) ? -EFAULT : 0;\n}\n\nstatic void ptp_event_failure(struct efx_nic *efx, int expected_frag_len)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\n\tnetif_err(efx, hw, efx->net_dev,\n\t\t\"PTP unexpected event length: got %d expected %d\\n\",\n\t\tptp->evt_frag_idx, expected_frag_len);\n\tptp->reset_required = true;\n\tqueue_work(ptp->workwq, &ptp->work);\n}\n\n \nstatic void ptp_event_rx(struct efx_nic *efx, struct efx_ptp_data *ptp)\n{\n\tstruct efx_ptp_event_rx *evt = NULL;\n\n\tif (WARN_ON_ONCE(ptp->rx_ts_inline))\n\t\treturn;\n\n\tif (ptp->evt_frag_idx != 3) {\n\t\tptp_event_failure(efx, 3);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ptp->evt_lock);\n\tif (!list_empty(&ptp->evt_free_list)) {\n\t\tevt = list_first_entry(&ptp->evt_free_list,\n\t\t\t\t       struct efx_ptp_event_rx, link);\n\t\tlist_del(&evt->link);\n\n\t\tevt->seq0 = EFX_QWORD_FIELD(ptp->evt_frags[2], MCDI_EVENT_DATA);\n\t\tevt->seq1 = (EFX_QWORD_FIELD(ptp->evt_frags[2],\n\t\t\t\t\t     MCDI_EVENT_SRC)        |\n\t\t\t     (EFX_QWORD_FIELD(ptp->evt_frags[1],\n\t\t\t\t\t      MCDI_EVENT_SRC) << 8) |\n\t\t\t     (EFX_QWORD_FIELD(ptp->evt_frags[0],\n\t\t\t\t\t      MCDI_EVENT_SRC) << 16));\n\t\tevt->hwtimestamp = efx->ptp_data->nic_to_kernel_time(\n\t\t\tEFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA),\n\t\t\tEFX_QWORD_FIELD(ptp->evt_frags[1], MCDI_EVENT_DATA),\n\t\t\tptp->ts_corrections.ptp_rx);\n\t\tevt->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);\n\t\tlist_add_tail(&evt->link, &ptp->evt_list);\n\n\t\tqueue_work(ptp->workwq, &ptp->work);\n\t} else if (net_ratelimit()) {\n\t\t \n\t\tnetif_err(efx, rx_err, efx->net_dev, \"PTP event queue overflow\\n\");\n\t}\n\tspin_unlock_bh(&ptp->evt_lock);\n}\n\nstatic void ptp_event_fault(struct efx_nic *efx, struct efx_ptp_data *ptp)\n{\n\tint code = EFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA);\n\tif (ptp->evt_frag_idx != 1) {\n\t\tptp_event_failure(efx, 1);\n\t\treturn;\n\t}\n\n\tnetif_err(efx, hw, efx->net_dev, \"PTP error %d\\n\", code);\n}\n\nstatic void ptp_event_pps(struct efx_nic *efx, struct efx_ptp_data *ptp)\n{\n\tif (ptp->nic_ts_enabled)\n\t\tqueue_work(ptp->pps_workwq, &ptp->pps_work);\n}\n\nvoid efx_siena_ptp_event(struct efx_nic *efx, efx_qword_t *ev)\n{\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tint code = EFX_QWORD_FIELD(*ev, MCDI_EVENT_CODE);\n\n\tif (!ptp) {\n\t\tif (!efx->ptp_warned) {\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"Received PTP event but PTP not set up\\n\");\n\t\t\tefx->ptp_warned = true;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!ptp->enabled)\n\t\treturn;\n\n\tif (ptp->evt_frag_idx == 0) {\n\t\tptp->evt_code = code;\n\t} else if (ptp->evt_code != code) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"PTP out of sequence event %d\\n\", code);\n\t\tptp->evt_frag_idx = 0;\n\t}\n\n\tptp->evt_frags[ptp->evt_frag_idx++] = *ev;\n\tif (!MCDI_EVENT_FIELD(*ev, CONT)) {\n\t\t \n\t\tswitch (code) {\n\t\tcase MCDI_EVENT_CODE_PTP_RX:\n\t\t\tptp_event_rx(efx, ptp);\n\t\t\tbreak;\n\t\tcase MCDI_EVENT_CODE_PTP_FAULT:\n\t\t\tptp_event_fault(efx, ptp);\n\t\t\tbreak;\n\t\tcase MCDI_EVENT_CODE_PTP_PPS:\n\t\t\tptp_event_pps(efx, ptp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t  \"PTP unknown event %d\\n\", code);\n\t\t\tbreak;\n\t\t}\n\t\tptp->evt_frag_idx = 0;\n\t} else if (MAX_EVENT_FRAGS == ptp->evt_frag_idx) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"PTP too many event fragments\\n\");\n\t\tptp->evt_frag_idx = 0;\n\t}\n}\n\nvoid efx_siena_time_sync_event(struct efx_channel *channel, efx_qword_t *ev)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\n\t \n\tchannel->sync_timestamp_major = MCDI_EVENT_FIELD(*ev, PTP_TIME_MAJOR);\n\tchannel->sync_timestamp_minor =\n\t\t(MCDI_EVENT_FIELD(*ev, PTP_TIME_MINOR_MS_8BITS) & 0xFC)\n\t\t\t<< ptp->nic_time.sync_event_minor_shift;\n\n\t \n\t(void) cmpxchg(&channel->sync_events_state, SYNC_EVENTS_REQUESTED,\n\t\t       SYNC_EVENTS_VALID);\n}\n\nstatic inline u32 efx_rx_buf_timestamp_minor(struct efx_nic *efx, const u8 *eh)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\treturn __le32_to_cpup((const __le32 *)(eh + efx->rx_packet_ts_offset));\n#else\n\tconst u8 *data = eh + efx->rx_packet_ts_offset;\n\treturn (u32)data[0]       |\n\t       (u32)data[1] << 8  |\n\t       (u32)data[2] << 16 |\n\t       (u32)data[3] << 24;\n#endif\n}\n\nvoid __efx_siena_rx_skb_attach_timestamp(struct efx_channel *channel,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tstruct efx_ptp_data *ptp = efx->ptp_data;\n\tu32 pkt_timestamp_major, pkt_timestamp_minor;\n\tu32 diff, carry;\n\tstruct skb_shared_hwtstamps *timestamps;\n\n\tif (channel->sync_events_state != SYNC_EVENTS_VALID)\n\t\treturn;\n\n\tpkt_timestamp_minor = efx_rx_buf_timestamp_minor(efx, skb_mac_header(skb));\n\n\t \n\tdiff = pkt_timestamp_minor - channel->sync_timestamp_minor;\n\tif (pkt_timestamp_minor < channel->sync_timestamp_minor)\n\t\tdiff += ptp->nic_time.minor_max;\n\n\t \n\tcarry = (channel->sync_timestamp_minor >= ptp->nic_time.minor_max - diff) ?\n\t\t1 : 0;\n\n\tif (diff <= ptp->nic_time.sync_event_diff_max) {\n\t\t \n\t\tpkt_timestamp_major = channel->sync_timestamp_major + carry;\n\t} else if (diff >= ptp->nic_time.sync_event_diff_min) {\n\t\t \n\t\tpkt_timestamp_major = channel->sync_timestamp_major - 1 + carry;\n\t} else {\n\t\t \n\t\tnetif_vdbg(efx, drv, efx->net_dev,\n\t\t\t  \"packet timestamp %x too far from sync event %x:%x\\n\",\n\t\t\t  pkt_timestamp_minor, channel->sync_timestamp_major,\n\t\t\t  channel->sync_timestamp_minor);\n\t\treturn;\n\t}\n\n\t \n\ttimestamps = skb_hwtstamps(skb);\n\ttimestamps->hwtstamp =\n\t\tptp->nic_to_kernel_time(pkt_timestamp_major,\n\t\t\t\t\tpkt_timestamp_minor,\n\t\t\t\t\tptp->ts_corrections.general_rx);\n}\n\nstatic int efx_phc_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct efx_ptp_data *ptp_data = container_of(ptp,\n\t\t\t\t\t\t     struct efx_ptp_data,\n\t\t\t\t\t\t     phc_clock_info);\n\ts32 delta = scaled_ppm_to_ppb(scaled_ppm);\n\tstruct efx_nic *efx = ptp_data->efx;\n\tMCDI_DECLARE_BUF(inadj, MC_CMD_PTP_IN_ADJUST_LEN);\n\ts64 adjustment_ns;\n\tint rc;\n\n\tif (delta > MAX_PPB)\n\t\tdelta = MAX_PPB;\n\telse if (delta < -MAX_PPB)\n\t\tdelta = -MAX_PPB;\n\n\t \n\tadjustment_ns = ((s64)delta * PPB_SCALE_WORD +\n\t\t\t (1 << (ptp_data->adjfreq_ppb_shift - 1))) >>\n\t\t\tptp_data->adjfreq_ppb_shift;\n\n\tMCDI_SET_DWORD(inadj, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);\n\tMCDI_SET_DWORD(inadj, PTP_IN_PERIPH_ID, 0);\n\tMCDI_SET_QWORD(inadj, PTP_IN_ADJUST_FREQ, adjustment_ns);\n\tMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_SECONDS, 0);\n\tMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_NANOSECONDS, 0);\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_PTP, inadj, sizeof(inadj),\n\t\t\t\tNULL, 0, NULL);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tptp_data->current_adjfreq = adjustment_ns;\n\treturn 0;\n}\n\nstatic int efx_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tu32 nic_major, nic_minor;\n\tstruct efx_ptp_data *ptp_data = container_of(ptp,\n\t\t\t\t\t\t     struct efx_ptp_data,\n\t\t\t\t\t\t     phc_clock_info);\n\tstruct efx_nic *efx = ptp_data->efx;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_ADJUST_LEN);\n\n\tefx->ptp_data->ns_to_nic_time(delta, &nic_major, &nic_minor);\n\n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\tMCDI_SET_QWORD(inbuf, PTP_IN_ADJUST_FREQ, ptp_data->current_adjfreq);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_MAJOR, nic_major);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_MINOR, nic_minor);\n\treturn efx_siena_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\n\t\t\t\t  NULL, 0, NULL);\n}\n\nstatic int efx_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct efx_ptp_data *ptp_data = container_of(ptp,\n\t\t\t\t\t\t     struct efx_ptp_data,\n\t\t\t\t\t\t     phc_clock_info);\n\tstruct efx_nic *efx = ptp_data->efx;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_READ_NIC_TIME_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_READ_NIC_TIME_LEN);\n\tint rc;\n\tktime_t kt;\n\n\tMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_READ_NIC_TIME);\n\tMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\n\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), NULL);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tkt = ptp_data->nic_to_kernel_time(\n\t\tMCDI_DWORD(outbuf, PTP_OUT_READ_NIC_TIME_MAJOR),\n\t\tMCDI_DWORD(outbuf, PTP_OUT_READ_NIC_TIME_MINOR), 0);\n\t*ts = ktime_to_timespec64(kt);\n\treturn 0;\n}\n\nstatic int efx_phc_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *e_ts)\n{\n\t \n\tint rc;\n\tstruct timespec64 time_now;\n\tstruct timespec64 delta;\n\n\trc = efx_phc_gettime(ptp, &time_now);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tdelta = timespec64_sub(*e_ts, time_now);\n\n\trc = efx_phc_adjtime(ptp, timespec64_to_ns(&delta));\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int efx_phc_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *request,\n\t\t\t  int enable)\n{\n\tstruct efx_ptp_data *ptp_data = container_of(ptp,\n\t\t\t\t\t\t     struct efx_ptp_data,\n\t\t\t\t\t\t     phc_clock_info);\n\tif (request->type != PTP_CLK_REQ_PPS)\n\t\treturn -EOPNOTSUPP;\n\n\tptp_data->nic_ts_enabled = !!enable;\n\treturn 0;\n}\n\nstatic const struct efx_channel_type efx_ptp_channel_type = {\n\t.handle_no_channel\t= efx_ptp_handle_no_channel,\n\t.pre_probe\t\t= efx_ptp_probe_channel,\n\t.post_remove\t\t= efx_ptp_remove_channel,\n\t.get_name\t\t= efx_ptp_get_channel_name,\n\t \n\t.receive_skb\t\t= efx_ptp_rx,\n\t.want_txqs\t\t= efx_ptp_want_txqs,\n\t.keep_eventq\t\t= false,\n};\n\nvoid efx_siena_ptp_defer_probe_with_channel(struct efx_nic *efx)\n{\n\t \n\tif (efx_ptp_disable(efx) == 0)\n\t\tefx->extra_channel_type[EFX_EXTRA_CHANNEL_PTP] =\n\t\t\t&efx_ptp_channel_type;\n}\n\nvoid efx_siena_ptp_start_datapath(struct efx_nic *efx)\n{\n\tif (efx_ptp_restart(efx))\n\t\tnetif_err(efx, drv, efx->net_dev, \"Failed to restart PTP.\\n\");\n\t \n\tif (efx->type->ptp_set_ts_sync_events)\n\t\tefx->type->ptp_set_ts_sync_events(efx, true, true);\n}\n\nvoid efx_siena_ptp_stop_datapath(struct efx_nic *efx)\n{\n\t \n\tif (efx->type->ptp_set_ts_sync_events)\n\t\tefx->type->ptp_set_ts_sync_events(efx, false, true);\n\tefx_ptp_stop(efx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}