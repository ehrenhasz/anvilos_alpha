{
  "module_name": "mcdi_port_common.c",
  "hash_id": "ab77b3f3981d3a8092aafbd37a98fb543e9000aaac0dd99025e38b59f1a20ad5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/siena/mcdi_port_common.c",
  "human_readable_source": "\n \n\n#include \"mcdi_port_common.h\"\n#include \"efx_common.h\"\n#include \"nic.h\"\n\nstatic int efx_mcdi_get_phy_cfg(struct efx_nic *efx,\n\t\t\t\tstruct efx_mcdi_phy_data *cfg)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PHY_CFG_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_PHY_CFG_IN_LEN != 0);\n\tBUILD_BUG_ON(MC_CMD_GET_PHY_CFG_OUT_NAME_LEN != sizeof(cfg->name));\n\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_GET_PHY_CFG, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (outlen < MC_CMD_GET_PHY_CFG_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\tcfg->flags = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_FLAGS);\n\tcfg->type = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_TYPE);\n\tcfg->supported_cap =\n\t\tMCDI_DWORD(outbuf, GET_PHY_CFG_OUT_SUPPORTED_CAP);\n\tcfg->channel = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_CHANNEL);\n\tcfg->port = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_PRT);\n\tcfg->stats_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_STATS_MASK);\n\tmemcpy(cfg->name, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_NAME),\n\t       sizeof(cfg->name));\n\tcfg->media = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MEDIA_TYPE);\n\tcfg->mmd_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MMD_MASK);\n\tmemcpy(cfg->revision, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_REVISION),\n\t       sizeof(cfg->revision));\n\n\treturn 0;\n\nfail:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nvoid efx_siena_link_set_advertising(struct efx_nic *efx,\n\t\t\t\t    const unsigned long *advertising)\n{\n\tmemcpy(efx->link_advertising, advertising,\n\t       sizeof(__ETHTOOL_DECLARE_LINK_MODE_MASK()));\n\n\tefx->link_advertising[0] |= ADVERTISED_Autoneg;\n\tif (advertising[0] & ADVERTISED_Pause)\n\t\tefx->wanted_fc |= (EFX_FC_TX | EFX_FC_RX);\n\telse\n\t\tefx->wanted_fc &= ~(EFX_FC_TX | EFX_FC_RX);\n\tif (advertising[0] & ADVERTISED_Asym_Pause)\n\t\tefx->wanted_fc ^= EFX_FC_TX;\n}\n\nstatic int efx_mcdi_set_link(struct efx_nic *efx, u32 capabilities,\n\t\t\t     u32 flags, u32 loopback_mode, u32 loopback_speed)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_LINK_IN_LEN);\n\n\tBUILD_BUG_ON(MC_CMD_SET_LINK_OUT_LEN != 0);\n\n\tMCDI_SET_DWORD(inbuf, SET_LINK_IN_CAP, capabilities);\n\tMCDI_SET_DWORD(inbuf, SET_LINK_IN_FLAGS, flags);\n\tMCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_MODE, loopback_mode);\n\tMCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_SPEED, loopback_speed);\n\n\treturn efx_siena_mcdi_rpc(efx, MC_CMD_SET_LINK, inbuf, sizeof(inbuf),\n\t\t\t\t  NULL, 0, NULL);\n}\n\nstatic int efx_mcdi_loopback_modes(struct efx_nic *efx, u64 *loopback_modes)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LOOPBACK_MODES_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_GET_LOOPBACK_MODES, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (outlen < (MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_OFST +\n\t\t      MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_LEN)) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\t*loopback_modes = MCDI_QWORD(outbuf, GET_LOOPBACK_MODES_OUT_SUGGESTED);\n\n\treturn 0;\n\nfail:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic void mcdi_to_ethtool_linkset(u32 media, u32 cap, unsigned long *linkset)\n{\n\t#define SET_BIT(name)\t__set_bit(ETHTOOL_LINK_MODE_ ## name ## _BIT, \\\n\t\t\t\t\t  linkset)\n\n\tbitmap_zero(linkset, __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tswitch (media) {\n\tcase MC_CMD_MEDIA_KX4:\n\t\tSET_BIT(Backplane);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))\n\t\t\tSET_BIT(1000baseKX_Full);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))\n\t\t\tSET_BIT(10000baseKX4_Full);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_40000FDX_LBN))\n\t\t\tSET_BIT(40000baseKR4_Full);\n\t\tbreak;\n\n\tcase MC_CMD_MEDIA_XFP:\n\tcase MC_CMD_MEDIA_SFP_PLUS:\n\tcase MC_CMD_MEDIA_QSFP_PLUS:\n\t\tSET_BIT(FIBRE);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN)) {\n\t\t\tSET_BIT(1000baseT_Full);\n\t\t\tSET_BIT(1000baseX_Full);\n\t\t}\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN)) {\n\t\t\tSET_BIT(10000baseCR_Full);\n\t\t\tSET_BIT(10000baseLR_Full);\n\t\t\tSET_BIT(10000baseSR_Full);\n\t\t}\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_40000FDX_LBN)) {\n\t\t\tSET_BIT(40000baseCR4_Full);\n\t\t\tSET_BIT(40000baseSR4_Full);\n\t\t}\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_100000FDX_LBN)) {\n\t\t\tSET_BIT(100000baseCR4_Full);\n\t\t\tSET_BIT(100000baseSR4_Full);\n\t\t}\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_25000FDX_LBN)) {\n\t\t\tSET_BIT(25000baseCR_Full);\n\t\t\tSET_BIT(25000baseSR_Full);\n\t\t}\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_50000FDX_LBN))\n\t\t\tSET_BIT(50000baseCR2_Full);\n\t\tbreak;\n\n\tcase MC_CMD_MEDIA_BASE_T:\n\t\tSET_BIT(TP);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_10HDX_LBN))\n\t\t\tSET_BIT(10baseT_Half);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_10FDX_LBN))\n\t\t\tSET_BIT(10baseT_Full);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_100HDX_LBN))\n\t\t\tSET_BIT(100baseT_Half);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_100FDX_LBN))\n\t\t\tSET_BIT(100baseT_Full);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_1000HDX_LBN))\n\t\t\tSET_BIT(1000baseT_Half);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))\n\t\t\tSET_BIT(1000baseT_Full);\n\t\tif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))\n\t\t\tSET_BIT(10000baseT_Full);\n\t\tbreak;\n\t}\n\n\tif (cap & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))\n\t\tSET_BIT(Pause);\n\tif (cap & (1 << MC_CMD_PHY_CAP_ASYM_LBN))\n\t\tSET_BIT(Asym_Pause);\n\tif (cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\n\t\tSET_BIT(Autoneg);\n\n\t#undef SET_BIT\n}\n\nstatic u32 ethtool_linkset_to_mcdi_cap(const unsigned long *linkset)\n{\n\tu32 result = 0;\n\n\t#define TEST_BIT(name)\ttest_bit(ETHTOOL_LINK_MODE_ ## name ## _BIT, \\\n\t\t\t\t\t linkset)\n\n\tif (TEST_BIT(10baseT_Half))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_10HDX_LBN);\n\tif (TEST_BIT(10baseT_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_10FDX_LBN);\n\tif (TEST_BIT(100baseT_Half))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_100HDX_LBN);\n\tif (TEST_BIT(100baseT_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_100FDX_LBN);\n\tif (TEST_BIT(1000baseT_Half))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_1000HDX_LBN);\n\tif (TEST_BIT(1000baseT_Full) || TEST_BIT(1000baseKX_Full) ||\n\t\t\tTEST_BIT(1000baseX_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_1000FDX_LBN);\n\tif (TEST_BIT(10000baseT_Full) || TEST_BIT(10000baseKX4_Full) ||\n\t\t\tTEST_BIT(10000baseCR_Full) || TEST_BIT(10000baseLR_Full) ||\n\t\t\tTEST_BIT(10000baseSR_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_10000FDX_LBN);\n\tif (TEST_BIT(40000baseCR4_Full) || TEST_BIT(40000baseKR4_Full) ||\n\t\t\tTEST_BIT(40000baseSR4_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_40000FDX_LBN);\n\tif (TEST_BIT(100000baseCR4_Full) || TEST_BIT(100000baseSR4_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_100000FDX_LBN);\n\tif (TEST_BIT(25000baseCR_Full) || TEST_BIT(25000baseSR_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_25000FDX_LBN);\n\tif (TEST_BIT(50000baseCR2_Full))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_50000FDX_LBN);\n\tif (TEST_BIT(Pause))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_PAUSE_LBN);\n\tif (TEST_BIT(Asym_Pause))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_ASYM_LBN);\n\tif (TEST_BIT(Autoneg))\n\t\tresult |= (1 << MC_CMD_PHY_CAP_AN_LBN);\n\n\t#undef TEST_BIT\n\n\treturn result;\n}\n\nstatic u32 efx_get_mcdi_phy_flags(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\tenum efx_phy_mode mode, supported;\n\tu32 flags;\n\n\t \n\tsupported = 0;\n\tif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_TXDIS_LBN))\n\t\tsupported |= PHY_MODE_TX_DISABLED;\n\tif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_LBN))\n\t\tsupported |= PHY_MODE_LOW_POWER;\n\tif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_POWEROFF_LBN))\n\t\tsupported |= PHY_MODE_OFF;\n\n\tmode = efx->phy_mode & supported;\n\n\tflags = 0;\n\tif (mode & PHY_MODE_TX_DISABLED)\n\t\tflags |= (1 << MC_CMD_SET_LINK_IN_TXDIS_LBN);\n\tif (mode & PHY_MODE_LOW_POWER)\n\t\tflags |= (1 << MC_CMD_SET_LINK_IN_LOWPOWER_LBN);\n\tif (mode & PHY_MODE_OFF)\n\t\tflags |= (1 << MC_CMD_SET_LINK_IN_POWEROFF_LBN);\n\n\treturn flags;\n}\n\nstatic u8 mcdi_to_ethtool_media(u32 media)\n{\n\tswitch (media) {\n\tcase MC_CMD_MEDIA_XAUI:\n\tcase MC_CMD_MEDIA_CX4:\n\tcase MC_CMD_MEDIA_KX4:\n\t\treturn PORT_OTHER;\n\n\tcase MC_CMD_MEDIA_XFP:\n\tcase MC_CMD_MEDIA_SFP_PLUS:\n\tcase MC_CMD_MEDIA_QSFP_PLUS:\n\t\treturn PORT_FIBRE;\n\n\tcase MC_CMD_MEDIA_BASE_T:\n\t\treturn PORT_TP;\n\n\tdefault:\n\t\treturn PORT_OTHER;\n\t}\n}\n\nstatic void efx_mcdi_phy_decode_link(struct efx_nic *efx,\n\t\t\t\t     struct efx_link_state *link_state,\n\t\t\t\t     u32 speed, u32 flags, u32 fcntl)\n{\n\tswitch (fcntl) {\n\tcase MC_CMD_FCNTL_AUTO:\n\t\tWARN_ON(1);\t \n\t\tlink_state->fc = EFX_FC_AUTO | EFX_FC_TX | EFX_FC_RX;\n\t\tbreak;\n\tcase MC_CMD_FCNTL_BIDIR:\n\t\tlink_state->fc = EFX_FC_TX | EFX_FC_RX;\n\t\tbreak;\n\tcase MC_CMD_FCNTL_RESPOND:\n\t\tlink_state->fc = EFX_FC_RX;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase MC_CMD_FCNTL_OFF:\n\t\tlink_state->fc = 0;\n\t\tbreak;\n\t}\n\n\tlink_state->up = !!(flags & (1 << MC_CMD_GET_LINK_OUT_LINK_UP_LBN));\n\tlink_state->fd = !!(flags & (1 << MC_CMD_GET_LINK_OUT_FULL_DUPLEX_LBN));\n\tlink_state->speed = speed;\n}\n\n \nstatic u32 ethtool_fec_caps_to_mcdi(u32 supported_cap, u32 ethtool_cap)\n{\n\tu32 ret = 0;\n\n\tif (ethtool_cap & ETHTOOL_FEC_OFF)\n\t\treturn 0;\n\n\tif (ethtool_cap & ETHTOOL_FEC_AUTO)\n\t\tret |= ((1 << MC_CMD_PHY_CAP_BASER_FEC_LBN) |\n\t\t\t(1 << MC_CMD_PHY_CAP_25G_BASER_FEC_LBN) |\n\t\t\t(1 << MC_CMD_PHY_CAP_RS_FEC_LBN)) & supported_cap;\n\tif (ethtool_cap & ETHTOOL_FEC_RS &&\n\t    supported_cap & (1 << MC_CMD_PHY_CAP_RS_FEC_LBN))\n\t\tret |= (1 << MC_CMD_PHY_CAP_RS_FEC_LBN) |\n\t\t       (1 << MC_CMD_PHY_CAP_RS_FEC_REQUESTED_LBN);\n\tif (ethtool_cap & ETHTOOL_FEC_BASER) {\n\t\tif (supported_cap & (1 << MC_CMD_PHY_CAP_BASER_FEC_LBN))\n\t\t\tret |= (1 << MC_CMD_PHY_CAP_BASER_FEC_LBN) |\n\t\t\t       (1 << MC_CMD_PHY_CAP_BASER_FEC_REQUESTED_LBN);\n\t\tif (supported_cap & (1 << MC_CMD_PHY_CAP_25G_BASER_FEC_LBN))\n\t\t\tret |= (1 << MC_CMD_PHY_CAP_25G_BASER_FEC_LBN) |\n\t\t\t       (1 << MC_CMD_PHY_CAP_25G_BASER_FEC_REQUESTED_LBN);\n\t}\n\treturn ret;\n}\n\n \nstatic u32 mcdi_fec_caps_to_ethtool(u32 caps, bool is_25g)\n{\n\tbool rs = caps & (1 << MC_CMD_PHY_CAP_RS_FEC_LBN),\n\t     rs_req = caps & (1 << MC_CMD_PHY_CAP_RS_FEC_REQUESTED_LBN),\n\t     baser = is_25g ? caps & (1 << MC_CMD_PHY_CAP_25G_BASER_FEC_LBN)\n\t\t\t    : caps & (1 << MC_CMD_PHY_CAP_BASER_FEC_LBN),\n\t     baser_req = is_25g ? caps & (1 << MC_CMD_PHY_CAP_25G_BASER_FEC_REQUESTED_LBN)\n\t\t\t\t: caps & (1 << MC_CMD_PHY_CAP_BASER_FEC_REQUESTED_LBN);\n\n\tif (!baser && !rs)\n\t\treturn ETHTOOL_FEC_OFF;\n\treturn (rs_req ? ETHTOOL_FEC_RS : 0) |\n\t       (baser_req ? ETHTOOL_FEC_BASER : 0) |\n\t       (baser == baser_req && rs == rs_req ? 0 : ETHTOOL_FEC_AUTO);\n}\n\n \nstatic void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\tu32 rmtadv;\n\n\t \n\tif (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\n\t\treturn;\n\n\t \n\tif (efx->wanted_fc & EFX_FC_AUTO)\n\t\treturn;\n\n\trmtadv = 0;\n\tif (lpa & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))\n\t\trmtadv |= ADVERTISED_Pause;\n\tif (lpa & (1 << MC_CMD_PHY_CAP_ASYM_LBN))\n\t\trmtadv |=  ADVERTISED_Asym_Pause;\n\n\tif ((efx->wanted_fc & EFX_FC_TX) && rmtadv == ADVERTISED_Asym_Pause)\n\t\tnetif_err(efx, link, efx->net_dev,\n\t\t\t  \"warning: link partner doesn't support pause frames\");\n}\n\nbool efx_siena_mcdi_phy_poll(struct efx_nic *efx)\n{\n\tstruct efx_link_state old_state = efx->link_state;\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_LEN);\n\tint rc;\n\n\tWARN_ON(!mutex_is_locked(&efx->mac_lock));\n\n\tBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\n\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), NULL);\n\tif (rc)\n\t\tefx->link_state.up = false;\n\telse\n\t\tefx_mcdi_phy_decode_link(\n\t\t\tefx, &efx->link_state,\n\t\t\tMCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),\n\t\t\tMCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),\n\t\t\tMCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));\n\n\treturn !efx_link_state_equal(&efx->link_state, &old_state);\n}\n\nint efx_siena_mcdi_phy_probe(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_phy_data *phy_data;\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_LEN);\n\tu32 caps;\n\tint rc;\n\n\t \n\tphy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);\n\tif (phy_data == NULL)\n\t\treturn -ENOMEM;\n\n\trc = efx_mcdi_get_phy_cfg(efx, phy_data);\n\tif (rc != 0)\n\t\tgoto fail;\n\n\t \n\tBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), NULL);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\tefx->phy_data = phy_data;\n\tefx->phy_type = phy_data->type;\n\n\tefx->mdio_bus = phy_data->channel;\n\tefx->mdio.prtad = phy_data->port;\n\tefx->mdio.mmds = phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22);\n\tefx->mdio.mode_support = 0;\n\tif (phy_data->mmd_mask & (1 << MC_CMD_MMD_CLAUSE22))\n\t\tefx->mdio.mode_support |= MDIO_SUPPORTS_C22;\n\tif (phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22))\n\t\tefx->mdio.mode_support |= MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\n\n\tcaps = MCDI_DWORD(outbuf, GET_LINK_OUT_CAP);\n\tif (caps & (1 << MC_CMD_PHY_CAP_AN_LBN))\n\t\tmcdi_to_ethtool_linkset(phy_data->media, caps,\n\t\t\t\t\tefx->link_advertising);\n\telse\n\t\tphy_data->forced_cap = caps;\n\n\t \n\tBUILD_BUG_ON(LOOPBACK_NONE != MC_CMD_LOOPBACK_NONE);\n\tBUILD_BUG_ON(LOOPBACK_DATA != MC_CMD_LOOPBACK_DATA);\n\tBUILD_BUG_ON(LOOPBACK_GMAC != MC_CMD_LOOPBACK_GMAC);\n\tBUILD_BUG_ON(LOOPBACK_XGMII != MC_CMD_LOOPBACK_XGMII);\n\tBUILD_BUG_ON(LOOPBACK_XGXS != MC_CMD_LOOPBACK_XGXS);\n\tBUILD_BUG_ON(LOOPBACK_XAUI != MC_CMD_LOOPBACK_XAUI);\n\tBUILD_BUG_ON(LOOPBACK_GMII != MC_CMD_LOOPBACK_GMII);\n\tBUILD_BUG_ON(LOOPBACK_SGMII != MC_CMD_LOOPBACK_SGMII);\n\tBUILD_BUG_ON(LOOPBACK_XGBR != MC_CMD_LOOPBACK_XGBR);\n\tBUILD_BUG_ON(LOOPBACK_XFI != MC_CMD_LOOPBACK_XFI);\n\tBUILD_BUG_ON(LOOPBACK_XAUI_FAR != MC_CMD_LOOPBACK_XAUI_FAR);\n\tBUILD_BUG_ON(LOOPBACK_GMII_FAR != MC_CMD_LOOPBACK_GMII_FAR);\n\tBUILD_BUG_ON(LOOPBACK_SGMII_FAR != MC_CMD_LOOPBACK_SGMII_FAR);\n\tBUILD_BUG_ON(LOOPBACK_XFI_FAR != MC_CMD_LOOPBACK_XFI_FAR);\n\tBUILD_BUG_ON(LOOPBACK_GPHY != MC_CMD_LOOPBACK_GPHY);\n\tBUILD_BUG_ON(LOOPBACK_PHYXS != MC_CMD_LOOPBACK_PHYXS);\n\tBUILD_BUG_ON(LOOPBACK_PCS != MC_CMD_LOOPBACK_PCS);\n\tBUILD_BUG_ON(LOOPBACK_PMAPMD != MC_CMD_LOOPBACK_PMAPMD);\n\tBUILD_BUG_ON(LOOPBACK_XPORT != MC_CMD_LOOPBACK_XPORT);\n\tBUILD_BUG_ON(LOOPBACK_XGMII_WS != MC_CMD_LOOPBACK_XGMII_WS);\n\tBUILD_BUG_ON(LOOPBACK_XAUI_WS != MC_CMD_LOOPBACK_XAUI_WS);\n\tBUILD_BUG_ON(LOOPBACK_XAUI_WS_FAR != MC_CMD_LOOPBACK_XAUI_WS_FAR);\n\tBUILD_BUG_ON(LOOPBACK_XAUI_WS_NEAR != MC_CMD_LOOPBACK_XAUI_WS_NEAR);\n\tBUILD_BUG_ON(LOOPBACK_GMII_WS != MC_CMD_LOOPBACK_GMII_WS);\n\tBUILD_BUG_ON(LOOPBACK_XFI_WS != MC_CMD_LOOPBACK_XFI_WS);\n\tBUILD_BUG_ON(LOOPBACK_XFI_WS_FAR != MC_CMD_LOOPBACK_XFI_WS_FAR);\n\tBUILD_BUG_ON(LOOPBACK_PHYXS_WS != MC_CMD_LOOPBACK_PHYXS_WS);\n\n\trc = efx_mcdi_loopback_modes(efx, &efx->loopback_modes);\n\tif (rc != 0)\n\t\tgoto fail;\n\t \n\tefx->loopback_modes &= ~(1 << LOOPBACK_NONE);\n\n\t \n\tefx_mcdi_phy_decode_link(efx, &efx->link_state,\n\t\t\t\t MCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),\n\t\t\t\t MCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),\n\t\t\t\t MCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));\n\n\t \n\tefx->fec_config = mcdi_fec_caps_to_ethtool(caps,\n\t\t\t\t\t\t   efx->link_state.speed == 25000 ||\n\t\t\t\t\t\t   efx->link_state.speed == 50000);\n\n\t \n\tefx->wanted_fc = EFX_FC_RX | EFX_FC_TX;\n\tif (phy_data->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\n\t\tefx->wanted_fc |= EFX_FC_AUTO;\n\tefx_siena_link_set_wanted_fc(efx, efx->wanted_fc);\n\n\treturn 0;\n\nfail:\n\tkfree(phy_data);\n\treturn rc;\n}\n\nvoid efx_siena_mcdi_phy_remove(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_phy_data *phy_data = efx->phy_data;\n\n\tefx->phy_data = NULL;\n\tkfree(phy_data);\n}\n\nvoid efx_siena_mcdi_phy_get_link_ksettings(struct efx_nic *efx,\n\t\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_LEN);\n\tint rc;\n\n\tcmd->base.speed = efx->link_state.speed;\n\tcmd->base.duplex = efx->link_state.fd;\n\tcmd->base.port = mcdi_to_ethtool_media(phy_cfg->media);\n\tcmd->base.phy_address = phy_cfg->port;\n\tcmd->base.autoneg = !!(efx->link_advertising[0] & ADVERTISED_Autoneg);\n\tcmd->base.mdio_support = (efx->mdio.mode_support &\n\t\t\t      (MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22));\n\n\tmcdi_to_ethtool_linkset(phy_cfg->media, phy_cfg->supported_cap,\n\t\t\t\tcmd->link_modes.supported);\n\tmemcpy(cmd->link_modes.advertising, efx->link_advertising,\n\t       sizeof(__ETHTOOL_DECLARE_LINK_MODE_MASK()));\n\n\tBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), NULL);\n\tif (rc)\n\t\treturn;\n\tmcdi_to_ethtool_linkset(phy_cfg->media,\n\t\t\t\tMCDI_DWORD(outbuf, GET_LINK_OUT_LP_CAP),\n\t\t\t\tcmd->link_modes.lp_advertising);\n}\n\nint\nefx_siena_mcdi_phy_set_link_ksettings(struct efx_nic *efx,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\tu32 caps;\n\tint rc;\n\n\tif (cmd->base.autoneg) {\n\t\tcaps = (ethtool_linkset_to_mcdi_cap(cmd->link_modes.advertising) |\n\t\t\t1 << MC_CMD_PHY_CAP_AN_LBN);\n\t} else if (cmd->base.duplex) {\n\t\tswitch (cmd->base.speed) {\n\t\tcase 10:     caps = 1 << MC_CMD_PHY_CAP_10FDX_LBN;     break;\n\t\tcase 100:    caps = 1 << MC_CMD_PHY_CAP_100FDX_LBN;    break;\n\t\tcase 1000:   caps = 1 << MC_CMD_PHY_CAP_1000FDX_LBN;   break;\n\t\tcase 10000:  caps = 1 << MC_CMD_PHY_CAP_10000FDX_LBN;  break;\n\t\tcase 40000:  caps = 1 << MC_CMD_PHY_CAP_40000FDX_LBN;  break;\n\t\tcase 100000: caps = 1 << MC_CMD_PHY_CAP_100000FDX_LBN; break;\n\t\tcase 25000:  caps = 1 << MC_CMD_PHY_CAP_25000FDX_LBN;  break;\n\t\tcase 50000:  caps = 1 << MC_CMD_PHY_CAP_50000FDX_LBN;  break;\n\t\tdefault:     return -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (cmd->base.speed) {\n\t\tcase 10:     caps = 1 << MC_CMD_PHY_CAP_10HDX_LBN;     break;\n\t\tcase 100:    caps = 1 << MC_CMD_PHY_CAP_100HDX_LBN;    break;\n\t\tcase 1000:   caps = 1 << MC_CMD_PHY_CAP_1000HDX_LBN;   break;\n\t\tdefault:     return -EINVAL;\n\t\t}\n\t}\n\n\tcaps |= ethtool_fec_caps_to_mcdi(phy_cfg->supported_cap, efx->fec_config);\n\n\trc = efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),\n\t\t\t       efx->loopback_mode, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cmd->base.autoneg) {\n\t\tefx_siena_link_set_advertising(efx, cmd->link_modes.advertising);\n\t\tphy_cfg->forced_cap = 0;\n\t} else {\n\t\tefx_siena_link_clear_advertising(efx);\n\t\tphy_cfg->forced_cap = caps;\n\t}\n\treturn 0;\n}\n\nint efx_siena_mcdi_phy_get_fecparam(struct efx_nic *efx,\n\t\t\t\t    struct ethtool_fecparam *fec)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_V2_LEN);\n\tu32 caps, active, speed;  \n\tbool is_25g = false;\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_GET_LINK_OUT_V2_LEN)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tspeed = MCDI_DWORD(outbuf, GET_LINK_OUT_V2_LINK_SPEED);\n\tis_25g = speed == 25000 || speed == 50000;\n\n\tcaps = MCDI_DWORD(outbuf, GET_LINK_OUT_V2_CAP);\n\tfec->fec = mcdi_fec_caps_to_ethtool(caps, is_25g);\n\t \n\tif (speed == 100000)\n\t\tfec->fec &= ~ETHTOOL_FEC_BASER;\n\n\tactive = MCDI_DWORD(outbuf, GET_LINK_OUT_V2_FEC_TYPE);\n\tswitch (active) {\n\tcase MC_CMD_FEC_NONE:\n\t\tfec->active_fec = ETHTOOL_FEC_OFF;\n\t\tbreak;\n\tcase MC_CMD_FEC_BASER:\n\t\tfec->active_fec = ETHTOOL_FEC_BASER;\n\t\tbreak;\n\tcase MC_CMD_FEC_RS:\n\t\tfec->active_fec = ETHTOOL_FEC_RS;\n\t\tbreak;\n\tdefault:\n\t\tnetif_warn(efx, hw, efx->net_dev,\n\t\t\t   \"Firmware reports unrecognised FEC_TYPE %u\\n\",\n\t\t\t   active);\n\t\t \n\t\tfec->active_fec = ETHTOOL_FEC_AUTO;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ethtool_fec_supported(u32 supported_cap, u32 ethtool_cap)\n{\n\tif (ethtool_cap & ETHTOOL_FEC_OFF)\n\t\treturn 0;\n\n\tif (ethtool_cap &&\n\t    !ethtool_fec_caps_to_mcdi(supported_cap, ethtool_cap))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint efx_siena_mcdi_phy_set_fecparam(struct efx_nic *efx,\n\t\t\t\t    const struct ethtool_fecparam *fec)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\tu32 caps;\n\tint rc;\n\n\trc = ethtool_fec_supported(phy_cfg->supported_cap, fec->fec);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, efx->link_advertising))\n\t\tcaps = (ethtool_linkset_to_mcdi_cap(efx->link_advertising) |\n\t\t\t1 << MC_CMD_PHY_CAP_AN_LBN);\n\telse\n\t\tcaps = phy_cfg->forced_cap;\n\n\tcaps |= ethtool_fec_caps_to_mcdi(phy_cfg->supported_cap, fec->fec);\n\trc = efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),\n\t\t\t       efx->loopback_mode, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tefx->fec_config = fec->fec;\n\treturn 0;\n}\n\nint efx_siena_mcdi_phy_test_alive(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PHY_STATE_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_PHY_STATE_IN_LEN != 0);\n\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_GET_PHY_STATE, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\n\tif (outlen < MC_CMD_GET_PHY_STATE_OUT_LEN)\n\t\treturn -EIO;\n\tif (MCDI_DWORD(outbuf, GET_PHY_STATE_OUT_STATE) != MC_CMD_PHY_STATE_OK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint efx_siena_mcdi_port_reconfigure(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\tu32 caps = (efx->link_advertising[0] ?\n\t\t    ethtool_linkset_to_mcdi_cap(efx->link_advertising) :\n\t\t    phy_cfg->forced_cap);\n\n\tcaps |= ethtool_fec_caps_to_mcdi(phy_cfg->supported_cap, efx->fec_config);\n\n\treturn efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),\n\t\t\t\t efx->loopback_mode, 0);\n}\n\nstatic const char *const mcdi_sft9001_cable_diag_names[] = {\n\t\"cable.pairA.length\",\n\t\"cable.pairB.length\",\n\t\"cable.pairC.length\",\n\t\"cable.pairD.length\",\n\t\"cable.pairA.status\",\n\t\"cable.pairB.status\",\n\t\"cable.pairC.status\",\n\t\"cable.pairD.status\",\n};\n\nstatic int efx_mcdi_bist(struct efx_nic *efx, unsigned int bist_mode,\n\t\t\t int *results)\n{\n\tunsigned int retry, i, count = 0;\n\tsize_t outlen;\n\tu32 status;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_START_BIST_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_POLL_BIST_OUT_SFT9001_LEN);\n\tu8 *ptr;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_START_BIST_OUT_LEN != 0);\n\tMCDI_SET_DWORD(inbuf, START_BIST_IN_TYPE, bist_mode);\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_START_BIST, inbuf,\n\t\t\t\tMC_CMD_START_BIST_IN_LEN, NULL, 0, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tfor (retry = 0; retry < 100; ++retry) {\n\t\tBUILD_BUG_ON(MC_CMD_POLL_BIST_IN_LEN != 0);\n\t\trc = efx_siena_mcdi_rpc(efx, MC_CMD_POLL_BIST, NULL, 0,\n\t\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tstatus = MCDI_DWORD(outbuf, POLL_BIST_OUT_RESULT);\n\t\tif (status != MC_CMD_POLL_BIST_RUNNING)\n\t\t\tgoto finished;\n\n\t\tmsleep(100);\n\t}\n\n\trc = -ETIMEDOUT;\n\tgoto out;\n\nfinished:\n\tresults[count++] = (status == MC_CMD_POLL_BIST_PASSED) ? 1 : -1;\n\n\t \n\tif (efx->phy_type == PHY_TYPE_SFT9001B &&\n\t    (bist_mode == MC_CMD_PHY_BIST_CABLE_SHORT ||\n\t     bist_mode == MC_CMD_PHY_BIST_CABLE_LONG)) {\n\t\tptr = MCDI_PTR(outbuf, POLL_BIST_OUT_SFT9001_CABLE_LENGTH_A);\n\t\tif (status == MC_CMD_POLL_BIST_PASSED &&\n\t\t    outlen >= MC_CMD_POLL_BIST_OUT_SFT9001_LEN) {\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tresults[count + i] =\n\t\t\t\t\tEFX_DWORD_FIELD(((efx_dword_t *)ptr)[i],\n\t\t\t\t\t\t\tEFX_DWORD_0);\n\t\t\t}\n\t\t}\n\t\tcount += 8;\n\t}\n\trc = count;\n\nout:\n\treturn rc;\n}\n\nint efx_siena_mcdi_phy_run_tests(struct efx_nic *efx, int *results,\n\t\t\t\t unsigned int flags)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\tu32 mode;\n\tint rc;\n\n\tif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {\n\t\trc = efx_mcdi_bist(efx, MC_CMD_PHY_BIST, results);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tresults += rc;\n\t}\n\n\t \n\tmode = 0;\n\tif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN)) {\n\t\tif ((flags & ETH_TEST_FL_OFFLINE) &&\n\t\t    (phy_cfg->flags &\n\t\t     (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN)))\n\t\t\tmode = MC_CMD_PHY_BIST_CABLE_LONG;\n\t\telse\n\t\t\tmode = MC_CMD_PHY_BIST_CABLE_SHORT;\n\t} else if (phy_cfg->flags &\n\t\t   (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))\n\t\tmode = MC_CMD_PHY_BIST_CABLE_LONG;\n\n\tif (mode != 0) {\n\t\trc = efx_mcdi_bist(efx, mode, results);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tresults += rc;\n\t}\n\n\treturn 0;\n}\n\nconst char *efx_siena_mcdi_phy_test_name(struct efx_nic *efx,\n\t\t\t\t\t unsigned int index)\n{\n\tstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\n\n\tif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {\n\t\tif (index == 0)\n\t\t\treturn \"bist\";\n\t\t--index;\n\t}\n\n\tif (phy_cfg->flags & ((1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN) |\n\t\t\t      (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))) {\n\t\tif (index == 0)\n\t\t\treturn \"cable\";\n\t\t--index;\n\n\t\tif (efx->phy_type == PHY_TYPE_SFT9001B) {\n\t\t\tif (index < ARRAY_SIZE(mcdi_sft9001_cable_diag_names))\n\t\t\t\treturn mcdi_sft9001_cable_diag_names[index];\n\t\t\tindex -= ARRAY_SIZE(mcdi_sft9001_cable_diag_names);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#define SFP_PAGE_SIZE\t\t128\n#define SFF_DIAG_TYPE_OFFSET\t92\n#define SFF_DIAG_ADDR_CHANGE\tBIT(2)\n#define SFF_8079_NUM_PAGES\t2\n#define SFF_8472_NUM_PAGES\t4\n#define SFF_8436_NUM_PAGES\t5\n#define SFF_DMT_LEVEL_OFFSET\t94\n\n \nstatic int efx_mcdi_phy_get_module_eeprom_page(struct efx_nic *efx,\n\t\t\t\t\t       unsigned int page,\n\t\t\t\t\t       u8 *data, ssize_t offset,\n\t\t\t\t\t       ssize_t space)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PHY_MEDIA_INFO_OUT_LENMAX);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_PHY_MEDIA_INFO_IN_LEN);\n\tunsigned int payload_len;\n\tunsigned int to_copy;\n\tsize_t outlen;\n\tint rc;\n\n\tif (offset > SFP_PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tto_copy = min(space, SFP_PAGE_SIZE - offset);\n\n\tMCDI_SET_DWORD(inbuf, GET_PHY_MEDIA_INFO_IN_PAGE, page);\n\trc = efx_siena_mcdi_rpc_quiet(efx, MC_CMD_GET_PHY_MEDIA_INFO,\n\t\t\t\t      inbuf, sizeof(inbuf),\n\t\t\t\t      outbuf, sizeof(outbuf),\n\t\t\t\t      &outlen);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (outlen < (MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_OFST +\n\t\t\tSFP_PAGE_SIZE))\n\t\treturn -EIO;\n\n\tpayload_len = MCDI_DWORD(outbuf, GET_PHY_MEDIA_INFO_OUT_DATALEN);\n\tif (payload_len != SFP_PAGE_SIZE)\n\t\treturn -EIO;\n\n\tmemcpy(data, MCDI_PTR(outbuf, GET_PHY_MEDIA_INFO_OUT_DATA) + offset,\n\t       to_copy);\n\n\treturn to_copy;\n}\n\nstatic int efx_mcdi_phy_get_module_eeprom_byte(struct efx_nic *efx,\n\t\t\t\t\t       unsigned int page,\n\t\t\t\t\t       u8 byte)\n{\n\tu8 data;\n\tint rc;\n\n\trc = efx_mcdi_phy_get_module_eeprom_page(efx, page, &data, byte, 1);\n\tif (rc == 1)\n\t\treturn data;\n\n\treturn rc;\n}\n\nstatic int efx_mcdi_phy_diag_type(struct efx_nic *efx)\n{\n\t \n\treturn efx_mcdi_phy_get_module_eeprom_byte(efx, 0,\n\t\t\t\t\t\t   SFF_DIAG_TYPE_OFFSET);\n}\n\nstatic int efx_mcdi_phy_sff_8472_level(struct efx_nic *efx)\n{\n\t \n\treturn efx_mcdi_phy_get_module_eeprom_byte(efx, 0,\n\t\t\t\t\t\t   SFF_DMT_LEVEL_OFFSET);\n}\n\nstatic u32 efx_mcdi_phy_module_type(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_phy_data *phy_data = efx->phy_data;\n\n\tif (phy_data->media != MC_CMD_MEDIA_QSFP_PLUS)\n\t\treturn phy_data->media;\n\n\t \n\tswitch (efx_mcdi_phy_get_module_eeprom_byte(efx, 0, 0)) {\n\tcase 0x3:\n\t\treturn MC_CMD_MEDIA_SFP_PLUS;\n\tcase 0xc:\n\tcase 0xd:\n\t\treturn MC_CMD_MEDIA_QSFP_PLUS;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint efx_siena_mcdi_phy_get_module_eeprom(struct efx_nic *efx,\n\t\t\t\t\t struct ethtool_eeprom *ee, u8 *data)\n{\n\tint rc;\n\tssize_t space_remaining = ee->len;\n\tunsigned int page_off;\n\tbool ignore_missing;\n\tint num_pages;\n\tint page;\n\n\tswitch (efx_mcdi_phy_module_type(efx)) {\n\tcase MC_CMD_MEDIA_SFP_PLUS:\n\t\tnum_pages = efx_mcdi_phy_sff_8472_level(efx) > 0 ?\n\t\t\t\tSFF_8472_NUM_PAGES : SFF_8079_NUM_PAGES;\n\t\tpage = 0;\n\t\tignore_missing = false;\n\t\tbreak;\n\tcase MC_CMD_MEDIA_QSFP_PLUS:\n\t\tnum_pages = SFF_8436_NUM_PAGES;\n\t\tpage = -1;  \n\t\tignore_missing = true;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpage_off = ee->offset % SFP_PAGE_SIZE;\n\tpage += ee->offset / SFP_PAGE_SIZE;\n\n\twhile (space_remaining && (page < num_pages)) {\n\t\trc = efx_mcdi_phy_get_module_eeprom_page(efx, page,\n\t\t\t\t\t\t\t data, page_off,\n\t\t\t\t\t\t\t space_remaining);\n\n\t\tif (rc > 0) {\n\t\t\tspace_remaining -= rc;\n\t\t\tdata += rc;\n\t\t\tpage_off = 0;\n\t\t\tpage++;\n\t\t} else if (rc == 0) {\n\t\t\tspace_remaining = 0;\n\t\t} else if (ignore_missing && (page > 0)) {\n\t\t\tint intended_size = SFP_PAGE_SIZE - page_off;\n\n\t\t\tspace_remaining -= intended_size;\n\t\t\tif (space_remaining < 0) {\n\t\t\t\tspace_remaining = 0;\n\t\t\t} else {\n\t\t\t\tmemset(data, 0, intended_size);\n\t\t\t\tdata += intended_size;\n\t\t\t\tpage_off = 0;\n\t\t\t\tpage++;\n\t\t\t\trc = 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint efx_siena_mcdi_phy_get_module_info(struct efx_nic *efx, struct ethtool_modinfo *modinfo)\n{\n\tint sff_8472_level;\n\tint diag_type;\n\n\tswitch (efx_mcdi_phy_module_type(efx)) {\n\tcase MC_CMD_MEDIA_SFP_PLUS:\n\t\tsff_8472_level = efx_mcdi_phy_sff_8472_level(efx);\n\n\t\t \n\t\tif (sff_8472_level < 0)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tdiag_type = efx_mcdi_phy_diag_type(efx);\n\n\t\tif (sff_8472_level == 0 ||\n\t\t    (diag_type & SFF_DIAG_ADDR_CHANGE)) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\t}\n\t\tbreak;\n\n\tcase MC_CMD_MEDIA_QSFP_PLUS:\n\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int efx_calc_mac_mtu(struct efx_nic *efx)\n{\n\treturn EFX_MAX_FRAME_LEN(efx->net_dev->mtu);\n}\n\nint efx_siena_mcdi_set_mac(struct efx_nic *efx)\n{\n\tu32 fcntl;\n\tMCDI_DECLARE_BUF(cmdbytes, MC_CMD_SET_MAC_IN_LEN);\n\n\tBUILD_BUG_ON(MC_CMD_SET_MAC_OUT_LEN != 0);\n\n\t \n\tether_addr_copy(MCDI_PTR(cmdbytes, SET_MAC_IN_ADDR),\n\t\t\tefx->net_dev->dev_addr);\n\n\tMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_MTU, efx_calc_mac_mtu(efx));\n\tMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_DRAIN, 0);\n\n\t \n\tMCDI_POPULATE_DWORD_1(cmdbytes, SET_MAC_IN_REJECT,\n\t\t\t      SET_MAC_IN_REJECT_UNCST, efx->unicast_filter);\n\n\tMCDI_POPULATE_DWORD_1(cmdbytes, SET_MAC_IN_FLAGS,\n\t\t\t      SET_MAC_IN_FLAG_INCLUDE_FCS,\n\t\t\t      !!(efx->net_dev->features & NETIF_F_RXFCS));\n\n\tswitch (efx->wanted_fc) {\n\tcase EFX_FC_RX | EFX_FC_TX:\n\t\tfcntl = MC_CMD_FCNTL_BIDIR;\n\t\tbreak;\n\tcase EFX_FC_RX:\n\t\tfcntl = MC_CMD_FCNTL_RESPOND;\n\t\tbreak;\n\tdefault:\n\t\tfcntl = MC_CMD_FCNTL_OFF;\n\t\tbreak;\n\t}\n\tif (efx->wanted_fc & EFX_FC_AUTO)\n\t\tfcntl = MC_CMD_FCNTL_AUTO;\n\tif (efx->fc_disable)\n\t\tfcntl = MC_CMD_FCNTL_OFF;\n\n\tMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_FCNTL, fcntl);\n\n\treturn efx_siena_mcdi_rpc(efx, MC_CMD_SET_MAC, cmdbytes,\n\t\t\t\t  sizeof(cmdbytes), NULL, 0, NULL);\n}\n\nenum efx_stats_action {\n\tEFX_STATS_ENABLE,\n\tEFX_STATS_DISABLE,\n\tEFX_STATS_PULL,\n};\n\nstatic int efx_mcdi_mac_stats(struct efx_nic *efx,\n\t\t\t      enum efx_stats_action action, int clear)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_MAC_STATS_IN_LEN);\n\tint rc;\n\tint change = action == EFX_STATS_PULL ? 0 : 1;\n\tint enable = action == EFX_STATS_ENABLE ? 1 : 0;\n\tint period = action == EFX_STATS_ENABLE ? 1000 : 0;\n\tdma_addr_t dma_addr = efx->stats_buffer.dma_addr;\n\tu32 dma_len = action != EFX_STATS_DISABLE ?\n\t\tefx->num_mac_stats * sizeof(u64) : 0;\n\n\tBUILD_BUG_ON(MC_CMD_MAC_STATS_OUT_DMA_LEN != 0);\n\n\tMCDI_SET_QWORD(inbuf, MAC_STATS_IN_DMA_ADDR, dma_addr);\n\tMCDI_POPULATE_DWORD_7(inbuf, MAC_STATS_IN_CMD,\n\t\t\t      MAC_STATS_IN_DMA, !!enable,\n\t\t\t      MAC_STATS_IN_CLEAR, clear,\n\t\t\t      MAC_STATS_IN_PERIODIC_CHANGE, change,\n\t\t\t      MAC_STATS_IN_PERIODIC_ENABLE, enable,\n\t\t\t      MAC_STATS_IN_PERIODIC_CLEAR, 0,\n\t\t\t      MAC_STATS_IN_PERIODIC_NOEVENT, 1,\n\t\t\t      MAC_STATS_IN_PERIOD_MS, period);\n\tMCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_LEN, dma_len);\n\n\tif (efx_nic_rev(efx) >= EFX_REV_HUNT_A0)\n\t\tMCDI_SET_DWORD(inbuf, MAC_STATS_IN_PORT_ID, efx->vport_id);\n\n\trc = efx_siena_mcdi_rpc_quiet(efx, MC_CMD_MAC_STATS, inbuf,\n\t\t\t\t      sizeof(inbuf), NULL, 0, NULL);\n\t \n\tif (rc && (rc != -ENOENT || atomic_read(&efx->active_queues)))\n\t\tefx_siena_mcdi_display_error(efx, MC_CMD_MAC_STATS,\n\t\t\t\t\t     sizeof(inbuf), NULL, 0, rc);\n\treturn rc;\n}\n\nvoid efx_siena_mcdi_mac_start_stats(struct efx_nic *efx)\n{\n\t__le64 *dma_stats = efx->stats_buffer.addr;\n\n\tdma_stats[efx->num_mac_stats - 1] = EFX_MC_STATS_GENERATION_INVALID;\n\n\tefx_mcdi_mac_stats(efx, EFX_STATS_ENABLE, 0);\n}\n\nvoid efx_siena_mcdi_mac_stop_stats(struct efx_nic *efx)\n{\n\tefx_mcdi_mac_stats(efx, EFX_STATS_DISABLE, 0);\n}\n\n#define EFX_MAC_STATS_WAIT_US 100\n#define EFX_MAC_STATS_WAIT_ATTEMPTS 10\n\nvoid efx_siena_mcdi_mac_pull_stats(struct efx_nic *efx)\n{\n\t__le64 *dma_stats = efx->stats_buffer.addr;\n\tint attempts = EFX_MAC_STATS_WAIT_ATTEMPTS;\n\n\tdma_stats[efx->num_mac_stats - 1] = EFX_MC_STATS_GENERATION_INVALID;\n\tefx_mcdi_mac_stats(efx, EFX_STATS_PULL, 0);\n\n\twhile (dma_stats[efx->num_mac_stats - 1] ==\n\t\t\t\tEFX_MC_STATS_GENERATION_INVALID &&\n\t\t\tattempts-- != 0)\n\t\tudelay(EFX_MAC_STATS_WAIT_US);\n}\n\nint efx_siena_mcdi_mac_init_stats(struct efx_nic *efx)\n{\n\tint rc;\n\n\tif (!efx->num_mac_stats)\n\t\treturn 0;\n\n\t \n\trc = efx_siena_alloc_buffer(efx, &efx->stats_buffer,\n\t\t\t\t    efx->num_mac_stats * sizeof(u64),\n\t\t\t\t    GFP_KERNEL);\n\tif (rc) {\n\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t   \"failed to allocate DMA buffer: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"stats buffer at %llx (virt %p phys %llx)\\n\",\n\t\t  (u64) efx->stats_buffer.dma_addr,\n\t\t  efx->stats_buffer.addr,\n\t\t  (u64) virt_to_phys(efx->stats_buffer.addr));\n\n\treturn 0;\n}\n\nvoid efx_siena_mcdi_mac_fini_stats(struct efx_nic *efx)\n{\n\tefx_siena_free_buffer(efx, &efx->stats_buffer);\n}\n\nstatic unsigned int efx_mcdi_event_link_speed[] = {\n\t[MCDI_EVENT_LINKCHANGE_SPEED_100M] = 100,\n\t[MCDI_EVENT_LINKCHANGE_SPEED_1G] = 1000,\n\t[MCDI_EVENT_LINKCHANGE_SPEED_10G] = 10000,\n\t[MCDI_EVENT_LINKCHANGE_SPEED_40G] = 40000,\n\t[MCDI_EVENT_LINKCHANGE_SPEED_25G] = 25000,\n\t[MCDI_EVENT_LINKCHANGE_SPEED_50G] = 50000,\n\t[MCDI_EVENT_LINKCHANGE_SPEED_100G] = 100000,\n};\n\nvoid efx_siena_mcdi_process_link_change(struct efx_nic *efx, efx_qword_t *ev)\n{\n\tu32 flags, fcntl, speed, lpa;\n\n\tspeed = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_SPEED);\n\tEFX_WARN_ON_PARANOID(speed >= ARRAY_SIZE(efx_mcdi_event_link_speed));\n\tspeed = efx_mcdi_event_link_speed[speed];\n\n\tflags = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LINK_FLAGS);\n\tfcntl = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_FCNTL);\n\tlpa = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LP_CAP);\n\n\t \n\tefx_mcdi_phy_decode_link(efx, &efx->link_state, speed, flags, fcntl);\n\n\tefx_mcdi_phy_check_fcntl(efx, lpa);\n\n\tefx_siena_link_status_changed(efx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}