{
  "module_name": "io.h",
  "hash_id": "e781fd1b046dad01888ccb669f65cd205bba133814be657fa2328321b9d95489",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/siena/io.h",
  "human_readable_source": " \n \n\n#ifndef EFX_IO_H\n#define EFX_IO_H\n\n#include <linux/io.h>\n#include <linux/spinlock.h>\n\n \n\n#if BITS_PER_LONG == 64\n#define EFX_USE_QWORD_IO 1\n#endif\n\n \n#ifdef CONFIG_X86_64\n \n#ifdef ioremap_wc\n#define EFX_USE_PIO 1\n#endif\n#endif\n\nstatic inline u32 efx_reg(struct efx_nic *efx, unsigned int reg)\n{\n\treturn efx->reg_base + reg;\n}\n\n#ifdef EFX_USE_QWORD_IO\nstatic inline void _efx_writeq(struct efx_nic *efx, __le64 value,\n\t\t\t\t  unsigned int reg)\n{\n\t__raw_writeq((__force u64)value, efx->membase + reg);\n}\nstatic inline __le64 _efx_readq(struct efx_nic *efx, unsigned int reg)\n{\n\treturn (__force __le64)__raw_readq(efx->membase + reg);\n}\n#endif\n\nstatic inline void _efx_writed(struct efx_nic *efx, __le32 value,\n\t\t\t\t  unsigned int reg)\n{\n\t__raw_writel((__force u32)value, efx->membase + reg);\n}\nstatic inline __le32 _efx_readd(struct efx_nic *efx, unsigned int reg)\n{\n\treturn (__force __le32)__raw_readl(efx->membase + reg);\n}\n\n \nstatic inline void efx_writeo(struct efx_nic *efx, const efx_oword_t *value,\n\t\t\t      unsigned int reg)\n{\n\tunsigned long flags __attribute__ ((unused));\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing register %x with \" EFX_OWORD_FMT \"\\n\", reg,\n\t\t   EFX_OWORD_VAL(*value));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n#ifdef EFX_USE_QWORD_IO\n\t_efx_writeq(efx, value->u64[0], reg + 0);\n\t_efx_writeq(efx, value->u64[1], reg + 8);\n#else\n\t_efx_writed(efx, value->u32[0], reg + 0);\n\t_efx_writed(efx, value->u32[1], reg + 4);\n\t_efx_writed(efx, value->u32[2], reg + 8);\n\t_efx_writed(efx, value->u32[3], reg + 12);\n#endif\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n}\n\n \nstatic inline void efx_sram_writeq(struct efx_nic *efx, void __iomem *membase,\n\t\t\t\t   const efx_qword_t *value, unsigned int index)\n{\n\tunsigned int addr = index * sizeof(*value);\n\tunsigned long flags __attribute__ ((unused));\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing SRAM address %x with \" EFX_QWORD_FMT \"\\n\",\n\t\t   addr, EFX_QWORD_VAL(*value));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n#ifdef EFX_USE_QWORD_IO\n\t__raw_writeq((__force u64)value->u64[0], membase + addr);\n#else\n\t__raw_writel((__force u32)value->u32[0], membase + addr);\n\t__raw_writel((__force u32)value->u32[1], membase + addr + 4);\n#endif\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n}\n\n \nstatic inline void efx_writed(struct efx_nic *efx, const efx_dword_t *value,\n\t\t\t      unsigned int reg)\n{\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing register %x with \"EFX_DWORD_FMT\"\\n\",\n\t\t   reg, EFX_DWORD_VAL(*value));\n\n\t \n\t_efx_writed(efx, value->u32[0], reg);\n}\n\n \nstatic inline void efx_reado(struct efx_nic *efx, efx_oword_t *value,\n\t\t\t     unsigned int reg)\n{\n\tunsigned long flags __attribute__ ((unused));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n\tvalue->u32[0] = _efx_readd(efx, reg + 0);\n\tvalue->u32[1] = _efx_readd(efx, reg + 4);\n\tvalue->u32[2] = _efx_readd(efx, reg + 8);\n\tvalue->u32[3] = _efx_readd(efx, reg + 12);\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"read from register %x, got \" EFX_OWORD_FMT \"\\n\", reg,\n\t\t   EFX_OWORD_VAL(*value));\n}\n\n \nstatic inline void efx_sram_readq(struct efx_nic *efx, void __iomem *membase,\n\t\t\t\t  efx_qword_t *value, unsigned int index)\n{\n\tunsigned int addr = index * sizeof(*value);\n\tunsigned long flags __attribute__ ((unused));\n\n\tspin_lock_irqsave(&efx->biu_lock, flags);\n#ifdef EFX_USE_QWORD_IO\n\tvalue->u64[0] = (__force __le64)__raw_readq(membase + addr);\n#else\n\tvalue->u32[0] = (__force __le32)__raw_readl(membase + addr);\n\tvalue->u32[1] = (__force __le32)__raw_readl(membase + addr + 4);\n#endif\n\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"read from SRAM address %x, got \"EFX_QWORD_FMT\"\\n\",\n\t\t   addr, EFX_QWORD_VAL(*value));\n}\n\n \nstatic inline void efx_readd(struct efx_nic *efx, efx_dword_t *value,\n\t\t\t\tunsigned int reg)\n{\n\tvalue->u32[0] = _efx_readd(efx, reg);\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"read from register %x, got \"EFX_DWORD_FMT\"\\n\",\n\t\t   reg, EFX_DWORD_VAL(*value));\n}\n\n \nstatic inline void\nefx_writeo_table(struct efx_nic *efx, const efx_oword_t *value,\n\t\t unsigned int reg, unsigned int index)\n{\n\tefx_writeo(efx, value, reg + index * sizeof(efx_oword_t));\n}\n\n \nstatic inline void efx_reado_table(struct efx_nic *efx, efx_oword_t *value,\n\t\t\t\t     unsigned int reg, unsigned int index)\n{\n\tefx_reado(efx, value, reg + index * sizeof(efx_oword_t));\n}\n\n \n#define EFX_DEFAULT_VI_STRIDE\t\t0x2000\n#define EF100_DEFAULT_VI_STRIDE\t\t0x10000\n\n \nstatic inline unsigned int efx_paged_reg(struct efx_nic *efx, unsigned int page,\n\t\t\t\t\t unsigned int reg)\n{\n\treturn page * efx->vi_stride + reg;\n}\n\n \nstatic inline void _efx_writeo_page(struct efx_nic *efx, efx_oword_t *value,\n\t\t\t\t    unsigned int reg, unsigned int page)\n{\n\treg = efx_paged_reg(efx, page, reg);\n\n\tnetif_vdbg(efx, hw, efx->net_dev,\n\t\t   \"writing register %x with \" EFX_OWORD_FMT \"\\n\", reg,\n\t\t   EFX_OWORD_VAL(*value));\n\n#ifdef EFX_USE_QWORD_IO\n\t_efx_writeq(efx, value->u64[0], reg + 0);\n\t_efx_writeq(efx, value->u64[1], reg + 8);\n#else\n\t_efx_writed(efx, value->u32[0], reg + 0);\n\t_efx_writed(efx, value->u32[1], reg + 4);\n\t_efx_writed(efx, value->u32[2], reg + 8);\n\t_efx_writed(efx, value->u32[3], reg + 12);\n#endif\n}\n#define efx_writeo_page(efx, value, reg, page)\t\t\t\t\\\n\t_efx_writeo_page(efx, value,\t\t\t\t\t\\\n\t\t\t reg +\t\t\t\t\t\t\\\n\t\t\t BUILD_BUG_ON_ZERO((reg) != 0x830 && (reg) != 0xa10), \\\n\t\t\t page)\n\n \nstatic inline void\n_efx_writed_page(struct efx_nic *efx, const efx_dword_t *value,\n\t\t unsigned int reg, unsigned int page)\n{\n\tefx_writed(efx, value, efx_paged_reg(efx, page, reg));\n}\n#define efx_writed_page(efx, value, reg, page)\t\t\t\t\\\n\t_efx_writed_page(efx, value,\t\t\t\t\t\\\n\t\t\t reg +\t\t\t\t\t\t\\\n\t\t\t BUILD_BUG_ON_ZERO((reg) != 0x180 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x200 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x400 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x420 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x830 &&\t\t\\\n\t\t\t\t\t   (reg) != 0x83c &&\t\t\\\n\t\t\t\t\t   (reg) != 0xa18 &&\t\t\\\n\t\t\t\t\t   (reg) != 0xa1c),\t\t\\\n\t\t\t page)\n\n \nstatic inline void _efx_writed_page_locked(struct efx_nic *efx,\n\t\t\t\t\t   const efx_dword_t *value,\n\t\t\t\t\t   unsigned int reg,\n\t\t\t\t\t   unsigned int page)\n{\n\tunsigned long flags __attribute__ ((unused));\n\n\tif (page == 0) {\n\t\tspin_lock_irqsave(&efx->biu_lock, flags);\n\t\tefx_writed(efx, value, efx_paged_reg(efx, page, reg));\n\t\tspin_unlock_irqrestore(&efx->biu_lock, flags);\n\t} else {\n\t\tefx_writed(efx, value, efx_paged_reg(efx, page, reg));\n\t}\n}\n#define efx_writed_page_locked(efx, value, reg, page)\t\t\t\\\n\t_efx_writed_page_locked(efx, value,\t\t\t\t\\\n\t\t\t\treg + BUILD_BUG_ON_ZERO((reg) != 0x420), \\\n\t\t\t\tpage)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}