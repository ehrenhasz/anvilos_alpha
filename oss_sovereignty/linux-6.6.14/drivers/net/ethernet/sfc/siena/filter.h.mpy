{
  "module_name": "filter.h",
  "hash_id": "b67da8f8e07b0c653a7cd2ad4a14af3bd74626f78577ff08546fbf7222fa1483",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/siena/filter.h",
  "human_readable_source": " \n \n\n#ifndef EFX_FILTER_H\n#define EFX_FILTER_H\n\n#include <linux/types.h>\n#include <linux/if_ether.h>\n#include <asm/byteorder.h>\n\n \nenum efx_filter_match_flags {\n\tEFX_FILTER_MATCH_REM_HOST =\t0x0001,\n\tEFX_FILTER_MATCH_LOC_HOST =\t0x0002,\n\tEFX_FILTER_MATCH_REM_MAC =\t0x0004,\n\tEFX_FILTER_MATCH_REM_PORT =\t0x0008,\n\tEFX_FILTER_MATCH_LOC_MAC =\t0x0010,\n\tEFX_FILTER_MATCH_LOC_PORT =\t0x0020,\n\tEFX_FILTER_MATCH_ETHER_TYPE =\t0x0040,\n\tEFX_FILTER_MATCH_INNER_VID =\t0x0080,\n\tEFX_FILTER_MATCH_OUTER_VID =\t0x0100,\n\tEFX_FILTER_MATCH_IP_PROTO =\t0x0200,\n\tEFX_FILTER_MATCH_LOC_MAC_IG =\t0x0400,\n\tEFX_FILTER_MATCH_ENCAP_TYPE =\t0x0800,\n};\n\n \nenum efx_filter_priority {\n\tEFX_FILTER_PRI_HINT = 0,\n\tEFX_FILTER_PRI_AUTO,\n\tEFX_FILTER_PRI_MANUAL,\n\tEFX_FILTER_PRI_REQUIRED,\n};\n\n \nenum efx_filter_flags {\n\tEFX_FILTER_FLAG_RX_RSS = 0x01,\n\tEFX_FILTER_FLAG_RX_SCATTER = 0x02,\n\tEFX_FILTER_FLAG_RX_OVER_AUTO = 0x04,\n\tEFX_FILTER_FLAG_RX = 0x08,\n\tEFX_FILTER_FLAG_TX = 0x10,\n};\n\n \nenum efx_encap_type {\n\tEFX_ENCAP_TYPE_NONE = 0,\n\tEFX_ENCAP_TYPE_VXLAN = 1,\n\tEFX_ENCAP_TYPE_NVGRE = 2,\n\tEFX_ENCAP_TYPE_GENEVE = 3,\n\n\tEFX_ENCAP_TYPES_MASK = 7,\n\tEFX_ENCAP_FLAG_IPV6 = 8,\n};\n\n \nstruct efx_filter_spec {\n\tu32\tmatch_flags:12;\n\tu32\tpriority:2;\n\tu32\tflags:6;\n\tu32\tdmaq_id:12;\n\tu32\trss_context;\n\t__be16\touter_vid __aligned(4);  \n\t__be16\tinner_vid;\n\tu8\tloc_mac[ETH_ALEN];\n\tu8\trem_mac[ETH_ALEN];\n\t__be16\tether_type;\n\tu8\tip_proto;\n\t__be32\tloc_host[4];\n\t__be32\trem_host[4];\n\t__be16\tloc_port;\n\t__be16\trem_port;\n\tu32     encap_type:4;\n\t \n};\n\nenum {\n\tEFX_FILTER_RX_DMAQ_ID_DROP = 0xfff\n};\n\nstatic inline void efx_filter_init_rx(struct efx_filter_spec *spec,\n\t\t\t\t      enum efx_filter_priority priority,\n\t\t\t\t      enum efx_filter_flags flags,\n\t\t\t\t      unsigned rxq_id)\n{\n\tmemset(spec, 0, sizeof(*spec));\n\tspec->priority = priority;\n\tspec->flags = EFX_FILTER_FLAG_RX | flags;\n\tspec->rss_context = 0;\n\tspec->dmaq_id = rxq_id;\n}\n\nstatic inline void efx_filter_init_tx(struct efx_filter_spec *spec,\n\t\t\t\t      unsigned txq_id)\n{\n\tmemset(spec, 0, sizeof(*spec));\n\tspec->priority = EFX_FILTER_PRI_REQUIRED;\n\tspec->flags = EFX_FILTER_FLAG_TX;\n\tspec->dmaq_id = txq_id;\n}\n\n \nstatic inline int\nefx_filter_set_ipv4_local(struct efx_filter_spec *spec, u8 proto,\n\t\t\t  __be32 host, __be16 port)\n{\n\tspec->match_flags |=\n\t\tEFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_IP_PROTO |\n\t\tEFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_LOC_PORT;\n\tspec->ether_type = htons(ETH_P_IP);\n\tspec->ip_proto = proto;\n\tspec->loc_host[0] = host;\n\tspec->loc_port = port;\n\treturn 0;\n}\n\n \nstatic inline int\nefx_filter_set_ipv4_full(struct efx_filter_spec *spec, u8 proto,\n\t\t\t __be32 lhost, __be16 lport,\n\t\t\t __be32 rhost, __be16 rport)\n{\n\tspec->match_flags |=\n\t\tEFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_IP_PROTO |\n\t\tEFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_LOC_PORT |\n\t\tEFX_FILTER_MATCH_REM_HOST | EFX_FILTER_MATCH_REM_PORT;\n\tspec->ether_type = htons(ETH_P_IP);\n\tspec->ip_proto = proto;\n\tspec->loc_host[0] = lhost;\n\tspec->loc_port = lport;\n\tspec->rem_host[0] = rhost;\n\tspec->rem_port = rport;\n\treturn 0;\n}\n\nenum {\n\tEFX_FILTER_VID_UNSPEC = 0xffff,\n};\n\n \nstatic inline int efx_filter_set_eth_local(struct efx_filter_spec *spec,\n\t\t\t\t\t   u16 vid, const u8 *addr)\n{\n\tif (vid == EFX_FILTER_VID_UNSPEC && addr == NULL)\n\t\treturn -EINVAL;\n\n\tif (vid != EFX_FILTER_VID_UNSPEC) {\n\t\tspec->match_flags |= EFX_FILTER_MATCH_OUTER_VID;\n\t\tspec->outer_vid = htons(vid);\n\t}\n\tif (addr != NULL) {\n\t\tspec->match_flags |= EFX_FILTER_MATCH_LOC_MAC;\n\t\tether_addr_copy(spec->loc_mac, addr);\n\t}\n\treturn 0;\n}\n\n \nstatic inline int efx_filter_set_uc_def(struct efx_filter_spec *spec)\n{\n\tspec->match_flags |= EFX_FILTER_MATCH_LOC_MAC_IG;\n\treturn 0;\n}\n\n \nstatic inline int efx_filter_set_mc_def(struct efx_filter_spec *spec)\n{\n\tspec->match_flags |= EFX_FILTER_MATCH_LOC_MAC_IG;\n\tspec->loc_mac[0] = 1;\n\treturn 0;\n}\n\nstatic inline void efx_filter_set_encap_type(struct efx_filter_spec *spec,\n\t\t\t\t\t     enum efx_encap_type encap_type)\n{\n\tspec->match_flags |= EFX_FILTER_MATCH_ENCAP_TYPE;\n\tspec->encap_type = encap_type;\n}\n\nstatic inline enum efx_encap_type efx_filter_get_encap_type(\n\t\tconst struct efx_filter_spec *spec)\n{\n\tif (spec->match_flags & EFX_FILTER_MATCH_ENCAP_TYPE)\n\t\treturn spec->encap_type;\n\treturn EFX_ENCAP_TYPE_NONE;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}