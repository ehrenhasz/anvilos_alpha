{
  "module_name": "siena.c",
  "hash_id": "00bdd1387a80429e74b8dedeca3ab14e3e58ef38d766b39df7dc5786ed808414",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/siena/siena.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include \"net_driver.h\"\n#include \"bitfield.h\"\n#include \"efx.h\"\n#include \"efx_common.h\"\n#include \"nic.h\"\n#include \"farch_regs.h\"\n#include \"io.h\"\n#include \"workarounds.h\"\n#include \"mcdi.h\"\n#include \"mcdi_pcol.h\"\n#include \"mcdi_port.h\"\n#include \"mcdi_port_common.h\"\n#include \"selftest.h\"\n#include \"siena_sriov.h\"\n#include \"rx_common.h\"\n\n \n\nstatic void siena_init_wol(struct efx_nic *efx);\n\n\nstatic void siena_push_irq_moderation(struct efx_channel *channel)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tefx_dword_t timer_cmd;\n\n\tif (channel->irq_moderation_us) {\n\t\tunsigned int ticks;\n\n\t\tticks = efx_siena_usecs_to_ticks(efx, channel->irq_moderation_us);\n\t\tEFX_POPULATE_DWORD_2(timer_cmd,\n\t\t\t\t     FRF_CZ_TC_TIMER_MODE,\n\t\t\t\t     FFE_CZ_TIMER_MODE_INT_HLDOFF,\n\t\t\t\t     FRF_CZ_TC_TIMER_VAL,\n\t\t\t\t     ticks - 1);\n\t} else {\n\t\tEFX_POPULATE_DWORD_2(timer_cmd,\n\t\t\t\t     FRF_CZ_TC_TIMER_MODE,\n\t\t\t\t     FFE_CZ_TIMER_MODE_DIS,\n\t\t\t\t     FRF_CZ_TC_TIMER_VAL, 0);\n\t}\n\tefx_writed_page_locked(channel->efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,\n\t\t\t       channel->channel);\n}\n\nvoid efx_siena_prepare_flush(struct efx_nic *efx)\n{\n\tif (efx->fc_disable++ == 0)\n\t\tefx_siena_mcdi_set_mac(efx);\n}\n\nvoid siena_finish_flush(struct efx_nic *efx)\n{\n\tif (--efx->fc_disable == 0)\n\t\tefx_siena_mcdi_set_mac(efx);\n}\n\nstatic const struct efx_farch_register_test siena_register_tests[] = {\n\t{ FR_AZ_ADR_REGION,\n\t  EFX_OWORD32(0x0003FFFF, 0x0003FFFF, 0x0003FFFF, 0x0003FFFF) },\n\t{ FR_CZ_USR_EV_CFG,\n\t  EFX_OWORD32(0x000103FF, 0x00000000, 0x00000000, 0x00000000) },\n\t{ FR_AZ_RX_CFG,\n\t  EFX_OWORD32(0xFFFFFFFE, 0xFFFFFFFF, 0x0003FFFF, 0x00000000) },\n\t{ FR_AZ_TX_CFG,\n\t  EFX_OWORD32(0x7FFF0037, 0xFFFF8000, 0xFFFFFFFF, 0x03FFFFFF) },\n\t{ FR_AZ_TX_RESERVED,\n\t  EFX_OWORD32(0xFFFEFE80, 0x1FFFFFFF, 0x020000FE, 0x007FFFFF) },\n\t{ FR_AZ_SRM_TX_DC_CFG,\n\t  EFX_OWORD32(0x001FFFFF, 0x00000000, 0x00000000, 0x00000000) },\n\t{ FR_AZ_RX_DC_CFG,\n\t  EFX_OWORD32(0x00000003, 0x00000000, 0x00000000, 0x00000000) },\n\t{ FR_AZ_RX_DC_PF_WM,\n\t  EFX_OWORD32(0x000003FF, 0x00000000, 0x00000000, 0x00000000) },\n\t{ FR_BZ_DP_CTRL,\n\t  EFX_OWORD32(0x00000FFF, 0x00000000, 0x00000000, 0x00000000) },\n\t{ FR_BZ_RX_RSS_TKEY,\n\t  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },\n\t{ FR_CZ_RX_RSS_IPV6_REG1,\n\t  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },\n\t{ FR_CZ_RX_RSS_IPV6_REG2,\n\t  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },\n\t{ FR_CZ_RX_RSS_IPV6_REG3,\n\t  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0x00000007, 0x00000000) },\n};\n\nstatic int siena_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)\n{\n\tenum reset_type reset_method = RESET_TYPE_ALL;\n\tint rc, rc2;\n\n\tefx_siena_reset_down(efx, reset_method);\n\n\t \n\trc = efx_siena_mcdi_reset(efx, reset_method);\n\tif (rc)\n\t\tgoto out;\n\n\ttests->registers =\n\t\tefx_farch_test_registers(efx, siena_register_tests,\n\t\t\t\t\t ARRAY_SIZE(siena_register_tests))\n\t\t? -1 : 1;\n\n\trc = efx_siena_mcdi_reset(efx, reset_method);\nout:\n\trc2 = efx_siena_reset_up(efx, reset_method, rc == 0);\n\treturn rc ? rc : rc2;\n}\n\n \n\nstatic void siena_ptp_write_host_time(struct efx_nic *efx, u32 host_time)\n{\n\t_efx_writed(efx, cpu_to_le32(host_time),\n\t\t    FR_CZ_MC_TREG_SMEM + MC_SMEM_P0_PTP_TIME_OFST);\n}\n\nstatic int siena_ptp_set_ts_config(struct efx_nic *efx,\n\t\t\t\t   struct hwtstamp_config *init)\n{\n\tint rc;\n\n\tswitch (init->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\t \n\t\treturn efx_siena_ptp_change_mode(efx,\n\t\t\t\t\tinit->tx_type != HWTSTAMP_TX_OFF,\n\t\t\t\t\tefx_siena_ptp_get_mode(efx));\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tinit->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\treturn efx_siena_ptp_change_mode(efx, true, MC_CMD_PTP_MODE_V1);\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tinit->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\t\trc = efx_siena_ptp_change_mode(efx, true,\n\t\t\t\t\t       MC_CMD_PTP_MODE_V2_ENHANCED);\n\t\t \n\t\tif (rc != 0)\n\t\t\trc = efx_siena_ptp_change_mode(efx, true,\n\t\t\t\t\t\t       MC_CMD_PTP_MODE_V2);\n\t\treturn rc;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n}\n\n \n\nstatic int siena_map_reset_flags(u32 *flags)\n{\n\tenum {\n\t\tSIENA_RESET_PORT = (ETH_RESET_DMA | ETH_RESET_FILTER |\n\t\t\t\t    ETH_RESET_OFFLOAD | ETH_RESET_MAC |\n\t\t\t\t    ETH_RESET_PHY),\n\t\tSIENA_RESET_MC = (SIENA_RESET_PORT |\n\t\t\t\t  ETH_RESET_MGMT << ETH_RESET_SHARED_SHIFT),\n\t};\n\n\tif ((*flags & SIENA_RESET_MC) == SIENA_RESET_MC) {\n\t\t*flags &= ~SIENA_RESET_MC;\n\t\treturn RESET_TYPE_WORLD;\n\t}\n\n\tif ((*flags & SIENA_RESET_PORT) == SIENA_RESET_PORT) {\n\t\t*flags &= ~SIENA_RESET_PORT;\n\t\treturn RESET_TYPE_ALL;\n\t}\n\n\t \n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_EEH\n \nstatic void siena_monitor(struct efx_nic *efx)\n{\n\tstruct eeh_dev *eehdev = pci_dev_to_eeh_dev(efx->pci_dev);\n\n\teeh_dev_check_failure(eehdev);\n}\n#endif\n\nstatic int siena_probe_nvconfig(struct efx_nic *efx)\n{\n\tu32 caps = 0;\n\tint rc;\n\n\trc = efx_siena_mcdi_get_board_cfg(efx, efx->net_dev->perm_addr, NULL,\n\t\t\t\t\t  &caps);\n\n\tefx->timer_quantum_ns =\n\t\t(caps & (1 << MC_CMD_CAPABILITIES_TURBO_ACTIVE_LBN)) ?\n\t\t3072 : 6144;  \n\tefx->timer_max_ns = efx->type->timer_period_max *\n\t\t\t    efx->timer_quantum_ns;\n\n\treturn rc;\n}\n\nstatic int siena_dimension_resources(struct efx_nic *efx)\n{\n\t \n\tefx_farch_dimension_resources(efx, FR_CZ_BUF_FULL_TBL_ROWS / 2);\n\treturn 0;\n}\n\n \nstatic unsigned int siena_mem_bar(struct efx_nic *efx)\n{\n\treturn 2;\n}\n\nstatic unsigned int siena_mem_map_size(struct efx_nic *efx)\n{\n\treturn FR_CZ_MC_TREG_SMEM +\n\t\tFR_CZ_MC_TREG_SMEM_STEP * FR_CZ_MC_TREG_SMEM_ROWS;\n}\n\nstatic int siena_probe_nic(struct efx_nic *efx)\n{\n\tstruct siena_nic_data *nic_data;\n\tefx_oword_t reg;\n\tint rc;\n\n\t \n\tnic_data = kzalloc(sizeof(struct siena_nic_data), GFP_KERNEL);\n\tif (!nic_data)\n\t\treturn -ENOMEM;\n\tnic_data->efx = efx;\n\tefx->nic_data = nic_data;\n\n\tif (efx_farch_fpga_ver(efx) != 0) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Siena FPGA not supported\\n\");\n\t\trc = -ENODEV;\n\t\tgoto fail1;\n\t}\n\n\tefx->max_channels = EFX_MAX_CHANNELS;\n\tefx->max_vis = EFX_MAX_CHANNELS;\n\tefx->max_tx_channels = EFX_MAX_CHANNELS;\n\tefx->tx_queues_per_channel = 4;\n\n\tefx_reado(efx, &reg, FR_AZ_CS_DEBUG);\n\tefx->port_num = EFX_OWORD_FIELD(reg, FRF_CZ_CS_PORT_NUM) - 1;\n\n\trc = efx_siena_mcdi_init(efx);\n\tif (rc)\n\t\tgoto fail1;\n\n\t \n\trc = efx_siena_mcdi_reset(efx, RESET_TYPE_ALL);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to reset NIC\\n\");\n\t\tgoto fail3;\n\t}\n\n\tsiena_init_wol(efx);\n\n\t \n\trc = efx_siena_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t),\n\t\t\t\t    GFP_KERNEL);\n\tif (rc)\n\t\tgoto fail4;\n\tBUG_ON(efx->irq_status.dma_addr & 0x0f);\n\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"INT_KER at %llx (virt %p phys %llx)\\n\",\n\t\t  (unsigned long long)efx->irq_status.dma_addr,\n\t\t  efx->irq_status.addr,\n\t\t  (unsigned long long)virt_to_phys(efx->irq_status.addr));\n\n\t \n\trc = siena_probe_nvconfig(efx);\n\tif (rc == -EINVAL) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"NVRAM is invalid therefore using defaults\\n\");\n\t\tefx->phy_type = PHY_TYPE_NONE;\n\t\tefx->mdio.prtad = MDIO_PRTAD_NONE;\n\t} else if (rc) {\n\t\tgoto fail5;\n\t}\n\n\trc = efx_siena_mcdi_mon_probe(efx);\n\tif (rc)\n\t\tgoto fail5;\n\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\tefx_siena_sriov_probe(efx);\n#endif\n\tefx_siena_ptp_defer_probe_with_channel(efx);\n\n\treturn 0;\n\nfail5:\n\tefx_siena_free_buffer(efx, &efx->irq_status);\nfail4:\nfail3:\n\tefx_siena_mcdi_detach(efx);\n\tefx_siena_mcdi_fini(efx);\nfail1:\n\tkfree(efx->nic_data);\n\treturn rc;\n}\n\nstatic int siena_rx_pull_rss_config(struct efx_nic *efx)\n{\n\tefx_oword_t temp;\n\n\t \n\tefx_reado(efx, &temp, FR_CZ_RX_RSS_IPV6_REG1);\n\tmemcpy(efx->rss_context.rx_hash_key, &temp, sizeof(temp));\n\tefx_reado(efx, &temp, FR_CZ_RX_RSS_IPV6_REG2);\n\tmemcpy(efx->rss_context.rx_hash_key + sizeof(temp), &temp, sizeof(temp));\n\tefx_reado(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);\n\tmemcpy(efx->rss_context.rx_hash_key + 2 * sizeof(temp), &temp,\n\t       FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);\n\tefx_farch_rx_pull_indir_table(efx);\n\treturn 0;\n}\n\nstatic int siena_rx_push_rss_config(struct efx_nic *efx, bool user,\n\t\t\t\t    const u32 *rx_indir_table, const u8 *key)\n{\n\tefx_oword_t temp;\n\n\t \n\tif (key)\n\t\tmemcpy(efx->rss_context.rx_hash_key, key, sizeof(temp));\n\tmemcpy(&temp, efx->rss_context.rx_hash_key, sizeof(temp));\n\tefx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);\n\n\t \n\tBUILD_BUG_ON(sizeof(efx->rss_context.rx_hash_key) <\n\t\t     2 * sizeof(temp) + FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8 ||\n\t\t     FRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN != 0);\n\tmemcpy(&temp, efx->rss_context.rx_hash_key, sizeof(temp));\n\tefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG1);\n\tmemcpy(&temp, efx->rss_context.rx_hash_key + sizeof(temp), sizeof(temp));\n\tefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG2);\n\tEFX_POPULATE_OWORD_2(temp, FRF_CZ_RX_RSS_IPV6_THASH_ENABLE, 1,\n\t\t\t     FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE, 1);\n\tmemcpy(&temp, efx->rss_context.rx_hash_key + 2 * sizeof(temp),\n\t       FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);\n\tefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);\n\n\tmemcpy(efx->rss_context.rx_indir_table, rx_indir_table,\n\t       sizeof(efx->rss_context.rx_indir_table));\n\tefx_farch_rx_push_indir_table(efx);\n\n\treturn 0;\n}\n\n \nstatic int siena_init_nic(struct efx_nic *efx)\n{\n\tefx_oword_t temp;\n\tint rc;\n\n\t \n\trc = efx_siena_mcdi_handle_assertion(efx);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tefx_reado(efx, &temp, FR_AZ_TX_RESERVED);\n\tEFX_SET_OWORD_FIELD(temp, FRF_BZ_TX_FLUSH_MIN_LEN_EN, 1);\n\tefx_writeo(efx, &temp, FR_AZ_TX_RESERVED);\n\n\t \n\tefx_reado(efx, &temp, FR_AZ_TX_CFG);\n\tEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);\n\tEFX_SET_OWORD_FIELD(temp, FRF_CZ_TX_FILTER_EN_BIT, 1);\n\tefx_writeo(efx, &temp, FR_AZ_TX_CFG);\n\n\tefx_reado(efx, &temp, FR_AZ_RX_CFG);\n\tEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_DESC_PUSH_EN, 0);\n\tEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_INGR_EN, 1);\n\t \n\tEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_INSRT_HDR, 1);\n\tEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_ALG, 1);\n\tEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_IP_HASH, 1);\n\tEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_USR_BUF_SIZE,\n\t\t\t    EFX_RX_USR_BUF_SIZE >> 5);\n\tefx_writeo(efx, &temp, FR_AZ_RX_CFG);\n\n\tsiena_rx_push_rss_config(efx, false, efx->rss_context.rx_indir_table, NULL);\n\tefx->rss_context.context_id = 0;  \n\n\t \n\trc = efx_siena_mcdi_log_ctrl(efx, true, false, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tEFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);\n\tefx_writeo(efx, &temp, FR_BZ_DP_CTRL);\n\n\tEFX_POPULATE_OWORD_1(temp, FRF_CZ_USREV_DIS, 1);\n\tefx_writeo(efx, &temp, FR_CZ_USR_EV_CFG);\n\n\tefx_farch_init_common(efx);\n\treturn 0;\n}\n\nstatic void siena_remove_nic(struct efx_nic *efx)\n{\n\tefx_siena_mcdi_mon_remove(efx);\n\n\tefx_siena_free_buffer(efx, &efx->irq_status);\n\n\tefx_siena_mcdi_reset(efx, RESET_TYPE_ALL);\n\n\tefx_siena_mcdi_detach(efx);\n\tefx_siena_mcdi_fini(efx);\n\n\t \n\tkfree(efx->nic_data);\n\tefx->nic_data = NULL;\n}\n\n#define SIENA_DMA_STAT(ext_name, mcdi_name)\t\t\t\\\n\t[SIENA_STAT_ ## ext_name] =\t\t\t\t\\\n\t{ #ext_name, 64, 8 * MC_CMD_MAC_ ## mcdi_name }\n#define SIENA_OTHER_STAT(ext_name)\t\t\t\t\\\n\t[SIENA_STAT_ ## ext_name] = { #ext_name, 0, 0 }\n#define GENERIC_SW_STAT(ext_name)\t\t\t\t\\\n\t[GENERIC_STAT_ ## ext_name] = { #ext_name, 0, 0 }\n\nstatic const struct efx_hw_stat_desc siena_stat_desc[SIENA_STAT_COUNT] = {\n\tSIENA_DMA_STAT(tx_bytes, TX_BYTES),\n\tSIENA_OTHER_STAT(tx_good_bytes),\n\tSIENA_DMA_STAT(tx_bad_bytes, TX_BAD_BYTES),\n\tSIENA_DMA_STAT(tx_packets, TX_PKTS),\n\tSIENA_DMA_STAT(tx_bad, TX_BAD_FCS_PKTS),\n\tSIENA_DMA_STAT(tx_pause, TX_PAUSE_PKTS),\n\tSIENA_DMA_STAT(tx_control, TX_CONTROL_PKTS),\n\tSIENA_DMA_STAT(tx_unicast, TX_UNICAST_PKTS),\n\tSIENA_DMA_STAT(tx_multicast, TX_MULTICAST_PKTS),\n\tSIENA_DMA_STAT(tx_broadcast, TX_BROADCAST_PKTS),\n\tSIENA_DMA_STAT(tx_lt64, TX_LT64_PKTS),\n\tSIENA_DMA_STAT(tx_64, TX_64_PKTS),\n\tSIENA_DMA_STAT(tx_65_to_127, TX_65_TO_127_PKTS),\n\tSIENA_DMA_STAT(tx_128_to_255, TX_128_TO_255_PKTS),\n\tSIENA_DMA_STAT(tx_256_to_511, TX_256_TO_511_PKTS),\n\tSIENA_DMA_STAT(tx_512_to_1023, TX_512_TO_1023_PKTS),\n\tSIENA_DMA_STAT(tx_1024_to_15xx, TX_1024_TO_15XX_PKTS),\n\tSIENA_DMA_STAT(tx_15xx_to_jumbo, TX_15XX_TO_JUMBO_PKTS),\n\tSIENA_DMA_STAT(tx_gtjumbo, TX_GTJUMBO_PKTS),\n\tSIENA_OTHER_STAT(tx_collision),\n\tSIENA_DMA_STAT(tx_single_collision, TX_SINGLE_COLLISION_PKTS),\n\tSIENA_DMA_STAT(tx_multiple_collision, TX_MULTIPLE_COLLISION_PKTS),\n\tSIENA_DMA_STAT(tx_excessive_collision, TX_EXCESSIVE_COLLISION_PKTS),\n\tSIENA_DMA_STAT(tx_deferred, TX_DEFERRED_PKTS),\n\tSIENA_DMA_STAT(tx_late_collision, TX_LATE_COLLISION_PKTS),\n\tSIENA_DMA_STAT(tx_excessive_deferred, TX_EXCESSIVE_DEFERRED_PKTS),\n\tSIENA_DMA_STAT(tx_non_tcpudp, TX_NON_TCPUDP_PKTS),\n\tSIENA_DMA_STAT(tx_mac_src_error, TX_MAC_SRC_ERR_PKTS),\n\tSIENA_DMA_STAT(tx_ip_src_error, TX_IP_SRC_ERR_PKTS),\n\tSIENA_DMA_STAT(rx_bytes, RX_BYTES),\n\tSIENA_OTHER_STAT(rx_good_bytes),\n\tSIENA_DMA_STAT(rx_bad_bytes, RX_BAD_BYTES),\n\tSIENA_DMA_STAT(rx_packets, RX_PKTS),\n\tSIENA_DMA_STAT(rx_good, RX_GOOD_PKTS),\n\tSIENA_DMA_STAT(rx_bad, RX_BAD_FCS_PKTS),\n\tSIENA_DMA_STAT(rx_pause, RX_PAUSE_PKTS),\n\tSIENA_DMA_STAT(rx_control, RX_CONTROL_PKTS),\n\tSIENA_DMA_STAT(rx_unicast, RX_UNICAST_PKTS),\n\tSIENA_DMA_STAT(rx_multicast, RX_MULTICAST_PKTS),\n\tSIENA_DMA_STAT(rx_broadcast, RX_BROADCAST_PKTS),\n\tSIENA_DMA_STAT(rx_lt64, RX_UNDERSIZE_PKTS),\n\tSIENA_DMA_STAT(rx_64, RX_64_PKTS),\n\tSIENA_DMA_STAT(rx_65_to_127, RX_65_TO_127_PKTS),\n\tSIENA_DMA_STAT(rx_128_to_255, RX_128_TO_255_PKTS),\n\tSIENA_DMA_STAT(rx_256_to_511, RX_256_TO_511_PKTS),\n\tSIENA_DMA_STAT(rx_512_to_1023, RX_512_TO_1023_PKTS),\n\tSIENA_DMA_STAT(rx_1024_to_15xx, RX_1024_TO_15XX_PKTS),\n\tSIENA_DMA_STAT(rx_15xx_to_jumbo, RX_15XX_TO_JUMBO_PKTS),\n\tSIENA_DMA_STAT(rx_gtjumbo, RX_GTJUMBO_PKTS),\n\tSIENA_DMA_STAT(rx_bad_gtjumbo, RX_JABBER_PKTS),\n\tSIENA_DMA_STAT(rx_overflow, RX_OVERFLOW_PKTS),\n\tSIENA_DMA_STAT(rx_false_carrier, RX_FALSE_CARRIER_PKTS),\n\tSIENA_DMA_STAT(rx_symbol_error, RX_SYMBOL_ERROR_PKTS),\n\tSIENA_DMA_STAT(rx_align_error, RX_ALIGN_ERROR_PKTS),\n\tSIENA_DMA_STAT(rx_length_error, RX_LENGTH_ERROR_PKTS),\n\tSIENA_DMA_STAT(rx_internal_error, RX_INTERNAL_ERROR_PKTS),\n\tSIENA_DMA_STAT(rx_nodesc_drop_cnt, RX_NODESC_DROPS),\n\tGENERIC_SW_STAT(rx_nodesc_trunc),\n\tGENERIC_SW_STAT(rx_noskb_drops),\n};\nstatic const unsigned long siena_stat_mask[] = {\n\t[0 ... BITS_TO_LONGS(SIENA_STAT_COUNT) - 1] = ~0UL,\n};\n\nstatic size_t siena_describe_nic_stats(struct efx_nic *efx, u8 *names)\n{\n\treturn efx_siena_describe_stats(siena_stat_desc, SIENA_STAT_COUNT,\n\t\t\t\t\tsiena_stat_mask, names);\n}\n\nstatic int siena_try_update_nic_stats(struct efx_nic *efx)\n{\n\tstruct siena_nic_data *nic_data = efx->nic_data;\n\tu64 *stats = nic_data->stats;\n\t__le64 *dma_stats;\n\t__le64 generation_start, generation_end;\n\n\tdma_stats = efx->stats_buffer.addr;\n\n\tgeneration_end = dma_stats[efx->num_mac_stats - 1];\n\tif (generation_end == EFX_MC_STATS_GENERATION_INVALID)\n\t\treturn 0;\n\trmb();\n\tefx_siena_update_stats(siena_stat_desc, SIENA_STAT_COUNT, siena_stat_mask,\n\t\t\t       stats, efx->stats_buffer.addr, false);\n\trmb();\n\tgeneration_start = dma_stats[MC_CMD_MAC_GENERATION_START];\n\tif (generation_end != generation_start)\n\t\treturn -EAGAIN;\n\n\t \n\tefx_siena_fix_nodesc_drop_stat(efx,\n\t\t\t\t       &stats[SIENA_STAT_rx_nodesc_drop_cnt]);\n\tefx_update_diff_stat(&stats[SIENA_STAT_tx_good_bytes],\n\t\t\t     stats[SIENA_STAT_tx_bytes] -\n\t\t\t     stats[SIENA_STAT_tx_bad_bytes]);\n\tstats[SIENA_STAT_tx_collision] =\n\t\tstats[SIENA_STAT_tx_single_collision] +\n\t\tstats[SIENA_STAT_tx_multiple_collision] +\n\t\tstats[SIENA_STAT_tx_excessive_collision] +\n\t\tstats[SIENA_STAT_tx_late_collision];\n\tefx_update_diff_stat(&stats[SIENA_STAT_rx_good_bytes],\n\t\t\t     stats[SIENA_STAT_rx_bytes] -\n\t\t\t     stats[SIENA_STAT_rx_bad_bytes]);\n\tefx_siena_update_sw_stats(efx, stats);\n\treturn 0;\n}\n\nstatic size_t siena_update_nic_stats(struct efx_nic *efx, u64 *full_stats,\n\t\t\t\t     struct rtnl_link_stats64 *core_stats)\n{\n\tstruct siena_nic_data *nic_data = efx->nic_data;\n\tu64 *stats = nic_data->stats;\n\tint retry;\n\n\t \n\tfor (retry = 0; retry < 100; ++retry) {\n\t\tif (siena_try_update_nic_stats(efx) == 0)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\tif (full_stats)\n\t\tmemcpy(full_stats, stats, sizeof(u64) * SIENA_STAT_COUNT);\n\n\tif (core_stats) {\n\t\tcore_stats->rx_packets = stats[SIENA_STAT_rx_packets];\n\t\tcore_stats->tx_packets = stats[SIENA_STAT_tx_packets];\n\t\tcore_stats->rx_bytes = stats[SIENA_STAT_rx_bytes];\n\t\tcore_stats->tx_bytes = stats[SIENA_STAT_tx_bytes];\n\t\tcore_stats->rx_dropped = stats[SIENA_STAT_rx_nodesc_drop_cnt] +\n\t\t\t\t\t stats[GENERIC_STAT_rx_nodesc_trunc] +\n\t\t\t\t\t stats[GENERIC_STAT_rx_noskb_drops];\n\t\tcore_stats->multicast = stats[SIENA_STAT_rx_multicast];\n\t\tcore_stats->collisions = stats[SIENA_STAT_tx_collision];\n\t\tcore_stats->rx_length_errors =\n\t\t\tstats[SIENA_STAT_rx_gtjumbo] +\n\t\t\tstats[SIENA_STAT_rx_length_error];\n\t\tcore_stats->rx_crc_errors = stats[SIENA_STAT_rx_bad];\n\t\tcore_stats->rx_frame_errors = stats[SIENA_STAT_rx_align_error];\n\t\tcore_stats->rx_fifo_errors = stats[SIENA_STAT_rx_overflow];\n\t\tcore_stats->tx_window_errors =\n\t\t\tstats[SIENA_STAT_tx_late_collision];\n\n\t\tcore_stats->rx_errors = (core_stats->rx_length_errors +\n\t\t\t\t\t core_stats->rx_crc_errors +\n\t\t\t\t\t core_stats->rx_frame_errors +\n\t\t\t\t\t stats[SIENA_STAT_rx_symbol_error]);\n\t\tcore_stats->tx_errors = (core_stats->tx_window_errors +\n\t\t\t\t\t stats[SIENA_STAT_tx_bad]);\n\t}\n\n\treturn SIENA_STAT_COUNT;\n}\n\nstatic int siena_mac_reconfigure(struct efx_nic *efx, bool mtu_only __always_unused)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_MCAST_HASH_IN_LEN);\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_SET_MCAST_HASH_IN_LEN !=\n\t\t     MC_CMD_SET_MCAST_HASH_IN_HASH0_OFST +\n\t\t     sizeof(efx->multicast_hash));\n\n\tefx_farch_filter_sync_rx_mode(efx);\n\n\tWARN_ON(!mutex_is_locked(&efx->mac_lock));\n\n\trc = efx_siena_mcdi_set_mac(efx);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tmemcpy(MCDI_PTR(inbuf, SET_MCAST_HASH_IN_HASH0),\n\t       efx->multicast_hash.byte, sizeof(efx->multicast_hash));\n\treturn efx_siena_mcdi_rpc(efx, MC_CMD_SET_MCAST_HASH,\n\t\t\t\t  inbuf, sizeof(inbuf), NULL, 0, NULL);\n}\n\n \n\nstatic void siena_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)\n{\n\tstruct siena_nic_data *nic_data = efx->nic_data;\n\n\twol->supported = WAKE_MAGIC;\n\tif (nic_data->wol_filter_id != -1)\n\t\twol->wolopts = WAKE_MAGIC;\n\telse\n\t\twol->wolopts = 0;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\n\nstatic int siena_set_wol(struct efx_nic *efx, u32 type)\n{\n\tstruct siena_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\tif (type & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (type & WAKE_MAGIC) {\n\t\tif (nic_data->wol_filter_id != -1)\n\t\t\tefx_siena_mcdi_wol_filter_remove(efx,\n\t\t\t\t\t\tnic_data->wol_filter_id);\n\t\trc = efx_siena_mcdi_wol_filter_set_magic(efx,\n\t\t\t\t\t\tefx->net_dev->dev_addr,\n\t\t\t\t\t\t&nic_data->wol_filter_id);\n\t\tif (rc)\n\t\t\tgoto fail;\n\n\t\tpci_wake_from_d3(efx->pci_dev, true);\n\t} else {\n\t\trc = efx_siena_mcdi_wol_filter_reset(efx);\n\t\tnic_data->wol_filter_id = -1;\n\t\tpci_wake_from_d3(efx->pci_dev, false);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n fail:\n\tnetif_err(efx, hw, efx->net_dev, \"%s failed: type=%d rc=%d\\n\",\n\t\t  __func__, type, rc);\n\treturn rc;\n}\n\n\nstatic void siena_init_wol(struct efx_nic *efx)\n{\n\tstruct siena_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\trc = efx_siena_mcdi_wol_filter_get_magic(efx, &nic_data->wol_filter_id);\n\n\tif (rc != 0) {\n\t\t \n\t\tefx_siena_mcdi_wol_filter_reset(efx);\n\t\tnic_data->wol_filter_id = -1;\n\t} else if (nic_data->wol_filter_id != -1) {\n\t\tpci_wake_from_d3(efx->pci_dev, true);\n\t}\n}\n\n \n\n#define MCDI_PDU(efx)\t\t\t\t\t\t\t\\\n\t(efx_port_num(efx) ? MC_SMEM_P1_PDU_OFST : MC_SMEM_P0_PDU_OFST)\n#define MCDI_DOORBELL(efx)\t\t\t\t\t\t\\\n\t(efx_port_num(efx) ? MC_SMEM_P1_DOORBELL_OFST : MC_SMEM_P0_DOORBELL_OFST)\n#define MCDI_STATUS(efx)\t\t\t\t\t\t\\\n\t(efx_port_num(efx) ? MC_SMEM_P1_STATUS_OFST : MC_SMEM_P0_STATUS_OFST)\n\nstatic void siena_mcdi_request(struct efx_nic *efx,\n\t\t\t       const efx_dword_t *hdr, size_t hdr_len,\n\t\t\t       const efx_dword_t *sdu, size_t sdu_len)\n{\n\tunsigned pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\n\tunsigned doorbell = FR_CZ_MC_TREG_SMEM + MCDI_DOORBELL(efx);\n\tunsigned int i;\n\tunsigned int inlen_dw = DIV_ROUND_UP(sdu_len, 4);\n\n\tEFX_WARN_ON_PARANOID(hdr_len != 4);\n\n\tefx_writed(efx, hdr, pdu);\n\n\tfor (i = 0; i < inlen_dw; i++)\n\t\tefx_writed(efx, &sdu[i], pdu + hdr_len + 4 * i);\n\n\t \n\twmb();\n\n\t \n\t_efx_writed(efx, (__force __le32) 0x45789abc, doorbell);\n}\n\nstatic bool siena_mcdi_poll_response(struct efx_nic *efx)\n{\n\tunsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\n\tefx_dword_t hdr;\n\n\tefx_readd(efx, &hdr, pdu);\n\n\t \n\treturn EFX_DWORD_FIELD(hdr, EFX_DWORD_0) != 0xffffffff &&\n\t\tEFX_DWORD_FIELD(hdr, MCDI_HEADER_RESPONSE);\n}\n\nstatic void siena_mcdi_read_response(struct efx_nic *efx, efx_dword_t *outbuf,\n\t\t\t\t     size_t offset, size_t outlen)\n{\n\tunsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\n\tunsigned int outlen_dw = DIV_ROUND_UP(outlen, 4);\n\tint i;\n\n\tfor (i = 0; i < outlen_dw; i++)\n\t\tefx_readd(efx, &outbuf[i], pdu + offset + 4 * i);\n}\n\nstatic int siena_mcdi_poll_reboot(struct efx_nic *efx)\n{\n\tstruct siena_nic_data *nic_data = efx->nic_data;\n\tunsigned int addr = FR_CZ_MC_TREG_SMEM + MCDI_STATUS(efx);\n\tefx_dword_t reg;\n\tu32 value;\n\n\tefx_readd(efx, &reg, addr);\n\tvalue = EFX_DWORD_FIELD(reg, EFX_DWORD_0);\n\n\tif (value == 0)\n\t\treturn 0;\n\n\tEFX_ZERO_DWORD(reg);\n\tefx_writed(efx, &reg, addr);\n\n\t \n\tnic_data->stats[SIENA_STAT_tx_good_bytes] = 0;\n\tnic_data->stats[SIENA_STAT_rx_good_bytes] = 0;\n\n\tif (value == MC_STATUS_DWORD_ASSERT)\n\t\treturn -EINTR;\n\telse\n\t\treturn -EIO;\n}\n\n \n\n#ifdef CONFIG_SFC_SIENA_MTD\n\nstruct siena_nvram_type_info {\n\tint port;\n\tconst char *name;\n};\n\nstatic const struct siena_nvram_type_info siena_nvram_types[] = {\n\t[MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO]\t= { 0, \"sfc_dummy_phy\" },\n\t[MC_CMD_NVRAM_TYPE_MC_FW]\t\t= { 0, \"sfc_mcfw\" },\n\t[MC_CMD_NVRAM_TYPE_MC_FW_BACKUP]\t= { 0, \"sfc_mcfw_backup\" },\n\t[MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT0]\t= { 0, \"sfc_static_cfg\" },\n\t[MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT1]\t= { 1, \"sfc_static_cfg\" },\n\t[MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0]\t= { 0, \"sfc_dynamic_cfg\" },\n\t[MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1]\t= { 1, \"sfc_dynamic_cfg\" },\n\t[MC_CMD_NVRAM_TYPE_EXP_ROM]\t\t= { 0, \"sfc_exp_rom\" },\n\t[MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT0]\t= { 0, \"sfc_exp_rom_cfg\" },\n\t[MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT1]\t= { 1, \"sfc_exp_rom_cfg\" },\n\t[MC_CMD_NVRAM_TYPE_PHY_PORT0]\t\t= { 0, \"sfc_phy_fw\" },\n\t[MC_CMD_NVRAM_TYPE_PHY_PORT1]\t\t= { 1, \"sfc_phy_fw\" },\n\t[MC_CMD_NVRAM_TYPE_FPGA]\t\t= { 0, \"sfc_fpga\" },\n};\n\nstatic int siena_mtd_probe_partition(struct efx_nic *efx,\n\t\t\t\t     struct efx_mcdi_mtd_partition *part,\n\t\t\t\t     unsigned int type)\n{\n\tconst struct siena_nvram_type_info *info;\n\tsize_t size, erase_size;\n\tbool protected;\n\tint rc;\n\n\tif (type >= ARRAY_SIZE(siena_nvram_types) ||\n\t    siena_nvram_types[type].name == NULL)\n\t\treturn -ENODEV;\n\n\tinfo = &siena_nvram_types[type];\n\n\tif (info->port != efx_port_num(efx))\n\t\treturn -ENODEV;\n\n\trc = efx_siena_mcdi_nvram_info(efx, type, &size, &erase_size,\n\t\t\t\t       &protected);\n\tif (rc)\n\t\treturn rc;\n\tif (protected)\n\t\treturn -ENODEV;  \n\n\tpart->nvram_type = type;\n\tpart->common.dev_type_name = \"Siena NVRAM manager\";\n\tpart->common.type_name = info->name;\n\n\tpart->common.mtd.type = MTD_NORFLASH;\n\tpart->common.mtd.flags = MTD_CAP_NORFLASH;\n\tpart->common.mtd.size = size;\n\tpart->common.mtd.erasesize = erase_size;\n\n\treturn 0;\n}\n\nstatic int siena_mtd_get_fw_subtypes(struct efx_nic *efx,\n\t\t\t\t     struct efx_mcdi_mtd_partition *parts,\n\t\t\t\t     size_t n_parts)\n{\n\tuint16_t fw_subtype_list[\n\t\tMC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MAXNUM];\n\tsize_t i;\n\tint rc;\n\n\trc = efx_siena_mcdi_get_board_cfg(efx, NULL, fw_subtype_list, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < n_parts; i++)\n\t\tparts[i].fw_subtype = fw_subtype_list[parts[i].nvram_type];\n\n\treturn 0;\n}\n\nstatic int siena_mtd_probe(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_mtd_partition *parts;\n\tu32 nvram_types;\n\tunsigned int type;\n\tsize_t n_parts;\n\tint rc;\n\n\tASSERT_RTNL();\n\n\trc = efx_siena_mcdi_nvram_types(efx, &nvram_types);\n\tif (rc)\n\t\treturn rc;\n\n\tparts = kcalloc(hweight32(nvram_types), sizeof(*parts), GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\ttype = 0;\n\tn_parts = 0;\n\n\twhile (nvram_types != 0) {\n\t\tif (nvram_types & 1) {\n\t\t\trc = siena_mtd_probe_partition(efx, &parts[n_parts],\n\t\t\t\t\t\t       type);\n\t\t\tif (rc == 0)\n\t\t\t\tn_parts++;\n\t\t\telse if (rc != -ENODEV)\n\t\t\t\tgoto fail;\n\t\t}\n\t\ttype++;\n\t\tnvram_types >>= 1;\n\t}\n\n\trc = siena_mtd_get_fw_subtypes(efx, parts, n_parts);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_siena_mtd_add(efx, &parts[0].common, n_parts, sizeof(*parts));\nfail:\n\tif (rc)\n\t\tkfree(parts);\n\treturn rc;\n}\n\n#endif  \n\nstatic unsigned int siena_check_caps(const struct efx_nic *efx,\n\t\t\t\t     u8 flag, u32 offset)\n{\n\t \n\treturn 0;\n}\n\nstatic unsigned int efx_siena_recycle_ring_size(const struct efx_nic *efx)\n{\n\t \n\treturn EFX_RECYCLE_RING_SIZE_10G;\n}\n\n \n\nconst struct efx_nic_type siena_a0_nic_type = {\n\t.is_vf = false,\n\t.mem_bar = siena_mem_bar,\n\t.mem_map_size = siena_mem_map_size,\n\t.probe = siena_probe_nic,\n\t.remove = siena_remove_nic,\n\t.init = siena_init_nic,\n\t.dimension_resources = siena_dimension_resources,\n\t.fini = efx_siena_port_dummy_op_void,\n#ifdef CONFIG_EEH\n\t.monitor = siena_monitor,\n#else\n\t.monitor = NULL,\n#endif\n\t.map_reset_reason = efx_siena_mcdi_map_reset_reason,\n\t.map_reset_flags = siena_map_reset_flags,\n\t.reset = efx_siena_mcdi_reset,\n\t.probe_port = efx_siena_mcdi_port_probe,\n\t.remove_port = efx_siena_mcdi_port_remove,\n\t.fini_dmaq = efx_farch_fini_dmaq,\n\t.prepare_flush = efx_siena_prepare_flush,\n\t.finish_flush = siena_finish_flush,\n\t.prepare_flr = efx_siena_port_dummy_op_void,\n\t.finish_flr = efx_farch_finish_flr,\n\t.describe_stats = siena_describe_nic_stats,\n\t.update_stats = siena_update_nic_stats,\n\t.start_stats = efx_siena_mcdi_mac_start_stats,\n\t.pull_stats = efx_siena_mcdi_mac_pull_stats,\n\t.stop_stats = efx_siena_mcdi_mac_stop_stats,\n\t.push_irq_moderation = siena_push_irq_moderation,\n\t.reconfigure_mac = siena_mac_reconfigure,\n\t.check_mac_fault = efx_siena_mcdi_mac_check_fault,\n\t.reconfigure_port = efx_siena_mcdi_port_reconfigure,\n\t.get_wol = siena_get_wol,\n\t.set_wol = siena_set_wol,\n\t.resume_wol = siena_init_wol,\n\t.test_chip = siena_test_chip,\n\t.test_nvram = efx_siena_mcdi_nvram_test_all,\n\t.mcdi_request = siena_mcdi_request,\n\t.mcdi_poll_response = siena_mcdi_poll_response,\n\t.mcdi_read_response = siena_mcdi_read_response,\n\t.mcdi_poll_reboot = siena_mcdi_poll_reboot,\n\t.irq_enable_master = efx_farch_irq_enable_master,\n\t.irq_test_generate = efx_farch_irq_test_generate,\n\t.irq_disable_non_ev = efx_farch_irq_disable_master,\n\t.irq_handle_msi = efx_farch_msi_interrupt,\n\t.irq_handle_legacy = efx_farch_legacy_interrupt,\n\t.tx_probe = efx_farch_tx_probe,\n\t.tx_init = efx_farch_tx_init,\n\t.tx_remove = efx_farch_tx_remove,\n\t.tx_write = efx_farch_tx_write,\n\t.tx_limit_len = efx_farch_tx_limit_len,\n\t.tx_enqueue = __efx_siena_enqueue_skb,\n\t.rx_push_rss_config = siena_rx_push_rss_config,\n\t.rx_pull_rss_config = siena_rx_pull_rss_config,\n\t.rx_probe = efx_farch_rx_probe,\n\t.rx_init = efx_farch_rx_init,\n\t.rx_remove = efx_farch_rx_remove,\n\t.rx_write = efx_farch_rx_write,\n\t.rx_defer_refill = efx_farch_rx_defer_refill,\n\t.rx_packet = __efx_siena_rx_packet,\n\t.ev_probe = efx_farch_ev_probe,\n\t.ev_init = efx_farch_ev_init,\n\t.ev_fini = efx_farch_ev_fini,\n\t.ev_remove = efx_farch_ev_remove,\n\t.ev_process = efx_farch_ev_process,\n\t.ev_read_ack = efx_farch_ev_read_ack,\n\t.ev_test_generate = efx_farch_ev_test_generate,\n\t.filter_table_probe = efx_farch_filter_table_probe,\n\t.filter_table_restore = efx_farch_filter_table_restore,\n\t.filter_table_remove = efx_farch_filter_table_remove,\n\t.filter_update_rx_scatter = efx_farch_filter_update_rx_scatter,\n\t.filter_insert = efx_farch_filter_insert,\n\t.filter_remove_safe = efx_farch_filter_remove_safe,\n\t.filter_get_safe = efx_farch_filter_get_safe,\n\t.filter_clear_rx = efx_farch_filter_clear_rx,\n\t.filter_count_rx_used = efx_farch_filter_count_rx_used,\n\t.filter_get_rx_id_limit = efx_farch_filter_get_rx_id_limit,\n\t.filter_get_rx_ids = efx_farch_filter_get_rx_ids,\n#ifdef CONFIG_RFS_ACCEL\n\t.filter_rfs_expire_one = efx_farch_filter_rfs_expire_one,\n#endif\n#ifdef CONFIG_SFC_SIENA_MTD\n\t.mtd_probe = siena_mtd_probe,\n\t.mtd_rename = efx_siena_mcdi_mtd_rename,\n\t.mtd_read = efx_siena_mcdi_mtd_read,\n\t.mtd_erase = efx_siena_mcdi_mtd_erase,\n\t.mtd_write = efx_siena_mcdi_mtd_write,\n\t.mtd_sync = efx_siena_mcdi_mtd_sync,\n#endif\n\t.ptp_write_host_time = siena_ptp_write_host_time,\n\t.ptp_set_ts_config = siena_ptp_set_ts_config,\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\t.sriov_configure = efx_siena_sriov_configure,\n\t.sriov_init = efx_siena_sriov_init,\n\t.sriov_fini = efx_siena_sriov_fini,\n\t.sriov_wanted = efx_siena_sriov_wanted,\n\t.sriov_reset = efx_siena_sriov_reset,\n\t.sriov_flr = efx_siena_sriov_flr,\n\t.sriov_set_vf_mac = efx_siena_sriov_set_vf_mac,\n\t.sriov_set_vf_vlan = efx_siena_sriov_set_vf_vlan,\n\t.sriov_set_vf_spoofchk = efx_siena_sriov_set_vf_spoofchk,\n\t.sriov_get_vf_config = efx_siena_sriov_get_vf_config,\n\t.vswitching_probe = efx_siena_port_dummy_op_int,\n\t.vswitching_restore = efx_siena_port_dummy_op_int,\n\t.vswitching_remove = efx_siena_port_dummy_op_void,\n\t.set_mac_address = efx_siena_sriov_mac_address_changed,\n#endif\n\n\t.revision = EFX_REV_SIENA_A0,\n\t.txd_ptr_tbl_base = FR_BZ_TX_DESC_PTR_TBL,\n\t.rxd_ptr_tbl_base = FR_BZ_RX_DESC_PTR_TBL,\n\t.buf_tbl_base = FR_BZ_BUF_FULL_TBL,\n\t.evq_ptr_tbl_base = FR_BZ_EVQ_PTR_TBL,\n\t.evq_rptr_tbl_base = FR_BZ_EVQ_RPTR,\n\t.max_dma_mask = DMA_BIT_MASK(FSF_AZ_TX_KER_BUF_ADDR_WIDTH),\n\t.rx_prefix_size = FS_BZ_RX_PREFIX_SIZE,\n\t.rx_hash_offset = FS_BZ_RX_PREFIX_HASH_OFST,\n\t.rx_buffer_padding = 0,\n\t.can_rx_scatter = true,\n\t.option_descriptors = false,\n\t.min_interrupt_mode = EFX_INT_MODE_LEGACY,\n\t.timer_period_max = 1 << FRF_CZ_TC_TIMER_VAL_WIDTH,\n\t.offload_features = (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\t\t     NETIF_F_RXHASH | NETIF_F_NTUPLE),\n\t.mcdi_max_ver = 1,\n\t.max_rx_ip_filters = FR_BZ_RX_FILTER_TBL0_ROWS,\n\t.hwtstamp_filters = (1 << HWTSTAMP_FILTER_NONE |\n\t\t\t     1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT |\n\t\t\t     1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT),\n\t.rx_hash_key_size = 16,\n\t.check_caps = siena_check_caps,\n\t.sensor_event = efx_siena_mcdi_sensor_event,\n\t.rx_recycle_ring_size = efx_siena_recycle_ring_size,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}