{
  "module_name": "mcdi_mon.c",
  "hash_id": "60dc6398d4f9501b95d552c185ee6dd043aac2c6c242e5607a9c8a6ed54aede3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/siena/mcdi_mon.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/hwmon.h>\n#include <linux/stat.h>\n\n#include \"net_driver.h\"\n#include \"mcdi.h\"\n#include \"mcdi_pcol.h\"\n#include \"nic.h\"\n\nenum efx_hwmon_type {\n\tEFX_HWMON_UNKNOWN,\n\tEFX_HWMON_TEMP,          \n\tEFX_HWMON_COOL,          \n\tEFX_HWMON_IN,\t\t \n\tEFX_HWMON_CURR,\t\t \n\tEFX_HWMON_POWER,\t \n\tEFX_HWMON_TYPES_COUNT\n};\n\nstatic const char *const efx_hwmon_unit[EFX_HWMON_TYPES_COUNT] = {\n\t[EFX_HWMON_TEMP]  = \" degC\",\n\t[EFX_HWMON_COOL]  = \" rpm\",  \n\t[EFX_HWMON_IN]    = \" mV\",\n\t[EFX_HWMON_CURR]  = \" mA\",\n\t[EFX_HWMON_POWER] = \" W\",\n};\n\nstatic const struct {\n\tconst char *label;\n\tenum efx_hwmon_type hwmon_type;\n\tint port;\n} efx_mcdi_sensor_type[] = {\n#define SENSOR(name, label, hwmon_type, port)\t\t\t\t\\\n\t[MC_CMD_SENSOR_##name] = { label, EFX_HWMON_ ## hwmon_type, port }\n\tSENSOR(CONTROLLER_TEMP,\t\t\"Controller board temp.\",   TEMP,  -1),\n\tSENSOR(PHY_COMMON_TEMP,\t\t\"PHY temp.\",\t\t    TEMP,  -1),\n\tSENSOR(CONTROLLER_COOLING,\t\"Controller heat sink\",\t    COOL,  -1),\n\tSENSOR(PHY0_TEMP,\t\t\"PHY temp.\",\t\t    TEMP,  0),\n\tSENSOR(PHY0_COOLING,\t\t\"PHY heat sink\",\t    COOL,  0),\n\tSENSOR(PHY1_TEMP,\t\t\"PHY temp.\",\t\t    TEMP,  1),\n\tSENSOR(PHY1_COOLING,\t\t\"PHY heat sink\",\t    COOL,  1),\n\tSENSOR(IN_1V0,\t\t\t\"1.0V supply\",\t\t    IN,    -1),\n\tSENSOR(IN_1V2,\t\t\t\"1.2V supply\",\t\t    IN,    -1),\n\tSENSOR(IN_1V8,\t\t\t\"1.8V supply\",\t\t    IN,    -1),\n\tSENSOR(IN_2V5,\t\t\t\"2.5V supply\",\t\t    IN,    -1),\n\tSENSOR(IN_3V3,\t\t\t\"3.3V supply\",\t\t    IN,    -1),\n\tSENSOR(IN_12V0,\t\t\t\"12.0V supply\",\t\t    IN,    -1),\n\tSENSOR(IN_1V2A,\t\t\t\"1.2V analogue supply\",\t    IN,    -1),\n\tSENSOR(IN_VREF,\t\t\t\"Ref. voltage\",\t\t    IN,    -1),\n\tSENSOR(OUT_VAOE,\t\t\"AOE FPGA supply\",\t    IN,    -1),\n\tSENSOR(AOE_TEMP,\t\t\"AOE FPGA temp.\",\t    TEMP,  -1),\n\tSENSOR(PSU_AOE_TEMP,\t\t\"AOE regulator temp.\",\t    TEMP,  -1),\n\tSENSOR(PSU_TEMP,\t\t\"Controller regulator temp.\",\n\t\t\t\t\t\t\t\t    TEMP,  -1),\n\tSENSOR(FAN_0,\t\t\t\"Fan 0\",\t\t    COOL,  -1),\n\tSENSOR(FAN_1,\t\t\t\"Fan 1\",\t\t    COOL,  -1),\n\tSENSOR(FAN_2,\t\t\t\"Fan 2\",\t\t    COOL,  -1),\n\tSENSOR(FAN_3,\t\t\t\"Fan 3\",\t\t    COOL,  -1),\n\tSENSOR(FAN_4,\t\t\t\"Fan 4\",\t\t    COOL,  -1),\n\tSENSOR(IN_VAOE,\t\t\t\"AOE input supply\",\t    IN,    -1),\n\tSENSOR(OUT_IAOE,\t\t\"AOE output current\",\t    CURR,  -1),\n\tSENSOR(IN_IAOE,\t\t\t\"AOE input current\",\t    CURR,  -1),\n\tSENSOR(NIC_POWER,\t\t\"Board power use\",\t    POWER, -1),\n\tSENSOR(IN_0V9,\t\t\t\"0.9V supply\",\t\t    IN,    -1),\n\tSENSOR(IN_I0V9,\t\t\t\"0.9V supply current\",\t    CURR,  -1),\n\tSENSOR(IN_I1V2,\t\t\t\"1.2V supply current\",\t    CURR,  -1),\n\tSENSOR(IN_0V9_ADC,\t\t\"0.9V supply (ext. ADC)\",   IN,    -1),\n\tSENSOR(CONTROLLER_2_TEMP,\t\"Controller board temp. 2\", TEMP,  -1),\n\tSENSOR(VREG_INTERNAL_TEMP,\t\"Regulator die temp.\",\t    TEMP,  -1),\n\tSENSOR(VREG_0V9_TEMP,\t\t\"0.9V regulator temp.\",     TEMP,  -1),\n\tSENSOR(VREG_1V2_TEMP,\t\t\"1.2V regulator temp.\",     TEMP,  -1),\n\tSENSOR(CONTROLLER_VPTAT,\n\t\t\t      \"Controller PTAT voltage (int. ADC)\", IN,    -1),\n\tSENSOR(CONTROLLER_INTERNAL_TEMP,\n\t\t\t\t \"Controller die temp. (int. ADC)\", TEMP,  -1),\n\tSENSOR(CONTROLLER_VPTAT_EXTADC,\n\t\t\t      \"Controller PTAT voltage (ext. ADC)\", IN,    -1),\n\tSENSOR(CONTROLLER_INTERNAL_TEMP_EXTADC,\n\t\t\t\t \"Controller die temp. (ext. ADC)\", TEMP,  -1),\n\tSENSOR(AMBIENT_TEMP,\t\t\"Ambient temp.\",\t    TEMP,  -1),\n\tSENSOR(AIRFLOW,\t\t\t\"Air flow raw\",\t\t    IN,    -1),\n\tSENSOR(VDD08D_VSS08D_CSR,\t\"0.9V die (int. ADC)\",\t    IN,    -1),\n\tSENSOR(VDD08D_VSS08D_CSR_EXTADC, \"0.9V die (ext. ADC)\",\t    IN,    -1),\n\tSENSOR(HOTPOINT_TEMP,  \"Controller board temp. (hotpoint)\", TEMP,  -1),\n#undef SENSOR\n};\n\nstatic const char *const sensor_status_names[] = {\n\t[MC_CMD_SENSOR_STATE_OK] = \"OK\",\n\t[MC_CMD_SENSOR_STATE_WARNING] = \"Warning\",\n\t[MC_CMD_SENSOR_STATE_FATAL] = \"Fatal\",\n\t[MC_CMD_SENSOR_STATE_BROKEN] = \"Device failure\",\n\t[MC_CMD_SENSOR_STATE_NO_READING] = \"No reading\",\n};\n\nvoid efx_siena_mcdi_sensor_event(struct efx_nic *efx, efx_qword_t *ev)\n{\n\tunsigned int type, state, value;\n\tenum efx_hwmon_type hwmon_type = EFX_HWMON_UNKNOWN;\n\tconst char *name = NULL, *state_txt, *unit;\n\n\ttype = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_MONITOR);\n\tstate = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_STATE);\n\tvalue = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_VALUE);\n\n\t \n\tif (type < ARRAY_SIZE(efx_mcdi_sensor_type)) {\n\t\tname = efx_mcdi_sensor_type[type].label;\n\t\thwmon_type = efx_mcdi_sensor_type[type].hwmon_type;\n\t}\n\tif (!name)\n\t\tname = \"No sensor name available\";\n\tEFX_WARN_ON_PARANOID(state >= ARRAY_SIZE(sensor_status_names));\n\tstate_txt = sensor_status_names[state];\n\tEFX_WARN_ON_PARANOID(hwmon_type >= EFX_HWMON_TYPES_COUNT);\n\tunit = efx_hwmon_unit[hwmon_type];\n\tif (!unit)\n\t\tunit = \"\";\n\n\tnetif_err(efx, hw, efx->net_dev,\n\t\t  \"Sensor %d (%s) reports condition '%s' for value %d%s\\n\",\n\t\t  type, name, state_txt, value, unit);\n}\n\n#ifdef CONFIG_SFC_SIENA_MCDI_MON\n\nstruct efx_mcdi_mon_attribute {\n\tstruct device_attribute dev_attr;\n\tunsigned int index;\n\tunsigned int type;\n\tenum efx_hwmon_type hwmon_type;\n\tunsigned int limit_value;\n\tchar name[12];\n};\n\nstatic int efx_mcdi_mon_update(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_READ_SENSORS_EXT_IN_LEN);\n\tint rc;\n\n\tMCDI_SET_QWORD(inbuf, READ_SENSORS_EXT_IN_DMA_ADDR,\n\t\t       hwmon->dma_buf.dma_addr);\n\tMCDI_SET_DWORD(inbuf, READ_SENSORS_EXT_IN_LENGTH, hwmon->dma_buf.len);\n\n\trc = efx_siena_mcdi_rpc(efx, MC_CMD_READ_SENSORS,\n\t\t\t\tinbuf, sizeof(inbuf), NULL, 0, NULL);\n\tif (rc == 0)\n\t\thwmon->last_update = jiffies;\n\treturn rc;\n}\n\nstatic int efx_mcdi_mon_get_entry(struct device *dev, unsigned int index,\n\t\t\t\t  efx_dword_t *entry)\n{\n\tstruct efx_nic *efx = dev_get_drvdata(dev->parent);\n\tstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_READ_SENSORS_OUT_LEN != 0);\n\n\tmutex_lock(&hwmon->update_lock);\n\n\t \n\tif (time_before(jiffies, hwmon->last_update + HZ))\n\t\trc = 0;\n\telse\n\t\trc = efx_mcdi_mon_update(efx);\n\n\t \n\t*entry = ((efx_dword_t *)hwmon->dma_buf.addr)[index];\n\n\tmutex_unlock(&hwmon->update_lock);\n\n\treturn rc;\n}\n\nstatic ssize_t efx_mcdi_mon_show_value(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct efx_mcdi_mon_attribute *mon_attr =\n\t\tcontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\n\tefx_dword_t entry;\n\tunsigned int value, state;\n\tint rc;\n\n\trc = efx_mcdi_mon_get_entry(dev, mon_attr->index, &entry);\n\tif (rc)\n\t\treturn rc;\n\n\tstate = EFX_DWORD_FIELD(entry, MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE);\n\tif (state == MC_CMD_SENSOR_STATE_NO_READING)\n\t\treturn -EBUSY;\n\n\tvalue = EFX_DWORD_FIELD(entry, MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE);\n\n\tswitch (mon_attr->hwmon_type) {\n\tcase EFX_HWMON_TEMP:\n\t\t \n\t\tvalue *= 1000;\n\t\tbreak;\n\tcase EFX_HWMON_POWER:\n\t\t \n\t\tvalue *= 1000000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", value);\n}\n\nstatic ssize_t efx_mcdi_mon_show_limit(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct efx_mcdi_mon_attribute *mon_attr =\n\t\tcontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\n\tunsigned int value;\n\n\tvalue = mon_attr->limit_value;\n\n\tswitch (mon_attr->hwmon_type) {\n\tcase EFX_HWMON_TEMP:\n\t\t \n\t\tvalue *= 1000;\n\t\tbreak;\n\tcase EFX_HWMON_POWER:\n\t\t \n\t\tvalue *= 1000000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", value);\n}\n\nstatic ssize_t efx_mcdi_mon_show_alarm(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct efx_mcdi_mon_attribute *mon_attr =\n\t\tcontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\n\tefx_dword_t entry;\n\tint state;\n\tint rc;\n\n\trc = efx_mcdi_mon_get_entry(dev, mon_attr->index, &entry);\n\tif (rc)\n\t\treturn rc;\n\n\tstate = EFX_DWORD_FIELD(entry, MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE);\n\treturn sprintf(buf, \"%d\\n\", state != MC_CMD_SENSOR_STATE_OK);\n}\n\nstatic ssize_t efx_mcdi_mon_show_label(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct efx_mcdi_mon_attribute *mon_attr =\n\t\tcontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       efx_mcdi_sensor_type[mon_attr->type].label);\n}\n\nstatic void\nefx_mcdi_mon_add_attr(struct efx_nic *efx, const char *name,\n\t\t      ssize_t (*reader)(struct device *,\n\t\t\t\t\tstruct device_attribute *, char *),\n\t\t      unsigned int index, unsigned int type,\n\t\t      unsigned int limit_value)\n{\n\tstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\n\tstruct efx_mcdi_mon_attribute *attr = &hwmon->attrs[hwmon->n_attrs];\n\n\tstrscpy(attr->name, name, sizeof(attr->name));\n\tattr->index = index;\n\tattr->type = type;\n\tif (type < ARRAY_SIZE(efx_mcdi_sensor_type))\n\t\tattr->hwmon_type = efx_mcdi_sensor_type[type].hwmon_type;\n\telse\n\t\tattr->hwmon_type = EFX_HWMON_UNKNOWN;\n\tattr->limit_value = limit_value;\n\tsysfs_attr_init(&attr->dev_attr.attr);\n\tattr->dev_attr.attr.name = attr->name;\n\tattr->dev_attr.attr.mode = 0444;\n\tattr->dev_attr.show = reader;\n\thwmon->group.attrs[hwmon->n_attrs++] = &attr->dev_attr.attr;\n}\n\nint efx_siena_mcdi_mon_probe(struct efx_nic *efx)\n{\n\tunsigned int n_temp = 0, n_cool = 0, n_in = 0, n_curr = 0, n_power = 0;\n\tstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_SENSOR_INFO_EXT_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_SENSOR_INFO_OUT_LENMAX);\n\tunsigned int n_pages, n_sensors, n_attrs, page;\n\tsize_t outlen;\n\tchar name[12];\n\tu32 mask;\n\tint rc, i, j, type;\n\n\t \n\tn_sensors = 0;\n\tpage = 0;\n\tdo {\n\t\tMCDI_SET_DWORD(inbuf, SENSOR_INFO_EXT_IN_PAGE, page);\n\n\t\trc = efx_siena_mcdi_rpc(efx, MC_CMD_SENSOR_INFO, inbuf,\n\t\t\t\t\tsizeof(inbuf), outbuf, sizeof(outbuf),\n\t\t\t\t\t&outlen);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (outlen < MC_CMD_SENSOR_INFO_OUT_LENMIN)\n\t\t\treturn -EIO;\n\n\t\tmask = MCDI_DWORD(outbuf, SENSOR_INFO_OUT_MASK);\n\t\tn_sensors += hweight32(mask & ~(1 << MC_CMD_SENSOR_PAGE0_NEXT));\n\t\t++page;\n\t} while (mask & (1 << MC_CMD_SENSOR_PAGE0_NEXT));\n\tn_pages = page;\n\n\t \n\tif (n_sensors == 0)\n\t\treturn 0;\n\n\trc = efx_siena_alloc_buffer(efx, &hwmon->dma_buf,\n\t\t\tn_sensors * MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_LEN,\n\t\t\tGFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_init(&hwmon->update_lock);\n\tefx_mcdi_mon_update(efx);\n\n\t \n\tn_attrs = 6 * n_sensors;\n\thwmon->attrs = kcalloc(n_attrs, sizeof(*hwmon->attrs), GFP_KERNEL);\n\tif (!hwmon->attrs) {\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\thwmon->group.attrs = kcalloc(n_attrs + 1, sizeof(struct attribute *),\n\t\t\t\t     GFP_KERNEL);\n\tif (!hwmon->group.attrs) {\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0, j = -1, type = -1; ; i++) {\n\t\tenum efx_hwmon_type hwmon_type;\n\t\tconst char *hwmon_prefix;\n\t\tunsigned hwmon_index;\n\t\tu16 min1, max1, min2, max2;\n\n\t\t \n\t\tdo {\n\t\t\ttype++;\n\n\t\t\tif ((type % 32) == 0) {\n\t\t\t\tpage = type / 32;\n\t\t\t\tj = -1;\n\t\t\t\tif (page == n_pages)\n\t\t\t\t\tgoto hwmon_register;\n\n\t\t\t\tMCDI_SET_DWORD(inbuf, SENSOR_INFO_EXT_IN_PAGE,\n\t\t\t\t\t       page);\n\t\t\t\trc = efx_siena_mcdi_rpc(efx, MC_CMD_SENSOR_INFO,\n\t\t\t\t\t\t\tinbuf, sizeof(inbuf),\n\t\t\t\t\t\t\toutbuf, sizeof(outbuf),\n\t\t\t\t\t\t\t&outlen);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto fail;\n\t\t\t\tif (outlen < MC_CMD_SENSOR_INFO_OUT_LENMIN) {\n\t\t\t\t\trc = -EIO;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\n\t\t\t\tmask = (MCDI_DWORD(outbuf,\n\t\t\t\t\t\t   SENSOR_INFO_OUT_MASK) &\n\t\t\t\t\t~(1 << MC_CMD_SENSOR_PAGE0_NEXT));\n\n\t\t\t\t \n\t\t\t\tif (outlen <\n\t\t\t\t    MC_CMD_SENSOR_INFO_OUT_LEN(hweight32(mask))) {\n\t\t\t\t\trc = -EIO;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!(mask & (1 << type % 32)));\n\t\tj++;\n\n\t\tif (type < ARRAY_SIZE(efx_mcdi_sensor_type)) {\n\t\t\thwmon_type = efx_mcdi_sensor_type[type].hwmon_type;\n\n\t\t\t \n\t\t\tif (hwmon_type != EFX_HWMON_UNKNOWN &&\n\t\t\t    efx_mcdi_sensor_type[type].port >= 0 &&\n\t\t\t    efx_mcdi_sensor_type[type].port !=\n\t\t\t    efx_port_num(efx))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\thwmon_type = EFX_HWMON_UNKNOWN;\n\t\t}\n\n\t\tswitch (hwmon_type) {\n\t\tcase EFX_HWMON_TEMP:\n\t\t\thwmon_prefix = \"temp\";\n\t\t\thwmon_index = ++n_temp;  \n\t\t\tbreak;\n\t\tcase EFX_HWMON_COOL:\n\t\t\t \n\t\t\thwmon_prefix = \"fan\";\n\t\t\thwmon_index = ++n_cool;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\thwmon_prefix = \"in\";\n\t\t\thwmon_index = n_in++;  \n\t\t\tbreak;\n\t\tcase EFX_HWMON_CURR:\n\t\t\thwmon_prefix = \"curr\";\n\t\t\thwmon_index = ++n_curr;  \n\t\t\tbreak;\n\t\tcase EFX_HWMON_POWER:\n\t\t\thwmon_prefix = \"power\";\n\t\t\thwmon_index = ++n_power;  \n\t\t\tbreak;\n\t\t}\n\n\t\tmin1 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\n\t\t\t\t\tSENSOR_INFO_ENTRY, j, MIN1);\n\t\tmax1 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\n\t\t\t\t\tSENSOR_INFO_ENTRY, j, MAX1);\n\t\tmin2 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\n\t\t\t\t\tSENSOR_INFO_ENTRY, j, MIN2);\n\t\tmax2 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\n\t\t\t\t\tSENSOR_INFO_ENTRY, j, MAX2);\n\n\t\tif (min1 != max1) {\n\t\t\tsnprintf(name, sizeof(name), \"%s%u_input\",\n\t\t\t\t hwmon_prefix, hwmon_index);\n\t\t\tefx_mcdi_mon_add_attr(\n\t\t\t\tefx, name, efx_mcdi_mon_show_value, i, type, 0);\n\n\t\t\tif (hwmon_type != EFX_HWMON_POWER) {\n\t\t\t\tsnprintf(name, sizeof(name), \"%s%u_min\",\n\t\t\t\t\t hwmon_prefix, hwmon_index);\n\t\t\t\tefx_mcdi_mon_add_attr(\n\t\t\t\t\tefx, name, efx_mcdi_mon_show_limit,\n\t\t\t\t\ti, type, min1);\n\t\t\t}\n\n\t\t\tsnprintf(name, sizeof(name), \"%s%u_max\",\n\t\t\t\t hwmon_prefix, hwmon_index);\n\t\t\tefx_mcdi_mon_add_attr(\n\t\t\t\tefx, name, efx_mcdi_mon_show_limit,\n\t\t\t\ti, type, max1);\n\n\t\t\tif (min2 != max2) {\n\t\t\t\t \n\t\t\t\tsnprintf(name, sizeof(name), \"%s%u_crit\",\n\t\t\t\t\t hwmon_prefix, hwmon_index);\n\t\t\t\tefx_mcdi_mon_add_attr(\n\t\t\t\t\tefx, name, efx_mcdi_mon_show_limit,\n\t\t\t\t\ti, type, max2);\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"%s%u_alarm\",\n\t\t\t hwmon_prefix, hwmon_index);\n\t\tefx_mcdi_mon_add_attr(\n\t\t\tefx, name, efx_mcdi_mon_show_alarm, i, type, 0);\n\n\t\tif (type < ARRAY_SIZE(efx_mcdi_sensor_type) &&\n\t\t    efx_mcdi_sensor_type[type].label) {\n\t\t\tsnprintf(name, sizeof(name), \"%s%u_label\",\n\t\t\t\t hwmon_prefix, hwmon_index);\n\t\t\tefx_mcdi_mon_add_attr(\n\t\t\t\tefx, name, efx_mcdi_mon_show_label, i, type, 0);\n\t\t}\n\t}\n\nhwmon_register:\n\thwmon->groups[0] = &hwmon->group;\n\thwmon->device = hwmon_device_register_with_groups(&efx->pci_dev->dev,\n\t\t\t\t\t\t\t  KBUILD_MODNAME, NULL,\n\t\t\t\t\t\t\t  hwmon->groups);\n\tif (IS_ERR(hwmon->device)) {\n\t\trc = PTR_ERR(hwmon->device);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tefx_siena_mcdi_mon_remove(efx);\n\treturn rc;\n}\n\nvoid efx_siena_mcdi_mon_remove(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\n\n\tif (hwmon->device)\n\t\thwmon_device_unregister(hwmon->device);\n\tkfree(hwmon->attrs);\n\tkfree(hwmon->group.attrs);\n\tefx_siena_free_buffer(efx, &hwmon->dma_buf);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}