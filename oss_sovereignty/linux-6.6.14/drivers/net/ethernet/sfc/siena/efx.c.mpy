{
  "module_name": "efx.c",
  "hash_id": "e2db57ce7398bbf1a9134202e662543e551ade3140f5edc49cd9025e92b2e0b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/siena/efx.c",
  "human_readable_source": "\n \n\n#include <linux/filter.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/in.h>\n#include <linux/ethtool.h>\n#include <linux/topology.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include \"net_driver.h\"\n#include <net/gre.h>\n#include <net/udp_tunnel.h>\n#include \"efx.h\"\n#include \"efx_common.h\"\n#include \"efx_channels.h\"\n#include \"rx_common.h\"\n#include \"tx_common.h\"\n#include \"nic.h\"\n#include \"io.h\"\n#include \"selftest.h\"\n#include \"sriov.h\"\n#ifdef CONFIG_SFC_SIENA_SRIOV\n#include \"siena_sriov.h\"\n#endif\n\n#include \"mcdi_port_common.h\"\n#include \"mcdi_pcol.h\"\n#include \"workarounds.h\"\n\n \n\nmodule_param_named(interrupt_mode, efx_siena_interrupt_mode, uint, 0444);\nMODULE_PARM_DESC(interrupt_mode,\n\t\t \"Interrupt mode (0=>MSIX 1=>MSI 2=>legacy)\");\n\nmodule_param_named(rss_cpus, efx_siena_rss_cpus, uint, 0444);\nMODULE_PARM_DESC(rss_cpus, \"Number of CPUs to use for Receive-Side Scaling\");\n\n \nbool efx_siena_separate_tx_channels;\nmodule_param_named(efx_separate_tx_channels, efx_siena_separate_tx_channels,\n\t\t   bool, 0444);\nMODULE_PARM_DESC(efx_separate_tx_channels,\n\t\t \"Use separate channels for TX and RX\");\n\n \nstatic unsigned int rx_irq_mod_usec = 60;\n\n \nstatic unsigned int tx_irq_mod_usec = 150;\n\nstatic bool phy_flash_cfg;\nmodule_param(phy_flash_cfg, bool, 0644);\nMODULE_PARM_DESC(phy_flash_cfg, \"Set PHYs into reflash mode initially\");\n\nstatic unsigned debug = (NETIF_MSG_DRV | NETIF_MSG_PROBE |\n\t\t\t NETIF_MSG_LINK | NETIF_MSG_IFDOWN |\n\t\t\t NETIF_MSG_IFUP | NETIF_MSG_RX_ERR |\n\t\t\t NETIF_MSG_TX_ERR | NETIF_MSG_HW);\nmodule_param(debug, uint, 0);\nMODULE_PARM_DESC(debug, \"Bitmapped debugging message enable value\");\n\n \n\nstatic void efx_remove_port(struct efx_nic *efx);\nstatic int efx_xdp_setup_prog(struct efx_nic *efx, struct bpf_prog *prog);\nstatic int efx_xdp(struct net_device *dev, struct netdev_bpf *xdp);\nstatic int efx_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **xdpfs,\n\t\t\tu32 flags);\n\n#define EFX_ASSERT_RESET_SERIALISED(efx)\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif ((efx->state == STATE_READY) ||\t\\\n\t\t    (efx->state == STATE_RECOVERY) ||\t\\\n\t\t    (efx->state == STATE_DISABLED))\t\\\n\t\t\tASSERT_RTNL();\t\t\t\\\n\t} while (0)\n\n \n\nstatic void efx_fini_port(struct efx_nic *efx);\n\nstatic int efx_probe_port(struct efx_nic *efx)\n{\n\tint rc;\n\n\tnetif_dbg(efx, probe, efx->net_dev, \"create port\\n\");\n\n\tif (phy_flash_cfg)\n\t\tefx->phy_mode = PHY_MODE_SPECIAL;\n\n\t \n\trc = efx->type->probe_port(efx);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\teth_hw_addr_set(efx->net_dev, efx->net_dev->perm_addr);\n\n\treturn 0;\n}\n\nstatic int efx_init_port(struct efx_nic *efx)\n{\n\tint rc;\n\n\tnetif_dbg(efx, drv, efx->net_dev, \"init port\\n\");\n\n\tmutex_lock(&efx->mac_lock);\n\n\tefx->port_initialized = true;\n\n\t \n\trc = efx_siena_mcdi_port_reconfigure(efx);\n\tif (rc && rc != -EPERM)\n\t\tgoto fail;\n\n\tmutex_unlock(&efx->mac_lock);\n\treturn 0;\n\nfail:\n\tmutex_unlock(&efx->mac_lock);\n\treturn rc;\n}\n\nstatic void efx_fini_port(struct efx_nic *efx)\n{\n\tnetif_dbg(efx, drv, efx->net_dev, \"shut down port\\n\");\n\n\tif (!efx->port_initialized)\n\t\treturn;\n\n\tefx->port_initialized = false;\n\n\tefx->link_state.up = false;\n\tefx_siena_link_status_changed(efx);\n}\n\nstatic void efx_remove_port(struct efx_nic *efx)\n{\n\tnetif_dbg(efx, drv, efx->net_dev, \"destroying port\\n\");\n\n\tefx->type->remove_port(efx);\n}\n\n \n\nstatic LIST_HEAD(efx_primary_list);\nstatic LIST_HEAD(efx_unassociated_list);\n\nstatic bool efx_same_controller(struct efx_nic *left, struct efx_nic *right)\n{\n\treturn left->type == right->type &&\n\t\tleft->vpd_sn && right->vpd_sn &&\n\t\t!strcmp(left->vpd_sn, right->vpd_sn);\n}\n\nstatic void efx_associate(struct efx_nic *efx)\n{\n\tstruct efx_nic *other, *next;\n\n\tif (efx->primary == efx) {\n\t\t \n\n\t\tnetif_dbg(efx, probe, efx->net_dev, \"adding to primary list\\n\");\n\t\tlist_add_tail(&efx->node, &efx_primary_list);\n\n\t\tlist_for_each_entry_safe(other, next, &efx_unassociated_list,\n\t\t\t\t\t node) {\n\t\t\tif (efx_same_controller(efx, other)) {\n\t\t\t\tlist_del(&other->node);\n\t\t\t\tnetif_dbg(other, probe, other->net_dev,\n\t\t\t\t\t  \"moving to secondary list of %s %s\\n\",\n\t\t\t\t\t  pci_name(efx->pci_dev),\n\t\t\t\t\t  efx->net_dev->name);\n\t\t\t\tlist_add_tail(&other->node,\n\t\t\t\t\t      &efx->secondary_list);\n\t\t\t\tother->primary = efx;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\n\t\tlist_for_each_entry(other, &efx_primary_list, node) {\n\t\t\tif (efx_same_controller(efx, other)) {\n\t\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t\t  \"adding to secondary list of %s %s\\n\",\n\t\t\t\t\t  pci_name(other->pci_dev),\n\t\t\t\t\t  other->net_dev->name);\n\t\t\t\tlist_add_tail(&efx->node,\n\t\t\t\t\t      &other->secondary_list);\n\t\t\t\tefx->primary = other;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"adding to unassociated list\\n\");\n\t\tlist_add_tail(&efx->node, &efx_unassociated_list);\n\t}\n}\n\nstatic void efx_dissociate(struct efx_nic *efx)\n{\n\tstruct efx_nic *other, *next;\n\n\tlist_del(&efx->node);\n\tefx->primary = NULL;\n\n\tlist_for_each_entry_safe(other, next, &efx->secondary_list, node) {\n\t\tlist_del(&other->node);\n\t\tnetif_dbg(other, probe, other->net_dev,\n\t\t\t  \"moving to unassociated list\\n\");\n\t\tlist_add_tail(&other->node, &efx_unassociated_list);\n\t\tother->primary = NULL;\n\t}\n}\n\nstatic int efx_probe_nic(struct efx_nic *efx)\n{\n\tint rc;\n\n\tnetif_dbg(efx, probe, efx->net_dev, \"creating NIC\\n\");\n\n\t \n\trc = efx->type->probe(efx);\n\tif (rc)\n\t\treturn rc;\n\n\tdo {\n\t\tif (!efx->max_channels || !efx->max_tx_channels) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"Insufficient resources to allocate\"\n\t\t\t\t  \" any channels\\n\");\n\t\t\trc = -ENOSPC;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\t \n\t\trc = efx_siena_probe_interrupts(efx);\n\t\tif (rc)\n\t\t\tgoto fail1;\n\n\t\trc = efx_siena_set_channels(efx);\n\t\tif (rc)\n\t\t\tgoto fail1;\n\n\t\t \n\t\trc = efx->type->dimension_resources(efx);\n\t\tif (rc != 0 && rc != -EAGAIN)\n\t\t\tgoto fail2;\n\n\t\tif (rc == -EAGAIN)\n\t\t\t \n\t\t\tefx_siena_remove_interrupts(efx);\n\n\t} while (rc == -EAGAIN);\n\n\tif (efx->n_channels > 1)\n\t\tnetdev_rss_key_fill(efx->rss_context.rx_hash_key,\n\t\t\t\t    sizeof(efx->rss_context.rx_hash_key));\n\tefx_siena_set_default_rx_indir_table(efx, &efx->rss_context);\n\n\t \n\tefx->irq_mod_step_us = DIV_ROUND_UP(efx->timer_quantum_ns, 1000);\n\tefx_siena_init_irq_moderation(efx, tx_irq_mod_usec, rx_irq_mod_usec,\n\t\t\t\t      true, true);\n\n\treturn 0;\n\nfail2:\n\tefx_siena_remove_interrupts(efx);\nfail1:\n\tefx->type->remove(efx);\n\treturn rc;\n}\n\nstatic void efx_remove_nic(struct efx_nic *efx)\n{\n\tnetif_dbg(efx, drv, efx->net_dev, \"destroying NIC\\n\");\n\n\tefx_siena_remove_interrupts(efx);\n\tefx->type->remove(efx);\n}\n\n \n\nstatic int efx_probe_all(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_probe_nic(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create NIC\\n\");\n\t\tgoto fail1;\n\t}\n\n\trc = efx_probe_port(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create port\\n\");\n\t\tgoto fail2;\n\t}\n\n\tBUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);\n\tif (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {\n\t\trc = -EINVAL;\n\t\tgoto fail3;\n\t}\n\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\trc = efx->type->vswitching_probe(efx);\n\tif (rc)  \n\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t   \"failed to setup vswitching rc=%d;\"\n\t\t\t   \" VFs may not function\\n\", rc);\n#endif\n\n\trc = efx_siena_probe_filters(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"failed to create filter tables\\n\");\n\t\tgoto fail4;\n\t}\n\n\trc = efx_siena_probe_channels(efx);\n\tif (rc)\n\t\tgoto fail5;\n\n\treturn 0;\n\n fail5:\n\tefx_siena_remove_filters(efx);\n fail4:\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\tefx->type->vswitching_remove(efx);\n#endif\n fail3:\n\tefx_remove_port(efx);\n fail2:\n\tefx_remove_nic(efx);\n fail1:\n\treturn rc;\n}\n\nstatic void efx_remove_all(struct efx_nic *efx)\n{\n\trtnl_lock();\n\tefx_xdp_setup_prog(efx, NULL);\n\trtnl_unlock();\n\n\tefx_siena_remove_channels(efx);\n\tefx_siena_remove_filters(efx);\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\tefx->type->vswitching_remove(efx);\n#endif\n\tefx_remove_port(efx);\n\tefx_remove_nic(efx);\n}\n\n \nunsigned int efx_siena_usecs_to_ticks(struct efx_nic *efx, unsigned int usecs)\n{\n\tif (usecs == 0)\n\t\treturn 0;\n\tif (usecs * 1000 < efx->timer_quantum_ns)\n\t\treturn 1;  \n\treturn usecs * 1000 / efx->timer_quantum_ns;\n}\n\n \nint efx_siena_init_irq_moderation(struct efx_nic *efx, unsigned int tx_usecs,\n\t\t\t\t  unsigned int rx_usecs, bool rx_adaptive,\n\t\t\t\t  bool rx_may_override_tx)\n{\n\tstruct efx_channel *channel;\n\tunsigned int timer_max_us;\n\n\tEFX_ASSERT_RESET_SERIALISED(efx);\n\n\ttimer_max_us = efx->timer_max_ns / 1000;\n\n\tif (tx_usecs > timer_max_us || rx_usecs > timer_max_us)\n\t\treturn -EINVAL;\n\n\tif (tx_usecs != rx_usecs && efx->tx_channel_offset == 0 &&\n\t    !rx_may_override_tx) {\n\t\tnetif_err(efx, drv, efx->net_dev, \"Channels are shared. \"\n\t\t\t  \"RX and TX IRQ moderation must be equal\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tefx->irq_rx_adaptive = rx_adaptive;\n\tefx->irq_rx_moderation_us = rx_usecs;\n\tefx_for_each_channel(channel, efx) {\n\t\tif (efx_channel_has_rx_queue(channel))\n\t\t\tchannel->irq_moderation_us = rx_usecs;\n\t\telse if (efx_channel_has_tx_queues(channel))\n\t\t\tchannel->irq_moderation_us = tx_usecs;\n\t\telse if (efx_channel_is_xdp_tx(channel))\n\t\t\tchannel->irq_moderation_us = tx_usecs;\n\t}\n\n\treturn 0;\n}\n\nvoid efx_siena_get_irq_moderation(struct efx_nic *efx, unsigned int *tx_usecs,\n\t\t\t\t  unsigned int *rx_usecs, bool *rx_adaptive)\n{\n\t*rx_adaptive = efx->irq_rx_adaptive;\n\t*rx_usecs = efx->irq_rx_moderation_us;\n\n\t \n\tif (efx->tx_channel_offset == 0) {\n\t\t*tx_usecs = *rx_usecs;\n\t} else {\n\t\tstruct efx_channel *tx_channel;\n\n\t\ttx_channel = efx->channel[efx->tx_channel_offset];\n\t\t*tx_usecs = tx_channel->irq_moderation_us;\n\t}\n}\n\n \n\n \nstatic int efx_ioctl(struct net_device *net_dev, struct ifreq *ifr, int cmd)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\tif (cmd == SIOCSHWTSTAMP)\n\t\treturn efx_siena_ptp_set_ts_config(efx, ifr);\n\tif (cmd == SIOCGHWTSTAMP)\n\t\treturn efx_siena_ptp_get_ts_config(efx, ifr);\n\n\t \n\tif ((cmd == SIOCGMIIREG || cmd == SIOCSMIIREG) &&\n\t    (data->phy_id & 0xfc00) == 0x0400)\n\t\tdata->phy_id ^= MDIO_PHY_ID_C45 | 0x0400;\n\n\treturn mdio_mii_ioctl(&efx->mdio, data, cmd);\n}\n\n \n\n \nstatic int efx_net_open(struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\tint rc;\n\n\tnetif_dbg(efx, ifup, efx->net_dev, \"opening device on CPU %d\\n\",\n\t\t  raw_smp_processor_id());\n\n\trc = efx_check_disabled(efx);\n\tif (rc)\n\t\treturn rc;\n\tif (efx->phy_mode & PHY_MODE_SPECIAL)\n\t\treturn -EBUSY;\n\tif (efx_siena_mcdi_poll_reboot(efx) && efx_siena_reset(efx, RESET_TYPE_ALL))\n\t\treturn -EIO;\n\n\t \n\tefx_siena_link_status_changed(efx);\n\n\tefx_siena_start_all(efx);\n\tif (efx->state == STATE_DISABLED || efx->reset_pending)\n\t\tnetif_device_detach(efx->net_dev);\n\tefx_siena_selftest_async_start(efx);\n\treturn 0;\n}\n\n \nstatic int efx_net_stop(struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\n\tnetif_dbg(efx, ifdown, efx->net_dev, \"closing on CPU %d\\n\",\n\t\t  raw_smp_processor_id());\n\n\t \n\tefx_siena_stop_all(efx);\n\n\treturn 0;\n}\n\nstatic int efx_vlan_rx_add_vid(struct net_device *net_dev, __be16 proto, u16 vid)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\n\tif (efx->type->vlan_rx_add_vid)\n\t\treturn efx->type->vlan_rx_add_vid(efx, proto, vid);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic int efx_vlan_rx_kill_vid(struct net_device *net_dev, __be16 proto, u16 vid)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\n\tif (efx->type->vlan_rx_kill_vid)\n\t\treturn efx->type->vlan_rx_kill_vid(efx, proto, vid);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic const struct net_device_ops efx_netdev_ops = {\n\t.ndo_open\t\t= efx_net_open,\n\t.ndo_stop\t\t= efx_net_stop,\n\t.ndo_get_stats64\t= efx_siena_net_stats,\n\t.ndo_tx_timeout\t\t= efx_siena_watchdog,\n\t.ndo_start_xmit\t\t= efx_siena_hard_start_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= efx_ioctl,\n\t.ndo_change_mtu\t\t= efx_siena_change_mtu,\n\t.ndo_set_mac_address\t= efx_siena_set_mac_address,\n\t.ndo_set_rx_mode\t= efx_siena_set_rx_mode,\n\t.ndo_set_features\t= efx_siena_set_features,\n\t.ndo_features_check\t= efx_siena_features_check,\n\t.ndo_vlan_rx_add_vid\t= efx_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= efx_vlan_rx_kill_vid,\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\t.ndo_set_vf_mac\t\t= efx_sriov_set_vf_mac,\n\t.ndo_set_vf_vlan\t= efx_sriov_set_vf_vlan,\n\t.ndo_set_vf_spoofchk\t= efx_sriov_set_vf_spoofchk,\n\t.ndo_get_vf_config\t= efx_sriov_get_vf_config,\n\t.ndo_set_vf_link_state  = efx_sriov_set_vf_link_state,\n#endif\n\t.ndo_get_phys_port_id   = efx_siena_get_phys_port_id,\n\t.ndo_get_phys_port_name\t= efx_siena_get_phys_port_name,\n\t.ndo_setup_tc\t\t= efx_siena_setup_tc,\n#ifdef CONFIG_RFS_ACCEL\n\t.ndo_rx_flow_steer\t= efx_siena_filter_rfs,\n#endif\n\t.ndo_xdp_xmit\t\t= efx_xdp_xmit,\n\t.ndo_bpf\t\t= efx_xdp\n};\n\nstatic int efx_xdp_setup_prog(struct efx_nic *efx, struct bpf_prog *prog)\n{\n\tstruct bpf_prog *old_prog;\n\n\tif (efx->xdp_rxq_info_failed) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Unable to bind XDP program due to previous failure of rxq_info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (prog && efx->net_dev->mtu > efx_siena_xdp_max_mtu(efx)) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Unable to configure XDP with MTU of %d (max: %d)\\n\",\n\t\t\t  efx->net_dev->mtu, efx_siena_xdp_max_mtu(efx));\n\t\treturn -EINVAL;\n\t}\n\n\told_prog = rtnl_dereference(efx->xdp_prog);\n\trcu_assign_pointer(efx->xdp_prog, prog);\n\t \n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\treturn 0;\n}\n\n \nstatic int efx_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tstruct efx_nic *efx = netdev_priv(dev);\n\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn efx_xdp_setup_prog(efx, xdp->prog);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int efx_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **xdpfs,\n\t\t\tu32 flags)\n{\n\tstruct efx_nic *efx = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\treturn efx_siena_xdp_tx_buffers(efx, n, xdpfs, flags & XDP_XMIT_FLUSH);\n}\n\nstatic void efx_update_name(struct efx_nic *efx)\n{\n\tstrcpy(efx->name, efx->net_dev->name);\n\tefx_siena_mtd_rename(efx);\n\tefx_siena_set_channel_names(efx);\n}\n\nstatic int efx_netdev_event(struct notifier_block *this,\n\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *net_dev = netdev_notifier_info_to_dev(ptr);\n\n\tif ((net_dev->netdev_ops == &efx_netdev_ops) &&\n\t    event == NETDEV_CHANGENAME)\n\t\tefx_update_name(netdev_priv(net_dev));\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block efx_netdev_notifier = {\n\t.notifier_call = efx_netdev_event,\n};\n\nstatic ssize_t phy_type_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct efx_nic *efx = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", efx->phy_type);\n}\nstatic DEVICE_ATTR_RO(phy_type);\n\nstatic int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n\tnet_dev->irq = efx->pci_dev->irq;\n\tnet_dev->netdev_ops = &efx_netdev_ops;\n\tif (efx_nic_rev(efx) >= EFX_REV_HUNT_A0)\n\t\tnet_dev->priv_flags |= IFF_UNICAST_FLT;\n\tnet_dev->ethtool_ops = &efx_siena_ethtool_ops;\n\tnetif_set_tso_max_segs(net_dev, EFX_TSO_MAX_SEGS);\n\tnet_dev->min_mtu = EFX_MIN_MTU;\n\tnet_dev->max_mtu = EFX_MAX_MTU;\n\n\trtnl_lock();\n\n\t \n\tefx->state = STATE_READY;\n\tsmp_mb();  \n\tif (efx->reset_pending) {\n\t\tpci_err(efx->pci_dev, \"aborting probe due to scheduled reset\\n\");\n\t\trc = -EIO;\n\t\tgoto fail_locked;\n\t}\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\n\t \n\tnetif_carrier_off(net_dev);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tstruct efx_tx_queue *tx_queue;\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\tefx_siena_init_tx_queue_core_txq(tx_queue);\n\t}\n\n\tefx_associate(efx);\n\n\trtnl_unlock();\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"failed to init net dev attributes\\n\");\n\t\tgoto fail_registered;\n\t}\n\n\tefx_siena_init_mcdi_logging(efx);\n\n\treturn 0;\n\nfail_registered:\n\trtnl_lock();\n\tefx_dissociate(efx);\n\tunregister_netdevice(net_dev);\nfail_locked:\n\tefx->state = STATE_UNINIT;\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n}\n\nstatic void efx_unregister_netdev(struct efx_nic *efx)\n{\n\tif (!efx->net_dev)\n\t\treturn;\n\n\tBUG_ON(netdev_priv(efx->net_dev) != efx);\n\n\tif (efx_dev_registered(efx)) {\n\t\tstrscpy(efx->name, pci_name(efx->pci_dev), sizeof(efx->name));\n\t\tefx_siena_fini_mcdi_logging(efx);\n\t\tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\t\tunregister_netdev(efx->net_dev);\n\t}\n}\n\n \n\n \nstatic const struct pci_device_id efx_pci_table[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_SOLARFLARE, 0x0803),\t \n\t .driver_data = (unsigned long)&siena_a0_nic_type},\n\t{PCI_DEVICE(PCI_VENDOR_ID_SOLARFLARE, 0x0813),\t \n\t .driver_data = (unsigned long)&siena_a0_nic_type},\n\t{0}\t\t\t \n};\n\n \n\nvoid efx_siena_update_sw_stats(struct efx_nic *efx, u64 *stats)\n{\n\tu64 n_rx_nodesc_trunc = 0;\n\tstruct efx_channel *channel;\n\n\tefx_for_each_channel(channel, efx)\n\t\tn_rx_nodesc_trunc += channel->n_rx_nodesc_trunc;\n\tstats[GENERIC_STAT_rx_nodesc_trunc] = n_rx_nodesc_trunc;\n\tstats[GENERIC_STAT_rx_noskb_drops] = atomic_read(&efx->n_rx_noskb_drops);\n}\n\n \n\n \nstatic void efx_pci_remove_main(struct efx_nic *efx)\n{\n\t \n\tBUG_ON(efx->state == STATE_READY);\n\tefx_siena_flush_reset_workqueue(efx);\n\n\tefx_siena_disable_interrupts(efx);\n\tefx_siena_clear_interrupt_affinity(efx);\n\tefx_siena_fini_interrupt(efx);\n\tefx_fini_port(efx);\n\tefx->type->fini(efx);\n\tefx_siena_fini_napi(efx);\n\tefx_remove_all(efx);\n}\n\n \nstatic void efx_pci_remove(struct pci_dev *pci_dev)\n{\n\tstruct efx_nic *efx;\n\n\tefx = pci_get_drvdata(pci_dev);\n\tif (!efx)\n\t\treturn;\n\n\t \n\trtnl_lock();\n\tefx_dissociate(efx);\n\tdev_close(efx->net_dev);\n\tefx_siena_disable_interrupts(efx);\n\tefx->state = STATE_UNINIT;\n\trtnl_unlock();\n\n\tif (efx->type->sriov_fini)\n\t\tefx->type->sriov_fini(efx);\n\n\tefx_unregister_netdev(efx);\n\n\tefx_siena_mtd_remove(efx);\n\n\tefx_pci_remove_main(efx);\n\n\tefx_siena_fini_io(efx);\n\tnetif_dbg(efx, drv, efx->net_dev, \"shutdown successful\\n\");\n\n\tefx_siena_fini_struct(efx);\n\tfree_netdev(efx->net_dev);\n};\n\n \nstatic void efx_probe_vpd_strings(struct efx_nic *efx)\n{\n\tstruct pci_dev *dev = efx->pci_dev;\n\tunsigned int vpd_size, kw_len;\n\tu8 *vpd_data;\n\tint start;\n\n\tvpd_data = pci_vpd_alloc(dev, &vpd_size);\n\tif (IS_ERR(vpd_data)) {\n\t\tpci_warn(dev, \"Unable to read VPD\\n\");\n\t\treturn;\n\t}\n\n\tstart = pci_vpd_find_ro_info_keyword(vpd_data, vpd_size,\n\t\t\t\t\t     PCI_VPD_RO_KEYWORD_PARTNO, &kw_len);\n\tif (start < 0)\n\t\tpci_err(dev, \"Part number not found or incomplete\\n\");\n\telse\n\t\tpci_info(dev, \"Part Number : %.*s\\n\", kw_len, vpd_data + start);\n\n\tstart = pci_vpd_find_ro_info_keyword(vpd_data, vpd_size,\n\t\t\t\t\t     PCI_VPD_RO_KEYWORD_SERIALNO, &kw_len);\n\tif (start < 0)\n\t\tpci_err(dev, \"Serial number not found or incomplete\\n\");\n\telse\n\t\tefx->vpd_sn = kmemdup_nul(vpd_data + start, kw_len, GFP_KERNEL);\n\n\tkfree(vpd_data);\n}\n\n\n \nstatic int efx_pci_probe_main(struct efx_nic *efx)\n{\n\tint rc;\n\n\t \n\trc = efx_probe_all(efx);\n\tif (rc)\n\t\tgoto fail1;\n\n\tefx_siena_init_napi(efx);\n\n\tdown_write(&efx->filter_sem);\n\trc = efx->type->init(efx);\n\tup_write(&efx->filter_sem);\n\tif (rc) {\n\t\tpci_err(efx->pci_dev, \"failed to initialise NIC\\n\");\n\t\tgoto fail3;\n\t}\n\n\trc = efx_init_port(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"failed to initialise port\\n\");\n\t\tgoto fail4;\n\t}\n\n\trc = efx_siena_init_interrupt(efx);\n\tif (rc)\n\t\tgoto fail5;\n\n\tefx_siena_set_interrupt_affinity(efx);\n\trc = efx_siena_enable_interrupts(efx);\n\tif (rc)\n\t\tgoto fail6;\n\n\treturn 0;\n\n fail6:\n\tefx_siena_clear_interrupt_affinity(efx);\n\tefx_siena_fini_interrupt(efx);\n fail5:\n\tefx_fini_port(efx);\n fail4:\n\tefx->type->fini(efx);\n fail3:\n\tefx_siena_fini_napi(efx);\n\tefx_remove_all(efx);\n fail1:\n\treturn rc;\n}\n\nstatic int efx_pci_probe_post_io(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tint rc = efx_pci_probe_main(efx);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (efx->type->sriov_init) {\n\t\trc = efx->type->sriov_init(efx);\n\t\tif (rc)\n\t\t\tpci_err(efx->pci_dev, \"SR-IOV can't be enabled rc %d\\n\",\n\t\t\t\trc);\n\t}\n\n\t \n\tnet_dev->features |= (efx->type->offload_features | NETIF_F_SG |\n\t\t\t      NETIF_F_TSO | NETIF_F_RXCSUM | NETIF_F_RXALL);\n\tif (efx->type->offload_features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))\n\t\tnet_dev->features |= NETIF_F_TSO6;\n\t \n\tif (!efx->type->tso_versions || !efx->type->tso_versions(efx))\n\t\tnet_dev->features &= ~NETIF_F_ALL_TSO;\n\t \n\tnet_dev->vlan_features |= (NETIF_F_HW_CSUM | NETIF_F_SG |\n\t\t\t\t   NETIF_F_HIGHDMA | NETIF_F_ALL_TSO |\n\t\t\t\t   NETIF_F_RXCSUM);\n\n\tnet_dev->hw_features |= net_dev->features & ~efx->fixed_features;\n\n\t \n\tnet_dev->features &= ~NETIF_F_RXALL;\n\n\t \n\tnet_dev->features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\tnet_dev->features |= efx->fixed_features;\n\n\tnet_dev->xdp_features = NETDEV_XDP_ACT_BASIC |\n\t\t\t\tNETDEV_XDP_ACT_REDIRECT |\n\t\t\t\tNETDEV_XDP_ACT_NDO_XMIT;\n\n\trc = efx_register_netdev(efx);\n\tif (!rc)\n\t\treturn 0;\n\n\tefx_pci_remove_main(efx);\n\treturn rc;\n}\n\n \nstatic int efx_pci_probe(struct pci_dev *pci_dev,\n\t\t\t const struct pci_device_id *entry)\n{\n\tstruct net_device *net_dev;\n\tstruct efx_nic *efx;\n\tint rc;\n\n\t \n\tnet_dev = alloc_etherdev_mqs(sizeof(*efx), EFX_MAX_CORE_TX_QUEUES,\n\t\t\t\t     EFX_MAX_RX_QUEUES);\n\tif (!net_dev)\n\t\treturn -ENOMEM;\n\tefx = netdev_priv(net_dev);\n\tefx->type = (const struct efx_nic_type *) entry->driver_data;\n\tefx->fixed_features |= NETIF_F_HIGHDMA;\n\n\tpci_set_drvdata(pci_dev, efx);\n\tSET_NETDEV_DEV(net_dev, &pci_dev->dev);\n\trc = efx_siena_init_struct(efx, pci_dev, net_dev);\n\tif (rc)\n\t\tgoto fail1;\n\n\tpci_info(pci_dev, \"Solarflare NIC detected\\n\");\n\n\tif (!efx->type->is_vf)\n\t\tefx_probe_vpd_strings(efx);\n\n\t \n\trc = efx_siena_init_io(efx, efx->type->mem_bar(efx),\n\t\t\t       efx->type->max_dma_mask,\n\t\t\t       efx->type->mem_map_size(efx));\n\tif (rc)\n\t\tgoto fail2;\n\n\trc = efx_pci_probe_post_io(efx);\n\tif (rc) {\n\t\t \n\t\tefx->reset_pending = 0;\n\t\trc = efx_pci_probe_post_io(efx);\n\t\tif (rc) {\n\t\t\t \n\t\t\tunsigned char r;\n\n\t\t\tget_random_bytes(&r, 1);\n\t\t\tmsleep((unsigned int)r + 50);\n\t\t\tefx->reset_pending = 0;\n\t\t\trc = efx_pci_probe_post_io(efx);\n\t\t}\n\t}\n\tif (rc)\n\t\tgoto fail3;\n\n\tnetif_dbg(efx, probe, efx->net_dev, \"initialisation successful\\n\");\n\n\t \n\trtnl_lock();\n\trc = efx_mtd_probe(efx);\n\trtnl_unlock();\n\tif (rc && rc != -EPERM)\n\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t   \"failed to create MTDs (%d)\\n\", rc);\n\n\tif (efx->type->udp_tnl_push_ports)\n\t\tefx->type->udp_tnl_push_ports(efx);\n\n\treturn 0;\n\n fail3:\n\tefx_siena_fini_io(efx);\n fail2:\n\tefx_siena_fini_struct(efx);\n fail1:\n\tWARN_ON(rc > 0);\n\tnetif_dbg(efx, drv, efx->net_dev, \"initialisation failed. rc=%d\\n\", rc);\n\tfree_netdev(net_dev);\n\treturn rc;\n}\n\n \n#ifdef CONFIG_SFC_SIENA_SRIOV\nstatic int efx_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\n{\n\tint rc;\n\tstruct efx_nic *efx = pci_get_drvdata(dev);\n\n\tif (efx->type->sriov_configure) {\n\t\trc = efx->type->sriov_configure(efx, num_vfs);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\telse\n\t\t\treturn num_vfs;\n\t} else\n\t\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic int efx_pm_freeze(struct device *dev)\n{\n\tstruct efx_nic *efx = dev_get_drvdata(dev);\n\n\trtnl_lock();\n\n\tif (efx->state != STATE_DISABLED) {\n\t\tefx->state = STATE_UNINIT;\n\n\t\tefx_device_detach_sync(efx);\n\n\t\tefx_siena_stop_all(efx);\n\t\tefx_siena_disable_interrupts(efx);\n\t}\n\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic void efx_pci_shutdown(struct pci_dev *pci_dev)\n{\n\tstruct efx_nic *efx = pci_get_drvdata(pci_dev);\n\n\tif (!efx)\n\t\treturn;\n\n\tefx_pm_freeze(&pci_dev->dev);\n\tpci_disable_device(pci_dev);\n}\n\nstatic int efx_pm_thaw(struct device *dev)\n{\n\tint rc;\n\tstruct efx_nic *efx = dev_get_drvdata(dev);\n\n\trtnl_lock();\n\n\tif (efx->state != STATE_DISABLED) {\n\t\trc = efx_siena_enable_interrupts(efx);\n\t\tif (rc)\n\t\t\tgoto fail;\n\n\t\tmutex_lock(&efx->mac_lock);\n\t\tefx_siena_mcdi_port_reconfigure(efx);\n\t\tmutex_unlock(&efx->mac_lock);\n\n\t\tefx_siena_start_all(efx);\n\n\t\tefx_device_attach_if_not_resetting(efx);\n\n\t\tefx->state = STATE_READY;\n\n\t\tefx->type->resume_wol(efx);\n\t}\n\n\trtnl_unlock();\n\n\t \n\tefx_siena_queue_reset_work(efx);\n\n\treturn 0;\n\nfail:\n\trtnl_unlock();\n\n\treturn rc;\n}\n\nstatic int efx_pm_poweroff(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct efx_nic *efx = pci_get_drvdata(pci_dev);\n\n\tefx->type->fini(efx);\n\n\tefx->reset_pending = 0;\n\n\tpci_save_state(pci_dev);\n\treturn pci_set_power_state(pci_dev, PCI_D3hot);\n}\n\n \nstatic int efx_pm_resume(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct efx_nic *efx = pci_get_drvdata(pci_dev);\n\tint rc;\n\n\trc = pci_set_power_state(pci_dev, PCI_D0);\n\tif (rc)\n\t\treturn rc;\n\tpci_restore_state(pci_dev);\n\trc = pci_enable_device(pci_dev);\n\tif (rc)\n\t\treturn rc;\n\tpci_set_master(efx->pci_dev);\n\trc = efx->type->reset(efx, RESET_TYPE_ALL);\n\tif (rc)\n\t\treturn rc;\n\tdown_write(&efx->filter_sem);\n\trc = efx->type->init(efx);\n\tup_write(&efx->filter_sem);\n\tif (rc)\n\t\treturn rc;\n\trc = efx_pm_thaw(dev);\n\treturn rc;\n}\n\nstatic int efx_pm_suspend(struct device *dev)\n{\n\tint rc;\n\n\tefx_pm_freeze(dev);\n\trc = efx_pm_poweroff(dev);\n\tif (rc)\n\t\tefx_pm_resume(dev);\n\treturn rc;\n}\n\nstatic const struct dev_pm_ops efx_pm_ops = {\n\t.suspend\t= efx_pm_suspend,\n\t.resume\t\t= efx_pm_resume,\n\t.freeze\t\t= efx_pm_freeze,\n\t.thaw\t\t= efx_pm_thaw,\n\t.poweroff\t= efx_pm_poweroff,\n\t.restore\t= efx_pm_resume,\n};\n\nstatic struct pci_driver efx_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= efx_pci_table,\n\t.probe\t\t= efx_pci_probe,\n\t.remove\t\t= efx_pci_remove,\n\t.driver.pm\t= &efx_pm_ops,\n\t.shutdown\t= efx_pci_shutdown,\n\t.err_handler\t= &efx_siena_err_handlers,\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\t.sriov_configure = efx_pci_sriov_configure,\n#endif\n};\n\n \n\nstatic int __init efx_init_module(void)\n{\n\tint rc;\n\n\tpr_info(\"Solarflare Siena driver\\n\");\n\n\trc = register_netdevice_notifier(&efx_netdev_notifier);\n\tif (rc)\n\t\tgoto err_notifier;\n\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\trc = efx_init_sriov();\n\tif (rc)\n\t\tgoto err_sriov;\n#endif\n\n\trc = efx_siena_create_reset_workqueue();\n\tif (rc)\n\t\tgoto err_reset;\n\n\trc = pci_register_driver(&efx_pci_driver);\n\tif (rc < 0)\n\t\tgoto err_pci;\n\n\treturn 0;\n\n err_pci:\n\tefx_siena_destroy_reset_workqueue();\n err_reset:\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\tefx_fini_sriov();\n err_sriov:\n#endif\n\tunregister_netdevice_notifier(&efx_netdev_notifier);\n err_notifier:\n\treturn rc;\n}\n\nstatic void __exit efx_exit_module(void)\n{\n\tpr_info(\"Solarflare Siena driver unloading\\n\");\n\n\tpci_unregister_driver(&efx_pci_driver);\n\tefx_siena_destroy_reset_workqueue();\n#ifdef CONFIG_SFC_SIENA_SRIOV\n\tefx_fini_sriov();\n#endif\n\tunregister_netdevice_notifier(&efx_netdev_notifier);\n\n}\n\nmodule_init(efx_init_module);\nmodule_exit(efx_exit_module);\n\nMODULE_AUTHOR(\"Solarflare Communications and \"\n\t      \"Michael Brown <mbrown@fensystems.co.uk>\");\nMODULE_DESCRIPTION(\"Solarflare Siena network driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, efx_pci_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}