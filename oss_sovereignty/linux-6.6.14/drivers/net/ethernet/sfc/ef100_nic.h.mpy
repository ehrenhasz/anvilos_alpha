{
  "module_name": "ef100_nic.h",
  "hash_id": "9b94bdf72cf6451d455bfc808400c2ec664ec1b04774ed92c6cb5965028b5feb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef100_nic.h",
  "human_readable_source": " \n \n#ifndef EFX_EF100_NIC_H\n#define EFX_EF100_NIC_H\n\n#include \"net_driver.h\"\n#include \"nic_common.h\"\n\nextern const struct efx_nic_type ef100_pf_nic_type;\nextern const struct efx_nic_type ef100_vf_nic_type;\n\nint ef100_probe_netdev_pf(struct efx_nic *efx);\nint ef100_probe_vf(struct efx_nic *efx);\nvoid ef100_remove(struct efx_nic *efx);\n\nenum {\n\tEF100_STAT_port_tx_bytes = GENERIC_STAT_COUNT,\n\tEF100_STAT_port_tx_packets,\n\tEF100_STAT_port_tx_pause,\n\tEF100_STAT_port_tx_unicast,\n\tEF100_STAT_port_tx_multicast,\n\tEF100_STAT_port_tx_broadcast,\n\tEF100_STAT_port_tx_lt64,\n\tEF100_STAT_port_tx_64,\n\tEF100_STAT_port_tx_65_to_127,\n\tEF100_STAT_port_tx_128_to_255,\n\tEF100_STAT_port_tx_256_to_511,\n\tEF100_STAT_port_tx_512_to_1023,\n\tEF100_STAT_port_tx_1024_to_15xx,\n\tEF100_STAT_port_tx_15xx_to_jumbo,\n\tEF100_STAT_port_rx_bytes,\n\tEF100_STAT_port_rx_packets,\n\tEF100_STAT_port_rx_good,\n\tEF100_STAT_port_rx_bad,\n\tEF100_STAT_port_rx_pause,\n\tEF100_STAT_port_rx_unicast,\n\tEF100_STAT_port_rx_multicast,\n\tEF100_STAT_port_rx_broadcast,\n\tEF100_STAT_port_rx_lt64,\n\tEF100_STAT_port_rx_64,\n\tEF100_STAT_port_rx_65_to_127,\n\tEF100_STAT_port_rx_128_to_255,\n\tEF100_STAT_port_rx_256_to_511,\n\tEF100_STAT_port_rx_512_to_1023,\n\tEF100_STAT_port_rx_1024_to_15xx,\n\tEF100_STAT_port_rx_15xx_to_jumbo,\n\tEF100_STAT_port_rx_gtjumbo,\n\tEF100_STAT_port_rx_bad_gtjumbo,\n\tEF100_STAT_port_rx_align_error,\n\tEF100_STAT_port_rx_length_error,\n\tEF100_STAT_port_rx_overflow,\n\tEF100_STAT_port_rx_nodesc_drops,\n\tEF100_STAT_COUNT\n};\n\nstruct ef100_nic_data {\n\tstruct efx_nic *efx;\n\tstruct efx_buffer mcdi_buf;\n\tu32 datapath_caps;\n\tu32 datapath_caps2;\n\tu32 datapath_caps3;\n\tunsigned int pf_index;\n\tu16 warm_boot_count;\n\tu8 port_id[ETH_ALEN];\n\tDECLARE_BITMAP(evq_phases, EFX_MAX_CHANNELS);\n\tu64 stats[EF100_STAT_COUNT];\n\tu32 base_mport;\n\tbool have_mport;  \n\tu32 own_mport;\n\tu32 local_mae_intf;  \n\tbool have_own_mport;  \n\tbool have_local_intf;  \n\tbool grp_mae;  \n\tu16 tso_max_hdr_len;\n\tu16 tso_max_payload_num_segs;\n\tu16 tso_max_frames;\n\tunsigned int tso_max_payload_len;\n};\n\n#define efx_ef100_has_cap(caps, flag) \\\n\t(!!((caps) & BIT_ULL(MC_CMD_GET_CAPABILITIES_V4_OUT_ ## flag ## _LBN)))\n\nint efx_ef100_init_datapath_caps(struct efx_nic *efx);\nint ef100_phy_probe(struct efx_nic *efx);\nint ef100_filter_table_probe(struct efx_nic *efx);\n\nint ef100_get_mac_address(struct efx_nic *efx, u8 *mac_address,\n\t\t\t  int client_handle, bool empty_ok);\nint efx_ef100_lookup_client_id(struct efx_nic *efx, efx_qword_t pciefn, u32 *id);\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}