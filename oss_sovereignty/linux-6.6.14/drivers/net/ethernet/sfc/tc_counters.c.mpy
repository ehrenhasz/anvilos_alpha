{
  "module_name": "tc_counters.c",
  "hash_id": "406165b5a8b027c2935271673be470a53150d7be4414447e7c05ffecef24a6b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/tc_counters.c",
  "human_readable_source": "\n \n\n#include \"tc_counters.h\"\n#include \"tc_encap_actions.h\"\n#include \"mae_counter_format.h\"\n#include \"mae.h\"\n#include \"rx_common.h\"\n\n \n\nstatic const struct rhashtable_params efx_tc_counter_id_ht_params = {\n\t.key_len\t= offsetof(struct efx_tc_counter_index, linkage),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_counter_index, linkage),\n};\n\nstatic const struct rhashtable_params efx_tc_counter_ht_params = {\n\t.key_len\t= offsetof(struct efx_tc_counter, linkage),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_counter, linkage),\n};\n\nstatic void efx_tc_counter_free(void *ptr, void *__unused)\n{\n\tstruct efx_tc_counter *cnt = ptr;\n\n\tWARN_ON(!list_empty(&cnt->users));\n\t \n\tflush_work(&cnt->work);\n\tEFX_WARN_ON_PARANOID(spin_is_locked(&cnt->lock));\n\tkfree(cnt);\n}\n\nstatic void efx_tc_counter_id_free(void *ptr, void *__unused)\n{\n\tstruct efx_tc_counter_index *ctr = ptr;\n\n\tWARN_ON(refcount_read(&ctr->ref));\n\tkfree(ctr);\n}\n\nint efx_tc_init_counters(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = rhashtable_init(&efx->tc->counter_id_ht, &efx_tc_counter_id_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_counter_id_ht;\n\trc = rhashtable_init(&efx->tc->counter_ht, &efx_tc_counter_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_counter_ht;\n\treturn 0;\nfail_counter_ht:\n\trhashtable_destroy(&efx->tc->counter_id_ht);\nfail_counter_id_ht:\n\treturn rc;\n}\n\n \nvoid efx_tc_destroy_counters(struct efx_nic *efx)\n{\n\trhashtable_destroy(&efx->tc->counter_ht);\n\trhashtable_destroy(&efx->tc->counter_id_ht);\n}\n\nvoid efx_tc_fini_counters(struct efx_nic *efx)\n{\n\trhashtable_free_and_destroy(&efx->tc->counter_id_ht, efx_tc_counter_id_free, NULL);\n\trhashtable_free_and_destroy(&efx->tc->counter_ht, efx_tc_counter_free, NULL);\n}\n\nstatic void efx_tc_counter_work(struct work_struct *work)\n{\n\tstruct efx_tc_counter *cnt = container_of(work, struct efx_tc_counter, work);\n\tstruct efx_tc_encap_action *encap;\n\tstruct efx_tc_action_set *act;\n\tunsigned long touched;\n\tstruct neighbour *n;\n\n\tspin_lock_bh(&cnt->lock);\n\ttouched = READ_ONCE(cnt->touched);\n\n\tlist_for_each_entry(act, &cnt->users, count_user) {\n\t\tencap = act->encap_md;\n\t\tif (!encap)\n\t\t\tcontinue;\n\t\tif (!encap->neigh)  \n\t\t\tcontinue;\n\t\tif (time_after_eq(encap->neigh->used, touched))\n\t\t\tcontinue;\n\t\tencap->neigh->used = touched;\n\t\t \n\t\tif (encap->neigh->dst_ip)\n\t\t\tn = neigh_lookup(&arp_tbl, &encap->neigh->dst_ip,\n\t\t\t\t\t encap->neigh->egdev);\n\t\telse\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tn = neigh_lookup(ipv6_stub->nd_tbl,\n\t\t\t\t\t &encap->neigh->dst_ip6,\n\t\t\t\t\t encap->neigh->egdev);\n#else\n\t\t\tn = NULL;\n#endif\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tneigh_event_send(n, NULL);\n\t\tneigh_release(n);\n\t}\n\tspin_unlock_bh(&cnt->lock);\n}\n\n \n\nstruct efx_tc_counter *efx_tc_flower_allocate_counter(struct efx_nic *efx,\n\t\t\t\t\t\t      int type)\n{\n\tstruct efx_tc_counter *cnt;\n\tint rc, rc2;\n\n\tcnt = kzalloc(sizeof(*cnt), GFP_USER);\n\tif (!cnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&cnt->lock);\n\tINIT_WORK(&cnt->work, efx_tc_counter_work);\n\tcnt->touched = jiffies;\n\tcnt->type = type;\n\n\trc = efx_mae_allocate_counter(efx, cnt);\n\tif (rc)\n\t\tgoto fail1;\n\tINIT_LIST_HEAD(&cnt->users);\n\trc = rhashtable_insert_fast(&efx->tc->counter_ht, &cnt->linkage,\n\t\t\t\t    efx_tc_counter_ht_params);\n\tif (rc)\n\t\tgoto fail2;\n\treturn cnt;\nfail2:\n\t \n\trc2 = efx_mae_free_counter(efx, cnt);\n\tif (rc2)\n\t\tnetif_warn(efx, hw, efx->net_dev,\n\t\t\t   \"Failed to free MAE counter %u, rc %d\\n\",\n\t\t\t   cnt->fw_id, rc2);\nfail1:\n\tkfree(cnt);\n\treturn ERR_PTR(rc > 0 ? -EIO : rc);\n}\n\nvoid efx_tc_flower_release_counter(struct efx_nic *efx,\n\t\t\t\t   struct efx_tc_counter *cnt)\n{\n\tint rc;\n\n\trhashtable_remove_fast(&efx->tc->counter_ht, &cnt->linkage,\n\t\t\t       efx_tc_counter_ht_params);\n\trc = efx_mae_free_counter(efx, cnt);\n\tif (rc)\n\t\tnetif_warn(efx, hw, efx->net_dev,\n\t\t\t   \"Failed to free MAE counter %u, rc %d\\n\",\n\t\t\t   cnt->fw_id, rc);\n\tWARN_ON(!list_empty(&cnt->users));\n\t \n\tsynchronize_rcu();\n\tflush_work(&cnt->work);\n\tEFX_WARN_ON_PARANOID(spin_is_locked(&cnt->lock));\n\tkfree(cnt);\n}\n\nstatic struct efx_tc_counter *efx_tc_flower_find_counter_by_fw_id(\n\t\t\t\tstruct efx_nic *efx, int type, u32 fw_id)\n{\n\tstruct efx_tc_counter key = {};\n\n\tkey.fw_id = fw_id;\n\tkey.type = type;\n\n\treturn rhashtable_lookup_fast(&efx->tc->counter_ht, &key,\n\t\t\t\t      efx_tc_counter_ht_params);\n}\n\n \n\nvoid efx_tc_flower_put_counter_index(struct efx_nic *efx,\n\t\t\t\t     struct efx_tc_counter_index *ctr)\n{\n\tif (!refcount_dec_and_test(&ctr->ref))\n\t\treturn;  \n\trhashtable_remove_fast(&efx->tc->counter_id_ht, &ctr->linkage,\n\t\t\t       efx_tc_counter_id_ht_params);\n\tefx_tc_flower_release_counter(efx, ctr->cnt);\n\tkfree(ctr);\n}\n\nstruct efx_tc_counter_index *efx_tc_flower_get_counter_index(\n\t\t\t\tstruct efx_nic *efx, unsigned long cookie,\n\t\t\t\tenum efx_tc_counter_type type)\n{\n\tstruct efx_tc_counter_index *ctr, *old;\n\tstruct efx_tc_counter *cnt;\n\n\tctr = kzalloc(sizeof(*ctr), GFP_USER);\n\tif (!ctr)\n\t\treturn ERR_PTR(-ENOMEM);\n\tctr->cookie = cookie;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->counter_id_ht,\n\t\t\t\t\t\t&ctr->linkage,\n\t\t\t\t\t\tefx_tc_counter_id_ht_params);\n\tif (old) {\n\t\t \n\t\tkfree(ctr);\n\t\tif (IS_ERR(old))  \n\t\t\treturn ERR_CAST(old);\n\t\tif (!refcount_inc_not_zero(&old->ref))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t \n\t\tctr = old;\n\t} else {\n\t\tcnt = efx_tc_flower_allocate_counter(efx, type);\n\t\tif (IS_ERR(cnt)) {\n\t\t\trhashtable_remove_fast(&efx->tc->counter_id_ht,\n\t\t\t\t\t       &ctr->linkage,\n\t\t\t\t\t       efx_tc_counter_id_ht_params);\n\t\t\tkfree(ctr);\n\t\t\treturn (void *)cnt;  \n\t\t}\n\t\tctr->cnt = cnt;\n\t\trefcount_set(&ctr->ref, 1);\n\t}\n\treturn ctr;\n}\n\nstruct efx_tc_counter_index *efx_tc_flower_find_counter_index(\n\t\t\t\tstruct efx_nic *efx, unsigned long cookie)\n{\n\tstruct efx_tc_counter_index key = {};\n\n\tkey.cookie = cookie;\n\treturn rhashtable_lookup_fast(&efx->tc->counter_id_ht, &key,\n\t\t\t\t      efx_tc_counter_id_ht_params);\n}\n\n \n\nstatic void efx_tc_handle_no_channel(struct efx_nic *efx)\n{\n\tnetif_warn(efx, drv, efx->net_dev,\n\t\t   \"MAE counters require MSI-X and 1 additional interrupt vector.\\n\");\n}\n\nstatic int efx_tc_probe_channel(struct efx_channel *channel)\n{\n\tstruct efx_rx_queue *rx_queue = &channel->rx_queue;\n\n\tchannel->irq_moderation_us = 0;\n\trx_queue->core_index = 0;\n\n\tINIT_WORK(&rx_queue->grant_work, efx_mae_counters_grant_credits);\n\n\treturn 0;\n}\n\nstatic int efx_tc_start_channel(struct efx_channel *channel)\n{\n\tstruct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);\n\tstruct efx_nic *efx = channel->efx;\n\n\treturn efx_mae_start_counters(efx, rx_queue);\n}\n\nstatic void efx_tc_stop_channel(struct efx_channel *channel)\n{\n\tstruct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);\n\tstruct efx_nic *efx = channel->efx;\n\tint rc;\n\n\trc = efx_mae_stop_counters(efx, rx_queue);\n\tif (rc)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"Failed to stop MAE counters streaming, rc=%d.\\n\",\n\t\t\t   rc);\n\trx_queue->grant_credits = false;\n\tflush_work(&rx_queue->grant_work);\n}\n\nstatic void efx_tc_remove_channel(struct efx_channel *channel)\n{\n}\n\nstatic void efx_tc_get_channel_name(struct efx_channel *channel,\n\t\t\t\t    char *buf, size_t len)\n{\n\tsnprintf(buf, len, \"%s-mae\", channel->efx->name);\n}\n\nstatic void efx_tc_counter_update(struct efx_nic *efx,\n\t\t\t\t  enum efx_tc_counter_type counter_type,\n\t\t\t\t  u32 counter_idx, u64 packets, u64 bytes,\n\t\t\t\t  u32 mark)\n{\n\tstruct efx_tc_counter *cnt;\n\n\trcu_read_lock();  \n\tcnt = efx_tc_flower_find_counter_by_fw_id(efx, counter_type, counter_idx);\n\tif (!cnt) {\n\t\t \n\t\tif (net_ratelimit())\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Got update for unwanted MAE counter %u type %u\\n\",\n\t\t\t\t  counter_idx, counter_type);\n\t\tgoto out;\n\t}\n\n\tspin_lock_bh(&cnt->lock);\n\tif ((s32)mark - (s32)cnt->gen < 0) {\n\t\t \n\t} else {\n\t\t \n\t\tcnt->gen = mark;\n\t\t \n\t\tcnt->packets += packets;\n\t\tcnt->bytes += bytes;\n\t\tcnt->touched = jiffies;\n\t}\n\tspin_unlock_bh(&cnt->lock);\n\tschedule_work(&cnt->work);\nout:\n\trcu_read_unlock();\n}\n\nstatic void efx_tc_rx_version_1(struct efx_nic *efx, const u8 *data, u32 mark)\n{\n\tu16 n_counters, i;\n\n\t \n\n\tn_counters = le16_to_cpu(*(const __le16 *)(data + 6));\n\n\t \n\tfor (i = 0; i < n_counters; i++) {\n\t\tconst void *entry = data + 8 + 16 * i;\n\t\tu64 packet_count, byte_count;\n\t\tu32 counter_idx;\n\n\t\tcounter_idx = le32_to_cpu(*(const __le32 *)entry);\n\t\tpacket_count = le32_to_cpu(*(const __le32 *)(entry + 4)) |\n\t\t\t       ((u64)le16_to_cpu(*(const __le16 *)(entry + 8)) << 32);\n\t\tbyte_count = le16_to_cpu(*(const __le16 *)(entry + 10)) |\n\t\t\t     ((u64)le32_to_cpu(*(const __le32 *)(entry + 12)) << 16);\n\t\tefx_tc_counter_update(efx, EFX_TC_COUNTER_TYPE_AR, counter_idx,\n\t\t\t\t      packet_count, byte_count, mark);\n\t}\n}\n\n#define TCV2_HDR_PTR(pkt, field)\t\t\t\t\t\t\\\n\t((void)BUILD_BUG_ON_ZERO(ERF_SC_PACKETISER_HEADER_##field##_LBN & 7),\t\\\n\t (pkt) + ERF_SC_PACKETISER_HEADER_##field##_LBN / 8)\n#define TCV2_HDR_BYTE(pkt, field)\t\t\t\t\t\t\\\n\t((void)BUILD_BUG_ON_ZERO(ERF_SC_PACKETISER_HEADER_##field##_WIDTH != 8),\\\n\t *TCV2_HDR_PTR(pkt, field))\n#define TCV2_HDR_WORD(pkt, field)\t\t\t\t\t\t\\\n\t((void)BUILD_BUG_ON_ZERO(ERF_SC_PACKETISER_HEADER_##field##_WIDTH != 16),\\\n\t (void)BUILD_BUG_ON_ZERO(ERF_SC_PACKETISER_HEADER_##field##_LBN & 15),\t\\\n\t *(__force const __le16 *)TCV2_HDR_PTR(pkt, field))\n#define TCV2_PKT_PTR(pkt, poff, i, field)\t\t\t\t\t\\\n\t((void)BUILD_BUG_ON_ZERO(ERF_SC_PACKETISER_PAYLOAD_##field##_LBN & 7),\t\\\n\t (pkt) + ERF_SC_PACKETISER_PAYLOAD_##field##_LBN/8 + poff +\t\t\\\n\t i * ER_RX_SL_PACKETISER_PAYLOAD_WORD_SIZE)\n\n \nstatic u64 efx_tc_read48(const __le16 *field)\n{\n\tu64 out = 0;\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tout |= (u64)le16_to_cpu(field[i]) << (i * 16);\n\treturn out;\n}\n\nstatic enum efx_tc_counter_type efx_tc_rx_version_2(struct efx_nic *efx,\n\t\t\t\t\t\t    const u8 *data, u32 mark)\n{\n\tu8 payload_offset, header_offset, ident;\n\tenum efx_tc_counter_type type;\n\tu16 n_counters, i;\n\n\tident = TCV2_HDR_BYTE(data, IDENTIFIER);\n\tswitch (ident) {\n\tcase ERF_SC_PACKETISER_HEADER_IDENTIFIER_AR:\n\t\ttype = EFX_TC_COUNTER_TYPE_AR;\n\t\tbreak;\n\tcase ERF_SC_PACKETISER_HEADER_IDENTIFIER_CT:\n\t\ttype = EFX_TC_COUNTER_TYPE_CT;\n\t\tbreak;\n\tcase ERF_SC_PACKETISER_HEADER_IDENTIFIER_OR:\n\t\ttype = EFX_TC_COUNTER_TYPE_OR;\n\t\tbreak;\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"ignored v2 MAE counter packet (bad identifier %u\"\n\t\t\t\t  \"), counters may be inaccurate\\n\", ident);\n\t\treturn EFX_TC_COUNTER_TYPE_MAX;\n\t}\n\theader_offset = TCV2_HDR_BYTE(data, HEADER_OFFSET);\n\t \n\tif (header_offset != ERF_SC_PACKETISER_HEADER_HEADER_OFFSET_DEFAULT) {\n\t\tif (net_ratelimit())\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"choked on v2 MAE counter packet (bad header_offset %u\"\n\t\t\t\t  \"), counters may be inaccurate\\n\", header_offset);\n\t\treturn EFX_TC_COUNTER_TYPE_MAX;\n\t}\n\tpayload_offset = TCV2_HDR_BYTE(data, PAYLOAD_OFFSET);\n\tn_counters = le16_to_cpu(TCV2_HDR_WORD(data, COUNT));\n\n\tfor (i = 0; i < n_counters; i++) {\n\t\tconst void *counter_idx_p, *packet_count_p, *byte_count_p;\n\t\tu64 packet_count, byte_count;\n\t\tu32 counter_idx;\n\n\t\t \n\t\tcounter_idx_p = TCV2_PKT_PTR(data, payload_offset, i, COUNTER_INDEX);\n\t\tBUILD_BUG_ON(ERF_SC_PACKETISER_PAYLOAD_COUNTER_INDEX_WIDTH != 24);\n\t\tBUILD_BUG_ON(ERF_SC_PACKETISER_PAYLOAD_COUNTER_INDEX_LBN & 31);\n\t\tcounter_idx = le32_to_cpu(*(const __le32 *)counter_idx_p) & 0xffffff;\n\t\t \n\t\tpacket_count_p = TCV2_PKT_PTR(data, payload_offset, i, PACKET_COUNT);\n\t\tBUILD_BUG_ON(ERF_SC_PACKETISER_PAYLOAD_PACKET_COUNT_WIDTH != 48);\n\t\tBUILD_BUG_ON(ERF_SC_PACKETISER_PAYLOAD_PACKET_COUNT_LBN & 15);\n\t\tpacket_count = efx_tc_read48((const __le16 *)packet_count_p);\n\t\t \n\t\tbyte_count_p = TCV2_PKT_PTR(data, payload_offset, i, BYTE_COUNT);\n\t\tBUILD_BUG_ON(ERF_SC_PACKETISER_PAYLOAD_BYTE_COUNT_WIDTH != 48);\n\t\tBUILD_BUG_ON(ERF_SC_PACKETISER_PAYLOAD_BYTE_COUNT_LBN & 15);\n\t\tbyte_count = efx_tc_read48((const __le16 *)byte_count_p);\n\n\t\tif (type == EFX_TC_COUNTER_TYPE_CT) {\n\t\t\t \n\t\t\tif (packet_count || byte_count != 1)\n\t\t\t\tnetdev_warn_once(efx->net_dev,\n\t\t\t\t\t\t \"CT counter with inconsistent state (%llu, %llu)\\n\",\n\t\t\t\t\t\t packet_count, byte_count);\n\t\t\t \n\t\t\tbyte_count = 0;\n\t\t}\n\n\t\tefx_tc_counter_update(efx, type, counter_idx, packet_count,\n\t\t\t\t      byte_count, mark);\n\t}\n\treturn type;\n}\n\n \nstatic bool efx_tc_rx(struct efx_rx_queue *rx_queue, u32 mark)\n{\n\tstruct efx_channel *channel = efx_rx_queue_channel(rx_queue);\n\tstruct efx_rx_buffer *rx_buf = efx_rx_buffer(rx_queue,\n\t\t\t\t\t\t     channel->rx_pkt_index);\n\tconst u8 *data = efx_rx_buf_va(rx_buf);\n\tstruct efx_nic *efx = rx_queue->efx;\n\tenum efx_tc_counter_type type;\n\tu8 version;\n\n\t \n\tversion = *data;\n\tswitch (version) {\n\tcase 1:\n\t\ttype = EFX_TC_COUNTER_TYPE_AR;\n\t\tefx_tc_rx_version_1(efx, data, mark);\n\t\tbreak;\n\tcase ERF_SC_PACKETISER_HEADER_VERSION_VALUE: \n\t\ttype = efx_tc_rx_version_2(efx, data, mark);\n\t\tbreak;\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"choked on MAE counter packet (bad version %u\"\n\t\t\t\t  \"); counters may be inaccurate\\n\",\n\t\t\t\t  version);\n\t\tgoto out;\n\t}\n\n\tif (type < EFX_TC_COUNTER_TYPE_MAX) {\n\t\t \n\t\tefx->tc->seen_gen[type] = mark;\n\t\tif (efx->tc->flush_counters &&\n\t\t    (s32)(efx->tc->flush_gen[type] - mark) <= 0)\n\t\t\twake_up(&efx->tc->flush_wq);\n\t}\nout:\n\tefx_free_rx_buffers(rx_queue, rx_buf, 1);\n\tchannel->rx_pkt_n_frags = 0;\n\treturn true;\n}\n\nconst struct efx_channel_type efx_tc_channel_type = {\n\t.handle_no_channel\t= efx_tc_handle_no_channel,\n\t.pre_probe\t\t= efx_tc_probe_channel,\n\t.start\t\t\t= efx_tc_start_channel,\n\t.stop\t\t\t= efx_tc_stop_channel,\n\t.post_remove\t\t= efx_tc_remove_channel,\n\t.get_name\t\t= efx_tc_get_channel_name,\n\t.receive_raw\t\t= efx_tc_rx,\n\t.keep_eventq\t\t= true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}