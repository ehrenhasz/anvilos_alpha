{
  "module_name": "tc_conntrack.c",
  "hash_id": "71a651ec27e6c9ef8320f354603b941947d6b68af046460f9483a4dca0267651",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/tc_conntrack.c",
  "human_readable_source": "\n \n\n#include \"tc_conntrack.h\"\n#include \"tc.h\"\n#include \"mae.h\"\n\nstatic int efx_tc_flow_block(enum tc_setup_type type, void *type_data,\n\t\t\t     void *cb_priv);\n\nstatic const struct rhashtable_params efx_tc_ct_zone_ht_params = {\n\t.key_len\t= offsetof(struct efx_tc_ct_zone, linkage),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_ct_zone, linkage),\n};\n\nstatic const struct rhashtable_params efx_tc_ct_ht_params = {\n\t.key_len\t= offsetof(struct efx_tc_ct_entry, linkage),\n\t.key_offset\t= 0,\n\t.head_offset\t= offsetof(struct efx_tc_ct_entry, linkage),\n};\n\nstatic void efx_tc_ct_zone_free(void *ptr, void *arg)\n{\n\tstruct efx_tc_ct_zone *zone = ptr;\n\tstruct efx_nic *efx = zone->efx;\n\n\tnetif_err(efx, drv, efx->net_dev,\n\t\t  \"tc ct_zone %u still present at teardown, removing\\n\",\n\t\t  zone->zone);\n\n\tnf_flow_table_offload_del_cb(zone->nf_ft, efx_tc_flow_block, zone);\n\tkfree(zone);\n}\n\nstatic void efx_tc_ct_free(void *ptr, void *arg)\n{\n\tstruct efx_tc_ct_entry *conn = ptr;\n\tstruct efx_nic *efx = arg;\n\n\tnetif_err(efx, drv, efx->net_dev,\n\t\t  \"tc ct_entry %lx still present at teardown\\n\",\n\t\t  conn->cookie);\n\n\t \n\tefx_tc_flower_release_counter(efx, conn->cnt);\n\tkfree(conn);\n}\n\nint efx_tc_init_conntrack(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = rhashtable_init(&efx->tc->ct_zone_ht, &efx_tc_ct_zone_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_ct_zone_ht;\n\trc = rhashtable_init(&efx->tc->ct_ht, &efx_tc_ct_ht_params);\n\tif (rc < 0)\n\t\tgoto fail_ct_ht;\n\treturn 0;\nfail_ct_ht:\n\trhashtable_destroy(&efx->tc->ct_zone_ht);\nfail_ct_zone_ht:\n\treturn rc;\n}\n\n \nvoid efx_tc_destroy_conntrack(struct efx_nic *efx)\n{\n\trhashtable_destroy(&efx->tc->ct_ht);\n\trhashtable_destroy(&efx->tc->ct_zone_ht);\n}\n\nvoid efx_tc_fini_conntrack(struct efx_nic *efx)\n{\n\trhashtable_free_and_destroy(&efx->tc->ct_zone_ht, efx_tc_ct_zone_free, NULL);\n\trhashtable_free_and_destroy(&efx->tc->ct_ht, efx_tc_ct_free, efx);\n}\n\n#define EFX_NF_TCP_FLAG(flg)\tcpu_to_be16(be32_to_cpu(TCP_FLAG_##flg) >> 16)\n\nstatic int efx_tc_ct_parse_match(struct efx_nic *efx, struct flow_rule *fr,\n\t\t\t\t struct efx_tc_ct_entry *conn)\n{\n\tstruct flow_dissector *dissector = fr->match.dissector;\n\tunsigned char ipv = 0;\n\tbool tcp = false;\n\n\tif (flow_rule_match_key(fr, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control fm;\n\n\t\tflow_rule_match_control(fr, &fm);\n\t\tif (IS_ALL_ONES(fm.mask->addr_type))\n\t\t\tswitch (fm.key->addr_type) {\n\t\t\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\t\t\tipv = 4;\n\t\t\t\tbreak;\n\t\t\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\t\t\tipv = 6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tif (!ipv) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Conntrack missing ipv specification\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_TCP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_META))) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Unsupported conntrack keys %#llx\\n\",\n\t\t\t  dissector->used_keys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(fr, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic fm;\n\n\t\tflow_rule_match_basic(fr, &fm);\n\t\tif (!IS_ALL_ONES(fm.mask->n_proto)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack eth_proto is not exact-match; mask %04x\\n\",\n\t\t\t\t   ntohs(fm.mask->n_proto));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->eth_proto = fm.key->n_proto;\n\t\tif (conn->eth_proto != (ipv == 4 ? htons(ETH_P_IP)\n\t\t\t\t\t\t : htons(ETH_P_IPV6))) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack eth_proto is not IPv%u, is %04x\\n\",\n\t\t\t\t   ipv, ntohs(conn->eth_proto));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!IS_ALL_ONES(fm.mask->ip_proto)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ip_proto is not exact-match; mask %02x\\n\",\n\t\t\t\t   fm.mask->ip_proto);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->ip_proto = fm.key->ip_proto;\n\t\tswitch (conn->ip_proto) {\n\t\tcase IPPROTO_TCP:\n\t\t\ttcp = true;\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ip_proto not TCP or UDP, is %02x\\n\",\n\t\t\t\t   conn->ip_proto);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Conntrack missing eth_proto, ip_proto\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ipv == 4 && flow_rule_match_key(fr, FLOW_DISSECTOR_KEY_IPV4_ADDRS)) {\n\t\tstruct flow_match_ipv4_addrs fm;\n\n\t\tflow_rule_match_ipv4_addrs(fr, &fm);\n\t\tif (!IS_ALL_ONES(fm.mask->src)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ipv4.src is not exact-match; mask %08x\\n\",\n\t\t\t\t   ntohl(fm.mask->src));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->src_ip = fm.key->src;\n\t\tif (!IS_ALL_ONES(fm.mask->dst)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ipv4.dst is not exact-match; mask %08x\\n\",\n\t\t\t\t   ntohl(fm.mask->dst));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->dst_ip = fm.key->dst;\n\t} else if (ipv == 6 && flow_rule_match_key(fr, FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\tstruct flow_match_ipv6_addrs fm;\n\n\t\tflow_rule_match_ipv6_addrs(fr, &fm);\n\t\tif (!efx_ipv6_addr_all_ones(&fm.mask->src)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ipv6.src is not exact-match; mask %pI6\\n\",\n\t\t\t\t   &fm.mask->src);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->src_ip6 = fm.key->src;\n\t\tif (!efx_ipv6_addr_all_ones(&fm.mask->dst)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ipv6.dst is not exact-match; mask %pI6\\n\",\n\t\t\t\t   &fm.mask->dst);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->dst_ip6 = fm.key->dst;\n\t} else {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Conntrack missing IPv%u addrs\\n\", ipv);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(fr, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports fm;\n\n\t\tflow_rule_match_ports(fr, &fm);\n\t\tif (!IS_ALL_ONES(fm.mask->src)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ports.src is not exact-match; mask %04x\\n\",\n\t\t\t\t   ntohs(fm.mask->src));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->l4_sport = fm.key->src;\n\t\tif (!IS_ALL_ONES(fm.mask->dst)) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack ports.dst is not exact-match; mask %04x\\n\",\n\t\t\t\t   ntohs(fm.mask->dst));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconn->l4_dport = fm.key->dst;\n\t} else {\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"Conntrack missing L4 ports\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(fr, FLOW_DISSECTOR_KEY_TCP)) {\n\t\t__be16 tcp_interesting_flags;\n\t\tstruct flow_match_tcp fm;\n\n\t\tif (!tcp) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Conntrack matching on TCP keys but ipproto is not tcp\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tflow_rule_match_tcp(fr, &fm);\n\t\ttcp_interesting_flags = EFX_NF_TCP_FLAG(SYN) |\n\t\t\t\t\tEFX_NF_TCP_FLAG(RST) |\n\t\t\t\t\tEFX_NF_TCP_FLAG(FIN);\n\t\t \n\t\tif (fm.key->flags & tcp_interesting_flags) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Unsupported conntrack tcp.flags %04x/%04x\\n\",\n\t\t\t\t   ntohs(fm.key->flags), ntohs(fm.mask->flags));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t \n\t\tif (fm.mask->flags & ~tcp_interesting_flags) {\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Unsupported conntrack tcp.flags %04x/%04x\\n\",\n\t\t\t\t   ntohs(fm.key->flags), ntohs(fm.mask->flags));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int efx_tc_ct_replace(struct efx_tc_ct_zone *ct_zone,\n\t\t\t     struct flow_cls_offload *tc)\n{\n\tstruct flow_rule *fr = flow_cls_offload_flow_rule(tc);\n\tstruct efx_tc_ct_entry *conn, *old;\n\tstruct efx_nic *efx = ct_zone->efx;\n\tconst struct flow_action_entry *fa;\n\tstruct efx_tc_counter *cnt;\n\tint rc, i;\n\n\tif (WARN_ON(!efx->tc))\n\t\treturn -ENETDOWN;\n\tif (WARN_ON(!efx->tc->up))\n\t\treturn -ENETDOWN;\n\n\tconn = kzalloc(sizeof(*conn), GFP_USER);\n\tif (!conn)\n\t\treturn -ENOMEM;\n\tconn->cookie = tc->cookie;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->ct_ht,\n\t\t\t\t\t\t&conn->linkage,\n\t\t\t\t\t\tefx_tc_ct_ht_params);\n\tif (IS_ERR(old)) {\n\t\trc = PTR_ERR(old);\n\t\tgoto release;\n\t} else if (old) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Already offloaded conntrack (cookie %lx)\\n\", tc->cookie);\n\t\trc = -EEXIST;\n\t\tgoto release;\n\t}\n\n\t \n\tconn->zone = ct_zone;\n\trc = efx_tc_ct_parse_match(efx, fr, conn);\n\tif (rc)\n\t\tgoto release;\n\n\t \n\tflow_action_for_each(i, fa, &fr->action) {\n\t\tswitch (fa->id) {\n\t\tcase FLOW_ACTION_CT_METADATA:\n\t\t\tconn->mark = fa->ct_metadata.mark;\n\t\t\tif (memchr_inv(fa->ct_metadata.labels, 0, sizeof(fa->ct_metadata.labels))) {\n\t\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t\t  \"Setting CT label not supported\\n\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"Unhandled action %u for conntrack\\n\", fa->id);\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto release;\n\t\t}\n\t}\n\n\t \n\tconn->nat_ip = conn->dnat ? conn->dst_ip : conn->src_ip;\n\tconn->l4_natport = conn->dnat ? conn->l4_dport : conn->l4_sport;\n\n\tcnt = efx_tc_flower_allocate_counter(efx, EFX_TC_COUNTER_TYPE_CT);\n\tif (IS_ERR(cnt)) {\n\t\trc = PTR_ERR(cnt);\n\t\tgoto release;\n\t}\n\tconn->cnt = cnt;\n\n\trc = efx_mae_insert_ct(efx, conn);\n\tif (rc) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Failed to insert conntrack, %d\\n\", rc);\n\t\tgoto release;\n\t}\n\tmutex_lock(&ct_zone->mutex);\n\tlist_add_tail(&conn->list, &ct_zone->cts);\n\tmutex_unlock(&ct_zone->mutex);\n\treturn 0;\nrelease:\n\tif (conn->cnt)\n\t\tefx_tc_flower_release_counter(efx, conn->cnt);\n\tif (!old)\n\t\trhashtable_remove_fast(&efx->tc->ct_ht, &conn->linkage,\n\t\t\t\t       efx_tc_ct_ht_params);\n\tkfree(conn);\n\treturn rc;\n}\n\n \nstatic void efx_tc_ct_remove(struct efx_nic *efx, struct efx_tc_ct_entry *conn)\n{\n\tint rc;\n\n\t \n\trc = efx_mae_remove_ct(efx, conn);\n\t \n\trhashtable_remove_fast(&efx->tc->ct_ht, &conn->linkage,\n\t\t\t       efx_tc_ct_ht_params);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"Failed to remove conntrack %lx from hw, rc %d\\n\",\n\t\t\t  conn->cookie, rc);\n\t} else {\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"Removed conntrack %lx\\n\",\n\t\t\t  conn->cookie);\n\t}\n}\n\nstatic void efx_tc_ct_remove_finish(struct efx_nic *efx, struct efx_tc_ct_entry *conn)\n{\n\t \n\tefx_tc_flower_release_counter(efx, conn->cnt);\n\tkfree(conn);\n}\n\nstatic int efx_tc_ct_destroy(struct efx_tc_ct_zone *ct_zone,\n\t\t\t     struct flow_cls_offload *tc)\n{\n\tstruct efx_nic *efx = ct_zone->efx;\n\tstruct efx_tc_ct_entry *conn;\n\n\tconn = rhashtable_lookup_fast(&efx->tc->ct_ht, &tc->cookie,\n\t\t\t\t      efx_tc_ct_ht_params);\n\tif (!conn) {\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"Conntrack %lx not found to remove\\n\", tc->cookie);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&ct_zone->mutex);\n\tlist_del(&conn->list);\n\tefx_tc_ct_remove(efx, conn);\n\tmutex_unlock(&ct_zone->mutex);\n\tsynchronize_rcu();\n\tefx_tc_ct_remove_finish(efx, conn);\n\treturn 0;\n}\n\nstatic int efx_tc_ct_stats(struct efx_tc_ct_zone *ct_zone,\n\t\t\t   struct flow_cls_offload *tc)\n{\n\tstruct efx_nic *efx = ct_zone->efx;\n\tstruct efx_tc_ct_entry *conn;\n\tstruct efx_tc_counter *cnt;\n\n\trcu_read_lock();\n\tconn = rhashtable_lookup_fast(&efx->tc->ct_ht, &tc->cookie,\n\t\t\t\t      efx_tc_ct_ht_params);\n\tif (!conn) {\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"Conntrack %lx not found for stats\\n\", tc->cookie);\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tcnt = conn->cnt;\n\tspin_lock_bh(&cnt->lock);\n\t \n\tflow_stats_update(&tc->stats, 0, 0, 0, cnt->touched,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\tspin_unlock_bh(&cnt->lock);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int efx_tc_flow_block(enum tc_setup_type type, void *type_data,\n\t\t\t     void *cb_priv)\n{\n\tstruct flow_cls_offload *tcb = type_data;\n\tstruct efx_tc_ct_zone *ct_zone = cb_priv;\n\n\tif (type != TC_SETUP_CLSFLOWER)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (tcb->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn efx_tc_ct_replace(ct_zone, tcb);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn efx_tc_ct_destroy(ct_zone, tcb);\n\tcase FLOW_CLS_STATS:\n\t\treturn efx_tc_ct_stats(ct_zone, tcb);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstruct efx_tc_ct_zone *efx_tc_ct_register_zone(struct efx_nic *efx, u16 zone,\n\t\t\t\t\t       struct nf_flowtable *ct_ft)\n{\n\tstruct efx_tc_ct_zone *ct_zone, *old;\n\tint rc;\n\n\tct_zone = kzalloc(sizeof(*ct_zone), GFP_USER);\n\tif (!ct_zone)\n\t\treturn ERR_PTR(-ENOMEM);\n\tct_zone->zone = zone;\n\told = rhashtable_lookup_get_insert_fast(&efx->tc->ct_zone_ht,\n\t\t\t\t\t\t&ct_zone->linkage,\n\t\t\t\t\t\tefx_tc_ct_zone_ht_params);\n\tif (old) {\n\t\t \n\t\tkfree(ct_zone);\n\t\tif (IS_ERR(old))  \n\t\t\treturn ERR_CAST(old);\n\t\tif (!refcount_inc_not_zero(&old->ref))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t \n\t\tWARN_ON_ONCE(old->nf_ft != ct_ft);\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Found existing ct_zone for %u\\n\", zone);\n\t\treturn old;\n\t}\n\tct_zone->nf_ft = ct_ft;\n\tct_zone->efx = efx;\n\tINIT_LIST_HEAD(&ct_zone->cts);\n\tmutex_init(&ct_zone->mutex);\n\trc = nf_flow_table_offload_add_cb(ct_ft, efx_tc_flow_block, ct_zone);\n\tnetif_dbg(efx, drv, efx->net_dev, \"Adding new ct_zone for %u, rc %d\\n\",\n\t\t  zone, rc);\n\tif (rc < 0)\n\t\tgoto fail;\n\trefcount_set(&ct_zone->ref, 1);\n\treturn ct_zone;\nfail:\n\trhashtable_remove_fast(&efx->tc->ct_zone_ht, &ct_zone->linkage,\n\t\t\t       efx_tc_ct_zone_ht_params);\n\tkfree(ct_zone);\n\treturn ERR_PTR(rc);\n}\n\nvoid efx_tc_ct_unregister_zone(struct efx_nic *efx,\n\t\t\t       struct efx_tc_ct_zone *ct_zone)\n{\n\tstruct efx_tc_ct_entry *conn, *next;\n\n\tif (!refcount_dec_and_test(&ct_zone->ref))\n\t\treturn;  \n\tnf_flow_table_offload_del_cb(ct_zone->nf_ft, efx_tc_flow_block, ct_zone);\n\trhashtable_remove_fast(&efx->tc->ct_zone_ht, &ct_zone->linkage,\n\t\t\t       efx_tc_ct_zone_ht_params);\n\tmutex_lock(&ct_zone->mutex);\n\tlist_for_each_entry(conn, &ct_zone->cts, list)\n\t\tefx_tc_ct_remove(efx, conn);\n\tsynchronize_rcu();\n\t \n\tlist_for_each_entry_safe(conn, next, &ct_zone->cts, list)\n\t\tefx_tc_ct_remove_finish(efx, conn);\n\tmutex_unlock(&ct_zone->mutex);\n\tmutex_destroy(&ct_zone->mutex);\n\tnetif_dbg(efx, drv, efx->net_dev, \"Removed ct_zone for %u\\n\",\n\t\t  ct_zone->zone);\n\tkfree(ct_zone);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}