{
  "module_name": "tc_bindings.c",
  "hash_id": "097f4da765a58b121a3527357a49c8efa4bd9477d0848c19b4b0c9168f142ee6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/tc_bindings.c",
  "human_readable_source": "\n \n\n#include \"tc_bindings.h\"\n#include \"tc.h\"\n#include \"tc_encap_actions.h\"\n\nstruct efx_tc_block_binding {\n\tstruct list_head list;\n\tstruct efx_nic *efx;\n\tstruct efx_rep *efv;\n\tstruct net_device *otherdev;  \n\tstruct flow_block *block;\n};\n\nstatic struct efx_tc_block_binding *efx_tc_find_binding(struct efx_nic *efx,\n\t\t\t\t\t\t\tstruct net_device *otherdev)\n{\n\tstruct efx_tc_block_binding *binding;\n\n\tASSERT_RTNL();\n\tlist_for_each_entry(binding, &efx->tc->block_list, list)\n\t\tif (binding->otherdev == otherdev)\n\t\t\treturn binding;\n\treturn NULL;\n}\n\nstatic int efx_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t   void *cb_priv)\n{\n\tstruct efx_tc_block_binding *binding = cb_priv;\n\tstruct flow_cls_offload *tcf = type_data;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn efx_tc_flower(binding->efx, binding->otherdev,\n\t\t\t\t     tcf, binding->efv);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nvoid efx_tc_block_unbind(void *cb_priv)\n{\n\tstruct efx_tc_block_binding *binding = cb_priv;\n\n\tlist_del(&binding->list);\n\tkfree(binding);\n}\n\nstatic struct efx_tc_block_binding *efx_tc_create_binding(\n\t\t\tstruct efx_nic *efx, struct efx_rep *efv,\n\t\t\tstruct net_device *otherdev, struct flow_block *block)\n{\n\tstruct efx_tc_block_binding *binding = kmalloc(sizeof(*binding), GFP_KERNEL);\n\n\tif (!binding)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbinding->efx = efx;\n\tbinding->efv = efv;\n\tbinding->otherdev = otherdev;\n\tbinding->block = block;\n\tlist_add(&binding->list, &efx->tc->block_list);\n\treturn binding;\n}\n\nint efx_tc_setup_block(struct net_device *net_dev, struct efx_nic *efx,\n\t\t       struct flow_block_offload *tcb, struct efx_rep *efv)\n{\n\tstruct efx_tc_block_binding *binding;\n\tstruct flow_block_cb *block_cb;\n\tint rc;\n\n\tif (tcb->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(!efx->tc))\n\t\treturn -ENETDOWN;\n\n\tswitch (tcb->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tbinding = efx_tc_create_binding(efx, efv, net_dev, tcb->block);\n\t\tif (IS_ERR(binding))\n\t\t\treturn PTR_ERR(binding);\n\t\tblock_cb = flow_block_cb_alloc(efx_tc_block_cb, binding,\n\t\t\t\t\t       binding, efx_tc_block_unbind);\n\t\trc = PTR_ERR_OR_ZERO(block_cb);\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"bind %sdirect block for device %s, rc %d\\n\",\n\t\t\t  net_dev == efx->net_dev ? \"\" :\n\t\t\t  efv ? \"semi\" : \"in\",\n\t\t\t  net_dev ? net_dev->name : NULL, rc);\n\t\tif (rc) {\n\t\t\tlist_del(&binding->list);\n\t\t\tkfree(binding);\n\t\t} else {\n\t\t\tflow_block_cb_add(block_cb, tcb);\n\t\t}\n\t\treturn rc;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tbinding = efx_tc_find_binding(efx, net_dev);\n\t\tif (binding) {\n\t\t\tblock_cb = flow_block_cb_lookup(tcb->block,\n\t\t\t\t\t\t\tefx_tc_block_cb,\n\t\t\t\t\t\t\tbinding);\n\t\t\tif (block_cb) {\n\t\t\t\tflow_block_cb_remove(block_cb, tcb);\n\t\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t\t  \"unbound %sdirect block for device %s\\n\",\n\t\t\t\t\t  net_dev == efx->net_dev ? \"\" :\n\t\t\t\t\t  binding->efv ? \"semi\" : \"in\",\n\t\t\t\t\t  net_dev ? net_dev->name : NULL);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t \n\t\tnetif_cond_dbg(efx, drv, efx->net_dev,\n\t\t\t       !efx->tc->up, warn,\n\t\t\t       \"%sdirect block unbind for device %s, was never bound\\n\",\n\t\t\t       net_dev == efx->net_dev ? \"\" : \"in\",\n\t\t\t       net_dev ? net_dev->name : NULL);\n\t\treturn -ENOENT;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint efx_tc_indr_setup_cb(struct net_device *net_dev, struct Qdisc *sch,\n\t\t\t void *cb_priv, enum tc_setup_type type,\n\t\t\t void *type_data, void *data,\n\t\t\t void (*cleanup)(struct flow_block_cb *block_cb))\n{\n\tstruct flow_block_offload *tcb = type_data;\n\tstruct efx_tc_block_binding *binding;\n\tstruct flow_block_cb *block_cb;\n\tstruct efx_nic *efx = cb_priv;\n\tbool is_ovs_int_port;\n\tint rc;\n\n\tif (!net_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tif (tcb->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS &&\n\t    tcb->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tis_ovs_int_port = netif_is_ovs_master(net_dev);\n\tif (tcb->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS &&\n\t    !is_ovs_int_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (is_ovs_int_port)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\tswitch (tcb->command) {\n\t\tcase FLOW_BLOCK_BIND:\n\t\t\tbinding = efx_tc_create_binding(efx, NULL, net_dev, tcb->block);\n\t\t\tif (IS_ERR(binding))\n\t\t\t\treturn PTR_ERR(binding);\n\t\t\tblock_cb = flow_indr_block_cb_alloc(efx_tc_block_cb, binding,\n\t\t\t\t\t\t\t    binding, efx_tc_block_unbind,\n\t\t\t\t\t\t\t    tcb, net_dev, sch, data, binding,\n\t\t\t\t\t\t\t    cleanup);\n\t\t\trc = PTR_ERR_OR_ZERO(block_cb);\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"bind indr block for device %s, rc %d\\n\",\n\t\t\t\t  net_dev ? net_dev->name : NULL, rc);\n\t\t\tif (rc) {\n\t\t\t\tlist_del(&binding->list);\n\t\t\t\tkfree(binding);\n\t\t\t} else {\n\t\t\t\tflow_block_cb_add(block_cb, tcb);\n\t\t\t}\n\t\t\treturn rc;\n\t\tcase FLOW_BLOCK_UNBIND:\n\t\t\tbinding = efx_tc_find_binding(efx, net_dev);\n\t\t\tif (!binding)\n\t\t\t\treturn -ENOENT;\n\t\t\tblock_cb = flow_block_cb_lookup(tcb->block,\n\t\t\t\t\t\t\tefx_tc_block_cb,\n\t\t\t\t\t\t\tbinding);\n\t\t\tif (!block_cb)\n\t\t\t\treturn -ENOENT;\n\t\t\tflow_indr_block_cb_remove(block_cb, tcb);\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"unbind indr block for device %s\\n\",\n\t\t\t\t  net_dev ? net_dev->name : NULL);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nint efx_tc_setup(struct net_device *net_dev, enum tc_setup_type type,\n\t\t void *type_data)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tif (efx->type->is_vf)\n\t\treturn -EOPNOTSUPP;\n\tif (!efx->tc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == TC_SETUP_CLSFLOWER)\n\t\treturn efx_tc_flower(efx, net_dev, type_data, NULL);\n\tif (type == TC_SETUP_BLOCK)\n\t\treturn efx_tc_setup_block(net_dev, efx, type_data, NULL);\n\n\treturn -EOPNOTSUPP;\n}\n\nint efx_tc_netdev_event(struct efx_nic *efx, unsigned long event,\n\t\t\tstruct net_device *net_dev)\n{\n\tif (efx->type->is_vf)\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_UNREGISTER)\n\t\tefx_tc_unregister_egdev(efx, net_dev);\n\n\treturn NOTIFY_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}