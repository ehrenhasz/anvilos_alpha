{
  "module_name": "mcdi.c",
  "hash_id": "2de5f78407f80e199805a1d3f7bbd32ff5abea2d8adc6a38ab473e5b7ea69544",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/mcdi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include \"net_driver.h\"\n#include \"nic.h\"\n#include \"io.h\"\n#include \"mcdi_pcol.h\"\n\n \n\n#define MCDI_RPC_TIMEOUT       (10 * HZ)\n\n \n#define MCDI_STATUS_DELAY_US\t\t100\n#define MCDI_STATUS_DELAY_COUNT\t\t2500\n#define MCDI_STATUS_SLEEP_MS\t\t\t\t\t\t\\\n\t(MCDI_STATUS_DELAY_US * MCDI_STATUS_DELAY_COUNT / 1000)\n\n#define SEQ_MASK\t\t\t\t\t\t\t\\\n\tEFX_MASK32(EFX_WIDTH(MCDI_HEADER_SEQ))\n\nstruct efx_mcdi_async_param {\n\tstruct list_head list;\n\tunsigned int cmd;\n\tsize_t inlen;\n\tsize_t outlen;\n\tbool quiet;\n\tefx_mcdi_async_completer *complete;\n\tunsigned long cookie;\n\t \n};\n\nstatic void efx_mcdi_timeout_async(struct timer_list *t);\nstatic int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,\n\t\t\t       bool *was_attached_out);\nstatic bool efx_mcdi_poll_once(struct efx_nic *efx);\nstatic void efx_mcdi_abandon(struct efx_nic *efx);\n\n#ifdef CONFIG_SFC_MCDI_LOGGING\nstatic bool mcdi_logging_default;\nmodule_param(mcdi_logging_default, bool, 0644);\nMODULE_PARM_DESC(mcdi_logging_default,\n\t\t \"Enable MCDI logging on newly-probed functions\");\n#endif\n\nint efx_mcdi_init(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi;\n\tbool already_attached;\n\tint rc = -ENOMEM;\n\n\tefx->mcdi = kzalloc(sizeof(*efx->mcdi), GFP_KERNEL);\n\tif (!efx->mcdi)\n\t\tgoto fail;\n\n\tmcdi = efx_mcdi(efx);\n\tmcdi->efx = efx;\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\t \n\tmcdi->logging_buffer = (char *)__get_free_page(GFP_KERNEL);\n\tif (!mcdi->logging_buffer)\n\t\tgoto fail1;\n\tmcdi->logging_enabled = mcdi_logging_default;\n#endif\n\tinit_waitqueue_head(&mcdi->wq);\n\tinit_waitqueue_head(&mcdi->proxy_rx_wq);\n\tspin_lock_init(&mcdi->iface_lock);\n\tmcdi->state = MCDI_STATE_QUIESCENT;\n\tmcdi->mode = MCDI_MODE_POLL;\n\tspin_lock_init(&mcdi->async_lock);\n\tINIT_LIST_HEAD(&mcdi->async_list);\n\ttimer_setup(&mcdi->async_timer, efx_mcdi_timeout_async, 0);\n\n\t(void) efx_mcdi_poll_reboot(efx);\n\tmcdi->new_epoch = true;\n\n\t \n\trc = efx_mcdi_handle_assertion(efx);\n\tif (rc)\n\t\tgoto fail2;\n\n\t \n\trc = efx_mcdi_drv_attach(efx, true, &already_attached);\n\tif (rc) {\n\t\tpci_err(efx->pci_dev, \"Unable to register driver with MCPU\\n\");\n\t\tgoto fail2;\n\t}\n\tif (already_attached)\n\t\t \n\t\tpci_err(efx->pci_dev, \"Host already registered with MCPU\\n\");\n\n\tif (efx->mcdi->fn_flags &\n\t    (1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY))\n\t\tefx->primary = efx;\n\n\treturn 0;\nfail2:\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tfree_page((unsigned long)mcdi->logging_buffer);\nfail1:\n#endif\n\tkfree(efx->mcdi);\n\tefx->mcdi = NULL;\nfail:\n\treturn rc;\n}\n\nvoid efx_mcdi_detach(struct efx_nic *efx)\n{\n\tif (!efx->mcdi)\n\t\treturn;\n\n\tBUG_ON(efx->mcdi->iface.state != MCDI_STATE_QUIESCENT);\n\n\t \n\tefx_mcdi_drv_attach(efx, false, NULL);\n}\n\nvoid efx_mcdi_fini(struct efx_nic *efx)\n{\n\tif (!efx->mcdi)\n\t\treturn;\n\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tfree_page((unsigned long)efx->mcdi->iface.logging_buffer);\n#endif\n\n\tkfree(efx->mcdi);\n}\n\nstatic void efx_mcdi_send_request(struct efx_nic *efx, unsigned cmd,\n\t\t\t\t  const efx_dword_t *inbuf, size_t inlen)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tchar *buf = mcdi->logging_buffer;  \n#endif\n\tefx_dword_t hdr[2];\n\tsize_t hdr_len;\n\tu32 xflags, seqno;\n\n\tBUG_ON(mcdi->state == MCDI_STATE_QUIESCENT);\n\n\t \n\tspin_lock_bh(&mcdi->iface_lock);\n\t++mcdi->seqno;\n\tseqno = mcdi->seqno & SEQ_MASK;\n\tspin_unlock_bh(&mcdi->iface_lock);\n\n\txflags = 0;\n\tif (mcdi->mode == MCDI_MODE_EVENTS)\n\t\txflags |= MCDI_HEADER_XFLAGS_EVREQ;\n\n\tif (efx->type->mcdi_max_ver == 1) {\n\t\t \n\t\tEFX_POPULATE_DWORD_7(hdr[0],\n\t\t\t\t     MCDI_HEADER_RESPONSE, 0,\n\t\t\t\t     MCDI_HEADER_RESYNC, 1,\n\t\t\t\t     MCDI_HEADER_CODE, cmd,\n\t\t\t\t     MCDI_HEADER_DATALEN, inlen,\n\t\t\t\t     MCDI_HEADER_SEQ, seqno,\n\t\t\t\t     MCDI_HEADER_XFLAGS, xflags,\n\t\t\t\t     MCDI_HEADER_NOT_EPOCH, !mcdi->new_epoch);\n\t\thdr_len = 4;\n\t} else {\n\t\t \n\t\tBUG_ON(inlen > MCDI_CTL_SDU_LEN_MAX_V2);\n\t\tEFX_POPULATE_DWORD_7(hdr[0],\n\t\t\t\t     MCDI_HEADER_RESPONSE, 0,\n\t\t\t\t     MCDI_HEADER_RESYNC, 1,\n\t\t\t\t     MCDI_HEADER_CODE, MC_CMD_V2_EXTN,\n\t\t\t\t     MCDI_HEADER_DATALEN, 0,\n\t\t\t\t     MCDI_HEADER_SEQ, seqno,\n\t\t\t\t     MCDI_HEADER_XFLAGS, xflags,\n\t\t\t\t     MCDI_HEADER_NOT_EPOCH, !mcdi->new_epoch);\n\t\tEFX_POPULATE_DWORD_2(hdr[1],\n\t\t\t\t     MC_CMD_V2_EXTN_IN_EXTENDED_CMD, cmd,\n\t\t\t\t     MC_CMD_V2_EXTN_IN_ACTUAL_LEN, inlen);\n\t\thdr_len = 8;\n\t}\n\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tif (mcdi->logging_enabled && !WARN_ON_ONCE(!buf)) {\n\t\tint bytes = 0;\n\t\tint i;\n\t\t \n\t\tWARN_ON_ONCE(hdr_len % 4);\n\t\tWARN_ON_ONCE(inlen % 4);\n\n\t\t \n\t\tfor (i = 0; i < hdr_len / 4 && bytes < PAGE_SIZE; i++)\n\t\t\tbytes += scnprintf(buf + bytes, PAGE_SIZE - bytes,\n\t\t\t\t\t   \" %08x\",\n\t\t\t\t\t   le32_to_cpu(hdr[i].u32[0]));\n\n\t\tfor (i = 0; i < inlen / 4 && bytes < PAGE_SIZE; i++)\n\t\t\tbytes += scnprintf(buf + bytes, PAGE_SIZE - bytes,\n\t\t\t\t\t   \" %08x\",\n\t\t\t\t\t   le32_to_cpu(inbuf[i].u32[0]));\n\n\t\tnetif_info(efx, hw, efx->net_dev, \"MCDI RPC REQ:%s\\n\", buf);\n\t}\n#endif\n\n\tefx->type->mcdi_request(efx, hdr, hdr_len, inbuf, inlen);\n\n\tmcdi->new_epoch = false;\n}\n\nstatic int efx_mcdi_errno(unsigned int mcdi_err)\n{\n\tswitch (mcdi_err) {\n\tcase 0:\n\t\treturn 0;\n#define TRANSLATE_ERROR(name)\t\t\t\t\t\\\n\tcase MC_CMD_ERR_ ## name:\t\t\t\t\\\n\t\treturn -name;\n\tTRANSLATE_ERROR(EPERM);\n\tTRANSLATE_ERROR(ENOENT);\n\tTRANSLATE_ERROR(EINTR);\n\tTRANSLATE_ERROR(EAGAIN);\n\tTRANSLATE_ERROR(EACCES);\n\tTRANSLATE_ERROR(EBUSY);\n\tTRANSLATE_ERROR(EINVAL);\n\tTRANSLATE_ERROR(EDEADLK);\n\tTRANSLATE_ERROR(ENOSYS);\n\tTRANSLATE_ERROR(ETIME);\n\tTRANSLATE_ERROR(EALREADY);\n\tTRANSLATE_ERROR(ENOSPC);\n#undef TRANSLATE_ERROR\n\tcase MC_CMD_ERR_ENOTSUP:\n\t\treturn -EOPNOTSUPP;\n\tcase MC_CMD_ERR_ALLOC_FAIL:\n\t\treturn -ENOBUFS;\n\tcase MC_CMD_ERR_MAC_EXIST:\n\t\treturn -EADDRINUSE;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n}\n\nstatic void efx_mcdi_read_response_header(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tunsigned int respseq, respcmd, error;\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tchar *buf = mcdi->logging_buffer;  \n#endif\n\tefx_dword_t hdr;\n\n\tefx->type->mcdi_read_response(efx, &hdr, 0, 4);\n\trespseq = EFX_DWORD_FIELD(hdr, MCDI_HEADER_SEQ);\n\trespcmd = EFX_DWORD_FIELD(hdr, MCDI_HEADER_CODE);\n\terror = EFX_DWORD_FIELD(hdr, MCDI_HEADER_ERROR);\n\n\tif (respcmd != MC_CMD_V2_EXTN) {\n\t\tmcdi->resp_hdr_len = 4;\n\t\tmcdi->resp_data_len = EFX_DWORD_FIELD(hdr, MCDI_HEADER_DATALEN);\n\t} else {\n\t\tefx->type->mcdi_read_response(efx, &hdr, 4, 4);\n\t\tmcdi->resp_hdr_len = 8;\n\t\tmcdi->resp_data_len =\n\t\t\tEFX_DWORD_FIELD(hdr, MC_CMD_V2_EXTN_IN_ACTUAL_LEN);\n\t}\n\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tif (mcdi->logging_enabled && !WARN_ON_ONCE(!buf)) {\n\t\tsize_t hdr_len, data_len;\n\t\tint bytes = 0;\n\t\tint i;\n\n\t\tWARN_ON_ONCE(mcdi->resp_hdr_len % 4);\n\t\thdr_len = mcdi->resp_hdr_len / 4;\n\t\t \n\t\tdata_len = DIV_ROUND_UP(mcdi->resp_data_len, 4);\n\n\t\t \n\t\tfor (i = 0; i < hdr_len && bytes < PAGE_SIZE; i++) {\n\t\t\tefx->type->mcdi_read_response(efx, &hdr, (i * 4), 4);\n\t\t\tbytes += scnprintf(buf + bytes, PAGE_SIZE - bytes,\n\t\t\t\t\t   \" %08x\", le32_to_cpu(hdr.u32[0]));\n\t\t}\n\n\t\tfor (i = 0; i < data_len && bytes < PAGE_SIZE; i++) {\n\t\t\tefx->type->mcdi_read_response(efx, &hdr,\n\t\t\t\t\tmcdi->resp_hdr_len + (i * 4), 4);\n\t\t\tbytes += scnprintf(buf + bytes, PAGE_SIZE - bytes,\n\t\t\t\t\t   \" %08x\", le32_to_cpu(hdr.u32[0]));\n\t\t}\n\n\t\tnetif_info(efx, hw, efx->net_dev, \"MCDI RPC RESP:%s\\n\", buf);\n\t}\n#endif\n\n\tmcdi->resprc_raw = 0;\n\tif (error && mcdi->resp_data_len == 0) {\n\t\tnetif_err(efx, hw, efx->net_dev, \"MC rebooted\\n\");\n\t\tmcdi->resprc = -EIO;\n\t} else if ((respseq ^ mcdi->seqno) & SEQ_MASK) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"MC response mismatch tx seq 0x%x rx seq 0x%x\\n\",\n\t\t\t  respseq, mcdi->seqno);\n\t\tmcdi->resprc = -EIO;\n\t} else if (error) {\n\t\tefx->type->mcdi_read_response(efx, &hdr, mcdi->resp_hdr_len, 4);\n\t\tmcdi->resprc_raw = EFX_DWORD_FIELD(hdr, EFX_DWORD_0);\n\t\tmcdi->resprc = efx_mcdi_errno(mcdi->resprc_raw);\n\t} else {\n\t\tmcdi->resprc = 0;\n\t}\n}\n\nstatic bool efx_mcdi_poll_once(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\n\trmb();\n\tif (!efx->type->mcdi_poll_response(efx))\n\t\treturn false;\n\n\tspin_lock_bh(&mcdi->iface_lock);\n\tefx_mcdi_read_response_header(efx);\n\tspin_unlock_bh(&mcdi->iface_lock);\n\n\treturn true;\n}\n\nstatic int efx_mcdi_poll(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tunsigned long time, finish;\n\tunsigned int spins;\n\tint rc;\n\n\t \n\trc = efx_mcdi_poll_reboot(efx);\n\tif (rc) {\n\t\tspin_lock_bh(&mcdi->iface_lock);\n\t\tmcdi->resprc = rc;\n\t\tmcdi->resp_hdr_len = 0;\n\t\tmcdi->resp_data_len = 0;\n\t\tspin_unlock_bh(&mcdi->iface_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tspins = USER_TICK_USEC;\n\tfinish = jiffies + MCDI_RPC_TIMEOUT;\n\n\twhile (1) {\n\t\tif (spins != 0) {\n\t\t\t--spins;\n\t\t\tudelay(1);\n\t\t} else {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\ttime = jiffies;\n\n\t\tif (efx_mcdi_poll_once(efx))\n\t\t\tbreak;\n\n\t\tif (time_after(time, finish))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nint efx_mcdi_poll_reboot(struct efx_nic *efx)\n{\n\tif (!efx->mcdi)\n\t\treturn 0;\n\n\treturn efx->type->mcdi_poll_reboot(efx);\n}\n\nstatic bool efx_mcdi_acquire_async(struct efx_mcdi_iface *mcdi)\n{\n\treturn cmpxchg(&mcdi->state,\n\t\t       MCDI_STATE_QUIESCENT, MCDI_STATE_RUNNING_ASYNC) ==\n\t\tMCDI_STATE_QUIESCENT;\n}\n\nstatic void efx_mcdi_acquire_sync(struct efx_mcdi_iface *mcdi)\n{\n\t \n\twait_event(mcdi->wq,\n\t\t   cmpxchg(&mcdi->state,\n\t\t\t   MCDI_STATE_QUIESCENT, MCDI_STATE_RUNNING_SYNC) ==\n\t\t   MCDI_STATE_QUIESCENT);\n}\n\nstatic int efx_mcdi_await_completion(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\n\tif (wait_event_timeout(mcdi->wq, mcdi->state == MCDI_STATE_COMPLETED,\n\t\t\t       MCDI_RPC_TIMEOUT) == 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tif (mcdi->mode == MCDI_MODE_POLL)\n\t\treturn efx_mcdi_poll(efx);\n\n\treturn 0;\n}\n\n \nstatic bool efx_mcdi_complete_sync(struct efx_mcdi_iface *mcdi)\n{\n\tif (cmpxchg(&mcdi->state,\n\t\t    MCDI_STATE_RUNNING_SYNC, MCDI_STATE_COMPLETED) ==\n\t    MCDI_STATE_RUNNING_SYNC) {\n\t\twake_up(&mcdi->wq);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void efx_mcdi_release(struct efx_mcdi_iface *mcdi)\n{\n\tif (mcdi->mode == MCDI_MODE_EVENTS) {\n\t\tstruct efx_mcdi_async_param *async;\n\t\tstruct efx_nic *efx = mcdi->efx;\n\n\t\t \n\t\tspin_lock_bh(&mcdi->async_lock);\n\t\tasync = list_first_entry_or_null(\n\t\t\t&mcdi->async_list, struct efx_mcdi_async_param, list);\n\t\tif (async) {\n\t\t\tmcdi->state = MCDI_STATE_RUNNING_ASYNC;\n\t\t\tefx_mcdi_send_request(efx, async->cmd,\n\t\t\t\t\t      (const efx_dword_t *)(async + 1),\n\t\t\t\t\t      async->inlen);\n\t\t\tmod_timer(&mcdi->async_timer,\n\t\t\t\t  jiffies + MCDI_RPC_TIMEOUT);\n\t\t}\n\t\tspin_unlock_bh(&mcdi->async_lock);\n\n\t\tif (async)\n\t\t\treturn;\n\t}\n\n\tmcdi->state = MCDI_STATE_QUIESCENT;\n\twake_up(&mcdi->wq);\n}\n\n \nstatic bool efx_mcdi_complete_async(struct efx_mcdi_iface *mcdi, bool timeout)\n{\n\tstruct efx_nic *efx = mcdi->efx;\n\tstruct efx_mcdi_async_param *async;\n\tsize_t hdr_len, data_len, err_len;\n\tefx_dword_t *outbuf;\n\tMCDI_DECLARE_BUF_ERR(errbuf);\n\tint rc;\n\n\tif (cmpxchg(&mcdi->state,\n\t\t    MCDI_STATE_RUNNING_ASYNC, MCDI_STATE_COMPLETED) !=\n\t    MCDI_STATE_RUNNING_ASYNC)\n\t\treturn false;\n\n\tspin_lock(&mcdi->iface_lock);\n\tif (timeout) {\n\t\t \n\t\t++mcdi->seqno;\n\t\t++mcdi->credits;\n\t\trc = -ETIMEDOUT;\n\t\thdr_len = 0;\n\t\tdata_len = 0;\n\t} else {\n\t\trc = mcdi->resprc;\n\t\thdr_len = mcdi->resp_hdr_len;\n\t\tdata_len = mcdi->resp_data_len;\n\t}\n\tspin_unlock(&mcdi->iface_lock);\n\n\t \n\tif (!timeout)\n\t\tdel_timer_sync(&mcdi->async_timer);\n\n\tspin_lock(&mcdi->async_lock);\n\tasync = list_first_entry(&mcdi->async_list,\n\t\t\t\t struct efx_mcdi_async_param, list);\n\tlist_del(&async->list);\n\tspin_unlock(&mcdi->async_lock);\n\n\toutbuf = (efx_dword_t *)(async + 1);\n\tefx->type->mcdi_read_response(efx, outbuf, hdr_len,\n\t\t\t\t      min(async->outlen, data_len));\n\tif (!timeout && rc && !async->quiet) {\n\t\terr_len = min(sizeof(errbuf), data_len);\n\t\tefx->type->mcdi_read_response(efx, errbuf, hdr_len,\n\t\t\t\t\t      sizeof(errbuf));\n\t\tefx_mcdi_display_error(efx, async->cmd, async->inlen, errbuf,\n\t\t\t\t       err_len, rc);\n\t}\n\n\tif (async->complete)\n\t\tasync->complete(efx, async->cookie, rc, outbuf,\n\t\t\t\tmin(async->outlen, data_len));\n\tkfree(async);\n\n\tefx_mcdi_release(mcdi);\n\n\treturn true;\n}\n\nstatic void efx_mcdi_ev_cpl(struct efx_nic *efx, unsigned int seqno,\n\t\t\t    unsigned int datalen, unsigned int mcdi_err)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tbool wake = false;\n\n\tspin_lock(&mcdi->iface_lock);\n\n\tif ((seqno ^ mcdi->seqno) & SEQ_MASK) {\n\t\tif (mcdi->credits)\n\t\t\t \n\t\t\t--mcdi->credits;\n\t\telse\n\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t  \"MC response mismatch tx seq 0x%x rx \"\n\t\t\t\t  \"seq 0x%x\\n\", seqno, mcdi->seqno);\n\t} else {\n\t\tif (efx->type->mcdi_max_ver >= 2) {\n\t\t\t \n\t\t\tefx_mcdi_read_response_header(efx);\n\t\t} else {\n\t\t\tmcdi->resprc = efx_mcdi_errno(mcdi_err);\n\t\t\tmcdi->resp_hdr_len = 4;\n\t\t\tmcdi->resp_data_len = datalen;\n\t\t}\n\n\t\twake = true;\n\t}\n\n\tspin_unlock(&mcdi->iface_lock);\n\n\tif (wake) {\n\t\tif (!efx_mcdi_complete_async(mcdi, false))\n\t\t\t(void) efx_mcdi_complete_sync(mcdi);\n\n\t\t \n\t}\n}\n\nstatic void efx_mcdi_timeout_async(struct timer_list *t)\n{\n\tstruct efx_mcdi_iface *mcdi = from_timer(mcdi, t, async_timer);\n\n\tefx_mcdi_complete_async(mcdi, true);\n}\n\nstatic int\nefx_mcdi_check_supported(struct efx_nic *efx, unsigned int cmd, size_t inlen)\n{\n\tif (efx->type->mcdi_max_ver < 0 ||\n\t     (efx->type->mcdi_max_ver < 2 &&\n\t      cmd > MC_CMD_CMD_SPACE_ESCAPE_7))\n\t\treturn -EINVAL;\n\n\tif (inlen > MCDI_CTL_SDU_LEN_MAX_V2 ||\n\t    (efx->type->mcdi_max_ver < 2 &&\n\t     inlen > MCDI_CTL_SDU_LEN_MAX_V1))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic bool efx_mcdi_get_proxy_handle(struct efx_nic *efx,\n\t\t\t\t      size_t hdr_len, size_t data_len,\n\t\t\t\t      u32 *proxy_handle)\n{\n\tMCDI_DECLARE_BUF_ERR(testbuf);\n\tconst size_t buflen = sizeof(testbuf);\n\n\tif (!proxy_handle || data_len < buflen)\n\t\treturn false;\n\n\tefx->type->mcdi_read_response(efx, testbuf, hdr_len, buflen);\n\tif (MCDI_DWORD(testbuf, ERR_CODE) == MC_CMD_ERR_PROXY_PENDING) {\n\t\t*proxy_handle = MCDI_DWORD(testbuf, ERR_PROXY_PENDING_HANDLE);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int _efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned int cmd,\n\t\t\t\tsize_t inlen,\n\t\t\t\tefx_dword_t *outbuf, size_t outlen,\n\t\t\t\tsize_t *outlen_actual, bool quiet,\n\t\t\t\tu32 *proxy_handle, int *raw_rc)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tMCDI_DECLARE_BUF_ERR(errbuf);\n\tint rc;\n\n\tif (mcdi->mode == MCDI_MODE_POLL)\n\t\trc = efx_mcdi_poll(efx);\n\telse\n\t\trc = efx_mcdi_await_completion(efx);\n\n\tif (rc != 0) {\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"MC command 0x%x inlen %d mode %d timed out\\n\",\n\t\t\t  cmd, (int)inlen, mcdi->mode);\n\n\t\tif (mcdi->mode == MCDI_MODE_EVENTS && efx_mcdi_poll_once(efx)) {\n\t\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t\t  \"MCDI request was completed without an event\\n\");\n\t\t\trc = 0;\n\t\t}\n\n\t\tefx_mcdi_abandon(efx);\n\n\t\t \n\t\tspin_lock_bh(&mcdi->iface_lock);\n\t\t++mcdi->seqno;\n\t\t++mcdi->credits;\n\t\tspin_unlock_bh(&mcdi->iface_lock);\n\t}\n\n\tif (proxy_handle)\n\t\t*proxy_handle = 0;\n\n\tif (rc != 0) {\n\t\tif (outlen_actual)\n\t\t\t*outlen_actual = 0;\n\t} else {\n\t\tsize_t hdr_len, data_len, err_len;\n\n\t\t \n\t\tspin_lock_bh(&mcdi->iface_lock);\n\t\trc = mcdi->resprc;\n\t\tif (raw_rc)\n\t\t\t*raw_rc = mcdi->resprc_raw;\n\t\thdr_len = mcdi->resp_hdr_len;\n\t\tdata_len = mcdi->resp_data_len;\n\t\terr_len = min(sizeof(errbuf), data_len);\n\t\tspin_unlock_bh(&mcdi->iface_lock);\n\n\t\tBUG_ON(rc > 0);\n\n\t\tefx->type->mcdi_read_response(efx, outbuf, hdr_len,\n\t\t\t\t\t      min(outlen, data_len));\n\t\tif (outlen_actual)\n\t\t\t*outlen_actual = data_len;\n\n\t\tefx->type->mcdi_read_response(efx, errbuf, hdr_len, err_len);\n\n\t\tif (cmd == MC_CMD_REBOOT && rc == -EIO) {\n\t\t\t \n\t\t} else if (rc == -EIO || rc == -EINTR) {\n\t\t\tnetif_err(efx, hw, efx->net_dev, \"MC reboot detected\\n\");\n\t\t\tnetif_dbg(efx, hw, efx->net_dev, \"MC rebooted during command %d rc %d\\n\",\n\t\t\t\t  cmd, -rc);\n\t\t\tif (efx->type->mcdi_reboot_detected)\n\t\t\t\tefx->type->mcdi_reboot_detected(efx);\n\t\t\tefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\n\t\t} else if (proxy_handle && (rc == -EPROTO) &&\n\t\t\t   efx_mcdi_get_proxy_handle(efx, hdr_len, data_len,\n\t\t\t\t\t\t     proxy_handle)) {\n\t\t\tmcdi->proxy_rx_status = 0;\n\t\t\tmcdi->proxy_rx_handle = 0;\n\t\t\tmcdi->state = MCDI_STATE_PROXY_WAIT;\n\t\t} else if (rc && !quiet) {\n\t\t\tefx_mcdi_display_error(efx, cmd, inlen, errbuf, err_len,\n\t\t\t\t\t       rc);\n\t\t}\n\n\t\tif (rc == -EIO || rc == -EINTR) {\n\t\t\tmsleep(MCDI_STATUS_SLEEP_MS);\n\t\t\tefx_mcdi_poll_reboot(efx);\n\t\t\tmcdi->new_epoch = true;\n\t\t}\n\t}\n\n\tif (!proxy_handle || !*proxy_handle)\n\t\tefx_mcdi_release(mcdi);\n\treturn rc;\n}\n\nstatic void efx_mcdi_proxy_abort(struct efx_mcdi_iface *mcdi)\n{\n\tif (mcdi->state == MCDI_STATE_PROXY_WAIT) {\n\t\t \n\t\tmcdi->proxy_rx_status = -EINTR;\n\t\twake_up(&mcdi->proxy_rx_wq);\n\t}\n}\n\nstatic void efx_mcdi_ev_proxy_response(struct efx_nic *efx,\n\t\t\t\t       u32 handle, int status)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\n\tWARN_ON(mcdi->state != MCDI_STATE_PROXY_WAIT);\n\n\tmcdi->proxy_rx_status = efx_mcdi_errno(status);\n\t \n\twmb();\n\tmcdi->proxy_rx_handle = handle;\n\twake_up(&mcdi->proxy_rx_wq);\n}\n\nstatic int efx_mcdi_proxy_wait(struct efx_nic *efx, u32 handle, bool quiet)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tint rc;\n\n\t \n\trc = wait_event_timeout(mcdi->proxy_rx_wq,\n\t\t\t\tmcdi->proxy_rx_handle != 0 ||\n\t\t\t\tmcdi->proxy_rx_status == -EINTR,\n\t\t\t\tMCDI_RPC_TIMEOUT);\n\n\tif (rc <= 0) {\n\t\tnetif_dbg(efx, hw, efx->net_dev,\n\t\t\t  \"MCDI proxy timeout %d\\n\", handle);\n\t\treturn -ETIMEDOUT;\n\t} else if (mcdi->proxy_rx_handle != handle) {\n\t\tnetif_warn(efx, hw, efx->net_dev,\n\t\t\t   \"MCDI proxy unexpected handle %d (expected %d)\\n\",\n\t\t\t   mcdi->proxy_rx_handle, handle);\n\t\treturn -EINVAL;\n\t}\n\n\treturn mcdi->proxy_rx_status;\n}\n\nstatic int _efx_mcdi_rpc(struct efx_nic *efx, unsigned int cmd,\n\t\t\t const efx_dword_t *inbuf, size_t inlen,\n\t\t\t efx_dword_t *outbuf, size_t outlen,\n\t\t\t size_t *outlen_actual, bool quiet, int *raw_rc)\n{\n\tu32 proxy_handle = 0;  \n\tint rc;\n\n\tif (inbuf && inlen && (inbuf == outbuf)) {\n\t\t \n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\trc = efx_mcdi_rpc_start(efx, cmd, inbuf, inlen);\n\tif (rc)\n\t\treturn rc;\n\n\trc = _efx_mcdi_rpc_finish(efx, cmd, inlen, outbuf, outlen,\n\t\t\t\t  outlen_actual, quiet, &proxy_handle, raw_rc);\n\n\tif (proxy_handle) {\n\t\t \n\t\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\n\t\tnetif_dbg(efx, hw, efx->net_dev,\n\t\t\t  \"MCDI waiting for proxy auth %d\\n\",\n\t\t\t  proxy_handle);\n\t\trc = efx_mcdi_proxy_wait(efx, proxy_handle, quiet);\n\n\t\tif (rc == 0) {\n\t\t\tnetif_dbg(efx, hw, efx->net_dev,\n\t\t\t\t  \"MCDI proxy retry %d\\n\", proxy_handle);\n\n\t\t\t \n\t\t\tmcdi->state = MCDI_STATE_RUNNING_SYNC;\n\t\t\tefx_mcdi_send_request(efx, cmd, inbuf, inlen);\n\n\t\t\trc = _efx_mcdi_rpc_finish(efx, cmd, inlen,\n\t\t\t\t\t\t  outbuf, outlen, outlen_actual,\n\t\t\t\t\t\t  quiet, NULL, raw_rc);\n\t\t} else {\n\t\t\tnetif_cond_dbg(efx, hw, efx->net_dev, rc == -EPERM, err,\n\t\t\t\t       \"MC command 0x%x failed after proxy auth rc=%d\\n\",\n\t\t\t\t       cmd, rc);\n\n\t\t\tif (rc == -EINTR || rc == -EIO)\n\t\t\t\tefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\n\t\t\tefx_mcdi_release(mcdi);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int _efx_mcdi_rpc_evb_retry(struct efx_nic *efx, unsigned cmd,\n\t\t\t\t   const efx_dword_t *inbuf, size_t inlen,\n\t\t\t\t   efx_dword_t *outbuf, size_t outlen,\n\t\t\t\t   size_t *outlen_actual, bool quiet)\n{\n\tint raw_rc = 0;\n\tint rc;\n\n\trc = _efx_mcdi_rpc(efx, cmd, inbuf, inlen,\n\t\t\t   outbuf, outlen, outlen_actual, true, &raw_rc);\n\n\tif ((rc == -EPROTO) && (raw_rc == MC_CMD_ERR_NO_EVB_PORT) &&\n\t    efx->type->is_vf) {\n\t\t \n\t\tunsigned long abort_time = jiffies + MCDI_RPC_TIMEOUT;\n\t\tunsigned int delay_us = 10000;\n\n\t\tnetif_dbg(efx, hw, efx->net_dev,\n\t\t\t  \"%s: NO_EVB_PORT; will retry request\\n\",\n\t\t\t  __func__);\n\n\t\tdo {\n\t\t\tusleep_range(delay_us, delay_us + 10000);\n\t\t\trc = _efx_mcdi_rpc(efx, cmd, inbuf, inlen,\n\t\t\t\t\t   outbuf, outlen, outlen_actual,\n\t\t\t\t\t   true, &raw_rc);\n\t\t\tif (delay_us < 100000)\n\t\t\t\tdelay_us <<= 1;\n\t\t} while ((rc == -EPROTO) &&\n\t\t\t (raw_rc == MC_CMD_ERR_NO_EVB_PORT) &&\n\t\t\t time_before(jiffies, abort_time));\n\t}\n\n\tif (rc && !quiet && !(cmd == MC_CMD_REBOOT && rc == -EIO))\n\t\tefx_mcdi_display_error(efx, cmd, inlen,\n\t\t\t\t       outbuf, outlen, rc);\n\n\treturn rc;\n}\n\n \nint efx_mcdi_rpc(struct efx_nic *efx, unsigned cmd,\n\t\t const efx_dword_t *inbuf, size_t inlen,\n\t\t efx_dword_t *outbuf, size_t outlen,\n\t\t size_t *outlen_actual)\n{\n\treturn _efx_mcdi_rpc_evb_retry(efx, cmd, inbuf, inlen, outbuf, outlen,\n\t\t\t\t       outlen_actual, false);\n}\n\n \nint efx_mcdi_rpc_quiet(struct efx_nic *efx, unsigned cmd,\n\t\t       const efx_dword_t *inbuf, size_t inlen,\n\t\t       efx_dword_t *outbuf, size_t outlen,\n\t\t       size_t *outlen_actual)\n{\n\treturn _efx_mcdi_rpc_evb_retry(efx, cmd, inbuf, inlen, outbuf, outlen,\n\t\t\t\t       outlen_actual, true);\n}\n\nint efx_mcdi_rpc_start(struct efx_nic *efx, unsigned cmd,\n\t\t       const efx_dword_t *inbuf, size_t inlen)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tint rc;\n\n\trc = efx_mcdi_check_supported(efx, cmd, inlen);\n\tif (rc)\n\t\treturn rc;\n\n\tif (efx->mc_bist_for_other_fn)\n\t\treturn -ENETDOWN;\n\n\tif (mcdi->mode == MCDI_MODE_FAIL)\n\t\treturn -ENETDOWN;\n\n\tefx_mcdi_acquire_sync(mcdi);\n\tefx_mcdi_send_request(efx, cmd, inbuf, inlen);\n\treturn 0;\n}\n\nstatic int _efx_mcdi_rpc_async(struct efx_nic *efx, unsigned int cmd,\n\t\t\t       const efx_dword_t *inbuf, size_t inlen,\n\t\t\t       size_t outlen,\n\t\t\t       efx_mcdi_async_completer *complete,\n\t\t\t       unsigned long cookie, bool quiet)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tstruct efx_mcdi_async_param *async;\n\tint rc;\n\n\trc = efx_mcdi_check_supported(efx, cmd, inlen);\n\tif (rc)\n\t\treturn rc;\n\n\tif (efx->mc_bist_for_other_fn)\n\t\treturn -ENETDOWN;\n\n\tasync = kmalloc(sizeof(*async) + ALIGN(max(inlen, outlen), 4),\n\t\t\tGFP_ATOMIC);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tasync->cmd = cmd;\n\tasync->inlen = inlen;\n\tasync->outlen = outlen;\n\tasync->quiet = quiet;\n\tasync->complete = complete;\n\tasync->cookie = cookie;\n\tmemcpy(async + 1, inbuf, inlen);\n\n\tspin_lock_bh(&mcdi->async_lock);\n\n\tif (mcdi->mode == MCDI_MODE_EVENTS) {\n\t\tlist_add_tail(&async->list, &mcdi->async_list);\n\n\t\t \n\t\tif (mcdi->async_list.next == &async->list &&\n\t\t    efx_mcdi_acquire_async(mcdi)) {\n\t\t\tefx_mcdi_send_request(efx, cmd, inbuf, inlen);\n\t\t\tmod_timer(&mcdi->async_timer,\n\t\t\t\t  jiffies + MCDI_RPC_TIMEOUT);\n\t\t}\n\t} else {\n\t\tkfree(async);\n\t\trc = -ENETDOWN;\n\t}\n\n\tspin_unlock_bh(&mcdi->async_lock);\n\n\treturn rc;\n}\n\n \nint\nefx_mcdi_rpc_async(struct efx_nic *efx, unsigned int cmd,\n\t\t   const efx_dword_t *inbuf, size_t inlen, size_t outlen,\n\t\t   efx_mcdi_async_completer *complete, unsigned long cookie)\n{\n\treturn _efx_mcdi_rpc_async(efx, cmd, inbuf, inlen, outlen, complete,\n\t\t\t\t   cookie, false);\n}\n\nint efx_mcdi_rpc_async_quiet(struct efx_nic *efx, unsigned int cmd,\n\t\t\t     const efx_dword_t *inbuf, size_t inlen,\n\t\t\t     size_t outlen, efx_mcdi_async_completer *complete,\n\t\t\t     unsigned long cookie)\n{\n\treturn _efx_mcdi_rpc_async(efx, cmd, inbuf, inlen, outlen, complete,\n\t\t\t\t   cookie, true);\n}\n\nint efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned cmd, size_t inlen,\n\t\t\tefx_dword_t *outbuf, size_t outlen,\n\t\t\tsize_t *outlen_actual)\n{\n\treturn _efx_mcdi_rpc_finish(efx, cmd, inlen, outbuf, outlen,\n\t\t\t\t    outlen_actual, false, NULL, NULL);\n}\n\nint efx_mcdi_rpc_finish_quiet(struct efx_nic *efx, unsigned cmd, size_t inlen,\n\t\t\t      efx_dword_t *outbuf, size_t outlen,\n\t\t\t      size_t *outlen_actual)\n{\n\treturn _efx_mcdi_rpc_finish(efx, cmd, inlen, outbuf, outlen,\n\t\t\t\t    outlen_actual, true, NULL, NULL);\n}\n\nvoid efx_mcdi_display_error(struct efx_nic *efx, unsigned cmd,\n\t\t\t    size_t inlen, efx_dword_t *outbuf,\n\t\t\t    size_t outlen, int rc)\n{\n\tint code = 0, err_arg = 0;\n\n\tif (outlen >= MC_CMD_ERR_CODE_OFST + 4)\n\t\tcode = MCDI_DWORD(outbuf, ERR_CODE);\n\tif (outlen >= MC_CMD_ERR_ARG_OFST + 4)\n\t\terr_arg = MCDI_DWORD(outbuf, ERR_ARG);\n\tnetif_cond_dbg(efx, hw, efx->net_dev, rc == -EPERM, err,\n\t\t       \"MC command 0x%x inlen %zu failed rc=%d (raw=%d) arg=%d\\n\",\n\t\t       cmd, inlen, rc, code, err_arg);\n}\n\n \nvoid efx_mcdi_mode_poll(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi;\n\n\tif (!efx->mcdi)\n\t\treturn;\n\n\tmcdi = efx_mcdi(efx);\n\t \n\tif (mcdi->mode == MCDI_MODE_POLL || mcdi->mode == MCDI_MODE_FAIL)\n\t\treturn;\n\n\t \n\tmcdi->mode = MCDI_MODE_POLL;\n\n\tefx_mcdi_complete_sync(mcdi);\n}\n\n \nvoid efx_mcdi_flush_async(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_async_param *async, *next;\n\tstruct efx_mcdi_iface *mcdi;\n\n\tif (!efx->mcdi)\n\t\treturn;\n\n\tmcdi = efx_mcdi(efx);\n\n\t \n\tBUG_ON(mcdi->mode == MCDI_MODE_EVENTS);\n\n\tdel_timer_sync(&mcdi->async_timer);\n\n\t \n\tif (mcdi->state == MCDI_STATE_RUNNING_ASYNC) {\n\t\tefx_mcdi_poll(efx);\n\t\tmcdi->state = MCDI_STATE_QUIESCENT;\n\t}\n\n\t \n\tlist_for_each_entry_safe(async, next, &mcdi->async_list, list) {\n\t\tif (async->complete)\n\t\t\tasync->complete(efx, async->cookie, -ENETDOWN, NULL, 0);\n\t\tlist_del(&async->list);\n\t\tkfree(async);\n\t}\n}\n\nvoid efx_mcdi_mode_event(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi;\n\n\tif (!efx->mcdi)\n\t\treturn;\n\n\tmcdi = efx_mcdi(efx);\n\t \n\tif (mcdi->mode == MCDI_MODE_EVENTS || mcdi->mode == MCDI_MODE_FAIL)\n\t\treturn;\n\n\t \n\tefx_mcdi_acquire_sync(mcdi);\n\tmcdi->mode = MCDI_MODE_EVENTS;\n\tefx_mcdi_release(mcdi);\n}\n\nstatic void efx_mcdi_ev_death(struct efx_nic *efx, int rc)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\n\t \n\tspin_lock(&mcdi->iface_lock);\n\tefx_mcdi_proxy_abort(mcdi);\n\n\tif (efx_mcdi_complete_sync(mcdi)) {\n\t\tif (mcdi->mode == MCDI_MODE_EVENTS) {\n\t\t\tmcdi->resprc = rc;\n\t\t\tmcdi->resp_hdr_len = 0;\n\t\t\tmcdi->resp_data_len = 0;\n\t\t\t++mcdi->credits;\n\t\t}\n\t} else {\n\t\tint count;\n\n\t\t \n\t\tfor (count = 0; count < MCDI_STATUS_DELAY_COUNT; ++count) {\n\t\t\trc = efx_mcdi_poll_reboot(efx);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\tudelay(MCDI_STATUS_DELAY_US);\n\t\t}\n\n\t\t \n\t\tif (!rc && efx->type->mcdi_reboot_detected)\n\t\t\tefx->type->mcdi_reboot_detected(efx);\n\n\t\tmcdi->new_epoch = true;\n\n\t\t \n\t\tefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\n\t}\n\n\tspin_unlock(&mcdi->iface_lock);\n}\n\n \nstatic void efx_mcdi_ev_bist(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\n\tspin_lock(&mcdi->iface_lock);\n\tefx->mc_bist_for_other_fn = true;\n\tefx_mcdi_proxy_abort(mcdi);\n\n\tif (efx_mcdi_complete_sync(mcdi)) {\n\t\tif (mcdi->mode == MCDI_MODE_EVENTS) {\n\t\t\tmcdi->resprc = -EIO;\n\t\t\tmcdi->resp_hdr_len = 0;\n\t\t\tmcdi->resp_data_len = 0;\n\t\t\t++mcdi->credits;\n\t\t}\n\t}\n\tmcdi->new_epoch = true;\n\tefx_schedule_reset(efx, RESET_TYPE_MC_BIST);\n\tspin_unlock(&mcdi->iface_lock);\n}\n\n \nstatic void efx_mcdi_abandon(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\n\tif (xchg(&mcdi->mode, MCDI_MODE_FAIL) == MCDI_MODE_FAIL)\n\t\treturn;  \n\tnetif_dbg(efx, hw, efx->net_dev, \"MCDI is timing out; trying to recover\\n\");\n\tefx_schedule_reset(efx, RESET_TYPE_MCDI_TIMEOUT);\n}\n\nstatic void efx_handle_drain_event(struct efx_nic *efx)\n{\n\tif (atomic_dec_and_test(&efx->active_queues))\n\t\twake_up(&efx->flush_wq);\n\n\tWARN_ON(atomic_read(&efx->active_queues) < 0);\n}\n\n \nvoid efx_mcdi_process_event(struct efx_channel *channel,\n\t\t\t    efx_qword_t *event)\n{\n\tstruct efx_nic *efx = channel->efx;\n\tint code = EFX_QWORD_FIELD(*event, MCDI_EVENT_CODE);\n\tu32 data = EFX_QWORD_FIELD(*event, MCDI_EVENT_DATA);\n\n\tswitch (code) {\n\tcase MCDI_EVENT_CODE_BADSSERT:\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"MC watchdog or assertion failure at 0x%x\\n\", data);\n\t\tefx_mcdi_ev_death(efx, -EINTR);\n\t\tbreak;\n\n\tcase MCDI_EVENT_CODE_PMNOTICE:\n\t\tnetif_info(efx, wol, efx->net_dev, \"MCDI PM event.\\n\");\n\t\tbreak;\n\n\tcase MCDI_EVENT_CODE_CMDDONE:\n\t\tefx_mcdi_ev_cpl(efx,\n\t\t\t\tMCDI_EVENT_FIELD(*event, CMDDONE_SEQ),\n\t\t\t\tMCDI_EVENT_FIELD(*event, CMDDONE_DATALEN),\n\t\t\t\tMCDI_EVENT_FIELD(*event, CMDDONE_ERRNO));\n\t\tbreak;\n\n\tcase MCDI_EVENT_CODE_LINKCHANGE:\n\t\tefx_mcdi_process_link_change(efx, event);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_SENSOREVT:\n\t\tefx_sensor_event(efx, event);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_SCHEDERR:\n\t\tnetif_dbg(efx, hw, efx->net_dev,\n\t\t\t  \"MC Scheduler alert (0x%x)\\n\", data);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_REBOOT:\n\tcase MCDI_EVENT_CODE_MC_REBOOT:\n\t\tnetif_info(efx, hw, efx->net_dev, \"MC Reboot\\n\");\n\t\tefx_mcdi_ev_death(efx, -EIO);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_MC_BIST:\n\t\tnetif_info(efx, hw, efx->net_dev, \"MC entered BIST mode\\n\");\n\t\tefx_mcdi_ev_bist(efx);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_MAC_STATS_DMA:\n\t\t \n\t\tbreak;\n\tcase MCDI_EVENT_CODE_PTP_FAULT:\n\tcase MCDI_EVENT_CODE_PTP_PPS:\n\t\tefx_ptp_event(efx, event);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_PTP_TIME:\n\t\tefx_time_sync_event(channel, event);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_TX_FLUSH:\n\tcase MCDI_EVENT_CODE_RX_FLUSH:\n\t\t \n\t\tBUILD_BUG_ON(MCDI_EVENT_TX_FLUSH_TO_DRIVER_LBN !=\n\t\t\t     MCDI_EVENT_RX_FLUSH_TO_DRIVER_LBN);\n\t\tif (!MCDI_EVENT_FIELD(*event, TX_FLUSH_TO_DRIVER))\n\t\t\tefx_handle_drain_event(efx);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_TX_ERR:\n\tcase MCDI_EVENT_CODE_RX_ERR:\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"%s DMA error (event: \"EFX_QWORD_FMT\")\\n\",\n\t\t\t  code == MCDI_EVENT_CODE_TX_ERR ? \"TX\" : \"RX\",\n\t\t\t  EFX_QWORD_VAL(*event));\n\t\tefx_schedule_reset(efx, RESET_TYPE_DMA_ERROR);\n\t\tbreak;\n\tcase MCDI_EVENT_CODE_PROXY_RESPONSE:\n\t\tefx_mcdi_ev_proxy_response(efx,\n\t\t\t\tMCDI_EVENT_FIELD(*event, PROXY_RESPONSE_HANDLE),\n\t\t\t\tMCDI_EVENT_FIELD(*event, PROXY_RESPONSE_RC));\n\t\tbreak;\n\tdefault:\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"Unknown MCDI event \" EFX_QWORD_FMT \"\\n\",\n\t\t\t  EFX_QWORD_VAL(*event));\n\t}\n}\n\n \n\nvoid efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_VERSION_OUT_LEN);\n\tsize_t outlength;\n\tconst __le16 *ver_words;\n\tsize_t offset;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_VERSION_IN_LEN != 0);\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_VERSION, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlength);\n\tif (rc)\n\t\tgoto fail;\n\tif (outlength < MC_CMD_GET_VERSION_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\tver_words = (__le16 *)MCDI_PTR(outbuf, GET_VERSION_OUT_VERSION);\n\toffset = scnprintf(buf, len, \"%u.%u.%u.%u\",\n\t\t\t   le16_to_cpu(ver_words[0]),\n\t\t\t   le16_to_cpu(ver_words[1]),\n\t\t\t   le16_to_cpu(ver_words[2]),\n\t\t\t   le16_to_cpu(ver_words[3]));\n\n\tif (efx->type->print_additional_fwver)\n\t\toffset += efx->type->print_additional_fwver(efx, buf + offset,\n\t\t\t\t\t\t\t    len - offset);\n\n\t \n\tif (WARN_ON(offset >= len))\n\t\tbuf[0] = 0;\n\n\treturn;\n\nfail:\n\tpci_err(efx->pci_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\tbuf[0] = 0;\n}\n\nstatic int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,\n\t\t\t       bool *was_attached)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_DRV_ATTACH_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_DRV_ATTACH_EXT_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_NEW_STATE,\n\t\t       driver_operating ? 1 : 0);\n\tMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_UPDATE, 1);\n\tMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_FIRMWARE_ID, MC_CMD_FW_LOW_LATENCY);\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_DRV_ATTACH, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\t \n\tif (rc == -EPERM) {\n\t\tpci_dbg(efx->pci_dev,\n\t\t\t\"%s with fw-variant setting failed EPERM, trying without it\\n\",\n\t\t\t__func__);\n\t\tMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_FIRMWARE_ID,\n\t\t\t       MC_CMD_FW_DONT_CARE);\n\t\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_DRV_ATTACH, inbuf,\n\t\t\t\t\tsizeof(inbuf), outbuf, sizeof(outbuf),\n\t\t\t\t\t&outlen);\n\t}\n\tif (rc) {\n\t\tefx_mcdi_display_error(efx, MC_CMD_DRV_ATTACH, sizeof(inbuf),\n\t\t\t\t       outbuf, outlen, rc);\n\t\tgoto fail;\n\t}\n\tif (outlen < MC_CMD_DRV_ATTACH_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\tif (driver_operating) {\n\t\tif (outlen >= MC_CMD_DRV_ATTACH_EXT_OUT_LEN) {\n\t\t\tefx->mcdi->fn_flags =\n\t\t\t\tMCDI_DWORD(outbuf,\n\t\t\t\t\t   DRV_ATTACH_EXT_OUT_FUNC_FLAGS);\n\t\t} else {\n\t\t\t \n\t\t\tefx->mcdi->fn_flags =\n\t\t\t\t1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL |\n\t\t\t\t1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_TRUSTED |\n\t\t\t\t(efx_port_num(efx) == 0) <<\n\t\t\t\tMC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY;\n\t\t}\n\t}\n\n\t \n\n\tif (was_attached != NULL)\n\t\t*was_attached = MCDI_DWORD(outbuf, DRV_ATTACH_OUT_OLD_STATE);\n\treturn 0;\n\nfail:\n\tpci_err(efx->pci_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nint efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address,\n\t\t\t   u16 *fw_subtype_list, u32 *capabilities)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_BOARD_CFG_OUT_LENMAX);\n\tsize_t outlen, i;\n\tint port_num = efx_port_num(efx);\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_IN_LEN != 0);\n\t \n\tBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST & 1);\n\tBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST & 1);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_BOARD_CFG, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (outlen < MC_CMD_GET_BOARD_CFG_OUT_LENMIN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\tif (mac_address)\n\t\tether_addr_copy(mac_address,\n\t\t\t\tport_num ?\n\t\t\t\tMCDI_PTR(outbuf, GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1) :\n\t\t\t\tMCDI_PTR(outbuf, GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0));\n\tif (fw_subtype_list) {\n\t\tfor (i = 0;\n\t\t     i < MCDI_VAR_ARRAY_LEN(outlen,\n\t\t\t\t\t    GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST);\n\t\t     i++)\n\t\t\tfw_subtype_list[i] = MCDI_ARRAY_WORD(\n\t\t\t\toutbuf, GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST, i);\n\t\tfor (; i < MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MAXNUM; i++)\n\t\t\tfw_subtype_list[i] = 0;\n\t}\n\tif (capabilities) {\n\t\tif (port_num)\n\t\t\t*capabilities = MCDI_DWORD(outbuf,\n\t\t\t\t\tGET_BOARD_CFG_OUT_CAPABILITIES_PORT1);\n\t\telse\n\t\t\t*capabilities = MCDI_DWORD(outbuf,\n\t\t\t\t\tGET_BOARD_CFG_OUT_CAPABILITIES_PORT0);\n\t}\n\n\treturn 0;\n\nfail:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d len=%d\\n\",\n\t\t  __func__, rc, (int)outlen);\n\n\treturn rc;\n}\n\nint efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart, u32 dest_evq)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_LOG_CTRL_IN_LEN);\n\tu32 dest = 0;\n\tint rc;\n\n\tif (uart)\n\t\tdest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_UART;\n\tif (evq)\n\t\tdest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ;\n\n\tMCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST, dest);\n\tMCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST_EVQ, dest_evq);\n\n\tBUILD_BUG_ON(MC_CMD_LOG_CTRL_OUT_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_LOG_CTRL, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\treturn rc;\n}\n\nint efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_TYPES_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_NVRAM_TYPES_IN_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TYPES, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\tif (outlen < MC_CMD_NVRAM_TYPES_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\t*nvram_types_out = MCDI_DWORD(outbuf, NVRAM_TYPES_OUT_TYPES);\n\treturn 0;\n\nfail:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\",\n\t\t  __func__, rc);\n\treturn rc;\n}\n\n \nstatic int efx_new_mcdi_nvram_types(struct efx_nic *efx, u32 *number,\n\t\t\t\t    u32 *nvram_types)\n{\n\tefx_dword_t *outbuf = kzalloc(MC_CMD_NVRAM_PARTITIONS_OUT_LENMAX_MCDI2,\n\t\t\t\t      GFP_KERNEL);\n\tsize_t outlen;\n\tint rc;\n\n\tif (!outbuf)\n\t\treturn -ENOMEM;\n\n\tBUILD_BUG_ON(MC_CMD_NVRAM_PARTITIONS_IN_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_PARTITIONS, NULL, 0,\n\t\t\t  outbuf, MC_CMD_NVRAM_PARTITIONS_OUT_LENMAX_MCDI2, &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\t*number = MCDI_DWORD(outbuf, NVRAM_PARTITIONS_OUT_NUM_PARTITIONS);\n\n\tmemcpy(nvram_types, MCDI_PTR(outbuf, NVRAM_PARTITIONS_OUT_TYPE_ID),\n\t       *number * sizeof(u32));\n\nfail:\n\tkfree(outbuf);\n\treturn rc;\n}\n\nint efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type,\n\t\t\tsize_t *size_out, size_t *erase_size_out,\n\t\t\tbool *protected_out)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_INFO_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_INFO_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_INFO_IN_TYPE, type);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_INFO, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\tif (outlen < MC_CMD_NVRAM_INFO_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\t*size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_SIZE);\n\t*erase_size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_ERASESIZE);\n\t*protected_out = !!(MCDI_DWORD(outbuf, NVRAM_INFO_OUT_FLAGS) &\n\t\t\t\t(1 << MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN));\n\treturn 0;\n\nfail:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int efx_mcdi_nvram_test(struct efx_nic *efx, unsigned int type)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_TEST_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_TEST_OUT_LEN);\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_TEST_IN_TYPE, type);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TEST, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (MCDI_DWORD(outbuf, NVRAM_TEST_OUT_RESULT)) {\n\tcase MC_CMD_NVRAM_TEST_PASS:\n\tcase MC_CMD_NVRAM_TEST_NOTSUPP:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \nint efx_new_mcdi_nvram_test_all(struct efx_nic *efx)\n{\n\tu32 *nvram_types = kzalloc(MC_CMD_NVRAM_PARTITIONS_OUT_LENMAX_MCDI2,\n\t\t\t\t   GFP_KERNEL);\n\tunsigned int number;\n\tint rc, i;\n\n\tif (!nvram_types)\n\t\treturn -ENOMEM;\n\n\trc = efx_new_mcdi_nvram_types(efx, &number, nvram_types);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\trc = -EAGAIN;\n\n\tfor (i = 0; i < number; i++) {\n\t\tif (nvram_types[i] == NVRAM_PARTITION_TYPE_PARTITION_MAP ||\n\t\t    nvram_types[i] == NVRAM_PARTITION_TYPE_DYNAMIC_CONFIG)\n\t\t\tcontinue;\n\n\t\trc = efx_mcdi_nvram_test(efx, nvram_types[i]);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\nfail:\n\tkfree(nvram_types);\n\treturn rc;\n}\n\nint efx_mcdi_nvram_test_all(struct efx_nic *efx)\n{\n\tu32 nvram_types;\n\tunsigned int type;\n\tint rc;\n\n\trc = efx_mcdi_nvram_types(efx, &nvram_types);\n\tif (rc)\n\t\tgoto fail1;\n\n\ttype = 0;\n\twhile (nvram_types != 0) {\n\t\tif (nvram_types & 1) {\n\t\t\trc = efx_mcdi_nvram_test(efx, type);\n\t\t\tif (rc)\n\t\t\t\tgoto fail2;\n\t\t}\n\t\ttype++;\n\t\tnvram_types >>= 1;\n\t}\n\n\treturn 0;\n\nfail2:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed type=%u\\n\",\n\t\t  __func__, type);\nfail1:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic int efx_mcdi_read_assertion(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_ASSERTS_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_ASSERTS_OUT_LEN);\n\tunsigned int flags, index;\n\tconst char *reason;\n\tsize_t outlen;\n\tint retry;\n\tint rc;\n\n\t \n\tretry = 2;\n\tdo {\n\t\tMCDI_SET_DWORD(inbuf, GET_ASSERTS_IN_CLEAR, 1);\n\t\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_GET_ASSERTS,\n\t\t\t\t\tinbuf, MC_CMD_GET_ASSERTS_IN_LEN,\n\t\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\t\tif (rc == -EPERM)\n\t\t\treturn 0;\n\t} while ((rc == -EINTR || rc == -EIO) && retry-- > 0);\n\n\tif (rc) {\n\t\tefx_mcdi_display_error(efx, MC_CMD_GET_ASSERTS,\n\t\t\t\t       MC_CMD_GET_ASSERTS_IN_LEN, outbuf,\n\t\t\t\t       outlen, rc);\n\t\treturn rc;\n\t}\n\tif (outlen < MC_CMD_GET_ASSERTS_OUT_LEN)\n\t\treturn -EIO;\n\n\t \n\tflags = MCDI_DWORD(outbuf, GET_ASSERTS_OUT_GLOBAL_FLAGS);\n\tif (flags == MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS)\n\t\treturn 0;\n\n\treason = (flags == MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL)\n\t\t? \"system-level assertion\"\n\t\t: (flags == MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL)\n\t\t? \"thread-level assertion\"\n\t\t: (flags == MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED)\n\t\t? \"watchdog reset\"\n\t\t: \"unknown assertion\";\n\tnetif_err(efx, hw, efx->net_dev,\n\t\t  \"MCPU %s at PC = 0x%.8x in thread 0x%.8x\\n\", reason,\n\t\t  MCDI_DWORD(outbuf, GET_ASSERTS_OUT_SAVED_PC_OFFS),\n\t\t  MCDI_DWORD(outbuf, GET_ASSERTS_OUT_THREAD_OFFS));\n\n\t \n\tfor (index = 0;\n\t     index < MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_NUM;\n\t     index++)\n\t\tnetif_err(efx, hw, efx->net_dev, \"R%.2d (?): 0x%.8x\\n\",\n\t\t\t  1 + index,\n\t\t\t  MCDI_ARRAY_DWORD(outbuf, GET_ASSERTS_OUT_GP_REGS_OFFS,\n\t\t\t\t\t   index));\n\n\treturn 1;\n}\n\nstatic int efx_mcdi_exit_assertion(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_REBOOT_IN_LEN);\n\tint rc;\n\n\t \n\tBUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);\n\tMCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS,\n\t\t       MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION);\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_REBOOT, inbuf, MC_CMD_REBOOT_IN_LEN,\n\t\t\t\tNULL, 0, NULL);\n\tif (rc == -EIO)\n\t\trc = 0;\n\tif (rc)\n\t\tefx_mcdi_display_error(efx, MC_CMD_REBOOT, MC_CMD_REBOOT_IN_LEN,\n\t\t\t\t       NULL, 0, rc);\n\treturn rc;\n}\n\nint efx_mcdi_handle_assertion(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_mcdi_read_assertion(efx);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\treturn efx_mcdi_exit_assertion(efx);\n}\n\nint efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_ID_LED_IN_LEN);\n\n\tBUILD_BUG_ON(EFX_LED_OFF != MC_CMD_LED_OFF);\n\tBUILD_BUG_ON(EFX_LED_ON != MC_CMD_LED_ON);\n\tBUILD_BUG_ON(EFX_LED_DEFAULT != MC_CMD_LED_DEFAULT);\n\n\tBUILD_BUG_ON(MC_CMD_SET_ID_LED_OUT_LEN != 0);\n\n\tMCDI_SET_DWORD(inbuf, SET_ID_LED_IN_STATE, mode);\n\n\treturn efx_mcdi_rpc(efx, MC_CMD_SET_ID_LED, inbuf, sizeof(inbuf), NULL, 0, NULL);\n}\n\nstatic int efx_mcdi_reset_func(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_ENTITY_RESET_IN_LEN);\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_ENTITY_RESET_OUT_LEN != 0);\n\tMCDI_POPULATE_DWORD_1(inbuf, ENTITY_RESET_IN_FLAG,\n\t\t\t      ENTITY_RESET_IN_FUNCTION_RESOURCE_RESET, 1);\n\trc = efx_mcdi_rpc(efx, MC_CMD_ENTITY_RESET, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\treturn rc;\n}\n\nstatic int efx_mcdi_reset_mc(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_REBOOT_IN_LEN);\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);\n\tMCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS, 0);\n\trc = efx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\t \n\tif (rc == -EIO)\n\t\treturn 0;\n\tif (rc == 0)\n\t\trc = -EIO;\n\treturn rc;\n}\n\nenum reset_type efx_mcdi_map_reset_reason(enum reset_type reason)\n{\n\treturn RESET_TYPE_RECOVER_OR_ALL;\n}\n\nint efx_mcdi_reset(struct efx_nic *efx, enum reset_type method)\n{\n\tint rc;\n\n\t \n\tif (method == RESET_TYPE_MCDI_TIMEOUT) {\n\t\trc = pci_reset_function(efx->pci_dev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t \n\t\tif (efx->mcdi) {\n\t\t\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\t\t\tmcdi->mode = MCDI_MODE_POLL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\trc = efx_mcdi_handle_assertion(efx);\n\tif (rc)\n\t\treturn rc;\n\n\tif (method == RESET_TYPE_DATAPATH)\n\t\treturn 0;\n\telse if (method == RESET_TYPE_WORLD)\n\t\treturn efx_mcdi_reset_mc(efx);\n\telse\n\t\treturn efx_mcdi_reset_func(efx);\n}\n\nstatic int efx_mcdi_wol_filter_set(struct efx_nic *efx, u32 type,\n\t\t\t\t   const u8 *mac, int *id_out)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_WOL_FILTER_SET_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_WOL_FILTER_SET_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_WOL_TYPE, type);\n\tMCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_FILTER_MODE,\n\t\t       MC_CMD_FILTER_MODE_SIMPLE);\n\tether_addr_copy(MCDI_PTR(inbuf, WOL_FILTER_SET_IN_MAGIC_MAC), mac);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_SET, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (outlen < MC_CMD_WOL_FILTER_SET_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\t*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_SET_OUT_FILTER_ID);\n\n\treturn 0;\n\nfail:\n\t*id_out = -1;\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n\n}\n\n\nint\nefx_mcdi_wol_filter_set_magic(struct efx_nic *efx,  const u8 *mac, int *id_out)\n{\n\treturn efx_mcdi_wol_filter_set(efx, MC_CMD_WOL_TYPE_MAGIC, mac, id_out);\n}\n\n\nint efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_WOL_FILTER_GET_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_GET, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (outlen < MC_CMD_WOL_FILTER_GET_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\t*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_GET_OUT_FILTER_ID);\n\n\treturn 0;\n\nfail:\n\t*id_out = -1;\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n\nint efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_WOL_FILTER_REMOVE_IN_LEN);\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, WOL_FILTER_REMOVE_IN_FILTER_ID, (u32)id);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_REMOVE, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\treturn rc;\n}\n\nint efx_mcdi_flush_rxqs(struct efx_nic *efx)\n{\n\tstruct efx_channel *channel;\n\tstruct efx_rx_queue *rx_queue;\n\tMCDI_DECLARE_BUF(inbuf,\n\t\t\t MC_CMD_FLUSH_RX_QUEUES_IN_LEN(EFX_MAX_CHANNELS));\n\tint rc, count;\n\n\tBUILD_BUG_ON(EFX_MAX_CHANNELS >\n\t\t     MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_MAXNUM);\n\n\tcount = 0;\n\tefx_for_each_channel(channel, efx) {\n\t\tefx_for_each_channel_rx_queue(rx_queue, channel) {\n\t\t\tif (rx_queue->flush_pending) {\n\t\t\t\trx_queue->flush_pending = false;\n\t\t\t\tatomic_dec(&efx->rxq_flush_pending);\n\t\t\t\tMCDI_SET_ARRAY_DWORD(\n\t\t\t\t\tinbuf, FLUSH_RX_QUEUES_IN_QID_OFST,\n\t\t\t\t\tcount, efx_rx_queue_index(rx_queue));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_FLUSH_RX_QUEUES, inbuf,\n\t\t\t  MC_CMD_FLUSH_RX_QUEUES_IN_LEN(count), NULL, 0, NULL);\n\tWARN_ON(rc < 0);\n\n\treturn rc;\n}\n\nint efx_mcdi_wol_filter_reset(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_RESET, NULL, 0, NULL, 0, NULL);\n\treturn rc;\n}\n\nint efx_mcdi_set_workaround(struct efx_nic *efx, u32 type, bool enabled,\n\t\t\t    unsigned int *flags)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_WORKAROUND_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_WORKAROUND_EXT_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_WORKAROUND_OUT_LEN != 0);\n\tMCDI_SET_DWORD(inbuf, WORKAROUND_IN_TYPE, type);\n\tMCDI_SET_DWORD(inbuf, WORKAROUND_IN_ENABLED, enabled);\n\trc = efx_mcdi_rpc(efx, MC_CMD_WORKAROUND, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!flags)\n\t\treturn 0;\n\n\tif (outlen >= MC_CMD_WORKAROUND_EXT_OUT_LEN)\n\t\t*flags = MCDI_DWORD(outbuf, WORKAROUND_EXT_OUT_FLAGS);\n\telse\n\t\t*flags = 0;\n\n\treturn 0;\n}\n\nint efx_mcdi_get_workarounds(struct efx_nic *efx, unsigned int *impl_out,\n\t\t\t     unsigned int *enabled_out)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_WORKAROUNDS_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_WORKAROUNDS, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (outlen < MC_CMD_GET_WORKAROUNDS_OUT_LEN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\tif (impl_out)\n\t\t*impl_out = MCDI_DWORD(outbuf, GET_WORKAROUNDS_OUT_IMPLEMENTED);\n\n\tif (enabled_out)\n\t\t*enabled_out = MCDI_DWORD(outbuf, GET_WORKAROUNDS_OUT_ENABLED);\n\n\treturn 0;\n\nfail:\n\t \n\tnetif_cond_dbg(efx, hw, efx->net_dev, rc == -ENOSYS, err,\n\t\t       \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nint efx_mcdi_get_privilege_mask(struct efx_nic *efx, u32 *mask)\n{\n\tMCDI_DECLARE_BUF(fi_outbuf, MC_CMD_GET_FUNCTION_INFO_OUT_LEN);\n\tMCDI_DECLARE_BUF(pm_inbuf, MC_CMD_PRIVILEGE_MASK_IN_LEN);\n\tMCDI_DECLARE_BUF(pm_outbuf, MC_CMD_PRIVILEGE_MASK_OUT_LEN);\n\tsize_t outlen;\n\tu16 pf, vf;\n\tint rc;\n\n\tif (!efx || !mask)\n\t\treturn -EINVAL;\n\n\t \n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_GET_FUNCTION_INFO, NULL, 0,\n\t\t\t\tfi_outbuf, MC_CMD_GET_FUNCTION_INFO_OUT_LEN,\n\t\t\t\t&outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\tif (outlen < MC_CMD_GET_FUNCTION_INFO_OUT_LEN)\n\t\treturn -EIO;\n\n\tpf = MCDI_DWORD(fi_outbuf, GET_FUNCTION_INFO_OUT_PF);\n\tvf = MCDI_DWORD(fi_outbuf, GET_FUNCTION_INFO_OUT_VF);\n\n\tMCDI_POPULATE_DWORD_2(pm_inbuf, PRIVILEGE_MASK_IN_FUNCTION,\n\t\t\t      PRIVILEGE_MASK_IN_FUNCTION_PF, pf,\n\t\t\t      PRIVILEGE_MASK_IN_FUNCTION_VF, vf);\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_PRIVILEGE_MASK,\n\t\t\t\tpm_inbuf, sizeof(pm_inbuf),\n\t\t\t\tpm_outbuf, sizeof(pm_outbuf), &outlen);\n\n\tif (rc != 0)\n\t\treturn rc;\n\tif (outlen < MC_CMD_PRIVILEGE_MASK_OUT_LEN)\n\t\treturn -EIO;\n\n\t*mask = MCDI_DWORD(pm_outbuf, PRIVILEGE_MASK_OUT_OLD_MASK);\n\n\treturn 0;\n}\n\nint efx_mcdi_nvram_metadata(struct efx_nic *efx, unsigned int type,\n\t\t\t    u32 *subtype, u16 version[4], char *desc,\n\t\t\t    size_t descsize)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_METADATA_IN_LEN);\n\tefx_dword_t *outbuf;\n\tsize_t outlen;\n\tu32 flags;\n\tint rc;\n\n\toutbuf = kzalloc(MC_CMD_NVRAM_METADATA_OUT_LENMAX_MCDI2, GFP_KERNEL);\n\tif (!outbuf)\n\t\treturn -ENOMEM;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_METADATA_IN_TYPE, type);\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_NVRAM_METADATA, inbuf,\n\t\t\t\tsizeof(inbuf), outbuf,\n\t\t\t\tMC_CMD_NVRAM_METADATA_OUT_LENMAX_MCDI2,\n\t\t\t\t&outlen);\n\tif (rc)\n\t\tgoto out_free;\n\tif (outlen < MC_CMD_NVRAM_METADATA_OUT_LENMIN) {\n\t\trc = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tflags = MCDI_DWORD(outbuf, NVRAM_METADATA_OUT_FLAGS);\n\n\tif (desc && descsize > 0) {\n\t\tif (flags & BIT(MC_CMD_NVRAM_METADATA_OUT_DESCRIPTION_VALID_LBN)) {\n\t\t\tif (descsize <=\n\t\t\t    MC_CMD_NVRAM_METADATA_OUT_DESCRIPTION_NUM(outlen)) {\n\t\t\t\trc = -E2BIG;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tstrncpy(desc,\n\t\t\t\tMCDI_PTR(outbuf, NVRAM_METADATA_OUT_DESCRIPTION),\n\t\t\t\tMC_CMD_NVRAM_METADATA_OUT_DESCRIPTION_NUM(outlen));\n\t\t\tdesc[MC_CMD_NVRAM_METADATA_OUT_DESCRIPTION_NUM(outlen)] = '\\0';\n\t\t} else {\n\t\t\tdesc[0] = '\\0';\n\t\t}\n\t}\n\n\tif (subtype) {\n\t\tif (flags & BIT(MC_CMD_NVRAM_METADATA_OUT_SUBTYPE_VALID_LBN))\n\t\t\t*subtype = MCDI_DWORD(outbuf, NVRAM_METADATA_OUT_SUBTYPE);\n\t\telse\n\t\t\t*subtype = 0;\n\t}\n\n\tif (version) {\n\t\tif (flags & BIT(MC_CMD_NVRAM_METADATA_OUT_VERSION_VALID_LBN)) {\n\t\t\tversion[0] = MCDI_WORD(outbuf, NVRAM_METADATA_OUT_VERSION_W);\n\t\t\tversion[1] = MCDI_WORD(outbuf, NVRAM_METADATA_OUT_VERSION_X);\n\t\t\tversion[2] = MCDI_WORD(outbuf, NVRAM_METADATA_OUT_VERSION_Y);\n\t\t\tversion[3] = MCDI_WORD(outbuf, NVRAM_METADATA_OUT_VERSION_Z);\n\t\t} else {\n\t\t\tversion[0] = 0;\n\t\t\tversion[1] = 0;\n\t\t\tversion[2] = 0;\n\t\t\tversion[3] = 0;\n\t\t}\n\t}\n\nout_free:\n\tkfree(outbuf);\n\treturn rc;\n}\n\n#ifdef CONFIG_SFC_MTD\n\n#define EFX_MCDI_NVRAM_LEN_MAX 128\n\nstatic int efx_mcdi_nvram_update_start(struct efx_nic *efx, unsigned int type)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_UPDATE_START_V2_IN_LEN);\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_UPDATE_START_IN_TYPE, type);\n\tMCDI_POPULATE_DWORD_1(inbuf, NVRAM_UPDATE_START_V2_IN_FLAGS,\n\t\t\t      NVRAM_UPDATE_START_V2_IN_FLAG_REPORT_VERIFY_RESULT,\n\t\t\t      1);\n\n\tBUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_START_OUT_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_START, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\n\treturn rc;\n}\n\nstatic int efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type,\n\t\t\t       loff_t offset, u8 *buffer, size_t length)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_READ_IN_V2_LEN);\n\tMCDI_DECLARE_BUF(outbuf,\n\t\t\t MC_CMD_NVRAM_READ_OUT_LEN(EFX_MCDI_NVRAM_LEN_MAX));\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_TYPE, type);\n\tMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_OFFSET, offset);\n\tMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_LENGTH, length);\n\tMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_V2_MODE,\n\t\t       MC_CMD_NVRAM_READ_IN_V2_DEFAULT);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_READ, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(buffer, MCDI_PTR(outbuf, NVRAM_READ_OUT_READ_BUFFER), length);\n\treturn 0;\n}\n\nstatic int efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type,\n\t\t\t\tloff_t offset, const u8 *buffer, size_t length)\n{\n\tMCDI_DECLARE_BUF(inbuf,\n\t\t\t MC_CMD_NVRAM_WRITE_IN_LEN(EFX_MCDI_NVRAM_LEN_MAX));\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_TYPE, type);\n\tMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_OFFSET, offset);\n\tMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_LENGTH, length);\n\tmemcpy(MCDI_PTR(inbuf, NVRAM_WRITE_IN_WRITE_BUFFER), buffer, length);\n\n\tBUILD_BUG_ON(MC_CMD_NVRAM_WRITE_OUT_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_WRITE, inbuf,\n\t\t\t  ALIGN(MC_CMD_NVRAM_WRITE_IN_LEN(length), 4),\n\t\t\t  NULL, 0, NULL);\n\treturn rc;\n}\n\nstatic int efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type,\n\t\t\t\tloff_t offset, size_t length)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_ERASE_IN_LEN);\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_TYPE, type);\n\tMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_OFFSET, offset);\n\tMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_LENGTH, length);\n\n\tBUILD_BUG_ON(MC_CMD_NVRAM_ERASE_OUT_LEN != 0);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_ERASE, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\treturn rc;\n}\n\nstatic int efx_mcdi_nvram_update_finish(struct efx_nic *efx, unsigned int type)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_UPDATE_FINISH_V2_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_UPDATE_FINISH_V2_OUT_LEN);\n\tsize_t outlen;\n\tint rc, rc2;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_UPDATE_FINISH_IN_TYPE, type);\n\t \n\tMCDI_POPULATE_DWORD_1(inbuf, NVRAM_UPDATE_FINISH_V2_IN_FLAGS,\n\t\t\t      NVRAM_UPDATE_FINISH_V2_IN_FLAG_REPORT_VERIFY_RESULT,\n\t\t\t      1);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_FINISH, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (!rc && outlen >= MC_CMD_NVRAM_UPDATE_FINISH_V2_OUT_LEN) {\n\t\trc2 = MCDI_DWORD(outbuf, NVRAM_UPDATE_FINISH_V2_OUT_RESULT_CODE);\n\t\tif (rc2 != MC_CMD_NVRAM_VERIFY_RC_SUCCESS)\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"NVRAM update failed verification with code 0x%x\\n\",\n\t\t\t\t  rc2);\n\t\tswitch (rc2) {\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_SUCCESS:\n\t\t\tbreak;\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_CMS_CHECK_FAILED:\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_MESSAGE_DIGEST_CHECK_FAILED:\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_SIGNATURE_CHECK_FAILED:\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_TRUSTED_APPROVERS_CHECK_FAILED:\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_SIGNATURE_CHAIN_CHECK_FAILED:\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_INVALID_CMS_FORMAT:\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_BAD_MESSAGE_DIGEST:\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_NO_VALID_SIGNATURES:\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_NO_TRUSTED_APPROVERS:\n\t\tcase MC_CMD_NVRAM_VERIFY_RC_NO_SIGNATURE_MATCH:\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"Unknown response to NVRAM_UPDATE_FINISH\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint efx_mcdi_mtd_read(struct mtd_info *mtd, loff_t start,\n\t\t      size_t len, size_t *retlen, u8 *buffer)\n{\n\tstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\n\tstruct efx_nic *efx = mtd->priv;\n\tloff_t offset = start;\n\tloff_t end = min_t(loff_t, start + len, mtd->size);\n\tsize_t chunk;\n\tint rc = 0;\n\n\twhile (offset < end) {\n\t\tchunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);\n\t\trc = efx_mcdi_nvram_read(efx, part->nvram_type, offset,\n\t\t\t\t\t buffer, chunk);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\toffset += chunk;\n\t\tbuffer += chunk;\n\t}\nout:\n\t*retlen = offset - start;\n\treturn rc;\n}\n\nint efx_mcdi_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)\n{\n\tstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\n\tstruct efx_nic *efx = mtd->priv;\n\tloff_t offset = start & ~((loff_t)(mtd->erasesize - 1));\n\tloff_t end = min_t(loff_t, start + len, mtd->size);\n\tsize_t chunk = part->common.mtd.erasesize;\n\tint rc = 0;\n\n\tif (!part->updating) {\n\t\trc = efx_mcdi_nvram_update_start(efx, part->nvram_type);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tpart->updating = true;\n\t}\n\n\t \n\twhile (offset < end) {\n\t\trc = efx_mcdi_nvram_erase(efx, part->nvram_type, offset,\n\t\t\t\t\t  chunk);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\toffset += chunk;\n\t}\nout:\n\treturn rc;\n}\n\nint efx_mcdi_mtd_write(struct mtd_info *mtd, loff_t start,\n\t\t       size_t len, size_t *retlen, const u8 *buffer)\n{\n\tstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\n\tstruct efx_nic *efx = mtd->priv;\n\tloff_t offset = start;\n\tloff_t end = min_t(loff_t, start + len, mtd->size);\n\tsize_t chunk;\n\tint rc = 0;\n\n\tif (!part->updating) {\n\t\trc = efx_mcdi_nvram_update_start(efx, part->nvram_type);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tpart->updating = true;\n\t}\n\n\twhile (offset < end) {\n\t\tchunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);\n\t\trc = efx_mcdi_nvram_write(efx, part->nvram_type, offset,\n\t\t\t\t\t  buffer, chunk);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\toffset += chunk;\n\t\tbuffer += chunk;\n\t}\nout:\n\t*retlen = offset - start;\n\treturn rc;\n}\n\nint efx_mcdi_mtd_sync(struct mtd_info *mtd)\n{\n\tstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\n\tstruct efx_nic *efx = mtd->priv;\n\tint rc = 0;\n\n\tif (part->updating) {\n\t\tpart->updating = false;\n\t\trc = efx_mcdi_nvram_update_finish(efx, part->nvram_type);\n\t}\n\n\treturn rc;\n}\n\nvoid efx_mcdi_mtd_rename(struct efx_mtd_partition *part)\n{\n\tstruct efx_mcdi_mtd_partition *mcdi_part =\n\t\tcontainer_of(part, struct efx_mcdi_mtd_partition, common);\n\tstruct efx_nic *efx = part->mtd.priv;\n\n\tsnprintf(part->name, sizeof(part->name), \"%s %s:%02x\",\n\t\t efx->name, part->type_name, mcdi_part->fw_subtype);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}