{
  "module_name": "mcdi_functions.c",
  "hash_id": "da0c01d75b137dabeb9c1470c126c204f08cd1dbfd115361ed5098d02adf83b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/mcdi_functions.c",
  "human_readable_source": "\n \n\n#include \"net_driver.h\"\n#include \"efx.h\"\n#include \"nic.h\"\n#include \"mcdi_functions.h\"\n#include \"mcdi.h\"\n#include \"mcdi_pcol.h\"\n\nint efx_mcdi_free_vis(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tsize_t outlen;\n\tint rc = efx_mcdi_rpc_quiet(efx, MC_CMD_FREE_VIS, NULL, 0,\n\t\t\t\t    outbuf, sizeof(outbuf), &outlen);\n\n\t \n\tif (rc == -EALREADY)\n\t\trc = 0;\n\tif (rc)\n\t\tefx_mcdi_display_error(efx, MC_CMD_FREE_VIS, 0, outbuf, outlen,\n\t\t\t\t       rc);\n\treturn rc;\n}\n\nint efx_mcdi_alloc_vis(struct efx_nic *efx, unsigned int min_vis,\n\t\t       unsigned int max_vis, unsigned int *vi_base,\n\t\t       unsigned int *allocated_vis)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_ALLOC_VIS_OUT_LEN);\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_ALLOC_VIS_IN_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, ALLOC_VIS_IN_MIN_VI_COUNT, min_vis);\n\tMCDI_SET_DWORD(inbuf, ALLOC_VIS_IN_MAX_VI_COUNT, max_vis);\n\trc = efx_mcdi_rpc(efx, MC_CMD_ALLOC_VIS, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (outlen < MC_CMD_ALLOC_VIS_OUT_LEN)\n\t\treturn -EIO;\n\n\tnetif_dbg(efx, drv, efx->net_dev, \"base VI is A0x%03x\\n\",\n\t\t  MCDI_DWORD(outbuf, ALLOC_VIS_OUT_VI_BASE));\n\n\tif (vi_base)\n\t\t*vi_base = MCDI_DWORD(outbuf, ALLOC_VIS_OUT_VI_BASE);\n\tif (allocated_vis)\n\t\t*allocated_vis = MCDI_DWORD(outbuf, ALLOC_VIS_OUT_VI_COUNT);\n\treturn 0;\n}\n\nint efx_mcdi_ev_probe(struct efx_channel *channel)\n{\n\treturn efx_nic_alloc_buffer(channel->efx, &channel->eventq,\n\t\t\t\t    (channel->eventq_mask + 1) *\n\t\t\t\t    sizeof(efx_qword_t),\n\t\t\t\t    GFP_KERNEL);\n}\n\nint efx_mcdi_ev_init(struct efx_channel *channel, bool v1_cut_thru, bool v2)\n{\n\tMCDI_DECLARE_BUF(inbuf,\n\t\t\t MC_CMD_INIT_EVQ_V2_IN_LEN(EFX_MAX_EVQ_SIZE * 8 /\n\t\t\t\t\t\t   EFX_BUF_SIZE));\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_INIT_EVQ_V2_OUT_LEN);\n\tsize_t entries = channel->eventq.len / EFX_BUF_SIZE;\n\tstruct efx_nic *efx = channel->efx;\n\tsize_t inlen, outlen;\n\tdma_addr_t dma_addr;\n\tint rc, i;\n\n\t \n\tmemset(channel->eventq.addr, 0xff, channel->eventq.len);\n\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_SIZE, channel->eventq_mask + 1);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_INSTANCE, channel->channel);\n\t \n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_IRQ_NUM, channel->channel);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_TMR_MODE,\n\t\t       MC_CMD_INIT_EVQ_IN_TMR_MODE_DIS);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_TMR_LOAD, 0);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_TMR_RELOAD, 0);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_COUNT_MODE,\n\t\t       MC_CMD_INIT_EVQ_IN_COUNT_MODE_DIS);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_COUNT_THRSHLD, 0);\n\n\tif (v2) {\n\t\t \n\t\tMCDI_POPULATE_DWORD_2(inbuf, INIT_EVQ_V2_IN_FLAGS,\n\t\t\t\t      INIT_EVQ_V2_IN_FLAG_INTERRUPTING, 1,\n\t\t\t\t      INIT_EVQ_V2_IN_FLAG_TYPE,\n\t\t\t\t      MC_CMD_INIT_EVQ_V2_IN_FLAG_TYPE_AUTO);\n\t} else {\n\t\tMCDI_POPULATE_DWORD_4(inbuf, INIT_EVQ_IN_FLAGS,\n\t\t\t\t      INIT_EVQ_IN_FLAG_INTERRUPTING, 1,\n\t\t\t\t      INIT_EVQ_IN_FLAG_RX_MERGE, 1,\n\t\t\t\t      INIT_EVQ_IN_FLAG_TX_MERGE, 1,\n\t\t\t\t      INIT_EVQ_IN_FLAG_CUT_THRU, v1_cut_thru);\n\t}\n\n\tdma_addr = channel->eventq.dma_addr;\n\tfor (i = 0; i < entries; ++i) {\n\t\tMCDI_SET_ARRAY_QWORD(inbuf, INIT_EVQ_IN_DMA_ADDR, i, dma_addr);\n\t\tdma_addr += EFX_BUF_SIZE;\n\t}\n\n\tinlen = MC_CMD_INIT_EVQ_IN_LEN(entries);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_INIT_EVQ, inbuf, inlen,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\n\tif (outlen >= MC_CMD_INIT_EVQ_V2_OUT_LEN)\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Channel %d using event queue flags %08x\\n\",\n\t\t\t  channel->channel,\n\t\t\t  MCDI_DWORD(outbuf, INIT_EVQ_V2_OUT_FLAGS));\n\n\treturn rc;\n}\n\nvoid efx_mcdi_ev_remove(struct efx_channel *channel)\n{\n\tefx_nic_free_buffer(channel->efx, &channel->eventq);\n}\n\nvoid efx_mcdi_ev_fini(struct efx_channel *channel)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FINI_EVQ_IN_LEN);\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tstruct efx_nic *efx = channel->efx;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, FINI_EVQ_IN_INSTANCE, channel->channel);\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_FINI_EVQ, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\n\tif (rc && rc != -EALREADY)\n\t\tgoto fail;\n\n\treturn;\n\nfail:\n\tefx_mcdi_display_error(efx, MC_CMD_FINI_EVQ, MC_CMD_FINI_EVQ_IN_LEN,\n\t\t\t       outbuf, outlen, rc);\n}\n\nint efx_mcdi_tx_init(struct efx_tx_queue *tx_queue)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_INIT_TXQ_IN_LEN(EFX_MAX_DMAQ_SIZE * 8 /\n\t\t\t\t\t\t       EFX_BUF_SIZE));\n\tbool csum_offload = tx_queue->type & EFX_TXQ_TYPE_OUTER_CSUM;\n\tbool inner_csum = tx_queue->type & EFX_TXQ_TYPE_INNER_CSUM;\n\tsize_t entries = tx_queue->txd.len / EFX_BUF_SIZE;\n\tstruct efx_channel *channel = tx_queue->channel;\n\tstruct efx_nic *efx = tx_queue->efx;\n\tdma_addr_t dma_addr;\n\tsize_t inlen;\n\tint rc, i;\n\n\tBUILD_BUG_ON(MC_CMD_INIT_TXQ_OUT_LEN != 0);\n\n\tMCDI_SET_DWORD(inbuf, INIT_TXQ_IN_SIZE, tx_queue->ptr_mask + 1);\n\tMCDI_SET_DWORD(inbuf, INIT_TXQ_IN_TARGET_EVQ, channel->channel);\n\tMCDI_SET_DWORD(inbuf, INIT_TXQ_IN_LABEL, tx_queue->label);\n\tMCDI_SET_DWORD(inbuf, INIT_TXQ_IN_INSTANCE, tx_queue->queue);\n\tMCDI_SET_DWORD(inbuf, INIT_TXQ_IN_OWNER_ID, 0);\n\tMCDI_SET_DWORD(inbuf, INIT_TXQ_IN_PORT_ID, efx->vport_id);\n\n\tdma_addr = tx_queue->txd.dma_addr;\n\n\tnetif_dbg(efx, hw, efx->net_dev, \"pushing TXQ %d. %zu entries (%llx)\\n\",\n\t\t  tx_queue->queue, entries, (u64)dma_addr);\n\n\tfor (i = 0; i < entries; ++i) {\n\t\tMCDI_SET_ARRAY_QWORD(inbuf, INIT_TXQ_IN_DMA_ADDR, i, dma_addr);\n\t\tdma_addr += EFX_BUF_SIZE;\n\t}\n\n\tinlen = MC_CMD_INIT_TXQ_IN_LEN(entries);\n\n\tdo {\n\t\tbool tso_v2 = tx_queue->tso_version == 2;\n\n\t\t \n\t\tMCDI_POPULATE_DWORD_6(inbuf, INIT_TXQ_IN_FLAGS,\n\t\t\t\t \n\t\t\t\tINIT_TXQ_EXT_IN_FLAG_TSOV2_EN, tso_v2,\n\t\t\t\tINIT_TXQ_IN_FLAG_IP_CSUM_DIS, !(csum_offload && tso_v2),\n\t\t\t\tINIT_TXQ_IN_FLAG_TCP_CSUM_DIS, !csum_offload,\n\t\t\t\tINIT_TXQ_EXT_IN_FLAG_TIMESTAMP, tx_queue->timestamping,\n\t\t\t\tINIT_TXQ_IN_FLAG_INNER_IP_CSUM_EN, inner_csum && !tso_v2,\n\t\t\t\tINIT_TXQ_IN_FLAG_INNER_TCP_CSUM_EN, inner_csum);\n\n\t\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_INIT_TXQ, inbuf, inlen,\n\t\t\t\t\tNULL, 0, NULL);\n\t\tif (rc == -ENOSPC && tso_v2) {\n\t\t\t \n\t\t\ttx_queue->tso_version = 0;\n\t\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t\t   \"TSOv2 context not available to segment in \"\n\t\t\t\t   \"hardware. TCP performance may be reduced.\\n\"\n\t\t\t\t   );\n\t\t} else if (rc) {\n\t\t\tefx_mcdi_display_error(efx, MC_CMD_INIT_TXQ,\n\t\t\t\t\t       MC_CMD_INIT_TXQ_EXT_IN_LEN,\n\t\t\t\t\t       NULL, 0, rc);\n\t\t\tgoto fail;\n\t\t}\n\t} while (rc);\n\n\treturn 0;\n\nfail:\n\treturn rc;\n}\n\nvoid efx_mcdi_tx_remove(struct efx_tx_queue *tx_queue)\n{\n\tefx_nic_free_buffer(tx_queue->efx, &tx_queue->txd);\n}\n\nvoid efx_mcdi_tx_fini(struct efx_tx_queue *tx_queue)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FINI_TXQ_IN_LEN);\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tstruct efx_nic *efx = tx_queue->efx;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, FINI_TXQ_IN_INSTANCE,\n\t\t       tx_queue->queue);\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_FINI_TXQ, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\n\tif (rc && rc != -EALREADY)\n\t\tgoto fail;\n\n\treturn;\n\nfail:\n\tefx_mcdi_display_error(efx, MC_CMD_FINI_TXQ, MC_CMD_FINI_TXQ_IN_LEN,\n\t\t\t       outbuf, outlen, rc);\n}\n\nint efx_mcdi_rx_probe(struct efx_rx_queue *rx_queue)\n{\n\treturn efx_nic_alloc_buffer(rx_queue->efx, &rx_queue->rxd,\n\t\t\t\t    (rx_queue->ptr_mask + 1) *\n\t\t\t\t    sizeof(efx_qword_t),\n\t\t\t\t    GFP_KERNEL);\n}\n\nvoid efx_mcdi_rx_init(struct efx_rx_queue *rx_queue)\n{\n\tstruct efx_channel *channel = efx_rx_queue_channel(rx_queue);\n\tsize_t entries = rx_queue->rxd.len / EFX_BUF_SIZE;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_INIT_RXQ_V4_IN_LEN);\n\tstruct efx_nic *efx = rx_queue->efx;\n\tunsigned int buffer_size;\n\tdma_addr_t dma_addr;\n\tint rc;\n\tint i;\n\tBUILD_BUG_ON(MC_CMD_INIT_RXQ_OUT_LEN != 0);\n\n\trx_queue->scatter_n = 0;\n\trx_queue->scatter_len = 0;\n\tif (efx->type->revision == EFX_REV_EF100)\n\t\tbuffer_size = efx->rx_page_buf_step;\n\telse\n\t\tbuffer_size = 0;\n\n\tMCDI_SET_DWORD(inbuf, INIT_RXQ_IN_SIZE, rx_queue->ptr_mask + 1);\n\tMCDI_SET_DWORD(inbuf, INIT_RXQ_IN_TARGET_EVQ, channel->channel);\n\tMCDI_SET_DWORD(inbuf, INIT_RXQ_IN_LABEL, efx_rx_queue_index(rx_queue));\n\tMCDI_SET_DWORD(inbuf, INIT_RXQ_IN_INSTANCE,\n\t\t       efx_rx_queue_index(rx_queue));\n\tMCDI_POPULATE_DWORD_2(inbuf, INIT_RXQ_IN_FLAGS,\n\t\t\t      INIT_RXQ_IN_FLAG_PREFIX, 1,\n\t\t\t      INIT_RXQ_IN_FLAG_TIMESTAMP, 1);\n\tMCDI_SET_DWORD(inbuf, INIT_RXQ_IN_OWNER_ID, 0);\n\tMCDI_SET_DWORD(inbuf, INIT_RXQ_IN_PORT_ID, efx->vport_id);\n\tMCDI_SET_DWORD(inbuf, INIT_RXQ_V4_IN_BUFFER_SIZE_BYTES, buffer_size);\n\n\tdma_addr = rx_queue->rxd.dma_addr;\n\n\tnetif_dbg(efx, hw, efx->net_dev, \"pushing RXQ %d. %zu entries (%llx)\\n\",\n\t\t  efx_rx_queue_index(rx_queue), entries, (u64)dma_addr);\n\n\tfor (i = 0; i < entries; ++i) {\n\t\tMCDI_SET_ARRAY_QWORD(inbuf, INIT_RXQ_IN_DMA_ADDR, i, dma_addr);\n\t\tdma_addr += EFX_BUF_SIZE;\n\t}\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_INIT_RXQ, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL);\n\tif (rc)\n\t\tnetdev_WARN(efx->net_dev, \"failed to initialise RXQ %d\\n\",\n\t\t\t    efx_rx_queue_index(rx_queue));\n}\n\nvoid efx_mcdi_rx_remove(struct efx_rx_queue *rx_queue)\n{\n\tefx_nic_free_buffer(rx_queue->efx, &rx_queue->rxd);\n}\n\nvoid efx_mcdi_rx_fini(struct efx_rx_queue *rx_queue)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FINI_RXQ_IN_LEN);\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tstruct efx_nic *efx = rx_queue->efx;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, FINI_RXQ_IN_INSTANCE,\n\t\t       efx_rx_queue_index(rx_queue));\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_FINI_RXQ, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\n\tif (rc && rc != -EALREADY)\n\t\tgoto fail;\n\n\treturn;\n\nfail:\n\tefx_mcdi_display_error(efx, MC_CMD_FINI_RXQ, MC_CMD_FINI_RXQ_IN_LEN,\n\t\t\t       outbuf, outlen, rc);\n}\n\nint efx_fini_dmaq(struct efx_nic *efx)\n{\n\tstruct efx_tx_queue *tx_queue;\n\tstruct efx_rx_queue *rx_queue;\n\tstruct efx_channel *channel;\n\tint pending;\n\n\t \n\tif (efx->must_realloc_vis) {\n\t\tatomic_set(&efx->active_queues, 0);\n\t\treturn 0;\n\t}\n\n\t \n\tif (efx->state != STATE_RECOVERY) {\n\t\tefx_for_each_channel(channel, efx) {\n\t\t\tefx_for_each_channel_rx_queue(rx_queue, channel)\n\t\t\t\tefx_mcdi_rx_fini(rx_queue);\n\t\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\t\tefx_mcdi_tx_fini(tx_queue);\n\t\t}\n\n\t\twait_event_timeout(efx->flush_wq,\n\t\t\t\t   atomic_read(&efx->active_queues) == 0,\n\t\t\t\t   msecs_to_jiffies(EFX_MAX_FLUSH_TIME));\n\t\tpending = atomic_read(&efx->active_queues);\n\t\tif (pending) {\n\t\t\tnetif_err(efx, hw, efx->net_dev, \"failed to flush %d queues\\n\",\n\t\t\t\t  pending);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint efx_mcdi_window_mode_to_stride(struct efx_nic *efx, u8 vi_window_mode)\n{\n\tswitch (vi_window_mode) {\n\tcase MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_8K:\n\t\tefx->vi_stride = 8192;\n\t\tbreak;\n\tcase MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_16K:\n\t\tefx->vi_stride = 16384;\n\t\tbreak;\n\tcase MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_64K:\n\t\tefx->vi_stride = 65536;\n\t\tbreak;\n\tdefault:\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Unrecognised VI window mode %d\\n\",\n\t\t\t  vi_window_mode);\n\t\treturn -EIO;\n\t}\n\tnetif_dbg(efx, probe, efx->net_dev, \"vi_stride = %u\\n\",\n\t\t  efx->vi_stride);\n\treturn 0;\n}\n\nint efx_get_pf_index(struct efx_nic *efx, unsigned int *pf_index)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_FUNCTION_INFO_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_FUNCTION_INFO, NULL, 0, outbuf,\n\t\t\t  sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < sizeof(outbuf))\n\t\treturn -EIO;\n\n\t*pf_index = MCDI_DWORD(outbuf, GET_FUNCTION_INFO_OUT_PF);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}