{
  "module_name": "ef100_netdev.c",
  "hash_id": "15ad38409ee8b851e122f779b332a80425a6ffe9a80d4bb5af8acd25a701746d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef100_netdev.c",
  "human_readable_source": "\n \n#include \"net_driver.h\"\n#include \"mcdi_port_common.h\"\n#include \"mcdi_functions.h\"\n#include \"efx_common.h\"\n#include \"efx_channels.h\"\n#include \"tx_common.h\"\n#include \"ef100_netdev.h\"\n#include \"ef100_ethtool.h\"\n#include \"nic_common.h\"\n#include \"ef100_nic.h\"\n#include \"ef100_tx.h\"\n#include \"ef100_regs.h\"\n#include \"mcdi_filters.h\"\n#include \"rx_common.h\"\n#include \"ef100_sriov.h\"\n#include \"tc_bindings.h\"\n#include \"tc_encap_actions.h\"\n#include \"efx_devlink.h\"\n\nstatic void ef100_update_name(struct efx_nic *efx)\n{\n\tstrcpy(efx->name, efx->net_dev->name);\n}\n\nstatic int ef100_alloc_vis(struct efx_nic *efx, unsigned int *allocated_vis)\n{\n\t \n\tunsigned int tx_vis = efx->n_tx_channels + efx->n_extra_tx_channels;\n\tunsigned int rx_vis = efx->n_rx_channels;\n\tunsigned int min_vis, max_vis;\n\tint rc;\n\n\tEFX_WARN_ON_PARANOID(efx->tx_queues_per_channel != 1);\n\n\ttx_vis += efx->n_xdp_channels * efx->xdp_tx_per_channel;\n\n\tmax_vis = max(rx_vis, tx_vis);\n\t \n\tmin_vis = efx->tx_queues_per_channel;\n\n\trc = efx_mcdi_alloc_vis(efx, min_vis, max_vis,\n\t\t\t\tNULL, allocated_vis);\n\n\t \n\tif (!rc && *allocated_vis < max_vis)\n\t\trc = -EAGAIN;\n\n\treturn rc;\n}\n\nstatic int ef100_remap_bar(struct efx_nic *efx, int max_vis)\n{\n\tunsigned int uc_mem_map_size;\n\tvoid __iomem *membase;\n\n\tefx->max_vis = max_vis;\n\tuc_mem_map_size = PAGE_ALIGN(max_vis * efx->vi_stride);\n\n\t \n\tmembase = ioremap(efx->membase_phys, uc_mem_map_size);\n\tif (!membase) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"could not extend memory BAR to %x\\n\",\n\t\t\t  uc_mem_map_size);\n\t\treturn -ENOMEM;\n\t}\n\tiounmap(efx->membase);\n\tefx->membase = membase;\n\treturn 0;\n}\n\n \nstatic int ef100_net_stop(struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tnetif_dbg(efx, ifdown, efx->net_dev, \"closing on CPU %d\\n\",\n\t\t  raw_smp_processor_id());\n\n\tefx_detach_reps(efx);\n\tnetif_stop_queue(net_dev);\n\tefx_stop_all(efx);\n\tefx_mcdi_mac_fini_stats(efx);\n\tefx_disable_interrupts(efx);\n\tefx_clear_interrupt_affinity(efx);\n\tefx_nic_fini_interrupt(efx);\n\tefx_remove_filters(efx);\n\tefx_fini_napi(efx);\n\tefx_remove_channels(efx);\n\tefx_mcdi_free_vis(efx);\n\tefx_remove_interrupts(efx);\n\n\tefx->state = STATE_NET_DOWN;\n\n\treturn 0;\n}\n\n \nstatic int ef100_net_open(struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tunsigned int allocated_vis;\n\tint rc;\n\n\tef100_update_name(efx);\n\tnetif_dbg(efx, ifup, net_dev, \"opening device on CPU %d\\n\",\n\t\t  raw_smp_processor_id());\n\n\trc = efx_check_disabled(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_probe_interrupts(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_set_channels(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_mcdi_free_vis(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = ef100_alloc_vis(efx, &allocated_vis);\n\tif (rc && rc != -EAGAIN)\n\t\tgoto fail;\n\n\t \n\tif (rc == -EAGAIN) {\n\t\trc = efx_mcdi_free_vis(efx);\n\t\tif (rc)\n\t\t\tgoto fail;\n\n\t\tefx_remove_interrupts(efx);\n\t\tefx->max_channels = allocated_vis;\n\n\t\trc = efx_probe_interrupts(efx);\n\t\tif (rc)\n\t\t\tgoto fail;\n\n\t\trc = efx_set_channels(efx);\n\t\tif (rc)\n\t\t\tgoto fail;\n\n\t\trc = ef100_alloc_vis(efx, &allocated_vis);\n\t\tif (rc && rc != -EAGAIN)\n\t\t\tgoto fail;\n\n\t\t \n\t\tif (rc == -EAGAIN) {\n\t\t\trc = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\trc = efx_probe_channels(efx);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ef100_remap_bar(efx, allocated_vis);\n\tif (rc)\n\t\tgoto fail;\n\n\tefx_init_napi(efx);\n\n\trc = efx_probe_filters(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_nic_init_interrupt(efx);\n\tif (rc)\n\t\tgoto fail;\n\tefx_set_interrupt_affinity(efx);\n\n\trc = efx_enable_interrupts(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\t(void) efx_mcdi_poll_reboot(efx);\n\n\trc = efx_mcdi_mac_init_stats(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\tefx_start_all(efx);\n\n\t \n\tmutex_lock(&efx->mac_lock);\n\tif (efx_mcdi_phy_poll(efx))\n\t\tefx_link_status_changed(efx);\n\tmutex_unlock(&efx->mac_lock);\n\n\tefx->state = STATE_NET_UP;\n\tif (netif_running(efx->net_dev))\n\t\tefx_attach_reps(efx);\n\n\treturn 0;\n\nfail:\n\tef100_net_stop(net_dev);\n\treturn rc;\n}\n\n \nstatic netdev_tx_t ef100_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\treturn __ef100_hard_start_xmit(skb, efx, net_dev, NULL);\n}\n\nnetdev_tx_t __ef100_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct efx_nic *efx,\n\t\t\t\t    struct net_device *net_dev,\n\t\t\t\t    struct efx_rep *efv)\n{\n\tstruct efx_tx_queue *tx_queue;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tchannel = efx_get_tx_channel(efx, skb_get_queue_mapping(skb));\n\tnetif_vdbg(efx, tx_queued, efx->net_dev,\n\t\t   \"%s len %d data %d channel %d\\n\", __func__,\n\t\t   skb->len, skb->data_len, channel->channel);\n\tif (!efx->n_channels || !efx->n_tx_channels || !channel) {\n\t\tnetif_stop_queue(net_dev);\n\t\tdev_kfree_skb_any(skb);\n\t\tgoto err;\n\t}\n\n\ttx_queue = &channel->tx_queue[0];\n\trc = __ef100_enqueue_skb(tx_queue, skb, efv);\n\tif (rc == 0)\n\t\treturn NETDEV_TX_OK;\n\nerr:\n\tnet_dev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops ef100_netdev_ops = {\n\t.ndo_open               = ef100_net_open,\n\t.ndo_stop               = ef100_net_stop,\n\t.ndo_start_xmit         = ef100_hard_start_xmit,\n\t.ndo_tx_timeout         = efx_watchdog,\n\t.ndo_get_stats64        = efx_net_stats,\n\t.ndo_change_mtu         = efx_change_mtu,\n\t.ndo_validate_addr      = eth_validate_addr,\n\t.ndo_set_mac_address    = efx_set_mac_address,\n\t.ndo_set_rx_mode        = efx_set_rx_mode,  \n\t.ndo_set_features       = efx_set_features,\n\t.ndo_get_phys_port_id   = efx_get_phys_port_id,\n\t.ndo_get_phys_port_name = efx_get_phys_port_name,\n#ifdef CONFIG_RFS_ACCEL\n\t.ndo_rx_flow_steer      = efx_filter_rfs,\n#endif\n#ifdef CONFIG_SFC_SRIOV\n\t.ndo_setup_tc\t\t= efx_tc_setup,\n#endif\n};\n\n \nint ef100_netdev_event(struct notifier_block *this,\n\t\t       unsigned long event, void *ptr)\n{\n\tstruct efx_nic *efx = container_of(this, struct efx_nic, netdev_notifier);\n\tstruct net_device *net_dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tint err;\n\n\tif (efx->net_dev == net_dev &&\n\t    (event == NETDEV_CHANGENAME || event == NETDEV_REGISTER))\n\t\tef100_update_name(efx);\n\n\tif (!nic_data->grp_mae)\n\t\treturn NOTIFY_DONE;\n\terr = efx_tc_netdev_event(efx, event, net_dev);\n\tif (err & NOTIFY_STOP_MASK)\n\t\treturn err;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int ef100_netevent_event(struct notifier_block *this,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct efx_nic *efx = container_of(this, struct efx_nic, netevent_notifier);\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tint err;\n\n\tif (!nic_data->grp_mae)\n\t\treturn NOTIFY_DONE;\n\terr = efx_tc_netevent_event(efx, event, ptr);\n\tif (err & NOTIFY_STOP_MASK)\n\t\treturn err;\n\n\treturn NOTIFY_DONE;\n};\n\nstatic int ef100_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n\tnet_dev->irq = efx->pci_dev->irq;\n\tnet_dev->netdev_ops = &ef100_netdev_ops;\n\tnet_dev->min_mtu = EFX_MIN_MTU;\n\tnet_dev->max_mtu = EFX_MAX_MTU;\n\tnet_dev->ethtool_ops = &ef100_ethtool_ops;\n\n\trtnl_lock();\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tef100_update_name(efx);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\t \n\tnetif_carrier_off(net_dev);\n\n\tefx->state = STATE_NET_DOWN;\n\trtnl_unlock();\n\tefx_init_mcdi_logging(efx);\n\n\treturn 0;\n\nfail_locked:\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n}\n\nstatic void ef100_unregister_netdev(struct efx_nic *efx)\n{\n\tif (efx_dev_registered(efx)) {\n\t\tefx_fini_mcdi_logging(efx);\n\t\tefx->state = STATE_PROBED;\n\t\tunregister_netdev(efx->net_dev);\n\t}\n}\n\nvoid ef100_remove_netdev(struct efx_probe_data *probe_data)\n{\n\tstruct efx_nic *efx = &probe_data->efx;\n\n\tif (!efx->net_dev)\n\t\treturn;\n\n\trtnl_lock();\n\tdev_close(efx->net_dev);\n\trtnl_unlock();\n\n\tunregister_netdevice_notifier(&efx->netdev_notifier);\n\tunregister_netevent_notifier(&efx->netevent_notifier);\n#if defined(CONFIG_SFC_SRIOV)\n\tif (!efx->type->is_vf)\n\t\tefx_ef100_pci_sriov_disable(efx, true);\n#endif\n\n\tefx_fini_devlink_lock(efx);\n\tef100_unregister_netdev(efx);\n\n#ifdef CONFIG_SFC_SRIOV\n\tef100_pf_unset_devlink_port(efx);\n\tefx_fini_tc(efx);\n#endif\n\n\tdown_write(&efx->filter_sem);\n\tefx_mcdi_filter_table_remove(efx);\n\tup_write(&efx->filter_sem);\n\tefx_fini_channels(efx);\n\tkfree(efx->phy_data);\n\tefx->phy_data = NULL;\n\n\tefx_fini_devlink_and_unlock(efx);\n\n\tfree_netdev(efx->net_dev);\n\tefx->net_dev = NULL;\n\tefx->state = STATE_PROBED;\n}\n\nint ef100_probe_netdev(struct efx_probe_data *probe_data)\n{\n\tstruct efx_nic *efx = &probe_data->efx;\n\tstruct efx_probe_data **probe_ptr;\n\tstruct ef100_nic_data *nic_data;\n\tstruct net_device *net_dev;\n\tint rc;\n\n\tif (efx->mcdi->fn_flags &\n\t\t\t(1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_NO_ACTIVE_PORT)) {\n\t\tpci_info(efx->pci_dev, \"No network port on this PCI function\");\n\t\treturn 0;\n\t}\n\n\t \n\tnet_dev = alloc_etherdev_mq(sizeof(probe_data), EFX_MAX_CORE_TX_QUEUES);\n\tif (!net_dev)\n\t\treturn -ENOMEM;\n\tprobe_ptr = netdev_priv(net_dev);\n\t*probe_ptr = probe_data;\n\tefx->net_dev = net_dev;\n\tSET_NETDEV_DEV(net_dev, &efx->pci_dev->dev);\n\n\t \n\tnet_dev->features |= efx->type->offload_features &\n\t\t\t     ~(NETIF_F_RXFCS | NETIF_F_RXALL);\n\tnet_dev->hw_features |= efx->type->offload_features;\n\tnet_dev->hw_enc_features |= efx->type->offload_features;\n\tnet_dev->vlan_features |= NETIF_F_HW_CSUM | NETIF_F_SG |\n\t\t\t\t  NETIF_F_HIGHDMA | NETIF_F_ALL_TSO;\n\tnetif_set_tso_max_segs(net_dev,\n\t\t\t       ESE_EF100_DP_GZ_TSO_MAX_HDR_NUM_SEGS_DEFAULT);\n\tefx->mdio.dev = net_dev;\n\n\trc = efx_ef100_init_datapath_caps(efx);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\trc = ef100_phy_probe(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = efx_init_channels(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\tdown_write(&efx->filter_sem);\n\trc = ef100_filter_table_probe(efx);\n\tup_write(&efx->filter_sem);\n\tif (rc)\n\t\tgoto fail;\n\n\tnetdev_rss_key_fill(efx->rss_context.rx_hash_key,\n\t\t\t    sizeof(efx->rss_context.rx_hash_key));\n\n\t \n\tefx_mcdi_push_default_indir_table(efx, efx->n_rx_channels);\n\n\tnic_data = efx->nic_data;\n\trc = ef100_get_mac_address(efx, net_dev->perm_addr, CLIENT_HANDLE_SELF,\n\t\t\t\t   efx->type->is_vf);\n\tif (rc)\n\t\treturn rc;\n\t \n\teth_hw_addr_set(net_dev, net_dev->perm_addr);\n\tether_addr_copy(nic_data->port_id, net_dev->perm_addr);\n\n\t \n\trc = efx_probe_devlink_and_lock(efx);\n\tif (rc)\n\t\tpci_info(efx->pci_dev, \"devlink registration failed\");\n\n\trc = ef100_register_netdev(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (!efx->type->is_vf) {\n\t\trc = ef100_probe_netdev_pf(efx);\n\t\tif (rc)\n\t\t\tgoto fail;\n#ifdef CONFIG_SFC_SRIOV\n\t\tef100_pf_set_devlink_port(efx);\n#endif\n\t}\n\n\tefx->netdev_notifier.notifier_call = ef100_netdev_event;\n\trc = register_netdevice_notifier(&efx->netdev_notifier);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Failed to register netdevice notifier, rc=%d\\n\", rc);\n\t\tgoto fail;\n\t}\n\n\tefx->netevent_notifier.notifier_call = ef100_netevent_event;\n\trc = register_netevent_notifier(&efx->netevent_notifier);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Failed to register netevent notifier, rc=%d\\n\", rc);\n\t\tgoto fail;\n\t}\n\n\tefx_probe_devlink_unlock(efx);\n\treturn rc;\nfail:\n#ifdef CONFIG_SFC_SRIOV\n\t \n\tef100_pf_unset_devlink_port(efx);\n#endif\n\tefx_probe_devlink_unlock(efx);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}