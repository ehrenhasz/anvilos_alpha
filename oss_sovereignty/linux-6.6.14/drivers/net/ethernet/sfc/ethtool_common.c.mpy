{
  "module_name": "ethtool_common.c",
  "hash_id": "5424f063f2610f7c00efe8e8f5517ce987c9ffbaeedba3f634135e5f1bad9af4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ethtool_common.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include \"net_driver.h\"\n#include \"mcdi.h\"\n#include \"nic.h\"\n#include \"selftest.h\"\n#include \"rx_common.h\"\n#include \"ethtool_common.h\"\n#include \"mcdi_port_common.h\"\n\nstruct efx_sw_stat_desc {\n\tconst char *name;\n\tenum {\n\t\tEFX_ETHTOOL_STAT_SOURCE_nic,\n\t\tEFX_ETHTOOL_STAT_SOURCE_channel,\n\t\tEFX_ETHTOOL_STAT_SOURCE_tx_queue\n\t} source;\n\tunsigned int offset;\n\tu64 (*get_stat)(void *field);  \n};\n\n \n#define EFX_ETHTOOL_STAT(stat_name, source_name, field, field_type, \\\n\t\t\t\tget_stat_function) {\t\t\t\\\n\t.name = #stat_name,\t\t\t\t\t\t\\\n\t.source = EFX_ETHTOOL_STAT_SOURCE_##source_name,\t\t\\\n\t.offset = ((((field_type *) 0) ==\t\t\t\t\\\n\t\t      &((struct efx_##source_name *)0)->field) ?\t\\\n\t\t    offsetof(struct efx_##source_name, field) :\t\t\\\n\t\t    offsetof(struct efx_##source_name, field)),\t\t\\\n\t.get_stat = get_stat_function,\t\t\t\t\t\\\n}\n\nstatic u64 efx_get_uint_stat(void *field)\n{\n\treturn *(unsigned int *)field;\n}\n\nstatic u64 efx_get_atomic_stat(void *field)\n{\n\treturn atomic_read((atomic_t *) field);\n}\n\n#define EFX_ETHTOOL_ATOMIC_NIC_ERROR_STAT(field)\t\t\\\n\tEFX_ETHTOOL_STAT(field, nic, field,\t\t\t\\\n\t\t\t atomic_t, efx_get_atomic_stat)\n\n#define EFX_ETHTOOL_UINT_CHANNEL_STAT(field)\t\t\t\\\n\tEFX_ETHTOOL_STAT(field, channel, n_##field,\t\t\\\n\t\t\t unsigned int, efx_get_uint_stat)\n#define EFX_ETHTOOL_UINT_CHANNEL_STAT_NO_N(field)\t\t\\\n\tEFX_ETHTOOL_STAT(field, channel, field,\t\t\t\\\n\t\t\t unsigned int, efx_get_uint_stat)\n\n#define EFX_ETHTOOL_UINT_TXQ_STAT(field)\t\t\t\\\n\tEFX_ETHTOOL_STAT(tx_##field, tx_queue, field,\t\t\\\n\t\t\t unsigned int, efx_get_uint_stat)\n\nstatic const struct efx_sw_stat_desc efx_sw_stat_desc[] = {\n\tEFX_ETHTOOL_UINT_TXQ_STAT(merge_events),\n\tEFX_ETHTOOL_UINT_TXQ_STAT(tso_bursts),\n\tEFX_ETHTOOL_UINT_TXQ_STAT(tso_long_headers),\n\tEFX_ETHTOOL_UINT_TXQ_STAT(tso_packets),\n\tEFX_ETHTOOL_UINT_TXQ_STAT(tso_fallbacks),\n\tEFX_ETHTOOL_UINT_TXQ_STAT(pushes),\n\tEFX_ETHTOOL_UINT_TXQ_STAT(pio_packets),\n\tEFX_ETHTOOL_UINT_TXQ_STAT(cb_packets),\n\tEFX_ETHTOOL_ATOMIC_NIC_ERROR_STAT(rx_reset),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_tobe_disc),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_ip_hdr_chksum_err),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_tcp_udp_chksum_err),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_inner_ip_hdr_chksum_err),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_inner_tcp_udp_chksum_err),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_outer_ip_hdr_chksum_err),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_outer_tcp_udp_chksum_err),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_eth_crc_err),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_mcast_mismatch),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_frm_trunc),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_merge_events),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_merge_packets),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_xdp_drops),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_xdp_bad_drops),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_xdp_tx),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_xdp_redirect),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rx_mport_bad),\n#ifdef CONFIG_RFS_ACCEL\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT_NO_N(rfs_filter_count),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rfs_succeeded),\n\tEFX_ETHTOOL_UINT_CHANNEL_STAT(rfs_failed),\n#endif\n};\n\n#define EFX_ETHTOOL_SW_STAT_COUNT ARRAY_SIZE(efx_sw_stat_desc)\n\nvoid efx_ethtool_get_drvinfo(struct net_device *net_dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tefx_mcdi_print_fwver(efx, info->fw_version,\n\t\t\t     sizeof(info->fw_version));\n\tstrscpy(info->bus_info, pci_name(efx->pci_dev), sizeof(info->bus_info));\n}\n\nu32 efx_ethtool_get_msglevel(struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\treturn efx->msg_enable;\n}\n\nvoid efx_ethtool_set_msglevel(struct net_device *net_dev, u32 msg_enable)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tefx->msg_enable = msg_enable;\n}\n\nvoid efx_ethtool_self_test(struct net_device *net_dev,\n\t\t\t   struct ethtool_test *test, u64 *data)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tstruct efx_self_tests *efx_tests;\n\tbool already_up;\n\tint rc = -ENOMEM;\n\n\tefx_tests = kzalloc(sizeof(*efx_tests), GFP_KERNEL);\n\tif (!efx_tests)\n\t\tgoto fail;\n\n\tif (!efx_net_active(efx->state)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tnetif_info(efx, drv, efx->net_dev, \"starting %sline testing\\n\",\n\t\t   (test->flags & ETH_TEST_FL_OFFLINE) ? \"off\" : \"on\");\n\n\t \n\talready_up = (efx->net_dev->flags & IFF_UP);\n\tif (!already_up) {\n\t\trc = dev_open(efx->net_dev, NULL);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"failed opening device.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = efx_selftest(efx, efx_tests, test->flags);\n\n\tif (!already_up)\n\t\tdev_close(efx->net_dev);\n\n\tnetif_info(efx, drv, efx->net_dev, \"%s %sline self-tests\\n\",\n\t\t   rc == 0 ? \"passed\" : \"failed\",\n\t\t   (test->flags & ETH_TEST_FL_OFFLINE) ? \"off\" : \"on\");\n\nout:\n\tefx_ethtool_fill_self_tests(efx, efx_tests, NULL, data);\n\tkfree(efx_tests);\nfail:\n\tif (rc)\n\t\ttest->flags |= ETH_TEST_FL_FAILED;\n}\n\nvoid efx_ethtool_get_pauseparam(struct net_device *net_dev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tpause->rx_pause = !!(efx->wanted_fc & EFX_FC_RX);\n\tpause->tx_pause = !!(efx->wanted_fc & EFX_FC_TX);\n\tpause->autoneg = !!(efx->wanted_fc & EFX_FC_AUTO);\n}\n\nint efx_ethtool_set_pauseparam(struct net_device *net_dev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tu8 wanted_fc, old_fc;\n\tu32 old_adv;\n\tint rc = 0;\n\n\tmutex_lock(&efx->mac_lock);\n\n\twanted_fc = ((pause->rx_pause ? EFX_FC_RX : 0) |\n\t\t     (pause->tx_pause ? EFX_FC_TX : 0) |\n\t\t     (pause->autoneg ? EFX_FC_AUTO : 0));\n\n\tif ((wanted_fc & EFX_FC_TX) && !(wanted_fc & EFX_FC_RX)) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Flow control unsupported: tx ON rx OFF\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((wanted_fc & EFX_FC_AUTO) && !efx->link_advertising[0]) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Autonegotiation is disabled\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (efx->type->prepare_enable_fc_tx &&\n\t    (wanted_fc & EFX_FC_TX) && !(efx->wanted_fc & EFX_FC_TX))\n\t\tefx->type->prepare_enable_fc_tx(efx);\n\n\told_adv = efx->link_advertising[0];\n\told_fc = efx->wanted_fc;\n\tefx_link_set_wanted_fc(efx, wanted_fc);\n\tif (efx->link_advertising[0] != old_adv ||\n\t    (efx->wanted_fc ^ old_fc) & EFX_FC_AUTO) {\n\t\trc = efx_mcdi_port_reconfigure(efx);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  \"Unable to advertise requested flow \"\n\t\t\t\t  \"control setting\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tefx_mac_reconfigure(efx, false);\n\nout:\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn rc;\n}\n\n \nstatic void efx_fill_test(unsigned int test_index, u8 *strings, u64 *data,\n\t\t\t  int *test, const char *unit_format, int unit_id,\n\t\t\t  const char *test_format, const char *test_id)\n{\n\tchar unit_str[ETH_GSTRING_LEN], test_str[ETH_GSTRING_LEN];\n\n\t \n\tif (data)\n\t\tdata[test_index] = *test;\n\n\t \n\tif (strings) {\n\t\tif (strchr(unit_format, '%'))\n\t\t\tsnprintf(unit_str, sizeof(unit_str),\n\t\t\t\t unit_format, unit_id);\n\t\telse\n\t\t\tstrcpy(unit_str, unit_format);\n\t\tsnprintf(test_str, sizeof(test_str), test_format, test_id);\n\t\tsnprintf(strings + test_index * ETH_GSTRING_LEN,\n\t\t\t ETH_GSTRING_LEN,\n\t\t\t \"%-6s %-24s\", unit_str, test_str);\n\t}\n}\n\n#define EFX_CHANNEL_NAME(_channel) \"chan%d\", _channel->channel\n#define EFX_TX_QUEUE_NAME(_tx_queue) \"txq%d\", _tx_queue->label\n#define EFX_LOOPBACK_NAME(_mode, _counter)\t\t\t\\\n\t\"loopback.%s.\" _counter, STRING_TABLE_LOOKUP(_mode, efx_loopback_mode)\n\n \nstatic int efx_fill_loopback_test(struct efx_nic *efx,\n\t\t\t\t  struct efx_loopback_self_tests *lb_tests,\n\t\t\t\t  enum efx_loopback_mode mode,\n\t\t\t\t  unsigned int test_index,\n\t\t\t\t  u8 *strings, u64 *data)\n{\n\tstruct efx_channel *channel =\n\t\tefx_get_channel(efx, efx->tx_channel_offset);\n\tstruct efx_tx_queue *tx_queue;\n\n\tefx_for_each_channel_tx_queue(tx_queue, channel) {\n\t\tefx_fill_test(test_index++, strings, data,\n\t\t\t      &lb_tests->tx_sent[tx_queue->label],\n\t\t\t      EFX_TX_QUEUE_NAME(tx_queue),\n\t\t\t      EFX_LOOPBACK_NAME(mode, \"tx_sent\"));\n\t\tefx_fill_test(test_index++, strings, data,\n\t\t\t      &lb_tests->tx_done[tx_queue->label],\n\t\t\t      EFX_TX_QUEUE_NAME(tx_queue),\n\t\t\t      EFX_LOOPBACK_NAME(mode, \"tx_done\"));\n\t}\n\tefx_fill_test(test_index++, strings, data,\n\t\t      &lb_tests->rx_good,\n\t\t      \"rx\", 0,\n\t\t      EFX_LOOPBACK_NAME(mode, \"rx_good\"));\n\tefx_fill_test(test_index++, strings, data,\n\t\t      &lb_tests->rx_bad,\n\t\t      \"rx\", 0,\n\t\t      EFX_LOOPBACK_NAME(mode, \"rx_bad\"));\n\n\treturn test_index;\n}\n\n \nint efx_ethtool_fill_self_tests(struct efx_nic *efx,\n\t\t\t\tstruct efx_self_tests *tests,\n\t\t\t\tu8 *strings, u64 *data)\n{\n\tstruct efx_channel *channel;\n\tunsigned int n = 0, i;\n\tenum efx_loopback_mode mode;\n\n\tefx_fill_test(n++, strings, data, &tests->phy_alive,\n\t\t      \"phy\", 0, \"alive\", NULL);\n\tefx_fill_test(n++, strings, data, &tests->nvram,\n\t\t      \"core\", 0, \"nvram\", NULL);\n\tefx_fill_test(n++, strings, data, &tests->interrupt,\n\t\t      \"core\", 0, \"interrupt\", NULL);\n\n\t \n\tefx_for_each_channel(channel, efx) {\n\t\tefx_fill_test(n++, strings, data,\n\t\t\t      &tests->eventq_dma[channel->channel],\n\t\t\t      EFX_CHANNEL_NAME(channel),\n\t\t\t      \"eventq.dma\", NULL);\n\t\tefx_fill_test(n++, strings, data,\n\t\t\t      &tests->eventq_int[channel->channel],\n\t\t\t      EFX_CHANNEL_NAME(channel),\n\t\t\t      \"eventq.int\", NULL);\n\t}\n\n\tefx_fill_test(n++, strings, data, &tests->memory,\n\t\t      \"core\", 0, \"memory\", NULL);\n\tefx_fill_test(n++, strings, data, &tests->registers,\n\t\t      \"core\", 0, \"registers\", NULL);\n\n\tfor (i = 0; true; ++i) {\n\t\tconst char *name;\n\n\t\tEFX_WARN_ON_PARANOID(i >= EFX_MAX_PHY_TESTS);\n\t\tname = efx_mcdi_phy_test_name(efx, i);\n\t\tif (name == NULL)\n\t\t\tbreak;\n\n\t\tefx_fill_test(n++, strings, data, &tests->phy_ext[i], \"phy\", 0, name, NULL);\n\t}\n\n\t \n\tfor (mode = LOOPBACK_NONE; mode <= LOOPBACK_TEST_MAX; mode++) {\n\t\tif (!(efx->loopback_modes & (1 << mode)))\n\t\t\tcontinue;\n\t\tn = efx_fill_loopback_test(efx,\n\t\t\t\t\t   &tests->loopback[mode], mode, n,\n\t\t\t\t\t   strings, data);\n\t}\n\n\treturn n;\n}\n\nstatic size_t efx_describe_per_queue_stats(struct efx_nic *efx, u8 *strings)\n{\n\tsize_t n_stats = 0;\n\tstruct efx_channel *channel;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tif (efx_channel_has_tx_queues(channel)) {\n\t\t\tn_stats++;\n\t\t\tif (strings != NULL) {\n\t\t\t\tsnprintf(strings, ETH_GSTRING_LEN,\n\t\t\t\t\t \"tx-%u.tx_packets\",\n\t\t\t\t\t channel->tx_queue[0].queue /\n\t\t\t\t\t EFX_MAX_TXQ_PER_CHANNEL);\n\n\t\t\t\tstrings += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t}\n\tefx_for_each_channel(channel, efx) {\n\t\tif (efx_channel_has_rx_queue(channel)) {\n\t\t\tn_stats++;\n\t\t\tif (strings != NULL) {\n\t\t\t\tsnprintf(strings, ETH_GSTRING_LEN,\n\t\t\t\t\t \"rx-%d.rx_packets\", channel->channel);\n\t\t\t\tstrings += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t}\n\tif (efx->xdp_tx_queue_count && efx->xdp_tx_queues) {\n\t\tunsigned short xdp;\n\n\t\tfor (xdp = 0; xdp < efx->xdp_tx_queue_count; xdp++) {\n\t\t\tn_stats++;\n\t\t\tif (strings) {\n\t\t\t\tsnprintf(strings, ETH_GSTRING_LEN,\n\t\t\t\t\t \"tx-xdp-cpu-%hu.tx_packets\", xdp);\n\t\t\t\tstrings += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_stats;\n}\n\nint efx_ethtool_get_sset_count(struct net_device *net_dev, int string_set)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\treturn efx->type->describe_stats(efx, NULL) +\n\t\t       EFX_ETHTOOL_SW_STAT_COUNT +\n\t\t       efx_describe_per_queue_stats(efx, NULL) +\n\t\t       efx_ptp_describe_stats(efx, NULL);\n\tcase ETH_SS_TEST:\n\t\treturn efx_ethtool_fill_self_tests(efx, NULL, NULL, NULL);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nvoid efx_ethtool_get_strings(struct net_device *net_dev,\n\t\t\t     u32 string_set, u8 *strings)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint i;\n\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\tstrings += (efx->type->describe_stats(efx, strings) *\n\t\t\t    ETH_GSTRING_LEN);\n\t\tfor (i = 0; i < EFX_ETHTOOL_SW_STAT_COUNT; i++)\n\t\t\tstrscpy(strings + i * ETH_GSTRING_LEN,\n\t\t\t\tefx_sw_stat_desc[i].name, ETH_GSTRING_LEN);\n\t\tstrings += EFX_ETHTOOL_SW_STAT_COUNT * ETH_GSTRING_LEN;\n\t\tstrings += (efx_describe_per_queue_stats(efx, strings) *\n\t\t\t    ETH_GSTRING_LEN);\n\t\tefx_ptp_describe_stats(efx, strings);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tefx_ethtool_fill_self_tests(efx, NULL, strings, NULL);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nvoid efx_ethtool_get_stats(struct net_device *net_dev,\n\t\t\t   struct ethtool_stats *stats,\n\t\t\t   u64 *data)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tconst struct efx_sw_stat_desc *stat;\n\tstruct efx_channel *channel;\n\tstruct efx_tx_queue *tx_queue;\n\tstruct efx_rx_queue *rx_queue;\n\tint i;\n\n\tspin_lock_bh(&efx->stats_lock);\n\n\t \n\tdata += efx->type->update_stats(efx, data, NULL);\n\n\t \n\tfor (i = 0; i < EFX_ETHTOOL_SW_STAT_COUNT; i++) {\n\t\tstat = &efx_sw_stat_desc[i];\n\t\tswitch (stat->source) {\n\t\tcase EFX_ETHTOOL_STAT_SOURCE_nic:\n\t\t\tdata[i] = stat->get_stat((void *)efx + stat->offset);\n\t\t\tbreak;\n\t\tcase EFX_ETHTOOL_STAT_SOURCE_channel:\n\t\t\tdata[i] = 0;\n\t\t\tefx_for_each_channel(channel, efx)\n\t\t\t\tdata[i] += stat->get_stat((void *)channel +\n\t\t\t\t\t\t\t  stat->offset);\n\t\t\tbreak;\n\t\tcase EFX_ETHTOOL_STAT_SOURCE_tx_queue:\n\t\t\tdata[i] = 0;\n\t\t\tefx_for_each_channel(channel, efx) {\n\t\t\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\t\t\tdata[i] +=\n\t\t\t\t\t\tstat->get_stat((void *)tx_queue\n\t\t\t\t\t\t\t       + stat->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tdata += EFX_ETHTOOL_SW_STAT_COUNT;\n\n\tspin_unlock_bh(&efx->stats_lock);\n\n\tefx_for_each_channel(channel, efx) {\n\t\tif (efx_channel_has_tx_queues(channel)) {\n\t\t\t*data = 0;\n\t\t\tefx_for_each_channel_tx_queue(tx_queue, channel) {\n\t\t\t\t*data += tx_queue->tx_packets;\n\t\t\t}\n\t\t\tdata++;\n\t\t}\n\t}\n\tefx_for_each_channel(channel, efx) {\n\t\tif (efx_channel_has_rx_queue(channel)) {\n\t\t\t*data = 0;\n\t\t\tefx_for_each_channel_rx_queue(rx_queue, channel) {\n\t\t\t\t*data += rx_queue->rx_packets;\n\t\t\t}\n\t\t\tdata++;\n\t\t}\n\t}\n\tif (efx->xdp_tx_queue_count && efx->xdp_tx_queues) {\n\t\tint xdp;\n\n\t\tfor (xdp = 0; xdp < efx->xdp_tx_queue_count; xdp++) {\n\t\t\tdata[0] = efx->xdp_tx_queues[xdp]->tx_packets;\n\t\t\tdata++;\n\t\t}\n\t}\n\n\tefx_ptp_update_stats(efx, data);\n}\n\n \nint efx_ethtool_get_link_ksettings(struct net_device *net_dev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tstruct efx_link_state *link_state = &efx->link_state;\n\n\tmutex_lock(&efx->mac_lock);\n\tefx_mcdi_phy_get_link_ksettings(efx, cmd);\n\tmutex_unlock(&efx->mac_lock);\n\n\t \n\tethtool_link_ksettings_add_link_mode(cmd, supported, Pause);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, Asym_Pause);\n\n\tif (LOOPBACK_INTERNAL(efx)) {\n\t\tcmd->base.speed = link_state->speed;\n\t\tcmd->base.duplex = link_state->fd ? DUPLEX_FULL : DUPLEX_HALF;\n\t}\n\n\treturn 0;\n}\n\n \nint efx_ethtool_set_link_ksettings(struct net_device *net_dev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint rc;\n\n\t \n\tif ((cmd->base.speed == SPEED_1000) &&\n\t    (cmd->base.duplex != DUPLEX_FULL)) {\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"rejecting unsupported 1000Mbps HD setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&efx->mac_lock);\n\trc = efx_mcdi_phy_set_link_ksettings(efx, cmd);\n\tmutex_unlock(&efx->mac_lock);\n\treturn rc;\n}\n\nint efx_ethtool_get_fecparam(struct net_device *net_dev,\n\t\t\t     struct ethtool_fecparam *fecparam)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint rc;\n\n\tmutex_lock(&efx->mac_lock);\n\trc = efx_mcdi_phy_get_fecparam(efx, fecparam);\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn rc;\n}\n\nint efx_ethtool_set_fecparam(struct net_device *net_dev,\n\t\t\t     struct ethtool_fecparam *fecparam)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint rc;\n\n\tmutex_lock(&efx->mac_lock);\n\trc = efx_mcdi_phy_set_fecparam(efx, fecparam);\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn rc;\n}\n\n \nstatic const u8 mac_addr_ig_mask[ETH_ALEN] __aligned(2) = {0x01, 0, 0, 0, 0, 0};\n\n#define IP4_ADDR_FULL_MASK\t((__force __be32)~0)\n#define IP_PROTO_FULL_MASK\t0xFF\n#define PORT_FULL_MASK\t\t((__force __be16)~0)\n#define ETHER_TYPE_FULL_MASK\t((__force __be16)~0)\n\nstatic inline void ip6_fill_mask(__be32 *mask)\n{\n\tmask[0] = mask[1] = mask[2] = mask[3] = ~(__be32)0;\n}\n\nstatic int efx_ethtool_get_class_rule(struct efx_nic *efx,\n\t\t\t\t      struct ethtool_rx_flow_spec *rule,\n\t\t\t\t      u32 *rss_context)\n{\n\tstruct ethtool_tcpip4_spec *ip_entry = &rule->h_u.tcp_ip4_spec;\n\tstruct ethtool_tcpip4_spec *ip_mask = &rule->m_u.tcp_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_entry = &rule->h_u.usr_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_mask = &rule->m_u.usr_ip4_spec;\n\tstruct ethtool_tcpip6_spec *ip6_entry = &rule->h_u.tcp_ip6_spec;\n\tstruct ethtool_tcpip6_spec *ip6_mask = &rule->m_u.tcp_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_entry = &rule->h_u.usr_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_mask = &rule->m_u.usr_ip6_spec;\n\tstruct ethhdr *mac_entry = &rule->h_u.ether_spec;\n\tstruct ethhdr *mac_mask = &rule->m_u.ether_spec;\n\tstruct efx_filter_spec spec;\n\tint rc;\n\n\trc = efx_filter_get_filter_safe(efx, EFX_FILTER_PRI_MANUAL,\n\t\t\t\t\trule->location, &spec);\n\tif (rc)\n\t\treturn rc;\n\n\tif (spec.dmaq_id == EFX_FILTER_RX_DMAQ_ID_DROP)\n\t\trule->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\trule->ring_cookie = spec.dmaq_id;\n\n\tif ((spec.match_flags & EFX_FILTER_MATCH_ETHER_TYPE) &&\n\t    spec.ether_type == htons(ETH_P_IP) &&\n\t    (spec.match_flags & EFX_FILTER_MATCH_IP_PROTO) &&\n\t    (spec.ip_proto == IPPROTO_TCP || spec.ip_proto == IPPROTO_UDP) &&\n\t    !(spec.match_flags &\n\t      ~(EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_OUTER_VID |\n\t\tEFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_REM_HOST |\n\t\tEFX_FILTER_MATCH_IP_PROTO |\n\t\tEFX_FILTER_MATCH_LOC_PORT | EFX_FILTER_MATCH_REM_PORT))) {\n\t\trule->flow_type = ((spec.ip_proto == IPPROTO_TCP) ?\n\t\t\t\t   TCP_V4_FLOW : UDP_V4_FLOW);\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_LOC_HOST) {\n\t\t\tip_entry->ip4dst = spec.loc_host[0];\n\t\t\tip_mask->ip4dst = IP4_ADDR_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_REM_HOST) {\n\t\t\tip_entry->ip4src = spec.rem_host[0];\n\t\t\tip_mask->ip4src = IP4_ADDR_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_LOC_PORT) {\n\t\t\tip_entry->pdst = spec.loc_port;\n\t\t\tip_mask->pdst = PORT_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_REM_PORT) {\n\t\t\tip_entry->psrc = spec.rem_port;\n\t\t\tip_mask->psrc = PORT_FULL_MASK;\n\t\t}\n\t} else if ((spec.match_flags & EFX_FILTER_MATCH_ETHER_TYPE) &&\n\t    spec.ether_type == htons(ETH_P_IPV6) &&\n\t    (spec.match_flags & EFX_FILTER_MATCH_IP_PROTO) &&\n\t    (spec.ip_proto == IPPROTO_TCP || spec.ip_proto == IPPROTO_UDP) &&\n\t    !(spec.match_flags &\n\t      ~(EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_OUTER_VID |\n\t\tEFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_REM_HOST |\n\t\tEFX_FILTER_MATCH_IP_PROTO |\n\t\tEFX_FILTER_MATCH_LOC_PORT | EFX_FILTER_MATCH_REM_PORT))) {\n\t\trule->flow_type = ((spec.ip_proto == IPPROTO_TCP) ?\n\t\t\t\t   TCP_V6_FLOW : UDP_V6_FLOW);\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_LOC_HOST) {\n\t\t\tmemcpy(ip6_entry->ip6dst, spec.loc_host,\n\t\t\t       sizeof(ip6_entry->ip6dst));\n\t\t\tip6_fill_mask(ip6_mask->ip6dst);\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_REM_HOST) {\n\t\t\tmemcpy(ip6_entry->ip6src, spec.rem_host,\n\t\t\t       sizeof(ip6_entry->ip6src));\n\t\t\tip6_fill_mask(ip6_mask->ip6src);\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_LOC_PORT) {\n\t\t\tip6_entry->pdst = spec.loc_port;\n\t\t\tip6_mask->pdst = PORT_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_REM_PORT) {\n\t\t\tip6_entry->psrc = spec.rem_port;\n\t\t\tip6_mask->psrc = PORT_FULL_MASK;\n\t\t}\n\t} else if (!(spec.match_flags &\n\t\t     ~(EFX_FILTER_MATCH_LOC_MAC | EFX_FILTER_MATCH_LOC_MAC_IG |\n\t\t       EFX_FILTER_MATCH_REM_MAC | EFX_FILTER_MATCH_ETHER_TYPE |\n\t\t       EFX_FILTER_MATCH_OUTER_VID))) {\n\t\trule->flow_type = ETHER_FLOW;\n\t\tif (spec.match_flags &\n\t\t    (EFX_FILTER_MATCH_LOC_MAC | EFX_FILTER_MATCH_LOC_MAC_IG)) {\n\t\t\tether_addr_copy(mac_entry->h_dest, spec.loc_mac);\n\t\t\tif (spec.match_flags & EFX_FILTER_MATCH_LOC_MAC)\n\t\t\t\teth_broadcast_addr(mac_mask->h_dest);\n\t\t\telse\n\t\t\t\tether_addr_copy(mac_mask->h_dest,\n\t\t\t\t\t\tmac_addr_ig_mask);\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_REM_MAC) {\n\t\t\tether_addr_copy(mac_entry->h_source, spec.rem_mac);\n\t\t\teth_broadcast_addr(mac_mask->h_source);\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_ETHER_TYPE) {\n\t\t\tmac_entry->h_proto = spec.ether_type;\n\t\t\tmac_mask->h_proto = ETHER_TYPE_FULL_MASK;\n\t\t}\n\t} else if (spec.match_flags & EFX_FILTER_MATCH_ETHER_TYPE &&\n\t\t   spec.ether_type == htons(ETH_P_IP) &&\n\t\t   !(spec.match_flags &\n\t\t     ~(EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_OUTER_VID |\n\t\t       EFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_REM_HOST |\n\t\t       EFX_FILTER_MATCH_IP_PROTO))) {\n\t\trule->flow_type = IPV4_USER_FLOW;\n\t\tuip_entry->ip_ver = ETH_RX_NFC_IP4;\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_IP_PROTO) {\n\t\t\tuip_mask->proto = IP_PROTO_FULL_MASK;\n\t\t\tuip_entry->proto = spec.ip_proto;\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_LOC_HOST) {\n\t\t\tuip_entry->ip4dst = spec.loc_host[0];\n\t\t\tuip_mask->ip4dst = IP4_ADDR_FULL_MASK;\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_REM_HOST) {\n\t\t\tuip_entry->ip4src = spec.rem_host[0];\n\t\t\tuip_mask->ip4src = IP4_ADDR_FULL_MASK;\n\t\t}\n\t} else if (spec.match_flags & EFX_FILTER_MATCH_ETHER_TYPE &&\n\t\t   spec.ether_type == htons(ETH_P_IPV6) &&\n\t\t   !(spec.match_flags &\n\t\t     ~(EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_OUTER_VID |\n\t\t       EFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_REM_HOST |\n\t\t       EFX_FILTER_MATCH_IP_PROTO))) {\n\t\trule->flow_type = IPV6_USER_FLOW;\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_IP_PROTO) {\n\t\t\tuip6_mask->l4_proto = IP_PROTO_FULL_MASK;\n\t\t\tuip6_entry->l4_proto = spec.ip_proto;\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_LOC_HOST) {\n\t\t\tmemcpy(uip6_entry->ip6dst, spec.loc_host,\n\t\t\t       sizeof(uip6_entry->ip6dst));\n\t\t\tip6_fill_mask(uip6_mask->ip6dst);\n\t\t}\n\t\tif (spec.match_flags & EFX_FILTER_MATCH_REM_HOST) {\n\t\t\tmemcpy(uip6_entry->ip6src, spec.rem_host,\n\t\t\t       sizeof(uip6_entry->ip6src));\n\t\t\tip6_fill_mask(uip6_mask->ip6src);\n\t\t}\n\t} else {\n\t\t \n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (spec.match_flags & EFX_FILTER_MATCH_OUTER_VID) {\n\t\trule->flow_type |= FLOW_EXT;\n\t\trule->h_ext.vlan_tci = spec.outer_vid;\n\t\trule->m_ext.vlan_tci = htons(0xfff);\n\t}\n\n\tif (spec.flags & EFX_FILTER_FLAG_RX_RSS) {\n\t\trule->flow_type |= FLOW_RSS;\n\t\t*rss_context = spec.rss_context;\n\t}\n\n\treturn rc;\n}\n\nint efx_ethtool_get_rxnfc(struct net_device *net_dev,\n\t\t\t  struct ethtool_rxnfc *info, u32 *rule_locs)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tu32 rss_context = 0;\n\ts32 rc = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = efx->n_rx_channels;\n\t\treturn 0;\n\n\tcase ETHTOOL_GRXFH: {\n\t\tstruct efx_rss_context *ctx = &efx->rss_context;\n\t\t__u64 data;\n\n\t\tmutex_lock(&efx->rss_lock);\n\t\tif (info->flow_type & FLOW_RSS && info->rss_context) {\n\t\t\tctx = efx_find_rss_context_entry(efx, info->rss_context);\n\t\t\tif (!ctx) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tdata = 0;\n\t\tif (!efx_rss_active(ctx))  \n\t\t\tgoto out_setdata_unlock;\n\n\t\tswitch (info->flow_type & ~FLOW_RSS) {\n\t\tcase UDP_V4_FLOW:\n\t\tcase UDP_V6_FLOW:\n\t\t\tif (ctx->rx_hash_udp_4tuple)\n\t\t\t\tdata = (RXH_L4_B_0_1 | RXH_L4_B_2_3 |\n\t\t\t\t\tRXH_IP_SRC | RXH_IP_DST);\n\t\t\telse\n\t\t\t\tdata = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tcase TCP_V4_FLOW:\n\t\tcase TCP_V6_FLOW:\n\t\t\tdata = (RXH_L4_B_0_1 | RXH_L4_B_2_3 |\n\t\t\t\tRXH_IP_SRC | RXH_IP_DST);\n\t\t\tbreak;\n\t\tcase SCTP_V4_FLOW:\n\t\tcase SCTP_V6_FLOW:\n\t\tcase AH_ESP_V4_FLOW:\n\t\tcase AH_ESP_V6_FLOW:\n\t\tcase IPV4_FLOW:\n\t\tcase IPV6_FLOW:\n\t\t\tdata = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\nout_setdata_unlock:\n\t\tinfo->data = data;\nout_unlock:\n\t\tmutex_unlock(&efx->rss_lock);\n\t\treturn rc;\n\t}\n\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tinfo->data = efx_filter_get_rx_id_limit(efx);\n\t\tif (info->data == 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tinfo->data |= RX_CLS_LOC_SPECIAL;\n\t\tinfo->rule_cnt =\n\t\t\tefx_filter_count_rx_used(efx, EFX_FILTER_PRI_MANUAL);\n\t\treturn 0;\n\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tif (efx_filter_get_rx_id_limit(efx) == 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\trc = efx_ethtool_get_class_rule(efx, &info->fs, &rss_context);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (info->fs.flow_type & FLOW_RSS)\n\t\t\tinfo->rss_context = rss_context;\n\t\treturn 0;\n\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tinfo->data = efx_filter_get_rx_id_limit(efx);\n\t\tif (info->data == 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\trc = efx_filter_get_rx_ids(efx, EFX_FILTER_PRI_MANUAL,\n\t\t\t\t\t   rule_locs, info->rule_cnt);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tinfo->rule_cnt = rc;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic inline bool ip6_mask_is_full(__be32 mask[4])\n{\n\treturn !~(mask[0] & mask[1] & mask[2] & mask[3]);\n}\n\nstatic inline bool ip6_mask_is_empty(__be32 mask[4])\n{\n\treturn !(mask[0] | mask[1] | mask[2] | mask[3]);\n}\n\nstatic int efx_ethtool_set_class_rule(struct efx_nic *efx,\n\t\t\t\t      struct ethtool_rx_flow_spec *rule,\n\t\t\t\t      u32 rss_context)\n{\n\tstruct ethtool_tcpip4_spec *ip_entry = &rule->h_u.tcp_ip4_spec;\n\tstruct ethtool_tcpip4_spec *ip_mask = &rule->m_u.tcp_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_entry = &rule->h_u.usr_ip4_spec;\n\tstruct ethtool_usrip4_spec *uip_mask = &rule->m_u.usr_ip4_spec;\n\tstruct ethtool_tcpip6_spec *ip6_entry = &rule->h_u.tcp_ip6_spec;\n\tstruct ethtool_tcpip6_spec *ip6_mask = &rule->m_u.tcp_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_entry = &rule->h_u.usr_ip6_spec;\n\tstruct ethtool_usrip6_spec *uip6_mask = &rule->m_u.usr_ip6_spec;\n\tu32 flow_type = rule->flow_type & ~(FLOW_EXT | FLOW_RSS);\n\tstruct ethhdr *mac_entry = &rule->h_u.ether_spec;\n\tstruct ethhdr *mac_mask = &rule->m_u.ether_spec;\n\tenum efx_filter_flags flags = 0;\n\tstruct efx_filter_spec spec;\n\tint rc;\n\n\t \n\tif (rule->location != RX_CLS_LOC_ANY)\n\t\treturn -EINVAL;\n\n\t \n\tif (rule->ring_cookie >= efx->n_rx_channels &&\n\t    rule->ring_cookie != RX_CLS_FLOW_DISC)\n\t\treturn -EINVAL;\n\n\t \n\tif ((rule->flow_type & FLOW_EXT) &&\n\t    (rule->m_ext.vlan_etype || rule->m_ext.data[0] ||\n\t     rule->m_ext.data[1]))\n\t\treturn -EINVAL;\n\n\tif (efx->rx_scatter)\n\t\tflags |= EFX_FILTER_FLAG_RX_SCATTER;\n\tif (rule->flow_type & FLOW_RSS)\n\t\tflags |= EFX_FILTER_FLAG_RX_RSS;\n\n\tefx_filter_init_rx(&spec, EFX_FILTER_PRI_MANUAL, flags,\n\t\t\t   (rule->ring_cookie == RX_CLS_FLOW_DISC) ?\n\t\t\t   EFX_FILTER_RX_DMAQ_ID_DROP : rule->ring_cookie);\n\n\tif (rule->flow_type & FLOW_RSS)\n\t\tspec.rss_context = rss_context;\n\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\tspec.match_flags = (EFX_FILTER_MATCH_ETHER_TYPE |\n\t\t\t\t    EFX_FILTER_MATCH_IP_PROTO);\n\t\tspec.ether_type = htons(ETH_P_IP);\n\t\tspec.ip_proto = flow_type == TCP_V4_FLOW ? IPPROTO_TCP\n\t\t\t\t\t\t\t : IPPROTO_UDP;\n\t\tif (ip_mask->ip4dst) {\n\t\t\tif (ip_mask->ip4dst != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_HOST;\n\t\t\tspec.loc_host[0] = ip_entry->ip4dst;\n\t\t}\n\t\tif (ip_mask->ip4src) {\n\t\t\tif (ip_mask->ip4src != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_REM_HOST;\n\t\t\tspec.rem_host[0] = ip_entry->ip4src;\n\t\t}\n\t\tif (ip_mask->pdst) {\n\t\t\tif (ip_mask->pdst != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_PORT;\n\t\t\tspec.loc_port = ip_entry->pdst;\n\t\t}\n\t\tif (ip_mask->psrc) {\n\t\t\tif (ip_mask->psrc != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_REM_PORT;\n\t\t\tspec.rem_port = ip_entry->psrc;\n\t\t}\n\t\tif (ip_mask->tos)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tspec.match_flags = (EFX_FILTER_MATCH_ETHER_TYPE |\n\t\t\t\t    EFX_FILTER_MATCH_IP_PROTO);\n\t\tspec.ether_type = htons(ETH_P_IPV6);\n\t\tspec.ip_proto = flow_type == TCP_V6_FLOW ? IPPROTO_TCP\n\t\t\t\t\t\t\t : IPPROTO_UDP;\n\t\tif (!ip6_mask_is_empty(ip6_mask->ip6dst)) {\n\t\t\tif (!ip6_mask_is_full(ip6_mask->ip6dst))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_HOST;\n\t\t\tmemcpy(spec.loc_host, ip6_entry->ip6dst, sizeof(spec.loc_host));\n\t\t}\n\t\tif (!ip6_mask_is_empty(ip6_mask->ip6src)) {\n\t\t\tif (!ip6_mask_is_full(ip6_mask->ip6src))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_REM_HOST;\n\t\t\tmemcpy(spec.rem_host, ip6_entry->ip6src, sizeof(spec.rem_host));\n\t\t}\n\t\tif (ip6_mask->pdst) {\n\t\t\tif (ip6_mask->pdst != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_PORT;\n\t\t\tspec.loc_port = ip6_entry->pdst;\n\t\t}\n\t\tif (ip6_mask->psrc) {\n\t\t\tif (ip6_mask->psrc != PORT_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_REM_PORT;\n\t\t\tspec.rem_port = ip6_entry->psrc;\n\t\t}\n\t\tif (ip6_mask->tclass)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase IPV4_USER_FLOW:\n\t\tif (uip_mask->l4_4_bytes || uip_mask->tos || uip_mask->ip_ver ||\n\t\t    uip_entry->ip_ver != ETH_RX_NFC_IP4)\n\t\t\treturn -EINVAL;\n\t\tspec.match_flags = EFX_FILTER_MATCH_ETHER_TYPE;\n\t\tspec.ether_type = htons(ETH_P_IP);\n\t\tif (uip_mask->ip4dst) {\n\t\t\tif (uip_mask->ip4dst != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_HOST;\n\t\t\tspec.loc_host[0] = uip_entry->ip4dst;\n\t\t}\n\t\tif (uip_mask->ip4src) {\n\t\t\tif (uip_mask->ip4src != IP4_ADDR_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_REM_HOST;\n\t\t\tspec.rem_host[0] = uip_entry->ip4src;\n\t\t}\n\t\tif (uip_mask->proto) {\n\t\t\tif (uip_mask->proto != IP_PROTO_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_IP_PROTO;\n\t\t\tspec.ip_proto = uip_entry->proto;\n\t\t}\n\t\tbreak;\n\n\tcase IPV6_USER_FLOW:\n\t\tif (uip6_mask->l4_4_bytes || uip6_mask->tclass)\n\t\t\treturn -EINVAL;\n\t\tspec.match_flags = EFX_FILTER_MATCH_ETHER_TYPE;\n\t\tspec.ether_type = htons(ETH_P_IPV6);\n\t\tif (!ip6_mask_is_empty(uip6_mask->ip6dst)) {\n\t\t\tif (!ip6_mask_is_full(uip6_mask->ip6dst))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_HOST;\n\t\t\tmemcpy(spec.loc_host, uip6_entry->ip6dst, sizeof(spec.loc_host));\n\t\t}\n\t\tif (!ip6_mask_is_empty(uip6_mask->ip6src)) {\n\t\t\tif (!ip6_mask_is_full(uip6_mask->ip6src))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_REM_HOST;\n\t\t\tmemcpy(spec.rem_host, uip6_entry->ip6src, sizeof(spec.rem_host));\n\t\t}\n\t\tif (uip6_mask->l4_proto) {\n\t\t\tif (uip6_mask->l4_proto != IP_PROTO_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_IP_PROTO;\n\t\t\tspec.ip_proto = uip6_entry->l4_proto;\n\t\t}\n\t\tbreak;\n\n\tcase ETHER_FLOW:\n\t\tif (!is_zero_ether_addr(mac_mask->h_dest)) {\n\t\t\tif (ether_addr_equal(mac_mask->h_dest,\n\t\t\t\t\t     mac_addr_ig_mask))\n\t\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_MAC_IG;\n\t\t\telse if (is_broadcast_ether_addr(mac_mask->h_dest))\n\t\t\t\tspec.match_flags |= EFX_FILTER_MATCH_LOC_MAC;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tether_addr_copy(spec.loc_mac, mac_entry->h_dest);\n\t\t}\n\t\tif (!is_zero_ether_addr(mac_mask->h_source)) {\n\t\t\tif (!is_broadcast_ether_addr(mac_mask->h_source))\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_REM_MAC;\n\t\t\tether_addr_copy(spec.rem_mac, mac_entry->h_source);\n\t\t}\n\t\tif (mac_mask->h_proto) {\n\t\t\tif (mac_mask->h_proto != ETHER_TYPE_FULL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tspec.match_flags |= EFX_FILTER_MATCH_ETHER_TYPE;\n\t\t\tspec.ether_type = mac_entry->h_proto;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((rule->flow_type & FLOW_EXT) && rule->m_ext.vlan_tci) {\n\t\tif (rule->m_ext.vlan_tci != htons(0xfff))\n\t\t\treturn -EINVAL;\n\t\tspec.match_flags |= EFX_FILTER_MATCH_OUTER_VID;\n\t\tspec.outer_vid = rule->h_ext.vlan_tci;\n\t}\n\n\trc = efx_filter_insert_filter(efx, &spec, true);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trule->location = rc;\n\treturn 0;\n}\n\nint efx_ethtool_set_rxnfc(struct net_device *net_dev,\n\t\t\t  struct ethtool_rxnfc *info)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tif (efx_filter_get_rx_id_limit(efx) == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\treturn efx_ethtool_set_class_rule(efx, &info->fs,\n\t\t\t\t\t\t  info->rss_context);\n\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\treturn efx_filter_remove_id_safe(efx, EFX_FILTER_PRI_MANUAL,\n\t\t\t\t\t\t info->fs.location);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nu32 efx_ethtool_get_rxfh_indir_size(struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\tif (efx->n_rx_channels == 1)\n\t\treturn 0;\n\treturn ARRAY_SIZE(efx->rss_context.rx_indir_table);\n}\n\nu32 efx_ethtool_get_rxfh_key_size(struct net_device *net_dev)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\treturn efx->type->rx_hash_key_size;\n}\n\nint efx_ethtool_get_rxfh(struct net_device *net_dev, u32 *indir, u8 *key,\n\t\t\t u8 *hfunc)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint rc;\n\n\trc = efx->type->rx_pull_rss_config(efx);\n\tif (rc)\n\t\treturn rc;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (indir)\n\t\tmemcpy(indir, efx->rss_context.rx_indir_table,\n\t\t       sizeof(efx->rss_context.rx_indir_table));\n\tif (key)\n\t\tmemcpy(key, efx->rss_context.rx_hash_key,\n\t\t       efx->type->rx_hash_key_size);\n\treturn 0;\n}\n\nint efx_ethtool_set_rxfh(struct net_device *net_dev, const u32 *indir,\n\t\t\t const u8 *key, const u8 hfunc)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\n\t \n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\tif (!indir && !key)\n\t\treturn 0;\n\n\tif (!key)\n\t\tkey = efx->rss_context.rx_hash_key;\n\tif (!indir)\n\t\tindir = efx->rss_context.rx_indir_table;\n\n\treturn efx->type->rx_push_rss_config(efx, true, indir, key);\n}\n\nint efx_ethtool_get_rxfh_context(struct net_device *net_dev, u32 *indir,\n\t\t\t\t u8 *key, u8 *hfunc, u32 rss_context)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tstruct efx_rss_context *ctx;\n\tint rc = 0;\n\n\tif (!efx->type->rx_pull_rss_context_config)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&efx->rss_lock);\n\tctx = efx_find_rss_context_entry(efx, rss_context);\n\tif (!ctx) {\n\t\trc = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\trc = efx->type->rx_pull_rss_context_config(efx, ctx);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (indir)\n\t\tmemcpy(indir, ctx->rx_indir_table, sizeof(ctx->rx_indir_table));\n\tif (key)\n\t\tmemcpy(key, ctx->rx_hash_key, efx->type->rx_hash_key_size);\nout_unlock:\n\tmutex_unlock(&efx->rss_lock);\n\treturn rc;\n}\n\nint efx_ethtool_set_rxfh_context(struct net_device *net_dev,\n\t\t\t\t const u32 *indir, const u8 *key,\n\t\t\t\t const u8 hfunc, u32 *rss_context,\n\t\t\t\t bool delete)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tstruct efx_rss_context *ctx;\n\tbool allocated = false;\n\tint rc;\n\n\tif (!efx->type->rx_push_rss_context_config)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&efx->rss_lock);\n\n\tif (*rss_context == ETH_RXFH_CONTEXT_ALLOC) {\n\t\tif (delete) {\n\t\t\t \n\t\t\trc = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tctx = efx_alloc_rss_context_entry(efx);\n\t\tif (!ctx) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tctx->context_id = EFX_MCDI_RSS_CONTEXT_INVALID;\n\t\t \n\t\tefx_set_default_rx_indir_table(efx, ctx);\n\t\tnetdev_rss_key_fill(ctx->rx_hash_key, sizeof(ctx->rx_hash_key));\n\t\tallocated = true;\n\t} else {\n\t\tctx = efx_find_rss_context_entry(efx, *rss_context);\n\t\tif (!ctx) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (delete) {\n\t\t \n\t\trc = efx->type->rx_push_rss_context_config(efx, ctx, NULL, NULL);\n\t\tif (!rc)\n\t\t\tefx_free_rss_context_entry(ctx);\n\t\tgoto out_unlock;\n\t}\n\n\tif (!key)\n\t\tkey = ctx->rx_hash_key;\n\tif (!indir)\n\t\tindir = ctx->rx_indir_table;\n\n\trc = efx->type->rx_push_rss_context_config(efx, ctx, indir, key);\n\tif (rc && allocated)\n\t\tefx_free_rss_context_entry(ctx);\n\telse\n\t\t*rss_context = ctx->user_id;\nout_unlock:\n\tmutex_unlock(&efx->rss_lock);\n\treturn rc;\n}\n\nint efx_ethtool_reset(struct net_device *net_dev, u32 *flags)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint rc;\n\n\trc = efx->type->map_reset_flags(flags);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn efx_reset(efx, rc);\n}\n\nint efx_ethtool_get_module_eeprom(struct net_device *net_dev,\n\t\t\t\t  struct ethtool_eeprom *ee,\n\t\t\t\t  u8 *data)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint ret;\n\n\tmutex_lock(&efx->mac_lock);\n\tret = efx_mcdi_phy_get_module_eeprom(efx, ee, data);\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn ret;\n}\n\nint efx_ethtool_get_module_info(struct net_device *net_dev,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n\tstruct efx_nic *efx = efx_netdev_priv(net_dev);\n\tint ret;\n\n\tmutex_lock(&efx->mac_lock);\n\tret = efx_mcdi_phy_get_module_info(efx, modinfo);\n\tmutex_unlock(&efx->mac_lock);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}