{
  "module_name": "ef100.c",
  "hash_id": "844c2533af3dd633eb76e32d40976333b6d8df0266860bcfead2a169803aae10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef100.c",
  "human_readable_source": "\n \n\n#include \"net_driver.h\"\n#include <linux/module.h>\n#include \"efx_common.h\"\n#include \"efx_channels.h\"\n#include \"io.h\"\n#include \"ef100_nic.h\"\n#include \"ef100_netdev.h\"\n#include \"ef100_sriov.h\"\n#include \"ef100_regs.h\"\n#include \"ef100.h\"\n\n#define EFX_EF100_PCI_DEFAULT_BAR\t2\n\n \n#define PCI_EXT_CAP_HDR_LENGTH  4\n\n \n#define ESE_GZ_CFGBAR_CONT_CAP_MIN_LENGTH      16\n\nstruct ef100_func_ctl_window {\n\tbool valid;\n\tunsigned int bar;\n\tu64 offset;\n};\n\nstatic int ef100_pci_walk_xilinx_table(struct efx_nic *efx, u64 offset,\n\t\t\t\t       struct ef100_func_ctl_window *result);\n\n \n#define ROUND_DOWN_TO_DWORD(x) (((x) & (~31)) >> 3)\n\n#define EXTRACT_BITS(x, lbn, width) \\\n\t(((x) >> ((lbn) & 31)) & ((1ull << (width)) - 1))\n\nstatic u32 _ef100_pci_get_bar_bits_with_width(struct efx_nic *efx,\n\t\t\t\t\t      int structure_start,\n\t\t\t\t\t      int lbn, int width)\n{\n\tefx_dword_t dword;\n\n\tefx_readd(efx, &dword, structure_start + ROUND_DOWN_TO_DWORD(lbn));\n\n\treturn EXTRACT_BITS(le32_to_cpu(dword.u32[0]), lbn, width);\n}\n\n#define ef100_pci_get_bar_bits(efx, entry_location, bitdef)\t\\\n\t_ef100_pci_get_bar_bits_with_width(efx, entry_location,\t\\\n\t\tESF_GZ_CFGBAR_ ## bitdef ## _LBN,\t\t\\\n\t\tESF_GZ_CFGBAR_ ## bitdef ## _WIDTH)\n\nstatic int ef100_pci_parse_ef100_entry(struct efx_nic *efx, int entry_location,\n\t\t\t\t       struct ef100_func_ctl_window *result)\n{\n\tu64 offset = ef100_pci_get_bar_bits(efx, entry_location, EF100_FUNC_CTL_WIN_OFF) <<\n\t\t\t\t\tESE_GZ_EF100_FUNC_CTL_WIN_OFF_SHIFT;\n\tu32 bar = ef100_pci_get_bar_bits(efx, entry_location, EF100_BAR);\n\n\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t  \"Found EF100 function control window bar=%d offset=0x%llx\\n\",\n\t\t  bar, offset);\n\n\tif (result->valid) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Duplicated EF100 table entry.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bar == ESE_GZ_CFGBAR_EF100_BAR_NUM_EXPANSION_ROM ||\n\t    bar == ESE_GZ_CFGBAR_EF100_BAR_NUM_INVALID) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Bad BAR value of %d in Xilinx capabilities EF100 entry.\\n\",\n\t\t\t  bar);\n\t\treturn -EINVAL;\n\t}\n\n\tresult->bar = bar;\n\tresult->offset = offset;\n\tresult->valid = true;\n\treturn 0;\n}\n\nstatic bool ef100_pci_does_bar_overflow(struct efx_nic *efx, int bar,\n\t\t\t\t\tu64 next_entry)\n{\n\treturn next_entry + ESE_GZ_CFGBAR_ENTRY_HEADER_SIZE >\n\t\t\t\t\tpci_resource_len(efx->pci_dev, bar);\n}\n\n \nstatic int ef100_pci_parse_continue_entry(struct efx_nic *efx, int entry_location,\n\t\t\t\t\t  struct ef100_func_ctl_window *result)\n{\n\tunsigned int previous_bar;\n\tefx_oword_t entry;\n\tu64 offset;\n\tint rc = 0;\n\tu32 bar;\n\n\tefx_reado(efx, &entry, entry_location);\n\n\tbar = EFX_OWORD_FIELD32(entry, ESF_GZ_CFGBAR_CONT_CAP_BAR);\n\n\toffset = EFX_OWORD_FIELD64(entry, ESF_GZ_CFGBAR_CONT_CAP_OFFSET) <<\n\t\tESE_GZ_CONT_CAP_OFFSET_BYTES_SHIFT;\n\n\tprevious_bar = efx->mem_bar;\n\n\tif (bar == ESE_GZ_VSEC_BAR_NUM_EXPANSION_ROM ||\n\t    bar == ESE_GZ_VSEC_BAR_NUM_INVALID) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Bad BAR value of %d in Xilinx capabilities sub-table.\\n\",\n\t\t\t  bar);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bar != previous_bar) {\n\t\tefx_fini_io(efx);\n\n\t\tif (ef100_pci_does_bar_overflow(efx, bar, offset)) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Xilinx table will overrun BAR[%d] offset=0x%llx\\n\",\n\t\t\t\t  bar, offset);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\trc = efx_init_io(efx, bar,\n\t\t\t\t (dma_addr_t)DMA_BIT_MASK(ESF_GZ_TX_SEND_ADDR_WIDTH),\n\t\t\t\t pci_resource_len(efx->pci_dev, bar));\n\t\tif (rc) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Mapping new BAR for Xilinx table failed, rc=%d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ef100_pci_walk_xilinx_table(efx, offset, result);\n\tif (rc)\n\t\treturn rc;\n\n\tif (bar != previous_bar) {\n\t\tefx_fini_io(efx);\n\n\t\t \n\t\trc = efx_init_io(efx, previous_bar,\n\t\t\t\t (dma_addr_t)DMA_BIT_MASK(ESF_GZ_TX_SEND_ADDR_WIDTH),\n\t\t\t\t pci_resource_len(efx->pci_dev, previous_bar));\n\t\tif (rc) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Putting old BAR back failed, rc=%d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ef100_pci_walk_xilinx_table(struct efx_nic *efx, u64 offset,\n\t\t\t\t       struct ef100_func_ctl_window *result)\n{\n\tu64 current_entry = offset;\n\tint rc = 0;\n\n\twhile (true) {\n\t\tu32 id = ef100_pci_get_bar_bits(efx, current_entry, ENTRY_FORMAT);\n\t\tu32 last = ef100_pci_get_bar_bits(efx, current_entry, ENTRY_LAST);\n\t\tu32 rev = ef100_pci_get_bar_bits(efx, current_entry, ENTRY_REV);\n\t\tu32 entry_size;\n\n\t\tif (id == ESE_GZ_CFGBAR_ENTRY_LAST)\n\t\t\treturn 0;\n\n\t\tentry_size = ef100_pci_get_bar_bits(efx, current_entry, ENTRY_SIZE);\n\n\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t  \"Seen Xilinx table entry 0x%x size 0x%x at 0x%llx in BAR[%d]\\n\",\n\t\t\t  id, entry_size, current_entry, efx->mem_bar);\n\n\t\tif (entry_size < sizeof(u32) * 2) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Xilinx table entry too short len=0x%x\\n\", entry_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase ESE_GZ_CFGBAR_ENTRY_EF100:\n\t\t\tif (rev != ESE_GZ_CFGBAR_ENTRY_REV_EF100 ||\n\t\t\t    entry_size < ESE_GZ_CFGBAR_ENTRY_SIZE_EF100) {\n\t\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t\t  \"Bad length or rev for EF100 entry in Xilinx capabilities table. entry_size=%d rev=%d.\\n\",\n\t\t\t\t\t  entry_size, rev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\trc = ef100_pci_parse_ef100_entry(efx, current_entry,\n\t\t\t\t\t\t\t result);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase ESE_GZ_CFGBAR_ENTRY_CONT_CAP_ADDR:\n\t\t\tif (rev != 0 || entry_size < ESE_GZ_CFGBAR_CONT_CAP_MIN_LENGTH) {\n\t\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t\t  \"Bad length or rev for continue entry in Xilinx capabilities table. entry_size=%d rev=%d.\\n\",\n\t\t\t\t\t  entry_size, rev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\trc = ef100_pci_parse_continue_entry(efx, current_entry, result);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (last)\n\t\t\treturn 0;\n\n\t\tcurrent_entry += entry_size;\n\n\t\tif (ef100_pci_does_bar_overflow(efx, efx->mem_bar, current_entry)) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Xilinx table overrun at position=0x%llx.\\n\",\n\t\t\t\t  current_entry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n}\n\nstatic int _ef100_pci_get_config_bits_with_width(struct efx_nic *efx,\n\t\t\t\t\t\t int structure_start, int lbn,\n\t\t\t\t\t\t int width, u32 *result)\n{\n\tint rc, pos = structure_start + ROUND_DOWN_TO_DWORD(lbn);\n\tu32 temp;\n\n\trc = pci_read_config_dword(efx->pci_dev, pos, &temp);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Failed to read PCI config dword at %d\\n\",\n\t\t\t  pos);\n\t\treturn rc;\n\t}\n\n\t*result = EXTRACT_BITS(temp, lbn, width);\n\n\treturn 0;\n}\n\n#define ef100_pci_get_config_bits(efx, entry_location, bitdef, result)\t\\\n\t_ef100_pci_get_config_bits_with_width(efx, entry_location,\t\\\n\t\t ESF_GZ_VSEC_ ## bitdef ## _LBN,\t\t\t\\\n\t\t ESF_GZ_VSEC_ ## bitdef ## _WIDTH, result)\n\n \nstatic int ef100_pci_parse_xilinx_cap(struct efx_nic *efx, int vndr_cap,\n\t\t\t\t      bool has_offset_hi,\n\t\t\t\t      struct ef100_func_ctl_window *result)\n{\n\tu32 offset_high = 0;\n\tu32 offset_lo = 0;\n\tu64 offset = 0;\n\tu32 bar = 0;\n\tint rc = 0;\n\n\trc = ef100_pci_get_config_bits(efx, vndr_cap, TBL_BAR, &bar);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Failed to read ESF_GZ_VSEC_TBL_BAR, rc=%d\\n\",\n\t\t\t  rc);\n\t\treturn rc;\n\t}\n\n\tif (bar == ESE_GZ_CFGBAR_CONT_CAP_BAR_NUM_EXPANSION_ROM ||\n\t    bar == ESE_GZ_CFGBAR_CONT_CAP_BAR_NUM_INVALID) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Bad BAR value of %d in Xilinx capabilities sub-table.\\n\",\n\t\t\t  bar);\n\t\treturn -EINVAL;\n\t}\n\n\trc = ef100_pci_get_config_bits(efx, vndr_cap, TBL_OFF_LO, &offset_lo);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Failed to read ESF_GZ_VSEC_TBL_OFF_LO, rc=%d\\n\",\n\t\t\t  rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (has_offset_hi) {\n\t\trc = ef100_pci_get_config_bits(efx, vndr_cap, TBL_OFF_HI, &offset_high);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Failed to read ESF_GZ_VSEC_TBL_OFF_HI, rc=%d\\n\",\n\t\t\t\t  rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\toffset = (((u64)offset_lo) << ESE_GZ_VSEC_TBL_OFF_LO_BYTES_SHIFT) |\n\t\t (((u64)offset_high) << ESE_GZ_VSEC_TBL_OFF_HI_BYTES_SHIFT);\n\n\tif (offset > pci_resource_len(efx->pci_dev, bar) - sizeof(u32) * 2) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Xilinx table will overrun BAR[%d] offset=0x%llx\\n\",\n\t\t\t  bar, offset);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = efx_init_io(efx, bar,\n\t\t\t (dma_addr_t)DMA_BIT_MASK(ESF_GZ_TX_SEND_ADDR_WIDTH),\n\t\t\t pci_resource_len(efx->pci_dev, bar));\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"efx_init_io failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = ef100_pci_walk_xilinx_table(efx, offset, result);\n\n\t \n\tefx_fini_io(efx);\n\treturn rc;\n}\n\n \nstatic int ef100_pci_find_func_ctrl_window(struct efx_nic *efx,\n\t\t\t\t\t   struct ef100_func_ctl_window *result)\n{\n\tint num_xilinx_caps = 0;\n\tint cap = 0;\n\n\tresult->valid = false;\n\n\twhile ((cap = pci_find_next_ext_capability(efx->pci_dev, cap, PCI_EXT_CAP_ID_VNDR)) != 0) {\n\t\tint vndr_cap = cap + PCI_EXT_CAP_HDR_LENGTH;\n\t\tu32 vsec_ver = 0;\n\t\tu32 vsec_len = 0;\n\t\tu32 vsec_id = 0;\n\t\tint rc = 0;\n\n\t\tnum_xilinx_caps++;\n\n\t\trc = ef100_pci_get_config_bits(efx, vndr_cap, ID, &vsec_id);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Failed to read ESF_GZ_VSEC_ID, rc=%d\\n\",\n\t\t\t\t  rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = ef100_pci_get_config_bits(efx, vndr_cap, VER, &vsec_ver);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Failed to read ESF_GZ_VSEC_VER, rc=%d\\n\",\n\t\t\t\t  rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\trc = ef100_pci_get_config_bits(efx, vndr_cap, LEN, &vsec_len);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t\t  \"Failed to read ESF_GZ_VSEC_LEN, rc=%d\\n\",\n\t\t\t\t  rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (vsec_id == ESE_GZ_XILINX_VSEC_ID &&\n\t\t    vsec_ver == ESE_GZ_VSEC_VER_XIL_CFGBAR &&\n\t\t    vsec_len >= ESE_GZ_VSEC_LEN_MIN) {\n\t\t\tbool has_offset_hi = (vsec_len >= ESE_GZ_VSEC_LEN_HIGH_OFFT);\n\n\t\t\trc = ef100_pci_parse_xilinx_cap(efx, vndr_cap,\n\t\t\t\t\t\t\thas_offset_hi, result);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (num_xilinx_caps && !result->valid) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"Seen %d Xilinx tables, but no EF100 entry.\\n\",\n\t\t\t  num_xilinx_caps);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ef100_pci_remove(struct pci_dev *pci_dev)\n{\n\tstruct efx_nic *efx = pci_get_drvdata(pci_dev);\n\tstruct efx_probe_data *probe_data;\n\n\tif (!efx)\n\t\treturn;\n\n\tprobe_data = container_of(efx, struct efx_probe_data, efx);\n\tef100_remove_netdev(probe_data);\n#ifdef CONFIG_SFC_SRIOV\n\tefx_fini_struct_tc(efx);\n#endif\n\n\tef100_remove(efx);\n\tefx_fini_io(efx);\n\n\tpci_dbg(pci_dev, \"shutdown successful\\n\");\n\n\tpci_set_drvdata(pci_dev, NULL);\n\tefx_fini_struct(efx);\n\tkfree(probe_data);\n};\n\nstatic int ef100_pci_probe(struct pci_dev *pci_dev,\n\t\t\t   const struct pci_device_id *entry)\n{\n\tstruct ef100_func_ctl_window fcw = { 0 };\n\tstruct efx_probe_data *probe_data;\n\tstruct efx_nic *efx;\n\tint rc;\n\n\t \n\tprobe_data = kzalloc(sizeof(*probe_data), GFP_KERNEL);\n\tif (!probe_data)\n\t\treturn -ENOMEM;\n\tprobe_data->pci_dev = pci_dev;\n\tefx = &probe_data->efx;\n\n\tefx->type = (const struct efx_nic_type *)entry->driver_data;\n\n\tefx->pci_dev = pci_dev;\n\tpci_set_drvdata(pci_dev, efx);\n\trc = efx_init_struct(efx, pci_dev);\n\tif (rc)\n\t\tgoto fail;\n\n\tefx->vi_stride = EF100_DEFAULT_VI_STRIDE;\n\tpci_info(pci_dev, \"Solarflare EF100 NIC detected\\n\");\n\n\trc = ef100_pci_find_func_ctrl_window(efx, &fcw);\n\tif (rc) {\n\t\tpci_err(pci_dev,\n\t\t\t\"Error looking for ef100 function control window, rc=%d\\n\",\n\t\t\trc);\n\t\tgoto fail;\n\t}\n\n\tif (!fcw.valid) {\n\t\t \n\t\tfcw.bar = EFX_EF100_PCI_DEFAULT_BAR;\n\t\tfcw.offset = 0;\n\t\tfcw.valid = true;\n\t}\n\n\tif (fcw.offset > pci_resource_len(efx->pci_dev, fcw.bar) - ESE_GZ_FCW_LEN) {\n\t\tpci_err(pci_dev, \"Func control window overruns BAR\\n\");\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\trc = efx_init_io(efx, fcw.bar,\n\t\t\t (dma_addr_t)DMA_BIT_MASK(ESF_GZ_TX_SEND_ADDR_WIDTH),\n\t\t\t pci_resource_len(efx->pci_dev, fcw.bar));\n\tif (rc)\n\t\tgoto fail;\n\n\tefx->reg_base = fcw.offset;\n\n\trc = efx->type->probe(efx);\n\tif (rc)\n\t\tgoto fail;\n\n\tefx->state = STATE_PROBED;\n\trc = ef100_probe_netdev(probe_data);\n\tif (rc)\n\t\tgoto fail;\n\n\tpci_dbg(pci_dev, \"initialisation successful\\n\");\n\n\treturn 0;\n\nfail:\n\tef100_pci_remove(pci_dev);\n\treturn rc;\n}\n\n#ifdef CONFIG_SFC_SRIOV\nstatic int ef100_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\n{\n\tstruct efx_nic *efx = pci_get_drvdata(dev);\n\tint rc;\n\n\tif (efx->type->sriov_configure) {\n\t\trc = efx->type->sriov_configure(efx, num_vfs);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\telse\n\t\t\treturn num_vfs;\n\t}\n\treturn -ENOENT;\n}\n#endif\n\n \nstatic const struct pci_device_id ef100_pci_table[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_XILINX, 0x0100),   \n\t\t.driver_data = (unsigned long) &ef100_pf_nic_type },\n\t{PCI_DEVICE(PCI_VENDOR_ID_XILINX, 0x1100),   \n\t\t.driver_data = (unsigned long) &ef100_vf_nic_type },\n\t{0}                      \n};\n\nstruct pci_driver ef100_pci_driver = {\n\t.name           = \"sfc_ef100\",\n\t.id_table       = ef100_pci_table,\n\t.probe          = ef100_pci_probe,\n\t.remove         = ef100_pci_remove,\n#ifdef CONFIG_SFC_SRIOV\n\t.sriov_configure = ef100_pci_sriov_configure,\n#endif\n\t.err_handler    = &efx_err_handlers,\n};\n\nMODULE_DEVICE_TABLE(pci, ef100_pci_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}