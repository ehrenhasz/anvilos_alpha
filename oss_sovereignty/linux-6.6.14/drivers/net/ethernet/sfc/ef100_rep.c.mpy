{
  "module_name": "ef100_rep.c",
  "hash_id": "3c41325ed4cabf425cf1670f7f8159e5b20c858758e19709131f72323a255b1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/ef100_rep.c",
  "human_readable_source": "\n \n\n#include <linux/rhashtable.h>\n#include \"ef100_rep.h\"\n#include \"ef100_netdev.h\"\n#include \"ef100_nic.h\"\n#include \"mae.h\"\n#include \"rx_common.h\"\n#include \"tc_bindings.h\"\n#include \"efx_devlink.h\"\n\n#define EFX_EF100_REP_DRIVER\t\"efx_ef100_rep\"\n\n#define EFX_REP_DEFAULT_PSEUDO_RING_SIZE\t64\n\nstatic int efx_ef100_rep_poll(struct napi_struct *napi, int weight);\n\nstatic int efx_ef100_rep_init_struct(struct efx_nic *efx, struct efx_rep *efv,\n\t\t\t\t     unsigned int i)\n{\n\tefv->parent = efx;\n\tefv->idx = i;\n\tINIT_LIST_HEAD(&efv->list);\n\tefv->dflt.fw_id = MC_CMD_MAE_ACTION_RULE_INSERT_OUT_ACTION_RULE_ID_NULL;\n\tINIT_LIST_HEAD(&efv->dflt.acts.list);\n\tINIT_LIST_HEAD(&efv->rx_list);\n\tspin_lock_init(&efv->rx_lock);\n\tefv->msg_enable = NETIF_MSG_DRV | NETIF_MSG_PROBE |\n\t\t\t  NETIF_MSG_LINK | NETIF_MSG_IFDOWN |\n\t\t\t  NETIF_MSG_IFUP | NETIF_MSG_RX_ERR |\n\t\t\t  NETIF_MSG_TX_ERR | NETIF_MSG_HW;\n\treturn 0;\n}\n\nstatic int efx_ef100_rep_open(struct net_device *net_dev)\n{\n\tstruct efx_rep *efv = netdev_priv(net_dev);\n\n\tnetif_napi_add(net_dev, &efv->napi, efx_ef100_rep_poll);\n\tnapi_enable(&efv->napi);\n\treturn 0;\n}\n\nstatic int efx_ef100_rep_close(struct net_device *net_dev)\n{\n\tstruct efx_rep *efv = netdev_priv(net_dev);\n\n\tnapi_disable(&efv->napi);\n\tnetif_napi_del(&efv->napi);\n\treturn 0;\n}\n\nstatic netdev_tx_t efx_ef100_rep_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct efx_rep *efv = netdev_priv(dev);\n\tstruct efx_nic *efx = efv->parent;\n\tnetdev_tx_t rc;\n\n\t \n\tatomic64_inc(&efv->stats.tx_packets);\n\tatomic64_add(skb->len, &efv->stats.tx_bytes);\n\tnetif_tx_lock(efx->net_dev);\n\trc = __ef100_hard_start_xmit(skb, efx, dev, efv);\n\tnetif_tx_unlock(efx->net_dev);\n\treturn rc;\n}\n\nstatic int efx_ef100_rep_get_port_parent_id(struct net_device *dev,\n\t\t\t\t\t    struct netdev_phys_item_id *ppid)\n{\n\tstruct efx_rep *efv = netdev_priv(dev);\n\tstruct efx_nic *efx = efv->parent;\n\tstruct ef100_nic_data *nic_data;\n\n\tnic_data = efx->nic_data;\n\t \n\tppid->id_len = sizeof(nic_data->port_id);\n\tmemcpy(ppid->id, nic_data->port_id, sizeof(nic_data->port_id));\n\treturn 0;\n}\n\nstatic int efx_ef100_rep_get_phys_port_name(struct net_device *dev,\n\t\t\t\t\t    char *buf, size_t len)\n{\n\tstruct efx_rep *efv = netdev_priv(dev);\n\tstruct efx_nic *efx = efv->parent;\n\tstruct ef100_nic_data *nic_data;\n\tint ret;\n\n\tnic_data = efx->nic_data;\n\tret = snprintf(buf, len, \"p%upf%uvf%u\", efx->port_num,\n\t\t       nic_data->pf_index, efv->idx);\n\tif (ret >= len)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int efx_ef100_rep_setup_tc(struct net_device *net_dev,\n\t\t\t\t  enum tc_setup_type type, void *type_data)\n{\n\tstruct efx_rep *efv = netdev_priv(net_dev);\n\tstruct efx_nic *efx = efv->parent;\n\n\tif (type == TC_SETUP_CLSFLOWER)\n\t\treturn efx_tc_flower(efx, net_dev, type_data, efv);\n\tif (type == TC_SETUP_BLOCK)\n\t\treturn efx_tc_setup_block(net_dev, efx, type_data, efv);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void efx_ef100_rep_get_stats64(struct net_device *dev,\n\t\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tstruct efx_rep *efv = netdev_priv(dev);\n\n\tstats->rx_packets = atomic64_read(&efv->stats.rx_packets);\n\tstats->tx_packets = atomic64_read(&efv->stats.tx_packets);\n\tstats->rx_bytes = atomic64_read(&efv->stats.rx_bytes);\n\tstats->tx_bytes = atomic64_read(&efv->stats.tx_bytes);\n\tstats->rx_dropped = atomic64_read(&efv->stats.rx_dropped);\n\tstats->tx_errors = atomic64_read(&efv->stats.tx_errors);\n}\n\nconst struct net_device_ops efx_ef100_rep_netdev_ops = {\n\t.ndo_open\t\t= efx_ef100_rep_open,\n\t.ndo_stop\t\t= efx_ef100_rep_close,\n\t.ndo_start_xmit\t\t= efx_ef100_rep_xmit,\n\t.ndo_get_port_parent_id\t= efx_ef100_rep_get_port_parent_id,\n\t.ndo_get_phys_port_name\t= efx_ef100_rep_get_phys_port_name,\n\t.ndo_get_stats64\t= efx_ef100_rep_get_stats64,\n\t.ndo_setup_tc\t\t= efx_ef100_rep_setup_tc,\n};\n\nstatic void efx_ef100_rep_get_drvinfo(struct net_device *dev,\n\t\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, EFX_EF100_REP_DRIVER, sizeof(drvinfo->driver));\n}\n\nstatic u32 efx_ef100_rep_ethtool_get_msglevel(struct net_device *net_dev)\n{\n\tstruct efx_rep *efv = netdev_priv(net_dev);\n\n\treturn efv->msg_enable;\n}\n\nstatic void efx_ef100_rep_ethtool_set_msglevel(struct net_device *net_dev,\n\t\t\t\t\t       u32 msg_enable)\n{\n\tstruct efx_rep *efv = netdev_priv(net_dev);\n\n\tefv->msg_enable = msg_enable;\n}\n\nstatic void efx_ef100_rep_ethtool_get_ringparam(struct net_device *net_dev,\n\t\t\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\t\t\tstruct kernel_ethtool_ringparam *kring,\n\t\t\t\t\t\tstruct netlink_ext_ack *ext_ack)\n{\n\tstruct efx_rep *efv = netdev_priv(net_dev);\n\n\tring->rx_max_pending = U32_MAX;\n\tring->rx_pending = efv->rx_pring_size;\n}\n\nstatic int efx_ef100_rep_ethtool_set_ringparam(struct net_device *net_dev,\n\t\t\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t\t\t       struct kernel_ethtool_ringparam *kring,\n\t\t\t\t\t       struct netlink_ext_ack *ext_ack)\n{\n\tstruct efx_rep *efv = netdev_priv(net_dev);\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending || ring->tx_pending)\n\t\treturn -EINVAL;\n\n\tefv->rx_pring_size = ring->rx_pending;\n\treturn 0;\n}\n\nstatic const struct ethtool_ops efx_ef100_rep_ethtool_ops = {\n\t.get_drvinfo\t\t= efx_ef100_rep_get_drvinfo,\n\t.get_msglevel\t\t= efx_ef100_rep_ethtool_get_msglevel,\n\t.set_msglevel\t\t= efx_ef100_rep_ethtool_set_msglevel,\n\t.get_ringparam\t\t= efx_ef100_rep_ethtool_get_ringparam,\n\t.set_ringparam\t\t= efx_ef100_rep_ethtool_set_ringparam,\n};\n\nstatic struct efx_rep *efx_ef100_rep_create_netdev(struct efx_nic *efx,\n\t\t\t\t\t\t   unsigned int i)\n{\n\tstruct net_device *net_dev;\n\tstruct efx_rep *efv;\n\tint rc;\n\n\tnet_dev = alloc_etherdev_mq(sizeof(*efv), 1);\n\tif (!net_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tefv = netdev_priv(net_dev);\n\trc = efx_ef100_rep_init_struct(efx, efv, i);\n\tif (rc)\n\t\tgoto fail1;\n\tefv->net_dev = net_dev;\n\trtnl_lock();\n\tspin_lock_bh(&efx->vf_reps_lock);\n\tlist_add_tail(&efv->list, &efx->vf_reps);\n\tspin_unlock_bh(&efx->vf_reps_lock);\n\tif (netif_running(efx->net_dev) && efx->state == STATE_NET_UP) {\n\t\tnetif_device_attach(net_dev);\n\t\tnetif_carrier_on(net_dev);\n\t} else {\n\t\tnetif_carrier_off(net_dev);\n\t\tnetif_tx_stop_all_queues(net_dev);\n\t}\n\trtnl_unlock();\n\n\tnet_dev->netdev_ops = &efx_ef100_rep_netdev_ops;\n\tnet_dev->ethtool_ops = &efx_ef100_rep_ethtool_ops;\n\tnet_dev->min_mtu = EFX_MIN_MTU;\n\tnet_dev->max_mtu = EFX_MAX_MTU;\n\tnet_dev->features |= NETIF_F_LLTX;\n\tnet_dev->hw_features |= NETIF_F_LLTX;\n\treturn efv;\nfail1:\n\tfree_netdev(net_dev);\n\treturn ERR_PTR(rc);\n}\n\nstatic int efx_ef100_configure_rep(struct efx_rep *efv)\n{\n\tstruct efx_nic *efx = efv->parent;\n\tint rc;\n\n\tefv->rx_pring_size = EFX_REP_DEFAULT_PSEUDO_RING_SIZE;\n\t \n\trc = efx_mae_lookup_mport(efx, efv->idx, &efv->mport);\n\tif (rc)\n\t\treturn rc;\n\tpci_dbg(efx->pci_dev, \"VF %u has mport ID %#x\\n\", efv->idx, efv->mport);\n\t \n\tWARN_ON(efv->mport >> 16);\n\n\treturn efx_tc_configure_default_rule_rep(efv);\n}\n\nstatic void efx_ef100_deconfigure_rep(struct efx_rep *efv)\n{\n\tstruct efx_nic *efx = efv->parent;\n\n\tefx_tc_deconfigure_default_rule(efx, &efv->dflt);\n}\n\nstatic void efx_ef100_rep_destroy_netdev(struct efx_rep *efv)\n{\n\tstruct efx_nic *efx = efv->parent;\n\n\trtnl_lock();\n\tspin_lock_bh(&efx->vf_reps_lock);\n\tlist_del(&efv->list);\n\tspin_unlock_bh(&efx->vf_reps_lock);\n\trtnl_unlock();\n\tsynchronize_rcu();\n\tfree_netdev(efv->net_dev);\n}\n\nint efx_ef100_vfrep_create(struct efx_nic *efx, unsigned int i)\n{\n\tstruct efx_rep *efv;\n\tint rc;\n\n\tefv = efx_ef100_rep_create_netdev(efx, i);\n\tif (IS_ERR(efv)) {\n\t\trc = PTR_ERR(efv);\n\t\tpci_err(efx->pci_dev,\n\t\t\t\"Failed to create representor for VF %d, rc %d\\n\", i,\n\t\t\trc);\n\t\treturn rc;\n\t}\n\trc = efx_ef100_configure_rep(efv);\n\tif (rc) {\n\t\tpci_err(efx->pci_dev,\n\t\t\t\"Failed to configure representor for VF %d, rc %d\\n\",\n\t\t\ti, rc);\n\t\tgoto fail1;\n\t}\n\tef100_rep_set_devlink_port(efv);\n\trc = register_netdev(efv->net_dev);\n\tif (rc) {\n\t\tpci_err(efx->pci_dev,\n\t\t\t\"Failed to register representor for VF %d, rc %d\\n\",\n\t\t\ti, rc);\n\t\tgoto fail2;\n\t}\n\tpci_dbg(efx->pci_dev, \"Representor for VF %d is %s\\n\", i,\n\t\tefv->net_dev->name);\n\treturn 0;\nfail2:\n\tef100_rep_unset_devlink_port(efv);\n\tefx_ef100_deconfigure_rep(efv);\nfail1:\n\tefx_ef100_rep_destroy_netdev(efv);\n\treturn rc;\n}\n\nvoid efx_ef100_vfrep_destroy(struct efx_nic *efx, struct efx_rep *efv)\n{\n\tstruct net_device *rep_dev;\n\n\trep_dev = efv->net_dev;\n\tif (!rep_dev)\n\t\treturn;\n\tnetif_dbg(efx, drv, rep_dev, \"Removing VF representor\\n\");\n\tunregister_netdev(rep_dev);\n\tef100_rep_unset_devlink_port(efv);\n\tefx_ef100_deconfigure_rep(efv);\n\tefx_ef100_rep_destroy_netdev(efv);\n}\n\nvoid efx_ef100_fini_vfreps(struct efx_nic *efx)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tstruct efx_rep *efv, *next;\n\n\tif (!nic_data->grp_mae)\n\t\treturn;\n\n\tlist_for_each_entry_safe(efv, next, &efx->vf_reps, list)\n\t\tefx_ef100_vfrep_destroy(efx, efv);\n}\n\nstatic bool ef100_mport_is_pcie_vnic(struct mae_mport_desc *mport_desc)\n{\n\treturn mport_desc->mport_type == MAE_MPORT_DESC_MPORT_TYPE_VNIC &&\n\t       mport_desc->vnic_client_type == MAE_MPORT_DESC_VNIC_CLIENT_TYPE_FUNCTION;\n}\n\nbool ef100_mport_on_local_intf(struct efx_nic *efx,\n\t\t\t       struct mae_mport_desc *mport_desc)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tbool pcie_func;\n\n\tpcie_func = ef100_mport_is_pcie_vnic(mport_desc);\n\n\treturn nic_data->have_local_intf && pcie_func &&\n\t\t     mport_desc->interface_idx == nic_data->local_mae_intf;\n}\n\nbool ef100_mport_is_vf(struct mae_mport_desc *mport_desc)\n{\n\tbool pcie_func;\n\n\tpcie_func = ef100_mport_is_pcie_vnic(mport_desc);\n\treturn pcie_func && (mport_desc->vf_idx != MAE_MPORT_DESC_VF_IDX_NULL);\n}\n\nvoid efx_ef100_init_reps(struct efx_nic *efx)\n{\n\tstruct ef100_nic_data *nic_data = efx->nic_data;\n\tint rc;\n\n\tnic_data->have_local_intf = false;\n\trc = efx_mae_enumerate_mports(efx);\n\tif (rc)\n\t\tpci_warn(efx->pci_dev,\n\t\t\t \"Could not enumerate mports (rc=%d), are we admin?\",\n\t\t\t rc);\n}\n\nvoid efx_ef100_fini_reps(struct efx_nic *efx)\n{\n\tstruct efx_mae *mae = efx->mae;\n\n\trhashtable_free_and_destroy(&mae->mports_ht, efx_mae_remove_mport,\n\t\t\t\t    NULL);\n}\n\nstatic int efx_ef100_rep_poll(struct napi_struct *napi, int weight)\n{\n\tstruct efx_rep *efv = container_of(napi, struct efx_rep, napi);\n\tunsigned int read_index;\n\tstruct list_head head;\n\tstruct sk_buff *skb;\n\tbool need_resched;\n\tint spent = 0;\n\n\tINIT_LIST_HEAD(&head);\n\t \n\tspin_lock_bh(&efv->rx_lock);\n\tread_index = efv->write_index;\n\twhile (spent < weight && !list_empty(&efv->rx_list)) {\n\t\tskb = list_first_entry(&efv->rx_list, struct sk_buff, list);\n\t\tlist_del(&skb->list);\n\t\tlist_add_tail(&skb->list, &head);\n\t\tspent++;\n\t}\n\tspin_unlock_bh(&efv->rx_lock);\n\t \n\tnetif_receive_skb_list(&head);\n\tif (spent < weight)\n\t\tif (napi_complete_done(napi, spent)) {\n\t\t\tspin_lock_bh(&efv->rx_lock);\n\t\t\tefv->read_index = read_index;\n\t\t\t \n\t\t\tneed_resched = efv->write_index != read_index;\n\t\t\tspin_unlock_bh(&efv->rx_lock);\n\t\t\tif (need_resched)\n\t\t\t\tnapi_schedule(&efv->napi);\n\t\t}\n\treturn spent;\n}\n\nvoid efx_ef100_rep_rx_packet(struct efx_rep *efv, struct efx_rx_buffer *rx_buf)\n{\n\tu8 *eh = efx_rx_buf_va(rx_buf);\n\tstruct sk_buff *skb;\n\tbool primed;\n\n\t \n\tif (efv->write_index - READ_ONCE(efv->read_index) > efv->rx_pring_size) {\n\t\tatomic64_inc(&efv->stats.rx_dropped);\n\t\tif (net_ratelimit())\n\t\t\tnetif_dbg(efv->parent, rx_err, efv->net_dev,\n\t\t\t\t  \"nodesc-dropped packet of length %u\\n\",\n\t\t\t\t  rx_buf->len);\n\t\treturn;\n\t}\n\n\tskb = netdev_alloc_skb(efv->net_dev, rx_buf->len);\n\tif (!skb) {\n\t\tatomic64_inc(&efv->stats.rx_dropped);\n\t\tif (net_ratelimit())\n\t\t\tnetif_dbg(efv->parent, rx_err, efv->net_dev,\n\t\t\t\t  \"noskb-dropped packet of length %u\\n\",\n\t\t\t\t  rx_buf->len);\n\t\treturn;\n\t}\n\tmemcpy(skb->data, eh, rx_buf->len);\n\t__skb_put(skb, rx_buf->len);\n\n\tskb_record_rx_queue(skb, 0);  \n\n\t \n\tskb->protocol = eth_type_trans(skb, efv->net_dev);\n\n\tskb_checksum_none_assert(skb);\n\n\tatomic64_inc(&efv->stats.rx_packets);\n\tatomic64_add(rx_buf->len, &efv->stats.rx_bytes);\n\n\t \n\tspin_lock_bh(&efv->rx_lock);\n\tprimed = efv->read_index == efv->write_index;\n\tlist_add_tail(&skb->list, &efv->rx_list);\n\tefv->write_index++;\n\tspin_unlock_bh(&efv->rx_lock);\n\t \n\tif (primed)\n\t\tnapi_schedule(&efv->napi);\n}\n\nstruct efx_rep *efx_ef100_find_rep_by_mport(struct efx_nic *efx, u16 mport)\n{\n\tstruct efx_rep *efv, *out = NULL;\n\n\t \n\tspin_lock_bh(&efx->vf_reps_lock);\n\tlist_for_each_entry(efv, &efx->vf_reps, list)\n\t\tif (efv->mport == mport) {\n\t\t\tout = efv;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock_bh(&efx->vf_reps_lock);\n\treturn out;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}