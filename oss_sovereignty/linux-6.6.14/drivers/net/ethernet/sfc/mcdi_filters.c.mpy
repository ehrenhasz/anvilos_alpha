{
  "module_name": "mcdi_filters.c",
  "hash_id": "02f34049411fb5e573d3ac0fe372669e94d0ee9f0fe7576247efc1b14452e160",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sfc/mcdi_filters.c",
  "human_readable_source": "\n \n\n#include \"mcdi_filters.h\"\n#include \"mcdi.h\"\n#include \"nic.h\"\n#include \"rx_common.h\"\n\n \n \n#define EFX_EF10_MAX_SHARED_RSS_CONTEXT_SIZE 64UL\n\n#define EFX_EF10_FILTER_ID_INVALID 0xffff\n\n \n#define EFX_EF10_FILTER_SEARCH_LIMIT 200\n\nstatic struct efx_filter_spec *\nefx_mcdi_filter_entry_spec(const struct efx_mcdi_filter_table *table,\n\t\t\t   unsigned int filter_idx)\n{\n\treturn (struct efx_filter_spec *)(table->entry[filter_idx].spec &\n\t\t\t\t\t  ~EFX_EF10_FILTER_FLAGS);\n}\n\nstatic unsigned int\nefx_mcdi_filter_entry_flags(const struct efx_mcdi_filter_table *table,\n\t\t\t   unsigned int filter_idx)\n{\n\treturn table->entry[filter_idx].spec & EFX_EF10_FILTER_FLAGS;\n}\n\nstatic u32 efx_mcdi_filter_get_unsafe_id(u32 filter_id)\n{\n\tWARN_ON_ONCE(filter_id == EFX_EF10_FILTER_ID_INVALID);\n\treturn filter_id & (EFX_MCDI_FILTER_TBL_ROWS - 1);\n}\n\nstatic unsigned int efx_mcdi_filter_get_unsafe_pri(u32 filter_id)\n{\n\treturn filter_id / (EFX_MCDI_FILTER_TBL_ROWS * 2);\n}\n\nstatic u32 efx_mcdi_filter_make_filter_id(unsigned int pri, u16 idx)\n{\n\treturn pri * EFX_MCDI_FILTER_TBL_ROWS * 2 + idx;\n}\n\n \nstatic bool efx_mcdi_filter_is_exclusive(const struct efx_filter_spec *spec)\n{\n\tif (spec->match_flags & EFX_FILTER_MATCH_LOC_MAC &&\n\t    !is_multicast_ether_addr(spec->loc_mac))\n\t\treturn true;\n\n\tif ((spec->match_flags &\n\t     (EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_LOC_HOST)) ==\n\t    (EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_LOC_HOST)) {\n\t\tif (spec->ether_type == htons(ETH_P_IP) &&\n\t\t    !ipv4_is_multicast(spec->loc_host[0]))\n\t\t\treturn true;\n\t\tif (spec->ether_type == htons(ETH_P_IPV6) &&\n\t\t    ((const u8 *)spec->loc_host)[0] != 0xff)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void\nefx_mcdi_filter_set_entry(struct efx_mcdi_filter_table *table,\n\t\t\t  unsigned int filter_idx,\n\t\t\t  const struct efx_filter_spec *spec,\n\t\t\t  unsigned int flags)\n{\n\ttable->entry[filter_idx].spec =\t(unsigned long)spec | flags;\n}\n\nstatic void\nefx_mcdi_filter_push_prep_set_match_fields(struct efx_nic *efx,\n\t\t\t\t\t   const struct efx_filter_spec *spec,\n\t\t\t\t\t   efx_dword_t *inbuf)\n{\n\tenum efx_encap_type encap_type = efx_filter_get_encap_type(spec);\n\tu32 match_fields = 0, uc_match, mc_match;\n\n\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_OP,\n\t\t       efx_mcdi_filter_is_exclusive(spec) ?\n\t\t       MC_CMD_FILTER_OP_IN_OP_INSERT :\n\t\t       MC_CMD_FILTER_OP_IN_OP_SUBSCRIBE);\n\n\t \n#define COPY_VALUE(value, mcdi_field)\t\t\t\t\t     \\\n\tdo {\t\t\t\t\t\t\t     \\\n\t\tmatch_fields |=\t\t\t\t\t     \\\n\t\t\t1 << MC_CMD_FILTER_OP_IN_MATCH_ ##\t     \\\n\t\t\tmcdi_field ## _LBN;\t\t\t     \\\n\t\tBUILD_BUG_ON(\t\t\t\t\t     \\\n\t\t\tMC_CMD_FILTER_OP_IN_ ## mcdi_field ## _LEN < \\\n\t\t\tsizeof(value));\t\t\t\t     \\\n\t\tmemcpy(MCDI_PTR(inbuf, FILTER_OP_IN_ ##\tmcdi_field), \\\n\t\t       &value, sizeof(value));\t\t\t     \\\n\t} while (0)\n#define COPY_FIELD(gen_flag, gen_field, mcdi_field)\t\t\t     \\\n\tif (spec->match_flags & EFX_FILTER_MATCH_ ## gen_flag) {     \\\n\t\tCOPY_VALUE(spec->gen_field, mcdi_field);\t     \\\n\t}\n\t \n\tif (encap_type) {\n\t\t \n\t\t__be16 ether_type =\n\t\t\thtons(encap_type & EFX_ENCAP_FLAG_IPV6 ?\n\t\t\t      ETH_P_IPV6 : ETH_P_IP);\n\t\tu8 vni_type = MC_CMD_FILTER_OP_EXT_IN_VNI_TYPE_GENEVE;\n\t\tu8 outer_ip_proto;\n\n\t\tswitch (encap_type & EFX_ENCAP_TYPES_MASK) {\n\t\tcase EFX_ENCAP_TYPE_VXLAN:\n\t\t\tvni_type = MC_CMD_FILTER_OP_EXT_IN_VNI_TYPE_VXLAN;\n\t\t\tfallthrough;\n\t\tcase EFX_ENCAP_TYPE_GENEVE:\n\t\t\tCOPY_VALUE(ether_type, ETHER_TYPE);\n\t\t\touter_ip_proto = IPPROTO_UDP;\n\t\t\tCOPY_VALUE(outer_ip_proto, IP_PROTO);\n\t\t\t \n\t\t\tMCDI_POPULATE_DWORD_1(inbuf,\n\t\t\t\tFILTER_OP_EXT_IN_VNI_OR_VSID,\n\t\t\t\tFILTER_OP_EXT_IN_VNI_TYPE,\n\t\t\t\tvni_type);\n\t\t\tbreak;\n\t\tcase EFX_ENCAP_TYPE_NVGRE:\n\t\t\tCOPY_VALUE(ether_type, ETHER_TYPE);\n\t\t\touter_ip_proto = IPPROTO_GRE;\n\t\t\tCOPY_VALUE(outer_ip_proto, IP_PROTO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tuc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_IFRM_UNKNOWN_UCAST_DST_LBN;\n\t\tmc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_IFRM_UNKNOWN_MCAST_DST_LBN;\n\t} else {\n\t\tuc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_UNKNOWN_UCAST_DST_LBN;\n\t\tmc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_UNKNOWN_MCAST_DST_LBN;\n\t}\n\n\tif (spec->match_flags & EFX_FILTER_MATCH_LOC_MAC_IG)\n\t\tmatch_fields |=\n\t\t\tis_multicast_ether_addr(spec->loc_mac) ?\n\t\t\t1 << mc_match :\n\t\t\t1 << uc_match;\n\tCOPY_FIELD(REM_HOST, rem_host, SRC_IP);\n\tCOPY_FIELD(LOC_HOST, loc_host, DST_IP);\n\tCOPY_FIELD(REM_MAC, rem_mac, SRC_MAC);\n\tCOPY_FIELD(REM_PORT, rem_port, SRC_PORT);\n\tCOPY_FIELD(LOC_MAC, loc_mac, DST_MAC);\n\tCOPY_FIELD(LOC_PORT, loc_port, DST_PORT);\n\tCOPY_FIELD(ETHER_TYPE, ether_type, ETHER_TYPE);\n\tCOPY_FIELD(INNER_VID, inner_vid, INNER_VLAN);\n\tCOPY_FIELD(OUTER_VID, outer_vid, OUTER_VLAN);\n\tCOPY_FIELD(IP_PROTO, ip_proto, IP_PROTO);\n#undef COPY_FIELD\n#undef COPY_VALUE\n\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_MATCH_FIELDS,\n\t\t       match_fields);\n}\n\nstatic void efx_mcdi_filter_push_prep(struct efx_nic *efx,\n\t\t\t\t      const struct efx_filter_spec *spec,\n\t\t\t\t      efx_dword_t *inbuf, u64 handle,\n\t\t\t\t      struct efx_rss_context *ctx,\n\t\t\t\t      bool replacing)\n{\n\tu32 flags = spec->flags;\n\n\tmemset(inbuf, 0, MC_CMD_FILTER_OP_EXT_IN_LEN);\n\n\t \n\tif (flags & EFX_FILTER_FLAG_RX_RSS) {\n\t\t \n\t\tif (WARN_ON_ONCE(!ctx))\n\t\t\tflags &= ~EFX_FILTER_FLAG_RX_RSS;\n\t\telse if (WARN_ON_ONCE(ctx->context_id == EFX_MCDI_RSS_CONTEXT_INVALID))\n\t\t\tflags &= ~EFX_FILTER_FLAG_RX_RSS;\n\t}\n\n\tif (replacing) {\n\t\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_OP,\n\t\t\t       MC_CMD_FILTER_OP_IN_OP_REPLACE);\n\t\tMCDI_SET_QWORD(inbuf, FILTER_OP_IN_HANDLE, handle);\n\t} else {\n\t\tefx_mcdi_filter_push_prep_set_match_fields(efx, spec, inbuf);\n\t}\n\n\tif (flags & EFX_FILTER_FLAG_VPORT_ID)\n\t\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_PORT_ID, spec->vport_id);\n\telse\n\t\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_PORT_ID, efx->vport_id);\n\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_RX_DEST,\n\t\t       spec->dmaq_id == EFX_FILTER_RX_DMAQ_ID_DROP ?\n\t\t       MC_CMD_FILTER_OP_IN_RX_DEST_DROP :\n\t\t       MC_CMD_FILTER_OP_IN_RX_DEST_HOST);\n\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_TX_DOMAIN, 0);\n\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_TX_DEST,\n\t\t       MC_CMD_FILTER_OP_IN_TX_DEST_DEFAULT);\n\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_RX_QUEUE,\n\t\t       spec->dmaq_id == EFX_FILTER_RX_DMAQ_ID_DROP ?\n\t\t       0 : spec->dmaq_id);\n\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_RX_MODE,\n\t\t       (flags & EFX_FILTER_FLAG_RX_RSS) ?\n\t\t       MC_CMD_FILTER_OP_IN_RX_MODE_RSS :\n\t\t       MC_CMD_FILTER_OP_IN_RX_MODE_SIMPLE);\n\tif (flags & EFX_FILTER_FLAG_RX_RSS)\n\t\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_RX_CONTEXT, ctx->context_id);\n}\n\nstatic int efx_mcdi_filter_push(struct efx_nic *efx,\n\t\t\t\tconst struct efx_filter_spec *spec, u64 *handle,\n\t\t\t\tstruct efx_rss_context *ctx, bool replacing)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FILTER_OP_EXT_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_FILTER_OP_EXT_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\tefx_mcdi_filter_push_prep(efx, spec, inbuf, *handle, ctx, replacing);\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_FILTER_OP, inbuf, sizeof(inbuf),\n\t\t\t\toutbuf, sizeof(outbuf), &outlen);\n\tif (rc && spec->priority != EFX_FILTER_PRI_HINT)\n\t\tefx_mcdi_display_error(efx, MC_CMD_FILTER_OP, sizeof(inbuf),\n\t\t\t\t       outbuf, outlen, rc);\n\tif (rc == 0)\n\t\t*handle = MCDI_QWORD(outbuf, FILTER_OP_OUT_HANDLE);\n\tif (rc == -ENOSPC)\n\t\trc = -EBUSY;  \n\treturn rc;\n}\n\nstatic u32 efx_mcdi_filter_mcdi_flags_from_spec(const struct efx_filter_spec *spec)\n{\n\tenum efx_encap_type encap_type = efx_filter_get_encap_type(spec);\n\tunsigned int match_flags = spec->match_flags;\n\tunsigned int uc_match, mc_match;\n\tu32 mcdi_flags = 0;\n\n#define MAP_FILTER_TO_MCDI_FLAG(gen_flag, mcdi_field, encap) {\t\t\\\n\t\tunsigned int  old_match_flags = match_flags;\t\t\\\n\t\tmatch_flags &= ~EFX_FILTER_MATCH_ ## gen_flag;\t\t\\\n\t\tif (match_flags != old_match_flags)\t\t\t\\\n\t\t\tmcdi_flags |=\t\t\t\t\t\\\n\t\t\t\t(1 << ((encap) ?\t\t\t\\\n\t\t\t\t       MC_CMD_FILTER_OP_EXT_IN_MATCH_IFRM_ ## \\\n\t\t\t\t       mcdi_field ## _LBN :\t\t\\\n\t\t\t\t       MC_CMD_FILTER_OP_EXT_IN_MATCH_ ##\\\n\t\t\t\t       mcdi_field ## _LBN));\t\t\\\n\t}\n\t \n\tMAP_FILTER_TO_MCDI_FLAG(REM_HOST, SRC_IP, encap_type);\n\tMAP_FILTER_TO_MCDI_FLAG(LOC_HOST, DST_IP, encap_type);\n\tMAP_FILTER_TO_MCDI_FLAG(REM_MAC, SRC_MAC, encap_type);\n\tMAP_FILTER_TO_MCDI_FLAG(REM_PORT, SRC_PORT, encap_type);\n\tMAP_FILTER_TO_MCDI_FLAG(LOC_MAC, DST_MAC, encap_type);\n\tMAP_FILTER_TO_MCDI_FLAG(LOC_PORT, DST_PORT, encap_type);\n\tMAP_FILTER_TO_MCDI_FLAG(ETHER_TYPE, ETHER_TYPE, encap_type);\n\tMAP_FILTER_TO_MCDI_FLAG(IP_PROTO, IP_PROTO, encap_type);\n\t \n\tMAP_FILTER_TO_MCDI_FLAG(INNER_VID, INNER_VLAN, false);\n\tMAP_FILTER_TO_MCDI_FLAG(OUTER_VID, OUTER_VLAN, false);\n#undef MAP_FILTER_TO_MCDI_FLAG\n\n\t \n\tif (encap_type) {\n\t\tmatch_flags &= ~EFX_FILTER_MATCH_ENCAP_TYPE;\n\t\tmcdi_flags |=\n\t\t\t(1 << MC_CMD_FILTER_OP_EXT_IN_MATCH_ETHER_TYPE_LBN);\n\t\tmcdi_flags |= (1 << MC_CMD_FILTER_OP_EXT_IN_MATCH_IP_PROTO_LBN);\n\n\t\tuc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_IFRM_UNKNOWN_UCAST_DST_LBN;\n\t\tmc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_IFRM_UNKNOWN_MCAST_DST_LBN;\n\t} else {\n\t\tuc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_UNKNOWN_UCAST_DST_LBN;\n\t\tmc_match = MC_CMD_FILTER_OP_EXT_IN_MATCH_UNKNOWN_MCAST_DST_LBN;\n\t}\n\n\tif (match_flags & EFX_FILTER_MATCH_LOC_MAC_IG) {\n\t\tmatch_flags &= ~EFX_FILTER_MATCH_LOC_MAC_IG;\n\t\tmcdi_flags |=\n\t\t\tis_multicast_ether_addr(spec->loc_mac) ?\n\t\t\t1 << mc_match :\n\t\t\t1 << uc_match;\n\t}\n\n\t \n\tWARN_ON_ONCE(match_flags);\n\n\treturn mcdi_flags;\n}\n\nstatic int efx_mcdi_filter_pri(struct efx_mcdi_filter_table *table,\n\t\t\t       const struct efx_filter_spec *spec)\n{\n\tu32 mcdi_flags = efx_mcdi_filter_mcdi_flags_from_spec(spec);\n\tunsigned int match_pri;\n\n\tfor (match_pri = 0;\n\t     match_pri < table->rx_match_count;\n\t     match_pri++)\n\t\tif (table->rx_match_mcdi_flags[match_pri] == mcdi_flags)\n\t\t\treturn match_pri;\n\n\treturn -EPROTONOSUPPORT;\n}\n\nstatic s32 efx_mcdi_filter_insert_locked(struct efx_nic *efx,\n\t\t\t\t\t struct efx_filter_spec *spec,\n\t\t\t\t\t bool replace_equal)\n{\n\tDECLARE_BITMAP(mc_rem_map, EFX_EF10_FILTER_SEARCH_LIMIT);\n\tstruct efx_mcdi_filter_table *table;\n\tstruct efx_filter_spec *saved_spec;\n\tstruct efx_rss_context *ctx = NULL;\n\tunsigned int match_pri, hash;\n\tunsigned int priv_flags;\n\tbool rss_locked = false;\n\tbool replacing = false;\n\tunsigned int depth, i;\n\tint ins_index = -1;\n\tDEFINE_WAIT(wait);\n\tbool is_mc_recip;\n\ts32 rc;\n\n\tWARN_ON(!rwsem_is_locked(&efx->filter_sem));\n\ttable = efx->filter_state;\n\tdown_write(&table->lock);\n\n\t \n\tif ((spec->flags & (EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)) !=\n\t    EFX_FILTER_FLAG_RX) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\trc = efx_mcdi_filter_pri(table, spec);\n\tif (rc < 0)\n\t\tgoto out_unlock;\n\tmatch_pri = rc;\n\n\thash = efx_filter_spec_hash(spec);\n\tis_mc_recip = efx_filter_is_mc_recipient(spec);\n\tif (is_mc_recip)\n\t\tbitmap_zero(mc_rem_map, EFX_EF10_FILTER_SEARCH_LIMIT);\n\n\tif (spec->flags & EFX_FILTER_FLAG_RX_RSS) {\n\t\tmutex_lock(&efx->rss_lock);\n\t\trss_locked = true;\n\t\tif (spec->rss_context)\n\t\t\tctx = efx_find_rss_context_entry(efx, spec->rss_context);\n\t\telse\n\t\t\tctx = &efx->rss_context;\n\t\tif (!ctx) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (ctx->context_id == EFX_MCDI_RSS_CONTEXT_INVALID) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tfor (depth = 1; depth < EFX_EF10_FILTER_SEARCH_LIMIT; depth++) {\n\t\ti = (hash + depth) & (EFX_MCDI_FILTER_TBL_ROWS - 1);\n\t\tsaved_spec = efx_mcdi_filter_entry_spec(table, i);\n\n\t\tif (!saved_spec) {\n\t\t\tif (ins_index < 0)\n\t\t\t\tins_index = i;\n\t\t} else if (efx_filter_spec_equal(spec, saved_spec)) {\n\t\t\tif (spec->priority < saved_spec->priority &&\n\t\t\t    spec->priority != EFX_FILTER_PRI_AUTO) {\n\t\t\t\trc = -EPERM;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tif (!is_mc_recip) {\n\t\t\t\t \n\t\t\t\tif (spec->priority ==\n\t\t\t\t    saved_spec->priority &&\n\t\t\t\t    !replace_equal) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tins_index = i;\n\t\t\t\tbreak;\n\t\t\t} else if (spec->priority >\n\t\t\t\t   saved_spec->priority ||\n\t\t\t\t   (spec->priority ==\n\t\t\t\t    saved_spec->priority &&\n\t\t\t\t    replace_equal)) {\n\t\t\t\tif (ins_index < 0)\n\t\t\t\t\tins_index = i;\n\t\t\t\telse\n\t\t\t\t\t__set_bit(depth, mc_rem_map);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ins_index < 0) {\n\t\trc = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tsaved_spec = efx_mcdi_filter_entry_spec(table, ins_index);\n\tif (saved_spec) {\n\t\tif (spec->priority == EFX_FILTER_PRI_AUTO &&\n\t\t    saved_spec->priority >= EFX_FILTER_PRI_AUTO) {\n\t\t\t \n\t\t\tif (saved_spec->priority > EFX_FILTER_PRI_AUTO)\n\t\t\t\tsaved_spec->flags |= EFX_FILTER_FLAG_RX_OVER_AUTO;\n\t\t\ttable->entry[ins_index].spec &=\n\t\t\t\t~EFX_EF10_FILTER_FLAG_AUTO_OLD;\n\t\t\trc = ins_index;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\treplacing = true;\n\t\tpriv_flags = efx_mcdi_filter_entry_flags(table, ins_index);\n\t} else {\n\t\tsaved_spec = kmalloc(sizeof(*spec), GFP_ATOMIC);\n\t\tif (!saved_spec) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t*saved_spec = *spec;\n\t\tpriv_flags = 0;\n\t}\n\tefx_mcdi_filter_set_entry(table, ins_index, saved_spec, priv_flags);\n\n\t \n\trc = efx_mcdi_filter_push(efx, spec, &table->entry[ins_index].handle,\n\t\t\t\t  ctx, replacing);\n\n\tif (rc == -EINVAL && efx->must_realloc_vis)\n\t\t \n\t\trc = -EAGAIN;\n\n\t \n\tif (rc == 0) {\n\t\tif (replacing) {\n\t\t\t \n\t\t\tif (saved_spec->priority == EFX_FILTER_PRI_AUTO)\n\t\t\t\tsaved_spec->flags |=\n\t\t\t\t\tEFX_FILTER_FLAG_RX_OVER_AUTO;\n\t\t\tsaved_spec->priority = spec->priority;\n\t\t\tsaved_spec->flags &= EFX_FILTER_FLAG_RX_OVER_AUTO;\n\t\t\tsaved_spec->flags |= spec->flags;\n\t\t\tsaved_spec->rss_context = spec->rss_context;\n\t\t\tsaved_spec->dmaq_id = spec->dmaq_id;\n\t\t\tsaved_spec->vport_id = spec->vport_id;\n\t\t}\n\t} else if (!replacing) {\n\t\tkfree(saved_spec);\n\t\tsaved_spec = NULL;\n\t} else {\n\t\t \n\t}\n\tefx_mcdi_filter_set_entry(table, ins_index, saved_spec, priv_flags);\n\n\t \n\tif (is_mc_recip) {\n\t\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FILTER_OP_EXT_IN_LEN);\n\t\tunsigned int depth, i;\n\n\t\tmemset(inbuf, 0, sizeof(inbuf));\n\n\t\tfor (depth = 0; depth < EFX_EF10_FILTER_SEARCH_LIMIT; depth++) {\n\t\t\tif (!test_bit(depth, mc_rem_map))\n\t\t\t\tcontinue;\n\n\t\t\ti = (hash + depth) & (EFX_MCDI_FILTER_TBL_ROWS - 1);\n\t\t\tsaved_spec = efx_mcdi_filter_entry_spec(table, i);\n\t\t\tpriv_flags = efx_mcdi_filter_entry_flags(table, i);\n\n\t\t\tif (rc == 0) {\n\t\t\t\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_OP,\n\t\t\t\t\t       MC_CMD_FILTER_OP_IN_OP_UNSUBSCRIBE);\n\t\t\t\tMCDI_SET_QWORD(inbuf, FILTER_OP_IN_HANDLE,\n\t\t\t\t\t       table->entry[i].handle);\n\t\t\t\trc = efx_mcdi_rpc(efx, MC_CMD_FILTER_OP,\n\t\t\t\t\t\t  inbuf, sizeof(inbuf),\n\t\t\t\t\t\t  NULL, 0, NULL);\n\t\t\t}\n\n\t\t\tif (rc == 0) {\n\t\t\t\tkfree(saved_spec);\n\t\t\t\tsaved_spec = NULL;\n\t\t\t\tpriv_flags = 0;\n\t\t\t}\n\t\t\tefx_mcdi_filter_set_entry(table, i, saved_spec,\n\t\t\t\t\t\t  priv_flags);\n\t\t}\n\t}\n\n\t \n\tif (rc == 0)\n\t\trc = efx_mcdi_filter_make_filter_id(match_pri, ins_index);\n\nout_unlock:\n\tif (rss_locked)\n\t\tmutex_unlock(&efx->rss_lock);\n\tup_write(&table->lock);\n\treturn rc;\n}\n\ns32 efx_mcdi_filter_insert(struct efx_nic *efx, struct efx_filter_spec *spec,\n\t\t\t   bool replace_equal)\n{\n\ts32 ret;\n\n\tdown_read(&efx->filter_sem);\n\tret = efx_mcdi_filter_insert_locked(efx, spec, replace_equal);\n\tup_read(&efx->filter_sem);\n\n\treturn ret;\n}\n\n \nstatic int efx_mcdi_filter_remove_internal(struct efx_nic *efx,\n\t\t\t\t\t   unsigned int priority_mask,\n\t\t\t\t\t   u32 filter_id, bool by_index)\n{\n\tunsigned int filter_idx = efx_mcdi_filter_get_unsafe_id(filter_id);\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tMCDI_DECLARE_BUF(inbuf,\n\t\t\t MC_CMD_FILTER_OP_IN_HANDLE_OFST +\n\t\t\t MC_CMD_FILTER_OP_IN_HANDLE_LEN);\n\tstruct efx_filter_spec *spec;\n\tDEFINE_WAIT(wait);\n\tint rc;\n\n\tspec = efx_mcdi_filter_entry_spec(table, filter_idx);\n\tif (!spec ||\n\t    (!by_index &&\n\t     efx_mcdi_filter_pri(table, spec) !=\n\t     efx_mcdi_filter_get_unsafe_pri(filter_id)))\n\t\treturn -ENOENT;\n\n\tif (spec->flags & EFX_FILTER_FLAG_RX_OVER_AUTO &&\n\t    priority_mask == (1U << EFX_FILTER_PRI_AUTO)) {\n\t\t \n\t\tspec->flags &= ~EFX_FILTER_FLAG_RX_OVER_AUTO;\n\t\ttable->entry[filter_idx].spec &= ~EFX_EF10_FILTER_FLAG_AUTO_OLD;\n\t\treturn 0;\n\t}\n\n\tif (!(priority_mask & (1U << spec->priority)))\n\t\treturn -ENOENT;\n\n\tif (spec->flags & EFX_FILTER_FLAG_RX_OVER_AUTO) {\n\t\t \n\n\t\tstruct efx_filter_spec new_spec = *spec;\n\n\t\tnew_spec.priority = EFX_FILTER_PRI_AUTO;\n\t\tnew_spec.flags = (EFX_FILTER_FLAG_RX |\n\t\t\t\t  (efx_rss_active(&efx->rss_context) ?\n\t\t\t\t   EFX_FILTER_FLAG_RX_RSS : 0));\n\t\tnew_spec.dmaq_id = 0;\n\t\tnew_spec.rss_context = 0;\n\t\trc = efx_mcdi_filter_push(efx, &new_spec,\n\t\t\t\t\t  &table->entry[filter_idx].handle,\n\t\t\t\t\t  &efx->rss_context,\n\t\t\t\t\t  true);\n\n\t\tif (rc == 0)\n\t\t\t*spec = new_spec;\n\t} else {\n\t\t \n\n\t\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_OP,\n\t\t\t       efx_mcdi_filter_is_exclusive(spec) ?\n\t\t\t       MC_CMD_FILTER_OP_IN_OP_REMOVE :\n\t\t\t       MC_CMD_FILTER_OP_IN_OP_UNSUBSCRIBE);\n\t\tMCDI_SET_QWORD(inbuf, FILTER_OP_IN_HANDLE,\n\t\t\t       table->entry[filter_idx].handle);\n\t\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_FILTER_OP,\n\t\t\t\t\tinbuf, sizeof(inbuf), NULL, 0, NULL);\n\n\t\tif ((rc == 0) || (rc == -ENOENT)) {\n\t\t\t \n\t\t\tkfree(spec);\n\t\t\tefx_mcdi_filter_set_entry(table, filter_idx, NULL, 0);\n\t\t} else {\n\t\t\tefx_mcdi_display_error(efx, MC_CMD_FILTER_OP,\n\t\t\t\t\t       MC_CMD_FILTER_OP_EXT_IN_LEN,\n\t\t\t\t\t       NULL, 0, rc);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic void efx_mcdi_filter_remove_old(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tint remove_failed = 0;\n\tint remove_noent = 0;\n\tint rc;\n\tint i;\n\n\tdown_write(&table->lock);\n\tfor (i = 0; i < EFX_MCDI_FILTER_TBL_ROWS; i++) {\n\t\tif (READ_ONCE(table->entry[i].spec) &\n\t\t    EFX_EF10_FILTER_FLAG_AUTO_OLD) {\n\t\t\trc = efx_mcdi_filter_remove_internal(efx,\n\t\t\t\t\t1U << EFX_FILTER_PRI_AUTO, i, true);\n\t\t\tif (rc == -ENOENT)\n\t\t\t\tremove_noent++;\n\t\t\telse if (rc)\n\t\t\t\tremove_failed++;\n\t\t}\n\t}\n\tup_write(&table->lock);\n\n\tif (remove_failed)\n\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t   \"%s: failed to remove %d filters\\n\",\n\t\t\t   __func__, remove_failed);\n\tif (remove_noent)\n\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t   \"%s: failed to remove %d non-existent filters\\n\",\n\t\t\t   __func__, remove_noent);\n}\n\nint efx_mcdi_filter_remove_safe(struct efx_nic *efx,\n\t\t\t\tenum efx_filter_priority priority,\n\t\t\t\tu32 filter_id)\n{\n\tstruct efx_mcdi_filter_table *table;\n\tint rc;\n\n\tdown_read(&efx->filter_sem);\n\ttable = efx->filter_state;\n\tdown_write(&table->lock);\n\trc = efx_mcdi_filter_remove_internal(efx, 1U << priority, filter_id,\n\t\t\t\t\t     false);\n\tup_write(&table->lock);\n\tup_read(&efx->filter_sem);\n\treturn rc;\n}\n\n \nstatic void efx_mcdi_filter_remove_unsafe(struct efx_nic *efx,\n\t\t\t\t\t  enum efx_filter_priority priority,\n\t\t\t\t\t  u32 filter_id)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\n\tif (filter_id == EFX_EF10_FILTER_ID_INVALID)\n\t\treturn;\n\n\tdown_write(&table->lock);\n\tefx_mcdi_filter_remove_internal(efx, 1U << priority, filter_id,\n\t\t\t\t\ttrue);\n\tup_write(&table->lock);\n}\n\nint efx_mcdi_filter_get_safe(struct efx_nic *efx,\n\t\t\t     enum efx_filter_priority priority,\n\t\t\t     u32 filter_id, struct efx_filter_spec *spec)\n{\n\tunsigned int filter_idx = efx_mcdi_filter_get_unsafe_id(filter_id);\n\tconst struct efx_filter_spec *saved_spec;\n\tstruct efx_mcdi_filter_table *table;\n\tint rc;\n\n\tdown_read(&efx->filter_sem);\n\ttable = efx->filter_state;\n\tdown_read(&table->lock);\n\tsaved_spec = efx_mcdi_filter_entry_spec(table, filter_idx);\n\tif (saved_spec && saved_spec->priority == priority &&\n\t    efx_mcdi_filter_pri(table, saved_spec) ==\n\t    efx_mcdi_filter_get_unsafe_pri(filter_id)) {\n\t\t*spec = *saved_spec;\n\t\trc = 0;\n\t} else {\n\t\trc = -ENOENT;\n\t}\n\tup_read(&table->lock);\n\tup_read(&efx->filter_sem);\n\treturn rc;\n}\n\nstatic int efx_mcdi_filter_insert_addr_list(struct efx_nic *efx,\n\t\t\t\t\t    struct efx_mcdi_filter_vlan *vlan,\n\t\t\t\t\t    bool multicast, bool rollback)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct efx_mcdi_dev_addr *addr_list;\n\tenum efx_filter_flags filter_flags;\n\tstruct efx_filter_spec spec;\n\tu8 baddr[ETH_ALEN];\n\tunsigned int i, j;\n\tint addr_count;\n\tu16 *ids;\n\tint rc;\n\n\tif (multicast) {\n\t\taddr_list = table->dev_mc_list;\n\t\taddr_count = table->dev_mc_count;\n\t\tids = vlan->mc;\n\t} else {\n\t\taddr_list = table->dev_uc_list;\n\t\taddr_count = table->dev_uc_count;\n\t\tids = vlan->uc;\n\t}\n\n\tfilter_flags = efx_rss_active(&efx->rss_context) ? EFX_FILTER_FLAG_RX_RSS : 0;\n\n\t \n\tfor (i = 0; i < addr_count; i++) {\n\t\tEFX_WARN_ON_PARANOID(ids[i] != EFX_EF10_FILTER_ID_INVALID);\n\t\tefx_filter_init_rx(&spec, EFX_FILTER_PRI_AUTO, filter_flags, 0);\n\t\tefx_filter_set_eth_local(&spec, vlan->vid, addr_list[i].addr);\n\t\trc = efx_mcdi_filter_insert_locked(efx, &spec, true);\n\t\tif (rc < 0) {\n\t\t\tif (rollback) {\n\t\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t\t   \"efx_mcdi_filter_insert failed rc=%d\\n\",\n\t\t\t\t\t   rc);\n\t\t\t\t \n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tefx_mcdi_filter_remove_unsafe(\n\t\t\t\t\t\tefx, EFX_FILTER_PRI_AUTO,\n\t\t\t\t\t\tids[j]);\n\t\t\t\t\tids[j] = EFX_EF10_FILTER_ID_INVALID;\n\t\t\t\t}\n\t\t\t\treturn rc;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t}\n\t\t} else {\n\t\t\tids[i] = efx_mcdi_filter_get_unsafe_id(rc);\n\t\t}\n\t}\n\n\tif (multicast && rollback) {\n\t\t \n\t\tEFX_WARN_ON_PARANOID(vlan->default_filters[EFX_EF10_BCAST] !=\n\t\t\t\t     EFX_EF10_FILTER_ID_INVALID);\n\t\tefx_filter_init_rx(&spec, EFX_FILTER_PRI_AUTO, filter_flags, 0);\n\t\teth_broadcast_addr(baddr);\n\t\tefx_filter_set_eth_local(&spec, vlan->vid, baddr);\n\t\trc = efx_mcdi_filter_insert_locked(efx, &spec, true);\n\t\tif (rc < 0) {\n\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t   \"Broadcast filter insert failed rc=%d\\n\", rc);\n\t\t\t \n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tefx_mcdi_filter_remove_unsafe(\n\t\t\t\t\tefx, EFX_FILTER_PRI_AUTO,\n\t\t\t\t\tids[j]);\n\t\t\t\tids[j] = EFX_EF10_FILTER_ID_INVALID;\n\t\t\t}\n\t\t\treturn rc;\n\t\t} else {\n\t\t\tvlan->default_filters[EFX_EF10_BCAST] =\n\t\t\t\tefx_mcdi_filter_get_unsafe_id(rc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int efx_mcdi_filter_insert_def(struct efx_nic *efx,\n\t\t\t\t      struct efx_mcdi_filter_vlan *vlan,\n\t\t\t\t      enum efx_encap_type encap_type,\n\t\t\t\t      bool multicast, bool rollback)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tenum efx_filter_flags filter_flags;\n\tstruct efx_filter_spec spec;\n\tu8 baddr[ETH_ALEN];\n\tint rc;\n\tu16 *id;\n\n\tfilter_flags = efx_rss_active(&efx->rss_context) ? EFX_FILTER_FLAG_RX_RSS : 0;\n\n\tefx_filter_init_rx(&spec, EFX_FILTER_PRI_AUTO, filter_flags, 0);\n\n\tif (multicast)\n\t\tefx_filter_set_mc_def(&spec);\n\telse\n\t\tefx_filter_set_uc_def(&spec);\n\n\tif (encap_type) {\n\t\tif (efx_has_cap(efx, VXLAN_NVGRE))\n\t\t\tefx_filter_set_encap_type(&spec, encap_type);\n\t\telse\n\t\t\t \n\t\t\treturn 0;\n\t}\n\n\tif (vlan->vid != EFX_FILTER_VID_UNSPEC)\n\t\tefx_filter_set_eth_local(&spec, vlan->vid, NULL);\n\n\trc = efx_mcdi_filter_insert_locked(efx, &spec, true);\n\tif (rc < 0) {\n\t\tconst char *um = multicast ? \"Multicast\" : \"Unicast\";\n\t\tconst char *encap_name = \"\";\n\t\tconst char *encap_ipv = \"\";\n\n\t\tif ((encap_type & EFX_ENCAP_TYPES_MASK) ==\n\t\t    EFX_ENCAP_TYPE_VXLAN)\n\t\t\tencap_name = \"VXLAN \";\n\t\telse if ((encap_type & EFX_ENCAP_TYPES_MASK) ==\n\t\t\t EFX_ENCAP_TYPE_NVGRE)\n\t\t\tencap_name = \"NVGRE \";\n\t\telse if ((encap_type & EFX_ENCAP_TYPES_MASK) ==\n\t\t\t EFX_ENCAP_TYPE_GENEVE)\n\t\t\tencap_name = \"GENEVE \";\n\t\tif (encap_type & EFX_ENCAP_FLAG_IPV6)\n\t\t\tencap_ipv = \"IPv6 \";\n\t\telse if (encap_type)\n\t\t\tencap_ipv = \"IPv4 \";\n\n\t\t \n\t\tnetif_cond_dbg(efx, drv, efx->net_dev,\n\t\t\t       rc == -EPERM && (encap_type || !multicast), warn,\n\t\t\t       \"%s%s%s mismatch filter insert failed rc=%d\\n\",\n\t\t\t       encap_name, encap_ipv, um, rc);\n\t} else if (multicast) {\n\t\t \n\t\tstatic enum efx_mcdi_filter_default_filters map[] = {\n\t\t\t[EFX_ENCAP_TYPE_NONE] = EFX_EF10_MCDEF,\n\t\t\t[EFX_ENCAP_TYPE_VXLAN] = EFX_EF10_VXLAN4_MCDEF,\n\t\t\t[EFX_ENCAP_TYPE_NVGRE] = EFX_EF10_NVGRE4_MCDEF,\n\t\t\t[EFX_ENCAP_TYPE_GENEVE] = EFX_EF10_GENEVE4_MCDEF,\n\t\t\t[EFX_ENCAP_TYPE_VXLAN | EFX_ENCAP_FLAG_IPV6] =\n\t\t\t\tEFX_EF10_VXLAN6_MCDEF,\n\t\t\t[EFX_ENCAP_TYPE_NVGRE | EFX_ENCAP_FLAG_IPV6] =\n\t\t\t\tEFX_EF10_NVGRE6_MCDEF,\n\t\t\t[EFX_ENCAP_TYPE_GENEVE | EFX_ENCAP_FLAG_IPV6] =\n\t\t\t\tEFX_EF10_GENEVE6_MCDEF,\n\t\t};\n\n\t\t \n\t\tBUILD_BUG_ON(EFX_EF10_BCAST != 0);\n\t\tif (encap_type >= ARRAY_SIZE(map) || map[encap_type] == 0) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tid = &vlan->default_filters[map[encap_type]];\n\n\t\tEFX_WARN_ON_PARANOID(*id != EFX_EF10_FILTER_ID_INVALID);\n\t\t*id = efx_mcdi_filter_get_unsafe_id(rc);\n\t\tif (!table->mc_chaining && !encap_type) {\n\t\t\t \n\t\t\tefx_filter_init_rx(&spec, EFX_FILTER_PRI_AUTO,\n\t\t\t\t\t   filter_flags, 0);\n\t\t\teth_broadcast_addr(baddr);\n\t\t\tefx_filter_set_eth_local(&spec, vlan->vid, baddr);\n\t\t\trc = efx_mcdi_filter_insert_locked(efx, &spec, true);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t\t   \"Broadcast filter insert failed rc=%d\\n\",\n\t\t\t\t\t   rc);\n\t\t\t\tif (rollback) {\n\t\t\t\t\t \n\t\t\t\t\tefx_mcdi_filter_remove_unsafe(\n\t\t\t\t\t\t\tefx, EFX_FILTER_PRI_AUTO,\n\t\t\t\t\t\t\t*id);\n\t\t\t\t\t*id = EFX_EF10_FILTER_ID_INVALID;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tEFX_WARN_ON_PARANOID(\n\t\t\t\t\tvlan->default_filters[EFX_EF10_BCAST] !=\n\t\t\t\t\tEFX_EF10_FILTER_ID_INVALID);\n\t\t\t\tvlan->default_filters[EFX_EF10_BCAST] =\n\t\t\t\t\tefx_mcdi_filter_get_unsafe_id(rc);\n\t\t\t}\n\t\t}\n\t\trc = 0;\n\t} else {\n\t\t \n\t\tstatic enum efx_mcdi_filter_default_filters map[] = {\n\t\t\t[EFX_ENCAP_TYPE_NONE] = EFX_EF10_UCDEF,\n\t\t\t[EFX_ENCAP_TYPE_VXLAN] = EFX_EF10_VXLAN4_UCDEF,\n\t\t\t[EFX_ENCAP_TYPE_NVGRE] = EFX_EF10_NVGRE4_UCDEF,\n\t\t\t[EFX_ENCAP_TYPE_GENEVE] = EFX_EF10_GENEVE4_UCDEF,\n\t\t\t[EFX_ENCAP_TYPE_VXLAN | EFX_ENCAP_FLAG_IPV6] =\n\t\t\t\tEFX_EF10_VXLAN6_UCDEF,\n\t\t\t[EFX_ENCAP_TYPE_NVGRE | EFX_ENCAP_FLAG_IPV6] =\n\t\t\t\tEFX_EF10_NVGRE6_UCDEF,\n\t\t\t[EFX_ENCAP_TYPE_GENEVE | EFX_ENCAP_FLAG_IPV6] =\n\t\t\t\tEFX_EF10_GENEVE6_UCDEF,\n\t\t};\n\n\t\t \n\t\tBUILD_BUG_ON(EFX_EF10_BCAST != 0);\n\t\tif (encap_type >= ARRAY_SIZE(map) || map[encap_type] == 0) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tid = &vlan->default_filters[map[encap_type]];\n\t\tEFX_WARN_ON_PARANOID(*id != EFX_EF10_FILTER_ID_INVALID);\n\t\t*id = rc;\n\t\trc = 0;\n\t}\n\treturn rc;\n}\n\n \nstatic void efx_mcdi_filter_vlan_sync_rx_mode(struct efx_nic *efx,\n\t\t\t\t\t      struct efx_mcdi_filter_vlan *vlan)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\n\t \n\tif ((vlan->vid == EFX_FILTER_VID_UNSPEC) == table->vlan_filter)\n\t\treturn;\n\n\t \n\tif (table->uc_promisc) {\n\t\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NONE,\n\t\t\t\t\t   false, false);\n\t\tefx_mcdi_filter_insert_addr_list(efx, vlan, false, false);\n\t} else {\n\t\t \n\t\tif (efx_mcdi_filter_insert_addr_list(efx, vlan, false, false))\n\t\t\tefx_mcdi_filter_insert_def(efx, vlan,\n\t\t\t\t\t\t   EFX_ENCAP_TYPE_NONE,\n\t\t\t\t\t\t   false, false);\n\t}\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN,\n\t\t\t\t   false, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN |\n\t\t\t\t\t      EFX_ENCAP_FLAG_IPV6,\n\t\t\t\t   false, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE,\n\t\t\t\t   false, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE |\n\t\t\t\t\t      EFX_ENCAP_FLAG_IPV6,\n\t\t\t\t   false, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE,\n\t\t\t\t   false, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE |\n\t\t\t\t\t      EFX_ENCAP_FLAG_IPV6,\n\t\t\t\t   false, false);\n\n\t \n\tif (table->mc_chaining && table->mc_promisc_last != table->mc_promisc)\n\t\tefx_mcdi_filter_remove_old(efx);\n\tif (table->mc_promisc) {\n\t\tif (table->mc_chaining) {\n\t\t\t \n\t\t\tif (efx_mcdi_filter_insert_def(efx, vlan,\n\t\t\t\t\t\t       EFX_ENCAP_TYPE_NONE,\n\t\t\t\t\t\t       true, true)) {\n\t\t\t\t \n\t\t\t\tefx_mcdi_filter_remove_old(efx);\n\t\t\t\tefx_mcdi_filter_insert_addr_list(efx, vlan,\n\t\t\t\t\t\t\t\t true, false);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tefx_mcdi_filter_insert_def(efx, vlan,\n\t\t\t\t\t\t   EFX_ENCAP_TYPE_NONE,\n\t\t\t\t\t\t   true, false);\n\t\t\tif (!table->mc_overflow)\n\t\t\t\tefx_mcdi_filter_insert_addr_list(efx, vlan,\n\t\t\t\t\t\t\t\t true, false);\n\t\t}\n\t} else {\n\t\t \n\t\tif (efx_mcdi_filter_insert_addr_list(efx, vlan, true, true)) {\n\t\t\t \n\t\t\tif (table->mc_chaining)\n\t\t\t\tefx_mcdi_filter_remove_old(efx);\n\t\t\tif (efx_mcdi_filter_insert_def(efx, vlan,\n\t\t\t\t\t\t       EFX_ENCAP_TYPE_NONE,\n\t\t\t\t\t\t       true, true))\n\t\t\t\tefx_mcdi_filter_insert_addr_list(efx, vlan,\n\t\t\t\t\t\t\t\t true, false);\n\t\t}\n\t}\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN,\n\t\t\t\t   true, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN |\n\t\t\t\t\t      EFX_ENCAP_FLAG_IPV6,\n\t\t\t\t   true, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE,\n\t\t\t\t   true, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE |\n\t\t\t\t\t      EFX_ENCAP_FLAG_IPV6,\n\t\t\t\t   true, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE,\n\t\t\t\t   true, false);\n\tefx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE |\n\t\t\t\t\t      EFX_ENCAP_FLAG_IPV6,\n\t\t\t\t   true, false);\n}\n\nint efx_mcdi_filter_clear_rx(struct efx_nic *efx,\n\t\t\t     enum efx_filter_priority priority)\n{\n\tstruct efx_mcdi_filter_table *table;\n\tunsigned int priority_mask;\n\tunsigned int i;\n\tint rc;\n\n\tpriority_mask = (((1U << (priority + 1)) - 1) &\n\t\t\t ~(1U << EFX_FILTER_PRI_AUTO));\n\n\tdown_read(&efx->filter_sem);\n\ttable = efx->filter_state;\n\tdown_write(&table->lock);\n\tfor (i = 0; i < EFX_MCDI_FILTER_TBL_ROWS; i++) {\n\t\trc = efx_mcdi_filter_remove_internal(efx, priority_mask,\n\t\t\t\t\t\t     i, true);\n\t\tif (rc && rc != -ENOENT)\n\t\t\tbreak;\n\t\trc = 0;\n\t}\n\n\tup_write(&table->lock);\n\tup_read(&efx->filter_sem);\n\treturn rc;\n}\n\nu32 efx_mcdi_filter_count_rx_used(struct efx_nic *efx,\n\t\t\t\t enum efx_filter_priority priority)\n{\n\tstruct efx_mcdi_filter_table *table;\n\tunsigned int filter_idx;\n\ts32 count = 0;\n\n\tdown_read(&efx->filter_sem);\n\ttable = efx->filter_state;\n\tdown_read(&table->lock);\n\tfor (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {\n\t\tif (table->entry[filter_idx].spec &&\n\t\t    efx_mcdi_filter_entry_spec(table, filter_idx)->priority ==\n\t\t    priority)\n\t\t\t++count;\n\t}\n\tup_read(&table->lock);\n\tup_read(&efx->filter_sem);\n\treturn count;\n}\n\nu32 efx_mcdi_filter_get_rx_id_limit(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\n\treturn table->rx_match_count * EFX_MCDI_FILTER_TBL_ROWS * 2;\n}\n\ns32 efx_mcdi_filter_get_rx_ids(struct efx_nic *efx,\n\t\t\t       enum efx_filter_priority priority,\n\t\t\t       u32 *buf, u32 size)\n{\n\tstruct efx_mcdi_filter_table *table;\n\tstruct efx_filter_spec *spec;\n\tunsigned int filter_idx;\n\ts32 count = 0;\n\n\tdown_read(&efx->filter_sem);\n\ttable = efx->filter_state;\n\tdown_read(&table->lock);\n\n\tfor (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {\n\t\tspec = efx_mcdi_filter_entry_spec(table, filter_idx);\n\t\tif (spec && spec->priority == priority) {\n\t\t\tif (count == size) {\n\t\t\t\tcount = -EMSGSIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[count++] =\n\t\t\t\tefx_mcdi_filter_make_filter_id(\n\t\t\t\t\tefx_mcdi_filter_pri(table, spec),\n\t\t\t\t\tfilter_idx);\n\t\t}\n\t}\n\tup_read(&table->lock);\n\tup_read(&efx->filter_sem);\n\treturn count;\n}\n\nstatic int efx_mcdi_filter_match_flags_from_mcdi(bool encap, u32 mcdi_flags)\n{\n\tint match_flags = 0;\n\n#define MAP_FLAG(gen_flag, mcdi_field) do {\t\t\t\t\\\n\t\tu32 old_mcdi_flags = mcdi_flags;\t\t\t\\\n\t\tmcdi_flags &= ~(1 << MC_CMD_FILTER_OP_EXT_IN_MATCH_ ##\t\\\n\t\t\t\t     mcdi_field ## _LBN);\t\t\\\n\t\tif (mcdi_flags != old_mcdi_flags)\t\t\t\\\n\t\t\tmatch_flags |= EFX_FILTER_MATCH_ ## gen_flag;\t\\\n\t} while (0)\n\n\tif (encap) {\n\t\t \n\t\tmatch_flags |= EFX_FILTER_MATCH_ENCAP_TYPE;\n\t\t \n\t\tmcdi_flags &=\n\t\t\t~(1 << MC_CMD_FILTER_OP_EXT_IN_MATCH_IP_PROTO_LBN);\n\t\tmcdi_flags &=\n\t\t\t~(1 << MC_CMD_FILTER_OP_EXT_IN_MATCH_ETHER_TYPE_LBN);\n\t\t \n\t\tMAP_FLAG(INNER_VID, INNER_VLAN);\n\t\tMAP_FLAG(OUTER_VID, OUTER_VLAN);\n\t\t \n\t\tMAP_FLAG(LOC_MAC_IG, IFRM_UNKNOWN_UCAST_DST);\n\t\tMAP_FLAG(LOC_MAC_IG, IFRM_UNKNOWN_MCAST_DST);\n\t\tMAP_FLAG(REM_HOST, IFRM_SRC_IP);\n\t\tMAP_FLAG(LOC_HOST, IFRM_DST_IP);\n\t\tMAP_FLAG(REM_MAC, IFRM_SRC_MAC);\n\t\tMAP_FLAG(REM_PORT, IFRM_SRC_PORT);\n\t\tMAP_FLAG(LOC_MAC, IFRM_DST_MAC);\n\t\tMAP_FLAG(LOC_PORT, IFRM_DST_PORT);\n\t\tMAP_FLAG(ETHER_TYPE, IFRM_ETHER_TYPE);\n\t\tMAP_FLAG(IP_PROTO, IFRM_IP_PROTO);\n\t} else {\n\t\tMAP_FLAG(LOC_MAC_IG, UNKNOWN_UCAST_DST);\n\t\tMAP_FLAG(LOC_MAC_IG, UNKNOWN_MCAST_DST);\n\t\tMAP_FLAG(REM_HOST, SRC_IP);\n\t\tMAP_FLAG(LOC_HOST, DST_IP);\n\t\tMAP_FLAG(REM_MAC, SRC_MAC);\n\t\tMAP_FLAG(REM_PORT, SRC_PORT);\n\t\tMAP_FLAG(LOC_MAC, DST_MAC);\n\t\tMAP_FLAG(LOC_PORT, DST_PORT);\n\t\tMAP_FLAG(ETHER_TYPE, ETHER_TYPE);\n\t\tMAP_FLAG(INNER_VID, INNER_VLAN);\n\t\tMAP_FLAG(OUTER_VID, OUTER_VLAN);\n\t\tMAP_FLAG(IP_PROTO, IP_PROTO);\n\t}\n#undef MAP_FLAG\n\n\t \n\tif (mcdi_flags)\n\t\treturn -EINVAL;\n\n\treturn match_flags;\n}\n\nbool efx_mcdi_filter_match_supported(struct efx_mcdi_filter_table *table,\n\t\t\t\t     bool encap,\n\t\t\t\t     enum efx_filter_match_flags match_flags)\n{\n\tunsigned int match_pri;\n\tint mf;\n\n\tfor (match_pri = 0;\n\t     match_pri < table->rx_match_count;\n\t     match_pri++) {\n\t\tmf = efx_mcdi_filter_match_flags_from_mcdi(encap,\n\t\t\t\ttable->rx_match_mcdi_flags[match_pri]);\n\t\tif (mf == match_flags)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\nefx_mcdi_filter_table_probe_matches(struct efx_nic *efx,\n\t\t\t\t    struct efx_mcdi_filter_table *table,\n\t\t\t\t    bool encap)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_PARSER_DISP_INFO_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PARSER_DISP_INFO_OUT_LENMAX);\n\tunsigned int pd_match_pri, pd_match_count;\n\tsize_t outlen;\n\tint rc;\n\n\t \n\tMCDI_SET_DWORD(inbuf, GET_PARSER_DISP_INFO_IN_OP,\n\t\t       encap ?\n\t\t       MC_CMD_GET_PARSER_DISP_INFO_IN_OP_GET_SUPPORTED_ENCAP_RX_MATCHES :\n\t\t       MC_CMD_GET_PARSER_DISP_INFO_IN_OP_GET_SUPPORTED_RX_MATCHES);\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_PARSER_DISP_INFO,\n\t\t\t  inbuf, sizeof(inbuf), outbuf, sizeof(outbuf),\n\t\t\t  &outlen);\n\tif (rc)\n\t\treturn rc;\n\n\tpd_match_count = MCDI_VAR_ARRAY_LEN(\n\t\toutlen, GET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES);\n\n\tfor (pd_match_pri = 0; pd_match_pri < pd_match_count; pd_match_pri++) {\n\t\tu32 mcdi_flags =\n\t\t\tMCDI_ARRAY_DWORD(\n\t\t\t\toutbuf,\n\t\t\t\tGET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES,\n\t\t\t\tpd_match_pri);\n\t\trc = efx_mcdi_filter_match_flags_from_mcdi(encap, mcdi_flags);\n\t\tif (rc < 0) {\n\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t  \"%s: fw flags %#x pri %u not supported in driver\\n\",\n\t\t\t\t  __func__, mcdi_flags, pd_match_pri);\n\t\t} else {\n\t\t\tnetif_dbg(efx, probe, efx->net_dev,\n\t\t\t\t  \"%s: fw flags %#x pri %u supported as driver flags %#x pri %u\\n\",\n\t\t\t\t  __func__, mcdi_flags, pd_match_pri,\n\t\t\t\t  rc, table->rx_match_count);\n\t\t\ttable->rx_match_mcdi_flags[table->rx_match_count] = mcdi_flags;\n\t\t\ttable->rx_match_count++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint efx_mcdi_filter_table_probe(struct efx_nic *efx, bool multicast_chaining)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_mcdi_filter_table *table;\n\tint rc;\n\n\tif (!efx_rwsem_assert_write_locked(&efx->filter_sem))\n\t\treturn -EINVAL;\n\n\tif (efx->filter_state)  \n\t\treturn 0;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable->mc_chaining = multicast_chaining;\n\ttable->rx_match_count = 0;\n\trc = efx_mcdi_filter_table_probe_matches(efx, table, false);\n\tif (rc)\n\t\tgoto fail;\n\tif (efx_has_cap(efx, VXLAN_NVGRE))\n\t\trc = efx_mcdi_filter_table_probe_matches(efx, table, true);\n\tif (rc)\n\t\tgoto fail;\n\tif ((efx_supported_features(efx) & NETIF_F_HW_VLAN_CTAG_FILTER) &&\n\t    !(efx_mcdi_filter_match_supported(table, false,\n\t\t(EFX_FILTER_MATCH_OUTER_VID | EFX_FILTER_MATCH_LOC_MAC)) &&\n\t      efx_mcdi_filter_match_supported(table, false,\n\t\t(EFX_FILTER_MATCH_OUTER_VID | EFX_FILTER_MATCH_LOC_MAC_IG)))) {\n\t\tnetif_info(efx, probe, net_dev,\n\t\t\t   \"VLAN filters are not supported in this firmware variant\\n\");\n\t\tnet_dev->features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\tefx->fixed_features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\tnet_dev->hw_features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\t}\n\n\ttable->entry = vzalloc(array_size(EFX_MCDI_FILTER_TBL_ROWS,\n\t\t\t\t\t  sizeof(*table->entry)));\n\tif (!table->entry) {\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\ttable->mc_promisc_last = false;\n\ttable->vlan_filter =\n\t\t!!(efx->net_dev->features & NETIF_F_HW_VLAN_CTAG_FILTER);\n\tINIT_LIST_HEAD(&table->vlan_list);\n\tinit_rwsem(&table->lock);\n\n\tefx->filter_state = table;\n\n\treturn 0;\nfail:\n\tkfree(table);\n\treturn rc;\n}\n\nvoid efx_mcdi_filter_table_reset_mc_allocations(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\n\tif (table) {\n\t\ttable->must_restore_filters = true;\n\t\ttable->must_restore_rss_contexts = true;\n\t}\n}\n\n \nvoid efx_mcdi_filter_table_restore(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tunsigned int invalid_filters = 0, failed = 0;\n\tstruct efx_mcdi_filter_vlan *vlan;\n\tstruct efx_filter_spec *spec;\n\tstruct efx_rss_context *ctx;\n\tunsigned int filter_idx;\n\tu32 mcdi_flags;\n\tint match_pri;\n\tint rc, i;\n\n\tWARN_ON(!rwsem_is_locked(&efx->filter_sem));\n\n\tif (!table || !table->must_restore_filters)\n\t\treturn;\n\n\tdown_write(&table->lock);\n\tmutex_lock(&efx->rss_lock);\n\n\tfor (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {\n\t\tspec = efx_mcdi_filter_entry_spec(table, filter_idx);\n\t\tif (!spec)\n\t\t\tcontinue;\n\n\t\tmcdi_flags = efx_mcdi_filter_mcdi_flags_from_spec(spec);\n\t\tmatch_pri = 0;\n\t\twhile (match_pri < table->rx_match_count &&\n\t\t       table->rx_match_mcdi_flags[match_pri] != mcdi_flags)\n\t\t\t++match_pri;\n\t\tif (match_pri >= table->rx_match_count) {\n\t\t\tinvalid_filters++;\n\t\t\tgoto not_restored;\n\t\t}\n\t\tif (spec->rss_context)\n\t\t\tctx = efx_find_rss_context_entry(efx, spec->rss_context);\n\t\telse\n\t\t\tctx = &efx->rss_context;\n\t\tif (spec->flags & EFX_FILTER_FLAG_RX_RSS) {\n\t\t\tif (!ctx) {\n\t\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t\t   \"Warning: unable to restore a filter with nonexistent RSS context %u.\\n\",\n\t\t\t\t\t   spec->rss_context);\n\t\t\t\tinvalid_filters++;\n\t\t\t\tgoto not_restored;\n\t\t\t}\n\t\t\tif (ctx->context_id == EFX_MCDI_RSS_CONTEXT_INVALID) {\n\t\t\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t\t\t   \"Warning: unable to restore a filter with RSS context %u as it was not created.\\n\",\n\t\t\t\t\t   spec->rss_context);\n\t\t\t\tinvalid_filters++;\n\t\t\t\tgoto not_restored;\n\t\t\t}\n\t\t}\n\n\t\trc = efx_mcdi_filter_push(efx, spec,\n\t\t\t\t\t  &table->entry[filter_idx].handle,\n\t\t\t\t\t  ctx, false);\n\t\tif (rc)\n\t\t\tfailed++;\n\n\t\tif (rc) {\nnot_restored:\n\t\t\tlist_for_each_entry(vlan, &table->vlan_list, list)\n\t\t\t\tfor (i = 0; i < EFX_EF10_NUM_DEFAULT_FILTERS; ++i)\n\t\t\t\t\tif (vlan->default_filters[i] == filter_idx)\n\t\t\t\t\t\tvlan->default_filters[i] =\n\t\t\t\t\t\t\tEFX_EF10_FILTER_ID_INVALID;\n\n\t\t\tkfree(spec);\n\t\t\tefx_mcdi_filter_set_entry(table, filter_idx, NULL, 0);\n\t\t}\n\t}\n\n\tmutex_unlock(&efx->rss_lock);\n\tup_write(&table->lock);\n\n\t \n\tif (invalid_filters)\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  \"Did not restore %u filters that are now unsupported.\\n\",\n\t\t\t  invalid_filters);\n\n\tif (failed)\n\t\tnetif_err(efx, hw, efx->net_dev,\n\t\t\t  \"unable to restore %u filters\\n\", failed);\n\telse\n\t\ttable->must_restore_filters = false;\n}\n\nvoid efx_mcdi_filter_table_down(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FILTER_OP_EXT_IN_LEN);\n\tstruct efx_filter_spec *spec;\n\tunsigned int filter_idx;\n\tint rc;\n\n\tif (!table)\n\t\treturn;\n\n\tefx_mcdi_filter_cleanup_vlans(efx);\n\n\tfor (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {\n\t\tspec = efx_mcdi_filter_entry_spec(table, filter_idx);\n\t\tif (!spec)\n\t\t\tcontinue;\n\n\t\tMCDI_SET_DWORD(inbuf, FILTER_OP_IN_OP,\n\t\t\t       efx_mcdi_filter_is_exclusive(spec) ?\n\t\t\t       MC_CMD_FILTER_OP_IN_OP_REMOVE :\n\t\t\t       MC_CMD_FILTER_OP_IN_OP_UNSUBSCRIBE);\n\t\tMCDI_SET_QWORD(inbuf, FILTER_OP_IN_HANDLE,\n\t\t\t       table->entry[filter_idx].handle);\n\t\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_FILTER_OP, inbuf,\n\t\t\t\t\tsizeof(inbuf), NULL, 0, NULL);\n\t\tif (rc)\n\t\t\tnetif_info(efx, drv, efx->net_dev,\n\t\t\t\t   \"%s: filter %04x remove failed\\n\",\n\t\t\t\t   __func__, filter_idx);\n\t\tkfree(spec);\n\t}\n}\n\nvoid efx_mcdi_filter_table_remove(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\n\tefx_mcdi_filter_table_down(efx);\n\n\tefx->filter_state = NULL;\n\t \n\tif (!efx_rwsem_assert_write_locked(&efx->filter_sem))\n\t\treturn;\n\n\tif (!table)\n\t\treturn;\n\n\tvfree(table->entry);\n\tkfree(table);\n}\n\nstatic void efx_mcdi_filter_mark_one_old(struct efx_nic *efx, uint16_t *id)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tunsigned int filter_idx;\n\n\tefx_rwsem_assert_write_locked(&table->lock);\n\n\tif (*id != EFX_EF10_FILTER_ID_INVALID) {\n\t\tfilter_idx = efx_mcdi_filter_get_unsafe_id(*id);\n\t\tif (!table->entry[filter_idx].spec)\n\t\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t\t  \"marked null spec old %04x:%04x\\n\", *id,\n\t\t\t\t  filter_idx);\n\t\ttable->entry[filter_idx].spec |= EFX_EF10_FILTER_FLAG_AUTO_OLD;\n\t\t*id = EFX_EF10_FILTER_ID_INVALID;\n\t}\n}\n\n \nstatic void _efx_mcdi_filter_vlan_mark_old(struct efx_nic *efx,\n\t\t\t\t\t   struct efx_mcdi_filter_vlan *vlan)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tunsigned int i;\n\n\tfor (i = 0; i < table->dev_uc_count; i++)\n\t\tefx_mcdi_filter_mark_one_old(efx, &vlan->uc[i]);\n\tfor (i = 0; i < table->dev_mc_count; i++)\n\t\tefx_mcdi_filter_mark_one_old(efx, &vlan->mc[i]);\n\tfor (i = 0; i < EFX_EF10_NUM_DEFAULT_FILTERS; i++)\n\t\tefx_mcdi_filter_mark_one_old(efx, &vlan->default_filters[i]);\n}\n\n \nstatic void efx_mcdi_filter_mark_old(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct efx_mcdi_filter_vlan *vlan;\n\n\tdown_write(&table->lock);\n\tlist_for_each_entry(vlan, &table->vlan_list, list)\n\t\t_efx_mcdi_filter_vlan_mark_old(efx, vlan);\n\tup_write(&table->lock);\n}\n\nint efx_mcdi_filter_add_vlan(struct efx_nic *efx, u16 vid)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct efx_mcdi_filter_vlan *vlan;\n\tunsigned int i;\n\n\tif (!efx_rwsem_assert_write_locked(&efx->filter_sem))\n\t\treturn -EINVAL;\n\n\tvlan = efx_mcdi_filter_find_vlan(efx, vid);\n\tif (WARN_ON(vlan)) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"VLAN %u already added\\n\", vid);\n\t\treturn -EALREADY;\n\t}\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tvlan->vid = vid;\n\n\tfor (i = 0; i < ARRAY_SIZE(vlan->uc); i++)\n\t\tvlan->uc[i] = EFX_EF10_FILTER_ID_INVALID;\n\tfor (i = 0; i < ARRAY_SIZE(vlan->mc); i++)\n\t\tvlan->mc[i] = EFX_EF10_FILTER_ID_INVALID;\n\tfor (i = 0; i < EFX_EF10_NUM_DEFAULT_FILTERS; i++)\n\t\tvlan->default_filters[i] = EFX_EF10_FILTER_ID_INVALID;\n\n\tlist_add_tail(&vlan->list, &table->vlan_list);\n\n\tif (efx_dev_registered(efx))\n\t\tefx_mcdi_filter_vlan_sync_rx_mode(efx, vlan);\n\n\treturn 0;\n}\n\nstatic void efx_mcdi_filter_del_vlan_internal(struct efx_nic *efx,\n\t\t\t\t\t      struct efx_mcdi_filter_vlan *vlan)\n{\n\tunsigned int i;\n\n\t \n\tif (!efx_rwsem_assert_write_locked(&efx->filter_sem))\n\t\treturn;\n\n\tlist_del(&vlan->list);\n\n\tfor (i = 0; i < ARRAY_SIZE(vlan->uc); i++)\n\t\tefx_mcdi_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,\n\t\t\t\t\t      vlan->uc[i]);\n\tfor (i = 0; i < ARRAY_SIZE(vlan->mc); i++)\n\t\tefx_mcdi_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,\n\t\t\t\t\t      vlan->mc[i]);\n\tfor (i = 0; i < EFX_EF10_NUM_DEFAULT_FILTERS; i++)\n\t\tif (vlan->default_filters[i] != EFX_EF10_FILTER_ID_INVALID)\n\t\t\tefx_mcdi_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,\n\t\t\t\t\t\t      vlan->default_filters[i]);\n\n\tkfree(vlan);\n}\n\nvoid efx_mcdi_filter_del_vlan(struct efx_nic *efx, u16 vid)\n{\n\tstruct efx_mcdi_filter_vlan *vlan;\n\n\t \n\tif (!efx_rwsem_assert_write_locked(&efx->filter_sem))\n\t\treturn;\n\n\tvlan = efx_mcdi_filter_find_vlan(efx, vid);\n\tif (!vlan) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"VLAN %u not found in filter state\\n\", vid);\n\t\treturn;\n\t}\n\n\tefx_mcdi_filter_del_vlan_internal(efx, vlan);\n}\n\nstruct efx_mcdi_filter_vlan *efx_mcdi_filter_find_vlan(struct efx_nic *efx,\n\t\t\t\t\t\t       u16 vid)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct efx_mcdi_filter_vlan *vlan;\n\n\tWARN_ON(!rwsem_is_locked(&efx->filter_sem));\n\n\tlist_for_each_entry(vlan, &table->vlan_list, list) {\n\t\tif (vlan->vid == vid)\n\t\t\treturn vlan;\n\t}\n\n\treturn NULL;\n}\n\nvoid efx_mcdi_filter_cleanup_vlans(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct efx_mcdi_filter_vlan *vlan, *next_vlan;\n\n\t \n\tif (!efx_rwsem_assert_write_locked(&efx->filter_sem))\n\t\treturn;\n\n\tif (!table)\n\t\treturn;\n\n\tlist_for_each_entry_safe(vlan, next_vlan, &table->vlan_list, list)\n\t\tefx_mcdi_filter_del_vlan_internal(efx, vlan);\n}\n\nstatic void efx_mcdi_filter_uc_addr_list(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct netdev_hw_addr *uc;\n\tunsigned int i;\n\n\ttable->uc_promisc = !!(net_dev->flags & IFF_PROMISC);\n\tether_addr_copy(table->dev_uc_list[0].addr, net_dev->dev_addr);\n\ti = 1;\n\tnetdev_for_each_uc_addr(uc, net_dev) {\n\t\tif (i >= EFX_EF10_FILTER_DEV_UC_MAX) {\n\t\t\ttable->uc_promisc = true;\n\t\t\tbreak;\n\t\t}\n\t\tether_addr_copy(table->dev_uc_list[i].addr, uc->addr);\n\t\ti++;\n\t}\n\n\ttable->dev_uc_count = i;\n}\n\nstatic void efx_mcdi_filter_mc_addr_list(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct netdev_hw_addr *mc;\n\tunsigned int i;\n\n\ttable->mc_overflow = false;\n\ttable->mc_promisc = !!(net_dev->flags & (IFF_PROMISC | IFF_ALLMULTI));\n\n\ti = 0;\n\tnetdev_for_each_mc_addr(mc, net_dev) {\n\t\tif (i >= EFX_EF10_FILTER_DEV_MC_MAX) {\n\t\t\ttable->mc_promisc = true;\n\t\t\ttable->mc_overflow = true;\n\t\t\tbreak;\n\t\t}\n\t\tether_addr_copy(table->dev_mc_list[i].addr, mc->addr);\n\t\ti++;\n\t}\n\n\ttable->dev_mc_count = i;\n}\n\n \nvoid efx_mcdi_filter_sync_rx_mode(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_mcdi_filter_vlan *vlan;\n\tbool vlan_filter;\n\n\tif (!efx_dev_registered(efx))\n\t\treturn;\n\n\tif (!table)\n\t\treturn;\n\n\tefx_mcdi_filter_mark_old(efx);\n\n\t \n\tnetif_addr_lock_bh(net_dev);\n\tefx_mcdi_filter_uc_addr_list(efx);\n\tefx_mcdi_filter_mc_addr_list(efx);\n\tnetif_addr_unlock_bh(net_dev);\n\n\t \n\tvlan_filter = !!(net_dev->features & NETIF_F_HW_VLAN_CTAG_FILTER);\n\tif (table->vlan_filter != vlan_filter) {\n\t\ttable->vlan_filter = vlan_filter;\n\t\tefx_mcdi_filter_remove_old(efx);\n\t}\n\n\tlist_for_each_entry(vlan, &table->vlan_list, list)\n\t\tefx_mcdi_filter_vlan_sync_rx_mode(efx, vlan);\n\n\tefx_mcdi_filter_remove_old(efx);\n\ttable->mc_promisc_last = table->mc_promisc;\n}\n\n#ifdef CONFIG_RFS_ACCEL\n\nbool efx_mcdi_filter_rfs_expire_one(struct efx_nic *efx, u32 flow_id,\n\t\t\t\t    unsigned int filter_idx)\n{\n\tstruct efx_filter_spec *spec, saved_spec;\n\tstruct efx_mcdi_filter_table *table;\n\tstruct efx_arfs_rule *rule = NULL;\n\tbool ret = true, force = false;\n\tu16 arfs_id;\n\n\tdown_read(&efx->filter_sem);\n\ttable = efx->filter_state;\n\tdown_write(&table->lock);\n\tspec = efx_mcdi_filter_entry_spec(table, filter_idx);\n\n\tif (!spec || spec->priority != EFX_FILTER_PRI_HINT)\n\t\tgoto out_unlock;\n\n\tspin_lock_bh(&efx->rps_hash_lock);\n\tif (!efx->rps_hash_table) {\n\t\t \n\t\tarfs_id = 0;\n\t} else {\n\t\trule = efx_rps_hash_find(efx, spec);\n\t\tif (!rule)\n\t\t\t \n\t\t\tgoto expire;\n\t\tarfs_id = rule->arfs_id;\n\t\tret = efx_rps_check_rule(rule, filter_idx, &force);\n\t\tif (force)\n\t\t\tgoto expire;\n\t\tif (!ret) {\n\t\t\tspin_unlock_bh(&efx->rps_hash_lock);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tif (!rps_may_expire_flow(efx->net_dev, spec->dmaq_id, flow_id, arfs_id))\n\t\tret = false;\n\telse if (rule)\n\t\trule->filter_id = EFX_ARFS_FILTER_ID_REMOVING;\nexpire:\n\tsaved_spec = *spec;  \n\tspin_unlock_bh(&efx->rps_hash_lock);\n\t \n\tif (ret)\n\t\tret = efx_mcdi_filter_remove_internal(efx, 1U << spec->priority,\n\t\t\t\t\t\t      filter_idx, true) == 0;\n\t \n\tif (ret && rule) {\n\t\t \n\t\tspin_lock_bh(&efx->rps_hash_lock);\n\t\tefx_rps_hash_del(efx, &saved_spec);\n\t\tspin_unlock_bh(&efx->rps_hash_lock);\n\t}\nout_unlock:\n\tup_write(&table->lock);\n\tup_read(&efx->filter_sem);\n\treturn ret;\n}\n\n#endif  \n\n#define RSS_MODE_HASH_ADDRS\t(1 << RSS_MODE_HASH_SRC_ADDR_LBN |\\\n\t\t\t\t 1 << RSS_MODE_HASH_DST_ADDR_LBN)\n#define RSS_MODE_HASH_PORTS\t(1 << RSS_MODE_HASH_SRC_PORT_LBN |\\\n\t\t\t\t 1 << RSS_MODE_HASH_DST_PORT_LBN)\n#define RSS_CONTEXT_FLAGS_DEFAULT\t(1 << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_TOEPLITZ_IPV4_EN_LBN |\\\n\t\t\t\t\t 1 << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_TOEPLITZ_TCPV4_EN_LBN |\\\n\t\t\t\t\t 1 << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_TOEPLITZ_IPV6_EN_LBN |\\\n\t\t\t\t\t 1 << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_TOEPLITZ_TCPV6_EN_LBN |\\\n\t\t\t\t\t (RSS_MODE_HASH_ADDRS | RSS_MODE_HASH_PORTS) << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_TCP_IPV4_RSS_MODE_LBN |\\\n\t\t\t\t\t RSS_MODE_HASH_ADDRS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_UDP_IPV4_RSS_MODE_LBN |\\\n\t\t\t\t\t RSS_MODE_HASH_ADDRS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_OTHER_IPV4_RSS_MODE_LBN |\\\n\t\t\t\t\t (RSS_MODE_HASH_ADDRS | RSS_MODE_HASH_PORTS) << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_TCP_IPV6_RSS_MODE_LBN |\\\n\t\t\t\t\t RSS_MODE_HASH_ADDRS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_UDP_IPV6_RSS_MODE_LBN |\\\n\t\t\t\t\t RSS_MODE_HASH_ADDRS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_OTHER_IPV6_RSS_MODE_LBN)\n\nint efx_mcdi_get_rss_context_flags(struct efx_nic *efx, u32 context, u32 *flags)\n{\n\t \n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\n\t \n\tBUILD_BUG_ON(MC_CMD_RSS_CONTEXT_GET_FLAGS_IN_LEN != MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_FLAGS_OFST);\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_GET_FLAGS_IN_RSS_CONTEXT_ID, context);\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_GET_FLAGS_OUT_FLAGS,\n\t\t       RSS_CONTEXT_FLAGS_DEFAULT);\n\trc = efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_GET_FLAGS, inbuf,\n\t\t\t  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\n\tif (rc == 0) {\n\t\tif (outlen < MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_LEN)\n\t\t\trc = -EIO;\n\t\telse\n\t\t\t*flags = MCDI_DWORD(outbuf, RSS_CONTEXT_GET_FLAGS_OUT_FLAGS);\n\t}\n\treturn rc;\n}\n\n \nvoid efx_mcdi_set_rss_context_flags(struct efx_nic *efx,\n\t\t\t\t    struct efx_rss_context *ctx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_SET_FLAGS_IN_LEN);\n\tu32 flags;\n\n\tBUILD_BUG_ON(MC_CMD_RSS_CONTEXT_SET_FLAGS_OUT_LEN != 0);\n\n\tif (efx_mcdi_get_rss_context_flags(efx, ctx->context_id, &flags) != 0)\n\t\treturn;\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_SET_FLAGS_IN_RSS_CONTEXT_ID,\n\t\t       ctx->context_id);\n\tflags |= RSS_MODE_HASH_PORTS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_UDP_IPV4_RSS_MODE_LBN;\n\tflags |= RSS_MODE_HASH_PORTS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_UDP_IPV6_RSS_MODE_LBN;\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_SET_FLAGS_IN_FLAGS, flags);\n\tif (!efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_SET_FLAGS, inbuf, sizeof(inbuf),\n\t\t\t  NULL, 0, NULL))\n\t\t \n\t\tctx->rx_hash_udp_4tuple = true;\n}\n\nstatic int efx_mcdi_filter_alloc_rss_context(struct efx_nic *efx, bool exclusive,\n\t\t\t\t\t     struct efx_rss_context *ctx,\n\t\t\t\t\t     unsigned *context_size)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_ALLOC_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_RSS_CONTEXT_ALLOC_OUT_LEN);\n\tsize_t outlen;\n\tint rc;\n\tu32 alloc_type = exclusive ?\n\t\t\t\tMC_CMD_RSS_CONTEXT_ALLOC_IN_TYPE_EXCLUSIVE :\n\t\t\t\tMC_CMD_RSS_CONTEXT_ALLOC_IN_TYPE_SHARED;\n\tunsigned rss_spread = exclusive ?\n\t\t\t\tefx->rss_spread :\n\t\t\t\tmin(rounddown_pow_of_two(efx->rss_spread),\n\t\t\t\t    EFX_EF10_MAX_SHARED_RSS_CONTEXT_SIZE);\n\n\tif (!exclusive && rss_spread == 1) {\n\t\tctx->context_id = EFX_MCDI_RSS_CONTEXT_INVALID;\n\t\tif (context_size)\n\t\t\t*context_size = 1;\n\t\treturn 0;\n\t}\n\n\tif (efx_has_cap(efx, RX_RSS_LIMITED))\n\t\treturn -EOPNOTSUPP;\n\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_ALLOC_IN_UPSTREAM_PORT_ID,\n\t\t       efx->vport_id);\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_ALLOC_IN_TYPE, alloc_type);\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_ALLOC_IN_NUM_QUEUES, rss_spread);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_ALLOC, inbuf, sizeof(inbuf),\n\t\toutbuf, sizeof(outbuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (outlen < MC_CMD_RSS_CONTEXT_ALLOC_OUT_LEN)\n\t\treturn -EIO;\n\n\tctx->context_id = MCDI_DWORD(outbuf, RSS_CONTEXT_ALLOC_OUT_RSS_CONTEXT_ID);\n\n\tif (context_size)\n\t\t*context_size = rss_spread;\n\n\tif (efx_has_cap(efx, ADDITIONAL_RSS_MODES))\n\t\tefx_mcdi_set_rss_context_flags(efx, ctx);\n\n\treturn 0;\n}\n\nstatic int efx_mcdi_filter_free_rss_context(struct efx_nic *efx, u32 context)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_FREE_IN_LEN);\n\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_FREE_IN_RSS_CONTEXT_ID,\n\t\t       context);\n\treturn efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_FREE, inbuf, sizeof(inbuf),\n\t\t\t    NULL, 0, NULL);\n}\n\nstatic int efx_mcdi_filter_populate_rss_table(struct efx_nic *efx, u32 context,\n\t\t\t\t       const u32 *rx_indir_table, const u8 *key)\n{\n\tMCDI_DECLARE_BUF(tablebuf, MC_CMD_RSS_CONTEXT_SET_TABLE_IN_LEN);\n\tMCDI_DECLARE_BUF(keybuf, MC_CMD_RSS_CONTEXT_SET_KEY_IN_LEN);\n\tint i, rc;\n\n\tMCDI_SET_DWORD(tablebuf, RSS_CONTEXT_SET_TABLE_IN_RSS_CONTEXT_ID,\n\t\t       context);\n\tBUILD_BUG_ON(ARRAY_SIZE(efx->rss_context.rx_indir_table) !=\n\t\t     MC_CMD_RSS_CONTEXT_SET_TABLE_IN_INDIRECTION_TABLE_LEN);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(efx->rss_context.rx_indir_table); ++i)\n\t\tMCDI_PTR(tablebuf,\n\t\t\t RSS_CONTEXT_SET_TABLE_IN_INDIRECTION_TABLE)[i] =\n\t\t\t\t(u8) rx_indir_table[i];\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_SET_TABLE, tablebuf,\n\t\t\t  sizeof(tablebuf), NULL, 0, NULL);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tMCDI_SET_DWORD(keybuf, RSS_CONTEXT_SET_KEY_IN_RSS_CONTEXT_ID,\n\t\t       context);\n\tBUILD_BUG_ON(ARRAY_SIZE(efx->rss_context.rx_hash_key) !=\n\t\t     MC_CMD_RSS_CONTEXT_SET_KEY_IN_TOEPLITZ_KEY_LEN);\n\tfor (i = 0; i < ARRAY_SIZE(efx->rss_context.rx_hash_key); ++i)\n\t\tMCDI_PTR(keybuf, RSS_CONTEXT_SET_KEY_IN_TOEPLITZ_KEY)[i] = key[i];\n\n\treturn efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_SET_KEY, keybuf,\n\t\t\t    sizeof(keybuf), NULL, 0, NULL);\n}\n\nvoid efx_mcdi_rx_free_indir_table(struct efx_nic *efx)\n{\n\tint rc;\n\n\tif (efx->rss_context.context_id != EFX_MCDI_RSS_CONTEXT_INVALID) {\n\t\trc = efx_mcdi_filter_free_rss_context(efx, efx->rss_context.context_id);\n\t\tWARN_ON(rc != 0);\n\t}\n\tefx->rss_context.context_id = EFX_MCDI_RSS_CONTEXT_INVALID;\n}\n\nstatic int efx_mcdi_filter_rx_push_shared_rss_config(struct efx_nic *efx,\n\t\t\t\t\t      unsigned *context_size)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tint rc = efx_mcdi_filter_alloc_rss_context(efx, false, &efx->rss_context,\n\t\t\t\t\t    context_size);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\ttable->rx_rss_context_exclusive = false;\n\tefx_set_default_rx_indir_table(efx, &efx->rss_context);\n\treturn 0;\n}\n\nstatic int efx_mcdi_filter_rx_push_exclusive_rss_config(struct efx_nic *efx,\n\t\t\t\t\t\t const u32 *rx_indir_table,\n\t\t\t\t\t\t const u8 *key)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tu32 old_rx_rss_context = efx->rss_context.context_id;\n\tint rc;\n\n\tif (efx->rss_context.context_id == EFX_MCDI_RSS_CONTEXT_INVALID ||\n\t    !table->rx_rss_context_exclusive) {\n\t\trc = efx_mcdi_filter_alloc_rss_context(efx, true, &efx->rss_context,\n\t\t\t\t\t\tNULL);\n\t\tif (rc == -EOPNOTSUPP)\n\t\t\treturn rc;\n\t\telse if (rc != 0)\n\t\t\tgoto fail1;\n\t}\n\n\trc = efx_mcdi_filter_populate_rss_table(efx, efx->rss_context.context_id,\n\t\t\t\t\t rx_indir_table, key);\n\tif (rc != 0)\n\t\tgoto fail2;\n\n\tif (efx->rss_context.context_id != old_rx_rss_context &&\n\t    old_rx_rss_context != EFX_MCDI_RSS_CONTEXT_INVALID)\n\t\tWARN_ON(efx_mcdi_filter_free_rss_context(efx, old_rx_rss_context) != 0);\n\ttable->rx_rss_context_exclusive = true;\n\tif (rx_indir_table != efx->rss_context.rx_indir_table)\n\t\tmemcpy(efx->rss_context.rx_indir_table, rx_indir_table,\n\t\t       sizeof(efx->rss_context.rx_indir_table));\n\tif (key != efx->rss_context.rx_hash_key)\n\t\tmemcpy(efx->rss_context.rx_hash_key, key,\n\t\t       efx->type->rx_hash_key_size);\n\n\treturn 0;\n\nfail2:\n\tif (old_rx_rss_context != efx->rss_context.context_id) {\n\t\tWARN_ON(efx_mcdi_filter_free_rss_context(efx, efx->rss_context.context_id) != 0);\n\t\tefx->rss_context.context_id = old_rx_rss_context;\n\t}\nfail1:\n\tnetif_err(efx, hw, efx->net_dev, \"%s: failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nint efx_mcdi_rx_push_rss_context_config(struct efx_nic *efx,\n\t\t\t\t\tstruct efx_rss_context *ctx,\n\t\t\t\t\tconst u32 *rx_indir_table,\n\t\t\t\t\tconst u8 *key)\n{\n\tint rc;\n\n\tWARN_ON(!mutex_is_locked(&efx->rss_lock));\n\n\tif (ctx->context_id == EFX_MCDI_RSS_CONTEXT_INVALID) {\n\t\trc = efx_mcdi_filter_alloc_rss_context(efx, true, ctx, NULL);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (!rx_indir_table)  \n\t\treturn efx_mcdi_filter_free_rss_context(efx, ctx->context_id);\n\n\trc = efx_mcdi_filter_populate_rss_table(efx, ctx->context_id,\n\t\t\t\t\t rx_indir_table, key);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(ctx->rx_indir_table, rx_indir_table,\n\t       sizeof(efx->rss_context.rx_indir_table));\n\tmemcpy(ctx->rx_hash_key, key, efx->type->rx_hash_key_size);\n\n\treturn 0;\n}\n\nint efx_mcdi_rx_pull_rss_context_config(struct efx_nic *efx,\n\t\t\t\t\tstruct efx_rss_context *ctx)\n{\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_GET_TABLE_IN_LEN);\n\tMCDI_DECLARE_BUF(tablebuf, MC_CMD_RSS_CONTEXT_GET_TABLE_OUT_LEN);\n\tMCDI_DECLARE_BUF(keybuf, MC_CMD_RSS_CONTEXT_GET_KEY_OUT_LEN);\n\tsize_t outlen;\n\tint rc, i;\n\n\tWARN_ON(!mutex_is_locked(&efx->rss_lock));\n\n\tBUILD_BUG_ON(MC_CMD_RSS_CONTEXT_GET_TABLE_IN_LEN !=\n\t\t     MC_CMD_RSS_CONTEXT_GET_KEY_IN_LEN);\n\n\tif (ctx->context_id == EFX_MCDI_RSS_CONTEXT_INVALID)\n\t\treturn -ENOENT;\n\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_GET_TABLE_IN_RSS_CONTEXT_ID,\n\t\t       ctx->context_id);\n\tBUILD_BUG_ON(ARRAY_SIZE(ctx->rx_indir_table) !=\n\t\t     MC_CMD_RSS_CONTEXT_GET_TABLE_OUT_INDIRECTION_TABLE_LEN);\n\trc = efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_GET_TABLE, inbuf, sizeof(inbuf),\n\t\t\t  tablebuf, sizeof(tablebuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (WARN_ON(outlen != MC_CMD_RSS_CONTEXT_GET_TABLE_OUT_LEN))\n\t\treturn -EIO;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctx->rx_indir_table); i++)\n\t\tctx->rx_indir_table[i] = MCDI_PTR(tablebuf,\n\t\t\t\tRSS_CONTEXT_GET_TABLE_OUT_INDIRECTION_TABLE)[i];\n\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_GET_KEY_IN_RSS_CONTEXT_ID,\n\t\t       ctx->context_id);\n\tBUILD_BUG_ON(ARRAY_SIZE(ctx->rx_hash_key) !=\n\t\t     MC_CMD_RSS_CONTEXT_SET_KEY_IN_TOEPLITZ_KEY_LEN);\n\trc = efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_GET_KEY, inbuf, sizeof(inbuf),\n\t\t\t  keybuf, sizeof(keybuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (WARN_ON(outlen != MC_CMD_RSS_CONTEXT_GET_KEY_OUT_LEN))\n\t\treturn -EIO;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctx->rx_hash_key); ++i)\n\t\tctx->rx_hash_key[i] = MCDI_PTR(\n\t\t\t\tkeybuf, RSS_CONTEXT_GET_KEY_OUT_TOEPLITZ_KEY)[i];\n\n\treturn 0;\n}\n\nint efx_mcdi_rx_pull_rss_config(struct efx_nic *efx)\n{\n\tint rc;\n\n\tmutex_lock(&efx->rss_lock);\n\trc = efx_mcdi_rx_pull_rss_context_config(efx, &efx->rss_context);\n\tmutex_unlock(&efx->rss_lock);\n\treturn rc;\n}\n\nvoid efx_mcdi_rx_restore_rss_contexts(struct efx_nic *efx)\n{\n\tstruct efx_mcdi_filter_table *table = efx->filter_state;\n\tstruct efx_rss_context *ctx;\n\tint rc;\n\n\tWARN_ON(!mutex_is_locked(&efx->rss_lock));\n\n\tif (!table->must_restore_rss_contexts)\n\t\treturn;\n\n\tlist_for_each_entry(ctx, &efx->rss_context.list, list) {\n\t\t \n\t\tctx->context_id = EFX_MCDI_RSS_CONTEXT_INVALID;\n\t\t \n\t\trc = efx_mcdi_rx_push_rss_context_config(efx, ctx,\n\t\t\t\t\t\t\t ctx->rx_indir_table,\n\t\t\t\t\t\t\t ctx->rx_hash_key);\n\t\tif (rc)\n\t\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t\t   \"failed to restore RSS context %u, rc=%d\"\n\t\t\t\t   \"; RSS filters may fail to be applied\\n\",\n\t\t\t\t   ctx->user_id, rc);\n\t}\n\ttable->must_restore_rss_contexts = false;\n}\n\nint efx_mcdi_pf_rx_push_rss_config(struct efx_nic *efx, bool user,\n\t\t\t\t   const u32 *rx_indir_table,\n\t\t\t\t   const u8 *key)\n{\n\tint rc;\n\n\tif (efx->rss_spread == 1)\n\t\treturn 0;\n\n\tif (!key)\n\t\tkey = efx->rss_context.rx_hash_key;\n\n\trc = efx_mcdi_filter_rx_push_exclusive_rss_config(efx, rx_indir_table, key);\n\n\tif (rc == -ENOBUFS && !user) {\n\t\tunsigned context_size;\n\t\tbool mismatch = false;\n\t\tsize_t i;\n\n\t\tfor (i = 0;\n\t\t     i < ARRAY_SIZE(efx->rss_context.rx_indir_table) && !mismatch;\n\t\t     i++)\n\t\t\tmismatch = rx_indir_table[i] !=\n\t\t\t\tethtool_rxfh_indir_default(i, efx->rss_spread);\n\n\t\trc = efx_mcdi_filter_rx_push_shared_rss_config(efx, &context_size);\n\t\tif (rc == 0) {\n\t\t\tif (context_size != efx->rss_spread)\n\t\t\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t\t\t   \"Could not allocate an exclusive RSS\"\n\t\t\t\t\t   \" context; allocated a shared one of\"\n\t\t\t\t\t   \" different size.\"\n\t\t\t\t\t   \" Wanted %u, got %u.\\n\",\n\t\t\t\t\t   efx->rss_spread, context_size);\n\t\t\telse if (mismatch)\n\t\t\t\tnetif_warn(efx, probe, efx->net_dev,\n\t\t\t\t\t   \"Could not allocate an exclusive RSS\"\n\t\t\t\t\t   \" context; allocated a shared one but\"\n\t\t\t\t\t   \" could not apply custom\"\n\t\t\t\t\t   \" indirection.\\n\");\n\t\t\telse\n\t\t\t\tnetif_info(efx, probe, efx->net_dev,\n\t\t\t\t\t   \"Could not allocate an exclusive RSS\"\n\t\t\t\t\t   \" context; allocated a shared one.\\n\");\n\t\t}\n\t}\n\treturn rc;\n}\n\nint efx_mcdi_vf_rx_push_rss_config(struct efx_nic *efx, bool user,\n\t\t\t\t   const u32 *rx_indir_table\n\t\t\t\t   __attribute__ ((unused)),\n\t\t\t\t   const u8 *key\n\t\t\t\t   __attribute__ ((unused)))\n{\n\tif (user)\n\t\treturn -EOPNOTSUPP;\n\tif (efx->rss_context.context_id != EFX_MCDI_RSS_CONTEXT_INVALID)\n\t\treturn 0;\n\treturn efx_mcdi_filter_rx_push_shared_rss_config(efx, NULL);\n}\n\nint efx_mcdi_push_default_indir_table(struct efx_nic *efx,\n\t\t\t\t      unsigned int rss_spread)\n{\n\tint rc = 0;\n\n\tif (efx->rss_spread == rss_spread)\n\t\treturn 0;\n\n\tefx->rss_spread = rss_spread;\n\tif (!efx->filter_state)\n\t\treturn 0;\n\n\tefx_mcdi_rx_free_indir_table(efx);\n\tif (rss_spread > 1) {\n\t\tefx_set_default_rx_indir_table(efx, &efx->rss_context);\n\t\trc = efx->type->rx_push_rss_config(efx, false,\n\t\t\t\t   efx->rss_context.rx_indir_table, NULL);\n\t}\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}