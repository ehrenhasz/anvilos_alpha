{
  "module_name": "ftgmac100.c",
  "hash_id": "339fe355034f1eff920df566fa17b184a46981ef18046aac771d76ad7f09d97e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/faraday/ftgmac100.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/crc32.h>\n#include <linux/if_vlan.h>\n#include <linux/of_net.h>\n#include <net/ip.h>\n#include <net/ncsi.h>\n\n#include \"ftgmac100.h\"\n\n#define DRV_NAME\t\"ftgmac100\"\n\n \n#define MAX_RX_QUEUE_ENTRIES\t1024\n#define MAX_TX_QUEUE_ENTRIES\t1024\n#define MIN_RX_QUEUE_ENTRIES\t32\n#define MIN_TX_QUEUE_ENTRIES\t32\n\n \n#define DEF_RX_QUEUE_ENTRIES\t128\n#define DEF_TX_QUEUE_ENTRIES\t128\n\n#define MAX_PKT_SIZE\t\t1536\n#define RX_BUF_SIZE\t\tMAX_PKT_SIZE\t \n\n \n#define TX_THRESHOLD\t\t(MAX_SKB_FRAGS + 1)\n\n#define FTGMAC_100MHZ\t\t100000000\n#define FTGMAC_25MHZ\t\t25000000\n\nstruct ftgmac100 {\n\t \n\tstruct resource *res;\n\tvoid __iomem *base;\n\n\t \n\tunsigned int rx_q_entries;\n\tstruct ftgmac100_rxdes *rxdes;\n\tdma_addr_t rxdes_dma;\n\tstruct sk_buff **rx_skbs;\n\tunsigned int rx_pointer;\n\tu32 rxdes0_edorr_mask;\n\n\t \n\tunsigned int tx_q_entries;\n\tstruct ftgmac100_txdes *txdes;\n\tdma_addr_t txdes_dma;\n\tstruct sk_buff **tx_skbs;\n\tunsigned int tx_clean_pointer;\n\tunsigned int tx_pointer;\n\tu32 txdes0_edotr_mask;\n\n\t \n\tunsigned int new_rx_q_entries;\n\tunsigned int new_tx_q_entries;\n\n\t \n\tvoid *rx_scratch;\n\tdma_addr_t rx_scratch_dma;\n\n\t \n\tstruct net_device *netdev;\n\tstruct device *dev;\n\tstruct ncsi_dev *ndev;\n\tstruct napi_struct napi;\n\tstruct work_struct reset_task;\n\tstruct mii_bus *mii_bus;\n\tstruct clk *clk;\n\n\t \n\tstruct clk *rclk;\n\n\t \n\tint cur_speed;\n\tint cur_duplex;\n\tbool use_ncsi;\n\n\t \n\tu32 maht0;\n\tu32 maht1;\n\n\t \n\tbool tx_pause;\n\tbool rx_pause;\n\tbool aneg_pause;\n\n\t \n\tbool need_mac_restart;\n\tbool is_aspeed;\n};\n\nstatic int ftgmac100_reset_mac(struct ftgmac100 *priv, u32 maccr)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint i;\n\n\t \n\tiowrite32(maccr, priv->base + FTGMAC100_OFFSET_MACCR);\n\tiowrite32(maccr | FTGMAC100_MACCR_SW_RST,\n\t\t  priv->base + FTGMAC100_OFFSET_MACCR);\n\tfor (i = 0; i < 200; i++) {\n\t\tunsigned int maccr;\n\n\t\tmaccr = ioread32(priv->base + FTGMAC100_OFFSET_MACCR);\n\t\tif (!(maccr & FTGMAC100_MACCR_SW_RST))\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\tnetdev_err(netdev, \"Hardware reset failed\\n\");\n\treturn -EIO;\n}\n\nstatic int ftgmac100_reset_and_config_mac(struct ftgmac100 *priv)\n{\n\tu32 maccr = 0;\n\n\tswitch (priv->cur_speed) {\n\tcase SPEED_10:\n\tcase 0:  \n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tmaccr |= FTGMAC100_MACCR_FAST_MODE;\n\t\tbreak;\n\n\tcase SPEED_1000:\n\t\tmaccr |= FTGMAC100_MACCR_GIGA_MODE;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->netdev, \"Unknown speed %d !\\n\",\n\t\t\t   priv->cur_speed);\n\t\tbreak;\n\t}\n\n\t \n\tpriv->rx_pointer = 0;\n\tpriv->tx_clean_pointer = 0;\n\tpriv->tx_pointer = 0;\n\n\t \n\tif (ftgmac100_reset_mac(priv, maccr))\n\t\treturn -EIO;\n\tusleep_range(10, 1000);\n\treturn ftgmac100_reset_mac(priv, maccr);\n}\n\nstatic void ftgmac100_write_mac_addr(struct ftgmac100 *priv, const u8 *mac)\n{\n\tunsigned int maddr = mac[0] << 8 | mac[1];\n\tunsigned int laddr = mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5];\n\n\tiowrite32(maddr, priv->base + FTGMAC100_OFFSET_MAC_MADR);\n\tiowrite32(laddr, priv->base + FTGMAC100_OFFSET_MAC_LADR);\n}\n\nstatic int ftgmac100_initial_mac(struct ftgmac100 *priv)\n{\n\tu8 mac[ETH_ALEN];\n\tunsigned int m;\n\tunsigned int l;\n\tint err;\n\n\terr = of_get_ethdev_address(priv->dev->of_node, priv->netdev);\n\tif (err == -EPROBE_DEFER)\n\t\treturn err;\n\tif (!err) {\n\t\tdev_info(priv->dev, \"Read MAC address %pM from device tree\\n\",\n\t\t\t priv->netdev->dev_addr);\n\t\treturn 0;\n\t}\n\n\tm = ioread32(priv->base + FTGMAC100_OFFSET_MAC_MADR);\n\tl = ioread32(priv->base + FTGMAC100_OFFSET_MAC_LADR);\n\n\tmac[0] = (m >> 8) & 0xff;\n\tmac[1] = m & 0xff;\n\tmac[2] = (l >> 24) & 0xff;\n\tmac[3] = (l >> 16) & 0xff;\n\tmac[4] = (l >> 8) & 0xff;\n\tmac[5] = l & 0xff;\n\n\tif (is_valid_ether_addr(mac)) {\n\t\teth_hw_addr_set(priv->netdev, mac);\n\t\tdev_info(priv->dev, \"Read MAC address %pM from chip\\n\", mac);\n\t} else {\n\t\teth_hw_addr_random(priv->netdev);\n\t\tdev_info(priv->dev, \"Generated random MAC address %pM\\n\",\n\t\t\t priv->netdev->dev_addr);\n\t}\n\n\treturn 0;\n}\n\nstatic int ftgmac100_set_mac_addr(struct net_device *dev, void *p)\n{\n\tint ret;\n\n\tret = eth_prepare_mac_addr_change(dev, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teth_commit_mac_addr_change(dev, p);\n\tftgmac100_write_mac_addr(netdev_priv(dev), dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic void ftgmac100_config_pause(struct ftgmac100 *priv)\n{\n\tu32 fcr = FTGMAC100_FCR_PAUSE_TIME(16);\n\n\t \n\tif (priv->rx_pause)\n\t\tfcr |= FTGMAC100_FCR_FC_EN;\n\n\t \n\tif (priv->tx_pause)\n\t\tfcr |= FTGMAC100_FCR_FCTHR_EN;\n\n\tiowrite32(fcr, priv->base + FTGMAC100_OFFSET_FCR);\n}\n\nstatic void ftgmac100_init_hw(struct ftgmac100 *priv)\n{\n\tu32 reg, rfifo_sz, tfifo_sz;\n\n\t \n\treg = ioread32(priv->base + FTGMAC100_OFFSET_ISR);\n\tiowrite32(reg, priv->base + FTGMAC100_OFFSET_ISR);\n\n\t \n\tiowrite32(priv->rxdes_dma, priv->base + FTGMAC100_OFFSET_RXR_BADR);\n\n\t \n\tiowrite32(priv->txdes_dma, priv->base + FTGMAC100_OFFSET_NPTXR_BADR);\n\n\t \n\tiowrite32(FTGMAC100_RBSR_SIZE(RX_BUF_SIZE),\n\t\t  priv->base + FTGMAC100_OFFSET_RBSR);\n\n\t \n\tiowrite32(FTGMAC100_APTC_RXPOLL_CNT(1),\n\t\t  priv->base + FTGMAC100_OFFSET_APTC);\n\n\t \n\tftgmac100_write_mac_addr(priv, priv->netdev->dev_addr);\n\n\t \n\tiowrite32(priv->maht0, priv->base + FTGMAC100_OFFSET_MAHT0);\n\tiowrite32(priv->maht1, priv->base + FTGMAC100_OFFSET_MAHT1);\n\n\t \n\tiowrite32(FTGMAC100_DBLAC_RXDES_SIZE(2) |    \n\t\t  FTGMAC100_DBLAC_TXDES_SIZE(2) |    \n\t\t  FTGMAC100_DBLAC_RXBURST_SIZE(3) |  \n\t\t  FTGMAC100_DBLAC_TXBURST_SIZE(3) |  \n\t\t  FTGMAC100_DBLAC_RX_THR_EN |        \n\t\t  FTGMAC100_DBLAC_RXFIFO_HTHR(6) |   \n\t\t  FTGMAC100_DBLAC_RXFIFO_LTHR(2),    \n\t\t  priv->base + FTGMAC100_OFFSET_DBLAC);\n\n\t \n\tiowrite32(FTGMAC100_ITC_RXINT_THR(1) |\n\t\t  FTGMAC100_ITC_TXINT_THR(1),\n\t\t  priv->base + FTGMAC100_OFFSET_ITC);\n\n\t \n\treg = ioread32(priv->base + FTGMAC100_OFFSET_FEAR);\n\trfifo_sz = reg & 0x00000007;\n\ttfifo_sz = (reg >> 3) & 0x00000007;\n\treg = ioread32(priv->base + FTGMAC100_OFFSET_TPAFCR);\n\treg &= ~0x3f000000;\n\treg |= (tfifo_sz << 27);\n\treg |= (rfifo_sz << 24);\n\tiowrite32(reg, priv->base + FTGMAC100_OFFSET_TPAFCR);\n}\n\nstatic void ftgmac100_start_hw(struct ftgmac100 *priv)\n{\n\tu32 maccr = ioread32(priv->base + FTGMAC100_OFFSET_MACCR);\n\n\t \n\tmaccr &= (FTGMAC100_MACCR_FAST_MODE | FTGMAC100_MACCR_GIGA_MODE);\n\n\t \n\tmaccr |= FTGMAC100_MACCR_TXDMA_EN\t|\n\t\t FTGMAC100_MACCR_RXDMA_EN\t|\n\t\t FTGMAC100_MACCR_TXMAC_EN\t|\n\t\t FTGMAC100_MACCR_RXMAC_EN\t|\n\t\t FTGMAC100_MACCR_CRC_APD\t|\n\t\t FTGMAC100_MACCR_PHY_LINK_LEVEL\t|\n\t\t FTGMAC100_MACCR_RX_RUNT\t|\n\t\t FTGMAC100_MACCR_RX_BROADPKT;\n\n\t \n\tif (priv->cur_duplex == DUPLEX_FULL)\n\t\tmaccr |= FTGMAC100_MACCR_FULLDUP;\n\tif (priv->netdev->flags & IFF_PROMISC)\n\t\tmaccr |= FTGMAC100_MACCR_RX_ALL;\n\tif (priv->netdev->flags & IFF_ALLMULTI)\n\t\tmaccr |= FTGMAC100_MACCR_RX_MULTIPKT;\n\telse if (netdev_mc_count(priv->netdev))\n\t\tmaccr |= FTGMAC100_MACCR_HT_MULTI_EN;\n\n\t \n\tif (priv->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tmaccr |= FTGMAC100_MACCR_RM_VLAN;\n\n\t \n\tiowrite32(maccr, priv->base + FTGMAC100_OFFSET_MACCR);\n}\n\nstatic void ftgmac100_stop_hw(struct ftgmac100 *priv)\n{\n\tiowrite32(0, priv->base + FTGMAC100_OFFSET_MACCR);\n}\n\nstatic void ftgmac100_calc_mc_hash(struct ftgmac100 *priv)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tpriv->maht1 = 0;\n\tpriv->maht0 = 0;\n\tnetdev_for_each_mc_addr(ha, priv->netdev) {\n\t\tu32 crc_val = ether_crc_le(ETH_ALEN, ha->addr);\n\n\t\tcrc_val = (~(crc_val >> 2)) & 0x3f;\n\t\tif (crc_val >= 32)\n\t\t\tpriv->maht1 |= 1ul << (crc_val - 32);\n\t\telse\n\t\t\tpriv->maht0 |= 1ul << (crc_val);\n\t}\n}\n\nstatic void ftgmac100_set_rx_mode(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\t \n\tftgmac100_calc_mc_hash(priv);\n\n\t \n\tif (!netif_running(netdev))\n\t\treturn;\n\n\t \n\tiowrite32(priv->maht0, priv->base + FTGMAC100_OFFSET_MAHT0);\n\tiowrite32(priv->maht1, priv->base + FTGMAC100_OFFSET_MAHT1);\n\n\t \n\tftgmac100_start_hw(priv);\n}\n\nstatic int ftgmac100_alloc_rx_buf(struct ftgmac100 *priv, unsigned int entry,\n\t\t\t\t  struct ftgmac100_rxdes *rxdes, gfp_t gfp)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tint err = 0;\n\n\tskb = netdev_alloc_skb_ip_align(netdev, RX_BUF_SIZE);\n\tif (unlikely(!skb)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev, \"failed to allocate rx skb\\n\");\n\t\terr = -ENOMEM;\n\t\tmap = priv->rx_scratch_dma;\n\t} else {\n\t\tmap = dma_map_single(priv->dev, skb->data, RX_BUF_SIZE,\n\t\t\t\t     DMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(priv->dev, map))) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(netdev, \"failed to map rx page\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tmap = priv->rx_scratch_dma;\n\t\t\tskb = NULL;\n\t\t\terr = -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tpriv->rx_skbs[entry] = skb;\n\n\t \n\trxdes->rxdes3 = cpu_to_le32(map);\n\n\t \n\tdma_wmb();\n\n\t \n\tif (entry == (priv->rx_q_entries - 1))\n\t\trxdes->rxdes0 = cpu_to_le32(priv->rxdes0_edorr_mask);\n\telse\n\t\trxdes->rxdes0 = 0;\n\n\treturn err;\n}\n\nstatic unsigned int ftgmac100_next_rx_pointer(struct ftgmac100 *priv,\n\t\t\t\t\t      unsigned int pointer)\n{\n\treturn (pointer + 1) & (priv->rx_q_entries - 1);\n}\n\nstatic void ftgmac100_rx_packet_error(struct ftgmac100 *priv, u32 status)\n{\n\tstruct net_device *netdev = priv->netdev;\n\n\tif (status & FTGMAC100_RXDES0_RX_ERR)\n\t\tnetdev->stats.rx_errors++;\n\n\tif (status & FTGMAC100_RXDES0_CRC_ERR)\n\t\tnetdev->stats.rx_crc_errors++;\n\n\tif (status & (FTGMAC100_RXDES0_FTL |\n\t\t      FTGMAC100_RXDES0_RUNT |\n\t\t      FTGMAC100_RXDES0_RX_ODD_NB))\n\t\tnetdev->stats.rx_length_errors++;\n}\n\nstatic bool ftgmac100_rx_packet(struct ftgmac100 *priv, int *processed)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct ftgmac100_rxdes *rxdes;\n\tstruct sk_buff *skb;\n\tunsigned int pointer, size;\n\tu32 status, csum_vlan;\n\tdma_addr_t map;\n\n\t \n\tpointer = priv->rx_pointer;\n\trxdes = &priv->rxdes[pointer];\n\n\t \n\tstatus = le32_to_cpu(rxdes->rxdes0);\n\n\t \n\tif (!(status & FTGMAC100_RXDES0_RXPKT_RDY))\n\t\treturn false;\n\n\t \n\tdma_rmb();\n\n\t \n\tif (unlikely(!(status & FTGMAC100_RXDES0_FRS) ||\n\t\t     !(status & FTGMAC100_RXDES0_LRS)))\n\t\tgoto drop;\n\n\t \n\tsize = status & FTGMAC100_RXDES0_VDBC;\n\tcsum_vlan = le32_to_cpu(rxdes->rxdes1);\n\n\t \n\tif (unlikely(status & RXDES0_ANY_ERROR)) {\n\t\t \n\t\tif ((status & FTGMAC100_RXDES0_RUNT) &&\n\t\t    (csum_vlan & FTGMAC100_RXDES1_VLANTAG_AVAIL) &&\n\t\t    (size >= 60))\n\t\t\tstatus &= ~FTGMAC100_RXDES0_RUNT;\n\n\t\t \n\t\tif (status & RXDES0_ANY_ERROR) {\n\t\t\tftgmac100_rx_packet_error(priv, status);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t \n\tskb = priv->rx_skbs[pointer];\n\tif (!unlikely(skb)) {\n\t\tftgmac100_alloc_rx_buf(priv, pointer, rxdes, GFP_ATOMIC);\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(status & FTGMAC100_RXDES0_MULTICAST))\n\t\tnetdev->stats.multicast++;\n\n\t \n\tif (netdev->features & NETIF_F_RXCSUM) {\n\t\tu32 err_bits = FTGMAC100_RXDES1_TCP_CHKSUM_ERR |\n\t\t\tFTGMAC100_RXDES1_UDP_CHKSUM_ERR |\n\t\t\tFTGMAC100_RXDES1_IP_CHKSUM_ERR;\n\t\tif ((csum_vlan & err_bits) ||\n\t\t    !(csum_vlan & FTGMAC100_RXDES1_PROT_MASK))\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\telse\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\t \n\tskb_put(skb, size);\n\n\t \n\tif ((netdev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    (csum_vlan & FTGMAC100_RXDES1_VLANTAG_AVAIL))\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t       csum_vlan & 0xffff);\n\n\t \n\tmap = le32_to_cpu(rxdes->rxdes3);\n\n#if defined(CONFIG_ARM) && !defined(CONFIG_ARM_DMA_USE_IOMMU)\n\t \n\tdma_unmap_single(priv->dev, map, size, DMA_FROM_DEVICE);\n#else\n\tdma_unmap_single(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\n#endif\n\n\n\t \n\tftgmac100_alloc_rx_buf(priv, pointer, rxdes, GFP_ATOMIC);\n\tpriv->rx_pointer = ftgmac100_next_rx_pointer(priv, pointer);\n\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += size;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_NONE)\n\t\tnetif_receive_skb(skb);\n\telse\n\t\tnapi_gro_receive(&priv->napi, skb);\n\n\t(*processed)++;\n\treturn true;\n\n drop:\n\t \n\trxdes->rxdes0 = cpu_to_le32(status & priv->rxdes0_edorr_mask);\n\tpriv->rx_pointer = ftgmac100_next_rx_pointer(priv, pointer);\n\tnetdev->stats.rx_dropped++;\n\treturn true;\n}\n\nstatic u32 ftgmac100_base_tx_ctlstat(struct ftgmac100 *priv,\n\t\t\t\t     unsigned int index)\n{\n\tif (index == (priv->tx_q_entries - 1))\n\t\treturn priv->txdes0_edotr_mask;\n\telse\n\t\treturn 0;\n}\n\nstatic unsigned int ftgmac100_next_tx_pointer(struct ftgmac100 *priv,\n\t\t\t\t\t      unsigned int pointer)\n{\n\treturn (pointer + 1) & (priv->tx_q_entries - 1);\n}\n\nstatic u32 ftgmac100_tx_buf_avail(struct ftgmac100 *priv)\n{\n\t \n\treturn (priv->tx_clean_pointer - priv->tx_pointer - 1) &\n\t\t(priv->tx_q_entries - 1);\n}\n\nstatic bool ftgmac100_tx_buf_cleanable(struct ftgmac100 *priv)\n{\n\treturn priv->tx_pointer != priv->tx_clean_pointer;\n}\n\nstatic void ftgmac100_free_tx_packet(struct ftgmac100 *priv,\n\t\t\t\t     unsigned int pointer,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     struct ftgmac100_txdes *txdes,\n\t\t\t\t     u32 ctl_stat)\n{\n\tdma_addr_t map = le32_to_cpu(txdes->txdes3);\n\tsize_t len;\n\n\tif (ctl_stat & FTGMAC100_TXDES0_FTS) {\n\t\tlen = skb_headlen(skb);\n\t\tdma_unmap_single(priv->dev, map, len, DMA_TO_DEVICE);\n\t} else {\n\t\tlen = FTGMAC100_TXDES0_TXBUF_SIZE(ctl_stat);\n\t\tdma_unmap_page(priv->dev, map, len, DMA_TO_DEVICE);\n\t}\n\n\t \n\tif (ctl_stat & FTGMAC100_TXDES0_LTS)\n\t\tdev_kfree_skb(skb);\n\tpriv->tx_skbs[pointer] = NULL;\n}\n\nstatic bool ftgmac100_tx_complete_packet(struct ftgmac100 *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct ftgmac100_txdes *txdes;\n\tstruct sk_buff *skb;\n\tunsigned int pointer;\n\tu32 ctl_stat;\n\n\tpointer = priv->tx_clean_pointer;\n\ttxdes = &priv->txdes[pointer];\n\n\tctl_stat = le32_to_cpu(txdes->txdes0);\n\tif (ctl_stat & FTGMAC100_TXDES0_TXDMA_OWN)\n\t\treturn false;\n\n\tskb = priv->tx_skbs[pointer];\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += skb->len;\n\tftgmac100_free_tx_packet(priv, pointer, skb, txdes, ctl_stat);\n\ttxdes->txdes0 = cpu_to_le32(ctl_stat & priv->txdes0_edotr_mask);\n\n\tpriv->tx_clean_pointer = ftgmac100_next_tx_pointer(priv, pointer);\n\n\treturn true;\n}\n\nstatic void ftgmac100_tx_complete(struct ftgmac100 *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\n\t \n\twhile (ftgmac100_tx_buf_cleanable(priv) &&\n\t       ftgmac100_tx_complete_packet(priv))\n\t\t;\n\n\t \n\tsmp_mb();\n\tif (unlikely(netif_queue_stopped(netdev) &&\n\t\t     ftgmac100_tx_buf_avail(priv) >= TX_THRESHOLD)) {\n\t\tstruct netdev_queue *txq;\n\n\t\ttxq = netdev_get_tx_queue(netdev, 0);\n\t\t__netif_tx_lock(txq, smp_processor_id());\n\t\tif (netif_queue_stopped(netdev) &&\n\t\t    ftgmac100_tx_buf_avail(priv) >= TX_THRESHOLD)\n\t\t\tnetif_wake_queue(netdev);\n\t\t__netif_tx_unlock(txq);\n\t}\n}\n\nstatic bool ftgmac100_prep_tx_csum(struct sk_buff *skb, u32 *csum_vlan)\n{\n\tif (skb->protocol == cpu_to_be16(ETH_P_IP)) {\n\t\tu8 ip_proto = ip_hdr(skb)->protocol;\n\n\t\t*csum_vlan |= FTGMAC100_TXDES1_IP_CHKSUM;\n\t\tswitch(ip_proto) {\n\t\tcase IPPROTO_TCP:\n\t\t\t*csum_vlan |= FTGMAC100_TXDES1_TCP_CHKSUM;\n\t\t\treturn true;\n\t\tcase IPPROTO_UDP:\n\t\t\t*csum_vlan |= FTGMAC100_TXDES1_UDP_CHKSUM;\n\t\t\treturn true;\n\t\tcase IPPROTO_IP:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn skb_checksum_help(skb) == 0;\n}\n\nstatic netdev_tx_t ftgmac100_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tstruct ftgmac100_txdes *txdes, *first;\n\tunsigned int pointer, nfrags, len, i, j;\n\tu32 f_ctl_stat, ctl_stat, csum_vlan;\n\tdma_addr_t map;\n\n\t \n\tif (eth_skb_pad(skb)) {\n\t\tnetdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tif (unlikely(skb->len > MAX_PKT_SIZE)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"tx packet too big\\n\");\n\t\tgoto drop;\n\t}\n\n\t \n\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t \n\tcsum_vlan = 0;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    !ftgmac100_prep_tx_csum(skb, &csum_vlan))\n\t\tgoto drop;\n\n\t \n\tif (skb_vlan_tag_present(skb)) {\n\t\tcsum_vlan |= FTGMAC100_TXDES1_INS_VLANTAG;\n\t\tcsum_vlan |= skb_vlan_tag_get(skb) & 0xffff;\n\t}\n\n\t \n\tlen = skb_headlen(skb);\n\n\t \n\tmap = dma_map_single(priv->dev, skb->data, len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(priv->dev, map)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"map tx packet head failed\\n\");\n\t\tgoto drop;\n\t}\n\n\t \n\tpointer = priv->tx_pointer;\n\ttxdes = first = &priv->txdes[pointer];\n\n\t \n\tpriv->tx_skbs[pointer] = skb;\n\tf_ctl_stat = ftgmac100_base_tx_ctlstat(priv, pointer);\n\tf_ctl_stat |= FTGMAC100_TXDES0_TXDMA_OWN;\n\tf_ctl_stat |= FTGMAC100_TXDES0_TXBUF_SIZE(len);\n\tf_ctl_stat |= FTGMAC100_TXDES0_FTS;\n\tif (nfrags == 0)\n\t\tf_ctl_stat |= FTGMAC100_TXDES0_LTS;\n\ttxdes->txdes3 = cpu_to_le32(map);\n\ttxdes->txdes1 = cpu_to_le32(csum_vlan);\n\n\t \n\tpointer = ftgmac100_next_tx_pointer(priv, pointer);\n\n\t \n\tfor (i = 0; i < nfrags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tlen = skb_frag_size(frag);\n\n\t\t \n\t\tmap = skb_frag_dma_map(priv->dev, frag, 0, len,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(priv->dev, map))\n\t\t\tgoto dma_err;\n\n\t\t \n\t\tpriv->tx_skbs[pointer] = skb;\n\t\ttxdes = &priv->txdes[pointer];\n\t\tctl_stat = ftgmac100_base_tx_ctlstat(priv, pointer);\n\t\tctl_stat |= FTGMAC100_TXDES0_TXDMA_OWN;\n\t\tctl_stat |= FTGMAC100_TXDES0_TXBUF_SIZE(len);\n\t\tif (i == (nfrags - 1))\n\t\t\tctl_stat |= FTGMAC100_TXDES0_LTS;\n\t\ttxdes->txdes0 = cpu_to_le32(ctl_stat);\n\t\ttxdes->txdes1 = 0;\n\t\ttxdes->txdes3 = cpu_to_le32(map);\n\n\t\t \n\t\tpointer = ftgmac100_next_tx_pointer(priv, pointer);\n\t}\n\n\t \n\tdma_wmb();\n\tfirst->txdes0 = cpu_to_le32(f_ctl_stat);\n\n\t \n\tpriv->tx_pointer = pointer;\n\n\t \n\tif (unlikely(ftgmac100_tx_buf_avail(priv) < TX_THRESHOLD)) {\n\t\tnetif_stop_queue(netdev);\n\t\t \n\t\tsmp_mb();\n\t\tif (ftgmac100_tx_buf_avail(priv) >= TX_THRESHOLD)\n\t\t\tnetif_wake_queue(netdev);\n\t}\n\n\t \n\tiowrite32(1, priv->base + FTGMAC100_OFFSET_NPTXPD);\n\n\treturn NETDEV_TX_OK;\n\n dma_err:\n\tif (net_ratelimit())\n\t\tnetdev_err(netdev, \"map tx fragment failed\\n\");\n\n\t \n\tpointer = priv->tx_pointer;\n\tftgmac100_free_tx_packet(priv, pointer, skb, first, f_ctl_stat);\n\tfirst->txdes0 = cpu_to_le32(f_ctl_stat & priv->txdes0_edotr_mask);\n\n\t \n\tfor (j = 0; j < i; j++) {\n\t\tpointer = ftgmac100_next_tx_pointer(priv, pointer);\n\t\ttxdes = &priv->txdes[pointer];\n\t\tctl_stat = le32_to_cpu(txdes->txdes0);\n\t\tftgmac100_free_tx_packet(priv, pointer, skb, txdes, ctl_stat);\n\t\ttxdes->txdes0 = cpu_to_le32(ctl_stat & priv->txdes0_edotr_mask);\n\t}\n\n\t \n drop:\n\t \n\tdev_kfree_skb_any(skb);\n\tnetdev->stats.tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ftgmac100_free_buffers(struct ftgmac100 *priv)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < priv->rx_q_entries; i++) {\n\t\tstruct ftgmac100_rxdes *rxdes = &priv->rxdes[i];\n\t\tstruct sk_buff *skb = priv->rx_skbs[i];\n\t\tdma_addr_t map = le32_to_cpu(rxdes->rxdes3);\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tpriv->rx_skbs[i] = NULL;\n\t\tdma_unmap_single(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\t \n\tfor (i = 0; i < priv->tx_q_entries; i++) {\n\t\tstruct ftgmac100_txdes *txdes = &priv->txdes[i];\n\t\tstruct sk_buff *skb = priv->tx_skbs[i];\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\t\tftgmac100_free_tx_packet(priv, i, skb, txdes,\n\t\t\t\t\t le32_to_cpu(txdes->txdes0));\n\t}\n}\n\nstatic void ftgmac100_free_rings(struct ftgmac100 *priv)\n{\n\t \n\tkfree(priv->rx_skbs);\n\tkfree(priv->tx_skbs);\n\n\t \n\tif (priv->rxdes)\n\t\tdma_free_coherent(priv->dev, MAX_RX_QUEUE_ENTRIES *\n\t\t\t\t  sizeof(struct ftgmac100_rxdes),\n\t\t\t\t  priv->rxdes, priv->rxdes_dma);\n\tpriv->rxdes = NULL;\n\n\tif (priv->txdes)\n\t\tdma_free_coherent(priv->dev, MAX_TX_QUEUE_ENTRIES *\n\t\t\t\t  sizeof(struct ftgmac100_txdes),\n\t\t\t\t  priv->txdes, priv->txdes_dma);\n\tpriv->txdes = NULL;\n\n\t \n\tif (priv->rx_scratch)\n\t\tdma_free_coherent(priv->dev, RX_BUF_SIZE,\n\t\t\t\t  priv->rx_scratch, priv->rx_scratch_dma);\n}\n\nstatic int ftgmac100_alloc_rings(struct ftgmac100 *priv)\n{\n\t \n\tpriv->rx_skbs = kcalloc(MAX_RX_QUEUE_ENTRIES, sizeof(void *),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->rx_skbs)\n\t\treturn -ENOMEM;\n\tpriv->tx_skbs = kcalloc(MAX_TX_QUEUE_ENTRIES, sizeof(void *),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->tx_skbs)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->rxdes = dma_alloc_coherent(priv->dev,\n\t\t\t\t\t MAX_RX_QUEUE_ENTRIES * sizeof(struct ftgmac100_rxdes),\n\t\t\t\t\t &priv->rxdes_dma, GFP_KERNEL);\n\tif (!priv->rxdes)\n\t\treturn -ENOMEM;\n\tpriv->txdes = dma_alloc_coherent(priv->dev,\n\t\t\t\t\t MAX_TX_QUEUE_ENTRIES * sizeof(struct ftgmac100_txdes),\n\t\t\t\t\t &priv->txdes_dma, GFP_KERNEL);\n\tif (!priv->txdes)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->rx_scratch = dma_alloc_coherent(priv->dev,\n\t\t\t\t\t      RX_BUF_SIZE,\n\t\t\t\t\t      &priv->rx_scratch_dma,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!priv->rx_scratch)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void ftgmac100_init_rings(struct ftgmac100 *priv)\n{\n\tstruct ftgmac100_rxdes *rxdes = NULL;\n\tstruct ftgmac100_txdes *txdes = NULL;\n\tint i;\n\n\t \n\tpriv->rx_q_entries = priv->new_rx_q_entries;\n\tpriv->tx_q_entries = priv->new_tx_q_entries;\n\n\tif (WARN_ON(priv->rx_q_entries < MIN_RX_QUEUE_ENTRIES))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < priv->rx_q_entries; i++) {\n\t\trxdes = &priv->rxdes[i];\n\t\trxdes->rxdes0 = 0;\n\t\trxdes->rxdes3 = cpu_to_le32(priv->rx_scratch_dma);\n\t}\n\t \n\trxdes->rxdes0 |= cpu_to_le32(priv->rxdes0_edorr_mask);\n\n\tif (WARN_ON(priv->tx_q_entries < MIN_RX_QUEUE_ENTRIES))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < priv->tx_q_entries; i++) {\n\t\ttxdes = &priv->txdes[i];\n\t\ttxdes->txdes0 = 0;\n\t}\n\ttxdes->txdes0 |= cpu_to_le32(priv->txdes0_edotr_mask);\n}\n\nstatic int ftgmac100_alloc_rx_buffers(struct ftgmac100 *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->rx_q_entries; i++) {\n\t\tstruct ftgmac100_rxdes *rxdes = &priv->rxdes[i];\n\n\t\tif (ftgmac100_alloc_rx_buf(priv, i, rxdes, GFP_KERNEL))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int ftgmac100_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)\n{\n\tstruct net_device *netdev = bus->priv;\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tunsigned int phycr;\n\tint i;\n\n\tphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\n\n\t \n\tphycr &= FTGMAC100_PHYCR_MDC_CYCTHR_MASK;\n\n\tphycr |= FTGMAC100_PHYCR_PHYAD(phy_addr) |\n\t\t FTGMAC100_PHYCR_REGAD(regnum) |\n\t\t FTGMAC100_PHYCR_MIIRD;\n\n\tiowrite32(phycr, priv->base + FTGMAC100_OFFSET_PHYCR);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\n\n\t\tif ((phycr & FTGMAC100_PHYCR_MIIRD) == 0) {\n\t\t\tint data;\n\n\t\t\tdata = ioread32(priv->base + FTGMAC100_OFFSET_PHYDATA);\n\t\t\treturn FTGMAC100_PHYDATA_MIIRDATA(data);\n\t\t}\n\n\t\tudelay(100);\n\t}\n\n\tnetdev_err(netdev, \"mdio read timed out\\n\");\n\treturn -EIO;\n}\n\nstatic int ftgmac100_mdiobus_write(struct mii_bus *bus, int phy_addr,\n\t\t\t\t   int regnum, u16 value)\n{\n\tstruct net_device *netdev = bus->priv;\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tunsigned int phycr;\n\tint data;\n\tint i;\n\n\tphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\n\n\t \n\tphycr &= FTGMAC100_PHYCR_MDC_CYCTHR_MASK;\n\n\tphycr |= FTGMAC100_PHYCR_PHYAD(phy_addr) |\n\t\t FTGMAC100_PHYCR_REGAD(regnum) |\n\t\t FTGMAC100_PHYCR_MIIWR;\n\n\tdata = FTGMAC100_PHYDATA_MIIWDATA(value);\n\n\tiowrite32(data, priv->base + FTGMAC100_OFFSET_PHYDATA);\n\tiowrite32(phycr, priv->base + FTGMAC100_OFFSET_PHYCR);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\n\n\t\tif ((phycr & FTGMAC100_PHYCR_MIIWR) == 0)\n\t\t\treturn 0;\n\n\t\tudelay(100);\n\t}\n\n\tnetdev_err(netdev, \"mdio write timed out\\n\");\n\treturn -EIO;\n}\n\nstatic void ftgmac100_get_drvinfo(struct net_device *netdev,\n\t\t\t\t  struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, dev_name(&netdev->dev), sizeof(info->bus_info));\n}\n\nstatic void\nftgmac100_get_ringparam(struct net_device *netdev,\n\t\t\tstruct ethtool_ringparam *ering,\n\t\t\tstruct kernel_ethtool_ringparam *kernel_ering,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\tmemset(ering, 0, sizeof(*ering));\n\tering->rx_max_pending = MAX_RX_QUEUE_ENTRIES;\n\tering->tx_max_pending = MAX_TX_QUEUE_ENTRIES;\n\tering->rx_pending = priv->rx_q_entries;\n\tering->tx_pending = priv->tx_q_entries;\n}\n\nstatic int\nftgmac100_set_ringparam(struct net_device *netdev,\n\t\t\tstruct ethtool_ringparam *ering,\n\t\t\tstruct kernel_ethtool_ringparam *kernel_ering,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\tif (ering->rx_pending > MAX_RX_QUEUE_ENTRIES ||\n\t    ering->tx_pending > MAX_TX_QUEUE_ENTRIES ||\n\t    ering->rx_pending < MIN_RX_QUEUE_ENTRIES ||\n\t    ering->tx_pending < MIN_TX_QUEUE_ENTRIES ||\n\t    !is_power_of_2(ering->rx_pending) ||\n\t    !is_power_of_2(ering->tx_pending))\n\t\treturn -EINVAL;\n\n\tpriv->new_rx_q_entries = ering->rx_pending;\n\tpriv->new_tx_q_entries = ering->tx_pending;\n\tif (netif_running(netdev))\n\t\tschedule_work(&priv->reset_task);\n\n\treturn 0;\n}\n\nstatic void ftgmac100_get_pauseparam(struct net_device *netdev,\n\t\t\t\t     struct ethtool_pauseparam *pause)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\tpause->autoneg = priv->aneg_pause;\n\tpause->tx_pause = priv->tx_pause;\n\tpause->rx_pause = priv->rx_pause;\n}\n\nstatic int ftgmac100_set_pauseparam(struct net_device *netdev,\n\t\t\t\t    struct ethtool_pauseparam *pause)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tstruct phy_device *phydev = netdev->phydev;\n\n\tpriv->aneg_pause = pause->autoneg;\n\tpriv->tx_pause = pause->tx_pause;\n\tpriv->rx_pause = pause->rx_pause;\n\n\tif (phydev)\n\t\tphy_set_asym_pause(phydev, pause->rx_pause, pause->tx_pause);\n\n\tif (netif_running(netdev)) {\n\t\tif (!(phydev && priv->aneg_pause))\n\t\t\tftgmac100_config_pause(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ftgmac100_ethtool_ops = {\n\t.get_drvinfo\t\t= ftgmac100_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.nway_reset\t\t= phy_ethtool_nway_reset,\n\t.get_ringparam\t\t= ftgmac100_get_ringparam,\n\t.set_ringparam\t\t= ftgmac100_set_ringparam,\n\t.get_pauseparam\t\t= ftgmac100_get_pauseparam,\n\t.set_pauseparam\t\t= ftgmac100_set_pauseparam,\n};\n\nstatic irqreturn_t ftgmac100_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *netdev = dev_id;\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tunsigned int status, new_mask = FTGMAC100_INT_BAD;\n\n\t \n\tstatus = ioread32(priv->base + FTGMAC100_OFFSET_ISR);\n\tiowrite32(status, priv->base + FTGMAC100_OFFSET_ISR);\n\tif (unlikely(status & FTGMAC100_INT_BAD)) {\n\n\t\t \n\t\tif (status & FTGMAC100_INT_NO_RXBUF)\n\t\t\tnetdev->stats.rx_over_errors++;\n\n\t\t \n\t\tif (status & FTGMAC100_INT_RPKT_LOST)\n\t\t\tnetdev->stats.rx_fifo_errors++;\n\n\t\t \n\t\tif (status & FTGMAC100_INT_XPKT_LOST)\n\t\t\tnetdev->stats.tx_fifo_errors++;\n\n\t\t \n\t\tif (status & FTGMAC100_INT_AHB_ERR) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t   \"AHB bus error ! Resetting chip.\\n\");\n\t\t\tiowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\n\t\t\tschedule_work(&priv->reset_task);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\t \n\t\tpriv->need_mac_restart = true;\n\n\t\t \n\t\tnew_mask &= ~status;\n\t}\n\n\t \n\tiowrite32(new_mask, priv->base + FTGMAC100_OFFSET_IER);\n\n\t \n\tnapi_schedule_irqoff(&priv->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool ftgmac100_check_rx(struct ftgmac100 *priv)\n{\n\tstruct ftgmac100_rxdes *rxdes = &priv->rxdes[priv->rx_pointer];\n\n\t \n\treturn !!(rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RXPKT_RDY));\n}\n\nstatic int ftgmac100_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ftgmac100 *priv = container_of(napi, struct ftgmac100, napi);\n\tint work_done = 0;\n\tbool more;\n\n\t \n\tif (ftgmac100_tx_buf_cleanable(priv))\n\t\tftgmac100_tx_complete(priv);\n\n\t \n\tdo {\n\t\tmore = ftgmac100_rx_packet(priv, &work_done);\n\t} while (more && work_done < budget);\n\n\n\t \n\tif (unlikely(priv->need_mac_restart)) {\n\t\tftgmac100_start_hw(priv);\n\t\tpriv->need_mac_restart = false;\n\n\t\t \n\t\tiowrite32(FTGMAC100_INT_BAD,\n\t\t\t  priv->base + FTGMAC100_OFFSET_IER);\n\t}\n\n\t \n\tif (ftgmac100_tx_buf_cleanable(priv))\n\t\twork_done = budget;\n\n\tif (work_done < budget) {\n\t\t \n\t\tiowrite32(FTGMAC100_INT_RXTX,\n\t\t\t  priv->base + FTGMAC100_OFFSET_ISR);\n\n\t\t \n\t\tioread32(priv->base + FTGMAC100_OFFSET_ISR);\n\n\t\t \n\t\tif (ftgmac100_check_rx(priv) ||\n\t\t    ftgmac100_tx_buf_cleanable(priv))\n\t\t\treturn budget;\n\n\t\t \n\t\tnapi_complete(napi);\n\n\t\t \n\t\tiowrite32(FTGMAC100_INT_ALL,\n\t\t\t  priv->base + FTGMAC100_OFFSET_IER);\n\t}\n\n\treturn work_done;\n}\n\nstatic int ftgmac100_init_all(struct ftgmac100 *priv, bool ignore_alloc_err)\n{\n\tint err = 0;\n\n\t \n\tftgmac100_init_rings(priv);\n\n\t \n\terr = ftgmac100_alloc_rx_buffers(priv);\n\tif (err && !ignore_alloc_err)\n\t\treturn err;\n\n\t \n\tftgmac100_init_hw(priv);\n\tftgmac100_config_pause(priv);\n\tftgmac100_start_hw(priv);\n\n\t \n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(priv->netdev);\n\n\t \n\tiowrite32(FTGMAC100_INT_ALL, priv->base + FTGMAC100_OFFSET_IER);\n\n\treturn err;\n}\n\nstatic void ftgmac100_reset(struct ftgmac100 *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint err;\n\n\tnetdev_dbg(netdev, \"Resetting NIC...\\n\");\n\n\t \n\trtnl_lock();\n\tif (netdev->phydev)\n\t\tmutex_lock(&netdev->phydev->lock);\n\tif (priv->mii_bus)\n\t\tmutex_lock(&priv->mii_bus->mdio_lock);\n\n\n\t \n\tif (!netif_running(netdev))\n\t\tgoto bail;\n\n\t \n\tnetif_trans_update(netdev);\n\tnapi_disable(&priv->napi);\n\tnetif_tx_disable(netdev);\n\n\t \n\tftgmac100_stop_hw(priv);\n\terr = ftgmac100_reset_and_config_mac(priv);\n\tif (err) {\n\t\t \n\t\tnetdev_err(netdev, \"attempting to continue...\\n\");\n\t}\n\n\t \n\tftgmac100_free_buffers(priv);\n\n\t \n\tftgmac100_init_all(priv, true);\n\n\tnetdev_dbg(netdev, \"Reset done !\\n\");\n bail:\n\tif (priv->mii_bus)\n\t\tmutex_unlock(&priv->mii_bus->mdio_lock);\n\tif (netdev->phydev)\n\t\tmutex_unlock(&netdev->phydev->lock);\n\trtnl_unlock();\n}\n\nstatic void ftgmac100_reset_task(struct work_struct *work)\n{\n\tstruct ftgmac100 *priv = container_of(work, struct ftgmac100,\n\t\t\t\t\t      reset_task);\n\n\tftgmac100_reset(priv);\n}\n\nstatic void ftgmac100_adjust_link(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tstruct phy_device *phydev = netdev->phydev;\n\tbool tx_pause, rx_pause;\n\tint new_speed;\n\n\t \n\tif (!phydev->link)\n\t\tnew_speed = 0;\n\telse\n\t\tnew_speed = phydev->speed;\n\n\t \n\tif (priv->aneg_pause) {\n\t\trx_pause = tx_pause = phydev->pause;\n\t\tif (phydev->asym_pause)\n\t\t\ttx_pause = !rx_pause;\n\t} else {\n\t\trx_pause = priv->rx_pause;\n\t\ttx_pause = priv->tx_pause;\n\t}\n\n\t \n\tif (phydev->speed == priv->cur_speed &&\n\t    phydev->duplex == priv->cur_duplex &&\n\t    rx_pause == priv->rx_pause &&\n\t    tx_pause == priv->tx_pause)\n\t\treturn;\n\n\t \n\tif (new_speed || priv->cur_speed)\n\t\tphy_print_status(phydev);\n\n\tpriv->cur_speed = new_speed;\n\tpriv->cur_duplex = phydev->duplex;\n\tpriv->rx_pause = rx_pause;\n\tpriv->tx_pause = tx_pause;\n\n\t \n\tif (!new_speed)\n\t\treturn;\n\n\t \n\tiowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\n\n\t \n\tif (netdev->phydev)\n\t\tmutex_unlock(&netdev->phydev->lock);\n\n\tftgmac100_reset(priv);\n\n\tif (netdev->phydev)\n\t\tmutex_lock(&netdev->phydev->lock);\n\n}\n\nstatic int ftgmac100_mii_probe(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tstruct platform_device *pdev = to_platform_device(priv->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct phy_device *phydev;\n\tphy_interface_t phy_intf;\n\tint err;\n\n\t \n\terr = of_get_phy_mode(np, &phy_intf);\n\tif (err)\n\t\tphy_intf = PHY_INTERFACE_MODE_RGMII;\n\n\t \n\tif (priv->is_aspeed && !(phy_interface_mode_is_rgmii(phy_intf))) {\n\t\tnetdev_warn(netdev,\n\t\t\t    \"Unsupported PHY mode %s !\\n\",\n\t\t\t    phy_modes(phy_intf));\n\t}\n\n\tphydev = phy_find_first(priv->mii_bus);\n\tif (!phydev) {\n\t\tnetdev_info(netdev, \"%s: no PHY found\\n\", netdev->name);\n\t\treturn -ENODEV;\n\t}\n\n\tphydev = phy_connect(netdev, phydev_name(phydev),\n\t\t\t     &ftgmac100_adjust_link, phy_intf);\n\n\tif (IS_ERR(phydev)) {\n\t\tnetdev_err(netdev, \"%s: Could not attach to PHY\\n\", netdev->name);\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\t \n\tphy_support_asym_pause(phydev);\n\n\t \n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\nstatic int ftgmac100_open(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tint err;\n\n\t \n\terr = ftgmac100_alloc_rings(priv);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Failed to allocate descriptors\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (priv->use_ncsi) {\n\t\tpriv->cur_duplex = DUPLEX_FULL;\n\t\tpriv->cur_speed = SPEED_100;\n\t} else {\n\t\tpriv->cur_duplex = 0;\n\t\tpriv->cur_speed = 0;\n\t}\n\n\t \n\terr = ftgmac100_reset_and_config_mac(priv);\n\tif (err)\n\t\tgoto err_hw;\n\n\t \n\tnetif_napi_add(netdev, &priv->napi, ftgmac100_poll);\n\n\t \n\terr = request_irq(netdev->irq, ftgmac100_interrupt, 0, netdev->name, netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"failed to request irq %d\\n\", netdev->irq);\n\t\tgoto err_irq;\n\t}\n\n\t \n\terr = ftgmac100_init_all(priv, false);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Failed to allocate packet buffers\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\tif (netdev->phydev) {\n\t\t \n\t\tphy_start(netdev->phydev);\n\t} else if (priv->use_ncsi) {\n\t\t \n\t\tnetif_carrier_on(netdev);\n\n\t\t \n\t\terr = ncsi_start_dev(priv->ndev);\n\t\tif (err)\n\t\t\tgoto err_ncsi;\n\t}\n\n\treturn 0;\n\n err_ncsi:\n\tnapi_disable(&priv->napi);\n\tnetif_stop_queue(netdev);\n err_alloc:\n\tftgmac100_free_buffers(priv);\n\tfree_irq(netdev->irq, netdev);\n err_irq:\n\tnetif_napi_del(&priv->napi);\n err_hw:\n\tiowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\n\tftgmac100_free_rings(priv);\n\treturn err;\n}\n\nstatic int ftgmac100_stop(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\t \n\n\t \n\tiowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\n\n\tnetif_stop_queue(netdev);\n\tnapi_disable(&priv->napi);\n\tnetif_napi_del(&priv->napi);\n\tif (netdev->phydev)\n\t\tphy_stop(netdev->phydev);\n\telse if (priv->use_ncsi)\n\t\tncsi_stop_dev(priv->ndev);\n\n\tftgmac100_stop_hw(priv);\n\tfree_irq(netdev->irq, netdev);\n\tftgmac100_free_buffers(priv);\n\tftgmac100_free_rings(priv);\n\n\treturn 0;\n}\n\nstatic void ftgmac100_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\t \n\tiowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\n\n\t \n\tschedule_work(&priv->reset_task);\n}\n\nstatic int ftgmac100_set_features(struct net_device *netdev,\n\t\t\t\t  netdev_features_t features)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tnetdev_features_t changed = netdev->features ^ features;\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\t \n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\tu32 maccr;\n\n\t\tmaccr = ioread32(priv->base + FTGMAC100_OFFSET_MACCR);\n\t\tif (priv->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\tmaccr |= FTGMAC100_MACCR_RM_VLAN;\n\t\telse\n\t\t\tmaccr &= ~FTGMAC100_MACCR_RM_VLAN;\n\t\tiowrite32(maccr, priv->base + FTGMAC100_OFFSET_MACCR);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void ftgmac100_poll_controller(struct net_device *netdev)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tftgmac100_interrupt(netdev->irq, netdev);\n\tlocal_irq_restore(flags);\n}\n#endif\n\nstatic const struct net_device_ops ftgmac100_netdev_ops = {\n\t.ndo_open\t\t= ftgmac100_open,\n\t.ndo_stop\t\t= ftgmac100_stop,\n\t.ndo_start_xmit\t\t= ftgmac100_hard_start_xmit,\n\t.ndo_set_mac_address\t= ftgmac100_set_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl,\n\t.ndo_tx_timeout\t\t= ftgmac100_tx_timeout,\n\t.ndo_set_rx_mode\t= ftgmac100_set_rx_mode,\n\t.ndo_set_features\t= ftgmac100_set_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= ftgmac100_poll_controller,\n#endif\n\t.ndo_vlan_rx_add_vid\t= ncsi_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= ncsi_vlan_rx_kill_vid,\n};\n\nstatic int ftgmac100_setup_mdio(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\tstruct platform_device *pdev = to_platform_device(priv->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *mdio_np;\n\tint i, err = 0;\n\tu32 reg;\n\n\t \n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -EIO;\n\n\tif (of_device_is_compatible(np, \"aspeed,ast2400-mac\") ||\n\t    of_device_is_compatible(np, \"aspeed,ast2500-mac\")) {\n\t\t \n\n\t\t \n\t\treg = ioread32(priv->base + FTGMAC100_OFFSET_REVR);\n\t\treg &= ~FTGMAC100_REVR_NEW_MDIO_INTERFACE;\n\t\tiowrite32(reg, priv->base + FTGMAC100_OFFSET_REVR);\n\t}\n\n\tpriv->mii_bus->name = \"ftgmac100_mdio\";\n\tsnprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%d\",\n\t\t pdev->name, pdev->id);\n\tpriv->mii_bus->parent = priv->dev;\n\tpriv->mii_bus->priv = priv->netdev;\n\tpriv->mii_bus->read = ftgmac100_mdiobus_read;\n\tpriv->mii_bus->write = ftgmac100_mdiobus_write;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++)\n\t\tpriv->mii_bus->irq[i] = PHY_POLL;\n\n\tmdio_np = of_get_child_by_name(np, \"mdio\");\n\n\terr = of_mdiobus_register(priv->mii_bus, mdio_np);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Cannot register MDIO bus!\\n\");\n\t\tgoto err_register_mdiobus;\n\t}\n\n\tof_node_put(mdio_np);\n\n\treturn 0;\n\nerr_register_mdiobus:\n\tmdiobus_free(priv->mii_bus);\n\treturn err;\n}\n\nstatic void ftgmac100_phy_disconnect(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\tif (!netdev->phydev)\n\t\treturn;\n\n\tphy_disconnect(netdev->phydev);\n\tif (of_phy_is_fixed_link(priv->dev->of_node))\n\t\tof_phy_deregister_fixed_link(priv->dev->of_node);\n}\n\nstatic void ftgmac100_destroy_mdio(struct net_device *netdev)\n{\n\tstruct ftgmac100 *priv = netdev_priv(netdev);\n\n\tif (!priv->mii_bus)\n\t\treturn;\n\n\tmdiobus_unregister(priv->mii_bus);\n\tmdiobus_free(priv->mii_bus);\n}\n\nstatic void ftgmac100_ncsi_handler(struct ncsi_dev *nd)\n{\n\tif (unlikely(nd->state != ncsi_dev_state_functional))\n\t\treturn;\n\n\tnetdev_dbg(nd->dev, \"NCSI interface %s\\n\",\n\t\t   nd->link_up ? \"up\" : \"down\");\n}\n\nstatic int ftgmac100_setup_clk(struct ftgmac100 *priv)\n{\n\tstruct clk *clk;\n\tint rc;\n\n\tclk = devm_clk_get(priv->dev, NULL  );\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\tpriv->clk = clk;\n\trc = clk_prepare_enable(priv->clk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = clk_set_rate(priv->clk, priv->use_ncsi ? FTGMAC_25MHZ :\n\t\t\t  FTGMAC_100MHZ);\n\tif (rc)\n\t\tgoto cleanup_clk;\n\n\t \n\tpriv->rclk = devm_clk_get_optional(priv->dev, \"RCLK\");\n\trc = clk_prepare_enable(priv->rclk);\n\tif (!rc)\n\t\treturn 0;\n\ncleanup_clk:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn rc;\n}\n\nstatic bool ftgmac100_has_child_node(struct device_node *np, const char *name)\n{\n\tstruct device_node *child_np = of_get_child_by_name(np, name);\n\tbool ret = false;\n\n\tif (child_np) {\n\t\tret = true;\n\t\tof_node_put(child_np);\n\t}\n\n\treturn ret;\n}\n\nstatic int ftgmac100_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tint irq;\n\tstruct net_device *netdev;\n\tstruct ftgmac100 *priv;\n\tstruct device_node *np;\n\tint err = 0;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tnetdev = alloc_etherdev(sizeof(*priv));\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tnetdev->ethtool_ops = &ftgmac100_ethtool_ops;\n\tnetdev->netdev_ops = &ftgmac100_netdev_ops;\n\tnetdev->watchdog_timeo = 5 * HZ;\n\n\tplatform_set_drvdata(pdev, netdev);\n\n\t \n\tpriv = netdev_priv(netdev);\n\tpriv->netdev = netdev;\n\tpriv->dev = &pdev->dev;\n\tINIT_WORK(&priv->reset_task, ftgmac100_reset_task);\n\n\t \n\tpriv->res = request_mem_region(res->start, resource_size(res),\n\t\t\t\t       dev_name(&pdev->dev));\n\tif (!priv->res) {\n\t\tdev_err(&pdev->dev, \"Could not reserve memory region\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_req_mem;\n\t}\n\n\tpriv->base = ioremap(res->start, resource_size(res));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"Failed to ioremap ethernet registers\\n\");\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tnetdev->irq = irq;\n\n\t \n\tpriv->tx_pause = true;\n\tpriv->rx_pause = true;\n\tpriv->aneg_pause = true;\n\n\t \n\terr = ftgmac100_initial_mac(priv);\n\tif (err)\n\t\tgoto err_phy_connect;\n\n\tnp = pdev->dev.of_node;\n\tif (np && (of_device_is_compatible(np, \"aspeed,ast2400-mac\") ||\n\t\t   of_device_is_compatible(np, \"aspeed,ast2500-mac\") ||\n\t\t   of_device_is_compatible(np, \"aspeed,ast2600-mac\"))) {\n\t\tpriv->rxdes0_edorr_mask = BIT(30);\n\t\tpriv->txdes0_edotr_mask = BIT(30);\n\t\tpriv->is_aspeed = true;\n\t} else {\n\t\tpriv->rxdes0_edorr_mask = BIT(15);\n\t\tpriv->txdes0_edotr_mask = BIT(15);\n\t}\n\n\tif (np && of_get_property(np, \"use-ncsi\", NULL)) {\n\t\tif (!IS_ENABLED(CONFIG_NET_NCSI)) {\n\t\t\tdev_err(&pdev->dev, \"NCSI stack not enabled\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_phy_connect;\n\t\t}\n\n\t\tdev_info(&pdev->dev, \"Using NCSI interface\\n\");\n\t\tpriv->use_ncsi = true;\n\t\tpriv->ndev = ncsi_register_dev(netdev, ftgmac100_ncsi_handler);\n\t\tif (!priv->ndev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_phy_connect;\n\t\t}\n\t} else if (np && of_phy_is_fixed_link(np)) {\n\t\tstruct phy_device *phy;\n\n\t\terr = of_phy_register_fixed_link(np);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register fixed PHY\\n\");\n\t\t\tgoto err_phy_connect;\n\t\t}\n\n\t\tphy = of_phy_get_and_connect(priv->netdev, np,\n\t\t\t\t\t     &ftgmac100_adjust_link);\n\t\tif (!phy) {\n\t\t\tdev_err(&pdev->dev, \"Failed to connect to fixed PHY\\n\");\n\t\t\tof_phy_deregister_fixed_link(np);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_phy_connect;\n\t\t}\n\n\t\t \n\t\tphy_attached_info(phy);\n\t} else if (np && of_get_property(np, \"phy-handle\", NULL)) {\n\t\tstruct phy_device *phy;\n\n\t\t \n\t\tif (of_device_is_compatible(np, \"aspeed,ast2400-mac\") ||\n\t\t    of_device_is_compatible(np, \"aspeed,ast2500-mac\")) {\n\t\t\terr = ftgmac100_setup_mdio(netdev);\n\t\t\tif (err)\n\t\t\t\tgoto err_setup_mdio;\n\t\t}\n\n\t\tphy = of_phy_get_and_connect(priv->netdev, np,\n\t\t\t\t\t     &ftgmac100_adjust_link);\n\t\tif (!phy) {\n\t\t\tdev_err(&pdev->dev, \"Failed to connect to phy\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_phy_connect;\n\t\t}\n\n\t\t \n\t\tphy_support_asym_pause(phy);\n\n\t\t \n\t\tphy_attached_info(phy);\n\t} else if (np && !ftgmac100_has_child_node(np, \"mdio\")) {\n\t\t \n\t\tpriv->use_ncsi = false;\n\t\terr = ftgmac100_setup_mdio(netdev);\n\t\tif (err)\n\t\t\tgoto err_setup_mdio;\n\n\t\terr = ftgmac100_mii_probe(netdev);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"MII probe failed!\\n\");\n\t\t\tgoto err_ncsi_dev;\n\t\t}\n\n\t}\n\n\tif (priv->is_aspeed) {\n\t\terr = ftgmac100_setup_clk(priv);\n\t\tif (err)\n\t\t\tgoto err_phy_connect;\n\n\t\t \n\t\tif (of_device_is_compatible(np, \"aspeed,ast2600-mac\"))\n\t\t\tiowrite32(FTGMAC100_TM_DEFAULT,\n\t\t\t\t  priv->base + FTGMAC100_OFFSET_TM);\n\t}\n\n\t \n\tpriv->rx_q_entries = priv->new_rx_q_entries = DEF_RX_QUEUE_ENTRIES;\n\tpriv->tx_q_entries = priv->new_tx_q_entries = DEF_TX_QUEUE_ENTRIES;\n\n\t \n\tnetdev->hw_features = NETIF_F_RXCSUM | NETIF_F_HW_CSUM |\n\t\tNETIF_F_GRO | NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX |\n\t\tNETIF_F_HW_VLAN_CTAG_TX;\n\n\tif (priv->use_ncsi)\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\t \n\tif (np && (of_device_is_compatible(np, \"aspeed,ast2400-mac\")))\n\t\tnetdev->hw_features &= ~NETIF_F_HW_CSUM;\n\n\t \n\tif (priv->use_ncsi && of_device_is_compatible(np, \"aspeed,ast2600-mac\"))\n\t\tnetdev->hw_features &= ~NETIF_F_HW_CSUM;\n\n\tif (np && of_get_property(np, \"no-hw-checksum\", NULL))\n\t\tnetdev->hw_features &= ~(NETIF_F_HW_CSUM | NETIF_F_RXCSUM);\n\tnetdev->features |= netdev->hw_features;\n\n\t \n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register netdev\\n\");\n\t\tgoto err_register_netdev;\n\t}\n\n\tnetdev_info(netdev, \"irq %d, mapped at %p\\n\", netdev->irq, priv->base);\n\n\treturn 0;\n\nerr_register_netdev:\n\tclk_disable_unprepare(priv->rclk);\n\tclk_disable_unprepare(priv->clk);\nerr_phy_connect:\n\tftgmac100_phy_disconnect(netdev);\nerr_ncsi_dev:\n\tif (priv->ndev)\n\t\tncsi_unregister_dev(priv->ndev);\n\tftgmac100_destroy_mdio(netdev);\nerr_setup_mdio:\n\tiounmap(priv->base);\nerr_ioremap:\n\trelease_resource(priv->res);\nerr_req_mem:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\treturn err;\n}\n\nstatic int ftgmac100_remove(struct platform_device *pdev)\n{\n\tstruct net_device *netdev;\n\tstruct ftgmac100 *priv;\n\n\tnetdev = platform_get_drvdata(pdev);\n\tpriv = netdev_priv(netdev);\n\n\tif (priv->ndev)\n\t\tncsi_unregister_dev(priv->ndev);\n\tunregister_netdev(netdev);\n\n\tclk_disable_unprepare(priv->rclk);\n\tclk_disable_unprepare(priv->clk);\n\n\t \n\tcancel_work_sync(&priv->reset_task);\n\n\tftgmac100_phy_disconnect(netdev);\n\tftgmac100_destroy_mdio(netdev);\n\n\tiounmap(priv->base);\n\trelease_resource(priv->res);\n\n\tnetif_napi_del(&priv->napi);\n\tfree_netdev(netdev);\n\treturn 0;\n}\n\nstatic const struct of_device_id ftgmac100_of_match[] = {\n\t{ .compatible = \"faraday,ftgmac100\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ftgmac100_of_match);\n\nstatic struct platform_driver ftgmac100_driver = {\n\t.probe\t= ftgmac100_probe,\n\t.remove\t= ftgmac100_remove,\n\t.driver\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= ftgmac100_of_match,\n\t},\n};\nmodule_platform_driver(ftgmac100_driver);\n\nMODULE_AUTHOR(\"Po-Yu Chuang <ratbert@faraday-tech.com>\");\nMODULE_DESCRIPTION(\"FTGMAC100 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}