{
  "module_name": "ftmac100.c",
  "hash_id": "fca42c1b76471ccb2d309178984697f86fe2d25b8f0fc8fc2d9398fac1a5279b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/faraday/ftmac100.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n\n#include \"ftmac100.h\"\n\n#define DRV_NAME\t\"ftmac100\"\n\n#define RX_QUEUE_ENTRIES\t128\t \n#define TX_QUEUE_ENTRIES\t16\t \n\n#define RX_BUF_SIZE\t\t2044\t \n#define MAX_PKT_SIZE\t\tRX_BUF_SIZE  \n\n#if MAX_PKT_SIZE > 0x7ff\n#error invalid MAX_PKT_SIZE\n#endif\n\n#if RX_BUF_SIZE > 0x7ff || RX_BUF_SIZE > PAGE_SIZE\n#error invalid RX_BUF_SIZE\n#endif\n\n \nstruct ftmac100_descs {\n\tstruct ftmac100_rxdes rxdes[RX_QUEUE_ENTRIES];\n\tstruct ftmac100_txdes txdes[TX_QUEUE_ENTRIES];\n};\n\nstruct ftmac100 {\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint irq;\n\n\tstruct ftmac100_descs *descs;\n\tdma_addr_t descs_dma_addr;\n\n\tunsigned int rx_pointer;\n\tunsigned int tx_clean_pointer;\n\tunsigned int tx_pointer;\n\tunsigned int tx_pending;\n\n\tspinlock_t tx_lock;\n\n\tstruct net_device *netdev;\n\tstruct device *dev;\n\tstruct napi_struct napi;\n\n\tstruct mii_if_info mii;\n};\n\nstatic int ftmac100_alloc_rx_page(struct ftmac100 *priv,\n\t\t\t\t  struct ftmac100_rxdes *rxdes, gfp_t gfp);\n\n \n#define INT_MASK_ALL_ENABLED\t(FTMAC100_INT_RPKT_FINISH\t| \\\n\t\t\t\t FTMAC100_INT_NORXBUF\t\t| \\\n\t\t\t\t FTMAC100_INT_XPKT_OK\t\t| \\\n\t\t\t\t FTMAC100_INT_XPKT_LOST\t\t| \\\n\t\t\t\t FTMAC100_INT_RPKT_LOST\t\t| \\\n\t\t\t\t FTMAC100_INT_AHB_ERR\t\t| \\\n\t\t\t\t FTMAC100_INT_PHYSTS_CHG)\n\n#define INT_MASK_ALL_DISABLED\t0\n\nstatic void ftmac100_enable_all_int(struct ftmac100 *priv)\n{\n\tiowrite32(INT_MASK_ALL_ENABLED, priv->base + FTMAC100_OFFSET_IMR);\n}\n\nstatic void ftmac100_disable_all_int(struct ftmac100 *priv)\n{\n\tiowrite32(INT_MASK_ALL_DISABLED, priv->base + FTMAC100_OFFSET_IMR);\n}\n\nstatic void ftmac100_set_rx_ring_base(struct ftmac100 *priv, dma_addr_t addr)\n{\n\tiowrite32(addr, priv->base + FTMAC100_OFFSET_RXR_BADR);\n}\n\nstatic void ftmac100_set_tx_ring_base(struct ftmac100 *priv, dma_addr_t addr)\n{\n\tiowrite32(addr, priv->base + FTMAC100_OFFSET_TXR_BADR);\n}\n\nstatic void ftmac100_txdma_start_polling(struct ftmac100 *priv)\n{\n\tiowrite32(1, priv->base + FTMAC100_OFFSET_TXPD);\n}\n\nstatic int ftmac100_reset(struct ftmac100 *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint i;\n\n\t \n\tiowrite32(FTMAC100_MACCR_SW_RST, priv->base + FTMAC100_OFFSET_MACCR);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tunsigned int maccr;\n\n\t\tmaccr = ioread32(priv->base + FTMAC100_OFFSET_MACCR);\n\t\tif (!(maccr & FTMAC100_MACCR_SW_RST)) {\n\t\t\t \n\t\t\tudelay(500);\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(1000);\n\t}\n\n\tnetdev_err(netdev, \"software reset failed\\n\");\n\treturn -EIO;\n}\n\nstatic void ftmac100_set_mac(struct ftmac100 *priv, const unsigned char *mac)\n{\n\tunsigned int maddr = mac[0] << 8 | mac[1];\n\tunsigned int laddr = mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5];\n\n\tiowrite32(maddr, priv->base + FTMAC100_OFFSET_MAC_MADR);\n\tiowrite32(laddr, priv->base + FTMAC100_OFFSET_MAC_LADR);\n}\n\nstatic void ftmac100_setup_mc_ht(struct ftmac100 *priv)\n{\n\tstruct netdev_hw_addr *ha;\n\tu64 maht = 0;  \n\n\tnetdev_for_each_mc_addr(ha, priv->netdev) {\n\t\tu32 hash = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\n\t\tmaht |= BIT_ULL(hash);\n\t}\n\n\tiowrite32(lower_32_bits(maht), priv->base + FTMAC100_OFFSET_MAHT0);\n\tiowrite32(upper_32_bits(maht), priv->base + FTMAC100_OFFSET_MAHT1);\n}\n\nstatic void ftmac100_set_rx_bits(struct ftmac100 *priv, unsigned int *maccr)\n{\n\tstruct net_device *netdev = priv->netdev;\n\n\t \n\t*maccr &= ~(FTMAC100_MACCR_RCV_ALL | FTMAC100_MACCR_RX_MULTIPKT |\n\t\t   FTMAC100_MACCR_HT_MULTI_EN);\n\n\t \n\tif (netdev->flags & IFF_PROMISC)\n\t\t*maccr |= FTMAC100_MACCR_RCV_ALL;\n\tif (netdev->flags & IFF_ALLMULTI)\n\t\t*maccr |= FTMAC100_MACCR_RX_MULTIPKT;\n\telse if (netdev_mc_count(netdev)) {\n\t\t*maccr |= FTMAC100_MACCR_HT_MULTI_EN;\n\t\tftmac100_setup_mc_ht(priv);\n\t}\n}\n\n#define MACCR_ENABLE_ALL\t(FTMAC100_MACCR_XMT_EN\t| \\\n\t\t\t\t FTMAC100_MACCR_RCV_EN\t| \\\n\t\t\t\t FTMAC100_MACCR_XDMA_EN\t| \\\n\t\t\t\t FTMAC100_MACCR_RDMA_EN\t| \\\n\t\t\t\t FTMAC100_MACCR_CRC_APD\t| \\\n\t\t\t\t FTMAC100_MACCR_FULLDUP\t| \\\n\t\t\t\t FTMAC100_MACCR_RX_RUNT\t| \\\n\t\t\t\t FTMAC100_MACCR_RX_BROADPKT)\n\nstatic int ftmac100_start_hw(struct ftmac100 *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tunsigned int maccr = MACCR_ENABLE_ALL;\n\n\tif (ftmac100_reset(priv))\n\t\treturn -EIO;\n\n\t \n\tftmac100_set_rx_ring_base(priv,\n\t\t\t\t  priv->descs_dma_addr +\n\t\t\t\t  offsetof(struct ftmac100_descs, rxdes));\n\tftmac100_set_tx_ring_base(priv,\n\t\t\t\t  priv->descs_dma_addr +\n\t\t\t\t  offsetof(struct ftmac100_descs, txdes));\n\n\tiowrite32(FTMAC100_APTC_RXPOLL_CNT(1), priv->base + FTMAC100_OFFSET_APTC);\n\n\tftmac100_set_mac(priv, netdev->dev_addr);\n\n\t  \n\tif (netdev->mtu > ETH_DATA_LEN)\n\t\tmaccr |= FTMAC100_MACCR_RX_FTL;\n\n\tftmac100_set_rx_bits(priv, &maccr);\n\n\tiowrite32(maccr, priv->base + FTMAC100_OFFSET_MACCR);\n\treturn 0;\n}\n\nstatic void ftmac100_stop_hw(struct ftmac100 *priv)\n{\n\tiowrite32(0, priv->base + FTMAC100_OFFSET_MACCR);\n}\n\n \nstatic bool ftmac100_rxdes_first_segment(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_FRS);\n}\n\nstatic bool ftmac100_rxdes_last_segment(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_LRS);\n}\n\nstatic bool ftmac100_rxdes_owned_by_dma(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RXDMA_OWN);\n}\n\nstatic void ftmac100_rxdes_set_dma_own(struct ftmac100_rxdes *rxdes)\n{\n\t \n\trxdes->rxdes0 = cpu_to_le32(FTMAC100_RXDES0_RXDMA_OWN);\n}\n\nstatic bool ftmac100_rxdes_rx_error(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RX_ERR);\n}\n\nstatic bool ftmac100_rxdes_crc_error(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_CRC_ERR);\n}\n\nstatic bool ftmac100_rxdes_runt(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RUNT);\n}\n\nstatic bool ftmac100_rxdes_odd_nibble(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RX_ODD_NB);\n}\n\nstatic unsigned int ftmac100_rxdes_frame_length(struct ftmac100_rxdes *rxdes)\n{\n\treturn le32_to_cpu(rxdes->rxdes0) & FTMAC100_RXDES0_RFL;\n}\n\nstatic bool ftmac100_rxdes_multicast(struct ftmac100_rxdes *rxdes)\n{\n\treturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_MULTICAST);\n}\n\nstatic void ftmac100_rxdes_set_buffer_size(struct ftmac100_rxdes *rxdes,\n\t\t\t\t\t   unsigned int size)\n{\n\trxdes->rxdes1 &= cpu_to_le32(FTMAC100_RXDES1_EDORR);\n\trxdes->rxdes1 |= cpu_to_le32(FTMAC100_RXDES1_RXBUF_SIZE(size));\n}\n\nstatic void ftmac100_rxdes_set_end_of_ring(struct ftmac100_rxdes *rxdes)\n{\n\trxdes->rxdes1 |= cpu_to_le32(FTMAC100_RXDES1_EDORR);\n}\n\nstatic void ftmac100_rxdes_set_dma_addr(struct ftmac100_rxdes *rxdes,\n\t\t\t\t\tdma_addr_t addr)\n{\n\trxdes->rxdes2 = cpu_to_le32(addr);\n}\n\nstatic dma_addr_t ftmac100_rxdes_get_dma_addr(struct ftmac100_rxdes *rxdes)\n{\n\treturn le32_to_cpu(rxdes->rxdes2);\n}\n\n \nstatic void ftmac100_rxdes_set_page(struct ftmac100_rxdes *rxdes, struct page *page)\n{\n\trxdes->rxdes3 = (unsigned int)page;\n}\n\nstatic struct page *ftmac100_rxdes_get_page(struct ftmac100_rxdes *rxdes)\n{\n\treturn (struct page *)rxdes->rxdes3;\n}\n\n \nstatic int ftmac100_next_rx_pointer(int pointer)\n{\n\treturn (pointer + 1) & (RX_QUEUE_ENTRIES - 1);\n}\n\nstatic void ftmac100_rx_pointer_advance(struct ftmac100 *priv)\n{\n\tpriv->rx_pointer = ftmac100_next_rx_pointer(priv->rx_pointer);\n}\n\nstatic struct ftmac100_rxdes *ftmac100_current_rxdes(struct ftmac100 *priv)\n{\n\treturn &priv->descs->rxdes[priv->rx_pointer];\n}\n\nstatic struct ftmac100_rxdes *\nftmac100_rx_locate_first_segment(struct ftmac100 *priv)\n{\n\tstruct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);\n\n\twhile (!ftmac100_rxdes_owned_by_dma(rxdes)) {\n\t\tif (ftmac100_rxdes_first_segment(rxdes))\n\t\t\treturn rxdes;\n\n\t\tftmac100_rxdes_set_dma_own(rxdes);\n\t\tftmac100_rx_pointer_advance(priv);\n\t\trxdes = ftmac100_current_rxdes(priv);\n\t}\n\n\treturn NULL;\n}\n\nstatic bool ftmac100_rx_packet_error(struct ftmac100 *priv,\n\t\t\t\t     struct ftmac100_rxdes *rxdes)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tbool error = false;\n\n\tif (unlikely(ftmac100_rxdes_rx_error(rxdes))) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev, \"rx err\\n\");\n\n\t\tnetdev->stats.rx_errors++;\n\t\terror = true;\n\t}\n\n\tif (unlikely(ftmac100_rxdes_crc_error(rxdes))) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev, \"rx crc err\\n\");\n\n\t\tnetdev->stats.rx_crc_errors++;\n\t\terror = true;\n\t}\n\n\tif (unlikely(ftmac100_rxdes_runt(rxdes))) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev, \"rx runt\\n\");\n\n\t\tnetdev->stats.rx_length_errors++;\n\t\terror = true;\n\t} else if (unlikely(ftmac100_rxdes_odd_nibble(rxdes))) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev, \"rx odd nibble\\n\");\n\n\t\tnetdev->stats.rx_length_errors++;\n\t\terror = true;\n\t}\n\t \n\n\treturn error;\n}\n\nstatic void ftmac100_rx_drop_packet(struct ftmac100 *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);\n\tbool done = false;\n\n\tif (net_ratelimit())\n\t\tnetdev_dbg(netdev, \"drop packet %p\\n\", rxdes);\n\n\tdo {\n\t\tif (ftmac100_rxdes_last_segment(rxdes))\n\t\t\tdone = true;\n\n\t\tftmac100_rxdes_set_dma_own(rxdes);\n\t\tftmac100_rx_pointer_advance(priv);\n\t\trxdes = ftmac100_current_rxdes(priv);\n\t} while (!done && !ftmac100_rxdes_owned_by_dma(rxdes));\n\n\tnetdev->stats.rx_dropped++;\n}\n\nstatic bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct ftmac100_rxdes *rxdes;\n\tstruct sk_buff *skb;\n\tstruct page *page;\n\tdma_addr_t map;\n\tint length;\n\tbool ret;\n\n\trxdes = ftmac100_rx_locate_first_segment(priv);\n\tif (!rxdes)\n\t\treturn false;\n\n\tif (unlikely(ftmac100_rx_packet_error(priv, rxdes))) {\n\t\tftmac100_rx_drop_packet(priv);\n\t\treturn true;\n\t}\n\n\t \n\tret = ftmac100_rxdes_last_segment(rxdes);\n\tif (unlikely(!ret)) {\n\t\tnetdev->stats.rx_length_errors++;\n\t\tftmac100_rx_drop_packet(priv);\n\t\treturn true;\n\t}\n\n\t \n\tskb = netdev_alloc_skb_ip_align(netdev, 128);\n\tif (unlikely(!skb)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"rx skb alloc failed\\n\");\n\n\t\tftmac100_rx_drop_packet(priv);\n\t\treturn true;\n\t}\n\n\tif (unlikely(ftmac100_rxdes_multicast(rxdes)))\n\t\tnetdev->stats.multicast++;\n\n\tmap = ftmac100_rxdes_get_dma_addr(rxdes);\n\tdma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\n\n\tlength = ftmac100_rxdes_frame_length(rxdes);\n\tpage = ftmac100_rxdes_get_page(rxdes);\n\tskb_fill_page_desc(skb, 0, page, 0, length);\n\tskb->len += length;\n\tskb->data_len += length;\n\n\tif (length > 128) {\n\t\tskb->truesize += PAGE_SIZE;\n\t\t \n\t\t__pskb_pull_tail(skb, ETH_HLEN);\n\t} else {\n\t\t \n\t\t__pskb_pull_tail(skb, length);\n\t}\n\tftmac100_alloc_rx_page(priv, rxdes, GFP_ATOMIC);\n\n\tftmac100_rx_pointer_advance(priv);\n\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += skb->len;\n\n\t \n\tnetif_receive_skb(skb);\n\n\t(*processed)++;\n\treturn true;\n}\n\n \nstatic void ftmac100_txdes_reset(struct ftmac100_txdes *txdes)\n{\n\t \n\ttxdes->txdes0 = 0;\n\ttxdes->txdes1 &= cpu_to_le32(FTMAC100_TXDES1_EDOTR);\n\ttxdes->txdes2 = 0;\n\ttxdes->txdes3 = 0;\n}\n\nstatic bool ftmac100_txdes_owned_by_dma(struct ftmac100_txdes *txdes)\n{\n\treturn txdes->txdes0 & cpu_to_le32(FTMAC100_TXDES0_TXDMA_OWN);\n}\n\nstatic void ftmac100_txdes_set_dma_own(struct ftmac100_txdes *txdes)\n{\n\t \n\twmb();\n\ttxdes->txdes0 |= cpu_to_le32(FTMAC100_TXDES0_TXDMA_OWN);\n}\n\nstatic bool ftmac100_txdes_excessive_collision(struct ftmac100_txdes *txdes)\n{\n\treturn txdes->txdes0 & cpu_to_le32(FTMAC100_TXDES0_TXPKT_EXSCOL);\n}\n\nstatic bool ftmac100_txdes_late_collision(struct ftmac100_txdes *txdes)\n{\n\treturn txdes->txdes0 & cpu_to_le32(FTMAC100_TXDES0_TXPKT_LATECOL);\n}\n\nstatic void ftmac100_txdes_set_end_of_ring(struct ftmac100_txdes *txdes)\n{\n\ttxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_EDOTR);\n}\n\nstatic void ftmac100_txdes_set_first_segment(struct ftmac100_txdes *txdes)\n{\n\ttxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_FTS);\n}\n\nstatic void ftmac100_txdes_set_last_segment(struct ftmac100_txdes *txdes)\n{\n\ttxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_LTS);\n}\n\nstatic void ftmac100_txdes_set_txint(struct ftmac100_txdes *txdes)\n{\n\ttxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_TXIC);\n}\n\nstatic void ftmac100_txdes_set_buffer_size(struct ftmac100_txdes *txdes,\n\t\t\t\t\t   unsigned int len)\n{\n\ttxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_TXBUF_SIZE(len));\n}\n\nstatic void ftmac100_txdes_set_dma_addr(struct ftmac100_txdes *txdes,\n\t\t\t\t\tdma_addr_t addr)\n{\n\ttxdes->txdes2 = cpu_to_le32(addr);\n}\n\nstatic dma_addr_t ftmac100_txdes_get_dma_addr(struct ftmac100_txdes *txdes)\n{\n\treturn le32_to_cpu(txdes->txdes2);\n}\n\n \nstatic void ftmac100_txdes_set_skb(struct ftmac100_txdes *txdes, struct sk_buff *skb)\n{\n\ttxdes->txdes3 = (unsigned int)skb;\n}\n\nstatic struct sk_buff *ftmac100_txdes_get_skb(struct ftmac100_txdes *txdes)\n{\n\treturn (struct sk_buff *)txdes->txdes3;\n}\n\n \nstatic int ftmac100_next_tx_pointer(int pointer)\n{\n\treturn (pointer + 1) & (TX_QUEUE_ENTRIES - 1);\n}\n\nstatic void ftmac100_tx_pointer_advance(struct ftmac100 *priv)\n{\n\tpriv->tx_pointer = ftmac100_next_tx_pointer(priv->tx_pointer);\n}\n\nstatic void ftmac100_tx_clean_pointer_advance(struct ftmac100 *priv)\n{\n\tpriv->tx_clean_pointer = ftmac100_next_tx_pointer(priv->tx_clean_pointer);\n}\n\nstatic struct ftmac100_txdes *ftmac100_current_txdes(struct ftmac100 *priv)\n{\n\treturn &priv->descs->txdes[priv->tx_pointer];\n}\n\nstatic struct ftmac100_txdes *ftmac100_current_clean_txdes(struct ftmac100 *priv)\n{\n\treturn &priv->descs->txdes[priv->tx_clean_pointer];\n}\n\nstatic bool ftmac100_tx_complete_packet(struct ftmac100 *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct ftmac100_txdes *txdes;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\n\tif (priv->tx_pending == 0)\n\t\treturn false;\n\n\ttxdes = ftmac100_current_clean_txdes(priv);\n\n\tif (ftmac100_txdes_owned_by_dma(txdes))\n\t\treturn false;\n\n\tskb = ftmac100_txdes_get_skb(txdes);\n\tmap = ftmac100_txdes_get_dma_addr(txdes);\n\n\tif (unlikely(ftmac100_txdes_excessive_collision(txdes) ||\n\t\t     ftmac100_txdes_late_collision(txdes))) {\n\t\t \n\t\tnetdev->stats.tx_aborted_errors++;\n\t} else {\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += skb->len;\n\t}\n\n\tdma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);\n\tdev_kfree_skb(skb);\n\n\tftmac100_txdes_reset(txdes);\n\n\tftmac100_tx_clean_pointer_advance(priv);\n\n\tspin_lock(&priv->tx_lock);\n\tpriv->tx_pending--;\n\tspin_unlock(&priv->tx_lock);\n\tnetif_wake_queue(netdev);\n\n\treturn true;\n}\n\nstatic void ftmac100_tx_complete(struct ftmac100 *priv)\n{\n\twhile (ftmac100_tx_complete_packet(priv))\n\t\t;\n}\n\nstatic netdev_tx_t ftmac100_xmit(struct ftmac100 *priv, struct sk_buff *skb,\n\t\t\t\t dma_addr_t map)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct ftmac100_txdes *txdes;\n\tunsigned int len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;\n\n\ttxdes = ftmac100_current_txdes(priv);\n\tftmac100_tx_pointer_advance(priv);\n\n\t \n\tftmac100_txdes_set_skb(txdes, skb);\n\tftmac100_txdes_set_dma_addr(txdes, map);\n\n\tftmac100_txdes_set_first_segment(txdes);\n\tftmac100_txdes_set_last_segment(txdes);\n\tftmac100_txdes_set_txint(txdes);\n\tftmac100_txdes_set_buffer_size(txdes, len);\n\n\tspin_lock(&priv->tx_lock);\n\tpriv->tx_pending++;\n\tif (priv->tx_pending == TX_QUEUE_ENTRIES)\n\t\tnetif_stop_queue(netdev);\n\n\t \n\tftmac100_txdes_set_dma_own(txdes);\n\tspin_unlock(&priv->tx_lock);\n\n\tftmac100_txdma_start_polling(priv);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int ftmac100_alloc_rx_page(struct ftmac100 *priv,\n\t\t\t\t  struct ftmac100_rxdes *rxdes, gfp_t gfp)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct page *page;\n\tdma_addr_t map;\n\n\tpage = alloc_page(gfp);\n\tif (!page) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"failed to allocate rx page\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmap = dma_map_page(priv->dev, page, 0, RX_BUF_SIZE, DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(priv->dev, map))) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"failed to map rx page\\n\");\n\t\t__free_page(page);\n\t\treturn -ENOMEM;\n\t}\n\n\tftmac100_rxdes_set_page(rxdes, page);\n\tftmac100_rxdes_set_dma_addr(rxdes, map);\n\tftmac100_rxdes_set_buffer_size(rxdes, RX_BUF_SIZE);\n\tftmac100_rxdes_set_dma_own(rxdes);\n\treturn 0;\n}\n\nstatic void ftmac100_free_buffers(struct ftmac100 *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_QUEUE_ENTRIES; i++) {\n\t\tstruct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];\n\t\tstruct page *page = ftmac100_rxdes_get_page(rxdes);\n\t\tdma_addr_t map = ftmac100_rxdes_get_dma_addr(rxdes);\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tdma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t__free_page(page);\n\t}\n\n\tfor (i = 0; i < TX_QUEUE_ENTRIES; i++) {\n\t\tstruct ftmac100_txdes *txdes = &priv->descs->txdes[i];\n\t\tstruct sk_buff *skb = ftmac100_txdes_get_skb(txdes);\n\t\tdma_addr_t map = ftmac100_txdes_get_dma_addr(txdes);\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tdma_free_coherent(priv->dev, sizeof(struct ftmac100_descs),\n\t\t\t  priv->descs, priv->descs_dma_addr);\n}\n\nstatic int ftmac100_alloc_buffers(struct ftmac100 *priv)\n{\n\tint i;\n\n\tpriv->descs = dma_alloc_coherent(priv->dev,\n\t\t\t\t\t sizeof(struct ftmac100_descs),\n\t\t\t\t\t &priv->descs_dma_addr, GFP_KERNEL);\n\tif (!priv->descs)\n\t\treturn -ENOMEM;\n\n\t \n\tftmac100_rxdes_set_end_of_ring(&priv->descs->rxdes[RX_QUEUE_ENTRIES - 1]);\n\n\tfor (i = 0; i < RX_QUEUE_ENTRIES; i++) {\n\t\tstruct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];\n\n\t\tif (ftmac100_alloc_rx_page(priv, rxdes, GFP_KERNEL))\n\t\t\tgoto err;\n\t}\n\n\t \n\tftmac100_txdes_set_end_of_ring(&priv->descs->txdes[TX_QUEUE_ENTRIES - 1]);\n\treturn 0;\n\nerr:\n\tftmac100_free_buffers(priv);\n\treturn -ENOMEM;\n}\n\n \nstatic int ftmac100_mdio_read(struct net_device *netdev, int phy_id, int reg)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\tunsigned int phycr;\n\tint i;\n\n\tphycr = FTMAC100_PHYCR_PHYAD(phy_id) |\n\t\tFTMAC100_PHYCR_REGAD(reg) |\n\t\tFTMAC100_PHYCR_MIIRD;\n\n\tiowrite32(phycr, priv->base + FTMAC100_OFFSET_PHYCR);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tphycr = ioread32(priv->base + FTMAC100_OFFSET_PHYCR);\n\n\t\tif ((phycr & FTMAC100_PHYCR_MIIRD) == 0)\n\t\t\treturn phycr & FTMAC100_PHYCR_MIIRDATA;\n\n\t\tudelay(100);\n\t}\n\n\tnetdev_err(netdev, \"mdio read timed out\\n\");\n\treturn 0;\n}\n\nstatic void ftmac100_mdio_write(struct net_device *netdev, int phy_id, int reg,\n\t\t\t\tint data)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\tunsigned int phycr;\n\tint i;\n\n\tphycr = FTMAC100_PHYCR_PHYAD(phy_id) |\n\t\tFTMAC100_PHYCR_REGAD(reg) |\n\t\tFTMAC100_PHYCR_MIIWR;\n\n\tdata = FTMAC100_PHYWDATA_MIIWDATA(data);\n\n\tiowrite32(data, priv->base + FTMAC100_OFFSET_PHYWDATA);\n\tiowrite32(phycr, priv->base + FTMAC100_OFFSET_PHYCR);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tphycr = ioread32(priv->base + FTMAC100_OFFSET_PHYCR);\n\n\t\tif ((phycr & FTMAC100_PHYCR_MIIWR) == 0)\n\t\t\treturn;\n\n\t\tudelay(100);\n\t}\n\n\tnetdev_err(netdev, \"mdio write timed out\\n\");\n}\n\n \nstatic void ftmac100_get_drvinfo(struct net_device *netdev,\n\t\t\t\t struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, dev_name(&netdev->dev), sizeof(info->bus_info));\n}\n\nstatic int ftmac100_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\n\tmii_ethtool_get_link_ksettings(&priv->mii, cmd);\n\n\treturn 0;\n}\n\nstatic int ftmac100_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\treturn mii_ethtool_set_link_ksettings(&priv->mii, cmd);\n}\n\nstatic int ftmac100_nway_reset(struct net_device *netdev)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\treturn mii_nway_restart(&priv->mii);\n}\n\nstatic u32 ftmac100_get_link(struct net_device *netdev)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\treturn mii_link_ok(&priv->mii);\n}\n\nstatic const struct ethtool_ops ftmac100_ethtool_ops = {\n\t.get_drvinfo\t\t= ftmac100_get_drvinfo,\n\t.nway_reset\t\t= ftmac100_nway_reset,\n\t.get_link\t\t= ftmac100_get_link,\n\t.get_link_ksettings\t= ftmac100_get_link_ksettings,\n\t.set_link_ksettings\t= ftmac100_set_link_ksettings,\n};\n\n \nstatic irqreturn_t ftmac100_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *netdev = dev_id;\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\n\t \n\tftmac100_disable_all_int(priv);\n\tif (likely(netif_running(netdev)))\n\t\tnapi_schedule(&priv->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ftmac100_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ftmac100 *priv = container_of(napi, struct ftmac100, napi);\n\tstruct net_device *netdev = priv->netdev;\n\tunsigned int status;\n\tbool completed = true;\n\tint rx = 0;\n\n\tstatus = ioread32(priv->base + FTMAC100_OFFSET_ISR);\n\n\tif (status & (FTMAC100_INT_RPKT_FINISH | FTMAC100_INT_NORXBUF)) {\n\t\t \n\t\tbool retry;\n\n\t\tdo {\n\t\t\tretry = ftmac100_rx_packet(priv, &rx);\n\t\t} while (retry && rx < budget);\n\n\t\tif (retry && rx == budget)\n\t\t\tcompleted = false;\n\t}\n\n\tif (status & (FTMAC100_INT_XPKT_OK | FTMAC100_INT_XPKT_LOST)) {\n\t\t \n\t\tftmac100_tx_complete(priv);\n\t}\n\n\tif (status & (FTMAC100_INT_NORXBUF | FTMAC100_INT_RPKT_LOST |\n\t\t      FTMAC100_INT_AHB_ERR | FTMAC100_INT_PHYSTS_CHG)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev, \"[ISR] = 0x%x: %s%s%s%s\\n\", status,\n\t\t\t\t    status & FTMAC100_INT_NORXBUF ? \"NORXBUF \" : \"\",\n\t\t\t\t    status & FTMAC100_INT_RPKT_LOST ? \"RPKT_LOST \" : \"\",\n\t\t\t\t    status & FTMAC100_INT_AHB_ERR ? \"AHB_ERR \" : \"\",\n\t\t\t\t    status & FTMAC100_INT_PHYSTS_CHG ? \"PHYSTS_CHG\" : \"\");\n\n\t\tif (status & FTMAC100_INT_NORXBUF) {\n\t\t\t \n\t\t\tnetdev->stats.rx_over_errors++;\n\t\t}\n\n\t\tif (status & FTMAC100_INT_RPKT_LOST) {\n\t\t\t \n\t\t\tnetdev->stats.rx_fifo_errors++;\n\t\t}\n\n\t\tif (status & FTMAC100_INT_PHYSTS_CHG) {\n\t\t\t \n\t\t\tmii_check_link(&priv->mii);\n\t\t}\n\t}\n\n\tif (completed) {\n\t\t \n\t\tnapi_complete(napi);\n\t\tftmac100_enable_all_int(priv);\n\t}\n\n\treturn rx;\n}\n\n \nstatic int ftmac100_open(struct net_device *netdev)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\tint err;\n\n\terr = ftmac100_alloc_buffers(priv);\n\tif (err) {\n\t\tnetdev_err(netdev, \"failed to allocate buffers\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\terr = request_irq(priv->irq, ftmac100_interrupt, 0, netdev->name, netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"failed to request irq %d\\n\", priv->irq);\n\t\tgoto err_irq;\n\t}\n\n\tpriv->rx_pointer = 0;\n\tpriv->tx_clean_pointer = 0;\n\tpriv->tx_pointer = 0;\n\tpriv->tx_pending = 0;\n\n\terr = ftmac100_start_hw(priv);\n\tif (err)\n\t\tgoto err_hw;\n\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(netdev);\n\n\tftmac100_enable_all_int(priv);\n\n\treturn 0;\n\nerr_hw:\n\tfree_irq(priv->irq, netdev);\nerr_irq:\n\tftmac100_free_buffers(priv);\nerr_alloc:\n\treturn err;\n}\n\nstatic int ftmac100_stop(struct net_device *netdev)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\n\tftmac100_disable_all_int(priv);\n\tnetif_stop_queue(netdev);\n\tnapi_disable(&priv->napi);\n\tftmac100_stop_hw(priv);\n\tfree_irq(priv->irq, netdev);\n\tftmac100_free_buffers(priv);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\nftmac100_hard_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\tdma_addr_t map;\n\n\tif (unlikely(skb->len > MAX_PKT_SIZE)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"tx packet too big\\n\");\n\n\t\tnetdev->stats.tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tmap = dma_map_single(priv->dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(priv->dev, map))) {\n\t\t \n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"map socket buffer failed\\n\");\n\n\t\tnetdev->stats.tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\treturn ftmac100_xmit(priv, skb, map);\n}\n\n \nstatic int ftmac100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\treturn generic_mii_ioctl(&priv->mii, data, cmd, NULL);\n}\n\nstatic int ftmac100_change_mtu(struct net_device *netdev, int mtu)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\tunsigned int maccr;\n\n\tmaccr = ioread32(priv->base + FTMAC100_OFFSET_MACCR);\n\tif (mtu > ETH_DATA_LEN) {\n\t\t \n\t\tmaccr |= FTMAC100_MACCR_RX_FTL;\n\t} else {\n\t\t \n\t\tmaccr &= ~FTMAC100_MACCR_RX_FTL;\n\t}\n\tiowrite32(maccr, priv->base + FTMAC100_OFFSET_MACCR);\n\n\tnetdev->mtu = mtu;\n\n\treturn 0;\n}\n\nstatic void ftmac100_set_rx_mode(struct net_device *netdev)\n{\n\tstruct ftmac100 *priv = netdev_priv(netdev);\n\tunsigned int maccr = ioread32(priv->base + FTMAC100_OFFSET_MACCR);\n\n\tftmac100_set_rx_bits(priv, &maccr);\n\tiowrite32(maccr, priv->base + FTMAC100_OFFSET_MACCR);\n}\n\nstatic const struct net_device_ops ftmac100_netdev_ops = {\n\t.ndo_open\t\t= ftmac100_open,\n\t.ndo_stop\t\t= ftmac100_stop,\n\t.ndo_start_xmit\t\t= ftmac100_hard_start_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= ftmac100_do_ioctl,\n\t.ndo_change_mtu\t\t= ftmac100_change_mtu,\n\t.ndo_set_rx_mode\t= ftmac100_set_rx_mode,\n};\n\n \nstatic int ftmac100_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tint irq;\n\tstruct net_device *netdev;\n\tstruct ftmac100 *priv;\n\tint err;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tnetdev = alloc_etherdev(sizeof(*priv));\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\tnetdev->ethtool_ops = &ftmac100_ethtool_ops;\n\tnetdev->netdev_ops = &ftmac100_netdev_ops;\n\tnetdev->max_mtu = MAX_PKT_SIZE - VLAN_ETH_HLEN;\n\n\terr = platform_get_ethdev_address(&pdev->dev, netdev);\n\tif (err == -EPROBE_DEFER)\n\t\tgoto defer_get_mac;\n\n\tplatform_set_drvdata(pdev, netdev);\n\n\t \n\tpriv = netdev_priv(netdev);\n\tpriv->netdev = netdev;\n\tpriv->dev = &pdev->dev;\n\n\tspin_lock_init(&priv->tx_lock);\n\n\t \n\tnetif_napi_add(netdev, &priv->napi, ftmac100_poll);\n\n\t \n\tpriv->res = request_mem_region(res->start, resource_size(res),\n\t\t\t\t       dev_name(&pdev->dev));\n\tif (!priv->res) {\n\t\tdev_err(&pdev->dev, \"Could not reserve memory region\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_req_mem;\n\t}\n\n\tpriv->base = ioremap(res->start, resource_size(res));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"Failed to ioremap ethernet registers\\n\");\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tpriv->irq = irq;\n\n\t \n\tpriv->mii.phy_id\t= 0;\n\tpriv->mii.phy_id_mask\t= 0x1f;\n\tpriv->mii.reg_num_mask\t= 0x1f;\n\tpriv->mii.dev\t\t= netdev;\n\tpriv->mii.mdio_read\t= ftmac100_mdio_read;\n\tpriv->mii.mdio_write\t= ftmac100_mdio_write;\n\n\t \n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register netdev\\n\");\n\t\tgoto err_register_netdev;\n\t}\n\n\tnetdev_info(netdev, \"irq %d, mapped at %p\\n\", priv->irq, priv->base);\n\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\teth_hw_addr_random(netdev);\n\t\tnetdev_info(netdev, \"generated random MAC address %pM\\n\",\n\t\t\t    netdev->dev_addr);\n\t}\n\n\treturn 0;\n\nerr_register_netdev:\n\tiounmap(priv->base);\nerr_ioremap:\n\trelease_resource(priv->res);\nerr_req_mem:\n\tnetif_napi_del(&priv->napi);\ndefer_get_mac:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\treturn err;\n}\n\nstatic int ftmac100_remove(struct platform_device *pdev)\n{\n\tstruct net_device *netdev;\n\tstruct ftmac100 *priv;\n\n\tnetdev = platform_get_drvdata(pdev);\n\tpriv = netdev_priv(netdev);\n\n\tunregister_netdev(netdev);\n\n\tiounmap(priv->base);\n\trelease_resource(priv->res);\n\n\tnetif_napi_del(&priv->napi);\n\tfree_netdev(netdev);\n\treturn 0;\n}\n\nstatic const struct of_device_id ftmac100_of_ids[] = {\n\t{ .compatible = \"andestech,atmac100\" },\n\t{ }\n};\n\nstatic struct platform_driver ftmac100_driver = {\n\t.probe\t\t= ftmac100_probe,\n\t.remove\t\t= ftmac100_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = ftmac100_of_ids\n\t},\n};\n\n \nmodule_platform_driver(ftmac100_driver);\n\nMODULE_AUTHOR(\"Po-Yu Chuang <ratbert@faraday-tech.com>\");\nMODULE_DESCRIPTION(\"FTMAC100 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(of, ftmac100_of_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}