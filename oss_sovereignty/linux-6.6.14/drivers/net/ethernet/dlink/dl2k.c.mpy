{
  "module_name": "dl2k.c",
  "hash_id": "1f2c2c2b4e168b556c10b1fbd0877955574ae6d5ba1b41664a9e1e5b41ff2742",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dlink/dl2k.c",
  "human_readable_source": "\n \n \n\n#include \"dl2k.h\"\n#include <linux/dma-mapping.h>\n\n#define dw32(reg, val)\tiowrite32(val, ioaddr + (reg))\n#define dw16(reg, val)\tiowrite16(val, ioaddr + (reg))\n#define dw8(reg, val)\tiowrite8(val, ioaddr + (reg))\n#define dr32(reg)\tioread32(ioaddr + (reg))\n#define dr16(reg)\tioread16(ioaddr + (reg))\n#define dr8(reg)\tioread8(ioaddr + (reg))\n\n#define MAX_UNITS 8\nstatic int mtu[MAX_UNITS];\nstatic int vlan[MAX_UNITS];\nstatic int jumbo[MAX_UNITS];\nstatic char *media[MAX_UNITS];\nstatic int tx_flow=-1;\nstatic int rx_flow=-1;\nstatic int copy_thresh;\nstatic int rx_coalesce=10;\t \nstatic int rx_timeout=200;\t \nstatic int tx_coalesce=16;\t \n\n\nMODULE_AUTHOR (\"Edward Peng\");\nMODULE_DESCRIPTION (\"D-Link DL2000-based Gigabit Ethernet Adapter\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_array(mtu, int, NULL, 0);\nmodule_param_array(media, charp, NULL, 0);\nmodule_param_array(vlan, int, NULL, 0);\nmodule_param_array(jumbo, int, NULL, 0);\nmodule_param(tx_flow, int, 0);\nmodule_param(rx_flow, int, 0);\nmodule_param(copy_thresh, int, 0);\nmodule_param(rx_coalesce, int, 0);\t \nmodule_param(rx_timeout, int, 0);\t \nmodule_param(tx_coalesce, int, 0);  \n\n\n \n#define DEFAULT_INTR (RxDMAComplete | HostError | IntRequested | TxDMAComplete| \\\n       UpdateStats | LinkEvent)\n\nstatic void dl2k_enable_int(struct netdev_private *np)\n{\n\tvoid __iomem *ioaddr = np->ioaddr;\n\n\tdw16(IntEnable, DEFAULT_INTR);\n}\n\nstatic const int max_intrloop = 50;\nstatic const int multicast_filter_limit = 0x40;\n\nstatic int rio_open (struct net_device *dev);\nstatic void rio_timer (struct timer_list *t);\nstatic void rio_tx_timeout (struct net_device *dev, unsigned int txqueue);\nstatic netdev_tx_t start_xmit (struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t rio_interrupt (int irq, void *dev_instance);\nstatic void rio_free_tx (struct net_device *dev, int irq);\nstatic void tx_error (struct net_device *dev, int tx_status);\nstatic int receive_packet (struct net_device *dev);\nstatic void rio_error (struct net_device *dev, int int_status);\nstatic void set_multicast (struct net_device *dev);\nstatic struct net_device_stats *get_stats (struct net_device *dev);\nstatic int clear_stats (struct net_device *dev);\nstatic int rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int rio_close (struct net_device *dev);\nstatic int find_miiphy (struct net_device *dev);\nstatic int parse_eeprom (struct net_device *dev);\nstatic int read_eeprom (struct netdev_private *, int eep_addr);\nstatic int mii_wait_link (struct net_device *dev, int wait);\nstatic int mii_set_media (struct net_device *dev);\nstatic int mii_get_media (struct net_device *dev);\nstatic int mii_set_media_pcs (struct net_device *dev);\nstatic int mii_get_media_pcs (struct net_device *dev);\nstatic int mii_read (struct net_device *dev, int phy_addr, int reg_num);\nstatic int mii_write (struct net_device *dev, int phy_addr, int reg_num,\n\t\t      u16 data);\n\nstatic const struct ethtool_ops ethtool_ops;\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= rio_open,\n\t.ndo_start_xmit\t= start_xmit,\n\t.ndo_stop\t\t= rio_close,\n\t.ndo_get_stats\t\t= get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_set_rx_mode\t= set_multicast,\n\t.ndo_eth_ioctl\t\t= rio_ioctl,\n\t.ndo_tx_timeout\t\t= rio_tx_timeout,\n};\n\nstatic int\nrio_probe1 (struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct netdev_private *np;\n\tstatic int card_idx;\n\tint chip_idx = ent->driver_data;\n\tint err, irq;\n\tvoid __iomem *ioaddr;\n\tvoid *ring_space;\n\tdma_addr_t ring_dma;\n\n\terr = pci_enable_device (pdev);\n\tif (err)\n\t\treturn err;\n\n\tirq = pdev->irq;\n\terr = pci_request_regions (pdev, \"dl2k\");\n\tif (err)\n\t\tgoto err_out_disable;\n\n\tpci_set_master (pdev);\n\n\terr = -ENOMEM;\n\n\tdev = alloc_etherdev (sizeof (*np));\n\tif (!dev)\n\t\tgoto err_out_res;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tnp = netdev_priv(dev);\n\n\t \n\tioaddr = pci_iomap(pdev, 0, 0);\n\tif (!ioaddr)\n\t\tgoto err_out_dev;\n\tnp->eeprom_addr = ioaddr;\n\n#ifdef MEM_MAPPING\n\t \n\tioaddr = pci_iomap(pdev, 1, 0);\n\tif (!ioaddr)\n\t\tgoto err_out_iounmap;\n#endif\n\tnp->ioaddr = ioaddr;\n\tnp->chip_id = chip_idx;\n\tnp->pdev = pdev;\n\tspin_lock_init (&np->tx_lock);\n\tspin_lock_init (&np->rx_lock);\n\n\t \n\tnp->an_enable = 1;\n\tnp->tx_coalesce = 1;\n\tif (card_idx < MAX_UNITS) {\n\t\tif (media[card_idx] != NULL) {\n\t\t\tnp->an_enable = 0;\n\t\t\tif (strcmp (media[card_idx], \"auto\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"autosense\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"0\") == 0 ) {\n\t\t\t\tnp->an_enable = 2;\n\t\t\t} else if (strcmp (media[card_idx], \"100mbps_fd\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"4\") == 0) {\n\t\t\t\tnp->speed = 100;\n\t\t\t\tnp->full_duplex = 1;\n\t\t\t} else if (strcmp (media[card_idx], \"100mbps_hd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"3\") == 0) {\n\t\t\t\tnp->speed = 100;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else if (strcmp (media[card_idx], \"10mbps_fd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"2\") == 0) {\n\t\t\t\tnp->speed = 10;\n\t\t\t\tnp->full_duplex = 1;\n\t\t\t} else if (strcmp (media[card_idx], \"10mbps_hd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"1\") == 0) {\n\t\t\t\tnp->speed = 10;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else if (strcmp (media[card_idx], \"1000mbps_fd\") == 0 ||\n\t\t\t\t strcmp (media[card_idx], \"6\") == 0) {\n\t\t\t\tnp->speed=1000;\n\t\t\t\tnp->full_duplex=1;\n\t\t\t} else if (strcmp (media[card_idx], \"1000mbps_hd\") == 0 ||\n\t\t\t\t strcmp (media[card_idx], \"5\") == 0) {\n\t\t\t\tnp->speed = 1000;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else {\n\t\t\t\tnp->an_enable = 1;\n\t\t\t}\n\t\t}\n\t\tif (jumbo[card_idx] != 0) {\n\t\t\tnp->jumbo = 1;\n\t\t\tdev->mtu = MAX_JUMBO;\n\t\t} else {\n\t\t\tnp->jumbo = 0;\n\t\t\tif (mtu[card_idx] > 0 && mtu[card_idx] < PACKET_SIZE)\n\t\t\t\tdev->mtu = mtu[card_idx];\n\t\t}\n\t\tnp->vlan = (vlan[card_idx] > 0 && vlan[card_idx] < 4096) ?\n\t\t    vlan[card_idx] : 0;\n\t\tif (rx_coalesce > 0 && rx_timeout > 0) {\n\t\t\tnp->rx_coalesce = rx_coalesce;\n\t\t\tnp->rx_timeout = rx_timeout;\n\t\t\tnp->coalesce = 1;\n\t\t}\n\t\tnp->tx_flow = (tx_flow == 0) ? 0 : 1;\n\t\tnp->rx_flow = (rx_flow == 0) ? 0 : 1;\n\n\t\tif (tx_coalesce < 1)\n\t\t\ttx_coalesce = 1;\n\t\telse if (tx_coalesce > TX_RING_SIZE-1)\n\t\t\ttx_coalesce = TX_RING_SIZE - 1;\n\t}\n\tdev->netdev_ops = &netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tdev->ethtool_ops = &ethtool_ops;\n#if 0\n\tdev->features = NETIF_F_IP_CSUM;\n#endif\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = np->jumbo ? MAX_JUMBO : PACKET_SIZE;\n\n\tpci_set_drvdata (pdev, dev);\n\n\tring_space = dma_alloc_coherent(&pdev->dev, TX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_iounmap;\n\tnp->tx_ring = ring_space;\n\tnp->tx_ring_dma = ring_dma;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, RX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_unmap_tx;\n\tnp->rx_ring = ring_space;\n\tnp->rx_ring_dma = ring_dma;\n\n\t \n\tparse_eeprom (dev);\n\n\t \n\terr = find_miiphy (dev);\n\tif (err)\n\t\tgoto err_out_unmap_rx;\n\n\t \n\tnp->phy_media = (dr16(ASICCtrl) & PhyMedia) ? 1 : 0;\n\tnp->link_status = 0;\n\t \n\tif (np->phy_media) {\n\t\t \n\t \tif (np->an_enable == 2) {\n\t\t\tnp->an_enable = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (np->speed == 1000)\n\t\t\tnp->an_enable = 1;\n\t}\n\n\terr = register_netdev (dev);\n\tif (err)\n\t\tgoto err_out_unmap_rx;\n\n\tcard_idx++;\n\n\tprintk (KERN_INFO \"%s: %s, %pM, IRQ %d\\n\",\n\t\tdev->name, np->name, dev->dev_addr, irq);\n\tif (tx_coalesce > 1)\n\t\tprintk(KERN_INFO \"tx_coalesce:\\t%d packets\\n\",\n\t\t\t\ttx_coalesce);\n\tif (np->coalesce)\n\t\tprintk(KERN_INFO\n\t\t       \"rx_coalesce:\\t%d packets\\n\"\n\t\t       \"rx_timeout: \\t%d ns\\n\",\n\t\t\t\tnp->rx_coalesce, np->rx_timeout*640);\n\tif (np->vlan)\n\t\tprintk(KERN_INFO \"vlan(id):\\t%d\\n\", np->vlan);\n\treturn 0;\n\nerr_out_unmap_rx:\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t  np->rx_ring_dma);\nerr_out_unmap_tx:\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t  np->tx_ring_dma);\nerr_out_iounmap:\n#ifdef MEM_MAPPING\n\tpci_iounmap(pdev, np->ioaddr);\n#endif\n\tpci_iounmap(pdev, np->eeprom_addr);\nerr_out_dev:\n\tfree_netdev (dev);\nerr_out_res:\n\tpci_release_regions (pdev);\nerr_out_disable:\n\tpci_disable_device (pdev);\n\treturn err;\n}\n\nstatic int\nfind_miiphy (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i, phy_found = 0;\n\n\tnp->phy_addr = 1;\n\n\tfor (i = 31; i >= 0; i--) {\n\t\tint mii_status = mii_read (dev, i, 1);\n\t\tif (mii_status != 0xffff && mii_status != 0x0000) {\n\t\t\tnp->phy_addr = i;\n\t\t\tphy_found++;\n\t\t}\n\t}\n\tif (!phy_found) {\n\t\tprintk (KERN_ERR \"%s: No MII PHY found!\\n\", dev->name);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int\nparse_eeprom (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tint i, j;\n\tu8 sromdata[256];\n\tu8 *psib;\n\tu32 crc;\n\tPSROM_t psrom = (PSROM_t) sromdata;\n\n\tint cid, next;\n\n\tfor (i = 0; i < 128; i++)\n\t\t((__le16 *) sromdata)[i] = cpu_to_le16(read_eeprom(np, i));\n\n\tif (np->pdev->vendor == PCI_VENDOR_ID_DLINK) {\t \n\t\t \n\t\tcrc = ~ether_crc_le (256 - 4, sromdata);\n\t\tif (psrom->crc != cpu_to_le32(crc)) {\n\t\t\tprintk (KERN_ERR \"%s: EEPROM data CRC error.\\n\",\n\t\t\t\t\tdev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\teth_hw_addr_set(dev, psrom->mac_addr);\n\n\tif (np->chip_id == CHIP_IP1000A) {\n\t\tnp->led_mode = psrom->led_mode;\n\t\treturn 0;\n\t}\n\n\tif (np->pdev->vendor != PCI_VENDOR_ID_DLINK) {\n\t\treturn 0;\n\t}\n\n\t \n\ti = 0x30;\n\tpsib = (u8 *) sromdata;\n\tdo {\n\t\tcid = psib[i++];\n\t\tnext = psib[i++];\n\t\tif ((cid == 0 && next == 0) || (cid == 0xff && next == 0xff)) {\n\t\t\tprintk (KERN_ERR \"Cell data error\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tswitch (cid) {\n\t\tcase 0:\t \n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\treturn 0;\n\t\tcase 2:\t \n\t\t\tnp->duplex_polarity = psib[i];\n\t\t\tdw8(PhyCtrl, dr8(PhyCtrl) | psib[i]);\n\t\t\tbreak;\n\t\tcase 3:\t \n\t\t\tnp->wake_polarity = psib[i];\n\t\t\tbreak;\n\t\tcase 9:\t \n\t\t\tj = (next - i > 255) ? 255 : next - i;\n\t\t\tmemcpy (np->name, &(psib[i]), j);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 8:\t \n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\treturn -1;\n\t\t}\n\t\ti = next;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic void rio_set_led_mode(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tu32 mode;\n\n\tif (np->chip_id != CHIP_IP1000A)\n\t\treturn;\n\n\tmode = dr32(ASICCtrl);\n\tmode &= ~(IPG_AC_LED_MODE_BIT_1 | IPG_AC_LED_MODE | IPG_AC_LED_SPEED);\n\n\tif (np->led_mode & 0x01)\n\t\tmode |= IPG_AC_LED_MODE;\n\tif (np->led_mode & 0x02)\n\t\tmode |= IPG_AC_LED_MODE_BIT_1;\n\tif (np->led_mode & 0x08)\n\t\tmode |= IPG_AC_LED_SPEED;\n\n\tdw32(ASICCtrl, mode);\n}\n\nstatic inline dma_addr_t desc_to_dma(struct netdev_desc *desc)\n{\n\treturn le64_to_cpu(desc->fraginfo) & DMA_BIT_MASK(48);\n}\n\nstatic void free_list(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint i;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tskb = np->rx_skbuff[i];\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&np->pdev->dev,\n\t\t\t\t\t desc_to_dma(&np->rx_ring[i]),\n\t\t\t\t\t skb->len, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tnp->rx_skbuff[i] = NULL;\n\t\t}\n\t\tnp->rx_ring[i].status = 0;\n\t\tnp->rx_ring[i].fraginfo = 0;\n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tskb = np->tx_skbuff[i];\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&np->pdev->dev,\n\t\t\t\t\t desc_to_dma(&np->tx_ring[i]),\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tnp->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic void rio_reset_ring(struct netdev_private *np)\n{\n\tint i;\n\n\tnp->cur_rx = 0;\n\tnp->cur_tx = 0;\n\tnp->old_rx = 0;\n\tnp->old_tx = 0;\n\n\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\tnp->tx_ring[i].status = cpu_to_le64(TFDDone);\n\n\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\tnp->rx_ring[i].status = 0;\n}\n\n  \nstatic int alloc_list(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\trio_reset_ring(np);\n\tnp->rx_buf_sz = (dev->mtu <= 1500 ? PACKET_SIZE : dev->mtu + 32);\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tnp->tx_skbuff[i] = NULL;\n\t\tnp->tx_ring[i].next_desc = cpu_to_le64(np->tx_ring_dma +\n\t\t\t\t\t      ((i + 1) % TX_RING_SIZE) *\n\t\t\t\t\t      sizeof(struct netdev_desc));\n\t}\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t \n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, np->rx_buf_sz);\n\t\tnp->rx_skbuff[i] = skb;\n\t\tif (!skb) {\n\t\t\tfree_list(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnp->rx_ring[i].next_desc = cpu_to_le64(np->rx_ring_dma +\n\t\t\t\t\t\t((i + 1) % RX_RING_SIZE) *\n\t\t\t\t\t\tsizeof(struct netdev_desc));\n\t\t \n\t\tnp->rx_ring[i].fraginfo =\n\t\t    cpu_to_le64(dma_map_single(&np->pdev->dev, skb->data,\n\t\t\t\t\t       np->rx_buf_sz, DMA_FROM_DEVICE));\n\t\tnp->rx_ring[i].fraginfo |= cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t}\n\n\treturn 0;\n}\n\nstatic void rio_hw_init(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tint i;\n\tu16 macctrl;\n\n\t \n\tdw16(ASICCtrl + 2,\n\t     GlobalReset | DMAReset | FIFOReset | NetworkReset | HostReset);\n\tmdelay(10);\n\n\trio_set_led_mode(dev);\n\n\t \n\tdw32(DebugCtrl, dr32(DebugCtrl) | 0x0230);\n\n\tif (np->chip_id == CHIP_IP1000A &&\n\t    (np->pdev->revision == 0x40 || np->pdev->revision == 0x41)) {\n\t\t \n\t\tmii_write(dev, np->phy_addr, 31, 0x0001);\n\t\tmii_write(dev, np->phy_addr, 27, 0x01e0);\n\t\tmii_write(dev, np->phy_addr, 31, 0x0002);\n\t\tmii_write(dev, np->phy_addr, 27, 0xeb8e);\n\t\tmii_write(dev, np->phy_addr, 31, 0x0000);\n\t\tmii_write(dev, np->phy_addr, 30, 0x005e);\n\t\t \n\t\tmii_write(dev, np->phy_addr, MII_CTRL1000, 0x0700);\n\t}\n\n\tif (np->phy_media)\n\t\tmii_set_media_pcs(dev);\n\telse\n\t\tmii_set_media(dev);\n\n\t \n\tif (np->jumbo != 0)\n\t\tdw16(MaxFrameSize, MAX_JUMBO+14);\n\n\t \n\tdw32(RFDListPtr0, np->rx_ring_dma);\n\tdw32(RFDListPtr1, 0);\n\n\t \n\t \n\tfor (i = 0; i < 3; i++)\n\t\tdw16(StationAddr0 + 2 * i,\n\t\t     cpu_to_le16(((const u16 *)dev->dev_addr)[i]));\n\n\tset_multicast (dev);\n\tif (np->coalesce) {\n\t\tdw32(RxDMAIntCtrl, np->rx_coalesce | np->rx_timeout << 16);\n\t}\n\t \n\tdw8(RxDMAPollPeriod, 0x20);\n\tdw8(TxDMAPollPeriod, 0xff);\n\tdw8(RxDMABurstThresh, 0x30);\n\tdw8(RxDMAUrgentThresh, 0x30);\n\tdw32(RmonStatMask, 0x0007ffff);\n\t \n\tclear_stats (dev);\n\n\t \n\tif (np->vlan) {\n\t\t \n\t\tdw32(RxDMAIntCtrl, dr32(RxDMAIntCtrl) | 0x7 << 10);\n\t\t \n\t\tdw16(VLANId, np->vlan);\n\t\t \n\t\tdw32(VLANTag, 0x8100 << 16 | np->vlan);\n\t\t \n\t\tdw32(MACCtrl, dr32(MACCtrl) | AutoVLANuntagging);\n\t}\n\n\t \n\tdw32(MACCtrl, dr32(MACCtrl) | StatsEnable | RxEnable | TxEnable);\n\n\tmacctrl = 0;\n\tmacctrl |= (np->vlan) ? AutoVLANuntagging : 0;\n\tmacctrl |= (np->full_duplex) ? DuplexSelect : 0;\n\tmacctrl |= (np->tx_flow) ? TxFlowControlEnable : 0;\n\tmacctrl |= (np->rx_flow) ? RxFlowControlEnable : 0;\n\tdw16(MACCtrl, macctrl);\n}\n\nstatic void rio_hw_stop(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\n\t \n\tdw16(IntEnable, 0);\n\n\t \n\tdw32(MACCtrl, TxDisable | RxDisable | StatsDisable);\n}\n\nstatic int rio_open(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tconst int irq = np->pdev->irq;\n\tint i;\n\n\ti = alloc_list(dev);\n\tif (i)\n\t\treturn i;\n\n\trio_hw_init(dev);\n\n\ti = request_irq(irq, rio_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (i) {\n\t\trio_hw_stop(dev);\n\t\tfree_list(dev);\n\t\treturn i;\n\t}\n\n\ttimer_setup(&np->timer, rio_timer, 0);\n\tnp->timer.expires = jiffies + 1 * HZ;\n\tadd_timer(&np->timer);\n\n\tnetif_start_queue (dev);\n\n\tdl2k_enable_int(np);\n\treturn 0;\n}\n\nstatic void\nrio_timer (struct timer_list *t)\n{\n\tstruct netdev_private *np = from_timer(np, t, timer);\n\tstruct net_device *dev = pci_get_drvdata(np->pdev);\n\tunsigned int entry;\n\tint next_tick = 1*HZ;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&np->rx_lock, flags);\n\t \n\tif (np->cur_rx - np->old_rx >= RX_RING_SIZE) {\n\t\tprintk(KERN_INFO \"Try to recover rx ring exhausted...\\n\");\n\t\t \n\t\tfor (; np->cur_rx - np->old_rx > 0; np->old_rx++) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tentry = np->old_rx % RX_RING_SIZE;\n\t\t\t \n\t\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\t\tskb = netdev_alloc_skb_ip_align(dev,\n\t\t\t\t\t\t\t\tnp->rx_buf_sz);\n\t\t\t\tif (skb == NULL) {\n\t\t\t\t\tnp->rx_ring[entry].fraginfo = 0;\n\t\t\t\t\tprintk (KERN_INFO\n\t\t\t\t\t\t\"%s: Still unable to re-allocate Rx skbuff.#%d\\n\",\n\t\t\t\t\t\tdev->name, entry);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\t\tnp->rx_ring[entry].fraginfo =\n\t\t\t\t    cpu_to_le64 (dma_map_single(&np->pdev->dev, skb->data,\n\t\t\t\t\t\t\t\tnp->rx_buf_sz, DMA_FROM_DEVICE));\n\t\t\t}\n\t\t\tnp->rx_ring[entry].fraginfo |=\n\t\t\t    cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t\t\tnp->rx_ring[entry].status = 0;\n\t\t}  \n\t}  \n\tspin_unlock_irqrestore (&np->rx_lock, flags);\n\tnp->timer.expires = jiffies + next_tick;\n\tadd_timer(&np->timer);\n}\n\nstatic void\nrio_tx_timeout (struct net_device *dev, unsigned int txqueue)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\n\tprintk (KERN_INFO \"%s: Tx timed out (%4.4x), is buffer full?\\n\",\n\t\tdev->name, dr32(TxStatus));\n\trio_free_tx(dev, 0);\n\tdev->if_port = 0;\n\tnetif_trans_update(dev);  \n}\n\nstatic netdev_tx_t\nstart_xmit (struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tstruct netdev_desc *txdesc;\n\tunsigned entry;\n\tu64 tfc_vlan_tag = 0;\n\n\tif (np->link_status == 0) {\t \n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tentry = np->cur_tx % TX_RING_SIZE;\n\tnp->tx_skbuff[entry] = skb;\n\ttxdesc = &np->tx_ring[entry];\n\n#if 0\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttxdesc->status |=\n\t\t    cpu_to_le64 (TCPChecksumEnable | UDPChecksumEnable |\n\t\t\t\t IPChecksumEnable);\n\t}\n#endif\n\tif (np->vlan) {\n\t\ttfc_vlan_tag = VLANTagInsert |\n\t\t    ((u64)np->vlan << 32) |\n\t\t    ((u64)skb->priority << 45);\n\t}\n\ttxdesc->fraginfo = cpu_to_le64 (dma_map_single(&np->pdev->dev, skb->data,\n\t\t\t\t\t\t       skb->len, DMA_TO_DEVICE));\n\ttxdesc->fraginfo |= cpu_to_le64((u64)skb->len << 48);\n\n\t \n\tif (entry % np->tx_coalesce == 0 || np->speed == 10)\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      TxDMAIndicate |\n\t\t\t\t\t      (1 << FragCountShift));\n\telse\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      (1 << FragCountShift));\n\n\t \n\tdw32(DMACtrl, dr32(DMACtrl) | 0x00001000);\n\t \n\tdw32(CountDown, 10000);\n\tnp->cur_tx = (np->cur_tx + 1) % TX_RING_SIZE;\n\tif ((np->cur_tx - np->old_tx + TX_RING_SIZE) % TX_RING_SIZE\n\t\t\t< TX_QUEUE_LEN - 1 && np->speed != 10) {\n\t\t \n\t} else if (!netif_queue_stopped(dev)) {\n\t\tnetif_stop_queue (dev);\n\t}\n\n\t \n\tif (!dr32(TFDListPtr0)) {\n\t\tdw32(TFDListPtr0, np->tx_ring_dma +\n\t\t     entry * sizeof (struct netdev_desc));\n\t\tdw32(TFDListPtr1, 0);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic irqreturn_t\nrio_interrupt (int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tunsigned int_status;\n\tint cnt = max_intrloop;\n\tint handled = 0;\n\n\twhile (1) {\n\t\tint_status = dr16(IntStatus);\n\t\tdw16(IntStatus, int_status);\n\t\tint_status &= DEFAULT_INTR;\n\t\tif (int_status == 0 || --cnt < 0)\n\t\t\tbreak;\n\t\thandled = 1;\n\t\t \n\t\tif (int_status & RxDMAComplete)\n\t\t\treceive_packet (dev);\n\t\t \n\t\tif ((int_status & (TxDMAComplete|IntRequested))) {\n\t\t\tint tx_status;\n\t\t\ttx_status = dr32(TxStatus);\n\t\t\tif (tx_status & 0x01)\n\t\t\t\ttx_error (dev, tx_status);\n\t\t\t \n\t\t\trio_free_tx (dev, 1);\n\t\t}\n\n\t\t \n\t\tif (int_status &\n\t\t    (HostError | LinkEvent | UpdateStats))\n\t\t\trio_error (dev, int_status);\n\t}\n\tif (np->cur_tx != np->old_tx)\n\t\tdw32(CountDown, 100);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void\nrio_free_tx (struct net_device *dev, int irq)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->old_tx % TX_RING_SIZE;\n\tunsigned long flag = 0;\n\n\tif (irq)\n\t\tspin_lock(&np->tx_lock);\n\telse\n\t\tspin_lock_irqsave(&np->tx_lock, flag);\n\n\t \n\twhile (entry != np->cur_tx) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (!(np->tx_ring[entry].status & cpu_to_le64(TFDDone)))\n\t\t\tbreak;\n\t\tskb = np->tx_skbuff[entry];\n\t\tdma_unmap_single(&np->pdev->dev,\n\t\t\t\t desc_to_dma(&np->tx_ring[entry]), skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (irq)\n\t\t\tdev_consume_skb_irq(skb);\n\t\telse\n\t\t\tdev_kfree_skb(skb);\n\n\t\tnp->tx_skbuff[entry] = NULL;\n\t\tentry = (entry + 1) % TX_RING_SIZE;\n\t}\n\tif (irq)\n\t\tspin_unlock(&np->tx_lock);\n\telse\n\t\tspin_unlock_irqrestore(&np->tx_lock, flag);\n\tnp->old_tx = entry;\n\n\t \n\n\tif (netif_queue_stopped(dev) &&\n\t    ((np->cur_tx - np->old_tx + TX_RING_SIZE) % TX_RING_SIZE\n\t    < TX_QUEUE_LEN - 1 || np->speed == 10)) {\n\t\tnetif_wake_queue (dev);\n\t}\n}\n\nstatic void\ntx_error (struct net_device *dev, int tx_status)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tint frame_id;\n\tint i;\n\n\tframe_id = (tx_status & 0xffff0000);\n\tprintk (KERN_ERR \"%s: Transmit error, TxStatus %4.4x, FrameId %d.\\n\",\n\t\tdev->name, tx_status, frame_id);\n\tdev->stats.tx_errors++;\n\t \n\tif (tx_status & 0x10) {\n\t\tdev->stats.tx_fifo_errors++;\n\t\tdw16(TxStartThresh, dr16(TxStartThresh) + 0x10);\n\t\t \n\t\tdw16(ASICCtrl + 2,\n\t\t     TxReset | DMAReset | FIFOReset | NetworkReset);\n\t\t \n\t\tfor (i = 50; i > 0; i--) {\n\t\t\tif (!(dr16(ASICCtrl + 2) & ResetBusy))\n\t\t\t\tbreak;\n\t\t\tmdelay (1);\n\t\t}\n\t\trio_set_led_mode(dev);\n\t\trio_free_tx (dev, 1);\n\t\t \n\t\tdw32(TFDListPtr0, np->tx_ring_dma +\n\t\t     np->old_tx * sizeof (struct netdev_desc));\n\t\tdw32(TFDListPtr1, 0);\n\n\t\t \n\t}\n\t \n\tif (tx_status & 0x04) {\n\t\tdev->stats.tx_fifo_errors++;\n\t\t \n\t\tdw16(ASICCtrl + 2, TxReset | FIFOReset);\n\t\t \n\t\tfor (i = 50; i > 0; i--) {\n\t\t\tif (!(dr16(ASICCtrl + 2) & ResetBusy))\n\t\t\t\tbreak;\n\t\t\tmdelay (1);\n\t\t}\n\t\trio_set_led_mode(dev);\n\t\t \n\t}\n\t \n\tif (tx_status & 0x08)\n\t\tdev->stats.collisions++;\n\t \n\tdw32(MACCtrl, dr16(MACCtrl) | TxEnable);\n}\n\nstatic int\nreceive_packet (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->cur_rx % RX_RING_SIZE;\n\tint cnt = 30;\n\n\t \n\twhile (1) {\n\t\tstruct netdev_desc *desc = &np->rx_ring[entry];\n\t\tint pkt_len;\n\t\tu64 frame_status;\n\n\t\tif (!(desc->status & cpu_to_le64(RFDDone)) ||\n\t\t    !(desc->status & cpu_to_le64(FrameStart)) ||\n\t\t    !(desc->status & cpu_to_le64(FrameEnd)))\n\t\t\tbreak;\n\n\t\t \n\t\tframe_status = le64_to_cpu(desc->status);\n\t\tpkt_len = frame_status & 0xffff;\n\t\tif (--cnt < 0)\n\t\t\tbreak;\n\t\t \n\t\tif (frame_status & RFS_Errors) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (frame_status & (RxRuntFrame | RxLengthError))\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (frame_status & RxFCSError)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (frame_status & RxAlignmentError && np->speed != 1000)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (frame_status & RxFIFOOverrun)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\t \n\t\t\tif (pkt_len > copy_thresh) {\n\t\t\t\tdma_unmap_single(&np->pdev->dev,\n\t\t\t\t\t\t desc_to_dma(desc),\n\t\t\t\t\t\t np->rx_buf_sz,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put (skb = np->rx_skbuff[entry], pkt_len);\n\t\t\t\tnp->rx_skbuff[entry] = NULL;\n\t\t\t} else if ((skb = netdev_alloc_skb_ip_align(dev, pkt_len))) {\n\t\t\t\tdma_sync_single_for_cpu(&np->pdev->dev,\n\t\t\t\t\t\t\tdesc_to_dma(desc),\n\t\t\t\t\t\t\tnp->rx_buf_sz,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tskb_copy_to_linear_data (skb,\n\t\t\t\t\t\t  np->rx_skbuff[entry]->data,\n\t\t\t\t\t\t  pkt_len);\n\t\t\t\tskb_put (skb, pkt_len);\n\t\t\t\tdma_sync_single_for_device(&np->pdev->dev,\n\t\t\t\t\t\t\t   desc_to_dma(desc),\n\t\t\t\t\t\t\t   np->rx_buf_sz,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans (skb, dev);\n#if 0\n\t\t\t \n\t\t\tif (np->pdev->pci_rev_id >= 0x0c &&\n\t\t\t\t!(frame_status & (TCPError | UDPError | IPError))) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t}\n#endif\n\t\t\tnetif_rx (skb);\n\t\t}\n\t\tentry = (entry + 1) % RX_RING_SIZE;\n\t}\n\tspin_lock(&np->rx_lock);\n\tnp->cur_rx = entry;\n\t \n\tentry = np->old_rx;\n\twhile (entry != np->cur_rx) {\n\t\tstruct sk_buff *skb;\n\t\t \n\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\tskb = netdev_alloc_skb_ip_align(dev, np->rx_buf_sz);\n\t\t\tif (skb == NULL) {\n\t\t\t\tnp->rx_ring[entry].fraginfo = 0;\n\t\t\t\tprintk (KERN_INFO\n\t\t\t\t\t\"%s: receive_packet: \"\n\t\t\t\t\t\"Unable to re-allocate Rx skbuff.#%d\\n\",\n\t\t\t\t\tdev->name, entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\tnp->rx_ring[entry].fraginfo =\n\t\t\t    cpu_to_le64(dma_map_single(&np->pdev->dev, skb->data,\n\t\t\t\t\t\t       np->rx_buf_sz, DMA_FROM_DEVICE));\n\t\t}\n\t\tnp->rx_ring[entry].fraginfo |=\n\t\t    cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t\tnp->rx_ring[entry].status = 0;\n\t\tentry = (entry + 1) % RX_RING_SIZE;\n\t}\n\tnp->old_rx = entry;\n\tspin_unlock(&np->rx_lock);\n\treturn 0;\n}\n\nstatic void\nrio_error (struct net_device *dev, int int_status)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tu16 macctrl;\n\n\t \n\tif (int_status & LinkEvent) {\n\t\tif (mii_wait_link (dev, 10) == 0) {\n\t\t\tprintk (KERN_INFO \"%s: Link up\\n\", dev->name);\n\t\t\tif (np->phy_media)\n\t\t\t\tmii_get_media_pcs (dev);\n\t\t\telse\n\t\t\t\tmii_get_media (dev);\n\t\t\tif (np->speed == 1000)\n\t\t\t\tnp->tx_coalesce = tx_coalesce;\n\t\t\telse\n\t\t\t\tnp->tx_coalesce = 1;\n\t\t\tmacctrl = 0;\n\t\t\tmacctrl |= (np->vlan) ? AutoVLANuntagging : 0;\n\t\t\tmacctrl |= (np->full_duplex) ? DuplexSelect : 0;\n\t\t\tmacctrl |= (np->tx_flow) ?\n\t\t\t\tTxFlowControlEnable : 0;\n\t\t\tmacctrl |= (np->rx_flow) ?\n\t\t\t\tRxFlowControlEnable : 0;\n\t\t\tdw16(MACCtrl, macctrl);\n\t\t\tnp->link_status = 1;\n\t\t\tnetif_carrier_on(dev);\n\t\t} else {\n\t\t\tprintk (KERN_INFO \"%s: Link off\\n\", dev->name);\n\t\t\tnp->link_status = 0;\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t}\n\n\t \n\tif (int_status & UpdateStats) {\n\t\tget_stats (dev);\n\t}\n\n\t \n\tif (int_status & HostError) {\n\t\tprintk (KERN_ERR \"%s: HostError! IntStatus %4.4x.\\n\",\n\t\t\tdev->name, int_status);\n\t\tdw16(ASICCtrl + 2, GlobalReset | HostReset);\n\t\tmdelay (500);\n\t\trio_set_led_mode(dev);\n\t}\n}\n\nstatic struct net_device_stats *\nget_stats (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n#ifdef MEM_MAPPING\n\tint i;\n#endif\n\tunsigned int stat_reg;\n\n\t \n\n\tdev->stats.rx_packets += dr32(FramesRcvOk);\n\tdev->stats.tx_packets += dr32(FramesXmtOk);\n\tdev->stats.rx_bytes += dr32(OctetRcvOk);\n\tdev->stats.tx_bytes += dr32(OctetXmtOk);\n\n\tdev->stats.multicast = dr32(McstFramesRcvdOk);\n\tdev->stats.collisions += dr32(SingleColFrames)\n\t\t\t     +  dr32(MultiColFrames);\n\n\t \n\tstat_reg = dr16(FramesAbortXSColls);\n\tdev->stats.tx_aborted_errors += stat_reg;\n\tdev->stats.tx_errors += stat_reg;\n\n\tstat_reg = dr16(CarrierSenseErrors);\n\tdev->stats.tx_carrier_errors += stat_reg;\n\tdev->stats.tx_errors += stat_reg;\n\n\t \n\tdr32(McstOctetXmtOk);\n\tdr16(BcstFramesXmtdOk);\n\tdr32(McstFramesXmtdOk);\n\tdr16(BcstFramesRcvdOk);\n\tdr16(MacControlFramesRcvd);\n\tdr16(FrameTooLongErrors);\n\tdr16(InRangeLengthErrors);\n\tdr16(FramesCheckSeqErrors);\n\tdr16(FramesLostRxErrors);\n\tdr32(McstOctetXmtOk);\n\tdr32(BcstOctetXmtOk);\n\tdr32(McstFramesXmtdOk);\n\tdr32(FramesWDeferredXmt);\n\tdr32(LateCollisions);\n\tdr16(BcstFramesXmtdOk);\n\tdr16(MacControlFramesXmtd);\n\tdr16(FramesWEXDeferal);\n\n#ifdef MEM_MAPPING\n\tfor (i = 0x100; i <= 0x150; i += 4)\n\t\tdr32(i);\n#endif\n\tdr16(TxJumboFrames);\n\tdr16(RxJumboFrames);\n\tdr16(TCPCheckSumErrors);\n\tdr16(UDPCheckSumErrors);\n\tdr16(IPCheckSumErrors);\n\treturn &dev->stats;\n}\n\nstatic int\nclear_stats (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n#ifdef MEM_MAPPING\n\tint i;\n#endif\n\n\t \n\tdr32(FramesRcvOk);\n\tdr32(FramesXmtOk);\n\tdr32(OctetRcvOk);\n\tdr32(OctetXmtOk);\n\n\tdr32(McstFramesRcvdOk);\n\tdr32(SingleColFrames);\n\tdr32(MultiColFrames);\n\tdr32(LateCollisions);\n\t \n\tdr16(FrameTooLongErrors);\n\tdr16(InRangeLengthErrors);\n\tdr16(FramesCheckSeqErrors);\n\tdr16(FramesLostRxErrors);\n\n\t \n\tdr16(FramesAbortXSColls);\n\tdr16(CarrierSenseErrors);\n\n\t \n\tdr32(McstOctetXmtOk);\n\tdr16(BcstFramesXmtdOk);\n\tdr32(McstFramesXmtdOk);\n\tdr16(BcstFramesRcvdOk);\n\tdr16(MacControlFramesRcvd);\n\tdr32(McstOctetXmtOk);\n\tdr32(BcstOctetXmtOk);\n\tdr32(McstFramesXmtdOk);\n\tdr32(FramesWDeferredXmt);\n\tdr16(BcstFramesXmtdOk);\n\tdr16(MacControlFramesXmtd);\n\tdr16(FramesWEXDeferal);\n#ifdef MEM_MAPPING\n\tfor (i = 0x100; i <= 0x150; i += 4)\n\t\tdr32(i);\n#endif\n\tdr16(TxJumboFrames);\n\tdr16(RxJumboFrames);\n\tdr16(TCPCheckSumErrors);\n\tdr16(UDPCheckSumErrors);\n\tdr16(IPCheckSumErrors);\n\treturn 0;\n}\n\nstatic void\nset_multicast (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tu32 hash_table[2];\n\tu16 rx_mode = 0;\n\n\thash_table[0] = hash_table[1] = 0;\n\t \n\thash_table[1] |= 0x02000000;\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\trx_mode = ReceiveAllFrames;\n\t} else if ((dev->flags & IFF_ALLMULTI) ||\n\t\t\t(netdev_mc_count(dev) > multicast_filter_limit)) {\n\t\t \n\t\trx_mode = ReceiveBroadcast | ReceiveMulticast | ReceiveUnicast;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\t \n\t\trx_mode =\n\t\t    ReceiveBroadcast | ReceiveMulticastHash | ReceiveUnicast;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint bit, index = 0;\n\t\t\tint crc = ether_crc_le(ETH_ALEN, ha->addr);\n\t\t\t \n\t\t\tfor (bit = 0; bit < 6; bit++)\n\t\t\t\tif (crc & (1 << (31 - bit)))\n\t\t\t\t\tindex |= (1 << bit);\n\t\t\thash_table[index / 32] |= (1 << (index % 32));\n\t\t}\n\t} else {\n\t\trx_mode = ReceiveBroadcast | ReceiveUnicast;\n\t}\n\tif (np->vlan) {\n\t\t \n\t\trx_mode |= ReceiveVLANMatch;\n\t}\n\n\tdw32(HashTable0, hash_table[0]);\n\tdw32(HashTable1, hash_table[1]);\n\tdw16(ReceiveMode, rx_mode);\n}\n\nstatic void rio_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, \"dl2k\", sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(np->pdev), sizeof(info->bus_info));\n}\n\nstatic int rio_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu32 supported, advertising;\n\n\tif (np->phy_media) {\n\t\t \n\t\tsupported = SUPPORTED_Autoneg | SUPPORTED_FIBRE;\n\t\tadvertising = ADVERTISED_Autoneg | ADVERTISED_FIBRE;\n\t\tcmd->base.port = PORT_FIBRE;\n\t} else {\n\t\t \n\t\tsupported = SUPPORTED_10baseT_Half |\n\t\t\tSUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half\n\t\t\t| SUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Full |\n\t\t\tSUPPORTED_Autoneg | SUPPORTED_MII;\n\t\tadvertising = ADVERTISED_10baseT_Half |\n\t\t\tADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half |\n\t\t\tADVERTISED_100baseT_Full | ADVERTISED_1000baseT_Full |\n\t\t\tADVERTISED_Autoneg | ADVERTISED_MII;\n\t\tcmd->base.port = PORT_MII;\n\t}\n\tif (np->link_status) {\n\t\tcmd->base.speed = np->speed;\n\t\tcmd->base.duplex = np->full_duplex ? DUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\tif (np->an_enable)\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\tcmd->base.phy_address = np->phy_addr;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int rio_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu32 speed = cmd->base.speed;\n\tu8 duplex = cmd->base.duplex;\n\n\tnetif_carrier_off(dev);\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tif (np->an_enable) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tnp->an_enable = 1;\n\t\t\tmii_set_media(dev);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tnp->an_enable = 0;\n\t\tif (np->speed == 1000) {\n\t\t\tspeed = SPEED_100;\n\t\t\tduplex = DUPLEX_FULL;\n\t\t\tprintk(\"Warning!! Can't disable Auto negotiation in 1000Mbps, change to Manual 100Mbps, Full duplex.\\n\");\n\t\t}\n\t\tswitch (speed) {\n\t\tcase SPEED_10:\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = (duplex == DUPLEX_FULL);\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = (duplex == DUPLEX_FULL);\n\t\t\tbreak;\n\t\tcase SPEED_1000:  \n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmii_set_media(dev);\n\t}\n\treturn 0;\n}\n\nstatic u32 rio_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->link_status;\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.get_drvinfo = rio_get_drvinfo,\n\t.get_link = rio_get_link,\n\t.get_link_ksettings = rio_get_link_ksettings,\n\t.set_link_ksettings = rio_set_link_ksettings,\n};\n\nstatic int\nrio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *miidata = if_mii(rq);\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmiidata->phy_id = phy_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n#define EEP_READ 0x0200\n#define EEP_BUSY 0x8000\n \n \nstatic int read_eeprom(struct netdev_private *np, int eep_addr)\n{\n\tvoid __iomem *ioaddr = np->eeprom_addr;\n\tint i = 1000;\n\n\tdw16(EepromCtrl, EEP_READ | (eep_addr & 0xff));\n\twhile (i-- > 0) {\n\t\tif (!(dr16(EepromCtrl) & EEP_BUSY))\n\t\t\treturn dr16(EepromData);\n\t}\n\treturn 0;\n}\n\nenum phy_ctrl_bits {\n\tMII_READ = 0x00, MII_CLK = 0x01, MII_DATA1 = 0x02, MII_WRITE = 0x04,\n\tMII_DUPLEX = 0x08,\n};\n\n#define mii_delay() dr8(PhyCtrl)\nstatic void\nmii_sendbit (struct net_device *dev, u32 data)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\n\tdata = ((data) ? MII_DATA1 : 0) | (dr8(PhyCtrl) & 0xf8) | MII_WRITE;\n\tdw8(PhyCtrl, data);\n\tmii_delay ();\n\tdw8(PhyCtrl, data | MII_CLK);\n\tmii_delay ();\n}\n\nstatic int\nmii_getbit (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tu8 data;\n\n\tdata = (dr8(PhyCtrl) & 0xf8) | MII_READ;\n\tdw8(PhyCtrl, data);\n\tmii_delay ();\n\tdw8(PhyCtrl, data | MII_CLK);\n\tmii_delay ();\n\treturn (dr8(PhyCtrl) >> 1) & 1;\n}\n\nstatic void\nmii_send_bits (struct net_device *dev, u32 data, int len)\n{\n\tint i;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tmii_sendbit (dev, data & (1 << i));\n\t}\n}\n\nstatic int\nmii_read (struct net_device *dev, int phy_addr, int reg_num)\n{\n\tu32 cmd;\n\tint i;\n\tu32 retval = 0;\n\n\t \n\tmii_send_bits (dev, 0xffffffff, 32);\n\t \n\t \n\tcmd = (0x06 << 10 | phy_addr << 5 | reg_num);\n\tmii_send_bits (dev, cmd, 14);\n\t \n\tif (mii_getbit (dev))\n\t\tgoto err_out;\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tretval |= mii_getbit (dev);\n\t\tretval <<= 1;\n\t}\n\t \n\tmii_getbit (dev);\n\treturn (retval >> 1) & 0xffff;\n\n      err_out:\n\treturn 0;\n}\nstatic int\nmii_write (struct net_device *dev, int phy_addr, int reg_num, u16 data)\n{\n\tu32 cmd;\n\n\t \n\tmii_send_bits (dev, 0xffffffff, 32);\n\t \n\t \n\tcmd = (0x5002 << 16) | (phy_addr << 23) | (reg_num << 18) | data;\n\tmii_send_bits (dev, cmd, 32);\n\t \n\tmii_getbit (dev);\n\treturn 0;\n}\nstatic int\nmii_wait_link (struct net_device *dev, int wait)\n{\n\t__u16 bmsr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tdo {\n\t\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\t\tif (bmsr & BMSR_LSTATUS)\n\t\t\treturn 0;\n\t\tmdelay (1);\n\t} while (--wait > 0);\n\treturn -1;\n}\nstatic int\nmii_get_media (struct net_device *dev)\n{\n\t__u16 negotiate;\n\t__u16 bmsr;\n\t__u16 mscr;\n\t__u16 mssr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\tif (np->an_enable) {\n\t\tif (!(bmsr & BMSR_ANEGCOMPLETE)) {\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t\tnegotiate = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\tmii_read (dev, phy_addr, MII_LPA);\n\t\tmscr = mii_read (dev, phy_addr, MII_CTRL1000);\n\t\tmssr = mii_read (dev, phy_addr, MII_STAT1000);\n\t\tif (mscr & ADVERTISE_1000FULL && mssr & LPA_1000FULL) {\n\t\t\tnp->speed = 1000;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Full duplex\\n\");\n\t\t} else if (mscr & ADVERTISE_1000HALF && mssr & LPA_1000HALF) {\n\t\t\tnp->speed = 1000;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Half duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_100FULL) {\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 100 Mbps, Full duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_100HALF) {\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 100 Mbps, Half duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_10FULL) {\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 10 Mbps, Full duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_10HALF) {\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 10 Mbps, Half duplex\\n\");\n\t\t}\n\t\tif (negotiate & ADVERTISE_PAUSE_CAP) {\n\t\t\tnp->tx_flow &= 1;\n\t\t\tnp->rx_flow &= 1;\n\t\t} else if (negotiate & ADVERTISE_PAUSE_ASYM) {\n\t\t\tnp->tx_flow = 0;\n\t\t\tnp->rx_flow &= 1;\n\t\t}\n\t\t \n\t} else {\n\t\t__u16 bmcr = mii_read (dev, phy_addr, MII_BMCR);\n\t\tswitch (bmcr & (BMCR_SPEED100 | BMCR_SPEED1000)) {\n\t\tcase BMCR_SPEED1000:\n\t\t\tprintk (KERN_INFO \"Operating at 1000 Mbps, \");\n\t\t\tbreak;\n\t\tcase BMCR_SPEED100:\n\t\t\tprintk (KERN_INFO \"Operating at 100 Mbps, \");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintk (KERN_INFO \"Operating at 10 Mbps, \");\n\t\t}\n\t\tif (bmcr & BMCR_FULLDPLX) {\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n\t}\n\tif (np->tx_flow)\n\t\tprintk(KERN_INFO \"Enable Tx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Tx Flow Control\\n\");\n\tif (np->rx_flow)\n\t\tprintk(KERN_INFO \"Enable Rx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Rx Flow Control\\n\");\n\n\treturn 0;\n}\n\nstatic int\nmii_set_media (struct net_device *dev)\n{\n\t__u16 pscr;\n\t__u16 bmcr;\n\t__u16 bmsr;\n\t__u16 anar;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\t \n\tif (np->an_enable) {\n\t\t \n\t\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\t\tanar = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\t~(ADVERTISE_100FULL | ADVERTISE_10FULL |\n\t\t\t  ADVERTISE_100HALF | ADVERTISE_10HALF |\n\t\t\t  ADVERTISE_100BASE4);\n\t\tif (bmsr & BMSR_100FULL)\n\t\t\tanar |= ADVERTISE_100FULL;\n\t\tif (bmsr & BMSR_100HALF)\n\t\t\tanar |= ADVERTISE_100HALF;\n\t\tif (bmsr & BMSR_100BASE4)\n\t\t\tanar |= ADVERTISE_100BASE4;\n\t\tif (bmsr & BMSR_10FULL)\n\t\t\tanar |= ADVERTISE_10FULL;\n\t\tif (bmsr & BMSR_10HALF)\n\t\t\tanar |= ADVERTISE_10HALF;\n\t\tanar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, anar);\n\n\t\t \n\t\tpscr = mii_read (dev, phy_addr, MII_PHY_SCR);\n\t\tpscr |= 3 << 5;\t \n\t\tmii_write (dev, phy_addr, MII_PHY_SCR, pscr);\n\n\t\t \n\t\tmii_write (dev, phy_addr, MII_BMCR, BMCR_RESET);\n\t\tbmcr = BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(1);\n\t} else {\n\t\t \n\t\t \n\t\tpscr = mii_read (dev, phy_addr, MII_PHY_SCR);\n\t\tpscr &= ~(3 << 5);\n\t\tmii_write (dev, phy_addr, MII_PHY_SCR, pscr);\n\n\t\t \n\t\tbmcr = mii_read (dev, phy_addr, MII_BMCR);\n\t\tbmcr |= BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\n\t\t \n\t\tbmcr = 0x1940;\t \n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay (100);\t \n\n\t\t \n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, 0);\n\n\t\t \n\t\tbmcr = BMCR_PDOWN;\n\t\tif (np->speed == 100) {\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\t\tprintk (KERN_INFO \"Manual 100 Mbps, \");\n\t\t} else if (np->speed == 10) {\n\t\t\tprintk (KERN_INFO \"Manual 10 Mbps, \");\n\t\t}\n\t\tif (np->full_duplex) {\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n#if 0\n\t\t \n\t\tmscr = mii_read (dev, phy_addr, MII_CTRL1000);\n\t\tmscr |= MII_MSCR_CFG_ENABLE;\n\t\tmscr &= ~MII_MSCR_CFG_VALUE = 0;\n#endif\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\t}\n\treturn 0;\n}\n\nstatic int\nmii_get_media_pcs (struct net_device *dev)\n{\n\t__u16 negotiate;\n\t__u16 bmsr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tbmsr = mii_read (dev, phy_addr, PCS_BMSR);\n\tif (np->an_enable) {\n\t\tif (!(bmsr & BMSR_ANEGCOMPLETE)) {\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t\tnegotiate = mii_read (dev, phy_addr, PCS_ANAR) &\n\t\t\tmii_read (dev, phy_addr, PCS_ANLPAR);\n\t\tnp->speed = 1000;\n\t\tif (negotiate & PCS_ANAR_FULL_DUPLEX) {\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Full duplex\\n\");\n\t\t\tnp->full_duplex = 1;\n\t\t} else {\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, half duplex\\n\");\n\t\t\tnp->full_duplex = 0;\n\t\t}\n\t\tif (negotiate & PCS_ANAR_PAUSE) {\n\t\t\tnp->tx_flow &= 1;\n\t\t\tnp->rx_flow &= 1;\n\t\t} else if (negotiate & PCS_ANAR_ASYMMETRIC) {\n\t\t\tnp->tx_flow = 0;\n\t\t\tnp->rx_flow &= 1;\n\t\t}\n\t\t \n\t} else {\n\t\t__u16 bmcr = mii_read (dev, phy_addr, PCS_BMCR);\n\t\tprintk (KERN_INFO \"Operating at 1000 Mbps, \");\n\t\tif (bmcr & BMCR_FULLDPLX) {\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n\t}\n\tif (np->tx_flow)\n\t\tprintk(KERN_INFO \"Enable Tx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Tx Flow Control\\n\");\n\tif (np->rx_flow)\n\t\tprintk(KERN_INFO \"Enable Rx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Rx Flow Control\\n\");\n\n\treturn 0;\n}\n\nstatic int\nmii_set_media_pcs (struct net_device *dev)\n{\n\t__u16 bmcr;\n\t__u16 esr;\n\t__u16 anar;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\t \n\tif (np->an_enable) {\n\t\t \n\t\tesr = mii_read (dev, phy_addr, PCS_ESR);\n\t\tanar = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\t~PCS_ANAR_HALF_DUPLEX &\n\t\t\t~PCS_ANAR_FULL_DUPLEX;\n\t\tif (esr & (MII_ESR_1000BT_HD | MII_ESR_1000BX_HD))\n\t\t\tanar |= PCS_ANAR_HALF_DUPLEX;\n\t\tif (esr & (MII_ESR_1000BT_FD | MII_ESR_1000BX_FD))\n\t\t\tanar |= PCS_ANAR_FULL_DUPLEX;\n\t\tanar |= PCS_ANAR_PAUSE | PCS_ANAR_ASYMMETRIC;\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, anar);\n\n\t\t \n\t\tmii_write (dev, phy_addr, MII_BMCR, BMCR_RESET);\n\t\tbmcr = BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(1);\n\t} else {\n\t\t \n\t\t \n\t\tbmcr = BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\t\tif (np->full_duplex) {\n\t\t\tbmcr = BMCR_FULLDPLX;\n\t\t\tprintk (KERN_INFO \"Manual full duplex\\n\");\n\t\t} else {\n\t\t\tbmcr = 0;\n\t\t\tprintk (KERN_INFO \"Manual half duplex\\n\");\n\t\t}\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\n\t\t \n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, 0);\n\t}\n\treturn 0;\n}\n\n\nstatic int\nrio_close (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct pci_dev *pdev = np->pdev;\n\n\tnetif_stop_queue (dev);\n\n\trio_hw_stop(dev);\n\n\tfree_irq(pdev->irq, dev);\n\tdel_timer_sync (&np->timer);\n\n\tfree_list(dev);\n\n\treturn 0;\n}\n\nstatic void\nrio_remove1 (struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata (pdev);\n\n\tif (dev) {\n\t\tstruct netdev_private *np = netdev_priv(dev);\n\n\t\tunregister_netdev (dev);\n\t\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t\t  np->rx_ring_dma);\n\t\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t\t  np->tx_ring_dma);\n#ifdef MEM_MAPPING\n\t\tpci_iounmap(pdev, np->ioaddr);\n#endif\n\t\tpci_iounmap(pdev, np->eeprom_addr);\n\t\tfree_netdev (dev);\n\t\tpci_release_regions (pdev);\n\t\tpci_disable_device (pdev);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rio_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tnetif_device_detach(dev);\n\tdel_timer_sync(&np->timer);\n\trio_hw_stop(dev);\n\n\treturn 0;\n}\n\nstatic int rio_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\trio_reset_ring(np);\n\trio_hw_init(dev);\n\tnp->timer.expires = jiffies + 1 * HZ;\n\tadd_timer(&np->timer);\n\tnetif_device_attach(dev);\n\tdl2k_enable_int(np);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rio_pm_ops, rio_suspend, rio_resume);\n#define RIO_PM_OPS    (&rio_pm_ops)\n\n#else\n\n#define RIO_PM_OPS\tNULL\n\n#endif  \n\nstatic struct pci_driver rio_driver = {\n\t.name\t\t= \"dl2k\",\n\t.id_table\t= rio_pci_tbl,\n\t.probe\t\t= rio_probe1,\n\t.remove\t\t= rio_remove1,\n\t.driver.pm\t= RIO_PM_OPS,\n};\n\nmodule_pci_driver(rio_driver);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}