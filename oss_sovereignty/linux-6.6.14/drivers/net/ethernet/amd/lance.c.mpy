{
  "module_name": "lance.c",
  "hash_id": "aa307fdf2e1152b98bf25041faadbdc3eed37ffd407bcedb244f26444373d179",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/lance.c",
  "human_readable_source": " \n \n\nstatic const char version[] = \"lance.c:v1.16 2006/11/09 dplatt@3do.com, becker@cesdis.gsfc.nasa.gov\\n\";\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n#include <linux/bitops.h>\n#include <net/Space.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\nstatic unsigned int lance_portlist[] __initdata = { 0x300, 0x320, 0x340, 0x360, 0};\nstatic int lance_probe1(struct net_device *dev, int ioaddr, int irq, int options);\nstatic int __init do_lance_probe(struct net_device *dev);\n\n\nstatic struct card {\n\tchar id_offset14;\n\tchar id_offset15;\n} cards[] = {\n\t{\t\n\t\t.id_offset14 = 0x57,\n\t\t.id_offset15 = 0x57,\n\t},\n\t{\t\n\t\t.id_offset14 = 0x52,\n\t\t.id_offset15 = 0x44,\n\t},\n\t{\t\n\t\t.id_offset14 = 0x52,\n\t\t.id_offset15 = 0x49,\n\t},\n};\n#define NUM_CARDS 3\n\n#ifdef LANCE_DEBUG\nstatic int lance_debug = LANCE_DEBUG;\n#else\nstatic int lance_debug = 1;\n#endif\n\n \n\n \n#ifndef LANCE_LOG_TX_BUFFERS\n#define LANCE_LOG_TX_BUFFERS 4\n#define LANCE_LOG_RX_BUFFERS 4\n#endif\n\n#define TX_RING_SIZE\t\t\t(1 << (LANCE_LOG_TX_BUFFERS))\n#define TX_RING_MOD_MASK\t\t(TX_RING_SIZE - 1)\n#define TX_RING_LEN_BITS\t\t((LANCE_LOG_TX_BUFFERS) << 29)\n\n#define RX_RING_SIZE\t\t\t(1 << (LANCE_LOG_RX_BUFFERS))\n#define RX_RING_MOD_MASK\t\t(RX_RING_SIZE - 1)\n#define RX_RING_LEN_BITS\t\t((LANCE_LOG_RX_BUFFERS) << 29)\n\n#define PKT_BUF_SZ\t\t1544\n\n \n#define LANCE_DATA 0x10\n#define LANCE_ADDR 0x12\n#define LANCE_RESET 0x14\n#define LANCE_BUS_IF 0x16\n#define LANCE_TOTAL_SIZE 0x18\n\n#define TX_TIMEOUT\t(HZ/5)\n\n \nstruct lance_rx_head {\n\ts32 base;\n\ts16 buf_length;\t\t\t \n\ts16 msg_length;\t\t\t \n};\n\nstruct lance_tx_head {\n\ts32 base;\n\ts16 length;\t\t\t\t \n\ts16 misc;\n};\n\n \nstruct lance_init_block {\n\tu16 mode;\t\t \n\tu8  phys_addr[6];  \n\tu32 filter[2];\t\t\t \n\t \n\tu32  rx_ring;\t\t\t \n\tu32  tx_ring;\n};\n\nstruct lance_private {\n\t \n\tstruct lance_rx_head rx_ring[RX_RING_SIZE];\n\tstruct lance_tx_head tx_ring[TX_RING_SIZE];\n\tstruct lance_init_block\tinit_block;\n\tconst char *name;\n\t \n\tstruct sk_buff* tx_skbuff[TX_RING_SIZE];\n\t \n\tstruct sk_buff* rx_skbuff[RX_RING_SIZE];\n\tunsigned long rx_buffs;\t\t \n\t \n\tchar (*tx_bounce_buffs)[PKT_BUF_SZ];\n\tint cur_rx, cur_tx;\t\t\t \n\tint dirty_rx, dirty_tx;\t\t \n\tint dma;\n\tunsigned char chip_version;\t \n\tspinlock_t devlock;\n};\n\n#define LANCE_MUST_PAD          0x00000001\n#define LANCE_ENABLE_AUTOSELECT 0x00000002\n#define LANCE_MUST_REINIT_RING  0x00000004\n#define LANCE_MUST_UNRESET      0x00000008\n#define LANCE_HAS_MISSED_FRAME  0x00000010\n\n \nstatic struct lance_chip_type {\n\tint id_number;\n\tconst char *name;\n\tint flags;\n} chip_table[] = {\n\t{0x0000, \"LANCE 7990\",\t\t\t\t \n\t\tLANCE_MUST_PAD + LANCE_MUST_UNRESET},\n\t{0x0003, \"PCnet/ISA 79C960\",\t\t \n\t\tLANCE_ENABLE_AUTOSELECT + LANCE_MUST_REINIT_RING +\n\t\t\tLANCE_HAS_MISSED_FRAME},\n\t{0x2260, \"PCnet/ISA+ 79C961\",\t\t \n\t\tLANCE_ENABLE_AUTOSELECT + LANCE_MUST_REINIT_RING +\n\t\t\tLANCE_HAS_MISSED_FRAME},\n\t{0x2420, \"PCnet/PCI 79C970\",\t\t \n\t\tLANCE_ENABLE_AUTOSELECT + LANCE_MUST_REINIT_RING +\n\t\t\tLANCE_HAS_MISSED_FRAME},\n\t \n\t{0x2430, \"PCnet32\",\t\t\t\t\t \n\t\tLANCE_ENABLE_AUTOSELECT + LANCE_MUST_REINIT_RING +\n\t\t\tLANCE_HAS_MISSED_FRAME},\n        {0x2621, \"PCnet/PCI-II 79C970A\",         \n                LANCE_ENABLE_AUTOSELECT + LANCE_MUST_REINIT_RING +\n                        LANCE_HAS_MISSED_FRAME},\n\t{0x0, \t \"PCnet (unknown)\",\n\t\tLANCE_ENABLE_AUTOSELECT + LANCE_MUST_REINIT_RING +\n\t\t\tLANCE_HAS_MISSED_FRAME},\n};\n\nenum {OLD_LANCE = 0, PCNET_ISA=1, PCNET_ISAP=2, PCNET_PCI=3, PCNET_VLB=4, PCNET_PCI_II=5, LANCE_UNKNOWN=6};\n\n\n \nstatic unsigned char lance_need_isa_bounce_buffers = 1;\n\nstatic int lance_open(struct net_device *dev);\nstatic void lance_init_ring(struct net_device *dev, gfp_t mode);\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev);\nstatic int lance_rx(struct net_device *dev);\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id);\nstatic int lance_close(struct net_device *dev);\nstatic struct net_device_stats *lance_get_stats(struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\nstatic void lance_tx_timeout (struct net_device *dev, unsigned int txqueue);\n\n\n\n#ifdef MODULE\n#define MAX_CARDS\t\t8\t \n\nstatic struct net_device *dev_lance[MAX_CARDS];\nstatic int io[MAX_CARDS];\nstatic int dma[MAX_CARDS];\nstatic int irq[MAX_CARDS];\n\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nmodule_param_hw_array(dma, int, dma, NULL, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nmodule_param(lance_debug, int, 0);\nMODULE_PARM_DESC(io, \"LANCE/PCnet I/O base address(es),required\");\nMODULE_PARM_DESC(dma, \"LANCE/PCnet ISA DMA channel (ignored for some devices)\");\nMODULE_PARM_DESC(irq, \"LANCE/PCnet IRQ number (ignored for some devices)\");\nMODULE_PARM_DESC(lance_debug, \"LANCE/PCnet debug level (0-7)\");\n\nstatic int __init lance_init_module(void)\n{\n\tstruct net_device *dev;\n\tint this_dev, found = 0;\n\n\tfor (this_dev = 0; this_dev < MAX_CARDS; this_dev++) {\n\t\tif (io[this_dev] == 0)  {\n\t\t\tif (this_dev != 0)  \n\t\t\t\tbreak;\n\t\t\tprintk(KERN_NOTICE \"lance.c: Module autoprobing not allowed. Append \\\"io=0xNNN\\\" value(s).\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tdev = alloc_etherdev(0);\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev->irq = irq[this_dev];\n\t\tdev->base_addr = io[this_dev];\n\t\tdev->dma = dma[this_dev];\n\t\tif (do_lance_probe(dev) == 0) {\n\t\t\tdev_lance[found++] = dev;\n\t\t\tcontinue;\n\t\t}\n\t\tfree_netdev(dev);\n\t\tbreak;\n\t}\n\tif (found != 0)\n\t\treturn 0;\n\treturn -ENXIO;\n}\nmodule_init(lance_init_module);\n\nstatic void cleanup_card(struct net_device *dev)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\tif (dev->dma != 4)\n\t\tfree_dma(dev->dma);\n\trelease_region(dev->base_addr, LANCE_TOTAL_SIZE);\n\tkfree(lp->tx_bounce_buffs);\n\tkfree((void*)lp->rx_buffs);\n\tkfree(lp);\n}\n\nstatic void __exit lance_cleanup_module(void)\n{\n\tint this_dev;\n\n\tfor (this_dev = 0; this_dev < MAX_CARDS; this_dev++) {\n\t\tstruct net_device *dev = dev_lance[this_dev];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tcleanup_card(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n}\nmodule_exit(lance_cleanup_module);\n#endif  \nMODULE_LICENSE(\"GPL\");\n\n\n \nstatic int __init do_lance_probe(struct net_device *dev)\n{\n\tunsigned int *port;\n\tint result;\n\n\tif (high_memory <= phys_to_virt(16*1024*1024))\n\t\tlance_need_isa_bounce_buffers = 0;\n\n\tfor (port = lance_portlist; *port; port++) {\n\t\tint ioaddr = *port;\n\t\tstruct resource *r = request_region(ioaddr, LANCE_TOTAL_SIZE,\n\t\t\t\t\t\t\t\"lance-probe\");\n\n\t\tif (r) {\n\t\t\t \n\t\t\tchar offset14 = inb(ioaddr + 14);\n\t\t\tint card;\n\t\t\tfor (card = 0; card < NUM_CARDS; ++card)\n\t\t\t\tif (cards[card].id_offset14 == offset14)\n\t\t\t\t\tbreak;\n\t\t\tif (card < NUM_CARDS) { \n\t\t\t\tchar offset15 = inb(ioaddr + 15);\n\t\t\t\tfor (card = 0; card < NUM_CARDS; ++card)\n\t\t\t\t\tif ((cards[card].id_offset14 == offset14) &&\n\t\t\t\t\t\t(cards[card].id_offset15 == offset15))\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (card < NUM_CARDS) {  \n\t\t\t\tresult = lance_probe1(dev, ioaddr, 0, 0);\n\t\t\t\tif (!result) {\n\t\t\t\t\tstruct lance_private *lp = dev->ml_priv;\n\t\t\t\t\tint ver = lp->chip_version;\n\n\t\t\t\t\tr->name = chip_table[ver].name;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\trelease_region(ioaddr, LANCE_TOTAL_SIZE);\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\n#ifndef MODULE\nstruct net_device * __init lance_probe(int unit)\n{\n\tstruct net_device *dev = alloc_etherdev(0);\n\tint err;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsprintf(dev->name, \"eth%d\", unit);\n\tnetdev_boot_setup_check(dev);\n\n\terr = do_lance_probe(dev);\n\tif (err)\n\t\tgoto out;\n\treturn dev;\nout:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n#endif\n\nstatic const struct net_device_ops lance_netdev_ops = {\n\t.ndo_open \t\t= lance_open,\n\t.ndo_start_xmit\t\t= lance_start_xmit,\n\t.ndo_stop\t\t= lance_close,\n\t.ndo_get_stats\t\t= lance_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_tx_timeout\t\t= lance_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int __init lance_probe1(struct net_device *dev, int ioaddr, int irq, int options)\n{\n\tstruct lance_private *lp;\n\tunsigned long dma_channels;\t \n\tint i, reset_val, lance_version;\n\tconst char *chipname;\n\t \n\tunsigned char hpJ2405A = 0;\t \n\tint hp_builtin = 0;\t\t \n\tstatic int did_version;\t\t \n\tunsigned long flags;\n\tint err = -ENOMEM;\n\tvoid __iomem *bios;\n\tu8 addr[ETH_ALEN];\n\n\t \n\tbios = ioremap(0xf00f0, 0x14);\n\tif (!bios)\n\t\treturn -ENOMEM;\n\tif (readw(bios + 0x12) == 0x5048)  {\n\t\tstatic const short ioaddr_table[] = { 0x300, 0x320, 0x340, 0x360};\n\t\tint hp_port = (readl(bios + 1) & 1)  ? 0x499 : 0x99;\n\t\t \n\t\tif ((inb(hp_port) & 0xc0) == 0x80 &&\n\t\t    ioaddr_table[inb(hp_port) & 3] == ioaddr)\n\t\t\thp_builtin = hp_port;\n\t}\n\tiounmap(bios);\n\t \n\thpJ2405A = (inb(ioaddr) == 0x08 && inb(ioaddr+1) == 0x00 &&\n\t\t    inb(ioaddr+2) == 0x09);\n\n\t \n\treset_val = inw(ioaddr+LANCE_RESET);  \n\n\t \n\tif (!hpJ2405A)\n\t\toutw(reset_val, ioaddr+LANCE_RESET);\n\n\toutw(0x0000, ioaddr+LANCE_ADDR);  \n\tif (inw(ioaddr+LANCE_DATA) != 0x0004)\n\t\treturn -ENODEV;\n\n\t \n\toutw(88, ioaddr+LANCE_ADDR);\n\tif (inw(ioaddr+LANCE_ADDR) != 88) {\n\t\tlance_version = 0;\n\t} else {\t\t\t \n\t\tint chip_version = inw(ioaddr+LANCE_DATA);\n\t\toutw(89, ioaddr+LANCE_ADDR);\n\t\tchip_version |= inw(ioaddr+LANCE_DATA) << 16;\n\t\tif (lance_debug > 2)\n\t\t\tprintk(\"  LANCE chip version is %#x.\\n\", chip_version);\n\t\tif ((chip_version & 0xfff) != 0x003)\n\t\t\treturn -ENODEV;\n\t\tchip_version = (chip_version >> 12) & 0xffff;\n\t\tfor (lance_version = 1; chip_table[lance_version].id_number; lance_version++) {\n\t\t\tif (chip_table[lance_version].id_number == chip_version)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tchipname = chip_table[lance_version].name;\n\tprintk(\"%s: %s at %#3x, \", dev->name, chipname, ioaddr);\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = inb(ioaddr + i);\n\teth_hw_addr_set(dev, addr);\n\tprintk(\"%pM\", dev->dev_addr);\n\n\tdev->base_addr = ioaddr;\n\t \n\n\tlp = kzalloc(sizeof(*lp), GFP_DMA | GFP_KERNEL);\n\tif (!lp)\n\t\treturn -ENOMEM;\n\tif (lance_debug > 6) printk(\" (#0x%05lx)\", (unsigned long)lp);\n\tdev->ml_priv = lp;\n\tlp->name = chipname;\n\tlp->rx_buffs = (unsigned long)kmalloc_array(RX_RING_SIZE, PKT_BUF_SZ,\n\t\t\t\t\t\t    GFP_DMA | GFP_KERNEL);\n\tif (!lp->rx_buffs)\n\t\tgoto out_lp;\n\tif (lance_need_isa_bounce_buffers) {\n\t\tlp->tx_bounce_buffs = kmalloc_array(TX_RING_SIZE, PKT_BUF_SZ,\n\t\t\t\t\t\t    GFP_DMA | GFP_KERNEL);\n\t\tif (!lp->tx_bounce_buffs)\n\t\t\tgoto out_rx;\n\t} else\n\t\tlp->tx_bounce_buffs = NULL;\n\n\tlp->chip_version = lance_version;\n\tspin_lock_init(&lp->devlock);\n\n\tlp->init_block.mode = 0x0003;\t\t \n\tfor (i = 0; i < 6; i++)\n\t\tlp->init_block.phys_addr[i] = dev->dev_addr[i];\n\tlp->init_block.filter[0] = 0x00000000;\n\tlp->init_block.filter[1] = 0x00000000;\n\tlp->init_block.rx_ring = ((u32)isa_virt_to_bus(lp->rx_ring) & 0xffffff) | RX_RING_LEN_BITS;\n\tlp->init_block.tx_ring = ((u32)isa_virt_to_bus(lp->tx_ring) & 0xffffff) | TX_RING_LEN_BITS;\n\n\toutw(0x0001, ioaddr+LANCE_ADDR);\n\tinw(ioaddr+LANCE_ADDR);\n\toutw((short) (u32) isa_virt_to_bus(&lp->init_block), ioaddr+LANCE_DATA);\n\toutw(0x0002, ioaddr+LANCE_ADDR);\n\tinw(ioaddr+LANCE_ADDR);\n\toutw(((u32)isa_virt_to_bus(&lp->init_block)) >> 16, ioaddr+LANCE_DATA);\n\toutw(0x0000, ioaddr+LANCE_ADDR);\n\tinw(ioaddr+LANCE_ADDR);\n\n\tif (irq) {\t\t\t\t\t \n\t\tdev->dma = 4;\t\t\t \n\t\tdev->irq = irq;\n\t} else if (hp_builtin) {\n\t\tstatic const char dma_tbl[4] = {3, 5, 6, 0};\n\t\tstatic const char irq_tbl[4] = {3, 4, 5, 9};\n\t\tunsigned char port_val = inb(hp_builtin);\n\t\tdev->dma = dma_tbl[(port_val >> 4) & 3];\n\t\tdev->irq = irq_tbl[(port_val >> 2) & 3];\n\t\tprintk(\" HP Vectra IRQ %d DMA %d.\\n\", dev->irq, dev->dma);\n\t} else if (hpJ2405A) {\n\t\tstatic const char dma_tbl[4] = {3, 5, 6, 7};\n\t\tstatic const char irq_tbl[8] = {3, 4, 5, 9, 10, 11, 12, 15};\n\t\tshort reset_val = inw(ioaddr+LANCE_RESET);\n\t\tdev->dma = dma_tbl[(reset_val >> 2) & 3];\n\t\tdev->irq = irq_tbl[(reset_val >> 4) & 7];\n\t\tprintk(\" HP J2405A IRQ %d DMA %d.\\n\", dev->irq, dev->dma);\n\t} else if (lance_version == PCNET_ISAP) {\t\t \n\t\tshort bus_info;\n\t\toutw(8, ioaddr+LANCE_ADDR);\n\t\tbus_info = inw(ioaddr+LANCE_BUS_IF);\n\t\tdev->dma = bus_info & 0x07;\n\t\tdev->irq = (bus_info >> 4) & 0x0F;\n\t} else {\n\t\t \n\t\tif (dev->mem_start & 0x07)\n\t\t\tdev->dma = dev->mem_start & 0x07;\n\t}\n\n\tif (dev->dma == 0) {\n\t\t \n\t\tdma_channels = ((inb(DMA1_STAT_REG) >> 4) & 0x0f) |\n\t\t\t(inb(DMA2_STAT_REG) & 0xf0);\n\t}\n\terr = -ENODEV;\n\tif (dev->irq >= 2)\n\t\tprintk(\" assigned IRQ %d\", dev->irq);\n\telse if (lance_version != 0)  {\t \n\t\tunsigned long irq_mask;\n\n\t\t \n\t\tirq_mask = probe_irq_on();\n\n\t\t \n\t\toutw(0x0041, ioaddr+LANCE_DATA);\n\n\t\tmdelay(20);\n\t\tdev->irq = probe_irq_off(irq_mask);\n\t\tif (dev->irq)\n\t\t\tprintk(\", probed IRQ %d\", dev->irq);\n\t\telse {\n\t\t\tprintk(\", failed to detect IRQ line.\\n\");\n\t\t\tgoto out_tx;\n\t\t}\n\n\t\t \n\t\tif (inw(ioaddr+LANCE_DATA) & 0x0100)\n\t\t\tdev->dma = 4;\n\t}\n\n\tif (dev->dma == 4) {\n\t\tprintk(\", no DMA needed.\\n\");\n\t} else if (dev->dma) {\n\t\tif (request_dma(dev->dma, chipname)) {\n\t\t\tprintk(\"DMA %d allocation failed.\\n\", dev->dma);\n\t\t\tgoto out_tx;\n\t\t} else\n\t\t\tprintk(\", assigned DMA %d.\\n\", dev->dma);\n\t} else {\t\t\t \n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tstatic const char dmas[] = { 5, 6, 7, 3 };\n\t\t\tint dma = dmas[i];\n\t\t\tint boguscnt;\n\n\t\t\t \n\t\t\tif (test_bit(dma, &dma_channels))\n\t\t\t\tcontinue;\n\t\t\toutw(0x7f04, ioaddr+LANCE_DATA);  \n\t\t\tif (request_dma(dma, chipname))\n\t\t\t\tcontinue;\n\n\t\t\tflags=claim_dma_lock();\n\t\t\tset_dma_mode(dma, DMA_MODE_CASCADE);\n\t\t\tenable_dma(dma);\n\t\t\trelease_dma_lock(flags);\n\n\t\t\t \n\t\t\toutw(0x0001, ioaddr+LANCE_DATA);\n\t\t\tfor (boguscnt = 100; boguscnt > 0; --boguscnt)\n\t\t\t\tif (inw(ioaddr+LANCE_DATA) & 0x0900)\n\t\t\t\t\tbreak;\n\t\t\tif (inw(ioaddr+LANCE_DATA) & 0x0100) {\n\t\t\t\tdev->dma = dma;\n\t\t\t\tprintk(\", DMA %d.\\n\", dev->dma);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tflags=claim_dma_lock();\n\t\t\t\tdisable_dma(dma);\n\t\t\t\trelease_dma_lock(flags);\n\t\t\t\tfree_dma(dma);\n\t\t\t}\n\t\t}\n\t\tif (i == 4) {\t\t\t \n\t\t\tprintk(\"DMA detection failed.\\n\");\n\t\t\tgoto out_tx;\n\t\t}\n\t}\n\n\tif (lance_version == 0 && dev->irq == 0) {\n\t\t \n\t\t \n\t\tunsigned long irq_mask;\n\n\t\tirq_mask = probe_irq_on();\n\t\toutw(0x0041, ioaddr+LANCE_DATA);\n\n\t\tmdelay(40);\n\t\tdev->irq = probe_irq_off(irq_mask);\n\t\tif (dev->irq == 0) {\n\t\t\tprintk(\"  Failed to detect the 7990 IRQ line.\\n\");\n\t\t\tgoto out_dma;\n\t\t}\n\t\tprintk(\"  Auto-IRQ detected IRQ%d.\\n\", dev->irq);\n\t}\n\n\tif (chip_table[lp->chip_version].flags & LANCE_ENABLE_AUTOSELECT) {\n\t\t \n\t\toutw(0x0002, ioaddr+LANCE_ADDR);\n\t\t \n\t\toutw(inw(ioaddr+LANCE_BUS_IF) | 0x0002, ioaddr+LANCE_BUS_IF);\n\t}\n\n\tif (lance_debug > 0  &&  did_version++ == 0)\n\t\tprintk(version);\n\n\t \n\tdev->netdev_ops = &lance_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out_dma;\n\treturn 0;\nout_dma:\n\tif (dev->dma != 4)\n\t\tfree_dma(dev->dma);\nout_tx:\n\tkfree(lp->tx_bounce_buffs);\nout_rx:\n\tkfree((void*)lp->rx_buffs);\nout_lp:\n\tkfree(lp);\n\treturn err;\n}\n\n\nstatic int\nlance_open(struct net_device *dev)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\tint ioaddr = dev->base_addr;\n\tint i;\n\n\tif (dev->irq == 0 ||\n\t\trequest_irq(dev->irq, lance_interrupt, 0, dev->name, dev)) {\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\n\t \n\tinw(ioaddr+LANCE_RESET);\n\n\t \n\tif (dev->dma != 4) {\n\t\tunsigned long flags=claim_dma_lock();\n\t\tenable_dma(dev->dma);\n\t\tset_dma_mode(dev->dma, DMA_MODE_CASCADE);\n\t\trelease_dma_lock(flags);\n\t}\n\n\t \n\tif (chip_table[lp->chip_version].flags & LANCE_MUST_UNRESET)\n\t\toutw(0, ioaddr+LANCE_RESET);\n\n\tif (chip_table[lp->chip_version].flags & LANCE_ENABLE_AUTOSELECT) {\n\t\t \n\t\toutw(0x0002, ioaddr+LANCE_ADDR);\n\t\t \n\t\toutw(inw(ioaddr+LANCE_BUS_IF) | 0x0002, ioaddr+LANCE_BUS_IF);\n\t}\n\n\tif (lance_debug > 1)\n\t\tprintk(\"%s: lance_open() irq %d dma %d tx/rx rings %#x/%#x init %#x.\\n\",\n\t\t\t   dev->name, dev->irq, dev->dma,\n\t\t           (u32) isa_virt_to_bus(lp->tx_ring),\n\t\t           (u32) isa_virt_to_bus(lp->rx_ring),\n\t\t\t   (u32) isa_virt_to_bus(&lp->init_block));\n\n\tlance_init_ring(dev, GFP_KERNEL);\n\t \n\toutw(0x0001, ioaddr+LANCE_ADDR);\n\toutw((short) (u32) isa_virt_to_bus(&lp->init_block), ioaddr+LANCE_DATA);\n\toutw(0x0002, ioaddr+LANCE_ADDR);\n\toutw(((u32)isa_virt_to_bus(&lp->init_block)) >> 16, ioaddr+LANCE_DATA);\n\n\toutw(0x0004, ioaddr+LANCE_ADDR);\n\toutw(0x0915, ioaddr+LANCE_DATA);\n\n\toutw(0x0000, ioaddr+LANCE_ADDR);\n\toutw(0x0001, ioaddr+LANCE_DATA);\n\n\tnetif_start_queue (dev);\n\n\ti = 0;\n\twhile (i++ < 100)\n\t\tif (inw(ioaddr+LANCE_DATA) & 0x0100)\n\t\t\tbreak;\n\t \n\toutw(0x0042, ioaddr+LANCE_DATA);\n\n\tif (lance_debug > 2)\n\t\tprintk(\"%s: LANCE open after %d ticks, init block %#x csr0 %4.4x.\\n\",\n\t\t\t   dev->name, i, (u32) isa_virt_to_bus(&lp->init_block), inw(ioaddr+LANCE_DATA));\n\n\treturn 0;\t\t\t\t\t \n}\n\n \n\nstatic void\nlance_purge_ring(struct net_device *dev)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\tint i;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = lp->rx_skbuff[i];\n\t\tlp->rx_skbuff[i] = NULL;\n\t\tlp->rx_ring[i].base = 0;\t\t \n\t\tif (skb)\n\t\t\tdev_kfree_skb_any(skb);\n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tif (lp->tx_skbuff[i]) {\n\t\t\tdev_kfree_skb_any(lp->tx_skbuff[i]);\n\t\t\tlp->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n}\n\n\n \nstatic void\nlance_init_ring(struct net_device *dev, gfp_t gfp)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\tint i;\n\n\tlp->cur_rx = lp->cur_tx = 0;\n\tlp->dirty_rx = lp->dirty_tx = 0;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb;\n\t\tvoid *rx_buff;\n\n\t\tskb = alloc_skb(PKT_BUF_SZ, GFP_DMA | gfp);\n\t\tlp->rx_skbuff[i] = skb;\n\t\tif (skb)\n\t\t\trx_buff = skb->data;\n\t\telse\n\t\t\trx_buff = kmalloc(PKT_BUF_SZ, GFP_DMA | gfp);\n\t\tif (!rx_buff)\n\t\t\tlp->rx_ring[i].base = 0;\n\t\telse\n\t\t\tlp->rx_ring[i].base = (u32)isa_virt_to_bus(rx_buff) | 0x80000000;\n\t\tlp->rx_ring[i].buf_length = -PKT_BUF_SZ;\n\t}\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tlp->tx_skbuff[i] = NULL;\n\t\tlp->tx_ring[i].base = 0;\n\t}\n\n\tlp->init_block.mode = 0x0000;\n\tfor (i = 0; i < 6; i++)\n\t\tlp->init_block.phys_addr[i] = dev->dev_addr[i];\n\tlp->init_block.filter[0] = 0x00000000;\n\tlp->init_block.filter[1] = 0x00000000;\n\tlp->init_block.rx_ring = ((u32)isa_virt_to_bus(lp->rx_ring) & 0xffffff) | RX_RING_LEN_BITS;\n\tlp->init_block.tx_ring = ((u32)isa_virt_to_bus(lp->tx_ring) & 0xffffff) | TX_RING_LEN_BITS;\n}\n\nstatic void\nlance_restart(struct net_device *dev, unsigned int csr0_bits, int must_reinit)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\n\tif (must_reinit ||\n\t\t(chip_table[lp->chip_version].flags & LANCE_MUST_REINIT_RING)) {\n\t\tlance_purge_ring(dev);\n\t\tlance_init_ring(dev, GFP_ATOMIC);\n\t}\n\toutw(0x0000,    dev->base_addr + LANCE_ADDR);\n\toutw(csr0_bits, dev->base_addr + LANCE_DATA);\n}\n\n\nstatic void lance_tx_timeout (struct net_device *dev, unsigned int txqueue)\n{\n\tstruct lance_private *lp = (struct lance_private *) dev->ml_priv;\n\tint ioaddr = dev->base_addr;\n\n\toutw (0, ioaddr + LANCE_ADDR);\n\tprintk (\"%s: transmit timed out, status %4.4x, resetting.\\n\",\n\t\tdev->name, inw (ioaddr + LANCE_DATA));\n\toutw (0x0004, ioaddr + LANCE_DATA);\n\tdev->stats.tx_errors++;\n#ifndef final_version\n\tif (lance_debug > 3) {\n\t\tint i;\n\t\tprintk (\" Ring data dump: dirty_tx %d cur_tx %d%s cur_rx %d.\",\n\t\t  lp->dirty_tx, lp->cur_tx, netif_queue_stopped(dev) ? \" (full)\" : \"\",\n\t\t\tlp->cur_rx);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tprintk (\"%s %08x %04x %04x\", i & 0x3 ? \"\" : \"\\n \",\n\t\t\t lp->rx_ring[i].base, -lp->rx_ring[i].buf_length,\n\t\t\t\tlp->rx_ring[i].msg_length);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tprintk (\"%s %08x %04x %04x\", i & 0x3 ? \"\" : \"\\n \",\n\t\t\t     lp->tx_ring[i].base, -lp->tx_ring[i].length,\n\t\t\t\tlp->tx_ring[i].misc);\n\t\tprintk (\"\\n\");\n\t}\n#endif\n\tlance_restart (dev, 0x0043, 1);\n\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue (dev);\n}\n\n\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\tint ioaddr = dev->base_addr;\n\tint entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->devlock, flags);\n\n\tif (lance_debug > 3) {\n\t\toutw(0x0000, ioaddr+LANCE_ADDR);\n\t\tprintk(\"%s: lance_start_xmit() called, csr0 %4.4x.\\n\", dev->name,\n\t\t\t   inw(ioaddr+LANCE_DATA));\n\t\toutw(0x0000, ioaddr+LANCE_DATA);\n\t}\n\n\t \n\n\t \n\tentry = lp->cur_tx & TX_RING_MOD_MASK;\n\n\t \n\n\t \n\tif (chip_table[lp->chip_version].flags & LANCE_MUST_PAD) {\n\t\tif (skb->len < ETH_ZLEN) {\n\t\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\t\tgoto out;\n\t\t\tlp->tx_ring[entry].length = -ETH_ZLEN;\n\t\t}\n\t\telse\n\t\t\tlp->tx_ring[entry].length = -skb->len;\n\t} else\n\t\tlp->tx_ring[entry].length = -skb->len;\n\n\tlp->tx_ring[entry].misc = 0x0000;\n\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\tif ((u32)isa_virt_to_bus(skb->data) + skb->len > 0x01000000) {\n\t\tif (lance_debug > 5)\n\t\t\tprintk(\"%s: bouncing a high-memory packet (%#x).\\n\",\n\t\t\t\t   dev->name, (u32)isa_virt_to_bus(skb->data));\n\t\tskb_copy_from_linear_data(skb, &lp->tx_bounce_buffs[entry], skb->len);\n\t\tlp->tx_ring[entry].base =\n\t\t\t((u32)isa_virt_to_bus((lp->tx_bounce_buffs + entry)) & 0xffffff) | 0x83000000;\n\t\tdev_consume_skb_irq(skb);\n\t} else {\n\t\tlp->tx_skbuff[entry] = skb;\n\t\tlp->tx_ring[entry].base = ((u32)isa_virt_to_bus(skb->data) & 0xffffff) | 0x83000000;\n\t}\n\tlp->cur_tx++;\n\n\t \n\toutw(0x0000, ioaddr+LANCE_ADDR);\n\toutw(0x0048, ioaddr+LANCE_DATA);\n\n\tif ((lp->cur_tx - lp->dirty_tx) >= TX_RING_SIZE)\n\t\tnetif_stop_queue(dev);\n\nout:\n\tspin_unlock_irqrestore(&lp->devlock, flags);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct lance_private *lp;\n\tint csr0, ioaddr, boguscnt=10;\n\tint must_restart;\n\n\tioaddr = dev->base_addr;\n\tlp = dev->ml_priv;\n\n\tspin_lock (&lp->devlock);\n\n\toutw(0x00, dev->base_addr + LANCE_ADDR);\n\twhile ((csr0 = inw(dev->base_addr + LANCE_DATA)) & 0x8600 &&\n\t       --boguscnt >= 0) {\n\t\t \n\t\toutw(csr0 & ~0x004f, dev->base_addr + LANCE_DATA);\n\n\t\tmust_restart = 0;\n\n\t\tif (lance_debug > 5)\n\t\t\tprintk(\"%s: interrupt  csr0=%#2.2x new csr=%#2.2x.\\n\",\n\t\t\t\t   dev->name, csr0, inw(dev->base_addr + LANCE_DATA));\n\n\t\tif (csr0 & 0x0400)\t\t\t \n\t\t\tlance_rx(dev);\n\n\t\tif (csr0 & 0x0200) {\t\t \n\t\t\tint dirty_tx = lp->dirty_tx;\n\n\t\t\twhile (dirty_tx < lp->cur_tx) {\n\t\t\t\tint entry = dirty_tx & TX_RING_MOD_MASK;\n\t\t\t\tint status = lp->tx_ring[entry].base;\n\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\t\t\t \n\n\t\t\t\tlp->tx_ring[entry].base = 0;\n\n\t\t\t\tif (status & 0x40000000) {\n\t\t\t\t\t \n\t\t\t\t\tint err_status = lp->tx_ring[entry].misc;\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\tif (err_status & 0x0400)\n\t\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\t\tif (err_status & 0x0800)\n\t\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\t\tif (err_status & 0x1000)\n\t\t\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\t\t\tif (err_status & 0x4000) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t\t\t \n\t\t\t\t\t\tprintk(\"%s: Tx FIFO error! Status %4.4x.\\n\",\n\t\t\t\t\t\t\t   dev->name, csr0);\n\t\t\t\t\t\t \n\t\t\t\t\t\tmust_restart = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (status & 0x18000000)\n\t\t\t\t\t\tdev->stats.collisions++;\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (lp->tx_skbuff[entry]) {\n\t\t\t\t\tdev_consume_skb_irq(lp->tx_skbuff[entry]);\n\t\t\t\t\tlp->tx_skbuff[entry] = NULL;\n\t\t\t\t}\n\t\t\t\tdirty_tx++;\n\t\t\t}\n\n#ifndef final_version\n\t\t\tif (lp->cur_tx - dirty_tx >= TX_RING_SIZE) {\n\t\t\t\tprintk(\"out-of-sync dirty pointer, %d vs. %d, full=%s.\\n\",\n\t\t\t\t\t   dirty_tx, lp->cur_tx,\n\t\t\t\t\t   netif_queue_stopped(dev) ? \"yes\" : \"no\");\n\t\t\t\tdirty_tx += TX_RING_SIZE;\n\t\t\t}\n#endif\n\n\t\t\t \n\t\t\tif (netif_queue_stopped(dev) &&\n\t\t\t    dirty_tx > lp->cur_tx - TX_RING_SIZE + 2)\n\t\t\t\tnetif_wake_queue (dev);\n\n\t\t\tlp->dirty_tx = dirty_tx;\n\t\t}\n\n\t\t \n\t\tif (csr0 & 0x4000)\n\t\t\tdev->stats.tx_errors++;  \n\t\tif (csr0 & 0x1000)\n\t\t\tdev->stats.rx_errors++;  \n\t\tif (csr0 & 0x0800) {\n\t\t\tprintk(\"%s: Bus master arbitration failure, status %4.4x.\\n\",\n\t\t\t\t   dev->name, csr0);\n\t\t\t \n\t\t\tmust_restart = 1;\n\t\t}\n\n\t\tif (must_restart) {\n\t\t\t \n\t\t\toutw(0x0000, dev->base_addr + LANCE_ADDR);\n\t\t\toutw(0x0004, dev->base_addr + LANCE_DATA);\n\t\t\tlance_restart(dev, 0x0002, 0);\n\t\t}\n\t}\n\n\t \n\toutw(0x0000, dev->base_addr + LANCE_ADDR);\n\toutw(0x7940, dev->base_addr + LANCE_DATA);\n\n\tif (lance_debug > 4)\n\t\tprintk(\"%s: exiting interrupt, csr%d=%#4.4x.\\n\",\n\t\t\t   dev->name, inw(ioaddr + LANCE_ADDR),\n\t\t\t   inw(dev->base_addr + LANCE_DATA));\n\n\tspin_unlock (&lp->devlock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nlance_rx(struct net_device *dev)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\tint entry = lp->cur_rx & RX_RING_MOD_MASK;\n\tint i;\n\n\t \n\twhile (lp->rx_ring[entry].base >= 0) {\n\t\tint status = lp->rx_ring[entry].base >> 24;\n\n\t\tif (status != 0x03) {\t\t\t \n\t\t\t \n\t\t\tif (status & 0x01)\t \n\t\t\t\tdev->stats.rx_errors++;  \n\t\t\tif (status & 0x20)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (status & 0x10)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif (status & 0x08)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (status & 0x04)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tlp->rx_ring[entry].base &= 0x03ffffff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t \n\t\t\tshort pkt_len = (lp->rx_ring[entry].msg_length & 0xfff)-4;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif(pkt_len<60)\n\t\t\t{\n\t\t\t\tprintk(\"%s: Runt packet!\\n\",dev->name);\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tskb = dev_alloc_skb(pkt_len+2);\n\t\t\t\tif (!skb)\n\t\t\t\t{\n\t\t\t\t\tprintk(\"%s: Memory squeeze, deferring packet.\\n\", dev->name);\n\t\t\t\t\tfor (i=0; i < RX_RING_SIZE; i++)\n\t\t\t\t\t\tif (lp->rx_ring[(entry+i) & RX_RING_MOD_MASK].base < 0)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (i > RX_RING_SIZE -2)\n\t\t\t\t\t{\n\t\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\t\tlp->rx_ring[entry].base |= 0x80000000;\n\t\t\t\t\t\tlp->cur_rx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tskb_reserve(skb,2);\t \n\t\t\t\tskb_put(skb,pkt_len);\t \n\t\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t(unsigned char *)isa_bus_to_virt((lp->rx_ring[entry].base & 0x00ffffff)),\n\t\t\t\t\tpkt_len);\n\t\t\t\tskb->protocol=eth_type_trans(skb,dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t}\n\t\t}\n\t\t \n\t\tlp->rx_ring[entry].buf_length = -PKT_BUF_SZ;\n\t\tlp->rx_ring[entry].base |= 0x80000000;\n\t\tentry = (++lp->cur_rx) & RX_RING_MOD_MASK;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int\nlance_close(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tstruct lance_private *lp = dev->ml_priv;\n\n\tnetif_stop_queue (dev);\n\n\tif (chip_table[lp->chip_version].flags & LANCE_HAS_MISSED_FRAME) {\n\t\toutw(112, ioaddr+LANCE_ADDR);\n\t\tdev->stats.rx_missed_errors = inw(ioaddr+LANCE_DATA);\n\t}\n\toutw(0, ioaddr+LANCE_ADDR);\n\n\tif (lance_debug > 1)\n\t\tprintk(\"%s: Shutting down ethercard, status was %2.2x.\\n\",\n\t\t\t   dev->name, inw(ioaddr+LANCE_DATA));\n\n\t \n\toutw(0x0004, ioaddr+LANCE_DATA);\n\n\tif (dev->dma != 4)\n\t{\n\t\tunsigned long flags=claim_dma_lock();\n\t\tdisable_dma(dev->dma);\n\t\trelease_dma_lock(flags);\n\t}\n\tfree_irq(dev->irq, dev);\n\n\tlance_purge_ring(dev);\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *lance_get_stats(struct net_device *dev)\n{\n\tstruct lance_private *lp = dev->ml_priv;\n\n\tif (chip_table[lp->chip_version].flags & LANCE_HAS_MISSED_FRAME) {\n\t\tshort ioaddr = dev->base_addr;\n\t\tshort saved_addr;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&lp->devlock, flags);\n\t\tsaved_addr = inw(ioaddr+LANCE_ADDR);\n\t\toutw(112, ioaddr+LANCE_ADDR);\n\t\tdev->stats.rx_missed_errors = inw(ioaddr+LANCE_DATA);\n\t\toutw(saved_addr, ioaddr+LANCE_ADDR);\n\t\tspin_unlock_irqrestore(&lp->devlock, flags);\n\t}\n\n\treturn &dev->stats;\n}\n\n \n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tshort ioaddr = dev->base_addr;\n\n\toutw(0, ioaddr+LANCE_ADDR);\n\toutw(0x0004, ioaddr+LANCE_DATA);  \n\n\tif (dev->flags&IFF_PROMISC) {\n\t\toutw(15, ioaddr+LANCE_ADDR);\n\t\toutw(0x8000, ioaddr+LANCE_DATA);  \n\t} else {\n\t\tshort multicast_table[4];\n\t\tint i;\n\t\tint num_addrs=netdev_mc_count(dev);\n\t\tif(dev->flags&IFF_ALLMULTI)\n\t\t\tnum_addrs=1;\n\t\t \n\t\tmemset(multicast_table, (num_addrs == 0) ? 0 : -1, sizeof(multicast_table));\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\toutw(8 + i, ioaddr+LANCE_ADDR);\n\t\t\toutw(multicast_table[i], ioaddr+LANCE_DATA);\n\t\t}\n\t\toutw(15, ioaddr+LANCE_ADDR);\n\t\toutw(0x0000, ioaddr+LANCE_DATA);  \n\t}\n\n\tlance_restart(dev, 0x0142, 0);  \n\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}