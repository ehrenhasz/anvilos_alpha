{
  "module_name": "auxbus.c",
  "hash_id": "ed39b4fa9c059f931cef067bf21cff1cc4affc2d73527ea34124b3dd546ec0a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pds_core/auxbus.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n\n#include \"core.h\"\n#include <linux/pds/pds_auxbus.h>\n\n \nint pds_client_register(struct pdsc *pf, char *devname)\n{\n\tunion pds_core_adminq_comp comp = {};\n\tunion pds_core_adminq_cmd cmd = {};\n\tint err;\n\tu16 ci;\n\n\tcmd.client_reg.opcode = PDS_AQ_CMD_CLIENT_REG;\n\tstrscpy(cmd.client_reg.devname, devname,\n\t\tsizeof(cmd.client_reg.devname));\n\n\terr = pdsc_adminq_post(pf, &cmd, &comp, false);\n\tif (err) {\n\t\tdev_info(pf->dev, \"register dev_name %s with DSC failed, status %d: %pe\\n\",\n\t\t\t devname, comp.status, ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tci = le16_to_cpu(comp.client_reg.client_id);\n\tif (!ci) {\n\t\tdev_err(pf->dev, \"%s: device returned null client_id\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(pf->dev, \"%s: device returned client_id %d for %s\\n\",\n\t\t__func__, ci, devname);\n\n\treturn ci;\n}\nEXPORT_SYMBOL_GPL(pds_client_register);\n\n \nint pds_client_unregister(struct pdsc *pf, u16 client_id)\n{\n\tunion pds_core_adminq_comp comp = {};\n\tunion pds_core_adminq_cmd cmd = {};\n\tint err;\n\n\tcmd.client_unreg.opcode = PDS_AQ_CMD_CLIENT_UNREG;\n\tcmd.client_unreg.client_id = cpu_to_le16(client_id);\n\n\terr = pdsc_adminq_post(pf, &cmd, &comp, false);\n\tif (err)\n\t\tdev_info(pf->dev, \"unregister client_id %d failed, status %d: %pe\\n\",\n\t\t\t client_id, comp.status, ERR_PTR(err));\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(pds_client_unregister);\n\n \nint pds_client_adminq_cmd(struct pds_auxiliary_dev *padev,\n\t\t\t  union pds_core_adminq_cmd *req,\n\t\t\t  size_t req_len,\n\t\t\t  union pds_core_adminq_comp *resp,\n\t\t\t  u64 flags)\n{\n\tunion pds_core_adminq_cmd cmd = {};\n\tstruct pci_dev *pf_pdev;\n\tstruct pdsc *pf;\n\tsize_t cp_len;\n\tint err;\n\n\tpf_pdev = pci_physfn(padev->vf_pdev);\n\tpf = pci_get_drvdata(pf_pdev);\n\n\tdev_dbg(pf->dev, \"%s: %s opcode %d\\n\",\n\t\t__func__, dev_name(&padev->aux_dev.dev), req->opcode);\n\n\tif (pf->state)\n\t\treturn -ENXIO;\n\n\t \n\tcmd.client_request.opcode = PDS_AQ_CMD_CLIENT_CMD;\n\tcmd.client_request.client_id = cpu_to_le16(padev->client_id);\n\tcp_len = min_t(size_t, req_len, sizeof(cmd.client_request.client_cmd));\n\tmemcpy(cmd.client_request.client_cmd, req, cp_len);\n\n\terr = pdsc_adminq_post(pf, &cmd, resp,\n\t\t\t       !!(flags & PDS_AQ_FLAG_FASTPOLL));\n\tif (err && err != -EAGAIN)\n\t\tdev_info(pf->dev, \"client admin cmd failed: %pe\\n\",\n\t\t\t ERR_PTR(err));\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(pds_client_adminq_cmd);\n\nstatic void pdsc_auxbus_dev_release(struct device *dev)\n{\n\tstruct pds_auxiliary_dev *padev =\n\t\tcontainer_of(dev, struct pds_auxiliary_dev, aux_dev.dev);\n\n\tkfree(padev);\n}\n\nstatic struct pds_auxiliary_dev *pdsc_auxbus_dev_register(struct pdsc *cf,\n\t\t\t\t\t\t\t  struct pdsc *pf,\n\t\t\t\t\t\t\t  u16 client_id,\n\t\t\t\t\t\t\t  char *name)\n{\n\tstruct auxiliary_device *aux_dev;\n\tstruct pds_auxiliary_dev *padev;\n\tint err;\n\n\tpadev = kzalloc(sizeof(*padev), GFP_KERNEL);\n\tif (!padev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpadev->vf_pdev = cf->pdev;\n\tpadev->client_id = client_id;\n\n\taux_dev = &padev->aux_dev;\n\taux_dev->name = name;\n\taux_dev->id = cf->uid;\n\taux_dev->dev.parent = cf->dev;\n\taux_dev->dev.release = pdsc_auxbus_dev_release;\n\n\terr = auxiliary_device_init(aux_dev);\n\tif (err < 0) {\n\t\tdev_warn(cf->dev, \"auxiliary_device_init of %s failed: %pe\\n\",\n\t\t\t name, ERR_PTR(err));\n\t\tgoto err_out;\n\t}\n\n\terr = auxiliary_device_add(aux_dev);\n\tif (err) {\n\t\tdev_warn(cf->dev, \"auxiliary_device_add of %s failed: %pe\\n\",\n\t\t\t name, ERR_PTR(err));\n\t\tgoto err_out_uninit;\n\t}\n\n\treturn padev;\n\nerr_out_uninit:\n\tauxiliary_device_uninit(aux_dev);\nerr_out:\n\tkfree(padev);\n\treturn ERR_PTR(err);\n}\n\nint pdsc_auxbus_dev_del(struct pdsc *cf, struct pdsc *pf)\n{\n\tstruct pds_auxiliary_dev *padev;\n\tint err = 0;\n\n\tmutex_lock(&pf->config_lock);\n\n\tpadev = pf->vfs[cf->vf_id].padev;\n\tif (padev) {\n\t\tpds_client_unregister(pf, padev->client_id);\n\t\tauxiliary_device_delete(&padev->aux_dev);\n\t\tauxiliary_device_uninit(&padev->aux_dev);\n\t\tpadev->client_id = 0;\n\t}\n\tpf->vfs[cf->vf_id].padev = NULL;\n\n\tmutex_unlock(&pf->config_lock);\n\treturn err;\n}\n\nint pdsc_auxbus_dev_add(struct pdsc *cf, struct pdsc *pf)\n{\n\tstruct pds_auxiliary_dev *padev;\n\tenum pds_core_vif_types vt;\n\tchar devname[PDS_DEVNAME_LEN];\n\tu16 vt_support;\n\tint client_id;\n\tint err = 0;\n\n\tmutex_lock(&pf->config_lock);\n\n\t \n\n\t \n\tvt = PDS_DEV_TYPE_VDPA;\n\tvt_support = !!le16_to_cpu(pf->dev_ident.vif_types[vt]);\n\tif (!(vt_support &&\n\t      pf->viftype_status[vt].supported &&\n\t      pf->viftype_status[vt].enabled))\n\t\tgoto out_unlock;\n\n\t \n\tsnprintf(devname, sizeof(devname), \"%s.%s.%d\",\n\t\t PDS_CORE_DRV_NAME, pf->viftype_status[vt].name, cf->uid);\n\tclient_id = pds_client_register(pf, devname);\n\tif (client_id < 0) {\n\t\terr = client_id;\n\t\tgoto out_unlock;\n\t}\n\n\tpadev = pdsc_auxbus_dev_register(cf, pf, client_id,\n\t\t\t\t\t pf->viftype_status[vt].name);\n\tif (IS_ERR(padev)) {\n\t\tpds_client_unregister(pf, client_id);\n\t\terr = PTR_ERR(padev);\n\t\tgoto out_unlock;\n\t}\n\tpf->vfs[cf->vf_id].padev = padev;\n\nout_unlock:\n\tmutex_unlock(&pf->config_lock);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}