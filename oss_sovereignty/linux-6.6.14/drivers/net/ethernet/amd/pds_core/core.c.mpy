{
  "module_name": "core.c",
  "hash_id": "28cd5b1eb8529ec589ed3b449c951b612ae684b81afc89c0842dbb8c3bc91078",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pds_core/core.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include \"core.h\"\n\nstatic BLOCKING_NOTIFIER_HEAD(pds_notify_chain);\n\nint pdsc_register_notify(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&pds_notify_chain, nb);\n}\nEXPORT_SYMBOL_GPL(pdsc_register_notify);\n\nvoid pdsc_unregister_notify(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&pds_notify_chain, nb);\n}\nEXPORT_SYMBOL_GPL(pdsc_unregister_notify);\n\nvoid pdsc_notify(unsigned long event, void *data)\n{\n\tblocking_notifier_call_chain(&pds_notify_chain, event, data);\n}\n\nvoid pdsc_intr_free(struct pdsc *pdsc, int index)\n{\n\tstruct pdsc_intr_info *intr_info;\n\n\tif (index >= pdsc->nintrs || index < 0) {\n\t\tWARN(true, \"bad intr index %d\\n\", index);\n\t\treturn;\n\t}\n\n\tintr_info = &pdsc->intr_info[index];\n\tif (!intr_info->vector)\n\t\treturn;\n\tdev_dbg(pdsc->dev, \"%s: idx %d vec %d name %s\\n\",\n\t\t__func__, index, intr_info->vector, intr_info->name);\n\n\tpds_core_intr_mask(&pdsc->intr_ctrl[index], PDS_CORE_INTR_MASK_SET);\n\tpds_core_intr_clean(&pdsc->intr_ctrl[index]);\n\n\tfree_irq(intr_info->vector, intr_info->data);\n\n\tmemset(intr_info, 0, sizeof(*intr_info));\n}\n\nint pdsc_intr_alloc(struct pdsc *pdsc, char *name,\n\t\t    irq_handler_t handler, void *data)\n{\n\tstruct pdsc_intr_info *intr_info;\n\tunsigned int index;\n\tint err;\n\n\t \n\tfor (index = 0; index < pdsc->nintrs; index++)\n\t\tif (!pdsc->intr_info[index].vector)\n\t\t\tbreak;\n\tif (index >= pdsc->nintrs) {\n\t\tdev_warn(pdsc->dev, \"%s: no intr, index=%d nintrs=%d\\n\",\n\t\t\t __func__, index, pdsc->nintrs);\n\t\treturn -ENOSPC;\n\t}\n\n\tpds_core_intr_clean_flags(&pdsc->intr_ctrl[index],\n\t\t\t\t  PDS_CORE_INTR_CRED_RESET_COALESCE);\n\n\tintr_info = &pdsc->intr_info[index];\n\n\tintr_info->index = index;\n\tintr_info->data = data;\n\tstrscpy(intr_info->name, name, sizeof(intr_info->name));\n\n\t \n\terr = pci_irq_vector(pdsc->pdev, index);\n\tif (err < 0) {\n\t\tdev_err(pdsc->dev, \"failed to get intr vector index %d: %pe\\n\",\n\t\t\tindex, ERR_PTR(err));\n\t\tgoto err_out_free_intr;\n\t}\n\tintr_info->vector = err;\n\n\t \n\tpds_core_intr_clean(&pdsc->intr_ctrl[index]);\n\tpds_core_intr_mask_assert(&pdsc->intr_ctrl[index], 1);\n\tpds_core_intr_mask(&pdsc->intr_ctrl[index], PDS_CORE_INTR_MASK_SET);\n\n\t \n\terr = request_irq(intr_info->vector, handler, 0, intr_info->name, data);\n\tif (err) {\n\t\tdev_err(pdsc->dev, \"failed to get intr irq vector %d: %pe\\n\",\n\t\t\tintr_info->vector, ERR_PTR(err));\n\t\tgoto err_out_free_intr;\n\t}\n\n\treturn index;\n\nerr_out_free_intr:\n\tpdsc_intr_free(pdsc, index);\n\treturn err;\n}\n\nstatic void pdsc_qcq_intr_free(struct pdsc *pdsc, struct pdsc_qcq *qcq)\n{\n\tif (!(qcq->flags & PDS_CORE_QCQ_F_INTR) ||\n\t    qcq->intx == PDS_CORE_INTR_INDEX_NOT_ASSIGNED)\n\t\treturn;\n\n\tpdsc_intr_free(pdsc, qcq->intx);\n\tqcq->intx = PDS_CORE_INTR_INDEX_NOT_ASSIGNED;\n}\n\nstatic int pdsc_qcq_intr_alloc(struct pdsc *pdsc, struct pdsc_qcq *qcq)\n{\n\tchar name[PDSC_INTR_NAME_MAX_SZ];\n\tint index;\n\n\tif (!(qcq->flags & PDS_CORE_QCQ_F_INTR)) {\n\t\tqcq->intx = PDS_CORE_INTR_INDEX_NOT_ASSIGNED;\n\t\treturn 0;\n\t}\n\n\tsnprintf(name, sizeof(name), \"%s-%d-%s\",\n\t\t PDS_CORE_DRV_NAME, pdsc->pdev->bus->number, qcq->q.name);\n\tindex = pdsc_intr_alloc(pdsc, name, pdsc_adminq_isr, qcq);\n\tif (index < 0)\n\t\treturn index;\n\tqcq->intx = index;\n\n\treturn 0;\n}\n\nvoid pdsc_qcq_free(struct pdsc *pdsc, struct pdsc_qcq *qcq)\n{\n\tstruct device *dev = pdsc->dev;\n\n\tif (!(qcq && qcq->pdsc))\n\t\treturn;\n\n\tpdsc_debugfs_del_qcq(qcq);\n\n\tpdsc_qcq_intr_free(pdsc, qcq);\n\n\tif (qcq->q_base)\n\t\tdma_free_coherent(dev, qcq->q_size,\n\t\t\t\t  qcq->q_base, qcq->q_base_pa);\n\n\tif (qcq->cq_base)\n\t\tdma_free_coherent(dev, qcq->cq_size,\n\t\t\t\t  qcq->cq_base, qcq->cq_base_pa);\n\n\tif (qcq->cq.info)\n\t\tvfree(qcq->cq.info);\n\n\tif (qcq->q.info)\n\t\tvfree(qcq->q.info);\n\n\tmemset(qcq, 0, sizeof(*qcq));\n}\n\nstatic void pdsc_q_map(struct pdsc_queue *q, void *base, dma_addr_t base_pa)\n{\n\tstruct pdsc_q_info *cur;\n\tunsigned int i;\n\n\tq->base = base;\n\tq->base_pa = base_pa;\n\n\tfor (i = 0, cur = q->info; i < q->num_descs; i++, cur++)\n\t\tcur->desc = base + (i * q->desc_size);\n}\n\nstatic void pdsc_cq_map(struct pdsc_cq *cq, void *base, dma_addr_t base_pa)\n{\n\tstruct pdsc_cq_info *cur;\n\tunsigned int i;\n\n\tcq->base = base;\n\tcq->base_pa = base_pa;\n\n\tfor (i = 0, cur = cq->info; i < cq->num_descs; i++, cur++)\n\t\tcur->comp = base + (i * cq->desc_size);\n}\n\nint pdsc_qcq_alloc(struct pdsc *pdsc, unsigned int type, unsigned int index,\n\t\t   const char *name, unsigned int flags, unsigned int num_descs,\n\t\t   unsigned int desc_size, unsigned int cq_desc_size,\n\t\t   unsigned int pid, struct pdsc_qcq *qcq)\n{\n\tstruct device *dev = pdsc->dev;\n\tvoid *q_base, *cq_base;\n\tdma_addr_t cq_base_pa;\n\tdma_addr_t q_base_pa;\n\tint err;\n\n\tqcq->q.info = vcalloc(num_descs, sizeof(*qcq->q.info));\n\tif (!qcq->q.info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tqcq->pdsc = pdsc;\n\tqcq->flags = flags;\n\tINIT_WORK(&qcq->work, pdsc_work_thread);\n\n\tqcq->q.type = type;\n\tqcq->q.index = index;\n\tqcq->q.num_descs = num_descs;\n\tqcq->q.desc_size = desc_size;\n\tqcq->q.tail_idx = 0;\n\tqcq->q.head_idx = 0;\n\tqcq->q.pid = pid;\n\tsnprintf(qcq->q.name, sizeof(qcq->q.name), \"%s%u\", name, index);\n\n\terr = pdsc_qcq_intr_alloc(pdsc, qcq);\n\tif (err)\n\t\tgoto err_out_free_q_info;\n\n\tqcq->cq.info = vcalloc(num_descs, sizeof(*qcq->cq.info));\n\tif (!qcq->cq.info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_irq;\n\t}\n\n\tqcq->cq.bound_intr = &pdsc->intr_info[qcq->intx];\n\tqcq->cq.num_descs = num_descs;\n\tqcq->cq.desc_size = cq_desc_size;\n\tqcq->cq.tail_idx = 0;\n\tqcq->cq.done_color = 1;\n\n\tif (flags & PDS_CORE_QCQ_F_NOTIFYQ) {\n\t\t \n\t\tqcq->q_size = PDS_PAGE_SIZE +\n\t\t\t      ALIGN(num_descs * desc_size, PDS_PAGE_SIZE) +\n\t\t\t      ALIGN(num_descs * cq_desc_size, PDS_PAGE_SIZE);\n\t\tqcq->q_base = dma_alloc_coherent(dev,\n\t\t\t\t\t\t qcq->q_size + qcq->cq_size,\n\t\t\t\t\t\t &qcq->q_base_pa,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!qcq->q_base) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free_cq_info;\n\t\t}\n\t\tq_base = PTR_ALIGN(qcq->q_base, PDS_PAGE_SIZE);\n\t\tq_base_pa = ALIGN(qcq->q_base_pa, PDS_PAGE_SIZE);\n\t\tpdsc_q_map(&qcq->q, q_base, q_base_pa);\n\n\t\tcq_base = PTR_ALIGN(q_base +\n\t\t\t\t    ALIGN(num_descs * desc_size, PDS_PAGE_SIZE),\n\t\t\t\t    PDS_PAGE_SIZE);\n\t\tcq_base_pa = ALIGN(qcq->q_base_pa +\n\t\t\t\t   ALIGN(num_descs * desc_size, PDS_PAGE_SIZE),\n\t\t\t\t   PDS_PAGE_SIZE);\n\n\t} else {\n\t\t \n\t\tqcq->q_size = PDS_PAGE_SIZE + (num_descs * desc_size);\n\t\tqcq->q_base = dma_alloc_coherent(dev, qcq->q_size,\n\t\t\t\t\t\t &qcq->q_base_pa,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!qcq->q_base) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free_cq_info;\n\t\t}\n\t\tq_base = PTR_ALIGN(qcq->q_base, PDS_PAGE_SIZE);\n\t\tq_base_pa = ALIGN(qcq->q_base_pa, PDS_PAGE_SIZE);\n\t\tpdsc_q_map(&qcq->q, q_base, q_base_pa);\n\n\t\t \n\t\tqcq->cq_size = PDS_PAGE_SIZE + (num_descs * cq_desc_size);\n\t\tqcq->cq_base = dma_alloc_coherent(dev, qcq->cq_size,\n\t\t\t\t\t\t  &qcq->cq_base_pa,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!qcq->cq_base) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free_q;\n\t\t}\n\t\tcq_base = PTR_ALIGN(qcq->cq_base, PDS_PAGE_SIZE);\n\t\tcq_base_pa = ALIGN(qcq->cq_base_pa, PDS_PAGE_SIZE);\n\t}\n\n\tpdsc_cq_map(&qcq->cq, cq_base, cq_base_pa);\n\tqcq->cq.bound_q = &qcq->q;\n\n\tpdsc_debugfs_add_qcq(pdsc, qcq);\n\n\treturn 0;\n\nerr_out_free_q:\n\tdma_free_coherent(dev, qcq->q_size, qcq->q_base, qcq->q_base_pa);\nerr_out_free_cq_info:\n\tvfree(qcq->cq.info);\nerr_out_free_irq:\n\tpdsc_qcq_intr_free(pdsc, qcq);\nerr_out_free_q_info:\n\tvfree(qcq->q.info);\n\tmemset(qcq, 0, sizeof(*qcq));\nerr_out:\n\tdev_err(dev, \"qcq alloc of %s%d failed %d\\n\", name, index, err);\n\treturn err;\n}\n\nstatic int pdsc_core_init(struct pdsc *pdsc)\n{\n\tunion pds_core_dev_comp comp = {};\n\tunion pds_core_dev_cmd cmd = {\n\t\t.init.opcode = PDS_CORE_CMD_INIT,\n\t};\n\tstruct pds_core_dev_init_data_out cido;\n\tstruct pds_core_dev_init_data_in cidi;\n\tu32 dbid_count;\n\tu32 dbpage_num;\n\tsize_t sz;\n\tint err;\n\n\tcidi.adminq_q_base = cpu_to_le64(pdsc->adminqcq.q_base_pa);\n\tcidi.adminq_cq_base = cpu_to_le64(pdsc->adminqcq.cq_base_pa);\n\tcidi.notifyq_cq_base = cpu_to_le64(pdsc->notifyqcq.cq.base_pa);\n\tcidi.flags = cpu_to_le32(PDS_CORE_QINIT_F_IRQ | PDS_CORE_QINIT_F_ENA);\n\tcidi.intr_index = cpu_to_le16(pdsc->adminqcq.intx);\n\tcidi.adminq_ring_size = ilog2(pdsc->adminqcq.q.num_descs);\n\tcidi.notifyq_ring_size = ilog2(pdsc->notifyqcq.q.num_descs);\n\n\tmutex_lock(&pdsc->devcmd_lock);\n\n\tsz = min_t(size_t, sizeof(cidi), sizeof(pdsc->cmd_regs->data));\n\tmemcpy_toio(&pdsc->cmd_regs->data, &cidi, sz);\n\n\terr = pdsc_devcmd_locked(pdsc, &cmd, &comp, pdsc->devcmd_timeout);\n\tif (!err) {\n\t\tsz = min_t(size_t, sizeof(cido), sizeof(pdsc->cmd_regs->data));\n\t\tmemcpy_fromio(&cido, &pdsc->cmd_regs->data, sz);\n\t}\n\n\tmutex_unlock(&pdsc->devcmd_lock);\n\tif (err) {\n\t\tdev_err(pdsc->dev, \"Device init command failed: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tpdsc->hw_index = le32_to_cpu(cido.core_hw_index);\n\n\tdbid_count = le32_to_cpu(pdsc->dev_ident.ndbpgs_per_lif);\n\tdbpage_num = pdsc->hw_index * dbid_count;\n\tpdsc->kern_dbpage = pdsc_map_dbpage(pdsc, dbpage_num);\n\tif (!pdsc->kern_dbpage) {\n\t\tdev_err(pdsc->dev, \"Cannot map dbpage, aborting\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpdsc->adminqcq.q.hw_type = cido.adminq_hw_type;\n\tpdsc->adminqcq.q.hw_index = le32_to_cpu(cido.adminq_hw_index);\n\tpdsc->adminqcq.q.dbval = PDS_CORE_DBELL_QID(pdsc->adminqcq.q.hw_index);\n\n\tpdsc->notifyqcq.q.hw_type = cido.notifyq_hw_type;\n\tpdsc->notifyqcq.q.hw_index = le32_to_cpu(cido.notifyq_hw_index);\n\tpdsc->notifyqcq.q.dbval = PDS_CORE_DBELL_QID(pdsc->notifyqcq.q.hw_index);\n\n\tpdsc->last_eid = 0;\n\n\treturn err;\n}\n\nstatic struct pdsc_viftype pdsc_viftype_defaults[] = {\n\t[PDS_DEV_TYPE_VDPA] = { .name = PDS_DEV_TYPE_VDPA_STR,\n\t\t\t\t.vif_id = PDS_DEV_TYPE_VDPA,\n\t\t\t\t.dl_id = DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET },\n\t[PDS_DEV_TYPE_MAX] = {}\n};\n\nstatic int pdsc_viftypes_init(struct pdsc *pdsc)\n{\n\tenum pds_core_vif_types vt;\n\n\tpdsc->viftype_status = kzalloc(sizeof(pdsc_viftype_defaults),\n\t\t\t\t       GFP_KERNEL);\n\tif (!pdsc->viftype_status)\n\t\treturn -ENOMEM;\n\n\tfor (vt = 0; vt < PDS_DEV_TYPE_MAX; vt++) {\n\t\tbool vt_support;\n\n\t\tif (!pdsc_viftype_defaults[vt].name)\n\t\t\tcontinue;\n\n\t\t \n\t\tpdsc->viftype_status[vt] = pdsc_viftype_defaults[vt];\n\n\t\t \n\t\tvt_support = !!le16_to_cpu(pdsc->dev_ident.vif_types[vt]);\n\t\tdev_dbg(pdsc->dev, \"VIF %s is %ssupported\\n\",\n\t\t\tpdsc->viftype_status[vt].name,\n\t\t\tvt_support ? \"\" : \"not \");\n\n\t\tpdsc->viftype_status[vt].supported = vt_support;\n\t}\n\n\treturn 0;\n}\n\nint pdsc_setup(struct pdsc *pdsc, bool init)\n{\n\tint numdescs;\n\tint err;\n\n\tif (init)\n\t\terr = pdsc_dev_init(pdsc);\n\telse\n\t\terr = pdsc_dev_reinit(pdsc);\n\tif (err)\n\t\treturn err;\n\n\t \n\tnumdescs = max_t(int, PDSC_ADMINQ_MIN_LENGTH, num_online_cpus());\n\tnumdescs += 2 * pci_sriov_get_totalvfs(pdsc->pdev);\n\tnumdescs = roundup_pow_of_two(numdescs);\n\terr = pdsc_qcq_alloc(pdsc, PDS_CORE_QTYPE_ADMINQ, 0, \"adminq\",\n\t\t\t     PDS_CORE_QCQ_F_CORE | PDS_CORE_QCQ_F_INTR,\n\t\t\t     numdescs,\n\t\t\t     sizeof(union pds_core_adminq_cmd),\n\t\t\t     sizeof(union pds_core_adminq_comp),\n\t\t\t     0, &pdsc->adminqcq);\n\tif (err)\n\t\tgoto err_out_teardown;\n\n\terr = pdsc_qcq_alloc(pdsc, PDS_CORE_QTYPE_NOTIFYQ, 0, \"notifyq\",\n\t\t\t     PDS_CORE_QCQ_F_NOTIFYQ,\n\t\t\t     PDSC_NOTIFYQ_LENGTH,\n\t\t\t     sizeof(struct pds_core_notifyq_cmd),\n\t\t\t     sizeof(union pds_core_notifyq_comp),\n\t\t\t     0, &pdsc->notifyqcq);\n\tif (err)\n\t\tgoto err_out_teardown;\n\n\t \n\tpdsc->notifyqcq.intx = pdsc->adminqcq.intx;\n\n\t \n\terr = pdsc_core_init(pdsc);\n\tif (err)\n\t\tgoto err_out_teardown;\n\n\t \n\terr = pdsc_viftypes_init(pdsc);\n\tif (err)\n\t\tgoto err_out_teardown;\n\n\tif (init)\n\t\tpdsc_debugfs_add_viftype(pdsc);\n\n\tclear_bit(PDSC_S_FW_DEAD, &pdsc->state);\n\treturn 0;\n\nerr_out_teardown:\n\tpdsc_teardown(pdsc, init);\n\treturn err;\n}\n\nvoid pdsc_teardown(struct pdsc *pdsc, bool removing)\n{\n\tint i;\n\n\tif (!pdsc->pdev->is_virtfn)\n\t\tpdsc_devcmd_reset(pdsc);\n\tpdsc_qcq_free(pdsc, &pdsc->notifyqcq);\n\tpdsc_qcq_free(pdsc, &pdsc->adminqcq);\n\n\tkfree(pdsc->viftype_status);\n\tpdsc->viftype_status = NULL;\n\n\tif (pdsc->intr_info) {\n\t\tfor (i = 0; i < pdsc->nintrs; i++)\n\t\t\tpdsc_intr_free(pdsc, i);\n\n\t\tif (removing) {\n\t\t\tkfree(pdsc->intr_info);\n\t\t\tpdsc->intr_info = NULL;\n\t\t}\n\t}\n\n\tif (pdsc->kern_dbpage) {\n\t\tiounmap(pdsc->kern_dbpage);\n\t\tpdsc->kern_dbpage = NULL;\n\t}\n\n\tset_bit(PDSC_S_FW_DEAD, &pdsc->state);\n}\n\nint pdsc_start(struct pdsc *pdsc)\n{\n\tpds_core_intr_mask(&pdsc->intr_ctrl[pdsc->adminqcq.intx],\n\t\t\t   PDS_CORE_INTR_MASK_CLEAR);\n\n\treturn 0;\n}\n\nvoid pdsc_stop(struct pdsc *pdsc)\n{\n\tint i;\n\n\tif (!pdsc->intr_info)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < pdsc->nintrs; i++)\n\t\tif (pdsc->intr_info[i].vector)\n\t\t\tpds_core_intr_mask(&pdsc->intr_ctrl[i],\n\t\t\t\t\t   PDS_CORE_INTR_MASK_SET);\n}\n\nstatic void pdsc_fw_down(struct pdsc *pdsc)\n{\n\tunion pds_core_notifyq_comp reset_event = {\n\t\t.reset.ecode = cpu_to_le16(PDS_EVENT_RESET),\n\t\t.reset.state = 0,\n\t};\n\n\tif (test_and_set_bit(PDSC_S_FW_DEAD, &pdsc->state)) {\n\t\tdev_err(pdsc->dev, \"%s: already happening\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tif (pdsc->fw_reporter)\n\t\tdevlink_health_report(pdsc->fw_reporter, \"FW down reported\", pdsc);\n\tpdsc_notify(PDS_EVENT_RESET, &reset_event);\n\n\tpdsc_stop(pdsc);\n\tpdsc_teardown(pdsc, PDSC_TEARDOWN_RECOVERY);\n}\n\nstatic void pdsc_fw_up(struct pdsc *pdsc)\n{\n\tunion pds_core_notifyq_comp reset_event = {\n\t\t.reset.ecode = cpu_to_le16(PDS_EVENT_RESET),\n\t\t.reset.state = 1,\n\t};\n\tint err;\n\n\tif (!test_bit(PDSC_S_FW_DEAD, &pdsc->state)) {\n\t\tdev_err(pdsc->dev, \"%s: fw not dead\\n\", __func__);\n\t\treturn;\n\t}\n\n\terr = pdsc_setup(pdsc, PDSC_SETUP_RECOVERY);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = pdsc_start(pdsc);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tpdsc->fw_recoveries++;\n\tif (pdsc->fw_reporter)\n\t\tdevlink_health_reporter_state_update(pdsc->fw_reporter,\n\t\t\t\t\t\t     DEVLINK_HEALTH_REPORTER_STATE_HEALTHY);\n\tpdsc_notify(PDS_EVENT_RESET, &reset_event);\n\n\treturn;\n\nerr_out:\n\tpdsc_teardown(pdsc, PDSC_TEARDOWN_RECOVERY);\n}\n\nvoid pdsc_health_thread(struct work_struct *work)\n{\n\tstruct pdsc *pdsc = container_of(work, struct pdsc, health_work);\n\tunsigned long mask;\n\tbool healthy;\n\n\tmutex_lock(&pdsc->config_lock);\n\n\t \n\tmask = BIT_ULL(PDSC_S_INITING_DRIVER) |\n\t       BIT_ULL(PDSC_S_STOPPING_DRIVER);\n\tif (pdsc->state & mask)\n\t\tgoto out_unlock;\n\n\thealthy = pdsc_is_fw_good(pdsc);\n\tdev_dbg(pdsc->dev, \"%s: health %d fw_status %#02x fw_heartbeat %d\\n\",\n\t\t__func__, healthy, pdsc->fw_status, pdsc->last_hb);\n\n\tif (test_bit(PDSC_S_FW_DEAD, &pdsc->state)) {\n\t\tif (healthy)\n\t\t\tpdsc_fw_up(pdsc);\n\t} else {\n\t\tif (!healthy)\n\t\t\tpdsc_fw_down(pdsc);\n\t}\n\n\tpdsc->fw_generation = pdsc->fw_status & PDS_CORE_FW_STS_F_GENERATION;\n\nout_unlock:\n\tmutex_unlock(&pdsc->config_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}