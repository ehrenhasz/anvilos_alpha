{
  "module_name": "devlink.c",
  "hash_id": "2425a9111ad2a755cad396de159dc470ee3f7de6a20e0774ab653f20fde1225d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pds_core/devlink.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include <linux/pds/pds_auxbus.h>\n\nstatic struct\npdsc_viftype *pdsc_dl_find_viftype_by_id(struct pdsc *pdsc,\n\t\t\t\t\t enum devlink_param_type dl_id)\n{\n\tint vt;\n\n\tif (!pdsc->viftype_status)\n\t\treturn NULL;\n\n\tfor (vt = 0; vt < PDS_DEV_TYPE_MAX; vt++) {\n\t\tif (pdsc->viftype_status[vt].dl_id == dl_id)\n\t\t\treturn &pdsc->viftype_status[vt];\n\t}\n\n\treturn NULL;\n}\n\nint pdsc_dl_enable_get(struct devlink *dl, u32 id,\n\t\t       struct devlink_param_gset_ctx *ctx)\n{\n\tstruct pdsc *pdsc = devlink_priv(dl);\n\tstruct pdsc_viftype *vt_entry;\n\n\tvt_entry = pdsc_dl_find_viftype_by_id(pdsc, id);\n\tif (!vt_entry)\n\t\treturn -ENOENT;\n\n\tctx->val.vbool = vt_entry->enabled;\n\n\treturn 0;\n}\n\nint pdsc_dl_enable_set(struct devlink *dl, u32 id,\n\t\t       struct devlink_param_gset_ctx *ctx)\n{\n\tstruct pdsc *pdsc = devlink_priv(dl);\n\tstruct pdsc_viftype *vt_entry;\n\tint err = 0;\n\tint vf_id;\n\n\tvt_entry = pdsc_dl_find_viftype_by_id(pdsc, id);\n\tif (!vt_entry || !vt_entry->supported)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vt_entry->enabled == ctx->val.vbool)\n\t\treturn 0;\n\n\tvt_entry->enabled = ctx->val.vbool;\n\tfor (vf_id = 0; vf_id < pdsc->num_vfs; vf_id++) {\n\t\tstruct pdsc *vf = pdsc->vfs[vf_id].vf;\n\n\t\terr = ctx->val.vbool ? pdsc_auxbus_dev_add(vf, pdsc) :\n\t\t\t\t       pdsc_auxbus_dev_del(vf, pdsc);\n\t}\n\n\treturn err;\n}\n\nint pdsc_dl_enable_validate(struct devlink *dl, u32 id,\n\t\t\t    union devlink_param_value val,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct pdsc *pdsc = devlink_priv(dl);\n\tstruct pdsc_viftype *vt_entry;\n\n\tvt_entry = pdsc_dl_find_viftype_by_id(pdsc, id);\n\tif (!vt_entry || !vt_entry->supported)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!pdsc->viftype_status[vt_entry->vif_id].supported)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nint pdsc_dl_flash_update(struct devlink *dl,\n\t\t\t struct devlink_flash_update_params *params,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct pdsc *pdsc = devlink_priv(dl);\n\n\treturn pdsc_firmware_update(pdsc, params->fw, extack);\n}\n\nstatic char *fw_slotnames[] = {\n\t\"fw.goldfw\",\n\t\"fw.mainfwa\",\n\t\"fw.mainfwb\",\n};\n\nint pdsc_dl_info_get(struct devlink *dl, struct devlink_info_req *req,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tunion pds_core_dev_cmd cmd = {\n\t\t.fw_control.opcode = PDS_CORE_CMD_FW_CONTROL,\n\t\t.fw_control.oper = PDS_CORE_FW_GET_LIST,\n\t};\n\tstruct pds_core_fw_list_info fw_list;\n\tstruct pdsc *pdsc = devlink_priv(dl);\n\tunion pds_core_dev_comp comp;\n\tchar buf[32];\n\tint listlen;\n\tint err;\n\tint i;\n\n\tmutex_lock(&pdsc->devcmd_lock);\n\terr = pdsc_devcmd_locked(pdsc, &cmd, &comp, pdsc->devcmd_timeout * 2);\n\tmemcpy_fromio(&fw_list, pdsc->cmd_regs->data, sizeof(fw_list));\n\tmutex_unlock(&pdsc->devcmd_lock);\n\tif (err && err != -EIO)\n\t\treturn err;\n\n\tlistlen = fw_list.num_fw_slots;\n\tfor (i = 0; i < listlen; i++) {\n\t\tif (i < ARRAY_SIZE(fw_slotnames))\n\t\t\tstrscpy(buf, fw_slotnames[i], sizeof(buf));\n\t\telse\n\t\t\tsnprintf(buf, sizeof(buf), \"fw.slot_%d\", i);\n\t\terr = devlink_info_version_stored_put(req, buf,\n\t\t\t\t\t\t      fw_list.fw_names[i].fw_version);\n\t}\n\n\terr = devlink_info_version_running_put(req,\n\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_FW,\n\t\t\t\t\t       pdsc->dev_info.fw_version);\n\tif (err)\n\t\treturn err;\n\n\tsnprintf(buf, sizeof(buf), \"0x%x\", pdsc->dev_info.asic_type);\n\terr = devlink_info_version_fixed_put(req,\n\t\t\t\t\t     DEVLINK_INFO_VERSION_GENERIC_ASIC_ID,\n\t\t\t\t\t     buf);\n\tif (err)\n\t\treturn err;\n\n\tsnprintf(buf, sizeof(buf), \"0x%x\", pdsc->dev_info.asic_rev);\n\terr = devlink_info_version_fixed_put(req,\n\t\t\t\t\t     DEVLINK_INFO_VERSION_GENERIC_ASIC_REV,\n\t\t\t\t\t     buf);\n\tif (err)\n\t\treturn err;\n\n\treturn devlink_info_serial_number_put(req, pdsc->dev_info.serial_num);\n}\n\nint pdsc_fw_reporter_diagnose(struct devlink_health_reporter *reporter,\n\t\t\t      struct devlink_fmsg *fmsg,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct pdsc *pdsc = devlink_health_reporter_priv(reporter);\n\tint err;\n\n\tmutex_lock(&pdsc->config_lock);\n\n\tif (test_bit(PDSC_S_FW_DEAD, &pdsc->state))\n\t\terr = devlink_fmsg_string_pair_put(fmsg, \"Status\", \"dead\");\n\telse if (!pdsc_is_fw_good(pdsc))\n\t\terr = devlink_fmsg_string_pair_put(fmsg, \"Status\", \"unhealthy\");\n\telse\n\t\terr = devlink_fmsg_string_pair_put(fmsg, \"Status\", \"healthy\");\n\n\tmutex_unlock(&pdsc->config_lock);\n\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"State\",\n\t\t\t\t\tpdsc->fw_status &\n\t\t\t\t\t\t~PDS_CORE_FW_STS_F_GENERATION);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"Generation\",\n\t\t\t\t\tpdsc->fw_generation >> 4);\n\tif (err)\n\t\treturn err;\n\n\treturn devlink_fmsg_u32_pair_put(fmsg, \"Recoveries\",\n\t\t\t\t\t pdsc->fw_recoveries);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}