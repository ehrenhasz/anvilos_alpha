{
  "module_name": "main.c",
  "hash_id": "3ad7cc314d94549cbecd5bf345e3aa99d7a3f7af7caadfedc8487e30f68db5c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pds_core/main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/pci.h>\n\n#include <linux/pds/pds_common.h>\n\n#include \"core.h\"\n\nMODULE_DESCRIPTION(PDSC_DRV_DESCRIPTION);\nMODULE_AUTHOR(\"Advanced Micro Devices, Inc\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic const struct pci_device_id pdsc_id_table[] = {\n\t{ PCI_VDEVICE(PENSANDO, PCI_DEVICE_ID_PENSANDO_CORE_PF) },\n\t{ PCI_VDEVICE(PENSANDO, PCI_DEVICE_ID_PENSANDO_VDPA_VF) },\n\t{ 0, }\t \n};\nMODULE_DEVICE_TABLE(pci, pdsc_id_table);\n\nstatic void pdsc_wdtimer_cb(struct timer_list *t)\n{\n\tstruct pdsc *pdsc = from_timer(pdsc, t, wdtimer);\n\n\tdev_dbg(pdsc->dev, \"%s: jiffies %ld\\n\", __func__, jiffies);\n\tmod_timer(&pdsc->wdtimer,\n\t\t  round_jiffies(jiffies + pdsc->wdtimer_period));\n\n\tqueue_work(pdsc->wq, &pdsc->health_work);\n}\n\nstatic void pdsc_unmap_bars(struct pdsc *pdsc)\n{\n\tstruct pdsc_dev_bar *bars = pdsc->bars;\n\tunsigned int i;\n\n\tfor (i = 0; i < PDS_CORE_BARS_MAX; i++) {\n\t\tif (bars[i].vaddr)\n\t\t\tpci_iounmap(pdsc->pdev, bars[i].vaddr);\n\t}\n}\n\nstatic int pdsc_map_bars(struct pdsc *pdsc)\n{\n\tstruct pdsc_dev_bar *bar = pdsc->bars;\n\tstruct pci_dev *pdev = pdsc->pdev;\n\tstruct device *dev = pdsc->dev;\n\tstruct pdsc_dev_bar *bars;\n\tunsigned int i, j;\n\tint num_bars = 0;\n\tint err;\n\tu32 sig;\n\n\tbars = pdsc->bars;\n\n\t \n\tfor (i = 0, j = 0; i < PDS_CORE_BARS_MAX; i++) {\n\t\tif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\n\t\t\tcontinue;\n\n\t\tbars[j].len = pci_resource_len(pdev, i);\n\t\tbars[j].bus_addr = pci_resource_start(pdev, i);\n\t\tbars[j].res_index = i;\n\n\t\t \n\t\tif (j > 0) {\n\t\t\tbars[j].vaddr = NULL;\n\t\t} else {\n\t\t\tbars[j].vaddr = pci_iomap(pdev, i, bars[j].len);\n\t\t\tif (!bars[j].vaddr) {\n\t\t\t\tdev_err(dev, \"Cannot map BAR %d, aborting\\n\", i);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\n\t\tj++;\n\t}\n\tnum_bars = j;\n\n\t \n\tif (num_bars < 1) {\n\t\tdev_err(dev, \"No bars found\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_out;\n\t}\n\n\tif (bar->len < PDS_CORE_BAR0_SIZE) {\n\t\tdev_err(dev, \"Resource bar size %lu too small\\n\", bar->len);\n\t\terr = -EFAULT;\n\t\tgoto err_out;\n\t}\n\n\tpdsc->info_regs = bar->vaddr + PDS_CORE_BAR0_DEV_INFO_REGS_OFFSET;\n\tpdsc->cmd_regs = bar->vaddr + PDS_CORE_BAR0_DEV_CMD_REGS_OFFSET;\n\tpdsc->intr_status = bar->vaddr + PDS_CORE_BAR0_INTR_STATUS_OFFSET;\n\tpdsc->intr_ctrl = bar->vaddr + PDS_CORE_BAR0_INTR_CTRL_OFFSET;\n\n\tsig = ioread32(&pdsc->info_regs->signature);\n\tif (sig != PDS_CORE_DEV_INFO_SIGNATURE) {\n\t\tdev_err(dev, \"Incompatible firmware signature %x\", sig);\n\t\terr = -EFAULT;\n\t\tgoto err_out;\n\t}\n\n\t \n\tbar++;\n\tif (num_bars < 2) {\n\t\tdev_err(dev, \"Doorbell bar missing\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_out;\n\t}\n\n\tpdsc->db_pages = bar->vaddr;\n\tpdsc->phy_db_pages = bar->bus_addr;\n\n\treturn 0;\n\nerr_out:\n\tpdsc_unmap_bars(pdsc);\n\treturn err;\n}\n\nvoid __iomem *pdsc_map_dbpage(struct pdsc *pdsc, int page_num)\n{\n\treturn pci_iomap_range(pdsc->pdev,\n\t\t\t       pdsc->bars[PDS_CORE_PCI_BAR_DBELL].res_index,\n\t\t\t       (u64)page_num << PAGE_SHIFT, PAGE_SIZE);\n}\n\nstatic int pdsc_sriov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct pdsc *pdsc = pci_get_drvdata(pdev);\n\tstruct device *dev = pdsc->dev;\n\tint ret = 0;\n\n\tif (num_vfs > 0) {\n\t\tpdsc->vfs = kcalloc(num_vfs, sizeof(struct pdsc_vf),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!pdsc->vfs)\n\t\t\treturn -ENOMEM;\n\t\tpdsc->num_vfs = num_vfs;\n\n\t\tret = pci_enable_sriov(pdev, num_vfs);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot enable SRIOV: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\t\tgoto no_vfs;\n\t\t}\n\n\t\treturn num_vfs;\n\t}\n\nno_vfs:\n\tpci_disable_sriov(pdev);\n\n\tkfree(pdsc->vfs);\n\tpdsc->vfs = NULL;\n\tpdsc->num_vfs = 0;\n\n\treturn ret;\n}\n\nstatic int pdsc_init_vf(struct pdsc *vf)\n{\n\tstruct devlink *dl;\n\tstruct pdsc *pf;\n\tint err;\n\n\tpf = pdsc_get_pf_struct(vf->pdev);\n\tif (IS_ERR_OR_NULL(pf))\n\t\treturn PTR_ERR(pf) ?: -1;\n\n\tvf->vf_id = pci_iov_vf_id(vf->pdev);\n\n\tdl = priv_to_devlink(vf);\n\tdevl_lock(dl);\n\tdevl_register(dl);\n\tdevl_unlock(dl);\n\n\tpf->vfs[vf->vf_id].vf = vf;\n\terr = pdsc_auxbus_dev_add(vf, pf);\n\tif (err) {\n\t\tdevl_lock(dl);\n\t\tdevl_unregister(dl);\n\t\tdevl_unlock(dl);\n\t}\n\n\treturn err;\n}\n\nstatic const struct devlink_health_reporter_ops pdsc_fw_reporter_ops = {\n\t.name = \"fw\",\n\t.diagnose = pdsc_fw_reporter_diagnose,\n};\n\nstatic const struct devlink_param pdsc_dl_params[] = {\n\tDEVLINK_PARAM_GENERIC(ENABLE_VNET,\n\t\t\t      BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t      pdsc_dl_enable_get,\n\t\t\t      pdsc_dl_enable_set,\n\t\t\t      pdsc_dl_enable_validate),\n};\n\n#define PDSC_WQ_NAME_LEN 24\n\nstatic int pdsc_init_pf(struct pdsc *pdsc)\n{\n\tstruct devlink_health_reporter *hr;\n\tchar wq_name[PDSC_WQ_NAME_LEN];\n\tstruct devlink *dl;\n\tint err;\n\n\tpcie_print_link_status(pdsc->pdev);\n\n\terr = pci_request_regions(pdsc->pdev, PDS_CORE_DRV_NAME);\n\tif (err) {\n\t\tdev_err(pdsc->dev, \"Cannot request PCI regions: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\terr = pdsc_map_bars(pdsc);\n\tif (err)\n\t\tgoto err_out_release_regions;\n\n\t \n\tsnprintf(wq_name, sizeof(wq_name), \"%s.%d\", PDS_CORE_DRV_NAME, pdsc->uid);\n\tpdsc->wq = create_singlethread_workqueue(wq_name);\n\tINIT_WORK(&pdsc->health_work, pdsc_health_thread);\n\ttimer_setup(&pdsc->wdtimer, pdsc_wdtimer_cb, 0);\n\tpdsc->wdtimer_period = PDSC_WATCHDOG_SECS * HZ;\n\n\tmutex_init(&pdsc->devcmd_lock);\n\tmutex_init(&pdsc->config_lock);\n\tspin_lock_init(&pdsc->adminq_lock);\n\n\tmutex_lock(&pdsc->config_lock);\n\tset_bit(PDSC_S_FW_DEAD, &pdsc->state);\n\n\terr = pdsc_setup(pdsc, PDSC_SETUP_INIT);\n\tif (err) {\n\t\tmutex_unlock(&pdsc->config_lock);\n\t\tgoto err_out_unmap_bars;\n\t}\n\n\terr = pdsc_start(pdsc);\n\tif (err) {\n\t\tmutex_unlock(&pdsc->config_lock);\n\t\tgoto err_out_teardown;\n\t}\n\n\tmutex_unlock(&pdsc->config_lock);\n\n\tdl = priv_to_devlink(pdsc);\n\tdevl_lock(dl);\n\terr = devl_params_register(dl, pdsc_dl_params,\n\t\t\t\t   ARRAY_SIZE(pdsc_dl_params));\n\tif (err) {\n\t\tdevl_unlock(dl);\n\t\tdev_warn(pdsc->dev, \"Failed to register devlink params: %pe\\n\",\n\t\t\t ERR_PTR(err));\n\t\tgoto err_out_stop;\n\t}\n\n\thr = devl_health_reporter_create(dl, &pdsc_fw_reporter_ops, 0, pdsc);\n\tif (IS_ERR(hr)) {\n\t\tdevl_unlock(dl);\n\t\tdev_warn(pdsc->dev, \"Failed to create fw reporter: %pe\\n\", hr);\n\t\terr = PTR_ERR(hr);\n\t\tgoto err_out_unreg_params;\n\t}\n\tpdsc->fw_reporter = hr;\n\n\tdevl_register(dl);\n\tdevl_unlock(dl);\n\n\t \n\tmod_timer(&pdsc->wdtimer, round_jiffies(jiffies + pdsc->wdtimer_period));\n\n\treturn 0;\n\nerr_out_unreg_params:\n\tdevlink_params_unregister(dl, pdsc_dl_params,\n\t\t\t\t  ARRAY_SIZE(pdsc_dl_params));\nerr_out_stop:\n\tpdsc_stop(pdsc);\nerr_out_teardown:\n\tpdsc_teardown(pdsc, PDSC_TEARDOWN_REMOVING);\nerr_out_unmap_bars:\n\tdel_timer_sync(&pdsc->wdtimer);\n\tif (pdsc->wq)\n\t\tdestroy_workqueue(pdsc->wq);\n\tmutex_destroy(&pdsc->config_lock);\n\tmutex_destroy(&pdsc->devcmd_lock);\n\tpci_free_irq_vectors(pdsc->pdev);\n\tpdsc_unmap_bars(pdsc);\nerr_out_release_regions:\n\tpci_release_regions(pdsc->pdev);\n\n\treturn err;\n}\n\nstatic const struct devlink_ops pdsc_dl_ops = {\n\t.info_get\t= pdsc_dl_info_get,\n\t.flash_update\t= pdsc_dl_flash_update,\n};\n\nstatic const struct devlink_ops pdsc_dl_vf_ops = {\n};\n\nstatic DEFINE_IDA(pdsc_ida);\n\nstatic int pdsc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct devlink_ops *ops;\n\tstruct devlink *dl;\n\tstruct pdsc *pdsc;\n\tbool is_pf;\n\tint err;\n\n\tis_pf = !pdev->is_virtfn;\n\tops = is_pf ? &pdsc_dl_ops : &pdsc_dl_vf_ops;\n\tdl = devlink_alloc(ops, sizeof(struct pdsc), dev);\n\tif (!dl)\n\t\treturn -ENOMEM;\n\tpdsc = devlink_priv(dl);\n\n\tpdsc->pdev = pdev;\n\tpdsc->dev = &pdev->dev;\n\tset_bit(PDSC_S_INITING_DRIVER, &pdsc->state);\n\tpci_set_drvdata(pdev, pdsc);\n\tpdsc_debugfs_add_dev(pdsc);\n\n\terr = ida_alloc(&pdsc_ida, GFP_KERNEL);\n\tif (err < 0) {\n\t\tdev_err(pdsc->dev, \"%s: id alloc failed: %pe\\n\",\n\t\t\t__func__, ERR_PTR(err));\n\t\tgoto err_out_free_devlink;\n\t}\n\tpdsc->uid = err;\n\n\t \n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(PDS_CORE_ADDR_LEN));\n\tif (err) {\n\t\tdev_err(dev, \"Unable to obtain 64-bit DMA for consistent allocations, aborting: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\tgoto err_out_free_ida;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot enable PCI device: %pe\\n\", ERR_PTR(err));\n\t\tgoto err_out_free_ida;\n\t}\n\tpci_set_master(pdev);\n\n\tif (is_pf)\n\t\terr = pdsc_init_pf(pdsc);\n\telse\n\t\terr = pdsc_init_vf(pdsc);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot init device: %pe\\n\", ERR_PTR(err));\n\t\tgoto err_out_disable_device;\n\t}\n\n\tclear_bit(PDSC_S_INITING_DRIVER, &pdsc->state);\n\treturn 0;\n\nerr_out_disable_device:\n\tpci_disable_device(pdev);\nerr_out_free_ida:\n\tida_free(&pdsc_ida, pdsc->uid);\nerr_out_free_devlink:\n\tpdsc_debugfs_del_dev(pdsc);\n\tdevlink_free(dl);\n\n\treturn err;\n}\n\nstatic void pdsc_remove(struct pci_dev *pdev)\n{\n\tstruct pdsc *pdsc = pci_get_drvdata(pdev);\n\tstruct devlink *dl;\n\n\t \n\tdl = priv_to_devlink(pdsc);\n\tdevl_lock(dl);\n\tdevl_unregister(dl);\n\tif (!pdev->is_virtfn) {\n\t\tif (pdsc->fw_reporter) {\n\t\t\tdevl_health_reporter_destroy(pdsc->fw_reporter);\n\t\t\tpdsc->fw_reporter = NULL;\n\t\t}\n\t\tdevl_params_unregister(dl, pdsc_dl_params,\n\t\t\t\t       ARRAY_SIZE(pdsc_dl_params));\n\t}\n\tdevl_unlock(dl);\n\n\tif (pdev->is_virtfn) {\n\t\tstruct pdsc *pf;\n\n\t\tpf = pdsc_get_pf_struct(pdsc->pdev);\n\t\tif (!IS_ERR(pf)) {\n\t\t\tpdsc_auxbus_dev_del(pdsc, pf);\n\t\t\tpf->vfs[pdsc->vf_id].vf = NULL;\n\t\t}\n\t} else {\n\t\t \n\t\tpdsc_sriov_configure(pdev, 0);\n\n\t\tdel_timer_sync(&pdsc->wdtimer);\n\t\tif (pdsc->wq)\n\t\t\tdestroy_workqueue(pdsc->wq);\n\n\t\tmutex_lock(&pdsc->config_lock);\n\t\tset_bit(PDSC_S_STOPPING_DRIVER, &pdsc->state);\n\n\t\tpdsc_stop(pdsc);\n\t\tpdsc_teardown(pdsc, PDSC_TEARDOWN_REMOVING);\n\t\tmutex_unlock(&pdsc->config_lock);\n\t\tmutex_destroy(&pdsc->config_lock);\n\t\tmutex_destroy(&pdsc->devcmd_lock);\n\n\t\tpci_free_irq_vectors(pdev);\n\t\tpdsc_unmap_bars(pdsc);\n\t\tpci_release_regions(pdev);\n\t}\n\n\tpci_disable_device(pdev);\n\n\tida_free(&pdsc_ida, pdsc->uid);\n\tpdsc_debugfs_del_dev(pdsc);\n\tdevlink_free(dl);\n}\n\nstatic struct pci_driver pdsc_driver = {\n\t.name = PDS_CORE_DRV_NAME,\n\t.id_table = pdsc_id_table,\n\t.probe = pdsc_probe,\n\t.remove = pdsc_remove,\n\t.sriov_configure = pdsc_sriov_configure,\n};\n\nvoid *pdsc_get_pf_struct(struct pci_dev *vf_pdev)\n{\n\treturn pci_iov_get_pf_drvdata(vf_pdev, &pdsc_driver);\n}\nEXPORT_SYMBOL_GPL(pdsc_get_pf_struct);\n\nstatic int __init pdsc_init_module(void)\n{\n\tif (strcmp(KBUILD_MODNAME, PDS_CORE_DRV_NAME))\n\t\treturn -EINVAL;\n\n\tpdsc_debugfs_create();\n\treturn pci_register_driver(&pdsc_driver);\n}\n\nstatic void __exit pdsc_cleanup_module(void)\n{\n\tpci_unregister_driver(&pdsc_driver);\n\tpdsc_debugfs_destroy();\n}\n\nmodule_init(pdsc_init_module);\nmodule_exit(pdsc_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}