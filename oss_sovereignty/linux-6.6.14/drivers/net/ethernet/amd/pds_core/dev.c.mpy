{
  "module_name": "dev.c",
  "hash_id": "687323d7ac993f09cb55b3945b2fcef4a64fc95222cadc81f7587344eb95ce4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pds_core/dev.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/utsname.h>\n\n#include \"core.h\"\n\nint pdsc_err_to_errno(enum pds_core_status_code code)\n{\n\tswitch (code) {\n\tcase PDS_RC_SUCCESS:\n\t\treturn 0;\n\tcase PDS_RC_EVERSION:\n\tcase PDS_RC_EQTYPE:\n\tcase PDS_RC_EQID:\n\tcase PDS_RC_EINVAL:\n\tcase PDS_RC_ENOSUPP:\n\t\treturn -EINVAL;\n\tcase PDS_RC_EPERM:\n\t\treturn -EPERM;\n\tcase PDS_RC_ENOENT:\n\t\treturn -ENOENT;\n\tcase PDS_RC_EAGAIN:\n\t\treturn -EAGAIN;\n\tcase PDS_RC_ENOMEM:\n\t\treturn -ENOMEM;\n\tcase PDS_RC_EFAULT:\n\t\treturn -EFAULT;\n\tcase PDS_RC_EBUSY:\n\t\treturn -EBUSY;\n\tcase PDS_RC_EEXIST:\n\t\treturn -EEXIST;\n\tcase PDS_RC_EVFID:\n\t\treturn -ENODEV;\n\tcase PDS_RC_ECLIENT:\n\t\treturn -ECHILD;\n\tcase PDS_RC_ENOSPC:\n\t\treturn -ENOSPC;\n\tcase PDS_RC_ERANGE:\n\t\treturn -ERANGE;\n\tcase PDS_RC_BAD_ADDR:\n\t\treturn -EFAULT;\n\tcase PDS_RC_EOPCODE:\n\tcase PDS_RC_EINTR:\n\tcase PDS_RC_DEV_CMD:\n\tcase PDS_RC_ERROR:\n\tcase PDS_RC_ERDMA:\n\tcase PDS_RC_EIO:\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nbool pdsc_is_fw_running(struct pdsc *pdsc)\n{\n\tpdsc->fw_status = ioread8(&pdsc->info_regs->fw_status);\n\tpdsc->last_fw_time = jiffies;\n\tpdsc->last_hb = ioread32(&pdsc->info_regs->fw_heartbeat);\n\n\t \n\treturn (pdsc->fw_status != 0xff) &&\n\t\t(pdsc->fw_status & PDS_CORE_FW_STS_F_RUNNING);\n}\n\nbool pdsc_is_fw_good(struct pdsc *pdsc)\n{\n\tbool fw_running = pdsc_is_fw_running(pdsc);\n\tu8 gen;\n\n\t \n\tgen = pdsc->fw_status & PDS_CORE_FW_STS_F_GENERATION;\n\n\treturn fw_running && gen == pdsc->fw_generation;\n}\n\nstatic u8 pdsc_devcmd_status(struct pdsc *pdsc)\n{\n\treturn ioread8(&pdsc->cmd_regs->comp.status);\n}\n\nstatic bool pdsc_devcmd_done(struct pdsc *pdsc)\n{\n\treturn ioread32(&pdsc->cmd_regs->done) & PDS_CORE_DEV_CMD_DONE;\n}\n\nstatic void pdsc_devcmd_dbell(struct pdsc *pdsc)\n{\n\tiowrite32(0, &pdsc->cmd_regs->done);\n\tiowrite32(1, &pdsc->cmd_regs->doorbell);\n}\n\nstatic void pdsc_devcmd_clean(struct pdsc *pdsc)\n{\n\tiowrite32(0, &pdsc->cmd_regs->doorbell);\n\tmemset_io(&pdsc->cmd_regs->cmd, 0, sizeof(pdsc->cmd_regs->cmd));\n}\n\nstatic const char *pdsc_devcmd_str(int opcode)\n{\n\tswitch (opcode) {\n\tcase PDS_CORE_CMD_NOP:\n\t\treturn \"PDS_CORE_CMD_NOP\";\n\tcase PDS_CORE_CMD_IDENTIFY:\n\t\treturn \"PDS_CORE_CMD_IDENTIFY\";\n\tcase PDS_CORE_CMD_RESET:\n\t\treturn \"PDS_CORE_CMD_RESET\";\n\tcase PDS_CORE_CMD_INIT:\n\t\treturn \"PDS_CORE_CMD_INIT\";\n\tcase PDS_CORE_CMD_FW_DOWNLOAD:\n\t\treturn \"PDS_CORE_CMD_FW_DOWNLOAD\";\n\tcase PDS_CORE_CMD_FW_CONTROL:\n\t\treturn \"PDS_CORE_CMD_FW_CONTROL\";\n\tdefault:\n\t\treturn \"PDS_CORE_CMD_UNKNOWN\";\n\t}\n}\n\nstatic int pdsc_devcmd_wait(struct pdsc *pdsc, u8 opcode, int max_seconds)\n{\n\tstruct device *dev = pdsc->dev;\n\tunsigned long start_time;\n\tunsigned long max_wait;\n\tunsigned long duration;\n\tint timeout = 0;\n\tint done = 0;\n\tint err = 0;\n\tint status;\n\n\tstart_time = jiffies;\n\tmax_wait = start_time + (max_seconds * HZ);\n\n\twhile (!done && !timeout) {\n\t\tdone = pdsc_devcmd_done(pdsc);\n\t\tif (done)\n\t\t\tbreak;\n\n\t\ttimeout = time_after(jiffies, max_wait);\n\t\tif (timeout)\n\t\t\tbreak;\n\n\t\tusleep_range(100, 200);\n\t}\n\tduration = jiffies - start_time;\n\n\tif (done && duration > HZ)\n\t\tdev_dbg(dev, \"DEVCMD %d %s after %ld secs\\n\",\n\t\t\topcode, pdsc_devcmd_str(opcode), duration / HZ);\n\n\tif (!done || timeout) {\n\t\tdev_err(dev, \"DEVCMD %d %s timeout, done %d timeout %d max_seconds=%d\\n\",\n\t\t\topcode, pdsc_devcmd_str(opcode), done, timeout,\n\t\t\tmax_seconds);\n\t\terr = -ETIMEDOUT;\n\t\tpdsc_devcmd_clean(pdsc);\n\t}\n\n\tstatus = pdsc_devcmd_status(pdsc);\n\terr = pdsc_err_to_errno(status);\n\tif (err && err != -EAGAIN)\n\t\tdev_err(dev, \"DEVCMD %d %s failed, status=%d err %d %pe\\n\",\n\t\t\topcode, pdsc_devcmd_str(opcode), status, err,\n\t\t\tERR_PTR(err));\n\n\treturn err;\n}\n\nint pdsc_devcmd_locked(struct pdsc *pdsc, union pds_core_dev_cmd *cmd,\n\t\t       union pds_core_dev_comp *comp, int max_seconds)\n{\n\tint err;\n\n\tmemcpy_toio(&pdsc->cmd_regs->cmd, cmd, sizeof(*cmd));\n\tpdsc_devcmd_dbell(pdsc);\n\terr = pdsc_devcmd_wait(pdsc, cmd->opcode, max_seconds);\n\tmemcpy_fromio(comp, &pdsc->cmd_regs->comp, sizeof(*comp));\n\n\tif ((err == -ENXIO || err == -ETIMEDOUT) && pdsc->wq)\n\t\tqueue_work(pdsc->wq, &pdsc->health_work);\n\n\treturn err;\n}\n\nint pdsc_devcmd(struct pdsc *pdsc, union pds_core_dev_cmd *cmd,\n\t\tunion pds_core_dev_comp *comp, int max_seconds)\n{\n\tint err;\n\n\tmutex_lock(&pdsc->devcmd_lock);\n\terr = pdsc_devcmd_locked(pdsc, cmd, comp, max_seconds);\n\tmutex_unlock(&pdsc->devcmd_lock);\n\n\treturn err;\n}\n\nint pdsc_devcmd_init(struct pdsc *pdsc)\n{\n\tunion pds_core_dev_comp comp = {};\n\tunion pds_core_dev_cmd cmd = {\n\t\t.opcode = PDS_CORE_CMD_INIT,\n\t};\n\n\treturn pdsc_devcmd(pdsc, &cmd, &comp, pdsc->devcmd_timeout);\n}\n\nint pdsc_devcmd_reset(struct pdsc *pdsc)\n{\n\tunion pds_core_dev_comp comp = {};\n\tunion pds_core_dev_cmd cmd = {\n\t\t.reset.opcode = PDS_CORE_CMD_RESET,\n\t};\n\n\treturn pdsc_devcmd(pdsc, &cmd, &comp, pdsc->devcmd_timeout);\n}\n\nstatic int pdsc_devcmd_identify_locked(struct pdsc *pdsc)\n{\n\tunion pds_core_dev_comp comp = {};\n\tunion pds_core_dev_cmd cmd = {\n\t\t.identify.opcode = PDS_CORE_CMD_IDENTIFY,\n\t\t.identify.ver = PDS_CORE_IDENTITY_VERSION_1,\n\t};\n\n\treturn pdsc_devcmd_locked(pdsc, &cmd, &comp, pdsc->devcmd_timeout);\n}\n\nstatic void pdsc_init_devinfo(struct pdsc *pdsc)\n{\n\tpdsc->dev_info.asic_type = ioread8(&pdsc->info_regs->asic_type);\n\tpdsc->dev_info.asic_rev = ioread8(&pdsc->info_regs->asic_rev);\n\tpdsc->fw_generation = PDS_CORE_FW_STS_F_GENERATION &\n\t\t\t      ioread8(&pdsc->info_regs->fw_status);\n\n\tmemcpy_fromio(pdsc->dev_info.fw_version,\n\t\t      pdsc->info_regs->fw_version,\n\t\t      PDS_CORE_DEVINFO_FWVERS_BUFLEN);\n\tpdsc->dev_info.fw_version[PDS_CORE_DEVINFO_FWVERS_BUFLEN] = 0;\n\n\tmemcpy_fromio(pdsc->dev_info.serial_num,\n\t\t      pdsc->info_regs->serial_num,\n\t\t      PDS_CORE_DEVINFO_SERIAL_BUFLEN);\n\tpdsc->dev_info.serial_num[PDS_CORE_DEVINFO_SERIAL_BUFLEN] = 0;\n\n\tdev_dbg(pdsc->dev, \"fw_version %s\\n\", pdsc->dev_info.fw_version);\n}\n\nstatic int pdsc_identify(struct pdsc *pdsc)\n{\n\tstruct pds_core_drv_identity drv = {};\n\tsize_t sz;\n\tint err;\n\tint n;\n\n\tdrv.drv_type = cpu_to_le32(PDS_DRIVER_LINUX);\n\t \n\tn = snprintf(drv.driver_ver_str, sizeof(drv.driver_ver_str),\n\t\t     \"%s %s\", PDS_CORE_DRV_NAME, utsname()->release);\n\tif (n > sizeof(drv.driver_ver_str))\n\t\tdev_dbg(pdsc->dev, \"release name truncated, don't care\\n\");\n\n\t \n\tmutex_lock(&pdsc->devcmd_lock);\n\n\tsz = min_t(size_t, sizeof(drv), sizeof(pdsc->cmd_regs->data));\n\tmemcpy_toio(&pdsc->cmd_regs->data, &drv, sz);\n\n\terr = pdsc_devcmd_identify_locked(pdsc);\n\tif (!err) {\n\t\tsz = min_t(size_t, sizeof(pdsc->dev_ident),\n\t\t\t   sizeof(pdsc->cmd_regs->data));\n\t\tmemcpy_fromio(&pdsc->dev_ident, &pdsc->cmd_regs->data, sz);\n\t}\n\tmutex_unlock(&pdsc->devcmd_lock);\n\n\tif (err) {\n\t\tdev_err(pdsc->dev, \"Cannot identify device: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tif (isprint(pdsc->dev_info.fw_version[0]) &&\n\t    isascii(pdsc->dev_info.fw_version[0]))\n\t\tdev_info(pdsc->dev, \"FW: %.*s\\n\",\n\t\t\t (int)(sizeof(pdsc->dev_info.fw_version) - 1),\n\t\t\t pdsc->dev_info.fw_version);\n\telse\n\t\tdev_info(pdsc->dev, \"FW: (invalid string) 0x%02x 0x%02x 0x%02x 0x%02x ...\\n\",\n\t\t\t (u8)pdsc->dev_info.fw_version[0],\n\t\t\t (u8)pdsc->dev_info.fw_version[1],\n\t\t\t (u8)pdsc->dev_info.fw_version[2],\n\t\t\t (u8)pdsc->dev_info.fw_version[3]);\n\n\treturn 0;\n}\n\nint pdsc_dev_reinit(struct pdsc *pdsc)\n{\n\tpdsc_init_devinfo(pdsc);\n\n\treturn pdsc_identify(pdsc);\n}\n\nint pdsc_dev_init(struct pdsc *pdsc)\n{\n\tunsigned int nintrs;\n\tint err;\n\n\t \n\tpdsc_init_devinfo(pdsc);\n\tpdsc->devcmd_timeout = PDS_CORE_DEVCMD_TIMEOUT;\n\n\terr = pdsc_devcmd_reset(pdsc);\n\tif (err)\n\t\treturn err;\n\n\terr = pdsc_identify(pdsc);\n\tif (err)\n\t\treturn err;\n\n\tpdsc_debugfs_add_ident(pdsc);\n\n\t \n\tnintrs = le32_to_cpu(pdsc->dev_ident.nintrs);\n\tnintrs = min_t(unsigned int, num_online_cpus(), nintrs);\n\n\t \n\tpdsc->intr_info = kcalloc(nintrs, sizeof(*pdsc->intr_info), GFP_KERNEL);\n\tif (!pdsc->intr_info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terr = pci_alloc_irq_vectors(pdsc->pdev, nintrs, nintrs, PCI_IRQ_MSIX);\n\tif (err != nintrs) {\n\t\tdev_err(pdsc->dev, \"Can't get %d intrs from OS: %pe\\n\",\n\t\t\tnintrs, ERR_PTR(err));\n\t\terr = -ENOSPC;\n\t\tgoto err_out;\n\t}\n\tpdsc->nintrs = nintrs;\n\n\treturn 0;\n\nerr_out:\n\tkfree(pdsc->intr_info);\n\tpdsc->intr_info = NULL;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}