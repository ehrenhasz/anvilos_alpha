{
  "module_name": "debugfs.c",
  "hash_id": "6ba0407de84de7f8d7855a4d4d9b7c9969c817f4fbe2d47b44bb2fc42b7a83e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pds_core/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n\n#include \"core.h\"\n\nstatic struct dentry *pdsc_dir;\n\nvoid pdsc_debugfs_create(void)\n{\n\tpdsc_dir = debugfs_create_dir(PDS_CORE_DRV_NAME, NULL);\n}\n\nvoid pdsc_debugfs_destroy(void)\n{\n\tdebugfs_remove_recursive(pdsc_dir);\n}\n\nvoid pdsc_debugfs_add_dev(struct pdsc *pdsc)\n{\n\tpdsc->dentry = debugfs_create_dir(pci_name(pdsc->pdev), pdsc_dir);\n\n\tdebugfs_create_ulong(\"state\", 0400, pdsc->dentry, &pdsc->state);\n}\n\nvoid pdsc_debugfs_del_dev(struct pdsc *pdsc)\n{\n\tdebugfs_remove_recursive(pdsc->dentry);\n\tpdsc->dentry = NULL;\n}\n\nstatic int identity_show(struct seq_file *seq, void *v)\n{\n\tstruct pdsc *pdsc = seq->private;\n\tstruct pds_core_dev_identity *ident;\n\tint vt;\n\n\tident = &pdsc->dev_ident;\n\n\tseq_printf(seq, \"fw_heartbeat:     0x%x\\n\",\n\t\t   ioread32(&pdsc->info_regs->fw_heartbeat));\n\n\tseq_printf(seq, \"nlifs:            %d\\n\",\n\t\t   le32_to_cpu(ident->nlifs));\n\tseq_printf(seq, \"nintrs:           %d\\n\",\n\t\t   le32_to_cpu(ident->nintrs));\n\tseq_printf(seq, \"ndbpgs_per_lif:   %d\\n\",\n\t\t   le32_to_cpu(ident->ndbpgs_per_lif));\n\tseq_printf(seq, \"intr_coal_mult:   %d\\n\",\n\t\t   le32_to_cpu(ident->intr_coal_mult));\n\tseq_printf(seq, \"intr_coal_div:    %d\\n\",\n\t\t   le32_to_cpu(ident->intr_coal_div));\n\n\tseq_puts(seq, \"vif_types:        \");\n\tfor (vt = 0; vt < PDS_DEV_TYPE_MAX; vt++)\n\t\tseq_printf(seq, \"%d \",\n\t\t\t   le16_to_cpu(pdsc->dev_ident.vif_types[vt]));\n\tseq_puts(seq, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(identity);\n\nvoid pdsc_debugfs_add_ident(struct pdsc *pdsc)\n{\n\tdebugfs_create_file(\"identity\", 0400, pdsc->dentry,\n\t\t\t    pdsc, &identity_fops);\n}\n\nstatic int viftype_show(struct seq_file *seq, void *v)\n{\n\tstruct pdsc *pdsc = seq->private;\n\tint vt;\n\n\tfor (vt = 0; vt < PDS_DEV_TYPE_MAX; vt++) {\n\t\tif (!pdsc->viftype_status[vt].name)\n\t\t\tcontinue;\n\n\t\tseq_printf(seq, \"%s\\t%d supported %d enabled\\n\",\n\t\t\t   pdsc->viftype_status[vt].name,\n\t\t\t   pdsc->viftype_status[vt].supported,\n\t\t\t   pdsc->viftype_status[vt].enabled);\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(viftype);\n\nvoid pdsc_debugfs_add_viftype(struct pdsc *pdsc)\n{\n\tdebugfs_create_file(\"viftypes\", 0400, pdsc->dentry,\n\t\t\t    pdsc, &viftype_fops);\n}\n\nstatic const struct debugfs_reg32 intr_ctrl_regs[] = {\n\t{ .name = \"coal_init\", .offset = 0, },\n\t{ .name = \"mask\", .offset = 4, },\n\t{ .name = \"credits\", .offset = 8, },\n\t{ .name = \"mask_on_assert\", .offset = 12, },\n\t{ .name = \"coal_timer\", .offset = 16, },\n};\n\nvoid pdsc_debugfs_add_qcq(struct pdsc *pdsc, struct pdsc_qcq *qcq)\n{\n\tstruct dentry *qcq_dentry, *q_dentry, *cq_dentry;\n\tstruct dentry *intr_dentry;\n\tstruct debugfs_regset32 *intr_ctrl_regset;\n\tstruct pdsc_intr_info *intr = &pdsc->intr_info[qcq->intx];\n\tstruct pdsc_queue *q = &qcq->q;\n\tstruct pdsc_cq *cq = &qcq->cq;\n\n\tqcq_dentry = debugfs_create_dir(q->name, pdsc->dentry);\n\tif (IS_ERR_OR_NULL(qcq_dentry))\n\t\treturn;\n\tqcq->dentry = qcq_dentry;\n\n\tdebugfs_create_x64(\"q_base_pa\", 0400, qcq_dentry, &qcq->q_base_pa);\n\tdebugfs_create_x32(\"q_size\", 0400, qcq_dentry, &qcq->q_size);\n\tdebugfs_create_x64(\"cq_base_pa\", 0400, qcq_dentry, &qcq->cq_base_pa);\n\tdebugfs_create_x32(\"cq_size\", 0400, qcq_dentry, &qcq->cq_size);\n\tdebugfs_create_x32(\"accum_work\", 0400, qcq_dentry, &qcq->accum_work);\n\n\tq_dentry = debugfs_create_dir(\"q\", qcq->dentry);\n\tif (IS_ERR_OR_NULL(q_dentry))\n\t\treturn;\n\n\tdebugfs_create_u32(\"index\", 0400, q_dentry, &q->index);\n\tdebugfs_create_u32(\"num_descs\", 0400, q_dentry, &q->num_descs);\n\tdebugfs_create_u32(\"desc_size\", 0400, q_dentry, &q->desc_size);\n\tdebugfs_create_u32(\"pid\", 0400, q_dentry, &q->pid);\n\n\tdebugfs_create_u16(\"tail\", 0400, q_dentry, &q->tail_idx);\n\tdebugfs_create_u16(\"head\", 0400, q_dentry, &q->head_idx);\n\n\tcq_dentry = debugfs_create_dir(\"cq\", qcq->dentry);\n\tif (IS_ERR_OR_NULL(cq_dentry))\n\t\treturn;\n\n\tdebugfs_create_x64(\"base_pa\", 0400, cq_dentry, &cq->base_pa);\n\tdebugfs_create_u32(\"num_descs\", 0400, cq_dentry, &cq->num_descs);\n\tdebugfs_create_u32(\"desc_size\", 0400, cq_dentry, &cq->desc_size);\n\tdebugfs_create_bool(\"done_color\", 0400, cq_dentry, &cq->done_color);\n\tdebugfs_create_u16(\"tail\", 0400, cq_dentry, &cq->tail_idx);\n\n\tif (qcq->flags & PDS_CORE_QCQ_F_INTR) {\n\t\tintr_dentry = debugfs_create_dir(\"intr\", qcq->dentry);\n\t\tif (IS_ERR_OR_NULL(intr_dentry))\n\t\t\treturn;\n\n\t\tdebugfs_create_u32(\"index\", 0400, intr_dentry, &intr->index);\n\t\tdebugfs_create_u32(\"vector\", 0400, intr_dentry, &intr->vector);\n\n\t\tintr_ctrl_regset = kzalloc(sizeof(*intr_ctrl_regset),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!intr_ctrl_regset)\n\t\t\treturn;\n\t\tintr_ctrl_regset->regs = intr_ctrl_regs;\n\t\tintr_ctrl_regset->nregs = ARRAY_SIZE(intr_ctrl_regs);\n\t\tintr_ctrl_regset->base = &pdsc->intr_ctrl[intr->index];\n\n\t\tdebugfs_create_regset32(\"intr_ctrl\", 0400, intr_dentry,\n\t\t\t\t\tintr_ctrl_regset);\n\t}\n};\n\nvoid pdsc_debugfs_del_qcq(struct pdsc_qcq *qcq)\n{\n\tdebugfs_remove_recursive(qcq->dentry);\n\tqcq->dentry = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}