{
  "module_name": "adminq.c",
  "hash_id": "2650fdcb03574d0b6f2f5d131135c46059793b0472efa860c6c2a1a520090c8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pds_core/adminq.c",
  "human_readable_source": "\n \n\n#include <linux/dynamic_debug.h>\n\n#include \"core.h\"\n\nstruct pdsc_wait_context {\n\tstruct pdsc_qcq *qcq;\n\tstruct completion wait_completion;\n};\n\nstatic int pdsc_process_notifyq(struct pdsc_qcq *qcq)\n{\n\tunion pds_core_notifyq_comp *comp;\n\tstruct pdsc *pdsc = qcq->pdsc;\n\tstruct pdsc_cq *cq = &qcq->cq;\n\tstruct pdsc_cq_info *cq_info;\n\tint nq_work = 0;\n\tu64 eid;\n\n\tcq_info = &cq->info[cq->tail_idx];\n\tcomp = cq_info->comp;\n\teid = le64_to_cpu(comp->event.eid);\n\twhile (eid > pdsc->last_eid) {\n\t\tu16 ecode = le16_to_cpu(comp->event.ecode);\n\n\t\tswitch (ecode) {\n\t\tcase PDS_EVENT_LINK_CHANGE:\n\t\t\tdev_info(pdsc->dev, \"NotifyQ LINK_CHANGE ecode %d eid %lld\\n\",\n\t\t\t\t ecode, eid);\n\t\t\tpdsc_notify(PDS_EVENT_LINK_CHANGE, comp);\n\t\t\tbreak;\n\n\t\tcase PDS_EVENT_RESET:\n\t\t\tdev_info(pdsc->dev, \"NotifyQ RESET ecode %d eid %lld\\n\",\n\t\t\t\t ecode, eid);\n\t\t\tpdsc_notify(PDS_EVENT_RESET, comp);\n\t\t\tbreak;\n\n\t\tcase PDS_EVENT_XCVR:\n\t\t\tdev_info(pdsc->dev, \"NotifyQ XCVR ecode %d eid %lld\\n\",\n\t\t\t\t ecode, eid);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_info(pdsc->dev, \"NotifyQ ecode %d eid %lld\\n\",\n\t\t\t\t ecode, eid);\n\t\t\tbreak;\n\t\t}\n\n\t\tpdsc->last_eid = eid;\n\t\tcq->tail_idx = (cq->tail_idx + 1) & (cq->num_descs - 1);\n\t\tcq_info = &cq->info[cq->tail_idx];\n\t\tcomp = cq_info->comp;\n\t\teid = le64_to_cpu(comp->event.eid);\n\n\t\tnq_work++;\n\t}\n\n\tqcq->accum_work += nq_work;\n\n\treturn nq_work;\n}\n\nvoid pdsc_process_adminq(struct pdsc_qcq *qcq)\n{\n\tunion pds_core_adminq_comp *comp;\n\tstruct pdsc_queue *q = &qcq->q;\n\tstruct pdsc *pdsc = qcq->pdsc;\n\tstruct pdsc_cq *cq = &qcq->cq;\n\tstruct pdsc_q_info *q_info;\n\tunsigned long irqflags;\n\tint nq_work = 0;\n\tint aq_work = 0;\n\tint credits;\n\n\t \n\tif (pdsc->state & BIT_ULL(PDSC_S_STOPPING_DRIVER)) {\n\t\tdev_err(pdsc->dev, \"%s: called while PDSC_S_STOPPING_DRIVER\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\t \n\tnq_work = pdsc_process_notifyq(&pdsc->notifyqcq);\n\n\t \n\tif (q->tail_idx == q->head_idx)\n\t\tgoto credits;\n\n\t \n\tspin_lock_irqsave(&pdsc->adminq_lock, irqflags);\n\tcomp = cq->info[cq->tail_idx].comp;\n\twhile (pdsc_color_match(comp->color, cq->done_color)) {\n\t\tq_info = &q->info[q->tail_idx];\n\t\tq->tail_idx = (q->tail_idx + 1) & (q->num_descs - 1);\n\n\t\t \n\t\tmemcpy(q_info->dest, comp, sizeof(*comp));\n\n\t\tcomplete_all(&q_info->wc->wait_completion);\n\n\t\tif (cq->tail_idx == cq->num_descs - 1)\n\t\t\tcq->done_color = !cq->done_color;\n\t\tcq->tail_idx = (cq->tail_idx + 1) & (cq->num_descs - 1);\n\t\tcomp = cq->info[cq->tail_idx].comp;\n\n\t\taq_work++;\n\t}\n\tspin_unlock_irqrestore(&pdsc->adminq_lock, irqflags);\n\n\tqcq->accum_work += aq_work;\n\ncredits:\n\t \n\tcredits = nq_work + aq_work;\n\tif (credits)\n\t\tpds_core_intr_credits(&pdsc->intr_ctrl[qcq->intx],\n\t\t\t\t      credits,\n\t\t\t\t      PDS_CORE_INTR_CRED_REARM);\n}\n\nvoid pdsc_work_thread(struct work_struct *work)\n{\n\tstruct pdsc_qcq *qcq = container_of(work, struct pdsc_qcq, work);\n\n\tpdsc_process_adminq(qcq);\n}\n\nirqreturn_t pdsc_adminq_isr(int irq, void *data)\n{\n\tstruct pdsc_qcq *qcq = data;\n\tstruct pdsc *pdsc = qcq->pdsc;\n\n\t \n\tif (pdsc->state & BIT_ULL(PDSC_S_STOPPING_DRIVER)) {\n\t\tdev_err(pdsc->dev, \"%s: called while PDSC_S_STOPPING_DRIVER\\n\",\n\t\t\t__func__);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tqueue_work(pdsc->wq, &qcq->work);\n\tpds_core_intr_mask(&pdsc->intr_ctrl[qcq->intx], PDS_CORE_INTR_MASK_CLEAR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __pdsc_adminq_post(struct pdsc *pdsc,\n\t\t\t      struct pdsc_qcq *qcq,\n\t\t\t      union pds_core_adminq_cmd *cmd,\n\t\t\t      union pds_core_adminq_comp *comp,\n\t\t\t      struct pdsc_wait_context *wc)\n{\n\tstruct pdsc_queue *q = &qcq->q;\n\tstruct pdsc_q_info *q_info;\n\tunsigned long irqflags;\n\tunsigned int avail;\n\tint index;\n\tint ret;\n\n\tspin_lock_irqsave(&pdsc->adminq_lock, irqflags);\n\n\t \n\tavail = q->tail_idx;\n\tif (q->head_idx >= avail)\n\t\tavail += q->num_descs - q->head_idx - 1;\n\telse\n\t\tavail -= q->head_idx + 1;\n\tif (!avail) {\n\t\tret = -ENOSPC;\n\t\tgoto err_out_unlock;\n\t}\n\n\t \n\tif (!pdsc_is_fw_running(pdsc)) {\n\t\tu8 fw_status = ioread8(&pdsc->info_regs->fw_status);\n\n\t\tdev_info(pdsc->dev, \"%s: post failed - fw not running %#02x:\\n\",\n\t\t\t __func__, fw_status);\n\t\tret = -ENXIO;\n\n\t\tgoto err_out_unlock;\n\t}\n\n\t \n\tindex = q->head_idx;\n\tq_info = &q->info[index];\n\tq_info->wc = wc;\n\tq_info->dest = comp;\n\tmemcpy(q_info->desc, cmd, sizeof(*cmd));\n\n\tdev_dbg(pdsc->dev, \"head_idx %d tail_idx %d\\n\",\n\t\tq->head_idx, q->tail_idx);\n\tdev_dbg(pdsc->dev, \"post admin queue command:\\n\");\n\tdynamic_hex_dump(\"cmd \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t cmd, sizeof(*cmd), true);\n\n\tq->head_idx = (q->head_idx + 1) & (q->num_descs - 1);\n\n\tpds_core_dbell_ring(pdsc->kern_dbpage,\n\t\t\t    q->hw_type, q->dbval | q->head_idx);\n\tret = index;\n\nerr_out_unlock:\n\tspin_unlock_irqrestore(&pdsc->adminq_lock, irqflags);\n\treturn ret;\n}\n\nint pdsc_adminq_post(struct pdsc *pdsc,\n\t\t     union pds_core_adminq_cmd *cmd,\n\t\t     union pds_core_adminq_comp *comp,\n\t\t     bool fast_poll)\n{\n\tstruct pdsc_wait_context wc = {\n\t\t.wait_completion =\n\t\t\tCOMPLETION_INITIALIZER_ONSTACK(wc.wait_completion),\n\t};\n\tunsigned long poll_interval = 1;\n\tunsigned long poll_jiffies;\n\tunsigned long time_limit;\n\tunsigned long time_start;\n\tunsigned long time_done;\n\tunsigned long remaining;\n\tint err = 0;\n\tint index;\n\n\twc.qcq = &pdsc->adminqcq;\n\tindex = __pdsc_adminq_post(pdsc, &pdsc->adminqcq, cmd, comp, &wc);\n\tif (index < 0) {\n\t\terr = index;\n\t\tgoto err_out;\n\t}\n\n\ttime_start = jiffies;\n\ttime_limit = time_start + HZ * pdsc->devcmd_timeout;\n\tdo {\n\t\t \n\t\tpoll_jiffies = msecs_to_jiffies(poll_interval);\n\t\tremaining = wait_for_completion_timeout(&wc.wait_completion,\n\t\t\t\t\t\t\tpoll_jiffies);\n\t\tif (remaining)\n\t\t\tbreak;\n\n\t\tif (!pdsc_is_fw_running(pdsc)) {\n\t\t\tu8 fw_status = ioread8(&pdsc->info_regs->fw_status);\n\n\t\t\tdev_dbg(pdsc->dev, \"%s: post wait failed - fw not running %#02x:\\n\",\n\t\t\t\t__func__, fw_status);\n\t\t\terr = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!fast_poll && poll_interval < PDSC_ADMINQ_MAX_POLL_INTERVAL)\n\t\t\tpoll_interval <<= 1;\n\t} while (time_before(jiffies, time_limit));\n\ttime_done = jiffies;\n\tdev_dbg(pdsc->dev, \"%s: elapsed %d msecs\\n\",\n\t\t__func__, jiffies_to_msecs(time_done - time_start));\n\n\t \n\tif (time_after_eq(time_done, time_limit))\n\t\terr = -ETIMEDOUT;\n\n\tdev_dbg(pdsc->dev, \"read admin queue completion idx %d:\\n\", index);\n\tdynamic_hex_dump(\"comp \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t comp, sizeof(*comp), true);\n\n\tif (remaining && comp->status)\n\t\terr = pdsc_err_to_errno(comp->status);\n\nerr_out:\n\tif (err) {\n\t\tdev_dbg(pdsc->dev, \"%s: opcode %d status %d err %pe\\n\",\n\t\t\t__func__, cmd->opcode, comp->status, ERR_PTR(err));\n\t\tif (err == -ENXIO || err == -ETIMEDOUT)\n\t\t\tqueue_work(pdsc->wq, &pdsc->health_work);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(pdsc_adminq_post);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}