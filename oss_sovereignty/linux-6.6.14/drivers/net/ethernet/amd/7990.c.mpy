{
  "module_name": "7990.c",
  "hash_id": "b880595cf99cc5d86bd6676ffbfb61259fd2981a7cfcdff575c919fc5aa0654e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/7990.c",
  "human_readable_source": "\n \n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/route.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/pgtable.h>\n#include <asm/irq.h>\n \n#include <linux/socket.h>\n#include <linux/bitops.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n#ifdef CONFIG_HP300\n#include <asm/blinken.h>\n#endif\n\n#include \"7990.h\"\n\n#define WRITERAP(lp, x)\tout_be16(lp->base + LANCE_RAP, (x))\n#define WRITERDP(lp, x)\tout_be16(lp->base + LANCE_RDP, (x))\n#define READRDP(lp)\tin_be16(lp->base + LANCE_RDP)\n\n#if IS_ENABLED(CONFIG_HPLANCE)\n#include \"hplance.h\"\n\n#undef WRITERAP\n#undef WRITERDP\n#undef READRDP\n\n#if IS_ENABLED(CONFIG_MVME147_NET)\n\n \n#define WRITERAP(lp, x)\t(lp->writerap(lp, x))\n#define WRITERDP(lp, x)\t(lp->writerdp(lp, x))\n#define READRDP(lp)\t(lp->readrdp(lp))\n\n#else\n\n \nstatic inline void WRITERAP(struct lance_private *lp, __u16 value)\n{\n\tdo {\n\t\tout_be16(lp->base + HPLANCE_REGOFF + LANCE_RAP, value);\n\t} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\n}\n\nstatic inline void WRITERDP(struct lance_private *lp, __u16 value)\n{\n\tdo {\n\t\tout_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP, value);\n\t} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\n}\n\nstatic inline __u16 READRDP(struct lance_private *lp)\n{\n\t__u16 value;\n\tdo {\n\t\tvalue = in_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP);\n\t} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\n\treturn value;\n}\n\n#endif\n#endif  \n\n \n \n#ifdef UNDEF\n#define PRINT_RINGS() \\\ndo { \\\n\tint t; \\\n\tfor (t = 0; t < RX_RING_SIZE; t++) { \\\n\t\tprintk(\"R%d: @(%02X %04X) len %04X, mblen %04X, bits %02X\\n\", \\\n\t\t       t, ib->brx_ring[t].rmd1_hadr, ib->brx_ring[t].rmd0, \\\n\t\t       ib->brx_ring[t].length, \\\n\t\t       ib->brx_ring[t].mblength, ib->brx_ring[t].rmd1_bits); \\\n\t} \\\n\tfor (t = 0; t < TX_RING_SIZE; t++) { \\\n\t\tprintk(\"T%d: @(%02X %04X) len %04X, misc %04X, bits %02X\\n\", \\\n\t\t       t, ib->btx_ring[t].tmd1_hadr, ib->btx_ring[t].tmd0, \\\n\t\t       ib->btx_ring[t].length, \\\n\t\t       ib->btx_ring[t].misc, ib->btx_ring[t].tmd1_bits); \\\n\t} \\\n} while (0)\n#else\n#define PRINT_RINGS()\n#endif\n\n \nstatic void load_csrs(struct lance_private *lp)\n{\n\tvolatile struct lance_init_block *aib = lp->lance_init_block;\n\tint leptr;\n\n\tleptr = LANCE_ADDR(aib);\n\n\tWRITERAP(lp, LE_CSR1);                     \n\tWRITERDP(lp, leptr & 0xFFFF);\n\tWRITERAP(lp, LE_CSR2);\n\tWRITERDP(lp, leptr >> 16);\n\tWRITERAP(lp, LE_CSR3);\n\tWRITERDP(lp, lp->busmaster_regval);        \n\n\t \n\tWRITERAP(lp, LE_CSR0);\n}\n\n \n#define DEBUG_IRING 0\n \nstatic void lance_init_ring(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile struct lance_init_block *aib;  \n\tint leptr;\n\tint i;\n\n\taib = lp->lance_init_block;\n\n\tlp->rx_new = lp->tx_new = 0;\n\tlp->rx_old = lp->tx_old = 0;\n\n\tib->mode = LE_MO_PROM;                              \n\n\t \n#ifdef __BIG_ENDIAN\n\tib->phys_addr[0] = dev->dev_addr[1];\n\tib->phys_addr[1] = dev->dev_addr[0];\n\tib->phys_addr[2] = dev->dev_addr[3];\n\tib->phys_addr[3] = dev->dev_addr[2];\n\tib->phys_addr[4] = dev->dev_addr[5];\n\tib->phys_addr[5] = dev->dev_addr[4];\n#else\n\tfor (i = 0; i < 6; i++)\n\t       ib->phys_addr[i] = dev->dev_addr[i];\n#endif\n\n\tif (DEBUG_IRING)\n\t\tprintk(\"TX rings:\\n\");\n\n\tlp->tx_full = 0;\n\t \n\tfor (i = 0; i < (1 << lp->lance_log_tx_bufs); i++) {\n\t\tleptr = LANCE_ADDR(&aib->tx_buf[i][0]);\n\t\tib->btx_ring[i].tmd0      = leptr;\n\t\tib->btx_ring[i].tmd1_hadr = leptr >> 16;\n\t\tib->btx_ring[i].tmd1_bits = 0;\n\t\tib->btx_ring[i].length    = 0xf000;  \n\t\tib->btx_ring[i].misc      = 0;\n\t\tif (DEBUG_IRING)\n\t\t\tprintk(\"%d: 0x%8.8x\\n\", i, leptr);\n\t}\n\n\t \n\tif (DEBUG_IRING)\n\t\tprintk(\"RX rings:\\n\");\n\tfor (i = 0; i < (1 << lp->lance_log_rx_bufs); i++) {\n\t\tleptr = LANCE_ADDR(&aib->rx_buf[i][0]);\n\n\t\tib->brx_ring[i].rmd0      = leptr;\n\t\tib->brx_ring[i].rmd1_hadr = leptr >> 16;\n\t\tib->brx_ring[i].rmd1_bits = LE_R1_OWN;\n\t\t \n\t\tib->brx_ring[i].length    = -RX_BUFF_SIZE | 0xf000;\n\t\tib->brx_ring[i].mblength  = 0;\n\t\tif (DEBUG_IRING)\n\t\t\tprintk(\"%d: 0x%8.8x\\n\", i, leptr);\n\t}\n\n\t \n\n\t \n\tleptr = LANCE_ADDR(&aib->brx_ring);\n\tib->rx_len = (lp->lance_log_rx_bufs << 13) | (leptr >> 16);\n\tib->rx_ptr = leptr;\n\tif (DEBUG_IRING)\n\t\tprintk(\"RX ptr: %8.8x\\n\", leptr);\n\n\t \n\tleptr = LANCE_ADDR(&aib->btx_ring);\n\tib->tx_len = (lp->lance_log_tx_bufs << 13) | (leptr >> 16);\n\tib->tx_ptr = leptr;\n\tif (DEBUG_IRING)\n\t\tprintk(\"TX ptr: %8.8x\\n\", leptr);\n\n\t \n\tib->filter[0] = 0;\n\tib->filter[1] = 0;\n\tPRINT_RINGS();\n}\n\n \nstatic int init_restart_lance(struct lance_private *lp)\n{\n\tint i;\n\n\tWRITERAP(lp, LE_CSR0);\n\tWRITERDP(lp, LE_C0_INIT);\n\n\t \n\n\t \n\tfor (i = 0; (i < 100) && !(READRDP(lp) & (LE_C0_ERR | LE_C0_IDON)); i++)\n\t\tbarrier();\n\tif ((i == 100) || (READRDP(lp) & LE_C0_ERR)) {\n\t\tprintk(\"LANCE unopened after %d ticks, csr0=%4.4x.\\n\", i, READRDP(lp));\n\t\treturn -1;\n\t}\n\n\t \n\tWRITERDP(lp, LE_C0_IDON);\n\tWRITERDP(lp, LE_C0_INEA | LE_C0_STRT);\n\n\treturn 0;\n}\n\nstatic int lance_reset(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint status;\n\n\t \n\tWRITERAP(lp, LE_CSR0);\n\tWRITERDP(lp, LE_C0_STOP);\n\n\tload_csrs(lp);\n\tlance_init_ring(dev);\n\tnetif_trans_update(dev);  \n\tstatus = init_restart_lance(lp);\n#ifdef DEBUG_DRIVER\n\tprintk(\"Lance restart=%d\\n\", status);\n#endif\n\treturn status;\n}\n\nstatic int lance_rx(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile struct lance_rx_desc *rd;\n\tunsigned char bits;\n#ifdef TEST_HITS\n\tint i;\n#endif\n\n#ifdef TEST_HITS\n\tprintk(\"[\");\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tif (i == lp->rx_new)\n\t\t\tprintk(\"%s\",\n\t\t\t       ib->brx_ring[i].rmd1_bits & LE_R1_OWN ? \"_\" : \"X\");\n\t\telse\n\t\t\tprintk(\"%s\",\n\t\t\t      ib->brx_ring[i].rmd1_bits & LE_R1_OWN ? \".\" : \"1\");\n\t}\n\tprintk(\"]\");\n#endif\n#ifdef CONFIG_HP300\n\tblinken_leds(0x40, 0);\n#endif\n\tWRITERDP(lp, LE_C0_RINT | LE_C0_INEA);      \n\tfor (rd = &ib->brx_ring[lp->rx_new];      \n\t     !((bits = rd->rmd1_bits) & LE_R1_OWN);\n\t     rd = &ib->brx_ring[lp->rx_new]) {\n\n\t\t \n\t\tif ((bits & LE_R1_POK) != LE_R1_POK) {\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tdev->stats.rx_errors++;\n\t\t\tcontinue;\n\t\t} else if (bits & LE_R1_ERR) {\n\t\t\t \n\t\t\tif (bits & LE_R1_BUF)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tif (bits & LE_R1_CRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (bits & LE_R1_OFL)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif (bits & LE_R1_FRA)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (bits & LE_R1_EOP)\n\t\t\t\tdev->stats.rx_errors++;\n\t\t} else {\n\t\t\tint len = (rd->mblength & 0xfff) - 4;\n\t\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, len + 2);\n\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\trd->mblength = 0;\n\t\t\t\trd->rmd1_bits = LE_R1_OWN;\n\t\t\t\tlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tskb_reserve(skb, 2);            \n\t\t\tskb_put(skb, len);              \n\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t (unsigned char *)&(ib->rx_buf[lp->rx_new][0]),\n\t\t\t\t\t len);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += len;\n\t\t}\n\n\t\t \n\t\trd->mblength = 0;\n\t\trd->rmd1_bits = LE_R1_OWN;\n\t\tlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\n\t}\n\treturn 0;\n}\n\nstatic int lance_tx(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile struct lance_tx_desc *td;\n\tint i, j;\n\tint status;\n\n#ifdef CONFIG_HP300\n\tblinken_leds(0x80, 0);\n#endif\n\t \n\tWRITERDP(lp, LE_C0_TINT | LE_C0_INEA);\n\t \n\n\tj = lp->tx_old;\n\tfor (i = j; i != lp->tx_new; i = j) {\n\t\ttd = &ib->btx_ring[i];\n\n\t\t \n\t\tif (td->tmd1_bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tif (td->tmd1_bits & LE_T1_ERR) {\n\t\t\tstatus = td->misc;\n\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (status & LE_T3_RTY)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tif (status & LE_T3_LCOL)\n\t\t\t\tdev->stats.tx_window_errors++;\n\n\t\t\tif (status & LE_T3_CLOS) {\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\tif (lp->auto_select) {\n\t\t\t\t\tlp->tpe = 1 - lp->tpe;\n\t\t\t\t\tprintk(\"%s: Carrier Lost, trying %s\\n\",\n\t\t\t\t\t       dev->name,\n\t\t\t\t\t       lp->tpe ? \"TPE\" : \"AUI\");\n\t\t\t\t\t \n\t\t\t\t\tWRITERAP(lp, LE_CSR0);\n\t\t\t\t\tWRITERDP(lp, LE_C0_STOP);\n\t\t\t\t\tlance_init_ring(dev);\n\t\t\t\t\tload_csrs(lp);\n\t\t\t\t\tinit_restart_lance(lp);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tif (status & (LE_T3_BUF|LE_T3_UFL)) {\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\n\t\t\t\tprintk(\"%s: Tx: ERR_BUF|ERR_UFL, restarting\\n\",\n\t\t\t\t       dev->name);\n\t\t\t\t \n\t\t\t\tWRITERAP(lp, LE_CSR0);\n\t\t\t\tWRITERDP(lp, LE_C0_STOP);\n\t\t\t\tlance_init_ring(dev);\n\t\t\t\tload_csrs(lp);\n\t\t\t\tinit_restart_lance(lp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if ((td->tmd1_bits & LE_T1_POK) == LE_T1_POK) {\n\t\t\t \n\t\t\ttd->tmd1_bits &= ~(LE_T1_POK);\n\n\t\t\t \n\t\t\tif (td->tmd1_bits & LE_T1_EONE)\n\t\t\t\tdev->stats.collisions++;\n\n\t\t\t \n\t\t\tif (td->tmd1_bits & LE_T1_EMORE)\n\t\t\t\tdev->stats.collisions += 2;\n\n\t\t\tdev->stats.tx_packets++;\n\t\t}\n\n\t\tj = (j + 1) & lp->tx_ring_mod_mask;\n\t}\n\tlp->tx_old = j;\n\tWRITERDP(lp, LE_C0_TINT | LE_C0_INEA);\n\treturn 0;\n}\n\nstatic irqreturn_t\nlance_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint csr0;\n\n\tspin_lock(&lp->devlock);\n\n\tWRITERAP(lp, LE_CSR0);               \n\tcsr0 = READRDP(lp);\n\n\tPRINT_RINGS();\n\n\tif (!(csr0 & LE_C0_INTR)) {      \n\t\tspin_unlock(&lp->devlock);\n\t\treturn IRQ_NONE;         \n\t}\n\n\t \n\tWRITERDP(lp, csr0 & ~(LE_C0_INEA|LE_C0_TDMD|LE_C0_STOP|LE_C0_STRT|LE_C0_INIT));\n\n\tif ((csr0 & LE_C0_ERR)) {\n\t\t \n\t\tWRITERDP(lp, LE_C0_BABL|LE_C0_ERR|LE_C0_MISS|LE_C0_INEA);\n\t}\n\n\tif (csr0 & LE_C0_RINT)\n\t\tlance_rx(dev);\n\n\tif (csr0 & LE_C0_TINT)\n\t\tlance_tx(dev);\n\n\t \n\tif (csr0 & LE_C0_BABL)\n\t\tdev->stats.tx_errors++;        \n\tif (csr0 & LE_C0_MISS)\n\t\tdev->stats.rx_errors++;        \n\tif (csr0 & LE_C0_MERR) {\n\t\tprintk(\"%s: Bus master arbitration failure, status %4.4x.\\n\",\n\t\t       dev->name, csr0);\n\t\t \n\t\tWRITERDP(lp, LE_C0_STRT);\n\t}\n\n\tif (lp->tx_full && netif_queue_stopped(dev) && (TX_BUFFS_AVAIL >= 0)) {\n\t\tlp->tx_full = 0;\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tWRITERAP(lp, LE_CSR0);\n\tWRITERDP(lp, LE_C0_BABL|LE_C0_CERR|LE_C0_MISS|LE_C0_MERR|LE_C0_IDON|LE_C0_INEA);\n\n\tspin_unlock(&lp->devlock);\n\treturn IRQ_HANDLED;\n}\n\nint lance_open(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint res;\n\n\t \n\tif (request_irq(lp->irq, lance_interrupt, IRQF_SHARED, lp->name, dev))\n\t\treturn -EAGAIN;\n\n\tres = lance_reset(dev);\n\tspin_lock_init(&lp->devlock);\n\tnetif_start_queue(dev);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(lance_open);\n\nint lance_close(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\t \n\tWRITERAP(lp, LE_CSR0);\n\tWRITERDP(lp, LE_C0_STOP);\n\n\tfree_irq(lp->irq, dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lance_close);\n\nvoid lance_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tprintk(\"lance_tx_timeout\\n\");\n\tlance_reset(dev);\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\nEXPORT_SYMBOL_GPL(lance_tx_timeout);\n\nnetdev_tx_t lance_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tint entry, skblen, len;\n\tstatic int outs;\n\tunsigned long flags;\n\n\tnetif_stop_queue(dev);\n\n\tif (!TX_BUFFS_AVAIL) {\n\t\tdev_consume_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tskblen = skb->len;\n\n#ifdef DEBUG_DRIVER\n\t \n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintk(\"\\n\");\n\t\t\tprintk(\"%2.2x \", skb->data[i]);\n\t\t}\n\t}\n#endif\n\tlen = (skblen <= ETH_ZLEN) ? ETH_ZLEN : skblen;\n\tentry = lp->tx_new & lp->tx_ring_mod_mask;\n\tib->btx_ring[entry].length = (-len) | 0xf000;\n\tib->btx_ring[entry].misc = 0;\n\n\tif (skb->len < ETH_ZLEN)\n\t\tmemset((void *)&ib->tx_buf[entry][0], 0, ETH_ZLEN);\n\tskb_copy_from_linear_data(skb, (void *)&ib->tx_buf[entry][0], skblen);\n\n\t \n\tib->btx_ring[entry].tmd1_bits = (LE_T1_POK|LE_T1_OWN);\n\tlp->tx_new = (lp->tx_new + 1) & lp->tx_ring_mod_mask;\n\n\touts++;\n\t \n\tWRITERDP(lp, LE_C0_INEA | LE_C0_TDMD);\n\tdev_consume_skb_any(skb);\n\n\tspin_lock_irqsave(&lp->devlock, flags);\n\tif (TX_BUFFS_AVAIL)\n\t\tnetif_start_queue(dev);\n\telse\n\t\tlp->tx_full = 1;\n\tspin_unlock_irqrestore(&lp->devlock, flags);\n\n\treturn NETDEV_TX_OK;\n}\nEXPORT_SYMBOL_GPL(lance_start_xmit);\n\n \nstatic void lance_load_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile u16 *mcast_table = (u16 *)&ib->filter;\n\tstruct netdev_hw_addr *ha;\n\tu32 crc;\n\n\t \n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tib->filter[0] = 0xffffffff;\n\t\tib->filter[1] = 0xffffffff;\n\t\treturn;\n\t}\n\t \n\tib->filter[0] = 0;\n\tib->filter[1] = 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tcrc = ether_crc_le(6, ha->addr);\n\t\tcrc = crc >> 26;\n\t\tmcast_table[crc >> 4] |= 1 << (crc & 0xf);\n\t}\n}\n\n\nvoid lance_set_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tint stopped;\n\n\tstopped = netif_queue_stopped(dev);\n\tif (!stopped)\n\t\tnetif_stop_queue(dev);\n\n\twhile (lp->tx_old != lp->tx_new)\n\t\tschedule();\n\n\tWRITERAP(lp, LE_CSR0);\n\tWRITERDP(lp, LE_C0_STOP);\n\tlance_init_ring(dev);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tib->mode |= LE_MO_PROM;\n\t} else {\n\t\tib->mode &= ~LE_MO_PROM;\n\t\tlance_load_multicast(dev);\n\t}\n\tload_csrs(lp);\n\tinit_restart_lance(lp);\n\n\tif (!stopped)\n\t\tnetif_start_queue(dev);\n}\nEXPORT_SYMBOL_GPL(lance_set_multicast);\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nvoid lance_poll(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tspin_lock(&lp->devlock);\n\tWRITERAP(lp, LE_CSR0);\n\tWRITERDP(lp, LE_C0_STRT);\n\tspin_unlock(&lp->devlock);\n\tlance_interrupt(dev->irq, dev);\n}\nEXPORT_SYMBOL_GPL(lance_poll);\n#endif\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}