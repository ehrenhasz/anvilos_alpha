{
  "module_name": "au1000_eth.c",
  "hash_id": "4facc1200059fdf7c872d2e4bb8be36925aa740750b8b82339c82f87bf2982ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/au1000_eth.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/ioport.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/cpu.h>\n#include <linux/io.h>\n\n#include <asm/mipsregs.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n\n#include <au1000.h>\n#include <au1xxx_eth.h>\n#include <prom.h>\n\n#include \"au1000_eth.h\"\n\n#ifdef AU1000_ETH_DEBUG\nstatic int au1000_debug = 5;\n#else\nstatic int au1000_debug = 3;\n#endif\n\n#define AU1000_DEF_MSG_ENABLE\t(NETIF_MSG_DRV\t| \\\n\t\t\t\tNETIF_MSG_PROBE\t| \\\n\t\t\t\tNETIF_MSG_LINK)\n\n#define DRV_NAME\t\"au1000_eth\"\n#define DRV_AUTHOR\t\"Pete Popov <ppopov@embeddedalley.com>\"\n#define DRV_DESC\t\"Au1xxx on-chip Ethernet driver\"\n\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n#define MAC_CONTROL\t\t0x0\n#  define MAC_RX_ENABLE\t\t(1 << 2)\n#  define MAC_TX_ENABLE\t\t(1 << 3)\n#  define MAC_DEF_CHECK\t\t(1 << 5)\n#  define MAC_SET_BL(X)\t\t(((X) & 0x3) << 6)\n#  define MAC_AUTO_PAD\t\t(1 << 8)\n#  define MAC_DISABLE_RETRY\t(1 << 10)\n#  define MAC_DISABLE_BCAST\t(1 << 11)\n#  define MAC_LATE_COL\t\t(1 << 12)\n#  define MAC_HASH_MODE\t\t(1 << 13)\n#  define MAC_HASH_ONLY\t\t(1 << 15)\n#  define MAC_PASS_ALL\t\t(1 << 16)\n#  define MAC_INVERSE_FILTER\t(1 << 17)\n#  define MAC_PROMISCUOUS\t(1 << 18)\n#  define MAC_PASS_ALL_MULTI\t(1 << 19)\n#  define MAC_FULL_DUPLEX\t(1 << 20)\n#  define MAC_NORMAL_MODE\t0\n#  define MAC_INT_LOOPBACK\t(1 << 21)\n#  define MAC_EXT_LOOPBACK\t(1 << 22)\n#  define MAC_DISABLE_RX_OWN\t(1 << 23)\n#  define MAC_BIG_ENDIAN\t(1 << 30)\n#  define MAC_RX_ALL\t\t(1 << 31)\n#define MAC_ADDRESS_HIGH\t0x4\n#define MAC_ADDRESS_LOW\t\t0x8\n#define MAC_MCAST_HIGH\t\t0xC\n#define MAC_MCAST_LOW\t\t0x10\n#define MAC_MII_CNTRL\t\t0x14\n#  define MAC_MII_BUSY\t\t(1 << 0)\n#  define MAC_MII_READ\t\t0\n#  define MAC_MII_WRITE\t\t(1 << 1)\n#  define MAC_SET_MII_SELECT_REG(X) (((X) & 0x1f) << 6)\n#  define MAC_SET_MII_SELECT_PHY(X) (((X) & 0x1f) << 11)\n#define MAC_MII_DATA\t\t0x18\n#define MAC_FLOW_CNTRL\t\t0x1C\n#  define MAC_FLOW_CNTRL_BUSY\t(1 << 0)\n#  define MAC_FLOW_CNTRL_ENABLE (1 << 1)\n#  define MAC_PASS_CONTROL\t(1 << 2)\n#  define MAC_SET_PAUSE(X)\t(((X) & 0xffff) << 16)\n#define MAC_VLAN1_TAG\t\t0x20\n#define MAC_VLAN2_TAG\t\t0x24\n\n \n#  define MAC_EN_CLOCK_ENABLE\t(1 << 0)\n#  define MAC_EN_RESET0\t\t(1 << 1)\n#  define MAC_EN_TOSS\t\t(0 << 2)\n#  define MAC_EN_CACHEABLE\t(1 << 3)\n#  define MAC_EN_RESET1\t\t(1 << 4)\n#  define MAC_EN_RESET2\t\t(1 << 5)\n#  define MAC_DMA_RESET\t\t(1 << 6)\n\n \n \n#define MAC_TX_BUFF0_STATUS\t0x0\n#  define TX_FRAME_ABORTED\t(1 << 0)\n#  define TX_JAB_TIMEOUT\t(1 << 1)\n#  define TX_NO_CARRIER\t\t(1 << 2)\n#  define TX_LOSS_CARRIER\t(1 << 3)\n#  define TX_EXC_DEF\t\t(1 << 4)\n#  define TX_LATE_COLL_ABORT\t(1 << 5)\n#  define TX_EXC_COLL\t\t(1 << 6)\n#  define TX_UNDERRUN\t\t(1 << 7)\n#  define TX_DEFERRED\t\t(1 << 8)\n#  define TX_LATE_COLL\t\t(1 << 9)\n#  define TX_COLL_CNT_MASK\t(0xF << 10)\n#  define TX_PKT_RETRY\t\t(1 << 31)\n#define MAC_TX_BUFF0_ADDR\t0x4\n#  define TX_DMA_ENABLE\t\t(1 << 0)\n#  define TX_T_DONE\t\t(1 << 1)\n#  define TX_GET_DMA_BUFFER(X)\t(((X) >> 2) & 0x3)\n#define MAC_TX_BUFF0_LEN\t0x8\n#define MAC_TX_BUFF1_STATUS\t0x10\n#define MAC_TX_BUFF1_ADDR\t0x14\n#define MAC_TX_BUFF1_LEN\t0x18\n#define MAC_TX_BUFF2_STATUS\t0x20\n#define MAC_TX_BUFF2_ADDR\t0x24\n#define MAC_TX_BUFF2_LEN\t0x28\n#define MAC_TX_BUFF3_STATUS\t0x30\n#define MAC_TX_BUFF3_ADDR\t0x34\n#define MAC_TX_BUFF3_LEN\t0x38\n\n \n#define MAC_RX_BUFF0_STATUS\t0x0\n#  define RX_FRAME_LEN_MASK\t0x3fff\n#  define RX_WDOG_TIMER\t\t(1 << 14)\n#  define RX_RUNT\t\t(1 << 15)\n#  define RX_OVERLEN\t\t(1 << 16)\n#  define RX_COLL\t\t(1 << 17)\n#  define RX_ETHER\t\t(1 << 18)\n#  define RX_MII_ERROR\t\t(1 << 19)\n#  define RX_DRIBBLING\t\t(1 << 20)\n#  define RX_CRC_ERROR\t\t(1 << 21)\n#  define RX_VLAN1\t\t(1 << 22)\n#  define RX_VLAN2\t\t(1 << 23)\n#  define RX_LEN_ERROR\t\t(1 << 24)\n#  define RX_CNTRL_FRAME\t(1 << 25)\n#  define RX_U_CNTRL_FRAME\t(1 << 26)\n#  define RX_MCAST_FRAME\t(1 << 27)\n#  define RX_BCAST_FRAME\t(1 << 28)\n#  define RX_FILTER_FAIL\t(1 << 29)\n#  define RX_PACKET_FILTER\t(1 << 30)\n#  define RX_MISSED_FRAME\t(1 << 31)\n\n#  define RX_ERROR (RX_WDOG_TIMER | RX_RUNT | RX_OVERLEN |  \\\n\t\t    RX_COLL | RX_MII_ERROR | RX_CRC_ERROR | \\\n\t\t    RX_LEN_ERROR | RX_U_CNTRL_FRAME | RX_MISSED_FRAME)\n#define MAC_RX_BUFF0_ADDR\t0x4\n#  define RX_DMA_ENABLE\t\t(1 << 0)\n#  define RX_T_DONE\t\t(1 << 1)\n#  define RX_GET_DMA_BUFFER(X)\t(((X) >> 2) & 0x3)\n#  define RX_SET_BUFF_ADDR(X)\t((X) & 0xffffffc0)\n#define MAC_RX_BUFF1_STATUS\t0x10\n#define MAC_RX_BUFF1_ADDR\t0x14\n#define MAC_RX_BUFF2_STATUS\t0x20\n#define MAC_RX_BUFF2_ADDR\t0x24\n#define MAC_RX_BUFF3_STATUS\t0x30\n#define MAC_RX_BUFF3_ADDR\t0x34\n\n \n\n \n\n \n\n \nstatic void au1000_enable_mac(struct net_device *dev, int force_reset)\n{\n\tunsigned long flags;\n\tstruct au1000_private *aup = netdev_priv(dev);\n\n\tspin_lock_irqsave(&aup->lock, flags);\n\n\tif (force_reset || (!aup->mac_enabled)) {\n\t\twritel(MAC_EN_CLOCK_ENABLE, aup->enable);\n\t\twmb();  \n\t\tmdelay(2);\n\t\twritel((MAC_EN_RESET0 | MAC_EN_RESET1 | MAC_EN_RESET2\n\t\t\t\t| MAC_EN_CLOCK_ENABLE), aup->enable);\n\t\twmb();  \n\t\tmdelay(2);\n\n\t\taup->mac_enabled = 1;\n\t}\n\n\tspin_unlock_irqrestore(&aup->lock, flags);\n}\n\n \nstatic int au1000_mdio_read(struct net_device *dev, int phy_addr, int reg)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tu32 *const mii_control_reg = &aup->mac->mii_control;\n\tu32 *const mii_data_reg = &aup->mac->mii_data;\n\tu32 timedout = 20;\n\tu32 mii_control;\n\n\twhile (readl(mii_control_reg) & MAC_MII_BUSY) {\n\t\tmdelay(1);\n\t\tif (--timedout == 0) {\n\t\t\tnetdev_err(dev, \"read_MII busy timeout!!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tmii_control = MAC_SET_MII_SELECT_REG(reg) |\n\t\tMAC_SET_MII_SELECT_PHY(phy_addr) | MAC_MII_READ;\n\n\twritel(mii_control, mii_control_reg);\n\n\ttimedout = 20;\n\twhile (readl(mii_control_reg) & MAC_MII_BUSY) {\n\t\tmdelay(1);\n\t\tif (--timedout == 0) {\n\t\t\tnetdev_err(dev, \"mdio_read busy timeout!!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn readl(mii_data_reg);\n}\n\nstatic void au1000_mdio_write(struct net_device *dev, int phy_addr,\n\t\t\t      int reg, u16 value)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tu32 *const mii_control_reg = &aup->mac->mii_control;\n\tu32 *const mii_data_reg = &aup->mac->mii_data;\n\tu32 timedout = 20;\n\tu32 mii_control;\n\n\twhile (readl(mii_control_reg) & MAC_MII_BUSY) {\n\t\tmdelay(1);\n\t\tif (--timedout == 0) {\n\t\t\tnetdev_err(dev, \"mdio_write busy timeout!!\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmii_control = MAC_SET_MII_SELECT_REG(reg) |\n\t\tMAC_SET_MII_SELECT_PHY(phy_addr) | MAC_MII_WRITE;\n\n\twritel(value, mii_data_reg);\n\twritel(mii_control, mii_control_reg);\n}\n\nstatic int au1000_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)\n{\n\tstruct net_device *const dev = bus->priv;\n\n\t \n\tau1000_enable_mac(dev, 0);\n\n\treturn au1000_mdio_read(dev, phy_addr, regnum);\n}\n\nstatic int au1000_mdiobus_write(struct mii_bus *bus, int phy_addr, int regnum,\n\t\t\t\tu16 value)\n{\n\tstruct net_device *const dev = bus->priv;\n\n\t \n\tau1000_enable_mac(dev, 0);\n\n\tau1000_mdio_write(dev, phy_addr, regnum, value);\n\treturn 0;\n}\n\nstatic int au1000_mdiobus_reset(struct mii_bus *bus)\n{\n\tstruct net_device *const dev = bus->priv;\n\n\t \n\tau1000_enable_mac(dev, 0);\n\n\treturn 0;\n}\n\nstatic void au1000_hard_stop(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tu32 reg;\n\n\tnetif_dbg(aup, drv, dev, \"hard stop\\n\");\n\n\treg = readl(&aup->mac->control);\n\treg &= ~(MAC_RX_ENABLE | MAC_TX_ENABLE);\n\twritel(reg, &aup->mac->control);\n\twmb();  \n\tmdelay(10);\n}\n\nstatic void au1000_enable_rx_tx(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tu32 reg;\n\n\tnetif_dbg(aup, hw, dev, \"enable_rx_tx\\n\");\n\n\treg = readl(&aup->mac->control);\n\treg |= (MAC_RX_ENABLE | MAC_TX_ENABLE);\n\twritel(reg, &aup->mac->control);\n\twmb();  \n\tmdelay(10);\n}\n\nstatic void\nau1000_adjust_link(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tunsigned long flags;\n\tu32 reg;\n\n\tint status_change = 0;\n\n\tBUG_ON(!phydev);\n\n\tspin_lock_irqsave(&aup->lock, flags);\n\n\tif (phydev->link && (aup->old_speed != phydev->speed)) {\n\t\t \n\n\t\tswitch (phydev->speed) {\n\t\tcase SPEED_10:\n\t\tcase SPEED_100:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_warn(dev, \"Speed (%d) is not 10/100 ???\\n\",\n\t\t\t\t\t\t\tphydev->speed);\n\t\t\tbreak;\n\t\t}\n\n\t\taup->old_speed = phydev->speed;\n\n\t\tstatus_change = 1;\n\t}\n\n\tif (phydev->link && (aup->old_duplex != phydev->duplex)) {\n\t\t \n\n\t\t \n\t\tau1000_hard_stop(dev);\n\n\t\treg = readl(&aup->mac->control);\n\t\tif (DUPLEX_FULL == phydev->duplex) {\n\t\t\treg |= MAC_FULL_DUPLEX;\n\t\t\treg &= ~MAC_DISABLE_RX_OWN;\n\t\t} else {\n\t\t\treg &= ~MAC_FULL_DUPLEX;\n\t\t\treg |= MAC_DISABLE_RX_OWN;\n\t\t}\n\t\twritel(reg, &aup->mac->control);\n\t\twmb();  \n\t\tmdelay(1);\n\n\t\tau1000_enable_rx_tx(dev);\n\t\taup->old_duplex = phydev->duplex;\n\n\t\tstatus_change = 1;\n\t}\n\n\tif (phydev->link != aup->old_link) {\n\t\t \n\n\t\tif (!phydev->link) {\n\t\t\t \n\t\t\taup->old_speed = 0;\n\t\t\taup->old_duplex = -1;\n\t\t}\n\n\t\taup->old_link = phydev->link;\n\t\tstatus_change = 1;\n\t}\n\n\tspin_unlock_irqrestore(&aup->lock, flags);\n\n\tif (status_change) {\n\t\tif (phydev->link)\n\t\t\tnetdev_info(dev, \"link up (%d/%s)\\n\",\n\t\t\t       phydev->speed,\n\t\t\t       DUPLEX_FULL == phydev->duplex ? \"Full\" : \"Half\");\n\t\telse\n\t\t\tnetdev_info(dev, \"link down\\n\");\n\t}\n}\n\nstatic int au1000_mii_probe(struct net_device *dev)\n{\n\tstruct au1000_private *const aup = netdev_priv(dev);\n\tstruct phy_device *phydev = NULL;\n\tint phy_addr;\n\n\tif (aup->phy_static_config) {\n\t\tBUG_ON(aup->mac_id < 0 || aup->mac_id > 1);\n\n\t\tif (aup->phy_addr)\n\t\t\tphydev = mdiobus_get_phy(aup->mii_bus, aup->phy_addr);\n\t\telse\n\t\t\tnetdev_info(dev, \"using PHY-less setup\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++)\n\t\tif (mdiobus_get_phy(aup->mii_bus, phy_addr)) {\n\t\t\tphydev = mdiobus_get_phy(aup->mii_bus, phy_addr);\n\t\t\tif (!aup->phy_search_highest_addr)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t}\n\n\tif (aup->phy1_search_mac0) {\n\t\t \n\t\tif (!phydev && (aup->mac_id == 1)) {\n\t\t\t \n\t\t\tdev_info(&dev->dev, \": no PHY found on MAC1, \"\n\t\t\t\t\"let's see if it's attached to MAC0...\\n\");\n\n\t\t\t \n\t\t\tfor (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {\n\t\t\t\tstruct phy_device *const tmp_phydev =\n\t\t\t\t\tmdiobus_get_phy(aup->mii_bus,\n\t\t\t\t\t\t\tphy_addr);\n\n\t\t\t\tif (aup->mac_id == 1)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (!tmp_phydev)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (tmp_phydev->attached_dev)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tphydev = tmp_phydev;\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t}\n\t}\n\n\tif (!phydev) {\n\t\tnetdev_err(dev, \"no PHY found\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tBUG_ON(phydev->attached_dev);\n\n\tphydev = phy_connect(dev, phydev_name(phydev),\n\t\t\t     &au1000_adjust_link, PHY_INTERFACE_MODE_MII);\n\n\tif (IS_ERR(phydev)) {\n\t\tnetdev_err(dev, \"Could not attach to PHY\\n\");\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\tphy_set_max_speed(phydev, SPEED_100);\n\n\taup->old_link = 0;\n\taup->old_speed = 0;\n\taup->old_duplex = -1;\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\n \nstatic struct db_dest *au1000_GetFreeDB(struct au1000_private *aup)\n{\n\tstruct db_dest *pDB;\n\tpDB = aup->pDBfree;\n\n\tif (pDB)\n\t\taup->pDBfree = pDB->pnext;\n\n\treturn pDB;\n}\n\nvoid au1000_ReleaseDB(struct au1000_private *aup, struct db_dest *pDB)\n{\n\tstruct db_dest *pDBfree = aup->pDBfree;\n\tif (pDBfree)\n\t\tpDBfree->pnext = pDB;\n\taup->pDBfree = pDB;\n}\n\nstatic void au1000_reset_mac_unlocked(struct net_device *dev)\n{\n\tstruct au1000_private *const aup = netdev_priv(dev);\n\tint i;\n\n\tau1000_hard_stop(dev);\n\n\twritel(MAC_EN_CLOCK_ENABLE, aup->enable);\n\twmb();  \n\tmdelay(2);\n\twritel(0, aup->enable);\n\twmb();  \n\tmdelay(2);\n\n\taup->tx_full = 0;\n\tfor (i = 0; i < NUM_RX_DMA; i++) {\n\t\t \n\t\taup->rx_dma_ring[i]->buff_stat &= ~0xf;\n\t}\n\tfor (i = 0; i < NUM_TX_DMA; i++) {\n\t\t \n\t\taup->tx_dma_ring[i]->buff_stat &= ~0xf;\n\t}\n\n\taup->mac_enabled = 0;\n\n}\n\nstatic void au1000_reset_mac(struct net_device *dev)\n{\n\tstruct au1000_private *const aup = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnetif_dbg(aup, hw, dev, \"reset mac, aup %x\\n\",\n\t\t\t\t\t(unsigned)aup);\n\n\tspin_lock_irqsave(&aup->lock, flags);\n\n\tau1000_reset_mac_unlocked(dev);\n\n\tspin_unlock_irqrestore(&aup->lock, flags);\n}\n\n \nstatic void\nau1000_setup_hw_rings(struct au1000_private *aup, void __iomem *tx_base)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_RX_DMA; i++) {\n\t\taup->rx_dma_ring[i] = (struct rx_dma *)\n\t\t\t(tx_base + 0x100 + sizeof(struct rx_dma) * i);\n\t}\n\tfor (i = 0; i < NUM_TX_DMA; i++) {\n\t\taup->tx_dma_ring[i] = (struct tx_dma *)\n\t\t\t(tx_base + sizeof(struct tx_dma) * i);\n\t}\n}\n\n \nstatic void\nau1000_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tsnprintf(info->bus_info, sizeof(info->bus_info), \"%s %d\", DRV_NAME,\n\t\t aup->mac_id);\n}\n\nstatic void au1000_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\taup->msg_enable = value;\n}\n\nstatic u32 au1000_get_msglevel(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\treturn aup->msg_enable;\n}\n\nstatic const struct ethtool_ops au1000_ethtool_ops = {\n\t.get_drvinfo = au1000_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_msglevel = au1000_get_msglevel,\n\t.set_msglevel = au1000_set_msglevel,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\n \nstatic int au1000_init(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tunsigned long flags;\n\tint i;\n\tu32 control;\n\n\tnetif_dbg(aup, hw, dev, \"au1000_init\\n\");\n\n\t \n\tau1000_enable_mac(dev, 1);\n\n\tspin_lock_irqsave(&aup->lock, flags);\n\n\twritel(0, &aup->mac->control);\n\taup->tx_head = (aup->tx_dma_ring[0]->buff_stat & 0xC) >> 2;\n\taup->tx_tail = aup->tx_head;\n\taup->rx_head = (aup->rx_dma_ring[0]->buff_stat & 0xC) >> 2;\n\n\twritel(dev->dev_addr[5]<<8 | dev->dev_addr[4],\n\t\t\t\t\t&aup->mac->mac_addr_high);\n\twritel(dev->dev_addr[3]<<24 | dev->dev_addr[2]<<16 |\n\t\tdev->dev_addr[1]<<8 | dev->dev_addr[0],\n\t\t\t\t\t&aup->mac->mac_addr_low);\n\n\n\tfor (i = 0; i < NUM_RX_DMA; i++)\n\t\taup->rx_dma_ring[i]->buff_stat |= RX_DMA_ENABLE;\n\n\twmb();  \n\n\tcontrol = MAC_RX_ENABLE | MAC_TX_ENABLE;\n#ifndef CONFIG_CPU_LITTLE_ENDIAN\n\tcontrol |= MAC_BIG_ENDIAN;\n#endif\n\tif (dev->phydev) {\n\t\tif (dev->phydev->link && (DUPLEX_FULL == dev->phydev->duplex))\n\t\t\tcontrol |= MAC_FULL_DUPLEX;\n\t\telse\n\t\t\tcontrol |= MAC_DISABLE_RX_OWN;\n\t} else {  \n\t\tcontrol |= MAC_FULL_DUPLEX;\n\t}\n\n\twritel(control, &aup->mac->control);\n\twritel(0x8100, &aup->mac->vlan1_tag);  \n\twmb();  \n\n\tspin_unlock_irqrestore(&aup->lock, flags);\n\treturn 0;\n}\n\nstatic inline void au1000_update_rx_stats(struct net_device *dev, u32 status)\n{\n\tstruct net_device_stats *ps = &dev->stats;\n\n\tps->rx_packets++;\n\tif (status & RX_MCAST_FRAME)\n\t\tps->multicast++;\n\n\tif (status & RX_ERROR) {\n\t\tps->rx_errors++;\n\t\tif (status & RX_MISSED_FRAME)\n\t\t\tps->rx_missed_errors++;\n\t\tif (status & (RX_OVERLEN | RX_RUNT | RX_LEN_ERROR))\n\t\t\tps->rx_length_errors++;\n\t\tif (status & RX_CRC_ERROR)\n\t\t\tps->rx_crc_errors++;\n\t\tif (status & RX_COLL)\n\t\t\tps->collisions++;\n\t} else\n\t\tps->rx_bytes += status & RX_FRAME_LEN_MASK;\n\n}\n\n \nstatic int au1000_rx(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct rx_dma *prxd;\n\tu32 buff_stat, status;\n\tstruct db_dest *pDB;\n\tu32\tfrmlen;\n\n\tnetif_dbg(aup, rx_status, dev, \"au1000_rx head %d\\n\", aup->rx_head);\n\n\tprxd = aup->rx_dma_ring[aup->rx_head];\n\tbuff_stat = prxd->buff_stat;\n\twhile (buff_stat & RX_T_DONE)  {\n\t\tstatus = prxd->status;\n\t\tpDB = aup->rx_db_inuse[aup->rx_head];\n\t\tau1000_update_rx_stats(dev, status);\n\t\tif (!(status & RX_ERROR))  {\n\n\t\t\t \n\t\t\tfrmlen = (status & RX_FRAME_LEN_MASK);\n\t\t\tfrmlen -= 4;  \n\t\t\tskb = netdev_alloc_skb(dev, frmlen + 2);\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t(unsigned char *)pDB->vaddr, frmlen);\n\t\t\tskb_put(skb, frmlen);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\t \n\t\t} else {\n\t\t\tif (au1000_debug > 4) {\n\t\t\t\tpr_err(\"rx_error(s):\");\n\t\t\t\tif (status & RX_MISSED_FRAME)\n\t\t\t\t\tpr_cont(\" miss\");\n\t\t\t\tif (status & RX_WDOG_TIMER)\n\t\t\t\t\tpr_cont(\" wdog\");\n\t\t\t\tif (status & RX_RUNT)\n\t\t\t\t\tpr_cont(\" runt\");\n\t\t\t\tif (status & RX_OVERLEN)\n\t\t\t\t\tpr_cont(\" overlen\");\n\t\t\t\tif (status & RX_COLL)\n\t\t\t\t\tpr_cont(\" coll\");\n\t\t\t\tif (status & RX_MII_ERROR)\n\t\t\t\t\tpr_cont(\" mii error\");\n\t\t\t\tif (status & RX_CRC_ERROR)\n\t\t\t\t\tpr_cont(\" crc error\");\n\t\t\t\tif (status & RX_LEN_ERROR)\n\t\t\t\t\tpr_cont(\" len error\");\n\t\t\t\tif (status & RX_U_CNTRL_FRAME)\n\t\t\t\t\tpr_cont(\" u control frame\");\n\t\t\t\tpr_cont(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tprxd->buff_stat = lower_32_bits(pDB->dma_addr) | RX_DMA_ENABLE;\n\t\taup->rx_head = (aup->rx_head + 1) & (NUM_RX_DMA - 1);\n\t\twmb();  \n\n\t\t \n\t\tprxd = aup->rx_dma_ring[aup->rx_head];\n\t\tbuff_stat = prxd->buff_stat;\n\t}\n\treturn 0;\n}\n\nstatic void au1000_update_tx_stats(struct net_device *dev, u32 status)\n{\n\tstruct net_device_stats *ps = &dev->stats;\n\n\tif (status & TX_FRAME_ABORTED) {\n\t\tif (!dev->phydev || (DUPLEX_FULL == dev->phydev->duplex)) {\n\t\t\tif (status & (TX_JAB_TIMEOUT | TX_UNDERRUN)) {\n\t\t\t\t \n\t\t\t\tps->tx_errors++;\n\t\t\t\tps->tx_aborted_errors++;\n\t\t\t}\n\t\t} else {\n\t\t\tps->tx_errors++;\n\t\t\tps->tx_aborted_errors++;\n\t\t\tif (status & (TX_NO_CARRIER | TX_LOSS_CARRIER))\n\t\t\t\tps->tx_carrier_errors++;\n\t\t}\n\t}\n}\n\n \nstatic void au1000_tx_ack(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tstruct tx_dma *ptxd;\n\n\tptxd = aup->tx_dma_ring[aup->tx_tail];\n\n\twhile (ptxd->buff_stat & TX_T_DONE) {\n\t\tau1000_update_tx_stats(dev, ptxd->status);\n\t\tptxd->buff_stat &= ~TX_T_DONE;\n\t\tptxd->len = 0;\n\t\twmb();  \n\n\t\taup->tx_tail = (aup->tx_tail + 1) & (NUM_TX_DMA - 1);\n\t\tptxd = aup->tx_dma_ring[aup->tx_tail];\n\n\t\tif (aup->tx_full) {\n\t\t\taup->tx_full = 0;\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t au1000_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\n\t \n\n\tau1000_rx(dev);\n\tau1000_tx_ack(dev);\n\treturn IRQ_RETVAL(1);\n}\n\nstatic int au1000_open(struct net_device *dev)\n{\n\tint retval;\n\tstruct au1000_private *aup = netdev_priv(dev);\n\n\tnetif_dbg(aup, drv, dev, \"open: dev=%p\\n\", dev);\n\n\tretval = request_irq(dev->irq, au1000_interrupt, 0,\n\t\t\t\t\tdev->name, dev);\n\tif (retval) {\n\t\tnetdev_err(dev, \"unable to get IRQ %d\\n\", dev->irq);\n\t\treturn retval;\n\t}\n\n\tretval = au1000_init(dev);\n\tif (retval) {\n\t\tnetdev_err(dev, \"error in au1000_init\\n\");\n\t\tfree_irq(dev->irq, dev);\n\t\treturn retval;\n\t}\n\n\tif (dev->phydev)\n\t\tphy_start(dev->phydev);\n\n\tnetif_start_queue(dev);\n\n\tnetif_dbg(aup, drv, dev, \"open: Initialization done.\\n\");\n\n\treturn 0;\n}\n\nstatic int au1000_close(struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct au1000_private *const aup = netdev_priv(dev);\n\n\tnetif_dbg(aup, drv, dev, \"close: dev=%p\\n\", dev);\n\n\tif (dev->phydev)\n\t\tphy_stop(dev->phydev);\n\n\tspin_lock_irqsave(&aup->lock, flags);\n\n\tau1000_reset_mac_unlocked(dev);\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tfree_irq(dev->irq, dev);\n\tspin_unlock_irqrestore(&aup->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t au1000_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tstruct net_device_stats *ps = &dev->stats;\n\tstruct tx_dma *ptxd;\n\tu32 buff_stat;\n\tstruct db_dest *pDB;\n\tint i;\n\n\tnetif_dbg(aup, tx_queued, dev, \"tx: aup %x len=%d, data=%p, head %d\\n\",\n\t\t\t\t(unsigned)aup, skb->len,\n\t\t\t\tskb->data, aup->tx_head);\n\n\tptxd = aup->tx_dma_ring[aup->tx_head];\n\tbuff_stat = ptxd->buff_stat;\n\tif (buff_stat & TX_DMA_ENABLE) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\taup->tx_full = 1;\n\t\treturn NETDEV_TX_BUSY;\n\t} else if (buff_stat & TX_T_DONE) {\n\t\tau1000_update_tx_stats(dev, ptxd->status);\n\t\tptxd->len = 0;\n\t}\n\n\tif (aup->tx_full) {\n\t\taup->tx_full = 0;\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tpDB = aup->tx_db_inuse[aup->tx_head];\n\tskb_copy_from_linear_data(skb, (void *)pDB->vaddr, skb->len);\n\tif (skb->len < ETH_ZLEN) {\n\t\tfor (i = skb->len; i < ETH_ZLEN; i++)\n\t\t\t((char *)pDB->vaddr)[i] = 0;\n\n\t\tptxd->len = ETH_ZLEN;\n\t} else\n\t\tptxd->len = skb->len;\n\n\tps->tx_packets++;\n\tps->tx_bytes += ptxd->len;\n\n\tptxd->buff_stat = lower_32_bits(pDB->dma_addr) | TX_DMA_ENABLE;\n\twmb();  \n\tdev_kfree_skb(skb);\n\taup->tx_head = (aup->tx_head + 1) & (NUM_TX_DMA - 1);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void au1000_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tnetdev_err(dev, \"au1000_tx_timeout: dev=%p\\n\", dev);\n\tau1000_reset_mac(dev);\n\tau1000_init(dev);\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\nstatic void au1000_multicast_list(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tu32 reg;\n\n\tnetif_dbg(aup, drv, dev, \"%s: flags=%x\\n\", __func__, dev->flags);\n\treg = readl(&aup->mac->control);\n\tif (dev->flags & IFF_PROMISC) {\t\t\t \n\t\treg |= MAC_PROMISCUOUS;\n\t} else if ((dev->flags & IFF_ALLMULTI)  ||\n\t\t\t   netdev_mc_count(dev) > MULTICAST_FILTER_LIMIT) {\n\t\treg |= MAC_PASS_ALL_MULTI;\n\t\treg &= ~MAC_PROMISCUOUS;\n\t\tnetdev_info(dev, \"Pass all multicast\\n\");\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 mc_filter[2];\t \n\n\t\tmc_filter[1] = mc_filter[0] = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tset_bit(ether_crc(ETH_ALEN, ha->addr)>>26,\n\t\t\t\t\t(long *)mc_filter);\n\t\twritel(mc_filter[1], &aup->mac->multi_hash_high);\n\t\twritel(mc_filter[0], &aup->mac->multi_hash_low);\n\t\treg &= ~MAC_PROMISCUOUS;\n\t\treg |= MAC_HASH_MODE;\n\t}\n\twritel(reg, &aup->mac->control);\n}\n\nstatic const struct net_device_ops au1000_netdev_ops = {\n\t.ndo_open\t\t= au1000_open,\n\t.ndo_stop\t\t= au1000_close,\n\t.ndo_start_xmit\t\t= au1000_tx,\n\t.ndo_set_rx_mode\t= au1000_multicast_list,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_tx_timeout\t\t= au1000_tx_timeout,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int au1000_probe(struct platform_device *pdev)\n{\n\tstruct au1000_private *aup = NULL;\n\tstruct au1000_eth_platform_data *pd;\n\tstruct net_device *dev = NULL;\n\tstruct db_dest *pDB, *pDBfree;\n\tint irq, i, err = 0;\n\tstruct resource *base, *macen, *macdma;\n\n\tbase = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!base) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve base register\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tmacen = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!macen) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve MAC Enable register\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tmacdma = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\tif (!macdma) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve MACDMA registers\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!request_mem_region(base->start, resource_size(base),\n\t\t\t\t\t\t\tpdev->name)) {\n\t\tdev_err(&pdev->dev, \"failed to request memory region for base registers\\n\");\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (!request_mem_region(macen->start, resource_size(macen),\n\t\t\t\t\t\t\tpdev->name)) {\n\t\tdev_err(&pdev->dev, \"failed to request memory region for MAC enable register\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_request;\n\t}\n\n\tif (!request_mem_region(macdma->start, resource_size(macdma),\n\t\t\t\t\t\t\tpdev->name)) {\n\t\tdev_err(&pdev->dev, \"failed to request MACDMA memory region\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_macdma;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct au1000_private));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tplatform_set_drvdata(pdev, dev);\n\taup = netdev_priv(dev);\n\n\tspin_lock_init(&aup->lock);\n\taup->msg_enable = (au1000_debug < 4 ?\n\t\t\t\tAU1000_DEF_MSG_ENABLE : au1000_debug);\n\n\t \n\taup->vaddr = dma_alloc_coherent(&pdev->dev, MAX_BUF_SIZE *\n\t\t\t\t\t(NUM_TX_BUFFS + NUM_RX_BUFFS),\n\t\t\t\t\t&aup->dma_addr, 0);\n\tif (!aup->vaddr) {\n\t\tdev_err(&pdev->dev, \"failed to allocate data buffers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_vaddr;\n\t}\n\n\t \n\taup->mac = (struct mac_reg *)\n\t\t\tioremap(base->start, resource_size(base));\n\tif (!aup->mac) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap MAC registers\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_remap1;\n\t}\n\n\t \n\taup->enable = (u32 *)ioremap(macen->start,\n\t\t\t\t\t\tresource_size(macen));\n\tif (!aup->enable) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap MAC enable register\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_remap2;\n\t}\n\taup->mac_id = pdev->id;\n\n\taup->macdma = ioremap(macdma->start, resource_size(macdma));\n\tif (!aup->macdma) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap MACDMA registers\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_remap3;\n\t}\n\n\tau1000_setup_hw_rings(aup, aup->macdma);\n\n\twritel(0, aup->enable);\n\taup->mac_enabled = 0;\n\n\tpd = dev_get_platdata(&pdev->dev);\n\tif (!pd) {\n\t\tdev_info(&pdev->dev, \"no platform_data passed,\"\n\t\t\t\t\t\" PHY search on MAC0\\n\");\n\t\taup->phy1_search_mac0 = 1;\n\t} else {\n\t\tif (is_valid_ether_addr(pd->mac)) {\n\t\t\teth_hw_addr_set(dev, pd->mac);\n\t\t} else {\n\t\t\t \n\t\t\teth_hw_addr_random(dev);\n\t\t}\n\n\t\taup->phy_static_config = pd->phy_static_config;\n\t\taup->phy_search_highest_addr = pd->phy_search_highest_addr;\n\t\taup->phy1_search_mac0 = pd->phy1_search_mac0;\n\t\taup->phy_addr = pd->phy_addr;\n\t\taup->phy_busid = pd->phy_busid;\n\t\taup->phy_irq = pd->phy_irq;\n\t}\n\n\tif (aup->phy_busid > 0) {\n\t\tdev_err(&pdev->dev, \"MAC0-associated PHY attached 2nd MACs MII bus not supported yet\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_mdiobus_alloc;\n\t}\n\n\taup->mii_bus = mdiobus_alloc();\n\tif (!aup->mii_bus) {\n\t\tdev_err(&pdev->dev, \"failed to allocate mdiobus structure\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_mdiobus_alloc;\n\t}\n\n\taup->mii_bus->priv = dev;\n\taup->mii_bus->read = au1000_mdiobus_read;\n\taup->mii_bus->write = au1000_mdiobus_write;\n\taup->mii_bus->reset = au1000_mdiobus_reset;\n\taup->mii_bus->name = \"au1000_eth_mii\";\n\tsnprintf(aup->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\tpdev->name, aup->mac_id);\n\n\t \n\tif (aup->phy_static_config)\n\t\tif (aup->phy_irq && aup->phy_busid == aup->mac_id)\n\t\t\taup->mii_bus->irq[aup->phy_addr] = aup->phy_irq;\n\n\terr = mdiobus_register(aup->mii_bus);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register MDIO bus\\n\");\n\t\tgoto err_mdiobus_reg;\n\t}\n\n\terr = au1000_mii_probe(dev);\n\tif (err != 0)\n\t\tgoto err_out;\n\n\tpDBfree = NULL;\n\t \n\tpDB = aup->db;\n\tfor (i = 0; i < (NUM_TX_BUFFS+NUM_RX_BUFFS); i++) {\n\t\tpDB->pnext = pDBfree;\n\t\tpDBfree = pDB;\n\t\tpDB->vaddr = aup->vaddr + MAX_BUF_SIZE * i;\n\t\tpDB->dma_addr = aup->dma_addr + MAX_BUF_SIZE * i;\n\t\tpDB++;\n\t}\n\taup->pDBfree = pDBfree;\n\n\terr = -ENODEV;\n\tfor (i = 0; i < NUM_RX_DMA; i++) {\n\t\tpDB = au1000_GetFreeDB(aup);\n\t\tif (!pDB)\n\t\t\tgoto err_out;\n\n\t\taup->rx_dma_ring[i]->buff_stat = lower_32_bits(pDB->dma_addr);\n\t\taup->rx_db_inuse[i] = pDB;\n\t}\n\n\tfor (i = 0; i < NUM_TX_DMA; i++) {\n\t\tpDB = au1000_GetFreeDB(aup);\n\t\tif (!pDB)\n\t\t\tgoto err_out;\n\n\t\taup->tx_dma_ring[i]->buff_stat = lower_32_bits(pDB->dma_addr);\n\t\taup->tx_dma_ring[i]->len = 0;\n\t\taup->tx_db_inuse[i] = pDB;\n\t}\n\n\tdev->base_addr = base->start;\n\tdev->irq = irq;\n\tdev->netdev_ops = &au1000_netdev_ops;\n\tdev->ethtool_ops = &au1000_ethtool_ops;\n\tdev->watchdog_timeo = ETH_TX_TIMEOUT;\n\n\t \n\tau1000_reset_mac(dev);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"Cannot register net device, aborting.\\n\");\n\t\tgoto err_out;\n\t}\n\n\tnetdev_info(dev, \"Au1xx0 Ethernet found at 0x%lx, irq %d\\n\",\n\t\t\t(unsigned long)base->start, irq);\n\n\treturn 0;\n\nerr_out:\n\tif (aup->mii_bus)\n\t\tmdiobus_unregister(aup->mii_bus);\n\n\t \n\tau1000_reset_mac(dev);\n\n\tfor (i = 0; i < NUM_RX_DMA; i++) {\n\t\tif (aup->rx_db_inuse[i])\n\t\t\tau1000_ReleaseDB(aup, aup->rx_db_inuse[i]);\n\t}\n\tfor (i = 0; i < NUM_TX_DMA; i++) {\n\t\tif (aup->tx_db_inuse[i])\n\t\t\tau1000_ReleaseDB(aup, aup->tx_db_inuse[i]);\n\t}\nerr_mdiobus_reg:\n\tmdiobus_free(aup->mii_bus);\nerr_mdiobus_alloc:\n\tiounmap(aup->macdma);\nerr_remap3:\n\tiounmap(aup->enable);\nerr_remap2:\n\tiounmap(aup->mac);\nerr_remap1:\n\tdma_free_coherent(&pdev->dev, MAX_BUF_SIZE * (NUM_TX_BUFFS + NUM_RX_BUFFS),\n\t\t\t  aup->vaddr, aup->dma_addr);\nerr_vaddr:\n\tfree_netdev(dev);\nerr_alloc:\n\trelease_mem_region(macdma->start, resource_size(macdma));\nerr_macdma:\n\trelease_mem_region(macen->start, resource_size(macen));\nerr_request:\n\trelease_mem_region(base->start, resource_size(base));\nout:\n\treturn err;\n}\n\nstatic int au1000_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tint i;\n\tstruct resource *base, *macen;\n\n\tunregister_netdev(dev);\n\tmdiobus_unregister(aup->mii_bus);\n\tmdiobus_free(aup->mii_bus);\n\n\tfor (i = 0; i < NUM_RX_DMA; i++)\n\t\tif (aup->rx_db_inuse[i])\n\t\t\tau1000_ReleaseDB(aup, aup->rx_db_inuse[i]);\n\n\tfor (i = 0; i < NUM_TX_DMA; i++)\n\t\tif (aup->tx_db_inuse[i])\n\t\t\tau1000_ReleaseDB(aup, aup->tx_db_inuse[i]);\n\n\tdma_free_coherent(&pdev->dev, MAX_BUF_SIZE * (NUM_TX_BUFFS + NUM_RX_BUFFS),\n\t\t\t  aup->vaddr, aup->dma_addr);\n\n\tiounmap(aup->macdma);\n\tiounmap(aup->mac);\n\tiounmap(aup->enable);\n\n\tbase = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\trelease_mem_region(base->start, resource_size(base));\n\n\tbase = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(base->start, resource_size(base));\n\n\tmacen = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\trelease_mem_region(macen->start, resource_size(macen));\n\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver au1000_eth_driver = {\n\t.probe  = au1000_probe,\n\t.remove = au1000_remove,\n\t.driver = {\n\t\t.name   = \"au1000-eth\",\n\t},\n};\n\nmodule_platform_driver(au1000_eth_driver);\n\nMODULE_ALIAS(\"platform:au1000-eth\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}