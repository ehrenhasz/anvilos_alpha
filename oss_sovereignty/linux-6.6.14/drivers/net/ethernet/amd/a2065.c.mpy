{
  "module_name": "a2065.c",
  "hash_id": "75368f292abd4d20ae2316944b3da9fe2e0dfbdb50da8bbf15c1a7c71336ea5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/a2065.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n \n \n\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n#include <linux/zorro.h>\n#include <linux/bitops.h>\n\n#include <asm/byteorder.h>\n#include <asm/irq.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n\n#include \"a2065.h\"\n\n \n\n#define LANCE_LOG_TX_BUFFERS\t(2)\n#define LANCE_LOG_RX_BUFFERS\t(4)\n\n#define TX_RING_SIZE\t\t(1 << LANCE_LOG_TX_BUFFERS)\n#define RX_RING_SIZE\t\t(1 << LANCE_LOG_RX_BUFFERS)\n\n#define TX_RING_MOD_MASK\t(TX_RING_SIZE - 1)\n#define RX_RING_MOD_MASK\t(RX_RING_SIZE - 1)\n\n#define PKT_BUF_SIZE\t\t(1544)\n#define RX_BUFF_SIZE            PKT_BUF_SIZE\n#define TX_BUFF_SIZE            PKT_BUF_SIZE\n\n \n\nstruct lance_init_block {\n\tunsigned short mode;\t\t \n\tunsigned char phys_addr[6];      \n\tunsigned filter[2];\t\t \n\n\t \n\tunsigned short rx_ptr;\t\t \n\tunsigned short rx_len;\t\t \n\tunsigned short tx_ptr;\t\t \n\tunsigned short tx_len;\t\t \n\n\t \n\tstruct lance_rx_desc brx_ring[RX_RING_SIZE];\n\tstruct lance_tx_desc btx_ring[TX_RING_SIZE];\n\n\tchar rx_buf[RX_RING_SIZE][RX_BUFF_SIZE];\n\tchar tx_buf[TX_RING_SIZE][TX_BUFF_SIZE];\n};\n\n \n\nstruct lance_private {\n\tchar *name;\n\tvolatile struct lance_regs *ll;\n\tvolatile struct lance_init_block *init_block;\t     \n\tvolatile struct lance_init_block *lance_init_block;  \n\n\tint rx_new, tx_new;\n\tint rx_old, tx_old;\n\n\tint lance_log_rx_bufs, lance_log_tx_bufs;\n\tint rx_ring_mod_mask, tx_ring_mod_mask;\n\n\tint tpe;\t\t       \n\tint auto_select;\t       \n\tunsigned short busmaster_regval;\n\n\tstruct timer_list         multicast_timer;\n\tstruct net_device\t  *dev;\n};\n\n#define LANCE_ADDR(x) ((int)(x) & ~0xff000000)\n\n \nstatic void load_csrs(struct lance_private *lp)\n{\n\tvolatile struct lance_regs *ll = lp->ll;\n\tvolatile struct lance_init_block *aib = lp->lance_init_block;\n\tint leptr = LANCE_ADDR(aib);\n\n\tll->rap = LE_CSR1;\n\tll->rdp = (leptr & 0xFFFF);\n\tll->rap = LE_CSR2;\n\tll->rdp = leptr >> 16;\n\tll->rap = LE_CSR3;\n\tll->rdp = lp->busmaster_regval;\n\n\t \n\tll->rap = LE_CSR0;\n}\n\n \nstatic void lance_init_ring(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile struct lance_init_block *aib = lp->lance_init_block;\n\t\t\t\t\t \n\tint leptr;\n\tint i;\n\n\t \n\tnetif_stop_queue(dev);\n\tlp->rx_new = lp->tx_new = 0;\n\tlp->rx_old = lp->tx_old = 0;\n\n\tib->mode = 0;\n\n\t \n\tib->phys_addr[0] = dev->dev_addr[1];\n\tib->phys_addr[1] = dev->dev_addr[0];\n\tib->phys_addr[2] = dev->dev_addr[3];\n\tib->phys_addr[3] = dev->dev_addr[2];\n\tib->phys_addr[4] = dev->dev_addr[5];\n\tib->phys_addr[5] = dev->dev_addr[4];\n\n\t \n\tnetdev_dbg(dev, \"TX rings:\\n\");\n\tfor (i = 0; i <= 1 << lp->lance_log_tx_bufs; i++) {\n\t\tleptr = LANCE_ADDR(&aib->tx_buf[i][0]);\n\t\tib->btx_ring[i].tmd0      = leptr;\n\t\tib->btx_ring[i].tmd1_hadr = leptr >> 16;\n\t\tib->btx_ring[i].tmd1_bits = 0;\n\t\tib->btx_ring[i].length    = 0xf000;  \n\t\tib->btx_ring[i].misc      = 0;\n\t\tif (i < 3)\n\t\t\tnetdev_dbg(dev, \"%d: 0x%08x\\n\", i, leptr);\n\t}\n\n\t \n\tnetdev_dbg(dev, \"RX rings:\\n\");\n\tfor (i = 0; i < 1 << lp->lance_log_rx_bufs; i++) {\n\t\tleptr = LANCE_ADDR(&aib->rx_buf[i][0]);\n\n\t\tib->brx_ring[i].rmd0      = leptr;\n\t\tib->brx_ring[i].rmd1_hadr = leptr >> 16;\n\t\tib->brx_ring[i].rmd1_bits = LE_R1_OWN;\n\t\tib->brx_ring[i].length    = -RX_BUFF_SIZE | 0xf000;\n\t\tib->brx_ring[i].mblength  = 0;\n\t\tif (i < 3)\n\t\t\tnetdev_dbg(dev, \"%d: 0x%08x\\n\", i, leptr);\n\t}\n\n\t \n\n\t \n\tleptr = LANCE_ADDR(&aib->brx_ring);\n\tib->rx_len = (lp->lance_log_rx_bufs << 13) | (leptr >> 16);\n\tib->rx_ptr = leptr;\n\tnetdev_dbg(dev, \"RX ptr: %08x\\n\", leptr);\n\n\t \n\tleptr = LANCE_ADDR(&aib->btx_ring);\n\tib->tx_len = (lp->lance_log_tx_bufs << 13) | (leptr >> 16);\n\tib->tx_ptr = leptr;\n\tnetdev_dbg(dev, \"TX ptr: %08x\\n\", leptr);\n\n\t \n\tib->filter[0] = 0;\n\tib->filter[1] = 0;\n}\n\nstatic int init_restart_lance(struct lance_private *lp)\n{\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint i;\n\n\tll->rap = LE_CSR0;\n\tll->rdp = LE_C0_INIT;\n\n\t \n\tfor (i = 0; (i < 100) && !(ll->rdp & (LE_C0_ERR | LE_C0_IDON)); i++)\n\t\tbarrier();\n\tif ((i == 100) || (ll->rdp & LE_C0_ERR)) {\n\t\tpr_err(\"unopened after %d ticks, csr0=%04x\\n\", i, ll->rdp);\n\t\treturn -EIO;\n\t}\n\n\t \n\tll->rdp = LE_C0_IDON;\n\tll->rdp = LE_C0_INEA | LE_C0_STRT;\n\n\treturn 0;\n}\n\nstatic int lance_rx(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile struct lance_regs *ll = lp->ll;\n\tvolatile struct lance_rx_desc *rd;\n\tunsigned char bits;\n\n#ifdef TEST_HITS\n\tint i;\n\tchar buf[RX_RING_SIZE + 1];\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tchar r1_own = ib->brx_ring[i].rmd1_bits & LE_R1_OWN;\n\t\tif (i == lp->rx_new)\n\t\t\tbuf[i] = r1_own ? '_' : 'X';\n\t\telse\n\t\t\tbuf[i] = r1_own ? '.' : '1';\n\t}\n\tbuf[RX_RING_SIZE] = 0;\n\n\tpr_debug(\"RxRing TestHits: [%s]\\n\", buf);\n#endif\n\n\tll->rdp = LE_C0_RINT | LE_C0_INEA;\n\tfor (rd = &ib->brx_ring[lp->rx_new];\n\t     !((bits = rd->rmd1_bits) & LE_R1_OWN);\n\t     rd = &ib->brx_ring[lp->rx_new]) {\n\n\t\t \n\t\tif ((bits & LE_R1_POK) != LE_R1_POK) {\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tdev->stats.rx_errors++;\n\t\t\tcontinue;\n\t\t} else if (bits & LE_R1_ERR) {\n\t\t\t \n\t\t\tif (bits & LE_R1_BUF)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tif (bits & LE_R1_CRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (bits & LE_R1_OFL)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif (bits & LE_R1_FRA)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (bits & LE_R1_EOP)\n\t\t\t\tdev->stats.rx_errors++;\n\t\t} else {\n\t\t\tint len = (rd->mblength & 0xfff) - 4;\n\t\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, len + 2);\n\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\trd->mblength = 0;\n\t\t\t\trd->rmd1_bits = LE_R1_OWN;\n\t\t\t\tlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tskb_reserve(skb, 2);\t\t \n\t\t\tskb_put(skb, len);\t\t \n\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t (unsigned char *)&ib->rx_buf[lp->rx_new][0],\n\t\t\t\t len);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += len;\n\t\t}\n\n\t\t \n\t\trd->mblength = 0;\n\t\trd->rmd1_bits = LE_R1_OWN;\n\t\tlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\n\t}\n\treturn 0;\n}\n\nstatic int lance_tx(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile struct lance_regs *ll = lp->ll;\n\tvolatile struct lance_tx_desc *td;\n\tint i, j;\n\tint status;\n\n\t \n\tll->rdp = LE_C0_TINT | LE_C0_INEA;\n\t \n\n\tj = lp->tx_old;\n\tfor (i = j; i != lp->tx_new; i = j) {\n\t\ttd = &ib->btx_ring[i];\n\n\t\t \n\t\tif (td->tmd1_bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tif (td->tmd1_bits & LE_T1_ERR) {\n\t\t\tstatus = td->misc;\n\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (status & LE_T3_RTY)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tif (status & LE_T3_LCOL)\n\t\t\t\tdev->stats.tx_window_errors++;\n\n\t\t\tif (status & LE_T3_CLOS) {\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\tif (lp->auto_select) {\n\t\t\t\t\tlp->tpe = 1 - lp->tpe;\n\t\t\t\t\tnetdev_err(dev, \"Carrier Lost, trying %s\\n\",\n\t\t\t\t\t\t   lp->tpe ? \"TPE\" : \"AUI\");\n\t\t\t\t\t \n\t\t\t\t\tll->rap = LE_CSR0;\n\t\t\t\t\tll->rdp = LE_C0_STOP;\n\t\t\t\t\tlance_init_ring(dev);\n\t\t\t\t\tload_csrs(lp);\n\t\t\t\t\tinit_restart_lance(lp);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (status & (LE_T3_BUF | LE_T3_UFL)) {\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\n\t\t\t\tnetdev_err(dev, \"Tx: ERR_BUF|ERR_UFL, restarting\\n\");\n\t\t\t\t \n\t\t\t\tll->rap = LE_CSR0;\n\t\t\t\tll->rdp = LE_C0_STOP;\n\t\t\t\tlance_init_ring(dev);\n\t\t\t\tload_csrs(lp);\n\t\t\t\tinit_restart_lance(lp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if ((td->tmd1_bits & LE_T1_POK) == LE_T1_POK) {\n\t\t\t \n\t\t\ttd->tmd1_bits &= ~(LE_T1_POK);\n\n\t\t\t \n\t\t\tif (td->tmd1_bits & LE_T1_EONE)\n\t\t\t\tdev->stats.collisions++;\n\n\t\t\t \n\t\t\tif (td->tmd1_bits & LE_T1_EMORE)\n\t\t\t\tdev->stats.collisions += 2;\n\n\t\t\tdev->stats.tx_packets++;\n\t\t}\n\n\t\tj = (j + 1) & lp->tx_ring_mod_mask;\n\t}\n\tlp->tx_old = j;\n\tll->rdp = LE_C0_TINT | LE_C0_INEA;\n\treturn 0;\n}\n\nstatic int lance_tx_buffs_avail(struct lance_private *lp)\n{\n\tif (lp->tx_old <= lp->tx_new)\n\t\treturn lp->tx_old + lp->tx_ring_mod_mask - lp->tx_new;\n\treturn lp->tx_old - lp->tx_new - 1;\n}\n\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint csr0;\n\n\tll->rap = LE_CSR0;\t\t \n\tcsr0 = ll->rdp;\n\n\tif (!(csr0 & LE_C0_INTR))\t \n\t\treturn IRQ_NONE;\t \n\n\t \n\tll->rdp = csr0 & ~(LE_C0_INEA | LE_C0_TDMD | LE_C0_STOP | LE_C0_STRT |\n\t\t\t   LE_C0_INIT);\n\n\tif (csr0 & LE_C0_ERR) {\n\t\t \n\t\tll->rdp = LE_C0_BABL | LE_C0_ERR | LE_C0_MISS | LE_C0_INEA;\n\t}\n\n\tif (csr0 & LE_C0_RINT)\n\t\tlance_rx(dev);\n\n\tif (csr0 & LE_C0_TINT)\n\t\tlance_tx(dev);\n\n\t \n\tif (csr0 & LE_C0_BABL)\n\t\tdev->stats.tx_errors++;        \n\tif (csr0 & LE_C0_MISS)\n\t\tdev->stats.rx_errors++;        \n\tif (csr0 & LE_C0_MERR) {\n\t\tnetdev_err(dev, \"Bus master arbitration failure, status %04x\\n\",\n\t\t\t   csr0);\n\t\t \n\t\tll->rdp = LE_C0_STRT;\n\t}\n\n\tif (netif_queue_stopped(dev) && lance_tx_buffs_avail(lp) > 0)\n\t\tnetif_wake_queue(dev);\n\n\tll->rap = LE_CSR0;\n\tll->rdp = (LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR |\n\t\t   LE_C0_IDON | LE_C0_INEA);\n\treturn IRQ_HANDLED;\n}\n\nstatic int lance_open(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint ret;\n\n\t \n\tll->rap = LE_CSR0;\n\tll->rdp = LE_C0_STOP;\n\n\t \n\tret = request_irq(IRQ_AMIGA_PORTS, lance_interrupt, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tload_csrs(lp);\n\tlance_init_ring(dev);\n\n\tnetif_start_queue(dev);\n\n\treturn init_restart_lance(lp);\n}\n\nstatic int lance_close(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\n\tnetif_stop_queue(dev);\n\tdel_timer_sync(&lp->multicast_timer);\n\n\t \n\tll->rap = LE_CSR0;\n\tll->rdp = LE_C0_STOP;\n\n\tfree_irq(IRQ_AMIGA_PORTS, dev);\n\treturn 0;\n}\n\nstatic inline int lance_reset(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint status;\n\n\t \n\tll->rap = LE_CSR0;\n\tll->rdp = LE_C0_STOP;\n\n\tload_csrs(lp);\n\n\tlance_init_ring(dev);\n\tnetif_trans_update(dev);  \n\tnetif_start_queue(dev);\n\n\tstatus = init_restart_lance(lp);\n\tnetdev_dbg(dev, \"Lance restart=%d\\n\", status);\n\n\treturn status;\n}\n\nstatic void lance_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\n\tnetdev_err(dev, \"transmit timed out, status %04x, reset\\n\", ll->rdp);\n\tlance_reset(dev);\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tint entry, skblen;\n\tint status = NETDEV_TX_OK;\n\tunsigned long flags;\n\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\tskblen = max_t(unsigned, skb->len, ETH_ZLEN);\n\n\tlocal_irq_save(flags);\n\n\tif (!lance_tx_buffs_avail(lp))\n\t\tgoto out_free;\n\n\t \n\tprint_hex_dump_debug(\"skb->data: \", DUMP_PREFIX_NONE, 16, 1, skb->data,\n\t\t\t     64, true);\n\n\tentry = lp->tx_new & lp->tx_ring_mod_mask;\n\tib->btx_ring[entry].length = (-skblen) | 0xf000;\n\tib->btx_ring[entry].misc = 0;\n\n\tskb_copy_from_linear_data(skb, (void *)&ib->tx_buf[entry][0], skblen);\n\n\t \n\tib->btx_ring[entry].tmd1_bits = (LE_T1_POK | LE_T1_OWN);\n\tlp->tx_new = (lp->tx_new+1) & lp->tx_ring_mod_mask;\n\tdev->stats.tx_bytes += skblen;\n\n\tif (lance_tx_buffs_avail(lp) <= 0)\n\t\tnetif_stop_queue(dev);\n\n\t \n\tll->rdp = LE_C0_INEA | LE_C0_TDMD;\n out_free:\n\tdev_kfree_skb(skb);\n\n\tlocal_irq_restore(flags);\n\n\treturn status;\n}\n\n \nstatic void lance_load_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile u16 *mcast_table = (u16 *)&ib->filter;\n\tstruct netdev_hw_addr *ha;\n\tu32 crc;\n\n\t \n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tib->filter[0] = 0xffffffff;\n\t\tib->filter[1] = 0xffffffff;\n\t\treturn;\n\t}\n\t \n\tib->filter[0] = 0;\n\tib->filter[1] = 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tcrc = ether_crc_le(6, ha->addr);\n\t\tcrc = crc >> 26;\n\t\tmcast_table[crc >> 4] |= 1 << (crc & 0xf);\n\t}\n}\n\nstatic void lance_set_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_init_block *ib = lp->init_block;\n\tvolatile struct lance_regs *ll = lp->ll;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tif (lp->tx_old != lp->tx_new) {\n\t\tmod_timer(&lp->multicast_timer, jiffies + 4);\n\t\tnetif_wake_queue(dev);\n\t\treturn;\n\t}\n\n\tnetif_stop_queue(dev);\n\n\tll->rap = LE_CSR0;\n\tll->rdp = LE_C0_STOP;\n\tlance_init_ring(dev);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tib->mode |= LE_MO_PROM;\n\t} else {\n\t\tib->mode &= ~LE_MO_PROM;\n\t\tlance_load_multicast(dev);\n\t}\n\tload_csrs(lp);\n\tinit_restart_lance(lp);\n\tnetif_wake_queue(dev);\n}\n\nstatic void lance_set_multicast_retry(struct timer_list *t)\n{\n\tstruct lance_private *lp = from_timer(lp, t, multicast_timer);\n\n\tlance_set_multicast(lp->dev);\n}\n\nstatic int a2065_init_one(struct zorro_dev *z,\n\t\t\t  const struct zorro_device_id *ent);\nstatic void a2065_remove_one(struct zorro_dev *z);\n\n\nstatic const struct zorro_device_id a2065_zorro_tbl[] = {\n\t{ ZORRO_PROD_CBM_A2065_1 },\n\t{ ZORRO_PROD_CBM_A2065_2 },\n\t{ ZORRO_PROD_AMERISTAR_A2065 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, a2065_zorro_tbl);\n\nstatic struct zorro_driver a2065_driver = {\n\t.name\t\t= \"a2065\",\n\t.id_table\t= a2065_zorro_tbl,\n\t.probe\t\t= a2065_init_one,\n\t.remove\t\t= a2065_remove_one,\n};\n\nstatic const struct net_device_ops lance_netdev_ops = {\n\t.ndo_open\t\t= lance_open,\n\t.ndo_stop\t\t= lance_close,\n\t.ndo_start_xmit\t\t= lance_start_xmit,\n\t.ndo_tx_timeout\t\t= lance_tx_timeout,\n\t.ndo_set_rx_mode\t= lance_set_multicast,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int a2065_init_one(struct zorro_dev *z,\n\t\t\t  const struct zorro_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct lance_private *priv;\n\tunsigned long board = z->resource.start;\n\tunsigned long base_addr = board + A2065_LANCE;\n\tunsigned long mem_start = board + A2065_RAM;\n\tstruct resource *r1, *r2;\n\tu8 addr[ETH_ALEN];\n\tu32 serial;\n\tint err;\n\n\tr1 = request_mem_region(base_addr, sizeof(struct lance_regs),\n\t\t\t\t\"Am7990\");\n\tif (!r1)\n\t\treturn -EBUSY;\n\tr2 = request_mem_region(mem_start, A2065_RAM_SIZE, \"RAM\");\n\tif (!r2) {\n\t\trelease_mem_region(base_addr, sizeof(struct lance_regs));\n\t\treturn -EBUSY;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct lance_private));\n\tif (!dev) {\n\t\trelease_mem_region(base_addr, sizeof(struct lance_regs));\n\t\trelease_mem_region(mem_start, A2065_RAM_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(dev);\n\n\tr1->name = dev->name;\n\tr2->name = dev->name;\n\n\tserial = be32_to_cpu(z->rom.er_SerialNumber);\n\taddr[0] = 0x00;\n\tif (z->id != ZORRO_PROD_AMERISTAR_A2065) {\t \n\t\taddr[1] = 0x80;\n\t\taddr[2] = 0x10;\n\t} else {\t\t\t\t\t \n\t\taddr[1] = 0x00;\n\t\taddr[2] = 0x9f;\n\t}\n\taddr[3] = (serial >> 16) & 0xff;\n\taddr[4] = (serial >> 8) & 0xff;\n\taddr[5] = serial & 0xff;\n\teth_hw_addr_set(dev, addr);\n\tdev->base_addr = (unsigned long)ZTWO_VADDR(base_addr);\n\tdev->mem_start = (unsigned long)ZTWO_VADDR(mem_start);\n\tdev->mem_end = dev->mem_start + A2065_RAM_SIZE;\n\n\tpriv->ll = (volatile struct lance_regs *)dev->base_addr;\n\tpriv->init_block = (struct lance_init_block *)dev->mem_start;\n\tpriv->lance_init_block = (struct lance_init_block *)A2065_RAM;\n\tpriv->auto_select = 0;\n\tpriv->busmaster_regval = LE_C3_BSWP;\n\n\tpriv->lance_log_rx_bufs = LANCE_LOG_RX_BUFFERS;\n\tpriv->lance_log_tx_bufs = LANCE_LOG_TX_BUFFERS;\n\tpriv->rx_ring_mod_mask = RX_RING_MOD_MASK;\n\tpriv->tx_ring_mod_mask = TX_RING_MOD_MASK;\n\tpriv->dev = dev;\n\n\tdev->netdev_ops = &lance_netdev_ops;\n\tdev->watchdog_timeo = 5*HZ;\n\tdev->dma = 0;\n\n\ttimer_setup(&priv->multicast_timer, lance_set_multicast_retry, 0);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\trelease_mem_region(base_addr, sizeof(struct lance_regs));\n\t\trelease_mem_region(mem_start, A2065_RAM_SIZE);\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\tzorro_set_drvdata(z, dev);\n\n\tnetdev_info(dev, \"A2065 at 0x%08lx, Ethernet Address %pM\\n\",\n\t\t    board, dev->dev_addr);\n\n\treturn 0;\n}\n\n\nstatic void a2065_remove_one(struct zorro_dev *z)\n{\n\tstruct net_device *dev = zorro_get_drvdata(z);\n\n\tunregister_netdev(dev);\n\trelease_mem_region(ZTWO_PADDR(dev->base_addr),\n\t\t\t   sizeof(struct lance_regs));\n\trelease_mem_region(ZTWO_PADDR(dev->mem_start), A2065_RAM_SIZE);\n\tfree_netdev(dev);\n}\n\nstatic int __init a2065_init_module(void)\n{\n\treturn zorro_register_driver(&a2065_driver);\n}\n\nstatic void __exit a2065_cleanup_module(void)\n{\n\tzorro_unregister_driver(&a2065_driver);\n}\n\nmodule_init(a2065_init_module);\nmodule_exit(a2065_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}