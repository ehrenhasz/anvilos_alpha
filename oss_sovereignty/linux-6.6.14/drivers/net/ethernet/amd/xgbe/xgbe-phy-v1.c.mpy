{
  "module_name": "xgbe-phy-v1.c",
  "hash_id": "123264495944e6832abbf6c660c06619117d9c9e7611575e44073ee6190095e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-phy-v1.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n#include <linux/property.h>\n#include <linux/mdio.h>\n#include <linux/phy.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\n#define XGBE_BLWC_PROPERTY\t\t\"amd,serdes-blwc\"\n#define XGBE_CDR_RATE_PROPERTY\t\t\"amd,serdes-cdr-rate\"\n#define XGBE_PQ_SKEW_PROPERTY\t\t\"amd,serdes-pq-skew\"\n#define XGBE_TX_AMP_PROPERTY\t\t\"amd,serdes-tx-amp\"\n#define XGBE_DFE_CFG_PROPERTY\t\t\"amd,serdes-dfe-tap-config\"\n#define XGBE_DFE_ENA_PROPERTY\t\t\"amd,serdes-dfe-tap-enable\"\n\n \n#define XGBE_SPEED_1000_BLWC\t\t1\n#define XGBE_SPEED_1000_CDR\t\t0x2\n#define XGBE_SPEED_1000_PLL\t\t0x0\n#define XGBE_SPEED_1000_PQ\t\t0xa\n#define XGBE_SPEED_1000_RATE\t\t0x3\n#define XGBE_SPEED_1000_TXAMP\t\t0xf\n#define XGBE_SPEED_1000_WORD\t\t0x1\n#define XGBE_SPEED_1000_DFE_TAP_CONFIG\t0x3\n#define XGBE_SPEED_1000_DFE_TAP_ENABLE\t0x0\n\n#define XGBE_SPEED_2500_BLWC\t\t1\n#define XGBE_SPEED_2500_CDR\t\t0x2\n#define XGBE_SPEED_2500_PLL\t\t0x0\n#define XGBE_SPEED_2500_PQ\t\t0xa\n#define XGBE_SPEED_2500_RATE\t\t0x1\n#define XGBE_SPEED_2500_TXAMP\t\t0xf\n#define XGBE_SPEED_2500_WORD\t\t0x1\n#define XGBE_SPEED_2500_DFE_TAP_CONFIG\t0x3\n#define XGBE_SPEED_2500_DFE_TAP_ENABLE\t0x0\n\n#define XGBE_SPEED_10000_BLWC\t\t0\n#define XGBE_SPEED_10000_CDR\t\t0x7\n#define XGBE_SPEED_10000_PLL\t\t0x1\n#define XGBE_SPEED_10000_PQ\t\t0x12\n#define XGBE_SPEED_10000_RATE\t\t0x0\n#define XGBE_SPEED_10000_TXAMP\t\t0xa\n#define XGBE_SPEED_10000_WORD\t\t0x7\n#define XGBE_SPEED_10000_DFE_TAP_CONFIG\t0x1\n#define XGBE_SPEED_10000_DFE_TAP_ENABLE\t0x7f\n\n \n#define XGBE_RATECHANGE_COUNT\t\t500\n\nstatic const u32 xgbe_phy_blwc[] = {\n\tXGBE_SPEED_1000_BLWC,\n\tXGBE_SPEED_2500_BLWC,\n\tXGBE_SPEED_10000_BLWC,\n};\n\nstatic const u32 xgbe_phy_cdr_rate[] = {\n\tXGBE_SPEED_1000_CDR,\n\tXGBE_SPEED_2500_CDR,\n\tXGBE_SPEED_10000_CDR,\n};\n\nstatic const u32 xgbe_phy_pq_skew[] = {\n\tXGBE_SPEED_1000_PQ,\n\tXGBE_SPEED_2500_PQ,\n\tXGBE_SPEED_10000_PQ,\n};\n\nstatic const u32 xgbe_phy_tx_amp[] = {\n\tXGBE_SPEED_1000_TXAMP,\n\tXGBE_SPEED_2500_TXAMP,\n\tXGBE_SPEED_10000_TXAMP,\n};\n\nstatic const u32 xgbe_phy_dfe_tap_cfg[] = {\n\tXGBE_SPEED_1000_DFE_TAP_CONFIG,\n\tXGBE_SPEED_2500_DFE_TAP_CONFIG,\n\tXGBE_SPEED_10000_DFE_TAP_CONFIG,\n};\n\nstatic const u32 xgbe_phy_dfe_tap_ena[] = {\n\tXGBE_SPEED_1000_DFE_TAP_ENABLE,\n\tXGBE_SPEED_2500_DFE_TAP_ENABLE,\n\tXGBE_SPEED_10000_DFE_TAP_ENABLE,\n};\n\nstruct xgbe_phy_data {\n\t \n\tunsigned int speed_set;\n\n\t \n\tu32 blwc[XGBE_SPEEDS];\n\tu32 cdr_rate[XGBE_SPEEDS];\n\tu32 pq_skew[XGBE_SPEEDS];\n\tu32 tx_amp[XGBE_SPEEDS];\n\tu32 dfe_tap_cfg[XGBE_SPEEDS];\n\tu32 dfe_tap_ena[XGBE_SPEEDS];\n};\n\nstatic void xgbe_phy_kr_training_pre(struct xgbe_prv_data *pdata)\n{\n\t\tXSIR0_IOWRITE_BITS(pdata, SIR0_KR_RT_1, RESET, 1);\n}\n\nstatic void xgbe_phy_kr_training_post(struct xgbe_prv_data *pdata)\n{\n\t\tXSIR0_IOWRITE_BITS(pdata, SIR0_KR_RT_1, RESET, 0);\n}\n\nstatic enum xgbe_mode xgbe_phy_an_outcome(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tenum xgbe_mode mode;\n\tunsigned int ad_reg, lp_reg;\n\n\tXGBE_SET_LP_ADV(lks, Autoneg);\n\tXGBE_SET_LP_ADV(lks, Backplane);\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA);\n\tif (lp_reg & 0x400)\n\t\tXGBE_SET_LP_ADV(lks, Pause);\n\tif (lp_reg & 0x800)\n\t\tXGBE_SET_LP_ADV(lks, Asym_Pause);\n\n\tif (pdata->phy.pause_autoneg) {\n\t\t \n\t\tpdata->phy.tx_pause = 0;\n\t\tpdata->phy.rx_pause = 0;\n\n\t\tif (ad_reg & lp_reg & 0x400) {\n\t\t\tpdata->phy.tx_pause = 1;\n\t\t\tpdata->phy.rx_pause = 1;\n\t\t} else if (ad_reg & lp_reg & 0x800) {\n\t\t\tif (ad_reg & 0x400)\n\t\t\t\tpdata->phy.rx_pause = 1;\n\t\t\telse if (lp_reg & 0x400)\n\t\t\t\tpdata->phy.tx_pause = 1;\n\t\t}\n\t}\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);\n\tif (lp_reg & 0x80)\n\t\tXGBE_SET_LP_ADV(lks, 10000baseKR_Full);\n\tif (lp_reg & 0x20) {\n\t\tif (phy_data->speed_set == XGBE_SPEEDSET_2500_10000)\n\t\t\tXGBE_SET_LP_ADV(lks, 2500baseX_Full);\n\t\telse\n\t\t\tXGBE_SET_LP_ADV(lks, 1000baseKX_Full);\n\t}\n\n\tad_reg &= lp_reg;\n\tif (ad_reg & 0x80) {\n\t\tmode = XGBE_MODE_KR;\n\t} else if (ad_reg & 0x20) {\n\t\tif (phy_data->speed_set == XGBE_SPEEDSET_2500_10000)\n\t\t\tmode = XGBE_MODE_KX_2500;\n\t\telse\n\t\t\tmode = XGBE_MODE_KX_1000;\n\t} else {\n\t\tmode = XGBE_MODE_UNKNOWN;\n\t}\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);\n\tif (lp_reg & 0xc000)\n\t\tXGBE_SET_LP_ADV(lks, 10000baseR_FEC);\n\n\treturn mode;\n}\n\nstatic void xgbe_phy_an_advertising(struct xgbe_prv_data *pdata,\n\t\t\t\t    struct ethtool_link_ksettings *dlks)\n{\n\tstruct ethtool_link_ksettings *slks = &pdata->phy.lks;\n\n\tXGBE_LM_COPY(dlks, advertising, slks, advertising);\n}\n\nstatic int xgbe_phy_an_config(struct xgbe_prv_data *pdata)\n{\n\t \n\treturn 0;\n}\n\nstatic enum xgbe_an_mode xgbe_phy_an_mode(struct xgbe_prv_data *pdata)\n{\n\treturn XGBE_AN_MODE_CL73;\n}\n\nstatic void xgbe_phy_pcs_power_cycle(struct xgbe_prv_data *pdata)\n{\n\tunsigned int reg;\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\n\treg |= MDIO_CTRL1_LPOWER;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, reg);\n\n\tusleep_range(75, 100);\n\n\treg &= ~MDIO_CTRL1_LPOWER;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, reg);\n}\n\nstatic void xgbe_phy_start_ratechange(struct xgbe_prv_data *pdata)\n{\n\t \n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, RATECHANGE, 1);\n}\n\nstatic void xgbe_phy_complete_ratechange(struct xgbe_prv_data *pdata)\n{\n\tunsigned int wait;\n\tu16 status;\n\n\t \n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, RATECHANGE, 0);\n\n\t \n\twait = XGBE_RATECHANGE_COUNT;\n\twhile (wait--) {\n\t\tusleep_range(50, 75);\n\n\t\tstatus = XSIR0_IOREAD(pdata, SIR0_STATUS);\n\t\tif (XSIR_GET_BITS(status, SIR0_STATUS, RX_READY) &&\n\t\t    XSIR_GET_BITS(status, SIR0_STATUS, TX_READY))\n\t\t\tgoto rx_reset;\n\t}\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"SerDes rx/tx not ready (%#hx)\\n\",\n\t\t  status);\n\nrx_reset:\n\t \n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG6, RESETB_RXD, 0);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG6, RESETB_RXD, 1);\n}\n\nstatic void xgbe_phy_kr_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int reg;\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL2);\n\treg &= ~MDIO_PCS_CTRL2_TYPE;\n\treg |= MDIO_PCS_CTRL2_10GBR;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL2, reg);\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\treg &= ~MDIO_CTRL1_SPEEDSEL;\n\treg |= MDIO_CTRL1_SPEED10G;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, reg);\n\n\txgbe_phy_pcs_power_cycle(pdata);\n\n\t \n\txgbe_phy_start_ratechange(pdata);\n\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, DATARATE, XGBE_SPEED_10000_RATE);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, WORDMODE, XGBE_SPEED_10000_WORD);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, PLLSEL, XGBE_SPEED_10000_PLL);\n\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, CDR_RATE,\n\t\t\t   phy_data->cdr_rate[XGBE_SPEED_10000]);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, TXAMP,\n\t\t\t   phy_data->tx_amp[XGBE_SPEED_10000]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG20, BLWC_ENA,\n\t\t\t   phy_data->blwc[XGBE_SPEED_10000]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG114, PQ_REG,\n\t\t\t   phy_data->pq_skew[XGBE_SPEED_10000]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG129, RXDFE_CONFIG,\n\t\t\t   phy_data->dfe_tap_cfg[XGBE_SPEED_10000]);\n\tXRXTX_IOWRITE(pdata, RXTX_REG22,\n\t\t      phy_data->dfe_tap_ena[XGBE_SPEED_10000]);\n\n\txgbe_phy_complete_ratechange(pdata);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"10GbE KR mode set\\n\");\n}\n\nstatic void xgbe_phy_kx_2500_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int reg;\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL2);\n\treg &= ~MDIO_PCS_CTRL2_TYPE;\n\treg |= MDIO_PCS_CTRL2_10GBX;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL2, reg);\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\treg &= ~MDIO_CTRL1_SPEEDSEL;\n\treg |= MDIO_CTRL1_SPEED1G;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, reg);\n\n\txgbe_phy_pcs_power_cycle(pdata);\n\n\t \n\txgbe_phy_start_ratechange(pdata);\n\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, DATARATE, XGBE_SPEED_2500_RATE);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, WORDMODE, XGBE_SPEED_2500_WORD);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, PLLSEL, XGBE_SPEED_2500_PLL);\n\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, CDR_RATE,\n\t\t\t   phy_data->cdr_rate[XGBE_SPEED_2500]);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, TXAMP,\n\t\t\t   phy_data->tx_amp[XGBE_SPEED_2500]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG20, BLWC_ENA,\n\t\t\t   phy_data->blwc[XGBE_SPEED_2500]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG114, PQ_REG,\n\t\t\t   phy_data->pq_skew[XGBE_SPEED_2500]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG129, RXDFE_CONFIG,\n\t\t\t   phy_data->dfe_tap_cfg[XGBE_SPEED_2500]);\n\tXRXTX_IOWRITE(pdata, RXTX_REG22,\n\t\t      phy_data->dfe_tap_ena[XGBE_SPEED_2500]);\n\n\txgbe_phy_complete_ratechange(pdata);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"2.5GbE KX mode set\\n\");\n}\n\nstatic void xgbe_phy_kx_1000_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int reg;\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL2);\n\treg &= ~MDIO_PCS_CTRL2_TYPE;\n\treg |= MDIO_PCS_CTRL2_10GBX;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL2, reg);\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\treg &= ~MDIO_CTRL1_SPEEDSEL;\n\treg |= MDIO_CTRL1_SPEED1G;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, reg);\n\n\txgbe_phy_pcs_power_cycle(pdata);\n\n\t \n\txgbe_phy_start_ratechange(pdata);\n\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, DATARATE, XGBE_SPEED_1000_RATE);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, WORDMODE, XGBE_SPEED_1000_WORD);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, PLLSEL, XGBE_SPEED_1000_PLL);\n\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, CDR_RATE,\n\t\t\t   phy_data->cdr_rate[XGBE_SPEED_1000]);\n\tXSIR1_IOWRITE_BITS(pdata, SIR1_SPEED, TXAMP,\n\t\t\t   phy_data->tx_amp[XGBE_SPEED_1000]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG20, BLWC_ENA,\n\t\t\t   phy_data->blwc[XGBE_SPEED_1000]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG114, PQ_REG,\n\t\t\t   phy_data->pq_skew[XGBE_SPEED_1000]);\n\tXRXTX_IOWRITE_BITS(pdata, RXTX_REG129, RXDFE_CONFIG,\n\t\t\t   phy_data->dfe_tap_cfg[XGBE_SPEED_1000]);\n\tXRXTX_IOWRITE(pdata, RXTX_REG22,\n\t\t      phy_data->dfe_tap_ena[XGBE_SPEED_1000]);\n\n\txgbe_phy_complete_ratechange(pdata);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"1GbE KX mode set\\n\");\n}\n\nstatic enum xgbe_mode xgbe_phy_cur_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tenum xgbe_mode mode;\n\tunsigned int reg;\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL2);\n\treg &= MDIO_PCS_CTRL2_TYPE;\n\n\tif (reg == MDIO_PCS_CTRL2_10GBR) {\n\t\tmode = XGBE_MODE_KR;\n\t} else {\n\t\tif (phy_data->speed_set == XGBE_SPEEDSET_2500_10000)\n\t\t\tmode = XGBE_MODE_KX_2500;\n\t\telse\n\t\t\tmode = XGBE_MODE_KX_1000;\n\t}\n\n\treturn mode;\n}\n\nstatic enum xgbe_mode xgbe_phy_switch_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tenum xgbe_mode mode;\n\n\t \n\tif (xgbe_phy_cur_mode(pdata) == XGBE_MODE_KR) {\n\t\tif (phy_data->speed_set == XGBE_SPEEDSET_2500_10000)\n\t\t\tmode = XGBE_MODE_KX_2500;\n\t\telse\n\t\t\tmode = XGBE_MODE_KX_1000;\n\t} else {\n\t\tmode = XGBE_MODE_KR;\n\t}\n\n\treturn mode;\n}\n\nstatic enum xgbe_mode xgbe_phy_get_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t\tint speed)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\treturn (phy_data->speed_set == XGBE_SPEEDSET_1000_10000)\n\t\t\t? XGBE_MODE_KX_1000 : XGBE_MODE_UNKNOWN;\n\tcase SPEED_2500:\n\t\treturn (phy_data->speed_set == XGBE_SPEEDSET_2500_10000)\n\t\t\t? XGBE_MODE_KX_2500 : XGBE_MODE_UNKNOWN;\n\tcase SPEED_10000:\n\t\treturn XGBE_MODE_KR;\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic void xgbe_phy_set_mode(struct xgbe_prv_data *pdata, enum xgbe_mode mode)\n{\n\tswitch (mode) {\n\tcase XGBE_MODE_KX_1000:\n\t\txgbe_phy_kx_1000_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_KX_2500:\n\t\txgbe_phy_kx_2500_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_KR:\n\t\txgbe_phy_kr_mode(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool xgbe_phy_check_mode(struct xgbe_prv_data *pdata,\n\t\t\t\tenum xgbe_mode mode, bool advert)\n{\n\tif (pdata->phy.autoneg == AUTONEG_ENABLE) {\n\t\treturn advert;\n\t} else {\n\t\tenum xgbe_mode cur_mode;\n\n\t\tcur_mode = xgbe_phy_get_mode(pdata, pdata->phy.speed);\n\t\tif (cur_mode == mode)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool xgbe_phy_use_mode(struct xgbe_prv_data *pdata, enum xgbe_mode mode)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\tswitch (mode) {\n\tcase XGBE_MODE_KX_1000:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 1000baseKX_Full));\n\tcase XGBE_MODE_KX_2500:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 2500baseX_Full));\n\tcase XGBE_MODE_KR:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseKR_Full));\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_valid_speed(struct xgbe_prv_data *pdata, int speed)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tif (phy_data->speed_set != XGBE_SPEEDSET_1000_10000)\n\t\t\treturn false;\n\t\treturn true;\n\tcase SPEED_2500:\n\t\tif (phy_data->speed_set != XGBE_SPEEDSET_2500_10000)\n\t\t\treturn false;\n\t\treturn true;\n\tcase SPEED_10000:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int xgbe_phy_link_status(struct xgbe_prv_data *pdata, int *an_restart)\n{\n\tunsigned int reg;\n\n\t*an_restart = 0;\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);\n\n\treturn (reg & MDIO_STAT1_LSTATUS) ? 1 : 0;\n}\n\nstatic void xgbe_phy_stop(struct xgbe_prv_data *pdata)\n{\n\t \n}\n\nstatic int xgbe_phy_start(struct xgbe_prv_data *pdata)\n{\n\t \n\treturn 0;\n}\n\nstatic int xgbe_phy_reset(struct xgbe_prv_data *pdata)\n{\n\tunsigned int reg, count;\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\treg |= MDIO_CTRL1_RESET;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, reg);\n\n\tcount = 50;\n\tdo {\n\t\tmsleep(20);\n\t\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\t} while ((reg & MDIO_CTRL1_RESET) && --count);\n\n\tif (reg & MDIO_CTRL1_RESET)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void xgbe_phy_exit(struct xgbe_prv_data *pdata)\n{\n\t \n}\n\nstatic int xgbe_phy_init(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data;\n\tint ret;\n\n\tphy_data = devm_kzalloc(pdata->dev, sizeof(*phy_data), GFP_KERNEL);\n\tif (!phy_data)\n\t\treturn -ENOMEM;\n\n\t \n\tret = device_property_read_u32(pdata->phy_dev, XGBE_SPEEDSET_PROPERTY,\n\t\t\t\t       &phy_data->speed_set);\n\tif (ret) {\n\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\tXGBE_SPEEDSET_PROPERTY);\n\t\treturn ret;\n\t}\n\n\tswitch (phy_data->speed_set) {\n\tcase XGBE_SPEEDSET_1000_10000:\n\tcase XGBE_SPEEDSET_2500_10000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\tXGBE_SPEEDSET_PROPERTY);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (device_property_present(pdata->phy_dev, XGBE_BLWC_PROPERTY)) {\n\t\tret = device_property_read_u32_array(pdata->phy_dev,\n\t\t\t\t\t\t     XGBE_BLWC_PROPERTY,\n\t\t\t\t\t\t     phy_data->blwc,\n\t\t\t\t\t\t     XGBE_SPEEDS);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\t\tXGBE_BLWC_PROPERTY);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmemcpy(phy_data->blwc, xgbe_phy_blwc,\n\t\t       sizeof(phy_data->blwc));\n\t}\n\n\tif (device_property_present(pdata->phy_dev, XGBE_CDR_RATE_PROPERTY)) {\n\t\tret = device_property_read_u32_array(pdata->phy_dev,\n\t\t\t\t\t\t     XGBE_CDR_RATE_PROPERTY,\n\t\t\t\t\t\t     phy_data->cdr_rate,\n\t\t\t\t\t\t     XGBE_SPEEDS);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\t\tXGBE_CDR_RATE_PROPERTY);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmemcpy(phy_data->cdr_rate, xgbe_phy_cdr_rate,\n\t\t       sizeof(phy_data->cdr_rate));\n\t}\n\n\tif (device_property_present(pdata->phy_dev, XGBE_PQ_SKEW_PROPERTY)) {\n\t\tret = device_property_read_u32_array(pdata->phy_dev,\n\t\t\t\t\t\t     XGBE_PQ_SKEW_PROPERTY,\n\t\t\t\t\t\t     phy_data->pq_skew,\n\t\t\t\t\t\t     XGBE_SPEEDS);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\t\tXGBE_PQ_SKEW_PROPERTY);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmemcpy(phy_data->pq_skew, xgbe_phy_pq_skew,\n\t\t       sizeof(phy_data->pq_skew));\n\t}\n\n\tif (device_property_present(pdata->phy_dev, XGBE_TX_AMP_PROPERTY)) {\n\t\tret = device_property_read_u32_array(pdata->phy_dev,\n\t\t\t\t\t\t     XGBE_TX_AMP_PROPERTY,\n\t\t\t\t\t\t     phy_data->tx_amp,\n\t\t\t\t\t\t     XGBE_SPEEDS);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\t\tXGBE_TX_AMP_PROPERTY);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmemcpy(phy_data->tx_amp, xgbe_phy_tx_amp,\n\t\t       sizeof(phy_data->tx_amp));\n\t}\n\n\tif (device_property_present(pdata->phy_dev, XGBE_DFE_CFG_PROPERTY)) {\n\t\tret = device_property_read_u32_array(pdata->phy_dev,\n\t\t\t\t\t\t     XGBE_DFE_CFG_PROPERTY,\n\t\t\t\t\t\t     phy_data->dfe_tap_cfg,\n\t\t\t\t\t\t     XGBE_SPEEDS);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\t\tXGBE_DFE_CFG_PROPERTY);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmemcpy(phy_data->dfe_tap_cfg, xgbe_phy_dfe_tap_cfg,\n\t\t       sizeof(phy_data->dfe_tap_cfg));\n\t}\n\n\tif (device_property_present(pdata->phy_dev, XGBE_DFE_ENA_PROPERTY)) {\n\t\tret = device_property_read_u32_array(pdata->phy_dev,\n\t\t\t\t\t\t     XGBE_DFE_ENA_PROPERTY,\n\t\t\t\t\t\t     phy_data->dfe_tap_ena,\n\t\t\t\t\t\t     XGBE_SPEEDS);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev, \"invalid %s property\\n\",\n\t\t\t\tXGBE_DFE_ENA_PROPERTY);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmemcpy(phy_data->dfe_tap_ena, xgbe_phy_dfe_tap_ena,\n\t\t       sizeof(phy_data->dfe_tap_ena));\n\t}\n\n\t \n\tXGBE_ZERO_SUP(lks);\n\tXGBE_SET_SUP(lks, Autoneg);\n\tXGBE_SET_SUP(lks, Pause);\n\tXGBE_SET_SUP(lks, Asym_Pause);\n\tXGBE_SET_SUP(lks, Backplane);\n\tXGBE_SET_SUP(lks, 10000baseKR_Full);\n\tswitch (phy_data->speed_set) {\n\tcase XGBE_SPEEDSET_1000_10000:\n\t\tXGBE_SET_SUP(lks, 1000baseKX_Full);\n\t\tbreak;\n\tcase XGBE_SPEEDSET_2500_10000:\n\t\tXGBE_SET_SUP(lks, 2500baseX_Full);\n\t\tbreak;\n\t}\n\n\tif (pdata->fec_ability & MDIO_PMA_10GBR_FECABLE_ABLE)\n\t\tXGBE_SET_SUP(lks, 10000baseR_FEC);\n\n\tpdata->phy_data = phy_data;\n\n\treturn 0;\n}\n\nvoid xgbe_init_function_ptrs_phy_v1(struct xgbe_phy_if *phy_if)\n{\n\tstruct xgbe_phy_impl_if *phy_impl = &phy_if->phy_impl;\n\n\tphy_impl->init\t\t\t= xgbe_phy_init;\n\tphy_impl->exit\t\t\t= xgbe_phy_exit;\n\n\tphy_impl->reset\t\t\t= xgbe_phy_reset;\n\tphy_impl->start\t\t\t= xgbe_phy_start;\n\tphy_impl->stop\t\t\t= xgbe_phy_stop;\n\n\tphy_impl->link_status\t\t= xgbe_phy_link_status;\n\n\tphy_impl->valid_speed\t\t= xgbe_phy_valid_speed;\n\n\tphy_impl->use_mode\t\t= xgbe_phy_use_mode;\n\tphy_impl->set_mode\t\t= xgbe_phy_set_mode;\n\tphy_impl->get_mode\t\t= xgbe_phy_get_mode;\n\tphy_impl->switch_mode\t\t= xgbe_phy_switch_mode;\n\tphy_impl->cur_mode\t\t= xgbe_phy_cur_mode;\n\n\tphy_impl->an_mode\t\t= xgbe_phy_an_mode;\n\n\tphy_impl->an_config\t\t= xgbe_phy_an_config;\n\n\tphy_impl->an_advertising\t= xgbe_phy_an_advertising;\n\n\tphy_impl->an_outcome\t\t= xgbe_phy_an_outcome;\n\n\tphy_impl->kr_training_pre\t= xgbe_phy_kr_training_pre;\n\tphy_impl->kr_training_post\t= xgbe_phy_kr_training_post;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}