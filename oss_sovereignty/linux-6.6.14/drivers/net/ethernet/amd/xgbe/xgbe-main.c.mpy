{
  "module_name": "xgbe-main.c",
  "hash_id": "dc62275054d0d3e32450d94a1106ac437e7630f311627159e9e0112512ee004d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-main.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/io.h>\n#include <linux/notifier.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\nMODULE_AUTHOR(\"Tom Lendacky <thomas.lendacky@amd.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(XGBE_DRV_DESC);\n\nstatic int debug = -1;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \" Network interface message level setting\");\n\nstatic const u32 default_msg_level = (NETIF_MSG_LINK | NETIF_MSG_IFDOWN |\n\t\t\t\t      NETIF_MSG_IFUP);\n\nstatic void xgbe_default_config(struct xgbe_prv_data *pdata)\n{\n\tDBGPR(\"-->xgbe_default_config\\n\");\n\n\tpdata->blen = DMA_SBMR_BLEN_64;\n\tpdata->pbl = DMA_PBL_128;\n\tpdata->aal = 1;\n\tpdata->rd_osr_limit = 8;\n\tpdata->wr_osr_limit = 8;\n\tpdata->tx_sf_mode = MTL_TSF_ENABLE;\n\tpdata->tx_threshold = MTL_TX_THRESHOLD_64;\n\tpdata->tx_osp_mode = DMA_OSP_ENABLE;\n\tpdata->rx_sf_mode = MTL_RSF_DISABLE;\n\tpdata->rx_threshold = MTL_RX_THRESHOLD_64;\n\tpdata->pause_autoneg = 1;\n\tpdata->tx_pause = 1;\n\tpdata->rx_pause = 1;\n\tpdata->phy_speed = SPEED_UNKNOWN;\n\tpdata->power_down = 0;\n\n\tDBGPR(\"<--xgbe_default_config\\n\");\n}\n\nstatic void xgbe_init_all_fptrs(struct xgbe_prv_data *pdata)\n{\n\txgbe_init_function_ptrs_dev(&pdata->hw_if);\n\txgbe_init_function_ptrs_phy(&pdata->phy_if);\n\txgbe_init_function_ptrs_i2c(&pdata->i2c_if);\n\txgbe_init_function_ptrs_desc(&pdata->desc_if);\n\n\tpdata->vdata->init_function_ptrs_phy_impl(&pdata->phy_if);\n}\n\nstruct xgbe_prv_data *xgbe_alloc_pdata(struct device *dev)\n{\n\tstruct xgbe_prv_data *pdata;\n\tstruct net_device *netdev;\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct xgbe_prv_data),\n\t\t\t\t   XGBE_MAX_DMA_CHANNELS);\n\tif (!netdev) {\n\t\tdev_err(dev, \"alloc_etherdev_mq failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tSET_NETDEV_DEV(netdev, dev);\n\tpdata = netdev_priv(netdev);\n\tpdata->netdev = netdev;\n\tpdata->dev = dev;\n\n\tspin_lock_init(&pdata->lock);\n\tspin_lock_init(&pdata->xpcs_lock);\n\tmutex_init(&pdata->rss_mutex);\n\tspin_lock_init(&pdata->tstamp_lock);\n\tmutex_init(&pdata->i2c_mutex);\n\tinit_completion(&pdata->i2c_complete);\n\tinit_completion(&pdata->mdio_complete);\n\n\tpdata->msg_enable = netif_msg_init(debug, default_msg_level);\n\n\tset_bit(XGBE_DOWN, &pdata->dev_state);\n\tset_bit(XGBE_STOPPED, &pdata->dev_state);\n\n\treturn pdata;\n}\n\nvoid xgbe_free_pdata(struct xgbe_prv_data *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\n\tfree_netdev(netdev);\n}\n\nvoid xgbe_set_counts(struct xgbe_prv_data *pdata)\n{\n\t \n\txgbe_init_all_fptrs(pdata);\n\n\t \n\txgbe_get_all_hw_features(pdata);\n\n\t \n\tif (!pdata->tx_max_channel_count)\n\t\tpdata->tx_max_channel_count = pdata->hw_feat.tx_ch_cnt;\n\tif (!pdata->rx_max_channel_count)\n\t\tpdata->rx_max_channel_count = pdata->hw_feat.rx_ch_cnt;\n\n\tif (!pdata->tx_max_q_count)\n\t\tpdata->tx_max_q_count = pdata->hw_feat.tx_q_cnt;\n\tif (!pdata->rx_max_q_count)\n\t\tpdata->rx_max_q_count = pdata->hw_feat.rx_q_cnt;\n\n\t \n\tpdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),\n\t\t\t\t     pdata->hw_feat.tx_ch_cnt);\n\tpdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,\n\t\t\t\t     pdata->tx_max_channel_count);\n\tpdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,\n\t\t\t\t     pdata->tx_max_q_count);\n\n\tpdata->tx_q_count = pdata->tx_ring_count;\n\n\tpdata->rx_ring_count = min_t(unsigned int, num_online_cpus(),\n\t\t\t\t     pdata->hw_feat.rx_ch_cnt);\n\tpdata->rx_ring_count = min_t(unsigned int, pdata->rx_ring_count,\n\t\t\t\t     pdata->rx_max_channel_count);\n\n\tpdata->rx_q_count = min_t(unsigned int, pdata->hw_feat.rx_q_cnt,\n\t\t\t\t  pdata->rx_max_q_count);\n\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(pdata->dev, \"TX/RX DMA channel count = %u/%u\\n\",\n\t\t\tpdata->tx_ring_count, pdata->rx_ring_count);\n\t\tdev_dbg(pdata->dev, \"TX/RX hardware queue count = %u/%u\\n\",\n\t\t\tpdata->tx_q_count, pdata->rx_q_count);\n\t}\n}\n\nint xgbe_config_netdev(struct xgbe_prv_data *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\tstruct device *dev = pdata->dev;\n\tint ret;\n\n\tnetdev->irq = pdata->dev_irq;\n\tnetdev->base_addr = (unsigned long)pdata->xgmac_regs;\n\teth_hw_addr_set(netdev, pdata->mac_addr);\n\n\t \n\tpdata->tx_sec_period = jiffies;\n\tpdata->tx_ded_period = jiffies;\n\tpdata->rx_sec_period = jiffies;\n\tpdata->rx_ded_period = jiffies;\n\tpdata->desc_sec_period = jiffies;\n\tpdata->desc_ded_period = jiffies;\n\n\t \n\tret = pdata->hw_if.exit(pdata);\n\tif (ret) {\n\t\tdev_err(dev, \"software reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\txgbe_default_config(pdata);\n\n\t \n\tret = dma_set_mask_and_coherent(dev,\n\t\t\t\t\tDMA_BIT_MASK(pdata->hw_feat.dma_width));\n\tif (ret) {\n\t\tdev_err(dev, \"dma_set_mask_and_coherent failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!pdata->tx_max_fifo_size)\n\t\tpdata->tx_max_fifo_size = pdata->hw_feat.tx_fifo_size;\n\tif (!pdata->rx_max_fifo_size)\n\t\tpdata->rx_max_fifo_size = pdata->hw_feat.rx_fifo_size;\n\n\t \n\tBUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);\n\tpdata->tx_desc_count = XGBE_TX_DESC_CNT;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(XGBE_RX_DESC_CNT);\n\tpdata->rx_desc_count = XGBE_RX_DESC_CNT;\n\n\t \n\tif (pdata->channel_irq_count) {\n\t\tpdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,\n\t\t\t\t\t     pdata->channel_irq_count);\n\t\tpdata->rx_ring_count = min_t(unsigned int, pdata->rx_ring_count,\n\t\t\t\t\t     pdata->channel_irq_count);\n\n\t\tif (netif_msg_probe(pdata))\n\t\t\tdev_dbg(pdata->dev,\n\t\t\t\t\"adjusted TX/RX DMA channel count = %u/%u\\n\",\n\t\t\t\tpdata->tx_ring_count, pdata->rx_ring_count);\n\t}\n\n\t \n\tnetdev_rss_key_fill(pdata->rss_key, sizeof(pdata->rss_key));\n\n\tXGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, IP2TE, 1);\n\tXGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, TCP4TE, 1);\n\tXGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, UDP4TE, 1);\n\n\t \n\tpdata->debugfs_an_cdr_workaround = pdata->vdata->an_cdr_workaround;\n\tret = pdata->phy_if.phy_init(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnetdev->netdev_ops = xgbe_get_netdev_ops();\n\tnetdev->ethtool_ops = xgbe_get_ethtool_ops();\n#ifdef CONFIG_AMD_XGBE_DCB\n\tnetdev->dcbnl_ops = xgbe_get_dcbnl_ops();\n#endif\n\n\t \n\tnetdev->hw_features = NETIF_F_SG |\n\t\t\t      NETIF_F_IP_CSUM |\n\t\t\t      NETIF_F_IPV6_CSUM |\n\t\t\t      NETIF_F_RXCSUM |\n\t\t\t      NETIF_F_TSO |\n\t\t\t      NETIF_F_TSO6 |\n\t\t\t      NETIF_F_GRO |\n\t\t\t      NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t      NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t      NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tif (pdata->hw_feat.rss)\n\t\tnetdev->hw_features |= NETIF_F_RXHASH;\n\n\tif (pdata->hw_feat.vxn) {\n\t\tnetdev->hw_enc_features = NETIF_F_SG |\n\t\t\t\t\t  NETIF_F_IP_CSUM |\n\t\t\t\t\t  NETIF_F_IPV6_CSUM |\n\t\t\t\t\t  NETIF_F_RXCSUM |\n\t\t\t\t\t  NETIF_F_TSO |\n\t\t\t\t\t  NETIF_F_TSO6 |\n\t\t\t\t\t  NETIF_F_GRO |\n\t\t\t\t\t  NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t  NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\n\t\tnetdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t       NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\n\t\tnetdev->udp_tunnel_nic_info = xgbe_get_udp_tunnel_info();\n\t}\n\n\tnetdev->vlan_features |= NETIF_F_SG |\n\t\t\t\t NETIF_F_IP_CSUM |\n\t\t\t\t NETIF_F_IPV6_CSUM |\n\t\t\t\t NETIF_F_TSO |\n\t\t\t\t NETIF_F_TSO6;\n\n\tnetdev->features |= netdev->hw_features;\n\tpdata->netdev_features = netdev->features;\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\tnetdev->min_mtu = 0;\n\tnetdev->max_mtu = XGMAC_JUMBO_PACKET_MTU;\n\n\t \n\tnetdev->watchdog_timeo = 0;\n\n\txgbe_init_rx_coalesce(pdata);\n\txgbe_init_tx_coalesce(pdata);\n\n\tnetif_carrier_off(netdev);\n\tret = register_netdev(netdev);\n\tif (ret) {\n\t\tdev_err(dev, \"net device registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (IS_REACHABLE(CONFIG_PTP_1588_CLOCK))\n\t\txgbe_ptp_register(pdata);\n\n\txgbe_debugfs_init(pdata);\n\n\tnetif_dbg(pdata, drv, pdata->netdev, \"%u Tx software queues\\n\",\n\t\t  pdata->tx_ring_count);\n\tnetif_dbg(pdata, drv, pdata->netdev, \"%u Rx software queues\\n\",\n\t\t  pdata->rx_ring_count);\n\n\treturn 0;\n}\n\nvoid xgbe_deconfig_netdev(struct xgbe_prv_data *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\n\txgbe_debugfs_exit(pdata);\n\n\tif (IS_REACHABLE(CONFIG_PTP_1588_CLOCK))\n\t\txgbe_ptp_unregister(pdata);\n\n\tunregister_netdev(netdev);\n\n\tpdata->phy_if.phy_exit(pdata);\n}\n\nstatic int xgbe_netdev_event(struct notifier_block *nb, unsigned long event,\n\t\t\t     void *data)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(data);\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tif (netdev->netdev_ops != xgbe_get_netdev_ops())\n\t\tgoto out;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\txgbe_debugfs_rename(pdata);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block xgbe_netdev_notifier = {\n\t.notifier_call = xgbe_netdev_event,\n};\n\nstatic int __init xgbe_mod_init(void)\n{\n\tint ret;\n\n\tret = register_netdevice_notifier(&xgbe_netdev_notifier);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xgbe_platform_init();\n\tif (ret)\n\t\tgoto err_platform_init;\n\n\tret = xgbe_pci_init();\n\tif (ret)\n\t\tgoto err_pci_init;\n\n\treturn 0;\n\nerr_pci_init:\n\txgbe_platform_exit();\nerr_platform_init:\n\tunregister_netdevice_notifier(&xgbe_netdev_notifier);\n\treturn ret;\n}\n\nstatic void __exit xgbe_mod_exit(void)\n{\n\txgbe_pci_exit();\n\n\txgbe_platform_exit();\n\n\tunregister_netdevice_notifier(&xgbe_netdev_notifier);\n}\n\nmodule_init(xgbe_mod_init);\nmodule_exit(xgbe_mod_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}