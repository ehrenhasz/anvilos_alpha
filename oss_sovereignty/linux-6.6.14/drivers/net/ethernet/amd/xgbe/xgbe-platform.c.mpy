{
  "module_name": "xgbe-platform.c",
  "hash_id": "26b18e8aaf05ce7b4007192e6a373f7c914f4f7e388850173b359db06ee2ef87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-platform.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/of_device.h>\n#include <linux/clk.h>\n#include <linux/property.h>\n#include <linux/acpi.h>\n#include <linux/mdio.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgbe_acpi_match[];\n\nstatic struct xgbe_version_data *xgbe_acpi_vdata(struct xgbe_prv_data *pdata)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(xgbe_acpi_match, pdata->dev);\n\n\treturn id ? (struct xgbe_version_data *)id->driver_data : NULL;\n}\n\nstatic int xgbe_acpi_support(struct xgbe_prv_data *pdata)\n{\n\tstruct device *dev = pdata->dev;\n\tu32 property;\n\tint ret;\n\n\t \n\tret = device_property_read_u32(dev, XGBE_ACPI_DMA_FREQ, &property);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to obtain %s property\\n\",\n\t\t\tXGBE_ACPI_DMA_FREQ);\n\t\treturn ret;\n\t}\n\tpdata->sysclk_rate = property;\n\n\t \n\tret = device_property_read_u32(dev, XGBE_ACPI_PTP_FREQ, &property);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to obtain %s property\\n\",\n\t\t\tXGBE_ACPI_PTP_FREQ);\n\t\treturn ret;\n\t}\n\tpdata->ptpclk_rate = property;\n\n\treturn 0;\n}\n#else    \nstatic struct xgbe_version_data *xgbe_acpi_vdata(struct xgbe_prv_data *pdata)\n{\n\treturn NULL;\n}\n\nstatic int xgbe_acpi_support(struct xgbe_prv_data *pdata)\n{\n\treturn -EINVAL;\n}\n#endif   \n\n#ifdef CONFIG_OF\nstatic const struct of_device_id xgbe_of_match[];\n\nstatic struct xgbe_version_data *xgbe_of_vdata(struct xgbe_prv_data *pdata)\n{\n\tconst struct of_device_id *id;\n\n\tid = of_match_device(xgbe_of_match, pdata->dev);\n\n\treturn id ? (struct xgbe_version_data *)id->data : NULL;\n}\n\nstatic int xgbe_of_support(struct xgbe_prv_data *pdata)\n{\n\tstruct device *dev = pdata->dev;\n\n\t \n\tpdata->sysclk = devm_clk_get(dev, XGBE_DMA_CLOCK);\n\tif (IS_ERR(pdata->sysclk)) {\n\t\tdev_err(dev, \"dma devm_clk_get failed\\n\");\n\t\treturn PTR_ERR(pdata->sysclk);\n\t}\n\tpdata->sysclk_rate = clk_get_rate(pdata->sysclk);\n\n\t \n\tpdata->ptpclk = devm_clk_get(dev, XGBE_PTP_CLOCK);\n\tif (IS_ERR(pdata->ptpclk)) {\n\t\tdev_err(dev, \"ptp devm_clk_get failed\\n\");\n\t\treturn PTR_ERR(pdata->ptpclk);\n\t}\n\tpdata->ptpclk_rate = clk_get_rate(pdata->ptpclk);\n\n\treturn 0;\n}\n\nstatic struct platform_device *xgbe_of_get_phy_pdev(struct xgbe_prv_data *pdata)\n{\n\tstruct device *dev = pdata->dev;\n\tstruct device_node *phy_node;\n\tstruct platform_device *phy_pdev;\n\n\tphy_node = of_parse_phandle(dev->of_node, \"phy-handle\", 0);\n\tif (phy_node) {\n\t\t \n\t\tphy_pdev = of_find_device_by_node(phy_node);\n\t\tof_node_put(phy_node);\n\t} else {\n\t\t \n\t\tget_device(dev);\n\t\tphy_pdev = pdata->platdev;\n\t}\n\n\treturn phy_pdev;\n}\n#else    \nstatic struct xgbe_version_data *xgbe_of_vdata(struct xgbe_prv_data *pdata)\n{\n\treturn NULL;\n}\n\nstatic int xgbe_of_support(struct xgbe_prv_data *pdata)\n{\n\treturn -EINVAL;\n}\n\nstatic struct platform_device *xgbe_of_get_phy_pdev(struct xgbe_prv_data *pdata)\n{\n\treturn NULL;\n}\n#endif   \n\nstatic unsigned int xgbe_resource_count(struct platform_device *pdev,\n\t\t\t\t\tunsigned int type)\n{\n\tunsigned int count;\n\tint i;\n\n\tfor (i = 0, count = 0; i < pdev->num_resources; i++) {\n\t\tstruct resource *res = &pdev->resource[i];\n\n\t\tif (type == resource_type(res))\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic struct platform_device *xgbe_get_phy_pdev(struct xgbe_prv_data *pdata)\n{\n\tstruct platform_device *phy_pdev;\n\n\tif (pdata->use_acpi) {\n\t\tget_device(pdata->dev);\n\t\tphy_pdev = pdata->platdev;\n\t} else {\n\t\tphy_pdev = xgbe_of_get_phy_pdev(pdata);\n\t}\n\n\treturn phy_pdev;\n}\n\nstatic struct xgbe_version_data *xgbe_get_vdata(struct xgbe_prv_data *pdata)\n{\n\treturn pdata->use_acpi ? xgbe_acpi_vdata(pdata)\n\t\t\t       : xgbe_of_vdata(pdata);\n}\n\nstatic int xgbe_platform_probe(struct platform_device *pdev)\n{\n\tstruct xgbe_prv_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct platform_device *phy_pdev;\n\tconst char *phy_mode;\n\tunsigned int phy_memnum, phy_irqnum;\n\tunsigned int dma_irqnum, dma_irqend;\n\tenum dev_dma_attr attr;\n\tint ret;\n\n\tpdata = xgbe_alloc_pdata(dev);\n\tif (IS_ERR(pdata)) {\n\t\tret = PTR_ERR(pdata);\n\t\tgoto err_alloc;\n\t}\n\n\tpdata->platdev = pdev;\n\tpdata->adev = ACPI_COMPANION(dev);\n\tplatform_set_drvdata(pdev, pdata);\n\n\t \n\tpdata->use_acpi = dev->of_node ? 0 : 1;\n\n\t \n\tpdata->vdata = xgbe_get_vdata(pdata);\n\n\tphy_pdev = xgbe_get_phy_pdev(pdata);\n\tif (!phy_pdev) {\n\t\tdev_err(dev, \"unable to obtain phy device\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_phydev;\n\t}\n\tpdata->phy_platdev = phy_pdev;\n\tpdata->phy_dev = &phy_pdev->dev;\n\n\tif (pdev == phy_pdev) {\n\t\t \n\t\tphy_memnum = xgbe_resource_count(pdev, IORESOURCE_MEM) - 3;\n\t\tphy_irqnum = platform_irq_count(pdev) - 1;\n\t\tdma_irqnum = 1;\n\t\tdma_irqend = phy_irqnum;\n\t} else {\n\t\t \n\t\tphy_memnum = 0;\n\t\tphy_irqnum = 0;\n\t\tdma_irqnum = 1;\n\t\tdma_irqend = platform_irq_count(pdev);\n\t}\n\n\t \n\tpdata->xgmac_regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pdata->xgmac_regs)) {\n\t\tdev_err(dev, \"xgmac ioremap failed\\n\");\n\t\tret = PTR_ERR(pdata->xgmac_regs);\n\t\tgoto err_io;\n\t}\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(dev, \"xgmac_regs = %p\\n\", pdata->xgmac_regs);\n\n\tpdata->xpcs_regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(pdata->xpcs_regs)) {\n\t\tdev_err(dev, \"xpcs ioremap failed\\n\");\n\t\tret = PTR_ERR(pdata->xpcs_regs);\n\t\tgoto err_io;\n\t}\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(dev, \"xpcs_regs  = %p\\n\", pdata->xpcs_regs);\n\n\tpdata->rxtx_regs = devm_platform_ioremap_resource(phy_pdev,\n\t\t\t\t\t\t\t  phy_memnum++);\n\tif (IS_ERR(pdata->rxtx_regs)) {\n\t\tdev_err(dev, \"rxtx ioremap failed\\n\");\n\t\tret = PTR_ERR(pdata->rxtx_regs);\n\t\tgoto err_io;\n\t}\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(dev, \"rxtx_regs  = %p\\n\", pdata->rxtx_regs);\n\n\tpdata->sir0_regs = devm_platform_ioremap_resource(phy_pdev,\n\t\t\t\t\t\t\t  phy_memnum++);\n\tif (IS_ERR(pdata->sir0_regs)) {\n\t\tdev_err(dev, \"sir0 ioremap failed\\n\");\n\t\tret = PTR_ERR(pdata->sir0_regs);\n\t\tgoto err_io;\n\t}\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(dev, \"sir0_regs  = %p\\n\", pdata->sir0_regs);\n\n\tpdata->sir1_regs = devm_platform_ioremap_resource(phy_pdev,\n\t\t\t\t\t\t\t  phy_memnum++);\n\tif (IS_ERR(pdata->sir1_regs)) {\n\t\tdev_err(dev, \"sir1 ioremap failed\\n\");\n\t\tret = PTR_ERR(pdata->sir1_regs);\n\t\tgoto err_io;\n\t}\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(dev, \"sir1_regs  = %p\\n\", pdata->sir1_regs);\n\n\t \n\tret = device_property_read_u8_array(dev, XGBE_MAC_ADDR_PROPERTY,\n\t\t\t\t\t    pdata->mac_addr,\n\t\t\t\t\t    sizeof(pdata->mac_addr));\n\tif (ret || !is_valid_ether_addr(pdata->mac_addr)) {\n\t\tdev_err(dev, \"invalid %s property\\n\", XGBE_MAC_ADDR_PROPERTY);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tgoto err_io;\n\t}\n\n\t \n\tret = device_property_read_string(dev, XGBE_PHY_MODE_PROPERTY,\n\t\t\t\t\t  &phy_mode);\n\tif (ret || strcmp(phy_mode, phy_modes(PHY_INTERFACE_MODE_XGMII))) {\n\t\tdev_err(dev, \"invalid %s property\\n\", XGBE_PHY_MODE_PROPERTY);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tgoto err_io;\n\t}\n\tpdata->phy_mode = PHY_INTERFACE_MODE_XGMII;\n\n\t \n\tif (device_property_present(dev, XGBE_DMA_IRQS_PROPERTY)) {\n\t\tpdata->per_channel_irq = 1;\n\t\tpdata->channel_irq_mode = XGBE_IRQ_MODE_EDGE;\n\t}\n\n\t \n\tif (pdata->use_acpi)\n\t\tret = xgbe_acpi_support(pdata);\n\telse\n\t\tret = xgbe_of_support(pdata);\n\tif (ret)\n\t\tgoto err_io;\n\n\t \n\tattr = device_get_dma_attr(dev);\n\tif (attr == DEV_DMA_NOT_SUPPORTED) {\n\t\tdev_err(dev, \"DMA is not supported\");\n\t\tret = -ENODEV;\n\t\tgoto err_io;\n\t}\n\tpdata->coherent = (attr == DEV_DMA_COHERENT);\n\tif (pdata->coherent) {\n\t\tpdata->arcr = XGBE_DMA_OS_ARCR;\n\t\tpdata->awcr = XGBE_DMA_OS_AWCR;\n\t} else {\n\t\tpdata->arcr = XGBE_DMA_SYS_ARCR;\n\t\tpdata->awcr = XGBE_DMA_SYS_AWCR;\n\t}\n\n\t \n\tpdata->tx_max_fifo_size = pdata->vdata->tx_max_fifo_size;\n\tpdata->rx_max_fifo_size = pdata->vdata->rx_max_fifo_size;\n\n\t \n\txgbe_set_counts(pdata);\n\n\t \n\tpdata->irq_count = 2;\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_io;\n\tpdata->dev_irq = ret;\n\n\t \n\tif (pdata->per_channel_irq) {\n\t\tunsigned int i, max = ARRAY_SIZE(pdata->channel_irq);\n\n\t\tfor (i = 0; (i < max) && (dma_irqnum < dma_irqend); i++) {\n\t\t\tret = platform_get_irq(pdata->platdev, dma_irqnum++);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_io;\n\n\t\t\tpdata->channel_irq[i] = ret;\n\t\t}\n\n\t\tpdata->channel_irq_count = max;\n\n\t\tpdata->irq_count += max;\n\t}\n\n\t \n\tret = platform_get_irq(phy_pdev, phy_irqnum++);\n\tif (ret < 0)\n\t\tgoto err_io;\n\tpdata->an_irq = ret;\n\n\t \n\tret = xgbe_config_netdev(pdata);\n\tif (ret)\n\t\tgoto err_io;\n\n\tnetdev_notice(pdata->netdev, \"net device enabled\\n\");\n\n\treturn 0;\n\nerr_io:\n\tplatform_device_put(phy_pdev);\n\nerr_phydev:\n\txgbe_free_pdata(pdata);\n\nerr_alloc:\n\tdev_notice(dev, \"net device not enabled\\n\");\n\n\treturn ret;\n}\n\nstatic int xgbe_platform_remove(struct platform_device *pdev)\n{\n\tstruct xgbe_prv_data *pdata = platform_get_drvdata(pdev);\n\n\txgbe_deconfig_netdev(pdata);\n\n\tplatform_device_put(pdata->phy_platdev);\n\n\txgbe_free_pdata(pdata);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int xgbe_platform_suspend(struct device *dev)\n{\n\tstruct xgbe_prv_data *pdata = dev_get_drvdata(dev);\n\tstruct net_device *netdev = pdata->netdev;\n\tint ret = 0;\n\n\tDBGPR(\"-->xgbe_suspend\\n\");\n\n\tif (netif_running(netdev))\n\t\tret = xgbe_powerdown(netdev, XGMAC_DRIVER_CONTEXT);\n\n\tpdata->lpm_ctrl = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\tpdata->lpm_ctrl |= MDIO_CTRL1_LPOWER;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\n\n\tDBGPR(\"<--xgbe_suspend\\n\");\n\n\treturn ret;\n}\n\nstatic int xgbe_platform_resume(struct device *dev)\n{\n\tstruct xgbe_prv_data *pdata = dev_get_drvdata(dev);\n\tstruct net_device *netdev = pdata->netdev;\n\tint ret = 0;\n\n\tDBGPR(\"-->xgbe_resume\\n\");\n\n\tpdata->lpm_ctrl &= ~MDIO_CTRL1_LPOWER;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\n\n\tif (netif_running(netdev)) {\n\t\tret = xgbe_powerup(netdev, XGMAC_DRIVER_CONTEXT);\n\n\t\t \n\t\tschedule_work(&pdata->restart_work);\n\t}\n\n\tDBGPR(\"<--xgbe_resume\\n\");\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct xgbe_version_data xgbe_v1 = {\n\t.init_function_ptrs_phy_impl\t= xgbe_init_function_ptrs_phy_v1,\n\t.xpcs_access\t\t\t= XGBE_XPCS_ACCESS_V1,\n\t.tx_max_fifo_size\t\t= 81920,\n\t.rx_max_fifo_size\t\t= 81920,\n\t.tx_tstamp_workaround\t\t= 1,\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgbe_acpi_match[] = {\n\t{ .id = \"AMDI8001\",\n\t  .driver_data = (kernel_ulong_t)&xgbe_v1 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(acpi, xgbe_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id xgbe_of_match[] = {\n\t{ .compatible = \"amd,xgbe-seattle-v1a\",\n\t  .data = &xgbe_v1 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, xgbe_of_match);\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(xgbe_platform_pm_ops,\n\t\t\t xgbe_platform_suspend, xgbe_platform_resume);\n\nstatic struct platform_driver xgbe_driver = {\n\t.driver = {\n\t\t.name = XGBE_DRV_NAME,\n#ifdef CONFIG_ACPI\n\t\t.acpi_match_table = xgbe_acpi_match,\n#endif\n#ifdef CONFIG_OF\n\t\t.of_match_table = xgbe_of_match,\n#endif\n\t\t.pm = &xgbe_platform_pm_ops,\n\t},\n\t.probe = xgbe_platform_probe,\n\t.remove = xgbe_platform_remove,\n};\n\nint xgbe_platform_init(void)\n{\n\treturn platform_driver_register(&xgbe_driver);\n}\n\nvoid xgbe_platform_exit(void)\n{\n\tplatform_driver_unregister(&xgbe_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}