{
  "module_name": "xgbe-dev.c",
  "hash_id": "ce5bbe9d78468eaaf5688566b29db39645bf13a5c5bee9b6d5c663c77a5113b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-dev.c",
  "human_readable_source": " \n\n#include <linux/phy.h>\n#include <linux/mdio.h>\n#include <linux/clk.h>\n#include <linux/bitrev.h>\n#include <linux/crc32.h>\n#include <linux/crc32poly.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\nstatic inline unsigned int xgbe_get_max_frame(struct xgbe_prv_data *pdata)\n{\n\treturn pdata->netdev->mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\n}\n\nstatic unsigned int xgbe_usec_to_riwt(struct xgbe_prv_data *pdata,\n\t\t\t\t      unsigned int usec)\n{\n\tunsigned long rate;\n\tunsigned int ret;\n\n\tDBGPR(\"-->xgbe_usec_to_riwt\\n\");\n\n\trate = pdata->sysclk_rate;\n\n\t \n\tret = (usec * (rate / 1000000)) / 256;\n\n\tDBGPR(\"<--xgbe_usec_to_riwt\\n\");\n\n\treturn ret;\n}\n\nstatic unsigned int xgbe_riwt_to_usec(struct xgbe_prv_data *pdata,\n\t\t\t\t      unsigned int riwt)\n{\n\tunsigned long rate;\n\tunsigned int ret;\n\n\tDBGPR(\"-->xgbe_riwt_to_usec\\n\");\n\n\trate = pdata->sysclk_rate;\n\n\t \n\tret = (riwt * 256) / (rate / 1000000);\n\n\tDBGPR(\"<--xgbe_riwt_to_usec\\n\");\n\n\treturn ret;\n}\n\nstatic int xgbe_config_pbl_val(struct xgbe_prv_data *pdata)\n{\n\tunsigned int pblx8, pbl;\n\tunsigned int i;\n\n\tpblx8 = DMA_PBL_X8_DISABLE;\n\tpbl = pdata->pbl;\n\n\tif (pdata->pbl > 32) {\n\t\tpblx8 = DMA_PBL_X8_ENABLE;\n\t\tpbl >>= 3;\n\t}\n\n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_CR, PBLX8,\n\t\t\t\t       pblx8);\n\n\t\tif (pdata->channel[i]->tx_ring)\n\t\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_TCR,\n\t\t\t\t\t       PBL, pbl);\n\n\t\tif (pdata->channel[i]->rx_ring)\n\t\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_RCR,\n\t\t\t\t\t       PBL, pbl);\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_config_osp_mode(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->tx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_TCR, OSP,\n\t\t\t\t       pdata->tx_osp_mode);\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_config_rsf_mode(struct xgbe_prv_data *pdata, unsigned int val)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->rx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RSF, val);\n\n\treturn 0;\n}\n\nstatic int xgbe_config_tsf_mode(struct xgbe_prv_data *pdata, unsigned int val)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TSF, val);\n\n\treturn 0;\n}\n\nstatic int xgbe_config_rx_threshold(struct xgbe_prv_data *pdata,\n\t\t\t\t    unsigned int val)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->rx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RTC, val);\n\n\treturn 0;\n}\n\nstatic int xgbe_config_tx_threshold(struct xgbe_prv_data *pdata,\n\t\t\t\t    unsigned int val)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TTC, val);\n\n\treturn 0;\n}\n\nstatic int xgbe_config_rx_coalesce(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->rx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_RIWT, RWT,\n\t\t\t\t       pdata->rx_riwt);\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_config_tx_coalesce(struct xgbe_prv_data *pdata)\n{\n\treturn 0;\n}\n\nstatic void xgbe_config_rx_buffer_size(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->rx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_RCR, RBSZ,\n\t\t\t\t       pdata->rx_buf_size);\n\t}\n}\n\nstatic void xgbe_config_tso_mode(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->tx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_TCR, TSE, 1);\n\t}\n}\n\nstatic void xgbe_config_sph_mode(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->rx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_CR, SPH, 1);\n\t}\n\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, HDSMS, XGBE_SPH_HDSMS_SIZE);\n}\n\nstatic int xgbe_write_rss_reg(struct xgbe_prv_data *pdata, unsigned int type,\n\t\t\t      unsigned int index, unsigned int val)\n{\n\tunsigned int wait;\n\tint ret = 0;\n\n\tmutex_lock(&pdata->rss_mutex);\n\n\tif (XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tXGMAC_IOWRITE(pdata, MAC_RSSDR, val);\n\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, RSSIA, index);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, ADDRT, type);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, CT, 0);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, OB, 1);\n\n\twait = 1000;\n\twhile (wait--) {\n\t\tif (!XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB))\n\t\t\tgoto unlock;\n\n\t\tusleep_range(1000, 1500);\n\t}\n\n\tret = -EBUSY;\n\nunlock:\n\tmutex_unlock(&pdata->rss_mutex);\n\n\treturn ret;\n}\n\nstatic int xgbe_write_rss_hash_key(struct xgbe_prv_data *pdata)\n{\n\tunsigned int key_regs = sizeof(pdata->rss_key) / sizeof(u32);\n\tunsigned int *key = (unsigned int *)&pdata->rss_key;\n\tint ret;\n\n\twhile (key_regs--) {\n\t\tret = xgbe_write_rss_reg(pdata, XGBE_RSS_HASH_KEY_TYPE,\n\t\t\t\t\t key_regs, *key++);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_write_rss_lookup_table(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++) {\n\t\tret = xgbe_write_rss_reg(pdata,\n\t\t\t\t\t XGBE_RSS_LOOKUP_TABLE_TYPE, i,\n\t\t\t\t\t pdata->rss_table[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_set_rss_hash_key(struct xgbe_prv_data *pdata, const u8 *key)\n{\n\tmemcpy(pdata->rss_key, key, sizeof(pdata->rss_key));\n\n\treturn xgbe_write_rss_hash_key(pdata);\n}\n\nstatic int xgbe_set_rss_lookup_table(struct xgbe_prv_data *pdata,\n\t\t\t\t     const u32 *table)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)\n\t\tXGMAC_SET_BITS(pdata->rss_table[i], MAC_RSSDR, DMCH, table[i]);\n\n\treturn xgbe_write_rss_lookup_table(pdata);\n}\n\nstatic int xgbe_enable_rss(struct xgbe_prv_data *pdata)\n{\n\tint ret;\n\n\tif (!pdata->hw_feat.rss)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tret = xgbe_write_rss_hash_key(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = xgbe_write_rss_lookup_table(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tXGMAC_IOWRITE(pdata, MAC_RSSCR, pdata->rss_options);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 1);\n\n\treturn 0;\n}\n\nstatic int xgbe_disable_rss(struct xgbe_prv_data *pdata)\n{\n\tif (!pdata->hw_feat.rss)\n\t\treturn -EOPNOTSUPP;\n\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 0);\n\n\treturn 0;\n}\n\nstatic void xgbe_config_rss(struct xgbe_prv_data *pdata)\n{\n\tint ret;\n\n\tif (!pdata->hw_feat.rss)\n\t\treturn;\n\n\tif (pdata->netdev->features & NETIF_F_RXHASH)\n\t\tret = xgbe_enable_rss(pdata);\n\telse\n\t\tret = xgbe_disable_rss(pdata);\n\n\tif (ret)\n\t\tnetdev_err(pdata->netdev,\n\t\t\t   \"error configuring RSS, RSS disabled\\n\");\n}\n\nstatic bool xgbe_is_pfc_queue(struct xgbe_prv_data *pdata,\n\t\t\t      unsigned int queue)\n{\n\tunsigned int prio, tc;\n\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++) {\n\t\t \n\t\tif (pdata->prio2q_map[prio] != queue)\n\t\t\tcontinue;\n\n\t\t \n\t\ttc = pdata->ets->prio_tc[prio];\n\n\t\t \n\t\tif (pdata->pfc->pfc_en & (1 << tc))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void xgbe_set_vxlan_id(struct xgbe_prv_data *pdata)\n{\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TIR, TNID, pdata->vxlan_port);\n\n\tnetif_dbg(pdata, drv, pdata->netdev, \"VXLAN tunnel id set to %hx\\n\",\n\t\t  pdata->vxlan_port);\n}\n\nstatic void xgbe_enable_vxlan(struct xgbe_prv_data *pdata)\n{\n\tif (!pdata->hw_feat.vxn)\n\t\treturn;\n\n\t \n\txgbe_set_vxlan_id(pdata);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, VUCC, 1);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, VNM, 0);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, VNE, 1);\n\n\tnetif_dbg(pdata, drv, pdata->netdev, \"VXLAN acceleration enabled\\n\");\n}\n\nstatic void xgbe_disable_vxlan(struct xgbe_prv_data *pdata)\n{\n\tif (!pdata->hw_feat.vxn)\n\t\treturn;\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, VNE, 0);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, VUCC, 0);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TIR, TNID, 0);\n\n\tnetif_dbg(pdata, drv, pdata->netdev, \"VXLAN acceleration disabled\\n\");\n}\n\nstatic unsigned int xgbe_get_fc_queue_count(struct xgbe_prv_data *pdata)\n{\n\tunsigned int max_q_count = XGMAC_MAX_FLOW_CONTROL_QUEUES;\n\n\t \n\tif (XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER) >= 0x30)\n\t\treturn max_q_count;\n\telse\n\t\treturn min_t(unsigned int, pdata->tx_q_count, max_q_count);\n}\n\nstatic int xgbe_disable_tx_flow_control(struct xgbe_prv_data *pdata)\n{\n\tunsigned int reg, reg_val;\n\tunsigned int i, q_count;\n\n\t \n\tfor (i = 0; i < pdata->rx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, EHFC, 0);\n\n\t \n\tq_count = xgbe_get_fc_queue_count(pdata);\n\treg = MAC_Q0TFCR;\n\tfor (i = 0; i < q_count; i++) {\n\t\treg_val = XGMAC_IOREAD(pdata, reg);\n\t\tXGMAC_SET_BITS(reg_val, MAC_Q0TFCR, TFE, 0);\n\t\tXGMAC_IOWRITE(pdata, reg, reg_val);\n\n\t\treg += MAC_QTFCR_INC;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_enable_tx_flow_control(struct xgbe_prv_data *pdata)\n{\n\tstruct ieee_pfc *pfc = pdata->pfc;\n\tstruct ieee_ets *ets = pdata->ets;\n\tunsigned int reg, reg_val;\n\tunsigned int i, q_count;\n\n\t \n\tfor (i = 0; i < pdata->rx_q_count; i++) {\n\t\tunsigned int ehfc = 0;\n\n\t\tif (pdata->rx_rfd[i]) {\n\t\t\t \n\t\t\tif (pfc && ets) {\n\t\t\t\tif (xgbe_is_pfc_queue(pdata, i))\n\t\t\t\t\tehfc = 1;\n\t\t\t} else {\n\t\t\t\tehfc = 1;\n\t\t\t}\n\t\t}\n\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, EHFC, ehfc);\n\n\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t  \"flow control %s for RXq%u\\n\",\n\t\t\t  ehfc ? \"enabled\" : \"disabled\", i);\n\t}\n\n\t \n\tq_count = xgbe_get_fc_queue_count(pdata);\n\treg = MAC_Q0TFCR;\n\tfor (i = 0; i < q_count; i++) {\n\t\treg_val = XGMAC_IOREAD(pdata, reg);\n\n\t\t \n\t\tXGMAC_SET_BITS(reg_val, MAC_Q0TFCR, TFE, 1);\n\t\t \n\t\tXGMAC_SET_BITS(reg_val, MAC_Q0TFCR, PT, 0xffff);\n\n\t\tXGMAC_IOWRITE(pdata, reg, reg_val);\n\n\t\treg += MAC_QTFCR_INC;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_disable_rx_flow_control(struct xgbe_prv_data *pdata)\n{\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RFCR, RFE, 0);\n\n\treturn 0;\n}\n\nstatic int xgbe_enable_rx_flow_control(struct xgbe_prv_data *pdata)\n{\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RFCR, RFE, 1);\n\n\treturn 0;\n}\n\nstatic int xgbe_config_tx_flow_control(struct xgbe_prv_data *pdata)\n{\n\tstruct ieee_pfc *pfc = pdata->pfc;\n\n\tif (pdata->tx_pause || (pfc && pfc->pfc_en))\n\t\txgbe_enable_tx_flow_control(pdata);\n\telse\n\t\txgbe_disable_tx_flow_control(pdata);\n\n\treturn 0;\n}\n\nstatic int xgbe_config_rx_flow_control(struct xgbe_prv_data *pdata)\n{\n\tstruct ieee_pfc *pfc = pdata->pfc;\n\n\tif (pdata->rx_pause || (pfc && pfc->pfc_en))\n\t\txgbe_enable_rx_flow_control(pdata);\n\telse\n\t\txgbe_disable_rx_flow_control(pdata);\n\n\treturn 0;\n}\n\nstatic void xgbe_config_flow_control(struct xgbe_prv_data *pdata)\n{\n\tstruct ieee_pfc *pfc = pdata->pfc;\n\n\txgbe_config_tx_flow_control(pdata);\n\txgbe_config_rx_flow_control(pdata);\n\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RFCR, PFCE,\n\t\t\t   (pfc && pfc->pfc_en) ? 1 : 0);\n}\n\nstatic void xgbe_enable_dma_interrupts(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_channel *channel;\n\tunsigned int i, ver;\n\n\t \n\tif (pdata->channel_irq_mode)\n\t\tXGMAC_IOWRITE_BITS(pdata, DMA_MR, INTM,\n\t\t\t\t   pdata->channel_irq_mode);\n\n\tver = XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER);\n\n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tchannel = pdata->channel[i];\n\n\t\t \n\t\tXGMAC_DMA_IOWRITE(channel, DMA_CH_SR,\n\t\t\t\t  XGMAC_DMA_IOREAD(channel, DMA_CH_SR));\n\n\t\t \n\t\tchannel->curr_ier = 0;\n\n\t\t \n\t\tif (ver < 0x21) {\n\t\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, NIE20, 1);\n\t\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, AIE20, 1);\n\t\t} else {\n\t\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, NIE, 1);\n\t\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, AIE, 1);\n\t\t}\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, FBEE, 1);\n\n\t\tif (channel->tx_ring) {\n\t\t\t \n\t\t\tif (!pdata->per_channel_irq || pdata->channel_irq_mode)\n\t\t\t\tXGMAC_SET_BITS(channel->curr_ier,\n\t\t\t\t\t       DMA_CH_IER, TIE, 1);\n\t\t}\n\t\tif (channel->rx_ring) {\n\t\t\t \n\t\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RBUE, 1);\n\t\t\tif (!pdata->per_channel_irq || pdata->channel_irq_mode)\n\t\t\t\tXGMAC_SET_BITS(channel->curr_ier,\n\t\t\t\t\t       DMA_CH_IER, RIE, 1);\n\t\t}\n\n\t\tXGMAC_DMA_IOWRITE(channel, DMA_CH_IER, channel->curr_ier);\n\t}\n}\n\nstatic void xgbe_enable_mtl_interrupts(struct xgbe_prv_data *pdata)\n{\n\tunsigned int mtl_q_isr;\n\tunsigned int q_count, i;\n\n\tq_count = max(pdata->hw_feat.tx_q_cnt, pdata->hw_feat.rx_q_cnt);\n\tfor (i = 0; i < q_count; i++) {\n\t\t \n\t\tmtl_q_isr = XGMAC_MTL_IOREAD(pdata, i, MTL_Q_ISR);\n\t\tXGMAC_MTL_IOWRITE(pdata, i, MTL_Q_ISR, mtl_q_isr);\n\n\t\t \n\t\tXGMAC_MTL_IOWRITE(pdata, i, MTL_Q_IER, 0);\n\t}\n}\n\nstatic void xgbe_enable_mac_interrupts(struct xgbe_prv_data *pdata)\n{\n\tunsigned int mac_ier = 0;\n\n\t \n\tXGMAC_SET_BITS(mac_ier, MAC_IER, TSIE, 1);\n\n\tXGMAC_IOWRITE(pdata, MAC_IER, mac_ier);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MMC_RIER, ALL_INTERRUPTS, 0xffffffff);\n\tXGMAC_IOWRITE_BITS(pdata, MMC_TIER, ALL_INTERRUPTS, 0xffffffff);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_MDIOIER, SNGLCOMPIE, 1);\n}\n\nstatic void xgbe_enable_ecc_interrupts(struct xgbe_prv_data *pdata)\n{\n\tunsigned int ecc_isr, ecc_ier = 0;\n\n\tif (!pdata->vdata->ecc_support)\n\t\treturn;\n\n\t \n\tecc_isr = XP_IOREAD(pdata, XP_ECC_ISR);\n\tXP_IOWRITE(pdata, XP_ECC_ISR, ecc_isr);\n\n\t \n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_DED, 1);\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_SEC, 1);\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_DED, 1);\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_SEC, 1);\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_DED, 1);\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_SEC, 1);\n\n\tXP_IOWRITE(pdata, XP_ECC_IER, ecc_ier);\n}\n\nstatic void xgbe_disable_ecc_ded(struct xgbe_prv_data *pdata)\n{\n\tunsigned int ecc_ier;\n\n\tecc_ier = XP_IOREAD(pdata, XP_ECC_IER);\n\n\t \n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_DED, 0);\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_DED, 0);\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_DED, 0);\n\n\tXP_IOWRITE(pdata, XP_ECC_IER, ecc_ier);\n}\n\nstatic void xgbe_disable_ecc_sec(struct xgbe_prv_data *pdata,\n\t\t\t\t enum xgbe_ecc_sec sec)\n{\n\tunsigned int ecc_ier;\n\n\tecc_ier = XP_IOREAD(pdata, XP_ECC_IER);\n\n\t \n\tswitch (sec) {\n\tcase XGBE_ECC_SEC_TX:\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_SEC, 0);\n\t\tbreak;\n\tcase XGBE_ECC_SEC_RX:\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_SEC, 0);\n\t\tbreak;\n\tcase XGBE_ECC_SEC_DESC:\n\tXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_SEC, 0);\n\t\tbreak;\n\t}\n\n\tXP_IOWRITE(pdata, XP_ECC_IER, ecc_ier);\n}\n\nstatic int xgbe_set_speed(struct xgbe_prv_data *pdata, int speed)\n{\n\tunsigned int ss;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tss = 0x07;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tss = 0x03;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tss = 0x02;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\tss = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (XGMAC_IOREAD_BITS(pdata, MAC_TCR, SS) != ss)\n\t\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, SS, ss);\n\n\treturn 0;\n}\n\nstatic int xgbe_enable_rx_vlan_stripping(struct xgbe_prv_data *pdata)\n{\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLRXS, 1);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, DOVLTC, 1);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ERSVLM, 0);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ESVL, 0);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLS, 0x3);\n\n\treturn 0;\n}\n\nstatic int xgbe_disable_rx_vlan_stripping(struct xgbe_prv_data *pdata)\n{\n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLS, 0);\n\n\treturn 0;\n}\n\nstatic int xgbe_enable_rx_vlan_filtering(struct xgbe_prv_data *pdata)\n{\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, VTFE, 1);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VTHM, 1);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VTIM, 0);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ETV, 1);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VL, 1);\n\n\treturn 0;\n}\n\nstatic int xgbe_disable_rx_vlan_filtering(struct xgbe_prv_data *pdata)\n{\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, VTFE, 0);\n\n\treturn 0;\n}\n\nstatic u32 xgbe_vid_crc32_le(__le16 vid_le)\n{\n\tu32 crc = ~0;\n\tu32 temp = 0;\n\tunsigned char *data = (unsigned char *)&vid_le;\n\tunsigned char data_byte = 0;\n\tint i, bits;\n\n\tbits = get_bitmask_order(VLAN_VID_MASK);\n\tfor (i = 0; i < bits; i++) {\n\t\tif ((i % 8) == 0)\n\t\t\tdata_byte = data[i / 8];\n\n\t\ttemp = ((crc & 1) ^ data_byte) & 1;\n\t\tcrc >>= 1;\n\t\tdata_byte >>= 1;\n\n\t\tif (temp)\n\t\t\tcrc ^= CRC32_POLY_LE;\n\t}\n\n\treturn crc;\n}\n\nstatic int xgbe_update_vlan_hash_table(struct xgbe_prv_data *pdata)\n{\n\tu32 crc;\n\tu16 vid;\n\t__le16 vid_le;\n\tu16 vlan_hash_table = 0;\n\n\t \n\tfor_each_set_bit(vid, pdata->active_vlans, VLAN_N_VID) {\n\t\t \n\t\tvid_le = cpu_to_le16(vid);\n\t\tcrc = bitrev32(~xgbe_vid_crc32_le(vid_le)) >> 28;\n\n\t\tvlan_hash_table |= (1 << crc);\n\t}\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANHTR, VLHT, vlan_hash_table);\n\n\treturn 0;\n}\n\nstatic int xgbe_set_promiscuous_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t     unsigned int enable)\n{\n\tunsigned int val = enable ? 1 : 0;\n\n\tif (XGMAC_IOREAD_BITS(pdata, MAC_PFR, PR) == val)\n\t\treturn 0;\n\n\tnetif_dbg(pdata, drv, pdata->netdev, \"%s promiscuous mode\\n\",\n\t\t  enable ? \"entering\" : \"leaving\");\n\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, PR, val);\n\n\t \n\tif (enable) {\n\t\txgbe_disable_rx_vlan_filtering(pdata);\n\t} else {\n\t\tif (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\t\txgbe_enable_rx_vlan_filtering(pdata);\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_set_all_multicast_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t       unsigned int enable)\n{\n\tunsigned int val = enable ? 1 : 0;\n\n\tif (XGMAC_IOREAD_BITS(pdata, MAC_PFR, PM) == val)\n\t\treturn 0;\n\n\tnetif_dbg(pdata, drv, pdata->netdev, \"%s allmulti mode\\n\",\n\t\t  enable ? \"entering\" : \"leaving\");\n\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, PM, val);\n\n\treturn 0;\n}\n\nstatic void xgbe_set_mac_reg(struct xgbe_prv_data *pdata,\n\t\t\t     struct netdev_hw_addr *ha, unsigned int *mac_reg)\n{\n\tunsigned int mac_addr_hi, mac_addr_lo;\n\tu8 *mac_addr;\n\n\tmac_addr_lo = 0;\n\tmac_addr_hi = 0;\n\n\tif (ha) {\n\t\tmac_addr = (u8 *)&mac_addr_lo;\n\t\tmac_addr[0] = ha->addr[0];\n\t\tmac_addr[1] = ha->addr[1];\n\t\tmac_addr[2] = ha->addr[2];\n\t\tmac_addr[3] = ha->addr[3];\n\t\tmac_addr = (u8 *)&mac_addr_hi;\n\t\tmac_addr[0] = ha->addr[4];\n\t\tmac_addr[1] = ha->addr[5];\n\n\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t  \"adding mac address %pM at %#x\\n\",\n\t\t\t  ha->addr, *mac_reg);\n\n\t\tXGMAC_SET_BITS(mac_addr_hi, MAC_MACA1HR, AE, 1);\n\t}\n\n\tXGMAC_IOWRITE(pdata, *mac_reg, mac_addr_hi);\n\t*mac_reg += MAC_MACA_INC;\n\tXGMAC_IOWRITE(pdata, *mac_reg, mac_addr_lo);\n\t*mac_reg += MAC_MACA_INC;\n}\n\nstatic void xgbe_set_mac_addn_addrs(struct xgbe_prv_data *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\tstruct netdev_hw_addr *ha;\n\tunsigned int mac_reg;\n\tunsigned int addn_macs;\n\n\tmac_reg = MAC_MACA1HR;\n\taddn_macs = pdata->hw_feat.addn_mac;\n\n\tif (netdev_uc_count(netdev) > addn_macs) {\n\t\txgbe_set_promiscuous_mode(pdata, 1);\n\t} else {\n\t\tnetdev_for_each_uc_addr(ha, netdev) {\n\t\t\txgbe_set_mac_reg(pdata, ha, &mac_reg);\n\t\t\taddn_macs--;\n\t\t}\n\n\t\tif (netdev_mc_count(netdev) > addn_macs) {\n\t\t\txgbe_set_all_multicast_mode(pdata, 1);\n\t\t} else {\n\t\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\t\txgbe_set_mac_reg(pdata, ha, &mac_reg);\n\t\t\t\taddn_macs--;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twhile (addn_macs--)\n\t\txgbe_set_mac_reg(pdata, NULL, &mac_reg);\n}\n\nstatic void xgbe_set_mac_hash_table(struct xgbe_prv_data *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\tstruct netdev_hw_addr *ha;\n\tunsigned int hash_reg;\n\tunsigned int hash_table_shift, hash_table_count;\n\tu32 hash_table[XGBE_MAC_HASH_TABLE_SIZE];\n\tu32 crc;\n\tunsigned int i;\n\n\thash_table_shift = 26 - (pdata->hw_feat.hash_table_size >> 7);\n\thash_table_count = pdata->hw_feat.hash_table_size / 32;\n\tmemset(hash_table, 0, sizeof(hash_table));\n\n\t \n\tnetdev_for_each_uc_addr(ha, netdev) {\n\t\tcrc = bitrev32(~crc32_le(~0, ha->addr, ETH_ALEN));\n\t\tcrc >>= hash_table_shift;\n\t\thash_table[crc >> 5] |= (1 << (crc & 0x1f));\n\t}\n\n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\tcrc = bitrev32(~crc32_le(~0, ha->addr, ETH_ALEN));\n\t\tcrc >>= hash_table_shift;\n\t\thash_table[crc >> 5] |= (1 << (crc & 0x1f));\n\t}\n\n\t \n\thash_reg = MAC_HTR0;\n\tfor (i = 0; i < hash_table_count; i++) {\n\t\tXGMAC_IOWRITE(pdata, hash_reg, hash_table[i]);\n\t\thash_reg += MAC_HTR_INC;\n\t}\n}\n\nstatic int xgbe_add_mac_addresses(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->hw_feat.hash_table_size)\n\t\txgbe_set_mac_hash_table(pdata);\n\telse\n\t\txgbe_set_mac_addn_addrs(pdata);\n\n\treturn 0;\n}\n\nstatic int xgbe_set_mac_address(struct xgbe_prv_data *pdata, const u8 *addr)\n{\n\tunsigned int mac_addr_hi, mac_addr_lo;\n\n\tmac_addr_hi = (addr[5] <<  8) | (addr[4] <<  0);\n\tmac_addr_lo = (addr[3] << 24) | (addr[2] << 16) |\n\t\t      (addr[1] <<  8) | (addr[0] <<  0);\n\n\tXGMAC_IOWRITE(pdata, MAC_MACA0HR, mac_addr_hi);\n\tXGMAC_IOWRITE(pdata, MAC_MACA0LR, mac_addr_lo);\n\n\treturn 0;\n}\n\nstatic int xgbe_config_rx_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\tunsigned int pr_mode, am_mode;\n\n\tpr_mode = ((netdev->flags & IFF_PROMISC) != 0);\n\tam_mode = ((netdev->flags & IFF_ALLMULTI) != 0);\n\n\txgbe_set_promiscuous_mode(pdata, pr_mode);\n\txgbe_set_all_multicast_mode(pdata, am_mode);\n\n\txgbe_add_mac_addresses(pdata);\n\n\treturn 0;\n}\n\nstatic int xgbe_clr_gpio(struct xgbe_prv_data *pdata, unsigned int gpio)\n{\n\tunsigned int reg;\n\n\tif (gpio > 15)\n\t\treturn -EINVAL;\n\n\treg = XGMAC_IOREAD(pdata, MAC_GPIOSR);\n\n\treg &= ~(1 << (gpio + 16));\n\tXGMAC_IOWRITE(pdata, MAC_GPIOSR, reg);\n\n\treturn 0;\n}\n\nstatic int xgbe_set_gpio(struct xgbe_prv_data *pdata, unsigned int gpio)\n{\n\tunsigned int reg;\n\n\tif (gpio > 15)\n\t\treturn -EINVAL;\n\n\treg = XGMAC_IOREAD(pdata, MAC_GPIOSR);\n\n\treg |= (1 << (gpio + 16));\n\tXGMAC_IOWRITE(pdata, MAC_GPIOSR, reg);\n\n\treturn 0;\n}\n\nstatic int xgbe_read_mmd_regs_v2(struct xgbe_prv_data *pdata, int prtad,\n\t\t\t\t int mmd_reg)\n{\n\tunsigned long flags;\n\tunsigned int mmd_address, index, offset;\n\tint mmd_data;\n\n\tif (mmd_reg & XGBE_ADDR_C45)\n\t\tmmd_address = mmd_reg & ~XGBE_ADDR_C45;\n\telse\n\t\tmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\n\n\t \n\tmmd_address <<= 1;\n\tindex = mmd_address & ~pdata->xpcs_window_mask;\n\toffset = pdata->xpcs_window + (mmd_address & pdata->xpcs_window_mask);\n\n\tspin_lock_irqsave(&pdata->xpcs_lock, flags);\n\tXPCS32_IOWRITE(pdata, pdata->xpcs_window_sel_reg, index);\n\tmmd_data = XPCS16_IOREAD(pdata, offset);\n\tspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\n\n\treturn mmd_data;\n}\n\nstatic void xgbe_write_mmd_regs_v2(struct xgbe_prv_data *pdata, int prtad,\n\t\t\t\t   int mmd_reg, int mmd_data)\n{\n\tunsigned long flags;\n\tunsigned int mmd_address, index, offset;\n\n\tif (mmd_reg & XGBE_ADDR_C45)\n\t\tmmd_address = mmd_reg & ~XGBE_ADDR_C45;\n\telse\n\t\tmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\n\n\t \n\tmmd_address <<= 1;\n\tindex = mmd_address & ~pdata->xpcs_window_mask;\n\toffset = pdata->xpcs_window + (mmd_address & pdata->xpcs_window_mask);\n\n\tspin_lock_irqsave(&pdata->xpcs_lock, flags);\n\tXPCS32_IOWRITE(pdata, pdata->xpcs_window_sel_reg, index);\n\tXPCS16_IOWRITE(pdata, offset, mmd_data);\n\tspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\n}\n\nstatic int xgbe_read_mmd_regs_v1(struct xgbe_prv_data *pdata, int prtad,\n\t\t\t\t int mmd_reg)\n{\n\tunsigned long flags;\n\tunsigned int mmd_address;\n\tint mmd_data;\n\n\tif (mmd_reg & XGBE_ADDR_C45)\n\t\tmmd_address = mmd_reg & ~XGBE_ADDR_C45;\n\telse\n\t\tmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\n\n\t \n\tspin_lock_irqsave(&pdata->xpcs_lock, flags);\n\tXPCS32_IOWRITE(pdata, PCS_V1_WINDOW_SELECT, mmd_address >> 8);\n\tmmd_data = XPCS32_IOREAD(pdata, (mmd_address & 0xff) << 2);\n\tspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\n\n\treturn mmd_data;\n}\n\nstatic void xgbe_write_mmd_regs_v1(struct xgbe_prv_data *pdata, int prtad,\n\t\t\t\t   int mmd_reg, int mmd_data)\n{\n\tunsigned int mmd_address;\n\tunsigned long flags;\n\n\tif (mmd_reg & XGBE_ADDR_C45)\n\t\tmmd_address = mmd_reg & ~XGBE_ADDR_C45;\n\telse\n\t\tmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\n\n\t \n\tspin_lock_irqsave(&pdata->xpcs_lock, flags);\n\tXPCS32_IOWRITE(pdata, PCS_V1_WINDOW_SELECT, mmd_address >> 8);\n\tXPCS32_IOWRITE(pdata, (mmd_address & 0xff) << 2, mmd_data);\n\tspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\n}\n\nstatic int xgbe_read_mmd_regs(struct xgbe_prv_data *pdata, int prtad,\n\t\t\t      int mmd_reg)\n{\n\tswitch (pdata->vdata->xpcs_access) {\n\tcase XGBE_XPCS_ACCESS_V1:\n\t\treturn xgbe_read_mmd_regs_v1(pdata, prtad, mmd_reg);\n\n\tcase XGBE_XPCS_ACCESS_V2:\n\tdefault:\n\t\treturn xgbe_read_mmd_regs_v2(pdata, prtad, mmd_reg);\n\t}\n}\n\nstatic void xgbe_write_mmd_regs(struct xgbe_prv_data *pdata, int prtad,\n\t\t\t\tint mmd_reg, int mmd_data)\n{\n\tswitch (pdata->vdata->xpcs_access) {\n\tcase XGBE_XPCS_ACCESS_V1:\n\t\treturn xgbe_write_mmd_regs_v1(pdata, prtad, mmd_reg, mmd_data);\n\n\tcase XGBE_XPCS_ACCESS_V2:\n\tdefault:\n\t\treturn xgbe_write_mmd_regs_v2(pdata, prtad, mmd_reg, mmd_data);\n\t}\n}\n\nstatic unsigned int xgbe_create_mdio_sca_c22(int port, int reg)\n{\n\tunsigned int mdio_sca;\n\n\tmdio_sca = 0;\n\tXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, RA, reg);\n\tXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, PA, port);\n\n\treturn mdio_sca;\n}\n\nstatic unsigned int xgbe_create_mdio_sca_c45(int port, unsigned int da, int reg)\n{\n\tunsigned int mdio_sca;\n\n\tmdio_sca = 0;\n\tXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, RA, reg);\n\tXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, PA, port);\n\tXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, DA, da);\n\n\treturn mdio_sca;\n}\n\nstatic int xgbe_write_ext_mii_regs(struct xgbe_prv_data *pdata,\n\t\t\t\t   unsigned int mdio_sca, u16 val)\n{\n\tunsigned int mdio_sccd;\n\n\treinit_completion(&pdata->mdio_complete);\n\n\tXGMAC_IOWRITE(pdata, MAC_MDIOSCAR, mdio_sca);\n\n\tmdio_sccd = 0;\n\tXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, DATA, val);\n\tXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, CMD, 1);\n\tXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, BUSY, 1);\n\tXGMAC_IOWRITE(pdata, MAC_MDIOSCCDR, mdio_sccd);\n\n\tif (!wait_for_completion_timeout(&pdata->mdio_complete, HZ)) {\n\t\tnetdev_err(pdata->netdev, \"mdio write operation timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_write_ext_mii_regs_c22(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t       int reg, u16 val)\n{\n\tunsigned int mdio_sca;\n\n\tmdio_sca = xgbe_create_mdio_sca_c22(addr, reg);\n\n\treturn xgbe_write_ext_mii_regs(pdata, mdio_sca, val);\n}\n\nstatic int xgbe_write_ext_mii_regs_c45(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t       int devad, int reg, u16 val)\n{\n\tunsigned int mdio_sca;\n\n\tmdio_sca = xgbe_create_mdio_sca_c45(addr, devad, reg);\n\n\treturn xgbe_write_ext_mii_regs(pdata, mdio_sca, val);\n}\n\nstatic int xgbe_read_ext_mii_regs(struct xgbe_prv_data *pdata,\n\t\t\t\t  unsigned int mdio_sca)\n{\n\tunsigned int mdio_sccd;\n\n\treinit_completion(&pdata->mdio_complete);\n\n\tXGMAC_IOWRITE(pdata, MAC_MDIOSCAR, mdio_sca);\n\n\tmdio_sccd = 0;\n\tXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, CMD, 3);\n\tXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, BUSY, 1);\n\tXGMAC_IOWRITE(pdata, MAC_MDIOSCCDR, mdio_sccd);\n\n\tif (!wait_for_completion_timeout(&pdata->mdio_complete, HZ)) {\n\t\tnetdev_err(pdata->netdev, \"mdio read operation timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn XGMAC_IOREAD_BITS(pdata, MAC_MDIOSCCDR, DATA);\n}\n\nstatic int xgbe_read_ext_mii_regs_c22(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t      int reg)\n{\n\tunsigned int mdio_sca;\n\n\tmdio_sca = xgbe_create_mdio_sca_c22(addr, reg);\n\n\treturn xgbe_read_ext_mii_regs(pdata, mdio_sca);\n}\n\nstatic int xgbe_read_ext_mii_regs_c45(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t      int devad, int reg)\n{\n\tunsigned int mdio_sca;\n\n\tmdio_sca = xgbe_create_mdio_sca_c45(addr, devad, reg);\n\n\treturn xgbe_read_ext_mii_regs(pdata, mdio_sca);\n}\n\nstatic int xgbe_set_ext_mii_mode(struct xgbe_prv_data *pdata, unsigned int port,\n\t\t\t\t enum xgbe_mdio_mode mode)\n{\n\tunsigned int reg_val = XGMAC_IOREAD(pdata, MAC_MDIOCL22R);\n\n\tswitch (mode) {\n\tcase XGBE_MDIO_MODE_CL22:\n\t\tif (port > XGMAC_MAX_C22_PORT)\n\t\t\treturn -EINVAL;\n\t\treg_val |= (1 << port);\n\t\tbreak;\n\tcase XGBE_MDIO_MODE_CL45:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tXGMAC_IOWRITE(pdata, MAC_MDIOCL22R, reg_val);\n\n\treturn 0;\n}\n\nstatic int xgbe_tx_complete(struct xgbe_ring_desc *rdesc)\n{\n\treturn !XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN);\n}\n\nstatic int xgbe_disable_rx_csum(struct xgbe_prv_data *pdata)\n{\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, IPC, 0);\n\n\treturn 0;\n}\n\nstatic int xgbe_enable_rx_csum(struct xgbe_prv_data *pdata)\n{\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, IPC, 1);\n\n\treturn 0;\n}\n\nstatic void xgbe_tx_desc_reset(struct xgbe_ring_data *rdata)\n{\n\tstruct xgbe_ring_desc *rdesc = rdata->rdesc;\n\n\t \n\trdesc->desc0 = 0;\n\trdesc->desc1 = 0;\n\trdesc->desc2 = 0;\n\trdesc->desc3 = 0;\n\n\t \n\tdma_wmb();\n}\n\nstatic void xgbe_tx_desc_init(struct xgbe_channel *channel)\n{\n\tstruct xgbe_ring *ring = channel->tx_ring;\n\tstruct xgbe_ring_data *rdata;\n\tint i;\n\tint start_index = ring->cur;\n\n\tDBGPR(\"-->tx_desc_init\\n\");\n\n\t \n\tfor (i = 0; i < ring->rdesc_count; i++) {\n\t\trdata = XGBE_GET_DESC_DATA(ring, i);\n\n\t\t \n\t\txgbe_tx_desc_reset(rdata);\n\t}\n\n\t \n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_TDRLR, ring->rdesc_count - 1);\n\n\t \n\trdata = XGBE_GET_DESC_DATA(ring, start_index);\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_TDLR_HI,\n\t\t\t  upper_32_bits(rdata->rdesc_dma));\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_TDLR_LO,\n\t\t\t  lower_32_bits(rdata->rdesc_dma));\n\n\tDBGPR(\"<--tx_desc_init\\n\");\n}\n\nstatic void xgbe_rx_desc_reset(struct xgbe_prv_data *pdata,\n\t\t\t       struct xgbe_ring_data *rdata, unsigned int index)\n{\n\tstruct xgbe_ring_desc *rdesc = rdata->rdesc;\n\tunsigned int rx_usecs = pdata->rx_usecs;\n\tunsigned int rx_frames = pdata->rx_frames;\n\tunsigned int inte;\n\tdma_addr_t hdr_dma, buf_dma;\n\n\tif (!rx_usecs && !rx_frames) {\n\t\t \n\t\tinte = 1;\n\t} else {\n\t\t \n\t\tif (rx_frames && !((index + 1) % rx_frames))\n\t\t\tinte = 1;\n\t\telse\n\t\t\tinte = 0;\n\t}\n\n\t \n\thdr_dma = rdata->rx.hdr.dma_base + rdata->rx.hdr.dma_off;\n\tbuf_dma = rdata->rx.buf.dma_base + rdata->rx.buf.dma_off;\n\trdesc->desc0 = cpu_to_le32(lower_32_bits(hdr_dma));\n\trdesc->desc1 = cpu_to_le32(upper_32_bits(hdr_dma));\n\trdesc->desc2 = cpu_to_le32(lower_32_bits(buf_dma));\n\trdesc->desc3 = cpu_to_le32(upper_32_bits(buf_dma));\n\n\tXGMAC_SET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, INTE, inte);\n\n\t \n\tdma_wmb();\n\n\tXGMAC_SET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, OWN, 1);\n\n\t \n\tdma_wmb();\n}\n\nstatic void xgbe_rx_desc_init(struct xgbe_channel *channel)\n{\n\tstruct xgbe_prv_data *pdata = channel->pdata;\n\tstruct xgbe_ring *ring = channel->rx_ring;\n\tstruct xgbe_ring_data *rdata;\n\tunsigned int start_index = ring->cur;\n\tunsigned int i;\n\n\tDBGPR(\"-->rx_desc_init\\n\");\n\n\t \n\tfor (i = 0; i < ring->rdesc_count; i++) {\n\t\trdata = XGBE_GET_DESC_DATA(ring, i);\n\n\t\t \n\t\txgbe_rx_desc_reset(pdata, rdata, i);\n\t}\n\n\t \n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_RDRLR, ring->rdesc_count - 1);\n\n\t \n\trdata = XGBE_GET_DESC_DATA(ring, start_index);\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_RDLR_HI,\n\t\t\t  upper_32_bits(rdata->rdesc_dma));\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_RDLR_LO,\n\t\t\t  lower_32_bits(rdata->rdesc_dma));\n\n\t \n\trdata = XGBE_GET_DESC_DATA(ring, start_index + ring->rdesc_count - 1);\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_RDTR_LO,\n\t\t\t  lower_32_bits(rdata->rdesc_dma));\n\n\tDBGPR(\"<--rx_desc_init\\n\");\n}\n\nstatic void xgbe_update_tstamp_addend(struct xgbe_prv_data *pdata,\n\t\t\t\t      unsigned int addend)\n{\n\tunsigned int count = 10000;\n\n\t \n\tXGMAC_IOWRITE(pdata, MAC_TSAR, addend);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_TSCR, TSADDREG, 1);\n\n\t \n\twhile (--count && XGMAC_IOREAD_BITS(pdata, MAC_TSCR, TSADDREG))\n\t\tudelay(5);\n\n\tif (!count)\n\t\tnetdev_err(pdata->netdev,\n\t\t\t   \"timed out updating timestamp addend register\\n\");\n}\n\nstatic void xgbe_set_tstamp_time(struct xgbe_prv_data *pdata, unsigned int sec,\n\t\t\t\t unsigned int nsec)\n{\n\tunsigned int count = 10000;\n\n\t \n\tXGMAC_IOWRITE(pdata, MAC_STSUR, sec);\n\tXGMAC_IOWRITE(pdata, MAC_STNUR, nsec);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_TSCR, TSINIT, 1);\n\n\t \n\twhile (--count && XGMAC_IOREAD_BITS(pdata, MAC_TSCR, TSINIT))\n\t\tudelay(5);\n\n\tif (!count)\n\t\tnetdev_err(pdata->netdev, \"timed out initializing timestamp\\n\");\n}\n\nstatic u64 xgbe_get_tstamp_time(struct xgbe_prv_data *pdata)\n{\n\tu64 nsec;\n\n\tnsec = XGMAC_IOREAD(pdata, MAC_STSR);\n\tnsec *= NSEC_PER_SEC;\n\tnsec += XGMAC_IOREAD(pdata, MAC_STNR);\n\n\treturn nsec;\n}\n\nstatic u64 xgbe_get_tx_tstamp(struct xgbe_prv_data *pdata)\n{\n\tunsigned int tx_snr, tx_ssr;\n\tu64 nsec;\n\n\tif (pdata->vdata->tx_tstamp_workaround) {\n\t\ttx_snr = XGMAC_IOREAD(pdata, MAC_TXSNR);\n\t\ttx_ssr = XGMAC_IOREAD(pdata, MAC_TXSSR);\n\t} else {\n\t\ttx_ssr = XGMAC_IOREAD(pdata, MAC_TXSSR);\n\t\ttx_snr = XGMAC_IOREAD(pdata, MAC_TXSNR);\n\t}\n\n\tif (XGMAC_GET_BITS(tx_snr, MAC_TXSNR, TXTSSTSMIS))\n\t\treturn 0;\n\n\tnsec = tx_ssr;\n\tnsec *= NSEC_PER_SEC;\n\tnsec += tx_snr;\n\n\treturn nsec;\n}\n\nstatic void xgbe_get_rx_tstamp(struct xgbe_packet_data *packet,\n\t\t\t       struct xgbe_ring_desc *rdesc)\n{\n\tu64 nsec;\n\n\tif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_CONTEXT_DESC3, TSA) &&\n\t    !XGMAC_GET_BITS_LE(rdesc->desc3, RX_CONTEXT_DESC3, TSD)) {\n\t\tnsec = le32_to_cpu(rdesc->desc1);\n\t\tnsec <<= 32;\n\t\tnsec |= le32_to_cpu(rdesc->desc0);\n\t\tif (nsec != 0xffffffffffffffffULL) {\n\t\t\tpacket->rx_tstamp = nsec;\n\t\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t\t       RX_TSTAMP, 1);\n\t\t}\n\t}\n}\n\nstatic int xgbe_config_tstamp(struct xgbe_prv_data *pdata,\n\t\t\t      unsigned int mac_tscr)\n{\n\t \n\tXGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSCTRLSSR, 1);\n\n\t \n\tXGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSCFUPDT, 1);\n\n\t \n\tXGMAC_SET_BITS(mac_tscr, MAC_TSCR, TXTSSTSM, 1);\n\n\tXGMAC_IOWRITE(pdata, MAC_TSCR, mac_tscr);\n\n\t \n\tif (!XGMAC_GET_BITS(mac_tscr, MAC_TSCR, TSENA))\n\t\treturn 0;\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_SSIR, SSINC, XGBE_TSTAMP_SSINC);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_SSIR, SNSINC, XGBE_TSTAMP_SNSINC);\n\txgbe_update_tstamp_addend(pdata, pdata->tstamp_addend);\n\txgbe_set_tstamp_time(pdata, 0, 0);\n\n\t \n\ttimecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\n\treturn 0;\n}\n\nstatic void xgbe_tx_start_xmit(struct xgbe_channel *channel,\n\t\t\t       struct xgbe_ring *ring)\n{\n\tstruct xgbe_prv_data *pdata = channel->pdata;\n\tstruct xgbe_ring_data *rdata;\n\n\t \n\twmb();\n\n\t \n\trdata = XGBE_GET_DESC_DATA(ring, ring->cur);\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_TDTR_LO,\n\t\t\t  lower_32_bits(rdata->rdesc_dma));\n\n\t \n\tif (pdata->tx_usecs && !channel->tx_timer_active) {\n\t\tchannel->tx_timer_active = 1;\n\t\tmod_timer(&channel->tx_timer,\n\t\t\t  jiffies + usecs_to_jiffies(pdata->tx_usecs));\n\t}\n\n\tring->tx.xmit_more = 0;\n}\n\nstatic void xgbe_dev_xmit(struct xgbe_channel *channel)\n{\n\tstruct xgbe_prv_data *pdata = channel->pdata;\n\tstruct xgbe_ring *ring = channel->tx_ring;\n\tstruct xgbe_ring_data *rdata;\n\tstruct xgbe_ring_desc *rdesc;\n\tstruct xgbe_packet_data *packet = &ring->packet_data;\n\tunsigned int tx_packets, tx_bytes;\n\tunsigned int csum, tso, vlan, vxlan;\n\tunsigned int tso_context, vlan_context;\n\tunsigned int tx_set_ic;\n\tint start_index = ring->cur;\n\tint cur_index = ring->cur;\n\tint i;\n\n\tDBGPR(\"-->xgbe_dev_xmit\\n\");\n\n\ttx_packets = packet->tx_packets;\n\ttx_bytes = packet->tx_bytes;\n\n\tcsum = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,\n\t\t\t      CSUM_ENABLE);\n\ttso = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,\n\t\t\t     TSO_ENABLE);\n\tvlan = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,\n\t\t\t      VLAN_CTAG);\n\tvxlan = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,\n\t\t\t       VXLAN);\n\n\tif (tso && (packet->mss != ring->tx.cur_mss))\n\t\ttso_context = 1;\n\telse\n\t\ttso_context = 0;\n\n\tif (vlan && (packet->vlan_ctag != ring->tx.cur_vlan_ctag))\n\t\tvlan_context = 1;\n\telse\n\t\tvlan_context = 0;\n\n\t \n\tring->coalesce_count += tx_packets;\n\tif (!pdata->tx_frames)\n\t\ttx_set_ic = 0;\n\telse if (tx_packets > pdata->tx_frames)\n\t\ttx_set_ic = 1;\n\telse if ((ring->coalesce_count % pdata->tx_frames) < tx_packets)\n\t\ttx_set_ic = 1;\n\telse\n\t\ttx_set_ic = 0;\n\n\trdata = XGBE_GET_DESC_DATA(ring, cur_index);\n\trdesc = rdata->rdesc;\n\n\t \n\tif (tso_context || vlan_context) {\n\t\tif (tso_context) {\n\t\t\tnetif_dbg(pdata, tx_queued, pdata->netdev,\n\t\t\t\t  \"TSO context descriptor, mss=%u\\n\",\n\t\t\t\t  packet->mss);\n\n\t\t\t \n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc2, TX_CONTEXT_DESC2,\n\t\t\t\t\t  MSS, packet->mss);\n\n\t\t\t \n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\n\t\t\t\t\t  CTXT, 1);\n\n\t\t\t \n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\n\t\t\t\t\t  TCMSSV, 1);\n\n\t\t\tring->tx.cur_mss = packet->mss;\n\t\t}\n\n\t\tif (vlan_context) {\n\t\t\tnetif_dbg(pdata, tx_queued, pdata->netdev,\n\t\t\t\t  \"VLAN context descriptor, ctag=%u\\n\",\n\t\t\t\t  packet->vlan_ctag);\n\n\t\t\t \n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\n\t\t\t\t\t  CTXT, 1);\n\n\t\t\t \n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\n\t\t\t\t\t  VT, packet->vlan_ctag);\n\n\t\t\t \n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\n\t\t\t\t\t  VLTV, 1);\n\n\t\t\tring->tx.cur_vlan_ctag = packet->vlan_ctag;\n\t\t}\n\n\t\tcur_index++;\n\t\trdata = XGBE_GET_DESC_DATA(ring, cur_index);\n\t\trdesc = rdata->rdesc;\n\t}\n\n\t \n\trdesc->desc0 =  cpu_to_le32(lower_32_bits(rdata->skb_dma));\n\trdesc->desc1 =  cpu_to_le32(upper_32_bits(rdata->skb_dma));\n\n\t \n\tXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, HL_B1L,\n\t\t\t  rdata->skb_dma_len);\n\n\t \n\tif (vlan)\n\t\tXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, VTIR,\n\t\t\t\t  TX_NORMAL_DESC2_VLAN_INSERT);\n\n\t \n\tif (XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES, PTP))\n\t\tXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, TTSE, 1);\n\n\t \n\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, FD, 1);\n\n\t \n\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT, 0);\n\n\t \n\tif (cur_index != start_index)\n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);\n\n\tif (tso) {\n\t\t \n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TSE, 1);\n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TCPPL,\n\t\t\t\t  packet->tcp_payload_len);\n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TCPHDRLEN,\n\t\t\t\t  packet->tcp_header_len / 4);\n\n\t\tpdata->ext_stats.tx_tso_packets += tx_packets;\n\t} else {\n\t\t \n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CPC, 0);\n\n\t\t \n\t\tif (csum)\n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3,\n\t\t\t\t\t  CIC, 0x3);\n\n\t\t \n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, FL,\n\t\t\t\t  packet->length);\n\t}\n\n\tif (vxlan) {\n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, VNP,\n\t\t\t\t  TX_NORMAL_DESC3_VXLAN_PACKET);\n\n\t\tpdata->ext_stats.tx_vxlan_packets += packet->tx_packets;\n\t}\n\n\tfor (i = cur_index - start_index + 1; i < packet->rdesc_count; i++) {\n\t\tcur_index++;\n\t\trdata = XGBE_GET_DESC_DATA(ring, cur_index);\n\t\trdesc = rdata->rdesc;\n\n\t\t \n\t\trdesc->desc0 = cpu_to_le32(lower_32_bits(rdata->skb_dma));\n\t\trdesc->desc1 = cpu_to_le32(upper_32_bits(rdata->skb_dma));\n\n\t\t \n\t\tXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, HL_B1L,\n\t\t\t\t  rdata->skb_dma_len);\n\n\t\t \n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);\n\n\t\t \n\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT, 0);\n\n\t\t \n\t\tif (csum)\n\t\t\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3,\n\t\t\t\t\t  CIC, 0x3);\n\t}\n\n\t \n\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, LD, 1);\n\n\t \n\tif (tx_set_ic)\n\t\tXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, IC, 1);\n\n\t \n\trdata->tx.packets = tx_packets;\n\trdata->tx.bytes = tx_bytes;\n\n\tpdata->ext_stats.txq_packets[channel->queue_index] += tx_packets;\n\tpdata->ext_stats.txq_bytes[channel->queue_index] += tx_bytes;\n\n\t \n\tdma_wmb();\n\n\t \n\trdata = XGBE_GET_DESC_DATA(ring, start_index);\n\trdesc = rdata->rdesc;\n\tXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);\n\n\tif (netif_msg_tx_queued(pdata))\n\t\txgbe_dump_tx_desc(pdata, ring, start_index,\n\t\t\t\t  packet->rdesc_count, 1);\n\n\t \n\tsmp_wmb();\n\n\tring->cur = cur_index + 1;\n\tif (!netdev_xmit_more() ||\n\t    netif_xmit_stopped(netdev_get_tx_queue(pdata->netdev,\n\t\t\t\t\t\t   channel->queue_index)))\n\t\txgbe_tx_start_xmit(channel, ring);\n\telse\n\t\tring->tx.xmit_more = 1;\n\n\tDBGPR(\"  %s: descriptors %u to %u written\\n\",\n\t      channel->name, start_index & (ring->rdesc_count - 1),\n\t      (ring->cur - 1) & (ring->rdesc_count - 1));\n\n\tDBGPR(\"<--xgbe_dev_xmit\\n\");\n}\n\nstatic int xgbe_dev_read(struct xgbe_channel *channel)\n{\n\tstruct xgbe_prv_data *pdata = channel->pdata;\n\tstruct xgbe_ring *ring = channel->rx_ring;\n\tstruct xgbe_ring_data *rdata;\n\tstruct xgbe_ring_desc *rdesc;\n\tstruct xgbe_packet_data *packet = &ring->packet_data;\n\tstruct net_device *netdev = pdata->netdev;\n\tunsigned int err, etlt, l34t;\n\n\tDBGPR(\"-->xgbe_dev_read: cur = %d\\n\", ring->cur);\n\n\trdata = XGBE_GET_DESC_DATA(ring, ring->cur);\n\trdesc = rdata->rdesc;\n\n\t \n\tif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, OWN))\n\t\treturn 1;\n\n\t \n\tdma_rmb();\n\n\tif (netif_msg_rx_status(pdata))\n\t\txgbe_dump_rx_desc(pdata, ring, ring->cur);\n\n\tif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CTXT)) {\n\t\t \n\t\txgbe_get_rx_tstamp(packet, rdesc);\n\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       CONTEXT, 1);\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       CONTEXT_NEXT, 0);\n\t\treturn 0;\n\t}\n\n\t \n\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES, CONTEXT, 0);\n\n\t \n\tif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CDA))\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       CONTEXT_NEXT, 1);\n\n\t \n\tif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, FD)) {\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       FIRST, 1);\n\t\trdata->rx.hdr_len = XGMAC_GET_BITS_LE(rdesc->desc2,\n\t\t\t\t\t\t      RX_NORMAL_DESC2, HL);\n\t\tif (rdata->rx.hdr_len)\n\t\t\tpdata->ext_stats.rx_split_header_packets++;\n\t} else {\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       FIRST, 0);\n\t}\n\n\t \n\tif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, RSV)) {\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       RSS_HASH, 1);\n\n\t\tpacket->rss_hash = le32_to_cpu(rdesc->desc1);\n\n\t\tl34t = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, L34T);\n\t\tswitch (l34t) {\n\t\tcase RX_DESC3_L34T_IPV4_TCP:\n\t\tcase RX_DESC3_L34T_IPV4_UDP:\n\t\tcase RX_DESC3_L34T_IPV6_TCP:\n\t\tcase RX_DESC3_L34T_IPV6_UDP:\n\t\t\tpacket->rss_hash_type = PKT_HASH_TYPE_L4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpacket->rss_hash_type = PKT_HASH_TYPE_L3;\n\t\t}\n\t}\n\n\t \n\tif (!XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, LD))\n\t\treturn 0;\n\n\t \n\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t       LAST, 1);\n\n\t \n\trdata->rx.len = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, PL);\n\n\t \n\tif (netdev->features & NETIF_F_RXCSUM) {\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       CSUM_DONE, 1);\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       TNPCSUM_DONE, 1);\n\t}\n\n\t \n\tif (XGMAC_GET_BITS_LE(rdesc->desc2, RX_NORMAL_DESC2, TNP)) {\n\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t       TNP, 1);\n\t\tpdata->ext_stats.rx_vxlan_packets++;\n\n\t\tl34t = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, L34T);\n\t\tswitch (l34t) {\n\t\tcase RX_DESC3_L34T_IPV4_UNKNOWN:\n\t\tcase RX_DESC3_L34T_IPV6_UNKNOWN:\n\t\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t\t       TNPCSUM_DONE, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\terr = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, ES);\n\tetlt = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, ETLT);\n\tnetif_dbg(pdata, rx_status, netdev, \"err=%u, etlt=%#x\\n\", err, etlt);\n\n\tif (!err || !etlt) {\n\t\t \n\t\tif ((etlt == 0x09) &&\n\t\t    (netdev->features & NETIF_F_HW_VLAN_CTAG_RX)) {\n\t\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t\t       VLAN_CTAG, 1);\n\t\t\tpacket->vlan_ctag = XGMAC_GET_BITS_LE(rdesc->desc0,\n\t\t\t\t\t\t\t      RX_NORMAL_DESC0,\n\t\t\t\t\t\t\t      OVT);\n\t\t\tnetif_dbg(pdata, rx_status, netdev, \"vlan-ctag=%#06x\\n\",\n\t\t\t\t  packet->vlan_ctag);\n\t\t}\n\t} else {\n\t\tunsigned int tnp = XGMAC_GET_BITS(packet->attributes,\n\t\t\t\t\t\t  RX_PACKET_ATTRIBUTES, TNP);\n\n\t\tif ((etlt == 0x05) || (etlt == 0x06)) {\n\t\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t\t       CSUM_DONE, 0);\n\t\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t\t       TNPCSUM_DONE, 0);\n\t\t\tpdata->ext_stats.rx_csum_errors++;\n\t\t} else if (tnp && ((etlt == 0x09) || (etlt == 0x0a))) {\n\t\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t\t       CSUM_DONE, 0);\n\t\t\tXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\n\t\t\t\t       TNPCSUM_DONE, 0);\n\t\t\tpdata->ext_stats.rx_vxlan_csum_errors++;\n\t\t} else {\n\t\t\tXGMAC_SET_BITS(packet->errors, RX_PACKET_ERRORS,\n\t\t\t\t       FRAME, 1);\n\t\t}\n\t}\n\n\tpdata->ext_stats.rxq_packets[channel->queue_index]++;\n\tpdata->ext_stats.rxq_bytes[channel->queue_index] += rdata->rx.len;\n\n\tDBGPR(\"<--xgbe_dev_read: %s - descriptor=%u (cur=%d)\\n\", channel->name,\n\t      ring->cur & (ring->rdesc_count - 1), ring->cur);\n\n\treturn 0;\n}\n\nstatic int xgbe_is_context_desc(struct xgbe_ring_desc *rdesc)\n{\n\t \n\treturn XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT);\n}\n\nstatic int xgbe_is_last_desc(struct xgbe_ring_desc *rdesc)\n{\n\t \n\treturn XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, LD);\n}\n\nstatic int xgbe_enable_int(struct xgbe_channel *channel,\n\t\t\t   enum xgbe_int int_id)\n{\n\tswitch (int_id) {\n\tcase XGMAC_INT_DMA_CH_SR_TI:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TIE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_TPS:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TXSE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_TBU:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TBUE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_RI:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RIE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_RBU:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RBUE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_RPS:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RSE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_TI_RI:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TIE, 1);\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RIE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_FBE:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, FBEE, 1);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_ALL:\n\t\tchannel->curr_ier |= channel->saved_ier;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_IER, channel->curr_ier);\n\n\treturn 0;\n}\n\nstatic int xgbe_disable_int(struct xgbe_channel *channel,\n\t\t\t    enum xgbe_int int_id)\n{\n\tswitch (int_id) {\n\tcase XGMAC_INT_DMA_CH_SR_TI:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TIE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_TPS:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TXSE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_TBU:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TBUE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_RI:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RIE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_RBU:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RBUE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_RPS:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RSE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_TI_RI:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, TIE, 0);\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RIE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_CH_SR_FBE:\n\t\tXGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, FBEE, 0);\n\t\tbreak;\n\tcase XGMAC_INT_DMA_ALL:\n\t\tchannel->saved_ier = channel->curr_ier;\n\t\tchannel->curr_ier = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tXGMAC_DMA_IOWRITE(channel, DMA_CH_IER, channel->curr_ier);\n\n\treturn 0;\n}\n\nstatic int __xgbe_exit(struct xgbe_prv_data *pdata)\n{\n\tunsigned int count = 2000;\n\n\tDBGPR(\"-->xgbe_exit\\n\");\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, DMA_MR, SWR, 1);\n\tusleep_range(10, 15);\n\n\t \n\twhile (--count && XGMAC_IOREAD_BITS(pdata, DMA_MR, SWR))\n\t\tusleep_range(500, 600);\n\n\tif (!count)\n\t\treturn -EBUSY;\n\n\tDBGPR(\"<--xgbe_exit\\n\");\n\n\treturn 0;\n}\n\nstatic int xgbe_exit(struct xgbe_prv_data *pdata)\n{\n\tint ret;\n\n\t \n\tret = __xgbe_exit(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __xgbe_exit(pdata);\n}\n\nstatic int xgbe_flush_tx_queues(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i, count;\n\n\tif (XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER) < 0x21)\n\t\treturn 0;\n\n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, FTQ, 1);\n\n\t \n\tfor (i = 0; i < pdata->tx_q_count; i++) {\n\t\tcount = 2000;\n\t\twhile (--count && XGMAC_MTL_IOREAD_BITS(pdata, i,\n\t\t\t\t\t\t\tMTL_Q_TQOMR, FTQ))\n\t\t\tusleep_range(500, 600);\n\n\t\tif (!count)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void xgbe_config_dma_bus(struct xgbe_prv_data *pdata)\n{\n\tunsigned int sbmr;\n\n\tsbmr = XGMAC_IOREAD(pdata, DMA_SBMR);\n\n\t \n\tXGMAC_SET_BITS(sbmr, DMA_SBMR, EAME, 1);\n\n\t \n\tXGMAC_SET_BITS(sbmr, DMA_SBMR, UNDEF, 1);\n\tXGMAC_SET_BITS(sbmr, DMA_SBMR, BLEN, pdata->blen >> 2);\n\tXGMAC_SET_BITS(sbmr, DMA_SBMR, AAL, pdata->aal);\n\tXGMAC_SET_BITS(sbmr, DMA_SBMR, RD_OSR_LMT, pdata->rd_osr_limit - 1);\n\tXGMAC_SET_BITS(sbmr, DMA_SBMR, WR_OSR_LMT, pdata->wr_osr_limit - 1);\n\n\tXGMAC_IOWRITE(pdata, DMA_SBMR, sbmr);\n\n\t \n\tif (pdata->vdata->tx_desc_prefetch)\n\t\tXGMAC_IOWRITE_BITS(pdata, DMA_TXEDMACR, TDPS,\n\t\t\t\t   pdata->vdata->tx_desc_prefetch);\n\n\tif (pdata->vdata->rx_desc_prefetch)\n\t\tXGMAC_IOWRITE_BITS(pdata, DMA_RXEDMACR, RDPS,\n\t\t\t\t   pdata->vdata->rx_desc_prefetch);\n}\n\nstatic void xgbe_config_dma_cache(struct xgbe_prv_data *pdata)\n{\n\tXGMAC_IOWRITE(pdata, DMA_AXIARCR, pdata->arcr);\n\tXGMAC_IOWRITE(pdata, DMA_AXIAWCR, pdata->awcr);\n\tif (pdata->awarcr)\n\t\tXGMAC_IOWRITE(pdata, DMA_AXIAWARCR, pdata->awarcr);\n}\n\nstatic void xgbe_config_mtl_mode(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MTL_OMR, ETSALG, MTL_ETSALG_WRR);\n\n\t \n\tfor (i = 0; i < pdata->hw_feat.tc_cnt; i++) {\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,\n\t\t\t\t       MTL_TSA_ETS);\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_QWR, QW, 1);\n\t}\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MTL_OMR, RAA, MTL_RAA_SP);\n}\n\nstatic void xgbe_queue_flow_control_threshold(struct xgbe_prv_data *pdata,\n\t\t\t\t\t      unsigned int queue,\n\t\t\t\t\t      unsigned int q_fifo_size)\n{\n\tunsigned int frame_fifo_size;\n\tunsigned int rfa, rfd;\n\n\tframe_fifo_size = XGMAC_FLOW_CONTROL_ALIGN(xgbe_get_max_frame(pdata));\n\n\tif (pdata->pfcq[queue] && (q_fifo_size > pdata->pfc_rfa)) {\n\t\t \n\t\trfa = pdata->pfc_rfa;\n\t\trfd = rfa + frame_fifo_size;\n\t\tif (rfd > XGMAC_FLOW_CONTROL_MAX)\n\t\t\trfd = XGMAC_FLOW_CONTROL_MAX;\n\t\tif (rfa >= XGMAC_FLOW_CONTROL_MAX)\n\t\t\trfa = XGMAC_FLOW_CONTROL_MAX - XGMAC_FLOW_CONTROL_UNIT;\n\t} else {\n\t\t \n\t\tif (q_fifo_size <= 2048) {\n\t\t\t \n\t\t\tpdata->rx_rfa[queue] = 0;\n\t\t\tpdata->rx_rfd[queue] = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (q_fifo_size <= 4096) {\n\t\t\t \n\t\t\tpdata->rx_rfa[queue] = 0;\t \n\t\t\tpdata->rx_rfd[queue] = 1;\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (q_fifo_size <= frame_fifo_size) {\n\t\t\t \n\t\t\tpdata->rx_rfa[queue] = 2;\t \n\t\t\tpdata->rx_rfd[queue] = 5;\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (q_fifo_size <= (frame_fifo_size * 3)) {\n\t\t\t \n\t\t\trfa = q_fifo_size - frame_fifo_size;\n\t\t\trfd = rfa + (frame_fifo_size / 2);\n\t\t} else {\n\t\t\t \n\t\t\trfa = frame_fifo_size * 2;\n\t\t\trfa += XGMAC_FLOW_CONTROL_UNIT;\n\t\t\trfd = rfa + frame_fifo_size;\n\t\t}\n\t}\n\n\tpdata->rx_rfa[queue] = XGMAC_FLOW_CONTROL_VALUE(rfa);\n\tpdata->rx_rfd[queue] = XGMAC_FLOW_CONTROL_VALUE(rfd);\n}\n\nstatic void xgbe_calculate_flow_control_threshold(struct xgbe_prv_data *pdata,\n\t\t\t\t\t\t  unsigned int *fifo)\n{\n\tunsigned int q_fifo_size;\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->rx_q_count; i++) {\n\t\tq_fifo_size = (fifo[i] + 1) * XGMAC_FIFO_UNIT;\n\n\t\txgbe_queue_flow_control_threshold(pdata, i, q_fifo_size);\n\t}\n}\n\nstatic void xgbe_config_flow_control_threshold(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->rx_q_count; i++) {\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQFCR, RFA,\n\t\t\t\t       pdata->rx_rfa[i]);\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQFCR, RFD,\n\t\t\t\t       pdata->rx_rfd[i]);\n\t}\n}\n\nstatic unsigned int xgbe_get_tx_fifo_size(struct xgbe_prv_data *pdata)\n{\n\t \n\treturn min_t(unsigned int, pdata->tx_max_fifo_size,\n\t\t     pdata->hw_feat.tx_fifo_size);\n}\n\nstatic unsigned int xgbe_get_rx_fifo_size(struct xgbe_prv_data *pdata)\n{\n\t \n\treturn min_t(unsigned int, pdata->rx_max_fifo_size,\n\t\t     pdata->hw_feat.rx_fifo_size);\n}\n\nstatic void xgbe_calculate_equal_fifo(unsigned int fifo_size,\n\t\t\t\t      unsigned int queue_count,\n\t\t\t\t      unsigned int *fifo)\n{\n\tunsigned int q_fifo_size;\n\tunsigned int p_fifo;\n\tunsigned int i;\n\n\tq_fifo_size = fifo_size / queue_count;\n\n\t \n\tp_fifo = q_fifo_size / XGMAC_FIFO_UNIT;\n\tif (p_fifo)\n\t\tp_fifo--;\n\n\t \n\tfor (i = 0; i < queue_count; i++)\n\t\tfifo[i] = p_fifo;\n}\n\nstatic unsigned int xgbe_set_nonprio_fifos(unsigned int fifo_size,\n\t\t\t\t\t   unsigned int queue_count,\n\t\t\t\t\t   unsigned int *fifo)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(XGMAC_FIFO_MIN_ALLOC);\n\n\tif (queue_count <= IEEE_8021QAZ_MAX_TCS)\n\t\treturn fifo_size;\n\n\t \n\tfor (i = IEEE_8021QAZ_MAX_TCS; i < queue_count; i++) {\n\t\tfifo[i] = (XGMAC_FIFO_MIN_ALLOC / XGMAC_FIFO_UNIT) - 1;\n\t\tfifo_size -= XGMAC_FIFO_MIN_ALLOC;\n\t}\n\n\treturn fifo_size;\n}\n\nstatic unsigned int xgbe_get_pfc_delay(struct xgbe_prv_data *pdata)\n{\n\tunsigned int delay;\n\n\t \n\tif (pdata->pfc->delay)\n\t\treturn pdata->pfc->delay / 8;\n\n\t \n\tdelay = xgbe_get_max_frame(pdata);\n\tdelay += XGMAC_ETH_PREAMBLE;\n\tdelay *= 2;\n\n\t \n\tdelay += XGMAC_PFC_DATA_LEN;\n\tdelay += ETH_HLEN + ETH_FCS_LEN;\n\tdelay += XGMAC_ETH_PREAMBLE;\n\n\t \n\tdelay += XGMAC_PFC_DELAYS;\n\n\treturn delay;\n}\n\nstatic unsigned int xgbe_get_pfc_queues(struct xgbe_prv_data *pdata)\n{\n\tunsigned int count, prio_queues;\n\tunsigned int i;\n\n\tif (!pdata->pfc->pfc_en)\n\t\treturn 0;\n\n\tcount = 0;\n\tprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\n\tfor (i = 0; i < prio_queues; i++) {\n\t\tif (!xgbe_is_pfc_queue(pdata, i))\n\t\t\tcontinue;\n\n\t\tpdata->pfcq[i] = 1;\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void xgbe_calculate_dcb_fifo(struct xgbe_prv_data *pdata,\n\t\t\t\t    unsigned int fifo_size,\n\t\t\t\t    unsigned int *fifo)\n{\n\tunsigned int q_fifo_size, rem_fifo, addn_fifo;\n\tunsigned int prio_queues;\n\tunsigned int pfc_count;\n\tunsigned int i;\n\n\tq_fifo_size = XGMAC_FIFO_ALIGN(xgbe_get_max_frame(pdata));\n\tprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\n\tpfc_count = xgbe_get_pfc_queues(pdata);\n\n\tif (!pfc_count || ((q_fifo_size * prio_queues) > fifo_size)) {\n\t\t \n\t\txgbe_calculate_equal_fifo(fifo_size, prio_queues, fifo);\n\t\treturn;\n\t}\n\n\t \n\trem_fifo = fifo_size - (q_fifo_size * prio_queues);\n\n\t \n\tpdata->pfc_rfa = xgbe_get_pfc_delay(pdata);\n\tpdata->pfc_rfa = XGMAC_FLOW_CONTROL_ALIGN(pdata->pfc_rfa);\n\n\tif (pdata->pfc_rfa > q_fifo_size) {\n\t\taddn_fifo = pdata->pfc_rfa - q_fifo_size;\n\t\taddn_fifo = XGMAC_FIFO_ALIGN(addn_fifo);\n\t} else {\n\t\taddn_fifo = 0;\n\t}\n\n\t \n\ti = prio_queues;\n\twhile (i > 0) {\n\t\ti--;\n\n\t\tfifo[i] = (q_fifo_size / XGMAC_FIFO_UNIT) - 1;\n\n\t\tif (!pdata->pfcq[i] || !addn_fifo)\n\t\t\tcontinue;\n\n\t\tif (addn_fifo > rem_fifo) {\n\t\t\tnetdev_warn(pdata->netdev,\n\t\t\t\t    \"RXq%u cannot set needed fifo size\\n\", i);\n\t\t\tif (!rem_fifo)\n\t\t\t\tcontinue;\n\n\t\t\taddn_fifo = rem_fifo;\n\t\t}\n\n\t\tfifo[i] += (addn_fifo / XGMAC_FIFO_UNIT);\n\t\trem_fifo -= addn_fifo;\n\t}\n\n\tif (rem_fifo) {\n\t\tunsigned int inc_fifo = rem_fifo / prio_queues;\n\n\t\t \n\t\tfor (i = 0; i < prio_queues; i++)\n\t\t\tfifo[i] += (inc_fifo / XGMAC_FIFO_UNIT);\n\t}\n}\n\nstatic void xgbe_config_tx_fifo_size(struct xgbe_prv_data *pdata)\n{\n\tunsigned int fifo_size;\n\tunsigned int fifo[XGBE_MAX_QUEUES];\n\tunsigned int i;\n\n\tfifo_size = xgbe_get_tx_fifo_size(pdata);\n\n\txgbe_calculate_equal_fifo(fifo_size, pdata->tx_q_count, fifo);\n\n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TQS, fifo[i]);\n\n\tnetif_info(pdata, drv, pdata->netdev,\n\t\t   \"%d Tx hardware queues, %d byte fifo per queue\\n\",\n\t\t   pdata->tx_q_count, ((fifo[0] + 1) * XGMAC_FIFO_UNIT));\n}\n\nstatic void xgbe_config_rx_fifo_size(struct xgbe_prv_data *pdata)\n{\n\tunsigned int fifo_size;\n\tunsigned int fifo[XGBE_MAX_QUEUES];\n\tunsigned int prio_queues;\n\tunsigned int i;\n\n\t \n\tmemset(pdata->pfcq, 0, sizeof(pdata->pfcq));\n\tpdata->pfc_rfa = 0;\n\n\tfifo_size = xgbe_get_rx_fifo_size(pdata);\n\tprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\n\n\t \n\tfifo_size = xgbe_set_nonprio_fifos(fifo_size, pdata->rx_q_count, fifo);\n\n\tif (pdata->pfc && pdata->ets)\n\t\txgbe_calculate_dcb_fifo(pdata, fifo_size, fifo);\n\telse\n\t\txgbe_calculate_equal_fifo(fifo_size, prio_queues, fifo);\n\n\tfor (i = 0; i < pdata->rx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RQS, fifo[i]);\n\n\txgbe_calculate_flow_control_threshold(pdata, fifo);\n\txgbe_config_flow_control_threshold(pdata);\n\n\tif (pdata->pfc && pdata->ets && pdata->pfc->pfc_en) {\n\t\tnetif_info(pdata, drv, pdata->netdev,\n\t\t\t   \"%u Rx hardware queues\\n\", pdata->rx_q_count);\n\t\tfor (i = 0; i < pdata->rx_q_count; i++)\n\t\t\tnetif_info(pdata, drv, pdata->netdev,\n\t\t\t\t   \"RxQ%u, %u byte fifo queue\\n\", i,\n\t\t\t\t   ((fifo[i] + 1) * XGMAC_FIFO_UNIT));\n\t} else {\n\t\tnetif_info(pdata, drv, pdata->netdev,\n\t\t\t   \"%u Rx hardware queues, %u byte fifo per queue\\n\",\n\t\t\t   pdata->rx_q_count,\n\t\t\t   ((fifo[0] + 1) * XGMAC_FIFO_UNIT));\n\t}\n}\n\nstatic void xgbe_config_queue_mapping(struct xgbe_prv_data *pdata)\n{\n\tunsigned int qptc, qptc_extra, queue;\n\tunsigned int prio_queues;\n\tunsigned int ppq, ppq_extra, prio;\n\tunsigned int mask;\n\tunsigned int i, j, reg, reg_val;\n\n\t \n\tqptc = pdata->tx_q_count / pdata->hw_feat.tc_cnt;\n\tqptc_extra = pdata->tx_q_count % pdata->hw_feat.tc_cnt;\n\n\tfor (i = 0, queue = 0; i < pdata->hw_feat.tc_cnt; i++) {\n\t\tfor (j = 0; j < qptc; j++) {\n\t\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t\t  \"TXq%u mapped to TC%u\\n\", queue, i);\n\t\t\tXGMAC_MTL_IOWRITE_BITS(pdata, queue, MTL_Q_TQOMR,\n\t\t\t\t\t       Q2TCMAP, i);\n\t\t\tpdata->q2tc_map[queue++] = i;\n\t\t}\n\n\t\tif (i < qptc_extra) {\n\t\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t\t  \"TXq%u mapped to TC%u\\n\", queue, i);\n\t\t\tXGMAC_MTL_IOWRITE_BITS(pdata, queue, MTL_Q_TQOMR,\n\t\t\t\t\t       Q2TCMAP, i);\n\t\t\tpdata->q2tc_map[queue++] = i;\n\t\t}\n\t}\n\n\t \n\tprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\n\tppq = IEEE_8021QAZ_MAX_TCS / prio_queues;\n\tppq_extra = IEEE_8021QAZ_MAX_TCS % prio_queues;\n\n\treg = MAC_RQC2R;\n\treg_val = 0;\n\tfor (i = 0, prio = 0; i < prio_queues;) {\n\t\tmask = 0;\n\t\tfor (j = 0; j < ppq; j++) {\n\t\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t\t  \"PRIO%u mapped to RXq%u\\n\", prio, i);\n\t\t\tmask |= (1 << prio);\n\t\t\tpdata->prio2q_map[prio++] = i;\n\t\t}\n\n\t\tif (i < ppq_extra) {\n\t\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t\t  \"PRIO%u mapped to RXq%u\\n\", prio, i);\n\t\t\tmask |= (1 << prio);\n\t\t\tpdata->prio2q_map[prio++] = i;\n\t\t}\n\n\t\treg_val |= (mask << ((i++ % MAC_RQC2_Q_PER_REG) << 3));\n\n\t\tif ((i % MAC_RQC2_Q_PER_REG) && (i != prio_queues))\n\t\t\tcontinue;\n\n\t\tXGMAC_IOWRITE(pdata, reg, reg_val);\n\t\treg += MAC_RQC2_INC;\n\t\treg_val = 0;\n\t}\n\n\t \n\treg = MTL_RQDCM0R;\n\treg_val = 0;\n\tfor (i = 0; i < pdata->rx_q_count;) {\n\t\treg_val |= (0x80 << ((i++ % MTL_RQDCM_Q_PER_REG) << 3));\n\n\t\tif ((i % MTL_RQDCM_Q_PER_REG) && (i != pdata->rx_q_count))\n\t\t\tcontinue;\n\n\t\tXGMAC_IOWRITE(pdata, reg, reg_val);\n\n\t\treg += MTL_RQDCM_INC;\n\t\treg_val = 0;\n\t}\n}\n\nstatic void xgbe_config_tc(struct xgbe_prv_data *pdata)\n{\n\tunsigned int offset, queue, prio;\n\tu8 i;\n\n\tnetdev_reset_tc(pdata->netdev);\n\tif (!pdata->num_tcs)\n\t\treturn;\n\n\tnetdev_set_num_tc(pdata->netdev, pdata->num_tcs);\n\n\tfor (i = 0, queue = 0, offset = 0; i < pdata->num_tcs; i++) {\n\t\twhile ((queue < pdata->tx_q_count) &&\n\t\t       (pdata->q2tc_map[queue] == i))\n\t\t\tqueue++;\n\n\t\tnetif_dbg(pdata, drv, pdata->netdev, \"TC%u using TXq%u-%u\\n\",\n\t\t\t  i, offset, queue - 1);\n\t\tnetdev_set_tc_queue(pdata->netdev, i, queue - offset, offset);\n\t\toffset = queue;\n\t}\n\n\tif (!pdata->ets)\n\t\treturn;\n\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++)\n\t\tnetdev_set_prio_tc_map(pdata->netdev, prio,\n\t\t\t\t       pdata->ets->prio_tc[prio]);\n}\n\nstatic void xgbe_config_dcb_tc(struct xgbe_prv_data *pdata)\n{\n\tstruct ieee_ets *ets = pdata->ets;\n\tunsigned int total_weight, min_weight, weight;\n\tunsigned int mask, reg, reg_val;\n\tunsigned int i, prio;\n\n\tif (!ets)\n\t\treturn;\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MTL_OMR, ETSALG, MTL_ETSALG_DWRR);\n\n\t \n\ttotal_weight = pdata->netdev->mtu * pdata->hw_feat.tc_cnt;\n\tmin_weight = total_weight / 100;\n\tif (!min_weight)\n\t\tmin_weight = 1;\n\n\tfor (i = 0; i < pdata->hw_feat.tc_cnt; i++) {\n\t\t \n\t\tmask = 0;\n\t\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++) {\n\t\t\tif (ets->prio_tc[prio] == i)\n\t\t\t\tmask |= (1 << prio);\n\t\t}\n\t\tmask &= 0xff;\n\n\t\tnetif_dbg(pdata, drv, pdata->netdev, \"TC%u PRIO mask=%#x\\n\",\n\t\t\t  i, mask);\n\t\treg = MTL_TCPM0R + (MTL_TCPM_INC * (i / MTL_TCPM_TC_PER_REG));\n\t\treg_val = XGMAC_IOREAD(pdata, reg);\n\n\t\treg_val &= ~(0xff << ((i % MTL_TCPM_TC_PER_REG) << 3));\n\t\treg_val |= (mask << ((i % MTL_TCPM_TC_PER_REG) << 3));\n\n\t\tXGMAC_IOWRITE(pdata, reg, reg_val);\n\n\t\t \n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t\t  \"TC%u using SP\\n\", i);\n\t\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,\n\t\t\t\t\t       MTL_TSA_SP);\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\tweight = total_weight * ets->tc_tx_bw[i] / 100;\n\t\t\tweight = clamp(weight, min_weight, total_weight);\n\n\t\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t\t  \"TC%u using DWRR (weight %u)\\n\", i, weight);\n\t\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,\n\t\t\t\t\t       MTL_TSA_ETS);\n\t\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_QWR, QW,\n\t\t\t\t\t       weight);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txgbe_config_tc(pdata);\n}\n\nstatic void xgbe_config_dcb_pfc(struct xgbe_prv_data *pdata)\n{\n\tif (!test_bit(XGBE_DOWN, &pdata->dev_state)) {\n\t\t \n\t\tnetif_tx_stop_all_queues(pdata->netdev);\n\n\t\t \n\t\tpdata->hw_if.disable_rx(pdata);\n\t}\n\n\txgbe_config_rx_fifo_size(pdata);\n\txgbe_config_flow_control(pdata);\n\n\tif (!test_bit(XGBE_DOWN, &pdata->dev_state)) {\n\t\t \n\t\tpdata->hw_if.enable_rx(pdata);\n\n\t\t \n\t\tnetif_tx_start_all_queues(pdata->netdev);\n\t}\n}\n\nstatic void xgbe_config_mac_address(struct xgbe_prv_data *pdata)\n{\n\txgbe_set_mac_address(pdata, pdata->netdev->dev_addr);\n\n\t \n\tif (pdata->hw_feat.hash_table_size) {\n\t\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, HPF, 1);\n\t\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, HUC, 1);\n\t\tXGMAC_IOWRITE_BITS(pdata, MAC_PFR, HMC, 1);\n\t}\n}\n\nstatic void xgbe_config_jumbo_enable(struct xgbe_prv_data *pdata)\n{\n\tunsigned int val;\n\n\tval = (pdata->netdev->mtu > XGMAC_STD_PACKET_MTU) ? 1 : 0;\n\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, JE, val);\n}\n\nstatic void xgbe_config_mac_speed(struct xgbe_prv_data *pdata)\n{\n\txgbe_set_speed(pdata, pdata->phy_speed);\n}\n\nstatic void xgbe_config_checksum_offload(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->netdev->features & NETIF_F_RXCSUM)\n\t\txgbe_enable_rx_csum(pdata);\n\telse\n\t\txgbe_disable_rx_csum(pdata);\n}\n\nstatic void xgbe_config_vlan_support(struct xgbe_prv_data *pdata)\n{\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANIR, CSVL, 0);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_VLANIR, VLTI, 1);\n\n\t \n\txgbe_update_vlan_hash_table(pdata);\n\n\tif (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\txgbe_enable_rx_vlan_filtering(pdata);\n\telse\n\t\txgbe_disable_rx_vlan_filtering(pdata);\n\n\tif (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\txgbe_enable_rx_vlan_stripping(pdata);\n\telse\n\t\txgbe_disable_rx_vlan_stripping(pdata);\n}\n\nstatic u64 xgbe_mmc_read(struct xgbe_prv_data *pdata, unsigned int reg_lo)\n{\n\tbool read_hi;\n\tu64 val;\n\n\tif (pdata->vdata->mmc_64bit) {\n\t\tswitch (reg_lo) {\n\t\t \n\t\tcase MMC_RXRUNTERROR:\n\t\tcase MMC_RXJABBERERROR:\n\t\tcase MMC_RXUNDERSIZE_G:\n\t\tcase MMC_RXOVERSIZE_G:\n\t\tcase MMC_RXWATCHDOGERROR:\n\t\t\tread_hi = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tread_hi = true;\n\t\t}\n\t} else {\n\t\tswitch (reg_lo) {\n\t\t \n\t\tcase MMC_TXOCTETCOUNT_GB_LO:\n\t\tcase MMC_TXOCTETCOUNT_G_LO:\n\t\tcase MMC_RXOCTETCOUNT_GB_LO:\n\t\tcase MMC_RXOCTETCOUNT_G_LO:\n\t\t\tread_hi = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tread_hi = false;\n\t\t}\n\t}\n\n\tval = XGMAC_IOREAD(pdata, reg_lo);\n\n\tif (read_hi)\n\t\tval |= ((u64)XGMAC_IOREAD(pdata, reg_lo + 4) << 32);\n\n\treturn val;\n}\n\nstatic void xgbe_tx_mmc_int(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_mmc_stats *stats = &pdata->mmc_stats;\n\tunsigned int mmc_isr = XGMAC_IOREAD(pdata, MMC_TISR);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXOCTETCOUNT_GB))\n\t\tstats->txoctetcount_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXFRAMECOUNT_GB))\n\t\tstats->txframecount_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXBROADCASTFRAMES_G))\n\t\tstats->txbroadcastframes_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXMULTICASTFRAMES_G))\n\t\tstats->txmulticastframes_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX64OCTETS_GB))\n\t\tstats->tx64octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TX64OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX65TO127OCTETS_GB))\n\t\tstats->tx65to127octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TX65TO127OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX128TO255OCTETS_GB))\n\t\tstats->tx128to255octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TX128TO255OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX256TO511OCTETS_GB))\n\t\tstats->tx256to511octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TX256TO511OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX512TO1023OCTETS_GB))\n\t\tstats->tx512to1023octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TX512TO1023OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX1024TOMAXOCTETS_GB))\n\t\tstats->tx1024tomaxoctets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TX1024TOMAXOCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXUNICASTFRAMES_GB))\n\t\tstats->txunicastframes_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXUNICASTFRAMES_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXMULTICASTFRAMES_GB))\n\t\tstats->txmulticastframes_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXBROADCASTFRAMES_GB))\n\t\tstats->txbroadcastframes_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXUNDERFLOWERROR))\n\t\tstats->txunderflowerror +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXUNDERFLOWERROR_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXOCTETCOUNT_G))\n\t\tstats->txoctetcount_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXFRAMECOUNT_G))\n\t\tstats->txframecount_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXPAUSEFRAMES))\n\t\tstats->txpauseframes +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXPAUSEFRAMES_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXVLANFRAMES_G))\n\t\tstats->txvlanframes_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_TXVLANFRAMES_G_LO);\n}\n\nstatic void xgbe_rx_mmc_int(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_mmc_stats *stats = &pdata->mmc_stats;\n\tunsigned int mmc_isr = XGMAC_IOREAD(pdata, MMC_RISR);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXFRAMECOUNT_GB))\n\t\tstats->rxframecount_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXFRAMECOUNT_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOCTETCOUNT_GB))\n\t\tstats->rxoctetcount_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOCTETCOUNT_G))\n\t\tstats->rxoctetcount_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXBROADCASTFRAMES_G))\n\t\tstats->rxbroadcastframes_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXBROADCASTFRAMES_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXMULTICASTFRAMES_G))\n\t\tstats->rxmulticastframes_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXMULTICASTFRAMES_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXCRCERROR))\n\t\tstats->rxcrcerror +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXCRCERROR_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXRUNTERROR))\n\t\tstats->rxrunterror +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXRUNTERROR);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXJABBERERROR))\n\t\tstats->rxjabbererror +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXJABBERERROR);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXUNDERSIZE_G))\n\t\tstats->rxundersize_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXUNDERSIZE_G);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOVERSIZE_G))\n\t\tstats->rxoversize_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXOVERSIZE_G);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX64OCTETS_GB))\n\t\tstats->rx64octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RX64OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX65TO127OCTETS_GB))\n\t\tstats->rx65to127octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RX65TO127OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX128TO255OCTETS_GB))\n\t\tstats->rx128to255octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RX128TO255OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX256TO511OCTETS_GB))\n\t\tstats->rx256to511octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RX256TO511OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX512TO1023OCTETS_GB))\n\t\tstats->rx512to1023octets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RX512TO1023OCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX1024TOMAXOCTETS_GB))\n\t\tstats->rx1024tomaxoctets_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RX1024TOMAXOCTETS_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXUNICASTFRAMES_G))\n\t\tstats->rxunicastframes_g +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXUNICASTFRAMES_G_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXLENGTHERROR))\n\t\tstats->rxlengtherror +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXLENGTHERROR_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOUTOFRANGETYPE))\n\t\tstats->rxoutofrangetype +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXOUTOFRANGETYPE_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXPAUSEFRAMES))\n\t\tstats->rxpauseframes +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXPAUSEFRAMES_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXFIFOOVERFLOW))\n\t\tstats->rxfifooverflow +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXFIFOOVERFLOW_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXVLANFRAMES_GB))\n\t\tstats->rxvlanframes_gb +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXVLANFRAMES_GB_LO);\n\n\tif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXWATCHDOGERROR))\n\t\tstats->rxwatchdogerror +=\n\t\t\txgbe_mmc_read(pdata, MMC_RXWATCHDOGERROR);\n}\n\nstatic void xgbe_read_mmc_stats(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_mmc_stats *stats = &pdata->mmc_stats;\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MMC_CR, MCF, 1);\n\n\tstats->txoctetcount_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_GB_LO);\n\n\tstats->txframecount_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_GB_LO);\n\n\tstats->txbroadcastframes_g +=\n\t\txgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_G_LO);\n\n\tstats->txmulticastframes_g +=\n\t\txgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_G_LO);\n\n\tstats->tx64octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TX64OCTETS_GB_LO);\n\n\tstats->tx65to127octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TX65TO127OCTETS_GB_LO);\n\n\tstats->tx128to255octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TX128TO255OCTETS_GB_LO);\n\n\tstats->tx256to511octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TX256TO511OCTETS_GB_LO);\n\n\tstats->tx512to1023octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TX512TO1023OCTETS_GB_LO);\n\n\tstats->tx1024tomaxoctets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TX1024TOMAXOCTETS_GB_LO);\n\n\tstats->txunicastframes_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TXUNICASTFRAMES_GB_LO);\n\n\tstats->txmulticastframes_gb +=\n\t\txgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_GB_LO);\n\n\tstats->txbroadcastframes_g +=\n\t\txgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_GB_LO);\n\n\tstats->txunderflowerror +=\n\t\txgbe_mmc_read(pdata, MMC_TXUNDERFLOWERROR_LO);\n\n\tstats->txoctetcount_g +=\n\t\txgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_G_LO);\n\n\tstats->txframecount_g +=\n\t\txgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_G_LO);\n\n\tstats->txpauseframes +=\n\t\txgbe_mmc_read(pdata, MMC_TXPAUSEFRAMES_LO);\n\n\tstats->txvlanframes_g +=\n\t\txgbe_mmc_read(pdata, MMC_TXVLANFRAMES_G_LO);\n\n\tstats->rxframecount_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RXFRAMECOUNT_GB_LO);\n\n\tstats->rxoctetcount_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_GB_LO);\n\n\tstats->rxoctetcount_g +=\n\t\txgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_G_LO);\n\n\tstats->rxbroadcastframes_g +=\n\t\txgbe_mmc_read(pdata, MMC_RXBROADCASTFRAMES_G_LO);\n\n\tstats->rxmulticastframes_g +=\n\t\txgbe_mmc_read(pdata, MMC_RXMULTICASTFRAMES_G_LO);\n\n\tstats->rxcrcerror +=\n\t\txgbe_mmc_read(pdata, MMC_RXCRCERROR_LO);\n\n\tstats->rxrunterror +=\n\t\txgbe_mmc_read(pdata, MMC_RXRUNTERROR);\n\n\tstats->rxjabbererror +=\n\t\txgbe_mmc_read(pdata, MMC_RXJABBERERROR);\n\n\tstats->rxundersize_g +=\n\t\txgbe_mmc_read(pdata, MMC_RXUNDERSIZE_G);\n\n\tstats->rxoversize_g +=\n\t\txgbe_mmc_read(pdata, MMC_RXOVERSIZE_G);\n\n\tstats->rx64octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RX64OCTETS_GB_LO);\n\n\tstats->rx65to127octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RX65TO127OCTETS_GB_LO);\n\n\tstats->rx128to255octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RX128TO255OCTETS_GB_LO);\n\n\tstats->rx256to511octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RX256TO511OCTETS_GB_LO);\n\n\tstats->rx512to1023octets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RX512TO1023OCTETS_GB_LO);\n\n\tstats->rx1024tomaxoctets_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RX1024TOMAXOCTETS_GB_LO);\n\n\tstats->rxunicastframes_g +=\n\t\txgbe_mmc_read(pdata, MMC_RXUNICASTFRAMES_G_LO);\n\n\tstats->rxlengtherror +=\n\t\txgbe_mmc_read(pdata, MMC_RXLENGTHERROR_LO);\n\n\tstats->rxoutofrangetype +=\n\t\txgbe_mmc_read(pdata, MMC_RXOUTOFRANGETYPE_LO);\n\n\tstats->rxpauseframes +=\n\t\txgbe_mmc_read(pdata, MMC_RXPAUSEFRAMES_LO);\n\n\tstats->rxfifooverflow +=\n\t\txgbe_mmc_read(pdata, MMC_RXFIFOOVERFLOW_LO);\n\n\tstats->rxvlanframes_gb +=\n\t\txgbe_mmc_read(pdata, MMC_RXVLANFRAMES_GB_LO);\n\n\tstats->rxwatchdogerror +=\n\t\txgbe_mmc_read(pdata, MMC_RXWATCHDOGERROR);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MMC_CR, MCF, 0);\n}\n\nstatic void xgbe_config_mmc(struct xgbe_prv_data *pdata)\n{\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MMC_CR, ROR, 1);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MMC_CR, CR, 1);\n}\n\nstatic void xgbe_txq_prepare_tx_stop(struct xgbe_prv_data *pdata,\n\t\t\t\t     unsigned int queue)\n{\n\tunsigned int tx_status;\n\tunsigned long tx_timeout;\n\n\t \n\ttx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);\n\twhile (time_before(jiffies, tx_timeout)) {\n\t\ttx_status = XGMAC_MTL_IOREAD(pdata, queue, MTL_Q_TQDR);\n\t\tif ((XGMAC_GET_BITS(tx_status, MTL_Q_TQDR, TRCSTS) != 1) &&\n\t\t    (XGMAC_GET_BITS(tx_status, MTL_Q_TQDR, TXQSTS) == 0))\n\t\t\tbreak;\n\n\t\tusleep_range(500, 1000);\n\t}\n\n\tif (!time_before(jiffies, tx_timeout))\n\t\tnetdev_info(pdata->netdev,\n\t\t\t    \"timed out waiting for Tx queue %u to empty\\n\",\n\t\t\t    queue);\n}\n\nstatic void xgbe_prepare_tx_stop(struct xgbe_prv_data *pdata,\n\t\t\t\t unsigned int queue)\n{\n\tunsigned int tx_dsr, tx_pos, tx_qidx;\n\tunsigned int tx_status;\n\tunsigned long tx_timeout;\n\n\tif (XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER) > 0x20)\n\t\treturn xgbe_txq_prepare_tx_stop(pdata, queue);\n\n\t \n\tif (queue < DMA_DSRX_FIRST_QUEUE) {\n\t\ttx_dsr = DMA_DSR0;\n\t\ttx_pos = (queue * DMA_DSR_Q_WIDTH) + DMA_DSR0_TPS_START;\n\t} else {\n\t\ttx_qidx = queue - DMA_DSRX_FIRST_QUEUE;\n\n\t\ttx_dsr = DMA_DSR1 + ((tx_qidx / DMA_DSRX_QPR) * DMA_DSRX_INC);\n\t\ttx_pos = ((tx_qidx % DMA_DSRX_QPR) * DMA_DSR_Q_WIDTH) +\n\t\t\t DMA_DSRX_TPS_START;\n\t}\n\n\t \n\ttx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);\n\twhile (time_before(jiffies, tx_timeout)) {\n\t\ttx_status = XGMAC_IOREAD(pdata, tx_dsr);\n\t\ttx_status = GET_BITS(tx_status, tx_pos, DMA_DSR_TPS_WIDTH);\n\t\tif ((tx_status == DMA_TPS_STOPPED) ||\n\t\t    (tx_status == DMA_TPS_SUSPENDED))\n\t\t\tbreak;\n\n\t\tusleep_range(500, 1000);\n\t}\n\n\tif (!time_before(jiffies, tx_timeout))\n\t\tnetdev_info(pdata->netdev,\n\t\t\t    \"timed out waiting for Tx DMA channel %u to stop\\n\",\n\t\t\t    queue);\n}\n\nstatic void xgbe_enable_tx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->tx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_TCR, ST, 1);\n\t}\n\n\t \n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TXQEN,\n\t\t\t\t       MTL_Q_ENABLED);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 1);\n}\n\nstatic void xgbe_disable_tx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\txgbe_prepare_tx_stop(pdata, i);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);\n\n\t \n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\tXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TXQEN, 0);\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->tx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_TCR, ST, 0);\n\t}\n}\n\nstatic void xgbe_prepare_rx_stop(struct xgbe_prv_data *pdata,\n\t\t\t\t unsigned int queue)\n{\n\tunsigned int rx_status;\n\tunsigned long rx_timeout;\n\n\t \n\trx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);\n\twhile (time_before(jiffies, rx_timeout)) {\n\t\trx_status = XGMAC_MTL_IOREAD(pdata, queue, MTL_Q_RQDR);\n\t\tif ((XGMAC_GET_BITS(rx_status, MTL_Q_RQDR, PRXQ) == 0) &&\n\t\t    (XGMAC_GET_BITS(rx_status, MTL_Q_RQDR, RXQSTS) == 0))\n\t\t\tbreak;\n\n\t\tusleep_range(500, 1000);\n\t}\n\n\tif (!time_before(jiffies, rx_timeout))\n\t\tnetdev_info(pdata->netdev,\n\t\t\t    \"timed out waiting for Rx queue %u to empty\\n\",\n\t\t\t    queue);\n}\n\nstatic void xgbe_enable_rx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int reg_val, i;\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->rx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_RCR, SR, 1);\n\t}\n\n\t \n\treg_val = 0;\n\tfor (i = 0; i < pdata->rx_q_count; i++)\n\t\treg_val |= (0x02 << (i << 1));\n\tXGMAC_IOWRITE(pdata, MAC_RQC0R, reg_val);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, DCRCC, 1);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, CST, 1);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, ACS, 1);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, RE, 1);\n}\n\nstatic void xgbe_disable_rx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, DCRCC, 0);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, CST, 0);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, ACS, 0);\n\tXGMAC_IOWRITE_BITS(pdata, MAC_RCR, RE, 0);\n\n\t \n\tfor (i = 0; i < pdata->rx_q_count; i++)\n\t\txgbe_prepare_rx_stop(pdata, i);\n\n\t \n\tXGMAC_IOWRITE(pdata, MAC_RQC0R, 0);\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->rx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_RCR, SR, 0);\n\t}\n}\n\nstatic void xgbe_powerup_tx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->tx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_TCR, ST, 1);\n\t}\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 1);\n}\n\nstatic void xgbe_powerdown_tx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < pdata->tx_q_count; i++)\n\t\txgbe_prepare_tx_stop(pdata, i);\n\n\t \n\tXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->tx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_TCR, ST, 0);\n\t}\n}\n\nstatic void xgbe_powerup_rx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->rx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_RCR, SR, 1);\n\t}\n}\n\nstatic void xgbe_powerdown_rx(struct xgbe_prv_data *pdata)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < pdata->channel_count; i++) {\n\t\tif (!pdata->channel[i]->rx_ring)\n\t\t\tbreak;\n\n\t\tXGMAC_DMA_IOWRITE_BITS(pdata->channel[i], DMA_CH_RCR, SR, 0);\n\t}\n}\n\nstatic int xgbe_init(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_desc_if *desc_if = &pdata->desc_if;\n\tint ret;\n\n\tDBGPR(\"-->xgbe_init\\n\");\n\n\t \n\tret = xgbe_flush_tx_queues(pdata);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev, \"error flushing TX queues\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\txgbe_config_dma_bus(pdata);\n\txgbe_config_dma_cache(pdata);\n\txgbe_config_osp_mode(pdata);\n\txgbe_config_pbl_val(pdata);\n\txgbe_config_rx_coalesce(pdata);\n\txgbe_config_tx_coalesce(pdata);\n\txgbe_config_rx_buffer_size(pdata);\n\txgbe_config_tso_mode(pdata);\n\txgbe_config_sph_mode(pdata);\n\txgbe_config_rss(pdata);\n\tdesc_if->wrapper_tx_desc_init(pdata);\n\tdesc_if->wrapper_rx_desc_init(pdata);\n\txgbe_enable_dma_interrupts(pdata);\n\n\t \n\txgbe_config_mtl_mode(pdata);\n\txgbe_config_queue_mapping(pdata);\n\txgbe_config_tsf_mode(pdata, pdata->tx_sf_mode);\n\txgbe_config_rsf_mode(pdata, pdata->rx_sf_mode);\n\txgbe_config_tx_threshold(pdata, pdata->tx_threshold);\n\txgbe_config_rx_threshold(pdata, pdata->rx_threshold);\n\txgbe_config_tx_fifo_size(pdata);\n\txgbe_config_rx_fifo_size(pdata);\n\t \n\txgbe_config_dcb_tc(pdata);\n\txgbe_enable_mtl_interrupts(pdata);\n\n\t \n\txgbe_config_mac_address(pdata);\n\txgbe_config_rx_mode(pdata);\n\txgbe_config_jumbo_enable(pdata);\n\txgbe_config_flow_control(pdata);\n\txgbe_config_mac_speed(pdata);\n\txgbe_config_checksum_offload(pdata);\n\txgbe_config_vlan_support(pdata);\n\txgbe_config_mmc(pdata);\n\txgbe_enable_mac_interrupts(pdata);\n\n\t \n\txgbe_enable_ecc_interrupts(pdata);\n\n\tDBGPR(\"<--xgbe_init\\n\");\n\n\treturn 0;\n}\n\nvoid xgbe_init_function_ptrs_dev(struct xgbe_hw_if *hw_if)\n{\n\tDBGPR(\"-->xgbe_init_function_ptrs\\n\");\n\n\thw_if->tx_complete = xgbe_tx_complete;\n\n\thw_if->set_mac_address = xgbe_set_mac_address;\n\thw_if->config_rx_mode = xgbe_config_rx_mode;\n\n\thw_if->enable_rx_csum = xgbe_enable_rx_csum;\n\thw_if->disable_rx_csum = xgbe_disable_rx_csum;\n\n\thw_if->enable_rx_vlan_stripping = xgbe_enable_rx_vlan_stripping;\n\thw_if->disable_rx_vlan_stripping = xgbe_disable_rx_vlan_stripping;\n\thw_if->enable_rx_vlan_filtering = xgbe_enable_rx_vlan_filtering;\n\thw_if->disable_rx_vlan_filtering = xgbe_disable_rx_vlan_filtering;\n\thw_if->update_vlan_hash_table = xgbe_update_vlan_hash_table;\n\n\thw_if->read_mmd_regs = xgbe_read_mmd_regs;\n\thw_if->write_mmd_regs = xgbe_write_mmd_regs;\n\n\thw_if->set_speed = xgbe_set_speed;\n\n\thw_if->set_ext_mii_mode = xgbe_set_ext_mii_mode;\n\thw_if->read_ext_mii_regs_c22 = xgbe_read_ext_mii_regs_c22;\n\thw_if->write_ext_mii_regs_c22 = xgbe_write_ext_mii_regs_c22;\n\thw_if->read_ext_mii_regs_c45 = xgbe_read_ext_mii_regs_c45;\n\thw_if->write_ext_mii_regs_c45 = xgbe_write_ext_mii_regs_c45;\n\n\thw_if->set_gpio = xgbe_set_gpio;\n\thw_if->clr_gpio = xgbe_clr_gpio;\n\n\thw_if->enable_tx = xgbe_enable_tx;\n\thw_if->disable_tx = xgbe_disable_tx;\n\thw_if->enable_rx = xgbe_enable_rx;\n\thw_if->disable_rx = xgbe_disable_rx;\n\n\thw_if->powerup_tx = xgbe_powerup_tx;\n\thw_if->powerdown_tx = xgbe_powerdown_tx;\n\thw_if->powerup_rx = xgbe_powerup_rx;\n\thw_if->powerdown_rx = xgbe_powerdown_rx;\n\n\thw_if->dev_xmit = xgbe_dev_xmit;\n\thw_if->dev_read = xgbe_dev_read;\n\thw_if->enable_int = xgbe_enable_int;\n\thw_if->disable_int = xgbe_disable_int;\n\thw_if->init = xgbe_init;\n\thw_if->exit = xgbe_exit;\n\n\t \n\thw_if->tx_desc_init = xgbe_tx_desc_init;\n\thw_if->rx_desc_init = xgbe_rx_desc_init;\n\thw_if->tx_desc_reset = xgbe_tx_desc_reset;\n\thw_if->rx_desc_reset = xgbe_rx_desc_reset;\n\thw_if->is_last_desc = xgbe_is_last_desc;\n\thw_if->is_context_desc = xgbe_is_context_desc;\n\thw_if->tx_start_xmit = xgbe_tx_start_xmit;\n\n\t \n\thw_if->config_tx_flow_control = xgbe_config_tx_flow_control;\n\thw_if->config_rx_flow_control = xgbe_config_rx_flow_control;\n\n\t \n\thw_if->config_rx_coalesce = xgbe_config_rx_coalesce;\n\thw_if->config_tx_coalesce = xgbe_config_tx_coalesce;\n\thw_if->usec_to_riwt = xgbe_usec_to_riwt;\n\thw_if->riwt_to_usec = xgbe_riwt_to_usec;\n\n\t \n\thw_if->config_rx_threshold = xgbe_config_rx_threshold;\n\thw_if->config_tx_threshold = xgbe_config_tx_threshold;\n\n\t \n\thw_if->config_rsf_mode = xgbe_config_rsf_mode;\n\thw_if->config_tsf_mode = xgbe_config_tsf_mode;\n\n\t \n\thw_if->config_osp_mode = xgbe_config_osp_mode;\n\n\t \n\thw_if->tx_mmc_int = xgbe_tx_mmc_int;\n\thw_if->rx_mmc_int = xgbe_rx_mmc_int;\n\thw_if->read_mmc_stats = xgbe_read_mmc_stats;\n\n\t \n\thw_if->config_tstamp = xgbe_config_tstamp;\n\thw_if->update_tstamp_addend = xgbe_update_tstamp_addend;\n\thw_if->set_tstamp_time = xgbe_set_tstamp_time;\n\thw_if->get_tstamp_time = xgbe_get_tstamp_time;\n\thw_if->get_tx_tstamp = xgbe_get_tx_tstamp;\n\n\t \n\thw_if->config_tc = xgbe_config_tc;\n\thw_if->config_dcb_tc = xgbe_config_dcb_tc;\n\thw_if->config_dcb_pfc = xgbe_config_dcb_pfc;\n\n\t \n\thw_if->enable_rss = xgbe_enable_rss;\n\thw_if->disable_rss = xgbe_disable_rss;\n\thw_if->set_rss_hash_key = xgbe_set_rss_hash_key;\n\thw_if->set_rss_lookup_table = xgbe_set_rss_lookup_table;\n\n\t \n\thw_if->disable_ecc_ded = xgbe_disable_ecc_ded;\n\thw_if->disable_ecc_sec = xgbe_disable_ecc_sec;\n\n\t \n\thw_if->enable_vxlan = xgbe_enable_vxlan;\n\thw_if->disable_vxlan = xgbe_disable_vxlan;\n\thw_if->set_vxlan_id = xgbe_set_vxlan_id;\n\n\tDBGPR(\"<--xgbe_init_function_ptrs\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}