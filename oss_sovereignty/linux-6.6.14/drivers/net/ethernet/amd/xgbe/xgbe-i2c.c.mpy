{
  "module_name": "xgbe-i2c.c",
  "hash_id": "ba90bc3fa0760a61bf8bac1b46b2bfa39d623d8a5caaac4eb7872ecfc57642c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-i2c.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/kmod.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\n#define XGBE_ABORT_COUNT\t500\n#define XGBE_DISABLE_COUNT\t1000\n\n#define XGBE_STD_SPEED\t\t1\n\n#define XGBE_INTR_RX_FULL\tBIT(IC_RAW_INTR_STAT_RX_FULL_INDEX)\n#define XGBE_INTR_TX_EMPTY\tBIT(IC_RAW_INTR_STAT_TX_EMPTY_INDEX)\n#define XGBE_INTR_TX_ABRT\tBIT(IC_RAW_INTR_STAT_TX_ABRT_INDEX)\n#define XGBE_INTR_STOP_DET\tBIT(IC_RAW_INTR_STAT_STOP_DET_INDEX)\n#define XGBE_DEFAULT_INT_MASK\t(XGBE_INTR_RX_FULL  |\t\\\n\t\t\t\t XGBE_INTR_TX_EMPTY |\t\\\n\t\t\t\t XGBE_INTR_TX_ABRT  |\t\\\n\t\t\t\t XGBE_INTR_STOP_DET)\n\n#define XGBE_I2C_READ\t\tBIT(8)\n#define XGBE_I2C_STOP\t\tBIT(9)\n\nstatic int xgbe_i2c_abort(struct xgbe_prv_data *pdata)\n{\n\tunsigned int wait = XGBE_ABORT_COUNT;\n\n\t \n\tXI2C_IOWRITE_BITS(pdata, IC_ENABLE, EN, 1);\n\n\t \n\tXI2C_IOWRITE_BITS(pdata, IC_ENABLE, ABORT, 1);\n\n\twhile (wait--) {\n\t\tif (!XI2C_IOREAD_BITS(pdata, IC_ENABLE, ABORT))\n\t\t\treturn 0;\n\n\t\tusleep_range(500, 600);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int xgbe_i2c_set_enable(struct xgbe_prv_data *pdata, bool enable)\n{\n\tunsigned int wait = XGBE_DISABLE_COUNT;\n\tunsigned int mode = enable ? 1 : 0;\n\n\twhile (wait--) {\n\t\tXI2C_IOWRITE_BITS(pdata, IC_ENABLE, EN, mode);\n\t\tif (XI2C_IOREAD_BITS(pdata, IC_ENABLE_STATUS, EN) == mode)\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 110);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int xgbe_i2c_disable(struct xgbe_prv_data *pdata)\n{\n\tunsigned int ret;\n\n\tret = xgbe_i2c_set_enable(pdata, false);\n\tif (ret) {\n\t\t \n\t\tret = xgbe_i2c_abort(pdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = xgbe_i2c_set_enable(pdata, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int xgbe_i2c_enable(struct xgbe_prv_data *pdata)\n{\n\treturn xgbe_i2c_set_enable(pdata, true);\n}\n\nstatic void xgbe_i2c_clear_all_interrupts(struct xgbe_prv_data *pdata)\n{\n\tXI2C_IOREAD(pdata, IC_CLR_INTR);\n}\n\nstatic void xgbe_i2c_disable_interrupts(struct xgbe_prv_data *pdata)\n{\n\tXI2C_IOWRITE(pdata, IC_INTR_MASK, 0);\n}\n\nstatic void xgbe_i2c_enable_interrupts(struct xgbe_prv_data *pdata)\n{\n\tXI2C_IOWRITE(pdata, IC_INTR_MASK, XGBE_DEFAULT_INT_MASK);\n}\n\nstatic void xgbe_i2c_write(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_i2c_op_state *state = &pdata->i2c.op_state;\n\tunsigned int tx_slots;\n\tunsigned int cmd;\n\n\t \n\ttx_slots = pdata->i2c.tx_fifo_size - XI2C_IOREAD(pdata, IC_TXFLR);\n\twhile (tx_slots && state->tx_len) {\n\t\tif (state->op->cmd == XGBE_I2C_CMD_READ)\n\t\t\tcmd = XGBE_I2C_READ;\n\t\telse\n\t\t\tcmd = *state->tx_buf++;\n\n\t\tif (state->tx_len == 1)\n\t\t\tXI2C_SET_BITS(cmd, IC_DATA_CMD, STOP, 1);\n\n\t\tXI2C_IOWRITE(pdata, IC_DATA_CMD, cmd);\n\n\t\ttx_slots--;\n\t\tstate->tx_len--;\n\t}\n\n\t \n\tif (!state->tx_len)\n\t\tXI2C_IOWRITE_BITS(pdata, IC_INTR_MASK, TX_EMPTY, 0);\n}\n\nstatic void xgbe_i2c_read(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_i2c_op_state *state = &pdata->i2c.op_state;\n\tunsigned int rx_slots;\n\n\t \n\tif (state->op->cmd != XGBE_I2C_CMD_READ)\n\t\treturn;\n\n\trx_slots = XI2C_IOREAD(pdata, IC_RXFLR);\n\twhile (rx_slots && state->rx_len) {\n\t\t*state->rx_buf++ = XI2C_IOREAD(pdata, IC_DATA_CMD);\n\t\tstate->rx_len--;\n\t\trx_slots--;\n\t}\n}\n\nstatic void xgbe_i2c_clear_isr_interrupts(struct xgbe_prv_data *pdata,\n\t\t\t\t\t  unsigned int isr)\n{\n\tstruct xgbe_i2c_op_state *state = &pdata->i2c.op_state;\n\n\tif (isr & XGBE_INTR_TX_ABRT) {\n\t\tstate->tx_abort_source = XI2C_IOREAD(pdata, IC_TX_ABRT_SOURCE);\n\t\tXI2C_IOREAD(pdata, IC_CLR_TX_ABRT);\n\t}\n\n\tif (isr & XGBE_INTR_STOP_DET)\n\t\tXI2C_IOREAD(pdata, IC_CLR_STOP_DET);\n}\n\nstatic void xgbe_i2c_isr_task(struct tasklet_struct *t)\n{\n\tstruct xgbe_prv_data *pdata = from_tasklet(pdata, t, tasklet_i2c);\n\tstruct xgbe_i2c_op_state *state = &pdata->i2c.op_state;\n\tunsigned int isr;\n\n\tisr = XI2C_IOREAD(pdata, IC_RAW_INTR_STAT);\n\tif (!isr)\n\t\tgoto reissue_check;\n\n\tnetif_dbg(pdata, intr, pdata->netdev,\n\t\t  \"I2C interrupt received: status=%#010x\\n\", isr);\n\n\txgbe_i2c_clear_isr_interrupts(pdata, isr);\n\n\tif (isr & XGBE_INTR_TX_ABRT) {\n\t\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t\t  \"I2C TX_ABRT received (%#010x) for target %#04x\\n\",\n\t\t\t  state->tx_abort_source, state->op->target);\n\n\t\txgbe_i2c_disable_interrupts(pdata);\n\n\t\tstate->ret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\txgbe_i2c_read(pdata);\n\n\t \n\txgbe_i2c_write(pdata);\n\nout:\n\t \n\tif (state->ret || XI2C_GET_BITS(isr, IC_RAW_INTR_STAT, STOP_DET))\n\t\tcomplete(&pdata->i2c_complete);\n\nreissue_check:\n\t \n\tif (pdata->vdata->irq_reissue_support)\n\t\tXP_IOWRITE(pdata, XP_INT_REISSUE_EN, 1 << 2);\n}\n\nstatic irqreturn_t xgbe_i2c_isr(int irq, void *data)\n{\n\tstruct xgbe_prv_data *pdata = (struct xgbe_prv_data *)data;\n\n\tif (pdata->isr_as_tasklet)\n\t\ttasklet_schedule(&pdata->tasklet_i2c);\n\telse\n\t\txgbe_i2c_isr_task(&pdata->tasklet_i2c);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void xgbe_i2c_set_mode(struct xgbe_prv_data *pdata)\n{\n\tunsigned int reg;\n\n\treg = XI2C_IOREAD(pdata, IC_CON);\n\tXI2C_SET_BITS(reg, IC_CON, MASTER_MODE, 1);\n\tXI2C_SET_BITS(reg, IC_CON, SLAVE_DISABLE, 1);\n\tXI2C_SET_BITS(reg, IC_CON, RESTART_EN, 1);\n\tXI2C_SET_BITS(reg, IC_CON, SPEED, XGBE_STD_SPEED);\n\tXI2C_SET_BITS(reg, IC_CON, RX_FIFO_FULL_HOLD, 1);\n\tXI2C_IOWRITE(pdata, IC_CON, reg);\n}\n\nstatic void xgbe_i2c_get_features(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_i2c *i2c = &pdata->i2c;\n\tunsigned int reg;\n\n\treg = XI2C_IOREAD(pdata, IC_COMP_PARAM_1);\n\ti2c->max_speed_mode = XI2C_GET_BITS(reg, IC_COMP_PARAM_1,\n\t\t\t\t\t    MAX_SPEED_MODE);\n\ti2c->rx_fifo_size = XI2C_GET_BITS(reg, IC_COMP_PARAM_1,\n\t\t\t\t\t  RX_BUFFER_DEPTH);\n\ti2c->tx_fifo_size = XI2C_GET_BITS(reg, IC_COMP_PARAM_1,\n\t\t\t\t\t  TX_BUFFER_DEPTH);\n\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(pdata->dev, \"I2C features: %s=%u, %s=%u, %s=%u\\n\",\n\t\t\t\"MAX_SPEED_MODE\", i2c->max_speed_mode,\n\t\t\t\"RX_BUFFER_DEPTH\", i2c->rx_fifo_size,\n\t\t\t\"TX_BUFFER_DEPTH\", i2c->tx_fifo_size);\n}\n\nstatic void xgbe_i2c_set_target(struct xgbe_prv_data *pdata, unsigned int addr)\n{\n\tXI2C_IOWRITE(pdata, IC_TAR, addr);\n}\n\nstatic irqreturn_t xgbe_i2c_combined_isr(struct xgbe_prv_data *pdata)\n{\n\txgbe_i2c_isr_task(&pdata->tasklet_i2c);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xgbe_i2c_xfer(struct xgbe_prv_data *pdata, struct xgbe_i2c_op *op)\n{\n\tstruct xgbe_i2c_op_state *state = &pdata->i2c.op_state;\n\tint ret;\n\n\tmutex_lock(&pdata->i2c_mutex);\n\n\treinit_completion(&pdata->i2c_complete);\n\n\tret = xgbe_i2c_disable(pdata);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev, \"failed to disable i2c master\\n\");\n\t\tgoto unlock;\n\t}\n\n\txgbe_i2c_set_target(pdata, op->target);\n\n\tmemset(state, 0, sizeof(*state));\n\tstate->op = op;\n\tstate->tx_len = op->len;\n\tstate->tx_buf = op->buf;\n\tstate->rx_len = op->len;\n\tstate->rx_buf = op->buf;\n\n\txgbe_i2c_clear_all_interrupts(pdata);\n\tret = xgbe_i2c_enable(pdata);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev, \"failed to enable i2c master\\n\");\n\t\tgoto unlock;\n\t}\n\n\t \n\txgbe_i2c_enable_interrupts(pdata);\n\n\tif (!wait_for_completion_timeout(&pdata->i2c_complete, HZ)) {\n\t\tnetdev_err(pdata->netdev, \"i2c operation timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto disable;\n\t}\n\n\tret = state->ret;\n\tif (ret) {\n\t\tif (state->tx_abort_source & IC_TX_ABRT_7B_ADDR_NOACK)\n\t\t\tret = -ENOTCONN;\n\t\telse if (state->tx_abort_source & IC_TX_ABRT_ARB_LOST)\n\t\t\tret = -EAGAIN;\n\t}\n\ndisable:\n\txgbe_i2c_disable_interrupts(pdata);\n\txgbe_i2c_disable(pdata);\n\nunlock:\n\tmutex_unlock(&pdata->i2c_mutex);\n\n\treturn ret;\n}\n\nstatic void xgbe_i2c_stop(struct xgbe_prv_data *pdata)\n{\n\tif (!pdata->i2c.started)\n\t\treturn;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"stopping I2C\\n\");\n\n\tpdata->i2c.started = 0;\n\n\txgbe_i2c_disable_interrupts(pdata);\n\txgbe_i2c_disable(pdata);\n\txgbe_i2c_clear_all_interrupts(pdata);\n\n\tif (pdata->dev_irq != pdata->i2c_irq) {\n\t\tdevm_free_irq(pdata->dev, pdata->i2c_irq, pdata);\n\t\ttasklet_kill(&pdata->tasklet_i2c);\n\t}\n}\n\nstatic int xgbe_i2c_start(struct xgbe_prv_data *pdata)\n{\n\tint ret;\n\n\tif (pdata->i2c.started)\n\t\treturn 0;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"starting I2C\\n\");\n\n\t \n\tif (pdata->dev_irq != pdata->i2c_irq) {\n\t\ttasklet_setup(&pdata->tasklet_i2c, xgbe_i2c_isr_task);\n\n\t\tret = devm_request_irq(pdata->dev, pdata->i2c_irq,\n\t\t\t\t       xgbe_i2c_isr, 0, pdata->i2c_name,\n\t\t\t\t       pdata);\n\t\tif (ret) {\n\t\t\tnetdev_err(pdata->netdev, \"i2c irq request failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpdata->i2c.started = 1;\n\n\treturn 0;\n}\n\nstatic int xgbe_i2c_init(struct xgbe_prv_data *pdata)\n{\n\tint ret;\n\n\txgbe_i2c_disable_interrupts(pdata);\n\n\tret = xgbe_i2c_disable(pdata);\n\tif (ret) {\n\t\tdev_err(pdata->dev, \"failed to disable i2c master\\n\");\n\t\treturn ret;\n\t}\n\n\txgbe_i2c_get_features(pdata);\n\n\txgbe_i2c_set_mode(pdata);\n\n\txgbe_i2c_clear_all_interrupts(pdata);\n\n\treturn 0;\n}\n\nvoid xgbe_init_function_ptrs_i2c(struct xgbe_i2c_if *i2c_if)\n{\n\ti2c_if->i2c_init\t\t= xgbe_i2c_init;\n\n\ti2c_if->i2c_start\t\t= xgbe_i2c_start;\n\ti2c_if->i2c_stop\t\t= xgbe_i2c_stop;\n\n\ti2c_if->i2c_xfer\t\t= xgbe_i2c_xfer;\n\n\ti2c_if->i2c_isr\t\t\t= xgbe_i2c_combined_isr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}