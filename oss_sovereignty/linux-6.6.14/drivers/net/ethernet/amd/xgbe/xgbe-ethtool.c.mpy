{
  "module_name": "xgbe-ethtool.c",
  "hash_id": "ac5bcbfa991448cc2817acd81dac2ad5f48dffc0fa440af674c6f4e42264fa9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c",
  "human_readable_source": " \n\n#include <linux/spinlock.h>\n#include <linux/phy.h>\n#include <linux/net_tstamp.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\nstruct xgbe_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint stat_size;\n\tint stat_offset;\n};\n\n#define XGMAC_MMC_STAT(_string, _var)\t\t\t\t\\\n\t{ _string,\t\t\t\t\t\t\\\n\t  sizeof_field(struct xgbe_mmc_stats, _var),\t\t\\\n\t  offsetof(struct xgbe_prv_data, mmc_stats._var),\t\\\n\t}\n\n#define XGMAC_EXT_STAT(_string, _var)\t\t\t\t\\\n\t{ _string,\t\t\t\t\t\t\\\n\t  sizeof_field(struct xgbe_ext_stats, _var),\t\t\\\n\t  offsetof(struct xgbe_prv_data, ext_stats._var),\t\\\n\t}\n\nstatic const struct xgbe_stats xgbe_gstring_stats[] = {\n\tXGMAC_MMC_STAT(\"tx_bytes\", txoctetcount_gb),\n\tXGMAC_MMC_STAT(\"tx_packets\", txframecount_gb),\n\tXGMAC_MMC_STAT(\"tx_unicast_packets\", txunicastframes_gb),\n\tXGMAC_MMC_STAT(\"tx_broadcast_packets\", txbroadcastframes_gb),\n\tXGMAC_MMC_STAT(\"tx_multicast_packets\", txmulticastframes_gb),\n\tXGMAC_MMC_STAT(\"tx_vlan_packets\", txvlanframes_g),\n\tXGMAC_EXT_STAT(\"tx_vxlan_packets\", tx_vxlan_packets),\n\tXGMAC_EXT_STAT(\"tx_tso_packets\", tx_tso_packets),\n\tXGMAC_MMC_STAT(\"tx_64_byte_packets\", tx64octets_gb),\n\tXGMAC_MMC_STAT(\"tx_65_to_127_byte_packets\", tx65to127octets_gb),\n\tXGMAC_MMC_STAT(\"tx_128_to_255_byte_packets\", tx128to255octets_gb),\n\tXGMAC_MMC_STAT(\"tx_256_to_511_byte_packets\", tx256to511octets_gb),\n\tXGMAC_MMC_STAT(\"tx_512_to_1023_byte_packets\", tx512to1023octets_gb),\n\tXGMAC_MMC_STAT(\"tx_1024_to_max_byte_packets\", tx1024tomaxoctets_gb),\n\tXGMAC_MMC_STAT(\"tx_underflow_errors\", txunderflowerror),\n\tXGMAC_MMC_STAT(\"tx_pause_frames\", txpauseframes),\n\n\tXGMAC_MMC_STAT(\"rx_bytes\", rxoctetcount_gb),\n\tXGMAC_MMC_STAT(\"rx_packets\", rxframecount_gb),\n\tXGMAC_MMC_STAT(\"rx_unicast_packets\", rxunicastframes_g),\n\tXGMAC_MMC_STAT(\"rx_broadcast_packets\", rxbroadcastframes_g),\n\tXGMAC_MMC_STAT(\"rx_multicast_packets\", rxmulticastframes_g),\n\tXGMAC_MMC_STAT(\"rx_vlan_packets\", rxvlanframes_gb),\n\tXGMAC_EXT_STAT(\"rx_vxlan_packets\", rx_vxlan_packets),\n\tXGMAC_MMC_STAT(\"rx_64_byte_packets\", rx64octets_gb),\n\tXGMAC_MMC_STAT(\"rx_65_to_127_byte_packets\", rx65to127octets_gb),\n\tXGMAC_MMC_STAT(\"rx_128_to_255_byte_packets\", rx128to255octets_gb),\n\tXGMAC_MMC_STAT(\"rx_256_to_511_byte_packets\", rx256to511octets_gb),\n\tXGMAC_MMC_STAT(\"rx_512_to_1023_byte_packets\", rx512to1023octets_gb),\n\tXGMAC_MMC_STAT(\"rx_1024_to_max_byte_packets\", rx1024tomaxoctets_gb),\n\tXGMAC_MMC_STAT(\"rx_undersize_packets\", rxundersize_g),\n\tXGMAC_MMC_STAT(\"rx_oversize_packets\", rxoversize_g),\n\tXGMAC_MMC_STAT(\"rx_crc_errors\", rxcrcerror),\n\tXGMAC_MMC_STAT(\"rx_crc_errors_small_packets\", rxrunterror),\n\tXGMAC_MMC_STAT(\"rx_crc_errors_giant_packets\", rxjabbererror),\n\tXGMAC_MMC_STAT(\"rx_length_errors\", rxlengtherror),\n\tXGMAC_MMC_STAT(\"rx_out_of_range_errors\", rxoutofrangetype),\n\tXGMAC_MMC_STAT(\"rx_fifo_overflow_errors\", rxfifooverflow),\n\tXGMAC_MMC_STAT(\"rx_watchdog_errors\", rxwatchdogerror),\n\tXGMAC_EXT_STAT(\"rx_csum_errors\", rx_csum_errors),\n\tXGMAC_EXT_STAT(\"rx_vxlan_csum_errors\", rx_vxlan_csum_errors),\n\tXGMAC_MMC_STAT(\"rx_pause_frames\", rxpauseframes),\n\tXGMAC_EXT_STAT(\"rx_split_header_packets\", rx_split_header_packets),\n\tXGMAC_EXT_STAT(\"rx_buffer_unavailable\", rx_buffer_unavailable),\n};\n\n#define XGBE_STATS_COUNT\tARRAY_SIZE(xgbe_gstring_stats)\n\nstatic void xgbe_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < XGBE_STATS_COUNT; i++) {\n\t\t\tmemcpy(data, xgbe_gstring_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < pdata->tx_ring_count; i++) {\n\t\t\tsprintf(data, \"txq_%u_packets\", i);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\tsprintf(data, \"txq_%u_bytes\", i);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < pdata->rx_ring_count; i++) {\n\t\t\tsprintf(data, \"rxq_%u_packets\", i);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\tsprintf(data, \"rxq_%u_bytes\", i);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void xgbe_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tu8 *stat;\n\tint i;\n\n\tpdata->hw_if.read_mmc_stats(pdata);\n\tfor (i = 0; i < XGBE_STATS_COUNT; i++) {\n\t\tstat = (u8 *)pdata + xgbe_gstring_stats[i].stat_offset;\n\t\t*data++ = *(u64 *)stat;\n\t}\n\tfor (i = 0; i < pdata->tx_ring_count; i++) {\n\t\t*data++ = pdata->ext_stats.txq_packets[i];\n\t\t*data++ = pdata->ext_stats.txq_bytes[i];\n\t}\n\tfor (i = 0; i < pdata->rx_ring_count; i++) {\n\t\t*data++ = pdata->ext_stats.rxq_packets[i];\n\t\t*data++ = pdata->ext_stats.rxq_bytes[i];\n\t}\n}\n\nstatic int xgbe_get_sset_count(struct net_device *netdev, int stringset)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tint ret;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tret = XGBE_STATS_COUNT +\n\t\t      (pdata->tx_ring_count * 2) +\n\t\t      (pdata->rx_ring_count * 2);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic void xgbe_get_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tpause->autoneg = pdata->phy.pause_autoneg;\n\tpause->tx_pause = pdata->phy.tx_pause;\n\tpause->rx_pause = pdata->phy.rx_pause;\n}\n\nstatic int xgbe_set_pauseparam(struct net_device *netdev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tint ret = 0;\n\n\tif (pause->autoneg && (pdata->phy.autoneg != AUTONEG_ENABLE)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"autoneg disabled, pause autoneg not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdata->phy.pause_autoneg = pause->autoneg;\n\tpdata->phy.tx_pause = pause->tx_pause;\n\tpdata->phy.rx_pause = pause->rx_pause;\n\n\tXGBE_CLR_ADV(lks, Pause);\n\tXGBE_CLR_ADV(lks, Asym_Pause);\n\n\tif (pause->rx_pause) {\n\t\tXGBE_SET_ADV(lks, Pause);\n\t\tXGBE_SET_ADV(lks, Asym_Pause);\n\t}\n\n\tif (pause->tx_pause) {\n\t\t \n\t\tif (XGBE_ADV(lks, Asym_Pause))\n\t\t\tXGBE_CLR_ADV(lks, Asym_Pause);\n\t\telse\n\t\t\tXGBE_SET_ADV(lks, Asym_Pause);\n\t}\n\n\tif (netif_running(netdev))\n\t\tret = pdata->phy_if.phy_config_aneg(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\tcmd->base.phy_address = pdata->phy.address;\n\n\tif (netif_carrier_ok(netdev)) {\n\t\tcmd->base.speed = pdata->phy.speed;\n\t\tcmd->base.duplex = pdata->phy.duplex;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.autoneg = pdata->phy.autoneg;\n\tcmd->base.port = PORT_NONE;\n\n\tXGBE_LM_COPY(cmd, supported, lks, supported);\n\tXGBE_LM_COPY(cmd, advertising, lks, advertising);\n\tXGBE_LM_COPY(cmd, lp_advertising, lks, lp_advertising);\n\n\treturn 0;\n}\n\nstatic int xgbe_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);\n\tu32 speed;\n\tint ret;\n\n\tspeed = cmd->base.speed;\n\n\tif (cmd->base.phy_address != pdata->phy.address) {\n\t\tnetdev_err(netdev, \"invalid phy address %hhu\\n\",\n\t\t\t   cmd->base.phy_address);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((cmd->base.autoneg != AUTONEG_ENABLE) &&\n\t    (cmd->base.autoneg != AUTONEG_DISABLE)) {\n\t\tnetdev_err(netdev, \"unsupported autoneg %hhu\\n\",\n\t\t\t   cmd->base.autoneg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->base.autoneg == AUTONEG_DISABLE) {\n\t\tif (!pdata->phy_if.phy_valid_speed(pdata, speed)) {\n\t\t\tnetdev_err(netdev, \"unsupported speed %u\\n\", speed);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cmd->base.duplex != DUPLEX_FULL) {\n\t\t\tnetdev_err(netdev, \"unsupported duplex %hhu\\n\",\n\t\t\t\t   cmd->base.duplex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnetif_dbg(pdata, link, netdev,\n\t\t  \"requested advertisement 0x%*pb, phy supported 0x%*pb\\n\",\n\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS, cmd->link_modes.advertising,\n\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS, lks->link_modes.supported);\n\n\tlinkmode_and(advertising, cmd->link_modes.advertising,\n\t\t     lks->link_modes.supported);\n\n\tif ((cmd->base.autoneg == AUTONEG_ENABLE) &&\n\t    bitmap_empty(advertising, __ETHTOOL_LINK_MODE_MASK_NBITS)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"unsupported requested advertisement\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = 0;\n\tpdata->phy.autoneg = cmd->base.autoneg;\n\tpdata->phy.speed = speed;\n\tpdata->phy.duplex = cmd->base.duplex;\n\tlinkmode_copy(lks->link_modes.advertising, advertising);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE)\n\t\tXGBE_SET_ADV(lks, Autoneg);\n\telse\n\t\tXGBE_CLR_ADV(lks, Autoneg);\n\n\tif (netif_running(netdev))\n\t\tret = pdata->phy_if.phy_config_aneg(pdata);\n\n\treturn ret;\n}\n\nstatic void xgbe_get_drvinfo(struct net_device *netdev,\n\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tstruct xgbe_hw_features *hw_feat = &pdata->hw_feat;\n\n\tstrscpy(drvinfo->driver, XGBE_DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, dev_name(pdata->dev),\n\t\tsizeof(drvinfo->bus_info));\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), \"%d.%d.%d\",\n\t\t XGMAC_GET_BITS(hw_feat->version, MAC_VR, USERVER),\n\t\t XGMAC_GET_BITS(hw_feat->version, MAC_VR, DEVID),\n\t\t XGMAC_GET_BITS(hw_feat->version, MAC_VR, SNPSVER));\n}\n\nstatic u32 xgbe_get_msglevel(struct net_device *netdev)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\treturn pdata->msg_enable;\n}\n\nstatic void xgbe_set_msglevel(struct net_device *netdev, u32 msglevel)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tpdata->msg_enable = msglevel;\n}\n\nstatic int xgbe_get_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ec,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tmemset(ec, 0, sizeof(struct ethtool_coalesce));\n\n\tec->rx_coalesce_usecs = pdata->rx_usecs;\n\tec->rx_max_coalesced_frames = pdata->rx_frames;\n\n\tec->tx_max_coalesced_frames = pdata->tx_frames;\n\n\treturn 0;\n}\n\nstatic int xgbe_set_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ec,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tstruct xgbe_hw_if *hw_if = &pdata->hw_if;\n\tunsigned int rx_frames, rx_riwt, rx_usecs;\n\tunsigned int tx_frames;\n\n\trx_riwt = hw_if->usec_to_riwt(pdata, ec->rx_coalesce_usecs);\n\trx_usecs = ec->rx_coalesce_usecs;\n\trx_frames = ec->rx_max_coalesced_frames;\n\n\t \n\tif (rx_usecs && !rx_riwt)\n\t\trx_riwt = 1;\n\n\t \n\tif (rx_riwt > XGMAC_MAX_DMA_RIWT) {\n\t\tnetdev_err(netdev, \"rx-usec is limited to %d usecs\\n\",\n\t\t\t   hw_if->riwt_to_usec(pdata, XGMAC_MAX_DMA_RIWT));\n\t\treturn -EINVAL;\n\t}\n\tif (rx_frames > pdata->rx_desc_count) {\n\t\tnetdev_err(netdev, \"rx-frames is limited to %d frames\\n\",\n\t\t\t   pdata->rx_desc_count);\n\t\treturn -EINVAL;\n\t}\n\n\ttx_frames = ec->tx_max_coalesced_frames;\n\n\t \n\tif (tx_frames > pdata->tx_desc_count) {\n\t\tnetdev_err(netdev, \"tx-frames is limited to %d frames\\n\",\n\t\t\t   pdata->tx_desc_count);\n\t\treturn -EINVAL;\n\t}\n\n\tpdata->rx_riwt = rx_riwt;\n\tpdata->rx_usecs = rx_usecs;\n\tpdata->rx_frames = rx_frames;\n\thw_if->config_rx_coalesce(pdata);\n\n\tpdata->tx_frames = tx_frames;\n\thw_if->config_tx_coalesce(pdata);\n\n\treturn 0;\n}\n\nstatic int xgbe_get_rxnfc(struct net_device *netdev,\n\t\t\t  struct ethtool_rxnfc *rxnfc, u32 *rule_locs)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\trxnfc->data = pdata->rx_ring_count;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 xgbe_get_rxfh_key_size(struct net_device *netdev)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\treturn sizeof(pdata->rss_key);\n}\n\nstatic u32 xgbe_get_rxfh_indir_size(struct net_device *netdev)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\treturn ARRAY_SIZE(pdata->rss_table);\n}\n\nstatic int xgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t u8 *hfunc)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tunsigned int i;\n\n\tif (indir) {\n\t\tfor (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)\n\t\t\tindir[i] = XGMAC_GET_BITS(pdata->rss_table[i],\n\t\t\t\t\t\t  MAC_RSSDR, DMCH);\n\t}\n\n\tif (key)\n\t\tmemcpy(key, pdata->rss_key, sizeof(pdata->rss_key));\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\treturn 0;\n}\n\nstatic int xgbe_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\t const u8 *key, const u8 hfunc)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tstruct xgbe_hw_if *hw_if = &pdata->hw_if;\n\tunsigned int ret;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP) {\n\t\tnetdev_err(netdev, \"unsupported hash function\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (indir) {\n\t\tret = hw_if->set_rss_lookup_table(pdata, indir);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (key) {\n\t\tret = hw_if->set_rss_hash_key(pdata, key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_get_ts_info(struct net_device *netdev,\n\t\t\t    struct ethtool_ts_info *ts_info)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t   SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t   SOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\t   SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t   SOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t   SOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tif (pdata->ptp_clock)\n\t\tts_info->phc_index = ptp_clock_index(pdata->ptp_clock);\n\telse\n\t\tts_info->phc_index = -1;\n\n\tts_info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\n\tts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\n\t\t\t      (1 << HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic int xgbe_get_module_info(struct net_device *netdev,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\treturn pdata->phy_if.module_info(pdata, modinfo);\n}\n\nstatic int xgbe_get_module_eeprom(struct net_device *netdev,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\treturn pdata->phy_if.module_eeprom(pdata, eeprom, data);\n}\n\nstatic void\nxgbe_get_ringparam(struct net_device *netdev,\n\t\t   struct ethtool_ringparam *ringparam,\n\t\t   struct kernel_ethtool_ringparam *kernel_ringparam,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tringparam->rx_max_pending = XGBE_RX_DESC_CNT_MAX;\n\tringparam->tx_max_pending = XGBE_TX_DESC_CNT_MAX;\n\tringparam->rx_pending = pdata->rx_desc_count;\n\tringparam->tx_pending = pdata->tx_desc_count;\n}\n\nstatic int xgbe_set_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ringparam,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ringparam,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tunsigned int rx, tx;\n\n\tif (ringparam->rx_mini_pending || ringparam->rx_jumbo_pending) {\n\t\tnetdev_err(netdev, \"unsupported ring parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ringparam->rx_pending < XGBE_RX_DESC_CNT_MIN) ||\n\t    (ringparam->rx_pending > XGBE_RX_DESC_CNT_MAX)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"rx ring parameter must be between %u and %u\\n\",\n\t\t\t   XGBE_RX_DESC_CNT_MIN, XGBE_RX_DESC_CNT_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ringparam->tx_pending < XGBE_TX_DESC_CNT_MIN) ||\n\t    (ringparam->tx_pending > XGBE_TX_DESC_CNT_MAX)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"tx ring parameter must be between %u and %u\\n\",\n\t\t\t   XGBE_TX_DESC_CNT_MIN, XGBE_TX_DESC_CNT_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\trx = __rounddown_pow_of_two(ringparam->rx_pending);\n\tif (rx != ringparam->rx_pending)\n\t\tnetdev_notice(netdev,\n\t\t\t      \"rx ring parameter rounded to power of two: %u\\n\",\n\t\t\t      rx);\n\n\ttx = __rounddown_pow_of_two(ringparam->tx_pending);\n\tif (tx != ringparam->tx_pending)\n\t\tnetdev_notice(netdev,\n\t\t\t      \"tx ring parameter rounded to power of two: %u\\n\",\n\t\t\t      tx);\n\n\tif ((rx == pdata->rx_desc_count) &&\n\t    (tx == pdata->tx_desc_count))\n\t\tgoto out;\n\n\tpdata->rx_desc_count = rx;\n\tpdata->tx_desc_count = tx;\n\n\txgbe_restart_dev(pdata);\n\nout:\n\treturn 0;\n}\n\nstatic void xgbe_get_channels(struct net_device *netdev,\n\t\t\t      struct ethtool_channels *channels)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tunsigned int rx, tx, combined;\n\n\t \n\trx = min(pdata->hw_feat.rx_ch_cnt, pdata->rx_max_channel_count);\n\trx = min(rx, pdata->channel_irq_count);\n\ttx = min(pdata->hw_feat.tx_ch_cnt, pdata->tx_max_channel_count);\n\ttx = min(tx, pdata->channel_irq_count);\n\ttx = min(tx, pdata->tx_max_q_count);\n\n\tcombined = min(rx, tx);\n\n\tchannels->max_combined = combined;\n\tchannels->max_rx = rx ? rx - 1 : 0;\n\tchannels->max_tx = tx ? tx - 1 : 0;\n\n\t \n\trx = pdata->new_rx_ring_count ? : pdata->rx_ring_count;\n\ttx = pdata->new_tx_ring_count ? : pdata->tx_ring_count;\n\n\tcombined = min(rx, tx);\n\trx -= combined;\n\ttx -= combined;\n\n\tchannels->combined_count = combined;\n\tchannels->rx_count = rx;\n\tchannels->tx_count = tx;\n}\n\nstatic void xgbe_print_set_channels_input(struct net_device *netdev,\n\t\t\t\t\t  struct ethtool_channels *channels)\n{\n\tnetdev_err(netdev, \"channel inputs: combined=%u, rx-only=%u, tx-only=%u\\n\",\n\t\t   channels->combined_count, channels->rx_count,\n\t\t   channels->tx_count);\n}\n\nstatic int xgbe_set_channels(struct net_device *netdev,\n\t\t\t     struct ethtool_channels *channels)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tunsigned int rx, rx_curr, tx, tx_curr, combined;\n\n\t \n\trx = min(pdata->hw_feat.rx_ch_cnt, pdata->rx_max_channel_count);\n\trx = min(rx, pdata->channel_irq_count);\n\ttx = min(pdata->hw_feat.tx_ch_cnt, pdata->tx_max_channel_count);\n\ttx = min(tx, pdata->tx_max_q_count);\n\ttx = min(tx, pdata->channel_irq_count);\n\n\tcombined = min(rx, tx);\n\n\t \n\tif (channels->other_count) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"other channel count must be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!channels->combined_count) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"at least one combined Rx/Tx channel is required\\n\");\n\t\txgbe_print_set_channels_input(netdev, channels);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (channels->combined_count > combined) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"combined channel count cannot exceed %u\\n\",\n\t\t\t   combined);\n\t\txgbe_print_set_channels_input(netdev, channels);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (channels->rx_count && channels->tx_count) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"cannot specify both Rx-only and Tx-only channels\\n\");\n\t\txgbe_print_set_channels_input(netdev, channels);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((channels->combined_count + channels->rx_count) > rx) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"total Rx channels (%u) requested exceeds maximum available (%u)\\n\",\n\t\t\t   channels->combined_count + channels->rx_count, rx);\n\t\txgbe_print_set_channels_input(netdev, channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((channels->combined_count + channels->tx_count) > tx) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"total Tx channels (%u) requested exceeds maximum available (%u)\\n\",\n\t\t\t   channels->combined_count + channels->tx_count, tx);\n\t\txgbe_print_set_channels_input(netdev, channels);\n\t\treturn -EINVAL;\n\t}\n\n\trx = channels->combined_count + channels->rx_count;\n\ttx = channels->combined_count + channels->tx_count;\n\n\trx_curr = pdata->new_rx_ring_count ? : pdata->rx_ring_count;\n\ttx_curr = pdata->new_tx_ring_count ? : pdata->tx_ring_count;\n\n\tif ((rx == rx_curr) && (tx == tx_curr))\n\t\tgoto out;\n\n\tpdata->new_rx_ring_count = rx;\n\tpdata->new_tx_ring_count = tx;\n\n\txgbe_full_restart_dev(pdata);\n\nout:\n\treturn 0;\n}\n\nstatic const struct ethtool_ops xgbe_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_drvinfo = xgbe_get_drvinfo,\n\t.get_msglevel = xgbe_get_msglevel,\n\t.set_msglevel = xgbe_set_msglevel,\n\t.get_link = ethtool_op_get_link,\n\t.get_coalesce = xgbe_get_coalesce,\n\t.set_coalesce = xgbe_set_coalesce,\n\t.get_pauseparam = xgbe_get_pauseparam,\n\t.set_pauseparam = xgbe_set_pauseparam,\n\t.get_strings = xgbe_get_strings,\n\t.get_ethtool_stats = xgbe_get_ethtool_stats,\n\t.get_sset_count = xgbe_get_sset_count,\n\t.get_rxnfc = xgbe_get_rxnfc,\n\t.get_rxfh_key_size = xgbe_get_rxfh_key_size,\n\t.get_rxfh_indir_size = xgbe_get_rxfh_indir_size,\n\t.get_rxfh = xgbe_get_rxfh,\n\t.set_rxfh = xgbe_set_rxfh,\n\t.get_ts_info = xgbe_get_ts_info,\n\t.get_link_ksettings = xgbe_get_link_ksettings,\n\t.set_link_ksettings = xgbe_set_link_ksettings,\n\t.get_module_info = xgbe_get_module_info,\n\t.get_module_eeprom = xgbe_get_module_eeprom,\n\t.get_ringparam = xgbe_get_ringparam,\n\t.set_ringparam = xgbe_set_ringparam,\n\t.get_channels = xgbe_get_channels,\n\t.set_channels = xgbe_set_channels,\n};\n\nconst struct ethtool_ops *xgbe_get_ethtool_ops(void)\n{\n\treturn &xgbe_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}