{
  "module_name": "xgbe-pci.c",
  "hash_id": "0a67f94182f0b44d846f96c4dea2aaf8d6e216a5fd96881990ff2cb2bfb89f20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-pci.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/log2.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\nstatic int xgbe_config_multi_msi(struct xgbe_prv_data *pdata)\n{\n\tunsigned int vector_count;\n\tunsigned int i, j;\n\tint ret;\n\n\tvector_count = XGBE_MSI_BASE_COUNT;\n\tvector_count += max(pdata->rx_ring_count,\n\t\t\t    pdata->tx_ring_count);\n\n\tret = pci_alloc_irq_vectors(pdata->pcidev, XGBE_MSI_MIN_COUNT,\n\t\t\t\t    vector_count, PCI_IRQ_MSI | PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdev_info(pdata->dev, \"multi MSI/MSI-X enablement failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->isr_as_tasklet = 1;\n\tpdata->irq_count = ret;\n\n\tpdata->dev_irq = pci_irq_vector(pdata->pcidev, 0);\n\tpdata->ecc_irq = pci_irq_vector(pdata->pcidev, 1);\n\tpdata->i2c_irq = pci_irq_vector(pdata->pcidev, 2);\n\tpdata->an_irq = pci_irq_vector(pdata->pcidev, 3);\n\n\tfor (i = XGBE_MSI_BASE_COUNT, j = 0; i < ret; i++, j++)\n\t\tpdata->channel_irq[j] = pci_irq_vector(pdata->pcidev, i);\n\tpdata->channel_irq_count = j;\n\n\tpdata->per_channel_irq = 1;\n\tpdata->channel_irq_mode = XGBE_IRQ_MODE_LEVEL;\n\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(pdata->dev, \"multi %s interrupts enabled\\n\",\n\t\t\tpdata->pcidev->msix_enabled ? \"MSI-X\" : \"MSI\");\n\n\treturn 0;\n}\n\nstatic int xgbe_config_irqs(struct xgbe_prv_data *pdata)\n{\n\tint ret;\n\n\tret = xgbe_config_multi_msi(pdata);\n\tif (!ret)\n\t\tgoto out;\n\n\tret = pci_alloc_irq_vectors(pdata->pcidev, 1, 1,\n\t\t\t\t    PCI_IRQ_LEGACY | PCI_IRQ_MSI);\n\tif (ret < 0) {\n\t\tdev_info(pdata->dev, \"single IRQ enablement failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->isr_as_tasklet = pdata->pcidev->msi_enabled ? 1 : 0;\n\tpdata->irq_count = 1;\n\tpdata->channel_irq_count = 1;\n\n\tpdata->dev_irq = pci_irq_vector(pdata->pcidev, 0);\n\tpdata->ecc_irq = pci_irq_vector(pdata->pcidev, 0);\n\tpdata->i2c_irq = pci_irq_vector(pdata->pcidev, 0);\n\tpdata->an_irq = pci_irq_vector(pdata->pcidev, 0);\n\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(pdata->dev, \"single %s interrupt enabled\\n\",\n\t\t\tpdata->pcidev->msi_enabled ?  \"MSI\" : \"legacy\");\n\nout:\n\tif (netif_msg_probe(pdata)) {\n\t\tunsigned int i;\n\n\t\tdev_dbg(pdata->dev, \" dev irq=%d\\n\", pdata->dev_irq);\n\t\tdev_dbg(pdata->dev, \" ecc irq=%d\\n\", pdata->ecc_irq);\n\t\tdev_dbg(pdata->dev, \" i2c irq=%d\\n\", pdata->i2c_irq);\n\t\tdev_dbg(pdata->dev, \"  an irq=%d\\n\", pdata->an_irq);\n\t\tfor (i = 0; i < pdata->channel_irq_count; i++)\n\t\t\tdev_dbg(pdata->dev, \" dma%u irq=%d\\n\",\n\t\t\t\ti, pdata->channel_irq[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct xgbe_prv_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem * const *iomap_table;\n\tstruct pci_dev *rdev;\n\tunsigned int ma_lo, ma_hi;\n\tunsigned int reg;\n\tint bar_mask;\n\tint ret;\n\n\tpdata = xgbe_alloc_pdata(dev);\n\tif (IS_ERR(pdata)) {\n\t\tret = PTR_ERR(pdata);\n\t\tgoto err_alloc;\n\t}\n\n\tpdata->pcidev = pdev;\n\tpci_set_drvdata(pdev, pdata);\n\n\t \n\tpdata->vdata = (struct xgbe_version_data *)id->driver_data;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"pcim_enable_device failed\\n\");\n\t\tgoto err_pci_enable;\n\t}\n\n\t \n\tbar_mask = pci_select_bars(pdev, IORESOURCE_MEM);\n\tret = pcim_iomap_regions(pdev, bar_mask, XGBE_DRV_NAME);\n\tif (ret) {\n\t\tdev_err(dev, \"pcim_iomap_regions failed\\n\");\n\t\tgoto err_pci_enable;\n\t}\n\n\tiomap_table = pcim_iomap_table(pdev);\n\tif (!iomap_table) {\n\t\tdev_err(dev, \"pcim_iomap_table failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_enable;\n\t}\n\n\tpdata->xgmac_regs = iomap_table[XGBE_XGMAC_BAR];\n\tif (!pdata->xgmac_regs) {\n\t\tdev_err(dev, \"xgmac ioremap failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_enable;\n\t}\n\tpdata->xprop_regs = pdata->xgmac_regs + XGBE_MAC_PROP_OFFSET;\n\tpdata->xi2c_regs = pdata->xgmac_regs + XGBE_I2C_CTRL_OFFSET;\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(dev, \"xgmac_regs = %p\\n\", pdata->xgmac_regs);\n\t\tdev_dbg(dev, \"xprop_regs = %p\\n\", pdata->xprop_regs);\n\t\tdev_dbg(dev, \"xi2c_regs  = %p\\n\", pdata->xi2c_regs);\n\t}\n\n\tpdata->xpcs_regs = iomap_table[XGBE_XPCS_BAR];\n\tif (!pdata->xpcs_regs) {\n\t\tdev_err(dev, \"xpcs ioremap failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_enable;\n\t}\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(dev, \"xpcs_regs  = %p\\n\", pdata->xpcs_regs);\n\n\t \n\trdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\n\tif (rdev &&\n\t    (rdev->vendor == PCI_VENDOR_ID_AMD) && (rdev->device == 0x15d0)) {\n\t\tpdata->xpcs_window_def_reg = PCS_V2_RV_WINDOW_DEF;\n\t\tpdata->xpcs_window_sel_reg = PCS_V2_RV_WINDOW_SELECT;\n\t} else if (rdev && (rdev->vendor == PCI_VENDOR_ID_AMD) &&\n\t\t   (rdev->device == 0x14b5)) {\n\t\tpdata->xpcs_window_def_reg = PCS_V2_YC_WINDOW_DEF;\n\t\tpdata->xpcs_window_sel_reg = PCS_V2_YC_WINDOW_SELECT;\n\n\t\t \n\t\tpdata->vdata->an_cdr_workaround = 0;\n\n\t\t \n\t\tpdata->vdata->enable_rrc = 0;\n\t} else {\n\t\tpdata->xpcs_window_def_reg = PCS_V2_WINDOW_DEF;\n\t\tpdata->xpcs_window_sel_reg = PCS_V2_WINDOW_SELECT;\n\t}\n\tpci_dev_put(rdev);\n\n\t \n\treg = XPCS32_IOREAD(pdata, pdata->xpcs_window_def_reg);\n\tpdata->xpcs_window = XPCS_GET_BITS(reg, PCS_V2_WINDOW_DEF, OFFSET);\n\tpdata->xpcs_window <<= 6;\n\tpdata->xpcs_window_size = XPCS_GET_BITS(reg, PCS_V2_WINDOW_DEF, SIZE);\n\tpdata->xpcs_window_size = 1 << (pdata->xpcs_window_size + 7);\n\tpdata->xpcs_window_mask = pdata->xpcs_window_size - 1;\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(dev, \"xpcs window def  = %#010x\\n\",\n\t\t\tpdata->xpcs_window_def_reg);\n\t\tdev_dbg(dev, \"xpcs window sel  = %#010x\\n\",\n\t\t\tpdata->xpcs_window_sel_reg);\n\t\tdev_dbg(dev, \"xpcs window      = %#010x\\n\",\n\t\t\tpdata->xpcs_window);\n\t\tdev_dbg(dev, \"xpcs window size = %#010x\\n\",\n\t\t\tpdata->xpcs_window_size);\n\t\tdev_dbg(dev, \"xpcs window mask = %#010x\\n\",\n\t\t\tpdata->xpcs_window_mask);\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tXP_IOWRITE(pdata, XP_INT_EN, 0x1fffff);\n\n\t \n\tma_lo = XP_IOREAD(pdata, XP_MAC_ADDR_LO);\n\tma_hi = XP_IOREAD(pdata, XP_MAC_ADDR_HI);\n\tpdata->mac_addr[0] = ma_lo & 0xff;\n\tpdata->mac_addr[1] = (ma_lo >> 8) & 0xff;\n\tpdata->mac_addr[2] = (ma_lo >> 16) & 0xff;\n\tpdata->mac_addr[3] = (ma_lo >> 24) & 0xff;\n\tpdata->mac_addr[4] = ma_hi & 0xff;\n\tpdata->mac_addr[5] = (ma_hi >> 8) & 0xff;\n\tif (!XP_GET_BITS(ma_hi, XP_MAC_ADDR_HI, VALID) ||\n\t    !is_valid_ether_addr(pdata->mac_addr)) {\n\t\tdev_err(dev, \"invalid mac address\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_pci_enable;\n\t}\n\n\t \n\tpdata->sysclk_rate = XGBE_V2_DMA_CLOCK_FREQ;\n\tpdata->ptpclk_rate = XGBE_V2_PTP_CLOCK_FREQ;\n\n\t \n\tpdata->coherent = 1;\n\tpdata->arcr = XGBE_DMA_PCI_ARCR;\n\tpdata->awcr = XGBE_DMA_PCI_AWCR;\n\tpdata->awarcr = XGBE_DMA_PCI_AWARCR;\n\n\t \n\tpdata->pp0 = XP_IOREAD(pdata, XP_PROP_0);\n\tpdata->pp1 = XP_IOREAD(pdata, XP_PROP_1);\n\tpdata->pp2 = XP_IOREAD(pdata, XP_PROP_2);\n\tpdata->pp3 = XP_IOREAD(pdata, XP_PROP_3);\n\tpdata->pp4 = XP_IOREAD(pdata, XP_PROP_4);\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(dev, \"port property 0 = %#010x\\n\", pdata->pp0);\n\t\tdev_dbg(dev, \"port property 1 = %#010x\\n\", pdata->pp1);\n\t\tdev_dbg(dev, \"port property 2 = %#010x\\n\", pdata->pp2);\n\t\tdev_dbg(dev, \"port property 3 = %#010x\\n\", pdata->pp3);\n\t\tdev_dbg(dev, \"port property 4 = %#010x\\n\", pdata->pp4);\n\t}\n\n\t \n\tpdata->tx_max_channel_count = XP_GET_BITS(pdata->pp1, XP_PROP_1,\n\t\t\t\t\t\t  MAX_TX_DMA);\n\tpdata->rx_max_channel_count = XP_GET_BITS(pdata->pp1, XP_PROP_1,\n\t\t\t\t\t\t  MAX_RX_DMA);\n\tpdata->tx_max_q_count = XP_GET_BITS(pdata->pp1, XP_PROP_1,\n\t\t\t\t\t    MAX_TX_QUEUES);\n\tpdata->rx_max_q_count = XP_GET_BITS(pdata->pp1, XP_PROP_1,\n\t\t\t\t\t    MAX_RX_QUEUES);\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(dev, \"max tx/rx channel count = %u/%u\\n\",\n\t\t\tpdata->tx_max_channel_count,\n\t\t\tpdata->rx_max_channel_count);\n\t\tdev_dbg(dev, \"max tx/rx hw queue count = %u/%u\\n\",\n\t\t\tpdata->tx_max_q_count, pdata->rx_max_q_count);\n\t}\n\n\t \n\txgbe_set_counts(pdata);\n\n\t \n\tpdata->tx_max_fifo_size = XP_GET_BITS(pdata->pp2, XP_PROP_2,\n\t\t\t\t\t      TX_FIFO_SIZE);\n\tpdata->tx_max_fifo_size *= 16384;\n\tpdata->tx_max_fifo_size = min(pdata->tx_max_fifo_size,\n\t\t\t\t      pdata->vdata->tx_max_fifo_size);\n\tpdata->rx_max_fifo_size = XP_GET_BITS(pdata->pp2, XP_PROP_2,\n\t\t\t\t\t      RX_FIFO_SIZE);\n\tpdata->rx_max_fifo_size *= 16384;\n\tpdata->rx_max_fifo_size = min(pdata->rx_max_fifo_size,\n\t\t\t\t      pdata->vdata->rx_max_fifo_size);\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(dev, \"max tx/rx max fifo size = %u/%u\\n\",\n\t\t\tpdata->tx_max_fifo_size, pdata->rx_max_fifo_size);\n\n\t \n\tret = xgbe_config_irqs(pdata);\n\tif (ret)\n\t\tgoto err_pci_enable;\n\n\t \n\tret = xgbe_config_netdev(pdata);\n\tif (ret)\n\t\tgoto err_irq_vectors;\n\n\tnetdev_notice(pdata->netdev, \"net device enabled\\n\");\n\n\treturn 0;\n\nerr_irq_vectors:\n\tpci_free_irq_vectors(pdata->pcidev);\n\nerr_pci_enable:\n\txgbe_free_pdata(pdata);\n\nerr_alloc:\n\tdev_notice(dev, \"net device not enabled\\n\");\n\n\treturn ret;\n}\n\nstatic void xgbe_pci_remove(struct pci_dev *pdev)\n{\n\tstruct xgbe_prv_data *pdata = pci_get_drvdata(pdev);\n\n\txgbe_deconfig_netdev(pdata);\n\n\tpci_free_irq_vectors(pdata->pcidev);\n\n\t \n\tXP_IOWRITE(pdata, XP_INT_EN, 0x0);\n\n\txgbe_free_pdata(pdata);\n}\n\nstatic int __maybe_unused xgbe_pci_suspend(struct device *dev)\n{\n\tstruct xgbe_prv_data *pdata = dev_get_drvdata(dev);\n\tstruct net_device *netdev = pdata->netdev;\n\tint ret = 0;\n\n\tif (netif_running(netdev))\n\t\tret = xgbe_powerdown(netdev, XGMAC_DRIVER_CONTEXT);\n\n\tpdata->lpm_ctrl = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\n\tpdata->lpm_ctrl |= MDIO_CTRL1_LPOWER;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused xgbe_pci_resume(struct device *dev)\n{\n\tstruct xgbe_prv_data *pdata = dev_get_drvdata(dev);\n\tstruct net_device *netdev = pdata->netdev;\n\tint ret = 0;\n\n\tXP_IOWRITE(pdata, XP_INT_EN, 0x1fffff);\n\n\tpdata->lpm_ctrl &= ~MDIO_CTRL1_LPOWER;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\n\n\tif (netif_running(netdev)) {\n\t\tret = xgbe_powerup(netdev, XGMAC_DRIVER_CONTEXT);\n\n\t\t \n\t\tschedule_work(&pdata->restart_work);\n\t}\n\n\treturn ret;\n}\n\nstatic struct xgbe_version_data xgbe_v2a = {\n\t.init_function_ptrs_phy_impl\t= xgbe_init_function_ptrs_phy_v2,\n\t.xpcs_access\t\t\t= XGBE_XPCS_ACCESS_V2,\n\t.mmc_64bit\t\t\t= 1,\n\t.tx_max_fifo_size\t\t= 229376,\n\t.rx_max_fifo_size\t\t= 229376,\n\t.tx_tstamp_workaround\t\t= 1,\n\t.ecc_support\t\t\t= 1,\n\t.i2c_support\t\t\t= 1,\n\t.irq_reissue_support\t\t= 1,\n\t.tx_desc_prefetch\t\t= 5,\n\t.rx_desc_prefetch\t\t= 5,\n\t.an_cdr_workaround\t\t= 1,\n\t.enable_rrc\t\t\t= 1,\n};\n\nstatic struct xgbe_version_data xgbe_v2b = {\n\t.init_function_ptrs_phy_impl\t= xgbe_init_function_ptrs_phy_v2,\n\t.xpcs_access\t\t\t= XGBE_XPCS_ACCESS_V2,\n\t.mmc_64bit\t\t\t= 1,\n\t.tx_max_fifo_size\t\t= 65536,\n\t.rx_max_fifo_size\t\t= 65536,\n\t.tx_tstamp_workaround\t\t= 1,\n\t.ecc_support\t\t\t= 1,\n\t.i2c_support\t\t\t= 1,\n\t.irq_reissue_support\t\t= 1,\n\t.tx_desc_prefetch\t\t= 5,\n\t.rx_desc_prefetch\t\t= 5,\n\t.an_cdr_workaround\t\t= 1,\n\t.enable_rrc\t\t\t= 1,\n};\n\nstatic const struct pci_device_id xgbe_pci_table[] = {\n\t{ PCI_VDEVICE(AMD, 0x1458),\n\t  .driver_data = (kernel_ulong_t)&xgbe_v2a },\n\t{ PCI_VDEVICE(AMD, 0x1459),\n\t  .driver_data = (kernel_ulong_t)&xgbe_v2b },\n\t \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, xgbe_pci_table);\n\nstatic SIMPLE_DEV_PM_OPS(xgbe_pci_pm_ops, xgbe_pci_suspend, xgbe_pci_resume);\n\nstatic struct pci_driver xgbe_driver = {\n\t.name = XGBE_DRV_NAME,\n\t.id_table = xgbe_pci_table,\n\t.probe = xgbe_pci_probe,\n\t.remove = xgbe_pci_remove,\n\t.driver = {\n\t\t.pm = &xgbe_pci_pm_ops,\n\t}\n};\n\nint xgbe_pci_init(void)\n{\n\treturn pci_register_driver(&xgbe_driver);\n}\n\nvoid xgbe_pci_exit(void)\n{\n\tpci_unregister_driver(&xgbe_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}