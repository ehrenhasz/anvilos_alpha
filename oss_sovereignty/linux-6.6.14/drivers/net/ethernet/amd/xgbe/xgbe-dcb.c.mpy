{
  "module_name": "xgbe-dcb.c",
  "hash_id": "8407c50d417e17838b2013446257d1f74beb9e7e83b4d6f01ff57351e4b5258a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-dcb.c",
  "human_readable_source": " \n\n#include <linux/netdevice.h>\n#include <net/dcbnl.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\nstatic int xgbe_dcb_ieee_getets(struct net_device *netdev,\n\t\t\t\tstruct ieee_ets *ets)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\t \n\tets->ets_cap = pdata->hw_feat.tc_cnt;\n\n\tif (pdata->ets) {\n\t\tets->cbs = pdata->ets->cbs;\n\t\tmemcpy(ets->tc_tx_bw, pdata->ets->tc_tx_bw,\n\t\t       sizeof(ets->tc_tx_bw));\n\t\tmemcpy(ets->tc_tsa, pdata->ets->tc_tsa,\n\t\t       sizeof(ets->tc_tsa));\n\t\tmemcpy(ets->prio_tc, pdata->ets->prio_tc,\n\t\t       sizeof(ets->prio_tc));\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_dcb_ieee_setets(struct net_device *netdev,\n\t\t\t\tstruct ieee_ets *ets)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tunsigned int i, tc_ets, tc_ets_weight;\n\tu8 max_tc = 0;\n\n\ttc_ets = 0;\n\ttc_ets_weight = 0;\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tnetif_dbg(pdata, drv, netdev,\n\t\t\t  \"TC%u: tx_bw=%hhu, rx_bw=%hhu, tsa=%hhu\\n\", i,\n\t\t\t  ets->tc_tx_bw[i], ets->tc_rx_bw[i],\n\t\t\t  ets->tc_tsa[i]);\n\t\tnetif_dbg(pdata, drv, netdev, \"PRIO%u: TC=%hhu\\n\", i,\n\t\t\t  ets->prio_tc[i]);\n\n\t\tmax_tc = max_t(u8, max_tc, ets->prio_tc[i]);\n\t\tif ((ets->tc_tx_bw[i] || ets->tc_tsa[i]))\n\t\t\tmax_tc = max_t(u8, max_tc, i);\n\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\ttc_ets = 1;\n\t\t\ttc_ets_weight += ets->tc_tx_bw[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_err(pdata, drv, netdev,\n\t\t\t\t  \"unsupported TSA algorithm (%hhu)\\n\",\n\t\t\t\t  ets->tc_tsa[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (max_tc >= pdata->hw_feat.tc_cnt) {\n\t\tnetif_err(pdata, drv, netdev,\n\t\t\t  \"exceeded number of supported traffic classes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (tc_ets && (tc_ets_weight != 100)) {\n\t\tnetif_err(pdata, drv, netdev,\n\t\t\t  \"sum of ETS algorithm weights is not 100 (%u)\\n\",\n\t\t\t  tc_ets_weight);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata->ets) {\n\t\tpdata->ets = devm_kzalloc(pdata->dev, sizeof(*pdata->ets),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pdata->ets)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpdata->num_tcs = max_tc + 1;\n\tmemcpy(pdata->ets, ets, sizeof(*pdata->ets));\n\n\tpdata->hw_if.config_dcb_tc(pdata);\n\n\treturn 0;\n}\n\nstatic int xgbe_dcb_ieee_getpfc(struct net_device *netdev,\n\t\t\t\tstruct ieee_pfc *pfc)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\t \n\tpfc->pfc_cap = pdata->hw_feat.tc_cnt;\n\n\tif (pdata->pfc) {\n\t\tpfc->pfc_en = pdata->pfc->pfc_en;\n\t\tpfc->mbc = pdata->pfc->mbc;\n\t\tpfc->delay = pdata->pfc->delay;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgbe_dcb_ieee_setpfc(struct net_device *netdev,\n\t\t\t\tstruct ieee_pfc *pfc)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\n\tnetif_dbg(pdata, drv, netdev,\n\t\t  \"cap=%d, en=%#x, mbc=%d, delay=%d\\n\",\n\t\t  pfc->pfc_cap, pfc->pfc_en, pfc->mbc, pfc->delay);\n\n\t \n\tif (pfc->pfc_en & ~((1 << pdata->hw_feat.tc_cnt) - 1)) {\n\t\tnetif_err(pdata, drv, netdev,\n\t\t\t  \"PFC requested for unsupported traffic class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata->pfc) {\n\t\tpdata->pfc = devm_kzalloc(pdata->dev, sizeof(*pdata->pfc),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pdata->pfc)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(pdata->pfc, pfc, sizeof(*pdata->pfc));\n\n\tpdata->hw_if.config_dcb_pfc(pdata);\n\n\treturn 0;\n}\n\nstatic u8 xgbe_dcb_getdcbx(struct net_device *netdev)\n{\n\treturn DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;\n}\n\nstatic u8 xgbe_dcb_setdcbx(struct net_device *netdev, u8 dcbx)\n{\n\tstruct xgbe_prv_data *pdata = netdev_priv(netdev);\n\tu8 support = xgbe_dcb_getdcbx(netdev);\n\n\tnetif_dbg(pdata, drv, netdev, \"DCBX=%#hhx\\n\", dcbx);\n\n\tif (dcbx & ~support)\n\t\treturn 1;\n\n\tif ((dcbx & support) != support)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct dcbnl_rtnl_ops xgbe_dcbnl_ops = {\n\t \n\t.ieee_getets = xgbe_dcb_ieee_getets,\n\t.ieee_setets = xgbe_dcb_ieee_setets,\n\t.ieee_getpfc = xgbe_dcb_ieee_getpfc,\n\t.ieee_setpfc = xgbe_dcb_ieee_setpfc,\n\n\t \n\t.getdcbx     = xgbe_dcb_getdcbx,\n\t.setdcbx     = xgbe_dcb_setdcbx,\n};\n\nconst struct dcbnl_rtnl_ops *xgbe_get_dcbnl_ops(void)\n{\n\treturn &xgbe_dcbnl_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}