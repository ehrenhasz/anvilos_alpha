{
  "module_name": "xgbe-mdio.c",
  "hash_id": "4f2e48a2dc5130f006cc6cfdb792731e75f724c587f7f2653e45b752a431da94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/mdio.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\nstatic int xgbe_phy_module_eeprom(struct xgbe_prv_data *pdata,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tif (!pdata->phy_if.phy_impl.module_eeprom)\n\t\treturn -ENXIO;\n\n\treturn pdata->phy_if.phy_impl.module_eeprom(pdata, eeprom, data);\n}\n\nstatic int xgbe_phy_module_info(struct xgbe_prv_data *pdata,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n\tif (!pdata->phy_if.phy_impl.module_info)\n\t\treturn -ENXIO;\n\n\treturn pdata->phy_if.phy_impl.module_info(pdata, modinfo);\n}\n\nstatic void xgbe_an37_clear_interrupts(struct xgbe_prv_data *pdata)\n{\n\tint reg;\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);\n\treg &= ~XGBE_AN_CL37_INT_MASK;\n\tXMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);\n}\n\nstatic void xgbe_an37_disable_interrupts(struct xgbe_prv_data *pdata)\n{\n\tint reg;\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);\n\treg &= ~XGBE_AN_CL37_INT_MASK;\n\tXMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);\n\treg &= ~XGBE_PCS_CL37_BP;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);\n}\n\nstatic void xgbe_an37_enable_interrupts(struct xgbe_prv_data *pdata)\n{\n\tint reg;\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);\n\treg |= XGBE_PCS_CL37_BP;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);\n\treg |= XGBE_AN_CL37_INT_MASK;\n\tXMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);\n}\n\nstatic void xgbe_an73_clear_interrupts(struct xgbe_prv_data *pdata)\n{\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, 0);\n}\n\nstatic void xgbe_an73_disable_interrupts(struct xgbe_prv_data *pdata)\n{\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);\n}\n\nstatic void xgbe_an73_enable_interrupts(struct xgbe_prv_data *pdata)\n{\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, XGBE_AN_CL73_INT_MASK);\n}\n\nstatic void xgbe_an_enable_interrupts(struct xgbe_prv_data *pdata)\n{\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\txgbe_an73_enable_interrupts(pdata);\n\t\tbreak;\n\tcase XGBE_AN_MODE_CL37:\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\txgbe_an37_enable_interrupts(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void xgbe_an_clear_interrupts_all(struct xgbe_prv_data *pdata)\n{\n\txgbe_an73_clear_interrupts(pdata);\n\txgbe_an37_clear_interrupts(pdata);\n}\n\nstatic void xgbe_kr_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_10000);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KR);\n}\n\nstatic void xgbe_kx_2500_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_2500);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_2500);\n}\n\nstatic void xgbe_kx_1000_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_1000);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_1000);\n}\n\nstatic void xgbe_sfi_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tif (pdata->kr_redrv)\n\t\treturn xgbe_kr_mode(pdata);\n\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_10000);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SFI);\n}\n\nstatic void xgbe_x_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_1000);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_X);\n}\n\nstatic void xgbe_sgmii_1000_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_1000);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SGMII_1000);\n}\n\nstatic void xgbe_sgmii_10_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_10);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SGMII_10);\n}\n\nstatic void xgbe_sgmii_100_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->hw_if.set_speed(pdata, SPEED_1000);\n\n\t \n\tpdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SGMII_100);\n}\n\nstatic enum xgbe_mode xgbe_cur_mode(struct xgbe_prv_data *pdata)\n{\n\treturn pdata->phy_if.phy_impl.cur_mode(pdata);\n}\n\nstatic bool xgbe_in_kr_mode(struct xgbe_prv_data *pdata)\n{\n\treturn (xgbe_cur_mode(pdata) == XGBE_MODE_KR);\n}\n\nstatic void xgbe_change_mode(struct xgbe_prv_data *pdata,\n\t\t\t     enum xgbe_mode mode)\n{\n\tswitch (mode) {\n\tcase XGBE_MODE_KX_1000:\n\t\txgbe_kx_1000_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_KX_2500:\n\t\txgbe_kx_2500_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_KR:\n\t\txgbe_kr_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SGMII_10:\n\t\txgbe_sgmii_10_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SGMII_100:\n\t\txgbe_sgmii_100_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SGMII_1000:\n\t\txgbe_sgmii_1000_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_X:\n\t\txgbe_x_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SFI:\n\t\txgbe_sfi_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_UNKNOWN:\n\t\tbreak;\n\tdefault:\n\t\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t\t  \"invalid operation mode requested (%u)\\n\", mode);\n\t}\n}\n\nstatic void xgbe_switch_mode(struct xgbe_prv_data *pdata)\n{\n\txgbe_change_mode(pdata, pdata->phy_if.phy_impl.switch_mode(pdata));\n}\n\nstatic bool xgbe_set_mode(struct xgbe_prv_data *pdata,\n\t\t\t  enum xgbe_mode mode)\n{\n\tif (mode == xgbe_cur_mode(pdata))\n\t\treturn false;\n\n\txgbe_change_mode(pdata, mode);\n\n\treturn true;\n}\n\nstatic bool xgbe_use_mode(struct xgbe_prv_data *pdata,\n\t\t\t  enum xgbe_mode mode)\n{\n\treturn pdata->phy_if.phy_impl.use_mode(pdata, mode);\n}\n\nstatic void xgbe_an37_set(struct xgbe_prv_data *pdata, bool enable,\n\t\t\t  bool restart)\n{\n\tunsigned int reg;\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_CTRL1);\n\treg &= ~MDIO_VEND2_CTRL1_AN_ENABLE;\n\n\tif (enable)\n\t\treg |= MDIO_VEND2_CTRL1_AN_ENABLE;\n\n\tif (restart)\n\t\treg |= MDIO_VEND2_CTRL1_AN_RESTART;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_CTRL1, reg);\n}\n\nstatic void xgbe_an37_restart(struct xgbe_prv_data *pdata)\n{\n\txgbe_an37_enable_interrupts(pdata);\n\txgbe_an37_set(pdata, true, true);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL37 AN enabled/restarted\\n\");\n}\n\nstatic void xgbe_an37_disable(struct xgbe_prv_data *pdata)\n{\n\txgbe_an37_set(pdata, false, false);\n\txgbe_an37_disable_interrupts(pdata);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL37 AN disabled\\n\");\n}\n\nstatic void xgbe_an73_set(struct xgbe_prv_data *pdata, bool enable,\n\t\t\t  bool restart)\n{\n\tunsigned int reg;\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);\n\treg &= ~XGBE_KR_TRAINING_ENABLE;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1);\n\treg &= ~MDIO_AN_CTRL1_ENABLE;\n\n\tif (enable)\n\t\treg |= MDIO_AN_CTRL1_ENABLE;\n\n\tif (restart)\n\t\treg |= MDIO_AN_CTRL1_RESTART;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_CTRL1, reg);\n}\n\nstatic void xgbe_an73_restart(struct xgbe_prv_data *pdata)\n{\n\txgbe_an73_enable_interrupts(pdata);\n\txgbe_an73_set(pdata, true, true);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL73 AN enabled/restarted\\n\");\n}\n\nstatic void xgbe_an73_disable(struct xgbe_prv_data *pdata)\n{\n\txgbe_an73_set(pdata, false, false);\n\txgbe_an73_disable_interrupts(pdata);\n\n\tpdata->an_start = 0;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL73 AN disabled\\n\");\n}\n\nstatic void xgbe_an_restart(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->phy_if.phy_impl.an_pre)\n\t\tpdata->phy_if.phy_impl.an_pre(pdata);\n\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\txgbe_an73_restart(pdata);\n\t\tbreak;\n\tcase XGBE_AN_MODE_CL37:\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\txgbe_an37_restart(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void xgbe_an_disable(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->phy_if.phy_impl.an_post)\n\t\tpdata->phy_if.phy_impl.an_post(pdata);\n\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\txgbe_an73_disable(pdata);\n\t\tbreak;\n\tcase XGBE_AN_MODE_CL37:\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\txgbe_an37_disable(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void xgbe_an_disable_all(struct xgbe_prv_data *pdata)\n{\n\txgbe_an73_disable(pdata);\n\txgbe_an37_disable(pdata);\n}\n\nstatic enum xgbe_an xgbe_an73_tx_training(struct xgbe_prv_data *pdata,\n\t\t\t\t\t  enum xgbe_rx *state)\n{\n\tunsigned int ad_reg, lp_reg, reg;\n\n\t*state = XGBE_RX_COMPLETE;\n\n\t \n\tif (!xgbe_in_kr_mode(pdata))\n\t\treturn XGBE_AN_PAGE_RECEIVED;\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL);\n\treg &= ~(MDIO_PMA_10GBR_FECABLE_ABLE | MDIO_PMA_10GBR_FECABLE_ERRABLE);\n\tif ((ad_reg & 0xc000) && (lp_reg & 0xc000))\n\t\treg |= pdata->fec_ability;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL, reg);\n\n\t \n\tif (pdata->phy_if.phy_impl.kr_training_pre)\n\t\tpdata->phy_if.phy_impl.kr_training_pre(pdata);\n\n\treg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);\n\treg |= XGBE_KR_TRAINING_ENABLE;\n\treg |= XGBE_KR_TRAINING_START;\n\tXMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);\n\tpdata->kr_start_time = jiffies;\n\n\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t  \"KR training initiated\\n\");\n\n\tif (pdata->phy_if.phy_impl.kr_training_post)\n\t\tpdata->phy_if.phy_impl.kr_training_post(pdata);\n\n\treturn XGBE_AN_PAGE_RECEIVED;\n}\n\nstatic enum xgbe_an xgbe_an73_tx_xnp(struct xgbe_prv_data *pdata,\n\t\t\t\t     enum xgbe_rx *state)\n{\n\tu16 msg;\n\n\t*state = XGBE_RX_XNP;\n\n\tmsg = XGBE_XNP_MCF_NULL_MESSAGE;\n\tmsg |= XGBE_XNP_MP_FORMATTED;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 2, 0);\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 1, 0);\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP, msg);\n\n\treturn XGBE_AN_PAGE_RECEIVED;\n}\n\nstatic enum xgbe_an xgbe_an73_rx_bpa(struct xgbe_prv_data *pdata,\n\t\t\t\t     enum xgbe_rx *state)\n{\n\tunsigned int link_support;\n\tunsigned int reg, ad_reg, lp_reg;\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);\n\n\t \n\tlink_support = xgbe_in_kr_mode(pdata) ? 0x80 : 0x20;\n\tif (!(reg & link_support))\n\t\treturn XGBE_AN_INCOMPAT_LINK;\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA);\n\n\treturn ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||\n\t\t(lp_reg & XGBE_XNP_NP_EXCHANGE))\n\t       ? xgbe_an73_tx_xnp(pdata, state)\n\t       : xgbe_an73_tx_training(pdata, state);\n}\n\nstatic enum xgbe_an xgbe_an73_rx_xnp(struct xgbe_prv_data *pdata,\n\t\t\t\t     enum xgbe_rx *state)\n{\n\tunsigned int ad_reg, lp_reg;\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_XNP);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPX);\n\n\treturn ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||\n\t\t(lp_reg & XGBE_XNP_NP_EXCHANGE))\n\t       ? xgbe_an73_tx_xnp(pdata, state)\n\t       : xgbe_an73_tx_training(pdata, state);\n}\n\nstatic enum xgbe_an xgbe_an73_page_received(struct xgbe_prv_data *pdata)\n{\n\tenum xgbe_rx *state;\n\tunsigned long an_timeout;\n\tenum xgbe_an ret;\n\n\tif (!pdata->an_start) {\n\t\tpdata->an_start = jiffies;\n\t} else {\n\t\tan_timeout = pdata->an_start +\n\t\t\t     msecs_to_jiffies(XGBE_AN_MS_TIMEOUT);\n\t\tif (time_after(jiffies, an_timeout)) {\n\t\t\t \n\t\t\tpdata->kr_state = XGBE_RX_BPA;\n\t\t\tpdata->kx_state = XGBE_RX_BPA;\n\n\t\t\tpdata->an_start = jiffies;\n\n\t\t\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t\t\t  \"CL73 AN timed out, resetting state\\n\");\n\t\t}\n\t}\n\n\tstate = xgbe_in_kr_mode(pdata) ? &pdata->kr_state\n\t\t\t\t       : &pdata->kx_state;\n\n\tswitch (*state) {\n\tcase XGBE_RX_BPA:\n\t\tret = xgbe_an73_rx_bpa(pdata, state);\n\t\tbreak;\n\n\tcase XGBE_RX_XNP:\n\t\tret = xgbe_an73_rx_xnp(pdata, state);\n\t\tbreak;\n\n\tdefault:\n\t\tret = XGBE_AN_ERROR;\n\t}\n\n\treturn ret;\n}\n\nstatic enum xgbe_an xgbe_an73_incompat_link(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\t \n\tif (xgbe_in_kr_mode(pdata)) {\n\t\tpdata->kr_state = XGBE_RX_ERROR;\n\n\t\tif (!XGBE_ADV(lks, 1000baseKX_Full) &&\n\t\t    !XGBE_ADV(lks, 2500baseX_Full))\n\t\t\treturn XGBE_AN_NO_LINK;\n\n\t\tif (pdata->kx_state != XGBE_RX_BPA)\n\t\t\treturn XGBE_AN_NO_LINK;\n\t} else {\n\t\tpdata->kx_state = XGBE_RX_ERROR;\n\n\t\tif (!XGBE_ADV(lks, 10000baseKR_Full))\n\t\t\treturn XGBE_AN_NO_LINK;\n\n\t\tif (pdata->kr_state != XGBE_RX_BPA)\n\t\t\treturn XGBE_AN_NO_LINK;\n\t}\n\n\txgbe_an_disable(pdata);\n\n\txgbe_switch_mode(pdata);\n\n\tpdata->an_result = XGBE_AN_READY;\n\n\txgbe_an_restart(pdata);\n\n\treturn XGBE_AN_INCOMPAT_LINK;\n}\n\nstatic void xgbe_an37_isr(struct xgbe_prv_data *pdata)\n{\n\tunsigned int reg;\n\n\t \n\txgbe_an37_disable_interrupts(pdata);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);\n\tpdata->an_int = reg & XGBE_AN_CL37_INT_MASK;\n\tpdata->an_status = reg & ~XGBE_AN_CL37_INT_MASK;\n\n\tif (pdata->an_int) {\n\t\t \n\t\treg &= ~XGBE_AN_CL37_INT_MASK;\n\t\tXMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);\n\n\t\tqueue_work(pdata->an_workqueue, &pdata->an_irq_work);\n\t} else {\n\t\t \n\t\txgbe_an37_enable_interrupts(pdata);\n\n\t\t \n\t\tif (pdata->vdata->irq_reissue_support)\n\t\t\tXP_IOWRITE(pdata, XP_INT_REISSUE_EN, 1 << 3);\n\t}\n}\n\nstatic void xgbe_an73_isr(struct xgbe_prv_data *pdata)\n{\n\t \n\txgbe_an73_disable_interrupts(pdata);\n\n\t \n\tpdata->an_int = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_INT);\n\n\tif (pdata->an_int) {\n\t\t \n\t\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, ~pdata->an_int);\n\n\t\tqueue_work(pdata->an_workqueue, &pdata->an_irq_work);\n\t} else {\n\t\t \n\t\txgbe_an73_enable_interrupts(pdata);\n\n\t\t \n\t\tif (pdata->vdata->irq_reissue_support)\n\t\t\tXP_IOWRITE(pdata, XP_INT_REISSUE_EN, 1 << 3);\n\t}\n}\n\nstatic void xgbe_an_isr_task(struct tasklet_struct *t)\n{\n\tstruct xgbe_prv_data *pdata = from_tasklet(pdata, t, tasklet_an);\n\n\tnetif_dbg(pdata, intr, pdata->netdev, \"AN interrupt received\\n\");\n\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\txgbe_an73_isr(pdata);\n\t\tbreak;\n\tcase XGBE_AN_MODE_CL37:\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\txgbe_an37_isr(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t xgbe_an_isr(int irq, void *data)\n{\n\tstruct xgbe_prv_data *pdata = (struct xgbe_prv_data *)data;\n\n\tif (pdata->isr_as_tasklet)\n\t\ttasklet_schedule(&pdata->tasklet_an);\n\telse\n\t\txgbe_an_isr_task(&pdata->tasklet_an);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t xgbe_an_combined_isr(struct xgbe_prv_data *pdata)\n{\n\txgbe_an_isr_task(&pdata->tasklet_an);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void xgbe_an_irq_work(struct work_struct *work)\n{\n\tstruct xgbe_prv_data *pdata = container_of(work,\n\t\t\t\t\t\t   struct xgbe_prv_data,\n\t\t\t\t\t\t   an_irq_work);\n\n\t \n\tflush_work(&pdata->an_work);\n\tqueue_work(pdata->an_workqueue, &pdata->an_work);\n}\n\nstatic const char *xgbe_state_as_string(enum xgbe_an state)\n{\n\tswitch (state) {\n\tcase XGBE_AN_READY:\n\t\treturn \"Ready\";\n\tcase XGBE_AN_PAGE_RECEIVED:\n\t\treturn \"Page-Received\";\n\tcase XGBE_AN_INCOMPAT_LINK:\n\t\treturn \"Incompatible-Link\";\n\tcase XGBE_AN_COMPLETE:\n\t\treturn \"Complete\";\n\tcase XGBE_AN_NO_LINK:\n\t\treturn \"No-Link\";\n\tcase XGBE_AN_ERROR:\n\t\treturn \"Error\";\n\tdefault:\n\t\treturn \"Undefined\";\n\t}\n}\n\nstatic void xgbe_an37_state_machine(struct xgbe_prv_data *pdata)\n{\n\tenum xgbe_an cur_state = pdata->an_state;\n\n\tif (!pdata->an_int)\n\t\treturn;\n\n\tif (pdata->an_int & XGBE_AN_CL37_INT_CMPLT) {\n\t\tpdata->an_state = XGBE_AN_COMPLETE;\n\t\tpdata->an_int &= ~XGBE_AN_CL37_INT_CMPLT;\n\n\t\t \n\t\tif ((pdata->an_mode == XGBE_AN_MODE_CL37_SGMII) &&\n\t\t    !(pdata->an_status & XGBE_SGMII_AN_LINK_STATUS))\n\t\t\tpdata->an_state = XGBE_AN_NO_LINK;\n\t}\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL37 AN %s\\n\",\n\t\t  xgbe_state_as_string(pdata->an_state));\n\n\tcur_state = pdata->an_state;\n\n\tswitch (pdata->an_state) {\n\tcase XGBE_AN_READY:\n\t\tbreak;\n\n\tcase XGBE_AN_COMPLETE:\n\t\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t\t  \"Auto negotiation successful\\n\");\n\t\tbreak;\n\n\tcase XGBE_AN_NO_LINK:\n\t\tbreak;\n\n\tdefault:\n\t\tpdata->an_state = XGBE_AN_ERROR;\n\t}\n\n\tif (pdata->an_state == XGBE_AN_ERROR) {\n\t\tnetdev_err(pdata->netdev,\n\t\t\t   \"error during auto-negotiation, state=%u\\n\",\n\t\t\t   cur_state);\n\n\t\tpdata->an_int = 0;\n\t\txgbe_an37_clear_interrupts(pdata);\n\t}\n\n\tif (pdata->an_state >= XGBE_AN_COMPLETE) {\n\t\tpdata->an_result = pdata->an_state;\n\t\tpdata->an_state = XGBE_AN_READY;\n\n\t\tif (pdata->phy_if.phy_impl.an_post)\n\t\t\tpdata->phy_if.phy_impl.an_post(pdata);\n\n\t\tnetif_dbg(pdata, link, pdata->netdev, \"CL37 AN result: %s\\n\",\n\t\t\t  xgbe_state_as_string(pdata->an_result));\n\t}\n\n\txgbe_an37_enable_interrupts(pdata);\n}\n\nstatic void xgbe_an73_state_machine(struct xgbe_prv_data *pdata)\n{\n\tenum xgbe_an cur_state = pdata->an_state;\n\n\tif (!pdata->an_int)\n\t\treturn;\n\nnext_int:\n\tif (pdata->an_int & XGBE_AN_CL73_PG_RCV) {\n\t\tpdata->an_state = XGBE_AN_PAGE_RECEIVED;\n\t\tpdata->an_int &= ~XGBE_AN_CL73_PG_RCV;\n\t} else if (pdata->an_int & XGBE_AN_CL73_INC_LINK) {\n\t\tpdata->an_state = XGBE_AN_INCOMPAT_LINK;\n\t\tpdata->an_int &= ~XGBE_AN_CL73_INC_LINK;\n\t} else if (pdata->an_int & XGBE_AN_CL73_INT_CMPLT) {\n\t\tpdata->an_state = XGBE_AN_COMPLETE;\n\t\tpdata->an_int &= ~XGBE_AN_CL73_INT_CMPLT;\n\t} else {\n\t\tpdata->an_state = XGBE_AN_ERROR;\n\t}\n\nagain:\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL73 AN %s\\n\",\n\t\t  xgbe_state_as_string(pdata->an_state));\n\n\tcur_state = pdata->an_state;\n\n\tswitch (pdata->an_state) {\n\tcase XGBE_AN_READY:\n\t\tpdata->an_supported = 0;\n\t\tbreak;\n\n\tcase XGBE_AN_PAGE_RECEIVED:\n\t\tpdata->an_state = xgbe_an73_page_received(pdata);\n\t\tpdata->an_supported++;\n\t\tbreak;\n\n\tcase XGBE_AN_INCOMPAT_LINK:\n\t\tpdata->an_supported = 0;\n\t\tpdata->parallel_detect = 0;\n\t\tpdata->an_state = xgbe_an73_incompat_link(pdata);\n\t\tbreak;\n\n\tcase XGBE_AN_COMPLETE:\n\t\tpdata->parallel_detect = pdata->an_supported ? 0 : 1;\n\t\tnetif_dbg(pdata, link, pdata->netdev, \"%s successful\\n\",\n\t\t\t  pdata->an_supported ? \"Auto negotiation\"\n\t\t\t\t\t      : \"Parallel detection\");\n\t\tbreak;\n\n\tcase XGBE_AN_NO_LINK:\n\t\tbreak;\n\n\tdefault:\n\t\tpdata->an_state = XGBE_AN_ERROR;\n\t}\n\n\tif (pdata->an_state == XGBE_AN_NO_LINK) {\n\t\tpdata->an_int = 0;\n\t\txgbe_an73_clear_interrupts(pdata);\n\t} else if (pdata->an_state == XGBE_AN_ERROR) {\n\t\tnetdev_err(pdata->netdev,\n\t\t\t   \"error during auto-negotiation, state=%u\\n\",\n\t\t\t   cur_state);\n\n\t\tpdata->an_int = 0;\n\t\txgbe_an73_clear_interrupts(pdata);\n\t}\n\n\tif (pdata->an_state >= XGBE_AN_COMPLETE) {\n\t\tpdata->an_result = pdata->an_state;\n\t\tpdata->an_state = XGBE_AN_READY;\n\t\tpdata->kr_state = XGBE_RX_BPA;\n\t\tpdata->kx_state = XGBE_RX_BPA;\n\t\tpdata->an_start = 0;\n\n\t\tif (pdata->phy_if.phy_impl.an_post)\n\t\t\tpdata->phy_if.phy_impl.an_post(pdata);\n\n\t\tnetif_dbg(pdata, link, pdata->netdev, \"CL73 AN result: %s\\n\",\n\t\t\t  xgbe_state_as_string(pdata->an_result));\n\t}\n\n\tif (cur_state != pdata->an_state)\n\t\tgoto again;\n\n\tif (pdata->an_int)\n\t\tgoto next_int;\n\n\txgbe_an73_enable_interrupts(pdata);\n}\n\nstatic void xgbe_an_state_machine(struct work_struct *work)\n{\n\tstruct xgbe_prv_data *pdata = container_of(work,\n\t\t\t\t\t\t   struct xgbe_prv_data,\n\t\t\t\t\t\t   an_work);\n\n\tmutex_lock(&pdata->an_mutex);\n\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\txgbe_an73_state_machine(pdata);\n\t\tbreak;\n\tcase XGBE_AN_MODE_CL37:\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\txgbe_an37_state_machine(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (pdata->vdata->irq_reissue_support)\n\t\tXP_IOWRITE(pdata, XP_INT_REISSUE_EN, 1 << 3);\n\n\tmutex_unlock(&pdata->an_mutex);\n}\n\nstatic void xgbe_an37_init(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings lks;\n\tunsigned int reg;\n\n\tpdata->phy_if.phy_impl.an_advertising(pdata, &lks);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE);\n\tif (XGBE_ADV(&lks, Pause))\n\t\treg |= 0x100;\n\telse\n\t\treg &= ~0x100;\n\n\tif (XGBE_ADV(&lks, Asym_Pause))\n\t\treg |= 0x80;\n\telse\n\t\treg &= ~0x80;\n\n\t \n\treg |= XGBE_AN_CL37_FD_MASK;\n\treg &= ~XGBE_AN_CL37_HD_MASK;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE, reg);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);\n\treg &= ~XGBE_AN_CL37_TX_CONFIG_MASK;\n\treg &= ~XGBE_AN_CL37_PCS_MODE_MASK;\n\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL37:\n\t\treg |= XGBE_AN_CL37_PCS_MODE_BASEX;\n\t\tbreak;\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\treg |= XGBE_AN_CL37_PCS_MODE_SGMII;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treg |= XGBE_AN_CL37_MII_CTRL_8BIT;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL37 AN (%s) initialized\\n\",\n\t\t  (pdata->an_mode == XGBE_AN_MODE_CL37) ? \"BaseX\" : \"SGMII\");\n}\n\nstatic void xgbe_an73_init(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings lks;\n\tunsigned int reg;\n\n\tpdata->phy_if.phy_impl.an_advertising(pdata, &lks);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);\n\tif (XGBE_ADV(&lks, 10000baseR_FEC))\n\t\treg |= 0xc000;\n\telse\n\t\treg &= ~0xc000;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2, reg);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);\n\tif (XGBE_ADV(&lks, 10000baseKR_Full))\n\t\treg |= 0x80;\n\telse\n\t\treg &= ~0x80;\n\n\tif (XGBE_ADV(&lks, 1000baseKX_Full) ||\n\t    XGBE_ADV(&lks, 2500baseX_Full))\n\t\treg |= 0x20;\n\telse\n\t\treg &= ~0x20;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1, reg);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);\n\tif (XGBE_ADV(&lks, Pause))\n\t\treg |= 0x400;\n\telse\n\t\treg &= ~0x400;\n\n\tif (XGBE_ADV(&lks, Asym_Pause))\n\t\treg |= 0x800;\n\telse\n\t\treg &= ~0x800;\n\n\t \n\treg &= ~XGBE_XNP_NP_EXCHANGE;\n\n\tXMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"CL73 AN initialized\\n\");\n}\n\nstatic void xgbe_an_init(struct xgbe_prv_data *pdata)\n{\n\t \n\tpdata->an_mode = pdata->phy_if.phy_impl.an_mode(pdata);\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\txgbe_an73_init(pdata);\n\t\tbreak;\n\tcase XGBE_AN_MODE_CL37:\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\txgbe_an37_init(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const char *xgbe_phy_fc_string(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->tx_pause && pdata->rx_pause)\n\t\treturn \"rx/tx\";\n\telse if (pdata->rx_pause)\n\t\treturn \"rx\";\n\telse if (pdata->tx_pause)\n\t\treturn \"tx\";\n\telse\n\t\treturn \"off\";\n}\n\nstatic const char *xgbe_phy_speed_string(int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\treturn \"10Mbps\";\n\tcase SPEED_100:\n\t\treturn \"100Mbps\";\n\tcase SPEED_1000:\n\t\treturn \"1Gbps\";\n\tcase SPEED_2500:\n\t\treturn \"2.5Gbps\";\n\tcase SPEED_10000:\n\t\treturn \"10Gbps\";\n\tcase SPEED_UNKNOWN:\n\t\treturn \"Unknown\";\n\tdefault:\n\t\treturn \"Unsupported\";\n\t}\n}\n\nstatic void xgbe_phy_print_status(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->phy.link)\n\t\tnetdev_info(pdata->netdev,\n\t\t\t    \"Link is Up - %s/%s - flow control %s\\n\",\n\t\t\t    xgbe_phy_speed_string(pdata->phy.speed),\n\t\t\t    pdata->phy.duplex == DUPLEX_FULL ? \"Full\" : \"Half\",\n\t\t\t    xgbe_phy_fc_string(pdata));\n\telse\n\t\tnetdev_info(pdata->netdev, \"Link is Down\\n\");\n}\n\nstatic void xgbe_phy_adjust_link(struct xgbe_prv_data *pdata)\n{\n\tint new_state = 0;\n\n\tif (pdata->phy.link) {\n\t\t \n\t\tpdata->pause_autoneg = pdata->phy.pause_autoneg;\n\n\t\tif (pdata->tx_pause != pdata->phy.tx_pause) {\n\t\t\tnew_state = 1;\n\t\t\tpdata->tx_pause = pdata->phy.tx_pause;\n\t\t\tpdata->hw_if.config_tx_flow_control(pdata);\n\t\t}\n\n\t\tif (pdata->rx_pause != pdata->phy.rx_pause) {\n\t\t\tnew_state = 1;\n\t\t\tpdata->rx_pause = pdata->phy.rx_pause;\n\t\t\tpdata->hw_if.config_rx_flow_control(pdata);\n\t\t}\n\n\t\t \n\t\tif (pdata->phy_speed != pdata->phy.speed) {\n\t\t\tnew_state = 1;\n\t\t\tpdata->phy_speed = pdata->phy.speed;\n\t\t}\n\n\t\tif (pdata->phy_link != pdata->phy.link) {\n\t\t\tnew_state = 1;\n\t\t\tpdata->phy_link = pdata->phy.link;\n\t\t}\n\t} else if (pdata->phy_link) {\n\t\tnew_state = 1;\n\t\tpdata->phy_link = 0;\n\t\tpdata->phy_speed = SPEED_UNKNOWN;\n\t}\n\n\tif (new_state && netif_msg_link(pdata))\n\t\txgbe_phy_print_status(pdata);\n}\n\nstatic bool xgbe_phy_valid_speed(struct xgbe_prv_data *pdata, int speed)\n{\n\treturn pdata->phy_if.phy_impl.valid_speed(pdata, speed);\n}\n\nstatic int xgbe_phy_config_fixed(struct xgbe_prv_data *pdata)\n{\n\tenum xgbe_mode mode;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"fixed PHY configuration\\n\");\n\n\t \n\txgbe_an_disable(pdata);\n\n\t \n\tmode = pdata->phy_if.phy_impl.get_mode(pdata, pdata->phy.speed);\n\tswitch (mode) {\n\tcase XGBE_MODE_KX_1000:\n\tcase XGBE_MODE_KX_2500:\n\tcase XGBE_MODE_KR:\n\tcase XGBE_MODE_SGMII_10:\n\tcase XGBE_MODE_SGMII_100:\n\tcase XGBE_MODE_SGMII_1000:\n\tcase XGBE_MODE_X:\n\tcase XGBE_MODE_SFI:\n\t\tbreak;\n\tcase XGBE_MODE_UNKNOWN:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pdata->phy.duplex != DUPLEX_FULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (mode == XGBE_MODE_SFI)\n\t\txgbe_change_mode(pdata, mode);\n\telse\n\t\txgbe_set_mode(pdata, mode);\n\n\treturn 0;\n}\n\nstatic int __xgbe_phy_config_aneg(struct xgbe_prv_data *pdata, bool set_mode)\n{\n\tint ret;\n\n\tmutex_lock(&pdata->an_mutex);\n\n\tset_bit(XGBE_LINK_INIT, &pdata->dev_state);\n\tpdata->link_check = jiffies;\n\n\tret = pdata->phy_if.phy_impl.an_config(pdata);\n\tif (ret)\n\t\tgoto out;\n\n\tif (pdata->phy.autoneg != AUTONEG_ENABLE) {\n\t\tret = xgbe_phy_config_fixed(pdata);\n\t\tif (ret || !pdata->kr_redrv)\n\t\t\tgoto out;\n\n\t\tnetif_dbg(pdata, link, pdata->netdev, \"AN redriver support\\n\");\n\t} else {\n\t\tnetif_dbg(pdata, link, pdata->netdev, \"AN PHY configuration\\n\");\n\t}\n\n\t \n\tdisable_irq(pdata->an_irq);\n\n\tif (set_mode) {\n\t\t \n\t\tif (xgbe_use_mode(pdata, XGBE_MODE_KR)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_KR);\n\t\t} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_2500)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_KX_2500);\n\t\t} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_1000)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_KX_1000);\n\t\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SFI)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_SFI);\n\t\t} else if (xgbe_use_mode(pdata, XGBE_MODE_X)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_X);\n\t\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_1000)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_SGMII_1000);\n\t\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_100)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_SGMII_100);\n\t\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_10)) {\n\t\t\txgbe_set_mode(pdata, XGBE_MODE_SGMII_10);\n\t\t} else {\n\t\t\tenable_irq(pdata->an_irq);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\txgbe_an_disable_all(pdata);\n\n\t \n\txgbe_an_clear_interrupts_all(pdata);\n\n\tpdata->an_result = XGBE_AN_READY;\n\tpdata->an_state = XGBE_AN_READY;\n\tpdata->kr_state = XGBE_RX_BPA;\n\tpdata->kx_state = XGBE_RX_BPA;\n\n\t \n\tenable_irq(pdata->an_irq);\n\n\txgbe_an_init(pdata);\n\txgbe_an_restart(pdata);\n\nout:\n\tif (ret)\n\t\tset_bit(XGBE_LINK_ERR, &pdata->dev_state);\n\telse\n\t\tclear_bit(XGBE_LINK_ERR, &pdata->dev_state);\n\n\tmutex_unlock(&pdata->an_mutex);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_config_aneg(struct xgbe_prv_data *pdata)\n{\n\treturn __xgbe_phy_config_aneg(pdata, true);\n}\n\nstatic int xgbe_phy_reconfig_aneg(struct xgbe_prv_data *pdata)\n{\n\treturn __xgbe_phy_config_aneg(pdata, false);\n}\n\nstatic bool xgbe_phy_aneg_done(struct xgbe_prv_data *pdata)\n{\n\treturn (pdata->an_result == XGBE_AN_COMPLETE);\n}\n\nstatic void xgbe_check_link_timeout(struct xgbe_prv_data *pdata)\n{\n\tunsigned long link_timeout;\n\tunsigned long kr_time;\n\tint wait;\n\n\tlink_timeout = pdata->link_check + (XGBE_LINK_TIMEOUT * HZ);\n\tif (time_after(jiffies, link_timeout)) {\n\t\tif ((xgbe_cur_mode(pdata) == XGBE_MODE_KR) &&\n\t\t    pdata->phy.autoneg == AUTONEG_ENABLE) {\n\t\t\t \n\t\t\twait = XGBE_KR_TRAINING_WAIT_ITER;\n\t\t\twhile (wait--) {\n\t\t\t\tkr_time = pdata->kr_start_time +\n\t\t\t\t\t  msecs_to_jiffies(XGBE_AN_MS_TIMEOUT);\n\t\t\t\tif (time_after(jiffies, kr_time))\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tif (pdata->an_result == XGBE_AN_COMPLETE)\n\t\t\t\t\treturn;\n\t\t\t\tusleep_range(10000, 11000);\n\t\t\t}\n\t\t}\n\t\tnetif_dbg(pdata, link, pdata->netdev, \"AN link timeout\\n\");\n\t\txgbe_phy_config_aneg(pdata);\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_status_aneg(struct xgbe_prv_data *pdata)\n{\n\treturn pdata->phy_if.phy_impl.an_outcome(pdata);\n}\n\nstatic bool xgbe_phy_status_result(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tenum xgbe_mode mode;\n\n\tXGBE_ZERO_LP_ADV(lks);\n\n\tif ((pdata->phy.autoneg != AUTONEG_ENABLE) || pdata->parallel_detect)\n\t\tmode = xgbe_cur_mode(pdata);\n\telse\n\t\tmode = xgbe_phy_status_aneg(pdata);\n\n\tswitch (mode) {\n\tcase XGBE_MODE_SGMII_10:\n\t\tpdata->phy.speed = SPEED_10;\n\t\tbreak;\n\tcase XGBE_MODE_SGMII_100:\n\t\tpdata->phy.speed = SPEED_100;\n\t\tbreak;\n\tcase XGBE_MODE_X:\n\tcase XGBE_MODE_KX_1000:\n\tcase XGBE_MODE_SGMII_1000:\n\t\tpdata->phy.speed = SPEED_1000;\n\t\tbreak;\n\tcase XGBE_MODE_KX_2500:\n\t\tpdata->phy.speed = SPEED_2500;\n\t\tbreak;\n\tcase XGBE_MODE_KR:\n\tcase XGBE_MODE_SFI:\n\t\tpdata->phy.speed = SPEED_10000;\n\t\tbreak;\n\tcase XGBE_MODE_UNKNOWN:\n\tdefault:\n\t\tpdata->phy.speed = SPEED_UNKNOWN;\n\t}\n\n\tpdata->phy.duplex = DUPLEX_FULL;\n\n\tif (!xgbe_set_mode(pdata, mode))\n\t\treturn false;\n\n\tif (pdata->an_again)\n\t\txgbe_phy_reconfig_aneg(pdata);\n\n\treturn true;\n}\n\nstatic void xgbe_phy_status(struct xgbe_prv_data *pdata)\n{\n\tunsigned int link_aneg;\n\tint an_restart;\n\n\tif (test_bit(XGBE_LINK_ERR, &pdata->dev_state)) {\n\t\tnetif_carrier_off(pdata->netdev);\n\n\t\tpdata->phy.link = 0;\n\t\tgoto adjust_link;\n\t}\n\n\tlink_aneg = (pdata->phy.autoneg == AUTONEG_ENABLE);\n\n\tpdata->phy.link = pdata->phy_if.phy_impl.link_status(pdata,\n\t\t\t\t\t\t\t     &an_restart);\n\tif (an_restart) {\n\t\txgbe_phy_config_aneg(pdata);\n\t\tgoto adjust_link;\n\t}\n\n\tif (pdata->phy.link) {\n\t\tif (link_aneg && !xgbe_phy_aneg_done(pdata)) {\n\t\t\txgbe_check_link_timeout(pdata);\n\t\t\treturn;\n\t\t}\n\n\t\tif (xgbe_phy_status_result(pdata))\n\t\t\treturn;\n\n\t\tif (test_bit(XGBE_LINK_INIT, &pdata->dev_state))\n\t\t\tclear_bit(XGBE_LINK_INIT, &pdata->dev_state);\n\n\t\tnetif_carrier_on(pdata->netdev);\n\t} else {\n\t\tif (test_bit(XGBE_LINK_INIT, &pdata->dev_state)) {\n\t\t\txgbe_check_link_timeout(pdata);\n\n\t\t\tif (link_aneg)\n\t\t\t\treturn;\n\t\t}\n\n\t\txgbe_phy_status_result(pdata);\n\n\t\tnetif_carrier_off(pdata->netdev);\n\t}\n\nadjust_link:\n\txgbe_phy_adjust_link(pdata);\n}\n\nstatic void xgbe_phy_stop(struct xgbe_prv_data *pdata)\n{\n\tnetif_dbg(pdata, link, pdata->netdev, \"stopping PHY\\n\");\n\n\tif (!pdata->phy_started)\n\t\treturn;\n\n\t \n\tpdata->phy_started = 0;\n\n\t \n\txgbe_an_disable_all(pdata);\n\n\tif (pdata->dev_irq != pdata->an_irq) {\n\t\tdevm_free_irq(pdata->dev, pdata->an_irq, pdata);\n\t\ttasklet_kill(&pdata->tasklet_an);\n\t}\n\n\tpdata->phy_if.phy_impl.stop(pdata);\n\n\tpdata->phy.link = 0;\n\n\txgbe_phy_adjust_link(pdata);\n}\n\nstatic int xgbe_phy_start(struct xgbe_prv_data *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\tint ret;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"starting PHY\\n\");\n\n\tret = pdata->phy_if.phy_impl.start(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (pdata->dev_irq != pdata->an_irq) {\n\t\ttasklet_setup(&pdata->tasklet_an, xgbe_an_isr_task);\n\n\t\tret = devm_request_irq(pdata->dev, pdata->an_irq,\n\t\t\t\t       xgbe_an_isr, 0, pdata->an_name,\n\t\t\t\t       pdata);\n\t\tif (ret) {\n\t\t\tnetdev_err(netdev, \"phy irq request failed\\n\");\n\t\t\tgoto err_stop;\n\t\t}\n\t}\n\n\t \n\tif (xgbe_use_mode(pdata, XGBE_MODE_KR)) {\n\t\txgbe_kr_mode(pdata);\n\t} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_2500)) {\n\t\txgbe_kx_2500_mode(pdata);\n\t} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_1000)) {\n\t\txgbe_kx_1000_mode(pdata);\n\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SFI)) {\n\t\txgbe_sfi_mode(pdata);\n\t} else if (xgbe_use_mode(pdata, XGBE_MODE_X)) {\n\t\txgbe_x_mode(pdata);\n\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_1000)) {\n\t\txgbe_sgmii_1000_mode(pdata);\n\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_100)) {\n\t\txgbe_sgmii_100_mode(pdata);\n\t} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_10)) {\n\t\txgbe_sgmii_10_mode(pdata);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err_irq;\n\t}\n\n\t \n\tpdata->phy_started = 1;\n\n\txgbe_an_init(pdata);\n\txgbe_an_enable_interrupts(pdata);\n\n\treturn xgbe_phy_config_aneg(pdata);\n\nerr_irq:\n\tif (pdata->dev_irq != pdata->an_irq)\n\t\tdevm_free_irq(pdata->dev, pdata->an_irq, pdata);\n\nerr_stop:\n\tpdata->phy_if.phy_impl.stop(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_reset(struct xgbe_prv_data *pdata)\n{\n\tint ret;\n\n\tret = pdata->phy_if.phy_impl.reset(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\txgbe_an_disable_all(pdata);\n\n\t \n\txgbe_an_clear_interrupts_all(pdata);\n\n\treturn 0;\n}\n\nstatic void xgbe_dump_phy_registers(struct xgbe_prv_data *pdata)\n{\n\tstruct device *dev = pdata->dev;\n\n\tdev_dbg(dev, \"\\n************* PHY Reg dump **********************\\n\");\n\n\tdev_dbg(dev, \"PCS Control Reg (%#06x) = %#06x\\n\", MDIO_CTRL1,\n\t\tXMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1));\n\tdev_dbg(dev, \"PCS Status Reg (%#06x) = %#06x\\n\", MDIO_STAT1,\n\t\tXMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1));\n\tdev_dbg(dev, \"Phy Id (PHYS ID 1 %#06x)= %#06x\\n\", MDIO_DEVID1,\n\t\tXMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID1));\n\tdev_dbg(dev, \"Phy Id (PHYS ID 2 %#06x)= %#06x\\n\", MDIO_DEVID2,\n\t\tXMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID2));\n\tdev_dbg(dev, \"Devices in Package (%#06x)= %#06x\\n\", MDIO_DEVS1,\n\t\tXMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS1));\n\tdev_dbg(dev, \"Devices in Package (%#06x)= %#06x\\n\", MDIO_DEVS2,\n\t\tXMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS2));\n\n\tdev_dbg(dev, \"Auto-Neg Control Reg (%#06x) = %#06x\\n\", MDIO_CTRL1,\n\t\tXMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1));\n\tdev_dbg(dev, \"Auto-Neg Status Reg (%#06x) = %#06x\\n\", MDIO_STAT1,\n\t\tXMDIO_READ(pdata, MDIO_MMD_AN, MDIO_STAT1));\n\tdev_dbg(dev, \"Auto-Neg Ad Reg 1 (%#06x) = %#06x\\n\",\n\t\tMDIO_AN_ADVERTISE,\n\t\tXMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE));\n\tdev_dbg(dev, \"Auto-Neg Ad Reg 2 (%#06x) = %#06x\\n\",\n\t\tMDIO_AN_ADVERTISE + 1,\n\t\tXMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1));\n\tdev_dbg(dev, \"Auto-Neg Ad Reg 3 (%#06x) = %#06x\\n\",\n\t\tMDIO_AN_ADVERTISE + 2,\n\t\tXMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2));\n\tdev_dbg(dev, \"Auto-Neg Completion Reg (%#06x) = %#06x\\n\",\n\t\tMDIO_AN_COMP_STAT,\n\t\tXMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_COMP_STAT));\n\n\tdev_dbg(dev, \"\\n*************************************************\\n\");\n}\n\nstatic int xgbe_phy_best_advertised_speed(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\tif (XGBE_ADV(lks, 10000baseKR_Full))\n\t\treturn SPEED_10000;\n\telse if (XGBE_ADV(lks, 10000baseT_Full))\n\t\treturn SPEED_10000;\n\telse if (XGBE_ADV(lks, 2500baseX_Full))\n\t\treturn SPEED_2500;\n\telse if (XGBE_ADV(lks, 2500baseT_Full))\n\t\treturn SPEED_2500;\n\telse if (XGBE_ADV(lks, 1000baseKX_Full))\n\t\treturn SPEED_1000;\n\telse if (XGBE_ADV(lks, 1000baseT_Full))\n\t\treturn SPEED_1000;\n\telse if (XGBE_ADV(lks, 100baseT_Full))\n\t\treturn SPEED_100;\n\telse if (XGBE_ADV(lks, 10baseT_Full))\n\t\treturn SPEED_10;\n\n\treturn SPEED_UNKNOWN;\n}\n\nstatic void xgbe_phy_exit(struct xgbe_prv_data *pdata)\n{\n\tpdata->phy_if.phy_impl.exit(pdata);\n}\n\nstatic int xgbe_phy_init(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tint ret;\n\n\tmutex_init(&pdata->an_mutex);\n\tINIT_WORK(&pdata->an_irq_work, xgbe_an_irq_work);\n\tINIT_WORK(&pdata->an_work, xgbe_an_state_machine);\n\tpdata->mdio_mmd = MDIO_MMD_PCS;\n\n\t \n\tpdata->fec_ability = XMDIO_READ(pdata, MDIO_MMD_PMAPMD,\n\t\t\t\t\tMDIO_PMA_10GBR_FECABLE);\n\tpdata->fec_ability &= (MDIO_PMA_10GBR_FECABLE_ABLE |\n\t\t\t       MDIO_PMA_10GBR_FECABLE_ERRABLE);\n\n\t \n\tret = pdata->phy_if.phy_impl.init(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tXGBE_LM_COPY(lks, advertising, lks, supported);\n\n\tpdata->phy.address = 0;\n\n\tif (XGBE_ADV(lks, Autoneg)) {\n\t\tpdata->phy.autoneg = AUTONEG_ENABLE;\n\t\tpdata->phy.speed = SPEED_UNKNOWN;\n\t\tpdata->phy.duplex = DUPLEX_UNKNOWN;\n\t} else {\n\t\tpdata->phy.autoneg = AUTONEG_DISABLE;\n\t\tpdata->phy.speed = xgbe_phy_best_advertised_speed(pdata);\n\t\tpdata->phy.duplex = DUPLEX_FULL;\n\t}\n\n\tpdata->phy.link = 0;\n\n\tpdata->phy.pause_autoneg = pdata->pause_autoneg;\n\tpdata->phy.tx_pause = pdata->tx_pause;\n\tpdata->phy.rx_pause = pdata->rx_pause;\n\n\t \n\tXGBE_CLR_ADV(lks, Pause);\n\tXGBE_CLR_ADV(lks, Asym_Pause);\n\n\tif (pdata->rx_pause) {\n\t\tXGBE_SET_ADV(lks, Pause);\n\t\tXGBE_SET_ADV(lks, Asym_Pause);\n\t}\n\n\tif (pdata->tx_pause) {\n\t\t \n\t\tif (XGBE_ADV(lks, Asym_Pause))\n\t\t\tXGBE_CLR_ADV(lks, Asym_Pause);\n\t\telse\n\t\t\tXGBE_SET_ADV(lks, Asym_Pause);\n\t}\n\n\tif (netif_msg_drv(pdata))\n\t\txgbe_dump_phy_registers(pdata);\n\n\treturn 0;\n}\n\nvoid xgbe_init_function_ptrs_phy(struct xgbe_phy_if *phy_if)\n{\n\tphy_if->phy_init        = xgbe_phy_init;\n\tphy_if->phy_exit        = xgbe_phy_exit;\n\n\tphy_if->phy_reset       = xgbe_phy_reset;\n\tphy_if->phy_start       = xgbe_phy_start;\n\tphy_if->phy_stop        = xgbe_phy_stop;\n\n\tphy_if->phy_status      = xgbe_phy_status;\n\tphy_if->phy_config_aneg = xgbe_phy_config_aneg;\n\n\tphy_if->phy_valid_speed = xgbe_phy_valid_speed;\n\n\tphy_if->an_isr          = xgbe_an_combined_isr;\n\n\tphy_if->module_info     = xgbe_phy_module_info;\n\tphy_if->module_eeprom   = xgbe_phy_module_eeprom;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}