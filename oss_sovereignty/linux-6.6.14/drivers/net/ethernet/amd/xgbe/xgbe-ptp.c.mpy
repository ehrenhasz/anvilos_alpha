{
  "module_name": "xgbe-ptp.c",
  "hash_id": "758e5dde4522d6573b654c766f22f370d905f5b3f774fb4228e5695b863cb3a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/net_tstamp.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\nstatic u64 xgbe_cc_read(const struct cyclecounter *cc)\n{\n\tstruct xgbe_prv_data *pdata = container_of(cc,\n\t\t\t\t\t\t   struct xgbe_prv_data,\n\t\t\t\t\t\t   tstamp_cc);\n\tu64 nsec;\n\n\tnsec = pdata->hw_if.get_tstamp_time(pdata);\n\n\treturn nsec;\n}\n\nstatic int xgbe_adjfine(struct ptp_clock_info *info, long scaled_ppm)\n{\n\tstruct xgbe_prv_data *pdata = container_of(info,\n\t\t\t\t\t\t   struct xgbe_prv_data,\n\t\t\t\t\t\t   ptp_clock_info);\n\tunsigned long flags;\n\tu64 addend;\n\n\taddend = adjust_by_scaled_ppm(pdata->tstamp_addend, scaled_ppm);\n\n\tspin_lock_irqsave(&pdata->tstamp_lock, flags);\n\n\tpdata->hw_if.update_tstamp_addend(pdata, addend);\n\n\tspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\n\n\treturn 0;\n}\n\nstatic int xgbe_adjtime(struct ptp_clock_info *info, s64 delta)\n{\n\tstruct xgbe_prv_data *pdata = container_of(info,\n\t\t\t\t\t\t   struct xgbe_prv_data,\n\t\t\t\t\t\t   ptp_clock_info);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->tstamp_lock, flags);\n\ttimecounter_adjtime(&pdata->tstamp_tc, delta);\n\tspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\n\n\treturn 0;\n}\n\nstatic int xgbe_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\tstruct xgbe_prv_data *pdata = container_of(info,\n\t\t\t\t\t\t   struct xgbe_prv_data,\n\t\t\t\t\t\t   ptp_clock_info);\n\tunsigned long flags;\n\tu64 nsec;\n\n\tspin_lock_irqsave(&pdata->tstamp_lock, flags);\n\n\tnsec = timecounter_read(&pdata->tstamp_tc);\n\n\tspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\n\n\t*ts = ns_to_timespec64(nsec);\n\n\treturn 0;\n}\n\nstatic int xgbe_settime(struct ptp_clock_info *info,\n\t\t\tconst struct timespec64 *ts)\n{\n\tstruct xgbe_prv_data *pdata = container_of(info,\n\t\t\t\t\t\t   struct xgbe_prv_data,\n\t\t\t\t\t\t   ptp_clock_info);\n\tunsigned long flags;\n\tu64 nsec;\n\n\tnsec = timespec64_to_ns(ts);\n\n\tspin_lock_irqsave(&pdata->tstamp_lock, flags);\n\n\ttimecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc, nsec);\n\n\tspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\n\n\treturn 0;\n}\n\nstatic int xgbe_enable(struct ptp_clock_info *info,\n\t\t       struct ptp_clock_request *request, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nvoid xgbe_ptp_register(struct xgbe_prv_data *pdata)\n{\n\tstruct ptp_clock_info *info = &pdata->ptp_clock_info;\n\tstruct ptp_clock *clock;\n\tstruct cyclecounter *cc = &pdata->tstamp_cc;\n\tu64 dividend;\n\n\tsnprintf(info->name, sizeof(info->name), \"%s\",\n\t\t netdev_name(pdata->netdev));\n\tinfo->owner = THIS_MODULE;\n\tinfo->max_adj = pdata->ptpclk_rate;\n\tinfo->adjfine = xgbe_adjfine;\n\tinfo->adjtime = xgbe_adjtime;\n\tinfo->gettime64 = xgbe_gettime;\n\tinfo->settime64 = xgbe_settime;\n\tinfo->enable = xgbe_enable;\n\n\tclock = ptp_clock_register(info, pdata->dev);\n\tif (IS_ERR(clock)) {\n\t\tdev_err(pdata->dev, \"ptp_clock_register failed\\n\");\n\t\treturn;\n\t}\n\n\tpdata->ptp_clock = clock;\n\n\t \n\tdividend = 50000000;\n\tdividend <<= 32;\n\tpdata->tstamp_addend = div_u64(dividend, pdata->ptpclk_rate);\n\n\t \n\tcc->read = xgbe_cc_read;\n\tcc->mask = CLOCKSOURCE_MASK(64);\n\tcc->mult = 1;\n\tcc->shift = 0;\n\n\ttimecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\n\t \n\tXGMAC_IOWRITE(pdata, MAC_TSCR, 0);\n\tpdata->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\n\tpdata->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\n}\n\nvoid xgbe_ptp_unregister(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->ptp_clock)\n\t\tptp_clock_unregister(pdata->ptp_clock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}