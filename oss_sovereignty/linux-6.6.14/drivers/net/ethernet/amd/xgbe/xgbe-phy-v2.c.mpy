{
  "module_name": "xgbe-phy-v2.c",
  "hash_id": "b6347f9aaf5bbe830bc1eadb639ee6386ec9edb6c69319f6f5e03cc020f0fd7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kmod.h>\n#include <linux/mdio.h>\n#include <linux/phy.h>\n#include <linux/ethtool.h>\n\n#include \"xgbe.h\"\n#include \"xgbe-common.h\"\n\n#define XGBE_PHY_PORT_SPEED_10\t\tBIT(0)\n#define XGBE_PHY_PORT_SPEED_100\t\tBIT(1)\n#define XGBE_PHY_PORT_SPEED_1000\tBIT(2)\n#define XGBE_PHY_PORT_SPEED_2500\tBIT(3)\n#define XGBE_PHY_PORT_SPEED_10000\tBIT(4)\n\n#define XGBE_MUTEX_RELEASE\t\t0x80000000\n\n#define XGBE_SFP_DIRECT\t\t\t7\n\n \n#define XGBE_SFP_SERIAL_ID_ADDRESS\t0x50\n#define XGBE_SFP_DIAG_INFO_ADDRESS\t0x51\n#define XGBE_SFP_PHY_ADDRESS\t\t0x56\n#define XGBE_GPIO_ADDRESS_PCA9555\t0x20\n\n \n#define XGBE_GPIO_NO_TX_FAULT\t\tBIT(0)\n#define XGBE_GPIO_NO_RATE_SELECT\tBIT(1)\n#define XGBE_GPIO_NO_MOD_ABSENT\t\tBIT(2)\n#define XGBE_GPIO_NO_RX_LOS\t\tBIT(3)\n\n \n#define XGBE_RATECHANGE_COUNT\t\t500\n\n \n#define XGBE_CDR_DELAY_INIT\t\t10000\n#define XGBE_CDR_DELAY_INC\t\t10000\n#define XGBE_CDR_DELAY_MAX\t\t100000\n\n \n#define XGBE_RRC_FREQUENCY\t\t10\n\nenum xgbe_port_mode {\n\tXGBE_PORT_MODE_RSVD = 0,\n\tXGBE_PORT_MODE_BACKPLANE,\n\tXGBE_PORT_MODE_BACKPLANE_2500,\n\tXGBE_PORT_MODE_1000BASE_T,\n\tXGBE_PORT_MODE_1000BASE_X,\n\tXGBE_PORT_MODE_NBASE_T,\n\tXGBE_PORT_MODE_10GBASE_T,\n\tXGBE_PORT_MODE_10GBASE_R,\n\tXGBE_PORT_MODE_SFP,\n\tXGBE_PORT_MODE_BACKPLANE_NO_AUTONEG,\n\tXGBE_PORT_MODE_MAX,\n};\n\nenum xgbe_conn_type {\n\tXGBE_CONN_TYPE_NONE = 0,\n\tXGBE_CONN_TYPE_SFP,\n\tXGBE_CONN_TYPE_MDIO,\n\tXGBE_CONN_TYPE_RSVD1,\n\tXGBE_CONN_TYPE_BACKPLANE,\n\tXGBE_CONN_TYPE_MAX,\n};\n\n \nenum xgbe_sfp_comm {\n\tXGBE_SFP_COMM_DIRECT = 0,\n\tXGBE_SFP_COMM_PCA9545,\n};\n\nenum xgbe_sfp_cable {\n\tXGBE_SFP_CABLE_UNKNOWN = 0,\n\tXGBE_SFP_CABLE_ACTIVE,\n\tXGBE_SFP_CABLE_PASSIVE,\n\tXGBE_SFP_CABLE_FIBER,\n};\n\nenum xgbe_sfp_base {\n\tXGBE_SFP_BASE_UNKNOWN = 0,\n\tXGBE_SFP_BASE_1000_T,\n\tXGBE_SFP_BASE_1000_SX,\n\tXGBE_SFP_BASE_1000_LX,\n\tXGBE_SFP_BASE_1000_CX,\n\tXGBE_SFP_BASE_10000_SR,\n\tXGBE_SFP_BASE_10000_LR,\n\tXGBE_SFP_BASE_10000_LRM,\n\tXGBE_SFP_BASE_10000_ER,\n\tXGBE_SFP_BASE_10000_CR,\n};\n\nenum xgbe_sfp_speed {\n\tXGBE_SFP_SPEED_UNKNOWN = 0,\n\tXGBE_SFP_SPEED_100_1000,\n\tXGBE_SFP_SPEED_1000,\n\tXGBE_SFP_SPEED_10000,\n};\n\n \n#define XGBE_SFP_BASE_ID\t\t\t0\n#define XGBE_SFP_ID_SFP\t\t\t\t0x03\n\n#define XGBE_SFP_BASE_EXT_ID\t\t\t1\n#define XGBE_SFP_EXT_ID_SFP\t\t\t0x04\n\n#define XGBE_SFP_BASE_10GBE_CC\t\t\t3\n#define XGBE_SFP_BASE_10GBE_CC_SR\t\tBIT(4)\n#define XGBE_SFP_BASE_10GBE_CC_LR\t\tBIT(5)\n#define XGBE_SFP_BASE_10GBE_CC_LRM\t\tBIT(6)\n#define XGBE_SFP_BASE_10GBE_CC_ER\t\tBIT(7)\n\n#define XGBE_SFP_BASE_1GBE_CC\t\t\t6\n#define XGBE_SFP_BASE_1GBE_CC_SX\t\tBIT(0)\n#define XGBE_SFP_BASE_1GBE_CC_LX\t\tBIT(1)\n#define XGBE_SFP_BASE_1GBE_CC_CX\t\tBIT(2)\n#define XGBE_SFP_BASE_1GBE_CC_T\t\t\tBIT(3)\n\n#define XGBE_SFP_BASE_CABLE\t\t\t8\n#define XGBE_SFP_BASE_CABLE_PASSIVE\t\tBIT(2)\n#define XGBE_SFP_BASE_CABLE_ACTIVE\t\tBIT(3)\n\n#define XGBE_SFP_BASE_BR\t\t\t12\n#define XGBE_SFP_BASE_BR_1GBE_MIN\t\t0x0a\n#define XGBE_SFP_BASE_BR_10GBE_MIN\t\t0x64\n\n#define XGBE_SFP_BASE_CU_CABLE_LEN\t\t18\n\n#define XGBE_SFP_BASE_VENDOR_NAME\t\t20\n#define XGBE_SFP_BASE_VENDOR_NAME_LEN\t\t16\n#define XGBE_SFP_BASE_VENDOR_PN\t\t\t40\n#define XGBE_SFP_BASE_VENDOR_PN_LEN\t\t16\n#define XGBE_SFP_BASE_VENDOR_REV\t\t56\n#define XGBE_SFP_BASE_VENDOR_REV_LEN\t\t4\n\n#define XGBE_SFP_BASE_CC\t\t\t63\n\n \n#define XGBE_SFP_BASE_VENDOR_SN\t\t\t4\n#define XGBE_SFP_BASE_VENDOR_SN_LEN\t\t16\n\n#define XGBE_SFP_EXTD_OPT1\t\t\t1\n#define XGBE_SFP_EXTD_OPT1_RX_LOS\t\tBIT(1)\n#define XGBE_SFP_EXTD_OPT1_TX_FAULT\t\tBIT(3)\n\n#define XGBE_SFP_EXTD_DIAG\t\t\t28\n#define XGBE_SFP_EXTD_DIAG_ADDR_CHANGE\t\tBIT(2)\n\n#define XGBE_SFP_EXTD_SFF_8472\t\t\t30\n\n#define XGBE_SFP_EXTD_CC\t\t\t31\n\nstruct xgbe_sfp_eeprom {\n\tu8 base[64];\n\tu8 extd[32];\n\tu8 vendor[32];\n};\n\n#define XGBE_SFP_DIAGS_SUPPORTED(_x)\t\t\t\\\n\t((_x)->extd[XGBE_SFP_EXTD_SFF_8472] &&\t\t\\\n\t !((_x)->extd[XGBE_SFP_EXTD_DIAG] & XGBE_SFP_EXTD_DIAG_ADDR_CHANGE))\n\n#define XGBE_SFP_EEPROM_BASE_LEN\t256\n#define XGBE_SFP_EEPROM_DIAG_LEN\t256\n#define XGBE_SFP_EEPROM_MAX\t\t(XGBE_SFP_EEPROM_BASE_LEN +\t\\\n\t\t\t\t\t XGBE_SFP_EEPROM_DIAG_LEN)\n\n#define XGBE_BEL_FUSE_VENDOR\t\"BEL-FUSE        \"\n#define XGBE_BEL_FUSE_PARTNO\t\"1GBT-SFP06      \"\n\n#define XGBE_MOLEX_VENDOR\t\"Molex Inc.      \"\n\nstruct xgbe_sfp_ascii {\n\tunion {\n\t\tchar vendor[XGBE_SFP_BASE_VENDOR_NAME_LEN + 1];\n\t\tchar partno[XGBE_SFP_BASE_VENDOR_PN_LEN + 1];\n\t\tchar rev[XGBE_SFP_BASE_VENDOR_REV_LEN + 1];\n\t\tchar serno[XGBE_SFP_BASE_VENDOR_SN_LEN + 1];\n\t} u;\n};\n\n \nenum xgbe_mdio_reset {\n\tXGBE_MDIO_RESET_NONE = 0,\n\tXGBE_MDIO_RESET_I2C_GPIO,\n\tXGBE_MDIO_RESET_INT_GPIO,\n\tXGBE_MDIO_RESET_MAX,\n};\n\n \nenum xgbe_phy_redrv_if {\n\tXGBE_PHY_REDRV_IF_MDIO = 0,\n\tXGBE_PHY_REDRV_IF_I2C,\n\tXGBE_PHY_REDRV_IF_MAX,\n};\n\nenum xgbe_phy_redrv_model {\n\tXGBE_PHY_REDRV_MODEL_4223 = 0,\n\tXGBE_PHY_REDRV_MODEL_4227,\n\tXGBE_PHY_REDRV_MODEL_MAX,\n};\n\nenum xgbe_phy_redrv_mode {\n\tXGBE_PHY_REDRV_MODE_CX = 5,\n\tXGBE_PHY_REDRV_MODE_SR = 9,\n};\n\n#define XGBE_PHY_REDRV_MODE_REG\t0x12b0\n\n \nstruct xgbe_phy_data {\n\tenum xgbe_port_mode port_mode;\n\n\tunsigned int port_id;\n\n\tunsigned int port_speeds;\n\n\tenum xgbe_conn_type conn_type;\n\n\tenum xgbe_mode cur_mode;\n\tenum xgbe_mode start_mode;\n\n\tunsigned int rrc_count;\n\n\tunsigned int mdio_addr;\n\n\t \n\tenum xgbe_sfp_comm sfp_comm;\n\tunsigned int sfp_mux_address;\n\tunsigned int sfp_mux_channel;\n\n\tunsigned int sfp_gpio_address;\n\tunsigned int sfp_gpio_mask;\n\tunsigned int sfp_gpio_inputs;\n\tunsigned int sfp_gpio_rx_los;\n\tunsigned int sfp_gpio_tx_fault;\n\tunsigned int sfp_gpio_mod_absent;\n\tunsigned int sfp_gpio_rate_select;\n\n\tunsigned int sfp_rx_los;\n\tunsigned int sfp_tx_fault;\n\tunsigned int sfp_mod_absent;\n\tunsigned int sfp_changed;\n\tunsigned int sfp_phy_avail;\n\tunsigned int sfp_cable_len;\n\tenum xgbe_sfp_base sfp_base;\n\tenum xgbe_sfp_cable sfp_cable;\n\tenum xgbe_sfp_speed sfp_speed;\n\tstruct xgbe_sfp_eeprom sfp_eeprom;\n\n\t \n\tenum xgbe_mdio_mode phydev_mode;\n\tstruct mii_bus *mii;\n\tstruct phy_device *phydev;\n\tenum xgbe_mdio_reset mdio_reset;\n\tunsigned int mdio_reset_addr;\n\tunsigned int mdio_reset_gpio;\n\n\t \n\tunsigned int redrv;\n\tunsigned int redrv_if;\n\tunsigned int redrv_addr;\n\tunsigned int redrv_lane;\n\tunsigned int redrv_model;\n\n\t \n\tunsigned int phy_cdr_notrack;\n\tunsigned int phy_cdr_delay;\n};\n\n \nstatic DEFINE_MUTEX(xgbe_phy_comm_lock);\n\nstatic enum xgbe_an_mode xgbe_phy_an_mode(struct xgbe_prv_data *pdata);\nstatic void xgbe_phy_rrc(struct xgbe_prv_data *pdata);\nstatic void xgbe_phy_perform_ratechange(struct xgbe_prv_data *pdata,\n\t\t\t\t\tenum xgbe_mb_cmd cmd,\n\t\t\t\t\tenum xgbe_mb_subcmd sub_cmd);\n\nstatic int xgbe_phy_i2c_xfer(struct xgbe_prv_data *pdata,\n\t\t\t     struct xgbe_i2c_op *i2c_op)\n{\n\treturn pdata->i2c_if.i2c_xfer(pdata, i2c_op);\n}\n\nstatic int xgbe_phy_redrv_write(struct xgbe_prv_data *pdata, unsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tstruct xgbe_i2c_op i2c_op;\n\t__be16 *redrv_val;\n\tu8 redrv_data[5], csum;\n\tunsigned int i, retry;\n\tint ret;\n\n\t \n\tredrv_data[0] = ((reg >> 8) & 0xff) << 1;\n\tredrv_data[1] = reg & 0xff;\n\tredrv_val = (__be16 *)&redrv_data[2];\n\t*redrv_val = cpu_to_be16(val);\n\n\t \n\tcsum = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tcsum += redrv_data[i];\n\t\tif (redrv_data[i] > csum)\n\t\t\tcsum++;\n\t}\n\tredrv_data[4] = ~csum;\n\n\tretry = 1;\nagain1:\n\ti2c_op.cmd = XGBE_I2C_CMD_WRITE;\n\ti2c_op.target = phy_data->redrv_addr;\n\ti2c_op.len = sizeof(redrv_data);\n\ti2c_op.buf = redrv_data;\n\tret = xgbe_phy_i2c_xfer(pdata, &i2c_op);\n\tif (ret) {\n\t\tif ((ret == -EAGAIN) && retry--)\n\t\t\tgoto again1;\n\n\t\treturn ret;\n\t}\n\n\tretry = 1;\nagain2:\n\ti2c_op.cmd = XGBE_I2C_CMD_READ;\n\ti2c_op.target = phy_data->redrv_addr;\n\ti2c_op.len = 1;\n\ti2c_op.buf = redrv_data;\n\tret = xgbe_phy_i2c_xfer(pdata, &i2c_op);\n\tif (ret) {\n\t\tif ((ret == -EAGAIN) && retry--)\n\t\t\tgoto again2;\n\n\t\treturn ret;\n\t}\n\n\tif (redrv_data[0] != 0xff) {\n\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t  \"Redriver write checksum error\\n\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_i2c_write(struct xgbe_prv_data *pdata, unsigned int target,\n\t\t\t      void *val, unsigned int val_len)\n{\n\tstruct xgbe_i2c_op i2c_op;\n\tint retry, ret;\n\n\tretry = 1;\nagain:\n\t \n\ti2c_op.cmd = XGBE_I2C_CMD_WRITE;\n\ti2c_op.target = target;\n\ti2c_op.len = val_len;\n\ti2c_op.buf = val;\n\tret = xgbe_phy_i2c_xfer(pdata, &i2c_op);\n\tif ((ret == -EAGAIN) && retry--)\n\t\tgoto again;\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_i2c_read(struct xgbe_prv_data *pdata, unsigned int target,\n\t\t\t     void *reg, unsigned int reg_len,\n\t\t\t     void *val, unsigned int val_len)\n{\n\tstruct xgbe_i2c_op i2c_op;\n\tint retry, ret;\n\n\tretry = 1;\nagain1:\n\t \n\ti2c_op.cmd = XGBE_I2C_CMD_WRITE;\n\ti2c_op.target = target;\n\ti2c_op.len = reg_len;\n\ti2c_op.buf = reg;\n\tret = xgbe_phy_i2c_xfer(pdata, &i2c_op);\n\tif (ret) {\n\t\tif ((ret == -EAGAIN) && retry--)\n\t\t\tgoto again1;\n\n\t\treturn ret;\n\t}\n\n\tretry = 1;\nagain2:\n\t \n\ti2c_op.cmd = XGBE_I2C_CMD_READ;\n\ti2c_op.target = target;\n\ti2c_op.len = val_len;\n\ti2c_op.buf = val;\n\tret = xgbe_phy_i2c_xfer(pdata, &i2c_op);\n\tif ((ret == -EAGAIN) && retry--)\n\t\tgoto again2;\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_sfp_put_mux(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tstruct xgbe_i2c_op i2c_op;\n\tu8 mux_channel;\n\n\tif (phy_data->sfp_comm == XGBE_SFP_COMM_DIRECT)\n\t\treturn 0;\n\n\t \n\tmux_channel = 0;\n\ti2c_op.cmd = XGBE_I2C_CMD_WRITE;\n\ti2c_op.target = phy_data->sfp_mux_address;\n\ti2c_op.len = sizeof(mux_channel);\n\ti2c_op.buf = &mux_channel;\n\n\treturn xgbe_phy_i2c_xfer(pdata, &i2c_op);\n}\n\nstatic int xgbe_phy_sfp_get_mux(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tstruct xgbe_i2c_op i2c_op;\n\tu8 mux_channel;\n\n\tif (phy_data->sfp_comm == XGBE_SFP_COMM_DIRECT)\n\t\treturn 0;\n\n\t \n\tmux_channel = 1 << phy_data->sfp_mux_channel;\n\ti2c_op.cmd = XGBE_I2C_CMD_WRITE;\n\ti2c_op.target = phy_data->sfp_mux_address;\n\ti2c_op.len = sizeof(mux_channel);\n\ti2c_op.buf = &mux_channel;\n\n\treturn xgbe_phy_i2c_xfer(pdata, &i2c_op);\n}\n\nstatic void xgbe_phy_put_comm_ownership(struct xgbe_prv_data *pdata)\n{\n\tmutex_unlock(&xgbe_phy_comm_lock);\n}\n\nstatic int xgbe_phy_get_comm_ownership(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned long timeout;\n\tunsigned int mutex_id;\n\n\t \n\tmutex_lock(&xgbe_phy_comm_lock);\n\n\t \n\tXP_IOWRITE(pdata, XP_I2C_MUTEX, XGBE_MUTEX_RELEASE);\n\tXP_IOWRITE(pdata, XP_MDIO_MUTEX, XGBE_MUTEX_RELEASE);\n\n\t \n\tmutex_id = 0;\n\tXP_SET_BITS(mutex_id, XP_I2C_MUTEX, ID, phy_data->port_id);\n\tXP_SET_BITS(mutex_id, XP_I2C_MUTEX, ACTIVE, 1);\n\n\ttimeout = jiffies + (5 * HZ);\n\twhile (time_before(jiffies, timeout)) {\n\t\t \n\t\tif (XP_IOREAD(pdata, XP_I2C_MUTEX) ||\n\t\t    XP_IOREAD(pdata, XP_MDIO_MUTEX)) {\n\t\t\tusleep_range(100, 200);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tXP_IOWRITE(pdata, XP_I2C_MUTEX, mutex_id);\n\t\tXP_IOWRITE(pdata, XP_MDIO_MUTEX, mutex_id);\n\n\t\treturn 0;\n\t}\n\n\tmutex_unlock(&xgbe_phy_comm_lock);\n\n\tnetdev_err(pdata->netdev, \"unable to obtain hardware mutexes\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int xgbe_phy_mdio_mii_write_c22(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t       int reg, u16 val)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (phy_data->phydev_mode != XGBE_MDIO_MODE_CL22)\n\t\treturn -EOPNOTSUPP;\n\n\treturn pdata->hw_if.write_ext_mii_regs_c22(pdata, addr, reg, val);\n}\n\nstatic int xgbe_phy_mdio_mii_write_c45(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t       int devad, int reg, u16 val)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (phy_data->phydev_mode != XGBE_MDIO_MODE_CL45)\n\t\treturn -EOPNOTSUPP;\n\n\treturn pdata->hw_if.write_ext_mii_regs_c45(pdata, addr, devad,\n\t\t\t\t\t\t   reg, val);\n}\n\nstatic int xgbe_phy_i2c_mii_write(struct xgbe_prv_data *pdata, int reg, u16 val)\n{\n\t__be16 *mii_val;\n\tu8 mii_data[3];\n\tint ret;\n\n\tret = xgbe_phy_sfp_get_mux(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tmii_data[0] = reg & 0xff;\n\tmii_val = (__be16 *)&mii_data[1];\n\t*mii_val = cpu_to_be16(val);\n\n\tret = xgbe_phy_i2c_write(pdata, XGBE_SFP_PHY_ADDRESS,\n\t\t\t\t mii_data, sizeof(mii_data));\n\n\txgbe_phy_sfp_put_mux(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_mii_write_c22(struct mii_bus *mii, int addr, int reg,\n\t\t\t\t  u16 val)\n{\n\tstruct xgbe_prv_data *pdata = mii->priv;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy_data->conn_type == XGBE_CONN_TYPE_SFP)\n\t\tret = xgbe_phy_i2c_mii_write(pdata, reg, val);\n\telse if (phy_data->conn_type & XGBE_CONN_TYPE_MDIO)\n\t\tret = xgbe_phy_mdio_mii_write_c22(pdata, addr, reg, val);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\txgbe_phy_put_comm_ownership(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_mii_write_c45(struct mii_bus *mii, int addr, int devad,\n\t\t\t\t  int reg, u16 val)\n{\n\tstruct xgbe_prv_data *pdata = mii->priv;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy_data->conn_type == XGBE_CONN_TYPE_SFP)\n\t\tret = -EOPNOTSUPP;\n\telse if (phy_data->conn_type & XGBE_CONN_TYPE_MDIO)\n\t\tret = xgbe_phy_mdio_mii_write_c45(pdata, addr, devad, reg, val);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\txgbe_phy_put_comm_ownership(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_mdio_mii_read_c22(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t      int reg)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (phy_data->phydev_mode != XGBE_MDIO_MODE_CL22)\n\t\treturn -EOPNOTSUPP;\n\n\treturn pdata->hw_if.read_ext_mii_regs_c22(pdata, addr, reg);\n}\n\nstatic int xgbe_phy_mdio_mii_read_c45(struct xgbe_prv_data *pdata, int addr,\n\t\t\t\t      int devad, int reg)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (phy_data->phydev_mode != XGBE_MDIO_MODE_CL45)\n\t\treturn -EOPNOTSUPP;\n\n\treturn pdata->hw_if.read_ext_mii_regs_c45(pdata, addr, devad, reg);\n}\n\nstatic int xgbe_phy_i2c_mii_read(struct xgbe_prv_data *pdata, int reg)\n{\n\t__be16 mii_val;\n\tu8 mii_reg;\n\tint ret;\n\n\tret = xgbe_phy_sfp_get_mux(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tmii_reg = reg;\n\tret = xgbe_phy_i2c_read(pdata, XGBE_SFP_PHY_ADDRESS,\n\t\t\t\t&mii_reg, sizeof(mii_reg),\n\t\t\t\t&mii_val, sizeof(mii_val));\n\tif (!ret)\n\t\tret = be16_to_cpu(mii_val);\n\n\txgbe_phy_sfp_put_mux(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_mii_read_c22(struct mii_bus *mii, int addr, int reg)\n{\n\tstruct xgbe_prv_data *pdata = mii->priv;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy_data->conn_type == XGBE_CONN_TYPE_SFP)\n\t\tret = xgbe_phy_i2c_mii_read(pdata, reg);\n\telse if (phy_data->conn_type & XGBE_CONN_TYPE_MDIO)\n\t\tret = xgbe_phy_mdio_mii_read_c22(pdata, addr, reg);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\txgbe_phy_put_comm_ownership(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_mii_read_c45(struct mii_bus *mii, int addr, int devad,\n\t\t\t\t int reg)\n{\n\tstruct xgbe_prv_data *pdata = mii->priv;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy_data->conn_type == XGBE_CONN_TYPE_SFP)\n\t\tret = -EOPNOTSUPP;\n\telse if (phy_data->conn_type & XGBE_CONN_TYPE_MDIO)\n\t\tret = xgbe_phy_mdio_mii_read_c45(pdata, addr, devad, reg);\n\telse\n\t\tret = -ENOTSUPP;\n\n\txgbe_phy_put_comm_ownership(pdata);\n\n\treturn ret;\n}\n\nstatic void xgbe_phy_sfp_phy_settings(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (!phy_data->sfp_mod_absent && !phy_data->sfp_changed)\n\t\treturn;\n\n\tXGBE_ZERO_SUP(lks);\n\n\tif (phy_data->sfp_mod_absent) {\n\t\tpdata->phy.speed = SPEED_UNKNOWN;\n\t\tpdata->phy.duplex = DUPLEX_UNKNOWN;\n\t\tpdata->phy.autoneg = AUTONEG_ENABLE;\n\t\tpdata->phy.pause_autoneg = AUTONEG_ENABLE;\n\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, TP);\n\t\tXGBE_SET_SUP(lks, FIBRE);\n\n\t\tXGBE_LM_COPY(lks, advertising, lks, supported);\n\n\t\treturn;\n\t}\n\n\tswitch (phy_data->sfp_base) {\n\tcase XGBE_SFP_BASE_1000_T:\n\tcase XGBE_SFP_BASE_1000_SX:\n\tcase XGBE_SFP_BASE_1000_LX:\n\tcase XGBE_SFP_BASE_1000_CX:\n\t\tpdata->phy.speed = SPEED_UNKNOWN;\n\t\tpdata->phy.duplex = DUPLEX_UNKNOWN;\n\t\tpdata->phy.autoneg = AUTONEG_ENABLE;\n\t\tpdata->phy.pause_autoneg = AUTONEG_ENABLE;\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tif (phy_data->sfp_base == XGBE_SFP_BASE_1000_T) {\n\t\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10)\n\t\t\t\tXGBE_SET_SUP(lks, 10baseT_Full);\n\t\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100)\n\t\t\t\tXGBE_SET_SUP(lks, 100baseT_Full);\n\t\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000)\n\t\t\t\tXGBE_SET_SUP(lks, 1000baseT_Full);\n\t\t} else {\n\t\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000)\n\t\t\t\tXGBE_SET_SUP(lks, 1000baseX_Full);\n\t\t}\n\t\tbreak;\n\tcase XGBE_SFP_BASE_10000_SR:\n\tcase XGBE_SFP_BASE_10000_LR:\n\tcase XGBE_SFP_BASE_10000_LRM:\n\tcase XGBE_SFP_BASE_10000_ER:\n\tcase XGBE_SFP_BASE_10000_CR:\n\t\tpdata->phy.speed = SPEED_10000;\n\t\tpdata->phy.duplex = DUPLEX_FULL;\n\t\tpdata->phy.autoneg = AUTONEG_DISABLE;\n\t\tpdata->phy.pause_autoneg = AUTONEG_DISABLE;\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000) {\n\t\t\tswitch (phy_data->sfp_base) {\n\t\t\tcase XGBE_SFP_BASE_10000_SR:\n\t\t\t\tXGBE_SET_SUP(lks, 10000baseSR_Full);\n\t\t\t\tbreak;\n\t\t\tcase XGBE_SFP_BASE_10000_LR:\n\t\t\t\tXGBE_SET_SUP(lks, 10000baseLR_Full);\n\t\t\t\tbreak;\n\t\t\tcase XGBE_SFP_BASE_10000_LRM:\n\t\t\t\tXGBE_SET_SUP(lks, 10000baseLRM_Full);\n\t\t\t\tbreak;\n\t\t\tcase XGBE_SFP_BASE_10000_ER:\n\t\t\t\tXGBE_SET_SUP(lks, 10000baseER_Full);\n\t\t\t\tbreak;\n\t\t\tcase XGBE_SFP_BASE_10000_CR:\n\t\t\t\tXGBE_SET_SUP(lks, 10000baseCR_Full);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpdata->phy.speed = SPEED_UNKNOWN;\n\t\tpdata->phy.duplex = DUPLEX_UNKNOWN;\n\t\tpdata->phy.autoneg = AUTONEG_DISABLE;\n\t\tpdata->phy.pause_autoneg = AUTONEG_DISABLE;\n\t\tbreak;\n\t}\n\n\tswitch (phy_data->sfp_base) {\n\tcase XGBE_SFP_BASE_1000_T:\n\tcase XGBE_SFP_BASE_1000_CX:\n\tcase XGBE_SFP_BASE_10000_CR:\n\t\tXGBE_SET_SUP(lks, TP);\n\t\tbreak;\n\tdefault:\n\t\tXGBE_SET_SUP(lks, FIBRE);\n\t\tbreak;\n\t}\n\n\tXGBE_LM_COPY(lks, advertising, lks, supported);\n}\n\nstatic bool xgbe_phy_sfp_bit_rate(struct xgbe_sfp_eeprom *sfp_eeprom,\n\t\t\t\t  enum xgbe_sfp_speed sfp_speed)\n{\n\tu8 *sfp_base, min;\n\n\tsfp_base = sfp_eeprom->base;\n\n\tswitch (sfp_speed) {\n\tcase XGBE_SFP_SPEED_1000:\n\t\tmin = XGBE_SFP_BASE_BR_1GBE_MIN;\n\t\tbreak;\n\tcase XGBE_SFP_SPEED_10000:\n\t\tmin = XGBE_SFP_BASE_BR_10GBE_MIN;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn sfp_base[XGBE_SFP_BASE_BR] >= min;\n}\n\nstatic void xgbe_phy_free_phy_device(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (phy_data->phydev) {\n\t\tphy_detach(phy_data->phydev);\n\t\tphy_device_remove(phy_data->phydev);\n\t\tphy_device_free(phy_data->phydev);\n\t\tphy_data->phydev = NULL;\n\t}\n}\n\nstatic bool xgbe_phy_finisar_phy_quirks(struct xgbe_prv_data *pdata)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported) = { 0, };\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int phy_id = phy_data->phydev->phy_id;\n\n\tif (phy_data->port_mode != XGBE_PORT_MODE_SFP)\n\t\treturn false;\n\n\tif ((phy_id & 0xfffffff0) != 0x01ff0cc0)\n\t\treturn false;\n\n\t \n\tphy_write(phy_data->phydev, 0x16, 0x0001);\n\tphy_write(phy_data->phydev, 0x00, 0x9140);\n\tphy_write(phy_data->phydev, 0x16, 0x0000);\n\n\t \n\tphy_write(phy_data->phydev, 0x1b, 0x9084);\n\tphy_write(phy_data->phydev, 0x09, 0x0e00);\n\tphy_write(phy_data->phydev, 0x00, 0x8140);\n\tphy_write(phy_data->phydev, 0x04, 0x0d01);\n\tphy_write(phy_data->phydev, 0x00, 0x9140);\n\n\tlinkmode_set_bit_array(phy_10_100_features_array,\n\t\t\t       ARRAY_SIZE(phy_10_100_features_array),\n\t\t\t       supported);\n\tlinkmode_set_bit_array(phy_gbit_features_array,\n\t\t\t       ARRAY_SIZE(phy_gbit_features_array),\n\t\t\t       supported);\n\n\tlinkmode_copy(phy_data->phydev->supported, supported);\n\n\tphy_support_asym_pause(phy_data->phydev);\n\n\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t  \"Finisar PHY quirk in place\\n\");\n\n\treturn true;\n}\n\nstatic bool xgbe_phy_belfuse_phy_quirks(struct xgbe_prv_data *pdata)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported) = { 0, };\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tstruct xgbe_sfp_eeprom *sfp_eeprom = &phy_data->sfp_eeprom;\n\tunsigned int phy_id = phy_data->phydev->phy_id;\n\tint reg;\n\n\tif (phy_data->port_mode != XGBE_PORT_MODE_SFP)\n\t\treturn false;\n\n\tif (memcmp(&sfp_eeprom->base[XGBE_SFP_BASE_VENDOR_NAME],\n\t\t   XGBE_BEL_FUSE_VENDOR, XGBE_SFP_BASE_VENDOR_NAME_LEN))\n\t\treturn false;\n\n\t \n\tpdata->an_again = 1;\n\n\tif (memcmp(&sfp_eeprom->base[XGBE_SFP_BASE_VENDOR_PN],\n\t\t   XGBE_BEL_FUSE_PARTNO, XGBE_SFP_BASE_VENDOR_PN_LEN))\n\t\treturn false;\n\n\tif ((phy_id & 0xfffffff0) != 0x03625d10)\n\t\treturn false;\n\n\t \n\tgenphy_soft_reset(phy_data->phydev);\n\n\t \n\tphy_write(phy_data->phydev, 0x18, 0x7007);\n\treg = phy_read(phy_data->phydev, 0x18);\n\tphy_write(phy_data->phydev, 0x18, reg & ~0x0080);\n\n\t \n\tphy_write(phy_data->phydev, 0x1c, 0x7c00);\n\treg = phy_read(phy_data->phydev, 0x1c);\n\treg &= 0x03ff;\n\treg &= ~0x0001;\n\tphy_write(phy_data->phydev, 0x1c, 0x8000 | 0x7c00 | reg | 0x0001);\n\n\t \n\treg = phy_read(phy_data->phydev, 0x00);\n\tphy_write(phy_data->phydev, 0x00, reg | 0x00800);\n\n\t \n\tphy_write(phy_data->phydev, 0x1c, 0x7c00);\n\treg = phy_read(phy_data->phydev, 0x1c);\n\treg &= 0x03ff;\n\treg &= ~0x0006;\n\tphy_write(phy_data->phydev, 0x1c, 0x8000 | 0x7c00 | reg | 0x0004);\n\n\t \n\treg = phy_read(phy_data->phydev, 0x00);\n\tphy_write(phy_data->phydev, 0x00, reg & ~0x00800);\n\n\t \n\tphy_write(phy_data->phydev, 0x1c, 0x7c00);\n\treg = phy_read(phy_data->phydev, 0x1c);\n\treg &= 0x03ff;\n\treg &= ~0x0001;\n\tphy_write(phy_data->phydev, 0x1c, 0x8000 | 0x7c00 | reg);\n\n\t \n\treg = phy_read(phy_data->phydev, 0x00);\n\tphy_write(phy_data->phydev, 0x00, reg & ~0x00800);\n\n\tlinkmode_set_bit_array(phy_10_100_features_array,\n\t\t\t       ARRAY_SIZE(phy_10_100_features_array),\n\t\t\t       supported);\n\tlinkmode_set_bit_array(phy_gbit_features_array,\n\t\t\t       ARRAY_SIZE(phy_gbit_features_array),\n\t\t\t       supported);\n\tlinkmode_copy(phy_data->phydev->supported, supported);\n\tphy_support_asym_pause(phy_data->phydev);\n\n\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t  \"BelFuse PHY quirk in place\\n\");\n\n\treturn true;\n}\n\nstatic void xgbe_phy_external_phy_quirks(struct xgbe_prv_data *pdata)\n{\n\tif (xgbe_phy_belfuse_phy_quirks(pdata))\n\t\treturn;\n\n\tif (xgbe_phy_finisar_phy_quirks(pdata))\n\t\treturn;\n}\n\nstatic int xgbe_phy_find_phy_device(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tstruct phy_device *phydev;\n\tint ret;\n\n\t \n\tif (phy_data->phydev)\n\t\treturn 0;\n\n\t \n\tpdata->an_again = 0;\n\n\t \n\tif (phy_data->phydev_mode == XGBE_MDIO_MODE_NONE)\n\t\treturn 0;\n\n\t \n\tif ((phy_data->port_mode == XGBE_PORT_MODE_SFP) &&\n\t    !phy_data->sfp_phy_avail)\n\t\treturn 0;\n\n\t \n\tret = pdata->hw_if.set_ext_mii_mode(pdata, phy_data->mdio_addr,\n\t\t\t\t\t    phy_data->phydev_mode);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev,\n\t\t\t   \"mdio port/clause not compatible (%u/%u)\\n\",\n\t\t\t   phy_data->mdio_addr, phy_data->phydev_mode);\n\t\treturn ret;\n\t}\n\n\t \n\tphydev = get_phy_device(phy_data->mii, phy_data->mdio_addr,\n\t\t\t\t(phy_data->phydev_mode == XGBE_MDIO_MODE_CL45));\n\tif (IS_ERR(phydev)) {\n\t\tnetdev_err(pdata->netdev, \"get_phy_device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tnetif_dbg(pdata, drv, pdata->netdev, \"external PHY id is %#010x\\n\",\n\t\t  phydev->phy_id);\n\n\t \n\n\tret = phy_device_register(phydev);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev, \"phy_device_register failed\\n\");\n\t\tphy_device_free(phydev);\n\t\treturn ret;\n\t}\n\n\tret = phy_attach_direct(pdata->netdev, phydev, phydev->dev_flags,\n\t\t\t\tPHY_INTERFACE_MODE_SGMII);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev, \"phy_attach_direct failed\\n\");\n\t\tphy_device_remove(phydev);\n\t\tphy_device_free(phydev);\n\t\treturn ret;\n\t}\n\tphy_data->phydev = phydev;\n\n\txgbe_phy_external_phy_quirks(pdata);\n\n\tlinkmode_and(phydev->advertising, phydev->advertising,\n\t\t     lks->link_modes.advertising);\n\n\tphy_start_aneg(phy_data->phydev);\n\n\treturn 0;\n}\n\nstatic void xgbe_phy_sfp_external_phy(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\tif (!phy_data->sfp_changed)\n\t\treturn;\n\n\tphy_data->sfp_phy_avail = 0;\n\n\tif (phy_data->sfp_base != XGBE_SFP_BASE_1000_T)\n\t\treturn;\n\n\t \n\tret = xgbe_phy_i2c_mii_read(pdata, MII_BMCR);\n\tif (ret < 0)\n\t\treturn;\n\n\t \n\tphy_data->sfp_phy_avail = 1;\n}\n\nstatic bool xgbe_phy_check_sfp_rx_los(struct xgbe_phy_data *phy_data)\n{\n\tu8 *sfp_extd = phy_data->sfp_eeprom.extd;\n\n\tif (!(sfp_extd[XGBE_SFP_EXTD_OPT1] & XGBE_SFP_EXTD_OPT1_RX_LOS))\n\t\treturn false;\n\n\tif (phy_data->sfp_gpio_mask & XGBE_GPIO_NO_RX_LOS)\n\t\treturn false;\n\n\tif (phy_data->sfp_gpio_inputs & (1 << phy_data->sfp_gpio_rx_los))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool xgbe_phy_check_sfp_tx_fault(struct xgbe_phy_data *phy_data)\n{\n\tu8 *sfp_extd = phy_data->sfp_eeprom.extd;\n\n\tif (!(sfp_extd[XGBE_SFP_EXTD_OPT1] & XGBE_SFP_EXTD_OPT1_TX_FAULT))\n\t\treturn false;\n\n\tif (phy_data->sfp_gpio_mask & XGBE_GPIO_NO_TX_FAULT)\n\t\treturn false;\n\n\tif (phy_data->sfp_gpio_inputs & (1 << phy_data->sfp_gpio_tx_fault))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool xgbe_phy_check_sfp_mod_absent(struct xgbe_phy_data *phy_data)\n{\n\tif (phy_data->sfp_gpio_mask & XGBE_GPIO_NO_MOD_ABSENT)\n\t\treturn false;\n\n\tif (phy_data->sfp_gpio_inputs & (1 << phy_data->sfp_gpio_mod_absent))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void xgbe_phy_sfp_parse_eeprom(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tstruct xgbe_sfp_eeprom *sfp_eeprom = &phy_data->sfp_eeprom;\n\tu8 *sfp_base;\n\n\tsfp_base = sfp_eeprom->base;\n\n\tif (sfp_base[XGBE_SFP_BASE_ID] != XGBE_SFP_ID_SFP)\n\t\treturn;\n\n\tif (sfp_base[XGBE_SFP_BASE_EXT_ID] != XGBE_SFP_EXT_ID_SFP)\n\t\treturn;\n\n\t \n\tphy_data->sfp_tx_fault = xgbe_phy_check_sfp_tx_fault(phy_data);\n\tphy_data->sfp_rx_los = xgbe_phy_check_sfp_rx_los(phy_data);\n\n\t \n\tif (sfp_base[XGBE_SFP_BASE_CABLE] & XGBE_SFP_BASE_CABLE_PASSIVE) {\n\t\tphy_data->sfp_cable = XGBE_SFP_CABLE_PASSIVE;\n\t\tphy_data->sfp_cable_len = sfp_base[XGBE_SFP_BASE_CU_CABLE_LEN];\n\t} else if (sfp_base[XGBE_SFP_BASE_CABLE] & XGBE_SFP_BASE_CABLE_ACTIVE) {\n\t\tphy_data->sfp_cable = XGBE_SFP_CABLE_ACTIVE;\n\t} else {\n\t\tphy_data->sfp_cable = XGBE_SFP_CABLE_FIBER;\n\t}\n\n\t \n\tif (phy_data->sfp_cable != XGBE_SFP_CABLE_FIBER &&\n\t    xgbe_phy_sfp_bit_rate(sfp_eeprom, XGBE_SFP_SPEED_10000))\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_10000_CR;\n\telse if (sfp_base[XGBE_SFP_BASE_10GBE_CC] & XGBE_SFP_BASE_10GBE_CC_SR)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_10000_SR;\n\telse if (sfp_base[XGBE_SFP_BASE_10GBE_CC] & XGBE_SFP_BASE_10GBE_CC_LR)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_10000_LR;\n\telse if (sfp_base[XGBE_SFP_BASE_10GBE_CC] & XGBE_SFP_BASE_10GBE_CC_LRM)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_10000_LRM;\n\telse if (sfp_base[XGBE_SFP_BASE_10GBE_CC] & XGBE_SFP_BASE_10GBE_CC_ER)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_10000_ER;\n\telse if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_1GBE_CC_SX)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_1000_SX;\n\telse if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_1GBE_CC_LX)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_1000_LX;\n\telse if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_1GBE_CC_CX)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_1000_CX;\n\telse if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_1GBE_CC_T)\n\t\tphy_data->sfp_base = XGBE_SFP_BASE_1000_T;\n\n\tswitch (phy_data->sfp_base) {\n\tcase XGBE_SFP_BASE_1000_T:\n\t\tphy_data->sfp_speed = XGBE_SFP_SPEED_100_1000;\n\t\tbreak;\n\tcase XGBE_SFP_BASE_1000_SX:\n\tcase XGBE_SFP_BASE_1000_LX:\n\tcase XGBE_SFP_BASE_1000_CX:\n\t\tphy_data->sfp_speed = XGBE_SFP_SPEED_1000;\n\t\tbreak;\n\tcase XGBE_SFP_BASE_10000_SR:\n\tcase XGBE_SFP_BASE_10000_LR:\n\tcase XGBE_SFP_BASE_10000_LRM:\n\tcase XGBE_SFP_BASE_10000_ER:\n\tcase XGBE_SFP_BASE_10000_CR:\n\t\tphy_data->sfp_speed = XGBE_SFP_SPEED_10000;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void xgbe_phy_sfp_eeprom_info(struct xgbe_prv_data *pdata,\n\t\t\t\t     struct xgbe_sfp_eeprom *sfp_eeprom)\n{\n\tstruct xgbe_sfp_ascii sfp_ascii;\n\tchar *sfp_data = (char *)&sfp_ascii;\n\n\tnetif_dbg(pdata, drv, pdata->netdev, \"SFP detected:\\n\");\n\tmemcpy(sfp_data, &sfp_eeprom->base[XGBE_SFP_BASE_VENDOR_NAME],\n\t       XGBE_SFP_BASE_VENDOR_NAME_LEN);\n\tsfp_data[XGBE_SFP_BASE_VENDOR_NAME_LEN] = '\\0';\n\tnetif_dbg(pdata, drv, pdata->netdev, \"  vendor:         %s\\n\",\n\t\t  sfp_data);\n\n\tmemcpy(sfp_data, &sfp_eeprom->base[XGBE_SFP_BASE_VENDOR_PN],\n\t       XGBE_SFP_BASE_VENDOR_PN_LEN);\n\tsfp_data[XGBE_SFP_BASE_VENDOR_PN_LEN] = '\\0';\n\tnetif_dbg(pdata, drv, pdata->netdev, \"  part number:    %s\\n\",\n\t\t  sfp_data);\n\n\tmemcpy(sfp_data, &sfp_eeprom->base[XGBE_SFP_BASE_VENDOR_REV],\n\t       XGBE_SFP_BASE_VENDOR_REV_LEN);\n\tsfp_data[XGBE_SFP_BASE_VENDOR_REV_LEN] = '\\0';\n\tnetif_dbg(pdata, drv, pdata->netdev, \"  revision level: %s\\n\",\n\t\t  sfp_data);\n\n\tmemcpy(sfp_data, &sfp_eeprom->extd[XGBE_SFP_BASE_VENDOR_SN],\n\t       XGBE_SFP_BASE_VENDOR_SN_LEN);\n\tsfp_data[XGBE_SFP_BASE_VENDOR_SN_LEN] = '\\0';\n\tnetif_dbg(pdata, drv, pdata->netdev, \"  serial number:  %s\\n\",\n\t\t  sfp_data);\n}\n\nstatic bool xgbe_phy_sfp_verify_eeprom(u8 cc_in, u8 *buf, unsigned int len)\n{\n\tu8 cc;\n\n\tfor (cc = 0; len; buf++, len--)\n\t\tcc += *buf;\n\n\treturn cc == cc_in;\n}\n\nstatic int xgbe_phy_sfp_read_eeprom(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tstruct xgbe_sfp_eeprom sfp_eeprom;\n\tu8 eeprom_addr;\n\tint ret;\n\n\tret = xgbe_phy_sfp_get_mux(pdata);\n\tif (ret) {\n\t\tdev_err_once(pdata->dev, \"%s: I2C error setting SFP MUX\\n\",\n\t\t\t     netdev_name(pdata->netdev));\n\t\treturn ret;\n\t}\n\n\t \n\teeprom_addr = 0;\n\tret = xgbe_phy_i2c_read(pdata, XGBE_SFP_SERIAL_ID_ADDRESS,\n\t\t\t\t&eeprom_addr, sizeof(eeprom_addr),\n\t\t\t\t&sfp_eeprom, sizeof(sfp_eeprom));\n\tif (ret) {\n\t\tdev_err_once(pdata->dev, \"%s: I2C error reading SFP EEPROM\\n\",\n\t\t\t     netdev_name(pdata->netdev));\n\t\tgoto put;\n\t}\n\n\t \n\tif (!xgbe_phy_sfp_verify_eeprom(sfp_eeprom.base[XGBE_SFP_BASE_CC],\n\t\t\t\t\tsfp_eeprom.base,\n\t\t\t\t\tsizeof(sfp_eeprom.base) - 1)) {\n\t\tret = -EINVAL;\n\t\tgoto put;\n\t}\n\n\tif (!xgbe_phy_sfp_verify_eeprom(sfp_eeprom.extd[XGBE_SFP_EXTD_CC],\n\t\t\t\t\tsfp_eeprom.extd,\n\t\t\t\t\tsizeof(sfp_eeprom.extd) - 1)) {\n\t\tret = -EINVAL;\n\t\tgoto put;\n\t}\n\n\t \n\tif (memcmp(&phy_data->sfp_eeprom, &sfp_eeprom, sizeof(sfp_eeprom))) {\n\t\tphy_data->sfp_changed = 1;\n\n\t\tif (netif_msg_drv(pdata))\n\t\t\txgbe_phy_sfp_eeprom_info(pdata, &sfp_eeprom);\n\n\t\tmemcpy(&phy_data->sfp_eeprom, &sfp_eeprom, sizeof(sfp_eeprom));\n\n\t\txgbe_phy_free_phy_device(pdata);\n\t} else {\n\t\tphy_data->sfp_changed = 0;\n\t}\n\nput:\n\txgbe_phy_sfp_put_mux(pdata);\n\n\treturn ret;\n}\n\nstatic void xgbe_phy_sfp_signals(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tu8 gpio_reg, gpio_ports[2];\n\tint ret;\n\n\t \n\tgpio_reg = 0;\n\tret = xgbe_phy_i2c_read(pdata, phy_data->sfp_gpio_address,\n\t\t\t\t&gpio_reg, sizeof(gpio_reg),\n\t\t\t\tgpio_ports, sizeof(gpio_ports));\n\tif (ret) {\n\t\tdev_err_once(pdata->dev, \"%s: I2C error reading SFP GPIOs\\n\",\n\t\t\t     netdev_name(pdata->netdev));\n\t\treturn;\n\t}\n\n\tphy_data->sfp_gpio_inputs = (gpio_ports[1] << 8) | gpio_ports[0];\n\n\tphy_data->sfp_mod_absent = xgbe_phy_check_sfp_mod_absent(phy_data);\n}\n\nstatic void xgbe_phy_sfp_mod_absent(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_free_phy_device(pdata);\n\n\tphy_data->sfp_mod_absent = 1;\n\tphy_data->sfp_phy_avail = 0;\n\tmemset(&phy_data->sfp_eeprom, 0, sizeof(phy_data->sfp_eeprom));\n}\n\nstatic void xgbe_phy_sfp_reset(struct xgbe_phy_data *phy_data)\n{\n\tphy_data->sfp_rx_los = 0;\n\tphy_data->sfp_tx_fault = 0;\n\tphy_data->sfp_mod_absent = 1;\n\tphy_data->sfp_base = XGBE_SFP_BASE_UNKNOWN;\n\tphy_data->sfp_cable = XGBE_SFP_CABLE_UNKNOWN;\n\tphy_data->sfp_speed = XGBE_SFP_SPEED_UNKNOWN;\n}\n\nstatic void xgbe_phy_sfp_detect(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\t \n\txgbe_phy_sfp_reset(phy_data);\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret)\n\t\treturn;\n\n\t \n\txgbe_phy_sfp_signals(pdata);\n\tif (phy_data->sfp_mod_absent) {\n\t\txgbe_phy_sfp_mod_absent(pdata);\n\t\tgoto put;\n\t}\n\n\tret = xgbe_phy_sfp_read_eeprom(pdata);\n\tif (ret) {\n\t\t \n\t\txgbe_phy_sfp_reset(phy_data);\n\t\txgbe_phy_sfp_mod_absent(pdata);\n\t\tgoto put;\n\t}\n\n\txgbe_phy_sfp_parse_eeprom(pdata);\n\n\txgbe_phy_sfp_external_phy(pdata);\n\nput:\n\txgbe_phy_sfp_phy_settings(pdata);\n\n\txgbe_phy_put_comm_ownership(pdata);\n}\n\nstatic int xgbe_phy_module_eeprom(struct xgbe_prv_data *pdata,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tu8 eeprom_addr, eeprom_data[XGBE_SFP_EEPROM_MAX];\n\tstruct xgbe_sfp_eeprom *sfp_eeprom;\n\tunsigned int i, j, rem;\n\tint ret;\n\n\trem = eeprom->len;\n\n\tif (!eeprom->len) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif ((eeprom->offset + eeprom->len) > XGBE_SFP_EEPROM_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (phy_data->port_mode != XGBE_PORT_MODE_SFP) {\n\t\tret = -ENXIO;\n\t\tgoto done;\n\t}\n\n\tif (!netif_running(pdata->netdev)) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (phy_data->sfp_mod_absent) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tret = xgbe_phy_sfp_get_mux(pdata);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev, \"I2C error setting SFP MUX\\n\");\n\t\tret = -EIO;\n\t\tgoto put_own;\n\t}\n\n\t \n\teeprom_addr = 0;\n\tret = xgbe_phy_i2c_read(pdata, XGBE_SFP_SERIAL_ID_ADDRESS,\n\t\t\t\t&eeprom_addr, sizeof(eeprom_addr),\n\t\t\t\teeprom_data, XGBE_SFP_EEPROM_BASE_LEN);\n\tif (ret) {\n\t\tnetdev_err(pdata->netdev,\n\t\t\t   \"I2C error reading SFP EEPROM\\n\");\n\t\tret = -EIO;\n\t\tgoto put_mux;\n\t}\n\n\tsfp_eeprom = (struct xgbe_sfp_eeprom *)eeprom_data;\n\n\tif (XGBE_SFP_DIAGS_SUPPORTED(sfp_eeprom)) {\n\t\t \n\t\teeprom_addr = 0;\n\t\tret = xgbe_phy_i2c_read(pdata, XGBE_SFP_DIAG_INFO_ADDRESS,\n\t\t\t\t\t&eeprom_addr, sizeof(eeprom_addr),\n\t\t\t\t\teeprom_data + XGBE_SFP_EEPROM_BASE_LEN,\n\t\t\t\t\tXGBE_SFP_EEPROM_DIAG_LEN);\n\t\tif (ret) {\n\t\t\tnetdev_err(pdata->netdev,\n\t\t\t\t   \"I2C error reading SFP DIAGS\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto put_mux;\n\t\t}\n\t}\n\n\tfor (i = 0, j = eeprom->offset; i < eeprom->len; i++, j++) {\n\t\tif ((j >= XGBE_SFP_EEPROM_BASE_LEN) &&\n\t\t    !XGBE_SFP_DIAGS_SUPPORTED(sfp_eeprom))\n\t\t\tbreak;\n\n\t\tdata[i] = eeprom_data[j];\n\t\trem--;\n\t}\n\nput_mux:\n\txgbe_phy_sfp_put_mux(pdata);\n\nput_own:\n\txgbe_phy_put_comm_ownership(pdata);\n\ndone:\n\teeprom->len -= rem;\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_module_info(struct xgbe_prv_data *pdata,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (phy_data->port_mode != XGBE_PORT_MODE_SFP)\n\t\treturn -ENXIO;\n\n\tif (!netif_running(pdata->netdev))\n\t\treturn -EIO;\n\n\tif (phy_data->sfp_mod_absent)\n\t\treturn -EIO;\n\n\tif (XGBE_SFP_DIAGS_SUPPORTED(&phy_data->sfp_eeprom)) {\n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t} else {\n\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t}\n\n\treturn 0;\n}\n\nstatic void xgbe_phy_phydev_flowctrl(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tu16 lcl_adv = 0, rmt_adv = 0;\n\tu8 fc;\n\n\tpdata->phy.tx_pause = 0;\n\tpdata->phy.rx_pause = 0;\n\n\tif (!phy_data->phydev)\n\t\treturn;\n\n\tlcl_adv = linkmode_adv_to_lcl_adv_t(phy_data->phydev->advertising);\n\n\tif (phy_data->phydev->pause) {\n\t\tXGBE_SET_LP_ADV(lks, Pause);\n\t\trmt_adv |= LPA_PAUSE_CAP;\n\t}\n\tif (phy_data->phydev->asym_pause) {\n\t\tXGBE_SET_LP_ADV(lks, Asym_Pause);\n\t\trmt_adv |= LPA_PAUSE_ASYM;\n\t}\n\n\tfc = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);\n\tif (fc & FLOW_CTRL_TX)\n\t\tpdata->phy.tx_pause = 1;\n\tif (fc & FLOW_CTRL_RX)\n\t\tpdata->phy.rx_pause = 1;\n}\n\nstatic enum xgbe_mode xgbe_phy_an37_sgmii_outcome(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tenum xgbe_mode mode;\n\n\tXGBE_SET_LP_ADV(lks, Autoneg);\n\tXGBE_SET_LP_ADV(lks, TP);\n\n\t \n\tif (pdata->phy.pause_autoneg)\n\t\txgbe_phy_phydev_flowctrl(pdata);\n\n\tswitch (pdata->an_status & XGBE_SGMII_AN_LINK_SPEED) {\n\tcase XGBE_SGMII_AN_LINK_SPEED_10:\n\t\tif (pdata->an_status & XGBE_SGMII_AN_LINK_DUPLEX) {\n\t\t\tXGBE_SET_LP_ADV(lks, 10baseT_Full);\n\t\t\tmode = XGBE_MODE_SGMII_10;\n\t\t} else {\n\t\t\t \n\t\t\tXGBE_SET_LP_ADV(lks, 10baseT_Half);\n\t\t\tmode = XGBE_MODE_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tcase XGBE_SGMII_AN_LINK_SPEED_100:\n\t\tif (pdata->an_status & XGBE_SGMII_AN_LINK_DUPLEX) {\n\t\t\tXGBE_SET_LP_ADV(lks, 100baseT_Full);\n\t\t\tmode = XGBE_MODE_SGMII_100;\n\t\t} else {\n\t\t\t \n\t\t\tXGBE_SET_LP_ADV(lks, 100baseT_Half);\n\t\t\tmode = XGBE_MODE_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tcase XGBE_SGMII_AN_LINK_SPEED_1000:\n\t\tif (pdata->an_status & XGBE_SGMII_AN_LINK_DUPLEX) {\n\t\t\tXGBE_SET_LP_ADV(lks, 1000baseT_Full);\n\t\t\tmode = XGBE_MODE_SGMII_1000;\n\t\t} else {\n\t\t\t \n\t\t\tXGBE_SET_LP_ADV(lks, 1000baseT_Half);\n\t\t\tmode = XGBE_MODE_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmode = XGBE_MODE_UNKNOWN;\n\t}\n\n\treturn mode;\n}\n\nstatic enum xgbe_mode xgbe_phy_an37_outcome(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tenum xgbe_mode mode;\n\tunsigned int ad_reg, lp_reg;\n\n\tXGBE_SET_LP_ADV(lks, Autoneg);\n\tXGBE_SET_LP_ADV(lks, FIBRE);\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_LP_ABILITY);\n\tif (lp_reg & 0x100)\n\t\tXGBE_SET_LP_ADV(lks, Pause);\n\tif (lp_reg & 0x80)\n\t\tXGBE_SET_LP_ADV(lks, Asym_Pause);\n\n\tif (pdata->phy.pause_autoneg) {\n\t\t \n\t\tpdata->phy.tx_pause = 0;\n\t\tpdata->phy.rx_pause = 0;\n\n\t\tif (ad_reg & lp_reg & 0x100) {\n\t\t\tpdata->phy.tx_pause = 1;\n\t\t\tpdata->phy.rx_pause = 1;\n\t\t} else if (ad_reg & lp_reg & 0x80) {\n\t\t\tif (ad_reg & 0x100)\n\t\t\t\tpdata->phy.rx_pause = 1;\n\t\t\telse if (lp_reg & 0x100)\n\t\t\t\tpdata->phy.tx_pause = 1;\n\t\t}\n\t}\n\n\tif (lp_reg & 0x20)\n\t\tXGBE_SET_LP_ADV(lks, 1000baseX_Full);\n\n\t \n\tad_reg &= lp_reg;\n\tmode = (ad_reg & 0x20) ? XGBE_MODE_X : XGBE_MODE_UNKNOWN;\n\n\treturn mode;\n}\n\nstatic enum xgbe_mode xgbe_phy_an73_redrv_outcome(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tenum xgbe_mode mode;\n\tunsigned int ad_reg, lp_reg;\n\n\tXGBE_SET_LP_ADV(lks, Autoneg);\n\tXGBE_SET_LP_ADV(lks, Backplane);\n\n\t \n\tif (pdata->phy.pause_autoneg)\n\t\txgbe_phy_phydev_flowctrl(pdata);\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);\n\tif (lp_reg & 0x80)\n\t\tXGBE_SET_LP_ADV(lks, 10000baseKR_Full);\n\tif (lp_reg & 0x20)\n\t\tXGBE_SET_LP_ADV(lks, 1000baseKX_Full);\n\n\tad_reg &= lp_reg;\n\tif (ad_reg & 0x80) {\n\t\tswitch (phy_data->port_mode) {\n\t\tcase XGBE_PORT_MODE_BACKPLANE:\n\t\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\t\tmode = XGBE_MODE_KR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmode = XGBE_MODE_SFI;\n\t\t\tbreak;\n\t\t}\n\t} else if (ad_reg & 0x20) {\n\t\tswitch (phy_data->port_mode) {\n\t\tcase XGBE_PORT_MODE_BACKPLANE:\n\t\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\t\tmode = XGBE_MODE_KX_1000;\n\t\t\tbreak;\n\t\tcase XGBE_PORT_MODE_1000BASE_X:\n\t\t\tmode = XGBE_MODE_X;\n\t\t\tbreak;\n\t\tcase XGBE_PORT_MODE_SFP:\n\t\t\tswitch (phy_data->sfp_base) {\n\t\t\tcase XGBE_SFP_BASE_1000_T:\n\t\t\t\tif (phy_data->phydev &&\n\t\t\t\t    (phy_data->phydev->speed == SPEED_10))\n\t\t\t\t\tmode = XGBE_MODE_SGMII_10;\n\t\t\t\telse if (phy_data->phydev &&\n\t\t\t\t\t (phy_data->phydev->speed == SPEED_100))\n\t\t\t\t\tmode = XGBE_MODE_SGMII_100;\n\t\t\t\telse\n\t\t\t\t\tmode = XGBE_MODE_SGMII_1000;\n\t\t\t\tbreak;\n\t\t\tcase XGBE_SFP_BASE_1000_SX:\n\t\t\tcase XGBE_SFP_BASE_1000_LX:\n\t\t\tcase XGBE_SFP_BASE_1000_CX:\n\t\t\tdefault:\n\t\t\t\tmode = XGBE_MODE_X;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (phy_data->phydev &&\n\t\t\t    (phy_data->phydev->speed == SPEED_10))\n\t\t\t\tmode = XGBE_MODE_SGMII_10;\n\t\t\telse if (phy_data->phydev &&\n\t\t\t\t (phy_data->phydev->speed == SPEED_100))\n\t\t\t\tmode = XGBE_MODE_SGMII_100;\n\t\t\telse\n\t\t\t\tmode = XGBE_MODE_SGMII_1000;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmode = XGBE_MODE_UNKNOWN;\n\t}\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);\n\tif (lp_reg & 0xc000)\n\t\tXGBE_SET_LP_ADV(lks, 10000baseR_FEC);\n\n\treturn mode;\n}\n\nstatic enum xgbe_mode xgbe_phy_an73_outcome(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tenum xgbe_mode mode;\n\tunsigned int ad_reg, lp_reg;\n\n\tXGBE_SET_LP_ADV(lks, Autoneg);\n\tXGBE_SET_LP_ADV(lks, Backplane);\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA);\n\tif (lp_reg & 0x400)\n\t\tXGBE_SET_LP_ADV(lks, Pause);\n\tif (lp_reg & 0x800)\n\t\tXGBE_SET_LP_ADV(lks, Asym_Pause);\n\n\tif (pdata->phy.pause_autoneg) {\n\t\t \n\t\tpdata->phy.tx_pause = 0;\n\t\tpdata->phy.rx_pause = 0;\n\n\t\tif (ad_reg & lp_reg & 0x400) {\n\t\t\tpdata->phy.tx_pause = 1;\n\t\t\tpdata->phy.rx_pause = 1;\n\t\t} else if (ad_reg & lp_reg & 0x800) {\n\t\t\tif (ad_reg & 0x400)\n\t\t\t\tpdata->phy.rx_pause = 1;\n\t\t\telse if (lp_reg & 0x400)\n\t\t\t\tpdata->phy.tx_pause = 1;\n\t\t}\n\t}\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);\n\tif (lp_reg & 0x80)\n\t\tXGBE_SET_LP_ADV(lks, 10000baseKR_Full);\n\tif (lp_reg & 0x20)\n\t\tXGBE_SET_LP_ADV(lks, 1000baseKX_Full);\n\n\tad_reg &= lp_reg;\n\tif (ad_reg & 0x80)\n\t\tmode = XGBE_MODE_KR;\n\telse if (ad_reg & 0x20)\n\t\tmode = XGBE_MODE_KX_1000;\n\telse\n\t\tmode = XGBE_MODE_UNKNOWN;\n\n\t \n\tad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);\n\tlp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);\n\tif (lp_reg & 0xc000)\n\t\tXGBE_SET_LP_ADV(lks, 10000baseR_FEC);\n\n\treturn mode;\n}\n\nstatic enum xgbe_mode xgbe_phy_an_outcome(struct xgbe_prv_data *pdata)\n{\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\t\treturn xgbe_phy_an73_outcome(pdata);\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\treturn xgbe_phy_an73_redrv_outcome(pdata);\n\tcase XGBE_AN_MODE_CL37:\n\t\treturn xgbe_phy_an37_outcome(pdata);\n\tcase XGBE_AN_MODE_CL37_SGMII:\n\t\treturn xgbe_phy_an37_sgmii_outcome(pdata);\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic void xgbe_phy_an_advertising(struct xgbe_prv_data *pdata,\n\t\t\t\t    struct ethtool_link_ksettings *dlks)\n{\n\tstruct ethtool_link_ksettings *slks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tXGBE_LM_COPY(dlks, advertising, slks, advertising);\n\n\t \n\tif (!phy_data->redrv)\n\t\treturn;\n\n\t \n\tXGBE_CLR_ADV(dlks, 1000baseKX_Full);\n\tXGBE_CLR_ADV(dlks, 10000baseKR_Full);\n\n\t \n\tif (pdata->fec_ability & MDIO_PMA_10GBR_FECABLE_ABLE)\n\t\tXGBE_SET_ADV(dlks, 10000baseR_FEC);\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\tXGBE_SET_ADV(dlks, 10000baseKR_Full);\n\t\tbreak;\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\tXGBE_SET_ADV(dlks, 1000baseKX_Full);\n\t\tbreak;\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\tcase XGBE_PORT_MODE_NBASE_T:\n\t\tXGBE_SET_ADV(dlks, 1000baseKX_Full);\n\t\tbreak;\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\tif (phy_data->phydev &&\n\t\t    (phy_data->phydev->speed == SPEED_10000))\n\t\t\tXGBE_SET_ADV(dlks, 10000baseKR_Full);\n\t\telse if (phy_data->phydev &&\n\t\t\t (phy_data->phydev->speed == SPEED_2500))\n\t\t\tXGBE_SET_ADV(dlks, 2500baseX_Full);\n\t\telse\n\t\t\tXGBE_SET_ADV(dlks, 1000baseKX_Full);\n\t\tbreak;\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\tXGBE_SET_ADV(dlks, 10000baseKR_Full);\n\t\tbreak;\n\tcase XGBE_PORT_MODE_SFP:\n\t\tswitch (phy_data->sfp_base) {\n\t\tcase XGBE_SFP_BASE_1000_T:\n\t\tcase XGBE_SFP_BASE_1000_SX:\n\t\tcase XGBE_SFP_BASE_1000_LX:\n\t\tcase XGBE_SFP_BASE_1000_CX:\n\t\t\tXGBE_SET_ADV(dlks, 1000baseKX_Full);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXGBE_SET_ADV(dlks, 10000baseKR_Full);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tXGBE_SET_ADV(dlks, 10000baseKR_Full);\n\t\tbreak;\n\t}\n}\n\nstatic int xgbe_phy_an_config(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\tret = xgbe_phy_find_phy_device(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!phy_data->phydev)\n\t\treturn 0;\n\n\tphy_data->phydev->autoneg = pdata->phy.autoneg;\n\tlinkmode_and(phy_data->phydev->advertising,\n\t\t     phy_data->phydev->supported,\n\t\t     lks->link_modes.advertising);\n\n\tif (pdata->phy.autoneg != AUTONEG_ENABLE) {\n\t\tphy_data->phydev->speed = pdata->phy.speed;\n\t\tphy_data->phydev->duplex = pdata->phy.duplex;\n\t}\n\n\tret = phy_start_aneg(phy_data->phydev);\n\n\treturn ret;\n}\n\nstatic enum xgbe_an_mode xgbe_phy_an_sfp_mode(struct xgbe_phy_data *phy_data)\n{\n\tswitch (phy_data->sfp_base) {\n\tcase XGBE_SFP_BASE_1000_T:\n\t\treturn XGBE_AN_MODE_CL37_SGMII;\n\tcase XGBE_SFP_BASE_1000_SX:\n\tcase XGBE_SFP_BASE_1000_LX:\n\tcase XGBE_SFP_BASE_1000_CX:\n\t\treturn XGBE_AN_MODE_CL37;\n\tdefault:\n\t\treturn XGBE_AN_MODE_NONE;\n\t}\n}\n\nstatic enum xgbe_an_mode xgbe_phy_an_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\t \n\tif (phy_data->redrv)\n\t\treturn XGBE_AN_MODE_CL73_REDRV;\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\t\treturn XGBE_AN_MODE_CL73;\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\treturn XGBE_AN_MODE_NONE;\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\t\treturn XGBE_AN_MODE_CL37_SGMII;\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\t\treturn XGBE_AN_MODE_CL37;\n\tcase XGBE_PORT_MODE_NBASE_T:\n\t\treturn XGBE_AN_MODE_CL37_SGMII;\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\treturn XGBE_AN_MODE_CL73;\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\treturn XGBE_AN_MODE_NONE;\n\tcase XGBE_PORT_MODE_SFP:\n\t\treturn xgbe_phy_an_sfp_mode(phy_data);\n\tdefault:\n\t\treturn XGBE_AN_MODE_NONE;\n\t}\n}\n\nstatic int xgbe_phy_set_redrv_mode_mdio(struct xgbe_prv_data *pdata,\n\t\t\t\t\tenum xgbe_phy_redrv_mode mode)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tu16 redrv_reg, redrv_val;\n\n\tredrv_reg = XGBE_PHY_REDRV_MODE_REG + (phy_data->redrv_lane * 0x1000);\n\tredrv_val = (u16)mode;\n\n\treturn pdata->hw_if.write_ext_mii_regs_c22(pdata, phy_data->redrv_addr,\n\t\t\t\t\t\t   redrv_reg, redrv_val);\n}\n\nstatic int xgbe_phy_set_redrv_mode_i2c(struct xgbe_prv_data *pdata,\n\t\t\t\t       enum xgbe_phy_redrv_mode mode)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int redrv_reg;\n\tint ret;\n\n\t \n\tredrv_reg = XGBE_PHY_REDRV_MODE_REG + (phy_data->redrv_lane * 0x1000);\n\n\tret = xgbe_phy_redrv_write(pdata, redrv_reg, mode);\n\n\treturn ret;\n}\n\nstatic void xgbe_phy_set_redrv_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tenum xgbe_phy_redrv_mode mode;\n\tint ret;\n\n\tif (!phy_data->redrv)\n\t\treturn;\n\n\tmode = XGBE_PHY_REDRV_MODE_CX;\n\tif ((phy_data->port_mode == XGBE_PORT_MODE_SFP) &&\n\t    (phy_data->sfp_base != XGBE_SFP_BASE_1000_CX) &&\n\t    (phy_data->sfp_base != XGBE_SFP_BASE_10000_CR))\n\t\tmode = XGBE_PHY_REDRV_MODE_SR;\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret)\n\t\treturn;\n\n\tif (phy_data->redrv_if)\n\t\txgbe_phy_set_redrv_mode_i2c(pdata, mode);\n\telse\n\t\txgbe_phy_set_redrv_mode_mdio(pdata, mode);\n\n\txgbe_phy_put_comm_ownership(pdata);\n}\n\n#define MAX_RX_ADAPT_RETRIES\t\t1\n#define XGBE_PMA_RX_VAL_SIG_MASK\t(XGBE_PMA_RX_SIG_DET_0_MASK | \\\n\t\t\t\t\t XGBE_PMA_RX_VALID_0_MASK)\n\nstatic void xgbe_set_rx_adap_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t  enum xgbe_mode mode)\n{\n\tif (pdata->rx_adapt_retries++ >= MAX_RX_ADAPT_RETRIES) {\n\t\tpdata->rx_adapt_retries = 0;\n\t\treturn;\n\t}\n\n\txgbe_phy_perform_ratechange(pdata,\n\t\t\t\t    mode == XGBE_MODE_KR ?\n\t\t\t\t    XGBE_MB_CMD_SET_10G_KR :\n\t\t\t\t    XGBE_MB_CMD_SET_10G_SFI,\n\t\t\t\t    XGBE_MB_SUBCMD_RX_ADAP);\n}\n\nstatic void xgbe_rx_adaptation(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int reg;\n\n\t \n\tXMDIO_WRITE_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_RX_EQ_CTRL4,\n\t\t\t XGBE_PMA_RX_AD_REQ_MASK, XGBE_PMA_RX_AD_REQ_ENABLE);\n\n\t \n\tmsleep(200);\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_PHY_RX_EQ_CEU);\n\n\t \n\tXMDIO_WRITE_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_RX_EQ_CTRL4,\n\t\t\t XGBE_PMA_RX_AD_REQ_MASK, XGBE_PMA_RX_AD_REQ_DISABLE);\n\n\t \n\tif ((reg & XGBE_PMA_CFF_UPDT_MASK) != XGBE_PMA_CFF_UPDT_MASK)\n\t\tgoto set_mode;\n\n\t \n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);\n\tif (reg & MDIO_STAT1_LSTATUS) {\n\t\t \n\t\tnetif_dbg(pdata, link, pdata->netdev, \"Block_lock done\");\n\t\tpdata->rx_adapt_done = true;\n\t\tpdata->mode_set = false;\n\t\treturn;\n\t}\n\nset_mode:\n\txgbe_set_rx_adap_mode(pdata, phy_data->cur_mode);\n}\n\nstatic void xgbe_phy_rx_adaptation(struct xgbe_prv_data *pdata)\n{\n\tunsigned int reg;\n\nrx_adapt_reinit:\n\treg = XMDIO_READ_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_RX_LSTS,\n\t\t\t      XGBE_PMA_RX_VAL_SIG_MASK);\n\n\t \n\tif ((reg & XGBE_PMA_RX_VAL_SIG_MASK) != XGBE_PMA_RX_VAL_SIG_MASK) {\n\t\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t\t  \"RX_VALID or LF_SIGDET is unset, issue rrc\");\n\t\txgbe_phy_rrc(pdata);\n\t\tif (pdata->rx_adapt_retries++ >= MAX_RX_ADAPT_RETRIES) {\n\t\t\tpdata->rx_adapt_retries = 0;\n\t\t\treturn;\n\t\t}\n\t\tgoto rx_adapt_reinit;\n\t}\n\n\t \n\txgbe_rx_adaptation(pdata);\n}\n\nstatic void xgbe_phy_rx_reset(struct xgbe_prv_data *pdata)\n{\n\tint reg;\n\n\treg = XMDIO_READ_BITS(pdata, MDIO_MMD_PCS, MDIO_PCS_DIGITAL_STAT,\n\t\t\t      XGBE_PCS_PSEQ_STATE_MASK);\n\tif (reg == XGBE_PCS_PSEQ_STATE_POWER_GOOD) {\n\t\t \n\t\tXMDIO_WRITE_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_RX_CTRL1,\n\t\t\t\t XGBE_PMA_RX_RST_0_MASK, XGBE_PMA_RX_RST_0_RESET_ON);\n\t\tndelay(20);\n\t\tXMDIO_WRITE_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_RX_CTRL1,\n\t\t\t\t XGBE_PMA_RX_RST_0_MASK, XGBE_PMA_RX_RST_0_RESET_OFF);\n\t\tusleep_range(40, 50);\n\t\tnetif_err(pdata, link, pdata->netdev, \"firmware mailbox reset performed\\n\");\n\t}\n}\n\nstatic void xgbe_phy_pll_ctrl(struct xgbe_prv_data *pdata, bool enable)\n{\n\t \n\tif (pdata->phy.autoneg != AUTONEG_DISABLE)\n\t\treturn;\n\n\tXMDIO_WRITE_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_VEND2_PMA_MISC_CTRL0,\n\t\t\t XGBE_PMA_PLL_CTRL_MASK,\n\t\t\t enable ? XGBE_PMA_PLL_CTRL_ENABLE\n\t\t\t\t: XGBE_PMA_PLL_CTRL_DISABLE);\n\n\t \n\tusleep_range(100, 200);\n}\n\nstatic void xgbe_phy_perform_ratechange(struct xgbe_prv_data *pdata,\n\t\t\t\t\tenum xgbe_mb_cmd cmd, enum xgbe_mb_subcmd sub_cmd)\n{\n\tunsigned int s0 = 0;\n\tunsigned int wait;\n\n\t \n\txgbe_phy_pll_ctrl(pdata, false);\n\n\t \n\tif (XP_IOREAD_BITS(pdata, XP_DRIVER_INT_RO, STATUS)) {\n\t\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t\t  \"firmware mailbox not ready for command\\n\");\n\t\txgbe_phy_rx_reset(pdata);\n\t}\n\n\t \n\tXP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, COMMAND, cmd);\n\tXP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, SUB_COMMAND, sub_cmd);\n\n\t \n\tXP_IOWRITE(pdata, XP_DRIVER_SCRATCH_0, s0);\n\tXP_IOWRITE(pdata, XP_DRIVER_SCRATCH_1, 0);\n\tXP_IOWRITE_BITS(pdata, XP_DRIVER_INT_REQ, REQUEST, 1);\n\n\t \n\twait = XGBE_RATECHANGE_COUNT;\n\twhile (wait--) {\n\t\tif (!XP_IOREAD_BITS(pdata, XP_DRIVER_INT_RO, STATUS))\n\t\t\tgoto do_rx_adaptation;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t  \"firmware mailbox command did not complete\\n\");\n\n\t \n\txgbe_phy_rx_reset(pdata);\n\tgoto reenable_pll;\n\ndo_rx_adaptation:\n\tif (pdata->en_rx_adap && sub_cmd == XGBE_MB_SUBCMD_RX_ADAP &&\n\t    (cmd == XGBE_MB_CMD_SET_10G_KR || cmd == XGBE_MB_CMD_SET_10G_SFI)) {\n\t\tnetif_dbg(pdata, link, pdata->netdev,\n\t\t\t  \"Enabling RX adaptation\\n\");\n\t\tpdata->mode_set = true;\n\t\txgbe_phy_rx_adaptation(pdata);\n\t\t \n\t\treturn;\n\t}\n\nreenable_pll:\n\t \n\tif (cmd != XGBE_MB_CMD_POWER_OFF &&\n\t    cmd != XGBE_MB_CMD_RRC)\n\t\txgbe_phy_pll_ctrl(pdata, true);\n}\n\nstatic void xgbe_phy_rrc(struct xgbe_prv_data *pdata)\n{\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_RRC, XGBE_MB_SUBCMD_NONE);\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"receiver reset complete\\n\");\n}\n\nstatic void xgbe_phy_power_off(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_POWER_OFF, XGBE_MB_SUBCMD_NONE);\n\n\tphy_data->cur_mode = XGBE_MODE_UNKNOWN;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"phy powered off\\n\");\n}\n\nstatic bool enable_rx_adap(struct xgbe_prv_data *pdata, enum xgbe_mode mode)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int ver;\n\n\t \n\tver = XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER);\n\tif (ver < 0x30)\n\t\treturn false;\n\n\t \n\tif (phy_data->redrv &&\n\t    (phy_data->redrv_model == XGBE_PHY_REDRV_MODEL_4223 ||\n\t     phy_data->redrv_model == XGBE_PHY_REDRV_MODEL_4227))\n\t\treturn false;\n\n\t \n\tif (mode == XGBE_MODE_KR &&\n\t    phy_data->port_mode != XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG)\n\t\treturn false;\n\n\tpdata->en_rx_adap = 1;\n\treturn true;\n}\n\nstatic void xgbe_phy_sfi_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\tif (phy_data->sfp_cable != XGBE_SFP_CABLE_PASSIVE) {\n\t\tpdata->en_rx_adap = 0;\n\t\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_10G_SFI, XGBE_MB_SUBCMD_ACTIVE);\n\t} else if ((phy_data->sfp_cable == XGBE_SFP_CABLE_PASSIVE) &&\n\t\t   (enable_rx_adap(pdata, XGBE_MODE_SFI))) {\n\t\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_10G_SFI,\n\t\t\t\t\t    XGBE_MB_SUBCMD_RX_ADAP);\n\t} else {\n\t\tif (phy_data->sfp_cable_len <= 1)\n\t\t\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_10G_SFI,\n\t\t\t\t\t\t    XGBE_MB_SUBCMD_PASSIVE_1M);\n\t\telse if (phy_data->sfp_cable_len <= 3)\n\t\t\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_10G_SFI,\n\t\t\t\t\t\t    XGBE_MB_SUBCMD_PASSIVE_3M);\n\t\telse\n\t\t\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_10G_SFI,\n\t\t\t\t\t\t    XGBE_MB_SUBCMD_PASSIVE_OTHER);\n\t}\n\n\tphy_data->cur_mode = XGBE_MODE_SFI;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"10GbE SFI mode set\\n\");\n}\n\nstatic void xgbe_phy_x_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_1G, XGBE_MB_SUBCMD_1G_KX);\n\n\tphy_data->cur_mode = XGBE_MODE_X;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"1GbE X mode set\\n\");\n}\n\nstatic void xgbe_phy_sgmii_1000_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_1G, XGBE_MB_SUBCMD_1G_SGMII);\n\n\tphy_data->cur_mode = XGBE_MODE_SGMII_1000;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"1GbE SGMII mode set\\n\");\n}\n\nstatic void xgbe_phy_sgmii_100_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_1G, XGBE_MB_SUBCMD_100MBITS);\n\n\tphy_data->cur_mode = XGBE_MODE_SGMII_100;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"100MbE SGMII mode set\\n\");\n}\n\nstatic void xgbe_phy_sgmii_10_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_1G, XGBE_MB_SUBCMD_10MBITS);\n\n\tphy_data->cur_mode = XGBE_MODE_SGMII_10;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"10MbE SGMII mode set\\n\");\n}\n\nstatic void xgbe_phy_kr_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\tif (enable_rx_adap(pdata, XGBE_MODE_KR))\n\t\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_10G_KR,\n\t\t\t\t\t    XGBE_MB_SUBCMD_RX_ADAP);\n\telse\n\t\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_10G_KR,\n\t\t\t\t\t    XGBE_MB_SUBCMD_NONE);\n\n\tphy_data->cur_mode = XGBE_MODE_KR;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"10GbE KR mode set\\n\");\n}\n\nstatic void xgbe_phy_kx_2500_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_2_5G, XGBE_MB_SUBCMD_NONE);\n\n\tphy_data->cur_mode = XGBE_MODE_KX_2500;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"2.5GbE KX mode set\\n\");\n}\n\nstatic void xgbe_phy_kx_1000_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\txgbe_phy_set_redrv_mode(pdata);\n\n\t \n\txgbe_phy_perform_ratechange(pdata, XGBE_MB_CMD_SET_1G, XGBE_MB_SUBCMD_1G_KX);\n\n\tphy_data->cur_mode = XGBE_MODE_KX_1000;\n\n\tnetif_dbg(pdata, link, pdata->netdev, \"1GbE KX mode set\\n\");\n}\n\nstatic enum xgbe_mode xgbe_phy_cur_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\treturn phy_data->cur_mode;\n}\n\nstatic enum xgbe_mode xgbe_phy_switch_baset_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\t \n\tif (phy_data->port_mode != XGBE_PORT_MODE_10GBASE_T)\n\t\treturn xgbe_phy_cur_mode(pdata);\n\n\tswitch (xgbe_phy_cur_mode(pdata)) {\n\tcase XGBE_MODE_SGMII_10:\n\tcase XGBE_MODE_SGMII_100:\n\tcase XGBE_MODE_SGMII_1000:\n\t\treturn XGBE_MODE_KR;\n\tcase XGBE_MODE_KX_2500:\n\t\treturn XGBE_MODE_SGMII_1000;\n\tcase XGBE_MODE_KR:\n\tdefault:\n\t\treturn XGBE_MODE_KX_2500;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_switch_bp_2500_mode(struct xgbe_prv_data *pdata)\n{\n\treturn XGBE_MODE_KX_2500;\n}\n\nstatic enum xgbe_mode xgbe_phy_switch_bp_mode(struct xgbe_prv_data *pdata)\n{\n\t \n\tswitch (xgbe_phy_cur_mode(pdata)) {\n\tcase XGBE_MODE_KX_1000:\n\t\treturn XGBE_MODE_KR;\n\tcase XGBE_MODE_KR:\n\tdefault:\n\t\treturn XGBE_MODE_KX_1000;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_switch_mode(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\treturn xgbe_phy_switch_bp_mode(pdata);\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\treturn xgbe_phy_switch_bp_2500_mode(pdata);\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\tcase XGBE_PORT_MODE_NBASE_T:\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\treturn xgbe_phy_switch_baset_mode(pdata);\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\tcase XGBE_PORT_MODE_SFP:\n\t\t \n\t\treturn xgbe_phy_cur_mode(pdata);\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_get_basex_mode(struct xgbe_phy_data *phy_data,\n\t\t\t\t\t      int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\treturn XGBE_MODE_X;\n\tcase SPEED_10000:\n\t\treturn XGBE_MODE_KR;\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_get_baset_mode(struct xgbe_phy_data *phy_data,\n\t\t\t\t\t      int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\treturn XGBE_MODE_SGMII_10;\n\tcase SPEED_100:\n\t\treturn XGBE_MODE_SGMII_100;\n\tcase SPEED_1000:\n\t\treturn XGBE_MODE_SGMII_1000;\n\tcase SPEED_2500:\n\t\treturn XGBE_MODE_KX_2500;\n\tcase SPEED_10000:\n\t\treturn XGBE_MODE_KR;\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_get_sfp_mode(struct xgbe_phy_data *phy_data,\n\t\t\t\t\t    int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\treturn XGBE_MODE_SGMII_10;\n\tcase SPEED_100:\n\t\treturn XGBE_MODE_SGMII_100;\n\tcase SPEED_1000:\n\t\tif (phy_data->sfp_base == XGBE_SFP_BASE_1000_T)\n\t\t\treturn XGBE_MODE_SGMII_1000;\n\t\telse\n\t\t\treturn XGBE_MODE_X;\n\tcase SPEED_10000:\n\tcase SPEED_UNKNOWN:\n\t\treturn XGBE_MODE_SFI;\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_get_bp_2500_mode(int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_2500:\n\t\treturn XGBE_MODE_KX_2500;\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_get_bp_mode(int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\treturn XGBE_MODE_KX_1000;\n\tcase SPEED_10000:\n\t\treturn XGBE_MODE_KR;\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic enum xgbe_mode xgbe_phy_get_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t\tint speed)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\treturn xgbe_phy_get_bp_mode(speed);\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\treturn xgbe_phy_get_bp_2500_mode(speed);\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\tcase XGBE_PORT_MODE_NBASE_T:\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\treturn xgbe_phy_get_baset_mode(phy_data, speed);\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\treturn xgbe_phy_get_basex_mode(phy_data, speed);\n\tcase XGBE_PORT_MODE_SFP:\n\t\treturn xgbe_phy_get_sfp_mode(phy_data, speed);\n\tdefault:\n\t\treturn XGBE_MODE_UNKNOWN;\n\t}\n}\n\nstatic void xgbe_phy_set_mode(struct xgbe_prv_data *pdata, enum xgbe_mode mode)\n{\n\tswitch (mode) {\n\tcase XGBE_MODE_KX_1000:\n\t\txgbe_phy_kx_1000_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_KX_2500:\n\t\txgbe_phy_kx_2500_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_KR:\n\t\txgbe_phy_kr_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SGMII_10:\n\t\txgbe_phy_sgmii_10_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SGMII_100:\n\t\txgbe_phy_sgmii_100_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SGMII_1000:\n\t\txgbe_phy_sgmii_1000_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_X:\n\t\txgbe_phy_x_mode(pdata);\n\t\tbreak;\n\tcase XGBE_MODE_SFI:\n\t\txgbe_phy_sfi_mode(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool xgbe_phy_check_mode(struct xgbe_prv_data *pdata,\n\t\t\t\tenum xgbe_mode mode, bool advert)\n{\n\tif (pdata->phy.autoneg == AUTONEG_ENABLE) {\n\t\treturn advert;\n\t} else {\n\t\tenum xgbe_mode cur_mode;\n\n\t\tcur_mode = xgbe_phy_get_mode(pdata, pdata->phy.speed);\n\t\tif (cur_mode == mode)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool xgbe_phy_use_basex_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t    enum xgbe_mode mode)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\tswitch (mode) {\n\tcase XGBE_MODE_X:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 1000baseX_Full));\n\tcase XGBE_MODE_KR:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseKR_Full));\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_use_baset_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t    enum xgbe_mode mode)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\tswitch (mode) {\n\tcase XGBE_MODE_SGMII_10:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 10baseT_Full));\n\tcase XGBE_MODE_SGMII_100:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 100baseT_Full));\n\tcase XGBE_MODE_SGMII_1000:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 1000baseT_Full));\n\tcase XGBE_MODE_KX_2500:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 2500baseT_Full));\n\tcase XGBE_MODE_KR:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseT_Full));\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_use_sfp_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t  enum xgbe_mode mode)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (mode) {\n\tcase XGBE_MODE_X:\n\t\tif (phy_data->sfp_base == XGBE_SFP_BASE_1000_T)\n\t\t\treturn false;\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 1000baseX_Full));\n\tcase XGBE_MODE_SGMII_10:\n\t\tif (phy_data->sfp_base != XGBE_SFP_BASE_1000_T)\n\t\t\treturn false;\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 10baseT_Full));\n\tcase XGBE_MODE_SGMII_100:\n\t\tif (phy_data->sfp_base != XGBE_SFP_BASE_1000_T)\n\t\t\treturn false;\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 100baseT_Full));\n\tcase XGBE_MODE_SGMII_1000:\n\t\tif (phy_data->sfp_base != XGBE_SFP_BASE_1000_T)\n\t\t\treturn false;\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 1000baseT_Full));\n\tcase XGBE_MODE_SFI:\n\t\tif (phy_data->sfp_mod_absent)\n\t\t\treturn true;\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseSR_Full)  ||\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseLR_Full)  ||\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseLRM_Full) ||\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseER_Full)  ||\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseCR_Full));\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_use_bp_2500_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t      enum xgbe_mode mode)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\tswitch (mode) {\n\tcase XGBE_MODE_KX_2500:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 2500baseX_Full));\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_use_bp_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t enum xgbe_mode mode)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\n\tswitch (mode) {\n\tcase XGBE_MODE_KX_1000:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 1000baseKX_Full));\n\tcase XGBE_MODE_KR:\n\t\treturn xgbe_phy_check_mode(pdata, mode,\n\t\t\t\t\t   XGBE_ADV(lks, 10000baseKR_Full));\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_use_mode(struct xgbe_prv_data *pdata, enum xgbe_mode mode)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\treturn xgbe_phy_use_bp_mode(pdata, mode);\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\treturn xgbe_phy_use_bp_2500_mode(pdata, mode);\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\tcase XGBE_PORT_MODE_NBASE_T:\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\treturn xgbe_phy_use_baset_mode(pdata, mode);\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\treturn xgbe_phy_use_basex_mode(pdata, mode);\n\tcase XGBE_PORT_MODE_SFP:\n\t\treturn xgbe_phy_use_sfp_mode(pdata, mode);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_valid_speed_basex_mode(struct xgbe_phy_data *phy_data,\n\t\t\t\t\t    int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\treturn (phy_data->port_mode == XGBE_PORT_MODE_1000BASE_X);\n\tcase SPEED_10000:\n\t\treturn (phy_data->port_mode == XGBE_PORT_MODE_10GBASE_R);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_valid_speed_baset_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t\t    int speed)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int ver;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\t \n\t\tver = XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER);\n\t\treturn (ver == 0x21 || ver >= 0x30);\n\tcase SPEED_100:\n\tcase SPEED_1000:\n\t\treturn true;\n\tcase SPEED_2500:\n\t\treturn ((phy_data->port_mode == XGBE_PORT_MODE_10GBASE_T) ||\n\t\t\t(phy_data->port_mode == XGBE_PORT_MODE_NBASE_T));\n\tcase SPEED_10000:\n\t\treturn (phy_data->port_mode == XGBE_PORT_MODE_10GBASE_T);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_valid_speed_sfp_mode(struct xgbe_prv_data *pdata,\n\t\t\t\t\t  int speed)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int ver;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\t \n\t\tver = XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER);\n\t\treturn ((ver == 0x21 || ver >= 0x30) &&\n\t\t\t(phy_data->sfp_speed == XGBE_SFP_SPEED_100_1000));\n\tcase SPEED_100:\n\t\treturn (phy_data->sfp_speed == XGBE_SFP_SPEED_100_1000);\n\tcase SPEED_1000:\n\t\treturn ((phy_data->sfp_speed == XGBE_SFP_SPEED_100_1000) ||\n\t\t\t(phy_data->sfp_speed == XGBE_SFP_SPEED_1000));\n\tcase SPEED_10000:\n\t\treturn (phy_data->sfp_speed == XGBE_SFP_SPEED_10000);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_valid_speed_bp_2500_mode(int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_2500:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_valid_speed_bp_mode(int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_1000:\n\tcase SPEED_10000:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool xgbe_phy_valid_speed(struct xgbe_prv_data *pdata, int speed)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\treturn xgbe_phy_valid_speed_bp_mode(speed);\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\treturn xgbe_phy_valid_speed_bp_2500_mode(speed);\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\tcase XGBE_PORT_MODE_NBASE_T:\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\treturn xgbe_phy_valid_speed_baset_mode(pdata, speed);\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\treturn xgbe_phy_valid_speed_basex_mode(phy_data, speed);\n\tcase XGBE_PORT_MODE_SFP:\n\t\treturn xgbe_phy_valid_speed_sfp_mode(pdata, speed);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int xgbe_phy_link_status(struct xgbe_prv_data *pdata, int *an_restart)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int reg;\n\tint ret;\n\n\t*an_restart = 0;\n\n\tif (phy_data->port_mode == XGBE_PORT_MODE_SFP) {\n\t\t \n\t\txgbe_phy_sfp_detect(pdata);\n\n\t\tif (phy_data->sfp_changed) {\n\t\t\t*an_restart = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (phy_data->sfp_mod_absent || phy_data->sfp_rx_los) {\n\t\t\tif (pdata->en_rx_adap)\n\t\t\t\tpdata->rx_adapt_done = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (phy_data->phydev) {\n\t\t \n\t\tret = phy_read_status(phy_data->phydev);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\n\t\tif ((pdata->phy.autoneg == AUTONEG_ENABLE) &&\n\t\t    !phy_aneg_done(phy_data->phydev))\n\t\t\treturn 0;\n\n\t\tif (!phy_data->phydev->link)\n\t\t\treturn 0;\n\t}\n\n\t \n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);\n\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);\n\n\tif (pdata->en_rx_adap) {\n\t\t \n\t\tif ((reg & MDIO_STAT1_LSTATUS) && pdata->rx_adapt_done)\n\t\t\treturn 1;\n\t\t \n\t\tif (pdata->mode_set) {\n\t\t\txgbe_phy_rx_adaptation(pdata);\n\t\t} else {\n\t\t\tpdata->rx_adapt_done = false;\n\t\t\txgbe_phy_set_mode(pdata, phy_data->cur_mode);\n\t\t}\n\n\t\t \n\t\treg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);\n\t\tif ((reg & MDIO_STAT1_LSTATUS) && pdata->rx_adapt_done)\n\t\t\treturn 1;\n\t} else if (reg & MDIO_STAT1_LSTATUS)\n\t\treturn 1;\n\n\tif (pdata->phy.autoneg == AUTONEG_ENABLE &&\n\t    phy_data->port_mode == XGBE_PORT_MODE_BACKPLANE) {\n\t\tif (!test_bit(XGBE_LINK_INIT, &pdata->dev_state)) {\n\t\t\tnetif_carrier_off(pdata->netdev);\n\t\t\t*an_restart = 1;\n\t\t}\n\t}\n\n\t \n\tif (pdata->vdata->enable_rrc && phy_data->rrc_count++ > XGBE_RRC_FREQUENCY) {\n\t\tphy_data->rrc_count = 0;\n\t\txgbe_phy_rrc(pdata);\n\t}\n\n\treturn 0;\n}\n\nstatic void xgbe_phy_sfp_gpio_setup(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tphy_data->sfp_gpio_address = XGBE_GPIO_ADDRESS_PCA9555 +\n\t\t\t\t     XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\t GPIO_ADDR);\n\n\tphy_data->sfp_gpio_mask = XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t      GPIO_MASK);\n\n\tphy_data->sfp_gpio_rx_los = XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\tGPIO_RX_LOS);\n\tphy_data->sfp_gpio_tx_fault = XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\t  GPIO_TX_FAULT);\n\tphy_data->sfp_gpio_mod_absent = XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\t    GPIO_MOD_ABS);\n\tphy_data->sfp_gpio_rate_select = XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\t     GPIO_RATE_SELECT);\n\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(pdata->dev, \"SFP: gpio_address=%#x\\n\",\n\t\t\tphy_data->sfp_gpio_address);\n\t\tdev_dbg(pdata->dev, \"SFP: gpio_mask=%#x\\n\",\n\t\t\tphy_data->sfp_gpio_mask);\n\t\tdev_dbg(pdata->dev, \"SFP: gpio_rx_los=%u\\n\",\n\t\t\tphy_data->sfp_gpio_rx_los);\n\t\tdev_dbg(pdata->dev, \"SFP: gpio_tx_fault=%u\\n\",\n\t\t\tphy_data->sfp_gpio_tx_fault);\n\t\tdev_dbg(pdata->dev, \"SFP: gpio_mod_absent=%u\\n\",\n\t\t\tphy_data->sfp_gpio_mod_absent);\n\t\tdev_dbg(pdata->dev, \"SFP: gpio_rate_select=%u\\n\",\n\t\t\tphy_data->sfp_gpio_rate_select);\n\t}\n}\n\nstatic void xgbe_phy_sfp_comm_setup(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int mux_addr_hi, mux_addr_lo;\n\n\tmux_addr_hi = XP_GET_BITS(pdata->pp4, XP_PROP_4, MUX_ADDR_HI);\n\tmux_addr_lo = XP_GET_BITS(pdata->pp4, XP_PROP_4, MUX_ADDR_LO);\n\tif (mux_addr_lo == XGBE_SFP_DIRECT)\n\t\treturn;\n\n\tphy_data->sfp_comm = XGBE_SFP_COMM_PCA9545;\n\tphy_data->sfp_mux_address = (mux_addr_hi << 2) + mux_addr_lo;\n\tphy_data->sfp_mux_channel = XP_GET_BITS(pdata->pp4, XP_PROP_4,\n\t\t\t\t\t\tMUX_CHAN);\n\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(pdata->dev, \"SFP: mux_address=%#x\\n\",\n\t\t\tphy_data->sfp_mux_address);\n\t\tdev_dbg(pdata->dev, \"SFP: mux_channel=%u\\n\",\n\t\t\tphy_data->sfp_mux_channel);\n\t}\n}\n\nstatic void xgbe_phy_sfp_setup(struct xgbe_prv_data *pdata)\n{\n\txgbe_phy_sfp_comm_setup(pdata);\n\txgbe_phy_sfp_gpio_setup(pdata);\n}\n\nstatic int xgbe_phy_int_mdio_reset(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int ret;\n\n\tret = pdata->hw_if.set_gpio(pdata, phy_data->mdio_reset_gpio);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pdata->hw_if.clr_gpio(pdata, phy_data->mdio_reset_gpio);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_i2c_mdio_reset(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tu8 gpio_reg, gpio_ports[2], gpio_data[3];\n\tint ret;\n\n\t \n\tgpio_reg = 2;\n\tret = xgbe_phy_i2c_read(pdata, phy_data->mdio_reset_addr,\n\t\t\t\t&gpio_reg, sizeof(gpio_reg),\n\t\t\t\tgpio_ports, sizeof(gpio_ports));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgpio_data[0] = 2;\n\tgpio_data[1] = gpio_ports[0];\n\tgpio_data[2] = gpio_ports[1];\n\n\t \n\tif (phy_data->mdio_reset_gpio < 8)\n\t\tgpio_data[1] |= (1 << (phy_data->mdio_reset_gpio % 8));\n\telse\n\t\tgpio_data[2] |= (1 << (phy_data->mdio_reset_gpio % 8));\n\n\t \n\tret = xgbe_phy_i2c_write(pdata, phy_data->mdio_reset_addr,\n\t\t\t\t gpio_data, sizeof(gpio_data));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (phy_data->mdio_reset_gpio < 8)\n\t\tgpio_data[1] &= ~(1 << (phy_data->mdio_reset_gpio % 8));\n\telse\n\t\tgpio_data[2] &= ~(1 << (phy_data->mdio_reset_gpio % 8));\n\n\t \n\tret = xgbe_phy_i2c_write(pdata, phy_data->mdio_reset_addr,\n\t\t\t\t gpio_data, sizeof(gpio_data));\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_mdio_reset(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\tif (phy_data->conn_type != XGBE_CONN_TYPE_MDIO)\n\t\treturn 0;\n\n\tret = xgbe_phy_get_comm_ownership(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy_data->mdio_reset == XGBE_MDIO_RESET_I2C_GPIO)\n\t\tret = xgbe_phy_i2c_mdio_reset(pdata);\n\telse if (phy_data->mdio_reset == XGBE_MDIO_RESET_INT_GPIO)\n\t\tret = xgbe_phy_int_mdio_reset(pdata);\n\n\txgbe_phy_put_comm_ownership(pdata);\n\n\treturn ret;\n}\n\nstatic bool xgbe_phy_redrv_error(struct xgbe_phy_data *phy_data)\n{\n\tif (!phy_data->redrv)\n\t\treturn false;\n\n\tif (phy_data->redrv_if >= XGBE_PHY_REDRV_IF_MAX)\n\t\treturn true;\n\n\tswitch (phy_data->redrv_model) {\n\tcase XGBE_PHY_REDRV_MODEL_4223:\n\t\tif (phy_data->redrv_lane > 3)\n\t\t\treturn true;\n\t\tbreak;\n\tcase XGBE_PHY_REDRV_MODEL_4227:\n\t\tif (phy_data->redrv_lane > 1)\n\t\t\treturn true;\n\t\tbreak;\n\tdefault:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int xgbe_phy_mdio_reset_setup(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (phy_data->conn_type != XGBE_CONN_TYPE_MDIO)\n\t\treturn 0;\n\n\tphy_data->mdio_reset = XP_GET_BITS(pdata->pp3, XP_PROP_3, MDIO_RESET);\n\tswitch (phy_data->mdio_reset) {\n\tcase XGBE_MDIO_RESET_NONE:\n\tcase XGBE_MDIO_RESET_I2C_GPIO:\n\tcase XGBE_MDIO_RESET_INT_GPIO:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pdata->dev, \"unsupported MDIO reset (%#x)\\n\",\n\t\t\tphy_data->mdio_reset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (phy_data->mdio_reset == XGBE_MDIO_RESET_I2C_GPIO) {\n\t\tphy_data->mdio_reset_addr = XGBE_GPIO_ADDRESS_PCA9555 +\n\t\t\t\t\t    XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\t\tMDIO_RESET_I2C_ADDR);\n\t\tphy_data->mdio_reset_gpio = XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\t\tMDIO_RESET_I2C_GPIO);\n\t} else if (phy_data->mdio_reset == XGBE_MDIO_RESET_INT_GPIO) {\n\t\tphy_data->mdio_reset_gpio = XP_GET_BITS(pdata->pp3, XP_PROP_3,\n\t\t\t\t\t\t\tMDIO_RESET_INT_GPIO);\n\t}\n\n\treturn 0;\n}\n\nstatic bool xgbe_phy_port_mode_mismatch(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tunsigned int ver;\n\n\t \n\tver = XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER);\n\tif ((ver < 0x30 && ver != 0x21) && (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10))\n\t\treturn true;\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\tif ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000))\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_2500)\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\t\tif ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000))\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000)\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_NBASE_T:\n\t\tif ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_2500))\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\tif ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_2500) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000))\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000)\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_SFP:\n\t\tif ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||\n\t\t    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool xgbe_phy_conn_type_mismatch(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_BACKPLANE:\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\tif (phy_data->conn_type == XGBE_CONN_TYPE_BACKPLANE)\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_1000BASE_T:\n\tcase XGBE_PORT_MODE_1000BASE_X:\n\tcase XGBE_PORT_MODE_NBASE_T:\n\tcase XGBE_PORT_MODE_10GBASE_T:\n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\tif (phy_data->conn_type == XGBE_CONN_TYPE_MDIO)\n\t\t\treturn false;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_SFP:\n\t\tif (phy_data->conn_type == XGBE_CONN_TYPE_SFP)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool xgbe_phy_port_enabled(struct xgbe_prv_data *pdata)\n{\n\tif (!XP_GET_BITS(pdata->pp0, XP_PROP_0, PORT_SPEEDS))\n\t\treturn false;\n\tif (!XP_GET_BITS(pdata->pp0, XP_PROP_0, CONN_TYPE))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void xgbe_phy_cdr_track(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (!pdata->debugfs_an_cdr_workaround)\n\t\treturn;\n\n\tif (!phy_data->phy_cdr_notrack)\n\t\treturn;\n\n\tusleep_range(phy_data->phy_cdr_delay,\n\t\t     phy_data->phy_cdr_delay + 500);\n\n\tXMDIO_WRITE_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_VEND2_PMA_CDR_CONTROL,\n\t\t\t XGBE_PMA_CDR_TRACK_EN_MASK,\n\t\t\t XGBE_PMA_CDR_TRACK_EN_ON);\n\n\tphy_data->phy_cdr_notrack = 0;\n}\n\nstatic void xgbe_phy_cdr_notrack(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tif (!pdata->debugfs_an_cdr_workaround)\n\t\treturn;\n\n\tif (phy_data->phy_cdr_notrack)\n\t\treturn;\n\n\tXMDIO_WRITE_BITS(pdata, MDIO_MMD_PMAPMD, MDIO_VEND2_PMA_CDR_CONTROL,\n\t\t\t XGBE_PMA_CDR_TRACK_EN_MASK,\n\t\t\t XGBE_PMA_CDR_TRACK_EN_OFF);\n\n\txgbe_phy_rrc(pdata);\n\n\tphy_data->phy_cdr_notrack = 1;\n}\n\nstatic void xgbe_phy_kr_training_post(struct xgbe_prv_data *pdata)\n{\n\tif (!pdata->debugfs_an_cdr_track_early)\n\t\txgbe_phy_cdr_track(pdata);\n}\n\nstatic void xgbe_phy_kr_training_pre(struct xgbe_prv_data *pdata)\n{\n\tif (pdata->debugfs_an_cdr_track_early)\n\t\txgbe_phy_cdr_track(pdata);\n}\n\nstatic void xgbe_phy_an_post(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\tif (phy_data->cur_mode != XGBE_MODE_KR)\n\t\t\tbreak;\n\n\t\txgbe_phy_cdr_track(pdata);\n\n\t\tswitch (pdata->an_result) {\n\t\tcase XGBE_AN_READY:\n\t\tcase XGBE_AN_COMPLETE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (phy_data->phy_cdr_delay < XGBE_CDR_DELAY_MAX)\n\t\t\t\tphy_data->phy_cdr_delay += XGBE_CDR_DELAY_INC;\n\t\t\telse\n\t\t\t\tphy_data->phy_cdr_delay = XGBE_CDR_DELAY_INIT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void xgbe_phy_an_pre(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\tswitch (pdata->an_mode) {\n\tcase XGBE_AN_MODE_CL73:\n\tcase XGBE_AN_MODE_CL73_REDRV:\n\t\tif (phy_data->cur_mode != XGBE_MODE_KR)\n\t\t\tbreak;\n\n\t\txgbe_phy_cdr_notrack(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void xgbe_phy_stop(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\t \n\txgbe_phy_free_phy_device(pdata);\n\n\t \n\txgbe_phy_sfp_reset(phy_data);\n\txgbe_phy_sfp_mod_absent(pdata);\n\n\t \n\txgbe_phy_cdr_track(pdata);\n\n\t \n\txgbe_phy_power_off(pdata);\n\n\t \n\tpdata->i2c_if.i2c_stop(pdata);\n}\n\nstatic int xgbe_phy_start(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tint ret;\n\n\t \n\tret = pdata->i2c_if.i2c_start(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (phy_data->redrv && !phy_data->redrv_if) {\n\t\tret = pdata->hw_if.set_ext_mii_mode(pdata, phy_data->redrv_addr,\n\t\t\t\t\t\t    XGBE_MDIO_MODE_CL22);\n\t\tif (ret) {\n\t\t\tnetdev_err(pdata->netdev,\n\t\t\t\t   \"redriver mdio port not compatible (%u)\\n\",\n\t\t\t\t   phy_data->redrv_addr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\txgbe_phy_set_mode(pdata, phy_data->start_mode);\n\n\t \n\txgbe_phy_cdr_track(pdata);\n\n\t \n\tswitch (phy_data->port_mode) {\n\tcase XGBE_PORT_MODE_SFP:\n\t\txgbe_phy_sfp_detect(pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = xgbe_phy_find_phy_device(pdata);\n\tif (ret)\n\t\tgoto err_i2c;\n\n\treturn 0;\n\nerr_i2c:\n\tpdata->i2c_if.i2c_stop(pdata);\n\n\treturn ret;\n}\n\nstatic int xgbe_phy_reset(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\tenum xgbe_mode cur_mode;\n\tint ret;\n\n\t \n\tcur_mode = phy_data->cur_mode;\n\txgbe_phy_power_off(pdata);\n\txgbe_phy_set_mode(pdata, cur_mode);\n\n\tif (!phy_data->phydev)\n\t\treturn 0;\n\n\t \n\tret = xgbe_phy_mdio_reset(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_init_hw(phy_data->phydev);\n}\n\nstatic void xgbe_phy_exit(struct xgbe_prv_data *pdata)\n{\n\tstruct xgbe_phy_data *phy_data = pdata->phy_data;\n\n\t \n\tmdiobus_unregister(phy_data->mii);\n}\n\nstatic int xgbe_phy_init(struct xgbe_prv_data *pdata)\n{\n\tstruct ethtool_link_ksettings *lks = &pdata->phy.lks;\n\tstruct xgbe_phy_data *phy_data;\n\tstruct mii_bus *mii;\n\tint ret;\n\n\t \n\tif (!xgbe_phy_port_enabled(pdata)) {\n\t\tdev_info(pdata->dev, \"device is not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = pdata->i2c_if.i2c_init(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_data = devm_kzalloc(pdata->dev, sizeof(*phy_data), GFP_KERNEL);\n\tif (!phy_data)\n\t\treturn -ENOMEM;\n\tpdata->phy_data = phy_data;\n\n\tphy_data->port_mode = XP_GET_BITS(pdata->pp0, XP_PROP_0, PORT_MODE);\n\tphy_data->port_id = XP_GET_BITS(pdata->pp0, XP_PROP_0, PORT_ID);\n\tphy_data->port_speeds = XP_GET_BITS(pdata->pp0, XP_PROP_0, PORT_SPEEDS);\n\tphy_data->conn_type = XP_GET_BITS(pdata->pp0, XP_PROP_0, CONN_TYPE);\n\tphy_data->mdio_addr = XP_GET_BITS(pdata->pp0, XP_PROP_0, MDIO_ADDR);\n\tif (netif_msg_probe(pdata)) {\n\t\tdev_dbg(pdata->dev, \"port mode=%u\\n\", phy_data->port_mode);\n\t\tdev_dbg(pdata->dev, \"port id=%u\\n\", phy_data->port_id);\n\t\tdev_dbg(pdata->dev, \"port speeds=%#x\\n\", phy_data->port_speeds);\n\t\tdev_dbg(pdata->dev, \"conn type=%u\\n\", phy_data->conn_type);\n\t\tdev_dbg(pdata->dev, \"mdio addr=%u\\n\", phy_data->mdio_addr);\n\t}\n\n\tphy_data->redrv = XP_GET_BITS(pdata->pp4, XP_PROP_4, REDRV_PRESENT);\n\tphy_data->redrv_if = XP_GET_BITS(pdata->pp4, XP_PROP_4, REDRV_IF);\n\tphy_data->redrv_addr = XP_GET_BITS(pdata->pp4, XP_PROP_4, REDRV_ADDR);\n\tphy_data->redrv_lane = XP_GET_BITS(pdata->pp4, XP_PROP_4, REDRV_LANE);\n\tphy_data->redrv_model = XP_GET_BITS(pdata->pp4, XP_PROP_4, REDRV_MODEL);\n\tif (phy_data->redrv && netif_msg_probe(pdata)) {\n\t\tdev_dbg(pdata->dev, \"redrv present\\n\");\n\t\tdev_dbg(pdata->dev, \"redrv i/f=%u\\n\", phy_data->redrv_if);\n\t\tdev_dbg(pdata->dev, \"redrv addr=%#x\\n\", phy_data->redrv_addr);\n\t\tdev_dbg(pdata->dev, \"redrv lane=%u\\n\", phy_data->redrv_lane);\n\t\tdev_dbg(pdata->dev, \"redrv model=%u\\n\", phy_data->redrv_model);\n\t}\n\n\t \n\tif (xgbe_phy_conn_type_mismatch(pdata)) {\n\t\tdev_err(pdata->dev, \"phy mode/connection mismatch (%#x/%#x)\\n\",\n\t\t\tphy_data->port_mode, phy_data->conn_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (xgbe_phy_port_mode_mismatch(pdata)) {\n\t\tdev_err(pdata->dev, \"phy mode/speed mismatch (%#x/%#x)\\n\",\n\t\t\tphy_data->port_mode, phy_data->port_speeds);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = xgbe_phy_mdio_reset_setup(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (xgbe_phy_redrv_error(phy_data)) {\n\t\tdev_err(pdata->dev, \"phy re-driver settings error\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpdata->kr_redrv = phy_data->redrv;\n\n\t \n\tphy_data->cur_mode = XGBE_MODE_UNKNOWN;\n\n\t \n\tXGBE_ZERO_SUP(lks);\n\n\tswitch (phy_data->port_mode) {\n\t \n\tcase XGBE_PORT_MODE_BACKPLANE:\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tfallthrough;\n\tcase XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG:\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, Backplane);\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) {\n\t\t\tXGBE_SET_SUP(lks, 1000baseKX_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_KX_1000;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000) {\n\t\t\tXGBE_SET_SUP(lks, 10000baseKR_Full);\n\t\t\tif (pdata->fec_ability & MDIO_PMA_10GBR_FECABLE_ABLE)\n\t\t\t\tXGBE_SET_SUP(lks, 10000baseR_FEC);\n\t\t\tphy_data->start_mode = XGBE_MODE_KR;\n\t\t}\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_NONE;\n\t\tbreak;\n\tcase XGBE_PORT_MODE_BACKPLANE_2500:\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, Backplane);\n\t\tXGBE_SET_SUP(lks, 2500baseX_Full);\n\t\tphy_data->start_mode = XGBE_MODE_KX_2500;\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_NONE;\n\t\tbreak;\n\n\t \n\tcase XGBE_PORT_MODE_1000BASE_T:\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, TP);\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10) {\n\t\t\tXGBE_SET_SUP(lks, 10baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_10;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) {\n\t\t\tXGBE_SET_SUP(lks, 100baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_100;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) {\n\t\t\tXGBE_SET_SUP(lks, 1000baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_1000;\n\t\t}\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_CL22;\n\t\tbreak;\n\n\t \n\tcase XGBE_PORT_MODE_1000BASE_X:\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, FIBRE);\n\t\tXGBE_SET_SUP(lks, 1000baseX_Full);\n\t\tphy_data->start_mode = XGBE_MODE_X;\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_CL22;\n\t\tbreak;\n\n\t \n\tcase XGBE_PORT_MODE_NBASE_T:\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, TP);\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10) {\n\t\t\tXGBE_SET_SUP(lks, 10baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_10;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) {\n\t\t\tXGBE_SET_SUP(lks, 100baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_100;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) {\n\t\t\tXGBE_SET_SUP(lks, 1000baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_1000;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_2500) {\n\t\t\tXGBE_SET_SUP(lks, 2500baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_KX_2500;\n\t\t}\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_CL45;\n\t\tbreak;\n\n\t \n\tcase XGBE_PORT_MODE_10GBASE_T:\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, TP);\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10) {\n\t\t\tXGBE_SET_SUP(lks, 10baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_10;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) {\n\t\t\tXGBE_SET_SUP(lks, 100baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_100;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) {\n\t\t\tXGBE_SET_SUP(lks, 1000baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_1000;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_2500) {\n\t\t\tXGBE_SET_SUP(lks, 2500baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_KX_2500;\n\t\t}\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000) {\n\t\t\tXGBE_SET_SUP(lks, 10000baseT_Full);\n\t\t\tphy_data->start_mode = XGBE_MODE_KR;\n\t\t}\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_CL45;\n\t\tbreak;\n\n\t \n\tcase XGBE_PORT_MODE_10GBASE_R:\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, FIBRE);\n\t\tXGBE_SET_SUP(lks, 10000baseSR_Full);\n\t\tXGBE_SET_SUP(lks, 10000baseLR_Full);\n\t\tXGBE_SET_SUP(lks, 10000baseLRM_Full);\n\t\tXGBE_SET_SUP(lks, 10000baseER_Full);\n\t\tif (pdata->fec_ability & MDIO_PMA_10GBR_FECABLE_ABLE)\n\t\t\tXGBE_SET_SUP(lks, 10000baseR_FEC);\n\t\tphy_data->start_mode = XGBE_MODE_SFI;\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_NONE;\n\t\tbreak;\n\n\t \n\tcase XGBE_PORT_MODE_SFP:\n\t\tXGBE_SET_SUP(lks, Autoneg);\n\t\tXGBE_SET_SUP(lks, Pause);\n\t\tXGBE_SET_SUP(lks, Asym_Pause);\n\t\tXGBE_SET_SUP(lks, TP);\n\t\tXGBE_SET_SUP(lks, FIBRE);\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10)\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_10;\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100)\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_100;\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000)\n\t\t\tphy_data->start_mode = XGBE_MODE_SGMII_1000;\n\t\tif (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000)\n\t\t\tphy_data->start_mode = XGBE_MODE_SFI;\n\n\t\tphy_data->phydev_mode = XGBE_MDIO_MODE_CL22;\n\n\t\txgbe_phy_sfp_setup(pdata);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (netif_msg_probe(pdata))\n\t\tdev_dbg(pdata->dev, \"phy supported=0x%*pb\\n\",\n\t\t\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\tlks->link_modes.supported);\n\n\tif ((phy_data->conn_type & XGBE_CONN_TYPE_MDIO) &&\n\t    (phy_data->phydev_mode != XGBE_MDIO_MODE_NONE)) {\n\t\tret = pdata->hw_if.set_ext_mii_mode(pdata, phy_data->mdio_addr,\n\t\t\t\t\t\t    phy_data->phydev_mode);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev,\n\t\t\t\t\"mdio port/clause not compatible (%d/%u)\\n\",\n\t\t\t\tphy_data->mdio_addr, phy_data->phydev_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (phy_data->redrv && !phy_data->redrv_if) {\n\t\tret = pdata->hw_if.set_ext_mii_mode(pdata, phy_data->redrv_addr,\n\t\t\t\t\t\t    XGBE_MDIO_MODE_CL22);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev,\n\t\t\t\t\"redriver mdio port not compatible (%u)\\n\",\n\t\t\t\tphy_data->redrv_addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tphy_data->phy_cdr_delay = XGBE_CDR_DELAY_INIT;\n\n\t \n\tmii = devm_mdiobus_alloc(pdata->dev);\n\tif (!mii) {\n\t\tdev_err(pdata->dev, \"mdiobus_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmii->priv = pdata;\n\tmii->name = \"amd-xgbe-mii\";\n\tmii->read = xgbe_phy_mii_read_c22;\n\tmii->write = xgbe_phy_mii_write_c22;\n\tmii->read_c45 = xgbe_phy_mii_read_c45;\n\tmii->write_c45 = xgbe_phy_mii_write_c45;\n\tmii->parent = pdata->dev;\n\tmii->phy_mask = ~0;\n\tsnprintf(mii->id, sizeof(mii->id), \"%s\", dev_name(pdata->dev));\n\tret = mdiobus_register(mii);\n\tif (ret) {\n\t\tdev_err(pdata->dev, \"mdiobus_register failed\\n\");\n\t\treturn ret;\n\t}\n\tphy_data->mii = mii;\n\n\treturn 0;\n}\n\nvoid xgbe_init_function_ptrs_phy_v2(struct xgbe_phy_if *phy_if)\n{\n\tstruct xgbe_phy_impl_if *phy_impl = &phy_if->phy_impl;\n\n\tphy_impl->init\t\t\t= xgbe_phy_init;\n\tphy_impl->exit\t\t\t= xgbe_phy_exit;\n\n\tphy_impl->reset\t\t\t= xgbe_phy_reset;\n\tphy_impl->start\t\t\t= xgbe_phy_start;\n\tphy_impl->stop\t\t\t= xgbe_phy_stop;\n\n\tphy_impl->link_status\t\t= xgbe_phy_link_status;\n\n\tphy_impl->valid_speed\t\t= xgbe_phy_valid_speed;\n\n\tphy_impl->use_mode\t\t= xgbe_phy_use_mode;\n\tphy_impl->set_mode\t\t= xgbe_phy_set_mode;\n\tphy_impl->get_mode\t\t= xgbe_phy_get_mode;\n\tphy_impl->switch_mode\t\t= xgbe_phy_switch_mode;\n\tphy_impl->cur_mode\t\t= xgbe_phy_cur_mode;\n\n\tphy_impl->an_mode\t\t= xgbe_phy_an_mode;\n\n\tphy_impl->an_config\t\t= xgbe_phy_an_config;\n\n\tphy_impl->an_advertising\t= xgbe_phy_an_advertising;\n\n\tphy_impl->an_outcome\t\t= xgbe_phy_an_outcome;\n\n\tphy_impl->an_pre\t\t= xgbe_phy_an_pre;\n\tphy_impl->an_post\t\t= xgbe_phy_an_post;\n\n\tphy_impl->kr_training_pre\t= xgbe_phy_kr_training_pre;\n\tphy_impl->kr_training_post\t= xgbe_phy_kr_training_post;\n\n\tphy_impl->module_info\t\t= xgbe_phy_module_info;\n\tphy_impl->module_eeprom\t\t= xgbe_phy_module_eeprom;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}