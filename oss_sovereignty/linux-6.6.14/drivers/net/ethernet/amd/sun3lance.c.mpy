{
  "module_name": "sun3lance.c",
  "hash_id": "050d03df650ab8dd5ff431b1241581f2a234108a1ad714fcc7c78b43f328d1ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/sun3lance.c",
  "human_readable_source": " \n \n\nstatic const char version[] =\n\"sun3lance.c: v1.2 1/12/2001  Sam Creasey (sammy@sammy.net)\\n\";\n\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n#include <linux/pgtable.h>\n\n#include <asm/cacheflush.h>\n#include <asm/setup.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <asm/dvma.h>\n#include <asm/idprom.h>\n#include <asm/machines.h>\n\n#ifdef CONFIG_SUN3\n#include <asm/sun3mmu.h>\n#else\n#include <asm/sun3xprom.h>\n#endif\n\n \n#define LANCE_OBIO 0x120000\n#define LANCE_IRQ IRQ_AUTO_3\n\n \n\n#define\tLANCE_DEBUG\t0\n\n#ifdef LANCE_DEBUG\nstatic int lance_debug = LANCE_DEBUG;\n#else\nstatic int lance_debug = 1;\n#endif\nmodule_param(lance_debug, int, 0);\nMODULE_PARM_DESC(lance_debug, \"SUN3 Lance debug level (0-3)\");\nMODULE_LICENSE(\"GPL\");\n\n#define\tDPRINTK(n,a) \\\n\tdo {  \\\n\t\tif (lance_debug >= n)  \\\n\t\t\tprintk a; \\\n\t} while( 0 )\n\n\n \n\n#define TX_LOG_RING_SIZE\t\t\t3\n#define RX_LOG_RING_SIZE\t\t\t5\n\n \n\n#define TX_RING_SIZE\t\t\t(1 << TX_LOG_RING_SIZE)\n#define TX_RING_LEN_BITS\t\t(TX_LOG_RING_SIZE << 5)\n#define\tTX_RING_MOD_MASK\t\t(TX_RING_SIZE - 1)\n\n#define RX_RING_SIZE\t\t\t(1 << RX_LOG_RING_SIZE)\n#define RX_RING_LEN_BITS\t\t(RX_LOG_RING_SIZE << 5)\n#define\tRX_RING_MOD_MASK\t\t(RX_RING_SIZE - 1)\n\n \n#define PKT_BUF_SZ\t\t1544\n\n \n#define\tPKTBUF_ADDR(head)\t(void *)((unsigned long)(MEM) | (head)->base)\n\n\n \nstruct lance_rx_head {\n\tunsigned short\tbase;\t\t \n\tvolatile unsigned char\tflag;\n\tunsigned char  base_hi;\t \n\tshort buf_length;\t \n\tvolatile short msg_length;\t \n};\n\nstruct lance_tx_head {\n\tunsigned short base;\t\t \n\tvolatile unsigned char\tflag;\n\tunsigned char base_hi;\t \n\tshort length;\t\t \n\tvolatile short misc;\n};\n\n \nstruct lance_init_block {\n\tunsigned short\tmode;\t\t \n\tunsigned char\thwaddr[6];\t \n\tunsigned int    filter[2];\t \n\t \n\tunsigned short rdra;\n\tunsigned short rlen;\n\tunsigned short tdra;\n\tunsigned short tlen;\n\tunsigned short pad[4];  \n};\n\n \nstruct lance_memory {\n\tstruct lance_init_block\tinit;\n\tstruct lance_tx_head\ttx_head[TX_RING_SIZE];\n\tstruct lance_rx_head\trx_head[RX_RING_SIZE];\n\tchar   rx_data[RX_RING_SIZE][PKT_BUF_SZ];\n\tchar   tx_data[TX_RING_SIZE][PKT_BUF_SZ];\n};\n\n \n\nstruct lance_private {\n\tvolatile unsigned short\t*iobase;\n\tstruct lance_memory\t*mem;\n\tint new_rx, new_tx;\t \n\tint old_tx, old_rx;      \n \n\tlong\t    tx_full;\n\tlong\t    lock;\n};\n\n \n\n#define\tMEM\tlp->mem\n#define\tDREG\tlp->iobase[0]\n#define\tAREG\tlp->iobase[1]\n#define\tREGA(a)\t(*( AREG = (a), &DREG ))\n\n \n\n \n#define TMD1_ENP\t\t0x01\t \n#define TMD1_STP\t\t0x02\t \n#define TMD1_DEF\t\t0x04\t \n#define TMD1_ONE\t\t0x08\t \n#define TMD1_MORE\t\t0x10\t \n#define TMD1_ERR\t\t0x40\t \n#define TMD1_OWN \t\t0x80\t \n\n#define TMD1_OWN_CHIP\tTMD1_OWN\n#define TMD1_OWN_HOST\t0\n\n \n#define TMD3_TDR\t\t0x03FF\t \n#define TMD3_RTRY\t\t0x0400\t \n#define TMD3_LCAR\t\t0x0800\t \n#define TMD3_LCOL\t\t0x1000\t \n#define TMD3_UFLO\t\t0x4000\t \n#define TMD3_BUFF\t\t0x8000\t \n\n \n#define RMD1_ENP\t\t0x01\t \n#define RMD1_STP\t\t0x02\t \n#define RMD1_BUFF\t\t0x04\t \n#define RMD1_CRC\t\t0x08\t \n#define RMD1_OFLO\t\t0x10\t \n#define RMD1_FRAM\t\t0x20\t \n#define RMD1_ERR\t\t0x40\t \n#define RMD1_OWN \t\t0x80\t \n\n#define RMD1_OWN_CHIP\tRMD1_OWN\n#define RMD1_OWN_HOST\t0\n\n \n#define CSR0\t0\t\t \n#define CSR1\t1\t\t \n#define CSR2\t2\t\t \n#define CSR3\t3\t\t \n#define CSR8\t8\t  \t \n#define CSR15\t15\t\t \n\n \n \n#define CSR0_INIT\t0x0001\t\t \n#define CSR0_STRT\t0x0002\t\t \n#define CSR0_STOP\t0x0004\t\t \n#define CSR0_TDMD\t0x0008\t\t \n#define CSR0_TXON\t0x0010\t\t \n#define CSR0_RXON\t0x0020\t\t \n#define CSR0_INEA\t0x0040\t\t \n#define CSR0_INTR\t0x0080\t\t \n#define CSR0_IDON\t0x0100\t\t \n#define CSR0_TINT\t0x0200\t\t \n#define CSR0_RINT\t0x0400\t\t \n#define CSR0_MERR\t0x0800\t\t \n#define CSR0_MISS\t0x1000\t\t \n#define CSR0_CERR\t0x2000\t\t \n#define CSR0_BABL\t0x4000\t\t \n#define CSR0_ERR\t0x8000\t\t \n\n \n#define CSR3_BCON\t0x0001\t\t \n#define CSR3_ACON\t0x0002\t\t \n#define CSR3_BSWP\t0x0004\t\t \n\n \n\nstatic int lance_probe( struct net_device *dev);\nstatic int lance_open( struct net_device *dev );\nstatic void lance_init_ring( struct net_device *dev );\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev);\nstatic irqreturn_t lance_interrupt( int irq, void *dev_id);\nstatic int lance_rx( struct net_device *dev );\nstatic int lance_close( struct net_device *dev );\nstatic void set_multicast_list( struct net_device *dev );\n\n \n\nstatic struct net_device * __init sun3lance_probe(void)\n{\n\tstruct net_device *dev;\n\tstatic int found;\n\tint err = -ENODEV;\n\n\tif (!MACH_IS_SUN3 && !MACH_IS_SUN3X)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tswitch(idprom->id_machtype) {\n\tcase SM_SUN3|SM_3_50:\n\tcase SM_SUN3|SM_3_60:\n\tcase SM_SUN3X|SM_3_80:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif (found)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = alloc_etherdev(sizeof(struct lance_private));\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!lance_probe(dev))\n\t\tgoto out;\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out1;\n\tfound = 1;\n\treturn dev;\n\nout1:\n#ifdef CONFIG_SUN3\n\tiounmap((void __iomem *)dev->base_addr);\n#endif\nout:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n\nstatic const struct net_device_ops lance_netdev_ops = {\n\t.ndo_open\t\t= lance_open,\n\t.ndo_stop\t\t= lance_close,\n\t.ndo_start_xmit\t\t= lance_start_xmit,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address\t= NULL,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int __init lance_probe( struct net_device *dev)\n{\n\tunsigned long ioaddr;\n\n\tstruct lance_private\t*lp;\n\tstatic int \t\tdid_version;\n\tvolatile unsigned short *ioaddr_probe;\n\tunsigned short tmp1, tmp2;\n\n#ifdef CONFIG_SUN3\n\tioaddr = (unsigned long)ioremap(LANCE_OBIO, PAGE_SIZE);\n\tif (!ioaddr)\n\t\treturn 0;\n#else\n\tioaddr = SUN3X_LANCE;\n#endif\n\n\t \n\t \n\n\tioaddr_probe = (volatile unsigned short *)ioaddr;\n\ttmp1 = ioaddr_probe[0];\n\ttmp2 = ioaddr_probe[1];\n\n\tioaddr_probe[1] = CSR0;\n\tioaddr_probe[0] = CSR0_INIT | CSR0_STOP;\n\n\tif(ioaddr_probe[0] != CSR0_STOP) {\n\t\tioaddr_probe[0] = tmp1;\n\t\tioaddr_probe[1] = tmp2;\n\n#ifdef CONFIG_SUN3\n\t\tiounmap((void __iomem *)ioaddr);\n#endif\n\t\treturn 0;\n\t}\n\n\tlp = netdev_priv(dev);\n\n\t \n\tMEM = dvma_malloc_align(sizeof(struct lance_memory), 0x10000);\n\tif (!MEM) {\n#ifdef CONFIG_SUN3\n\t\tiounmap((void __iomem *)ioaddr);\n#endif\n\t\tprintk(KERN_WARNING \"SUN3 Lance couldn't allocate DVMA memory\\n\");\n\t\treturn 0;\n\t}\n\n\tlp->iobase = (volatile unsigned short *)ioaddr;\n\tdev->base_addr = (unsigned long)ioaddr;  \n\n\tREGA(CSR0) = CSR0_STOP;\n\n\tif (request_irq(LANCE_IRQ, lance_interrupt, 0, \"SUN3 Lance\", dev) < 0) {\n#ifdef CONFIG_SUN3\n\t\tiounmap((void __iomem *)ioaddr);\n#endif\n\t\tdvma_free((void *)MEM);\n\t\tprintk(KERN_WARNING \"SUN3 Lance unable to allocate IRQ\\n\");\n\t\treturn 0;\n\t}\n\tdev->irq = (unsigned short)LANCE_IRQ;\n\n\n\tprintk(\"%s: SUN3 Lance at io %#lx, mem %#lx, irq %d, hwaddr \",\n\t\t   dev->name,\n\t\t   (unsigned long)ioaddr,\n\t\t   (unsigned long)MEM,\n\t\t   dev->irq);\n\n\t \n\teth_hw_addr_set(dev, idprom->id_ethaddr);\n\n\t \n\tMEM->init.hwaddr[0] = dev->dev_addr[1];\n\tMEM->init.hwaddr[1] = dev->dev_addr[0];\n\tMEM->init.hwaddr[2] = dev->dev_addr[3];\n\tMEM->init.hwaddr[3] = dev->dev_addr[2];\n\tMEM->init.hwaddr[4] = dev->dev_addr[5];\n\tMEM->init.hwaddr[5] = dev->dev_addr[4];\n\n\tprintk(\"%pM\\n\", dev->dev_addr);\n\n\tMEM->init.mode = 0x0000;\n\tMEM->init.filter[0] = 0x00000000;\n\tMEM->init.filter[1] = 0x00000000;\n\tMEM->init.rdra = dvma_vtob(MEM->rx_head);\n\tMEM->init.rlen    = (RX_LOG_RING_SIZE << 13) |\n\t\t(dvma_vtob(MEM->rx_head) >> 16);\n\tMEM->init.tdra = dvma_vtob(MEM->tx_head);\n\tMEM->init.tlen    = (TX_LOG_RING_SIZE << 13) |\n\t\t(dvma_vtob(MEM->tx_head) >> 16);\n\n\tDPRINTK(2, (\"initaddr: %08lx rx_ring: %08lx tx_ring: %08lx\\n\",\n\t       dvma_vtob(&(MEM->init)), dvma_vtob(MEM->rx_head),\n\t       (dvma_vtob(MEM->tx_head))));\n\n\tif (did_version++ == 0)\n\t\tprintk( version );\n\n\tdev->netdev_ops = &lance_netdev_ops;\n \n\tset_bit(__LINK_STATE_PRESENT, &dev->state);\n\n\n\treturn 1;\n}\n\nstatic int lance_open( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint i;\n\n\tDPRINTK( 2, ( \"%s: lance_open()\\n\", dev->name ));\n\n\tREGA(CSR0) = CSR0_STOP;\n\n\tlance_init_ring(dev);\n\n\t \n\tREGA(CSR0) = CSR0_INIT;\n\n\ti = 1000000;\n\twhile (--i > 0)\n\t\tif (DREG & CSR0_IDON)\n\t\t\tbreak;\n\tif (i <= 0 || (DREG & CSR0_ERR)) {\n\t\tDPRINTK( 2, ( \"lance_open(): opening %s failed, i=%d, csr0=%04x\\n\",\n\t\t\t\t\t  dev->name, i, DREG ));\n\t\tDREG = CSR0_STOP;\n\t\treturn -EIO;\n\t}\n\n\tDREG = CSR0_IDON | CSR0_STRT | CSR0_INEA;\n\n\tnetif_start_queue(dev);\n\n\tDPRINTK( 2, ( \"%s: LANCE is open, csr0 %04x\\n\", dev->name, DREG ));\n\n\treturn 0;\n}\n\n\n \n\nstatic void lance_init_ring( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint i;\n\n\tlp->lock = 0;\n\tlp->tx_full = 0;\n\tlp->new_rx = lp->new_tx = 0;\n\tlp->old_rx = lp->old_tx = 0;\n\n\tfor( i = 0; i < TX_RING_SIZE; i++ ) {\n\t\tMEM->tx_head[i].base = dvma_vtob(MEM->tx_data[i]);\n\t\tMEM->tx_head[i].flag = 0;\n\t\tMEM->tx_head[i].base_hi =\n\t\t\t(dvma_vtob(MEM->tx_data[i])) >>16;\n\t\tMEM->tx_head[i].length = 0;\n\t\tMEM->tx_head[i].misc = 0;\n\t}\n\n\tfor( i = 0; i < RX_RING_SIZE; i++ ) {\n\t\tMEM->rx_head[i].base = dvma_vtob(MEM->rx_data[i]);\n\t\tMEM->rx_head[i].flag = RMD1_OWN_CHIP;\n\t\tMEM->rx_head[i].base_hi =\n\t\t\t(dvma_vtob(MEM->rx_data[i])) >> 16;\n\t\tMEM->rx_head[i].buf_length = -PKT_BUF_SZ | 0xf000;\n\t\tMEM->rx_head[i].msg_length = 0;\n\t}\n\n\t \n\tMEM->init.hwaddr[0] = dev->dev_addr[1];\n\tMEM->init.hwaddr[1] = dev->dev_addr[0];\n\tMEM->init.hwaddr[2] = dev->dev_addr[3];\n\tMEM->init.hwaddr[3] = dev->dev_addr[2];\n\tMEM->init.hwaddr[4] = dev->dev_addr[5];\n\tMEM->init.hwaddr[5] = dev->dev_addr[4];\n\n\tMEM->init.mode = 0x0000;\n\tMEM->init.filter[0] = 0x00000000;\n\tMEM->init.filter[1] = 0x00000000;\n\tMEM->init.rdra = dvma_vtob(MEM->rx_head);\n\tMEM->init.rlen    = (RX_LOG_RING_SIZE << 13) |\n\t\t(dvma_vtob(MEM->rx_head) >> 16);\n\tMEM->init.tdra = dvma_vtob(MEM->tx_head);\n\tMEM->init.tlen    = (TX_LOG_RING_SIZE << 13) |\n\t\t(dvma_vtob(MEM->tx_head) >> 16);\n\n\n\t \n\tREGA(CSR1) = dvma_vtob(&(MEM->init));\n\tREGA(CSR2) = dvma_vtob(&(MEM->init)) >> 16;\n\n#ifdef CONFIG_SUN3X\n\tREGA(CSR3) = CSR3_BSWP | CSR3_ACON | CSR3_BCON;\n#else\n\tREGA(CSR3) = CSR3_BSWP;\n#endif\n\n}\n\n\nstatic netdev_tx_t\nlance_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint entry, len;\n\tstruct lance_tx_head *head;\n\tunsigned long flags;\n\n\tDPRINTK( 1, ( \"%s: transmit start.\\n\",\n\t\t      dev->name));\n\n\t \n\tif (netif_queue_stopped(dev)) {\n\t\tint tickssofar = jiffies - dev_trans_start(dev);\n\t\tif (tickssofar < HZ/5)\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tDPRINTK( 1, ( \"%s: transmit timed out, status %04x, resetting.\\n\",\n\t\t\t\t\t  dev->name, DREG ));\n\t\tDREG = CSR0_STOP;\n\t\t \n\t\tREGA(CSR3) = CSR3_BSWP;\n\t\tdev->stats.tx_errors++;\n\n\t\tif(lance_debug >= 2) {\n\t\t\tint i;\n\t\t\tprintk(\"Ring data: old_tx %d new_tx %d%s new_rx %d\\n\",\n\t\t\t       lp->old_tx, lp->new_tx,\n\t\t\t       lp->tx_full ? \" (full)\" : \"\",\n\t\t\t       lp->new_rx );\n\t\t\tfor( i = 0 ; i < RX_RING_SIZE; i++ )\n\t\t\t\tprintk( \"rx #%d: base=%04x blen=%04x mlen=%04x\\n\",\n\t\t\t\t\ti, MEM->rx_head[i].base,\n\t\t\t\t\t-MEM->rx_head[i].buf_length,\n\t\t\t\t\tMEM->rx_head[i].msg_length);\n\t\t\tfor( i = 0 ; i < TX_RING_SIZE; i++ )\n\t\t\t\tprintk(\"tx #%d: base=%04x len=%04x misc=%04x\\n\",\n\t\t\t\t       i, MEM->tx_head[i].base,\n\t\t\t\t       -MEM->tx_head[i].length,\n\t\t\t\t       MEM->tx_head[i].misc );\n\t\t}\n\n\t\tlance_init_ring(dev);\n\t\tREGA( CSR0 ) = CSR0_INEA | CSR0_INIT | CSR0_STRT;\n\n\t\tnetif_start_queue(dev);\n\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\n\t \n\n\t \n\n\tnetif_stop_queue(dev);\n\n\tif (test_and_set_bit( 0, (void*)&lp->lock ) != 0) {\n\t\tprintk( \"%s: tx queue lock!.\\n\", dev->name);\n\t\t \n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tAREG = CSR0;\n\tDPRINTK( 2, ( \"%s: lance_start_xmit() called, csr0 %4.4x.\\n\",\n\t\t\t\t  dev->name, DREG ));\n\n#ifdef CONFIG_SUN3X\n\t \n\tif(!(DREG & CSR0_INIT)) {\n\t\tDPRINTK( 1, (\"INIT not set, reinitializing...\\n\"));\n\t\tREGA( CSR0 ) = CSR0_STOP;\n\t\tlance_init_ring(dev);\n\t\tREGA( CSR0 ) = CSR0_INIT | CSR0_STRT;\n\t}\n#endif\n\n\t \n#if 0\n\tif (lance_debug >= 2) {\n\t\tprintk( \"%s: TX pkt %d type 0x%04x\"\n\t\t\t\" from %s to %s\"\n\t\t\t\" data at 0x%08x len %d\\n\",\n\t\t\tdev->name, lp->new_tx, ((u_short *)skb->data)[6],\n\t\t\tDEV_ADDR(&skb->data[6]), DEV_ADDR(skb->data),\n\t\t\t(int)skb->data, (int)skb->len );\n\t}\n#endif\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tentry = lp->new_tx;\n\thead  = &(MEM->tx_head[entry]);\n\n\t \n\n\t \n\tlen = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;\n\n \n\thead->length = (-len) | 0xf000;\n\thead->misc = 0;\n\n\tskb_copy_from_linear_data(skb, PKTBUF_ADDR(head), skb->len);\n\tif (len != skb->len)\n\t\tmemset(PKTBUF_ADDR(head) + skb->len, 0, len-skb->len);\n\n\thead->flag = TMD1_OWN_CHIP | TMD1_ENP | TMD1_STP;\n\tlp->new_tx = (lp->new_tx + 1) & TX_RING_MOD_MASK;\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\tREGA(CSR0) = CSR0_INEA | CSR0_TDMD | CSR0_STRT;\n\tAREG = CSR0;\n\tDPRINTK( 2, ( \"%s: lance_start_xmit() exiting, csr0 %4.4x.\\n\",\n\t\t\t\t  dev->name, DREG ));\n\tdev_kfree_skb(skb);\n\n\tlp->lock = 0;\n\tif ((MEM->tx_head[(entry+1) & TX_RING_MOD_MASK].flag & TMD1_OWN) ==\n\t    TMD1_OWN_HOST)\n\t\tnetif_start_queue(dev);\n\n\tlocal_irq_restore(flags);\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic irqreturn_t lance_interrupt( int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint csr0;\n\n still_more:\n\tflush_cache_all();\n\n\tAREG = CSR0;\n\tcsr0 = DREG;\n\n\t \n\tDREG = csr0 & (CSR0_TINT | CSR0_RINT | CSR0_IDON);\n\n\t \n\tif(csr0 & CSR0_ERR)\n\t\tDREG = CSR0_BABL | CSR0_MERR | CSR0_CERR | CSR0_MISS;\n\n\n\tDPRINTK( 2, ( \"%s: interrupt  csr0=%04x new csr=%04x.\\n\",\n\t\t      dev->name, csr0, DREG ));\n\n\tif (csr0 & CSR0_TINT) {\t\t\t \n\t\tint old_tx = lp->old_tx;\n\n \n \n \n \n \n \n \n \n \n\n\t\twhile( old_tx != lp->new_tx) {\n\t\t\tstruct lance_tx_head *head = &(MEM->tx_head[old_tx]);\n\n\t\t\tDPRINTK(3, (\"on tx_ring %d\\n\", old_tx));\n\n\t\t\tif (head->flag & TMD1_OWN_CHIP)\n\t\t\t\tbreak;  \n\n\t\t\tif (head->flag & TMD1_ERR) {\n\t\t\t\tint status = head->misc;\n\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\tif (status & TMD3_RTRY) dev->stats.tx_aborted_errors++;\n\t\t\t\tif (status & TMD3_LCAR) dev->stats.tx_carrier_errors++;\n\t\t\t\tif (status & TMD3_LCOL) dev->stats.tx_window_errors++;\n\t\t\t\tif (status & (TMD3_UFLO | TMD3_BUFF)) {\n\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t\tprintk(\"%s: Tx FIFO error\\n\",\n\t\t\t\t\t       dev->name);\n\t\t\t\t\tREGA(CSR0) = CSR0_STOP;\n\t\t\t\t\tREGA(CSR3) = CSR3_BSWP;\n\t\t\t\t\tlance_init_ring(dev);\n\t\t\t\t\tREGA(CSR0) = CSR0_STRT | CSR0_INEA;\n\t\t\t\t\treturn IRQ_HANDLED;\n\t\t\t\t}\n\t\t\t} else if(head->flag & (TMD1_ENP | TMD1_STP)) {\n\n\t\t\t\thead->flag &= ~(TMD1_ENP | TMD1_STP);\n\t\t\t\tif(head->flag & (TMD1_ONE | TMD1_MORE))\n\t\t\t\t\tdev->stats.collisions++;\n\n\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\tDPRINTK(3, (\"cleared tx ring %d\\n\", old_tx));\n\t\t\t}\n\t\t\told_tx = (old_tx +1) & TX_RING_MOD_MASK;\n\t\t}\n\n\t\tlp->old_tx = old_tx;\n\t}\n\n\n\tif (netif_queue_stopped(dev)) {\n\t\t \n\t\tnetif_start_queue(dev);\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tif (csr0 & CSR0_RINT)\t\t\t \n\t\tlance_rx( dev );\n\n\t \n\tif (csr0 & CSR0_BABL) dev->stats.tx_errors++;  \n\tif (csr0 & CSR0_MISS) dev->stats.rx_errors++;  \n\tif (csr0 & CSR0_MERR) {\n\t\tDPRINTK( 1, ( \"%s: Bus master arbitration failure (?!?), \"\n\t\t\t      \"status %04x.\\n\", dev->name, csr0 ));\n\t\t \n\t\tREGA(CSR0) = CSR0_STOP;\n\t\tREGA(CSR3) = CSR3_BSWP;\n\t\tlance_init_ring(dev);\n\t\tREGA(CSR0) = CSR0_STRT | CSR0_INEA;\n\t}\n\n\n     \n\n\n\n\tREGA(CSR0) = CSR0_INEA;\n\n\tif(DREG & (CSR0_RINT | CSR0_TINT)) {\n\t     DPRINTK(2, (\"restarting interrupt, csr0=%#04x\\n\", DREG));\n\t     goto still_more;\n\t}\n\n\tDPRINTK( 2, ( \"%s: exiting interrupt, csr0=%#04x.\\n\",\n\t\t\t\t  dev->name, DREG ));\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int lance_rx( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint entry = lp->new_rx;\n\n\t \n\twhile( (MEM->rx_head[entry].flag & RMD1_OWN) == RMD1_OWN_HOST ) {\n\t\tstruct lance_rx_head *head = &(MEM->rx_head[entry]);\n\t\tint status = head->flag;\n\n\t\tif (status != (RMD1_ENP|RMD1_STP)) {   \n\t\t\t \n\t\t\tif (status & RMD1_ENP)\t \n\t\t\t\tdev->stats.rx_errors++;  \n\t\t\tif (status & RMD1_FRAM) dev->stats.rx_frame_errors++;\n\t\t\tif (status & RMD1_OFLO) dev->stats.rx_over_errors++;\n\t\t\tif (status & RMD1_CRC) dev->stats.rx_crc_errors++;\n\t\t\tif (status & RMD1_BUFF) dev->stats.rx_fifo_errors++;\n\t\t\thead->flag &= (RMD1_ENP|RMD1_STP);\n\t\t} else {\n\t\t\t \n\n\t\t\tshort pkt_len = (head->msg_length & 0xfff) - 4;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (pkt_len < 60) {\n\t\t\t\tprintk( \"%s: Runt packet!\\n\", dev->name );\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\thead->msg_length = 0;\n\t\t\t\t\thead->flag |= RMD1_OWN_CHIP;\n\t\t\t\t\tlp->new_rx = (lp->new_rx+1) &\n\t\t\t\t\t     RX_RING_MOD_MASK;\n\t\t\t\t}\n\n#if 0\n\t\t\t\tif (lance_debug >= 3) {\n\t\t\t\t\tu_char *data = PKTBUF_ADDR(head);\n\t\t\t\t\tprintk(\"%s: RX pkt %d type 0x%04x\"\n\t\t\t\t\t       \" from %pM to %pM\",\n\t\t\t\t\t       dev->name, lp->new_tx, ((u_short *)data)[6],\n\t\t\t\t\t       &data[6], data);\n\n\t\t\t\t\tprintk(\" data %02x %02x %02x %02x %02x %02x %02x %02x \"\n\t\t\t\t\t       \"len %d at %08x\\n\",\n\t\t\t\t\t       data[15], data[16], data[17], data[18],\n\t\t\t\t\t       data[19], data[20], data[21], data[22],\n\t\t\t\t\t       pkt_len, data);\n\t\t\t\t}\n#endif\n\t\t\t\tif (lance_debug >= 3) {\n\t\t\t\t\tu_char *data = PKTBUF_ADDR(head);\n\t\t\t\t\tprintk( \"%s: RX pkt %d type 0x%04x len %d\\n \", dev->name, entry, ((u_short *)data)[6], pkt_len);\n\t\t\t\t}\n\n\n\t\t\t\tskb_reserve( skb, 2 );\t \n\t\t\t\tskb_put( skb, pkt_len );\t \n\t\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t\t PKTBUF_ADDR(head),\n\t\t\t\t\t\t pkt_len);\n\n\t\t\t\tskb->protocol = eth_type_trans( skb, dev );\n\t\t\t\tnetif_rx( skb );\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t}\n\t\t}\n\n\n\t\thead->msg_length = 0;\n\t\thead->flag = RMD1_OWN_CHIP;\n\n\t\tentry = lp->new_rx = (lp->new_rx +1) & RX_RING_MOD_MASK;\n\t}\n\n\t \n\t \n\n\treturn 0;\n}\n\n\nstatic int lance_close( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\tAREG = CSR0;\n\n\tDPRINTK( 2, ( \"%s: Shutting down ethercard, status was %2.2x.\\n\",\n\t\t\t\t  dev->name, DREG ));\n\n\t \n\tDREG = CSR0_STOP;\n\treturn 0;\n}\n\n\n \n\n \nstatic void set_multicast_list( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tif(netif_queue_stopped(dev))\n\t\t \n\t\treturn;\n\n\t \n\tDREG = CSR0_STOP;  \n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tDPRINTK( 3, ( \"%s: Promiscuous mode enabled.\\n\", dev->name ));\n\t\tREGA( CSR15 ) = 0x8000;  \n\t} else {\n\t\tshort multicast_table[4];\n\t\tint num_addrs = netdev_mc_count(dev);\n\t\tint i;\n\t\t \n\t\tmemset( multicast_table, (num_addrs == 0) ? 0 : -1,\n\t\t\t\tsizeof(multicast_table) );\n\t\tfor( i = 0; i < 4; i++ )\n\t\t\tREGA( CSR8+i ) = multicast_table[i];\n\t\tREGA( CSR15 ) = 0;  \n\t}\n\n\t \n\tREGA( CSR3 ) = CSR3_BSWP;\n\n\t \n\tREGA( CSR0 ) = CSR0_IDON | CSR0_INEA | CSR0_STRT;\n}\n\n\nstatic struct net_device *sun3lance_dev;\n\nstatic int __init sun3lance_init(void)\n{\n\tsun3lance_dev = sun3lance_probe();\n\treturn PTR_ERR_OR_ZERO(sun3lance_dev);\n}\nmodule_init(sun3lance_init);\n\nstatic void __exit sun3lance_cleanup(void)\n{\n\tunregister_netdev(sun3lance_dev);\n#ifdef CONFIG_SUN3\n\tiounmap((void __iomem *)sun3lance_dev->base_addr);\n#endif\n\tfree_netdev(sun3lance_dev);\n}\nmodule_exit(sun3lance_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}