{
  "module_name": "nmclan_cs.c",
  "hash_id": "bbadefceb980932ad6711f70a917ff48152fdcfc8bbc5c9f60d5abd509fbee34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/nmclan_cs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"nmclan_cs\"\n\n \n\n#define MULTI_TX\t\t\t0\n#define RESET_ON_TIMEOUT\t\t1\n#define TX_INTERRUPTABLE\t\t1\n#define RESET_XILINX\t\t\t0\n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/bitops.h>\n\n#include <pcmcia/cisreg.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n \n\n#define MACE_LADRF_LEN\t\t\t8\n\t\t\t\t\t \n\n \n#define MACE_MAX_IR_ITERATIONS\t\t10\n#define MACE_MAX_RX_ITERATIONS\t\t12\n\t \n\n \n#define AM2150_MAX_TX_FRAMES\t\t4\n#define AM2150_MAX_RX_FRAMES\t\t12\n\n \n#define AM2150_RCV\t\t\t0x00\n#define AM2150_XMT\t\t\t0x04\n#define AM2150_XMT_SKIP\t\t\t0x09\n#define AM2150_RCV_NEXT\t\t\t0x0A\n#define AM2150_RCV_FRAME_COUNT\t\t0x0B\n#define AM2150_MACE_BANK\t\t0x0C\n#define AM2150_MACE_BASE\t\t0x10\n\n \n#define MACE_RCVFIFO\t\t\t0\n#define MACE_XMTFIFO\t\t\t1\n#define MACE_XMTFC\t\t\t2\n#define MACE_XMTFS\t\t\t3\n#define MACE_XMTRC\t\t\t4\n#define MACE_RCVFC\t\t\t5\n#define MACE_RCVFS\t\t\t6\n#define MACE_FIFOFC\t\t\t7\n#define MACE_IR\t\t\t\t8\n#define MACE_IMR\t\t\t9\n#define MACE_PR\t\t\t\t10\n#define MACE_BIUCC\t\t\t11\n#define MACE_FIFOCC\t\t\t12\n#define MACE_MACCC\t\t\t13\n#define MACE_PLSCC\t\t\t14\n#define MACE_PHYCC\t\t\t15\n#define MACE_CHIPIDL\t\t\t16\n#define MACE_CHIPIDH\t\t\t17\n#define MACE_IAC\t\t\t18\n \n#define MACE_LADRF\t\t\t20\n#define MACE_PADR\t\t\t21\n \n \n#define MACE_MPC\t\t\t24\n \n#define MACE_RNTPC\t\t\t26\n#define MACE_RCVCC\t\t\t27\n \n#define MACE_UTR\t\t\t29\n#define MACE_RTR1\t\t\t30\n#define MACE_RTR2\t\t\t31\n\n \n#define MACE_XMTRC_EXDEF\t\t0x80\n#define MACE_XMTRC_XMTRC\t\t0x0F\n\n#define MACE_XMTFS_XMTSV\t\t0x80\n#define MACE_XMTFS_UFLO\t\t\t0x40\n#define MACE_XMTFS_LCOL\t\t\t0x20\n#define MACE_XMTFS_MORE\t\t\t0x10\n#define MACE_XMTFS_ONE\t\t\t0x08\n#define MACE_XMTFS_DEFER\t\t0x04\n#define MACE_XMTFS_LCAR\t\t\t0x02\n#define MACE_XMTFS_RTRY\t\t\t0x01\n\n#define MACE_RCVFS_RCVSTS\t\t0xF000\n#define MACE_RCVFS_OFLO\t\t\t0x8000\n#define MACE_RCVFS_CLSN\t\t\t0x4000\n#define MACE_RCVFS_FRAM\t\t\t0x2000\n#define MACE_RCVFS_FCS\t\t\t0x1000\n\n#define MACE_FIFOFC_RCVFC\t\t0xF0\n#define MACE_FIFOFC_XMTFC\t\t0x0F\n\n#define MACE_IR_JAB\t\t\t0x80\n#define MACE_IR_BABL\t\t\t0x40\n#define MACE_IR_CERR\t\t\t0x20\n#define MACE_IR_RCVCCO\t\t\t0x10\n#define MACE_IR_RNTPCO\t\t\t0x08\n#define MACE_IR_MPCO\t\t\t0x04\n#define MACE_IR_RCVINT\t\t\t0x02\n#define MACE_IR_XMTINT\t\t\t0x01\n\n#define MACE_MACCC_PROM\t\t\t0x80\n#define MACE_MACCC_DXMT2PD\t\t0x40\n#define MACE_MACCC_EMBA\t\t\t0x20\n#define MACE_MACCC_RESERVED\t\t0x10\n#define MACE_MACCC_DRCVPA\t\t0x08\n#define MACE_MACCC_DRCVBC\t\t0x04\n#define MACE_MACCC_ENXMT\t\t0x02\n#define MACE_MACCC_ENRCV\t\t0x01\n\n#define MACE_PHYCC_LNKFL\t\t0x80\n#define MACE_PHYCC_DLNKTST\t\t0x40\n#define MACE_PHYCC_REVPOL\t\t0x20\n#define MACE_PHYCC_DAPC\t\t\t0x10\n#define MACE_PHYCC_LRT\t\t\t0x08\n#define MACE_PHYCC_ASEL\t\t\t0x04\n#define MACE_PHYCC_RWAKE\t\t0x02\n#define MACE_PHYCC_AWAKE\t\t0x01\n\n#define MACE_IAC_ADDRCHG\t\t0x80\n#define MACE_IAC_PHYADDR\t\t0x04\n#define MACE_IAC_LOGADDR\t\t0x02\n\n#define MACE_UTR_RTRE\t\t\t0x80\n#define MACE_UTR_RTRD\t\t\t0x40\n#define MACE_UTR_RPA\t\t\t0x20\n#define MACE_UTR_FCOLL\t\t\t0x10\n#define MACE_UTR_RCVFCSE\t\t0x08\n#define MACE_UTR_LOOP_INCL_MENDEC\t0x06\n#define MACE_UTR_LOOP_NO_MENDEC\t\t0x04\n#define MACE_UTR_LOOP_EXTERNAL\t\t0x02\n#define MACE_UTR_LOOP_NONE\t\t0x00\n#define MACE_UTR_RESERVED\t\t0x01\n\n \n#define MACEBANK(win_num) outb((win_num), ioaddr + AM2150_MACE_BANK)\n\n#define MACE_IMR_DEFAULT \\\n  (0xFF - \\\n    ( \\\n      MACE_IR_CERR | \\\n      MACE_IR_RCVCCO | \\\n      MACE_IR_RNTPCO | \\\n      MACE_IR_MPCO | \\\n      MACE_IR_RCVINT | \\\n      MACE_IR_XMTINT \\\n    ) \\\n  )\n#undef MACE_IMR_DEFAULT\n#define MACE_IMR_DEFAULT 0x00  \n\n#define TX_TIMEOUT\t\t((400*HZ)/1000)\n\n \n\ntypedef struct _mace_statistics {\n     \n    int xmtsv;\n    int uflo;\n    int lcol;\n    int more;\n    int one;\n    int defer;\n    int lcar;\n    int rtry;\n\n     \n    int exdef;\n    int xmtrc;\n\n     \n    int oflo;\n    int clsn;\n    int fram;\n    int fcs;\n\n     \n    int rfs_rntpc;\n\n     \n    int rfs_rcvcc;\n\n     \n    int jab;\n    int babl;\n    int cerr;\n    int rcvcco;\n    int rntpco;\n    int mpco;\n\n     \n    int mpc;\n\n     \n    int rntpc;\n\n     \n    int rcvcc;\n} mace_statistics;\n\ntypedef struct _mace_private {\n\tstruct pcmcia_device\t*p_dev;\n    mace_statistics mace_stats;  \n\n     \n    int multicast_ladrf[MACE_LADRF_LEN];  \n    int multicast_num_addrs;\n\n    char tx_free_frames;  \n    char tx_irq_disabled;  \n\n    spinlock_t bank_lock;  \n} mace_private;\n\n \n\nstatic const char *if_names[]={\n    \"Auto\", \"10baseT\", \"BNC\",\n};\n\n \n\nMODULE_DESCRIPTION(\"New Media PCMCIA ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\n \nINT_MODULE_PARM(if_port, 0);\n\n\n \n\nstatic int nmclan_config(struct pcmcia_device *link);\nstatic void nmclan_release(struct pcmcia_device *link);\n\nstatic void nmclan_reset(struct net_device *dev);\nstatic int mace_config(struct net_device *dev, struct ifmap *map);\nstatic int mace_open(struct net_device *dev);\nstatic int mace_close(struct net_device *dev);\nstatic netdev_tx_t mace_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev);\nstatic void mace_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic irqreturn_t mace_interrupt(int irq, void *dev_id);\nstatic struct net_device_stats *mace_get_stats(struct net_device *dev);\nstatic int mace_rx(struct net_device *dev, unsigned char RxCnt);\nstatic void restore_multicast_list(struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\nstatic const struct ethtool_ops netdev_ethtool_ops;\n\n\nstatic void nmclan_detach(struct pcmcia_device *p_dev);\n\nstatic const struct net_device_ops mace_netdev_ops = {\n\t.ndo_open\t\t= mace_open,\n\t.ndo_stop\t\t= mace_close,\n\t.ndo_start_xmit\t\t= mace_start_xmit,\n\t.ndo_tx_timeout\t\t= mace_tx_timeout,\n\t.ndo_set_config\t\t= mace_config,\n\t.ndo_get_stats\t\t= mace_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int nmclan_probe(struct pcmcia_device *link)\n{\n    mace_private *lp;\n    struct net_device *dev;\n\n    dev_dbg(&link->dev, \"nmclan_attach()\\n\");\n\n     \n    dev = alloc_etherdev(sizeof(mace_private));\n    if (!dev)\n\t    return -ENOMEM;\n    lp = netdev_priv(dev);\n    lp->p_dev = link;\n    link->priv = dev;\n\n    spin_lock_init(&lp->bank_lock);\n    link->resource[0]->end = 32;\n    link->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n    link->config_flags |= CONF_ENABLE_IRQ;\n    link->config_index = 1;\n    link->config_regs = PRESENT_OPTION;\n\n    lp->tx_free_frames=AM2150_MAX_TX_FRAMES;\n\n    dev->netdev_ops = &mace_netdev_ops;\n    dev->ethtool_ops = &netdev_ethtool_ops;\n    dev->watchdog_timeo = TX_TIMEOUT;\n\n    return nmclan_config(link);\n}  \n\nstatic void nmclan_detach(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n\n    dev_dbg(&link->dev, \"nmclan_detach\\n\");\n\n    unregister_netdev(dev);\n\n    nmclan_release(link);\n\n    free_netdev(dev);\n}  \n\n \nstatic int mace_read(mace_private *lp, unsigned int ioaddr, int reg)\n{\n  int data = 0xFF;\n  unsigned long flags;\n\n  switch (reg >> 4) {\n  case 0:  \n      data = inb(ioaddr + AM2150_MACE_BASE + reg);\n      break;\n  case 1:  \n      spin_lock_irqsave(&lp->bank_lock, flags);\n      MACEBANK(1);\n      data = inb(ioaddr + AM2150_MACE_BASE + (reg & 0x0F));\n      MACEBANK(0);\n      spin_unlock_irqrestore(&lp->bank_lock, flags);\n      break;\n  }\n  return data & 0xFF;\n}  \n\n \nstatic void mace_write(mace_private *lp, unsigned int ioaddr, int reg,\n\t\t       int data)\n{\n  unsigned long flags;\n\n  switch (reg >> 4) {\n  case 0:  \n      outb(data & 0xFF, ioaddr + AM2150_MACE_BASE + reg);\n      break;\n  case 1:  \n      spin_lock_irqsave(&lp->bank_lock, flags);\n      MACEBANK(1);\n      outb(data & 0xFF, ioaddr + AM2150_MACE_BASE + (reg & 0x0F));\n      MACEBANK(0);\n      spin_unlock_irqrestore(&lp->bank_lock, flags);\n      break;\n  }\n}  \n\n \nstatic int mace_init(mace_private *lp, unsigned int ioaddr,\n\t\t     const char *enet_addr)\n{\n  int i;\n  int ct = 0;\n\n   \n  mace_write(lp, ioaddr, MACE_BIUCC, 1);\n  while (mace_read(lp, ioaddr, MACE_BIUCC) & 0x01) {\n     ;\n    if(++ct > 500)\n    {\n\tpr_err(\"reset failed, card removed?\\n\");\n\treturn -1;\n    }\n    udelay(1);\n  }\n  mace_write(lp, ioaddr, MACE_BIUCC, 0);\n\n   \n  mace_write(lp, ioaddr, MACE_FIFOCC, 0x0F);\n\n  mace_write(lp,ioaddr, MACE_RCVFC, 0);  \n  mace_write(lp, ioaddr, MACE_IMR, 0xFF);  \n\n   \n  switch (if_port) {\n  case 1:\n      mace_write(lp, ioaddr, MACE_PLSCC, 0x02);\n      break;\n  case 2:\n      mace_write(lp, ioaddr, MACE_PLSCC, 0x00);\n      break;\n  default:\n      mace_write(lp, ioaddr, MACE_PHYCC,   4);\n       \n      break;\n  }\n\n  mace_write(lp, ioaddr, MACE_IAC, MACE_IAC_ADDRCHG | MACE_IAC_PHYADDR);\n   \n  ct = 0;\n  while (mace_read(lp, ioaddr, MACE_IAC) & MACE_IAC_ADDRCHG)\n  {\n\tif(++ ct > 500)\n\t{\n\t\tpr_err(\"ADDRCHG timeout, card removed?\\n\");\n\t\treturn -1;\n\t}\n  }\n   \n  for (i = 0; i < ETH_ALEN; i++)\n    mace_write(lp, ioaddr, MACE_PADR, enet_addr[i]);\n\n   \n   \n   \n  mace_write(lp, ioaddr, MACE_MACCC, 0x00);\n  return 0;\n}  \n\nstatic int nmclan_config(struct pcmcia_device *link)\n{\n  struct net_device *dev = link->priv;\n  mace_private *lp = netdev_priv(dev);\n  u8 *buf;\n  size_t len;\n  int i, ret;\n  unsigned int ioaddr;\n\n  dev_dbg(&link->dev, \"nmclan_config\\n\");\n\n  link->io_lines = 5;\n  ret = pcmcia_request_io(link);\n  if (ret)\n\t  goto failed;\n  ret = pcmcia_request_irq(link, mace_interrupt);\n  if (ret)\n\t  goto failed;\n  ret = pcmcia_enable_device(link);\n  if (ret)\n\t  goto failed;\n\n  dev->irq = link->irq;\n  dev->base_addr = link->resource[0]->start;\n\n  ioaddr = dev->base_addr;\n\n   \n  len = pcmcia_get_tuple(link, 0x80, &buf);\n  if (!buf || len < ETH_ALEN) {\n\t  kfree(buf);\n\t  goto failed;\n  }\n  eth_hw_addr_set(dev, buf);\n  kfree(buf);\n\n   \n  {\n    char sig[2];\n\n    sig[0] = mace_read(lp, ioaddr, MACE_CHIPIDL);\n    sig[1] = mace_read(lp, ioaddr, MACE_CHIPIDH);\n    if ((sig[0] == 0x40) && ((sig[1] & 0x0F) == 0x09)) {\n      dev_dbg(&link->dev, \"nmclan_cs configured: mace id=%x %x\\n\",\n\t    sig[0], sig[1]);\n    } else {\n      pr_notice(\"mace id not found: %x %x should be 0x40 0x?9\\n\",\n\t\tsig[0], sig[1]);\n      goto failed;\n    }\n  }\n\n  if(mace_init(lp, ioaddr, dev->dev_addr) == -1)\n\tgoto failed;\n\n   \n  if (if_port <= 2)\n    dev->if_port = if_port;\n  else\n    pr_notice(\"invalid if_port requested\\n\");\n\n  SET_NETDEV_DEV(dev, &link->dev);\n\n  i = register_netdev(dev);\n  if (i != 0) {\n    pr_notice(\"register_netdev() failed\\n\");\n    goto failed;\n  }\n\n  netdev_info(dev, \"nmclan: port %#3lx, irq %d, %s port, hw_addr %pM\\n\",\n\t      dev->base_addr, dev->irq, if_names[dev->if_port], dev->dev_addr);\n  return 0;\n\nfailed:\n\tnmclan_release(link);\n\treturn -ENODEV;\n}  \n\nstatic void nmclan_release(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"nmclan_release\\n\");\n\tpcmcia_disable_device(link);\n}\n\nstatic int nmclan_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int nmclan_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\tnmclan_reset(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void nmclan_reset(struct net_device *dev)\n{\n  mace_private *lp = netdev_priv(dev);\n\n#if RESET_XILINX\n  struct pcmcia_device *link = &lp->link;\n  u8 OrigCorValue;\n\n   \n  pcmcia_read_config_byte(link, CISREG_COR, &OrigCorValue);\n\n   \n  dev_dbg(&link->dev, \"nmclan_reset: OrigCorValue=0x%x, resetting...\\n\",\n\tOrigCorValue);\n  pcmcia_write_config_byte(link, CISREG_COR, COR_SOFT_RESET);\n   \n\n   \n  pcmcia_write_config_byte(link, CISREG_COR,\n\t\t\t  (COR_LEVEL_REQ | (OrigCorValue & COR_CONFIG_MASK)));\n   \n  lp->tx_free_frames=AM2150_MAX_TX_FRAMES;\n\n#endif  \n\n   \n  lp->tx_free_frames=AM2150_MAX_TX_FRAMES;\n\n   \n  mace_init(lp, dev->base_addr, dev->dev_addr);\n  mace_write(lp, dev->base_addr, MACE_IMR, MACE_IMR_DEFAULT);\n\n   \n  restore_multicast_list(dev);\n}  \n\n \nstatic int mace_config(struct net_device *dev, struct ifmap *map)\n{\n  if ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\n    if (map->port <= 2) {\n      dev->if_port = map->port;\n      netdev_info(dev, \"switched to %s port\\n\", if_names[dev->if_port]);\n    } else\n      return -EINVAL;\n  }\n  return 0;\n}  \n\n \nstatic int mace_open(struct net_device *dev)\n{\n  unsigned int ioaddr = dev->base_addr;\n  mace_private *lp = netdev_priv(dev);\n  struct pcmcia_device *link = lp->p_dev;\n\n  if (!pcmcia_dev_present(link))\n    return -ENODEV;\n\n  link->open++;\n\n  MACEBANK(0);\n\n  netif_start_queue(dev);\n  nmclan_reset(dev);\n\n  return 0;  \n}  \n\n \nstatic int mace_close(struct net_device *dev)\n{\n  unsigned int ioaddr = dev->base_addr;\n  mace_private *lp = netdev_priv(dev);\n  struct pcmcia_device *link = lp->p_dev;\n\n  dev_dbg(&link->dev, \"%s: shutting down ethercard.\\n\", dev->name);\n\n   \n  outb(0xFF, ioaddr + AM2150_MACE_BASE + MACE_IMR);\n\n  link->open--;\n  netif_stop_queue(dev);\n\n  return 0;\n}  \n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tsnprintf(info->bus_info, sizeof(info->bus_info),\n\t\t\"PCMCIA 0x%lx\", dev->base_addr);\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n};\n\n \n\nstatic void mace_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n  mace_private *lp = netdev_priv(dev);\n  struct pcmcia_device *link = lp->p_dev;\n\n  netdev_notice(dev, \"transmit timed out -- \");\n#if RESET_ON_TIMEOUT\n  pr_cont(\"resetting card\\n\");\n  pcmcia_reset_card(link->socket);\n#else  \n  pr_cont(\"NOT resetting card\\n\");\n#endif  \n  netif_trans_update(dev);  \n  netif_wake_queue(dev);\n}\n\nstatic netdev_tx_t mace_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n  mace_private *lp = netdev_priv(dev);\n  unsigned int ioaddr = dev->base_addr;\n\n  netif_stop_queue(dev);\n\n  pr_debug(\"%s: mace_start_xmit(length = %ld) called.\\n\",\n\tdev->name, (long)skb->len);\n\n#if (!TX_INTERRUPTABLE)\n   \n  outb(MACE_IMR_DEFAULT | MACE_IR_XMTINT,\n    ioaddr + AM2150_MACE_BASE + MACE_IMR);\n  lp->tx_irq_disabled=1;\n#endif  \n\n  {\n     \n\n    dev->stats.tx_bytes += skb->len;\n    lp->tx_free_frames--;\n\n     \n     \n    outw(skb->len, ioaddr + AM2150_XMT);\n     \n    outsw(ioaddr + AM2150_XMT, skb->data, skb->len >> 1);\n    if (skb->len & 1) {\n       \n      outb(skb->data[skb->len-1], ioaddr + AM2150_XMT);\n    }\n\n#if MULTI_TX\n    if (lp->tx_free_frames > 0)\n      netif_start_queue(dev);\n#endif  \n  }\n\n#if (!TX_INTERRUPTABLE)\n   \n  lp->tx_irq_disabled=0;\n  outb(MACE_IMR_DEFAULT, ioaddr + AM2150_MACE_BASE + MACE_IMR);\n#endif  \n\n  dev_kfree_skb(skb);\n\n  return NETDEV_TX_OK;\n}  \n\n \nstatic irqreturn_t mace_interrupt(int irq, void *dev_id)\n{\n  struct net_device *dev = (struct net_device *) dev_id;\n  mace_private *lp = netdev_priv(dev);\n  unsigned int ioaddr;\n  int status;\n  int IntrCnt = MACE_MAX_IR_ITERATIONS;\n\n  if (!dev) {\n    pr_debug(\"mace_interrupt(): irq 0x%X for unknown device.\\n\",\n\t  irq);\n    return IRQ_NONE;\n  }\n\n  ioaddr = dev->base_addr;\n\n  if (lp->tx_irq_disabled) {\n    const char *msg;\n    if (lp->tx_irq_disabled)\n      msg = \"Interrupt with tx_irq_disabled\";\n    else\n      msg = \"Re-entering the interrupt handler\";\n    netdev_notice(dev, \"%s [isr=%02X, imr=%02X]\\n\",\n\t\t  msg,\n\t\t  inb(ioaddr + AM2150_MACE_BASE + MACE_IR),\n\t\t  inb(ioaddr + AM2150_MACE_BASE + MACE_IMR));\n     \n    return IRQ_NONE;\n  }\n\n  if (!netif_device_present(dev)) {\n    netdev_dbg(dev, \"interrupt from dead card\\n\");\n    return IRQ_NONE;\n  }\n\n  do {\n     \n    status = inb(ioaddr + AM2150_MACE_BASE + MACE_IR);\n    if (!(status & ~MACE_IMR_DEFAULT) && IntrCnt == MACE_MAX_IR_ITERATIONS)\n      return IRQ_NONE;\n\n    pr_debug(\"mace_interrupt: irq 0x%X status 0x%X.\\n\", irq, status);\n\n    if (status & MACE_IR_RCVINT) {\n      mace_rx(dev, MACE_MAX_RX_ITERATIONS);\n    }\n\n    if (status & MACE_IR_XMTINT) {\n      unsigned char fifofc;\n      unsigned char xmtrc;\n      unsigned char xmtfs;\n\n      fifofc = inb(ioaddr + AM2150_MACE_BASE + MACE_FIFOFC);\n      if ((fifofc & MACE_FIFOFC_XMTFC)==0) {\n\tdev->stats.tx_errors++;\n\toutb(0xFF, ioaddr + AM2150_XMT_SKIP);\n      }\n\n       \n      xmtrc = inb(ioaddr + AM2150_MACE_BASE + MACE_XMTRC);\n      if (xmtrc & MACE_XMTRC_EXDEF) lp->mace_stats.exdef++;\n      lp->mace_stats.xmtrc += (xmtrc & MACE_XMTRC_XMTRC);\n\n      if (\n        (xmtfs = inb(ioaddr + AM2150_MACE_BASE + MACE_XMTFS)) &\n        MACE_XMTFS_XMTSV  \n      ) {\n\tlp->mace_stats.xmtsv++;\n\n\tif (xmtfs & ~MACE_XMTFS_XMTSV) {\n\t  if (xmtfs & MACE_XMTFS_UFLO) {\n\t     \n\t    lp->mace_stats.uflo++;\n\t  }\n\t  if (xmtfs & MACE_XMTFS_LCOL) {\n\t     \n\t    lp->mace_stats.lcol++;\n\t  }\n\t  if (xmtfs & MACE_XMTFS_MORE) {\n\t     \n\t    lp->mace_stats.more++;\n\t  }\n\t  if (xmtfs & MACE_XMTFS_ONE) {\n\t     \n\t    lp->mace_stats.one++;\n\t  }\n\t  if (xmtfs & MACE_XMTFS_DEFER) {\n\t     \n\t    lp->mace_stats.defer++;\n\t  }\n\t  if (xmtfs & MACE_XMTFS_LCAR) {\n\t     \n\t    lp->mace_stats.lcar++;\n\t  }\n\t  if (xmtfs & MACE_XMTFS_RTRY) {\n\t     \n\t    lp->mace_stats.rtry++;\n\t  }\n        }  \n\n      }  \n\n      dev->stats.tx_packets++;\n      lp->tx_free_frames++;\n      netif_wake_queue(dev);\n    }  \n\n    if (status & ~MACE_IMR_DEFAULT & ~MACE_IR_RCVINT & ~MACE_IR_XMTINT) {\n      if (status & MACE_IR_JAB) {\n         \n        lp->mace_stats.jab++;\n      }\n      if (status & MACE_IR_BABL) {\n         \n        lp->mace_stats.babl++;\n      }\n      if (status & MACE_IR_CERR) {\n\t \n        lp->mace_stats.cerr++;\n      }\n      if (status & MACE_IR_RCVCCO) {\n         \n        lp->mace_stats.rcvcco++;\n      }\n      if (status & MACE_IR_RNTPCO) {\n         \n        lp->mace_stats.rntpco++;\n      }\n      if (status & MACE_IR_MPCO) {\n         \n        lp->mace_stats.mpco++;\n      }\n    }  \n\n  } while ((status & ~MACE_IMR_DEFAULT) && (--IntrCnt));\n\n  return IRQ_HANDLED;\n}  \n\n \nstatic int mace_rx(struct net_device *dev, unsigned char RxCnt)\n{\n  mace_private *lp = netdev_priv(dev);\n  unsigned int ioaddr = dev->base_addr;\n  unsigned char rx_framecnt;\n  unsigned short rx_status;\n\n  while (\n    ((rx_framecnt = inb(ioaddr + AM2150_RCV_FRAME_COUNT)) > 0) &&\n    (rx_framecnt <= 12) &&  \n    (RxCnt--)\n  ) {\n    rx_status = inw(ioaddr + AM2150_RCV);\n\n    pr_debug(\"%s: in mace_rx(), framecnt 0x%X, rx_status\"\n\t  \" 0x%X.\\n\", dev->name, rx_framecnt, rx_status);\n\n    if (rx_status & MACE_RCVFS_RCVSTS) {  \n      dev->stats.rx_errors++;\n      if (rx_status & MACE_RCVFS_OFLO) {\n        lp->mace_stats.oflo++;\n      }\n      if (rx_status & MACE_RCVFS_CLSN) {\n        lp->mace_stats.clsn++;\n      }\n      if (rx_status & MACE_RCVFS_FRAM) {\n\tlp->mace_stats.fram++;\n      }\n      if (rx_status & MACE_RCVFS_FCS) {\n        lp->mace_stats.fcs++;\n      }\n    } else {\n      short pkt_len = (rx_status & ~MACE_RCVFS_RCVSTS) - 4;\n         \n      struct sk_buff *skb;\n\n      lp->mace_stats.rfs_rntpc += inb(ioaddr + AM2150_RCV);\n         \n      lp->mace_stats.rfs_rcvcc += inb(ioaddr + AM2150_RCV);\n         \n\n      pr_debug(\"    receiving packet size 0x%X rx_status\"\n\t    \" 0x%X.\\n\", pkt_len, rx_status);\n\n      skb = netdev_alloc_skb(dev, pkt_len + 2);\n\n      if (skb) {\n\tskb_reserve(skb, 2);\n\tinsw(ioaddr + AM2150_RCV, skb_put(skb, pkt_len), pkt_len>>1);\n\tif (pkt_len & 1)\n\t    *(skb_tail_pointer(skb) - 1) = inb(ioaddr + AM2150_RCV);\n\tskb->protocol = eth_type_trans(skb, dev);\n\n\tnetif_rx(skb);  \n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += pkt_len;\n\toutb(0xFF, ioaddr + AM2150_RCV_NEXT);  \n\tcontinue;\n      } else {\n\tpr_debug(\"%s: couldn't allocate a sk_buff of size\"\n\t      \" %d.\\n\", dev->name, pkt_len);\n\tdev->stats.rx_dropped++;\n      }\n    }\n    outb(0xFF, ioaddr + AM2150_RCV_NEXT);  \n  }  \n\n  return 0;\n}  \n\n \nstatic void pr_linux_stats(struct net_device_stats *pstats)\n{\n  pr_debug(\"pr_linux_stats\\n\");\n  pr_debug(\" rx_packets=%-7ld        tx_packets=%ld\\n\",\n\t(long)pstats->rx_packets, (long)pstats->tx_packets);\n  pr_debug(\" rx_errors=%-7ld         tx_errors=%ld\\n\",\n\t(long)pstats->rx_errors, (long)pstats->tx_errors);\n  pr_debug(\" rx_dropped=%-7ld        tx_dropped=%ld\\n\",\n\t(long)pstats->rx_dropped, (long)pstats->tx_dropped);\n  pr_debug(\" multicast=%-7ld         collisions=%ld\\n\",\n\t(long)pstats->multicast, (long)pstats->collisions);\n\n  pr_debug(\" rx_length_errors=%-7ld  rx_over_errors=%ld\\n\",\n\t(long)pstats->rx_length_errors, (long)pstats->rx_over_errors);\n  pr_debug(\" rx_crc_errors=%-7ld     rx_frame_errors=%ld\\n\",\n\t(long)pstats->rx_crc_errors, (long)pstats->rx_frame_errors);\n  pr_debug(\" rx_fifo_errors=%-7ld    rx_missed_errors=%ld\\n\",\n\t(long)pstats->rx_fifo_errors, (long)pstats->rx_missed_errors);\n\n  pr_debug(\" tx_aborted_errors=%-7ld tx_carrier_errors=%ld\\n\",\n\t(long)pstats->tx_aborted_errors, (long)pstats->tx_carrier_errors);\n  pr_debug(\" tx_fifo_errors=%-7ld    tx_heartbeat_errors=%ld\\n\",\n\t(long)pstats->tx_fifo_errors, (long)pstats->tx_heartbeat_errors);\n  pr_debug(\" tx_window_errors=%ld\\n\",\n\t(long)pstats->tx_window_errors);\n}  \n\n \nstatic void pr_mace_stats(mace_statistics *pstats)\n{\n  pr_debug(\"pr_mace_stats\\n\");\n\n  pr_debug(\" xmtsv=%-7d             uflo=%d\\n\",\n\tpstats->xmtsv, pstats->uflo);\n  pr_debug(\" lcol=%-7d              more=%d\\n\",\n\tpstats->lcol, pstats->more);\n  pr_debug(\" one=%-7d               defer=%d\\n\",\n\tpstats->one, pstats->defer);\n  pr_debug(\" lcar=%-7d              rtry=%d\\n\",\n\tpstats->lcar, pstats->rtry);\n\n   \n  pr_debug(\" exdef=%-7d             xmtrc=%d\\n\",\n\tpstats->exdef, pstats->xmtrc);\n\n   \n  pr_debug(\" oflo=%-7d              clsn=%d\\n\",\n\tpstats->oflo, pstats->clsn);\n  pr_debug(\" fram=%-7d              fcs=%d\\n\",\n\tpstats->fram, pstats->fcs);\n\n   \n   \n  pr_debug(\" rfs_rntpc=%-7d         rfs_rcvcc=%d\\n\",\n\tpstats->rfs_rntpc, pstats->rfs_rcvcc);\n\n   \n  pr_debug(\" jab=%-7d               babl=%d\\n\",\n\tpstats->jab, pstats->babl);\n  pr_debug(\" cerr=%-7d              rcvcco=%d\\n\",\n\tpstats->cerr, pstats->rcvcco);\n  pr_debug(\" rntpco=%-7d            mpco=%d\\n\",\n\tpstats->rntpco, pstats->mpco);\n\n   \n  pr_debug(\" mpc=%d\\n\", pstats->mpc);\n\n   \n  pr_debug(\" rntpc=%d\\n\", pstats->rntpc);\n\n   \n  pr_debug(\" rcvcc=%d\\n\", pstats->rcvcc);\n\n}  \n\n \nstatic void update_stats(unsigned int ioaddr, struct net_device *dev)\n{\n  mace_private *lp = netdev_priv(dev);\n\n  lp->mace_stats.rcvcc += mace_read(lp, ioaddr, MACE_RCVCC);\n  lp->mace_stats.rntpc += mace_read(lp, ioaddr, MACE_RNTPC);\n  lp->mace_stats.mpc += mace_read(lp, ioaddr, MACE_MPC);\n   \n\n   \n\n   \n  dev->stats.collisions =\n    lp->mace_stats.rcvcco * 256 + lp->mace_stats.rcvcc;\n     \n\n   \n  dev->stats.rx_length_errors =\n    lp->mace_stats.rntpco * 256 + lp->mace_stats.rntpc;\n   \n  dev->stats.rx_crc_errors = lp->mace_stats.fcs;\n  dev->stats.rx_frame_errors = lp->mace_stats.fram;\n  dev->stats.rx_fifo_errors = lp->mace_stats.oflo;\n  dev->stats.rx_missed_errors =\n    lp->mace_stats.mpco * 256 + lp->mace_stats.mpc;\n\n   \n  dev->stats.tx_aborted_errors = lp->mace_stats.rtry;\n  dev->stats.tx_carrier_errors = lp->mace_stats.lcar;\n     \n  dev->stats.tx_fifo_errors = lp->mace_stats.uflo;\n  dev->stats.tx_heartbeat_errors = lp->mace_stats.cerr;\n   \n}  \n\n \nstatic struct net_device_stats *mace_get_stats(struct net_device *dev)\n{\n  mace_private *lp = netdev_priv(dev);\n\n  update_stats(dev->base_addr, dev);\n\n  pr_debug(\"%s: updating the statistics.\\n\", dev->name);\n  pr_linux_stats(&dev->stats);\n  pr_mace_stats(&lp->mace_stats);\n\n  return &dev->stats;\n}  \n\n \n\n#ifdef BROKEN_MULTICAST\n\nstatic void updateCRC(int *CRC, int bit)\n{\n  static const int poly[]={\n    1,1,1,0, 1,1,0,1,\n    1,0,1,1, 1,0,0,0,\n    1,0,0,0, 0,0,1,1,\n    0,0,1,0, 0,0,0,0\n  };  \n\n  int j;\n\n   \n  for (j = 32; j > 0; j--)\n    CRC[j] = CRC[j-1];\n  CRC[0] = 0;\n\n   \n  if (bit ^ CRC[32])\n    for (j = 0; j < 32; j++)\n      CRC[j] ^= poly[j];\n}  \n\n \nstatic void BuildLAF(int *ladrf, int *adr)\n{\n  int CRC[33]={1};  \n\n  int i, byte;  \n  int hashcode;  \n\n  CRC[32]=0;\n\n  for (byte = 0; byte < 6; byte++)\n    for (i = 0; i < 8; i++)\n      updateCRC(CRC, (adr[byte] >> i) & 1);\n\n  hashcode = 0;\n  for (i = 0; i < 6; i++)\n    hashcode = (hashcode << 1) + CRC[i];\n\n  byte = hashcode >> 3;\n  ladrf[byte] |= (1 << (hashcode & 7));\n\n#ifdef PCMCIA_DEBUG\n  if (0)\n    printk(KERN_DEBUG \"    adr =%pM\\n\", adr);\n  printk(KERN_DEBUG \"    hashcode = %d(decimal), ladrf[0:63] =\", hashcode);\n  for (i = 0; i < 8; i++)\n    pr_cont(\" %02X\", ladrf[i]);\n  pr_cont(\"\\n\");\n#endif\n}  \n\n \nstatic void restore_multicast_list(struct net_device *dev)\n{\n  mace_private *lp = netdev_priv(dev);\n  int num_addrs = lp->multicast_num_addrs;\n  int *ladrf = lp->multicast_ladrf;\n  unsigned int ioaddr = dev->base_addr;\n  int i;\n\n  pr_debug(\"%s: restoring Rx mode to %d addresses.\\n\",\n\tdev->name, num_addrs);\n\n  if (num_addrs > 0) {\n\n    pr_debug(\"Attempt to restore multicast list detected.\\n\");\n\n    mace_write(lp, ioaddr, MACE_IAC, MACE_IAC_ADDRCHG | MACE_IAC_LOGADDR);\n     \n    while (mace_read(lp, ioaddr, MACE_IAC) & MACE_IAC_ADDRCHG)\n      ;\n     \n    for (i = 0; i < MACE_LADRF_LEN; i++)\n      mace_write(lp, ioaddr, MACE_LADRF, ladrf[i]);\n\n    mace_write(lp, ioaddr, MACE_UTR, MACE_UTR_RCVFCSE | MACE_UTR_LOOP_EXTERNAL);\n    mace_write(lp, ioaddr, MACE_MACCC, MACE_MACCC_ENXMT | MACE_MACCC_ENRCV);\n\n  } else if (num_addrs < 0) {\n\n     \n    mace_write(lp, ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\n    mace_write(lp, ioaddr, MACE_MACCC,\n      MACE_MACCC_PROM | MACE_MACCC_ENXMT | MACE_MACCC_ENRCV\n    );\n\n  } else {\n\n     \n    mace_write(lp, ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\n    mace_write(lp, ioaddr, MACE_MACCC, MACE_MACCC_ENXMT | MACE_MACCC_ENRCV);\n\n  }\n}  \n\n \n\nstatic void set_multicast_list(struct net_device *dev)\n{\n  mace_private *lp = netdev_priv(dev);\n  int adr[ETH_ALEN] = {0};  \n  struct netdev_hw_addr *ha;\n\n#ifdef PCMCIA_DEBUG\n  {\n    static int old;\n    if (netdev_mc_count(dev) != old) {\n      old = netdev_mc_count(dev);\n      pr_debug(\"%s: setting Rx mode to %d addresses.\\n\",\n\t    dev->name, old);\n    }\n  }\n#endif\n\n   \n  lp->multicast_num_addrs = netdev_mc_count(dev);\n\n   \n  if (num_addrs > 0) {\n     \n    memset(lp->multicast_ladrf, 0, MACE_LADRF_LEN);\n    netdev_for_each_mc_addr(ha, dev) {\n      memcpy(adr, ha->addr, ETH_ALEN);\n      BuildLAF(lp->multicast_ladrf, adr);\n    }\n  }\n\n  restore_multicast_list(dev);\n\n}  \n\n#endif  \n\nstatic void restore_multicast_list(struct net_device *dev)\n{\n  unsigned int ioaddr = dev->base_addr;\n  mace_private *lp = netdev_priv(dev);\n\n  pr_debug(\"%s: restoring Rx mode to %d addresses.\\n\", dev->name,\n\tlp->multicast_num_addrs);\n\n  if (dev->flags & IFF_PROMISC) {\n     \n    mace_write(lp,ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\n    mace_write(lp, ioaddr, MACE_MACCC,\n      MACE_MACCC_PROM | MACE_MACCC_ENXMT | MACE_MACCC_ENRCV\n    );\n  } else {\n     \n    mace_write(lp, ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\n    mace_write(lp, ioaddr, MACE_MACCC, MACE_MACCC_ENXMT | MACE_MACCC_ENRCV);\n  }\n}  \n\nstatic void set_multicast_list(struct net_device *dev)\n{\n  mace_private *lp = netdev_priv(dev);\n\n#ifdef PCMCIA_DEBUG\n  {\n    static int old;\n    if (netdev_mc_count(dev) != old) {\n      old = netdev_mc_count(dev);\n      pr_debug(\"%s: setting Rx mode to %d addresses.\\n\",\n\t    dev->name, old);\n    }\n  }\n#endif\n\n  lp->multicast_num_addrs = netdev_mc_count(dev);\n  restore_multicast_list(dev);\n\n}  \n\nstatic const struct pcmcia_device_id nmclan_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID12(\"New Media Corporation\", \"Ethernet\", 0x085a850b, 0x00b2e941),\n\tPCMCIA_DEVICE_PROD_ID12(\"Portable Add-ons\", \"Ethernet+\", 0xebf1d60, 0xad673aaf),\n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, nmclan_ids);\n\nstatic struct pcmcia_driver nmclan_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nmclan_cs\",\n\t.probe\t\t= nmclan_probe,\n\t.remove\t\t= nmclan_detach,\n\t.id_table       = nmclan_ids,\n\t.suspend\t= nmclan_suspend,\n\t.resume\t\t= nmclan_resume,\n};\nmodule_pcmcia_driver(nmclan_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}