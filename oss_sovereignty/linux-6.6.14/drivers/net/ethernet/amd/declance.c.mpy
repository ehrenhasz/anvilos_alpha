{
  "module_name": "declance.c",
  "hash_id": "2a0cb13e2cd7abe4a1f7dead66b5d8fe5718b2f5c3de6ebe85aafa95bb9708e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/declance.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/tc.h>\n#include <linux/types.h>\n\n#include <asm/addrspace.h>\n\n#include <asm/dec/interrupts.h>\n#include <asm/dec/ioasic.h>\n#include <asm/dec/ioasic_addrs.h>\n#include <asm/dec/kn01.h>\n#include <asm/dec/machtype.h>\n#include <asm/dec/system.h>\n\nstatic const char version[] =\n\"declance.c: v0.011 by Linux MIPS DECstation task force\\n\";\n\nMODULE_AUTHOR(\"Linux MIPS DECstation task force\");\nMODULE_DESCRIPTION(\"DEC LANCE (DECstation onboard, PMAD-xx) driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define __unused __attribute__ ((unused))\n\n \n#define ASIC_LANCE 1\n#define PMAD_LANCE 2\n#define PMAX_LANCE 3\n\n\n#define LE_CSR0 0\n#define LE_CSR1 1\n#define LE_CSR2 2\n#define LE_CSR3 3\n\n#define LE_MO_PROM      0x8000\t \n\n#define\tLE_C0_ERR\t0x8000\t \n#define\tLE_C0_BABL\t0x4000\t \n#define\tLE_C0_CERR\t0x2000\t \n#define\tLE_C0_MISS\t0x1000\t \n#define\tLE_C0_MERR\t0x0800\t \n#define\tLE_C0_RINT\t0x0400\t \n#define\tLE_C0_TINT\t0x0200\t \n#define\tLE_C0_IDON\t0x0100\t \n#define\tLE_C0_INTR\t0x0080\t \n#define\tLE_C0_INEA\t0x0040\t \n#define\tLE_C0_RXON\t0x0020\t \n#define\tLE_C0_TXON\t0x0010\t \n#define\tLE_C0_TDMD\t0x0008\t \n#define\tLE_C0_STOP\t0x0004\t \n#define\tLE_C0_STRT\t0x0002\t \n#define\tLE_C0_INIT\t0x0001\t \n\n#define\tLE_C3_BSWP\t0x4\t \n#define\tLE_C3_ACON\t0x2\t \n#define\tLE_C3_BCON\t0x1\t \n\n \n#define LE_R1_OWN\t0x8000\t \n#define LE_R1_ERR\t0x4000\t \n#define LE_R1_FRA\t0x2000\t \n#define LE_R1_OFL\t0x1000\t \n#define LE_R1_CRC\t0x0800\t \n#define LE_R1_BUF\t0x0400\t \n#define LE_R1_SOP\t0x0200\t \n#define LE_R1_EOP\t0x0100\t \n#define LE_R1_POK\t0x0300\t \n\n \n#define LE_T1_OWN\t0x8000\t \n#define LE_T1_ERR\t0x4000\t \n#define LE_T1_EMORE\t0x1000\t \n#define LE_T1_EONE\t0x0800\t \n#define LE_T1_EDEF\t0x0400\t \n#define LE_T1_SOP\t0x0200\t \n#define LE_T1_EOP\t0x0100\t \n#define LE_T1_POK\t0x0300\t \n\n#define LE_T3_BUF       0x8000\t \n#define LE_T3_UFL       0x4000\t \n#define LE_T3_LCOL      0x1000\t \n#define LE_T3_CLOS      0x0800\t \n#define LE_T3_RTY       0x0400\t \n#define LE_T3_TDR       0x03ff\t \n\n \n\n#ifndef LANCE_LOG_TX_BUFFERS\n#define LANCE_LOG_TX_BUFFERS 4\n#define LANCE_LOG_RX_BUFFERS 4\n#endif\n\n#define TX_RING_SIZE\t\t\t(1 << (LANCE_LOG_TX_BUFFERS))\n#define TX_RING_MOD_MASK\t\t(TX_RING_SIZE - 1)\n\n#define RX_RING_SIZE\t\t\t(1 << (LANCE_LOG_RX_BUFFERS))\n#define RX_RING_MOD_MASK\t\t(RX_RING_SIZE - 1)\n\n#define PKT_BUF_SZ\t\t1536\n#define RX_BUFF_SIZE            PKT_BUF_SZ\n#define TX_BUFF_SIZE            PKT_BUF_SZ\n\n#undef TEST_HITS\n#define ZERO 0\n\n \n\nstruct lance_rx_desc {\n\tunsigned short rmd0;\t\t \n\tunsigned short rmd1;\t\t \n\tshort length;\t\t\t \n\tunsigned short mblength;\t \n};\n\nstruct lance_tx_desc {\n\tunsigned short tmd0;\t\t \n\tunsigned short tmd1;\t\t \n\tshort length;\t\t\t \n\tunsigned short misc;\n};\n\n\n \nstruct lance_init_block {\n\tunsigned short mode;\t\t \n\n\tunsigned short phys_addr[3];\t \n\tunsigned short filter[4];\t \n\n\t \n\tunsigned short rx_ptr;\t\t \n\tunsigned short rx_len;\t\t \n\tunsigned short tx_ptr;\t\t \n\tunsigned short tx_len;\t\t \n\n\tshort gap[4];\n\n\t \n\tstruct lance_rx_desc brx_ring[RX_RING_SIZE];\n\tstruct lance_tx_desc btx_ring[TX_RING_SIZE];\n};\n\n#define BUF_OFFSET_CPU sizeof(struct lance_init_block)\n#define BUF_OFFSET_LNC sizeof(struct lance_init_block)\n\n#define shift_off(off, type)\t\t\t\t\t\t\\\n\t(type == ASIC_LANCE || type == PMAX_LANCE ? off << 1 : off)\n\n#define lib_off(rt, type)\t\t\t\t\t\t\\\n\tshift_off(offsetof(struct lance_init_block, rt), type)\n\n#define lib_ptr(ib, rt, type) \t\t\t\t\t\t\\\n\t((volatile u16 *)((u8 *)(ib) + lib_off(rt, type)))\n\n#define rds_off(rt, type)\t\t\t\t\t\t\\\n\tshift_off(offsetof(struct lance_rx_desc, rt), type)\n\n#define rds_ptr(rd, rt, type) \t\t\t\t\t\t\\\n\t((volatile u16 *)((u8 *)(rd) + rds_off(rt, type)))\n\n#define tds_off(rt, type)\t\t\t\t\t\t\\\n\tshift_off(offsetof(struct lance_tx_desc, rt), type)\n\n#define tds_ptr(td, rt, type) \t\t\t\t\t\t\\\n\t((volatile u16 *)((u8 *)(td) + tds_off(rt, type)))\n\nstruct lance_private {\n\tstruct net_device *next;\n\tint type;\n\tint dma_irq;\n\tvolatile struct lance_regs *ll;\n\n\tspinlock_t\tlock;\n\n\tint rx_new, tx_new;\n\tint rx_old, tx_old;\n\n\tunsigned short busmaster_regval;\n\n\tstruct timer_list       multicast_timer;\n\tstruct net_device\t*dev;\n\n\t \n\tchar *rx_buf_ptr_cpu[RX_RING_SIZE];\n\tchar *tx_buf_ptr_cpu[TX_RING_SIZE];\n\n\t \n\tuint rx_buf_ptr_lnc[RX_RING_SIZE];\n\tuint tx_buf_ptr_lnc[TX_RING_SIZE];\n};\n\n#define TX_BUFFS_AVAIL ((lp->tx_old<=lp->tx_new)?\\\n\t\t\tlp->tx_old+TX_RING_MOD_MASK-lp->tx_new:\\\n\t\t\tlp->tx_old - lp->tx_new-1)\n\n \nstruct lance_regs {\n\tvolatile unsigned short rdp;\t \n\tunsigned short pad;\n\tvolatile unsigned short rap;\t \n};\n\nint dec_lance_debug = 2;\n\nstatic struct tc_driver dec_lance_tc_driver;\nstatic struct net_device *root_lance_dev;\n\nstatic inline void writereg(volatile unsigned short *regptr, short value)\n{\n\t*regptr = value;\n\tiob();\n}\n\n \nstatic void load_csrs(struct lance_private *lp)\n{\n\tvolatile struct lance_regs *ll = lp->ll;\n\tuint leptr;\n\n\t \n\tleptr = 0;\n\n\twritereg(&ll->rap, LE_CSR1);\n\twritereg(&ll->rdp, (leptr & 0xFFFF));\n\twritereg(&ll->rap, LE_CSR2);\n\twritereg(&ll->rdp, leptr >> 16);\n\twritereg(&ll->rap, LE_CSR3);\n\twritereg(&ll->rdp, lp->busmaster_regval);\n\n\t \n\twritereg(&ll->rap, LE_CSR0);\n}\n\n \nstatic void cp_to_buf(const int type, void *to, const void *from, int len)\n{\n\tunsigned short *tp;\n\tconst unsigned short *fp;\n\tunsigned short clen;\n\tunsigned char *rtp;\n\tconst unsigned char *rfp;\n\n\tif (type == PMAD_LANCE) {\n\t\tmemcpy(to, from, len);\n\t} else if (type == PMAX_LANCE) {\n\t\tclen = len >> 1;\n\t\ttp = to;\n\t\tfp = from;\n\n\t\twhile (clen--) {\n\t\t\t*tp++ = *fp++;\n\t\t\ttp++;\n\t\t}\n\n\t\tclen = len & 1;\n\t\trtp = (unsigned char *)tp;\n\t\trfp = (const unsigned char *)fp;\n\t\twhile (clen--) {\n\t\t\t*rtp++ = *rfp++;\n\t\t}\n\t} else {\n\t\t \n\t\tclen = len >> 4;\n\t\ttp = to;\n\t\tfp = from;\n\t\twhile (clen--) {\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\ttp += 8;\n\t\t}\n\n\t\t \n\t\tclen = len & 15;\n\t\trtp = (unsigned char *)tp;\n\t\trfp = (const unsigned char *)fp;\n\t\twhile (clen--) {\n\t\t\t*rtp++ = *rfp++;\n\t\t}\n\t}\n\n\tiob();\n}\n\nstatic void cp_from_buf(const int type, void *to, const void *from, int len)\n{\n\tunsigned short *tp;\n\tconst unsigned short *fp;\n\tunsigned short clen;\n\tunsigned char *rtp;\n\tconst unsigned char *rfp;\n\n\tif (type == PMAD_LANCE) {\n\t\tmemcpy(to, from, len);\n\t} else if (type == PMAX_LANCE) {\n\t\tclen = len >> 1;\n\t\ttp = to;\n\t\tfp = from;\n\t\twhile (clen--) {\n\t\t\t*tp++ = *fp++;\n\t\t\tfp++;\n\t\t}\n\n\t\tclen = len & 1;\n\n\t\trtp = (unsigned char *)tp;\n\t\trfp = (const unsigned char *)fp;\n\n\t\twhile (clen--) {\n\t\t\t*rtp++ = *rfp++;\n\t\t}\n\t} else {\n\n\t\t \n\t\tclen = len >> 4;\n\t\ttp = to;\n\t\tfp = from;\n\t\twhile (clen--) {\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\t*tp++ = *fp++;\n\t\t\tfp += 8;\n\t\t}\n\n\t\t \n\t\tclen = len & 15;\n\t\trtp = (unsigned char *)tp;\n\t\trfp = (const unsigned char *)fp;\n\t\twhile (clen--) {\n\t\t\t*rtp++ = *rfp++;\n\t\t}\n\n\n\t}\n\n}\n\n \nstatic void lance_init_ring(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile u16 *ib = (volatile u16 *)dev->mem_start;\n\tuint leptr;\n\tint i;\n\n\t \n\tnetif_stop_queue(dev);\n\tlp->rx_new = lp->tx_new = 0;\n\tlp->rx_old = lp->tx_old = 0;\n\n\t \n\t*lib_ptr(ib, phys_addr[0], lp->type) = (dev->dev_addr[1] << 8) |\n\t\t\t\t     dev->dev_addr[0];\n\t*lib_ptr(ib, phys_addr[1], lp->type) = (dev->dev_addr[3] << 8) |\n\t\t\t\t     dev->dev_addr[2];\n\t*lib_ptr(ib, phys_addr[2], lp->type) = (dev->dev_addr[5] << 8) |\n\t\t\t\t     dev->dev_addr[4];\n\t \n\n\t \n\tleptr = offsetof(struct lance_init_block, brx_ring);\n\t*lib_ptr(ib, rx_len, lp->type) = (LANCE_LOG_RX_BUFFERS << 13) |\n\t\t\t\t\t (leptr >> 16);\n\t*lib_ptr(ib, rx_ptr, lp->type) = leptr;\n\tif (ZERO)\n\t\tprintk(\"RX ptr: %8.8x(%8.8x)\\n\",\n\t\t       leptr, (uint)lib_off(brx_ring, lp->type));\n\n\t \n\tleptr = offsetof(struct lance_init_block, btx_ring);\n\t*lib_ptr(ib, tx_len, lp->type) = (LANCE_LOG_TX_BUFFERS << 13) |\n\t\t\t\t\t (leptr >> 16);\n\t*lib_ptr(ib, tx_ptr, lp->type) = leptr;\n\tif (ZERO)\n\t\tprintk(\"TX ptr: %8.8x(%8.8x)\\n\",\n\t\t       leptr, (uint)lib_off(btx_ring, lp->type));\n\n\tif (ZERO)\n\t\tprintk(\"TX rings:\\n\");\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tleptr = lp->tx_buf_ptr_lnc[i];\n\t\t*lib_ptr(ib, btx_ring[i].tmd0, lp->type) = leptr;\n\t\t*lib_ptr(ib, btx_ring[i].tmd1, lp->type) = (leptr >> 16) &\n\t\t\t\t\t\t\t   0xff;\n\t\t*lib_ptr(ib, btx_ring[i].length, lp->type) = 0xf000;\n\t\t\t\t\t\t \n\t\t*lib_ptr(ib, btx_ring[i].misc, lp->type) = 0;\n\t\tif (i < 3 && ZERO)\n\t\t\tprintk(\"%d: %8.8x(%p)\\n\",\n\t\t\t       i, leptr, lp->tx_buf_ptr_cpu[i]);\n\t}\n\n\t \n\tif (ZERO)\n\t\tprintk(\"RX rings:\\n\");\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tleptr = lp->rx_buf_ptr_lnc[i];\n\t\t*lib_ptr(ib, brx_ring[i].rmd0, lp->type) = leptr;\n\t\t*lib_ptr(ib, brx_ring[i].rmd1, lp->type) = ((leptr >> 16) &\n\t\t\t\t\t\t\t    0xff) |\n\t\t\t\t\t\t\t   LE_R1_OWN;\n\t\t*lib_ptr(ib, brx_ring[i].length, lp->type) = -RX_BUFF_SIZE |\n\t\t\t\t\t\t\t     0xf000;\n\t\t*lib_ptr(ib, brx_ring[i].mblength, lp->type) = 0;\n\t\tif (i < 3 && ZERO)\n\t\t\tprintk(\"%d: %8.8x(%p)\\n\",\n\t\t\t       i, leptr, lp->rx_buf_ptr_cpu[i]);\n\t}\n\tiob();\n}\n\nstatic int init_restart_lance(struct lance_private *lp)\n{\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint i;\n\n\twritereg(&ll->rap, LE_CSR0);\n\twritereg(&ll->rdp, LE_C0_INIT);\n\n\t \n\tfor (i = 0; (i < 100) && !(ll->rdp & LE_C0_IDON); i++) {\n\t\tudelay(10);\n\t}\n\tif ((i == 100) || (ll->rdp & LE_C0_ERR)) {\n\t\tprintk(\"LANCE unopened after %d ticks, csr0=%4.4x.\\n\",\n\t\t       i, ll->rdp);\n\t\treturn -1;\n\t}\n\tif ((ll->rdp & LE_C0_ERR)) {\n\t\tprintk(\"LANCE unopened after %d ticks, csr0=%4.4x.\\n\",\n\t\t       i, ll->rdp);\n\t\treturn -1;\n\t}\n\twritereg(&ll->rdp, LE_C0_IDON);\n\twritereg(&ll->rdp, LE_C0_STRT);\n\twritereg(&ll->rdp, LE_C0_INEA);\n\n\treturn 0;\n}\n\nstatic int lance_rx(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile u16 *ib = (volatile u16 *)dev->mem_start;\n\tvolatile u16 *rd;\n\tunsigned short bits;\n\tint entry, len;\n\tstruct sk_buff *skb;\n\n#ifdef TEST_HITS\n\t{\n\t\tint i;\n\n\t\tprintk(\"[\");\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tif (i == lp->rx_new)\n\t\t\t\tprintk(\"%s\", *lib_ptr(ib, brx_ring[i].rmd1,\n\t\t\t\t\t\t      lp->type) &\n\t\t\t\t\t     LE_R1_OWN ? \"_\" : \"X\");\n\t\t\telse\n\t\t\t\tprintk(\"%s\", *lib_ptr(ib, brx_ring[i].rmd1,\n\t\t\t\t\t\t      lp->type) &\n\t\t\t\t\t     LE_R1_OWN ? \".\" : \"1\");\n\t\t}\n\t\tprintk(\"]\");\n\t}\n#endif\n\n\tfor (rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type);\n\t     !((bits = *rds_ptr(rd, rmd1, lp->type)) & LE_R1_OWN);\n\t     rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type)) {\n\t\tentry = lp->rx_new;\n\n\t\t \n\t\tif ((bits & LE_R1_POK) != LE_R1_POK) {\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tdev->stats.rx_errors++;\n\t\t} else if (bits & LE_R1_ERR) {\n\t\t\t \n\t\t\tif (bits & LE_R1_BUF)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tif (bits & LE_R1_CRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (bits & LE_R1_OFL)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif (bits & LE_R1_FRA)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (bits & LE_R1_EOP)\n\t\t\t\tdev->stats.rx_errors++;\n\t\t} else {\n\t\t\tlen = (*rds_ptr(rd, mblength, lp->type) & 0xfff) - 4;\n\t\t\tskb = netdev_alloc_skb(dev, len + 2);\n\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t*rds_ptr(rd, mblength, lp->type) = 0;\n\t\t\t\t*rds_ptr(rd, rmd1, lp->type) =\n\t\t\t\t\t((lp->rx_buf_ptr_lnc[entry] >> 16) &\n\t\t\t\t\t 0xff) | LE_R1_OWN;\n\t\t\t\tlp->rx_new = (entry + 1) & RX_RING_MOD_MASK;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdev->stats.rx_bytes += len;\n\n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tskb_put(skb, len);\t \n\n\t\t\tcp_from_buf(lp->type, skb->data,\n\t\t\t\t    lp->rx_buf_ptr_cpu[entry], len);\n\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\n\t\t \n\t\t*rds_ptr(rd, mblength, lp->type) = 0;\n\t\t*rds_ptr(rd, length, lp->type) = -RX_BUFF_SIZE | 0xf000;\n\t\t*rds_ptr(rd, rmd1, lp->type) =\n\t\t\t((lp->rx_buf_ptr_lnc[entry] >> 16) & 0xff) | LE_R1_OWN;\n\t\tlp->rx_new = (entry + 1) & RX_RING_MOD_MASK;\n\t}\n\treturn 0;\n}\n\nstatic void lance_tx(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile u16 *ib = (volatile u16 *)dev->mem_start;\n\tvolatile struct lance_regs *ll = lp->ll;\n\tvolatile u16 *td;\n\tint i, j;\n\tint status;\n\n\tj = lp->tx_old;\n\n\tspin_lock(&lp->lock);\n\n\tfor (i = j; i != lp->tx_new; i = j) {\n\t\ttd = lib_ptr(ib, btx_ring[i], lp->type);\n\t\t \n\t\tif (*tds_ptr(td, tmd1, lp->type) & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tif (*tds_ptr(td, tmd1, lp->type) & LE_T1_ERR) {\n\t\t\tstatus = *tds_ptr(td, misc, lp->type);\n\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (status & LE_T3_RTY)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tif (status & LE_T3_LCOL)\n\t\t\t\tdev->stats.tx_window_errors++;\n\n\t\t\tif (status & LE_T3_CLOS) {\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\tprintk(\"%s: Carrier Lost\\n\", dev->name);\n\t\t\t\t \n\t\t\t\twritereg(&ll->rap, LE_CSR0);\n\t\t\t\twritereg(&ll->rdp, LE_C0_STOP);\n\t\t\t\tlance_init_ring(dev);\n\t\t\t\tload_csrs(lp);\n\t\t\t\tinit_restart_lance(lp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (status & (LE_T3_BUF | LE_T3_UFL)) {\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\n\t\t\t\tprintk(\"%s: Tx: ERR_BUF|ERR_UFL, restarting\\n\",\n\t\t\t\t       dev->name);\n\t\t\t\t \n\t\t\t\twritereg(&ll->rap, LE_CSR0);\n\t\t\t\twritereg(&ll->rdp, LE_C0_STOP);\n\t\t\t\tlance_init_ring(dev);\n\t\t\t\tload_csrs(lp);\n\t\t\t\tinit_restart_lance(lp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if ((*tds_ptr(td, tmd1, lp->type) & LE_T1_POK) ==\n\t\t\t   LE_T1_POK) {\n\t\t\t \n\t\t\t*tds_ptr(td, tmd1, lp->type) &= ~(LE_T1_POK);\n\n\t\t\t \n\t\t\tif (*tds_ptr(td, tmd1, lp->type) & LE_T1_EONE)\n\t\t\t\tdev->stats.collisions++;\n\n\t\t\t \n\t\t\tif (*tds_ptr(td, tmd1, lp->type) & LE_T1_EMORE)\n\t\t\t\tdev->stats.collisions += 2;\n\n\t\t\tdev->stats.tx_packets++;\n\t\t}\n\t\tj = (j + 1) & TX_RING_MOD_MASK;\n\t}\n\tlp->tx_old = j;\nout:\n\tif (netif_queue_stopped(dev) &&\n\t    TX_BUFFS_AVAIL > 0)\n\t\tnetif_wake_queue(dev);\n\n\tspin_unlock(&lp->lock);\n}\n\nstatic irqreturn_t lance_dma_merr_int(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\n\tprintk(KERN_ERR \"%s: DMA error\\n\", dev->name);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint csr0;\n\n\twritereg(&ll->rap, LE_CSR0);\n\tcsr0 = ll->rdp;\n\n\t \n\twritereg(&ll->rdp, csr0 & (LE_C0_INTR | LE_C0_TINT | LE_C0_RINT));\n\n\tif ((csr0 & LE_C0_ERR)) {\n\t\t \n\t\twritereg(&ll->rdp, LE_C0_BABL | LE_C0_ERR | LE_C0_MISS |\n\t\t\t LE_C0_CERR | LE_C0_MERR);\n\t}\n\tif (csr0 & LE_C0_RINT)\n\t\tlance_rx(dev);\n\n\tif (csr0 & LE_C0_TINT)\n\t\tlance_tx(dev);\n\n\tif (csr0 & LE_C0_BABL)\n\t\tdev->stats.tx_errors++;\n\n\tif (csr0 & LE_C0_MISS)\n\t\tdev->stats.rx_errors++;\n\n\tif (csr0 & LE_C0_MERR) {\n\t\tprintk(\"%s: Memory error, status %04x\\n\", dev->name, csr0);\n\n\t\twritereg(&ll->rdp, LE_C0_STOP);\n\n\t\tlance_init_ring(dev);\n\t\tload_csrs(lp);\n\t\tinit_restart_lance(lp);\n\t\tnetif_wake_queue(dev);\n\t}\n\n\twritereg(&ll->rdp, LE_C0_INEA);\n\twritereg(&ll->rdp, LE_C0_INEA);\n\treturn IRQ_HANDLED;\n}\n\nstatic int lance_open(struct net_device *dev)\n{\n\tvolatile u16 *ib = (volatile u16 *)dev->mem_start;\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint status = 0;\n\n\t \n\twritereg(&ll->rap, LE_CSR0);\n\twritereg(&ll->rdp, LE_C0_STOP);\n\n\t \n\t*lib_ptr(ib, mode, lp->type) = 0;\n\t*lib_ptr(ib, filter[0], lp->type) = 0;\n\t*lib_ptr(ib, filter[1], lp->type) = 0;\n\t*lib_ptr(ib, filter[2], lp->type) = 0;\n\t*lib_ptr(ib, filter[3], lp->type) = 0;\n\n\tlance_init_ring(dev);\n\tload_csrs(lp);\n\n\tnetif_start_queue(dev);\n\n\t \n\tif (request_irq(dev->irq, lance_interrupt, 0, \"lance\", dev)) {\n\t\tprintk(\"%s: Can't get IRQ %d\\n\", dev->name, dev->irq);\n\t\treturn -EAGAIN;\n\t}\n\tif (lp->dma_irq >= 0) {\n\t\tunsigned long flags;\n\n\t\tif (request_irq(lp->dma_irq, lance_dma_merr_int, IRQF_ONESHOT,\n\t\t\t\t\"lance error\", dev)) {\n\t\t\tfree_irq(dev->irq, dev);\n\t\t\tprintk(\"%s: Can't get DMA IRQ %d\\n\", dev->name,\n\t\t\t\tlp->dma_irq);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tspin_lock_irqsave(&ioasic_ssr_lock, flags);\n\n\t\tfast_mb();\n\t\t \n\t\tioasic_write(IO_REG_SSR,\n\t\t\t     ioasic_read(IO_REG_SSR) | IO_SSR_LANCE_DMA_EN);\n\n\t\tfast_mb();\n\t\tspin_unlock_irqrestore(&ioasic_ssr_lock, flags);\n\t}\n\n\tstatus = init_restart_lance(lp);\n\treturn status;\n}\n\nstatic int lance_close(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\n\tnetif_stop_queue(dev);\n\tdel_timer_sync(&lp->multicast_timer);\n\n\t \n\twritereg(&ll->rap, LE_CSR0);\n\twritereg(&ll->rdp, LE_C0_STOP);\n\n\tif (lp->dma_irq >= 0) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ioasic_ssr_lock, flags);\n\n\t\tfast_mb();\n\t\t \n\t\tioasic_write(IO_REG_SSR,\n\t\t\t     ioasic_read(IO_REG_SSR) & ~IO_SSR_LANCE_DMA_EN);\n\n\t\tfast_iob();\n\t\tspin_unlock_irqrestore(&ioasic_ssr_lock, flags);\n\n\t\tfree_irq(lp->dma_irq, dev);\n\t}\n\tfree_irq(dev->irq, dev);\n\treturn 0;\n}\n\nstatic inline int lance_reset(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tint status;\n\n\t \n\twritereg(&ll->rap, LE_CSR0);\n\twritereg(&ll->rdp, LE_C0_STOP);\n\n\tlance_init_ring(dev);\n\tload_csrs(lp);\n\tnetif_trans_update(dev);  \n\tstatus = init_restart_lance(lp);\n\treturn status;\n}\n\nstatic void lance_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\n\tprintk(KERN_ERR \"%s: transmit timed out, status %04x, reset\\n\",\n\t\tdev->name, ll->rdp);\n\tlance_reset(dev);\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile struct lance_regs *ll = lp->ll;\n\tvolatile u16 *ib = (volatile u16 *)dev->mem_start;\n\tunsigned long flags;\n\tint entry, len;\n\n\tlen = skb->len;\n\n\tif (len < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\treturn NETDEV_TX_OK;\n\t\tlen = ETH_ZLEN;\n\t}\n\n\tdev->stats.tx_bytes += len;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tentry = lp->tx_new;\n\t*lib_ptr(ib, btx_ring[entry].length, lp->type) = (-len);\n\t*lib_ptr(ib, btx_ring[entry].misc, lp->type) = 0;\n\n\tcp_to_buf(lp->type, lp->tx_buf_ptr_cpu[entry], skb->data, len);\n\n\t \n\t*lib_ptr(ib, btx_ring[entry].tmd1, lp->type) =\n\t\t((lp->tx_buf_ptr_lnc[entry] >> 16) & 0xff) |\n\t\t(LE_T1_POK | LE_T1_OWN);\n\tlp->tx_new = (entry + 1) & TX_RING_MOD_MASK;\n\n\tif (TX_BUFFS_AVAIL <= 0)\n\t\tnetif_stop_queue(dev);\n\n\t \n\twritereg(&ll->rdp, LE_C0_INEA | LE_C0_TDMD);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void lance_load_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile u16 *ib = (volatile u16 *)dev->mem_start;\n\tstruct netdev_hw_addr *ha;\n\tu32 crc;\n\n\t \n\tif (dev->flags & IFF_ALLMULTI) {\n\t\t*lib_ptr(ib, filter[0], lp->type) = 0xffff;\n\t\t*lib_ptr(ib, filter[1], lp->type) = 0xffff;\n\t\t*lib_ptr(ib, filter[2], lp->type) = 0xffff;\n\t\t*lib_ptr(ib, filter[3], lp->type) = 0xffff;\n\t\treturn;\n\t}\n\t \n\t*lib_ptr(ib, filter[0], lp->type) = 0;\n\t*lib_ptr(ib, filter[1], lp->type) = 0;\n\t*lib_ptr(ib, filter[2], lp->type) = 0;\n\t*lib_ptr(ib, filter[3], lp->type) = 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tcrc = ether_crc_le(ETH_ALEN, ha->addr);\n\t\tcrc = crc >> 26;\n\t\t*lib_ptr(ib, filter[crc >> 4], lp->type) |= 1 << (crc & 0xf);\n\t}\n}\n\nstatic void lance_set_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tvolatile u16 *ib = (volatile u16 *)dev->mem_start;\n\tvolatile struct lance_regs *ll = lp->ll;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tif (lp->tx_old != lp->tx_new) {\n\t\tmod_timer(&lp->multicast_timer, jiffies + 4 * HZ/100);\n\t\tnetif_wake_queue(dev);\n\t\treturn;\n\t}\n\n\tnetif_stop_queue(dev);\n\n\twritereg(&ll->rap, LE_CSR0);\n\twritereg(&ll->rdp, LE_C0_STOP);\n\n\tlance_init_ring(dev);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t*lib_ptr(ib, mode, lp->type) |= LE_MO_PROM;\n\t} else {\n\t\t*lib_ptr(ib, mode, lp->type) &= ~LE_MO_PROM;\n\t\tlance_load_multicast(dev);\n\t}\n\tload_csrs(lp);\n\tinit_restart_lance(lp);\n\tnetif_wake_queue(dev);\n}\n\nstatic void lance_set_multicast_retry(struct timer_list *t)\n{\n\tstruct lance_private *lp = from_timer(lp, t, multicast_timer);\n\tstruct net_device *dev = lp->dev;\n\n\tlance_set_multicast(dev);\n}\n\nstatic const struct net_device_ops lance_netdev_ops = {\n\t.ndo_open\t\t= lance_open,\n\t.ndo_stop\t\t= lance_close,\n\t.ndo_start_xmit\t\t= lance_start_xmit,\n\t.ndo_tx_timeout\t\t= lance_tx_timeout,\n\t.ndo_set_rx_mode\t= lance_set_multicast,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int dec_lance_probe(struct device *bdev, const int type)\n{\n\tstatic unsigned version_printed;\n\tstatic const char fmt[] = \"declance%d\";\n\tchar name[10];\n\tstruct net_device *dev;\n\tstruct lance_private *lp;\n\tvolatile struct lance_regs *ll;\n\tresource_size_t start = 0, len = 0;\n\tint i, ret;\n\tunsigned long esar_base;\n\tunsigned char *esar;\n\tu8 addr[ETH_ALEN];\n\tconst char *desc;\n\n\tif (dec_lance_debug && version_printed++ == 0)\n\t\tprintk(version);\n\n\tif (bdev)\n\t\tsnprintf(name, sizeof(name), \"%s\", dev_name(bdev));\n\telse {\n\t\ti = 0;\n\t\tdev = root_lance_dev;\n\t\twhile (dev) {\n\t\t\ti++;\n\t\t\tlp = netdev_priv(dev);\n\t\t\tdev = lp->next;\n\t\t}\n\t\tsnprintf(name, sizeof(name), fmt, i);\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct lance_private));\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t \n\tlp = netdev_priv(dev);\n\tspin_lock_init(&lp->lock);\n\n\tlp->type = type;\n\tswitch (type) {\n\tcase ASIC_LANCE:\n\t\tdev->base_addr = CKSEG1ADDR(dec_kn_slot_base + IOASIC_LANCE);\n\n\t\t \n\t\t \n\t\tdev->mem_start = CKSEG1ADDR(0x00020000);\n\t\tdev->mem_end = dev->mem_start + 0x00020000;\n\t\tdev->irq = dec_interrupt[DEC_IRQ_LANCE];\n\t\tesar_base = CKSEG1ADDR(dec_kn_slot_base + IOASIC_ESAR);\n\n\t\t \n\t\tmemset((void *)dev->mem_start, 0,\n\t\t       dev->mem_end - dev->mem_start);\n\n\t\t \n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tlp->rx_buf_ptr_cpu[i] =\n\t\t\t\t(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\n\t\t\t\t\t 2 * i * RX_BUFF_SIZE);\n\t\t\tlp->rx_buf_ptr_lnc[i] =\n\t\t\t\t(BUF_OFFSET_LNC + i * RX_BUFF_SIZE);\n\t\t}\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tlp->tx_buf_ptr_cpu[i] =\n\t\t\t\t(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\n\t\t\t\t\t 2 * RX_RING_SIZE * RX_BUFF_SIZE +\n\t\t\t\t\t 2 * i * TX_BUFF_SIZE);\n\t\t\tlp->tx_buf_ptr_lnc[i] =\n\t\t\t\t(BUF_OFFSET_LNC +\n\t\t\t\t RX_RING_SIZE * RX_BUFF_SIZE +\n\t\t\t\t i * TX_BUFF_SIZE);\n\t\t}\n\n\t\t \n\t\tlp->dma_irq = dec_interrupt[DEC_IRQ_LANCE_MERR];\n\t\tioasic_write(IO_REG_LANCE_DMA_P,\n\t\t\t     CPHYSADDR(dev->mem_start) << 3);\n\n\t\tbreak;\n#ifdef CONFIG_TC\n\tcase PMAD_LANCE:\n\t\tdev_set_drvdata(bdev, dev);\n\n\t\tstart = to_tc_dev(bdev)->resource.start;\n\t\tlen = to_tc_dev(bdev)->resource.end - start + 1;\n\t\tif (!request_mem_region(start, len, dev_name(bdev))) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"%s: Unable to reserve MMIO resource\\n\",\n\t\t\t       dev_name(bdev));\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_out_dev;\n\t\t}\n\n\t\tdev->mem_start = CKSEG1ADDR(start);\n\t\tdev->mem_end = dev->mem_start + 0x100000;\n\t\tdev->base_addr = dev->mem_start + 0x100000;\n\t\tdev->irq = to_tc_dev(bdev)->interrupt;\n\t\tesar_base = dev->mem_start + 0x1c0002;\n\t\tlp->dma_irq = -1;\n\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tlp->rx_buf_ptr_cpu[i] =\n\t\t\t\t(char *)(dev->mem_start + BUF_OFFSET_CPU +\n\t\t\t\t\t i * RX_BUFF_SIZE);\n\t\t\tlp->rx_buf_ptr_lnc[i] =\n\t\t\t\t(BUF_OFFSET_LNC + i * RX_BUFF_SIZE);\n\t\t}\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tlp->tx_buf_ptr_cpu[i] =\n\t\t\t\t(char *)(dev->mem_start + BUF_OFFSET_CPU +\n\t\t\t\t\t RX_RING_SIZE * RX_BUFF_SIZE +\n\t\t\t\t\t i * TX_BUFF_SIZE);\n\t\t\tlp->tx_buf_ptr_lnc[i] =\n\t\t\t\t(BUF_OFFSET_LNC +\n\t\t\t\t RX_RING_SIZE * RX_BUFF_SIZE +\n\t\t\t\t i * TX_BUFF_SIZE);\n\t\t}\n\n\t\tbreak;\n#endif\n\tcase PMAX_LANCE:\n\t\tdev->irq = dec_interrupt[DEC_IRQ_LANCE];\n\t\tdev->base_addr = CKSEG1ADDR(KN01_SLOT_BASE + KN01_LANCE);\n\t\tdev->mem_start = CKSEG1ADDR(KN01_SLOT_BASE + KN01_LANCE_MEM);\n\t\tdev->mem_end = dev->mem_start + KN01_SLOT_SIZE;\n\t\tesar_base = CKSEG1ADDR(KN01_SLOT_BASE + KN01_ESAR + 1);\n\t\tlp->dma_irq = -1;\n\n\t\t \n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tlp->rx_buf_ptr_cpu[i] =\n\t\t\t\t(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\n\t\t\t\t\t 2 * i * RX_BUFF_SIZE);\n\t\t\tlp->rx_buf_ptr_lnc[i] =\n\t\t\t\t(BUF_OFFSET_LNC + i * RX_BUFF_SIZE);\n\t\t}\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tlp->tx_buf_ptr_cpu[i] =\n\t\t\t\t(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\n\t\t\t\t\t 2 * RX_RING_SIZE * RX_BUFF_SIZE +\n\t\t\t\t\t 2 * i * TX_BUFF_SIZE);\n\t\t\tlp->tx_buf_ptr_lnc[i] =\n\t\t\t\t(BUF_OFFSET_LNC +\n\t\t\t\t RX_RING_SIZE * RX_BUFF_SIZE +\n\t\t\t\t i * TX_BUFF_SIZE);\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: declance_init called with unknown type\\n\",\n\t\t\tname);\n\t\tret = -ENODEV;\n\t\tgoto err_out_dev;\n\t}\n\n\tll = (struct lance_regs *) dev->base_addr;\n\tesar = (unsigned char *) esar_base;\n\n\t \n\t \n\tif (esar[0x60] != 0xff && esar[0x64] != 0x00 &&\n\t    esar[0x68] != 0x55 && esar[0x6c] != 0xaa) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s: Ethernet station address prom not found!\\n\",\n\t\t\tname);\n\t\tret = -ENODEV;\n\t\tgoto err_out_resource;\n\t}\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif (esar[i * 4] != esar[0x3c - i * 4] &&\n\t\t    esar[i * 4] != esar[0x40 + i * 4] &&\n\t\t    esar[0x3c - i * 4] != esar[0x40 + i * 4]) {\n\t\t\tprintk(KERN_ERR \"%s: Something is wrong with the \"\n\t\t\t\t\"ethernet station address prom!\\n\", name);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_out_resource;\n\t\t}\n\t}\n\n\t \n\tswitch (type) {\n\tcase ASIC_LANCE:\n\t\tdesc = \"IOASIC onboard LANCE\";\n\t\tbreak;\n\tcase PMAD_LANCE:\n\t\tdesc = \"PMAD-AA\";\n\t\tbreak;\n\tcase PMAX_LANCE:\n\t\tdesc = \"PMAX onboard LANCE\";\n\t\tbreak;\n\t}\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = esar[i * 4];\n\teth_hw_addr_set(dev, addr);\n\n\tprintk(\"%s: %s, addr = %pM, irq = %d\\n\",\n\t       name, desc, dev->dev_addr, dev->irq);\n\n\tdev->netdev_ops = &lance_netdev_ops;\n\tdev->watchdog_timeo = 5*HZ;\n\n\t \n\tlp->ll = ll;\n\n\t \n\tlp->busmaster_regval = 0;\n\n\tdev->dma = 0;\n\n\t \n\tlp->dev = dev;\n\ttimer_setup(&lp->multicast_timer, lance_set_multicast_retry, 0);\n\n\n\tret = register_netdev(dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s: Unable to register netdev, aborting.\\n\", name);\n\t\tgoto err_out_resource;\n\t}\n\n\tif (!bdev) {\n\t\tlp->next = root_lance_dev;\n\t\troot_lance_dev = dev;\n\t}\n\n\tprintk(\"%s: registered as %s.\\n\", name, dev->name);\n\treturn 0;\n\nerr_out_resource:\n\tif (bdev)\n\t\trelease_mem_region(start, len);\n\nerr_out_dev:\n\tfree_netdev(dev);\n\nerr_out:\n\treturn ret;\n}\n\n \nstatic int __init dec_lance_platform_probe(void)\n{\n\tint count = 0;\n\n\tif (dec_interrupt[DEC_IRQ_LANCE] >= 0) {\n\t\tif (dec_interrupt[DEC_IRQ_LANCE_MERR] >= 0) {\n\t\t\tif (dec_lance_probe(NULL, ASIC_LANCE) >= 0)\n\t\t\t\tcount++;\n\t\t} else if (!TURBOCHANNEL) {\n\t\t\tif (dec_lance_probe(NULL, PMAX_LANCE) >= 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn (count > 0) ? 0 : -ENODEV;\n}\n\nstatic void __exit dec_lance_platform_remove(void)\n{\n\twhile (root_lance_dev) {\n\t\tstruct net_device *dev = root_lance_dev;\n\t\tstruct lance_private *lp = netdev_priv(dev);\n\n\t\tunregister_netdev(dev);\n\t\troot_lance_dev = lp->next;\n\t\tfree_netdev(dev);\n\t}\n}\n\n#ifdef CONFIG_TC\nstatic int dec_lance_tc_probe(struct device *dev);\nstatic int dec_lance_tc_remove(struct device *dev);\n\nstatic const struct tc_device_id dec_lance_tc_table[] = {\n\t{ \"DEC     \", \"PMAD-AA \" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(tc, dec_lance_tc_table);\n\nstatic struct tc_driver dec_lance_tc_driver = {\n\t.id_table\t= dec_lance_tc_table,\n\t.driver\t\t= {\n\t\t.name\t= \"declance\",\n\t\t.bus\t= &tc_bus_type,\n\t\t.probe\t= dec_lance_tc_probe,\n\t\t.remove\t= dec_lance_tc_remove,\n\t},\n};\n\nstatic int dec_lance_tc_probe(struct device *dev)\n{\n        int status = dec_lance_probe(dev, PMAD_LANCE);\n        if (!status)\n                get_device(dev);\n        return status;\n}\n\nstatic void dec_lance_remove(struct device *bdev)\n{\n\tstruct net_device *dev = dev_get_drvdata(bdev);\n\tresource_size_t start, len;\n\n\tunregister_netdev(dev);\n\tstart = to_tc_dev(bdev)->resource.start;\n\tlen = to_tc_dev(bdev)->resource.end - start + 1;\n\trelease_mem_region(start, len);\n\tfree_netdev(dev);\n}\n\nstatic int dec_lance_tc_remove(struct device *dev)\n{\n        put_device(dev);\n        dec_lance_remove(dev);\n        return 0;\n}\n#endif\n\nstatic int __init dec_lance_init(void)\n{\n\tint status;\n\n\tstatus = tc_register_driver(&dec_lance_tc_driver);\n\tif (!status)\n\t\tdec_lance_platform_probe();\n\treturn status;\n}\n\nstatic void __exit dec_lance_exit(void)\n{\n\tdec_lance_platform_remove();\n\ttc_unregister_driver(&dec_lance_tc_driver);\n}\n\n\nmodule_init(dec_lance_init);\nmodule_exit(dec_lance_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}