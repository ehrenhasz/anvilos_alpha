{
  "module_name": "atarilance.c",
  "hash_id": "867f7a0e9e13b7c70a4fd1ed29c38d2fc227a3bfdfaac6790e295ebfde450dcd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/atarilance.c",
  "human_readable_source": " \n \n\nstatic const char version[] = \"atarilance.c: v1.3 04/04/96 \"\n\t\t\t      \"Roman.Hodek@informatik.uni-erlangen.de\\n\";\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n\n#include <asm/setup.h>\n#include <asm/irq.h>\n#include <asm/atarihw.h>\n#include <asm/atariints.h>\n#include <asm/io.h>\n\n \n\n#define\tLANCE_DEBUG\t1\n\n#ifdef LANCE_DEBUG\nstatic int lance_debug = LANCE_DEBUG;\n#else\nstatic int lance_debug = 1;\n#endif\nmodule_param(lance_debug, int, 0);\nMODULE_PARM_DESC(lance_debug, \"atarilance debug level (0-3)\");\nMODULE_LICENSE(\"GPL\");\n\n \n#undef LANCE_DEBUG_PROBE\n\n#define\tDPRINTK(n,a)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (lance_debug >= n)\t\t\t\t\t\\\n\t\t\tprintk a;\t\t\t\t\t\t\t\\\n\t} while( 0 )\n\n#ifdef LANCE_DEBUG_PROBE\n# define PROBE_PRINT(a)\tprintk a\n#else\n# define PROBE_PRINT(a)\n#endif\n\n \n\n#define TX_LOG_RING_SIZE\t\t\t3\n#define RX_LOG_RING_SIZE\t\t\t5\n\n \n\n#define TX_RING_SIZE\t\t\t(1 << TX_LOG_RING_SIZE)\n#define TX_RING_LEN_BITS\t\t(TX_LOG_RING_SIZE << 5)\n#define\tTX_RING_MOD_MASK\t\t(TX_RING_SIZE - 1)\n\n#define RX_RING_SIZE\t\t\t(1 << RX_LOG_RING_SIZE)\n#define RX_RING_LEN_BITS\t\t(RX_LOG_RING_SIZE << 5)\n#define\tRX_RING_MOD_MASK\t\t(RX_RING_SIZE - 1)\n\n#define TX_TIMEOUT\t(HZ/5)\n\n \nstruct lance_rx_head {\n\tunsigned short\t\t\tbase;\t\t \n\tvolatile unsigned char\tflag;\n\tunsigned char\t\t\tbase_hi;\t \n\tshort\t\t\t\t\tbuf_length;\t \n\tvolatile short\t\t\tmsg_length;\t \n};\n\nstruct lance_tx_head {\n\tunsigned short\t\t\tbase;\t\t \n\tvolatile unsigned char\tflag;\n\tunsigned char\t\t\tbase_hi;\t \n\tshort\t\t\t\t\tlength;\t\t \n\tvolatile short\t\t\tmisc;\n};\n\nstruct ringdesc {\n\tunsigned short\tadr_lo;\t\t \n\tunsigned char\tlen;\t\t \n\tunsigned char\tadr_hi;\t\t \n};\n\n \nstruct lance_init_block {\n\tunsigned short\tmode;\t\t \n\tunsigned char\thwaddr[6];\t \n\tunsigned\t\tfilter[2];\t \n\t \n\tstruct ringdesc\trx_ring;\n\tstruct ringdesc\ttx_ring;\n};\n\n \nstruct lance_memory {\n\tstruct lance_init_block\tinit;\n\tstruct lance_tx_head\ttx_head[TX_RING_SIZE];\n\tstruct lance_rx_head\trx_head[RX_RING_SIZE];\n\tchar\t\t\t\t\tpacket_area[];\t \n};\n\n \n#define\tRIEBL_RSVD_START\t0xee70\n#define\tRIEBL_RSVD_END\t\t0xeec0\n#define RIEBL_MAGIC\t\t\t0x09051990\n#define RIEBL_MAGIC_ADDR\t((unsigned long *)(((char *)MEM) + 0xee8a))\n#define RIEBL_HWADDR_ADDR\t((unsigned char *)(((char *)MEM) + 0xee8e))\n#define RIEBL_IVEC_ADDR\t\t((unsigned short *)(((char *)MEM) + 0xfffe))\n\n \n\nstatic unsigned char OldRieblDefHwaddr[6] = {\n\t0x00, 0x00, 0x36, 0x04, 0x00, 0x00\n};\n\n\n \n\nstruct lance_ioreg {\n \tvolatile unsigned short\tdata;\n \tvolatile unsigned short\taddr;\n\t\t\t\tunsigned char\t\t\t_dummy1[3];\n \tvolatile unsigned char\tivec;\n\t\t\t\tunsigned char\t\t\t_dummy2[5];\n \tvolatile unsigned char\teeprom;\n\t\t\t\tunsigned char\t\t\t_dummy3;\n \tvolatile unsigned char\tmem;\n};\n\n \n\nenum lance_type {\n\tOLD_RIEBL,\t\t \n\tNEW_RIEBL,\t\t \n\tPAM_CARD\t\t \n};\n\nstatic char *lance_names[] = {\n\t\"Riebl-Card (without battery)\",\n\t\"Riebl-Card (with battery)\",\n\t\"PAM intern card\"\n};\n\n \n\nstruct lance_private {\n\tenum lance_type\t\tcardtype;\n\tstruct lance_ioreg\t*iobase;\n\tstruct lance_memory\t*mem;\n\tint\t\t \tcur_rx, cur_tx;\t \n\tint\t\t\tdirty_tx;\t\t \n\t\t\t\t \n\tvoid\t\t\t*(*memcpy_f)( void *, const void *, size_t );\n \n\tlong\t\t\ttx_full;\n\tspinlock_t\t\tdevlock;\n};\n\n \n\n#define\tMEM\t\tlp->mem\n#define\tDREG\tIO->data\n#define\tAREG\tIO->addr\n#define\tREGA(a)\t(*( AREG = (a), &DREG ))\n\n \n#define PKT_BUF_SZ\t\t1544\n \n#define\tPKTBUF_ADDR(head)\t(((unsigned char *)(MEM)) + (head)->base)\n\n \n\nstatic struct lance_addr {\n\tunsigned long\tmemaddr;\n\tunsigned long\tioaddr;\n\tint\t\t\t\tslow_flag;\n} lance_addr_list[] = {\n\t{ 0xfe010000, 0xfe00fff0, 0 },\t \n\t{ 0xffc10000, 0xffc0fff0, 0 },\t \n\t{ 0xffe00000, 0xffff7000, 1 },\t \n\t{ 0xffd00000, 0xffff7000, 1 },\t \n\t{ 0xffcf0000, 0xffcffff0, 0 },\t \n\t{ 0xfecf0000, 0xfecffff0, 0 },\t \n};\n\n#define\tN_LANCE_ADDR\tARRAY_SIZE(lance_addr_list)\n\n\n \n\n \n#define TMD1_ENP\t\t0x01\t \n#define TMD1_STP\t\t0x02\t \n#define TMD1_DEF\t\t0x04\t \n#define TMD1_ONE\t\t0x08\t \n#define TMD1_MORE\t\t0x10\t \n#define TMD1_ERR\t\t0x40\t \n#define TMD1_OWN \t\t0x80\t \n\n#define TMD1_OWN_CHIP\tTMD1_OWN\n#define TMD1_OWN_HOST\t0\n\n \n#define TMD3_TDR\t\t0x03FF\t \n#define TMD3_RTRY\t\t0x0400\t \n#define TMD3_LCAR\t\t0x0800\t \n#define TMD3_LCOL\t\t0x1000\t \n#define TMD3_UFLO\t\t0x4000\t \n#define TMD3_BUFF\t\t0x8000\t \n\n \n#define RMD1_ENP\t\t0x01\t \n#define RMD1_STP\t\t0x02\t \n#define RMD1_BUFF\t\t0x04\t \n#define RMD1_CRC\t\t0x08\t \n#define RMD1_OFLO\t\t0x10\t \n#define RMD1_FRAM\t\t0x20\t \n#define RMD1_ERR\t\t0x40\t \n#define RMD1_OWN \t\t0x80\t \n\n#define RMD1_OWN_CHIP\tRMD1_OWN\n#define RMD1_OWN_HOST\t0\n\n \n#define CSR0\t0\t\t \n#define CSR1\t1\t\t \n#define CSR2\t2\t\t \n#define CSR3\t3\t\t \n#define CSR8\t8\t  \t \n#define CSR15\t15\t\t \n\n \n \n#define CSR0_INIT\t0x0001\t\t \n#define CSR0_STRT\t0x0002\t\t \n#define CSR0_STOP\t0x0004\t\t \n#define CSR0_TDMD\t0x0008\t\t \n#define CSR0_TXON\t0x0010\t\t \n#define CSR0_RXON\t0x0020\t\t \n#define CSR0_INEA\t0x0040\t\t \n#define CSR0_INTR\t0x0080\t\t \n#define CSR0_IDON\t0x0100\t\t \n#define CSR0_TINT\t0x0200\t\t \n#define CSR0_RINT\t0x0400\t\t \n#define CSR0_MERR\t0x0800\t\t \n#define CSR0_MISS\t0x1000\t\t \n#define CSR0_CERR\t0x2000\t\t \n#define CSR0_BABL\t0x4000\t\t \n#define CSR0_ERR\t0x8000\t\t \n\n \n#define CSR3_BCON\t0x0001\t\t \n#define CSR3_ACON\t0x0002\t\t \n#define CSR3_BSWP\t0x0004\t\t \n\n\n\n \n\nstatic unsigned long lance_probe1( struct net_device *dev, struct lance_addr\n                                   *init_rec );\nstatic int lance_open( struct net_device *dev );\nstatic void lance_init_ring( struct net_device *dev );\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev);\nstatic irqreturn_t lance_interrupt( int irq, void *dev_id );\nstatic int lance_rx( struct net_device *dev );\nstatic int lance_close( struct net_device *dev );\nstatic void set_multicast_list( struct net_device *dev );\nstatic int lance_set_mac_address( struct net_device *dev, void *addr );\nstatic void lance_tx_timeout (struct net_device *dev, unsigned int txqueue);\n\n \n\n\n\n\n\nstatic void *slow_memcpy( void *dst, const void *src, size_t len )\n\n{\tchar *cto = dst;\n\tconst char *cfrom = src;\n\n\twhile( len-- ) {\n\t\t*cto++ = *cfrom++;\n\t\tMFPDELAY();\n\t}\n\treturn dst;\n}\n\n\nstatic struct net_device * __init atarilance_probe(void)\n{\n\tint i;\n\tstatic int found;\n\tstruct net_device *dev;\n\tint err = -ENODEV;\n\n\tif (!MACH_IS_ATARI || found)\n\t\t \n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = alloc_etherdev(sizeof(struct lance_private));\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor( i = 0; i < N_LANCE_ADDR; ++i ) {\n\t\tif (lance_probe1( dev, &lance_addr_list[i] )) {\n\t\t\tfound = 1;\n\t\t\terr = register_netdev(dev);\n\t\t\tif (!err)\n\t\t\t\treturn dev;\n\t\t\tfree_irq(dev->irq, dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n\n\n \n\nstatic noinline int __init addr_accessible(volatile void *regp, int wordflag,\n\t\t\t\t\t   int writeflag)\n{\n\tint\t\tret;\n\tunsigned long\tflags;\n\tlong\t*vbr, save_berr;\n\n\tlocal_irq_save(flags);\n\n\t__asm__ __volatile__ ( \"movec\t%/vbr,%0\" : \"=r\" (vbr) : );\n\tsave_berr = vbr[2];\n\n\t__asm__ __volatile__\n\t(\t\"movel\t%/sp,%/d1\\n\\t\"\n\t\t\"movel\t#Lberr,%2@\\n\\t\"\n\t\t\"moveq\t#0,%0\\n\\t\"\n\t\t\"tstl   %3\\n\\t\"\n\t\t\"bne\t1f\\n\\t\"\n\t\t\"moveb\t%1@,%/d0\\n\\t\"\n\t\t\"nop\t\\n\\t\"\n\t\t\"bra\t2f\\n\"\n\"1:\t\t movew\t%1@,%/d0\\n\\t\"\n\t\t\"nop\t\\n\"\n\"2:\t\t tstl   %4\\n\\t\"\n\t\t\"beq\t2f\\n\\t\"\n\t\t\"tstl\t%3\\n\\t\"\n\t\t\"bne\t1f\\n\\t\"\n\t\t\"clrb\t%1@\\n\\t\"\n\t\t\"nop\t\\n\\t\"\n\t\t\"moveb\t%/d0,%1@\\n\\t\"\n\t\t\"nop\t\\n\\t\"\n\t\t\"bra\t2f\\n\"\n\"1:\t\t clrw\t%1@\\n\\t\"\n\t\t\"nop\t\\n\\t\"\n\t\t\"movew\t%/d0,%1@\\n\\t\"\n\t\t\"nop\t\\n\"\n\"2:\t\t moveq\t#1,%0\\n\"\n\"Lberr:\t movel\t%/d1,%/sp\"\n\t\t: \"=&d\" (ret)\n\t\t: \"a\" (regp), \"a\" (&vbr[2]), \"rm\" (wordflag), \"rm\" (writeflag)\n\t\t: \"d0\", \"d1\", \"memory\"\n\t);\n\n\tvbr[2] = save_berr;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\nstatic const struct net_device_ops lance_netdev_ops = {\n\t.ndo_open\t\t= lance_open,\n\t.ndo_stop\t\t= lance_close,\n\t.ndo_start_xmit\t\t= lance_start_xmit,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address\t= lance_set_mac_address,\n\t.ndo_tx_timeout\t\t= lance_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic unsigned long __init lance_probe1( struct net_device *dev,\n\t\t\t\t\t   struct lance_addr *init_rec )\n{\n\tvolatile unsigned short *memaddr =\n\t\t(volatile unsigned short *)init_rec->memaddr;\n\tvolatile unsigned short *ioaddr =\n\t\t(volatile unsigned short *)init_rec->ioaddr;\n\tstruct lance_private\t*lp;\n\tstruct lance_ioreg\t\t*IO;\n\tint \t\t\t\t\ti;\n\tstatic int \t\t\t\tdid_version;\n\tunsigned short\t\t\tsave1, save2;\n\tu8 addr[ETH_ALEN];\n\n\tPROBE_PRINT(( \"Probing for Lance card at mem %#lx io %#lx\\n\",\n\t\t\t\t  (long)memaddr, (long)ioaddr ));\n\n\t \n\tPROBE_PRINT(( \"lance_probe1: testing memory to be accessible\\n\" ));\n\tif (!addr_accessible( memaddr, 1, 1 )) goto probe_fail;\n\n\t \n\tPROBE_PRINT(( \"lance_probe1: testing memory to be writable (1)\\n\" ));\n\tsave1 = *memaddr;\n\t*memaddr = 0x0001;\n\tif (*memaddr != 0x0001) goto probe_fail;\n\tPROBE_PRINT(( \"lance_probe1: testing memory to be writable (2)\\n\" ));\n\t*memaddr = 0x0000;\n\tif (*memaddr != 0x0000) goto probe_fail;\n\t*memaddr = save1;\n\n\t \n\tPROBE_PRINT(( \"lance_probe1: testing ioport to be accessible\\n\" ));\n\tif (!addr_accessible( ioaddr, 1, 1 )) goto probe_fail;\n\n\t \n\tPROBE_PRINT(( \"lance_probe1: testing ioport to be writeable\\n\" ));\n\tsave2 = ioaddr[1];\n\tioaddr[1] = 0x0001;\n\tif (ioaddr[1] != 0x0001) goto probe_fail;\n\n\t \n\tPROBE_PRINT(( \"lance_probe1: testing CSR0 register function (1)\\n\" ));\n\tsave1 = ioaddr[0];\n\tioaddr[1] = CSR0;\n\tioaddr[0] = CSR0_INIT | CSR0_STOP;\n\tif (ioaddr[0] != CSR0_STOP) {\n\t\tioaddr[0] = save1;\n\t\tioaddr[1] = save2;\n\t\tgoto probe_fail;\n\t}\n\tPROBE_PRINT(( \"lance_probe1: testing CSR0 register function (2)\\n\" ));\n\tioaddr[0] = CSR0_STOP;\n\tif (ioaddr[0] != CSR0_STOP) {\n\t\tioaddr[0] = save1;\n\t\tioaddr[1] = save2;\n\t\tgoto probe_fail;\n\t}\n\n\t \n\tPROBE_PRINT(( \"lance_probe1: Lance card detected\\n\" ));\n\tgoto probe_ok;\n\n  probe_fail:\n\treturn 0;\n\n  probe_ok:\n\tlp = netdev_priv(dev);\n\tMEM = (struct lance_memory *)memaddr;\n\tIO = lp->iobase = (struct lance_ioreg *)ioaddr;\n\tdev->base_addr = (unsigned long)ioaddr;  \n\tlp->memcpy_f = init_rec->slow_flag ? slow_memcpy : memcpy;\n\n\tREGA( CSR0 ) = CSR0_STOP;\n\n\t \n\tif (addr_accessible( &(IO->eeprom), 0, 0 )) {\n\t\t \n\t\ti = IO->mem;\n\t\tlp->cardtype = PAM_CARD;\n\t}\n\telse if (*RIEBL_MAGIC_ADDR == RIEBL_MAGIC) {\n\t\tlp->cardtype = NEW_RIEBL;\n\t}\n\telse\n\t\tlp->cardtype = OLD_RIEBL;\n\n\tif (lp->cardtype == PAM_CARD ||\n\t\tmemaddr == (unsigned short *)0xffe00000) {\n\t\t \n\t\tif (request_irq(IRQ_AUTO_5, lance_interrupt, 0,\n\t\t\t\t\"PAM,Riebl-ST Ethernet\", dev)) {\n\t\t\tprintk( \"Lance: request for irq %d failed\\n\", IRQ_AUTO_5 );\n\t\t\treturn 0;\n\t\t}\n\t\tdev->irq = IRQ_AUTO_5;\n\t}\n\telse {\n\t\t \n\t\tunsigned int irq = atari_register_vme_int();\n\t\tif (!irq) {\n\t\t\tprintk( \"Lance: request for VME interrupt failed\\n\" );\n\t\t\treturn 0;\n\t\t}\n\t\tif (request_irq(irq, lance_interrupt, 0, \"Riebl-VME Ethernet\",\n\t\t\t\tdev)) {\n\t\t\tprintk( \"Lance: request for irq %u failed\\n\", irq );\n\t\t\treturn 0;\n\t\t}\n\t\tdev->irq = irq;\n\t}\n\n\tprintk(\"%s: %s at io %#lx, mem %#lx, irq %d%s, hwaddr \",\n\t\t   dev->name, lance_names[lp->cardtype],\n\t\t   (unsigned long)ioaddr,\n\t\t   (unsigned long)memaddr,\n\t\t   dev->irq,\n\t\t   init_rec->slow_flag ? \" (slow memcpy)\" : \"\" );\n\n\t \n\tswitch( lp->cardtype ) {\n\tcase OLD_RIEBL:\n\t\t \n\t\teth_hw_addr_set(dev, OldRieblDefHwaddr);\n\t\tbreak;\n\tcase NEW_RIEBL:\n\t\tlp->memcpy_f(addr, RIEBL_HWADDR_ADDR, ETH_ALEN);\n\t\teth_hw_addr_set(dev, addr);\n\t\tbreak;\n\tcase PAM_CARD:\n\t\ti = IO->eeprom;\n\t\tfor( i = 0; i < 6; ++i )\n\t\t\taddr[i] =\n\t\t\t\t((((unsigned short *)MEM)[i*2] & 0x0f) << 4) |\n\t\t\t\t((((unsigned short *)MEM)[i*2+1] & 0x0f));\n\t\teth_hw_addr_set(dev, addr);\n\t\ti = IO->mem;\n\t\tbreak;\n\t}\n\tprintk(\"%pM\\n\", dev->dev_addr);\n\tif (lp->cardtype == OLD_RIEBL) {\n\t\tprintk( \"%s: Warning: This is a default ethernet address!\\n\",\n\t\t\t\tdev->name );\n\t\tprintk( \"      Use \\\"ifconfig hw ether ...\\\" to set the address.\\n\" );\n\t}\n\n\tspin_lock_init(&lp->devlock);\n\n\tMEM->init.mode = 0x0000;\t\t \n\tfor( i = 0; i < 6; i++ )\n\t\tMEM->init.hwaddr[i] = dev->dev_addr[i^1];  \n\tMEM->init.filter[0] = 0x00000000;\n\tMEM->init.filter[1] = 0x00000000;\n\tMEM->init.rx_ring.adr_lo = offsetof( struct lance_memory, rx_head );\n\tMEM->init.rx_ring.adr_hi = 0;\n\tMEM->init.rx_ring.len    = RX_RING_LEN_BITS;\n\tMEM->init.tx_ring.adr_lo = offsetof( struct lance_memory, tx_head );\n\tMEM->init.tx_ring.adr_hi = 0;\n\tMEM->init.tx_ring.len    = TX_RING_LEN_BITS;\n\n\tif (lp->cardtype == PAM_CARD)\n\t\tIO->ivec = IRQ_SOURCE_TO_VECTOR(dev->irq);\n\telse\n\t\t*RIEBL_IVEC_ADDR = IRQ_SOURCE_TO_VECTOR(dev->irq);\n\n\tif (did_version++ == 0)\n\t\tDPRINTK( 1, ( version ));\n\n\tdev->netdev_ops = &lance_netdev_ops;\n\n\t \n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\treturn 1;\n}\n\n\nstatic int lance_open( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_ioreg\t *IO = lp->iobase;\n\tint i;\n\n\tDPRINTK( 2, ( \"%s: lance_open()\\n\", dev->name ));\n\n\tlance_init_ring(dev);\n\t \n\n\tREGA( CSR3 ) = CSR3_BSWP | (lp->cardtype == PAM_CARD ? CSR3_ACON : 0);\n\tREGA( CSR2 ) = 0;\n\tREGA( CSR1 ) = 0;\n\tREGA( CSR0 ) = CSR0_INIT;\n\t \n\n\ti = 1000000;\n\twhile (--i > 0)\n\t\tif (DREG & CSR0_IDON)\n\t\t\tbreak;\n\tif (i <= 0 || (DREG & CSR0_ERR)) {\n\t\tDPRINTK( 2, ( \"lance_open(): opening %s failed, i=%d, csr0=%04x\\n\",\n\t\t\t\t\t  dev->name, i, DREG ));\n\t\tDREG = CSR0_STOP;\n\t\treturn -EIO;\n\t}\n\tDREG = CSR0_IDON;\n\tDREG = CSR0_STRT;\n\tDREG = CSR0_INEA;\n\n\tnetif_start_queue (dev);\n\n\tDPRINTK( 2, ( \"%s: LANCE is open, csr0 %04x\\n\", dev->name, DREG ));\n\n\treturn 0;\n}\n\n\n \n\nstatic void lance_init_ring( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint i;\n\tunsigned offset;\n\n\tlp->tx_full = 0;\n\tlp->cur_rx = lp->cur_tx = 0;\n\tlp->dirty_tx = 0;\n\n\toffset = offsetof( struct lance_memory, packet_area );\n\n \n#define\tCHECK_OFFSET(o)\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\\n\t\tif (lp->cardtype == OLD_RIEBL || lp->cardtype == NEW_RIEBL) {\t\t \\\n\t\t\tif (((o) < RIEBL_RSVD_START) ? (o)+PKT_BUF_SZ > RIEBL_RSVD_START \\\n\t\t\t\t\t\t\t\t\t\t : (o) < RIEBL_RSVD_END)\t\t\t \\\n\t\t\t\t(o) = RIEBL_RSVD_END;\t\t\t\t\t\t\t\t\t\t \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\\n\t} while(0)\n\n\tfor( i = 0; i < TX_RING_SIZE; i++ ) {\n\t\tCHECK_OFFSET(offset);\n\t\tMEM->tx_head[i].base = offset;\n\t\tMEM->tx_head[i].flag = TMD1_OWN_HOST;\n\t\tMEM->tx_head[i].base_hi = 0;\n\t\tMEM->tx_head[i].length = 0;\n\t\tMEM->tx_head[i].misc = 0;\n\t\toffset += PKT_BUF_SZ;\n\t}\n\n\tfor( i = 0; i < RX_RING_SIZE; i++ ) {\n\t\tCHECK_OFFSET(offset);\n\t\tMEM->rx_head[i].base = offset;\n\t\tMEM->rx_head[i].flag = TMD1_OWN_CHIP;\n\t\tMEM->rx_head[i].base_hi = 0;\n\t\tMEM->rx_head[i].buf_length = -PKT_BUF_SZ;\n\t\tMEM->rx_head[i].msg_length = 0;\n\t\toffset += PKT_BUF_SZ;\n\t}\n}\n\n\n \n\n\nstatic void lance_tx_timeout (struct net_device *dev, unsigned int txqueue)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_ioreg\t *IO = lp->iobase;\n\n\tAREG = CSR0;\n\tDPRINTK( 1, ( \"%s: transmit timed out, status %04x, resetting.\\n\",\n\t\t\t  dev->name, DREG ));\n\tDREG = CSR0_STOP;\n\t \n\tREGA( CSR3 ) = CSR3_BSWP | (lp->cardtype == PAM_CARD ? CSR3_ACON : 0);\n\tdev->stats.tx_errors++;\n#ifndef final_version\n\t\t{\tint i;\n\t\t\tDPRINTK( 2, ( \"Ring data: dirty_tx %d cur_tx %d%s cur_rx %d\\n\",\n\t\t\t\t\t\t  lp->dirty_tx, lp->cur_tx,\n\t\t\t\t\t\t  lp->tx_full ? \" (full)\" : \"\",\n\t\t\t\t\t\t  lp->cur_rx ));\n\t\t\tfor( i = 0 ; i < RX_RING_SIZE; i++ )\n\t\t\t\tDPRINTK( 2, ( \"rx #%d: base=%04x blen=%04x mlen=%04x\\n\",\n\t\t\t\t\t\t\t  i, MEM->rx_head[i].base,\n\t\t\t\t\t\t\t  -MEM->rx_head[i].buf_length,\n\t\t\t\t\t\t\t  MEM->rx_head[i].msg_length ));\n\t\t\tfor( i = 0 ; i < TX_RING_SIZE; i++ )\n\t\t\t\tDPRINTK( 2, ( \"tx #%d: base=%04x len=%04x misc=%04x\\n\",\n\t\t\t\t\t\t\t  i, MEM->tx_head[i].base,\n\t\t\t\t\t\t\t  -MEM->tx_head[i].length,\n\t\t\t\t\t\t\t  MEM->tx_head[i].misc ));\n\t\t}\n#endif\n\t \n\t \n\tlance_init_ring(dev);\n\tREGA( CSR0 ) = CSR0_INEA | CSR0_INIT | CSR0_STRT;\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\n \n\nstatic netdev_tx_t\nlance_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_ioreg\t *IO = lp->iobase;\n\tint entry, len;\n\tstruct lance_tx_head *head;\n\tunsigned long flags;\n\n\tDPRINTK( 2, ( \"%s: lance_start_xmit() called, csr0 %4.4x.\\n\",\n\t\t\t\t  dev->name, DREG ));\n\n\n\t \n\tlen = skb->len;\n\tif (len < ETH_ZLEN)\n\t\tlen = ETH_ZLEN;\n\t \n\telse if (lp->cardtype == PAM_CARD && (len & 1))\n\t\t++len;\n\n\tif (len > skb->len) {\n\t\tif (skb_padto(skb, len))\n\t\t\treturn NETDEV_TX_OK;\n\t}\n\n\tnetif_stop_queue (dev);\n\n\t \n\tif (lance_debug >= 3) {\n\t\tprintk( \"%s: TX pkt type 0x%04x from %pM to %pM\"\n\t\t\t\t\" data at 0x%08x len %d\\n\",\n\t\t\t\tdev->name, ((u_short *)skb->data)[6],\n\t\t\t\t&skb->data[6], skb->data,\n\t\t\t\t(int)skb->data, (int)skb->len );\n\t}\n\n\t \n\tspin_lock_irqsave (&lp->devlock, flags);\n\n\t \n\tentry = lp->cur_tx & TX_RING_MOD_MASK;\n\thead  = &(MEM->tx_head[entry]);\n\n\t \n\n\n\thead->length = -len;\n\thead->misc = 0;\n\tlp->memcpy_f( PKTBUF_ADDR(head), (void *)skb->data, skb->len );\n\thead->flag = TMD1_OWN_CHIP | TMD1_ENP | TMD1_STP;\n\tdev->stats.tx_bytes += skb->len;\n\tdev_consume_skb_irq(skb);\n\tlp->cur_tx++;\n\twhile( lp->cur_tx >= TX_RING_SIZE && lp->dirty_tx >= TX_RING_SIZE ) {\n\t\tlp->cur_tx -= TX_RING_SIZE;\n\t\tlp->dirty_tx -= TX_RING_SIZE;\n\t}\n\n\t \n\tDREG = CSR0_INEA | CSR0_TDMD;\n\n\tif ((MEM->tx_head[(entry+1) & TX_RING_MOD_MASK].flag & TMD1_OWN) ==\n\t\tTMD1_OWN_HOST)\n\t\tnetif_start_queue (dev);\n\telse\n\t\tlp->tx_full = 1;\n\tspin_unlock_irqrestore (&lp->devlock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic irqreturn_t lance_interrupt( int irq, void *dev_id )\n{\n\tstruct net_device *dev = dev_id;\n\tstruct lance_private *lp;\n\tstruct lance_ioreg\t *IO;\n\tint csr0, boguscnt = 10;\n\tint handled = 0;\n\n\tif (!dev) {\n\t\tDPRINTK( 1, ( \"lance_interrupt(): interrupt for unknown device.\\n\" ));\n\t\treturn IRQ_NONE;\n\t}\n\n\tlp = netdev_priv(dev);\n\tIO = lp->iobase;\n\tspin_lock (&lp->devlock);\n\n\tAREG = CSR0;\n\n\twhile( ((csr0 = DREG) & (CSR0_ERR | CSR0_TINT | CSR0_RINT)) &&\n\t\t   --boguscnt >= 0) {\n\t\thandled = 1;\n\t\t \n\t\tDREG = csr0 & ~(CSR0_INIT | CSR0_STRT | CSR0_STOP |\n\t\t\t\t\t\t\t\t\tCSR0_TDMD | CSR0_INEA);\n\n\t\tDPRINTK( 2, ( \"%s: interrupt  csr0=%04x new csr=%04x.\\n\",\n\t\t\t\t\t  dev->name, csr0, DREG ));\n\n\t\tif (csr0 & CSR0_RINT)\t\t\t \n\t\t\tlance_rx( dev );\n\n\t\tif (csr0 & CSR0_TINT) {\t\t\t \n\t\t\tint dirty_tx = lp->dirty_tx;\n\n\t\t\twhile( dirty_tx < lp->cur_tx) {\n\t\t\t\tint entry = dirty_tx & TX_RING_MOD_MASK;\n\t\t\t\tint status = MEM->tx_head[entry].flag;\n\n\t\t\t\tif (status & TMD1_OWN_CHIP)\n\t\t\t\t\tbreak;\t\t\t \n\n\t\t\t\tMEM->tx_head[entry].flag = 0;\n\n\t\t\t\tif (status & TMD1_ERR) {\n\t\t\t\t\t \n\t\t\t\t\tint err_status = MEM->tx_head[entry].misc;\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\tif (err_status & TMD3_RTRY) dev->stats.tx_aborted_errors++;\n\t\t\t\t\tif (err_status & TMD3_LCAR) dev->stats.tx_carrier_errors++;\n\t\t\t\t\tif (err_status & TMD3_LCOL) dev->stats.tx_window_errors++;\n\t\t\t\t\tif (err_status & TMD3_UFLO) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t\t\t \n\t\t\t\t\t\tDPRINTK( 1, ( \"%s: Tx FIFO error! Status %04x\\n\",\n\t\t\t\t\t\t\t\t\t  dev->name, csr0 ));\n\t\t\t\t\t\t \n\t\t\t\t\t\tDREG = CSR0_STRT;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (status & (TMD1_MORE | TMD1_ONE | TMD1_DEF))\n\t\t\t\t\t\tdev->stats.collisions++;\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tdirty_tx++;\n\t\t\t}\n\n#ifndef final_version\n\t\t\tif (lp->cur_tx - dirty_tx >= TX_RING_SIZE) {\n\t\t\t\tDPRINTK( 0, ( \"out-of-sync dirty pointer,\"\n\t\t\t\t\t\t\t  \" %d vs. %d, full=%ld.\\n\",\n\t\t\t\t\t\t\t  dirty_tx, lp->cur_tx, lp->tx_full ));\n\t\t\t\tdirty_tx += TX_RING_SIZE;\n\t\t\t}\n#endif\n\n\t\t\tif (lp->tx_full && (netif_queue_stopped(dev)) &&\n\t\t\t\tdirty_tx > lp->cur_tx - TX_RING_SIZE + 2) {\n\t\t\t\t \n\t\t\t\tlp->tx_full = 0;\n\t\t\t\tnetif_wake_queue (dev);\n\t\t\t}\n\n\t\t\tlp->dirty_tx = dirty_tx;\n\t\t}\n\n\t\t \n\t\tif (csr0 & CSR0_BABL) dev->stats.tx_errors++;  \n\t\tif (csr0 & CSR0_MISS) dev->stats.rx_errors++;  \n\t\tif (csr0 & CSR0_MERR) {\n\t\t\tDPRINTK( 1, ( \"%s: Bus master arbitration failure (?!?), \"\n\t\t\t\t\t\t  \"status %04x.\\n\", dev->name, csr0 ));\n\t\t\t \n\t\t\tDREG = CSR0_STRT;\n\t\t}\n\t}\n\n     \n\tDREG = CSR0_BABL | CSR0_CERR | CSR0_MISS | CSR0_MERR |\n\t\t   CSR0_IDON | CSR0_INEA;\n\n\tDPRINTK( 2, ( \"%s: exiting interrupt, csr0=%#04x.\\n\",\n\t\t\t\t  dev->name, DREG ));\n\n\tspin_unlock (&lp->devlock);\n\treturn IRQ_RETVAL(handled);\n}\n\n\nstatic int lance_rx( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint entry = lp->cur_rx & RX_RING_MOD_MASK;\n\tint i;\n\n\tDPRINTK( 2, ( \"%s: rx int, flag=%04x\\n\", dev->name,\n\t\t\t\t  MEM->rx_head[entry].flag ));\n\n\t \n\twhile( (MEM->rx_head[entry].flag & RMD1_OWN) == RMD1_OWN_HOST ) {\n\t\tstruct lance_rx_head *head = &(MEM->rx_head[entry]);\n\t\tint status = head->flag;\n\n\t\tif (status != (RMD1_ENP|RMD1_STP)) {\t\t \n\t\t\t \n\t\t\tif (status & RMD1_ENP)\t \n\t\t\t\tdev->stats.rx_errors++;  \n\t\t\tif (status & RMD1_FRAM) dev->stats.rx_frame_errors++;\n\t\t\tif (status & RMD1_OFLO) dev->stats.rx_over_errors++;\n\t\t\tif (status & RMD1_CRC) dev->stats.rx_crc_errors++;\n\t\t\tif (status & RMD1_BUFF) dev->stats.rx_fifo_errors++;\n\t\t\thead->flag &= (RMD1_ENP|RMD1_STP);\n\t\t} else {\n\t\t\t \n\t\t\tshort pkt_len = head->msg_length & 0xfff;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (pkt_len < 60) {\n\t\t\t\tprintk( \"%s: Runt packet!\\n\", dev->name );\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tfor( i = 0; i < RX_RING_SIZE; i++ )\n\t\t\t\t\t\tif (MEM->rx_head[(entry+i) & RX_RING_MOD_MASK].flag &\n\t\t\t\t\t\t\tRMD1_OWN_CHIP)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (i > RX_RING_SIZE - 2) {\n\t\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\t\thead->flag |= RMD1_OWN_CHIP;\n\t\t\t\t\t\tlp->cur_rx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lance_debug >= 3) {\n\t\t\t\t\tu_char *data = PKTBUF_ADDR(head);\n\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: RX pkt type 0x%04x from %pM to %pM \"\n\t\t\t\t\t\t   \"data %8ph len %d\\n\",\n\t\t\t\t\t\t   dev->name, ((u_short *)data)[6],\n\t\t\t\t\t\t   &data[6], data, &data[15], pkt_len);\n\t\t\t\t}\n\n\t\t\t\tskb_reserve( skb, 2 );\t \n\t\t\t\tskb_put( skb, pkt_len );\t \n\t\t\t\tlp->memcpy_f( skb->data, PKTBUF_ADDR(head), pkt_len );\n\t\t\t\tskb->protocol = eth_type_trans( skb, dev );\n\t\t\t\tnetif_rx( skb );\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t}\n\t\t}\n\n\t\thead->flag |= RMD1_OWN_CHIP;\n\t\tentry = (++lp->cur_rx) & RX_RING_MOD_MASK;\n\t}\n\tlp->cur_rx &= RX_RING_MOD_MASK;\n\n\t \n\t \n\n\treturn 0;\n}\n\n\nstatic int lance_close( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_ioreg\t *IO = lp->iobase;\n\n\tnetif_stop_queue (dev);\n\n\tAREG = CSR0;\n\n\tDPRINTK( 2, ( \"%s: Shutting down ethercard, status was %2.2x.\\n\",\n\t\t\t\t  dev->name, DREG ));\n\n\t \n\tDREG = CSR0_STOP;\n\n\treturn 0;\n}\n\n\n \n\nstatic void set_multicast_list( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_ioreg\t *IO = lp->iobase;\n\n\tif (netif_running(dev))\n\t\t \n\t\treturn;\n\n\t \n\tDREG = CSR0_STOP;  \n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tDPRINTK( 2, ( \"%s: Promiscuous mode enabled.\\n\", dev->name ));\n\t\tREGA( CSR15 ) = 0x8000;  \n\t} else {\n\t\tshort multicast_table[4];\n\t\tint num_addrs = netdev_mc_count(dev);\n\t\tint i;\n\t\t \n\t\tmemset( multicast_table, (num_addrs == 0) ? 0 : -1,\n\t\t\t\tsizeof(multicast_table) );\n\t\tfor( i = 0; i < 4; i++ )\n\t\t\tREGA( CSR8+i ) = multicast_table[i];\n\t\tREGA( CSR15 ) = 0;  \n\t}\n\n\t \n\tREGA( CSR3 ) = CSR3_BSWP | (lp->cardtype == PAM_CARD ? CSR3_ACON : 0);\n\n\t \n\tREGA( CSR0 ) = CSR0_IDON | CSR0_INEA | CSR0_STRT;\n}\n\n\n \n\nstatic int lance_set_mac_address( struct net_device *dev, void *addr )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct sockaddr *saddr = addr;\n\tint i;\n\n\tif (lp->cardtype != OLD_RIEBL && lp->cardtype != NEW_RIEBL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (netif_running(dev)) {\n\t\t \n\t\tDPRINTK( 1, ( \"%s: hwaddr can be set only while card isn't open.\\n\",\n\t\t\t\t\t  dev->name ));\n\t\treturn -EIO;\n\t}\n\n\teth_hw_addr_set(dev, saddr->sa_data);\n\tfor( i = 0; i < 6; i++ )\n\t\tMEM->init.hwaddr[i] = dev->dev_addr[i^1];  \n\tlp->memcpy_f( RIEBL_HWADDR_ADDR, dev->dev_addr, 6 );\n\t \n\t*RIEBL_MAGIC_ADDR = RIEBL_MAGIC;\n\n\treturn 0;\n}\n\nstatic struct net_device *atarilance_dev;\n\nstatic int __init atarilance_module_init(void)\n{\n\tatarilance_dev = atarilance_probe();\n\treturn PTR_ERR_OR_ZERO(atarilance_dev);\n}\n\nstatic void __exit atarilance_module_exit(void)\n{\n\tunregister_netdev(atarilance_dev);\n\tfree_irq(atarilance_dev->irq, atarilance_dev);\n\tfree_netdev(atarilance_dev);\n}\nmodule_init(atarilance_module_init);\nmodule_exit(atarilance_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}