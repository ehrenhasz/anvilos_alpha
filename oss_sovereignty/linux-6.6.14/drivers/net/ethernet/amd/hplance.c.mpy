{
  "module_name": "hplance.c",
  "hash_id": "1ac87558eab1f0d752f652ef94d810947526e5a15fbf63ca2710299dedfd099e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/hplance.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/pgtable.h>\n \n#include <linux/socket.h>\n#include <linux/route.h>\n#include <linux/dio.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n\n#include <asm/io.h>\n\n#include \"hplance.h\"\n\n \n#define LANCE_LOG_TX_BUFFERS 1\n#define LANCE_LOG_RX_BUFFERS 3\n\n#include \"7990.h\"                                  \n\n \nstruct hplance_private {\n\tstruct lance_private lance;\n};\n\n \nstatic int hplance_init_one(struct dio_dev *d, const struct dio_device_id *ent);\nstatic void hplance_init(struct net_device *dev, struct dio_dev *d);\nstatic void hplance_remove_one(struct dio_dev *d);\nstatic void hplance_writerap(void *priv, unsigned short value);\nstatic void hplance_writerdp(void *priv, unsigned short value);\nstatic unsigned short hplance_readrdp(void *priv);\nstatic int hplance_open(struct net_device *dev);\nstatic int hplance_close(struct net_device *dev);\n\nstatic struct dio_device_id hplance_dio_tbl[] = {\n\t{ DIO_ID_LAN },\n\t{ 0 }\n};\n\nstatic struct dio_driver hplance_driver = {\n\t.name      = \"hplance\",\n\t.id_table  = hplance_dio_tbl,\n\t.probe     = hplance_init_one,\n\t.remove    = hplance_remove_one,\n};\n\nstatic const struct net_device_ops hplance_netdev_ops = {\n\t.ndo_open\t\t= hplance_open,\n\t.ndo_stop\t\t= hplance_close,\n\t.ndo_start_xmit\t\t= lance_start_xmit,\n\t.ndo_set_rx_mode\t= lance_set_multicast,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= lance_poll,\n#endif\n};\n\n \nstatic int hplance_init_one(struct dio_dev *d, const struct dio_device_id *ent)\n{\n\tstruct net_device *dev;\n\tint err = -ENOMEM;\n\n\tdev = alloc_etherdev(sizeof(struct hplance_private));\n\tif (!dev)\n\t\tgoto out;\n\n\terr = -EBUSY;\n\tif (!request_mem_region(dio_resource_start(d),\n\t\t\t\tdio_resource_len(d), d->name))\n\t\tgoto out_free_netdev;\n\n\thplance_init(dev, d);\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out_release_mem_region;\n\n\tdio_set_drvdata(d, dev);\n\n\tprintk(KERN_INFO \"%s: %s; select code %d, addr %pM, irq %d\\n\",\n\t       dev->name, d->name, d->scode, dev->dev_addr, d->ipl);\n\n\treturn 0;\n\n out_release_mem_region:\n\trelease_mem_region(dio_resource_start(d), dio_resource_len(d));\n out_free_netdev:\n\tfree_netdev(dev);\n out:\n\treturn err;\n}\n\nstatic void hplance_remove_one(struct dio_dev *d)\n{\n\tstruct net_device *dev = dio_get_drvdata(d);\n\n\tunregister_netdev(dev);\n\trelease_mem_region(dio_resource_start(d), dio_resource_len(d));\n\tfree_netdev(dev);\n}\n\n \nstatic void hplance_init(struct net_device *dev, struct dio_dev *d)\n{\n\tunsigned long va = (d->resource.start + DIO_VIRADDRBASE);\n\tstruct hplance_private *lp;\n\tu8 addr[ETH_ALEN];\n\tint i;\n\n\t \n\tout_8(va + DIO_IDOFF, 0xff);\n\tudelay(100);                               \n\n\t \n\tdev->base_addr = va;\n\tdev->netdev_ops = &hplance_netdev_ops;\n\tdev->dma = 0;\n\n\tfor (i = 0; i < 6; i++) {\n\t\t \n\t\taddr[i] = ((in_8(va + HPLANCE_NVRAMOFF + i*4 + 1) & 0xF) << 4)\n\t\t\t| (in_8(va + HPLANCE_NVRAMOFF + i*4 + 3) & 0xF);\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\tlp = netdev_priv(dev);\n\tlp->lance.name = d->name;\n\tlp->lance.base = va;\n\tlp->lance.init_block = (struct lance_init_block *)(va + HPLANCE_MEMOFF);  \n\tlp->lance.lance_init_block = NULL;               \n\tlp->lance.busmaster_regval = LE_C3_BSWP;         \n\tlp->lance.irq = d->ipl;\n\tlp->lance.writerap = hplance_writerap;\n\tlp->lance.writerdp = hplance_writerdp;\n\tlp->lance.readrdp = hplance_readrdp;\n\tlp->lance.lance_log_rx_bufs = LANCE_LOG_RX_BUFFERS;\n\tlp->lance.lance_log_tx_bufs = LANCE_LOG_TX_BUFFERS;\n\tlp->lance.rx_ring_mod_mask = RX_RING_MOD_MASK;\n\tlp->lance.tx_ring_mod_mask = TX_RING_MOD_MASK;\n}\n\n \nstatic void hplance_writerap(void *priv, unsigned short value)\n{\n\tstruct lance_private *lp = (struct lance_private *)priv;\n\n\tdo {\n\t\tout_be16(lp->base + HPLANCE_REGOFF + LANCE_RAP, value);\n\t} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\n}\n\nstatic void hplance_writerdp(void *priv, unsigned short value)\n{\n\tstruct lance_private *lp = (struct lance_private *)priv;\n\n\tdo {\n\t\tout_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP, value);\n\t} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\n}\n\nstatic unsigned short hplance_readrdp(void *priv)\n{\n\tstruct lance_private *lp = (struct lance_private *)priv;\n\t__u16 value;\n\n\tdo {\n\t\tvalue = in_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP);\n\t} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\n\treturn value;\n}\n\nstatic int hplance_open(struct net_device *dev)\n{\n\tint status;\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tstatus = lance_open(dev);                  \n\tif (status)\n\t\treturn status;\n\t \n\tout_8(lp->base + HPLANCE_STATUS, LE_IE);\n\n\treturn 0;\n}\n\nstatic int hplance_close(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tout_8(lp->base + HPLANCE_STATUS, 0);\t \n\tlance_close(dev);\n\treturn 0;\n}\n\nstatic int __init hplance_init_module(void)\n{\n\treturn dio_register_driver(&hplance_driver);\n}\n\nstatic void __exit hplance_cleanup_module(void)\n{\n\tdio_unregister_driver(&hplance_driver);\n}\n\nmodule_init(hplance_init_module);\nmodule_exit(hplance_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}