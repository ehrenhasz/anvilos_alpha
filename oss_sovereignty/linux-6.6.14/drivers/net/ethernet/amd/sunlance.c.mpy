{
  "module_name": "sunlance.c",
  "hash_id": "7fa69f1be6772ecedfbdb91887e45dc55e5202da2dc67f17e5e5f77332a1b1f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/sunlance.c",
  "human_readable_source": "\n \n\n#undef DEBUG_DRIVER\n\nstatic char lancestr[] = \"LANCE\";\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/socket.h>  \n#include <linux/route.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/gfp.h>\n#include <linux/pgtable.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/byteorder.h>\t \n#include <asm/idprom.h>\n#include <asm/prom.h>\n#include <asm/auxio.h>\t\t \n#include <asm/irq.h>\n\n#define DRV_NAME\t\"sunlance\"\n#define DRV_RELDATE\t\"8/24/03\"\n#define DRV_AUTHOR\t\"Miguel de Icaza (miguel@nuclecu.unam.mx)\"\n\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(\"Sun Lance ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#ifndef LANCE_LOG_TX_BUFFERS\n#define LANCE_LOG_TX_BUFFERS 4\n#define LANCE_LOG_RX_BUFFERS 4\n#endif\n\n#define LE_CSR0 0\n#define LE_CSR1 1\n#define LE_CSR2 2\n#define LE_CSR3 3\n\n#define LE_MO_PROM      0x8000   \n\n#define\tLE_C0_ERR\t0x8000\t \n#define\tLE_C0_BABL\t0x4000\t \n#define\tLE_C0_CERR\t0x2000\t \n#define\tLE_C0_MISS\t0x1000\t \n#define\tLE_C0_MERR\t0x0800\t \n#define\tLE_C0_RINT\t0x0400\t \n#define\tLE_C0_TINT\t0x0200\t \n#define\tLE_C0_IDON\t0x0100\t \n#define\tLE_C0_INTR\t0x0080\t \n#define\tLE_C0_INEA\t0x0040\t \n#define\tLE_C0_RXON\t0x0020\t \n#define\tLE_C0_TXON\t0x0010\t \n#define\tLE_C0_TDMD\t0x0008\t \n#define\tLE_C0_STOP\t0x0004\t \n#define\tLE_C0_STRT\t0x0002\t \n#define\tLE_C0_INIT\t0x0001\t \n\n#define\tLE_C3_BSWP\t0x4      \n#define\tLE_C3_ACON\t0x2\t \n#define\tLE_C3_BCON\t0x1\t \n\n \n#define LE_R1_OWN       0x80     \n#define LE_R1_ERR       0x40     \n#define LE_R1_FRA       0x20     \n#define LE_R1_OFL       0x10     \n#define LE_R1_CRC       0x08     \n#define LE_R1_BUF       0x04     \n#define LE_R1_SOP       0x02     \n#define LE_R1_EOP       0x01     \n#define LE_R1_POK       0x03     \n\n#define LE_T1_OWN       0x80     \n#define LE_T1_ERR       0x40     \n#define LE_T1_EMORE     0x10     \n#define LE_T1_EONE      0x08     \n#define LE_T1_EDEF      0x04     \n#define LE_T1_SOP       0x02     \n#define LE_T1_EOP       0x01     \n#define LE_T1_POK\t0x03\t \n\n#define LE_T3_BUF       0x8000   \n#define LE_T3_UFL       0x4000   \n#define LE_T3_LCOL      0x1000   \n#define LE_T3_CLOS      0x0800   \n#define LE_T3_RTY       0x0400   \n#define LE_T3_TDR       0x03ff   \n\n#define TX_RING_SIZE\t\t\t(1 << (LANCE_LOG_TX_BUFFERS))\n#define TX_RING_MOD_MASK\t\t(TX_RING_SIZE - 1)\n#define TX_RING_LEN_BITS\t\t((LANCE_LOG_TX_BUFFERS) << 29)\n#define TX_NEXT(__x)\t\t\t(((__x)+1) & TX_RING_MOD_MASK)\n\n#define RX_RING_SIZE\t\t\t(1 << (LANCE_LOG_RX_BUFFERS))\n#define RX_RING_MOD_MASK\t\t(RX_RING_SIZE - 1)\n#define RX_RING_LEN_BITS\t\t((LANCE_LOG_RX_BUFFERS) << 29)\n#define RX_NEXT(__x)\t\t\t(((__x)+1) & RX_RING_MOD_MASK)\n\n#define PKT_BUF_SZ\t\t1544\n#define RX_BUFF_SIZE            PKT_BUF_SZ\n#define TX_BUFF_SIZE            PKT_BUF_SZ\n\nstruct lance_rx_desc {\n\tu16\trmd0;\t\t \n\tu8\trmd1_bits;\t \n\tu8\trmd1_hadr;\t \n\ts16\tlength;\t\t \n\tu16\tmblength;\t \n};\n\nstruct lance_tx_desc {\n\tu16\ttmd0;\t\t \n\tu8 \ttmd1_bits;\t \n\tu8 \ttmd1_hadr;\t \n\ts16 \tlength;\t\t \n\tu16 \tmisc;\n};\n\n \n \nstruct lance_init_block {\n\tu16\tmode;\t\t \n\tu8\tphys_addr[6];\t \n\tu32\tfilter[2];\t \n\n\t \n\tu16\trx_ptr;\t\t \n\tu16\trx_len;\t\t \n\tu16\ttx_ptr;\t\t \n\tu16\ttx_len;\t\t \n\n\t \n\tstruct lance_rx_desc brx_ring[RX_RING_SIZE];\n\tstruct lance_tx_desc btx_ring[TX_RING_SIZE];\n\n\tu8\ttx_buf [TX_RING_SIZE][TX_BUFF_SIZE];\n\tu8\tpad[2];\t\t \n\tu8\trx_buf [RX_RING_SIZE][RX_BUFF_SIZE];\n};\n\n#define libdesc_offset(rt, elem) \\\n((__u32)(((unsigned long)(&(((struct lance_init_block *)0)->rt[elem])))))\n\n#define libbuff_offset(rt, elem) \\\n((__u32)(((unsigned long)(&(((struct lance_init_block *)0)->rt[elem][0])))))\n\nstruct lance_private {\n\tvoid __iomem\t*lregs;\t\t \n\tvoid __iomem\t*dregs;\t\t \n\tstruct lance_init_block __iomem *init_block_iomem;\n\tstruct lance_init_block *init_block_mem;\n\n\tspinlock_t\tlock;\n\n\tint\t\trx_new, tx_new;\n\tint\t\trx_old, tx_old;\n\n\tstruct platform_device *ledma;\t \n\tchar\t\ttpe;\t\t \n\tchar\t\tauto_select;\t \n\tchar\t\tburst_sizes;\t \n\tchar\t\tpio_buffer;\t \n\n\tunsigned short\tbusmaster_regval;\n\n\tvoid (*init_ring)(struct net_device *);\n\tvoid (*rx)(struct net_device *);\n\tvoid (*tx)(struct net_device *);\n\n\tchar\t       \t       *name;\n\tdma_addr_t\t\tinit_block_dvma;\n\tstruct net_device      *dev;\t\t   \n\tstruct platform_device       *op;\n\tstruct platform_device       *lebuffer;\n\tstruct timer_list       multicast_timer;\n};\n\n#define TX_BUFFS_AVAIL ((lp->tx_old<=lp->tx_new)?\\\n\t\t\tlp->tx_old+TX_RING_MOD_MASK-lp->tx_new:\\\n\t\t\tlp->tx_old - lp->tx_new-1)\n\n \n#define RDP\t\t0x00UL\t\t \n#define RAP\t\t0x02UL\t\t \n#define LANCE_REG_SIZE\t0x04UL\n\n#define STOP_LANCE(__lp) \\\ndo {\tvoid __iomem *__base = (__lp)->lregs; \\\n\tsbus_writew(LE_CSR0,\t__base + RAP); \\\n\tsbus_writew(LE_C0_STOP,\t__base + RDP); \\\n} while (0)\n\nint sparc_lance_debug = 2;\n\n \n \n \n \n\n#define LANCE_ADDR(x) ((long)(x) & ~0xff000000)\n\n \nstatic void load_csrs(struct lance_private *lp)\n{\n\tu32 leptr;\n\n\tif (lp->pio_buffer)\n\t\tleptr = 0;\n\telse\n\t\tleptr = LANCE_ADDR(lp->init_block_dvma);\n\n\tsbus_writew(LE_CSR1,\t\t  lp->lregs + RAP);\n\tsbus_writew(leptr & 0xffff,\t  lp->lregs + RDP);\n\tsbus_writew(LE_CSR2,\t\t  lp->lregs + RAP);\n\tsbus_writew(leptr >> 16,\t  lp->lregs + RDP);\n\tsbus_writew(LE_CSR3,\t\t  lp->lregs + RAP);\n\tsbus_writew(lp->busmaster_regval, lp->lregs + RDP);\n\n\t \n\tsbus_writew(LE_CSR0, lp->lregs + RAP);\n}\n\n \nstatic void lance_init_ring_dvma(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_init_block *ib = lp->init_block_mem;\n\tdma_addr_t aib = lp->init_block_dvma;\n\t__u32 leptr;\n\tint i;\n\n\t \n\tnetif_stop_queue(dev);\n\tlp->rx_new = lp->tx_new = 0;\n\tlp->rx_old = lp->tx_old = 0;\n\n\t \n\tib->phys_addr [0] = dev->dev_addr [1];\n\tib->phys_addr [1] = dev->dev_addr [0];\n\tib->phys_addr [2] = dev->dev_addr [3];\n\tib->phys_addr [3] = dev->dev_addr [2];\n\tib->phys_addr [4] = dev->dev_addr [5];\n\tib->phys_addr [5] = dev->dev_addr [4];\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tleptr = LANCE_ADDR(aib + libbuff_offset(tx_buf, i));\n\t\tib->btx_ring [i].tmd0      = leptr;\n\t\tib->btx_ring [i].tmd1_hadr = leptr >> 16;\n\t\tib->btx_ring [i].tmd1_bits = 0;\n\t\tib->btx_ring [i].length    = 0xf000;  \n\t\tib->btx_ring [i].misc      = 0;\n\t}\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tleptr = LANCE_ADDR(aib + libbuff_offset(rx_buf, i));\n\n\t\tib->brx_ring [i].rmd0      = leptr;\n\t\tib->brx_ring [i].rmd1_hadr = leptr >> 16;\n\t\tib->brx_ring [i].rmd1_bits = LE_R1_OWN;\n\t\tib->brx_ring [i].length    = -RX_BUFF_SIZE | 0xf000;\n\t\tib->brx_ring [i].mblength  = 0;\n\t}\n\n\t \n\n\t \n\tleptr = LANCE_ADDR(aib + libdesc_offset(brx_ring, 0));\n\tib->rx_len = (LANCE_LOG_RX_BUFFERS << 13) | (leptr >> 16);\n\tib->rx_ptr = leptr;\n\n\t \n\tleptr = LANCE_ADDR(aib + libdesc_offset(btx_ring, 0));\n\tib->tx_len = (LANCE_LOG_TX_BUFFERS << 13) | (leptr >> 16);\n\tib->tx_ptr = leptr;\n}\n\nstatic void lance_init_ring_pio(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\tu32 leptr;\n\tint i;\n\n\t \n\tnetif_stop_queue(dev);\n\tlp->rx_new = lp->tx_new = 0;\n\tlp->rx_old = lp->tx_old = 0;\n\n\t \n\tsbus_writeb(dev->dev_addr[1], &ib->phys_addr[0]);\n\tsbus_writeb(dev->dev_addr[0], &ib->phys_addr[1]);\n\tsbus_writeb(dev->dev_addr[3], &ib->phys_addr[2]);\n\tsbus_writeb(dev->dev_addr[2], &ib->phys_addr[3]);\n\tsbus_writeb(dev->dev_addr[5], &ib->phys_addr[4]);\n\tsbus_writeb(dev->dev_addr[4], &ib->phys_addr[5]);\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tleptr = libbuff_offset(tx_buf, i);\n\t\tsbus_writew(leptr,\t&ib->btx_ring [i].tmd0);\n\t\tsbus_writeb(leptr >> 16,&ib->btx_ring [i].tmd1_hadr);\n\t\tsbus_writeb(0,\t\t&ib->btx_ring [i].tmd1_bits);\n\n\t\t \n\t\tsbus_writew(0xf000,\t&ib->btx_ring [i].length);\n\t\tsbus_writew(0,\t\t&ib->btx_ring [i].misc);\n\t}\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tleptr = libbuff_offset(rx_buf, i);\n\n\t\tsbus_writew(leptr,\t&ib->brx_ring [i].rmd0);\n\t\tsbus_writeb(leptr >> 16,&ib->brx_ring [i].rmd1_hadr);\n\t\tsbus_writeb(LE_R1_OWN,\t&ib->brx_ring [i].rmd1_bits);\n\t\tsbus_writew(-RX_BUFF_SIZE|0xf000,\n\t\t\t    &ib->brx_ring [i].length);\n\t\tsbus_writew(0,\t\t&ib->brx_ring [i].mblength);\n\t}\n\n\t \n\n\t \n\tleptr = libdesc_offset(brx_ring, 0);\n\tsbus_writew((LANCE_LOG_RX_BUFFERS << 13) | (leptr >> 16),\n\t\t    &ib->rx_len);\n\tsbus_writew(leptr, &ib->rx_ptr);\n\n\t \n\tleptr = libdesc_offset(btx_ring, 0);\n\tsbus_writew((LANCE_LOG_TX_BUFFERS << 13) | (leptr >> 16),\n\t\t    &ib->tx_len);\n\tsbus_writew(leptr, &ib->tx_ptr);\n}\n\nstatic void init_restart_ledma(struct lance_private *lp)\n{\n\tu32 csr = sbus_readl(lp->dregs + DMA_CSR);\n\n\tif (!(csr & DMA_HNDL_ERROR)) {\n\t\t \n\t\twhile (sbus_readl(lp->dregs + DMA_CSR) & DMA_FIFO_ISDRAIN)\n\t\t\tbarrier();\n\t}\n\n\tcsr = sbus_readl(lp->dregs + DMA_CSR);\n\tcsr &= ~DMA_E_BURSTS;\n\tif (lp->burst_sizes & DMA_BURST32)\n\t\tcsr |= DMA_E_BURST32;\n\telse\n\t\tcsr |= DMA_E_BURST16;\n\n\tcsr |= (DMA_DSBL_RD_DRN | DMA_DSBL_WR_INV | DMA_FIFO_INV);\n\n\tif (lp->tpe)\n\t\tcsr |= DMA_EN_ENETAUI;\n\telse\n\t\tcsr &= ~DMA_EN_ENETAUI;\n\tudelay(20);\n\tsbus_writel(csr, lp->dregs + DMA_CSR);\n\tudelay(200);\n}\n\nstatic int init_restart_lance(struct lance_private *lp)\n{\n\tu16 regval = 0;\n\tint i;\n\n\tif (lp->dregs)\n\t\tinit_restart_ledma(lp);\n\n\tsbus_writew(LE_CSR0,\tlp->lregs + RAP);\n\tsbus_writew(LE_C0_INIT,\tlp->lregs + RDP);\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tregval = sbus_readw(lp->lregs + RDP);\n\n\t\tif (regval & (LE_C0_ERR | LE_C0_IDON))\n\t\t\tbreak;\n\t\tbarrier();\n\t}\n\tif (i == 100 || (regval & LE_C0_ERR)) {\n\t\tprintk(KERN_ERR \"LANCE unopened after %d ticks, csr0=%4.4x.\\n\",\n\t\t       i, regval);\n\t\tif (lp->dregs)\n\t\t\tprintk(\"dcsr=%8.8x\\n\", sbus_readl(lp->dregs + DMA_CSR));\n\t\treturn -1;\n\t}\n\n\t \n\tsbus_writew(LE_C0_IDON,\t\t\tlp->lregs + RDP);\n\tsbus_writew(LE_C0_INEA | LE_C0_STRT,\tlp->lregs + RDP);\n\n\tif (lp->dregs) {\n\t\tu32 csr = sbus_readl(lp->dregs + DMA_CSR);\n\n\t\tcsr |= DMA_INT_ENAB;\n\t\tsbus_writel(csr, lp->dregs + DMA_CSR);\n\t}\n\n\treturn 0;\n}\n\nstatic void lance_rx_dvma(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_init_block *ib = lp->init_block_mem;\n\tstruct lance_rx_desc *rd;\n\tu8 bits;\n\tint len, entry = lp->rx_new;\n\tstruct sk_buff *skb;\n\n\tfor (rd = &ib->brx_ring [entry];\n\t     !((bits = rd->rmd1_bits) & LE_R1_OWN);\n\t     rd = &ib->brx_ring [entry]) {\n\n\t\t \n\t\tif ((bits & LE_R1_POK) != LE_R1_POK) {\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tdev->stats.rx_errors++;\n\t\t} else if (bits & LE_R1_ERR) {\n\t\t\t \n\t\t\tif (bits & LE_R1_BUF) dev->stats.rx_fifo_errors++;\n\t\t\tif (bits & LE_R1_CRC) dev->stats.rx_crc_errors++;\n\t\t\tif (bits & LE_R1_OFL) dev->stats.rx_over_errors++;\n\t\t\tif (bits & LE_R1_FRA) dev->stats.rx_frame_errors++;\n\t\t\tif (bits & LE_R1_EOP) dev->stats.rx_errors++;\n\t\t} else {\n\t\t\tlen = (rd->mblength & 0xfff) - 4;\n\t\t\tskb = netdev_alloc_skb(dev, len + 2);\n\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\trd->mblength = 0;\n\t\t\t\trd->rmd1_bits = LE_R1_OWN;\n\t\t\t\tlp->rx_new = RX_NEXT(entry);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdev->stats.rx_bytes += len;\n\n\t\t\tskb_reserve(skb, 2);\t\t \n\t\t\tskb_put(skb, len);\t\t \n\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t (unsigned char *)&(ib->rx_buf [entry][0]),\n\t\t\t\t\t len);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\n\t\t \n\t\trd->mblength = 0;\n\t\trd->rmd1_bits = LE_R1_OWN;\n\t\tentry = RX_NEXT(entry);\n\t}\n\n\tlp->rx_new = entry;\n}\n\nstatic void lance_tx_dvma(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_init_block *ib = lp->init_block_mem;\n\tint i, j;\n\n\tspin_lock(&lp->lock);\n\n\tj = lp->tx_old;\n\tfor (i = j; i != lp->tx_new; i = j) {\n\t\tstruct lance_tx_desc *td = &ib->btx_ring [i];\n\t\tu8 bits = td->tmd1_bits;\n\n\t\t \n\t\tif (bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tif (bits & LE_T1_ERR) {\n\t\t\tu16 status = td->misc;\n\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (status & LE_T3_RTY)  dev->stats.tx_aborted_errors++;\n\t\t\tif (status & LE_T3_LCOL) dev->stats.tx_window_errors++;\n\n\t\t\tif (status & LE_T3_CLOS) {\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\tif (lp->auto_select) {\n\t\t\t\t\tlp->tpe = 1 - lp->tpe;\n\t\t\t\t\tprintk(KERN_NOTICE \"%s: Carrier Lost, trying %s\\n\",\n\t\t\t\t\t       dev->name, lp->tpe?\"TPE\":\"AUI\");\n\t\t\t\t\tSTOP_LANCE(lp);\n\t\t\t\t\tlp->init_ring(dev);\n\t\t\t\t\tload_csrs(lp);\n\t\t\t\t\tinit_restart_lance(lp);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (status & (LE_T3_BUF|LE_T3_UFL)) {\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\n\t\t\t\tprintk(KERN_ERR \"%s: Tx: ERR_BUF|ERR_UFL, restarting\\n\",\n\t\t\t\t       dev->name);\n\t\t\t\tSTOP_LANCE(lp);\n\t\t\t\tlp->init_ring(dev);\n\t\t\t\tload_csrs(lp);\n\t\t\t\tinit_restart_lance(lp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if ((bits & LE_T1_POK) == LE_T1_POK) {\n\t\t\t \n\t\t\ttd->tmd1_bits = bits & ~(LE_T1_POK);\n\n\t\t\t \n\t\t\tif (bits & LE_T1_EONE)\n\t\t\t\tdev->stats.collisions++;\n\n\t\t\t \n\t\t\tif (bits & LE_T1_EMORE)\n\t\t\t\tdev->stats.collisions += 2;\n\n\t\t\tdev->stats.tx_packets++;\n\t\t}\n\n\t\tj = TX_NEXT(j);\n\t}\n\tlp->tx_old = j;\nout:\n\tif (netif_queue_stopped(dev) &&\n\t    TX_BUFFS_AVAIL > 0)\n\t\tnetif_wake_queue(dev);\n\n\tspin_unlock(&lp->lock);\n}\n\nstatic void lance_piocopy_to_skb(struct sk_buff *skb, void __iomem *piobuf, int len)\n{\n\tu16 *p16 = (u16 *) skb->data;\n\tu32 *p32;\n\tu8 *p8;\n\tvoid __iomem *pbuf = piobuf;\n\n\t \n\t*p16++ = sbus_readw(pbuf);\n\tp32 = (u32 *) p16;\n\tpbuf += 2;\n\tlen -= 2;\n\n\twhile (len >= 4) {\n\t\t*p32++ = sbus_readl(pbuf);\n\t\tpbuf += 4;\n\t\tlen -= 4;\n\t}\n\tp8 = (u8 *) p32;\n\tif (len >= 2) {\n\t\tp16 = (u16 *) p32;\n\t\t*p16++ = sbus_readw(pbuf);\n\t\tpbuf += 2;\n\t\tlen -= 2;\n\t\tp8 = (u8 *) p16;\n\t}\n\tif (len >= 1)\n\t\t*p8 = sbus_readb(pbuf);\n}\n\nstatic void lance_rx_pio(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\tstruct lance_rx_desc __iomem *rd;\n\tunsigned char bits;\n\tint len, entry;\n\tstruct sk_buff *skb;\n\n\tentry = lp->rx_new;\n\tfor (rd = &ib->brx_ring [entry];\n\t     !((bits = sbus_readb(&rd->rmd1_bits)) & LE_R1_OWN);\n\t     rd = &ib->brx_ring [entry]) {\n\n\t\t \n\t\tif ((bits & LE_R1_POK) != LE_R1_POK) {\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tdev->stats.rx_errors++;\n\t\t} else if (bits & LE_R1_ERR) {\n\t\t\t \n\t\t\tif (bits & LE_R1_BUF) dev->stats.rx_fifo_errors++;\n\t\t\tif (bits & LE_R1_CRC) dev->stats.rx_crc_errors++;\n\t\t\tif (bits & LE_R1_OFL) dev->stats.rx_over_errors++;\n\t\t\tif (bits & LE_R1_FRA) dev->stats.rx_frame_errors++;\n\t\t\tif (bits & LE_R1_EOP) dev->stats.rx_errors++;\n\t\t} else {\n\t\t\tlen = (sbus_readw(&rd->mblength) & 0xfff) - 4;\n\t\t\tskb = netdev_alloc_skb(dev, len + 2);\n\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tsbus_writew(0, &rd->mblength);\n\t\t\t\tsbus_writeb(LE_R1_OWN, &rd->rmd1_bits);\n\t\t\t\tlp->rx_new = RX_NEXT(entry);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdev->stats.rx_bytes += len;\n\n\t\t\tskb_reserve (skb, 2);\t\t \n\t\t\tskb_put(skb, len);\t\t \n\t\t\tlance_piocopy_to_skb(skb, &(ib->rx_buf[entry][0]), len);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\n\t\t \n\t\tsbus_writew(0, &rd->mblength);\n\t\tsbus_writeb(LE_R1_OWN, &rd->rmd1_bits);\n\t\tentry = RX_NEXT(entry);\n\t}\n\n\tlp->rx_new = entry;\n}\n\nstatic void lance_tx_pio(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\tint i, j;\n\n\tspin_lock(&lp->lock);\n\n\tj = lp->tx_old;\n\tfor (i = j; i != lp->tx_new; i = j) {\n\t\tstruct lance_tx_desc __iomem *td = &ib->btx_ring [i];\n\t\tu8 bits = sbus_readb(&td->tmd1_bits);\n\n\t\t \n\t\tif (bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tif (bits & LE_T1_ERR) {\n\t\t\tu16 status = sbus_readw(&td->misc);\n\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (status & LE_T3_RTY)  dev->stats.tx_aborted_errors++;\n\t\t\tif (status & LE_T3_LCOL) dev->stats.tx_window_errors++;\n\n\t\t\tif (status & LE_T3_CLOS) {\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\tif (lp->auto_select) {\n\t\t\t\t\tlp->tpe = 1 - lp->tpe;\n\t\t\t\t\tprintk(KERN_NOTICE \"%s: Carrier Lost, trying %s\\n\",\n\t\t\t\t\t       dev->name, lp->tpe?\"TPE\":\"AUI\");\n\t\t\t\t\tSTOP_LANCE(lp);\n\t\t\t\t\tlp->init_ring(dev);\n\t\t\t\t\tload_csrs(lp);\n\t\t\t\t\tinit_restart_lance(lp);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (status & (LE_T3_BUF|LE_T3_UFL)) {\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\n\t\t\t\tprintk(KERN_ERR \"%s: Tx: ERR_BUF|ERR_UFL, restarting\\n\",\n\t\t\t\t       dev->name);\n\t\t\t\tSTOP_LANCE(lp);\n\t\t\t\tlp->init_ring(dev);\n\t\t\t\tload_csrs(lp);\n\t\t\t\tinit_restart_lance(lp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if ((bits & LE_T1_POK) == LE_T1_POK) {\n\t\t\t \n\t\t\tsbus_writeb(bits & ~(LE_T1_POK), &td->tmd1_bits);\n\n\t\t\t \n\t\t\tif (bits & LE_T1_EONE)\n\t\t\t\tdev->stats.collisions++;\n\n\t\t\t \n\t\t\tif (bits & LE_T1_EMORE)\n\t\t\t\tdev->stats.collisions += 2;\n\n\t\t\tdev->stats.tx_packets++;\n\t\t}\n\n\t\tj = TX_NEXT(j);\n\t}\n\tlp->tx_old = j;\n\n\tif (netif_queue_stopped(dev) &&\n\t    TX_BUFFS_AVAIL > 0)\n\t\tnetif_wake_queue(dev);\nout:\n\tspin_unlock(&lp->lock);\n}\n\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint csr0;\n\n\tsbus_writew(LE_CSR0, lp->lregs + RAP);\n\tcsr0 = sbus_readw(lp->lregs + RDP);\n\n\t \n\tsbus_writew(csr0 & (LE_C0_INTR | LE_C0_TINT | LE_C0_RINT),\n\t\t    lp->lregs + RDP);\n\n\tif ((csr0 & LE_C0_ERR) != 0) {\n\t\t \n\t\tsbus_writew((LE_C0_BABL | LE_C0_ERR | LE_C0_MISS |\n\t\t\t     LE_C0_CERR | LE_C0_MERR),\n\t\t\t    lp->lregs + RDP);\n\t}\n\n\tif (csr0 & LE_C0_RINT)\n\t\tlp->rx(dev);\n\n\tif (csr0 & LE_C0_TINT)\n\t\tlp->tx(dev);\n\n\tif (csr0 & LE_C0_BABL)\n\t\tdev->stats.tx_errors++;\n\n\tif (csr0 & LE_C0_MISS)\n\t\tdev->stats.rx_errors++;\n\n\tif (csr0 & LE_C0_MERR) {\n\t\tif (lp->dregs) {\n\t\t\tu32 addr = sbus_readl(lp->dregs + DMA_ADDR);\n\n\t\t\tprintk(KERN_ERR \"%s: Memory error, status %04x, addr %06x\\n\",\n\t\t\t       dev->name, csr0, addr & 0xffffff);\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"%s: Memory error, status %04x\\n\",\n\t\t\t       dev->name, csr0);\n\t\t}\n\n\t\tsbus_writew(LE_C0_STOP, lp->lregs + RDP);\n\n\t\tif (lp->dregs) {\n\t\t\tu32 dma_csr = sbus_readl(lp->dregs + DMA_CSR);\n\n\t\t\tdma_csr |= DMA_FIFO_INV;\n\t\t\tsbus_writel(dma_csr, lp->dregs + DMA_CSR);\n\t\t}\n\n\t\tlp->init_ring(dev);\n\t\tload_csrs(lp);\n\t\tinit_restart_lance(lp);\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tsbus_writew(LE_C0_INEA, lp->lregs + RDP);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void build_fake_packet(struct lance_private *lp)\n{\n\tstruct net_device *dev = lp->dev;\n\tint i, entry;\n\n\tentry = lp->tx_new & TX_RING_MOD_MASK;\n\tif (lp->pio_buffer) {\n\t\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\t\tu16 __iomem *packet = (u16 __iomem *) &(ib->tx_buf[entry][0]);\n\t\tstruct ethhdr __iomem *eth = (struct ethhdr __iomem *) packet;\n\t\tfor (i = 0; i < (ETH_ZLEN / sizeof(u16)); i++)\n\t\t\tsbus_writew(0, &packet[i]);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tsbus_writeb(dev->dev_addr[i], &eth->h_dest[i]);\n\t\t\tsbus_writeb(dev->dev_addr[i], &eth->h_source[i]);\n\t\t}\n\t\tsbus_writew((-ETH_ZLEN) | 0xf000, &ib->btx_ring[entry].length);\n\t\tsbus_writew(0, &ib->btx_ring[entry].misc);\n\t\tsbus_writeb(LE_T1_POK|LE_T1_OWN, &ib->btx_ring[entry].tmd1_bits);\n\t} else {\n\t\tstruct lance_init_block *ib = lp->init_block_mem;\n\t\tu16 *packet = (u16 *) &(ib->tx_buf[entry][0]);\n\t\tstruct ethhdr *eth = (struct ethhdr *) packet;\n\t\tmemset(packet, 0, ETH_ZLEN);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\teth->h_dest[i] = dev->dev_addr[i];\n\t\t\teth->h_source[i] = dev->dev_addr[i];\n\t\t}\n\t\tib->btx_ring[entry].length = (-ETH_ZLEN) | 0xf000;\n\t\tib->btx_ring[entry].misc = 0;\n\t\tib->btx_ring[entry].tmd1_bits = (LE_T1_POK|LE_T1_OWN);\n\t}\n\tlp->tx_new = TX_NEXT(entry);\n}\n\nstatic int lance_open(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint status = 0;\n\n\tSTOP_LANCE(lp);\n\n\tif (request_irq(dev->irq, lance_interrupt, IRQF_SHARED,\n\t\t\tlancestr, (void *) dev)) {\n\t\tprintk(KERN_ERR \"Lance: Can't get irq %d\\n\", dev->irq);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (lp->dregs) {\n\t\tu32 regval = lp->init_block_dvma & 0xff000000;\n\n\t\tsbus_writel(regval, lp->dregs + DMA_TEST);\n\t}\n\n\t \n\tif (lp->pio_buffer) {\n\t\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\t\tsbus_writew(0, &ib->mode);\n\t\tsbus_writel(0, &ib->filter[0]);\n\t\tsbus_writel(0, &ib->filter[1]);\n\t} else {\n\t\tstruct lance_init_block *ib = lp->init_block_mem;\n\t\tib->mode = 0;\n\t\tib->filter [0] = 0;\n\t\tib->filter [1] = 0;\n\t}\n\n\tlp->init_ring(dev);\n\tload_csrs(lp);\n\n\tnetif_start_queue(dev);\n\n\tstatus = init_restart_lance(lp);\n\tif (!status && lp->auto_select) {\n\t\tbuild_fake_packet(lp);\n\t\tsbus_writew(LE_C0_INEA | LE_C0_TDMD, lp->lregs + RDP);\n\t}\n\n\treturn status;\n}\n\nstatic int lance_close(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tdel_timer_sync(&lp->multicast_timer);\n\n\tSTOP_LANCE(lp);\n\n\tfree_irq(dev->irq, (void *) dev);\n\treturn 0;\n}\n\nstatic int lance_reset(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint status;\n\n\tSTOP_LANCE(lp);\n\n\t \n\tif (lp->dregs) {\n\t\tu32 csr, addr;\n\n\t\tprintk(KERN_ERR \"resetting ledma\\n\");\n\t\tcsr = sbus_readl(lp->dregs + DMA_CSR);\n\t\tsbus_writel(csr | DMA_RST_ENET, lp->dregs + DMA_CSR);\n\t\tudelay(200);\n\t\tsbus_writel(csr & ~DMA_RST_ENET, lp->dregs + DMA_CSR);\n\n\t\taddr = lp->init_block_dvma & 0xff000000;\n\t\tsbus_writel(addr, lp->dregs + DMA_TEST);\n\t}\n\tlp->init_ring(dev);\n\tload_csrs(lp);\n\tnetif_trans_update(dev);  \n\tstatus = init_restart_lance(lp);\n\treturn status;\n}\n\nstatic void lance_piocopy_from_skb(void __iomem *dest, unsigned char *src, int len)\n{\n\tvoid __iomem *piobuf = dest;\n\tu32 *p32;\n\tu16 *p16;\n\tu8 *p8;\n\n\tswitch ((unsigned long)src & 0x3) {\n\tcase 0:\n\t\tp32 = (u32 *) src;\n\t\twhile (len >= 4) {\n\t\t\tsbus_writel(*p32, piobuf);\n\t\t\tp32++;\n\t\t\tpiobuf += 4;\n\t\t\tlen -= 4;\n\t\t}\n\t\tsrc = (char *) p32;\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tp8 = (u8 *) src;\n\t\twhile (len >= 4) {\n\t\t\tu32 val;\n\n\t\t\tval  = p8[0] << 24;\n\t\t\tval |= p8[1] << 16;\n\t\t\tval |= p8[2] << 8;\n\t\t\tval |= p8[3];\n\t\t\tsbus_writel(val, piobuf);\n\t\t\tp8 += 4;\n\t\t\tpiobuf += 4;\n\t\t\tlen -= 4;\n\t\t}\n\t\tsrc = (char *) p8;\n\t\tbreak;\n\tcase 2:\n\t\tp16 = (u16 *) src;\n\t\twhile (len >= 4) {\n\t\t\tu32 val = p16[0]<<16 | p16[1];\n\t\t\tsbus_writel(val, piobuf);\n\t\t\tp16 += 2;\n\t\t\tpiobuf += 4;\n\t\t\tlen -= 4;\n\t\t}\n\t\tsrc = (char *) p16;\n\t\tbreak;\n\t}\n\tif (len >= 2) {\n\t\tu16 val = src[0] << 8 | src[1];\n\t\tsbus_writew(val, piobuf);\n\t\tsrc += 2;\n\t\tpiobuf += 2;\n\t\tlen -= 2;\n\t}\n\tif (len >= 1)\n\t\tsbus_writeb(src[0], piobuf);\n}\n\nstatic void lance_piozero(void __iomem *dest, int len)\n{\n\tvoid __iomem *piobuf = dest;\n\n\tif ((unsigned long)piobuf & 1) {\n\t\tsbus_writeb(0, piobuf);\n\t\tpiobuf += 1;\n\t\tlen -= 1;\n\t\tif (len == 0)\n\t\t\treturn;\n\t}\n\tif (len == 1) {\n\t\tsbus_writeb(0, piobuf);\n\t\treturn;\n\t}\n\tif ((unsigned long)piobuf & 2) {\n\t\tsbus_writew(0, piobuf);\n\t\tpiobuf += 2;\n\t\tlen -= 2;\n\t\tif (len == 0)\n\t\t\treturn;\n\t}\n\twhile (len >= 4) {\n\t\tsbus_writel(0, piobuf);\n\t\tpiobuf += 4;\n\t\tlen -= 4;\n\t}\n\tif (len >= 2) {\n\t\tsbus_writew(0, piobuf);\n\t\tpiobuf += 2;\n\t\tlen -= 2;\n\t}\n\tif (len >= 1)\n\t\tsbus_writeb(0, piobuf);\n}\n\nstatic void lance_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\n\tprintk(KERN_ERR \"%s: transmit timed out, status %04x, reset\\n\",\n\t       dev->name, sbus_readw(lp->lregs + RDP));\n\tlance_reset(dev);\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint entry, skblen, len;\n\n\tskblen = skb->len;\n\n\tlen = (skblen <= ETH_ZLEN) ? ETH_ZLEN : skblen;\n\n\tspin_lock_irq(&lp->lock);\n\n\tdev->stats.tx_bytes += len;\n\n\tentry = lp->tx_new & TX_RING_MOD_MASK;\n\tif (lp->pio_buffer) {\n\t\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\t\tsbus_writew((-len) | 0xf000, &ib->btx_ring[entry].length);\n\t\tsbus_writew(0, &ib->btx_ring[entry].misc);\n\t\tlance_piocopy_from_skb(&ib->tx_buf[entry][0], skb->data, skblen);\n\t\tif (len != skblen)\n\t\t\tlance_piozero(&ib->tx_buf[entry][skblen], len - skblen);\n\t\tsbus_writeb(LE_T1_POK | LE_T1_OWN, &ib->btx_ring[entry].tmd1_bits);\n\t} else {\n\t\tstruct lance_init_block *ib = lp->init_block_mem;\n\t\tib->btx_ring [entry].length = (-len) | 0xf000;\n\t\tib->btx_ring [entry].misc = 0;\n\t\tskb_copy_from_linear_data(skb, &ib->tx_buf [entry][0], skblen);\n\t\tif (len != skblen)\n\t\t\tmemset((char *) &ib->tx_buf [entry][skblen], 0, len - skblen);\n\t\tib->btx_ring [entry].tmd1_bits = (LE_T1_POK | LE_T1_OWN);\n\t}\n\n\tlp->tx_new = TX_NEXT(entry);\n\n\tif (TX_BUFFS_AVAIL <= 0)\n\t\tnetif_stop_queue(dev);\n\n\t \n\tsbus_writew(LE_C0_INEA | LE_C0_TDMD, lp->lregs + RDP);\n\n\t \n\tif (lp->dregs)\n\t\tsbus_readw(lp->lregs + RDP);\n\n\tspin_unlock_irq(&lp->lock);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void lance_load_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tu32 crc;\n\tu32 val;\n\n\t \n\tif (dev->flags & IFF_ALLMULTI)\n\t\tval = ~0;\n\telse\n\t\tval = 0;\n\n\tif (lp->pio_buffer) {\n\t\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\t\tsbus_writel(val, &ib->filter[0]);\n\t\tsbus_writel(val, &ib->filter[1]);\n\t} else {\n\t\tstruct lance_init_block *ib = lp->init_block_mem;\n\t\tib->filter [0] = val;\n\t\tib->filter [1] = val;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI)\n\t\treturn;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tcrc = ether_crc_le(6, ha->addr);\n\t\tcrc = crc >> 26;\n\t\tif (lp->pio_buffer) {\n\t\t\tstruct lance_init_block __iomem *ib = lp->init_block_iomem;\n\t\t\tu16 __iomem *mcast_table = (u16 __iomem *) &ib->filter;\n\t\t\tu16 tmp = sbus_readw(&mcast_table[crc>>4]);\n\t\t\ttmp |= 1 << (crc & 0xf);\n\t\t\tsbus_writew(tmp, &mcast_table[crc>>4]);\n\t\t} else {\n\t\t\tstruct lance_init_block *ib = lp->init_block_mem;\n\t\t\tu16 *mcast_table = (u16 *) &ib->filter;\n\t\t\tmcast_table [crc >> 4] |= 1 << (crc & 0xf);\n\t\t}\n\t}\n}\n\nstatic void lance_set_multicast(struct net_device *dev)\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tstruct lance_init_block *ib_mem = lp->init_block_mem;\n\tstruct lance_init_block __iomem *ib_iomem = lp->init_block_iomem;\n\tu16 mode;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tif (lp->tx_old != lp->tx_new) {\n\t\tmod_timer(&lp->multicast_timer, jiffies + 4);\n\t\tnetif_wake_queue(dev);\n\t\treturn;\n\t}\n\n\tnetif_stop_queue(dev);\n\n\tSTOP_LANCE(lp);\n\tlp->init_ring(dev);\n\n\tif (lp->pio_buffer)\n\t\tmode = sbus_readw(&ib_iomem->mode);\n\telse\n\t\tmode = ib_mem->mode;\n\tif (dev->flags & IFF_PROMISC) {\n\t\tmode |= LE_MO_PROM;\n\t\tif (lp->pio_buffer)\n\t\t\tsbus_writew(mode, &ib_iomem->mode);\n\t\telse\n\t\t\tib_mem->mode = mode;\n\t} else {\n\t\tmode &= ~LE_MO_PROM;\n\t\tif (lp->pio_buffer)\n\t\t\tsbus_writew(mode, &ib_iomem->mode);\n\t\telse\n\t\t\tib_mem->mode = mode;\n\t\tlance_load_multicast(dev);\n\t}\n\tload_csrs(lp);\n\tinit_restart_lance(lp);\n\tnetif_wake_queue(dev);\n}\n\nstatic void lance_set_multicast_retry(struct timer_list *t)\n{\n\tstruct lance_private *lp = from_timer(lp, t, multicast_timer);\n\tstruct net_device *dev = lp->dev;\n\n\tlance_set_multicast(dev);\n}\n\nstatic void lance_free_hwresources(struct lance_private *lp)\n{\n\tif (lp->lregs)\n\t\tof_iounmap(&lp->op->resource[0], lp->lregs, LANCE_REG_SIZE);\n\tif (lp->dregs) {\n\t\tstruct platform_device *ledma = lp->ledma;\n\n\t\tof_iounmap(&ledma->resource[0], lp->dregs,\n\t\t\t   resource_size(&ledma->resource[0]));\n\t}\n\tif (lp->init_block_iomem) {\n\t\tof_iounmap(&lp->lebuffer->resource[0], lp->init_block_iomem,\n\t\t\t   sizeof(struct lance_init_block));\n\t} else if (lp->init_block_mem) {\n\t\tdma_free_coherent(&lp->op->dev,\n\t\t\t\t  sizeof(struct lance_init_block),\n\t\t\t\t  lp->init_block_mem,\n\t\t\t\t  lp->init_block_dvma);\n\t}\n}\n\n \nstatic void sparc_lance_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"sunlance\", sizeof(info->driver));\n}\n\nstatic const struct ethtool_ops sparc_lance_ethtool_ops = {\n\t.get_drvinfo\t\t= sparc_lance_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops sparc_lance_ops = {\n\t.ndo_open\t\t= lance_open,\n\t.ndo_stop\t\t= lance_close,\n\t.ndo_start_xmit\t\t= lance_start_xmit,\n\t.ndo_set_rx_mode\t= lance_set_multicast,\n\t.ndo_tx_timeout\t\t= lance_tx_timeout,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int sparc_lance_probe_one(struct platform_device *op,\n\t\t\t\t struct platform_device *ledma,\n\t\t\t\t struct platform_device *lebuffer)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct lance_private *lp;\n\tstruct net_device *dev;\n\n\tdev = alloc_etherdev(sizeof(struct lance_private) + 8);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tlp = netdev_priv(dev);\n\n\tspin_lock_init(&lp->lock);\n\n\t \n\teth_hw_addr_set(dev, idprom->id_ethaddr);\n\n\t \n\tlp->lregs = of_ioremap(&op->resource[0], 0,\n\t\t\t       LANCE_REG_SIZE, lancestr);\n\tif (!lp->lregs) {\n\t\tprintk(KERN_ERR \"SunLance: Cannot map registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\tlp->ledma = ledma;\n\tif (lp->ledma) {\n\t\tlp->dregs = of_ioremap(&ledma->resource[0], 0,\n\t\t\t\t       resource_size(&ledma->resource[0]),\n\t\t\t\t       \"ledma\");\n\t\tif (!lp->dregs) {\n\t\t\tprintk(KERN_ERR \"SunLance: Cannot map \"\n\t\t\t       \"ledma registers.\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlp->op = op;\n\tlp->lebuffer = lebuffer;\n\tif (lebuffer) {\n\t\t \n\t\tif (lebuffer->resource[0].start & 7) {\n\t\t\tprintk(KERN_ERR \"SunLance: ERROR: Rx and Tx rings not on even boundary.\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tlp->init_block_iomem =\n\t\t\tof_ioremap(&lebuffer->resource[0], 0,\n\t\t\t\t   sizeof(struct lance_init_block), \"lebuffer\");\n\t\tif (!lp->init_block_iomem) {\n\t\t\tprintk(KERN_ERR \"SunLance: Cannot map PIO buffer.\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tlp->init_block_dvma = 0;\n\t\tlp->pio_buffer = 1;\n\t\tlp->init_ring = lance_init_ring_pio;\n\t\tlp->rx = lance_rx_pio;\n\t\tlp->tx = lance_tx_pio;\n\t} else {\n\t\tlp->init_block_mem =\n\t\t\tdma_alloc_coherent(&op->dev,\n\t\t\t\t\t   sizeof(struct lance_init_block),\n\t\t\t\t\t   &lp->init_block_dvma, GFP_ATOMIC);\n\t\tif (!lp->init_block_mem)\n\t\t\tgoto fail;\n\n\t\tlp->pio_buffer = 0;\n\t\tlp->init_ring = lance_init_ring_dvma;\n\t\tlp->rx = lance_rx_dvma;\n\t\tlp->tx = lance_tx_dvma;\n\t}\n\tlp->busmaster_regval = of_getintprop_default(dp,  \"busmaster-regval\",\n\t\t\t\t\t\t     (LE_C3_BSWP |\n\t\t\t\t\t\t      LE_C3_ACON |\n\t\t\t\t\t\t      LE_C3_BCON));\n\n\tlp->name = lancestr;\n\n\tlp->burst_sizes = 0;\n\tif (lp->ledma) {\n\t\tstruct device_node *ledma_dp = ledma->dev.of_node;\n\t\tstruct device_node *sbus_dp;\n\t\tunsigned int sbmask;\n\t\tconst char *prop;\n\t\tu32 csr;\n\n\t\t \n\t\tlp->burst_sizes = of_getintprop_default(ledma_dp,\n\t\t\t\t\t\t\t\"burst-sizes\", 0);\n\n\t\t \n\t\tsbus_dp = ledma_dp->parent;\n\t\tsbmask = of_getintprop_default(sbus_dp, \"burst-sizes\",\n\t\t\t\t\t       DMA_BURSTBITS);\n\t\tlp->burst_sizes &= sbmask;\n\n\t\t \n\t\tprop = of_get_property(ledma_dp, \"cable-selection\", NULL);\n\t\tif (!prop || prop[0] == '\\0') {\n\t\t\tstruct device_node *nd;\n\n\t\t\tprintk(KERN_INFO \"SunLance: using \"\n\t\t\t       \"auto-carrier-detection.\\n\");\n\n\t\t\tnd = of_find_node_by_path(\"/options\");\n\t\t\tif (!nd)\n\t\t\t\tgoto no_link_test;\n\n\t\t\tprop = of_get_property(nd, \"tpe-link-test?\", NULL);\n\t\t\tif (!prop)\n\t\t\t\tgoto node_put;\n\n\t\t\tif (strcmp(prop, \"true\")) {\n\t\t\t\tprintk(KERN_NOTICE \"SunLance: warning: overriding option \"\n\t\t\t\t       \"'tpe-link-test?'\\n\");\n\t\t\t\tprintk(KERN_NOTICE \"SunLance: warning: mail any problems \"\n\t\t\t\t       \"to ecd@skynet.be\\n\");\n\t\t\t\tauxio_set_lte(AUXIO_LTE_ON);\n\t\t\t}\nnode_put:\n\t\t\tof_node_put(nd);\nno_link_test:\n\t\t\tlp->auto_select = 1;\n\t\t\tlp->tpe = 0;\n\t\t} else if (!strcmp(prop, \"aui\")) {\n\t\t\tlp->auto_select = 0;\n\t\t\tlp->tpe = 0;\n\t\t} else {\n\t\t\tlp->auto_select = 0;\n\t\t\tlp->tpe = 1;\n\t\t}\n\n\t\t \n\t\tcsr = sbus_readl(lp->dregs + DMA_CSR);\n\t\tsbus_writel(csr | DMA_RST_ENET, lp->dregs + DMA_CSR);\n\t\tudelay(200);\n\t\tsbus_writel(csr & ~DMA_RST_ENET, lp->dregs + DMA_CSR);\n\t} else\n\t\tlp->dregs = NULL;\n\n\tlp->dev = dev;\n\tSET_NETDEV_DEV(dev, &op->dev);\n\tdev->watchdog_timeo = 5*HZ;\n\tdev->ethtool_ops = &sparc_lance_ethtool_ops;\n\tdev->netdev_ops = &sparc_lance_ops;\n\n\tdev->irq = op->archdata.irqs[0];\n\n\t \n\ttimer_setup(&lp->multicast_timer, lance_set_multicast_retry, 0);\n\n\tif (register_netdev(dev)) {\n\t\tprintk(KERN_ERR \"SunLance: Cannot register device.\\n\");\n\t\tgoto fail;\n\t}\n\n\tplatform_set_drvdata(op, lp);\n\n\tprintk(KERN_INFO \"%s: LANCE %pM\\n\",\n\t       dev->name, dev->dev_addr);\n\n\treturn 0;\n\nfail:\n\tlance_free_hwresources(lp);\n\tfree_netdev(dev);\n\treturn -ENODEV;\n}\n\nstatic int sunlance_sbus_probe(struct platform_device *op)\n{\n\tstruct platform_device *parent = to_platform_device(op->dev.parent);\n\tstruct device_node *parent_dp = parent->dev.of_node;\n\tint err;\n\n\tif (of_node_name_eq(parent_dp, \"ledma\")) {\n\t\terr = sparc_lance_probe_one(op, parent, NULL);\n\t} else if (of_node_name_eq(parent_dp, \"lebuffer\")) {\n\t\terr = sparc_lance_probe_one(op, NULL, parent);\n\t} else\n\t\terr = sparc_lance_probe_one(op, NULL, NULL);\n\n\treturn err;\n}\n\nstatic int sunlance_sbus_remove(struct platform_device *op)\n{\n\tstruct lance_private *lp = platform_get_drvdata(op);\n\tstruct net_device *net_dev = lp->dev;\n\n\tunregister_netdev(net_dev);\n\n\tlance_free_hwresources(lp);\n\n\tfree_netdev(net_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sunlance_sbus_match[] = {\n\t{\n\t\t.name = \"le\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, sunlance_sbus_match);\n\nstatic struct platform_driver sunlance_sbus_driver = {\n\t.driver = {\n\t\t.name = \"sunlance\",\n\t\t.of_match_table = sunlance_sbus_match,\n\t},\n\t.probe\t\t= sunlance_sbus_probe,\n\t.remove\t\t= sunlance_sbus_remove,\n};\n\nmodule_platform_driver(sunlance_sbus_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}