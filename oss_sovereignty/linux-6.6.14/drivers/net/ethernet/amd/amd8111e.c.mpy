{
  "module_name": "amd8111e.c",
  "hash_id": "f7fff6c1406f4a79392283e2324fb3834ca0e256387af1b93d7eadead2617932",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/amd8111e.c",
  "human_readable_source": "\n\n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/if_vlan.h>\n#include <linux/ctype.h>\n#include <linux/crc32.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n#define AMD8111E_VLAN_TAG_USED 1\n#else\n#define AMD8111E_VLAN_TAG_USED 0\n#endif\n\n#include \"amd8111e.h\"\n#define MODULE_NAME\t\"amd8111e\"\nMODULE_AUTHOR(\"Advanced Micro Devices, Inc.\");\nMODULE_DESCRIPTION(\"AMD8111 based 10/100 Ethernet Controller.\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_array(speed_duplex, int, NULL, 0);\nMODULE_PARM_DESC(speed_duplex, \"Set device speed and duplex modes, 0: Auto Negotiate, 1: 10Mbps Half Duplex, 2: 10Mbps Full Duplex, 3: 100Mbps Half Duplex, 4: 100Mbps Full Duplex\");\nmodule_param_array(coalesce, bool, NULL, 0);\nMODULE_PARM_DESC(coalesce, \"Enable or Disable interrupt coalescing, 1: Enable, 0: Disable\");\nmodule_param_array(dynamic_ipg, bool, NULL, 0);\nMODULE_PARM_DESC(dynamic_ipg, \"Enable or Disable dynamic IPG, 1: Enable, 0: Disable\");\n\n \nstatic int amd8111e_read_phy(struct amd8111e_priv *lp,\n\t\t\t     int phy_id, int reg, u32 *val)\n{\n\tvoid __iomem *mmio = lp->mmio;\n\tunsigned int reg_val;\n\tunsigned int repeat = REPEAT_CNT;\n\n\treg_val = readl(mmio + PHY_ACCESS);\n\twhile (reg_val & PHY_CMD_ACTIVE)\n\t\treg_val = readl(mmio + PHY_ACCESS);\n\n\twritel(PHY_RD_CMD | ((phy_id & 0x1f) << 21) |\n\t\t\t   ((reg & 0x1f) << 16), mmio + PHY_ACCESS);\n\tdo {\n\t\treg_val = readl(mmio + PHY_ACCESS);\n\t\tudelay(30);   \n\t} while (--repeat && (reg_val & PHY_CMD_ACTIVE));\n\tif (reg_val & PHY_RD_ERR)\n\t\tgoto err_phy_read;\n\n\t*val = reg_val & 0xffff;\n\treturn 0;\nerr_phy_read:\n\t*val = 0;\n\treturn -EINVAL;\n\n}\n\n \nstatic int amd8111e_write_phy(struct amd8111e_priv *lp,\n\t\t\t      int phy_id, int reg, u32 val)\n{\n\tunsigned int repeat = REPEAT_CNT;\n\tvoid __iomem *mmio = lp->mmio;\n\tunsigned int reg_val;\n\n\treg_val = readl(mmio + PHY_ACCESS);\n\twhile (reg_val & PHY_CMD_ACTIVE)\n\t\treg_val = readl(mmio + PHY_ACCESS);\n\n\twritel(PHY_WR_CMD | ((phy_id & 0x1f) << 21) |\n\t\t\t   ((reg & 0x1f) << 16)|val, mmio + PHY_ACCESS);\n\n\tdo {\n\t\treg_val = readl(mmio + PHY_ACCESS);\n\t\tudelay(30);   \n\t} while (--repeat && (reg_val & PHY_CMD_ACTIVE));\n\n\tif (reg_val & PHY_RD_ERR)\n\t\tgoto err_phy_write;\n\n\treturn 0;\n\nerr_phy_write:\n\treturn -EINVAL;\n\n}\n\n \nstatic int amd8111e_mdio_read(struct net_device *dev, int phy_id, int reg_num)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tunsigned int reg_val;\n\n\tamd8111e_read_phy(lp, phy_id, reg_num, &reg_val);\n\treturn reg_val;\n\n}\n\n \nstatic void amd8111e_mdio_write(struct net_device *dev,\n\t\t\t\tint phy_id, int reg_num, int val)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\n\tamd8111e_write_phy(lp, phy_id, reg_num, val);\n}\n\n \nstatic void amd8111e_set_ext_phy(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tu32 bmcr, advert, tmp;\n\n\t \n\tadvert = amd8111e_mdio_read(dev, lp->ext_phy_addr, MII_ADVERTISE);\n\ttmp = advert & ~(ADVERTISE_ALL | ADVERTISE_100BASE4);\n\tswitch (lp->ext_phy_option) {\n\tdefault:\n\tcase SPEED_AUTONEG:  \n\t\ttmp |= (ADVERTISE_10HALF | ADVERTISE_10FULL |\n\t\t\tADVERTISE_100HALF | ADVERTISE_100FULL);\n\t\tbreak;\n\tcase SPEED10_HALF:\n\t\ttmp |= ADVERTISE_10HALF;\n\t\tbreak;\n\tcase SPEED10_FULL:\n\t\ttmp |= ADVERTISE_10FULL;\n\t\tbreak;\n\tcase SPEED100_HALF:\n\t\ttmp |= ADVERTISE_100HALF;\n\t\tbreak;\n\tcase SPEED100_FULL:\n\t\ttmp |= ADVERTISE_100FULL;\n\t\tbreak;\n\t}\n\n\tif(advert != tmp)\n\t\tamd8111e_mdio_write(dev, lp->ext_phy_addr, MII_ADVERTISE, tmp);\n\t \n\tbmcr = amd8111e_mdio_read(dev, lp->ext_phy_addr, MII_BMCR);\n\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\tamd8111e_mdio_write(dev, lp->ext_phy_addr, MII_BMCR, bmcr);\n\n}\n\n \nstatic int amd8111e_free_skbs(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tstruct sk_buff *rx_skbuff;\n\tint i;\n\n\t \n\tfor (i = 0; i < NUM_TX_BUFFERS; i++) {\n\t\tif (lp->tx_skbuff[i]) {\n\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t lp->tx_dma_addr[i],\n\t\t\t\t\t lp->tx_skbuff[i]->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(lp->tx_skbuff[i]);\n\t\t\tlp->tx_skbuff[i] = NULL;\n\t\t\tlp->tx_dma_addr[i] = 0;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < NUM_RX_BUFFERS; i++) {\n\t\trx_skbuff = lp->rx_skbuff[i];\n\t\tif (rx_skbuff) {\n\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t lp->rx_dma_addr[i],\n\t\t\t\t\t lp->rx_buff_len - 2, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(lp->rx_skbuff[i]);\n\t\t\tlp->rx_skbuff[i] = NULL;\n\t\t\tlp->rx_dma_addr[i] = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void amd8111e_set_rx_buff_len(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tunsigned int mtu = dev->mtu;\n\n\tif (mtu > ETH_DATA_LEN) {\n\t\t \n\t\tlp->rx_buff_len = mtu + ETH_HLEN + 10;\n\t\tlp->options |= OPTION_JUMBO_ENABLE;\n\t} else {\n\t\tlp->rx_buff_len = PKT_BUFF_SZ;\n\t\tlp->options &= ~OPTION_JUMBO_ENABLE;\n\t}\n}\n\n \nstatic int amd8111e_init_ring(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint i;\n\n\tlp->rx_idx = lp->tx_idx = 0;\n\tlp->tx_complete_idx = 0;\n\tlp->tx_ring_idx = 0;\n\n\n\tif (lp->opened)\n\t\t \n\t\tamd8111e_free_skbs(dev);\n\n\telse {\n\t\t \n\t\tlp->tx_ring = dma_alloc_coherent(&lp->pci_dev->dev,\n\t\t\tsizeof(struct amd8111e_tx_dr) * NUM_TX_RING_DR,\n\t\t\t&lp->tx_ring_dma_addr, GFP_ATOMIC);\n\t\tif (!lp->tx_ring)\n\t\t\tgoto err_no_mem;\n\n\t\tlp->rx_ring = dma_alloc_coherent(&lp->pci_dev->dev,\n\t\t\tsizeof(struct amd8111e_rx_dr) * NUM_RX_RING_DR,\n\t\t\t&lp->rx_ring_dma_addr, GFP_ATOMIC);\n\t\tif (!lp->rx_ring)\n\t\t\tgoto err_free_tx_ring;\n\t}\n\n\t \n\tamd8111e_set_rx_buff_len(dev);\n\n\t \n\tfor (i = 0; i < NUM_RX_BUFFERS; i++) {\n\n\t\tlp->rx_skbuff[i] = netdev_alloc_skb(dev, lp->rx_buff_len);\n\t\tif (!lp->rx_skbuff[i]) {\n\t\t\t \n\t\t\tfor (--i; i >= 0; i--)\n\t\t\t\tdev_kfree_skb(lp->rx_skbuff[i]);\n\t\t\tgoto err_free_rx_ring;\n\t\t}\n\t\tskb_reserve(lp->rx_skbuff[i], 2);\n\t}\n         \n\tfor (i = 0; i < NUM_RX_BUFFERS; i++) {\n\t\tlp->rx_dma_addr[i] = dma_map_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t    lp->rx_skbuff[i]->data,\n\t\t\t\t\t\t    lp->rx_buff_len - 2,\n\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\n\t\tlp->rx_ring[i].buff_phy_addr = cpu_to_le32(lp->rx_dma_addr[i]);\n\t\tlp->rx_ring[i].buff_count = cpu_to_le16(lp->rx_buff_len-2);\n\t\twmb();\n\t\tlp->rx_ring[i].rx_flags = cpu_to_le16(OWN_BIT);\n\t}\n\n\t \n\tfor (i = 0; i < NUM_TX_RING_DR; i++) {\n\t\tlp->tx_ring[i].buff_phy_addr = 0;\n\t\tlp->tx_ring[i].tx_flags = 0;\n\t\tlp->tx_ring[i].buff_count = 0;\n\t}\n\n\treturn 0;\n\nerr_free_rx_ring:\n\n\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t  sizeof(struct amd8111e_rx_dr) * NUM_RX_RING_DR,\n\t\t\t  lp->rx_ring, lp->rx_ring_dma_addr);\n\nerr_free_tx_ring:\n\n\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t  sizeof(struct amd8111e_tx_dr) * NUM_TX_RING_DR,\n\t\t\t  lp->tx_ring, lp->tx_ring_dma_addr);\n\nerr_no_mem:\n\treturn -ENOMEM;\n}\n\n \nstatic int amd8111e_set_coalesce(struct net_device *dev, enum coal_mode cmod)\n{\n\tunsigned int timeout;\n\tunsigned int event_count;\n\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tvoid __iomem *mmio = lp->mmio;\n\tstruct amd8111e_coalesce_conf *coal_conf = &lp->coal_conf;\n\n\n\tswitch(cmod)\n\t{\n\t\tcase RX_INTR_COAL :\n\t\t\ttimeout = coal_conf->rx_timeout;\n\t\t\tevent_count = coal_conf->rx_event_count;\n\t\t\tif (timeout > MAX_TIMEOUT ||\n\t\t\t    event_count > MAX_EVENT_COUNT)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttimeout = timeout * DELAY_TIMER_CONV;\n\t\t\twritel(VAL0|STINTEN, mmio+INTEN0);\n\t\t\twritel((u32)DLY_INT_A_R0 | (event_count << 16) |\n\t\t\t\ttimeout, mmio + DLY_INT_A);\n\t\t\tbreak;\n\n\t\tcase TX_INTR_COAL:\n\t\t\ttimeout = coal_conf->tx_timeout;\n\t\t\tevent_count = coal_conf->tx_event_count;\n\t\t\tif (timeout > MAX_TIMEOUT ||\n\t\t\t    event_count > MAX_EVENT_COUNT)\n\t\t\t\treturn -EINVAL;\n\n\n\t\t\ttimeout = timeout * DELAY_TIMER_CONV;\n\t\t\twritel(VAL0 | STINTEN, mmio + INTEN0);\n\t\t\twritel((u32)DLY_INT_B_T0 | (event_count << 16) |\n\t\t\t\ttimeout, mmio + DLY_INT_B);\n\t\t\tbreak;\n\n\t\tcase DISABLE_COAL:\n\t\t\twritel(0, mmio + STVAL);\n\t\t\twritel(STINTEN, mmio + INTEN0);\n\t\t\twritel(0, mmio + DLY_INT_B);\n\t\t\twritel(0, mmio + DLY_INT_A);\n\t\t\tbreak;\n\t\t case ENABLE_COAL:\n\t\t        \n\t\t\twritel((u32)SOFT_TIMER_FREQ, mmio + STVAL);  \n\t\t\twritel(VAL0 | STINTEN, mmio + INTEN0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\n   }\n\treturn 0;\n\n}\n\n \nstatic int amd8111e_restart(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tvoid __iomem *mmio = lp->mmio;\n\tint i, reg_val;\n\n\t \n\twritel(RUN, mmio + CMD0);\n\n\tif (amd8111e_init_ring(dev))\n\t\treturn -ENOMEM;\n\n\t \n\twritel((u32)VAL1 | EN_PMGR, mmio + CMD3);\n\twritel((u32)XPHYANE | XPHYRST, mmio + CTRL2);\n\n\tamd8111e_set_ext_phy(dev);\n\n\t \n\treg_val = readl(mmio + CTRL1);\n\treg_val &= ~XMTSP_MASK;\n\twritel(reg_val | XMTSP_128 | CACHE_ALIGN, mmio + CTRL1);\n\n\t \n\twritel(APINT5EN | APINT4EN | APINT3EN | APINT2EN | APINT1EN |\n\t\tAPINT0EN | MIIPDTINTEN | MCCIINTEN | MCCINTEN | MREINTEN |\n\t\tSPNDINTEN | MPINTEN | SINTEN | STINTEN, mmio + INTEN0);\n\n\twritel(VAL3 | LCINTEN | VAL1 | TINTEN0 | VAL0 | RINTEN0, mmio + INTEN0);\n\n\t \n\twritel((u32)lp->tx_ring_dma_addr, mmio + XMT_RING_BASE_ADDR0);\n\twritel((u32)lp->rx_ring_dma_addr, mmio + RCV_RING_BASE_ADDR0);\n\n\twritew((u32)NUM_TX_RING_DR, mmio + XMT_RING_LEN0);\n\twritew((u16)NUM_RX_RING_DR, mmio + RCV_RING_LEN0);\n\n\t \n\twritew((u32)DEFAULT_IPG, mmio + IPG);\n\twritew((u32)(DEFAULT_IPG-IFS1_DELTA), mmio + IFS1);\n\n\tif (lp->options & OPTION_JUMBO_ENABLE) {\n\t\twritel((u32)VAL2|JUMBO, mmio + CMD3);\n\t\t \n\t\twritel(REX_UFLO, mmio + CMD2);\n\t\t \n\t\twritel(VAL0 | APAD_XMT | REX_RTRY, mmio + CMD2);\n\t} else {\n\t\twritel(VAL0 | APAD_XMT | REX_RTRY | REX_UFLO, mmio + CMD2);\n\t\twritel((u32)JUMBO, mmio + CMD3);\n\t}\n\n#if AMD8111E_VLAN_TAG_USED\n\twritel((u32)VAL2 | VSIZE | VL_TAG_DEL, mmio + CMD3);\n#endif\n\twritel(VAL0 | APAD_XMT | REX_RTRY, mmio + CMD2);\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\twriteb(dev->dev_addr[i], mmio + PADR + i);\n\n\t \n\tif (lp->options & OPTION_INTR_COAL_ENABLE) {\n\t\tnetdev_info(dev, \"Interrupt Coalescing Enabled.\\n\");\n\t\tamd8111e_set_coalesce(dev, ENABLE_COAL);\n\t}\n\n\t \n\twritel(VAL2 | RDMD0, mmio + CMD0);\n\twritel(VAL0 | INTREN | RUN, mmio + CMD0);\n\n\t \n\treadl(mmio+CMD0);\n\treturn 0;\n}\n\n \nstatic void amd8111e_init_hw_default(struct amd8111e_priv *lp)\n{\n\tunsigned int reg_val;\n\tunsigned int logic_filter[2] = {0,};\n\tvoid __iomem *mmio = lp->mmio;\n\n\n\t \n\twritel(RUN, mmio + CMD0);\n\n\t \n\twritel(0, mmio + RCV_RING_BASE_ADDR0);\n\n\t \n\twritel(0, mmio + XMT_RING_BASE_ADDR0);\n\twritel(0, mmio + XMT_RING_BASE_ADDR1);\n\twritel(0, mmio + XMT_RING_BASE_ADDR2);\n\twritel(0, mmio + XMT_RING_BASE_ADDR3);\n\n\t \n\twritel(CMD0_CLEAR, mmio + CMD0);\n\n\t \n\twritel(CMD2_CLEAR, mmio + CMD2);\n\n\t \n\twritel(CMD7_CLEAR, mmio + CMD7);\n\n\t \n\twritel(0x0, mmio + DLY_INT_A);\n\twritel(0x0, mmio + DLY_INT_B);\n\n\t \n\twritel(0x0, mmio + FLOW_CONTROL);\n\n\t \n\treg_val = readl(mmio + INT0);\n\twritel(reg_val, mmio + INT0);\n\n\t \n\twritel(0x0, mmio + STVAL);\n\n\t \n\twritel(INTEN0_CLEAR, mmio + INTEN0);\n\n\t \n\twritel(0x0, mmio + LADRF);\n\n\t \n\twritel(0x80010, mmio + SRAM_SIZE);\n\n\t \n\twritel(0x0, mmio + RCV_RING_LEN0);\n\n\t \n\twritel(0x0, mmio +  XMT_RING_LEN0);\n\twritel(0x0, mmio +  XMT_RING_LEN1);\n\twritel(0x0, mmio +  XMT_RING_LEN2);\n\twritel(0x0, mmio +  XMT_RING_LEN3);\n\n\t \n\twritel(0x0, mmio + XMT_RING_LIMIT);\n\n\t \n\twritew(MIB_CLEAR, mmio + MIB_ADDR);\n\n\t \n\tamd8111e_writeq(*(u64 *)logic_filter, mmio + LADRF);\n\n\t \n\treg_val = readl(mmio + SRAM_SIZE);\n\n\tif (lp->options & OPTION_JUMBO_ENABLE)\n\t\twritel(VAL2 | JUMBO, mmio + CMD3);\n#if AMD8111E_VLAN_TAG_USED\n\twritel(VAL2 | VSIZE | VL_TAG_DEL, mmio + CMD3);\n#endif\n\t \n\twritel(CTRL1_DEFAULT, mmio + CTRL1);\n\n\t \n\treadl(mmio + CMD2);\n\n}\n\n \nstatic void amd8111e_disable_interrupt(struct amd8111e_priv *lp)\n{\n\tu32 intr0;\n\n\t \n\twritel(INTREN, lp->mmio + CMD0);\n\n\t \n\tintr0 = readl(lp->mmio + INT0);\n\twritel(intr0, lp->mmio + INT0);\n\n\t \n\treadl(lp->mmio + INT0);\n\n}\n\n \nstatic void amd8111e_stop_chip(struct amd8111e_priv *lp)\n{\n\twritel(RUN, lp->mmio + CMD0);\n\n\t \n\treadl(lp->mmio + CMD0);\n}\n\n \nstatic void amd8111e_free_ring(struct amd8111e_priv *lp)\n{\n\t \n\tif (lp->rx_ring) {\n\t\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t\t  sizeof(struct amd8111e_rx_dr) * NUM_RX_RING_DR,\n\t\t\t\t  lp->rx_ring, lp->rx_ring_dma_addr);\n\t\tlp->rx_ring = NULL;\n\t}\n\n\tif (lp->tx_ring) {\n\t\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t\t  sizeof(struct amd8111e_tx_dr) * NUM_TX_RING_DR,\n\t\t\t\t  lp->tx_ring, lp->tx_ring_dma_addr);\n\n\t\tlp->tx_ring = NULL;\n\t}\n\n}\n\n \nstatic int amd8111e_tx(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint tx_index;\n\tint status;\n\t \n\twhile (lp->tx_complete_idx != lp->tx_idx) {\n\t\ttx_index =  lp->tx_complete_idx & TX_RING_DR_MOD_MASK;\n\t\tstatus = le16_to_cpu(lp->tx_ring[tx_index].tx_flags);\n\n\t\tif (status & OWN_BIT)\n\t\t\tbreak;\t \n\n\t\tlp->tx_ring[tx_index].buff_phy_addr = 0;\n\n\t\t \n\t\tif (lp->tx_skbuff[tx_index]) {\n\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t lp->tx_dma_addr[tx_index],\n\t\t\t\t\t lp->tx_skbuff[tx_index]->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_consume_skb_irq(lp->tx_skbuff[tx_index]);\n\t\t\tlp->tx_skbuff[tx_index] = NULL;\n\t\t\tlp->tx_dma_addr[tx_index] = 0;\n\t\t}\n\t\tlp->tx_complete_idx++;\n\t\t \n\t\tlp->coal_conf.tx_packets++;\n\t\tlp->coal_conf.tx_bytes +=\n\t\t\tle16_to_cpu(lp->tx_ring[tx_index].buff_count);\n\n\t\tif (netif_queue_stopped(dev) &&\n\t\t\tlp->tx_complete_idx > lp->tx_idx - NUM_TX_BUFFERS + 2) {\n\t\t\t \n\t\t\t \n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int amd8111e_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct amd8111e_priv *lp = container_of(napi, struct amd8111e_priv, napi);\n\tstruct net_device *dev = lp->amd8111e_net_dev;\n\tint rx_index = lp->rx_idx & RX_RING_DR_MOD_MASK;\n\tvoid __iomem *mmio = lp->mmio;\n\tstruct sk_buff *skb, *new_skb;\n\tint min_pkt_len, status;\n\tint num_rx_pkt = 0;\n\tshort pkt_len;\n#if AMD8111E_VLAN_TAG_USED\n\tshort vtag;\n#endif\n\n\twhile (num_rx_pkt < budget) {\n\t\tstatus = le16_to_cpu(lp->rx_ring[rx_index].rx_flags);\n\t\tif (status & OWN_BIT)\n\t\t\tbreak;\n\n\t\t \n\t\tif (status & ERR_BIT) {\n\t\t\t \n\t\t\tlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\n\t\t\tgoto err_next_pkt;\n\t\t}\n\t\t \n\t\tif (!((status & STP_BIT) && (status & ENP_BIT))) {\n\t\t\t \n\t\t\tlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\n\t\t\tgoto err_next_pkt;\n\t\t}\n\t\tpkt_len = le16_to_cpu(lp->rx_ring[rx_index].msg_count) - 4;\n\n#if AMD8111E_VLAN_TAG_USED\n\t\tvtag = status & TT_MASK;\n\t\t \n\t\tif (vtag != 0)\n\t\t\tmin_pkt_len = MIN_PKT_LEN - 4;\n\t\t\telse\n#endif\n\t\t\tmin_pkt_len = MIN_PKT_LEN;\n\n\t\tif (pkt_len < min_pkt_len) {\n\t\t\tlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\n\t\t\tlp->drv_rx_errors++;\n\t\t\tgoto err_next_pkt;\n\t\t}\n\t\tnew_skb = netdev_alloc_skb(dev, lp->rx_buff_len);\n\t\tif (!new_skb) {\n\t\t\t \n\t\t\tlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\n\t\t\tlp->drv_rx_errors++;\n\t\t\tgoto err_next_pkt;\n\t\t}\n\n\t\tskb_reserve(new_skb, 2);\n\t\tskb = lp->rx_skbuff[rx_index];\n\t\tdma_unmap_single(&lp->pci_dev->dev, lp->rx_dma_addr[rx_index],\n\t\t\t\t lp->rx_buff_len - 2, DMA_FROM_DEVICE);\n\t\tskb_put(skb, pkt_len);\n\t\tlp->rx_skbuff[rx_index] = new_skb;\n\t\tlp->rx_dma_addr[rx_index] = dma_map_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t\t   new_skb->data,\n\t\t\t\t\t\t\t   lp->rx_buff_len - 2,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\n#if AMD8111E_VLAN_TAG_USED\n\t\tif (vtag == TT_VLAN_TAGGED) {\n\t\t\tu16 vlan_tag = le16_to_cpu(lp->rx_ring[rx_index].tag_ctrl_info);\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);\n\t\t}\n#endif\n\t\tnapi_gro_receive(napi, skb);\n\t\t \n\t\tlp->coal_conf.rx_packets++;\n\t\tlp->coal_conf.rx_bytes += pkt_len;\n\t\tnum_rx_pkt++;\n\nerr_next_pkt:\n\t\tlp->rx_ring[rx_index].buff_phy_addr\n\t\t\t= cpu_to_le32(lp->rx_dma_addr[rx_index]);\n\t\tlp->rx_ring[rx_index].buff_count =\n\t\t\tcpu_to_le16(lp->rx_buff_len-2);\n\t\twmb();\n\t\tlp->rx_ring[rx_index].rx_flags |= cpu_to_le16(OWN_BIT);\n\t\trx_index = (++lp->rx_idx) & RX_RING_DR_MOD_MASK;\n\t}\n\n\tif (num_rx_pkt < budget && napi_complete_done(napi, num_rx_pkt)) {\n\t\tunsigned long flags;\n\n\t\t \n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\twritel(VAL0|RINTEN0, mmio + INTEN0);\n\t\twritel(VAL2 | RDMD0, mmio + CMD0);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t}\n\n\treturn num_rx_pkt;\n}\n\n \nstatic int amd8111e_link_change(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint status0, speed;\n\n\t \n\tstatus0 = readl(lp->mmio + STAT0);\n\n\tif (status0 & LINK_STATS) {\n\t\tif (status0 & AUTONEG_COMPLETE)\n\t\t\tlp->link_config.autoneg = AUTONEG_ENABLE;\n\t\telse\n\t\t\tlp->link_config.autoneg = AUTONEG_DISABLE;\n\n\t\tif (status0 & FULL_DPLX)\n\t\t\tlp->link_config.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tlp->link_config.duplex = DUPLEX_HALF;\n\t\tspeed = (status0 & SPEED_MASK) >> 7;\n\t\tif (speed == PHY_SPEED_10)\n\t\t\tlp->link_config.speed = SPEED_10;\n\t\telse if (speed == PHY_SPEED_100)\n\t\t\tlp->link_config.speed = SPEED_100;\n\n\t\tnetdev_info(dev, \"Link is Up. Speed is %s Mbps %s Duplex\\n\",\n\t\t\t    (lp->link_config.speed == SPEED_100) ?\n\t\t\t\t\t\t\t\"100\" : \"10\",\n\t\t\t    (lp->link_config.duplex == DUPLEX_FULL) ?\n\t\t\t\t\t\t\t\"Full\" : \"Half\");\n\n\t\tnetif_carrier_on(dev);\n\t} else {\n\t\tlp->link_config.speed = SPEED_INVALID;\n\t\tlp->link_config.duplex = DUPLEX_INVALID;\n\t\tlp->link_config.autoneg = AUTONEG_INVALID;\n\t\tnetdev_info(dev, \"Link is Down.\\n\");\n\t\tnetif_carrier_off(dev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int amd8111e_read_mib(void __iomem *mmio, u8 MIB_COUNTER)\n{\n\tunsigned int  status;\n\tunsigned  int data;\n\tunsigned int repeat = REPEAT_CNT;\n\n\twritew(MIB_RD_CMD | MIB_COUNTER, mmio + MIB_ADDR);\n\tdo {\n\t\tstatus = readw(mmio + MIB_ADDR);\n\t\tudelay(2);\t \n\t}\n\twhile (--repeat && (status & MIB_CMD_ACTIVE));\n\n\tdata = readl(mmio + MIB_DATA);\n\treturn data;\n}\n\n \nstatic struct net_device_stats *amd8111e_get_stats(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tvoid __iomem *mmio = lp->mmio;\n\tunsigned long flags;\n\tstruct net_device_stats *new_stats = &dev->stats;\n\n\tif (!lp->opened)\n\t\treturn new_stats;\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\t \n\tnew_stats->rx_packets = amd8111e_read_mib(mmio, rcv_broadcast_pkts)+\n\t\t\t\tamd8111e_read_mib(mmio, rcv_multicast_pkts)+\n\t\t\t\tamd8111e_read_mib(mmio, rcv_unicast_pkts);\n\n\t \n\tnew_stats->tx_packets = amd8111e_read_mib(mmio, xmt_packets);\n\n\t \n\tnew_stats->rx_bytes = amd8111e_read_mib(mmio, rcv_octets);\n\n\t \n\tnew_stats->tx_bytes = amd8111e_read_mib(mmio, xmt_octets);\n\n\t \n\t \n\tnew_stats->rx_errors = amd8111e_read_mib(mmio, rcv_undersize_pkts)+\n\t\t\t\tamd8111e_read_mib(mmio, rcv_fragments)+\n\t\t\t\tamd8111e_read_mib(mmio, rcv_jabbers)+\n\t\t\t\tamd8111e_read_mib(mmio, rcv_alignment_errors)+\n\t\t\t\tamd8111e_read_mib(mmio, rcv_fcs_errors)+\n\t\t\t\tamd8111e_read_mib(mmio, rcv_miss_pkts)+\n\t\t\t\tlp->drv_rx_errors;\n\n\t \n\tnew_stats->tx_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);\n\n\t \n\tnew_stats->rx_dropped = amd8111e_read_mib(mmio, rcv_miss_pkts);\n\n\t \n\tnew_stats->tx_dropped = amd8111e_read_mib(mmio,  xmt_underrun_pkts);\n\n\t \n\tnew_stats->multicast = amd8111e_read_mib(mmio, rcv_multicast_pkts);\n\n\t \n\tnew_stats->collisions = amd8111e_read_mib(mmio, xmt_collisions);\n\n\t \n\tnew_stats->rx_length_errors =\n\t\tamd8111e_read_mib(mmio, rcv_undersize_pkts)+\n\t\tamd8111e_read_mib(mmio, rcv_oversize_pkts);\n\n\t \n\tnew_stats->rx_over_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);\n\n\t \n\tnew_stats->rx_crc_errors = amd8111e_read_mib(mmio, rcv_fcs_errors);\n\n\t \n\tnew_stats->rx_frame_errors =\n\t\tamd8111e_read_mib(mmio, rcv_alignment_errors);\n\n\t \n\tnew_stats->rx_fifo_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);\n\n\t \n\tnew_stats->rx_missed_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);\n\n\t \n\tnew_stats->tx_aborted_errors =\n\t\tamd8111e_read_mib(mmio, xmt_excessive_collision);\n\n\t \n\tnew_stats->tx_carrier_errors =\n\t\tamd8111e_read_mib(mmio, xmt_loss_carrier);\n\n\t \n\tnew_stats->tx_fifo_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);\n\n\t \n\tnew_stats->tx_window_errors =\n\t\tamd8111e_read_mib(mmio, xmt_late_collision);\n\n\t \n\t \n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn new_stats;\n}\n\n \nstatic int amd8111e_calc_coalesce(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tstruct amd8111e_coalesce_conf *coal_conf = &lp->coal_conf;\n\tint tx_pkt_rate;\n\tint rx_pkt_rate;\n\tint tx_data_rate;\n\tint rx_data_rate;\n\tint rx_pkt_size;\n\tint tx_pkt_size;\n\n\ttx_pkt_rate = coal_conf->tx_packets - coal_conf->tx_prev_packets;\n\tcoal_conf->tx_prev_packets =  coal_conf->tx_packets;\n\n\ttx_data_rate = coal_conf->tx_bytes - coal_conf->tx_prev_bytes;\n\tcoal_conf->tx_prev_bytes =  coal_conf->tx_bytes;\n\n\trx_pkt_rate = coal_conf->rx_packets - coal_conf->rx_prev_packets;\n\tcoal_conf->rx_prev_packets =  coal_conf->rx_packets;\n\n\trx_data_rate = coal_conf->rx_bytes - coal_conf->rx_prev_bytes;\n\tcoal_conf->rx_prev_bytes =  coal_conf->rx_bytes;\n\n\tif (rx_pkt_rate < 800) {\n\t\tif (coal_conf->rx_coal_type != NO_COALESCE) {\n\n\t\t\tcoal_conf->rx_timeout = 0x0;\n\t\t\tcoal_conf->rx_event_count = 0;\n\t\t\tamd8111e_set_coalesce(dev, RX_INTR_COAL);\n\t\t\tcoal_conf->rx_coal_type = NO_COALESCE;\n\t\t}\n\t} else {\n\n\t\trx_pkt_size = rx_data_rate/rx_pkt_rate;\n\t\tif (rx_pkt_size < 128) {\n\t\t\tif (coal_conf->rx_coal_type != NO_COALESCE) {\n\n\t\t\t\tcoal_conf->rx_timeout = 0;\n\t\t\t\tcoal_conf->rx_event_count = 0;\n\t\t\t\tamd8111e_set_coalesce(dev, RX_INTR_COAL);\n\t\t\t\tcoal_conf->rx_coal_type = NO_COALESCE;\n\t\t\t}\n\n\t\t} else if ((rx_pkt_size >= 128) && (rx_pkt_size < 512)) {\n\n\t\t\tif (coal_conf->rx_coal_type !=  LOW_COALESCE) {\n\t\t\t\tcoal_conf->rx_timeout = 1;\n\t\t\t\tcoal_conf->rx_event_count = 4;\n\t\t\t\tamd8111e_set_coalesce(dev, RX_INTR_COAL);\n\t\t\t\tcoal_conf->rx_coal_type = LOW_COALESCE;\n\t\t\t}\n\t\t} else if ((rx_pkt_size >= 512) && (rx_pkt_size < 1024)) {\n\n\t\t\tif (coal_conf->rx_coal_type != MEDIUM_COALESCE) {\n\t\t\t\tcoal_conf->rx_timeout = 1;\n\t\t\t\tcoal_conf->rx_event_count = 4;\n\t\t\t\tamd8111e_set_coalesce(dev, RX_INTR_COAL);\n\t\t\t\tcoal_conf->rx_coal_type = MEDIUM_COALESCE;\n\t\t\t}\n\n\t\t} else if (rx_pkt_size >= 1024) {\n\n\t\t\tif (coal_conf->rx_coal_type !=  HIGH_COALESCE) {\n\t\t\t\tcoal_conf->rx_timeout = 2;\n\t\t\t\tcoal_conf->rx_event_count = 3;\n\t\t\t\tamd8111e_set_coalesce(dev, RX_INTR_COAL);\n\t\t\t\tcoal_conf->rx_coal_type = HIGH_COALESCE;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (tx_pkt_rate < 800) {\n\t\tif (coal_conf->tx_coal_type != NO_COALESCE) {\n\n\t\t\tcoal_conf->tx_timeout = 0x0;\n\t\t\tcoal_conf->tx_event_count = 0;\n\t\t\tamd8111e_set_coalesce(dev, TX_INTR_COAL);\n\t\t\tcoal_conf->tx_coal_type = NO_COALESCE;\n\t\t}\n\t} else {\n\n\t\ttx_pkt_size = tx_data_rate/tx_pkt_rate;\n\t\tif (tx_pkt_size < 128) {\n\n\t\t\tif (coal_conf->tx_coal_type != NO_COALESCE) {\n\n\t\t\t\tcoal_conf->tx_timeout = 0;\n\t\t\t\tcoal_conf->tx_event_count = 0;\n\t\t\t\tamd8111e_set_coalesce(dev, TX_INTR_COAL);\n\t\t\t\tcoal_conf->tx_coal_type = NO_COALESCE;\n\t\t\t}\n\n\t\t} else if ((tx_pkt_size >= 128) && (tx_pkt_size < 512)) {\n\n\t\t\tif (coal_conf->tx_coal_type != LOW_COALESCE) {\n\t\t\t\tcoal_conf->tx_timeout = 1;\n\t\t\t\tcoal_conf->tx_event_count = 2;\n\t\t\t\tamd8111e_set_coalesce(dev, TX_INTR_COAL);\n\t\t\t\tcoal_conf->tx_coal_type = LOW_COALESCE;\n\n\t\t\t}\n\t\t} else if ((tx_pkt_size >= 512) && (tx_pkt_size < 1024)) {\n\n\t\t\tif (coal_conf->tx_coal_type != MEDIUM_COALESCE) {\n\t\t\t\tcoal_conf->tx_timeout = 2;\n\t\t\t\tcoal_conf->tx_event_count = 5;\n\t\t\t\tamd8111e_set_coalesce(dev, TX_INTR_COAL);\n\t\t\t\tcoal_conf->tx_coal_type = MEDIUM_COALESCE;\n\t\t\t}\n\t\t} else if (tx_pkt_size >= 1024) {\n\t\t\tif (coal_conf->tx_coal_type != HIGH_COALESCE) {\n\t\t\t\tcoal_conf->tx_timeout = 4;\n\t\t\t\tcoal_conf->tx_event_count = 8;\n\t\t\t\tamd8111e_set_coalesce(dev, TX_INTR_COAL);\n\t\t\t\tcoal_conf->tx_coal_type = HIGH_COALESCE;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}\n\n \nstatic irqreturn_t amd8111e_interrupt(int irq, void *dev_id)\n{\n\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tvoid __iomem *mmio = lp->mmio;\n\tunsigned int intr0, intren0;\n\tunsigned int handled = 1;\n\n\tif (unlikely(!dev))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&lp->lock);\n\n\t \n\twritel(INTREN, mmio + CMD0);\n\n\t \n\tintr0 = readl(mmio + INT0);\n\tintren0 = readl(mmio + INTEN0);\n\n\t \n\n\tif (!(intr0 & INTR)) {\n\t\thandled = 0;\n\t\tgoto err_no_interrupt;\n\t}\n\n\t \n\twritel(intr0, mmio + INT0);\n\n\t \n\tif (intr0 & RINT0) {\n\t\tif (napi_schedule_prep(&lp->napi)) {\n\t\t\t \n\t\t\twritel(RINTEN0, mmio + INTEN0);\n\t\t\t \n\t\t\t__napi_schedule(&lp->napi);\n\t\t} else if (intren0 & RINTEN0) {\n\t\t\tnetdev_dbg(dev, \"************Driver bug! interrupt while in poll\\n\");\n\t\t\t \n\t\t\twritel(RINTEN0, mmio + INTEN0);\n\t\t}\n\t}\n\n\t \n\tif (intr0 & TINT0)\n\t\tamd8111e_tx(dev);\n\n\t \n\tif (intr0 & LCINT)\n\t\tamd8111e_link_change(dev);\n\n\t \n\tif (intr0 & STINT)\n\t\tamd8111e_calc_coalesce(dev);\n\nerr_no_interrupt:\n\twritel(VAL0 | INTREN, mmio + CMD0);\n\n\tspin_unlock(&lp->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void amd8111e_poll(struct net_device *dev)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\tamd8111e_interrupt(0, dev);\n\tlocal_irq_restore(flags);\n}\n#endif\n\n\n \nstatic int amd8111e_close(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tnetif_stop_queue(dev);\n\n\tnapi_disable(&lp->napi);\n\n\tspin_lock_irq(&lp->lock);\n\n\tamd8111e_disable_interrupt(lp);\n\tamd8111e_stop_chip(lp);\n\n\t \n\tamd8111e_free_skbs(lp->amd8111e_net_dev);\n\n\tnetif_carrier_off(lp->amd8111e_net_dev);\n\n\t \n\tif (lp->options & OPTION_DYN_IPG_ENABLE)\n\t\tdel_timer_sync(&lp->ipg_data.ipg_timer);\n\n\tspin_unlock_irq(&lp->lock);\n\tfree_irq(dev->irq, dev);\n\tamd8111e_free_ring(lp);\n\n\t \n\tamd8111e_get_stats(dev);\n\tlp->opened = 0;\n\treturn 0;\n}\n\n \nstatic int amd8111e_open(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\n\tif (dev->irq == 0 || request_irq(dev->irq, amd8111e_interrupt,\n\t\t\t\t\t IRQF_SHARED, dev->name, dev))\n\t\treturn -EAGAIN;\n\n\tnapi_enable(&lp->napi);\n\n\tspin_lock_irq(&lp->lock);\n\n\tamd8111e_init_hw_default(lp);\n\n\tif (amd8111e_restart(dev)) {\n\t\tspin_unlock_irq(&lp->lock);\n\t\tnapi_disable(&lp->napi);\n\t\tif (dev->irq)\n\t\t\tfree_irq(dev->irq, dev);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tif (lp->options & OPTION_DYN_IPG_ENABLE) {\n\t\tadd_timer(&lp->ipg_data.ipg_timer);\n\t\tnetdev_info(dev, \"Dynamic IPG Enabled\\n\");\n\t}\n\n\tlp->opened = 1;\n\n\tspin_unlock_irq(&lp->lock);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic int amd8111e_tx_queue_avail(struct amd8111e_priv *lp)\n{\n\tint tx_index = lp->tx_idx & TX_BUFF_MOD_MASK;\n\tif (lp->tx_skbuff[tx_index])\n\t\treturn -1;\n\telse\n\t\treturn 0;\n\n}\n\n \nstatic netdev_tx_t amd8111e_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint tx_index;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\ttx_index = lp->tx_idx & TX_RING_DR_MOD_MASK;\n\n\tlp->tx_ring[tx_index].buff_count = cpu_to_le16(skb->len);\n\n\tlp->tx_skbuff[tx_index] = skb;\n\tlp->tx_ring[tx_index].tx_flags = 0;\n\n#if AMD8111E_VLAN_TAG_USED\n\tif (skb_vlan_tag_present(skb)) {\n\t\tlp->tx_ring[tx_index].tag_ctrl_cmd |=\n\t\t\t\tcpu_to_le16(TCC_VLAN_INSERT);\n\t\tlp->tx_ring[tx_index].tag_ctrl_info =\n\t\t\t\tcpu_to_le16(skb_vlan_tag_get(skb));\n\n\t}\n#endif\n\tlp->tx_dma_addr[tx_index] =\n\t    dma_map_single(&lp->pci_dev->dev, skb->data, skb->len,\n\t\t\t   DMA_TO_DEVICE);\n\tlp->tx_ring[tx_index].buff_phy_addr =\n\t    cpu_to_le32(lp->tx_dma_addr[tx_index]);\n\n\t \n\twmb();\n\tlp->tx_ring[tx_index].tx_flags |=\n\t    cpu_to_le16(OWN_BIT | STP_BIT | ENP_BIT|ADD_FCS_BIT|LTINT_BIT);\n\n\tlp->tx_idx++;\n\n\t \n\twritel(VAL1 | TDMD0, lp->mmio + CMD0);\n\twritel(VAL2 | RDMD0, lp->mmio + CMD0);\n\n\tif (amd8111e_tx_queue_avail(lp) < 0) {\n\t\tnetif_stop_queue(dev);\n\t}\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn NETDEV_TX_OK;\n}\n \nstatic void amd8111e_read_regs(struct amd8111e_priv *lp, u32 *buf)\n{\n\tvoid __iomem *mmio = lp->mmio;\n\t \n\tbuf[0] = readl(mmio + XMT_RING_BASE_ADDR0);\n\tbuf[1] = readl(mmio + XMT_RING_LEN0);\n\tbuf[2] = readl(mmio + RCV_RING_BASE_ADDR0);\n\tbuf[3] = readl(mmio + RCV_RING_LEN0);\n\tbuf[4] = readl(mmio + CMD0);\n\tbuf[5] = readl(mmio + CMD2);\n\tbuf[6] = readl(mmio + CMD3);\n\tbuf[7] = readl(mmio + CMD7);\n\tbuf[8] = readl(mmio + INT0);\n\tbuf[9] = readl(mmio + INTEN0);\n\tbuf[10] = readl(mmio + LADRF);\n\tbuf[11] = readl(mmio + LADRF+4);\n\tbuf[12] = readl(mmio + STAT0);\n}\n\n\n \nstatic void amd8111e_set_multicast_list(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tu32 mc_filter[2];\n\tint bit_num;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\twritel(VAL2 | PROM, lp->mmio + CMD2);\n\t\treturn;\n\t}\n\telse\n\t\twritel(PROM, lp->mmio + CMD2);\n\tif (dev->flags & IFF_ALLMULTI ||\n\t    netdev_mc_count(dev) > MAX_FILTER_SIZE) {\n\t\t \n\t\tmc_filter[1] = mc_filter[0] = 0xffffffff;\n\t\tlp->options |= OPTION_MULTICAST_ENABLE;\n\t\tamd8111e_writeq(*(u64 *)mc_filter, lp->mmio + LADRF);\n\t\treturn;\n\t}\n\tif (netdev_mc_empty(dev)) {\n\t\t \n\t\tmc_filter[1] = mc_filter[0] = 0;\n\t\tlp->options &= ~OPTION_MULTICAST_ENABLE;\n\t\tamd8111e_writeq(*(u64 *)mc_filter, lp->mmio + LADRF);\n\t\t \n\t\twritel(PROM, lp->mmio + CMD2);\n\t\treturn;\n\t}\n\t \n\tlp->options |= OPTION_MULTICAST_ENABLE;\n\tmc_filter[1] = mc_filter[0] = 0;\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tbit_num = (ether_crc_le(ETH_ALEN, ha->addr) >> 26) & 0x3f;\n\t\tmc_filter[bit_num >> 5] |= 1 << (bit_num & 31);\n\t}\n\tamd8111e_writeq(*(u64 *)mc_filter, lp->mmio + LADRF);\n\n\t \n\treadl(lp->mmio + CMD2);\n\n}\n\nstatic void amd8111e_get_drvinfo(struct net_device *dev,\n\t\t\t\t struct ethtool_drvinfo *info)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tstruct pci_dev *pci_dev = lp->pci_dev;\n\tstrscpy(info->driver, MODULE_NAME, sizeof(info->driver));\n\tsnprintf(info->fw_version, sizeof(info->fw_version),\n\t\t\"%u\", chip_version);\n\tstrscpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));\n}\n\nstatic int amd8111e_get_regs_len(struct net_device *dev)\n{\n\treturn AMD8111E_REG_DUMP_LEN;\n}\n\nstatic void amd8111e_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tregs->version = 0;\n\tamd8111e_read_regs(lp, buf);\n}\n\nstatic int amd8111e_get_link_ksettings(struct net_device *dev,\n\t\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tspin_lock_irq(&lp->lock);\n\tmii_ethtool_get_link_ksettings(&lp->mii_if, cmd);\n\tspin_unlock_irq(&lp->lock);\n\treturn 0;\n}\n\nstatic int amd8111e_set_link_ksettings(struct net_device *dev,\n\t\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint res;\n\tspin_lock_irq(&lp->lock);\n\tres = mii_ethtool_set_link_ksettings(&lp->mii_if, cmd);\n\tspin_unlock_irq(&lp->lock);\n\treturn res;\n}\n\nstatic int amd8111e_nway_reset(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\treturn mii_nway_restart(&lp->mii_if);\n}\n\nstatic u32 amd8111e_get_link(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\treturn mii_link_ok(&lp->mii_if);\n}\n\nstatic void amd8111e_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol_info)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\twol_info->supported = WAKE_MAGIC|WAKE_PHY;\n\tif (lp->options & OPTION_WOL_ENABLE)\n\t\twol_info->wolopts = WAKE_MAGIC;\n}\n\nstatic int amd8111e_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol_info)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tif (wol_info->wolopts & ~(WAKE_MAGIC|WAKE_PHY))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&lp->lock);\n\tif (wol_info->wolopts & WAKE_MAGIC)\n\t\tlp->options |=\n\t\t\t(OPTION_WOL_ENABLE | OPTION_WAKE_MAGIC_ENABLE);\n\telse if (wol_info->wolopts & WAKE_PHY)\n\t\tlp->options |=\n\t\t\t(OPTION_WOL_ENABLE | OPTION_WAKE_PHY_ENABLE);\n\telse\n\t\tlp->options &= ~OPTION_WOL_ENABLE;\n\tspin_unlock_irq(&lp->lock);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = amd8111e_get_drvinfo,\n\t.get_regs_len = amd8111e_get_regs_len,\n\t.get_regs = amd8111e_get_regs,\n\t.nway_reset = amd8111e_nway_reset,\n\t.get_link = amd8111e_get_link,\n\t.get_wol = amd8111e_get_wol,\n\t.set_wol = amd8111e_set_wol,\n\t.get_link_ksettings = amd8111e_get_link_ksettings,\n\t.set_link_ksettings = amd8111e_set_link_ksettings,\n};\n\n \nstatic int amd8111e_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint err;\n\tu32 mii_regval;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = lp->ext_phy_addr;\n\n\t\tfallthrough;\n\tcase SIOCGMIIREG:\n\n\t\tspin_lock_irq(&lp->lock);\n\t\terr = amd8111e_read_phy(lp, data->phy_id,\n\t\t\tdata->reg_num & PHY_REG_ADDR_MASK, &mii_regval);\n\t\tspin_unlock_irq(&lp->lock);\n\n\t\tdata->val_out = mii_regval;\n\t\treturn err;\n\n\tcase SIOCSMIIREG:\n\n\t\tspin_lock_irq(&lp->lock);\n\t\terr = amd8111e_write_phy(lp, data->phy_id,\n\t\t\tdata->reg_num & PHY_REG_ADDR_MASK, data->val_in);\n\t\tspin_unlock_irq(&lp->lock);\n\n\t\treturn err;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\nstatic int amd8111e_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint i;\n\tstruct sockaddr *addr = p;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\tspin_lock_irq(&lp->lock);\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\twriteb(dev->dev_addr[i], lp->mmio + PADR + i);\n\n\tspin_unlock_irq(&lp->lock);\n\n\treturn 0;\n}\n\n \nstatic int amd8111e_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint err;\n\n\tif (!netif_running(dev)) {\n\t\t \n\t\tdev->mtu = new_mtu;\n\t\treturn 0;\n\t}\n\n\tspin_lock_irq(&lp->lock);\n\n\t \n\twritel(RUN, lp->mmio + CMD0);\n\n\tdev->mtu = new_mtu;\n\n\terr = amd8111e_restart(dev);\n\tspin_unlock_irq(&lp->lock);\n\tif (!err)\n\t\tnetif_start_queue(dev);\n\treturn err;\n}\n\nstatic int amd8111e_enable_magicpkt(struct amd8111e_priv *lp)\n{\n\twritel(VAL1 | MPPLBA, lp->mmio + CMD3);\n\twritel(VAL0 | MPEN_SW, lp->mmio + CMD7);\n\n\t \n\treadl(lp->mmio + CMD7);\n\treturn 0;\n}\n\nstatic int amd8111e_enable_link_change(struct amd8111e_priv *lp)\n{\n\n\t \n\twritel(VAL0 | LCMODE_SW, lp->mmio + CMD7);\n\n\t \n\treadl(lp->mmio + CMD7);\n\treturn 0;\n}\n\n \nstatic void amd8111e_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint err;\n\n\tnetdev_err(dev, \"transmit timed out, resetting\\n\");\n\n\tspin_lock_irq(&lp->lock);\n\terr = amd8111e_restart(dev);\n\tspin_unlock_irq(&lp->lock);\n\tif (!err)\n\t\tnetif_wake_queue(dev);\n}\n\nstatic int __maybe_unused amd8111e_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\t \n\tspin_lock_irq(&lp->lock);\n\tamd8111e_disable_interrupt(lp);\n\tspin_unlock_irq(&lp->lock);\n\n\tnetif_device_detach(dev);\n\n\t \n\tspin_lock_irq(&lp->lock);\n\tif (lp->options & OPTION_DYN_IPG_ENABLE)\n\t\tdel_timer_sync(&lp->ipg_data.ipg_timer);\n\tamd8111e_stop_chip(lp);\n\tspin_unlock_irq(&lp->lock);\n\n\tif (lp->options & OPTION_WOL_ENABLE) {\n\t\t  \n\t\tif (lp->options & OPTION_WAKE_MAGIC_ENABLE)\n\t\t\tamd8111e_enable_magicpkt(lp);\n\t\tif (lp->options & OPTION_WAKE_PHY_ENABLE)\n\t\t\tamd8111e_enable_link_change(lp);\n\n\t\tdevice_set_wakeup_enable(dev_d, 1);\n\n\t} else {\n\t\tdevice_set_wakeup_enable(dev_d, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused amd8111e_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tnetif_device_attach(dev);\n\n\tspin_lock_irq(&lp->lock);\n\tamd8111e_restart(dev);\n\t \n\tif (lp->options & OPTION_DYN_IPG_ENABLE)\n\t\tmod_timer(&lp->ipg_data.ipg_timer,\n\t\t\t\tjiffies + IPG_CONVERGE_JIFFIES);\n\tspin_unlock_irq(&lp->lock);\n\n\treturn 0;\n}\n\nstatic void amd8111e_config_ipg(struct timer_list *t)\n{\n\tstruct amd8111e_priv *lp = from_timer(lp, t, ipg_data.ipg_timer);\n\tstruct ipg_info *ipg_data = &lp->ipg_data;\n\tvoid __iomem *mmio = lp->mmio;\n\tunsigned int prev_col_cnt = ipg_data->col_cnt;\n\tunsigned int total_col_cnt;\n\tunsigned int tmp_ipg;\n\n\tif (lp->link_config.duplex == DUPLEX_FULL) {\n\t\tipg_data->ipg = DEFAULT_IPG;\n\t\treturn;\n\t}\n\n\tif (ipg_data->ipg_state == SSTATE) {\n\n\t\tif (ipg_data->timer_tick == IPG_STABLE_TIME) {\n\n\t\t\tipg_data->timer_tick = 0;\n\t\t\tipg_data->ipg = MIN_IPG - IPG_STEP;\n\t\t\tipg_data->current_ipg = MIN_IPG;\n\t\t\tipg_data->diff_col_cnt = 0xFFFFFFFF;\n\t\t\tipg_data->ipg_state = CSTATE;\n\t\t}\n\t\telse\n\t\t\tipg_data->timer_tick++;\n\t}\n\n\tif (ipg_data->ipg_state == CSTATE) {\n\n\t\t \n\n\t\ttotal_col_cnt = ipg_data->col_cnt =\n\t\t\t\tamd8111e_read_mib(mmio, xmt_collisions);\n\n\t\tif ((total_col_cnt - prev_col_cnt) <\n\t\t\t\t(ipg_data->diff_col_cnt)) {\n\n\t\t\tipg_data->diff_col_cnt =\n\t\t\t\ttotal_col_cnt - prev_col_cnt;\n\n\t\t\tipg_data->ipg = ipg_data->current_ipg;\n\t\t}\n\n\t\tipg_data->current_ipg += IPG_STEP;\n\n\t\tif (ipg_data->current_ipg <= MAX_IPG)\n\t\t\ttmp_ipg = ipg_data->current_ipg;\n\t\telse {\n\t\t\ttmp_ipg = ipg_data->ipg;\n\t\t\tipg_data->ipg_state = SSTATE;\n\t\t}\n\t\twritew((u32)tmp_ipg, mmio + IPG);\n\t\twritew((u32)(tmp_ipg - IFS1_DELTA), mmio + IFS1);\n\t}\n\tmod_timer(&lp->ipg_data.ipg_timer, jiffies + IPG_CONVERGE_JIFFIES);\n\treturn;\n\n}\n\nstatic void amd8111e_probe_ext_phy(struct net_device *dev)\n{\n\tstruct amd8111e_priv *lp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0x1e; i >= 0; i--) {\n\t\tu32 id1, id2;\n\n\t\tif (amd8111e_read_phy(lp, i, MII_PHYSID1, &id1))\n\t\t\tcontinue;\n\t\tif (amd8111e_read_phy(lp, i, MII_PHYSID2, &id2))\n\t\t\tcontinue;\n\t\tlp->ext_phy_id = (id1 << 16) | id2;\n\t\tlp->ext_phy_addr = i;\n\t\treturn;\n\t}\n\tlp->ext_phy_id = 0;\n\tlp->ext_phy_addr = 1;\n}\n\nstatic const struct net_device_ops amd8111e_netdev_ops = {\n\t.ndo_open\t\t= amd8111e_open,\n\t.ndo_stop\t\t= amd8111e_close,\n\t.ndo_start_xmit\t\t= amd8111e_start_xmit,\n\t.ndo_tx_timeout\t\t= amd8111e_tx_timeout,\n\t.ndo_get_stats\t\t= amd8111e_get_stats,\n\t.ndo_set_rx_mode\t= amd8111e_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= amd8111e_set_mac_address,\n\t.ndo_eth_ioctl\t\t= amd8111e_ioctl,\n\t.ndo_change_mtu\t\t= amd8111e_change_mtu,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t = amd8111e_poll,\n#endif\n};\n\nstatic int amd8111e_probe_one(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *ent)\n{\n\tint err, i;\n\tunsigned long reg_addr, reg_len;\n\tstruct amd8111e_priv *lp;\n\tstruct net_device *dev;\n\tu8 addr[ETH_ALEN];\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot enable new PCI device\\n\");\n\t\treturn err;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev, \"Cannot find PCI base address\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_disable_pdev;\n\t}\n\n\terr = pci_request_regions(pdev, MODULE_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources\\n\");\n\t\tgoto err_disable_pdev;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tif (!pdev->pm_cap) {\n\t\tdev_err(&pdev->dev, \"No Power Management capability\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_free_reg;\n\t}\n\n\t \n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)) < 0) {\n\t\tdev_err(&pdev->dev, \"DMA not supported\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_free_reg;\n\t}\n\n\treg_addr = pci_resource_start(pdev, 0);\n\treg_len = pci_resource_len(pdev, 0);\n\n\tdev = alloc_etherdev(sizeof(struct amd8111e_priv));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_reg;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n#if AMD8111E_VLAN_TAG_USED\n\tdev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;\n#endif\n\n\tlp = netdev_priv(dev);\n\tlp->pci_dev = pdev;\n\tlp->amd8111e_net_dev = dev;\n\tlp->pm_cap = pdev->pm_cap;\n\n\tspin_lock_init(&lp->lock);\n\n\tlp->mmio = devm_ioremap(&pdev->dev, reg_addr, reg_len);\n\tif (!lp->mmio) {\n\t\tdev_err(&pdev->dev, \"Cannot map device registers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\taddr[i] = readb(lp->mmio + PADR + i);\n\teth_hw_addr_set(dev, addr);\n\n\t \n\tlp->ext_phy_option = speed_duplex[card_idx];\n\tif (coalesce[card_idx])\n\t\tlp->options |= OPTION_INTR_COAL_ENABLE;\n\tif (dynamic_ipg[card_idx++])\n\t\tlp->options |= OPTION_DYN_IPG_ENABLE;\n\n\n\t \n\tdev->netdev_ops = &amd8111e_netdev_ops;\n\tdev->ethtool_ops = &ops;\n\tdev->irq = pdev->irq;\n\tdev->watchdog_timeo = AMD8111E_TX_TIMEOUT;\n\tdev->min_mtu = AMD8111E_MIN_MTU;\n\tdev->max_mtu = AMD8111E_MAX_MTU;\n\tnetif_napi_add_weight(dev, &lp->napi, amd8111e_rx_poll, 32);\n\n\t \n\tamd8111e_probe_ext_phy(dev);\n\n\t \n\tlp->mii_if.dev = dev;\n\tlp->mii_if.mdio_read = amd8111e_mdio_read;\n\tlp->mii_if.mdio_write = amd8111e_mdio_write;\n\tlp->mii_if.phy_id = lp->ext_phy_addr;\n\n\t \n\tamd8111e_set_rx_buff_len(dev);\n\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tif (lp->options & OPTION_DYN_IPG_ENABLE) {\n\t\ttimer_setup(&lp->ipg_data.ipg_timer, amd8111e_config_ipg, 0);\n\t\tlp->ipg_data.ipg_timer.expires = jiffies +\n\t\t\t\t\t\t IPG_CONVERGE_JIFFIES;\n\t\tlp->ipg_data.ipg = DEFAULT_IPG;\n\t\tlp->ipg_data.ipg_state = CSTATE;\n\t}\n\n\t \n\tchip_version = (readl(lp->mmio + CHIPID) & 0xf0000000) >> 28;\n\tdev_info(&pdev->dev, \"[ Rev %x ] PCI 10/100BaseT Ethernet %pM\\n\",\n\t\t chip_version, dev->dev_addr);\n\tif (lp->ext_phy_id)\n\t\tdev_info(&pdev->dev, \"Found MII PHY ID 0x%08x at address 0x%02x\\n\",\n\t\t\t lp->ext_phy_id, lp->ext_phy_addr);\n\telse\n\t\tdev_info(&pdev->dev, \"Couldn't detect MII PHY, assuming address 0x01\\n\");\n\n\treturn 0;\n\nerr_free_dev:\n\tfree_netdev(dev);\n\nerr_free_reg:\n\tpci_release_regions(pdev);\n\nerr_disable_pdev:\n\tpci_disable_device(pdev);\n\treturn err;\n\n}\n\nstatic void amd8111e_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tunregister_netdev(dev);\n\t\tfree_netdev(dev);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic const struct pci_device_id amd8111e_pci_tbl[] = {\n\t{\n\t .vendor = PCI_VENDOR_ID_AMD,\n\t .device = PCI_DEVICE_ID_AMD8111E_7462,\n\t},\n\t{\n\t .vendor = 0,\n\t}\n};\nMODULE_DEVICE_TABLE(pci, amd8111e_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(amd8111e_pm_ops, amd8111e_suspend, amd8111e_resume);\n\nstatic struct pci_driver amd8111e_driver = {\n\t.name\t\t= MODULE_NAME,\n\t.id_table\t= amd8111e_pci_tbl,\n\t.probe\t\t= amd8111e_probe_one,\n\t.remove\t\t= amd8111e_remove_one,\n\t.driver.pm\t= &amd8111e_pm_ops\n};\n\nmodule_pci_driver(amd8111e_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}