{
  "module_name": "ariadne.c",
  "hash_id": "b780e487a000628e6f3e44ffc17d6b45536f6c23bba09fd6dbba7853cc90dc8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/ariadne.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n \n\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/zorro.h>\n#include <linux/bitops.h>\n\n#include <asm/byteorder.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n#include <asm/irq.h>\n\n#include \"ariadne.h\"\n\n#ifdef ARIADNE_DEBUG\nint ariadne_debug = ARIADNE_DEBUG;\n#else\nint ariadne_debug = 1;\n#endif\n\n \n\n \n#define swapw(x)\t(((x >> 8) & 0x00ff) | ((x << 8) & 0xff00))\n \n#define lowb(x)\t\t(x & 0xff)\n \n#define swhighw(x)\t((((x) >> 8) & 0xff00) | (((x) >> 24) & 0x00ff))\n \n#define swloww(x)\t((((x) << 8) & 0xff00) | (((x) >> 8) & 0x00ff))\n\n \n\n#define TX_RING_SIZE\t5\n#define RX_RING_SIZE\t16\n\n#define PKT_BUF_SIZE\t1520\n\n \n\nstruct ariadne_private {\n\tvolatile struct TDRE *tx_ring[TX_RING_SIZE];\n\tvolatile struct RDRE *rx_ring[RX_RING_SIZE];\n\tvolatile u_short *tx_buff[TX_RING_SIZE];\n\tvolatile u_short *rx_buff[RX_RING_SIZE];\n\tint cur_tx, cur_rx;\t\t \n\tint dirty_tx;\t\t\t \n\tchar tx_full;\n};\n\n \n\nstruct lancedata {\n\tstruct TDRE tx_ring[TX_RING_SIZE];\n\tstruct RDRE rx_ring[RX_RING_SIZE];\n\tu_short tx_buff[TX_RING_SIZE][PKT_BUF_SIZE / sizeof(u_short)];\n\tu_short rx_buff[RX_RING_SIZE][PKT_BUF_SIZE / sizeof(u_short)];\n};\n\nstatic void memcpyw(volatile u_short *dest, u_short *src, int len)\n{\n\twhile (len >= 2) {\n\t\t*(dest++) = *(src++);\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*dest = (*(u_char *)src) << 8;\n}\n\nstatic void ariadne_init_ring(struct net_device *dev)\n{\n\tstruct ariadne_private *priv = netdev_priv(dev);\n\tvolatile struct lancedata *lancedata = (struct lancedata *)dev->mem_start;\n\tint i;\n\n\tnetif_stop_queue(dev);\n\n\tpriv->tx_full = 0;\n\tpriv->cur_rx = priv->cur_tx = 0;\n\tpriv->dirty_tx = 0;\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tvolatile struct TDRE *t = &lancedata->tx_ring[i];\n\t\tt->TMD0 = swloww(ARIADNE_RAM +\n\t\t\t\t offsetof(struct lancedata, tx_buff[i]));\n\t\tt->TMD1 = swhighw(ARIADNE_RAM +\n\t\t\t\t  offsetof(struct lancedata, tx_buff[i])) |\n\t\t\tTF_STP | TF_ENP;\n\t\tt->TMD2 = swapw((u_short)-PKT_BUF_SIZE);\n\t\tt->TMD3 = 0;\n\t\tpriv->tx_ring[i] = &lancedata->tx_ring[i];\n\t\tpriv->tx_buff[i] = lancedata->tx_buff[i];\n\t\tnetdev_dbg(dev, \"TX Entry %2d at %p, Buf at %p\\n\",\n\t\t\t   i, &lancedata->tx_ring[i], lancedata->tx_buff[i]);\n\t}\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tvolatile struct RDRE *r = &lancedata->rx_ring[i];\n\t\tr->RMD0 = swloww(ARIADNE_RAM +\n\t\t\t\t offsetof(struct lancedata, rx_buff[i]));\n\t\tr->RMD1 = swhighw(ARIADNE_RAM +\n\t\t\t\t  offsetof(struct lancedata, rx_buff[i])) |\n\t\t\tRF_OWN;\n\t\tr->RMD2 = swapw((u_short)-PKT_BUF_SIZE);\n\t\tr->RMD3 = 0x0000;\n\t\tpriv->rx_ring[i] = &lancedata->rx_ring[i];\n\t\tpriv->rx_buff[i] = lancedata->rx_buff[i];\n\t\tnetdev_dbg(dev, \"RX Entry %2d at %p, Buf at %p\\n\",\n\t\t\t   i, &lancedata->rx_ring[i], lancedata->rx_buff[i]);\n\t}\n}\n\nstatic int ariadne_rx(struct net_device *dev)\n{\n\tstruct ariadne_private *priv = netdev_priv(dev);\n\tint entry = priv->cur_rx % RX_RING_SIZE;\n\tint i;\n\n\t \n\twhile (!(lowb(priv->rx_ring[entry]->RMD1) & RF_OWN)) {\n\t\tint status = lowb(priv->rx_ring[entry]->RMD1);\n\n\t\tif (status != (RF_STP | RF_ENP)) {\t \n\t\t\t \n\t\t\t \n\t\t\tif (status & RF_ENP)\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\tif (status & RF_FRAM)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (status & RF_OFLO)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif (status & RF_CRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (status & RF_BUFF)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tpriv->rx_ring[entry]->RMD1 &= 0xff00 | RF_STP | RF_ENP;\n\t\t} else {\n\t\t\t \n\t\t\tshort pkt_len = swapw(priv->rx_ring[entry]->RMD3);\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\tif (!skb) {\n\t\t\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\t\t\tif (lowb(priv->rx_ring[(entry + i) % RX_RING_SIZE]->RMD1) & RF_OWN)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif (i > RX_RING_SIZE - 2) {\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\tpriv->rx_ring[entry]->RMD1 |= RF_OWN;\n\t\t\t\t\tpriv->cur_rx++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tskb_put(skb, pkt_len);\t \n\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t\t(const void *)priv->rx_buff[entry],\n\t\t\t\t\t\tpkt_len);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetdev_dbg(dev, \"RX pkt type 0x%04x from %pM to %pM data %p len %u\\n\",\n\t\t\t\t   ((u_short *)skb->data)[6],\n\t\t\t\t   skb->data + 6, skb->data,\n\t\t\t\t   skb->data, skb->len);\n\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\n\t\tpriv->rx_ring[entry]->RMD1 |= RF_OWN;\n\t\tentry = (++priv->cur_rx) % RX_RING_SIZE;\n\t}\n\n\tpriv->cur_rx = priv->cur_rx % RX_RING_SIZE;\n\n\t \n\n\treturn 0;\n}\n\nstatic irqreturn_t ariadne_interrupt(int irq, void *data)\n{\n\tstruct net_device *dev = (struct net_device *)data;\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\tstruct ariadne_private *priv;\n\tint csr0, boguscnt;\n\tint handled = 0;\n\n\tlance->RAP = CSR0;\t\t \n\n\tif (!(lance->RDP & INTR))\t \n\t\treturn IRQ_NONE;\t \n\n\tpriv = netdev_priv(dev);\n\n\tboguscnt = 10;\n\twhile ((csr0 = lance->RDP) & (ERR | RINT | TINT) && --boguscnt >= 0) {\n\t\t \n\t\tlance->RDP = csr0 & ~(INEA | TDMD | STOP | STRT | INIT);\n\n#ifdef DEBUG\n\t\tif (ariadne_debug > 5) {\n\t\t\tnetdev_dbg(dev, \"interrupt  csr0=%#02x new csr=%#02x [\",\n\t\t\t\t   csr0, lance->RDP);\n\t\t\tif (csr0 & INTR)\n\t\t\t\tpr_cont(\" INTR\");\n\t\t\tif (csr0 & INEA)\n\t\t\t\tpr_cont(\" INEA\");\n\t\t\tif (csr0 & RXON)\n\t\t\t\tpr_cont(\" RXON\");\n\t\t\tif (csr0 & TXON)\n\t\t\t\tpr_cont(\" TXON\");\n\t\t\tif (csr0 & TDMD)\n\t\t\t\tpr_cont(\" TDMD\");\n\t\t\tif (csr0 & STOP)\n\t\t\t\tpr_cont(\" STOP\");\n\t\t\tif (csr0 & STRT)\n\t\t\t\tpr_cont(\" STRT\");\n\t\t\tif (csr0 & INIT)\n\t\t\t\tpr_cont(\" INIT\");\n\t\t\tif (csr0 & ERR)\n\t\t\t\tpr_cont(\" ERR\");\n\t\t\tif (csr0 & BABL)\n\t\t\t\tpr_cont(\" BABL\");\n\t\t\tif (csr0 & CERR)\n\t\t\t\tpr_cont(\" CERR\");\n\t\t\tif (csr0 & MISS)\n\t\t\t\tpr_cont(\" MISS\");\n\t\t\tif (csr0 & MERR)\n\t\t\t\tpr_cont(\" MERR\");\n\t\t\tif (csr0 & RINT)\n\t\t\t\tpr_cont(\" RINT\");\n\t\t\tif (csr0 & TINT)\n\t\t\t\tpr_cont(\" TINT\");\n\t\t\tif (csr0 & IDON)\n\t\t\t\tpr_cont(\" IDON\");\n\t\t\tpr_cont(\" ]\\n\");\n\t\t}\n#endif\n\n\t\tif (csr0 & RINT) {\t \n\t\t\thandled = 1;\n\t\t\tariadne_rx(dev);\n\t\t}\n\n\t\tif (csr0 & TINT) {\t \n\t\t\tint dirty_tx = priv->dirty_tx;\n\n\t\t\thandled = 1;\n\t\t\twhile (dirty_tx < priv->cur_tx) {\n\t\t\t\tint entry = dirty_tx % TX_RING_SIZE;\n\t\t\t\tint status = lowb(priv->tx_ring[entry]->TMD1);\n\n\t\t\t\tif (status & TF_OWN)\n\t\t\t\t\tbreak;\t \n\n\t\t\t\tpriv->tx_ring[entry]->TMD1 &= 0xff00;\n\n\t\t\t\tif (status & TF_ERR) {\n\t\t\t\t\t \n\t\t\t\t\tint err_status = priv->tx_ring[entry]->TMD3;\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\tif (err_status & EF_RTRY)\n\t\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\t\tif (err_status & EF_LCAR)\n\t\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\t\tif (err_status & EF_LCOL)\n\t\t\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\t\t\tif (err_status & EF_UFLO) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t\t\t \n\t\t\t\t\t\tnetdev_err(dev, \"Tx FIFO error! Status %04x\\n\",\n\t\t\t\t\t\t\t   csr0);\n\t\t\t\t\t\t \n\t\t\t\t\t\tlance->RDP = STRT;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (status & (TF_MORE | TF_ONE))\n\t\t\t\t\t\tdev->stats.collisions++;\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t}\n\t\t\t\tdirty_tx++;\n\t\t\t}\n\n#ifndef final_version\n\t\t\tif (priv->cur_tx - dirty_tx >= TX_RING_SIZE) {\n\t\t\t\tnetdev_err(dev, \"out-of-sync dirty pointer, %d vs. %d, full=%d\\n\",\n\t\t\t\t\t   dirty_tx, priv->cur_tx,\n\t\t\t\t\t   priv->tx_full);\n\t\t\t\tdirty_tx += TX_RING_SIZE;\n\t\t\t}\n#endif\n\n\t\t\tif (priv->tx_full && netif_queue_stopped(dev) &&\n\t\t\t    dirty_tx > priv->cur_tx - TX_RING_SIZE + 2) {\n\t\t\t\t \n\t\t\t\tpriv->tx_full = 0;\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\t}\n\n\t\t\tpriv->dirty_tx = dirty_tx;\n\t\t}\n\n\t\t \n\t\tif (csr0 & BABL) {\n\t\t\thandled = 1;\n\t\t\tdev->stats.tx_errors++;\t \n\t\t}\n\t\tif (csr0 & MISS) {\n\t\t\thandled = 1;\n\t\t\tdev->stats.rx_errors++;\t \n\t\t}\n\t\tif (csr0 & MERR) {\n\t\t\thandled = 1;\n\t\t\tnetdev_err(dev, \"Bus master arbitration failure, status %04x\\n\",\n\t\t\t\t   csr0);\n\t\t\t \n\t\t\tlance->RDP = STRT;\n\t\t}\n\t}\n\n\t \n\tlance->RAP = CSR0;\t\t \n\tlance->RDP = INEA | BABL | CERR | MISS | MERR | IDON;\n\n\tif (ariadne_debug > 4)\n\t\tnetdev_dbg(dev, \"exiting interrupt, csr%d=%#04x\\n\",\n\t\t\t   lance->RAP, lance->RDP);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int ariadne_open(struct net_device *dev)\n{\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\tu_short in;\n\tu_long version;\n\tint i;\n\n\t \n\tin = lance->Reset;\n\n\t \n\tlance->RAP = CSR0;\t\t \n\tlance->RDP = STOP;\n\n\t \n\tlance->RAP = CSR88;\t\t \n\tversion = swapw(lance->RDP);\n\tlance->RAP = CSR89;\t\t \n\tversion |= swapw(lance->RDP) << 16;\n\tif ((version & 0x00000fff) != 0x00000003) {\n\t\tpr_warn(\"Couldn't find AMD Ethernet Chip\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tif ((version & 0x0ffff000) != 0x00003000) {\n\t\tpr_warn(\"Couldn't find Am79C960 (Wrong part number = %ld)\\n\",\n\t\t       (version & 0x0ffff000) >> 12);\n\t\treturn -EAGAIN;\n\t}\n\n\tnetdev_dbg(dev, \"Am79C960 (PCnet-ISA) Revision %ld\\n\",\n\t\t   (version & 0xf0000000) >> 28);\n\n\tariadne_init_ring(dev);\n\n\t \n\tlance->RAP = CSR3;\t\t \n\tlance->RDP = 0x0000;\n\tlance->RAP = CSR4;\t\t \n\tlance->RDP = DPOLL | APAD_XMT | MFCOM | RCVCCOM | TXSTRTM | JABM;\n\n\t \n\tlance->RAP = CSR8;\t\t \n\tlance->RDP = 0x0000;\n\tlance->RAP = CSR9;\t\t \n\tlance->RDP = 0x0000;\n\tlance->RAP = CSR10;\t\t \n\tlance->RDP = 0x0000;\n\tlance->RAP = CSR11;\t\t \n\tlance->RDP = 0x0000;\n\n\t \n\tlance->RAP = CSR12;\t\t \n\tlance->RDP = ((const u_short *)&dev->dev_addr[0])[0];\n\tlance->RAP = CSR13;\t\t \n\tlance->RDP = ((const u_short *)&dev->dev_addr[0])[1];\n\tlance->RAP = CSR14;\t\t \n\tlance->RDP = ((const u_short *)&dev->dev_addr[0])[2];\n\n\t \n\tlance->RAP = CSR15;\t\t \n\tlance->RDP = 0x0000;\n\n\t \n\tlance->RAP = CSR30;\t\t \n\tlance->RDP = swloww(ARIADNE_RAM + offsetof(struct lancedata, tx_ring));\n\tlance->RAP = CSR31;\t\t \n\tlance->RDP = swhighw(ARIADNE_RAM + offsetof(struct lancedata, tx_ring));\n\n\t \n\tlance->RAP = CSR24;\t\t \n\tlance->RDP = swloww(ARIADNE_RAM + offsetof(struct lancedata, rx_ring));\n\tlance->RAP = CSR25;\t\t \n\tlance->RDP = swhighw(ARIADNE_RAM + offsetof(struct lancedata, rx_ring));\n\n\t \n\tlance->RAP = CSR76;\t\t \n\tlance->RDP = swapw(((u_short)-RX_RING_SIZE));\n\tlance->RAP = CSR78;\t\t \n\tlance->RDP = swapw(((u_short)-TX_RING_SIZE));\n\n\t \n\tlance->RAP = ISACSR2;\t\t \n\tlance->IDP = ASEL;\n\n\t \n\tlance->RAP = ISACSR5;\t\t \n\tlance->IDP = PSE|XMTE;\n\tlance->RAP = ISACSR6;\t \n\tlance->IDP = PSE|COLE;\n\tlance->RAP = ISACSR7;\t \n\tlance->IDP = PSE|RCVE;\n\n\tnetif_start_queue(dev);\n\n\ti = request_irq(IRQ_AMIGA_PORTS, ariadne_interrupt, IRQF_SHARED,\n\t\t\tdev->name, dev);\n\tif (i)\n\t\treturn i;\n\n\tlance->RAP = CSR0;\t\t \n\tlance->RDP = INEA | STRT;\n\n\treturn 0;\n}\n\nstatic int ariadne_close(struct net_device *dev)\n{\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\n\tnetif_stop_queue(dev);\n\n\tlance->RAP = CSR112;\t\t \n\tdev->stats.rx_missed_errors = swapw(lance->RDP);\n\tlance->RAP = CSR0;\t\t \n\n\tif (ariadne_debug > 1) {\n\t\tnetdev_dbg(dev, \"Shutting down ethercard, status was %02x\\n\",\n\t\t\t   lance->RDP);\n\t\tnetdev_dbg(dev, \"%lu packets missed\\n\",\n\t\t\t   dev->stats.rx_missed_errors);\n\t}\n\n\t \n\tlance->RDP = STOP;\n\n\tfree_irq(IRQ_AMIGA_PORTS, dev);\n\n\treturn 0;\n}\n\nstatic inline void ariadne_reset(struct net_device *dev)\n{\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\n\tlance->RAP = CSR0;\t \n\tlance->RDP = STOP;\n\tariadne_init_ring(dev);\n\tlance->RDP = INEA | STRT;\n\tnetif_start_queue(dev);\n}\n\nstatic void ariadne_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\n\tnetdev_err(dev, \"transmit timed out, status %04x, resetting\\n\",\n\t\t   lance->RDP);\n\tariadne_reset(dev);\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t ariadne_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct ariadne_private *priv = netdev_priv(dev);\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\tint entry;\n\tunsigned long flags;\n\tint len = skb->len;\n\n#if 0\n\tif (ariadne_debug > 3) {\n\t\tlance->RAP = CSR0;\t \n\t\tnetdev_dbg(dev, \"%s: csr0 %04x\\n\", __func__, lance->RDP);\n\t\tlance->RDP = 0x0000;\n\t}\n#endif\n\n\t \n\tif (skb->len < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\treturn NETDEV_TX_OK;\n\t\tlen = ETH_ZLEN;\n\t}\n\n\t \n\n\tnetdev_dbg(dev, \"TX pkt type 0x%04x from %pM to %pM data %p len %u\\n\",\n\t\t   ((u_short *)skb->data)[6],\n\t\t   skb->data + 6, skb->data,\n\t\t   skb->data, skb->len);\n\n\tlocal_irq_save(flags);\n\n\tentry = priv->cur_tx % TX_RING_SIZE;\n\n\t \n\n\tpriv->tx_ring[entry]->TMD2 = swapw((u_short)-skb->len);\n\tpriv->tx_ring[entry]->TMD3 = 0x0000;\n\tmemcpyw(priv->tx_buff[entry], (u_short *)skb->data, len);\n\n#ifdef DEBUG\n\tprint_hex_dump(KERN_DEBUG, \"tx_buff: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       (void *)priv->tx_buff[entry],\n\t\t       skb->len > 64 ? 64 : skb->len, true);\n#endif\n\n\tpriv->tx_ring[entry]->TMD1 = (priv->tx_ring[entry]->TMD1 & 0xff00)\n\t\t| TF_OWN | TF_STP | TF_ENP;\n\n\tdev_kfree_skb(skb);\n\n\tpriv->cur_tx++;\n\tif ((priv->cur_tx >= TX_RING_SIZE) &&\n\t    (priv->dirty_tx >= TX_RING_SIZE)) {\n\n\t\tnetdev_dbg(dev, \"*** Subtracting TX_RING_SIZE from cur_tx (%d) and dirty_tx (%d)\\n\",\n\t\t\t   priv->cur_tx, priv->dirty_tx);\n\n\t\tpriv->cur_tx -= TX_RING_SIZE;\n\t\tpriv->dirty_tx -= TX_RING_SIZE;\n\t}\n\tdev->stats.tx_bytes += len;\n\n\t \n\tlance->RAP = CSR0;\t\t \n\tlance->RDP = INEA | TDMD;\n\n\tif (lowb(priv->tx_ring[(entry + 1) % TX_RING_SIZE]->TMD1) != 0) {\n\t\tnetif_stop_queue(dev);\n\t\tpriv->tx_full = 1;\n\t}\n\tlocal_irq_restore(flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct net_device_stats *ariadne_get_stats(struct net_device *dev)\n{\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\tshort saved_addr;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tsaved_addr = lance->RAP;\n\tlance->RAP = CSR112;\t\t \n\tdev->stats.rx_missed_errors = swapw(lance->RDP);\n\tlance->RAP = saved_addr;\n\tlocal_irq_restore(flags);\n\n\treturn &dev->stats;\n}\n\n \nstatic void set_multicast_list(struct net_device *dev)\n{\n\tvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tnetif_stop_queue(dev);\n\n\t \n\tlance->RAP = CSR0;\t\t \n\tlance->RDP = STOP;\t\t \n\tariadne_init_ring(dev);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tlance->RAP = CSR15;\t \n\t\tlance->RDP = PROM;\t \n\t} else {\n\t\tshort multicast_table[4];\n\t\tint num_addrs = netdev_mc_count(dev);\n\t\tint i;\n\t\t \n\t\tmemset(multicast_table, (num_addrs == 0) ? 0 : -1,\n\t\t       sizeof(multicast_table));\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tlance->RAP = CSR8 + (i << 8);\n\t\t\t\t\t \n\t\t\tlance->RDP = swapw(multicast_table[i]);\n\t\t}\n\t\tlance->RAP = CSR15;\t \n\t\tlance->RDP = 0x0000;\t \n\t}\n\n\tlance->RAP = CSR0;\t\t \n\tlance->RDP = INEA | STRT | IDON; \n\n\tnetif_wake_queue(dev);\n}\n\n\nstatic void ariadne_remove_one(struct zorro_dev *z)\n{\n\tstruct net_device *dev = zorro_get_drvdata(z);\n\n\tunregister_netdev(dev);\n\trelease_mem_region(ZTWO_PADDR(dev->base_addr), sizeof(struct Am79C960));\n\trelease_mem_region(ZTWO_PADDR(dev->mem_start), ARIADNE_RAM_SIZE);\n\tfree_netdev(dev);\n}\n\nstatic const struct zorro_device_id ariadne_zorro_tbl[] = {\n\t{ ZORRO_PROD_VILLAGE_TRONIC_ARIADNE },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, ariadne_zorro_tbl);\n\nstatic const struct net_device_ops ariadne_netdev_ops = {\n\t.ndo_open\t\t= ariadne_open,\n\t.ndo_stop\t\t= ariadne_close,\n\t.ndo_start_xmit\t\t= ariadne_start_xmit,\n\t.ndo_tx_timeout\t\t= ariadne_tx_timeout,\n\t.ndo_get_stats\t\t= ariadne_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int ariadne_init_one(struct zorro_dev *z,\n\t\t\t    const struct zorro_device_id *ent)\n{\n\tunsigned long board = z->resource.start;\n\tunsigned long base_addr = board + ARIADNE_LANCE;\n\tunsigned long mem_start = board + ARIADNE_RAM;\n\tstruct resource *r1, *r2;\n\tstruct net_device *dev;\n\tu8 addr[ETH_ALEN];\n\tu32 serial;\n\tint err;\n\n\tr1 = request_mem_region(base_addr, sizeof(struct Am79C960), \"Am79C960\");\n\tif (!r1)\n\t\treturn -EBUSY;\n\tr2 = request_mem_region(mem_start, ARIADNE_RAM_SIZE, \"RAM\");\n\tif (!r2) {\n\t\trelease_mem_region(base_addr, sizeof(struct Am79C960));\n\t\treturn -EBUSY;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct ariadne_private));\n\tif (!dev) {\n\t\trelease_mem_region(base_addr, sizeof(struct Am79C960));\n\t\trelease_mem_region(mem_start, ARIADNE_RAM_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\tr1->name = dev->name;\n\tr2->name = dev->name;\n\n\tserial = be32_to_cpu(z->rom.er_SerialNumber);\n\taddr[0] = 0x00;\n\taddr[1] = 0x60;\n\taddr[2] = 0x30;\n\taddr[3] = (serial >> 16) & 0xff;\n\taddr[4] = (serial >> 8) & 0xff;\n\taddr[5] = serial & 0xff;\n\teth_hw_addr_set(dev, addr);\n\tdev->base_addr = (unsigned long)ZTWO_VADDR(base_addr);\n\tdev->mem_start = (unsigned long)ZTWO_VADDR(mem_start);\n\tdev->mem_end = dev->mem_start + ARIADNE_RAM_SIZE;\n\n\tdev->netdev_ops = &ariadne_netdev_ops;\n\tdev->watchdog_timeo = 5 * HZ;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\trelease_mem_region(base_addr, sizeof(struct Am79C960));\n\t\trelease_mem_region(mem_start, ARIADNE_RAM_SIZE);\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\tzorro_set_drvdata(z, dev);\n\n\tnetdev_info(dev, \"Ariadne at 0x%08lx, Ethernet Address %pM\\n\",\n\t\t    board, dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic struct zorro_driver ariadne_driver = {\n\t.name\t\t= \"ariadne\",\n\t.id_table\t= ariadne_zorro_tbl,\n\t.probe\t\t= ariadne_init_one,\n\t.remove\t\t= ariadne_remove_one,\n};\n\nstatic int __init ariadne_init_module(void)\n{\n\treturn zorro_register_driver(&ariadne_driver);\n}\n\nstatic void __exit ariadne_cleanup_module(void)\n{\n\tzorro_unregister_driver(&ariadne_driver);\n}\n\nmodule_init(ariadne_init_module);\nmodule_exit(ariadne_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}