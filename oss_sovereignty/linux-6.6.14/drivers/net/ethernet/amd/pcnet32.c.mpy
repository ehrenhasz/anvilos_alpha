{
  "module_name": "pcnet32.c",
  "hash_id": "ef2c2ac90f87d40c0566959351040bf66ae269152632889d93651455b875a980",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amd/pcnet32.c",
  "human_readable_source": " \n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"pcnet32\"\n#define DRV_RELDATE\t\"21.Apr.2008\"\n#define PFX\t\tDRV_NAME \": \"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/moduleparam.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\n \nstatic const struct pci_device_id pcnet32_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LANCE_HOME), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LANCE), },\n\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_TRIDENT, PCI_DEVICE_ID_AMD_LANCE),\n\t  .class = (PCI_CLASS_NETWORK_ETHERNET << 8), .class_mask = 0xffff00, },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(pci, pcnet32_pci_tbl);\n\nstatic int cards_found;\n\n \nstatic unsigned int pcnet32_portlist[] =\n    { 0x300, 0x320, 0x340, 0x360, 0 };\n\nstatic int pcnet32_debug;\nstatic int tx_start = 1;\t \nstatic int pcnet32vlb;\t\t \n\nstatic struct net_device *pcnet32_dev;\n\nstatic int max_interrupt_work = 2;\nstatic int rx_copybreak = 200;\n\n#define PCNET32_PORT_AUI      0x00\n#define PCNET32_PORT_10BT     0x01\n#define PCNET32_PORT_GPSI     0x02\n#define PCNET32_PORT_MII      0x03\n\n#define PCNET32_PORT_PORTSEL  0x03\n#define PCNET32_PORT_ASEL     0x04\n#define PCNET32_PORT_100      0x40\n#define PCNET32_PORT_FD\t      0x80\n\n#define PCNET32_DMA_MASK 0xffffffff\n\n#define PCNET32_WATCHDOG_TIMEOUT (jiffies + (2 * HZ))\n#define PCNET32_BLINK_TIMEOUT\t(jiffies + (HZ/4))\n\n \nstatic const unsigned char options_mapping[] = {\n\tPCNET32_PORT_ASEL,\t\t\t \n\tPCNET32_PORT_AUI,\t\t\t \n\tPCNET32_PORT_AUI,\t\t\t \n\tPCNET32_PORT_ASEL,\t\t\t \n\tPCNET32_PORT_10BT | PCNET32_PORT_FD,\t \n\tPCNET32_PORT_ASEL,\t\t\t \n\tPCNET32_PORT_ASEL,\t\t\t \n\tPCNET32_PORT_ASEL,\t\t\t \n\tPCNET32_PORT_ASEL,\t\t\t \n\tPCNET32_PORT_MII,\t\t\t \n\tPCNET32_PORT_MII | PCNET32_PORT_FD,\t \n\tPCNET32_PORT_MII,\t\t\t \n\tPCNET32_PORT_10BT,\t\t\t \n\tPCNET32_PORT_MII | PCNET32_PORT_100,\t \n\t\t\t\t\t\t \n\tPCNET32_PORT_MII | PCNET32_PORT_100 | PCNET32_PORT_FD,\n\tPCNET32_PORT_ASEL\t\t\t \n};\n\nstatic const char pcnet32_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Loopback test  (offline)\"\n};\n\n#define PCNET32_TEST_LEN\tARRAY_SIZE(pcnet32_gstrings_test)\n\n#define PCNET32_NUM_REGS 136\n\n#define MAX_UNITS 8\t\t \nstatic int options[MAX_UNITS];\nstatic int full_duplex[MAX_UNITS];\nstatic int homepna[MAX_UNITS];\n\n \n\n \n#ifndef PCNET32_LOG_TX_BUFFERS\n#define PCNET32_LOG_TX_BUFFERS\t\t4\n#define PCNET32_LOG_RX_BUFFERS\t\t5\n#define PCNET32_LOG_MAX_TX_BUFFERS\t9\t \n#define PCNET32_LOG_MAX_RX_BUFFERS\t9\n#endif\n\n#define TX_RING_SIZE\t\t(1 << (PCNET32_LOG_TX_BUFFERS))\n#define TX_MAX_RING_SIZE\t(1 << (PCNET32_LOG_MAX_TX_BUFFERS))\n\n#define RX_RING_SIZE\t\t(1 << (PCNET32_LOG_RX_BUFFERS))\n#define RX_MAX_RING_SIZE\t(1 << (PCNET32_LOG_MAX_RX_BUFFERS))\n\n#define PKT_BUF_SKB\t\t1544\n \n#define PKT_BUF_SIZE\t\t(PKT_BUF_SKB - NET_IP_ALIGN)\n \n#define NEG_BUF_SIZE\t\t(NET_IP_ALIGN - PKT_BUF_SKB)\n\n \n#define PCNET32_WIO_RDP\t\t0x10\n#define PCNET32_WIO_RAP\t\t0x12\n#define PCNET32_WIO_RESET\t0x14\n#define PCNET32_WIO_BDP\t\t0x16\n\n#define PCNET32_DWIO_RDP\t0x10\n#define PCNET32_DWIO_RAP\t0x14\n#define PCNET32_DWIO_RESET\t0x18\n#define PCNET32_DWIO_BDP\t0x1C\n\n#define PCNET32_TOTAL_SIZE\t0x20\n\n#define CSR0\t\t0\n#define CSR0_INIT\t0x1\n#define CSR0_START\t0x2\n#define CSR0_STOP\t0x4\n#define CSR0_TXPOLL\t0x8\n#define CSR0_INTEN\t0x40\n#define CSR0_IDON\t0x0100\n#define CSR0_NORMAL\t(CSR0_START | CSR0_INTEN)\n#define PCNET32_INIT_LOW\t1\n#define PCNET32_INIT_HIGH\t2\n#define CSR3\t\t3\n#define CSR4\t\t4\n#define CSR5\t\t5\n#define CSR5_SUSPEND\t0x0001\n#define CSR15\t\t15\n#define PCNET32_MC_FILTER\t8\n\n#define PCNET32_79C970A\t0x2621\n\n \nstruct pcnet32_rx_head {\n\t__le32\tbase;\n\t__le16\tbuf_length;\t \n\t__le16\tstatus;\n\t__le32\tmsg_length;\n\t__le32\treserved;\n};\n\nstruct pcnet32_tx_head {\n\t__le32\tbase;\n\t__le16\tlength;\t\t \n\t__le16\tstatus;\n\t__le32\tmisc;\n\t__le32\treserved;\n};\n\n \nstruct pcnet32_init_block {\n\t__le16\tmode;\n\t__le16\ttlen_rlen;\n\tu8\tphys_addr[6];\n\t__le16\treserved;\n\t__le32\tfilter[2];\n\t \n\t__le32\trx_ring;\n\t__le32\ttx_ring;\n};\n\n \nstruct pcnet32_access {\n\tu16\t(*read_csr) (unsigned long, int);\n\tvoid\t(*write_csr) (unsigned long, int, u16);\n\tu16\t(*read_bcr) (unsigned long, int);\n\tvoid\t(*write_bcr) (unsigned long, int, u16);\n\tu16\t(*read_rap) (unsigned long);\n\tvoid\t(*write_rap) (unsigned long, u16);\n\tvoid\t(*reset) (unsigned long);\n};\n\n \nstruct pcnet32_private {\n\tstruct pcnet32_init_block *init_block;\n\t \n\tstruct pcnet32_rx_head\t*rx_ring;\n\tstruct pcnet32_tx_head\t*tx_ring;\n\tdma_addr_t\t\tinit_dma_addr; \n\tstruct pci_dev\t\t*pci_dev;\n\tconst char\t\t*name;\n\t \n\tstruct sk_buff\t\t**tx_skbuff;\n\tstruct sk_buff\t\t**rx_skbuff;\n\tdma_addr_t\t\t*tx_dma_addr;\n\tdma_addr_t\t\t*rx_dma_addr;\n\tconst struct pcnet32_access *a;\n\tspinlock_t\t\tlock;\t\t \n\tunsigned int\t\tcur_rx, cur_tx;\t \n\tunsigned int\t\trx_ring_size;\t \n\tunsigned int\t\ttx_ring_size;\t \n\tunsigned int\t\trx_mod_mask;\t \n\tunsigned int\t\ttx_mod_mask;\t \n\tunsigned short\t\trx_len_bits;\n\tunsigned short\t\ttx_len_bits;\n\tdma_addr_t\t\trx_ring_dma_addr;\n\tdma_addr_t\t\ttx_ring_dma_addr;\n\tunsigned int\t\tdirty_rx,\t \n\t\t\t\tdirty_tx;\n\n\tstruct net_device\t*dev;\n\tstruct napi_struct\tnapi;\n\tchar\t\t\ttx_full;\n\tchar\t\t\tphycount;\t \n\tint\t\t\toptions;\n\tunsigned int\t\tshared_irq:1,\t \n\t\t\t\tdxsuflo:1,    \n\t\t\t\tmii:1,\t\t \n\t\t\t\tautoneg:1,\t \n\t\t\t\tport_tp:1,\t \n\t\t\t\tfdx:1;\t\t \n\tstruct net_device\t*next;\n\tstruct mii_if_info\tmii_if;\n\tstruct timer_list\twatchdog_timer;\n\tu32\t\t\tmsg_enable;\t \n\n\t \n\tu32\t\t\tphymask;\n\tunsigned short\t\tchip_version;\t \n\n\t \n\tu16 \t\t\tsave_regs[4];\n};\n\nstatic int pcnet32_probe_pci(struct pci_dev *, const struct pci_device_id *);\nstatic int pcnet32_probe1(unsigned long, int, struct pci_dev *);\nstatic int pcnet32_open(struct net_device *);\nstatic int pcnet32_init_ring(struct net_device *);\nstatic netdev_tx_t pcnet32_start_xmit(struct sk_buff *,\n\t\t\t\t      struct net_device *);\nstatic void pcnet32_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic irqreturn_t pcnet32_interrupt(int, void *);\nstatic int pcnet32_close(struct net_device *);\nstatic struct net_device_stats *pcnet32_get_stats(struct net_device *);\nstatic void pcnet32_load_multicast(struct net_device *dev);\nstatic void pcnet32_set_multicast_list(struct net_device *);\nstatic int pcnet32_ioctl(struct net_device *, struct ifreq *, int);\nstatic void pcnet32_watchdog(struct timer_list *);\nstatic int mdio_read(struct net_device *dev, int phy_id, int reg_num);\nstatic void mdio_write(struct net_device *dev, int phy_id, int reg_num,\n\t\t       int val);\nstatic void pcnet32_restart(struct net_device *dev, unsigned int csr0_bits);\nstatic void pcnet32_ethtool_test(struct net_device *dev,\n\t\t\t\t struct ethtool_test *eth_test, u64 * data);\nstatic int pcnet32_loopback_test(struct net_device *dev, uint64_t * data1);\nstatic int pcnet32_get_regs_len(struct net_device *dev);\nstatic void pcnet32_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t     void *ptr);\nstatic void pcnet32_purge_tx_ring(struct net_device *dev);\nstatic int pcnet32_alloc_ring(struct net_device *dev, const char *name);\nstatic void pcnet32_free_ring(struct net_device *dev);\nstatic void pcnet32_check_media(struct net_device *dev, int verbose);\n\nstatic u16 pcnet32_wio_read_csr(unsigned long addr, int index)\n{\n\toutw(index, addr + PCNET32_WIO_RAP);\n\treturn inw(addr + PCNET32_WIO_RDP);\n}\n\nstatic void pcnet32_wio_write_csr(unsigned long addr, int index, u16 val)\n{\n\toutw(index, addr + PCNET32_WIO_RAP);\n\toutw(val, addr + PCNET32_WIO_RDP);\n}\n\nstatic u16 pcnet32_wio_read_bcr(unsigned long addr, int index)\n{\n\toutw(index, addr + PCNET32_WIO_RAP);\n\treturn inw(addr + PCNET32_WIO_BDP);\n}\n\nstatic void pcnet32_wio_write_bcr(unsigned long addr, int index, u16 val)\n{\n\toutw(index, addr + PCNET32_WIO_RAP);\n\toutw(val, addr + PCNET32_WIO_BDP);\n}\n\nstatic u16 pcnet32_wio_read_rap(unsigned long addr)\n{\n\treturn inw(addr + PCNET32_WIO_RAP);\n}\n\nstatic void pcnet32_wio_write_rap(unsigned long addr, u16 val)\n{\n\toutw(val, addr + PCNET32_WIO_RAP);\n}\n\nstatic void pcnet32_wio_reset(unsigned long addr)\n{\n\tinw(addr + PCNET32_WIO_RESET);\n}\n\nstatic int pcnet32_wio_check(unsigned long addr)\n{\n\toutw(88, addr + PCNET32_WIO_RAP);\n\treturn inw(addr + PCNET32_WIO_RAP) == 88;\n}\n\nstatic const struct pcnet32_access pcnet32_wio = {\n\t.read_csr = pcnet32_wio_read_csr,\n\t.write_csr = pcnet32_wio_write_csr,\n\t.read_bcr = pcnet32_wio_read_bcr,\n\t.write_bcr = pcnet32_wio_write_bcr,\n\t.read_rap = pcnet32_wio_read_rap,\n\t.write_rap = pcnet32_wio_write_rap,\n\t.reset = pcnet32_wio_reset\n};\n\nstatic u16 pcnet32_dwio_read_csr(unsigned long addr, int index)\n{\n\toutl(index, addr + PCNET32_DWIO_RAP);\n\treturn inl(addr + PCNET32_DWIO_RDP) & 0xffff;\n}\n\nstatic void pcnet32_dwio_write_csr(unsigned long addr, int index, u16 val)\n{\n\toutl(index, addr + PCNET32_DWIO_RAP);\n\toutl(val, addr + PCNET32_DWIO_RDP);\n}\n\nstatic u16 pcnet32_dwio_read_bcr(unsigned long addr, int index)\n{\n\toutl(index, addr + PCNET32_DWIO_RAP);\n\treturn inl(addr + PCNET32_DWIO_BDP) & 0xffff;\n}\n\nstatic void pcnet32_dwio_write_bcr(unsigned long addr, int index, u16 val)\n{\n\toutl(index, addr + PCNET32_DWIO_RAP);\n\toutl(val, addr + PCNET32_DWIO_BDP);\n}\n\nstatic u16 pcnet32_dwio_read_rap(unsigned long addr)\n{\n\treturn inl(addr + PCNET32_DWIO_RAP) & 0xffff;\n}\n\nstatic void pcnet32_dwio_write_rap(unsigned long addr, u16 val)\n{\n\toutl(val, addr + PCNET32_DWIO_RAP);\n}\n\nstatic void pcnet32_dwio_reset(unsigned long addr)\n{\n\tinl(addr + PCNET32_DWIO_RESET);\n}\n\nstatic int pcnet32_dwio_check(unsigned long addr)\n{\n\toutl(88, addr + PCNET32_DWIO_RAP);\n\treturn (inl(addr + PCNET32_DWIO_RAP) & 0xffff) == 88;\n}\n\nstatic const struct pcnet32_access pcnet32_dwio = {\n\t.read_csr = pcnet32_dwio_read_csr,\n\t.write_csr = pcnet32_dwio_write_csr,\n\t.read_bcr = pcnet32_dwio_read_bcr,\n\t.write_bcr = pcnet32_dwio_write_bcr,\n\t.read_rap = pcnet32_dwio_read_rap,\n\t.write_rap = pcnet32_dwio_write_rap,\n\t.reset = pcnet32_dwio_reset\n};\n\nstatic void pcnet32_netif_stop(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\n\tnetif_trans_update(dev);  \n\tnapi_disable(&lp->napi);\n\tnetif_tx_disable(dev);\n}\n\nstatic void pcnet32_netif_start(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tulong ioaddr = dev->base_addr;\n\tu16 val;\n\n\tnetif_wake_queue(dev);\n\tval = lp->a->read_csr(ioaddr, CSR3);\n\tval &= 0x00ff;\n\tlp->a->write_csr(ioaddr, CSR3, val);\n\tnapi_enable(&lp->napi);\n}\n\n \nstatic void pcnet32_realloc_tx_ring(struct net_device *dev,\n\t\t\t\t    struct pcnet32_private *lp,\n\t\t\t\t    unsigned int size)\n{\n\tdma_addr_t new_ring_dma_addr;\n\tdma_addr_t *new_dma_addr_list;\n\tstruct pcnet32_tx_head *new_tx_ring;\n\tstruct sk_buff **new_skb_list;\n\tunsigned int entries = BIT(size);\n\n\tpcnet32_purge_tx_ring(dev);\n\n\tnew_tx_ring =\n\t\tdma_alloc_coherent(&lp->pci_dev->dev,\n\t\t\t\t   sizeof(struct pcnet32_tx_head) * entries,\n\t\t\t\t   &new_ring_dma_addr, GFP_ATOMIC);\n\tif (!new_tx_ring)\n\t\treturn;\n\n\tnew_dma_addr_list = kcalloc(entries, sizeof(dma_addr_t), GFP_ATOMIC);\n\tif (!new_dma_addr_list)\n\t\tgoto free_new_tx_ring;\n\n\tnew_skb_list = kcalloc(entries, sizeof(struct sk_buff *), GFP_ATOMIC);\n\tif (!new_skb_list)\n\t\tgoto free_new_lists;\n\n\tkfree(lp->tx_skbuff);\n\tkfree(lp->tx_dma_addr);\n\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t  sizeof(struct pcnet32_tx_head) * lp->tx_ring_size,\n\t\t\t  lp->tx_ring, lp->tx_ring_dma_addr);\n\n\tlp->tx_ring_size = entries;\n\tlp->tx_mod_mask = lp->tx_ring_size - 1;\n\tlp->tx_len_bits = (size << 12);\n\tlp->tx_ring = new_tx_ring;\n\tlp->tx_ring_dma_addr = new_ring_dma_addr;\n\tlp->tx_dma_addr = new_dma_addr_list;\n\tlp->tx_skbuff = new_skb_list;\n\treturn;\n\nfree_new_lists:\n\tkfree(new_dma_addr_list);\nfree_new_tx_ring:\n\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t  sizeof(struct pcnet32_tx_head) * entries,\n\t\t\t  new_tx_ring, new_ring_dma_addr);\n}\n\n \nstatic void pcnet32_realloc_rx_ring(struct net_device *dev,\n\t\t\t\t    struct pcnet32_private *lp,\n\t\t\t\t    unsigned int size)\n{\n\tdma_addr_t new_ring_dma_addr;\n\tdma_addr_t *new_dma_addr_list;\n\tstruct pcnet32_rx_head *new_rx_ring;\n\tstruct sk_buff **new_skb_list;\n\tint new, overlap;\n\tunsigned int entries = BIT(size);\n\n\tnew_rx_ring =\n\t\tdma_alloc_coherent(&lp->pci_dev->dev,\n\t\t\t\t   sizeof(struct pcnet32_rx_head) * entries,\n\t\t\t\t   &new_ring_dma_addr, GFP_ATOMIC);\n\tif (!new_rx_ring)\n\t\treturn;\n\n\tnew_dma_addr_list = kcalloc(entries, sizeof(dma_addr_t), GFP_ATOMIC);\n\tif (!new_dma_addr_list)\n\t\tgoto free_new_rx_ring;\n\n\tnew_skb_list = kcalloc(entries, sizeof(struct sk_buff *), GFP_ATOMIC);\n\tif (!new_skb_list)\n\t\tgoto free_new_lists;\n\n\t \n\toverlap = min(entries, lp->rx_ring_size);\n\tfor (new = 0; new < overlap; new++) {\n\t\tnew_rx_ring[new] = lp->rx_ring[new];\n\t\tnew_dma_addr_list[new] = lp->rx_dma_addr[new];\n\t\tnew_skb_list[new] = lp->rx_skbuff[new];\n\t}\n\t \n\tfor (; new < entries; new++) {\n\t\tstruct sk_buff *rx_skbuff;\n\t\tnew_skb_list[new] = netdev_alloc_skb(dev, PKT_BUF_SKB);\n\t\trx_skbuff = new_skb_list[new];\n\t\tif (!rx_skbuff) {\n\t\t\t \n\t\t\tnetif_err(lp, drv, dev, \"%s netdev_alloc_skb failed\\n\",\n\t\t\t\t  __func__);\n\t\t\tgoto free_all_new;\n\t\t}\n\t\tskb_reserve(rx_skbuff, NET_IP_ALIGN);\n\n\t\tnew_dma_addr_list[new] =\n\t\t\t    dma_map_single(&lp->pci_dev->dev, rx_skbuff->data,\n\t\t\t\t\t   PKT_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&lp->pci_dev->dev, new_dma_addr_list[new])) {\n\t\t\tnetif_err(lp, drv, dev, \"%s dma mapping failed\\n\",\n\t\t\t\t  __func__);\n\t\t\tdev_kfree_skb(new_skb_list[new]);\n\t\t\tgoto free_all_new;\n\t\t}\n\t\tnew_rx_ring[new].base = cpu_to_le32(new_dma_addr_list[new]);\n\t\tnew_rx_ring[new].buf_length = cpu_to_le16(NEG_BUF_SIZE);\n\t\tnew_rx_ring[new].status = cpu_to_le16(0x8000);\n\t}\n\t \n\tfor (; new < lp->rx_ring_size; new++) {\n\t\tif (lp->rx_skbuff[new]) {\n\t\t\tif (!dma_mapping_error(&lp->pci_dev->dev, lp->rx_dma_addr[new]))\n\t\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t lp->rx_dma_addr[new],\n\t\t\t\t\t\t PKT_BUF_SIZE,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(lp->rx_skbuff[new]);\n\t\t}\n\t}\n\n\tkfree(lp->rx_skbuff);\n\tkfree(lp->rx_dma_addr);\n\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t  sizeof(struct pcnet32_rx_head) * lp->rx_ring_size,\n\t\t\t  lp->rx_ring, lp->rx_ring_dma_addr);\n\n\tlp->rx_ring_size = entries;\n\tlp->rx_mod_mask = lp->rx_ring_size - 1;\n\tlp->rx_len_bits = (size << 4);\n\tlp->rx_ring = new_rx_ring;\n\tlp->rx_ring_dma_addr = new_ring_dma_addr;\n\tlp->rx_dma_addr = new_dma_addr_list;\n\tlp->rx_skbuff = new_skb_list;\n\treturn;\n\nfree_all_new:\n\twhile (--new >= lp->rx_ring_size) {\n\t\tif (new_skb_list[new]) {\n\t\t\tif (!dma_mapping_error(&lp->pci_dev->dev, new_dma_addr_list[new]))\n\t\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t new_dma_addr_list[new],\n\t\t\t\t\t\t PKT_BUF_SIZE,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(new_skb_list[new]);\n\t\t}\n\t}\n\tkfree(new_skb_list);\nfree_new_lists:\n\tkfree(new_dma_addr_list);\nfree_new_rx_ring:\n\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t  sizeof(struct pcnet32_rx_head) * entries,\n\t\t\t  new_rx_ring, new_ring_dma_addr);\n}\n\nstatic void pcnet32_purge_rx_ring(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < lp->rx_ring_size; i++) {\n\t\tlp->rx_ring[i].status = 0;\t \n\t\twmb();\t\t \n\t\tif (lp->rx_skbuff[i]) {\n\t\t\tif (!dma_mapping_error(&lp->pci_dev->dev, lp->rx_dma_addr[i]))\n\t\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t lp->rx_dma_addr[i],\n\t\t\t\t\t\t PKT_BUF_SIZE,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(lp->rx_skbuff[i]);\n\t\t}\n\t\tlp->rx_skbuff[i] = NULL;\n\t\tlp->rx_dma_addr[i] = 0;\n\t}\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void pcnet32_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tpcnet32_interrupt(0, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \nstatic int pcnet32_suspend(struct net_device *dev, unsigned long *flags,\n\t\t\t   int can_sleep)\n{\n\tint csr5;\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tconst struct pcnet32_access *a = lp->a;\n\tulong ioaddr = dev->base_addr;\n\tint ticks;\n\n\t \n\tif (lp->chip_version < PCNET32_79C970A)\n\t\treturn 0;\n\n\t \n\tcsr5 = a->read_csr(ioaddr, CSR5);\n\ta->write_csr(ioaddr, CSR5, csr5 | CSR5_SUSPEND);\n\n\t \n\tticks = 0;\n\twhile (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {\n\t\tspin_unlock_irqrestore(&lp->lock, *flags);\n\t\tif (can_sleep)\n\t\t\tmsleep(1);\n\t\telse\n\t\t\tmdelay(1);\n\t\tspin_lock_irqsave(&lp->lock, *flags);\n\t\tticks++;\n\t\tif (ticks > 200) {\n\t\t\tnetif_printk(lp, hw, KERN_DEBUG, dev,\n\t\t\t\t     \"Error getting into suspend!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void pcnet32_clr_suspend(struct pcnet32_private *lp, ulong ioaddr)\n{\n\tint csr5 = lp->a->read_csr(ioaddr, CSR5);\n\t \n\tlp->a->write_csr(ioaddr, CSR5, csr5 & ~CSR5_SUSPEND);\n}\n\nstatic int pcnet32_get_link_ksettings(struct net_device *dev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (lp->mii) {\n\t\tmii_ethtool_get_link_ksettings(&lp->mii_if, cmd);\n\t} else if (lp->chip_version == PCNET32_79C970A) {\n\t\tif (lp->autoneg) {\n\t\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t\t\tif (lp->a->read_bcr(dev->base_addr, 4) == 0xc0)\n\t\t\t\tcmd->base.port = PORT_AUI;\n\t\t\telse\n\t\t\t\tcmd->base.port = PORT_TP;\n\t\t} else {\n\t\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\t\tcmd->base.port = lp->port_tp ? PORT_TP : PORT_AUI;\n\t\t}\n\t\tcmd->base.duplex = lp->fdx ? DUPLEX_FULL : DUPLEX_HALF;\n\t\tcmd->base.speed = SPEED_10;\n\t\tethtool_convert_legacy_u32_to_link_mode(\n\t\t\t\t\t\tcmd->link_modes.supported,\n\t\t\t\t\t\tSUPPORTED_TP | SUPPORTED_AUI);\n\t}\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn 0;\n}\n\nstatic int pcnet32_set_link_ksettings(struct net_device *dev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tulong ioaddr = dev->base_addr;\n\tunsigned long flags;\n\tint r = -EOPNOTSUPP;\n\tint suspended, bcr2, bcr9, csr15;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (lp->mii) {\n\t\tr = mii_ethtool_set_link_ksettings(&lp->mii_if, cmd);\n\t} else if (lp->chip_version == PCNET32_79C970A) {\n\t\tsuspended = pcnet32_suspend(dev, &flags, 0);\n\t\tif (!suspended)\n\t\t\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\n\n\t\tlp->autoneg = cmd->base.autoneg == AUTONEG_ENABLE;\n\t\tbcr2 = lp->a->read_bcr(ioaddr, 2);\n\t\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\t\tlp->a->write_bcr(ioaddr, 2, bcr2 | 0x0002);\n\t\t} else {\n\t\t\tlp->a->write_bcr(ioaddr, 2, bcr2 & ~0x0002);\n\n\t\t\tlp->port_tp = cmd->base.port == PORT_TP;\n\t\t\tcsr15 = lp->a->read_csr(ioaddr, CSR15) & ~0x0180;\n\t\t\tif (cmd->base.port == PORT_TP)\n\t\t\t\tcsr15 |= 0x0080;\n\t\t\tlp->a->write_csr(ioaddr, CSR15, csr15);\n\t\t\tlp->init_block->mode = cpu_to_le16(csr15);\n\n\t\t\tlp->fdx = cmd->base.duplex == DUPLEX_FULL;\n\t\t\tbcr9 = lp->a->read_bcr(ioaddr, 9) & ~0x0003;\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\t\tbcr9 |= 0x0003;\n\t\t\tlp->a->write_bcr(ioaddr, 9, bcr9);\n\t\t}\n\t\tif (suspended)\n\t\t\tpcnet32_clr_suspend(lp, ioaddr);\n\t\telse if (netif_running(dev))\n\t\t\tpcnet32_restart(dev, CSR0_NORMAL);\n\t\tr = 0;\n\t}\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn r;\n}\n\nstatic void pcnet32_get_drvinfo(struct net_device *dev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tif (lp->pci_dev)\n\t\tstrscpy(info->bus_info, pci_name(lp->pci_dev),\n\t\t\tsizeof(info->bus_info));\n\telse\n\t\tsnprintf(info->bus_info, sizeof(info->bus_info),\n\t\t\t\"VLB 0x%lx\", dev->base_addr);\n}\n\nstatic u32 pcnet32_get_link(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (lp->mii) {\n\t\tr = mii_link_ok(&lp->mii_if);\n\t} else if (lp->chip_version == PCNET32_79C970A) {\n\t\tulong ioaddr = dev->base_addr;\t \n\t\t \n\t\tif (!lp->autoneg && lp->port_tp)\n\t\t\tr = (lp->a->read_bcr(ioaddr, 4) != 0xc0);\n\t\telse  \n\t\t\tr = 1;\n\t} else if (lp->chip_version > PCNET32_79C970A) {\n\t\tulong ioaddr = dev->base_addr;\t \n\t\tr = (lp->a->read_bcr(ioaddr, 4) != 0xc0);\n\t} else {\t \n\t\tr = 1;\n\t}\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn r;\n}\n\nstatic u32 pcnet32_get_msglevel(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\treturn lp->msg_enable;\n}\n\nstatic void pcnet32_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tlp->msg_enable = value;\n}\n\nstatic int pcnet32_nway_reset(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\tint r = -EOPNOTSUPP;\n\n\tif (lp->mii) {\n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\tr = mii_nway_restart(&lp->mii_if);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t}\n\treturn r;\n}\n\nstatic void pcnet32_get_ringparam(struct net_device *dev,\n\t\t\t\t  struct ethtool_ringparam *ering,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\n\tering->tx_max_pending = TX_MAX_RING_SIZE;\n\tering->tx_pending = lp->tx_ring_size;\n\tering->rx_max_pending = RX_MAX_RING_SIZE;\n\tering->rx_pending = lp->rx_ring_size;\n}\n\nstatic int pcnet32_set_ringparam(struct net_device *dev,\n\t\t\t\t struct ethtool_ringparam *ering,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\tunsigned int size;\n\tulong ioaddr = dev->base_addr;\n\tint i;\n\n\tif (ering->rx_mini_pending || ering->rx_jumbo_pending)\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\tpcnet32_netif_stop(dev);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\t \n\n\tsize = min(ering->tx_pending, (unsigned int)TX_MAX_RING_SIZE);\n\n\t \n\tfor (i = 2; i <= PCNET32_LOG_MAX_TX_BUFFERS; i++) {\n\t\tif (size <= (1 << i))\n\t\t\tbreak;\n\t}\n\tif ((1 << i) != lp->tx_ring_size)\n\t\tpcnet32_realloc_tx_ring(dev, lp, i);\n\n\tsize = min(ering->rx_pending, (unsigned int)RX_MAX_RING_SIZE);\n\tfor (i = 2; i <= PCNET32_LOG_MAX_RX_BUFFERS; i++) {\n\t\tif (size <= (1 << i))\n\t\t\tbreak;\n\t}\n\tif ((1 << i) != lp->rx_ring_size)\n\t\tpcnet32_realloc_rx_ring(dev, lp, i);\n\n\tlp->napi.weight = lp->rx_ring_size / 2;\n\n\tif (netif_running(dev)) {\n\t\tpcnet32_netif_start(dev);\n\t\tpcnet32_restart(dev, CSR0_NORMAL);\n\t}\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\tnetif_info(lp, drv, dev, \"Ring Param Settings: RX: %d, TX: %d\\n\",\n\t\t   lp->rx_ring_size, lp->tx_ring_size);\n\n\treturn 0;\n}\n\nstatic void pcnet32_get_strings(struct net_device *dev, u32 stringset,\n\t\t\t\tu8 *data)\n{\n\tmemcpy(data, pcnet32_gstrings_test, sizeof(pcnet32_gstrings_test));\n}\n\nstatic int pcnet32_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn PCNET32_TEST_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void pcnet32_ethtool_test(struct net_device *dev,\n\t\t\t\t struct ethtool_test *test, u64 * data)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint rc;\n\n\tif (test->flags == ETH_TEST_FL_OFFLINE) {\n\t\trc = pcnet32_loopback_test(dev, data);\n\t\tif (rc) {\n\t\t\tnetif_printk(lp, hw, KERN_DEBUG, dev,\n\t\t\t\t     \"Loopback test failed\\n\");\n\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\t} else\n\t\t\tnetif_printk(lp, hw, KERN_DEBUG, dev,\n\t\t\t\t     \"Loopback test passed\\n\");\n\t} else\n\t\tnetif_printk(lp, hw, KERN_DEBUG, dev,\n\t\t\t     \"No tests to run (specify 'Offline' on ethtool)\\n\");\n}\t\t\t\t \n\nstatic int pcnet32_loopback_test(struct net_device *dev, uint64_t * data1)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tconst struct pcnet32_access *a = lp->a;\t \n\tulong ioaddr = dev->base_addr;\t \n\tstruct sk_buff *skb;\t \n\tint x, i;\t\t \n\tint numbuffs = 4;\t \n\tu16 status = 0x8300;\t \n\t__le16 teststatus;\t \n\tint rc;\t\t\t \n\tint size;\t\t \n\tunsigned char *packet;\t \n\tstatic const int data_len = 60;\t \n\tunsigned long flags;\n\tunsigned long ticks;\n\n\trc = 1;\t\t\t \n\n\tif (netif_running(dev))\n\t\tpcnet32_netif_stop(dev);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\t \n\n\tnumbuffs = min(numbuffs, (int)min(lp->rx_ring_size, lp->tx_ring_size));\n\n\t \n\tlp->a->reset(ioaddr);\n\tlp->a->write_csr(ioaddr, CSR4, 0x0915);\t \n\n\t \n\tlp->a->write_bcr(ioaddr, 20, 2);\n\n\t \n\tpcnet32_restart(dev, 0x0000);\n\n\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\t \n\n\t \n\tsize = data_len + 15;\n\tfor (x = 0; x < numbuffs; x++) {\n\t\tskb = netdev_alloc_skb(dev, size);\n\t\tif (!skb) {\n\t\t\tnetif_printk(lp, hw, KERN_DEBUG, dev,\n\t\t\t\t     \"Cannot allocate skb at line: %d!\\n\",\n\t\t\t\t     __LINE__);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tpacket = skb->data;\n\t\tskb_put(skb, size);\t \n\t\tlp->tx_skbuff[x] = skb;\n\t\tlp->tx_ring[x].length = cpu_to_le16(-skb->len);\n\t\tlp->tx_ring[x].misc = 0;\n\n\t\t \n\t\tfor (i = 0; i < 6; i++)\n\t\t\t*packet++ = dev->dev_addr[i];\n\t\tfor (i = 0; i < 6; i++)\n\t\t\t*packet++ = dev->dev_addr[i];\n\t\t \n\t\t*packet++ = 0x08;\n\t\t*packet++ = 0x06;\n\t\t \n\t\t*packet++ = x;\n\t\t \n\t\tfor (i = 0; i < data_len; i++)\n\t\t\t*packet++ = i;\n\n\t\tlp->tx_dma_addr[x] =\n\t\t\tdma_map_single(&lp->pci_dev->dev, skb->data, skb->len,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&lp->pci_dev->dev, lp->tx_dma_addr[x])) {\n\t\t\tnetif_printk(lp, hw, KERN_DEBUG, dev,\n\t\t\t\t     \"DMA mapping error at line: %d!\\n\",\n\t\t\t\t     __LINE__);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tlp->tx_ring[x].base = cpu_to_le32(lp->tx_dma_addr[x]);\n\t\twmb();\t \n\t\tlp->tx_ring[x].status = cpu_to_le16(status);\n\t}\n\n\tx = a->read_bcr(ioaddr, 32);\t \n\ta->write_bcr(ioaddr, 32, x | 0x0002);\n\n\t \n\tx = a->read_csr(ioaddr, CSR15) & 0xfffc;\n\tlp->a->write_csr(ioaddr, CSR15, x | 0x0044);\n\n\tteststatus = cpu_to_le16(0x8000);\n\tlp->a->write_csr(ioaddr, CSR0, CSR0_START);\t \n\n\t \n\tfor (x = 0; x < numbuffs; x++) {\n\t\tticks = 0;\n\t\trmb();\n\t\twhile ((lp->rx_ring[x].status & teststatus) && (ticks < 200)) {\n\t\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\t\tmsleep(1);\n\t\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\t\trmb();\n\t\t\tticks++;\n\t\t}\n\t\tif (ticks == 200) {\n\t\t\tnetif_err(lp, hw, dev, \"Desc %d failed to reset!\\n\", x);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\t \n\twmb();\n\tif (netif_msg_hw(lp) && netif_msg_pktdata(lp)) {\n\t\tnetdev_printk(KERN_DEBUG, dev, \"RX loopback packets:\\n\");\n\n\t\tfor (x = 0; x < numbuffs; x++) {\n\t\t\tnetdev_printk(KERN_DEBUG, dev, \"Packet %d: \", x);\n\t\t\tskb = lp->rx_skbuff[x];\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tpr_cont(\" %02x\", *(skb->data + i));\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t}\n\n\tx = 0;\n\trc = 0;\n\twhile (x < numbuffs && !rc) {\n\t\tskb = lp->rx_skbuff[x];\n\t\tpacket = lp->tx_skbuff[x]->data;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (*(skb->data + i) != packet[i]) {\n\t\t\t\tnetif_printk(lp, hw, KERN_DEBUG, dev,\n\t\t\t\t\t     \"Error in compare! %2x - %02x %02x\\n\",\n\t\t\t\t\t     i, *(skb->data + i), packet[i]);\n\t\t\t\trc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx++;\n\t}\n\nclean_up:\n\t*data1 = rc;\n\tpcnet32_purge_tx_ring(dev);\n\n\tx = a->read_csr(ioaddr, CSR15);\n\ta->write_csr(ioaddr, CSR15, (x & ~0x0044));\t \n\n\tx = a->read_bcr(ioaddr, 32);\t \n\ta->write_bcr(ioaddr, 32, (x & ~0x0002));\n\n\tif (netif_running(dev)) {\n\t\tpcnet32_netif_start(dev);\n\t\tpcnet32_restart(dev, CSR0_NORMAL);\n\t} else {\n\t\tpcnet32_purge_rx_ring(dev);\n\t\tlp->a->write_bcr(ioaddr, 20, 4);\t \n\t}\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn rc;\n}\t\t\t\t \n\nstatic int pcnet32_set_phys_id(struct net_device *dev,\n\t\t\t       enum ethtool_phys_id_state state)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tconst struct pcnet32_access *a = lp->a;\n\tulong ioaddr = dev->base_addr;\n\tunsigned long flags;\n\tint i;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\t \n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\tfor (i = 4; i < 8; i++)\n\t\t\tlp->save_regs[i - 4] = a->read_bcr(ioaddr, i);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\treturn 2;\t \n\n\tcase ETHTOOL_ID_ON:\n\tcase ETHTOOL_ID_OFF:\n\t\t \n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\tfor (i = 4; i < 8; i++)\n\t\t\ta->write_bcr(ioaddr, i, a->read_bcr(ioaddr, i) ^ 0x4000);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\t \n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\tfor (i = 4; i < 8; i++)\n\t\t\ta->write_bcr(ioaddr, i, lp->save_regs[i - 4]);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t}\n\treturn 0;\n}\n\n \n\nstatic void pcnet32_rx_entry(struct net_device *dev,\n\t\t\t     struct pcnet32_private *lp,\n\t\t\t     struct pcnet32_rx_head *rxp,\n\t\t\t     int entry)\n{\n\tint status = (short)le16_to_cpu(rxp->status) >> 8;\n\tint rx_in_place = 0;\n\tstruct sk_buff *skb;\n\tshort pkt_len;\n\n\tif (status != 0x03) {\t \n\t\t \n\t\tif (status & 0x01)\t \n\t\t\tdev->stats.rx_errors++;\t \n\t\tif (status & 0x20)\n\t\t\tdev->stats.rx_frame_errors++;\n\t\tif (status & 0x10)\n\t\t\tdev->stats.rx_over_errors++;\n\t\tif (status & 0x08)\n\t\t\tdev->stats.rx_crc_errors++;\n\t\tif (status & 0x04)\n\t\t\tdev->stats.rx_fifo_errors++;\n\t\treturn;\n\t}\n\n\tpkt_len = (le32_to_cpu(rxp->msg_length) & 0xfff) - 4;\n\n\t \n\tif (unlikely(pkt_len > PKT_BUF_SIZE)) {\n\t\tnetif_err(lp, drv, dev, \"Impossible packet size %d!\\n\",\n\t\t\t  pkt_len);\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\tif (pkt_len < 60) {\n\t\tnetif_err(lp, rx_err, dev, \"Runt packet!\\n\");\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\n\tif (pkt_len > rx_copybreak) {\n\t\tstruct sk_buff *newskb;\n\t\tdma_addr_t new_dma_addr;\n\n\t\tnewskb = netdev_alloc_skb(dev, PKT_BUF_SKB);\n\t\t \n\t\tif (newskb) {\n\t\t\tskb_reserve(newskb, NET_IP_ALIGN);\n\t\t\tnew_dma_addr = dma_map_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t      newskb->data,\n\t\t\t\t\t\t      PKT_BUF_SIZE,\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&lp->pci_dev->dev, new_dma_addr)) {\n\t\t\t\tnetif_err(lp, rx_err, dev,\n\t\t\t\t\t  \"DMA mapping error.\\n\");\n\t\t\t\tdev_kfree_skb(newskb);\n\t\t\t\tskb = NULL;\n\t\t\t} else {\n\t\t\t\tskb = lp->rx_skbuff[entry];\n\t\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t lp->rx_dma_addr[entry],\n\t\t\t\t\t\t PKT_BUF_SIZE,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\tlp->rx_skbuff[entry] = newskb;\n\t\t\t\tlp->rx_dma_addr[entry] = new_dma_addr;\n\t\t\t\trxp->base = cpu_to_le32(new_dma_addr);\n\t\t\t\trx_in_place = 1;\n\t\t\t}\n\t\t} else\n\t\t\tskb = NULL;\n\t} else\n\t\tskb = netdev_alloc_skb(dev, pkt_len + NET_IP_ALIGN);\n\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tif (!rx_in_place) {\n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\tskb_put(skb, pkt_len);\t \n\t\tdma_sync_single_for_cpu(&lp->pci_dev->dev,\n\t\t\t\t\tlp->rx_dma_addr[entry], pkt_len,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t (unsigned char *)(lp->rx_skbuff[entry]->data),\n\t\t\t\t pkt_len);\n\t\tdma_sync_single_for_device(&lp->pci_dev->dev,\n\t\t\t\t\t   lp->rx_dma_addr[entry], pkt_len,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\t}\n\tdev->stats.rx_bytes += skb->len;\n\tskb->protocol = eth_type_trans(skb, dev);\n\tnetif_receive_skb(skb);\n\tdev->stats.rx_packets++;\n}\n\nstatic int pcnet32_rx(struct net_device *dev, int budget)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint entry = lp->cur_rx & lp->rx_mod_mask;\n\tstruct pcnet32_rx_head *rxp = &lp->rx_ring[entry];\n\tint npackets = 0;\n\n\t \n\twhile (npackets < budget && (short)le16_to_cpu(rxp->status) >= 0) {\n\t\tpcnet32_rx_entry(dev, lp, rxp, entry);\n\t\tnpackets += 1;\n\t\t \n\t\trxp->buf_length = cpu_to_le16(NEG_BUF_SIZE);\n\t\twmb();\t \n\t\trxp->status = cpu_to_le16(0x8000);\n\t\tentry = (++lp->cur_rx) & lp->rx_mod_mask;\n\t\trxp = &lp->rx_ring[entry];\n\t}\n\n\treturn npackets;\n}\n\nstatic int pcnet32_tx(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned int dirty_tx = lp->dirty_tx;\n\tint delta;\n\tint must_restart = 0;\n\n\twhile (dirty_tx != lp->cur_tx) {\n\t\tint entry = dirty_tx & lp->tx_mod_mask;\n\t\tint status = (short)le16_to_cpu(lp->tx_ring[entry].status);\n\n\t\tif (status < 0)\n\t\t\tbreak;\t \n\n\t\tlp->tx_ring[entry].base = 0;\n\n\t\tif (status & 0x4000) {\n\t\t\t \n\t\t\tint err_status = le32_to_cpu(lp->tx_ring[entry].misc);\n\t\t\tdev->stats.tx_errors++;\n\t\t\tnetif_err(lp, tx_err, dev,\n\t\t\t\t  \"Tx error status=%04x err_status=%08x\\n\",\n\t\t\t\t  status, err_status);\n\t\t\tif (err_status & 0x04000000)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tif (err_status & 0x08000000)\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\tif (err_status & 0x10000000)\n\t\t\t\tdev->stats.tx_window_errors++;\n#ifndef DO_DXSUFLO\n\t\t\tif (err_status & 0x40000000) {\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tnetif_err(lp, tx_err, dev, \"Tx FIFO error!\\n\");\n\t\t\t\tmust_restart = 1;\n\t\t\t}\n#else\n\t\t\tif (err_status & 0x40000000) {\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\tif (!lp->dxsuflo) {\t \n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tnetif_err(lp, tx_err, dev, \"Tx FIFO error!\\n\");\n\t\t\t\t\tmust_restart = 1;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tif (status & 0x1800)\n\t\t\t\tdev->stats.collisions++;\n\t\t\tdev->stats.tx_packets++;\n\t\t}\n\n\t\t \n\t\tif (lp->tx_skbuff[entry]) {\n\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t lp->tx_dma_addr[entry],\n\t\t\t\t\t lp->tx_skbuff[entry]->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(lp->tx_skbuff[entry]);\n\t\t\tlp->tx_skbuff[entry] = NULL;\n\t\t\tlp->tx_dma_addr[entry] = 0;\n\t\t}\n\t\tdirty_tx++;\n\t}\n\n\tdelta = (lp->cur_tx - dirty_tx) & (lp->tx_mod_mask + lp->tx_ring_size);\n\tif (delta > lp->tx_ring_size) {\n\t\tnetif_err(lp, drv, dev, \"out-of-sync dirty pointer, %d vs. %d, full=%d\\n\",\n\t\t\t  dirty_tx, lp->cur_tx, lp->tx_full);\n\t\tdirty_tx += lp->tx_ring_size;\n\t\tdelta -= lp->tx_ring_size;\n\t}\n\n\tif (lp->tx_full &&\n\t    netif_queue_stopped(dev) &&\n\t    delta < lp->tx_ring_size - 2) {\n\t\t \n\t\tlp->tx_full = 0;\n\t\tnetif_wake_queue(dev);\n\t}\n\tlp->dirty_tx = dirty_tx;\n\n\treturn must_restart;\n}\n\nstatic int pcnet32_poll(struct napi_struct *napi, int budget)\n{\n\tstruct pcnet32_private *lp = container_of(napi, struct pcnet32_private, napi);\n\tstruct net_device *dev = lp->dev;\n\tunsigned long ioaddr = dev->base_addr;\n\tunsigned long flags;\n\tint work_done;\n\tu16 val;\n\n\twork_done = pcnet32_rx(dev, budget);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (pcnet32_tx(dev)) {\n\t\t \n\t\tlp->a->reset(ioaddr);\n\t\tlp->a->write_csr(ioaddr, CSR4, 0x0915);\t \n\t\tpcnet32_restart(dev, CSR0_START);\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tif (work_done < budget && napi_complete_done(napi, work_done)) {\n\t\t \n\t\tval = lp->a->read_csr(ioaddr, CSR3);\n\t\tval &= 0x00ff;\n\t\tlp->a->write_csr(ioaddr, CSR3, val);\n\n\t\t \n\t\tlp->a->write_csr(ioaddr, CSR0, CSR0_INTEN);\n\t}\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn work_done;\n}\n\n#define PCNET32_REGS_PER_PHY\t32\n#define PCNET32_MAX_PHYS\t32\nstatic int pcnet32_get_regs_len(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint j = lp->phycount * PCNET32_REGS_PER_PHY;\n\n\treturn (PCNET32_NUM_REGS + j) * sizeof(u16);\n}\n\nstatic void pcnet32_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t     void *ptr)\n{\n\tint i, csr0;\n\tu16 *buff = ptr;\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tconst struct pcnet32_access *a = lp->a;\n\tulong ioaddr = dev->base_addr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tcsr0 = a->read_csr(ioaddr, CSR0);\n\tif (!(csr0 & CSR0_STOP))\t \n\t\tpcnet32_suspend(dev, &flags, 1);\n\n\t \n\tfor (i = 0; i < 16; i += 2)\n\t\t*buff++ = inw(ioaddr + i);\n\n\t \n\tfor (i = 0; i < 90; i++)\n\t\t*buff++ = a->read_csr(ioaddr, i);\n\n\t*buff++ = a->read_csr(ioaddr, 112);\n\t*buff++ = a->read_csr(ioaddr, 114);\n\n\t \n\tfor (i = 0; i < 30; i++)\n\t\t*buff++ = a->read_bcr(ioaddr, i);\n\n\t*buff++ = 0;\t\t \n\n\tfor (i = 31; i < 36; i++)\n\t\t*buff++ = a->read_bcr(ioaddr, i);\n\n\t \n\tif (lp->mii) {\n\t\tint j;\n\t\tfor (j = 0; j < PCNET32_MAX_PHYS; j++) {\n\t\t\tif (lp->phymask & (1 << j)) {\n\t\t\t\tfor (i = 0; i < PCNET32_REGS_PER_PHY; i++) {\n\t\t\t\t\tlp->a->write_bcr(ioaddr, 33,\n\t\t\t\t\t\t\t(j << 5) | i);\n\t\t\t\t\t*buff++ = lp->a->read_bcr(ioaddr, 34);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(csr0 & CSR0_STOP))\t \n\t\tpcnet32_clr_suspend(lp, ioaddr);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\nstatic const struct ethtool_ops pcnet32_ethtool_ops = {\n\t.get_drvinfo\t\t= pcnet32_get_drvinfo,\n\t.get_msglevel\t\t= pcnet32_get_msglevel,\n\t.set_msglevel\t\t= pcnet32_set_msglevel,\n\t.nway_reset\t\t= pcnet32_nway_reset,\n\t.get_link\t\t= pcnet32_get_link,\n\t.get_ringparam\t\t= pcnet32_get_ringparam,\n\t.set_ringparam\t\t= pcnet32_set_ringparam,\n\t.get_strings\t\t= pcnet32_get_strings,\n\t.self_test\t\t= pcnet32_ethtool_test,\n\t.set_phys_id\t\t= pcnet32_set_phys_id,\n\t.get_regs_len\t\t= pcnet32_get_regs_len,\n\t.get_regs\t\t= pcnet32_get_regs,\n\t.get_sset_count\t\t= pcnet32_get_sset_count,\n\t.get_link_ksettings\t= pcnet32_get_link_ksettings,\n\t.set_link_ksettings\t= pcnet32_set_link_ksettings,\n};\n\n \n\nstatic void pcnet32_probe_vlbus(unsigned int *pcnet32_portlist)\n{\n\tunsigned int *port, ioaddr;\n\n\t \n\tfor (port = pcnet32_portlist; (ioaddr = *port); port++) {\n\t\tif (request_region\n\t\t    (ioaddr, PCNET32_TOTAL_SIZE, \"pcnet32_probe_vlbus\")) {\n\t\t\t \n\t\t\tif ((inb(ioaddr + 14) == 0x57) &&\n\t\t\t    (inb(ioaddr + 15) == 0x57)) {\n\t\t\t\tpcnet32_probe1(ioaddr, 0, NULL);\n\t\t\t} else {\n\t\t\t\trelease_region(ioaddr, PCNET32_TOTAL_SIZE);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int\npcnet32_probe_pci(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned long ioaddr;\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err < 0) {\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_err(\"failed to enable device -- err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tpci_set_master(pdev);\n\n\tif (!pci_resource_len(pdev, 0)) {\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_err(\"card has no PCI IO resources, aborting\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_disable_dev;\n\t}\n\n\terr = dma_set_mask(&pdev->dev, PCNET32_DMA_MASK);\n\tif (err) {\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_err(\"architecture does not support 32bit PCI busmaster DMA\\n\");\n\t\tgoto err_disable_dev;\n\t}\n\n\tioaddr = pci_resource_start(pdev, 0);\n\tif (!request_region(ioaddr, PCNET32_TOTAL_SIZE, \"pcnet32_probe_pci\")) {\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_err(\"io address range already allocated\\n\");\n\t\terr = -EBUSY;\n\t\tgoto err_disable_dev;\n\t}\n\n\terr = pcnet32_probe1(ioaddr, 1, pdev);\n\nerr_disable_dev:\n\tif (err < 0)\n\t\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic const struct net_device_ops pcnet32_netdev_ops = {\n\t.ndo_open\t\t= pcnet32_open,\n\t.ndo_stop \t\t= pcnet32_close,\n\t.ndo_start_xmit\t\t= pcnet32_start_xmit,\n\t.ndo_tx_timeout\t\t= pcnet32_tx_timeout,\n\t.ndo_get_stats\t\t= pcnet32_get_stats,\n\t.ndo_set_rx_mode\t= pcnet32_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= pcnet32_ioctl,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= pcnet32_poll_controller,\n#endif\n};\n\n \nstatic int\npcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)\n{\n\tstruct pcnet32_private *lp;\n\tint i, media;\n\tint fdx, mii, fset, dxsuflo, sram;\n\tint chip_version;\n\tchar *chipname;\n\tstruct net_device *dev;\n\tconst struct pcnet32_access *a = NULL;\n\tu8 promaddr[ETH_ALEN];\n\tu8 addr[ETH_ALEN];\n\tint ret = -ENODEV;\n\n\t \n\tpcnet32_wio_reset(ioaddr);\n\n\t \n\tif (pcnet32_wio_read_csr(ioaddr, 0) == 4 && pcnet32_wio_check(ioaddr)) {\n\t\ta = &pcnet32_wio;\n\t} else {\n\t\tpcnet32_dwio_reset(ioaddr);\n\t\tif (pcnet32_dwio_read_csr(ioaddr, 0) == 4 &&\n\t\t    pcnet32_dwio_check(ioaddr)) {\n\t\t\ta = &pcnet32_dwio;\n\t\t} else {\n\t\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\t\tpr_err(\"No access methods\\n\");\n\t\t\tgoto err_release_region;\n\t\t}\n\t}\n\n\tchip_version =\n\t    a->read_csr(ioaddr, 88) | (a->read_csr(ioaddr, 89) << 16);\n\tif ((pcnet32_debug & NETIF_MSG_PROBE) && (pcnet32_debug & NETIF_MSG_HW))\n\t\tpr_info(\"  PCnet chip version is %#x\\n\", chip_version);\n\tif ((chip_version & 0xfff) != 0x003) {\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_info(\"Unsupported chip version\\n\");\n\t\tgoto err_release_region;\n\t}\n\n\t \n\tfdx = mii = fset = dxsuflo = sram = 0;\n\tchip_version = (chip_version >> 12) & 0xffff;\n\n\tswitch (chip_version) {\n\tcase 0x2420:\n\t\tchipname = \"PCnet/PCI 79C970\";\t \n\t\tbreak;\n\tcase 0x2430:\n\t\tif (shared)\n\t\t\tchipname = \"PCnet/PCI 79C970\";\t \n\t\telse\n\t\t\tchipname = \"PCnet/32 79C965\";\t \n\t\tbreak;\n\tcase 0x2621:\n\t\tchipname = \"PCnet/PCI II 79C970A\";\t \n\t\tfdx = 1;\n\t\tbreak;\n\tcase 0x2623:\n\t\tchipname = \"PCnet/FAST 79C971\";\t \n\t\tfdx = 1;\n\t\tmii = 1;\n\t\tfset = 1;\n\t\tbreak;\n\tcase 0x2624:\n\t\tchipname = \"PCnet/FAST+ 79C972\";\t \n\t\tfdx = 1;\n\t\tmii = 1;\n\t\tfset = 1;\n\t\tbreak;\n\tcase 0x2625:\n\t\tchipname = \"PCnet/FAST III 79C973\";\t \n\t\tfdx = 1;\n\t\tmii = 1;\n\t\tsram = 1;\n\t\tbreak;\n\tcase 0x2626:\n\t\tchipname = \"PCnet/Home 79C978\";\t \n\t\tfdx = 1;\n\t\t \n\t\tmedia = a->read_bcr(ioaddr, 49);\n\t\tmedia &= ~3;\t \n\t\tif (cards_found < MAX_UNITS && homepna[cards_found])\n\t\t\tmedia |= 1;\t \n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tprintk(KERN_DEBUG PFX \"media set to %sMbit mode\\n\",\n\t\t\t       (media & 1) ? \"1\" : \"10\");\n\t\ta->write_bcr(ioaddr, 49, media);\n\t\tbreak;\n\tcase 0x2627:\n\t\tchipname = \"PCnet/FAST III 79C975\";\t \n\t\tfdx = 1;\n\t\tmii = 1;\n\t\tsram = 1;\n\t\tbreak;\n\tcase 0x2628:\n\t\tchipname = \"PCnet/PRO 79C976\";\n\t\tfdx = 1;\n\t\tmii = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_info(\"PCnet version %#x, no PCnet32 chip\\n\",\n\t\t\t\tchip_version);\n\t\tgoto err_release_region;\n\t}\n\n\t \n\n\tif (fset) {\n\t\ta->write_bcr(ioaddr, 18, (a->read_bcr(ioaddr, 18) | 0x0860));\n\t\ta->write_csr(ioaddr, 80,\n\t\t\t     (a->read_csr(ioaddr, 80) & 0x0C00) | 0x0c00);\n\t\tdxsuflo = 1;\n\t}\n\n\t \n\tif (sram) {\n\t\t \n\t\ta->write_bcr(ioaddr, 25, 0x17);\n\t\ta->write_bcr(ioaddr, 26, 0xc);\n\t\t \n\t\ta->write_bcr(ioaddr, 18, a->read_bcr(ioaddr, 18) | (1 << 11));\n\t}\n\n\tdev = alloc_etherdev(sizeof(*lp));\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release_region;\n\t}\n\n\tif (pdev)\n\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\tpr_info(\"%s at %#3lx,\", chipname, ioaddr);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned int val;\n\t\tval = a->read_csr(ioaddr, i + 12) & 0x0ffff;\n\t\t \n\t\taddr[2 * i] = val & 0x0ff;\n\t\taddr[2 * i + 1] = (val >> 8) & 0x0ff;\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tpromaddr[i] = inb(ioaddr + i);\n\n\tif (!ether_addr_equal(promaddr, dev->dev_addr) ||\n\t    !is_valid_ether_addr(dev->dev_addr)) {\n\t\tif (is_valid_ether_addr(promaddr)) {\n\t\t\tif (pcnet32_debug & NETIF_MSG_PROBE) {\n\t\t\t\tpr_cont(\" warning: CSR address invalid,\\n\");\n\t\t\t\tpr_info(\"    using instead PROM address of\");\n\t\t\t}\n\t\t\teth_hw_addr_set(dev, promaddr);\n\t\t}\n\t}\n\n\t \n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\tstatic const u8 zero_addr[ETH_ALEN] = {};\n\n\t\teth_hw_addr_set(dev, zero_addr);\n\t}\n\n\tif (pcnet32_debug & NETIF_MSG_PROBE) {\n\t\tpr_cont(\" %pM\", dev->dev_addr);\n\n\t\t \n\t\tif (((chip_version + 1) & 0xfffe) == 0x2624) {\n\t\t\ti = a->read_csr(ioaddr, 80) & 0x0C00;\t \n\t\t\tpr_info(\"    tx_start_pt(0x%04x):\", i);\n\t\t\tswitch (i >> 10) {\n\t\t\tcase 0:\n\t\t\t\tpr_cont(\"  20 bytes,\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpr_cont(\"  64 bytes,\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpr_cont(\" 128 bytes,\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tpr_cont(\"~220 bytes,\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = a->read_bcr(ioaddr, 18);\t \n\t\t\tpr_cont(\" BCR18(%x):\", i & 0xffff);\n\t\t\tif (i & (1 << 5))\n\t\t\t\tpr_cont(\"BurstWrEn \");\n\t\t\tif (i & (1 << 6))\n\t\t\t\tpr_cont(\"BurstRdEn \");\n\t\t\tif (i & (1 << 7))\n\t\t\t\tpr_cont(\"DWordIO \");\n\t\t\tif (i & (1 << 11))\n\t\t\t\tpr_cont(\"NoUFlow \");\n\t\t\ti = a->read_bcr(ioaddr, 25);\n\t\t\tpr_info(\"    SRAMSIZE=0x%04x,\", i << 8);\n\t\t\ti = a->read_bcr(ioaddr, 26);\n\t\t\tpr_cont(\" SRAM_BND=0x%04x,\", i << 8);\n\t\t\ti = a->read_bcr(ioaddr, 27);\n\t\t\tif (i & (1 << 14))\n\t\t\t\tpr_cont(\"LowLatRx\");\n\t\t}\n\t}\n\n\tdev->base_addr = ioaddr;\n\tlp = netdev_priv(dev);\n\t \n\tlp->init_block = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t    sizeof(*lp->init_block),\n\t\t\t\t\t    &lp->init_dma_addr, GFP_KERNEL);\n\tif (!lp->init_block) {\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_err(\"Coherent memory allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_netdev;\n\t}\n\tlp->pci_dev = pdev;\n\n\tlp->dev = dev;\n\n\tspin_lock_init(&lp->lock);\n\n\tlp->name = chipname;\n\tlp->shared_irq = shared;\n\tlp->tx_ring_size = TX_RING_SIZE;\t \n\tlp->rx_ring_size = RX_RING_SIZE;\t \n\tlp->tx_mod_mask = lp->tx_ring_size - 1;\n\tlp->rx_mod_mask = lp->rx_ring_size - 1;\n\tlp->tx_len_bits = (PCNET32_LOG_TX_BUFFERS << 12);\n\tlp->rx_len_bits = (PCNET32_LOG_RX_BUFFERS << 4);\n\tlp->mii_if.full_duplex = fdx;\n\tlp->mii_if.phy_id_mask = 0x1f;\n\tlp->mii_if.reg_num_mask = 0x1f;\n\tlp->dxsuflo = dxsuflo;\n\tlp->mii = mii;\n\tlp->chip_version = chip_version;\n\tlp->msg_enable = pcnet32_debug;\n\tif ((cards_found >= MAX_UNITS) ||\n\t    (options[cards_found] >= sizeof(options_mapping)))\n\t\tlp->options = PCNET32_PORT_ASEL;\n\telse\n\t\tlp->options = options_mapping[options[cards_found]];\n\t \n\tif (lp->chip_version == PCNET32_79C970A)\n\t\tlp->options = PCNET32_PORT_10BT;\n\tlp->mii_if.dev = dev;\n\tlp->mii_if.mdio_read = mdio_read;\n\tlp->mii_if.mdio_write = mdio_write;\n\n\t \n\tlp->napi.weight = lp->rx_ring_size / 2;\n\n\tnetif_napi_add_weight(dev, &lp->napi, pcnet32_poll,\n\t\t\t      lp->rx_ring_size / 2);\n\n\tif (fdx && !(lp->options & PCNET32_PORT_ASEL) &&\n\t    ((cards_found >= MAX_UNITS) || full_duplex[cards_found]))\n\t\tlp->options |= PCNET32_PORT_FD;\n\n\tlp->a = a;\n\n\t \n\tif (pcnet32_alloc_ring(dev, pci_name(lp->pci_dev))) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ring;\n\t}\n\t \n\tif (dev->dev_addr[0] == 0x00 && dev->dev_addr[1] == 0xe0 &&\n\t    dev->dev_addr[2] == 0x75)\n\t\tlp->options = PCNET32_PORT_FD | PCNET32_PORT_GPSI;\n\n\tlp->init_block->mode = cpu_to_le16(0x0003);\t \n\tlp->init_block->tlen_rlen =\n\t    cpu_to_le16(lp->tx_len_bits | lp->rx_len_bits);\n\tfor (i = 0; i < 6; i++)\n\t\tlp->init_block->phys_addr[i] = dev->dev_addr[i];\n\tlp->init_block->filter[0] = 0x00000000;\n\tlp->init_block->filter[1] = 0x00000000;\n\tlp->init_block->rx_ring = cpu_to_le32(lp->rx_ring_dma_addr);\n\tlp->init_block->tx_ring = cpu_to_le32(lp->tx_ring_dma_addr);\n\n\t \n\ta->write_bcr(ioaddr, 20, 2);\n\n\ta->write_csr(ioaddr, 1, (lp->init_dma_addr & 0xffff));\n\ta->write_csr(ioaddr, 2, (lp->init_dma_addr >> 16));\n\n\tif (pdev) {\t\t \n\t\tdev->irq = pdev->irq;\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_cont(\" assigned IRQ %d\\n\", dev->irq);\n\t} else {\n\t\tunsigned long irq_mask = probe_irq_on();\n\n\t\t \n\t\t \n\t\ta->write_csr(ioaddr, CSR0, CSR0_INTEN | CSR0_INIT);\n\t\tmdelay(1);\n\n\t\tdev->irq = probe_irq_off(irq_mask);\n\t\tif (!dev->irq) {\n\t\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\t\tpr_cont(\", failed to detect IRQ line\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_ring;\n\t\t}\n\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\tpr_cont(\", probed IRQ %d\\n\", dev->irq);\n\t}\n\n\t \n\tif (lp->mii) {\n\t\t \n\n\t\tlp->mii_if.phy_id = ((lp->a->read_bcr(ioaddr, 33)) >> 5) & 0x1f;\n\t\t \n\t\tfor (i = 0; i < PCNET32_MAX_PHYS; i++) {\n\t\t\tunsigned short id1, id2;\n\n\t\t\tid1 = mdio_read(dev, i, MII_PHYSID1);\n\t\t\tif (id1 == 0xffff)\n\t\t\t\tcontinue;\n\t\t\tid2 = mdio_read(dev, i, MII_PHYSID2);\n\t\t\tif (id2 == 0xffff)\n\t\t\t\tcontinue;\n\t\t\tif (i == 31 && ((chip_version + 1) & 0xfffe) == 0x2624)\n\t\t\t\tcontinue;\t \n\t\t\tlp->phycount++;\n\t\t\tlp->phymask |= (1 << i);\n\t\t\tlp->mii_if.phy_id = i;\n\t\t\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\t\t\tpr_info(\"Found PHY %04x:%04x at address %d\\n\",\n\t\t\t\t\tid1, id2, i);\n\t\t}\n\t\tlp->a->write_bcr(ioaddr, 33, (lp->mii_if.phy_id) << 5);\n\t\tif (lp->phycount > 1)\n\t\t\tlp->options |= PCNET32_PORT_MII;\n\t}\n\n\ttimer_setup(&lp->watchdog_timer, pcnet32_watchdog, 0);\n\n\t \n\tdev->netdev_ops = &pcnet32_netdev_ops;\n\tdev->ethtool_ops = &pcnet32_ethtool_ops;\n\tdev->watchdog_timeo = (5 * HZ);\n\n\t \n\tif (register_netdev(dev))\n\t\tgoto err_free_ring;\n\n\tif (pdev) {\n\t\tpci_set_drvdata(pdev, dev);\n\t} else {\n\t\tlp->next = pcnet32_dev;\n\t\tpcnet32_dev = dev;\n\t}\n\n\tif (pcnet32_debug & NETIF_MSG_PROBE)\n\t\tpr_info(\"%s: registered as %s\\n\", dev->name, lp->name);\n\tcards_found++;\n\n\t \n\ta->write_bcr(ioaddr, 2, a->read_bcr(ioaddr, 2) | 0x1000);\n\n\treturn 0;\n\nerr_free_ring:\n\tpcnet32_free_ring(dev);\n\tdma_free_coherent(&lp->pci_dev->dev, sizeof(*lp->init_block),\n\t\t\t  lp->init_block, lp->init_dma_addr);\nerr_free_netdev:\n\tfree_netdev(dev);\nerr_release_region:\n\trelease_region(ioaddr, PCNET32_TOTAL_SIZE);\n\treturn ret;\n}\n\n \nstatic int pcnet32_alloc_ring(struct net_device *dev, const char *name)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\n\tlp->tx_ring = dma_alloc_coherent(&lp->pci_dev->dev,\n\t\t\t\t\t sizeof(struct pcnet32_tx_head) * lp->tx_ring_size,\n\t\t\t\t\t &lp->tx_ring_dma_addr, GFP_KERNEL);\n\tif (!lp->tx_ring) {\n\t\tnetif_err(lp, drv, dev, \"Coherent memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlp->rx_ring = dma_alloc_coherent(&lp->pci_dev->dev,\n\t\t\t\t\t sizeof(struct pcnet32_rx_head) * lp->rx_ring_size,\n\t\t\t\t\t &lp->rx_ring_dma_addr, GFP_KERNEL);\n\tif (!lp->rx_ring) {\n\t\tnetif_err(lp, drv, dev, \"Coherent memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlp->tx_dma_addr = kcalloc(lp->tx_ring_size, sizeof(dma_addr_t),\n\t\t\t\t  GFP_KERNEL);\n\tif (!lp->tx_dma_addr)\n\t\treturn -ENOMEM;\n\n\tlp->rx_dma_addr = kcalloc(lp->rx_ring_size, sizeof(dma_addr_t),\n\t\t\t\t  GFP_KERNEL);\n\tif (!lp->rx_dma_addr)\n\t\treturn -ENOMEM;\n\n\tlp->tx_skbuff = kcalloc(lp->tx_ring_size, sizeof(struct sk_buff *),\n\t\t\t\tGFP_KERNEL);\n\tif (!lp->tx_skbuff)\n\t\treturn -ENOMEM;\n\n\tlp->rx_skbuff = kcalloc(lp->rx_ring_size, sizeof(struct sk_buff *),\n\t\t\t\tGFP_KERNEL);\n\tif (!lp->rx_skbuff)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void pcnet32_free_ring(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\n\tkfree(lp->tx_skbuff);\n\tlp->tx_skbuff = NULL;\n\n\tkfree(lp->rx_skbuff);\n\tlp->rx_skbuff = NULL;\n\n\tkfree(lp->tx_dma_addr);\n\tlp->tx_dma_addr = NULL;\n\n\tkfree(lp->rx_dma_addr);\n\tlp->rx_dma_addr = NULL;\n\n\tif (lp->tx_ring) {\n\t\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t\t  sizeof(struct pcnet32_tx_head) * lp->tx_ring_size,\n\t\t\t\t  lp->tx_ring, lp->tx_ring_dma_addr);\n\t\tlp->tx_ring = NULL;\n\t}\n\n\tif (lp->rx_ring) {\n\t\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t\t  sizeof(struct pcnet32_rx_head) * lp->rx_ring_size,\n\t\t\t\t  lp->rx_ring, lp->rx_ring_dma_addr);\n\t\tlp->rx_ring = NULL;\n\t}\n}\n\nstatic int pcnet32_open(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tstruct pci_dev *pdev = lp->pci_dev;\n\tunsigned long ioaddr = dev->base_addr;\n\tu16 val;\n\tint i;\n\tint rc;\n\tunsigned long flags;\n\n\tif (request_irq(dev->irq, pcnet32_interrupt,\n\t\t\tlp->shared_irq ? IRQF_SHARED : 0, dev->name,\n\t\t\t(void *)dev)) {\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\t \n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\trc = -EINVAL;\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\tlp->a->reset(ioaddr);\n\n\t \n\tlp->a->write_bcr(ioaddr, 20, 2);\n\n\tnetif_printk(lp, ifup, KERN_DEBUG, dev,\n\t\t     \"%s() irq %d tx/rx rings %#x/%#x init %#x\\n\",\n\t\t     __func__, dev->irq, (u32) (lp->tx_ring_dma_addr),\n\t\t     (u32) (lp->rx_ring_dma_addr),\n\t\t     (u32) (lp->init_dma_addr));\n\n\tlp->autoneg = !!(lp->options & PCNET32_PORT_ASEL);\n\tlp->port_tp = !!(lp->options & PCNET32_PORT_10BT);\n\tlp->fdx = !!(lp->options & PCNET32_PORT_FD);\n\n\t \n\tval = lp->a->read_bcr(ioaddr, 2) & ~2;\n\tif (lp->options & PCNET32_PORT_ASEL)\n\t\tval |= 2;\n\tlp->a->write_bcr(ioaddr, 2, val);\n\n\t \n\tif (lp->mii_if.full_duplex) {\n\t\tval = lp->a->read_bcr(ioaddr, 9) & ~3;\n\t\tif (lp->options & PCNET32_PORT_FD) {\n\t\t\tval |= 1;\n\t\t\tif (lp->options == (PCNET32_PORT_FD | PCNET32_PORT_AUI))\n\t\t\t\tval |= 2;\n\t\t} else if (lp->options & PCNET32_PORT_ASEL) {\n\t\t\t \n\t\t\tif (lp->chip_version == 0x2627)\n\t\t\t\tval |= 3;\n\t\t}\n\t\tlp->a->write_bcr(ioaddr, 9, val);\n\t}\n\n\t \n\tval = lp->a->read_csr(ioaddr, 124) & ~0x10;\n\tif ((lp->options & PCNET32_PORT_PORTSEL) == PCNET32_PORT_GPSI)\n\t\tval |= 0x10;\n\tlp->a->write_csr(ioaddr, 124, val);\n\n\t \n\tif (pdev && pdev->subsystem_vendor == PCI_VENDOR_ID_AT &&\n\t    (pdev->subsystem_device == PCI_SUBDEVICE_ID_AT_2700FX ||\n\t     pdev->subsystem_device == PCI_SUBDEVICE_ID_AT_2701FX)) {\n\t\tif (lp->options & PCNET32_PORT_ASEL) {\n\t\t\tlp->options = PCNET32_PORT_FD | PCNET32_PORT_100;\n\t\t\tnetif_printk(lp, link, KERN_DEBUG, dev,\n\t\t\t\t     \"Setting 100Mb-Full Duplex\\n\");\n\t\t}\n\t}\n\tif (lp->phycount < 2) {\n\t\t \n\t\tif (lp->mii && !(lp->options & PCNET32_PORT_ASEL)) {\n\t\t\tlp->a->write_bcr(ioaddr, 32,\n\t\t\t\t\tlp->a->read_bcr(ioaddr, 32) | 0x0080);\n\t\t\t \n\t\t\tval = lp->a->read_bcr(ioaddr, 32) & ~0xb8;\n\t\t\tif (lp->options & PCNET32_PORT_FD)\n\t\t\t\tval |= 0x10;\n\t\t\tif (lp->options & PCNET32_PORT_100)\n\t\t\t\tval |= 0x08;\n\t\t\tlp->a->write_bcr(ioaddr, 32, val);\n\t\t} else {\n\t\t\tif (lp->options & PCNET32_PORT_ASEL) {\n\t\t\t\tlp->a->write_bcr(ioaddr, 32,\n\t\t\t\t\t\tlp->a->read_bcr(ioaddr,\n\t\t\t\t\t\t\t       32) | 0x0080);\n\t\t\t\t \n\t\t\t\tval = lp->a->read_bcr(ioaddr, 32) & ~0x98;\n\t\t\t\tval |= 0x20;\n\t\t\t\tlp->a->write_bcr(ioaddr, 32, val);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint first_phy = -1;\n\t\tu16 bmcr;\n\t\tu32 bcr9;\n\t\tstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\n\n\t\t \n\t\tval = lp->a->read_bcr(ioaddr, 2);\n\t\tlp->a->write_bcr(ioaddr, 2, val & ~2);\n\t\tval = lp->a->read_bcr(ioaddr, 32);\n\t\tlp->a->write_bcr(ioaddr, 32, val & ~(1 << 7));\t \n\n\t\tif (!(lp->options & PCNET32_PORT_ASEL)) {\n\t\t\t \n\t\t\tecmd.port = PORT_MII;\n\t\t\tecmd.transceiver = XCVR_INTERNAL;\n\t\t\tecmd.autoneg = AUTONEG_DISABLE;\n\t\t\tethtool_cmd_speed_set(&ecmd,\n\t\t\t\t\t      (lp->options & PCNET32_PORT_100) ?\n\t\t\t\t\t      SPEED_100 : SPEED_10);\n\t\t\tbcr9 = lp->a->read_bcr(ioaddr, 9);\n\n\t\t\tif (lp->options & PCNET32_PORT_FD) {\n\t\t\t\tecmd.duplex = DUPLEX_FULL;\n\t\t\t\tbcr9 |= (1 << 0);\n\t\t\t} else {\n\t\t\t\tecmd.duplex = DUPLEX_HALF;\n\t\t\t\tbcr9 |= ~(1 << 0);\n\t\t\t}\n\t\t\tlp->a->write_bcr(ioaddr, 9, bcr9);\n\t\t}\n\n\t\tfor (i = 0; i < PCNET32_MAX_PHYS; i++) {\n\t\t\tif (lp->phymask & (1 << i)) {\n\t\t\t\t \n\t\t\t\tbmcr = mdio_read(dev, i, MII_BMCR);\n\t\t\t\tif (first_phy == -1) {\n\t\t\t\t\tfirst_phy = i;\n\t\t\t\t\tmdio_write(dev, i, MII_BMCR,\n\t\t\t\t\t\t   bmcr & ~BMCR_ISOLATE);\n\t\t\t\t} else {\n\t\t\t\t\tmdio_write(dev, i, MII_BMCR,\n\t\t\t\t\t\t   bmcr | BMCR_ISOLATE);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tlp->mii_if.phy_id = i;\n\t\t\t\tecmd.phy_address = i;\n\t\t\t\tif (lp->options & PCNET32_PORT_ASEL) {\n\t\t\t\t\tmii_ethtool_gset(&lp->mii_if, &ecmd);\n\t\t\t\t\tecmd.autoneg = AUTONEG_ENABLE;\n\t\t\t\t}\n\t\t\t\tmii_ethtool_sset(&lp->mii_if, &ecmd);\n\t\t\t}\n\t\t}\n\t\tlp->mii_if.phy_id = first_phy;\n\t\tnetif_info(lp, link, dev, \"Using PHY number %d\\n\", first_phy);\n\t}\n\n#ifdef DO_DXSUFLO\n\tif (lp->dxsuflo) {\t \n\t\tval = lp->a->read_csr(ioaddr, CSR3);\n\t\tval |= 0x40;\n\t\tlp->a->write_csr(ioaddr, CSR3, val);\n\t}\n#endif\n\n\tlp->init_block->mode =\n\t    cpu_to_le16((lp->options & PCNET32_PORT_PORTSEL) << 7);\n\tpcnet32_load_multicast(dev);\n\n\tif (pcnet32_init_ring(dev)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_free_ring;\n\t}\n\n\tnapi_enable(&lp->napi);\n\n\t \n\tlp->a->write_csr(ioaddr, 1, (lp->init_dma_addr & 0xffff));\n\tlp->a->write_csr(ioaddr, 2, (lp->init_dma_addr >> 16));\n\n\tlp->a->write_csr(ioaddr, CSR4, 0x0915);\t \n\tlp->a->write_csr(ioaddr, CSR0, CSR0_INIT);\n\n\tnetif_start_queue(dev);\n\n\tif (lp->chip_version >= PCNET32_79C970A) {\n\t\t \n\t\tpcnet32_check_media(dev, 1);\n\t\tmod_timer(&lp->watchdog_timer, PCNET32_WATCHDOG_TIMEOUT);\n\t}\n\n\ti = 0;\n\twhile (i++ < 100)\n\t\tif (lp->a->read_csr(ioaddr, CSR0) & CSR0_IDON)\n\t\t\tbreak;\n\t \n\tlp->a->write_csr(ioaddr, CSR0, CSR0_NORMAL);\n\n\tnetif_printk(lp, ifup, KERN_DEBUG, dev,\n\t\t     \"pcnet32 open after %d ticks, init block %#x csr0 %4.4x\\n\",\n\t\t     i,\n\t\t     (u32) (lp->init_dma_addr),\n\t\t     lp->a->read_csr(ioaddr, CSR0));\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn 0;\t\t \n\nerr_free_ring:\n\t \n\tpcnet32_purge_rx_ring(dev);\n\n\t \n\tlp->a->write_bcr(ioaddr, 20, 4);\n\nerr_free_irq:\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\tfree_irq(dev->irq, dev);\n\treturn rc;\n}\n\n \n\nstatic void pcnet32_purge_tx_ring(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < lp->tx_ring_size; i++) {\n\t\tlp->tx_ring[i].status = 0;\t \n\t\twmb();\t\t \n\t\tif (lp->tx_skbuff[i]) {\n\t\t\tif (!dma_mapping_error(&lp->pci_dev->dev, lp->tx_dma_addr[i]))\n\t\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t lp->tx_dma_addr[i],\n\t\t\t\t\t\t lp->tx_skbuff[i]->len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(lp->tx_skbuff[i]);\n\t\t}\n\t\tlp->tx_skbuff[i] = NULL;\n\t\tlp->tx_dma_addr[i] = 0;\n\t}\n}\n\n \nstatic int pcnet32_init_ring(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint i;\n\n\tlp->tx_full = 0;\n\tlp->cur_rx = lp->cur_tx = 0;\n\tlp->dirty_rx = lp->dirty_tx = 0;\n\n\tfor (i = 0; i < lp->rx_ring_size; i++) {\n\t\tstruct sk_buff *rx_skbuff = lp->rx_skbuff[i];\n\t\tif (!rx_skbuff) {\n\t\t\tlp->rx_skbuff[i] = netdev_alloc_skb(dev, PKT_BUF_SKB);\n\t\t\trx_skbuff = lp->rx_skbuff[i];\n\t\t\tif (!rx_skbuff) {\n\t\t\t\t \n\t\t\t\tnetif_err(lp, drv, dev, \"%s netdev_alloc_skb failed\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tskb_reserve(rx_skbuff, NET_IP_ALIGN);\n\t\t}\n\n\t\trmb();\n\t\tif (lp->rx_dma_addr[i] == 0) {\n\t\t\tlp->rx_dma_addr[i] =\n\t\t\t    dma_map_single(&lp->pci_dev->dev, rx_skbuff->data,\n\t\t\t\t\t   PKT_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&lp->pci_dev->dev, lp->rx_dma_addr[i])) {\n\t\t\t\t \n\t\t\t\tnetif_err(lp, drv, dev,\n\t\t\t\t\t  \"%s pci dma mapping error\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tlp->rx_ring[i].base = cpu_to_le32(lp->rx_dma_addr[i]);\n\t\tlp->rx_ring[i].buf_length = cpu_to_le16(NEG_BUF_SIZE);\n\t\twmb();\t\t \n\t\tlp->rx_ring[i].status = cpu_to_le16(0x8000);\n\t}\n\t \n\tfor (i = 0; i < lp->tx_ring_size; i++) {\n\t\tlp->tx_ring[i].status = 0;\t \n\t\twmb();\t\t \n\t\tlp->tx_ring[i].base = 0;\n\t\tlp->tx_dma_addr[i] = 0;\n\t}\n\n\tlp->init_block->tlen_rlen =\n\t    cpu_to_le16(lp->tx_len_bits | lp->rx_len_bits);\n\tfor (i = 0; i < 6; i++)\n\t\tlp->init_block->phys_addr[i] = dev->dev_addr[i];\n\tlp->init_block->rx_ring = cpu_to_le32(lp->rx_ring_dma_addr);\n\tlp->init_block->tx_ring = cpu_to_le32(lp->tx_ring_dma_addr);\n\twmb();\t\t\t \n\treturn 0;\n}\n\n \nstatic void pcnet32_restart(struct net_device *dev, unsigned int csr0_bits)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long ioaddr = dev->base_addr;\n\tint i;\n\n\t \n\tfor (i = 0; i < 100; i++)\n\t\tif (lp->a->read_csr(ioaddr, CSR0) & CSR0_STOP)\n\t\t\tbreak;\n\n\tif (i >= 100)\n\t\tnetif_err(lp, drv, dev, \"%s timed out waiting for stop\\n\",\n\t\t\t  __func__);\n\n\tpcnet32_purge_tx_ring(dev);\n\tif (pcnet32_init_ring(dev))\n\t\treturn;\n\n\t \n\tlp->a->write_csr(ioaddr, CSR0, CSR0_INIT);\n\ti = 0;\n\twhile (i++ < 1000)\n\t\tif (lp->a->read_csr(ioaddr, CSR0) & CSR0_IDON)\n\t\t\tbreak;\n\n\tlp->a->write_csr(ioaddr, CSR0, csr0_bits);\n}\n\nstatic void pcnet32_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long ioaddr = dev->base_addr, flags;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\t \n\tif (pcnet32_debug & NETIF_MSG_DRV)\n\t\tpr_err(\"%s: transmit timed out, status %4.4x, resetting\\n\",\n\t\t       dev->name, lp->a->read_csr(ioaddr, CSR0));\n\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\n\tdev->stats.tx_errors++;\n\tif (netif_msg_tx_err(lp)) {\n\t\tint i;\n\t\tprintk(KERN_DEBUG\n\t\t       \" Ring data dump: dirty_tx %d cur_tx %d%s cur_rx %d.\",\n\t\t       lp->dirty_tx, lp->cur_tx, lp->tx_full ? \" (full)\" : \"\",\n\t\t       lp->cur_rx);\n\t\tfor (i = 0; i < lp->rx_ring_size; i++)\n\t\t\tprintk(\"%s %08x %04x %08x %04x\", i & 1 ? \"\" : \"\\n \",\n\t\t\t       le32_to_cpu(lp->rx_ring[i].base),\n\t\t\t       (-le16_to_cpu(lp->rx_ring[i].buf_length)) &\n\t\t\t       0xffff, le32_to_cpu(lp->rx_ring[i].msg_length),\n\t\t\t       le16_to_cpu(lp->rx_ring[i].status));\n\t\tfor (i = 0; i < lp->tx_ring_size; i++)\n\t\t\tprintk(\"%s %08x %04x %08x %04x\", i & 1 ? \"\" : \"\\n \",\n\t\t\t       le32_to_cpu(lp->tx_ring[i].base),\n\t\t\t       (-le16_to_cpu(lp->tx_ring[i].length)) & 0xffff,\n\t\t\t       le32_to_cpu(lp->tx_ring[i].misc),\n\t\t\t       le16_to_cpu(lp->tx_ring[i].status));\n\t\tprintk(\"\\n\");\n\t}\n\tpcnet32_restart(dev, CSR0_NORMAL);\n\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\nstatic netdev_tx_t pcnet32_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long ioaddr = dev->base_addr;\n\tu16 status;\n\tint entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tnetif_printk(lp, tx_queued, KERN_DEBUG, dev,\n\t\t     \"%s() called, csr0 %4.4x\\n\",\n\t\t     __func__, lp->a->read_csr(ioaddr, CSR0));\n\n\t \n\tstatus = 0x8300;\n\n\t \n\n\t \n\tentry = lp->cur_tx & lp->tx_mod_mask;\n\n\t \n\n\tlp->tx_ring[entry].length = cpu_to_le16(-skb->len);\n\n\tlp->tx_ring[entry].misc = 0x00000000;\n\n\tlp->tx_dma_addr[entry] =\n\t    dma_map_single(&lp->pci_dev->dev, skb->data, skb->len,\n\t\t\t   DMA_TO_DEVICE);\n\tif (dma_mapping_error(&lp->pci_dev->dev, lp->tx_dma_addr[entry])) {\n\t\tdev_kfree_skb_any(skb);\n\t\tdev->stats.tx_dropped++;\n\t\tgoto drop_packet;\n\t}\n\tlp->tx_skbuff[entry] = skb;\n\tlp->tx_ring[entry].base = cpu_to_le32(lp->tx_dma_addr[entry]);\n\twmb();\t\t\t \n\tlp->tx_ring[entry].status = cpu_to_le16(status);\n\n\tlp->cur_tx++;\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\tlp->a->write_csr(ioaddr, CSR0, CSR0_INTEN | CSR0_TXPOLL);\n\n\tif (lp->tx_ring[(entry + 1) & lp->tx_mod_mask].base != 0) {\n\t\tlp->tx_full = 1;\n\t\tnetif_stop_queue(dev);\n\t}\ndrop_packet:\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t\npcnet32_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct pcnet32_private *lp;\n\tunsigned long ioaddr;\n\tu16 csr0;\n\tint boguscnt = max_interrupt_work;\n\n\tioaddr = dev->base_addr;\n\tlp = netdev_priv(dev);\n\n\tspin_lock(&lp->lock);\n\n\tcsr0 = lp->a->read_csr(ioaddr, CSR0);\n\twhile ((csr0 & 0x8f00) && --boguscnt >= 0) {\n\t\tif (csr0 == 0xffff)\n\t\t\tbreak;\t \n\t\t \n\t\tlp->a->write_csr(ioaddr, CSR0, csr0 & ~0x004f);\n\n\t\tnetif_printk(lp, intr, KERN_DEBUG, dev,\n\t\t\t     \"interrupt  csr0=%#2.2x new csr=%#2.2x\\n\",\n\t\t\t     csr0, lp->a->read_csr(ioaddr, CSR0));\n\n\t\t \n\t\tif (csr0 & 0x4000)\n\t\t\tdev->stats.tx_errors++;\t \n\t\tif (csr0 & 0x1000) {\n\t\t\t \n\t\t\tdev->stats.rx_errors++;\t \n\t\t}\n\t\tif (csr0 & 0x0800) {\n\t\t\tnetif_err(lp, drv, dev, \"Bus master arbitration failure, status %4.4x\\n\",\n\t\t\t\t  csr0);\n\t\t\t \n\t\t}\n\t\tif (napi_schedule_prep(&lp->napi)) {\n\t\t\tu16 val;\n\t\t\t \n\t\t\tval = lp->a->read_csr(ioaddr, CSR3);\n\t\t\tval |= 0x5f00;\n\t\t\tlp->a->write_csr(ioaddr, CSR3, val);\n\n\t\t\t__napi_schedule(&lp->napi);\n\t\t\tbreak;\n\t\t}\n\t\tcsr0 = lp->a->read_csr(ioaddr, CSR0);\n\t}\n\n\tnetif_printk(lp, intr, KERN_DEBUG, dev,\n\t\t     \"exiting interrupt, csr0=%#4.4x\\n\",\n\t\t     lp->a->read_csr(ioaddr, CSR0));\n\n\tspin_unlock(&lp->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pcnet32_close(struct net_device *dev)\n{\n\tunsigned long ioaddr = dev->base_addr;\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tdel_timer_sync(&lp->watchdog_timer);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&lp->napi);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tdev->stats.rx_missed_errors = lp->a->read_csr(ioaddr, 112);\n\n\tnetif_printk(lp, ifdown, KERN_DEBUG, dev,\n\t\t     \"Shutting down ethercard, status was %2.2x\\n\",\n\t\t     lp->a->read_csr(ioaddr, CSR0));\n\n\t \n\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\n\n\t \n\tlp->a->write_bcr(ioaddr, 20, 4);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\tfree_irq(dev->irq, dev);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tpcnet32_purge_rx_ring(dev);\n\tpcnet32_purge_tx_ring(dev);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *pcnet32_get_stats(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long ioaddr = dev->base_addr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tdev->stats.rx_missed_errors = lp->a->read_csr(ioaddr, 112);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn &dev->stats;\n}\n\n \nstatic void pcnet32_load_multicast(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tvolatile struct pcnet32_init_block *ib = lp->init_block;\n\tvolatile __le16 *mcast_table = (__le16 *)ib->filter;\n\tstruct netdev_hw_addr *ha;\n\tunsigned long ioaddr = dev->base_addr;\n\tint i;\n\tu32 crc;\n\n\t \n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tib->filter[0] = cpu_to_le32(~0U);\n\t\tib->filter[1] = cpu_to_le32(~0U);\n\t\tlp->a->write_csr(ioaddr, PCNET32_MC_FILTER, 0xffff);\n\t\tlp->a->write_csr(ioaddr, PCNET32_MC_FILTER+1, 0xffff);\n\t\tlp->a->write_csr(ioaddr, PCNET32_MC_FILTER+2, 0xffff);\n\t\tlp->a->write_csr(ioaddr, PCNET32_MC_FILTER+3, 0xffff);\n\t\treturn;\n\t}\n\t \n\tib->filter[0] = 0;\n\tib->filter[1] = 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tcrc = ether_crc_le(6, ha->addr);\n\t\tcrc = crc >> 26;\n\t\tmcast_table[crc >> 4] |= cpu_to_le16(1 << (crc & 0xf));\n\t}\n\tfor (i = 0; i < 4; i++)\n\t\tlp->a->write_csr(ioaddr, PCNET32_MC_FILTER + i,\n\t\t\t\tle16_to_cpu(mcast_table[i]));\n}\n\n \nstatic void pcnet32_set_multicast_list(struct net_device *dev)\n{\n\tunsigned long ioaddr = dev->base_addr, flags;\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint csr15, suspended;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tsuspended = pcnet32_suspend(dev, &flags, 0);\n\tcsr15 = lp->a->read_csr(ioaddr, CSR15);\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tnetif_info(lp, hw, dev, \"Promiscuous mode enabled\\n\");\n\t\tlp->init_block->mode =\n\t\t    cpu_to_le16(0x8000 | (lp->options & PCNET32_PORT_PORTSEL) <<\n\t\t\t\t7);\n\t\tlp->a->write_csr(ioaddr, CSR15, csr15 | 0x8000);\n\t} else {\n\t\tlp->init_block->mode =\n\t\t    cpu_to_le16((lp->options & PCNET32_PORT_PORTSEL) << 7);\n\t\tlp->a->write_csr(ioaddr, CSR15, csr15 & 0x7fff);\n\t\tpcnet32_load_multicast(dev);\n\t}\n\n\tif (suspended) {\n\t\tpcnet32_clr_suspend(lp, ioaddr);\n\t} else {\n\t\tlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\n\t\tpcnet32_restart(dev, CSR0_NORMAL);\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\n \nstatic int mdio_read(struct net_device *dev, int phy_id, int reg_num)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long ioaddr = dev->base_addr;\n\tu16 val_out;\n\n\tif (!lp->mii)\n\t\treturn 0;\n\n\tlp->a->write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));\n\tval_out = lp->a->read_bcr(ioaddr, 34);\n\n\treturn val_out;\n}\n\n \nstatic void mdio_write(struct net_device *dev, int phy_id, int reg_num, int val)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tunsigned long ioaddr = dev->base_addr;\n\n\tif (!lp->mii)\n\t\treturn;\n\n\tlp->a->write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));\n\tlp->a->write_bcr(ioaddr, 34, val);\n}\n\nstatic int pcnet32_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint rc;\n\tunsigned long flags;\n\n\t \n\tif (lp->mii) {\n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\trc = generic_mii_ioctl(&lp->mii_if, if_mii(rq), cmd, NULL);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t} else {\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\treturn rc;\n}\n\nstatic int pcnet32_check_otherphy(struct net_device *dev)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tstruct mii_if_info mii = lp->mii_if;\n\tu16 bmcr;\n\tint i;\n\n\tfor (i = 0; i < PCNET32_MAX_PHYS; i++) {\n\t\tif (i == lp->mii_if.phy_id)\n\t\t\tcontinue;\t \n\t\tif (lp->phymask & (1 << i)) {\n\t\t\tmii.phy_id = i;\n\t\t\tif (mii_link_ok(&mii)) {\n\t\t\t\t \n\t\t\t\tnetif_info(lp, link, dev, \"Using PHY number %d\\n\",\n\t\t\t\t\t   i);\n\n\t\t\t\t \n\t\t\t\tbmcr =\n\t\t\t\t    mdio_read(dev, lp->mii_if.phy_id, MII_BMCR);\n\t\t\t\tmdio_write(dev, lp->mii_if.phy_id, MII_BMCR,\n\t\t\t\t\t   bmcr | BMCR_ISOLATE);\n\n\t\t\t\t \n\t\t\t\tbmcr = mdio_read(dev, i, MII_BMCR);\n\t\t\t\tmdio_write(dev, i, MII_BMCR,\n\t\t\t\t\t   bmcr & ~BMCR_ISOLATE);\n\n\t\t\t\t \n\t\t\t\tlp->mii_if.phy_id = i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic void pcnet32_check_media(struct net_device *dev, int verbose)\n{\n\tstruct pcnet32_private *lp = netdev_priv(dev);\n\tint curr_link;\n\tint prev_link = netif_carrier_ok(dev) ? 1 : 0;\n\tu32 bcr9;\n\n\tif (lp->mii) {\n\t\tcurr_link = mii_link_ok(&lp->mii_if);\n\t} else if (lp->chip_version == PCNET32_79C970A) {\n\t\tulong ioaddr = dev->base_addr;\t \n\t\t \n\t\tif (!lp->autoneg && lp->port_tp)\n\t\t\tcurr_link = (lp->a->read_bcr(ioaddr, 4) != 0xc0);\n\t\telse  \n\t\t\tcurr_link = 1;\n\t} else {\n\t\tulong ioaddr = dev->base_addr;\t \n\t\tcurr_link = (lp->a->read_bcr(ioaddr, 4) != 0xc0);\n\t}\n\tif (!curr_link) {\n\t\tif (prev_link || verbose) {\n\t\t\tnetif_carrier_off(dev);\n\t\t\tnetif_info(lp, link, dev, \"link down\\n\");\n\t\t}\n\t\tif (lp->phycount > 1) {\n\t\t\tpcnet32_check_otherphy(dev);\n\t\t}\n\t} else if (verbose || !prev_link) {\n\t\tnetif_carrier_on(dev);\n\t\tif (lp->mii) {\n\t\t\tif (netif_msg_link(lp)) {\n\t\t\t\tstruct ethtool_cmd ecmd = {\n\t\t\t\t\t.cmd = ETHTOOL_GSET };\n\t\t\t\tmii_ethtool_gset(&lp->mii_if, &ecmd);\n\t\t\t\tnetdev_info(dev, \"link up, %uMbps, %s-duplex\\n\",\n\t\t\t\t\t    ethtool_cmd_speed(&ecmd),\n\t\t\t\t\t    (ecmd.duplex == DUPLEX_FULL)\n\t\t\t\t\t    ? \"full\" : \"half\");\n\t\t\t}\n\t\t\tbcr9 = lp->a->read_bcr(dev->base_addr, 9);\n\t\t\tif ((bcr9 & (1 << 0)) != lp->mii_if.full_duplex) {\n\t\t\t\tif (lp->mii_if.full_duplex)\n\t\t\t\t\tbcr9 |= (1 << 0);\n\t\t\t\telse\n\t\t\t\t\tbcr9 &= ~(1 << 0);\n\t\t\t\tlp->a->write_bcr(dev->base_addr, 9, bcr9);\n\t\t\t}\n\t\t} else {\n\t\t\tnetif_info(lp, link, dev, \"link up\\n\");\n\t\t}\n\t}\n}\n\n \n\nstatic void pcnet32_watchdog(struct timer_list *t)\n{\n\tstruct pcnet32_private *lp = from_timer(lp, t, watchdog_timer);\n\tstruct net_device *dev = lp->dev;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&lp->lock, flags);\n\tpcnet32_check_media(dev, 0);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\tmod_timer(&lp->watchdog_timer, round_jiffies(PCNET32_WATCHDOG_TIMEOUT));\n}\n\nstatic int __maybe_unused pcnet32_pm_suspend(struct device *device_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(device_d);\n\n\tif (netif_running(dev)) {\n\t\tnetif_device_detach(dev);\n\t\tpcnet32_close(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pcnet32_pm_resume(struct device *device_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(device_d);\n\n\tif (netif_running(dev)) {\n\t\tpcnet32_open(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void pcnet32_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct pcnet32_private *lp = netdev_priv(dev);\n\n\t\tunregister_netdev(dev);\n\t\tpcnet32_free_ring(dev);\n\t\trelease_region(dev->base_addr, PCNET32_TOTAL_SIZE);\n\t\tdma_free_coherent(&lp->pci_dev->dev, sizeof(*lp->init_block),\n\t\t\t\t  lp->init_block, lp->init_dma_addr);\n\t\tfree_netdev(dev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic SIMPLE_DEV_PM_OPS(pcnet32_pm_ops, pcnet32_pm_suspend, pcnet32_pm_resume);\n\nstatic struct pci_driver pcnet32_driver = {\n\t.name = DRV_NAME,\n\t.probe = pcnet32_probe_pci,\n\t.remove = pcnet32_remove_one,\n\t.id_table = pcnet32_pci_tbl,\n\t.driver = {\n\t\t.pm = &pcnet32_pm_ops,\n\t},\n};\n\n \nstatic int debug = -1;\nstatic int tx_start_pt = -1;\nstatic int pcnet32_have_pci;\n\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, DRV_NAME \" debug level\");\nmodule_param(max_interrupt_work, int, 0);\nMODULE_PARM_DESC(max_interrupt_work,\n\t\t DRV_NAME \" maximum events handled per interrupt\");\nmodule_param(rx_copybreak, int, 0);\nMODULE_PARM_DESC(rx_copybreak,\n\t\t DRV_NAME \" copy breakpoint for copy-only-tiny-frames\");\nmodule_param(tx_start_pt, int, 0);\nMODULE_PARM_DESC(tx_start_pt, DRV_NAME \" transmit start point (0-3)\");\nmodule_param(pcnet32vlb, int, 0);\nMODULE_PARM_DESC(pcnet32vlb, DRV_NAME \" Vesa local bus (VLB) support (0/1)\");\nmodule_param_array(options, int, NULL, 0);\nMODULE_PARM_DESC(options, DRV_NAME \" initial option setting(s) (0-15)\");\nmodule_param_array(full_duplex, int, NULL, 0);\nMODULE_PARM_DESC(full_duplex, DRV_NAME \" full duplex setting(s) (1)\");\n \nmodule_param_array(homepna, int, NULL, 0);\nMODULE_PARM_DESC(homepna,\n\t\t DRV_NAME\n\t\t \" mode for 79C978 cards (1 for HomePNA, 0 for Ethernet, default Ethernet\");\n\nMODULE_AUTHOR(\"Thomas Bogendoerfer\");\nMODULE_DESCRIPTION(\"Driver for PCnet32 and PCnetPCI based ethercards\");\nMODULE_LICENSE(\"GPL\");\n\n#define PCNET32_MSG_DEFAULT (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)\n\nstatic int __init pcnet32_init_module(void)\n{\n\tpcnet32_debug = netif_msg_init(debug, PCNET32_MSG_DEFAULT);\n\n\tif ((tx_start_pt >= 0) && (tx_start_pt <= 3))\n\t\ttx_start = tx_start_pt;\n\n\t \n\tif (!pci_register_driver(&pcnet32_driver))\n\t\tpcnet32_have_pci = 1;\n\n\t \n\tif (pcnet32vlb)\n\t\tpcnet32_probe_vlbus(pcnet32_portlist);\n\n\tif (cards_found && (pcnet32_debug & NETIF_MSG_PROBE))\n\t\tpr_info(\"%d cards_found\\n\", cards_found);\n\n\treturn (pcnet32_have_pci + cards_found) ? 0 : -ENODEV;\n}\n\nstatic void __exit pcnet32_cleanup_module(void)\n{\n\tstruct net_device *next_dev;\n\n\twhile (pcnet32_dev) {\n\t\tstruct pcnet32_private *lp = netdev_priv(pcnet32_dev);\n\t\tnext_dev = lp->next;\n\t\tunregister_netdev(pcnet32_dev);\n\t\tpcnet32_free_ring(pcnet32_dev);\n\t\trelease_region(pcnet32_dev->base_addr, PCNET32_TOTAL_SIZE);\n\t\tdma_free_coherent(&lp->pci_dev->dev, sizeof(*lp->init_block),\n\t\t\t\t  lp->init_block, lp->init_dma_addr);\n\t\tfree_netdev(pcnet32_dev);\n\t\tpcnet32_dev = next_dev;\n\t}\n\n\tif (pcnet32_have_pci)\n\t\tpci_unregister_driver(&pcnet32_driver);\n}\n\nmodule_init(pcnet32_init_module);\nmodule_exit(pcnet32_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}