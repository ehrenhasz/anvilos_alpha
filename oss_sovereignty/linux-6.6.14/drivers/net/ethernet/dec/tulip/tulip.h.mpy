{
  "module_name": "tulip.h",
  "hash_id": "53f022d7158fc191bc00097ded64f77697c60439d0ff3aa001746a4dc88ebb16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/tulip.h",
  "human_readable_source": " \n\n#ifndef __NET_TULIP_H__\n#define __NET_TULIP_H__\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n\n\n\n \n#define TULIP_DEBUG 1\n\n#ifdef CONFIG_TULIP_MMIO\n#define TULIP_BAR\t1\t \n#else\n#define TULIP_BAR\t0\t \n#endif\n\n\n\nstruct tulip_chip_table {\n\tchar *chip_name;\n\tint io_size;\n\tint valid_intrs;\t \n\tint flags;\n\tvoid (*media_timer) (struct timer_list *);\n\twork_func_t media_task;\n};\n\n\nenum tbl_flag {\n\tHAS_MII\t\t\t= 0x00001,\n\tHAS_MEDIA_TABLE\t\t= 0x00002,\n\tCSR12_IN_SROM\t\t= 0x00004,\n\tALWAYS_CHECK_MII\t= 0x00008,\n\tHAS_ACPI\t\t= 0x00010,\n\tMC_HASH_ONLY\t\t= 0x00020,  \n\tHAS_PNICNWAY\t\t= 0x00080,\n\tHAS_NWAY\t\t= 0x00040,  \n\tHAS_INTR_MITIGATION\t= 0x00100,\n\tIS_ASIX\t\t\t= 0x00200,\n\tHAS_8023X\t\t= 0x00400,\n\tCOMET_MAC_ADDR\t\t= 0x00800,\n\tHAS_PCI_MWI\t\t= 0x01000,\n\tHAS_PHY_IRQ\t\t= 0x02000,\n\tHAS_SWAPPED_SEEPROM\t= 0x04000,\n\tNEEDS_FAKE_MEDIA_TABLE\t= 0x08000,\n\tCOMET_PM\t\t= 0x10000,\n};\n\n\n \n \nenum chips {\n\tDC21040 = 0,\n\tDC21041 = 1,\n\tDC21140 = 2,\n\tDC21142 = 3, DC21143 = 3,\n\tLC82C168,\n\tMX98713,\n\tMX98715,\n\tMX98725,\n\tAX88140,\n\tPNIC2,\n\tCOMET,\n\tCOMPEX9881,\n\tI21145,\n\tDM910X,\n\tCONEXANT,\n};\n\n\nenum MediaIs {\n\tMediaIsFD = 1,\n\tMediaAlwaysFD = 2,\n\tMediaIsMII = 4,\n\tMediaIsFx = 8,\n\tMediaIs100 = 16\n};\n\n\n \nenum tulip_offsets {\n\tCSR0 = 0,\n\tCSR1 = 0x08,\n\tCSR2 = 0x10,\n\tCSR3 = 0x18,\n\tCSR4 = 0x20,\n\tCSR5 = 0x28,\n\tCSR6 = 0x30,\n\tCSR7 = 0x38,\n\tCSR8 = 0x40,\n\tCSR9 = 0x48,\n\tCSR10 = 0x50,\n\tCSR11 = 0x58,\n\tCSR12 = 0x60,\n\tCSR13 = 0x68,\n\tCSR14 = 0x70,\n\tCSR15 = 0x78,\n\tCSR18 = 0x88,\n\tCSR19 = 0x8c,\n\tCSR20 = 0x90,\n\tCSR27 = 0xAC,\n\tCSR28 = 0xB0,\n};\n\n \nenum pci_cfg_driver_reg {\n\tCFDD = 0x40,\n\tCFDD_Sleep = (1 << 31),\n\tCFDD_Snooze = (1 << 30),\n};\n\n#define RxPollInt (RxIntr|RxNoBuf|RxDied|RxJabber)\n\n \nenum status_bits {\n\tTimerInt = 0x800,\n\tSystemError = 0x2000,\n\tTPLnkFail = 0x1000,\n\tTPLnkPass = 0x10,\n\tNormalIntr = 0x10000,\n\tAbnormalIntr = 0x8000,\n\tRxJabber = 0x200,\n\tRxDied = 0x100,\n\tRxNoBuf = 0x80,\n\tRxIntr = 0x40,\n\tTxFIFOUnderflow = 0x20,\n\tRxErrIntr = 0x10,\n\tTxJabber = 0x08,\n\tTxNoBuf = 0x04,\n\tTxDied = 0x02,\n\tTxIntr = 0x01,\n};\n\n \n#define CSR5_TS\t0x00700000\n#define CSR5_RS\t0x000e0000\n\nenum tulip_mode_bits {\n\tTxThreshold\t\t= (1 << 22),\n\tFullDuplex\t\t= (1 << 9),\n\tTxOn\t\t\t= 0x2000,\n\tAcceptBroadcast\t\t= 0x0100,\n\tAcceptAllMulticast\t= 0x0080,\n\tAcceptAllPhys\t\t= 0x0040,\n\tAcceptRunt\t\t= 0x0008,\n\tRxOn\t\t\t= 0x0002,\n\tRxTx\t\t\t= (TxOn | RxOn),\n};\n\n\nenum tulip_busconfig_bits {\n\tMWI\t\t\t= (1 << 24),\n\tMRL\t\t\t= (1 << 23),\n\tMRM\t\t\t= (1 << 21),\n\tCALShift\t\t= 14,\n\tBurstLenShift\t\t= 8,\n};\n\n\n \nstruct tulip_rx_desc {\n\t__le32 status;\n\t__le32 length;\n\t__le32 buffer1;\n\t__le32 buffer2;\n};\n\n\nstruct tulip_tx_desc {\n\t__le32 status;\n\t__le32 length;\n\t__le32 buffer1;\n\t__le32 buffer2;\t\t \n};\n\n\nenum desc_status_bits {\n\tDescOwned    = 0x80000000,\n\tDescWholePkt = 0x60000000,\n\tDescEndPkt   = 0x40000000,\n\tDescStartPkt = 0x20000000,\n\tDescEndRing  = 0x02000000,\n\tDescUseLink  = 0x01000000,\n\n\t \n\tRxDescErrorSummary = 0x8000,\n\tRxDescCRCError = 0x0002,\n\tRxDescCollisionSeen = 0x0040,\n\n\t \n\tRxDescFrameTooLong = 0x0080,\n\tRxDescRunt = 0x0800,\n\tRxDescDescErr = 0x4000,\n\tRxWholePkt   = 0x00000300,\n\t \n\tRxLengthOver2047 = 0x38000010\n};\n\n\nenum t21143_csr6_bits {\n\tcsr6_sc = (1<<31),\n\tcsr6_ra = (1<<30),\n\tcsr6_ign_dest_msb = (1<<26),\n\tcsr6_mbo = (1<<25),\n\tcsr6_scr = (1<<24),   \n\tcsr6_pcs = (1<<23),   \n\tcsr6_ttm = (1<<22),   \n\tcsr6_sf = (1<<21),    \n\tcsr6_hbd = (1<<19),   \n\tcsr6_ps = (1<<18),    \n\tcsr6_ca = (1<<17),    \n\tcsr6_trh = (1<<15),   \n\tcsr6_trl = (1<<14),   \n\n\t \n\n\t \n\n\tcsr6_fc = (1<<12),    \n\tcsr6_om_int_loop = (1<<10),  \n\tcsr6_om_ext_loop = (1<<11),  \n\t \n\tcsr6_fd = (1<<9),     \n\tcsr6_pm = (1<<7),     \n\tcsr6_pr = (1<<6),     \n\tcsr6_sb = (1<<5),     \n\tcsr6_if = (1<<4),     \n\tcsr6_pb = (1<<3),     \n\tcsr6_ho = (1<<2),     \n\tcsr6_hp = (1<<0),     \n\n\tcsr6_mask_capture = (csr6_sc | csr6_ca),\n\tcsr6_mask_defstate = (csr6_mask_capture | csr6_mbo),\n\tcsr6_mask_hdcap = (csr6_mask_defstate | csr6_hbd | csr6_ps),\n\tcsr6_mask_hdcaptt = (csr6_mask_hdcap  | csr6_trh | csr6_trl),\n\tcsr6_mask_fullcap = (csr6_mask_hdcaptt | csr6_fd),\n\tcsr6_mask_fullpromisc = (csr6_pr | csr6_pm),\n\tcsr6_mask_filters = (csr6_hp | csr6_ho | csr6_if),\n\tcsr6_mask_100bt = (csr6_scr | csr6_pcs | csr6_hbd),\n};\n\nenum tulip_comet_csr13_bits {\n \n        comet_csr13_linkoffe = (1 << 17),\n        comet_csr13_linkone = (1 << 16),\n        comet_csr13_wfre = (1 << 10),\n        comet_csr13_mpre = (1 << 9),\n        comet_csr13_lsce = (1 << 8),\n        comet_csr13_wfr = (1 << 2),\n        comet_csr13_mpr = (1 << 1),\n        comet_csr13_lsc = (1 << 0),\n};\n\nenum tulip_comet_csr18_bits {\n        comet_csr18_pmes_sticky = (1 << 24),\n        comet_csr18_pm_mode = (1 << 19),\n        comet_csr18_apm_mode = (1 << 18),\n        comet_csr18_d3a = (1 << 7)\n};\n\nenum tulip_comet_csr20_bits {\n        comet_csr20_pmes = (1 << 15),\n};\n\n \n\n#define TX_RING_SIZE\t32\n#define RX_RING_SIZE\t128\n#define MEDIA_MASK     31\n\n \n#define PKT_BUF_SZ\t(1536 + 4)\t \n\n#define TULIP_MIN_CACHE_LINE\t8\t \n\n#if defined(__sparc__) || defined(__hppa__)\n \n#define TULIP_MAX_CACHE_LINE\t16\t \n#else\n#define TULIP_MAX_CACHE_LINE\t32\t \n#endif\n\n\n \n#define DESC_RING_WRAP 0x02000000\n\n\n#define EEPROM_SIZE 512 \t \n\n\n#define RUN_AT(x) (jiffies + (x))\n\n#define get_u16(ptr) get_unaligned_le16((ptr))\n\nstruct medialeaf {\n\tu8 type;\n\tu8 media;\n\tunsigned char *leafdata;\n};\n\n\nstruct mediatable {\n\tu16 defaultmedia;\n\tu8 leafcount;\n\tu8 csr12dir;\t\t \n\tunsigned has_mii:1;\n\tunsigned has_nonmii:1;\n\tunsigned has_reset:6;\n\tu32 csr15dir;\n\tu32 csr15val;\t\t \n\tstruct medialeaf mleaf[];\n};\n\n\nstruct mediainfo {\n\tstruct mediainfo *next;\n\tint info_type;\n\tint index;\n\tunsigned char *info;\n};\n\nstruct ring_info {\n\tstruct sk_buff\t*skb;\n\tdma_addr_t\tmapping;\n};\n\n\nstruct tulip_private {\n\tconst char *product_name;\n\tstruct net_device *next_module;\n\tstruct tulip_rx_desc *rx_ring;\n\tstruct tulip_tx_desc *tx_ring;\n\tdma_addr_t rx_ring_dma;\n\tdma_addr_t tx_ring_dma;\n\t \n\tstruct ring_info tx_buffers[TX_RING_SIZE];\n\t \n\tstruct ring_info rx_buffers[RX_RING_SIZE];\n\tu16 setup_frame[96];\t \n\tint chip_id;\n\tint revision;\n\tint flags;\n\tstruct napi_struct napi;\n\tstruct timer_list timer;\t \n\tstruct timer_list oom_timer;     \n\tu32 mc_filter[2];\n\tspinlock_t lock;\n\tspinlock_t mii_lock;\n\tunsigned int cur_rx, cur_tx;\t \n\tunsigned int dirty_rx, dirty_tx;\t \n\n#ifdef \tCONFIG_TULIP_NAPI_HW_MITIGATION\n        int mit_on;\n#endif\n\tunsigned int full_duplex:1;\t \n\tunsigned int full_duplex_lock:1;\n\tunsigned int fake_addr:1;\t \n\tunsigned int default_port:4;\t \n\tunsigned int media2:4;\t \n\tunsigned int medialock:1;\t \n\tunsigned int mediasense:1;\t \n\tunsigned int nway:1, nwayset:1;\t\t \n\tunsigned int timeout_recovery:1;\n\tunsigned int csr0;\t \n\tunsigned int csr6;\t \n\tunsigned char eeprom[EEPROM_SIZE];\t \n\tvoid (*link_change) (struct net_device * dev, int csr5);\n        struct ethtool_wolinfo wolinfo;         \n\tu16 sym_advertise, mii_advertise;  \n\tu16 lpar;\t\t \n\tu16 advertising[4];\n\tsigned char phys[4], mii_cnt;\t \n\tstruct mediatable *mtable;\n\tint cur_index;\t\t \n\tint saved_if_port;\n\tstruct pci_dev *pdev;\n\tint ttimer;\n\tint susp_rx;\n\tunsigned long nir;\n\tvoid __iomem *base_addr;\n\tint csr12_shadow;\n\tint pad0;\t\t \n\tstruct work_struct media_work;\n\tstruct net_device *dev;\n};\n\n\nstruct eeprom_fixup {\n\tchar *name;\n\tunsigned char addr0;\n\tunsigned char addr1;\n\tunsigned char addr2;\n\tu16 newtable[32];\t \n};\n\n\n \nextern u16 t21142_csr14[];\nvoid t21142_media_task(struct work_struct *work);\nvoid t21142_start_nway(struct net_device *dev);\nvoid t21142_lnk_change(struct net_device *dev, int csr5);\n\n\n \nvoid pnic2_lnk_change(struct net_device *dev, int csr5);\nvoid pnic2_timer(struct timer_list *t);\nvoid pnic2_start_nway(struct net_device *dev);\n\n \nvoid tulip_parse_eeprom(struct net_device *dev);\nint tulip_read_eeprom(struct net_device *dev, int location, int addr_len);\n\n \nextern unsigned int tulip_max_interrupt_work;\nextern int tulip_rx_copybreak;\nirqreturn_t tulip_interrupt(int irq, void *dev_instance);\nint tulip_refill_rx(struct net_device *dev);\n#ifdef CONFIG_TULIP_NAPI\nint tulip_poll(struct napi_struct *napi, int budget);\n#endif\n\n\n \nint tulip_mdio_read(struct net_device *dev, int phy_id, int location);\nvoid tulip_mdio_write(struct net_device *dev, int phy_id, int location, int value);\nvoid tulip_select_media(struct net_device *dev, int startup);\nint tulip_check_duplex(struct net_device *dev);\nvoid tulip_find_mii (struct net_device *dev, int board_idx);\n\n \nvoid pnic_do_nway(struct net_device *dev);\nvoid pnic_lnk_change(struct net_device *dev, int csr5);\nvoid pnic_timer(struct timer_list *t);\n\n \nvoid tulip_media_task(struct work_struct *work);\nvoid mxic_timer(struct timer_list *t);\nvoid comet_timer(struct timer_list *t);\n\n \nextern int tulip_debug;\nextern const char * const medianame[];\nextern const char tulip_media_cap[];\nextern const struct tulip_chip_table tulip_tbl[];\nvoid oom_timer(struct timer_list *t);\nextern u8 t21040_csr13[];\n\nstatic inline void tulip_start_rxtx(struct tulip_private *tp)\n{\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tiowrite32(tp->csr6 | RxTx, ioaddr + CSR6);\n\tbarrier();\n\t(void) ioread32(ioaddr + CSR6);  \n}\n\nstatic inline void tulip_stop_rxtx(struct tulip_private *tp)\n{\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tu32 csr6 = ioread32(ioaddr + CSR6);\n\n\tif (csr6 & RxTx) {\n\t\tunsigned i=1300/10;\n\t\tiowrite32(csr6 & ~RxTx, ioaddr + CSR6);\n\t\tbarrier();\n\t\t \n\t\twhile (--i && (ioread32(ioaddr + CSR5) & (CSR5_TS|CSR5_RS)))\n\t\t\tudelay(10);\n\n\t\tif (!i)\n\t\t\tnetdev_dbg(tp->dev, \"tulip_stop_rxtx() failed (CSR5 0x%x CSR6 0x%x)\\n\",\n\t\t\t\t   ioread32(ioaddr + CSR5),\n\t\t\t\t   ioread32(ioaddr + CSR6));\n\t}\n}\n\nstatic inline void tulip_restart_rxtx(struct tulip_private *tp)\n{\n\ttulip_stop_rxtx(tp);\n\tudelay(5);\n\ttulip_start_rxtx(tp);\n}\n\nstatic inline void tulip_tx_timeout_complete(struct tulip_private *tp, void __iomem *ioaddr)\n{\n\t \n\ttulip_restart_rxtx(tp);\n\t \n\tiowrite32(0, ioaddr + CSR1);\n\n\ttp->dev->stats.tx_errors++;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}