{
  "module_name": "media.c",
  "hash_id": "980ea821b0c6917b5c171674989af4ce2ae932baa89b6712a19360bd7c78a862",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/media.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include \"tulip.h\"\n\n\n \n#define mdio_delay() ioread32(mdio_addr)\n\n \n#define MDIO_SHIFT_CLK\t\t0x10000\n#define MDIO_DATA_WRITE0\t0x00000\n#define MDIO_DATA_WRITE1\t0x20000\n#define MDIO_ENB\t\t0x00000  \n#define MDIO_ENB_IN\t\t0x40000\n#define MDIO_DATA_READ\t\t0x80000\n\nstatic const unsigned char comet_miireg2offset[32] = {\n\t0xB4, 0xB8, 0xBC, 0xC0,  0xC4, 0xC8, 0xCC, 0,  0,0,0,0,  0,0,0,0,\n\t0,0xD0,0,0,  0,0,0,0,  0,0,0,0, 0, 0xD4, 0xD8, 0xDC, };\n\n\n \n\nint tulip_mdio_read(struct net_device *dev, int phy_id, int location)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint i;\n\tint read_cmd = (0xf6 << 10) | ((phy_id & 0x1f) << 5) | location;\n\tint retval = 0;\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tvoid __iomem *mdio_addr = ioaddr + CSR9;\n\tunsigned long flags;\n\n\tif (location & ~0x1f)\n\t\treturn 0xffff;\n\n\tif (tp->chip_id == COMET  &&  phy_id == 30) {\n\t\tif (comet_miireg2offset[location])\n\t\t\treturn ioread32(ioaddr + comet_miireg2offset[location]);\n\t\treturn 0xffff;\n\t}\n\n\tspin_lock_irqsave(&tp->mii_lock, flags);\n\tif (tp->chip_id == LC82C168) {\n\t\tiowrite32(0x60020000 + (phy_id<<23) + (location<<18), ioaddr + 0xA0);\n\t\tioread32(ioaddr + 0xA0);\n\t\tioread32(ioaddr + 0xA0);\n\t\tfor (i = 1000; i >= 0; --i) {\n\t\t\tbarrier();\n\t\t\tif ( ! ((retval = ioread32(ioaddr + 0xA0)) & 0x80000000))\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&tp->mii_lock, flags);\n\t\treturn retval & 0xffff;\n\t}\n\n\t \n\tfor (i = 32; i >= 0; i--) {\n\t\tiowrite32(MDIO_ENB | MDIO_DATA_WRITE1, mdio_addr);\n\t\tmdio_delay();\n\t\tiowrite32(MDIO_ENB | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);\n\t\tmdio_delay();\n\t}\n\t \n\tfor (i = 15; i >= 0; i--) {\n\t\tint dataval = (read_cmd & (1 << i)) ? MDIO_DATA_WRITE1 : 0;\n\n\t\tiowrite32(MDIO_ENB | dataval, mdio_addr);\n\t\tmdio_delay();\n\t\tiowrite32(MDIO_ENB | dataval | MDIO_SHIFT_CLK, mdio_addr);\n\t\tmdio_delay();\n\t}\n\t \n\tfor (i = 19; i > 0; i--) {\n\t\tiowrite32(MDIO_ENB_IN, mdio_addr);\n\t\tmdio_delay();\n\t\tretval = (retval << 1) | ((ioread32(mdio_addr) & MDIO_DATA_READ) ? 1 : 0);\n\t\tiowrite32(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\n\t\tmdio_delay();\n\t}\n\n\tspin_unlock_irqrestore(&tp->mii_lock, flags);\n\treturn (retval>>1) & 0xffff;\n}\n\nvoid tulip_mdio_write(struct net_device *dev, int phy_id, int location, int val)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint i;\n\tint cmd = (0x5002 << 16) | ((phy_id & 0x1f) << 23) | (location<<18) | (val & 0xffff);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tvoid __iomem *mdio_addr = ioaddr + CSR9;\n\tunsigned long flags;\n\n\tif (location & ~0x1f)\n\t\treturn;\n\n\tif (tp->chip_id == COMET && phy_id == 30) {\n\t\tif (comet_miireg2offset[location])\n\t\t\tiowrite32(val, ioaddr + comet_miireg2offset[location]);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&tp->mii_lock, flags);\n\tif (tp->chip_id == LC82C168) {\n\t\tiowrite32(cmd, ioaddr + 0xA0);\n\t\tfor (i = 1000; i >= 0; --i) {\n\t\t\tbarrier();\n\t\t\tif ( ! (ioread32(ioaddr + 0xA0) & 0x80000000))\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&tp->mii_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 32; i >= 0; i--) {\n\t\tiowrite32(MDIO_ENB | MDIO_DATA_WRITE1, mdio_addr);\n\t\tmdio_delay();\n\t\tiowrite32(MDIO_ENB | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);\n\t\tmdio_delay();\n\t}\n\t \n\tfor (i = 31; i >= 0; i--) {\n\t\tint dataval = (cmd & (1 << i)) ? MDIO_DATA_WRITE1 : 0;\n\t\tiowrite32(MDIO_ENB | dataval, mdio_addr);\n\t\tmdio_delay();\n\t\tiowrite32(MDIO_ENB | dataval | MDIO_SHIFT_CLK, mdio_addr);\n\t\tmdio_delay();\n\t}\n\t \n\tfor (i = 2; i > 0; i--) {\n\t\tiowrite32(MDIO_ENB_IN, mdio_addr);\n\t\tmdio_delay();\n\t\tiowrite32(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\n\t\tmdio_delay();\n\t}\n\n\tspin_unlock_irqrestore(&tp->mii_lock, flags);\n}\n\n\n \nvoid tulip_select_media(struct net_device *dev, int startup)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tstruct mediatable *mtable = tp->mtable;\n\tu32 new_csr6;\n\tint i;\n\n\tif (mtable) {\n\t\tstruct medialeaf *mleaf = &mtable->mleaf[tp->cur_index];\n\t\tunsigned char *p = mleaf->leafdata;\n\t\tswitch (mleaf->type) {\n\t\tcase 0:\t\t\t\t\t \n\t\t\tif (tulip_debug > 1)\n\t\t\t\tnetdev_dbg(dev, \"Using a 21140 non-MII transceiver with control setting %02x\\n\",\n\t\t\t\t\t   p[1]);\n\t\t\tdev->if_port = p[0];\n\t\t\tif (startup)\n\t\t\t\tiowrite32(mtable->csr12dir | 0x100, ioaddr + CSR12);\n\t\t\tiowrite32(p[1], ioaddr + CSR12);\n\t\t\tnew_csr6 = 0x02000000 | ((p[2] & 0x71) << 18);\n\t\t\tbreak;\n\t\tcase 2: case 4: {\n\t\t\tu16 setup[5];\n\t\t\tu32 csr13val, csr14val, csr15dir, csr15val;\n\t\t\tfor (i = 0; i < 5; i++)\n\t\t\t\tsetup[i] = get_u16(&p[i*2 + 1]);\n\n\t\t\tdev->if_port = p[0] & MEDIA_MASK;\n\t\t\tif (tulip_media_cap[dev->if_port] & MediaAlwaysFD)\n\t\t\t\ttp->full_duplex = 1;\n\n\t\t\tif (startup && mtable->has_reset) {\n\t\t\t\tstruct medialeaf *rleaf = &mtable->mleaf[mtable->has_reset];\n\t\t\t\tunsigned char *rst = rleaf->leafdata;\n\t\t\t\tif (tulip_debug > 1)\n\t\t\t\t\tnetdev_dbg(dev, \"Resetting the transceiver\\n\");\n\t\t\t\tfor (i = 0; i < rst[0]; i++)\n\t\t\t\t\tiowrite32(get_u16(rst + 1 + (i<<1)) << 16, ioaddr + CSR15);\n\t\t\t}\n\t\t\tif (tulip_debug > 1)\n\t\t\t\tnetdev_dbg(dev, \"21143 non-MII %s transceiver control %04x/%04x\\n\",\n\t\t\t\t\t   medianame[dev->if_port],\n\t\t\t\t\t   setup[0], setup[1]);\n\t\t\tif (p[0] & 0x40) {\t \n\t\t\t\tcsr13val = setup[0];\n\t\t\t\tcsr14val = setup[1];\n\t\t\t\tcsr15dir = (setup[3]<<16) | setup[2];\n\t\t\t\tcsr15val = (setup[4]<<16) | setup[2];\n\t\t\t\tiowrite32(0, ioaddr + CSR13);\n\t\t\t\tiowrite32(csr14val, ioaddr + CSR14);\n\t\t\t\tiowrite32(csr15dir, ioaddr + CSR15);\t \n\t\t\t\tiowrite32(csr15val, ioaddr + CSR15);\t \n\t\t\t\tiowrite32(csr13val, ioaddr + CSR13);\n\t\t\t} else {\n\t\t\t\tcsr13val = 1;\n\t\t\t\tcsr14val = 0;\n\t\t\t\tcsr15dir = (setup[0]<<16) | 0x0008;\n\t\t\t\tcsr15val = (setup[1]<<16) | 0x0008;\n\t\t\t\tif (dev->if_port <= 4)\n\t\t\t\t\tcsr14val = t21142_csr14[dev->if_port];\n\t\t\t\tif (startup) {\n\t\t\t\t\tiowrite32(0, ioaddr + CSR13);\n\t\t\t\t\tiowrite32(csr14val, ioaddr + CSR14);\n\t\t\t\t}\n\t\t\t\tiowrite32(csr15dir, ioaddr + CSR15);\t \n\t\t\t\tiowrite32(csr15val, ioaddr + CSR15);\t \n\t\t\t\tif (startup) iowrite32(csr13val, ioaddr + CSR13);\n\t\t\t}\n\t\t\tif (tulip_debug > 1)\n\t\t\t\tnetdev_dbg(dev, \"Setting CSR15 to %08x/%08x\\n\",\n\t\t\t\t\t   csr15dir, csr15val);\n\t\t\tif (mleaf->type == 4)\n\t\t\t\tnew_csr6 = 0x82020000 | ((setup[2] & 0x71) << 18);\n\t\t\telse\n\t\t\t\tnew_csr6 = 0x82420000;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1: case 3: {\n\t\t\tint phy_num = p[0];\n\t\t\tint init_length = p[1];\n\t\t\tu16 *misc_info, tmp_info;\n\n\t\t\tdev->if_port = 11;\n\t\t\tnew_csr6 = 0x020E0000;\n\t\t\tif (mleaf->type == 3) {\t \n\t\t\t\tu16 *init_sequence = (u16*)(p+2);\n\t\t\t\tu16 *reset_sequence = &((u16*)(p+3))[init_length];\n\t\t\t\tint reset_length = p[2 + init_length*2];\n\t\t\t\tmisc_info = reset_sequence + reset_length;\n\t\t\t\tif (startup) {\n\t\t\t\t\tint timeout = 10;\t \n\t\t\t\t\tfor (i = 0; i < reset_length; i++)\n\t\t\t\t\t\tiowrite32(get_u16(&reset_sequence[i]) << 16, ioaddr + CSR15);\n\n\t\t\t\t\t \n\t\t\t\t\tioread32(ioaddr + CSR15);\n\n\t\t\t\t\t \n\t\t\t\t\tudelay(500);\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\twhile (timeout-- &&\n\t\t\t\t\t\t(tulip_mdio_read (dev, phy_num, MII_BMCR) & BMCR_RESET))\n\t\t\t\t\t\tudelay(100);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < init_length; i++)\n\t\t\t\t\tiowrite32(get_u16(&init_sequence[i]) << 16, ioaddr + CSR15);\n\n\t\t\t\tioread32(ioaddr + CSR15);\t \n\t\t\t} else {\n\t\t\t\tu8 *init_sequence = p + 2;\n\t\t\t\tu8 *reset_sequence = p + 3 + init_length;\n\t\t\t\tint reset_length = p[2 + init_length];\n\t\t\t\tmisc_info = (u16*)(reset_sequence + reset_length);\n\t\t\t\tif (startup) {\n\t\t\t\t\tint timeout = 10;\t \n\t\t\t\t\tiowrite32(mtable->csr12dir | 0x100, ioaddr + CSR12);\n\t\t\t\t\tfor (i = 0; i < reset_length; i++)\n\t\t\t\t\t\tiowrite32(reset_sequence[i], ioaddr + CSR12);\n\n\t\t\t\t\t \n\t\t\t\t\tioread32(ioaddr + CSR12);\n\n\t\t\t\t\t \n\t\t\t\t\tudelay(500);\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\twhile (timeout-- &&\n\t\t\t\t\t\t(tulip_mdio_read (dev, phy_num, MII_BMCR) & BMCR_RESET))\n\t\t\t\t\t\tudelay(100);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < init_length; i++)\n\t\t\t\t\tiowrite32(init_sequence[i], ioaddr + CSR12);\n\n\t\t\t\tioread32(ioaddr + CSR12);\t \n\t\t\t}\n\n\t\t\ttmp_info = get_u16(&misc_info[1]);\n\t\t\tif (tmp_info)\n\t\t\t\ttp->advertising[phy_num] = tmp_info | 1;\n\t\t\tif (tmp_info && startup < 2) {\n\t\t\t\tif (tp->mii_advertise == 0)\n\t\t\t\t\ttp->mii_advertise = tp->advertising[phy_num];\n\t\t\t\tif (tulip_debug > 1)\n\t\t\t\t\tnetdev_dbg(dev, \" Advertising %04x on MII %d\\n\",\n\t\t\t\t\t\t   tp->mii_advertise,\n\t\t\t\t\t\t   tp->phys[phy_num]);\n\t\t\t\ttulip_mdio_write(dev, tp->phys[phy_num], 4, tp->mii_advertise);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 5: case 6: {\n\t\t\tnew_csr6 = 0;  \n\n\t\t\tif (startup && mtable->has_reset) {\n\t\t\t\tstruct medialeaf *rleaf = &mtable->mleaf[mtable->has_reset];\n\t\t\t\tunsigned char *rst = rleaf->leafdata;\n\t\t\t\tif (tulip_debug > 1)\n\t\t\t\t\tnetdev_dbg(dev, \"Resetting the transceiver\\n\");\n\t\t\t\tfor (i = 0; i < rst[0]; i++)\n\t\t\t\t\tiowrite32(get_u16(rst + 1 + (i<<1)) << 16, ioaddr + CSR15);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tnetdev_dbg(dev, \" Invalid media table selection %d\\n\",\n\t\t\t\t   mleaf->type);\n\t\t\tnew_csr6 = 0x020E0000;\n\t\t}\n\t\tif (tulip_debug > 1)\n\t\t\tnetdev_dbg(dev, \"Using media type %s, CSR12 is %02x\\n\",\n\t\t\t\t   medianame[dev->if_port],\n\t\t\t\t   ioread32(ioaddr + CSR12) & 0xff);\n\t} else if (tp->chip_id == LC82C168) {\n\t\tif (startup && ! tp->medialock)\n\t\t\tdev->if_port = tp->mii_cnt ? 11 : 0;\n\t\tif (tulip_debug > 1)\n\t\t\tnetdev_dbg(dev, \"PNIC PHY status is %3.3x, media %s\\n\",\n\t\t\t\t   ioread32(ioaddr + 0xB8),\n\t\t\t\t   medianame[dev->if_port]);\n\t\tif (tp->mii_cnt) {\n\t\t\tnew_csr6 = 0x810C0000;\n\t\t\tiowrite32(0x0001, ioaddr + CSR15);\n\t\t\tiowrite32(0x0201B07A, ioaddr + 0xB8);\n\t\t} else if (startup) {\n\t\t\t \n\t\t\tiowrite32(0x32, ioaddr + CSR12);\n\t\t\tnew_csr6 = 0x00420000;\n\t\t\tiowrite32(0x0001B078, ioaddr + 0xB8);\n\t\t\tiowrite32(0x0201B078, ioaddr + 0xB8);\n\t\t} else if (dev->if_port == 3  ||  dev->if_port == 5) {\n\t\t\tiowrite32(0x33, ioaddr + CSR12);\n\t\t\tnew_csr6 = 0x01860000;\n\t\t\t \n\t\t\tiowrite32(0x0001F868, ioaddr + 0xB8);\n\t\t} else {\n\t\t\tiowrite32(0x32, ioaddr + CSR12);\n\t\t\tnew_csr6 = 0x00420000;\n\t\t\tiowrite32(0x1F078, ioaddr + 0xB8);\n\t\t}\n\t} else {\t\t\t\t\t \n\t\tif (tp->default_port == 0)\n\t\t\tdev->if_port = tp->mii_cnt ? 11 : 3;\n\t\tif (tulip_media_cap[dev->if_port] & MediaIsMII) {\n\t\t\tnew_csr6 = 0x020E0000;\n\t\t} else if (tulip_media_cap[dev->if_port] & MediaIsFx) {\n\t\t\tnew_csr6 = 0x02860000;\n\t\t} else\n\t\t\tnew_csr6 = 0x03860000;\n\t\tif (tulip_debug > 1)\n\t\t\tnetdev_dbg(dev, \"No media description table, assuming %s transceiver, CSR12 %02x\\n\",\n\t\t\t\t   medianame[dev->if_port],\n\t\t\t\t   ioread32(ioaddr + CSR12));\n\t}\n\n\ttp->csr6 = new_csr6 | (tp->csr6 & 0xfdff) | (tp->full_duplex ? 0x0200 : 0);\n\n\tmdelay(1);\n}\n\n \nint tulip_check_duplex(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tunsigned int bmsr, lpa, negotiated, new_csr6;\n\n\tbmsr = tulip_mdio_read(dev, tp->phys[0], MII_BMSR);\n\tlpa = tulip_mdio_read(dev, tp->phys[0], MII_LPA);\n\tif (tulip_debug > 1)\n\t\tdev_info(&dev->dev, \"MII status %04x, Link partner report %04x\\n\",\n\t\t\t bmsr, lpa);\n\tif (bmsr == 0xffff)\n\t\treturn -2;\n\tif ((bmsr & BMSR_LSTATUS) == 0) {\n\t\tint new_bmsr = tulip_mdio_read(dev, tp->phys[0], MII_BMSR);\n\t\tif ((new_bmsr & BMSR_LSTATUS) == 0) {\n\t\t\tif (tulip_debug  > 1)\n\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t \"No link beat on the MII interface, status %04x\\n\",\n\t\t\t\t\t new_bmsr);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tnegotiated = lpa & tp->advertising[0];\n\ttp->full_duplex = mii_duplex(tp->full_duplex_lock, negotiated);\n\n\tnew_csr6 = tp->csr6;\n\n\tif (negotiated & LPA_100) new_csr6 &= ~TxThreshold;\n\telse\t\t\t  new_csr6 |= TxThreshold;\n\tif (tp->full_duplex) new_csr6 |= FullDuplex;\n\telse\t\t     new_csr6 &= ~FullDuplex;\n\n\tif (new_csr6 != tp->csr6) {\n\t\ttp->csr6 = new_csr6;\n\t\ttulip_restart_rxtx(tp);\n\n\t\tif (tulip_debug > 0)\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t \"Setting %s-duplex based on MII#%d link partner capability of %04x\\n\",\n\t\t\t\t tp->full_duplex ? \"full\" : \"half\",\n\t\t\t\t tp->phys[0], lpa);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid tulip_find_mii(struct net_device *dev, int board_idx)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint phyn, phy_idx = 0;\n\tint mii_reg0;\n\tint mii_advert;\n\tunsigned int to_advert, new_bmcr, ane_switch;\n\n\t \n\tfor (phyn = 1; phyn <= 32 && phy_idx < ARRAY_SIZE(tp->phys); phyn++) {\n\t\tint phy = phyn & 0x1f;\n\t\tint mii_status = tulip_mdio_read (dev, phy, MII_BMSR);\n\t\tif ((mii_status & 0x8301) == 0x8001 ||\n\t\t    ((mii_status & BMSR_100BASE4) == 0 &&\n\t\t     (mii_status & 0x7800) != 0)) {\n\t\t\t \n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmii_reg0 = tulip_mdio_read (dev, phy, MII_BMCR);\n\t\tmii_advert = tulip_mdio_read (dev, phy, MII_ADVERTISE);\n\t\tane_switch = 0;\n\n\t\t \n\t\tif ((mii_advert & ADVERTISE_ALL) == 0) {\n\t\t\tunsigned int tmpadv = tulip_mdio_read (dev, phy, MII_BMSR);\n\t\t\tmii_advert = ((tmpadv >> 6) & 0x3e0) | 1;\n\t\t}\n\n\t\tif (tp->mii_advertise) {\n\t\t\ttp->advertising[phy_idx] =\n\t\t\tto_advert = tp->mii_advertise;\n\t\t} else if (tp->advertising[phy_idx]) {\n\t\t\tto_advert = tp->advertising[phy_idx];\n\t\t} else {\n\t\t\ttp->advertising[phy_idx] =\n\t\t\ttp->mii_advertise =\n\t\t\tto_advert = mii_advert;\n\t\t}\n\n\t\ttp->phys[phy_idx++] = phy;\n\n\t\tpr_info(\"tulip%d:  MII transceiver #%d config %04x status %04x advertising %04x\\n\",\n\t\t\tboard_idx, phy, mii_reg0, mii_status, mii_advert);\n\n\t\t \n\t\tif (mii_advert != to_advert) {\n\t\t\tpr_debug(\"tulip%d:  Advertising %04x on PHY %d, previously advertising %04x\\n\",\n\t\t\t\t board_idx, to_advert, phy, mii_advert);\n\t\t\ttulip_mdio_write (dev, phy, 4, to_advert);\n\t\t}\n\n\t\t \n\t\tif (tp->default_port == 0) {\n\t\t\tnew_bmcr = mii_reg0 | BMCR_ANENABLE;\n\t\t\tif (new_bmcr != mii_reg0) {\n\t\t\t\tnew_bmcr |= BMCR_ANRESTART;\n\t\t\t\tane_switch = 1;\n\t\t\t}\n\t\t}\n\t\t \n\t\telse {\n\t\t\tnew_bmcr = mii_reg0 & ~BMCR_ANENABLE;\n\t\t\tif (new_bmcr != mii_reg0)\n\t\t\t\tane_switch = 1;\n\t\t}\n\n\t\t \n\t\tnew_bmcr &= ~(BMCR_CTST | BMCR_FULLDPLX | BMCR_ISOLATE |\n\t\t\t      BMCR_PDOWN | BMCR_SPEED100 | BMCR_LOOPBACK |\n\t\t\t      BMCR_RESET);\n\n\t\tif (tp->full_duplex)\n\t\t\tnew_bmcr |= BMCR_FULLDPLX;\n\t\tif (tulip_media_cap[tp->default_port] & MediaIs100)\n\t\t\tnew_bmcr |= BMCR_SPEED100;\n\n\t\tif (new_bmcr != mii_reg0) {\n\t\t\t \n\t\t\tif (ane_switch) {\n\t\t\t\ttulip_mdio_write (dev, phy, MII_BMCR, new_bmcr);\n\t\t\t\tudelay (10);\n\t\t\t}\n\t\t\ttulip_mdio_write (dev, phy, MII_BMCR, new_bmcr);\n\t\t}\n\t}\n\ttp->mii_cnt = phy_idx;\n\tif (tp->mtable && tp->mtable->has_mii && phy_idx == 0) {\n\t\tpr_info(\"tulip%d: ***WARNING***: No MII transceiver found!\\n\",\n\t\t\tboard_idx);\n\t\ttp->phys[0] = 1;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}