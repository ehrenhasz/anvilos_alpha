{
  "module_name": "xircom_cb.c",
  "hash_id": "16465da626dcd8efa17ececba2dbec1e5cc4ba59d97328b3917987d3c5b2d976",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/xircom_cb.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#ifdef CONFIG_NET_POLL_CONTROLLER\n#include <asm/irq.h>\n#endif\n\nMODULE_DESCRIPTION(\"Xircom Cardbus ethernet driver\");\nMODULE_AUTHOR(\"Arjan van de Ven <arjanv@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n\n#define xw32(reg, val)\tiowrite32(val, ioaddr + (reg))\n#define xr32(reg)\tioread32(ioaddr + (reg))\n#define xr8(reg)\tioread8(ioaddr + (reg))\n\n \n#define CSR0\t0x00\n#define CSR1\t0x08\n#define CSR2\t0x10\n#define CSR3\t0x18\n#define CSR4\t0x20\n#define CSR5\t0x28\n#define CSR6\t0x30\n#define CSR7\t0x38\n#define CSR8\t0x40\n#define CSR9\t0x48\n#define CSR10\t0x50\n#define CSR11\t0x58\n#define CSR12\t0x60\n#define CSR13\t0x68\n#define CSR14\t0x70\n#define CSR15\t0x78\n#define CSR16\t0x80\n\n \n#define PCI_POWERMGMT \t0x40\n\n \n\n#define NUMDESCRIPTORS 4\n\nstatic int bufferoffsets[NUMDESCRIPTORS] = {128,2048,4096,6144};\n\n\nstruct xircom_private {\n\t \n\n\t__le32 *rx_buffer;\n\t__le32 *tx_buffer;\n\n\tdma_addr_t rx_dma_handle;\n\tdma_addr_t tx_dma_handle;\n\n\tstruct sk_buff *tx_skb[4];\n\n\tvoid __iomem *ioaddr;\n\tint open;\n\n\t \n\tint transmit_used;\n\n\t \n\tspinlock_t lock;\n\n\tstruct pci_dev *pdev;\n\tstruct net_device *dev;\n};\n\n\n \nstatic int xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id);\nstatic void xircom_remove(struct pci_dev *pdev);\nstatic irqreturn_t xircom_interrupt(int irq, void *dev_instance);\nstatic netdev_tx_t xircom_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev);\nstatic int xircom_open(struct net_device *dev);\nstatic int xircom_close(struct net_device *dev);\nstatic void xircom_up(struct xircom_private *card);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void xircom_poll_controller(struct net_device *dev);\n#endif\n\nstatic void investigate_read_descriptor(struct net_device *dev,struct xircom_private *card, int descnr, unsigned int bufferoffset);\nstatic void investigate_write_descriptor(struct net_device *dev, struct xircom_private *card, int descnr, unsigned int bufferoffset);\nstatic void read_mac_address(struct xircom_private *card);\nstatic void transceiver_voodoo(struct xircom_private *card);\nstatic void initialize_card(struct xircom_private *card);\nstatic void trigger_transmit(struct xircom_private *card);\nstatic void trigger_receive(struct xircom_private *card);\nstatic void setup_descriptors(struct xircom_private *card);\nstatic void remove_descriptors(struct xircom_private *card);\nstatic int link_status_changed(struct xircom_private *card);\nstatic void activate_receiver(struct xircom_private *card);\nstatic void deactivate_receiver(struct xircom_private *card);\nstatic void activate_transmitter(struct xircom_private *card);\nstatic void deactivate_transmitter(struct xircom_private *card);\nstatic void enable_transmit_interrupt(struct xircom_private *card);\nstatic void enable_receive_interrupt(struct xircom_private *card);\nstatic void enable_link_interrupt(struct xircom_private *card);\nstatic void disable_all_interrupts(struct xircom_private *card);\nstatic int link_status(struct xircom_private *card);\n\n\n\nstatic const struct pci_device_id xircom_pci_table[] = {\n\t{ PCI_VDEVICE(XIRCOM, 0x0003), },\n\t{0,},\n};\nMODULE_DEVICE_TABLE(pci, xircom_pci_table);\n\nstatic struct pci_driver xircom_ops = {\n\t.name\t\t= \"xircom_cb\",\n\t.id_table\t= xircom_pci_table,\n\t.probe\t\t= xircom_probe,\n\t.remove\t\t= xircom_remove,\n};\n\n\n#if defined DEBUG && DEBUG > 1\nstatic void print_binary(unsigned int number)\n{\n\tint i,i2;\n\tchar buffer[64];\n\tmemset(buffer,0,64);\n\ti2=0;\n\tfor (i=31;i>=0;i--) {\n\t\tif (number & (1<<i))\n\t\t\tbuffer[i2++]='1';\n\t\telse\n\t\t\tbuffer[i2++]='0';\n\t\tif ((i&3)==0)\n\t\t\tbuffer[i2++]=' ';\n\t}\n\tpr_debug(\"%s\\n\",buffer);\n}\n#endif\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= xircom_open,\n\t.ndo_stop\t\t= xircom_close,\n\t.ndo_start_xmit\t\t= xircom_start_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= xircom_poll_controller,\n#endif\n};\n\n \nstatic int xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct device *d = &pdev->dev;\n\tstruct net_device *dev = NULL;\n\tstruct xircom_private *private;\n\tunsigned long flags;\n\tunsigned short tmp16;\n\tint rc;\n\n\t \n\n\trc = pci_enable_device(pdev);\n\tif (rc < 0)\n\t\tgoto out;\n\n\t \n\tpci_write_config_dword(pdev, PCI_POWERMGMT, 0x0000);\n\n\tpci_set_master(pdev);  \n\n\t \n\tpci_read_config_word (pdev,PCI_STATUS, &tmp16);\n\tpci_write_config_word (pdev, PCI_STATUS,tmp16);\n\n\trc = pci_request_regions(pdev, \"xircom_cb\");\n\tif (rc < 0) {\n\t\tpr_err(\"%s: failed to allocate io-region\\n\", __func__);\n\t\tgoto err_disable;\n\t}\n\n\trc = -ENOMEM;\n\t \n\tdev = alloc_etherdev(sizeof(struct xircom_private));\n\tif (!dev)\n\t\tgoto err_release;\n\n\tprivate = netdev_priv(dev);\n\n\t \n\tprivate->rx_buffer = dma_alloc_coherent(d, 8192,\n\t\t\t\t\t\t&private->rx_dma_handle,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (private->rx_buffer == NULL)\n\t\tgoto rx_buf_fail;\n\n\tprivate->tx_buffer = dma_alloc_coherent(d, 8192,\n\t\t\t\t\t\t&private->tx_dma_handle,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (private->tx_buffer == NULL)\n\t\tgoto tx_buf_fail;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\n\tprivate->dev = dev;\n\tprivate->pdev = pdev;\n\n\t \n\tprivate->ioaddr = pci_iomap(pdev, 0, 0);\n\tif (!private->ioaddr)\n\t\tgoto reg_fail;\n\n\tspin_lock_init(&private->lock);\n\n\tinitialize_card(private);\n\tread_mac_address(private);\n\tsetup_descriptors(private);\n\n\tdev->netdev_ops = &netdev_ops;\n\tpci_set_drvdata(pdev, dev);\n\n\trc = register_netdev(dev);\n\tif (rc < 0) {\n\t\tpr_err(\"%s: netdevice registration failed\\n\", __func__);\n\t\tgoto err_unmap;\n\t}\n\n\tnetdev_info(dev, \"Xircom cardbus revision %i at irq %i\\n\",\n\t\t    pdev->revision, pdev->irq);\n\t \n\t \n\ttransceiver_voodoo(private);\n\n\tspin_lock_irqsave(&private->lock,flags);\n\tactivate_transmitter(private);\n\tactivate_receiver(private);\n\tspin_unlock_irqrestore(&private->lock,flags);\n\n\ttrigger_receive(private);\nout:\n\treturn rc;\n\nerr_unmap:\n\tpci_iounmap(pdev, private->ioaddr);\nreg_fail:\n\tdma_free_coherent(d, 8192, private->tx_buffer, private->tx_dma_handle);\ntx_buf_fail:\n\tdma_free_coherent(d, 8192, private->rx_buffer, private->rx_dma_handle);\nrx_buf_fail:\n\tfree_netdev(dev);\nerr_release:\n\tpci_release_regions(pdev);\nerr_disable:\n\tpci_disable_device(pdev);\n\tgoto out;\n}\n\n\n \nstatic void xircom_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct xircom_private *card = netdev_priv(dev);\n\tstruct device *d = &pdev->dev;\n\n\tunregister_netdev(dev);\n\tpci_iounmap(pdev, card->ioaddr);\n\tdma_free_coherent(d, 8192, card->tx_buffer, card->tx_dma_handle);\n\tdma_free_coherent(d, 8192, card->rx_buffer, card->rx_dma_handle);\n\tfree_netdev(dev);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic irqreturn_t xircom_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = (struct net_device *) dev_instance;\n\tstruct xircom_private *card = netdev_priv(dev);\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int status;\n\tint i;\n\n\tspin_lock(&card->lock);\n\tstatus = xr32(CSR5);\n\n#if defined DEBUG && DEBUG > 1\n\tprint_binary(status);\n\tpr_debug(\"tx status 0x%08x 0x%08x\\n\",\n\t\t card->tx_buffer[0], card->tx_buffer[4]);\n\tpr_debug(\"rx status 0x%08x 0x%08x\\n\",\n\t\t card->rx_buffer[0], card->rx_buffer[4]);\n#endif\n\t \n\tif (status == 0 || status == 0xffffffff) {\n\t\tspin_unlock(&card->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (link_status_changed(card)) {\n\t\tint newlink;\n\t\tnetdev_dbg(dev, \"Link status has changed\\n\");\n\t\tnewlink = link_status(card);\n\t\tnetdev_info(dev, \"Link is %d mbit\\n\", newlink);\n\t\tif (newlink)\n\t\t\tnetif_carrier_on(dev);\n\t\telse\n\t\t\tnetif_carrier_off(dev);\n\n\t}\n\n\t \n\tstatus |= 0xffffffff;  \n\txw32(CSR5, status);\n\n\n\tfor (i=0;i<NUMDESCRIPTORS;i++)\n\t\tinvestigate_write_descriptor(dev,card,i,bufferoffsets[i]);\n\tfor (i=0;i<NUMDESCRIPTORS;i++)\n\t\tinvestigate_read_descriptor(dev,card,i,bufferoffsets[i]);\n\n\tspin_unlock(&card->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic netdev_tx_t xircom_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct xircom_private *card;\n\tunsigned long flags;\n\tint nextdescriptor;\n\tint desc;\n\n\tcard = netdev_priv(dev);\n\tspin_lock_irqsave(&card->lock,flags);\n\n\t \n\tfor (desc=0;desc<NUMDESCRIPTORS;desc++)\n\t\tinvestigate_write_descriptor(dev,card,desc,bufferoffsets[desc]);\n\n\n\tnextdescriptor = (card->transmit_used +1) % (NUMDESCRIPTORS);\n\tdesc = card->transmit_used;\n\n\t \n\tif (card->tx_buffer[4*desc]==0) {\n\t\t\t \n\n\t\t\tmemset(&card->tx_buffer[bufferoffsets[desc]/4],0,1536);\n\t\t\tskb_copy_from_linear_data(skb,\n\t\t\t\t  &(card->tx_buffer[bufferoffsets[desc] / 4]),\n\t\t\t\t\t\t  skb->len);\n\t\t\t \n\n\t\t\tcard->tx_buffer[4*desc+1] = cpu_to_le32(skb->len);\n\t\t\tif (desc == NUMDESCRIPTORS - 1)  \n\t\t\t\tcard->tx_buffer[4*desc+1] |= cpu_to_le32(1<<25);  \n\n\t\t\tcard->tx_buffer[4*desc+1] |= cpu_to_le32(0xF0000000);\n\t\t\t\t\t\t  \n\t\t\tcard->tx_skb[desc] = skb;\n\n\t\t\twmb();\n\t\t\t \n\t\t\tcard->tx_buffer[4*desc] = cpu_to_le32(0x80000000);\n\t\t\ttrigger_transmit(card);\n\t\t\tif (card->tx_buffer[nextdescriptor*4] & cpu_to_le32(0x8000000)) {\n\t\t\t\t \n\t\t\t\tnetif_stop_queue(dev);\n\t\t\t}\n\t\t\tcard->transmit_used = nextdescriptor;\n\t\t\tspin_unlock_irqrestore(&card->lock,flags);\n\t\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\tspin_unlock_irqrestore(&card->lock,flags);\n\ttrigger_transmit(card);\n\n\treturn NETDEV_TX_BUSY;\n}\n\n\n\n\nstatic int xircom_open(struct net_device *dev)\n{\n\tstruct xircom_private *xp = netdev_priv(dev);\n\tconst int irq = xp->pdev->irq;\n\tint retval;\n\n\tnetdev_info(dev, \"xircom cardbus adaptor found, using irq %i\\n\", irq);\n\tretval = request_irq(irq, xircom_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (retval)\n\t\treturn retval;\n\n\txircom_up(xp);\n\txp->open = 1;\n\n\treturn 0;\n}\n\nstatic int xircom_close(struct net_device *dev)\n{\n\tstruct xircom_private *card;\n\tunsigned long flags;\n\n\tcard = netdev_priv(dev);\n\tnetif_stop_queue(dev);  \n\n\n\tspin_lock_irqsave(&card->lock,flags);\n\n\tdisable_all_interrupts(card);\n#if 0\n\t \n\tdeactivate_receiver(card);\n\tdeactivate_transmitter(card);\n#endif\n\tremove_descriptors(card);\n\n\tspin_unlock_irqrestore(&card->lock,flags);\n\n\tcard->open = 0;\n\tfree_irq(card->pdev->irq, dev);\n\n\treturn 0;\n\n}\n\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void xircom_poll_controller(struct net_device *dev)\n{\n\tstruct xircom_private *xp = netdev_priv(dev);\n\tconst int irq = xp->pdev->irq;\n\n\tdisable_irq(irq);\n\txircom_interrupt(irq, dev);\n\tenable_irq(irq);\n}\n#endif\n\n\nstatic void initialize_card(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\t \n\tval = xr32(CSR0);\n\tval |= 0x01;\t\t \n\txw32(CSR0, val);\n\n\tudelay(100);\t\t \n\n\tval = xr32(CSR0);\n\tval &= ~0x01;\t\t \n\txw32(CSR0, val);\n\n\n\tval = 0;\t\t \n\txw32(CSR0, val);\n\n\n\tdisable_all_interrupts(card);\n\tdeactivate_receiver(card);\n\tdeactivate_transmitter(card);\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n}\n\n \nstatic void trigger_transmit(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\n\txw32(CSR1, 0);\n}\n\n \nstatic void trigger_receive(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\n\txw32(CSR2, 0);\n}\n\n \nstatic void setup_descriptors(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tu32 address;\n\tint i;\n\n\tBUG_ON(card->rx_buffer == NULL);\n\tBUG_ON(card->tx_buffer == NULL);\n\n\t \n\tmemset(card->rx_buffer, 0, 128);\t \n\tfor (i=0;i<NUMDESCRIPTORS;i++ ) {\n\n\t\t \n\t\tcard->rx_buffer[i*4 + 0] = cpu_to_le32(0x80000000);\n\t\t \n\t\tcard->rx_buffer[i*4 + 1] = cpu_to_le32(1536);\n\t\tif (i == NUMDESCRIPTORS - 1)  \n\t\t\tcard->rx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);\n\n\t\t \n\n\t\taddress = card->rx_dma_handle;\n\t\tcard->rx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);\n\t\t \n\t\tcard->rx_buffer[i*4 + 3] = 0;\n\t}\n\n\twmb();\n\t \n\taddress = card->rx_dma_handle;\n\txw32(CSR3, address);\t \n\n\n\t \n\tmemset(card->tx_buffer, 0, 128);\t \n\n\tfor (i=0;i<NUMDESCRIPTORS;i++ ) {\n\t\t \n\t\tcard->tx_buffer[i*4 + 0] = 0x00000000;\n\t\t \n\t\tcard->tx_buffer[i*4 + 1] = cpu_to_le32(1536);\n\t\tif (i == NUMDESCRIPTORS - 1)  \n\t\t\tcard->tx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);\n\n\t\t \n\t\taddress = card->tx_dma_handle;\n\t\tcard->tx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);\n\t\t \n\t\tcard->tx_buffer[i*4 + 3] = 0;\n\t}\n\n\twmb();\n\t \n\taddress = card->tx_dma_handle;\n\txw32(CSR4, address);\t \n}\n\n \nstatic void remove_descriptors(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\n\tval = 0;\n\txw32(CSR3, val);\t \n\txw32(CSR4, val);\t \n}\n\n \nstatic int link_status_changed(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\n\tval = xr32(CSR5);\t \n\tif (!(val & (1 << 27)))\t \n\t\treturn 0;\n\n\t \n\tval = (1 << 27);\n\txw32(CSR5, val);\n\n\treturn 1;\n}\n\n\n \nstatic int transmit_active(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\n\tif (!(xr32(CSR5) & (7 << 20)))\t \n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int receive_active(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\n\tif (!(xr32(CSR5) & (7 << 17)))\t \n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic void activate_receiver(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\tint counter;\n\n\tval = xr32(CSR6);\t \n\n\t \n\tif ((val&2) && (receive_active(card)))\n\t\treturn;\n\n\n\tval = val & ~2;\t\t \n\txw32(CSR6, val);\n\n\tcounter = 10;\n\twhile (counter > 0) {\n\t\tif (!receive_active(card))\n\t\t\tbreak;\n\t\t \n\t\tudelay(50);\n\t\tcounter--;\n\t\tif (counter <= 0)\n\t\t\tnetdev_err(card->dev, \"Receiver failed to deactivate\\n\");\n\t}\n\n\t \n\tval = xr32(CSR6);\t \n\tval = val | 2;\t\t \n\txw32(CSR6, val);\n\n\t \n\tcounter = 10;\n\twhile (counter > 0) {\n\t\tif (receive_active(card))\n\t\t\tbreak;\n\t\t \n\t\tudelay(50);\n\t\tcounter--;\n\t\tif (counter <= 0)\n\t\t\tnetdev_err(card->dev,\n\t\t\t\t   \"Receiver failed to re-activate\\n\");\n\t}\n}\n\n \nstatic void deactivate_receiver(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\tint counter;\n\n\tval = xr32(CSR6);\t \n\tval = val & ~2;\t\t \n\txw32(CSR6, val);\n\n\tcounter = 10;\n\twhile (counter > 0) {\n\t\tif (!receive_active(card))\n\t\t\tbreak;\n\t\t \n\t\tudelay(50);\n\t\tcounter--;\n\t\tif (counter <= 0)\n\t\t\tnetdev_err(card->dev, \"Receiver failed to deactivate\\n\");\n\t}\n}\n\n\n \nstatic void activate_transmitter(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\tint counter;\n\n\tval = xr32(CSR6);\t \n\n\t \n\tif ((val&(1<<13)) && (transmit_active(card)))\n\t\treturn;\n\n\tval = val & ~(1 << 13);\t \n\txw32(CSR6, val);\n\n\tcounter = 10;\n\twhile (counter > 0) {\n\t\tif (!transmit_active(card))\n\t\t\tbreak;\n\t\t \n\t\tudelay(50);\n\t\tcounter--;\n\t\tif (counter <= 0)\n\t\t\tnetdev_err(card->dev,\n\t\t\t\t   \"Transmitter failed to deactivate\\n\");\n\t}\n\n\t \n\tval = xr32(CSR6);\t \n\tval = val | (1 << 13);\t \n\txw32(CSR6, val);\n\n\t \n\tcounter = 10;\n\twhile (counter > 0) {\n\t\tif (transmit_active(card))\n\t\t\tbreak;\n\t\t \n\t\tudelay(50);\n\t\tcounter--;\n\t\tif (counter <= 0)\n\t\t\tnetdev_err(card->dev,\n\t\t\t\t   \"Transmitter failed to re-activate\\n\");\n\t}\n}\n\n \nstatic void deactivate_transmitter(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\tint counter;\n\n\tval = xr32(CSR6);\t \n\tval = val & ~2;\t\t \n\txw32(CSR6, val);\n\n\tcounter = 20;\n\twhile (counter > 0) {\n\t\tif (!transmit_active(card))\n\t\t\tbreak;\n\t\t \n\t\tudelay(50);\n\t\tcounter--;\n\t\tif (counter <= 0)\n\t\t\tnetdev_err(card->dev,\n\t\t\t\t   \"Transmitter failed to deactivate\\n\");\n\t}\n}\n\n\n \nstatic void enable_transmit_interrupt(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\n\tval = xr32(CSR7);\t \n\tval |= 1;\t\t \n\txw32(CSR7, val);\n}\n\n\n \nstatic void enable_receive_interrupt(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\n\tval = xr32(CSR7);\t \n\tval = val | (1 << 6);\t \n\txw32(CSR7, val);\n}\n\n \nstatic void enable_link_interrupt(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\n\tval = xr32(CSR7);\t \n\tval = val | (1 << 27);\t \n\txw32(CSR7, val);\n}\n\n\n\n \nstatic void disable_all_interrupts(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\n\txw32(CSR7, 0);\n}\n\n \nstatic void enable_common_interrupts(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\n\tval = xr32(CSR7);\t \n\tval |= (1<<16);  \n\tval |= (1<<15);  \n\tval |= (1<<13);  \n\tval |= (1<<8);   \n\tval |= (1<<7);   \n\tval |= (1<<5);   \n\tval |= (1<<2);   \n\tval |= (1<<1);   \n\txw32(CSR7, val);\n}\n\n \nstatic int enable_promisc(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned int val;\n\n\tval = xr32(CSR6);\n\tval = val | (1 << 6);\n\txw32(CSR6, val);\n\n\treturn 1;\n}\n\n\n\n\n \nstatic int link_status(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tu8 val;\n\n\tval = xr8(CSR12);\n\n\t \n\tif (!(val & (1 << 2)))\n\t\treturn 10;\n\t \n\tif (!(val & (1 << 1)))\n\t\treturn 100;\n\n\t \n\n\treturn 0;\n}\n\n\n\n\n\n \nstatic void read_mac_address(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned long flags;\n\tu8 link;\n\tint i;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\txw32(CSR9, 1 << 12);\t \n\tfor (i = 0x100; i < 0x1f7; i += link + 2) {\n\t\tu8 tuple, data_id, data_count;\n\n\t\txw32(CSR10, i);\n\t\ttuple = xr32(CSR9);\n\t\txw32(CSR10, i + 1);\n\t\tlink = xr32(CSR9);\n\t\txw32(CSR10, i + 2);\n\t\tdata_id = xr32(CSR9);\n\t\txw32(CSR10, i + 3);\n\t\tdata_count = xr32(CSR9);\n\t\tif ((tuple == 0x22) && (data_id == 0x04) && (data_count == 0x06)) {\n\t\t\tu8 addr[ETH_ALEN];\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < 6; j++) {\n\t\t\t\txw32(CSR10, i + j + 4);\n\t\t\t\taddr[j] = xr32(CSR9) & 0xff;\n\t\t\t}\n\t\t\teth_hw_addr_set(card->dev, addr);\n\t\t\tbreak;\n\t\t} else if (link == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tpr_debug(\" %pM\\n\", card->dev->dev_addr);\n}\n\n\n \nstatic void transceiver_voodoo(struct xircom_private *card)\n{\n\tvoid __iomem *ioaddr = card->ioaddr;\n\tunsigned long flags;\n\n\t \n\tpci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);\n\n\tsetup_descriptors(card);\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\txw32(CSR15, 0x0008);\n\tudelay(25);\n\txw32(CSR15, 0xa8050000);\n\tudelay(25);\n\txw32(CSR15, 0xa00f0000);\n\tudelay(25);\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tnetif_start_queue(card->dev);\n}\n\n\nstatic void xircom_up(struct xircom_private *card)\n{\n\tunsigned long flags;\n\tint i;\n\n\t \n\tpci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);\n\n\tsetup_descriptors(card);\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\n\tenable_link_interrupt(card);\n\tenable_transmit_interrupt(card);\n\tenable_receive_interrupt(card);\n\tenable_common_interrupts(card);\n\tenable_promisc(card);\n\n\t \n\tfor (i=0;i<NUMDESCRIPTORS;i++)\n\t\tinvestigate_read_descriptor(card->dev,card,i,bufferoffsets[i]);\n\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n\ttrigger_receive(card);\n\ttrigger_transmit(card);\n\tnetif_start_queue(card->dev);\n}\n\n \nstatic void\ninvestigate_read_descriptor(struct net_device *dev, struct xircom_private *card,\n\t\t\t    int descnr, unsigned int bufferoffset)\n{\n\tint status;\n\n\tstatus = le32_to_cpu(card->rx_buffer[4*descnr]);\n\n\tif (status > 0) {\t\t \n\n\t\t \n\n\t\tshort pkt_len = ((status >> 16) & 0x7ff) - 4;\n\t\t\t\t\t \n\t\tstruct sk_buff *skb;\n\n\t\tif (pkt_len > 1518) {\n\t\t\tnetdev_err(dev, \"Packet length %i is bogus\\n\", pkt_len);\n\t\t\tpkt_len = 1518;\n\t\t}\n\n\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\tif (skb == NULL) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tgoto out;\n\t\t}\n\t\tskb_reserve(skb, 2);\n\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t&card->rx_buffer[bufferoffset / 4],\n\t\t\t\t\tpkt_len);\n\t\tskb_put(skb, pkt_len);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += pkt_len;\n\nout:\n\t\t \n\t\tcard->rx_buffer[4*descnr] = cpu_to_le32(0x80000000);\n\t\ttrigger_receive(card);\n\t}\n}\n\n\n \nstatic void\ninvestigate_write_descriptor(struct net_device *dev,\n\t\t\t     struct xircom_private *card,\n\t\t\t     int descnr, unsigned int bufferoffset)\n{\n\tint status;\n\n\tstatus = le32_to_cpu(card->tx_buffer[4*descnr]);\n#if 0\n\tif (status & 0x8000) {\t \n\t\tpr_err(\"Major transmit error status %x\\n\", status);\n\t\tcard->tx_buffer[4*descnr] = 0;\n\t\tnetif_wake_queue (dev);\n\t}\n#endif\n\tif (status > 0) {\t \n\t\tif (card->tx_skb[descnr]!=NULL) {\n\t\t\tdev->stats.tx_bytes += card->tx_skb[descnr]->len;\n\t\t\tdev_kfree_skb_irq(card->tx_skb[descnr]);\n\t\t}\n\t\tcard->tx_skb[descnr] = NULL;\n\t\t \n\t\tif (status & (1 << 8))\n\t\t\tdev->stats.collisions++;\n\t\tcard->tx_buffer[4*descnr] = 0;  \n\t\tnetif_wake_queue (dev);\n\t\tdev->stats.tx_packets++;\n\t}\n}\n\nmodule_pci_driver(xircom_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}