{
  "module_name": "uli526x.c",
  "hash_id": "f79a5eaaae2ce53a83056635b9449ce7dcdfa729e62ecac5c85b22a62f6678a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/uli526x.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"uli526x\"\n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/bitops.h>\n\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <linux/uaccess.h>\n\n#define uw32(reg, val)\tiowrite32(val, ioaddr + (reg))\n#define ur32(reg)\tioread32(ioaddr + (reg))\n\n \n#define PCI_ULI5261_ID  0x526110B9\t \n#define PCI_ULI5263_ID  0x526310B9\t \n\n#define ULI526X_IO_SIZE 0x100\n#define TX_DESC_CNT     0x20             \n#define RX_DESC_CNT     0x30             \n#define TX_FREE_DESC_CNT (TX_DESC_CNT - 2)\t \n#define TX_WAKE_DESC_CNT (TX_DESC_CNT - 3)\t \n#define DESC_ALL_CNT    (TX_DESC_CNT + RX_DESC_CNT)\n#define TX_BUF_ALLOC    0x600\n#define RX_ALLOC_SIZE   0x620\n#define ULI526X_RESET    1\n#define CR0_DEFAULT     0\n#define CR6_DEFAULT     0x22200000\n#define CR7_DEFAULT     0x180c1\n#define CR15_DEFAULT    0x06             \n#define TDES0_ERR_MASK  0x4302           \n#define MAX_PACKET_SIZE 1514\n#define ULI5261_MAX_MULTICAST 14\n#define RX_COPY_SIZE\t100\n#define MAX_CHECK_PACKET 0x8000\n\n#define ULI526X_10MHF      0\n#define ULI526X_100MHF     1\n#define ULI526X_10MFD      4\n#define ULI526X_100MFD     5\n#define ULI526X_AUTO       8\n\n#define ULI526X_TXTH_72\t0x400000\t \n#define ULI526X_TXTH_96\t0x404000\t \n#define ULI526X_TXTH_128\t0x0000\t\t \n#define ULI526X_TXTH_256\t0x4000\t\t \n#define ULI526X_TXTH_512\t0x8000\t\t \n#define ULI526X_TXTH_1K\t0xC000\t\t \n\n#define ULI526X_TIMER_WUT  (jiffies + HZ * 1) \n#define ULI526X_TX_TIMEOUT ((16*HZ)/2)\t \n#define ULI526X_TX_KICK \t(4*HZ/2)\t \n\n#define ULI526X_DBUG(dbug_now, msg, value)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (uli526x_debug || (dbug_now))\t\t\t\\\n\t\tpr_err(\"%s %lx\\n\", (msg), (long) (value));\t\\\n} while (0)\n\n#define SHOW_MEDIA_TYPE(mode)\t\t\t\t\t\\\n\tpr_err(\"Change Speed to %sMhz %s duplex\\n\",\t\t\\\n\t       mode & 1 ? \"100\" : \"10\",\t\t\t\t\\\n\t       mode & 4 ? \"full\" : \"half\");\n\n\n \n#define CR9_SROM_READ   0x4800\n#define CR9_SRCS        0x1\n#define CR9_SRCLK       0x2\n#define CR9_CRDOUT      0x8\n#define SROM_DATA_0     0x0\n#define SROM_DATA_1     0x4\n#define PHY_DATA_1      0x20000\n#define PHY_DATA_0      0x00000\n#define MDCLKH          0x10000\n\n#define PHY_POWER_DOWN\t0x800\n\n#define SROM_V41_CODE   0x14\n\n \nstruct tx_desc {\n        __le32 tdes0, tdes1, tdes2, tdes3;  \n        char *tx_buf_ptr;                \n        struct tx_desc *next_tx_desc;\n} __attribute__(( aligned(32) ));\n\nstruct rx_desc {\n\t__le32 rdes0, rdes1, rdes2, rdes3;  \n\tstruct sk_buff *rx_skb_ptr;\t \n\tstruct rx_desc *next_rx_desc;\n} __attribute__(( aligned(32) ));\n\nstruct uli526x_board_info {\n\tstruct uli_phy_ops {\n\t\tvoid (*write)(struct uli526x_board_info *, u8, u8, u16);\n\t\tu16 (*read)(struct uli526x_board_info *, u8, u8);\n\t} phy;\n\tstruct net_device *next_dev;\t \n\tstruct pci_dev *pdev;\t\t \n\tspinlock_t lock;\n\n\tvoid __iomem *ioaddr;\t\t \n\tu32 cr0_data;\n\tu32 cr5_data;\n\tu32 cr6_data;\n\tu32 cr7_data;\n\tu32 cr15_data;\n\n\t \n\tdma_addr_t buf_pool_dma_ptr;\t \n\tdma_addr_t buf_pool_dma_start;\t \n\tdma_addr_t desc_pool_dma_ptr;\t \n\tdma_addr_t first_tx_desc_dma;\n\tdma_addr_t first_rx_desc_dma;\n\n\t \n\tunsigned char *buf_pool_ptr;\t \n\tunsigned char *buf_pool_start;\t \n\tunsigned char *desc_pool_ptr;\t \n\tstruct tx_desc *first_tx_desc;\n\tstruct tx_desc *tx_insert_ptr;\n\tstruct tx_desc *tx_remove_ptr;\n\tstruct rx_desc *first_rx_desc;\n\tstruct rx_desc *rx_insert_ptr;\n\tstruct rx_desc *rx_ready_ptr;\t \n\tunsigned long tx_packet_cnt;\t \n\tunsigned long rx_avail_cnt;\t \n\tunsigned long interval_rx_cnt;\t \n\n\tu16 dbug_cnt;\n\tu16 NIC_capability;\t\t \n\tu16 PHY_reg4;\t\t\t \n\n\tu8 media_mode;\t\t\t \n\tu8 op_mode;\t\t\t \n\tu8 phy_addr;\n\tu8 link_failed;\t\t\t \n\tu8 wait_reset;\t\t\t \n\tstruct timer_list timer;\n\n\t \n\tunsigned long tx_fifo_underrun;\n\tunsigned long tx_loss_carrier;\n\tunsigned long tx_no_carrier;\n\tunsigned long tx_late_collision;\n\tunsigned long tx_excessive_collision;\n\tunsigned long tx_jabber_timeout;\n\tunsigned long reset_count;\n\tunsigned long reset_cr8;\n\tunsigned long reset_fatal;\n\tunsigned long reset_TXtimeout;\n\n\t \n\tunsigned char srom[128];\n\tu8 init;\n};\n\nenum uli526x_offsets {\n\tDCR0 = 0x00, DCR1 = 0x08, DCR2 = 0x10, DCR3 = 0x18, DCR4 = 0x20,\n\tDCR5 = 0x28, DCR6 = 0x30, DCR7 = 0x38, DCR8 = 0x40, DCR9 = 0x48,\n\tDCR10 = 0x50, DCR11 = 0x58, DCR12 = 0x60, DCR13 = 0x68, DCR14 = 0x70,\n\tDCR15 = 0x78\n};\n\nenum uli526x_CR6_bits {\n\tCR6_RXSC = 0x2, CR6_PBF = 0x8, CR6_PM = 0x40, CR6_PAM = 0x80,\n\tCR6_FDM = 0x200, CR6_TXSC = 0x2000, CR6_STI = 0x100000,\n\tCR6_SFT = 0x200000, CR6_RXA = 0x40000000, CR6_NO_PURGE = 0x20000000\n};\n\n \nstatic int uli526x_debug;\nstatic unsigned char uli526x_media_mode = ULI526X_AUTO;\nstatic u32 uli526x_cr6_user_set;\n\n \nstatic int debug;\nstatic u32 cr6set;\nstatic int mode = 8;\n\n \nstatic int uli526x_open(struct net_device *);\nstatic netdev_tx_t uli526x_start_xmit(struct sk_buff *,\n\t\t\t\t\t    struct net_device *);\nstatic int uli526x_stop(struct net_device *);\nstatic void uli526x_set_filter_mode(struct net_device *);\nstatic const struct ethtool_ops netdev_ethtool_ops;\nstatic u16 read_srom_word(struct uli526x_board_info *, int);\nstatic irqreturn_t uli526x_interrupt(int, void *);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void uli526x_poll(struct net_device *dev);\n#endif\nstatic void uli526x_descriptor_init(struct net_device *, void __iomem *);\nstatic void allocate_rx_buffer(struct net_device *);\nstatic void update_cr6(u32, void __iomem *);\nstatic void send_filter_frame(struct net_device *, int);\nstatic u16 phy_readby_cr9(struct uli526x_board_info *, u8, u8);\nstatic u16 phy_readby_cr10(struct uli526x_board_info *, u8, u8);\nstatic void phy_writeby_cr9(struct uli526x_board_info *, u8, u8, u16);\nstatic void phy_writeby_cr10(struct uli526x_board_info *, u8, u8, u16);\nstatic void phy_write_1bit(struct uli526x_board_info *db, u32);\nstatic u16 phy_read_1bit(struct uli526x_board_info *db);\nstatic u8 uli526x_sense_speed(struct uli526x_board_info *);\nstatic void uli526x_process_mode(struct uli526x_board_info *);\nstatic void uli526x_timer(struct timer_list *t);\nstatic void uli526x_rx_packet(struct net_device *, struct uli526x_board_info *);\nstatic void uli526x_free_tx_pkt(struct net_device *, struct uli526x_board_info *);\nstatic void uli526x_reuse_skb(struct uli526x_board_info *, struct sk_buff *);\nstatic void uli526x_dynamic_reset(struct net_device *);\nstatic void uli526x_free_rxbuffer(struct uli526x_board_info *);\nstatic void uli526x_init(struct net_device *);\nstatic void uli526x_set_phyxcer(struct uli526x_board_info *);\n\nstatic void srom_clk_write(struct uli526x_board_info *db, u32 data)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\tuw32(DCR9, data | CR9_SROM_READ | CR9_SRCS);\n\tudelay(5);\n\tuw32(DCR9, data | CR9_SROM_READ | CR9_SRCS | CR9_SRCLK);\n\tudelay(5);\n\tuw32(DCR9, data | CR9_SROM_READ | CR9_SRCS);\n\tudelay(5);\n}\n\n \n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= uli526x_open,\n\t.ndo_stop\t\t= uli526x_stop,\n\t.ndo_start_xmit\t\t= uli526x_start_xmit,\n\t.ndo_set_rx_mode\t= uli526x_set_filter_mode,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller \t= uli526x_poll,\n#endif\n};\n\n \n\nstatic int uli526x_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct uli526x_board_info *db;\t \n\tstruct net_device *dev;\n\tvoid __iomem *ioaddr;\n\tu8 addr[ETH_ALEN];\n\tint i, err;\n\n\tULI526X_DBUG(0, \"uli526x_init_one()\", 0);\n\n\t \n\tdev = alloc_etherdev(sizeof(*db));\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tpr_warn(\"32-bit PCI DMA not available\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_free;\n\t}\n\n\t \n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto err_out_free;\n\n\tif (!pci_resource_start(pdev, 0)) {\n\t\tpr_err(\"I/O base is zero\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\tif (pci_resource_len(pdev, 0) < (ULI526X_IO_SIZE) ) {\n\t\tpr_err(\"Allocated I/O size too small\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to request PCI regions\\n\");\n\t\tgoto err_out_disable;\n\t}\n\n\t \n\tdb = netdev_priv(dev);\n\n\t \n\terr = -ENOMEM;\n\n\tdb->desc_pool_ptr = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t       sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\n\t\t\t\t\t       &db->desc_pool_dma_ptr, GFP_KERNEL);\n\tif (!db->desc_pool_ptr)\n\t\tgoto err_out_release;\n\n\tdb->buf_pool_ptr = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t      TX_BUF_ALLOC * TX_DESC_CNT + 4,\n\t\t\t\t\t      &db->buf_pool_dma_ptr, GFP_KERNEL);\n\tif (!db->buf_pool_ptr)\n\t\tgoto err_out_free_tx_desc;\n\n\tdb->first_tx_desc = (struct tx_desc *) db->desc_pool_ptr;\n\tdb->first_tx_desc_dma = db->desc_pool_dma_ptr;\n\tdb->buf_pool_start = db->buf_pool_ptr;\n\tdb->buf_pool_dma_start = db->buf_pool_dma_ptr;\n\n\tswitch (ent->driver_data) {\n\tcase PCI_ULI5263_ID:\n\t\tdb->phy.write\t= phy_writeby_cr10;\n\t\tdb->phy.read\t= phy_readby_cr10;\n\t\tbreak;\n\tdefault:\n\t\tdb->phy.write\t= phy_writeby_cr9;\n\t\tdb->phy.read\t= phy_readby_cr9;\n\t\tbreak;\n\t}\n\n\t \n\tioaddr = pci_iomap(pdev, 0, 0);\n\tif (!ioaddr)\n\t\tgoto err_out_free_tx_buf;\n\n\tdb->ioaddr = ioaddr;\n\tdb->pdev = pdev;\n\tdb->init = 1;\n\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tdev->netdev_ops = &netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\n\tspin_lock_init(&db->lock);\n\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\t((__le16 *) db->srom)[i] = cpu_to_le16(read_srom_word(db, i));\n\n\t \n\tif(((u16 *) db->srom)[0] == 0xffff || ((u16 *) db->srom)[0] == 0)\t\t \n\t{\n\t\tuw32(DCR0, 0x10000);\t\n\t\tuw32(DCR13, 0x1c0);\t\n\t\tuw32(DCR14, 0);\t\t\n\t\tuw32(DCR14, 0x10);\t\n\t\tuw32(DCR14, 0);\t\t\n\t\tuw32(DCR13, 0);\t\t\n\t\tuw32(DCR13, 0x1b0);\t\n\t\t\n\t\tfor (i = 0; i < 6; i++)\n\t\t\taddr[i] = ur32(DCR14);\n\t\t\n\t\tuw32(DCR13, 0);\t\t\n\t\tuw32(DCR0, 0);\t\t\n\t\tudelay(10);\n\t}\n\telse\t\t \n\t{\n\t\tfor (i = 0; i < 6; i++)\n\t\t\taddr[i] = db->srom[20 + i];\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\terr = register_netdev (dev);\n\tif (err)\n\t\tgoto err_out_unmap;\n\n\tnetdev_info(dev, \"ULi M%04lx at pci%s, %pM, irq %d\\n\",\n\t\t    ent->driver_data >> 16, pci_name(pdev),\n\t\t    dev->dev_addr, pdev->irq);\n\n\tpci_set_master(pdev);\n\n\treturn 0;\n\nerr_out_unmap:\n\tpci_iounmap(pdev, db->ioaddr);\nerr_out_free_tx_buf:\n\tdma_free_coherent(&pdev->dev, TX_BUF_ALLOC * TX_DESC_CNT + 4,\n\t\t\t  db->buf_pool_ptr, db->buf_pool_dma_ptr);\nerr_out_free_tx_desc:\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\n\t\t\t  db->desc_pool_ptr, db->desc_pool_dma_ptr);\nerr_out_release:\n\tpci_release_regions(pdev);\nerr_out_disable:\n\tpci_disable_device(pdev);\nerr_out_free:\n\tfree_netdev(dev);\n\n\treturn err;\n}\n\n\nstatic void uli526x_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tpci_iounmap(pdev, db->ioaddr);\n\tdma_free_coherent(&db->pdev->dev,\n\t\t\t  sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\n\t\t\t  db->desc_pool_ptr, db->desc_pool_dma_ptr);\n\tdma_free_coherent(&db->pdev->dev, TX_BUF_ALLOC * TX_DESC_CNT + 4,\n\t\t\t  db->buf_pool_ptr, db->buf_pool_dma_ptr);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tfree_netdev(dev);\n}\n\n\n \n\nstatic int uli526x_open(struct net_device *dev)\n{\n\tint ret;\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\n\tULI526X_DBUG(0, \"uli526x_open\", 0);\n\n\t \n\tdb->cr6_data = CR6_DEFAULT | uli526x_cr6_user_set;\n\tdb->tx_packet_cnt = 0;\n\tdb->rx_avail_cnt = 0;\n\tdb->link_failed = 1;\n\tnetif_carrier_off(dev);\n\tdb->wait_reset = 0;\n\n\tdb->NIC_capability = 0xf;\t \n\tdb->PHY_reg4 = 0x1e0;\n\n\t \n\tdb->cr6_data |= ULI526X_TXTH_256;\n\tdb->cr0_data = CR0_DEFAULT;\n\n\t \n\tuli526x_init(dev);\n\n\tret = request_irq(db->pdev->irq, uli526x_interrupt, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnetif_wake_queue(dev);\n\n\t \n\ttimer_setup(&db->timer, uli526x_timer, 0);\n\tdb->timer.expires = ULI526X_TIMER_WUT + HZ * 2;\n\tadd_timer(&db->timer);\n\n\treturn 0;\n}\n\n\n \n\nstatic void uli526x_init(struct net_device *dev)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tstruct uli_phy_ops *phy = &db->phy;\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu8\tphy_tmp;\n\tu8\ttimeout;\n\tu16 phy_reg_reset;\n\n\n\tULI526X_DBUG(0, \"uli526x_init()\", 0);\n\n\t \n\tuw32(DCR0, ULI526X_RESET);\t \n\tudelay(100);\n\tuw32(DCR0, db->cr0_data);\n\tudelay(5);\n\n\t \n\tdb->phy_addr = 1;\n\tfor (phy_tmp = 0; phy_tmp < 32; phy_tmp++) {\n\t\tu16 phy_value;\n\n\t\tphy_value = phy->read(db, phy_tmp, 3);\t\n\t\tif (phy_value != 0xffff && phy_value != 0) {\n\t\t\tdb->phy_addr = phy_tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phy_tmp == 32)\n\t\tpr_warn(\"Can not find the phy address!!!\\n\");\n\t \n\tdb->media_mode = uli526x_media_mode;\n\n\t \n\tphy_reg_reset = phy->read(db, db->phy_addr, 0);\n\tphy_reg_reset = (phy_reg_reset | 0x8000);\n\tphy->write(db, db->phy_addr, 0, phy_reg_reset);\n\n\t \n\tudelay(500);\n\ttimeout = 10;\n\twhile (timeout-- && phy->read(db, db->phy_addr, 0) & 0x8000)\n\t\tudelay(100);\n\n\t \n\tuli526x_set_phyxcer(db);\n\n\t \n\tif ( !(db->media_mode & ULI526X_AUTO) )\n\t\tdb->op_mode = db->media_mode;\t\t \n\n\t \n\tuli526x_descriptor_init(dev, ioaddr);\n\n\t \n\tupdate_cr6(db->cr6_data, ioaddr);\n\n\t \n\tsend_filter_frame(dev, netdev_mc_count(dev));\t \n\n\t \n\tdb->cr7_data = CR7_DEFAULT;\n\tuw32(DCR7, db->cr7_data);\n\n\t \n\tuw32(DCR15, db->cr15_data);\n\n\t \n\tdb->cr6_data |= CR6_RXSC | CR6_TXSC;\n\tupdate_cr6(db->cr6_data, ioaddr);\n}\n\n\n \n\nstatic netdev_tx_t uli526x_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tstruct tx_desc *txptr;\n\tunsigned long flags;\n\n\tULI526X_DBUG(0, \"uli526x_start_xmit\", 0);\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tif (skb->len > MAX_PACKET_SIZE) {\n\t\tnetdev_err(dev, \"big packet = %d\\n\", (u16)skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\tif (db->tx_packet_cnt >= TX_FREE_DESC_CNT) {\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\tnetdev_err(dev, \"No Tx resource %ld\\n\", db->tx_packet_cnt);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tuw32(DCR7, 0);\n\n\t \n\ttxptr = db->tx_insert_ptr;\n\tskb_copy_from_linear_data(skb, txptr->tx_buf_ptr, skb->len);\n\ttxptr->tdes1 = cpu_to_le32(0xe1000000 | skb->len);\n\n\t \n\tdb->tx_insert_ptr = txptr->next_tx_desc;\n\n\t \n\tif (db->tx_packet_cnt < TX_DESC_CNT) {\n\t\ttxptr->tdes0 = cpu_to_le32(0x80000000);\t \n\t\tdb->tx_packet_cnt++;\t\t\t \n\t\tuw32(DCR1, 0x1);\t\t\t \n\t\tnetif_trans_update(dev);\t\t \n\t}\n\n\t \n\tif ( db->tx_packet_cnt < TX_FREE_DESC_CNT )\n\t\tnetif_wake_queue(dev);\n\n\t \n\tspin_unlock_irqrestore(&db->lock, flags);\n\tuw32(DCR7, db->cr7_data);\n\n\t \n\tdev_consume_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n\n \n\nstatic int uli526x_stop(struct net_device *dev)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tdel_timer_sync(&db->timer);\n\n\t \n\tuw32(DCR0, ULI526X_RESET);\n\tudelay(5);\n\tdb->phy.write(db, db->phy_addr, 0, 0x8000);\n\n\t \n\tfree_irq(db->pdev->irq, dev);\n\n\t \n\tuli526x_free_rxbuffer(db);\n\n\treturn 0;\n}\n\n\n \n\nstatic irqreturn_t uli526x_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&db->lock, flags);\n\tuw32(DCR7, 0);\n\n\t \n\tdb->cr5_data = ur32(DCR5);\n\tuw32(DCR5, db->cr5_data);\n\tif ( !(db->cr5_data & 0x180c1) ) {\n\t\t \n\t\tuw32(DCR7, db->cr7_data);\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (db->cr5_data & 0x2000) {\n\t\t \n\t\tULI526X_DBUG(1, \"System bus error happen. CR5=\", db->cr5_data);\n\t\tdb->reset_fatal++;\n\t\tdb->wait_reset = 1;\t \n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t  \n\tif ( (db->cr5_data & 0x40) && db->rx_avail_cnt )\n\t\tuli526x_rx_packet(dev, db);\n\n\t \n\tif (db->rx_avail_cnt<RX_DESC_CNT)\n\t\tallocate_rx_buffer(dev);\n\n\t \n\tif ( db->cr5_data & 0x01)\n\t\tuli526x_free_tx_pkt(dev, db);\n\n\t \n\tuw32(DCR7, db->cr7_data);\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void uli526x_poll(struct net_device *dev)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\n\t \n\tuli526x_interrupt(db->pdev->irq, dev);\n}\n#endif\n\n \n\nstatic void uli526x_free_tx_pkt(struct net_device *dev,\n\t\t\t\tstruct uli526x_board_info * db)\n{\n\tstruct tx_desc *txptr;\n\tu32 tdes0;\n\n\ttxptr = db->tx_remove_ptr;\n\twhile(db->tx_packet_cnt) {\n\t\ttdes0 = le32_to_cpu(txptr->tdes0);\n\t\tif (tdes0 & 0x80000000)\n\t\t\tbreak;\n\n\t\t \n\t\tdb->tx_packet_cnt--;\n\t\tdev->stats.tx_packets++;\n\n\t\t \n\t\tif ( tdes0 != 0x7fffffff ) {\n\t\t\tdev->stats.collisions += (tdes0 >> 3) & 0xf;\n\t\t\tdev->stats.tx_bytes += le32_to_cpu(txptr->tdes1) & 0x7ff;\n\t\t\tif (tdes0 & TDES0_ERR_MASK) {\n\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\tif (tdes0 & 0x0002) {\t \n\t\t\t\t\tdb->tx_fifo_underrun++;\n\t\t\t\t\tif ( !(db->cr6_data & CR6_SFT) ) {\n\t\t\t\t\t\tdb->cr6_data = db->cr6_data | CR6_SFT;\n\t\t\t\t\t\tupdate_cr6(db->cr6_data, db->ioaddr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tdes0 & 0x0100)\n\t\t\t\t\tdb->tx_excessive_collision++;\n\t\t\t\tif (tdes0 & 0x0200)\n\t\t\t\t\tdb->tx_late_collision++;\n\t\t\t\tif (tdes0 & 0x0400)\n\t\t\t\t\tdb->tx_no_carrier++;\n\t\t\t\tif (tdes0 & 0x0800)\n\t\t\t\t\tdb->tx_loss_carrier++;\n\t\t\t\tif (tdes0 & 0x4000)\n\t\t\t\t\tdb->tx_jabber_timeout++;\n\t\t\t}\n\t\t}\n\n\t\ttxptr = txptr->next_tx_desc;\n\t} \n\n\t \n\tdb->tx_remove_ptr = txptr;\n\n\t \n\tif ( db->tx_packet_cnt < TX_WAKE_DESC_CNT )\n\t\tnetif_wake_queue(dev);\t \n}\n\n\n \n\nstatic void uli526x_rx_packet(struct net_device *dev, struct uli526x_board_info * db)\n{\n\tstruct rx_desc *rxptr;\n\tstruct sk_buff *skb;\n\tint rxlen;\n\tu32 rdes0;\n\n\trxptr = db->rx_ready_ptr;\n\n\twhile(db->rx_avail_cnt) {\n\t\trdes0 = le32_to_cpu(rxptr->rdes0);\n\t\tif (rdes0 & 0x80000000)\t \n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tdb->rx_avail_cnt--;\n\t\tdb->interval_rx_cnt++;\n\n\t\tdma_unmap_single(&db->pdev->dev, le32_to_cpu(rxptr->rdes2),\n\t\t\t\t RX_ALLOC_SIZE, DMA_FROM_DEVICE);\n\t\tif ( (rdes0 & 0x300) != 0x300) {\n\t\t\t \n\t\t\t \n\t\t\tULI526X_DBUG(0, \"Reuse SK buffer, rdes0\", rdes0);\n\t\t\tuli526x_reuse_skb(db, rxptr->rx_skb_ptr);\n\t\t} else {\n\t\t\t \n\t\t\trxlen = ( (rdes0 >> 16) & 0x3fff) - 4;\n\n\t\t\t \n\t\t\tif (rdes0 & 0x8000) {\n\t\t\t\t \n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tif (rdes0 & 1)\n\t\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t\tif (rdes0 & 2)\n\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tif (rdes0 & 0x80)\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t}\n\n\t\t\tif ( !(rdes0 & 0x8000) ||\n\t\t\t\t((db->cr6_data & CR6_PM) && (rxlen>6)) ) {\n\t\t\t\tstruct sk_buff *new_skb = NULL;\n\n\t\t\t\tskb = rxptr->rx_skb_ptr;\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif ((rxlen < RX_COPY_SIZE) &&\n\t\t\t\t    (((new_skb = netdev_alloc_skb(dev, rxlen + 2)) != NULL))) {\n\t\t\t\t\tskb = new_skb;\n\t\t\t\t\t \n\t\t\t\t\tskb_reserve(skb, 2);  \n\t\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t\t     skb_tail_pointer(rxptr->rx_skb_ptr),\n\t\t\t\t\t\t     rxlen);\n\t\t\t\t\tuli526x_reuse_skb(db, rxptr->rx_skb_ptr);\n\t\t\t\t} else\n\t\t\t\t\tskb_put(skb, rxlen);\n\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += rxlen;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tULI526X_DBUG(0, \"Reuse SK buffer, rdes0\", rdes0);\n\t\t\t\tuli526x_reuse_skb(db, rxptr->rx_skb_ptr);\n\t\t\t}\n\t\t}\n\n\t\trxptr = rxptr->next_rx_desc;\n\t}\n\n\tdb->rx_ready_ptr = rxptr;\n}\n\n\n \n\nstatic void uli526x_set_filter_mode(struct net_device * dev)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\n\tULI526X_DBUG(0, \"uli526x_set_filter_mode()\", 0);\n\tspin_lock_irqsave(&db->lock, flags);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tULI526X_DBUG(0, \"Enable PROM Mode\", 0);\n\t\tdb->cr6_data |= CR6_PM | CR6_PBF;\n\t\tupdate_cr6(db->cr6_data, db->ioaddr);\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI ||\n\t    netdev_mc_count(dev) > ULI5261_MAX_MULTICAST) {\n\t\tULI526X_DBUG(0, \"Pass all multicast address\",\n\t\t\t     netdev_mc_count(dev));\n\t\tdb->cr6_data &= ~(CR6_PM | CR6_PBF);\n\t\tdb->cr6_data |= CR6_PAM;\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn;\n\t}\n\n\tULI526X_DBUG(0, \"Set multicast address\", netdev_mc_count(dev));\n\tsend_filter_frame(dev, netdev_mc_count(dev)); \t \n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\nstatic void\nULi_ethtool_get_link_ksettings(struct uli526x_board_info *db,\n\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tu32 supported, advertising;\n\n\tsupported = (SUPPORTED_10baseT_Half |\n\t                   SUPPORTED_10baseT_Full |\n\t                   SUPPORTED_100baseT_Half |\n\t                   SUPPORTED_100baseT_Full |\n\t                   SUPPORTED_Autoneg |\n\t                   SUPPORTED_MII);\n\n\tadvertising = (ADVERTISED_10baseT_Half |\n\t                   ADVERTISED_10baseT_Full |\n\t                   ADVERTISED_100baseT_Half |\n\t                   ADVERTISED_100baseT_Full |\n\t                   ADVERTISED_Autoneg |\n\t                   ADVERTISED_MII);\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\tcmd->base.port = PORT_MII;\n\tcmd->base.phy_address = db->phy_addr;\n\n\tcmd->base.speed = SPEED_10;\n\tcmd->base.duplex = DUPLEX_HALF;\n\n\tif(db->op_mode==ULI526X_100MHF || db->op_mode==ULI526X_100MFD)\n\t{\n\t\tcmd->base.speed = SPEED_100;\n\t}\n\tif(db->op_mode==ULI526X_10MFD || db->op_mode==ULI526X_100MFD)\n\t{\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t}\n\tif(db->link_failed)\n\t{\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tif (db->media_mode & ULI526X_AUTO)\n\t{\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t}\n}\n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct uli526x_board_info *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(np->pdev), sizeof(info->bus_info));\n}\n\nstatic int netdev_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct uli526x_board_info *np = netdev_priv(dev);\n\n\tULi_ethtool_get_link_ksettings(np, cmd);\n\n\treturn 0;\n}\n\nstatic u32 netdev_get_link(struct net_device *dev) {\n\tstruct uli526x_board_info *np = netdev_priv(dev);\n\n\tif(np->link_failed)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic void uli526x_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\twol->supported = WAKE_PHY | WAKE_MAGIC;\n\twol->wolopts = 0;\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.get_link\t\t= netdev_get_link,\n\t.get_wol\t\t= uli526x_get_wol,\n\t.get_link_ksettings\t= netdev_get_link_ksettings,\n};\n\n \n\nstatic void uli526x_timer(struct timer_list *t)\n{\n\tstruct uli526x_board_info *db = from_timer(db, t, timer);\n\tstruct net_device *dev = pci_get_drvdata(db->pdev);\n\tstruct uli_phy_ops *phy = &db->phy;\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tunsigned long flags;\n\tu8 tmp_cr12 = 0;\n\tu32 tmp_cr8;\n\n\t\n\tspin_lock_irqsave(&db->lock, flags);\n\n\n\t \n\ttmp_cr8 = ur32(DCR8);\n\tif ( (db->interval_rx_cnt==0) && (tmp_cr8) ) {\n\t\tdb->reset_cr8++;\n\t\tdb->wait_reset = 1;\n\t}\n\tdb->interval_rx_cnt = 0;\n\n\t \n\tif ( db->tx_packet_cnt &&\n\t     time_after(jiffies, dev_trans_start(dev) + ULI526X_TX_KICK) ) {\n\t\tuw32(DCR1, 0x1);   \n\n\t\t\n\t\tif ( time_after(jiffies, dev_trans_start(dev) + ULI526X_TX_TIMEOUT) ) {\n\t\t\tdb->reset_TXtimeout++;\n\t\t\tdb->wait_reset = 1;\n\t\t\tnetdev_err(dev, \" Tx timeout - resetting\\n\");\n\t\t}\n\t}\n\n\tif (db->wait_reset) {\n\t\tULI526X_DBUG(0, \"Dynamic Reset device\", db->tx_packet_cnt);\n\t\tdb->reset_count++;\n\t\tuli526x_dynamic_reset(dev);\n\t\tdb->timer.expires = ULI526X_TIMER_WUT;\n\t\tadd_timer(&db->timer);\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif ((phy->read(db, db->phy_addr, 5) & 0x01e0)!=0)\n\t\ttmp_cr12 = 3;\n\n\tif ( !(tmp_cr12 & 0x3) && !db->link_failed ) {\n\t\t \n\t\tULI526X_DBUG(0, \"Link Failed\", tmp_cr12);\n\t\tnetif_carrier_off(dev);\n\t\tnetdev_info(dev, \"NIC Link is Down\\n\");\n\t\tdb->link_failed = 1;\n\n\t\t \n\t\t \n\t\tif ( !(db->media_mode & 0x8) )\n\t\t\tphy->write(db, db->phy_addr, 0, 0x1000);\n\n\t\t \n\t\tif (db->media_mode & ULI526X_AUTO) {\n\t\t\tdb->cr6_data&=~0x00000200;\t \n\t\t\tupdate_cr6(db->cr6_data, db->ioaddr);\n\t\t}\n\t} else\n\t\tif ((tmp_cr12 & 0x3) && db->link_failed) {\n\t\t\tULI526X_DBUG(0, \"Link link OK\", tmp_cr12);\n\t\t\tdb->link_failed = 0;\n\n\t\t\t \n\t\t\tif ( (db->media_mode & ULI526X_AUTO) &&\n\t\t\t\tuli526x_sense_speed(db) )\n\t\t\t\tdb->link_failed = 1;\n\t\t\tuli526x_process_mode(db);\n\n\t\t\tif(db->link_failed==0)\n\t\t\t{\n\t\t\t\tnetdev_info(dev, \"NIC Link is Up %d Mbps %s duplex\\n\",\n\t\t\t\t\t    (db->op_mode == ULI526X_100MHF ||\n\t\t\t\t\t     db->op_mode == ULI526X_100MFD)\n\t\t\t\t\t    ? 100 : 10,\n\t\t\t\t\t    (db->op_mode == ULI526X_10MFD ||\n\t\t\t\t\t     db->op_mode == ULI526X_100MFD)\n\t\t\t\t\t    ? \"Full\" : \"Half\");\n\t\t\t\tnetif_carrier_on(dev);\n\t\t\t}\n\t\t\t \n\t\t}\n\t\telse if(!(tmp_cr12 & 0x3) && db->link_failed)\n\t\t{\n\t\t\tif(db->init==1)\n\t\t\t{\n\t\t\t\tnetdev_info(dev, \"NIC Link is Down\\n\");\n\t\t\t\tnetif_carrier_off(dev);\n\t\t\t}\n\t\t}\n\tdb->init = 0;\n\n\t \n\tdb->timer.expires = ULI526X_TIMER_WUT;\n\tadd_timer(&db->timer);\n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\n\n \n\nstatic void uli526x_reset_prepare(struct net_device *dev)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\t \n\tdb->cr6_data &= ~(CR6_RXSC | CR6_TXSC);\t \n\tupdate_cr6(db->cr6_data, ioaddr);\n\tuw32(DCR7, 0);\t\t\t\t \n\tuw32(DCR5, ur32(DCR5));\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tuli526x_free_rxbuffer(db);\n\n\t \n\tdb->tx_packet_cnt = 0;\n\tdb->rx_avail_cnt = 0;\n\tdb->link_failed = 1;\n\tdb->init=1;\n\tdb->wait_reset = 0;\n}\n\n\n \n\nstatic void uli526x_dynamic_reset(struct net_device *dev)\n{\n\tULI526X_DBUG(0, \"uli526x_dynamic_reset()\", 0);\n\n\tuli526x_reset_prepare(dev);\n\n\t \n\tuli526x_init(dev);\n\n\t \n\tnetif_wake_queue(dev);\n}\n\n \n\nstatic int __maybe_unused uli526x_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tULI526X_DBUG(0, \"uli526x_suspend\", 0);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tnetif_device_detach(dev);\n\tuli526x_reset_prepare(dev);\n\n\tdevice_set_wakeup_enable(dev_d, 0);\n\n\treturn 0;\n}\n\n \n\nstatic int __maybe_unused uli526x_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tULI526X_DBUG(0, \"uli526x_resume\", 0);\n\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tnetif_device_attach(dev);\n\t \n\tuli526x_init(dev);\n\t \n\tnetif_wake_queue(dev);\n\n\treturn 0;\n}\n\n \n\nstatic void uli526x_free_rxbuffer(struct uli526x_board_info * db)\n{\n\tULI526X_DBUG(0, \"uli526x_free_rxbuffer()\", 0);\n\n\t \n\twhile (db->rx_avail_cnt) {\n\t\tdev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);\n\t\tdb->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;\n\t\tdb->rx_avail_cnt--;\n\t}\n}\n\n\n \n\nstatic void uli526x_reuse_skb(struct uli526x_board_info *db, struct sk_buff * skb)\n{\n\tstruct rx_desc *rxptr = db->rx_insert_ptr;\n\n\tif (!(rxptr->rdes0 & cpu_to_le32(0x80000000))) {\n\t\trxptr->rx_skb_ptr = skb;\n\t\trxptr->rdes2 = cpu_to_le32(dma_map_single(&db->pdev->dev, skb_tail_pointer(skb),\n\t\t\t\t\t\t\t  RX_ALLOC_SIZE, DMA_FROM_DEVICE));\n\t\twmb();\n\t\trxptr->rdes0 = cpu_to_le32(0x80000000);\n\t\tdb->rx_avail_cnt++;\n\t\tdb->rx_insert_ptr = rxptr->next_rx_desc;\n\t} else\n\t\tULI526X_DBUG(0, \"SK Buffer reuse method error\", db->rx_avail_cnt);\n}\n\n\n \n\nstatic void uli526x_descriptor_init(struct net_device *dev, void __iomem *ioaddr)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tstruct tx_desc *tmp_tx;\n\tstruct rx_desc *tmp_rx;\n\tunsigned char *tmp_buf;\n\tdma_addr_t tmp_tx_dma, tmp_rx_dma;\n\tdma_addr_t tmp_buf_dma;\n\tint i;\n\n\tULI526X_DBUG(0, \"uli526x_descriptor_init()\", 0);\n\n\t \n\tdb->tx_insert_ptr = db->first_tx_desc;\n\tdb->tx_remove_ptr = db->first_tx_desc;\n\tuw32(DCR4, db->first_tx_desc_dma);\t \n\n\t \n\tdb->first_rx_desc = (void *)db->first_tx_desc + sizeof(struct tx_desc) * TX_DESC_CNT;\n\tdb->first_rx_desc_dma =  db->first_tx_desc_dma + sizeof(struct tx_desc) * TX_DESC_CNT;\n\tdb->rx_insert_ptr = db->first_rx_desc;\n\tdb->rx_ready_ptr = db->first_rx_desc;\n\tuw32(DCR3, db->first_rx_desc_dma);\t \n\n\t \n\ttmp_buf = db->buf_pool_start;\n\ttmp_buf_dma = db->buf_pool_dma_start;\n\ttmp_tx_dma = db->first_tx_desc_dma;\n\tfor (tmp_tx = db->first_tx_desc, i = 0; i < TX_DESC_CNT; i++, tmp_tx++) {\n\t\ttmp_tx->tx_buf_ptr = tmp_buf;\n\t\ttmp_tx->tdes0 = cpu_to_le32(0);\n\t\ttmp_tx->tdes1 = cpu_to_le32(0x81000000);\t \n\t\ttmp_tx->tdes2 = cpu_to_le32(tmp_buf_dma);\n\t\ttmp_tx_dma += sizeof(struct tx_desc);\n\t\ttmp_tx->tdes3 = cpu_to_le32(tmp_tx_dma);\n\t\ttmp_tx->next_tx_desc = tmp_tx + 1;\n\t\ttmp_buf = tmp_buf + TX_BUF_ALLOC;\n\t\ttmp_buf_dma = tmp_buf_dma + TX_BUF_ALLOC;\n\t}\n\t(--tmp_tx)->tdes3 = cpu_to_le32(db->first_tx_desc_dma);\n\ttmp_tx->next_tx_desc = db->first_tx_desc;\n\n\t  \n\ttmp_rx_dma=db->first_rx_desc_dma;\n\tfor (tmp_rx = db->first_rx_desc, i = 0; i < RX_DESC_CNT; i++, tmp_rx++) {\n\t\ttmp_rx->rdes0 = cpu_to_le32(0);\n\t\ttmp_rx->rdes1 = cpu_to_le32(0x01000600);\n\t\ttmp_rx_dma += sizeof(struct rx_desc);\n\t\ttmp_rx->rdes3 = cpu_to_le32(tmp_rx_dma);\n\t\ttmp_rx->next_rx_desc = tmp_rx + 1;\n\t}\n\t(--tmp_rx)->rdes3 = cpu_to_le32(db->first_rx_desc_dma);\n\ttmp_rx->next_rx_desc = db->first_rx_desc;\n\n\t \n\tallocate_rx_buffer(dev);\n}\n\n\n \nstatic void update_cr6(u32 cr6_data, void __iomem *ioaddr)\n{\n\tuw32(DCR6, cr6_data);\n\tudelay(5);\n}\n\n\n \n\n#ifdef __BIG_ENDIAN\n#define FLT_SHIFT 16\n#else\n#define FLT_SHIFT 0\n#endif\n\nstatic void send_filter_frame(struct net_device *dev, int mc_cnt)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tstruct netdev_hw_addr *ha;\n\tstruct tx_desc *txptr;\n\tconst u16 * addrptr;\n\tu32 * suptr;\n\tint i;\n\n\tULI526X_DBUG(0, \"send_filter_frame()\", 0);\n\n\ttxptr = db->tx_insert_ptr;\n\tsuptr = (u32 *) txptr->tx_buf_ptr;\n\n\t \n\taddrptr = (const u16 *) dev->dev_addr;\n\t*suptr++ = addrptr[0] << FLT_SHIFT;\n\t*suptr++ = addrptr[1] << FLT_SHIFT;\n\t*suptr++ = addrptr[2] << FLT_SHIFT;\n\n\t \n\t*suptr++ = 0xffff << FLT_SHIFT;\n\t*suptr++ = 0xffff << FLT_SHIFT;\n\t*suptr++ = 0xffff << FLT_SHIFT;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\taddrptr = (u16 *) ha->addr;\n\t\t*suptr++ = addrptr[0] << FLT_SHIFT;\n\t\t*suptr++ = addrptr[1] << FLT_SHIFT;\n\t\t*suptr++ = addrptr[2] << FLT_SHIFT;\n\t}\n\n\tfor (i = netdev_mc_count(dev); i < 14; i++) {\n\t\t*suptr++ = 0xffff << FLT_SHIFT;\n\t\t*suptr++ = 0xffff << FLT_SHIFT;\n\t\t*suptr++ = 0xffff << FLT_SHIFT;\n\t}\n\n\t \n\tdb->tx_insert_ptr = txptr->next_tx_desc;\n\ttxptr->tdes1 = cpu_to_le32(0x890000c0);\n\n\t \n\tif (db->tx_packet_cnt < TX_DESC_CNT) {\n\t\t \n\t\tdb->tx_packet_cnt++;\n\t\ttxptr->tdes0 = cpu_to_le32(0x80000000);\n\t\tupdate_cr6(db->cr6_data | 0x2000, ioaddr);\n\t\tuw32(DCR1, 0x1);\t \n\t\tupdate_cr6(db->cr6_data, ioaddr);\n\t\tnetif_trans_update(dev);\n\t} else\n\t\tnetdev_err(dev, \"No Tx resource - Send_filter_frame!\\n\");\n}\n\n\n \n\nstatic void allocate_rx_buffer(struct net_device *dev)\n{\n\tstruct uli526x_board_info *db = netdev_priv(dev);\n\tstruct rx_desc *rxptr;\n\tstruct sk_buff *skb;\n\n\trxptr = db->rx_insert_ptr;\n\n\twhile(db->rx_avail_cnt < RX_DESC_CNT) {\n\t\tskb = netdev_alloc_skb(dev, RX_ALLOC_SIZE);\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\trxptr->rx_skb_ptr = skb;  \n\t\trxptr->rdes2 = cpu_to_le32(dma_map_single(&db->pdev->dev, skb_tail_pointer(skb),\n\t\t\t\t\t\t\t  RX_ALLOC_SIZE, DMA_FROM_DEVICE));\n\t\twmb();\n\t\trxptr->rdes0 = cpu_to_le32(0x80000000);\n\t\trxptr = rxptr->next_rx_desc;\n\t\tdb->rx_avail_cnt++;\n\t}\n\n\tdb->rx_insert_ptr = rxptr;\n}\n\n\n \n\nstatic u16 read_srom_word(struct uli526x_board_info *db, int offset)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu16 srom_data = 0;\n\tint i;\n\n\tuw32(DCR9, CR9_SROM_READ);\n\tuw32(DCR9, CR9_SROM_READ | CR9_SRCS);\n\n\t \n\tsrom_clk_write(db, SROM_DATA_1);\n\tsrom_clk_write(db, SROM_DATA_1);\n\tsrom_clk_write(db, SROM_DATA_0);\n\n\t \n\tfor (i = 5; i >= 0; i--) {\n\t\tsrom_data = (offset & (1 << i)) ? SROM_DATA_1 : SROM_DATA_0;\n\t\tsrom_clk_write(db, srom_data);\n\t}\n\n\tuw32(DCR9, CR9_SROM_READ | CR9_SRCS);\n\n\tfor (i = 16; i > 0; i--) {\n\t\tuw32(DCR9, CR9_SROM_READ | CR9_SRCS | CR9_SRCLK);\n\t\tudelay(5);\n\t\tsrom_data = (srom_data << 1) |\n\t\t\t    ((ur32(DCR9) & CR9_CRDOUT) ? 1 : 0);\n\t\tuw32(DCR9, CR9_SROM_READ | CR9_SRCS);\n\t\tudelay(5);\n\t}\n\n\tuw32(DCR9, CR9_SROM_READ);\n\treturn srom_data;\n}\n\n\n \n\nstatic u8 uli526x_sense_speed(struct uli526x_board_info * db)\n{\n\tstruct uli_phy_ops *phy = &db->phy;\n\tu8 ErrFlag = 0;\n\tu16 phy_mode;\n\n\tphy_mode = phy->read(db, db->phy_addr, 1);\n\tphy_mode = phy->read(db, db->phy_addr, 1);\n\n\tif ( (phy_mode & 0x24) == 0x24 ) {\n\n\t\tphy_mode = ((phy->read(db, db->phy_addr, 5) & 0x01e0)<<7);\n\t\tif(phy_mode&0x8000)\n\t\t\tphy_mode = 0x8000;\n\t\telse if(phy_mode&0x4000)\n\t\t\tphy_mode = 0x4000;\n\t\telse if(phy_mode&0x2000)\n\t\t\tphy_mode = 0x2000;\n\t\telse\n\t\t\tphy_mode = 0x1000;\n\n\t\tswitch (phy_mode) {\n\t\tcase 0x1000: db->op_mode = ULI526X_10MHF; break;\n\t\tcase 0x2000: db->op_mode = ULI526X_10MFD; break;\n\t\tcase 0x4000: db->op_mode = ULI526X_100MHF; break;\n\t\tcase 0x8000: db->op_mode = ULI526X_100MFD; break;\n\t\tdefault: db->op_mode = ULI526X_10MHF; ErrFlag = 1; break;\n\t\t}\n\t} else {\n\t\tdb->op_mode = ULI526X_10MHF;\n\t\tULI526X_DBUG(0, \"Link Failed :\", phy_mode);\n\t\tErrFlag = 1;\n\t}\n\n\treturn ErrFlag;\n}\n\n\n \n\nstatic void uli526x_set_phyxcer(struct uli526x_board_info *db)\n{\n\tstruct uli_phy_ops *phy = &db->phy;\n\tu16 phy_reg;\n\n\t \n\tphy_reg = phy->read(db, db->phy_addr, 4) & ~0x01e0;\n\n\tif (db->media_mode & ULI526X_AUTO) {\n\t\t \n\t\tphy_reg |= db->PHY_reg4;\n\t} else {\n\t\t \n\t\tswitch(db->media_mode) {\n\t\tcase ULI526X_10MHF: phy_reg |= 0x20; break;\n\t\tcase ULI526X_10MFD: phy_reg |= 0x40; break;\n\t\tcase ULI526X_100MHF: phy_reg |= 0x80; break;\n\t\tcase ULI526X_100MFD: phy_reg |= 0x100; break;\n\t\t}\n\n\t}\n\n\t \n\tif ( !(phy_reg & 0x01e0)) {\n\t\tphy_reg|=db->PHY_reg4;\n\t\tdb->media_mode|=ULI526X_AUTO;\n\t}\n\tphy->write(db, db->phy_addr, 4, phy_reg);\n\n\t \n\tphy->write(db, db->phy_addr, 0, 0x1200);\n\tudelay(50);\n}\n\n\n \n\nstatic void uli526x_process_mode(struct uli526x_board_info *db)\n{\n\tstruct uli_phy_ops *phy = &db->phy;\n\tu16 phy_reg;\n\n\t \n\tif (db->op_mode & 0x4)\n\t\tdb->cr6_data |= CR6_FDM;\t \n\telse\n\t\tdb->cr6_data &= ~CR6_FDM;\t \n\n\tupdate_cr6(db->cr6_data, db->ioaddr);\n\n\t \n\tif (!(db->media_mode & 0x8)) {\n\t\t \n\t\tphy_reg = phy->read(db, db->phy_addr, 6);\n\t\tif (!(phy_reg & 0x1)) {\n\t\t\t \n\t\t\tphy_reg = 0x0;\n\t\t\tswitch(db->op_mode) {\n\t\t\tcase ULI526X_10MHF: phy_reg = 0x0; break;\n\t\t\tcase ULI526X_10MFD: phy_reg = 0x100; break;\n\t\t\tcase ULI526X_100MHF: phy_reg = 0x2000; break;\n\t\t\tcase ULI526X_100MFD: phy_reg = 0x2100; break;\n\t\t\t}\n\t\t\tphy->write(db, db->phy_addr, 0, phy_reg);\n\t\t}\n\t}\n}\n\n\n \nstatic void phy_writeby_cr9(struct uli526x_board_info *db, u8 phy_addr,\n\t\t\t    u8 offset, u16 phy_data)\n{\n\tu16 i;\n\n\t \n\tfor (i = 0; i < 35; i++)\n\t\tphy_write_1bit(db, PHY_DATA_1);\n\n\t \n\tphy_write_1bit(db, PHY_DATA_0);\n\tphy_write_1bit(db, PHY_DATA_1);\n\n\t \n\tphy_write_1bit(db, PHY_DATA_0);\n\tphy_write_1bit(db, PHY_DATA_1);\n\n\t \n\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\tphy_write_1bit(db, phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t \n\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\tphy_write_1bit(db, offset & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t \n\tphy_write_1bit(db, PHY_DATA_1);\n\tphy_write_1bit(db, PHY_DATA_0);\n\n\t \n\tfor (i = 0x8000; i > 0; i >>= 1)\n\t\tphy_write_1bit(db, phy_data & i ? PHY_DATA_1 : PHY_DATA_0);\n}\n\nstatic u16 phy_readby_cr9(struct uli526x_board_info *db, u8 phy_addr, u8 offset)\n{\n\tu16 phy_data;\n\tint i;\n\n\t \n\tfor (i = 0; i < 35; i++)\n\t\tphy_write_1bit(db, PHY_DATA_1);\n\n\t \n\tphy_write_1bit(db, PHY_DATA_0);\n\tphy_write_1bit(db, PHY_DATA_1);\n\n\t \n\tphy_write_1bit(db, PHY_DATA_1);\n\tphy_write_1bit(db, PHY_DATA_0);\n\n\t \n\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\tphy_write_1bit(db, phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t \n\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\tphy_write_1bit(db, offset & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t \n\tphy_read_1bit(db);\n\n\t \n\tfor (phy_data = 0, i = 0; i < 16; i++) {\n\t\tphy_data <<= 1;\n\t\tphy_data |= phy_read_1bit(db);\n\t}\n\n\treturn phy_data;\n}\n\nstatic u16 phy_readby_cr10(struct uli526x_board_info *db, u8 phy_addr,\n\t\t\t   u8 offset)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu32 cr10_value = phy_addr;\n\n\tcr10_value = (cr10_value <<  5) + offset;\n\tcr10_value = (cr10_value << 16) + 0x08000000;\n\tuw32(DCR10, cr10_value);\n\tudelay(1);\n\twhile (1) {\n\t\tcr10_value = ur32(DCR10);\n\t\tif (cr10_value & 0x10000000)\n\t\t\tbreak;\n\t}\n\treturn cr10_value & 0x0ffff;\n}\n\nstatic void phy_writeby_cr10(struct uli526x_board_info *db, u8 phy_addr,\n\t\t\t     u8 offset, u16 phy_data)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu32 cr10_value = phy_addr;\n\n\tcr10_value = (cr10_value <<  5) + offset;\n\tcr10_value = (cr10_value << 16) + 0x04000000 + phy_data;\n\tuw32(DCR10, cr10_value);\n\tudelay(1);\n}\n \n\nstatic void phy_write_1bit(struct uli526x_board_info *db, u32 data)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\tuw32(DCR9, data);\t\t \n\tudelay(1);\n\tuw32(DCR9, data | MDCLKH);\t \n\tudelay(1);\n\tuw32(DCR9, data);\t\t \n\tudelay(1);\n}\n\n\n \n\nstatic u16 phy_read_1bit(struct uli526x_board_info *db)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu16 phy_data;\n\n\tuw32(DCR9, 0x50000);\n\tudelay(1);\n\tphy_data = (ur32(DCR9) >> 19) & 0x1;\n\tuw32(DCR9, 0x40000);\n\tudelay(1);\n\n\treturn phy_data;\n}\n\n\nstatic const struct pci_device_id uli526x_pci_tbl[] = {\n\t{ 0x10B9, 0x5261, PCI_ANY_ID, PCI_ANY_ID, 0, 0, PCI_ULI5261_ID },\n\t{ 0x10B9, 0x5263, PCI_ANY_ID, PCI_ANY_ID, 0, 0, PCI_ULI5263_ID },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, uli526x_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(uli526x_pm_ops, uli526x_suspend, uli526x_resume);\n\nstatic struct pci_driver uli526x_driver = {\n\t.name\t\t= \"uli526x\",\n\t.id_table\t= uli526x_pci_tbl,\n\t.probe\t\t= uli526x_init_one,\n\t.remove\t\t= uli526x_remove_one,\n\t.driver.pm\t= &uli526x_pm_ops,\n};\n\nMODULE_AUTHOR(\"Peer Chen, peer.chen@uli.com.tw\");\nMODULE_DESCRIPTION(\"ULi M5261/M5263 fast ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(debug, int, 0644);\nmodule_param(mode, int, 0);\nmodule_param(cr6set, int, 0);\nMODULE_PARM_DESC(debug, \"ULi M5261/M5263 enable debugging (0-1)\");\nMODULE_PARM_DESC(mode, \"ULi M5261/M5263: Bit 0: 10/100Mbps, bit 2: duplex, bit 8: HomePNA\");\n\n \n\nstatic int __init uli526x_init_module(void)\n{\n\n\tULI526X_DBUG(0, \"init_module() \", debug);\n\n\tif (debug)\n\t\tuli526x_debug = debug;\t \n\tif (cr6set)\n\t\tuli526x_cr6_user_set = cr6set;\n\n\tswitch (mode) {\n\tcase ULI526X_10MHF:\n\tcase ULI526X_100MHF:\n\tcase ULI526X_10MFD:\n\tcase ULI526X_100MFD:\n\t\tuli526x_media_mode = mode;\n\t\tbreak;\n\tdefault:\n\t\tuli526x_media_mode = ULI526X_AUTO;\n\t\tbreak;\n\t}\n\n\treturn pci_register_driver(&uli526x_driver);\n}\n\n\n \n\nstatic void __exit uli526x_cleanup_module(void)\n{\n\tULI526X_DBUG(0, \"uli526x_cleanup_module() \", debug);\n\tpci_unregister_driver(&uli526x_driver);\n}\n\nmodule_init(uli526x_init_module);\nmodule_exit(uli526x_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}