{
  "module_name": "winbond-840.c",
  "hash_id": "bfb6d96bc3574e0942aff54fabd0c3768573098cc53a8669de4244f5baf5b076",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/winbond-840.c",
  "human_readable_source": " \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"winbond-840\"\n\n \n\n \n\nstatic int debug = 1;\t\t\t \nstatic int max_interrupt_work = 20;\n \nstatic int multicast_filter_limit = 32;\n\n \nstatic int rx_copybreak;\n\n \n#define MAX_UNITS 8\t\t \nstatic int options[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int full_duplex[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\n\n \n\n \n#define TX_QUEUE_LEN\t10\t\t \n#define TX_QUEUE_LEN_RESTART\t5\n\n#define TX_BUFLIMIT\t(1024-128)\n\n \n#define TX_FIFO_SIZE (2048)\n#define TX_BUG_FIFO_LIMIT (TX_FIFO_SIZE-1514-16)\n\n\n \n \n#define TX_TIMEOUT  (2*HZ)\n\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/rtnetlink.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\t\t \n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include \"tulip.h\"\n\n#undef PKT_BUF_SZ\t\t\t \n#define PKT_BUF_SZ\t\t1536\t \n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"Winbond W89c840 Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(max_interrupt_work, int, 0);\nmodule_param(debug, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param(multicast_filter_limit, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nMODULE_PARM_DESC(max_interrupt_work, \"winbond-840 maximum events handled per interrupt\");\nMODULE_PARM_DESC(debug, \"winbond-840 debug level (0-6)\");\nMODULE_PARM_DESC(rx_copybreak, \"winbond-840 copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(multicast_filter_limit, \"winbond-840 maximum number of filtered multicast addresses\");\nMODULE_PARM_DESC(options, \"winbond-840: Bits 0-3: media type, bit 17: full duplex\");\nMODULE_PARM_DESC(full_duplex, \"winbond-840 full duplex setting(s) (1)\");\n\n \n\n\n\n \nenum chip_capability_flags {\n\tCanHaveMII=1, HasBrokenTx=2, AlwaysFDX=4, FDXOnNoMII=8,\n};\n\nstatic const struct pci_device_id w840_pci_tbl[] = {\n\t{ 0x1050, 0x0840, PCI_ANY_ID, 0x8153,     0, 0, 0 },\n\t{ 0x1050, 0x0840, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },\n\t{ 0x11f6, 0x2011, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, w840_pci_tbl);\n\nenum {\n\tnetdev_res_size\t\t= 128,\t \n};\n\nstruct pci_id_info {\n        const char *name;\n        int drv_flags;\t\t \n};\n\nstatic const struct pci_id_info pci_id_tbl[] = {\n\t{ \t\t\t\t \n\t  \"Winbond W89c840\",\tCanHaveMII | HasBrokenTx | FDXOnNoMII},\n\t{ \"Winbond W89c840\",\tCanHaveMII | HasBrokenTx},\n\t{ \"Compex RL100-ATX\",\tCanHaveMII | HasBrokenTx},\n\t{ }\t \n};\n\n \n\n \nenum w840_offsets {\n\tPCIBusCfg=0x00, TxStartDemand=0x04, RxStartDemand=0x08,\n\tRxRingPtr=0x0C, TxRingPtr=0x10,\n\tIntrStatus=0x14, NetworkConfig=0x18, IntrEnable=0x1C,\n\tRxMissed=0x20, EECtrl=0x24, MIICtrl=0x24, BootRom=0x28, GPTimer=0x2C,\n\tCurRxDescAddr=0x30, CurRxBufAddr=0x34,\t\t\t \n\tMulticastFilter0=0x38, MulticastFilter1=0x3C, StationAddr=0x40,\n\tCurTxDescAddr=0x4C, CurTxBufAddr=0x50,\n};\n\n \nenum rx_mode_bits {\n\tAcceptErr=0x80,\n\tRxAcceptBroadcast=0x20, AcceptMulticast=0x10,\n\tRxAcceptAllPhys=0x08, AcceptMyPhys=0x02,\n};\n\nenum mii_reg_bits {\n\tMDIO_ShiftClk=0x10000, MDIO_DataIn=0x80000, MDIO_DataOut=0x20000,\n\tMDIO_EnbOutput=0x40000, MDIO_EnbIn = 0x00000,\n};\n\n \nstruct w840_rx_desc {\n\ts32 status;\n\ts32 length;\n\tu32 buffer1;\n\tu32 buffer2;\n};\n\nstruct w840_tx_desc {\n\ts32 status;\n\ts32 length;\n\tu32 buffer1, buffer2;\n};\n\n#define MII_CNT\t\t1  \nstruct netdev_private {\n\tstruct w840_rx_desc *rx_ring;\n\tdma_addr_t\trx_addr[RX_RING_SIZE];\n\tstruct w840_tx_desc *tx_ring;\n\tdma_addr_t\ttx_addr[TX_RING_SIZE];\n\tdma_addr_t ring_dma_addr;\n\t \n\tstruct sk_buff* rx_skbuff[RX_RING_SIZE];\n\t \n\tstruct sk_buff* tx_skbuff[TX_RING_SIZE];\n\tstruct net_device_stats stats;\n\tstruct timer_list timer;\t \n\t \n\tspinlock_t lock;\n\tint chip_id, drv_flags;\n\tstruct pci_dev *pci_dev;\n\tint csr6;\n\tstruct w840_rx_desc *rx_head_desc;\n\tunsigned int cur_rx, dirty_rx;\t\t \n\tunsigned int rx_buf_sz;\t\t\t\t \n\tunsigned int cur_tx, dirty_tx;\n\tunsigned int tx_q_bytes;\n\tunsigned int tx_full;\t\t\t\t \n\t \n\tint mii_cnt;\t\t\t\t\t\t \n\tunsigned char phys[MII_CNT];\t\t \n\tu32 mii;\n\tstruct mii_if_info mii_if;\n\tvoid __iomem *base_addr;\n};\n\nstatic int  eeprom_read(void __iomem *ioaddr, int location);\nstatic int  mdio_read(struct net_device *dev, int phy_id, int location);\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value);\nstatic int  netdev_open(struct net_device *dev);\nstatic int  update_link(struct net_device *dev);\nstatic void netdev_timer(struct timer_list *t);\nstatic void init_rxtx_rings(struct net_device *dev);\nstatic void free_rxtx_rings(struct netdev_private *np);\nstatic void init_registers(struct net_device *dev);\nstatic void tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic int alloc_ringdesc(struct net_device *dev);\nstatic void free_ringdesc(struct netdev_private *np);\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t intr_handler(int irq, void *dev_instance);\nstatic void netdev_error(struct net_device *dev, int intr_status);\nstatic int  netdev_rx(struct net_device *dev);\nstatic u32 __set_rx_mode(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic struct net_device_stats *get_stats(struct net_device *dev);\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic const struct ethtool_ops netdev_ethtool_ops;\nstatic int  netdev_close(struct net_device *dev);\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= netdev_open,\n\t.ndo_stop\t\t= netdev_close,\n\t.ndo_start_xmit\t\t= start_tx,\n\t.ndo_get_stats\t\t= get_stats,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_eth_ioctl\t\t= netdev_ioctl,\n\t.ndo_tx_timeout\t\t= tx_timeout,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int w840_probe1(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct netdev_private *np;\n\tstatic int find_cnt;\n\tint chip_idx = ent->driver_data;\n\tint irq;\n\tint i, option = find_cnt < MAX_UNITS ? options[find_cnt] : 0;\n\t__le16 addr[ETH_ALEN / 2];\n\tvoid __iomem *ioaddr;\n\n\ti = pcim_enable_device(pdev);\n\tif (i) return i;\n\n\tpci_set_master(pdev);\n\n\tirq = pdev->irq;\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tpr_warn(\"Device %s disabled due to DMA limitations\\n\",\n\t\t\tpci_name(pdev));\n\t\treturn -EIO;\n\t}\n\tdev = alloc_etherdev(sizeof(*np));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tif (pci_request_regions(pdev, DRV_NAME))\n\t\tgoto err_out_netdev;\n\n\tioaddr = pci_iomap(pdev, TULIP_BAR, netdev_res_size);\n\tif (!ioaddr)\n\t\tgoto err_out_netdev;\n\n\tfor (i = 0; i < 3; i++)\n\t\taddr[i] = cpu_to_le16(eeprom_read(ioaddr, i));\n\teth_hw_addr_set(dev, (u8 *)addr);\n\n\t \n\tiowrite32(0x00000001, ioaddr + PCIBusCfg);\n\n\tnp = netdev_priv(dev);\n\tnp->pci_dev = pdev;\n\tnp->chip_id = chip_idx;\n\tnp->drv_flags = pci_id_tbl[chip_idx].drv_flags;\n\tspin_lock_init(&np->lock);\n\tnp->mii_if.dev = dev;\n\tnp->mii_if.mdio_read = mdio_read;\n\tnp->mii_if.mdio_write = mdio_write;\n\tnp->base_addr = ioaddr;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tif (dev->mem_start)\n\t\toption = dev->mem_start;\n\n\t \n\tif (option > 0) {\n\t\tif (option & 0x200)\n\t\t\tnp->mii_if.full_duplex = 1;\n\t\tif (option & 15)\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t \"ignoring user supplied media type %d\",\n\t\t\t\t option & 15);\n\t}\n\tif (find_cnt < MAX_UNITS  &&  full_duplex[find_cnt] > 0)\n\t\tnp->mii_if.full_duplex = 1;\n\n\tif (np->mii_if.full_duplex)\n\t\tnp->mii_if.force_media = 1;\n\n\t \n\tdev->netdev_ops = &netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\ti = register_netdev(dev);\n\tif (i)\n\t\tgoto err_out_cleardev;\n\n\tdev_info(&dev->dev, \"%s at %p, %pM, IRQ %d\\n\",\n\t\t pci_id_tbl[chip_idx].name, ioaddr, dev->dev_addr, irq);\n\n\tif (np->drv_flags & CanHaveMII) {\n\t\tint phy, phy_idx = 0;\n\t\tfor (phy = 1; phy < 32 && phy_idx < MII_CNT; phy++) {\n\t\t\tint mii_status = mdio_read(dev, phy, MII_BMSR);\n\t\t\tif (mii_status != 0xffff  &&  mii_status != 0x0000) {\n\t\t\t\tnp->phys[phy_idx++] = phy;\n\t\t\t\tnp->mii_if.advertising = mdio_read(dev, phy, MII_ADVERTISE);\n\t\t\t\tnp->mii = (mdio_read(dev, phy, MII_PHYSID1) << 16)+\n\t\t\t\t\t\tmdio_read(dev, phy, MII_PHYSID2);\n\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t \"MII PHY %08xh found at address %d, status 0x%04x advertising %04x\\n\",\n\t\t\t\t\t np->mii, phy, mii_status,\n\t\t\t\t\t np->mii_if.advertising);\n\t\t\t}\n\t\t}\n\t\tnp->mii_cnt = phy_idx;\n\t\tnp->mii_if.phy_id = np->phys[0];\n\t\tif (phy_idx == 0) {\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"MII PHY not found -- this device may not operate correctly\\n\");\n\t\t}\n\t}\n\n\tfind_cnt++;\n\treturn 0;\n\nerr_out_cleardev:\n\tpci_iounmap(pdev, ioaddr);\nerr_out_netdev:\n\tfree_netdev (dev);\n\treturn -ENODEV;\n}\n\n\n \n\n \n#define eeprom_delay(ee_addr)\tioread32(ee_addr)\n\nenum EEPROM_Ctrl_Bits {\n\tEE_ShiftClk=0x02, EE_Write0=0x801, EE_Write1=0x805,\n\tEE_ChipSelect=0x801, EE_DataIn=0x08,\n};\n\n \nenum EEPROM_Cmds {\n\tEE_WriteCmd=(5 << 6), EE_ReadCmd=(6 << 6), EE_EraseCmd=(7 << 6),\n};\n\nstatic int eeprom_read(void __iomem *addr, int location)\n{\n\tint i;\n\tint retval = 0;\n\tvoid __iomem *ee_addr = addr + EECtrl;\n\tint read_cmd = location | EE_ReadCmd;\n\tiowrite32(EE_ChipSelect, ee_addr);\n\n\t \n\tfor (i = 10; i >= 0; i--) {\n\t\tshort dataval = (read_cmd & (1 << i)) ? EE_Write1 : EE_Write0;\n\t\tiowrite32(dataval, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t\tiowrite32(dataval | EE_ShiftClk, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t}\n\tiowrite32(EE_ChipSelect, ee_addr);\n\teeprom_delay(ee_addr);\n\n\tfor (i = 16; i > 0; i--) {\n\t\tiowrite32(EE_ChipSelect | EE_ShiftClk, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t\tretval = (retval << 1) | ((ioread32(ee_addr) & EE_DataIn) ? 1 : 0);\n\t\tiowrite32(EE_ChipSelect, ee_addr);\n\t\teeprom_delay(ee_addr);\n\t}\n\n\t \n\tiowrite32(0, ee_addr);\n\treturn retval;\n}\n\n \n#define mdio_delay(mdio_addr) ioread32(mdio_addr)\n\n \nstatic char mii_preamble_required = 1;\n\n#define MDIO_WRITE0 (MDIO_EnbOutput)\n#define MDIO_WRITE1 (MDIO_DataOut | MDIO_EnbOutput)\n\n \nstatic void mdio_sync(void __iomem *mdio_addr)\n{\n\tint bits = 32;\n\n\t \n\twhile (--bits >= 0) {\n\t\tiowrite32(MDIO_WRITE1, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t\tiowrite32(MDIO_WRITE1 | MDIO_ShiftClk, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t}\n}\n\nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *mdio_addr = np->base_addr + MIICtrl;\n\tint mii_cmd = (0xf6 << 10) | (phy_id << 5) | location;\n\tint i, retval = 0;\n\n\tif (mii_preamble_required)\n\t\tmdio_sync(mdio_addr);\n\n\t \n\tfor (i = 15; i >= 0; i--) {\n\t\tint dataval = (mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;\n\n\t\tiowrite32(dataval, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t\tiowrite32(dataval | MDIO_ShiftClk, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t}\n\t \n\tfor (i = 20; i > 0; i--) {\n\t\tiowrite32(MDIO_EnbIn, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t\tretval = (retval << 1) | ((ioread32(mdio_addr) & MDIO_DataIn) ? 1 : 0);\n\t\tiowrite32(MDIO_EnbIn | MDIO_ShiftClk, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t}\n\treturn (retval>>1) & 0xffff;\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *mdio_addr = np->base_addr + MIICtrl;\n\tint mii_cmd = (0x5002 << 16) | (phy_id << 23) | (location<<18) | value;\n\tint i;\n\n\tif (location == 4  &&  phy_id == np->phys[0])\n\t\tnp->mii_if.advertising = value;\n\n\tif (mii_preamble_required)\n\t\tmdio_sync(mdio_addr);\n\n\t \n\tfor (i = 31; i >= 0; i--) {\n\t\tint dataval = (mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;\n\n\t\tiowrite32(dataval, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t\tiowrite32(dataval | MDIO_ShiftClk, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t}\n\t \n\tfor (i = 2; i > 0; i--) {\n\t\tiowrite32(MDIO_EnbIn, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t\tiowrite32(MDIO_EnbIn | MDIO_ShiftClk, mdio_addr);\n\t\tmdio_delay(mdio_addr);\n\t}\n}\n\n\nstatic int netdev_open(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\tconst int irq = np->pci_dev->irq;\n\tint i;\n\n\tiowrite32(0x00000001, ioaddr + PCIBusCfg);\t\t \n\n\tnetif_device_detach(dev);\n\ti = request_irq(irq, intr_handler, IRQF_SHARED, dev->name, dev);\n\tif (i)\n\t\tgoto out_err;\n\n\tif (debug > 1)\n\t\tnetdev_dbg(dev, \"%s() irq %d\\n\", __func__, irq);\n\n\ti = alloc_ringdesc(dev);\n\tif (i)\n\t\tgoto out_err;\n\n\tspin_lock_irq(&np->lock);\n\tnetif_device_attach(dev);\n\tinit_registers(dev);\n\tspin_unlock_irq(&np->lock);\n\n\tnetif_start_queue(dev);\n\tif (debug > 2)\n\t\tnetdev_dbg(dev, \"Done %s()\\n\", __func__);\n\n\t \n\ttimer_setup(&np->timer, netdev_timer, 0);\n\tnp->timer.expires = jiffies + 1*HZ;\n\tadd_timer(&np->timer);\n\treturn 0;\nout_err:\n\tnetif_device_attach(dev);\n\treturn i;\n}\n\n#define MII_DAVICOM_DM9101\t0x0181b800\n\nstatic int update_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint duplex, fasteth, result, mii_reg;\n\n\t \n\tmii_reg = mdio_read(dev, np->phys[0], MII_BMSR);\n\n\tif (mii_reg == 0xffff)\n\t\treturn np->csr6;\n\t \n\tmii_reg = mdio_read(dev, np->phys[0], MII_BMSR);\n\tif (!(mii_reg & 0x4)) {\n\t\tif (netif_carrier_ok(dev)) {\n\t\t\tif (debug)\n\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t \"MII #%d reports no link. Disabling watchdog\\n\",\n\t\t\t\t\t np->phys[0]);\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t\treturn np->csr6;\n\t}\n\tif (!netif_carrier_ok(dev)) {\n\t\tif (debug)\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t \"MII #%d link is back. Enabling watchdog\\n\",\n\t\t\t\t np->phys[0]);\n\t\tnetif_carrier_on(dev);\n\t}\n\n\tif ((np->mii & ~0xf) == MII_DAVICOM_DM9101) {\n\t\t \n\t\tmii_reg = mdio_read(dev, np->phys[0], MII_BMCR);\n\t\tduplex = mii_reg & BMCR_FULLDPLX;\n\t\tfasteth = mii_reg & BMCR_SPEED100;\n\t} else {\n\t\tint negotiated;\n\t\tmii_reg\t= mdio_read(dev, np->phys[0], MII_LPA);\n\t\tnegotiated = mii_reg & np->mii_if.advertising;\n\n\t\tduplex = (negotiated & LPA_100FULL) || ((negotiated & 0x02C0) == LPA_10FULL);\n\t\tfasteth = negotiated & 0x380;\n\t}\n\tduplex |= np->mii_if.force_media;\n\t \n\tresult = np->csr6 & ~0x20000200;\n\tif (duplex)\n\t\tresult |= 0x200;\n\tif (fasteth)\n\t\tresult |= 0x20000000;\n\tif (result != np->csr6 && debug)\n\t\tdev_info(&dev->dev,\n\t\t\t \"Setting %dMBit-%s-duplex based on MII#%d\\n\",\n\t\t\t fasteth ? 100 : 10, duplex ? \"full\" : \"half\",\n\t\t\t np->phys[0]);\n\treturn result;\n}\n\n#define RXTX_TIMEOUT\t2000\nstatic inline void update_csr6(struct net_device *dev, int new)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\tint limit = RXTX_TIMEOUT;\n\n\tif (!netif_device_present(dev))\n\t\tnew = 0;\n\tif (new==np->csr6)\n\t\treturn;\n\t \n\tiowrite32(np->csr6 & ~0x2002, ioaddr + NetworkConfig);\n\t \n\tfor (;;) {\n\t\tint csr5 = ioread32(ioaddr + IntrStatus);\n\t\tint t;\n\n\t\tt = (csr5 >> 17) & 0x07;\n\t\tif (t==0||t==1) {\n\t\t\t \n\t\t\tt = (csr5 >> 20) & 0x07;\n\t\t\tif (t==0||t==1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlimit--;\n\t\tif(!limit) {\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t \"couldn't stop rxtx, IntrStatus %xh\\n\", csr5);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\tnp->csr6 = new;\n\t \n\tiowrite32(np->csr6, ioaddr + NetworkConfig);\n\tif (new & 0x200)\n\t\tnp->mii_if.full_duplex = 1;\n}\n\nstatic void netdev_timer(struct timer_list *t)\n{\n\tstruct netdev_private *np = from_timer(np, t, timer);\n\tstruct net_device *dev = pci_get_drvdata(np->pci_dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\n\tif (debug > 2)\n\t\tnetdev_dbg(dev, \"Media selection timer tick, status %08x config %08x\\n\",\n\t\t\t   ioread32(ioaddr + IntrStatus),\n\t\t\t   ioread32(ioaddr + NetworkConfig));\n\tspin_lock_irq(&np->lock);\n\tupdate_csr6(dev, update_link(dev));\n\tspin_unlock_irq(&np->lock);\n\tnp->timer.expires = jiffies + 10*HZ;\n\tadd_timer(&np->timer);\n}\n\nstatic void init_rxtx_rings(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\tnp->rx_head_desc = &np->rx_ring[0];\n\tnp->tx_ring = (struct w840_tx_desc*)&np->rx_ring[RX_RING_SIZE];\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].length = np->rx_buf_sz;\n\t\tnp->rx_ring[i].status = 0;\n\t\tnp->rx_skbuff[i] = NULL;\n\t}\n\t \n\tnp->rx_ring[i-1].length |= DescEndRing;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, np->rx_buf_sz);\n\t\tnp->rx_skbuff[i] = skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\tnp->rx_addr[i] = dma_map_single(&np->pci_dev->dev, skb->data,\n\t\t\t\t\t\tnp->rx_buf_sz,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tnp->rx_ring[i].buffer1 = np->rx_addr[i];\n\t\tnp->rx_ring[i].status = DescOwned;\n\t}\n\n\tnp->cur_rx = 0;\n\tnp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tnp->tx_skbuff[i] = NULL;\n\t\tnp->tx_ring[i].status = 0;\n\t}\n\tnp->tx_full = 0;\n\tnp->tx_q_bytes = np->dirty_tx = np->cur_tx = 0;\n\n\tiowrite32(np->ring_dma_addr, np->base_addr + RxRingPtr);\n\tiowrite32(np->ring_dma_addr+sizeof(struct w840_rx_desc)*RX_RING_SIZE,\n\t\tnp->base_addr + TxRingPtr);\n\n}\n\nstatic void free_rxtx_rings(struct netdev_private* np)\n{\n\tint i;\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].status = 0;\n\t\tif (np->rx_skbuff[i]) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev, np->rx_addr[i],\n\t\t\t\t\t np->rx_skbuff[i]->len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(np->rx_skbuff[i]);\n\t\t}\n\t\tnp->rx_skbuff[i] = NULL;\n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tif (np->tx_skbuff[i]) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev, np->tx_addr[i],\n\t\t\t\t\t np->tx_skbuff[i]->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(np->tx_skbuff[i]);\n\t\t}\n\t\tnp->tx_skbuff[i] = NULL;\n\t}\n}\n\nstatic void init_registers(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\tint i;\n\n\tfor (i = 0; i < 6; i++)\n\t\tiowrite8(dev->dev_addr[i], ioaddr + StationAddr + i);\n\n\t \n#ifdef __BIG_ENDIAN\n\ti = (1<<20);\t \n#else\n\ti = 0;\n#endif\n\ti |= (0x04<<2);\t\t \n\ti |= 0x02;\t\t \n\n\t \n\n#if defined (__i386__) && !defined(MODULE) && !defined(CONFIG_UML)\n\t \n\tif (boot_cpu_data.x86 <= 4) {\n\t\ti |= 0x4800;\n\t\tdev_info(&dev->dev,\n\t\t\t \"This is a 386/486 PCI system, setting cache alignment to 8 longwords\\n\");\n\t} else {\n\t\ti |= 0xE000;\n\t}\n#elif defined(__powerpc__) || defined(__i386__) || defined(__alpha__) || defined(__ia64__) || defined(__x86_64__)\n\ti |= 0xE000;\n#elif defined(CONFIG_SPARC) || defined (CONFIG_PARISC) || defined(CONFIG_ARM)\n\ti |= 0x4800;\n#else\n\tdev_warn(&dev->dev, \"unknown CPU architecture, using default csr0 setting\\n\");\n\ti |= 0x4800;\n#endif\n\tiowrite32(i, ioaddr + PCIBusCfg);\n\n\tnp->csr6 = 0;\n\t \n\tupdate_csr6(dev, 0x00022002 | update_link(dev) | __set_rx_mode(dev));\n\n\t \n\tiowrite32(0x1A0F5, ioaddr + IntrStatus);\n\tiowrite32(0x1A0F5, ioaddr + IntrEnable);\n\n\tiowrite32(0, ioaddr + RxStartDemand);\n}\n\nstatic void tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\tconst int irq = np->pci_dev->irq;\n\n\tdev_warn(&dev->dev, \"Transmit timed out, status %08x, resetting...\\n\",\n\t\t ioread32(ioaddr + IntrStatus));\n\n\t{\n\t\tint i;\n\t\tprintk(KERN_DEBUG \"  Rx ring %p: \", np->rx_ring);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tprintk(KERN_CONT \" %08x\", (unsigned int)np->rx_ring[i].status);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tprintk(KERN_DEBUG \"  Tx ring %p: \", np->tx_ring);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tprintk(KERN_CONT \" %08x\", np->tx_ring[i].status);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_DEBUG \"Tx cur %d Tx dirty %d Tx Full %d, q bytes %d\\n\",\n\t       np->cur_tx, np->dirty_tx, np->tx_full, np->tx_q_bytes);\n\tprintk(KERN_DEBUG \"Tx Descriptor addr %xh\\n\", ioread32(ioaddr+0x4C));\n\n\tdisable_irq(irq);\n\tspin_lock_irq(&np->lock);\n\t \n\n\tiowrite32(1, np->base_addr+PCIBusCfg);\n\tudelay(1);\n\n\tfree_rxtx_rings(np);\n\tinit_rxtx_rings(dev);\n\tinit_registers(dev);\n\tspin_unlock_irq(&np->lock);\n\tenable_irq(irq);\n\n\tnetif_wake_queue(dev);\n\tnetif_trans_update(dev);  \n\tnp->stats.tx_errors++;\n}\n\n \nstatic int alloc_ringdesc(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tnp->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\n\n\tnp->rx_ring = dma_alloc_coherent(&np->pci_dev->dev,\n\t\t\t\t\t sizeof(struct w840_rx_desc) * RX_RING_SIZE +\n\t\t\t\t\t sizeof(struct w840_tx_desc) * TX_RING_SIZE,\n\t\t\t\t\t &np->ring_dma_addr, GFP_KERNEL);\n\tif(!np->rx_ring)\n\t\treturn -ENOMEM;\n\tinit_rxtx_rings(dev);\n\treturn 0;\n}\n\nstatic void free_ringdesc(struct netdev_private *np)\n{\n\tdma_free_coherent(&np->pci_dev->dev,\n\t\t\t  sizeof(struct w840_rx_desc) * RX_RING_SIZE +\n\t\t\t  sizeof(struct w840_tx_desc) * TX_RING_SIZE,\n\t\t\t  np->rx_ring, np->ring_dma_addr);\n\n}\n\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tunsigned entry;\n\n\t \n\n\t \n\tentry = np->cur_tx % TX_RING_SIZE;\n\n\tnp->tx_addr[entry] = dma_map_single(&np->pci_dev->dev, skb->data,\n\t\t\t\t\t    skb->len, DMA_TO_DEVICE);\n\tnp->tx_skbuff[entry] = skb;\n\n\tnp->tx_ring[entry].buffer1 = np->tx_addr[entry];\n\tif (skb->len < TX_BUFLIMIT) {\n\t\tnp->tx_ring[entry].length = DescWholePkt | skb->len;\n\t} else {\n\t\tint len = skb->len - TX_BUFLIMIT;\n\n\t\tnp->tx_ring[entry].buffer2 = np->tx_addr[entry]+TX_BUFLIMIT;\n\t\tnp->tx_ring[entry].length = DescWholePkt | (len << 11) | TX_BUFLIMIT;\n\t}\n\tif(entry == TX_RING_SIZE-1)\n\t\tnp->tx_ring[entry].length |= DescEndRing;\n\n\t \n\tspin_lock_irq(&np->lock);\n\tnp->cur_tx++;\n\n\twmb();  \n\tnp->tx_ring[entry].status = DescOwned;\n\twmb();  \n\tiowrite32(0, np->base_addr + TxStartDemand);\n\tnp->tx_q_bytes += skb->len;\n\t \n\tif (np->cur_tx - np->dirty_tx > TX_QUEUE_LEN ||\n\t\t((np->drv_flags & HasBrokenTx) && np->tx_q_bytes > TX_BUG_FIFO_LIMIT)) {\n\t\tnetif_stop_queue(dev);\n\t\twmb();\n\t\tnp->tx_full = 1;\n\t}\n\tspin_unlock_irq(&np->lock);\n\n\tif (debug > 4) {\n\t\tnetdev_dbg(dev, \"Transmit frame #%d queued in slot %d\\n\",\n\t\t\t   np->cur_tx, entry);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic void netdev_tx_done(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tfor (; np->cur_tx - np->dirty_tx > 0; np->dirty_tx++) {\n\t\tint entry = np->dirty_tx % TX_RING_SIZE;\n\t\tint tx_status = np->tx_ring[entry].status;\n\n\t\tif (tx_status < 0)\n\t\t\tbreak;\n\t\tif (tx_status & 0x8000) { \t \n#ifndef final_version\n\t\t\tif (debug > 1)\n\t\t\t\tnetdev_dbg(dev, \"Transmit error, Tx status %08x\\n\",\n\t\t\t\t\t   tx_status);\n#endif\n\t\t\tnp->stats.tx_errors++;\n\t\t\tif (tx_status & 0x0104) np->stats.tx_aborted_errors++;\n\t\t\tif (tx_status & 0x0C80) np->stats.tx_carrier_errors++;\n\t\t\tif (tx_status & 0x0200) np->stats.tx_window_errors++;\n\t\t\tif (tx_status & 0x0002) np->stats.tx_fifo_errors++;\n\t\t\tif ((tx_status & 0x0080) && np->mii_if.full_duplex == 0)\n\t\t\t\tnp->stats.tx_heartbeat_errors++;\n\t\t} else {\n#ifndef final_version\n\t\t\tif (debug > 3)\n\t\t\t\tnetdev_dbg(dev, \"Transmit slot %d ok, Tx status %08x\\n\",\n\t\t\t\t\t   entry, tx_status);\n#endif\n\t\t\tnp->stats.tx_bytes += np->tx_skbuff[entry]->len;\n\t\t\tnp->stats.collisions += (tx_status >> 3) & 15;\n\t\t\tnp->stats.tx_packets++;\n\t\t}\n\t\t \n\t\tdma_unmap_single(&np->pci_dev->dev, np->tx_addr[entry],\n\t\t\t\t np->tx_skbuff[entry]->len, DMA_TO_DEVICE);\n\t\tnp->tx_q_bytes -= np->tx_skbuff[entry]->len;\n\t\tdev_kfree_skb_irq(np->tx_skbuff[entry]);\n\t\tnp->tx_skbuff[entry] = NULL;\n\t}\n\tif (np->tx_full &&\n\t\tnp->cur_tx - np->dirty_tx < TX_QUEUE_LEN_RESTART &&\n\t\tnp->tx_q_bytes < TX_BUG_FIFO_LIMIT) {\n\t\t \n\t\tnp->tx_full = 0;\n\t\twmb();\n\t\tnetif_wake_queue(dev);\n\t}\n}\n\n \nstatic irqreturn_t intr_handler(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = (struct net_device *)dev_instance;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\tint work_limit = max_interrupt_work;\n\tint handled = 0;\n\n\tif (!netif_device_present(dev))\n\t\treturn IRQ_NONE;\n\tdo {\n\t\tu32 intr_status = ioread32(ioaddr + IntrStatus);\n\n\t\t \n\t\tiowrite32(intr_status & 0x001ffff, ioaddr + IntrStatus);\n\n\t\tif (debug > 4)\n\t\t\tnetdev_dbg(dev, \"Interrupt, status %04x\\n\", intr_status);\n\n\t\tif ((intr_status & (NormalIntr|AbnormalIntr)) == 0)\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\t\tif (intr_status & (RxIntr | RxNoBuf))\n\t\t\tnetdev_rx(dev);\n\t\tif (intr_status & RxNoBuf)\n\t\t\tiowrite32(0, ioaddr + RxStartDemand);\n\n\t\tif (intr_status & (TxNoBuf | TxIntr) &&\n\t\t\tnp->cur_tx != np->dirty_tx) {\n\t\t\tspin_lock(&np->lock);\n\t\t\tnetdev_tx_done(dev);\n\t\t\tspin_unlock(&np->lock);\n\t\t}\n\n\t\t \n\t\tif (intr_status & (AbnormalIntr | TxFIFOUnderflow | SystemError |\n\t\t\t\t\t\t   TimerInt | TxDied))\n\t\t\tnetdev_error(dev, intr_status);\n\n\t\tif (--work_limit < 0) {\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"Too much work at interrupt, status=0x%04x\\n\",\n\t\t\t\t intr_status);\n\t\t\t \n\t\t\tspin_lock(&np->lock);\n\t\t\tif (netif_device_present(dev)) {\n\t\t\t\tiowrite32(AbnormalIntr | TimerInt, ioaddr + IntrEnable);\n\t\t\t\tiowrite32(10, ioaddr + GPTimer);\n\t\t\t}\n\t\t\tspin_unlock(&np->lock);\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tif (debug > 3)\n\t\tnetdev_dbg(dev, \"exiting interrupt, status=%#4.4x\\n\",\n\t\t\t   ioread32(ioaddr + IntrStatus));\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic int netdev_rx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->cur_rx % RX_RING_SIZE;\n\tint work_limit = np->dirty_rx + RX_RING_SIZE - np->cur_rx;\n\n\tif (debug > 4) {\n\t\tnetdev_dbg(dev, \" In netdev_rx(), entry %d status %04x\\n\",\n\t\t\t   entry, np->rx_ring[entry].status);\n\t}\n\n\t \n\twhile (--work_limit >= 0) {\n\t\tstruct w840_rx_desc *desc = np->rx_head_desc;\n\t\ts32 status = desc->status;\n\n\t\tif (debug > 4)\n\t\t\tnetdev_dbg(dev, \"  netdev_rx() status was %08x\\n\",\n\t\t\t\t   status);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif ((status & 0x38008300) != 0x0300) {\n\t\t\tif ((status & 0x38000300) != 0x0300) {\n\t\t\t\t \n\t\t\t\tif ((status & 0xffff) != 0x7fff) {\n\t\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t\t \"Oversized Ethernet frame spanned multiple buffers, entry %#x status %04x!\\n\",\n\t\t\t\t\t\t np->cur_rx, status);\n\t\t\t\t\tnp->stats.rx_length_errors++;\n\t\t\t\t}\n\t\t\t} else if (status & 0x8000) {\n\t\t\t\t \n\t\t\t\tif (debug > 2)\n\t\t\t\t\tnetdev_dbg(dev, \"Receive error, Rx status %08x\\n\",\n\t\t\t\t\t\t   status);\n\t\t\t\tnp->stats.rx_errors++;  \n\t\t\t\tif (status & 0x0890) np->stats.rx_length_errors++;\n\t\t\t\tif (status & 0x004C) np->stats.rx_frame_errors++;\n\t\t\t\tif (status & 0x0002) np->stats.rx_crc_errors++;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\t\t\t \n\t\t\tint pkt_len = ((status >> 16) & 0x7ff) - 4;\n\n#ifndef final_version\n\t\t\tif (debug > 4)\n\t\t\t\tnetdev_dbg(dev, \"  netdev_rx() normal Rx pkt length %d status %x\\n\",\n\t\t\t\t\t   pkt_len, status);\n#endif\n\t\t\t \n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tdma_sync_single_for_cpu(&np->pci_dev->dev,\n\t\t\t\t\t\t\tnp->rx_addr[entry],\n\t\t\t\t\t\t\tnp->rx_skbuff[entry]->len,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tskb_copy_to_linear_data(skb, np->rx_skbuff[entry]->data, pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\tdma_sync_single_for_device(&np->pci_dev->dev,\n\t\t\t\t\t\t\t   np->rx_addr[entry],\n\t\t\t\t\t\t\t   np->rx_skbuff[entry]->len,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t\t np->rx_addr[entry],\n\t\t\t\t\t\t np->rx_skbuff[entry]->len,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put(skb = np->rx_skbuff[entry], pkt_len);\n\t\t\t\tnp->rx_skbuff[entry] = NULL;\n\t\t\t}\n#ifndef final_version\t\t\t\t \n\t\t\t \n\t\t\tif (debug > 5)\n\t\t\t\tnetdev_dbg(dev, \"  Rx data %pM %pM %02x%02x %pI4\\n\",\n\t\t\t\t\t   &skb->data[0], &skb->data[6],\n\t\t\t\t\t   skb->data[12], skb->data[13],\n\t\t\t\t\t   &skb->data[14]);\n#endif\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tnp->stats.rx_packets++;\n\t\t\tnp->stats.rx_bytes += pkt_len;\n\t\t}\n\t\tentry = (++np->cur_rx) % RX_RING_SIZE;\n\t\tnp->rx_head_desc = &np->rx_ring[entry];\n\t}\n\n\t \n\tfor (; np->cur_rx - np->dirty_rx > 0; np->dirty_rx++) {\n\t\tstruct sk_buff *skb;\n\t\tentry = np->dirty_rx % RX_RING_SIZE;\n\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\tskb = netdev_alloc_skb(dev, np->rx_buf_sz);\n\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t\t\t \n\t\t\tnp->rx_addr[entry] = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\t    skb->data,\n\t\t\t\t\t\t\t    np->rx_buf_sz,\n\t\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\t\tnp->rx_ring[entry].buffer1 = np->rx_addr[entry];\n\t\t}\n\t\twmb();\n\t\tnp->rx_ring[entry].status = DescOwned;\n\t}\n\n\treturn 0;\n}\n\nstatic void netdev_error(struct net_device *dev, int intr_status)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\n\tif (debug > 2)\n\t\tnetdev_dbg(dev, \"Abnormal event, %08x\\n\", intr_status);\n\tif (intr_status == 0xffffffff)\n\t\treturn;\n\tspin_lock(&np->lock);\n\tif (intr_status & TxFIFOUnderflow) {\n\t\tint new;\n\t\t \n#if 0\n\t\t \n\t\tnew = np->csr6 + 0x4000;\n#else\n\t\tnew = (np->csr6 >> 14)&0x7f;\n\t\tif (new < 64)\n\t\t\tnew *= 2;\n\t\t else\n\t\t \tnew = 127;  \n\t\tnew = (np->csr6 & ~(0x7F << 14)) | (new<<14);\n#endif\n\t\tnetdev_dbg(dev, \"Tx underflow, new csr6 %08x\\n\", new);\n\t\tupdate_csr6(dev, new);\n\t}\n\tif (intr_status & RxDied) {\t\t \n\t\tnp->stats.rx_errors++;\n\t}\n\tif (intr_status & TimerInt) {\n\t\t \n\t\tif (netif_device_present(dev))\n\t\t\tiowrite32(0x1A0F5, ioaddr + IntrEnable);\n\t}\n\tnp->stats.rx_missed_errors += ioread32(ioaddr + RxMissed) & 0xffff;\n\tiowrite32(0, ioaddr + RxStartDemand);\n\tspin_unlock(&np->lock);\n}\n\nstatic struct net_device_stats *get_stats(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\n\t \n\tspin_lock_irq(&np->lock);\n\tif (netif_running(dev) && netif_device_present(dev))\n\t\tnp->stats.rx_missed_errors += ioread32(ioaddr + RxMissed) & 0xffff;\n\tspin_unlock_irq(&np->lock);\n\n\treturn &np->stats;\n}\n\n\nstatic u32 __set_rx_mode(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\tu32 mc_filter[2];\t\t\t \n\tu32 rx_mode;\n\n\tif (dev->flags & IFF_PROMISC) {\t\t\t \n\t\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\t\trx_mode = RxAcceptBroadcast | AcceptMulticast | RxAcceptAllPhys\n\t\t\t| AcceptMyPhys;\n\t} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\t\trx_mode = RxAcceptBroadcast | AcceptMulticast | AcceptMyPhys;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint filbit;\n\n\t\t\tfilbit = (ether_crc(ETH_ALEN, ha->addr) >> 26) ^ 0x3F;\n\t\t\tfilbit &= 0x3f;\n\t\t\tmc_filter[filbit >> 5] |= 1 << (filbit & 31);\n\t\t}\n\t\trx_mode = RxAcceptBroadcast | AcceptMulticast | AcceptMyPhys;\n\t}\n\tiowrite32(mc_filter[0], ioaddr + MulticastFilter0);\n\tiowrite32(mc_filter[1], ioaddr + MulticastFilter1);\n\treturn rx_mode;\n}\n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu32 rx_mode = __set_rx_mode(dev);\n\tspin_lock_irq(&np->lock);\n\tupdate_csr6(dev, (np->csr6 & ~0x00F8) | rx_mode);\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic void netdev_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int netdev_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tspin_lock_irq(&np->lock);\n\tmii_ethtool_get_link_ksettings(&np->mii_if, cmd);\n\tspin_unlock_irq(&np->lock);\n\n\treturn 0;\n}\n\nstatic int netdev_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint rc;\n\n\tspin_lock_irq(&np->lock);\n\trc = mii_ethtool_set_link_ksettings(&np->mii_if, cmd);\n\tspin_unlock_irq(&np->lock);\n\n\treturn rc;\n}\n\nstatic int netdev_nway_reset(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn mii_nway_restart(&np->mii_if);\n}\n\nstatic u32 netdev_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn mii_link_ok(&np->mii_if);\n}\n\nstatic u32 netdev_get_msglevel(struct net_device *dev)\n{\n\treturn debug;\n}\n\nstatic void netdev_set_msglevel(struct net_device *dev, u32 value)\n{\n\tdebug = value;\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.nway_reset\t\t= netdev_nway_reset,\n\t.get_link\t\t= netdev_get_link,\n\t.get_msglevel\t\t= netdev_get_msglevel,\n\t.set_msglevel\t\t= netdev_set_msglevel,\n\t.get_link_ksettings\t= netdev_get_link_ksettings,\n\t.set_link_ksettings\t= netdev_set_link_ksettings,\n};\n\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tswitch(cmd) {\n\tcase SIOCGMIIPHY:\t\t \n\t\tdata->phy_id = ((struct netdev_private *)netdev_priv(dev))->phys[0] & 0x1f;\n\t\tfallthrough;\n\n\tcase SIOCGMIIREG:\t\t \n\t\tspin_lock_irq(&np->lock);\n\t\tdata->val_out = mdio_read(dev, data->phy_id & 0x1f, data->reg_num & 0x1f);\n\t\tspin_unlock_irq(&np->lock);\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\t\t \n\t\tspin_lock_irq(&np->lock);\n\t\tmdio_write(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);\n\t\tspin_unlock_irq(&np->lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int netdev_close(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\n\tnetif_stop_queue(dev);\n\n\tif (debug > 1) {\n\t\tnetdev_dbg(dev, \"Shutting down ethercard, status was %08x Config %08x\\n\",\n\t\t\t   ioread32(ioaddr + IntrStatus),\n\t\t\t   ioread32(ioaddr + NetworkConfig));\n\t\tnetdev_dbg(dev, \"Queue pointers were Tx %d / %d,  Rx %d / %d\\n\",\n\t\t\t   np->cur_tx, np->dirty_tx,\n\t\t\t   np->cur_rx, np->dirty_rx);\n\t}\n\n\t \n\tspin_lock_irq(&np->lock);\n\tnetif_device_detach(dev);\n\tupdate_csr6(dev, 0);\n\tiowrite32(0x0000, ioaddr + IntrEnable);\n\tspin_unlock_irq(&np->lock);\n\n\tfree_irq(np->pci_dev->irq, dev);\n\twmb();\n\tnetif_device_attach(dev);\n\n\tif (ioread32(ioaddr + NetworkConfig) != 0xffffffff)\n\t\tnp->stats.rx_missed_errors += ioread32(ioaddr + RxMissed) & 0xffff;\n\n#ifdef __i386__\n\tif (debug > 2) {\n\t\tint i;\n\n\t\tprintk(KERN_DEBUG\"  Tx ring at %p:\\n\", np->tx_ring);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tprintk(KERN_DEBUG \" #%d desc. %04x %04x %08x\\n\",\n\t\t\t       i, np->tx_ring[i].length,\n\t\t\t       np->tx_ring[i].status, np->tx_ring[i].buffer1);\n\t\tprintk(KERN_DEBUG \"  Rx ring %p:\\n\", np->rx_ring);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tprintk(KERN_DEBUG \" #%d desc. %04x %04x %08x\\n\",\n\t\t\t       i, np->rx_ring[i].length,\n\t\t\t       np->rx_ring[i].status, np->rx_ring[i].buffer1);\n\t\t}\n\t}\n#endif  \n\n\tdel_timer_sync(&np->timer);\n\n\tfree_rxtx_rings(np);\n\tfree_ringdesc(np);\n\n\treturn 0;\n}\n\nstatic void w840_remove1(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct netdev_private *np = netdev_priv(dev);\n\t\tunregister_netdev(dev);\n\t\tpci_iounmap(pdev, np->base_addr);\n\t\tfree_netdev(dev);\n\t}\n}\n\n \nstatic int __maybe_unused w840_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base_addr;\n\n\trtnl_lock();\n\tif (netif_running (dev)) {\n\t\tdel_timer_sync(&np->timer);\n\n\t\tspin_lock_irq(&np->lock);\n\t\tnetif_device_detach(dev);\n\t\tupdate_csr6(dev, 0);\n\t\tiowrite32(0, ioaddr + IntrEnable);\n\t\tspin_unlock_irq(&np->lock);\n\n\t\tsynchronize_irq(np->pci_dev->irq);\n\t\tnetif_tx_disable(dev);\n\n\t\tnp->stats.rx_missed_errors += ioread32(ioaddr + RxMissed) & 0xffff;\n\n\t\t \n\n\t\tBUG_ON(np->csr6 || ioread32(ioaddr + IntrEnable));\n\n\t\t \n\n\t\tfree_rxtx_rings(np);\n\t} else {\n\t\tnetif_device_detach(dev);\n\t}\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic int __maybe_unused w840_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\trtnl_lock();\n\tif (netif_device_present(dev))\n\t\tgoto out;  \n\tif (netif_running(dev)) {\n\t\tspin_lock_irq(&np->lock);\n\t\tiowrite32(1, np->base_addr+PCIBusCfg);\n\t\tioread32(np->base_addr+PCIBusCfg);\n\t\tudelay(1);\n\t\tnetif_device_attach(dev);\n\t\tinit_rxtx_rings(dev);\n\t\tinit_registers(dev);\n\t\tspin_unlock_irq(&np->lock);\n\n\t\tnetif_wake_queue(dev);\n\n\t\tmod_timer(&np->timer, jiffies + 1*HZ);\n\t} else {\n\t\tnetif_device_attach(dev);\n\t}\nout:\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(w840_pm_ops, w840_suspend, w840_resume);\n\nstatic struct pci_driver w840_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= w840_pci_tbl,\n\t.probe\t\t= w840_probe1,\n\t.remove\t\t= w840_remove1,\n\t.driver.pm\t= &w840_pm_ops,\n};\n\nmodule_pci_driver(w840_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}