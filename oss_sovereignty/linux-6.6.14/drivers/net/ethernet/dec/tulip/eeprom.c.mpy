{
  "module_name": "eeprom.c",
  "hash_id": "05ac1cc17994ffdf22e984af4b241fb87077da598e68a1611e52149181be4f1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/eeprom.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include \"tulip.h\"\n#include <asm/unaligned.h>\n\n\n\n \n \n\n \nstatic struct eeprom_fixup eeprom_fixups[] = {\n  {\"Asante\", 0, 0, 0x94, {0x1e00, 0x0000, 0x0800, 0x0100, 0x018c,\n\t\t\t  0x0000, 0x0000, 0xe078, 0x0001, 0x0050, 0x0018 }},\n  {\"SMC9332DST\", 0, 0, 0xC0, { 0x1e00, 0x0000, 0x0800, 0x041f,\n\t\t\t   0x0000, 0x009E,  \n\t\t\t   0x0004, 0x009E,  \n\t\t\t   0x0903, 0x006D,  \n\t\t\t   0x0905, 0x006D,   }},\n  {\"Cogent EM100\", 0, 0, 0x92, { 0x1e00, 0x0000, 0x0800, 0x063f,\n\t\t\t\t 0x0107, 0x8021,  \n\t\t\t\t 0x0108, 0x8021,  \n\t\t\t\t 0x0100, 0x009E,  \n\t\t\t\t 0x0104, 0x009E,  \n\t\t\t\t 0x0103, 0x006D,  \n\t\t\t\t 0x0105, 0x006D,   }},\n  {\"Maxtech NX-110\", 0, 0, 0xE8, { 0x1e00, 0x0000, 0x0800, 0x0513,\n\t\t\t\t   0x1001, 0x009E,  \n\t\t\t\t   0x0000, 0x009E,  \n\t\t\t\t   0x0004, 0x009E,  \n\t\t\t\t   0x0303, 0x006D,  \n\t\t\t\t   0x0305, 0x006D,  }},\n  {\"Accton EN1207\", 0, 0, 0xE8, { 0x1e00, 0x0000, 0x0800, 0x051F,\n\t\t\t\t  0x1B01, 0x0000,  \n\t\t\t\t  0x0B00, 0x009E,  \n\t\t\t\t  0x0B04, 0x009E,  \n\t\t\t\t  0x1B03, 0x006D,  \n\t\t\t\t  0x1B05, 0x006D,  \n   }},\n  {\"NetWinder\", 0x00, 0x10, 0x57,\n\t \n\t{ 0x1e00, 0x0000, 0x000b, 0x8f01, 0x0103, 0x0300, 0x0821, 0x000, 0x0001, 0x0000, 0x01e1 }\n  },\n  {\"Cobalt Microserver\", 0, 0x10, 0xE0, {0x1e00,  \n\t\t\t\t\t 0x0000,  \n\t\t\t\t\t 0x0800,  \n\t\t\t\t\t 0x8001,  \n\t\t\t\t\t 0x0003,  \n\t\t\t\t\t 0x0400,  \n\t\t\t\t\t 0x0801,  \n\t\t\t\t\t 0x0000,  \n\t\t\t\t\t 0x0800,  \n\t\t\t\t\t 0x0000,  \n\t\t\t\t\t 0x7800,  \n\t\t\t\t\t 0x01e0,  \n\t\t\t\t\t 0x5000,  \n\t\t\t\t\t 0x1800,  \n\t\t\t\t\t 0x0000,  \n  }},\n  {NULL}};\n\n\nstatic const char *const block_name[] = {\n\t\"21140 non-MII\",\n\t\"21140 MII PHY\",\n\t\"21142 Serial PHY\",\n\t\"21142 MII PHY\",\n\t\"21143 SYM PHY\",\n\t\"21143 reset method\"\n};\n\n\n \nstatic void tulip_build_fake_mediatable(struct tulip_private *tp)\n{\n#ifdef CONFIG_GSC\n\tif (tp->flags & NEEDS_FAKE_MEDIA_TABLE) {\n\t\tstatic unsigned char leafdata[] =\n\t\t\t{ 0x01,        \n\t\t\t  0x02,        \n\t\t\t  0x02, 0x00,  \n\t\t\t  0x02,        \n\t\t\t  0x01, 0x00,  \n\t\t\t  0x00, 0x78,  \n\t\t\t  0x00, 0xe0,  \n\t\t\t  0x00, 0x05,  \n\t\t\t  0x00, 0x06   \n\t\t\t};\n\n\t\ttp->mtable = devm_kmalloc(&tp->pdev->dev, sizeof(struct mediatable) +\n\t\t\t\t\t  sizeof(struct medialeaf), GFP_KERNEL);\n\n\t\tif (tp->mtable == NULL)\n\t\t\treturn;  \n\n\t\ttp->mtable->defaultmedia = 0x800;\n\t\ttp->mtable->leafcount = 1;\n\t\ttp->mtable->csr12dir = 0x3f;  \n\t\ttp->mtable->has_nonmii = 0;\n\t\ttp->mtable->has_reset = 0;\n\t\ttp->mtable->has_mii = 1;\n\t\ttp->mtable->csr15dir = tp->mtable->csr15val = 0;\n\t\ttp->mtable->mleaf[0].type = 1;\n\t\ttp->mtable->mleaf[0].media = 11;\n\t\ttp->mtable->mleaf[0].leafdata = &leafdata[0];\n\t\ttp->flags |= HAS_PHY_IRQ;\n\t\ttp->csr12_shadow = -1;\n\t}\n#endif\n}\n\nvoid tulip_parse_eeprom(struct net_device *dev)\n{\n\t \n\n\t \n\tstatic struct mediatable *last_mediatable;\n\tstatic unsigned char *last_ee_data;\n\tstatic int controller_index;\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tunsigned char *ee_data = tp->eeprom;\n\tint i;\n\n\ttp->mtable = NULL;\n\t \n\tfor (i = 0; i < 8; i ++)\n\t\tif (ee_data[i] != ee_data[16+i])\n\t\t\tbreak;\n\tif (i >= 8) {\n\t\tif (ee_data[0] == 0xff) {\n\t\t\tif (last_mediatable) {\n\t\t\t\tcontroller_index++;\n\t\t\t\tpr_info(\"%s: Controller %d of multiport board\\n\",\n\t\t\t\t\tdev->name, controller_index);\n\t\t\t\ttp->mtable = last_mediatable;\n\t\t\t\tee_data = last_ee_data;\n\t\t\t\tgoto subsequent_board;\n\t\t\t} else\n\t\t\t\tpr_info(\"%s: Missing EEPROM, this interface may not work correctly!\\n\",\n\t\t\t\t\tdev->name);\n\t\t\treturn;\n\t\t}\n\t   \n\t  for (i = 0; eeprom_fixups[i].name; i++) {\n\t\t  if (dev->dev_addr[0] == eeprom_fixups[i].addr0 &&\n\t\t      dev->dev_addr[1] == eeprom_fixups[i].addr1 &&\n\t\t      dev->dev_addr[2] == eeprom_fixups[i].addr2) {\n\t\t  if (dev->dev_addr[2] == 0xE8 && ee_data[0x1a] == 0x55)\n\t\t\t  i++;\t\t\t \n\t\t  memcpy(ee_data + 26, eeprom_fixups[i].newtable,\n\t\t\t\t sizeof(eeprom_fixups[i].newtable));\n\t\t  pr_info(\"%s: Old format EEPROM on '%s' board.  Using substitute media control info\\n\",\n\t\t\t  dev->name, eeprom_fixups[i].name);\n\t\t  break;\n\t\t}\n\t  }\n\t  if (eeprom_fixups[i].name == NULL) {  \n\t\t  pr_info(\"%s: Old style EEPROM with no media selection information\\n\",\n\t\t\t  dev->name);\n\t\treturn;\n\t  }\n\t}\n\n\tcontroller_index = 0;\n\tif (ee_data[19] > 1) {\t\t \n\t\tlast_ee_data = ee_data;\n\t}\nsubsequent_board:\n\n\tif (ee_data[27] == 0) {\t\t \n\t\ttulip_build_fake_mediatable(tp);\n\t} else {\n\t\tunsigned char *p = (void *)ee_data + ee_data[27];\n\t\tunsigned char csr12dir = 0;\n\t\tint count, new_advertise = 0;\n\t\tstruct mediatable *mtable;\n\t\tu16 media = get_u16(p);\n\n\t\tp += 2;\n\t\tif (tp->flags & CSR12_IN_SROM)\n\t\t\tcsr12dir = *p++;\n\t\tcount = *p++;\n\n\t         \n\t        if (count == 0) {\n\t\t\tif (tulip_debug > 0)\n\t\t\t\tpr_warn(\"%s: no phy info, aborting mtable build\\n\",\n\t\t\t\t\tdev->name);\n\t\t        return;\n\t\t}\n\n\t\tmtable = devm_kmalloc(&tp->pdev->dev, struct_size(mtable, mleaf, count),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (mtable == NULL)\n\t\t\treturn;\t\t\t\t \n\t\tlast_mediatable = tp->mtable = mtable;\n\t\tmtable->defaultmedia = media;\n\t\tmtable->leafcount = count;\n\t\tmtable->csr12dir = csr12dir;\n\t\tmtable->has_nonmii = mtable->has_mii = mtable->has_reset = 0;\n\t\tmtable->csr15dir = mtable->csr15val = 0;\n\n\t\tpr_info(\"%s: EEPROM default media type %s\\n\",\n\t\t\tdev->name,\n\t\t\tmedia & 0x0800 ? \"Autosense\"\n\t\t\t\t       : medianame[media & MEDIA_MASK]);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstruct medialeaf *leaf = &mtable->mleaf[i];\n\n\t\t\tif ((p[0] & 0x80) == 0) {  \n\t\t\t\tleaf->type = 0;\n\t\t\t\tleaf->media = p[0] & 0x3f;\n\t\t\t\tleaf->leafdata = p;\n\t\t\t\tif ((p[2] & 0x61) == 0x01)\t \n\t\t\t\t\tmtable->has_mii = 1;\n\t\t\t\tp += 4;\n\t\t\t} else {\n\t\t\t\tleaf->type = p[1];\n\t\t\t\tif (p[1] == 0x05) {\n\t\t\t\t\tmtable->has_reset = i;\n\t\t\t\t\tleaf->media = p[2] & 0x0f;\n\t\t\t\t} else if (tp->chip_id == DM910X && p[1] == 0x80) {\n\t\t\t\t\t \n\t\t\t\t\tmtable->leafcount--;\n\t\t\t\t\tcount--;\n\t\t\t\t\ti--;\n\t\t\t\t\tleaf->leafdata = p + 2;\n\t\t\t\t\tp += (p[0] & 0x3f) + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (p[1] & 1) {\n\t\t\t\t\tint gpr_len, reset_len;\n\n\t\t\t\t\tmtable->has_mii = 1;\n\t\t\t\t\tleaf->media = 11;\n\t\t\t\t\tgpr_len=p[3]*2;\n\t\t\t\t\treset_len=p[4+gpr_len]*2;\n\t\t\t\t\tnew_advertise |= get_u16(&p[7+gpr_len+reset_len]);\n\t\t\t\t} else {\n\t\t\t\t\tmtable->has_nonmii = 1;\n\t\t\t\t\tleaf->media = p[2] & MEDIA_MASK;\n\t\t\t\t\t \n\t\t\t\t\tif (tp->chip_id == DM910X && leaf->media == 1)\n\t\t\t\t\t\tleaf->media = 3;\n\t\t\t\t\tswitch (leaf->media) {\n\t\t\t\t\tcase 0: new_advertise |= 0x0020; break;\n\t\t\t\t\tcase 4: new_advertise |= 0x0040; break;\n\t\t\t\t\tcase 3: new_advertise |= 0x0080; break;\n\t\t\t\t\tcase 5: new_advertise |= 0x0100; break;\n\t\t\t\t\tcase 6: new_advertise |= 0x0200; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (p[1] == 2  &&  leaf->media == 0) {\n\t\t\t\t\t\tif (p[2] & 0x40) {\n\t\t\t\t\t\t\tu32 base15 = get_unaligned((u16*)&p[7]);\n\t\t\t\t\t\t\tmtable->csr15dir =\n\t\t\t\t\t\t\t\t(get_unaligned((u16*)&p[9])<<16) + base15;\n\t\t\t\t\t\t\tmtable->csr15val =\n\t\t\t\t\t\t\t\t(get_unaligned((u16*)&p[11])<<16) + base15;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmtable->csr15dir = get_unaligned((u16*)&p[3])<<16;\n\t\t\t\t\t\t\tmtable->csr15val = get_unaligned((u16*)&p[5])<<16;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tleaf->leafdata = p + 2;\n\t\t\t\tp += (p[0] & 0x3f) + 1;\n\t\t\t}\n\t\t\tif (tulip_debug > 1  &&  leaf->media == 11) {\n\t\t\t\tunsigned char *bp = leaf->leafdata;\n\t\t\t\tpr_info(\"%s: MII interface PHY %d, setup/reset sequences %d/%d long, capabilities %02x %02x\\n\",\n\t\t\t\t\tdev->name,\n\t\t\t\t\tbp[0], bp[1], bp[2 + bp[1]*2],\n\t\t\t\t\tbp[5 + bp[2 + bp[1]*2]*2],\n\t\t\t\t\tbp[4 + bp[2 + bp[1]*2]*2]);\n\t\t\t}\n\t\t\tpr_info(\"%s: Index #%d - Media %s (#%d) described by a %s (%d) block\\n\",\n\t\t\t\tdev->name,\n\t\t\t\ti, medianame[leaf->media & 15], leaf->media,\n\t\t\t\tleaf->type < ARRAY_SIZE(block_name) ? block_name[leaf->type] : \"<unknown>\",\n\t\t\t\tleaf->type);\n\t\t}\n\t\tif (new_advertise)\n\t\t\ttp->sym_advertise = new_advertise;\n\t}\n}\n \n\n \n#define EE_SHIFT_CLK\t0x02\t \n#define EE_CS\t\t0x01\t \n#define EE_DATA_WRITE\t0x04\t \n#define EE_WRITE_0\t0x01\n#define EE_WRITE_1\t0x05\n#define EE_DATA_READ\t0x08\t \n#define EE_ENB\t\t(0x4800 | EE_CS)\n\n \n#define eeprom_delay()\tioread32(ee_addr)\n\n \n#define EE_READ_CMD\t\t(6)\n\n \nint tulip_read_eeprom(struct net_device *dev, int location, int addr_len)\n{\n\tint i;\n\tunsigned retval = 0;\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ee_addr = tp->base_addr + CSR9;\n\tint read_cmd = location | (EE_READ_CMD << addr_len);\n\n\t \n\tif (location > (1 << addr_len) - 1)\n\t\treturn 0;\n\n\tiowrite32(EE_ENB & ~EE_CS, ee_addr);\n\tiowrite32(EE_ENB, ee_addr);\n\n\t \n\tfor (i = 4 + addr_len; i >= 0; i--) {\n\t\tshort dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;\n\t\tiowrite32(EE_ENB | dataval, ee_addr);\n\t\teeprom_delay();\n\t\tiowrite32(EE_ENB | dataval | EE_SHIFT_CLK, ee_addr);\n\t\teeprom_delay();\n\t\tretval = (retval << 1) | ((ioread32(ee_addr) & EE_DATA_READ) ? 1 : 0);\n\t}\n\tiowrite32(EE_ENB, ee_addr);\n\teeprom_delay();\n\n\tfor (i = 16; i > 0; i--) {\n\t\tiowrite32(EE_ENB | EE_SHIFT_CLK, ee_addr);\n\t\teeprom_delay();\n\t\tretval = (retval << 1) | ((ioread32(ee_addr) & EE_DATA_READ) ? 1 : 0);\n\t\tiowrite32(EE_ENB, ee_addr);\n\t\teeprom_delay();\n\t}\n\n\t \n\tiowrite32(EE_ENB & ~EE_CS, ee_addr);\n\treturn (tp->flags & HAS_SWAPPED_SEEPROM) ? swab16(retval) : retval;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}