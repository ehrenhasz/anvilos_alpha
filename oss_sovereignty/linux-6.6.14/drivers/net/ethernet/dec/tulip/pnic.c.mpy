{
  "module_name": "pnic.c",
  "hash_id": "02e037bd9658ca893db3e3a9163a0b6d7a349da4fd41b3c66b14a06ae42144e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/pnic.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include \"tulip.h\"\n\n\nvoid pnic_do_nway(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tu32 phy_reg = ioread32(ioaddr + 0xB8);\n\tu32 new_csr6;\n\n\tif (phy_reg & 0x78000000) {  \n\t\tif (phy_reg & 0x20000000)\t\tdev->if_port = 5;\n\t\telse if (phy_reg & 0x40000000)\tdev->if_port = 3;\n\t\telse if (phy_reg & 0x10000000)\tdev->if_port = 4;\n\t\telse if (phy_reg & 0x08000000)\tdev->if_port = 0;\n\t\ttp->nwayset = 1;\n\t\tnew_csr6 = (dev->if_port & 1) ? 0x01860000 : 0x00420000;\n\t\tiowrite32(0x32 | (dev->if_port & 1), ioaddr + CSR12);\n\t\tif (dev->if_port & 1)\n\t\t\tiowrite32(0x1F868, ioaddr + 0xB8);\n\t\tif (phy_reg & 0x30000000) {\n\t\t\ttp->full_duplex = 1;\n\t\t\tnew_csr6 |= 0x00000200;\n\t\t}\n\t\tif (tulip_debug > 1)\n\t\t\tnetdev_dbg(dev, \"PNIC autonegotiated status %08x, %s\\n\",\n\t\t\t\t   phy_reg, medianame[dev->if_port]);\n\t\tif (tp->csr6 != new_csr6) {\n\t\t\ttp->csr6 = new_csr6;\n\t\t\t \n\t\t\ttulip_restart_rxtx(tp);\n\t\t\tnetif_trans_update(dev);\n\t\t}\n\t}\n}\n\nvoid pnic_lnk_change(struct net_device *dev, int csr5)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tint phy_reg = ioread32(ioaddr + 0xB8);\n\n\tif (tulip_debug > 1)\n\t\tnetdev_dbg(dev, \"PNIC link changed state %08x, CSR5 %08x\\n\",\n\t\t\t   phy_reg, csr5);\n\tif (ioread32(ioaddr + CSR5) & TPLnkFail) {\n\t\tiowrite32((ioread32(ioaddr + CSR7) & ~TPLnkFail) | TPLnkPass, ioaddr + CSR7);\n\t\t \n\t\tif (tulip_media_cap[dev->if_port] & MediaIsMII)\n\t\t\treturn;\n\t\tif (! tp->nwayset || time_after(jiffies, dev_trans_start(dev) + 1*HZ)) {\n\t\t\ttp->csr6 = 0x00420000 | (tp->csr6 & 0x0000fdff);\n\t\t\tiowrite32(tp->csr6, ioaddr + CSR6);\n\t\t\tiowrite32(0x30, ioaddr + CSR12);\n\t\t\tiowrite32(0x0201F078, ioaddr + 0xB8);  \n\t\t\tnetif_trans_update(dev);\n\t\t}\n\t} else if (ioread32(ioaddr + CSR5) & TPLnkPass) {\n\t\tif (tulip_media_cap[dev->if_port] & MediaIsMII) {\n\t\t\tspin_lock(&tp->lock);\n\t\t\ttulip_check_duplex(dev);\n\t\t\tspin_unlock(&tp->lock);\n\t\t} else {\n\t\t\tpnic_do_nway(dev);\n\t\t}\n\t\tiowrite32((ioread32(ioaddr + CSR7) & ~TPLnkPass) | TPLnkFail, ioaddr + CSR7);\n\t}\n}\n\nvoid pnic_timer(struct timer_list *t)\n{\n\tstruct tulip_private *tp = from_timer(tp, t, timer);\n\tstruct net_device *dev = tp->dev;\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tint next_tick = 60*HZ;\n\n\tif(!ioread32(ioaddr + CSR7)) {\n\t\t \n\t\tgoto too_good_connection;\n\t}\n\n\tif (tulip_media_cap[dev->if_port] & MediaIsMII) {\n\t\tspin_lock_irq(&tp->lock);\n\t\tif (tulip_check_duplex(dev) > 0)\n\t\t\tnext_tick = 3*HZ;\n\t\tspin_unlock_irq(&tp->lock);\n\t} else {\n\t\tint csr12 = ioread32(ioaddr + CSR12);\n\t\tint new_csr6 = tp->csr6 & ~0x40C40200;\n\t\tint phy_reg = ioread32(ioaddr + 0xB8);\n\t\tint csr5 = ioread32(ioaddr + CSR5);\n\n\t\tif (tulip_debug > 1)\n\t\t\tnetdev_dbg(dev, \"PNIC timer PHY status %08x, %s CSR5 %08x\\n\",\n\t\t\t\t   phy_reg, medianame[dev->if_port], csr5);\n\t\tif (phy_reg & 0x04000000) {\t \n\t\t\tiowrite32(0x0201F078, ioaddr + 0xB8);\n\t\t\tnext_tick = 1*HZ;\n\t\t\ttp->nwayset = 0;\n\t\t} else if (phy_reg & 0x78000000) {  \n\t\t\tpnic_do_nway(dev);\n\t\t\tnext_tick = 60*HZ;\n\t\t} else if (csr5 & TPLnkFail) {  \n\t\t\tif (tulip_debug > 1)\n\t\t\t\tnetdev_dbg(dev, \"%s link beat failed, CSR12 %04x, CSR5 %08x, PHY %03x\\n\",\n\t\t\t\t\t   medianame[dev->if_port],\n\t\t\t\t\t   csr12,\n\t\t\t\t\t   ioread32(ioaddr + CSR5),\n\t\t\t\t\t   ioread32(ioaddr + 0xB8));\n\t\t\tnext_tick = 3*HZ;\n\t\t\tif (tp->medialock) {\n\t\t\t} else if (tp->nwayset  &&  (dev->if_port & 1)) {\n\t\t\t\tnext_tick = 1*HZ;\n\t\t\t} else if (dev->if_port == 0) {\n\t\t\t\tdev->if_port = 3;\n\t\t\t\tiowrite32(0x33, ioaddr + CSR12);\n\t\t\t\tnew_csr6 = 0x01860000;\n\t\t\t\tiowrite32(0x1F868, ioaddr + 0xB8);\n\t\t\t} else {\n\t\t\t\tdev->if_port = 0;\n\t\t\t\tiowrite32(0x32, ioaddr + CSR12);\n\t\t\t\tnew_csr6 = 0x00420000;\n\t\t\t\tiowrite32(0x1F078, ioaddr + 0xB8);\n\t\t\t}\n\t\t\tif (tp->csr6 != new_csr6) {\n\t\t\t\ttp->csr6 = new_csr6;\n\t\t\t\t \n\t\t\t\ttulip_restart_rxtx(tp);\n\t\t\t\tnetif_trans_update(dev);\n\t\t\t\tif (tulip_debug > 1)\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"Changing PNIC configuration to %s %s-duplex, CSR6 %08x\\n\",\n\t\t\t\t\t\t medianame[dev->if_port],\n\t\t\t\t\t\t tp->full_duplex ? \"full\" : \"half\",\n\t\t\t\t\t\t new_csr6);\n\t\t\t}\n\t\t}\n\t}\ntoo_good_connection:\n\tmod_timer(&tp->timer, RUN_AT(next_tick));\n\tif(!ioread32(ioaddr + CSR7)) {\n\t\tif (tulip_debug > 1)\n\t\t\tdev_info(&dev->dev, \"sw timer wakeup\\n\");\n\t\tdisable_irq(dev->irq);\n\t\ttulip_refill_rx(dev);\n\t\tenable_irq(dev->irq);\n\t\tiowrite32(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR7);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}