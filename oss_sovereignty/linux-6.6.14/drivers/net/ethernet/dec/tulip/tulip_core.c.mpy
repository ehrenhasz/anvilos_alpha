{
  "module_name": "tulip_core.c",
  "hash_id": "f760c372e1d1babac369473c8853f0c6a21a349f3ba12a2f606dfb7b7d6f3509",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/tulip_core.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"tulip: \" fmt\n\n#define DRV_NAME\t\"tulip\"\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include \"tulip.h\"\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n\n#ifdef CONFIG_SPARC\n#include <asm/prom.h>\n#endif\n\n \n\n \nstatic unsigned int max_interrupt_work = 25;\n\n#define MAX_UNITS 8\n \nstatic int full_duplex[MAX_UNITS];\nstatic int options[MAX_UNITS];\nstatic int mtu[MAX_UNITS];\t\t\t \n\n \nconst char * const medianame[32] = {\n\t\"10baseT\", \"10base2\", \"AUI\", \"100baseTx\",\n\t\"10baseT-FDX\", \"100baseTx-FDX\", \"100baseT4\", \"100baseFx\",\n\t\"100baseFx-FDX\", \"MII 10baseT\", \"MII 10baseT-FDX\", \"MII\",\n\t\"10baseT(forced)\", \"MII 100baseTx\", \"MII 100baseTx-FDX\", \"MII 100baseT4\",\n\t\"MII 100baseFx-HDX\", \"MII 100baseFx-FDX\", \"Home-PNA 1Mbps\", \"Invalid-19\",\n\t\"\",\"\",\"\",\"\", \"\",\"\",\"\",\"\",  \"\",\"\",\"\",\"Transceiver reset\",\n};\n\n \n#if defined(__alpha__) || defined(__arm__) || defined(__hppa__) || \\\n\tdefined(CONFIG_SPARC) || defined(__ia64__) || \\\n\tdefined(__sh__) || defined(__mips__)\nstatic int rx_copybreak = 1518;\n#else\nstatic int rx_copybreak = 100;\n#endif\n\n \n\n#if defined(__alpha__) || defined(__ia64__)\nstatic int csr0 = 0x01A00000 | 0xE000;\n#elif defined(__i386__) || defined(__powerpc__) || defined(__x86_64__)\nstatic int csr0 = 0x01A00000 | 0x8000;\n#elif defined(CONFIG_SPARC) || defined(__hppa__)\n \nstatic int csr0 = 0x01A00000 | 0x9000;\n#elif defined(__arm__) || defined(__sh__)\nstatic int csr0 = 0x01A00000 | 0x4800;\n#elif defined(__mips__)\nstatic int csr0 = 0x00200000 | 0x4000;\n#else\nstatic int csr0;\n#endif\n\n \n \n#define TX_TIMEOUT  (4*HZ)\n\n\nMODULE_AUTHOR(\"The Linux Kernel Team\");\nMODULE_DESCRIPTION(\"Digital 21*4* Tulip ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(tulip_debug, int, 0);\nmodule_param(max_interrupt_work, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param(csr0, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\n\n#ifdef TULIP_DEBUG\nint tulip_debug = TULIP_DEBUG;\n#else\nint tulip_debug = 1;\n#endif\n\nstatic void tulip_timer(struct timer_list *t)\n{\n\tstruct tulip_private *tp = from_timer(tp, t, timer);\n\tstruct net_device *dev = tp->dev;\n\n\tif (netif_running(dev))\n\t\tschedule_work(&tp->media_work);\n}\n\n \n\nconst struct tulip_chip_table tulip_tbl[] = {\n  { },  \n  { },  \n\n   \n  { \"Digital DS21140 Tulip\", 128, 0x0001ebef,\n\tHAS_MII | HAS_MEDIA_TABLE | CSR12_IN_SROM | HAS_PCI_MWI, tulip_timer,\n\ttulip_media_task },\n\n   \n  { \"Digital DS21142/43 Tulip\", 128, 0x0801fbff,\n\tHAS_MII | HAS_MEDIA_TABLE | ALWAYS_CHECK_MII | HAS_ACPI | HAS_NWAY\n\t| HAS_INTR_MITIGATION | HAS_PCI_MWI, tulip_timer, t21142_media_task },\n\n   \n  { \"Lite-On 82c168 PNIC\", 256, 0x0001fbef,\n\tHAS_MII | HAS_PNICNWAY, pnic_timer, },\n\n   \n  { \"Macronix 98713 PMAC\", 128, 0x0001ebef,\n\tHAS_MII | HAS_MEDIA_TABLE | CSR12_IN_SROM, mxic_timer, },\n\n   \n  { \"Macronix 98715 PMAC\", 256, 0x0001ebef,\n\tHAS_MEDIA_TABLE, mxic_timer, },\n\n   \n  { \"Macronix 98725 PMAC\", 256, 0x0001ebef,\n\tHAS_MEDIA_TABLE, mxic_timer, },\n\n   \n  { \"ASIX AX88140\", 128, 0x0001fbff,\n\tHAS_MII | HAS_MEDIA_TABLE | CSR12_IN_SROM | MC_HASH_ONLY\n\t| IS_ASIX, tulip_timer, tulip_media_task },\n\n   \n  { \"Lite-On PNIC-II\", 256, 0x0801fbff,\n\tHAS_MII | HAS_NWAY | HAS_8023X | HAS_PCI_MWI, pnic2_timer, },\n\n   \n  { \"ADMtek Comet\", 256, 0x0001abef,\n\tHAS_MII | MC_HASH_ONLY | COMET_MAC_ADDR, comet_timer, },\n\n   \n  { \"Compex 9881 PMAC\", 128, 0x0001ebef,\n\tHAS_MII | HAS_MEDIA_TABLE | CSR12_IN_SROM, mxic_timer, },\n\n   \n  { \"Intel DS21145 Tulip\", 128, 0x0801fbff,\n\tHAS_MII | HAS_MEDIA_TABLE | ALWAYS_CHECK_MII | HAS_ACPI\n\t| HAS_NWAY | HAS_PCI_MWI, tulip_timer, tulip_media_task },\n\n   \n#ifdef CONFIG_TULIP_DM910X\n  { \"Davicom DM9102/DM9102A\", 128, 0x0001ebef,\n\tHAS_MII | HAS_MEDIA_TABLE | CSR12_IN_SROM | HAS_ACPI,\n\ttulip_timer, tulip_media_task },\n#else\n  { NULL },\n#endif\n\n   \n  { \"Conexant LANfinity\", 256, 0x0001ebef,\n\tHAS_MII | HAS_ACPI, tulip_timer, tulip_media_task },\n\n};\n\n\nstatic const struct pci_device_id tulip_pci_tbl[] = {\n\t{ 0x1011, 0x0009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DC21140 },\n\t{ 0x1011, 0x0019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DC21143 },\n\t{ 0x11AD, 0x0002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, LC82C168 },\n\t{ 0x10d9, 0x0512, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MX98713 },\n\t{ 0x10d9, 0x0531, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MX98715 },\n \n\t{ 0x125B, 0x1400, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AX88140 },\n\t{ 0x11AD, 0xc115, PCI_ANY_ID, PCI_ANY_ID, 0, 0, PNIC2 },\n\t{ 0x1317, 0x0981, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1317, 0x0985, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1317, 0x1985, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1317, 0x9511, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x13D1, 0xAB02, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x13D1, 0xAB03, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x13D1, 0xAB08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x104A, 0x0981, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x104A, 0x2774, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1259, 0xa120, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x11F6, 0x9881, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMPEX9881 },\n\t{ 0x8086, 0x0039, PCI_ANY_ID, PCI_ANY_ID, 0, 0, I21145 },\n#ifdef CONFIG_TULIP_DM910X\n\t{ 0x1282, 0x9100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DM910X },\n\t{ 0x1282, 0x9102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DM910X },\n#endif\n\t{ 0x1113, 0x1216, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1113, 0x1217, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MX98715 },\n\t{ 0x1113, 0x9511, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1186, 0x1541, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1186, 0x1561, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1186, 0x1591, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x14f1, 0x1803, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CONEXANT },\n\t{ 0x1626, 0x8410, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1737, 0xAB09, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x1737, 0xAB08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x17B3, 0xAB08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ 0x10b7, 0x9300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },  \n\t{ 0x14ea, 0xab08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },  \n\t{ 0x1414, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },  \n\t{ 0x1414, 0x0002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },\n\t{ }  \n};\nMODULE_DEVICE_TABLE(pci, tulip_pci_tbl);\n\n\n \nconst char tulip_media_cap[32] =\n{0,0,0,16,  3,19,16,24,  27,4,7,5, 0,20,23,20,  28,31,0,0, };\n\nstatic void tulip_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void tulip_init_ring(struct net_device *dev);\nstatic void tulip_free_ring(struct net_device *dev);\nstatic netdev_tx_t tulip_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev);\nstatic int tulip_open(struct net_device *dev);\nstatic int tulip_close(struct net_device *dev);\nstatic void tulip_up(struct net_device *dev);\nstatic void tulip_down(struct net_device *dev);\nstatic struct net_device_stats *tulip_get_stats(struct net_device *dev);\nstatic int private_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic void set_rx_mode(struct net_device *dev);\nstatic void tulip_set_wolopts(struct pci_dev *pdev, u32 wolopts);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void poll_tulip(struct net_device *dev);\n#endif\n\nstatic void tulip_set_power_state (struct tulip_private *tp,\n\t\t\t\t   int sleep, int snooze)\n{\n\tif (tp->flags & HAS_ACPI) {\n\t\tu32 tmp, newtmp;\n\t\tpci_read_config_dword (tp->pdev, CFDD, &tmp);\n\t\tnewtmp = tmp & ~(CFDD_Sleep | CFDD_Snooze);\n\t\tif (sleep)\n\t\t\tnewtmp |= CFDD_Sleep;\n\t\telse if (snooze)\n\t\t\tnewtmp |= CFDD_Snooze;\n\t\tif (tmp != newtmp)\n\t\t\tpci_write_config_dword (tp->pdev, CFDD, newtmp);\n\t}\n\n}\n\n\nstatic void tulip_up(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tint next_tick = 3*HZ;\n\tu32 reg;\n\tint i;\n\n#ifdef CONFIG_TULIP_NAPI\n\tnapi_enable(&tp->napi);\n#endif\n\n\t \n\ttulip_set_power_state (tp, 0, 0);\n\n\t \n\tpci_enable_wake(tp->pdev, PCI_D3hot, 0);\n\tpci_enable_wake(tp->pdev, PCI_D3cold, 0);\n\ttulip_set_wolopts(tp->pdev, 0);\n\n\t \n\tif (tp->mii_cnt  ||  (tp->mtable  &&  tp->mtable->has_mii))\n\t\tiowrite32(0x00040000, ioaddr + CSR6);\n\n\t \n\tiowrite32(0x00000001, ioaddr + CSR0);\n\tpci_read_config_dword(tp->pdev, PCI_COMMAND, &reg);   \n\tudelay(100);\n\n\t \n\tiowrite32(tp->csr0, ioaddr + CSR0);\n\tpci_read_config_dword(tp->pdev, PCI_COMMAND, &reg);   \n\tudelay(100);\n\n\tif (tulip_debug > 1)\n\t\tnetdev_dbg(dev, \"tulip_up(), irq==%d\\n\", tp->pdev->irq);\n\n\tiowrite32(tp->rx_ring_dma, ioaddr + CSR3);\n\tiowrite32(tp->tx_ring_dma, ioaddr + CSR4);\n\ttp->cur_rx = tp->cur_tx = 0;\n\ttp->dirty_rx = tp->dirty_tx = 0;\n\n\tif (tp->flags & MC_HASH_ONLY) {\n\t\tu32 addr_low = get_unaligned_le32(dev->dev_addr);\n\t\tu32 addr_high = get_unaligned_le16(dev->dev_addr + 4);\n\t\tif (tp->chip_id == AX88140) {\n\t\t\tiowrite32(0, ioaddr + CSR13);\n\t\t\tiowrite32(addr_low,  ioaddr + CSR14);\n\t\t\tiowrite32(1, ioaddr + CSR13);\n\t\t\tiowrite32(addr_high, ioaddr + CSR14);\n\t\t} else if (tp->flags & COMET_MAC_ADDR) {\n\t\t\tiowrite32(addr_low,  ioaddr + 0xA4);\n\t\t\tiowrite32(addr_high, ioaddr + 0xA8);\n\t\t\tiowrite32(0, ioaddr + CSR27);\n\t\t\tiowrite32(0, ioaddr + CSR28);\n\t\t}\n\t} else {\n\t\t \n\t\tconst u16 *eaddrs = (const u16 *)dev->dev_addr;\n\t\tu16 *setup_frm = &tp->setup_frame[15*6];\n\t\tdma_addr_t mapping;\n\n\t\t \n\t\tmemset(tp->setup_frame, 0xff, sizeof(tp->setup_frame));\n\t\t \n\t\t*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\n\t\t*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\n\t\t*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\n\n\t\tmapping = dma_map_single(&tp->pdev->dev, tp->setup_frame,\n\t\t\t\t\t sizeof(tp->setup_frame),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\ttp->tx_buffers[tp->cur_tx].skb = NULL;\n\t\ttp->tx_buffers[tp->cur_tx].mapping = mapping;\n\n\t\t \n\t\ttp->tx_ring[tp->cur_tx].length = cpu_to_le32(0x08000000 | 192);\n\t\ttp->tx_ring[tp->cur_tx].buffer1 = cpu_to_le32(mapping);\n\t\ttp->tx_ring[tp->cur_tx].status = cpu_to_le32(DescOwned);\n\n\t\ttp->cur_tx++;\n\t}\n\n\ttp->saved_if_port = dev->if_port;\n\tif (dev->if_port == 0)\n\t\tdev->if_port = tp->default_port;\n\n\t \n\ti = 0;\n\tif (tp->mtable == NULL)\n\t\tgoto media_picked;\n\tif (dev->if_port) {\n\t\tint looking_for = tulip_media_cap[dev->if_port] & MediaIsMII ? 11 :\n\t\t\t(dev->if_port == 12 ? 0 : dev->if_port);\n\t\tfor (i = 0; i < tp->mtable->leafcount; i++)\n\t\t\tif (tp->mtable->mleaf[i].media == looking_for) {\n\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t \"Using user-specified media %s\\n\",\n\t\t\t\t\t medianame[dev->if_port]);\n\t\t\t\tgoto media_picked;\n\t\t\t}\n\t}\n\tif ((tp->mtable->defaultmedia & 0x0800) == 0) {\n\t\tint looking_for = tp->mtable->defaultmedia & MEDIA_MASK;\n\t\tfor (i = 0; i < tp->mtable->leafcount; i++)\n\t\t\tif (tp->mtable->mleaf[i].media == looking_for) {\n\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t \"Using EEPROM-set media %s\\n\",\n\t\t\t\t\t medianame[looking_for]);\n\t\t\t\tgoto media_picked;\n\t\t\t}\n\t}\n\t \n\tfor (i = tp->mtable->leafcount - 1;\n\t\t (tulip_media_cap[tp->mtable->mleaf[i].media] & MediaAlwaysFD) && i > 0; i--)\n\t\t;\nmedia_picked:\n\n\ttp->csr6 = 0;\n\ttp->cur_index = i;\n\ttp->nwayset = 0;\n\n\tif (dev->if_port) {\n\t\tif (tp->chip_id == DC21143  &&\n\t\t    (tulip_media_cap[dev->if_port] & MediaIsMII)) {\n\t\t\t \n\t\t\tiowrite32(0x0000, ioaddr + CSR13);\n\t\t\tiowrite32(0x0000, ioaddr + CSR14);\n\t\t\tiowrite32(0x0008, ioaddr + CSR15);\n\t\t}\n\t\ttulip_select_media(dev, 1);\n\t} else if (tp->chip_id == DC21142) {\n\t\tif (tp->mii_cnt) {\n\t\t\ttulip_select_media(dev, 1);\n\t\t\tif (tulip_debug > 1)\n\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t \"Using MII transceiver %d, status %04x\\n\",\n\t\t\t\t\t tp->phys[0],\n\t\t\t\t\t tulip_mdio_read(dev, tp->phys[0], 1));\n\t\t\tiowrite32(csr6_mask_defstate, ioaddr + CSR6);\n\t\t\ttp->csr6 = csr6_mask_hdcap;\n\t\t\tdev->if_port = 11;\n\t\t\tiowrite32(0x0000, ioaddr + CSR13);\n\t\t\tiowrite32(0x0000, ioaddr + CSR14);\n\t\t} else\n\t\t\tt21142_start_nway(dev);\n\t} else if (tp->chip_id == PNIC2) {\n\t         \n\t        tp->sym_advertise = 0x01E0;\n                 \n\t        iowrite32(ioread32(ioaddr+CSR5)| 0x00008010, ioaddr + CSR5);\n\t        iowrite32(ioread32(ioaddr+CSR7)| 0x00008010, ioaddr + CSR7);\n\t\tpnic2_start_nway(dev);\n\t} else if (tp->chip_id == LC82C168  &&  ! tp->medialock) {\n\t\tif (tp->mii_cnt) {\n\t\t\tdev->if_port = 11;\n\t\t\ttp->csr6 = 0x814C0000 | (tp->full_duplex ? 0x0200 : 0);\n\t\t\tiowrite32(0x0001, ioaddr + CSR15);\n\t\t} else if (ioread32(ioaddr + CSR5) & TPLnkPass)\n\t\t\tpnic_do_nway(dev);\n\t\telse {\n\t\t\t \n\t\t\tiowrite32(0x32, ioaddr + CSR12);\n\t\t\ttp->csr6 = 0x00420000;\n\t\t\tiowrite32(0x0001B078, ioaddr + 0xB8);\n\t\t\tiowrite32(0x0201B078, ioaddr + 0xB8);\n\t\t\tnext_tick = 1*HZ;\n\t\t}\n\t} else if ((tp->chip_id == MX98713 || tp->chip_id == COMPEX9881) &&\n\t\t   ! tp->medialock) {\n\t\tdev->if_port = 0;\n\t\ttp->csr6 = 0x01880000 | (tp->full_duplex ? 0x0200 : 0);\n\t\tiowrite32(0x0f370000 | ioread16(ioaddr + 0x80), ioaddr + 0x80);\n\t} else if (tp->chip_id == MX98715 || tp->chip_id == MX98725) {\n\t\t \n\t\tdev->if_port = 0;\n\t\ttp->csr6 = 0x01a80200;\n\t\tiowrite32(0x0f370000 | ioread16(ioaddr + 0x80), ioaddr + 0x80);\n\t\tiowrite32(0x11000 | ioread16(ioaddr + 0xa0), ioaddr + 0xa0);\n\t} else if (tp->chip_id == COMET || tp->chip_id == CONEXANT) {\n\t\t \n\t\tiowrite32(ioread32(ioaddr + 0x88) | 1, ioaddr + 0x88);\n\t\tdev->if_port = tp->mii_cnt ? 11 : 0;\n\t\ttp->csr6 = 0x00040000;\n\t} else if (tp->chip_id == AX88140) {\n\t\ttp->csr6 = tp->mii_cnt ? 0x00040100 : 0x00000100;\n\t} else\n\t\ttulip_select_media(dev, 1);\n\n\t \n\ttulip_stop_rxtx(tp);\n\tbarrier();\n\tudelay(5);\n\tiowrite32(tp->csr6 | TxOn, ioaddr + CSR6);\n\n\t \n\tiowrite32(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR5);\n\tiowrite32(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR7);\n\ttulip_start_rxtx(tp);\n\tiowrite32(0, ioaddr + CSR2);\t\t \n\n\tif (tulip_debug > 2) {\n\t\tnetdev_dbg(dev, \"Done tulip_up(), CSR0 %08x, CSR5 %08x CSR6 %08x\\n\",\n\t\t\t   ioread32(ioaddr + CSR0),\n\t\t\t   ioread32(ioaddr + CSR5),\n\t\t\t   ioread32(ioaddr + CSR6));\n\t}\n\n\t \n\ttp->timer.expires = RUN_AT(next_tick);\n\tadd_timer(&tp->timer);\n#ifdef CONFIG_TULIP_NAPI\n\ttimer_setup(&tp->oom_timer, oom_timer, 0);\n#endif\n}\n\nstatic int\ntulip_open(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint retval;\n\n\ttulip_init_ring (dev);\n\n\tretval = request_irq(tp->pdev->irq, tulip_interrupt, IRQF_SHARED,\n\t\t\t     dev->name, dev);\n\tif (retval)\n\t\tgoto free_ring;\n\n\ttulip_up (dev);\n\n\tnetif_start_queue (dev);\n\n\treturn 0;\n\nfree_ring:\n\ttulip_free_ring (dev);\n\treturn retval;\n}\n\n\nstatic void tulip_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave (&tp->lock, flags);\n\n\tif (tulip_media_cap[dev->if_port] & MediaIsMII) {\n\t\t \n\t\tif (tulip_debug > 1)\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"Transmit timeout using MII device\\n\");\n\t} else if (tp->chip_id == DC21140 || tp->chip_id == DC21142 ||\n\t\t   tp->chip_id == MX98713 || tp->chip_id == COMPEX9881 ||\n\t\t   tp->chip_id == DM910X) {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"21140 transmit timed out, status %08x, SIA %08x %08x %08x %08x, resetting...\\n\",\n\t\t\t ioread32(ioaddr + CSR5), ioread32(ioaddr + CSR12),\n\t\t\t ioread32(ioaddr + CSR13), ioread32(ioaddr + CSR14),\n\t\t\t ioread32(ioaddr + CSR15));\n\t\ttp->timeout_recovery = 1;\n\t\tschedule_work(&tp->media_work);\n\t\tgoto out_unlock;\n\t} else if (tp->chip_id == PNIC2) {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"PNIC2 transmit timed out, status %08x, CSR6/7 %08x / %08x CSR12 %08x, resetting...\\n\",\n\t\t\t (int)ioread32(ioaddr + CSR5),\n\t\t\t (int)ioread32(ioaddr + CSR6),\n\t\t\t (int)ioread32(ioaddr + CSR7),\n\t\t\t (int)ioread32(ioaddr + CSR12));\n\t} else {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"Transmit timed out, status %08x, CSR12 %08x, resetting...\\n\",\n\t\t\t ioread32(ioaddr + CSR5), ioread32(ioaddr + CSR12));\n\t\tdev->if_port = 0;\n\t}\n\n#if defined(way_too_many_messages)\n\tif (tulip_debug > 3) {\n\t\tint i;\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tu8 *buf = (u8 *)(tp->rx_ring[i].buffer1);\n\t\t\tint j;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%2d: %08x %08x %08x %08x  %02x %02x %02x\\n\",\n\t\t\t       i,\n\t\t\t       (unsigned int)tp->rx_ring[i].status,\n\t\t\t       (unsigned int)tp->rx_ring[i].length,\n\t\t\t       (unsigned int)tp->rx_ring[i].buffer1,\n\t\t\t       (unsigned int)tp->rx_ring[i].buffer2,\n\t\t\t       buf[0], buf[1], buf[2]);\n\t\t\tfor (j = 0; ((j < 1600) && buf[j] != 0xee); j++)\n\t\t\t\tif (j < 100)\n\t\t\t\t\tpr_cont(\" %02x\", buf[j]);\n\t\t\tpr_cont(\" j=%d\\n\", j);\n\t\t}\n\t\tprintk(KERN_DEBUG \"  Rx ring %p: \", tp->rx_ring);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tpr_cont(\" %08x\", (unsigned int)tp->rx_ring[i].status);\n\t\tprintk(KERN_DEBUG \"  Tx ring %p: \", tp->tx_ring);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tpr_cont(\" %08x\", (unsigned int)tp->tx_ring[i].status);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\n\ttulip_tx_timeout_complete(tp, ioaddr);\n\nout_unlock:\n\tspin_unlock_irqrestore (&tp->lock, flags);\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue (dev);\n}\n\n\n \nstatic void tulip_init_ring(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint i;\n\n\ttp->susp_rx = 0;\n\ttp->ttimer = 0;\n\ttp->nir = 0;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\ttp->rx_ring[i].status = 0x00000000;\n\t\ttp->rx_ring[i].length = cpu_to_le32(PKT_BUF_SZ);\n\t\ttp->rx_ring[i].buffer2 = cpu_to_le32(tp->rx_ring_dma + sizeof(struct tulip_rx_desc) * (i + 1));\n\t\ttp->rx_buffers[i].skb = NULL;\n\t\ttp->rx_buffers[i].mapping = 0;\n\t}\n\t \n\ttp->rx_ring[i-1].length = cpu_to_le32(PKT_BUF_SZ | DESC_RING_WRAP);\n\ttp->rx_ring[i-1].buffer2 = cpu_to_le32(tp->rx_ring_dma);\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tdma_addr_t mapping;\n\n\t\t \n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, PKT_BUF_SZ);\n\t\ttp->rx_buffers[i].skb = skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\tmapping = dma_map_single(&tp->pdev->dev, skb->data,\n\t\t\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\ttp->rx_buffers[i].mapping = mapping;\n\t\ttp->rx_ring[i].status = cpu_to_le32(DescOwned);\t \n\t\ttp->rx_ring[i].buffer1 = cpu_to_le32(mapping);\n\t}\n\ttp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\ttp->tx_buffers[i].skb = NULL;\n\t\ttp->tx_buffers[i].mapping = 0;\n\t\ttp->tx_ring[i].status = 0x00000000;\n\t\ttp->tx_ring[i].buffer2 = cpu_to_le32(tp->tx_ring_dma + sizeof(struct tulip_tx_desc) * (i + 1));\n\t}\n\ttp->tx_ring[i-1].buffer2 = cpu_to_le32(tp->tx_ring_dma);\n}\n\nstatic netdev_tx_t\ntulip_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint entry;\n\tu32 flag;\n\tdma_addr_t mapping;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tp->lock, flags);\n\n\t \n\tentry = tp->cur_tx % TX_RING_SIZE;\n\n\ttp->tx_buffers[entry].skb = skb;\n\tmapping = dma_map_single(&tp->pdev->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\ttp->tx_buffers[entry].mapping = mapping;\n\ttp->tx_ring[entry].buffer1 = cpu_to_le32(mapping);\n\n\tif (tp->cur_tx - tp->dirty_tx < TX_RING_SIZE/2) { \n\t\tflag = 0x60000000;  \n\t} else if (tp->cur_tx - tp->dirty_tx == TX_RING_SIZE/2) {\n\t\tflag = 0xe0000000;  \n\t} else if (tp->cur_tx - tp->dirty_tx < TX_RING_SIZE - 2) {\n\t\tflag = 0x60000000;  \n\t} else {\t\t \n\t\tflag = 0xe0000000;  \n\t\tnetif_stop_queue(dev);\n\t}\n\tif (entry == TX_RING_SIZE-1)\n\t\tflag = 0xe0000000 | DESC_RING_WRAP;\n\n\ttp->tx_ring[entry].length = cpu_to_le32(skb->len | flag);\n\t \n\ttp->tx_ring[entry].status = cpu_to_le32(DescOwned);\n\twmb();\n\n\ttp->cur_tx++;\n\n\t \n\tiowrite32(0, tp->base_addr + CSR1);\n\n\tspin_unlock_irqrestore(&tp->lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void tulip_clean_tx_ring(struct tulip_private *tp)\n{\n\tunsigned int dirty_tx;\n\n\tfor (dirty_tx = tp->dirty_tx ; tp->cur_tx - dirty_tx > 0;\n\t\tdirty_tx++) {\n\t\tint entry = dirty_tx % TX_RING_SIZE;\n\t\tint status = le32_to_cpu(tp->tx_ring[entry].status);\n\n\t\tif (status < 0) {\n\t\t\ttp->dev->stats.tx_errors++;\t \n\t\t\ttp->tx_ring[entry].status = 0;\n\t\t}\n\n\t\t \n\t\tif (tp->tx_buffers[entry].skb == NULL) {\n\t\t\t \n\t\t\tif (tp->tx_buffers[entry].mapping)\n\t\t\t\tdma_unmap_single(&tp->pdev->dev,\n\t\t\t\t\t\t tp->tx_buffers[entry].mapping,\n\t\t\t\t\t\t sizeof(tp->setup_frame),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdma_unmap_single(&tp->pdev->dev,\n\t\t\t\t tp->tx_buffers[entry].mapping,\n\t\t\t\t tp->tx_buffers[entry].skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t \n\t\tdev_kfree_skb_irq(tp->tx_buffers[entry].skb);\n\t\ttp->tx_buffers[entry].skb = NULL;\n\t\ttp->tx_buffers[entry].mapping = 0;\n\t}\n}\n\nstatic void tulip_down (struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tunsigned long flags;\n\n\tcancel_work_sync(&tp->media_work);\n\n#ifdef CONFIG_TULIP_NAPI\n\tnapi_disable(&tp->napi);\n#endif\n\n\tdel_timer_sync (&tp->timer);\n#ifdef CONFIG_TULIP_NAPI\n\tdel_timer_sync (&tp->oom_timer);\n#endif\n\tspin_lock_irqsave (&tp->lock, flags);\n\n\t \n\tiowrite32 (0x00000000, ioaddr + CSR7);\n\n\t \n\ttulip_stop_rxtx(tp);\n\n\t \n\ttulip_refill_rx(dev);\n\n\t \n\ttulip_clean_tx_ring(tp);\n\n\tif (ioread32(ioaddr + CSR6) != 0xffffffff)\n\t\tdev->stats.rx_missed_errors += ioread32(ioaddr + CSR8) & 0xffff;\n\n\tspin_unlock_irqrestore (&tp->lock, flags);\n\n\ttimer_setup(&tp->timer, tulip_tbl[tp->chip_id].media_timer, 0);\n\n\tdev->if_port = tp->saved_if_port;\n\n\t \n\ttulip_set_power_state (tp, 0, 1);\n}\n\nstatic void tulip_free_ring (struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = tp->rx_buffers[i].skb;\n\t\tdma_addr_t mapping = tp->rx_buffers[i].mapping;\n\n\t\ttp->rx_buffers[i].skb = NULL;\n\t\ttp->rx_buffers[i].mapping = 0;\n\n\t\ttp->rx_ring[i].status = 0;\t \n\t\ttp->rx_ring[i].length = 0;\n\t\t \n\t\ttp->rx_ring[i].buffer1 = cpu_to_le32(0xBADF00D0);\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&tp->pdev->dev, mapping, PKT_BUF_SZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb (skb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = tp->tx_buffers[i].skb;\n\n\t\tif (skb != NULL) {\n\t\t\tdma_unmap_single(&tp->pdev->dev,\n\t\t\t\t\t tp->tx_buffers[i].mapping, skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb (skb);\n\t\t}\n\t\ttp->tx_buffers[i].skb = NULL;\n\t\ttp->tx_buffers[i].mapping = 0;\n\t}\n}\n\nstatic int tulip_close (struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\n\tnetif_stop_queue (dev);\n\n\ttulip_down (dev);\n\n\tif (tulip_debug > 1)\n\t\tnetdev_dbg(dev, \"Shutting down ethercard, status was %02x\\n\",\n\t\t\t   ioread32 (ioaddr + CSR5));\n\n\tfree_irq (tp->pdev->irq, dev);\n\n\ttulip_free_ring (dev);\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *tulip_get_stats(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\n\tif (netif_running(dev)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave (&tp->lock, flags);\n\n\t\tdev->stats.rx_missed_errors += ioread32(ioaddr + CSR8) & 0xffff;\n\n\t\tspin_unlock_irqrestore(&tp->lock, flags);\n\t}\n\n\treturn &dev->stats;\n}\n\n\nstatic void tulip_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct tulip_private *np = netdev_priv(dev);\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(np->pdev), sizeof(info->bus_info));\n}\n\n\nstatic int tulip_ethtool_set_wol(struct net_device *dev,\n\t\t\t\t struct ethtool_wolinfo *wolinfo)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\n\tif (wolinfo->wolopts & (~tp->wolinfo.supported))\n\t\t   return -EOPNOTSUPP;\n\n\ttp->wolinfo.wolopts = wolinfo->wolopts;\n\tdevice_set_wakeup_enable(&tp->pdev->dev, tp->wolinfo.wolopts);\n\treturn 0;\n}\n\nstatic void tulip_ethtool_get_wol(struct net_device *dev,\n\t\t\t\t  struct ethtool_wolinfo *wolinfo)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\n\twolinfo->supported = tp->wolinfo.supported;\n\twolinfo->wolopts = tp->wolinfo.wolopts;\n\treturn;\n}\n\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = tulip_get_drvinfo,\n\t.set_wol     = tulip_ethtool_set_wol,\n\t.get_wol     = tulip_ethtool_get_wol,\n};\n\n \nstatic int private_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tconst unsigned int phy_idx = 0;\n\tint phy = tp->phys[phy_idx] & 0x1f;\n\tunsigned int regnum = data->reg_num;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\t\t \n\t\tif (tp->mii_cnt)\n\t\t\tdata->phy_id = phy;\n\t\telse if (tp->flags & HAS_NWAY)\n\t\t\tdata->phy_id = 32;\n\t\telse if (tp->chip_id == COMET)\n\t\t\tdata->phy_id = 1;\n\t\telse\n\t\t\treturn -ENODEV;\n\t\tfallthrough;\n\n\tcase SIOCGMIIREG:\t\t \n\t\tif (data->phy_id == 32 && (tp->flags & HAS_NWAY)) {\n\t\t\tint csr12 = ioread32 (ioaddr + CSR12);\n\t\t\tint csr14 = ioread32 (ioaddr + CSR14);\n\t\t\tswitch (regnum) {\n\t\t\tcase 0:\n                                if (((csr14<<5) & 0x1000) ||\n                                        (dev->if_port == 5 && tp->nwayset))\n                                        data->val_out = 0x1000;\n                                else\n                                        data->val_out = (tulip_media_cap[dev->if_port]&MediaIs100 ? 0x2000 : 0)\n                                                | (tulip_media_cap[dev->if_port]&MediaIsFD ? 0x0100 : 0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n                                data->val_out =\n\t\t\t\t\t0x1848 +\n\t\t\t\t\t((csr12&0x7000) == 0x5000 ? 0x20 : 0) +\n\t\t\t\t\t((csr12&0x06) == 6 ? 0 : 4);\n                                data->val_out |= 0x6048;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n                                 \n                                data->val_out =\n\t\t\t\t\t((ioread32(ioaddr + CSR6) >> 3) & 0x0040) +\n\t\t\t\t\t((csr14 >> 1) & 0x20) + 1;\n                                data->val_out |= ((csr14 >> 9) & 0x03C0);\n\t\t\t\tbreak;\n\t\t\tcase 5: data->val_out = tp->lpar; break;\n\t\t\tdefault: data->val_out = 0; break;\n\t\t\t}\n\t\t} else {\n\t\t\tdata->val_out = tulip_mdio_read (dev, data->phy_id & 0x1f, regnum);\n\t\t}\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\t\t \n\t\tif (regnum & ~0x1f)\n\t\t\treturn -EINVAL;\n\t\tif (data->phy_id == phy) {\n\t\t\tu16 value = data->val_in;\n\t\t\tswitch (regnum) {\n\t\t\tcase 0:\t \n\t\t\t\ttp->full_duplex_lock = (value & 0x9000) ? 0 : 1;\n\t\t\t\tif (tp->full_duplex_lock)\n\t\t\t\t\ttp->full_duplex = (value & 0x0100) ? 1 : 0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\ttp->advertising[phy_idx] =\n\t\t\t\ttp->mii_advertise = data->val_in;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (data->phy_id == 32 && (tp->flags & HAS_NWAY)) {\n\t\t\tu16 value = data->val_in;\n\t\t\tif (regnum == 0) {\n\t\t\t  if ((value & 0x1200) == 0x1200) {\n\t\t\t    if (tp->chip_id == PNIC2) {\n                                   pnic2_start_nway (dev);\n                            } else {\n\t\t\t\t   t21142_start_nway (dev);\n                            }\n\t\t\t  }\n\t\t\t} else if (regnum == 4)\n\t\t\t\ttp->sym_advertise = value;\n\t\t} else {\n\t\t\ttulip_mdio_write (dev, data->phy_id & 0x1f, regnum, data->val_in);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n\n \n\nstatic void build_setup_frame_hash(u16 *setup_frm, struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tu16 hash_table[32];\n\tstruct netdev_hw_addr *ha;\n\tconst u16 *eaddrs;\n\tint i;\n\n\tmemset(hash_table, 0, sizeof(hash_table));\n\t__set_bit_le(255, hash_table);\t\t\t \n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tint index = ether_crc_le(ETH_ALEN, ha->addr) & 0x1ff;\n\n\t\t__set_bit_le(index, hash_table);\n\t}\n\tfor (i = 0; i < 32; i++) {\n\t\t*setup_frm++ = hash_table[i];\n\t\t*setup_frm++ = hash_table[i];\n\t}\n\tsetup_frm = &tp->setup_frame[13*6];\n\n\t \n\teaddrs = (const u16 *)dev->dev_addr;\n\t*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\n\t*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\n\t*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\n}\n\nstatic void build_setup_frame_perfect(u16 *setup_frm, struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tconst u16 *eaddrs;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\teaddrs = (u16 *) ha->addr;\n\t\t*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\n\t\t*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\n\t\t*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\n\t}\n\t \n\tmemset(setup_frm, 0xff, (15 - netdev_mc_count(dev)) * 12);\n\tsetup_frm = &tp->setup_frame[15*6];\n\n\t \n\teaddrs = (const u16 *)dev->dev_addr;\n\t*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\n\t*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\n\t*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\n}\n\n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tint csr6;\n\n\tcsr6 = ioread32(ioaddr + CSR6) & ~0x00D5;\n\n\ttp->csr6 &= ~0x00D5;\n\tif (dev->flags & IFF_PROMISC) {\t\t\t \n\t\ttp->csr6 |= AcceptAllMulticast | AcceptAllPhys;\n\t\tcsr6 |= AcceptAllMulticast | AcceptAllPhys;\n\t} else if ((netdev_mc_count(dev) > 1000) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\ttp->csr6 |= AcceptAllMulticast;\n\t\tcsr6 |= AcceptAllMulticast;\n\t} else\tif (tp->flags & MC_HASH_ONLY) {\n\t\t \n\t\t \n\t\tstruct netdev_hw_addr *ha;\n\t\tif (netdev_mc_count(dev) > 64) {\n\t\t\t \n\t\t\ttp->csr6 |= AcceptAllMulticast;\n\t\t\tcsr6 |= AcceptAllMulticast;\n\t\t} else {\n\t\t\tu32 mc_filter[2] = {0, 0};\t\t  \n\t\t\tint filterbit;\n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\tif (tp->flags & COMET_MAC_ADDR)\n\t\t\t\t\tfilterbit = ether_crc_le(ETH_ALEN,\n\t\t\t\t\t\t\t\t ha->addr);\n\t\t\t\telse\n\t\t\t\t\tfilterbit = ether_crc(ETH_ALEN,\n\t\t\t\t\t\t\t      ha->addr) >> 26;\n\t\t\t\tfilterbit &= 0x3f;\n\t\t\t\tmc_filter[filterbit >> 5] |= 1 << (filterbit & 31);\n\t\t\t\tif (tulip_debug > 2)\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"Added filter for %pM  %08x bit %d\\n\",\n\t\t\t\t\t\t ha->addr,\n\t\t\t\t\t\t ether_crc(ETH_ALEN, ha->addr),\n\t\t\t\t\t\t filterbit);\n\t\t\t}\n\t\t\tif (mc_filter[0] == tp->mc_filter[0]  &&\n\t\t\t\tmc_filter[1] == tp->mc_filter[1])\n\t\t\t\t;\t\t\t\t \n\t\t\telse if (tp->flags & IS_ASIX) {\n\t\t\t\tiowrite32(2, ioaddr + CSR13);\n\t\t\t\tiowrite32(mc_filter[0], ioaddr + CSR14);\n\t\t\t\tiowrite32(3, ioaddr + CSR13);\n\t\t\t\tiowrite32(mc_filter[1], ioaddr + CSR14);\n\t\t\t} else if (tp->flags & COMET_MAC_ADDR) {\n\t\t\t\tiowrite32(mc_filter[0], ioaddr + CSR27);\n\t\t\t\tiowrite32(mc_filter[1], ioaddr + CSR28);\n\t\t\t}\n\t\t\ttp->mc_filter[0] = mc_filter[0];\n\t\t\ttp->mc_filter[1] = mc_filter[1];\n\t\t}\n\t} else {\n\t\tunsigned long flags;\n\t\tu32 tx_flags = 0x08000000 | 192;\n\n\t\t \n\t\tif (netdev_mc_count(dev) > 14) {\n\t\t\t \n\t\t\tbuild_setup_frame_hash(tp->setup_frame, dev);\n\t\t\ttx_flags = 0x08400000 | 192;\n\t\t} else {\n\t\t\tbuild_setup_frame_perfect(tp->setup_frame, dev);\n\t\t}\n\n\t\tspin_lock_irqsave(&tp->lock, flags);\n\n\t\tif (tp->cur_tx - tp->dirty_tx > TX_RING_SIZE - 2) {\n\t\t\t \n\t\t} else {\n\t\t\tunsigned int entry;\n\t\t\tint dummy = -1;\n\n\t\t\t \n\n\t\t\tentry = tp->cur_tx++ % TX_RING_SIZE;\n\n\t\t\tif (entry != 0) {\n\t\t\t\t \n\t\t\t\ttp->tx_buffers[entry].skb = NULL;\n\t\t\t\ttp->tx_buffers[entry].mapping = 0;\n\t\t\t\ttp->tx_ring[entry].length =\n\t\t\t\t\t(entry == TX_RING_SIZE-1) ? cpu_to_le32(DESC_RING_WRAP) : 0;\n\t\t\t\ttp->tx_ring[entry].buffer1 = 0;\n\t\t\t\t \n\t\t\t\tdummy = entry;\n\t\t\t\tentry = tp->cur_tx++ % TX_RING_SIZE;\n\n\t\t\t}\n\n\t\t\ttp->tx_buffers[entry].skb = NULL;\n\t\t\ttp->tx_buffers[entry].mapping =\n\t\t\t\tdma_map_single(&tp->pdev->dev,\n\t\t\t\t\t       tp->setup_frame,\n\t\t\t\t\t       sizeof(tp->setup_frame),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t \n\t\t\tif (entry == TX_RING_SIZE-1)\n\t\t\t\ttx_flags |= DESC_RING_WRAP;\t\t \n\t\t\ttp->tx_ring[entry].length = cpu_to_le32(tx_flags);\n\t\t\ttp->tx_ring[entry].buffer1 =\n\t\t\t\tcpu_to_le32(tp->tx_buffers[entry].mapping);\n\t\t\ttp->tx_ring[entry].status = cpu_to_le32(DescOwned);\n\t\t\tif (dummy >= 0)\n\t\t\t\ttp->tx_ring[dummy].status = cpu_to_le32(DescOwned);\n\t\t\tif (tp->cur_tx - tp->dirty_tx >= TX_RING_SIZE - 2)\n\t\t\t\tnetif_stop_queue(dev);\n\n\t\t\t \n\t\t\tiowrite32(0, ioaddr + CSR1);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&tp->lock, flags);\n\t}\n\n\tiowrite32(csr6, ioaddr + CSR6);\n}\n\n#ifdef CONFIG_TULIP_MWI\nstatic void tulip_mwi_config(struct pci_dev *pdev, struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tu8 cache;\n\tu16 pci_command;\n\tu32 csr0;\n\n\tif (tulip_debug > 3)\n\t\tnetdev_dbg(dev, \"tulip_mwi_config()\\n\");\n\n\ttp->csr0 = csr0 = 0;\n\n\t \n\tcsr0 |= MRM | MWI;\n\n\t \n\tpci_try_set_mwi(pdev);\n\n\t \n\tpci_read_config_word(pdev, PCI_COMMAND, &pci_command);\n\tif ((csr0 & MWI) && (!(pci_command & PCI_COMMAND_INVALIDATE)))\n\t\tcsr0 &= ~MWI;\n\n\t \n\tpci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &cache);\n\tif ((csr0 & MWI) && (cache == 0)) {\n\t\tcsr0 &= ~MWI;\n\t\tpci_clear_mwi(pdev);\n\t}\n\n\t \n\tswitch (cache) {\n\tcase 8:\n\t\tcsr0 |= MRL | (1 << CALShift) | (16 << BurstLenShift);\n\t\tbreak;\n\tcase 16:\n\t\tcsr0 |= MRL | (2 << CALShift) | (16 << BurstLenShift);\n\t\tbreak;\n\tcase 32:\n\t\tcsr0 |= MRL | (3 << CALShift) | (32 << BurstLenShift);\n\t\tbreak;\n\tdefault:\n\t\tcache = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (cache)\n\t\tgoto out;\n\n\t \n\tif (csr0 & MWI) {\n\t\tpci_clear_mwi(pdev);\n\t\tcsr0 &= ~MWI;\n\t}\n\n\t \n\tcsr0 |= (8 << BurstLenShift) | (1 << CALShift);\n\nout:\n\ttp->csr0 = csr0;\n\tif (tulip_debug > 2)\n\t\tnetdev_dbg(dev, \"MWI config cacheline=%d, csr0=%08x\\n\",\n\t\t\t   cache, csr0);\n}\n#endif\n\n \n\nstatic int tulip_uli_dm_quirk(struct pci_dev *pdev)\n{\n\tif (pdev->vendor == 0x1282 && pdev->device == 0x9102)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic const struct net_device_ops tulip_netdev_ops = {\n\t.ndo_open\t\t= tulip_open,\n\t.ndo_start_xmit\t\t= tulip_start_xmit,\n\t.ndo_tx_timeout\t\t= tulip_tx_timeout,\n\t.ndo_stop\t\t= tulip_close,\n\t.ndo_get_stats\t\t= tulip_get_stats,\n\t.ndo_eth_ioctl\t\t= private_ioctl,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t = poll_tulip,\n#endif\n};\n\nstatic const struct pci_device_id early_486_chipsets[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82424) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_496) },\n\t{ },\n};\n\nstatic int tulip_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct tulip_private *tp;\n\t \n\tstatic unsigned char last_phys_addr[ETH_ALEN] = {\n\t\t0x00, 'L', 'i', 'n', 'u', 'x'\n\t};\n#if defined(__i386__) || defined(__x86_64__)\t \n\tstatic int last_irq;\n#endif\n\tint i, irq;\n\tunsigned short sum;\n\tunsigned char *ee_data;\n\tstruct net_device *dev;\n\tvoid __iomem *ioaddr;\n\tstatic int board_idx = -1;\n\tint chip_idx = ent->driver_data;\n\tconst char *chip_name = tulip_tbl[chip_idx].chip_name;\n\tunsigned int eeprom_missing = 0;\n\tu8 addr[ETH_ALEN] __aligned(2);\n\tunsigned int force_csr0 = 0;\n\n\tboard_idx++;\n\n\t \n\n        if (pdev->subsystem_vendor == PCI_VENDOR_ID_LMC) {\n\t\tpr_err(\"skipping LMC card\\n\");\n\t\treturn -ENODEV;\n\t} else if (pdev->subsystem_vendor == PCI_VENDOR_ID_SBE &&\n\t\t   (pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_T3E3 ||\n\t\t    pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P0 ||\n\t\t    pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P1)) {\n\t\tpr_err(\"skipping SBE T3E3 port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n#ifdef CONFIG_TULIP_DM910X\n\tif (chip_idx == DM910X) {\n\t\tstruct device_node *dp;\n\n\t\tif (pdev->vendor == 0x1282 && pdev->device == 0x9100 &&\n\t\t    pdev->revision < 0x30) {\n\t\t\tpr_info(\"skipping early DM9100 with Crc bug (use dmfe)\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdp = pci_device_to_OF_node(pdev);\n\t\tif (!(dp && of_get_property(dp, \"local-mac-address\", NULL))) {\n\t\t\tpr_info(\"skipping DM910x expansion card (use dmfe)\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\t \n\n\t \n\n\tif (pci_dev_present(early_486_chipsets)) {\n\t\tcsr0 = MRL | MRM | (8 << BurstLenShift) | (1 << CALShift);\n\t\tforce_csr0 = 1;\n\t}\n\n\t \n\tif (chip_idx == AX88140) {\n\t\tif ((csr0 & 0x3f00) == 0)\n\t\t\tcsr0 |= 0x2000;\n\t}\n\n\t \n\tif (chip_idx == LC82C168)\n\t\tcsr0 &= ~0xfff10000;  \n\n\t \n\tif (tulip_uli_dm_quirk(pdev)) {\n\t\tcsr0 &= ~0x01f100ff;\n#if defined(CONFIG_SPARC)\n                csr0 = (csr0 & ~0xff00) | 0xe000;\n#endif\n\t}\n\t \n\n\ti = pcim_enable_device(pdev);\n\tif (i) {\n\t\tpr_err(\"Cannot enable tulip board #%d, aborting\\n\", board_idx);\n\t\treturn i;\n\t}\n\n\tirq = pdev->irq;\n\n\t \n\tdev = devm_alloc_etherdev(&pdev->dev, sizeof(*tp));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tif (pci_resource_len (pdev, 0) < tulip_tbl[chip_idx].io_size) {\n\t\tpr_err(\"%s: I/O region (0x%llx@0x%llx) too small, aborting\\n\",\n\t\t       pci_name(pdev),\n\t\t       (unsigned long long)pci_resource_len (pdev, 0),\n\t\t       (unsigned long long)pci_resource_start (pdev, 0));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (pci_request_regions(pdev, DRV_NAME))\n\t\treturn -ENODEV;\n\n\tioaddr = pcim_iomap(pdev, TULIP_BAR, tulip_tbl[chip_idx].io_size);\n\n\tif (!ioaddr)\n\t\treturn -ENODEV;\n\n\t \n\ttp = netdev_priv(dev);\n\ttp->dev = dev;\n\n\ttp->rx_ring = dmam_alloc_coherent(&pdev->dev,\n\t\t\t\t\t  sizeof(struct tulip_rx_desc) * RX_RING_SIZE +\n\t\t\t\t\t  sizeof(struct tulip_tx_desc) * TX_RING_SIZE,\n\t\t\t\t\t  &tp->rx_ring_dma, GFP_KERNEL);\n\tif (!tp->rx_ring)\n\t\treturn -ENODEV;\n\ttp->tx_ring = (struct tulip_tx_desc *)(tp->rx_ring + RX_RING_SIZE);\n\ttp->tx_ring_dma = tp->rx_ring_dma + sizeof(struct tulip_rx_desc) * RX_RING_SIZE;\n\n\ttp->chip_id = chip_idx;\n\ttp->flags = tulip_tbl[chip_idx].flags;\n\n\ttp->wolinfo.supported = 0;\n\ttp->wolinfo.wolopts = 0;\n\t \n\tif (chip_idx == COMET ) {\n\t\tu32 sig;\n\t\tpci_read_config_dword (pdev, 0x80, &sig);\n\t\tif (sig == 0x09811317) {\n\t\t\ttp->flags |= COMET_PM;\n\t\t\ttp->wolinfo.supported = WAKE_PHY | WAKE_MAGIC;\n\t\t\tpr_info(\"%s: Enabled WOL support for AN983B\\n\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\ttp->pdev = pdev;\n\ttp->base_addr = ioaddr;\n\ttp->revision = pdev->revision;\n\ttp->csr0 = csr0;\n\tspin_lock_init(&tp->lock);\n\tspin_lock_init(&tp->mii_lock);\n\ttimer_setup(&tp->timer, tulip_tbl[tp->chip_id].media_timer, 0);\n\n\tINIT_WORK(&tp->media_work, tulip_tbl[tp->chip_id].media_task);\n\n#ifdef CONFIG_TULIP_MWI\n\tif (!force_csr0 && (tp->flags & HAS_PCI_MWI))\n\t\ttulip_mwi_config (pdev, dev);\n#endif\n\n\t \n\ttulip_stop_rxtx(tp);\n\n\tpci_set_master(pdev);\n\n#ifdef CONFIG_GSC\n\tif (pdev->subsystem_vendor == PCI_VENDOR_ID_HP) {\n\t\tswitch (pdev->subsystem_device) {\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase 0x1061:\n\t\tcase 0x1062:\n\t\tcase 0x1063:\n\t\tcase 0x1098:\n\t\tcase 0x1099:\n\t\tcase 0x10EE:\n\t\t\ttp->flags |= HAS_SWAPPED_SEEPROM | NEEDS_FAKE_MEDIA_TABLE;\n\t\t\tchip_name = \"GSC DS21140 Tulip\";\n\t\t}\n\t}\n#endif\n\n\t \n\tioread32(ioaddr + CSR8);\n\n\t \n\tee_data = tp->eeprom;\n\tmemset(ee_data, 0, sizeof(tp->eeprom));\n\tsum = 0;\n\tif (chip_idx == LC82C168) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tint value, boguscnt = 100000;\n\t\t\tiowrite32(0x600 | i, ioaddr + 0x98);\n\t\t\tdo {\n\t\t\t\tvalue = ioread32(ioaddr + CSR9);\n\t\t\t} while (value < 0  && --boguscnt > 0);\n\t\t\tput_unaligned_le16(value, ((__le16 *)addr) + i);\n\t\t\tsum += value & 0xffff;\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\t} else if (chip_idx == COMET) {\n\t\t \n\t\tput_unaligned_le32(ioread32(ioaddr + 0xA4), addr);\n\t\tput_unaligned_le16(ioread32(ioaddr + 0xA8), addr + 4);\n\t\teth_hw_addr_set(dev, addr);\n\t\tfor (i = 0; i < 6; i ++)\n\t\t\tsum += dev->dev_addr[i];\n\t} else {\n\t\t \n\t\tint sa_offset = 0;\n\t\tint ee_addr_size = tulip_read_eeprom(dev, 0xff, 8) & 0x40000 ? 8 : 6;\n\t\tint ee_max_addr = ((1 << ee_addr_size) - 1) * sizeof(u16);\n\n\t\tif (ee_max_addr > sizeof(tp->eeprom))\n\t\t\tee_max_addr = sizeof(tp->eeprom);\n\n\t\tfor (i = 0; i < ee_max_addr ; i += sizeof(u16)) {\n\t\t\tu16 data = tulip_read_eeprom(dev, i/2, ee_addr_size);\n\t\t\tee_data[i] = data & 0xff;\n\t\t\tee_data[i + 1] = data >> 8;\n\t\t}\n\n\t\t \n\t\t \n\t\tfor (i = 0; i < 8; i ++)\n\t\t\tif (ee_data[i] != ee_data[16+i])\n\t\t\t\tsa_offset = 20;\n\t\tif (chip_idx == CONEXANT) {\n\t\t\t \n\t\t\tif (ee_data[0x198] == 0x04  &&  ee_data[0x199] == 6)\n\t\t\t\tsa_offset = 0x19A;\n\t\t} else if (ee_data[0] == 0xff  &&  ee_data[1] == 0xff &&\n\t\t\t\t   ee_data[2] == 0) {\n\t\t\tsa_offset = 2;\t\t \n\t\t}\n#ifdef CONFIG_MIPS_COBALT\n               if ((pdev->bus->number == 0) &&\n                   ((PCI_SLOT(pdev->devfn) == 7) ||\n                    (PCI_SLOT(pdev->devfn) == 12))) {\n                        \n                       sa_offset = 0;\n\t\t        \n\t\t       memcpy(ee_data + 16, ee_data, 8);\n               }\n#endif\n#ifdef CONFIG_GSC\n\t\t \n\t\tif (ee_data[0] == 0x61 && ee_data[1] == 0x10) {\n\t\t\t \n\t\t\tee_data[0] = ee_data[2];\n\t\t\tee_data[1] = ee_data[3];\n\t\t\tee_data[2] = 0x61;\n\t\t\tee_data[3] = 0x10;\n\n\t\t\t \n\t\t\tfor (i = 4; i >= 0; i -= 2) {\n\t\t\t\tee_data[17 + i + 3] = ee_data[17 + i];\n\t\t\t\tee_data[16 + i + 5] = ee_data[16 + i];\n\t\t\t}\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < 6; i ++) {\n\t\t\taddr[i] = ee_data[i + sa_offset];\n\t\t\tsum += ee_data[i + sa_offset];\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\t}\n\t \n\tif ((dev->dev_addr[0] == 0xA0 ||\n\t     dev->dev_addr[0] == 0xC0 ||\n\t     dev->dev_addr[0] == 0x02) &&\n\t    dev->dev_addr[1] == 0x00) {\n\t\tfor (i = 0; i < 6; i+=2) {\n\t\t\taddr[i] = dev->dev_addr[i+1];\n\t\t\taddr[i+1] = dev->dev_addr[i];\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\t}\n\n\t \n\tif (sum == 0  || sum == 6*0xff) {\n#if defined(CONFIG_SPARC)\n\t\tstruct device_node *dp = pci_device_to_OF_node(pdev);\n\t\tconst unsigned char *addr2;\n\t\tint len;\n#endif\n\t\teeprom_missing = 1;\n\t\tfor (i = 0; i < 5; i++)\n\t\t\taddr[i] = last_phys_addr[i];\n\t\taddr[i] = last_phys_addr[i] + 1;\n\t\teth_hw_addr_set(dev, addr);\n#if defined(CONFIG_SPARC)\n\t\taddr2 = of_get_property(dp, \"local-mac-address\", &len);\n\t\tif (addr2 && len == ETH_ALEN)\n\t\t\teth_hw_addr_set(dev, addr2);\n#endif\n#if defined(__i386__) || defined(__x86_64__)\t \n\t\tif (last_irq)\n\t\t\tirq = last_irq;\n#endif\n\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\tlast_phys_addr[i] = dev->dev_addr[i];\n#if defined(__i386__) || defined(__x86_64__)\t \n\tlast_irq = irq;\n#endif\n\n\t \n\tif (board_idx >= 0  &&  board_idx < MAX_UNITS) {\n\t\tif (options[board_idx] & MEDIA_MASK)\n\t\t\ttp->default_port = options[board_idx] & MEDIA_MASK;\n\t\tif ((options[board_idx] & FullDuplex) || full_duplex[board_idx] > 0)\n\t\t\ttp->full_duplex = 1;\n\t\tif (mtu[board_idx] > 0)\n\t\t\tdev->mtu = mtu[board_idx];\n\t}\n\tif (dev->mem_start & MEDIA_MASK)\n\t\ttp->default_port = dev->mem_start & MEDIA_MASK;\n\tif (tp->default_port) {\n\t\tpr_info(DRV_NAME \"%d: Transceiver selection forced to %s\\n\",\n\t\t\tboard_idx, medianame[tp->default_port & MEDIA_MASK]);\n\t\ttp->medialock = 1;\n\t\tif (tulip_media_cap[tp->default_port] & MediaAlwaysFD)\n\t\t\ttp->full_duplex = 1;\n\t}\n\tif (tp->full_duplex)\n\t\ttp->full_duplex_lock = 1;\n\n\tif (tulip_media_cap[tp->default_port] & MediaIsMII) {\n\t\tstatic const u16 media2advert[] = {\n\t\t\t0x20, 0x40, 0x03e0, 0x60, 0x80, 0x100, 0x200\n\t\t};\n\t\ttp->mii_advertise = media2advert[tp->default_port - 9];\n\t\ttp->mii_advertise |= (tp->flags & HAS_8023X);  \n\t}\n\n\tif (tp->flags & HAS_MEDIA_TABLE) {\n\t\tsprintf(dev->name, DRV_NAME \"%d\", board_idx);\t \n\t\ttulip_parse_eeprom(dev);\n\t\tstrcpy(dev->name, \"eth%d\");\t\t\t \n\t}\n\n\tif ((tp->flags & ALWAYS_CHECK_MII) ||\n\t\t(tp->mtable  &&  tp->mtable->has_mii) ||\n\t\t( ! tp->mtable  &&  (tp->flags & HAS_MII))) {\n\t\tif (tp->mtable  &&  tp->mtable->has_mii) {\n\t\t\tfor (i = 0; i < tp->mtable->leafcount; i++)\n\t\t\t\tif (tp->mtable->mleaf[i].media == 11) {\n\t\t\t\t\ttp->cur_index = i;\n\t\t\t\t\ttp->saved_if_port = dev->if_port;\n\t\t\t\t\ttulip_select_media(dev, 2);\n\t\t\t\t\tdev->if_port = tp->saved_if_port;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\n\t\t \n\t\ttulip_find_mii (dev, board_idx);\n\t}\n\n\t \n\tdev->netdev_ops = &tulip_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n#ifdef CONFIG_TULIP_NAPI\n\tnetif_napi_add_weight(dev, &tp->napi, tulip_poll, 16);\n#endif\n\tdev->ethtool_ops = &ops;\n\n\ti = register_netdev(dev);\n\tif (i)\n\t\treturn i;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tdev_info(&dev->dev,\n#ifdef CONFIG_TULIP_MMIO\n\t\t \"%s rev %d at MMIO %#llx,%s %pM, IRQ %d\\n\",\n#else\n\t\t \"%s rev %d at Port %#llx,%s %pM, IRQ %d\\n\",\n#endif\n\t\t chip_name, pdev->revision,\n\t\t (unsigned long long)pci_resource_start(pdev, TULIP_BAR),\n\t\t eeprom_missing ? \" EEPROM not present,\" : \"\",\n\t\t dev->dev_addr, irq);\n\n        if (tp->chip_id == PNIC2)\n\t\ttp->link_change = pnic2_lnk_change;\n\telse if (tp->flags & HAS_NWAY)\n\t\ttp->link_change = t21142_lnk_change;\n\telse if (tp->flags & HAS_PNICNWAY)\n\t\ttp->link_change = pnic_lnk_change;\n\n\t \n\tswitch (chip_idx) {\n\tcase DC21140:\n\tcase DM910X:\n\tdefault:\n\t\tif (tp->mtable)\n\t\t\tiowrite32(tp->mtable->csr12dir | 0x100, ioaddr + CSR12);\n\t\tbreak;\n\tcase DC21142:\n\t\tif (tp->mii_cnt  ||  tulip_media_cap[dev->if_port] & MediaIsMII) {\n\t\t\tiowrite32(csr6_mask_defstate, ioaddr + CSR6);\n\t\t\tiowrite32(0x0000, ioaddr + CSR13);\n\t\t\tiowrite32(0x0000, ioaddr + CSR14);\n\t\t\tiowrite32(csr6_mask_hdcap, ioaddr + CSR6);\n\t\t} else\n\t\t\tt21142_start_nway(dev);\n\t\tbreak;\n\tcase PNIC2:\n\t         \n\t\tiowrite32(0x0000, ioaddr + CSR13);\n\t\tiowrite32(0x0000, ioaddr + CSR14);\n\t\tbreak;\n\tcase LC82C168:\n\t\tif ( ! tp->mii_cnt) {\n\t\t\ttp->nway = 1;\n\t\t\ttp->nwayset = 0;\n\t\t\tiowrite32(csr6_ttm | csr6_ca, ioaddr + CSR6);\n\t\t\tiowrite32(0x30, ioaddr + CSR12);\n\t\t\tiowrite32(0x0001F078, ioaddr + CSR6);\n\t\t\tiowrite32(0x0201F078, ioaddr + CSR6);  \n\t\t}\n\t\tbreak;\n\tcase MX98713:\n\tcase COMPEX9881:\n\t\tiowrite32(0x00000000, ioaddr + CSR6);\n\t\tiowrite32(0x000711C0, ioaddr + CSR14);  \n\t\tiowrite32(0x00000001, ioaddr + CSR13);\n\t\tbreak;\n\tcase MX98715:\n\tcase MX98725:\n\t\tiowrite32(0x01a80000, ioaddr + CSR6);\n\t\tiowrite32(0xFFFFFFFF, ioaddr + CSR14);\n\t\tiowrite32(0x00001000, ioaddr + CSR12);\n\t\tbreak;\n\tcase COMET:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\ttulip_set_power_state (tp, 0, 1);\n\n\treturn 0;\n}\n\n\n \nstatic void tulip_set_wolopts (struct pci_dev *pdev, u32 wolopts)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\n\tif (tp->flags & COMET_PM) {\n\t\tunsigned int tmp;\n\n\t\ttmp = ioread32(ioaddr + CSR18);\n\t\ttmp &= ~(comet_csr18_pmes_sticky | comet_csr18_apm_mode | comet_csr18_d3a);\n\t\ttmp |= comet_csr18_pm_mode;\n\t\tiowrite32(tmp, ioaddr + CSR18);\n\n\t\t \n\t\ttmp = ioread32(ioaddr + CSR13);\n\t\ttmp &= ~(comet_csr13_linkoffe | comet_csr13_linkone | comet_csr13_wfre | comet_csr13_lsce | comet_csr13_mpre);\n\t\tif (wolopts & WAKE_MAGIC)\n\t\t\ttmp |= comet_csr13_mpre;\n\t\tif (wolopts & WAKE_PHY)\n\t\t\ttmp |= comet_csr13_linkoffe | comet_csr13_linkone | comet_csr13_lsce;\n\t\t \n\t\ttmp |= comet_csr13_wfr | comet_csr13_mpr | comet_csr13_lsc;\n\t\tiowrite32(tmp, ioaddr + CSR13);\n\t}\n}\n\nstatic int __maybe_unused tulip_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct tulip_private *tp = netdev_priv(dev);\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tif (!netif_running(dev))\n\t\tgoto save_state;\n\n\ttulip_down(dev);\n\n\tnetif_device_detach(dev);\n\t \n\tfree_irq(tp->pdev->irq, dev);\n\nsave_state:\n\ttulip_set_wolopts(to_pci_dev(dev_d), tp->wolinfo.wolopts);\n\tdevice_set_wakeup_enable(dev_d, !!tp->wolinfo.wolopts);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tulip_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tunsigned int tmp;\n\tint retval = 0;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tretval = request_irq(pdev->irq, tulip_interrupt, IRQF_SHARED,\n\t\t\t     dev->name, dev);\n\tif (retval) {\n\t\tpr_err(\"request_irq failed in resume\\n\");\n\t\treturn retval;\n\t}\n\n\tif (tp->flags & COMET_PM) {\n\t\tdevice_set_wakeup_enable(dev_d, 0);\n\n\t\t \n\t\ttmp = ioread32(ioaddr + CSR20);\n\t\ttmp |= comet_csr20_pmes;\n\t\tiowrite32(tmp, ioaddr + CSR20);\n\n\t\t \n\t\ttulip_set_wolopts(pdev, 0);\n\t}\n\tnetif_device_attach(dev);\n\n\tif (netif_running(dev))\n\t\ttulip_up(dev);\n\n\treturn 0;\n}\n\nstatic void tulip_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata (pdev);\n\n\tif (!dev)\n\t\treturn;\n\n\tunregister_netdev(dev);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \n\nstatic void poll_tulip (struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tconst int irq = tp->pdev->irq;\n\n\t \n\tdisable_irq(irq);\n\ttulip_interrupt (irq, dev);\n\tenable_irq(irq);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tulip_pm_ops, tulip_suspend, tulip_resume);\n\nstatic struct pci_driver tulip_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= tulip_pci_tbl,\n\t.probe\t\t= tulip_init_one,\n\t.remove\t\t= tulip_remove_one,\n\t.driver.pm\t= &tulip_pm_ops,\n};\n\n\nstatic int __init tulip_init (void)\n{\n\tif (!csr0) {\n\t\tpr_warn(\"tulip: unknown CPU architecture, using default csr0\\n\");\n\t\t \n\t\tcsr0 = 0x00A00000 | 0x4800;\n\t}\n\n\t \n\ttulip_rx_copybreak = rx_copybreak;\n\ttulip_max_interrupt_work = max_interrupt_work;\n\n\t \n\treturn pci_register_driver(&tulip_driver);\n}\n\n\nstatic void __exit tulip_cleanup (void)\n{\n\tpci_unregister_driver (&tulip_driver);\n}\n\n\nmodule_init(tulip_init);\nmodule_exit(tulip_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}