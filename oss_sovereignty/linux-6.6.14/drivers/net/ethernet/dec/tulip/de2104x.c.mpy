{
  "module_name": "de2104x.c",
  "hash_id": "11bd967fc52a7c4c5047f75bb0dde7ca698fa47af1880dc04be2efa2af7efa39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/de2104x.c",
  "human_readable_source": " \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\t\"de2104x\"\n#define DRV_RELDATE\t\t\"Mar 17, 2004\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/compiler.h>\n#include <linux/rtnetlink.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\nMODULE_AUTHOR(\"Jeff Garzik <jgarzik@pobox.com>\");\nMODULE_DESCRIPTION(\"Intel/Digital 21040/1 series PCI Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug = -1;\nmodule_param (debug, int, 0);\nMODULE_PARM_DESC (debug, \"de2104x bitmapped message enable number\");\n\n \n#if defined(__alpha__) || defined(__arm__) || defined(__hppa__) || \\\n        defined(CONFIG_SPARC) || defined(__ia64__) ||\t\t   \\\n        defined(__sh__) || defined(__mips__)\nstatic int rx_copybreak = 1518;\n#else\nstatic int rx_copybreak = 100;\n#endif\nmodule_param (rx_copybreak, int, 0);\nMODULE_PARM_DESC (rx_copybreak, \"de2104x Breakpoint at which Rx packets are copied\");\n\n#define DE_DEF_MSG_ENABLE\t(NETIF_MSG_DRV\t\t| \\\n\t\t\t\t NETIF_MSG_PROBE \t| \\\n\t\t\t\t NETIF_MSG_LINK\t\t| \\\n\t\t\t\t NETIF_MSG_IFDOWN\t| \\\n\t\t\t\t NETIF_MSG_IFUP\t\t| \\\n\t\t\t\t NETIF_MSG_RX_ERR\t| \\\n\t\t\t\t NETIF_MSG_TX_ERR)\n\n \n#ifndef CONFIG_DE2104X_DSL\n#define DSL\t\t\t0\n#else\n#define DSL\t\t\tCONFIG_DE2104X_DSL\n#endif\n\n#define DE_RX_RING_SIZE\t\t128\n#define DE_TX_RING_SIZE\t\t64\n#define DE_RING_BYTES\t\t\\\n\t\t((sizeof(struct de_desc) * DE_RX_RING_SIZE) +\t\\\n\t\t(sizeof(struct de_desc) * DE_TX_RING_SIZE))\n#define NEXT_TX(N)\t\t(((N) + 1) & (DE_TX_RING_SIZE - 1))\n#define NEXT_RX(N)\t\t(((N) + 1) & (DE_RX_RING_SIZE - 1))\n#define TX_BUFFS_AVAIL(CP)\t\t\t\t\t\\\n\t(((CP)->tx_tail <= (CP)->tx_head) ?\t\t\t\\\n\t  (CP)->tx_tail + (DE_TX_RING_SIZE - 1) - (CP)->tx_head :\t\\\n\t  (CP)->tx_tail - (CP)->tx_head - 1)\n\n#define PKT_BUF_SZ\t\t1536\t \n#define RX_OFFSET\t\t2\n\n#define DE_SETUP_SKB\t\t((struct sk_buff *) 1)\n#define DE_DUMMY_SKB\t\t((struct sk_buff *) 2)\n#define DE_SETUP_FRAME_WORDS\t96\n#define DE_EEPROM_WORDS\t\t256\n#define DE_EEPROM_SIZE\t\t(DE_EEPROM_WORDS * sizeof(u16))\n#define DE_MAX_MEDIA\t\t5\n\n#define DE_MEDIA_TP_AUTO\t0\n#define DE_MEDIA_BNC\t\t1\n#define DE_MEDIA_AUI\t\t2\n#define DE_MEDIA_TP\t\t3\n#define DE_MEDIA_TP_FD\t\t4\n#define DE_MEDIA_INVALID\tDE_MAX_MEDIA\n#define DE_MEDIA_FIRST\t\t0\n#define DE_MEDIA_LAST\t\t(DE_MAX_MEDIA - 1)\n#define DE_AUI_BNC\t\t(SUPPORTED_AUI | SUPPORTED_BNC)\n\n#define DE_TIMER_LINK\t\t(60 * HZ)\n#define DE_TIMER_NO_LINK\t(5 * HZ)\n\n#define DE_NUM_REGS\t\t16\n#define DE_REGS_SIZE\t\t(DE_NUM_REGS * sizeof(u32))\n#define DE_REGS_VER\t\t1\n\n \n#define TX_TIMEOUT\t\t(6*HZ)\n\n \n#define FULL_DUPLEX_MAGIC\t0x6969\n\nenum {\n\t \n\tBusMode\t\t\t= 0x00,\n\tTxPoll\t\t\t= 0x08,\n\tRxPoll\t\t\t= 0x10,\n\tRxRingAddr\t\t= 0x18,\n\tTxRingAddr\t\t= 0x20,\n\tMacStatus\t\t= 0x28,\n\tMacMode\t\t\t= 0x30,\n\tIntrMask\t\t= 0x38,\n\tRxMissed\t\t= 0x40,\n\tROMCmd\t\t\t= 0x48,\n\tCSR11\t\t\t= 0x58,\n\tSIAStatus\t\t= 0x60,\n\tCSR13\t\t\t= 0x68,\n\tCSR14\t\t\t= 0x70,\n\tCSR15\t\t\t= 0x78,\n\tPCIPM\t\t\t= 0x40,\n\n\t \n\tCmdReset\t\t= (1 << 0),\n\tCacheAlign16\t\t= 0x00008000,\n\tBurstLen4\t\t= 0x00000400,\n\tDescSkipLen\t\t= (DSL << 2),\n\n\t \n\tNormalTxPoll\t\t= (1 << 0),\n\tNormalRxPoll\t\t= (1 << 0),\n\n\t \n\tDescOwn\t\t\t= (1 << 31),\n\tRxError\t\t\t= (1 << 15),\n\tRxErrLong\t\t= (1 << 7),\n\tRxErrCRC\t\t= (1 << 1),\n\tRxErrFIFO\t\t= (1 << 0),\n\tRxErrRunt\t\t= (1 << 11),\n\tRxErrFrame\t\t= (1 << 14),\n\tRingEnd\t\t\t= (1 << 25),\n\tFirstFrag\t\t= (1 << 29),\n\tLastFrag\t\t= (1 << 30),\n\tTxError\t\t\t= (1 << 15),\n\tTxFIFOUnder\t\t= (1 << 1),\n\tTxLinkFail\t\t= (1 << 2) | (1 << 10) | (1 << 11),\n\tTxMaxCol\t\t= (1 << 8),\n\tTxOWC\t\t\t= (1 << 9),\n\tTxJabber\t\t= (1 << 14),\n\tSetupFrame\t\t= (1 << 27),\n\tTxSwInt\t\t\t= (1 << 31),\n\n\t \n\tIntrOK\t\t\t= (1 << 16),\n\tIntrErr\t\t\t= (1 << 15),\n\tRxIntr\t\t\t= (1 << 6),\n\tRxEmpty\t\t\t= (1 << 7),\n\tTxIntr\t\t\t= (1 << 0),\n\tTxEmpty\t\t\t= (1 << 2),\n\tPciErr\t\t\t= (1 << 13),\n\tTxState\t\t\t= (1 << 22) | (1 << 21) | (1 << 20),\n\tRxState\t\t\t= (1 << 19) | (1 << 18) | (1 << 17),\n\tLinkFail\t\t= (1 << 12),\n\tLinkPass\t\t= (1 << 4),\n\tRxStopped\t\t= (1 << 8),\n\tTxStopped\t\t= (1 << 1),\n\n\t \n\tTxEnable\t\t= (1 << 13),\n\tRxEnable\t\t= (1 << 1),\n\tRxTx\t\t\t= TxEnable | RxEnable,\n\tFullDuplex\t\t= (1 << 9),\n\tAcceptAllMulticast\t= (1 << 7),\n\tAcceptAllPhys\t\t= (1 << 6),\n\tBOCnt\t\t\t= (1 << 5),\n\tMacModeClear\t\t= (1<<12) | (1<<11) | (1<<10) | (1<<8) | (1<<3) |\n\t\t\t\t  RxTx | BOCnt | AcceptAllPhys | AcceptAllMulticast,\n\n\t \n\tEE_SHIFT_CLK\t\t= 0x02,\t \n\tEE_CS\t\t\t= 0x01,\t \n\tEE_DATA_WRITE\t\t= 0x04,\t \n\tEE_WRITE_0\t\t= 0x01,\n\tEE_WRITE_1\t\t= 0x05,\n\tEE_DATA_READ\t\t= 0x08,\t \n\tEE_ENB\t\t\t= (0x4800 | EE_CS),\n\n\t \n\tEE_READ_CMD\t\t= 6,\n\n\t \n\tRxMissedOver\t\t= (1 << 16),\n\tRxMissedMask\t\t= 0xffff,\n\n\t \n\tSROMC0InfoLeaf\t\t= 27,\n\tMediaBlockMask\t\t= 0x3f,\n\tMediaCustomCSRs\t\t= (1 << 6),\n\n\t \n\tPM_Sleep\t\t= (1 << 31),\n\tPM_Snooze\t\t= (1 << 30),\n\tPM_Mask\t\t\t= PM_Sleep | PM_Snooze,\n\n\t \n\tNWayState\t\t= (1 << 14) | (1 << 13) | (1 << 12),\n\tNWayRestart\t\t= (1 << 12),\n\tNonselPortActive\t= (1 << 9),\n\tSelPortActive\t\t= (1 << 8),\n\tLinkFailStatus\t\t= (1 << 2),\n\tNetCxnErr\t\t= (1 << 1),\n};\n\nstatic const u32 de_intr_mask =\n\tIntrOK | IntrErr | RxIntr | RxEmpty | TxIntr | TxEmpty |\n\tLinkPass | LinkFail | PciErr;\n\n \nstatic const u32 de_bus_mode = CacheAlign16 | BurstLen4 | DescSkipLen;\n\nstruct de_srom_media_block {\n\tu8\t\t\topts;\n\tu16\t\t\tcsr13;\n\tu16\t\t\tcsr14;\n\tu16\t\t\tcsr15;\n} __packed;\n\nstruct de_srom_info_leaf {\n\tu16\t\t\tdefault_media;\n\tu8\t\t\tn_blocks;\n\tu8\t\t\tunused;\n} __packed;\n\nstruct de_desc {\n\t__le32\t\t\topts1;\n\t__le32\t\t\topts2;\n\t__le32\t\t\taddr1;\n\t__le32\t\t\taddr2;\n#if DSL\n\t__le32\t\t\tskip[DSL];\n#endif\n};\n\nstruct media_info {\n\tu16\t\t\ttype;\t \n\tu16\t\t\tcsr13;\n\tu16\t\t\tcsr14;\n\tu16\t\t\tcsr15;\n};\n\nstruct ring_info {\n\tstruct sk_buff\t\t*skb;\n\tdma_addr_t\t\tmapping;\n};\n\nstruct de_private {\n\tunsigned\t\ttx_head;\n\tunsigned\t\ttx_tail;\n\tunsigned\t\trx_tail;\n\n\tvoid\t\t\t__iomem *regs;\n\tstruct net_device\t*dev;\n\tspinlock_t\t\tlock;\n\n\tstruct de_desc\t\t*rx_ring;\n\tstruct de_desc\t\t*tx_ring;\n\tstruct ring_info\ttx_skb[DE_TX_RING_SIZE];\n\tstruct ring_info\trx_skb[DE_RX_RING_SIZE];\n\tunsigned\t\trx_buf_sz;\n\tdma_addr_t\t\tring_dma;\n\n\tu32\t\t\tmsg_enable;\n\n\tstruct pci_dev\t\t*pdev;\n\n\tu16\t\t\tsetup_frame[DE_SETUP_FRAME_WORDS];\n\n\tu32\t\t\tmedia_type;\n\tu32\t\t\tmedia_supported;\n\tu32\t\t\tmedia_advertise;\n\tstruct media_info\tmedia[DE_MAX_MEDIA];\n\tstruct timer_list\tmedia_timer;\n\n\tu8\t\t\t*ee_data;\n\tunsigned\t\tboard_idx;\n\tunsigned\t\tde21040 : 1;\n\tunsigned\t\tmedia_lock : 1;\n};\n\n\nstatic void de_set_rx_mode (struct net_device *dev);\nstatic void de_tx (struct de_private *de);\nstatic void de_clean_rings (struct de_private *de);\nstatic void de_media_interrupt (struct de_private *de, u32 status);\nstatic void de21040_media_timer (struct timer_list *t);\nstatic void de21041_media_timer (struct timer_list *t);\nstatic unsigned int de_ok_to_advertise (struct de_private *de, u32 new_media);\n\n\nstatic const struct pci_device_id de_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_TULIP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_TULIP_PLUS,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pci, de_pci_tbl);\n\nstatic const char * const media_name[DE_MAX_MEDIA] = {\n\t\"10baseT auto\",\n\t\"BNC\",\n\t\"AUI\",\n\t\"10baseT-HD\",\n\t\"10baseT-FD\"\n};\n\n \nstatic u16 t21040_csr13[] = { 0, 0, 0x8F09, 0x8F01, 0x8F01, };\nstatic u16 t21040_csr14[] = { 0, 0, 0x0705, 0xFFFF, 0xFFFD, };\nstatic u16 t21040_csr15[] = { 0, 0, 0x0006, 0x0000, 0x0000, };\n\n \nstatic u16 t21041_csr13[] = { 0xEF01, 0xEF09, 0xEF09, 0xEF01, 0xEF09, };\nstatic u16 t21041_csr14[] = { 0xFFFF, 0xF7FD, 0xF7FD, 0x7F3F, 0x7F3D, };\n \nstatic u16 t21041_csr14_brk[] = { 0xFF3F, 0xF7FD, 0xF7FD, 0x7F3F, 0x7F3D, };\nstatic u16 t21041_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };\n\n\n#define dr32(reg)\tioread32(de->regs + (reg))\n#define dw32(reg, val)\tiowrite32((val), de->regs + (reg))\n\n\nstatic void de_rx_err_acct (struct de_private *de, unsigned rx_tail,\n\t\t\t    u32 status, u32 len)\n{\n\tnetif_dbg(de, rx_err, de->dev,\n\t\t  \"rx err, slot %d status 0x%x len %d\\n\",\n\t\t  rx_tail, status, len);\n\n\tif ((status & 0x38000300) != 0x0300) {\n\t\t \n\t\tif ((status & 0xffff) != 0x7fff) {\n\t\t\tnetif_warn(de, rx_err, de->dev,\n\t\t\t\t   \"Oversized Ethernet frame spanned multiple buffers, status %08x!\\n\",\n\t\t\t\t   status);\n\t\t\tde->dev->stats.rx_length_errors++;\n\t\t}\n\t} else if (status & RxError) {\n\t\t \n\t\tde->dev->stats.rx_errors++;  \n\t\tif (status & 0x0890) de->dev->stats.rx_length_errors++;\n\t\tif (status & RxErrCRC) de->dev->stats.rx_crc_errors++;\n\t\tif (status & RxErrFIFO) de->dev->stats.rx_fifo_errors++;\n\t}\n}\n\nstatic void de_rx (struct de_private *de)\n{\n\tunsigned rx_tail = de->rx_tail;\n\tunsigned rx_work = DE_RX_RING_SIZE;\n\tunsigned drop = 0;\n\tint rc;\n\n\twhile (--rx_work) {\n\t\tu32 status, len;\n\t\tdma_addr_t mapping;\n\t\tstruct sk_buff *skb, *copy_skb;\n\t\tunsigned copying_skb, buflen;\n\n\t\tskb = de->rx_skb[rx_tail].skb;\n\t\tBUG_ON(!skb);\n\t\trmb();\n\t\tstatus = le32_to_cpu(de->rx_ring[rx_tail].opts1);\n\t\tif (status & DescOwn)\n\t\t\tbreak;\n\n\t\t \n\t\tlen = ((status >> 16) & 0x7fff) - 4;\n\t\tmapping = de->rx_skb[rx_tail].mapping;\n\n\t\tif (unlikely(drop)) {\n\t\t\tde->dev->stats.rx_dropped++;\n\t\t\tgoto rx_next;\n\t\t}\n\n\t\tif (unlikely((status & 0x38008300) != 0x0300)) {\n\t\t\tde_rx_err_acct(de, rx_tail, status, len);\n\t\t\tgoto rx_next;\n\t\t}\n\n\t\tcopying_skb = (len <= rx_copybreak);\n\n\t\tnetif_dbg(de, rx_status, de->dev,\n\t\t\t  \"rx slot %d status 0x%x len %d copying? %d\\n\",\n\t\t\t  rx_tail, status, len, copying_skb);\n\n\t\tbuflen = copying_skb ? (len + RX_OFFSET) : de->rx_buf_sz;\n\t\tcopy_skb = netdev_alloc_skb(de->dev, buflen);\n\t\tif (unlikely(!copy_skb)) {\n\t\t\tde->dev->stats.rx_dropped++;\n\t\t\tdrop = 1;\n\t\t\trx_work = 100;\n\t\t\tgoto rx_next;\n\t\t}\n\n\t\tif (!copying_skb) {\n\t\t\tdma_unmap_single(&de->pdev->dev, mapping, buflen,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tskb_put(skb, len);\n\n\t\t\tmapping =\n\t\t\tde->rx_skb[rx_tail].mapping =\n\t\t\t\tdma_map_single(&de->pdev->dev, copy_skb->data,\n\t\t\t\t\t       buflen, DMA_FROM_DEVICE);\n\t\t\tde->rx_skb[rx_tail].skb = copy_skb;\n\t\t} else {\n\t\t\tdma_sync_single_for_cpu(&de->pdev->dev, mapping, len,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tskb_reserve(copy_skb, RX_OFFSET);\n\t\t\tskb_copy_from_linear_data(skb, skb_put(copy_skb, len),\n\t\t\t\t\t\t  len);\n\t\t\tdma_sync_single_for_device(&de->pdev->dev, mapping,\n\t\t\t\t\t\t   len, DMA_FROM_DEVICE);\n\n\t\t\t \n\t\t\tskb = copy_skb;\n\t\t}\n\n\t\tskb->protocol = eth_type_trans (skb, de->dev);\n\n\t\tde->dev->stats.rx_packets++;\n\t\tde->dev->stats.rx_bytes += skb->len;\n\t\trc = netif_rx (skb);\n\t\tif (rc == NET_RX_DROP)\n\t\t\tdrop = 1;\n\nrx_next:\n\t\tif (rx_tail == (DE_RX_RING_SIZE - 1))\n\t\t\tde->rx_ring[rx_tail].opts2 =\n\t\t\t\tcpu_to_le32(RingEnd | de->rx_buf_sz);\n\t\telse\n\t\t\tde->rx_ring[rx_tail].opts2 = cpu_to_le32(de->rx_buf_sz);\n\t\tde->rx_ring[rx_tail].addr1 = cpu_to_le32(mapping);\n\t\twmb();\n\t\tde->rx_ring[rx_tail].opts1 = cpu_to_le32(DescOwn);\n\t\trx_tail = NEXT_RX(rx_tail);\n\t}\n\n\tif (!rx_work)\n\t\tnetdev_warn(de->dev, \"rx work limit reached\\n\");\n\n\tde->rx_tail = rx_tail;\n}\n\nstatic irqreturn_t de_interrupt (int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct de_private *de = netdev_priv(dev);\n\tu32 status;\n\n\tstatus = dr32(MacStatus);\n\tif ((!(status & (IntrOK|IntrErr))) || (status == 0xFFFF))\n\t\treturn IRQ_NONE;\n\n\tnetif_dbg(de, intr, dev, \"intr, status %08x mode %08x desc %u/%u/%u\\n\",\n\t\t  status, dr32(MacMode),\n\t\t  de->rx_tail, de->tx_head, de->tx_tail);\n\n\tdw32(MacStatus, status);\n\n\tif (status & (RxIntr | RxEmpty)) {\n\t\tde_rx(de);\n\t\tif (status & RxEmpty)\n\t\t\tdw32(RxPoll, NormalRxPoll);\n\t}\n\n\tspin_lock(&de->lock);\n\n\tif (status & (TxIntr | TxEmpty))\n\t\tde_tx(de);\n\n\tif (status & (LinkPass | LinkFail))\n\t\tde_media_interrupt(de, status);\n\n\tspin_unlock(&de->lock);\n\n\tif (status & PciErr) {\n\t\tu16 pci_status;\n\n\t\tpci_read_config_word(de->pdev, PCI_STATUS, &pci_status);\n\t\tpci_write_config_word(de->pdev, PCI_STATUS, pci_status);\n\t\tnetdev_err(de->dev,\n\t\t\t   \"PCI bus error, status=%08x, PCI status=%04x\\n\",\n\t\t\t   status, pci_status);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void de_tx (struct de_private *de)\n{\n\tunsigned tx_head = de->tx_head;\n\tunsigned tx_tail = de->tx_tail;\n\n\twhile (tx_tail != tx_head) {\n\t\tstruct sk_buff *skb;\n\t\tu32 status;\n\n\t\trmb();\n\t\tstatus = le32_to_cpu(de->tx_ring[tx_tail].opts1);\n\t\tif (status & DescOwn)\n\t\t\tbreak;\n\n\t\tskb = de->tx_skb[tx_tail].skb;\n\t\tBUG_ON(!skb);\n\t\tif (unlikely(skb == DE_DUMMY_SKB))\n\t\t\tgoto next;\n\n\t\tif (unlikely(skb == DE_SETUP_SKB)) {\n\t\t\tdma_unmap_single(&de->pdev->dev,\n\t\t\t\t\t de->tx_skb[tx_tail].mapping,\n\t\t\t\t\t sizeof(de->setup_frame),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tgoto next;\n\t\t}\n\n\t\tdma_unmap_single(&de->pdev->dev, de->tx_skb[tx_tail].mapping,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\t\tif (status & LastFrag) {\n\t\t\tif (status & TxError) {\n\t\t\t\tnetif_dbg(de, tx_err, de->dev,\n\t\t\t\t\t  \"tx err, status 0x%x\\n\",\n\t\t\t\t\t  status);\n\t\t\t\tde->dev->stats.tx_errors++;\n\t\t\t\tif (status & TxOWC)\n\t\t\t\t\tde->dev->stats.tx_window_errors++;\n\t\t\t\tif (status & TxMaxCol)\n\t\t\t\t\tde->dev->stats.tx_aborted_errors++;\n\t\t\t\tif (status & TxLinkFail)\n\t\t\t\t\tde->dev->stats.tx_carrier_errors++;\n\t\t\t\tif (status & TxFIFOUnder)\n\t\t\t\t\tde->dev->stats.tx_fifo_errors++;\n\t\t\t} else {\n\t\t\t\tde->dev->stats.tx_packets++;\n\t\t\t\tde->dev->stats.tx_bytes += skb->len;\n\t\t\t\tnetif_dbg(de, tx_done, de->dev,\n\t\t\t\t\t  \"tx done, slot %d\\n\", tx_tail);\n\t\t\t}\n\t\t\tdev_consume_skb_irq(skb);\n\t\t}\n\nnext:\n\t\tde->tx_skb[tx_tail].skb = NULL;\n\n\t\ttx_tail = NEXT_TX(tx_tail);\n\t}\n\n\tde->tx_tail = tx_tail;\n\n\tif (netif_queue_stopped(de->dev) && (TX_BUFFS_AVAIL(de) > (DE_TX_RING_SIZE / 4)))\n\t\tnetif_wake_queue(de->dev);\n}\n\nstatic netdev_tx_t de_start_xmit (struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tunsigned int entry, tx_free;\n\tu32 mapping, len, flags = FirstFrag | LastFrag;\n\tstruct de_desc *txd;\n\n\tspin_lock_irq(&de->lock);\n\n\ttx_free = TX_BUFFS_AVAIL(de);\n\tif (tx_free == 0) {\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock_irq(&de->lock);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\ttx_free--;\n\n\tentry = de->tx_head;\n\n\ttxd = &de->tx_ring[entry];\n\n\tlen = skb->len;\n\tmapping = dma_map_single(&de->pdev->dev, skb->data, len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (entry == (DE_TX_RING_SIZE - 1))\n\t\tflags |= RingEnd;\n\tif (!tx_free || (tx_free == (DE_TX_RING_SIZE / 2)))\n\t\tflags |= TxSwInt;\n\tflags |= len;\n\ttxd->opts2 = cpu_to_le32(flags);\n\ttxd->addr1 = cpu_to_le32(mapping);\n\n\tde->tx_skb[entry].skb = skb;\n\tde->tx_skb[entry].mapping = mapping;\n\twmb();\n\n\ttxd->opts1 = cpu_to_le32(DescOwn);\n\twmb();\n\n\tde->tx_head = NEXT_TX(entry);\n\tnetif_dbg(de, tx_queued, dev, \"tx queued, slot %d, skblen %d\\n\",\n\t\t  entry, skb->len);\n\n\tif (tx_free == 0)\n\t\tnetif_stop_queue(dev);\n\n\tspin_unlock_irq(&de->lock);\n\n\t \n\tdw32(TxPoll, NormalTxPoll);\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic void build_setup_frame_hash(u16 *setup_frm, struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tu16 hash_table[32];\n\tstruct netdev_hw_addr *ha;\n\tconst u16 *eaddrs;\n\tint i;\n\n\tmemset(hash_table, 0, sizeof(hash_table));\n\t__set_bit_le(255, hash_table);\t\t\t \n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tint index = ether_crc_le(ETH_ALEN, ha->addr) & 0x1ff;\n\n\t\t__set_bit_le(index, hash_table);\n\t}\n\n\tfor (i = 0; i < 32; i++) {\n\t\t*setup_frm++ = hash_table[i];\n\t\t*setup_frm++ = hash_table[i];\n\t}\n\tsetup_frm = &de->setup_frame[13*6];\n\n\t \n\teaddrs = (const u16 *)dev->dev_addr;\n\t*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\n\t*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\n\t*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\n}\n\nstatic void build_setup_frame_perfect(u16 *setup_frm, struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tconst u16 *eaddrs;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\teaddrs = (u16 *) ha->addr;\n\t\t*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\n\t\t*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\n\t\t*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\n\t}\n\t \n\tmemset(setup_frm, 0xff, (15 - netdev_mc_count(dev)) * 12);\n\tsetup_frm = &de->setup_frame[15*6];\n\n\t \n\teaddrs = (const u16 *)dev->dev_addr;\n\t*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\n\t*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\n\t*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\n}\n\n\nstatic void __de_set_rx_mode (struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tu32 macmode;\n\tunsigned int entry;\n\tu32 mapping;\n\tstruct de_desc *txd;\n\tstruct de_desc *dummy_txd = NULL;\n\n\tmacmode = dr32(MacMode) & ~(AcceptAllMulticast | AcceptAllPhys);\n\n\tif (dev->flags & IFF_PROMISC) {\t \n\t\tmacmode |= AcceptAllMulticast | AcceptAllPhys;\n\t\tgoto out;\n\t}\n\n\tif ((netdev_mc_count(dev) > 1000) || (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\tmacmode |= AcceptAllMulticast;\n\t\tgoto out;\n\t}\n\n\t \n\tif (netdev_mc_count(dev) > 14)\t \n\t\tbuild_setup_frame_hash (de->setup_frame, dev);\n\telse\n\t\tbuild_setup_frame_perfect (de->setup_frame, dev);\n\n\t \n\n\tentry = de->tx_head;\n\n\t \n\tif (entry != 0) {\n\t\tde->tx_skb[entry].skb = DE_DUMMY_SKB;\n\n\t\tdummy_txd = &de->tx_ring[entry];\n\t\tdummy_txd->opts2 = (entry == (DE_TX_RING_SIZE - 1)) ?\n\t\t\t\t   cpu_to_le32(RingEnd) : 0;\n\t\tdummy_txd->addr1 = 0;\n\n\t\t \n\n\t\tentry = NEXT_TX(entry);\n\t}\n\n\tde->tx_skb[entry].skb = DE_SETUP_SKB;\n\tde->tx_skb[entry].mapping = mapping =\n\t    dma_map_single(&de->pdev->dev, de->setup_frame,\n\t\t\t   sizeof(de->setup_frame), DMA_TO_DEVICE);\n\n\t \n\ttxd = &de->tx_ring[entry];\n\tif (entry == (DE_TX_RING_SIZE - 1))\n\t\ttxd->opts2 = cpu_to_le32(SetupFrame | RingEnd | sizeof (de->setup_frame));\n\telse\n\t\ttxd->opts2 = cpu_to_le32(SetupFrame | sizeof (de->setup_frame));\n\ttxd->addr1 = cpu_to_le32(mapping);\n\twmb();\n\n\ttxd->opts1 = cpu_to_le32(DescOwn);\n\twmb();\n\n\tif (dummy_txd) {\n\t\tdummy_txd->opts1 = cpu_to_le32(DescOwn);\n\t\twmb();\n\t}\n\n\tde->tx_head = NEXT_TX(entry);\n\n\tif (TX_BUFFS_AVAIL(de) == 0)\n\t\tnetif_stop_queue(dev);\n\n\t \n\tdw32(TxPoll, NormalTxPoll);\n\nout:\n\tif (macmode != dr32(MacMode))\n\t\tdw32(MacMode, macmode);\n}\n\nstatic void de_set_rx_mode (struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct de_private *de = netdev_priv(dev);\n\n\tspin_lock_irqsave (&de->lock, flags);\n\t__de_set_rx_mode(dev);\n\tspin_unlock_irqrestore (&de->lock, flags);\n}\n\nstatic inline void de_rx_missed(struct de_private *de, u32 rx_missed)\n{\n\tif (unlikely(rx_missed & RxMissedOver))\n\t\tde->dev->stats.rx_missed_errors += RxMissedMask;\n\telse\n\t\tde->dev->stats.rx_missed_errors += (rx_missed & RxMissedMask);\n}\n\nstatic void __de_get_stats(struct de_private *de)\n{\n\tu32 tmp = dr32(RxMissed);  \n\n\tde_rx_missed(de, tmp);\n}\n\nstatic struct net_device_stats *de_get_stats(struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\n\t \n\tspin_lock_irq(&de->lock);\n\tif (netif_running(dev) && netif_device_present(dev))\n\t\t__de_get_stats(de);\n\tspin_unlock_irq(&de->lock);\n\n\treturn &dev->stats;\n}\n\nstatic inline int de_is_running (struct de_private *de)\n{\n\treturn (dr32(MacStatus) & (RxState | TxState)) ? 1 : 0;\n}\n\nstatic void de_stop_rxtx (struct de_private *de)\n{\n\tu32 macmode;\n\tunsigned int i = 1300/100;\n\n\tmacmode = dr32(MacMode);\n\tif (macmode & RxTx) {\n\t\tdw32(MacMode, macmode & ~RxTx);\n\t\tdr32(MacMode);\n\t}\n\n\t \n\twhile (--i) {\n\t\tif (!de_is_running(de))\n\t\t\treturn;\n\t\tudelay(100);\n\t}\n\n\tnetdev_warn(de->dev, \"timeout expired, stopping DMA\\n\");\n}\n\nstatic inline void de_start_rxtx (struct de_private *de)\n{\n\tu32 macmode;\n\n\tmacmode = dr32(MacMode);\n\tif ((macmode & RxTx) != RxTx) {\n\t\tdw32(MacMode, macmode | RxTx);\n\t\tdr32(MacMode);\n\t}\n}\n\nstatic void de_stop_hw (struct de_private *de)\n{\n\n\tudelay(5);\n\tdw32(IntrMask, 0);\n\n\tde_stop_rxtx(de);\n\n\tdw32(MacStatus, dr32(MacStatus));\n\n\tudelay(10);\n\n\tde->rx_tail = 0;\n\tde->tx_head = de->tx_tail = 0;\n}\n\nstatic void de_link_up(struct de_private *de)\n{\n\tif (!netif_carrier_ok(de->dev)) {\n\t\tnetif_carrier_on(de->dev);\n\t\tnetif_info(de, link, de->dev, \"link up, media %s\\n\",\n\t\t\t   media_name[de->media_type]);\n\t}\n}\n\nstatic void de_link_down(struct de_private *de)\n{\n\tif (netif_carrier_ok(de->dev)) {\n\t\tnetif_carrier_off(de->dev);\n\t\tnetif_info(de, link, de->dev, \"link down\\n\");\n\t}\n}\n\nstatic void de_set_media (struct de_private *de)\n{\n\tunsigned media = de->media_type;\n\tu32 macmode = dr32(MacMode);\n\n\tif (de_is_running(de))\n\t\tnetdev_warn(de->dev, \"chip is running while changing media!\\n\");\n\n\tif (de->de21040)\n\t\tdw32(CSR11, FULL_DUPLEX_MAGIC);\n\tdw32(CSR13, 0);  \n\tdw32(CSR14, de->media[media].csr14);\n\tdw32(CSR15, de->media[media].csr15);\n\tdw32(CSR13, de->media[media].csr13);\n\n\t \n\tmdelay(10);\n\n\tif (media == DE_MEDIA_TP_FD)\n\t\tmacmode |= FullDuplex;\n\telse\n\t\tmacmode &= ~FullDuplex;\n\n\tnetif_info(de, link, de->dev, \"set link %s\\n\", media_name[media]);\n\tnetif_info(de, hw, de->dev, \"mode 0x%x, sia 0x%x,0x%x,0x%x,0x%x\\n\",\n\t\t   dr32(MacMode), dr32(SIAStatus),\n\t\t   dr32(CSR13), dr32(CSR14), dr32(CSR15));\n\tnetif_info(de, hw, de->dev, \"set mode 0x%x, set sia 0x%x,0x%x,0x%x\\n\",\n\t\t   macmode, de->media[media].csr13,\n\t\t   de->media[media].csr14, de->media[media].csr15);\n\tif (macmode != dr32(MacMode))\n\t\tdw32(MacMode, macmode);\n}\n\nstatic void de_next_media (struct de_private *de, const u32 *media,\n\t\t\t   unsigned int n_media)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_media; i++) {\n\t\tif (de_ok_to_advertise(de, media[i])) {\n\t\t\tde->media_type = media[i];\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void de21040_media_timer (struct timer_list *t)\n{\n\tstruct de_private *de = from_timer(de, t, media_timer);\n\tstruct net_device *dev = de->dev;\n\tu32 status = dr32(SIAStatus);\n\tunsigned int carrier;\n\tunsigned long flags;\n\n\tcarrier = (status & NetCxnErr) ? 0 : 1;\n\n\tif (carrier) {\n\t\tif (de->media_type != DE_MEDIA_AUI && (status & LinkFailStatus))\n\t\t\tgoto no_link_yet;\n\n\t\tde->media_timer.expires = jiffies + DE_TIMER_LINK;\n\t\tadd_timer(&de->media_timer);\n\t\tif (!netif_carrier_ok(dev))\n\t\t\tde_link_up(de);\n\t\telse\n\t\t\tnetif_info(de, timer, dev, \"%s link ok, status %x\\n\",\n\t\t\t\t   media_name[de->media_type], status);\n\t\treturn;\n\t}\n\n\tde_link_down(de);\n\n\tif (de->media_lock)\n\t\treturn;\n\n\tif (de->media_type == DE_MEDIA_AUI) {\n\t\tstatic const u32 next_state = DE_MEDIA_TP;\n\t\tde_next_media(de, &next_state, 1);\n\t} else {\n\t\tstatic const u32 next_state = DE_MEDIA_AUI;\n\t\tde_next_media(de, &next_state, 1);\n\t}\n\n\tspin_lock_irqsave(&de->lock, flags);\n\tde_stop_rxtx(de);\n\tspin_unlock_irqrestore(&de->lock, flags);\n\tde_set_media(de);\n\tde_start_rxtx(de);\n\nno_link_yet:\n\tde->media_timer.expires = jiffies + DE_TIMER_NO_LINK;\n\tadd_timer(&de->media_timer);\n\n\tnetif_info(de, timer, dev, \"no link, trying media %s, status %x\\n\",\n\t\t   media_name[de->media_type], status);\n}\n\nstatic unsigned int de_ok_to_advertise (struct de_private *de, u32 new_media)\n{\n\tswitch (new_media) {\n\tcase DE_MEDIA_TP_AUTO:\n\t\tif (!(de->media_advertise & ADVERTISED_Autoneg))\n\t\t\treturn 0;\n\t\tif (!(de->media_advertise & (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full)))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase DE_MEDIA_BNC:\n\t\tif (!(de->media_advertise & ADVERTISED_BNC))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase DE_MEDIA_AUI:\n\t\tif (!(de->media_advertise & ADVERTISED_AUI))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase DE_MEDIA_TP:\n\t\tif (!(de->media_advertise & ADVERTISED_10baseT_Half))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase DE_MEDIA_TP_FD:\n\t\tif (!(de->media_advertise & ADVERTISED_10baseT_Full))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic void de21041_media_timer (struct timer_list *t)\n{\n\tstruct de_private *de = from_timer(de, t, media_timer);\n\tstruct net_device *dev = de->dev;\n\tu32 status = dr32(SIAStatus);\n\tunsigned int carrier;\n\tunsigned long flags;\n\n\t \n\tdw32(SIAStatus, NonselPortActive | SelPortActive);\n\n\tcarrier = (status & NetCxnErr) ? 0 : 1;\n\n\tif (carrier) {\n\t\tif ((de->media_type == DE_MEDIA_TP_AUTO ||\n\t\t     de->media_type == DE_MEDIA_TP ||\n\t\t     de->media_type == DE_MEDIA_TP_FD) &&\n\t\t    (status & LinkFailStatus))\n\t\t\tgoto no_link_yet;\n\n\t\tde->media_timer.expires = jiffies + DE_TIMER_LINK;\n\t\tadd_timer(&de->media_timer);\n\t\tif (!netif_carrier_ok(dev))\n\t\t\tde_link_up(de);\n\t\telse\n\t\t\tnetif_info(de, timer, dev,\n\t\t\t\t   \"%s link ok, mode %x status %x\\n\",\n\t\t\t\t   media_name[de->media_type],\n\t\t\t\t   dr32(MacMode), status);\n\t\treturn;\n\t}\n\n\tde_link_down(de);\n\n\t \n\tif (de->media_lock)\n\t\tgoto set_media;\n\n\t \n\tif (status & NonselPortActive) {\n\t\tunsigned int have_media = 1;\n\n\t\t \n\t\tif (de->media_type == DE_MEDIA_AUI ||\n\t\t    de->media_type == DE_MEDIA_BNC) {\n\t\t\tif (de_ok_to_advertise(de, DE_MEDIA_TP_AUTO))\n\t\t\t\tde->media_type = DE_MEDIA_TP_AUTO;\n\t\t\telse\n\t\t\t\thave_media = 0;\n\t\t}\n\n\t\t \n\t\telse if (((de->media_supported & DE_AUI_BNC) == SUPPORTED_BNC) &&\n\t\t\t de_ok_to_advertise(de, DE_MEDIA_BNC))\n\t\t\tde->media_type = DE_MEDIA_BNC;\n\n\t\t \n\t\telse if (((de->media_supported & DE_AUI_BNC) == SUPPORTED_AUI) &&\n\t\t\t de_ok_to_advertise(de, DE_MEDIA_AUI))\n\t\t\tde->media_type = DE_MEDIA_AUI;\n\n\t\t \n\t\telse\n\t\t\thave_media = 0;\n\n\t\tif (have_media)\n\t\t\tgoto set_media;\n\t}\n\n\t \n\tif (de->media_type == DE_MEDIA_AUI) {\n\t\tstatic const u32 next_states[] = {\n\t\t\tDE_MEDIA_BNC, DE_MEDIA_TP_AUTO\n\t\t};\n\t\tde_next_media(de, next_states, ARRAY_SIZE(next_states));\n\t} else if (de->media_type == DE_MEDIA_BNC) {\n\t\tstatic const u32 next_states[] = {\n\t\t\tDE_MEDIA_TP_AUTO, DE_MEDIA_AUI\n\t\t};\n\t\tde_next_media(de, next_states, ARRAY_SIZE(next_states));\n\t} else {\n\t\tstatic const u32 next_states[] = {\n\t\t\tDE_MEDIA_AUI, DE_MEDIA_BNC, DE_MEDIA_TP_AUTO\n\t\t};\n\t\tde_next_media(de, next_states, ARRAY_SIZE(next_states));\n\t}\n\nset_media:\n\tspin_lock_irqsave(&de->lock, flags);\n\tde_stop_rxtx(de);\n\tspin_unlock_irqrestore(&de->lock, flags);\n\tde_set_media(de);\n\tde_start_rxtx(de);\n\nno_link_yet:\n\tde->media_timer.expires = jiffies + DE_TIMER_NO_LINK;\n\tadd_timer(&de->media_timer);\n\n\tnetif_info(de, timer, dev, \"no link, trying media %s, status %x\\n\",\n\t\t   media_name[de->media_type], status);\n}\n\nstatic void de_media_interrupt (struct de_private *de, u32 status)\n{\n\tif (status & LinkPass) {\n\t\t \n\t\tif ((de->media_type == DE_MEDIA_AUI ||\n\t\t     de->media_type == DE_MEDIA_BNC) &&\n\t\t    (de->media_lock ||\n\t\t     !de_ok_to_advertise(de, DE_MEDIA_TP_AUTO)))\n\t\t\treturn;\n\t\t \n\t\tif ((de->media_type == DE_MEDIA_AUI ||\n\t\t     de->media_type == DE_MEDIA_BNC)) {\n\t\t\tde->media_type = DE_MEDIA_TP_AUTO;\n\t\t\tde_stop_rxtx(de);\n\t\t\tde_set_media(de);\n\t\t\tde_start_rxtx(de);\n\t\t}\n\t\tde_link_up(de);\n\t\tmod_timer(&de->media_timer, jiffies + DE_TIMER_LINK);\n\t\treturn;\n\t}\n\n\tBUG_ON(!(status & LinkFail));\n\t \n\tif (netif_carrier_ok(de->dev) && de->media_type != DE_MEDIA_AUI &&\n\t    de->media_type != DE_MEDIA_BNC) {\n\t\tde_link_down(de);\n\t\tmod_timer(&de->media_timer, jiffies + DE_TIMER_NO_LINK);\n\t}\n}\n\nstatic int de_reset_mac (struct de_private *de)\n{\n\tu32 status, tmp;\n\n\t \n\n\tif (dr32(BusMode) == 0xffffffff)\n\t\treturn -EBUSY;\n\n\t \n\tdw32 (BusMode, CmdReset);\n\tmdelay (1);\n\n\tdw32 (BusMode, de_bus_mode);\n\tmdelay (1);\n\n\tfor (tmp = 0; tmp < 5; tmp++) {\n\t\tdr32 (BusMode);\n\t\tmdelay (1);\n\t}\n\n\tmdelay (1);\n\n\tstatus = dr32(MacStatus);\n\tif (status & (RxState | TxState))\n\t\treturn -EBUSY;\n\tif (status == 0xffffffff)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic void de_adapter_wake (struct de_private *de)\n{\n\tu32 pmctl;\n\n\tif (de->de21040)\n\t\treturn;\n\n\tpci_read_config_dword(de->pdev, PCIPM, &pmctl);\n\tif (pmctl & PM_Mask) {\n\t\tpmctl &= ~PM_Mask;\n\t\tpci_write_config_dword(de->pdev, PCIPM, pmctl);\n\n\t\t \n\t\tmsleep(10);\n\t}\n}\n\nstatic void de_adapter_sleep (struct de_private *de)\n{\n\tu32 pmctl;\n\n\tif (de->de21040)\n\t\treturn;\n\n\tdw32(CSR13, 0);  \n\tpci_read_config_dword(de->pdev, PCIPM, &pmctl);\n\tpmctl |= PM_Sleep;\n\tpci_write_config_dword(de->pdev, PCIPM, pmctl);\n}\n\nstatic int de_init_hw (struct de_private *de)\n{\n\tstruct net_device *dev = de->dev;\n\tu32 macmode;\n\tint rc;\n\n\tde_adapter_wake(de);\n\n\tmacmode = dr32(MacMode) & ~MacModeClear;\n\n\trc = de_reset_mac(de);\n\tif (rc)\n\t\treturn rc;\n\n\tde_set_media(de);  \n\n\tdw32(RxRingAddr, de->ring_dma);\n\tdw32(TxRingAddr, de->ring_dma + (sizeof(struct de_desc) * DE_RX_RING_SIZE));\n\n\tdw32(MacMode, RxTx | macmode);\n\n\tdr32(RxMissed);  \n\n\tdw32(IntrMask, de_intr_mask);\n\n\tde_set_rx_mode(dev);\n\n\treturn 0;\n}\n\nstatic int de_refill_rx (struct de_private *de)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < DE_RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb(de->dev, de->rx_buf_sz);\n\t\tif (!skb)\n\t\t\tgoto err_out;\n\n\t\tde->rx_skb[i].mapping = dma_map_single(&de->pdev->dev,\n\t\t\t\t\t\t       skb->data,\n\t\t\t\t\t\t       de->rx_buf_sz,\n\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\tde->rx_skb[i].skb = skb;\n\n\t\tde->rx_ring[i].opts1 = cpu_to_le32(DescOwn);\n\t\tif (i == (DE_RX_RING_SIZE - 1))\n\t\t\tde->rx_ring[i].opts2 =\n\t\t\t\tcpu_to_le32(RingEnd | de->rx_buf_sz);\n\t\telse\n\t\t\tde->rx_ring[i].opts2 = cpu_to_le32(de->rx_buf_sz);\n\t\tde->rx_ring[i].addr1 = cpu_to_le32(de->rx_skb[i].mapping);\n\t\tde->rx_ring[i].addr2 = 0;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tde_clean_rings(de);\n\treturn -ENOMEM;\n}\n\nstatic int de_init_rings (struct de_private *de)\n{\n\tmemset(de->tx_ring, 0, sizeof(struct de_desc) * DE_TX_RING_SIZE);\n\tde->tx_ring[DE_TX_RING_SIZE - 1].opts2 = cpu_to_le32(RingEnd);\n\n\tde->rx_tail = 0;\n\tde->tx_head = de->tx_tail = 0;\n\n\treturn de_refill_rx (de);\n}\n\nstatic int de_alloc_rings (struct de_private *de)\n{\n\tde->rx_ring = dma_alloc_coherent(&de->pdev->dev, DE_RING_BYTES,\n\t\t\t\t\t &de->ring_dma, GFP_KERNEL);\n\tif (!de->rx_ring)\n\t\treturn -ENOMEM;\n\tde->tx_ring = &de->rx_ring[DE_RX_RING_SIZE];\n\treturn de_init_rings(de);\n}\n\nstatic void de_clean_rings (struct de_private *de)\n{\n\tunsigned i;\n\n\tmemset(de->rx_ring, 0, sizeof(struct de_desc) * DE_RX_RING_SIZE);\n\tde->rx_ring[DE_RX_RING_SIZE - 1].opts2 = cpu_to_le32(RingEnd);\n\twmb();\n\tmemset(de->tx_ring, 0, sizeof(struct de_desc) * DE_TX_RING_SIZE);\n\tde->tx_ring[DE_TX_RING_SIZE - 1].opts2 = cpu_to_le32(RingEnd);\n\twmb();\n\n\tfor (i = 0; i < DE_RX_RING_SIZE; i++) {\n\t\tif (de->rx_skb[i].skb) {\n\t\t\tdma_unmap_single(&de->pdev->dev,\n\t\t\t\t\t de->rx_skb[i].mapping, de->rx_buf_sz,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(de->rx_skb[i].skb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < DE_TX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = de->tx_skb[i].skb;\n\t\tif ((skb) && (skb != DE_DUMMY_SKB)) {\n\t\t\tif (skb != DE_SETUP_SKB) {\n\t\t\t\tde->dev->stats.tx_dropped++;\n\t\t\t\tdma_unmap_single(&de->pdev->dev,\n\t\t\t\t\t\t de->tx_skb[i].mapping,\n\t\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&de->pdev->dev,\n\t\t\t\t\t\t de->tx_skb[i].mapping,\n\t\t\t\t\t\t sizeof(de->setup_frame),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(&de->rx_skb, 0, sizeof(struct ring_info) * DE_RX_RING_SIZE);\n\tmemset(&de->tx_skb, 0, sizeof(struct ring_info) * DE_TX_RING_SIZE);\n}\n\nstatic void de_free_rings (struct de_private *de)\n{\n\tde_clean_rings(de);\n\tdma_free_coherent(&de->pdev->dev, DE_RING_BYTES, de->rx_ring,\n\t\t\t  de->ring_dma);\n\tde->rx_ring = NULL;\n\tde->tx_ring = NULL;\n}\n\nstatic int de_open (struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tconst int irq = de->pdev->irq;\n\tint rc;\n\n\tnetif_dbg(de, ifup, dev, \"enabling interface\\n\");\n\n\tde->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\n\n\trc = de_alloc_rings(de);\n\tif (rc) {\n\t\tnetdev_err(dev, \"ring allocation failure, err=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tdw32(IntrMask, 0);\n\n\trc = request_irq(irq, de_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (rc) {\n\t\tnetdev_err(dev, \"IRQ %d request failure, err=%d\\n\", irq, rc);\n\t\tgoto err_out_free;\n\t}\n\n\trc = de_init_hw(de);\n\tif (rc) {\n\t\tnetdev_err(dev, \"h/w init failure, err=%d\\n\", rc);\n\t\tgoto err_out_free_irq;\n\t}\n\n\tnetif_start_queue(dev);\n\tmod_timer(&de->media_timer, jiffies + DE_TIMER_NO_LINK);\n\n\treturn 0;\n\nerr_out_free_irq:\n\tfree_irq(irq, dev);\nerr_out_free:\n\tde_free_rings(de);\n\treturn rc;\n}\n\nstatic int de_close (struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnetif_dbg(de, ifdown, dev, \"disabling interface\\n\");\n\n\tdel_timer_sync(&de->media_timer);\n\n\tspin_lock_irqsave(&de->lock, flags);\n\tde_stop_hw(de);\n\tnetif_stop_queue(dev);\n\tnetif_carrier_off(dev);\n\tspin_unlock_irqrestore(&de->lock, flags);\n\n\tfree_irq(de->pdev->irq, dev);\n\n\tde_free_rings(de);\n\tde_adapter_sleep(de);\n\treturn 0;\n}\n\nstatic void de_tx_timeout (struct net_device *dev, unsigned int txqueue)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tconst int irq = de->pdev->irq;\n\n\tnetdev_dbg(dev, \"NIC status %08x mode %08x sia %08x desc %u/%u/%u\\n\",\n\t\t   dr32(MacStatus), dr32(MacMode), dr32(SIAStatus),\n\t\t   de->rx_tail, de->tx_head, de->tx_tail);\n\n\tdel_timer_sync(&de->media_timer);\n\n\tdisable_irq(irq);\n\tspin_lock_irq(&de->lock);\n\n\tde_stop_hw(de);\n\tnetif_stop_queue(dev);\n\tnetif_carrier_off(dev);\n\n\tspin_unlock_irq(&de->lock);\n\tenable_irq(irq);\n\n\t \n\t__de_get_stats(de);\n\n\tsynchronize_irq(irq);\n\tde_clean_rings(de);\n\n\tde_init_rings(de);\n\n\tde_init_hw(de);\n\n\tnetif_wake_queue(dev);\n}\n\nstatic void __de_get_regs(struct de_private *de, u8 *buf)\n{\n\tint i;\n\tu32 *rbuf = (u32 *)buf;\n\n\t \n\tfor (i = 0; i < DE_NUM_REGS; i++)\n\t\trbuf[i] = dr32(i * 8);\n\n\t \n\tde_rx_missed(de, rbuf[8]);\n}\n\nstatic void __de_get_link_ksettings(struct de_private *de,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tde->media_supported);\n\tcmd->base.phy_address = 0;\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tde->media_advertise);\n\n\tswitch (de->media_type) {\n\tcase DE_MEDIA_AUI:\n\t\tcmd->base.port = PORT_AUI;\n\t\tbreak;\n\tcase DE_MEDIA_BNC:\n\t\tcmd->base.port = PORT_BNC;\n\t\tbreak;\n\tdefault:\n\t\tcmd->base.port = PORT_TP;\n\t\tbreak;\n\t}\n\n\tcmd->base.speed = 10;\n\n\tif (dr32(MacMode) & FullDuplex)\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\telse\n\t\tcmd->base.duplex = DUPLEX_HALF;\n\n\tif (de->media_lock)\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\telse\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\n\t \n}\n\nstatic int __de_set_link_ksettings(struct de_private *de,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tu32 new_media;\n\tunsigned int media_lock;\n\tu8 duplex = cmd->base.duplex;\n\tu8 port = cmd->base.port;\n\tu8 autoneg = cmd->base.autoneg;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (cmd->base.speed != 10)\n\t\treturn -EINVAL;\n\tif (duplex != DUPLEX_HALF && duplex != DUPLEX_FULL)\n\t\treturn -EINVAL;\n\tif (port != PORT_TP && port != PORT_AUI && port != PORT_BNC)\n\t\treturn -EINVAL;\n\tif (de->de21040 && port == PORT_BNC)\n\t\treturn -EINVAL;\n\tif (autoneg != AUTONEG_DISABLE && autoneg != AUTONEG_ENABLE)\n\t\treturn -EINVAL;\n\tif (advertising & ~de->media_supported)\n\t\treturn -EINVAL;\n\tif (autoneg == AUTONEG_ENABLE &&\n\t    (!(advertising & ADVERTISED_Autoneg)))\n\t\treturn -EINVAL;\n\n\tswitch (port) {\n\tcase PORT_AUI:\n\t\tnew_media = DE_MEDIA_AUI;\n\t\tif (!(advertising & ADVERTISED_AUI))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PORT_BNC:\n\t\tnew_media = DE_MEDIA_BNC;\n\t\tif (!(advertising & ADVERTISED_BNC))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tif (autoneg == AUTONEG_ENABLE)\n\t\t\tnew_media = DE_MEDIA_TP_AUTO;\n\t\telse if (duplex == DUPLEX_FULL)\n\t\t\tnew_media = DE_MEDIA_TP_FD;\n\t\telse\n\t\t\tnew_media = DE_MEDIA_TP;\n\t\tif (!(advertising & ADVERTISED_TP))\n\t\t\treturn -EINVAL;\n\t\tif (!(advertising & (ADVERTISED_10baseT_Full |\n\t\t\t\t     ADVERTISED_10baseT_Half)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tmedia_lock = (autoneg == AUTONEG_ENABLE) ? 0 : 1;\n\n\tif ((new_media == de->media_type) &&\n\t    (media_lock == de->media_lock) &&\n\t    (advertising == de->media_advertise))\n\t\treturn 0;  \n\n\tde_link_down(de);\n\tmod_timer(&de->media_timer, jiffies + DE_TIMER_NO_LINK);\n\tde_stop_rxtx(de);\n\n\tde->media_type = new_media;\n\tde->media_lock = media_lock;\n\tde->media_advertise = advertising;\n\tde_set_media(de);\n\tif (netif_running(de->dev))\n\t\tde_start_rxtx(de);\n\n\treturn 0;\n}\n\nstatic void de_get_drvinfo (struct net_device *dev,struct ethtool_drvinfo *info)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(de->pdev), sizeof(info->bus_info));\n}\n\nstatic int de_get_regs_len(struct net_device *dev)\n{\n\treturn DE_REGS_SIZE;\n}\n\nstatic int de_get_link_ksettings(struct net_device *dev,\n\t\t\t\t struct ethtool_link_ksettings *cmd)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\n\tspin_lock_irq(&de->lock);\n\t__de_get_link_ksettings(de, cmd);\n\tspin_unlock_irq(&de->lock);\n\n\treturn 0;\n}\n\nstatic int de_set_link_ksettings(struct net_device *dev,\n\t\t\t\t const struct ethtool_link_ksettings *cmd)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tint rc;\n\n\tspin_lock_irq(&de->lock);\n\trc = __de_set_link_ksettings(de, cmd);\n\tspin_unlock_irq(&de->lock);\n\n\treturn rc;\n}\n\nstatic u32 de_get_msglevel(struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\n\treturn de->msg_enable;\n}\n\nstatic void de_set_msglevel(struct net_device *dev, u32 msglvl)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\n\tde->msg_enable = msglvl;\n}\n\nstatic int de_get_eeprom(struct net_device *dev,\n\t\t\t struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\n\tif (!de->ee_data)\n\t\treturn -EOPNOTSUPP;\n\tif ((eeprom->offset != 0) || (eeprom->magic != 0) ||\n\t    (eeprom->len != DE_EEPROM_SIZE))\n\t\treturn -EINVAL;\n\tmemcpy(data, de->ee_data, eeprom->len);\n\n\treturn 0;\n}\n\nstatic int de_nway_reset(struct net_device *dev)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\tu32 status;\n\n\tif (de->media_type != DE_MEDIA_TP_AUTO)\n\t\treturn -EINVAL;\n\tif (netif_carrier_ok(de->dev))\n\t\tde_link_down(de);\n\n\tstatus = dr32(SIAStatus);\n\tdw32(SIAStatus, (status & ~NWayState) | NWayRestart);\n\tnetif_info(de, link, dev, \"link nway restart, status %x,%x\\n\",\n\t\t   status, dr32(SIAStatus));\n\treturn 0;\n}\n\nstatic void de_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\tvoid *data)\n{\n\tstruct de_private *de = netdev_priv(dev);\n\n\tregs->version = (DE_REGS_VER << 2) | de->de21040;\n\n\tspin_lock_irq(&de->lock);\n\t__de_get_regs(de, data);\n\tspin_unlock_irq(&de->lock);\n}\n\nstatic const struct ethtool_ops de_ethtool_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_drvinfo\t\t= de_get_drvinfo,\n\t.get_regs_len\t\t= de_get_regs_len,\n\t.get_msglevel\t\t= de_get_msglevel,\n\t.set_msglevel\t\t= de_set_msglevel,\n\t.get_eeprom\t\t= de_get_eeprom,\n\t.nway_reset\t\t= de_nway_reset,\n\t.get_regs\t\t= de_get_regs,\n\t.get_link_ksettings\t= de_get_link_ksettings,\n\t.set_link_ksettings\t= de_set_link_ksettings,\n};\n\nstatic void de21040_get_mac_address(struct de_private *de)\n{\n\tu8 addr[ETH_ALEN];\n\tunsigned i;\n\n\tdw32 (ROMCmd, 0);\t \n\tudelay(5);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tint value, boguscnt = 100000;\n\t\tdo {\n\t\t\tvalue = dr32(ROMCmd);\n\t\t\trmb();\n\t\t} while (value < 0 && --boguscnt > 0);\n\t\taddr[i] = value;\n\t\tudelay(1);\n\t\tif (boguscnt <= 0)\n\t\t\tpr_warn(\"timeout reading 21040 MAC address byte %u\\n\",\n\t\t\t\ti);\n\t}\n\teth_hw_addr_set(de->dev, addr);\n}\n\nstatic void de21040_get_media_info(struct de_private *de)\n{\n\tunsigned int i;\n\n\tde->media_type = DE_MEDIA_TP;\n\tde->media_supported |= SUPPORTED_TP | SUPPORTED_10baseT_Full |\n\t\t\t       SUPPORTED_10baseT_Half | SUPPORTED_AUI;\n\tde->media_advertise = de->media_supported;\n\n\tfor (i = 0; i < DE_MAX_MEDIA; i++) {\n\t\tswitch (i) {\n\t\tcase DE_MEDIA_AUI:\n\t\tcase DE_MEDIA_TP:\n\t\tcase DE_MEDIA_TP_FD:\n\t\t\tde->media[i].type = i;\n\t\t\tde->media[i].csr13 = t21040_csr13[i];\n\t\t\tde->media[i].csr14 = t21040_csr14[i];\n\t\t\tde->media[i].csr15 = t21040_csr15[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tde->media[i].type = DE_MEDIA_INVALID;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic unsigned tulip_read_eeprom(void __iomem *regs, int location,\n\t\t\t\t  int addr_len)\n{\n\tint i;\n\tunsigned retval = 0;\n\tvoid __iomem *ee_addr = regs + ROMCmd;\n\tint read_cmd = location | (EE_READ_CMD << addr_len);\n\n\twritel(EE_ENB & ~EE_CS, ee_addr);\n\twritel(EE_ENB, ee_addr);\n\n\t \n\tfor (i = 4 + addr_len; i >= 0; i--) {\n\t\tshort dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;\n\t\twritel(EE_ENB | dataval, ee_addr);\n\t\treadl(ee_addr);\n\t\twritel(EE_ENB | dataval | EE_SHIFT_CLK, ee_addr);\n\t\treadl(ee_addr);\n\t\tretval = (retval << 1) | ((readl(ee_addr) & EE_DATA_READ) ? 1 : 0);\n\t}\n\twritel(EE_ENB, ee_addr);\n\treadl(ee_addr);\n\n\tfor (i = 16; i > 0; i--) {\n\t\twritel(EE_ENB | EE_SHIFT_CLK, ee_addr);\n\t\treadl(ee_addr);\n\t\tretval = (retval << 1) | ((readl(ee_addr) & EE_DATA_READ) ? 1 : 0);\n\t\twritel(EE_ENB, ee_addr);\n\t\treadl(ee_addr);\n\t}\n\n\t \n\twritel(EE_ENB & ~EE_CS, ee_addr);\n\treturn retval;\n}\n\nstatic void de21041_get_srom_info(struct de_private *de)\n{\n\tunsigned i, sa_offset = 0, ofs;\n\tu8 ee_data[DE_EEPROM_SIZE + 6] = {};\n\tunsigned ee_addr_size = tulip_read_eeprom(de->regs, 0xff, 8) & 0x40000 ? 8 : 6;\n\tstruct de_srom_info_leaf *il;\n\tvoid *bufp;\n\n\t \n\tfor (i = 0; i < DE_EEPROM_WORDS; i++)\n\t\t((__le16 *)ee_data)[i] =\n\t\t\tcpu_to_le16(tulip_read_eeprom(de->regs, i, ee_addr_size));\n\n\t \n\t \n\n#ifndef CONFIG_MIPS_COBALT\n\n\tfor (i = 0; i < 8; i ++)\n\t\tif (ee_data[i] != ee_data[16+i])\n\t\t\tsa_offset = 20;\n\n#endif\n\n\t \n\teth_hw_addr_set(de->dev, &ee_data[sa_offset]);\n\n\t \n\tofs = ee_data[SROMC0InfoLeaf];\n\tif (ofs >= (sizeof(ee_data) - sizeof(struct de_srom_info_leaf) - sizeof(struct de_srom_media_block)))\n\t\tgoto bad_srom;\n\n\t \n\til = (struct de_srom_info_leaf *) &ee_data[ofs];\n\n\t \n\tif (il->n_blocks == 0)\n\t\tgoto bad_srom;\n\tif ((sizeof(ee_data) - ofs) <\n\t    (sizeof(struct de_srom_info_leaf) + (sizeof(struct de_srom_media_block) * il->n_blocks)))\n\t\tgoto bad_srom;\n\n\t \n\tswitch (get_unaligned(&il->default_media)) {\n\tcase 0x0001:  de->media_type = DE_MEDIA_BNC; break;\n\tcase 0x0002:  de->media_type = DE_MEDIA_AUI; break;\n\tcase 0x0204:  de->media_type = DE_MEDIA_TP_FD; break;\n\tdefault: de->media_type = DE_MEDIA_TP_AUTO; break;\n\t}\n\n\tif (netif_msg_probe(de))\n\t\tpr_info(\"de%d: SROM leaf offset %u, default media %s\\n\",\n\t\t       de->board_idx, ofs, media_name[de->media_type]);\n\n\t \n\tfor (i = 0; i < DE_MAX_MEDIA; i++) {\n\t\tde->media[i].type = DE_MEDIA_INVALID;\n\t\tde->media[i].csr13 = 0xffff;\n\t\tde->media[i].csr14 = 0xffff;\n\t\tde->media[i].csr15 = 0xffff;\n\t}\n\n\t \n\tbufp = ((void *)il) + sizeof(*il);\n\tfor (i = 0; i < il->n_blocks; i++) {\n\t\tstruct de_srom_media_block *ib = bufp;\n\t\tunsigned idx;\n\n\t\t \n\t\tswitch(ib->opts & MediaBlockMask) {\n\t\tcase 0:  \n\t\t\tde->media_supported |= SUPPORTED_TP | SUPPORTED_10baseT_Half\n\t\t\t\t\t  | SUPPORTED_Autoneg;\n\t\t\tidx = DE_MEDIA_TP;\n\t\t\tde->media[DE_MEDIA_TP_AUTO].type = DE_MEDIA_TP_AUTO;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tde->media_supported |= SUPPORTED_BNC;\n\t\t\tidx = DE_MEDIA_BNC;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tde->media_supported |= SUPPORTED_AUI;\n\t\t\tidx = DE_MEDIA_AUI;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\tde->media_supported |= SUPPORTED_TP | SUPPORTED_10baseT_Full\n\t\t\t\t\t  | SUPPORTED_Autoneg;\n\t\t\tidx = DE_MEDIA_TP_FD;\n\t\t\tde->media[DE_MEDIA_TP_AUTO].type = DE_MEDIA_TP_AUTO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto bad_srom;\n\t\t}\n\n\t\tde->media[idx].type = idx;\n\n\t\tif (netif_msg_probe(de))\n\t\t\tpr_info(\"de%d:   media block #%u: %s\",\n\t\t\t\tde->board_idx, i,\n\t\t\t\tmedia_name[de->media[idx].type]);\n\n\t\tbufp += sizeof (ib->opts);\n\n\t\tif (ib->opts & MediaCustomCSRs) {\n\t\t\tde->media[idx].csr13 = get_unaligned(&ib->csr13);\n\t\t\tde->media[idx].csr14 = get_unaligned(&ib->csr14);\n\t\t\tde->media[idx].csr15 = get_unaligned(&ib->csr15);\n\t\t\tbufp += sizeof(ib->csr13) + sizeof(ib->csr14) +\n\t\t\t\tsizeof(ib->csr15);\n\n\t\t\tif (netif_msg_probe(de))\n\t\t\t\tpr_cont(\" (%x,%x,%x)\\n\",\n\t\t\t\t\tde->media[idx].csr13,\n\t\t\t\t\tde->media[idx].csr14,\n\t\t\t\t\tde->media[idx].csr15);\n\n\t\t} else {\n\t\t\tif (netif_msg_probe(de))\n\t\t\t\tpr_cont(\"\\n\");\n\t\t}\n\n\t\tif (bufp > ((void *)&ee_data[DE_EEPROM_SIZE - 3]))\n\t\t\tbreak;\n\t}\n\n\tde->media_advertise = de->media_supported;\n\nfill_defaults:\n\t \n\tfor (i = 0; i < DE_MAX_MEDIA; i++) {\n\t\tif (de->media[i].csr13 == 0xffff)\n\t\t\tde->media[i].csr13 = t21041_csr13[i];\n\t\tif (de->media[i].csr14 == 0xffff) {\n\t\t\t \n\t\t\tif (de->pdev->revision < 0x20)\n\t\t\t\tde->media[i].csr14 = t21041_csr14_brk[i];\n\t\t\telse\n\t\t\t\tde->media[i].csr14 = t21041_csr14[i];\n\t\t}\n\t\tif (de->media[i].csr15 == 0xffff)\n\t\t\tde->media[i].csr15 = t21041_csr15[i];\n\t}\n\n\tde->ee_data = kmemdup(&ee_data[0], DE_EEPROM_SIZE, GFP_KERNEL);\n\n\treturn;\n\nbad_srom:\n\t \n\tfor (i = 0; i < DE_MAX_MEDIA; i++)\n\t\tde->media[i].type = i;\n\tde->media_supported =\n\t\tSUPPORTED_10baseT_Half |\n\t\tSUPPORTED_10baseT_Full |\n\t\tSUPPORTED_Autoneg |\n\t\tSUPPORTED_TP |\n\t\tSUPPORTED_AUI |\n\t\tSUPPORTED_BNC;\n\tgoto fill_defaults;\n}\n\nstatic const struct net_device_ops de_netdev_ops = {\n\t.ndo_open\t\t= de_open,\n\t.ndo_stop\t\t= de_close,\n\t.ndo_set_rx_mode\t= de_set_rx_mode,\n\t.ndo_start_xmit\t\t= de_start_xmit,\n\t.ndo_get_stats\t\t= de_get_stats,\n\t.ndo_tx_timeout \t= de_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int de_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct de_private *de;\n\tint rc;\n\tvoid __iomem *regs;\n\tunsigned long pciaddr;\n\tstatic int board_idx = -1;\n\n\tboard_idx++;\n\n\t \n\tdev = alloc_etherdev(sizeof(struct de_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->netdev_ops = &de_netdev_ops;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tdev->ethtool_ops = &de_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tde = netdev_priv(dev);\n\tde->de21040 = ent->driver_data == 0 ? 1 : 0;\n\tde->pdev = pdev;\n\tde->dev = dev;\n\tde->msg_enable = (debug < 0 ? DE_DEF_MSG_ENABLE : debug);\n\tde->board_idx = board_idx;\n\tspin_lock_init (&de->lock);\n\ttimer_setup(&de->media_timer,\n\t\t    de->de21040 ? de21040_media_timer : de21041_media_timer,\n\t\t    0);\n\n\tnetif_carrier_off(dev);\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc)\n\t\tgoto err_out_free;\n\n\t \n\trc = pci_request_regions(pdev, DRV_NAME);\n\tif (rc)\n\t\tgoto err_out_disable;\n\n\t \n\tif (pdev->irq < 2) {\n\t\trc = -EIO;\n\t\tpr_err(\"invalid irq (%d) for pci dev %s\\n\",\n\t\t       pdev->irq, pci_name(pdev));\n\t\tgoto err_out_res;\n\t}\n\n\t \n\tpciaddr = pci_resource_start(pdev, 1);\n\tif (!pciaddr) {\n\t\trc = -EIO;\n\t\tpr_err(\"no MMIO resource for pci dev %s\\n\", pci_name(pdev));\n\t\tgoto err_out_res;\n\t}\n\tif (pci_resource_len(pdev, 1) < DE_REGS_SIZE) {\n\t\trc = -EIO;\n\t\tpr_err(\"MMIO resource (%llx) too small on pci dev %s\\n\",\n\t\t       (unsigned long long)pci_resource_len(pdev, 1),\n\t\t       pci_name(pdev));\n\t\tgoto err_out_res;\n\t}\n\n\t \n\tregs = ioremap(pciaddr, DE_REGS_SIZE);\n\tif (!regs) {\n\t\trc = -EIO;\n\t\tpr_err(\"Cannot map PCI MMIO (%llx@%lx) on pci dev %s\\n\",\n\t\t       (unsigned long long)pci_resource_len(pdev, 1),\n\t\t       pciaddr, pci_name(pdev));\n\t\tgoto err_out_res;\n\t}\n\tde->regs = regs;\n\n\tde_adapter_wake(de);\n\n\t \n\trc = de_reset_mac(de);\n\tif (rc) {\n\t\tpr_err(\"Cannot reset MAC, pci dev %s\\n\", pci_name(pdev));\n\t\tgoto err_out_iomap;\n\t}\n\n\t \n\tif (de->de21040) {\n\t\tde21040_get_mac_address(de);\n\t\tde21040_get_media_info(de);\n\t} else {\n\t\tde21041_get_srom_info(de);\n\t}\n\n\t \n\trc = register_netdev(dev);\n\tif (rc)\n\t\tgoto err_out_iomap;\n\n\t \n\tnetdev_info(dev, \"%s at %p, %pM, IRQ %d\\n\",\n\t\t    de->de21040 ? \"21040\" : \"21041\",\n\t\t    regs, dev->dev_addr, pdev->irq);\n\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tpci_set_master(pdev);\n\n\t \n\tde_adapter_sleep(de);\n\n\treturn 0;\n\nerr_out_iomap:\n\tkfree(de->ee_data);\n\tiounmap(regs);\nerr_out_res:\n\tpci_release_regions(pdev);\nerr_out_disable:\n\tpci_disable_device(pdev);\nerr_out_free:\n\tfree_netdev(dev);\n\treturn rc;\n}\n\nstatic void de_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct de_private *de = netdev_priv(dev);\n\n\tBUG_ON(!dev);\n\tunregister_netdev(dev);\n\tkfree(de->ee_data);\n\tiounmap(de->regs);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tfree_netdev(dev);\n}\n\nstatic int __maybe_unused de_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct de_private *de = netdev_priv(dev);\n\n\trtnl_lock();\n\tif (netif_running (dev)) {\n\t\tconst int irq = pdev->irq;\n\n\t\tdel_timer_sync(&de->media_timer);\n\n\t\tdisable_irq(irq);\n\t\tspin_lock_irq(&de->lock);\n\n\t\tde_stop_hw(de);\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t\tnetif_carrier_off(dev);\n\n\t\tspin_unlock_irq(&de->lock);\n\t\tenable_irq(irq);\n\n\t\t \n\t\t__de_get_stats(de);\n\n\t\tsynchronize_irq(irq);\n\t\tde_clean_rings(de);\n\n\t\tde_adapter_sleep(de);\n\t} else {\n\t\tnetif_device_detach(dev);\n\t}\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic int __maybe_unused de_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct de_private *de = netdev_priv(dev);\n\n\trtnl_lock();\n\tif (netif_device_present(dev))\n\t\tgoto out;\n\tif (!netif_running(dev))\n\t\tgoto out_attach;\n\tpci_set_master(pdev);\n\tde_init_rings(de);\n\tde_init_hw(de);\nout_attach:\n\tnetif_device_attach(dev);\nout:\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(de_pm_ops, de_suspend, de_resume);\n\nstatic void de_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\trtnl_lock();\n\tdev_close(dev);\n\trtnl_unlock();\n}\n\nstatic struct pci_driver de_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= de_pci_tbl,\n\t.probe\t\t= de_init_one,\n\t.remove\t\t= de_remove_one,\n\t.shutdown\t= de_shutdown,\n\t.driver.pm\t= &de_pm_ops,\n};\n\nmodule_pci_driver(de_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}