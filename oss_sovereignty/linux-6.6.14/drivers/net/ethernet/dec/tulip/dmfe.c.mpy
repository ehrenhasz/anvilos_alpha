{
  "module_name": "dmfe.c",
  "hash_id": "f643cbd0d88b0dd23481dca2f9e4a9a35113e8263cd016e1619ef56fc4730454",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/dmfe.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"dmfe\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <linux/uaccess.h>\n#include <asm/irq.h>\n\n#ifdef CONFIG_TULIP_DM910X\n#include <linux/of.h>\n#endif\n\n\n \n#define PCI_DM9132_ID   0x91321282       \n#define PCI_DM9102_ID   0x91021282       \n#define PCI_DM9100_ID   0x91001282       \n#define PCI_DM9009_ID   0x90091282       \n\n#define DM9102_IO_SIZE  0x80\n#define DM9102A_IO_SIZE 0x100\n#define TX_MAX_SEND_CNT 0x1              \n#define TX_DESC_CNT     0x10             \n#define RX_DESC_CNT     0x20             \n#define TX_FREE_DESC_CNT (TX_DESC_CNT - 2)\t \n#define TX_WAKE_DESC_CNT (TX_DESC_CNT - 3)\t \n#define DESC_ALL_CNT    (TX_DESC_CNT + RX_DESC_CNT)\n#define TX_BUF_ALLOC    0x600\n#define RX_ALLOC_SIZE   0x620\n#define DM910X_RESET    1\n#define CR0_DEFAULT     0x00E00000       \n#define CR6_DEFAULT     0x00080000       \n#define CR7_DEFAULT     0x180c1\n#define CR15_DEFAULT    0x06             \n#define TDES0_ERR_MASK  0x4302           \n#define MAX_PACKET_SIZE 1514\n#define DMFE_MAX_MULTICAST 14\n#define RX_COPY_SIZE\t100\n#define MAX_CHECK_PACKET 0x8000\n#define DM9801_NOISE_FLOOR 8\n#define DM9802_NOISE_FLOOR 5\n\n#define DMFE_WOL_LINKCHANGE\t0x20000000\n#define DMFE_WOL_SAMPLEPACKET\t0x10000000\n#define DMFE_WOL_MAGICPACKET\t0x08000000\n\n\n#define DMFE_10MHF      0\n#define DMFE_100MHF     1\n#define DMFE_10MFD      4\n#define DMFE_100MFD     5\n#define DMFE_AUTO       8\n#define DMFE_1M_HPNA    0x10\n\n#define DMFE_TXTH_72\t0x400000\t \n#define DMFE_TXTH_96\t0x404000\t \n#define DMFE_TXTH_128\t0x0000\t\t \n#define DMFE_TXTH_256\t0x4000\t\t \n#define DMFE_TXTH_512\t0x8000\t\t \n#define DMFE_TXTH_1K\t0xC000\t\t \n\n#define DMFE_TIMER_WUT  (jiffies + HZ * 1) \n#define DMFE_TX_TIMEOUT ((3*HZ)/2)\t \n#define DMFE_TX_KICK \t(HZ/2)\t \n\n#define dw32(reg, val)\tiowrite32(val, ioaddr + (reg))\n#define dw16(reg, val)\tiowrite16(val, ioaddr + (reg))\n#define dr32(reg)\tioread32(ioaddr + (reg))\n#define dr16(reg)\tioread16(ioaddr + (reg))\n#define dr8(reg)\tioread8(ioaddr + (reg))\n\n#define DMFE_DBUG(dbug_now, msg, value)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (dmfe_debug || (dbug_now))\t\t\\\n\t\t\tpr_err(\"%s %lx\\n\",\t\t\\\n\t\t\t       (msg), (long) (value));\t\\\n\t} while (0)\n\n#define SHOW_MEDIA_TYPE(mode)\t\t\t\t\\\n\tpr_info(\"Change Speed to %sMhz %s duplex\\n\" ,\t\\\n\t\t(mode & 1) ? \"100\":\"10\",\t\t\\\n\t\t(mode & 4) ? \"full\":\"half\");\n\n\n \n#define CR9_SROM_READ   0x4800\n#define CR9_SRCS        0x1\n#define CR9_SRCLK       0x2\n#define CR9_CRDOUT      0x8\n#define SROM_DATA_0     0x0\n#define SROM_DATA_1     0x4\n#define PHY_DATA_1      0x20000\n#define PHY_DATA_0      0x00000\n#define MDCLKH          0x10000\n\n#define PHY_POWER_DOWN\t0x800\n\n#define SROM_V41_CODE   0x14\n\n#define __CHK_IO_SIZE(pci_id, dev_rev) \\\n (( ((pci_id)==PCI_DM9132_ID) || ((dev_rev) >= 0x30) ) ? \\\n\tDM9102A_IO_SIZE: DM9102_IO_SIZE)\n\n#define CHK_IO_SIZE(pci_dev) \\\n\t(__CHK_IO_SIZE(((pci_dev)->device << 16) | (pci_dev)->vendor, \\\n\t(pci_dev)->revision))\n\n \nstruct tx_desc {\n        __le32 tdes0, tdes1, tdes2, tdes3;  \n        char *tx_buf_ptr;                \n        struct tx_desc *next_tx_desc;\n} __attribute__(( aligned(32) ));\n\nstruct rx_desc {\n\t__le32 rdes0, rdes1, rdes2, rdes3;  \n\tstruct sk_buff *rx_skb_ptr;\t \n\tstruct rx_desc *next_rx_desc;\n} __attribute__(( aligned(32) ));\n\nstruct dmfe_board_info {\n\tu32 chip_id;\t\t\t \n\tu8 chip_revision;\t\t \n\tstruct net_device *next_dev;\t \n\tstruct pci_dev *pdev;\t\t \n\tspinlock_t lock;\n\n\tvoid __iomem *ioaddr;\t\t \n\tu32 cr0_data;\n\tu32 cr5_data;\n\tu32 cr6_data;\n\tu32 cr7_data;\n\tu32 cr15_data;\n\n\t \n\tdma_addr_t buf_pool_dma_ptr;\t \n\tdma_addr_t buf_pool_dma_start;\t \n\tdma_addr_t desc_pool_dma_ptr;\t \n\tdma_addr_t first_tx_desc_dma;\n\tdma_addr_t first_rx_desc_dma;\n\n\t \n\tunsigned char *buf_pool_ptr;\t \n\tunsigned char *buf_pool_start;\t \n\tunsigned char *desc_pool_ptr;\t \n\tstruct tx_desc *first_tx_desc;\n\tstruct tx_desc *tx_insert_ptr;\n\tstruct tx_desc *tx_remove_ptr;\n\tstruct rx_desc *first_rx_desc;\n\tstruct rx_desc *rx_insert_ptr;\n\tstruct rx_desc *rx_ready_ptr;\t \n\tunsigned long tx_packet_cnt;\t \n\tunsigned long tx_queue_cnt;\t \n\tunsigned long rx_avail_cnt;\t \n\tunsigned long interval_rx_cnt;\t \n\n\tu16 HPNA_command;\t\t \n\tu16 HPNA_timer;\t\t\t \n\tu16 dbug_cnt;\n\tu16 NIC_capability;\t\t \n\tu16 PHY_reg4;\t\t\t \n\n\tu8 HPNA_present;\t\t \n\tu8 chip_type;\t\t\t \n\tu8 media_mode;\t\t\t \n\tu8 op_mode;\t\t\t \n\tu8 phy_addr;\n\tu8 wait_reset;\t\t\t \n\tu8 dm910x_chk_mode;\t\t \n\tu8 first_in_callback;\t\t \n\tu8 wol_mode;\t\t\t \n\tstruct timer_list timer;\n\n\t \n\tunsigned long tx_fifo_underrun;\n\tunsigned long tx_loss_carrier;\n\tunsigned long tx_no_carrier;\n\tunsigned long tx_late_collision;\n\tunsigned long tx_excessive_collision;\n\tunsigned long tx_jabber_timeout;\n\tunsigned long reset_count;\n\tunsigned long reset_cr8;\n\tunsigned long reset_fatal;\n\tunsigned long reset_TXtimeout;\n\n\t \n\tunsigned char srom[128];\n};\n\nenum dmfe_offsets {\n\tDCR0 = 0x00, DCR1 = 0x08, DCR2 = 0x10, DCR3 = 0x18, DCR4 = 0x20,\n\tDCR5 = 0x28, DCR6 = 0x30, DCR7 = 0x38, DCR8 = 0x40, DCR9 = 0x48,\n\tDCR10 = 0x50, DCR11 = 0x58, DCR12 = 0x60, DCR13 = 0x68, DCR14 = 0x70,\n\tDCR15 = 0x78\n};\n\nenum dmfe_CR6_bits {\n\tCR6_RXSC = 0x2, CR6_PBF = 0x8, CR6_PM = 0x40, CR6_PAM = 0x80,\n\tCR6_FDM = 0x200, CR6_TXSC = 0x2000, CR6_STI = 0x100000,\n\tCR6_SFT = 0x200000, CR6_RXA = 0x40000000, CR6_NO_PURGE = 0x20000000\n};\n\n \nstatic int dmfe_debug;\nstatic unsigned char dmfe_media_mode = DMFE_AUTO;\nstatic u32 dmfe_cr6_user_set;\n\n \nstatic int debug;\nstatic u32 cr6set;\nstatic unsigned char mode = 8;\nstatic u8 chkmode = 1;\nstatic u8 HPNA_mode;\t\t \nstatic u8 HPNA_rx_cmd;\t\t \nstatic u8 HPNA_tx_cmd;\t\t \nstatic u8 HPNA_NoiseFloor;\t \nstatic u8 SF_mode;\t\t \n\n\n \nstatic int dmfe_open(struct net_device *);\nstatic netdev_tx_t dmfe_start_xmit(struct sk_buff *, struct net_device *);\nstatic int dmfe_stop(struct net_device *);\nstatic void dmfe_set_filter_mode(struct net_device *);\nstatic const struct ethtool_ops netdev_ethtool_ops;\nstatic u16 read_srom_word(void __iomem *, int);\nstatic irqreturn_t dmfe_interrupt(int , void *);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void poll_dmfe (struct net_device *dev);\n#endif\nstatic void dmfe_descriptor_init(struct net_device *);\nstatic void allocate_rx_buffer(struct net_device *);\nstatic void update_cr6(u32, void __iomem *);\nstatic void send_filter_frame(struct net_device *);\nstatic void dm9132_id_table(struct net_device *);\nstatic u16 dmfe_phy_read(void __iomem *, u8, u8, u32);\nstatic void dmfe_phy_write(void __iomem *, u8, u8, u16, u32);\nstatic void dmfe_phy_write_1bit(void __iomem *, u32);\nstatic u16 dmfe_phy_read_1bit(void __iomem *);\nstatic u8 dmfe_sense_speed(struct dmfe_board_info *);\nstatic void dmfe_process_mode(struct dmfe_board_info *);\nstatic void dmfe_timer(struct timer_list *);\nstatic inline u32 cal_CRC(unsigned char *, unsigned int, u8);\nstatic void dmfe_rx_packet(struct net_device *, struct dmfe_board_info *);\nstatic void dmfe_free_tx_pkt(struct net_device *, struct dmfe_board_info *);\nstatic void dmfe_reuse_skb(struct dmfe_board_info *, struct sk_buff *);\nstatic void dmfe_dynamic_reset(struct net_device *);\nstatic void dmfe_free_rxbuffer(struct dmfe_board_info *);\nstatic void dmfe_init_dm910x(struct net_device *);\nstatic void dmfe_parse_srom(struct dmfe_board_info *);\nstatic void dmfe_program_DM9801(struct dmfe_board_info *, int);\nstatic void dmfe_program_DM9802(struct dmfe_board_info *);\nstatic void dmfe_HPNA_remote_cmd_chk(struct dmfe_board_info * );\nstatic void dmfe_set_phyxcer(struct dmfe_board_info *);\n\n \n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open \t\t= dmfe_open,\n\t.ndo_stop\t\t= dmfe_stop,\n\t.ndo_start_xmit\t\t= dmfe_start_xmit,\n\t.ndo_set_rx_mode\t= dmfe_set_filter_mode,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= poll_dmfe,\n#endif\n};\n\n \n\nstatic int dmfe_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct dmfe_board_info *db;\t \n\tstruct net_device *dev;\n\tu32 pci_pmr;\n\tint i, err;\n\n\tDMFE_DBUG(0, \"dmfe_init_one()\", 0);\n\n\t \n#ifdef CONFIG_TULIP_DM910X\n\tif ((ent->driver_data == PCI_DM9100_ID && pdev->revision >= 0x30) ||\n\t    ent->driver_data == PCI_DM9102_ID) {\n\t\tstruct device_node *dp = pci_device_to_OF_node(pdev);\n\n\t\tif (dp && of_get_property(dp, \"local-mac-address\", NULL)) {\n\t\t\tpr_info(\"skipping on-board DM910x (use tulip)\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\t \n\tdev = alloc_etherdev(sizeof(*db));\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tpr_warn(\"32-bit PCI DMA not available\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_free;\n\t}\n\n\t \n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto err_out_free;\n\n\tif (!pci_resource_start(pdev, 0)) {\n\t\tpr_err(\"I/O base is zero\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\tif (pci_resource_len(pdev, 0) < (CHK_IO_SIZE(pdev)) ) {\n\t\tpr_err(\"Allocated I/O size too small\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n#if 0\t \n\n\t \n\t \n\n\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);\n#endif\n\n\tif (pci_request_regions(pdev, DRV_NAME)) {\n\t\tpr_err(\"Failed to request PCI regions\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\t \n\tdb = netdev_priv(dev);\n\n\t \n\tdb->desc_pool_ptr = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t       sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\n\t\t\t\t\t       &db->desc_pool_dma_ptr, GFP_KERNEL);\n\tif (!db->desc_pool_ptr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_res;\n\t}\n\n\tdb->buf_pool_ptr = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t      TX_BUF_ALLOC * TX_DESC_CNT + 4,\n\t\t\t\t\t      &db->buf_pool_dma_ptr, GFP_KERNEL);\n\tif (!db->buf_pool_ptr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_desc;\n\t}\n\n\tdb->first_tx_desc = (struct tx_desc *) db->desc_pool_ptr;\n\tdb->first_tx_desc_dma = db->desc_pool_dma_ptr;\n\tdb->buf_pool_start = db->buf_pool_ptr;\n\tdb->buf_pool_dma_start = db->buf_pool_dma_ptr;\n\n\tdb->chip_id = ent->driver_data;\n\t \n\tdb->ioaddr = pci_iomap(pdev, 0, 0);\n\tif (!db->ioaddr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_buf;\n\t}\n\n\tdb->chip_revision = pdev->revision;\n\tdb->wol_mode = 0;\n\n\tdb->pdev = pdev;\n\n\tpci_set_drvdata(pdev, dev);\n\tdev->netdev_ops = &netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\tnetif_carrier_off(dev);\n\tspin_lock_init(&db->lock);\n\n\tpci_read_config_dword(pdev, 0x50, &pci_pmr);\n\tpci_pmr &= 0x70000;\n\tif ( (pci_pmr == 0x10000) && (db->chip_revision == 0x31) )\n\t\tdb->chip_type = 1;\t \n\telse\n\t\tdb->chip_type = 0;\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\t((__le16 *) db->srom)[i] =\n\t\t\tcpu_to_le16(read_srom_word(db->ioaddr, i));\n\t}\n\n\t \n\teth_hw_addr_set(dev, &db->srom[20]);\n\n\terr = register_netdev (dev);\n\tif (err)\n\t\tgoto err_out_unmap;\n\n\tdev_info(&dev->dev, \"Davicom DM%04lx at pci%s, %pM, irq %d\\n\",\n\t\t ent->driver_data >> 16,\n\t\t pci_name(pdev), dev->dev_addr, pdev->irq);\n\n\tpci_set_master(pdev);\n\n\treturn 0;\n\nerr_out_unmap:\n\tpci_iounmap(pdev, db->ioaddr);\nerr_out_free_buf:\n\tdma_free_coherent(&pdev->dev, TX_BUF_ALLOC * TX_DESC_CNT + 4,\n\t\t\t  db->buf_pool_ptr, db->buf_pool_dma_ptr);\nerr_out_free_desc:\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\n\t\t\t  db->desc_pool_ptr, db->desc_pool_dma_ptr);\nerr_out_res:\n\tpci_release_regions(pdev);\nerr_out_disable:\n\tpci_disable_device(pdev);\nerr_out_free:\n\tfree_netdev(dev);\n\n\treturn err;\n}\n\n\nstatic void dmfe_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\n\tDMFE_DBUG(0, \"dmfe_remove_one()\", 0);\n\n\tif (dev) {\n\n\t\tunregister_netdev(dev);\n\t\tpci_iounmap(db->pdev, db->ioaddr);\n\t\tdma_free_coherent(&db->pdev->dev,\n\t\t\t\t  sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\n\t\t\t\t  db->desc_pool_ptr, db->desc_pool_dma_ptr);\n\t\tdma_free_coherent(&db->pdev->dev,\n\t\t\t\t  TX_BUF_ALLOC * TX_DESC_CNT + 4,\n\t\t\t\t  db->buf_pool_ptr, db->buf_pool_dma_ptr);\n\t\tpci_release_regions(pdev);\n\t\tfree_netdev(dev);\t \n\t}\n\n\tDMFE_DBUG(0, \"dmfe_remove_one() exit\", 0);\n}\n\n\n \n\nstatic int dmfe_open(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tconst int irq = db->pdev->irq;\n\tint ret;\n\n\tDMFE_DBUG(0, \"dmfe_open\", 0);\n\n\tret = request_irq(irq, dmfe_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdb->cr6_data = CR6_DEFAULT | dmfe_cr6_user_set;\n\tdb->tx_packet_cnt = 0;\n\tdb->tx_queue_cnt = 0;\n\tdb->rx_avail_cnt = 0;\n\tdb->wait_reset = 0;\n\n\tdb->first_in_callback = 0;\n\tdb->NIC_capability = 0xf;\t \n\tdb->PHY_reg4 = 0x1e0;\n\n\t \n\tif ( !chkmode || (db->chip_id == PCI_DM9132_ID) ||\n\t\t(db->chip_revision >= 0x30) ) {\n\t\tdb->cr6_data |= DMFE_TXTH_256;\n\t\tdb->cr0_data = CR0_DEFAULT;\n\t\tdb->dm910x_chk_mode=4;\t\t \n\t} else {\n\t\tdb->cr6_data |= CR6_SFT;\t \n\t\tdb->cr0_data = 0;\n\t\tdb->dm910x_chk_mode = 1;\t \n\t}\n\n\t \n\tdmfe_init_dm910x(dev);\n\n\t \n\tnetif_wake_queue(dev);\n\n\t \n\ttimer_setup(&db->timer, dmfe_timer, 0);\n\tdb->timer.expires = DMFE_TIMER_WUT + HZ * 2;\n\tadd_timer(&db->timer);\n\n\treturn 0;\n}\n\n\n \n\nstatic void dmfe_init_dm910x(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\tDMFE_DBUG(0, \"dmfe_init_dm910x()\", 0);\n\n\t \n\tdw32(DCR0, DM910X_RESET);\t \n\tudelay(100);\n\tdw32(DCR0, db->cr0_data);\n\tudelay(5);\n\n\t \n\tdb->phy_addr = 1;\n\n\t \n\tdmfe_parse_srom(db);\n\tdb->media_mode = dmfe_media_mode;\n\n\t \n\tdw32(DCR12, 0x180);\t\t \n\tif (db->chip_id == PCI_DM9009_ID) {\n\t\tdw32(DCR12, 0x80);\t \n\t\tmdelay(300);\t\t\t \n\t}\n\tdw32(DCR12, 0x0);\t \n\n\t \n\tif ( !(db->media_mode & 0x10) )\t \n\t\tdmfe_set_phyxcer(db);\n\n\t \n\tif ( !(db->media_mode & DMFE_AUTO) )\n\t\tdb->op_mode = db->media_mode; \t \n\n\t \n\tdmfe_descriptor_init(dev);\n\n\t \n\tupdate_cr6(db->cr6_data, ioaddr);\n\n\t \n\tif (db->chip_id == PCI_DM9132_ID)\n\t\tdm9132_id_table(dev);\t \n\telse\n\t\tsend_filter_frame(dev);\t \n\n\t \n\tdb->cr7_data = CR7_DEFAULT;\n\tdw32(DCR7, db->cr7_data);\n\n\t \n\tdw32(DCR15, db->cr15_data);\n\n\t \n\tdb->cr6_data |= CR6_RXSC | CR6_TXSC | 0x40000;\n\tupdate_cr6(db->cr6_data, ioaddr);\n}\n\n\n \n\nstatic netdev_tx_t dmfe_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tstruct tx_desc *txptr;\n\tunsigned long flags;\n\n\tDMFE_DBUG(0, \"dmfe_start_xmit\", 0);\n\n\t \n\tif (skb->len > MAX_PACKET_SIZE) {\n\t\tpr_err(\"big packet = %d\\n\", (u16)skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\tif (db->tx_queue_cnt >= TX_FREE_DESC_CNT) {\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\tpr_err(\"No Tx resource %ld\\n\", db->tx_queue_cnt);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tdw32(DCR7, 0);\n\n\t \n\ttxptr = db->tx_insert_ptr;\n\tskb_copy_from_linear_data(skb, txptr->tx_buf_ptr, skb->len);\n\ttxptr->tdes1 = cpu_to_le32(0xe1000000 | skb->len);\n\n\t \n\tdb->tx_insert_ptr = txptr->next_tx_desc;\n\n\t \n\tif ( (!db->tx_queue_cnt) && (db->tx_packet_cnt < TX_MAX_SEND_CNT) ) {\n\t\ttxptr->tdes0 = cpu_to_le32(0x80000000);\t \n\t\tdb->tx_packet_cnt++;\t\t\t \n\t\tdw32(DCR1, 0x1);\t\t\t \n\t\tnetif_trans_update(dev);\t\t \n\t} else {\n\t\tdb->tx_queue_cnt++;\t\t\t \n\t\tdw32(DCR1, 0x1);\t\t\t \n\t}\n\n\t \n\tif ( db->tx_queue_cnt < TX_FREE_DESC_CNT )\n\t\tnetif_wake_queue(dev);\n\n\t \n\tspin_unlock_irqrestore(&db->lock, flags);\n\tdw32(DCR7, db->cr7_data);\n\n\t \n\tdev_consume_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n\n \n\nstatic int dmfe_stop(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\tDMFE_DBUG(0, \"dmfe_stop\", 0);\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tdel_timer_sync(&db->timer);\n\n\t \n\tdw32(DCR0, DM910X_RESET);\n\tudelay(100);\n\tdmfe_phy_write(ioaddr, db->phy_addr, 0, 0x8000, db->chip_id);\n\n\t \n\tfree_irq(db->pdev->irq, dev);\n\n\t \n\tdmfe_free_rxbuffer(db);\n\n#if 0\n\t \n\tprintk(\"FU:%lx EC:%lx LC:%lx NC:%lx LOC:%lx TXJT:%lx RESET:%lx RCR8:%lx FAL:%lx TT:%lx\\n\",\n\t       db->tx_fifo_underrun, db->tx_excessive_collision,\n\t       db->tx_late_collision, db->tx_no_carrier, db->tx_loss_carrier,\n\t       db->tx_jabber_timeout, db->reset_count, db->reset_cr8,\n\t       db->reset_fatal, db->reset_TXtimeout);\n#endif\n\n\treturn 0;\n}\n\n\n \n\nstatic irqreturn_t dmfe_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tunsigned long flags;\n\n\tDMFE_DBUG(0, \"dmfe_interrupt()\", 0);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\tdb->cr5_data = dr32(DCR5);\n\tdw32(DCR5, db->cr5_data);\n\tif ( !(db->cr5_data & 0xc1) ) {\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tdw32(DCR7, 0);\n\n\t \n\tif (db->cr5_data & 0x2000) {\n\t\t \n\t\tDMFE_DBUG(1, \"System bus error happen. CR5=\", db->cr5_data);\n\t\tdb->reset_fatal++;\n\t\tdb->wait_reset = 1;\t \n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t  \n\tif ( (db->cr5_data & 0x40) && db->rx_avail_cnt )\n\t\tdmfe_rx_packet(dev, db);\n\n\t \n\tif (db->rx_avail_cnt<RX_DESC_CNT)\n\t\tallocate_rx_buffer(dev);\n\n\t \n\tif ( db->cr5_data & 0x01)\n\t\tdmfe_free_tx_pkt(dev, db);\n\n\t \n\tif (db->dm910x_chk_mode & 0x2) {\n\t\tdb->dm910x_chk_mode = 0x4;\n\t\tdb->cr6_data |= 0x100;\n\t\tupdate_cr6(db->cr6_data, ioaddr);\n\t}\n\n\t \n\tdw32(DCR7, db->cr7_data);\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \n\nstatic void poll_dmfe (struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tconst int irq = db->pdev->irq;\n\n\t \n\tdisable_irq(irq);\n\tdmfe_interrupt (irq, dev);\n\tenable_irq(irq);\n}\n#endif\n\n \n\nstatic void dmfe_free_tx_pkt(struct net_device *dev, struct dmfe_board_info *db)\n{\n\tstruct tx_desc *txptr;\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu32 tdes0;\n\n\ttxptr = db->tx_remove_ptr;\n\twhile(db->tx_packet_cnt) {\n\t\ttdes0 = le32_to_cpu(txptr->tdes0);\n\t\tif (tdes0 & 0x80000000)\n\t\t\tbreak;\n\n\t\t \n\t\tdb->tx_packet_cnt--;\n\t\tdev->stats.tx_packets++;\n\n\t\t \n\t\tif ( tdes0 != 0x7fffffff ) {\n\t\t\tdev->stats.collisions += (tdes0 >> 3) & 0xf;\n\t\t\tdev->stats.tx_bytes += le32_to_cpu(txptr->tdes1) & 0x7ff;\n\t\t\tif (tdes0 & TDES0_ERR_MASK) {\n\t\t\t\tdev->stats.tx_errors++;\n\n\t\t\t\tif (tdes0 & 0x0002) {\t \n\t\t\t\t\tdb->tx_fifo_underrun++;\n\t\t\t\t\tif ( !(db->cr6_data & CR6_SFT) ) {\n\t\t\t\t\t\tdb->cr6_data = db->cr6_data | CR6_SFT;\n\t\t\t\t\t\tupdate_cr6(db->cr6_data, ioaddr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tdes0 & 0x0100)\n\t\t\t\t\tdb->tx_excessive_collision++;\n\t\t\t\tif (tdes0 & 0x0200)\n\t\t\t\t\tdb->tx_late_collision++;\n\t\t\t\tif (tdes0 & 0x0400)\n\t\t\t\t\tdb->tx_no_carrier++;\n\t\t\t\tif (tdes0 & 0x0800)\n\t\t\t\t\tdb->tx_loss_carrier++;\n\t\t\t\tif (tdes0 & 0x4000)\n\t\t\t\t\tdb->tx_jabber_timeout++;\n\t\t\t}\n\t\t}\n\n\t\ttxptr = txptr->next_tx_desc;\n\t} \n\n\t \n\tdb->tx_remove_ptr = txptr;\n\n\t \n\tif ( (db->tx_packet_cnt < TX_MAX_SEND_CNT) && db->tx_queue_cnt ) {\n\t\ttxptr->tdes0 = cpu_to_le32(0x80000000);\t \n\t\tdb->tx_packet_cnt++;\t\t\t \n\t\tdb->tx_queue_cnt--;\n\t\tdw32(DCR1, 0x1);\t\t\t \n\t\tnetif_trans_update(dev);\t\t \n\t}\n\n\t \n\tif ( db->tx_queue_cnt < TX_WAKE_DESC_CNT )\n\t\tnetif_wake_queue(dev);\t \n}\n\n\n \n\nstatic inline u32 cal_CRC(unsigned char * Data, unsigned int Len, u8 flag)\n{\n\tu32 crc = crc32(~0, Data, Len);\n\tif (flag) crc = ~crc;\n\treturn crc;\n}\n\n\n \n\nstatic void dmfe_rx_packet(struct net_device *dev, struct dmfe_board_info *db)\n{\n\tstruct rx_desc *rxptr;\n\tstruct sk_buff *skb, *newskb;\n\tint rxlen;\n\tu32 rdes0;\n\n\trxptr = db->rx_ready_ptr;\n\n\twhile(db->rx_avail_cnt) {\n\t\trdes0 = le32_to_cpu(rxptr->rdes0);\n\t\tif (rdes0 & 0x80000000)\t \n\t\t\tbreak;\n\n\t\tdb->rx_avail_cnt--;\n\t\tdb->interval_rx_cnt++;\n\n\t\tdma_unmap_single(&db->pdev->dev, le32_to_cpu(rxptr->rdes2),\n\t\t\t\t RX_ALLOC_SIZE, DMA_FROM_DEVICE);\n\n\t\tif ( (rdes0 & 0x300) != 0x300) {\n\t\t\t \n\t\t\t \n\t\t\tDMFE_DBUG(0, \"Reuse SK buffer, rdes0\", rdes0);\n\t\t\tdmfe_reuse_skb(db, rxptr->rx_skb_ptr);\n\t\t} else {\n\t\t\t \n\t\t\trxlen = ( (rdes0 >> 16) & 0x3fff) - 4;\n\n\t\t\t \n\t\t\tif (rdes0 & 0x8000) {\n\t\t\t\t \n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tif (rdes0 & 1)\n\t\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t\tif (rdes0 & 2)\n\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tif (rdes0 & 0x80)\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t}\n\n\t\t\tif ( !(rdes0 & 0x8000) ||\n\t\t\t\t((db->cr6_data & CR6_PM) && (rxlen>6)) ) {\n\t\t\t\tskb = rxptr->rx_skb_ptr;\n\n\t\t\t\t \n\t\t\t\tif ( (db->dm910x_chk_mode & 1) &&\n\t\t\t\t\t(cal_CRC(skb->data, rxlen, 1) !=\n\t\t\t\t\t(*(u32 *) (skb->data+rxlen) ))) {  \n\t\t\t\t\t \n\t\t\t\t\tdmfe_reuse_skb(db, rxptr->rx_skb_ptr);\n\t\t\t\t\tdb->dm910x_chk_mode = 3;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tif ((rxlen < RX_COPY_SIZE) &&\n\t\t\t\t\t\t((newskb = netdev_alloc_skb(dev, rxlen + 2))\n\t\t\t\t\t\t!= NULL)) {\n\n\t\t\t\t\t\tskb = newskb;\n\t\t\t\t\t\t \n\t\t\t\t\t\tskb_reserve(skb, 2);  \n\t\t\t\t\t\tskb_copy_from_linear_data(rxptr->rx_skb_ptr,\n\t\t\t\t\t\t\t  skb_put(skb, rxlen),\n\t\t\t\t\t\t\t\t\t  rxlen);\n\t\t\t\t\t\tdmfe_reuse_skb(db, rxptr->rx_skb_ptr);\n\t\t\t\t\t} else\n\t\t\t\t\t\tskb_put(skb, rxlen);\n\n\t\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\t\tnetif_rx(skb);\n\t\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\t\tdev->stats.rx_bytes += rxlen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tDMFE_DBUG(0, \"Reuse SK buffer, rdes0\", rdes0);\n\t\t\t\tdmfe_reuse_skb(db, rxptr->rx_skb_ptr);\n\t\t\t}\n\t\t}\n\n\t\trxptr = rxptr->next_rx_desc;\n\t}\n\n\tdb->rx_ready_ptr = rxptr;\n}\n\n \n\nstatic void dmfe_set_filter_mode(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\tint mc_count = netdev_mc_count(dev);\n\n\tDMFE_DBUG(0, \"dmfe_set_filter_mode()\", 0);\n\tspin_lock_irqsave(&db->lock, flags);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tDMFE_DBUG(0, \"Enable PROM Mode\", 0);\n\t\tdb->cr6_data |= CR6_PM | CR6_PBF;\n\t\tupdate_cr6(db->cr6_data, db->ioaddr);\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI || mc_count > DMFE_MAX_MULTICAST) {\n\t\tDMFE_DBUG(0, \"Pass all multicast address\", mc_count);\n\t\tdb->cr6_data &= ~(CR6_PM | CR6_PBF);\n\t\tdb->cr6_data |= CR6_PAM;\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn;\n\t}\n\n\tDMFE_DBUG(0, \"Set multicast address\", mc_count);\n\tif (db->chip_id == PCI_DM9132_ID)\n\t\tdm9132_id_table(dev);\t \n\telse\n\t\tsend_filter_frame(dev);\t \n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\n \n\nstatic void dmfe_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct dmfe_board_info *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(np->pdev), sizeof(info->bus_info));\n}\n\nstatic int dmfe_ethtool_set_wol(struct net_device *dev,\n\t\t\t\tstruct ethtool_wolinfo *wolinfo)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\n\tif (wolinfo->wolopts & (WAKE_UCAST | WAKE_MCAST | WAKE_BCAST |\n\t\t   \t\tWAKE_ARP | WAKE_MAGICSECURE))\n\t\t   return -EOPNOTSUPP;\n\n\tdb->wol_mode = wolinfo->wolopts;\n\treturn 0;\n}\n\nstatic void dmfe_ethtool_get_wol(struct net_device *dev,\n\t\t\t\t struct ethtool_wolinfo *wolinfo)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\n\twolinfo->supported = WAKE_PHY | WAKE_MAGIC;\n\twolinfo->wolopts = db->wol_mode;\n}\n\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= dmfe_ethtool_get_drvinfo,\n\t.get_link               = ethtool_op_get_link,\n\t.set_wol\t\t= dmfe_ethtool_set_wol,\n\t.get_wol\t\t= dmfe_ethtool_get_wol,\n};\n\n \n\nstatic void dmfe_timer(struct timer_list *t)\n{\n\tstruct dmfe_board_info *db = from_timer(db, t, timer);\n\tstruct net_device *dev = pci_get_drvdata(db->pdev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu32 tmp_cr8;\n\tunsigned char tmp_cr12;\n\tunsigned long flags;\n\n\tint link_ok, link_ok_phy;\n\n\tDMFE_DBUG(0, \"dmfe_timer()\", 0);\n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\tif (db->first_in_callback == 0) {\n\t\tdb->first_in_callback = 1;\n\t\tif (db->chip_type && (db->chip_id==PCI_DM9102_ID)) {\n\t\t\tdb->cr6_data &= ~0x40000;\n\t\t\tupdate_cr6(db->cr6_data, ioaddr);\n\t\t\tdmfe_phy_write(ioaddr, db->phy_addr, 0, 0x1000, db->chip_id);\n\t\t\tdb->cr6_data |= 0x40000;\n\t\t\tupdate_cr6(db->cr6_data, ioaddr);\n\t\t\tdb->timer.expires = DMFE_TIMER_WUT + HZ * 2;\n\t\t\tadd_timer(&db->timer);\n\t\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\t \n\tif ( (db->dm910x_chk_mode & 0x1) &&\n\t\t(dev->stats.rx_packets > MAX_CHECK_PACKET) )\n\t\tdb->dm910x_chk_mode = 0x4;\n\n\t \n\ttmp_cr8 = dr32(DCR8);\n\tif ( (db->interval_rx_cnt==0) && (tmp_cr8) ) {\n\t\tdb->reset_cr8++;\n\t\tdb->wait_reset = 1;\n\t}\n\tdb->interval_rx_cnt = 0;\n\n\t \n\tif ( db->tx_packet_cnt &&\n\t     time_after(jiffies, dev_trans_start(dev) + DMFE_TX_KICK) ) {\n\t\tdw32(DCR1, 0x1);    \n\n\t\t \n\t\tif (time_after(jiffies, dev_trans_start(dev) + DMFE_TX_TIMEOUT) ) {\n\t\t\tdb->reset_TXtimeout++;\n\t\t\tdb->wait_reset = 1;\n\t\t\tdev_warn(&dev->dev, \"Tx timeout - resetting\\n\");\n\t\t}\n\t}\n\n\tif (db->wait_reset) {\n\t\tDMFE_DBUG(0, \"Dynamic Reset device\", db->tx_packet_cnt);\n\t\tdb->reset_count++;\n\t\tdmfe_dynamic_reset(dev);\n\t\tdb->first_in_callback = 0;\n\t\tdb->timer.expires = DMFE_TIMER_WUT;\n\t\tadd_timer(&db->timer);\n\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (db->chip_id == PCI_DM9132_ID)\n\t\ttmp_cr12 = dr8(DCR9 + 3);\t \n\telse\n\t\ttmp_cr12 = dr8(DCR12);\t\t \n\n\tif ( ((db->chip_id == PCI_DM9102_ID) &&\n\t\t(db->chip_revision == 0x30)) ||\n\t\t((db->chip_id == PCI_DM9132_ID) &&\n\t\t(db->chip_revision == 0x10)) ) {\n\t\t \n\t\tif (tmp_cr12 & 2)\n\t\t\tlink_ok = 0;\n\t\telse\n\t\t\tlink_ok = 1;\n\t}\n\telse\n\t\t \n\t\tlink_ok = (tmp_cr12 & 0x43) ? 1 : 0;\n\n\n\t \n\n\t \n\tdmfe_phy_read (db->ioaddr, db->phy_addr, 1, db->chip_id);\n\tlink_ok_phy = (dmfe_phy_read (db->ioaddr,\n\t\t\t\t      db->phy_addr, 1, db->chip_id) & 0x4) ? 1 : 0;\n\n\tif (link_ok_phy != link_ok) {\n\t\tDMFE_DBUG (0, \"PHY and chip report different link status\", 0);\n\t\tlink_ok = link_ok | link_ok_phy;\n\t}\n\n\tif ( !link_ok && netif_carrier_ok(dev)) {\n\t\t \n\t\tDMFE_DBUG(0, \"Link Failed\", tmp_cr12);\n\t\tnetif_carrier_off(dev);\n\n\t\t \n\t\t \n\t\tif ( !(db->media_mode & 0x38) )\n\t\t\tdmfe_phy_write(db->ioaddr, db->phy_addr,\n\t\t\t\t       0, 0x1000, db->chip_id);\n\n\t\t \n\t\tif (db->media_mode & DMFE_AUTO) {\n\t\t\t \n\t\t\tdb->cr6_data|=0x00040000;\t \n\t\t\tdb->cr6_data&=~0x00000200;\t \n\t\t\tupdate_cr6(db->cr6_data, ioaddr);\n\t\t}\n\t} else if (!netif_carrier_ok(dev)) {\n\n\t\tDMFE_DBUG(0, \"Link link OK\", tmp_cr12);\n\n\t\t \n\t\tif ( !(db->media_mode & DMFE_AUTO) || !dmfe_sense_speed(db)) {\n\t\t\tnetif_carrier_on(dev);\n\t\t\tSHOW_MEDIA_TYPE(db->op_mode);\n\t\t}\n\n\t\tdmfe_process_mode(db);\n\t}\n\n\t \n\tif (db->HPNA_command & 0xf00) {\n\t\tdb->HPNA_timer--;\n\t\tif (!db->HPNA_timer)\n\t\t\tdmfe_HPNA_remote_cmd_chk(db);\n\t}\n\n\t \n\tdb->timer.expires = DMFE_TIMER_WUT;\n\tadd_timer(&db->timer);\n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\n\n \n\nstatic void dmfe_dynamic_reset(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\tDMFE_DBUG(0, \"dmfe_dynamic_reset()\", 0);\n\n\t \n\tdb->cr6_data &= ~(CR6_RXSC | CR6_TXSC);\t \n\tupdate_cr6(db->cr6_data, ioaddr);\n\tdw32(DCR7, 0);\t\t\t\t \n\tdw32(DCR5, dr32(DCR5));\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tdmfe_free_rxbuffer(db);\n\n\t \n\tdb->tx_packet_cnt = 0;\n\tdb->tx_queue_cnt = 0;\n\tdb->rx_avail_cnt = 0;\n\tnetif_carrier_off(dev);\n\tdb->wait_reset = 0;\n\n\t \n\tdmfe_init_dm910x(dev);\n\n\t \n\tnetif_wake_queue(dev);\n}\n\n\n \n\nstatic void dmfe_free_rxbuffer(struct dmfe_board_info * db)\n{\n\tDMFE_DBUG(0, \"dmfe_free_rxbuffer()\", 0);\n\n\t \n\twhile (db->rx_avail_cnt) {\n\t\tdev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);\n\t\tdb->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;\n\t\tdb->rx_avail_cnt--;\n\t}\n}\n\n\n \n\nstatic void dmfe_reuse_skb(struct dmfe_board_info *db, struct sk_buff * skb)\n{\n\tstruct rx_desc *rxptr = db->rx_insert_ptr;\n\n\tif (!(rxptr->rdes0 & cpu_to_le32(0x80000000))) {\n\t\trxptr->rx_skb_ptr = skb;\n\t\trxptr->rdes2 = cpu_to_le32(dma_map_single(&db->pdev->dev, skb->data,\n\t\t\t\t\t\t\t  RX_ALLOC_SIZE, DMA_FROM_DEVICE));\n\t\twmb();\n\t\trxptr->rdes0 = cpu_to_le32(0x80000000);\n\t\tdb->rx_avail_cnt++;\n\t\tdb->rx_insert_ptr = rxptr->next_rx_desc;\n\t} else\n\t\tDMFE_DBUG(0, \"SK Buffer reuse method error\", db->rx_avail_cnt);\n}\n\n\n \n\nstatic void dmfe_descriptor_init(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tstruct tx_desc *tmp_tx;\n\tstruct rx_desc *tmp_rx;\n\tunsigned char *tmp_buf;\n\tdma_addr_t tmp_tx_dma, tmp_rx_dma;\n\tdma_addr_t tmp_buf_dma;\n\tint i;\n\n\tDMFE_DBUG(0, \"dmfe_descriptor_init()\", 0);\n\n\t \n\tdb->tx_insert_ptr = db->first_tx_desc;\n\tdb->tx_remove_ptr = db->first_tx_desc;\n\tdw32(DCR4, db->first_tx_desc_dma);      \n\n\t \n\tdb->first_rx_desc = (void *)db->first_tx_desc +\n\t\t\tsizeof(struct tx_desc) * TX_DESC_CNT;\n\n\tdb->first_rx_desc_dma =  db->first_tx_desc_dma +\n\t\t\tsizeof(struct tx_desc) * TX_DESC_CNT;\n\tdb->rx_insert_ptr = db->first_rx_desc;\n\tdb->rx_ready_ptr = db->first_rx_desc;\n\tdw32(DCR3, db->first_rx_desc_dma);\t\t \n\n\t \n\ttmp_buf = db->buf_pool_start;\n\ttmp_buf_dma = db->buf_pool_dma_start;\n\ttmp_tx_dma = db->first_tx_desc_dma;\n\tfor (tmp_tx = db->first_tx_desc, i = 0; i < TX_DESC_CNT; i++, tmp_tx++) {\n\t\ttmp_tx->tx_buf_ptr = tmp_buf;\n\t\ttmp_tx->tdes0 = cpu_to_le32(0);\n\t\ttmp_tx->tdes1 = cpu_to_le32(0x81000000);\t \n\t\ttmp_tx->tdes2 = cpu_to_le32(tmp_buf_dma);\n\t\ttmp_tx_dma += sizeof(struct tx_desc);\n\t\ttmp_tx->tdes3 = cpu_to_le32(tmp_tx_dma);\n\t\ttmp_tx->next_tx_desc = tmp_tx + 1;\n\t\ttmp_buf = tmp_buf + TX_BUF_ALLOC;\n\t\ttmp_buf_dma = tmp_buf_dma + TX_BUF_ALLOC;\n\t}\n\t(--tmp_tx)->tdes3 = cpu_to_le32(db->first_tx_desc_dma);\n\ttmp_tx->next_tx_desc = db->first_tx_desc;\n\n\t  \n\ttmp_rx_dma=db->first_rx_desc_dma;\n\tfor (tmp_rx = db->first_rx_desc, i = 0; i < RX_DESC_CNT; i++, tmp_rx++) {\n\t\ttmp_rx->rdes0 = cpu_to_le32(0);\n\t\ttmp_rx->rdes1 = cpu_to_le32(0x01000600);\n\t\ttmp_rx_dma += sizeof(struct rx_desc);\n\t\ttmp_rx->rdes3 = cpu_to_le32(tmp_rx_dma);\n\t\ttmp_rx->next_rx_desc = tmp_rx + 1;\n\t}\n\t(--tmp_rx)->rdes3 = cpu_to_le32(db->first_rx_desc_dma);\n\ttmp_rx->next_rx_desc = db->first_rx_desc;\n\n\t \n\tallocate_rx_buffer(dev);\n}\n\n\n \n\nstatic void update_cr6(u32 cr6_data, void __iomem *ioaddr)\n{\n\tu32 cr6_tmp;\n\n\tcr6_tmp = cr6_data & ~0x2002;            \n\tdw32(DCR6, cr6_tmp);\n\tudelay(5);\n\tdw32(DCR6, cr6_data);\n\tudelay(5);\n}\n\n\n \n\nstatic void dm9132_id_table(struct net_device *dev)\n{\n\tconst u16 *addrptr = (const u16 *)dev->dev_addr;\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr + 0xc0;\n\tstruct netdev_hw_addr *ha;\n\tu16 i, hash_table[4];\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tdw16(0, addrptr[i]);\n\t\tioaddr += 4;\n\t}\n\n\t \n\tmemset(hash_table, 0, sizeof(hash_table));\n\n\t \n\thash_table[3] = 0x8000;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tu32 hash_val = cal_CRC((char *)ha->addr, 6, 0) & 0x3f;\n\n\t\thash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++, ioaddr += 4)\n\t\tdw16(0, hash_table[i]);\n}\n\n\n \n\nstatic void send_filter_frame(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tstruct tx_desc *txptr;\n\tconst u16 * addrptr;\n\tu32 * suptr;\n\tint i;\n\n\tDMFE_DBUG(0, \"send_filter_frame()\", 0);\n\n\ttxptr = db->tx_insert_ptr;\n\tsuptr = (u32 *) txptr->tx_buf_ptr;\n\n\t \n\taddrptr = (const u16 *) dev->dev_addr;\n\t*suptr++ = addrptr[0];\n\t*suptr++ = addrptr[1];\n\t*suptr++ = addrptr[2];\n\n\t \n\t*suptr++ = 0xffff;\n\t*suptr++ = 0xffff;\n\t*suptr++ = 0xffff;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\taddrptr = (u16 *) ha->addr;\n\t\t*suptr++ = addrptr[0];\n\t\t*suptr++ = addrptr[1];\n\t\t*suptr++ = addrptr[2];\n\t}\n\n\tfor (i = netdev_mc_count(dev); i < 14; i++) {\n\t\t*suptr++ = 0xffff;\n\t\t*suptr++ = 0xffff;\n\t\t*suptr++ = 0xffff;\n\t}\n\n\t \n\tdb->tx_insert_ptr = txptr->next_tx_desc;\n\ttxptr->tdes1 = cpu_to_le32(0x890000c0);\n\n\t \n\tif (!db->tx_packet_cnt) {\n\t\tvoid __iomem *ioaddr = db->ioaddr;\n\n\t\t \n\t\tdb->tx_packet_cnt++;\n\t\ttxptr->tdes0 = cpu_to_le32(0x80000000);\n\t\tupdate_cr6(db->cr6_data | 0x2000, ioaddr);\n\t\tdw32(DCR1, 0x1);\t \n\t\tupdate_cr6(db->cr6_data, ioaddr);\n\t\tnetif_trans_update(dev);\n\t} else\n\t\tdb->tx_queue_cnt++;\t \n}\n\n\n \n\nstatic void allocate_rx_buffer(struct net_device *dev)\n{\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tstruct rx_desc *rxptr;\n\tstruct sk_buff *skb;\n\n\trxptr = db->rx_insert_ptr;\n\n\twhile(db->rx_avail_cnt < RX_DESC_CNT) {\n\t\tif ( ( skb = netdev_alloc_skb(dev, RX_ALLOC_SIZE) ) == NULL )\n\t\t\tbreak;\n\t\trxptr->rx_skb_ptr = skb;  \n\t\trxptr->rdes2 = cpu_to_le32(dma_map_single(&db->pdev->dev, skb->data,\n\t\t\t\t\t\t\t  RX_ALLOC_SIZE, DMA_FROM_DEVICE));\n\t\twmb();\n\t\trxptr->rdes0 = cpu_to_le32(0x80000000);\n\t\trxptr = rxptr->next_rx_desc;\n\t\tdb->rx_avail_cnt++;\n\t}\n\n\tdb->rx_insert_ptr = rxptr;\n}\n\nstatic void srom_clk_write(void __iomem *ioaddr, u32 data)\n{\n\tstatic const u32 cmd[] = {\n\t\tCR9_SROM_READ | CR9_SRCS,\n\t\tCR9_SROM_READ | CR9_SRCS | CR9_SRCLK,\n\t\tCR9_SROM_READ | CR9_SRCS\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cmd); i++) {\n\t\tdw32(DCR9, data | cmd[i]);\n\t\tudelay(5);\n\t}\n}\n\n \nstatic u16 read_srom_word(void __iomem *ioaddr, int offset)\n{\n\tu16 srom_data;\n\tint i;\n\n\tdw32(DCR9, CR9_SROM_READ);\n\tudelay(5);\n\tdw32(DCR9, CR9_SROM_READ | CR9_SRCS);\n\tudelay(5);\n\n\t \n\tsrom_clk_write(ioaddr, SROM_DATA_1);\n\tsrom_clk_write(ioaddr, SROM_DATA_1);\n\tsrom_clk_write(ioaddr, SROM_DATA_0);\n\n\t \n\tfor (i = 5; i >= 0; i--) {\n\t\tsrom_data = (offset & (1 << i)) ? SROM_DATA_1 : SROM_DATA_0;\n\t\tsrom_clk_write(ioaddr, srom_data);\n\t}\n\n\tdw32(DCR9, CR9_SROM_READ | CR9_SRCS);\n\tudelay(5);\n\n\tfor (i = 16; i > 0; i--) {\n\t\tdw32(DCR9, CR9_SROM_READ | CR9_SRCS | CR9_SRCLK);\n\t\tudelay(5);\n\t\tsrom_data = (srom_data << 1) |\n\t\t\t\t((dr32(DCR9) & CR9_CRDOUT) ? 1 : 0);\n\t\tdw32(DCR9, CR9_SROM_READ | CR9_SRCS);\n\t\tudelay(5);\n\t}\n\n\tdw32(DCR9, CR9_SROM_READ);\n\tudelay(5);\n\treturn srom_data;\n}\n\n\n \n\nstatic u8 dmfe_sense_speed(struct dmfe_board_info *db)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu8 ErrFlag = 0;\n\tu16 phy_mode;\n\n\t \n\tupdate_cr6(db->cr6_data & ~0x40000, ioaddr);\n\n\tphy_mode = dmfe_phy_read(db->ioaddr, db->phy_addr, 1, db->chip_id);\n\tphy_mode = dmfe_phy_read(db->ioaddr, db->phy_addr, 1, db->chip_id);\n\n\tif ( (phy_mode & 0x24) == 0x24 ) {\n\t\tif (db->chip_id == PCI_DM9132_ID)\t \n\t\t\tphy_mode = dmfe_phy_read(db->ioaddr,\n\t\t\t\t\t\t db->phy_addr, 7, db->chip_id) & 0xf000;\n\t\telse \t\t\t\t \n\t\t\tphy_mode = dmfe_phy_read(db->ioaddr,\n\t\t\t\t\t\t db->phy_addr, 17, db->chip_id) & 0xf000;\n\t\tswitch (phy_mode) {\n\t\tcase 0x1000: db->op_mode = DMFE_10MHF; break;\n\t\tcase 0x2000: db->op_mode = DMFE_10MFD; break;\n\t\tcase 0x4000: db->op_mode = DMFE_100MHF; break;\n\t\tcase 0x8000: db->op_mode = DMFE_100MFD; break;\n\t\tdefault: db->op_mode = DMFE_10MHF;\n\t\t\tErrFlag = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdb->op_mode = DMFE_10MHF;\n\t\tDMFE_DBUG(0, \"Link Failed :\", phy_mode);\n\t\tErrFlag = 1;\n\t}\n\n\treturn ErrFlag;\n}\n\n\n \n\nstatic void dmfe_set_phyxcer(struct dmfe_board_info *db)\n{\n\tvoid __iomem *ioaddr = db->ioaddr;\n\tu16 phy_reg;\n\n\t \n\tdb->cr6_data &= ~0x40000;\n\tupdate_cr6(db->cr6_data, ioaddr);\n\n\t \n\tif (db->chip_id == PCI_DM9009_ID) {\n\t\tphy_reg = dmfe_phy_read(db->ioaddr,\n\t\t\t\t\tdb->phy_addr, 18, db->chip_id) & ~0x1000;\n\n\t\tdmfe_phy_write(db->ioaddr,\n\t\t\t       db->phy_addr, 18, phy_reg, db->chip_id);\n\t}\n\n\t \n\tphy_reg = dmfe_phy_read(db->ioaddr, db->phy_addr, 4, db->chip_id) & ~0x01e0;\n\n\tif (db->media_mode & DMFE_AUTO) {\n\t\t \n\t\tphy_reg |= db->PHY_reg4;\n\t} else {\n\t\t \n\t\tswitch(db->media_mode) {\n\t\tcase DMFE_10MHF: phy_reg |= 0x20; break;\n\t\tcase DMFE_10MFD: phy_reg |= 0x40; break;\n\t\tcase DMFE_100MHF: phy_reg |= 0x80; break;\n\t\tcase DMFE_100MFD: phy_reg |= 0x100; break;\n\t\t}\n\t\tif (db->chip_id == PCI_DM9009_ID) phy_reg &= 0x61;\n\t}\n\n\t \n\tif ( !(phy_reg & 0x01e0)) {\n\t\tphy_reg|=db->PHY_reg4;\n\t\tdb->media_mode|=DMFE_AUTO;\n\t}\n\tdmfe_phy_write(db->ioaddr, db->phy_addr, 4, phy_reg, db->chip_id);\n\n\t \n\tif ( db->chip_type && (db->chip_id == PCI_DM9102_ID) )\n\t\tdmfe_phy_write(db->ioaddr, db->phy_addr, 0, 0x1800, db->chip_id);\n\tif ( !db->chip_type )\n\t\tdmfe_phy_write(db->ioaddr, db->phy_addr, 0, 0x1200, db->chip_id);\n}\n\n\n \n\nstatic void dmfe_process_mode(struct dmfe_board_info *db)\n{\n\tu16 phy_reg;\n\n\t \n\tif (db->op_mode & 0x4)\n\t\tdb->cr6_data |= CR6_FDM;\t \n\telse\n\t\tdb->cr6_data &= ~CR6_FDM;\t \n\n\t \n\tif (db->op_mode & 0x10)\t\t \n\t\tdb->cr6_data |= 0x40000; \n\telse\n\t\tdb->cr6_data &= ~0x40000; \n\n\tupdate_cr6(db->cr6_data, db->ioaddr);\n\n\t \n\tif ( !(db->media_mode & 0x18)) {\n\t\t \n\t\tphy_reg = dmfe_phy_read(db->ioaddr, db->phy_addr, 6, db->chip_id);\n\t\tif ( !(phy_reg & 0x1) ) {\n\t\t\t \n\t\t\tphy_reg = 0x0;\n\t\t\tswitch(db->op_mode) {\n\t\t\tcase DMFE_10MHF: phy_reg = 0x0; break;\n\t\t\tcase DMFE_10MFD: phy_reg = 0x100; break;\n\t\t\tcase DMFE_100MHF: phy_reg = 0x2000; break;\n\t\t\tcase DMFE_100MFD: phy_reg = 0x2100; break;\n\t\t\t}\n\t\t\tdmfe_phy_write(db->ioaddr,\n\t\t\t\t       db->phy_addr, 0, phy_reg, db->chip_id);\n\t\t\tif ( db->chip_type && (db->chip_id == PCI_DM9102_ID) )\n\t\t\t\tmdelay(20);\n\t\t\tdmfe_phy_write(db->ioaddr,\n\t\t\t\t       db->phy_addr, 0, phy_reg, db->chip_id);\n\t\t}\n\t}\n}\n\n\n \n\nstatic void dmfe_phy_write(void __iomem *ioaddr, u8 phy_addr, u8 offset,\n\t\t\t   u16 phy_data, u32 chip_id)\n{\n\tu16 i;\n\n\tif (chip_id == PCI_DM9132_ID) {\n\t\tdw16(0x80 + offset * 4, phy_data);\n\t} else {\n\t\t \n\n\t\t \n\t\tfor (i = 0; i < 35; i++)\n\t\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_1);\n\n\t\t \n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_0);\n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_1);\n\n\t\t \n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_0);\n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_1);\n\n\t\t \n\t\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\t\tdmfe_phy_write_1bit(ioaddr,\n\t\t\t\t\t    phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t\t \n\t\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\t\tdmfe_phy_write_1bit(ioaddr,\n\t\t\t\t\t    offset & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t\t \n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_1);\n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_0);\n\n\t\t \n\t\tfor ( i = 0x8000; i > 0; i >>= 1)\n\t\t\tdmfe_phy_write_1bit(ioaddr,\n\t\t\t\t\t    phy_data & i ? PHY_DATA_1 : PHY_DATA_0);\n\t}\n}\n\n\n \n\nstatic u16 dmfe_phy_read(void __iomem *ioaddr, u8 phy_addr, u8 offset, u32 chip_id)\n{\n\tint i;\n\tu16 phy_data;\n\n\tif (chip_id == PCI_DM9132_ID) {\n\t\t \n\t\tphy_data = dr16(0x80 + offset * 4);\n\t} else {\n\t\t \n\n\t\t \n\t\tfor (i = 0; i < 35; i++)\n\t\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_1);\n\n\t\t \n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_0);\n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_1);\n\n\t\t \n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_1);\n\t\tdmfe_phy_write_1bit(ioaddr, PHY_DATA_0);\n\n\t\t \n\t\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\t\tdmfe_phy_write_1bit(ioaddr,\n\t\t\t\t\t    phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t\t \n\t\tfor (i = 0x10; i > 0; i = i >> 1)\n\t\t\tdmfe_phy_write_1bit(ioaddr,\n\t\t\t\t\t    offset & i ? PHY_DATA_1 : PHY_DATA_0);\n\n\t\t \n\t\tdmfe_phy_read_1bit(ioaddr);\n\n\t\t \n\t\tfor (phy_data = 0, i = 0; i < 16; i++) {\n\t\t\tphy_data <<= 1;\n\t\t\tphy_data |= dmfe_phy_read_1bit(ioaddr);\n\t\t}\n\t}\n\n\treturn phy_data;\n}\n\n\n \n\nstatic void dmfe_phy_write_1bit(void __iomem *ioaddr, u32 phy_data)\n{\n\tdw32(DCR9, phy_data);\t\t \n\tudelay(1);\n\tdw32(DCR9, phy_data | MDCLKH);\t \n\tudelay(1);\n\tdw32(DCR9, phy_data);\t\t \n\tudelay(1);\n}\n\n\n \n\nstatic u16 dmfe_phy_read_1bit(void __iomem *ioaddr)\n{\n\tu16 phy_data;\n\n\tdw32(DCR9, 0x50000);\n\tudelay(1);\n\tphy_data = (dr32(DCR9) >> 19) & 0x1;\n\tdw32(DCR9, 0x40000);\n\tudelay(1);\n\n\treturn phy_data;\n}\n\n\n \n\nstatic void dmfe_parse_srom(struct dmfe_board_info * db)\n{\n\tchar * srom = db->srom;\n\tint dmfe_mode, tmp_reg;\n\n\tDMFE_DBUG(0, \"dmfe_parse_srom() \", 0);\n\n\t \n\tdb->cr15_data = CR15_DEFAULT;\n\n\t \n\tif ( ( (int) srom[18] & 0xff) == SROM_V41_CODE) {\n\t\t \n\t\t \n\t\tdb->NIC_capability = le16_to_cpup((__le16 *) (srom + 34));\n\t\tdb->PHY_reg4 = 0;\n\t\tfor (tmp_reg = 1; tmp_reg < 0x10; tmp_reg <<= 1) {\n\t\t\tswitch( db->NIC_capability & tmp_reg ) {\n\t\t\tcase 0x1: db->PHY_reg4 |= 0x0020; break;\n\t\t\tcase 0x2: db->PHY_reg4 |= 0x0040; break;\n\t\t\tcase 0x4: db->PHY_reg4 |= 0x0080; break;\n\t\t\tcase 0x8: db->PHY_reg4 |= 0x0100; break;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdmfe_mode = (le32_to_cpup((__le32 *) (srom + 34)) &\n\t\t\t     le32_to_cpup((__le32 *) (srom + 36)));\n\t\tswitch(dmfe_mode) {\n\t\tcase 0x4: dmfe_media_mode = DMFE_100MHF; break;\t \n\t\tcase 0x2: dmfe_media_mode = DMFE_10MFD; break;\t \n\t\tcase 0x8: dmfe_media_mode = DMFE_100MFD; break;\t \n\t\tcase 0x100:\n\t\tcase 0x200: dmfe_media_mode = DMFE_1M_HPNA; break; \n\t\t}\n\n\t\t \n\t\t \n\t\tif ( (SF_mode & 0x1) || (srom[43] & 0x80) )\n\t\t\tdb->cr15_data |= 0x40;\n\n\t\t \n\t\tif ( (SF_mode & 0x2) || (srom[40] & 0x1) )\n\t\t\tdb->cr15_data |= 0x400;\n\n\t\t \n\t\tif ( (SF_mode & 0x4) || (srom[40] & 0xe) )\n\t\t\tdb->cr15_data |= 0x9800;\n\t}\n\n\t \n\tdb->HPNA_command = 1;\n\n\t \n\tif (HPNA_rx_cmd == 0)\n\t\tdb->HPNA_command |= 0x8000;\n\n\t  \n\tif (HPNA_tx_cmd == 1)\n\t\tswitch(HPNA_mode) {\t \n\t\tcase 0: db->HPNA_command |= 0x0904; break;\n\t\tcase 1: db->HPNA_command |= 0x0a00; break;\n\t\tcase 2: db->HPNA_command |= 0x0506; break;\n\t\tcase 3: db->HPNA_command |= 0x0602; break;\n\t\t}\n\telse\n\t\tswitch(HPNA_mode) {\t \n\t\tcase 0: db->HPNA_command |= 0x0004; break;\n\t\tcase 1: db->HPNA_command |= 0x0000; break;\n\t\tcase 2: db->HPNA_command |= 0x0006; break;\n\t\tcase 3: db->HPNA_command |= 0x0002; break;\n\t\t}\n\n\t \n\tdb->HPNA_present = 0;\n\tupdate_cr6(db->cr6_data | 0x40000, db->ioaddr);\n\ttmp_reg = dmfe_phy_read(db->ioaddr, db->phy_addr, 3, db->chip_id);\n\tif ( ( tmp_reg & 0xfff0 ) == 0xb900 ) {\n\t\t \n\t\tdb->HPNA_timer = 8;\n\t\tif ( dmfe_phy_read(db->ioaddr, db->phy_addr, 31, db->chip_id) == 0x4404) {\n\t\t\t \n\t\t\tdb->HPNA_present = 1;\n\t\t\tdmfe_program_DM9801(db, tmp_reg);\n\t\t} else {\n\t\t\t \n\t\t\tdb->HPNA_present = 2;\n\t\t\tdmfe_program_DM9802(db);\n\t\t}\n\t}\n\n}\n\n\n \n\nstatic void dmfe_program_DM9801(struct dmfe_board_info * db, int HPNA_rev)\n{\n\tuint reg17, reg25;\n\n\tif ( !HPNA_NoiseFloor ) HPNA_NoiseFloor = DM9801_NOISE_FLOOR;\n\tswitch(HPNA_rev) {\n\tcase 0xb900:  \n\t\tdb->HPNA_command |= 0x1000;\n\t\treg25 = dmfe_phy_read(db->ioaddr, db->phy_addr, 24, db->chip_id);\n\t\treg25 = ( (reg25 + HPNA_NoiseFloor) & 0xff) | 0xf000;\n\t\treg17 = dmfe_phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id);\n\t\tbreak;\n\tcase 0xb901:  \n\t\treg25 = dmfe_phy_read(db->ioaddr, db->phy_addr, 25, db->chip_id);\n\t\treg25 = (reg25 & 0xff00) + HPNA_NoiseFloor;\n\t\treg17 = dmfe_phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id);\n\t\treg17 = (reg17 & 0xfff0) + HPNA_NoiseFloor + 3;\n\t\tbreak;\n\tcase 0xb902:  \n\tcase 0xb903:  \n\tdefault:\n\t\tdb->HPNA_command |= 0x1000;\n\t\treg25 = dmfe_phy_read(db->ioaddr, db->phy_addr, 25, db->chip_id);\n\t\treg25 = (reg25 & 0xff00) + HPNA_NoiseFloor - 5;\n\t\treg17 = dmfe_phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id);\n\t\treg17 = (reg17 & 0xfff0) + HPNA_NoiseFloor;\n\t\tbreak;\n\t}\n\tdmfe_phy_write(db->ioaddr, db->phy_addr, 16, db->HPNA_command, db->chip_id);\n\tdmfe_phy_write(db->ioaddr, db->phy_addr, 17, reg17, db->chip_id);\n\tdmfe_phy_write(db->ioaddr, db->phy_addr, 25, reg25, db->chip_id);\n}\n\n\n \n\nstatic void dmfe_program_DM9802(struct dmfe_board_info * db)\n{\n\tuint phy_reg;\n\n\tif ( !HPNA_NoiseFloor ) HPNA_NoiseFloor = DM9802_NOISE_FLOOR;\n\tdmfe_phy_write(db->ioaddr, db->phy_addr, 16, db->HPNA_command, db->chip_id);\n\tphy_reg = dmfe_phy_read(db->ioaddr, db->phy_addr, 25, db->chip_id);\n\tphy_reg = ( phy_reg & 0xff00) + HPNA_NoiseFloor;\n\tdmfe_phy_write(db->ioaddr, db->phy_addr, 25, phy_reg, db->chip_id);\n}\n\n\n \n\nstatic void dmfe_HPNA_remote_cmd_chk(struct dmfe_board_info * db)\n{\n\tuint phy_reg;\n\n\t \n\tphy_reg = dmfe_phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id) & 0x60;\n\tswitch(phy_reg) {\n\tcase 0x00: phy_reg = 0x0a00;break;  \n\tcase 0x20: phy_reg = 0x0900;break;  \n\tcase 0x40: phy_reg = 0x0600;break;  \n\tcase 0x60: phy_reg = 0x0500;break;  \n\t}\n\n\t \n\tif ( phy_reg != (db->HPNA_command & 0x0f00) ) {\n\t\tdmfe_phy_write(db->ioaddr, db->phy_addr, 16, db->HPNA_command,\n\t\t\t       db->chip_id);\n\t\tdb->HPNA_timer=8;\n\t} else\n\t\tdb->HPNA_timer=600;\t \n}\n\n\n\nstatic const struct pci_device_id dmfe_pci_tbl[] = {\n\t{ 0x1282, 0x9132, PCI_ANY_ID, PCI_ANY_ID, 0, 0, PCI_DM9132_ID },\n\t{ 0x1282, 0x9102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, PCI_DM9102_ID },\n\t{ 0x1282, 0x9100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, PCI_DM9100_ID },\n\t{ 0x1282, 0x9009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, PCI_DM9009_ID },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, dmfe_pci_tbl);\n\nstatic int __maybe_unused dmfe_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct dmfe_board_info *db = netdev_priv(dev);\n\tvoid __iomem *ioaddr = db->ioaddr;\n\n\t \n\tnetif_device_detach(dev);\n\n\t \n\tdb->cr6_data &= ~(CR6_RXSC | CR6_TXSC);\n\tupdate_cr6(db->cr6_data, ioaddr);\n\n\t \n\tdw32(DCR7, 0);\n\tdw32(DCR5, dr32(DCR5));\n\n\t \n\tdmfe_free_rxbuffer(db);\n\n\t \n\tdevice_wakeup_enable(dev_d);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dmfe_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\t \n\tdmfe_init_dm910x(dev);\n\n\t \n\tdevice_wakeup_disable(dev_d);\n\n\t \n\tnetif_device_attach(dev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(dmfe_pm_ops, dmfe_suspend, dmfe_resume);\n\nstatic struct pci_driver dmfe_driver = {\n\t.name\t\t= \"dmfe\",\n\t.id_table\t= dmfe_pci_tbl,\n\t.probe\t\t= dmfe_init_one,\n\t.remove\t\t= dmfe_remove_one,\n\t.driver.pm\t= &dmfe_pm_ops,\n};\n\nMODULE_AUTHOR(\"Sten Wang, sten_wang@davicom.com.tw\");\nMODULE_DESCRIPTION(\"Davicom DM910X fast ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(debug, int, 0);\nmodule_param(mode, byte, 0);\nmodule_param(cr6set, int, 0);\nmodule_param(chkmode, byte, 0);\nmodule_param(HPNA_mode, byte, 0);\nmodule_param(HPNA_rx_cmd, byte, 0);\nmodule_param(HPNA_tx_cmd, byte, 0);\nmodule_param(HPNA_NoiseFloor, byte, 0);\nmodule_param(SF_mode, byte, 0);\nMODULE_PARM_DESC(debug, \"Davicom DM9xxx enable debugging (0-1)\");\nMODULE_PARM_DESC(mode, \"Davicom DM9xxx: \"\n\t\t\"Bit 0: 10/100Mbps, bit 2: duplex, bit 8: HomePNA\");\n\nMODULE_PARM_DESC(SF_mode, \"Davicom DM9xxx special function \"\n\t\t\"(bit 0: VLAN, bit 1 Flow Control, bit 2: TX pause packet)\");\n\n \n\nstatic int __init dmfe_init_module(void)\n{\n\tint rc;\n\n\tDMFE_DBUG(0, \"init_module() \", debug);\n\n\tif (debug)\n\t\tdmfe_debug = debug;\t \n\tif (cr6set)\n\t\tdmfe_cr6_user_set = cr6set;\n\n\tswitch (mode) {\n\tcase DMFE_10MHF:\n\tcase DMFE_100MHF:\n\tcase DMFE_10MFD:\n\tcase DMFE_100MFD:\n\tcase DMFE_1M_HPNA:\n\t\tdmfe_media_mode = mode;\n\t\tbreak;\n\tdefault:\n\t\tdmfe_media_mode = DMFE_AUTO;\n\t\tbreak;\n\t}\n\n\tif (HPNA_mode > 4)\n\t\tHPNA_mode = 0;\t\t \n\tif (HPNA_rx_cmd > 1)\n\t\tHPNA_rx_cmd = 0;\t \n\tif (HPNA_tx_cmd > 1)\n\t\tHPNA_tx_cmd = 0;\t \n\tif (HPNA_NoiseFloor > 15)\n\t\tHPNA_NoiseFloor = 0;\n\n\trc = pci_register_driver(&dmfe_driver);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n\n \n\nstatic void __exit dmfe_cleanup_module(void)\n{\n\tDMFE_DBUG(0, \"dmfe_cleanup_module() \", debug);\n\tpci_unregister_driver(&dmfe_driver);\n}\n\nmodule_init(dmfe_init_module);\nmodule_exit(dmfe_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}