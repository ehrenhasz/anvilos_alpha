{
  "module_name": "interrupt.c",
  "hash_id": "c9fdf6661f80533bc2d8a48462519b839b3137fd93696d45501abced0c080f75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dec/tulip/interrupt.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include \"tulip.h\"\n#include <linux/etherdevice.h>\n\nint tulip_rx_copybreak;\nunsigned int tulip_max_interrupt_work;\n\n#ifdef CONFIG_TULIP_NAPI_HW_MITIGATION\n#define MIT_SIZE 15\n#define MIT_TABLE 15  \n\nstatic unsigned int mit_table[MIT_SIZE+1] =\n{\n         \n\n        0x0,              \n        0x80150000,       \n        0x80150000,\n        0x80270000,\n        0x80370000,\n        0x80490000,\n        0x80590000,\n        0x80690000,\n        0x807B0000,\n        0x808B0000,\n        0x809D0000,\n        0x80AD0000,\n        0x80BD0000,\n        0x80CF0000,\n        0x80DF0000,\n\n        0x80F10000       \n};\n#endif\n\n\nint tulip_refill_rx(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint entry;\n\tint refilled = 0;\n\n\t \n\tfor (; tp->cur_rx - tp->dirty_rx > 0; tp->dirty_rx++) {\n\t\tentry = tp->dirty_rx % RX_RING_SIZE;\n\t\tif (tp->rx_buffers[entry].skb == NULL) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tdma_addr_t mapping;\n\n\t\t\tskb = tp->rx_buffers[entry].skb =\n\t\t\t\tnetdev_alloc_skb(dev, PKT_BUF_SZ);\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\n\n\t\t\tmapping = dma_map_single(&tp->pdev->dev, skb->data,\n\t\t\t\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&tp->pdev->dev, mapping)) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\ttp->rx_buffers[entry].skb = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttp->rx_buffers[entry].mapping = mapping;\n\n\t\t\ttp->rx_ring[entry].buffer1 = cpu_to_le32(mapping);\n\t\t\trefilled++;\n\t\t}\n\t\ttp->rx_ring[entry].status = cpu_to_le32(DescOwned);\n\t}\n\tif(tp->chip_id == LC82C168) {\n\t\tif(((ioread32(tp->base_addr + CSR5)>>17)&0x07) == 4) {\n\t\t\t \n\t\t\tiowrite32(0x01, tp->base_addr + CSR2);\n\t\t}\n\t}\n\treturn refilled;\n}\n\n#ifdef CONFIG_TULIP_NAPI\n\nvoid oom_timer(struct timer_list *t)\n{\n\tstruct tulip_private *tp = from_timer(tp, t, oom_timer);\n\n\tnapi_schedule(&tp->napi);\n}\n\nint tulip_poll(struct napi_struct *napi, int budget)\n{\n\tstruct tulip_private *tp = container_of(napi, struct tulip_private, napi);\n\tstruct net_device *dev = tp->dev;\n\tint entry = tp->cur_rx % RX_RING_SIZE;\n\tint work_done = 0;\n#ifdef CONFIG_TULIP_NAPI_HW_MITIGATION\n\tint received = 0;\n#endif\n\n#ifdef CONFIG_TULIP_NAPI_HW_MITIGATION\n\n \n\n        if (budget >=RX_RING_SIZE) budget--;\n#endif\n\n\tif (tulip_debug > 4)\n\t\tnetdev_dbg(dev, \" In tulip_rx(), entry %d %08x\\n\",\n\t\t\t   entry, tp->rx_ring[entry].status);\n\n       do {\n\t\tif (ioread32(tp->base_addr + CSR5) == 0xffffffff) {\n\t\t\tnetdev_dbg(dev, \" In tulip_poll(), hardware disappeared\\n\");\n\t\t\tbreak;\n\t\t}\n                \n               iowrite32((RxIntr | RxNoBuf), tp->base_addr + CSR5);\n\n\n                \n               while ( ! (tp->rx_ring[entry].status & cpu_to_le32(DescOwned))) {\n                       s32 status = le32_to_cpu(tp->rx_ring[entry].status);\n\t\t       short pkt_len;\n\n                       if (tp->dirty_rx + RX_RING_SIZE == tp->cur_rx)\n                               break;\n\n\t\t       if (tulip_debug > 5)\n\t\t\t\tnetdev_dbg(dev, \"In tulip_rx(), entry %d %08x\\n\",\n\t\t\t\t\t   entry, status);\n\n\t\t       if (++work_done >= budget)\n                               goto not_done;\n\n\t\t        \n\t\t       pkt_len = ((status >> 16) & 0x7ff) - 4;\n\n\t\t        \n\n\t\t       if ((status & (RxLengthOver2047 |\n\t\t\t\t      RxDescCRCError |\n\t\t\t\t      RxDescCollisionSeen |\n\t\t\t\t      RxDescRunt |\n\t\t\t\t      RxDescDescErr |\n\t\t\t\t      RxWholePkt)) != RxWholePkt ||\n\t\t\t   pkt_len > 1518) {\n\t\t\t       if ((status & (RxLengthOver2047 |\n\t\t\t\t\t      RxWholePkt)) != RxWholePkt) {\n                                 \n                                       if ((status & 0xffff) != 0x7fff) {\n                                               if (tulip_debug > 1)\n                                                       dev_warn(&dev->dev,\n\t\t\t\t\t\t\t\t\"Oversized Ethernet frame spanned multiple buffers, status %08x!\\n\",\n\t\t\t\t\t\t\t\tstatus);\n\t\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\t\t}\n\t\t\t       } else {\n                                 \n\t\t\t\t       if (tulip_debug > 2)\n\t\t\t\t\t\tnetdev_dbg(dev, \"Receive error, Rx status %08x\\n\",\n\t\t\t\t\t\t\t   status);\n\t\t\t\t\tdev->stats.rx_errors++;  \n\t\t\t\t\tif (pkt_len > 1518 ||\n\t\t\t\t\t    (status & RxDescRunt))\n\t\t\t\t\t\tdev->stats.rx_length_errors++;\n\n\t\t\t\t\tif (status & 0x0004)\n\t\t\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\t\tif (status & 0x0002)\n\t\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\t\tif (status & 0x0001)\n\t\t\t\t\t\tdev->stats.rx_fifo_errors++;\n                               }\n                       } else {\n                               struct sk_buff *skb;\n\n                                \n                               if (pkt_len < tulip_rx_copybreak &&\n                                   (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n                                       skb_reserve(skb, 2);     \n\t\t\t\t\tdma_sync_single_for_cpu(&tp->pdev->dev,\n\t\t\t\t\t\t\t\ttp->rx_buffers[entry].mapping,\n\t\t\t\t\t\t\t\tpkt_len,\n\t\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n#if ! defined(__alpha__)\n                                       skb_copy_to_linear_data(skb, tp->rx_buffers[entry].skb->data,\n                                                        pkt_len);\n                                       skb_put(skb, pkt_len);\n#else\n                                       skb_put_data(skb,\n                                                    tp->rx_buffers[entry].skb->data,\n                                                    pkt_len);\n#endif\n\t\t\t\t\tdma_sync_single_for_device(&tp->pdev->dev,\n\t\t\t\t\t\t\t\t   tp->rx_buffers[entry].mapping,\n\t\t\t\t\t\t\t\t   pkt_len,\n\t\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n                               } else {         \n                                       char *temp = skb_put(skb = tp->rx_buffers[entry].skb,\n                                                            pkt_len);\n\n#ifndef final_version\n                                       if (tp->rx_buffers[entry].mapping !=\n                                           le32_to_cpu(tp->rx_ring[entry].buffer1)) {\n                                               dev_err(&dev->dev,\n\t\t\t\t\t\t       \"Internal fault: The skbuff addresses do not match in tulip_rx: %08x vs. %08llx %p / %p\\n\",\n\t\t\t\t\t\t       le32_to_cpu(tp->rx_ring[entry].buffer1),\n\t\t\t\t\t\t       (unsigned long long)tp->rx_buffers[entry].mapping,\n\t\t\t\t\t\t       skb->head, temp);\n                                       }\n#endif\n\n\t\t\t\t\tdma_unmap_single(&tp->pdev->dev,\n\t\t\t\t\t\t\t tp->rx_buffers[entry].mapping,\n\t\t\t\t\t\t\t PKT_BUF_SZ,\n\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\n                                       tp->rx_buffers[entry].skb = NULL;\n                                       tp->rx_buffers[entry].mapping = 0;\n                               }\n                               skb->protocol = eth_type_trans(skb, dev);\n\n                               netif_receive_skb(skb);\n\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n                       }\n#ifdef CONFIG_TULIP_NAPI_HW_MITIGATION\n\t\t       received++;\n#endif\n\n                       entry = (++tp->cur_rx) % RX_RING_SIZE;\n                       if (tp->cur_rx - tp->dirty_rx > RX_RING_SIZE/4)\n                               tulip_refill_rx(dev);\n\n                }\n\n                \n\n                \n       } while ((ioread32(tp->base_addr + CSR5) & RxIntr));\n\n #ifdef CONFIG_TULIP_NAPI_HW_MITIGATION\n\n           \n\n\n          if( tp->flags &  HAS_INTR_MITIGATION) {\n                 if( received > 1 ) {\n                         if( ! tp->mit_on ) {\n                                 tp->mit_on = 1;\n                                 iowrite32(mit_table[MIT_TABLE], tp->base_addr + CSR11);\n                         }\n                  }\n                 else {\n                         if( tp->mit_on ) {\n                                 tp->mit_on = 0;\n                                 iowrite32(0, tp->base_addr + CSR11);\n                         }\n                  }\n          }\n\n#endif  \n\n         tulip_refill_rx(dev);\n\n          \n         if (tp->rx_buffers[tp->dirty_rx % RX_RING_SIZE].skb == NULL)\n\t\t goto oom;\n\n          \n\n\tnapi_complete_done(napi, work_done);\n\tiowrite32(tulip_tbl[tp->chip_id].valid_intrs, tp->base_addr+CSR7);\n\n          \n\n         return work_done;\n\n not_done:\n         if (tp->cur_rx - tp->dirty_rx > RX_RING_SIZE/2 ||\n             tp->rx_buffers[tp->dirty_rx % RX_RING_SIZE].skb == NULL)\n                 tulip_refill_rx(dev);\n\n         if (tp->rx_buffers[tp->dirty_rx % RX_RING_SIZE].skb == NULL)\n\t\t goto oom;\n\n         return work_done;\n\n oom:     \n\n          \n         mod_timer(&tp->oom_timer, jiffies+1);\n\n          \n\n          \n         napi_complete_done(napi, work_done);\n\n         return work_done;\n}\n\n#else  \n\nstatic int tulip_rx(struct net_device *dev)\n{\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint entry = tp->cur_rx % RX_RING_SIZE;\n\tint rx_work_limit = tp->dirty_rx + RX_RING_SIZE - tp->cur_rx;\n\tint received = 0;\n\n\tif (tulip_debug > 4)\n\t\tnetdev_dbg(dev, \"In tulip_rx(), entry %d %08x\\n\",\n\t\t\t   entry, tp->rx_ring[entry].status);\n\t \n\twhile ( ! (tp->rx_ring[entry].status & cpu_to_le32(DescOwned))) {\n\t\ts32 status = le32_to_cpu(tp->rx_ring[entry].status);\n\t\tshort pkt_len;\n\n\t\tif (tulip_debug > 5)\n\t\t\tnetdev_dbg(dev, \"In tulip_rx(), entry %d %08x\\n\",\n\t\t\t\t   entry, status);\n\t\tif (--rx_work_limit < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tpkt_len = ((status >> 16) & 0x7ff) - 4;\n\t\t \n\n\t\tif ((status & (RxLengthOver2047 |\n\t\t\t       RxDescCRCError |\n\t\t\t       RxDescCollisionSeen |\n\t\t\t       RxDescRunt |\n\t\t\t       RxDescDescErr |\n\t\t\t       RxWholePkt))        != RxWholePkt ||\n\t\t    pkt_len > 1518) {\n\t\t\tif ((status & (RxLengthOver2047 |\n\t\t\t     RxWholePkt))         != RxWholePkt) {\n\t\t\t\t \n\t\t\t\tif ((status & 0xffff) != 0x7fff) {\n\t\t\t\t\tif (tulip_debug > 1)\n\t\t\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t\t\t    \"Oversized Ethernet frame spanned multiple buffers, status %08x!\\n\",\n\t\t\t\t\t\t\t    status);\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (tulip_debug > 2)\n\t\t\t\t\tnetdev_dbg(dev, \"Receive error, Rx status %08x\\n\",\n\t\t\t\t\t\t   status);\n\t\t\t\tdev->stats.rx_errors++;  \n\t\t\t\tif (pkt_len > 1518 ||\n\t\t\t\t    (status & RxDescRunt))\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tif (status & 0x0004)\n\t\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tif (status & 0x0002)\n\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tif (status & 0x0001)\n\t\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\t \n\t\t\tif (pkt_len < tulip_rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tdma_sync_single_for_cpu(&tp->pdev->dev,\n\t\t\t\t\t\t\ttp->rx_buffers[entry].mapping,\n\t\t\t\t\t\t\tpkt_len,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n#if ! defined(__alpha__)\n\t\t\t\tskb_copy_to_linear_data(skb, tp->rx_buffers[entry].skb->data,\n\t\t\t\t\t\t pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n#else\n\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t     tp->rx_buffers[entry].skb->data,\n\t\t\t\t\t     pkt_len);\n#endif\n\t\t\t\tdma_sync_single_for_device(&tp->pdev->dev,\n\t\t\t\t\t\t\t   tp->rx_buffers[entry].mapping,\n\t\t\t\t\t\t\t   pkt_len,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t} else { \t \n\t\t\t\tchar *temp = skb_put(skb = tp->rx_buffers[entry].skb,\n\t\t\t\t\t\t     pkt_len);\n\n#ifndef final_version\n\t\t\t\tif (tp->rx_buffers[entry].mapping !=\n\t\t\t\t    le32_to_cpu(tp->rx_ring[entry].buffer1)) {\n\t\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\t\"Internal fault: The skbuff addresses do not match in tulip_rx: %08x vs. %Lx %p / %p\\n\",\n\t\t\t\t\t\tle32_to_cpu(tp->rx_ring[entry].buffer1),\n\t\t\t\t\t\t(long long)tp->rx_buffers[entry].mapping,\n\t\t\t\t\t\tskb->head, temp);\n\t\t\t\t}\n#endif\n\n\t\t\t\tdma_unmap_single(&tp->pdev->dev,\n\t\t\t\t\t\t tp->rx_buffers[entry].mapping,\n\t\t\t\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\n\t\t\t\ttp->rx_buffers[entry].skb = NULL;\n\t\t\t\ttp->rx_buffers[entry].mapping = 0;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\t\t\tnetif_rx(skb);\n\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\t\treceived++;\n\t\tentry = (++tp->cur_rx) % RX_RING_SIZE;\n\t}\n\treturn received;\n}\n#endif   \n\nstatic inline unsigned int phy_interrupt (struct net_device *dev)\n{\n#ifdef __hppa__\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tint csr12 = ioread32(tp->base_addr + CSR12) & 0xff;\n\n\tif (csr12 != tp->csr12_shadow) {\n\t\t \n\t\tiowrite32(csr12 | 0x02, tp->base_addr + CSR12);\n\t\ttp->csr12_shadow = csr12;\n\t\t \n\t\tspin_lock(&tp->lock);\n\t\ttulip_check_duplex(dev);\n\t\tspin_unlock(&tp->lock);\n\t\t \n\t\tiowrite32(csr12 & ~0x02, tp->base_addr + CSR12);\n\n\t\treturn 1;\n\t}\n#endif\n\n\treturn 0;\n}\n\n \nirqreturn_t tulip_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = (struct net_device *)dev_instance;\n\tstruct tulip_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->base_addr;\n\tint csr5;\n\tint missed;\n\tint rx = 0;\n\tint tx = 0;\n\tint oi = 0;\n\tint maxrx = RX_RING_SIZE;\n\tint maxtx = TX_RING_SIZE;\n\tint maxoi = TX_RING_SIZE;\n#ifdef CONFIG_TULIP_NAPI\n\tint rxd = 0;\n#else\n\tint entry;\n#endif\n\tunsigned int work_count = tulip_max_interrupt_work;\n\tunsigned int handled = 0;\n\n\t \n\tcsr5 = ioread32(ioaddr + CSR5);\n\n        if (tp->flags & HAS_PHY_IRQ)\n\t        handled = phy_interrupt (dev);\n\n\tif ((csr5 & (NormalIntr|AbnormalIntr)) == 0)\n\t\treturn IRQ_RETVAL(handled);\n\n\ttp->nir++;\n\n\tdo {\n\n#ifdef CONFIG_TULIP_NAPI\n\n\t\tif (!rxd && (csr5 & (RxIntr | RxNoBuf))) {\n\t\t\trxd++;\n\t\t\t \n\t\t\tiowrite32(tulip_tbl[tp->chip_id].valid_intrs&~RxPollInt, ioaddr + CSR7);\n\t\t\tnapi_schedule(&tp->napi);\n\n\t\t\tif (!(csr5&~(AbnormalIntr|NormalIntr|RxPollInt|TPLnkPass)))\n                               break;\n\t\t}\n\n                \n\n\t\tiowrite32(csr5 & 0x0001ff3f, ioaddr + CSR5);\n\n#else\n\t\t \n\t\tiowrite32(csr5 & 0x0001ffff, ioaddr + CSR5);\n\n\n\t\tif (csr5 & (RxIntr | RxNoBuf)) {\n\t\t\t\trx += tulip_rx(dev);\n\t\t\ttulip_refill_rx(dev);\n\t\t}\n\n#endif  \n\n\t\tif (tulip_debug > 4)\n\t\t\tnetdev_dbg(dev, \"interrupt  csr5=%#8.8x new csr5=%#8.8x\\n\",\n\t\t\t\t   csr5, ioread32(ioaddr + CSR5));\n\n\n\t\tif (csr5 & (TxNoBuf | TxDied | TxIntr | TimerInt)) {\n\t\t\tunsigned int dirty_tx;\n\n\t\t\tspin_lock(&tp->lock);\n\n\t\t\tfor (dirty_tx = tp->dirty_tx; tp->cur_tx - dirty_tx > 0;\n\t\t\t\t dirty_tx++) {\n\t\t\t\tint entry = dirty_tx % TX_RING_SIZE;\n\t\t\t\tint status = le32_to_cpu(tp->tx_ring[entry].status);\n\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\t\t\t \n\n\t\t\t\t \n\t\t\t\tif (tp->tx_buffers[entry].skb == NULL) {\n\t\t\t\t\t \n\t\t\t\t\tif (tp->tx_buffers[entry].mapping)\n\t\t\t\t\t\tdma_unmap_single(&tp->pdev->dev,\n\t\t\t\t\t\t\t\t tp->tx_buffers[entry].mapping,\n\t\t\t\t\t\t\t\t sizeof(tp->setup_frame),\n\t\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (status & 0x8000) {\n\t\t\t\t\t \n#ifndef final_version\n\t\t\t\t\tif (tulip_debug > 1)\n\t\t\t\t\t\tnetdev_dbg(dev, \"Transmit error, Tx status %08x\\n\",\n\t\t\t\t\t\t\t   status);\n#endif\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\tif (status & 0x4104)\n\t\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\t\tif (status & 0x0C00)\n\t\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\t\tif (status & 0x0200)\n\t\t\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\t\t\tif (status & 0x0002)\n\t\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t\tif ((status & 0x0080) && tp->full_duplex == 0)\n\t\t\t\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\t\t\t} else {\n\t\t\t\t\tdev->stats.tx_bytes +=\n\t\t\t\t\t\ttp->tx_buffers[entry].skb->len;\n\t\t\t\t\tdev->stats.collisions += (status >> 3) & 15;\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t}\n\n\t\t\t\tdma_unmap_single(&tp->pdev->dev,\n\t\t\t\t\t\t tp->tx_buffers[entry].mapping,\n\t\t\t\t\t\t tp->tx_buffers[entry].skb->len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\t\t \n\t\t\t\tdev_kfree_skb_irq(tp->tx_buffers[entry].skb);\n\t\t\t\ttp->tx_buffers[entry].skb = NULL;\n\t\t\t\ttp->tx_buffers[entry].mapping = 0;\n\t\t\t\ttx++;\n\t\t\t}\n\n#ifndef final_version\n\t\t\tif (tp->cur_tx - dirty_tx > TX_RING_SIZE) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"Out-of-sync dirty pointer, %d vs. %d\\n\",\n\t\t\t\t\tdirty_tx, tp->cur_tx);\n\t\t\t\tdirty_tx += TX_RING_SIZE;\n\t\t\t}\n#endif\n\n\t\t\tif (tp->cur_tx - dirty_tx < TX_RING_SIZE - 2)\n\t\t\t\tnetif_wake_queue(dev);\n\n\t\t\ttp->dirty_tx = dirty_tx;\n\t\t\tif (csr5 & TxDied) {\n\t\t\t\tif (tulip_debug > 2)\n\t\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t\t \"The transmitter stopped.  CSR5 is %x, CSR6 %x, new CSR6 %x\\n\",\n\t\t\t\t\t\t csr5, ioread32(ioaddr + CSR6),\n\t\t\t\t\t\t tp->csr6);\n\t\t\t\ttulip_restart_rxtx(tp);\n\t\t\t}\n\t\t\tspin_unlock(&tp->lock);\n\t\t}\n\n\t\t \n\t\tif (csr5 & AbnormalIntr) {\t \n\t\t\tif (csr5 == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (csr5 & TxJabber)\n\t\t\t\tdev->stats.tx_errors++;\n\t\t\tif (csr5 & TxFIFOUnderflow) {\n\t\t\t\tif ((tp->csr6 & 0xC000) != 0xC000)\n\t\t\t\t\ttp->csr6 += 0x4000;\t \n\t\t\t\telse\n\t\t\t\t\ttp->csr6 |= 0x00200000;   \n\t\t\t\t \n\t\t\t\ttulip_restart_rxtx(tp);\n\t\t\t\tiowrite32(0, ioaddr + CSR1);\n\t\t\t}\n\t\t\tif (csr5 & (RxDied | RxNoBuf)) {\n\t\t\t\tif (tp->flags & COMET_MAC_ADDR) {\n\t\t\t\t\tiowrite32(tp->mc_filter[0], ioaddr + 0xAC);\n\t\t\t\t\tiowrite32(tp->mc_filter[1], ioaddr + 0xB0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (csr5 & RxDied) {\t\t \n\t\t\t\tdev->stats.rx_missed_errors += ioread32(ioaddr + CSR8) & 0xffff;\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\ttulip_start_rxtx(tp);\n\t\t\t}\n\t\t\t \n\t\t\tif (csr5 & (TPLnkPass | TPLnkFail | 0x08000000)) {\n\t\t\t\tif (tp->link_change)\n\t\t\t\t\t(tp->link_change)(dev, csr5);\n\t\t\t}\n\t\t\tif (csr5 & SystemError) {\n\t\t\t\tint error = (csr5 >> 23) & 7;\n\t\t\t\t \n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"(%lu) System Error occurred (%d)\\n\",\n\t\t\t\t\ttp->nir, error);\n\t\t\t}\n\t\t\t \n\t\t\tiowrite32(0x0800f7ba, ioaddr + CSR5);\n\t\t\toi++;\n\t\t}\n\t\tif (csr5 & TimerInt) {\n\n\t\t\tif (tulip_debug > 2)\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"Re-enabling interrupts, %08x\\n\",\n\t\t\t\t\tcsr5);\n\t\t\tiowrite32(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR7);\n\t\t\ttp->ttimer = 0;\n\t\t\toi++;\n\t\t}\n\t\tif (tx > maxtx || rx > maxrx || oi > maxoi) {\n\t\t\tif (tulip_debug > 1)\n\t\t\t\tdev_warn(&dev->dev, \"Too much work during an interrupt, csr5=0x%08x. (%lu) (%d,%d,%d)\\n\",\n\t\t\t\t\t csr5, tp->nir, tx, rx, oi);\n\n                        \n                        iowrite32(0x8001ffff, ioaddr + CSR5);\n                        if (tp->flags & HAS_INTR_MITIGATION) {\n                      \n                                iowrite32(0x8b240000, ioaddr + CSR11);\n                        } else if (tp->chip_id == LC82C168) {\n\t\t\t\t \n\t\t\t\tiowrite32(0x00, ioaddr + CSR7);\n\t\t\t\tmod_timer(&tp->timer, RUN_AT(HZ/50));\n\t\t\t} else {\n                           \n                                iowrite32(((~csr5) & 0x0001ebef) | AbnormalIntr | TimerInt, ioaddr + CSR7);\n                                iowrite32(0x0012, ioaddr + CSR11);\n                        }\n\t\t\tbreak;\n\t\t}\n\n\t\twork_count--;\n\t\tif (work_count == 0)\n\t\t\tbreak;\n\n\t\tcsr5 = ioread32(ioaddr + CSR5);\n\n#ifdef CONFIG_TULIP_NAPI\n\t\tif (rxd)\n\t\t\tcsr5 &= ~RxPollInt;\n\t} while ((csr5 & (TxNoBuf |\n\t\t\t  TxDied |\n\t\t\t  TxIntr |\n\t\t\t  TimerInt |\n\t\t\t   \n\t\t\t  RxDied |\n\t\t\t  TxFIFOUnderflow |\n\t\t\t  TxJabber |\n\t\t\t  TPLnkFail |\n\t\t\t  SystemError )) != 0);\n#else\n\t} while ((csr5 & (NormalIntr|AbnormalIntr)) != 0);\n\n\ttulip_refill_rx(dev);\n\n\t \n\tentry = tp->dirty_rx % RX_RING_SIZE;\n\tif (tp->rx_buffers[entry].skb == NULL) {\n\t\tif (tulip_debug > 1)\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"in rx suspend mode: (%lu) (tp->cur_rx = %u, ttimer = %d, rx = %d) go/stay in suspend mode\\n\",\n\t\t\t\t tp->nir, tp->cur_rx, tp->ttimer, rx);\n\t\tif (tp->chip_id == LC82C168) {\n\t\t\tiowrite32(0x00, ioaddr + CSR7);\n\t\t\tmod_timer(&tp->timer, RUN_AT(HZ/50));\n\t\t} else {\n\t\t\tif (tp->ttimer == 0 || (ioread32(ioaddr + CSR11) & 0xffff) == 0) {\n\t\t\t\tif (tulip_debug > 1)\n\t\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t\t \"in rx suspend mode: (%lu) set timer\\n\",\n\t\t\t\t\t\t tp->nir);\n\t\t\t\tiowrite32(tulip_tbl[tp->chip_id].valid_intrs | TimerInt,\n\t\t\t\t\tioaddr + CSR7);\n\t\t\t\tiowrite32(TimerInt, ioaddr + CSR5);\n\t\t\t\tiowrite32(12, ioaddr + CSR11);\n\t\t\t\ttp->ttimer = 1;\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\n\tif ((missed = ioread32(ioaddr + CSR8) & 0x1ffff)) {\n\t\tdev->stats.rx_dropped += missed & 0x10000 ? 0x10000 : missed;\n\t}\n\n\tif (tulip_debug > 4)\n\t\tnetdev_dbg(dev, \"exiting interrupt, csr5=%#04x\\n\",\n\t\t\t   ioread32(ioaddr + CSR5));\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}