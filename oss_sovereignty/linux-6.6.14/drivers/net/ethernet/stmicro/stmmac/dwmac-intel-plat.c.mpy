{
  "module_name": "dwmac-intel-plat.c",
  "hash_id": "2102c2aac9943db261a1a72855a61db77b67d342c91a9e557d4386c9c2230b45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-intel-plat.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/stmmac.h>\n\n#include \"dwmac4.h\"\n#include \"stmmac.h\"\n#include \"stmmac_platform.h\"\n\nstruct intel_dwmac {\n\tstruct device *dev;\n\tstruct clk *tx_clk;\n\tconst struct intel_dwmac_data *data;\n};\n\nstruct intel_dwmac_data {\n\tvoid (*fix_mac_speed)(void *priv, unsigned int speed, unsigned int mode);\n\tunsigned long ptp_ref_clk_rate;\n\tunsigned long tx_clk_rate;\n\tbool tx_clk_en;\n};\n\nstatic void kmb_eth_fix_mac_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct intel_dwmac *dwmac = priv;\n\tunsigned long rate;\n\tint ret;\n\n\trate = clk_get_rate(dwmac->tx_clk);\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\trate = 125000000;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\trate = 25000000;\n\t\tbreak;\n\n\tcase SPEED_10:\n\t\trate = 2500000;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dwmac->dev, \"Invalid speed\\n\");\n\t\tbreak;\n\t}\n\n\tret = clk_set_rate(dwmac->tx_clk, rate);\n\tif (ret)\n\t\tdev_err(dwmac->dev, \"Failed to configure tx clock rate\\n\");\n}\n\nstatic const struct intel_dwmac_data kmb_data = {\n\t.fix_mac_speed = kmb_eth_fix_mac_speed,\n\t.ptp_ref_clk_rate = 200000000,\n\t.tx_clk_rate = 125000000,\n\t.tx_clk_en = true,\n};\n\nstatic const struct of_device_id intel_eth_plat_match[] = {\n\t{ .compatible = \"intel,keembay-dwmac\", .data = &kmb_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, intel_eth_plat_match);\n\nstatic int intel_eth_plat_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tconst struct of_device_id *match;\n\tstruct intel_dwmac *dwmac;\n\tunsigned long rate;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat)) {\n\t\tdev_err(&pdev->dev, \"dt configuration failed\\n\");\n\t\treturn PTR_ERR(plat_dat);\n\t}\n\n\tdwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->dev = &pdev->dev;\n\tdwmac->tx_clk = NULL;\n\n\tmatch = of_match_device(intel_eth_plat_match, &pdev->dev);\n\tif (match && match->data) {\n\t\tdwmac->data = (const struct intel_dwmac_data *)match->data;\n\n\t\tif (dwmac->data->fix_mac_speed)\n\t\t\tplat_dat->fix_mac_speed = dwmac->data->fix_mac_speed;\n\n\t\t \n\t\tif (dwmac->data->tx_clk_en) {\n\t\t\tdwmac->tx_clk = devm_clk_get(&pdev->dev, \"tx_clk\");\n\t\t\tif (IS_ERR(dwmac->tx_clk)) {\n\t\t\t\tret = PTR_ERR(dwmac->tx_clk);\n\t\t\t\tgoto err_remove_config_dt;\n\t\t\t}\n\n\t\t\tclk_prepare_enable(dwmac->tx_clk);\n\n\t\t\t \n\t\t\trate = clk_get_rate(dwmac->tx_clk);\n\t\t\tif (dwmac->data->tx_clk_rate &&\n\t\t\t    rate != dwmac->data->tx_clk_rate) {\n\t\t\t\trate = dwmac->data->tx_clk_rate;\n\t\t\t\tret = clk_set_rate(dwmac->tx_clk, rate);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\t\"Failed to set tx_clk\\n\");\n\t\t\t\t\tgoto err_remove_config_dt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\trate = clk_get_rate(plat_dat->clk_ptp_ref);\n\t\tif (dwmac->data->ptp_ref_clk_rate &&\n\t\t    rate != dwmac->data->ptp_ref_clk_rate) {\n\t\t\trate = dwmac->data->ptp_ref_clk_rate;\n\t\t\tret = clk_set_rate(plat_dat->clk_ptp_ref, rate);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Failed to set clk_ptp_ref\\n\");\n\t\t\t\tgoto err_remove_config_dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tplat_dat->bsp_priv = dwmac;\n\tplat_dat->eee_usecs_rate = plat_dat->clk_ptp_rate;\n\n\tif (plat_dat->eee_usecs_rate > 0) {\n\t\tu32 tx_lpi_usec;\n\n\t\ttx_lpi_usec = (plat_dat->eee_usecs_rate / 1000000) - 1;\n\t\twritel(tx_lpi_usec, stmmac_res.addr + GMAC_1US_TIC_COUNTER);\n\t}\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret) {\n\t\tclk_disable_unprepare(dwmac->tx_clk);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\treturn 0;\n\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void intel_eth_plat_remove(struct platform_device *pdev)\n{\n\tstruct intel_dwmac *dwmac = get_stmmac_bsp_priv(&pdev->dev);\n\n\tstmmac_pltfr_remove(pdev);\n\tclk_disable_unprepare(dwmac->tx_clk);\n}\n\nstatic struct platform_driver intel_eth_plat_driver = {\n\t.probe  = intel_eth_plat_probe,\n\t.remove_new = intel_eth_plat_remove,\n\t.driver = {\n\t\t.name\t\t= \"intel-eth-plat\",\n\t\t.pm\t\t= &stmmac_pltfr_pm_ops,\n\t\t.of_match_table = intel_eth_plat_match,\n\t},\n};\nmodule_platform_driver(intel_eth_plat_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel DWMAC platform driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}