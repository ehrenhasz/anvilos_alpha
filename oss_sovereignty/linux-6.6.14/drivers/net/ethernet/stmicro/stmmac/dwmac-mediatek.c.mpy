{
  "module_name": "dwmac-mediatek.c",
  "hash_id": "e9e2124c1da8a66590fbe23f986150625ed14a9df323a1e7a123e4c7a8989307",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac.h\"\n#include \"stmmac_platform.h\"\n\n \n#define PERI_ETH_PHY_INTF_SEL\t0x418\n#define PHY_INTF_MII\t\t0\n#define PHY_INTF_RGMII\t\t1\n#define PHY_INTF_RMII\t\t4\n#define RMII_CLK_SRC_RXC\tBIT(4)\n#define RMII_CLK_SRC_INTERNAL\tBIT(5)\n\n#define PERI_ETH_DLY\t0x428\n#define ETH_DLY_GTXC_INV\tBIT(6)\n#define ETH_DLY_GTXC_ENABLE\tBIT(5)\n#define ETH_DLY_GTXC_STAGES\tGENMASK(4, 0)\n#define ETH_DLY_TXC_INV\t\tBIT(20)\n#define ETH_DLY_TXC_ENABLE\tBIT(19)\n#define ETH_DLY_TXC_STAGES\tGENMASK(18, 14)\n#define ETH_DLY_RXC_INV\t\tBIT(13)\n#define ETH_DLY_RXC_ENABLE\tBIT(12)\n#define ETH_DLY_RXC_STAGES\tGENMASK(11, 7)\n\n#define PERI_ETH_DLY_FINE\t0x800\n#define ETH_RMII_DLY_TX_INV\tBIT(2)\n#define ETH_FINE_DLY_GTXC\tBIT(1)\n#define ETH_FINE_DLY_RXC\tBIT(0)\n\n \n#define MT8195_PERI_ETH_CTRL0\t\t0xFD0\n#define MT8195_RMII_CLK_SRC_INTERNAL\tBIT(28)\n#define MT8195_RMII_CLK_SRC_RXC\t\tBIT(27)\n#define MT8195_ETH_INTF_SEL\t\tGENMASK(26, 24)\n#define MT8195_RGMII_TXC_PHASE_CTRL\tBIT(22)\n#define MT8195_EXT_PHY_MODE\t\tBIT(21)\n#define MT8195_DLY_GTXC_INV\t\tBIT(12)\n#define MT8195_DLY_GTXC_ENABLE\t\tBIT(5)\n#define MT8195_DLY_GTXC_STAGES\t\tGENMASK(4, 0)\n\n#define MT8195_PERI_ETH_CTRL1\t\t0xFD4\n#define MT8195_DLY_RXC_INV\t\tBIT(25)\n#define MT8195_DLY_RXC_ENABLE\t\tBIT(18)\n#define MT8195_DLY_RXC_STAGES\t\tGENMASK(17, 13)\n#define MT8195_DLY_TXC_INV\t\tBIT(12)\n#define MT8195_DLY_TXC_ENABLE\t\tBIT(5)\n#define MT8195_DLY_TXC_STAGES\t\tGENMASK(4, 0)\n\n#define MT8195_PERI_ETH_CTRL2\t\t0xFD8\n#define MT8195_DLY_RMII_RXC_INV\t\tBIT(25)\n#define MT8195_DLY_RMII_RXC_ENABLE\tBIT(18)\n#define MT8195_DLY_RMII_RXC_STAGES\tGENMASK(17, 13)\n#define MT8195_DLY_RMII_TXC_INV\t\tBIT(12)\n#define MT8195_DLY_RMII_TXC_ENABLE\tBIT(5)\n#define MT8195_DLY_RMII_TXC_STAGES\tGENMASK(4, 0)\n\nstruct mac_delay_struct {\n\tu32 tx_delay;\n\tu32 rx_delay;\n\tbool tx_inv;\n\tbool rx_inv;\n};\n\nstruct mediatek_dwmac_plat_data {\n\tconst struct mediatek_dwmac_variant *variant;\n\tstruct mac_delay_struct mac_delay;\n\tstruct clk *rmii_internal_clk;\n\tstruct clk_bulk_data *clks;\n\tstruct regmap *peri_regmap;\n\tstruct device_node *np;\n\tstruct device *dev;\n\tphy_interface_t phy_mode;\n\tbool rmii_clk_from_mac;\n\tbool rmii_rxc;\n\tbool mac_wol;\n};\n\nstruct mediatek_dwmac_variant {\n\tint (*dwmac_set_phy_interface)(struct mediatek_dwmac_plat_data *plat);\n\tint (*dwmac_set_delay)(struct mediatek_dwmac_plat_data *plat);\n\n\t \n\tconst char * const *clk_list;\n\tint num_clks;\n\n\tu32 dma_bit_mask;\n\tu32 rx_delay_max;\n\tu32 tx_delay_max;\n};\n\n \nstatic const char * const mt2712_dwmac_clk_l[] = {\n\t\"axi\", \"apb\", \"mac_main\", \"ptp_ref\"\n};\n\nstatic const char * const mt8195_dwmac_clk_l[] = {\n\t\"axi\", \"apb\", \"mac_cg\", \"mac_main\", \"ptp_ref\"\n};\n\nstatic int mt2712_set_interface(struct mediatek_dwmac_plat_data *plat)\n{\n\tint rmii_clk_from_mac = plat->rmii_clk_from_mac ? RMII_CLK_SRC_INTERNAL : 0;\n\tint rmii_rxc = plat->rmii_rxc ? RMII_CLK_SRC_RXC : 0;\n\tu32 intf_val = 0;\n\n\t \n\tswitch (plat->phy_mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tintf_val |= PHY_INTF_MII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tintf_val |= (PHY_INTF_RMII | rmii_rxc | rmii_clk_from_mac);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tintf_val |= PHY_INTF_RGMII;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(plat->dev, \"phy interface not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(plat->peri_regmap, PERI_ETH_PHY_INTF_SEL, intf_val);\n\n\treturn 0;\n}\n\nstatic void mt2712_delay_ps2stage(struct mediatek_dwmac_plat_data *plat)\n{\n\tstruct mac_delay_struct *mac_delay = &plat->mac_delay;\n\n\tswitch (plat->phy_mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\t \n\t\tmac_delay->tx_delay /= 550;\n\t\tmac_delay->rx_delay /= 550;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\t \n\t\tmac_delay->tx_delay /= 170;\n\t\tmac_delay->rx_delay /= 170;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(plat->dev, \"phy interface not supported\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void mt2712_delay_stage2ps(struct mediatek_dwmac_plat_data *plat)\n{\n\tstruct mac_delay_struct *mac_delay = &plat->mac_delay;\n\n\tswitch (plat->phy_mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\t \n\t\tmac_delay->tx_delay *= 550;\n\t\tmac_delay->rx_delay *= 550;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\t \n\t\tmac_delay->tx_delay *= 170;\n\t\tmac_delay->rx_delay *= 170;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(plat->dev, \"phy interface not supported\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic int mt2712_set_delay(struct mediatek_dwmac_plat_data *plat)\n{\n\tstruct mac_delay_struct *mac_delay = &plat->mac_delay;\n\tu32 delay_val = 0, fine_val = 0;\n\n\tmt2712_delay_ps2stage(plat);\n\n\tswitch (plat->phy_mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_ENABLE, !!mac_delay->tx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_STAGES, mac_delay->tx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_INV, mac_delay->tx_inv);\n\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_ENABLE, !!mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_STAGES, mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_INV, mac_delay->rx_inv);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tif (plat->rmii_clk_from_mac) {\n\t\t\t \n\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_ENABLE, !!mac_delay->rx_delay);\n\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_STAGES, mac_delay->rx_delay);\n\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_INV, mac_delay->rx_inv);\n\n\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_GTXC_ENABLE, !!mac_delay->tx_delay);\n\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_GTXC_STAGES, mac_delay->tx_delay);\n\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_GTXC_INV, mac_delay->tx_inv);\n\t\t} else {\n\t\t\t \n\t\t\tif (plat->rmii_rxc) {\n\t\t\t\t \n\t\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_ENABLE, !!mac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_STAGES, mac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_INV, mac_delay->rx_inv);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_ENABLE, !!mac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_STAGES, mac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(ETH_DLY_TXC_INV, mac_delay->rx_inv);\n\t\t\t}\n\t\t\t \n\t\t\tif (mac_delay->tx_inv)\n\t\t\t\tfine_val = ETH_RMII_DLY_TX_INV;\n\t\t}\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tfine_val = ETH_FINE_DLY_GTXC | ETH_FINE_DLY_RXC;\n\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_GTXC_ENABLE, !!mac_delay->tx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_GTXC_STAGES, mac_delay->tx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_GTXC_INV, mac_delay->tx_inv);\n\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_ENABLE, !!mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_STAGES, mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(ETH_DLY_RXC_INV, mac_delay->rx_inv);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(plat->dev, \"phy interface not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tregmap_write(plat->peri_regmap, PERI_ETH_DLY, delay_val);\n\tregmap_write(plat->peri_regmap, PERI_ETH_DLY_FINE, fine_val);\n\n\tmt2712_delay_stage2ps(plat);\n\n\treturn 0;\n}\n\nstatic const struct mediatek_dwmac_variant mt2712_gmac_variant = {\n\t\t.dwmac_set_phy_interface = mt2712_set_interface,\n\t\t.dwmac_set_delay = mt2712_set_delay,\n\t\t.clk_list = mt2712_dwmac_clk_l,\n\t\t.num_clks = ARRAY_SIZE(mt2712_dwmac_clk_l),\n\t\t.dma_bit_mask = 33,\n\t\t.rx_delay_max = 17600,\n\t\t.tx_delay_max = 17600,\n};\n\nstatic int mt8195_set_interface(struct mediatek_dwmac_plat_data *plat)\n{\n\tint rmii_clk_from_mac = plat->rmii_clk_from_mac ? MT8195_RMII_CLK_SRC_INTERNAL : 0;\n\tint rmii_rxc = plat->rmii_rxc ? MT8195_RMII_CLK_SRC_RXC : 0;\n\tu32 intf_val = 0;\n\n\t \n\tswitch (plat->phy_mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tintf_val |= FIELD_PREP(MT8195_ETH_INTF_SEL, PHY_INTF_MII);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tintf_val |= (rmii_rxc | rmii_clk_from_mac);\n\t\tintf_val |= FIELD_PREP(MT8195_ETH_INTF_SEL, PHY_INTF_RMII);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tintf_val |= FIELD_PREP(MT8195_ETH_INTF_SEL, PHY_INTF_RGMII);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(plat->dev, \"phy interface not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tintf_val |= MT8195_EXT_PHY_MODE;\n\n\tregmap_write(plat->peri_regmap, MT8195_PERI_ETH_CTRL0, intf_val);\n\n\treturn 0;\n}\n\nstatic void mt8195_delay_ps2stage(struct mediatek_dwmac_plat_data *plat)\n{\n\tstruct mac_delay_struct *mac_delay = &plat->mac_delay;\n\n\t \n\tmac_delay->tx_delay /= 290;\n\tmac_delay->rx_delay /= 290;\n}\n\nstatic void mt8195_delay_stage2ps(struct mediatek_dwmac_plat_data *plat)\n{\n\tstruct mac_delay_struct *mac_delay = &plat->mac_delay;\n\n\t \n\tmac_delay->tx_delay *= 290;\n\tmac_delay->rx_delay *= 290;\n}\n\nstatic int mt8195_set_delay(struct mediatek_dwmac_plat_data *plat)\n{\n\tstruct mac_delay_struct *mac_delay = &plat->mac_delay;\n\tu32 gtxc_delay_val = 0, delay_val = 0, rmii_delay_val = 0;\n\n\tmt8195_delay_ps2stage(plat);\n\n\tswitch (plat->phy_mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_TXC_ENABLE, !!mac_delay->tx_delay);\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_TXC_STAGES, mac_delay->tx_delay);\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_TXC_INV, mac_delay->tx_inv);\n\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_ENABLE, !!mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_STAGES, mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_INV, mac_delay->rx_inv);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tif (plat->rmii_clk_from_mac) {\n\t\t\t \n\t\t\trmii_delay_val |= FIELD_PREP(MT8195_DLY_RMII_TXC_ENABLE,\n\t\t\t\t\t\t     !!mac_delay->tx_delay);\n\t\t\trmii_delay_val |= FIELD_PREP(MT8195_DLY_RMII_TXC_STAGES,\n\t\t\t\t\t\t     mac_delay->tx_delay);\n\t\t\trmii_delay_val |= FIELD_PREP(MT8195_DLY_RMII_TXC_INV,\n\t\t\t\t\t\t     mac_delay->tx_inv);\n\n\t\t\trmii_delay_val |= FIELD_PREP(MT8195_DLY_RMII_RXC_ENABLE,\n\t\t\t\t\t\t     !!mac_delay->rx_delay);\n\t\t\trmii_delay_val |= FIELD_PREP(MT8195_DLY_RMII_RXC_STAGES,\n\t\t\t\t\t\t     mac_delay->rx_delay);\n\t\t\trmii_delay_val |= FIELD_PREP(MT8195_DLY_RMII_RXC_INV,\n\t\t\t\t\t\t     mac_delay->rx_inv);\n\t\t} else {\n\t\t\t \n\t\t\tif (plat->rmii_rxc) {\n\t\t\t\t \n\t\t\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_ENABLE,\n\t\t\t\t\t\t\t!!mac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_STAGES,\n\t\t\t\t\t\t\tmac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_INV,\n\t\t\t\t\t\t\tmac_delay->rx_inv);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdelay_val |= FIELD_PREP(MT8195_DLY_TXC_ENABLE,\n\t\t\t\t\t\t\t!!mac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(MT8195_DLY_TXC_STAGES,\n\t\t\t\t\t\t\tmac_delay->rx_delay);\n\t\t\t\tdelay_val |= FIELD_PREP(MT8195_DLY_TXC_INV,\n\t\t\t\t\t\t\tmac_delay->rx_inv);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tgtxc_delay_val |= FIELD_PREP(MT8195_DLY_GTXC_ENABLE, !!mac_delay->tx_delay);\n\t\tgtxc_delay_val |= FIELD_PREP(MT8195_DLY_GTXC_STAGES, mac_delay->tx_delay);\n\t\tgtxc_delay_val |= FIELD_PREP(MT8195_DLY_GTXC_INV, mac_delay->tx_inv);\n\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_ENABLE, !!mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_STAGES, mac_delay->rx_delay);\n\t\tdelay_val |= FIELD_PREP(MT8195_DLY_RXC_INV, mac_delay->rx_inv);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(plat->dev, \"phy interface not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(plat->peri_regmap,\n\t\t\t   MT8195_PERI_ETH_CTRL0,\n\t\t\t   MT8195_RGMII_TXC_PHASE_CTRL |\n\t\t\t   MT8195_DLY_GTXC_INV |\n\t\t\t   MT8195_DLY_GTXC_ENABLE |\n\t\t\t   MT8195_DLY_GTXC_STAGES,\n\t\t\t   gtxc_delay_val);\n\tregmap_write(plat->peri_regmap, MT8195_PERI_ETH_CTRL1, delay_val);\n\tregmap_write(plat->peri_regmap, MT8195_PERI_ETH_CTRL2, rmii_delay_val);\n\n\tmt8195_delay_stage2ps(plat);\n\n\treturn 0;\n}\n\nstatic const struct mediatek_dwmac_variant mt8195_gmac_variant = {\n\t.dwmac_set_phy_interface = mt8195_set_interface,\n\t.dwmac_set_delay = mt8195_set_delay,\n\t.clk_list = mt8195_dwmac_clk_l,\n\t.num_clks = ARRAY_SIZE(mt8195_dwmac_clk_l),\n\t.dma_bit_mask = 35,\n\t.rx_delay_max = 9280,\n\t.tx_delay_max = 9280,\n};\n\nstatic int mediatek_dwmac_config_dt(struct mediatek_dwmac_plat_data *plat)\n{\n\tstruct mac_delay_struct *mac_delay = &plat->mac_delay;\n\tu32 tx_delay_ps, rx_delay_ps;\n\tint err;\n\n\tplat->peri_regmap = syscon_regmap_lookup_by_phandle(plat->np, \"mediatek,pericfg\");\n\tif (IS_ERR(plat->peri_regmap)) {\n\t\tdev_err(plat->dev, \"Failed to get pericfg syscon\\n\");\n\t\treturn PTR_ERR(plat->peri_regmap);\n\t}\n\n\terr = of_get_phy_mode(plat->np, &plat->phy_mode);\n\tif (err) {\n\t\tdev_err(plat->dev, \"not find phy-mode\\n\");\n\t\treturn err;\n\t}\n\n\tif (!of_property_read_u32(plat->np, \"mediatek,tx-delay-ps\", &tx_delay_ps)) {\n\t\tif (tx_delay_ps < plat->variant->tx_delay_max) {\n\t\t\tmac_delay->tx_delay = tx_delay_ps;\n\t\t} else {\n\t\t\tdev_err(plat->dev, \"Invalid TX clock delay: %dps\\n\", tx_delay_ps);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!of_property_read_u32(plat->np, \"mediatek,rx-delay-ps\", &rx_delay_ps)) {\n\t\tif (rx_delay_ps < plat->variant->rx_delay_max) {\n\t\t\tmac_delay->rx_delay = rx_delay_ps;\n\t\t} else {\n\t\t\tdev_err(plat->dev, \"Invalid RX clock delay: %dps\\n\", rx_delay_ps);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmac_delay->tx_inv = of_property_read_bool(plat->np, \"mediatek,txc-inverse\");\n\tmac_delay->rx_inv = of_property_read_bool(plat->np, \"mediatek,rxc-inverse\");\n\tplat->rmii_rxc = of_property_read_bool(plat->np, \"mediatek,rmii-rxc\");\n\tplat->rmii_clk_from_mac = of_property_read_bool(plat->np, \"mediatek,rmii-clk-from-mac\");\n\tplat->mac_wol = of_property_read_bool(plat->np, \"mediatek,mac-wol\");\n\n\treturn 0;\n}\n\nstatic int mediatek_dwmac_clk_init(struct mediatek_dwmac_plat_data *plat)\n{\n\tconst struct mediatek_dwmac_variant *variant = plat->variant;\n\tint i, ret;\n\n\tplat->clks = devm_kcalloc(plat->dev, variant->num_clks, sizeof(*plat->clks), GFP_KERNEL);\n\tif (!plat->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < variant->num_clks; i++)\n\t\tplat->clks[i].id = variant->clk_list[i];\n\n\tret = devm_clk_bulk_get(plat->dev, variant->num_clks, plat->clks);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (plat->rmii_clk_from_mac) {\n\t\tplat->rmii_internal_clk = devm_clk_get(plat->dev, \"rmii_internal\");\n\t\tif (IS_ERR(plat->rmii_internal_clk))\n\t\t\tret = PTR_ERR(plat->rmii_internal_clk);\n\t} else {\n\t\tplat->rmii_internal_clk = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int mediatek_dwmac_init(struct platform_device *pdev, void *priv)\n{\n\tstruct mediatek_dwmac_plat_data *plat = priv;\n\tconst struct mediatek_dwmac_variant *variant = plat->variant;\n\tint ret;\n\n\tif (variant->dwmac_set_phy_interface) {\n\t\tret = variant->dwmac_set_phy_interface(plat);\n\t\tif (ret) {\n\t\t\tdev_err(plat->dev, \"failed to set phy interface, err = %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (variant->dwmac_set_delay) {\n\t\tret = variant->dwmac_set_delay(plat);\n\t\tif (ret) {\n\t\t\tdev_err(plat->dev, \"failed to set delay value, err = %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mediatek_dwmac_clks_config(void *priv, bool enabled)\n{\n\tstruct mediatek_dwmac_plat_data *plat = priv;\n\tconst struct mediatek_dwmac_variant *variant = plat->variant;\n\tint ret = 0;\n\n\tif (enabled) {\n\t\tret = clk_bulk_prepare_enable(variant->num_clks, plat->clks);\n\t\tif (ret) {\n\t\t\tdev_err(plat->dev, \"failed to enable clks, err = %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare_enable(plat->rmii_internal_clk);\n\t\tif (ret) {\n\t\t\tdev_err(plat->dev, \"failed to enable rmii internal clk, err = %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tclk_disable_unprepare(plat->rmii_internal_clk);\n\t\tclk_bulk_disable_unprepare(variant->num_clks, plat->clks);\n\t}\n\n\treturn ret;\n}\n\nstatic int mediatek_dwmac_common_data(struct platform_device *pdev,\n\t\t\t\t      struct plat_stmmacenet_data *plat,\n\t\t\t\t      struct mediatek_dwmac_plat_data *priv_plat)\n{\n\tint i;\n\n\tplat->mac_interface = priv_plat->phy_mode;\n\tif (priv_plat->mac_wol)\n\t\tplat->flags |= STMMAC_FLAG_USE_PHY_WOL;\n\telse\n\t\tplat->flags &= ~STMMAC_FLAG_USE_PHY_WOL;\n\tplat->riwt_off = 1;\n\tplat->maxmtu = ETH_DATA_LEN;\n\tplat->host_dma_width = priv_plat->variant->dma_bit_mask;\n\tplat->bsp_priv = priv_plat;\n\tplat->init = mediatek_dwmac_init;\n\tplat->clks_config = mediatek_dwmac_clks_config;\n\n\tplat->safety_feat_cfg = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t     sizeof(*plat->safety_feat_cfg),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!plat->safety_feat_cfg)\n\t\treturn -ENOMEM;\n\n\tplat->safety_feat_cfg->tsoee = 1;\n\tplat->safety_feat_cfg->mrxpee = 0;\n\tplat->safety_feat_cfg->mestee = 1;\n\tplat->safety_feat_cfg->mrxee = 1;\n\tplat->safety_feat_cfg->mtxee = 1;\n\tplat->safety_feat_cfg->epsi = 0;\n\tplat->safety_feat_cfg->edpp = 1;\n\tplat->safety_feat_cfg->prtyen = 1;\n\tplat->safety_feat_cfg->tmouten = 1;\n\n\tfor (i = 0; i < plat->tx_queues_to_use; i++) {\n\t\t \n\t\tif (i > 0)\n\t\t\tplat->tx_queues_cfg[i].tbs_en = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int mediatek_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct mediatek_dwmac_plat_data *priv_plat;\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tint ret;\n\n\tpriv_plat = devm_kzalloc(&pdev->dev, sizeof(*priv_plat), GFP_KERNEL);\n\tif (!priv_plat)\n\t\treturn -ENOMEM;\n\n\tpriv_plat->variant = of_device_get_match_data(&pdev->dev);\n\tif (!priv_plat->variant) {\n\t\tdev_err(&pdev->dev, \"Missing dwmac-mediatek variant\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv_plat->dev = &pdev->dev;\n\tpriv_plat->np = pdev->dev.of_node;\n\n\tret = mediatek_dwmac_config_dt(priv_plat);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mediatek_dwmac_clk_init(priv_plat);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tmediatek_dwmac_common_data(pdev, plat_dat, priv_plat);\n\tmediatek_dwmac_init(pdev, priv_plat);\n\n\tret = mediatek_dwmac_clks_config(priv_plat, true);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto err_drv_probe;\n\n\treturn 0;\n\nerr_drv_probe:\n\tmediatek_dwmac_clks_config(priv_plat, false);\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void mediatek_dwmac_remove(struct platform_device *pdev)\n{\n\tstruct mediatek_dwmac_plat_data *priv_plat = get_stmmac_bsp_priv(&pdev->dev);\n\n\tstmmac_pltfr_remove(pdev);\n\tmediatek_dwmac_clks_config(priv_plat, false);\n}\n\nstatic const struct of_device_id mediatek_dwmac_match[] = {\n\t{ .compatible = \"mediatek,mt2712-gmac\",\n\t  .data = &mt2712_gmac_variant },\n\t{ .compatible = \"mediatek,mt8195-gmac\",\n\t  .data = &mt8195_gmac_variant },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, mediatek_dwmac_match);\n\nstatic struct platform_driver mediatek_dwmac_driver = {\n\t.probe  = mediatek_dwmac_probe,\n\t.remove_new = mediatek_dwmac_remove,\n\t.driver = {\n\t\t.name           = \"dwmac-mediatek\",\n\t\t.pm\t\t= &stmmac_pltfr_pm_ops,\n\t\t.of_match_table = mediatek_dwmac_match,\n\t},\n};\nmodule_platform_driver(mediatek_dwmac_driver);\n\nMODULE_AUTHOR(\"Biao Huang <biao.huang@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek DWMAC specific glue layer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}