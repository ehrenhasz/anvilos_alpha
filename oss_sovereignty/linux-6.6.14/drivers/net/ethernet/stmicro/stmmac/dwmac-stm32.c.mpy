{
  "module_name": "dwmac-stm32.c",
  "hash_id": "2ad8e42a5dd6f8248c14d6a4da14750be98b357feaa7cab6aa596a5ac41beb8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac_platform.h\"\n\n#define SYSCFG_MCU_ETH_MASK\t\tBIT(23)\n#define SYSCFG_MP1_ETH_MASK\t\tGENMASK(23, 16)\n#define SYSCFG_PMCCLRR_OFFSET\t\t0x40\n\n#define SYSCFG_PMCR_ETH_CLK_SEL\t\tBIT(16)\n#define SYSCFG_PMCR_ETH_REF_CLK_SEL\tBIT(17)\n\n \n#define ETH_CK_F_25M\t25000000\n#define ETH_CK_F_50M\t50000000\n#define ETH_CK_F_125M\t125000000\n\n \n#define SYSCFG_PMCR_ETH_SEL_MII\t\tBIT(20)\n#define SYSCFG_PMCR_ETH_SEL_RGMII\tBIT(21)\n#define SYSCFG_PMCR_ETH_SEL_RMII\tBIT(23)\n#define SYSCFG_PMCR_ETH_SEL_GMII\t0\n#define SYSCFG_MCU_ETH_SEL_MII\t\t0\n#define SYSCFG_MCU_ETH_SEL_RMII\t\t1\n\n \n\nstruct stm32_dwmac {\n\tstruct clk *clk_tx;\n\tstruct clk *clk_rx;\n\tstruct clk *clk_eth_ck;\n\tstruct clk *clk_ethstp;\n\tstruct clk *syscfg_clk;\n\tint ext_phyclk;\n\tint enable_eth_ck;\n\tint eth_clk_sel_reg;\n\tint eth_ref_clk_sel_reg;\n\tint irq_pwr_wakeup;\n\tu32 mode_reg;\t\t  \n\tstruct regmap *regmap;\n\tu32 speed;\n\tconst struct stm32_ops *ops;\n\tstruct device *dev;\n};\n\nstruct stm32_ops {\n\tint (*set_mode)(struct plat_stmmacenet_data *plat_dat);\n\tint (*clk_prepare)(struct stm32_dwmac *dwmac, bool prepare);\n\tint (*suspend)(struct stm32_dwmac *dwmac);\n\tvoid (*resume)(struct stm32_dwmac *dwmac);\n\tint (*parse_data)(struct stm32_dwmac *dwmac,\n\t\t\t  struct device *dev);\n\tu32 syscfg_eth_mask;\n\tbool clk_rx_enable_in_suspend;\n};\n\nstatic int stm32_dwmac_init(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct stm32_dwmac *dwmac = plat_dat->bsp_priv;\n\tint ret;\n\n\tif (dwmac->ops->set_mode) {\n\t\tret = dwmac->ops->set_mode(plat_dat);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dwmac->clk_tx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dwmac->ops->clk_rx_enable_in_suspend ||\n\t    !dwmac->dev->power.is_suspended) {\n\t\tret = clk_prepare_enable(dwmac->clk_rx);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(dwmac->clk_tx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (dwmac->ops->clk_prepare) {\n\t\tret = dwmac->ops->clk_prepare(dwmac, true);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(dwmac->clk_rx);\n\t\t\tclk_disable_unprepare(dwmac->clk_tx);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32mp1_clk_prepare(struct stm32_dwmac *dwmac, bool prepare)\n{\n\tint ret = 0;\n\n\tif (prepare) {\n\t\tret = clk_prepare_enable(dwmac->syscfg_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (dwmac->enable_eth_ck) {\n\t\t\tret = clk_prepare_enable(dwmac->clk_eth_ck);\n\t\t\tif (ret) {\n\t\t\t\tclk_disable_unprepare(dwmac->syscfg_clk);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tclk_disable_unprepare(dwmac->syscfg_clk);\n\t\tif (dwmac->enable_eth_ck)\n\t\t\tclk_disable_unprepare(dwmac->clk_eth_ck);\n\t}\n\treturn ret;\n}\n\nstatic int stm32mp1_set_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct stm32_dwmac *dwmac = plat_dat->bsp_priv;\n\tu32 reg = dwmac->mode_reg, clk_rate;\n\tint val;\n\n\tclk_rate = clk_get_rate(dwmac->clk_eth_ck);\n\tdwmac->enable_eth_ck = false;\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tif (clk_rate == ETH_CK_F_25M && dwmac->ext_phyclk)\n\t\t\tdwmac->enable_eth_ck = true;\n\t\tval = SYSCFG_PMCR_ETH_SEL_MII;\n\t\tpr_debug(\"SYSCFG init : PHY_INTERFACE_MODE_MII\\n\");\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tval = SYSCFG_PMCR_ETH_SEL_GMII;\n\t\tif (clk_rate == ETH_CK_F_25M &&\n\t\t    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {\n\t\t\tdwmac->enable_eth_ck = true;\n\t\t\tval |= SYSCFG_PMCR_ETH_CLK_SEL;\n\t\t}\n\t\tpr_debug(\"SYSCFG init : PHY_INTERFACE_MODE_GMII\\n\");\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = SYSCFG_PMCR_ETH_SEL_RMII;\n\t\tif ((clk_rate == ETH_CK_F_25M || clk_rate == ETH_CK_F_50M) &&\n\t\t    (dwmac->eth_ref_clk_sel_reg || dwmac->ext_phyclk)) {\n\t\t\tdwmac->enable_eth_ck = true;\n\t\t\tval |= SYSCFG_PMCR_ETH_REF_CLK_SEL;\n\t\t}\n\t\tpr_debug(\"SYSCFG init : PHY_INTERFACE_MODE_RMII\\n\");\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tval = SYSCFG_PMCR_ETH_SEL_RGMII;\n\t\tif ((clk_rate == ETH_CK_F_25M || clk_rate == ETH_CK_F_125M) &&\n\t\t    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {\n\t\t\tdwmac->enable_eth_ck = true;\n\t\t\tval |= SYSCFG_PMCR_ETH_CLK_SEL;\n\t\t}\n\t\tpr_debug(\"SYSCFG init : PHY_INTERFACE_MODE_RGMII\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"SYSCFG init :  Do not manage %d interface\\n\",\n\t\t\t plat_dat->mac_interface);\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_write(dwmac->regmap, reg + SYSCFG_PMCCLRR_OFFSET,\n\t\t     dwmac->ops->syscfg_eth_mask);\n\n\t \n\treturn regmap_update_bits(dwmac->regmap, reg,\n\t\t\t\t dwmac->ops->syscfg_eth_mask, val);\n}\n\nstatic int stm32mcu_set_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct stm32_dwmac *dwmac = plat_dat->bsp_priv;\n\tu32 reg = dwmac->mode_reg;\n\tint val;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tval = SYSCFG_MCU_ETH_SEL_MII;\n\t\tpr_debug(\"SYSCFG init : PHY_INTERFACE_MODE_MII\\n\");\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = SYSCFG_MCU_ETH_SEL_RMII;\n\t\tpr_debug(\"SYSCFG init : PHY_INTERFACE_MODE_RMII\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"SYSCFG init :  Do not manage %d interface\\n\",\n\t\t\t plat_dat->mac_interface);\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(dwmac->regmap, reg,\n\t\t\t\t dwmac->ops->syscfg_eth_mask, val << 23);\n}\n\nstatic void stm32_dwmac_clk_disable(struct stm32_dwmac *dwmac)\n{\n\tclk_disable_unprepare(dwmac->clk_tx);\n\tclk_disable_unprepare(dwmac->clk_rx);\n\n\tif (dwmac->ops->clk_prepare)\n\t\tdwmac->ops->clk_prepare(dwmac, false);\n}\n\nstatic int stm32_dwmac_parse_data(struct stm32_dwmac *dwmac,\n\t\t\t\t  struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tint err;\n\n\t \n\tdwmac->clk_tx = devm_clk_get(dev, \"mac-clk-tx\");\n\tif (IS_ERR(dwmac->clk_tx)) {\n\t\tdev_err(dev, \"No ETH Tx clock provided...\\n\");\n\t\treturn PTR_ERR(dwmac->clk_tx);\n\t}\n\n\tdwmac->clk_rx = devm_clk_get(dev, \"mac-clk-rx\");\n\tif (IS_ERR(dwmac->clk_rx)) {\n\t\tdev_err(dev, \"No ETH Rx clock provided...\\n\");\n\t\treturn PTR_ERR(dwmac->clk_rx);\n\t}\n\n\tif (dwmac->ops->parse_data) {\n\t\terr = dwmac->ops->parse_data(dwmac, dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tdwmac->regmap = syscon_regmap_lookup_by_phandle(np, \"st,syscon\");\n\tif (IS_ERR(dwmac->regmap))\n\t\treturn PTR_ERR(dwmac->regmap);\n\n\terr = of_property_read_u32_index(np, \"st,syscon\", 1, &dwmac->mode_reg);\n\tif (err)\n\t\tdev_err(dev, \"Can't get sysconfig mode offset (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic int stm32mp1_parse_data(struct stm32_dwmac *dwmac,\n\t\t\t       struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *np = dev->of_node;\n\tint err = 0;\n\n\t \n\tdwmac->ext_phyclk = of_property_read_bool(np, \"st,ext-phyclk\");\n\n\t \n\tdwmac->eth_clk_sel_reg = of_property_read_bool(np, \"st,eth-clk-sel\");\n\n\t \n\tdwmac->eth_ref_clk_sel_reg =\n\t\tof_property_read_bool(np, \"st,eth-ref-clk-sel\");\n\n\t \n\tdwmac->clk_eth_ck = devm_clk_get(dev, \"eth-ck\");\n\tif (IS_ERR(dwmac->clk_eth_ck)) {\n\t\tdev_info(dev, \"No phy clock provided...\\n\");\n\t\tdwmac->clk_eth_ck = NULL;\n\t}\n\n\t \n\tdwmac->clk_ethstp = devm_clk_get(dev, \"ethstp\");\n\tif (IS_ERR(dwmac->clk_ethstp)) {\n\t\tdev_err(dev,\n\t\t\t\"No ETH peripheral clock provided for CStop mode ...\\n\");\n\t\treturn PTR_ERR(dwmac->clk_ethstp);\n\t}\n\n\t \n\tdwmac->syscfg_clk = devm_clk_get(dev, \"syscfg-clk\");\n\tif (IS_ERR(dwmac->syscfg_clk))\n\t\tdwmac->syscfg_clk = NULL;\n\n\t \n\tdwmac->irq_pwr_wakeup = platform_get_irq_byname_optional(pdev,\n\t\t\t\t\t\t\t\"stm32_pwr_wakeup\");\n\tif (dwmac->irq_pwr_wakeup == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!dwmac->clk_eth_ck && dwmac->irq_pwr_wakeup >= 0) {\n\t\terr = device_init_wakeup(&pdev->dev, true);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to init wake up irq\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = dev_pm_set_dedicated_wake_irq(&pdev->dev,\n\t\t\t\t\t\t    dwmac->irq_pwr_wakeup);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to set wake up irq\\n\");\n\t\t\tdevice_init_wakeup(&pdev->dev, false);\n\t\t}\n\t\tdevice_set_wakeup_enable(&pdev->dev, false);\n\t}\n\treturn err;\n}\n\nstatic int stm32_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct stm32_dwmac *dwmac;\n\tconst struct stm32_ops *data;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tdwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"no of match data provided\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->ops = data;\n\tdwmac->dev = &pdev->dev;\n\n\tret = stm32_dwmac_parse_data(dwmac, &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to parse OF data\\n\");\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tplat_dat->bsp_priv = dwmac;\n\n\tret = stm32_dwmac_init(plat_dat);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\treturn 0;\n\nerr_clk_disable:\n\tstm32_dwmac_clk_disable(dwmac);\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void stm32_dwmac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct stm32_dwmac *dwmac = priv->plat->bsp_priv;\n\n\tstmmac_dvr_remove(&pdev->dev);\n\n\tstm32_dwmac_clk_disable(priv->plat->bsp_priv);\n\n\tif (dwmac->irq_pwr_wakeup >= 0) {\n\t\tdev_pm_clear_wake_irq(&pdev->dev);\n\t\tdevice_init_wakeup(&pdev->dev, false);\n\t}\n}\n\nstatic int stm32mp1_suspend(struct stm32_dwmac *dwmac)\n{\n\tint ret = 0;\n\n\tret = clk_prepare_enable(dwmac->clk_ethstp);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable_unprepare(dwmac->clk_tx);\n\tclk_disable_unprepare(dwmac->syscfg_clk);\n\tif (dwmac->enable_eth_ck)\n\t\tclk_disable_unprepare(dwmac->clk_eth_ck);\n\n\treturn ret;\n}\n\nstatic void stm32mp1_resume(struct stm32_dwmac *dwmac)\n{\n\tclk_disable_unprepare(dwmac->clk_ethstp);\n}\n\nstatic int stm32mcu_suspend(struct stm32_dwmac *dwmac)\n{\n\tclk_disable_unprepare(dwmac->clk_tx);\n\tclk_disable_unprepare(dwmac->clk_rx);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm32_dwmac_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct stm32_dwmac *dwmac = priv->plat->bsp_priv;\n\n\tint ret;\n\n\tret = stmmac_suspend(dev);\n\n\tif (dwmac->ops->suspend)\n\t\tret = dwmac->ops->suspend(dwmac);\n\n\treturn ret;\n}\n\nstatic int stm32_dwmac_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct stm32_dwmac *dwmac = priv->plat->bsp_priv;\n\tint ret;\n\n\tif (dwmac->ops->resume)\n\t\tdwmac->ops->resume(dwmac);\n\n\tret = stm32_dwmac_init(priv->plat);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stmmac_resume(dev);\n\n\treturn ret;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(stm32_dwmac_pm_ops,\n\tstm32_dwmac_suspend, stm32_dwmac_resume);\n\nstatic struct stm32_ops stm32mcu_dwmac_data = {\n\t.set_mode = stm32mcu_set_mode,\n\t.suspend = stm32mcu_suspend,\n\t.syscfg_eth_mask = SYSCFG_MCU_ETH_MASK\n};\n\nstatic struct stm32_ops stm32mp1_dwmac_data = {\n\t.set_mode = stm32mp1_set_mode,\n\t.clk_prepare = stm32mp1_clk_prepare,\n\t.suspend = stm32mp1_suspend,\n\t.resume = stm32mp1_resume,\n\t.parse_data = stm32mp1_parse_data,\n\t.syscfg_eth_mask = SYSCFG_MP1_ETH_MASK,\n\t.clk_rx_enable_in_suspend = true\n};\n\nstatic const struct of_device_id stm32_dwmac_match[] = {\n\t{ .compatible = \"st,stm32-dwmac\", .data = &stm32mcu_dwmac_data},\n\t{ .compatible = \"st,stm32mp1-dwmac\", .data = &stm32mp1_dwmac_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, stm32_dwmac_match);\n\nstatic struct platform_driver stm32_dwmac_driver = {\n\t.probe  = stm32_dwmac_probe,\n\t.remove_new = stm32_dwmac_remove,\n\t.driver = {\n\t\t.name           = \"stm32-dwmac\",\n\t\t.pm\t\t= &stm32_dwmac_pm_ops,\n\t\t.of_match_table = stm32_dwmac_match,\n\t},\n};\nmodule_platform_driver(stm32_dwmac_driver);\n\nMODULE_AUTHOR(\"Alexandre Torgue <alexandre.torgue@gmail.com>\");\nMODULE_AUTHOR(\"Christophe Roullier <christophe.roullier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 DWMAC Specific Glue layer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}