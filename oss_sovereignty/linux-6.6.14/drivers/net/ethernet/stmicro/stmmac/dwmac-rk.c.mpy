{
  "module_name": "dwmac-rk.c",
  "hash_id": "fe2116da5659ad158eb5fc83eb86dc0c0cd64a4cf157f16e9cb66c4df85923b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c",
  "human_readable_source": "\n \n\n#include <linux/stmmac.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/phy.h>\n#include <linux/of_net.h>\n#include <linux/gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/pm_runtime.h>\n\n#include \"stmmac_platform.h\"\n\nstruct rk_priv_data;\nstruct rk_gmac_ops {\n\tvoid (*set_to_rgmii)(struct rk_priv_data *bsp_priv,\n\t\t\t     int tx_delay, int rx_delay);\n\tvoid (*set_to_rmii)(struct rk_priv_data *bsp_priv);\n\tvoid (*set_rgmii_speed)(struct rk_priv_data *bsp_priv, int speed);\n\tvoid (*set_rmii_speed)(struct rk_priv_data *bsp_priv, int speed);\n\tvoid (*set_clock_selection)(struct rk_priv_data *bsp_priv, bool input,\n\t\t\t\t    bool enable);\n\tvoid (*integrated_phy_powerup)(struct rk_priv_data *bsp_priv);\n\tbool regs_valid;\n\tu32 regs[];\n};\n\nstatic const char * const rk_clocks[] = {\n\t\"aclk_mac\", \"pclk_mac\", \"mac_clk_tx\", \"clk_mac_speed\",\n};\n\nstatic const char * const rk_rmii_clocks[] = {\n\t\"mac_clk_rx\", \"clk_mac_ref\", \"clk_mac_refout\",\n};\n\nenum rk_clocks_index {\n\tRK_ACLK_MAC = 0,\n\tRK_PCLK_MAC,\n\tRK_MAC_CLK_TX,\n\tRK_CLK_MAC_SPEED,\n\tRK_MAC_CLK_RX,\n\tRK_CLK_MAC_REF,\n\tRK_CLK_MAC_REFOUT,\n};\n\nstruct rk_priv_data {\n\tstruct platform_device *pdev;\n\tphy_interface_t phy_iface;\n\tint id;\n\tstruct regulator *regulator;\n\tbool suspended;\n\tconst struct rk_gmac_ops *ops;\n\n\tbool clk_enabled;\n\tbool clock_input;\n\tbool integrated_phy;\n\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\tstruct clk *clk_mac;\n\tstruct clk *clk_phy;\n\n\tstruct reset_control *phy_reset;\n\n\tint tx_delay;\n\tint rx_delay;\n\n\tstruct regmap *grf;\n\tstruct regmap *php_grf;\n};\n\n#define HIWORD_UPDATE(val, mask, shift) \\\n\t\t((val) << (shift) | (mask) << ((shift) + 16))\n\n#define GRF_BIT(nr)\t(BIT(nr) | BIT(nr+16))\n#define GRF_CLR_BIT(nr)\t(BIT(nr+16))\n\n#define DELAY_ENABLE(soc, tx, rx) \\\n\t(((tx) ? soc##_GMAC_TXCLK_DLY_ENABLE : soc##_GMAC_TXCLK_DLY_DISABLE) | \\\n\t ((rx) ? soc##_GMAC_RXCLK_DLY_ENABLE : soc##_GMAC_RXCLK_DLY_DISABLE))\n\n#define PX30_GRF_GMAC_CON1\t\t0x0904\n\n \n#define PX30_GMAC_PHY_INTF_SEL_RMII\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5) | \\\n\t\t\t\t\t GRF_BIT(6))\n#define PX30_GMAC_SPEED_10M\t\tGRF_CLR_BIT(2)\n#define PX30_GMAC_SPEED_100M\t\tGRF_BIT(2)\n\nstatic void px30_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, PX30_GRF_GMAC_CON1,\n\t\t     PX30_GMAC_PHY_INTF_SEL_RMII);\n}\n\nstatic void px30_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct clk *clk_mac_speed = bsp_priv->clks[RK_CLK_MAC_SPEED].clk;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tint ret;\n\n\tif (!clk_mac_speed) {\n\t\tdev_err(dev, \"%s: Missing clk_mac_speed clock\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, PX30_GRF_GMAC_CON1,\n\t\t\t     PX30_GMAC_SPEED_10M);\n\n\t\tret = clk_set_rate(clk_mac_speed, 2500000);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"%s: set clk_mac_speed rate 2500000 failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, PX30_GRF_GMAC_CON1,\n\t\t\t     PX30_GMAC_SPEED_100M);\n\n\t\tret = clk_set_rate(clk_mac_speed, 25000000);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"%s: set clk_mac_speed rate 25000000 failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops px30_ops = {\n\t.set_to_rmii = px30_set_to_rmii,\n\t.set_rmii_speed = px30_set_rmii_speed,\n};\n\n#define RK3128_GRF_MAC_CON0\t0x0168\n#define RK3128_GRF_MAC_CON1\t0x016c\n\n \n#define RK3128_GMAC_TXCLK_DLY_ENABLE   GRF_BIT(14)\n#define RK3128_GMAC_TXCLK_DLY_DISABLE  GRF_CLR_BIT(14)\n#define RK3128_GMAC_RXCLK_DLY_ENABLE   GRF_BIT(15)\n#define RK3128_GMAC_RXCLK_DLY_DISABLE  GRF_CLR_BIT(15)\n#define RK3128_GMAC_CLK_RX_DL_CFG(val) HIWORD_UPDATE(val, 0x7F, 7)\n#define RK3128_GMAC_CLK_TX_DL_CFG(val) HIWORD_UPDATE(val, 0x7F, 0)\n\n \n#define RK3128_GMAC_PHY_INTF_SEL_RGMII\t\\\n\t\t(GRF_BIT(6) | GRF_CLR_BIT(7) | GRF_CLR_BIT(8))\n#define RK3128_GMAC_PHY_INTF_SEL_RMII\t\\\n\t\t(GRF_CLR_BIT(6) | GRF_CLR_BIT(7) | GRF_BIT(8))\n#define RK3128_GMAC_FLOW_CTRL          GRF_BIT(9)\n#define RK3128_GMAC_FLOW_CTRL_CLR      GRF_CLR_BIT(9)\n#define RK3128_GMAC_SPEED_10M          GRF_CLR_BIT(10)\n#define RK3128_GMAC_SPEED_100M         GRF_BIT(10)\n#define RK3128_GMAC_RMII_CLK_25M       GRF_BIT(11)\n#define RK3128_GMAC_RMII_CLK_2_5M      GRF_CLR_BIT(11)\n#define RK3128_GMAC_CLK_125M           (GRF_CLR_BIT(12) | GRF_CLR_BIT(13))\n#define RK3128_GMAC_CLK_25M            (GRF_BIT(12) | GRF_BIT(13))\n#define RK3128_GMAC_CLK_2_5M           (GRF_CLR_BIT(12) | GRF_BIT(13))\n#define RK3128_GMAC_RMII_MODE          GRF_BIT(14)\n#define RK3128_GMAC_RMII_MODE_CLR      GRF_CLR_BIT(14)\n\nstatic void rk3128_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON1,\n\t\t     RK3128_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3128_GMAC_RMII_MODE_CLR);\n\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON0,\n\t\t     DELAY_ENABLE(RK3128, tx_delay, rx_delay) |\n\t\t     RK3128_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3128_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3128_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON1,\n\t\t     RK3128_GMAC_PHY_INTF_SEL_RMII | RK3128_GMAC_RMII_MODE);\n}\n\nstatic void rk3128_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON1,\n\t\t\t     RK3128_GMAC_CLK_2_5M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON1,\n\t\t\t     RK3128_GMAC_CLK_25M);\n\telse if (speed == 1000)\n\t\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON1,\n\t\t\t     RK3128_GMAC_CLK_125M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RGMII! speed=%d\", speed);\n}\n\nstatic void rk3128_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON1,\n\t\t\t     RK3128_GMAC_RMII_CLK_2_5M |\n\t\t\t     RK3128_GMAC_SPEED_10M);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, RK3128_GRF_MAC_CON1,\n\t\t\t     RK3128_GMAC_RMII_CLK_25M |\n\t\t\t     RK3128_GMAC_SPEED_100M);\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops rk3128_ops = {\n\t.set_to_rgmii = rk3128_set_to_rgmii,\n\t.set_to_rmii = rk3128_set_to_rmii,\n\t.set_rgmii_speed = rk3128_set_rgmii_speed,\n\t.set_rmii_speed = rk3128_set_rmii_speed,\n};\n\n#define RK3228_GRF_MAC_CON0\t0x0900\n#define RK3228_GRF_MAC_CON1\t0x0904\n\n#define RK3228_GRF_CON_MUX\t0x50\n\n \n#define RK3228_GMAC_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 7)\n#define RK3228_GMAC_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\n \n#define RK3228_GMAC_PHY_INTF_SEL_RGMII\t\\\n\t\t(GRF_BIT(4) | GRF_CLR_BIT(5) | GRF_CLR_BIT(6))\n#define RK3228_GMAC_PHY_INTF_SEL_RMII\t\\\n\t\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5) | GRF_BIT(6))\n#define RK3228_GMAC_FLOW_CTRL\t\tGRF_BIT(3)\n#define RK3228_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(3)\n#define RK3228_GMAC_SPEED_10M\t\tGRF_CLR_BIT(2)\n#define RK3228_GMAC_SPEED_100M\t\tGRF_BIT(2)\n#define RK3228_GMAC_RMII_CLK_25M\tGRF_BIT(7)\n#define RK3228_GMAC_RMII_CLK_2_5M\tGRF_CLR_BIT(7)\n#define RK3228_GMAC_CLK_125M\t\t(GRF_CLR_BIT(8) | GRF_CLR_BIT(9))\n#define RK3228_GMAC_CLK_25M\t\t(GRF_BIT(8) | GRF_BIT(9))\n#define RK3228_GMAC_CLK_2_5M\t\t(GRF_CLR_BIT(8) | GRF_BIT(9))\n#define RK3228_GMAC_RMII_MODE\t\tGRF_BIT(10)\n#define RK3228_GMAC_RMII_MODE_CLR\tGRF_CLR_BIT(10)\n#define RK3228_GMAC_TXCLK_DLY_ENABLE\tGRF_BIT(0)\n#define RK3228_GMAC_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(0)\n#define RK3228_GMAC_RXCLK_DLY_ENABLE\tGRF_BIT(1)\n#define RK3228_GMAC_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(1)\n\n \n#define RK3228_GRF_CON_MUX_GMAC_INTEGRATED_PHY\tGRF_BIT(15)\n\nstatic void rk3228_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1,\n\t\t     RK3228_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3228_GMAC_RMII_MODE_CLR |\n\t\t     DELAY_ENABLE(RK3228, tx_delay, rx_delay));\n\n\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON0,\n\t\t     RK3228_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3228_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3228_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1,\n\t\t     RK3228_GMAC_PHY_INTF_SEL_RMII |\n\t\t     RK3228_GMAC_RMII_MODE);\n\n\t \n\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1, GRF_BIT(11));\n}\n\nstatic void rk3228_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1,\n\t\t\t     RK3228_GMAC_CLK_2_5M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1,\n\t\t\t     RK3228_GMAC_CLK_25M);\n\telse if (speed == 1000)\n\t\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1,\n\t\t\t     RK3228_GMAC_CLK_125M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RGMII! speed=%d\", speed);\n}\n\nstatic void rk3228_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1,\n\t\t\t     RK3228_GMAC_RMII_CLK_2_5M |\n\t\t\t     RK3228_GMAC_SPEED_10M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3228_GRF_MAC_CON1,\n\t\t\t     RK3228_GMAC_RMII_CLK_25M |\n\t\t\t     RK3228_GMAC_SPEED_100M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n}\n\nstatic void rk3228_integrated_phy_powerup(struct rk_priv_data *priv)\n{\n\tregmap_write(priv->grf, RK3228_GRF_CON_MUX,\n\t\t     RK3228_GRF_CON_MUX_GMAC_INTEGRATED_PHY);\n}\n\nstatic const struct rk_gmac_ops rk3228_ops = {\n\t.set_to_rgmii = rk3228_set_to_rgmii,\n\t.set_to_rmii = rk3228_set_to_rmii,\n\t.set_rgmii_speed = rk3228_set_rgmii_speed,\n\t.set_rmii_speed = rk3228_set_rmii_speed,\n\t.integrated_phy_powerup =  rk3228_integrated_phy_powerup,\n};\n\n#define RK3288_GRF_SOC_CON1\t0x0248\n#define RK3288_GRF_SOC_CON3\t0x0250\n\n \n#define RK3288_GMAC_PHY_INTF_SEL_RGMII\t(GRF_BIT(6) | GRF_CLR_BIT(7) | \\\n\t\t\t\t\t GRF_CLR_BIT(8))\n#define RK3288_GMAC_PHY_INTF_SEL_RMII\t(GRF_CLR_BIT(6) | GRF_CLR_BIT(7) | \\\n\t\t\t\t\t GRF_BIT(8))\n#define RK3288_GMAC_FLOW_CTRL\t\tGRF_BIT(9)\n#define RK3288_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(9)\n#define RK3288_GMAC_SPEED_10M\t\tGRF_CLR_BIT(10)\n#define RK3288_GMAC_SPEED_100M\t\tGRF_BIT(10)\n#define RK3288_GMAC_RMII_CLK_25M\tGRF_BIT(11)\n#define RK3288_GMAC_RMII_CLK_2_5M\tGRF_CLR_BIT(11)\n#define RK3288_GMAC_CLK_125M\t\t(GRF_CLR_BIT(12) | GRF_CLR_BIT(13))\n#define RK3288_GMAC_CLK_25M\t\t(GRF_BIT(12) | GRF_BIT(13))\n#define RK3288_GMAC_CLK_2_5M\t\t(GRF_CLR_BIT(12) | GRF_BIT(13))\n#define RK3288_GMAC_RMII_MODE\t\tGRF_BIT(14)\n#define RK3288_GMAC_RMII_MODE_CLR\tGRF_CLR_BIT(14)\n\n \n#define RK3288_GMAC_TXCLK_DLY_ENABLE\tGRF_BIT(14)\n#define RK3288_GMAC_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(14)\n#define RK3288_GMAC_RXCLK_DLY_ENABLE\tGRF_BIT(15)\n#define RK3288_GMAC_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(15)\n#define RK3288_GMAC_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 7)\n#define RK3288_GMAC_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\nstatic void rk3288_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\n\t\t     RK3288_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3288_GMAC_RMII_MODE_CLR);\n\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON3,\n\t\t     DELAY_ENABLE(RK3288, tx_delay, rx_delay) |\n\t\t     RK3288_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3288_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3288_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\n\t\t     RK3288_GMAC_PHY_INTF_SEL_RMII | RK3288_GMAC_RMII_MODE);\n}\n\nstatic void rk3288_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\n\t\t\t     RK3288_GMAC_CLK_2_5M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\n\t\t\t     RK3288_GMAC_CLK_25M);\n\telse if (speed == 1000)\n\t\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\n\t\t\t     RK3288_GMAC_CLK_125M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RGMII! speed=%d\", speed);\n}\n\nstatic void rk3288_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\n\t\t\t     RK3288_GMAC_RMII_CLK_2_5M |\n\t\t\t     RK3288_GMAC_SPEED_10M);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\n\t\t\t     RK3288_GMAC_RMII_CLK_25M |\n\t\t\t     RK3288_GMAC_SPEED_100M);\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops rk3288_ops = {\n\t.set_to_rgmii = rk3288_set_to_rgmii,\n\t.set_to_rmii = rk3288_set_to_rmii,\n\t.set_rgmii_speed = rk3288_set_rgmii_speed,\n\t.set_rmii_speed = rk3288_set_rmii_speed,\n};\n\n#define RK3308_GRF_MAC_CON0\t\t0x04a0\n\n \n#define RK3308_GMAC_PHY_INTF_SEL_RMII\t(GRF_CLR_BIT(2) | GRF_CLR_BIT(3) | \\\n\t\t\t\t\tGRF_BIT(4))\n#define RK3308_GMAC_FLOW_CTRL\t\tGRF_BIT(3)\n#define RK3308_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(3)\n#define RK3308_GMAC_SPEED_10M\t\tGRF_CLR_BIT(0)\n#define RK3308_GMAC_SPEED_100M\t\tGRF_BIT(0)\n\nstatic void rk3308_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3308_GRF_MAC_CON0,\n\t\t     RK3308_GMAC_PHY_INTF_SEL_RMII);\n}\n\nstatic void rk3308_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, RK3308_GRF_MAC_CON0,\n\t\t\t     RK3308_GMAC_SPEED_10M);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, RK3308_GRF_MAC_CON0,\n\t\t\t     RK3308_GMAC_SPEED_100M);\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops rk3308_ops = {\n\t.set_to_rmii = rk3308_set_to_rmii,\n\t.set_rmii_speed = rk3308_set_rmii_speed,\n};\n\n#define RK3328_GRF_MAC_CON0\t0x0900\n#define RK3328_GRF_MAC_CON1\t0x0904\n#define RK3328_GRF_MAC_CON2\t0x0908\n#define RK3328_GRF_MACPHY_CON1\t0xb04\n\n \n#define RK3328_GMAC_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 7)\n#define RK3328_GMAC_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\n \n#define RK3328_GMAC_PHY_INTF_SEL_RGMII\t\\\n\t\t(GRF_BIT(4) | GRF_CLR_BIT(5) | GRF_CLR_BIT(6))\n#define RK3328_GMAC_PHY_INTF_SEL_RMII\t\\\n\t\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5) | GRF_BIT(6))\n#define RK3328_GMAC_FLOW_CTRL\t\tGRF_BIT(3)\n#define RK3328_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(3)\n#define RK3328_GMAC_SPEED_10M\t\tGRF_CLR_BIT(2)\n#define RK3328_GMAC_SPEED_100M\t\tGRF_BIT(2)\n#define RK3328_GMAC_RMII_CLK_25M\tGRF_BIT(7)\n#define RK3328_GMAC_RMII_CLK_2_5M\tGRF_CLR_BIT(7)\n#define RK3328_GMAC_CLK_125M\t\t(GRF_CLR_BIT(11) | GRF_CLR_BIT(12))\n#define RK3328_GMAC_CLK_25M\t\t(GRF_BIT(11) | GRF_BIT(12))\n#define RK3328_GMAC_CLK_2_5M\t\t(GRF_CLR_BIT(11) | GRF_BIT(12))\n#define RK3328_GMAC_RMII_MODE\t\tGRF_BIT(9)\n#define RK3328_GMAC_RMII_MODE_CLR\tGRF_CLR_BIT(9)\n#define RK3328_GMAC_TXCLK_DLY_ENABLE\tGRF_BIT(0)\n#define RK3328_GMAC_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(0)\n#define RK3328_GMAC_RXCLK_DLY_ENABLE\tGRF_BIT(1)\n#define RK3328_GMAC_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(0)\n\n \n#define RK3328_MACPHY_RMII_MODE\t\tGRF_BIT(9)\n\nstatic void rk3328_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3328_GRF_MAC_CON1,\n\t\t     RK3328_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3328_GMAC_RMII_MODE_CLR |\n\t\t     RK3328_GMAC_RXCLK_DLY_ENABLE |\n\t\t     RK3328_GMAC_TXCLK_DLY_ENABLE);\n\n\tregmap_write(bsp_priv->grf, RK3328_GRF_MAC_CON0,\n\t\t     RK3328_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3328_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3328_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tunsigned int reg;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\treg = bsp_priv->integrated_phy ? RK3328_GRF_MAC_CON2 :\n\t\t  RK3328_GRF_MAC_CON1;\n\n\tregmap_write(bsp_priv->grf, reg,\n\t\t     RK3328_GMAC_PHY_INTF_SEL_RMII |\n\t\t     RK3328_GMAC_RMII_MODE);\n}\n\nstatic void rk3328_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3328_GRF_MAC_CON1,\n\t\t\t     RK3328_GMAC_CLK_2_5M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3328_GRF_MAC_CON1,\n\t\t\t     RK3328_GMAC_CLK_25M);\n\telse if (speed == 1000)\n\t\tregmap_write(bsp_priv->grf, RK3328_GRF_MAC_CON1,\n\t\t\t     RK3328_GMAC_CLK_125M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RGMII! speed=%d\", speed);\n}\n\nstatic void rk3328_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tunsigned int reg;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\treg = bsp_priv->integrated_phy ? RK3328_GRF_MAC_CON2 :\n\t\t  RK3328_GRF_MAC_CON1;\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, reg,\n\t\t\t     RK3328_GMAC_RMII_CLK_2_5M |\n\t\t\t     RK3328_GMAC_SPEED_10M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, reg,\n\t\t\t     RK3328_GMAC_RMII_CLK_25M |\n\t\t\t     RK3328_GMAC_SPEED_100M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n}\n\nstatic void rk3328_integrated_phy_powerup(struct rk_priv_data *priv)\n{\n\tregmap_write(priv->grf, RK3328_GRF_MACPHY_CON1,\n\t\t     RK3328_MACPHY_RMII_MODE);\n}\n\nstatic const struct rk_gmac_ops rk3328_ops = {\n\t.set_to_rgmii = rk3328_set_to_rgmii,\n\t.set_to_rmii = rk3328_set_to_rmii,\n\t.set_rgmii_speed = rk3328_set_rgmii_speed,\n\t.set_rmii_speed = rk3328_set_rmii_speed,\n\t.integrated_phy_powerup =  rk3328_integrated_phy_powerup,\n};\n\n#define RK3366_GRF_SOC_CON6\t0x0418\n#define RK3366_GRF_SOC_CON7\t0x041c\n\n \n#define RK3366_GMAC_PHY_INTF_SEL_RGMII\t(GRF_BIT(9) | GRF_CLR_BIT(10) | \\\n\t\t\t\t\t GRF_CLR_BIT(11))\n#define RK3366_GMAC_PHY_INTF_SEL_RMII\t(GRF_CLR_BIT(9) | GRF_CLR_BIT(10) | \\\n\t\t\t\t\t GRF_BIT(11))\n#define RK3366_GMAC_FLOW_CTRL\t\tGRF_BIT(8)\n#define RK3366_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(8)\n#define RK3366_GMAC_SPEED_10M\t\tGRF_CLR_BIT(7)\n#define RK3366_GMAC_SPEED_100M\t\tGRF_BIT(7)\n#define RK3366_GMAC_RMII_CLK_25M\tGRF_BIT(3)\n#define RK3366_GMAC_RMII_CLK_2_5M\tGRF_CLR_BIT(3)\n#define RK3366_GMAC_CLK_125M\t\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5))\n#define RK3366_GMAC_CLK_25M\t\t(GRF_BIT(4) | GRF_BIT(5))\n#define RK3366_GMAC_CLK_2_5M\t\t(GRF_CLR_BIT(4) | GRF_BIT(5))\n#define RK3366_GMAC_RMII_MODE\t\tGRF_BIT(6)\n#define RK3366_GMAC_RMII_MODE_CLR\tGRF_CLR_BIT(6)\n\n \n#define RK3366_GMAC_TXCLK_DLY_ENABLE\tGRF_BIT(7)\n#define RK3366_GMAC_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(7)\n#define RK3366_GMAC_RXCLK_DLY_ENABLE\tGRF_BIT(15)\n#define RK3366_GMAC_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(15)\n#define RK3366_GMAC_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 8)\n#define RK3366_GMAC_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\nstatic void rk3366_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON6,\n\t\t     RK3366_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3366_GMAC_RMII_MODE_CLR);\n\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON7,\n\t\t     DELAY_ENABLE(RK3366, tx_delay, rx_delay) |\n\t\t     RK3366_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3366_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3366_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON6,\n\t\t     RK3366_GMAC_PHY_INTF_SEL_RMII | RK3366_GMAC_RMII_MODE);\n}\n\nstatic void rk3366_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON6,\n\t\t\t     RK3366_GMAC_CLK_2_5M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON6,\n\t\t\t     RK3366_GMAC_CLK_25M);\n\telse if (speed == 1000)\n\t\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON6,\n\t\t\t     RK3366_GMAC_CLK_125M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RGMII! speed=%d\", speed);\n}\n\nstatic void rk3366_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON6,\n\t\t\t     RK3366_GMAC_RMII_CLK_2_5M |\n\t\t\t     RK3366_GMAC_SPEED_10M);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, RK3366_GRF_SOC_CON6,\n\t\t\t     RK3366_GMAC_RMII_CLK_25M |\n\t\t\t     RK3366_GMAC_SPEED_100M);\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops rk3366_ops = {\n\t.set_to_rgmii = rk3366_set_to_rgmii,\n\t.set_to_rmii = rk3366_set_to_rmii,\n\t.set_rgmii_speed = rk3366_set_rgmii_speed,\n\t.set_rmii_speed = rk3366_set_rmii_speed,\n};\n\n#define RK3368_GRF_SOC_CON15\t0x043c\n#define RK3368_GRF_SOC_CON16\t0x0440\n\n \n#define RK3368_GMAC_PHY_INTF_SEL_RGMII\t(GRF_BIT(9) | GRF_CLR_BIT(10) | \\\n\t\t\t\t\t GRF_CLR_BIT(11))\n#define RK3368_GMAC_PHY_INTF_SEL_RMII\t(GRF_CLR_BIT(9) | GRF_CLR_BIT(10) | \\\n\t\t\t\t\t GRF_BIT(11))\n#define RK3368_GMAC_FLOW_CTRL\t\tGRF_BIT(8)\n#define RK3368_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(8)\n#define RK3368_GMAC_SPEED_10M\t\tGRF_CLR_BIT(7)\n#define RK3368_GMAC_SPEED_100M\t\tGRF_BIT(7)\n#define RK3368_GMAC_RMII_CLK_25M\tGRF_BIT(3)\n#define RK3368_GMAC_RMII_CLK_2_5M\tGRF_CLR_BIT(3)\n#define RK3368_GMAC_CLK_125M\t\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5))\n#define RK3368_GMAC_CLK_25M\t\t(GRF_BIT(4) | GRF_BIT(5))\n#define RK3368_GMAC_CLK_2_5M\t\t(GRF_CLR_BIT(4) | GRF_BIT(5))\n#define RK3368_GMAC_RMII_MODE\t\tGRF_BIT(6)\n#define RK3368_GMAC_RMII_MODE_CLR\tGRF_CLR_BIT(6)\n\n \n#define RK3368_GMAC_TXCLK_DLY_ENABLE\tGRF_BIT(7)\n#define RK3368_GMAC_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(7)\n#define RK3368_GMAC_RXCLK_DLY_ENABLE\tGRF_BIT(15)\n#define RK3368_GMAC_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(15)\n#define RK3368_GMAC_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 8)\n#define RK3368_GMAC_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\nstatic void rk3368_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\n\t\t     RK3368_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3368_GMAC_RMII_MODE_CLR);\n\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON16,\n\t\t     DELAY_ENABLE(RK3368, tx_delay, rx_delay) |\n\t\t     RK3368_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3368_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3368_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\n\t\t     RK3368_GMAC_PHY_INTF_SEL_RMII | RK3368_GMAC_RMII_MODE);\n}\n\nstatic void rk3368_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\n\t\t\t     RK3368_GMAC_CLK_2_5M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\n\t\t\t     RK3368_GMAC_CLK_25M);\n\telse if (speed == 1000)\n\t\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\n\t\t\t     RK3368_GMAC_CLK_125M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RGMII! speed=%d\", speed);\n}\n\nstatic void rk3368_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\n\t\t\t     RK3368_GMAC_RMII_CLK_2_5M |\n\t\t\t     RK3368_GMAC_SPEED_10M);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\n\t\t\t     RK3368_GMAC_RMII_CLK_25M |\n\t\t\t     RK3368_GMAC_SPEED_100M);\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops rk3368_ops = {\n\t.set_to_rgmii = rk3368_set_to_rgmii,\n\t.set_to_rmii = rk3368_set_to_rmii,\n\t.set_rgmii_speed = rk3368_set_rgmii_speed,\n\t.set_rmii_speed = rk3368_set_rmii_speed,\n};\n\n#define RK3399_GRF_SOC_CON5\t0xc214\n#define RK3399_GRF_SOC_CON6\t0xc218\n\n \n#define RK3399_GMAC_PHY_INTF_SEL_RGMII\t(GRF_BIT(9) | GRF_CLR_BIT(10) | \\\n\t\t\t\t\t GRF_CLR_BIT(11))\n#define RK3399_GMAC_PHY_INTF_SEL_RMII\t(GRF_CLR_BIT(9) | GRF_CLR_BIT(10) | \\\n\t\t\t\t\t GRF_BIT(11))\n#define RK3399_GMAC_FLOW_CTRL\t\tGRF_BIT(8)\n#define RK3399_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(8)\n#define RK3399_GMAC_SPEED_10M\t\tGRF_CLR_BIT(7)\n#define RK3399_GMAC_SPEED_100M\t\tGRF_BIT(7)\n#define RK3399_GMAC_RMII_CLK_25M\tGRF_BIT(3)\n#define RK3399_GMAC_RMII_CLK_2_5M\tGRF_CLR_BIT(3)\n#define RK3399_GMAC_CLK_125M\t\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5))\n#define RK3399_GMAC_CLK_25M\t\t(GRF_BIT(4) | GRF_BIT(5))\n#define RK3399_GMAC_CLK_2_5M\t\t(GRF_CLR_BIT(4) | GRF_BIT(5))\n#define RK3399_GMAC_RMII_MODE\t\tGRF_BIT(6)\n#define RK3399_GMAC_RMII_MODE_CLR\tGRF_CLR_BIT(6)\n\n \n#define RK3399_GMAC_TXCLK_DLY_ENABLE\tGRF_BIT(7)\n#define RK3399_GMAC_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(7)\n#define RK3399_GMAC_RXCLK_DLY_ENABLE\tGRF_BIT(15)\n#define RK3399_GMAC_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(15)\n#define RK3399_GMAC_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 8)\n#define RK3399_GMAC_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\nstatic void rk3399_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON5,\n\t\t     RK3399_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3399_GMAC_RMII_MODE_CLR);\n\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON6,\n\t\t     DELAY_ENABLE(RK3399, tx_delay, rx_delay) |\n\t\t     RK3399_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3399_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3399_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON5,\n\t\t     RK3399_GMAC_PHY_INTF_SEL_RMII | RK3399_GMAC_RMII_MODE);\n}\n\nstatic void rk3399_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10)\n\t\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON5,\n\t\t\t     RK3399_GMAC_CLK_2_5M);\n\telse if (speed == 100)\n\t\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON5,\n\t\t\t     RK3399_GMAC_CLK_25M);\n\telse if (speed == 1000)\n\t\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON5,\n\t\t\t     RK3399_GMAC_CLK_125M);\n\telse\n\t\tdev_err(dev, \"unknown speed value for RGMII! speed=%d\", speed);\n}\n\nstatic void rk3399_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON5,\n\t\t\t     RK3399_GMAC_RMII_CLK_2_5M |\n\t\t\t     RK3399_GMAC_SPEED_10M);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, RK3399_GRF_SOC_CON5,\n\t\t\t     RK3399_GMAC_RMII_CLK_25M |\n\t\t\t     RK3399_GMAC_SPEED_100M);\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops rk3399_ops = {\n\t.set_to_rgmii = rk3399_set_to_rgmii,\n\t.set_to_rmii = rk3399_set_to_rmii,\n\t.set_rgmii_speed = rk3399_set_rgmii_speed,\n\t.set_rmii_speed = rk3399_set_rmii_speed,\n};\n\n#define RK3568_GRF_GMAC0_CON0\t\t0x0380\n#define RK3568_GRF_GMAC0_CON1\t\t0x0384\n#define RK3568_GRF_GMAC1_CON0\t\t0x0388\n#define RK3568_GRF_GMAC1_CON1\t\t0x038c\n\n \n#define RK3568_GMAC_PHY_INTF_SEL_RGMII\t\\\n\t\t(GRF_BIT(4) | GRF_CLR_BIT(5) | GRF_CLR_BIT(6))\n#define RK3568_GMAC_PHY_INTF_SEL_RMII\t\\\n\t\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5) | GRF_BIT(6))\n#define RK3568_GMAC_FLOW_CTRL\t\t\tGRF_BIT(3)\n#define RK3568_GMAC_FLOW_CTRL_CLR\t\tGRF_CLR_BIT(3)\n#define RK3568_GMAC_RXCLK_DLY_ENABLE\t\tGRF_BIT(1)\n#define RK3568_GMAC_RXCLK_DLY_DISABLE\t\tGRF_CLR_BIT(1)\n#define RK3568_GMAC_TXCLK_DLY_ENABLE\t\tGRF_BIT(0)\n#define RK3568_GMAC_TXCLK_DLY_DISABLE\t\tGRF_CLR_BIT(0)\n\n \n#define RK3568_GMAC_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 8)\n#define RK3568_GMAC_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\nstatic void rk3568_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tu32 con0, con1;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tcon0 = (bsp_priv->id == 1) ? RK3568_GRF_GMAC1_CON0 :\n\t\t\t\t     RK3568_GRF_GMAC0_CON0;\n\tcon1 = (bsp_priv->id == 1) ? RK3568_GRF_GMAC1_CON1 :\n\t\t\t\t     RK3568_GRF_GMAC0_CON1;\n\n\tregmap_write(bsp_priv->grf, con0,\n\t\t     RK3568_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3568_GMAC_CLK_TX_DL_CFG(tx_delay));\n\n\tregmap_write(bsp_priv->grf, con1,\n\t\t     RK3568_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RK3568_GMAC_RXCLK_DLY_ENABLE |\n\t\t     RK3568_GMAC_TXCLK_DLY_ENABLE);\n}\n\nstatic void rk3568_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tu32 con1;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcon1 = (bsp_priv->id == 1) ? RK3568_GRF_GMAC1_CON1 :\n\t\t\t\t     RK3568_GRF_GMAC0_CON1;\n\tregmap_write(bsp_priv->grf, con1, RK3568_GMAC_PHY_INTF_SEL_RMII);\n}\n\nstatic void rk3568_set_gmac_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct clk *clk_mac_speed = bsp_priv->clks[RK_CLK_MAC_SPEED].clk;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tunsigned long rate;\n\tint ret;\n\n\tswitch (speed) {\n\tcase 10:\n\t\trate = 2500000;\n\t\tbreak;\n\tcase 100:\n\t\trate = 25000000;\n\t\tbreak;\n\tcase 1000:\n\t\trate = 125000000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown speed value for GMAC speed=%d\", speed);\n\t\treturn;\n\t}\n\n\tret = clk_set_rate(clk_mac_speed, rate);\n\tif (ret)\n\t\tdev_err(dev, \"%s: set clk_mac_speed rate %ld failed %d\\n\",\n\t\t\t__func__, rate, ret);\n}\n\nstatic const struct rk_gmac_ops rk3568_ops = {\n\t.set_to_rgmii = rk3568_set_to_rgmii,\n\t.set_to_rmii = rk3568_set_to_rmii,\n\t.set_rgmii_speed = rk3568_set_gmac_speed,\n\t.set_rmii_speed = rk3568_set_gmac_speed,\n\t.regs_valid = true,\n\t.regs = {\n\t\t0xfe2a0000,  \n\t\t0xfe010000,  \n\t\t0x0,  \n\t},\n};\n\n \n#define RK3588_GRF_GMAC_CON7\t\t\t0X031c\n#define RK3588_GRF_GMAC_CON8\t\t\t0X0320\n#define RK3588_GRF_GMAC_CON9\t\t\t0X0324\n\n#define RK3588_GMAC_RXCLK_DLY_ENABLE(id)\tGRF_BIT(2 * (id) + 3)\n#define RK3588_GMAC_RXCLK_DLY_DISABLE(id)\tGRF_CLR_BIT(2 * (id) + 3)\n#define RK3588_GMAC_TXCLK_DLY_ENABLE(id)\tGRF_BIT(2 * (id) + 2)\n#define RK3588_GMAC_TXCLK_DLY_DISABLE(id)\tGRF_CLR_BIT(2 * (id) + 2)\n\n#define RK3588_GMAC_CLK_RX_DL_CFG(val)\t\tHIWORD_UPDATE(val, 0xFF, 8)\n#define RK3588_GMAC_CLK_TX_DL_CFG(val)\t\tHIWORD_UPDATE(val, 0xFF, 0)\n\n \n#define RK3588_GRF_GMAC_CON0\t\t\t0X0008\n#define RK3588_GRF_CLK_CON1\t\t\t0X0070\n\n#define RK3588_GMAC_PHY_INTF_SEL_RGMII(id)\t\\\n\t(GRF_BIT(3 + (id) * 6) | GRF_CLR_BIT(4 + (id) * 6) | GRF_CLR_BIT(5 + (id) * 6))\n#define RK3588_GMAC_PHY_INTF_SEL_RMII(id)\t\\\n\t(GRF_CLR_BIT(3 + (id) * 6) | GRF_CLR_BIT(4 + (id) * 6) | GRF_BIT(5 + (id) * 6))\n\n#define RK3588_GMAC_CLK_RMII_MODE(id)\t\tGRF_BIT(5 * (id))\n#define RK3588_GMAC_CLK_RGMII_MODE(id)\t\tGRF_CLR_BIT(5 * (id))\n\n#define RK3588_GMAC_CLK_SELET_CRU(id)\t\tGRF_BIT(5 * (id) + 4)\n#define RK3588_GMAC_CLK_SELET_IO(id)\t\tGRF_CLR_BIT(5 * (id) + 4)\n\n#define RK3588_GMA_CLK_RMII_DIV2(id)\t\tGRF_BIT(5 * (id) + 2)\n#define RK3588_GMA_CLK_RMII_DIV20(id)\t\tGRF_CLR_BIT(5 * (id) + 2)\n\n#define RK3588_GMAC_CLK_RGMII_DIV1(id)\t\t\\\n\t\t\t(GRF_CLR_BIT(5 * (id) + 2) | GRF_CLR_BIT(5 * (id) + 3))\n#define RK3588_GMAC_CLK_RGMII_DIV5(id)\t\t\\\n\t\t\t(GRF_BIT(5 * (id) + 2) | GRF_BIT(5 * (id) + 3))\n#define RK3588_GMAC_CLK_RGMII_DIV50(id)\t\t\\\n\t\t\t(GRF_CLR_BIT(5 * (id) + 2) | GRF_BIT(5 * (id) + 3))\n\n#define RK3588_GMAC_CLK_RMII_GATE(id)\t\tGRF_BIT(5 * (id) + 1)\n#define RK3588_GMAC_CLK_RMII_NOGATE(id)\t\tGRF_CLR_BIT(5 * (id) + 1)\n\nstatic void rk3588_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tu32 offset_con, id = bsp_priv->id;\n\n\tif (IS_ERR(bsp_priv->grf) || IS_ERR(bsp_priv->php_grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf or rockchip,php_grf property\\n\");\n\t\treturn;\n\t}\n\n\toffset_con = bsp_priv->id == 1 ? RK3588_GRF_GMAC_CON9 :\n\t\t\t\t\t RK3588_GRF_GMAC_CON8;\n\n\tregmap_write(bsp_priv->php_grf, RK3588_GRF_GMAC_CON0,\n\t\t     RK3588_GMAC_PHY_INTF_SEL_RGMII(id));\n\n\tregmap_write(bsp_priv->php_grf, RK3588_GRF_CLK_CON1,\n\t\t     RK3588_GMAC_CLK_RGMII_MODE(id));\n\n\tregmap_write(bsp_priv->grf, RK3588_GRF_GMAC_CON7,\n\t\t     RK3588_GMAC_RXCLK_DLY_ENABLE(id) |\n\t\t     RK3588_GMAC_TXCLK_DLY_ENABLE(id));\n\n\tregmap_write(bsp_priv->grf, offset_con,\n\t\t     RK3588_GMAC_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RK3588_GMAC_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rk3588_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->php_grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,php_grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->php_grf, RK3588_GRF_GMAC_CON0,\n\t\t     RK3588_GMAC_PHY_INTF_SEL_RMII(bsp_priv->id));\n\n\tregmap_write(bsp_priv->php_grf, RK3588_GRF_CLK_CON1,\n\t\t     RK3588_GMAC_CLK_RMII_MODE(bsp_priv->id));\n}\n\nstatic void rk3588_set_gmac_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tunsigned int val = 0, id = bsp_priv->id;\n\n\tswitch (speed) {\n\tcase 10:\n\t\tif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII)\n\t\t\tval = RK3588_GMA_CLK_RMII_DIV20(id);\n\t\telse\n\t\t\tval = RK3588_GMAC_CLK_RGMII_DIV50(id);\n\t\tbreak;\n\tcase 100:\n\t\tif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII)\n\t\t\tval = RK3588_GMA_CLK_RMII_DIV2(id);\n\t\telse\n\t\t\tval = RK3588_GMAC_CLK_RGMII_DIV5(id);\n\t\tbreak;\n\tcase 1000:\n\t\tif (bsp_priv->phy_iface != PHY_INTERFACE_MODE_RMII)\n\t\t\tval = RK3588_GMAC_CLK_RGMII_DIV1(id);\n\t\telse\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tregmap_write(bsp_priv->php_grf, RK3588_GRF_CLK_CON1, val);\n\n\treturn;\nerr:\n\tdev_err(dev, \"unknown speed value for GMAC speed=%d\", speed);\n}\n\nstatic void rk3588_set_clock_selection(struct rk_priv_data *bsp_priv, bool input,\n\t\t\t\t       bool enable)\n{\n\tunsigned int val = input ? RK3588_GMAC_CLK_SELET_IO(bsp_priv->id) :\n\t\t\t\t   RK3588_GMAC_CLK_SELET_CRU(bsp_priv->id);\n\n\tval |= enable ? RK3588_GMAC_CLK_RMII_NOGATE(bsp_priv->id) :\n\t\t\tRK3588_GMAC_CLK_RMII_GATE(bsp_priv->id);\n\n\tregmap_write(bsp_priv->php_grf, RK3588_GRF_CLK_CON1, val);\n}\n\nstatic const struct rk_gmac_ops rk3588_ops = {\n\t.set_to_rgmii = rk3588_set_to_rgmii,\n\t.set_to_rmii = rk3588_set_to_rmii,\n\t.set_rgmii_speed = rk3588_set_gmac_speed,\n\t.set_rmii_speed = rk3588_set_gmac_speed,\n\t.set_clock_selection = rk3588_set_clock_selection,\n\t.regs_valid = true,\n\t.regs = {\n\t\t0xfe1b0000,  \n\t\t0xfe1c0000,  \n\t\t0x0,  \n\t},\n};\n\n#define RV1108_GRF_GMAC_CON0\t\t0X0900\n\n \n#define RV1108_GMAC_PHY_INTF_SEL_RMII\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5) | \\\n\t\t\t\t\tGRF_BIT(6))\n#define RV1108_GMAC_FLOW_CTRL\t\tGRF_BIT(3)\n#define RV1108_GMAC_FLOW_CTRL_CLR\tGRF_CLR_BIT(3)\n#define RV1108_GMAC_SPEED_10M\t\tGRF_CLR_BIT(2)\n#define RV1108_GMAC_SPEED_100M\t\tGRF_BIT(2)\n#define RV1108_GMAC_RMII_CLK_25M\tGRF_BIT(7)\n#define RV1108_GMAC_RMII_CLK_2_5M\tGRF_CLR_BIT(7)\n\nstatic void rv1108_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RV1108_GRF_GMAC_CON0,\n\t\t     RV1108_GMAC_PHY_INTF_SEL_RMII);\n}\n\nstatic void rv1108_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (speed == 10) {\n\t\tregmap_write(bsp_priv->grf, RV1108_GRF_GMAC_CON0,\n\t\t\t     RV1108_GMAC_RMII_CLK_2_5M |\n\t\t\t     RV1108_GMAC_SPEED_10M);\n\t} else if (speed == 100) {\n\t\tregmap_write(bsp_priv->grf, RV1108_GRF_GMAC_CON0,\n\t\t\t     RV1108_GMAC_RMII_CLK_25M |\n\t\t\t     RV1108_GMAC_SPEED_100M);\n\t} else {\n\t\tdev_err(dev, \"unknown speed value for RMII! speed=%d\", speed);\n\t}\n}\n\nstatic const struct rk_gmac_ops rv1108_ops = {\n\t.set_to_rmii = rv1108_set_to_rmii,\n\t.set_rmii_speed = rv1108_set_rmii_speed,\n};\n\n#define RV1126_GRF_GMAC_CON0\t\t0X0070\n#define RV1126_GRF_GMAC_CON1\t\t0X0074\n#define RV1126_GRF_GMAC_CON2\t\t0X0078\n\n \n#define RV1126_GMAC_PHY_INTF_SEL_RGMII\t\\\n\t\t(GRF_BIT(4) | GRF_CLR_BIT(5) | GRF_CLR_BIT(6))\n#define RV1126_GMAC_PHY_INTF_SEL_RMII\t\\\n\t\t(GRF_CLR_BIT(4) | GRF_CLR_BIT(5) | GRF_BIT(6))\n#define RV1126_GMAC_FLOW_CTRL\t\t\tGRF_BIT(7)\n#define RV1126_GMAC_FLOW_CTRL_CLR\t\tGRF_CLR_BIT(7)\n#define RV1126_GMAC_M0_RXCLK_DLY_ENABLE\t\tGRF_BIT(1)\n#define RV1126_GMAC_M0_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(1)\n#define RV1126_GMAC_M0_TXCLK_DLY_ENABLE\t\tGRF_BIT(0)\n#define RV1126_GMAC_M0_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(0)\n#define RV1126_GMAC_M1_RXCLK_DLY_ENABLE\t\tGRF_BIT(3)\n#define RV1126_GMAC_M1_RXCLK_DLY_DISABLE\tGRF_CLR_BIT(3)\n#define RV1126_GMAC_M1_TXCLK_DLY_ENABLE\t\tGRF_BIT(2)\n#define RV1126_GMAC_M1_TXCLK_DLY_DISABLE\tGRF_CLR_BIT(2)\n\n \n#define RV1126_GMAC_M0_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 8)\n#define RV1126_GMAC_M0_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n \n#define RV1126_GMAC_M1_CLK_RX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 8)\n#define RV1126_GMAC_M1_CLK_TX_DL_CFG(val)\tHIWORD_UPDATE(val, 0x7F, 0)\n\nstatic void rv1126_set_to_rgmii(struct rk_priv_data *bsp_priv,\n\t\t\t\tint tx_delay, int rx_delay)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RV1126_GRF_GMAC_CON0,\n\t\t     RV1126_GMAC_PHY_INTF_SEL_RGMII |\n\t\t     RV1126_GMAC_M0_RXCLK_DLY_ENABLE |\n\t\t     RV1126_GMAC_M0_TXCLK_DLY_ENABLE |\n\t\t     RV1126_GMAC_M1_RXCLK_DLY_ENABLE |\n\t\t     RV1126_GMAC_M1_TXCLK_DLY_ENABLE);\n\n\tregmap_write(bsp_priv->grf, RV1126_GRF_GMAC_CON1,\n\t\t     RV1126_GMAC_M0_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RV1126_GMAC_M0_CLK_TX_DL_CFG(tx_delay));\n\n\tregmap_write(bsp_priv->grf, RV1126_GRF_GMAC_CON2,\n\t\t     RV1126_GMAC_M1_CLK_RX_DL_CFG(rx_delay) |\n\t\t     RV1126_GMAC_M1_CLK_TX_DL_CFG(tx_delay));\n}\n\nstatic void rv1126_set_to_rmii(struct rk_priv_data *bsp_priv)\n{\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (IS_ERR(bsp_priv->grf)) {\n\t\tdev_err(dev, \"%s: Missing rockchip,grf property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tregmap_write(bsp_priv->grf, RV1126_GRF_GMAC_CON0,\n\t\t     RV1126_GMAC_PHY_INTF_SEL_RMII);\n}\n\nstatic void rv1126_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct clk *clk_mac_speed = bsp_priv->clks[RK_CLK_MAC_SPEED].clk;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tunsigned long rate;\n\tint ret;\n\n\tswitch (speed) {\n\tcase 10:\n\t\trate = 2500000;\n\t\tbreak;\n\tcase 100:\n\t\trate = 25000000;\n\t\tbreak;\n\tcase 1000:\n\t\trate = 125000000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown speed value for RGMII speed=%d\", speed);\n\t\treturn;\n\t}\n\n\tret = clk_set_rate(clk_mac_speed, rate);\n\tif (ret)\n\t\tdev_err(dev, \"%s: set clk_mac_speed rate %ld failed %d\\n\",\n\t\t\t__func__, rate, ret);\n}\n\nstatic void rv1126_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\n{\n\tstruct clk *clk_mac_speed = bsp_priv->clks[RK_CLK_MAC_SPEED].clk;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tunsigned long rate;\n\tint ret;\n\n\tswitch (speed) {\n\tcase 10:\n\t\trate = 2500000;\n\t\tbreak;\n\tcase 100:\n\t\trate = 25000000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown speed value for RGMII speed=%d\", speed);\n\t\treturn;\n\t}\n\n\tret = clk_set_rate(clk_mac_speed, rate);\n\tif (ret)\n\t\tdev_err(dev, \"%s: set clk_mac_speed rate %ld failed %d\\n\",\n\t\t\t__func__, rate, ret);\n}\n\nstatic const struct rk_gmac_ops rv1126_ops = {\n\t.set_to_rgmii = rv1126_set_to_rgmii,\n\t.set_to_rmii = rv1126_set_to_rmii,\n\t.set_rgmii_speed = rv1126_set_rgmii_speed,\n\t.set_rmii_speed = rv1126_set_rmii_speed,\n};\n\n#define RK_GRF_MACPHY_CON0\t\t0xb00\n#define RK_GRF_MACPHY_CON1\t\t0xb04\n#define RK_GRF_MACPHY_CON2\t\t0xb08\n#define RK_GRF_MACPHY_CON3\t\t0xb0c\n\n#define RK_MACPHY_ENABLE\t\tGRF_BIT(0)\n#define RK_MACPHY_DISABLE\t\tGRF_CLR_BIT(0)\n#define RK_MACPHY_CFG_CLK_50M\t\tGRF_BIT(14)\n#define RK_GMAC2PHY_RMII_MODE\t\t(GRF_BIT(6) | GRF_CLR_BIT(7))\n#define RK_GRF_CON2_MACPHY_ID\t\tHIWORD_UPDATE(0x1234, 0xffff, 0)\n#define RK_GRF_CON3_MACPHY_ID\t\tHIWORD_UPDATE(0x35, 0x3f, 0)\n\nstatic void rk_gmac_integrated_phy_powerup(struct rk_priv_data *priv)\n{\n\tif (priv->ops->integrated_phy_powerup)\n\t\tpriv->ops->integrated_phy_powerup(priv);\n\n\tregmap_write(priv->grf, RK_GRF_MACPHY_CON0, RK_MACPHY_CFG_CLK_50M);\n\tregmap_write(priv->grf, RK_GRF_MACPHY_CON0, RK_GMAC2PHY_RMII_MODE);\n\n\tregmap_write(priv->grf, RK_GRF_MACPHY_CON2, RK_GRF_CON2_MACPHY_ID);\n\tregmap_write(priv->grf, RK_GRF_MACPHY_CON3, RK_GRF_CON3_MACPHY_ID);\n\n\tif (priv->phy_reset) {\n\t\t \n\t\tregmap_write(priv->grf, RK_GRF_MACPHY_CON0, RK_MACPHY_DISABLE);\n\t\tif (priv->phy_reset)\n\t\t\treset_control_assert(priv->phy_reset);\n\t\tusleep_range(10, 20);\n\t\tif (priv->phy_reset)\n\t\t\treset_control_deassert(priv->phy_reset);\n\t\tusleep_range(10, 20);\n\t\tregmap_write(priv->grf, RK_GRF_MACPHY_CON0, RK_MACPHY_ENABLE);\n\t\tmsleep(30);\n\t}\n}\n\nstatic void rk_gmac_integrated_phy_powerdown(struct rk_priv_data *priv)\n{\n\tregmap_write(priv->grf, RK_GRF_MACPHY_CON0, RK_MACPHY_DISABLE);\n\tif (priv->phy_reset)\n\t\treset_control_assert(priv->phy_reset);\n}\n\nstatic int rk_gmac_clk_init(struct plat_stmmacenet_data *plat)\n{\n\tstruct rk_priv_data *bsp_priv = plat->bsp_priv;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\tint phy_iface = bsp_priv->phy_iface;\n\tint i, j, ret;\n\n\tbsp_priv->clk_enabled = false;\n\n\tbsp_priv->num_clks = ARRAY_SIZE(rk_clocks);\n\tif (phy_iface == PHY_INTERFACE_MODE_RMII)\n\t\tbsp_priv->num_clks += ARRAY_SIZE(rk_rmii_clocks);\n\n\tbsp_priv->clks = devm_kcalloc(dev, bsp_priv->num_clks,\n\t\t\t\t      sizeof(*bsp_priv->clks), GFP_KERNEL);\n\tif (!bsp_priv->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(rk_clocks); i++)\n\t\tbsp_priv->clks[i].id = rk_clocks[i];\n\n\tif (phy_iface == PHY_INTERFACE_MODE_RMII) {\n\t\tfor (j = 0; j < ARRAY_SIZE(rk_rmii_clocks); j++)\n\t\t\tbsp_priv->clks[i++].id = rk_rmii_clocks[j];\n\t}\n\n\tret = devm_clk_bulk_get_optional(dev, bsp_priv->num_clks,\n\t\t\t\t\t bsp_priv->clks);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get clocks\\n\");\n\n\t \n\tbsp_priv->clk_mac = devm_clk_get(dev, \"stmmaceth\");\n\tret = PTR_ERR_OR_ZERO(bsp_priv->clk_mac);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot get stmmaceth clock\\n\");\n\n\tif (bsp_priv->clock_input) {\n\t\tdev_info(dev, \"clock input from PHY\\n\");\n\t} else if (phy_iface == PHY_INTERFACE_MODE_RMII) {\n\t\tclk_set_rate(bsp_priv->clk_mac, 50000000);\n\t}\n\n\tif (plat->phy_node && bsp_priv->integrated_phy) {\n\t\tbsp_priv->clk_phy = of_clk_get(plat->phy_node, 0);\n\t\tret = PTR_ERR_OR_ZERO(bsp_priv->clk_phy);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Cannot get PHY clock\\n\");\n\t\tclk_set_rate(bsp_priv->clk_phy, 50000000);\n\t}\n\n\treturn 0;\n}\n\nstatic int gmac_clk_enable(struct rk_priv_data *bsp_priv, bool enable)\n{\n\tint ret;\n\n\tif (enable) {\n\t\tif (!bsp_priv->clk_enabled) {\n\t\t\tret = clk_bulk_prepare_enable(bsp_priv->num_clks,\n\t\t\t\t\t\t      bsp_priv->clks);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = clk_prepare_enable(bsp_priv->clk_phy);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (bsp_priv->ops && bsp_priv->ops->set_clock_selection)\n\t\t\t\tbsp_priv->ops->set_clock_selection(bsp_priv,\n\t\t\t\t\t       bsp_priv->clock_input, true);\n\n\t\t\tmdelay(5);\n\t\t\tbsp_priv->clk_enabled = true;\n\t\t}\n\t} else {\n\t\tif (bsp_priv->clk_enabled) {\n\t\t\tclk_bulk_disable_unprepare(bsp_priv->num_clks,\n\t\t\t\t\t\t   bsp_priv->clks);\n\t\t\tclk_disable_unprepare(bsp_priv->clk_phy);\n\n\t\t\tif (bsp_priv->ops && bsp_priv->ops->set_clock_selection)\n\t\t\t\tbsp_priv->ops->set_clock_selection(bsp_priv,\n\t\t\t\t\t      bsp_priv->clock_input, false);\n\n\t\t\tbsp_priv->clk_enabled = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int phy_power_on(struct rk_priv_data *bsp_priv, bool enable)\n{\n\tstruct regulator *ldo = bsp_priv->regulator;\n\tint ret;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tif (enable) {\n\t\tret = regulator_enable(ldo);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"fail to enable phy-supply\\n\");\n\t} else {\n\t\tret = regulator_disable(ldo);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"fail to disable phy-supply\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic struct rk_priv_data *rk_gmac_setup(struct platform_device *pdev,\n\t\t\t\t\t  struct plat_stmmacenet_data *plat,\n\t\t\t\t\t  const struct rk_gmac_ops *ops)\n{\n\tstruct rk_priv_data *bsp_priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint ret;\n\tconst char *strings = NULL;\n\tint value;\n\n\tbsp_priv = devm_kzalloc(dev, sizeof(*bsp_priv), GFP_KERNEL);\n\tif (!bsp_priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tof_get_phy_mode(dev->of_node, &bsp_priv->phy_iface);\n\tbsp_priv->ops = ops;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res && ops->regs_valid) {\n\t\tint i = 0;\n\n\t\twhile (ops->regs[i]) {\n\t\t\tif (ops->regs[i] == res->start) {\n\t\t\t\tbsp_priv->id = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tbsp_priv->regulator = devm_regulator_get(dev, \"phy\");\n\tif (IS_ERR(bsp_priv->regulator)) {\n\t\tret = PTR_ERR(bsp_priv->regulator);\n\t\tdev_err_probe(dev, ret, \"failed to get phy regulator\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = of_property_read_string(dev->of_node, \"clock_in_out\", &strings);\n\tif (ret) {\n\t\tdev_err(dev, \"Can not read property: clock_in_out.\\n\");\n\t\tbsp_priv->clock_input = true;\n\t} else {\n\t\tdev_info(dev, \"clock input or output? (%s).\\n\",\n\t\t\t strings);\n\t\tif (!strcmp(strings, \"input\"))\n\t\t\tbsp_priv->clock_input = true;\n\t\telse\n\t\t\tbsp_priv->clock_input = false;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"tx_delay\", &value);\n\tif (ret) {\n\t\tbsp_priv->tx_delay = 0x30;\n\t\tdev_err(dev, \"Can not read property: tx_delay.\");\n\t\tdev_err(dev, \"set tx_delay to 0x%x\\n\",\n\t\t\tbsp_priv->tx_delay);\n\t} else {\n\t\tdev_info(dev, \"TX delay(0x%x).\\n\", value);\n\t\tbsp_priv->tx_delay = value;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"rx_delay\", &value);\n\tif (ret) {\n\t\tbsp_priv->rx_delay = 0x10;\n\t\tdev_err(dev, \"Can not read property: rx_delay.\");\n\t\tdev_err(dev, \"set rx_delay to 0x%x\\n\",\n\t\t\tbsp_priv->rx_delay);\n\t} else {\n\t\tdev_info(dev, \"RX delay(0x%x).\\n\", value);\n\t\tbsp_priv->rx_delay = value;\n\t}\n\n\tbsp_priv->grf = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"rockchip,grf\");\n\tbsp_priv->php_grf = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t    \"rockchip,php-grf\");\n\n\tif (plat->phy_node) {\n\t\tbsp_priv->integrated_phy = of_property_read_bool(plat->phy_node,\n\t\t\t\t\t\t\t\t \"phy-is-integrated\");\n\t\tif (bsp_priv->integrated_phy) {\n\t\t\tbsp_priv->phy_reset = of_reset_control_get(plat->phy_node, NULL);\n\t\t\tif (IS_ERR(bsp_priv->phy_reset)) {\n\t\t\t\tdev_err(&pdev->dev, \"No PHY reset control found.\\n\");\n\t\t\t\tbsp_priv->phy_reset = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tdev_info(dev, \"integrated PHY? (%s).\\n\",\n\t\t bsp_priv->integrated_phy ? \"yes\" : \"no\");\n\n\tbsp_priv->pdev = pdev;\n\n\treturn bsp_priv;\n}\n\nstatic int rk_gmac_check_ops(struct rk_priv_data *bsp_priv)\n{\n\tswitch (bsp_priv->phy_iface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tif (!bsp_priv->ops->set_to_rgmii)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tif (!bsp_priv->ops->set_to_rmii)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&bsp_priv->pdev->dev,\n\t\t\t\"unsupported interface %d\", bsp_priv->phy_iface);\n\t}\n\treturn 0;\n}\n\nstatic int rk_gmac_powerup(struct rk_priv_data *bsp_priv)\n{\n\tint ret;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tret = rk_gmac_check_ops(bsp_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gmac_clk_enable(bsp_priv, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (bsp_priv->phy_iface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tdev_info(dev, \"init for RGMII\\n\");\n\t\tbsp_priv->ops->set_to_rgmii(bsp_priv, bsp_priv->tx_delay,\n\t\t\t\t\t    bsp_priv->rx_delay);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tdev_info(dev, \"init for RGMII_ID\\n\");\n\t\tbsp_priv->ops->set_to_rgmii(bsp_priv, 0, 0);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tdev_info(dev, \"init for RGMII_RXID\\n\");\n\t\tbsp_priv->ops->set_to_rgmii(bsp_priv, bsp_priv->tx_delay, 0);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tdev_info(dev, \"init for RGMII_TXID\\n\");\n\t\tbsp_priv->ops->set_to_rgmii(bsp_priv, 0, bsp_priv->rx_delay);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tdev_info(dev, \"init for RMII\\n\");\n\t\tbsp_priv->ops->set_to_rmii(bsp_priv);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"NO interface defined!\\n\");\n\t}\n\n\tret = phy_power_on(bsp_priv, true);\n\tif (ret) {\n\t\tgmac_clk_enable(bsp_priv, false);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\n\tif (bsp_priv->integrated_phy)\n\t\trk_gmac_integrated_phy_powerup(bsp_priv);\n\n\treturn 0;\n}\n\nstatic void rk_gmac_powerdown(struct rk_priv_data *gmac)\n{\n\tif (gmac->integrated_phy)\n\t\trk_gmac_integrated_phy_powerdown(gmac);\n\n\tpm_runtime_put_sync(&gmac->pdev->dev);\n\n\tphy_power_on(gmac, false);\n\tgmac_clk_enable(gmac, false);\n}\n\nstatic void rk_fix_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct rk_priv_data *bsp_priv = priv;\n\tstruct device *dev = &bsp_priv->pdev->dev;\n\n\tswitch (bsp_priv->phy_iface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tif (bsp_priv->ops->set_rgmii_speed)\n\t\t\tbsp_priv->ops->set_rgmii_speed(bsp_priv, speed);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tif (bsp_priv->ops->set_rmii_speed)\n\t\t\tbsp_priv->ops->set_rmii_speed(bsp_priv, speed);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported interface %d\", bsp_priv->phy_iface);\n\t}\n}\n\nstatic int rk_gmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tconst struct rk_gmac_ops *data;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"no of match data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\t \n\tif (!plat_dat->has_gmac4)\n\t\tplat_dat->has_gmac = true;\n\tplat_dat->fix_mac_speed = rk_fix_speed;\n\n\tplat_dat->bsp_priv = rk_gmac_setup(pdev, plat_dat, data);\n\tif (IS_ERR(plat_dat->bsp_priv)) {\n\t\tret = PTR_ERR(plat_dat->bsp_priv);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tret = rk_gmac_clk_init(plat_dat);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = rk_gmac_powerup(plat_dat->bsp_priv);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto err_gmac_powerdown;\n\n\treturn 0;\n\nerr_gmac_powerdown:\n\trk_gmac_powerdown(plat_dat->bsp_priv);\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void rk_gmac_remove(struct platform_device *pdev)\n{\n\tstruct rk_priv_data *bsp_priv = get_stmmac_bsp_priv(&pdev->dev);\n\n\tstmmac_dvr_remove(&pdev->dev);\n\n\trk_gmac_powerdown(bsp_priv);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rk_gmac_suspend(struct device *dev)\n{\n\tstruct rk_priv_data *bsp_priv = get_stmmac_bsp_priv(dev);\n\tint ret = stmmac_suspend(dev);\n\n\t \n\tif (!device_may_wakeup(dev)) {\n\t\trk_gmac_powerdown(bsp_priv);\n\t\tbsp_priv->suspended = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int rk_gmac_resume(struct device *dev)\n{\n\tstruct rk_priv_data *bsp_priv = get_stmmac_bsp_priv(dev);\n\n\t \n\tif (bsp_priv->suspended) {\n\t\trk_gmac_powerup(bsp_priv);\n\t\tbsp_priv->suspended = false;\n\t}\n\n\treturn stmmac_resume(dev);\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(rk_gmac_pm_ops, rk_gmac_suspend, rk_gmac_resume);\n\nstatic const struct of_device_id rk_gmac_dwmac_match[] = {\n\t{ .compatible = \"rockchip,px30-gmac\",\t.data = &px30_ops   },\n\t{ .compatible = \"rockchip,rk3128-gmac\", .data = &rk3128_ops },\n\t{ .compatible = \"rockchip,rk3228-gmac\", .data = &rk3228_ops },\n\t{ .compatible = \"rockchip,rk3288-gmac\", .data = &rk3288_ops },\n\t{ .compatible = \"rockchip,rk3308-gmac\", .data = &rk3308_ops },\n\t{ .compatible = \"rockchip,rk3328-gmac\", .data = &rk3328_ops },\n\t{ .compatible = \"rockchip,rk3366-gmac\", .data = &rk3366_ops },\n\t{ .compatible = \"rockchip,rk3368-gmac\", .data = &rk3368_ops },\n\t{ .compatible = \"rockchip,rk3399-gmac\", .data = &rk3399_ops },\n\t{ .compatible = \"rockchip,rk3568-gmac\", .data = &rk3568_ops },\n\t{ .compatible = \"rockchip,rk3588-gmac\", .data = &rk3588_ops },\n\t{ .compatible = \"rockchip,rv1108-gmac\", .data = &rv1108_ops },\n\t{ .compatible = \"rockchip,rv1126-gmac\", .data = &rv1126_ops },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rk_gmac_dwmac_match);\n\nstatic struct platform_driver rk_gmac_dwmac_driver = {\n\t.probe  = rk_gmac_probe,\n\t.remove_new = rk_gmac_remove,\n\t.driver = {\n\t\t.name           = \"rk_gmac-dwmac\",\n\t\t.pm\t\t= &rk_gmac_pm_ops,\n\t\t.of_match_table = rk_gmac_dwmac_match,\n\t},\n};\nmodule_platform_driver(rk_gmac_dwmac_driver);\n\nMODULE_AUTHOR(\"Chen-Zhi (Roger Chen) <roger.chen@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip RK3288 DWMAC specific glue layer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}