{
  "module_name": "dwmac-sun8i.c",
  "hash_id": "6a0a8c2a026737bdef1288d14882c2ba268c08f8b219548b851cd5476cd4dc93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mdio-mux.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac.h\"\n#include \"stmmac_platform.h\"\n\n \n\n \nstruct emac_variant {\n\tu32 default_syscon_value;\n\tconst struct reg_field *syscon_field;\n\tbool soc_has_internal_phy;\n\tbool support_mii;\n\tbool support_rmii;\n\tbool support_rgmii;\n\tu8 rx_delay_max;\n\tu8 tx_delay_max;\n};\n\n \nstruct sunxi_priv_data {\n\tstruct clk *ephy_clk;\n\tstruct regulator *regulator;\n\tstruct reset_control *rst_ephy;\n\tconst struct emac_variant *variant;\n\tstruct regmap_field *regmap_field;\n\tbool internal_phy_powered;\n\tbool use_internal_phy;\n\tvoid *mux_handle;\n};\n\n \nstatic const struct reg_field sun8i_syscon_reg_field = {\n\t.reg = 0x30,\n\t.lsb = 0,\n\t.msb = 31,\n};\n\n \nstatic const struct reg_field sun8i_ccu_reg_field = {\n\t.reg = 0x164,\n\t.lsb = 0,\n\t.msb = 31,\n};\n\nstatic const struct emac_variant emac_variant_h3 = {\n\t.default_syscon_value = 0x58000,\n\t.syscon_field = &sun8i_syscon_reg_field,\n\t.soc_has_internal_phy = true,\n\t.support_mii = true,\n\t.support_rmii = true,\n\t.support_rgmii = true,\n\t.rx_delay_max = 31,\n\t.tx_delay_max = 7,\n};\n\nstatic const struct emac_variant emac_variant_v3s = {\n\t.default_syscon_value = 0x38000,\n\t.syscon_field = &sun8i_syscon_reg_field,\n\t.soc_has_internal_phy = true,\n\t.support_mii = true\n};\n\nstatic const struct emac_variant emac_variant_a83t = {\n\t.default_syscon_value = 0,\n\t.syscon_field = &sun8i_syscon_reg_field,\n\t.soc_has_internal_phy = false,\n\t.support_mii = true,\n\t.support_rgmii = true,\n\t.rx_delay_max = 31,\n\t.tx_delay_max = 7,\n};\n\nstatic const struct emac_variant emac_variant_r40 = {\n\t.default_syscon_value = 0,\n\t.syscon_field = &sun8i_ccu_reg_field,\n\t.support_mii = true,\n\t.support_rgmii = true,\n\t.rx_delay_max = 7,\n};\n\nstatic const struct emac_variant emac_variant_a64 = {\n\t.default_syscon_value = 0,\n\t.syscon_field = &sun8i_syscon_reg_field,\n\t.soc_has_internal_phy = false,\n\t.support_mii = true,\n\t.support_rmii = true,\n\t.support_rgmii = true,\n\t.rx_delay_max = 31,\n\t.tx_delay_max = 7,\n};\n\nstatic const struct emac_variant emac_variant_h6 = {\n\t.default_syscon_value = 0x50000,\n\t.syscon_field = &sun8i_syscon_reg_field,\n\t \n\t.soc_has_internal_phy = false,\n\t.support_mii = true,\n\t.support_rmii = true,\n\t.support_rgmii = true,\n\t.rx_delay_max = 31,\n\t.tx_delay_max = 7,\n};\n\n#define EMAC_BASIC_CTL0 0x00\n#define EMAC_BASIC_CTL1 0x04\n#define EMAC_INT_STA    0x08\n#define EMAC_INT_EN     0x0C\n#define EMAC_TX_CTL0    0x10\n#define EMAC_TX_CTL1    0x14\n#define EMAC_TX_FLOW_CTL        0x1C\n#define EMAC_TX_DESC_LIST 0x20\n#define EMAC_RX_CTL0    0x24\n#define EMAC_RX_CTL1    0x28\n#define EMAC_RX_DESC_LIST 0x34\n#define EMAC_RX_FRM_FLT 0x38\n#define EMAC_MDIO_CMD   0x48\n#define EMAC_MDIO_DATA  0x4C\n#define EMAC_MACADDR_HI(reg) (0x50 + (reg) * 8)\n#define EMAC_MACADDR_LO(reg) (0x54 + (reg) * 8)\n#define EMAC_TX_DMA_STA 0xB0\n#define EMAC_TX_CUR_DESC        0xB4\n#define EMAC_TX_CUR_BUF 0xB8\n#define EMAC_RX_DMA_STA 0xC0\n#define EMAC_RX_CUR_DESC        0xC4\n#define EMAC_RX_CUR_BUF 0xC8\n\n \n#define EMAC_DUPLEX_FULL\tBIT(0)\n#define EMAC_LOOPBACK\t\tBIT(1)\n#define EMAC_SPEED_1000 0\n#define EMAC_SPEED_100 (0x03 << 2)\n#define EMAC_SPEED_10 (0x02 << 2)\n\n \n#define EMAC_BURSTLEN_SHIFT\t\t24\n\n \n#define EMAC_FRM_FLT_RXALL              BIT(0)\n#define EMAC_FRM_FLT_CTL                BIT(13)\n#define EMAC_FRM_FLT_MULTICAST          BIT(16)\n\n \n#define EMAC_RX_MD              BIT(1)\n#define EMAC_RX_TH_MASK\t\tGENMASK(5, 4)\n#define EMAC_RX_TH_32\t\t0\n#define EMAC_RX_TH_64\t\t(0x1 << 4)\n#define EMAC_RX_TH_96\t\t(0x2 << 4)\n#define EMAC_RX_TH_128\t\t(0x3 << 4)\n#define EMAC_RX_DMA_EN  BIT(30)\n#define EMAC_RX_DMA_START       BIT(31)\n\n \n#define EMAC_TX_MD              BIT(1)\n#define EMAC_TX_NEXT_FRM        BIT(2)\n#define EMAC_TX_TH_MASK\t\tGENMASK(10, 8)\n#define EMAC_TX_TH_64\t\t0\n#define EMAC_TX_TH_128\t\t(0x1 << 8)\n#define EMAC_TX_TH_192\t\t(0x2 << 8)\n#define EMAC_TX_TH_256\t\t(0x3 << 8)\n#define EMAC_TX_DMA_EN  BIT(30)\n#define EMAC_TX_DMA_START       BIT(31)\n\n \n#define EMAC_RX_RECEIVER_EN             BIT(31)\n#define EMAC_RX_DO_CRC BIT(27)\n#define EMAC_RX_FLOW_CTL_EN             BIT(16)\n\n \n#define EMAC_TX_TRANSMITTER_EN  BIT(31)\n\n \n#define EMAC_TX_FLOW_CTL_EN             BIT(0)\n\n \n#define EMAC_TX_INT             BIT(0)\n#define EMAC_TX_DMA_STOP_INT    BIT(1)\n#define EMAC_TX_BUF_UA_INT      BIT(2)\n#define EMAC_TX_TIMEOUT_INT     BIT(3)\n#define EMAC_TX_UNDERFLOW_INT   BIT(4)\n#define EMAC_TX_EARLY_INT       BIT(5)\n#define EMAC_RX_INT             BIT(8)\n#define EMAC_RX_BUF_UA_INT      BIT(9)\n#define EMAC_RX_DMA_STOP_INT    BIT(10)\n#define EMAC_RX_TIMEOUT_INT     BIT(11)\n#define EMAC_RX_OVERFLOW_INT    BIT(12)\n#define EMAC_RX_EARLY_INT       BIT(13)\n#define EMAC_RGMII_STA_INT      BIT(16)\n\n#define EMAC_INT_MSK_COMMON\tEMAC_RGMII_STA_INT\n#define EMAC_INT_MSK_TX\t\t(EMAC_TX_INT | \\\n\t\t\t\t EMAC_TX_DMA_STOP_INT | \\\n\t\t\t\t EMAC_TX_BUF_UA_INT | \\\n\t\t\t\t EMAC_TX_TIMEOUT_INT | \\\n\t\t\t\t EMAC_TX_UNDERFLOW_INT | \\\n\t\t\t\t EMAC_TX_EARLY_INT |\\\n\t\t\t\t EMAC_INT_MSK_COMMON)\n#define EMAC_INT_MSK_RX\t\t(EMAC_RX_INT | \\\n\t\t\t\t EMAC_RX_BUF_UA_INT | \\\n\t\t\t\t EMAC_RX_DMA_STOP_INT | \\\n\t\t\t\t EMAC_RX_TIMEOUT_INT | \\\n\t\t\t\t EMAC_RX_OVERFLOW_INT | \\\n\t\t\t\t EMAC_RX_EARLY_INT | \\\n\t\t\t\t EMAC_INT_MSK_COMMON)\n\n#define MAC_ADDR_TYPE_DST BIT(31)\n\n \n#define H3_EPHY_ADDR_SHIFT\t20\n#define H3_EPHY_CLK_SEL\t\tBIT(18)  \n#define H3_EPHY_LED_POL\t\tBIT(17)  \n#define H3_EPHY_SHUTDOWN\tBIT(16)  \n#define H3_EPHY_SELECT\t\tBIT(15)  \n#define H3_EPHY_MUX_MASK\t(H3_EPHY_SHUTDOWN | H3_EPHY_SELECT)\n#define DWMAC_SUN8I_MDIO_MUX_INTERNAL_ID\t1\n#define DWMAC_SUN8I_MDIO_MUX_EXTERNAL_ID\t2\n\n \n#define SYSCON_RMII_EN\t\tBIT(13)  \n\n \n#define SYSCON_ETXDC_SHIFT\t\t10\n#define SYSCON_ERXDC_SHIFT\t\t5\n \n#define SYSCON_EPIT\t\t\tBIT(2)  \n#define SYSCON_ETCS_MASK\t\tGENMASK(1, 0)\n#define SYSCON_ETCS_MII\t\t0x0\n#define SYSCON_ETCS_EXT_GMII\t0x1\n#define SYSCON_ETCS_INT_GMII\t0x2\n\n \nstatic int sun8i_dwmac_dma_reset(void __iomem *ioaddr)\n{\n\twritel(0, ioaddr + EMAC_RX_CTL1);\n\twritel(0, ioaddr + EMAC_TX_CTL1);\n\twritel(0, ioaddr + EMAC_RX_FRM_FLT);\n\twritel(0, ioaddr + EMAC_RX_DESC_LIST);\n\twritel(0, ioaddr + EMAC_TX_DESC_LIST);\n\twritel(0, ioaddr + EMAC_INT_EN);\n\twritel(0x1FFFFFF, ioaddr + EMAC_INT_STA);\n\treturn 0;\n}\n\n \nstatic void sun8i_dwmac_dma_init(void __iomem *ioaddr,\n\t\t\t\t struct stmmac_dma_cfg *dma_cfg, int atds)\n{\n\twritel(EMAC_RX_INT | EMAC_TX_INT, ioaddr + EMAC_INT_EN);\n\twritel(0x1FFFFFF, ioaddr + EMAC_INT_STA);\n}\n\nstatic void sun8i_dwmac_dma_init_rx(struct stmmac_priv *priv,\n\t\t\t\t    void __iomem *ioaddr,\n\t\t\t\t    struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t    dma_addr_t dma_rx_phy, u32 chan)\n{\n\t \n\twritel(lower_32_bits(dma_rx_phy), ioaddr + EMAC_RX_DESC_LIST);\n}\n\nstatic void sun8i_dwmac_dma_init_tx(struct stmmac_priv *priv,\n\t\t\t\t    void __iomem *ioaddr,\n\t\t\t\t    struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t    dma_addr_t dma_tx_phy, u32 chan)\n{\n\t \n\twritel(lower_32_bits(dma_tx_phy), ioaddr + EMAC_TX_DESC_LIST);\n}\n\n \nstatic void sun8i_dwmac_dump_regs(struct stmmac_priv *priv,\n\t\t\t\t  void __iomem *ioaddr, u32 *reg_space)\n{\n\tint i;\n\n\tfor (i = 0; i < 0xC8; i += 4) {\n\t\tif (i == 0x32 || i == 0x3C)\n\t\t\tcontinue;\n\t\treg_space[i / 4] = readl(ioaddr + i);\n\t}\n}\n\n \nstatic void sun8i_dwmac_dump_mac_regs(struct mac_device_info *hw,\n\t\t\t\t      u32 *reg_space)\n{\n\tint i;\n\tvoid __iomem *ioaddr = hw->pcsr;\n\n\tfor (i = 0; i < 0xC8; i += 4) {\n\t\tif (i == 0x32 || i == 0x3C)\n\t\t\tcontinue;\n\t\treg_space[i / 4] = readl(ioaddr + i);\n\t}\n}\n\nstatic void sun8i_dwmac_enable_dma_irq(struct stmmac_priv *priv,\n\t\t\t\t       void __iomem *ioaddr, u32 chan,\n\t\t\t\t       bool rx, bool tx)\n{\n\tu32 value = readl(ioaddr + EMAC_INT_EN);\n\n\tif (rx)\n\t\tvalue |= EMAC_RX_INT;\n\tif (tx)\n\t\tvalue |= EMAC_TX_INT;\n\n\twritel(value, ioaddr + EMAC_INT_EN);\n}\n\nstatic void sun8i_dwmac_disable_dma_irq(struct stmmac_priv *priv,\n\t\t\t\t\tvoid __iomem *ioaddr, u32 chan,\n\t\t\t\t\tbool rx, bool tx)\n{\n\tu32 value = readl(ioaddr + EMAC_INT_EN);\n\n\tif (rx)\n\t\tvalue &= ~EMAC_RX_INT;\n\tif (tx)\n\t\tvalue &= ~EMAC_TX_INT;\n\n\twritel(value, ioaddr + EMAC_INT_EN);\n}\n\nstatic void sun8i_dwmac_dma_start_tx(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr, u32 chan)\n{\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_TX_CTL1);\n\tv |= EMAC_TX_DMA_START;\n\tv |= EMAC_TX_DMA_EN;\n\twritel(v, ioaddr + EMAC_TX_CTL1);\n}\n\nstatic void sun8i_dwmac_enable_dma_transmission(void __iomem *ioaddr)\n{\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_TX_CTL1);\n\tv |= EMAC_TX_DMA_START;\n\tv |= EMAC_TX_DMA_EN;\n\twritel(v, ioaddr + EMAC_TX_CTL1);\n}\n\nstatic void sun8i_dwmac_dma_stop_tx(struct stmmac_priv *priv,\n\t\t\t\t    void __iomem *ioaddr, u32 chan)\n{\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_TX_CTL1);\n\tv &= ~EMAC_TX_DMA_EN;\n\twritel(v, ioaddr + EMAC_TX_CTL1);\n}\n\nstatic void sun8i_dwmac_dma_start_rx(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr, u32 chan)\n{\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_RX_CTL1);\n\tv |= EMAC_RX_DMA_START;\n\tv |= EMAC_RX_DMA_EN;\n\twritel(v, ioaddr + EMAC_RX_CTL1);\n}\n\nstatic void sun8i_dwmac_dma_stop_rx(struct stmmac_priv *priv,\n\t\t\t\t    void __iomem *ioaddr, u32 chan)\n{\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_RX_CTL1);\n\tv &= ~EMAC_RX_DMA_EN;\n\twritel(v, ioaddr + EMAC_RX_CTL1);\n}\n\nstatic int sun8i_dwmac_dma_interrupt(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr,\n\t\t\t\t     struct stmmac_extra_stats *x, u32 chan,\n\t\t\t\t     u32 dir)\n{\n\tstruct stmmac_rxq_stats *rxq_stats = &priv->xstats.rxq_stats[chan];\n\tstruct stmmac_txq_stats *txq_stats = &priv->xstats.txq_stats[chan];\n\tint ret = 0;\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_INT_STA);\n\n\tif (dir == DMA_DIR_RX)\n\t\tv &= EMAC_INT_MSK_RX;\n\telse if (dir == DMA_DIR_TX)\n\t\tv &= EMAC_INT_MSK_TX;\n\n\tif (v & EMAC_TX_INT) {\n\t\tret |= handle_tx;\n\t\tu64_stats_update_begin(&txq_stats->syncp);\n\t\ttxq_stats->tx_normal_irq_n++;\n\t\tu64_stats_update_end(&txq_stats->syncp);\n\t}\n\n\tif (v & EMAC_TX_DMA_STOP_INT)\n\t\tx->tx_process_stopped_irq++;\n\n\tif (v & EMAC_TX_BUF_UA_INT)\n\t\tx->tx_process_stopped_irq++;\n\n\tif (v & EMAC_TX_TIMEOUT_INT)\n\t\tret |= tx_hard_error;\n\n\tif (v & EMAC_TX_UNDERFLOW_INT) {\n\t\tret |= tx_hard_error;\n\t\tx->tx_undeflow_irq++;\n\t}\n\n\tif (v & EMAC_TX_EARLY_INT)\n\t\tx->tx_early_irq++;\n\n\tif (v & EMAC_RX_INT) {\n\t\tret |= handle_rx;\n\t\tu64_stats_update_begin(&rxq_stats->syncp);\n\t\trxq_stats->rx_normal_irq_n++;\n\t\tu64_stats_update_end(&rxq_stats->syncp);\n\t}\n\n\tif (v & EMAC_RX_BUF_UA_INT)\n\t\tx->rx_buf_unav_irq++;\n\n\tif (v & EMAC_RX_DMA_STOP_INT)\n\t\tx->rx_process_stopped_irq++;\n\n\tif (v & EMAC_RX_TIMEOUT_INT)\n\t\tret |= tx_hard_error;\n\n\tif (v & EMAC_RX_OVERFLOW_INT) {\n\t\tret |= tx_hard_error;\n\t\tx->rx_overflow_irq++;\n\t}\n\n\tif (v & EMAC_RX_EARLY_INT)\n\t\tx->rx_early_irq++;\n\n\tif (v & EMAC_RGMII_STA_INT)\n\t\tx->irq_rgmii_n++;\n\n\twritel(v, ioaddr + EMAC_INT_STA);\n\n\treturn ret;\n}\n\nstatic void sun8i_dwmac_dma_operation_mode_rx(struct stmmac_priv *priv,\n\t\t\t\t\t      void __iomem *ioaddr, int mode,\n\t\t\t\t\t      u32 channel, int fifosz, u8 qmode)\n{\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_RX_CTL1);\n\tif (mode == SF_DMA_MODE) {\n\t\tv |= EMAC_RX_MD;\n\t} else {\n\t\tv &= ~EMAC_RX_MD;\n\t\tv &= ~EMAC_RX_TH_MASK;\n\t\tif (mode < 32)\n\t\t\tv |= EMAC_RX_TH_32;\n\t\telse if (mode < 64)\n\t\t\tv |= EMAC_RX_TH_64;\n\t\telse if (mode < 96)\n\t\t\tv |= EMAC_RX_TH_96;\n\t\telse if (mode < 128)\n\t\t\tv |= EMAC_RX_TH_128;\n\t}\n\twritel(v, ioaddr + EMAC_RX_CTL1);\n}\n\nstatic void sun8i_dwmac_dma_operation_mode_tx(struct stmmac_priv *priv,\n\t\t\t\t\t      void __iomem *ioaddr, int mode,\n\t\t\t\t\t      u32 channel, int fifosz, u8 qmode)\n{\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_TX_CTL1);\n\tif (mode == SF_DMA_MODE) {\n\t\tv |= EMAC_TX_MD;\n\t\t \n\t\tv |= EMAC_TX_NEXT_FRM;\n\t} else {\n\t\tv &= ~EMAC_TX_MD;\n\t\tv &= ~EMAC_TX_TH_MASK;\n\t\tif (mode < 64)\n\t\t\tv |= EMAC_TX_TH_64;\n\t\telse if (mode < 128)\n\t\t\tv |= EMAC_TX_TH_128;\n\t\telse if (mode < 192)\n\t\t\tv |= EMAC_TX_TH_192;\n\t\telse if (mode < 256)\n\t\t\tv |= EMAC_TX_TH_256;\n\t}\n\twritel(v, ioaddr + EMAC_TX_CTL1);\n}\n\nstatic const struct stmmac_dma_ops sun8i_dwmac_dma_ops = {\n\t.reset = sun8i_dwmac_dma_reset,\n\t.init = sun8i_dwmac_dma_init,\n\t.init_rx_chan = sun8i_dwmac_dma_init_rx,\n\t.init_tx_chan = sun8i_dwmac_dma_init_tx,\n\t.dump_regs = sun8i_dwmac_dump_regs,\n\t.dma_rx_mode = sun8i_dwmac_dma_operation_mode_rx,\n\t.dma_tx_mode = sun8i_dwmac_dma_operation_mode_tx,\n\t.enable_dma_transmission = sun8i_dwmac_enable_dma_transmission,\n\t.enable_dma_irq = sun8i_dwmac_enable_dma_irq,\n\t.disable_dma_irq = sun8i_dwmac_disable_dma_irq,\n\t.start_tx = sun8i_dwmac_dma_start_tx,\n\t.stop_tx = sun8i_dwmac_dma_stop_tx,\n\t.start_rx = sun8i_dwmac_dma_start_rx,\n\t.stop_rx = sun8i_dwmac_dma_stop_rx,\n\t.dma_interrupt = sun8i_dwmac_dma_interrupt,\n};\n\nstatic int sun8i_dwmac_power_internal_phy(struct stmmac_priv *priv);\n\nstatic int sun8i_dwmac_init(struct platform_device *pdev, void *priv)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct sunxi_priv_data *gmac = priv;\n\tint ret;\n\n\tif (gmac->regulator) {\n\t\tret = regulator_enable(gmac->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Fail to enable regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (gmac->use_internal_phy) {\n\t\tret = sun8i_dwmac_power_internal_phy(netdev_priv(ndev));\n\t\tif (ret)\n\t\t\tgoto err_disable_regulator;\n\t}\n\n\treturn 0;\n\nerr_disable_regulator:\n\tif (gmac->regulator)\n\t\tregulator_disable(gmac->regulator);\n\n\treturn ret;\n}\n\nstatic void sun8i_dwmac_core_init(struct mac_device_info *hw,\n\t\t\t\t  struct net_device *dev)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 v;\n\n\tv = (8 << EMAC_BURSTLEN_SHIFT);  \n\twritel(v, ioaddr + EMAC_BASIC_CTL1);\n}\n\nstatic void sun8i_dwmac_set_mac(void __iomem *ioaddr, bool enable)\n{\n\tu32 t, r;\n\n\tt = readl(ioaddr + EMAC_TX_CTL0);\n\tr = readl(ioaddr + EMAC_RX_CTL0);\n\tif (enable) {\n\t\tt |= EMAC_TX_TRANSMITTER_EN;\n\t\tr |= EMAC_RX_RECEIVER_EN;\n\t} else {\n\t\tt &= ~EMAC_TX_TRANSMITTER_EN;\n\t\tr &= ~EMAC_RX_RECEIVER_EN;\n\t}\n\twritel(t, ioaddr + EMAC_TX_CTL0);\n\twritel(r, ioaddr + EMAC_RX_CTL0);\n}\n\n \nstatic void sun8i_dwmac_set_umac_addr(struct mac_device_info *hw,\n\t\t\t\t      const unsigned char *addr,\n\t\t\t\t      unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 v;\n\n\tif (!addr) {\n\t\twritel(0, ioaddr + EMAC_MACADDR_HI(reg_n));\n\t\treturn;\n\t}\n\n\tstmmac_set_mac_addr(ioaddr, addr, EMAC_MACADDR_HI(reg_n),\n\t\t\t    EMAC_MACADDR_LO(reg_n));\n\tif (reg_n > 0) {\n\t\tv = readl(ioaddr + EMAC_MACADDR_HI(reg_n));\n\t\tv |= MAC_ADDR_TYPE_DST;\n\t\twritel(v, ioaddr + EMAC_MACADDR_HI(reg_n));\n\t}\n}\n\nstatic void sun8i_dwmac_get_umac_addr(struct mac_device_info *hw,\n\t\t\t\t      unsigned char *addr,\n\t\t\t\t      unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\n\tstmmac_get_mac_addr(ioaddr, addr, EMAC_MACADDR_HI(reg_n),\n\t\t\t    EMAC_MACADDR_LO(reg_n));\n}\n\n \nstatic int sun8i_dwmac_rx_ipc_enable(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_RX_CTL0);\n\tv |= EMAC_RX_DO_CRC;\n\twritel(v, ioaddr + EMAC_RX_CTL0);\n\n\treturn 1;\n}\n\nstatic void sun8i_dwmac_set_filter(struct mac_device_info *hw,\n\t\t\t\t   struct net_device *dev)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 v;\n\tint i = 1;\n\tstruct netdev_hw_addr *ha;\n\tint macaddrs = netdev_uc_count(dev) + netdev_mc_count(dev) + 1;\n\n\tv = EMAC_FRM_FLT_CTL;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tv = EMAC_FRM_FLT_RXALL;\n\t} else if (dev->flags & IFF_ALLMULTI) {\n\t\tv |= EMAC_FRM_FLT_MULTICAST;\n\t} else if (macaddrs <= hw->unicast_filter_entries) {\n\t\tif (!netdev_mc_empty(dev)) {\n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\tsun8i_dwmac_set_umac_addr(hw, ha->addr, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (!netdev_uc_empty(dev)) {\n\t\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\t\tsun8i_dwmac_set_umac_addr(hw, ha->addr, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!(readl(ioaddr + EMAC_RX_FRM_FLT) & EMAC_FRM_FLT_RXALL))\n\t\t\tnetdev_info(dev, \"Too many address, switching to promiscuous\\n\");\n\t\tv = EMAC_FRM_FLT_RXALL;\n\t}\n\n\t \n\twhile (i < hw->unicast_filter_entries)\n\t\tsun8i_dwmac_set_umac_addr(hw, NULL, i++);\n\n\twritel(v, ioaddr + EMAC_RX_FRM_FLT);\n}\n\nstatic void sun8i_dwmac_flow_ctrl(struct mac_device_info *hw,\n\t\t\t\t  unsigned int duplex, unsigned int fc,\n\t\t\t\t  unsigned int pause_time, u32 tx_cnt)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 v;\n\n\tv = readl(ioaddr + EMAC_RX_CTL0);\n\tif (fc == FLOW_AUTO)\n\t\tv |= EMAC_RX_FLOW_CTL_EN;\n\telse\n\t\tv &= ~EMAC_RX_FLOW_CTL_EN;\n\twritel(v, ioaddr + EMAC_RX_CTL0);\n\n\tv = readl(ioaddr + EMAC_TX_FLOW_CTL);\n\tif (fc == FLOW_AUTO)\n\t\tv |= EMAC_TX_FLOW_CTL_EN;\n\telse\n\t\tv &= ~EMAC_TX_FLOW_CTL_EN;\n\twritel(v, ioaddr + EMAC_TX_FLOW_CTL);\n}\n\nstatic int sun8i_dwmac_reset(struct stmmac_priv *priv)\n{\n\tu32 v;\n\tint err;\n\n\tv = readl(priv->ioaddr + EMAC_BASIC_CTL1);\n\twritel(v | 0x01, priv->ioaddr + EMAC_BASIC_CTL1);\n\n\t \n\terr = readl_poll_timeout(priv->ioaddr + EMAC_BASIC_CTL1, v,\n\t\t\t\t !(v & 0x01), 100, 100000);\n\n\tif (err) {\n\t\tdev_err(priv->device, \"EMAC reset timeout\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int get_ephy_nodes(struct stmmac_priv *priv)\n{\n\tstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\n\tstruct device_node *mdio_mux, *iphynode;\n\tstruct device_node *mdio_internal;\n\tint ret;\n\n\tmdio_mux = of_get_child_by_name(priv->device->of_node, \"mdio-mux\");\n\tif (!mdio_mux) {\n\t\tdev_err(priv->device, \"Cannot get mdio-mux node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmdio_internal = of_get_compatible_child(mdio_mux,\n\t\t\t\t\t\t\"allwinner,sun8i-h3-mdio-internal\");\n\tof_node_put(mdio_mux);\n\tif (!mdio_internal) {\n\t\tdev_err(priv->device, \"Cannot get internal_mdio node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor_each_child_of_node(mdio_internal, iphynode) {\n\t\tgmac->ephy_clk = of_clk_get(iphynode, 0);\n\t\tif (IS_ERR(gmac->ephy_clk))\n\t\t\tcontinue;\n\t\tgmac->rst_ephy = of_reset_control_get_exclusive(iphynode, NULL);\n\t\tif (IS_ERR(gmac->rst_ephy)) {\n\t\t\tret = PTR_ERR(gmac->rst_ephy);\n\t\t\tif (ret == -EPROBE_DEFER) {\n\t\t\t\tof_node_put(iphynode);\n\t\t\t\tof_node_put(mdio_internal);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdev_info(priv->device, \"Found internal PHY node\\n\");\n\t\tof_node_put(iphynode);\n\t\tof_node_put(mdio_internal);\n\t\treturn 0;\n\t}\n\n\tof_node_put(mdio_internal);\n\treturn -ENODEV;\n}\n\nstatic int sun8i_dwmac_power_internal_phy(struct stmmac_priv *priv)\n{\n\tstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\n\tint ret;\n\n\tif (gmac->internal_phy_powered) {\n\t\tdev_warn(priv->device, \"Internal PHY already powered\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_info(priv->device, \"Powering internal PHY\\n\");\n\tret = clk_prepare_enable(gmac->ephy_clk);\n\tif (ret) {\n\t\tdev_err(priv->device, \"Cannot enable internal PHY\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = reset_control_reset(gmac->rst_ephy);\n\tif (ret) {\n\t\tdev_err(priv->device, \"Cannot reset internal PHY\\n\");\n\t\tclk_disable_unprepare(gmac->ephy_clk);\n\t\treturn ret;\n\t}\n\n\tgmac->internal_phy_powered = true;\n\n\treturn 0;\n}\n\nstatic void sun8i_dwmac_unpower_internal_phy(struct sunxi_priv_data *gmac)\n{\n\tif (!gmac->internal_phy_powered)\n\t\treturn;\n\n\tclk_disable_unprepare(gmac->ephy_clk);\n\treset_control_assert(gmac->rst_ephy);\n\tgmac->internal_phy_powered = false;\n}\n\n \nstatic int mdio_mux_syscon_switch_fn(int current_child, int desired_child,\n\t\t\t\t     void *data)\n{\n\tstruct stmmac_priv *priv = data;\n\tstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\n\tu32 reg, val;\n\tint ret = 0;\n\n\tif (current_child ^ desired_child) {\n\t\tregmap_field_read(gmac->regmap_field, &reg);\n\t\tswitch (desired_child) {\n\t\tcase DWMAC_SUN8I_MDIO_MUX_INTERNAL_ID:\n\t\t\tdev_info(priv->device, \"Switch mux to internal PHY\");\n\t\t\tval = (reg & ~H3_EPHY_MUX_MASK) | H3_EPHY_SELECT;\n\t\t\tgmac->use_internal_phy = true;\n\t\t\tbreak;\n\t\tcase DWMAC_SUN8I_MDIO_MUX_EXTERNAL_ID:\n\t\t\tdev_info(priv->device, \"Switch mux to external PHY\");\n\t\t\tval = (reg & ~H3_EPHY_MUX_MASK) | H3_EPHY_SHUTDOWN;\n\t\t\tgmac->use_internal_phy = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(priv->device, \"Invalid child ID %x\\n\",\n\t\t\t\tdesired_child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregmap_field_write(gmac->regmap_field, val);\n\t\tif (gmac->use_internal_phy) {\n\t\t\tret = sun8i_dwmac_power_internal_phy(priv);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tsun8i_dwmac_unpower_internal_phy(gmac);\n\t\t}\n\t\t \n\t\tret = sun8i_dwmac_reset(priv);\n\t}\n\treturn ret;\n}\n\nstatic int sun8i_dwmac_register_mdio_mux(struct stmmac_priv *priv)\n{\n\tint ret;\n\tstruct device_node *mdio_mux;\n\tstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\n\n\tmdio_mux = of_get_child_by_name(priv->device->of_node, \"mdio-mux\");\n\tif (!mdio_mux)\n\t\treturn -ENODEV;\n\n\tret = mdio_mux_init(priv->device, mdio_mux, mdio_mux_syscon_switch_fn,\n\t\t\t    &gmac->mux_handle, priv, priv->mii);\n\tof_node_put(mdio_mux);\n\treturn ret;\n}\n\nstatic int sun8i_dwmac_set_syscon(struct device *dev,\n\t\t\t\t  struct plat_stmmacenet_data *plat)\n{\n\tstruct sunxi_priv_data *gmac = plat->bsp_priv;\n\tstruct device_node *node = dev->of_node;\n\tint ret;\n\tu32 reg, val;\n\n\tret = regmap_field_read(gmac->regmap_field, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"Fail to read from regmap field.\\n\");\n\t\treturn ret;\n\t}\n\n\treg = gmac->variant->default_syscon_value;\n\tif (reg != val)\n\t\tdev_warn(dev,\n\t\t\t \"Current syscon value is not the default %x (expect %x)\\n\",\n\t\t\t val, reg);\n\n\tif (gmac->variant->soc_has_internal_phy) {\n\t\tif (of_property_read_bool(node, \"allwinner,leds-active-low\"))\n\t\t\treg |= H3_EPHY_LED_POL;\n\t\telse\n\t\t\treg &= ~H3_EPHY_LED_POL;\n\n\t\t \n\t\treg |= H3_EPHY_CLK_SEL;\n\n\t\tret = of_mdio_parse_addr(dev, plat->phy_node);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Could not parse MDIO addr\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\treg |= 1 << H3_EPHY_ADDR_SHIFT;\n\t} else {\n\t\t \n\t\treg &= ~H3_EPHY_SELECT;\n\t}\n\n\tif (!of_property_read_u32(node, \"allwinner,tx-delay-ps\", &val)) {\n\t\tif (val % 100) {\n\t\t\tdev_err(dev, \"tx-delay must be a multiple of 100\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval /= 100;\n\t\tdev_dbg(dev, \"set tx-delay to %x\\n\", val);\n\t\tif (val <= gmac->variant->tx_delay_max) {\n\t\t\treg &= ~(gmac->variant->tx_delay_max <<\n\t\t\t\t SYSCON_ETXDC_SHIFT);\n\t\t\treg |= (val << SYSCON_ETXDC_SHIFT);\n\t\t} else {\n\t\t\tdev_err(dev, \"Invalid TX clock delay: %d\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!of_property_read_u32(node, \"allwinner,rx-delay-ps\", &val)) {\n\t\tif (val % 100) {\n\t\t\tdev_err(dev, \"rx-delay must be a multiple of 100\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval /= 100;\n\t\tdev_dbg(dev, \"set rx-delay to %x\\n\", val);\n\t\tif (val <= gmac->variant->rx_delay_max) {\n\t\t\treg &= ~(gmac->variant->rx_delay_max <<\n\t\t\t\t SYSCON_ERXDC_SHIFT);\n\t\t\treg |= (val << SYSCON_ERXDC_SHIFT);\n\t\t} else {\n\t\t\tdev_err(dev, \"Invalid RX clock delay: %d\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\treg &= ~(SYSCON_ETCS_MASK | SYSCON_EPIT);\n\tif (gmac->variant->support_rmii)\n\t\treg &= ~SYSCON_RMII_EN;\n\n\tswitch (plat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\t \n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\treg |= SYSCON_EPIT | SYSCON_ETCS_INT_GMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\treg |= SYSCON_RMII_EN | SYSCON_ETCS_EXT_GMII;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported interface mode: %s\",\n\t\t\tphy_modes(plat->mac_interface));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_field_write(gmac->regmap_field, reg);\n\n\treturn 0;\n}\n\nstatic void sun8i_dwmac_unset_syscon(struct sunxi_priv_data *gmac)\n{\n\tu32 reg = gmac->variant->default_syscon_value;\n\n\tregmap_field_write(gmac->regmap_field, reg);\n}\n\nstatic void sun8i_dwmac_exit(struct platform_device *pdev, void *priv)\n{\n\tstruct sunxi_priv_data *gmac = priv;\n\n\tif (gmac->variant->soc_has_internal_phy)\n\t\tsun8i_dwmac_unpower_internal_phy(gmac);\n\n\tif (gmac->regulator)\n\t\tregulator_disable(gmac->regulator);\n}\n\nstatic void sun8i_dwmac_set_mac_loopback(void __iomem *ioaddr, bool enable)\n{\n\tu32 value = readl(ioaddr + EMAC_BASIC_CTL0);\n\n\tif (enable)\n\t\tvalue |= EMAC_LOOPBACK;\n\telse\n\t\tvalue &= ~EMAC_LOOPBACK;\n\n\twritel(value, ioaddr + EMAC_BASIC_CTL0);\n}\n\nstatic const struct stmmac_ops sun8i_dwmac_ops = {\n\t.core_init = sun8i_dwmac_core_init,\n\t.set_mac = sun8i_dwmac_set_mac,\n\t.dump_regs = sun8i_dwmac_dump_mac_regs,\n\t.rx_ipc = sun8i_dwmac_rx_ipc_enable,\n\t.set_filter = sun8i_dwmac_set_filter,\n\t.flow_ctrl = sun8i_dwmac_flow_ctrl,\n\t.set_umac_addr = sun8i_dwmac_set_umac_addr,\n\t.get_umac_addr = sun8i_dwmac_get_umac_addr,\n\t.set_mac_loopback = sun8i_dwmac_set_mac_loopback,\n};\n\nstatic struct mac_device_info *sun8i_dwmac_setup(void *ppriv)\n{\n\tstruct mac_device_info *mac;\n\tstruct stmmac_priv *priv = ppriv;\n\n\tmac = devm_kzalloc(priv->device, sizeof(*mac), GFP_KERNEL);\n\tif (!mac)\n\t\treturn NULL;\n\n\tmac->pcsr = priv->ioaddr;\n\tmac->mac = &sun8i_dwmac_ops;\n\tmac->dma = &sun8i_dwmac_dma_ops;\n\n\tpriv->dev->priv_flags |= IFF_UNICAST_FLT;\n\n\t \n\tmac->link.speed_mask = GENMASK(3, 2) | EMAC_LOOPBACK;\n\tmac->link.speed10 = EMAC_SPEED_10;\n\tmac->link.speed100 = EMAC_SPEED_100;\n\tmac->link.speed1000 = EMAC_SPEED_1000;\n\tmac->link.duplex = EMAC_DUPLEX_FULL;\n\tmac->mii.addr = EMAC_MDIO_CMD;\n\tmac->mii.data = EMAC_MDIO_DATA;\n\tmac->mii.reg_shift = 4;\n\tmac->mii.reg_mask = GENMASK(8, 4);\n\tmac->mii.addr_shift = 12;\n\tmac->mii.addr_mask = GENMASK(16, 12);\n\tmac->mii.clk_csr_shift = 20;\n\tmac->mii.clk_csr_mask = GENMASK(22, 20);\n\tmac->unicast_filter_entries = 8;\n\n\t \n\tpriv->synopsys_id = 0;\n\n\treturn mac;\n}\n\nstatic struct regmap *sun8i_dwmac_get_syscon_from_dev(struct device_node *node)\n{\n\tstruct device_node *syscon_node;\n\tstruct platform_device *syscon_pdev;\n\tstruct regmap *regmap = NULL;\n\n\tsyscon_node = of_parse_phandle(node, \"syscon\", 0);\n\tif (!syscon_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsyscon_pdev = of_find_device_by_node(syscon_node);\n\tif (!syscon_pdev) {\n\t\t \n\t\tregmap = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out_put_node;\n\t}\n\n\t \n\tregmap = dev_get_regmap(&syscon_pdev->dev, NULL);\n\tif (!regmap)\n\t\tregmap = ERR_PTR(-EINVAL);\n\n\tplatform_device_put(syscon_pdev);\nout_put_node:\n\tof_node_put(syscon_node);\n\treturn regmap;\n}\n\nstatic int sun8i_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct sunxi_priv_data *gmac;\n\tstruct device *dev = &pdev->dev;\n\tphy_interface_t interface;\n\tint ret;\n\tstruct stmmac_priv *priv;\n\tstruct net_device *ndev;\n\tstruct regmap *regmap;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tgmac = devm_kzalloc(dev, sizeof(*gmac), GFP_KERNEL);\n\tif (!gmac)\n\t\treturn -ENOMEM;\n\n\tgmac->variant = of_device_get_match_data(&pdev->dev);\n\tif (!gmac->variant) {\n\t\tdev_err(&pdev->dev, \"Missing dwmac-sun8i variant\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tgmac->regulator = devm_regulator_get_optional(dev, \"phy\");\n\tif (IS_ERR(gmac->regulator)) {\n\t\tif (PTR_ERR(gmac->regulator) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(dev, \"No regulator found\\n\");\n\t\tgmac->regulator = NULL;\n\t}\n\n\t \n\tregmap = sun8i_dwmac_get_syscon_from_dev(pdev->dev.of_node);\n\tif (IS_ERR(regmap))\n\t\tregmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t \"syscon\");\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(&pdev->dev, \"Unable to map syscon: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgmac->regmap_field = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t     *gmac->variant->syscon_field);\n\tif (IS_ERR(gmac->regmap_field)) {\n\t\tret = PTR_ERR(gmac->regmap_field);\n\t\tdev_err(dev, \"Unable to map syscon register: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_get_phy_mode(dev->of_node, &interface);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\t \n\tplat_dat->mac_interface = interface;\n\tplat_dat->rx_coe = STMMAC_RX_COE_TYPE2;\n\tplat_dat->tx_coe = 1;\n\tplat_dat->flags |= STMMAC_FLAG_HAS_SUN8I;\n\tplat_dat->bsp_priv = gmac;\n\tplat_dat->init = sun8i_dwmac_init;\n\tplat_dat->exit = sun8i_dwmac_exit;\n\tplat_dat->setup = sun8i_dwmac_setup;\n\tplat_dat->tx_fifo_size = 4096;\n\tplat_dat->rx_fifo_size = 16384;\n\n\tret = sun8i_dwmac_set_syscon(&pdev->dev, plat_dat);\n\tif (ret)\n\t\tgoto dwmac_deconfig;\n\n\tret = sun8i_dwmac_init(pdev, plat_dat->bsp_priv);\n\tif (ret)\n\t\tgoto dwmac_syscon;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto dwmac_exit;\n\n\tndev = dev_get_drvdata(&pdev->dev);\n\tpriv = netdev_priv(ndev);\n\n\t \n\tpm_runtime_get_sync(&pdev->dev);\n\n\t \n\tif (gmac->variant->soc_has_internal_phy) {\n\t\tret = get_ephy_nodes(priv);\n\t\tif (ret)\n\t\t\tgoto dwmac_remove;\n\t\tret = sun8i_dwmac_register_mdio_mux(priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register mux\\n\");\n\t\t\tgoto dwmac_mux;\n\t\t}\n\t} else {\n\t\tret = sun8i_dwmac_reset(priv);\n\t\tif (ret)\n\t\t\tgoto dwmac_remove;\n\t}\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\ndwmac_mux:\n\treset_control_put(gmac->rst_ephy);\n\tclk_put(gmac->ephy_clk);\ndwmac_remove:\n\tpm_runtime_put_noidle(&pdev->dev);\n\tstmmac_dvr_remove(&pdev->dev);\ndwmac_exit:\n\tsun8i_dwmac_exit(pdev, gmac);\ndwmac_syscon:\n\tsun8i_dwmac_unset_syscon(gmac);\ndwmac_deconfig:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void sun8i_dwmac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\n\n\tif (gmac->variant->soc_has_internal_phy) {\n\t\tmdio_mux_uninit(gmac->mux_handle);\n\t\tsun8i_dwmac_unpower_internal_phy(gmac);\n\t\treset_control_put(gmac->rst_ephy);\n\t\tclk_put(gmac->ephy_clk);\n\t}\n\n\tstmmac_pltfr_remove(pdev);\n\tsun8i_dwmac_unset_syscon(gmac);\n}\n\nstatic void sun8i_dwmac_shutdown(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\n\n\tsun8i_dwmac_exit(pdev, gmac);\n}\n\nstatic const struct of_device_id sun8i_dwmac_match[] = {\n\t{ .compatible = \"allwinner,sun8i-h3-emac\",\n\t\t.data = &emac_variant_h3 },\n\t{ .compatible = \"allwinner,sun8i-v3s-emac\",\n\t\t.data = &emac_variant_v3s },\n\t{ .compatible = \"allwinner,sun8i-a83t-emac\",\n\t\t.data = &emac_variant_a83t },\n\t{ .compatible = \"allwinner,sun8i-r40-gmac\",\n\t\t.data = &emac_variant_r40 },\n\t{ .compatible = \"allwinner,sun50i-a64-emac\",\n\t\t.data = &emac_variant_a64 },\n\t{ .compatible = \"allwinner,sun50i-h6-emac\",\n\t\t.data = &emac_variant_h6 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun8i_dwmac_match);\n\nstatic struct platform_driver sun8i_dwmac_driver = {\n\t.probe  = sun8i_dwmac_probe,\n\t.remove_new = sun8i_dwmac_remove,\n\t.shutdown = sun8i_dwmac_shutdown,\n\t.driver = {\n\t\t.name           = \"dwmac-sun8i\",\n\t\t.pm\t\t= &stmmac_pltfr_pm_ops,\n\t\t.of_match_table = sun8i_dwmac_match,\n\t},\n};\nmodule_platform_driver(sun8i_dwmac_driver);\n\nMODULE_AUTHOR(\"Corentin Labbe <clabbe.montjoie@gmail.com>\");\nMODULE_DESCRIPTION(\"Allwinner sun8i DWMAC specific glue layer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}