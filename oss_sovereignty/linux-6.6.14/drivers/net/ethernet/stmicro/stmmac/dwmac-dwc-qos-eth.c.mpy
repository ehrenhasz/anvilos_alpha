{
  "module_name": "dwmac-dwc-qos-eth.c",
  "hash_id": "41b9d49c35d7d301a1bdb326a34911210fcec5cd2ad5a6a2633acadc85e045ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-dwc-qos-eth.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/ethtool.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac_platform.h\"\n#include \"dwmac4.h\"\n\nstruct tegra_eqos {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\n\tstruct reset_control *rst;\n\tstruct clk *clk_master;\n\tstruct clk *clk_slave;\n\tstruct clk *clk_tx;\n\tstruct clk *clk_rx;\n\n\tstruct gpio_desc *reset;\n};\n\nstatic int dwc_eth_dwmac_config_dt(struct platform_device *pdev,\n\t\t\t\t   struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct device *dev = &pdev->dev;\n\tu32 burst_map = 0;\n\tu32 bit_index = 0;\n\tu32 a_index = 0;\n\n\tif (!plat_dat->axi) {\n\t\tplat_dat->axi = kzalloc(sizeof(struct stmmac_axi), GFP_KERNEL);\n\n\t\tif (!plat_dat->axi)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tplat_dat->axi->axi_lpi_en = device_property_read_bool(dev,\n\t\t\t\t\t\t\t      \"snps,en-lpi\");\n\tif (device_property_read_u32(dev, \"snps,write-requests\",\n\t\t\t\t     &plat_dat->axi->axi_wr_osr_lmt)) {\n\t\t \n\t\tplat_dat->axi->axi_wr_osr_lmt = 1;\n\t} else {\n\t\t \n\t\tplat_dat->axi->axi_wr_osr_lmt--;\n\t}\n\n\tif (device_property_read_u32(dev, \"snps,read-requests\",\n\t\t\t\t     &plat_dat->axi->axi_rd_osr_lmt)) {\n\t\t \n\t\tplat_dat->axi->axi_rd_osr_lmt = 1;\n\t} else {\n\t\t \n\t\tplat_dat->axi->axi_rd_osr_lmt--;\n\t}\n\tdevice_property_read_u32(dev, \"snps,burst-map\", &burst_map);\n\n\t \n\tfor (bit_index = 0; bit_index < 7; bit_index++) {\n\t\tif (burst_map & (1 << bit_index)) {\n\t\t\tswitch (bit_index) {\n\t\t\tcase 0:\n\t\t\tplat_dat->axi->axi_blen[a_index] = 4; break;\n\t\t\tcase 1:\n\t\t\tplat_dat->axi->axi_blen[a_index] = 8; break;\n\t\t\tcase 2:\n\t\t\tplat_dat->axi->axi_blen[a_index] = 16; break;\n\t\t\tcase 3:\n\t\t\tplat_dat->axi->axi_blen[a_index] = 32; break;\n\t\t\tcase 4:\n\t\t\tplat_dat->axi->axi_blen[a_index] = 64; break;\n\t\t\tcase 5:\n\t\t\tplat_dat->axi->axi_blen[a_index] = 128; break;\n\t\t\tcase 6:\n\t\t\tplat_dat->axi->axi_blen[a_index] = 256; break;\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t\t}\n\t\t\ta_index++;\n\t\t}\n\t}\n\n\t \n\tplat_dat->has_gmac4 = 1;\n\tplat_dat->dma_cfg->aal = 1;\n\tplat_dat->flags |= STMMAC_FLAG_TSO_EN;\n\tplat_dat->pmt = 1;\n\n\treturn 0;\n}\n\nstatic int dwc_qos_probe(struct platform_device *pdev,\n\t\t\t struct plat_stmmacenet_data *plat_dat,\n\t\t\t struct stmmac_resources *stmmac_res)\n{\n\tint err;\n\n\tplat_dat->stmmac_clk = devm_clk_get(&pdev->dev, \"apb_pclk\");\n\tif (IS_ERR(plat_dat->stmmac_clk)) {\n\t\tdev_err(&pdev->dev, \"apb_pclk clock not found.\\n\");\n\t\treturn PTR_ERR(plat_dat->stmmac_clk);\n\t}\n\n\terr = clk_prepare_enable(plat_dat->stmmac_clk);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable apb_pclk clock: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tplat_dat->pclk = devm_clk_get(&pdev->dev, \"phy_ref_clk\");\n\tif (IS_ERR(plat_dat->pclk)) {\n\t\tdev_err(&pdev->dev, \"phy_ref_clk clock not found.\\n\");\n\t\terr = PTR_ERR(plat_dat->pclk);\n\t\tgoto disable;\n\t}\n\n\terr = clk_prepare_enable(plat_dat->pclk);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable phy_ref clock: %d\\n\",\n\t\t\terr);\n\t\tgoto disable;\n\t}\n\n\treturn 0;\n\ndisable:\n\tclk_disable_unprepare(plat_dat->stmmac_clk);\n\treturn err;\n}\n\nstatic void dwc_qos_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\tclk_disable_unprepare(priv->plat->pclk);\n\tclk_disable_unprepare(priv->plat->stmmac_clk);\n}\n\n#define SDMEMCOMPPADCTRL 0x8800\n#define  SDMEMCOMPPADCTRL_PAD_E_INPUT_OR_E_PWRD BIT(31)\n\n#define AUTO_CAL_CONFIG 0x8804\n#define  AUTO_CAL_CONFIG_START BIT(31)\n#define  AUTO_CAL_CONFIG_ENABLE BIT(29)\n\n#define AUTO_CAL_STATUS 0x880c\n#define  AUTO_CAL_STATUS_ACTIVE BIT(31)\n\nstatic void tegra_eqos_fix_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct tegra_eqos *eqos = priv;\n\tunsigned long rate = 125000000;\n\tbool needs_calibration = false;\n\tu32 value;\n\tint err;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tneeds_calibration = true;\n\t\trate = 125000000;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tneeds_calibration = true;\n\t\trate = 25000000;\n\t\tbreak;\n\n\tcase SPEED_10:\n\t\trate = 2500000;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(eqos->dev, \"invalid speed %u\\n\", speed);\n\t\tbreak;\n\t}\n\n\tif (needs_calibration) {\n\t\t \n\t\tvalue = readl(eqos->regs + SDMEMCOMPPADCTRL);\n\t\tvalue |= SDMEMCOMPPADCTRL_PAD_E_INPUT_OR_E_PWRD;\n\t\twritel(value, eqos->regs + SDMEMCOMPPADCTRL);\n\n\t\tudelay(1);\n\n\t\tvalue = readl(eqos->regs + AUTO_CAL_CONFIG);\n\t\tvalue |= AUTO_CAL_CONFIG_START | AUTO_CAL_CONFIG_ENABLE;\n\t\twritel(value, eqos->regs + AUTO_CAL_CONFIG);\n\n\t\terr = readl_poll_timeout_atomic(eqos->regs + AUTO_CAL_STATUS,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tvalue & AUTO_CAL_STATUS_ACTIVE,\n\t\t\t\t\t\t1, 10);\n\t\tif (err < 0) {\n\t\t\tdev_err(eqos->dev, \"calibration did not start\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\terr = readl_poll_timeout_atomic(eqos->regs + AUTO_CAL_STATUS,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t(value & AUTO_CAL_STATUS_ACTIVE) == 0,\n\t\t\t\t\t\t20, 200);\n\t\tif (err < 0) {\n\t\t\tdev_err(eqos->dev, \"calibration didn't finish\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\tfailed:\n\t\tvalue = readl(eqos->regs + SDMEMCOMPPADCTRL);\n\t\tvalue &= ~SDMEMCOMPPADCTRL_PAD_E_INPUT_OR_E_PWRD;\n\t\twritel(value, eqos->regs + SDMEMCOMPPADCTRL);\n\t} else {\n\t\tvalue = readl(eqos->regs + AUTO_CAL_CONFIG);\n\t\tvalue &= ~AUTO_CAL_CONFIG_ENABLE;\n\t\twritel(value, eqos->regs + AUTO_CAL_CONFIG);\n\t}\n\n\terr = clk_set_rate(eqos->clk_tx, rate);\n\tif (err < 0)\n\t\tdev_err(eqos->dev, \"failed to set TX rate: %d\\n\", err);\n}\n\nstatic int tegra_eqos_init(struct platform_device *pdev, void *priv)\n{\n\tstruct tegra_eqos *eqos = priv;\n\tunsigned long rate;\n\tu32 value;\n\n\trate = clk_get_rate(eqos->clk_slave);\n\n\tvalue = (rate / 1000000) - 1;\n\twritel(value, eqos->regs + GMAC_1US_TIC_COUNTER);\n\n\treturn 0;\n}\n\nstatic int tegra_eqos_probe(struct platform_device *pdev,\n\t\t\t    struct plat_stmmacenet_data *data,\n\t\t\t    struct stmmac_resources *res)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra_eqos *eqos;\n\tint err;\n\n\teqos = devm_kzalloc(&pdev->dev, sizeof(*eqos), GFP_KERNEL);\n\tif (!eqos)\n\t\treturn -ENOMEM;\n\n\teqos->dev = &pdev->dev;\n\teqos->regs = res->addr;\n\n\tif (!is_of_node(dev->fwnode))\n\t\tgoto bypass_clk_reset_gpio;\n\n\teqos->clk_master = devm_clk_get(&pdev->dev, \"master_bus\");\n\tif (IS_ERR(eqos->clk_master)) {\n\t\terr = PTR_ERR(eqos->clk_master);\n\t\tgoto error;\n\t}\n\n\terr = clk_prepare_enable(eqos->clk_master);\n\tif (err < 0)\n\t\tgoto error;\n\n\teqos->clk_slave = devm_clk_get(&pdev->dev, \"slave_bus\");\n\tif (IS_ERR(eqos->clk_slave)) {\n\t\terr = PTR_ERR(eqos->clk_slave);\n\t\tgoto disable_master;\n\t}\n\n\tdata->stmmac_clk = eqos->clk_slave;\n\n\terr = clk_prepare_enable(eqos->clk_slave);\n\tif (err < 0)\n\t\tgoto disable_master;\n\n\teqos->clk_rx = devm_clk_get(&pdev->dev, \"rx\");\n\tif (IS_ERR(eqos->clk_rx)) {\n\t\terr = PTR_ERR(eqos->clk_rx);\n\t\tgoto disable_slave;\n\t}\n\n\terr = clk_prepare_enable(eqos->clk_rx);\n\tif (err < 0)\n\t\tgoto disable_slave;\n\n\teqos->clk_tx = devm_clk_get(&pdev->dev, \"tx\");\n\tif (IS_ERR(eqos->clk_tx)) {\n\t\terr = PTR_ERR(eqos->clk_tx);\n\t\tgoto disable_rx;\n\t}\n\n\terr = clk_prepare_enable(eqos->clk_tx);\n\tif (err < 0)\n\t\tgoto disable_rx;\n\n\teqos->reset = devm_gpiod_get(&pdev->dev, \"phy-reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(eqos->reset)) {\n\t\terr = PTR_ERR(eqos->reset);\n\t\tgoto disable_tx;\n\t}\n\n\tusleep_range(2000, 4000);\n\tgpiod_set_value(eqos->reset, 0);\n\n\t \n\tdata->mdio_bus_data->needs_reset = false;\n\n\teqos->rst = devm_reset_control_get(&pdev->dev, \"eqos\");\n\tif (IS_ERR(eqos->rst)) {\n\t\terr = PTR_ERR(eqos->rst);\n\t\tgoto reset_phy;\n\t}\n\n\terr = reset_control_assert(eqos->rst);\n\tif (err < 0)\n\t\tgoto reset_phy;\n\n\tusleep_range(2000, 4000);\n\n\terr = reset_control_deassert(eqos->rst);\n\tif (err < 0)\n\t\tgoto reset_phy;\n\n\tusleep_range(2000, 4000);\n\nbypass_clk_reset_gpio:\n\tdata->fix_mac_speed = tegra_eqos_fix_speed;\n\tdata->init = tegra_eqos_init;\n\tdata->bsp_priv = eqos;\n\tdata->flags |= STMMAC_FLAG_SPH_DISABLE;\n\n\terr = tegra_eqos_init(pdev, eqos);\n\tif (err < 0)\n\t\tgoto reset;\n\n\treturn 0;\nreset:\n\treset_control_assert(eqos->rst);\nreset_phy:\n\tgpiod_set_value(eqos->reset, 1);\ndisable_tx:\n\tclk_disable_unprepare(eqos->clk_tx);\ndisable_rx:\n\tclk_disable_unprepare(eqos->clk_rx);\ndisable_slave:\n\tclk_disable_unprepare(eqos->clk_slave);\ndisable_master:\n\tclk_disable_unprepare(eqos->clk_master);\nerror:\n\treturn err;\n}\n\nstatic void tegra_eqos_remove(struct platform_device *pdev)\n{\n\tstruct tegra_eqos *eqos = get_stmmac_bsp_priv(&pdev->dev);\n\n\treset_control_assert(eqos->rst);\n\tgpiod_set_value(eqos->reset, 1);\n\tclk_disable_unprepare(eqos->clk_tx);\n\tclk_disable_unprepare(eqos->clk_rx);\n\tclk_disable_unprepare(eqos->clk_slave);\n\tclk_disable_unprepare(eqos->clk_master);\n}\n\nstruct dwc_eth_dwmac_data {\n\tint (*probe)(struct platform_device *pdev,\n\t\t     struct plat_stmmacenet_data *data,\n\t\t     struct stmmac_resources *res);\n\tvoid (*remove)(struct platform_device *pdev);\n};\n\nstatic const struct dwc_eth_dwmac_data dwc_qos_data = {\n\t.probe = dwc_qos_probe,\n\t.remove = dwc_qos_remove,\n};\n\nstatic const struct dwc_eth_dwmac_data tegra_eqos_data = {\n\t.probe = tegra_eqos_probe,\n\t.remove = tegra_eqos_remove,\n};\n\nstatic int dwc_eth_dwmac_probe(struct platform_device *pdev)\n{\n\tconst struct dwc_eth_dwmac_data *data;\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tint ret;\n\n\tdata = device_get_match_data(&pdev->dev);\n\n\tmemset(&stmmac_res, 0, sizeof(struct stmmac_resources));\n\n\t \n\tstmmac_res.irq = platform_get_irq(pdev, 0);\n\tif (stmmac_res.irq < 0)\n\t\treturn stmmac_res.irq;\n\tstmmac_res.wol_irq = stmmac_res.irq;\n\n\tstmmac_res.addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(stmmac_res.addr))\n\t\treturn PTR_ERR(stmmac_res.addr);\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tret = data->probe(pdev, plat_dat, &stmmac_res);\n\tif (ret < 0) {\n\t\tdev_err_probe(&pdev->dev, ret, \"failed to probe subdriver\\n\");\n\n\t\tgoto remove_config;\n\t}\n\n\tret = dwc_eth_dwmac_config_dt(pdev, plat_dat);\n\tif (ret)\n\t\tgoto remove;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto remove;\n\n\treturn ret;\n\nremove:\n\tdata->remove(pdev);\nremove_config:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void dwc_eth_dwmac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tconst struct dwc_eth_dwmac_data *data;\n\n\tdata = device_get_match_data(&pdev->dev);\n\n\tstmmac_dvr_remove(&pdev->dev);\n\n\tdata->remove(pdev);\n\n\tstmmac_remove_config_dt(pdev, priv->plat);\n}\n\nstatic const struct of_device_id dwc_eth_dwmac_match[] = {\n\t{ .compatible = \"snps,dwc-qos-ethernet-4.10\", .data = &dwc_qos_data },\n\t{ .compatible = \"nvidia,tegra186-eqos\", .data = &tegra_eqos_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, dwc_eth_dwmac_match);\n\nstatic struct platform_driver dwc_eth_dwmac_driver = {\n\t.probe  = dwc_eth_dwmac_probe,\n\t.remove_new = dwc_eth_dwmac_remove,\n\t.driver = {\n\t\t.name           = \"dwc-eth-dwmac\",\n\t\t.pm             = &stmmac_pltfr_pm_ops,\n\t\t.of_match_table = dwc_eth_dwmac_match,\n\t},\n};\nmodule_platform_driver(dwc_eth_dwmac_driver);\n\nMODULE_AUTHOR(\"Joao Pinto <jpinto@synopsys.com>\");\nMODULE_DESCRIPTION(\"Synopsys DWC Ethernet Quality-of-Service v4.10a driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}