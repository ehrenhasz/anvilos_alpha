{
  "module_name": "stmmac_pcs.h",
  "hash_id": "5bcfd8082b57cb8f1b8a99d054e1b1cc6f3198af17d551619a6e9b0ede8beca2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_pcs.h",
  "human_readable_source": " \n \n\n#ifndef __STMMAC_PCS_H__\n#define __STMMAC_PCS_H__\n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include \"common.h\"\n\n \n#define GMAC_AN_CTRL(x)\t\t(x)\t\t \n#define GMAC_AN_STATUS(x)\t(x + 0x4)\t \n#define GMAC_ANE_ADV(x)\t\t(x + 0x8)\t \n#define GMAC_ANE_LPA(x)\t\t(x + 0xc)\t \n#define GMAC_ANE_EXP(x)\t\t(x + 0x10)\t \n#define GMAC_TBI(x)\t\t(x + 0x14)\t \n\n \n#define GMAC_AN_CTRL_RAN\tBIT(9)\t \n#define GMAC_AN_CTRL_ANE\tBIT(12)\t \n#define GMAC_AN_CTRL_ELE\tBIT(14)\t \n#define GMAC_AN_CTRL_ECD\tBIT(16)\t \n#define GMAC_AN_CTRL_LR\t\tBIT(17)\t \n#define GMAC_AN_CTRL_SGMRAL\tBIT(18)\t \n\n \n#define GMAC_AN_STATUS_LS\tBIT(2)\t \n#define GMAC_AN_STATUS_ANA\tBIT(3)\t \n#define GMAC_AN_STATUS_ANC\tBIT(5)\t \n#define GMAC_AN_STATUS_ES\tBIT(8)\t \n\n \n#define GMAC_ANE_FD\t\tBIT(5)\n#define GMAC_ANE_HD\t\tBIT(6)\n#define GMAC_ANE_PSE\t\tGENMASK(8, 7)\n#define GMAC_ANE_PSE_SHIFT\t7\n#define GMAC_ANE_RFE\t\tGENMASK(13, 12)\n#define GMAC_ANE_RFE_SHIFT\t12\n#define GMAC_ANE_ACK\t\tBIT(14)\n\n \nstatic inline void dwmac_pcs_isr(void __iomem *ioaddr, u32 reg,\n\t\t\t\t unsigned int intr_status,\n\t\t\t\t struct stmmac_extra_stats *x)\n{\n\tu32 val = readl(ioaddr + GMAC_AN_STATUS(reg));\n\n\tif (intr_status & PCS_ANE_IRQ) {\n\t\tx->irq_pcs_ane_n++;\n\t\tif (val & GMAC_AN_STATUS_ANC)\n\t\t\tpr_info(\"stmmac_pcs: ANE process completed\\n\");\n\t}\n\n\tif (intr_status & PCS_LINK_IRQ) {\n\t\tx->irq_pcs_link_n++;\n\t\tif (val & GMAC_AN_STATUS_LS)\n\t\t\tpr_info(\"stmmac_pcs: Link Up\\n\");\n\t\telse\n\t\t\tpr_info(\"stmmac_pcs: Link Down\\n\");\n\t}\n}\n\n \nstatic inline void dwmac_rane(void __iomem *ioaddr, u32 reg, bool restart)\n{\n\tu32 value = readl(ioaddr + GMAC_AN_CTRL(reg));\n\n\tif (restart)\n\t\tvalue |= GMAC_AN_CTRL_RAN;\n\n\twritel(value, ioaddr + GMAC_AN_CTRL(reg));\n}\n\n \nstatic inline void dwmac_ctrl_ane(void __iomem *ioaddr, u32 reg, bool ane,\n\t\t\t\t  bool srgmi_ral, bool loopback)\n{\n\tu32 value = readl(ioaddr + GMAC_AN_CTRL(reg));\n\n\t \n\tif (ane)\n\t\tvalue |= GMAC_AN_CTRL_ANE | GMAC_AN_CTRL_RAN;\n\n\t \n\tif (srgmi_ral)\n\t\tvalue |= GMAC_AN_CTRL_SGMRAL;\n\n\tif (loopback)\n\t\tvalue |= GMAC_AN_CTRL_ELE;\n\n\twritel(value, ioaddr + GMAC_AN_CTRL(reg));\n}\n\n \nstatic inline void dwmac_get_adv_lp(void __iomem *ioaddr, u32 reg,\n\t\t\t\t    struct rgmii_adv *adv_lp)\n{\n\tu32 value = readl(ioaddr + GMAC_ANE_ADV(reg));\n\n\tif (value & GMAC_ANE_FD)\n\t\tadv_lp->duplex = DUPLEX_FULL;\n\tif (value & GMAC_ANE_HD)\n\t\tadv_lp->duplex |= DUPLEX_HALF;\n\n\tadv_lp->pause = (value & GMAC_ANE_PSE) >> GMAC_ANE_PSE_SHIFT;\n\n\tvalue = readl(ioaddr + GMAC_ANE_LPA(reg));\n\n\tif (value & GMAC_ANE_FD)\n\t\tadv_lp->lp_duplex = DUPLEX_FULL;\n\tif (value & GMAC_ANE_HD)\n\t\tadv_lp->lp_duplex = DUPLEX_HALF;\n\n\tadv_lp->lp_pause = (value & GMAC_ANE_PSE) >> GMAC_ANE_PSE_SHIFT;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}