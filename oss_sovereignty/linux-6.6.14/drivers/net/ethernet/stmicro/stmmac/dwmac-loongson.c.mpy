{
  "module_name": "dwmac-loongson.c",
  "hash_id": "412cd179486594fdaa16dee51103419a3307f89effa985b5d1fb7c3f87507c3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-loongson.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/pci.h>\n#include <linux/dmi.h>\n#include <linux/device.h>\n#include <linux/of_irq.h>\n#include \"stmmac.h\"\n\nstatic int loongson_default_data(struct plat_stmmacenet_data *plat)\n{\n\tplat->clk_csr = 2;\t \n\tplat->has_gmac = 1;\n\tplat->force_sf_dma_mode = 1;\n\n\t \n\tplat->multicast_filter_bins = HASH_TABLE_SIZE;\n\n\t \n\tplat->unicast_filter_entries = 1;\n\n\t \n\tplat->maxmtu = JUMBO_LEN;\n\n\t \n\tplat->tx_queues_to_use = 1;\n\tplat->rx_queues_to_use = 1;\n\n\t \n\tplat->tx_queues_cfg[0].use_prio = false;\n\tplat->rx_queues_cfg[0].use_prio = false;\n\n\t \n\tplat->rx_queues_cfg[0].pkt_route = 0x0;\n\n\t \n\tplat->phy_addr = -1;\n\n\tplat->dma_cfg->pbl = 32;\n\tplat->dma_cfg->pblx8 = true;\n\n\tplat->multicast_filter_bins = 256;\n\treturn 0;\n}\n\nstatic int loongson_dwmac_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct plat_stmmacenet_data *plat;\n\tstruct stmmac_resources res;\n\tstruct device_node *np;\n\tint ret, i, phy_mode;\n\n\tnp = dev_of_node(&pdev->dev);\n\n\tif (!np) {\n\t\tpr_info(\"dwmac_loongson_pci: No OF node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\n\tif (!plat)\n\t\treturn -ENOMEM;\n\n\tplat->mdio_bus_data = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t   sizeof(*plat->mdio_bus_data),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!plat->mdio_bus_data)\n\t\treturn -ENOMEM;\n\n\tplat->mdio_node = of_get_child_by_name(np, \"mdio\");\n\tif (plat->mdio_node) {\n\t\tdev_info(&pdev->dev, \"Found MDIO subnode\\n\");\n\t\tplat->mdio_bus_data->needs_reset = true;\n\t}\n\n\tplat->dma_cfg = devm_kzalloc(&pdev->dev, sizeof(*plat->dma_cfg), GFP_KERNEL);\n\tif (!plat->dma_cfg) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_node;\n\t}\n\n\t \n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: ERROR: failed to enable device\\n\", __func__);\n\t\tgoto err_put_node;\n\t}\n\n\t \n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (pci_resource_len(pdev, i) == 0)\n\t\t\tcontinue;\n\t\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\t\tif (ret)\n\t\t\tgoto err_disable_device;\n\t\tbreak;\n\t}\n\n\tplat->bus_id = of_alias_get_id(np, \"ethernet\");\n\tif (plat->bus_id < 0)\n\t\tplat->bus_id = pci_dev_id(pdev);\n\n\tphy_mode = device_get_phy_mode(&pdev->dev);\n\tif (phy_mode < 0) {\n\t\tdev_err(&pdev->dev, \"phy_mode not found\\n\");\n\t\tret = phy_mode;\n\t\tgoto err_disable_device;\n\t}\n\n\tplat->phy_interface = phy_mode;\n\tplat->mac_interface = PHY_INTERFACE_MODE_GMII;\n\n\tpci_set_master(pdev);\n\n\tloongson_default_data(plat);\n\tpci_enable_msi(pdev);\n\tmemset(&res, 0, sizeof(res));\n\tres.addr = pcim_iomap_table(pdev)[0];\n\n\tres.irq = of_irq_get_byname(np, \"macirq\");\n\tif (res.irq < 0) {\n\t\tdev_err(&pdev->dev, \"IRQ macirq not found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_disable_msi;\n\t}\n\n\tres.wol_irq = of_irq_get_byname(np, \"eth_wake_irq\");\n\tif (res.wol_irq < 0) {\n\t\tdev_info(&pdev->dev, \"IRQ eth_wake_irq not found, using macirq\\n\");\n\t\tres.wol_irq = res.irq;\n\t}\n\n\tres.lpi_irq = of_irq_get_byname(np, \"eth_lpi\");\n\tif (res.lpi_irq < 0) {\n\t\tdev_err(&pdev->dev, \"IRQ eth_lpi not found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_disable_msi;\n\t}\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat, &res);\n\tif (ret)\n\t\tgoto err_disable_msi;\n\n\treturn ret;\n\nerr_disable_msi:\n\tpci_disable_msi(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\nerr_put_node:\n\tof_node_put(plat->mdio_node);\n\treturn ret;\n}\n\nstatic void loongson_dwmac_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(&pdev->dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint i;\n\n\tof_node_put(priv->plat->mdio_node);\n\tstmmac_dvr_remove(&pdev->dev);\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (pci_resource_len(pdev, i) == 0)\n\t\t\tcontinue;\n\t\tpcim_iounmap_regions(pdev, BIT(i));\n\t\tbreak;\n\t}\n\n\tpci_disable_msi(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused loongson_dwmac_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tret = stmmac_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_save_state(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_disable_device(pdev);\n\tpci_wake_from_d3(pdev, true);\n\treturn 0;\n}\n\nstatic int __maybe_unused loongson_dwmac_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tpci_restore_state(pdev);\n\tpci_set_power_state(pdev, PCI_D0);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\treturn stmmac_resume(dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(loongson_dwmac_pm_ops, loongson_dwmac_suspend,\n\t\t\t loongson_dwmac_resume);\n\nstatic const struct pci_device_id loongson_dwmac_id_table[] = {\n\t{ PCI_VDEVICE(LOONGSON, 0x7a03) },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, loongson_dwmac_id_table);\n\nstatic struct pci_driver loongson_dwmac_driver = {\n\t.name = \"dwmac-loongson-pci\",\n\t.id_table = loongson_dwmac_id_table,\n\t.probe = loongson_dwmac_probe,\n\t.remove = loongson_dwmac_remove,\n\t.driver = {\n\t\t.pm = &loongson_dwmac_pm_ops,\n\t},\n};\n\nmodule_pci_driver(loongson_dwmac_driver);\n\nMODULE_DESCRIPTION(\"Loongson DWMAC PCI driver\");\nMODULE_AUTHOR(\"Qing Zhang <zhangqing@loongson.cn>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}