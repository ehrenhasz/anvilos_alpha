{
  "module_name": "norm_desc.c",
  "hash_id": "2790842d2bf6c9227005bfc923ed2a8de0d5ec799ffbfeed60c6860ccf0472f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/norm_desc.c",
  "human_readable_source": "\n \n\n#include <linux/stmmac.h>\n#include \"common.h\"\n#include \"descs_com.h\"\n\nstatic int ndesc_get_tx_status(struct stmmac_extra_stats *x,\n\t\t\t       struct dma_desc *p, void __iomem *ioaddr)\n{\n\tunsigned int tdes0 = le32_to_cpu(p->des0);\n\tunsigned int tdes1 = le32_to_cpu(p->des1);\n\tint ret = tx_done;\n\n\t \n\tif (unlikely(tdes0 & TDES0_OWN))\n\t\treturn tx_dma_own;\n\n\t \n\tif (likely(!(tdes1 & TDES1_LAST_SEGMENT)))\n\t\treturn tx_not_ls;\n\n\tif (unlikely(tdes0 & TDES0_ERROR_SUMMARY)) {\n\t\tif (unlikely(tdes0 & TDES0_UNDERFLOW_ERROR)) {\n\t\t\tx->tx_underflow++;\n\t\t}\n\t\tif (unlikely(tdes0 & TDES0_NO_CARRIER)) {\n\t\t\tx->tx_carrier++;\n\t\t}\n\t\tif (unlikely(tdes0 & TDES0_LOSS_CARRIER)) {\n\t\t\tx->tx_losscarrier++;\n\t\t}\n\t\tif (unlikely((tdes0 & TDES0_EXCESSIVE_DEFERRAL) ||\n\t\t\t     (tdes0 & TDES0_EXCESSIVE_COLLISIONS) ||\n\t\t\t     (tdes0 & TDES0_LATE_COLLISION))) {\n\t\t\tunsigned int collisions;\n\n\t\t\tcollisions = (tdes0 & TDES0_COLLISION_COUNT_MASK) >> 3;\n\t\t\tx->tx_collision += collisions;\n\t\t}\n\t\tret = tx_err;\n\t}\n\n\tif (tdes0 & TDES0_VLAN_FRAME)\n\t\tx->tx_vlan++;\n\n\tif (unlikely(tdes0 & TDES0_DEFERRED))\n\t\tx->tx_deferred++;\n\n\treturn ret;\n}\n\nstatic int ndesc_get_tx_len(struct dma_desc *p)\n{\n\treturn (le32_to_cpu(p->des1) & RDES1_BUFFER1_SIZE_MASK);\n}\n\n \nstatic int ndesc_get_rx_status(struct stmmac_extra_stats *x,\n\t\t\t       struct dma_desc *p)\n{\n\tint ret = good_frame;\n\tunsigned int rdes0 = le32_to_cpu(p->des0);\n\n\tif (unlikely(rdes0 & RDES0_OWN))\n\t\treturn dma_own;\n\n\tif (unlikely(!(rdes0 & RDES0_LAST_DESCRIPTOR))) {\n\t\tx->rx_length++;\n\t\treturn discard_frame;\n\t}\n\n\tif (unlikely(rdes0 & RDES0_ERROR_SUMMARY)) {\n\t\tif (unlikely(rdes0 & RDES0_DESCRIPTOR_ERROR))\n\t\t\tx->rx_desc++;\n\t\tif (unlikely(rdes0 & RDES0_SA_FILTER_FAIL))\n\t\t\tx->sa_filter_fail++;\n\t\tif (unlikely(rdes0 & RDES0_OVERFLOW_ERROR))\n\t\t\tx->overflow_error++;\n\t\tif (unlikely(rdes0 & RDES0_IPC_CSUM_ERROR))\n\t\t\tx->ipc_csum_error++;\n\t\tif (unlikely(rdes0 & RDES0_COLLISION)) {\n\t\t\tx->rx_collision++;\n\t\t}\n\t\tif (unlikely(rdes0 & RDES0_CRC_ERROR)) {\n\t\t\tx->rx_crc_errors++;\n\t\t}\n\t\tret = discard_frame;\n\t}\n\tif (unlikely(rdes0 & RDES0_DRIBBLING))\n\t\tx->dribbling_bit++;\n\n\tif (unlikely(rdes0 & RDES0_LENGTH_ERROR)) {\n\t\tx->rx_length++;\n\t\tret = discard_frame;\n\t}\n\tif (unlikely(rdes0 & RDES0_MII_ERROR)) {\n\t\tx->rx_mii++;\n\t\tret = discard_frame;\n\t}\n#ifdef STMMAC_VLAN_TAG_USED\n\tif (rdes0 & RDES0_VLAN_TAG)\n\t\tx->vlan_tag++;\n#endif\n\treturn ret;\n}\n\nstatic void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,\n\t\t\t       int end, int bfsize)\n{\n\tint bfsize1;\n\n\tp->des0 |= cpu_to_le32(RDES0_OWN);\n\n\tbfsize1 = min(bfsize, BUF_SIZE_2KiB - 1);\n\tp->des1 |= cpu_to_le32(bfsize1 & RDES1_BUFFER1_SIZE_MASK);\n\n\tif (mode == STMMAC_CHAIN_MODE)\n\t\tndesc_rx_set_on_chain(p, end);\n\telse\n\t\tndesc_rx_set_on_ring(p, end, bfsize);\n\n\tif (disable_rx_ic)\n\t\tp->des1 |= cpu_to_le32(RDES1_DISABLE_IC);\n}\n\nstatic void ndesc_init_tx_desc(struct dma_desc *p, int mode, int end)\n{\n\tp->des0 &= cpu_to_le32(~TDES0_OWN);\n\tif (mode == STMMAC_CHAIN_MODE)\n\t\tndesc_tx_set_on_chain(p);\n\telse\n\t\tndesc_end_tx_desc_on_ring(p, end);\n}\n\nstatic int ndesc_get_tx_owner(struct dma_desc *p)\n{\n\treturn (le32_to_cpu(p->des0) & TDES0_OWN) >> 31;\n}\n\nstatic void ndesc_set_tx_owner(struct dma_desc *p)\n{\n\tp->des0 |= cpu_to_le32(TDES0_OWN);\n}\n\nstatic void ndesc_set_rx_owner(struct dma_desc *p, int disable_rx_ic)\n{\n\tp->des0 |= cpu_to_le32(RDES0_OWN);\n}\n\nstatic int ndesc_get_tx_ls(struct dma_desc *p)\n{\n\treturn (le32_to_cpu(p->des1) & TDES1_LAST_SEGMENT) >> 30;\n}\n\nstatic void ndesc_release_tx_desc(struct dma_desc *p, int mode)\n{\n\tint ter = (le32_to_cpu(p->des1) & TDES1_END_RING) >> 25;\n\n\tmemset(p, 0, offsetof(struct dma_desc, des2));\n\tif (mode == STMMAC_CHAIN_MODE)\n\t\tndesc_tx_set_on_chain(p);\n\telse\n\t\tndesc_end_tx_desc_on_ring(p, ter);\n}\n\nstatic void ndesc_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,\n\t\t\t\t  bool csum_flag, int mode, bool tx_own,\n\t\t\t\t  bool ls, unsigned int tot_pkt_len)\n{\n\tunsigned int tdes1 = le32_to_cpu(p->des1);\n\n\tif (is_fs)\n\t\ttdes1 |= TDES1_FIRST_SEGMENT;\n\telse\n\t\ttdes1 &= ~TDES1_FIRST_SEGMENT;\n\n\tif (likely(csum_flag))\n\t\ttdes1 |= (TX_CIC_FULL) << TDES1_CHECKSUM_INSERTION_SHIFT;\n\telse\n\t\ttdes1 &= ~(TX_CIC_FULL << TDES1_CHECKSUM_INSERTION_SHIFT);\n\n\tif (ls)\n\t\ttdes1 |= TDES1_LAST_SEGMENT;\n\n\tp->des1 = cpu_to_le32(tdes1);\n\n\tif (mode == STMMAC_CHAIN_MODE)\n\t\tnorm_set_tx_desc_len_on_chain(p, len);\n\telse\n\t\tnorm_set_tx_desc_len_on_ring(p, len);\n\n\tif (tx_own)\n\t\tp->des0 |= cpu_to_le32(TDES0_OWN);\n}\n\nstatic void ndesc_set_tx_ic(struct dma_desc *p)\n{\n\tp->des1 |= cpu_to_le32(TDES1_INTERRUPT);\n}\n\nstatic int ndesc_get_rx_frame_len(struct dma_desc *p, int rx_coe_type)\n{\n\tunsigned int csum = 0;\n\n\t \n\tif (rx_coe_type == STMMAC_RX_COE_TYPE1)\n\t\tcsum = 2;\n\n\treturn (((le32_to_cpu(p->des0) & RDES0_FRAME_LEN_MASK)\n\t\t\t\t>> RDES0_FRAME_LEN_SHIFT) -\n\t\tcsum);\n\n}\n\nstatic void ndesc_enable_tx_timestamp(struct dma_desc *p)\n{\n\tp->des1 |= cpu_to_le32(TDES1_TIME_STAMP_ENABLE);\n}\n\nstatic int ndesc_get_tx_timestamp_status(struct dma_desc *p)\n{\n\treturn (le32_to_cpu(p->des0) & TDES0_TIME_STAMP_STATUS) >> 17;\n}\n\nstatic void ndesc_get_timestamp(void *desc, u32 ats, u64 *ts)\n{\n\tstruct dma_desc *p = (struct dma_desc *)desc;\n\tu64 ns;\n\n\tns = le32_to_cpu(p->des2);\n\t \n\tns += le32_to_cpu(p->des3) * 1000000000ULL;\n\n\t*ts = ns;\n}\n\nstatic int ndesc_get_rx_timestamp_status(void *desc, void *next_desc, u32 ats)\n{\n\tstruct dma_desc *p = (struct dma_desc *)desc;\n\n\tif ((le32_to_cpu(p->des2) == 0xffffffff) &&\n\t    (le32_to_cpu(p->des3) == 0xffffffff))\n\t\t \n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic void ndesc_display_ring(void *head, unsigned int size, bool rx,\n\t\t\t       dma_addr_t dma_rx_phy, unsigned int desc_size)\n{\n\tstruct dma_desc *p = (struct dma_desc *)head;\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tpr_info(\"%s descriptor ring:\\n\", rx ? \"RX\" : \"TX\");\n\n\tfor (i = 0; i < size; i++) {\n\t\tu64 x;\n\t\tdma_addr = dma_rx_phy + i * sizeof(*p);\n\n\t\tx = *(u64 *)p;\n\t\tpr_info(\"%03d [%pad]: 0x%x 0x%x 0x%x 0x%x\",\n\t\t\ti, &dma_addr,\n\t\t\t(unsigned int)x, (unsigned int)(x >> 32),\n\t\t\tp->des2, p->des3);\n\t\tp++;\n\t}\n\tpr_info(\"\\n\");\n}\n\nstatic void ndesc_set_addr(struct dma_desc *p, dma_addr_t addr)\n{\n\tp->des2 = cpu_to_le32(addr);\n}\n\nstatic void ndesc_clear(struct dma_desc *p)\n{\n\tp->des2 = 0;\n}\n\nconst struct stmmac_desc_ops ndesc_ops = {\n\t.tx_status = ndesc_get_tx_status,\n\t.rx_status = ndesc_get_rx_status,\n\t.get_tx_len = ndesc_get_tx_len,\n\t.init_rx_desc = ndesc_init_rx_desc,\n\t.init_tx_desc = ndesc_init_tx_desc,\n\t.get_tx_owner = ndesc_get_tx_owner,\n\t.release_tx_desc = ndesc_release_tx_desc,\n\t.prepare_tx_desc = ndesc_prepare_tx_desc,\n\t.set_tx_ic = ndesc_set_tx_ic,\n\t.get_tx_ls = ndesc_get_tx_ls,\n\t.set_tx_owner = ndesc_set_tx_owner,\n\t.set_rx_owner = ndesc_set_rx_owner,\n\t.get_rx_frame_len = ndesc_get_rx_frame_len,\n\t.enable_tx_timestamp = ndesc_enable_tx_timestamp,\n\t.get_tx_timestamp_status = ndesc_get_tx_timestamp_status,\n\t.get_timestamp = ndesc_get_timestamp,\n\t.get_rx_timestamp_status = ndesc_get_rx_timestamp_status,\n\t.display_ring = ndesc_display_ring,\n\t.set_addr = ndesc_set_addr,\n\t.clear = ndesc_clear,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}