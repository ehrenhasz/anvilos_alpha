{
  "module_name": "hwif.c",
  "hash_id": "f2aba22de4da41f88b551ec41497ca10be5ebf25ea2ccf00a32644d47467f5cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/hwif.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include \"stmmac.h\"\n#include \"stmmac_ptp.h\"\n\nstatic u32 stmmac_get_id(struct stmmac_priv *priv, u32 id_reg)\n{\n\tu32 reg = readl(priv->ioaddr + id_reg);\n\n\tif (!reg) {\n\t\tdev_info(priv->device, \"Version ID not available\\n\");\n\t\treturn 0x0;\n\t}\n\n\tdev_info(priv->device, \"User ID: 0x%x, Synopsys ID: 0x%x\\n\",\n\t\t\t(unsigned int)(reg & GENMASK(15, 8)) >> 8,\n\t\t\t(unsigned int)(reg & GENMASK(7, 0)));\n\treturn reg & GENMASK(7, 0);\n}\n\nstatic u32 stmmac_get_dev_id(struct stmmac_priv *priv, u32 id_reg)\n{\n\tu32 reg = readl(priv->ioaddr + id_reg);\n\n\tif (!reg) {\n\t\tdev_info(priv->device, \"Version ID not available\\n\");\n\t\treturn 0x0;\n\t}\n\n\treturn (reg & GENMASK(15, 8)) >> 8;\n}\n\nstatic void stmmac_dwmac_mode_quirk(struct stmmac_priv *priv)\n{\n\tstruct mac_device_info *mac = priv->hw;\n\n\tif (priv->chain_mode) {\n\t\tdev_info(priv->device, \"Chain mode enabled\\n\");\n\t\tpriv->mode = STMMAC_CHAIN_MODE;\n\t\tmac->mode = &chain_mode_ops;\n\t} else {\n\t\tdev_info(priv->device, \"Ring mode enabled\\n\");\n\t\tpriv->mode = STMMAC_RING_MODE;\n\t\tmac->mode = &ring_mode_ops;\n\t}\n}\n\nstatic int stmmac_dwmac1_quirks(struct stmmac_priv *priv)\n{\n\tstruct mac_device_info *mac = priv->hw;\n\n\tif (priv->plat->enh_desc) {\n\t\tdev_info(priv->device, \"Enhanced/Alternate descriptors\\n\");\n\n\t\t \n\t\tif (priv->synopsys_id >= DWMAC_CORE_3_50) {\n\t\t\tdev_info(priv->device, \"Enabled extended descriptors\\n\");\n\t\t\tpriv->extend_desc = 1;\n\t\t} else {\n\t\t\tdev_warn(priv->device, \"Extended descriptors not supported\\n\");\n\t\t}\n\n\t\tmac->desc = &enh_desc_ops;\n\t} else {\n\t\tdev_info(priv->device, \"Normal descriptors\\n\");\n\t\tmac->desc = &ndesc_ops;\n\t}\n\n\tstmmac_dwmac_mode_quirk(priv);\n\treturn 0;\n}\n\nstatic int stmmac_dwmac4_quirks(struct stmmac_priv *priv)\n{\n\tstmmac_dwmac_mode_quirk(priv);\n\treturn 0;\n}\n\nstatic int stmmac_dwxlgmac_quirks(struct stmmac_priv *priv)\n{\n\tpriv->hw->xlgmac = true;\n\treturn 0;\n}\n\nint stmmac_reset(struct stmmac_priv *priv, void __iomem *ioaddr)\n{\n\tstruct plat_stmmacenet_data *plat = priv ? priv->plat : NULL;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tif (plat && plat->fix_soc_reset)\n\t\treturn plat->fix_soc_reset(plat, ioaddr);\n\n\treturn stmmac_do_callback(priv, dma, reset, ioaddr);\n}\n\nstatic const struct stmmac_hwif_entry {\n\tbool gmac;\n\tbool gmac4;\n\tbool xgmac;\n\tu32 min_id;\n\tu32 dev_id;\n\tconst struct stmmac_regs_off regs;\n\tconst void *desc;\n\tconst void *dma;\n\tconst void *mac;\n\tconst void *hwtimestamp;\n\tconst void *mode;\n\tconst void *tc;\n\tconst void *mmc;\n\tint (*setup)(struct stmmac_priv *priv);\n\tint (*quirks)(struct stmmac_priv *priv);\n} stmmac_hw[] = {\n\t \n\t{\n\t\t.gmac = false,\n\t\t.gmac4 = false,\n\t\t.xgmac = false,\n\t\t.min_id = 0,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_GMAC3_X_OFFSET,\n\t\t\t.mmc_off = MMC_GMAC3_X_OFFSET,\n\t\t},\n\t\t.desc = NULL,\n\t\t.dma = &dwmac100_dma_ops,\n\t\t.mac = &dwmac100_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = NULL,\n\t\t.tc = NULL,\n\t\t.mmc = &dwmac_mmc_ops,\n\t\t.setup = dwmac100_setup,\n\t\t.quirks = stmmac_dwmac1_quirks,\n\t}, {\n\t\t.gmac = true,\n\t\t.gmac4 = false,\n\t\t.xgmac = false,\n\t\t.min_id = 0,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_GMAC3_X_OFFSET,\n\t\t\t.mmc_off = MMC_GMAC3_X_OFFSET,\n\t\t},\n\t\t.desc = NULL,\n\t\t.dma = &dwmac1000_dma_ops,\n\t\t.mac = &dwmac1000_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = NULL,\n\t\t.tc = NULL,\n\t\t.mmc = &dwmac_mmc_ops,\n\t\t.setup = dwmac1000_setup,\n\t\t.quirks = stmmac_dwmac1_quirks,\n\t}, {\n\t\t.gmac = false,\n\t\t.gmac4 = true,\n\t\t.xgmac = false,\n\t\t.min_id = 0,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_GMAC4_OFFSET,\n\t\t\t.mmc_off = MMC_GMAC4_OFFSET,\n\t\t},\n\t\t.desc = &dwmac4_desc_ops,\n\t\t.dma = &dwmac4_dma_ops,\n\t\t.mac = &dwmac4_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = NULL,\n\t\t.tc = &dwmac510_tc_ops,\n\t\t.mmc = &dwmac_mmc_ops,\n\t\t.setup = dwmac4_setup,\n\t\t.quirks = stmmac_dwmac4_quirks,\n\t}, {\n\t\t.gmac = false,\n\t\t.gmac4 = true,\n\t\t.xgmac = false,\n\t\t.min_id = DWMAC_CORE_4_00,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_GMAC4_OFFSET,\n\t\t\t.mmc_off = MMC_GMAC4_OFFSET,\n\t\t},\n\t\t.desc = &dwmac4_desc_ops,\n\t\t.dma = &dwmac4_dma_ops,\n\t\t.mac = &dwmac410_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = &dwmac4_ring_mode_ops,\n\t\t.tc = &dwmac510_tc_ops,\n\t\t.mmc = &dwmac_mmc_ops,\n\t\t.setup = dwmac4_setup,\n\t\t.quirks = NULL,\n\t}, {\n\t\t.gmac = false,\n\t\t.gmac4 = true,\n\t\t.xgmac = false,\n\t\t.min_id = DWMAC_CORE_4_10,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_GMAC4_OFFSET,\n\t\t\t.mmc_off = MMC_GMAC4_OFFSET,\n\t\t},\n\t\t.desc = &dwmac4_desc_ops,\n\t\t.dma = &dwmac410_dma_ops,\n\t\t.mac = &dwmac410_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = &dwmac4_ring_mode_ops,\n\t\t.tc = &dwmac510_tc_ops,\n\t\t.mmc = &dwmac_mmc_ops,\n\t\t.setup = dwmac4_setup,\n\t\t.quirks = NULL,\n\t}, {\n\t\t.gmac = false,\n\t\t.gmac4 = true,\n\t\t.xgmac = false,\n\t\t.min_id = DWMAC_CORE_5_10,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_GMAC4_OFFSET,\n\t\t\t.mmc_off = MMC_GMAC4_OFFSET,\n\t\t},\n\t\t.desc = &dwmac4_desc_ops,\n\t\t.dma = &dwmac410_dma_ops,\n\t\t.mac = &dwmac510_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = &dwmac4_ring_mode_ops,\n\t\t.tc = &dwmac510_tc_ops,\n\t\t.mmc = &dwmac_mmc_ops,\n\t\t.setup = dwmac4_setup,\n\t\t.quirks = NULL,\n\t}, {\n\t\t.gmac = false,\n\t\t.gmac4 = false,\n\t\t.xgmac = true,\n\t\t.min_id = DWXGMAC_CORE_2_10,\n\t\t.dev_id = DWXGMAC_ID,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_XGMAC_OFFSET,\n\t\t\t.mmc_off = MMC_XGMAC_OFFSET,\n\t\t},\n\t\t.desc = &dwxgmac210_desc_ops,\n\t\t.dma = &dwxgmac210_dma_ops,\n\t\t.mac = &dwxgmac210_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = NULL,\n\t\t.tc = &dwmac510_tc_ops,\n\t\t.mmc = &dwxgmac_mmc_ops,\n\t\t.setup = dwxgmac2_setup,\n\t\t.quirks = NULL,\n\t}, {\n\t\t.gmac = false,\n\t\t.gmac4 = false,\n\t\t.xgmac = true,\n\t\t.min_id = DWXLGMAC_CORE_2_00,\n\t\t.dev_id = DWXLGMAC_ID,\n\t\t.regs = {\n\t\t\t.ptp_off = PTP_XGMAC_OFFSET,\n\t\t\t.mmc_off = MMC_XGMAC_OFFSET,\n\t\t},\n\t\t.desc = &dwxgmac210_desc_ops,\n\t\t.dma = &dwxgmac210_dma_ops,\n\t\t.mac = &dwxlgmac2_ops,\n\t\t.hwtimestamp = &stmmac_ptp,\n\t\t.mode = NULL,\n\t\t.tc = &dwmac510_tc_ops,\n\t\t.mmc = &dwxgmac_mmc_ops,\n\t\t.setup = dwxlgmac2_setup,\n\t\t.quirks = stmmac_dwxlgmac_quirks,\n\t},\n};\n\nint stmmac_hwif_init(struct stmmac_priv *priv)\n{\n\tbool needs_xgmac = priv->plat->has_xgmac;\n\tbool needs_gmac4 = priv->plat->has_gmac4;\n\tbool needs_gmac = priv->plat->has_gmac;\n\tconst struct stmmac_hwif_entry *entry;\n\tstruct mac_device_info *mac;\n\tbool needs_setup = true;\n\tu32 id, dev_id = 0;\n\tint i, ret;\n\n\tif (needs_gmac) {\n\t\tid = stmmac_get_id(priv, GMAC_VERSION);\n\t} else if (needs_gmac4 || needs_xgmac) {\n\t\tid = stmmac_get_id(priv, GMAC4_VERSION);\n\t\tif (needs_xgmac)\n\t\t\tdev_id = stmmac_get_dev_id(priv, GMAC4_VERSION);\n\t} else {\n\t\tid = 0;\n\t}\n\n\t \n\tpriv->synopsys_id = id;\n\n\t \n\tpriv->ptpaddr = priv->ioaddr +\n\t\t(needs_gmac4 ? PTP_GMAC4_OFFSET : PTP_GMAC3_X_OFFSET);\n\tpriv->mmcaddr = priv->ioaddr +\n\t\t(needs_gmac4 ? MMC_GMAC4_OFFSET : MMC_GMAC3_X_OFFSET);\n\n\t \n\tif (priv->plat->setup) {\n\t\tmac = priv->plat->setup(priv);\n\t\tneeds_setup = false;\n\t} else {\n\t\tmac = devm_kzalloc(priv->device, sizeof(*mac), GFP_KERNEL);\n\t}\n\n\tif (!mac)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = ARRAY_SIZE(stmmac_hw) - 1; i >= 0; i--) {\n\t\tentry = &stmmac_hw[i];\n\n\t\tif (needs_gmac ^ entry->gmac)\n\t\t\tcontinue;\n\t\tif (needs_gmac4 ^ entry->gmac4)\n\t\t\tcontinue;\n\t\tif (needs_xgmac ^ entry->xgmac)\n\t\t\tcontinue;\n\t\t \n\t\tif (priv->synopsys_id < entry->min_id)\n\t\t\tcontinue;\n\t\tif (needs_xgmac && (dev_id ^ entry->dev_id))\n\t\t\tcontinue;\n\n\t\t \n\t\tmac->desc = mac->desc ? : entry->desc;\n\t\tmac->dma = mac->dma ? : entry->dma;\n\t\tmac->mac = mac->mac ? : entry->mac;\n\t\tmac->ptp = mac->ptp ? : entry->hwtimestamp;\n\t\tmac->mode = mac->mode ? : entry->mode;\n\t\tmac->tc = mac->tc ? : entry->tc;\n\t\tmac->mmc = mac->mmc ? : entry->mmc;\n\n\t\tpriv->hw = mac;\n\t\tpriv->ptpaddr = priv->ioaddr + entry->regs.ptp_off;\n\t\tpriv->mmcaddr = priv->ioaddr + entry->regs.mmc_off;\n\n\t\t \n\t\tif (needs_setup) {\n\t\t\tret = entry->setup(priv);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpriv->hwif_quirks = entry->quirks;\n\t\treturn 0;\n\t}\n\n\tdev_err(priv->device, \"Failed to find HW IF (id=0x%x, gmac=%d/%d)\\n\",\n\t\t\tid, needs_gmac, needs_gmac4);\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}