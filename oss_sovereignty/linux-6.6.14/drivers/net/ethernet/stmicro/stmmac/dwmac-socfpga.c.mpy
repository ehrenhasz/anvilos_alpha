{
  "module_name": "dwmac-socfpga.c",
  "hash_id": "74cec0b008ad370ede897955237b4bf98da6827667f455c3baa7927e3a60e418",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/altera-sysmgr.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/regmap.h>\n#include <linux/mdio/mdio-regmap.h>\n#include <linux/pcs-lynx.h>\n#include <linux/reset.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac.h\"\n#include \"stmmac_platform.h\"\n\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII 0x0\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RGMII 0x1\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RMII 0x2\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_WIDTH 2\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_MASK 0x00000003\n#define SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK 0x00000010\n#define SYSMGR_GEN10_EMACGRP_CTRL_PTP_REF_CLK_MASK 0x00000100\n\n#define SYSMGR_FPGAGRP_MODULE_REG  0x00000028\n#define SYSMGR_FPGAGRP_MODULE_EMAC 0x00000004\n#define SYSMGR_FPGAINTF_EMAC_REG\t0x00000070\n#define SYSMGR_FPGAINTF_EMAC_BIT\t0x1\n\n#define EMAC_SPLITTER_CTRL_REG\t\t\t0x0\n#define EMAC_SPLITTER_CTRL_SPEED_MASK\t\t0x3\n#define EMAC_SPLITTER_CTRL_SPEED_10\t\t0x2\n#define EMAC_SPLITTER_CTRL_SPEED_100\t\t0x3\n#define EMAC_SPLITTER_CTRL_SPEED_1000\t\t0x0\n\n#define SGMII_ADAPTER_CTRL_REG\t\t0x00\n#define SGMII_ADAPTER_ENABLE\t\t0x0000\n#define SGMII_ADAPTER_DISABLE\t\t0x0001\n\nstruct socfpga_dwmac;\nstruct socfpga_dwmac_ops {\n\tint (*set_phy_mode)(struct socfpga_dwmac *dwmac_priv);\n};\n\nstruct socfpga_dwmac {\n\tu32\treg_offset;\n\tu32\treg_shift;\n\tstruct\tdevice *dev;\n\tstruct regmap *sys_mgr_base_addr;\n\tstruct reset_control *stmmac_rst;\n\tstruct reset_control *stmmac_ocp_rst;\n\tvoid __iomem *splitter_base;\n\tvoid __iomem *tse_pcs_base;\n\tvoid __iomem *sgmii_adapter_base;\n\tbool f2h_ptp_ref_clk;\n\tconst struct socfpga_dwmac_ops *ops;\n\tstruct mdio_device *pcs_mdiodev;\n};\n\nstatic void socfpga_dwmac_fix_mac_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct socfpga_dwmac *dwmac = (struct socfpga_dwmac *)priv;\n\tvoid __iomem *splitter_base = dwmac->splitter_base;\n\tvoid __iomem *sgmii_adapter_base = dwmac->sgmii_adapter_base;\n\tstruct device *dev = dwmac->dev;\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct phy_device *phy_dev = ndev->phydev;\n\tu32 val;\n\n\tif (sgmii_adapter_base)\n\t\twritew(SGMII_ADAPTER_DISABLE,\n\t\t       sgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\n\n\tif (splitter_base) {\n\t\tval = readl(splitter_base + EMAC_SPLITTER_CTRL_REG);\n\t\tval &= ~EMAC_SPLITTER_CTRL_SPEED_MASK;\n\n\t\tswitch (speed) {\n\t\tcase 1000:\n\t\t\tval |= EMAC_SPLITTER_CTRL_SPEED_1000;\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\tval |= EMAC_SPLITTER_CTRL_SPEED_100;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tval |= EMAC_SPLITTER_CTRL_SPEED_10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\twritel(val, splitter_base + EMAC_SPLITTER_CTRL_REG);\n\t}\n\n\tif (phy_dev && sgmii_adapter_base)\n\t\twritew(SGMII_ADAPTER_ENABLE,\n\t\t       sgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\n}\n\nstatic int socfpga_dwmac_parse_data(struct socfpga_dwmac *dwmac, struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *sys_mgr_base_addr;\n\tu32 reg_offset, reg_shift;\n\tint ret, index;\n\tstruct device_node *np_splitter = NULL;\n\tstruct device_node *np_sgmii_adapter = NULL;\n\tstruct resource res_splitter;\n\tstruct resource res_tse_pcs;\n\tstruct resource res_sgmii_adapter;\n\n\tsys_mgr_base_addr =\n\t\taltr_sysmgr_regmap_lookup_by_phandle(np, \"altr,sysmgr-syscon\");\n\tif (IS_ERR(sys_mgr_base_addr)) {\n\t\tdev_info(dev, \"No sysmgr-syscon node found\\n\");\n\t\treturn PTR_ERR(sys_mgr_base_addr);\n\t}\n\n\tret = of_property_read_u32_index(np, \"altr,sysmgr-syscon\", 1, &reg_offset);\n\tif (ret) {\n\t\tdev_info(dev, \"Could not read reg_offset from sysmgr-syscon!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_index(np, \"altr,sysmgr-syscon\", 2, &reg_shift);\n\tif (ret) {\n\t\tdev_info(dev, \"Could not read reg_shift from sysmgr-syscon!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdwmac->f2h_ptp_ref_clk = of_property_read_bool(np, \"altr,f2h_ptp_ref_clk\");\n\n\tnp_splitter = of_parse_phandle(np, \"altr,emac-splitter\", 0);\n\tif (np_splitter) {\n\t\tret = of_address_to_resource(np_splitter, 0, &res_splitter);\n\t\tof_node_put(np_splitter);\n\t\tif (ret) {\n\t\t\tdev_info(dev, \"Missing emac splitter address\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdwmac->splitter_base = devm_ioremap_resource(dev, &res_splitter);\n\t\tif (IS_ERR(dwmac->splitter_base)) {\n\t\t\tdev_info(dev, \"Failed to mapping emac splitter\\n\");\n\t\t\treturn PTR_ERR(dwmac->splitter_base);\n\t\t}\n\t}\n\n\tnp_sgmii_adapter = of_parse_phandle(np,\n\t\t\t\t\t    \"altr,gmii-to-sgmii-converter\", 0);\n\tif (np_sgmii_adapter) {\n\t\tindex = of_property_match_string(np_sgmii_adapter, \"reg-names\",\n\t\t\t\t\t\t \"hps_emac_interface_splitter_avalon_slave\");\n\n\t\tif (index >= 0) {\n\t\t\tif (of_address_to_resource(np_sgmii_adapter, index,\n\t\t\t\t\t\t   &res_splitter)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s: ERROR: missing emac splitter address\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\n\t\t\tdwmac->splitter_base =\n\t\t\t    devm_ioremap_resource(dev, &res_splitter);\n\n\t\t\tif (IS_ERR(dwmac->splitter_base)) {\n\t\t\t\tret = PTR_ERR(dwmac->splitter_base);\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\t\t}\n\n\t\tindex = of_property_match_string(np_sgmii_adapter, \"reg-names\",\n\t\t\t\t\t\t \"gmii_to_sgmii_adapter_avalon_slave\");\n\n\t\tif (index >= 0) {\n\t\t\tif (of_address_to_resource(np_sgmii_adapter, index,\n\t\t\t\t\t\t   &res_sgmii_adapter)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s: ERROR: failed mapping adapter\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\n\t\t\tdwmac->sgmii_adapter_base =\n\t\t\t    devm_ioremap_resource(dev, &res_sgmii_adapter);\n\n\t\t\tif (IS_ERR(dwmac->sgmii_adapter_base)) {\n\t\t\t\tret = PTR_ERR(dwmac->sgmii_adapter_base);\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\t\t}\n\n\t\tindex = of_property_match_string(np_sgmii_adapter, \"reg-names\",\n\t\t\t\t\t\t \"eth_tse_control_port\");\n\n\t\tif (index >= 0) {\n\t\t\tif (of_address_to_resource(np_sgmii_adapter, index,\n\t\t\t\t\t\t   &res_tse_pcs)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s: ERROR: failed mapping tse control port\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\n\t\t\tdwmac->tse_pcs_base =\n\t\t\t    devm_ioremap_resource(dev, &res_tse_pcs);\n\n\t\t\tif (IS_ERR(dwmac->tse_pcs_base)) {\n\t\t\t\tret = PTR_ERR(dwmac->tse_pcs_base);\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\t\t}\n\t}\n\tdwmac->reg_offset = reg_offset;\n\tdwmac->reg_shift = reg_shift;\n\tdwmac->sys_mgr_base_addr = sys_mgr_base_addr;\n\tdwmac->dev = dev;\n\tof_node_put(np_sgmii_adapter);\n\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(np_sgmii_adapter);\n\treturn ret;\n}\n\nstatic int socfpga_get_plat_phymode(struct socfpga_dwmac *dwmac)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dwmac->dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\treturn priv->plat->mac_interface;\n}\n\nstatic void socfpga_sgmii_config(struct socfpga_dwmac *dwmac, bool enable)\n{\n\tu16 val = enable ? SGMII_ADAPTER_ENABLE : SGMII_ADAPTER_DISABLE;\n\n\twritew(val, dwmac->sgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\n}\n\nstatic int socfpga_set_phy_mode_common(int phymode, u32 *val)\n{\n\tswitch (phymode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\t*val = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_GMII:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\t*val = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\t*val = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RMII;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int socfpga_gen5_set_phy_mode(struct socfpga_dwmac *dwmac)\n{\n\tstruct regmap *sys_mgr_base_addr = dwmac->sys_mgr_base_addr;\n\tint phymode = socfpga_get_plat_phymode(dwmac);\n\tu32 reg_offset = dwmac->reg_offset;\n\tu32 reg_shift = dwmac->reg_shift;\n\tu32 ctrl, val, module;\n\n\tif (socfpga_set_phy_mode_common(phymode, &val)) {\n\t\tdev_err(dwmac->dev, \"bad phy mode %d\\n\", phymode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (dwmac->splitter_base)\n\t\tval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;\n\n\t \n\treset_control_assert(dwmac->stmmac_ocp_rst);\n\treset_control_assert(dwmac->stmmac_rst);\n\n\tregmap_read(sys_mgr_base_addr, reg_offset, &ctrl);\n\tctrl &= ~(SYSMGR_EMACGRP_CTRL_PHYSEL_MASK << reg_shift);\n\tctrl |= val << reg_shift;\n\n\tif (dwmac->f2h_ptp_ref_clk ||\n\t    phymode == PHY_INTERFACE_MODE_MII ||\n\t    phymode == PHY_INTERFACE_MODE_GMII ||\n\t    phymode == PHY_INTERFACE_MODE_SGMII) {\n\t\tregmap_read(sys_mgr_base_addr, SYSMGR_FPGAGRP_MODULE_REG,\n\t\t\t    &module);\n\t\tmodule |= (SYSMGR_FPGAGRP_MODULE_EMAC << (reg_shift / 2));\n\t\tregmap_write(sys_mgr_base_addr, SYSMGR_FPGAGRP_MODULE_REG,\n\t\t\t     module);\n\t}\n\n\tif (dwmac->f2h_ptp_ref_clk)\n\t\tctrl |= SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK << (reg_shift / 2);\n\telse\n\t\tctrl &= ~(SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK <<\n\t\t\t  (reg_shift / 2));\n\n\tregmap_write(sys_mgr_base_addr, reg_offset, ctrl);\n\n\t \n\treset_control_deassert(dwmac->stmmac_ocp_rst);\n\treset_control_deassert(dwmac->stmmac_rst);\n\tif (phymode == PHY_INTERFACE_MODE_SGMII)\n\t\tsocfpga_sgmii_config(dwmac, true);\n\n\treturn 0;\n}\n\nstatic int socfpga_gen10_set_phy_mode(struct socfpga_dwmac *dwmac)\n{\n\tstruct regmap *sys_mgr_base_addr = dwmac->sys_mgr_base_addr;\n\tint phymode = socfpga_get_plat_phymode(dwmac);\n\tu32 reg_offset = dwmac->reg_offset;\n\tu32 reg_shift = dwmac->reg_shift;\n\tu32 ctrl, val, module;\n\n\tif (socfpga_set_phy_mode_common(phymode, &val))\n\t\treturn -EINVAL;\n\n\t \n\tif (dwmac->splitter_base)\n\t\tval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;\n\n\t \n\treset_control_assert(dwmac->stmmac_ocp_rst);\n\treset_control_assert(dwmac->stmmac_rst);\n\n\tregmap_read(sys_mgr_base_addr, reg_offset, &ctrl);\n\tctrl &= ~(SYSMGR_EMACGRP_CTRL_PHYSEL_MASK);\n\tctrl |= val;\n\n\tif (dwmac->f2h_ptp_ref_clk ||\n\t    phymode == PHY_INTERFACE_MODE_MII ||\n\t    phymode == PHY_INTERFACE_MODE_GMII ||\n\t    phymode == PHY_INTERFACE_MODE_SGMII) {\n\t\tctrl |= SYSMGR_GEN10_EMACGRP_CTRL_PTP_REF_CLK_MASK;\n\t\tregmap_read(sys_mgr_base_addr, SYSMGR_FPGAINTF_EMAC_REG,\n\t\t\t    &module);\n\t\tmodule |= (SYSMGR_FPGAINTF_EMAC_BIT << reg_shift);\n\t\tregmap_write(sys_mgr_base_addr, SYSMGR_FPGAINTF_EMAC_REG,\n\t\t\t     module);\n\t} else {\n\t\tctrl &= ~SYSMGR_GEN10_EMACGRP_CTRL_PTP_REF_CLK_MASK;\n\t}\n\n\tregmap_write(sys_mgr_base_addr, reg_offset, ctrl);\n\n\t \n\treset_control_deassert(dwmac->stmmac_ocp_rst);\n\treset_control_deassert(dwmac->stmmac_rst);\n\tif (phymode == PHY_INTERFACE_MODE_SGMII)\n\t\tsocfpga_sgmii_config(dwmac, true);\n\treturn 0;\n}\n\nstatic int socfpga_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct device\t\t*dev = &pdev->dev;\n\tint\t\t\tret;\n\tstruct socfpga_dwmac\t*dwmac;\n\tstruct net_device\t*ndev;\n\tstruct stmmac_priv\t*stpriv;\n\tconst struct socfpga_dwmac_ops *ops;\n\n\tops = device_get_match_data(&pdev->dev);\n\tif (!ops) {\n\t\tdev_err(&pdev->dev, \"no of match data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tdwmac = devm_kzalloc(dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->stmmac_ocp_rst = devm_reset_control_get_optional(dev, \"stmmaceth-ocp\");\n\tif (IS_ERR(dwmac->stmmac_ocp_rst)) {\n\t\tret = PTR_ERR(dwmac->stmmac_ocp_rst);\n\t\tdev_err(dev, \"error getting reset control of ocp %d\\n\", ret);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\treset_control_deassert(dwmac->stmmac_ocp_rst);\n\n\tret = socfpga_dwmac_parse_data(dwmac, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to parse OF data\\n\");\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->ops = ops;\n\tplat_dat->bsp_priv = dwmac;\n\tplat_dat->fix_mac_speed = socfpga_dwmac_fix_mac_speed;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tndev = platform_get_drvdata(pdev);\n\tstpriv = netdev_priv(ndev);\n\n\t \n\tdwmac->stmmac_rst = stpriv->plat->stmmac_rst;\n\n\tret = ops->set_phy_mode(dwmac);\n\tif (ret)\n\t\tgoto err_dvr_remove;\n\n\t \n\tif (dwmac->tse_pcs_base) {\n\t\tstruct regmap_config pcs_regmap_cfg;\n\t\tstruct mdio_regmap_config mrc;\n\t\tstruct regmap *pcs_regmap;\n\t\tstruct mii_bus *pcs_bus;\n\n\t\tmemset(&pcs_regmap_cfg, 0, sizeof(pcs_regmap_cfg));\n\t\tmemset(&mrc, 0, sizeof(mrc));\n\n\t\tpcs_regmap_cfg.reg_bits = 16;\n\t\tpcs_regmap_cfg.val_bits = 16;\n\t\tpcs_regmap_cfg.reg_shift = REGMAP_UPSHIFT(1);\n\n\t\tpcs_regmap = devm_regmap_init_mmio(&pdev->dev, dwmac->tse_pcs_base,\n\t\t\t\t\t\t   &pcs_regmap_cfg);\n\t\tif (IS_ERR(pcs_regmap)) {\n\t\t\tret = PTR_ERR(pcs_regmap);\n\t\t\tgoto err_dvr_remove;\n\t\t}\n\n\t\tmrc.regmap = pcs_regmap;\n\t\tmrc.parent = &pdev->dev;\n\t\tmrc.valid_addr = 0x0;\n\t\tmrc.autoscan = false;\n\n\t\tsnprintf(mrc.name, MII_BUS_ID_SIZE, \"%s-pcs-mii\", ndev->name);\n\t\tpcs_bus = devm_mdio_regmap_register(&pdev->dev, &mrc);\n\t\tif (IS_ERR(pcs_bus)) {\n\t\t\tret = PTR_ERR(pcs_bus);\n\t\t\tgoto err_dvr_remove;\n\t\t}\n\n\t\tstpriv->hw->lynx_pcs = lynx_pcs_create_mdiodev(pcs_bus, 0);\n\t\tif (IS_ERR(stpriv->hw->lynx_pcs)) {\n\t\t\tret = PTR_ERR(stpriv->hw->lynx_pcs);\n\t\t\tgoto err_dvr_remove;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_dvr_remove:\n\tstmmac_dvr_remove(&pdev->dev);\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void socfpga_dwmac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct phylink_pcs *pcs = priv->hw->lynx_pcs;\n\n\tstmmac_pltfr_remove(pdev);\n\n\tlynx_pcs_destroy(pcs);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int socfpga_dwmac_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct socfpga_dwmac *dwmac_priv = get_stmmac_bsp_priv(dev);\n\n\tdwmac_priv->ops->set_phy_mode(priv->plat->bsp_priv);\n\n\t \n\tif (ndev->phydev)\n\t\tphy_resume(ndev->phydev);\n\n\treturn stmmac_resume(dev);\n}\n#endif  \n\nstatic int __maybe_unused socfpga_dwmac_runtime_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\tstmmac_bus_clks_config(priv, false);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused socfpga_dwmac_runtime_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\treturn stmmac_bus_clks_config(priv, true);\n}\n\nstatic const struct dev_pm_ops socfpga_dwmac_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stmmac_suspend, socfpga_dwmac_resume)\n\tSET_RUNTIME_PM_OPS(socfpga_dwmac_runtime_suspend, socfpga_dwmac_runtime_resume, NULL)\n};\n\nstatic const struct socfpga_dwmac_ops socfpga_gen5_ops = {\n\t.set_phy_mode = socfpga_gen5_set_phy_mode,\n};\n\nstatic const struct socfpga_dwmac_ops socfpga_gen10_ops = {\n\t.set_phy_mode = socfpga_gen10_set_phy_mode,\n};\n\nstatic const struct of_device_id socfpga_dwmac_match[] = {\n\t{ .compatible = \"altr,socfpga-stmmac\", .data = &socfpga_gen5_ops },\n\t{ .compatible = \"altr,socfpga-stmmac-a10-s10\", .data = &socfpga_gen10_ops },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, socfpga_dwmac_match);\n\nstatic struct platform_driver socfpga_dwmac_driver = {\n\t.probe  = socfpga_dwmac_probe,\n\t.remove_new = socfpga_dwmac_remove,\n\t.driver = {\n\t\t.name           = \"socfpga-dwmac\",\n\t\t.pm\t\t= &socfpga_dwmac_pm_ops,\n\t\t.of_match_table = socfpga_dwmac_match,\n\t},\n};\nmodule_platform_driver(socfpga_dwmac_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}