{
  "module_name": "dwmac_lib.c",
  "hash_id": "b4cd18febab1848d1a1262a8bac3d167218bf71d4f58f04c21952e08524fb0ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include \"common.h\"\n#include \"dwmac_dma.h\"\n#include \"stmmac.h\"\n\n#define GMAC_HI_REG_AE\t\t0x80000000\n\nint dwmac_dma_reset(void __iomem *ioaddr)\n{\n\tu32 value = readl(ioaddr + DMA_BUS_MODE);\n\n\t \n\tvalue |= DMA_BUS_MODE_SFT_RESET;\n\twritel(value, ioaddr + DMA_BUS_MODE);\n\n\treturn readl_poll_timeout(ioaddr + DMA_BUS_MODE, value,\n\t\t\t\t !(value & DMA_BUS_MODE_SFT_RESET),\n\t\t\t\t 10000, 200000);\n}\n\n \nvoid dwmac_enable_dma_transmission(void __iomem *ioaddr)\n{\n\twritel(1, ioaddr + DMA_XMT_POLL_DEMAND);\n}\n\nvoid dwmac_enable_dma_irq(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t  u32 chan, bool rx, bool tx)\n{\n\tu32 value = readl(ioaddr + DMA_INTR_ENA);\n\n\tif (rx)\n\t\tvalue |= DMA_INTR_DEFAULT_RX;\n\tif (tx)\n\t\tvalue |= DMA_INTR_DEFAULT_TX;\n\n\twritel(value, ioaddr + DMA_INTR_ENA);\n}\n\nvoid dwmac_disable_dma_irq(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t   u32 chan, bool rx, bool tx)\n{\n\tu32 value = readl(ioaddr + DMA_INTR_ENA);\n\n\tif (rx)\n\t\tvalue &= ~DMA_INTR_DEFAULT_RX;\n\tif (tx)\n\t\tvalue &= ~DMA_INTR_DEFAULT_TX;\n\n\twritel(value, ioaddr + DMA_INTR_ENA);\n}\n\nvoid dwmac_dma_start_tx(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\tu32 chan)\n{\n\tu32 value = readl(ioaddr + DMA_CONTROL);\n\tvalue |= DMA_CONTROL_ST;\n\twritel(value, ioaddr + DMA_CONTROL);\n}\n\nvoid dwmac_dma_stop_tx(struct stmmac_priv *priv, void __iomem *ioaddr, u32 chan)\n{\n\tu32 value = readl(ioaddr + DMA_CONTROL);\n\tvalue &= ~DMA_CONTROL_ST;\n\twritel(value, ioaddr + DMA_CONTROL);\n}\n\nvoid dwmac_dma_start_rx(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\tu32 chan)\n{\n\tu32 value = readl(ioaddr + DMA_CONTROL);\n\tvalue |= DMA_CONTROL_SR;\n\twritel(value, ioaddr + DMA_CONTROL);\n}\n\nvoid dwmac_dma_stop_rx(struct stmmac_priv *priv, void __iomem *ioaddr, u32 chan)\n{\n\tu32 value = readl(ioaddr + DMA_CONTROL);\n\tvalue &= ~DMA_CONTROL_SR;\n\twritel(value, ioaddr + DMA_CONTROL);\n}\n\n#ifdef DWMAC_DMA_DEBUG\nstatic void show_tx_process_state(unsigned int status)\n{\n\tunsigned int state;\n\tstate = (status & DMA_STATUS_TS_MASK) >> DMA_STATUS_TS_SHIFT;\n\n\tswitch (state) {\n\tcase 0:\n\t\tpr_debug(\"- TX (Stopped): Reset or Stop command\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tpr_debug(\"- TX (Running): Fetching the Tx desc\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tpr_debug(\"- TX (Running): Waiting for end of tx\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tpr_debug(\"- TX (Running): Reading the data \"\n\t\t       \"and queuing the data into the Tx buf\\n\");\n\t\tbreak;\n\tcase 6:\n\t\tpr_debug(\"- TX (Suspended): Tx Buff Underflow \"\n\t\t       \"or an unavailable Transmit descriptor\\n\");\n\t\tbreak;\n\tcase 7:\n\t\tpr_debug(\"- TX (Running): Closing Tx descriptor\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void show_rx_process_state(unsigned int status)\n{\n\tunsigned int state;\n\tstate = (status & DMA_STATUS_RS_MASK) >> DMA_STATUS_RS_SHIFT;\n\n\tswitch (state) {\n\tcase 0:\n\t\tpr_debug(\"- RX (Stopped): Reset or Stop command\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tpr_debug(\"- RX (Running): Fetching the Rx desc\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tpr_debug(\"- RX (Running): Checking for end of pkt\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tpr_debug(\"- RX (Running): Waiting for Rx pkt\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tpr_debug(\"- RX (Suspended): Unavailable Rx buf\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tpr_debug(\"- RX (Running): Closing Rx descriptor\\n\");\n\t\tbreak;\n\tcase 6:\n\t\tpr_debug(\"- RX(Running): Flushing the current frame\"\n\t\t       \" from the Rx buf\\n\");\n\t\tbreak;\n\tcase 7:\n\t\tpr_debug(\"- RX (Running): Queuing the Rx frame\"\n\t\t       \" from the Rx buf into memory\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n#endif\n\nint dwmac_dma_interrupt(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\tstruct stmmac_extra_stats *x, u32 chan, u32 dir)\n{\n\tstruct stmmac_rxq_stats *rxq_stats = &priv->xstats.rxq_stats[chan];\n\tstruct stmmac_txq_stats *txq_stats = &priv->xstats.txq_stats[chan];\n\tint ret = 0;\n\t \n\tu32 intr_status = readl(ioaddr + DMA_STATUS);\n\n#ifdef DWMAC_DMA_DEBUG\n\t \n\tpr_debug(\"%s: [CSR5: 0x%08x]\\n\", __func__, intr_status);\n\tshow_tx_process_state(intr_status);\n\tshow_rx_process_state(intr_status);\n#endif\n\n\tif (dir == DMA_DIR_RX)\n\t\tintr_status &= DMA_STATUS_MSK_RX;\n\telse if (dir == DMA_DIR_TX)\n\t\tintr_status &= DMA_STATUS_MSK_TX;\n\n\t \n\tif (unlikely(intr_status & DMA_STATUS_AIS)) {\n\t\tif (unlikely(intr_status & DMA_STATUS_UNF)) {\n\t\t\tret = tx_hard_error_bump_tc;\n\t\t\tx->tx_undeflow_irq++;\n\t\t}\n\t\tif (unlikely(intr_status & DMA_STATUS_TJT))\n\t\t\tx->tx_jabber_irq++;\n\n\t\tif (unlikely(intr_status & DMA_STATUS_OVF))\n\t\t\tx->rx_overflow_irq++;\n\n\t\tif (unlikely(intr_status & DMA_STATUS_RU))\n\t\t\tx->rx_buf_unav_irq++;\n\t\tif (unlikely(intr_status & DMA_STATUS_RPS))\n\t\t\tx->rx_process_stopped_irq++;\n\t\tif (unlikely(intr_status & DMA_STATUS_RWT))\n\t\t\tx->rx_watchdog_irq++;\n\t\tif (unlikely(intr_status & DMA_STATUS_ETI))\n\t\t\tx->tx_early_irq++;\n\t\tif (unlikely(intr_status & DMA_STATUS_TPS)) {\n\t\t\tx->tx_process_stopped_irq++;\n\t\t\tret = tx_hard_error;\n\t\t}\n\t\tif (unlikely(intr_status & DMA_STATUS_FBI)) {\n\t\t\tx->fatal_bus_error_irq++;\n\t\t\tret = tx_hard_error;\n\t\t}\n\t}\n\t \n\tif (likely(intr_status & DMA_STATUS_NIS)) {\n\t\tif (likely(intr_status & DMA_STATUS_RI)) {\n\t\t\tu32 value = readl(ioaddr + DMA_INTR_ENA);\n\t\t\t \n\t\t\tif (likely(value & DMA_INTR_ENA_RIE)) {\n\t\t\t\tu64_stats_update_begin(&rxq_stats->syncp);\n\t\t\t\trxq_stats->rx_normal_irq_n++;\n\t\t\t\tu64_stats_update_end(&rxq_stats->syncp);\n\t\t\t\tret |= handle_rx;\n\t\t\t}\n\t\t}\n\t\tif (likely(intr_status & DMA_STATUS_TI)) {\n\t\t\tu64_stats_update_begin(&txq_stats->syncp);\n\t\t\ttxq_stats->tx_normal_irq_n++;\n\t\t\tu64_stats_update_end(&txq_stats->syncp);\n\t\t\tret |= handle_tx;\n\t\t}\n\t\tif (unlikely(intr_status & DMA_STATUS_ERI))\n\t\t\tx->rx_early_irq++;\n\t}\n\t \n\tif (unlikely(intr_status &\n\t\t     (DMA_STATUS_GPI | DMA_STATUS_GMI | DMA_STATUS_GLI)))\n\t\tpr_warn(\"%s: unexpected status %08x\\n\", __func__, intr_status);\n\n\t \n\twritel((intr_status & 0x1ffff), ioaddr + DMA_STATUS);\n\n\treturn ret;\n}\n\nvoid dwmac_dma_flush_tx_fifo(void __iomem *ioaddr)\n{\n\tu32 csr6 = readl(ioaddr + DMA_CONTROL);\n\twritel((csr6 | DMA_CONTROL_FTF), ioaddr + DMA_CONTROL);\n\n\tdo {} while ((readl(ioaddr + DMA_CONTROL) & DMA_CONTROL_FTF));\n}\n\nvoid stmmac_set_mac_addr(void __iomem *ioaddr, const u8 addr[6],\n\t\t\t unsigned int high, unsigned int low)\n{\n\tunsigned long data;\n\n\tdata = (addr[5] << 8) | addr[4];\n\t \n\twritel(data | GMAC_HI_REG_AE, ioaddr + high);\n\tdata = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\n\twritel(data, ioaddr + low);\n}\nEXPORT_SYMBOL_GPL(stmmac_set_mac_addr);\n\n \nvoid stmmac_set_mac(void __iomem *ioaddr, bool enable)\n{\n\tu32 old_val, value;\n\n\told_val = readl(ioaddr + MAC_CTRL_REG);\n\tvalue = old_val;\n\n\tif (enable)\n\t\tvalue |= MAC_ENABLE_RX | MAC_ENABLE_TX;\n\telse\n\t\tvalue &= ~(MAC_ENABLE_TX | MAC_ENABLE_RX);\n\n\tif (value != old_val)\n\t\twritel(value, ioaddr + MAC_CTRL_REG);\n}\n\nvoid stmmac_get_mac_addr(void __iomem *ioaddr, unsigned char *addr,\n\t\t\t unsigned int high, unsigned int low)\n{\n\tunsigned int hi_addr, lo_addr;\n\n\t \n\thi_addr = readl(ioaddr + high);\n\tlo_addr = readl(ioaddr + low);\n\n\t \n\taddr[0] = lo_addr & 0xff;\n\taddr[1] = (lo_addr >> 8) & 0xff;\n\taddr[2] = (lo_addr >> 16) & 0xff;\n\taddr[3] = (lo_addr >> 24) & 0xff;\n\taddr[4] = hi_addr & 0xff;\n\taddr[5] = (hi_addr >> 8) & 0xff;\n}\nEXPORT_SYMBOL_GPL(stmmac_get_mac_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}