{
  "module_name": "ring_mode.c",
  "hash_id": "f6cf8616a9e655652874221b508a64cc3bd94f3f9ef31fa465469aa7a4338085",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/ring_mode.c",
  "human_readable_source": "\n \n\n#include \"stmmac.h\"\n\nstatic int jumbo_frm(struct stmmac_tx_queue *tx_q, struct sk_buff *skb,\n\t\t     int csum)\n{\n\tunsigned int nopaged_len = skb_headlen(skb);\n\tstruct stmmac_priv *priv = tx_q->priv_data;\n\tunsigned int entry = tx_q->cur_tx;\n\tunsigned int bmax, len, des2;\n\tstruct dma_desc *desc;\n\n\tif (priv->extend_desc)\n\t\tdesc = (struct dma_desc *)(tx_q->dma_etx + entry);\n\telse\n\t\tdesc = tx_q->dma_tx + entry;\n\n\tif (priv->plat->enh_desc)\n\t\tbmax = BUF_SIZE_8KiB;\n\telse\n\t\tbmax = BUF_SIZE_2KiB;\n\n\tlen = nopaged_len - bmax;\n\n\tif (nopaged_len > BUF_SIZE_8KiB) {\n\n\t\tdes2 = dma_map_single(priv->device, skb->data, bmax,\n\t\t\t\t      DMA_TO_DEVICE);\n\t\tdesc->des2 = cpu_to_le32(des2);\n\t\tif (dma_mapping_error(priv->device, des2))\n\t\t\treturn -1;\n\n\t\ttx_q->tx_skbuff_dma[entry].buf = des2;\n\t\ttx_q->tx_skbuff_dma[entry].len = bmax;\n\t\ttx_q->tx_skbuff_dma[entry].is_jumbo = true;\n\n\t\tdesc->des3 = cpu_to_le32(des2 + BUF_SIZE_4KiB);\n\t\tstmmac_prepare_tx_desc(priv, desc, 1, bmax, csum,\n\t\t\t\tSTMMAC_RING_MODE, 0, false, skb->len);\n\t\ttx_q->tx_skbuff[entry] = NULL;\n\t\tentry = STMMAC_GET_ENTRY(entry, priv->dma_conf.dma_tx_size);\n\n\t\tif (priv->extend_desc)\n\t\t\tdesc = (struct dma_desc *)(tx_q->dma_etx + entry);\n\t\telse\n\t\t\tdesc = tx_q->dma_tx + entry;\n\n\t\tdes2 = dma_map_single(priv->device, skb->data + bmax, len,\n\t\t\t\t      DMA_TO_DEVICE);\n\t\tdesc->des2 = cpu_to_le32(des2);\n\t\tif (dma_mapping_error(priv->device, des2))\n\t\t\treturn -1;\n\t\ttx_q->tx_skbuff_dma[entry].buf = des2;\n\t\ttx_q->tx_skbuff_dma[entry].len = len;\n\t\ttx_q->tx_skbuff_dma[entry].is_jumbo = true;\n\n\t\tdesc->des3 = cpu_to_le32(des2 + BUF_SIZE_4KiB);\n\t\tstmmac_prepare_tx_desc(priv, desc, 0, len, csum,\n\t\t\t\tSTMMAC_RING_MODE, 1, !skb_is_nonlinear(skb),\n\t\t\t\tskb->len);\n\t} else {\n\t\tdes2 = dma_map_single(priv->device, skb->data,\n\t\t\t\t      nopaged_len, DMA_TO_DEVICE);\n\t\tdesc->des2 = cpu_to_le32(des2);\n\t\tif (dma_mapping_error(priv->device, des2))\n\t\t\treturn -1;\n\t\ttx_q->tx_skbuff_dma[entry].buf = des2;\n\t\ttx_q->tx_skbuff_dma[entry].len = nopaged_len;\n\t\ttx_q->tx_skbuff_dma[entry].is_jumbo = true;\n\t\tdesc->des3 = cpu_to_le32(des2 + BUF_SIZE_4KiB);\n\t\tstmmac_prepare_tx_desc(priv, desc, 1, nopaged_len, csum,\n\t\t\t\tSTMMAC_RING_MODE, 0, !skb_is_nonlinear(skb),\n\t\t\t\tskb->len);\n\t}\n\n\ttx_q->cur_tx = entry;\n\n\treturn entry;\n}\n\nstatic unsigned int is_jumbo_frm(int len, int enh_desc)\n{\n\tunsigned int ret = 0;\n\n\tif (len >= BUF_SIZE_4KiB)\n\t\tret = 1;\n\n\treturn ret;\n}\n\nstatic void refill_desc3(struct stmmac_rx_queue *rx_q, struct dma_desc *p)\n{\n\tstruct stmmac_priv *priv = rx_q->priv_data;\n\n\t \n\tif (priv->dma_conf.dma_buf_sz == BUF_SIZE_16KiB)\n\t\tp->des3 = cpu_to_le32(le32_to_cpu(p->des2) + BUF_SIZE_8KiB);\n}\n\n \nstatic void init_desc3(struct dma_desc *p)\n{\n\tp->des3 = cpu_to_le32(le32_to_cpu(p->des2) + BUF_SIZE_8KiB);\n}\n\nstatic void clean_desc3(struct stmmac_tx_queue *tx_q, struct dma_desc *p)\n{\n\tstruct stmmac_priv *priv = tx_q->priv_data;\n\tunsigned int entry = tx_q->dirty_tx;\n\n\t \n\tif (unlikely(tx_q->tx_skbuff_dma[entry].is_jumbo ||\n\t\t     (tx_q->tx_skbuff_dma[entry].last_segment &&\n\t\t      !priv->extend_desc && priv->hwts_tx_en)))\n\t\tp->des3 = 0;\n}\n\nstatic int set_16kib_bfsize(int mtu)\n{\n\tint ret = 0;\n\tif (unlikely(mtu > BUF_SIZE_8KiB))\n\t\tret = BUF_SIZE_16KiB;\n\treturn ret;\n}\n\nconst struct stmmac_mode_ops ring_mode_ops = {\n\t.is_jumbo_frm = is_jumbo_frm,\n\t.jumbo_frm = jumbo_frm,\n\t.refill_desc3 = refill_desc3,\n\t.init_desc3 = init_desc3,\n\t.clean_desc3 = clean_desc3,\n\t.set_16kib_bfsize = set_16kib_bfsize,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}