{
  "module_name": "dwmac-qcom-ethqos.c",
  "hash_id": "aab26a4dd4040b7c3d967a03252b48961d8e48753cceab0197f3c08d8fcc0178",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n\n#include \"stmmac.h\"\n#include \"stmmac_platform.h\"\n\n#define RGMII_IO_MACRO_CONFIG\t\t0x0\n#define SDCC_HC_REG_DLL_CONFIG\t\t0x4\n#define SDCC_TEST_CTL\t\t\t0x8\n#define SDCC_HC_REG_DDR_CONFIG\t\t0xC\n#define SDCC_HC_REG_DLL_CONFIG2\t\t0x10\n#define SDC4_STATUS\t\t\t0x14\n#define SDCC_USR_CTL\t\t\t0x18\n#define RGMII_IO_MACRO_CONFIG2\t\t0x1C\n#define RGMII_IO_MACRO_DEBUG1\t\t0x20\n#define EMAC_SYSTEM_LOW_POWER_DEBUG\t0x28\n\n \n#define RGMII_CONFIG_FUNC_CLK_EN\t\tBIT(30)\n#define RGMII_CONFIG_POS_NEG_DATA_SEL\t\tBIT(23)\n#define RGMII_CONFIG_GPIO_CFG_RX_INT\t\tGENMASK(21, 20)\n#define RGMII_CONFIG_GPIO_CFG_TX_INT\t\tGENMASK(19, 17)\n#define RGMII_CONFIG_MAX_SPD_PRG_9\t\tGENMASK(16, 8)\n#define RGMII_CONFIG_MAX_SPD_PRG_2\t\tGENMASK(7, 6)\n#define RGMII_CONFIG_INTF_SEL\t\t\tGENMASK(5, 4)\n#define RGMII_CONFIG_BYPASS_TX_ID_EN\t\tBIT(3)\n#define RGMII_CONFIG_LOOPBACK_EN\t\tBIT(2)\n#define RGMII_CONFIG_PROG_SWAP\t\t\tBIT(1)\n#define RGMII_CONFIG_DDR_MODE\t\t\tBIT(0)\n#define RGMII_CONFIG_SGMII_CLK_DVDR\t\tGENMASK(18, 10)\n\n \n#define SDCC_DLL_CONFIG_DLL_RST\t\t\tBIT(30)\n#define SDCC_DLL_CONFIG_PDN\t\t\tBIT(29)\n#define SDCC_DLL_CONFIG_MCLK_FREQ\t\tGENMASK(26, 24)\n#define SDCC_DLL_CONFIG_CDR_SELEXT\t\tGENMASK(23, 20)\n#define SDCC_DLL_CONFIG_CDR_EXT_EN\t\tBIT(19)\n#define SDCC_DLL_CONFIG_CK_OUT_EN\t\tBIT(18)\n#define SDCC_DLL_CONFIG_CDR_EN\t\t\tBIT(17)\n#define SDCC_DLL_CONFIG_DLL_EN\t\t\tBIT(16)\n#define SDCC_DLL_MCLK_GATING_EN\t\t\tBIT(5)\n#define SDCC_DLL_CDR_FINE_PHASE\t\t\tGENMASK(3, 2)\n\n \n#define SDCC_DDR_CONFIG_PRG_DLY_EN\t\tBIT(31)\n#define SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY\tGENMASK(26, 21)\n#define SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_CODE\tGENMASK(29, 27)\n#define SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_EN\tBIT(30)\n#define SDCC_DDR_CONFIG_TCXO_CYCLES_CNT\t\tGENMASK(11, 9)\n#define SDCC_DDR_CONFIG_PRG_RCLK_DLY\t\tGENMASK(8, 0)\n\n \n#define SDCC_DLL_CONFIG2_DLL_CLOCK_DIS\t\tBIT(21)\n#define SDCC_DLL_CONFIG2_MCLK_FREQ_CALC\t\tGENMASK(17, 10)\n#define SDCC_DLL_CONFIG2_DDR_TRAFFIC_INIT_SEL\tGENMASK(3, 2)\n#define SDCC_DLL_CONFIG2_DDR_TRAFFIC_INIT_SW\tBIT(1)\n#define SDCC_DLL_CONFIG2_DDR_CAL_EN\t\tBIT(0)\n\n \n#define SDC4_STATUS_DLL_LOCK\t\t\tBIT(7)\n\n \n#define RGMII_CONFIG2_RSVD_CONFIG15\t\tGENMASK(31, 17)\n#define RGMII_CONFIG2_RGMII_CLK_SEL_CFG\t\tBIT(16)\n#define RGMII_CONFIG2_TX_TO_RX_LOOPBACK_EN\tBIT(13)\n#define RGMII_CONFIG2_CLK_DIVIDE_SEL\t\tBIT(12)\n#define RGMII_CONFIG2_RX_PROG_SWAP\t\tBIT(7)\n#define RGMII_CONFIG2_DATA_DIVIDE_CLK_SEL\tBIT(6)\n#define RGMII_CONFIG2_TX_CLK_PHASE_SHIFT_EN\tBIT(5)\n\n \n#define ETHQOS_MAC_CTRL_SPEED_MODE\t\tBIT(14)\n#define ETHQOS_MAC_CTRL_PORT_SEL\t\tBIT(15)\n\n#define SGMII_10M_RX_CLK_DVDR\t\t\t0x31\n\nstruct ethqos_emac_por {\n\tunsigned int offset;\n\tunsigned int value;\n};\n\nstruct ethqos_emac_driver_data {\n\tconst struct ethqos_emac_por *por;\n\tunsigned int num_por;\n\tbool rgmii_config_loopback_en;\n\tbool has_emac_ge_3;\n\tconst char *link_clk_name;\n\tbool has_integrated_pcs;\n\tstruct dwmac4_addrs dwmac4_addrs;\n};\n\nstruct qcom_ethqos {\n\tstruct platform_device *pdev;\n\tvoid __iomem *rgmii_base;\n\tvoid __iomem *mac_base;\n\tint (*configure_func)(struct qcom_ethqos *ethqos);\n\n\tunsigned int link_clk_rate;\n\tstruct clk *link_clk;\n\tstruct phy *serdes_phy;\n\tunsigned int speed;\n\tphy_interface_t phy_mode;\n\n\tconst struct ethqos_emac_por *por;\n\tunsigned int num_por;\n\tbool rgmii_config_loopback_en;\n\tbool has_emac_ge_3;\n};\n\nstatic int rgmii_readl(struct qcom_ethqos *ethqos, unsigned int offset)\n{\n\treturn readl(ethqos->rgmii_base + offset);\n}\n\nstatic void rgmii_writel(struct qcom_ethqos *ethqos,\n\t\t\t int value, unsigned int offset)\n{\n\twritel(value, ethqos->rgmii_base + offset);\n}\n\nstatic void rgmii_updatel(struct qcom_ethqos *ethqos,\n\t\t\t  int mask, int val, unsigned int offset)\n{\n\tunsigned int temp;\n\n\ttemp = rgmii_readl(ethqos, offset);\n\ttemp = (temp & ~(mask)) | val;\n\trgmii_writel(ethqos, temp, offset);\n}\n\nstatic void rgmii_dump(void *priv)\n{\n\tstruct qcom_ethqos *ethqos = priv;\n\tstruct device *dev = &ethqos->pdev->dev;\n\n\tdev_dbg(dev, \"Rgmii register dump\\n\");\n\tdev_dbg(dev, \"RGMII_IO_MACRO_CONFIG: %x\\n\",\n\t\trgmii_readl(ethqos, RGMII_IO_MACRO_CONFIG));\n\tdev_dbg(dev, \"SDCC_HC_REG_DLL_CONFIG: %x\\n\",\n\t\trgmii_readl(ethqos, SDCC_HC_REG_DLL_CONFIG));\n\tdev_dbg(dev, \"SDCC_HC_REG_DDR_CONFIG: %x\\n\",\n\t\trgmii_readl(ethqos, SDCC_HC_REG_DDR_CONFIG));\n\tdev_dbg(dev, \"SDCC_HC_REG_DLL_CONFIG2: %x\\n\",\n\t\trgmii_readl(ethqos, SDCC_HC_REG_DLL_CONFIG2));\n\tdev_dbg(dev, \"SDC4_STATUS: %x\\n\",\n\t\trgmii_readl(ethqos, SDC4_STATUS));\n\tdev_dbg(dev, \"SDCC_USR_CTL: %x\\n\",\n\t\trgmii_readl(ethqos, SDCC_USR_CTL));\n\tdev_dbg(dev, \"RGMII_IO_MACRO_CONFIG2: %x\\n\",\n\t\trgmii_readl(ethqos, RGMII_IO_MACRO_CONFIG2));\n\tdev_dbg(dev, \"RGMII_IO_MACRO_DEBUG1: %x\\n\",\n\t\trgmii_readl(ethqos, RGMII_IO_MACRO_DEBUG1));\n\tdev_dbg(dev, \"EMAC_SYSTEM_LOW_POWER_DEBUG: %x\\n\",\n\t\trgmii_readl(ethqos, EMAC_SYSTEM_LOW_POWER_DEBUG));\n}\n\n \n#define RGMII_1000_NOM_CLK_FREQ\t\t\t(250 * 1000 * 1000UL)\n#define RGMII_ID_MODE_100_LOW_SVS_CLK_FREQ\t (50 * 1000 * 1000UL)\n#define RGMII_ID_MODE_10_LOW_SVS_CLK_FREQ\t  (5 * 1000 * 1000UL)\n\nstatic void\nethqos_update_link_clk(struct qcom_ethqos *ethqos, unsigned int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tethqos->link_clk_rate =  RGMII_1000_NOM_CLK_FREQ;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tethqos->link_clk_rate =  RGMII_ID_MODE_100_LOW_SVS_CLK_FREQ;\n\t\tbreak;\n\n\tcase SPEED_10:\n\t\tethqos->link_clk_rate =  RGMII_ID_MODE_10_LOW_SVS_CLK_FREQ;\n\t\tbreak;\n\t}\n\n\tclk_set_rate(ethqos->link_clk, ethqos->link_clk_rate);\n}\n\nstatic void ethqos_set_func_clk_en(struct qcom_ethqos *ethqos)\n{\n\trgmii_updatel(ethqos, RGMII_CONFIG_FUNC_CLK_EN,\n\t\t      RGMII_CONFIG_FUNC_CLK_EN, RGMII_IO_MACRO_CONFIG);\n}\n\nstatic const struct ethqos_emac_por emac_v2_3_0_por[] = {\n\t{ .offset = RGMII_IO_MACRO_CONFIG,\t.value = 0x00C01343 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG,\t.value = 0x2004642C },\n\t{ .offset = SDCC_HC_REG_DDR_CONFIG,\t.value = 0x00000000 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG2,\t.value = 0x00200000 },\n\t{ .offset = SDCC_USR_CTL,\t\t.value = 0x00010800 },\n\t{ .offset = RGMII_IO_MACRO_CONFIG2,\t.value = 0x00002060 },\n};\n\nstatic const struct ethqos_emac_driver_data emac_v2_3_0_data = {\n\t.por = emac_v2_3_0_por,\n\t.num_por = ARRAY_SIZE(emac_v2_3_0_por),\n\t.rgmii_config_loopback_en = true,\n\t.has_emac_ge_3 = false,\n};\n\nstatic const struct ethqos_emac_por emac_v2_1_0_por[] = {\n\t{ .offset = RGMII_IO_MACRO_CONFIG,\t.value = 0x40C01343 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG,\t.value = 0x2004642C },\n\t{ .offset = SDCC_HC_REG_DDR_CONFIG,\t.value = 0x00000000 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG2,\t.value = 0x00200000 },\n\t{ .offset = SDCC_USR_CTL,\t\t.value = 0x00010800 },\n\t{ .offset = RGMII_IO_MACRO_CONFIG2,\t.value = 0x00002060 },\n};\n\nstatic const struct ethqos_emac_driver_data emac_v2_1_0_data = {\n\t.por = emac_v2_1_0_por,\n\t.num_por = ARRAY_SIZE(emac_v2_1_0_por),\n\t.rgmii_config_loopback_en = false,\n\t.has_emac_ge_3 = false,\n};\n\nstatic const struct ethqos_emac_por emac_v3_0_0_por[] = {\n\t{ .offset = RGMII_IO_MACRO_CONFIG,\t.value = 0x40c01343 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG,\t.value = 0x2004642c },\n\t{ .offset = SDCC_HC_REG_DDR_CONFIG,\t.value = 0x80040800 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG2,\t.value = 0x00200000 },\n\t{ .offset = SDCC_USR_CTL,\t\t.value = 0x00010800 },\n\t{ .offset = RGMII_IO_MACRO_CONFIG2,\t.value = 0x00002060 },\n};\n\nstatic const struct ethqos_emac_driver_data emac_v3_0_0_data = {\n\t.por = emac_v3_0_0_por,\n\t.num_por = ARRAY_SIZE(emac_v3_0_0_por),\n\t.rgmii_config_loopback_en = false,\n\t.has_emac_ge_3 = true,\n\t.dwmac4_addrs = {\n\t\t.dma_chan = 0x00008100,\n\t\t.dma_chan_offset = 0x1000,\n\t\t.mtl_chan = 0x00008000,\n\t\t.mtl_chan_offset = 0x1000,\n\t\t.mtl_ets_ctrl = 0x00008010,\n\t\t.mtl_ets_ctrl_offset = 0x1000,\n\t\t.mtl_txq_weight = 0x00008018,\n\t\t.mtl_txq_weight_offset = 0x1000,\n\t\t.mtl_send_slp_cred = 0x0000801c,\n\t\t.mtl_send_slp_cred_offset = 0x1000,\n\t\t.mtl_high_cred = 0x00008020,\n\t\t.mtl_high_cred_offset = 0x1000,\n\t\t.mtl_low_cred = 0x00008024,\n\t\t.mtl_low_cred_offset = 0x1000,\n\t},\n};\n\nstatic const struct ethqos_emac_por emac_v4_0_0_por[] = {\n\t{ .offset = RGMII_IO_MACRO_CONFIG,\t.value = 0x40c01343 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG,\t.value = 0x2004642c },\n\t{ .offset = SDCC_HC_REG_DDR_CONFIG,\t.value = 0x80040800 },\n\t{ .offset = SDCC_HC_REG_DLL_CONFIG2,\t.value = 0x00200000 },\n\t{ .offset = SDCC_USR_CTL,\t\t.value = 0x00010800 },\n\t{ .offset = RGMII_IO_MACRO_CONFIG2,\t.value = 0x00002060 },\n};\n\nstatic const struct ethqos_emac_driver_data emac_v4_0_0_data = {\n\t.por = emac_v4_0_0_por,\n\t.num_por = ARRAY_SIZE(emac_v3_0_0_por),\n\t.rgmii_config_loopback_en = false,\n\t.has_emac_ge_3 = true,\n\t.link_clk_name = \"phyaux\",\n\t.has_integrated_pcs = true,\n\t.dwmac4_addrs = {\n\t\t.dma_chan = 0x00008100,\n\t\t.dma_chan_offset = 0x1000,\n\t\t.mtl_chan = 0x00008000,\n\t\t.mtl_chan_offset = 0x1000,\n\t\t.mtl_ets_ctrl = 0x00008010,\n\t\t.mtl_ets_ctrl_offset = 0x1000,\n\t\t.mtl_txq_weight = 0x00008018,\n\t\t.mtl_txq_weight_offset = 0x1000,\n\t\t.mtl_send_slp_cred = 0x0000801c,\n\t\t.mtl_send_slp_cred_offset = 0x1000,\n\t\t.mtl_high_cred = 0x00008020,\n\t\t.mtl_high_cred_offset = 0x1000,\n\t\t.mtl_low_cred = 0x00008024,\n\t\t.mtl_low_cred_offset = 0x1000,\n\t},\n};\n\nstatic int ethqos_dll_configure(struct qcom_ethqos *ethqos)\n{\n\tstruct device *dev = &ethqos->pdev->dev;\n\tunsigned int val;\n\tint retry = 1000;\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_CDR_EN,\n\t\t      SDCC_DLL_CONFIG_CDR_EN, SDCC_HC_REG_DLL_CONFIG);\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_CDR_EXT_EN,\n\t\t      SDCC_DLL_CONFIG_CDR_EXT_EN, SDCC_HC_REG_DLL_CONFIG);\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_CK_OUT_EN,\n\t\t      0, SDCC_HC_REG_DLL_CONFIG);\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_DLL_EN,\n\t\t      SDCC_DLL_CONFIG_DLL_EN, SDCC_HC_REG_DLL_CONFIG);\n\n\tif (!ethqos->has_emac_ge_3) {\n\t\trgmii_updatel(ethqos, SDCC_DLL_MCLK_GATING_EN,\n\t\t\t      0, SDCC_HC_REG_DLL_CONFIG);\n\n\t\trgmii_updatel(ethqos, SDCC_DLL_CDR_FINE_PHASE,\n\t\t\t      0, SDCC_HC_REG_DLL_CONFIG);\n\t}\n\n\t \n\tdo {\n\t\tval = rgmii_readl(ethqos, SDCC_HC_REG_DLL_CONFIG);\n\t\tval &= SDCC_DLL_CONFIG_CK_OUT_EN;\n\t\tif (!val)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t\tretry--;\n\t} while (retry > 0);\n\tif (!retry)\n\t\tdev_err(dev, \"Clear CK_OUT_EN timedout\\n\");\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_CK_OUT_EN,\n\t\t      SDCC_DLL_CONFIG_CK_OUT_EN, SDCC_HC_REG_DLL_CONFIG);\n\n\t \n\tretry = 1000;\n\tdo {\n\t\tval = rgmii_readl(ethqos, SDCC_HC_REG_DLL_CONFIG);\n\t\tval &= SDCC_DLL_CONFIG_CK_OUT_EN;\n\t\tif (val)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t\tretry--;\n\t} while (retry > 0);\n\tif (!retry)\n\t\tdev_err(dev, \"Set CK_OUT_EN timedout\\n\");\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG2_DDR_CAL_EN,\n\t\t      SDCC_DLL_CONFIG2_DDR_CAL_EN, SDCC_HC_REG_DLL_CONFIG2);\n\n\tif (!ethqos->has_emac_ge_3) {\n\t\trgmii_updatel(ethqos, SDCC_DLL_CONFIG2_DLL_CLOCK_DIS,\n\t\t\t      0, SDCC_HC_REG_DLL_CONFIG2);\n\n\t\trgmii_updatel(ethqos, SDCC_DLL_CONFIG2_MCLK_FREQ_CALC,\n\t\t\t      0x1A << 10, SDCC_HC_REG_DLL_CONFIG2);\n\n\t\trgmii_updatel(ethqos, SDCC_DLL_CONFIG2_DDR_TRAFFIC_INIT_SEL,\n\t\t\t      BIT(2), SDCC_HC_REG_DLL_CONFIG2);\n\n\t\trgmii_updatel(ethqos, SDCC_DLL_CONFIG2_DDR_TRAFFIC_INIT_SW,\n\t\t\t      SDCC_DLL_CONFIG2_DDR_TRAFFIC_INIT_SW,\n\t\t\t      SDCC_HC_REG_DLL_CONFIG2);\n\t}\n\n\treturn 0;\n}\n\nstatic int ethqos_rgmii_macro_init(struct qcom_ethqos *ethqos)\n{\n\tstruct device *dev = &ethqos->pdev->dev;\n\tint phase_shift;\n\tint loopback;\n\n\t \n\tif (ethqos->phy_mode == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    ethqos->phy_mode == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\tphase_shift = 0;\n\telse\n\t\tphase_shift = RGMII_CONFIG2_TX_CLK_PHASE_SHIFT_EN;\n\n\t \n\trgmii_updatel(ethqos, RGMII_CONFIG2_TX_TO_RX_LOOPBACK_EN,\n\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\n\t \n\tif (ethqos->rgmii_config_loopback_en)\n\t\tloopback = RGMII_CONFIG_LOOPBACK_EN;\n\telse\n\t\tloopback = 0;\n\n\t \n\trgmii_updatel(ethqos, RGMII_CONFIG_INTF_SEL,\n\t\t      0, RGMII_IO_MACRO_CONFIG);\n\n\tswitch (ethqos->speed) {\n\tcase SPEED_1000:\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_DDR_MODE,\n\t\t\t      RGMII_CONFIG_DDR_MODE, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_BYPASS_TX_ID_EN,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_POS_NEG_DATA_SEL,\n\t\t\t      RGMII_CONFIG_POS_NEG_DATA_SEL,\n\t\t\t      RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_PROG_SWAP,\n\t\t\t      RGMII_CONFIG_PROG_SWAP, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_DATA_DIVIDE_CLK_SEL,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_TX_CLK_PHASE_SHIFT_EN,\n\t\t\t      phase_shift, RGMII_IO_MACRO_CONFIG2);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RSVD_CONFIG15,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t      RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t      RGMII_IO_MACRO_CONFIG2);\n\n\t\t \n\t\tif (ethqos->has_emac_ge_3) {\n\t\t\t \n\t\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_PRG_RCLK_DLY,\n\t\t\t\t      115, SDCC_HC_REG_DDR_CONFIG);\n\t\t} else {\n\t\t\t \n\t\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_PRG_RCLK_DLY,\n\t\t\t\t      57, SDCC_HC_REG_DDR_CONFIG);\n\t\t}\n\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_PRG_DLY_EN,\n\t\t\t      SDCC_DDR_CONFIG_PRG_DLY_EN,\n\t\t\t      SDCC_HC_REG_DDR_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_LOOPBACK_EN,\n\t\t\t      loopback, RGMII_IO_MACRO_CONFIG);\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_DDR_MODE,\n\t\t\t      RGMII_CONFIG_DDR_MODE, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_BYPASS_TX_ID_EN,\n\t\t\t      RGMII_CONFIG_BYPASS_TX_ID_EN,\n\t\t\t      RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_POS_NEG_DATA_SEL,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_PROG_SWAP,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_DATA_DIVIDE_CLK_SEL,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_TX_CLK_PHASE_SHIFT_EN,\n\t\t\t      phase_shift, RGMII_IO_MACRO_CONFIG2);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_MAX_SPD_PRG_2,\n\t\t\t      BIT(6), RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RSVD_CONFIG15,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\n\t\tif (ethqos->has_emac_ge_3)\n\t\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t\t      RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t\t      RGMII_IO_MACRO_CONFIG2);\n\t\telse\n\t\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\n\t\t \n\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_CODE,\n\t\t\t      (BIT(29) | BIT(27)), SDCC_HC_REG_DDR_CONFIG);\n\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY,\n\t\t\t      SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY,\n\t\t\t      SDCC_HC_REG_DDR_CONFIG);\n\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_EN,\n\t\t\t      SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_EN,\n\t\t\t      SDCC_HC_REG_DDR_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_LOOPBACK_EN,\n\t\t\t      loopback, RGMII_IO_MACRO_CONFIG);\n\t\tbreak;\n\n\tcase SPEED_10:\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_DDR_MODE,\n\t\t\t      RGMII_CONFIG_DDR_MODE, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_BYPASS_TX_ID_EN,\n\t\t\t      RGMII_CONFIG_BYPASS_TX_ID_EN,\n\t\t\t      RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_POS_NEG_DATA_SEL,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_PROG_SWAP,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_DATA_DIVIDE_CLK_SEL,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_TX_CLK_PHASE_SHIFT_EN,\n\t\t\t      phase_shift, RGMII_IO_MACRO_CONFIG2);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_MAX_SPD_PRG_9,\n\t\t\t      BIT(12) | GENMASK(9, 8),\n\t\t\t      RGMII_IO_MACRO_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RSVD_CONFIG15,\n\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\t\tif (ethqos->has_emac_ge_3)\n\t\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t\t      RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t\t      RGMII_IO_MACRO_CONFIG2);\n\t\telse\n\t\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RX_PROG_SWAP,\n\t\t\t\t      0, RGMII_IO_MACRO_CONFIG2);\n\t\t \n\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_CODE,\n\t\t\t      (BIT(29) | BIT(27)), SDCC_HC_REG_DDR_CONFIG);\n\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY,\n\t\t\t      SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY,\n\t\t\t      SDCC_HC_REG_DDR_CONFIG);\n\t\trgmii_updatel(ethqos, SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_EN,\n\t\t\t      SDCC_DDR_CONFIG_EXT_PRG_RCLK_DLY_EN,\n\t\t\t      SDCC_HC_REG_DDR_CONFIG);\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_LOOPBACK_EN,\n\t\t\t      loopback, RGMII_IO_MACRO_CONFIG);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid speed %d\\n\", ethqos->speed);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ethqos_configure_rgmii(struct qcom_ethqos *ethqos)\n{\n\tstruct device *dev = &ethqos->pdev->dev;\n\tvolatile unsigned int dll_lock;\n\tunsigned int i, retry = 1000;\n\n\t \n\tfor (i = 0; i < ethqos->num_por; i++)\n\t\trgmii_writel(ethqos, ethqos->por[i].value,\n\t\t\t     ethqos->por[i].offset);\n\tethqos_set_func_clk_en(ethqos);\n\n\t \n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_DLL_RST,\n\t\t      SDCC_DLL_CONFIG_DLL_RST, SDCC_HC_REG_DLL_CONFIG);\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_PDN,\n\t\t      SDCC_DLL_CONFIG_PDN, SDCC_HC_REG_DLL_CONFIG);\n\n\tif (ethqos->has_emac_ge_3) {\n\t\tif (ethqos->speed == SPEED_1000) {\n\t\t\trgmii_writel(ethqos, 0x1800000, SDCC_TEST_CTL);\n\t\t\trgmii_writel(ethqos, 0x2C010800, SDCC_USR_CTL);\n\t\t\trgmii_writel(ethqos, 0xA001, SDCC_HC_REG_DLL_CONFIG2);\n\t\t} else {\n\t\t\trgmii_writel(ethqos, 0x40010800, SDCC_USR_CTL);\n\t\t\trgmii_writel(ethqos, 0xA001, SDCC_HC_REG_DLL_CONFIG2);\n\t\t}\n\t}\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_DLL_RST, 0,\n\t\t      SDCC_HC_REG_DLL_CONFIG);\n\n\t \n\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_PDN, 0,\n\t\t      SDCC_HC_REG_DLL_CONFIG);\n\n\tif (ethqos->speed != SPEED_100 && ethqos->speed != SPEED_10) {\n\t\t \n\t\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_DLL_EN,\n\t\t\t      SDCC_DLL_CONFIG_DLL_EN, SDCC_HC_REG_DLL_CONFIG);\n\n\t\t \n\t\trgmii_updatel(ethqos, SDCC_DLL_CONFIG_CK_OUT_EN,\n\t\t\t      SDCC_DLL_CONFIG_CK_OUT_EN,\n\t\t\t      SDCC_HC_REG_DLL_CONFIG);\n\n\t\t \n\t\tif (!ethqos->has_emac_ge_3)\n\t\t\trgmii_updatel(ethqos, GENMASK(26, 24), BIT(26),\n\t\t\t\t      SDCC_USR_CTL);\n\n\t\t \n\t\tdo {\n\t\t\tmdelay(1);\n\t\t\tdll_lock = rgmii_readl(ethqos, SDC4_STATUS);\n\t\t\tif (dll_lock & SDC4_STATUS_DLL_LOCK)\n\t\t\t\tbreak;\n\t\t\tretry--;\n\t\t} while (retry > 0);\n\t\tif (!retry)\n\t\t\tdev_err(dev, \"Timeout while waiting for DLL lock\\n\");\n\t}\n\n\tif (ethqos->speed == SPEED_1000)\n\t\tethqos_dll_configure(ethqos);\n\n\tethqos_rgmii_macro_init(ethqos);\n\n\treturn 0;\n}\n\n \nstatic int ethqos_configure_sgmii(struct qcom_ethqos *ethqos)\n{\n\tint val;\n\n\tval = readl(ethqos->mac_base + MAC_CTRL_REG);\n\n\tswitch (ethqos->speed) {\n\tcase SPEED_1000:\n\t\tval &= ~ETHQOS_MAC_CTRL_PORT_SEL;\n\t\trgmii_updatel(ethqos, RGMII_CONFIG2_RGMII_CLK_SEL_CFG,\n\t\t\t      RGMII_CONFIG2_RGMII_CLK_SEL_CFG,\n\t\t\t      RGMII_IO_MACRO_CONFIG2);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tval |= ETHQOS_MAC_CTRL_PORT_SEL | ETHQOS_MAC_CTRL_SPEED_MODE;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tval |= ETHQOS_MAC_CTRL_PORT_SEL;\n\t\tval &= ~ETHQOS_MAC_CTRL_SPEED_MODE;\n\t\trgmii_updatel(ethqos, RGMII_CONFIG_SGMII_CLK_DVDR,\n\t\t\t      FIELD_PREP(RGMII_CONFIG_SGMII_CLK_DVDR,\n\t\t\t\t\t SGMII_10M_RX_CLK_DVDR),\n\t\t\t      RGMII_IO_MACRO_CONFIG);\n\t\tbreak;\n\t}\n\n\twritel(val, ethqos->mac_base + MAC_CTRL_REG);\n\n\treturn val;\n}\n\nstatic int ethqos_configure(struct qcom_ethqos *ethqos)\n{\n\treturn ethqos->configure_func(ethqos);\n}\n\nstatic void ethqos_fix_mac_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct qcom_ethqos *ethqos = priv;\n\n\tethqos->speed = speed;\n\tethqos_update_link_clk(ethqos, speed);\n\tethqos_configure(ethqos);\n}\n\nstatic int qcom_ethqos_serdes_powerup(struct net_device *ndev, void *priv)\n{\n\tstruct qcom_ethqos *ethqos = priv;\n\tint ret;\n\n\tret = phy_init(ethqos->serdes_phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_power_on(ethqos->serdes_phy);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_set_speed(ethqos->serdes_phy, ethqos->speed);\n}\n\nstatic void qcom_ethqos_serdes_powerdown(struct net_device *ndev, void *priv)\n{\n\tstruct qcom_ethqos *ethqos = priv;\n\n\tphy_power_off(ethqos->serdes_phy);\n\tphy_exit(ethqos->serdes_phy);\n}\n\nstatic int ethqos_clks_config(void *priv, bool enabled)\n{\n\tstruct qcom_ethqos *ethqos = priv;\n\tint ret = 0;\n\n\tif (enabled) {\n\t\tret = clk_prepare_enable(ethqos->link_clk);\n\t\tif (ret) {\n\t\t\tdev_err(&ethqos->pdev->dev, \"link_clk enable failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tethqos_set_func_clk_en(ethqos);\n\t} else {\n\t\tclk_disable_unprepare(ethqos->link_clk);\n\t}\n\n\treturn ret;\n}\n\nstatic void ethqos_clks_disable(void *data)\n{\n\tethqos_clks_config(data, false);\n}\n\nstatic void ethqos_ptp_clk_freq_config(struct stmmac_priv *priv)\n{\n\tstruct plat_stmmacenet_data *plat_dat = priv->plat;\n\tint err;\n\n\tif (!plat_dat->clk_ptp_ref)\n\t\treturn;\n\n\t \n\terr = clk_set_rate(plat_dat->clk_ptp_ref, ULONG_MAX);\n\tif (err)\n\t\tnetdev_err(priv->dev, \"Failed to max out clk_ptp_ref: %d\\n\", err);\n\tplat_dat->clk_ptp_rate = clk_get_rate(plat_dat->clk_ptp_ref);\n\n\tnetdev_dbg(priv->dev, \"PTP rate %d\\n\", plat_dat->clk_ptp_rate);\n}\n\nstatic int qcom_ethqos_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct ethqos_emac_driver_data *data;\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_ethqos *ethqos;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to get platform resources\\n\");\n\n\tplat_dat = devm_stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(plat_dat),\n\t\t\t\t     \"dt configuration failed\\n\");\n\t}\n\n\tplat_dat->clks_config = ethqos_clks_config;\n\n\tethqos = devm_kzalloc(dev, sizeof(*ethqos), GFP_KERNEL);\n\tif (!ethqos)\n\t\treturn -ENOMEM;\n\n\tret = of_get_phy_mode(np, &ethqos->phy_mode);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get phy mode\\n\");\n\tswitch (ethqos->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tethqos->configure_func = ethqos_configure_rgmii;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tethqos->configure_func = ethqos_configure_sgmii;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported phy mode %s\\n\",\n\t\t\tphy_modes(ethqos->phy_mode));\n\t\treturn -EINVAL;\n\t}\n\n\tethqos->pdev = pdev;\n\tethqos->rgmii_base = devm_platform_ioremap_resource_byname(pdev, \"rgmii\");\n\tif (IS_ERR(ethqos->rgmii_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(ethqos->rgmii_base),\n\t\t\t\t     \"Failed to map rgmii resource\\n\");\n\n\tethqos->mac_base = stmmac_res.addr;\n\n\tdata = of_device_get_match_data(dev);\n\tethqos->por = data->por;\n\tethqos->num_por = data->num_por;\n\tethqos->rgmii_config_loopback_en = data->rgmii_config_loopback_en;\n\tethqos->has_emac_ge_3 = data->has_emac_ge_3;\n\n\tethqos->link_clk = devm_clk_get(dev, data->link_clk_name ?: \"rgmii\");\n\tif (IS_ERR(ethqos->link_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ethqos->link_clk),\n\t\t\t\t     \"Failed to get link_clk\\n\");\n\n\tret = ethqos_clks_config(ethqos, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, ethqos_clks_disable, ethqos);\n\tif (ret)\n\t\treturn ret;\n\n\tethqos->serdes_phy = devm_phy_optional_get(dev, \"serdes\");\n\tif (IS_ERR(ethqos->serdes_phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(ethqos->serdes_phy),\n\t\t\t\t     \"Failed to get serdes phy\\n\");\n\n\tethqos->speed = SPEED_1000;\n\tethqos_update_link_clk(ethqos, SPEED_1000);\n\tethqos_set_func_clk_en(ethqos);\n\n\tplat_dat->bsp_priv = ethqos;\n\tplat_dat->fix_mac_speed = ethqos_fix_mac_speed;\n\tplat_dat->dump_debug_regs = rgmii_dump;\n\tplat_dat->ptp_clk_freq_config = ethqos_ptp_clk_freq_config;\n\tplat_dat->has_gmac4 = 1;\n\tif (ethqos->has_emac_ge_3)\n\t\tplat_dat->dwmac4_addrs = &data->dwmac4_addrs;\n\tplat_dat->pmt = 1;\n\tif (of_property_read_bool(np, \"snps,tso\"))\n\t\tplat_dat->flags |= STMMAC_FLAG_TSO_EN;\n\tif (of_device_is_compatible(np, \"qcom,qcs404-ethqos\"))\n\t\tplat_dat->flags |= STMMAC_FLAG_RX_CLK_RUNS_IN_LPI;\n\tif (data->has_integrated_pcs)\n\t\tplat_dat->flags |= STMMAC_FLAG_HAS_INTEGRATED_PCS;\n\n\tif (ethqos->serdes_phy) {\n\t\tplat_dat->serdes_powerup = qcom_ethqos_serdes_powerup;\n\t\tplat_dat->serdes_powerdown  = qcom_ethqos_serdes_powerdown;\n\t}\n\n\treturn devm_stmmac_pltfr_probe(pdev, plat_dat, &stmmac_res);\n}\n\nstatic const struct of_device_id qcom_ethqos_match[] = {\n\t{ .compatible = \"qcom,qcs404-ethqos\", .data = &emac_v2_3_0_data},\n\t{ .compatible = \"qcom,sa8775p-ethqos\", .data = &emac_v4_0_0_data},\n\t{ .compatible = \"qcom,sc8280xp-ethqos\", .data = &emac_v3_0_0_data},\n\t{ .compatible = \"qcom,sm8150-ethqos\", .data = &emac_v2_1_0_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_ethqos_match);\n\nstatic struct platform_driver qcom_ethqos_driver = {\n\t.probe  = qcom_ethqos_probe,\n\t.driver = {\n\t\t.name           = \"qcom-ethqos\",\n\t\t.pm\t\t= &stmmac_pltfr_pm_ops,\n\t\t.of_match_table = qcom_ethqos_match,\n\t},\n};\nmodule_platform_driver(qcom_ethqos_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm ETHQOS driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}