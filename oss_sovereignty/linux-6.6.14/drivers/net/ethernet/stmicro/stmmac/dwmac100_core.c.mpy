{
  "module_name": "dwmac100_core.c",
  "hash_id": "6e90eef210f6dc3c94118371e325568cbcb9cc45824b681b628aa8188bcff852",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <asm/io.h>\n#include \"stmmac.h\"\n#include \"dwmac100.h\"\n\nstatic void dwmac100_core_init(struct mac_device_info *hw,\n\t\t\t       struct net_device *dev)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + MAC_CONTROL);\n\n\tvalue |= MAC_CORE_INIT;\n\n\twritel(value, ioaddr + MAC_CONTROL);\n\n#ifdef STMMAC_VLAN_TAG_USED\n\twritel(ETH_P_8021Q, ioaddr + MAC_VLAN1);\n#endif\n}\n\nstatic void dwmac100_dump_mac_regs(struct mac_device_info *hw, u32 *reg_space)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\n\treg_space[MAC_CONTROL / 4] = readl(ioaddr + MAC_CONTROL);\n\treg_space[MAC_ADDR_HIGH / 4] = readl(ioaddr + MAC_ADDR_HIGH);\n\treg_space[MAC_ADDR_LOW / 4] = readl(ioaddr + MAC_ADDR_LOW);\n\treg_space[MAC_HASH_HIGH / 4] = readl(ioaddr + MAC_HASH_HIGH);\n\treg_space[MAC_HASH_LOW / 4] = readl(ioaddr + MAC_HASH_LOW);\n\treg_space[MAC_FLOW_CTRL / 4] = readl(ioaddr + MAC_FLOW_CTRL);\n\treg_space[MAC_VLAN1 / 4] = readl(ioaddr + MAC_VLAN1);\n\treg_space[MAC_VLAN2 / 4] = readl(ioaddr + MAC_VLAN2);\n}\n\nstatic int dwmac100_rx_ipc_enable(struct mac_device_info *hw)\n{\n\treturn 0;\n}\n\nstatic int dwmac100_irq_status(struct mac_device_info *hw,\n\t\t\t       struct stmmac_extra_stats *x)\n{\n\treturn 0;\n}\n\nstatic void dwmac100_set_umac_addr(struct mac_device_info *hw,\n\t\t\t\t   const unsigned char *addr,\n\t\t\t\t   unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tstmmac_set_mac_addr(ioaddr, addr, MAC_ADDR_HIGH, MAC_ADDR_LOW);\n}\n\nstatic void dwmac100_get_umac_addr(struct mac_device_info *hw,\n\t\t\t\t   unsigned char *addr,\n\t\t\t\t   unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tstmmac_get_mac_addr(ioaddr, addr, MAC_ADDR_HIGH, MAC_ADDR_LOW);\n}\n\nstatic void dwmac100_set_filter(struct mac_device_info *hw,\n\t\t\t\tstruct net_device *dev)\n{\n\tvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\n\tu32 value = readl(ioaddr + MAC_CONTROL);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tvalue |= MAC_CONTROL_PR;\n\t\tvalue &= ~(MAC_CONTROL_PM | MAC_CONTROL_IF | MAC_CONTROL_HO |\n\t\t\t   MAC_CONTROL_HP);\n\t} else if ((netdev_mc_count(dev) > HASH_TABLE_SIZE)\n\t\t   || (dev->flags & IFF_ALLMULTI)) {\n\t\tvalue |= MAC_CONTROL_PM;\n\t\tvalue &= ~(MAC_CONTROL_PR | MAC_CONTROL_IF | MAC_CONTROL_HO);\n\t\twritel(0xffffffff, ioaddr + MAC_HASH_HIGH);\n\t\twritel(0xffffffff, ioaddr + MAC_HASH_LOW);\n\t} else if (netdev_mc_empty(dev)) {\t \n\t\tvalue &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF |\n\t\t\t   MAC_CONTROL_HO | MAC_CONTROL_HP);\n\t} else {\n\t\tu32 mc_filter[2];\n\t\tstruct netdev_hw_addr *ha;\n\n\t\t \n\t\tvalue |= MAC_CONTROL_HP;\n\t\tvalue &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR |\n\t\t\t   MAC_CONTROL_IF | MAC_CONTROL_HO);\n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t \n\t\t\tint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\t \n\t\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\n\t\t}\n\t\twritel(mc_filter[0], ioaddr + MAC_HASH_LOW);\n\t\twritel(mc_filter[1], ioaddr + MAC_HASH_HIGH);\n\t}\n\n\twritel(value, ioaddr + MAC_CONTROL);\n}\n\nstatic void dwmac100_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,\n\t\t\t       unsigned int fc, unsigned int pause_time,\n\t\t\t       u32 tx_cnt)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tunsigned int flow = MAC_FLOW_CTRL_ENABLE;\n\n\tif (duplex)\n\t\tflow |= (pause_time << MAC_FLOW_CTRL_PT_SHIFT);\n\twritel(flow, ioaddr + MAC_FLOW_CTRL);\n}\n\n \nstatic void dwmac100_pmt(struct mac_device_info *hw, unsigned long mode)\n{\n\treturn;\n}\n\nstatic void dwmac100_set_mac_loopback(void __iomem *ioaddr, bool enable)\n{\n\tu32 value = readl(ioaddr + MAC_CONTROL);\n\n\tif (enable)\n\t\tvalue |= MAC_CONTROL_OM;\n\telse\n\t\tvalue &= ~MAC_CONTROL_OM;\n\n\twritel(value, ioaddr + MAC_CONTROL);\n}\n\nconst struct stmmac_ops dwmac100_ops = {\n\t.core_init = dwmac100_core_init,\n\t.set_mac = stmmac_set_mac,\n\t.rx_ipc = dwmac100_rx_ipc_enable,\n\t.dump_regs = dwmac100_dump_mac_regs,\n\t.host_irq_status = dwmac100_irq_status,\n\t.set_filter = dwmac100_set_filter,\n\t.flow_ctrl = dwmac100_flow_ctrl,\n\t.pmt = dwmac100_pmt,\n\t.set_umac_addr = dwmac100_set_umac_addr,\n\t.get_umac_addr = dwmac100_get_umac_addr,\n\t.set_mac_loopback = dwmac100_set_mac_loopback,\n};\n\nint dwmac100_setup(struct stmmac_priv *priv)\n{\n\tstruct mac_device_info *mac = priv->hw;\n\n\tdev_info(priv->device, \"\\tDWMAC100\\n\");\n\n\tmac->pcsr = priv->ioaddr;\n\tmac->link.duplex = MAC_CONTROL_F;\n\tmac->link.speed10 = 0;\n\tmac->link.speed100 = 0;\n\tmac->link.speed1000 = 0;\n\tmac->link.speed_mask = MAC_CONTROL_PS;\n\tmac->mii.addr = MAC_MII_ADDR;\n\tmac->mii.data = MAC_MII_DATA;\n\tmac->mii.addr_shift = 11;\n\tmac->mii.addr_mask = 0x0000F800;\n\tmac->mii.reg_shift = 6;\n\tmac->mii.reg_mask = 0x000007C0;\n\tmac->mii.clk_csr_shift = 2;\n\tmac->mii.clk_csr_mask = GENMASK(5, 2);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}