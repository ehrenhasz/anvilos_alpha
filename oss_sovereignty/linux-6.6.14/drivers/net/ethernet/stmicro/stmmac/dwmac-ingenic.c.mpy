{
  "module_name": "dwmac-ingenic.c",
  "hash_id": "ac32e6afe07a4d6d30535fcd248e095efdd32174b8468b92d981580162a12b00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-ingenic.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac_platform.h\"\n\n#define MACPHYC_TXCLK_SEL_MASK\t\tGENMASK(31, 31)\n#define MACPHYC_TXCLK_SEL_OUTPUT\t0x1\n#define MACPHYC_TXCLK_SEL_INPUT\t\t0x0\n#define MACPHYC_MODE_SEL_MASK\t\tGENMASK(31, 31)\n#define MACPHYC_MODE_SEL_RMII\t\t0x0\n#define MACPHYC_TX_SEL_MASK\t\t\tGENMASK(19, 19)\n#define MACPHYC_TX_SEL_ORIGIN\t\t0x0\n#define MACPHYC_TX_SEL_DELAY\t\t0x1\n#define MACPHYC_TX_DELAY_MASK\t\tGENMASK(18, 12)\n#define MACPHYC_RX_SEL_MASK\t\t\tGENMASK(11, 11)\n#define MACPHYC_RX_SEL_ORIGIN\t\t0x0\n#define MACPHYC_RX_SEL_DELAY\t\t0x1\n#define MACPHYC_RX_DELAY_MASK\t\tGENMASK(10, 4)\n#define MACPHYC_SOFT_RST_MASK\t\tGENMASK(3, 3)\n#define MACPHYC_PHY_INFT_MASK\t\tGENMASK(2, 0)\n#define MACPHYC_PHY_INFT_RMII\t\t0x4\n#define MACPHYC_PHY_INFT_RGMII\t\t0x1\n#define MACPHYC_PHY_INFT_GMII\t\t0x0\n#define MACPHYC_PHY_INFT_MII\t\t0x0\n\n#define MACPHYC_TX_DELAY_PS_MAX\t\t2496\n#define MACPHYC_TX_DELAY_PS_MIN\t\t20\n\n#define MACPHYC_RX_DELAY_PS_MAX\t\t2496\n#define MACPHYC_RX_DELAY_PS_MIN\t\t20\n\nenum ingenic_mac_version {\n\tID_JZ4775,\n\tID_X1000,\n\tID_X1600,\n\tID_X1830,\n\tID_X2000,\n};\n\nstruct ingenic_mac {\n\tconst struct ingenic_soc_info *soc_info;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\n\tint rx_delay;\n\tint tx_delay;\n};\n\nstruct ingenic_soc_info {\n\tenum ingenic_mac_version version;\n\tu32 mask;\n\n\tint (*set_mode)(struct plat_stmmacenet_data *plat_dat);\n};\n\nstatic int ingenic_mac_init(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct ingenic_mac *mac = plat_dat->bsp_priv;\n\tint ret;\n\n\tif (mac->soc_info->set_mode) {\n\t\tret = mac->soc_info->set_mode(plat_dat);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int jz4775_mac_set_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct ingenic_mac *mac = plat_dat->bsp_priv;\n\tunsigned int val;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tval = FIELD_PREP(MACPHYC_TXCLK_SEL_MASK, MACPHYC_TXCLK_SEL_INPUT) |\n\t\t\t  FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_MII);\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_MII\\n\");\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tval = FIELD_PREP(MACPHYC_TXCLK_SEL_MASK, MACPHYC_TXCLK_SEL_INPUT) |\n\t\t\t  FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_GMII);\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_GMII\\n\");\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = FIELD_PREP(MACPHYC_TXCLK_SEL_MASK, MACPHYC_TXCLK_SEL_INPUT) |\n\t\t\t  FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_RMII);\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_RMII\\n\");\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tval = FIELD_PREP(MACPHYC_TXCLK_SEL_MASK, MACPHYC_TXCLK_SEL_INPUT) |\n\t\t\t  FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_RGMII);\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_RGMII\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mac->dev, \"Unsupported interface %d\", plat_dat->mac_interface);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn regmap_update_bits(mac->regmap, 0, mac->soc_info->mask, val);\n}\n\nstatic int x1000_mac_set_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct ingenic_mac *mac = plat_dat->bsp_priv;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_RMII\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mac->dev, \"Unsupported interface %d\", plat_dat->mac_interface);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn regmap_update_bits(mac->regmap, 0, mac->soc_info->mask, 0);\n}\n\nstatic int x1600_mac_set_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct ingenic_mac *mac = plat_dat->bsp_priv;\n\tunsigned int val;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_RMII);\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_RMII\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mac->dev, \"Unsupported interface %d\", plat_dat->mac_interface);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn regmap_update_bits(mac->regmap, 0, mac->soc_info->mask, val);\n}\n\nstatic int x1830_mac_set_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct ingenic_mac *mac = plat_dat->bsp_priv;\n\tunsigned int val;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = FIELD_PREP(MACPHYC_MODE_SEL_MASK, MACPHYC_MODE_SEL_RMII) |\n\t\t\t  FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_RMII);\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_RMII\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mac->dev, \"Unsupported interface %d\", plat_dat->mac_interface);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn regmap_update_bits(mac->regmap, 0, mac->soc_info->mask, val);\n}\n\nstatic int x2000_mac_set_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct ingenic_mac *mac = plat_dat->bsp_priv;\n\tunsigned int val;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = FIELD_PREP(MACPHYC_TX_SEL_MASK, MACPHYC_TX_SEL_ORIGIN) |\n\t\t\t  FIELD_PREP(MACPHYC_RX_SEL_MASK, MACPHYC_RX_SEL_ORIGIN) |\n\t\t\t  FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_RMII);\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_RMII\\n\");\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tval = FIELD_PREP(MACPHYC_PHY_INFT_MASK, MACPHYC_PHY_INFT_RGMII);\n\n\t\tif (mac->tx_delay == 0)\n\t\t\tval |= FIELD_PREP(MACPHYC_TX_SEL_MASK, MACPHYC_TX_SEL_ORIGIN);\n\t\telse\n\t\t\tval |= FIELD_PREP(MACPHYC_TX_SEL_MASK, MACPHYC_TX_SEL_DELAY) |\n\t\t\t\t   FIELD_PREP(MACPHYC_TX_DELAY_MASK, (mac->tx_delay + 9750) / 19500 - 1);\n\n\t\tif (mac->rx_delay == 0)\n\t\t\tval |= FIELD_PREP(MACPHYC_RX_SEL_MASK, MACPHYC_RX_SEL_ORIGIN);\n\t\telse\n\t\t\tval |= FIELD_PREP(MACPHYC_RX_SEL_MASK, MACPHYC_RX_SEL_DELAY) |\n\t\t\t\t   FIELD_PREP(MACPHYC_RX_DELAY_MASK, (mac->rx_delay + 9750) / 19500 - 1);\n\n\t\tdev_dbg(mac->dev, \"MAC PHY Control Register: PHY_INTERFACE_MODE_RGMII\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mac->dev, \"Unsupported interface %d\", plat_dat->mac_interface);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn regmap_update_bits(mac->regmap, 0, mac->soc_info->mask, val);\n}\n\nstatic int ingenic_mac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct ingenic_mac *mac;\n\tconst struct ingenic_soc_info *data;\n\tu32 tx_delay_ps, rx_delay_ps;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tmac = devm_kzalloc(&pdev->dev, sizeof(*mac), GFP_KERNEL);\n\tif (!mac) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"No of match data provided\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\t \n\tmac->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, \"mode-reg\");\n\tif (IS_ERR(mac->regmap)) {\n\t\tdev_err(&pdev->dev, \"%s: Failed to get syscon regmap\\n\", __func__);\n\t\tret = PTR_ERR(mac->regmap);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tif (!of_property_read_u32(pdev->dev.of_node, \"tx-clk-delay-ps\", &tx_delay_ps)) {\n\t\tif (tx_delay_ps >= MACPHYC_TX_DELAY_PS_MIN &&\n\t\t\ttx_delay_ps <= MACPHYC_TX_DELAY_PS_MAX) {\n\t\t\tmac->tx_delay = tx_delay_ps * 1000;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"Invalid TX clock delay: %dps\\n\", tx_delay_ps);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_remove_config_dt;\n\t\t}\n\t}\n\n\tif (!of_property_read_u32(pdev->dev.of_node, \"rx-clk-delay-ps\", &rx_delay_ps)) {\n\t\tif (rx_delay_ps >= MACPHYC_RX_DELAY_PS_MIN &&\n\t\t\trx_delay_ps <= MACPHYC_RX_DELAY_PS_MAX) {\n\t\t\tmac->rx_delay = rx_delay_ps * 1000;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"Invalid RX clock delay: %dps\\n\", rx_delay_ps);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_remove_config_dt;\n\t\t}\n\t}\n\n\tmac->soc_info = data;\n\tmac->dev = &pdev->dev;\n\n\tplat_dat->bsp_priv = mac;\n\n\tret = ingenic_mac_init(plat_dat);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\treturn 0;\n\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ingenic_mac_suspend(struct device *dev)\n{\n\tint ret;\n\n\tret = stmmac_suspend(dev);\n\n\treturn ret;\n}\n\nstatic int ingenic_mac_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = ingenic_mac_init(priv->plat);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stmmac_resume(dev);\n\n\treturn ret;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(ingenic_mac_pm_ops, ingenic_mac_suspend, ingenic_mac_resume);\n\nstatic struct ingenic_soc_info jz4775_soc_info = {\n\t.version = ID_JZ4775,\n\t.mask = MACPHYC_TXCLK_SEL_MASK | MACPHYC_SOFT_RST_MASK | MACPHYC_PHY_INFT_MASK,\n\n\t.set_mode = jz4775_mac_set_mode,\n};\n\nstatic struct ingenic_soc_info x1000_soc_info = {\n\t.version = ID_X1000,\n\t.mask = MACPHYC_SOFT_RST_MASK,\n\n\t.set_mode = x1000_mac_set_mode,\n};\n\nstatic struct ingenic_soc_info x1600_soc_info = {\n\t.version = ID_X1600,\n\t.mask = MACPHYC_SOFT_RST_MASK | MACPHYC_PHY_INFT_MASK,\n\n\t.set_mode = x1600_mac_set_mode,\n};\n\nstatic struct ingenic_soc_info x1830_soc_info = {\n\t.version = ID_X1830,\n\t.mask = MACPHYC_MODE_SEL_MASK | MACPHYC_SOFT_RST_MASK | MACPHYC_PHY_INFT_MASK,\n\n\t.set_mode = x1830_mac_set_mode,\n};\n\nstatic struct ingenic_soc_info x2000_soc_info = {\n\t.version = ID_X2000,\n\t.mask = MACPHYC_TX_SEL_MASK | MACPHYC_TX_DELAY_MASK | MACPHYC_RX_SEL_MASK |\n\t\t\tMACPHYC_RX_DELAY_MASK | MACPHYC_SOFT_RST_MASK | MACPHYC_PHY_INFT_MASK,\n\n\t.set_mode = x2000_mac_set_mode,\n};\n\nstatic const struct of_device_id ingenic_mac_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4775-mac\", .data = &jz4775_soc_info },\n\t{ .compatible = \"ingenic,x1000-mac\", .data = &x1000_soc_info },\n\t{ .compatible = \"ingenic,x1600-mac\", .data = &x1600_soc_info },\n\t{ .compatible = \"ingenic,x1830-mac\", .data = &x1830_soc_info },\n\t{ .compatible = \"ingenic,x2000-mac\", .data = &x2000_soc_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ingenic_mac_of_matches);\n\nstatic struct platform_driver ingenic_mac_driver = {\n\t.probe\t\t= ingenic_mac_probe,\n\t.remove_new\t= stmmac_pltfr_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"ingenic-mac\",\n\t\t.pm\t\t= pm_ptr(&ingenic_mac_pm_ops),\n\t\t.of_match_table = ingenic_mac_of_matches,\n\t},\n};\nmodule_platform_driver(ingenic_mac_driver);\n\nMODULE_AUTHOR(\"\u5468\u7430\u6770 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>\");\nMODULE_DESCRIPTION(\"Ingenic SoCs DWMAC specific glue layer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}